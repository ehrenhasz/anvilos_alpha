{
  "module_name": "cm.c",
  "hash_id": "0da8c5358bc54ce74c86356a6877a991043c8e0c71e57abb39323fdb553b7ee6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/core/cm.c",
  "human_readable_source": "\n \n\n#include <linux/completion.h>\n#include <linux/dma-mapping.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/idr.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/workqueue.h>\n#include <linux/kdev_t.h>\n#include <linux/etherdevice.h>\n\n#include <rdma/ib_cache.h>\n#include <rdma/ib_cm.h>\n#include <rdma/ib_sysfs.h>\n#include \"cm_msgs.h\"\n#include \"core_priv.h\"\n#include \"cm_trace.h\"\n\nMODULE_AUTHOR(\"Sean Hefty\");\nMODULE_DESCRIPTION(\"InfiniBand CM\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n\nstatic const char * const ibcm_rej_reason_strs[] = {\n\t[IB_CM_REJ_NO_QP]\t\t\t= \"no QP\",\n\t[IB_CM_REJ_NO_EEC]\t\t\t= \"no EEC\",\n\t[IB_CM_REJ_NO_RESOURCES]\t\t= \"no resources\",\n\t[IB_CM_REJ_TIMEOUT]\t\t\t= \"timeout\",\n\t[IB_CM_REJ_UNSUPPORTED]\t\t\t= \"unsupported\",\n\t[IB_CM_REJ_INVALID_COMM_ID]\t\t= \"invalid comm ID\",\n\t[IB_CM_REJ_INVALID_COMM_INSTANCE]\t= \"invalid comm instance\",\n\t[IB_CM_REJ_INVALID_SERVICE_ID]\t\t= \"invalid service ID\",\n\t[IB_CM_REJ_INVALID_TRANSPORT_TYPE]\t= \"invalid transport type\",\n\t[IB_CM_REJ_STALE_CONN]\t\t\t= \"stale conn\",\n\t[IB_CM_REJ_RDC_NOT_EXIST]\t\t= \"RDC not exist\",\n\t[IB_CM_REJ_INVALID_GID]\t\t\t= \"invalid GID\",\n\t[IB_CM_REJ_INVALID_LID]\t\t\t= \"invalid LID\",\n\t[IB_CM_REJ_INVALID_SL]\t\t\t= \"invalid SL\",\n\t[IB_CM_REJ_INVALID_TRAFFIC_CLASS]\t= \"invalid traffic class\",\n\t[IB_CM_REJ_INVALID_HOP_LIMIT]\t\t= \"invalid hop limit\",\n\t[IB_CM_REJ_INVALID_PACKET_RATE]\t\t= \"invalid packet rate\",\n\t[IB_CM_REJ_INVALID_ALT_GID]\t\t= \"invalid alt GID\",\n\t[IB_CM_REJ_INVALID_ALT_LID]\t\t= \"invalid alt LID\",\n\t[IB_CM_REJ_INVALID_ALT_SL]\t\t= \"invalid alt SL\",\n\t[IB_CM_REJ_INVALID_ALT_TRAFFIC_CLASS]\t= \"invalid alt traffic class\",\n\t[IB_CM_REJ_INVALID_ALT_HOP_LIMIT]\t= \"invalid alt hop limit\",\n\t[IB_CM_REJ_INVALID_ALT_PACKET_RATE]\t= \"invalid alt packet rate\",\n\t[IB_CM_REJ_PORT_CM_REDIRECT]\t\t= \"port CM redirect\",\n\t[IB_CM_REJ_PORT_REDIRECT]\t\t= \"port redirect\",\n\t[IB_CM_REJ_INVALID_MTU]\t\t\t= \"invalid MTU\",\n\t[IB_CM_REJ_INSUFFICIENT_RESP_RESOURCES]\t= \"insufficient resp resources\",\n\t[IB_CM_REJ_CONSUMER_DEFINED]\t\t= \"consumer defined\",\n\t[IB_CM_REJ_INVALID_RNR_RETRY]\t\t= \"invalid RNR retry\",\n\t[IB_CM_REJ_DUPLICATE_LOCAL_COMM_ID]\t= \"duplicate local comm ID\",\n\t[IB_CM_REJ_INVALID_CLASS_VERSION]\t= \"invalid class version\",\n\t[IB_CM_REJ_INVALID_FLOW_LABEL]\t\t= \"invalid flow label\",\n\t[IB_CM_REJ_INVALID_ALT_FLOW_LABEL]\t= \"invalid alt flow label\",\n\t[IB_CM_REJ_VENDOR_OPTION_NOT_SUPPORTED] =\n\t\t\"vendor option is not supported\",\n};\n\nconst char *__attribute_const__ ibcm_reject_msg(int reason)\n{\n\tsize_t index = reason;\n\n\tif (index < ARRAY_SIZE(ibcm_rej_reason_strs) &&\n\t    ibcm_rej_reason_strs[index])\n\t\treturn ibcm_rej_reason_strs[index];\n\telse\n\t\treturn \"unrecognized reason\";\n}\nEXPORT_SYMBOL(ibcm_reject_msg);\n\nstruct cm_id_private;\nstruct cm_work;\nstatic int cm_add_one(struct ib_device *device);\nstatic void cm_remove_one(struct ib_device *device, void *client_data);\nstatic void cm_process_work(struct cm_id_private *cm_id_priv,\n\t\t\t    struct cm_work *work);\nstatic int cm_send_sidr_rep_locked(struct cm_id_private *cm_id_priv,\n\t\t\t\t   struct ib_cm_sidr_rep_param *param);\nstatic int cm_send_dreq_locked(struct cm_id_private *cm_id_priv,\n\t\t\t       const void *private_data, u8 private_data_len);\nstatic int cm_send_drep_locked(struct cm_id_private *cm_id_priv,\n\t\t\t       void *private_data, u8 private_data_len);\nstatic int cm_send_rej_locked(struct cm_id_private *cm_id_priv,\n\t\t\t      enum ib_cm_rej_reason reason, void *ari,\n\t\t\t      u8 ari_length, const void *private_data,\n\t\t\t      u8 private_data_len);\n\nstatic struct ib_client cm_client = {\n\t.name   = \"cm\",\n\t.add    = cm_add_one,\n\t.remove = cm_remove_one\n};\n\nstatic struct ib_cm {\n\tspinlock_t lock;\n\tstruct list_head device_list;\n\trwlock_t device_lock;\n\tstruct rb_root listen_service_table;\n\tu64 listen_service_id;\n\t \n\tstruct rb_root remote_qp_table;\n\tstruct rb_root remote_id_table;\n\tstruct rb_root remote_sidr_table;\n\tstruct xarray local_id_table;\n\tu32 local_id_next;\n\t__be32 random_id_operand;\n\tstruct list_head timewait_list;\n\tstruct workqueue_struct *wq;\n} cm;\n\n \nenum {\n\tCM_REQ_COUNTER,\n\tCM_MRA_COUNTER,\n\tCM_REJ_COUNTER,\n\tCM_REP_COUNTER,\n\tCM_RTU_COUNTER,\n\tCM_DREQ_COUNTER,\n\tCM_DREP_COUNTER,\n\tCM_SIDR_REQ_COUNTER,\n\tCM_SIDR_REP_COUNTER,\n\tCM_LAP_COUNTER,\n\tCM_APR_COUNTER,\n\tCM_ATTR_COUNT,\n\tCM_ATTR_ID_OFFSET = 0x0010,\n};\n\nenum {\n\tCM_XMIT,\n\tCM_XMIT_RETRIES,\n\tCM_RECV,\n\tCM_RECV_DUPLICATES,\n\tCM_COUNTER_GROUPS\n};\n\nstruct cm_counter_attribute {\n\tstruct ib_port_attribute attr;\n\tunsigned short group;\n\tunsigned short index;\n};\n\nstruct cm_port {\n\tstruct cm_device *cm_dev;\n\tstruct ib_mad_agent *mad_agent;\n\tu32 port_num;\n\tatomic_long_t counters[CM_COUNTER_GROUPS][CM_ATTR_COUNT];\n};\n\nstruct cm_device {\n\tstruct kref kref;\n\tstruct list_head list;\n\tspinlock_t mad_agent_lock;\n\tstruct ib_device *ib_device;\n\tu8 ack_delay;\n\tint going_down;\n\tstruct cm_port *port[];\n};\n\nstruct cm_av {\n\tstruct cm_port *port;\n\tstruct rdma_ah_attr ah_attr;\n\tu16 dlid_datapath;\n\tu16 pkey_index;\n\tu8 timeout;\n};\n\nstruct cm_work {\n\tstruct delayed_work work;\n\tstruct list_head list;\n\tstruct cm_port *port;\n\tstruct ib_mad_recv_wc *mad_recv_wc;\t \n\t__be32 local_id;\t\t\t \n\t__be32 remote_id;\n\tstruct ib_cm_event cm_event;\n\tstruct sa_path_rec path[];\n};\n\nstruct cm_timewait_info {\n\tstruct cm_work work;\n\tstruct list_head list;\n\tstruct rb_node remote_qp_node;\n\tstruct rb_node remote_id_node;\n\t__be64 remote_ca_guid;\n\t__be32 remote_qpn;\n\tu8 inserted_remote_qp;\n\tu8 inserted_remote_id;\n};\n\nstruct cm_id_private {\n\tstruct ib_cm_id\tid;\n\n\tstruct rb_node service_node;\n\tstruct rb_node sidr_id_node;\n\tu32 sidr_slid;\n\tspinlock_t lock;\t \n\tstruct completion comp;\n\trefcount_t refcount;\n\t \n\tint listen_sharecount;\n\tstruct rcu_head rcu;\n\n\tstruct ib_mad_send_buf *msg;\n\tstruct cm_timewait_info *timewait_info;\n\t \n\tstruct cm_av av;\n\tstruct cm_av alt_av;\n\n\tvoid *private_data;\n\t__be64 tid;\n\t__be32 local_qpn;\n\t__be32 remote_qpn;\n\tenum ib_qp_type qp_type;\n\t__be32 sq_psn;\n\t__be32 rq_psn;\n\tint timeout_ms;\n\tenum ib_mtu path_mtu;\n\t__be16 pkey;\n\tu8 private_data_len;\n\tu8 max_cm_retries;\n\tu8 responder_resources;\n\tu8 initiator_depth;\n\tu8 retry_count;\n\tu8 rnr_retry_count;\n\tu8 service_timeout;\n\tu8 target_ack_delay;\n\n\tstruct list_head work_list;\n\tatomic_t work_count;\n\n\tstruct rdma_ucm_ece ece;\n};\n\nstatic void cm_dev_release(struct kref *kref)\n{\n\tstruct cm_device *cm_dev = container_of(kref, struct cm_device, kref);\n\tu32 i;\n\n\trdma_for_each_port(cm_dev->ib_device, i)\n\t\tkfree(cm_dev->port[i - 1]);\n\n\tkfree(cm_dev);\n}\n\nstatic void cm_device_put(struct cm_device *cm_dev)\n{\n\tkref_put(&cm_dev->kref, cm_dev_release);\n}\n\nstatic void cm_work_handler(struct work_struct *work);\n\nstatic inline void cm_deref_id(struct cm_id_private *cm_id_priv)\n{\n\tif (refcount_dec_and_test(&cm_id_priv->refcount))\n\t\tcomplete(&cm_id_priv->comp);\n}\n\nstatic struct ib_mad_send_buf *cm_alloc_msg(struct cm_id_private *cm_id_priv)\n{\n\tstruct ib_mad_agent *mad_agent;\n\tstruct ib_mad_send_buf *m;\n\tstruct ib_ah *ah;\n\n\tlockdep_assert_held(&cm_id_priv->lock);\n\n\tif (!cm_id_priv->av.port)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tspin_lock(&cm_id_priv->av.port->cm_dev->mad_agent_lock);\n\tmad_agent = cm_id_priv->av.port->mad_agent;\n\tif (!mad_agent) {\n\t\tm = ERR_PTR(-EINVAL);\n\t\tgoto out;\n\t}\n\n\tah = rdma_create_ah(mad_agent->qp->pd, &cm_id_priv->av.ah_attr, 0);\n\tif (IS_ERR(ah)) {\n\t\tm = ERR_CAST(ah);\n\t\tgoto out;\n\t}\n\n\tm = ib_create_send_mad(mad_agent, cm_id_priv->id.remote_cm_qpn,\n\t\t\t       cm_id_priv->av.pkey_index,\n\t\t\t       0, IB_MGMT_MAD_HDR, IB_MGMT_MAD_DATA,\n\t\t\t       GFP_ATOMIC,\n\t\t\t       IB_MGMT_BASE_VERSION);\n\tif (IS_ERR(m)) {\n\t\trdma_destroy_ah(ah, 0);\n\t\tgoto out;\n\t}\n\n\t \n\tm->ah = ah;\n\tm->retries = cm_id_priv->max_cm_retries;\n\n\trefcount_inc(&cm_id_priv->refcount);\n\tm->context[0] = cm_id_priv;\n\nout:\n\tspin_unlock(&cm_id_priv->av.port->cm_dev->mad_agent_lock);\n\treturn m;\n}\n\nstatic void cm_free_msg(struct ib_mad_send_buf *msg)\n{\n\tstruct cm_id_private *cm_id_priv = msg->context[0];\n\n\tif (msg->ah)\n\t\trdma_destroy_ah(msg->ah, 0);\n\tcm_deref_id(cm_id_priv);\n\tib_free_send_mad(msg);\n}\n\nstatic struct ib_mad_send_buf *\ncm_alloc_priv_msg(struct cm_id_private *cm_id_priv)\n{\n\tstruct ib_mad_send_buf *msg;\n\n\tlockdep_assert_held(&cm_id_priv->lock);\n\n\tmsg = cm_alloc_msg(cm_id_priv);\n\tif (IS_ERR(msg))\n\t\treturn msg;\n\tcm_id_priv->msg = msg;\n\treturn msg;\n}\n\nstatic void cm_free_priv_msg(struct ib_mad_send_buf *msg)\n{\n\tstruct cm_id_private *cm_id_priv = msg->context[0];\n\n\tlockdep_assert_held(&cm_id_priv->lock);\n\n\tif (!WARN_ON(cm_id_priv->msg != msg))\n\t\tcm_id_priv->msg = NULL;\n\n\tif (msg->ah)\n\t\trdma_destroy_ah(msg->ah, 0);\n\tcm_deref_id(cm_id_priv);\n\tib_free_send_mad(msg);\n}\n\nstatic struct ib_mad_send_buf *cm_alloc_response_msg_no_ah(struct cm_port *port,\n\t\t\t\t\t\t\t   struct ib_mad_recv_wc *mad_recv_wc)\n{\n\treturn ib_create_send_mad(port->mad_agent, 1, mad_recv_wc->wc->pkey_index,\n\t\t\t\t  0, IB_MGMT_MAD_HDR, IB_MGMT_MAD_DATA,\n\t\t\t\t  GFP_ATOMIC,\n\t\t\t\t  IB_MGMT_BASE_VERSION);\n}\n\nstatic int cm_create_response_msg_ah(struct cm_port *port,\n\t\t\t\t     struct ib_mad_recv_wc *mad_recv_wc,\n\t\t\t\t     struct ib_mad_send_buf *msg)\n{\n\tstruct ib_ah *ah;\n\n\tah = ib_create_ah_from_wc(port->mad_agent->qp->pd, mad_recv_wc->wc,\n\t\t\t\t  mad_recv_wc->recv_buf.grh, port->port_num);\n\tif (IS_ERR(ah))\n\t\treturn PTR_ERR(ah);\n\n\tmsg->ah = ah;\n\treturn 0;\n}\n\nstatic int cm_alloc_response_msg(struct cm_port *port,\n\t\t\t\t struct ib_mad_recv_wc *mad_recv_wc,\n\t\t\t\t struct ib_mad_send_buf **msg)\n{\n\tstruct ib_mad_send_buf *m;\n\tint ret;\n\n\tm = cm_alloc_response_msg_no_ah(port, mad_recv_wc);\n\tif (IS_ERR(m))\n\t\treturn PTR_ERR(m);\n\n\tret = cm_create_response_msg_ah(port, mad_recv_wc, m);\n\tif (ret) {\n\t\tib_free_send_mad(m);\n\t\treturn ret;\n\t}\n\n\t*msg = m;\n\treturn 0;\n}\n\nstatic void cm_free_response_msg(struct ib_mad_send_buf *msg)\n{\n\tif (msg->ah)\n\t\trdma_destroy_ah(msg->ah, 0);\n\tib_free_send_mad(msg);\n}\n\nstatic void *cm_copy_private_data(const void *private_data, u8 private_data_len)\n{\n\tvoid *data;\n\n\tif (!private_data || !private_data_len)\n\t\treturn NULL;\n\n\tdata = kmemdup(private_data, private_data_len, GFP_KERNEL);\n\tif (!data)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\treturn data;\n}\n\nstatic void cm_set_private_data(struct cm_id_private *cm_id_priv,\n\t\t\t\t void *private_data, u8 private_data_len)\n{\n\tif (cm_id_priv->private_data && cm_id_priv->private_data_len)\n\t\tkfree(cm_id_priv->private_data);\n\n\tcm_id_priv->private_data = private_data;\n\tcm_id_priv->private_data_len = private_data_len;\n}\n\nstatic void cm_set_av_port(struct cm_av *av, struct cm_port *port)\n{\n\tstruct cm_port *old_port = av->port;\n\n\tif (old_port == port)\n\t\treturn;\n\n\tav->port = port;\n\tif (old_port)\n\t\tcm_device_put(old_port->cm_dev);\n\tif (port)\n\t\tkref_get(&port->cm_dev->kref);\n}\n\nstatic void cm_init_av_for_lap(struct cm_port *port, struct ib_wc *wc,\n\t\t\t       struct rdma_ah_attr *ah_attr, struct cm_av *av)\n{\n\tcm_set_av_port(av, port);\n\tav->pkey_index = wc->pkey_index;\n\trdma_move_ah_attr(&av->ah_attr, ah_attr);\n}\n\nstatic int cm_init_av_for_response(struct cm_port *port, struct ib_wc *wc,\n\t\t\t\t   struct ib_grh *grh, struct cm_av *av)\n{\n\tcm_set_av_port(av, port);\n\tav->pkey_index = wc->pkey_index;\n\treturn ib_init_ah_attr_from_wc(port->cm_dev->ib_device,\n\t\t\t\t       port->port_num, wc,\n\t\t\t\t       grh, &av->ah_attr);\n}\n\nstatic struct cm_port *\nget_cm_port_from_path(struct sa_path_rec *path, const struct ib_gid_attr *attr)\n{\n\tstruct cm_device *cm_dev;\n\tstruct cm_port *port = NULL;\n\tunsigned long flags;\n\n\tif (attr) {\n\t\tread_lock_irqsave(&cm.device_lock, flags);\n\t\tlist_for_each_entry(cm_dev, &cm.device_list, list) {\n\t\t\tif (cm_dev->ib_device == attr->device) {\n\t\t\t\tport = cm_dev->port[attr->port_num - 1];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tread_unlock_irqrestore(&cm.device_lock, flags);\n\t} else {\n\t\t \n\t\tread_lock_irqsave(&cm.device_lock, flags);\n\t\tlist_for_each_entry(cm_dev, &cm.device_list, list) {\n\t\t\tattr = rdma_find_gid(cm_dev->ib_device,\n\t\t\t\t\t     &path->sgid,\n\t\t\t\t\t     sa_conv_pathrec_to_gid_type(path),\n\t\t\t\t\t     NULL);\n\t\t\tif (!IS_ERR(attr)) {\n\t\t\t\tport = cm_dev->port[attr->port_num - 1];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tread_unlock_irqrestore(&cm.device_lock, flags);\n\t\tif (port)\n\t\t\trdma_put_gid_attr(attr);\n\t}\n\treturn port;\n}\n\nstatic int cm_init_av_by_path(struct sa_path_rec *path,\n\t\t\t      const struct ib_gid_attr *sgid_attr,\n\t\t\t      struct cm_av *av)\n{\n\tstruct rdma_ah_attr new_ah_attr;\n\tstruct cm_device *cm_dev;\n\tstruct cm_port *port;\n\tint ret;\n\n\tport = get_cm_port_from_path(path, sgid_attr);\n\tif (!port)\n\t\treturn -EINVAL;\n\tcm_dev = port->cm_dev;\n\n\tret = ib_find_cached_pkey(cm_dev->ib_device, port->port_num,\n\t\t\t\t  be16_to_cpu(path->pkey), &av->pkey_index);\n\tif (ret)\n\t\treturn ret;\n\n\tcm_set_av_port(av, port);\n\n\t \n\tret = ib_init_ah_attr_from_path(cm_dev->ib_device, port->port_num, path,\n\t\t\t\t\t&new_ah_attr, sgid_attr);\n\tif (ret)\n\t\treturn ret;\n\n\tav->timeout = path->packet_life_time + 1;\n\trdma_move_ah_attr(&av->ah_attr, &new_ah_attr);\n\treturn 0;\n}\n\n \nstatic void cm_move_av_from_path(struct cm_av *dest, struct cm_av *src)\n{\n\tcm_set_av_port(dest, src->port);\n\tcm_set_av_port(src, NULL);\n\tdest->pkey_index = src->pkey_index;\n\trdma_move_ah_attr(&dest->ah_attr, &src->ah_attr);\n\tdest->timeout = src->timeout;\n}\n\nstatic void cm_destroy_av(struct cm_av *av)\n{\n\trdma_destroy_ah_attr(&av->ah_attr);\n\tcm_set_av_port(av, NULL);\n}\n\nstatic u32 cm_local_id(__be32 local_id)\n{\n\treturn (__force u32) (local_id ^ cm.random_id_operand);\n}\n\nstatic struct cm_id_private *cm_acquire_id(__be32 local_id, __be32 remote_id)\n{\n\tstruct cm_id_private *cm_id_priv;\n\n\trcu_read_lock();\n\tcm_id_priv = xa_load(&cm.local_id_table, cm_local_id(local_id));\n\tif (!cm_id_priv || cm_id_priv->id.remote_id != remote_id ||\n\t    !refcount_inc_not_zero(&cm_id_priv->refcount))\n\t\tcm_id_priv = NULL;\n\trcu_read_unlock();\n\n\treturn cm_id_priv;\n}\n\n \nstatic int be32_lt(__be32 a, __be32 b)\n{\n\treturn (__force u32) a < (__force u32) b;\n}\n\nstatic int be32_gt(__be32 a, __be32 b)\n{\n\treturn (__force u32) a > (__force u32) b;\n}\n\nstatic int be64_lt(__be64 a, __be64 b)\n{\n\treturn (__force u64) a < (__force u64) b;\n}\n\nstatic int be64_gt(__be64 a, __be64 b)\n{\n\treturn (__force u64) a > (__force u64) b;\n}\n\n \nstatic struct cm_id_private *cm_insert_listen(struct cm_id_private *cm_id_priv,\n\t\t\t\t\t      ib_cm_handler shared_handler)\n{\n\tstruct rb_node **link = &cm.listen_service_table.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct cm_id_private *cur_cm_id_priv;\n\t__be64 service_id = cm_id_priv->id.service_id;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cm.lock, flags);\n\twhile (*link) {\n\t\tparent = *link;\n\t\tcur_cm_id_priv = rb_entry(parent, struct cm_id_private,\n\t\t\t\t\t  service_node);\n\n\t\tif (cm_id_priv->id.device < cur_cm_id_priv->id.device)\n\t\t\tlink = &(*link)->rb_left;\n\t\telse if (cm_id_priv->id.device > cur_cm_id_priv->id.device)\n\t\t\tlink = &(*link)->rb_right;\n\t\telse if (be64_lt(service_id, cur_cm_id_priv->id.service_id))\n\t\t\tlink = &(*link)->rb_left;\n\t\telse if (be64_gt(service_id, cur_cm_id_priv->id.service_id))\n\t\t\tlink = &(*link)->rb_right;\n\t\telse {\n\t\t\t \n\t\t\tif (cur_cm_id_priv->id.cm_handler != shared_handler ||\n\t\t\t    cur_cm_id_priv->id.context ||\n\t\t\t    WARN_ON(!cur_cm_id_priv->id.cm_handler)) {\n\t\t\t\tspin_unlock_irqrestore(&cm.lock, flags);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\trefcount_inc(&cur_cm_id_priv->refcount);\n\t\t\tcur_cm_id_priv->listen_sharecount++;\n\t\t\tspin_unlock_irqrestore(&cm.lock, flags);\n\t\t\treturn cur_cm_id_priv;\n\t\t}\n\t}\n\tcm_id_priv->listen_sharecount++;\n\trb_link_node(&cm_id_priv->service_node, parent, link);\n\trb_insert_color(&cm_id_priv->service_node, &cm.listen_service_table);\n\tspin_unlock_irqrestore(&cm.lock, flags);\n\treturn cm_id_priv;\n}\n\nstatic struct cm_id_private *cm_find_listen(struct ib_device *device,\n\t\t\t\t\t    __be64 service_id)\n{\n\tstruct rb_node *node = cm.listen_service_table.rb_node;\n\tstruct cm_id_private *cm_id_priv;\n\n\twhile (node) {\n\t\tcm_id_priv = rb_entry(node, struct cm_id_private, service_node);\n\n\t\tif (device < cm_id_priv->id.device)\n\t\t\tnode = node->rb_left;\n\t\telse if (device > cm_id_priv->id.device)\n\t\t\tnode = node->rb_right;\n\t\telse if (be64_lt(service_id, cm_id_priv->id.service_id))\n\t\t\tnode = node->rb_left;\n\t\telse if (be64_gt(service_id, cm_id_priv->id.service_id))\n\t\t\tnode = node->rb_right;\n\t\telse {\n\t\t\trefcount_inc(&cm_id_priv->refcount);\n\t\t\treturn cm_id_priv;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic struct cm_timewait_info *\ncm_insert_remote_id(struct cm_timewait_info *timewait_info)\n{\n\tstruct rb_node **link = &cm.remote_id_table.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct cm_timewait_info *cur_timewait_info;\n\t__be64 remote_ca_guid = timewait_info->remote_ca_guid;\n\t__be32 remote_id = timewait_info->work.remote_id;\n\n\twhile (*link) {\n\t\tparent = *link;\n\t\tcur_timewait_info = rb_entry(parent, struct cm_timewait_info,\n\t\t\t\t\t     remote_id_node);\n\t\tif (be32_lt(remote_id, cur_timewait_info->work.remote_id))\n\t\t\tlink = &(*link)->rb_left;\n\t\telse if (be32_gt(remote_id, cur_timewait_info->work.remote_id))\n\t\t\tlink = &(*link)->rb_right;\n\t\telse if (be64_lt(remote_ca_guid, cur_timewait_info->remote_ca_guid))\n\t\t\tlink = &(*link)->rb_left;\n\t\telse if (be64_gt(remote_ca_guid, cur_timewait_info->remote_ca_guid))\n\t\t\tlink = &(*link)->rb_right;\n\t\telse\n\t\t\treturn cur_timewait_info;\n\t}\n\ttimewait_info->inserted_remote_id = 1;\n\trb_link_node(&timewait_info->remote_id_node, parent, link);\n\trb_insert_color(&timewait_info->remote_id_node, &cm.remote_id_table);\n\treturn NULL;\n}\n\nstatic struct cm_id_private *cm_find_remote_id(__be64 remote_ca_guid,\n\t\t\t\t\t       __be32 remote_id)\n{\n\tstruct rb_node *node = cm.remote_id_table.rb_node;\n\tstruct cm_timewait_info *timewait_info;\n\tstruct cm_id_private *res = NULL;\n\n\tspin_lock_irq(&cm.lock);\n\twhile (node) {\n\t\ttimewait_info = rb_entry(node, struct cm_timewait_info,\n\t\t\t\t\t remote_id_node);\n\t\tif (be32_lt(remote_id, timewait_info->work.remote_id))\n\t\t\tnode = node->rb_left;\n\t\telse if (be32_gt(remote_id, timewait_info->work.remote_id))\n\t\t\tnode = node->rb_right;\n\t\telse if (be64_lt(remote_ca_guid, timewait_info->remote_ca_guid))\n\t\t\tnode = node->rb_left;\n\t\telse if (be64_gt(remote_ca_guid, timewait_info->remote_ca_guid))\n\t\t\tnode = node->rb_right;\n\t\telse {\n\t\t\tres = cm_acquire_id(timewait_info->work.local_id,\n\t\t\t\t\t     timewait_info->work.remote_id);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irq(&cm.lock);\n\treturn res;\n}\n\nstatic struct cm_timewait_info *\ncm_insert_remote_qpn(struct cm_timewait_info *timewait_info)\n{\n\tstruct rb_node **link = &cm.remote_qp_table.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct cm_timewait_info *cur_timewait_info;\n\t__be64 remote_ca_guid = timewait_info->remote_ca_guid;\n\t__be32 remote_qpn = timewait_info->remote_qpn;\n\n\twhile (*link) {\n\t\tparent = *link;\n\t\tcur_timewait_info = rb_entry(parent, struct cm_timewait_info,\n\t\t\t\t\t     remote_qp_node);\n\t\tif (be32_lt(remote_qpn, cur_timewait_info->remote_qpn))\n\t\t\tlink = &(*link)->rb_left;\n\t\telse if (be32_gt(remote_qpn, cur_timewait_info->remote_qpn))\n\t\t\tlink = &(*link)->rb_right;\n\t\telse if (be64_lt(remote_ca_guid, cur_timewait_info->remote_ca_guid))\n\t\t\tlink = &(*link)->rb_left;\n\t\telse if (be64_gt(remote_ca_guid, cur_timewait_info->remote_ca_guid))\n\t\t\tlink = &(*link)->rb_right;\n\t\telse\n\t\t\treturn cur_timewait_info;\n\t}\n\ttimewait_info->inserted_remote_qp = 1;\n\trb_link_node(&timewait_info->remote_qp_node, parent, link);\n\trb_insert_color(&timewait_info->remote_qp_node, &cm.remote_qp_table);\n\treturn NULL;\n}\n\nstatic struct cm_id_private *\ncm_insert_remote_sidr(struct cm_id_private *cm_id_priv)\n{\n\tstruct rb_node **link = &cm.remote_sidr_table.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct cm_id_private *cur_cm_id_priv;\n\t__be32 remote_id = cm_id_priv->id.remote_id;\n\n\twhile (*link) {\n\t\tparent = *link;\n\t\tcur_cm_id_priv = rb_entry(parent, struct cm_id_private,\n\t\t\t\t\t  sidr_id_node);\n\t\tif (be32_lt(remote_id, cur_cm_id_priv->id.remote_id))\n\t\t\tlink = &(*link)->rb_left;\n\t\telse if (be32_gt(remote_id, cur_cm_id_priv->id.remote_id))\n\t\t\tlink = &(*link)->rb_right;\n\t\telse {\n\t\t\tif (cur_cm_id_priv->sidr_slid < cm_id_priv->sidr_slid)\n\t\t\t\tlink = &(*link)->rb_left;\n\t\t\telse if (cur_cm_id_priv->sidr_slid > cm_id_priv->sidr_slid)\n\t\t\t\tlink = &(*link)->rb_right;\n\t\t\telse\n\t\t\t\treturn cur_cm_id_priv;\n\t\t}\n\t}\n\trb_link_node(&cm_id_priv->sidr_id_node, parent, link);\n\trb_insert_color(&cm_id_priv->sidr_id_node, &cm.remote_sidr_table);\n\treturn NULL;\n}\n\nstatic struct cm_id_private *cm_alloc_id_priv(struct ib_device *device,\n\t\t\t\t\t      ib_cm_handler cm_handler,\n\t\t\t\t\t      void *context)\n{\n\tstruct cm_id_private *cm_id_priv;\n\tu32 id;\n\tint ret;\n\n\tcm_id_priv = kzalloc(sizeof *cm_id_priv, GFP_KERNEL);\n\tif (!cm_id_priv)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcm_id_priv->id.state = IB_CM_IDLE;\n\tcm_id_priv->id.device = device;\n\tcm_id_priv->id.cm_handler = cm_handler;\n\tcm_id_priv->id.context = context;\n\tcm_id_priv->id.remote_cm_qpn = 1;\n\n\tRB_CLEAR_NODE(&cm_id_priv->service_node);\n\tRB_CLEAR_NODE(&cm_id_priv->sidr_id_node);\n\tspin_lock_init(&cm_id_priv->lock);\n\tinit_completion(&cm_id_priv->comp);\n\tINIT_LIST_HEAD(&cm_id_priv->work_list);\n\tatomic_set(&cm_id_priv->work_count, -1);\n\trefcount_set(&cm_id_priv->refcount, 1);\n\n\tret = xa_alloc_cyclic(&cm.local_id_table, &id, NULL, xa_limit_32b,\n\t\t\t      &cm.local_id_next, GFP_KERNEL);\n\tif (ret < 0)\n\t\tgoto error;\n\tcm_id_priv->id.local_id = (__force __be32)id ^ cm.random_id_operand;\n\n\treturn cm_id_priv;\n\nerror:\n\tkfree(cm_id_priv);\n\treturn ERR_PTR(ret);\n}\n\n \nstatic void cm_finalize_id(struct cm_id_private *cm_id_priv)\n{\n\txa_store(&cm.local_id_table, cm_local_id(cm_id_priv->id.local_id),\n\t\t cm_id_priv, GFP_ATOMIC);\n}\n\nstruct ib_cm_id *ib_create_cm_id(struct ib_device *device,\n\t\t\t\t ib_cm_handler cm_handler,\n\t\t\t\t void *context)\n{\n\tstruct cm_id_private *cm_id_priv;\n\n\tcm_id_priv = cm_alloc_id_priv(device, cm_handler, context);\n\tif (IS_ERR(cm_id_priv))\n\t\treturn ERR_CAST(cm_id_priv);\n\n\tcm_finalize_id(cm_id_priv);\n\treturn &cm_id_priv->id;\n}\nEXPORT_SYMBOL(ib_create_cm_id);\n\nstatic struct cm_work *cm_dequeue_work(struct cm_id_private *cm_id_priv)\n{\n\tstruct cm_work *work;\n\n\tif (list_empty(&cm_id_priv->work_list))\n\t\treturn NULL;\n\n\twork = list_entry(cm_id_priv->work_list.next, struct cm_work, list);\n\tlist_del(&work->list);\n\treturn work;\n}\n\nstatic void cm_free_work(struct cm_work *work)\n{\n\tif (work->mad_recv_wc)\n\t\tib_free_recv_mad(work->mad_recv_wc);\n\tkfree(work);\n}\n\nstatic void cm_queue_work_unlock(struct cm_id_private *cm_id_priv,\n\t\t\t\t struct cm_work *work)\n\t__releases(&cm_id_priv->lock)\n{\n\tbool immediate;\n\n\t \n\timmediate = atomic_inc_and_test(&cm_id_priv->work_count);\n\tif (!immediate) {\n\t\tlist_add_tail(&work->list, &cm_id_priv->work_list);\n\t\t \n\t\tcm_deref_id(cm_id_priv);\n\t}\n\tspin_unlock_irq(&cm_id_priv->lock);\n\n\tif (immediate)\n\t\tcm_process_work(cm_id_priv, work);\n}\n\nstatic inline int cm_convert_to_ms(int iba_time)\n{\n\t \n\treturn 1 << max(iba_time - 8, 0);\n}\n\n \nstatic u8 cm_ack_timeout(u8 ca_ack_delay, u8 packet_life_time)\n{\n\tint ack_timeout = packet_life_time + 1;\n\n\tif (ack_timeout >= ca_ack_delay)\n\t\tack_timeout += (ca_ack_delay >= (ack_timeout - 1));\n\telse\n\t\tack_timeout = ca_ack_delay +\n\t\t\t      (ack_timeout >= (ca_ack_delay - 1));\n\n\treturn min(31, ack_timeout);\n}\n\nstatic void cm_remove_remote(struct cm_id_private *cm_id_priv)\n{\n\tstruct cm_timewait_info *timewait_info = cm_id_priv->timewait_info;\n\n\tif (timewait_info->inserted_remote_id) {\n\t\trb_erase(&timewait_info->remote_id_node, &cm.remote_id_table);\n\t\ttimewait_info->inserted_remote_id = 0;\n\t}\n\n\tif (timewait_info->inserted_remote_qp) {\n\t\trb_erase(&timewait_info->remote_qp_node, &cm.remote_qp_table);\n\t\ttimewait_info->inserted_remote_qp = 0;\n\t}\n}\n\nstatic struct cm_timewait_info *cm_create_timewait_info(__be32 local_id)\n{\n\tstruct cm_timewait_info *timewait_info;\n\n\ttimewait_info = kzalloc(sizeof *timewait_info, GFP_KERNEL);\n\tif (!timewait_info)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttimewait_info->work.local_id = local_id;\n\tINIT_DELAYED_WORK(&timewait_info->work.work, cm_work_handler);\n\ttimewait_info->work.cm_event.event = IB_CM_TIMEWAIT_EXIT;\n\treturn timewait_info;\n}\n\nstatic void cm_enter_timewait(struct cm_id_private *cm_id_priv)\n{\n\tint wait_time;\n\tunsigned long flags;\n\tstruct cm_device *cm_dev;\n\n\tlockdep_assert_held(&cm_id_priv->lock);\n\n\tcm_dev = ib_get_client_data(cm_id_priv->id.device, &cm_client);\n\tif (!cm_dev)\n\t\treturn;\n\n\tspin_lock_irqsave(&cm.lock, flags);\n\tcm_remove_remote(cm_id_priv);\n\tlist_add_tail(&cm_id_priv->timewait_info->list, &cm.timewait_list);\n\tspin_unlock_irqrestore(&cm.lock, flags);\n\n\t \n\tcm_id_priv->id.state = IB_CM_TIMEWAIT;\n\twait_time = cm_convert_to_ms(cm_id_priv->av.timeout);\n\n\t \n\tspin_lock_irqsave(&cm.lock, flags);\n\tif (!cm_dev->going_down)\n\t\tqueue_delayed_work(cm.wq, &cm_id_priv->timewait_info->work.work,\n\t\t\t\t   msecs_to_jiffies(wait_time));\n\tspin_unlock_irqrestore(&cm.lock, flags);\n\n\t \n\tBUILD_BUG_ON(offsetof(struct cm_timewait_info, work) != 0);\n\tcm_id_priv->timewait_info = NULL;\n}\n\nstatic void cm_reset_to_idle(struct cm_id_private *cm_id_priv)\n{\n\tunsigned long flags;\n\n\tlockdep_assert_held(&cm_id_priv->lock);\n\n\tcm_id_priv->id.state = IB_CM_IDLE;\n\tif (cm_id_priv->timewait_info) {\n\t\tspin_lock_irqsave(&cm.lock, flags);\n\t\tcm_remove_remote(cm_id_priv);\n\t\tspin_unlock_irqrestore(&cm.lock, flags);\n\t\tkfree(cm_id_priv->timewait_info);\n\t\tcm_id_priv->timewait_info = NULL;\n\t}\n}\n\nstatic void cm_destroy_id(struct ib_cm_id *cm_id, int err)\n{\n\tstruct cm_id_private *cm_id_priv;\n\tstruct cm_work *work;\n\n\tcm_id_priv = container_of(cm_id, struct cm_id_private, id);\n\tspin_lock_irq(&cm_id_priv->lock);\nretest:\n\tswitch (cm_id->state) {\n\tcase IB_CM_LISTEN:\n\t\tspin_lock(&cm.lock);\n\t\tif (--cm_id_priv->listen_sharecount > 0) {\n\t\t\t \n\t\t\tWARN_ON(refcount_read(&cm_id_priv->refcount) == 1);\n\t\t\tspin_unlock(&cm.lock);\n\t\t\tspin_unlock_irq(&cm_id_priv->lock);\n\t\t\tcm_deref_id(cm_id_priv);\n\t\t\treturn;\n\t\t}\n\t\tcm_id->state = IB_CM_IDLE;\n\t\trb_erase(&cm_id_priv->service_node, &cm.listen_service_table);\n\t\tRB_CLEAR_NODE(&cm_id_priv->service_node);\n\t\tspin_unlock(&cm.lock);\n\t\tbreak;\n\tcase IB_CM_SIDR_REQ_SENT:\n\t\tcm_id->state = IB_CM_IDLE;\n\t\tib_cancel_mad(cm_id_priv->msg);\n\t\tbreak;\n\tcase IB_CM_SIDR_REQ_RCVD:\n\t\tcm_send_sidr_rep_locked(cm_id_priv,\n\t\t\t\t\t&(struct ib_cm_sidr_rep_param){\n\t\t\t\t\t\t.status = IB_SIDR_REJECT });\n\t\t \n\t\tcm_id->state = IB_CM_IDLE;\n\t\tbreak;\n\tcase IB_CM_REQ_SENT:\n\tcase IB_CM_MRA_REQ_RCVD:\n\t\tib_cancel_mad(cm_id_priv->msg);\n\t\tcm_send_rej_locked(cm_id_priv, IB_CM_REJ_TIMEOUT,\n\t\t\t\t   &cm_id_priv->id.device->node_guid,\n\t\t\t\t   sizeof(cm_id_priv->id.device->node_guid),\n\t\t\t\t   NULL, 0);\n\t\tbreak;\n\tcase IB_CM_REQ_RCVD:\n\t\tif (err == -ENOMEM) {\n\t\t\t \n\t\t\tcm_reset_to_idle(cm_id_priv);\n\t\t} else {\n\t\t\tcm_send_rej_locked(cm_id_priv,\n\t\t\t\t\t   IB_CM_REJ_CONSUMER_DEFINED, NULL, 0,\n\t\t\t\t\t   NULL, 0);\n\t\t}\n\t\tbreak;\n\tcase IB_CM_REP_SENT:\n\tcase IB_CM_MRA_REP_RCVD:\n\t\tib_cancel_mad(cm_id_priv->msg);\n\t\tcm_send_rej_locked(cm_id_priv, IB_CM_REJ_CONSUMER_DEFINED, NULL,\n\t\t\t\t   0, NULL, 0);\n\t\tgoto retest;\n\tcase IB_CM_MRA_REQ_SENT:\n\tcase IB_CM_REP_RCVD:\n\tcase IB_CM_MRA_REP_SENT:\n\t\tcm_send_rej_locked(cm_id_priv, IB_CM_REJ_CONSUMER_DEFINED, NULL,\n\t\t\t\t   0, NULL, 0);\n\t\tbreak;\n\tcase IB_CM_ESTABLISHED:\n\t\tif (cm_id_priv->qp_type == IB_QPT_XRC_TGT) {\n\t\t\tcm_id->state = IB_CM_IDLE;\n\t\t\tbreak;\n\t\t}\n\t\tcm_send_dreq_locked(cm_id_priv, NULL, 0);\n\t\tgoto retest;\n\tcase IB_CM_DREQ_SENT:\n\t\tib_cancel_mad(cm_id_priv->msg);\n\t\tcm_enter_timewait(cm_id_priv);\n\t\tgoto retest;\n\tcase IB_CM_DREQ_RCVD:\n\t\tcm_send_drep_locked(cm_id_priv, NULL, 0);\n\t\tWARN_ON(cm_id->state != IB_CM_TIMEWAIT);\n\t\tgoto retest;\n\tcase IB_CM_TIMEWAIT:\n\t\t \n\t\tcm_id->state = IB_CM_IDLE;\n\t\tbreak;\n\tcase IB_CM_IDLE:\n\t\tbreak;\n\t}\n\tWARN_ON(cm_id->state != IB_CM_IDLE);\n\n\tspin_lock(&cm.lock);\n\t \n\tif (cm_id_priv->timewait_info) {\n\t\tcm_remove_remote(cm_id_priv);\n\t\tkfree(cm_id_priv->timewait_info);\n\t\tcm_id_priv->timewait_info = NULL;\n\t}\n\n\tWARN_ON(cm_id_priv->listen_sharecount);\n\tWARN_ON(!RB_EMPTY_NODE(&cm_id_priv->service_node));\n\tif (!RB_EMPTY_NODE(&cm_id_priv->sidr_id_node))\n\t\trb_erase(&cm_id_priv->sidr_id_node, &cm.remote_sidr_table);\n\tspin_unlock(&cm.lock);\n\tspin_unlock_irq(&cm_id_priv->lock);\n\n\txa_erase(&cm.local_id_table, cm_local_id(cm_id->local_id));\n\tcm_deref_id(cm_id_priv);\n\twait_for_completion(&cm_id_priv->comp);\n\twhile ((work = cm_dequeue_work(cm_id_priv)) != NULL)\n\t\tcm_free_work(work);\n\n\tcm_destroy_av(&cm_id_priv->av);\n\tcm_destroy_av(&cm_id_priv->alt_av);\n\tkfree(cm_id_priv->private_data);\n\tkfree_rcu(cm_id_priv, rcu);\n}\n\nvoid ib_destroy_cm_id(struct ib_cm_id *cm_id)\n{\n\tcm_destroy_id(cm_id, 0);\n}\nEXPORT_SYMBOL(ib_destroy_cm_id);\n\nstatic int cm_init_listen(struct cm_id_private *cm_id_priv, __be64 service_id)\n{\n\tif ((service_id & IB_SERVICE_ID_AGN_MASK) == IB_CM_ASSIGN_SERVICE_ID &&\n\t    (service_id != IB_CM_ASSIGN_SERVICE_ID))\n\t\treturn -EINVAL;\n\n\tif (service_id == IB_CM_ASSIGN_SERVICE_ID)\n\t\tcm_id_priv->id.service_id = cpu_to_be64(cm.listen_service_id++);\n\telse\n\t\tcm_id_priv->id.service_id = service_id;\n\n\treturn 0;\n}\n\n \nint ib_cm_listen(struct ib_cm_id *cm_id, __be64 service_id)\n{\n\tstruct cm_id_private *cm_id_priv =\n\t\tcontainer_of(cm_id, struct cm_id_private, id);\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&cm_id_priv->lock, flags);\n\tif (cm_id_priv->id.state != IB_CM_IDLE) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = cm_init_listen(cm_id_priv, service_id);\n\tif (ret)\n\t\tgoto out;\n\n\tif (!cm_insert_listen(cm_id_priv, NULL)) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tcm_id_priv->id.state = IB_CM_LISTEN;\n\tret = 0;\n\nout:\n\tspin_unlock_irqrestore(&cm_id_priv->lock, flags);\n\treturn ret;\n}\nEXPORT_SYMBOL(ib_cm_listen);\n\n \nstruct ib_cm_id *ib_cm_insert_listen(struct ib_device *device,\n\t\t\t\t     ib_cm_handler cm_handler,\n\t\t\t\t     __be64 service_id)\n{\n\tstruct cm_id_private *listen_id_priv;\n\tstruct cm_id_private *cm_id_priv;\n\tint err = 0;\n\n\t \n\tcm_id_priv = cm_alloc_id_priv(device, cm_handler, NULL);\n\tif (IS_ERR(cm_id_priv))\n\t\treturn ERR_CAST(cm_id_priv);\n\n\terr = cm_init_listen(cm_id_priv, service_id);\n\tif (err) {\n\t\tib_destroy_cm_id(&cm_id_priv->id);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tspin_lock_irq(&cm_id_priv->lock);\n\tlisten_id_priv = cm_insert_listen(cm_id_priv, cm_handler);\n\tif (listen_id_priv != cm_id_priv) {\n\t\tspin_unlock_irq(&cm_id_priv->lock);\n\t\tib_destroy_cm_id(&cm_id_priv->id);\n\t\tif (!listen_id_priv)\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\treturn &listen_id_priv->id;\n\t}\n\tcm_id_priv->id.state = IB_CM_LISTEN;\n\tspin_unlock_irq(&cm_id_priv->lock);\n\n\t \n\n\treturn &cm_id_priv->id;\n}\nEXPORT_SYMBOL(ib_cm_insert_listen);\n\nstatic __be64 cm_form_tid(struct cm_id_private *cm_id_priv)\n{\n\tu64 hi_tid = 0, low_tid;\n\n\tlockdep_assert_held(&cm_id_priv->lock);\n\n\tlow_tid = (u64)cm_id_priv->id.local_id;\n\tif (!cm_id_priv->av.port)\n\t\treturn cpu_to_be64(low_tid);\n\n\tspin_lock(&cm_id_priv->av.port->cm_dev->mad_agent_lock);\n\tif (cm_id_priv->av.port->mad_agent)\n\t\thi_tid = ((u64)cm_id_priv->av.port->mad_agent->hi_tid) << 32;\n\tspin_unlock(&cm_id_priv->av.port->cm_dev->mad_agent_lock);\n\treturn cpu_to_be64(hi_tid | low_tid);\n}\n\nstatic void cm_format_mad_hdr(struct ib_mad_hdr *hdr,\n\t\t\t      __be16 attr_id, __be64 tid)\n{\n\thdr->base_version  = IB_MGMT_BASE_VERSION;\n\thdr->mgmt_class\t   = IB_MGMT_CLASS_CM;\n\thdr->class_version = IB_CM_CLASS_VERSION;\n\thdr->method\t   = IB_MGMT_METHOD_SEND;\n\thdr->attr_id\t   = attr_id;\n\thdr->tid\t   = tid;\n}\n\nstatic void cm_format_mad_ece_hdr(struct ib_mad_hdr *hdr, __be16 attr_id,\n\t\t\t\t  __be64 tid, u32 attr_mod)\n{\n\tcm_format_mad_hdr(hdr, attr_id, tid);\n\thdr->attr_mod = cpu_to_be32(attr_mod);\n}\n\nstatic void cm_format_req(struct cm_req_msg *req_msg,\n\t\t\t  struct cm_id_private *cm_id_priv,\n\t\t\t  struct ib_cm_req_param *param)\n{\n\tstruct sa_path_rec *pri_path = param->primary_path;\n\tstruct sa_path_rec *alt_path = param->alternate_path;\n\tbool pri_ext = false;\n\t__be16 lid;\n\n\tif (pri_path->rec_type == SA_PATH_REC_TYPE_OPA)\n\t\tpri_ext = opa_is_extended_lid(pri_path->opa.dlid,\n\t\t\t\t\t      pri_path->opa.slid);\n\n\tcm_format_mad_ece_hdr(&req_msg->hdr, CM_REQ_ATTR_ID,\n\t\t\t      cm_form_tid(cm_id_priv), param->ece.attr_mod);\n\n\tIBA_SET(CM_REQ_LOCAL_COMM_ID, req_msg,\n\t\tbe32_to_cpu(cm_id_priv->id.local_id));\n\tIBA_SET(CM_REQ_SERVICE_ID, req_msg, be64_to_cpu(param->service_id));\n\tIBA_SET(CM_REQ_LOCAL_CA_GUID, req_msg,\n\t\tbe64_to_cpu(cm_id_priv->id.device->node_guid));\n\tIBA_SET(CM_REQ_LOCAL_QPN, req_msg, param->qp_num);\n\tIBA_SET(CM_REQ_INITIATOR_DEPTH, req_msg, param->initiator_depth);\n\tIBA_SET(CM_REQ_REMOTE_CM_RESPONSE_TIMEOUT, req_msg,\n\t\tparam->remote_cm_response_timeout);\n\tcm_req_set_qp_type(req_msg, param->qp_type);\n\tIBA_SET(CM_REQ_END_TO_END_FLOW_CONTROL, req_msg, param->flow_control);\n\tIBA_SET(CM_REQ_STARTING_PSN, req_msg, param->starting_psn);\n\tIBA_SET(CM_REQ_LOCAL_CM_RESPONSE_TIMEOUT, req_msg,\n\t\tparam->local_cm_response_timeout);\n\tIBA_SET(CM_REQ_PARTITION_KEY, req_msg,\n\t\tbe16_to_cpu(param->primary_path->pkey));\n\tIBA_SET(CM_REQ_PATH_PACKET_PAYLOAD_MTU, req_msg,\n\t\tparam->primary_path->mtu);\n\tIBA_SET(CM_REQ_MAX_CM_RETRIES, req_msg, param->max_cm_retries);\n\n\tif (param->qp_type != IB_QPT_XRC_INI) {\n\t\tIBA_SET(CM_REQ_RESPONDER_RESOURCES, req_msg,\n\t\t\tparam->responder_resources);\n\t\tIBA_SET(CM_REQ_RETRY_COUNT, req_msg, param->retry_count);\n\t\tIBA_SET(CM_REQ_RNR_RETRY_COUNT, req_msg,\n\t\t\tparam->rnr_retry_count);\n\t\tIBA_SET(CM_REQ_SRQ, req_msg, param->srq);\n\t}\n\n\t*IBA_GET_MEM_PTR(CM_REQ_PRIMARY_LOCAL_PORT_GID, req_msg) =\n\t\tpri_path->sgid;\n\t*IBA_GET_MEM_PTR(CM_REQ_PRIMARY_REMOTE_PORT_GID, req_msg) =\n\t\tpri_path->dgid;\n\tif (pri_ext) {\n\t\tIBA_GET_MEM_PTR(CM_REQ_PRIMARY_LOCAL_PORT_GID, req_msg)\n\t\t\t->global.interface_id =\n\t\t\tOPA_MAKE_ID(be32_to_cpu(pri_path->opa.slid));\n\t\tIBA_GET_MEM_PTR(CM_REQ_PRIMARY_REMOTE_PORT_GID, req_msg)\n\t\t\t->global.interface_id =\n\t\t\tOPA_MAKE_ID(be32_to_cpu(pri_path->opa.dlid));\n\t}\n\tif (pri_path->hop_limit <= 1) {\n\t\tIBA_SET(CM_REQ_PRIMARY_LOCAL_PORT_LID, req_msg,\n\t\t\tbe16_to_cpu(pri_ext ? 0 :\n\t\t\t\t\t      htons(ntohl(sa_path_get_slid(\n\t\t\t\t\t\t      pri_path)))));\n\t\tIBA_SET(CM_REQ_PRIMARY_REMOTE_PORT_LID, req_msg,\n\t\t\tbe16_to_cpu(pri_ext ? 0 :\n\t\t\t\t\t      htons(ntohl(sa_path_get_dlid(\n\t\t\t\t\t\t      pri_path)))));\n\t} else {\n\n\t\tif (param->primary_path_inbound) {\n\t\t\tlid = param->primary_path_inbound->ib.dlid;\n\t\t\tIBA_SET(CM_REQ_PRIMARY_LOCAL_PORT_LID, req_msg,\n\t\t\t\tbe16_to_cpu(lid));\n\t\t} else\n\t\t\tIBA_SET(CM_REQ_PRIMARY_LOCAL_PORT_LID, req_msg,\n\t\t\t\tbe16_to_cpu(IB_LID_PERMISSIVE));\n\n\t\t \n\t\tIBA_SET(CM_REQ_PRIMARY_REMOTE_PORT_LID, req_msg,\n\t\t\tbe16_to_cpu(IB_LID_PERMISSIVE));\n\t}\n\tIBA_SET(CM_REQ_PRIMARY_FLOW_LABEL, req_msg,\n\t\tbe32_to_cpu(pri_path->flow_label));\n\tIBA_SET(CM_REQ_PRIMARY_PACKET_RATE, req_msg, pri_path->rate);\n\tIBA_SET(CM_REQ_PRIMARY_TRAFFIC_CLASS, req_msg, pri_path->traffic_class);\n\tIBA_SET(CM_REQ_PRIMARY_HOP_LIMIT, req_msg, pri_path->hop_limit);\n\tIBA_SET(CM_REQ_PRIMARY_SL, req_msg, pri_path->sl);\n\tIBA_SET(CM_REQ_PRIMARY_SUBNET_LOCAL, req_msg,\n\t\t(pri_path->hop_limit <= 1));\n\tIBA_SET(CM_REQ_PRIMARY_LOCAL_ACK_TIMEOUT, req_msg,\n\t\tcm_ack_timeout(cm_id_priv->av.port->cm_dev->ack_delay,\n\t\t\t       pri_path->packet_life_time));\n\n\tif (alt_path) {\n\t\tbool alt_ext = false;\n\n\t\tif (alt_path->rec_type == SA_PATH_REC_TYPE_OPA)\n\t\t\talt_ext = opa_is_extended_lid(alt_path->opa.dlid,\n\t\t\t\t\t\t      alt_path->opa.slid);\n\n\t\t*IBA_GET_MEM_PTR(CM_REQ_ALTERNATE_LOCAL_PORT_GID, req_msg) =\n\t\t\talt_path->sgid;\n\t\t*IBA_GET_MEM_PTR(CM_REQ_ALTERNATE_REMOTE_PORT_GID, req_msg) =\n\t\t\talt_path->dgid;\n\t\tif (alt_ext) {\n\t\t\tIBA_GET_MEM_PTR(CM_REQ_ALTERNATE_LOCAL_PORT_GID,\n\t\t\t\t\treq_msg)\n\t\t\t\t->global.interface_id =\n\t\t\t\tOPA_MAKE_ID(be32_to_cpu(alt_path->opa.slid));\n\t\t\tIBA_GET_MEM_PTR(CM_REQ_ALTERNATE_REMOTE_PORT_GID,\n\t\t\t\t\treq_msg)\n\t\t\t\t->global.interface_id =\n\t\t\t\tOPA_MAKE_ID(be32_to_cpu(alt_path->opa.dlid));\n\t\t}\n\t\tif (alt_path->hop_limit <= 1) {\n\t\t\tIBA_SET(CM_REQ_ALTERNATE_LOCAL_PORT_LID, req_msg,\n\t\t\t\tbe16_to_cpu(\n\t\t\t\t\talt_ext ? 0 :\n\t\t\t\t\t\t  htons(ntohl(sa_path_get_slid(\n\t\t\t\t\t\t\t  alt_path)))));\n\t\t\tIBA_SET(CM_REQ_ALTERNATE_REMOTE_PORT_LID, req_msg,\n\t\t\t\tbe16_to_cpu(\n\t\t\t\t\talt_ext ? 0 :\n\t\t\t\t\t\t  htons(ntohl(sa_path_get_dlid(\n\t\t\t\t\t\t\t  alt_path)))));\n\t\t} else {\n\t\t\tIBA_SET(CM_REQ_ALTERNATE_LOCAL_PORT_LID, req_msg,\n\t\t\t\tbe16_to_cpu(IB_LID_PERMISSIVE));\n\t\t\tIBA_SET(CM_REQ_ALTERNATE_REMOTE_PORT_LID, req_msg,\n\t\t\t\tbe16_to_cpu(IB_LID_PERMISSIVE));\n\t\t}\n\t\tIBA_SET(CM_REQ_ALTERNATE_FLOW_LABEL, req_msg,\n\t\t\tbe32_to_cpu(alt_path->flow_label));\n\t\tIBA_SET(CM_REQ_ALTERNATE_PACKET_RATE, req_msg, alt_path->rate);\n\t\tIBA_SET(CM_REQ_ALTERNATE_TRAFFIC_CLASS, req_msg,\n\t\t\talt_path->traffic_class);\n\t\tIBA_SET(CM_REQ_ALTERNATE_HOP_LIMIT, req_msg,\n\t\t\talt_path->hop_limit);\n\t\tIBA_SET(CM_REQ_ALTERNATE_SL, req_msg, alt_path->sl);\n\t\tIBA_SET(CM_REQ_ALTERNATE_SUBNET_LOCAL, req_msg,\n\t\t\t(alt_path->hop_limit <= 1));\n\t\tIBA_SET(CM_REQ_ALTERNATE_LOCAL_ACK_TIMEOUT, req_msg,\n\t\t\tcm_ack_timeout(cm_id_priv->av.port->cm_dev->ack_delay,\n\t\t\t\t       alt_path->packet_life_time));\n\t}\n\tIBA_SET(CM_REQ_VENDOR_ID, req_msg, param->ece.vendor_id);\n\n\tif (param->private_data && param->private_data_len)\n\t\tIBA_SET_MEM(CM_REQ_PRIVATE_DATA, req_msg, param->private_data,\n\t\t\t    param->private_data_len);\n}\n\nstatic int cm_validate_req_param(struct ib_cm_req_param *param)\n{\n\tif (!param->primary_path)\n\t\treturn -EINVAL;\n\n\tif (param->qp_type != IB_QPT_RC && param->qp_type != IB_QPT_UC &&\n\t    param->qp_type != IB_QPT_XRC_INI)\n\t\treturn -EINVAL;\n\n\tif (param->private_data &&\n\t    param->private_data_len > IB_CM_REQ_PRIVATE_DATA_SIZE)\n\t\treturn -EINVAL;\n\n\tif (param->alternate_path &&\n\t    (param->alternate_path->pkey != param->primary_path->pkey ||\n\t     param->alternate_path->mtu != param->primary_path->mtu))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nint ib_send_cm_req(struct ib_cm_id *cm_id,\n\t\t   struct ib_cm_req_param *param)\n{\n\tstruct cm_av av = {}, alt_av = {};\n\tstruct cm_id_private *cm_id_priv;\n\tstruct ib_mad_send_buf *msg;\n\tstruct cm_req_msg *req_msg;\n\tunsigned long flags;\n\tint ret;\n\n\tret = cm_validate_req_param(param);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tcm_id_priv = container_of(cm_id, struct cm_id_private, id);\n\tspin_lock_irqsave(&cm_id_priv->lock, flags);\n\tif (cm_id->state != IB_CM_IDLE || WARN_ON(cm_id_priv->timewait_info)) {\n\t\tspin_unlock_irqrestore(&cm_id_priv->lock, flags);\n\t\treturn -EINVAL;\n\t}\n\tspin_unlock_irqrestore(&cm_id_priv->lock, flags);\n\n\tcm_id_priv->timewait_info = cm_create_timewait_info(cm_id_priv->\n\t\t\t\t\t\t\t    id.local_id);\n\tif (IS_ERR(cm_id_priv->timewait_info)) {\n\t\tret = PTR_ERR(cm_id_priv->timewait_info);\n\t\tcm_id_priv->timewait_info = NULL;\n\t\treturn ret;\n\t}\n\n\tret = cm_init_av_by_path(param->primary_path,\n\t\t\t\t param->ppath_sgid_attr, &av);\n\tif (ret)\n\t\treturn ret;\n\tif (param->alternate_path) {\n\t\tret = cm_init_av_by_path(param->alternate_path, NULL,\n\t\t\t\t\t &alt_av);\n\t\tif (ret) {\n\t\t\tcm_destroy_av(&av);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tcm_id->service_id = param->service_id;\n\tcm_id_priv->timeout_ms = cm_convert_to_ms(\n\t\t\t\t    param->primary_path->packet_life_time) * 2 +\n\t\t\t\t cm_convert_to_ms(\n\t\t\t\t    param->remote_cm_response_timeout);\n\tcm_id_priv->max_cm_retries = param->max_cm_retries;\n\tcm_id_priv->initiator_depth = param->initiator_depth;\n\tcm_id_priv->responder_resources = param->responder_resources;\n\tcm_id_priv->retry_count = param->retry_count;\n\tcm_id_priv->path_mtu = param->primary_path->mtu;\n\tcm_id_priv->pkey = param->primary_path->pkey;\n\tcm_id_priv->qp_type = param->qp_type;\n\n\tspin_lock_irqsave(&cm_id_priv->lock, flags);\n\n\tcm_move_av_from_path(&cm_id_priv->av, &av);\n\tif (param->primary_path_outbound)\n\t\tcm_id_priv->av.dlid_datapath =\n\t\t\tbe16_to_cpu(param->primary_path_outbound->ib.dlid);\n\n\tif (param->alternate_path)\n\t\tcm_move_av_from_path(&cm_id_priv->alt_av, &alt_av);\n\n\tmsg = cm_alloc_priv_msg(cm_id_priv);\n\tif (IS_ERR(msg)) {\n\t\tret = PTR_ERR(msg);\n\t\tgoto out_unlock;\n\t}\n\n\treq_msg = (struct cm_req_msg *)msg->mad;\n\tcm_format_req(req_msg, cm_id_priv, param);\n\tcm_id_priv->tid = req_msg->hdr.tid;\n\tmsg->timeout_ms = cm_id_priv->timeout_ms;\n\tmsg->context[1] = (void *)(unsigned long)IB_CM_REQ_SENT;\n\n\tcm_id_priv->local_qpn = cpu_to_be32(IBA_GET(CM_REQ_LOCAL_QPN, req_msg));\n\tcm_id_priv->rq_psn = cpu_to_be32(IBA_GET(CM_REQ_STARTING_PSN, req_msg));\n\n\ttrace_icm_send_req(&cm_id_priv->id);\n\tret = ib_post_send_mad(msg, NULL);\n\tif (ret)\n\t\tgoto out_free;\n\tBUG_ON(cm_id->state != IB_CM_IDLE);\n\tcm_id->state = IB_CM_REQ_SENT;\n\tspin_unlock_irqrestore(&cm_id_priv->lock, flags);\n\treturn 0;\nout_free:\n\tcm_free_priv_msg(msg);\nout_unlock:\n\tspin_unlock_irqrestore(&cm_id_priv->lock, flags);\n\treturn ret;\n}\nEXPORT_SYMBOL(ib_send_cm_req);\n\nstatic int cm_issue_rej(struct cm_port *port,\n\t\t\tstruct ib_mad_recv_wc *mad_recv_wc,\n\t\t\tenum ib_cm_rej_reason reason,\n\t\t\tenum cm_msg_response msg_rejected,\n\t\t\tvoid *ari, u8 ari_length)\n{\n\tstruct ib_mad_send_buf *msg = NULL;\n\tstruct cm_rej_msg *rej_msg, *rcv_msg;\n\tint ret;\n\n\tret = cm_alloc_response_msg(port, mad_recv_wc, &msg);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\trcv_msg = (struct cm_rej_msg *) mad_recv_wc->recv_buf.mad;\n\trej_msg = (struct cm_rej_msg *) msg->mad;\n\n\tcm_format_mad_hdr(&rej_msg->hdr, CM_REJ_ATTR_ID, rcv_msg->hdr.tid);\n\tIBA_SET(CM_REJ_REMOTE_COMM_ID, rej_msg,\n\t\tIBA_GET(CM_REJ_LOCAL_COMM_ID, rcv_msg));\n\tIBA_SET(CM_REJ_LOCAL_COMM_ID, rej_msg,\n\t\tIBA_GET(CM_REJ_REMOTE_COMM_ID, rcv_msg));\n\tIBA_SET(CM_REJ_MESSAGE_REJECTED, rej_msg, msg_rejected);\n\tIBA_SET(CM_REJ_REASON, rej_msg, reason);\n\n\tif (ari && ari_length) {\n\t\tIBA_SET(CM_REJ_REJECTED_INFO_LENGTH, rej_msg, ari_length);\n\t\tIBA_SET_MEM(CM_REJ_ARI, rej_msg, ari, ari_length);\n\t}\n\n\ttrace_icm_issue_rej(\n\t\tIBA_GET(CM_REJ_LOCAL_COMM_ID, rcv_msg),\n\t\tIBA_GET(CM_REJ_REMOTE_COMM_ID, rcv_msg));\n\tret = ib_post_send_mad(msg, NULL);\n\tif (ret)\n\t\tcm_free_response_msg(msg);\n\n\treturn ret;\n}\n\nstatic bool cm_req_has_alt_path(struct cm_req_msg *req_msg)\n{\n\treturn ((cpu_to_be16(\n\t\t\tIBA_GET(CM_REQ_ALTERNATE_LOCAL_PORT_LID, req_msg))) ||\n\t\t(ib_is_opa_gid(IBA_GET_MEM_PTR(CM_REQ_ALTERNATE_LOCAL_PORT_GID,\n\t\t\t\t\t       req_msg))));\n}\n\nstatic void cm_path_set_rec_type(struct ib_device *ib_device, u32 port_num,\n\t\t\t\t struct sa_path_rec *path, union ib_gid *gid)\n{\n\tif (ib_is_opa_gid(gid) && rdma_cap_opa_ah(ib_device, port_num))\n\t\tpath->rec_type = SA_PATH_REC_TYPE_OPA;\n\telse\n\t\tpath->rec_type = SA_PATH_REC_TYPE_IB;\n}\n\nstatic void cm_format_path_lid_from_req(struct cm_req_msg *req_msg,\n\t\t\t\t\tstruct sa_path_rec *primary_path,\n\t\t\t\t\tstruct sa_path_rec *alt_path,\n\t\t\t\t\tstruct ib_wc *wc)\n{\n\tu32 lid;\n\n\tif (primary_path->rec_type != SA_PATH_REC_TYPE_OPA) {\n\t\tsa_path_set_dlid(primary_path, wc->slid);\n\t\tsa_path_set_slid(primary_path,\n\t\t\t\t IBA_GET(CM_REQ_PRIMARY_REMOTE_PORT_LID,\n\t\t\t\t\t req_msg));\n\t} else {\n\t\tlid = opa_get_lid_from_gid(IBA_GET_MEM_PTR(\n\t\t\tCM_REQ_PRIMARY_LOCAL_PORT_GID, req_msg));\n\t\tsa_path_set_dlid(primary_path, lid);\n\n\t\tlid = opa_get_lid_from_gid(IBA_GET_MEM_PTR(\n\t\t\tCM_REQ_PRIMARY_REMOTE_PORT_GID, req_msg));\n\t\tsa_path_set_slid(primary_path, lid);\n\t}\n\n\tif (!cm_req_has_alt_path(req_msg))\n\t\treturn;\n\n\tif (alt_path->rec_type != SA_PATH_REC_TYPE_OPA) {\n\t\tsa_path_set_dlid(alt_path,\n\t\t\t\t IBA_GET(CM_REQ_ALTERNATE_LOCAL_PORT_LID,\n\t\t\t\t\t req_msg));\n\t\tsa_path_set_slid(alt_path,\n\t\t\t\t IBA_GET(CM_REQ_ALTERNATE_REMOTE_PORT_LID,\n\t\t\t\t\t req_msg));\n\t} else {\n\t\tlid = opa_get_lid_from_gid(IBA_GET_MEM_PTR(\n\t\t\tCM_REQ_ALTERNATE_LOCAL_PORT_GID, req_msg));\n\t\tsa_path_set_dlid(alt_path, lid);\n\n\t\tlid = opa_get_lid_from_gid(IBA_GET_MEM_PTR(\n\t\t\tCM_REQ_ALTERNATE_REMOTE_PORT_GID, req_msg));\n\t\tsa_path_set_slid(alt_path, lid);\n\t}\n}\n\nstatic void cm_format_paths_from_req(struct cm_req_msg *req_msg,\n\t\t\t\t     struct sa_path_rec *primary_path,\n\t\t\t\t     struct sa_path_rec *alt_path,\n\t\t\t\t     struct ib_wc *wc)\n{\n\tprimary_path->dgid =\n\t\t*IBA_GET_MEM_PTR(CM_REQ_PRIMARY_LOCAL_PORT_GID, req_msg);\n\tprimary_path->sgid =\n\t\t*IBA_GET_MEM_PTR(CM_REQ_PRIMARY_REMOTE_PORT_GID, req_msg);\n\tprimary_path->flow_label =\n\t\tcpu_to_be32(IBA_GET(CM_REQ_PRIMARY_FLOW_LABEL, req_msg));\n\tprimary_path->hop_limit = IBA_GET(CM_REQ_PRIMARY_HOP_LIMIT, req_msg);\n\tprimary_path->traffic_class =\n\t\tIBA_GET(CM_REQ_PRIMARY_TRAFFIC_CLASS, req_msg);\n\tprimary_path->reversible = 1;\n\tprimary_path->pkey =\n\t\tcpu_to_be16(IBA_GET(CM_REQ_PARTITION_KEY, req_msg));\n\tprimary_path->sl = IBA_GET(CM_REQ_PRIMARY_SL, req_msg);\n\tprimary_path->mtu_selector = IB_SA_EQ;\n\tprimary_path->mtu = IBA_GET(CM_REQ_PATH_PACKET_PAYLOAD_MTU, req_msg);\n\tprimary_path->rate_selector = IB_SA_EQ;\n\tprimary_path->rate = IBA_GET(CM_REQ_PRIMARY_PACKET_RATE, req_msg);\n\tprimary_path->packet_life_time_selector = IB_SA_EQ;\n\tprimary_path->packet_life_time =\n\t\tIBA_GET(CM_REQ_PRIMARY_LOCAL_ACK_TIMEOUT, req_msg);\n\tprimary_path->packet_life_time -= (primary_path->packet_life_time > 0);\n\tprimary_path->service_id =\n\t\tcpu_to_be64(IBA_GET(CM_REQ_SERVICE_ID, req_msg));\n\tif (sa_path_is_roce(primary_path))\n\t\tprimary_path->roce.route_resolved = false;\n\n\tif (cm_req_has_alt_path(req_msg)) {\n\t\talt_path->dgid = *IBA_GET_MEM_PTR(\n\t\t\tCM_REQ_ALTERNATE_LOCAL_PORT_GID, req_msg);\n\t\talt_path->sgid = *IBA_GET_MEM_PTR(\n\t\t\tCM_REQ_ALTERNATE_REMOTE_PORT_GID, req_msg);\n\t\talt_path->flow_label = cpu_to_be32(\n\t\t\tIBA_GET(CM_REQ_ALTERNATE_FLOW_LABEL, req_msg));\n\t\talt_path->hop_limit =\n\t\t\tIBA_GET(CM_REQ_ALTERNATE_HOP_LIMIT, req_msg);\n\t\talt_path->traffic_class =\n\t\t\tIBA_GET(CM_REQ_ALTERNATE_TRAFFIC_CLASS, req_msg);\n\t\talt_path->reversible = 1;\n\t\talt_path->pkey =\n\t\t\tcpu_to_be16(IBA_GET(CM_REQ_PARTITION_KEY, req_msg));\n\t\talt_path->sl = IBA_GET(CM_REQ_ALTERNATE_SL, req_msg);\n\t\talt_path->mtu_selector = IB_SA_EQ;\n\t\talt_path->mtu =\n\t\t\tIBA_GET(CM_REQ_PATH_PACKET_PAYLOAD_MTU, req_msg);\n\t\talt_path->rate_selector = IB_SA_EQ;\n\t\talt_path->rate = IBA_GET(CM_REQ_ALTERNATE_PACKET_RATE, req_msg);\n\t\talt_path->packet_life_time_selector = IB_SA_EQ;\n\t\talt_path->packet_life_time =\n\t\t\tIBA_GET(CM_REQ_ALTERNATE_LOCAL_ACK_TIMEOUT, req_msg);\n\t\talt_path->packet_life_time -= (alt_path->packet_life_time > 0);\n\t\talt_path->service_id =\n\t\t\tcpu_to_be64(IBA_GET(CM_REQ_SERVICE_ID, req_msg));\n\n\t\tif (sa_path_is_roce(alt_path))\n\t\t\talt_path->roce.route_resolved = false;\n\t}\n\tcm_format_path_lid_from_req(req_msg, primary_path, alt_path, wc);\n}\n\nstatic u16 cm_get_bth_pkey(struct cm_work *work)\n{\n\tstruct ib_device *ib_dev = work->port->cm_dev->ib_device;\n\tu32 port_num = work->port->port_num;\n\tu16 pkey_index = work->mad_recv_wc->wc->pkey_index;\n\tu16 pkey;\n\tint ret;\n\n\tret = ib_get_cached_pkey(ib_dev, port_num, pkey_index, &pkey);\n\tif (ret) {\n\t\tdev_warn_ratelimited(&ib_dev->dev, \"ib_cm: Couldn't retrieve pkey for incoming request (port %u, pkey index %u). %d\\n\",\n\t\t\t\t     port_num, pkey_index, ret);\n\t\treturn 0;\n\t}\n\n\treturn pkey;\n}\n\n \nstatic void cm_opa_to_ib_sgid(struct cm_work *work,\n\t\t\t      struct sa_path_rec *path)\n{\n\tstruct ib_device *dev = work->port->cm_dev->ib_device;\n\tu32 port_num = work->port->port_num;\n\n\tif (rdma_cap_opa_ah(dev, port_num) &&\n\t    (ib_is_opa_gid(&path->sgid))) {\n\t\tunion ib_gid sgid;\n\n\t\tif (rdma_query_gid(dev, port_num, 0, &sgid)) {\n\t\t\tdev_warn(&dev->dev,\n\t\t\t\t \"Error updating sgid in CM request\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tpath->sgid = sgid;\n\t}\n}\n\nstatic void cm_format_req_event(struct cm_work *work,\n\t\t\t\tstruct cm_id_private *cm_id_priv,\n\t\t\t\tstruct ib_cm_id *listen_id)\n{\n\tstruct cm_req_msg *req_msg;\n\tstruct ib_cm_req_event_param *param;\n\n\treq_msg = (struct cm_req_msg *)work->mad_recv_wc->recv_buf.mad;\n\tparam = &work->cm_event.param.req_rcvd;\n\tparam->listen_id = listen_id;\n\tparam->bth_pkey = cm_get_bth_pkey(work);\n\tparam->port = cm_id_priv->av.port->port_num;\n\tparam->primary_path = &work->path[0];\n\tcm_opa_to_ib_sgid(work, param->primary_path);\n\tif (cm_req_has_alt_path(req_msg)) {\n\t\tparam->alternate_path = &work->path[1];\n\t\tcm_opa_to_ib_sgid(work, param->alternate_path);\n\t} else {\n\t\tparam->alternate_path = NULL;\n\t}\n\tparam->remote_ca_guid =\n\t\tcpu_to_be64(IBA_GET(CM_REQ_LOCAL_CA_GUID, req_msg));\n\tparam->remote_qkey = IBA_GET(CM_REQ_LOCAL_Q_KEY, req_msg);\n\tparam->remote_qpn = IBA_GET(CM_REQ_LOCAL_QPN, req_msg);\n\tparam->qp_type = cm_req_get_qp_type(req_msg);\n\tparam->starting_psn = IBA_GET(CM_REQ_STARTING_PSN, req_msg);\n\tparam->responder_resources = IBA_GET(CM_REQ_INITIATOR_DEPTH, req_msg);\n\tparam->initiator_depth = IBA_GET(CM_REQ_RESPONDER_RESOURCES, req_msg);\n\tparam->local_cm_response_timeout =\n\t\tIBA_GET(CM_REQ_REMOTE_CM_RESPONSE_TIMEOUT, req_msg);\n\tparam->flow_control = IBA_GET(CM_REQ_END_TO_END_FLOW_CONTROL, req_msg);\n\tparam->remote_cm_response_timeout =\n\t\tIBA_GET(CM_REQ_LOCAL_CM_RESPONSE_TIMEOUT, req_msg);\n\tparam->retry_count = IBA_GET(CM_REQ_RETRY_COUNT, req_msg);\n\tparam->rnr_retry_count = IBA_GET(CM_REQ_RNR_RETRY_COUNT, req_msg);\n\tparam->srq = IBA_GET(CM_REQ_SRQ, req_msg);\n\tparam->ppath_sgid_attr = cm_id_priv->av.ah_attr.grh.sgid_attr;\n\tparam->ece.vendor_id = IBA_GET(CM_REQ_VENDOR_ID, req_msg);\n\tparam->ece.attr_mod = be32_to_cpu(req_msg->hdr.attr_mod);\n\n\twork->cm_event.private_data =\n\t\tIBA_GET_MEM_PTR(CM_REQ_PRIVATE_DATA, req_msg);\n}\n\nstatic void cm_process_work(struct cm_id_private *cm_id_priv,\n\t\t\t    struct cm_work *work)\n{\n\tint ret;\n\n\t \n\tret = cm_id_priv->id.cm_handler(&cm_id_priv->id, &work->cm_event);\n\tcm_free_work(work);\n\n\twhile (!ret && !atomic_add_negative(-1, &cm_id_priv->work_count)) {\n\t\tspin_lock_irq(&cm_id_priv->lock);\n\t\twork = cm_dequeue_work(cm_id_priv);\n\t\tspin_unlock_irq(&cm_id_priv->lock);\n\t\tif (!work)\n\t\t\treturn;\n\n\t\tret = cm_id_priv->id.cm_handler(&cm_id_priv->id,\n\t\t\t\t\t\t&work->cm_event);\n\t\tcm_free_work(work);\n\t}\n\tcm_deref_id(cm_id_priv);\n\tif (ret)\n\t\tcm_destroy_id(&cm_id_priv->id, ret);\n}\n\nstatic void cm_format_mra(struct cm_mra_msg *mra_msg,\n\t\t\t  struct cm_id_private *cm_id_priv,\n\t\t\t  enum cm_msg_response msg_mraed, u8 service_timeout,\n\t\t\t  const void *private_data, u8 private_data_len)\n{\n\tcm_format_mad_hdr(&mra_msg->hdr, CM_MRA_ATTR_ID, cm_id_priv->tid);\n\tIBA_SET(CM_MRA_MESSAGE_MRAED, mra_msg, msg_mraed);\n\tIBA_SET(CM_MRA_LOCAL_COMM_ID, mra_msg,\n\t\tbe32_to_cpu(cm_id_priv->id.local_id));\n\tIBA_SET(CM_MRA_REMOTE_COMM_ID, mra_msg,\n\t\tbe32_to_cpu(cm_id_priv->id.remote_id));\n\tIBA_SET(CM_MRA_SERVICE_TIMEOUT, mra_msg, service_timeout);\n\n\tif (private_data && private_data_len)\n\t\tIBA_SET_MEM(CM_MRA_PRIVATE_DATA, mra_msg, private_data,\n\t\t\t    private_data_len);\n}\n\nstatic void cm_format_rej(struct cm_rej_msg *rej_msg,\n\t\t\t  struct cm_id_private *cm_id_priv,\n\t\t\t  enum ib_cm_rej_reason reason, void *ari,\n\t\t\t  u8 ari_length, const void *private_data,\n\t\t\t  u8 private_data_len, enum ib_cm_state state)\n{\n\tlockdep_assert_held(&cm_id_priv->lock);\n\n\tcm_format_mad_hdr(&rej_msg->hdr, CM_REJ_ATTR_ID, cm_id_priv->tid);\n\tIBA_SET(CM_REJ_REMOTE_COMM_ID, rej_msg,\n\t\tbe32_to_cpu(cm_id_priv->id.remote_id));\n\n\tswitch (state) {\n\tcase IB_CM_REQ_RCVD:\n\t\tIBA_SET(CM_REJ_LOCAL_COMM_ID, rej_msg, be32_to_cpu(0));\n\t\tIBA_SET(CM_REJ_MESSAGE_REJECTED, rej_msg, CM_MSG_RESPONSE_REQ);\n\t\tbreak;\n\tcase IB_CM_MRA_REQ_SENT:\n\t\tIBA_SET(CM_REJ_LOCAL_COMM_ID, rej_msg,\n\t\t\tbe32_to_cpu(cm_id_priv->id.local_id));\n\t\tIBA_SET(CM_REJ_MESSAGE_REJECTED, rej_msg, CM_MSG_RESPONSE_REQ);\n\t\tbreak;\n\tcase IB_CM_REP_RCVD:\n\tcase IB_CM_MRA_REP_SENT:\n\t\tIBA_SET(CM_REJ_LOCAL_COMM_ID, rej_msg,\n\t\t\tbe32_to_cpu(cm_id_priv->id.local_id));\n\t\tIBA_SET(CM_REJ_MESSAGE_REJECTED, rej_msg, CM_MSG_RESPONSE_REP);\n\t\tbreak;\n\tdefault:\n\t\tIBA_SET(CM_REJ_LOCAL_COMM_ID, rej_msg,\n\t\t\tbe32_to_cpu(cm_id_priv->id.local_id));\n\t\tIBA_SET(CM_REJ_MESSAGE_REJECTED, rej_msg,\n\t\t\tCM_MSG_RESPONSE_OTHER);\n\t\tbreak;\n\t}\n\n\tIBA_SET(CM_REJ_REASON, rej_msg, reason);\n\tif (ari && ari_length) {\n\t\tIBA_SET(CM_REJ_REJECTED_INFO_LENGTH, rej_msg, ari_length);\n\t\tIBA_SET_MEM(CM_REJ_ARI, rej_msg, ari, ari_length);\n\t}\n\n\tif (private_data && private_data_len)\n\t\tIBA_SET_MEM(CM_REJ_PRIVATE_DATA, rej_msg, private_data,\n\t\t\t    private_data_len);\n}\n\nstatic void cm_dup_req_handler(struct cm_work *work,\n\t\t\t       struct cm_id_private *cm_id_priv)\n{\n\tstruct ib_mad_send_buf *msg = NULL;\n\tint ret;\n\n\tatomic_long_inc(\n\t\t&work->port->counters[CM_RECV_DUPLICATES][CM_REQ_COUNTER]);\n\n\t \n\tspin_lock_irq(&cm_id_priv->lock);\n\tif (cm_id_priv->id.state == IB_CM_REQ_RCVD) {\n\t\tspin_unlock_irq(&cm_id_priv->lock);\n\t\treturn;\n\t}\n\tspin_unlock_irq(&cm_id_priv->lock);\n\n\tret = cm_alloc_response_msg(work->port, work->mad_recv_wc, &msg);\n\tif (ret)\n\t\treturn;\n\n\tspin_lock_irq(&cm_id_priv->lock);\n\tswitch (cm_id_priv->id.state) {\n\tcase IB_CM_MRA_REQ_SENT:\n\t\tcm_format_mra((struct cm_mra_msg *) msg->mad, cm_id_priv,\n\t\t\t      CM_MSG_RESPONSE_REQ, cm_id_priv->service_timeout,\n\t\t\t      cm_id_priv->private_data,\n\t\t\t      cm_id_priv->private_data_len);\n\t\tbreak;\n\tcase IB_CM_TIMEWAIT:\n\t\tcm_format_rej((struct cm_rej_msg *)msg->mad, cm_id_priv,\n\t\t\t      IB_CM_REJ_STALE_CONN, NULL, 0, NULL, 0,\n\t\t\t      IB_CM_TIMEWAIT);\n\t\tbreak;\n\tdefault:\n\t\tgoto unlock;\n\t}\n\tspin_unlock_irq(&cm_id_priv->lock);\n\n\ttrace_icm_send_dup_req(&cm_id_priv->id);\n\tret = ib_post_send_mad(msg, NULL);\n\tif (ret)\n\t\tgoto free;\n\treturn;\n\nunlock:\tspin_unlock_irq(&cm_id_priv->lock);\nfree:\tcm_free_response_msg(msg);\n}\n\nstatic struct cm_id_private *cm_match_req(struct cm_work *work,\n\t\t\t\t\t  struct cm_id_private *cm_id_priv)\n{\n\tstruct cm_id_private *listen_cm_id_priv, *cur_cm_id_priv;\n\tstruct cm_timewait_info *timewait_info;\n\tstruct cm_req_msg *req_msg;\n\n\treq_msg = (struct cm_req_msg *)work->mad_recv_wc->recv_buf.mad;\n\n\t \n\tspin_lock_irq(&cm.lock);\n\ttimewait_info = cm_insert_remote_id(cm_id_priv->timewait_info);\n\tif (timewait_info) {\n\t\tcur_cm_id_priv = cm_acquire_id(timewait_info->work.local_id,\n\t\t\t\t\t   timewait_info->work.remote_id);\n\t\tspin_unlock_irq(&cm.lock);\n\t\tif (cur_cm_id_priv) {\n\t\t\tcm_dup_req_handler(work, cur_cm_id_priv);\n\t\t\tcm_deref_id(cur_cm_id_priv);\n\t\t}\n\t\treturn NULL;\n\t}\n\n\t \n\ttimewait_info = cm_insert_remote_qpn(cm_id_priv->timewait_info);\n\tif (timewait_info) {\n\t\tcm_remove_remote(cm_id_priv);\n\t\tcur_cm_id_priv = cm_acquire_id(timewait_info->work.local_id,\n\t\t\t\t\t   timewait_info->work.remote_id);\n\n\t\tspin_unlock_irq(&cm.lock);\n\t\tcm_issue_rej(work->port, work->mad_recv_wc,\n\t\t\t     IB_CM_REJ_STALE_CONN, CM_MSG_RESPONSE_REQ,\n\t\t\t     NULL, 0);\n\t\tif (cur_cm_id_priv) {\n\t\t\tib_send_cm_dreq(&cur_cm_id_priv->id, NULL, 0);\n\t\t\tcm_deref_id(cur_cm_id_priv);\n\t\t}\n\t\treturn NULL;\n\t}\n\n\t \n\tlisten_cm_id_priv = cm_find_listen(\n\t\tcm_id_priv->id.device,\n\t\tcpu_to_be64(IBA_GET(CM_REQ_SERVICE_ID, req_msg)));\n\tif (!listen_cm_id_priv) {\n\t\tcm_remove_remote(cm_id_priv);\n\t\tspin_unlock_irq(&cm.lock);\n\t\tcm_issue_rej(work->port, work->mad_recv_wc,\n\t\t\t     IB_CM_REJ_INVALID_SERVICE_ID, CM_MSG_RESPONSE_REQ,\n\t\t\t     NULL, 0);\n\t\treturn NULL;\n\t}\n\tspin_unlock_irq(&cm.lock);\n\treturn listen_cm_id_priv;\n}\n\n \nstatic void cm_process_routed_req(struct cm_req_msg *req_msg, struct ib_wc *wc)\n{\n\tif (!IBA_GET(CM_REQ_PRIMARY_SUBNET_LOCAL, req_msg)) {\n\t\tif (cpu_to_be16(IBA_GET(CM_REQ_PRIMARY_LOCAL_PORT_LID,\n\t\t\t\t\treq_msg)) == IB_LID_PERMISSIVE) {\n\t\t\tIBA_SET(CM_REQ_PRIMARY_LOCAL_PORT_LID, req_msg,\n\t\t\t\tbe16_to_cpu(ib_lid_be16(wc->slid)));\n\t\t\tIBA_SET(CM_REQ_PRIMARY_SL, req_msg, wc->sl);\n\t\t}\n\n\t\tif (cpu_to_be16(IBA_GET(CM_REQ_PRIMARY_REMOTE_PORT_LID,\n\t\t\t\t\treq_msg)) == IB_LID_PERMISSIVE)\n\t\t\tIBA_SET(CM_REQ_PRIMARY_REMOTE_PORT_LID, req_msg,\n\t\t\t\twc->dlid_path_bits);\n\t}\n\n\tif (!IBA_GET(CM_REQ_ALTERNATE_SUBNET_LOCAL, req_msg)) {\n\t\tif (cpu_to_be16(IBA_GET(CM_REQ_ALTERNATE_LOCAL_PORT_LID,\n\t\t\t\t\treq_msg)) == IB_LID_PERMISSIVE) {\n\t\t\tIBA_SET(CM_REQ_ALTERNATE_LOCAL_PORT_LID, req_msg,\n\t\t\t\tbe16_to_cpu(ib_lid_be16(wc->slid)));\n\t\t\tIBA_SET(CM_REQ_ALTERNATE_SL, req_msg, wc->sl);\n\t\t}\n\n\t\tif (cpu_to_be16(IBA_GET(CM_REQ_ALTERNATE_REMOTE_PORT_LID,\n\t\t\t\t\treq_msg)) == IB_LID_PERMISSIVE)\n\t\t\tIBA_SET(CM_REQ_ALTERNATE_REMOTE_PORT_LID, req_msg,\n\t\t\t\twc->dlid_path_bits);\n\t}\n}\n\nstatic int cm_req_handler(struct cm_work *work)\n{\n\tstruct cm_id_private *cm_id_priv, *listen_cm_id_priv;\n\tstruct cm_req_msg *req_msg;\n\tconst struct ib_global_route *grh;\n\tconst struct ib_gid_attr *gid_attr;\n\tint ret;\n\n\treq_msg = (struct cm_req_msg *)work->mad_recv_wc->recv_buf.mad;\n\n\tcm_id_priv =\n\t\tcm_alloc_id_priv(work->port->cm_dev->ib_device, NULL, NULL);\n\tif (IS_ERR(cm_id_priv))\n\t\treturn PTR_ERR(cm_id_priv);\n\n\tcm_id_priv->id.remote_id =\n\t\tcpu_to_be32(IBA_GET(CM_REQ_LOCAL_COMM_ID, req_msg));\n\tcm_id_priv->id.service_id =\n\t\tcpu_to_be64(IBA_GET(CM_REQ_SERVICE_ID, req_msg));\n\tcm_id_priv->tid = req_msg->hdr.tid;\n\tcm_id_priv->timeout_ms = cm_convert_to_ms(\n\t\tIBA_GET(CM_REQ_LOCAL_CM_RESPONSE_TIMEOUT, req_msg));\n\tcm_id_priv->max_cm_retries = IBA_GET(CM_REQ_MAX_CM_RETRIES, req_msg);\n\tcm_id_priv->remote_qpn =\n\t\tcpu_to_be32(IBA_GET(CM_REQ_LOCAL_QPN, req_msg));\n\tcm_id_priv->initiator_depth =\n\t\tIBA_GET(CM_REQ_RESPONDER_RESOURCES, req_msg);\n\tcm_id_priv->responder_resources =\n\t\tIBA_GET(CM_REQ_INITIATOR_DEPTH, req_msg);\n\tcm_id_priv->path_mtu = IBA_GET(CM_REQ_PATH_PACKET_PAYLOAD_MTU, req_msg);\n\tcm_id_priv->pkey = cpu_to_be16(IBA_GET(CM_REQ_PARTITION_KEY, req_msg));\n\tcm_id_priv->sq_psn = cpu_to_be32(IBA_GET(CM_REQ_STARTING_PSN, req_msg));\n\tcm_id_priv->retry_count = IBA_GET(CM_REQ_RETRY_COUNT, req_msg);\n\tcm_id_priv->rnr_retry_count = IBA_GET(CM_REQ_RNR_RETRY_COUNT, req_msg);\n\tcm_id_priv->qp_type = cm_req_get_qp_type(req_msg);\n\n\tret = cm_init_av_for_response(work->port, work->mad_recv_wc->wc,\n\t\t\t\t      work->mad_recv_wc->recv_buf.grh,\n\t\t\t\t      &cm_id_priv->av);\n\tif (ret)\n\t\tgoto destroy;\n\tcm_id_priv->timewait_info = cm_create_timewait_info(cm_id_priv->\n\t\t\t\t\t\t\t    id.local_id);\n\tif (IS_ERR(cm_id_priv->timewait_info)) {\n\t\tret = PTR_ERR(cm_id_priv->timewait_info);\n\t\tcm_id_priv->timewait_info = NULL;\n\t\tgoto destroy;\n\t}\n\tcm_id_priv->timewait_info->work.remote_id = cm_id_priv->id.remote_id;\n\tcm_id_priv->timewait_info->remote_ca_guid =\n\t\tcpu_to_be64(IBA_GET(CM_REQ_LOCAL_CA_GUID, req_msg));\n\tcm_id_priv->timewait_info->remote_qpn = cm_id_priv->remote_qpn;\n\n\t \n\tcm_id_priv->id.state = IB_CM_REQ_RCVD;\n\n\tlisten_cm_id_priv = cm_match_req(work, cm_id_priv);\n\tif (!listen_cm_id_priv) {\n\t\ttrace_icm_no_listener_err(&cm_id_priv->id);\n\t\tcm_id_priv->id.state = IB_CM_IDLE;\n\t\tret = -EINVAL;\n\t\tgoto destroy;\n\t}\n\n\tmemset(&work->path[0], 0, sizeof(work->path[0]));\n\tif (cm_req_has_alt_path(req_msg))\n\t\tmemset(&work->path[1], 0, sizeof(work->path[1]));\n\tgrh = rdma_ah_read_grh(&cm_id_priv->av.ah_attr);\n\tgid_attr = grh->sgid_attr;\n\n\tif (cm_id_priv->av.ah_attr.type == RDMA_AH_ATTR_TYPE_ROCE) {\n\t\twork->path[0].rec_type =\n\t\t\tsa_conv_gid_to_pathrec_type(gid_attr->gid_type);\n\t} else {\n\t\tcm_process_routed_req(req_msg, work->mad_recv_wc->wc);\n\t\tcm_path_set_rec_type(\n\t\t\twork->port->cm_dev->ib_device, work->port->port_num,\n\t\t\t&work->path[0],\n\t\t\tIBA_GET_MEM_PTR(CM_REQ_PRIMARY_LOCAL_PORT_GID,\n\t\t\t\t\treq_msg));\n\t}\n\tif (cm_req_has_alt_path(req_msg))\n\t\twork->path[1].rec_type = work->path[0].rec_type;\n\tcm_format_paths_from_req(req_msg, &work->path[0],\n\t\t\t\t &work->path[1], work->mad_recv_wc->wc);\n\tif (cm_id_priv->av.ah_attr.type == RDMA_AH_ATTR_TYPE_ROCE)\n\t\tsa_path_set_dmac(&work->path[0],\n\t\t\t\t cm_id_priv->av.ah_attr.roce.dmac);\n\twork->path[0].hop_limit = grh->hop_limit;\n\n\t \n\tcm_destroy_av(&cm_id_priv->av);\n\tret = cm_init_av_by_path(&work->path[0], gid_attr, &cm_id_priv->av);\n\tif (ret) {\n\t\tint err;\n\n\t\terr = rdma_query_gid(work->port->cm_dev->ib_device,\n\t\t\t\t     work->port->port_num, 0,\n\t\t\t\t     &work->path[0].sgid);\n\t\tif (err)\n\t\t\tib_send_cm_rej(&cm_id_priv->id, IB_CM_REJ_INVALID_GID,\n\t\t\t\t       NULL, 0, NULL, 0);\n\t\telse\n\t\t\tib_send_cm_rej(&cm_id_priv->id, IB_CM_REJ_INVALID_GID,\n\t\t\t\t       &work->path[0].sgid,\n\t\t\t\t       sizeof(work->path[0].sgid),\n\t\t\t\t       NULL, 0);\n\t\tgoto rejected;\n\t}\n\tif (cm_id_priv->av.ah_attr.type == RDMA_AH_ATTR_TYPE_IB)\n\t\tcm_id_priv->av.dlid_datapath =\n\t\t\tIBA_GET(CM_REQ_PRIMARY_LOCAL_PORT_LID, req_msg);\n\n\tif (cm_req_has_alt_path(req_msg)) {\n\t\tret = cm_init_av_by_path(&work->path[1], NULL,\n\t\t\t\t\t &cm_id_priv->alt_av);\n\t\tif (ret) {\n\t\t\tib_send_cm_rej(&cm_id_priv->id,\n\t\t\t\t       IB_CM_REJ_INVALID_ALT_GID,\n\t\t\t\t       &work->path[0].sgid,\n\t\t\t\t       sizeof(work->path[0].sgid), NULL, 0);\n\t\t\tgoto rejected;\n\t\t}\n\t}\n\n\tcm_id_priv->id.cm_handler = listen_cm_id_priv->id.cm_handler;\n\tcm_id_priv->id.context = listen_cm_id_priv->id.context;\n\tcm_format_req_event(work, cm_id_priv, &listen_cm_id_priv->id);\n\n\t \n\tspin_lock_irq(&cm_id_priv->lock);\n\tcm_finalize_id(cm_id_priv);\n\n\t \n\trefcount_inc(&cm_id_priv->refcount);\n\tcm_queue_work_unlock(cm_id_priv, work);\n\t \n\tcm_deref_id(listen_cm_id_priv);\n\treturn 0;\n\nrejected:\n\tcm_deref_id(listen_cm_id_priv);\ndestroy:\n\tib_destroy_cm_id(&cm_id_priv->id);\n\treturn ret;\n}\n\nstatic void cm_format_rep(struct cm_rep_msg *rep_msg,\n\t\t\t  struct cm_id_private *cm_id_priv,\n\t\t\t  struct ib_cm_rep_param *param)\n{\n\tcm_format_mad_ece_hdr(&rep_msg->hdr, CM_REP_ATTR_ID, cm_id_priv->tid,\n\t\t\t      param->ece.attr_mod);\n\tIBA_SET(CM_REP_LOCAL_COMM_ID, rep_msg,\n\t\tbe32_to_cpu(cm_id_priv->id.local_id));\n\tIBA_SET(CM_REP_REMOTE_COMM_ID, rep_msg,\n\t\tbe32_to_cpu(cm_id_priv->id.remote_id));\n\tIBA_SET(CM_REP_STARTING_PSN, rep_msg, param->starting_psn);\n\tIBA_SET(CM_REP_RESPONDER_RESOURCES, rep_msg,\n\t\tparam->responder_resources);\n\tIBA_SET(CM_REP_TARGET_ACK_DELAY, rep_msg,\n\t\tcm_id_priv->av.port->cm_dev->ack_delay);\n\tIBA_SET(CM_REP_FAILOVER_ACCEPTED, rep_msg, param->failover_accepted);\n\tIBA_SET(CM_REP_RNR_RETRY_COUNT, rep_msg, param->rnr_retry_count);\n\tIBA_SET(CM_REP_LOCAL_CA_GUID, rep_msg,\n\t\tbe64_to_cpu(cm_id_priv->id.device->node_guid));\n\n\tif (cm_id_priv->qp_type != IB_QPT_XRC_TGT) {\n\t\tIBA_SET(CM_REP_INITIATOR_DEPTH, rep_msg,\n\t\t\tparam->initiator_depth);\n\t\tIBA_SET(CM_REP_END_TO_END_FLOW_CONTROL, rep_msg,\n\t\t\tparam->flow_control);\n\t\tIBA_SET(CM_REP_SRQ, rep_msg, param->srq);\n\t\tIBA_SET(CM_REP_LOCAL_QPN, rep_msg, param->qp_num);\n\t} else {\n\t\tIBA_SET(CM_REP_SRQ, rep_msg, 1);\n\t\tIBA_SET(CM_REP_LOCAL_EE_CONTEXT_NUMBER, rep_msg, param->qp_num);\n\t}\n\n\tIBA_SET(CM_REP_VENDOR_ID_L, rep_msg, param->ece.vendor_id);\n\tIBA_SET(CM_REP_VENDOR_ID_M, rep_msg, param->ece.vendor_id >> 8);\n\tIBA_SET(CM_REP_VENDOR_ID_H, rep_msg, param->ece.vendor_id >> 16);\n\n\tif (param->private_data && param->private_data_len)\n\t\tIBA_SET_MEM(CM_REP_PRIVATE_DATA, rep_msg, param->private_data,\n\t\t\t    param->private_data_len);\n}\n\nint ib_send_cm_rep(struct ib_cm_id *cm_id,\n\t\t   struct ib_cm_rep_param *param)\n{\n\tstruct cm_id_private *cm_id_priv;\n\tstruct ib_mad_send_buf *msg;\n\tstruct cm_rep_msg *rep_msg;\n\tunsigned long flags;\n\tint ret;\n\n\tif (param->private_data &&\n\t    param->private_data_len > IB_CM_REP_PRIVATE_DATA_SIZE)\n\t\treturn -EINVAL;\n\n\tcm_id_priv = container_of(cm_id, struct cm_id_private, id);\n\tspin_lock_irqsave(&cm_id_priv->lock, flags);\n\tif (cm_id->state != IB_CM_REQ_RCVD &&\n\t    cm_id->state != IB_CM_MRA_REQ_SENT) {\n\t\ttrace_icm_send_rep_err(cm_id_priv->id.local_id, cm_id->state);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmsg = cm_alloc_priv_msg(cm_id_priv);\n\tif (IS_ERR(msg)) {\n\t\tret = PTR_ERR(msg);\n\t\tgoto out;\n\t}\n\n\trep_msg = (struct cm_rep_msg *) msg->mad;\n\tcm_format_rep(rep_msg, cm_id_priv, param);\n\tmsg->timeout_ms = cm_id_priv->timeout_ms;\n\tmsg->context[1] = (void *) (unsigned long) IB_CM_REP_SENT;\n\n\ttrace_icm_send_rep(cm_id);\n\tret = ib_post_send_mad(msg, NULL);\n\tif (ret)\n\t\tgoto out_free;\n\n\tcm_id->state = IB_CM_REP_SENT;\n\tcm_id_priv->initiator_depth = param->initiator_depth;\n\tcm_id_priv->responder_resources = param->responder_resources;\n\tcm_id_priv->rq_psn = cpu_to_be32(IBA_GET(CM_REP_STARTING_PSN, rep_msg));\n\tWARN_ONCE(param->qp_num & 0xFF000000,\n\t\t  \"IBTA declares QPN to be 24 bits, but it is 0x%X\\n\",\n\t\t  param->qp_num);\n\tcm_id_priv->local_qpn = cpu_to_be32(param->qp_num & 0xFFFFFF);\n\tspin_unlock_irqrestore(&cm_id_priv->lock, flags);\n\treturn 0;\n\nout_free:\n\tcm_free_priv_msg(msg);\nout:\n\tspin_unlock_irqrestore(&cm_id_priv->lock, flags);\n\treturn ret;\n}\nEXPORT_SYMBOL(ib_send_cm_rep);\n\nstatic void cm_format_rtu(struct cm_rtu_msg *rtu_msg,\n\t\t\t  struct cm_id_private *cm_id_priv,\n\t\t\t  const void *private_data,\n\t\t\t  u8 private_data_len)\n{\n\tcm_format_mad_hdr(&rtu_msg->hdr, CM_RTU_ATTR_ID, cm_id_priv->tid);\n\tIBA_SET(CM_RTU_LOCAL_COMM_ID, rtu_msg,\n\t\tbe32_to_cpu(cm_id_priv->id.local_id));\n\tIBA_SET(CM_RTU_REMOTE_COMM_ID, rtu_msg,\n\t\tbe32_to_cpu(cm_id_priv->id.remote_id));\n\n\tif (private_data && private_data_len)\n\t\tIBA_SET_MEM(CM_RTU_PRIVATE_DATA, rtu_msg, private_data,\n\t\t\t    private_data_len);\n}\n\nint ib_send_cm_rtu(struct ib_cm_id *cm_id,\n\t\t   const void *private_data,\n\t\t   u8 private_data_len)\n{\n\tstruct cm_id_private *cm_id_priv;\n\tstruct ib_mad_send_buf *msg;\n\tunsigned long flags;\n\tvoid *data;\n\tint ret;\n\n\tif (private_data && private_data_len > IB_CM_RTU_PRIVATE_DATA_SIZE)\n\t\treturn -EINVAL;\n\n\tdata = cm_copy_private_data(private_data, private_data_len);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tcm_id_priv = container_of(cm_id, struct cm_id_private, id);\n\tspin_lock_irqsave(&cm_id_priv->lock, flags);\n\tif (cm_id->state != IB_CM_REP_RCVD &&\n\t    cm_id->state != IB_CM_MRA_REP_SENT) {\n\t\ttrace_icm_send_cm_rtu_err(cm_id);\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tmsg = cm_alloc_msg(cm_id_priv);\n\tif (IS_ERR(msg)) {\n\t\tret = PTR_ERR(msg);\n\t\tgoto error;\n\t}\n\n\tcm_format_rtu((struct cm_rtu_msg *) msg->mad, cm_id_priv,\n\t\t      private_data, private_data_len);\n\n\ttrace_icm_send_rtu(cm_id);\n\tret = ib_post_send_mad(msg, NULL);\n\tif (ret) {\n\t\tspin_unlock_irqrestore(&cm_id_priv->lock, flags);\n\t\tcm_free_msg(msg);\n\t\tkfree(data);\n\t\treturn ret;\n\t}\n\n\tcm_id->state = IB_CM_ESTABLISHED;\n\tcm_set_private_data(cm_id_priv, data, private_data_len);\n\tspin_unlock_irqrestore(&cm_id_priv->lock, flags);\n\treturn 0;\n\nerror:\tspin_unlock_irqrestore(&cm_id_priv->lock, flags);\n\tkfree(data);\n\treturn ret;\n}\nEXPORT_SYMBOL(ib_send_cm_rtu);\n\nstatic void cm_format_rep_event(struct cm_work *work, enum ib_qp_type qp_type)\n{\n\tstruct cm_rep_msg *rep_msg;\n\tstruct ib_cm_rep_event_param *param;\n\n\trep_msg = (struct cm_rep_msg *)work->mad_recv_wc->recv_buf.mad;\n\tparam = &work->cm_event.param.rep_rcvd;\n\tparam->remote_ca_guid =\n\t\tcpu_to_be64(IBA_GET(CM_REP_LOCAL_CA_GUID, rep_msg));\n\tparam->remote_qkey = IBA_GET(CM_REP_LOCAL_Q_KEY, rep_msg);\n\tparam->remote_qpn = be32_to_cpu(cm_rep_get_qpn(rep_msg, qp_type));\n\tparam->starting_psn = IBA_GET(CM_REP_STARTING_PSN, rep_msg);\n\tparam->responder_resources = IBA_GET(CM_REP_INITIATOR_DEPTH, rep_msg);\n\tparam->initiator_depth = IBA_GET(CM_REP_RESPONDER_RESOURCES, rep_msg);\n\tparam->target_ack_delay = IBA_GET(CM_REP_TARGET_ACK_DELAY, rep_msg);\n\tparam->failover_accepted = IBA_GET(CM_REP_FAILOVER_ACCEPTED, rep_msg);\n\tparam->flow_control = IBA_GET(CM_REP_END_TO_END_FLOW_CONTROL, rep_msg);\n\tparam->rnr_retry_count = IBA_GET(CM_REP_RNR_RETRY_COUNT, rep_msg);\n\tparam->srq = IBA_GET(CM_REP_SRQ, rep_msg);\n\tparam->ece.vendor_id = IBA_GET(CM_REP_VENDOR_ID_H, rep_msg) << 16;\n\tparam->ece.vendor_id |= IBA_GET(CM_REP_VENDOR_ID_M, rep_msg) << 8;\n\tparam->ece.vendor_id |= IBA_GET(CM_REP_VENDOR_ID_L, rep_msg);\n\tparam->ece.attr_mod = be32_to_cpu(rep_msg->hdr.attr_mod);\n\n\twork->cm_event.private_data =\n\t\tIBA_GET_MEM_PTR(CM_REP_PRIVATE_DATA, rep_msg);\n}\n\nstatic void cm_dup_rep_handler(struct cm_work *work)\n{\n\tstruct cm_id_private *cm_id_priv;\n\tstruct cm_rep_msg *rep_msg;\n\tstruct ib_mad_send_buf *msg = NULL;\n\tint ret;\n\n\trep_msg = (struct cm_rep_msg *) work->mad_recv_wc->recv_buf.mad;\n\tcm_id_priv = cm_acquire_id(\n\t\tcpu_to_be32(IBA_GET(CM_REP_REMOTE_COMM_ID, rep_msg)),\n\t\tcpu_to_be32(IBA_GET(CM_REP_LOCAL_COMM_ID, rep_msg)));\n\tif (!cm_id_priv)\n\t\treturn;\n\n\tatomic_long_inc(\n\t\t&work->port->counters[CM_RECV_DUPLICATES][CM_REP_COUNTER]);\n\tret = cm_alloc_response_msg(work->port, work->mad_recv_wc, &msg);\n\tif (ret)\n\t\tgoto deref;\n\n\tspin_lock_irq(&cm_id_priv->lock);\n\tif (cm_id_priv->id.state == IB_CM_ESTABLISHED)\n\t\tcm_format_rtu((struct cm_rtu_msg *) msg->mad, cm_id_priv,\n\t\t\t      cm_id_priv->private_data,\n\t\t\t      cm_id_priv->private_data_len);\n\telse if (cm_id_priv->id.state == IB_CM_MRA_REP_SENT)\n\t\tcm_format_mra((struct cm_mra_msg *) msg->mad, cm_id_priv,\n\t\t\t      CM_MSG_RESPONSE_REP, cm_id_priv->service_timeout,\n\t\t\t      cm_id_priv->private_data,\n\t\t\t      cm_id_priv->private_data_len);\n\telse\n\t\tgoto unlock;\n\tspin_unlock_irq(&cm_id_priv->lock);\n\n\ttrace_icm_send_dup_rep(&cm_id_priv->id);\n\tret = ib_post_send_mad(msg, NULL);\n\tif (ret)\n\t\tgoto free;\n\tgoto deref;\n\nunlock:\tspin_unlock_irq(&cm_id_priv->lock);\nfree:\tcm_free_response_msg(msg);\nderef:\tcm_deref_id(cm_id_priv);\n}\n\nstatic int cm_rep_handler(struct cm_work *work)\n{\n\tstruct cm_id_private *cm_id_priv;\n\tstruct cm_rep_msg *rep_msg;\n\tint ret;\n\tstruct cm_id_private *cur_cm_id_priv;\n\tstruct cm_timewait_info *timewait_info;\n\n\trep_msg = (struct cm_rep_msg *)work->mad_recv_wc->recv_buf.mad;\n\tcm_id_priv = cm_acquire_id(\n\t\tcpu_to_be32(IBA_GET(CM_REP_REMOTE_COMM_ID, rep_msg)), 0);\n\tif (!cm_id_priv) {\n\t\tcm_dup_rep_handler(work);\n\t\ttrace_icm_remote_no_priv_err(\n\t\t\t IBA_GET(CM_REP_REMOTE_COMM_ID, rep_msg));\n\t\treturn -EINVAL;\n\t}\n\n\tcm_format_rep_event(work, cm_id_priv->qp_type);\n\n\tspin_lock_irq(&cm_id_priv->lock);\n\tswitch (cm_id_priv->id.state) {\n\tcase IB_CM_REQ_SENT:\n\tcase IB_CM_MRA_REQ_RCVD:\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\ttrace_icm_rep_unknown_err(\n\t\t\tIBA_GET(CM_REP_LOCAL_COMM_ID, rep_msg),\n\t\t\tIBA_GET(CM_REP_REMOTE_COMM_ID, rep_msg),\n\t\t\tcm_id_priv->id.state);\n\t\tspin_unlock_irq(&cm_id_priv->lock);\n\t\tgoto error;\n\t}\n\n\tcm_id_priv->timewait_info->work.remote_id =\n\t\tcpu_to_be32(IBA_GET(CM_REP_LOCAL_COMM_ID, rep_msg));\n\tcm_id_priv->timewait_info->remote_ca_guid =\n\t\tcpu_to_be64(IBA_GET(CM_REP_LOCAL_CA_GUID, rep_msg));\n\tcm_id_priv->timewait_info->remote_qpn = cm_rep_get_qpn(rep_msg, cm_id_priv->qp_type);\n\n\tspin_lock(&cm.lock);\n\t \n\tif (cm_insert_remote_id(cm_id_priv->timewait_info)) {\n\t\tspin_unlock(&cm.lock);\n\t\tspin_unlock_irq(&cm_id_priv->lock);\n\t\tret = -EINVAL;\n\t\ttrace_icm_insert_failed_err(\n\t\t\t IBA_GET(CM_REP_REMOTE_COMM_ID, rep_msg));\n\t\tgoto error;\n\t}\n\t \n\ttimewait_info = cm_insert_remote_qpn(cm_id_priv->timewait_info);\n\tif (timewait_info) {\n\t\tcm_remove_remote(cm_id_priv);\n\t\tcur_cm_id_priv = cm_acquire_id(timewait_info->work.local_id,\n\t\t\t\t\t   timewait_info->work.remote_id);\n\n\t\tspin_unlock(&cm.lock);\n\t\tspin_unlock_irq(&cm_id_priv->lock);\n\t\tcm_issue_rej(work->port, work->mad_recv_wc,\n\t\t\t     IB_CM_REJ_STALE_CONN, CM_MSG_RESPONSE_REP,\n\t\t\t     NULL, 0);\n\t\tret = -EINVAL;\n\t\ttrace_icm_staleconn_err(\n\t\t\tIBA_GET(CM_REP_LOCAL_COMM_ID, rep_msg),\n\t\t\tIBA_GET(CM_REP_REMOTE_COMM_ID, rep_msg));\n\n\t\tif (cur_cm_id_priv) {\n\t\t\tib_send_cm_dreq(&cur_cm_id_priv->id, NULL, 0);\n\t\t\tcm_deref_id(cur_cm_id_priv);\n\t\t}\n\n\t\tgoto error;\n\t}\n\tspin_unlock(&cm.lock);\n\n\tcm_id_priv->id.state = IB_CM_REP_RCVD;\n\tcm_id_priv->id.remote_id =\n\t\tcpu_to_be32(IBA_GET(CM_REP_LOCAL_COMM_ID, rep_msg));\n\tcm_id_priv->remote_qpn = cm_rep_get_qpn(rep_msg, cm_id_priv->qp_type);\n\tcm_id_priv->initiator_depth =\n\t\tIBA_GET(CM_REP_RESPONDER_RESOURCES, rep_msg);\n\tcm_id_priv->responder_resources =\n\t\tIBA_GET(CM_REP_INITIATOR_DEPTH, rep_msg);\n\tcm_id_priv->sq_psn = cpu_to_be32(IBA_GET(CM_REP_STARTING_PSN, rep_msg));\n\tcm_id_priv->rnr_retry_count = IBA_GET(CM_REP_RNR_RETRY_COUNT, rep_msg);\n\tcm_id_priv->target_ack_delay =\n\t\tIBA_GET(CM_REP_TARGET_ACK_DELAY, rep_msg);\n\tcm_id_priv->av.timeout =\n\t\t\tcm_ack_timeout(cm_id_priv->target_ack_delay,\n\t\t\t\t       cm_id_priv->av.timeout - 1);\n\tcm_id_priv->alt_av.timeout =\n\t\t\tcm_ack_timeout(cm_id_priv->target_ack_delay,\n\t\t\t\t       cm_id_priv->alt_av.timeout - 1);\n\n\tib_cancel_mad(cm_id_priv->msg);\n\tcm_queue_work_unlock(cm_id_priv, work);\n\treturn 0;\n\nerror:\n\tcm_deref_id(cm_id_priv);\n\treturn ret;\n}\n\nstatic int cm_establish_handler(struct cm_work *work)\n{\n\tstruct cm_id_private *cm_id_priv;\n\n\t \n\tcm_id_priv = cm_acquire_id(work->local_id, work->remote_id);\n\tif (!cm_id_priv)\n\t\treturn -EINVAL;\n\n\tspin_lock_irq(&cm_id_priv->lock);\n\tif (cm_id_priv->id.state != IB_CM_ESTABLISHED) {\n\t\tspin_unlock_irq(&cm_id_priv->lock);\n\t\tgoto out;\n\t}\n\n\tib_cancel_mad(cm_id_priv->msg);\n\tcm_queue_work_unlock(cm_id_priv, work);\n\treturn 0;\nout:\n\tcm_deref_id(cm_id_priv);\n\treturn -EINVAL;\n}\n\nstatic int cm_rtu_handler(struct cm_work *work)\n{\n\tstruct cm_id_private *cm_id_priv;\n\tstruct cm_rtu_msg *rtu_msg;\n\n\trtu_msg = (struct cm_rtu_msg *)work->mad_recv_wc->recv_buf.mad;\n\tcm_id_priv = cm_acquire_id(\n\t\tcpu_to_be32(IBA_GET(CM_RTU_REMOTE_COMM_ID, rtu_msg)),\n\t\tcpu_to_be32(IBA_GET(CM_RTU_LOCAL_COMM_ID, rtu_msg)));\n\tif (!cm_id_priv)\n\t\treturn -EINVAL;\n\n\twork->cm_event.private_data =\n\t\tIBA_GET_MEM_PTR(CM_RTU_PRIVATE_DATA, rtu_msg);\n\n\tspin_lock_irq(&cm_id_priv->lock);\n\tif (cm_id_priv->id.state != IB_CM_REP_SENT &&\n\t    cm_id_priv->id.state != IB_CM_MRA_REP_RCVD) {\n\t\tspin_unlock_irq(&cm_id_priv->lock);\n\t\tatomic_long_inc(&work->port->counters[CM_RECV_DUPLICATES]\n\t\t\t\t\t\t     [CM_RTU_COUNTER]);\n\t\tgoto out;\n\t}\n\tcm_id_priv->id.state = IB_CM_ESTABLISHED;\n\n\tib_cancel_mad(cm_id_priv->msg);\n\tcm_queue_work_unlock(cm_id_priv, work);\n\treturn 0;\nout:\n\tcm_deref_id(cm_id_priv);\n\treturn -EINVAL;\n}\n\nstatic void cm_format_dreq(struct cm_dreq_msg *dreq_msg,\n\t\t\t  struct cm_id_private *cm_id_priv,\n\t\t\t  const void *private_data,\n\t\t\t  u8 private_data_len)\n{\n\tcm_format_mad_hdr(&dreq_msg->hdr, CM_DREQ_ATTR_ID,\n\t\t\t  cm_form_tid(cm_id_priv));\n\tIBA_SET(CM_DREQ_LOCAL_COMM_ID, dreq_msg,\n\t\tbe32_to_cpu(cm_id_priv->id.local_id));\n\tIBA_SET(CM_DREQ_REMOTE_COMM_ID, dreq_msg,\n\t\tbe32_to_cpu(cm_id_priv->id.remote_id));\n\tIBA_SET(CM_DREQ_REMOTE_QPN_EECN, dreq_msg,\n\t\tbe32_to_cpu(cm_id_priv->remote_qpn));\n\n\tif (private_data && private_data_len)\n\t\tIBA_SET_MEM(CM_DREQ_PRIVATE_DATA, dreq_msg, private_data,\n\t\t\t    private_data_len);\n}\n\nstatic int cm_send_dreq_locked(struct cm_id_private *cm_id_priv,\n\t\t\t       const void *private_data, u8 private_data_len)\n{\n\tstruct ib_mad_send_buf *msg;\n\tint ret;\n\n\tlockdep_assert_held(&cm_id_priv->lock);\n\n\tif (private_data && private_data_len > IB_CM_DREQ_PRIVATE_DATA_SIZE)\n\t\treturn -EINVAL;\n\n\tif (cm_id_priv->id.state != IB_CM_ESTABLISHED) {\n\t\ttrace_icm_dreq_skipped(&cm_id_priv->id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (cm_id_priv->id.lap_state == IB_CM_LAP_SENT ||\n\t    cm_id_priv->id.lap_state == IB_CM_MRA_LAP_RCVD)\n\t\tib_cancel_mad(cm_id_priv->msg);\n\n\tmsg = cm_alloc_priv_msg(cm_id_priv);\n\tif (IS_ERR(msg)) {\n\t\tcm_enter_timewait(cm_id_priv);\n\t\treturn PTR_ERR(msg);\n\t}\n\n\tcm_format_dreq((struct cm_dreq_msg *) msg->mad, cm_id_priv,\n\t\t       private_data, private_data_len);\n\tmsg->timeout_ms = cm_id_priv->timeout_ms;\n\tmsg->context[1] = (void *) (unsigned long) IB_CM_DREQ_SENT;\n\n\ttrace_icm_send_dreq(&cm_id_priv->id);\n\tret = ib_post_send_mad(msg, NULL);\n\tif (ret) {\n\t\tcm_enter_timewait(cm_id_priv);\n\t\tcm_free_priv_msg(msg);\n\t\treturn ret;\n\t}\n\n\tcm_id_priv->id.state = IB_CM_DREQ_SENT;\n\treturn 0;\n}\n\nint ib_send_cm_dreq(struct ib_cm_id *cm_id, const void *private_data,\n\t\t    u8 private_data_len)\n{\n\tstruct cm_id_private *cm_id_priv =\n\t\tcontainer_of(cm_id, struct cm_id_private, id);\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&cm_id_priv->lock, flags);\n\tret = cm_send_dreq_locked(cm_id_priv, private_data, private_data_len);\n\tspin_unlock_irqrestore(&cm_id_priv->lock, flags);\n\treturn ret;\n}\nEXPORT_SYMBOL(ib_send_cm_dreq);\n\nstatic void cm_format_drep(struct cm_drep_msg *drep_msg,\n\t\t\t  struct cm_id_private *cm_id_priv,\n\t\t\t  const void *private_data,\n\t\t\t  u8 private_data_len)\n{\n\tcm_format_mad_hdr(&drep_msg->hdr, CM_DREP_ATTR_ID, cm_id_priv->tid);\n\tIBA_SET(CM_DREP_LOCAL_COMM_ID, drep_msg,\n\t\tbe32_to_cpu(cm_id_priv->id.local_id));\n\tIBA_SET(CM_DREP_REMOTE_COMM_ID, drep_msg,\n\t\tbe32_to_cpu(cm_id_priv->id.remote_id));\n\n\tif (private_data && private_data_len)\n\t\tIBA_SET_MEM(CM_DREP_PRIVATE_DATA, drep_msg, private_data,\n\t\t\t    private_data_len);\n}\n\nstatic int cm_send_drep_locked(struct cm_id_private *cm_id_priv,\n\t\t\t       void *private_data, u8 private_data_len)\n{\n\tstruct ib_mad_send_buf *msg;\n\tint ret;\n\n\tlockdep_assert_held(&cm_id_priv->lock);\n\n\tif (private_data && private_data_len > IB_CM_DREP_PRIVATE_DATA_SIZE)\n\t\treturn -EINVAL;\n\n\tif (cm_id_priv->id.state != IB_CM_DREQ_RCVD) {\n\t\ttrace_icm_send_drep_err(&cm_id_priv->id);\n\t\tkfree(private_data);\n\t\treturn -EINVAL;\n\t}\n\n\tcm_set_private_data(cm_id_priv, private_data, private_data_len);\n\tcm_enter_timewait(cm_id_priv);\n\n\tmsg = cm_alloc_msg(cm_id_priv);\n\tif (IS_ERR(msg))\n\t\treturn PTR_ERR(msg);\n\n\tcm_format_drep((struct cm_drep_msg *) msg->mad, cm_id_priv,\n\t\t       private_data, private_data_len);\n\n\ttrace_icm_send_drep(&cm_id_priv->id);\n\tret = ib_post_send_mad(msg, NULL);\n\tif (ret) {\n\t\tcm_free_msg(msg);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nint ib_send_cm_drep(struct ib_cm_id *cm_id, const void *private_data,\n\t\t    u8 private_data_len)\n{\n\tstruct cm_id_private *cm_id_priv =\n\t\tcontainer_of(cm_id, struct cm_id_private, id);\n\tunsigned long flags;\n\tvoid *data;\n\tint ret;\n\n\tdata = cm_copy_private_data(private_data, private_data_len);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tspin_lock_irqsave(&cm_id_priv->lock, flags);\n\tret = cm_send_drep_locked(cm_id_priv, data, private_data_len);\n\tspin_unlock_irqrestore(&cm_id_priv->lock, flags);\n\treturn ret;\n}\nEXPORT_SYMBOL(ib_send_cm_drep);\n\nstatic int cm_issue_drep(struct cm_port *port,\n\t\t\t struct ib_mad_recv_wc *mad_recv_wc)\n{\n\tstruct ib_mad_send_buf *msg = NULL;\n\tstruct cm_dreq_msg *dreq_msg;\n\tstruct cm_drep_msg *drep_msg;\n\tint ret;\n\n\tret = cm_alloc_response_msg(port, mad_recv_wc, &msg);\n\tif (ret)\n\t\treturn ret;\n\n\tdreq_msg = (struct cm_dreq_msg *) mad_recv_wc->recv_buf.mad;\n\tdrep_msg = (struct cm_drep_msg *) msg->mad;\n\n\tcm_format_mad_hdr(&drep_msg->hdr, CM_DREP_ATTR_ID, dreq_msg->hdr.tid);\n\tIBA_SET(CM_DREP_REMOTE_COMM_ID, drep_msg,\n\t\tIBA_GET(CM_DREQ_LOCAL_COMM_ID, dreq_msg));\n\tIBA_SET(CM_DREP_LOCAL_COMM_ID, drep_msg,\n\t\tIBA_GET(CM_DREQ_REMOTE_COMM_ID, dreq_msg));\n\n\ttrace_icm_issue_drep(\n\t\tIBA_GET(CM_DREQ_LOCAL_COMM_ID, dreq_msg),\n\t\tIBA_GET(CM_DREQ_REMOTE_COMM_ID, dreq_msg));\n\tret = ib_post_send_mad(msg, NULL);\n\tif (ret)\n\t\tcm_free_response_msg(msg);\n\n\treturn ret;\n}\n\nstatic int cm_dreq_handler(struct cm_work *work)\n{\n\tstruct cm_id_private *cm_id_priv;\n\tstruct cm_dreq_msg *dreq_msg;\n\tstruct ib_mad_send_buf *msg = NULL;\n\n\tdreq_msg = (struct cm_dreq_msg *)work->mad_recv_wc->recv_buf.mad;\n\tcm_id_priv = cm_acquire_id(\n\t\tcpu_to_be32(IBA_GET(CM_DREQ_REMOTE_COMM_ID, dreq_msg)),\n\t\tcpu_to_be32(IBA_GET(CM_DREQ_LOCAL_COMM_ID, dreq_msg)));\n\tif (!cm_id_priv) {\n\t\tatomic_long_inc(&work->port->counters[CM_RECV_DUPLICATES]\n\t\t\t\t\t\t     [CM_DREQ_COUNTER]);\n\t\tcm_issue_drep(work->port, work->mad_recv_wc);\n\t\ttrace_icm_no_priv_err(\n\t\t\tIBA_GET(CM_DREQ_LOCAL_COMM_ID, dreq_msg),\n\t\t\tIBA_GET(CM_DREQ_REMOTE_COMM_ID, dreq_msg));\n\t\treturn -EINVAL;\n\t}\n\n\twork->cm_event.private_data =\n\t\tIBA_GET_MEM_PTR(CM_DREQ_PRIVATE_DATA, dreq_msg);\n\n\tspin_lock_irq(&cm_id_priv->lock);\n\tif (cm_id_priv->local_qpn !=\n\t    cpu_to_be32(IBA_GET(CM_DREQ_REMOTE_QPN_EECN, dreq_msg)))\n\t\tgoto unlock;\n\n\tswitch (cm_id_priv->id.state) {\n\tcase IB_CM_REP_SENT:\n\tcase IB_CM_DREQ_SENT:\n\tcase IB_CM_MRA_REP_RCVD:\n\t\tib_cancel_mad(cm_id_priv->msg);\n\t\tbreak;\n\tcase IB_CM_ESTABLISHED:\n\t\tif (cm_id_priv->id.lap_state == IB_CM_LAP_SENT ||\n\t\t    cm_id_priv->id.lap_state == IB_CM_MRA_LAP_RCVD)\n\t\t\tib_cancel_mad(cm_id_priv->msg);\n\t\tbreak;\n\tcase IB_CM_TIMEWAIT:\n\t\tatomic_long_inc(&work->port->counters[CM_RECV_DUPLICATES]\n\t\t\t\t\t\t     [CM_DREQ_COUNTER]);\n\t\tmsg = cm_alloc_response_msg_no_ah(work->port, work->mad_recv_wc);\n\t\tif (IS_ERR(msg))\n\t\t\tgoto unlock;\n\n\t\tcm_format_drep((struct cm_drep_msg *) msg->mad, cm_id_priv,\n\t\t\t       cm_id_priv->private_data,\n\t\t\t       cm_id_priv->private_data_len);\n\t\tspin_unlock_irq(&cm_id_priv->lock);\n\n\t\tif (cm_create_response_msg_ah(work->port, work->mad_recv_wc, msg) ||\n\t\t    ib_post_send_mad(msg, NULL))\n\t\t\tcm_free_response_msg(msg);\n\t\tgoto deref;\n\tcase IB_CM_DREQ_RCVD:\n\t\tatomic_long_inc(&work->port->counters[CM_RECV_DUPLICATES]\n\t\t\t\t\t\t     [CM_DREQ_COUNTER]);\n\t\tgoto unlock;\n\tdefault:\n\t\ttrace_icm_dreq_unknown_err(&cm_id_priv->id);\n\t\tgoto unlock;\n\t}\n\tcm_id_priv->id.state = IB_CM_DREQ_RCVD;\n\tcm_id_priv->tid = dreq_msg->hdr.tid;\n\tcm_queue_work_unlock(cm_id_priv, work);\n\treturn 0;\n\nunlock:\tspin_unlock_irq(&cm_id_priv->lock);\nderef:\tcm_deref_id(cm_id_priv);\n\treturn -EINVAL;\n}\n\nstatic int cm_drep_handler(struct cm_work *work)\n{\n\tstruct cm_id_private *cm_id_priv;\n\tstruct cm_drep_msg *drep_msg;\n\n\tdrep_msg = (struct cm_drep_msg *)work->mad_recv_wc->recv_buf.mad;\n\tcm_id_priv = cm_acquire_id(\n\t\tcpu_to_be32(IBA_GET(CM_DREP_REMOTE_COMM_ID, drep_msg)),\n\t\tcpu_to_be32(IBA_GET(CM_DREP_LOCAL_COMM_ID, drep_msg)));\n\tif (!cm_id_priv)\n\t\treturn -EINVAL;\n\n\twork->cm_event.private_data =\n\t\tIBA_GET_MEM_PTR(CM_DREP_PRIVATE_DATA, drep_msg);\n\n\tspin_lock_irq(&cm_id_priv->lock);\n\tif (cm_id_priv->id.state != IB_CM_DREQ_SENT &&\n\t    cm_id_priv->id.state != IB_CM_DREQ_RCVD) {\n\t\tspin_unlock_irq(&cm_id_priv->lock);\n\t\tgoto out;\n\t}\n\tcm_enter_timewait(cm_id_priv);\n\n\tib_cancel_mad(cm_id_priv->msg);\n\tcm_queue_work_unlock(cm_id_priv, work);\n\treturn 0;\nout:\n\tcm_deref_id(cm_id_priv);\n\treturn -EINVAL;\n}\n\nstatic int cm_send_rej_locked(struct cm_id_private *cm_id_priv,\n\t\t\t      enum ib_cm_rej_reason reason, void *ari,\n\t\t\t      u8 ari_length, const void *private_data,\n\t\t\t      u8 private_data_len)\n{\n\tenum ib_cm_state state = cm_id_priv->id.state;\n\tstruct ib_mad_send_buf *msg;\n\tint ret;\n\n\tlockdep_assert_held(&cm_id_priv->lock);\n\n\tif ((private_data && private_data_len > IB_CM_REJ_PRIVATE_DATA_SIZE) ||\n\t    (ari && ari_length > IB_CM_REJ_ARI_LENGTH))\n\t\treturn -EINVAL;\n\n\ttrace_icm_send_rej(&cm_id_priv->id, reason);\n\n\tswitch (state) {\n\tcase IB_CM_REQ_SENT:\n\tcase IB_CM_MRA_REQ_RCVD:\n\tcase IB_CM_REQ_RCVD:\n\tcase IB_CM_MRA_REQ_SENT:\n\tcase IB_CM_REP_RCVD:\n\tcase IB_CM_MRA_REP_SENT:\n\t\tcm_reset_to_idle(cm_id_priv);\n\t\tmsg = cm_alloc_msg(cm_id_priv);\n\t\tif (IS_ERR(msg))\n\t\t\treturn PTR_ERR(msg);\n\t\tcm_format_rej((struct cm_rej_msg *)msg->mad, cm_id_priv, reason,\n\t\t\t      ari, ari_length, private_data, private_data_len,\n\t\t\t      state);\n\t\tbreak;\n\tcase IB_CM_REP_SENT:\n\tcase IB_CM_MRA_REP_RCVD:\n\t\tcm_enter_timewait(cm_id_priv);\n\t\tmsg = cm_alloc_msg(cm_id_priv);\n\t\tif (IS_ERR(msg))\n\t\t\treturn PTR_ERR(msg);\n\t\tcm_format_rej((struct cm_rej_msg *)msg->mad, cm_id_priv, reason,\n\t\t\t      ari, ari_length, private_data, private_data_len,\n\t\t\t      state);\n\t\tbreak;\n\tdefault:\n\t\ttrace_icm_send_unknown_rej_err(&cm_id_priv->id);\n\t\treturn -EINVAL;\n\t}\n\n\tret = ib_post_send_mad(msg, NULL);\n\tif (ret) {\n\t\tcm_free_msg(msg);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint ib_send_cm_rej(struct ib_cm_id *cm_id, enum ib_cm_rej_reason reason,\n\t\t   void *ari, u8 ari_length, const void *private_data,\n\t\t   u8 private_data_len)\n{\n\tstruct cm_id_private *cm_id_priv =\n\t\tcontainer_of(cm_id, struct cm_id_private, id);\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&cm_id_priv->lock, flags);\n\tret = cm_send_rej_locked(cm_id_priv, reason, ari, ari_length,\n\t\t\t\t private_data, private_data_len);\n\tspin_unlock_irqrestore(&cm_id_priv->lock, flags);\n\treturn ret;\n}\nEXPORT_SYMBOL(ib_send_cm_rej);\n\nstatic void cm_format_rej_event(struct cm_work *work)\n{\n\tstruct cm_rej_msg *rej_msg;\n\tstruct ib_cm_rej_event_param *param;\n\n\trej_msg = (struct cm_rej_msg *)work->mad_recv_wc->recv_buf.mad;\n\tparam = &work->cm_event.param.rej_rcvd;\n\tparam->ari = IBA_GET_MEM_PTR(CM_REJ_ARI, rej_msg);\n\tparam->ari_length = IBA_GET(CM_REJ_REJECTED_INFO_LENGTH, rej_msg);\n\tparam->reason = IBA_GET(CM_REJ_REASON, rej_msg);\n\twork->cm_event.private_data =\n\t\tIBA_GET_MEM_PTR(CM_REJ_PRIVATE_DATA, rej_msg);\n}\n\nstatic struct cm_id_private *cm_acquire_rejected_id(struct cm_rej_msg *rej_msg)\n{\n\tstruct cm_id_private *cm_id_priv;\n\t__be32 remote_id;\n\n\tremote_id = cpu_to_be32(IBA_GET(CM_REJ_LOCAL_COMM_ID, rej_msg));\n\n\tif (IBA_GET(CM_REJ_REASON, rej_msg) == IB_CM_REJ_TIMEOUT) {\n\t\tcm_id_priv = cm_find_remote_id(\n\t\t\t*((__be64 *)IBA_GET_MEM_PTR(CM_REJ_ARI, rej_msg)),\n\t\t\tremote_id);\n\t} else if (IBA_GET(CM_REJ_MESSAGE_REJECTED, rej_msg) ==\n\t\t   CM_MSG_RESPONSE_REQ)\n\t\tcm_id_priv = cm_acquire_id(\n\t\t\tcpu_to_be32(IBA_GET(CM_REJ_REMOTE_COMM_ID, rej_msg)),\n\t\t\t0);\n\telse\n\t\tcm_id_priv = cm_acquire_id(\n\t\t\tcpu_to_be32(IBA_GET(CM_REJ_REMOTE_COMM_ID, rej_msg)),\n\t\t\tremote_id);\n\n\treturn cm_id_priv;\n}\n\nstatic int cm_rej_handler(struct cm_work *work)\n{\n\tstruct cm_id_private *cm_id_priv;\n\tstruct cm_rej_msg *rej_msg;\n\n\trej_msg = (struct cm_rej_msg *)work->mad_recv_wc->recv_buf.mad;\n\tcm_id_priv = cm_acquire_rejected_id(rej_msg);\n\tif (!cm_id_priv)\n\t\treturn -EINVAL;\n\n\tcm_format_rej_event(work);\n\n\tspin_lock_irq(&cm_id_priv->lock);\n\tswitch (cm_id_priv->id.state) {\n\tcase IB_CM_REQ_SENT:\n\tcase IB_CM_MRA_REQ_RCVD:\n\tcase IB_CM_REP_SENT:\n\tcase IB_CM_MRA_REP_RCVD:\n\t\tib_cancel_mad(cm_id_priv->msg);\n\t\tfallthrough;\n\tcase IB_CM_REQ_RCVD:\n\tcase IB_CM_MRA_REQ_SENT:\n\t\tif (IBA_GET(CM_REJ_REASON, rej_msg) == IB_CM_REJ_STALE_CONN)\n\t\t\tcm_enter_timewait(cm_id_priv);\n\t\telse\n\t\t\tcm_reset_to_idle(cm_id_priv);\n\t\tbreak;\n\tcase IB_CM_DREQ_SENT:\n\t\tib_cancel_mad(cm_id_priv->msg);\n\t\tfallthrough;\n\tcase IB_CM_REP_RCVD:\n\tcase IB_CM_MRA_REP_SENT:\n\t\tcm_enter_timewait(cm_id_priv);\n\t\tbreak;\n\tcase IB_CM_ESTABLISHED:\n\t\tif (cm_id_priv->id.lap_state == IB_CM_LAP_UNINIT ||\n\t\t    cm_id_priv->id.lap_state == IB_CM_LAP_SENT) {\n\t\t\tif (cm_id_priv->id.lap_state == IB_CM_LAP_SENT)\n\t\t\t\tib_cancel_mad(cm_id_priv->msg);\n\t\t\tcm_enter_timewait(cm_id_priv);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\ttrace_icm_rej_unknown_err(&cm_id_priv->id);\n\t\tspin_unlock_irq(&cm_id_priv->lock);\n\t\tgoto out;\n\t}\n\n\tcm_queue_work_unlock(cm_id_priv, work);\n\treturn 0;\nout:\n\tcm_deref_id(cm_id_priv);\n\treturn -EINVAL;\n}\n\nint ib_send_cm_mra(struct ib_cm_id *cm_id,\n\t\t   u8 service_timeout,\n\t\t   const void *private_data,\n\t\t   u8 private_data_len)\n{\n\tstruct cm_id_private *cm_id_priv;\n\tstruct ib_mad_send_buf *msg;\n\tenum ib_cm_state cm_state;\n\tenum ib_cm_lap_state lap_state;\n\tenum cm_msg_response msg_response;\n\tvoid *data;\n\tunsigned long flags;\n\tint ret;\n\n\tif (private_data && private_data_len > IB_CM_MRA_PRIVATE_DATA_SIZE)\n\t\treturn -EINVAL;\n\n\tdata = cm_copy_private_data(private_data, private_data_len);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tcm_id_priv = container_of(cm_id, struct cm_id_private, id);\n\n\tspin_lock_irqsave(&cm_id_priv->lock, flags);\n\tswitch (cm_id_priv->id.state) {\n\tcase IB_CM_REQ_RCVD:\n\t\tcm_state = IB_CM_MRA_REQ_SENT;\n\t\tlap_state = cm_id->lap_state;\n\t\tmsg_response = CM_MSG_RESPONSE_REQ;\n\t\tbreak;\n\tcase IB_CM_REP_RCVD:\n\t\tcm_state = IB_CM_MRA_REP_SENT;\n\t\tlap_state = cm_id->lap_state;\n\t\tmsg_response = CM_MSG_RESPONSE_REP;\n\t\tbreak;\n\tcase IB_CM_ESTABLISHED:\n\t\tif (cm_id->lap_state == IB_CM_LAP_RCVD) {\n\t\t\tcm_state = cm_id->state;\n\t\t\tlap_state = IB_CM_MRA_LAP_SENT;\n\t\t\tmsg_response = CM_MSG_RESPONSE_OTHER;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\ttrace_icm_send_mra_unknown_err(&cm_id_priv->id);\n\t\tret = -EINVAL;\n\t\tgoto error_unlock;\n\t}\n\n\tif (!(service_timeout & IB_CM_MRA_FLAG_DELAY)) {\n\t\tmsg = cm_alloc_msg(cm_id_priv);\n\t\tif (IS_ERR(msg)) {\n\t\t\tret = PTR_ERR(msg);\n\t\t\tgoto error_unlock;\n\t\t}\n\n\t\tcm_format_mra((struct cm_mra_msg *) msg->mad, cm_id_priv,\n\t\t\t      msg_response, service_timeout,\n\t\t\t      private_data, private_data_len);\n\t\ttrace_icm_send_mra(cm_id);\n\t\tret = ib_post_send_mad(msg, NULL);\n\t\tif (ret)\n\t\t\tgoto error_free_msg;\n\t}\n\n\tcm_id->state = cm_state;\n\tcm_id->lap_state = lap_state;\n\tcm_id_priv->service_timeout = service_timeout;\n\tcm_set_private_data(cm_id_priv, data, private_data_len);\n\tspin_unlock_irqrestore(&cm_id_priv->lock, flags);\n\treturn 0;\n\nerror_free_msg:\n\tcm_free_msg(msg);\nerror_unlock:\n\tspin_unlock_irqrestore(&cm_id_priv->lock, flags);\n\tkfree(data);\n\treturn ret;\n}\nEXPORT_SYMBOL(ib_send_cm_mra);\n\nstatic struct cm_id_private *cm_acquire_mraed_id(struct cm_mra_msg *mra_msg)\n{\n\tswitch (IBA_GET(CM_MRA_MESSAGE_MRAED, mra_msg)) {\n\tcase CM_MSG_RESPONSE_REQ:\n\t\treturn cm_acquire_id(\n\t\t\tcpu_to_be32(IBA_GET(CM_MRA_REMOTE_COMM_ID, mra_msg)),\n\t\t\t0);\n\tcase CM_MSG_RESPONSE_REP:\n\tcase CM_MSG_RESPONSE_OTHER:\n\t\treturn cm_acquire_id(\n\t\t\tcpu_to_be32(IBA_GET(CM_MRA_REMOTE_COMM_ID, mra_msg)),\n\t\t\tcpu_to_be32(IBA_GET(CM_MRA_LOCAL_COMM_ID, mra_msg)));\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nstatic int cm_mra_handler(struct cm_work *work)\n{\n\tstruct cm_id_private *cm_id_priv;\n\tstruct cm_mra_msg *mra_msg;\n\tint timeout;\n\n\tmra_msg = (struct cm_mra_msg *)work->mad_recv_wc->recv_buf.mad;\n\tcm_id_priv = cm_acquire_mraed_id(mra_msg);\n\tif (!cm_id_priv)\n\t\treturn -EINVAL;\n\n\twork->cm_event.private_data =\n\t\tIBA_GET_MEM_PTR(CM_MRA_PRIVATE_DATA, mra_msg);\n\twork->cm_event.param.mra_rcvd.service_timeout =\n\t\tIBA_GET(CM_MRA_SERVICE_TIMEOUT, mra_msg);\n\ttimeout = cm_convert_to_ms(IBA_GET(CM_MRA_SERVICE_TIMEOUT, mra_msg)) +\n\t\t  cm_convert_to_ms(cm_id_priv->av.timeout);\n\n\tspin_lock_irq(&cm_id_priv->lock);\n\tswitch (cm_id_priv->id.state) {\n\tcase IB_CM_REQ_SENT:\n\t\tif (IBA_GET(CM_MRA_MESSAGE_MRAED, mra_msg) !=\n\t\t\t    CM_MSG_RESPONSE_REQ ||\n\t\t    ib_modify_mad(cm_id_priv->msg, timeout))\n\t\t\tgoto out;\n\t\tcm_id_priv->id.state = IB_CM_MRA_REQ_RCVD;\n\t\tbreak;\n\tcase IB_CM_REP_SENT:\n\t\tif (IBA_GET(CM_MRA_MESSAGE_MRAED, mra_msg) !=\n\t\t\t    CM_MSG_RESPONSE_REP ||\n\t\t    ib_modify_mad(cm_id_priv->msg, timeout))\n\t\t\tgoto out;\n\t\tcm_id_priv->id.state = IB_CM_MRA_REP_RCVD;\n\t\tbreak;\n\tcase IB_CM_ESTABLISHED:\n\t\tif (IBA_GET(CM_MRA_MESSAGE_MRAED, mra_msg) !=\n\t\t\t    CM_MSG_RESPONSE_OTHER ||\n\t\t    cm_id_priv->id.lap_state != IB_CM_LAP_SENT ||\n\t\t    ib_modify_mad(cm_id_priv->msg, timeout)) {\n\t\t\tif (cm_id_priv->id.lap_state == IB_CM_MRA_LAP_RCVD)\n\t\t\t\tatomic_long_inc(\n\t\t\t\t\t&work->port->counters[CM_RECV_DUPLICATES]\n\t\t\t\t\t\t\t     [CM_MRA_COUNTER]);\n\t\t\tgoto out;\n\t\t}\n\t\tcm_id_priv->id.lap_state = IB_CM_MRA_LAP_RCVD;\n\t\tbreak;\n\tcase IB_CM_MRA_REQ_RCVD:\n\tcase IB_CM_MRA_REP_RCVD:\n\t\tatomic_long_inc(&work->port->counters[CM_RECV_DUPLICATES]\n\t\t\t\t\t\t     [CM_MRA_COUNTER]);\n\t\tfallthrough;\n\tdefault:\n\t\ttrace_icm_mra_unknown_err(&cm_id_priv->id);\n\t\tgoto out;\n\t}\n\n\tcm_id_priv->msg->context[1] = (void *) (unsigned long)\n\t\t\t\t      cm_id_priv->id.state;\n\tcm_queue_work_unlock(cm_id_priv, work);\n\treturn 0;\nout:\n\tspin_unlock_irq(&cm_id_priv->lock);\n\tcm_deref_id(cm_id_priv);\n\treturn -EINVAL;\n}\n\nstatic void cm_format_path_lid_from_lap(struct cm_lap_msg *lap_msg,\n\t\t\t\t\tstruct sa_path_rec *path)\n{\n\tu32 lid;\n\n\tif (path->rec_type != SA_PATH_REC_TYPE_OPA) {\n\t\tsa_path_set_dlid(path, IBA_GET(CM_LAP_ALTERNATE_LOCAL_PORT_LID,\n\t\t\t\t\t       lap_msg));\n\t\tsa_path_set_slid(path, IBA_GET(CM_LAP_ALTERNATE_REMOTE_PORT_LID,\n\t\t\t\t\t       lap_msg));\n\t} else {\n\t\tlid = opa_get_lid_from_gid(IBA_GET_MEM_PTR(\n\t\t\tCM_LAP_ALTERNATE_LOCAL_PORT_GID, lap_msg));\n\t\tsa_path_set_dlid(path, lid);\n\n\t\tlid = opa_get_lid_from_gid(IBA_GET_MEM_PTR(\n\t\t\tCM_LAP_ALTERNATE_REMOTE_PORT_GID, lap_msg));\n\t\tsa_path_set_slid(path, lid);\n\t}\n}\n\nstatic void cm_format_path_from_lap(struct cm_id_private *cm_id_priv,\n\t\t\t\t    struct sa_path_rec *path,\n\t\t\t\t    struct cm_lap_msg *lap_msg)\n{\n\tpath->dgid = *IBA_GET_MEM_PTR(CM_LAP_ALTERNATE_LOCAL_PORT_GID, lap_msg);\n\tpath->sgid =\n\t\t*IBA_GET_MEM_PTR(CM_LAP_ALTERNATE_REMOTE_PORT_GID, lap_msg);\n\tpath->flow_label =\n\t\tcpu_to_be32(IBA_GET(CM_LAP_ALTERNATE_FLOW_LABEL, lap_msg));\n\tpath->hop_limit = IBA_GET(CM_LAP_ALTERNATE_HOP_LIMIT, lap_msg);\n\tpath->traffic_class = IBA_GET(CM_LAP_ALTERNATE_TRAFFIC_CLASS, lap_msg);\n\tpath->reversible = 1;\n\tpath->pkey = cm_id_priv->pkey;\n\tpath->sl = IBA_GET(CM_LAP_ALTERNATE_SL, lap_msg);\n\tpath->mtu_selector = IB_SA_EQ;\n\tpath->mtu = cm_id_priv->path_mtu;\n\tpath->rate_selector = IB_SA_EQ;\n\tpath->rate = IBA_GET(CM_LAP_ALTERNATE_PACKET_RATE, lap_msg);\n\tpath->packet_life_time_selector = IB_SA_EQ;\n\tpath->packet_life_time =\n\t\tIBA_GET(CM_LAP_ALTERNATE_LOCAL_ACK_TIMEOUT, lap_msg);\n\tpath->packet_life_time -= (path->packet_life_time > 0);\n\tcm_format_path_lid_from_lap(lap_msg, path);\n}\n\nstatic int cm_lap_handler(struct cm_work *work)\n{\n\tstruct cm_id_private *cm_id_priv;\n\tstruct cm_lap_msg *lap_msg;\n\tstruct ib_cm_lap_event_param *param;\n\tstruct ib_mad_send_buf *msg = NULL;\n\tstruct rdma_ah_attr ah_attr;\n\tstruct cm_av alt_av = {};\n\tint ret;\n\n\t \n\tif (rdma_protocol_roce(work->port->cm_dev->ib_device,\n\t\t\t       work->port->port_num))\n\t\treturn -EINVAL;\n\n\t \n\tlap_msg = (struct cm_lap_msg *)work->mad_recv_wc->recv_buf.mad;\n\tcm_id_priv = cm_acquire_id(\n\t\tcpu_to_be32(IBA_GET(CM_LAP_REMOTE_COMM_ID, lap_msg)),\n\t\tcpu_to_be32(IBA_GET(CM_LAP_LOCAL_COMM_ID, lap_msg)));\n\tif (!cm_id_priv)\n\t\treturn -EINVAL;\n\n\tparam = &work->cm_event.param.lap_rcvd;\n\tmemset(&work->path[0], 0, sizeof(work->path[1]));\n\tcm_path_set_rec_type(work->port->cm_dev->ib_device,\n\t\t\t     work->port->port_num, &work->path[0],\n\t\t\t     IBA_GET_MEM_PTR(CM_LAP_ALTERNATE_LOCAL_PORT_GID,\n\t\t\t\t\t     lap_msg));\n\tparam->alternate_path = &work->path[0];\n\tcm_format_path_from_lap(cm_id_priv, param->alternate_path, lap_msg);\n\twork->cm_event.private_data =\n\t\tIBA_GET_MEM_PTR(CM_LAP_PRIVATE_DATA, lap_msg);\n\n\tret = ib_init_ah_attr_from_wc(work->port->cm_dev->ib_device,\n\t\t\t\t      work->port->port_num,\n\t\t\t\t      work->mad_recv_wc->wc,\n\t\t\t\t      work->mad_recv_wc->recv_buf.grh,\n\t\t\t\t      &ah_attr);\n\tif (ret)\n\t\tgoto deref;\n\n\tret = cm_init_av_by_path(param->alternate_path, NULL, &alt_av);\n\tif (ret) {\n\t\trdma_destroy_ah_attr(&ah_attr);\n\t\tgoto deref;\n\t}\n\n\tspin_lock_irq(&cm_id_priv->lock);\n\tcm_init_av_for_lap(work->port, work->mad_recv_wc->wc,\n\t\t\t   &ah_attr, &cm_id_priv->av);\n\tcm_move_av_from_path(&cm_id_priv->alt_av, &alt_av);\n\n\tif (cm_id_priv->id.state != IB_CM_ESTABLISHED)\n\t\tgoto unlock;\n\n\tswitch (cm_id_priv->id.lap_state) {\n\tcase IB_CM_LAP_UNINIT:\n\tcase IB_CM_LAP_IDLE:\n\t\tbreak;\n\tcase IB_CM_MRA_LAP_SENT:\n\t\tatomic_long_inc(&work->port->counters[CM_RECV_DUPLICATES]\n\t\t\t\t\t\t     [CM_LAP_COUNTER]);\n\t\tmsg = cm_alloc_response_msg_no_ah(work->port, work->mad_recv_wc);\n\t\tif (IS_ERR(msg))\n\t\t\tgoto unlock;\n\n\t\tcm_format_mra((struct cm_mra_msg *) msg->mad, cm_id_priv,\n\t\t\t      CM_MSG_RESPONSE_OTHER,\n\t\t\t      cm_id_priv->service_timeout,\n\t\t\t      cm_id_priv->private_data,\n\t\t\t      cm_id_priv->private_data_len);\n\t\tspin_unlock_irq(&cm_id_priv->lock);\n\n\t\tif (cm_create_response_msg_ah(work->port, work->mad_recv_wc, msg) ||\n\t\t    ib_post_send_mad(msg, NULL))\n\t\t\tcm_free_response_msg(msg);\n\t\tgoto deref;\n\tcase IB_CM_LAP_RCVD:\n\t\tatomic_long_inc(&work->port->counters[CM_RECV_DUPLICATES]\n\t\t\t\t\t\t     [CM_LAP_COUNTER]);\n\t\tgoto unlock;\n\tdefault:\n\t\tgoto unlock;\n\t}\n\n\tcm_id_priv->id.lap_state = IB_CM_LAP_RCVD;\n\tcm_id_priv->tid = lap_msg->hdr.tid;\n\tcm_queue_work_unlock(cm_id_priv, work);\n\treturn 0;\n\nunlock:\tspin_unlock_irq(&cm_id_priv->lock);\nderef:\tcm_deref_id(cm_id_priv);\n\treturn -EINVAL;\n}\n\nstatic int cm_apr_handler(struct cm_work *work)\n{\n\tstruct cm_id_private *cm_id_priv;\n\tstruct cm_apr_msg *apr_msg;\n\n\t \n\tif (rdma_protocol_roce(work->port->cm_dev->ib_device,\n\t\t\t       work->port->port_num))\n\t\treturn -EINVAL;\n\n\tapr_msg = (struct cm_apr_msg *)work->mad_recv_wc->recv_buf.mad;\n\tcm_id_priv = cm_acquire_id(\n\t\tcpu_to_be32(IBA_GET(CM_APR_REMOTE_COMM_ID, apr_msg)),\n\t\tcpu_to_be32(IBA_GET(CM_APR_LOCAL_COMM_ID, apr_msg)));\n\tif (!cm_id_priv)\n\t\treturn -EINVAL;  \n\n\twork->cm_event.param.apr_rcvd.ap_status =\n\t\tIBA_GET(CM_APR_AR_STATUS, apr_msg);\n\twork->cm_event.param.apr_rcvd.apr_info =\n\t\tIBA_GET_MEM_PTR(CM_APR_ADDITIONAL_INFORMATION, apr_msg);\n\twork->cm_event.param.apr_rcvd.info_len =\n\t\tIBA_GET(CM_APR_ADDITIONAL_INFORMATION_LENGTH, apr_msg);\n\twork->cm_event.private_data =\n\t\tIBA_GET_MEM_PTR(CM_APR_PRIVATE_DATA, apr_msg);\n\n\tspin_lock_irq(&cm_id_priv->lock);\n\tif (cm_id_priv->id.state != IB_CM_ESTABLISHED ||\n\t    (cm_id_priv->id.lap_state != IB_CM_LAP_SENT &&\n\t     cm_id_priv->id.lap_state != IB_CM_MRA_LAP_RCVD)) {\n\t\tspin_unlock_irq(&cm_id_priv->lock);\n\t\tgoto out;\n\t}\n\tcm_id_priv->id.lap_state = IB_CM_LAP_IDLE;\n\tib_cancel_mad(cm_id_priv->msg);\n\tcm_queue_work_unlock(cm_id_priv, work);\n\treturn 0;\nout:\n\tcm_deref_id(cm_id_priv);\n\treturn -EINVAL;\n}\n\nstatic int cm_timewait_handler(struct cm_work *work)\n{\n\tstruct cm_timewait_info *timewait_info;\n\tstruct cm_id_private *cm_id_priv;\n\n\ttimewait_info = container_of(work, struct cm_timewait_info, work);\n\tspin_lock_irq(&cm.lock);\n\tlist_del(&timewait_info->list);\n\tspin_unlock_irq(&cm.lock);\n\n\tcm_id_priv = cm_acquire_id(timewait_info->work.local_id,\n\t\t\t\t   timewait_info->work.remote_id);\n\tif (!cm_id_priv)\n\t\treturn -EINVAL;\n\n\tspin_lock_irq(&cm_id_priv->lock);\n\tif (cm_id_priv->id.state != IB_CM_TIMEWAIT ||\n\t    cm_id_priv->remote_qpn != timewait_info->remote_qpn) {\n\t\tspin_unlock_irq(&cm_id_priv->lock);\n\t\tgoto out;\n\t}\n\tcm_id_priv->id.state = IB_CM_IDLE;\n\tcm_queue_work_unlock(cm_id_priv, work);\n\treturn 0;\nout:\n\tcm_deref_id(cm_id_priv);\n\treturn -EINVAL;\n}\n\nstatic void cm_format_sidr_req(struct cm_sidr_req_msg *sidr_req_msg,\n\t\t\t       struct cm_id_private *cm_id_priv,\n\t\t\t       struct ib_cm_sidr_req_param *param)\n{\n\tcm_format_mad_hdr(&sidr_req_msg->hdr, CM_SIDR_REQ_ATTR_ID,\n\t\t\t  cm_form_tid(cm_id_priv));\n\tIBA_SET(CM_SIDR_REQ_REQUESTID, sidr_req_msg,\n\t\tbe32_to_cpu(cm_id_priv->id.local_id));\n\tIBA_SET(CM_SIDR_REQ_PARTITION_KEY, sidr_req_msg,\n\t\tbe16_to_cpu(param->path->pkey));\n\tIBA_SET(CM_SIDR_REQ_SERVICEID, sidr_req_msg,\n\t\tbe64_to_cpu(param->service_id));\n\n\tif (param->private_data && param->private_data_len)\n\t\tIBA_SET_MEM(CM_SIDR_REQ_PRIVATE_DATA, sidr_req_msg,\n\t\t\t    param->private_data, param->private_data_len);\n}\n\nint ib_send_cm_sidr_req(struct ib_cm_id *cm_id,\n\t\t\tstruct ib_cm_sidr_req_param *param)\n{\n\tstruct cm_id_private *cm_id_priv;\n\tstruct ib_mad_send_buf *msg;\n\tstruct cm_av av = {};\n\tunsigned long flags;\n\tint ret;\n\n\tif (!param->path || (param->private_data &&\n\t     param->private_data_len > IB_CM_SIDR_REQ_PRIVATE_DATA_SIZE))\n\t\treturn -EINVAL;\n\n\tcm_id_priv = container_of(cm_id, struct cm_id_private, id);\n\tret = cm_init_av_by_path(param->path, param->sgid_attr, &av);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock_irqsave(&cm_id_priv->lock, flags);\n\tcm_move_av_from_path(&cm_id_priv->av, &av);\n\tcm_id->service_id = param->service_id;\n\tcm_id_priv->timeout_ms = param->timeout_ms;\n\tcm_id_priv->max_cm_retries = param->max_cm_retries;\n\tif (cm_id->state != IB_CM_IDLE) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tmsg = cm_alloc_priv_msg(cm_id_priv);\n\tif (IS_ERR(msg)) {\n\t\tret = PTR_ERR(msg);\n\t\tgoto out_unlock;\n\t}\n\n\tcm_format_sidr_req((struct cm_sidr_req_msg *)msg->mad, cm_id_priv,\n\t\t\t   param);\n\tmsg->timeout_ms = cm_id_priv->timeout_ms;\n\tmsg->context[1] = (void *)(unsigned long)IB_CM_SIDR_REQ_SENT;\n\n\ttrace_icm_send_sidr_req(&cm_id_priv->id);\n\tret = ib_post_send_mad(msg, NULL);\n\tif (ret)\n\t\tgoto out_free;\n\tcm_id->state = IB_CM_SIDR_REQ_SENT;\n\tspin_unlock_irqrestore(&cm_id_priv->lock, flags);\n\treturn 0;\nout_free:\n\tcm_free_priv_msg(msg);\nout_unlock:\n\tspin_unlock_irqrestore(&cm_id_priv->lock, flags);\n\treturn ret;\n}\nEXPORT_SYMBOL(ib_send_cm_sidr_req);\n\nstatic void cm_format_sidr_req_event(struct cm_work *work,\n\t\t\t\t     const struct cm_id_private *rx_cm_id,\n\t\t\t\t     struct ib_cm_id *listen_id)\n{\n\tstruct cm_sidr_req_msg *sidr_req_msg;\n\tstruct ib_cm_sidr_req_event_param *param;\n\n\tsidr_req_msg = (struct cm_sidr_req_msg *)\n\t\t\t\twork->mad_recv_wc->recv_buf.mad;\n\tparam = &work->cm_event.param.sidr_req_rcvd;\n\tparam->pkey = IBA_GET(CM_SIDR_REQ_PARTITION_KEY, sidr_req_msg);\n\tparam->listen_id = listen_id;\n\tparam->service_id =\n\t\tcpu_to_be64(IBA_GET(CM_SIDR_REQ_SERVICEID, sidr_req_msg));\n\tparam->bth_pkey = cm_get_bth_pkey(work);\n\tparam->port = work->port->port_num;\n\tparam->sgid_attr = rx_cm_id->av.ah_attr.grh.sgid_attr;\n\twork->cm_event.private_data =\n\t\tIBA_GET_MEM_PTR(CM_SIDR_REQ_PRIVATE_DATA, sidr_req_msg);\n}\n\nstatic int cm_sidr_req_handler(struct cm_work *work)\n{\n\tstruct cm_id_private *cm_id_priv, *listen_cm_id_priv;\n\tstruct cm_sidr_req_msg *sidr_req_msg;\n\tstruct ib_wc *wc;\n\tint ret;\n\n\tcm_id_priv =\n\t\tcm_alloc_id_priv(work->port->cm_dev->ib_device, NULL, NULL);\n\tif (IS_ERR(cm_id_priv))\n\t\treturn PTR_ERR(cm_id_priv);\n\n\t \n\tsidr_req_msg = (struct cm_sidr_req_msg *)\n\t\t\t\twork->mad_recv_wc->recv_buf.mad;\n\n\tcm_id_priv->id.remote_id =\n\t\tcpu_to_be32(IBA_GET(CM_SIDR_REQ_REQUESTID, sidr_req_msg));\n\tcm_id_priv->id.service_id =\n\t\tcpu_to_be64(IBA_GET(CM_SIDR_REQ_SERVICEID, sidr_req_msg));\n\tcm_id_priv->tid = sidr_req_msg->hdr.tid;\n\n\twc = work->mad_recv_wc->wc;\n\tcm_id_priv->sidr_slid = wc->slid;\n\tret = cm_init_av_for_response(work->port, work->mad_recv_wc->wc,\n\t\t\t\t      work->mad_recv_wc->recv_buf.grh,\n\t\t\t\t      &cm_id_priv->av);\n\tif (ret)\n\t\tgoto out;\n\n\tspin_lock_irq(&cm.lock);\n\tlisten_cm_id_priv = cm_insert_remote_sidr(cm_id_priv);\n\tif (listen_cm_id_priv) {\n\t\tspin_unlock_irq(&cm.lock);\n\t\tatomic_long_inc(&work->port->counters[CM_RECV_DUPLICATES]\n\t\t\t\t\t\t     [CM_SIDR_REQ_COUNTER]);\n\t\tgoto out;  \n\t}\n\tcm_id_priv->id.state = IB_CM_SIDR_REQ_RCVD;\n\tlisten_cm_id_priv = cm_find_listen(cm_id_priv->id.device,\n\t\t\t\t\t   cm_id_priv->id.service_id);\n\tif (!listen_cm_id_priv) {\n\t\tspin_unlock_irq(&cm.lock);\n\t\tib_send_cm_sidr_rep(&cm_id_priv->id,\n\t\t\t\t    &(struct ib_cm_sidr_rep_param){\n\t\t\t\t\t    .status = IB_SIDR_UNSUPPORTED });\n\t\tgoto out;  \n\t}\n\tspin_unlock_irq(&cm.lock);\n\n\tcm_id_priv->id.cm_handler = listen_cm_id_priv->id.cm_handler;\n\tcm_id_priv->id.context = listen_cm_id_priv->id.context;\n\n\t \n\n\tcm_format_sidr_req_event(work, cm_id_priv, &listen_cm_id_priv->id);\n\tret = cm_id_priv->id.cm_handler(&cm_id_priv->id, &work->cm_event);\n\tcm_free_work(work);\n\t \n\tcm_deref_id(listen_cm_id_priv);\n\tif (ret)\n\t\tcm_destroy_id(&cm_id_priv->id, ret);\n\treturn 0;\nout:\n\tib_destroy_cm_id(&cm_id_priv->id);\n\treturn -EINVAL;\n}\n\nstatic void cm_format_sidr_rep(struct cm_sidr_rep_msg *sidr_rep_msg,\n\t\t\t       struct cm_id_private *cm_id_priv,\n\t\t\t       struct ib_cm_sidr_rep_param *param)\n{\n\tcm_format_mad_ece_hdr(&sidr_rep_msg->hdr, CM_SIDR_REP_ATTR_ID,\n\t\t\t      cm_id_priv->tid, param->ece.attr_mod);\n\tIBA_SET(CM_SIDR_REP_REQUESTID, sidr_rep_msg,\n\t\tbe32_to_cpu(cm_id_priv->id.remote_id));\n\tIBA_SET(CM_SIDR_REP_STATUS, sidr_rep_msg, param->status);\n\tIBA_SET(CM_SIDR_REP_QPN, sidr_rep_msg, param->qp_num);\n\tIBA_SET(CM_SIDR_REP_SERVICEID, sidr_rep_msg,\n\t\tbe64_to_cpu(cm_id_priv->id.service_id));\n\tIBA_SET(CM_SIDR_REP_Q_KEY, sidr_rep_msg, param->qkey);\n\tIBA_SET(CM_SIDR_REP_VENDOR_ID_L, sidr_rep_msg,\n\t\tparam->ece.vendor_id & 0xFF);\n\tIBA_SET(CM_SIDR_REP_VENDOR_ID_H, sidr_rep_msg,\n\t\t(param->ece.vendor_id >> 8) & 0xFF);\n\n\tif (param->info && param->info_length)\n\t\tIBA_SET_MEM(CM_SIDR_REP_ADDITIONAL_INFORMATION, sidr_rep_msg,\n\t\t\t    param->info, param->info_length);\n\n\tif (param->private_data && param->private_data_len)\n\t\tIBA_SET_MEM(CM_SIDR_REP_PRIVATE_DATA, sidr_rep_msg,\n\t\t\t    param->private_data, param->private_data_len);\n}\n\nstatic int cm_send_sidr_rep_locked(struct cm_id_private *cm_id_priv,\n\t\t\t\t   struct ib_cm_sidr_rep_param *param)\n{\n\tstruct ib_mad_send_buf *msg;\n\tunsigned long flags;\n\tint ret;\n\n\tlockdep_assert_held(&cm_id_priv->lock);\n\n\tif ((param->info && param->info_length > IB_CM_SIDR_REP_INFO_LENGTH) ||\n\t    (param->private_data &&\n\t     param->private_data_len > IB_CM_SIDR_REP_PRIVATE_DATA_SIZE))\n\t\treturn -EINVAL;\n\n\tif (cm_id_priv->id.state != IB_CM_SIDR_REQ_RCVD)\n\t\treturn -EINVAL;\n\n\tmsg = cm_alloc_msg(cm_id_priv);\n\tif (IS_ERR(msg))\n\t\treturn PTR_ERR(msg);\n\n\tcm_format_sidr_rep((struct cm_sidr_rep_msg *) msg->mad, cm_id_priv,\n\t\t\t   param);\n\ttrace_icm_send_sidr_rep(&cm_id_priv->id);\n\tret = ib_post_send_mad(msg, NULL);\n\tif (ret) {\n\t\tcm_free_msg(msg);\n\t\treturn ret;\n\t}\n\tcm_id_priv->id.state = IB_CM_IDLE;\n\tspin_lock_irqsave(&cm.lock, flags);\n\tif (!RB_EMPTY_NODE(&cm_id_priv->sidr_id_node)) {\n\t\trb_erase(&cm_id_priv->sidr_id_node, &cm.remote_sidr_table);\n\t\tRB_CLEAR_NODE(&cm_id_priv->sidr_id_node);\n\t}\n\tspin_unlock_irqrestore(&cm.lock, flags);\n\treturn 0;\n}\n\nint ib_send_cm_sidr_rep(struct ib_cm_id *cm_id,\n\t\t\tstruct ib_cm_sidr_rep_param *param)\n{\n\tstruct cm_id_private *cm_id_priv =\n\t\tcontainer_of(cm_id, struct cm_id_private, id);\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&cm_id_priv->lock, flags);\n\tret = cm_send_sidr_rep_locked(cm_id_priv, param);\n\tspin_unlock_irqrestore(&cm_id_priv->lock, flags);\n\treturn ret;\n}\nEXPORT_SYMBOL(ib_send_cm_sidr_rep);\n\nstatic void cm_format_sidr_rep_event(struct cm_work *work,\n\t\t\t\t     const struct cm_id_private *cm_id_priv)\n{\n\tstruct cm_sidr_rep_msg *sidr_rep_msg;\n\tstruct ib_cm_sidr_rep_event_param *param;\n\n\tsidr_rep_msg = (struct cm_sidr_rep_msg *)\n\t\t\t\twork->mad_recv_wc->recv_buf.mad;\n\tparam = &work->cm_event.param.sidr_rep_rcvd;\n\tparam->status = IBA_GET(CM_SIDR_REP_STATUS, sidr_rep_msg);\n\tparam->qkey = IBA_GET(CM_SIDR_REP_Q_KEY, sidr_rep_msg);\n\tparam->qpn = IBA_GET(CM_SIDR_REP_QPN, sidr_rep_msg);\n\tparam->info = IBA_GET_MEM_PTR(CM_SIDR_REP_ADDITIONAL_INFORMATION,\n\t\t\t\t      sidr_rep_msg);\n\tparam->info_len = IBA_GET(CM_SIDR_REP_ADDITIONAL_INFORMATION_LENGTH,\n\t\t\t\t  sidr_rep_msg);\n\tparam->sgid_attr = cm_id_priv->av.ah_attr.grh.sgid_attr;\n\twork->cm_event.private_data =\n\t\tIBA_GET_MEM_PTR(CM_SIDR_REP_PRIVATE_DATA, sidr_rep_msg);\n}\n\nstatic int cm_sidr_rep_handler(struct cm_work *work)\n{\n\tstruct cm_sidr_rep_msg *sidr_rep_msg;\n\tstruct cm_id_private *cm_id_priv;\n\n\tsidr_rep_msg = (struct cm_sidr_rep_msg *)\n\t\t\t\twork->mad_recv_wc->recv_buf.mad;\n\tcm_id_priv = cm_acquire_id(\n\t\tcpu_to_be32(IBA_GET(CM_SIDR_REP_REQUESTID, sidr_rep_msg)), 0);\n\tif (!cm_id_priv)\n\t\treturn -EINVAL;  \n\n\tspin_lock_irq(&cm_id_priv->lock);\n\tif (cm_id_priv->id.state != IB_CM_SIDR_REQ_SENT) {\n\t\tspin_unlock_irq(&cm_id_priv->lock);\n\t\tgoto out;\n\t}\n\tcm_id_priv->id.state = IB_CM_IDLE;\n\tib_cancel_mad(cm_id_priv->msg);\n\tspin_unlock_irq(&cm_id_priv->lock);\n\n\tcm_format_sidr_rep_event(work, cm_id_priv);\n\tcm_process_work(cm_id_priv, work);\n\treturn 0;\nout:\n\tcm_deref_id(cm_id_priv);\n\treturn -EINVAL;\n}\n\nstatic void cm_process_send_error(struct cm_id_private *cm_id_priv,\n\t\t\t\t  struct ib_mad_send_buf *msg,\n\t\t\t\t  enum ib_cm_state state,\n\t\t\t\t  enum ib_wc_status wc_status)\n{\n\tstruct ib_cm_event cm_event = {};\n\tint ret;\n\n\t \n\tspin_lock_irq(&cm_id_priv->lock);\n\tif (msg != cm_id_priv->msg) {\n\t\tspin_unlock_irq(&cm_id_priv->lock);\n\t\tcm_free_msg(msg);\n\t\treturn;\n\t}\n\tcm_free_priv_msg(msg);\n\n\tif (state != cm_id_priv->id.state || wc_status == IB_WC_SUCCESS ||\n\t    wc_status == IB_WC_WR_FLUSH_ERR)\n\t\tgoto out_unlock;\n\n\ttrace_icm_mad_send_err(state, wc_status);\n\tswitch (state) {\n\tcase IB_CM_REQ_SENT:\n\tcase IB_CM_MRA_REQ_RCVD:\n\t\tcm_reset_to_idle(cm_id_priv);\n\t\tcm_event.event = IB_CM_REQ_ERROR;\n\t\tbreak;\n\tcase IB_CM_REP_SENT:\n\tcase IB_CM_MRA_REP_RCVD:\n\t\tcm_reset_to_idle(cm_id_priv);\n\t\tcm_event.event = IB_CM_REP_ERROR;\n\t\tbreak;\n\tcase IB_CM_DREQ_SENT:\n\t\tcm_enter_timewait(cm_id_priv);\n\t\tcm_event.event = IB_CM_DREQ_ERROR;\n\t\tbreak;\n\tcase IB_CM_SIDR_REQ_SENT:\n\t\tcm_id_priv->id.state = IB_CM_IDLE;\n\t\tcm_event.event = IB_CM_SIDR_REQ_ERROR;\n\t\tbreak;\n\tdefault:\n\t\tgoto out_unlock;\n\t}\n\tspin_unlock_irq(&cm_id_priv->lock);\n\tcm_event.param.send_status = wc_status;\n\n\t \n\tret = cm_id_priv->id.cm_handler(&cm_id_priv->id, &cm_event);\n\tif (ret)\n\t\tib_destroy_cm_id(&cm_id_priv->id);\n\treturn;\nout_unlock:\n\tspin_unlock_irq(&cm_id_priv->lock);\n}\n\nstatic void cm_send_handler(struct ib_mad_agent *mad_agent,\n\t\t\t    struct ib_mad_send_wc *mad_send_wc)\n{\n\tstruct ib_mad_send_buf *msg = mad_send_wc->send_buf;\n\tstruct cm_id_private *cm_id_priv = msg->context[0];\n\tenum ib_cm_state state =\n\t\t(enum ib_cm_state)(unsigned long)msg->context[1];\n\tstruct cm_port *port;\n\tu16 attr_index;\n\n\tport = mad_agent->context;\n\tattr_index = be16_to_cpu(((struct ib_mad_hdr *)\n\t\t\t\t  msg->mad)->attr_id) - CM_ATTR_ID_OFFSET;\n\n\t \n\tif (!cm_id_priv && (attr_index != CM_REJ_COUNTER))\n\t\tmsg->retries = 1;\n\n\tatomic_long_add(1 + msg->retries, &port->counters[CM_XMIT][attr_index]);\n\tif (msg->retries)\n\t\tatomic_long_add(msg->retries,\n\t\t\t\t&port->counters[CM_XMIT_RETRIES][attr_index]);\n\n\tif (cm_id_priv)\n\t\tcm_process_send_error(cm_id_priv, msg, state,\n\t\t\t\t      mad_send_wc->status);\n\telse\n\t\tcm_free_response_msg(msg);\n}\n\nstatic void cm_work_handler(struct work_struct *_work)\n{\n\tstruct cm_work *work = container_of(_work, struct cm_work, work.work);\n\tint ret;\n\n\tswitch (work->cm_event.event) {\n\tcase IB_CM_REQ_RECEIVED:\n\t\tret = cm_req_handler(work);\n\t\tbreak;\n\tcase IB_CM_MRA_RECEIVED:\n\t\tret = cm_mra_handler(work);\n\t\tbreak;\n\tcase IB_CM_REJ_RECEIVED:\n\t\tret = cm_rej_handler(work);\n\t\tbreak;\n\tcase IB_CM_REP_RECEIVED:\n\t\tret = cm_rep_handler(work);\n\t\tbreak;\n\tcase IB_CM_RTU_RECEIVED:\n\t\tret = cm_rtu_handler(work);\n\t\tbreak;\n\tcase IB_CM_USER_ESTABLISHED:\n\t\tret = cm_establish_handler(work);\n\t\tbreak;\n\tcase IB_CM_DREQ_RECEIVED:\n\t\tret = cm_dreq_handler(work);\n\t\tbreak;\n\tcase IB_CM_DREP_RECEIVED:\n\t\tret = cm_drep_handler(work);\n\t\tbreak;\n\tcase IB_CM_SIDR_REQ_RECEIVED:\n\t\tret = cm_sidr_req_handler(work);\n\t\tbreak;\n\tcase IB_CM_SIDR_REP_RECEIVED:\n\t\tret = cm_sidr_rep_handler(work);\n\t\tbreak;\n\tcase IB_CM_LAP_RECEIVED:\n\t\tret = cm_lap_handler(work);\n\t\tbreak;\n\tcase IB_CM_APR_RECEIVED:\n\t\tret = cm_apr_handler(work);\n\t\tbreak;\n\tcase IB_CM_TIMEWAIT_EXIT:\n\t\tret = cm_timewait_handler(work);\n\t\tbreak;\n\tdefault:\n\t\ttrace_icm_handler_err(work->cm_event.event);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\tif (ret)\n\t\tcm_free_work(work);\n}\n\nstatic int cm_establish(struct ib_cm_id *cm_id)\n{\n\tstruct cm_id_private *cm_id_priv;\n\tstruct cm_work *work;\n\tunsigned long flags;\n\tint ret = 0;\n\tstruct cm_device *cm_dev;\n\n\tcm_dev = ib_get_client_data(cm_id->device, &cm_client);\n\tif (!cm_dev)\n\t\treturn -ENODEV;\n\n\twork = kmalloc(sizeof *work, GFP_ATOMIC);\n\tif (!work)\n\t\treturn -ENOMEM;\n\n\tcm_id_priv = container_of(cm_id, struct cm_id_private, id);\n\tspin_lock_irqsave(&cm_id_priv->lock, flags);\n\tswitch (cm_id->state) {\n\tcase IB_CM_REP_SENT:\n\tcase IB_CM_MRA_REP_RCVD:\n\t\tcm_id->state = IB_CM_ESTABLISHED;\n\t\tbreak;\n\tcase IB_CM_ESTABLISHED:\n\t\tret = -EISCONN;\n\t\tbreak;\n\tdefault:\n\t\ttrace_icm_establish_err(cm_id);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&cm_id_priv->lock, flags);\n\n\tif (ret) {\n\t\tkfree(work);\n\t\tgoto out;\n\t}\n\n\t \n\tINIT_DELAYED_WORK(&work->work, cm_work_handler);\n\twork->local_id = cm_id->local_id;\n\twork->remote_id = cm_id->remote_id;\n\twork->mad_recv_wc = NULL;\n\twork->cm_event.event = IB_CM_USER_ESTABLISHED;\n\n\t \n\tspin_lock_irqsave(&cm.lock, flags);\n\tif (!cm_dev->going_down) {\n\t\tqueue_delayed_work(cm.wq, &work->work, 0);\n\t} else {\n\t\tkfree(work);\n\t\tret = -ENODEV;\n\t}\n\tspin_unlock_irqrestore(&cm.lock, flags);\n\nout:\n\treturn ret;\n}\n\nstatic int cm_migrate(struct ib_cm_id *cm_id)\n{\n\tstruct cm_id_private *cm_id_priv;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tcm_id_priv = container_of(cm_id, struct cm_id_private, id);\n\tspin_lock_irqsave(&cm_id_priv->lock, flags);\n\tif (cm_id->state == IB_CM_ESTABLISHED &&\n\t    (cm_id->lap_state == IB_CM_LAP_UNINIT ||\n\t     cm_id->lap_state == IB_CM_LAP_IDLE)) {\n\t\tcm_id->lap_state = IB_CM_LAP_IDLE;\n\t\tcm_id_priv->av = cm_id_priv->alt_av;\n\t} else\n\t\tret = -EINVAL;\n\tspin_unlock_irqrestore(&cm_id_priv->lock, flags);\n\n\treturn ret;\n}\n\nint ib_cm_notify(struct ib_cm_id *cm_id, enum ib_event_type event)\n{\n\tint ret;\n\n\tswitch (event) {\n\tcase IB_EVENT_COMM_EST:\n\t\tret = cm_establish(cm_id);\n\t\tbreak;\n\tcase IB_EVENT_PATH_MIG:\n\t\tret = cm_migrate(cm_id);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL(ib_cm_notify);\n\nstatic void cm_recv_handler(struct ib_mad_agent *mad_agent,\n\t\t\t    struct ib_mad_send_buf *send_buf,\n\t\t\t    struct ib_mad_recv_wc *mad_recv_wc)\n{\n\tstruct cm_port *port = mad_agent->context;\n\tstruct cm_work *work;\n\tenum ib_cm_event_type event;\n\tbool alt_path = false;\n\tu16 attr_id;\n\tint paths = 0;\n\tint going_down = 0;\n\n\tswitch (mad_recv_wc->recv_buf.mad->mad_hdr.attr_id) {\n\tcase CM_REQ_ATTR_ID:\n\t\talt_path = cm_req_has_alt_path((struct cm_req_msg *)\n\t\t\t\t\t\tmad_recv_wc->recv_buf.mad);\n\t\tpaths = 1 + (alt_path != 0);\n\t\tevent = IB_CM_REQ_RECEIVED;\n\t\tbreak;\n\tcase CM_MRA_ATTR_ID:\n\t\tevent = IB_CM_MRA_RECEIVED;\n\t\tbreak;\n\tcase CM_REJ_ATTR_ID:\n\t\tevent = IB_CM_REJ_RECEIVED;\n\t\tbreak;\n\tcase CM_REP_ATTR_ID:\n\t\tevent = IB_CM_REP_RECEIVED;\n\t\tbreak;\n\tcase CM_RTU_ATTR_ID:\n\t\tevent = IB_CM_RTU_RECEIVED;\n\t\tbreak;\n\tcase CM_DREQ_ATTR_ID:\n\t\tevent = IB_CM_DREQ_RECEIVED;\n\t\tbreak;\n\tcase CM_DREP_ATTR_ID:\n\t\tevent = IB_CM_DREP_RECEIVED;\n\t\tbreak;\n\tcase CM_SIDR_REQ_ATTR_ID:\n\t\tevent = IB_CM_SIDR_REQ_RECEIVED;\n\t\tbreak;\n\tcase CM_SIDR_REP_ATTR_ID:\n\t\tevent = IB_CM_SIDR_REP_RECEIVED;\n\t\tbreak;\n\tcase CM_LAP_ATTR_ID:\n\t\tpaths = 1;\n\t\tevent = IB_CM_LAP_RECEIVED;\n\t\tbreak;\n\tcase CM_APR_ATTR_ID:\n\t\tevent = IB_CM_APR_RECEIVED;\n\t\tbreak;\n\tdefault:\n\t\tib_free_recv_mad(mad_recv_wc);\n\t\treturn;\n\t}\n\n\tattr_id = be16_to_cpu(mad_recv_wc->recv_buf.mad->mad_hdr.attr_id);\n\tatomic_long_inc(&port->counters[CM_RECV][attr_id - CM_ATTR_ID_OFFSET]);\n\n\twork = kmalloc(struct_size(work, path, paths), GFP_KERNEL);\n\tif (!work) {\n\t\tib_free_recv_mad(mad_recv_wc);\n\t\treturn;\n\t}\n\n\tINIT_DELAYED_WORK(&work->work, cm_work_handler);\n\twork->cm_event.event = event;\n\twork->mad_recv_wc = mad_recv_wc;\n\twork->port = port;\n\n\t \n\tspin_lock_irq(&cm.lock);\n\tif (!port->cm_dev->going_down)\n\t\tqueue_delayed_work(cm.wq, &work->work, 0);\n\telse\n\t\tgoing_down = 1;\n\tspin_unlock_irq(&cm.lock);\n\n\tif (going_down) {\n\t\tkfree(work);\n\t\tib_free_recv_mad(mad_recv_wc);\n\t}\n}\n\nstatic int cm_init_qp_init_attr(struct cm_id_private *cm_id_priv,\n\t\t\t\tstruct ib_qp_attr *qp_attr,\n\t\t\t\tint *qp_attr_mask)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&cm_id_priv->lock, flags);\n\tswitch (cm_id_priv->id.state) {\n\tcase IB_CM_REQ_SENT:\n\tcase IB_CM_MRA_REQ_RCVD:\n\tcase IB_CM_REQ_RCVD:\n\tcase IB_CM_MRA_REQ_SENT:\n\tcase IB_CM_REP_RCVD:\n\tcase IB_CM_MRA_REP_SENT:\n\tcase IB_CM_REP_SENT:\n\tcase IB_CM_MRA_REP_RCVD:\n\tcase IB_CM_ESTABLISHED:\n\t\t*qp_attr_mask = IB_QP_STATE | IB_QP_ACCESS_FLAGS |\n\t\t\t\tIB_QP_PKEY_INDEX | IB_QP_PORT;\n\t\tqp_attr->qp_access_flags = IB_ACCESS_REMOTE_WRITE;\n\t\tif (cm_id_priv->responder_resources) {\n\t\t\tstruct ib_device *ib_dev = cm_id_priv->id.device;\n\t\t\tu64 support_flush = ib_dev->attrs.device_cap_flags &\n\t\t\t  (IB_DEVICE_FLUSH_GLOBAL | IB_DEVICE_FLUSH_PERSISTENT);\n\t\t\tu32 flushable = support_flush ?\n\t\t\t\t\t(IB_ACCESS_FLUSH_GLOBAL |\n\t\t\t\t\t IB_ACCESS_FLUSH_PERSISTENT) : 0;\n\n\t\t\tqp_attr->qp_access_flags |= IB_ACCESS_REMOTE_READ |\n\t\t\t\t\t\t    IB_ACCESS_REMOTE_ATOMIC |\n\t\t\t\t\t\t    flushable;\n\t\t}\n\t\tqp_attr->pkey_index = cm_id_priv->av.pkey_index;\n\t\tif (cm_id_priv->av.port)\n\t\t\tqp_attr->port_num = cm_id_priv->av.port->port_num;\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\ttrace_icm_qp_init_err(&cm_id_priv->id);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&cm_id_priv->lock, flags);\n\treturn ret;\n}\n\nstatic int cm_init_qp_rtr_attr(struct cm_id_private *cm_id_priv,\n\t\t\t       struct ib_qp_attr *qp_attr,\n\t\t\t       int *qp_attr_mask)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&cm_id_priv->lock, flags);\n\tswitch (cm_id_priv->id.state) {\n\tcase IB_CM_REQ_RCVD:\n\tcase IB_CM_MRA_REQ_SENT:\n\tcase IB_CM_REP_RCVD:\n\tcase IB_CM_MRA_REP_SENT:\n\tcase IB_CM_REP_SENT:\n\tcase IB_CM_MRA_REP_RCVD:\n\tcase IB_CM_ESTABLISHED:\n\t\t*qp_attr_mask = IB_QP_STATE | IB_QP_AV | IB_QP_PATH_MTU |\n\t\t\t\tIB_QP_DEST_QPN | IB_QP_RQ_PSN;\n\t\tqp_attr->ah_attr = cm_id_priv->av.ah_attr;\n\t\tif ((qp_attr->ah_attr.type == RDMA_AH_ATTR_TYPE_IB) &&\n\t\t    cm_id_priv->av.dlid_datapath &&\n\t\t    (cm_id_priv->av.dlid_datapath != 0xffff))\n\t\t\tqp_attr->ah_attr.ib.dlid = cm_id_priv->av.dlid_datapath;\n\t\tqp_attr->path_mtu = cm_id_priv->path_mtu;\n\t\tqp_attr->dest_qp_num = be32_to_cpu(cm_id_priv->remote_qpn);\n\t\tqp_attr->rq_psn = be32_to_cpu(cm_id_priv->rq_psn);\n\t\tif (cm_id_priv->qp_type == IB_QPT_RC ||\n\t\t    cm_id_priv->qp_type == IB_QPT_XRC_TGT) {\n\t\t\t*qp_attr_mask |= IB_QP_MAX_DEST_RD_ATOMIC |\n\t\t\t\t\t IB_QP_MIN_RNR_TIMER;\n\t\t\tqp_attr->max_dest_rd_atomic =\n\t\t\t\t\tcm_id_priv->responder_resources;\n\t\t\tqp_attr->min_rnr_timer = 0;\n\t\t}\n\t\tif (rdma_ah_get_dlid(&cm_id_priv->alt_av.ah_attr) &&\n\t\t    cm_id_priv->alt_av.port) {\n\t\t\t*qp_attr_mask |= IB_QP_ALT_PATH;\n\t\t\tqp_attr->alt_port_num = cm_id_priv->alt_av.port->port_num;\n\t\t\tqp_attr->alt_pkey_index = cm_id_priv->alt_av.pkey_index;\n\t\t\tqp_attr->alt_timeout = cm_id_priv->alt_av.timeout;\n\t\t\tqp_attr->alt_ah_attr = cm_id_priv->alt_av.ah_attr;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\ttrace_icm_qp_rtr_err(&cm_id_priv->id);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&cm_id_priv->lock, flags);\n\treturn ret;\n}\n\nstatic int cm_init_qp_rts_attr(struct cm_id_private *cm_id_priv,\n\t\t\t       struct ib_qp_attr *qp_attr,\n\t\t\t       int *qp_attr_mask)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&cm_id_priv->lock, flags);\n\tswitch (cm_id_priv->id.state) {\n\t \n\tcase IB_CM_REQ_RCVD:\n\tcase IB_CM_MRA_REQ_SENT:\n\n\tcase IB_CM_REP_RCVD:\n\tcase IB_CM_MRA_REP_SENT:\n\tcase IB_CM_REP_SENT:\n\tcase IB_CM_MRA_REP_RCVD:\n\tcase IB_CM_ESTABLISHED:\n\t\tif (cm_id_priv->id.lap_state == IB_CM_LAP_UNINIT) {\n\t\t\t*qp_attr_mask = IB_QP_STATE | IB_QP_SQ_PSN;\n\t\t\tqp_attr->sq_psn = be32_to_cpu(cm_id_priv->sq_psn);\n\t\t\tswitch (cm_id_priv->qp_type) {\n\t\t\tcase IB_QPT_RC:\n\t\t\tcase IB_QPT_XRC_INI:\n\t\t\t\t*qp_attr_mask |= IB_QP_RETRY_CNT | IB_QP_RNR_RETRY |\n\t\t\t\t\t\t IB_QP_MAX_QP_RD_ATOMIC;\n\t\t\t\tqp_attr->retry_cnt = cm_id_priv->retry_count;\n\t\t\t\tqp_attr->rnr_retry = cm_id_priv->rnr_retry_count;\n\t\t\t\tqp_attr->max_rd_atomic = cm_id_priv->initiator_depth;\n\t\t\t\tfallthrough;\n\t\t\tcase IB_QPT_XRC_TGT:\n\t\t\t\t*qp_attr_mask |= IB_QP_TIMEOUT;\n\t\t\t\tqp_attr->timeout = cm_id_priv->av.timeout;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (rdma_ah_get_dlid(&cm_id_priv->alt_av.ah_attr)) {\n\t\t\t\t*qp_attr_mask |= IB_QP_PATH_MIG_STATE;\n\t\t\t\tqp_attr->path_mig_state = IB_MIG_REARM;\n\t\t\t}\n\t\t} else {\n\t\t\t*qp_attr_mask = IB_QP_ALT_PATH | IB_QP_PATH_MIG_STATE;\n\t\t\tif (cm_id_priv->alt_av.port)\n\t\t\t\tqp_attr->alt_port_num =\n\t\t\t\t\tcm_id_priv->alt_av.port->port_num;\n\t\t\tqp_attr->alt_pkey_index = cm_id_priv->alt_av.pkey_index;\n\t\t\tqp_attr->alt_timeout = cm_id_priv->alt_av.timeout;\n\t\t\tqp_attr->alt_ah_attr = cm_id_priv->alt_av.ah_attr;\n\t\t\tqp_attr->path_mig_state = IB_MIG_REARM;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\ttrace_icm_qp_rts_err(&cm_id_priv->id);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&cm_id_priv->lock, flags);\n\treturn ret;\n}\n\nint ib_cm_init_qp_attr(struct ib_cm_id *cm_id,\n\t\t       struct ib_qp_attr *qp_attr,\n\t\t       int *qp_attr_mask)\n{\n\tstruct cm_id_private *cm_id_priv;\n\tint ret;\n\n\tcm_id_priv = container_of(cm_id, struct cm_id_private, id);\n\tswitch (qp_attr->qp_state) {\n\tcase IB_QPS_INIT:\n\t\tret = cm_init_qp_init_attr(cm_id_priv, qp_attr, qp_attr_mask);\n\t\tbreak;\n\tcase IB_QPS_RTR:\n\t\tret = cm_init_qp_rtr_attr(cm_id_priv, qp_attr, qp_attr_mask);\n\t\tbreak;\n\tcase IB_QPS_RTS:\n\t\tret = cm_init_qp_rts_attr(cm_id_priv, qp_attr, qp_attr_mask);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL(ib_cm_init_qp_attr);\n\nstatic ssize_t cm_show_counter(struct ib_device *ibdev, u32 port_num,\n\t\t\t       struct ib_port_attribute *attr, char *buf)\n{\n\tstruct cm_counter_attribute *cm_attr =\n\t\tcontainer_of(attr, struct cm_counter_attribute, attr);\n\tstruct cm_device *cm_dev = ib_get_client_data(ibdev, &cm_client);\n\n\tif (WARN_ON(!cm_dev))\n\t\treturn -EINVAL;\n\n\treturn sysfs_emit(\n\t\tbuf, \"%ld\\n\",\n\t\tatomic_long_read(\n\t\t\t&cm_dev->port[port_num - 1]\n\t\t\t\t ->counters[cm_attr->group][cm_attr->index]));\n}\n\n#define CM_COUNTER_ATTR(_name, _group, _index)                                 \\\n\t{                                                                      \\\n\t\t.attr = __ATTR(_name, 0444, cm_show_counter, NULL),            \\\n\t\t.group = _group, .index = _index                               \\\n\t}\n\n#define CM_COUNTER_GROUP(_group, _name)                                        \\\n\tstatic struct cm_counter_attribute cm_counter_attr_##_group[] = {      \\\n\t\tCM_COUNTER_ATTR(req, _group, CM_REQ_COUNTER),                  \\\n\t\tCM_COUNTER_ATTR(mra, _group, CM_MRA_COUNTER),                  \\\n\t\tCM_COUNTER_ATTR(rej, _group, CM_REJ_COUNTER),                  \\\n\t\tCM_COUNTER_ATTR(rep, _group, CM_REP_COUNTER),                  \\\n\t\tCM_COUNTER_ATTR(rtu, _group, CM_RTU_COUNTER),                  \\\n\t\tCM_COUNTER_ATTR(dreq, _group, CM_DREQ_COUNTER),                \\\n\t\tCM_COUNTER_ATTR(drep, _group, CM_DREP_COUNTER),                \\\n\t\tCM_COUNTER_ATTR(sidr_req, _group, CM_SIDR_REQ_COUNTER),        \\\n\t\tCM_COUNTER_ATTR(sidr_rep, _group, CM_SIDR_REP_COUNTER),        \\\n\t\tCM_COUNTER_ATTR(lap, _group, CM_LAP_COUNTER),                  \\\n\t\tCM_COUNTER_ATTR(apr, _group, CM_APR_COUNTER),                  \\\n\t};                                                                     \\\n\tstatic struct attribute *cm_counter_attrs_##_group[] = {               \\\n\t\t&cm_counter_attr_##_group[0].attr.attr,                        \\\n\t\t&cm_counter_attr_##_group[1].attr.attr,                        \\\n\t\t&cm_counter_attr_##_group[2].attr.attr,                        \\\n\t\t&cm_counter_attr_##_group[3].attr.attr,                        \\\n\t\t&cm_counter_attr_##_group[4].attr.attr,                        \\\n\t\t&cm_counter_attr_##_group[5].attr.attr,                        \\\n\t\t&cm_counter_attr_##_group[6].attr.attr,                        \\\n\t\t&cm_counter_attr_##_group[7].attr.attr,                        \\\n\t\t&cm_counter_attr_##_group[8].attr.attr,                        \\\n\t\t&cm_counter_attr_##_group[9].attr.attr,                        \\\n\t\t&cm_counter_attr_##_group[10].attr.attr,                       \\\n\t\tNULL,                                                          \\\n\t};                                                                     \\\n\tstatic const struct attribute_group cm_counter_group_##_group = {      \\\n\t\t.name = _name,                                                 \\\n\t\t.attrs = cm_counter_attrs_##_group,                            \\\n\t};\n\nCM_COUNTER_GROUP(CM_XMIT, \"cm_tx_msgs\")\nCM_COUNTER_GROUP(CM_XMIT_RETRIES, \"cm_tx_retries\")\nCM_COUNTER_GROUP(CM_RECV, \"cm_rx_msgs\")\nCM_COUNTER_GROUP(CM_RECV_DUPLICATES, \"cm_rx_duplicates\")\n\nstatic const struct attribute_group *cm_counter_groups[] = {\n\t&cm_counter_group_CM_XMIT,\n\t&cm_counter_group_CM_XMIT_RETRIES,\n\t&cm_counter_group_CM_RECV,\n\t&cm_counter_group_CM_RECV_DUPLICATES,\n\tNULL,\n};\n\nstatic int cm_add_one(struct ib_device *ib_device)\n{\n\tstruct cm_device *cm_dev;\n\tstruct cm_port *port;\n\tstruct ib_mad_reg_req reg_req = {\n\t\t.mgmt_class = IB_MGMT_CLASS_CM,\n\t\t.mgmt_class_version = IB_CM_CLASS_VERSION,\n\t};\n\tstruct ib_port_modify port_modify = {\n\t\t.set_port_cap_mask = IB_PORT_CM_SUP\n\t};\n\tunsigned long flags;\n\tint ret;\n\tint count = 0;\n\tu32 i;\n\n\tcm_dev = kzalloc(struct_size(cm_dev, port, ib_device->phys_port_cnt),\n\t\t\t GFP_KERNEL);\n\tif (!cm_dev)\n\t\treturn -ENOMEM;\n\n\tkref_init(&cm_dev->kref);\n\tspin_lock_init(&cm_dev->mad_agent_lock);\n\tcm_dev->ib_device = ib_device;\n\tcm_dev->ack_delay = ib_device->attrs.local_ca_ack_delay;\n\tcm_dev->going_down = 0;\n\n\tib_set_client_data(ib_device, &cm_client, cm_dev);\n\n\tset_bit(IB_MGMT_METHOD_SEND, reg_req.method_mask);\n\trdma_for_each_port (ib_device, i) {\n\t\tif (!rdma_cap_ib_cm(ib_device, i))\n\t\t\tcontinue;\n\n\t\tport = kzalloc(sizeof *port, GFP_KERNEL);\n\t\tif (!port) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error1;\n\t\t}\n\n\t\tcm_dev->port[i-1] = port;\n\t\tport->cm_dev = cm_dev;\n\t\tport->port_num = i;\n\n\t\tret = ib_port_register_client_groups(ib_device, i,\n\t\t\t\t\t\t     cm_counter_groups);\n\t\tif (ret)\n\t\t\tgoto error1;\n\n\t\tport->mad_agent = ib_register_mad_agent(ib_device, i,\n\t\t\t\t\t\t\tIB_QPT_GSI,\n\t\t\t\t\t\t\t&reg_req,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\tcm_send_handler,\n\t\t\t\t\t\t\tcm_recv_handler,\n\t\t\t\t\t\t\tport,\n\t\t\t\t\t\t\t0);\n\t\tif (IS_ERR(port->mad_agent)) {\n\t\t\tret = PTR_ERR(port->mad_agent);\n\t\t\tgoto error2;\n\t\t}\n\n\t\tret = ib_modify_port(ib_device, i, 0, &port_modify);\n\t\tif (ret)\n\t\t\tgoto error3;\n\n\t\tcount++;\n\t}\n\n\tif (!count) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto free;\n\t}\n\n\twrite_lock_irqsave(&cm.device_lock, flags);\n\tlist_add_tail(&cm_dev->list, &cm.device_list);\n\twrite_unlock_irqrestore(&cm.device_lock, flags);\n\treturn 0;\n\nerror3:\n\tib_unregister_mad_agent(port->mad_agent);\nerror2:\n\tib_port_unregister_client_groups(ib_device, i, cm_counter_groups);\nerror1:\n\tport_modify.set_port_cap_mask = 0;\n\tport_modify.clr_port_cap_mask = IB_PORT_CM_SUP;\n\twhile (--i) {\n\t\tif (!rdma_cap_ib_cm(ib_device, i))\n\t\t\tcontinue;\n\n\t\tport = cm_dev->port[i-1];\n\t\tib_modify_port(ib_device, port->port_num, 0, &port_modify);\n\t\tib_unregister_mad_agent(port->mad_agent);\n\t\tib_port_unregister_client_groups(ib_device, i,\n\t\t\t\t\t\t cm_counter_groups);\n\t}\nfree:\n\tcm_device_put(cm_dev);\n\treturn ret;\n}\n\nstatic void cm_remove_one(struct ib_device *ib_device, void *client_data)\n{\n\tstruct cm_device *cm_dev = client_data;\n\tstruct cm_port *port;\n\tstruct ib_port_modify port_modify = {\n\t\t.clr_port_cap_mask = IB_PORT_CM_SUP\n\t};\n\tunsigned long flags;\n\tu32 i;\n\n\twrite_lock_irqsave(&cm.device_lock, flags);\n\tlist_del(&cm_dev->list);\n\twrite_unlock_irqrestore(&cm.device_lock, flags);\n\n\tspin_lock_irq(&cm.lock);\n\tcm_dev->going_down = 1;\n\tspin_unlock_irq(&cm.lock);\n\n\trdma_for_each_port (ib_device, i) {\n\t\tstruct ib_mad_agent *mad_agent;\n\n\t\tif (!rdma_cap_ib_cm(ib_device, i))\n\t\t\tcontinue;\n\n\t\tport = cm_dev->port[i-1];\n\t\tmad_agent = port->mad_agent;\n\t\tib_modify_port(ib_device, port->port_num, 0, &port_modify);\n\t\t \n\t\tflush_workqueue(cm.wq);\n\t\t \n\t\tspin_lock(&cm_dev->mad_agent_lock);\n\t\tport->mad_agent = NULL;\n\t\tspin_unlock(&cm_dev->mad_agent_lock);\n\t\tib_unregister_mad_agent(mad_agent);\n\t\tib_port_unregister_client_groups(ib_device, i,\n\t\t\t\t\t\t cm_counter_groups);\n\t}\n\n\tcm_device_put(cm_dev);\n}\n\nstatic int __init ib_cm_init(void)\n{\n\tint ret;\n\n\tINIT_LIST_HEAD(&cm.device_list);\n\trwlock_init(&cm.device_lock);\n\tspin_lock_init(&cm.lock);\n\tcm.listen_service_table = RB_ROOT;\n\tcm.listen_service_id = be64_to_cpu(IB_CM_ASSIGN_SERVICE_ID);\n\tcm.remote_id_table = RB_ROOT;\n\tcm.remote_qp_table = RB_ROOT;\n\tcm.remote_sidr_table = RB_ROOT;\n\txa_init_flags(&cm.local_id_table, XA_FLAGS_ALLOC);\n\tget_random_bytes(&cm.random_id_operand, sizeof cm.random_id_operand);\n\tINIT_LIST_HEAD(&cm.timewait_list);\n\n\tcm.wq = alloc_workqueue(\"ib_cm\", 0, 1);\n\tif (!cm.wq) {\n\t\tret = -ENOMEM;\n\t\tgoto error2;\n\t}\n\n\tret = ib_register_client(&cm_client);\n\tif (ret)\n\t\tgoto error3;\n\n\treturn 0;\nerror3:\n\tdestroy_workqueue(cm.wq);\nerror2:\n\treturn ret;\n}\n\nstatic void __exit ib_cm_cleanup(void)\n{\n\tstruct cm_timewait_info *timewait_info, *tmp;\n\n\tspin_lock_irq(&cm.lock);\n\tlist_for_each_entry(timewait_info, &cm.timewait_list, list)\n\t\tcancel_delayed_work(&timewait_info->work.work);\n\tspin_unlock_irq(&cm.lock);\n\n\tib_unregister_client(&cm_client);\n\tdestroy_workqueue(cm.wq);\n\n\tlist_for_each_entry_safe(timewait_info, tmp, &cm.timewait_list, list) {\n\t\tlist_del(&timewait_info->list);\n\t\tkfree(timewait_info);\n\t}\n\n\tWARN_ON(!xa_empty(&cm.local_id_table));\n}\n\nmodule_init(ib_cm_init);\nmodule_exit(ib_cm_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}