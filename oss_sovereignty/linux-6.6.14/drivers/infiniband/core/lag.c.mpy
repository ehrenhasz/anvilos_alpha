{
  "module_name": "lag.c",
  "hash_id": "c71140b1d73819732aa387aefeb9db2c3cff914bcec46335a7f28a5b08c60849",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/core/lag.c",
  "human_readable_source": "\n \n\n#include <rdma/ib_verbs.h>\n#include <rdma/ib_cache.h>\n#include <rdma/lag.h>\n\nstatic struct sk_buff *rdma_build_skb(struct net_device *netdev,\n\t\t\t\t      struct rdma_ah_attr *ah_attr,\n\t\t\t\t      gfp_t flags)\n{\n\tstruct ipv6hdr *ip6h;\n\tstruct sk_buff *skb;\n\tstruct ethhdr *eth;\n\tstruct iphdr *iph;\n\tstruct udphdr *uh;\n\tu8 smac[ETH_ALEN];\n\tbool is_ipv4;\n\tint hdr_len;\n\n\tis_ipv4 = ipv6_addr_v4mapped((struct in6_addr *)ah_attr->grh.dgid.raw);\n\thdr_len = ETH_HLEN + sizeof(struct udphdr) + LL_RESERVED_SPACE(netdev);\n\thdr_len += is_ipv4 ? sizeof(struct iphdr) : sizeof(struct ipv6hdr);\n\n\tskb = alloc_skb(hdr_len, flags);\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb->dev = netdev;\n\tskb_reserve(skb, hdr_len);\n\tskb_push(skb, sizeof(struct udphdr));\n\tskb_reset_transport_header(skb);\n\tuh = udp_hdr(skb);\n\tuh->source =\n\t\thtons(rdma_flow_label_to_udp_sport(ah_attr->grh.flow_label));\n\tuh->dest = htons(ROCE_V2_UDP_DPORT);\n\tuh->len = htons(sizeof(struct udphdr));\n\n\tif (is_ipv4) {\n\t\tskb_push(skb, sizeof(struct iphdr));\n\t\tskb_reset_network_header(skb);\n\t\tiph = ip_hdr(skb);\n\t\tiph->frag_off = 0;\n\t\tiph->version = 4;\n\t\tiph->protocol = IPPROTO_UDP;\n\t\tiph->ihl = 0x5;\n\t\tiph->tot_len = htons(sizeof(struct udphdr) + sizeof(struct\n\t\t\t\t\t\t\t\t    iphdr));\n\t\tmemcpy(&iph->saddr, ah_attr->grh.sgid_attr->gid.raw + 12,\n\t\t       sizeof(struct in_addr));\n\t\tmemcpy(&iph->daddr, ah_attr->grh.dgid.raw + 12,\n\t\t       sizeof(struct in_addr));\n\t} else {\n\t\tskb_push(skb, sizeof(struct ipv6hdr));\n\t\tskb_reset_network_header(skb);\n\t\tip6h = ipv6_hdr(skb);\n\t\tip6h->version = 6;\n\t\tip6h->nexthdr = IPPROTO_UDP;\n\t\tmemcpy(&ip6h->flow_lbl, &ah_attr->grh.flow_label,\n\t\t       sizeof(*ip6h->flow_lbl));\n\t\tmemcpy(&ip6h->saddr, ah_attr->grh.sgid_attr->gid.raw,\n\t\t       sizeof(struct in6_addr));\n\t\tmemcpy(&ip6h->daddr, ah_attr->grh.dgid.raw,\n\t\t       sizeof(struct in6_addr));\n\t}\n\n\tskb_push(skb, sizeof(struct ethhdr));\n\tskb_reset_mac_header(skb);\n\teth = eth_hdr(skb);\n\tskb->protocol = eth->h_proto = htons(is_ipv4 ? ETH_P_IP : ETH_P_IPV6);\n\trdma_read_gid_l2_fields(ah_attr->grh.sgid_attr, NULL, smac);\n\tmemcpy(eth->h_source, smac, ETH_ALEN);\n\tmemcpy(eth->h_dest, ah_attr->roce.dmac, ETH_ALEN);\n\n\treturn skb;\n}\n\nstatic struct net_device *rdma_get_xmit_slave_udp(struct ib_device *device,\n\t\t\t\t\t\t  struct net_device *master,\n\t\t\t\t\t\t  struct rdma_ah_attr *ah_attr,\n\t\t\t\t\t\t  gfp_t flags)\n{\n\tstruct net_device *slave;\n\tstruct sk_buff *skb;\n\n\tskb = rdma_build_skb(master, ah_attr, flags);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trcu_read_lock();\n\tslave = netdev_get_xmit_slave(master, skb,\n\t\t\t\t      !!(device->lag_flags &\n\t\t\t\t\t RDMA_LAG_FLAGS_HASH_ALL_SLAVES));\n\tif (slave)\n\t\tdev_hold(slave);\n\trcu_read_unlock();\n\tkfree_skb(skb);\n\treturn slave;\n}\n\nvoid rdma_lag_put_ah_roce_slave(struct net_device *xmit_slave)\n{\n\tif (xmit_slave)\n\t\tdev_put(xmit_slave);\n}\n\nstruct net_device *rdma_lag_get_ah_roce_slave(struct ib_device *device,\n\t\t\t\t\t      struct rdma_ah_attr *ah_attr,\n\t\t\t\t\t      gfp_t flags)\n{\n\tstruct net_device *slave = NULL;\n\tstruct net_device *master;\n\n\tif (!(ah_attr->type == RDMA_AH_ATTR_TYPE_ROCE &&\n\t      ah_attr->grh.sgid_attr->gid_type == IB_GID_TYPE_ROCE_UDP_ENCAP &&\n\t      ah_attr->grh.flow_label))\n\t\treturn NULL;\n\n\trcu_read_lock();\n\tmaster = rdma_read_gid_attr_ndev_rcu(ah_attr->grh.sgid_attr);\n\tif (IS_ERR(master)) {\n\t\trcu_read_unlock();\n\t\treturn master;\n\t}\n\tdev_hold(master);\n\trcu_read_unlock();\n\n\tif (!netif_is_bond_master(master))\n\t\tgoto put;\n\n\tslave = rdma_get_xmit_slave_udp(device, master, ah_attr, flags);\nput:\n\tdev_put(master);\n\treturn slave;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}