{
  "module_name": "restrack.c",
  "hash_id": "4eff4b109bcfc2d8dddbf8efbff96ecaa364714aaf23759ea8e4301bf015a65c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/core/restrack.c",
  "human_readable_source": "\n \n\n#include <rdma/rdma_cm.h>\n#include <rdma/ib_verbs.h>\n#include <rdma/restrack.h>\n#include <rdma/rdma_counter.h>\n#include <linux/mutex.h>\n#include <linux/sched/task.h>\n#include <linux/pid_namespace.h>\n\n#include \"cma_priv.h\"\n#include \"restrack.h\"\n\n \nint rdma_restrack_init(struct ib_device *dev)\n{\n\tstruct rdma_restrack_root *rt;\n\tint i;\n\n\tdev->res = kcalloc(RDMA_RESTRACK_MAX, sizeof(*rt), GFP_KERNEL);\n\tif (!dev->res)\n\t\treturn -ENOMEM;\n\n\trt = dev->res;\n\n\tfor (i = 0; i < RDMA_RESTRACK_MAX; i++)\n\t\txa_init_flags(&rt[i].xa, XA_FLAGS_ALLOC);\n\n\treturn 0;\n}\n\nstatic const char *type2str(enum rdma_restrack_type type)\n{\n\tstatic const char * const names[RDMA_RESTRACK_MAX] = {\n\t\t[RDMA_RESTRACK_PD] = \"PD\",\n\t\t[RDMA_RESTRACK_CQ] = \"CQ\",\n\t\t[RDMA_RESTRACK_QP] = \"QP\",\n\t\t[RDMA_RESTRACK_CM_ID] = \"CM_ID\",\n\t\t[RDMA_RESTRACK_MR] = \"MR\",\n\t\t[RDMA_RESTRACK_CTX] = \"CTX\",\n\t\t[RDMA_RESTRACK_COUNTER] = \"COUNTER\",\n\t\t[RDMA_RESTRACK_SRQ] = \"SRQ\",\n\t};\n\n\treturn names[type];\n};\n\n \nvoid rdma_restrack_clean(struct ib_device *dev)\n{\n\tstruct rdma_restrack_root *rt = dev->res;\n\tstruct rdma_restrack_entry *e;\n\tchar buf[TASK_COMM_LEN];\n\tbool found = false;\n\tconst char *owner;\n\tint i;\n\n\tfor (i = 0 ; i < RDMA_RESTRACK_MAX; i++) {\n\t\tstruct xarray *xa = &dev->res[i].xa;\n\n\t\tif (!xa_empty(xa)) {\n\t\t\tunsigned long index;\n\n\t\t\tif (!found) {\n\t\t\t\tpr_err(\"restrack: %s\", CUT_HERE);\n\t\t\t\tdev_err(&dev->dev, \"BUG: RESTRACK detected leak of resources\\n\");\n\t\t\t}\n\t\t\txa_for_each(xa, index, e) {\n\t\t\t\tif (rdma_is_kernel_res(e)) {\n\t\t\t\t\towner = e->kern_name;\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tget_task_comm(buf, e->task);\n\t\t\t\t\towner = buf;\n\t\t\t\t}\n\n\t\t\t\tpr_err(\"restrack: %s %s object allocated by %s is not freed\\n\",\n\t\t\t\t       rdma_is_kernel_res(e) ? \"Kernel\" :\n\t\t\t\t\t\t\t       \"User\",\n\t\t\t\t       type2str(e->type), owner);\n\t\t\t}\n\t\t\tfound = true;\n\t\t}\n\t\txa_destroy(xa);\n\t}\n\tif (found)\n\t\tpr_err(\"restrack: %s\", CUT_HERE);\n\n\tkfree(rt);\n}\n\n \nint rdma_restrack_count(struct ib_device *dev, enum rdma_restrack_type type)\n{\n\tstruct rdma_restrack_root *rt = &dev->res[type];\n\tstruct rdma_restrack_entry *e;\n\tXA_STATE(xas, &rt->xa, 0);\n\tu32 cnt = 0;\n\n\txa_lock(&rt->xa);\n\txas_for_each(&xas, e, U32_MAX)\n\t\tcnt++;\n\txa_unlock(&rt->xa);\n\treturn cnt;\n}\nEXPORT_SYMBOL(rdma_restrack_count);\n\nstatic struct ib_device *res_to_dev(struct rdma_restrack_entry *res)\n{\n\tswitch (res->type) {\n\tcase RDMA_RESTRACK_PD:\n\t\treturn container_of(res, struct ib_pd, res)->device;\n\tcase RDMA_RESTRACK_CQ:\n\t\treturn container_of(res, struct ib_cq, res)->device;\n\tcase RDMA_RESTRACK_QP:\n\t\treturn container_of(res, struct ib_qp, res)->device;\n\tcase RDMA_RESTRACK_CM_ID:\n\t\treturn container_of(res, struct rdma_id_private,\n\t\t\t\t    res)->id.device;\n\tcase RDMA_RESTRACK_MR:\n\t\treturn container_of(res, struct ib_mr, res)->device;\n\tcase RDMA_RESTRACK_CTX:\n\t\treturn container_of(res, struct ib_ucontext, res)->device;\n\tcase RDMA_RESTRACK_COUNTER:\n\t\treturn container_of(res, struct rdma_counter, res)->device;\n\tcase RDMA_RESTRACK_SRQ:\n\t\treturn container_of(res, struct ib_srq, res)->device;\n\tdefault:\n\t\tWARN_ONCE(true, \"Wrong resource tracking type %u\\n\", res->type);\n\t\treturn NULL;\n\t}\n}\n\n \nstatic void rdma_restrack_attach_task(struct rdma_restrack_entry *res,\n\t\t\t\t      struct task_struct *task)\n{\n\tif (WARN_ON_ONCE(!task))\n\t\treturn;\n\n\tif (res->task)\n\t\tput_task_struct(res->task);\n\tget_task_struct(task);\n\tres->task = task;\n\tres->user = true;\n}\n\n \nvoid rdma_restrack_set_name(struct rdma_restrack_entry *res, const char *caller)\n{\n\tif (caller) {\n\t\tres->kern_name = caller;\n\t\treturn;\n\t}\n\n\trdma_restrack_attach_task(res, current);\n}\nEXPORT_SYMBOL(rdma_restrack_set_name);\n\n \nvoid rdma_restrack_parent_name(struct rdma_restrack_entry *dst,\n\t\t\t       const struct rdma_restrack_entry *parent)\n{\n\tif (rdma_is_kernel_res(parent))\n\t\tdst->kern_name = parent->kern_name;\n\telse\n\t\trdma_restrack_attach_task(dst, parent->task);\n}\nEXPORT_SYMBOL(rdma_restrack_parent_name);\n\n \nvoid rdma_restrack_new(struct rdma_restrack_entry *res,\n\t\t       enum rdma_restrack_type type)\n{\n\tkref_init(&res->kref);\n\tinit_completion(&res->comp);\n\tres->type = type;\n}\nEXPORT_SYMBOL(rdma_restrack_new);\n\n \nvoid rdma_restrack_add(struct rdma_restrack_entry *res)\n{\n\tstruct ib_device *dev = res_to_dev(res);\n\tstruct rdma_restrack_root *rt;\n\tint ret = 0;\n\n\tif (!dev)\n\t\treturn;\n\n\tif (res->no_track)\n\t\tgoto out;\n\n\trt = &dev->res[res->type];\n\n\tif (res->type == RDMA_RESTRACK_QP) {\n\t\t \n\t\tstruct ib_qp *qp = container_of(res, struct ib_qp, res);\n\n\t\tWARN_ONCE(qp->qp_num >> 24 || qp->port >> 8,\n\t\t\t  \"QP number 0x%0X and port 0x%0X\", qp->qp_num,\n\t\t\t  qp->port);\n\t\tres->id = qp->qp_num;\n\t\tif (qp->qp_type == IB_QPT_SMI || qp->qp_type == IB_QPT_GSI)\n\t\t\tres->id |= qp->port << 24;\n\t\tret = xa_insert(&rt->xa, res->id, res, GFP_KERNEL);\n\t\tif (ret)\n\t\t\tres->id = 0;\n\t} else if (res->type == RDMA_RESTRACK_COUNTER) {\n\t\t \n\t\tstruct rdma_counter *counter;\n\n\t\tcounter = container_of(res, struct rdma_counter, res);\n\t\tret = xa_insert(&rt->xa, counter->id, res, GFP_KERNEL);\n\t\tres->id = ret ? 0 : counter->id;\n\t} else {\n\t\tret = xa_alloc_cyclic(&rt->xa, &res->id, res, xa_limit_32b,\n\t\t\t\t      &rt->next_id, GFP_KERNEL);\n\t\tret = (ret < 0) ? ret : 0;\n\t}\n\nout:\n\tif (!ret)\n\t\tres->valid = true;\n}\nEXPORT_SYMBOL(rdma_restrack_add);\n\nint __must_check rdma_restrack_get(struct rdma_restrack_entry *res)\n{\n\treturn kref_get_unless_zero(&res->kref);\n}\nEXPORT_SYMBOL(rdma_restrack_get);\n\n \nstruct rdma_restrack_entry *\nrdma_restrack_get_byid(struct ib_device *dev,\n\t\t       enum rdma_restrack_type type, u32 id)\n{\n\tstruct rdma_restrack_root *rt = &dev->res[type];\n\tstruct rdma_restrack_entry *res;\n\n\txa_lock(&rt->xa);\n\tres = xa_load(&rt->xa, id);\n\tif (!res || !rdma_restrack_get(res))\n\t\tres = ERR_PTR(-ENOENT);\n\txa_unlock(&rt->xa);\n\n\treturn res;\n}\nEXPORT_SYMBOL(rdma_restrack_get_byid);\n\nstatic void restrack_release(struct kref *kref)\n{\n\tstruct rdma_restrack_entry *res;\n\n\tres = container_of(kref, struct rdma_restrack_entry, kref);\n\tif (res->task) {\n\t\tput_task_struct(res->task);\n\t\tres->task = NULL;\n\t}\n\tcomplete(&res->comp);\n}\n\nint rdma_restrack_put(struct rdma_restrack_entry *res)\n{\n\treturn kref_put(&res->kref, restrack_release);\n}\nEXPORT_SYMBOL(rdma_restrack_put);\n\n \nvoid rdma_restrack_del(struct rdma_restrack_entry *res)\n{\n\tstruct rdma_restrack_entry *old;\n\tstruct rdma_restrack_root *rt;\n\tstruct ib_device *dev;\n\n\tif (!res->valid) {\n\t\tif (res->task) {\n\t\t\tput_task_struct(res->task);\n\t\t\tres->task = NULL;\n\t\t}\n\t\treturn;\n\t}\n\n\tif (res->no_track)\n\t\tgoto out;\n\n\tdev = res_to_dev(res);\n\tif (WARN_ON(!dev))\n\t\treturn;\n\n\trt = &dev->res[res->type];\n\n\told = xa_erase(&rt->xa, res->id);\n\tWARN_ON(old != res);\n\nout:\n\tres->valid = false;\n\trdma_restrack_put(res);\n\twait_for_completion(&res->comp);\n}\nEXPORT_SYMBOL(rdma_restrack_del);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}