{
  "module_name": "cma_configfs.c",
  "hash_id": "8347b308a75da95ef2a333310456f00926a0b09a8ea9c5112729eec6d6241bd8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/core/cma_configfs.c",
  "human_readable_source": " \n\n#include <linux/configfs.h>\n#include <rdma/ib_verbs.h>\n#include <rdma/rdma_cm.h>\n\n#include \"core_priv.h\"\n#include \"cma_priv.h\"\n\nstruct cma_device;\n\nstruct cma_dev_group;\n\nstruct cma_dev_port_group {\n\tu32\t\t\tport_num;\n\tstruct cma_dev_group\t*cma_dev_group;\n\tstruct config_group\tgroup;\n};\n\nstruct cma_dev_group {\n\tchar\t\t\t\tname[IB_DEVICE_NAME_MAX];\n\tstruct config_group\t\tdevice_group;\n\tstruct config_group\t\tports_group;\n\tstruct cma_dev_port_group\t*ports;\n};\n\nstatic struct cma_dev_port_group *to_dev_port_group(struct config_item *item)\n{\n\tstruct config_group *group;\n\n\tif (!item)\n\t\treturn NULL;\n\n\tgroup = container_of(item, struct config_group, cg_item);\n\treturn container_of(group, struct cma_dev_port_group, group);\n}\n\nstatic bool filter_by_name(struct ib_device *ib_dev, void *cookie)\n{\n\treturn !strcmp(dev_name(&ib_dev->dev), cookie);\n}\n\nstatic int cma_configfs_params_get(struct config_item *item,\n\t\t\t\t   struct cma_device **pcma_dev,\n\t\t\t\t   struct cma_dev_port_group **pgroup)\n{\n\tstruct cma_dev_port_group *group = to_dev_port_group(item);\n\tstruct cma_device *cma_dev;\n\n\tif (!group)\n\t\treturn -ENODEV;\n\n\tcma_dev = cma_enum_devices_by_ibdev(filter_by_name,\n\t\t\t\t\t    group->cma_dev_group->name);\n\tif (!cma_dev)\n\t\treturn -ENODEV;\n\n\t*pcma_dev = cma_dev;\n\t*pgroup = group;\n\n\treturn 0;\n}\n\nstatic void cma_configfs_params_put(struct cma_device *cma_dev)\n{\n\tcma_dev_put(cma_dev);\n}\n\nstatic ssize_t default_roce_mode_show(struct config_item *item,\n\t\t\t\t      char *buf)\n{\n\tstruct cma_device *cma_dev;\n\tstruct cma_dev_port_group *group;\n\tint gid_type;\n\tssize_t ret;\n\n\tret = cma_configfs_params_get(item, &cma_dev, &group);\n\tif (ret)\n\t\treturn ret;\n\n\tgid_type = cma_get_default_gid_type(cma_dev, group->port_num);\n\tcma_configfs_params_put(cma_dev);\n\n\tif (gid_type < 0)\n\t\treturn gid_type;\n\n\treturn sysfs_emit(buf, \"%s\\n\", ib_cache_gid_type_str(gid_type));\n}\n\nstatic ssize_t default_roce_mode_store(struct config_item *item,\n\t\t\t\t       const char *buf, size_t count)\n{\n\tstruct cma_device *cma_dev;\n\tstruct cma_dev_port_group *group;\n\tint gid_type;\n\tssize_t ret;\n\n\tret = cma_configfs_params_get(item, &cma_dev, &group);\n\tif (ret)\n\t\treturn ret;\n\n\tgid_type = ib_cache_gid_parse_type_str(buf);\n\tif (gid_type < 0) {\n\t\tcma_configfs_params_put(cma_dev);\n\t\treturn -EINVAL;\n\t}\n\n\tret = cma_set_default_gid_type(cma_dev, group->port_num, gid_type);\n\n\tcma_configfs_params_put(cma_dev);\n\n\treturn !ret ? strnlen(buf, count) : ret;\n}\n\nCONFIGFS_ATTR(, default_roce_mode);\n\nstatic ssize_t default_roce_tos_show(struct config_item *item, char *buf)\n{\n\tstruct cma_device *cma_dev;\n\tstruct cma_dev_port_group *group;\n\tssize_t ret;\n\tu8 tos;\n\n\tret = cma_configfs_params_get(item, &cma_dev, &group);\n\tif (ret)\n\t\treturn ret;\n\n\ttos = cma_get_default_roce_tos(cma_dev, group->port_num);\n\tcma_configfs_params_put(cma_dev);\n\n\treturn sysfs_emit(buf, \"%u\\n\", tos);\n}\n\nstatic ssize_t default_roce_tos_store(struct config_item *item,\n\t\t\t\t      const char *buf, size_t count)\n{\n\tstruct cma_device *cma_dev;\n\tstruct cma_dev_port_group *group;\n\tssize_t ret;\n\tu8 tos;\n\n\tret = kstrtou8(buf, 0, &tos);\n\tif (ret)\n\t\treturn ret;\n\n\tret = cma_configfs_params_get(item, &cma_dev, &group);\n\tif (ret)\n\t\treturn ret;\n\n\tret = cma_set_default_roce_tos(cma_dev, group->port_num, tos);\n\tcma_configfs_params_put(cma_dev);\n\n\treturn ret ? ret : strnlen(buf, count);\n}\n\nCONFIGFS_ATTR(, default_roce_tos);\n\nstatic struct configfs_attribute *cma_configfs_attributes[] = {\n\t&attr_default_roce_mode,\n\t&attr_default_roce_tos,\n\tNULL,\n};\n\nstatic const struct config_item_type cma_port_group_type = {\n\t.ct_attrs\t= cma_configfs_attributes,\n\t.ct_owner\t= THIS_MODULE\n};\n\nstatic int make_cma_ports(struct cma_dev_group *cma_dev_group,\n\t\t\t  struct cma_device *cma_dev)\n{\n\tstruct cma_dev_port_group *ports;\n\tstruct ib_device *ibdev;\n\tu32 ports_num;\n\tu32 i;\n\n\tibdev = cma_get_ib_dev(cma_dev);\n\n\tif (!ibdev)\n\t\treturn -ENODEV;\n\n\tports_num = ibdev->phys_port_cnt;\n\tports = kcalloc(ports_num, sizeof(*cma_dev_group->ports),\n\t\t\tGFP_KERNEL);\n\n\tif (!ports)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ports_num; i++) {\n\t\tchar port_str[11];\n\n\t\tports[i].port_num = i + 1;\n\t\tsnprintf(port_str, sizeof(port_str), \"%u\", i + 1);\n\t\tports[i].cma_dev_group = cma_dev_group;\n\t\tconfig_group_init_type_name(&ports[i].group,\n\t\t\t\t\t    port_str,\n\t\t\t\t\t    &cma_port_group_type);\n\t\tconfigfs_add_default_group(&ports[i].group,\n\t\t\t\t&cma_dev_group->ports_group);\n\n\t}\n\tcma_dev_group->ports = ports;\n\treturn 0;\n}\n\nstatic void release_cma_dev(struct config_item  *item)\n{\n\tstruct config_group *group = container_of(item, struct config_group,\n\t\t\t\t\t\t  cg_item);\n\tstruct cma_dev_group *cma_dev_group = container_of(group,\n\t\t\t\t\t\t\t   struct cma_dev_group,\n\t\t\t\t\t\t\t   device_group);\n\n\tkfree(cma_dev_group);\n};\n\nstatic void release_cma_ports_group(struct config_item  *item)\n{\n\tstruct config_group *group = container_of(item, struct config_group,\n\t\t\t\t\t\t  cg_item);\n\tstruct cma_dev_group *cma_dev_group = container_of(group,\n\t\t\t\t\t\t\t   struct cma_dev_group,\n\t\t\t\t\t\t\t   ports_group);\n\n\tkfree(cma_dev_group->ports);\n\tcma_dev_group->ports = NULL;\n};\n\nstatic struct configfs_item_operations cma_ports_item_ops = {\n\t.release = release_cma_ports_group\n};\n\nstatic const struct config_item_type cma_ports_group_type = {\n\t.ct_item_ops\t= &cma_ports_item_ops,\n\t.ct_owner\t= THIS_MODULE\n};\n\nstatic struct configfs_item_operations cma_device_item_ops = {\n\t.release = release_cma_dev\n};\n\nstatic const struct config_item_type cma_device_group_type = {\n\t.ct_item_ops\t= &cma_device_item_ops,\n\t.ct_owner\t= THIS_MODULE\n};\n\nstatic struct config_group *make_cma_dev(struct config_group *group,\n\t\t\t\t\t const char *name)\n{\n\tint err = -ENODEV;\n\tstruct cma_device *cma_dev = cma_enum_devices_by_ibdev(filter_by_name,\n\t\t\t\t\t\t\t       (void *)name);\n\tstruct cma_dev_group *cma_dev_group = NULL;\n\n\tif (!cma_dev)\n\t\tgoto fail;\n\n\tcma_dev_group = kzalloc(sizeof(*cma_dev_group), GFP_KERNEL);\n\n\tif (!cma_dev_group) {\n\t\terr = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tstrscpy(cma_dev_group->name, name, sizeof(cma_dev_group->name));\n\n\tconfig_group_init_type_name(&cma_dev_group->ports_group, \"ports\",\n\t\t\t\t    &cma_ports_group_type);\n\n\terr = make_cma_ports(cma_dev_group, cma_dev);\n\tif (err)\n\t\tgoto fail;\n\n\tconfig_group_init_type_name(&cma_dev_group->device_group, name,\n\t\t\t\t    &cma_device_group_type);\n\tconfigfs_add_default_group(&cma_dev_group->ports_group,\n\t\t\t&cma_dev_group->device_group);\n\n\tcma_dev_put(cma_dev);\n\treturn &cma_dev_group->device_group;\n\nfail:\n\tif (cma_dev)\n\t\tcma_dev_put(cma_dev);\n\tkfree(cma_dev_group);\n\treturn ERR_PTR(err);\n}\n\nstatic void drop_cma_dev(struct config_group *cgroup, struct config_item *item)\n{\n\tstruct config_group *group =\n\t\tcontainer_of(item, struct config_group, cg_item);\n\tstruct cma_dev_group *cma_dev_group =\n\t\tcontainer_of(group, struct cma_dev_group, device_group);\n\n\tconfigfs_remove_default_groups(&cma_dev_group->ports_group);\n\tconfigfs_remove_default_groups(&cma_dev_group->device_group);\n\tconfig_item_put(item);\n}\n\nstatic struct configfs_group_operations cma_subsys_group_ops = {\n\t.make_group\t= make_cma_dev,\n\t.drop_item\t= drop_cma_dev,\n};\n\nstatic const struct config_item_type cma_subsys_type = {\n\t.ct_group_ops\t= &cma_subsys_group_ops,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstatic struct configfs_subsystem cma_subsys = {\n\t.su_group\t= {\n\t\t.cg_item\t= {\n\t\t\t.ci_namebuf\t= \"rdma_cm\",\n\t\t\t.ci_type\t= &cma_subsys_type,\n\t\t},\n\t},\n};\n\nint __init cma_configfs_init(void)\n{\n\tint ret;\n\n\tconfig_group_init(&cma_subsys.su_group);\n\tmutex_init(&cma_subsys.su_mutex);\n\tret = configfs_register_subsystem(&cma_subsys);\n\tif (ret)\n\t\tmutex_destroy(&cma_subsys.su_mutex);\n\treturn ret;\n}\n\nvoid __exit cma_configfs_exit(void)\n{\n\tconfigfs_unregister_subsystem(&cma_subsys);\n\tmutex_destroy(&cma_subsys.su_mutex);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}