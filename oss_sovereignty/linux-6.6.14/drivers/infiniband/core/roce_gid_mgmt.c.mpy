{
  "module_name": "roce_gid_mgmt.c",
  "hash_id": "54d4b680f690df6408e05def66aa7199e5bede033559f0d6929aabd24d5a7b77",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/core/roce_gid_mgmt.c",
  "human_readable_source": " \n\n#include \"core_priv.h\"\n\n#include <linux/in.h>\n#include <linux/in6.h>\n\n \n#include <net/addrconf.h>\n#include <net/bonding.h>\n\n#include <rdma/ib_cache.h>\n#include <rdma/ib_addr.h>\n\nstatic struct workqueue_struct *gid_cache_wq;\n\nenum gid_op_type {\n\tGID_DEL = 0,\n\tGID_ADD\n};\n\nstruct update_gid_event_work {\n\tstruct work_struct work;\n\tunion ib_gid       gid;\n\tstruct ib_gid_attr gid_attr;\n\tenum gid_op_type gid_op;\n};\n\n#define ROCE_NETDEV_CALLBACK_SZ\t\t3\nstruct netdev_event_work_cmd {\n\troce_netdev_callback\tcb;\n\troce_netdev_filter\tfilter;\n\tstruct net_device\t*ndev;\n\tstruct net_device\t*filter_ndev;\n};\n\nstruct netdev_event_work {\n\tstruct work_struct\t\twork;\n\tstruct netdev_event_work_cmd\tcmds[ROCE_NETDEV_CALLBACK_SZ];\n};\n\nstatic const struct {\n\tbool (*is_supported)(const struct ib_device *device, u32 port_num);\n\tenum ib_gid_type gid_type;\n} PORT_CAP_TO_GID_TYPE[] = {\n\t{rdma_protocol_roce_eth_encap, IB_GID_TYPE_ROCE},\n\t{rdma_protocol_roce_udp_encap, IB_GID_TYPE_ROCE_UDP_ENCAP},\n};\n\n#define CAP_TO_GID_TABLE_SIZE\tARRAY_SIZE(PORT_CAP_TO_GID_TYPE)\n\nunsigned long roce_gid_type_mask_support(struct ib_device *ib_dev, u32 port)\n{\n\tint i;\n\tunsigned int ret_flags = 0;\n\n\tif (!rdma_protocol_roce(ib_dev, port))\n\t\treturn 1UL << IB_GID_TYPE_IB;\n\n\tfor (i = 0; i < CAP_TO_GID_TABLE_SIZE; i++)\n\t\tif (PORT_CAP_TO_GID_TYPE[i].is_supported(ib_dev, port))\n\t\t\tret_flags |= 1UL << PORT_CAP_TO_GID_TYPE[i].gid_type;\n\n\treturn ret_flags;\n}\nEXPORT_SYMBOL(roce_gid_type_mask_support);\n\nstatic void update_gid(enum gid_op_type gid_op, struct ib_device *ib_dev,\n\t\t       u32 port, union ib_gid *gid,\n\t\t       struct ib_gid_attr *gid_attr)\n{\n\tint i;\n\tunsigned long gid_type_mask = roce_gid_type_mask_support(ib_dev, port);\n\n\tfor (i = 0; i < IB_GID_TYPE_SIZE; i++) {\n\t\tif ((1UL << i) & gid_type_mask) {\n\t\t\tgid_attr->gid_type = i;\n\t\t\tswitch (gid_op) {\n\t\t\tcase GID_ADD:\n\t\t\t\tib_cache_gid_add(ib_dev, port,\n\t\t\t\t\t\t gid, gid_attr);\n\t\t\t\tbreak;\n\t\t\tcase GID_DEL:\n\t\t\t\tib_cache_gid_del(ib_dev, port,\n\t\t\t\t\t\t gid, gid_attr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nenum bonding_slave_state {\n\tBONDING_SLAVE_STATE_ACTIVE\t= 1UL << 0,\n\tBONDING_SLAVE_STATE_INACTIVE\t= 1UL << 1,\n\t \n\tBONDING_SLAVE_STATE_NA\t\t= 1UL << 2,\n};\n\nstatic enum bonding_slave_state is_eth_active_slave_of_bonding_rcu(struct net_device *dev,\n\t\t\t\t\t\t\t\t   struct net_device *upper)\n{\n\tif (upper && netif_is_bond_master(upper)) {\n\t\tstruct net_device *pdev =\n\t\t\tbond_option_active_slave_get_rcu(netdev_priv(upper));\n\n\t\tif (pdev)\n\t\t\treturn dev == pdev ? BONDING_SLAVE_STATE_ACTIVE :\n\t\t\t\tBONDING_SLAVE_STATE_INACTIVE;\n\t}\n\n\treturn BONDING_SLAVE_STATE_NA;\n}\n\n#define REQUIRED_BOND_STATES\t\t(BONDING_SLAVE_STATE_ACTIVE |\t\\\n\t\t\t\t\t BONDING_SLAVE_STATE_NA)\nstatic bool\nis_eth_port_of_netdev_filter(struct ib_device *ib_dev, u32 port,\n\t\t\t     struct net_device *rdma_ndev, void *cookie)\n{\n\tstruct net_device *real_dev;\n\tbool res;\n\n\tif (!rdma_ndev)\n\t\treturn false;\n\n\trcu_read_lock();\n\treal_dev = rdma_vlan_dev_real_dev(cookie);\n\tif (!real_dev)\n\t\treal_dev = cookie;\n\n\tres = ((rdma_is_upper_dev_rcu(rdma_ndev, cookie) &&\n\t       (is_eth_active_slave_of_bonding_rcu(rdma_ndev, real_dev) &\n\t\tREQUIRED_BOND_STATES)) ||\n\t       real_dev == rdma_ndev);\n\n\trcu_read_unlock();\n\treturn res;\n}\n\nstatic bool\nis_eth_port_inactive_slave_filter(struct ib_device *ib_dev, u32 port,\n\t\t\t\t  struct net_device *rdma_ndev, void *cookie)\n{\n\tstruct net_device *master_dev;\n\tbool res;\n\n\tif (!rdma_ndev)\n\t\treturn false;\n\n\trcu_read_lock();\n\tmaster_dev = netdev_master_upper_dev_get_rcu(rdma_ndev);\n\tres = is_eth_active_slave_of_bonding_rcu(rdma_ndev, master_dev) ==\n\t\tBONDING_SLAVE_STATE_INACTIVE;\n\trcu_read_unlock();\n\n\treturn res;\n}\n\n \nstatic bool\nis_ndev_for_default_gid_filter(struct ib_device *ib_dev, u32 port,\n\t\t\t       struct net_device *rdma_ndev, void *cookie)\n{\n\tstruct net_device *cookie_ndev = cookie;\n\tbool res;\n\n\tif (!rdma_ndev)\n\t\treturn false;\n\n\trcu_read_lock();\n\n\t \n\tres = ((cookie_ndev == rdma_ndev && !netif_is_bond_slave(rdma_ndev)) ||\n\t       (netif_is_bond_master(cookie_ndev) &&\n\t\trdma_is_upper_dev_rcu(rdma_ndev, cookie_ndev)));\n\n\trcu_read_unlock();\n\treturn res;\n}\n\nstatic bool pass_all_filter(struct ib_device *ib_dev, u32 port,\n\t\t\t    struct net_device *rdma_ndev, void *cookie)\n{\n\treturn true;\n}\n\nstatic bool upper_device_filter(struct ib_device *ib_dev, u32 port,\n\t\t\t\tstruct net_device *rdma_ndev, void *cookie)\n{\n\tbool res;\n\n\tif (!rdma_ndev)\n\t\treturn false;\n\n\tif (rdma_ndev == cookie)\n\t\treturn true;\n\n\trcu_read_lock();\n\tres = rdma_is_upper_dev_rcu(rdma_ndev, cookie);\n\trcu_read_unlock();\n\n\treturn res;\n}\n\n \nstatic bool\nis_upper_ndev_bond_master_filter(struct ib_device *ib_dev, u32 port,\n\t\t\t\t struct net_device *rdma_ndev,\n\t\t\t\t void *cookie)\n{\n\tstruct net_device *cookie_ndev = cookie;\n\tbool match = false;\n\n\tif (!rdma_ndev)\n\t\treturn false;\n\n\trcu_read_lock();\n\tif (netif_is_bond_master(cookie_ndev) &&\n\t    rdma_is_upper_dev_rcu(rdma_ndev, cookie_ndev))\n\t\tmatch = true;\n\trcu_read_unlock();\n\treturn match;\n}\n\nstatic void update_gid_ip(enum gid_op_type gid_op,\n\t\t\t  struct ib_device *ib_dev,\n\t\t\t  u32 port, struct net_device *ndev,\n\t\t\t  struct sockaddr *addr)\n{\n\tunion ib_gid gid;\n\tstruct ib_gid_attr gid_attr;\n\n\trdma_ip2gid(addr, &gid);\n\tmemset(&gid_attr, 0, sizeof(gid_attr));\n\tgid_attr.ndev = ndev;\n\n\tupdate_gid(gid_op, ib_dev, port, &gid, &gid_attr);\n}\n\nstatic void bond_delete_netdev_default_gids(struct ib_device *ib_dev,\n\t\t\t\t\t    u32 port,\n\t\t\t\t\t    struct net_device *rdma_ndev,\n\t\t\t\t\t    struct net_device *event_ndev)\n{\n\tstruct net_device *real_dev = rdma_vlan_dev_real_dev(event_ndev);\n\tunsigned long gid_type_mask;\n\n\tif (!rdma_ndev)\n\t\treturn;\n\n\tif (!real_dev)\n\t\treal_dev = event_ndev;\n\n\trcu_read_lock();\n\n\tif (((rdma_ndev != event_ndev &&\n\t      !rdma_is_upper_dev_rcu(rdma_ndev, event_ndev)) ||\n\t     is_eth_active_slave_of_bonding_rcu(rdma_ndev, real_dev)\n\t\t\t\t\t\t ==\n\t     BONDING_SLAVE_STATE_INACTIVE)) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\trcu_read_unlock();\n\n\tgid_type_mask = roce_gid_type_mask_support(ib_dev, port);\n\n\tib_cache_gid_set_default_gid(ib_dev, port, rdma_ndev,\n\t\t\t\t     gid_type_mask,\n\t\t\t\t     IB_CACHE_GID_DEFAULT_MODE_DELETE);\n}\n\nstatic void enum_netdev_ipv4_ips(struct ib_device *ib_dev,\n\t\t\t\t u32 port, struct net_device *ndev)\n{\n\tconst struct in_ifaddr *ifa;\n\tstruct in_device *in_dev;\n\tstruct sin_list {\n\t\tstruct list_head\tlist;\n\t\tstruct sockaddr_in\tip;\n\t};\n\tstruct sin_list *sin_iter;\n\tstruct sin_list *sin_temp;\n\n\tLIST_HEAD(sin_list);\n\tif (ndev->reg_state >= NETREG_UNREGISTERING)\n\t\treturn;\n\n\trcu_read_lock();\n\tin_dev = __in_dev_get_rcu(ndev);\n\tif (!in_dev) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tin_dev_for_each_ifa_rcu(ifa, in_dev) {\n\t\tstruct sin_list *entry = kzalloc(sizeof(*entry), GFP_ATOMIC);\n\n\t\tif (!entry)\n\t\t\tcontinue;\n\n\t\tentry->ip.sin_family = AF_INET;\n\t\tentry->ip.sin_addr.s_addr = ifa->ifa_address;\n\t\tlist_add_tail(&entry->list, &sin_list);\n\t}\n\n\trcu_read_unlock();\n\n\tlist_for_each_entry_safe(sin_iter, sin_temp, &sin_list, list) {\n\t\tupdate_gid_ip(GID_ADD, ib_dev, port, ndev,\n\t\t\t      (struct sockaddr *)&sin_iter->ip);\n\t\tlist_del(&sin_iter->list);\n\t\tkfree(sin_iter);\n\t}\n}\n\nstatic void enum_netdev_ipv6_ips(struct ib_device *ib_dev,\n\t\t\t\t u32 port, struct net_device *ndev)\n{\n\tstruct inet6_ifaddr *ifp;\n\tstruct inet6_dev *in6_dev;\n\tstruct sin6_list {\n\t\tstruct list_head\tlist;\n\t\tstruct sockaddr_in6\tsin6;\n\t};\n\tstruct sin6_list *sin6_iter;\n\tstruct sin6_list *sin6_temp;\n\tstruct ib_gid_attr gid_attr = {.ndev = ndev};\n\tLIST_HEAD(sin6_list);\n\n\tif (ndev->reg_state >= NETREG_UNREGISTERING)\n\t\treturn;\n\n\tin6_dev = in6_dev_get(ndev);\n\tif (!in6_dev)\n\t\treturn;\n\n\tread_lock_bh(&in6_dev->lock);\n\tlist_for_each_entry(ifp, &in6_dev->addr_list, if_list) {\n\t\tstruct sin6_list *entry = kzalloc(sizeof(*entry), GFP_ATOMIC);\n\n\t\tif (!entry)\n\t\t\tcontinue;\n\n\t\tentry->sin6.sin6_family = AF_INET6;\n\t\tentry->sin6.sin6_addr = ifp->addr;\n\t\tlist_add_tail(&entry->list, &sin6_list);\n\t}\n\tread_unlock_bh(&in6_dev->lock);\n\n\tin6_dev_put(in6_dev);\n\n\tlist_for_each_entry_safe(sin6_iter, sin6_temp, &sin6_list, list) {\n\t\tunion ib_gid\tgid;\n\n\t\trdma_ip2gid((struct sockaddr *)&sin6_iter->sin6, &gid);\n\t\tupdate_gid(GID_ADD, ib_dev, port, &gid, &gid_attr);\n\t\tlist_del(&sin6_iter->list);\n\t\tkfree(sin6_iter);\n\t}\n}\n\nstatic void _add_netdev_ips(struct ib_device *ib_dev, u32 port,\n\t\t\t    struct net_device *ndev)\n{\n\tenum_netdev_ipv4_ips(ib_dev, port, ndev);\n\tif (IS_ENABLED(CONFIG_IPV6))\n\t\tenum_netdev_ipv6_ips(ib_dev, port, ndev);\n}\n\nstatic void add_netdev_ips(struct ib_device *ib_dev, u32 port,\n\t\t\t   struct net_device *rdma_ndev, void *cookie)\n{\n\t_add_netdev_ips(ib_dev, port, cookie);\n}\n\nstatic void del_netdev_ips(struct ib_device *ib_dev, u32 port,\n\t\t\t   struct net_device *rdma_ndev, void *cookie)\n{\n\tib_cache_gid_del_all_netdev_gids(ib_dev, port, cookie);\n}\n\n \nstatic void del_default_gids(struct ib_device *ib_dev, u32 port,\n\t\t\t     struct net_device *rdma_ndev, void *cookie)\n{\n\tstruct net_device *cookie_ndev = cookie;\n\tunsigned long gid_type_mask;\n\n\tgid_type_mask = roce_gid_type_mask_support(ib_dev, port);\n\n\tib_cache_gid_set_default_gid(ib_dev, port, cookie_ndev, gid_type_mask,\n\t\t\t\t     IB_CACHE_GID_DEFAULT_MODE_DELETE);\n}\n\nstatic void add_default_gids(struct ib_device *ib_dev, u32 port,\n\t\t\t     struct net_device *rdma_ndev, void *cookie)\n{\n\tstruct net_device *event_ndev = cookie;\n\tunsigned long gid_type_mask;\n\n\tgid_type_mask = roce_gid_type_mask_support(ib_dev, port);\n\tib_cache_gid_set_default_gid(ib_dev, port, event_ndev, gid_type_mask,\n\t\t\t\t     IB_CACHE_GID_DEFAULT_MODE_SET);\n}\n\nstatic void enum_all_gids_of_dev_cb(struct ib_device *ib_dev,\n\t\t\t\t    u32 port,\n\t\t\t\t    struct net_device *rdma_ndev,\n\t\t\t\t    void *cookie)\n{\n\tstruct net *net;\n\tstruct net_device *ndev;\n\n\t \n\trtnl_lock();\n\tdown_read(&net_rwsem);\n\tfor_each_net(net)\n\t\tfor_each_netdev(net, ndev) {\n\t\t\t \n\t\t\tif (is_ndev_for_default_gid_filter(ib_dev, port,\n\t\t\t\t\t\t\t   rdma_ndev, ndev))\n\t\t\t\tadd_default_gids(ib_dev, port, rdma_ndev, ndev);\n\n\t\t\tif (is_eth_port_of_netdev_filter(ib_dev, port,\n\t\t\t\t\t\t\t rdma_ndev, ndev))\n\t\t\t\t_add_netdev_ips(ib_dev, port, ndev);\n\t\t}\n\tup_read(&net_rwsem);\n\trtnl_unlock();\n}\n\n \nvoid rdma_roce_rescan_device(struct ib_device *ib_dev)\n{\n\tib_enum_roce_netdev(ib_dev, pass_all_filter, NULL,\n\t\t\t    enum_all_gids_of_dev_cb, NULL);\n}\nEXPORT_SYMBOL(rdma_roce_rescan_device);\n\nstatic void callback_for_addr_gid_device_scan(struct ib_device *device,\n\t\t\t\t\t      u32 port,\n\t\t\t\t\t      struct net_device *rdma_ndev,\n\t\t\t\t\t      void *cookie)\n{\n\tstruct update_gid_event_work *parsed = cookie;\n\n\treturn update_gid(parsed->gid_op, device,\n\t\t\t  port, &parsed->gid,\n\t\t\t  &parsed->gid_attr);\n}\n\nstruct upper_list {\n\tstruct list_head list;\n\tstruct net_device *upper;\n};\n\nstatic int netdev_upper_walk(struct net_device *upper,\n\t\t\t     struct netdev_nested_priv *priv)\n{\n\tstruct upper_list *entry = kmalloc(sizeof(*entry), GFP_ATOMIC);\n\tstruct list_head *upper_list = (struct list_head *)priv->data;\n\n\tif (!entry)\n\t\treturn 0;\n\n\tlist_add_tail(&entry->list, upper_list);\n\tdev_hold(upper);\n\tentry->upper = upper;\n\n\treturn 0;\n}\n\nstatic void handle_netdev_upper(struct ib_device *ib_dev, u32 port,\n\t\t\t\tvoid *cookie,\n\t\t\t\tvoid (*handle_netdev)(struct ib_device *ib_dev,\n\t\t\t\t\t\t      u32 port,\n\t\t\t\t\t\t      struct net_device *ndev))\n{\n\tstruct net_device *ndev = cookie;\n\tstruct netdev_nested_priv priv;\n\tstruct upper_list *upper_iter;\n\tstruct upper_list *upper_temp;\n\tLIST_HEAD(upper_list);\n\n\tpriv.data = &upper_list;\n\trcu_read_lock();\n\tnetdev_walk_all_upper_dev_rcu(ndev, netdev_upper_walk, &priv);\n\trcu_read_unlock();\n\n\thandle_netdev(ib_dev, port, ndev);\n\tlist_for_each_entry_safe(upper_iter, upper_temp, &upper_list,\n\t\t\t\t list) {\n\t\thandle_netdev(ib_dev, port, upper_iter->upper);\n\t\tdev_put(upper_iter->upper);\n\t\tlist_del(&upper_iter->list);\n\t\tkfree(upper_iter);\n\t}\n}\n\nstatic void _roce_del_all_netdev_gids(struct ib_device *ib_dev, u32 port,\n\t\t\t\t      struct net_device *event_ndev)\n{\n\tib_cache_gid_del_all_netdev_gids(ib_dev, port, event_ndev);\n}\n\nstatic void del_netdev_upper_ips(struct ib_device *ib_dev, u32 port,\n\t\t\t\t struct net_device *rdma_ndev, void *cookie)\n{\n\thandle_netdev_upper(ib_dev, port, cookie, _roce_del_all_netdev_gids);\n}\n\nstatic void add_netdev_upper_ips(struct ib_device *ib_dev, u32 port,\n\t\t\t\t struct net_device *rdma_ndev, void *cookie)\n{\n\thandle_netdev_upper(ib_dev, port, cookie, _add_netdev_ips);\n}\n\nstatic void del_netdev_default_ips_join(struct ib_device *ib_dev, u32 port,\n\t\t\t\t\tstruct net_device *rdma_ndev,\n\t\t\t\t\tvoid *cookie)\n{\n\tstruct net_device *master_ndev;\n\n\trcu_read_lock();\n\tmaster_ndev = netdev_master_upper_dev_get_rcu(rdma_ndev);\n\tif (master_ndev)\n\t\tdev_hold(master_ndev);\n\trcu_read_unlock();\n\n\tif (master_ndev) {\n\t\tbond_delete_netdev_default_gids(ib_dev, port, rdma_ndev,\n\t\t\t\t\t\tmaster_ndev);\n\t\tdev_put(master_ndev);\n\t}\n}\n\n \n\nstatic void netdevice_event_work_handler(struct work_struct *_work)\n{\n\tstruct netdev_event_work *work =\n\t\tcontainer_of(_work, struct netdev_event_work, work);\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(work->cmds) && work->cmds[i].cb; i++) {\n\t\tib_enum_all_roce_netdevs(work->cmds[i].filter,\n\t\t\t\t\t work->cmds[i].filter_ndev,\n\t\t\t\t\t work->cmds[i].cb,\n\t\t\t\t\t work->cmds[i].ndev);\n\t\tdev_put(work->cmds[i].ndev);\n\t\tdev_put(work->cmds[i].filter_ndev);\n\t}\n\n\tkfree(work);\n}\n\nstatic int netdevice_queue_work(struct netdev_event_work_cmd *cmds,\n\t\t\t\tstruct net_device *ndev)\n{\n\tunsigned int i;\n\tstruct netdev_event_work *ndev_work =\n\t\tkmalloc(sizeof(*ndev_work), GFP_KERNEL);\n\n\tif (!ndev_work)\n\t\treturn NOTIFY_DONE;\n\n\tmemcpy(ndev_work->cmds, cmds, sizeof(ndev_work->cmds));\n\tfor (i = 0; i < ARRAY_SIZE(ndev_work->cmds) && ndev_work->cmds[i].cb; i++) {\n\t\tif (!ndev_work->cmds[i].ndev)\n\t\t\tndev_work->cmds[i].ndev = ndev;\n\t\tif (!ndev_work->cmds[i].filter_ndev)\n\t\t\tndev_work->cmds[i].filter_ndev = ndev;\n\t\tdev_hold(ndev_work->cmds[i].ndev);\n\t\tdev_hold(ndev_work->cmds[i].filter_ndev);\n\t}\n\tINIT_WORK(&ndev_work->work, netdevice_event_work_handler);\n\n\tqueue_work(gid_cache_wq, &ndev_work->work);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic const struct netdev_event_work_cmd add_cmd = {\n\t.cb\t= add_netdev_ips,\n\t.filter\t= is_eth_port_of_netdev_filter\n};\n\nstatic const struct netdev_event_work_cmd add_cmd_upper_ips = {\n\t.cb\t= add_netdev_upper_ips,\n\t.filter = is_eth_port_of_netdev_filter\n};\n\nstatic void\nndev_event_unlink(struct netdev_notifier_changeupper_info *changeupper_info,\n\t\t  struct netdev_event_work_cmd *cmds)\n{\n\tstatic const struct netdev_event_work_cmd\n\t\t\tupper_ips_del_cmd = {\n\t\t\t\t.cb\t= del_netdev_upper_ips,\n\t\t\t\t.filter\t= upper_device_filter\n\t};\n\n\tcmds[0] = upper_ips_del_cmd;\n\tcmds[0].ndev = changeupper_info->upper_dev;\n\tcmds[1] = add_cmd;\n}\n\nstatic const struct netdev_event_work_cmd bonding_default_add_cmd = {\n\t.cb\t= add_default_gids,\n\t.filter\t= is_upper_ndev_bond_master_filter\n};\n\nstatic void\nndev_event_link(struct net_device *event_ndev,\n\t\tstruct netdev_notifier_changeupper_info *changeupper_info,\n\t\tstruct netdev_event_work_cmd *cmds)\n{\n\tstatic const struct netdev_event_work_cmd\n\t\t\tbonding_default_del_cmd = {\n\t\t\t\t.cb\t= del_default_gids,\n\t\t\t\t.filter\t= is_upper_ndev_bond_master_filter\n\t\t\t};\n\t \n\tcmds[0] = bonding_default_del_cmd;\n\tcmds[0].ndev = event_ndev;\n\tcmds[0].filter_ndev = changeupper_info->upper_dev;\n\n\t \n\tcmds[1] = bonding_default_add_cmd;\n\tcmds[1].ndev = changeupper_info->upper_dev;\n\tcmds[1].filter_ndev = changeupper_info->upper_dev;\n\n\t \n\tcmds[2] = add_cmd_upper_ips;\n\tcmds[2].ndev = changeupper_info->upper_dev;\n\tcmds[2].filter_ndev = changeupper_info->upper_dev;\n}\n\nstatic void netdevice_event_changeupper(struct net_device *event_ndev,\n\t\tstruct netdev_notifier_changeupper_info *changeupper_info,\n\t\tstruct netdev_event_work_cmd *cmds)\n{\n\tif (changeupper_info->linking)\n\t\tndev_event_link(event_ndev, changeupper_info, cmds);\n\telse\n\t\tndev_event_unlink(changeupper_info, cmds);\n}\n\nstatic const struct netdev_event_work_cmd add_default_gid_cmd = {\n\t.cb\t= add_default_gids,\n\t.filter\t= is_ndev_for_default_gid_filter,\n};\n\nstatic int netdevice_event(struct notifier_block *this, unsigned long event,\n\t\t\t   void *ptr)\n{\n\tstatic const struct netdev_event_work_cmd del_cmd = {\n\t\t.cb = del_netdev_ips, .filter = pass_all_filter};\n\tstatic const struct netdev_event_work_cmd\n\t\t\tbonding_default_del_cmd_join = {\n\t\t\t\t.cb\t= del_netdev_default_ips_join,\n\t\t\t\t.filter\t= is_eth_port_inactive_slave_filter\n\t\t\t};\n\tstatic const struct netdev_event_work_cmd\n\t\t\tnetdev_del_cmd = {\n\t\t\t\t.cb\t= del_netdev_ips,\n\t\t\t\t.filter = is_eth_port_of_netdev_filter\n\t\t\t};\n\tstatic const struct netdev_event_work_cmd bonding_event_ips_del_cmd = {\n\t\t.cb = del_netdev_upper_ips, .filter = upper_device_filter};\n\tstruct net_device *ndev = netdev_notifier_info_to_dev(ptr);\n\tstruct netdev_event_work_cmd cmds[ROCE_NETDEV_CALLBACK_SZ] = { {NULL} };\n\n\tif (ndev->type != ARPHRD_ETHER)\n\t\treturn NOTIFY_DONE;\n\n\tswitch (event) {\n\tcase NETDEV_REGISTER:\n\tcase NETDEV_UP:\n\t\tcmds[0] = bonding_default_del_cmd_join;\n\t\tcmds[1] = add_default_gid_cmd;\n\t\tcmds[2] = add_cmd;\n\t\tbreak;\n\n\tcase NETDEV_UNREGISTER:\n\t\tif (ndev->reg_state < NETREG_UNREGISTERED)\n\t\t\tcmds[0] = del_cmd;\n\t\telse\n\t\t\treturn NOTIFY_DONE;\n\t\tbreak;\n\n\tcase NETDEV_CHANGEADDR:\n\t\tcmds[0] = netdev_del_cmd;\n\t\tif (ndev->reg_state == NETREG_REGISTERED) {\n\t\t\tcmds[1] = add_default_gid_cmd;\n\t\t\tcmds[2] = add_cmd;\n\t\t}\n\t\tbreak;\n\n\tcase NETDEV_CHANGEUPPER:\n\t\tnetdevice_event_changeupper(ndev,\n\t\t\tcontainer_of(ptr, struct netdev_notifier_changeupper_info, info),\n\t\t\tcmds);\n\t\tbreak;\n\n\tcase NETDEV_BONDING_FAILOVER:\n\t\tcmds[0] = bonding_event_ips_del_cmd;\n\t\t \n\t\tcmds[1] = bonding_default_add_cmd;\n\t\t \n\t\tcmds[2] = add_cmd_upper_ips;\n\t\tbreak;\n\n\tdefault:\n\t\treturn NOTIFY_DONE;\n\t}\n\n\treturn netdevice_queue_work(cmds, ndev);\n}\n\nstatic void update_gid_event_work_handler(struct work_struct *_work)\n{\n\tstruct update_gid_event_work *work =\n\t\tcontainer_of(_work, struct update_gid_event_work, work);\n\n\tib_enum_all_roce_netdevs(is_eth_port_of_netdev_filter,\n\t\t\t\t work->gid_attr.ndev,\n\t\t\t\t callback_for_addr_gid_device_scan, work);\n\n\tdev_put(work->gid_attr.ndev);\n\tkfree(work);\n}\n\nstatic int addr_event(struct notifier_block *this, unsigned long event,\n\t\t      struct sockaddr *sa, struct net_device *ndev)\n{\n\tstruct update_gid_event_work *work;\n\tenum gid_op_type gid_op;\n\n\tif (ndev->type != ARPHRD_ETHER)\n\t\treturn NOTIFY_DONE;\n\n\tswitch (event) {\n\tcase NETDEV_UP:\n\t\tgid_op = GID_ADD;\n\t\tbreak;\n\n\tcase NETDEV_DOWN:\n\t\tgid_op = GID_DEL;\n\t\tbreak;\n\n\tdefault:\n\t\treturn NOTIFY_DONE;\n\t}\n\n\twork = kmalloc(sizeof(*work), GFP_ATOMIC);\n\tif (!work)\n\t\treturn NOTIFY_DONE;\n\n\tINIT_WORK(&work->work, update_gid_event_work_handler);\n\n\trdma_ip2gid(sa, &work->gid);\n\twork->gid_op = gid_op;\n\n\tmemset(&work->gid_attr, 0, sizeof(work->gid_attr));\n\tdev_hold(ndev);\n\twork->gid_attr.ndev   = ndev;\n\n\tqueue_work(gid_cache_wq, &work->work);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int inetaddr_event(struct notifier_block *this, unsigned long event,\n\t\t\t  void *ptr)\n{\n\tstruct sockaddr_in\tin;\n\tstruct net_device\t*ndev;\n\tstruct in_ifaddr\t*ifa = ptr;\n\n\tin.sin_family = AF_INET;\n\tin.sin_addr.s_addr = ifa->ifa_address;\n\tndev = ifa->ifa_dev->dev;\n\n\treturn addr_event(this, event, (struct sockaddr *)&in, ndev);\n}\n\nstatic int inet6addr_event(struct notifier_block *this, unsigned long event,\n\t\t\t   void *ptr)\n{\n\tstruct sockaddr_in6\tin6;\n\tstruct net_device\t*ndev;\n\tstruct inet6_ifaddr\t*ifa6 = ptr;\n\n\tin6.sin6_family = AF_INET6;\n\tin6.sin6_addr = ifa6->addr;\n\tndev = ifa6->idev->dev;\n\n\treturn addr_event(this, event, (struct sockaddr *)&in6, ndev);\n}\n\nstatic struct notifier_block nb_netdevice = {\n\t.notifier_call = netdevice_event\n};\n\nstatic struct notifier_block nb_inetaddr = {\n\t.notifier_call = inetaddr_event\n};\n\nstatic struct notifier_block nb_inet6addr = {\n\t.notifier_call = inet6addr_event\n};\n\nint __init roce_gid_mgmt_init(void)\n{\n\tgid_cache_wq = alloc_ordered_workqueue(\"gid-cache-wq\", 0);\n\tif (!gid_cache_wq)\n\t\treturn -ENOMEM;\n\n\tregister_inetaddr_notifier(&nb_inetaddr);\n\tif (IS_ENABLED(CONFIG_IPV6))\n\t\tregister_inet6addr_notifier(&nb_inet6addr);\n\t \n\tregister_netdevice_notifier(&nb_netdevice);\n\n\treturn 0;\n}\n\nvoid __exit roce_gid_mgmt_cleanup(void)\n{\n\tif (IS_ENABLED(CONFIG_IPV6))\n\t\tunregister_inet6addr_notifier(&nb_inet6addr);\n\tunregister_inetaddr_notifier(&nb_inetaddr);\n\tunregister_netdevice_notifier(&nb_netdevice);\n\t \n\tdestroy_workqueue(gid_cache_wq);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}