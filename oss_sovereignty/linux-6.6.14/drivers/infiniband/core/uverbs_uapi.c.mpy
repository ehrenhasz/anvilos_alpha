{
  "module_name": "uverbs_uapi.c",
  "hash_id": "104496ad270fd789ba952ae398b38484830a3692319fdc3090ce59493b4bb489",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/core/uverbs_uapi.c",
  "human_readable_source": "\n \n#include <rdma/uverbs_ioctl.h>\n#include <rdma/rdma_user_ioctl.h>\n#include <linux/bitops.h>\n#include \"rdma_core.h\"\n#include \"uverbs.h\"\n\nstatic int ib_uverbs_notsupp(struct uverbs_attr_bundle *attrs)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic void *uapi_add_elm(struct uverbs_api *uapi, u32 key, size_t alloc_size)\n{\n\tvoid *elm;\n\tint rc;\n\n\tif (key == UVERBS_API_KEY_ERR)\n\t\treturn ERR_PTR(-EOVERFLOW);\n\n\telm = kzalloc(alloc_size, GFP_KERNEL);\n\tif (!elm)\n\t\treturn ERR_PTR(-ENOMEM);\n\trc = radix_tree_insert(&uapi->radix, key, elm);\n\tif (rc) {\n\t\tkfree(elm);\n\t\treturn ERR_PTR(rc);\n\t}\n\n\treturn elm;\n}\n\nstatic void *uapi_add_get_elm(struct uverbs_api *uapi, u32 key,\n\t\t\t      size_t alloc_size, bool *exists)\n{\n\tvoid *elm;\n\n\telm = uapi_add_elm(uapi, key, alloc_size);\n\tif (!IS_ERR(elm)) {\n\t\t*exists = false;\n\t\treturn elm;\n\t}\n\n\tif (elm != ERR_PTR(-EEXIST))\n\t\treturn elm;\n\n\telm = radix_tree_lookup(&uapi->radix, key);\n\tif (WARN_ON(!elm))\n\t\treturn ERR_PTR(-EINVAL);\n\t*exists = true;\n\treturn elm;\n}\n\nstatic int uapi_create_write(struct uverbs_api *uapi,\n\t\t\t     struct ib_device *ibdev,\n\t\t\t     const struct uapi_definition *def,\n\t\t\t     u32 obj_key,\n\t\t\t     u32 *cur_method_key)\n{\n\tstruct uverbs_api_write_method *method_elm;\n\tu32 method_key = obj_key;\n\tbool exists;\n\n\tif (def->write.is_ex)\n\t\tmethod_key |= uapi_key_write_ex_method(def->write.command_num);\n\telse\n\t\tmethod_key |= uapi_key_write_method(def->write.command_num);\n\n\tmethod_elm = uapi_add_get_elm(uapi, method_key, sizeof(*method_elm),\n\t\t\t\t      &exists);\n\tif (IS_ERR(method_elm))\n\t\treturn PTR_ERR(method_elm);\n\n\tif (WARN_ON(exists && (def->write.is_ex != method_elm->is_ex)))\n\t\treturn -EINVAL;\n\n\tmethod_elm->is_ex = def->write.is_ex;\n\tmethod_elm->handler = def->func_write;\n\tif (!def->write.is_ex)\n\t\tmethod_elm->disabled = !(ibdev->uverbs_cmd_mask &\n\t\t\t\t\t BIT_ULL(def->write.command_num));\n\n\tif (!def->write.is_ex && def->func_write) {\n\t\tmethod_elm->has_udata = def->write.has_udata;\n\t\tmethod_elm->has_resp = def->write.has_resp;\n\t\tmethod_elm->req_size = def->write.req_size;\n\t\tmethod_elm->resp_size = def->write.resp_size;\n\t}\n\n\t*cur_method_key = method_key;\n\treturn 0;\n}\n\nstatic int uapi_merge_method(struct uverbs_api *uapi,\n\t\t\t     struct uverbs_api_object *obj_elm, u32 obj_key,\n\t\t\t     const struct uverbs_method_def *method,\n\t\t\t     bool is_driver)\n{\n\tu32 method_key = obj_key | uapi_key_ioctl_method(method->id);\n\tstruct uverbs_api_ioctl_method *method_elm;\n\tunsigned int i;\n\tbool exists;\n\n\tif (!method->attrs)\n\t\treturn 0;\n\n\tmethod_elm = uapi_add_get_elm(uapi, method_key, sizeof(*method_elm),\n\t\t\t\t      &exists);\n\tif (IS_ERR(method_elm))\n\t\treturn PTR_ERR(method_elm);\n\tif (exists) {\n\t\t \n\t\tif (WARN_ON(method->handler))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tWARN_ON(!method->handler);\n\t\trcu_assign_pointer(method_elm->handler, method->handler);\n\t\tif (method->handler != uverbs_destroy_def_handler)\n\t\t\tmethod_elm->driver_method = is_driver;\n\t}\n\n\tfor (i = 0; i != method->num_attrs; i++) {\n\t\tconst struct uverbs_attr_def *attr = (*method->attrs)[i];\n\t\tstruct uverbs_api_attr *attr_slot;\n\n\t\tif (!attr)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (attr->attr.type == UVERBS_ATTR_TYPE_ENUM_IN)\n\t\t\tmethod_elm->driver_method |= is_driver;\n\n\t\t \n\t\tif (attr->attr.type == UVERBS_ATTR_TYPE_IDRS_ARRAY) {\n\t\t\tu8 access = attr->attr.u2.objs_arr.access;\n\n\t\t\tif (WARN_ON(access == UVERBS_ACCESS_NEW ||\n\t\t\t\t    access == UVERBS_ACCESS_DESTROY))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tattr_slot =\n\t\t\tuapi_add_elm(uapi, method_key | uapi_key_attr(attr->id),\n\t\t\t\t     sizeof(*attr_slot));\n\t\t \n\t\tif (IS_ERR(attr_slot))\n\t\t\treturn PTR_ERR(attr_slot);\n\n\t\tattr_slot->spec = attr->attr;\n\t}\n\n\treturn 0;\n}\n\nstatic int uapi_merge_obj_tree(struct uverbs_api *uapi,\n\t\t\t       const struct uverbs_object_def *obj,\n\t\t\t       bool is_driver)\n{\n\tstruct uverbs_api_object *obj_elm;\n\tunsigned int i;\n\tu32 obj_key;\n\tbool exists;\n\tint rc;\n\n\tobj_key = uapi_key_obj(obj->id);\n\tobj_elm = uapi_add_get_elm(uapi, obj_key, sizeof(*obj_elm), &exists);\n\tif (IS_ERR(obj_elm))\n\t\treturn PTR_ERR(obj_elm);\n\n\tif (obj->type_attrs) {\n\t\tif (WARN_ON(obj_elm->type_attrs))\n\t\t\treturn -EINVAL;\n\n\t\tobj_elm->id = obj->id;\n\t\tobj_elm->type_attrs = obj->type_attrs;\n\t\tobj_elm->type_class = obj->type_attrs->type_class;\n\t\t \n\t\tif (WARN_ON(is_driver &&\n\t\t\t    obj->type_attrs->type_class != &uverbs_idr_class &&\n\t\t\t    obj->type_attrs->type_class != &uverbs_fd_class))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!obj->methods)\n\t\treturn 0;\n\n\tfor (i = 0; i != obj->num_methods; i++) {\n\t\tconst struct uverbs_method_def *method = (*obj->methods)[i];\n\n\t\tif (!method)\n\t\t\tcontinue;\n\n\t\trc = uapi_merge_method(uapi, obj_elm, obj_key, method,\n\t\t\t\t       is_driver);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic int uapi_disable_elm(struct uverbs_api *uapi,\n\t\t\t    const struct uapi_definition *def,\n\t\t\t    u32 obj_key,\n\t\t\t    u32 method_key)\n{\n\tbool exists;\n\n\tif (def->scope == UAPI_SCOPE_OBJECT) {\n\t\tstruct uverbs_api_object *obj_elm;\n\n\t\tobj_elm = uapi_add_get_elm(\n\t\t\tuapi, obj_key, sizeof(*obj_elm), &exists);\n\t\tif (IS_ERR(obj_elm))\n\t\t\treturn PTR_ERR(obj_elm);\n\t\tobj_elm->disabled = 1;\n\t\treturn 0;\n\t}\n\n\tif (def->scope == UAPI_SCOPE_METHOD &&\n\t    uapi_key_is_ioctl_method(method_key)) {\n\t\tstruct uverbs_api_ioctl_method *method_elm;\n\n\t\tmethod_elm = uapi_add_get_elm(uapi, method_key,\n\t\t\t\t\t      sizeof(*method_elm), &exists);\n\t\tif (IS_ERR(method_elm))\n\t\t\treturn PTR_ERR(method_elm);\n\t\tmethod_elm->disabled = 1;\n\t\treturn 0;\n\t}\n\n\tif (def->scope == UAPI_SCOPE_METHOD &&\n\t    (uapi_key_is_write_method(method_key) ||\n\t     uapi_key_is_write_ex_method(method_key))) {\n\t\tstruct uverbs_api_write_method *write_elm;\n\n\t\twrite_elm = uapi_add_get_elm(uapi, method_key,\n\t\t\t\t\t     sizeof(*write_elm), &exists);\n\t\tif (IS_ERR(write_elm))\n\t\t\treturn PTR_ERR(write_elm);\n\t\twrite_elm->disabled = 1;\n\t\treturn 0;\n\t}\n\n\tWARN_ON(true);\n\treturn -EINVAL;\n}\n\nstatic int uapi_merge_def(struct uverbs_api *uapi, struct ib_device *ibdev,\n\t\t\t  const struct uapi_definition *def_list,\n\t\t\t  bool is_driver)\n{\n\tconst struct uapi_definition *def = def_list;\n\tu32 cur_obj_key = UVERBS_API_KEY_ERR;\n\tu32 cur_method_key = UVERBS_API_KEY_ERR;\n\tbool exists;\n\tint rc;\n\n\tif (!def_list)\n\t\treturn 0;\n\n\tfor (;; def++) {\n\t\tswitch ((enum uapi_definition_kind)def->kind) {\n\t\tcase UAPI_DEF_CHAIN:\n\t\t\trc = uapi_merge_def(uapi, ibdev, def->chain, is_driver);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\tcontinue;\n\n\t\tcase UAPI_DEF_CHAIN_OBJ_TREE:\n\t\t\tif (WARN_ON(def->object_start.object_id !=\n\t\t\t\t    def->chain_obj_tree->id))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tcur_obj_key = uapi_key_obj(def->object_start.object_id);\n\t\t\trc = uapi_merge_obj_tree(uapi, def->chain_obj_tree,\n\t\t\t\t\t\t is_driver);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\tcontinue;\n\n\t\tcase UAPI_DEF_END:\n\t\t\treturn 0;\n\n\t\tcase UAPI_DEF_IS_SUPPORTED_DEV_FN: {\n\t\t\tvoid **ibdev_fn =\n\t\t\t\t(void *)(&ibdev->ops) + def->needs_fn_offset;\n\n\t\t\tif (*ibdev_fn)\n\t\t\t\tcontinue;\n\t\t\trc = uapi_disable_elm(\n\t\t\t\tuapi, def, cur_obj_key, cur_method_key);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcase UAPI_DEF_IS_SUPPORTED_FUNC:\n\t\t\tif (def->func_is_supported(ibdev))\n\t\t\t\tcontinue;\n\t\t\trc = uapi_disable_elm(\n\t\t\t\tuapi, def, cur_obj_key, cur_method_key);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\tcontinue;\n\n\t\tcase UAPI_DEF_OBJECT_START: {\n\t\t\tstruct uverbs_api_object *obj_elm;\n\n\t\t\tcur_obj_key = uapi_key_obj(def->object_start.object_id);\n\t\t\tobj_elm = uapi_add_get_elm(uapi, cur_obj_key,\n\t\t\t\t\t\t   sizeof(*obj_elm), &exists);\n\t\t\tif (IS_ERR(obj_elm))\n\t\t\t\treturn PTR_ERR(obj_elm);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcase UAPI_DEF_WRITE:\n\t\t\trc = uapi_create_write(\n\t\t\t\tuapi, ibdev, def, cur_obj_key, &cur_method_key);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\tcontinue;\n\t\t}\n\t\tWARN_ON(true);\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int\nuapi_finalize_ioctl_method(struct uverbs_api *uapi,\n\t\t\t   struct uverbs_api_ioctl_method *method_elm,\n\t\t\t   u32 method_key)\n{\n\tstruct radix_tree_iter iter;\n\tunsigned int num_attrs = 0;\n\tunsigned int max_bkey = 0;\n\tbool single_uobj = false;\n\tvoid __rcu **slot;\n\n\tmethod_elm->destroy_bkey = UVERBS_API_ATTR_BKEY_LEN;\n\tradix_tree_for_each_slot (slot, &uapi->radix, &iter,\n\t\t\t\t  uapi_key_attrs_start(method_key)) {\n\t\tstruct uverbs_api_attr *elm =\n\t\t\trcu_dereference_protected(*slot, true);\n\t\tu32 attr_key = iter.index & UVERBS_API_ATTR_KEY_MASK;\n\t\tu32 attr_bkey = uapi_bkey_attr(attr_key);\n\t\tu8 type = elm->spec.type;\n\n\t\tif (uapi_key_attr_to_ioctl_method(iter.index) !=\n\t\t    uapi_key_attr_to_ioctl_method(method_key))\n\t\t\tbreak;\n\n\t\tif (elm->spec.mandatory)\n\t\t\t__set_bit(attr_bkey, method_elm->attr_mandatory);\n\n\t\tif (elm->spec.is_udata)\n\t\t\tmethod_elm->has_udata = true;\n\n\t\tif (type == UVERBS_ATTR_TYPE_IDR ||\n\t\t    type == UVERBS_ATTR_TYPE_FD) {\n\t\t\tu8 access = elm->spec.u.obj.access;\n\n\t\t\t \n\t\t\tif (access == UVERBS_ACCESS_NEW ||\n\t\t\t    access == UVERBS_ACCESS_DESTROY) {\n\t\t\t\tif (WARN_ON(single_uobj))\n\t\t\t\t\treturn -EINVAL;\n\n\t\t\t\tsingle_uobj = true;\n\t\t\t\tif (WARN_ON(!elm->spec.mandatory))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (access == UVERBS_ACCESS_DESTROY)\n\t\t\t\tmethod_elm->destroy_bkey = attr_bkey;\n\t\t}\n\n\t\tmax_bkey = max(max_bkey, attr_bkey);\n\t\tnum_attrs++;\n\t}\n\n\tmethod_elm->key_bitmap_len = max_bkey + 1;\n\tWARN_ON(method_elm->key_bitmap_len > UVERBS_API_ATTR_BKEY_LEN);\n\n\tuapi_compute_bundle_size(method_elm, num_attrs);\n\treturn 0;\n}\n\nstatic int uapi_finalize(struct uverbs_api *uapi)\n{\n\tconst struct uverbs_api_write_method **data;\n\tunsigned long max_write_ex = 0;\n\tunsigned long max_write = 0;\n\tstruct radix_tree_iter iter;\n\tvoid __rcu **slot;\n\tint rc;\n\tint i;\n\n\tradix_tree_for_each_slot (slot, &uapi->radix, &iter, 0) {\n\t\tstruct uverbs_api_ioctl_method *method_elm =\n\t\t\trcu_dereference_protected(*slot, true);\n\n\t\tif (uapi_key_is_ioctl_method(iter.index)) {\n\t\t\trc = uapi_finalize_ioctl_method(uapi, method_elm,\n\t\t\t\t\t\t\titer.index);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\n\t\tif (uapi_key_is_write_method(iter.index))\n\t\t\tmax_write = max(max_write,\n\t\t\t\t\titer.index & UVERBS_API_ATTR_KEY_MASK);\n\t\tif (uapi_key_is_write_ex_method(iter.index))\n\t\t\tmax_write_ex =\n\t\t\t\tmax(max_write_ex,\n\t\t\t\t    iter.index & UVERBS_API_ATTR_KEY_MASK);\n\t}\n\n\tuapi->notsupp_method.handler = ib_uverbs_notsupp;\n\tuapi->num_write = max_write + 1;\n\tuapi->num_write_ex = max_write_ex + 1;\n\tdata = kmalloc_array(uapi->num_write + uapi->num_write_ex,\n\t\t\t     sizeof(*uapi->write_methods), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i != uapi->num_write + uapi->num_write_ex; i++)\n\t\tdata[i] = &uapi->notsupp_method;\n\tuapi->write_methods = data;\n\tuapi->write_ex_methods = data + uapi->num_write;\n\n\tradix_tree_for_each_slot (slot, &uapi->radix, &iter, 0) {\n\t\tif (uapi_key_is_write_method(iter.index))\n\t\t\tuapi->write_methods[iter.index &\n\t\t\t\t\t    UVERBS_API_ATTR_KEY_MASK] =\n\t\t\t\trcu_dereference_protected(*slot, true);\n\t\tif (uapi_key_is_write_ex_method(iter.index))\n\t\t\tuapi->write_ex_methods[iter.index &\n\t\t\t\t\t       UVERBS_API_ATTR_KEY_MASK] =\n\t\t\t\trcu_dereference_protected(*slot, true);\n\t}\n\n\treturn 0;\n}\n\nstatic void uapi_remove_range(struct uverbs_api *uapi, u32 start, u32 last)\n{\n\tstruct radix_tree_iter iter;\n\tvoid __rcu **slot;\n\n\tradix_tree_for_each_slot (slot, &uapi->radix, &iter, start) {\n\t\tif (iter.index > last)\n\t\t\treturn;\n\t\tkfree(rcu_dereference_protected(*slot, true));\n\t\tradix_tree_iter_delete(&uapi->radix, &iter, slot);\n\t}\n}\n\nstatic void uapi_remove_object(struct uverbs_api *uapi, u32 obj_key)\n{\n\tuapi_remove_range(uapi, obj_key,\n\t\t\t  obj_key | UVERBS_API_METHOD_KEY_MASK |\n\t\t\t\t  UVERBS_API_ATTR_KEY_MASK);\n}\n\nstatic void uapi_remove_method(struct uverbs_api *uapi, u32 method_key)\n{\n\tuapi_remove_range(uapi, method_key,\n\t\t\t  method_key | UVERBS_API_ATTR_KEY_MASK);\n}\n\n\nstatic u32 uapi_get_obj_id(struct uverbs_attr_spec *spec)\n{\n\tif (spec->type == UVERBS_ATTR_TYPE_IDR ||\n\t    spec->type == UVERBS_ATTR_TYPE_FD)\n\t\treturn spec->u.obj.obj_type;\n\tif (spec->type == UVERBS_ATTR_TYPE_IDRS_ARRAY)\n\t\treturn spec->u2.objs_arr.obj_type;\n\treturn UVERBS_API_KEY_ERR;\n}\n\nstatic void uapi_key_okay(u32 key)\n{\n\tunsigned int count = 0;\n\n\tif (uapi_key_is_object(key))\n\t\tcount++;\n\tif (uapi_key_is_ioctl_method(key))\n\t\tcount++;\n\tif (uapi_key_is_write_method(key))\n\t\tcount++;\n\tif (uapi_key_is_write_ex_method(key))\n\t\tcount++;\n\tif (uapi_key_is_attr(key))\n\t\tcount++;\n\tWARN(count != 1, \"Bad count %u key=%x\", count, key);\n}\n\nstatic void uapi_finalize_disable(struct uverbs_api *uapi)\n{\n\tstruct radix_tree_iter iter;\n\tu32 starting_key = 0;\n\tbool scan_again = false;\n\tvoid __rcu **slot;\n\nagain:\n\tradix_tree_for_each_slot (slot, &uapi->radix, &iter, starting_key) {\n\t\tuapi_key_okay(iter.index);\n\n\t\tif (uapi_key_is_object(iter.index)) {\n\t\t\tstruct uverbs_api_object *obj_elm =\n\t\t\t\trcu_dereference_protected(*slot, true);\n\n\t\t\tif (obj_elm->disabled) {\n\t\t\t\t \n\t\t\t\tscan_again = true;\n\t\t\t\tstarting_key = iter.index;\n\t\t\t\tuapi_remove_object(uapi, iter.index);\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (uapi_key_is_ioctl_method(iter.index)) {\n\t\t\tstruct uverbs_api_ioctl_method *method_elm =\n\t\t\t\trcu_dereference_protected(*slot, true);\n\n\t\t\tif (method_elm->disabled) {\n\t\t\t\tstarting_key = iter.index;\n\t\t\t\tuapi_remove_method(uapi, iter.index);\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (uapi_key_is_write_method(iter.index) ||\n\t\t    uapi_key_is_write_ex_method(iter.index)) {\n\t\t\tstruct uverbs_api_write_method *method_elm =\n\t\t\t\trcu_dereference_protected(*slot, true);\n\n\t\t\tif (method_elm->disabled) {\n\t\t\t\tkfree(method_elm);\n\t\t\t\tradix_tree_iter_delete(&uapi->radix, &iter, slot);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (uapi_key_is_attr(iter.index)) {\n\t\t\tstruct uverbs_api_attr *attr_elm =\n\t\t\t\trcu_dereference_protected(*slot, true);\n\t\t\tconst struct uverbs_api_object *tmp_obj;\n\t\t\tu32 obj_key;\n\n\t\t\t \n\t\t\tif (!attr_elm->spec.mandatory)\n\t\t\t\tcontinue;\n\t\t\tobj_key = uapi_get_obj_id(&attr_elm->spec);\n\t\t\tif (obj_key == UVERBS_API_KEY_ERR)\n\t\t\t\tcontinue;\n\t\t\ttmp_obj = uapi_get_object(uapi, obj_key);\n\t\t\tif (IS_ERR(tmp_obj)) {\n\t\t\t\tif (PTR_ERR(tmp_obj) == -ENOMSG)\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tif (!tmp_obj->disabled)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tstarting_key = iter.index;\n\t\t\tuapi_remove_method(\n\t\t\t\tuapi,\n\t\t\t\titer.index & (UVERBS_API_OBJ_KEY_MASK |\n\t\t\t\t\t      UVERBS_API_METHOD_KEY_MASK));\n\t\t\tgoto again;\n\t\t}\n\n\t\tWARN_ON(false);\n\t}\n\n\tif (!scan_again)\n\t\treturn;\n\tscan_again = false;\n\tstarting_key = 0;\n\tgoto again;\n}\n\nvoid uverbs_destroy_api(struct uverbs_api *uapi)\n{\n\tif (!uapi)\n\t\treturn;\n\n\tuapi_remove_range(uapi, 0, U32_MAX);\n\tkfree(uapi->write_methods);\n\tkfree(uapi);\n}\n\nstatic const struct uapi_definition uverbs_core_api[] = {\n\tUAPI_DEF_CHAIN(uverbs_def_obj_async_fd),\n\tUAPI_DEF_CHAIN(uverbs_def_obj_counters),\n\tUAPI_DEF_CHAIN(uverbs_def_obj_cq),\n\tUAPI_DEF_CHAIN(uverbs_def_obj_device),\n\tUAPI_DEF_CHAIN(uverbs_def_obj_dm),\n\tUAPI_DEF_CHAIN(uverbs_def_obj_flow_action),\n\tUAPI_DEF_CHAIN(uverbs_def_obj_intf),\n\tUAPI_DEF_CHAIN(uverbs_def_obj_mr),\n\tUAPI_DEF_CHAIN(uverbs_def_obj_qp),\n\tUAPI_DEF_CHAIN(uverbs_def_obj_srq),\n\tUAPI_DEF_CHAIN(uverbs_def_obj_wq),\n\tUAPI_DEF_CHAIN(uverbs_def_write_intf),\n\t{},\n};\n\nstruct uverbs_api *uverbs_alloc_api(struct ib_device *ibdev)\n{\n\tstruct uverbs_api *uapi;\n\tint rc;\n\n\tuapi = kzalloc(sizeof(*uapi), GFP_KERNEL);\n\tif (!uapi)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_RADIX_TREE(&uapi->radix, GFP_KERNEL);\n\tuapi->driver_id = ibdev->ops.driver_id;\n\n\trc = uapi_merge_def(uapi, ibdev, uverbs_core_api, false);\n\tif (rc)\n\t\tgoto err;\n\trc = uapi_merge_def(uapi, ibdev, ibdev->driver_def, true);\n\tif (rc)\n\t\tgoto err;\n\n\tuapi_finalize_disable(uapi);\n\trc = uapi_finalize(uapi);\n\tif (rc)\n\t\tgoto err;\n\n\treturn uapi;\nerr:\n\tif (rc != -ENOMEM)\n\t\tdev_err(&ibdev->dev,\n\t\t\t\"Setup of uverbs_api failed, kernel parsing tree description is not valid (%d)??\\n\",\n\t\t\trc);\n\n\tuverbs_destroy_api(uapi);\n\treturn ERR_PTR(rc);\n}\n\n \nvoid uverbs_disassociate_api_pre(struct ib_uverbs_device *uverbs_dev)\n{\n\tstruct uverbs_api *uapi = uverbs_dev->uapi;\n\tstruct radix_tree_iter iter;\n\tvoid __rcu **slot;\n\n\trcu_assign_pointer(uverbs_dev->ib_dev, NULL);\n\n\tradix_tree_for_each_slot (slot, &uapi->radix, &iter, 0) {\n\t\tif (uapi_key_is_ioctl_method(iter.index)) {\n\t\t\tstruct uverbs_api_ioctl_method *method_elm =\n\t\t\t\trcu_dereference_protected(*slot, true);\n\n\t\t\tif (method_elm->driver_method)\n\t\t\t\trcu_assign_pointer(method_elm->handler, NULL);\n\t\t}\n\t}\n\n\tsynchronize_srcu(&uverbs_dev->disassociate_srcu);\n}\n\n \nvoid uverbs_disassociate_api(struct uverbs_api *uapi)\n{\n\tstruct radix_tree_iter iter;\n\tvoid __rcu **slot;\n\n\tradix_tree_for_each_slot (slot, &uapi->radix, &iter, 0) {\n\t\tif (uapi_key_is_object(iter.index)) {\n\t\t\tstruct uverbs_api_object *object_elm =\n\t\t\t\trcu_dereference_protected(*slot, true);\n\n\t\t\t \n\t\t\tobject_elm->type_attrs = NULL;\n\t\t} else if (uapi_key_is_attr(iter.index)) {\n\t\t\tstruct uverbs_api_attr *elm =\n\t\t\t\trcu_dereference_protected(*slot, true);\n\n\t\t\tif (elm->spec.type == UVERBS_ATTR_TYPE_ENUM_IN)\n\t\t\t\telm->spec.u2.enum_def.ids = NULL;\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}