{
  "module_name": "packer.c",
  "hash_id": "9a23774c66b9577bd075fff813b49091b678c21cd2ea950eecc3e2f485cd2819",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/core/packer.c",
  "human_readable_source": " \n\n#include <linux/export.h>\n#include <linux/string.h>\n\n#include <rdma/ib_pack.h>\n\nstatic u64 value_read(int offset, int size, void *structure)\n{\n\tswitch (size) {\n\tcase 1: return                *(u8  *) (structure + offset);\n\tcase 2: return be16_to_cpup((__be16 *) (structure + offset));\n\tcase 4: return be32_to_cpup((__be32 *) (structure + offset));\n\tcase 8: return be64_to_cpup((__be64 *) (structure + offset));\n\tdefault:\n\t\tpr_warn(\"Field size %d bits not handled\\n\", size * 8);\n\t\treturn 0;\n\t}\n}\n\n \nvoid ib_pack(const struct ib_field        *desc,\n\t     int                           desc_len,\n\t     void                         *structure,\n\t     void                         *buf)\n{\n\tint i;\n\n\tfor (i = 0; i < desc_len; ++i) {\n\t\tif (desc[i].size_bits <= 32) {\n\t\t\tint shift;\n\t\t\tu32 val;\n\t\t\t__be32 mask;\n\t\t\t__be32 *addr;\n\n\t\t\tshift = 32 - desc[i].offset_bits - desc[i].size_bits;\n\t\t\tif (desc[i].struct_size_bytes)\n\t\t\t\tval = value_read(desc[i].struct_offset_bytes,\n\t\t\t\t\t\t desc[i].struct_size_bytes,\n\t\t\t\t\t\t structure) << shift;\n\t\t\telse\n\t\t\t\tval = 0;\n\n\t\t\tmask = cpu_to_be32(((1ull << desc[i].size_bits) - 1) << shift);\n\t\t\taddr = (__be32 *) buf + desc[i].offset_words;\n\t\t\t*addr = (*addr & ~mask) | (cpu_to_be32(val) & mask);\n\t\t} else if (desc[i].size_bits <= 64) {\n\t\t\tint shift;\n\t\t\tu64 val;\n\t\t\t__be64 mask;\n\t\t\t__be64 *addr;\n\n\t\t\tshift = 64 - desc[i].offset_bits - desc[i].size_bits;\n\t\t\tif (desc[i].struct_size_bytes)\n\t\t\t\tval = value_read(desc[i].struct_offset_bytes,\n\t\t\t\t\t\t desc[i].struct_size_bytes,\n\t\t\t\t\t\t structure) << shift;\n\t\t\telse\n\t\t\t\tval = 0;\n\n\t\t\tmask = cpu_to_be64((~0ull >> (64 - desc[i].size_bits)) << shift);\n\t\t\taddr = (__be64 *) ((__be32 *) buf + desc[i].offset_words);\n\t\t\t*addr = (*addr & ~mask) | (cpu_to_be64(val) & mask);\n\t\t} else {\n\t\t\tif (desc[i].offset_bits % 8 ||\n\t\t\t    desc[i].size_bits   % 8) {\n\t\t\t\tpr_warn(\"Structure field %s of size %d bits is not byte-aligned\\n\",\n\t\t\t\t\tdesc[i].field_name, desc[i].size_bits);\n\t\t\t}\n\n\t\t\tif (desc[i].struct_size_bytes)\n\t\t\t\tmemcpy(buf + desc[i].offset_words * 4 +\n\t\t\t\t       desc[i].offset_bits / 8,\n\t\t\t\t       structure + desc[i].struct_offset_bytes,\n\t\t\t\t       desc[i].size_bits / 8);\n\t\t\telse\n\t\t\t\tmemset(buf + desc[i].offset_words * 4 +\n\t\t\t\t       desc[i].offset_bits / 8,\n\t\t\t\t       0,\n\t\t\t\t       desc[i].size_bits / 8);\n\t\t}\n\t}\n}\nEXPORT_SYMBOL(ib_pack);\n\nstatic void value_write(int offset, int size, u64 val, void *structure)\n{\n\tswitch (size * 8) {\n\tcase 8:  *(    u8 *) (structure + offset) = val; break;\n\tcase 16: *(__be16 *) (structure + offset) = cpu_to_be16(val); break;\n\tcase 32: *(__be32 *) (structure + offset) = cpu_to_be32(val); break;\n\tcase 64: *(__be64 *) (structure + offset) = cpu_to_be64(val); break;\n\tdefault:\n\t\tpr_warn(\"Field size %d bits not handled\\n\", size * 8);\n\t}\n}\n\n \nvoid ib_unpack(const struct ib_field        *desc,\n\t       int                           desc_len,\n\t       void                         *buf,\n\t       void                         *structure)\n{\n\tint i;\n\n\tfor (i = 0; i < desc_len; ++i) {\n\t\tif (!desc[i].struct_size_bytes)\n\t\t\tcontinue;\n\n\t\tif (desc[i].size_bits <= 32) {\n\t\t\tint shift;\n\t\t\tu32  val;\n\t\t\tu32  mask;\n\t\t\t__be32 *addr;\n\n\t\t\tshift = 32 - desc[i].offset_bits - desc[i].size_bits;\n\t\t\tmask = ((1ull << desc[i].size_bits) - 1) << shift;\n\t\t\taddr = (__be32 *) buf + desc[i].offset_words;\n\t\t\tval = (be32_to_cpup(addr) & mask) >> shift;\n\t\t\tvalue_write(desc[i].struct_offset_bytes,\n\t\t\t\t    desc[i].struct_size_bytes,\n\t\t\t\t    val,\n\t\t\t\t    structure);\n\t\t} else if (desc[i].size_bits <= 64) {\n\t\t\tint shift;\n\t\t\tu64  val;\n\t\t\tu64  mask;\n\t\t\t__be64 *addr;\n\n\t\t\tshift = 64 - desc[i].offset_bits - desc[i].size_bits;\n\t\t\tmask = (~0ull >> (64 - desc[i].size_bits)) << shift;\n\t\t\taddr = (__be64 *) buf + desc[i].offset_words;\n\t\t\tval = (be64_to_cpup(addr) & mask) >> shift;\n\t\t\tvalue_write(desc[i].struct_offset_bytes,\n\t\t\t\t    desc[i].struct_size_bytes,\n\t\t\t\t    val,\n\t\t\t\t    structure);\n\t\t} else {\n\t\t\tif (desc[i].offset_bits % 8 ||\n\t\t\t    desc[i].size_bits   % 8) {\n\t\t\t\tpr_warn(\"Structure field %s of size %d bits is not byte-aligned\\n\",\n\t\t\t\t\tdesc[i].field_name, desc[i].size_bits);\n\t\t\t}\n\n\t\t\tmemcpy(structure + desc[i].struct_offset_bytes,\n\t\t\t       buf + desc[i].offset_words * 4 +\n\t\t\t       desc[i].offset_bits / 8,\n\t\t\t       desc[i].size_bits / 8);\n\t\t}\n\t}\n}\nEXPORT_SYMBOL(ib_unpack);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}