{
  "module_name": "sysfs.c",
  "hash_id": "d24bbc74e56b87070202fc15f22179db89e63dc537b459314e35414cb18856bb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/core/sysfs.c",
  "human_readable_source": " \n\n#include \"core_priv.h\"\n\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/netdevice.h>\n#include <linux/ethtool.h>\n\n#include <rdma/ib_mad.h>\n#include <rdma/ib_pma.h>\n#include <rdma/ib_cache.h>\n#include <rdma/rdma_counter.h>\n#include <rdma/ib_sysfs.h>\n\nstruct port_table_attribute {\n\tstruct ib_port_attribute attr;\n\tchar\t\t\tname[8];\n\tint\t\t\tindex;\n\t__be16\t\t\tattr_id;\n};\n\nstruct gid_attr_group {\n\tstruct ib_port *port;\n\tstruct kobject kobj;\n\tstruct attribute_group groups[2];\n\tconst struct attribute_group *groups_list[3];\n\tstruct port_table_attribute attrs_list[];\n};\n\nstruct ib_port {\n\tstruct kobject kobj;\n\tstruct ib_device *ibdev;\n\tstruct gid_attr_group *gid_attr_group;\n\tstruct hw_stats_port_data *hw_stats_data;\n\n\tstruct attribute_group groups[3];\n\tconst struct attribute_group *groups_list[5];\n\tu32 port_num;\n\tstruct port_table_attribute attrs_list[];\n};\n\nstruct hw_stats_device_attribute {\n\tstruct device_attribute attr;\n\tssize_t (*show)(struct ib_device *ibdev, struct rdma_hw_stats *stats,\n\t\t\tunsigned int index, unsigned int port_num, char *buf);\n\tssize_t (*store)(struct ib_device *ibdev, struct rdma_hw_stats *stats,\n\t\t\t unsigned int index, unsigned int port_num,\n\t\t\t const char *buf, size_t count);\n};\n\nstruct hw_stats_port_attribute {\n\tstruct ib_port_attribute attr;\n\tssize_t (*show)(struct ib_device *ibdev, struct rdma_hw_stats *stats,\n\t\t\tunsigned int index, unsigned int port_num, char *buf);\n\tssize_t (*store)(struct ib_device *ibdev, struct rdma_hw_stats *stats,\n\t\t\t unsigned int index, unsigned int port_num,\n\t\t\t const char *buf, size_t count);\n};\n\nstruct hw_stats_device_data {\n\tstruct attribute_group group;\n\tstruct rdma_hw_stats *stats;\n\tstruct hw_stats_device_attribute attrs[];\n};\n\nstruct hw_stats_port_data {\n\tstruct rdma_hw_stats *stats;\n\tstruct hw_stats_port_attribute attrs[];\n};\n\nstatic ssize_t port_attr_show(struct kobject *kobj,\n\t\t\t      struct attribute *attr, char *buf)\n{\n\tstruct ib_port_attribute *port_attr =\n\t\tcontainer_of(attr, struct ib_port_attribute, attr);\n\tstruct ib_port *p = container_of(kobj, struct ib_port, kobj);\n\n\tif (!port_attr->show)\n\t\treturn -EIO;\n\n\treturn port_attr->show(p->ibdev, p->port_num, port_attr, buf);\n}\n\nstatic ssize_t port_attr_store(struct kobject *kobj,\n\t\t\t       struct attribute *attr,\n\t\t\t       const char *buf, size_t count)\n{\n\tstruct ib_port_attribute *port_attr =\n\t\tcontainer_of(attr, struct ib_port_attribute, attr);\n\tstruct ib_port *p = container_of(kobj, struct ib_port, kobj);\n\n\tif (!port_attr->store)\n\t\treturn -EIO;\n\treturn port_attr->store(p->ibdev, p->port_num, port_attr, buf, count);\n}\n\nstruct ib_device *ib_port_sysfs_get_ibdev_kobj(struct kobject *kobj,\n\t\t\t\t\t       u32 *port_num)\n{\n\tstruct ib_port *port = container_of(kobj, struct ib_port, kobj);\n\n\t*port_num = port->port_num;\n\treturn port->ibdev;\n}\nEXPORT_SYMBOL(ib_port_sysfs_get_ibdev_kobj);\n\nstatic const struct sysfs_ops port_sysfs_ops = {\n\t.show\t= port_attr_show,\n\t.store\t= port_attr_store\n};\n\nstatic ssize_t hw_stat_device_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct hw_stats_device_attribute *stat_attr =\n\t\tcontainer_of(attr, struct hw_stats_device_attribute, attr);\n\tstruct ib_device *ibdev = container_of(dev, struct ib_device, dev);\n\n\treturn stat_attr->show(ibdev, ibdev->hw_stats_data->stats,\n\t\t\t       stat_attr - ibdev->hw_stats_data->attrs, 0, buf);\n}\n\nstatic ssize_t hw_stat_device_store(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct hw_stats_device_attribute *stat_attr =\n\t\tcontainer_of(attr, struct hw_stats_device_attribute, attr);\n\tstruct ib_device *ibdev = container_of(dev, struct ib_device, dev);\n\n\treturn stat_attr->store(ibdev, ibdev->hw_stats_data->stats,\n\t\t\t\tstat_attr - ibdev->hw_stats_data->attrs, 0, buf,\n\t\t\t\tcount);\n}\n\nstatic ssize_t hw_stat_port_show(struct ib_device *ibdev, u32 port_num,\n\t\t\t\t struct ib_port_attribute *attr, char *buf)\n{\n\tstruct hw_stats_port_attribute *stat_attr =\n\t\tcontainer_of(attr, struct hw_stats_port_attribute, attr);\n\tstruct ib_port *port = ibdev->port_data[port_num].sysfs;\n\n\treturn stat_attr->show(ibdev, port->hw_stats_data->stats,\n\t\t\t       stat_attr - port->hw_stats_data->attrs,\n\t\t\t       port->port_num, buf);\n}\n\nstatic ssize_t hw_stat_port_store(struct ib_device *ibdev, u32 port_num,\n\t\t\t\t  struct ib_port_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct hw_stats_port_attribute *stat_attr =\n\t\tcontainer_of(attr, struct hw_stats_port_attribute, attr);\n\tstruct ib_port *port = ibdev->port_data[port_num].sysfs;\n\n\treturn stat_attr->store(ibdev, port->hw_stats_data->stats,\n\t\t\t\tstat_attr - port->hw_stats_data->attrs,\n\t\t\t\tport->port_num, buf, count);\n}\n\nstatic ssize_t gid_attr_show(struct kobject *kobj,\n\t\t\t     struct attribute *attr, char *buf)\n{\n\tstruct ib_port_attribute *port_attr =\n\t\tcontainer_of(attr, struct ib_port_attribute, attr);\n\tstruct ib_port *p = container_of(kobj, struct gid_attr_group,\n\t\t\t\t\t kobj)->port;\n\n\tif (!port_attr->show)\n\t\treturn -EIO;\n\n\treturn port_attr->show(p->ibdev, p->port_num, port_attr, buf);\n}\n\nstatic const struct sysfs_ops gid_attr_sysfs_ops = {\n\t.show = gid_attr_show\n};\n\nstatic ssize_t state_show(struct ib_device *ibdev, u32 port_num,\n\t\t\t  struct ib_port_attribute *unused, char *buf)\n{\n\tstruct ib_port_attr attr;\n\tssize_t ret;\n\n\tstatic const char *state_name[] = {\n\t\t[IB_PORT_NOP]\t\t= \"NOP\",\n\t\t[IB_PORT_DOWN]\t\t= \"DOWN\",\n\t\t[IB_PORT_INIT]\t\t= \"INIT\",\n\t\t[IB_PORT_ARMED]\t\t= \"ARMED\",\n\t\t[IB_PORT_ACTIVE]\t= \"ACTIVE\",\n\t\t[IB_PORT_ACTIVE_DEFER]\t= \"ACTIVE_DEFER\"\n\t};\n\n\tret = ib_query_port(ibdev, port_num, &attr);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"%d: %s\\n\", attr.state,\n\t\t\t  attr.state >= 0 &&\n\t\t\t\t\t  attr.state < ARRAY_SIZE(state_name) ?\n\t\t\t\t  state_name[attr.state] :\n\t\t\t\t  \"UNKNOWN\");\n}\n\nstatic ssize_t lid_show(struct ib_device *ibdev, u32 port_num,\n\t\t\tstruct ib_port_attribute *unused, char *buf)\n{\n\tstruct ib_port_attr attr;\n\tssize_t ret;\n\n\tret = ib_query_port(ibdev, port_num, &attr);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"0x%x\\n\", attr.lid);\n}\n\nstatic ssize_t lid_mask_count_show(struct ib_device *ibdev, u32 port_num,\n\t\t\t\t   struct ib_port_attribute *unused, char *buf)\n{\n\tstruct ib_port_attr attr;\n\tssize_t ret;\n\n\tret = ib_query_port(ibdev, port_num, &attr);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"%u\\n\", attr.lmc);\n}\n\nstatic ssize_t sm_lid_show(struct ib_device *ibdev, u32 port_num,\n\t\t\t   struct ib_port_attribute *unused, char *buf)\n{\n\tstruct ib_port_attr attr;\n\tssize_t ret;\n\n\tret = ib_query_port(ibdev, port_num, &attr);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"0x%x\\n\", attr.sm_lid);\n}\n\nstatic ssize_t sm_sl_show(struct ib_device *ibdev, u32 port_num,\n\t\t\t  struct ib_port_attribute *unused, char *buf)\n{\n\tstruct ib_port_attr attr;\n\tssize_t ret;\n\n\tret = ib_query_port(ibdev, port_num, &attr);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"%u\\n\", attr.sm_sl);\n}\n\nstatic ssize_t cap_mask_show(struct ib_device *ibdev, u32 port_num,\n\t\t\t     struct ib_port_attribute *unused, char *buf)\n{\n\tstruct ib_port_attr attr;\n\tssize_t ret;\n\n\tret = ib_query_port(ibdev, port_num, &attr);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"0x%08x\\n\", attr.port_cap_flags);\n}\n\nstatic ssize_t rate_show(struct ib_device *ibdev, u32 port_num,\n\t\t\t struct ib_port_attribute *unused, char *buf)\n{\n\tstruct ib_port_attr attr;\n\tchar *speed = \"\";\n\tint rate;\t\t \n\tssize_t ret;\n\n\tret = ib_query_port(ibdev, port_num, &attr);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (attr.active_speed) {\n\tcase IB_SPEED_DDR:\n\t\tspeed = \" DDR\";\n\t\trate = 50;\n\t\tbreak;\n\tcase IB_SPEED_QDR:\n\t\tspeed = \" QDR\";\n\t\trate = 100;\n\t\tbreak;\n\tcase IB_SPEED_FDR10:\n\t\tspeed = \" FDR10\";\n\t\trate = 100;\n\t\tbreak;\n\tcase IB_SPEED_FDR:\n\t\tspeed = \" FDR\";\n\t\trate = 140;\n\t\tbreak;\n\tcase IB_SPEED_EDR:\n\t\tspeed = \" EDR\";\n\t\trate = 250;\n\t\tbreak;\n\tcase IB_SPEED_HDR:\n\t\tspeed = \" HDR\";\n\t\trate = 500;\n\t\tbreak;\n\tcase IB_SPEED_NDR:\n\t\tspeed = \" NDR\";\n\t\trate = 1000;\n\t\tbreak;\n\tcase IB_SPEED_SDR:\n\tdefault:\t\t \n\t\tspeed = \" SDR\";\n\t\trate = 25;\n\t\tbreak;\n\t}\n\n\trate *= ib_width_enum_to_int(attr.active_width);\n\tif (rate < 0)\n\t\treturn -EINVAL;\n\n\treturn sysfs_emit(buf, \"%d%s Gb/sec (%dX%s)\\n\", rate / 10,\n\t\t\t  rate % 10 ? \".5\" : \"\",\n\t\t\t  ib_width_enum_to_int(attr.active_width), speed);\n}\n\nstatic const char *phys_state_to_str(enum ib_port_phys_state phys_state)\n{\n\tstatic const char *phys_state_str[] = {\n\t\t\"<unknown>\",\n\t\t\"Sleep\",\n\t\t\"Polling\",\n\t\t\"Disabled\",\n\t\t\"PortConfigurationTraining\",\n\t\t\"LinkUp\",\n\t\t\"LinkErrorRecovery\",\n\t\t\"Phy Test\",\n\t};\n\n\tif (phys_state < ARRAY_SIZE(phys_state_str))\n\t\treturn phys_state_str[phys_state];\n\treturn \"<unknown>\";\n}\n\nstatic ssize_t phys_state_show(struct ib_device *ibdev, u32 port_num,\n\t\t\t       struct ib_port_attribute *unused, char *buf)\n{\n\tstruct ib_port_attr attr;\n\n\tssize_t ret;\n\n\tret = ib_query_port(ibdev, port_num, &attr);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"%u: %s\\n\", attr.phys_state,\n\t\t\t  phys_state_to_str(attr.phys_state));\n}\n\nstatic ssize_t link_layer_show(struct ib_device *ibdev, u32 port_num,\n\t\t\t       struct ib_port_attribute *unused, char *buf)\n{\n\tconst char *output;\n\n\tswitch (rdma_port_get_link_layer(ibdev, port_num)) {\n\tcase IB_LINK_LAYER_INFINIBAND:\n\t\toutput = \"InfiniBand\";\n\t\tbreak;\n\tcase IB_LINK_LAYER_ETHERNET:\n\t\toutput = \"Ethernet\";\n\t\tbreak;\n\tdefault:\n\t\toutput = \"Unknown\";\n\t\tbreak;\n\t}\n\n\treturn sysfs_emit(buf, \"%s\\n\", output);\n}\n\nstatic IB_PORT_ATTR_RO(state);\nstatic IB_PORT_ATTR_RO(lid);\nstatic IB_PORT_ATTR_RO(lid_mask_count);\nstatic IB_PORT_ATTR_RO(sm_lid);\nstatic IB_PORT_ATTR_RO(sm_sl);\nstatic IB_PORT_ATTR_RO(cap_mask);\nstatic IB_PORT_ATTR_RO(rate);\nstatic IB_PORT_ATTR_RO(phys_state);\nstatic IB_PORT_ATTR_RO(link_layer);\n\nstatic struct attribute *port_default_attrs[] = {\n\t&ib_port_attr_state.attr,\n\t&ib_port_attr_lid.attr,\n\t&ib_port_attr_lid_mask_count.attr,\n\t&ib_port_attr_sm_lid.attr,\n\t&ib_port_attr_sm_sl.attr,\n\t&ib_port_attr_cap_mask.attr,\n\t&ib_port_attr_rate.attr,\n\t&ib_port_attr_phys_state.attr,\n\t&ib_port_attr_link_layer.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(port_default);\n\nstatic ssize_t print_ndev(const struct ib_gid_attr *gid_attr, char *buf)\n{\n\tstruct net_device *ndev;\n\tint ret = -EINVAL;\n\n\trcu_read_lock();\n\tndev = rcu_dereference(gid_attr->ndev);\n\tif (ndev)\n\t\tret = sysfs_emit(buf, \"%s\\n\", ndev->name);\n\trcu_read_unlock();\n\treturn ret;\n}\n\nstatic ssize_t print_gid_type(const struct ib_gid_attr *gid_attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"%s\\n\",\n\t\t\t  ib_cache_gid_type_str(gid_attr->gid_type));\n}\n\nstatic ssize_t _show_port_gid_attr(\n\tstruct ib_device *ibdev, u32 port_num, struct ib_port_attribute *attr,\n\tchar *buf,\n\tssize_t (*print)(const struct ib_gid_attr *gid_attr, char *buf))\n{\n\tstruct port_table_attribute *tab_attr =\n\t\tcontainer_of(attr, struct port_table_attribute, attr);\n\tconst struct ib_gid_attr *gid_attr;\n\tssize_t ret;\n\n\tgid_attr = rdma_get_gid_attr(ibdev, port_num, tab_attr->index);\n\tif (IS_ERR(gid_attr))\n\t\t \n\t\treturn -EINVAL;\n\n\tret = print(gid_attr, buf);\n\trdma_put_gid_attr(gid_attr);\n\treturn ret;\n}\n\nstatic ssize_t show_port_gid(struct ib_device *ibdev, u32 port_num,\n\t\t\t     struct ib_port_attribute *attr, char *buf)\n{\n\tstruct port_table_attribute *tab_attr =\n\t\tcontainer_of(attr, struct port_table_attribute, attr);\n\tconst struct ib_gid_attr *gid_attr;\n\tint len;\n\n\tgid_attr = rdma_get_gid_attr(ibdev, port_num, tab_attr->index);\n\tif (IS_ERR(gid_attr)) {\n\t\tconst union ib_gid zgid = {};\n\n\t\t \n\t\treturn sysfs_emit(buf, \"%pI6\\n\", zgid.raw);\n\t}\n\n\tlen = sysfs_emit(buf, \"%pI6\\n\", gid_attr->gid.raw);\n\trdma_put_gid_attr(gid_attr);\n\treturn len;\n}\n\nstatic ssize_t show_port_gid_attr_ndev(struct ib_device *ibdev, u32 port_num,\n\t\t\t\t       struct ib_port_attribute *attr,\n\t\t\t\t       char *buf)\n{\n\treturn _show_port_gid_attr(ibdev, port_num, attr, buf, print_ndev);\n}\n\nstatic ssize_t show_port_gid_attr_gid_type(struct ib_device *ibdev,\n\t\t\t\t\t   u32 port_num,\n\t\t\t\t\t   struct ib_port_attribute *attr,\n\t\t\t\t\t   char *buf)\n{\n\treturn _show_port_gid_attr(ibdev, port_num, attr, buf, print_gid_type);\n}\n\nstatic ssize_t show_port_pkey(struct ib_device *ibdev, u32 port_num,\n\t\t\t      struct ib_port_attribute *attr, char *buf)\n{\n\tstruct port_table_attribute *tab_attr =\n\t\tcontainer_of(attr, struct port_table_attribute, attr);\n\tu16 pkey;\n\tint ret;\n\n\tret = ib_query_pkey(ibdev, port_num, tab_attr->index, &pkey);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"0x%04x\\n\", pkey);\n}\n\n#define PORT_PMA_ATTR(_name, _counter, _width, _offset)\t\t\t\\\nstruct port_table_attribute port_pma_attr_##_name = {\t\t\t\\\n\t.attr  = __ATTR(_name, S_IRUGO, show_pma_counter, NULL),\t\\\n\t.index = (_offset) | ((_width) << 16) | ((_counter) << 24),\t\\\n\t.attr_id = IB_PMA_PORT_COUNTERS,\t\t\t\t\\\n}\n\n#define PORT_PMA_ATTR_EXT(_name, _width, _offset)\t\t\t\\\nstruct port_table_attribute port_pma_attr_ext_##_name = {\t\t\\\n\t.attr  = __ATTR(_name, S_IRUGO, show_pma_counter, NULL),\t\\\n\t.index = (_offset) | ((_width) << 16),\t\t\t\t\\\n\t.attr_id = IB_PMA_PORT_COUNTERS_EXT,\t\t\t\t\\\n}\n\n \nstatic int get_perf_mad(struct ib_device *dev, int port_num, __be16 attr,\n\t\tvoid *data, int offset, size_t size)\n{\n\tstruct ib_mad *in_mad;\n\tstruct ib_mad *out_mad;\n\tsize_t mad_size = sizeof(*out_mad);\n\tu16 out_mad_pkey_index = 0;\n\tssize_t ret;\n\n\tif (!dev->ops.process_mad)\n\t\treturn -ENOSYS;\n\n\tin_mad = kzalloc(sizeof(*in_mad), GFP_KERNEL);\n\tout_mad = kzalloc(sizeof(*out_mad), GFP_KERNEL);\n\tif (!in_mad || !out_mad) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tin_mad->mad_hdr.base_version  = 1;\n\tin_mad->mad_hdr.mgmt_class    = IB_MGMT_CLASS_PERF_MGMT;\n\tin_mad->mad_hdr.class_version = 1;\n\tin_mad->mad_hdr.method        = IB_MGMT_METHOD_GET;\n\tin_mad->mad_hdr.attr_id       = attr;\n\n\tif (attr != IB_PMA_CLASS_PORT_INFO)\n\t\tin_mad->data[41] = port_num;\t \n\n\tif ((dev->ops.process_mad(dev, IB_MAD_IGNORE_MKEY, port_num, NULL, NULL,\n\t\t\t\t  in_mad, out_mad, &mad_size,\n\t\t\t\t  &out_mad_pkey_index) &\n\t     (IB_MAD_RESULT_SUCCESS | IB_MAD_RESULT_REPLY)) !=\n\t    (IB_MAD_RESULT_SUCCESS | IB_MAD_RESULT_REPLY)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tmemcpy(data, out_mad->data + offset, size);\n\tret = size;\nout:\n\tkfree(in_mad);\n\tkfree(out_mad);\n\treturn ret;\n}\n\nstatic ssize_t show_pma_counter(struct ib_device *ibdev, u32 port_num,\n\t\t\t\tstruct ib_port_attribute *attr, char *buf)\n{\n\tstruct port_table_attribute *tab_attr =\n\t\tcontainer_of(attr, struct port_table_attribute, attr);\n\tint offset = tab_attr->index & 0xffff;\n\tint width  = (tab_attr->index >> 16) & 0xff;\n\tint ret;\n\tu8 data[8];\n\tint len;\n\n\tret = get_perf_mad(ibdev, port_num, tab_attr->attr_id, &data,\n\t\t\t40 + offset / 8, sizeof(data));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (width) {\n\tcase 4:\n\t\tlen = sysfs_emit(buf, \"%d\\n\",\n\t\t\t\t (*data >> (4 - (offset % 8))) & 0xf);\n\t\tbreak;\n\tcase 8:\n\t\tlen = sysfs_emit(buf, \"%u\\n\", *data);\n\t\tbreak;\n\tcase 16:\n\t\tlen = sysfs_emit(buf, \"%u\\n\", be16_to_cpup((__be16 *)data));\n\t\tbreak;\n\tcase 32:\n\t\tlen = sysfs_emit(buf, \"%u\\n\", be32_to_cpup((__be32 *)data));\n\t\tbreak;\n\tcase 64:\n\t\tlen = sysfs_emit(buf, \"%llu\\n\", be64_to_cpup((__be64 *)data));\n\t\tbreak;\n\tdefault:\n\t\tlen = 0;\n\t\tbreak;\n\t}\n\n\treturn len;\n}\n\nstatic PORT_PMA_ATTR(symbol_error\t\t    ,  0, 16,  32);\nstatic PORT_PMA_ATTR(link_error_recovery\t    ,  1,  8,  48);\nstatic PORT_PMA_ATTR(link_downed\t\t    ,  2,  8,  56);\nstatic PORT_PMA_ATTR(port_rcv_errors\t\t    ,  3, 16,  64);\nstatic PORT_PMA_ATTR(port_rcv_remote_physical_errors,  4, 16,  80);\nstatic PORT_PMA_ATTR(port_rcv_switch_relay_errors   ,  5, 16,  96);\nstatic PORT_PMA_ATTR(port_xmit_discards\t\t    ,  6, 16, 112);\nstatic PORT_PMA_ATTR(port_xmit_constraint_errors    ,  7,  8, 128);\nstatic PORT_PMA_ATTR(port_rcv_constraint_errors\t    ,  8,  8, 136);\nstatic PORT_PMA_ATTR(local_link_integrity_errors    ,  9,  4, 152);\nstatic PORT_PMA_ATTR(excessive_buffer_overrun_errors, 10,  4, 156);\nstatic PORT_PMA_ATTR(VL15_dropped\t\t    , 11, 16, 176);\nstatic PORT_PMA_ATTR(port_xmit_data\t\t    , 12, 32, 192);\nstatic PORT_PMA_ATTR(port_rcv_data\t\t    , 13, 32, 224);\nstatic PORT_PMA_ATTR(port_xmit_packets\t\t    , 14, 32, 256);\nstatic PORT_PMA_ATTR(port_rcv_packets\t\t    , 15, 32, 288);\nstatic PORT_PMA_ATTR(port_xmit_wait\t\t    ,  0, 32, 320);\n\n \nstatic PORT_PMA_ATTR_EXT(port_xmit_data\t\t    , 64,  64);\nstatic PORT_PMA_ATTR_EXT(port_rcv_data\t\t    , 64, 128);\nstatic PORT_PMA_ATTR_EXT(port_xmit_packets\t    , 64, 192);\nstatic PORT_PMA_ATTR_EXT(port_rcv_packets\t    , 64, 256);\nstatic PORT_PMA_ATTR_EXT(unicast_xmit_packets\t    , 64, 320);\nstatic PORT_PMA_ATTR_EXT(unicast_rcv_packets\t    , 64, 384);\nstatic PORT_PMA_ATTR_EXT(multicast_xmit_packets\t    , 64, 448);\nstatic PORT_PMA_ATTR_EXT(multicast_rcv_packets\t    , 64, 512);\n\nstatic struct attribute *pma_attrs[] = {\n\t&port_pma_attr_symbol_error.attr.attr,\n\t&port_pma_attr_link_error_recovery.attr.attr,\n\t&port_pma_attr_link_downed.attr.attr,\n\t&port_pma_attr_port_rcv_errors.attr.attr,\n\t&port_pma_attr_port_rcv_remote_physical_errors.attr.attr,\n\t&port_pma_attr_port_rcv_switch_relay_errors.attr.attr,\n\t&port_pma_attr_port_xmit_discards.attr.attr,\n\t&port_pma_attr_port_xmit_constraint_errors.attr.attr,\n\t&port_pma_attr_port_rcv_constraint_errors.attr.attr,\n\t&port_pma_attr_local_link_integrity_errors.attr.attr,\n\t&port_pma_attr_excessive_buffer_overrun_errors.attr.attr,\n\t&port_pma_attr_VL15_dropped.attr.attr,\n\t&port_pma_attr_port_xmit_data.attr.attr,\n\t&port_pma_attr_port_rcv_data.attr.attr,\n\t&port_pma_attr_port_xmit_packets.attr.attr,\n\t&port_pma_attr_port_rcv_packets.attr.attr,\n\t&port_pma_attr_port_xmit_wait.attr.attr,\n\tNULL\n};\n\nstatic struct attribute *pma_attrs_ext[] = {\n\t&port_pma_attr_symbol_error.attr.attr,\n\t&port_pma_attr_link_error_recovery.attr.attr,\n\t&port_pma_attr_link_downed.attr.attr,\n\t&port_pma_attr_port_rcv_errors.attr.attr,\n\t&port_pma_attr_port_rcv_remote_physical_errors.attr.attr,\n\t&port_pma_attr_port_rcv_switch_relay_errors.attr.attr,\n\t&port_pma_attr_port_xmit_discards.attr.attr,\n\t&port_pma_attr_port_xmit_constraint_errors.attr.attr,\n\t&port_pma_attr_port_rcv_constraint_errors.attr.attr,\n\t&port_pma_attr_local_link_integrity_errors.attr.attr,\n\t&port_pma_attr_excessive_buffer_overrun_errors.attr.attr,\n\t&port_pma_attr_VL15_dropped.attr.attr,\n\t&port_pma_attr_ext_port_xmit_data.attr.attr,\n\t&port_pma_attr_ext_port_rcv_data.attr.attr,\n\t&port_pma_attr_ext_port_xmit_packets.attr.attr,\n\t&port_pma_attr_port_xmit_wait.attr.attr,\n\t&port_pma_attr_ext_port_rcv_packets.attr.attr,\n\t&port_pma_attr_ext_unicast_rcv_packets.attr.attr,\n\t&port_pma_attr_ext_unicast_xmit_packets.attr.attr,\n\t&port_pma_attr_ext_multicast_rcv_packets.attr.attr,\n\t&port_pma_attr_ext_multicast_xmit_packets.attr.attr,\n\tNULL\n};\n\nstatic struct attribute *pma_attrs_noietf[] = {\n\t&port_pma_attr_symbol_error.attr.attr,\n\t&port_pma_attr_link_error_recovery.attr.attr,\n\t&port_pma_attr_link_downed.attr.attr,\n\t&port_pma_attr_port_rcv_errors.attr.attr,\n\t&port_pma_attr_port_rcv_remote_physical_errors.attr.attr,\n\t&port_pma_attr_port_rcv_switch_relay_errors.attr.attr,\n\t&port_pma_attr_port_xmit_discards.attr.attr,\n\t&port_pma_attr_port_xmit_constraint_errors.attr.attr,\n\t&port_pma_attr_port_rcv_constraint_errors.attr.attr,\n\t&port_pma_attr_local_link_integrity_errors.attr.attr,\n\t&port_pma_attr_excessive_buffer_overrun_errors.attr.attr,\n\t&port_pma_attr_VL15_dropped.attr.attr,\n\t&port_pma_attr_ext_port_xmit_data.attr.attr,\n\t&port_pma_attr_ext_port_rcv_data.attr.attr,\n\t&port_pma_attr_ext_port_xmit_packets.attr.attr,\n\t&port_pma_attr_ext_port_rcv_packets.attr.attr,\n\t&port_pma_attr_port_xmit_wait.attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group pma_group = {\n\t.name  = \"counters\",\n\t.attrs  = pma_attrs\n};\n\nstatic const struct attribute_group pma_group_ext = {\n\t.name  = \"counters\",\n\t.attrs  = pma_attrs_ext\n};\n\nstatic const struct attribute_group pma_group_noietf = {\n\t.name  = \"counters\",\n\t.attrs  = pma_attrs_noietf\n};\n\nstatic void ib_port_release(struct kobject *kobj)\n{\n\tstruct ib_port *port = container_of(kobj, struct ib_port, kobj);\n\tint i;\n\n\tfor (i = 0; i != ARRAY_SIZE(port->groups); i++)\n\t\tkfree(port->groups[i].attrs);\n\tif (port->hw_stats_data)\n\t\trdma_free_hw_stats_struct(port->hw_stats_data->stats);\n\tkfree(port->hw_stats_data);\n\tkvfree(port);\n}\n\nstatic void ib_port_gid_attr_release(struct kobject *kobj)\n{\n\tstruct gid_attr_group *gid_attr_group =\n\t\tcontainer_of(kobj, struct gid_attr_group, kobj);\n\tint i;\n\n\tfor (i = 0; i != ARRAY_SIZE(gid_attr_group->groups); i++)\n\t\tkfree(gid_attr_group->groups[i].attrs);\n\tkfree(gid_attr_group);\n}\n\nstatic struct kobj_type port_type = {\n\t.release       = ib_port_release,\n\t.sysfs_ops     = &port_sysfs_ops,\n\t.default_groups = port_default_groups,\n};\n\nstatic struct kobj_type gid_attr_type = {\n\t.sysfs_ops      = &gid_attr_sysfs_ops,\n\t.release        = ib_port_gid_attr_release\n};\n\n \nstatic const struct attribute_group *get_counter_table(struct ib_device *dev,\n\t\t\t\t\t\t       int port_num)\n{\n\tstruct ib_class_port_info cpi;\n\n\tif (get_perf_mad(dev, port_num, IB_PMA_CLASS_PORT_INFO,\n\t\t\t\t&cpi, 40, sizeof(cpi)) >= 0) {\n\t\tif (cpi.capability_mask & IB_PMA_CLASS_CAP_EXT_WIDTH)\n\t\t\t \n\t\t\treturn &pma_group_ext;\n\n\t\tif (cpi.capability_mask & IB_PMA_CLASS_CAP_EXT_WIDTH_NOIETF)\n\t\t\t \n\t\t\treturn &pma_group_noietf;\n\t}\n\n\t \n\treturn &pma_group;\n}\n\nstatic int update_hw_stats(struct ib_device *dev, struct rdma_hw_stats *stats,\n\t\t\t   u32 port_num, int index)\n{\n\tint ret;\n\n\tif (time_is_after_eq_jiffies(stats->timestamp + stats->lifespan))\n\t\treturn 0;\n\tret = dev->ops.get_hw_stats(dev, stats, port_num, index);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret == stats->num_counters)\n\t\tstats->timestamp = jiffies;\n\n\treturn 0;\n}\n\nstatic int print_hw_stat(struct ib_device *dev, int port_num,\n\t\t\t struct rdma_hw_stats *stats, int index, char *buf)\n{\n\tu64 v = rdma_counter_get_hwstat_value(dev, port_num, index);\n\n\treturn sysfs_emit(buf, \"%llu\\n\", stats->value[index] + v);\n}\n\nstatic ssize_t show_hw_stats(struct ib_device *ibdev,\n\t\t\t     struct rdma_hw_stats *stats, unsigned int index,\n\t\t\t     unsigned int port_num, char *buf)\n{\n\tint ret;\n\n\tmutex_lock(&stats->lock);\n\tret = update_hw_stats(ibdev, stats, port_num, index);\n\tif (ret)\n\t\tgoto unlock;\n\tret = print_hw_stat(ibdev, port_num, stats, index, buf);\nunlock:\n\tmutex_unlock(&stats->lock);\n\n\treturn ret;\n}\n\nstatic ssize_t show_stats_lifespan(struct ib_device *ibdev,\n\t\t\t\t   struct rdma_hw_stats *stats,\n\t\t\t\t   unsigned int index, unsigned int port_num,\n\t\t\t\t   char *buf)\n{\n\tint msecs;\n\n\tmutex_lock(&stats->lock);\n\tmsecs = jiffies_to_msecs(stats->lifespan);\n\tmutex_unlock(&stats->lock);\n\n\treturn sysfs_emit(buf, \"%d\\n\", msecs);\n}\n\nstatic ssize_t set_stats_lifespan(struct ib_device *ibdev,\n\t\t\t\t   struct rdma_hw_stats *stats,\n\t\t\t\t   unsigned int index, unsigned int port_num,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tint msecs;\n\tint jiffies;\n\tint ret;\n\n\tret = kstrtoint(buf, 10, &msecs);\n\tif (ret)\n\t\treturn ret;\n\tif (msecs < 0 || msecs > 10000)\n\t\treturn -EINVAL;\n\tjiffies = msecs_to_jiffies(msecs);\n\n\tmutex_lock(&stats->lock);\n\tstats->lifespan = jiffies;\n\tmutex_unlock(&stats->lock);\n\n\treturn count;\n}\n\nstatic struct hw_stats_device_data *\nalloc_hw_stats_device(struct ib_device *ibdev)\n{\n\tstruct hw_stats_device_data *data;\n\tstruct rdma_hw_stats *stats;\n\n\tif (!ibdev->ops.alloc_hw_device_stats)\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\tstats = ibdev->ops.alloc_hw_device_stats(ibdev);\n\tif (!stats)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!stats->descs || stats->num_counters <= 0)\n\t\tgoto err_free_stats;\n\n\t \n\tdata = kzalloc(struct_size(data, attrs, size_add(stats->num_counters, 1)),\n\t\t       GFP_KERNEL);\n\tif (!data)\n\t\tgoto err_free_stats;\n\tdata->group.attrs = kcalloc(stats->num_counters + 2,\n\t\t\t\t    sizeof(*data->group.attrs), GFP_KERNEL);\n\tif (!data->group.attrs)\n\t\tgoto err_free_data;\n\n\tdata->group.name = \"hw_counters\";\n\tdata->stats = stats;\n\treturn data;\n\nerr_free_data:\n\tkfree(data);\nerr_free_stats:\n\trdma_free_hw_stats_struct(stats);\n\treturn ERR_PTR(-ENOMEM);\n}\n\nvoid ib_device_release_hw_stats(struct hw_stats_device_data *data)\n{\n\tkfree(data->group.attrs);\n\trdma_free_hw_stats_struct(data->stats);\n\tkfree(data);\n}\n\nint ib_setup_device_attrs(struct ib_device *ibdev)\n{\n\tstruct hw_stats_device_attribute *attr;\n\tstruct hw_stats_device_data *data;\n\tbool opstat_skipped = false;\n\tint i, ret, pos = 0;\n\n\tdata = alloc_hw_stats_device(ibdev);\n\tif (IS_ERR(data)) {\n\t\tif (PTR_ERR(data) == -EOPNOTSUPP)\n\t\t\treturn 0;\n\t\treturn PTR_ERR(data);\n\t}\n\tibdev->hw_stats_data = data;\n\n\tret = ibdev->ops.get_hw_stats(ibdev, data->stats, 0,\n\t\t\t\t      data->stats->num_counters);\n\tif (ret != data->stats->num_counters) {\n\t\tif (WARN_ON(ret >= 0))\n\t\t\treturn -EINVAL;\n\t\treturn ret;\n\t}\n\n\tdata->stats->timestamp = jiffies;\n\n\tfor (i = 0; i < data->stats->num_counters; i++) {\n\t\tif (data->stats->descs[i].flags & IB_STAT_FLAG_OPTIONAL) {\n\t\t\topstat_skipped = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tWARN_ON(opstat_skipped);\n\t\tattr = &data->attrs[pos];\n\t\tsysfs_attr_init(&attr->attr.attr);\n\t\tattr->attr.attr.name = data->stats->descs[i].name;\n\t\tattr->attr.attr.mode = 0444;\n\t\tattr->attr.show = hw_stat_device_show;\n\t\tattr->show = show_hw_stats;\n\t\tdata->group.attrs[pos] = &attr->attr.attr;\n\t\tpos++;\n\t}\n\n\tattr = &data->attrs[pos];\n\tsysfs_attr_init(&attr->attr.attr);\n\tattr->attr.attr.name = \"lifespan\";\n\tattr->attr.attr.mode = 0644;\n\tattr->attr.show = hw_stat_device_show;\n\tattr->show = show_stats_lifespan;\n\tattr->attr.store = hw_stat_device_store;\n\tattr->store = set_stats_lifespan;\n\tdata->group.attrs[pos] = &attr->attr.attr;\n\tfor (i = 0; i != ARRAY_SIZE(ibdev->groups); i++)\n\t\tif (!ibdev->groups[i]) {\n\t\t\tibdev->groups[i] = &data->group;\n\t\t\treturn 0;\n\t\t}\n\tWARN(true, \"struct ib_device->groups is too small\");\n\treturn -EINVAL;\n}\n\nstatic struct hw_stats_port_data *\nalloc_hw_stats_port(struct ib_port *port, struct attribute_group *group)\n{\n\tstruct ib_device *ibdev = port->ibdev;\n\tstruct hw_stats_port_data *data;\n\tstruct rdma_hw_stats *stats;\n\n\tif (!ibdev->ops.alloc_hw_port_stats)\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\tstats = ibdev->ops.alloc_hw_port_stats(port->ibdev, port->port_num);\n\tif (!stats)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!stats->descs || stats->num_counters <= 0)\n\t\tgoto err_free_stats;\n\n\t \n\tdata = kzalloc(struct_size(data, attrs, size_add(stats->num_counters, 1)),\n\t\t       GFP_KERNEL);\n\tif (!data)\n\t\tgoto err_free_stats;\n\tgroup->attrs = kcalloc(stats->num_counters + 2,\n\t\t\t\t    sizeof(*group->attrs), GFP_KERNEL);\n\tif (!group->attrs)\n\t\tgoto err_free_data;\n\n\tgroup->name = \"hw_counters\";\n\tdata->stats = stats;\n\treturn data;\n\nerr_free_data:\n\tkfree(data);\nerr_free_stats:\n\trdma_free_hw_stats_struct(stats);\n\treturn ERR_PTR(-ENOMEM);\n}\n\nstatic int setup_hw_port_stats(struct ib_port *port,\n\t\t\t       struct attribute_group *group)\n{\n\tstruct hw_stats_port_attribute *attr;\n\tstruct hw_stats_port_data *data;\n\tbool opstat_skipped = false;\n\tint i, ret, pos = 0;\n\n\tdata = alloc_hw_stats_port(port, group);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tret = port->ibdev->ops.get_hw_stats(port->ibdev, data->stats,\n\t\t\t\t\t    port->port_num,\n\t\t\t\t\t    data->stats->num_counters);\n\tif (ret != data->stats->num_counters) {\n\t\tif (WARN_ON(ret >= 0))\n\t\t\treturn -EINVAL;\n\t\treturn ret;\n\t}\n\n\tdata->stats->timestamp = jiffies;\n\n\tfor (i = 0; i < data->stats->num_counters; i++) {\n\t\tif (data->stats->descs[i].flags & IB_STAT_FLAG_OPTIONAL) {\n\t\t\topstat_skipped = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tWARN_ON(opstat_skipped);\n\t\tattr = &data->attrs[pos];\n\t\tsysfs_attr_init(&attr->attr.attr);\n\t\tattr->attr.attr.name = data->stats->descs[i].name;\n\t\tattr->attr.attr.mode = 0444;\n\t\tattr->attr.show = hw_stat_port_show;\n\t\tattr->show = show_hw_stats;\n\t\tgroup->attrs[pos] = &attr->attr.attr;\n\t\tpos++;\n\t}\n\n\tattr = &data->attrs[pos];\n\tsysfs_attr_init(&attr->attr.attr);\n\tattr->attr.attr.name = \"lifespan\";\n\tattr->attr.attr.mode = 0644;\n\tattr->attr.show = hw_stat_port_show;\n\tattr->show = show_stats_lifespan;\n\tattr->attr.store = hw_stat_port_store;\n\tattr->store = set_stats_lifespan;\n\tgroup->attrs[pos] = &attr->attr.attr;\n\n\tport->hw_stats_data = data;\n\treturn 0;\n}\n\nstruct rdma_hw_stats *ib_get_hw_stats_port(struct ib_device *ibdev,\n\t\t\t\t\t   u32 port_num)\n{\n\tif (!ibdev->port_data || !rdma_is_port_valid(ibdev, port_num) ||\n\t    !ibdev->port_data[port_num].sysfs->hw_stats_data)\n\t\treturn NULL;\n\treturn ibdev->port_data[port_num].sysfs->hw_stats_data->stats;\n}\n\nstatic int\nalloc_port_table_group(const char *name, struct attribute_group *group,\n\t\t       struct port_table_attribute *attrs, size_t num,\n\t\t       ssize_t (*show)(struct ib_device *ibdev, u32 port_num,\n\t\t\t\t       struct ib_port_attribute *, char *buf))\n{\n\tstruct attribute **attr_list;\n\tint i;\n\n\tattr_list = kcalloc(num + 1, sizeof(*attr_list), GFP_KERNEL);\n\tif (!attr_list)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < num; i++) {\n\t\tstruct port_table_attribute *element = &attrs[i];\n\n\t\tif (snprintf(element->name, sizeof(element->name), \"%d\", i) >=\n\t\t    sizeof(element->name))\n\t\t\tgoto err;\n\n\t\tsysfs_attr_init(&element->attr.attr);\n\t\telement->attr.attr.name = element->name;\n\t\telement->attr.attr.mode = 0444;\n\t\telement->attr.show = show;\n\t\telement->index = i;\n\n\t\tattr_list[i] = &element->attr.attr;\n\t}\n\tgroup->name = name;\n\tgroup->attrs = attr_list;\n\treturn 0;\nerr:\n\tkfree(attr_list);\n\treturn -EINVAL;\n}\n\n \nstatic int setup_gid_attrs(struct ib_port *port,\n\t\t\t   const struct ib_port_attr *attr)\n{\n\tstruct gid_attr_group *gid_attr_group;\n\tint ret;\n\n\tgid_attr_group = kzalloc(struct_size(gid_attr_group, attrs_list,\n\t\t\t\t\t     size_mul(attr->gid_tbl_len, 2)),\n\t\t\t\t GFP_KERNEL);\n\tif (!gid_attr_group)\n\t\treturn -ENOMEM;\n\tgid_attr_group->port = port;\n\tkobject_init(&gid_attr_group->kobj, &gid_attr_type);\n\n\tret = alloc_port_table_group(\"ndevs\", &gid_attr_group->groups[0],\n\t\t\t\t     gid_attr_group->attrs_list,\n\t\t\t\t     attr->gid_tbl_len,\n\t\t\t\t     show_port_gid_attr_ndev);\n\tif (ret)\n\t\tgoto err_put;\n\tgid_attr_group->groups_list[0] = &gid_attr_group->groups[0];\n\n\tret = alloc_port_table_group(\n\t\t\"types\", &gid_attr_group->groups[1],\n\t\tgid_attr_group->attrs_list + attr->gid_tbl_len,\n\t\tattr->gid_tbl_len, show_port_gid_attr_gid_type);\n\tif (ret)\n\t\tgoto err_put;\n\tgid_attr_group->groups_list[1] = &gid_attr_group->groups[1];\n\n\tret = kobject_add(&gid_attr_group->kobj, &port->kobj, \"gid_attrs\");\n\tif (ret)\n\t\tgoto err_put;\n\tret = sysfs_create_groups(&gid_attr_group->kobj,\n\t\t\t\t  gid_attr_group->groups_list);\n\tif (ret)\n\t\tgoto err_del;\n\tport->gid_attr_group = gid_attr_group;\n\treturn 0;\n\nerr_del:\n\tkobject_del(&gid_attr_group->kobj);\nerr_put:\n\tkobject_put(&gid_attr_group->kobj);\n\treturn ret;\n}\n\nstatic void destroy_gid_attrs(struct ib_port *port)\n{\n\tstruct gid_attr_group *gid_attr_group = port->gid_attr_group;\n\n\tif (!gid_attr_group)\n\t\treturn;\n\tsysfs_remove_groups(&gid_attr_group->kobj, gid_attr_group->groups_list);\n\tkobject_del(&gid_attr_group->kobj);\n\tkobject_put(&gid_attr_group->kobj);\n}\n\n \nstatic struct ib_port *setup_port(struct ib_core_device *coredev, int port_num,\n\t\t\t\t  const struct ib_port_attr *attr)\n{\n\tstruct ib_device *device = rdma_device_to_ibdev(&coredev->dev);\n\tbool is_full_dev = &device->coredev == coredev;\n\tconst struct attribute_group **cur_group;\n\tstruct ib_port *p;\n\tint ret;\n\n\tp = kvzalloc(struct_size(p, attrs_list,\n\t\t\t\tsize_add(attr->gid_tbl_len, attr->pkey_tbl_len)),\n\t\t     GFP_KERNEL);\n\tif (!p)\n\t\treturn ERR_PTR(-ENOMEM);\n\tp->ibdev = device;\n\tp->port_num = port_num;\n\tkobject_init(&p->kobj, &port_type);\n\n\tif (device->port_data && is_full_dev)\n\t\tdevice->port_data[port_num].sysfs = p;\n\n\tcur_group = p->groups_list;\n\tret = alloc_port_table_group(\"gids\", &p->groups[0], p->attrs_list,\n\t\t\t\t     attr->gid_tbl_len, show_port_gid);\n\tif (ret)\n\t\tgoto err_put;\n\t*cur_group++ = &p->groups[0];\n\n\tif (attr->pkey_tbl_len) {\n\t\tret = alloc_port_table_group(\"pkeys\", &p->groups[1],\n\t\t\t\t\t     p->attrs_list + attr->gid_tbl_len,\n\t\t\t\t\t     attr->pkey_tbl_len, show_port_pkey);\n\t\tif (ret)\n\t\t\tgoto err_put;\n\t\t*cur_group++ = &p->groups[1];\n\t}\n\n\t \n\tif (port_num && is_full_dev) {\n\t\tret = setup_hw_port_stats(p, &p->groups[2]);\n\t\tif (ret && ret != -EOPNOTSUPP)\n\t\t\tgoto err_put;\n\t\tif (!ret)\n\t\t\t*cur_group++ = &p->groups[2];\n\t}\n\n\tif (device->ops.process_mad && is_full_dev)\n\t\t*cur_group++ = get_counter_table(device, port_num);\n\n\tret = kobject_add(&p->kobj, coredev->ports_kobj, \"%d\", port_num);\n\tif (ret)\n\t\tgoto err_put;\n\tret = sysfs_create_groups(&p->kobj, p->groups_list);\n\tif (ret)\n\t\tgoto err_del;\n\tif (is_full_dev) {\n\t\tret = sysfs_create_groups(&p->kobj, device->ops.port_groups);\n\t\tif (ret)\n\t\t\tgoto err_groups;\n\t}\n\n\tlist_add_tail(&p->kobj.entry, &coredev->port_list);\n\treturn p;\n\nerr_groups:\n\tsysfs_remove_groups(&p->kobj, p->groups_list);\nerr_del:\n\tkobject_del(&p->kobj);\nerr_put:\n\tif (device->port_data && is_full_dev)\n\t\tdevice->port_data[port_num].sysfs = NULL;\n\tkobject_put(&p->kobj);\n\treturn ERR_PTR(ret);\n}\n\nstatic void destroy_port(struct ib_core_device *coredev, struct ib_port *port)\n{\n\tbool is_full_dev = &port->ibdev->coredev == coredev;\n\n\tlist_del(&port->kobj.entry);\n\tif (is_full_dev)\n\t\tsysfs_remove_groups(&port->kobj, port->ibdev->ops.port_groups);\n\n\tsysfs_remove_groups(&port->kobj, port->groups_list);\n\tkobject_del(&port->kobj);\n\n\tif (port->ibdev->port_data &&\n\t    port->ibdev->port_data[port->port_num].sysfs == port)\n\t\tport->ibdev->port_data[port->port_num].sysfs = NULL;\n\n\tkobject_put(&port->kobj);\n}\n\nstatic const char *node_type_string(int node_type)\n{\n\tswitch (node_type) {\n\tcase RDMA_NODE_IB_CA:\n\t\treturn \"CA\";\n\tcase RDMA_NODE_IB_SWITCH:\n\t\treturn \"switch\";\n\tcase RDMA_NODE_IB_ROUTER:\n\t\treturn \"router\";\n\tcase RDMA_NODE_RNIC:\n\t\treturn \"RNIC\";\n\tcase RDMA_NODE_USNIC:\n\t\treturn \"usNIC\";\n\tcase RDMA_NODE_USNIC_UDP:\n\t\treturn \"usNIC UDP\";\n\tcase RDMA_NODE_UNSPECIFIED:\n\t\treturn \"unspecified\";\n\t}\n\treturn \"<unknown>\";\n}\n\nstatic ssize_t node_type_show(struct device *device,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct ib_device *dev = rdma_device_to_ibdev(device);\n\n\treturn sysfs_emit(buf, \"%u: %s\\n\", dev->node_type,\n\t\t\t  node_type_string(dev->node_type));\n}\nstatic DEVICE_ATTR_RO(node_type);\n\nstatic ssize_t sys_image_guid_show(struct device *device,\n\t\t\t\t   struct device_attribute *dev_attr, char *buf)\n{\n\tstruct ib_device *dev = rdma_device_to_ibdev(device);\n\t__be16 *guid = (__be16 *)&dev->attrs.sys_image_guid;\n\n\treturn sysfs_emit(buf, \"%04x:%04x:%04x:%04x\\n\",\n\t\t\t  be16_to_cpu(guid[0]),\n\t\t\t  be16_to_cpu(guid[1]),\n\t\t\t  be16_to_cpu(guid[2]),\n\t\t\t  be16_to_cpu(guid[3]));\n}\nstatic DEVICE_ATTR_RO(sys_image_guid);\n\nstatic ssize_t node_guid_show(struct device *device,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct ib_device *dev = rdma_device_to_ibdev(device);\n\t__be16 *node_guid = (__be16 *)&dev->node_guid;\n\n\treturn sysfs_emit(buf, \"%04x:%04x:%04x:%04x\\n\",\n\t\t\t  be16_to_cpu(node_guid[0]),\n\t\t\t  be16_to_cpu(node_guid[1]),\n\t\t\t  be16_to_cpu(node_guid[2]),\n\t\t\t  be16_to_cpu(node_guid[3]));\n}\nstatic DEVICE_ATTR_RO(node_guid);\n\nstatic ssize_t node_desc_show(struct device *device,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct ib_device *dev = rdma_device_to_ibdev(device);\n\n\treturn sysfs_emit(buf, \"%.64s\\n\", dev->node_desc);\n}\n\nstatic ssize_t node_desc_store(struct device *device,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       const char *buf, size_t count)\n{\n\tstruct ib_device *dev = rdma_device_to_ibdev(device);\n\tstruct ib_device_modify desc = {};\n\tint ret;\n\n\tif (!dev->ops.modify_device)\n\t\treturn -EOPNOTSUPP;\n\n\tmemcpy(desc.node_desc, buf, min_t(int, count, IB_DEVICE_NODE_DESC_MAX));\n\tret = ib_modify_device(dev, IB_DEVICE_MODIFY_NODE_DESC, &desc);\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(node_desc);\n\nstatic ssize_t fw_ver_show(struct device *device, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct ib_device *dev = rdma_device_to_ibdev(device);\n\tchar version[IB_FW_VERSION_NAME_MAX] = {};\n\n\tib_get_device_fw_str(dev, version);\n\n\treturn sysfs_emit(buf, \"%s\\n\", version);\n}\nstatic DEVICE_ATTR_RO(fw_ver);\n\nstatic struct attribute *ib_dev_attrs[] = {\n\t&dev_attr_node_type.attr,\n\t&dev_attr_node_guid.attr,\n\t&dev_attr_sys_image_guid.attr,\n\t&dev_attr_fw_ver.attr,\n\t&dev_attr_node_desc.attr,\n\tNULL,\n};\n\nconst struct attribute_group ib_dev_attr_group = {\n\t.attrs = ib_dev_attrs,\n};\n\nvoid ib_free_port_attrs(struct ib_core_device *coredev)\n{\n\tstruct kobject *p, *t;\n\n\tlist_for_each_entry_safe(p, t, &coredev->port_list, entry) {\n\t\tstruct ib_port *port = container_of(p, struct ib_port, kobj);\n\n\t\tdestroy_gid_attrs(port);\n\t\tdestroy_port(coredev, port);\n\t}\n\n\tkobject_put(coredev->ports_kobj);\n}\n\nint ib_setup_port_attrs(struct ib_core_device *coredev)\n{\n\tstruct ib_device *device = rdma_device_to_ibdev(&coredev->dev);\n\tu32 port_num;\n\tint ret;\n\n\tcoredev->ports_kobj = kobject_create_and_add(\"ports\",\n\t\t\t\t\t\t     &coredev->dev.kobj);\n\tif (!coredev->ports_kobj)\n\t\treturn -ENOMEM;\n\n\trdma_for_each_port (device, port_num) {\n\t\tstruct ib_port_attr attr;\n\t\tstruct ib_port *port;\n\n\t\tret = ib_query_port(device, port_num, &attr);\n\t\tif (ret)\n\t\t\tgoto err_put;\n\n\t\tport = setup_port(coredev, port_num, &attr);\n\t\tif (IS_ERR(port)) {\n\t\t\tret = PTR_ERR(port);\n\t\t\tgoto err_put;\n\t\t}\n\n\t\tret = setup_gid_attrs(port, &attr);\n\t\tif (ret)\n\t\t\tgoto err_put;\n\t}\n\treturn 0;\n\nerr_put:\n\tib_free_port_attrs(coredev);\n\treturn ret;\n}\n\n \nint ib_port_register_client_groups(struct ib_device *ibdev, u32 port_num,\n\t\t\t\t   const struct attribute_group **groups)\n{\n\treturn sysfs_create_groups(&ibdev->port_data[port_num].sysfs->kobj,\n\t\t\t\t   groups);\n}\nEXPORT_SYMBOL(ib_port_register_client_groups);\n\nvoid ib_port_unregister_client_groups(struct ib_device *ibdev, u32 port_num,\n\t\t\t\t      const struct attribute_group **groups)\n{\n\treturn sysfs_remove_groups(&ibdev->port_data[port_num].sysfs->kobj,\n\t\t\t\t   groups);\n}\nEXPORT_SYMBOL(ib_port_unregister_client_groups);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}