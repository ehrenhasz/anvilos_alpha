{
  "module_name": "verbs.c",
  "hash_id": "dfc8e16ccb22df716b6b847cb6e18971e943d56cbe6c9014f560a4f4a0c78a63",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/core/verbs.c",
  "human_readable_source": " \n\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/in.h>\n#include <linux/in6.h>\n#include <net/addrconf.h>\n#include <linux/security.h>\n\n#include <rdma/ib_verbs.h>\n#include <rdma/ib_cache.h>\n#include <rdma/ib_addr.h>\n#include <rdma/rw.h>\n#include <rdma/lag.h>\n\n#include \"core_priv.h\"\n#include <trace/events/rdma_core.h>\n\nstatic int ib_resolve_eth_dmac(struct ib_device *device,\n\t\t\t       struct rdma_ah_attr *ah_attr);\n\nstatic const char * const ib_events[] = {\n\t[IB_EVENT_CQ_ERR]\t\t= \"CQ error\",\n\t[IB_EVENT_QP_FATAL]\t\t= \"QP fatal error\",\n\t[IB_EVENT_QP_REQ_ERR]\t\t= \"QP request error\",\n\t[IB_EVENT_QP_ACCESS_ERR]\t= \"QP access error\",\n\t[IB_EVENT_COMM_EST]\t\t= \"communication established\",\n\t[IB_EVENT_SQ_DRAINED]\t\t= \"send queue drained\",\n\t[IB_EVENT_PATH_MIG]\t\t= \"path migration successful\",\n\t[IB_EVENT_PATH_MIG_ERR]\t\t= \"path migration error\",\n\t[IB_EVENT_DEVICE_FATAL]\t\t= \"device fatal error\",\n\t[IB_EVENT_PORT_ACTIVE]\t\t= \"port active\",\n\t[IB_EVENT_PORT_ERR]\t\t= \"port error\",\n\t[IB_EVENT_LID_CHANGE]\t\t= \"LID change\",\n\t[IB_EVENT_PKEY_CHANGE]\t\t= \"P_key change\",\n\t[IB_EVENT_SM_CHANGE]\t\t= \"SM change\",\n\t[IB_EVENT_SRQ_ERR]\t\t= \"SRQ error\",\n\t[IB_EVENT_SRQ_LIMIT_REACHED]\t= \"SRQ limit reached\",\n\t[IB_EVENT_QP_LAST_WQE_REACHED]\t= \"last WQE reached\",\n\t[IB_EVENT_CLIENT_REREGISTER]\t= \"client reregister\",\n\t[IB_EVENT_GID_CHANGE]\t\t= \"GID changed\",\n};\n\nconst char *__attribute_const__ ib_event_msg(enum ib_event_type event)\n{\n\tsize_t index = event;\n\n\treturn (index < ARRAY_SIZE(ib_events) && ib_events[index]) ?\n\t\t\tib_events[index] : \"unrecognized event\";\n}\nEXPORT_SYMBOL(ib_event_msg);\n\nstatic const char * const wc_statuses[] = {\n\t[IB_WC_SUCCESS]\t\t\t= \"success\",\n\t[IB_WC_LOC_LEN_ERR]\t\t= \"local length error\",\n\t[IB_WC_LOC_QP_OP_ERR]\t\t= \"local QP operation error\",\n\t[IB_WC_LOC_EEC_OP_ERR]\t\t= \"local EE context operation error\",\n\t[IB_WC_LOC_PROT_ERR]\t\t= \"local protection error\",\n\t[IB_WC_WR_FLUSH_ERR]\t\t= \"WR flushed\",\n\t[IB_WC_MW_BIND_ERR]\t\t= \"memory bind operation error\",\n\t[IB_WC_BAD_RESP_ERR]\t\t= \"bad response error\",\n\t[IB_WC_LOC_ACCESS_ERR]\t\t= \"local access error\",\n\t[IB_WC_REM_INV_REQ_ERR]\t\t= \"remote invalid request error\",\n\t[IB_WC_REM_ACCESS_ERR]\t\t= \"remote access error\",\n\t[IB_WC_REM_OP_ERR]\t\t= \"remote operation error\",\n\t[IB_WC_RETRY_EXC_ERR]\t\t= \"transport retry counter exceeded\",\n\t[IB_WC_RNR_RETRY_EXC_ERR]\t= \"RNR retry counter exceeded\",\n\t[IB_WC_LOC_RDD_VIOL_ERR]\t= \"local RDD violation error\",\n\t[IB_WC_REM_INV_RD_REQ_ERR]\t= \"remote invalid RD request\",\n\t[IB_WC_REM_ABORT_ERR]\t\t= \"operation aborted\",\n\t[IB_WC_INV_EECN_ERR]\t\t= \"invalid EE context number\",\n\t[IB_WC_INV_EEC_STATE_ERR]\t= \"invalid EE context state\",\n\t[IB_WC_FATAL_ERR]\t\t= \"fatal error\",\n\t[IB_WC_RESP_TIMEOUT_ERR]\t= \"response timeout error\",\n\t[IB_WC_GENERAL_ERR]\t\t= \"general error\",\n};\n\nconst char *__attribute_const__ ib_wc_status_msg(enum ib_wc_status status)\n{\n\tsize_t index = status;\n\n\treturn (index < ARRAY_SIZE(wc_statuses) && wc_statuses[index]) ?\n\t\t\twc_statuses[index] : \"unrecognized status\";\n}\nEXPORT_SYMBOL(ib_wc_status_msg);\n\n__attribute_const__ int ib_rate_to_mult(enum ib_rate rate)\n{\n\tswitch (rate) {\n\tcase IB_RATE_2_5_GBPS: return   1;\n\tcase IB_RATE_5_GBPS:   return   2;\n\tcase IB_RATE_10_GBPS:  return   4;\n\tcase IB_RATE_20_GBPS:  return   8;\n\tcase IB_RATE_30_GBPS:  return  12;\n\tcase IB_RATE_40_GBPS:  return  16;\n\tcase IB_RATE_60_GBPS:  return  24;\n\tcase IB_RATE_80_GBPS:  return  32;\n\tcase IB_RATE_120_GBPS: return  48;\n\tcase IB_RATE_14_GBPS:  return   6;\n\tcase IB_RATE_56_GBPS:  return  22;\n\tcase IB_RATE_112_GBPS: return  45;\n\tcase IB_RATE_168_GBPS: return  67;\n\tcase IB_RATE_25_GBPS:  return  10;\n\tcase IB_RATE_100_GBPS: return  40;\n\tcase IB_RATE_200_GBPS: return  80;\n\tcase IB_RATE_300_GBPS: return 120;\n\tcase IB_RATE_28_GBPS:  return  11;\n\tcase IB_RATE_50_GBPS:  return  20;\n\tcase IB_RATE_400_GBPS: return 160;\n\tcase IB_RATE_600_GBPS: return 240;\n\tdefault:\t       return  -1;\n\t}\n}\nEXPORT_SYMBOL(ib_rate_to_mult);\n\n__attribute_const__ enum ib_rate mult_to_ib_rate(int mult)\n{\n\tswitch (mult) {\n\tcase 1:   return IB_RATE_2_5_GBPS;\n\tcase 2:   return IB_RATE_5_GBPS;\n\tcase 4:   return IB_RATE_10_GBPS;\n\tcase 8:   return IB_RATE_20_GBPS;\n\tcase 12:  return IB_RATE_30_GBPS;\n\tcase 16:  return IB_RATE_40_GBPS;\n\tcase 24:  return IB_RATE_60_GBPS;\n\tcase 32:  return IB_RATE_80_GBPS;\n\tcase 48:  return IB_RATE_120_GBPS;\n\tcase 6:   return IB_RATE_14_GBPS;\n\tcase 22:  return IB_RATE_56_GBPS;\n\tcase 45:  return IB_RATE_112_GBPS;\n\tcase 67:  return IB_RATE_168_GBPS;\n\tcase 10:  return IB_RATE_25_GBPS;\n\tcase 40:  return IB_RATE_100_GBPS;\n\tcase 80:  return IB_RATE_200_GBPS;\n\tcase 120: return IB_RATE_300_GBPS;\n\tcase 11:  return IB_RATE_28_GBPS;\n\tcase 20:  return IB_RATE_50_GBPS;\n\tcase 160: return IB_RATE_400_GBPS;\n\tcase 240: return IB_RATE_600_GBPS;\n\tdefault:  return IB_RATE_PORT_CURRENT;\n\t}\n}\nEXPORT_SYMBOL(mult_to_ib_rate);\n\n__attribute_const__ int ib_rate_to_mbps(enum ib_rate rate)\n{\n\tswitch (rate) {\n\tcase IB_RATE_2_5_GBPS: return 2500;\n\tcase IB_RATE_5_GBPS:   return 5000;\n\tcase IB_RATE_10_GBPS:  return 10000;\n\tcase IB_RATE_20_GBPS:  return 20000;\n\tcase IB_RATE_30_GBPS:  return 30000;\n\tcase IB_RATE_40_GBPS:  return 40000;\n\tcase IB_RATE_60_GBPS:  return 60000;\n\tcase IB_RATE_80_GBPS:  return 80000;\n\tcase IB_RATE_120_GBPS: return 120000;\n\tcase IB_RATE_14_GBPS:  return 14062;\n\tcase IB_RATE_56_GBPS:  return 56250;\n\tcase IB_RATE_112_GBPS: return 112500;\n\tcase IB_RATE_168_GBPS: return 168750;\n\tcase IB_RATE_25_GBPS:  return 25781;\n\tcase IB_RATE_100_GBPS: return 103125;\n\tcase IB_RATE_200_GBPS: return 206250;\n\tcase IB_RATE_300_GBPS: return 309375;\n\tcase IB_RATE_28_GBPS:  return 28125;\n\tcase IB_RATE_50_GBPS:  return 53125;\n\tcase IB_RATE_400_GBPS: return 425000;\n\tcase IB_RATE_600_GBPS: return 637500;\n\tdefault:\t       return -1;\n\t}\n}\nEXPORT_SYMBOL(ib_rate_to_mbps);\n\n__attribute_const__ enum rdma_transport_type\nrdma_node_get_transport(unsigned int node_type)\n{\n\n\tif (node_type == RDMA_NODE_USNIC)\n\t\treturn RDMA_TRANSPORT_USNIC;\n\tif (node_type == RDMA_NODE_USNIC_UDP)\n\t\treturn RDMA_TRANSPORT_USNIC_UDP;\n\tif (node_type == RDMA_NODE_RNIC)\n\t\treturn RDMA_TRANSPORT_IWARP;\n\tif (node_type == RDMA_NODE_UNSPECIFIED)\n\t\treturn RDMA_TRANSPORT_UNSPECIFIED;\n\n\treturn RDMA_TRANSPORT_IB;\n}\nEXPORT_SYMBOL(rdma_node_get_transport);\n\nenum rdma_link_layer rdma_port_get_link_layer(struct ib_device *device,\n\t\t\t\t\t      u32 port_num)\n{\n\tenum rdma_transport_type lt;\n\tif (device->ops.get_link_layer)\n\t\treturn device->ops.get_link_layer(device, port_num);\n\n\tlt = rdma_node_get_transport(device->node_type);\n\tif (lt == RDMA_TRANSPORT_IB)\n\t\treturn IB_LINK_LAYER_INFINIBAND;\n\n\treturn IB_LINK_LAYER_ETHERNET;\n}\nEXPORT_SYMBOL(rdma_port_get_link_layer);\n\n \n\n \nstruct ib_pd *__ib_alloc_pd(struct ib_device *device, unsigned int flags,\n\t\tconst char *caller)\n{\n\tstruct ib_pd *pd;\n\tint mr_access_flags = 0;\n\tint ret;\n\n\tpd = rdma_zalloc_drv_obj(device, ib_pd);\n\tif (!pd)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpd->device = device;\n\tpd->flags = flags;\n\n\trdma_restrack_new(&pd->res, RDMA_RESTRACK_PD);\n\trdma_restrack_set_name(&pd->res, caller);\n\n\tret = device->ops.alloc_pd(pd, NULL);\n\tif (ret) {\n\t\trdma_restrack_put(&pd->res);\n\t\tkfree(pd);\n\t\treturn ERR_PTR(ret);\n\t}\n\trdma_restrack_add(&pd->res);\n\n\tif (device->attrs.kernel_cap_flags & IBK_LOCAL_DMA_LKEY)\n\t\tpd->local_dma_lkey = device->local_dma_lkey;\n\telse\n\t\tmr_access_flags |= IB_ACCESS_LOCAL_WRITE;\n\n\tif (flags & IB_PD_UNSAFE_GLOBAL_RKEY) {\n\t\tpr_warn(\"%s: enabling unsafe global rkey\\n\", caller);\n\t\tmr_access_flags |= IB_ACCESS_REMOTE_READ | IB_ACCESS_REMOTE_WRITE;\n\t}\n\n\tif (mr_access_flags) {\n\t\tstruct ib_mr *mr;\n\n\t\tmr = pd->device->ops.get_dma_mr(pd, mr_access_flags);\n\t\tif (IS_ERR(mr)) {\n\t\t\tib_dealloc_pd(pd);\n\t\t\treturn ERR_CAST(mr);\n\t\t}\n\n\t\tmr->device\t= pd->device;\n\t\tmr->pd\t\t= pd;\n\t\tmr->type        = IB_MR_TYPE_DMA;\n\t\tmr->uobject\t= NULL;\n\t\tmr->need_inval\t= false;\n\n\t\tpd->__internal_mr = mr;\n\n\t\tif (!(device->attrs.kernel_cap_flags & IBK_LOCAL_DMA_LKEY))\n\t\t\tpd->local_dma_lkey = pd->__internal_mr->lkey;\n\n\t\tif (flags & IB_PD_UNSAFE_GLOBAL_RKEY)\n\t\t\tpd->unsafe_global_rkey = pd->__internal_mr->rkey;\n\t}\n\n\treturn pd;\n}\nEXPORT_SYMBOL(__ib_alloc_pd);\n\n \nint ib_dealloc_pd_user(struct ib_pd *pd, struct ib_udata *udata)\n{\n\tint ret;\n\n\tif (pd->__internal_mr) {\n\t\tret = pd->device->ops.dereg_mr(pd->__internal_mr, NULL);\n\t\tWARN_ON(ret);\n\t\tpd->__internal_mr = NULL;\n\t}\n\n\tret = pd->device->ops.dealloc_pd(pd, udata);\n\tif (ret)\n\t\treturn ret;\n\n\trdma_restrack_del(&pd->res);\n\tkfree(pd);\n\treturn ret;\n}\nEXPORT_SYMBOL(ib_dealloc_pd_user);\n\n \n\n \nvoid rdma_copy_ah_attr(struct rdma_ah_attr *dest,\n\t\t       const struct rdma_ah_attr *src)\n{\n\t*dest = *src;\n\tif (dest->grh.sgid_attr)\n\t\trdma_hold_gid_attr(dest->grh.sgid_attr);\n}\nEXPORT_SYMBOL(rdma_copy_ah_attr);\n\n \nvoid rdma_replace_ah_attr(struct rdma_ah_attr *old,\n\t\t\t  const struct rdma_ah_attr *new)\n{\n\trdma_destroy_ah_attr(old);\n\t*old = *new;\n\tif (old->grh.sgid_attr)\n\t\trdma_hold_gid_attr(old->grh.sgid_attr);\n}\nEXPORT_SYMBOL(rdma_replace_ah_attr);\n\n \nvoid rdma_move_ah_attr(struct rdma_ah_attr *dest, struct rdma_ah_attr *src)\n{\n\trdma_destroy_ah_attr(dest);\n\t*dest = *src;\n\tsrc->grh.sgid_attr = NULL;\n}\nEXPORT_SYMBOL(rdma_move_ah_attr);\n\n \nstatic int rdma_check_ah_attr(struct ib_device *device,\n\t\t\t      struct rdma_ah_attr *ah_attr)\n{\n\tif (!rdma_is_port_valid(device, ah_attr->port_num))\n\t\treturn -EINVAL;\n\n\tif ((rdma_is_grh_required(device, ah_attr->port_num) ||\n\t     ah_attr->type == RDMA_AH_ATTR_TYPE_ROCE) &&\n\t    !(ah_attr->ah_flags & IB_AH_GRH))\n\t\treturn -EINVAL;\n\n\tif (ah_attr->grh.sgid_attr) {\n\t\t \n\t\tif (ah_attr->grh.sgid_attr->index != ah_attr->grh.sgid_index ||\n\t\t    ah_attr->grh.sgid_attr->port_num != ah_attr->port_num)\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nstatic int rdma_fill_sgid_attr(struct ib_device *device,\n\t\t\t       struct rdma_ah_attr *ah_attr,\n\t\t\t       const struct ib_gid_attr **old_sgid_attr)\n{\n\tconst struct ib_gid_attr *sgid_attr;\n\tstruct ib_global_route *grh;\n\tint ret;\n\n\t*old_sgid_attr = ah_attr->grh.sgid_attr;\n\n\tret = rdma_check_ah_attr(device, ah_attr);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!(ah_attr->ah_flags & IB_AH_GRH))\n\t\treturn 0;\n\n\tgrh = rdma_ah_retrieve_grh(ah_attr);\n\tif (grh->sgid_attr)\n\t\treturn 0;\n\n\tsgid_attr =\n\t\trdma_get_gid_attr(device, ah_attr->port_num, grh->sgid_index);\n\tif (IS_ERR(sgid_attr))\n\t\treturn PTR_ERR(sgid_attr);\n\n\t \n\tgrh->sgid_attr = sgid_attr;\n\treturn 0;\n}\n\nstatic void rdma_unfill_sgid_attr(struct rdma_ah_attr *ah_attr,\n\t\t\t\t  const struct ib_gid_attr *old_sgid_attr)\n{\n\t \n\tif (ah_attr->grh.sgid_attr == old_sgid_attr)\n\t\treturn;\n\n\t \n\trdma_destroy_ah_attr(ah_attr);\n}\n\nstatic const struct ib_gid_attr *\nrdma_update_sgid_attr(struct rdma_ah_attr *ah_attr,\n\t\t      const struct ib_gid_attr *old_attr)\n{\n\tif (old_attr)\n\t\trdma_put_gid_attr(old_attr);\n\tif (ah_attr->ah_flags & IB_AH_GRH) {\n\t\trdma_hold_gid_attr(ah_attr->grh.sgid_attr);\n\t\treturn ah_attr->grh.sgid_attr;\n\t}\n\treturn NULL;\n}\n\nstatic struct ib_ah *_rdma_create_ah(struct ib_pd *pd,\n\t\t\t\t     struct rdma_ah_attr *ah_attr,\n\t\t\t\t     u32 flags,\n\t\t\t\t     struct ib_udata *udata,\n\t\t\t\t     struct net_device *xmit_slave)\n{\n\tstruct rdma_ah_init_attr init_attr = {};\n\tstruct ib_device *device = pd->device;\n\tstruct ib_ah *ah;\n\tint ret;\n\n\tmight_sleep_if(flags & RDMA_CREATE_AH_SLEEPABLE);\n\n\tif (!udata && !device->ops.create_ah)\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tah = rdma_zalloc_drv_obj_gfp(\n\t\tdevice, ib_ah,\n\t\t(flags & RDMA_CREATE_AH_SLEEPABLE) ? GFP_KERNEL : GFP_ATOMIC);\n\tif (!ah)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tah->device = device;\n\tah->pd = pd;\n\tah->type = ah_attr->type;\n\tah->sgid_attr = rdma_update_sgid_attr(ah_attr, NULL);\n\tinit_attr.ah_attr = ah_attr;\n\tinit_attr.flags = flags;\n\tinit_attr.xmit_slave = xmit_slave;\n\n\tif (udata)\n\t\tret = device->ops.create_user_ah(ah, &init_attr, udata);\n\telse\n\t\tret = device->ops.create_ah(ah, &init_attr, NULL);\n\tif (ret) {\n\t\tif (ah->sgid_attr)\n\t\t\trdma_put_gid_attr(ah->sgid_attr);\n\t\tkfree(ah);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tatomic_inc(&pd->usecnt);\n\treturn ah;\n}\n\n \nstruct ib_ah *rdma_create_ah(struct ib_pd *pd, struct rdma_ah_attr *ah_attr,\n\t\t\t     u32 flags)\n{\n\tconst struct ib_gid_attr *old_sgid_attr;\n\tstruct net_device *slave;\n\tstruct ib_ah *ah;\n\tint ret;\n\n\tret = rdma_fill_sgid_attr(pd->device, ah_attr, &old_sgid_attr);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\tslave = rdma_lag_get_ah_roce_slave(pd->device, ah_attr,\n\t\t\t\t\t   (flags & RDMA_CREATE_AH_SLEEPABLE) ?\n\t\t\t\t\t   GFP_KERNEL : GFP_ATOMIC);\n\tif (IS_ERR(slave)) {\n\t\trdma_unfill_sgid_attr(ah_attr, old_sgid_attr);\n\t\treturn (void *)slave;\n\t}\n\tah = _rdma_create_ah(pd, ah_attr, flags, NULL, slave);\n\trdma_lag_put_ah_roce_slave(slave);\n\trdma_unfill_sgid_attr(ah_attr, old_sgid_attr);\n\treturn ah;\n}\nEXPORT_SYMBOL(rdma_create_ah);\n\n \nstruct ib_ah *rdma_create_user_ah(struct ib_pd *pd,\n\t\t\t\t  struct rdma_ah_attr *ah_attr,\n\t\t\t\t  struct ib_udata *udata)\n{\n\tconst struct ib_gid_attr *old_sgid_attr;\n\tstruct ib_ah *ah;\n\tint err;\n\n\terr = rdma_fill_sgid_attr(pd->device, ah_attr, &old_sgid_attr);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tif (ah_attr->type == RDMA_AH_ATTR_TYPE_ROCE) {\n\t\terr = ib_resolve_eth_dmac(pd->device, ah_attr);\n\t\tif (err) {\n\t\t\tah = ERR_PTR(err);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tah = _rdma_create_ah(pd, ah_attr, RDMA_CREATE_AH_SLEEPABLE,\n\t\t\t     udata, NULL);\n\nout:\n\trdma_unfill_sgid_attr(ah_attr, old_sgid_attr);\n\treturn ah;\n}\nEXPORT_SYMBOL(rdma_create_user_ah);\n\nint ib_get_rdma_header_version(const union rdma_network_hdr *hdr)\n{\n\tconst struct iphdr *ip4h = (struct iphdr *)&hdr->roce4grh;\n\tstruct iphdr ip4h_checked;\n\tconst struct ipv6hdr *ip6h = (struct ipv6hdr *)&hdr->ibgrh;\n\n\t \n\tif (ip6h->version != 6)\n\t\treturn (ip4h->version == 4) ? 4 : 0;\n\t \n\n\t \n\tif (ip4h->ihl != 5)\n\t\treturn 6;\n\n\t \n\tmemcpy(&ip4h_checked, ip4h, sizeof(ip4h_checked));\n\tip4h_checked.check = 0;\n\tip4h_checked.check = ip_fast_csum((u8 *)&ip4h_checked, 5);\n\t \n\tif (ip4h->check == ip4h_checked.check)\n\t\treturn 4;\n\treturn 6;\n}\nEXPORT_SYMBOL(ib_get_rdma_header_version);\n\nstatic enum rdma_network_type ib_get_net_type_by_grh(struct ib_device *device,\n\t\t\t\t\t\t     u32 port_num,\n\t\t\t\t\t\t     const struct ib_grh *grh)\n{\n\tint grh_version;\n\n\tif (rdma_protocol_ib(device, port_num))\n\t\treturn RDMA_NETWORK_IB;\n\n\tgrh_version = ib_get_rdma_header_version((union rdma_network_hdr *)grh);\n\n\tif (grh_version == 4)\n\t\treturn RDMA_NETWORK_IPV4;\n\n\tif (grh->next_hdr == IPPROTO_UDP)\n\t\treturn RDMA_NETWORK_IPV6;\n\n\treturn RDMA_NETWORK_ROCE_V1;\n}\n\nstruct find_gid_index_context {\n\tu16 vlan_id;\n\tenum ib_gid_type gid_type;\n};\n\nstatic bool find_gid_index(const union ib_gid *gid,\n\t\t\t   const struct ib_gid_attr *gid_attr,\n\t\t\t   void *context)\n{\n\tstruct find_gid_index_context *ctx = context;\n\tu16 vlan_id = 0xffff;\n\tint ret;\n\n\tif (ctx->gid_type != gid_attr->gid_type)\n\t\treturn false;\n\n\tret = rdma_read_gid_l2_fields(gid_attr, &vlan_id, NULL);\n\tif (ret)\n\t\treturn false;\n\n\treturn ctx->vlan_id == vlan_id;\n}\n\nstatic const struct ib_gid_attr *\nget_sgid_attr_from_eth(struct ib_device *device, u32 port_num,\n\t\t       u16 vlan_id, const union ib_gid *sgid,\n\t\t       enum ib_gid_type gid_type)\n{\n\tstruct find_gid_index_context context = {.vlan_id = vlan_id,\n\t\t\t\t\t\t .gid_type = gid_type};\n\n\treturn rdma_find_gid_by_filter(device, sgid, port_num, find_gid_index,\n\t\t\t\t       &context);\n}\n\nint ib_get_gids_from_rdma_hdr(const union rdma_network_hdr *hdr,\n\t\t\t      enum rdma_network_type net_type,\n\t\t\t      union ib_gid *sgid, union ib_gid *dgid)\n{\n\tstruct sockaddr_in  src_in;\n\tstruct sockaddr_in  dst_in;\n\t__be32 src_saddr, dst_saddr;\n\n\tif (!sgid || !dgid)\n\t\treturn -EINVAL;\n\n\tif (net_type == RDMA_NETWORK_IPV4) {\n\t\tmemcpy(&src_in.sin_addr.s_addr,\n\t\t       &hdr->roce4grh.saddr, 4);\n\t\tmemcpy(&dst_in.sin_addr.s_addr,\n\t\t       &hdr->roce4grh.daddr, 4);\n\t\tsrc_saddr = src_in.sin_addr.s_addr;\n\t\tdst_saddr = dst_in.sin_addr.s_addr;\n\t\tipv6_addr_set_v4mapped(src_saddr,\n\t\t\t\t       (struct in6_addr *)sgid);\n\t\tipv6_addr_set_v4mapped(dst_saddr,\n\t\t\t\t       (struct in6_addr *)dgid);\n\t\treturn 0;\n\t} else if (net_type == RDMA_NETWORK_IPV6 ||\n\t\t   net_type == RDMA_NETWORK_IB || RDMA_NETWORK_ROCE_V1) {\n\t\t*dgid = hdr->ibgrh.dgid;\n\t\t*sgid = hdr->ibgrh.sgid;\n\t\treturn 0;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n}\nEXPORT_SYMBOL(ib_get_gids_from_rdma_hdr);\n\n \nstatic int ib_resolve_unicast_gid_dmac(struct ib_device *device,\n\t\t\t\t       struct rdma_ah_attr *ah_attr)\n{\n\tstruct ib_global_route *grh = rdma_ah_retrieve_grh(ah_attr);\n\tconst struct ib_gid_attr *sgid_attr = grh->sgid_attr;\n\tint hop_limit = 0xff;\n\tint ret = 0;\n\n\t \n\tif (rdma_link_local_addr((struct in6_addr *)grh->dgid.raw) &&\n\t    sgid_attr->gid_type == IB_GID_TYPE_ROCE) {\n\t\trdma_get_ll_mac((struct in6_addr *)grh->dgid.raw,\n\t\t\t\tah_attr->roce.dmac);\n\t\treturn ret;\n\t}\n\n\tret = rdma_addr_find_l2_eth_by_grh(&sgid_attr->gid, &grh->dgid,\n\t\t\t\t\t   ah_attr->roce.dmac,\n\t\t\t\t\t   sgid_attr, &hop_limit);\n\n\tgrh->hop_limit = hop_limit;\n\treturn ret;\n}\n\n \nint ib_init_ah_attr_from_wc(struct ib_device *device, u32 port_num,\n\t\t\t    const struct ib_wc *wc, const struct ib_grh *grh,\n\t\t\t    struct rdma_ah_attr *ah_attr)\n{\n\tu32 flow_class;\n\tint ret;\n\tenum rdma_network_type net_type = RDMA_NETWORK_IB;\n\tenum ib_gid_type gid_type = IB_GID_TYPE_IB;\n\tconst struct ib_gid_attr *sgid_attr;\n\tint hoplimit = 0xff;\n\tunion ib_gid dgid;\n\tunion ib_gid sgid;\n\n\tmight_sleep();\n\n\tmemset(ah_attr, 0, sizeof *ah_attr);\n\tah_attr->type = rdma_ah_find_type(device, port_num);\n\tif (rdma_cap_eth_ah(device, port_num)) {\n\t\tif (wc->wc_flags & IB_WC_WITH_NETWORK_HDR_TYPE)\n\t\t\tnet_type = wc->network_hdr_type;\n\t\telse\n\t\t\tnet_type = ib_get_net_type_by_grh(device, port_num, grh);\n\t\tgid_type = ib_network_to_gid_type(net_type);\n\t}\n\tret = ib_get_gids_from_rdma_hdr((union rdma_network_hdr *)grh, net_type,\n\t\t\t\t\t&sgid, &dgid);\n\tif (ret)\n\t\treturn ret;\n\n\trdma_ah_set_sl(ah_attr, wc->sl);\n\trdma_ah_set_port_num(ah_attr, port_num);\n\n\tif (rdma_protocol_roce(device, port_num)) {\n\t\tu16 vlan_id = wc->wc_flags & IB_WC_WITH_VLAN ?\n\t\t\t\twc->vlan_id : 0xffff;\n\n\t\tif (!(wc->wc_flags & IB_WC_GRH))\n\t\t\treturn -EPROTOTYPE;\n\n\t\tsgid_attr = get_sgid_attr_from_eth(device, port_num,\n\t\t\t\t\t\t   vlan_id, &dgid,\n\t\t\t\t\t\t   gid_type);\n\t\tif (IS_ERR(sgid_attr))\n\t\t\treturn PTR_ERR(sgid_attr);\n\n\t\tflow_class = be32_to_cpu(grh->version_tclass_flow);\n\t\trdma_move_grh_sgid_attr(ah_attr,\n\t\t\t\t\t&sgid,\n\t\t\t\t\tflow_class & 0xFFFFF,\n\t\t\t\t\thoplimit,\n\t\t\t\t\t(flow_class >> 20) & 0xFF,\n\t\t\t\t\tsgid_attr);\n\n\t\tret = ib_resolve_unicast_gid_dmac(device, ah_attr);\n\t\tif (ret)\n\t\t\trdma_destroy_ah_attr(ah_attr);\n\n\t\treturn ret;\n\t} else {\n\t\trdma_ah_set_dlid(ah_attr, wc->slid);\n\t\trdma_ah_set_path_bits(ah_attr, wc->dlid_path_bits);\n\n\t\tif ((wc->wc_flags & IB_WC_GRH) == 0)\n\t\t\treturn 0;\n\n\t\tif (dgid.global.interface_id !=\n\t\t\t\t\tcpu_to_be64(IB_SA_WELL_KNOWN_GUID)) {\n\t\t\tsgid_attr = rdma_find_gid_by_port(\n\t\t\t\tdevice, &dgid, IB_GID_TYPE_IB, port_num, NULL);\n\t\t} else\n\t\t\tsgid_attr = rdma_get_gid_attr(device, port_num, 0);\n\n\t\tif (IS_ERR(sgid_attr))\n\t\t\treturn PTR_ERR(sgid_attr);\n\t\tflow_class = be32_to_cpu(grh->version_tclass_flow);\n\t\trdma_move_grh_sgid_attr(ah_attr,\n\t\t\t\t\t&sgid,\n\t\t\t\t\tflow_class & 0xFFFFF,\n\t\t\t\t\thoplimit,\n\t\t\t\t\t(flow_class >> 20) & 0xFF,\n\t\t\t\t\tsgid_attr);\n\n\t\treturn 0;\n\t}\n}\nEXPORT_SYMBOL(ib_init_ah_attr_from_wc);\n\n \nvoid rdma_move_grh_sgid_attr(struct rdma_ah_attr *attr, union ib_gid *dgid,\n\t\t\t     u32 flow_label, u8 hop_limit, u8 traffic_class,\n\t\t\t     const struct ib_gid_attr *sgid_attr)\n{\n\trdma_ah_set_grh(attr, dgid, flow_label, sgid_attr->index, hop_limit,\n\t\t\ttraffic_class);\n\tattr->grh.sgid_attr = sgid_attr;\n}\nEXPORT_SYMBOL(rdma_move_grh_sgid_attr);\n\n \nvoid rdma_destroy_ah_attr(struct rdma_ah_attr *ah_attr)\n{\n\tif (ah_attr->grh.sgid_attr) {\n\t\trdma_put_gid_attr(ah_attr->grh.sgid_attr);\n\t\tah_attr->grh.sgid_attr = NULL;\n\t}\n}\nEXPORT_SYMBOL(rdma_destroy_ah_attr);\n\nstruct ib_ah *ib_create_ah_from_wc(struct ib_pd *pd, const struct ib_wc *wc,\n\t\t\t\t   const struct ib_grh *grh, u32 port_num)\n{\n\tstruct rdma_ah_attr ah_attr;\n\tstruct ib_ah *ah;\n\tint ret;\n\n\tret = ib_init_ah_attr_from_wc(pd->device, port_num, wc, grh, &ah_attr);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tah = rdma_create_ah(pd, &ah_attr, RDMA_CREATE_AH_SLEEPABLE);\n\n\trdma_destroy_ah_attr(&ah_attr);\n\treturn ah;\n}\nEXPORT_SYMBOL(ib_create_ah_from_wc);\n\nint rdma_modify_ah(struct ib_ah *ah, struct rdma_ah_attr *ah_attr)\n{\n\tconst struct ib_gid_attr *old_sgid_attr;\n\tint ret;\n\n\tif (ah->type != ah_attr->type)\n\t\treturn -EINVAL;\n\n\tret = rdma_fill_sgid_attr(ah->device, ah_attr, &old_sgid_attr);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ah->device->ops.modify_ah ?\n\t\tah->device->ops.modify_ah(ah, ah_attr) :\n\t\t-EOPNOTSUPP;\n\n\tah->sgid_attr = rdma_update_sgid_attr(ah_attr, ah->sgid_attr);\n\trdma_unfill_sgid_attr(ah_attr, old_sgid_attr);\n\treturn ret;\n}\nEXPORT_SYMBOL(rdma_modify_ah);\n\nint rdma_query_ah(struct ib_ah *ah, struct rdma_ah_attr *ah_attr)\n{\n\tah_attr->grh.sgid_attr = NULL;\n\n\treturn ah->device->ops.query_ah ?\n\t\tah->device->ops.query_ah(ah, ah_attr) :\n\t\t-EOPNOTSUPP;\n}\nEXPORT_SYMBOL(rdma_query_ah);\n\nint rdma_destroy_ah_user(struct ib_ah *ah, u32 flags, struct ib_udata *udata)\n{\n\tconst struct ib_gid_attr *sgid_attr = ah->sgid_attr;\n\tstruct ib_pd *pd;\n\tint ret;\n\n\tmight_sleep_if(flags & RDMA_DESTROY_AH_SLEEPABLE);\n\n\tpd = ah->pd;\n\n\tret = ah->device->ops.destroy_ah(ah, flags);\n\tif (ret)\n\t\treturn ret;\n\n\tatomic_dec(&pd->usecnt);\n\tif (sgid_attr)\n\t\trdma_put_gid_attr(sgid_attr);\n\n\tkfree(ah);\n\treturn ret;\n}\nEXPORT_SYMBOL(rdma_destroy_ah_user);\n\n \n\n \nstruct ib_srq *ib_create_srq_user(struct ib_pd *pd,\n\t\t\t\t  struct ib_srq_init_attr *srq_init_attr,\n\t\t\t\t  struct ib_usrq_object *uobject,\n\t\t\t\t  struct ib_udata *udata)\n{\n\tstruct ib_srq *srq;\n\tint ret;\n\n\tsrq = rdma_zalloc_drv_obj(pd->device, ib_srq);\n\tif (!srq)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tsrq->device = pd->device;\n\tsrq->pd = pd;\n\tsrq->event_handler = srq_init_attr->event_handler;\n\tsrq->srq_context = srq_init_attr->srq_context;\n\tsrq->srq_type = srq_init_attr->srq_type;\n\tsrq->uobject = uobject;\n\n\tif (ib_srq_has_cq(srq->srq_type)) {\n\t\tsrq->ext.cq = srq_init_attr->ext.cq;\n\t\tatomic_inc(&srq->ext.cq->usecnt);\n\t}\n\tif (srq->srq_type == IB_SRQT_XRC) {\n\t\tsrq->ext.xrc.xrcd = srq_init_attr->ext.xrc.xrcd;\n\t\tif (srq->ext.xrc.xrcd)\n\t\t\tatomic_inc(&srq->ext.xrc.xrcd->usecnt);\n\t}\n\tatomic_inc(&pd->usecnt);\n\n\trdma_restrack_new(&srq->res, RDMA_RESTRACK_SRQ);\n\trdma_restrack_parent_name(&srq->res, &pd->res);\n\n\tret = pd->device->ops.create_srq(srq, srq_init_attr, udata);\n\tif (ret) {\n\t\trdma_restrack_put(&srq->res);\n\t\tatomic_dec(&pd->usecnt);\n\t\tif (srq->srq_type == IB_SRQT_XRC && srq->ext.xrc.xrcd)\n\t\t\tatomic_dec(&srq->ext.xrc.xrcd->usecnt);\n\t\tif (ib_srq_has_cq(srq->srq_type))\n\t\t\tatomic_dec(&srq->ext.cq->usecnt);\n\t\tkfree(srq);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\trdma_restrack_add(&srq->res);\n\n\treturn srq;\n}\nEXPORT_SYMBOL(ib_create_srq_user);\n\nint ib_modify_srq(struct ib_srq *srq,\n\t\t  struct ib_srq_attr *srq_attr,\n\t\t  enum ib_srq_attr_mask srq_attr_mask)\n{\n\treturn srq->device->ops.modify_srq ?\n\t\tsrq->device->ops.modify_srq(srq, srq_attr, srq_attr_mask,\n\t\t\t\t\t    NULL) : -EOPNOTSUPP;\n}\nEXPORT_SYMBOL(ib_modify_srq);\n\nint ib_query_srq(struct ib_srq *srq,\n\t\t struct ib_srq_attr *srq_attr)\n{\n\treturn srq->device->ops.query_srq ?\n\t\tsrq->device->ops.query_srq(srq, srq_attr) : -EOPNOTSUPP;\n}\nEXPORT_SYMBOL(ib_query_srq);\n\nint ib_destroy_srq_user(struct ib_srq *srq, struct ib_udata *udata)\n{\n\tint ret;\n\n\tif (atomic_read(&srq->usecnt))\n\t\treturn -EBUSY;\n\n\tret = srq->device->ops.destroy_srq(srq, udata);\n\tif (ret)\n\t\treturn ret;\n\n\tatomic_dec(&srq->pd->usecnt);\n\tif (srq->srq_type == IB_SRQT_XRC && srq->ext.xrc.xrcd)\n\t\tatomic_dec(&srq->ext.xrc.xrcd->usecnt);\n\tif (ib_srq_has_cq(srq->srq_type))\n\t\tatomic_dec(&srq->ext.cq->usecnt);\n\trdma_restrack_del(&srq->res);\n\tkfree(srq);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(ib_destroy_srq_user);\n\n \n\nstatic void __ib_shared_qp_event_handler(struct ib_event *event, void *context)\n{\n\tstruct ib_qp *qp = context;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&qp->device->qp_open_list_lock, flags);\n\tlist_for_each_entry(event->element.qp, &qp->open_list, open_list)\n\t\tif (event->element.qp->event_handler)\n\t\t\tevent->element.qp->event_handler(event, event->element.qp->qp_context);\n\tspin_unlock_irqrestore(&qp->device->qp_open_list_lock, flags);\n}\n\nstatic struct ib_qp *__ib_open_qp(struct ib_qp *real_qp,\n\t\t\t\t  void (*event_handler)(struct ib_event *, void *),\n\t\t\t\t  void *qp_context)\n{\n\tstruct ib_qp *qp;\n\tunsigned long flags;\n\tint err;\n\n\tqp = kzalloc(sizeof *qp, GFP_KERNEL);\n\tif (!qp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tqp->real_qp = real_qp;\n\terr = ib_open_shared_qp_security(qp, real_qp->device);\n\tif (err) {\n\t\tkfree(qp);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tqp->real_qp = real_qp;\n\tatomic_inc(&real_qp->usecnt);\n\tqp->device = real_qp->device;\n\tqp->event_handler = event_handler;\n\tqp->qp_context = qp_context;\n\tqp->qp_num = real_qp->qp_num;\n\tqp->qp_type = real_qp->qp_type;\n\n\tspin_lock_irqsave(&real_qp->device->qp_open_list_lock, flags);\n\tlist_add(&qp->open_list, &real_qp->open_list);\n\tspin_unlock_irqrestore(&real_qp->device->qp_open_list_lock, flags);\n\n\treturn qp;\n}\n\nstruct ib_qp *ib_open_qp(struct ib_xrcd *xrcd,\n\t\t\t struct ib_qp_open_attr *qp_open_attr)\n{\n\tstruct ib_qp *qp, *real_qp;\n\n\tif (qp_open_attr->qp_type != IB_QPT_XRC_TGT)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdown_read(&xrcd->tgt_qps_rwsem);\n\treal_qp = xa_load(&xrcd->tgt_qps, qp_open_attr->qp_num);\n\tif (!real_qp) {\n\t\tup_read(&xrcd->tgt_qps_rwsem);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tqp = __ib_open_qp(real_qp, qp_open_attr->event_handler,\n\t\t\t  qp_open_attr->qp_context);\n\tup_read(&xrcd->tgt_qps_rwsem);\n\treturn qp;\n}\nEXPORT_SYMBOL(ib_open_qp);\n\nstatic struct ib_qp *create_xrc_qp_user(struct ib_qp *qp,\n\t\t\t\t\tstruct ib_qp_init_attr *qp_init_attr)\n{\n\tstruct ib_qp *real_qp = qp;\n\tint err;\n\n\tqp->event_handler = __ib_shared_qp_event_handler;\n\tqp->qp_context = qp;\n\tqp->pd = NULL;\n\tqp->send_cq = qp->recv_cq = NULL;\n\tqp->srq = NULL;\n\tqp->xrcd = qp_init_attr->xrcd;\n\tatomic_inc(&qp_init_attr->xrcd->usecnt);\n\tINIT_LIST_HEAD(&qp->open_list);\n\n\tqp = __ib_open_qp(real_qp, qp_init_attr->event_handler,\n\t\t\t  qp_init_attr->qp_context);\n\tif (IS_ERR(qp))\n\t\treturn qp;\n\n\terr = xa_err(xa_store(&qp_init_attr->xrcd->tgt_qps, real_qp->qp_num,\n\t\t\t      real_qp, GFP_KERNEL));\n\tif (err) {\n\t\tib_close_qp(qp);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn qp;\n}\n\nstatic struct ib_qp *create_qp(struct ib_device *dev, struct ib_pd *pd,\n\t\t\t       struct ib_qp_init_attr *attr,\n\t\t\t       struct ib_udata *udata,\n\t\t\t       struct ib_uqp_object *uobj, const char *caller)\n{\n\tstruct ib_udata dummy = {};\n\tstruct ib_qp *qp;\n\tint ret;\n\n\tif (!dev->ops.create_qp)\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tqp = rdma_zalloc_drv_obj_numa(dev, ib_qp);\n\tif (!qp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tqp->device = dev;\n\tqp->pd = pd;\n\tqp->uobject = uobj;\n\tqp->real_qp = qp;\n\n\tqp->qp_type = attr->qp_type;\n\tqp->rwq_ind_tbl = attr->rwq_ind_tbl;\n\tqp->srq = attr->srq;\n\tqp->event_handler = attr->event_handler;\n\tqp->port = attr->port_num;\n\tqp->qp_context = attr->qp_context;\n\n\tspin_lock_init(&qp->mr_lock);\n\tINIT_LIST_HEAD(&qp->rdma_mrs);\n\tINIT_LIST_HEAD(&qp->sig_mrs);\n\n\tqp->send_cq = attr->send_cq;\n\tqp->recv_cq = attr->recv_cq;\n\n\trdma_restrack_new(&qp->res, RDMA_RESTRACK_QP);\n\tWARN_ONCE(!udata && !caller, \"Missing kernel QP owner\");\n\trdma_restrack_set_name(&qp->res, udata ? NULL : caller);\n\tret = dev->ops.create_qp(qp, attr, udata);\n\tif (ret)\n\t\tgoto err_create;\n\n\t \n\tqp->send_cq = attr->send_cq;\n\tqp->recv_cq = attr->recv_cq;\n\n\tret = ib_create_qp_security(qp, dev);\n\tif (ret)\n\t\tgoto err_security;\n\n\trdma_restrack_add(&qp->res);\n\treturn qp;\n\nerr_security:\n\tqp->device->ops.destroy_qp(qp, udata ? &dummy : NULL);\nerr_create:\n\trdma_restrack_put(&qp->res);\n\tkfree(qp);\n\treturn ERR_PTR(ret);\n\n}\n\n \nstruct ib_qp *ib_create_qp_user(struct ib_device *dev, struct ib_pd *pd,\n\t\t\t\tstruct ib_qp_init_attr *attr,\n\t\t\t\tstruct ib_udata *udata,\n\t\t\t\tstruct ib_uqp_object *uobj, const char *caller)\n{\n\tstruct ib_qp *qp, *xrc_qp;\n\n\tif (attr->qp_type == IB_QPT_XRC_TGT)\n\t\tqp = create_qp(dev, pd, attr, NULL, NULL, caller);\n\telse\n\t\tqp = create_qp(dev, pd, attr, udata, uobj, NULL);\n\tif (attr->qp_type != IB_QPT_XRC_TGT || IS_ERR(qp))\n\t\treturn qp;\n\n\txrc_qp = create_xrc_qp_user(qp, attr);\n\tif (IS_ERR(xrc_qp)) {\n\t\tib_destroy_qp(qp);\n\t\treturn xrc_qp;\n\t}\n\n\txrc_qp->uobject = uobj;\n\treturn xrc_qp;\n}\nEXPORT_SYMBOL(ib_create_qp_user);\n\nvoid ib_qp_usecnt_inc(struct ib_qp *qp)\n{\n\tif (qp->pd)\n\t\tatomic_inc(&qp->pd->usecnt);\n\tif (qp->send_cq)\n\t\tatomic_inc(&qp->send_cq->usecnt);\n\tif (qp->recv_cq)\n\t\tatomic_inc(&qp->recv_cq->usecnt);\n\tif (qp->srq)\n\t\tatomic_inc(&qp->srq->usecnt);\n\tif (qp->rwq_ind_tbl)\n\t\tatomic_inc(&qp->rwq_ind_tbl->usecnt);\n}\nEXPORT_SYMBOL(ib_qp_usecnt_inc);\n\nvoid ib_qp_usecnt_dec(struct ib_qp *qp)\n{\n\tif (qp->rwq_ind_tbl)\n\t\tatomic_dec(&qp->rwq_ind_tbl->usecnt);\n\tif (qp->srq)\n\t\tatomic_dec(&qp->srq->usecnt);\n\tif (qp->recv_cq)\n\t\tatomic_dec(&qp->recv_cq->usecnt);\n\tif (qp->send_cq)\n\t\tatomic_dec(&qp->send_cq->usecnt);\n\tif (qp->pd)\n\t\tatomic_dec(&qp->pd->usecnt);\n}\nEXPORT_SYMBOL(ib_qp_usecnt_dec);\n\nstruct ib_qp *ib_create_qp_kernel(struct ib_pd *pd,\n\t\t\t\t  struct ib_qp_init_attr *qp_init_attr,\n\t\t\t\t  const char *caller)\n{\n\tstruct ib_device *device = pd->device;\n\tstruct ib_qp *qp;\n\tint ret;\n\n\t \n\tif (qp_init_attr->cap.max_rdma_ctxs)\n\t\trdma_rw_init_qp(device, qp_init_attr);\n\n\tqp = create_qp(device, pd, qp_init_attr, NULL, NULL, caller);\n\tif (IS_ERR(qp))\n\t\treturn qp;\n\n\tib_qp_usecnt_inc(qp);\n\n\tif (qp_init_attr->cap.max_rdma_ctxs) {\n\t\tret = rdma_rw_init_mrs(qp, qp_init_attr);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\t \n\tqp->max_write_sge = qp_init_attr->cap.max_send_sge;\n\tqp->max_read_sge = min_t(u32, qp_init_attr->cap.max_send_sge,\n\t\t\t\t device->attrs.max_sge_rd);\n\tif (qp_init_attr->create_flags & IB_QP_CREATE_INTEGRITY_EN)\n\t\tqp->integrity_en = true;\n\n\treturn qp;\n\nerr:\n\tib_destroy_qp(qp);\n\treturn ERR_PTR(ret);\n\n}\nEXPORT_SYMBOL(ib_create_qp_kernel);\n\nstatic const struct {\n\tint\t\t\tvalid;\n\tenum ib_qp_attr_mask\treq_param[IB_QPT_MAX];\n\tenum ib_qp_attr_mask\topt_param[IB_QPT_MAX];\n} qp_state_table[IB_QPS_ERR + 1][IB_QPS_ERR + 1] = {\n\t[IB_QPS_RESET] = {\n\t\t[IB_QPS_RESET] = { .valid = 1 },\n\t\t[IB_QPS_INIT]  = {\n\t\t\t.valid = 1,\n\t\t\t.req_param = {\n\t\t\t\t[IB_QPT_UD]  = (IB_QP_PKEY_INDEX\t\t|\n\t\t\t\t\t\tIB_QP_PORT\t\t\t|\n\t\t\t\t\t\tIB_QP_QKEY),\n\t\t\t\t[IB_QPT_RAW_PACKET] = IB_QP_PORT,\n\t\t\t\t[IB_QPT_UC]  = (IB_QP_PKEY_INDEX\t\t|\n\t\t\t\t\t\tIB_QP_PORT\t\t\t|\n\t\t\t\t\t\tIB_QP_ACCESS_FLAGS),\n\t\t\t\t[IB_QPT_RC]  = (IB_QP_PKEY_INDEX\t\t|\n\t\t\t\t\t\tIB_QP_PORT\t\t\t|\n\t\t\t\t\t\tIB_QP_ACCESS_FLAGS),\n\t\t\t\t[IB_QPT_XRC_INI] = (IB_QP_PKEY_INDEX\t\t|\n\t\t\t\t\t\tIB_QP_PORT\t\t\t|\n\t\t\t\t\t\tIB_QP_ACCESS_FLAGS),\n\t\t\t\t[IB_QPT_XRC_TGT] = (IB_QP_PKEY_INDEX\t\t|\n\t\t\t\t\t\tIB_QP_PORT\t\t\t|\n\t\t\t\t\t\tIB_QP_ACCESS_FLAGS),\n\t\t\t\t[IB_QPT_SMI] = (IB_QP_PKEY_INDEX\t\t|\n\t\t\t\t\t\tIB_QP_QKEY),\n\t\t\t\t[IB_QPT_GSI] = (IB_QP_PKEY_INDEX\t\t|\n\t\t\t\t\t\tIB_QP_QKEY),\n\t\t\t}\n\t\t},\n\t},\n\t[IB_QPS_INIT]  = {\n\t\t[IB_QPS_RESET] = { .valid = 1 },\n\t\t[IB_QPS_ERR] =   { .valid = 1 },\n\t\t[IB_QPS_INIT]  = {\n\t\t\t.valid = 1,\n\t\t\t.opt_param = {\n\t\t\t\t[IB_QPT_UD]  = (IB_QP_PKEY_INDEX\t\t|\n\t\t\t\t\t\tIB_QP_PORT\t\t\t|\n\t\t\t\t\t\tIB_QP_QKEY),\n\t\t\t\t[IB_QPT_UC]  = (IB_QP_PKEY_INDEX\t\t|\n\t\t\t\t\t\tIB_QP_PORT\t\t\t|\n\t\t\t\t\t\tIB_QP_ACCESS_FLAGS),\n\t\t\t\t[IB_QPT_RC]  = (IB_QP_PKEY_INDEX\t\t|\n\t\t\t\t\t\tIB_QP_PORT\t\t\t|\n\t\t\t\t\t\tIB_QP_ACCESS_FLAGS),\n\t\t\t\t[IB_QPT_XRC_INI] = (IB_QP_PKEY_INDEX\t\t|\n\t\t\t\t\t\tIB_QP_PORT\t\t\t|\n\t\t\t\t\t\tIB_QP_ACCESS_FLAGS),\n\t\t\t\t[IB_QPT_XRC_TGT] = (IB_QP_PKEY_INDEX\t\t|\n\t\t\t\t\t\tIB_QP_PORT\t\t\t|\n\t\t\t\t\t\tIB_QP_ACCESS_FLAGS),\n\t\t\t\t[IB_QPT_SMI] = (IB_QP_PKEY_INDEX\t\t|\n\t\t\t\t\t\tIB_QP_QKEY),\n\t\t\t\t[IB_QPT_GSI] = (IB_QP_PKEY_INDEX\t\t|\n\t\t\t\t\t\tIB_QP_QKEY),\n\t\t\t}\n\t\t},\n\t\t[IB_QPS_RTR]   = {\n\t\t\t.valid = 1,\n\t\t\t.req_param = {\n\t\t\t\t[IB_QPT_UC]  = (IB_QP_AV\t\t\t|\n\t\t\t\t\t\tIB_QP_PATH_MTU\t\t\t|\n\t\t\t\t\t\tIB_QP_DEST_QPN\t\t\t|\n\t\t\t\t\t\tIB_QP_RQ_PSN),\n\t\t\t\t[IB_QPT_RC]  = (IB_QP_AV\t\t\t|\n\t\t\t\t\t\tIB_QP_PATH_MTU\t\t\t|\n\t\t\t\t\t\tIB_QP_DEST_QPN\t\t\t|\n\t\t\t\t\t\tIB_QP_RQ_PSN\t\t\t|\n\t\t\t\t\t\tIB_QP_MAX_DEST_RD_ATOMIC\t|\n\t\t\t\t\t\tIB_QP_MIN_RNR_TIMER),\n\t\t\t\t[IB_QPT_XRC_INI] = (IB_QP_AV\t\t\t|\n\t\t\t\t\t\tIB_QP_PATH_MTU\t\t\t|\n\t\t\t\t\t\tIB_QP_DEST_QPN\t\t\t|\n\t\t\t\t\t\tIB_QP_RQ_PSN),\n\t\t\t\t[IB_QPT_XRC_TGT] = (IB_QP_AV\t\t\t|\n\t\t\t\t\t\tIB_QP_PATH_MTU\t\t\t|\n\t\t\t\t\t\tIB_QP_DEST_QPN\t\t\t|\n\t\t\t\t\t\tIB_QP_RQ_PSN\t\t\t|\n\t\t\t\t\t\tIB_QP_MAX_DEST_RD_ATOMIC\t|\n\t\t\t\t\t\tIB_QP_MIN_RNR_TIMER),\n\t\t\t},\n\t\t\t.opt_param = {\n\t\t\t\t [IB_QPT_UD]  = (IB_QP_PKEY_INDEX\t\t|\n\t\t\t\t\t\t IB_QP_QKEY),\n\t\t\t\t [IB_QPT_UC]  = (IB_QP_ALT_PATH\t\t\t|\n\t\t\t\t\t\t IB_QP_ACCESS_FLAGS\t\t|\n\t\t\t\t\t\t IB_QP_PKEY_INDEX),\n\t\t\t\t [IB_QPT_RC]  = (IB_QP_ALT_PATH\t\t\t|\n\t\t\t\t\t\t IB_QP_ACCESS_FLAGS\t\t|\n\t\t\t\t\t\t IB_QP_PKEY_INDEX),\n\t\t\t\t [IB_QPT_XRC_INI] = (IB_QP_ALT_PATH\t\t|\n\t\t\t\t\t\t IB_QP_ACCESS_FLAGS\t\t|\n\t\t\t\t\t\t IB_QP_PKEY_INDEX),\n\t\t\t\t [IB_QPT_XRC_TGT] = (IB_QP_ALT_PATH\t\t|\n\t\t\t\t\t\t IB_QP_ACCESS_FLAGS\t\t|\n\t\t\t\t\t\t IB_QP_PKEY_INDEX),\n\t\t\t\t [IB_QPT_SMI] = (IB_QP_PKEY_INDEX\t\t|\n\t\t\t\t\t\t IB_QP_QKEY),\n\t\t\t\t [IB_QPT_GSI] = (IB_QP_PKEY_INDEX\t\t|\n\t\t\t\t\t\t IB_QP_QKEY),\n\t\t\t },\n\t\t},\n\t},\n\t[IB_QPS_RTR]   = {\n\t\t[IB_QPS_RESET] = { .valid = 1 },\n\t\t[IB_QPS_ERR] =   { .valid = 1 },\n\t\t[IB_QPS_RTS]   = {\n\t\t\t.valid = 1,\n\t\t\t.req_param = {\n\t\t\t\t[IB_QPT_UD]  = IB_QP_SQ_PSN,\n\t\t\t\t[IB_QPT_UC]  = IB_QP_SQ_PSN,\n\t\t\t\t[IB_QPT_RC]  = (IB_QP_TIMEOUT\t\t\t|\n\t\t\t\t\t\tIB_QP_RETRY_CNT\t\t\t|\n\t\t\t\t\t\tIB_QP_RNR_RETRY\t\t\t|\n\t\t\t\t\t\tIB_QP_SQ_PSN\t\t\t|\n\t\t\t\t\t\tIB_QP_MAX_QP_RD_ATOMIC),\n\t\t\t\t[IB_QPT_XRC_INI] = (IB_QP_TIMEOUT\t\t|\n\t\t\t\t\t\tIB_QP_RETRY_CNT\t\t\t|\n\t\t\t\t\t\tIB_QP_RNR_RETRY\t\t\t|\n\t\t\t\t\t\tIB_QP_SQ_PSN\t\t\t|\n\t\t\t\t\t\tIB_QP_MAX_QP_RD_ATOMIC),\n\t\t\t\t[IB_QPT_XRC_TGT] = (IB_QP_TIMEOUT\t\t|\n\t\t\t\t\t\tIB_QP_SQ_PSN),\n\t\t\t\t[IB_QPT_SMI] = IB_QP_SQ_PSN,\n\t\t\t\t[IB_QPT_GSI] = IB_QP_SQ_PSN,\n\t\t\t},\n\t\t\t.opt_param = {\n\t\t\t\t [IB_QPT_UD]  = (IB_QP_CUR_STATE\t\t|\n\t\t\t\t\t\t IB_QP_QKEY),\n\t\t\t\t [IB_QPT_UC]  = (IB_QP_CUR_STATE\t\t|\n\t\t\t\t\t\t IB_QP_ALT_PATH\t\t\t|\n\t\t\t\t\t\t IB_QP_ACCESS_FLAGS\t\t|\n\t\t\t\t\t\t IB_QP_PATH_MIG_STATE),\n\t\t\t\t [IB_QPT_RC]  = (IB_QP_CUR_STATE\t\t|\n\t\t\t\t\t\t IB_QP_ALT_PATH\t\t\t|\n\t\t\t\t\t\t IB_QP_ACCESS_FLAGS\t\t|\n\t\t\t\t\t\t IB_QP_MIN_RNR_TIMER\t\t|\n\t\t\t\t\t\t IB_QP_PATH_MIG_STATE),\n\t\t\t\t [IB_QPT_XRC_INI] = (IB_QP_CUR_STATE\t\t|\n\t\t\t\t\t\t IB_QP_ALT_PATH\t\t\t|\n\t\t\t\t\t\t IB_QP_ACCESS_FLAGS\t\t|\n\t\t\t\t\t\t IB_QP_PATH_MIG_STATE),\n\t\t\t\t [IB_QPT_XRC_TGT] = (IB_QP_CUR_STATE\t\t|\n\t\t\t\t\t\t IB_QP_ALT_PATH\t\t\t|\n\t\t\t\t\t\t IB_QP_ACCESS_FLAGS\t\t|\n\t\t\t\t\t\t IB_QP_MIN_RNR_TIMER\t\t|\n\t\t\t\t\t\t IB_QP_PATH_MIG_STATE),\n\t\t\t\t [IB_QPT_SMI] = (IB_QP_CUR_STATE\t\t|\n\t\t\t\t\t\t IB_QP_QKEY),\n\t\t\t\t [IB_QPT_GSI] = (IB_QP_CUR_STATE\t\t|\n\t\t\t\t\t\t IB_QP_QKEY),\n\t\t\t\t [IB_QPT_RAW_PACKET] = IB_QP_RATE_LIMIT,\n\t\t\t }\n\t\t}\n\t},\n\t[IB_QPS_RTS]   = {\n\t\t[IB_QPS_RESET] = { .valid = 1 },\n\t\t[IB_QPS_ERR] =   { .valid = 1 },\n\t\t[IB_QPS_RTS]   = {\n\t\t\t.valid = 1,\n\t\t\t.opt_param = {\n\t\t\t\t[IB_QPT_UD]  = (IB_QP_CUR_STATE\t\t\t|\n\t\t\t\t\t\tIB_QP_QKEY),\n\t\t\t\t[IB_QPT_UC]  = (IB_QP_CUR_STATE\t\t\t|\n\t\t\t\t\t\tIB_QP_ACCESS_FLAGS\t\t|\n\t\t\t\t\t\tIB_QP_ALT_PATH\t\t\t|\n\t\t\t\t\t\tIB_QP_PATH_MIG_STATE),\n\t\t\t\t[IB_QPT_RC]  = (IB_QP_CUR_STATE\t\t\t|\n\t\t\t\t\t\tIB_QP_ACCESS_FLAGS\t\t|\n\t\t\t\t\t\tIB_QP_ALT_PATH\t\t\t|\n\t\t\t\t\t\tIB_QP_PATH_MIG_STATE\t\t|\n\t\t\t\t\t\tIB_QP_MIN_RNR_TIMER),\n\t\t\t\t[IB_QPT_XRC_INI] = (IB_QP_CUR_STATE\t\t|\n\t\t\t\t\t\tIB_QP_ACCESS_FLAGS\t\t|\n\t\t\t\t\t\tIB_QP_ALT_PATH\t\t\t|\n\t\t\t\t\t\tIB_QP_PATH_MIG_STATE),\n\t\t\t\t[IB_QPT_XRC_TGT] = (IB_QP_CUR_STATE\t\t|\n\t\t\t\t\t\tIB_QP_ACCESS_FLAGS\t\t|\n\t\t\t\t\t\tIB_QP_ALT_PATH\t\t\t|\n\t\t\t\t\t\tIB_QP_PATH_MIG_STATE\t\t|\n\t\t\t\t\t\tIB_QP_MIN_RNR_TIMER),\n\t\t\t\t[IB_QPT_SMI] = (IB_QP_CUR_STATE\t\t\t|\n\t\t\t\t\t\tIB_QP_QKEY),\n\t\t\t\t[IB_QPT_GSI] = (IB_QP_CUR_STATE\t\t\t|\n\t\t\t\t\t\tIB_QP_QKEY),\n\t\t\t\t[IB_QPT_RAW_PACKET] = IB_QP_RATE_LIMIT,\n\t\t\t}\n\t\t},\n\t\t[IB_QPS_SQD]   = {\n\t\t\t.valid = 1,\n\t\t\t.opt_param = {\n\t\t\t\t[IB_QPT_UD]  = IB_QP_EN_SQD_ASYNC_NOTIFY,\n\t\t\t\t[IB_QPT_UC]  = IB_QP_EN_SQD_ASYNC_NOTIFY,\n\t\t\t\t[IB_QPT_RC]  = IB_QP_EN_SQD_ASYNC_NOTIFY,\n\t\t\t\t[IB_QPT_XRC_INI] = IB_QP_EN_SQD_ASYNC_NOTIFY,\n\t\t\t\t[IB_QPT_XRC_TGT] = IB_QP_EN_SQD_ASYNC_NOTIFY,  \n\t\t\t\t[IB_QPT_SMI] = IB_QP_EN_SQD_ASYNC_NOTIFY,\n\t\t\t\t[IB_QPT_GSI] = IB_QP_EN_SQD_ASYNC_NOTIFY\n\t\t\t}\n\t\t},\n\t},\n\t[IB_QPS_SQD]   = {\n\t\t[IB_QPS_RESET] = { .valid = 1 },\n\t\t[IB_QPS_ERR] =   { .valid = 1 },\n\t\t[IB_QPS_RTS]   = {\n\t\t\t.valid = 1,\n\t\t\t.opt_param = {\n\t\t\t\t[IB_QPT_UD]  = (IB_QP_CUR_STATE\t\t\t|\n\t\t\t\t\t\tIB_QP_QKEY),\n\t\t\t\t[IB_QPT_UC]  = (IB_QP_CUR_STATE\t\t\t|\n\t\t\t\t\t\tIB_QP_ALT_PATH\t\t\t|\n\t\t\t\t\t\tIB_QP_ACCESS_FLAGS\t\t|\n\t\t\t\t\t\tIB_QP_PATH_MIG_STATE),\n\t\t\t\t[IB_QPT_RC]  = (IB_QP_CUR_STATE\t\t\t|\n\t\t\t\t\t\tIB_QP_ALT_PATH\t\t\t|\n\t\t\t\t\t\tIB_QP_ACCESS_FLAGS\t\t|\n\t\t\t\t\t\tIB_QP_MIN_RNR_TIMER\t\t|\n\t\t\t\t\t\tIB_QP_PATH_MIG_STATE),\n\t\t\t\t[IB_QPT_XRC_INI] = (IB_QP_CUR_STATE\t\t|\n\t\t\t\t\t\tIB_QP_ALT_PATH\t\t\t|\n\t\t\t\t\t\tIB_QP_ACCESS_FLAGS\t\t|\n\t\t\t\t\t\tIB_QP_PATH_MIG_STATE),\n\t\t\t\t[IB_QPT_XRC_TGT] = (IB_QP_CUR_STATE\t\t|\n\t\t\t\t\t\tIB_QP_ALT_PATH\t\t\t|\n\t\t\t\t\t\tIB_QP_ACCESS_FLAGS\t\t|\n\t\t\t\t\t\tIB_QP_MIN_RNR_TIMER\t\t|\n\t\t\t\t\t\tIB_QP_PATH_MIG_STATE),\n\t\t\t\t[IB_QPT_SMI] = (IB_QP_CUR_STATE\t\t\t|\n\t\t\t\t\t\tIB_QP_QKEY),\n\t\t\t\t[IB_QPT_GSI] = (IB_QP_CUR_STATE\t\t\t|\n\t\t\t\t\t\tIB_QP_QKEY),\n\t\t\t}\n\t\t},\n\t\t[IB_QPS_SQD]   = {\n\t\t\t.valid = 1,\n\t\t\t.opt_param = {\n\t\t\t\t[IB_QPT_UD]  = (IB_QP_PKEY_INDEX\t\t|\n\t\t\t\t\t\tIB_QP_QKEY),\n\t\t\t\t[IB_QPT_UC]  = (IB_QP_AV\t\t\t|\n\t\t\t\t\t\tIB_QP_ALT_PATH\t\t\t|\n\t\t\t\t\t\tIB_QP_ACCESS_FLAGS\t\t|\n\t\t\t\t\t\tIB_QP_PKEY_INDEX\t\t|\n\t\t\t\t\t\tIB_QP_PATH_MIG_STATE),\n\t\t\t\t[IB_QPT_RC]  = (IB_QP_PORT\t\t\t|\n\t\t\t\t\t\tIB_QP_AV\t\t\t|\n\t\t\t\t\t\tIB_QP_TIMEOUT\t\t\t|\n\t\t\t\t\t\tIB_QP_RETRY_CNT\t\t\t|\n\t\t\t\t\t\tIB_QP_RNR_RETRY\t\t\t|\n\t\t\t\t\t\tIB_QP_MAX_QP_RD_ATOMIC\t\t|\n\t\t\t\t\t\tIB_QP_MAX_DEST_RD_ATOMIC\t|\n\t\t\t\t\t\tIB_QP_ALT_PATH\t\t\t|\n\t\t\t\t\t\tIB_QP_ACCESS_FLAGS\t\t|\n\t\t\t\t\t\tIB_QP_PKEY_INDEX\t\t|\n\t\t\t\t\t\tIB_QP_MIN_RNR_TIMER\t\t|\n\t\t\t\t\t\tIB_QP_PATH_MIG_STATE),\n\t\t\t\t[IB_QPT_XRC_INI] = (IB_QP_PORT\t\t\t|\n\t\t\t\t\t\tIB_QP_AV\t\t\t|\n\t\t\t\t\t\tIB_QP_TIMEOUT\t\t\t|\n\t\t\t\t\t\tIB_QP_RETRY_CNT\t\t\t|\n\t\t\t\t\t\tIB_QP_RNR_RETRY\t\t\t|\n\t\t\t\t\t\tIB_QP_MAX_QP_RD_ATOMIC\t\t|\n\t\t\t\t\t\tIB_QP_ALT_PATH\t\t\t|\n\t\t\t\t\t\tIB_QP_ACCESS_FLAGS\t\t|\n\t\t\t\t\t\tIB_QP_PKEY_INDEX\t\t|\n\t\t\t\t\t\tIB_QP_PATH_MIG_STATE),\n\t\t\t\t[IB_QPT_XRC_TGT] = (IB_QP_PORT\t\t\t|\n\t\t\t\t\t\tIB_QP_AV\t\t\t|\n\t\t\t\t\t\tIB_QP_TIMEOUT\t\t\t|\n\t\t\t\t\t\tIB_QP_MAX_DEST_RD_ATOMIC\t|\n\t\t\t\t\t\tIB_QP_ALT_PATH\t\t\t|\n\t\t\t\t\t\tIB_QP_ACCESS_FLAGS\t\t|\n\t\t\t\t\t\tIB_QP_PKEY_INDEX\t\t|\n\t\t\t\t\t\tIB_QP_MIN_RNR_TIMER\t\t|\n\t\t\t\t\t\tIB_QP_PATH_MIG_STATE),\n\t\t\t\t[IB_QPT_SMI] = (IB_QP_PKEY_INDEX\t\t|\n\t\t\t\t\t\tIB_QP_QKEY),\n\t\t\t\t[IB_QPT_GSI] = (IB_QP_PKEY_INDEX\t\t|\n\t\t\t\t\t\tIB_QP_QKEY),\n\t\t\t}\n\t\t}\n\t},\n\t[IB_QPS_SQE]   = {\n\t\t[IB_QPS_RESET] = { .valid = 1 },\n\t\t[IB_QPS_ERR] =   { .valid = 1 },\n\t\t[IB_QPS_RTS]   = {\n\t\t\t.valid = 1,\n\t\t\t.opt_param = {\n\t\t\t\t[IB_QPT_UD]  = (IB_QP_CUR_STATE\t\t\t|\n\t\t\t\t\t\tIB_QP_QKEY),\n\t\t\t\t[IB_QPT_UC]  = (IB_QP_CUR_STATE\t\t\t|\n\t\t\t\t\t\tIB_QP_ACCESS_FLAGS),\n\t\t\t\t[IB_QPT_SMI] = (IB_QP_CUR_STATE\t\t\t|\n\t\t\t\t\t\tIB_QP_QKEY),\n\t\t\t\t[IB_QPT_GSI] = (IB_QP_CUR_STATE\t\t\t|\n\t\t\t\t\t\tIB_QP_QKEY),\n\t\t\t}\n\t\t}\n\t},\n\t[IB_QPS_ERR] = {\n\t\t[IB_QPS_RESET] = { .valid = 1 },\n\t\t[IB_QPS_ERR] =   { .valid = 1 }\n\t}\n};\n\nbool ib_modify_qp_is_ok(enum ib_qp_state cur_state, enum ib_qp_state next_state,\n\t\t\tenum ib_qp_type type, enum ib_qp_attr_mask mask)\n{\n\tenum ib_qp_attr_mask req_param, opt_param;\n\n\tif (mask & IB_QP_CUR_STATE  &&\n\t    cur_state != IB_QPS_RTR && cur_state != IB_QPS_RTS &&\n\t    cur_state != IB_QPS_SQD && cur_state != IB_QPS_SQE)\n\t\treturn false;\n\n\tif (!qp_state_table[cur_state][next_state].valid)\n\t\treturn false;\n\n\treq_param = qp_state_table[cur_state][next_state].req_param[type];\n\topt_param = qp_state_table[cur_state][next_state].opt_param[type];\n\n\tif ((mask & req_param) != req_param)\n\t\treturn false;\n\n\tif (mask & ~(req_param | opt_param | IB_QP_STATE))\n\t\treturn false;\n\n\treturn true;\n}\nEXPORT_SYMBOL(ib_modify_qp_is_ok);\n\n \nstatic int ib_resolve_eth_dmac(struct ib_device *device,\n\t\t\t       struct rdma_ah_attr *ah_attr)\n{\n\tint ret = 0;\n\n\tif (rdma_is_multicast_addr((struct in6_addr *)ah_attr->grh.dgid.raw)) {\n\t\tif (ipv6_addr_v4mapped((struct in6_addr *)ah_attr->grh.dgid.raw)) {\n\t\t\t__be32 addr = 0;\n\n\t\t\tmemcpy(&addr, ah_attr->grh.dgid.raw + 12, 4);\n\t\t\tip_eth_mc_map(addr, (char *)ah_attr->roce.dmac);\n\t\t} else {\n\t\t\tipv6_eth_mc_map((struct in6_addr *)ah_attr->grh.dgid.raw,\n\t\t\t\t\t(char *)ah_attr->roce.dmac);\n\t\t}\n\t} else {\n\t\tret = ib_resolve_unicast_gid_dmac(device, ah_attr);\n\t}\n\treturn ret;\n}\n\nstatic bool is_qp_type_connected(const struct ib_qp *qp)\n{\n\treturn (qp->qp_type == IB_QPT_UC ||\n\t\tqp->qp_type == IB_QPT_RC ||\n\t\tqp->qp_type == IB_QPT_XRC_INI ||\n\t\tqp->qp_type == IB_QPT_XRC_TGT);\n}\n\n \nstatic int _ib_modify_qp(struct ib_qp *qp, struct ib_qp_attr *attr,\n\t\t\t int attr_mask, struct ib_udata *udata)\n{\n\tu32 port = attr_mask & IB_QP_PORT ? attr->port_num : qp->port;\n\tconst struct ib_gid_attr *old_sgid_attr_av;\n\tconst struct ib_gid_attr *old_sgid_attr_alt_av;\n\tint ret;\n\n\tattr->xmit_slave = NULL;\n\tif (attr_mask & IB_QP_AV) {\n\t\tret = rdma_fill_sgid_attr(qp->device, &attr->ah_attr,\n\t\t\t\t\t  &old_sgid_attr_av);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (attr->ah_attr.type == RDMA_AH_ATTR_TYPE_ROCE &&\n\t\t    is_qp_type_connected(qp)) {\n\t\t\tstruct net_device *slave;\n\n\t\t\t \n\t\t\tif (udata) {\n\t\t\t\tret = ib_resolve_eth_dmac(qp->device,\n\t\t\t\t\t\t\t  &attr->ah_attr);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out_av;\n\t\t\t}\n\t\t\tslave = rdma_lag_get_ah_roce_slave(qp->device,\n\t\t\t\t\t\t\t   &attr->ah_attr,\n\t\t\t\t\t\t\t   GFP_KERNEL);\n\t\t\tif (IS_ERR(slave)) {\n\t\t\t\tret = PTR_ERR(slave);\n\t\t\t\tgoto out_av;\n\t\t\t}\n\t\t\tattr->xmit_slave = slave;\n\t\t}\n\t}\n\tif (attr_mask & IB_QP_ALT_PATH) {\n\t\t \n\t\tret = rdma_fill_sgid_attr(qp->device, &attr->alt_ah_attr,\n\t\t\t\t\t  &old_sgid_attr_alt_av);\n\t\tif (ret)\n\t\t\tgoto out_av;\n\n\t\t \n\t\tif (!(rdma_protocol_ib(qp->device,\n\t\t\t\t       attr->alt_ah_attr.port_num) &&\n\t\t      rdma_protocol_ib(qp->device, port))) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (rdma_ib_or_roce(qp->device, port)) {\n\t\tif (attr_mask & IB_QP_RQ_PSN && attr->rq_psn & ~0xffffff) {\n\t\t\tdev_warn(&qp->device->dev,\n\t\t\t\t \"%s rq_psn overflow, masking to 24 bits\\n\",\n\t\t\t\t __func__);\n\t\t\tattr->rq_psn &= 0xffffff;\n\t\t}\n\n\t\tif (attr_mask & IB_QP_SQ_PSN && attr->sq_psn & ~0xffffff) {\n\t\t\tdev_warn(&qp->device->dev,\n\t\t\t\t \" %s sq_psn overflow, masking to 24 bits\\n\",\n\t\t\t\t __func__);\n\t\t\tattr->sq_psn &= 0xffffff;\n\t\t}\n\t}\n\n\t \n\tif (!qp->counter && (attr_mask & IB_QP_PORT) &&\n\t    ((attr_mask & IB_QP_STATE) && attr->qp_state == IB_QPS_INIT))\n\t\trdma_counter_bind_qp_auto(qp, attr->port_num);\n\n\tret = ib_security_modify_qp(qp, attr, attr_mask, udata);\n\tif (ret)\n\t\tgoto out;\n\n\tif (attr_mask & IB_QP_PORT)\n\t\tqp->port = attr->port_num;\n\tif (attr_mask & IB_QP_AV)\n\t\tqp->av_sgid_attr =\n\t\t\trdma_update_sgid_attr(&attr->ah_attr, qp->av_sgid_attr);\n\tif (attr_mask & IB_QP_ALT_PATH)\n\t\tqp->alt_path_sgid_attr = rdma_update_sgid_attr(\n\t\t\t&attr->alt_ah_attr, qp->alt_path_sgid_attr);\n\nout:\n\tif (attr_mask & IB_QP_ALT_PATH)\n\t\trdma_unfill_sgid_attr(&attr->alt_ah_attr, old_sgid_attr_alt_av);\nout_av:\n\tif (attr_mask & IB_QP_AV) {\n\t\trdma_lag_put_ah_roce_slave(attr->xmit_slave);\n\t\trdma_unfill_sgid_attr(&attr->ah_attr, old_sgid_attr_av);\n\t}\n\treturn ret;\n}\n\n \nint ib_modify_qp_with_udata(struct ib_qp *ib_qp, struct ib_qp_attr *attr,\n\t\t\t    int attr_mask, struct ib_udata *udata)\n{\n\treturn _ib_modify_qp(ib_qp->real_qp, attr, attr_mask, udata);\n}\nEXPORT_SYMBOL(ib_modify_qp_with_udata);\n\nstatic void ib_get_width_and_speed(u32 netdev_speed, u32 lanes,\n\t\t\t\t   u16 *speed, u8 *width)\n{\n\tif (!lanes) {\n\t\tif (netdev_speed <= SPEED_1000) {\n\t\t\t*width = IB_WIDTH_1X;\n\t\t\t*speed = IB_SPEED_SDR;\n\t\t} else if (netdev_speed <= SPEED_10000) {\n\t\t\t*width = IB_WIDTH_1X;\n\t\t\t*speed = IB_SPEED_FDR10;\n\t\t} else if (netdev_speed <= SPEED_20000) {\n\t\t\t*width = IB_WIDTH_4X;\n\t\t\t*speed = IB_SPEED_DDR;\n\t\t} else if (netdev_speed <= SPEED_25000) {\n\t\t\t*width = IB_WIDTH_1X;\n\t\t\t*speed = IB_SPEED_EDR;\n\t\t} else if (netdev_speed <= SPEED_40000) {\n\t\t\t*width = IB_WIDTH_4X;\n\t\t\t*speed = IB_SPEED_FDR10;\n\t\t} else if (netdev_speed <= SPEED_50000) {\n\t\t\t*width = IB_WIDTH_2X;\n\t\t\t*speed = IB_SPEED_EDR;\n\t\t} else if (netdev_speed <= SPEED_100000) {\n\t\t\t*width = IB_WIDTH_4X;\n\t\t\t*speed = IB_SPEED_EDR;\n\t\t} else if (netdev_speed <= SPEED_200000) {\n\t\t\t*width = IB_WIDTH_4X;\n\t\t\t*speed = IB_SPEED_HDR;\n\t\t} else {\n\t\t\t*width = IB_WIDTH_4X;\n\t\t\t*speed = IB_SPEED_NDR;\n\t\t}\n\n\t\treturn;\n\t}\n\n\tswitch (lanes) {\n\tcase 1:\n\t\t*width = IB_WIDTH_1X;\n\t\tbreak;\n\tcase 2:\n\t\t*width = IB_WIDTH_2X;\n\t\tbreak;\n\tcase 4:\n\t\t*width = IB_WIDTH_4X;\n\t\tbreak;\n\tcase 8:\n\t\t*width = IB_WIDTH_8X;\n\t\tbreak;\n\tcase 12:\n\t\t*width = IB_WIDTH_12X;\n\t\tbreak;\n\tdefault:\n\t\t*width = IB_WIDTH_1X;\n\t}\n\n\tswitch (netdev_speed / lanes) {\n\tcase SPEED_2500:\n\t\t*speed = IB_SPEED_SDR;\n\t\tbreak;\n\tcase SPEED_5000:\n\t\t*speed = IB_SPEED_DDR;\n\t\tbreak;\n\tcase SPEED_10000:\n\t\t*speed = IB_SPEED_FDR10;\n\t\tbreak;\n\tcase SPEED_14000:\n\t\t*speed = IB_SPEED_FDR;\n\t\tbreak;\n\tcase SPEED_25000:\n\t\t*speed = IB_SPEED_EDR;\n\t\tbreak;\n\tcase SPEED_50000:\n\t\t*speed = IB_SPEED_HDR;\n\t\tbreak;\n\tcase SPEED_100000:\n\t\t*speed = IB_SPEED_NDR;\n\t\tbreak;\n\tdefault:\n\t\t*speed = IB_SPEED_SDR;\n\t}\n}\n\nint ib_get_eth_speed(struct ib_device *dev, u32 port_num, u16 *speed, u8 *width)\n{\n\tint rc;\n\tu32 netdev_speed;\n\tstruct net_device *netdev;\n\tstruct ethtool_link_ksettings lksettings = {};\n\n\tif (rdma_port_get_link_layer(dev, port_num) != IB_LINK_LAYER_ETHERNET)\n\t\treturn -EINVAL;\n\n\tnetdev = ib_device_get_netdev(dev, port_num);\n\tif (!netdev)\n\t\treturn -ENODEV;\n\n\trtnl_lock();\n\trc = __ethtool_get_link_ksettings(netdev, &lksettings);\n\trtnl_unlock();\n\n\tdev_put(netdev);\n\n\tif (!rc && lksettings.base.speed != (u32)SPEED_UNKNOWN) {\n\t\tnetdev_speed = lksettings.base.speed;\n\t} else {\n\t\tnetdev_speed = SPEED_1000;\n\t\tif (rc)\n\t\t\tpr_warn(\"%s speed is unknown, defaulting to %u\\n\",\n\t\t\t\tnetdev->name, netdev_speed);\n\t}\n\n\tib_get_width_and_speed(netdev_speed, lksettings.lanes,\n\t\t\t       speed, width);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ib_get_eth_speed);\n\nint ib_modify_qp(struct ib_qp *qp,\n\t\t struct ib_qp_attr *qp_attr,\n\t\t int qp_attr_mask)\n{\n\treturn _ib_modify_qp(qp->real_qp, qp_attr, qp_attr_mask, NULL);\n}\nEXPORT_SYMBOL(ib_modify_qp);\n\nint ib_query_qp(struct ib_qp *qp,\n\t\tstruct ib_qp_attr *qp_attr,\n\t\tint qp_attr_mask,\n\t\tstruct ib_qp_init_attr *qp_init_attr)\n{\n\tqp_attr->ah_attr.grh.sgid_attr = NULL;\n\tqp_attr->alt_ah_attr.grh.sgid_attr = NULL;\n\n\treturn qp->device->ops.query_qp ?\n\t\tqp->device->ops.query_qp(qp->real_qp, qp_attr, qp_attr_mask,\n\t\t\t\t\t qp_init_attr) : -EOPNOTSUPP;\n}\nEXPORT_SYMBOL(ib_query_qp);\n\nint ib_close_qp(struct ib_qp *qp)\n{\n\tstruct ib_qp *real_qp;\n\tunsigned long flags;\n\n\treal_qp = qp->real_qp;\n\tif (real_qp == qp)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&real_qp->device->qp_open_list_lock, flags);\n\tlist_del(&qp->open_list);\n\tspin_unlock_irqrestore(&real_qp->device->qp_open_list_lock, flags);\n\n\tatomic_dec(&real_qp->usecnt);\n\tif (qp->qp_sec)\n\t\tib_close_shared_qp_security(qp->qp_sec);\n\tkfree(qp);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ib_close_qp);\n\nstatic int __ib_destroy_shared_qp(struct ib_qp *qp)\n{\n\tstruct ib_xrcd *xrcd;\n\tstruct ib_qp *real_qp;\n\tint ret;\n\n\treal_qp = qp->real_qp;\n\txrcd = real_qp->xrcd;\n\tdown_write(&xrcd->tgt_qps_rwsem);\n\tib_close_qp(qp);\n\tif (atomic_read(&real_qp->usecnt) == 0)\n\t\txa_erase(&xrcd->tgt_qps, real_qp->qp_num);\n\telse\n\t\treal_qp = NULL;\n\tup_write(&xrcd->tgt_qps_rwsem);\n\n\tif (real_qp) {\n\t\tret = ib_destroy_qp(real_qp);\n\t\tif (!ret)\n\t\t\tatomic_dec(&xrcd->usecnt);\n\t}\n\n\treturn 0;\n}\n\nint ib_destroy_qp_user(struct ib_qp *qp, struct ib_udata *udata)\n{\n\tconst struct ib_gid_attr *alt_path_sgid_attr = qp->alt_path_sgid_attr;\n\tconst struct ib_gid_attr *av_sgid_attr = qp->av_sgid_attr;\n\tstruct ib_qp_security *sec;\n\tint ret;\n\n\tWARN_ON_ONCE(qp->mrs_used > 0);\n\n\tif (atomic_read(&qp->usecnt))\n\t\treturn -EBUSY;\n\n\tif (qp->real_qp != qp)\n\t\treturn __ib_destroy_shared_qp(qp);\n\n\tsec  = qp->qp_sec;\n\tif (sec)\n\t\tib_destroy_qp_security_begin(sec);\n\n\tif (!qp->uobject)\n\t\trdma_rw_cleanup_mrs(qp);\n\n\trdma_counter_unbind_qp(qp, true);\n\tret = qp->device->ops.destroy_qp(qp, udata);\n\tif (ret) {\n\t\tif (sec)\n\t\t\tib_destroy_qp_security_abort(sec);\n\t\treturn ret;\n\t}\n\n\tif (alt_path_sgid_attr)\n\t\trdma_put_gid_attr(alt_path_sgid_attr);\n\tif (av_sgid_attr)\n\t\trdma_put_gid_attr(av_sgid_attr);\n\n\tib_qp_usecnt_dec(qp);\n\tif (sec)\n\t\tib_destroy_qp_security_end(sec);\n\n\trdma_restrack_del(&qp->res);\n\tkfree(qp);\n\treturn ret;\n}\nEXPORT_SYMBOL(ib_destroy_qp_user);\n\n \n\nstruct ib_cq *__ib_create_cq(struct ib_device *device,\n\t\t\t     ib_comp_handler comp_handler,\n\t\t\t     void (*event_handler)(struct ib_event *, void *),\n\t\t\t     void *cq_context,\n\t\t\t     const struct ib_cq_init_attr *cq_attr,\n\t\t\t     const char *caller)\n{\n\tstruct ib_cq *cq;\n\tint ret;\n\n\tcq = rdma_zalloc_drv_obj(device, ib_cq);\n\tif (!cq)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcq->device = device;\n\tcq->uobject = NULL;\n\tcq->comp_handler = comp_handler;\n\tcq->event_handler = event_handler;\n\tcq->cq_context = cq_context;\n\tatomic_set(&cq->usecnt, 0);\n\n\trdma_restrack_new(&cq->res, RDMA_RESTRACK_CQ);\n\trdma_restrack_set_name(&cq->res, caller);\n\n\tret = device->ops.create_cq(cq, cq_attr, NULL);\n\tif (ret) {\n\t\trdma_restrack_put(&cq->res);\n\t\tkfree(cq);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\trdma_restrack_add(&cq->res);\n\treturn cq;\n}\nEXPORT_SYMBOL(__ib_create_cq);\n\nint rdma_set_cq_moderation(struct ib_cq *cq, u16 cq_count, u16 cq_period)\n{\n\tif (cq->shared)\n\t\treturn -EOPNOTSUPP;\n\n\treturn cq->device->ops.modify_cq ?\n\t\tcq->device->ops.modify_cq(cq, cq_count,\n\t\t\t\t\t  cq_period) : -EOPNOTSUPP;\n}\nEXPORT_SYMBOL(rdma_set_cq_moderation);\n\nint ib_destroy_cq_user(struct ib_cq *cq, struct ib_udata *udata)\n{\n\tint ret;\n\n\tif (WARN_ON_ONCE(cq->shared))\n\t\treturn -EOPNOTSUPP;\n\n\tif (atomic_read(&cq->usecnt))\n\t\treturn -EBUSY;\n\n\tret = cq->device->ops.destroy_cq(cq, udata);\n\tif (ret)\n\t\treturn ret;\n\n\trdma_restrack_del(&cq->res);\n\tkfree(cq);\n\treturn ret;\n}\nEXPORT_SYMBOL(ib_destroy_cq_user);\n\nint ib_resize_cq(struct ib_cq *cq, int cqe)\n{\n\tif (cq->shared)\n\t\treturn -EOPNOTSUPP;\n\n\treturn cq->device->ops.resize_cq ?\n\t\tcq->device->ops.resize_cq(cq, cqe, NULL) : -EOPNOTSUPP;\n}\nEXPORT_SYMBOL(ib_resize_cq);\n\n \n\nstruct ib_mr *ib_reg_user_mr(struct ib_pd *pd, u64 start, u64 length,\n\t\t\t     u64 virt_addr, int access_flags)\n{\n\tstruct ib_mr *mr;\n\n\tif (access_flags & IB_ACCESS_ON_DEMAND) {\n\t\tif (!(pd->device->attrs.kernel_cap_flags &\n\t\t      IBK_ON_DEMAND_PAGING)) {\n\t\t\tpr_debug(\"ODP support not available\\n\");\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t}\n\n\tmr = pd->device->ops.reg_user_mr(pd, start, length, virt_addr,\n\t\t\t\t\t access_flags, NULL);\n\n\tif (IS_ERR(mr))\n\t\treturn mr;\n\n\tmr->device = pd->device;\n\tmr->type = IB_MR_TYPE_USER;\n\tmr->pd = pd;\n\tmr->dm = NULL;\n\tatomic_inc(&pd->usecnt);\n\tmr->iova =  virt_addr;\n\tmr->length = length;\n\n\trdma_restrack_new(&mr->res, RDMA_RESTRACK_MR);\n\trdma_restrack_parent_name(&mr->res, &pd->res);\n\trdma_restrack_add(&mr->res);\n\n\treturn mr;\n}\nEXPORT_SYMBOL(ib_reg_user_mr);\n\nint ib_advise_mr(struct ib_pd *pd, enum ib_uverbs_advise_mr_advice advice,\n\t\t u32 flags, struct ib_sge *sg_list, u32 num_sge)\n{\n\tif (!pd->device->ops.advise_mr)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!num_sge)\n\t\treturn 0;\n\n\treturn pd->device->ops.advise_mr(pd, advice, flags, sg_list, num_sge,\n\t\t\t\t\t NULL);\n}\nEXPORT_SYMBOL(ib_advise_mr);\n\nint ib_dereg_mr_user(struct ib_mr *mr, struct ib_udata *udata)\n{\n\tstruct ib_pd *pd = mr->pd;\n\tstruct ib_dm *dm = mr->dm;\n\tstruct ib_sig_attrs *sig_attrs = mr->sig_attrs;\n\tint ret;\n\n\ttrace_mr_dereg(mr);\n\trdma_restrack_del(&mr->res);\n\tret = mr->device->ops.dereg_mr(mr, udata);\n\tif (!ret) {\n\t\tatomic_dec(&pd->usecnt);\n\t\tif (dm)\n\t\t\tatomic_dec(&dm->usecnt);\n\t\tkfree(sig_attrs);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL(ib_dereg_mr_user);\n\n \nstruct ib_mr *ib_alloc_mr(struct ib_pd *pd, enum ib_mr_type mr_type,\n\t\t\t  u32 max_num_sg)\n{\n\tstruct ib_mr *mr;\n\n\tif (!pd->device->ops.alloc_mr) {\n\t\tmr = ERR_PTR(-EOPNOTSUPP);\n\t\tgoto out;\n\t}\n\n\tif (mr_type == IB_MR_TYPE_INTEGRITY) {\n\t\tWARN_ON_ONCE(1);\n\t\tmr = ERR_PTR(-EINVAL);\n\t\tgoto out;\n\t}\n\n\tmr = pd->device->ops.alloc_mr(pd, mr_type, max_num_sg);\n\tif (IS_ERR(mr))\n\t\tgoto out;\n\n\tmr->device = pd->device;\n\tmr->pd = pd;\n\tmr->dm = NULL;\n\tmr->uobject = NULL;\n\tatomic_inc(&pd->usecnt);\n\tmr->need_inval = false;\n\tmr->type = mr_type;\n\tmr->sig_attrs = NULL;\n\n\trdma_restrack_new(&mr->res, RDMA_RESTRACK_MR);\n\trdma_restrack_parent_name(&mr->res, &pd->res);\n\trdma_restrack_add(&mr->res);\nout:\n\ttrace_mr_alloc(pd, mr_type, max_num_sg, mr);\n\treturn mr;\n}\nEXPORT_SYMBOL(ib_alloc_mr);\n\n \nstruct ib_mr *ib_alloc_mr_integrity(struct ib_pd *pd,\n\t\t\t\t    u32 max_num_data_sg,\n\t\t\t\t    u32 max_num_meta_sg)\n{\n\tstruct ib_mr *mr;\n\tstruct ib_sig_attrs *sig_attrs;\n\n\tif (!pd->device->ops.alloc_mr_integrity ||\n\t    !pd->device->ops.map_mr_sg_pi) {\n\t\tmr = ERR_PTR(-EOPNOTSUPP);\n\t\tgoto out;\n\t}\n\n\tif (!max_num_meta_sg) {\n\t\tmr = ERR_PTR(-EINVAL);\n\t\tgoto out;\n\t}\n\n\tsig_attrs = kzalloc(sizeof(struct ib_sig_attrs), GFP_KERNEL);\n\tif (!sig_attrs) {\n\t\tmr = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\tmr = pd->device->ops.alloc_mr_integrity(pd, max_num_data_sg,\n\t\t\t\t\t\tmax_num_meta_sg);\n\tif (IS_ERR(mr)) {\n\t\tkfree(sig_attrs);\n\t\tgoto out;\n\t}\n\n\tmr->device = pd->device;\n\tmr->pd = pd;\n\tmr->dm = NULL;\n\tmr->uobject = NULL;\n\tatomic_inc(&pd->usecnt);\n\tmr->need_inval = false;\n\tmr->type = IB_MR_TYPE_INTEGRITY;\n\tmr->sig_attrs = sig_attrs;\n\n\trdma_restrack_new(&mr->res, RDMA_RESTRACK_MR);\n\trdma_restrack_parent_name(&mr->res, &pd->res);\n\trdma_restrack_add(&mr->res);\nout:\n\ttrace_mr_integ_alloc(pd, max_num_data_sg, max_num_meta_sg, mr);\n\treturn mr;\n}\nEXPORT_SYMBOL(ib_alloc_mr_integrity);\n\n \n\nstatic bool is_valid_mcast_lid(struct ib_qp *qp, u16 lid)\n{\n\tstruct ib_qp_init_attr init_attr = {};\n\tstruct ib_qp_attr attr = {};\n\tint num_eth_ports = 0;\n\tunsigned int port;\n\n\t \n\tif (!ib_query_qp(qp, &attr, IB_QP_STATE | IB_QP_PORT, &init_attr)) {\n\t\tif (attr.qp_state >= IB_QPS_INIT) {\n\t\t\tif (rdma_port_get_link_layer(qp->device, attr.port_num) !=\n\t\t\t    IB_LINK_LAYER_INFINIBAND)\n\t\t\t\treturn true;\n\t\t\tgoto lid_check;\n\t\t}\n\t}\n\n\t \n\trdma_for_each_port(qp->device, port)\n\t\tif (rdma_port_get_link_layer(qp->device, port) !=\n\t\t    IB_LINK_LAYER_INFINIBAND)\n\t\t\tnum_eth_ports++;\n\n\t \n\tif (num_eth_ports)\n\t\treturn true;\n\n\t \nlid_check:\n\treturn !(lid < be16_to_cpu(IB_MULTICAST_LID_BASE) ||\n\t\t lid == be16_to_cpu(IB_LID_PERMISSIVE));\n}\n\nint ib_attach_mcast(struct ib_qp *qp, union ib_gid *gid, u16 lid)\n{\n\tint ret;\n\n\tif (!qp->device->ops.attach_mcast)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdma_is_multicast_addr((struct in6_addr *)gid->raw) ||\n\t    qp->qp_type != IB_QPT_UD || !is_valid_mcast_lid(qp, lid))\n\t\treturn -EINVAL;\n\n\tret = qp->device->ops.attach_mcast(qp, gid, lid);\n\tif (!ret)\n\t\tatomic_inc(&qp->usecnt);\n\treturn ret;\n}\nEXPORT_SYMBOL(ib_attach_mcast);\n\nint ib_detach_mcast(struct ib_qp *qp, union ib_gid *gid, u16 lid)\n{\n\tint ret;\n\n\tif (!qp->device->ops.detach_mcast)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rdma_is_multicast_addr((struct in6_addr *)gid->raw) ||\n\t    qp->qp_type != IB_QPT_UD || !is_valid_mcast_lid(qp, lid))\n\t\treturn -EINVAL;\n\n\tret = qp->device->ops.detach_mcast(qp, gid, lid);\n\tif (!ret)\n\t\tatomic_dec(&qp->usecnt);\n\treturn ret;\n}\nEXPORT_SYMBOL(ib_detach_mcast);\n\n \nstruct ib_xrcd *ib_alloc_xrcd_user(struct ib_device *device,\n\t\t\t\t   struct inode *inode, struct ib_udata *udata)\n{\n\tstruct ib_xrcd *xrcd;\n\tint ret;\n\n\tif (!device->ops.alloc_xrcd)\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\txrcd = rdma_zalloc_drv_obj(device, ib_xrcd);\n\tif (!xrcd)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\txrcd->device = device;\n\txrcd->inode = inode;\n\tatomic_set(&xrcd->usecnt, 0);\n\tinit_rwsem(&xrcd->tgt_qps_rwsem);\n\txa_init(&xrcd->tgt_qps);\n\n\tret = device->ops.alloc_xrcd(xrcd, udata);\n\tif (ret)\n\t\tgoto err;\n\treturn xrcd;\nerr:\n\tkfree(xrcd);\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL(ib_alloc_xrcd_user);\n\n \nint ib_dealloc_xrcd_user(struct ib_xrcd *xrcd, struct ib_udata *udata)\n{\n\tint ret;\n\n\tif (atomic_read(&xrcd->usecnt))\n\t\treturn -EBUSY;\n\n\tWARN_ON(!xa_empty(&xrcd->tgt_qps));\n\tret = xrcd->device->ops.dealloc_xrcd(xrcd, udata);\n\tif (ret)\n\t\treturn ret;\n\tkfree(xrcd);\n\treturn ret;\n}\nEXPORT_SYMBOL(ib_dealloc_xrcd_user);\n\n \nstruct ib_wq *ib_create_wq(struct ib_pd *pd,\n\t\t\t   struct ib_wq_init_attr *wq_attr)\n{\n\tstruct ib_wq *wq;\n\n\tif (!pd->device->ops.create_wq)\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\twq = pd->device->ops.create_wq(pd, wq_attr, NULL);\n\tif (!IS_ERR(wq)) {\n\t\twq->event_handler = wq_attr->event_handler;\n\t\twq->wq_context = wq_attr->wq_context;\n\t\twq->wq_type = wq_attr->wq_type;\n\t\twq->cq = wq_attr->cq;\n\t\twq->device = pd->device;\n\t\twq->pd = pd;\n\t\twq->uobject = NULL;\n\t\tatomic_inc(&pd->usecnt);\n\t\tatomic_inc(&wq_attr->cq->usecnt);\n\t\tatomic_set(&wq->usecnt, 0);\n\t}\n\treturn wq;\n}\nEXPORT_SYMBOL(ib_create_wq);\n\n \nint ib_destroy_wq_user(struct ib_wq *wq, struct ib_udata *udata)\n{\n\tstruct ib_cq *cq = wq->cq;\n\tstruct ib_pd *pd = wq->pd;\n\tint ret;\n\n\tif (atomic_read(&wq->usecnt))\n\t\treturn -EBUSY;\n\n\tret = wq->device->ops.destroy_wq(wq, udata);\n\tif (ret)\n\t\treturn ret;\n\n\tatomic_dec(&pd->usecnt);\n\tatomic_dec(&cq->usecnt);\n\treturn ret;\n}\nEXPORT_SYMBOL(ib_destroy_wq_user);\n\nint ib_check_mr_status(struct ib_mr *mr, u32 check_mask,\n\t\t       struct ib_mr_status *mr_status)\n{\n\tif (!mr->device->ops.check_mr_status)\n\t\treturn -EOPNOTSUPP;\n\n\treturn mr->device->ops.check_mr_status(mr, check_mask, mr_status);\n}\nEXPORT_SYMBOL(ib_check_mr_status);\n\nint ib_set_vf_link_state(struct ib_device *device, int vf, u32 port,\n\t\t\t int state)\n{\n\tif (!device->ops.set_vf_link_state)\n\t\treturn -EOPNOTSUPP;\n\n\treturn device->ops.set_vf_link_state(device, vf, port, state);\n}\nEXPORT_SYMBOL(ib_set_vf_link_state);\n\nint ib_get_vf_config(struct ib_device *device, int vf, u32 port,\n\t\t     struct ifla_vf_info *info)\n{\n\tif (!device->ops.get_vf_config)\n\t\treturn -EOPNOTSUPP;\n\n\treturn device->ops.get_vf_config(device, vf, port, info);\n}\nEXPORT_SYMBOL(ib_get_vf_config);\n\nint ib_get_vf_stats(struct ib_device *device, int vf, u32 port,\n\t\t    struct ifla_vf_stats *stats)\n{\n\tif (!device->ops.get_vf_stats)\n\t\treturn -EOPNOTSUPP;\n\n\treturn device->ops.get_vf_stats(device, vf, port, stats);\n}\nEXPORT_SYMBOL(ib_get_vf_stats);\n\nint ib_set_vf_guid(struct ib_device *device, int vf, u32 port, u64 guid,\n\t\t   int type)\n{\n\tif (!device->ops.set_vf_guid)\n\t\treturn -EOPNOTSUPP;\n\n\treturn device->ops.set_vf_guid(device, vf, port, guid, type);\n}\nEXPORT_SYMBOL(ib_set_vf_guid);\n\nint ib_get_vf_guid(struct ib_device *device, int vf, u32 port,\n\t\t   struct ifla_vf_guid *node_guid,\n\t\t   struct ifla_vf_guid *port_guid)\n{\n\tif (!device->ops.get_vf_guid)\n\t\treturn -EOPNOTSUPP;\n\n\treturn device->ops.get_vf_guid(device, vf, port, node_guid, port_guid);\n}\nEXPORT_SYMBOL(ib_get_vf_guid);\n \nint ib_map_mr_sg_pi(struct ib_mr *mr, struct scatterlist *data_sg,\n\t\t    int data_sg_nents, unsigned int *data_sg_offset,\n\t\t    struct scatterlist *meta_sg, int meta_sg_nents,\n\t\t    unsigned int *meta_sg_offset, unsigned int page_size)\n{\n\tif (unlikely(!mr->device->ops.map_mr_sg_pi ||\n\t\t     WARN_ON_ONCE(mr->type != IB_MR_TYPE_INTEGRITY)))\n\t\treturn -EOPNOTSUPP;\n\n\tmr->page_size = page_size;\n\n\treturn mr->device->ops.map_mr_sg_pi(mr, data_sg, data_sg_nents,\n\t\t\t\t\t    data_sg_offset, meta_sg,\n\t\t\t\t\t    meta_sg_nents, meta_sg_offset);\n}\nEXPORT_SYMBOL(ib_map_mr_sg_pi);\n\n \nint ib_map_mr_sg(struct ib_mr *mr, struct scatterlist *sg, int sg_nents,\n\t\t unsigned int *sg_offset, unsigned int page_size)\n{\n\tif (unlikely(!mr->device->ops.map_mr_sg))\n\t\treturn -EOPNOTSUPP;\n\n\tmr->page_size = page_size;\n\n\treturn mr->device->ops.map_mr_sg(mr, sg, sg_nents, sg_offset);\n}\nEXPORT_SYMBOL(ib_map_mr_sg);\n\n \nint ib_sg_to_pages(struct ib_mr *mr, struct scatterlist *sgl, int sg_nents,\n\t\tunsigned int *sg_offset_p, int (*set_page)(struct ib_mr *, u64))\n{\n\tstruct scatterlist *sg;\n\tu64 last_end_dma_addr = 0;\n\tunsigned int sg_offset = sg_offset_p ? *sg_offset_p : 0;\n\tunsigned int last_page_off = 0;\n\tu64 page_mask = ~((u64)mr->page_size - 1);\n\tint i, ret;\n\n\tif (unlikely(sg_nents <= 0 || sg_offset > sg_dma_len(&sgl[0])))\n\t\treturn -EINVAL;\n\n\tmr->iova = sg_dma_address(&sgl[0]) + sg_offset;\n\tmr->length = 0;\n\n\tfor_each_sg(sgl, sg, sg_nents, i) {\n\t\tu64 dma_addr = sg_dma_address(sg) + sg_offset;\n\t\tu64 prev_addr = dma_addr;\n\t\tunsigned int dma_len = sg_dma_len(sg) - sg_offset;\n\t\tu64 end_dma_addr = dma_addr + dma_len;\n\t\tu64 page_addr = dma_addr & page_mask;\n\n\t\t \n\t\tif (i && (last_page_off != 0 || page_addr != dma_addr)) {\n\t\t\t \n\t\t\tif (last_end_dma_addr != dma_addr)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tgoto next_page;\n\t\t}\n\n\t\tdo {\n\t\t\tret = set_page(mr, page_addr);\n\t\t\tif (unlikely(ret < 0)) {\n\t\t\t\tsg_offset = prev_addr - sg_dma_address(sg);\n\t\t\t\tmr->length += prev_addr - dma_addr;\n\t\t\t\tif (sg_offset_p)\n\t\t\t\t\t*sg_offset_p = sg_offset;\n\t\t\t\treturn i || sg_offset ? i : ret;\n\t\t\t}\n\t\t\tprev_addr = page_addr;\nnext_page:\n\t\t\tpage_addr += mr->page_size;\n\t\t} while (page_addr < end_dma_addr);\n\n\t\tmr->length += dma_len;\n\t\tlast_end_dma_addr = end_dma_addr;\n\t\tlast_page_off = end_dma_addr & ~page_mask;\n\n\t\tsg_offset = 0;\n\t}\n\n\tif (sg_offset_p)\n\t\t*sg_offset_p = 0;\n\treturn i;\n}\nEXPORT_SYMBOL(ib_sg_to_pages);\n\nstruct ib_drain_cqe {\n\tstruct ib_cqe cqe;\n\tstruct completion done;\n};\n\nstatic void ib_drain_qp_done(struct ib_cq *cq, struct ib_wc *wc)\n{\n\tstruct ib_drain_cqe *cqe = container_of(wc->wr_cqe, struct ib_drain_cqe,\n\t\t\t\t\t\tcqe);\n\n\tcomplete(&cqe->done);\n}\n\n \nstatic void __ib_drain_sq(struct ib_qp *qp)\n{\n\tstruct ib_cq *cq = qp->send_cq;\n\tstruct ib_qp_attr attr = { .qp_state = IB_QPS_ERR };\n\tstruct ib_drain_cqe sdrain;\n\tstruct ib_rdma_wr swr = {\n\t\t.wr = {\n\t\t\t.next = NULL,\n\t\t\t{ .wr_cqe\t= &sdrain.cqe, },\n\t\t\t.opcode\t= IB_WR_RDMA_WRITE,\n\t\t},\n\t};\n\tint ret;\n\n\tret = ib_modify_qp(qp, &attr, IB_QP_STATE);\n\tif (ret) {\n\t\tWARN_ONCE(ret, \"failed to drain send queue: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tsdrain.cqe.done = ib_drain_qp_done;\n\tinit_completion(&sdrain.done);\n\n\tret = ib_post_send(qp, &swr.wr, NULL);\n\tif (ret) {\n\t\tWARN_ONCE(ret, \"failed to drain send queue: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tif (cq->poll_ctx == IB_POLL_DIRECT)\n\t\twhile (wait_for_completion_timeout(&sdrain.done, HZ / 10) <= 0)\n\t\t\tib_process_cq_direct(cq, -1);\n\telse\n\t\twait_for_completion(&sdrain.done);\n}\n\n \nstatic void __ib_drain_rq(struct ib_qp *qp)\n{\n\tstruct ib_cq *cq = qp->recv_cq;\n\tstruct ib_qp_attr attr = { .qp_state = IB_QPS_ERR };\n\tstruct ib_drain_cqe rdrain;\n\tstruct ib_recv_wr rwr = {};\n\tint ret;\n\n\tret = ib_modify_qp(qp, &attr, IB_QP_STATE);\n\tif (ret) {\n\t\tWARN_ONCE(ret, \"failed to drain recv queue: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\trwr.wr_cqe = &rdrain.cqe;\n\trdrain.cqe.done = ib_drain_qp_done;\n\tinit_completion(&rdrain.done);\n\n\tret = ib_post_recv(qp, &rwr, NULL);\n\tif (ret) {\n\t\tWARN_ONCE(ret, \"failed to drain recv queue: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tif (cq->poll_ctx == IB_POLL_DIRECT)\n\t\twhile (wait_for_completion_timeout(&rdrain.done, HZ / 10) <= 0)\n\t\t\tib_process_cq_direct(cq, -1);\n\telse\n\t\twait_for_completion(&rdrain.done);\n}\n\n \nvoid ib_drain_sq(struct ib_qp *qp)\n{\n\tif (qp->device->ops.drain_sq)\n\t\tqp->device->ops.drain_sq(qp);\n\telse\n\t\t__ib_drain_sq(qp);\n\ttrace_cq_drain_complete(qp->send_cq);\n}\nEXPORT_SYMBOL(ib_drain_sq);\n\n \nvoid ib_drain_rq(struct ib_qp *qp)\n{\n\tif (qp->device->ops.drain_rq)\n\t\tqp->device->ops.drain_rq(qp);\n\telse\n\t\t__ib_drain_rq(qp);\n\ttrace_cq_drain_complete(qp->recv_cq);\n}\nEXPORT_SYMBOL(ib_drain_rq);\n\n \nvoid ib_drain_qp(struct ib_qp *qp)\n{\n\tib_drain_sq(qp);\n\tif (!qp->srq)\n\t\tib_drain_rq(qp);\n}\nEXPORT_SYMBOL(ib_drain_qp);\n\nstruct net_device *rdma_alloc_netdev(struct ib_device *device, u32 port_num,\n\t\t\t\t     enum rdma_netdev_t type, const char *name,\n\t\t\t\t     unsigned char name_assign_type,\n\t\t\t\t     void (*setup)(struct net_device *))\n{\n\tstruct rdma_netdev_alloc_params params;\n\tstruct net_device *netdev;\n\tint rc;\n\n\tif (!device->ops.rdma_netdev_get_params)\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\trc = device->ops.rdma_netdev_get_params(device, port_num, type,\n\t\t\t\t\t\t&params);\n\tif (rc)\n\t\treturn ERR_PTR(rc);\n\n\tnetdev = alloc_netdev_mqs(params.sizeof_priv, name, name_assign_type,\n\t\t\t\t  setup, params.txqs, params.rxqs);\n\tif (!netdev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\treturn netdev;\n}\nEXPORT_SYMBOL(rdma_alloc_netdev);\n\nint rdma_init_netdev(struct ib_device *device, u32 port_num,\n\t\t     enum rdma_netdev_t type, const char *name,\n\t\t     unsigned char name_assign_type,\n\t\t     void (*setup)(struct net_device *),\n\t\t     struct net_device *netdev)\n{\n\tstruct rdma_netdev_alloc_params params;\n\tint rc;\n\n\tif (!device->ops.rdma_netdev_get_params)\n\t\treturn -EOPNOTSUPP;\n\n\trc = device->ops.rdma_netdev_get_params(device, port_num, type,\n\t\t\t\t\t\t&params);\n\tif (rc)\n\t\treturn rc;\n\n\treturn params.initialize_rdma_netdev(device, port_num,\n\t\t\t\t\t     netdev, params.param);\n}\nEXPORT_SYMBOL(rdma_init_netdev);\n\nvoid __rdma_block_iter_start(struct ib_block_iter *biter,\n\t\t\t     struct scatterlist *sglist, unsigned int nents,\n\t\t\t     unsigned long pgsz)\n{\n\tmemset(biter, 0, sizeof(struct ib_block_iter));\n\tbiter->__sg = sglist;\n\tbiter->__sg_nents = nents;\n\n\t \n\tbiter->__pg_bit = __fls(pgsz);\n}\nEXPORT_SYMBOL(__rdma_block_iter_start);\n\nbool __rdma_block_iter_next(struct ib_block_iter *biter)\n{\n\tunsigned int block_offset;\n\tunsigned int sg_delta;\n\n\tif (!biter->__sg_nents || !biter->__sg)\n\t\treturn false;\n\n\tbiter->__dma_addr = sg_dma_address(biter->__sg) + biter->__sg_advance;\n\tblock_offset = biter->__dma_addr & (BIT_ULL(biter->__pg_bit) - 1);\n\tsg_delta = BIT_ULL(biter->__pg_bit) - block_offset;\n\n\tif (sg_dma_len(biter->__sg) - biter->__sg_advance > sg_delta) {\n\t\tbiter->__sg_advance += sg_delta;\n\t} else {\n\t\tbiter->__sg_advance = 0;\n\t\tbiter->__sg = sg_next(biter->__sg);\n\t\tbiter->__sg_nents--;\n\t}\n\n\treturn true;\n}\nEXPORT_SYMBOL(__rdma_block_iter_next);\n\n \nstruct rdma_hw_stats *rdma_alloc_hw_stats_struct(\n\tconst struct rdma_stat_desc *descs, int num_counters,\n\tunsigned long lifespan)\n{\n\tstruct rdma_hw_stats *stats;\n\n\tstats = kzalloc(struct_size(stats, value, num_counters), GFP_KERNEL);\n\tif (!stats)\n\t\treturn NULL;\n\n\tstats->is_disabled = kcalloc(BITS_TO_LONGS(num_counters),\n\t\t\t\t     sizeof(*stats->is_disabled), GFP_KERNEL);\n\tif (!stats->is_disabled)\n\t\tgoto err;\n\n\tstats->descs = descs;\n\tstats->num_counters = num_counters;\n\tstats->lifespan = msecs_to_jiffies(lifespan);\n\tmutex_init(&stats->lock);\n\n\treturn stats;\n\nerr:\n\tkfree(stats);\n\treturn NULL;\n}\nEXPORT_SYMBOL(rdma_alloc_hw_stats_struct);\n\n \nvoid rdma_free_hw_stats_struct(struct rdma_hw_stats *stats)\n{\n\tif (!stats)\n\t\treturn;\n\n\tkfree(stats->is_disabled);\n\tkfree(stats);\n}\nEXPORT_SYMBOL(rdma_free_hw_stats_struct);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}