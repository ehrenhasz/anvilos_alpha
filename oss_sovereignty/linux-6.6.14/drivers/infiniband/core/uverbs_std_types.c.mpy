{
  "module_name": "uverbs_std_types.c",
  "hash_id": "4da717f14186aae86e1ff6f15cc0eb525bef2f27f542808065aae52f34d619b6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/core/uverbs_std_types.c",
  "human_readable_source": " \n\n#include <rdma/uverbs_std_types.h>\n#include <rdma/ib_user_verbs.h>\n#include <rdma/ib_verbs.h>\n#include <linux/bug.h>\n#include <linux/file.h>\n#include <rdma/restrack.h>\n#include \"rdma_core.h\"\n#include \"uverbs.h\"\n\nstatic int uverbs_free_ah(struct ib_uobject *uobject,\n\t\t\t  enum rdma_remove_reason why,\n\t\t\t  struct uverbs_attr_bundle *attrs)\n{\n\treturn rdma_destroy_ah_user((struct ib_ah *)uobject->object,\n\t\t\t\t    RDMA_DESTROY_AH_SLEEPABLE,\n\t\t\t\t    &attrs->driver_udata);\n}\n\nstatic int uverbs_free_flow(struct ib_uobject *uobject,\n\t\t\t    enum rdma_remove_reason why,\n\t\t\t    struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_flow *flow = (struct ib_flow *)uobject->object;\n\tstruct ib_uflow_object *uflow =\n\t\tcontainer_of(uobject, struct ib_uflow_object, uobject);\n\tstruct ib_qp *qp = flow->qp;\n\tint ret;\n\n\tret = flow->device->ops.destroy_flow(flow);\n\tif (!ret) {\n\t\tif (qp)\n\t\t\tatomic_dec(&qp->usecnt);\n\t\tib_uverbs_flow_resources_free(uflow->resources);\n\t}\n\n\treturn ret;\n}\n\nstatic int uverbs_free_mw(struct ib_uobject *uobject,\n\t\t\t  enum rdma_remove_reason why,\n\t\t\t  struct uverbs_attr_bundle *attrs)\n{\n\treturn uverbs_dealloc_mw((struct ib_mw *)uobject->object);\n}\n\nstatic int uverbs_free_rwq_ind_tbl(struct ib_uobject *uobject,\n\t\t\t\t   enum rdma_remove_reason why,\n\t\t\t\t   struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_rwq_ind_table *rwq_ind_tbl = uobject->object;\n\tstruct ib_wq **ind_tbl = rwq_ind_tbl->ind_tbl;\n\tu32 table_size = (1 << rwq_ind_tbl->log_ind_tbl_size);\n\tint ret, i;\n\n\tif (atomic_read(&rwq_ind_tbl->usecnt))\n\t\treturn -EBUSY;\n\n\tret = rwq_ind_tbl->device->ops.destroy_rwq_ind_table(rwq_ind_tbl);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < table_size; i++)\n\t\tatomic_dec(&ind_tbl[i]->usecnt);\n\n\tkfree(rwq_ind_tbl);\n\tkfree(ind_tbl);\n\treturn 0;\n}\n\nstatic int uverbs_free_xrcd(struct ib_uobject *uobject,\n\t\t\t    enum rdma_remove_reason why,\n\t\t\t    struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_xrcd *xrcd = uobject->object;\n\tstruct ib_uxrcd_object *uxrcd =\n\t\tcontainer_of(uobject, struct ib_uxrcd_object, uobject);\n\tint ret;\n\n\tif (atomic_read(&uxrcd->refcnt))\n\t\treturn -EBUSY;\n\n\tmutex_lock(&attrs->ufile->device->xrcd_tree_mutex);\n\tret = ib_uverbs_dealloc_xrcd(uobject, xrcd, why, attrs);\n\tmutex_unlock(&attrs->ufile->device->xrcd_tree_mutex);\n\n\treturn ret;\n}\n\nstatic int uverbs_free_pd(struct ib_uobject *uobject,\n\t\t\t  enum rdma_remove_reason why,\n\t\t\t  struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_pd *pd = uobject->object;\n\n\tif (atomic_read(&pd->usecnt))\n\t\treturn -EBUSY;\n\n\treturn ib_dealloc_pd_user(pd, &attrs->driver_udata);\n}\n\nvoid ib_uverbs_free_event_queue(struct ib_uverbs_event_queue *event_queue)\n{\n\tstruct ib_uverbs_event *entry, *tmp;\n\n\tspin_lock_irq(&event_queue->lock);\n\t \n\tevent_queue->is_closed = 1;\n\tspin_unlock_irq(&event_queue->lock);\n\twake_up_interruptible(&event_queue->poll_wait);\n\tkill_fasync(&event_queue->async_queue, SIGIO, POLL_IN);\n\n\tspin_lock_irq(&event_queue->lock);\n\tlist_for_each_entry_safe(entry, tmp, &event_queue->event_list, list) {\n\t\tif (entry->counter)\n\t\t\tlist_del(&entry->obj_list);\n\t\tlist_del(&entry->list);\n\t\tkfree(entry);\n\t}\n\tspin_unlock_irq(&event_queue->lock);\n}\n\nstatic void\nuverbs_completion_event_file_destroy_uobj(struct ib_uobject *uobj,\n\t\t\t\t\t  enum rdma_remove_reason why)\n{\n\tstruct ib_uverbs_completion_event_file *file =\n\t\tcontainer_of(uobj, struct ib_uverbs_completion_event_file,\n\t\t\t     uobj);\n\n\tib_uverbs_free_event_queue(&file->ev_queue);\n}\n\nint uverbs_destroy_def_handler(struct uverbs_attr_bundle *attrs)\n{\n\treturn 0;\n}\nEXPORT_SYMBOL(uverbs_destroy_def_handler);\n\nDECLARE_UVERBS_NAMED_OBJECT(\n\tUVERBS_OBJECT_COMP_CHANNEL,\n\tUVERBS_TYPE_ALLOC_FD(sizeof(struct ib_uverbs_completion_event_file),\n\t\t\t     uverbs_completion_event_file_destroy_uobj,\n\t\t\t     &uverbs_event_fops,\n\t\t\t     \"[infinibandevent]\",\n\t\t\t     O_RDONLY));\n\nDECLARE_UVERBS_NAMED_METHOD_DESTROY(\n\tUVERBS_METHOD_MW_DESTROY,\n\tUVERBS_ATTR_IDR(UVERBS_ATTR_DESTROY_MW_HANDLE,\n\t\t\tUVERBS_OBJECT_MW,\n\t\t\tUVERBS_ACCESS_DESTROY,\n\t\t\tUA_MANDATORY));\n\nDECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_MW,\n\t\t\t    UVERBS_TYPE_ALLOC_IDR(uverbs_free_mw),\n\t\t\t    &UVERBS_METHOD(UVERBS_METHOD_MW_DESTROY));\n\nDECLARE_UVERBS_NAMED_METHOD_DESTROY(\n\tUVERBS_METHOD_AH_DESTROY,\n\tUVERBS_ATTR_IDR(UVERBS_ATTR_DESTROY_AH_HANDLE,\n\t\t\tUVERBS_OBJECT_AH,\n\t\t\tUVERBS_ACCESS_DESTROY,\n\t\t\tUA_MANDATORY));\n\nDECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_AH,\n\t\t\t    UVERBS_TYPE_ALLOC_IDR(uverbs_free_ah),\n\t\t\t    &UVERBS_METHOD(UVERBS_METHOD_AH_DESTROY));\n\nDECLARE_UVERBS_NAMED_METHOD_DESTROY(\n\tUVERBS_METHOD_FLOW_DESTROY,\n\tUVERBS_ATTR_IDR(UVERBS_ATTR_DESTROY_FLOW_HANDLE,\n\t\t\tUVERBS_OBJECT_FLOW,\n\t\t\tUVERBS_ACCESS_DESTROY,\n\t\t\tUA_MANDATORY));\n\nDECLARE_UVERBS_NAMED_OBJECT(\n\tUVERBS_OBJECT_FLOW,\n\tUVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_uflow_object),\n\t\t\t\t uverbs_free_flow),\n\t\t\t    &UVERBS_METHOD(UVERBS_METHOD_FLOW_DESTROY));\n\nDECLARE_UVERBS_NAMED_METHOD_DESTROY(\n\tUVERBS_METHOD_RWQ_IND_TBL_DESTROY,\n\tUVERBS_ATTR_IDR(UVERBS_ATTR_DESTROY_RWQ_IND_TBL_HANDLE,\n\t\t\tUVERBS_OBJECT_RWQ_IND_TBL,\n\t\t\tUVERBS_ACCESS_DESTROY,\n\t\t\tUA_MANDATORY));\n\nDECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_RWQ_IND_TBL,\n\t\t\t    UVERBS_TYPE_ALLOC_IDR(uverbs_free_rwq_ind_tbl),\n\t\t\t    &UVERBS_METHOD(UVERBS_METHOD_RWQ_IND_TBL_DESTROY));\n\nDECLARE_UVERBS_NAMED_METHOD_DESTROY(\n\tUVERBS_METHOD_XRCD_DESTROY,\n\tUVERBS_ATTR_IDR(UVERBS_ATTR_DESTROY_XRCD_HANDLE,\n\t\t\tUVERBS_OBJECT_XRCD,\n\t\t\tUVERBS_ACCESS_DESTROY,\n\t\t\tUA_MANDATORY));\n\nDECLARE_UVERBS_NAMED_OBJECT(\n\tUVERBS_OBJECT_XRCD,\n\tUVERBS_TYPE_ALLOC_IDR_SZ(sizeof(struct ib_uxrcd_object),\n\t\t\t\t uverbs_free_xrcd),\n\t\t\t    &UVERBS_METHOD(UVERBS_METHOD_XRCD_DESTROY));\n\nDECLARE_UVERBS_NAMED_METHOD_DESTROY(\n\tUVERBS_METHOD_PD_DESTROY,\n\tUVERBS_ATTR_IDR(UVERBS_ATTR_DESTROY_PD_HANDLE,\n\t\t\tUVERBS_OBJECT_PD,\n\t\t\tUVERBS_ACCESS_DESTROY,\n\t\t\tUA_MANDATORY));\n\nDECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_PD,\n\t\t\t    UVERBS_TYPE_ALLOC_IDR(uverbs_free_pd),\n\t\t\t    &UVERBS_METHOD(UVERBS_METHOD_PD_DESTROY));\n\nconst struct uapi_definition uverbs_def_obj_intf[] = {\n\tUAPI_DEF_CHAIN_OBJ_TREE_NAMED(UVERBS_OBJECT_PD,\n\t\t\t\t      UAPI_DEF_OBJ_NEEDS_FN(dealloc_pd)),\n\tUAPI_DEF_CHAIN_OBJ_TREE_NAMED(UVERBS_OBJECT_COMP_CHANNEL,\n\t\t\t\t      UAPI_DEF_OBJ_NEEDS_FN(dealloc_pd)),\n\tUAPI_DEF_CHAIN_OBJ_TREE_NAMED(UVERBS_OBJECT_AH,\n\t\t\t\t      UAPI_DEF_OBJ_NEEDS_FN(destroy_ah)),\n\tUAPI_DEF_CHAIN_OBJ_TREE_NAMED(UVERBS_OBJECT_MW,\n\t\t\t\t      UAPI_DEF_OBJ_NEEDS_FN(dealloc_mw)),\n\tUAPI_DEF_CHAIN_OBJ_TREE_NAMED(UVERBS_OBJECT_FLOW,\n\t\t\t\t      UAPI_DEF_OBJ_NEEDS_FN(destroy_flow)),\n\tUAPI_DEF_CHAIN_OBJ_TREE_NAMED(\n\t\tUVERBS_OBJECT_RWQ_IND_TBL,\n\t\tUAPI_DEF_OBJ_NEEDS_FN(destroy_rwq_ind_table)),\n\tUAPI_DEF_CHAIN_OBJ_TREE_NAMED(UVERBS_OBJECT_XRCD,\n\t\t\t\t      UAPI_DEF_OBJ_NEEDS_FN(dealloc_xrcd)),\n\t{}\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}