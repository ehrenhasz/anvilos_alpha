{
  "module_name": "iwcm.c",
  "hash_id": "902a03078e4126c91ee660acc3c32efe2f7a7b272f81a0c7aaf85bda1c7f0f52",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/core/iwcm.c",
  "human_readable_source": " \n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/idr.h>\n#include <linux/interrupt.h>\n#include <linux/rbtree.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/sysctl.h>\n\n#include <rdma/iw_cm.h>\n#include <rdma/ib_addr.h>\n#include <rdma/iw_portmap.h>\n#include <rdma/rdma_netlink.h>\n\n#include \"iwcm.h\"\n\nMODULE_AUTHOR(\"Tom Tucker\");\nMODULE_DESCRIPTION(\"iWARP CM\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n\nstatic const char * const iwcm_rej_reason_strs[] = {\n\t[ECONNRESET]\t\t\t= \"reset by remote host\",\n\t[ECONNREFUSED]\t\t\t= \"refused by remote application\",\n\t[ETIMEDOUT]\t\t\t= \"setup timeout\",\n};\n\nconst char *__attribute_const__ iwcm_reject_msg(int reason)\n{\n\tsize_t index;\n\n\t \n\tindex = -reason;\n\n\tif (index < ARRAY_SIZE(iwcm_rej_reason_strs) &&\n\t    iwcm_rej_reason_strs[index])\n\t\treturn iwcm_rej_reason_strs[index];\n\telse\n\t\treturn \"unrecognized reason\";\n}\nEXPORT_SYMBOL(iwcm_reject_msg);\n\nstatic struct rdma_nl_cbs iwcm_nl_cb_table[RDMA_NL_IWPM_NUM_OPS] = {\n\t[RDMA_NL_IWPM_REG_PID] = {.dump = iwpm_register_pid_cb},\n\t[RDMA_NL_IWPM_ADD_MAPPING] = {.dump = iwpm_add_mapping_cb},\n\t[RDMA_NL_IWPM_QUERY_MAPPING] = {.dump = iwpm_add_and_query_mapping_cb},\n\t[RDMA_NL_IWPM_REMOTE_INFO] = {.dump = iwpm_remote_info_cb},\n\t[RDMA_NL_IWPM_HANDLE_ERR] = {.dump = iwpm_mapping_error_cb},\n\t[RDMA_NL_IWPM_MAPINFO] = {.dump = iwpm_mapping_info_cb},\n\t[RDMA_NL_IWPM_MAPINFO_NUM] = {.dump = iwpm_ack_mapping_info_cb},\n\t[RDMA_NL_IWPM_HELLO] = {.dump = iwpm_hello_cb}\n};\n\nstatic struct workqueue_struct *iwcm_wq;\nstruct iwcm_work {\n\tstruct work_struct work;\n\tstruct iwcm_id_private *cm_id;\n\tstruct list_head list;\n\tstruct iw_cm_event event;\n\tstruct list_head free_list;\n};\n\nstatic unsigned int default_backlog = 256;\n\nstatic struct ctl_table_header *iwcm_ctl_table_hdr;\nstatic struct ctl_table iwcm_ctl_table[] = {\n\t{\n\t\t.procname\t= \"default_backlog\",\n\t\t.data\t\t= &default_backlog,\n\t\t.maxlen\t\t= sizeof(default_backlog),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{ }\n};\n\n \n\nstatic struct iwcm_work *get_work(struct iwcm_id_private *cm_id_priv)\n{\n\tstruct iwcm_work *work;\n\n\tif (list_empty(&cm_id_priv->work_free_list))\n\t\treturn NULL;\n\twork = list_entry(cm_id_priv->work_free_list.next, struct iwcm_work,\n\t\t\t  free_list);\n\tlist_del_init(&work->free_list);\n\treturn work;\n}\n\nstatic void put_work(struct iwcm_work *work)\n{\n\tlist_add(&work->free_list, &work->cm_id->work_free_list);\n}\n\nstatic void dealloc_work_entries(struct iwcm_id_private *cm_id_priv)\n{\n\tstruct list_head *e, *tmp;\n\n\tlist_for_each_safe(e, tmp, &cm_id_priv->work_free_list) {\n\t\tlist_del(e);\n\t\tkfree(list_entry(e, struct iwcm_work, free_list));\n\t}\n}\n\nstatic int alloc_work_entries(struct iwcm_id_private *cm_id_priv, int count)\n{\n\tstruct iwcm_work *work;\n\n\tBUG_ON(!list_empty(&cm_id_priv->work_free_list));\n\twhile (count--) {\n\t\twork = kmalloc(sizeof(struct iwcm_work), GFP_KERNEL);\n\t\tif (!work) {\n\t\t\tdealloc_work_entries(cm_id_priv);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\twork->cm_id = cm_id_priv;\n\t\tINIT_LIST_HEAD(&work->list);\n\t\tput_work(work);\n\t}\n\treturn 0;\n}\n\n \nstatic int copy_private_data(struct iw_cm_event *event)\n{\n\tvoid *p;\n\n\tp = kmemdup(event->private_data, event->private_data_len, GFP_ATOMIC);\n\tif (!p)\n\t\treturn -ENOMEM;\n\tevent->private_data = p;\n\treturn 0;\n}\n\nstatic void free_cm_id(struct iwcm_id_private *cm_id_priv)\n{\n\tdealloc_work_entries(cm_id_priv);\n\tkfree(cm_id_priv);\n}\n\n \nstatic int iwcm_deref_id(struct iwcm_id_private *cm_id_priv)\n{\n\tif (refcount_dec_and_test(&cm_id_priv->refcount)) {\n\t\tBUG_ON(!list_empty(&cm_id_priv->work_list));\n\t\tfree_cm_id(cm_id_priv);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic void add_ref(struct iw_cm_id *cm_id)\n{\n\tstruct iwcm_id_private *cm_id_priv;\n\tcm_id_priv = container_of(cm_id, struct iwcm_id_private, id);\n\trefcount_inc(&cm_id_priv->refcount);\n}\n\nstatic void rem_ref(struct iw_cm_id *cm_id)\n{\n\tstruct iwcm_id_private *cm_id_priv;\n\n\tcm_id_priv = container_of(cm_id, struct iwcm_id_private, id);\n\n\t(void)iwcm_deref_id(cm_id_priv);\n}\n\nstatic int cm_event_handler(struct iw_cm_id *cm_id, struct iw_cm_event *event);\n\nstruct iw_cm_id *iw_create_cm_id(struct ib_device *device,\n\t\t\t\t iw_cm_handler cm_handler,\n\t\t\t\t void *context)\n{\n\tstruct iwcm_id_private *cm_id_priv;\n\n\tcm_id_priv = kzalloc(sizeof(*cm_id_priv), GFP_KERNEL);\n\tif (!cm_id_priv)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcm_id_priv->state = IW_CM_STATE_IDLE;\n\tcm_id_priv->id.device = device;\n\tcm_id_priv->id.cm_handler = cm_handler;\n\tcm_id_priv->id.context = context;\n\tcm_id_priv->id.event_handler = cm_event_handler;\n\tcm_id_priv->id.add_ref = add_ref;\n\tcm_id_priv->id.rem_ref = rem_ref;\n\tspin_lock_init(&cm_id_priv->lock);\n\trefcount_set(&cm_id_priv->refcount, 1);\n\tinit_waitqueue_head(&cm_id_priv->connect_wait);\n\tinit_completion(&cm_id_priv->destroy_comp);\n\tINIT_LIST_HEAD(&cm_id_priv->work_list);\n\tINIT_LIST_HEAD(&cm_id_priv->work_free_list);\n\n\treturn &cm_id_priv->id;\n}\nEXPORT_SYMBOL(iw_create_cm_id);\n\n\nstatic int iwcm_modify_qp_err(struct ib_qp *qp)\n{\n\tstruct ib_qp_attr qp_attr;\n\n\tif (!qp)\n\t\treturn -EINVAL;\n\n\tqp_attr.qp_state = IB_QPS_ERR;\n\treturn ib_modify_qp(qp, &qp_attr, IB_QP_STATE);\n}\n\n \nstatic int iwcm_modify_qp_sqd(struct ib_qp *qp)\n{\n\tstruct ib_qp_attr qp_attr;\n\n\tBUG_ON(qp == NULL);\n\tqp_attr.qp_state = IB_QPS_SQD;\n\treturn ib_modify_qp(qp, &qp_attr, IB_QP_STATE);\n}\n\n \nint iw_cm_disconnect(struct iw_cm_id *cm_id, int abrupt)\n{\n\tstruct iwcm_id_private *cm_id_priv;\n\tunsigned long flags;\n\tint ret = 0;\n\tstruct ib_qp *qp = NULL;\n\n\tcm_id_priv = container_of(cm_id, struct iwcm_id_private, id);\n\t \n\twait_event(cm_id_priv->connect_wait,\n\t\t   !test_bit(IWCM_F_CONNECT_WAIT, &cm_id_priv->flags));\n\n\tspin_lock_irqsave(&cm_id_priv->lock, flags);\n\tswitch (cm_id_priv->state) {\n\tcase IW_CM_STATE_ESTABLISHED:\n\t\tcm_id_priv->state = IW_CM_STATE_CLOSING;\n\n\t\t \n\t\tif (cm_id_priv->qp)\n\t\t\tqp = cm_id_priv->qp;\n\t\telse\n\t\t\tret = -EINVAL;\n\t\tbreak;\n\tcase IW_CM_STATE_LISTEN:\n\t\tret = -EINVAL;\n\t\tbreak;\n\tcase IW_CM_STATE_CLOSING:\n\t\t \n\tcase IW_CM_STATE_IDLE:\n\t\t \n\t\tbreak;\n\tcase IW_CM_STATE_CONN_RECV:\n\t\t \n\t\tbreak;\n\tcase IW_CM_STATE_CONN_SENT:\n\t\t \n\tdefault:\n\t\tBUG();\n\t}\n\tspin_unlock_irqrestore(&cm_id_priv->lock, flags);\n\n\tif (qp) {\n\t\tif (abrupt)\n\t\t\tret = iwcm_modify_qp_err(qp);\n\t\telse\n\t\t\tret = iwcm_modify_qp_sqd(qp);\n\n\t\t \n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL(iw_cm_disconnect);\n\n \nstatic void destroy_cm_id(struct iw_cm_id *cm_id)\n{\n\tstruct iwcm_id_private *cm_id_priv;\n\tstruct ib_qp *qp;\n\tunsigned long flags;\n\n\tcm_id_priv = container_of(cm_id, struct iwcm_id_private, id);\n\t \n\twait_event(cm_id_priv->connect_wait,\n\t\t   !test_bit(IWCM_F_CONNECT_WAIT, &cm_id_priv->flags));\n\n\t \n\tset_bit(IWCM_F_DROP_EVENTS, &cm_id_priv->flags);\n\n\tspin_lock_irqsave(&cm_id_priv->lock, flags);\n\tqp = cm_id_priv->qp;\n\tcm_id_priv->qp = NULL;\n\n\tswitch (cm_id_priv->state) {\n\tcase IW_CM_STATE_LISTEN:\n\t\tcm_id_priv->state = IW_CM_STATE_DESTROYING;\n\t\tspin_unlock_irqrestore(&cm_id_priv->lock, flags);\n\t\t \n\t\tcm_id->device->ops.iw_destroy_listen(cm_id);\n\t\tspin_lock_irqsave(&cm_id_priv->lock, flags);\n\t\tbreak;\n\tcase IW_CM_STATE_ESTABLISHED:\n\t\tcm_id_priv->state = IW_CM_STATE_DESTROYING;\n\t\tspin_unlock_irqrestore(&cm_id_priv->lock, flags);\n\t\t \n\t\t(void)iwcm_modify_qp_err(qp);\n\t\tspin_lock_irqsave(&cm_id_priv->lock, flags);\n\t\tbreak;\n\tcase IW_CM_STATE_IDLE:\n\tcase IW_CM_STATE_CLOSING:\n\t\tcm_id_priv->state = IW_CM_STATE_DESTROYING;\n\t\tbreak;\n\tcase IW_CM_STATE_CONN_RECV:\n\t\t \n\t\tcm_id_priv->state = IW_CM_STATE_DESTROYING;\n\t\tspin_unlock_irqrestore(&cm_id_priv->lock, flags);\n\t\tcm_id->device->ops.iw_reject(cm_id, NULL, 0);\n\t\tspin_lock_irqsave(&cm_id_priv->lock, flags);\n\t\tbreak;\n\tcase IW_CM_STATE_CONN_SENT:\n\tcase IW_CM_STATE_DESTROYING:\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&cm_id_priv->lock, flags);\n\tif (qp)\n\t\tcm_id_priv->id.device->ops.iw_rem_ref(qp);\n\n\tif (cm_id->mapped) {\n\t\tiwpm_remove_mapinfo(&cm_id->local_addr, &cm_id->m_local_addr);\n\t\tiwpm_remove_mapping(&cm_id->local_addr, RDMA_NL_IWCM);\n\t}\n\n\t(void)iwcm_deref_id(cm_id_priv);\n}\n\n \nvoid iw_destroy_cm_id(struct iw_cm_id *cm_id)\n{\n\tdestroy_cm_id(cm_id);\n}\nEXPORT_SYMBOL(iw_destroy_cm_id);\n\n \nstatic void iw_cm_check_wildcard(struct sockaddr_storage *pm_addr,\n\t\t\t\t struct sockaddr_storage *cm_addr,\n\t\t\t\t struct sockaddr_storage *cm_outaddr)\n{\n\tif (pm_addr->ss_family == AF_INET) {\n\t\tstruct sockaddr_in *pm4_addr = (struct sockaddr_in *)pm_addr;\n\n\t\tif (pm4_addr->sin_addr.s_addr == htonl(INADDR_ANY)) {\n\t\t\tstruct sockaddr_in *cm4_addr =\n\t\t\t\t(struct sockaddr_in *)cm_addr;\n\t\t\tstruct sockaddr_in *cm4_outaddr =\n\t\t\t\t(struct sockaddr_in *)cm_outaddr;\n\n\t\t\tcm4_outaddr->sin_addr = cm4_addr->sin_addr;\n\t\t}\n\t} else {\n\t\tstruct sockaddr_in6 *pm6_addr = (struct sockaddr_in6 *)pm_addr;\n\n\t\tif (ipv6_addr_type(&pm6_addr->sin6_addr) == IPV6_ADDR_ANY) {\n\t\t\tstruct sockaddr_in6 *cm6_addr =\n\t\t\t\t(struct sockaddr_in6 *)cm_addr;\n\t\t\tstruct sockaddr_in6 *cm6_outaddr =\n\t\t\t\t(struct sockaddr_in6 *)cm_outaddr;\n\n\t\t\tcm6_outaddr->sin6_addr = cm6_addr->sin6_addr;\n\t\t}\n\t}\n}\n\n \nstatic int iw_cm_map(struct iw_cm_id *cm_id, bool active)\n{\n\tconst char *devname = dev_name(&cm_id->device->dev);\n\tconst char *ifname = cm_id->device->iw_ifname;\n\tstruct iwpm_dev_data pm_reg_msg = {};\n\tstruct iwpm_sa_data pm_msg;\n\tint status;\n\n\tif (strlen(devname) >= sizeof(pm_reg_msg.dev_name) ||\n\t    strlen(ifname) >= sizeof(pm_reg_msg.if_name))\n\t\treturn -EINVAL;\n\n\tcm_id->m_local_addr = cm_id->local_addr;\n\tcm_id->m_remote_addr = cm_id->remote_addr;\n\n\tstrcpy(pm_reg_msg.dev_name, devname);\n\tstrcpy(pm_reg_msg.if_name, ifname);\n\n\tif (iwpm_register_pid(&pm_reg_msg, RDMA_NL_IWCM) ||\n\t    !iwpm_valid_pid())\n\t\treturn 0;\n\n\tcm_id->mapped = true;\n\tpm_msg.loc_addr = cm_id->local_addr;\n\tpm_msg.rem_addr = cm_id->remote_addr;\n\tpm_msg.flags = (cm_id->device->iw_driver_flags & IW_F_NO_PORT_MAP) ?\n\t\t       IWPM_FLAGS_NO_PORT_MAP : 0;\n\tif (active)\n\t\tstatus = iwpm_add_and_query_mapping(&pm_msg,\n\t\t\t\t\t\t    RDMA_NL_IWCM);\n\telse\n\t\tstatus = iwpm_add_mapping(&pm_msg, RDMA_NL_IWCM);\n\n\tif (!status) {\n\t\tcm_id->m_local_addr = pm_msg.mapped_loc_addr;\n\t\tif (active) {\n\t\t\tcm_id->m_remote_addr = pm_msg.mapped_rem_addr;\n\t\t\tiw_cm_check_wildcard(&pm_msg.mapped_rem_addr,\n\t\t\t\t\t     &cm_id->remote_addr,\n\t\t\t\t\t     &cm_id->m_remote_addr);\n\t\t}\n\t}\n\n\treturn iwpm_create_mapinfo(&cm_id->local_addr,\n\t\t\t\t   &cm_id->m_local_addr,\n\t\t\t\t   RDMA_NL_IWCM, pm_msg.flags);\n}\n\n \nint iw_cm_listen(struct iw_cm_id *cm_id, int backlog)\n{\n\tstruct iwcm_id_private *cm_id_priv;\n\tunsigned long flags;\n\tint ret;\n\n\tcm_id_priv = container_of(cm_id, struct iwcm_id_private, id);\n\n\tif (!backlog)\n\t\tbacklog = default_backlog;\n\n\tret = alloc_work_entries(cm_id_priv, backlog);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock_irqsave(&cm_id_priv->lock, flags);\n\tswitch (cm_id_priv->state) {\n\tcase IW_CM_STATE_IDLE:\n\t\tcm_id_priv->state = IW_CM_STATE_LISTEN;\n\t\tspin_unlock_irqrestore(&cm_id_priv->lock, flags);\n\t\tret = iw_cm_map(cm_id, false);\n\t\tif (!ret)\n\t\t\tret = cm_id->device->ops.iw_create_listen(cm_id,\n\t\t\t\t\t\t\t\t  backlog);\n\t\tif (ret)\n\t\t\tcm_id_priv->state = IW_CM_STATE_IDLE;\n\t\tspin_lock_irqsave(&cm_id_priv->lock, flags);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\tspin_unlock_irqrestore(&cm_id_priv->lock, flags);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(iw_cm_listen);\n\n \nint iw_cm_reject(struct iw_cm_id *cm_id,\n\t\t const void *private_data,\n\t\t u8 private_data_len)\n{\n\tstruct iwcm_id_private *cm_id_priv;\n\tunsigned long flags;\n\tint ret;\n\n\tcm_id_priv = container_of(cm_id, struct iwcm_id_private, id);\n\tset_bit(IWCM_F_CONNECT_WAIT, &cm_id_priv->flags);\n\n\tspin_lock_irqsave(&cm_id_priv->lock, flags);\n\tif (cm_id_priv->state != IW_CM_STATE_CONN_RECV) {\n\t\tspin_unlock_irqrestore(&cm_id_priv->lock, flags);\n\t\tclear_bit(IWCM_F_CONNECT_WAIT, &cm_id_priv->flags);\n\t\twake_up_all(&cm_id_priv->connect_wait);\n\t\treturn -EINVAL;\n\t}\n\tcm_id_priv->state = IW_CM_STATE_IDLE;\n\tspin_unlock_irqrestore(&cm_id_priv->lock, flags);\n\n\tret = cm_id->device->ops.iw_reject(cm_id, private_data,\n\t\t\t\t\t  private_data_len);\n\n\tclear_bit(IWCM_F_CONNECT_WAIT, &cm_id_priv->flags);\n\twake_up_all(&cm_id_priv->connect_wait);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(iw_cm_reject);\n\n \nint iw_cm_accept(struct iw_cm_id *cm_id,\n\t\t struct iw_cm_conn_param *iw_param)\n{\n\tstruct iwcm_id_private *cm_id_priv;\n\tstruct ib_qp *qp;\n\tunsigned long flags;\n\tint ret;\n\n\tcm_id_priv = container_of(cm_id, struct iwcm_id_private, id);\n\tset_bit(IWCM_F_CONNECT_WAIT, &cm_id_priv->flags);\n\n\tspin_lock_irqsave(&cm_id_priv->lock, flags);\n\tif (cm_id_priv->state != IW_CM_STATE_CONN_RECV) {\n\t\tspin_unlock_irqrestore(&cm_id_priv->lock, flags);\n\t\tclear_bit(IWCM_F_CONNECT_WAIT, &cm_id_priv->flags);\n\t\twake_up_all(&cm_id_priv->connect_wait);\n\t\treturn -EINVAL;\n\t}\n\t \n\tqp = cm_id->device->ops.iw_get_qp(cm_id->device, iw_param->qpn);\n\tif (!qp) {\n\t\tspin_unlock_irqrestore(&cm_id_priv->lock, flags);\n\t\tclear_bit(IWCM_F_CONNECT_WAIT, &cm_id_priv->flags);\n\t\twake_up_all(&cm_id_priv->connect_wait);\n\t\treturn -EINVAL;\n\t}\n\tcm_id->device->ops.iw_add_ref(qp);\n\tcm_id_priv->qp = qp;\n\tspin_unlock_irqrestore(&cm_id_priv->lock, flags);\n\n\tret = cm_id->device->ops.iw_accept(cm_id, iw_param);\n\tif (ret) {\n\t\t \n\t\tBUG_ON(cm_id_priv->state != IW_CM_STATE_CONN_RECV);\n\t\tcm_id_priv->state = IW_CM_STATE_IDLE;\n\t\tspin_lock_irqsave(&cm_id_priv->lock, flags);\n\t\tqp = cm_id_priv->qp;\n\t\tcm_id_priv->qp = NULL;\n\t\tspin_unlock_irqrestore(&cm_id_priv->lock, flags);\n\t\tif (qp)\n\t\t\tcm_id->device->ops.iw_rem_ref(qp);\n\t\tclear_bit(IWCM_F_CONNECT_WAIT, &cm_id_priv->flags);\n\t\twake_up_all(&cm_id_priv->connect_wait);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL(iw_cm_accept);\n\n \nint iw_cm_connect(struct iw_cm_id *cm_id, struct iw_cm_conn_param *iw_param)\n{\n\tstruct iwcm_id_private *cm_id_priv;\n\tint ret;\n\tunsigned long flags;\n\tstruct ib_qp *qp = NULL;\n\n\tcm_id_priv = container_of(cm_id, struct iwcm_id_private, id);\n\n\tret = alloc_work_entries(cm_id_priv, 4);\n\tif (ret)\n\t\treturn ret;\n\n\tset_bit(IWCM_F_CONNECT_WAIT, &cm_id_priv->flags);\n\tspin_lock_irqsave(&cm_id_priv->lock, flags);\n\n\tif (cm_id_priv->state != IW_CM_STATE_IDLE) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\t \n\tqp = cm_id->device->ops.iw_get_qp(cm_id->device, iw_param->qpn);\n\tif (!qp) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\tcm_id->device->ops.iw_add_ref(qp);\n\tcm_id_priv->qp = qp;\n\tcm_id_priv->state = IW_CM_STATE_CONN_SENT;\n\tspin_unlock_irqrestore(&cm_id_priv->lock, flags);\n\n\tret = iw_cm_map(cm_id, true);\n\tif (!ret)\n\t\tret = cm_id->device->ops.iw_connect(cm_id, iw_param);\n\tif (!ret)\n\t\treturn 0;\t \n\n\tspin_lock_irqsave(&cm_id_priv->lock, flags);\n\tqp = cm_id_priv->qp;\n\tcm_id_priv->qp = NULL;\n\tcm_id_priv->state = IW_CM_STATE_IDLE;\nerr:\n\tspin_unlock_irqrestore(&cm_id_priv->lock, flags);\n\tif (qp)\n\t\tcm_id->device->ops.iw_rem_ref(qp);\n\tclear_bit(IWCM_F_CONNECT_WAIT, &cm_id_priv->flags);\n\twake_up_all(&cm_id_priv->connect_wait);\n\treturn ret;\n}\nEXPORT_SYMBOL(iw_cm_connect);\n\n \nstatic void cm_conn_req_handler(struct iwcm_id_private *listen_id_priv,\n\t\t\t\tstruct iw_cm_event *iw_event)\n{\n\tunsigned long flags;\n\tstruct iw_cm_id *cm_id;\n\tstruct iwcm_id_private *cm_id_priv;\n\tint ret;\n\n\t \n\tBUG_ON(iw_event->status);\n\n\tcm_id = iw_create_cm_id(listen_id_priv->id.device,\n\t\t\t\tlisten_id_priv->id.cm_handler,\n\t\t\t\tlisten_id_priv->id.context);\n\t \n\tif (IS_ERR(cm_id))\n\t\tgoto out;\n\n\tcm_id->provider_data = iw_event->provider_data;\n\tcm_id->m_local_addr = iw_event->local_addr;\n\tcm_id->m_remote_addr = iw_event->remote_addr;\n\tcm_id->local_addr = listen_id_priv->id.local_addr;\n\n\tret = iwpm_get_remote_info(&listen_id_priv->id.m_local_addr,\n\t\t\t\t   &iw_event->remote_addr,\n\t\t\t\t   &cm_id->remote_addr,\n\t\t\t\t   RDMA_NL_IWCM);\n\tif (ret) {\n\t\tcm_id->remote_addr = iw_event->remote_addr;\n\t} else {\n\t\tiw_cm_check_wildcard(&listen_id_priv->id.m_local_addr,\n\t\t\t\t     &iw_event->local_addr,\n\t\t\t\t     &cm_id->local_addr);\n\t\tiw_event->local_addr = cm_id->local_addr;\n\t\tiw_event->remote_addr = cm_id->remote_addr;\n\t}\n\n\tcm_id_priv = container_of(cm_id, struct iwcm_id_private, id);\n\tcm_id_priv->state = IW_CM_STATE_CONN_RECV;\n\n\t \n\tspin_lock_irqsave(&listen_id_priv->lock, flags);\n\tif (listen_id_priv->state != IW_CM_STATE_LISTEN) {\n\t\tspin_unlock_irqrestore(&listen_id_priv->lock, flags);\n\t\tiw_cm_reject(cm_id, NULL, 0);\n\t\tiw_destroy_cm_id(cm_id);\n\t\tgoto out;\n\t}\n\tspin_unlock_irqrestore(&listen_id_priv->lock, flags);\n\n\tret = alloc_work_entries(cm_id_priv, 3);\n\tif (ret) {\n\t\tiw_cm_reject(cm_id, NULL, 0);\n\t\tiw_destroy_cm_id(cm_id);\n\t\tgoto out;\n\t}\n\n\t \n\tret = cm_id->cm_handler(cm_id, iw_event);\n\tif (ret) {\n\t\tiw_cm_reject(cm_id, NULL, 0);\n\t\tiw_destroy_cm_id(cm_id);\n\t}\n\nout:\n\tif (iw_event->private_data_len)\n\t\tkfree(iw_event->private_data);\n}\n\n \nstatic int cm_conn_est_handler(struct iwcm_id_private *cm_id_priv,\n\t\t\t       struct iw_cm_event *iw_event)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&cm_id_priv->lock, flags);\n\n\t \n\tclear_bit(IWCM_F_CONNECT_WAIT, &cm_id_priv->flags);\n\tBUG_ON(cm_id_priv->state != IW_CM_STATE_CONN_RECV);\n\tcm_id_priv->state = IW_CM_STATE_ESTABLISHED;\n\tspin_unlock_irqrestore(&cm_id_priv->lock, flags);\n\tret = cm_id_priv->id.cm_handler(&cm_id_priv->id, iw_event);\n\twake_up_all(&cm_id_priv->connect_wait);\n\n\treturn ret;\n}\n\n \nstatic int cm_conn_rep_handler(struct iwcm_id_private *cm_id_priv,\n\t\t\t       struct iw_cm_event *iw_event)\n{\n\tstruct ib_qp *qp = NULL;\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&cm_id_priv->lock, flags);\n\t \n\tclear_bit(IWCM_F_CONNECT_WAIT, &cm_id_priv->flags);\n\tBUG_ON(cm_id_priv->state != IW_CM_STATE_CONN_SENT);\n\tif (iw_event->status == 0) {\n\t\tcm_id_priv->id.m_local_addr = iw_event->local_addr;\n\t\tcm_id_priv->id.m_remote_addr = iw_event->remote_addr;\n\t\tiw_event->local_addr = cm_id_priv->id.local_addr;\n\t\tiw_event->remote_addr = cm_id_priv->id.remote_addr;\n\t\tcm_id_priv->state = IW_CM_STATE_ESTABLISHED;\n\t} else {\n\t\t \n\t\tqp = cm_id_priv->qp;\n\t\tcm_id_priv->qp = NULL;\n\t\tcm_id_priv->state = IW_CM_STATE_IDLE;\n\t}\n\tspin_unlock_irqrestore(&cm_id_priv->lock, flags);\n\tif (qp)\n\t\tcm_id_priv->id.device->ops.iw_rem_ref(qp);\n\tret = cm_id_priv->id.cm_handler(&cm_id_priv->id, iw_event);\n\n\tif (iw_event->private_data_len)\n\t\tkfree(iw_event->private_data);\n\n\t \n\twake_up_all(&cm_id_priv->connect_wait);\n\n\treturn ret;\n}\n\n \nstatic void cm_disconnect_handler(struct iwcm_id_private *cm_id_priv,\n\t\t\t\t  struct iw_cm_event *iw_event)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cm_id_priv->lock, flags);\n\tif (cm_id_priv->state == IW_CM_STATE_ESTABLISHED)\n\t\tcm_id_priv->state = IW_CM_STATE_CLOSING;\n\tspin_unlock_irqrestore(&cm_id_priv->lock, flags);\n}\n\n \nstatic int cm_close_handler(struct iwcm_id_private *cm_id_priv,\n\t\t\t\t  struct iw_cm_event *iw_event)\n{\n\tstruct ib_qp *qp;\n\tunsigned long flags;\n\tint ret = 0, notify_event = 0;\n\tspin_lock_irqsave(&cm_id_priv->lock, flags);\n\tqp = cm_id_priv->qp;\n\tcm_id_priv->qp = NULL;\n\n\tswitch (cm_id_priv->state) {\n\tcase IW_CM_STATE_ESTABLISHED:\n\tcase IW_CM_STATE_CLOSING:\n\t\tcm_id_priv->state = IW_CM_STATE_IDLE;\n\t\tnotify_event = 1;\n\t\tbreak;\n\tcase IW_CM_STATE_DESTROYING:\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\tspin_unlock_irqrestore(&cm_id_priv->lock, flags);\n\n\tif (qp)\n\t\tcm_id_priv->id.device->ops.iw_rem_ref(qp);\n\tif (notify_event)\n\t\tret = cm_id_priv->id.cm_handler(&cm_id_priv->id, iw_event);\n\treturn ret;\n}\n\nstatic int process_event(struct iwcm_id_private *cm_id_priv,\n\t\t\t struct iw_cm_event *iw_event)\n{\n\tint ret = 0;\n\n\tswitch (iw_event->event) {\n\tcase IW_CM_EVENT_CONNECT_REQUEST:\n\t\tcm_conn_req_handler(cm_id_priv, iw_event);\n\t\tbreak;\n\tcase IW_CM_EVENT_CONNECT_REPLY:\n\t\tret = cm_conn_rep_handler(cm_id_priv, iw_event);\n\t\tbreak;\n\tcase IW_CM_EVENT_ESTABLISHED:\n\t\tret = cm_conn_est_handler(cm_id_priv, iw_event);\n\t\tbreak;\n\tcase IW_CM_EVENT_DISCONNECT:\n\t\tcm_disconnect_handler(cm_id_priv, iw_event);\n\t\tbreak;\n\tcase IW_CM_EVENT_CLOSE:\n\t\tret = cm_close_handler(cm_id_priv, iw_event);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\treturn ret;\n}\n\n \nstatic void cm_work_handler(struct work_struct *_work)\n{\n\tstruct iwcm_work *work = container_of(_work, struct iwcm_work, work);\n\tstruct iw_cm_event levent;\n\tstruct iwcm_id_private *cm_id_priv = work->cm_id;\n\tunsigned long flags;\n\tint empty;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&cm_id_priv->lock, flags);\n\tempty = list_empty(&cm_id_priv->work_list);\n\twhile (!empty) {\n\t\twork = list_entry(cm_id_priv->work_list.next,\n\t\t\t\t  struct iwcm_work, list);\n\t\tlist_del_init(&work->list);\n\t\tempty = list_empty(&cm_id_priv->work_list);\n\t\tlevent = work->event;\n\t\tput_work(work);\n\t\tspin_unlock_irqrestore(&cm_id_priv->lock, flags);\n\n\t\tif (!test_bit(IWCM_F_DROP_EVENTS, &cm_id_priv->flags)) {\n\t\t\tret = process_event(cm_id_priv, &levent);\n\t\t\tif (ret)\n\t\t\t\tdestroy_cm_id(&cm_id_priv->id);\n\t\t} else\n\t\t\tpr_debug(\"dropping event %d\\n\", levent.event);\n\t\tif (iwcm_deref_id(cm_id_priv))\n\t\t\treturn;\n\t\tif (empty)\n\t\t\treturn;\n\t\tspin_lock_irqsave(&cm_id_priv->lock, flags);\n\t}\n\tspin_unlock_irqrestore(&cm_id_priv->lock, flags);\n}\n\n \nstatic int cm_event_handler(struct iw_cm_id *cm_id,\n\t\t\t     struct iw_cm_event *iw_event)\n{\n\tstruct iwcm_work *work;\n\tstruct iwcm_id_private *cm_id_priv;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tcm_id_priv = container_of(cm_id, struct iwcm_id_private, id);\n\n\tspin_lock_irqsave(&cm_id_priv->lock, flags);\n\twork = get_work(cm_id_priv);\n\tif (!work) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tINIT_WORK(&work->work, cm_work_handler);\n\twork->cm_id = cm_id_priv;\n\twork->event = *iw_event;\n\n\tif ((work->event.event == IW_CM_EVENT_CONNECT_REQUEST ||\n\t     work->event.event == IW_CM_EVENT_CONNECT_REPLY) &&\n\t    work->event.private_data_len) {\n\t\tret = copy_private_data(&work->event);\n\t\tif (ret) {\n\t\t\tput_work(work);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\trefcount_inc(&cm_id_priv->refcount);\n\tif (list_empty(&cm_id_priv->work_list)) {\n\t\tlist_add_tail(&work->list, &cm_id_priv->work_list);\n\t\tqueue_work(iwcm_wq, &work->work);\n\t} else\n\t\tlist_add_tail(&work->list, &cm_id_priv->work_list);\nout:\n\tspin_unlock_irqrestore(&cm_id_priv->lock, flags);\n\treturn ret;\n}\n\nstatic int iwcm_init_qp_init_attr(struct iwcm_id_private *cm_id_priv,\n\t\t\t\t  struct ib_qp_attr *qp_attr,\n\t\t\t\t  int *qp_attr_mask)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&cm_id_priv->lock, flags);\n\tswitch (cm_id_priv->state) {\n\tcase IW_CM_STATE_IDLE:\n\tcase IW_CM_STATE_CONN_SENT:\n\tcase IW_CM_STATE_CONN_RECV:\n\tcase IW_CM_STATE_ESTABLISHED:\n\t\t*qp_attr_mask = IB_QP_STATE | IB_QP_ACCESS_FLAGS;\n\t\tqp_attr->qp_access_flags = IB_ACCESS_REMOTE_WRITE|\n\t\t\t\t\t   IB_ACCESS_REMOTE_READ;\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&cm_id_priv->lock, flags);\n\treturn ret;\n}\n\nstatic int iwcm_init_qp_rts_attr(struct iwcm_id_private *cm_id_priv,\n\t\t\t\t  struct ib_qp_attr *qp_attr,\n\t\t\t\t  int *qp_attr_mask)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&cm_id_priv->lock, flags);\n\tswitch (cm_id_priv->state) {\n\tcase IW_CM_STATE_IDLE:\n\tcase IW_CM_STATE_CONN_SENT:\n\tcase IW_CM_STATE_CONN_RECV:\n\tcase IW_CM_STATE_ESTABLISHED:\n\t\t*qp_attr_mask = 0;\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&cm_id_priv->lock, flags);\n\treturn ret;\n}\n\nint iw_cm_init_qp_attr(struct iw_cm_id *cm_id,\n\t\t       struct ib_qp_attr *qp_attr,\n\t\t       int *qp_attr_mask)\n{\n\tstruct iwcm_id_private *cm_id_priv;\n\tint ret;\n\n\tcm_id_priv = container_of(cm_id, struct iwcm_id_private, id);\n\tswitch (qp_attr->qp_state) {\n\tcase IB_QPS_INIT:\n\tcase IB_QPS_RTR:\n\t\tret = iwcm_init_qp_init_attr(cm_id_priv,\n\t\t\t\t\t     qp_attr, qp_attr_mask);\n\t\tbreak;\n\tcase IB_QPS_RTS:\n\t\tret = iwcm_init_qp_rts_attr(cm_id_priv,\n\t\t\t\t\t    qp_attr, qp_attr_mask);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL(iw_cm_init_qp_attr);\n\nstatic int __init iw_cm_init(void)\n{\n\tint ret;\n\n\tret = iwpm_init(RDMA_NL_IWCM);\n\tif (ret)\n\t\treturn ret;\n\n\tiwcm_wq = alloc_ordered_workqueue(\"iw_cm_wq\", 0);\n\tif (!iwcm_wq)\n\t\tgoto err_alloc;\n\n\tiwcm_ctl_table_hdr = register_net_sysctl(&init_net, \"net/iw_cm\",\n\t\t\t\t\t\t iwcm_ctl_table);\n\tif (!iwcm_ctl_table_hdr) {\n\t\tpr_err(\"iw_cm: couldn't register sysctl paths\\n\");\n\t\tgoto err_sysctl;\n\t}\n\n\trdma_nl_register(RDMA_NL_IWCM, iwcm_nl_cb_table);\n\treturn 0;\n\nerr_sysctl:\n\tdestroy_workqueue(iwcm_wq);\nerr_alloc:\n\tiwpm_exit(RDMA_NL_IWCM);\n\treturn -ENOMEM;\n}\n\nstatic void __exit iw_cm_cleanup(void)\n{\n\trdma_nl_unregister(RDMA_NL_IWCM);\n\tunregister_net_sysctl_table(iwcm_ctl_table_hdr);\n\tdestroy_workqueue(iwcm_wq);\n\tiwpm_exit(RDMA_NL_IWCM);\n}\n\nMODULE_ALIAS_RDMA_NETLINK(RDMA_NL_IWCM, 2);\n\nmodule_init(iw_cm_init);\nmodule_exit(iw_cm_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}