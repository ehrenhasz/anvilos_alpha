{
  "module_name": "ucma.c",
  "hash_id": "ff87d966df7735d14d944c11f9ea43e95cc5b10af15451e603e539b772d82d61",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/core/ucma.c",
  "human_readable_source": " \n\n#include <linux/completion.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/poll.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/in.h>\n#include <linux/in6.h>\n#include <linux/miscdevice.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/nsproxy.h>\n\n#include <linux/nospec.h>\n\n#include <rdma/rdma_user_cm.h>\n#include <rdma/ib_marshall.h>\n#include <rdma/rdma_cm.h>\n#include <rdma/rdma_cm_ib.h>\n#include <rdma/ib_addr.h>\n#include <rdma/ib.h>\n#include <rdma/ib_cm.h>\n#include <rdma/rdma_netlink.h>\n#include \"core_priv.h\"\n\nMODULE_AUTHOR(\"Sean Hefty\");\nMODULE_DESCRIPTION(\"RDMA Userspace Connection Manager Access\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n\nstatic unsigned int max_backlog = 1024;\n\nstatic struct ctl_table_header *ucma_ctl_table_hdr;\nstatic struct ctl_table ucma_ctl_table[] = {\n\t{\n\t\t.procname\t= \"max_backlog\",\n\t\t.data\t\t= &max_backlog,\n\t\t.maxlen\t\t= sizeof max_backlog,\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{ }\n};\n\nstruct ucma_file {\n\tstruct mutex\t\tmut;\n\tstruct file\t\t*filp;\n\tstruct list_head\tctx_list;\n\tstruct list_head\tevent_list;\n\twait_queue_head_t\tpoll_wait;\n};\n\nstruct ucma_context {\n\tu32\t\t\tid;\n\tstruct completion\tcomp;\n\trefcount_t\t\tref;\n\tint\t\t\tevents_reported;\n\tatomic_t\t\tbacklog;\n\n\tstruct ucma_file\t*file;\n\tstruct rdma_cm_id\t*cm_id;\n\tstruct mutex\t\tmutex;\n\tu64\t\t\tuid;\n\n\tstruct list_head\tlist;\n\tstruct list_head\tmc_list;\n\tstruct work_struct\tclose_work;\n};\n\nstruct ucma_multicast {\n\tstruct ucma_context\t*ctx;\n\tu32\t\t\tid;\n\tint\t\t\tevents_reported;\n\n\tu64\t\t\tuid;\n\tu8\t\t\tjoin_state;\n\tstruct list_head\tlist;\n\tstruct sockaddr_storage\taddr;\n};\n\nstruct ucma_event {\n\tstruct ucma_context\t*ctx;\n\tstruct ucma_context\t*conn_req_ctx;\n\tstruct ucma_multicast\t*mc;\n\tstruct list_head\tlist;\n\tstruct rdma_ucm_event_resp resp;\n};\n\nstatic DEFINE_XARRAY_ALLOC(ctx_table);\nstatic DEFINE_XARRAY_ALLOC(multicast_table);\n\nstatic const struct file_operations ucma_fops;\nstatic int ucma_destroy_private_ctx(struct ucma_context *ctx);\n\nstatic inline struct ucma_context *_ucma_find_context(int id,\n\t\t\t\t\t\t      struct ucma_file *file)\n{\n\tstruct ucma_context *ctx;\n\n\tctx = xa_load(&ctx_table, id);\n\tif (!ctx)\n\t\tctx = ERR_PTR(-ENOENT);\n\telse if (ctx->file != file)\n\t\tctx = ERR_PTR(-EINVAL);\n\treturn ctx;\n}\n\nstatic struct ucma_context *ucma_get_ctx(struct ucma_file *file, int id)\n{\n\tstruct ucma_context *ctx;\n\n\txa_lock(&ctx_table);\n\tctx = _ucma_find_context(id, file);\n\tif (!IS_ERR(ctx))\n\t\tif (!refcount_inc_not_zero(&ctx->ref))\n\t\t\tctx = ERR_PTR(-ENXIO);\n\txa_unlock(&ctx_table);\n\treturn ctx;\n}\n\nstatic void ucma_put_ctx(struct ucma_context *ctx)\n{\n\tif (refcount_dec_and_test(&ctx->ref))\n\t\tcomplete(&ctx->comp);\n}\n\n \nstatic struct ucma_context *ucma_get_ctx_dev(struct ucma_file *file, int id)\n{\n\tstruct ucma_context *ctx = ucma_get_ctx(file, id);\n\n\tif (IS_ERR(ctx))\n\t\treturn ctx;\n\tif (!ctx->cm_id->device) {\n\t\tucma_put_ctx(ctx);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\treturn ctx;\n}\n\nstatic void ucma_close_id(struct work_struct *work)\n{\n\tstruct ucma_context *ctx =  container_of(work, struct ucma_context, close_work);\n\n\t \n\tucma_put_ctx(ctx);\n\twait_for_completion(&ctx->comp);\n\t \n\trdma_destroy_id(ctx->cm_id);\n\n\t \n\tctx->cm_id = NULL;\n}\n\nstatic struct ucma_context *ucma_alloc_ctx(struct ucma_file *file)\n{\n\tstruct ucma_context *ctx;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn NULL;\n\n\tINIT_WORK(&ctx->close_work, ucma_close_id);\n\tinit_completion(&ctx->comp);\n\tINIT_LIST_HEAD(&ctx->mc_list);\n\t \n\tINIT_LIST_HEAD(&ctx->list);\n\tctx->file = file;\n\tmutex_init(&ctx->mutex);\n\n\tif (xa_alloc(&ctx_table, &ctx->id, NULL, xa_limit_32b, GFP_KERNEL)) {\n\t\tkfree(ctx);\n\t\treturn NULL;\n\t}\n\treturn ctx;\n}\n\nstatic void ucma_set_ctx_cm_id(struct ucma_context *ctx,\n\t\t\t       struct rdma_cm_id *cm_id)\n{\n\trefcount_set(&ctx->ref, 1);\n\tctx->cm_id = cm_id;\n}\n\nstatic void ucma_finish_ctx(struct ucma_context *ctx)\n{\n\tlockdep_assert_held(&ctx->file->mut);\n\tlist_add_tail(&ctx->list, &ctx->file->ctx_list);\n\txa_store(&ctx_table, ctx->id, ctx, GFP_KERNEL);\n}\n\nstatic void ucma_copy_conn_event(struct rdma_ucm_conn_param *dst,\n\t\t\t\t struct rdma_conn_param *src)\n{\n\tif (src->private_data_len)\n\t\tmemcpy(dst->private_data, src->private_data,\n\t\t       src->private_data_len);\n\tdst->private_data_len = src->private_data_len;\n\tdst->responder_resources = src->responder_resources;\n\tdst->initiator_depth = src->initiator_depth;\n\tdst->flow_control = src->flow_control;\n\tdst->retry_count = src->retry_count;\n\tdst->rnr_retry_count = src->rnr_retry_count;\n\tdst->srq = src->srq;\n\tdst->qp_num = src->qp_num;\n}\n\nstatic void ucma_copy_ud_event(struct ib_device *device,\n\t\t\t       struct rdma_ucm_ud_param *dst,\n\t\t\t       struct rdma_ud_param *src)\n{\n\tif (src->private_data_len)\n\t\tmemcpy(dst->private_data, src->private_data,\n\t\t       src->private_data_len);\n\tdst->private_data_len = src->private_data_len;\n\tib_copy_ah_attr_to_user(device, &dst->ah_attr, &src->ah_attr);\n\tdst->qp_num = src->qp_num;\n\tdst->qkey = src->qkey;\n}\n\nstatic struct ucma_event *ucma_create_uevent(struct ucma_context *ctx,\n\t\t\t\t\t     struct rdma_cm_event *event)\n{\n\tstruct ucma_event *uevent;\n\n\tuevent = kzalloc(sizeof(*uevent), GFP_KERNEL);\n\tif (!uevent)\n\t\treturn NULL;\n\n\tuevent->ctx = ctx;\n\tswitch (event->event) {\n\tcase RDMA_CM_EVENT_MULTICAST_JOIN:\n\tcase RDMA_CM_EVENT_MULTICAST_ERROR:\n\t\tuevent->mc = (struct ucma_multicast *)\n\t\t\t     event->param.ud.private_data;\n\t\tuevent->resp.uid = uevent->mc->uid;\n\t\tuevent->resp.id = uevent->mc->id;\n\t\tbreak;\n\tdefault:\n\t\tuevent->resp.uid = ctx->uid;\n\t\tuevent->resp.id = ctx->id;\n\t\tbreak;\n\t}\n\tuevent->resp.event = event->event;\n\tuevent->resp.status = event->status;\n\tif (ctx->cm_id->qp_type == IB_QPT_UD)\n\t\tucma_copy_ud_event(ctx->cm_id->device, &uevent->resp.param.ud,\n\t\t\t\t   &event->param.ud);\n\telse\n\t\tucma_copy_conn_event(&uevent->resp.param.conn,\n\t\t\t\t     &event->param.conn);\n\n\tuevent->resp.ece.vendor_id = event->ece.vendor_id;\n\tuevent->resp.ece.attr_mod = event->ece.attr_mod;\n\treturn uevent;\n}\n\nstatic int ucma_connect_event_handler(struct rdma_cm_id *cm_id,\n\t\t\t\t      struct rdma_cm_event *event)\n{\n\tstruct ucma_context *listen_ctx = cm_id->context;\n\tstruct ucma_context *ctx;\n\tstruct ucma_event *uevent;\n\n\tif (!atomic_add_unless(&listen_ctx->backlog, -1, 0))\n\t\treturn -ENOMEM;\n\tctx = ucma_alloc_ctx(listen_ctx->file);\n\tif (!ctx)\n\t\tgoto err_backlog;\n\tucma_set_ctx_cm_id(ctx, cm_id);\n\n\tuevent = ucma_create_uevent(listen_ctx, event);\n\tif (!uevent)\n\t\tgoto err_alloc;\n\tuevent->conn_req_ctx = ctx;\n\tuevent->resp.id = ctx->id;\n\n\tctx->cm_id->context = ctx;\n\n\tmutex_lock(&ctx->file->mut);\n\tucma_finish_ctx(ctx);\n\tlist_add_tail(&uevent->list, &ctx->file->event_list);\n\tmutex_unlock(&ctx->file->mut);\n\twake_up_interruptible(&ctx->file->poll_wait);\n\treturn 0;\n\nerr_alloc:\n\tucma_destroy_private_ctx(ctx);\nerr_backlog:\n\tatomic_inc(&listen_ctx->backlog);\n\t \n\treturn -ENOMEM;\n}\n\nstatic int ucma_event_handler(struct rdma_cm_id *cm_id,\n\t\t\t      struct rdma_cm_event *event)\n{\n\tstruct ucma_event *uevent;\n\tstruct ucma_context *ctx = cm_id->context;\n\n\tif (event->event == RDMA_CM_EVENT_CONNECT_REQUEST)\n\t\treturn ucma_connect_event_handler(cm_id, event);\n\n\t \n\tif (ctx->uid) {\n\t\tuevent = ucma_create_uevent(ctx, event);\n\t\tif (!uevent)\n\t\t\treturn 0;\n\n\t\tmutex_lock(&ctx->file->mut);\n\t\tlist_add_tail(&uevent->list, &ctx->file->event_list);\n\t\tmutex_unlock(&ctx->file->mut);\n\t\twake_up_interruptible(&ctx->file->poll_wait);\n\t}\n\n\tif (event->event == RDMA_CM_EVENT_DEVICE_REMOVAL) {\n\t\txa_lock(&ctx_table);\n\t\tif (xa_load(&ctx_table, ctx->id) == ctx)\n\t\t\tqueue_work(system_unbound_wq, &ctx->close_work);\n\t\txa_unlock(&ctx_table);\n\t}\n\treturn 0;\n}\n\nstatic ssize_t ucma_get_event(struct ucma_file *file, const char __user *inbuf,\n\t\t\t      int in_len, int out_len)\n{\n\tstruct rdma_ucm_get_event cmd;\n\tstruct ucma_event *uevent;\n\n\t \n\tif (out_len < sizeof(uevent->resp) - sizeof(uevent->resp.reserved) -\n\t\t\t      sizeof(uevent->resp.ece))\n\t\treturn -ENOSPC;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tmutex_lock(&file->mut);\n\twhile (list_empty(&file->event_list)) {\n\t\tmutex_unlock(&file->mut);\n\n\t\tif (file->filp->f_flags & O_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\n\t\tif (wait_event_interruptible(file->poll_wait,\n\t\t\t\t\t     !list_empty(&file->event_list)))\n\t\t\treturn -ERESTARTSYS;\n\n\t\tmutex_lock(&file->mut);\n\t}\n\n\tuevent = list_first_entry(&file->event_list, struct ucma_event, list);\n\n\tif (copy_to_user(u64_to_user_ptr(cmd.response),\n\t\t\t &uevent->resp,\n\t\t\t min_t(size_t, out_len, sizeof(uevent->resp)))) {\n\t\tmutex_unlock(&file->mut);\n\t\treturn -EFAULT;\n\t}\n\n\tlist_del(&uevent->list);\n\tuevent->ctx->events_reported++;\n\tif (uevent->mc)\n\t\tuevent->mc->events_reported++;\n\tif (uevent->resp.event == RDMA_CM_EVENT_CONNECT_REQUEST)\n\t\tatomic_inc(&uevent->ctx->backlog);\n\tmutex_unlock(&file->mut);\n\n\tkfree(uevent);\n\treturn 0;\n}\n\nstatic int ucma_get_qp_type(struct rdma_ucm_create_id *cmd, enum ib_qp_type *qp_type)\n{\n\tswitch (cmd->ps) {\n\tcase RDMA_PS_TCP:\n\t\t*qp_type = IB_QPT_RC;\n\t\treturn 0;\n\tcase RDMA_PS_UDP:\n\tcase RDMA_PS_IPOIB:\n\t\t*qp_type = IB_QPT_UD;\n\t\treturn 0;\n\tcase RDMA_PS_IB:\n\t\t*qp_type = cmd->qp_type;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic ssize_t ucma_create_id(struct ucma_file *file, const char __user *inbuf,\n\t\t\t      int in_len, int out_len)\n{\n\tstruct rdma_ucm_create_id cmd;\n\tstruct rdma_ucm_create_id_resp resp;\n\tstruct ucma_context *ctx;\n\tstruct rdma_cm_id *cm_id;\n\tenum ib_qp_type qp_type;\n\tint ret;\n\n\tif (out_len < sizeof(resp))\n\t\treturn -ENOSPC;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tret = ucma_get_qp_type(&cmd, &qp_type);\n\tif (ret)\n\t\treturn ret;\n\n\tctx = ucma_alloc_ctx(file);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->uid = cmd.uid;\n\tcm_id = rdma_create_user_id(ucma_event_handler, ctx, cmd.ps, qp_type);\n\tif (IS_ERR(cm_id)) {\n\t\tret = PTR_ERR(cm_id);\n\t\tgoto err1;\n\t}\n\tucma_set_ctx_cm_id(ctx, cm_id);\n\n\tresp.id = ctx->id;\n\tif (copy_to_user(u64_to_user_ptr(cmd.response),\n\t\t\t &resp, sizeof(resp))) {\n\t\tret = -EFAULT;\n\t\tgoto err1;\n\t}\n\n\tmutex_lock(&file->mut);\n\tucma_finish_ctx(ctx);\n\tmutex_unlock(&file->mut);\n\treturn 0;\n\nerr1:\n\tucma_destroy_private_ctx(ctx);\n\treturn ret;\n}\n\nstatic void ucma_cleanup_multicast(struct ucma_context *ctx)\n{\n\tstruct ucma_multicast *mc, *tmp;\n\n\txa_lock(&multicast_table);\n\tlist_for_each_entry_safe(mc, tmp, &ctx->mc_list, list) {\n\t\tlist_del(&mc->list);\n\t\t \n\t\t__xa_erase(&multicast_table, mc->id);\n\t\tkfree(mc);\n\t}\n\txa_unlock(&multicast_table);\n}\n\nstatic void ucma_cleanup_mc_events(struct ucma_multicast *mc)\n{\n\tstruct ucma_event *uevent, *tmp;\n\n\trdma_lock_handler(mc->ctx->cm_id);\n\tmutex_lock(&mc->ctx->file->mut);\n\tlist_for_each_entry_safe(uevent, tmp, &mc->ctx->file->event_list, list) {\n\t\tif (uevent->mc != mc)\n\t\t\tcontinue;\n\n\t\tlist_del(&uevent->list);\n\t\tkfree(uevent);\n\t}\n\tmutex_unlock(&mc->ctx->file->mut);\n\trdma_unlock_handler(mc->ctx->cm_id);\n}\n\nstatic int ucma_cleanup_ctx_events(struct ucma_context *ctx)\n{\n\tint events_reported;\n\tstruct ucma_event *uevent, *tmp;\n\tLIST_HEAD(list);\n\n\t \n\tmutex_lock(&ctx->file->mut);\n\tlist_for_each_entry_safe(uevent, tmp, &ctx->file->event_list, list) {\n\t\tif (uevent->ctx != ctx)\n\t\t\tcontinue;\n\n\t\tif (uevent->resp.event == RDMA_CM_EVENT_CONNECT_REQUEST &&\n\t\t    xa_cmpxchg(&ctx_table, uevent->conn_req_ctx->id,\n\t\t\t       uevent->conn_req_ctx, XA_ZERO_ENTRY,\n\t\t\t       GFP_KERNEL) == uevent->conn_req_ctx) {\n\t\t\tlist_move_tail(&uevent->list, &list);\n\t\t\tcontinue;\n\t\t}\n\t\tlist_del(&uevent->list);\n\t\tkfree(uevent);\n\t}\n\tlist_del(&ctx->list);\n\tevents_reported = ctx->events_reported;\n\tmutex_unlock(&ctx->file->mut);\n\n\t \n\tlist_for_each_entry_safe(uevent, tmp, &list, list) {\n\t\tucma_destroy_private_ctx(uevent->conn_req_ctx);\n\t\tkfree(uevent);\n\t}\n\treturn events_reported;\n}\n\n \nstatic int ucma_destroy_private_ctx(struct ucma_context *ctx)\n{\n\tint events_reported;\n\n\t \n\tcancel_work_sync(&ctx->close_work);\n\tif (refcount_read(&ctx->ref))\n\t\tucma_close_id(&ctx->close_work);\n\n\tevents_reported = ucma_cleanup_ctx_events(ctx);\n\tucma_cleanup_multicast(ctx);\n\n\tWARN_ON(xa_cmpxchg(&ctx_table, ctx->id, XA_ZERO_ENTRY, NULL,\n\t\t\t   GFP_KERNEL) != NULL);\n\tmutex_destroy(&ctx->mutex);\n\tkfree(ctx);\n\treturn events_reported;\n}\n\nstatic ssize_t ucma_destroy_id(struct ucma_file *file, const char __user *inbuf,\n\t\t\t       int in_len, int out_len)\n{\n\tstruct rdma_ucm_destroy_id cmd;\n\tstruct rdma_ucm_destroy_id_resp resp;\n\tstruct ucma_context *ctx;\n\tint ret = 0;\n\n\tif (out_len < sizeof(resp))\n\t\treturn -ENOSPC;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\txa_lock(&ctx_table);\n\tctx = _ucma_find_context(cmd.id, file);\n\tif (!IS_ERR(ctx)) {\n\t\tif (__xa_cmpxchg(&ctx_table, ctx->id, ctx, XA_ZERO_ENTRY,\n\t\t\t\t GFP_KERNEL) != ctx)\n\t\t\tctx = ERR_PTR(-ENOENT);\n\t}\n\txa_unlock(&ctx_table);\n\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\tresp.events_reported = ucma_destroy_private_ctx(ctx);\n\tif (copy_to_user(u64_to_user_ptr(cmd.response),\n\t\t\t &resp, sizeof(resp)))\n\t\tret = -EFAULT;\n\n\treturn ret;\n}\n\nstatic ssize_t ucma_bind_ip(struct ucma_file *file, const char __user *inbuf,\n\t\t\t      int in_len, int out_len)\n{\n\tstruct rdma_ucm_bind_ip cmd;\n\tstruct ucma_context *ctx;\n\tint ret;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tif (!rdma_addr_size_in6(&cmd.addr))\n\t\treturn -EINVAL;\n\n\tctx = ucma_get_ctx(file, cmd.id);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\tmutex_lock(&ctx->mutex);\n\tret = rdma_bind_addr(ctx->cm_id, (struct sockaddr *) &cmd.addr);\n\tmutex_unlock(&ctx->mutex);\n\n\tucma_put_ctx(ctx);\n\treturn ret;\n}\n\nstatic ssize_t ucma_bind(struct ucma_file *file, const char __user *inbuf,\n\t\t\t int in_len, int out_len)\n{\n\tstruct rdma_ucm_bind cmd;\n\tstruct ucma_context *ctx;\n\tint ret;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tif (cmd.reserved || !cmd.addr_size ||\n\t    cmd.addr_size != rdma_addr_size_kss(&cmd.addr))\n\t\treturn -EINVAL;\n\n\tctx = ucma_get_ctx(file, cmd.id);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\tmutex_lock(&ctx->mutex);\n\tret = rdma_bind_addr(ctx->cm_id, (struct sockaddr *) &cmd.addr);\n\tmutex_unlock(&ctx->mutex);\n\tucma_put_ctx(ctx);\n\treturn ret;\n}\n\nstatic ssize_t ucma_resolve_ip(struct ucma_file *file,\n\t\t\t       const char __user *inbuf,\n\t\t\t       int in_len, int out_len)\n{\n\tstruct rdma_ucm_resolve_ip cmd;\n\tstruct ucma_context *ctx;\n\tint ret;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tif ((cmd.src_addr.sin6_family && !rdma_addr_size_in6(&cmd.src_addr)) ||\n\t    !rdma_addr_size_in6(&cmd.dst_addr))\n\t\treturn -EINVAL;\n\n\tctx = ucma_get_ctx(file, cmd.id);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\tmutex_lock(&ctx->mutex);\n\tret = rdma_resolve_addr(ctx->cm_id, (struct sockaddr *) &cmd.src_addr,\n\t\t\t\t(struct sockaddr *) &cmd.dst_addr, cmd.timeout_ms);\n\tmutex_unlock(&ctx->mutex);\n\tucma_put_ctx(ctx);\n\treturn ret;\n}\n\nstatic ssize_t ucma_resolve_addr(struct ucma_file *file,\n\t\t\t\t const char __user *inbuf,\n\t\t\t\t int in_len, int out_len)\n{\n\tstruct rdma_ucm_resolve_addr cmd;\n\tstruct ucma_context *ctx;\n\tint ret;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tif (cmd.reserved ||\n\t    (cmd.src_size && (cmd.src_size != rdma_addr_size_kss(&cmd.src_addr))) ||\n\t    !cmd.dst_size || (cmd.dst_size != rdma_addr_size_kss(&cmd.dst_addr)))\n\t\treturn -EINVAL;\n\n\tctx = ucma_get_ctx(file, cmd.id);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\tmutex_lock(&ctx->mutex);\n\tret = rdma_resolve_addr(ctx->cm_id, (struct sockaddr *) &cmd.src_addr,\n\t\t\t\t(struct sockaddr *) &cmd.dst_addr, cmd.timeout_ms);\n\tmutex_unlock(&ctx->mutex);\n\tucma_put_ctx(ctx);\n\treturn ret;\n}\n\nstatic ssize_t ucma_resolve_route(struct ucma_file *file,\n\t\t\t\t  const char __user *inbuf,\n\t\t\t\t  int in_len, int out_len)\n{\n\tstruct rdma_ucm_resolve_route cmd;\n\tstruct ucma_context *ctx;\n\tint ret;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tctx = ucma_get_ctx_dev(file, cmd.id);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\tmutex_lock(&ctx->mutex);\n\tret = rdma_resolve_route(ctx->cm_id, cmd.timeout_ms);\n\tmutex_unlock(&ctx->mutex);\n\tucma_put_ctx(ctx);\n\treturn ret;\n}\n\nstatic void ucma_copy_ib_route(struct rdma_ucm_query_route_resp *resp,\n\t\t\t       struct rdma_route *route)\n{\n\tstruct rdma_dev_addr *dev_addr;\n\n\tresp->num_paths = route->num_pri_alt_paths;\n\tswitch (route->num_pri_alt_paths) {\n\tcase 0:\n\t\tdev_addr = &route->addr.dev_addr;\n\t\trdma_addr_get_dgid(dev_addr,\n\t\t\t\t   (union ib_gid *) &resp->ib_route[0].dgid);\n\t\trdma_addr_get_sgid(dev_addr,\n\t\t\t\t   (union ib_gid *) &resp->ib_route[0].sgid);\n\t\tresp->ib_route[0].pkey = cpu_to_be16(ib_addr_get_pkey(dev_addr));\n\t\tbreak;\n\tcase 2:\n\t\tib_copy_path_rec_to_user(&resp->ib_route[1],\n\t\t\t\t\t &route->path_rec[1]);\n\t\tfallthrough;\n\tcase 1:\n\t\tib_copy_path_rec_to_user(&resp->ib_route[0],\n\t\t\t\t\t &route->path_rec[0]);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void ucma_copy_iboe_route(struct rdma_ucm_query_route_resp *resp,\n\t\t\t\t struct rdma_route *route)\n{\n\n\tresp->num_paths = route->num_pri_alt_paths;\n\tswitch (route->num_pri_alt_paths) {\n\tcase 0:\n\t\trdma_ip2gid((struct sockaddr *)&route->addr.dst_addr,\n\t\t\t    (union ib_gid *)&resp->ib_route[0].dgid);\n\t\trdma_ip2gid((struct sockaddr *)&route->addr.src_addr,\n\t\t\t    (union ib_gid *)&resp->ib_route[0].sgid);\n\t\tresp->ib_route[0].pkey = cpu_to_be16(0xffff);\n\t\tbreak;\n\tcase 2:\n\t\tib_copy_path_rec_to_user(&resp->ib_route[1],\n\t\t\t\t\t &route->path_rec[1]);\n\t\tfallthrough;\n\tcase 1:\n\t\tib_copy_path_rec_to_user(&resp->ib_route[0],\n\t\t\t\t\t &route->path_rec[0]);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void ucma_copy_iw_route(struct rdma_ucm_query_route_resp *resp,\n\t\t\t       struct rdma_route *route)\n{\n\tstruct rdma_dev_addr *dev_addr;\n\n\tdev_addr = &route->addr.dev_addr;\n\trdma_addr_get_dgid(dev_addr, (union ib_gid *) &resp->ib_route[0].dgid);\n\trdma_addr_get_sgid(dev_addr, (union ib_gid *) &resp->ib_route[0].sgid);\n}\n\nstatic ssize_t ucma_query_route(struct ucma_file *file,\n\t\t\t\tconst char __user *inbuf,\n\t\t\t\tint in_len, int out_len)\n{\n\tstruct rdma_ucm_query cmd;\n\tstruct rdma_ucm_query_route_resp resp;\n\tstruct ucma_context *ctx;\n\tstruct sockaddr *addr;\n\tint ret = 0;\n\n\tif (out_len < offsetof(struct rdma_ucm_query_route_resp, ibdev_index))\n\t\treturn -ENOSPC;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tctx = ucma_get_ctx(file, cmd.id);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\tmutex_lock(&ctx->mutex);\n\tmemset(&resp, 0, sizeof resp);\n\taddr = (struct sockaddr *) &ctx->cm_id->route.addr.src_addr;\n\tmemcpy(&resp.src_addr, addr, addr->sa_family == AF_INET ?\n\t\t\t\t     sizeof(struct sockaddr_in) :\n\t\t\t\t     sizeof(struct sockaddr_in6));\n\taddr = (struct sockaddr *) &ctx->cm_id->route.addr.dst_addr;\n\tmemcpy(&resp.dst_addr, addr, addr->sa_family == AF_INET ?\n\t\t\t\t     sizeof(struct sockaddr_in) :\n\t\t\t\t     sizeof(struct sockaddr_in6));\n\tif (!ctx->cm_id->device)\n\t\tgoto out;\n\n\tresp.node_guid = (__force __u64) ctx->cm_id->device->node_guid;\n\tresp.ibdev_index = ctx->cm_id->device->index;\n\tresp.port_num = ctx->cm_id->port_num;\n\n\tif (rdma_cap_ib_sa(ctx->cm_id->device, ctx->cm_id->port_num))\n\t\tucma_copy_ib_route(&resp, &ctx->cm_id->route);\n\telse if (rdma_protocol_roce(ctx->cm_id->device, ctx->cm_id->port_num))\n\t\tucma_copy_iboe_route(&resp, &ctx->cm_id->route);\n\telse if (rdma_protocol_iwarp(ctx->cm_id->device, ctx->cm_id->port_num))\n\t\tucma_copy_iw_route(&resp, &ctx->cm_id->route);\n\nout:\n\tmutex_unlock(&ctx->mutex);\n\tif (copy_to_user(u64_to_user_ptr(cmd.response), &resp,\n\t\t\t min_t(size_t, out_len, sizeof(resp))))\n\t\tret = -EFAULT;\n\n\tucma_put_ctx(ctx);\n\treturn ret;\n}\n\nstatic void ucma_query_device_addr(struct rdma_cm_id *cm_id,\n\t\t\t\t   struct rdma_ucm_query_addr_resp *resp)\n{\n\tif (!cm_id->device)\n\t\treturn;\n\n\tresp->node_guid = (__force __u64) cm_id->device->node_guid;\n\tresp->ibdev_index = cm_id->device->index;\n\tresp->port_num = cm_id->port_num;\n\tresp->pkey = (__force __u16) cpu_to_be16(\n\t\t     ib_addr_get_pkey(&cm_id->route.addr.dev_addr));\n}\n\nstatic ssize_t ucma_query_addr(struct ucma_context *ctx,\n\t\t\t       void __user *response, int out_len)\n{\n\tstruct rdma_ucm_query_addr_resp resp;\n\tstruct sockaddr *addr;\n\tint ret = 0;\n\n\tif (out_len < offsetof(struct rdma_ucm_query_addr_resp, ibdev_index))\n\t\treturn -ENOSPC;\n\n\tmemset(&resp, 0, sizeof resp);\n\n\taddr = (struct sockaddr *) &ctx->cm_id->route.addr.src_addr;\n\tresp.src_size = rdma_addr_size(addr);\n\tmemcpy(&resp.src_addr, addr, resp.src_size);\n\n\taddr = (struct sockaddr *) &ctx->cm_id->route.addr.dst_addr;\n\tresp.dst_size = rdma_addr_size(addr);\n\tmemcpy(&resp.dst_addr, addr, resp.dst_size);\n\n\tucma_query_device_addr(ctx->cm_id, &resp);\n\n\tif (copy_to_user(response, &resp, min_t(size_t, out_len, sizeof(resp))))\n\t\tret = -EFAULT;\n\n\treturn ret;\n}\n\nstatic ssize_t ucma_query_path(struct ucma_context *ctx,\n\t\t\t       void __user *response, int out_len)\n{\n\tstruct rdma_ucm_query_path_resp *resp;\n\tint i, ret = 0;\n\n\tif (out_len < sizeof(*resp))\n\t\treturn -ENOSPC;\n\n\tresp = kzalloc(out_len, GFP_KERNEL);\n\tif (!resp)\n\t\treturn -ENOMEM;\n\n\tresp->num_paths = ctx->cm_id->route.num_pri_alt_paths;\n\tfor (i = 0, out_len -= sizeof(*resp);\n\t     i < resp->num_paths && out_len > sizeof(struct ib_path_rec_data);\n\t     i++, out_len -= sizeof(struct ib_path_rec_data)) {\n\t\tstruct sa_path_rec *rec = &ctx->cm_id->route.path_rec[i];\n\n\t\tresp->path_data[i].flags = IB_PATH_GMP | IB_PATH_PRIMARY |\n\t\t\t\t\t   IB_PATH_BIDIRECTIONAL;\n\t\tif (rec->rec_type == SA_PATH_REC_TYPE_OPA) {\n\t\t\tstruct sa_path_rec ib;\n\n\t\t\tsa_convert_path_opa_to_ib(&ib, rec);\n\t\t\tib_sa_pack_path(&ib, &resp->path_data[i].path_rec);\n\n\t\t} else {\n\t\t\tib_sa_pack_path(rec, &resp->path_data[i].path_rec);\n\t\t}\n\t}\n\n\tif (copy_to_user(response, resp, struct_size(resp, path_data, i)))\n\t\tret = -EFAULT;\n\n\tkfree(resp);\n\treturn ret;\n}\n\nstatic ssize_t ucma_query_gid(struct ucma_context *ctx,\n\t\t\t      void __user *response, int out_len)\n{\n\tstruct rdma_ucm_query_addr_resp resp;\n\tstruct sockaddr_ib *addr;\n\tint ret = 0;\n\n\tif (out_len < offsetof(struct rdma_ucm_query_addr_resp, ibdev_index))\n\t\treturn -ENOSPC;\n\n\tmemset(&resp, 0, sizeof resp);\n\n\tucma_query_device_addr(ctx->cm_id, &resp);\n\n\taddr = (struct sockaddr_ib *) &resp.src_addr;\n\tresp.src_size = sizeof(*addr);\n\tif (ctx->cm_id->route.addr.src_addr.ss_family == AF_IB) {\n\t\tmemcpy(addr, &ctx->cm_id->route.addr.src_addr, resp.src_size);\n\t} else {\n\t\taddr->sib_family = AF_IB;\n\t\taddr->sib_pkey = (__force __be16) resp.pkey;\n\t\trdma_read_gids(ctx->cm_id, (union ib_gid *)&addr->sib_addr,\n\t\t\t       NULL);\n\t\taddr->sib_sid = rdma_get_service_id(ctx->cm_id, (struct sockaddr *)\n\t\t\t\t\t\t    &ctx->cm_id->route.addr.src_addr);\n\t}\n\n\taddr = (struct sockaddr_ib *) &resp.dst_addr;\n\tresp.dst_size = sizeof(*addr);\n\tif (ctx->cm_id->route.addr.dst_addr.ss_family == AF_IB) {\n\t\tmemcpy(addr, &ctx->cm_id->route.addr.dst_addr, resp.dst_size);\n\t} else {\n\t\taddr->sib_family = AF_IB;\n\t\taddr->sib_pkey = (__force __be16) resp.pkey;\n\t\trdma_read_gids(ctx->cm_id, NULL,\n\t\t\t       (union ib_gid *)&addr->sib_addr);\n\t\taddr->sib_sid = rdma_get_service_id(ctx->cm_id, (struct sockaddr *)\n\t\t\t\t\t\t    &ctx->cm_id->route.addr.dst_addr);\n\t}\n\n\tif (copy_to_user(response, &resp, min_t(size_t, out_len, sizeof(resp))))\n\t\tret = -EFAULT;\n\n\treturn ret;\n}\n\nstatic ssize_t ucma_query(struct ucma_file *file,\n\t\t\t  const char __user *inbuf,\n\t\t\t  int in_len, int out_len)\n{\n\tstruct rdma_ucm_query cmd;\n\tstruct ucma_context *ctx;\n\tvoid __user *response;\n\tint ret;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tresponse = u64_to_user_ptr(cmd.response);\n\tctx = ucma_get_ctx(file, cmd.id);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\tmutex_lock(&ctx->mutex);\n\tswitch (cmd.option) {\n\tcase RDMA_USER_CM_QUERY_ADDR:\n\t\tret = ucma_query_addr(ctx, response, out_len);\n\t\tbreak;\n\tcase RDMA_USER_CM_QUERY_PATH:\n\t\tret = ucma_query_path(ctx, response, out_len);\n\t\tbreak;\n\tcase RDMA_USER_CM_QUERY_GID:\n\t\tret = ucma_query_gid(ctx, response, out_len);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOSYS;\n\t\tbreak;\n\t}\n\tmutex_unlock(&ctx->mutex);\n\n\tucma_put_ctx(ctx);\n\treturn ret;\n}\n\nstatic void ucma_copy_conn_param(struct rdma_cm_id *id,\n\t\t\t\t struct rdma_conn_param *dst,\n\t\t\t\t struct rdma_ucm_conn_param *src)\n{\n\tdst->private_data = src->private_data;\n\tdst->private_data_len = src->private_data_len;\n\tdst->responder_resources = src->responder_resources;\n\tdst->initiator_depth = src->initiator_depth;\n\tdst->flow_control = src->flow_control;\n\tdst->retry_count = src->retry_count;\n\tdst->rnr_retry_count = src->rnr_retry_count;\n\tdst->srq = src->srq;\n\tdst->qp_num = src->qp_num & 0xFFFFFF;\n\tdst->qkey = (id->route.addr.src_addr.ss_family == AF_IB) ? src->qkey : 0;\n}\n\nstatic ssize_t ucma_connect(struct ucma_file *file, const char __user *inbuf,\n\t\t\t    int in_len, int out_len)\n{\n\tstruct rdma_conn_param conn_param;\n\tstruct rdma_ucm_ece ece = {};\n\tstruct rdma_ucm_connect cmd;\n\tstruct ucma_context *ctx;\n\tsize_t in_size;\n\tint ret;\n\n\tif (in_len < offsetofend(typeof(cmd), reserved))\n\t\treturn -EINVAL;\n\tin_size = min_t(size_t, in_len, sizeof(cmd));\n\tif (copy_from_user(&cmd, inbuf, in_size))\n\t\treturn -EFAULT;\n\n\tif (!cmd.conn_param.valid)\n\t\treturn -EINVAL;\n\n\tctx = ucma_get_ctx_dev(file, cmd.id);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\tucma_copy_conn_param(ctx->cm_id, &conn_param, &cmd.conn_param);\n\tif (offsetofend(typeof(cmd), ece) <= in_size) {\n\t\tece.vendor_id = cmd.ece.vendor_id;\n\t\tece.attr_mod = cmd.ece.attr_mod;\n\t}\n\n\tmutex_lock(&ctx->mutex);\n\tret = rdma_connect_ece(ctx->cm_id, &conn_param, &ece);\n\tmutex_unlock(&ctx->mutex);\n\tucma_put_ctx(ctx);\n\treturn ret;\n}\n\nstatic ssize_t ucma_listen(struct ucma_file *file, const char __user *inbuf,\n\t\t\t   int in_len, int out_len)\n{\n\tstruct rdma_ucm_listen cmd;\n\tstruct ucma_context *ctx;\n\tint ret;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tctx = ucma_get_ctx(file, cmd.id);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\tif (cmd.backlog <= 0 || cmd.backlog > max_backlog)\n\t\tcmd.backlog = max_backlog;\n\tatomic_set(&ctx->backlog, cmd.backlog);\n\n\tmutex_lock(&ctx->mutex);\n\tret = rdma_listen(ctx->cm_id, cmd.backlog);\n\tmutex_unlock(&ctx->mutex);\n\tucma_put_ctx(ctx);\n\treturn ret;\n}\n\nstatic ssize_t ucma_accept(struct ucma_file *file, const char __user *inbuf,\n\t\t\t   int in_len, int out_len)\n{\n\tstruct rdma_ucm_accept cmd;\n\tstruct rdma_conn_param conn_param;\n\tstruct rdma_ucm_ece ece = {};\n\tstruct ucma_context *ctx;\n\tsize_t in_size;\n\tint ret;\n\n\tif (in_len < offsetofend(typeof(cmd), reserved))\n\t\treturn -EINVAL;\n\tin_size = min_t(size_t, in_len, sizeof(cmd));\n\tif (copy_from_user(&cmd, inbuf, in_size))\n\t\treturn -EFAULT;\n\n\tctx = ucma_get_ctx_dev(file, cmd.id);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\tif (offsetofend(typeof(cmd), ece) <= in_size) {\n\t\tece.vendor_id = cmd.ece.vendor_id;\n\t\tece.attr_mod = cmd.ece.attr_mod;\n\t}\n\n\tif (cmd.conn_param.valid) {\n\t\tucma_copy_conn_param(ctx->cm_id, &conn_param, &cmd.conn_param);\n\t\tmutex_lock(&ctx->mutex);\n\t\trdma_lock_handler(ctx->cm_id);\n\t\tret = rdma_accept_ece(ctx->cm_id, &conn_param, &ece);\n\t\tif (!ret) {\n\t\t\t \n\t\t\tctx->uid = cmd.uid;\n\t\t}\n\t\trdma_unlock_handler(ctx->cm_id);\n\t\tmutex_unlock(&ctx->mutex);\n\t} else {\n\t\tmutex_lock(&ctx->mutex);\n\t\trdma_lock_handler(ctx->cm_id);\n\t\tret = rdma_accept_ece(ctx->cm_id, NULL, &ece);\n\t\trdma_unlock_handler(ctx->cm_id);\n\t\tmutex_unlock(&ctx->mutex);\n\t}\n\tucma_put_ctx(ctx);\n\treturn ret;\n}\n\nstatic ssize_t ucma_reject(struct ucma_file *file, const char __user *inbuf,\n\t\t\t   int in_len, int out_len)\n{\n\tstruct rdma_ucm_reject cmd;\n\tstruct ucma_context *ctx;\n\tint ret;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tif (!cmd.reason)\n\t\tcmd.reason = IB_CM_REJ_CONSUMER_DEFINED;\n\n\tswitch (cmd.reason) {\n\tcase IB_CM_REJ_CONSUMER_DEFINED:\n\tcase IB_CM_REJ_VENDOR_OPTION_NOT_SUPPORTED:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tctx = ucma_get_ctx_dev(file, cmd.id);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\tmutex_lock(&ctx->mutex);\n\tret = rdma_reject(ctx->cm_id, cmd.private_data, cmd.private_data_len,\n\t\t\t  cmd.reason);\n\tmutex_unlock(&ctx->mutex);\n\tucma_put_ctx(ctx);\n\treturn ret;\n}\n\nstatic ssize_t ucma_disconnect(struct ucma_file *file, const char __user *inbuf,\n\t\t\t       int in_len, int out_len)\n{\n\tstruct rdma_ucm_disconnect cmd;\n\tstruct ucma_context *ctx;\n\tint ret;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tctx = ucma_get_ctx_dev(file, cmd.id);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\tmutex_lock(&ctx->mutex);\n\tret = rdma_disconnect(ctx->cm_id);\n\tmutex_unlock(&ctx->mutex);\n\tucma_put_ctx(ctx);\n\treturn ret;\n}\n\nstatic ssize_t ucma_init_qp_attr(struct ucma_file *file,\n\t\t\t\t const char __user *inbuf,\n\t\t\t\t int in_len, int out_len)\n{\n\tstruct rdma_ucm_init_qp_attr cmd;\n\tstruct ib_uverbs_qp_attr resp;\n\tstruct ucma_context *ctx;\n\tstruct ib_qp_attr qp_attr;\n\tint ret;\n\n\tif (out_len < sizeof(resp))\n\t\treturn -ENOSPC;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tif (cmd.qp_state > IB_QPS_ERR)\n\t\treturn -EINVAL;\n\n\tctx = ucma_get_ctx_dev(file, cmd.id);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\tresp.qp_attr_mask = 0;\n\tmemset(&qp_attr, 0, sizeof qp_attr);\n\tqp_attr.qp_state = cmd.qp_state;\n\tmutex_lock(&ctx->mutex);\n\tret = rdma_init_qp_attr(ctx->cm_id, &qp_attr, &resp.qp_attr_mask);\n\tmutex_unlock(&ctx->mutex);\n\tif (ret)\n\t\tgoto out;\n\n\tib_copy_qp_attr_to_user(ctx->cm_id->device, &resp, &qp_attr);\n\tif (copy_to_user(u64_to_user_ptr(cmd.response),\n\t\t\t &resp, sizeof(resp)))\n\t\tret = -EFAULT;\n\nout:\n\tucma_put_ctx(ctx);\n\treturn ret;\n}\n\nstatic int ucma_set_option_id(struct ucma_context *ctx, int optname,\n\t\t\t      void *optval, size_t optlen)\n{\n\tint ret = 0;\n\n\tswitch (optname) {\n\tcase RDMA_OPTION_ID_TOS:\n\t\tif (optlen != sizeof(u8)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\trdma_set_service_type(ctx->cm_id, *((u8 *) optval));\n\t\tbreak;\n\tcase RDMA_OPTION_ID_REUSEADDR:\n\t\tif (optlen != sizeof(int)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tret = rdma_set_reuseaddr(ctx->cm_id, *((int *) optval) ? 1 : 0);\n\t\tbreak;\n\tcase RDMA_OPTION_ID_AFONLY:\n\t\tif (optlen != sizeof(int)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tret = rdma_set_afonly(ctx->cm_id, *((int *) optval) ? 1 : 0);\n\t\tbreak;\n\tcase RDMA_OPTION_ID_ACK_TIMEOUT:\n\t\tif (optlen != sizeof(u8)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tret = rdma_set_ack_timeout(ctx->cm_id, *((u8 *)optval));\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOSYS;\n\t}\n\n\treturn ret;\n}\n\nstatic int ucma_set_ib_path(struct ucma_context *ctx,\n\t\t\t    struct ib_path_rec_data *path_data, size_t optlen)\n{\n\tstruct sa_path_rec sa_path;\n\tstruct rdma_cm_event event;\n\tint ret;\n\n\tif (optlen % sizeof(*path_data))\n\t\treturn -EINVAL;\n\n\tfor (; optlen; optlen -= sizeof(*path_data), path_data++) {\n\t\tif (path_data->flags == (IB_PATH_GMP | IB_PATH_PRIMARY |\n\t\t\t\t\t IB_PATH_BIDIRECTIONAL))\n\t\t\tbreak;\n\t}\n\n\tif (!optlen)\n\t\treturn -EINVAL;\n\n\tif (!ctx->cm_id->device)\n\t\treturn -EINVAL;\n\n\tmemset(&sa_path, 0, sizeof(sa_path));\n\n\tsa_path.rec_type = SA_PATH_REC_TYPE_IB;\n\tib_sa_unpack_path(path_data->path_rec, &sa_path);\n\n\tif (rdma_cap_opa_ah(ctx->cm_id->device, ctx->cm_id->port_num)) {\n\t\tstruct sa_path_rec opa;\n\n\t\tsa_convert_path_ib_to_opa(&opa, &sa_path);\n\t\tmutex_lock(&ctx->mutex);\n\t\tret = rdma_set_ib_path(ctx->cm_id, &opa);\n\t\tmutex_unlock(&ctx->mutex);\n\t} else {\n\t\tmutex_lock(&ctx->mutex);\n\t\tret = rdma_set_ib_path(ctx->cm_id, &sa_path);\n\t\tmutex_unlock(&ctx->mutex);\n\t}\n\tif (ret)\n\t\treturn ret;\n\n\tmemset(&event, 0, sizeof event);\n\tevent.event = RDMA_CM_EVENT_ROUTE_RESOLVED;\n\treturn ucma_event_handler(ctx->cm_id, &event);\n}\n\nstatic int ucma_set_option_ib(struct ucma_context *ctx, int optname,\n\t\t\t      void *optval, size_t optlen)\n{\n\tint ret;\n\n\tswitch (optname) {\n\tcase RDMA_OPTION_IB_PATH:\n\t\tret = ucma_set_ib_path(ctx, optval, optlen);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOSYS;\n\t}\n\n\treturn ret;\n}\n\nstatic int ucma_set_option_level(struct ucma_context *ctx, int level,\n\t\t\t\t int optname, void *optval, size_t optlen)\n{\n\tint ret;\n\n\tswitch (level) {\n\tcase RDMA_OPTION_ID:\n\t\tmutex_lock(&ctx->mutex);\n\t\tret = ucma_set_option_id(ctx, optname, optval, optlen);\n\t\tmutex_unlock(&ctx->mutex);\n\t\tbreak;\n\tcase RDMA_OPTION_IB:\n\t\tret = ucma_set_option_ib(ctx, optname, optval, optlen);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOSYS;\n\t}\n\n\treturn ret;\n}\n\nstatic ssize_t ucma_set_option(struct ucma_file *file, const char __user *inbuf,\n\t\t\t       int in_len, int out_len)\n{\n\tstruct rdma_ucm_set_option cmd;\n\tstruct ucma_context *ctx;\n\tvoid *optval;\n\tint ret;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tif (unlikely(cmd.optlen > KMALLOC_MAX_SIZE))\n\t\treturn -EINVAL;\n\n\tctx = ucma_get_ctx(file, cmd.id);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\toptval = memdup_user(u64_to_user_ptr(cmd.optval),\n\t\t\t     cmd.optlen);\n\tif (IS_ERR(optval)) {\n\t\tret = PTR_ERR(optval);\n\t\tgoto out;\n\t}\n\n\tret = ucma_set_option_level(ctx, cmd.level, cmd.optname, optval,\n\t\t\t\t    cmd.optlen);\n\tkfree(optval);\n\nout:\n\tucma_put_ctx(ctx);\n\treturn ret;\n}\n\nstatic ssize_t ucma_notify(struct ucma_file *file, const char __user *inbuf,\n\t\t\t   int in_len, int out_len)\n{\n\tstruct rdma_ucm_notify cmd;\n\tstruct ucma_context *ctx;\n\tint ret = -EINVAL;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tctx = ucma_get_ctx(file, cmd.id);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\tmutex_lock(&ctx->mutex);\n\tif (ctx->cm_id->device)\n\t\tret = rdma_notify(ctx->cm_id, (enum ib_event_type)cmd.event);\n\tmutex_unlock(&ctx->mutex);\n\n\tucma_put_ctx(ctx);\n\treturn ret;\n}\n\nstatic ssize_t ucma_process_join(struct ucma_file *file,\n\t\t\t\t struct rdma_ucm_join_mcast *cmd,  int out_len)\n{\n\tstruct rdma_ucm_create_id_resp resp;\n\tstruct ucma_context *ctx;\n\tstruct ucma_multicast *mc;\n\tstruct sockaddr *addr;\n\tint ret;\n\tu8 join_state;\n\n\tif (out_len < sizeof(resp))\n\t\treturn -ENOSPC;\n\n\taddr = (struct sockaddr *) &cmd->addr;\n\tif (cmd->addr_size != rdma_addr_size(addr))\n\t\treturn -EINVAL;\n\n\tif (cmd->join_flags == RDMA_MC_JOIN_FLAG_FULLMEMBER)\n\t\tjoin_state = BIT(FULLMEMBER_JOIN);\n\telse if (cmd->join_flags == RDMA_MC_JOIN_FLAG_SENDONLY_FULLMEMBER)\n\t\tjoin_state = BIT(SENDONLY_FULLMEMBER_JOIN);\n\telse\n\t\treturn -EINVAL;\n\n\tctx = ucma_get_ctx_dev(file, cmd->id);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\tmc = kzalloc(sizeof(*mc), GFP_KERNEL);\n\tif (!mc) {\n\t\tret = -ENOMEM;\n\t\tgoto err_put_ctx;\n\t}\n\n\tmc->ctx = ctx;\n\tmc->join_state = join_state;\n\tmc->uid = cmd->uid;\n\tmemcpy(&mc->addr, addr, cmd->addr_size);\n\n\txa_lock(&multicast_table);\n\tif (__xa_alloc(&multicast_table, &mc->id, NULL, xa_limit_32b,\n\t\t     GFP_KERNEL)) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_mc;\n\t}\n\n\tlist_add_tail(&mc->list, &ctx->mc_list);\n\txa_unlock(&multicast_table);\n\n\tmutex_lock(&ctx->mutex);\n\tret = rdma_join_multicast(ctx->cm_id, (struct sockaddr *)&mc->addr,\n\t\t\t\t  join_state, mc);\n\tmutex_unlock(&ctx->mutex);\n\tif (ret)\n\t\tgoto err_xa_erase;\n\n\tresp.id = mc->id;\n\tif (copy_to_user(u64_to_user_ptr(cmd->response),\n\t\t\t &resp, sizeof(resp))) {\n\t\tret = -EFAULT;\n\t\tgoto err_leave_multicast;\n\t}\n\n\txa_store(&multicast_table, mc->id, mc, 0);\n\n\tucma_put_ctx(ctx);\n\treturn 0;\n\nerr_leave_multicast:\n\tmutex_lock(&ctx->mutex);\n\trdma_leave_multicast(ctx->cm_id, (struct sockaddr *) &mc->addr);\n\tmutex_unlock(&ctx->mutex);\n\tucma_cleanup_mc_events(mc);\nerr_xa_erase:\n\txa_lock(&multicast_table);\n\tlist_del(&mc->list);\n\t__xa_erase(&multicast_table, mc->id);\nerr_free_mc:\n\txa_unlock(&multicast_table);\n\tkfree(mc);\nerr_put_ctx:\n\tucma_put_ctx(ctx);\n\treturn ret;\n}\n\nstatic ssize_t ucma_join_ip_multicast(struct ucma_file *file,\n\t\t\t\t      const char __user *inbuf,\n\t\t\t\t      int in_len, int out_len)\n{\n\tstruct rdma_ucm_join_ip_mcast cmd;\n\tstruct rdma_ucm_join_mcast join_cmd;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tjoin_cmd.response = cmd.response;\n\tjoin_cmd.uid = cmd.uid;\n\tjoin_cmd.id = cmd.id;\n\tjoin_cmd.addr_size = rdma_addr_size_in6(&cmd.addr);\n\tif (!join_cmd.addr_size)\n\t\treturn -EINVAL;\n\n\tjoin_cmd.join_flags = RDMA_MC_JOIN_FLAG_FULLMEMBER;\n\tmemcpy(&join_cmd.addr, &cmd.addr, join_cmd.addr_size);\n\n\treturn ucma_process_join(file, &join_cmd, out_len);\n}\n\nstatic ssize_t ucma_join_multicast(struct ucma_file *file,\n\t\t\t\t   const char __user *inbuf,\n\t\t\t\t   int in_len, int out_len)\n{\n\tstruct rdma_ucm_join_mcast cmd;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\tif (!rdma_addr_size_kss(&cmd.addr))\n\t\treturn -EINVAL;\n\n\treturn ucma_process_join(file, &cmd, out_len);\n}\n\nstatic ssize_t ucma_leave_multicast(struct ucma_file *file,\n\t\t\t\t    const char __user *inbuf,\n\t\t\t\t    int in_len, int out_len)\n{\n\tstruct rdma_ucm_destroy_id cmd;\n\tstruct rdma_ucm_destroy_id_resp resp;\n\tstruct ucma_multicast *mc;\n\tint ret = 0;\n\n\tif (out_len < sizeof(resp))\n\t\treturn -ENOSPC;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\txa_lock(&multicast_table);\n\tmc = xa_load(&multicast_table, cmd.id);\n\tif (!mc)\n\t\tmc = ERR_PTR(-ENOENT);\n\telse if (READ_ONCE(mc->ctx->file) != file)\n\t\tmc = ERR_PTR(-EINVAL);\n\telse if (!refcount_inc_not_zero(&mc->ctx->ref))\n\t\tmc = ERR_PTR(-ENXIO);\n\n\tif (IS_ERR(mc)) {\n\t\txa_unlock(&multicast_table);\n\t\tret = PTR_ERR(mc);\n\t\tgoto out;\n\t}\n\n\tlist_del(&mc->list);\n\t__xa_erase(&multicast_table, mc->id);\n\txa_unlock(&multicast_table);\n\n\tmutex_lock(&mc->ctx->mutex);\n\trdma_leave_multicast(mc->ctx->cm_id, (struct sockaddr *) &mc->addr);\n\tmutex_unlock(&mc->ctx->mutex);\n\n\tucma_cleanup_mc_events(mc);\n\n\tucma_put_ctx(mc->ctx);\n\tresp.events_reported = mc->events_reported;\n\tkfree(mc);\n\n\tif (copy_to_user(u64_to_user_ptr(cmd.response),\n\t\t\t &resp, sizeof(resp)))\n\t\tret = -EFAULT;\nout:\n\treturn ret;\n}\n\nstatic ssize_t ucma_migrate_id(struct ucma_file *new_file,\n\t\t\t       const char __user *inbuf,\n\t\t\t       int in_len, int out_len)\n{\n\tstruct rdma_ucm_migrate_id cmd;\n\tstruct rdma_ucm_migrate_resp resp;\n\tstruct ucma_event *uevent, *tmp;\n\tstruct ucma_context *ctx;\n\tLIST_HEAD(event_list);\n\tstruct fd f;\n\tstruct ucma_file *cur_file;\n\tint ret = 0;\n\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\n\t \n\tf = fdget(cmd.fd);\n\tif (!f.file)\n\t\treturn -ENOENT;\n\tif (f.file->f_op != &ucma_fops) {\n\t\tret = -EINVAL;\n\t\tgoto file_put;\n\t}\n\tcur_file = f.file->private_data;\n\n\t \n\tctx = ucma_get_ctx(cur_file, cmd.id);\n\tif (IS_ERR(ctx)) {\n\t\tret = PTR_ERR(ctx);\n\t\tgoto file_put;\n\t}\n\n\trdma_lock_handler(ctx->cm_id);\n\t \n\txa_lock(&ctx_table);\n\tif (_ucma_find_context(cmd.id, cur_file) != ctx) {\n\t\txa_unlock(&ctx_table);\n\t\tret = -ENOENT;\n\t\tgoto err_unlock;\n\t}\n\tctx->file = new_file;\n\txa_unlock(&ctx_table);\n\n\tmutex_lock(&cur_file->mut);\n\tlist_del(&ctx->list);\n\t \n\tlist_for_each_entry_safe(uevent, tmp, &cur_file->event_list, list)\n\t\tif (uevent->ctx == ctx)\n\t\t\tlist_move_tail(&uevent->list, &event_list);\n\tresp.events_reported = ctx->events_reported;\n\tmutex_unlock(&cur_file->mut);\n\n\tmutex_lock(&new_file->mut);\n\tlist_add_tail(&ctx->list, &new_file->ctx_list);\n\tlist_splice_tail(&event_list, &new_file->event_list);\n\tmutex_unlock(&new_file->mut);\n\n\tif (copy_to_user(u64_to_user_ptr(cmd.response),\n\t\t\t &resp, sizeof(resp)))\n\t\tret = -EFAULT;\n\nerr_unlock:\n\trdma_unlock_handler(ctx->cm_id);\n\tucma_put_ctx(ctx);\nfile_put:\n\tfdput(f);\n\treturn ret;\n}\n\nstatic ssize_t (*ucma_cmd_table[])(struct ucma_file *file,\n\t\t\t\t   const char __user *inbuf,\n\t\t\t\t   int in_len, int out_len) = {\n\t[RDMA_USER_CM_CMD_CREATE_ID] \t = ucma_create_id,\n\t[RDMA_USER_CM_CMD_DESTROY_ID]\t = ucma_destroy_id,\n\t[RDMA_USER_CM_CMD_BIND_IP]\t = ucma_bind_ip,\n\t[RDMA_USER_CM_CMD_RESOLVE_IP]\t = ucma_resolve_ip,\n\t[RDMA_USER_CM_CMD_RESOLVE_ROUTE] = ucma_resolve_route,\n\t[RDMA_USER_CM_CMD_QUERY_ROUTE]\t = ucma_query_route,\n\t[RDMA_USER_CM_CMD_CONNECT]\t = ucma_connect,\n\t[RDMA_USER_CM_CMD_LISTEN]\t = ucma_listen,\n\t[RDMA_USER_CM_CMD_ACCEPT]\t = ucma_accept,\n\t[RDMA_USER_CM_CMD_REJECT]\t = ucma_reject,\n\t[RDMA_USER_CM_CMD_DISCONNECT]\t = ucma_disconnect,\n\t[RDMA_USER_CM_CMD_INIT_QP_ATTR]\t = ucma_init_qp_attr,\n\t[RDMA_USER_CM_CMD_GET_EVENT]\t = ucma_get_event,\n\t[RDMA_USER_CM_CMD_GET_OPTION]\t = NULL,\n\t[RDMA_USER_CM_CMD_SET_OPTION]\t = ucma_set_option,\n\t[RDMA_USER_CM_CMD_NOTIFY]\t = ucma_notify,\n\t[RDMA_USER_CM_CMD_JOIN_IP_MCAST] = ucma_join_ip_multicast,\n\t[RDMA_USER_CM_CMD_LEAVE_MCAST]\t = ucma_leave_multicast,\n\t[RDMA_USER_CM_CMD_MIGRATE_ID]\t = ucma_migrate_id,\n\t[RDMA_USER_CM_CMD_QUERY]\t = ucma_query,\n\t[RDMA_USER_CM_CMD_BIND]\t\t = ucma_bind,\n\t[RDMA_USER_CM_CMD_RESOLVE_ADDR]\t = ucma_resolve_addr,\n\t[RDMA_USER_CM_CMD_JOIN_MCAST]\t = ucma_join_multicast\n};\n\nstatic ssize_t ucma_write(struct file *filp, const char __user *buf,\n\t\t\t  size_t len, loff_t *pos)\n{\n\tstruct ucma_file *file = filp->private_data;\n\tstruct rdma_ucm_cmd_hdr hdr;\n\tssize_t ret;\n\n\tif (!ib_safe_file_access(filp)) {\n\t\tpr_err_once(\"%s: process %d (%s) changed security contexts after opening file descriptor, this is not allowed.\\n\",\n\t\t\t    __func__, task_tgid_vnr(current), current->comm);\n\t\treturn -EACCES;\n\t}\n\n\tif (len < sizeof(hdr))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&hdr, buf, sizeof(hdr)))\n\t\treturn -EFAULT;\n\n\tif (hdr.cmd >= ARRAY_SIZE(ucma_cmd_table))\n\t\treturn -EINVAL;\n\thdr.cmd = array_index_nospec(hdr.cmd, ARRAY_SIZE(ucma_cmd_table));\n\n\tif (hdr.in + sizeof(hdr) > len)\n\t\treturn -EINVAL;\n\n\tif (!ucma_cmd_table[hdr.cmd])\n\t\treturn -ENOSYS;\n\n\tret = ucma_cmd_table[hdr.cmd](file, buf + sizeof(hdr), hdr.in, hdr.out);\n\tif (!ret)\n\t\tret = len;\n\n\treturn ret;\n}\n\nstatic __poll_t ucma_poll(struct file *filp, struct poll_table_struct *wait)\n{\n\tstruct ucma_file *file = filp->private_data;\n\t__poll_t mask = 0;\n\n\tpoll_wait(filp, &file->poll_wait, wait);\n\n\tif (!list_empty(&file->event_list))\n\t\tmask = EPOLLIN | EPOLLRDNORM;\n\n\treturn mask;\n}\n\n \nstatic int ucma_open(struct inode *inode, struct file *filp)\n{\n\tstruct ucma_file *file;\n\n\tfile = kmalloc(sizeof *file, GFP_KERNEL);\n\tif (!file)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&file->event_list);\n\tINIT_LIST_HEAD(&file->ctx_list);\n\tinit_waitqueue_head(&file->poll_wait);\n\tmutex_init(&file->mut);\n\n\tfilp->private_data = file;\n\tfile->filp = filp;\n\n\treturn stream_open(inode, filp);\n}\n\nstatic int ucma_close(struct inode *inode, struct file *filp)\n{\n\tstruct ucma_file *file = filp->private_data;\n\n\t \n\twhile (!list_empty(&file->ctx_list)) {\n\t\tstruct ucma_context *ctx = list_first_entry(\n\t\t\t&file->ctx_list, struct ucma_context, list);\n\n\t\tWARN_ON(xa_cmpxchg(&ctx_table, ctx->id, ctx, XA_ZERO_ENTRY,\n\t\t\t\t   GFP_KERNEL) != ctx);\n\t\tucma_destroy_private_ctx(ctx);\n\t}\n\tkfree(file);\n\treturn 0;\n}\n\nstatic const struct file_operations ucma_fops = {\n\t.owner \t = THIS_MODULE,\n\t.open \t = ucma_open,\n\t.release = ucma_close,\n\t.write\t = ucma_write,\n\t.poll    = ucma_poll,\n\t.llseek\t = no_llseek,\n};\n\nstatic struct miscdevice ucma_misc = {\n\t.minor\t\t= MISC_DYNAMIC_MINOR,\n\t.name\t\t= \"rdma_cm\",\n\t.nodename\t= \"infiniband/rdma_cm\",\n\t.mode\t\t= 0666,\n\t.fops\t\t= &ucma_fops,\n};\n\nstatic int ucma_get_global_nl_info(struct ib_client_nl_info *res)\n{\n\tres->abi = RDMA_USER_CM_ABI_VERSION;\n\tres->cdev = ucma_misc.this_device;\n\treturn 0;\n}\n\nstatic struct ib_client rdma_cma_client = {\n\t.name = \"rdma_cm\",\n\t.get_global_nl_info = ucma_get_global_nl_info,\n};\nMODULE_ALIAS_RDMA_CLIENT(\"rdma_cm\");\n\nstatic ssize_t abi_version_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", RDMA_USER_CM_ABI_VERSION);\n}\nstatic DEVICE_ATTR_RO(abi_version);\n\nstatic int __init ucma_init(void)\n{\n\tint ret;\n\n\tret = misc_register(&ucma_misc);\n\tif (ret)\n\t\treturn ret;\n\n\tret = device_create_file(ucma_misc.this_device, &dev_attr_abi_version);\n\tif (ret) {\n\t\tpr_err(\"rdma_ucm: couldn't create abi_version attr\\n\");\n\t\tgoto err1;\n\t}\n\n\tucma_ctl_table_hdr = register_net_sysctl(&init_net, \"net/rdma_ucm\", ucma_ctl_table);\n\tif (!ucma_ctl_table_hdr) {\n\t\tpr_err(\"rdma_ucm: couldn't register sysctl paths\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err2;\n\t}\n\n\tret = ib_register_client(&rdma_cma_client);\n\tif (ret)\n\t\tgoto err3;\n\n\treturn 0;\nerr3:\n\tunregister_net_sysctl_table(ucma_ctl_table_hdr);\nerr2:\n\tdevice_remove_file(ucma_misc.this_device, &dev_attr_abi_version);\nerr1:\n\tmisc_deregister(&ucma_misc);\n\treturn ret;\n}\n\nstatic void __exit ucma_cleanup(void)\n{\n\tib_unregister_client(&rdma_cma_client);\n\tunregister_net_sysctl_table(ucma_ctl_table_hdr);\n\tdevice_remove_file(ucma_misc.this_device, &dev_attr_abi_version);\n\tmisc_deregister(&ucma_misc);\n}\n\nmodule_init(ucma_init);\nmodule_exit(ucma_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}