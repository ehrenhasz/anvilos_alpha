{
  "module_name": "ud_header.c",
  "hash_id": "97f5e4d3428ed3d2ed496adce143639096722ea38999a465f39151875677c35c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/core/ud_header.c",
  "human_readable_source": " \n\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/if_ether.h>\n#include <linux/ip.h>\n\n#include <rdma/ib_pack.h>\n\n#define STRUCT_FIELD(header, field) \\\n\t.struct_offset_bytes = offsetof(struct ib_unpacked_ ## header, field),      \\\n\t.struct_size_bytes   = sizeof_field(struct ib_unpacked_ ## header, field), \\\n\t.field_name          = #header \":\" #field\n\nstatic const struct ib_field lrh_table[]  = {\n\t{ STRUCT_FIELD(lrh, virtual_lane),\n\t  .offset_words = 0,\n\t  .offset_bits  = 0,\n\t  .size_bits    = 4 },\n\t{ STRUCT_FIELD(lrh, link_version),\n\t  .offset_words = 0,\n\t  .offset_bits  = 4,\n\t  .size_bits    = 4 },\n\t{ STRUCT_FIELD(lrh, service_level),\n\t  .offset_words = 0,\n\t  .offset_bits  = 8,\n\t  .size_bits    = 4 },\n\t{ RESERVED,\n\t  .offset_words = 0,\n\t  .offset_bits  = 12,\n\t  .size_bits    = 2 },\n\t{ STRUCT_FIELD(lrh, link_next_header),\n\t  .offset_words = 0,\n\t  .offset_bits  = 14,\n\t  .size_bits    = 2 },\n\t{ STRUCT_FIELD(lrh, destination_lid),\n\t  .offset_words = 0,\n\t  .offset_bits  = 16,\n\t  .size_bits    = 16 },\n\t{ RESERVED,\n\t  .offset_words = 1,\n\t  .offset_bits  = 0,\n\t  .size_bits    = 5 },\n\t{ STRUCT_FIELD(lrh, packet_length),\n\t  .offset_words = 1,\n\t  .offset_bits  = 5,\n\t  .size_bits    = 11 },\n\t{ STRUCT_FIELD(lrh, source_lid),\n\t  .offset_words = 1,\n\t  .offset_bits  = 16,\n\t  .size_bits    = 16 }\n};\n\nstatic const struct ib_field eth_table[]  = {\n\t{ STRUCT_FIELD(eth, dmac_h),\n\t  .offset_words = 0,\n\t  .offset_bits  = 0,\n\t  .size_bits    = 32 },\n\t{ STRUCT_FIELD(eth, dmac_l),\n\t  .offset_words = 1,\n\t  .offset_bits  = 0,\n\t  .size_bits    = 16 },\n\t{ STRUCT_FIELD(eth, smac_h),\n\t  .offset_words = 1,\n\t  .offset_bits  = 16,\n\t  .size_bits    = 16 },\n\t{ STRUCT_FIELD(eth, smac_l),\n\t  .offset_words = 2,\n\t  .offset_bits  = 0,\n\t  .size_bits    = 32 },\n\t{ STRUCT_FIELD(eth, type),\n\t  .offset_words = 3,\n\t  .offset_bits  = 0,\n\t  .size_bits    = 16 }\n};\n\nstatic const struct ib_field vlan_table[]  = {\n\t{ STRUCT_FIELD(vlan, tag),\n\t  .offset_words = 0,\n\t  .offset_bits  = 0,\n\t  .size_bits    = 16 },\n\t{ STRUCT_FIELD(vlan, type),\n\t  .offset_words = 0,\n\t  .offset_bits  = 16,\n\t  .size_bits    = 16 }\n};\n\nstatic const struct ib_field ip4_table[]  = {\n\t{ STRUCT_FIELD(ip4, ver),\n\t  .offset_words = 0,\n\t  .offset_bits  = 0,\n\t  .size_bits    = 4 },\n\t{ STRUCT_FIELD(ip4, hdr_len),\n\t  .offset_words = 0,\n\t  .offset_bits  = 4,\n\t  .size_bits    = 4 },\n\t{ STRUCT_FIELD(ip4, tos),\n\t  .offset_words = 0,\n\t  .offset_bits  = 8,\n\t  .size_bits    = 8 },\n\t{ STRUCT_FIELD(ip4, tot_len),\n\t  .offset_words = 0,\n\t  .offset_bits  = 16,\n\t  .size_bits    = 16 },\n\t{ STRUCT_FIELD(ip4, id),\n\t  .offset_words = 1,\n\t  .offset_bits  = 0,\n\t  .size_bits    = 16 },\n\t{ STRUCT_FIELD(ip4, frag_off),\n\t  .offset_words = 1,\n\t  .offset_bits  = 16,\n\t  .size_bits    = 16 },\n\t{ STRUCT_FIELD(ip4, ttl),\n\t  .offset_words = 2,\n\t  .offset_bits  = 0,\n\t  .size_bits    = 8 },\n\t{ STRUCT_FIELD(ip4, protocol),\n\t  .offset_words = 2,\n\t  .offset_bits  = 8,\n\t  .size_bits    = 8 },\n\t{ STRUCT_FIELD(ip4, check),\n\t  .offset_words = 2,\n\t  .offset_bits  = 16,\n\t  .size_bits    = 16 },\n\t{ STRUCT_FIELD(ip4, saddr),\n\t  .offset_words = 3,\n\t  .offset_bits  = 0,\n\t  .size_bits    = 32 },\n\t{ STRUCT_FIELD(ip4, daddr),\n\t  .offset_words = 4,\n\t  .offset_bits  = 0,\n\t  .size_bits    = 32 }\n};\n\nstatic const struct ib_field udp_table[]  = {\n\t{ STRUCT_FIELD(udp, sport),\n\t  .offset_words = 0,\n\t  .offset_bits  = 0,\n\t  .size_bits    = 16 },\n\t{ STRUCT_FIELD(udp, dport),\n\t  .offset_words = 0,\n\t  .offset_bits  = 16,\n\t  .size_bits    = 16 },\n\t{ STRUCT_FIELD(udp, length),\n\t  .offset_words = 1,\n\t  .offset_bits  = 0,\n\t  .size_bits    = 16 },\n\t{ STRUCT_FIELD(udp, csum),\n\t  .offset_words = 1,\n\t  .offset_bits  = 16,\n\t  .size_bits    = 16 }\n};\n\nstatic const struct ib_field grh_table[]  = {\n\t{ STRUCT_FIELD(grh, ip_version),\n\t  .offset_words = 0,\n\t  .offset_bits  = 0,\n\t  .size_bits    = 4 },\n\t{ STRUCT_FIELD(grh, traffic_class),\n\t  .offset_words = 0,\n\t  .offset_bits  = 4,\n\t  .size_bits    = 8 },\n\t{ STRUCT_FIELD(grh, flow_label),\n\t  .offset_words = 0,\n\t  .offset_bits  = 12,\n\t  .size_bits    = 20 },\n\t{ STRUCT_FIELD(grh, payload_length),\n\t  .offset_words = 1,\n\t  .offset_bits  = 0,\n\t  .size_bits    = 16 },\n\t{ STRUCT_FIELD(grh, next_header),\n\t  .offset_words = 1,\n\t  .offset_bits  = 16,\n\t  .size_bits    = 8 },\n\t{ STRUCT_FIELD(grh, hop_limit),\n\t  .offset_words = 1,\n\t  .offset_bits  = 24,\n\t  .size_bits    = 8 },\n\t{ STRUCT_FIELD(grh, source_gid),\n\t  .offset_words = 2,\n\t  .offset_bits  = 0,\n\t  .size_bits    = 128 },\n\t{ STRUCT_FIELD(grh, destination_gid),\n\t  .offset_words = 6,\n\t  .offset_bits  = 0,\n\t  .size_bits    = 128 }\n};\n\nstatic const struct ib_field bth_table[]  = {\n\t{ STRUCT_FIELD(bth, opcode),\n\t  .offset_words = 0,\n\t  .offset_bits  = 0,\n\t  .size_bits    = 8 },\n\t{ STRUCT_FIELD(bth, solicited_event),\n\t  .offset_words = 0,\n\t  .offset_bits  = 8,\n\t  .size_bits    = 1 },\n\t{ STRUCT_FIELD(bth, mig_req),\n\t  .offset_words = 0,\n\t  .offset_bits  = 9,\n\t  .size_bits    = 1 },\n\t{ STRUCT_FIELD(bth, pad_count),\n\t  .offset_words = 0,\n\t  .offset_bits  = 10,\n\t  .size_bits    = 2 },\n\t{ STRUCT_FIELD(bth, transport_header_version),\n\t  .offset_words = 0,\n\t  .offset_bits  = 12,\n\t  .size_bits    = 4 },\n\t{ STRUCT_FIELD(bth, pkey),\n\t  .offset_words = 0,\n\t  .offset_bits  = 16,\n\t  .size_bits    = 16 },\n\t{ RESERVED,\n\t  .offset_words = 1,\n\t  .offset_bits  = 0,\n\t  .size_bits    = 8 },\n\t{ STRUCT_FIELD(bth, destination_qpn),\n\t  .offset_words = 1,\n\t  .offset_bits  = 8,\n\t  .size_bits    = 24 },\n\t{ STRUCT_FIELD(bth, ack_req),\n\t  .offset_words = 2,\n\t  .offset_bits  = 0,\n\t  .size_bits    = 1 },\n\t{ RESERVED,\n\t  .offset_words = 2,\n\t  .offset_bits  = 1,\n\t  .size_bits    = 7 },\n\t{ STRUCT_FIELD(bth, psn),\n\t  .offset_words = 2,\n\t  .offset_bits  = 8,\n\t  .size_bits    = 24 }\n};\n\nstatic const struct ib_field deth_table[] = {\n\t{ STRUCT_FIELD(deth, qkey),\n\t  .offset_words = 0,\n\t  .offset_bits  = 0,\n\t  .size_bits    = 32 },\n\t{ RESERVED,\n\t  .offset_words = 1,\n\t  .offset_bits  = 0,\n\t  .size_bits    = 8 },\n\t{ STRUCT_FIELD(deth, source_qpn),\n\t  .offset_words = 1,\n\t  .offset_bits  = 8,\n\t  .size_bits    = 24 }\n};\n\n__sum16 ib_ud_ip4_csum(struct ib_ud_header *header)\n{\n\tstruct iphdr iph;\n\n\tiph.ihl\t\t= 5;\n\tiph.version\t= 4;\n\tiph.tos\t\t= header->ip4.tos;\n\tiph.tot_len\t= header->ip4.tot_len;\n\tiph.id\t\t= header->ip4.id;\n\tiph.frag_off\t= header->ip4.frag_off;\n\tiph.ttl\t\t= header->ip4.ttl;\n\tiph.protocol\t= header->ip4.protocol;\n\tiph.check\t= 0;\n\tiph.saddr\t= header->ip4.saddr;\n\tiph.daddr\t= header->ip4.daddr;\n\n\treturn ip_fast_csum((u8 *)&iph, iph.ihl);\n}\nEXPORT_SYMBOL(ib_ud_ip4_csum);\n\n \nint ib_ud_header_init(int     payload_bytes,\n\t\t      int    lrh_present,\n\t\t      int    eth_present,\n\t\t      int    vlan_present,\n\t\t      int    grh_present,\n\t\t      int    ip_version,\n\t\t      int    udp_present,\n\t\t      int    immediate_present,\n\t\t      struct ib_ud_header *header)\n{\n\tsize_t udp_bytes = udp_present ? IB_UDP_BYTES : 0;\n\n\tgrh_present = grh_present && !ip_version;\n\tmemset(header, 0, sizeof *header);\n\n\t \n\tif (udp_present && ip_version != 4 && ip_version != 6)\n\t\treturn -EINVAL;\n\n\tif (lrh_present) {\n\t\tu16 packet_length;\n\n\t\theader->lrh.link_version     = 0;\n\t\theader->lrh.link_next_header =\n\t\t\tgrh_present ? IB_LNH_IBA_GLOBAL : IB_LNH_IBA_LOCAL;\n\t\tpacket_length = (IB_LRH_BYTES\t+\n\t\t\t\t IB_BTH_BYTES\t+\n\t\t\t\t IB_DETH_BYTES\t+\n\t\t\t\t (grh_present ? IB_GRH_BYTES : 0) +\n\t\t\t\t payload_bytes\t+\n\t\t\t\t 4\t\t+  \n\t\t\t\t 3) / 4;\t   \n\t\theader->lrh.packet_length = cpu_to_be16(packet_length);\n\t}\n\n\tif (vlan_present)\n\t\theader->eth.type = cpu_to_be16(ETH_P_8021Q);\n\n\tif (ip_version == 6 || grh_present) {\n\t\theader->grh.ip_version      = 6;\n\t\theader->grh.payload_length  =\n\t\t\tcpu_to_be16((udp_bytes        +\n\t\t\t\t     IB_BTH_BYTES     +\n\t\t\t\t     IB_DETH_BYTES    +\n\t\t\t\t     payload_bytes    +\n\t\t\t\t     4                +  \n\t\t\t\t     3) & ~3);           \n\t\theader->grh.next_header     = udp_present ? IPPROTO_UDP : 0x1b;\n\t}\n\n\tif (ip_version == 4) {\n\t\theader->ip4.ver = 4;  \n\t\theader->ip4.hdr_len = 5;  \n\t\theader->ip4.tot_len =\n\t\t\tcpu_to_be16(IB_IP4_BYTES   +\n\t\t\t\t     udp_bytes     +\n\t\t\t\t     IB_BTH_BYTES  +\n\t\t\t\t     IB_DETH_BYTES +\n\t\t\t\t     payload_bytes +\n\t\t\t\t     4);      \n\t\theader->ip4.protocol = IPPROTO_UDP;\n\t}\n\tif (udp_present && ip_version)\n\t\theader->udp.length =\n\t\t\tcpu_to_be16(IB_UDP_BYTES   +\n\t\t\t\t     IB_BTH_BYTES  +\n\t\t\t\t     IB_DETH_BYTES +\n\t\t\t\t     payload_bytes +\n\t\t\t\t     4);      \n\n\tif (immediate_present)\n\t\theader->bth.opcode           = IB_OPCODE_UD_SEND_ONLY_WITH_IMMEDIATE;\n\telse\n\t\theader->bth.opcode           = IB_OPCODE_UD_SEND_ONLY;\n\theader->bth.pad_count                = (4 - payload_bytes) & 3;\n\theader->bth.transport_header_version = 0;\n\n\theader->lrh_present = lrh_present;\n\theader->eth_present = eth_present;\n\theader->vlan_present = vlan_present;\n\theader->grh_present = grh_present || (ip_version == 6);\n\theader->ipv4_present = ip_version == 4;\n\theader->udp_present = udp_present;\n\theader->immediate_present = immediate_present;\n\treturn 0;\n}\nEXPORT_SYMBOL(ib_ud_header_init);\n\n \nint ib_ud_header_pack(struct ib_ud_header *header,\n\t\t      void                *buf)\n{\n\tint len = 0;\n\n\tif (header->lrh_present) {\n\t\tib_pack(lrh_table, ARRAY_SIZE(lrh_table),\n\t\t\t&header->lrh, buf + len);\n\t\tlen += IB_LRH_BYTES;\n\t}\n\tif (header->eth_present) {\n\t\tib_pack(eth_table, ARRAY_SIZE(eth_table),\n\t\t\t&header->eth, buf + len);\n\t\tlen += IB_ETH_BYTES;\n\t}\n\tif (header->vlan_present) {\n\t\tib_pack(vlan_table, ARRAY_SIZE(vlan_table),\n\t\t\t&header->vlan, buf + len);\n\t\tlen += IB_VLAN_BYTES;\n\t}\n\tif (header->grh_present) {\n\t\tib_pack(grh_table, ARRAY_SIZE(grh_table),\n\t\t\t&header->grh, buf + len);\n\t\tlen += IB_GRH_BYTES;\n\t}\n\tif (header->ipv4_present) {\n\t\tib_pack(ip4_table, ARRAY_SIZE(ip4_table),\n\t\t\t&header->ip4, buf + len);\n\t\tlen += IB_IP4_BYTES;\n\t}\n\tif (header->udp_present) {\n\t\tib_pack(udp_table, ARRAY_SIZE(udp_table),\n\t\t\t&header->udp, buf + len);\n\t\tlen += IB_UDP_BYTES;\n\t}\n\n\tib_pack(bth_table, ARRAY_SIZE(bth_table),\n\t\t&header->bth, buf + len);\n\tlen += IB_BTH_BYTES;\n\n\tib_pack(deth_table, ARRAY_SIZE(deth_table),\n\t\t&header->deth, buf + len);\n\tlen += IB_DETH_BYTES;\n\n\tif (header->immediate_present) {\n\t\tmemcpy(buf + len, &header->immediate_data, sizeof header->immediate_data);\n\t\tlen += sizeof header->immediate_data;\n\t}\n\n\treturn len;\n}\nEXPORT_SYMBOL(ib_ud_header_pack);\n\n \nint ib_ud_header_unpack(void                *buf,\n\t\t\tstruct ib_ud_header *header)\n{\n\tib_unpack(lrh_table, ARRAY_SIZE(lrh_table),\n\t\t  buf, &header->lrh);\n\tbuf += IB_LRH_BYTES;\n\n\tif (header->lrh.link_version != 0) {\n\t\tpr_warn(\"Invalid LRH.link_version %u\\n\",\n\t\t\theader->lrh.link_version);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (header->lrh.link_next_header) {\n\tcase IB_LNH_IBA_LOCAL:\n\t\theader->grh_present = 0;\n\t\tbreak;\n\n\tcase IB_LNH_IBA_GLOBAL:\n\t\theader->grh_present = 1;\n\t\tib_unpack(grh_table, ARRAY_SIZE(grh_table),\n\t\t\t  buf, &header->grh);\n\t\tbuf += IB_GRH_BYTES;\n\n\t\tif (header->grh.ip_version != 6) {\n\t\t\tpr_warn(\"Invalid GRH.ip_version %u\\n\",\n\t\t\t\theader->grh.ip_version);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (header->grh.next_header != 0x1b) {\n\t\t\tpr_warn(\"Invalid GRH.next_header 0x%02x\\n\",\n\t\t\t\theader->grh.next_header);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tpr_warn(\"Invalid LRH.link_next_header %u\\n\",\n\t\t\theader->lrh.link_next_header);\n\t\treturn -EINVAL;\n\t}\n\n\tib_unpack(bth_table, ARRAY_SIZE(bth_table),\n\t\t  buf, &header->bth);\n\tbuf += IB_BTH_BYTES;\n\n\tswitch (header->bth.opcode) {\n\tcase IB_OPCODE_UD_SEND_ONLY:\n\t\theader->immediate_present = 0;\n\t\tbreak;\n\tcase IB_OPCODE_UD_SEND_ONLY_WITH_IMMEDIATE:\n\t\theader->immediate_present = 1;\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"Invalid BTH.opcode 0x%02x\\n\", header->bth.opcode);\n\t\treturn -EINVAL;\n\t}\n\n\tif (header->bth.transport_header_version != 0) {\n\t\tpr_warn(\"Invalid BTH.transport_header_version %u\\n\",\n\t\t\theader->bth.transport_header_version);\n\t\treturn -EINVAL;\n\t}\n\n\tib_unpack(deth_table, ARRAY_SIZE(deth_table),\n\t\t  buf, &header->deth);\n\tbuf += IB_DETH_BYTES;\n\n\tif (header->immediate_present)\n\t\tmemcpy(&header->immediate_data, buf, sizeof header->immediate_data);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ib_ud_header_unpack);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}