{
  "module_name": "iwpm_util.c",
  "hash_id": "02169c900b9b4caa60996e890fcb83c4339625163062d3867a3fa9caed02dca9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/core/iwpm_util.c",
  "human_readable_source": " \n\n#include \"iwpm_util.h\"\n\n#define IWPM_MAPINFO_HASH_SIZE\t512\n#define IWPM_MAPINFO_HASH_MASK\t(IWPM_MAPINFO_HASH_SIZE - 1)\n#define IWPM_REMINFO_HASH_SIZE\t64\n#define IWPM_REMINFO_HASH_MASK\t(IWPM_REMINFO_HASH_SIZE - 1)\n#define IWPM_MSG_SIZE\t\t512\n\nstatic LIST_HEAD(iwpm_nlmsg_req_list);\nstatic DEFINE_SPINLOCK(iwpm_nlmsg_req_lock);\n\nstatic struct hlist_head *iwpm_hash_bucket;\nstatic DEFINE_SPINLOCK(iwpm_mapinfo_lock);\n\nstatic struct hlist_head *iwpm_reminfo_bucket;\nstatic DEFINE_SPINLOCK(iwpm_reminfo_lock);\n\nstatic struct iwpm_admin_data iwpm_admin;\n\n \nint iwpm_init(u8 nl_client)\n{\n\tiwpm_hash_bucket = kcalloc(IWPM_MAPINFO_HASH_SIZE,\n\t\t\t\t   sizeof(struct hlist_head), GFP_KERNEL);\n\tif (!iwpm_hash_bucket)\n\t\treturn -ENOMEM;\n\n\tiwpm_reminfo_bucket = kcalloc(IWPM_REMINFO_HASH_SIZE,\n\t\t\t\t      sizeof(struct hlist_head), GFP_KERNEL);\n\tif (!iwpm_reminfo_bucket) {\n\t\tkfree(iwpm_hash_bucket);\n\t\treturn -ENOMEM;\n\t}\n\n\tiwpm_set_registration(nl_client, IWPM_REG_UNDEF);\n\tpr_debug(\"%s: Mapinfo and reminfo tables are created\\n\", __func__);\n\treturn 0;\n}\n\nstatic void free_hash_bucket(void);\nstatic void free_reminfo_bucket(void);\n\n \nint iwpm_exit(u8 nl_client)\n{\n\tfree_hash_bucket();\n\tfree_reminfo_bucket();\n\tpr_debug(\"%s: Resources are destroyed\\n\", __func__);\n\tiwpm_set_registration(nl_client, IWPM_REG_UNDEF);\n\treturn 0;\n}\n\nstatic struct hlist_head *get_mapinfo_hash_bucket(struct sockaddr_storage *,\n\t\t\t\t\t       struct sockaddr_storage *);\n\n \nint iwpm_create_mapinfo(struct sockaddr_storage *local_sockaddr,\n\t\t\tstruct sockaddr_storage *mapped_sockaddr,\n\t\t\tu8 nl_client, u32 map_flags)\n{\n\tstruct hlist_head *hash_bucket_head = NULL;\n\tstruct iwpm_mapping_info *map_info;\n\tunsigned long flags;\n\tint ret = -EINVAL;\n\n\tmap_info = kzalloc(sizeof(struct iwpm_mapping_info), GFP_KERNEL);\n\tif (!map_info)\n\t\treturn -ENOMEM;\n\n\tmemcpy(&map_info->local_sockaddr, local_sockaddr,\n\t       sizeof(struct sockaddr_storage));\n\tmemcpy(&map_info->mapped_sockaddr, mapped_sockaddr,\n\t       sizeof(struct sockaddr_storage));\n\tmap_info->nl_client = nl_client;\n\tmap_info->map_flags = map_flags;\n\n\tspin_lock_irqsave(&iwpm_mapinfo_lock, flags);\n\tif (iwpm_hash_bucket) {\n\t\thash_bucket_head = get_mapinfo_hash_bucket(\n\t\t\t\t\t&map_info->local_sockaddr,\n\t\t\t\t\t&map_info->mapped_sockaddr);\n\t\tif (hash_bucket_head) {\n\t\t\thlist_add_head(&map_info->hlist_node, hash_bucket_head);\n\t\t\tret = 0;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&iwpm_mapinfo_lock, flags);\n\n\tif (!hash_bucket_head)\n\t\tkfree(map_info);\n\treturn ret;\n}\n\n \nint iwpm_remove_mapinfo(struct sockaddr_storage *local_sockaddr,\n\t\t\tstruct sockaddr_storage *mapped_local_addr)\n{\n\tstruct hlist_node *tmp_hlist_node;\n\tstruct hlist_head *hash_bucket_head;\n\tstruct iwpm_mapping_info *map_info = NULL;\n\tunsigned long flags;\n\tint ret = -EINVAL;\n\n\tspin_lock_irqsave(&iwpm_mapinfo_lock, flags);\n\tif (iwpm_hash_bucket) {\n\t\thash_bucket_head = get_mapinfo_hash_bucket(\n\t\t\t\t\tlocal_sockaddr,\n\t\t\t\t\tmapped_local_addr);\n\t\tif (!hash_bucket_head)\n\t\t\tgoto remove_mapinfo_exit;\n\n\t\thlist_for_each_entry_safe(map_info, tmp_hlist_node,\n\t\t\t\t\thash_bucket_head, hlist_node) {\n\n\t\t\tif (!iwpm_compare_sockaddr(&map_info->mapped_sockaddr,\n\t\t\t\t\t\tmapped_local_addr)) {\n\n\t\t\t\thlist_del_init(&map_info->hlist_node);\n\t\t\t\tkfree(map_info);\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\nremove_mapinfo_exit:\n\tspin_unlock_irqrestore(&iwpm_mapinfo_lock, flags);\n\treturn ret;\n}\n\nstatic void free_hash_bucket(void)\n{\n\tstruct hlist_node *tmp_hlist_node;\n\tstruct iwpm_mapping_info *map_info;\n\tunsigned long flags;\n\tint i;\n\n\t \n\tspin_lock_irqsave(&iwpm_mapinfo_lock, flags);\n\tfor (i = 0; i < IWPM_MAPINFO_HASH_SIZE; i++) {\n\t\thlist_for_each_entry_safe(map_info, tmp_hlist_node,\n\t\t\t&iwpm_hash_bucket[i], hlist_node) {\n\n\t\t\t\thlist_del_init(&map_info->hlist_node);\n\t\t\t\tkfree(map_info);\n\t\t\t}\n\t}\n\t \n\tkfree(iwpm_hash_bucket);\n\tiwpm_hash_bucket = NULL;\n\tspin_unlock_irqrestore(&iwpm_mapinfo_lock, flags);\n}\n\nstatic void free_reminfo_bucket(void)\n{\n\tstruct hlist_node *tmp_hlist_node;\n\tstruct iwpm_remote_info *rem_info;\n\tunsigned long flags;\n\tint i;\n\n\t \n\tspin_lock_irqsave(&iwpm_reminfo_lock, flags);\n\tfor (i = 0; i < IWPM_REMINFO_HASH_SIZE; i++) {\n\t\thlist_for_each_entry_safe(rem_info, tmp_hlist_node,\n\t\t\t&iwpm_reminfo_bucket[i], hlist_node) {\n\n\t\t\t\thlist_del_init(&rem_info->hlist_node);\n\t\t\t\tkfree(rem_info);\n\t\t\t}\n\t}\n\t \n\tkfree(iwpm_reminfo_bucket);\n\tiwpm_reminfo_bucket = NULL;\n\tspin_unlock_irqrestore(&iwpm_reminfo_lock, flags);\n}\n\nstatic struct hlist_head *get_reminfo_hash_bucket(struct sockaddr_storage *,\n\t\t\t\t\t\tstruct sockaddr_storage *);\n\nvoid iwpm_add_remote_info(struct iwpm_remote_info *rem_info)\n{\n\tstruct hlist_head *hash_bucket_head;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&iwpm_reminfo_lock, flags);\n\tif (iwpm_reminfo_bucket) {\n\t\thash_bucket_head = get_reminfo_hash_bucket(\n\t\t\t\t\t&rem_info->mapped_loc_sockaddr,\n\t\t\t\t\t&rem_info->mapped_rem_sockaddr);\n\t\tif (hash_bucket_head)\n\t\t\thlist_add_head(&rem_info->hlist_node, hash_bucket_head);\n\t}\n\tspin_unlock_irqrestore(&iwpm_reminfo_lock, flags);\n}\n\n \nint iwpm_get_remote_info(struct sockaddr_storage *mapped_loc_addr,\n\t\t\t struct sockaddr_storage *mapped_rem_addr,\n\t\t\t struct sockaddr_storage *remote_addr,\n\t\t\t u8 nl_client)\n{\n\tstruct hlist_node *tmp_hlist_node;\n\tstruct hlist_head *hash_bucket_head;\n\tstruct iwpm_remote_info *rem_info = NULL;\n\tunsigned long flags;\n\tint ret = -EINVAL;\n\n\tspin_lock_irqsave(&iwpm_reminfo_lock, flags);\n\tif (iwpm_reminfo_bucket) {\n\t\thash_bucket_head = get_reminfo_hash_bucket(\n\t\t\t\t\tmapped_loc_addr,\n\t\t\t\t\tmapped_rem_addr);\n\t\tif (!hash_bucket_head)\n\t\t\tgoto get_remote_info_exit;\n\t\thlist_for_each_entry_safe(rem_info, tmp_hlist_node,\n\t\t\t\t\thash_bucket_head, hlist_node) {\n\n\t\t\tif (!iwpm_compare_sockaddr(&rem_info->mapped_loc_sockaddr,\n\t\t\t\tmapped_loc_addr) &&\n\t\t\t\t!iwpm_compare_sockaddr(&rem_info->mapped_rem_sockaddr,\n\t\t\t\tmapped_rem_addr)) {\n\n\t\t\t\tmemcpy(remote_addr, &rem_info->remote_sockaddr,\n\t\t\t\t\tsizeof(struct sockaddr_storage));\n\t\t\t\tiwpm_print_sockaddr(remote_addr,\n\t\t\t\t\t\t\"get_remote_info: Remote sockaddr:\");\n\n\t\t\t\thlist_del_init(&rem_info->hlist_node);\n\t\t\t\tkfree(rem_info);\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\nget_remote_info_exit:\n\tspin_unlock_irqrestore(&iwpm_reminfo_lock, flags);\n\treturn ret;\n}\n\nstruct iwpm_nlmsg_request *iwpm_get_nlmsg_request(__u32 nlmsg_seq,\n\t\t\t\t\tu8 nl_client, gfp_t gfp)\n{\n\tstruct iwpm_nlmsg_request *nlmsg_request;\n\tunsigned long flags;\n\n\tnlmsg_request = kzalloc(sizeof(struct iwpm_nlmsg_request), gfp);\n\tif (!nlmsg_request)\n\t\treturn NULL;\n\n\tspin_lock_irqsave(&iwpm_nlmsg_req_lock, flags);\n\tlist_add_tail(&nlmsg_request->inprocess_list, &iwpm_nlmsg_req_list);\n\tspin_unlock_irqrestore(&iwpm_nlmsg_req_lock, flags);\n\n\tkref_init(&nlmsg_request->kref);\n\tkref_get(&nlmsg_request->kref);\n\tnlmsg_request->nlmsg_seq = nlmsg_seq;\n\tnlmsg_request->nl_client = nl_client;\n\tnlmsg_request->request_done = 0;\n\tnlmsg_request->err_code = 0;\n\tsema_init(&nlmsg_request->sem, 1);\n\tdown(&nlmsg_request->sem);\n\treturn nlmsg_request;\n}\n\nvoid iwpm_free_nlmsg_request(struct kref *kref)\n{\n\tstruct iwpm_nlmsg_request *nlmsg_request;\n\tunsigned long flags;\n\n\tnlmsg_request = container_of(kref, struct iwpm_nlmsg_request, kref);\n\n\tspin_lock_irqsave(&iwpm_nlmsg_req_lock, flags);\n\tlist_del_init(&nlmsg_request->inprocess_list);\n\tspin_unlock_irqrestore(&iwpm_nlmsg_req_lock, flags);\n\n\tif (!nlmsg_request->request_done)\n\t\tpr_debug(\"%s Freeing incomplete nlmsg request (seq = %u).\\n\",\n\t\t\t__func__, nlmsg_request->nlmsg_seq);\n\tkfree(nlmsg_request);\n}\n\nstruct iwpm_nlmsg_request *iwpm_find_nlmsg_request(__u32 echo_seq)\n{\n\tstruct iwpm_nlmsg_request *nlmsg_request;\n\tstruct iwpm_nlmsg_request *found_request = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&iwpm_nlmsg_req_lock, flags);\n\tlist_for_each_entry(nlmsg_request, &iwpm_nlmsg_req_list,\n\t\t\t    inprocess_list) {\n\t\tif (nlmsg_request->nlmsg_seq == echo_seq) {\n\t\t\tfound_request = nlmsg_request;\n\t\t\tkref_get(&nlmsg_request->kref);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&iwpm_nlmsg_req_lock, flags);\n\treturn found_request;\n}\n\nint iwpm_wait_complete_req(struct iwpm_nlmsg_request *nlmsg_request)\n{\n\tint ret;\n\n\tret = down_timeout(&nlmsg_request->sem, IWPM_NL_TIMEOUT);\n\tif (ret) {\n\t\tret = -EINVAL;\n\t\tpr_info(\"%s: Timeout %d sec for netlink request (seq = %u)\\n\",\n\t\t\t__func__, (IWPM_NL_TIMEOUT/HZ), nlmsg_request->nlmsg_seq);\n\t} else {\n\t\tret = nlmsg_request->err_code;\n\t}\n\tkref_put(&nlmsg_request->kref, iwpm_free_nlmsg_request);\n\treturn ret;\n}\n\nint iwpm_get_nlmsg_seq(void)\n{\n\treturn atomic_inc_return(&iwpm_admin.nlmsg_seq);\n}\n\n \nu32 iwpm_get_registration(u8 nl_client)\n{\n\treturn iwpm_admin.reg_list[nl_client];\n}\n\n \nvoid iwpm_set_registration(u8 nl_client, u32 reg)\n{\n\tiwpm_admin.reg_list[nl_client] = reg;\n}\n\n \nu32 iwpm_check_registration(u8 nl_client, u32 reg)\n{\n\treturn (iwpm_get_registration(nl_client) & reg);\n}\n\nint iwpm_compare_sockaddr(struct sockaddr_storage *a_sockaddr,\n\t\t\t\tstruct sockaddr_storage *b_sockaddr)\n{\n\tif (a_sockaddr->ss_family != b_sockaddr->ss_family)\n\t\treturn 1;\n\tif (a_sockaddr->ss_family == AF_INET) {\n\t\tstruct sockaddr_in *a4_sockaddr =\n\t\t\t(struct sockaddr_in *)a_sockaddr;\n\t\tstruct sockaddr_in *b4_sockaddr =\n\t\t\t(struct sockaddr_in *)b_sockaddr;\n\t\tif (!memcmp(&a4_sockaddr->sin_addr,\n\t\t\t&b4_sockaddr->sin_addr, sizeof(struct in_addr))\n\t\t\t&& a4_sockaddr->sin_port == b4_sockaddr->sin_port)\n\t\t\t\treturn 0;\n\n\t} else if (a_sockaddr->ss_family == AF_INET6) {\n\t\tstruct sockaddr_in6 *a6_sockaddr =\n\t\t\t(struct sockaddr_in6 *)a_sockaddr;\n\t\tstruct sockaddr_in6 *b6_sockaddr =\n\t\t\t(struct sockaddr_in6 *)b_sockaddr;\n\t\tif (!memcmp(&a6_sockaddr->sin6_addr,\n\t\t\t&b6_sockaddr->sin6_addr, sizeof(struct in6_addr))\n\t\t\t&& a6_sockaddr->sin6_port == b6_sockaddr->sin6_port)\n\t\t\t\treturn 0;\n\n\t} else {\n\t\tpr_err(\"%s: Invalid sockaddr family\\n\", __func__);\n\t}\n\treturn 1;\n}\n\nstruct sk_buff *iwpm_create_nlmsg(u32 nl_op, struct nlmsghdr **nlh,\n\t\t\t\t\t\tint nl_client)\n{\n\tstruct sk_buff *skb = NULL;\n\n\tskb = dev_alloc_skb(IWPM_MSG_SIZE);\n\tif (!skb)\n\t\tgoto create_nlmsg_exit;\n\n\tif (!(ibnl_put_msg(skb, nlh, 0, 0, nl_client, nl_op,\n\t\t\t   NLM_F_REQUEST))) {\n\t\tpr_warn(\"%s: Unable to put the nlmsg header\\n\", __func__);\n\t\tdev_kfree_skb(skb);\n\t\tskb = NULL;\n\t}\ncreate_nlmsg_exit:\n\treturn skb;\n}\n\nint iwpm_parse_nlmsg(struct netlink_callback *cb, int policy_max,\n\t\t\t\t   const struct nla_policy *nlmsg_policy,\n\t\t\t\t   struct nlattr *nltb[], const char *msg_type)\n{\n\tint nlh_len = 0;\n\tint ret;\n\tconst char *err_str = \"\";\n\n\tret = nlmsg_validate_deprecated(cb->nlh, nlh_len, policy_max - 1,\n\t\t\t\t\tnlmsg_policy, NULL);\n\tif (ret) {\n\t\terr_str = \"Invalid attribute\";\n\t\tgoto parse_nlmsg_error;\n\t}\n\tret = nlmsg_parse_deprecated(cb->nlh, nlh_len, nltb, policy_max - 1,\n\t\t\t\t     nlmsg_policy, NULL);\n\tif (ret) {\n\t\terr_str = \"Unable to parse the nlmsg\";\n\t\tgoto parse_nlmsg_error;\n\t}\n\tret = iwpm_validate_nlmsg_attr(nltb, policy_max);\n\tif (ret) {\n\t\terr_str = \"Invalid NULL attribute\";\n\t\tgoto parse_nlmsg_error;\n\t}\n\treturn 0;\nparse_nlmsg_error:\n\tpr_warn(\"%s: %s (msg type %s ret = %d)\\n\",\n\t\t\t__func__, err_str, msg_type, ret);\n\treturn ret;\n}\n\nvoid iwpm_print_sockaddr(struct sockaddr_storage *sockaddr, char *msg)\n{\n\tstruct sockaddr_in6 *sockaddr_v6;\n\tstruct sockaddr_in *sockaddr_v4;\n\n\tswitch (sockaddr->ss_family) {\n\tcase AF_INET:\n\t\tsockaddr_v4 = (struct sockaddr_in *)sockaddr;\n\t\tpr_debug(\"%s IPV4 %pI4: %u(0x%04X)\\n\",\n\t\t\tmsg, &sockaddr_v4->sin_addr,\n\t\t\tntohs(sockaddr_v4->sin_port),\n\t\t\tntohs(sockaddr_v4->sin_port));\n\t\tbreak;\n\tcase AF_INET6:\n\t\tsockaddr_v6 = (struct sockaddr_in6 *)sockaddr;\n\t\tpr_debug(\"%s IPV6 %pI6: %u(0x%04X)\\n\",\n\t\t\tmsg, &sockaddr_v6->sin6_addr,\n\t\t\tntohs(sockaddr_v6->sin6_port),\n\t\t\tntohs(sockaddr_v6->sin6_port));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic u32 iwpm_ipv6_jhash(struct sockaddr_in6 *ipv6_sockaddr)\n{\n\tu32 ipv6_hash = jhash(&ipv6_sockaddr->sin6_addr, sizeof(struct in6_addr), 0);\n\tu32 hash = jhash_2words(ipv6_hash, (__force u32) ipv6_sockaddr->sin6_port, 0);\n\treturn hash;\n}\n\nstatic u32 iwpm_ipv4_jhash(struct sockaddr_in *ipv4_sockaddr)\n{\n\tu32 ipv4_hash = jhash(&ipv4_sockaddr->sin_addr, sizeof(struct in_addr), 0);\n\tu32 hash = jhash_2words(ipv4_hash, (__force u32) ipv4_sockaddr->sin_port, 0);\n\treturn hash;\n}\n\nstatic int get_hash_bucket(struct sockaddr_storage *a_sockaddr,\n\t\t\t\tstruct sockaddr_storage *b_sockaddr, u32 *hash)\n{\n\tu32 a_hash, b_hash;\n\n\tif (a_sockaddr->ss_family == AF_INET) {\n\t\ta_hash = iwpm_ipv4_jhash((struct sockaddr_in *) a_sockaddr);\n\t\tb_hash = iwpm_ipv4_jhash((struct sockaddr_in *) b_sockaddr);\n\n\t} else if (a_sockaddr->ss_family == AF_INET6) {\n\t\ta_hash = iwpm_ipv6_jhash((struct sockaddr_in6 *) a_sockaddr);\n\t\tb_hash = iwpm_ipv6_jhash((struct sockaddr_in6 *) b_sockaddr);\n\t} else {\n\t\tpr_err(\"%s: Invalid sockaddr family\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (a_hash == b_hash)  \n\t\t*hash = a_hash;\n\telse\n\t\t*hash = jhash_2words(a_hash, b_hash, 0);\n\treturn 0;\n}\n\nstatic struct hlist_head *get_mapinfo_hash_bucket(struct sockaddr_storage\n\t\t\t\t*local_sockaddr, struct sockaddr_storage\n\t\t\t\t*mapped_sockaddr)\n{\n\tu32 hash;\n\tint ret;\n\n\tret = get_hash_bucket(local_sockaddr, mapped_sockaddr, &hash);\n\tif (ret)\n\t\treturn NULL;\n\treturn &iwpm_hash_bucket[hash & IWPM_MAPINFO_HASH_MASK];\n}\n\nstatic struct hlist_head *get_reminfo_hash_bucket(struct sockaddr_storage\n\t\t\t\t*mapped_loc_sockaddr, struct sockaddr_storage\n\t\t\t\t*mapped_rem_sockaddr)\n{\n\tu32 hash;\n\tint ret;\n\n\tret = get_hash_bucket(mapped_loc_sockaddr, mapped_rem_sockaddr, &hash);\n\tif (ret)\n\t\treturn NULL;\n\treturn &iwpm_reminfo_bucket[hash & IWPM_REMINFO_HASH_MASK];\n}\n\nstatic int send_mapinfo_num(u32 mapping_num, u8 nl_client, int iwpm_pid)\n{\n\tstruct sk_buff *skb = NULL;\n\tstruct nlmsghdr *nlh;\n\tu32 msg_seq;\n\tconst char *err_str = \"\";\n\tint ret = -EINVAL;\n\n\tskb = iwpm_create_nlmsg(RDMA_NL_IWPM_MAPINFO_NUM, &nlh, nl_client);\n\tif (!skb) {\n\t\terr_str = \"Unable to create a nlmsg\";\n\t\tgoto mapinfo_num_error;\n\t}\n\tnlh->nlmsg_seq = iwpm_get_nlmsg_seq();\n\tmsg_seq = 0;\n\terr_str = \"Unable to put attribute of mapinfo number nlmsg\";\n\tret = ibnl_put_attr(skb, nlh, sizeof(u32), &msg_seq, IWPM_NLA_MAPINFO_SEQ);\n\tif (ret)\n\t\tgoto mapinfo_num_error;\n\tret = ibnl_put_attr(skb, nlh, sizeof(u32),\n\t\t\t\t&mapping_num, IWPM_NLA_MAPINFO_SEND_NUM);\n\tif (ret)\n\t\tgoto mapinfo_num_error;\n\n\tnlmsg_end(skb, nlh);\n\n\tret = rdma_nl_unicast(&init_net, skb, iwpm_pid);\n\tif (ret) {\n\t\tskb = NULL;\n\t\terr_str = \"Unable to send a nlmsg\";\n\t\tgoto mapinfo_num_error;\n\t}\n\tpr_debug(\"%s: Sent mapping number = %u\\n\", __func__, mapping_num);\n\treturn 0;\nmapinfo_num_error:\n\tpr_info(\"%s: %s\\n\", __func__, err_str);\n\tdev_kfree_skb(skb);\n\treturn ret;\n}\n\nstatic int send_nlmsg_done(struct sk_buff *skb, u8 nl_client, int iwpm_pid)\n{\n\tstruct nlmsghdr *nlh = NULL;\n\tint ret = 0;\n\n\tif (!skb)\n\t\treturn ret;\n\tif (!(ibnl_put_msg(skb, &nlh, 0, 0, nl_client,\n\t\t\t   RDMA_NL_IWPM_MAPINFO, NLM_F_MULTI))) {\n\t\tpr_warn(\"%s Unable to put NLMSG_DONE\\n\", __func__);\n\t\tdev_kfree_skb(skb);\n\t\treturn -ENOMEM;\n\t}\n\tnlh->nlmsg_type = NLMSG_DONE;\n\tret = rdma_nl_unicast(&init_net, skb, iwpm_pid);\n\tif (ret)\n\t\tpr_warn(\"%s Unable to send a nlmsg\\n\", __func__);\n\treturn ret;\n}\n\nint iwpm_send_mapinfo(u8 nl_client, int iwpm_pid)\n{\n\tstruct iwpm_mapping_info *map_info;\n\tstruct sk_buff *skb = NULL;\n\tstruct nlmsghdr *nlh;\n\tint skb_num = 0, mapping_num = 0;\n\tint i = 0, nlmsg_bytes = 0;\n\tunsigned long flags;\n\tconst char *err_str = \"\";\n\tint ret;\n\n\tskb = dev_alloc_skb(NLMSG_GOODSIZE);\n\tif (!skb) {\n\t\tret = -ENOMEM;\n\t\terr_str = \"Unable to allocate skb\";\n\t\tgoto send_mapping_info_exit;\n\t}\n\tskb_num++;\n\tspin_lock_irqsave(&iwpm_mapinfo_lock, flags);\n\tret = -EINVAL;\n\tfor (i = 0; i < IWPM_MAPINFO_HASH_SIZE; i++) {\n\t\thlist_for_each_entry(map_info, &iwpm_hash_bucket[i],\n\t\t\t\t     hlist_node) {\n\t\t\tif (map_info->nl_client != nl_client)\n\t\t\t\tcontinue;\n\t\t\tnlh = NULL;\n\t\t\tif (!(ibnl_put_msg(skb, &nlh, 0, 0, nl_client,\n\t\t\t\t\tRDMA_NL_IWPM_MAPINFO, NLM_F_MULTI))) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\terr_str = \"Unable to put the nlmsg header\";\n\t\t\t\tgoto send_mapping_info_unlock;\n\t\t\t}\n\t\t\terr_str = \"Unable to put attribute of the nlmsg\";\n\t\t\tret = ibnl_put_attr(skb, nlh,\n\t\t\t\t\tsizeof(struct sockaddr_storage),\n\t\t\t\t\t&map_info->local_sockaddr,\n\t\t\t\t\tIWPM_NLA_MAPINFO_LOCAL_ADDR);\n\t\t\tif (ret)\n\t\t\t\tgoto send_mapping_info_unlock;\n\n\t\t\tret = ibnl_put_attr(skb, nlh,\n\t\t\t\t\tsizeof(struct sockaddr_storage),\n\t\t\t\t\t&map_info->mapped_sockaddr,\n\t\t\t\t\tIWPM_NLA_MAPINFO_MAPPED_ADDR);\n\t\t\tif (ret)\n\t\t\t\tgoto send_mapping_info_unlock;\n\n\t\t\tif (iwpm_ulib_version > IWPM_UABI_VERSION_MIN) {\n\t\t\t\tret = ibnl_put_attr(skb, nlh, sizeof(u32),\n\t\t\t\t\t\t&map_info->map_flags,\n\t\t\t\t\t\tIWPM_NLA_MAPINFO_FLAGS);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto send_mapping_info_unlock;\n\t\t\t}\n\n\t\t\tnlmsg_end(skb, nlh);\n\n\t\t\tiwpm_print_sockaddr(&map_info->local_sockaddr,\n\t\t\t\t\"send_mapping_info: Local sockaddr:\");\n\t\t\tiwpm_print_sockaddr(&map_info->mapped_sockaddr,\n\t\t\t\t\"send_mapping_info: Mapped local sockaddr:\");\n\t\t\tmapping_num++;\n\t\t\tnlmsg_bytes += nlh->nlmsg_len;\n\n\t\t\t \n\t\t\tif (NLMSG_GOODSIZE - nlmsg_bytes < nlh->nlmsg_len * 2) {\n\t\t\t\t \n\t\t\t\tnlmsg_bytes = 0;\n\t\t\t\tskb_num++;\n\t\t\t\tspin_unlock_irqrestore(&iwpm_mapinfo_lock,\n\t\t\t\t\t\t       flags);\n\t\t\t\t \n\t\t\t\tret = send_nlmsg_done(skb, nl_client, iwpm_pid);\n\t\t\t\tskb = NULL;\n\t\t\t\tif (ret) {\n\t\t\t\t\terr_str = \"Unable to send map info\";\n\t\t\t\t\tgoto send_mapping_info_exit;\n\t\t\t\t}\n\t\t\t\tif (skb_num == IWPM_MAPINFO_SKB_COUNT) {\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\terr_str = \"Insufficient skbs for map info\";\n\t\t\t\t\tgoto send_mapping_info_exit;\n\t\t\t\t}\n\t\t\t\tskb = dev_alloc_skb(NLMSG_GOODSIZE);\n\t\t\t\tif (!skb) {\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\terr_str = \"Unable to allocate skb\";\n\t\t\t\t\tgoto send_mapping_info_exit;\n\t\t\t\t}\n\t\t\t\tspin_lock_irqsave(&iwpm_mapinfo_lock, flags);\n\t\t\t}\n\t\t}\n\t}\nsend_mapping_info_unlock:\n\tspin_unlock_irqrestore(&iwpm_mapinfo_lock, flags);\nsend_mapping_info_exit:\n\tif (ret) {\n\t\tpr_warn(\"%s: %s (ret = %d)\\n\", __func__, err_str, ret);\n\t\tdev_kfree_skb(skb);\n\t\treturn ret;\n\t}\n\tsend_nlmsg_done(skb, nl_client, iwpm_pid);\n\treturn send_mapinfo_num(mapping_num, nl_client, iwpm_pid);\n}\n\nint iwpm_mapinfo_available(void)\n{\n\tunsigned long flags;\n\tint full_bucket = 0, i = 0;\n\n\tspin_lock_irqsave(&iwpm_mapinfo_lock, flags);\n\tif (iwpm_hash_bucket) {\n\t\tfor (i = 0; i < IWPM_MAPINFO_HASH_SIZE; i++) {\n\t\t\tif (!hlist_empty(&iwpm_hash_bucket[i])) {\n\t\t\t\tfull_bucket = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&iwpm_mapinfo_lock, flags);\n\treturn full_bucket;\n}\n\nint iwpm_send_hello(u8 nl_client, int iwpm_pid, u16 abi_version)\n{\n\tstruct sk_buff *skb = NULL;\n\tstruct nlmsghdr *nlh;\n\tconst char *err_str;\n\tint ret = -EINVAL;\n\n\tskb = iwpm_create_nlmsg(RDMA_NL_IWPM_HELLO, &nlh, nl_client);\n\tif (!skb) {\n\t\terr_str = \"Unable to create a nlmsg\";\n\t\tgoto hello_num_error;\n\t}\n\tnlh->nlmsg_seq = iwpm_get_nlmsg_seq();\n\terr_str = \"Unable to put attribute of abi_version into nlmsg\";\n\tret = ibnl_put_attr(skb, nlh, sizeof(u16), &abi_version,\n\t\t\t    IWPM_NLA_HELLO_ABI_VERSION);\n\tif (ret)\n\t\tgoto hello_num_error;\n\tnlmsg_end(skb, nlh);\n\n\tret = rdma_nl_unicast(&init_net, skb, iwpm_pid);\n\tif (ret) {\n\t\tskb = NULL;\n\t\terr_str = \"Unable to send a nlmsg\";\n\t\tgoto hello_num_error;\n\t}\n\tpr_debug(\"%s: Sent hello abi_version = %u\\n\", __func__, abi_version);\n\treturn 0;\nhello_num_error:\n\tpr_info(\"%s: %s\\n\", __func__, err_str);\n\tdev_kfree_skb(skb);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}