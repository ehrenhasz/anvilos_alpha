{
  "module_name": "multicast.c",
  "hash_id": "0025567c108b3408359b3b09f500faf8bc757a386f230c0e19f952bd266fbc48",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/core/multicast.c",
  "human_readable_source": " \n\n#include <linux/completion.h>\n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/random.h>\n\n#include <rdma/ib_cache.h>\n#include \"sa.h\"\n\nstatic int mcast_add_one(struct ib_device *device);\nstatic void mcast_remove_one(struct ib_device *device, void *client_data);\n\nstatic struct ib_client mcast_client = {\n\t.name   = \"ib_multicast\",\n\t.add    = mcast_add_one,\n\t.remove = mcast_remove_one\n};\n\nstatic struct ib_sa_client\tsa_client;\nstatic struct workqueue_struct\t*mcast_wq;\nstatic union ib_gid mgid0;\n\nstruct mcast_device;\n\nstruct mcast_port {\n\tstruct mcast_device\t*dev;\n\tspinlock_t\t\tlock;\n\tstruct rb_root\t\ttable;\n\trefcount_t\t\trefcount;\n\tstruct completion\tcomp;\n\tu32\t\t\tport_num;\n};\n\nstruct mcast_device {\n\tstruct ib_device\t*device;\n\tstruct ib_event_handler\tevent_handler;\n\tint\t\t\tstart_port;\n\tint\t\t\tend_port;\n\tstruct mcast_port\tport[];\n};\n\nenum mcast_state {\n\tMCAST_JOINING,\n\tMCAST_MEMBER,\n\tMCAST_ERROR,\n};\n\nenum mcast_group_state {\n\tMCAST_IDLE,\n\tMCAST_BUSY,\n\tMCAST_GROUP_ERROR,\n\tMCAST_PKEY_EVENT\n};\n\nenum {\n\tMCAST_INVALID_PKEY_INDEX = 0xFFFF\n};\n\nstruct mcast_member;\n\nstruct mcast_group {\n\tstruct ib_sa_mcmember_rec rec;\n\tstruct rb_node\t\tnode;\n\tstruct mcast_port\t*port;\n\tspinlock_t\t\tlock;\n\tstruct work_struct\twork;\n\tstruct list_head\tpending_list;\n\tstruct list_head\tactive_list;\n\tstruct mcast_member\t*last_join;\n\tint\t\t\tmembers[NUM_JOIN_MEMBERSHIP_TYPES];\n\tatomic_t\t\trefcount;\n\tenum mcast_group_state\tstate;\n\tstruct ib_sa_query\t*query;\n\tu16\t\t\tpkey_index;\n\tu8\t\t\tleave_state;\n\tint\t\t\tretries;\n};\n\nstruct mcast_member {\n\tstruct ib_sa_multicast\tmulticast;\n\tstruct ib_sa_client\t*client;\n\tstruct mcast_group\t*group;\n\tstruct list_head\tlist;\n\tenum mcast_state\tstate;\n\trefcount_t\t\trefcount;\n\tstruct completion\tcomp;\n};\n\nstatic void join_handler(int status, struct ib_sa_mcmember_rec *rec,\n\t\t\t void *context);\nstatic void leave_handler(int status, struct ib_sa_mcmember_rec *rec,\n\t\t\t  void *context);\n\nstatic struct mcast_group *mcast_find(struct mcast_port *port,\n\t\t\t\t      union ib_gid *mgid)\n{\n\tstruct rb_node *node = port->table.rb_node;\n\tstruct mcast_group *group;\n\tint ret;\n\n\twhile (node) {\n\t\tgroup = rb_entry(node, struct mcast_group, node);\n\t\tret = memcmp(mgid->raw, group->rec.mgid.raw, sizeof *mgid);\n\t\tif (!ret)\n\t\t\treturn group;\n\n\t\tif (ret < 0)\n\t\t\tnode = node->rb_left;\n\t\telse\n\t\t\tnode = node->rb_right;\n\t}\n\treturn NULL;\n}\n\nstatic struct mcast_group *mcast_insert(struct mcast_port *port,\n\t\t\t\t\tstruct mcast_group *group,\n\t\t\t\t\tint allow_duplicates)\n{\n\tstruct rb_node **link = &port->table.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct mcast_group *cur_group;\n\tint ret;\n\n\twhile (*link) {\n\t\tparent = *link;\n\t\tcur_group = rb_entry(parent, struct mcast_group, node);\n\n\t\tret = memcmp(group->rec.mgid.raw, cur_group->rec.mgid.raw,\n\t\t\t     sizeof group->rec.mgid);\n\t\tif (ret < 0)\n\t\t\tlink = &(*link)->rb_left;\n\t\telse if (ret > 0)\n\t\t\tlink = &(*link)->rb_right;\n\t\telse if (allow_duplicates)\n\t\t\tlink = &(*link)->rb_left;\n\t\telse\n\t\t\treturn cur_group;\n\t}\n\trb_link_node(&group->node, parent, link);\n\trb_insert_color(&group->node, &port->table);\n\treturn NULL;\n}\n\nstatic void deref_port(struct mcast_port *port)\n{\n\tif (refcount_dec_and_test(&port->refcount))\n\t\tcomplete(&port->comp);\n}\n\nstatic void release_group(struct mcast_group *group)\n{\n\tstruct mcast_port *port = group->port;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tif (atomic_dec_and_test(&group->refcount)) {\n\t\trb_erase(&group->node, &port->table);\n\t\tspin_unlock_irqrestore(&port->lock, flags);\n\t\tkfree(group);\n\t\tderef_port(port);\n\t} else\n\t\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic void deref_member(struct mcast_member *member)\n{\n\tif (refcount_dec_and_test(&member->refcount))\n\t\tcomplete(&member->comp);\n}\n\nstatic void queue_join(struct mcast_member *member)\n{\n\tstruct mcast_group *group = member->group;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&group->lock, flags);\n\tlist_add_tail(&member->list, &group->pending_list);\n\tif (group->state == MCAST_IDLE) {\n\t\tgroup->state = MCAST_BUSY;\n\t\tatomic_inc(&group->refcount);\n\t\tqueue_work(mcast_wq, &group->work);\n\t}\n\tspin_unlock_irqrestore(&group->lock, flags);\n}\n\n \nstatic void adjust_membership(struct mcast_group *group, u8 join_state, int inc)\n{\n\tint i;\n\n\tfor (i = 0; i < NUM_JOIN_MEMBERSHIP_TYPES; i++, join_state >>= 1)\n\t\tif (join_state & 0x1)\n\t\t\tgroup->members[i] += inc;\n}\n\n \nstatic u8 get_leave_state(struct mcast_group *group)\n{\n\tu8 leave_state = 0;\n\tint i;\n\n\tfor (i = 0; i < NUM_JOIN_MEMBERSHIP_TYPES; i++)\n\t\tif (!group->members[i])\n\t\t\tleave_state |= (0x1 << i);\n\n\treturn leave_state & group->rec.join_state;\n}\n\nstatic int check_selector(ib_sa_comp_mask comp_mask,\n\t\t\t  ib_sa_comp_mask selector_mask,\n\t\t\t  ib_sa_comp_mask value_mask,\n\t\t\t  u8 selector, u8 src_value, u8 dst_value)\n{\n\tint err;\n\n\tif (!(comp_mask & selector_mask) || !(comp_mask & value_mask))\n\t\treturn 0;\n\n\tswitch (selector) {\n\tcase IB_SA_GT:\n\t\terr = (src_value <= dst_value);\n\t\tbreak;\n\tcase IB_SA_LT:\n\t\terr = (src_value >= dst_value);\n\t\tbreak;\n\tcase IB_SA_EQ:\n\t\terr = (src_value != dst_value);\n\t\tbreak;\n\tdefault:\n\t\terr = 0;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int cmp_rec(struct ib_sa_mcmember_rec *src,\n\t\t   struct ib_sa_mcmember_rec *dst, ib_sa_comp_mask comp_mask)\n{\n\t \n\n\tif (comp_mask & IB_SA_MCMEMBER_REC_PORT_GID &&\n\t    memcmp(&src->port_gid, &dst->port_gid, sizeof src->port_gid))\n\t\treturn -EINVAL;\n\tif (comp_mask & IB_SA_MCMEMBER_REC_QKEY && src->qkey != dst->qkey)\n\t\treturn -EINVAL;\n\tif (comp_mask & IB_SA_MCMEMBER_REC_MLID && src->mlid != dst->mlid)\n\t\treturn -EINVAL;\n\tif (check_selector(comp_mask, IB_SA_MCMEMBER_REC_MTU_SELECTOR,\n\t\t\t   IB_SA_MCMEMBER_REC_MTU, dst->mtu_selector,\n\t\t\t   src->mtu, dst->mtu))\n\t\treturn -EINVAL;\n\tif (comp_mask & IB_SA_MCMEMBER_REC_TRAFFIC_CLASS &&\n\t    src->traffic_class != dst->traffic_class)\n\t\treturn -EINVAL;\n\tif (comp_mask & IB_SA_MCMEMBER_REC_PKEY && src->pkey != dst->pkey)\n\t\treturn -EINVAL;\n\tif (check_selector(comp_mask, IB_SA_MCMEMBER_REC_RATE_SELECTOR,\n\t\t\t   IB_SA_MCMEMBER_REC_RATE, dst->rate_selector,\n\t\t\t   src->rate, dst->rate))\n\t\treturn -EINVAL;\n\tif (check_selector(comp_mask,\n\t\t\t   IB_SA_MCMEMBER_REC_PACKET_LIFE_TIME_SELECTOR,\n\t\t\t   IB_SA_MCMEMBER_REC_PACKET_LIFE_TIME,\n\t\t\t   dst->packet_life_time_selector,\n\t\t\t   src->packet_life_time, dst->packet_life_time))\n\t\treturn -EINVAL;\n\tif (comp_mask & IB_SA_MCMEMBER_REC_SL && src->sl != dst->sl)\n\t\treturn -EINVAL;\n\tif (comp_mask & IB_SA_MCMEMBER_REC_FLOW_LABEL &&\n\t    src->flow_label != dst->flow_label)\n\t\treturn -EINVAL;\n\tif (comp_mask & IB_SA_MCMEMBER_REC_HOP_LIMIT &&\n\t    src->hop_limit != dst->hop_limit)\n\t\treturn -EINVAL;\n\tif (comp_mask & IB_SA_MCMEMBER_REC_SCOPE && src->scope != dst->scope)\n\t\treturn -EINVAL;\n\n\t \n\n\treturn 0;\n}\n\nstatic int send_join(struct mcast_group *group, struct mcast_member *member)\n{\n\tstruct mcast_port *port = group->port;\n\tint ret;\n\n\tgroup->last_join = member;\n\tret = ib_sa_mcmember_rec_query(&sa_client, port->dev->device,\n\t\t\t\t       port->port_num, IB_MGMT_METHOD_SET,\n\t\t\t\t       &member->multicast.rec,\n\t\t\t\t       member->multicast.comp_mask,\n\t\t\t\t       3000, GFP_KERNEL, join_handler, group,\n\t\t\t\t       &group->query);\n\treturn (ret > 0) ? 0 : ret;\n}\n\nstatic int send_leave(struct mcast_group *group, u8 leave_state)\n{\n\tstruct mcast_port *port = group->port;\n\tstruct ib_sa_mcmember_rec rec;\n\tint ret;\n\n\trec = group->rec;\n\trec.join_state = leave_state;\n\tgroup->leave_state = leave_state;\n\n\tret = ib_sa_mcmember_rec_query(&sa_client, port->dev->device,\n\t\t\t\t       port->port_num, IB_SA_METHOD_DELETE, &rec,\n\t\t\t\t       IB_SA_MCMEMBER_REC_MGID     |\n\t\t\t\t       IB_SA_MCMEMBER_REC_PORT_GID |\n\t\t\t\t       IB_SA_MCMEMBER_REC_JOIN_STATE,\n\t\t\t\t       3000, GFP_KERNEL, leave_handler,\n\t\t\t\t       group, &group->query);\n\treturn (ret > 0) ? 0 : ret;\n}\n\nstatic void join_group(struct mcast_group *group, struct mcast_member *member,\n\t\t       u8 join_state)\n{\n\tmember->state = MCAST_MEMBER;\n\tadjust_membership(group, join_state, 1);\n\tgroup->rec.join_state |= join_state;\n\tmember->multicast.rec = group->rec;\n\tmember->multicast.rec.join_state = join_state;\n\tlist_move(&member->list, &group->active_list);\n}\n\nstatic int fail_join(struct mcast_group *group, struct mcast_member *member,\n\t\t     int status)\n{\n\tspin_lock_irq(&group->lock);\n\tlist_del_init(&member->list);\n\tspin_unlock_irq(&group->lock);\n\treturn member->multicast.callback(status, &member->multicast);\n}\n\nstatic void process_group_error(struct mcast_group *group)\n{\n\tstruct mcast_member *member;\n\tint ret = 0;\n\tu16 pkey_index;\n\n\tif (group->state == MCAST_PKEY_EVENT)\n\t\tret = ib_find_pkey(group->port->dev->device,\n\t\t\t\t   group->port->port_num,\n\t\t\t\t   be16_to_cpu(group->rec.pkey), &pkey_index);\n\n\tspin_lock_irq(&group->lock);\n\tif (group->state == MCAST_PKEY_EVENT && !ret &&\n\t    group->pkey_index == pkey_index)\n\t\tgoto out;\n\n\twhile (!list_empty(&group->active_list)) {\n\t\tmember = list_entry(group->active_list.next,\n\t\t\t\t    struct mcast_member, list);\n\t\trefcount_inc(&member->refcount);\n\t\tlist_del_init(&member->list);\n\t\tadjust_membership(group, member->multicast.rec.join_state, -1);\n\t\tmember->state = MCAST_ERROR;\n\t\tspin_unlock_irq(&group->lock);\n\n\t\tret = member->multicast.callback(-ENETRESET,\n\t\t\t\t\t\t &member->multicast);\n\t\tderef_member(member);\n\t\tif (ret)\n\t\t\tib_sa_free_multicast(&member->multicast);\n\t\tspin_lock_irq(&group->lock);\n\t}\n\n\tgroup->rec.join_state = 0;\nout:\n\tgroup->state = MCAST_BUSY;\n\tspin_unlock_irq(&group->lock);\n}\n\nstatic void mcast_work_handler(struct work_struct *work)\n{\n\tstruct mcast_group *group;\n\tstruct mcast_member *member;\n\tstruct ib_sa_multicast *multicast;\n\tint status, ret;\n\tu8 join_state;\n\n\tgroup = container_of(work, typeof(*group), work);\nretest:\n\tspin_lock_irq(&group->lock);\n\twhile (!list_empty(&group->pending_list) ||\n\t       (group->state != MCAST_BUSY)) {\n\n\t\tif (group->state != MCAST_BUSY) {\n\t\t\tspin_unlock_irq(&group->lock);\n\t\t\tprocess_group_error(group);\n\t\t\tgoto retest;\n\t\t}\n\n\t\tmember = list_entry(group->pending_list.next,\n\t\t\t\t    struct mcast_member, list);\n\t\tmulticast = &member->multicast;\n\t\tjoin_state = multicast->rec.join_state;\n\t\trefcount_inc(&member->refcount);\n\n\t\tif (join_state == (group->rec.join_state & join_state)) {\n\t\t\tstatus = cmp_rec(&group->rec, &multicast->rec,\n\t\t\t\t\t multicast->comp_mask);\n\t\t\tif (!status)\n\t\t\t\tjoin_group(group, member, join_state);\n\t\t\telse\n\t\t\t\tlist_del_init(&member->list);\n\t\t\tspin_unlock_irq(&group->lock);\n\t\t\tret = multicast->callback(status, multicast);\n\t\t} else {\n\t\t\tspin_unlock_irq(&group->lock);\n\t\t\tstatus = send_join(group, member);\n\t\t\tif (!status) {\n\t\t\t\tderef_member(member);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tret = fail_join(group, member, status);\n\t\t}\n\n\t\tderef_member(member);\n\t\tif (ret)\n\t\t\tib_sa_free_multicast(&member->multicast);\n\t\tspin_lock_irq(&group->lock);\n\t}\n\n\tjoin_state = get_leave_state(group);\n\tif (join_state) {\n\t\tgroup->rec.join_state &= ~join_state;\n\t\tspin_unlock_irq(&group->lock);\n\t\tif (send_leave(group, join_state))\n\t\t\tgoto retest;\n\t} else {\n\t\tgroup->state = MCAST_IDLE;\n\t\tspin_unlock_irq(&group->lock);\n\t\trelease_group(group);\n\t}\n}\n\n \nstatic void process_join_error(struct mcast_group *group, int status)\n{\n\tstruct mcast_member *member;\n\tint ret;\n\n\tspin_lock_irq(&group->lock);\n\tmember = list_entry(group->pending_list.next,\n\t\t\t    struct mcast_member, list);\n\tif (group->last_join == member) {\n\t\trefcount_inc(&member->refcount);\n\t\tlist_del_init(&member->list);\n\t\tspin_unlock_irq(&group->lock);\n\t\tret = member->multicast.callback(status, &member->multicast);\n\t\tderef_member(member);\n\t\tif (ret)\n\t\t\tib_sa_free_multicast(&member->multicast);\n\t} else\n\t\tspin_unlock_irq(&group->lock);\n}\n\nstatic void join_handler(int status, struct ib_sa_mcmember_rec *rec,\n\t\t\t void *context)\n{\n\tstruct mcast_group *group = context;\n\tu16 pkey_index = MCAST_INVALID_PKEY_INDEX;\n\n\tif (status)\n\t\tprocess_join_error(group, status);\n\telse {\n\t\tint mgids_changed, is_mgid0;\n\n\t\tif (ib_find_pkey(group->port->dev->device,\n\t\t\t\t group->port->port_num, be16_to_cpu(rec->pkey),\n\t\t\t\t &pkey_index))\n\t\t\tpkey_index = MCAST_INVALID_PKEY_INDEX;\n\n\t\tspin_lock_irq(&group->port->lock);\n\t\tif (group->state == MCAST_BUSY &&\n\t\t    group->pkey_index == MCAST_INVALID_PKEY_INDEX)\n\t\t\tgroup->pkey_index = pkey_index;\n\t\tmgids_changed = memcmp(&rec->mgid, &group->rec.mgid,\n\t\t\t\t       sizeof(group->rec.mgid));\n\t\tgroup->rec = *rec;\n\t\tif (mgids_changed) {\n\t\t\trb_erase(&group->node, &group->port->table);\n\t\t\tis_mgid0 = !memcmp(&mgid0, &group->rec.mgid,\n\t\t\t\t\t   sizeof(mgid0));\n\t\t\tmcast_insert(group->port, group, is_mgid0);\n\t\t}\n\t\tspin_unlock_irq(&group->port->lock);\n\t}\n\tmcast_work_handler(&group->work);\n}\n\nstatic void leave_handler(int status, struct ib_sa_mcmember_rec *rec,\n\t\t\t  void *context)\n{\n\tstruct mcast_group *group = context;\n\n\tif (status && group->retries > 0 &&\n\t    !send_leave(group, group->leave_state))\n\t\tgroup->retries--;\n\telse\n\t\tmcast_work_handler(&group->work);\n}\n\nstatic struct mcast_group *acquire_group(struct mcast_port *port,\n\t\t\t\t\t union ib_gid *mgid, gfp_t gfp_mask)\n{\n\tstruct mcast_group *group, *cur_group;\n\tunsigned long flags;\n\tint is_mgid0;\n\n\tis_mgid0 = !memcmp(&mgid0, mgid, sizeof mgid0);\n\tif (!is_mgid0) {\n\t\tspin_lock_irqsave(&port->lock, flags);\n\t\tgroup = mcast_find(port, mgid);\n\t\tif (group)\n\t\t\tgoto found;\n\t\tspin_unlock_irqrestore(&port->lock, flags);\n\t}\n\n\tgroup = kzalloc(sizeof *group, gfp_mask);\n\tif (!group)\n\t\treturn NULL;\n\n\tgroup->retries = 3;\n\tgroup->port = port;\n\tgroup->rec.mgid = *mgid;\n\tgroup->pkey_index = MCAST_INVALID_PKEY_INDEX;\n\tINIT_LIST_HEAD(&group->pending_list);\n\tINIT_LIST_HEAD(&group->active_list);\n\tINIT_WORK(&group->work, mcast_work_handler);\n\tspin_lock_init(&group->lock);\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tcur_group = mcast_insert(port, group, is_mgid0);\n\tif (cur_group) {\n\t\tkfree(group);\n\t\tgroup = cur_group;\n\t} else\n\t\trefcount_inc(&port->refcount);\nfound:\n\tatomic_inc(&group->refcount);\n\tspin_unlock_irqrestore(&port->lock, flags);\n\treturn group;\n}\n\n \nstruct ib_sa_multicast *\nib_sa_join_multicast(struct ib_sa_client *client,\n\t\t     struct ib_device *device, u32 port_num,\n\t\t     struct ib_sa_mcmember_rec *rec,\n\t\t     ib_sa_comp_mask comp_mask, gfp_t gfp_mask,\n\t\t     int (*callback)(int status,\n\t\t\t\t     struct ib_sa_multicast *multicast),\n\t\t     void *context)\n{\n\tstruct mcast_device *dev;\n\tstruct mcast_member *member;\n\tstruct ib_sa_multicast *multicast;\n\tint ret;\n\n\tdev = ib_get_client_data(device, &mcast_client);\n\tif (!dev)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tmember = kmalloc(sizeof *member, gfp_mask);\n\tif (!member)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tib_sa_client_get(client);\n\tmember->client = client;\n\tmember->multicast.rec = *rec;\n\tmember->multicast.comp_mask = comp_mask;\n\tmember->multicast.callback = callback;\n\tmember->multicast.context = context;\n\tinit_completion(&member->comp);\n\trefcount_set(&member->refcount, 1);\n\tmember->state = MCAST_JOINING;\n\n\tmember->group = acquire_group(&dev->port[port_num - dev->start_port],\n\t\t\t\t      &rec->mgid, gfp_mask);\n\tif (!member->group) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t \n\tmulticast = &member->multicast;\n\tqueue_join(member);\n\treturn multicast;\n\nerr:\n\tib_sa_client_put(client);\n\tkfree(member);\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL(ib_sa_join_multicast);\n\nvoid ib_sa_free_multicast(struct ib_sa_multicast *multicast)\n{\n\tstruct mcast_member *member;\n\tstruct mcast_group *group;\n\n\tmember = container_of(multicast, struct mcast_member, multicast);\n\tgroup = member->group;\n\n\tspin_lock_irq(&group->lock);\n\tif (member->state == MCAST_MEMBER)\n\t\tadjust_membership(group, multicast->rec.join_state, -1);\n\n\tlist_del_init(&member->list);\n\n\tif (group->state == MCAST_IDLE) {\n\t\tgroup->state = MCAST_BUSY;\n\t\tspin_unlock_irq(&group->lock);\n\t\t \n\t\tqueue_work(mcast_wq, &group->work);\n\t} else {\n\t\tspin_unlock_irq(&group->lock);\n\t\trelease_group(group);\n\t}\n\n\tderef_member(member);\n\twait_for_completion(&member->comp);\n\tib_sa_client_put(member->client);\n\tkfree(member);\n}\nEXPORT_SYMBOL(ib_sa_free_multicast);\n\nint ib_sa_get_mcmember_rec(struct ib_device *device, u32 port_num,\n\t\t\t   union ib_gid *mgid, struct ib_sa_mcmember_rec *rec)\n{\n\tstruct mcast_device *dev;\n\tstruct mcast_port *port;\n\tstruct mcast_group *group;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tdev = ib_get_client_data(device, &mcast_client);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tport = &dev->port[port_num - dev->start_port];\n\tspin_lock_irqsave(&port->lock, flags);\n\tgroup = mcast_find(port, mgid);\n\tif (group)\n\t\t*rec = group->rec;\n\telse\n\t\tret = -EADDRNOTAVAIL;\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(ib_sa_get_mcmember_rec);\n\n \nint ib_init_ah_from_mcmember(struct ib_device *device, u32 port_num,\n\t\t\t     struct ib_sa_mcmember_rec *rec,\n\t\t\t     struct net_device *ndev,\n\t\t\t     enum ib_gid_type gid_type,\n\t\t\t     struct rdma_ah_attr *ah_attr)\n{\n\tconst struct ib_gid_attr *sgid_attr;\n\n\t \n\tif (rdma_protocol_ib(device, port_num))\n\t\tndev = NULL;\n\telse if (!rdma_protocol_roce(device, port_num))\n\t\treturn -EINVAL;\n\n\tsgid_attr = rdma_find_gid_by_port(device, &rec->port_gid,\n\t\t\t\t\t  gid_type, port_num, ndev);\n\tif (IS_ERR(sgid_attr))\n\t\treturn PTR_ERR(sgid_attr);\n\n\tmemset(ah_attr, 0, sizeof(*ah_attr));\n\tah_attr->type = rdma_ah_find_type(device, port_num);\n\n\trdma_ah_set_dlid(ah_attr, be16_to_cpu(rec->mlid));\n\trdma_ah_set_sl(ah_attr, rec->sl);\n\trdma_ah_set_port_num(ah_attr, port_num);\n\trdma_ah_set_static_rate(ah_attr, rec->rate);\n\trdma_move_grh_sgid_attr(ah_attr, &rec->mgid,\n\t\t\t\tbe32_to_cpu(rec->flow_label),\n\t\t\t\trec->hop_limit,\trec->traffic_class,\n\t\t\t\tsgid_attr);\n\treturn 0;\n}\nEXPORT_SYMBOL(ib_init_ah_from_mcmember);\n\nstatic void mcast_groups_event(struct mcast_port *port,\n\t\t\t       enum mcast_group_state state)\n{\n\tstruct mcast_group *group;\n\tstruct rb_node *node;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tfor (node = rb_first(&port->table); node; node = rb_next(node)) {\n\t\tgroup = rb_entry(node, struct mcast_group, node);\n\t\tspin_lock(&group->lock);\n\t\tif (group->state == MCAST_IDLE) {\n\t\t\tatomic_inc(&group->refcount);\n\t\t\tqueue_work(mcast_wq, &group->work);\n\t\t}\n\t\tif (group->state != MCAST_GROUP_ERROR)\n\t\t\tgroup->state = state;\n\t\tspin_unlock(&group->lock);\n\t}\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\nstatic void mcast_event_handler(struct ib_event_handler *handler,\n\t\t\t\tstruct ib_event *event)\n{\n\tstruct mcast_device *dev;\n\tint index;\n\n\tdev = container_of(handler, struct mcast_device, event_handler);\n\tif (!rdma_cap_ib_mcast(dev->device, event->element.port_num))\n\t\treturn;\n\n\tindex = event->element.port_num - dev->start_port;\n\n\tswitch (event->event) {\n\tcase IB_EVENT_PORT_ERR:\n\tcase IB_EVENT_LID_CHANGE:\n\tcase IB_EVENT_CLIENT_REREGISTER:\n\t\tmcast_groups_event(&dev->port[index], MCAST_GROUP_ERROR);\n\t\tbreak;\n\tcase IB_EVENT_PKEY_CHANGE:\n\t\tmcast_groups_event(&dev->port[index], MCAST_PKEY_EVENT);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int mcast_add_one(struct ib_device *device)\n{\n\tstruct mcast_device *dev;\n\tstruct mcast_port *port;\n\tint i;\n\tint count = 0;\n\n\tdev = kmalloc(struct_size(dev, port, device->phys_port_cnt),\n\t\t      GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tdev->start_port = rdma_start_port(device);\n\tdev->end_port = rdma_end_port(device);\n\n\tfor (i = 0; i <= dev->end_port - dev->start_port; i++) {\n\t\tif (!rdma_cap_ib_mcast(device, dev->start_port + i))\n\t\t\tcontinue;\n\t\tport = &dev->port[i];\n\t\tport->dev = dev;\n\t\tport->port_num = dev->start_port + i;\n\t\tspin_lock_init(&port->lock);\n\t\tport->table = RB_ROOT;\n\t\tinit_completion(&port->comp);\n\t\trefcount_set(&port->refcount, 1);\n\t\t++count;\n\t}\n\n\tif (!count) {\n\t\tkfree(dev);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tdev->device = device;\n\tib_set_client_data(device, &mcast_client, dev);\n\n\tINIT_IB_EVENT_HANDLER(&dev->event_handler, device, mcast_event_handler);\n\tib_register_event_handler(&dev->event_handler);\n\treturn 0;\n}\n\nstatic void mcast_remove_one(struct ib_device *device, void *client_data)\n{\n\tstruct mcast_device *dev = client_data;\n\tstruct mcast_port *port;\n\tint i;\n\n\tib_unregister_event_handler(&dev->event_handler);\n\tflush_workqueue(mcast_wq);\n\n\tfor (i = 0; i <= dev->end_port - dev->start_port; i++) {\n\t\tif (rdma_cap_ib_mcast(device, dev->start_port + i)) {\n\t\t\tport = &dev->port[i];\n\t\t\tderef_port(port);\n\t\t\twait_for_completion(&port->comp);\n\t\t}\n\t}\n\n\tkfree(dev);\n}\n\nint mcast_init(void)\n{\n\tint ret;\n\n\tmcast_wq = alloc_ordered_workqueue(\"ib_mcast\", WQ_MEM_RECLAIM);\n\tif (!mcast_wq)\n\t\treturn -ENOMEM;\n\n\tib_sa_register_client(&sa_client);\n\n\tret = ib_register_client(&mcast_client);\n\tif (ret)\n\t\tgoto err;\n\treturn 0;\n\nerr:\n\tib_sa_unregister_client(&sa_client);\n\tdestroy_workqueue(mcast_wq);\n\treturn ret;\n}\n\nvoid mcast_cleanup(void)\n{\n\tib_unregister_client(&mcast_client);\n\tib_sa_unregister_client(&sa_client);\n\tdestroy_workqueue(mcast_wq);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}