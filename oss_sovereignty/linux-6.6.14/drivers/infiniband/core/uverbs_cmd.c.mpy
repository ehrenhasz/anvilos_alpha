{
  "module_name": "uverbs_cmd.c",
  "hash_id": "2817022c5f1a3d48f74b5209b9c455da58d75f1bd54ac50ac240c62bf6b86249",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/core/uverbs_cmd.c",
  "human_readable_source": " \n\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#include <linux/uaccess.h>\n\n#include <rdma/uverbs_types.h>\n#include <rdma/uverbs_std_types.h>\n#include \"rdma_core.h\"\n\n#include \"uverbs.h\"\n#include \"core_priv.h\"\n\n \nstatic int uverbs_response(struct uverbs_attr_bundle *attrs, const void *resp,\n\t\t\t   size_t resp_len)\n{\n\tint ret;\n\n\tif (uverbs_attr_is_valid(attrs, UVERBS_ATTR_CORE_OUT))\n\t\treturn uverbs_copy_to_struct_or_zero(\n\t\t\tattrs, UVERBS_ATTR_CORE_OUT, resp, resp_len);\n\n\tif (copy_to_user(attrs->ucore.outbuf, resp,\n\t\t\t min(attrs->ucore.outlen, resp_len)))\n\t\treturn -EFAULT;\n\n\tif (resp_len < attrs->ucore.outlen) {\n\t\t \n\t\tret = clear_user(attrs->ucore.outbuf + resp_len,\n\t\t\t\t attrs->ucore.outlen - resp_len);\n\t\tif (ret)\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int uverbs_request(struct uverbs_attr_bundle *attrs, void *req,\n\t\t\t  size_t req_len)\n{\n\tif (copy_from_user(req, attrs->ucore.inbuf,\n\t\t\t   min(attrs->ucore.inlen, req_len)))\n\t\treturn -EFAULT;\n\n\tif (attrs->ucore.inlen < req_len) {\n\t\tmemset(req + attrs->ucore.inlen, 0,\n\t\t       req_len - attrs->ucore.inlen);\n\t} else if (attrs->ucore.inlen > req_len) {\n\t\tif (!ib_is_buffer_cleared(attrs->ucore.inbuf + req_len,\n\t\t\t\t\t  attrs->ucore.inlen - req_len))\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\n \nstatic u32 uverbs_response_length(struct uverbs_attr_bundle *attrs,\n\t\t\t\t  size_t resp_len)\n{\n\treturn min_t(size_t, attrs->ucore.outlen, resp_len);\n}\n\n \nstruct uverbs_req_iter {\n\tconst void __user *cur;\n\tconst void __user *end;\n};\n\nstatic int uverbs_request_start(struct uverbs_attr_bundle *attrs,\n\t\t\t\tstruct uverbs_req_iter *iter,\n\t\t\t\tvoid *req,\n\t\t\t\tsize_t req_len)\n{\n\tif (attrs->ucore.inlen < req_len)\n\t\treturn -ENOSPC;\n\n\tif (copy_from_user(req, attrs->ucore.inbuf, req_len))\n\t\treturn -EFAULT;\n\n\titer->cur = attrs->ucore.inbuf + req_len;\n\titer->end = attrs->ucore.inbuf + attrs->ucore.inlen;\n\treturn 0;\n}\n\nstatic int uverbs_request_next(struct uverbs_req_iter *iter, void *val,\n\t\t\t       size_t len)\n{\n\tif (iter->cur + len > iter->end)\n\t\treturn -ENOSPC;\n\n\tif (copy_from_user(val, iter->cur, len))\n\t\treturn -EFAULT;\n\n\titer->cur += len;\n\treturn 0;\n}\n\nstatic const void __user *uverbs_request_next_ptr(struct uverbs_req_iter *iter,\n\t\t\t\t\t\t  size_t len)\n{\n\tconst void __user *res = iter->cur;\n\n\tif (iter->cur + len > iter->end)\n\t\treturn (void __force __user *)ERR_PTR(-ENOSPC);\n\titer->cur += len;\n\treturn res;\n}\n\nstatic int uverbs_request_finish(struct uverbs_req_iter *iter)\n{\n\tif (!ib_is_buffer_cleared(iter->cur, iter->end - iter->cur))\n\t\treturn -EOPNOTSUPP;\n\treturn 0;\n}\n\n \nstruct ib_udata *uverbs_get_cleared_udata(struct uverbs_attr_bundle *attrs)\n{\n\tattrs->driver_udata = (struct ib_udata){};\n\treturn &attrs->driver_udata;\n}\n\nstatic struct ib_uverbs_completion_event_file *\n_ib_uverbs_lookup_comp_file(s32 fd, struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uobject *uobj = ufd_get_read(UVERBS_OBJECT_COMP_CHANNEL,\n\t\t\t\t\t       fd, attrs);\n\n\tif (IS_ERR(uobj))\n\t\treturn (void *)uobj;\n\n\tuverbs_uobject_get(uobj);\n\tuobj_put_read(uobj);\n\n\treturn container_of(uobj, struct ib_uverbs_completion_event_file,\n\t\t\t    uobj);\n}\n#define ib_uverbs_lookup_comp_file(_fd, _ufile)                                \\\n\t_ib_uverbs_lookup_comp_file((_fd)*typecheck(s32, _fd), _ufile)\n\nint ib_alloc_ucontext(struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uverbs_file *ufile = attrs->ufile;\n\tstruct ib_ucontext *ucontext;\n\tstruct ib_device *ib_dev;\n\n\tib_dev = srcu_dereference(ufile->device->ib_dev,\n\t\t\t\t  &ufile->device->disassociate_srcu);\n\tif (!ib_dev)\n\t\treturn -EIO;\n\n\tucontext = rdma_zalloc_drv_obj(ib_dev, ib_ucontext);\n\tif (!ucontext)\n\t\treturn -ENOMEM;\n\n\tucontext->device = ib_dev;\n\tucontext->ufile = ufile;\n\txa_init_flags(&ucontext->mmap_xa, XA_FLAGS_ALLOC);\n\n\trdma_restrack_new(&ucontext->res, RDMA_RESTRACK_CTX);\n\trdma_restrack_set_name(&ucontext->res, NULL);\n\tattrs->context = ucontext;\n\treturn 0;\n}\n\nint ib_init_ucontext(struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_ucontext *ucontext = attrs->context;\n\tstruct ib_uverbs_file *file = attrs->ufile;\n\tint ret;\n\n\tif (!down_read_trylock(&file->hw_destroy_rwsem))\n\t\treturn -EIO;\n\tmutex_lock(&file->ucontext_lock);\n\tif (file->ucontext) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tret = ib_rdmacg_try_charge(&ucontext->cg_obj, ucontext->device,\n\t\t\t\t   RDMACG_RESOURCE_HCA_HANDLE);\n\tif (ret)\n\t\tgoto err;\n\n\tret = ucontext->device->ops.alloc_ucontext(ucontext,\n\t\t\t\t\t\t   &attrs->driver_udata);\n\tif (ret)\n\t\tgoto err_uncharge;\n\n\trdma_restrack_add(&ucontext->res);\n\n\t \n\tsmp_store_release(&file->ucontext, ucontext);\n\n\tmutex_unlock(&file->ucontext_lock);\n\tup_read(&file->hw_destroy_rwsem);\n\treturn 0;\n\nerr_uncharge:\n\tib_rdmacg_uncharge(&ucontext->cg_obj, ucontext->device,\n\t\t\t   RDMACG_RESOURCE_HCA_HANDLE);\nerr:\n\tmutex_unlock(&file->ucontext_lock);\n\tup_read(&file->hw_destroy_rwsem);\n\treturn ret;\n}\n\nstatic int ib_uverbs_get_context(struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uverbs_get_context_resp resp;\n\tstruct ib_uverbs_get_context cmd;\n\tstruct ib_device *ib_dev;\n\tstruct ib_uobject *uobj;\n\tint ret;\n\n\tret = uverbs_request(attrs, &cmd, sizeof(cmd));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ib_alloc_ucontext(attrs);\n\tif (ret)\n\t\treturn ret;\n\n\tuobj = uobj_alloc(UVERBS_OBJECT_ASYNC_EVENT, attrs, &ib_dev);\n\tif (IS_ERR(uobj)) {\n\t\tret = PTR_ERR(uobj);\n\t\tgoto err_ucontext;\n\t}\n\n\tresp = (struct ib_uverbs_get_context_resp){\n\t\t.num_comp_vectors = attrs->ufile->device->num_comp_vectors,\n\t\t.async_fd = uobj->id,\n\t};\n\tret = uverbs_response(attrs, &resp, sizeof(resp));\n\tif (ret)\n\t\tgoto err_uobj;\n\n\tret = ib_init_ucontext(attrs);\n\tif (ret)\n\t\tgoto err_uobj;\n\n\tib_uverbs_init_async_event_file(\n\t\tcontainer_of(uobj, struct ib_uverbs_async_event_file, uobj));\n\trdma_alloc_commit_uobject(uobj, attrs);\n\treturn 0;\n\nerr_uobj:\n\trdma_alloc_abort_uobject(uobj, attrs, false);\nerr_ucontext:\n\trdma_restrack_put(&attrs->context->res);\n\tkfree(attrs->context);\n\tattrs->context = NULL;\n\treturn ret;\n}\n\nstatic void copy_query_dev_fields(struct ib_ucontext *ucontext,\n\t\t\t\t  struct ib_uverbs_query_device_resp *resp,\n\t\t\t\t  struct ib_device_attr *attr)\n{\n\tstruct ib_device *ib_dev = ucontext->device;\n\n\tresp->fw_ver\t\t= attr->fw_ver;\n\tresp->node_guid\t\t= ib_dev->node_guid;\n\tresp->sys_image_guid\t= attr->sys_image_guid;\n\tresp->max_mr_size\t= attr->max_mr_size;\n\tresp->page_size_cap\t= attr->page_size_cap;\n\tresp->vendor_id\t\t= attr->vendor_id;\n\tresp->vendor_part_id\t= attr->vendor_part_id;\n\tresp->hw_ver\t\t= attr->hw_ver;\n\tresp->max_qp\t\t= attr->max_qp;\n\tresp->max_qp_wr\t\t= attr->max_qp_wr;\n\tresp->device_cap_flags  = lower_32_bits(attr->device_cap_flags);\n\tresp->max_sge\t\t= min(attr->max_send_sge, attr->max_recv_sge);\n\tresp->max_sge_rd\t= attr->max_sge_rd;\n\tresp->max_cq\t\t= attr->max_cq;\n\tresp->max_cqe\t\t= attr->max_cqe;\n\tresp->max_mr\t\t= attr->max_mr;\n\tresp->max_pd\t\t= attr->max_pd;\n\tresp->max_qp_rd_atom\t= attr->max_qp_rd_atom;\n\tresp->max_ee_rd_atom\t= attr->max_ee_rd_atom;\n\tresp->max_res_rd_atom\t= attr->max_res_rd_atom;\n\tresp->max_qp_init_rd_atom\t= attr->max_qp_init_rd_atom;\n\tresp->max_ee_init_rd_atom\t= attr->max_ee_init_rd_atom;\n\tresp->atomic_cap\t\t= attr->atomic_cap;\n\tresp->max_ee\t\t\t= attr->max_ee;\n\tresp->max_rdd\t\t\t= attr->max_rdd;\n\tresp->max_mw\t\t\t= attr->max_mw;\n\tresp->max_raw_ipv6_qp\t\t= attr->max_raw_ipv6_qp;\n\tresp->max_raw_ethy_qp\t\t= attr->max_raw_ethy_qp;\n\tresp->max_mcast_grp\t\t= attr->max_mcast_grp;\n\tresp->max_mcast_qp_attach\t= attr->max_mcast_qp_attach;\n\tresp->max_total_mcast_qp_attach\t= attr->max_total_mcast_qp_attach;\n\tresp->max_ah\t\t\t= attr->max_ah;\n\tresp->max_srq\t\t\t= attr->max_srq;\n\tresp->max_srq_wr\t\t= attr->max_srq_wr;\n\tresp->max_srq_sge\t\t= attr->max_srq_sge;\n\tresp->max_pkeys\t\t\t= attr->max_pkeys;\n\tresp->local_ca_ack_delay\t= attr->local_ca_ack_delay;\n\tresp->phys_port_cnt = min_t(u32, ib_dev->phys_port_cnt, U8_MAX);\n}\n\nstatic int ib_uverbs_query_device(struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uverbs_query_device      cmd;\n\tstruct ib_uverbs_query_device_resp resp;\n\tstruct ib_ucontext *ucontext;\n\tint ret;\n\n\tucontext = ib_uverbs_get_ucontext(attrs);\n\tif (IS_ERR(ucontext))\n\t\treturn PTR_ERR(ucontext);\n\n\tret = uverbs_request(attrs, &cmd, sizeof(cmd));\n\tif (ret)\n\t\treturn ret;\n\n\tmemset(&resp, 0, sizeof resp);\n\tcopy_query_dev_fields(ucontext, &resp, &ucontext->device->attrs);\n\n\treturn uverbs_response(attrs, &resp, sizeof(resp));\n}\n\nstatic int ib_uverbs_query_port(struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uverbs_query_port      cmd;\n\tstruct ib_uverbs_query_port_resp resp;\n\tstruct ib_port_attr              attr;\n\tint                              ret;\n\tstruct ib_ucontext *ucontext;\n\tstruct ib_device *ib_dev;\n\n\tucontext = ib_uverbs_get_ucontext(attrs);\n\tif (IS_ERR(ucontext))\n\t\treturn PTR_ERR(ucontext);\n\tib_dev = ucontext->device;\n\n\tret = uverbs_request(attrs, &cmd, sizeof(cmd));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ib_query_port(ib_dev, cmd.port_num, &attr);\n\tif (ret)\n\t\treturn ret;\n\n\tmemset(&resp, 0, sizeof resp);\n\tcopy_port_attr_to_resp(&attr, &resp, ib_dev, cmd.port_num);\n\n\treturn uverbs_response(attrs, &resp, sizeof(resp));\n}\n\nstatic int ib_uverbs_alloc_pd(struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uverbs_alloc_pd_resp resp = {};\n\tstruct ib_uverbs_alloc_pd      cmd;\n\tstruct ib_uobject             *uobj;\n\tstruct ib_pd                  *pd;\n\tint                            ret;\n\tstruct ib_device *ib_dev;\n\n\tret = uverbs_request(attrs, &cmd, sizeof(cmd));\n\tif (ret)\n\t\treturn ret;\n\n\tuobj = uobj_alloc(UVERBS_OBJECT_PD, attrs, &ib_dev);\n\tif (IS_ERR(uobj))\n\t\treturn PTR_ERR(uobj);\n\n\tpd = rdma_zalloc_drv_obj(ib_dev, ib_pd);\n\tif (!pd) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tpd->device  = ib_dev;\n\tpd->uobject = uobj;\n\tatomic_set(&pd->usecnt, 0);\n\n\trdma_restrack_new(&pd->res, RDMA_RESTRACK_PD);\n\trdma_restrack_set_name(&pd->res, NULL);\n\n\tret = ib_dev->ops.alloc_pd(pd, &attrs->driver_udata);\n\tif (ret)\n\t\tgoto err_alloc;\n\trdma_restrack_add(&pd->res);\n\n\tuobj->object = pd;\n\tuobj_finalize_uobj_create(uobj, attrs);\n\n\tresp.pd_handle = uobj->id;\n\treturn uverbs_response(attrs, &resp, sizeof(resp));\n\nerr_alloc:\n\trdma_restrack_put(&pd->res);\n\tkfree(pd);\nerr:\n\tuobj_alloc_abort(uobj, attrs);\n\treturn ret;\n}\n\nstatic int ib_uverbs_dealloc_pd(struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uverbs_dealloc_pd cmd;\n\tint ret;\n\n\tret = uverbs_request(attrs, &cmd, sizeof(cmd));\n\tif (ret)\n\t\treturn ret;\n\n\treturn uobj_perform_destroy(UVERBS_OBJECT_PD, cmd.pd_handle, attrs);\n}\n\nstruct xrcd_table_entry {\n\tstruct rb_node  node;\n\tstruct ib_xrcd *xrcd;\n\tstruct inode   *inode;\n};\n\nstatic int xrcd_table_insert(struct ib_uverbs_device *dev,\n\t\t\t    struct inode *inode,\n\t\t\t    struct ib_xrcd *xrcd)\n{\n\tstruct xrcd_table_entry *entry, *scan;\n\tstruct rb_node **p = &dev->xrcd_tree.rb_node;\n\tstruct rb_node *parent = NULL;\n\n\tentry = kmalloc(sizeof *entry, GFP_KERNEL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tentry->xrcd  = xrcd;\n\tentry->inode = inode;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tscan = rb_entry(parent, struct xrcd_table_entry, node);\n\n\t\tif (inode < scan->inode) {\n\t\t\tp = &(*p)->rb_left;\n\t\t} else if (inode > scan->inode) {\n\t\t\tp = &(*p)->rb_right;\n\t\t} else {\n\t\t\tkfree(entry);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\trb_link_node(&entry->node, parent, p);\n\trb_insert_color(&entry->node, &dev->xrcd_tree);\n\tigrab(inode);\n\treturn 0;\n}\n\nstatic struct xrcd_table_entry *xrcd_table_search(struct ib_uverbs_device *dev,\n\t\t\t\t\t\t  struct inode *inode)\n{\n\tstruct xrcd_table_entry *entry;\n\tstruct rb_node *p = dev->xrcd_tree.rb_node;\n\n\twhile (p) {\n\t\tentry = rb_entry(p, struct xrcd_table_entry, node);\n\n\t\tif (inode < entry->inode)\n\t\t\tp = p->rb_left;\n\t\telse if (inode > entry->inode)\n\t\t\tp = p->rb_right;\n\t\telse\n\t\t\treturn entry;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct ib_xrcd *find_xrcd(struct ib_uverbs_device *dev, struct inode *inode)\n{\n\tstruct xrcd_table_entry *entry;\n\n\tentry = xrcd_table_search(dev, inode);\n\tif (!entry)\n\t\treturn NULL;\n\n\treturn entry->xrcd;\n}\n\nstatic void xrcd_table_delete(struct ib_uverbs_device *dev,\n\t\t\t      struct inode *inode)\n{\n\tstruct xrcd_table_entry *entry;\n\n\tentry = xrcd_table_search(dev, inode);\n\tif (entry) {\n\t\tiput(inode);\n\t\trb_erase(&entry->node, &dev->xrcd_tree);\n\t\tkfree(entry);\n\t}\n}\n\nstatic int ib_uverbs_open_xrcd(struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uverbs_device *ibudev = attrs->ufile->device;\n\tstruct ib_uverbs_open_xrcd_resp\tresp = {};\n\tstruct ib_uverbs_open_xrcd\tcmd;\n\tstruct ib_uxrcd_object         *obj;\n\tstruct ib_xrcd                 *xrcd = NULL;\n\tstruct inode                   *inode = NULL;\n\tint\t\t\t\tnew_xrcd = 0;\n\tstruct ib_device *ib_dev;\n\tstruct fd f = {};\n\tint ret;\n\n\tret = uverbs_request(attrs, &cmd, sizeof(cmd));\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&ibudev->xrcd_tree_mutex);\n\n\tif (cmd.fd != -1) {\n\t\t \n\t\tf = fdget(cmd.fd);\n\t\tif (!f.file) {\n\t\t\tret = -EBADF;\n\t\t\tgoto err_tree_mutex_unlock;\n\t\t}\n\n\t\tinode = file_inode(f.file);\n\t\txrcd = find_xrcd(ibudev, inode);\n\t\tif (!xrcd && !(cmd.oflags & O_CREAT)) {\n\t\t\t \n\t\t\tret = -EAGAIN;\n\t\t\tgoto err_tree_mutex_unlock;\n\t\t}\n\n\t\tif (xrcd && cmd.oflags & O_EXCL) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_tree_mutex_unlock;\n\t\t}\n\t}\n\n\tobj = (struct ib_uxrcd_object *)uobj_alloc(UVERBS_OBJECT_XRCD, attrs,\n\t\t\t\t\t\t   &ib_dev);\n\tif (IS_ERR(obj)) {\n\t\tret = PTR_ERR(obj);\n\t\tgoto err_tree_mutex_unlock;\n\t}\n\n\tif (!xrcd) {\n\t\txrcd = ib_alloc_xrcd_user(ib_dev, inode, &attrs->driver_udata);\n\t\tif (IS_ERR(xrcd)) {\n\t\t\tret = PTR_ERR(xrcd);\n\t\t\tgoto err;\n\t\t}\n\t\tnew_xrcd = 1;\n\t}\n\n\tatomic_set(&obj->refcnt, 0);\n\tobj->uobject.object = xrcd;\n\n\tif (inode) {\n\t\tif (new_xrcd) {\n\t\t\t \n\t\t\tret = xrcd_table_insert(ibudev, inode, xrcd);\n\t\t\tif (ret)\n\t\t\t\tgoto err_dealloc_xrcd;\n\t\t}\n\t\tatomic_inc(&xrcd->usecnt);\n\t}\n\n\tif (f.file)\n\t\tfdput(f);\n\n\tmutex_unlock(&ibudev->xrcd_tree_mutex);\n\tuobj_finalize_uobj_create(&obj->uobject, attrs);\n\n\tresp.xrcd_handle = obj->uobject.id;\n\treturn uverbs_response(attrs, &resp, sizeof(resp));\n\nerr_dealloc_xrcd:\n\tib_dealloc_xrcd_user(xrcd, uverbs_get_cleared_udata(attrs));\n\nerr:\n\tuobj_alloc_abort(&obj->uobject, attrs);\n\nerr_tree_mutex_unlock:\n\tif (f.file)\n\t\tfdput(f);\n\n\tmutex_unlock(&ibudev->xrcd_tree_mutex);\n\n\treturn ret;\n}\n\nstatic int ib_uverbs_close_xrcd(struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uverbs_close_xrcd cmd;\n\tint ret;\n\n\tret = uverbs_request(attrs, &cmd, sizeof(cmd));\n\tif (ret)\n\t\treturn ret;\n\n\treturn uobj_perform_destroy(UVERBS_OBJECT_XRCD, cmd.xrcd_handle, attrs);\n}\n\nint ib_uverbs_dealloc_xrcd(struct ib_uobject *uobject, struct ib_xrcd *xrcd,\n\t\t\t   enum rdma_remove_reason why,\n\t\t\t   struct uverbs_attr_bundle *attrs)\n{\n\tstruct inode *inode;\n\tint ret;\n\tstruct ib_uverbs_device *dev = attrs->ufile->device;\n\n\tinode = xrcd->inode;\n\tif (inode && !atomic_dec_and_test(&xrcd->usecnt))\n\t\treturn 0;\n\n\tret = ib_dealloc_xrcd_user(xrcd, &attrs->driver_udata);\n\tif (ret) {\n\t\tatomic_inc(&xrcd->usecnt);\n\t\treturn ret;\n\t}\n\n\tif (inode)\n\t\txrcd_table_delete(dev, inode);\n\n\treturn 0;\n}\n\nstatic int ib_uverbs_reg_mr(struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uverbs_reg_mr_resp resp = {};\n\tstruct ib_uverbs_reg_mr      cmd;\n\tstruct ib_uobject           *uobj;\n\tstruct ib_pd                *pd;\n\tstruct ib_mr                *mr;\n\tint                          ret;\n\tstruct ib_device *ib_dev;\n\n\tret = uverbs_request(attrs, &cmd, sizeof(cmd));\n\tif (ret)\n\t\treturn ret;\n\n\tif ((cmd.start & ~PAGE_MASK) != (cmd.hca_va & ~PAGE_MASK))\n\t\treturn -EINVAL;\n\n\tuobj = uobj_alloc(UVERBS_OBJECT_MR, attrs, &ib_dev);\n\tif (IS_ERR(uobj))\n\t\treturn PTR_ERR(uobj);\n\n\tret = ib_check_mr_access(ib_dev, cmd.access_flags);\n\tif (ret)\n\t\tgoto err_free;\n\n\tpd = uobj_get_obj_read(pd, UVERBS_OBJECT_PD, cmd.pd_handle, attrs);\n\tif (!pd) {\n\t\tret = -EINVAL;\n\t\tgoto err_free;\n\t}\n\n\tmr = pd->device->ops.reg_user_mr(pd, cmd.start, cmd.length, cmd.hca_va,\n\t\t\t\t\t cmd.access_flags,\n\t\t\t\t\t &attrs->driver_udata);\n\tif (IS_ERR(mr)) {\n\t\tret = PTR_ERR(mr);\n\t\tgoto err_put;\n\t}\n\n\tmr->device  = pd->device;\n\tmr->pd      = pd;\n\tmr->type    = IB_MR_TYPE_USER;\n\tmr->dm\t    = NULL;\n\tmr->sig_attrs = NULL;\n\tmr->uobject = uobj;\n\tatomic_inc(&pd->usecnt);\n\tmr->iova = cmd.hca_va;\n\tmr->length = cmd.length;\n\n\trdma_restrack_new(&mr->res, RDMA_RESTRACK_MR);\n\trdma_restrack_set_name(&mr->res, NULL);\n\trdma_restrack_add(&mr->res);\n\n\tuobj->object = mr;\n\tuobj_put_obj_read(pd);\n\tuobj_finalize_uobj_create(uobj, attrs);\n\n\tresp.lkey = mr->lkey;\n\tresp.rkey = mr->rkey;\n\tresp.mr_handle = uobj->id;\n\treturn uverbs_response(attrs, &resp, sizeof(resp));\n\nerr_put:\n\tuobj_put_obj_read(pd);\nerr_free:\n\tuobj_alloc_abort(uobj, attrs);\n\treturn ret;\n}\n\nstatic int ib_uverbs_rereg_mr(struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uverbs_rereg_mr      cmd;\n\tstruct ib_uverbs_rereg_mr_resp resp;\n\tstruct ib_mr                *mr;\n\tint                          ret;\n\tstruct ib_uobject\t    *uobj;\n\tstruct ib_uobject *new_uobj;\n\tstruct ib_device *ib_dev;\n\tstruct ib_pd *orig_pd;\n\tstruct ib_pd *new_pd;\n\tstruct ib_mr *new_mr;\n\n\tret = uverbs_request(attrs, &cmd, sizeof(cmd));\n\tif (ret)\n\t\treturn ret;\n\n\tif (!cmd.flags)\n\t\treturn -EINVAL;\n\n\tif (cmd.flags & ~IB_MR_REREG_SUPPORTED)\n\t\treturn -EOPNOTSUPP;\n\n\tif ((cmd.flags & IB_MR_REREG_TRANS) &&\n\t    (cmd.start & ~PAGE_MASK) != (cmd.hca_va & ~PAGE_MASK))\n\t\treturn -EINVAL;\n\n\tuobj = uobj_get_write(UVERBS_OBJECT_MR, cmd.mr_handle, attrs);\n\tif (IS_ERR(uobj))\n\t\treturn PTR_ERR(uobj);\n\n\tmr = uobj->object;\n\n\tif (mr->dm) {\n\t\tret = -EINVAL;\n\t\tgoto put_uobjs;\n\t}\n\n\tif (cmd.flags & IB_MR_REREG_ACCESS) {\n\t\tret = ib_check_mr_access(mr->device, cmd.access_flags);\n\t\tif (ret)\n\t\t\tgoto put_uobjs;\n\t}\n\n\torig_pd = mr->pd;\n\tif (cmd.flags & IB_MR_REREG_PD) {\n\t\tnew_pd = uobj_get_obj_read(pd, UVERBS_OBJECT_PD, cmd.pd_handle,\n\t\t\t\t\t   attrs);\n\t\tif (!new_pd) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto put_uobjs;\n\t\t}\n\t} else {\n\t\tnew_pd = mr->pd;\n\t}\n\n\t \n\tnew_uobj = uobj_alloc(UVERBS_OBJECT_MR, attrs, &ib_dev);\n\tif (IS_ERR(new_uobj)) {\n\t\tret = PTR_ERR(new_uobj);\n\t\tgoto put_uobj_pd;\n\t}\n\n\tnew_mr = ib_dev->ops.rereg_user_mr(mr, cmd.flags, cmd.start, cmd.length,\n\t\t\t\t\t   cmd.hca_va, cmd.access_flags, new_pd,\n\t\t\t\t\t   &attrs->driver_udata);\n\tif (IS_ERR(new_mr)) {\n\t\tret = PTR_ERR(new_mr);\n\t\tgoto put_new_uobj;\n\t}\n\tif (new_mr) {\n\t\tnew_mr->device = new_pd->device;\n\t\tnew_mr->pd = new_pd;\n\t\tnew_mr->type = IB_MR_TYPE_USER;\n\t\tnew_mr->uobject = uobj;\n\t\tatomic_inc(&new_pd->usecnt);\n\t\tnew_uobj->object = new_mr;\n\n\t\trdma_restrack_new(&new_mr->res, RDMA_RESTRACK_MR);\n\t\trdma_restrack_set_name(&new_mr->res, NULL);\n\t\trdma_restrack_add(&new_mr->res);\n\n\t\t \n\t\trdma_assign_uobject(uobj, new_uobj, attrs);\n\t\trdma_alloc_commit_uobject(new_uobj, attrs);\n\t\tuobj_put_destroy(uobj);\n\t\tnew_uobj = NULL;\n\t\tuobj = NULL;\n\t\tmr = new_mr;\n\t} else {\n\t\tif (cmd.flags & IB_MR_REREG_PD) {\n\t\t\tatomic_dec(&orig_pd->usecnt);\n\t\t\tmr->pd = new_pd;\n\t\t\tatomic_inc(&new_pd->usecnt);\n\t\t}\n\t\tif (cmd.flags & IB_MR_REREG_TRANS) {\n\t\t\tmr->iova = cmd.hca_va;\n\t\t\tmr->length = cmd.length;\n\t\t}\n\t}\n\n\tmemset(&resp, 0, sizeof(resp));\n\tresp.lkey      = mr->lkey;\n\tresp.rkey      = mr->rkey;\n\n\tret = uverbs_response(attrs, &resp, sizeof(resp));\n\nput_new_uobj:\n\tif (new_uobj)\n\t\tuobj_alloc_abort(new_uobj, attrs);\nput_uobj_pd:\n\tif (cmd.flags & IB_MR_REREG_PD)\n\t\tuobj_put_obj_read(new_pd);\n\nput_uobjs:\n\tif (uobj)\n\t\tuobj_put_write(uobj);\n\n\treturn ret;\n}\n\nstatic int ib_uverbs_dereg_mr(struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uverbs_dereg_mr cmd;\n\tint ret;\n\n\tret = uverbs_request(attrs, &cmd, sizeof(cmd));\n\tif (ret)\n\t\treturn ret;\n\n\treturn uobj_perform_destroy(UVERBS_OBJECT_MR, cmd.mr_handle, attrs);\n}\n\nstatic int ib_uverbs_alloc_mw(struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uverbs_alloc_mw      cmd;\n\tstruct ib_uverbs_alloc_mw_resp resp = {};\n\tstruct ib_uobject             *uobj;\n\tstruct ib_pd                  *pd;\n\tstruct ib_mw                  *mw;\n\tint                            ret;\n\tstruct ib_device *ib_dev;\n\n\tret = uverbs_request(attrs, &cmd, sizeof(cmd));\n\tif (ret)\n\t\treturn ret;\n\n\tuobj = uobj_alloc(UVERBS_OBJECT_MW, attrs, &ib_dev);\n\tif (IS_ERR(uobj))\n\t\treturn PTR_ERR(uobj);\n\n\tpd = uobj_get_obj_read(pd, UVERBS_OBJECT_PD, cmd.pd_handle, attrs);\n\tif (!pd) {\n\t\tret = -EINVAL;\n\t\tgoto err_free;\n\t}\n\n\tif (cmd.mw_type != IB_MW_TYPE_1 && cmd.mw_type != IB_MW_TYPE_2) {\n\t\tret = -EINVAL;\n\t\tgoto err_put;\n\t}\n\n\tmw = rdma_zalloc_drv_obj(ib_dev, ib_mw);\n\tif (!mw) {\n\t\tret = -ENOMEM;\n\t\tgoto err_put;\n\t}\n\n\tmw->device = ib_dev;\n\tmw->pd = pd;\n\tmw->uobject = uobj;\n\tmw->type = cmd.mw_type;\n\n\tret = pd->device->ops.alloc_mw(mw, &attrs->driver_udata);\n\tif (ret)\n\t\tgoto err_alloc;\n\n\tatomic_inc(&pd->usecnt);\n\n\tuobj->object = mw;\n\tuobj_put_obj_read(pd);\n\tuobj_finalize_uobj_create(uobj, attrs);\n\n\tresp.rkey = mw->rkey;\n\tresp.mw_handle = uobj->id;\n\treturn uverbs_response(attrs, &resp, sizeof(resp));\n\nerr_alloc:\n\tkfree(mw);\nerr_put:\n\tuobj_put_obj_read(pd);\nerr_free:\n\tuobj_alloc_abort(uobj, attrs);\n\treturn ret;\n}\n\nstatic int ib_uverbs_dealloc_mw(struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uverbs_dealloc_mw cmd;\n\tint ret;\n\n\tret = uverbs_request(attrs, &cmd, sizeof(cmd));\n\tif (ret)\n\t\treturn ret;\n\n\treturn uobj_perform_destroy(UVERBS_OBJECT_MW, cmd.mw_handle, attrs);\n}\n\nstatic int ib_uverbs_create_comp_channel(struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uverbs_create_comp_channel\t   cmd;\n\tstruct ib_uverbs_create_comp_channel_resp  resp;\n\tstruct ib_uobject\t\t\t  *uobj;\n\tstruct ib_uverbs_completion_event_file\t  *ev_file;\n\tstruct ib_device *ib_dev;\n\tint ret;\n\n\tret = uverbs_request(attrs, &cmd, sizeof(cmd));\n\tif (ret)\n\t\treturn ret;\n\n\tuobj = uobj_alloc(UVERBS_OBJECT_COMP_CHANNEL, attrs, &ib_dev);\n\tif (IS_ERR(uobj))\n\t\treturn PTR_ERR(uobj);\n\n\tev_file = container_of(uobj, struct ib_uverbs_completion_event_file,\n\t\t\t       uobj);\n\tib_uverbs_init_event_queue(&ev_file->ev_queue);\n\tuobj_finalize_uobj_create(uobj, attrs);\n\n\tresp.fd = uobj->id;\n\treturn uverbs_response(attrs, &resp, sizeof(resp));\n}\n\nstatic int create_cq(struct uverbs_attr_bundle *attrs,\n\t\t     struct ib_uverbs_ex_create_cq *cmd)\n{\n\tstruct ib_ucq_object           *obj;\n\tstruct ib_uverbs_completion_event_file    *ev_file = NULL;\n\tstruct ib_cq                   *cq;\n\tint                             ret;\n\tstruct ib_uverbs_ex_create_cq_resp resp = {};\n\tstruct ib_cq_init_attr attr = {};\n\tstruct ib_device *ib_dev;\n\n\tif (cmd->comp_vector >= attrs->ufile->device->num_comp_vectors)\n\t\treturn -EINVAL;\n\n\tobj = (struct ib_ucq_object *)uobj_alloc(UVERBS_OBJECT_CQ, attrs,\n\t\t\t\t\t\t &ib_dev);\n\tif (IS_ERR(obj))\n\t\treturn PTR_ERR(obj);\n\n\tif (cmd->comp_channel >= 0) {\n\t\tev_file = ib_uverbs_lookup_comp_file(cmd->comp_channel, attrs);\n\t\tif (IS_ERR(ev_file)) {\n\t\t\tret = PTR_ERR(ev_file);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tobj->uevent.uobject.user_handle = cmd->user_handle;\n\tINIT_LIST_HEAD(&obj->comp_list);\n\tINIT_LIST_HEAD(&obj->uevent.event_list);\n\n\tattr.cqe = cmd->cqe;\n\tattr.comp_vector = cmd->comp_vector;\n\tattr.flags = cmd->flags;\n\n\tcq = rdma_zalloc_drv_obj(ib_dev, ib_cq);\n\tif (!cq) {\n\t\tret = -ENOMEM;\n\t\tgoto err_file;\n\t}\n\tcq->device        = ib_dev;\n\tcq->uobject       = obj;\n\tcq->comp_handler  = ib_uverbs_comp_handler;\n\tcq->event_handler = ib_uverbs_cq_event_handler;\n\tcq->cq_context    = ev_file ? &ev_file->ev_queue : NULL;\n\tatomic_set(&cq->usecnt, 0);\n\n\trdma_restrack_new(&cq->res, RDMA_RESTRACK_CQ);\n\trdma_restrack_set_name(&cq->res, NULL);\n\n\tret = ib_dev->ops.create_cq(cq, &attr, &attrs->driver_udata);\n\tif (ret)\n\t\tgoto err_free;\n\trdma_restrack_add(&cq->res);\n\n\tobj->uevent.uobject.object = cq;\n\tobj->uevent.event_file = READ_ONCE(attrs->ufile->default_async_file);\n\tif (obj->uevent.event_file)\n\t\tuverbs_uobject_get(&obj->uevent.event_file->uobj);\n\tuobj_finalize_uobj_create(&obj->uevent.uobject, attrs);\n\n\tresp.base.cq_handle = obj->uevent.uobject.id;\n\tresp.base.cqe = cq->cqe;\n\tresp.response_length = uverbs_response_length(attrs, sizeof(resp));\n\treturn uverbs_response(attrs, &resp, sizeof(resp));\n\nerr_free:\n\trdma_restrack_put(&cq->res);\n\tkfree(cq);\nerr_file:\n\tif (ev_file)\n\t\tib_uverbs_release_ucq(ev_file, obj);\nerr:\n\tuobj_alloc_abort(&obj->uevent.uobject, attrs);\n\treturn ret;\n}\n\nstatic int ib_uverbs_create_cq(struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uverbs_create_cq      cmd;\n\tstruct ib_uverbs_ex_create_cq\tcmd_ex;\n\tint ret;\n\n\tret = uverbs_request(attrs, &cmd, sizeof(cmd));\n\tif (ret)\n\t\treturn ret;\n\n\tmemset(&cmd_ex, 0, sizeof(cmd_ex));\n\tcmd_ex.user_handle = cmd.user_handle;\n\tcmd_ex.cqe = cmd.cqe;\n\tcmd_ex.comp_vector = cmd.comp_vector;\n\tcmd_ex.comp_channel = cmd.comp_channel;\n\n\treturn create_cq(attrs, &cmd_ex);\n}\n\nstatic int ib_uverbs_ex_create_cq(struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uverbs_ex_create_cq  cmd;\n\tint ret;\n\n\tret = uverbs_request(attrs, &cmd, sizeof(cmd));\n\tif (ret)\n\t\treturn ret;\n\n\tif (cmd.comp_mask)\n\t\treturn -EINVAL;\n\n\tif (cmd.reserved)\n\t\treturn -EINVAL;\n\n\treturn create_cq(attrs, &cmd);\n}\n\nstatic int ib_uverbs_resize_cq(struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uverbs_resize_cq\tcmd;\n\tstruct ib_uverbs_resize_cq_resp\tresp = {};\n\tstruct ib_cq\t\t\t*cq;\n\tint ret;\n\n\tret = uverbs_request(attrs, &cmd, sizeof(cmd));\n\tif (ret)\n\t\treturn ret;\n\n\tcq = uobj_get_obj_read(cq, UVERBS_OBJECT_CQ, cmd.cq_handle, attrs);\n\tif (!cq)\n\t\treturn -EINVAL;\n\n\tret = cq->device->ops.resize_cq(cq, cmd.cqe, &attrs->driver_udata);\n\tif (ret)\n\t\tgoto out;\n\n\tresp.cqe = cq->cqe;\n\n\tret = uverbs_response(attrs, &resp, sizeof(resp));\nout:\n\trdma_lookup_put_uobject(&cq->uobject->uevent.uobject,\n\t\t\t\tUVERBS_LOOKUP_READ);\n\n\treturn ret;\n}\n\nstatic int copy_wc_to_user(struct ib_device *ib_dev, void __user *dest,\n\t\t\t   struct ib_wc *wc)\n{\n\tstruct ib_uverbs_wc tmp;\n\n\ttmp.wr_id\t\t= wc->wr_id;\n\ttmp.status\t\t= wc->status;\n\ttmp.opcode\t\t= wc->opcode;\n\ttmp.vendor_err\t\t= wc->vendor_err;\n\ttmp.byte_len\t\t= wc->byte_len;\n\ttmp.ex.imm_data\t\t= wc->ex.imm_data;\n\ttmp.qp_num\t\t= wc->qp->qp_num;\n\ttmp.src_qp\t\t= wc->src_qp;\n\ttmp.wc_flags\t\t= wc->wc_flags;\n\ttmp.pkey_index\t\t= wc->pkey_index;\n\tif (rdma_cap_opa_ah(ib_dev, wc->port_num))\n\t\ttmp.slid\t= OPA_TO_IB_UCAST_LID(wc->slid);\n\telse\n\t\ttmp.slid\t= ib_lid_cpu16(wc->slid);\n\ttmp.sl\t\t\t= wc->sl;\n\ttmp.dlid_path_bits\t= wc->dlid_path_bits;\n\ttmp.port_num\t\t= wc->port_num;\n\ttmp.reserved\t\t= 0;\n\n\tif (copy_to_user(dest, &tmp, sizeof tmp))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int ib_uverbs_poll_cq(struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uverbs_poll_cq       cmd;\n\tstruct ib_uverbs_poll_cq_resp  resp;\n\tu8 __user                     *header_ptr;\n\tu8 __user                     *data_ptr;\n\tstruct ib_cq                  *cq;\n\tstruct ib_wc                   wc;\n\tint                            ret;\n\n\tret = uverbs_request(attrs, &cmd, sizeof(cmd));\n\tif (ret)\n\t\treturn ret;\n\n\tcq = uobj_get_obj_read(cq, UVERBS_OBJECT_CQ, cmd.cq_handle, attrs);\n\tif (!cq)\n\t\treturn -EINVAL;\n\n\t \n\theader_ptr = attrs->ucore.outbuf;\n\tdata_ptr = header_ptr + sizeof resp;\n\n\tmemset(&resp, 0, sizeof resp);\n\twhile (resp.count < cmd.ne) {\n\t\tret = ib_poll_cq(cq, 1, &wc);\n\t\tif (ret < 0)\n\t\t\tgoto out_put;\n\t\tif (!ret)\n\t\t\tbreak;\n\n\t\tret = copy_wc_to_user(cq->device, data_ptr, &wc);\n\t\tif (ret)\n\t\t\tgoto out_put;\n\n\t\tdata_ptr += sizeof(struct ib_uverbs_wc);\n\t\t++resp.count;\n\t}\n\n\tif (copy_to_user(header_ptr, &resp, sizeof resp)) {\n\t\tret = -EFAULT;\n\t\tgoto out_put;\n\t}\n\tret = 0;\n\n\tif (uverbs_attr_is_valid(attrs, UVERBS_ATTR_CORE_OUT))\n\t\tret = uverbs_output_written(attrs, UVERBS_ATTR_CORE_OUT);\n\nout_put:\n\trdma_lookup_put_uobject(&cq->uobject->uevent.uobject,\n\t\t\t\tUVERBS_LOOKUP_READ);\n\treturn ret;\n}\n\nstatic int ib_uverbs_req_notify_cq(struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uverbs_req_notify_cq cmd;\n\tstruct ib_cq                  *cq;\n\tint ret;\n\n\tret = uverbs_request(attrs, &cmd, sizeof(cmd));\n\tif (ret)\n\t\treturn ret;\n\n\tcq = uobj_get_obj_read(cq, UVERBS_OBJECT_CQ, cmd.cq_handle, attrs);\n\tif (!cq)\n\t\treturn -EINVAL;\n\n\tib_req_notify_cq(cq, cmd.solicited_only ?\n\t\t\t IB_CQ_SOLICITED : IB_CQ_NEXT_COMP);\n\n\trdma_lookup_put_uobject(&cq->uobject->uevent.uobject,\n\t\t\t\tUVERBS_LOOKUP_READ);\n\treturn 0;\n}\n\nstatic int ib_uverbs_destroy_cq(struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uverbs_destroy_cq      cmd;\n\tstruct ib_uverbs_destroy_cq_resp resp;\n\tstruct ib_uobject\t\t*uobj;\n\tstruct ib_ucq_object        \t*obj;\n\tint ret;\n\n\tret = uverbs_request(attrs, &cmd, sizeof(cmd));\n\tif (ret)\n\t\treturn ret;\n\n\tuobj = uobj_get_destroy(UVERBS_OBJECT_CQ, cmd.cq_handle, attrs);\n\tif (IS_ERR(uobj))\n\t\treturn PTR_ERR(uobj);\n\n\tobj = container_of(uobj, struct ib_ucq_object, uevent.uobject);\n\tmemset(&resp, 0, sizeof(resp));\n\tresp.comp_events_reported  = obj->comp_events_reported;\n\tresp.async_events_reported = obj->uevent.events_reported;\n\n\tuobj_put_destroy(uobj);\n\n\treturn uverbs_response(attrs, &resp, sizeof(resp));\n}\n\nstatic int create_qp(struct uverbs_attr_bundle *attrs,\n\t\t     struct ib_uverbs_ex_create_qp *cmd)\n{\n\tstruct ib_uqp_object\t\t*obj;\n\tstruct ib_device\t\t*device;\n\tstruct ib_pd\t\t\t*pd = NULL;\n\tstruct ib_xrcd\t\t\t*xrcd = NULL;\n\tstruct ib_uobject\t\t*xrcd_uobj = ERR_PTR(-ENOENT);\n\tstruct ib_cq\t\t\t*scq = NULL, *rcq = NULL;\n\tstruct ib_srq\t\t\t*srq = NULL;\n\tstruct ib_qp\t\t\t*qp;\n\tstruct ib_qp_init_attr\t\tattr = {};\n\tstruct ib_uverbs_ex_create_qp_resp resp = {};\n\tint\t\t\t\tret;\n\tstruct ib_rwq_ind_table *ind_tbl = NULL;\n\tbool has_sq = true;\n\tstruct ib_device *ib_dev;\n\n\tswitch (cmd->qp_type) {\n\tcase IB_QPT_RAW_PACKET:\n\t\tif (!capable(CAP_NET_RAW))\n\t\t\treturn -EPERM;\n\t\tbreak;\n\tcase IB_QPT_RC:\n\tcase IB_QPT_UC:\n\tcase IB_QPT_UD:\n\tcase IB_QPT_XRC_INI:\n\tcase IB_QPT_XRC_TGT:\n\tcase IB_QPT_DRIVER:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tobj = (struct ib_uqp_object *)uobj_alloc(UVERBS_OBJECT_QP, attrs,\n\t\t\t\t\t\t &ib_dev);\n\tif (IS_ERR(obj))\n\t\treturn PTR_ERR(obj);\n\tobj->uxrcd = NULL;\n\tobj->uevent.uobject.user_handle = cmd->user_handle;\n\tmutex_init(&obj->mcast_lock);\n\n\tif (cmd->comp_mask & IB_UVERBS_CREATE_QP_MASK_IND_TABLE) {\n\t\tind_tbl = uobj_get_obj_read(rwq_ind_table,\n\t\t\t\t\t    UVERBS_OBJECT_RWQ_IND_TBL,\n\t\t\t\t\t    cmd->rwq_ind_tbl_handle, attrs);\n\t\tif (!ind_tbl) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_put;\n\t\t}\n\n\t\tattr.rwq_ind_tbl = ind_tbl;\n\t}\n\n\tif (ind_tbl && (cmd->max_recv_wr || cmd->max_recv_sge || cmd->is_srq)) {\n\t\tret = -EINVAL;\n\t\tgoto err_put;\n\t}\n\n\tif (ind_tbl && !cmd->max_send_wr)\n\t\thas_sq = false;\n\n\tif (cmd->qp_type == IB_QPT_XRC_TGT) {\n\t\txrcd_uobj = uobj_get_read(UVERBS_OBJECT_XRCD, cmd->pd_handle,\n\t\t\t\t\t  attrs);\n\n\t\tif (IS_ERR(xrcd_uobj)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_put;\n\t\t}\n\n\t\txrcd = (struct ib_xrcd *)xrcd_uobj->object;\n\t\tif (!xrcd) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_put;\n\t\t}\n\t\tdevice = xrcd->device;\n\t} else {\n\t\tif (cmd->qp_type == IB_QPT_XRC_INI) {\n\t\t\tcmd->max_recv_wr = 0;\n\t\t\tcmd->max_recv_sge = 0;\n\t\t} else {\n\t\t\tif (cmd->is_srq) {\n\t\t\t\tsrq = uobj_get_obj_read(srq, UVERBS_OBJECT_SRQ,\n\t\t\t\t\t\t\tcmd->srq_handle, attrs);\n\t\t\t\tif (!srq || srq->srq_type == IB_SRQT_XRC) {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tgoto err_put;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ind_tbl) {\n\t\t\t\tif (cmd->recv_cq_handle != cmd->send_cq_handle) {\n\t\t\t\t\trcq = uobj_get_obj_read(\n\t\t\t\t\t\tcq, UVERBS_OBJECT_CQ,\n\t\t\t\t\t\tcmd->recv_cq_handle, attrs);\n\t\t\t\t\tif (!rcq) {\n\t\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\t\tgoto err_put;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (has_sq)\n\t\t\tscq = uobj_get_obj_read(cq, UVERBS_OBJECT_CQ,\n\t\t\t\t\t\tcmd->send_cq_handle, attrs);\n\t\tif (!ind_tbl && cmd->qp_type != IB_QPT_XRC_INI)\n\t\t\trcq = rcq ?: scq;\n\t\tpd = uobj_get_obj_read(pd, UVERBS_OBJECT_PD, cmd->pd_handle,\n\t\t\t\t       attrs);\n\t\tif (!pd || (!scq && has_sq)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_put;\n\t\t}\n\n\t\tdevice = pd->device;\n\t}\n\n\tattr.event_handler = ib_uverbs_qp_event_handler;\n\tattr.send_cq       = scq;\n\tattr.recv_cq       = rcq;\n\tattr.srq           = srq;\n\tattr.xrcd\t   = xrcd;\n\tattr.sq_sig_type   = cmd->sq_sig_all ? IB_SIGNAL_ALL_WR :\n\t\t\t\t\t      IB_SIGNAL_REQ_WR;\n\tattr.qp_type       = cmd->qp_type;\n\n\tattr.cap.max_send_wr     = cmd->max_send_wr;\n\tattr.cap.max_recv_wr     = cmd->max_recv_wr;\n\tattr.cap.max_send_sge    = cmd->max_send_sge;\n\tattr.cap.max_recv_sge    = cmd->max_recv_sge;\n\tattr.cap.max_inline_data = cmd->max_inline_data;\n\n\tINIT_LIST_HEAD(&obj->uevent.event_list);\n\tINIT_LIST_HEAD(&obj->mcast_list);\n\n\tattr.create_flags = cmd->create_flags;\n\tif (attr.create_flags & ~(IB_QP_CREATE_BLOCK_MULTICAST_LOOPBACK |\n\t\t\t\tIB_QP_CREATE_CROSS_CHANNEL |\n\t\t\t\tIB_QP_CREATE_MANAGED_SEND |\n\t\t\t\tIB_QP_CREATE_MANAGED_RECV |\n\t\t\t\tIB_QP_CREATE_SCATTER_FCS |\n\t\t\t\tIB_QP_CREATE_CVLAN_STRIPPING |\n\t\t\t\tIB_QP_CREATE_SOURCE_QPN |\n\t\t\t\tIB_QP_CREATE_PCI_WRITE_END_PADDING)) {\n\t\tret = -EINVAL;\n\t\tgoto err_put;\n\t}\n\n\tif (attr.create_flags & IB_QP_CREATE_SOURCE_QPN) {\n\t\tif (!capable(CAP_NET_RAW)) {\n\t\t\tret = -EPERM;\n\t\t\tgoto err_put;\n\t\t}\n\n\t\tattr.source_qpn = cmd->source_qpn;\n\t}\n\n\tqp = ib_create_qp_user(device, pd, &attr, &attrs->driver_udata, obj,\n\t\t\t       KBUILD_MODNAME);\n\tif (IS_ERR(qp)) {\n\t\tret = PTR_ERR(qp);\n\t\tgoto err_put;\n\t}\n\tib_qp_usecnt_inc(qp);\n\n\tobj->uevent.uobject.object = qp;\n\tobj->uevent.event_file = READ_ONCE(attrs->ufile->default_async_file);\n\tif (obj->uevent.event_file)\n\t\tuverbs_uobject_get(&obj->uevent.event_file->uobj);\n\n\tif (xrcd) {\n\t\tobj->uxrcd = container_of(xrcd_uobj, struct ib_uxrcd_object,\n\t\t\t\t\t  uobject);\n\t\tatomic_inc(&obj->uxrcd->refcnt);\n\t\tuobj_put_read(xrcd_uobj);\n\t}\n\n\tif (pd)\n\t\tuobj_put_obj_read(pd);\n\tif (scq)\n\t\trdma_lookup_put_uobject(&scq->uobject->uevent.uobject,\n\t\t\t\t\tUVERBS_LOOKUP_READ);\n\tif (rcq && rcq != scq)\n\t\trdma_lookup_put_uobject(&rcq->uobject->uevent.uobject,\n\t\t\t\t\tUVERBS_LOOKUP_READ);\n\tif (srq)\n\t\trdma_lookup_put_uobject(&srq->uobject->uevent.uobject,\n\t\t\t\t\tUVERBS_LOOKUP_READ);\n\tif (ind_tbl)\n\t\tuobj_put_obj_read(ind_tbl);\n\tuobj_finalize_uobj_create(&obj->uevent.uobject, attrs);\n\n\tresp.base.qpn             = qp->qp_num;\n\tresp.base.qp_handle       = obj->uevent.uobject.id;\n\tresp.base.max_recv_sge    = attr.cap.max_recv_sge;\n\tresp.base.max_send_sge    = attr.cap.max_send_sge;\n\tresp.base.max_recv_wr     = attr.cap.max_recv_wr;\n\tresp.base.max_send_wr     = attr.cap.max_send_wr;\n\tresp.base.max_inline_data = attr.cap.max_inline_data;\n\tresp.response_length = uverbs_response_length(attrs, sizeof(resp));\n\treturn uverbs_response(attrs, &resp, sizeof(resp));\n\nerr_put:\n\tif (!IS_ERR(xrcd_uobj))\n\t\tuobj_put_read(xrcd_uobj);\n\tif (pd)\n\t\tuobj_put_obj_read(pd);\n\tif (scq)\n\t\trdma_lookup_put_uobject(&scq->uobject->uevent.uobject,\n\t\t\t\t\tUVERBS_LOOKUP_READ);\n\tif (rcq && rcq != scq)\n\t\trdma_lookup_put_uobject(&rcq->uobject->uevent.uobject,\n\t\t\t\t\tUVERBS_LOOKUP_READ);\n\tif (srq)\n\t\trdma_lookup_put_uobject(&srq->uobject->uevent.uobject,\n\t\t\t\t\tUVERBS_LOOKUP_READ);\n\tif (ind_tbl)\n\t\tuobj_put_obj_read(ind_tbl);\n\n\tuobj_alloc_abort(&obj->uevent.uobject, attrs);\n\treturn ret;\n}\n\nstatic int ib_uverbs_create_qp(struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uverbs_create_qp      cmd;\n\tstruct ib_uverbs_ex_create_qp\tcmd_ex;\n\tint ret;\n\n\tret = uverbs_request(attrs, &cmd, sizeof(cmd));\n\tif (ret)\n\t\treturn ret;\n\n\tmemset(&cmd_ex, 0, sizeof(cmd_ex));\n\tcmd_ex.user_handle = cmd.user_handle;\n\tcmd_ex.pd_handle = cmd.pd_handle;\n\tcmd_ex.send_cq_handle = cmd.send_cq_handle;\n\tcmd_ex.recv_cq_handle = cmd.recv_cq_handle;\n\tcmd_ex.srq_handle = cmd.srq_handle;\n\tcmd_ex.max_send_wr = cmd.max_send_wr;\n\tcmd_ex.max_recv_wr = cmd.max_recv_wr;\n\tcmd_ex.max_send_sge = cmd.max_send_sge;\n\tcmd_ex.max_recv_sge = cmd.max_recv_sge;\n\tcmd_ex.max_inline_data = cmd.max_inline_data;\n\tcmd_ex.sq_sig_all = cmd.sq_sig_all;\n\tcmd_ex.qp_type = cmd.qp_type;\n\tcmd_ex.is_srq = cmd.is_srq;\n\n\treturn create_qp(attrs, &cmd_ex);\n}\n\nstatic int ib_uverbs_ex_create_qp(struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uverbs_ex_create_qp cmd;\n\tint ret;\n\n\tret = uverbs_request(attrs, &cmd, sizeof(cmd));\n\tif (ret)\n\t\treturn ret;\n\n\tif (cmd.comp_mask & ~IB_UVERBS_CREATE_QP_SUP_COMP_MASK)\n\t\treturn -EINVAL;\n\n\tif (cmd.reserved)\n\t\treturn -EINVAL;\n\n\treturn create_qp(attrs, &cmd);\n}\n\nstatic int ib_uverbs_open_qp(struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uverbs_create_qp_resp resp = {};\n\tstruct ib_uverbs_open_qp        cmd;\n\tstruct ib_uqp_object           *obj;\n\tstruct ib_xrcd\t\t       *xrcd;\n\tstruct ib_qp                   *qp;\n\tstruct ib_qp_open_attr          attr = {};\n\tint ret;\n\tstruct ib_uobject *xrcd_uobj;\n\tstruct ib_device *ib_dev;\n\n\tret = uverbs_request(attrs, &cmd, sizeof(cmd));\n\tif (ret)\n\t\treturn ret;\n\n\tobj = (struct ib_uqp_object *)uobj_alloc(UVERBS_OBJECT_QP, attrs,\n\t\t\t\t\t\t &ib_dev);\n\tif (IS_ERR(obj))\n\t\treturn PTR_ERR(obj);\n\n\txrcd_uobj = uobj_get_read(UVERBS_OBJECT_XRCD, cmd.pd_handle, attrs);\n\tif (IS_ERR(xrcd_uobj)) {\n\t\tret = -EINVAL;\n\t\tgoto err_put;\n\t}\n\n\txrcd = (struct ib_xrcd *)xrcd_uobj->object;\n\tif (!xrcd) {\n\t\tret = -EINVAL;\n\t\tgoto err_xrcd;\n\t}\n\n\tattr.event_handler = ib_uverbs_qp_event_handler;\n\tattr.qp_num        = cmd.qpn;\n\tattr.qp_type       = cmd.qp_type;\n\n\tINIT_LIST_HEAD(&obj->uevent.event_list);\n\tINIT_LIST_HEAD(&obj->mcast_list);\n\n\tqp = ib_open_qp(xrcd, &attr);\n\tif (IS_ERR(qp)) {\n\t\tret = PTR_ERR(qp);\n\t\tgoto err_xrcd;\n\t}\n\n\tobj->uevent.uobject.object = qp;\n\tobj->uevent.uobject.user_handle = cmd.user_handle;\n\n\tobj->uxrcd = container_of(xrcd_uobj, struct ib_uxrcd_object, uobject);\n\tatomic_inc(&obj->uxrcd->refcnt);\n\tqp->uobject = obj;\n\tuobj_put_read(xrcd_uobj);\n\tuobj_finalize_uobj_create(&obj->uevent.uobject, attrs);\n\n\tresp.qpn = qp->qp_num;\n\tresp.qp_handle = obj->uevent.uobject.id;\n\treturn uverbs_response(attrs, &resp, sizeof(resp));\n\nerr_xrcd:\n\tuobj_put_read(xrcd_uobj);\nerr_put:\n\tuobj_alloc_abort(&obj->uevent.uobject, attrs);\n\treturn ret;\n}\n\nstatic void copy_ah_attr_to_uverbs(struct ib_uverbs_qp_dest *uverb_attr,\n\t\t\t\t   struct rdma_ah_attr *rdma_attr)\n{\n\tconst struct ib_global_route   *grh;\n\n\tuverb_attr->dlid              = rdma_ah_get_dlid(rdma_attr);\n\tuverb_attr->sl                = rdma_ah_get_sl(rdma_attr);\n\tuverb_attr->src_path_bits     = rdma_ah_get_path_bits(rdma_attr);\n\tuverb_attr->static_rate       = rdma_ah_get_static_rate(rdma_attr);\n\tuverb_attr->is_global         = !!(rdma_ah_get_ah_flags(rdma_attr) &\n\t\t\t\t\t IB_AH_GRH);\n\tif (uverb_attr->is_global) {\n\t\tgrh = rdma_ah_read_grh(rdma_attr);\n\t\tmemcpy(uverb_attr->dgid, grh->dgid.raw, 16);\n\t\tuverb_attr->flow_label        = grh->flow_label;\n\t\tuverb_attr->sgid_index        = grh->sgid_index;\n\t\tuverb_attr->hop_limit         = grh->hop_limit;\n\t\tuverb_attr->traffic_class     = grh->traffic_class;\n\t}\n\tuverb_attr->port_num          = rdma_ah_get_port_num(rdma_attr);\n}\n\nstatic int ib_uverbs_query_qp(struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uverbs_query_qp      cmd;\n\tstruct ib_uverbs_query_qp_resp resp;\n\tstruct ib_qp                   *qp;\n\tstruct ib_qp_attr              *attr;\n\tstruct ib_qp_init_attr         *init_attr;\n\tint                            ret;\n\n\tret = uverbs_request(attrs, &cmd, sizeof(cmd));\n\tif (ret)\n\t\treturn ret;\n\n\tattr      = kmalloc(sizeof *attr, GFP_KERNEL);\n\tinit_attr = kmalloc(sizeof *init_attr, GFP_KERNEL);\n\tif (!attr || !init_attr) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tqp = uobj_get_obj_read(qp, UVERBS_OBJECT_QP, cmd.qp_handle, attrs);\n\tif (!qp) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = ib_query_qp(qp, attr, cmd.attr_mask, init_attr);\n\n\trdma_lookup_put_uobject(&qp->uobject->uevent.uobject,\n\t\t\t\tUVERBS_LOOKUP_READ);\n\n\tif (ret)\n\t\tgoto out;\n\n\tmemset(&resp, 0, sizeof resp);\n\n\tresp.qp_state               = attr->qp_state;\n\tresp.cur_qp_state           = attr->cur_qp_state;\n\tresp.path_mtu               = attr->path_mtu;\n\tresp.path_mig_state         = attr->path_mig_state;\n\tresp.qkey                   = attr->qkey;\n\tresp.rq_psn                 = attr->rq_psn;\n\tresp.sq_psn                 = attr->sq_psn;\n\tresp.dest_qp_num            = attr->dest_qp_num;\n\tresp.qp_access_flags        = attr->qp_access_flags;\n\tresp.pkey_index             = attr->pkey_index;\n\tresp.alt_pkey_index         = attr->alt_pkey_index;\n\tresp.sq_draining            = attr->sq_draining;\n\tresp.max_rd_atomic          = attr->max_rd_atomic;\n\tresp.max_dest_rd_atomic     = attr->max_dest_rd_atomic;\n\tresp.min_rnr_timer          = attr->min_rnr_timer;\n\tresp.port_num               = attr->port_num;\n\tresp.timeout                = attr->timeout;\n\tresp.retry_cnt              = attr->retry_cnt;\n\tresp.rnr_retry              = attr->rnr_retry;\n\tresp.alt_port_num           = attr->alt_port_num;\n\tresp.alt_timeout            = attr->alt_timeout;\n\n\tcopy_ah_attr_to_uverbs(&resp.dest, &attr->ah_attr);\n\tcopy_ah_attr_to_uverbs(&resp.alt_dest, &attr->alt_ah_attr);\n\n\tresp.max_send_wr            = init_attr->cap.max_send_wr;\n\tresp.max_recv_wr            = init_attr->cap.max_recv_wr;\n\tresp.max_send_sge           = init_attr->cap.max_send_sge;\n\tresp.max_recv_sge           = init_attr->cap.max_recv_sge;\n\tresp.max_inline_data        = init_attr->cap.max_inline_data;\n\tresp.sq_sig_all             = init_attr->sq_sig_type == IB_SIGNAL_ALL_WR;\n\n\tret = uverbs_response(attrs, &resp, sizeof(resp));\n\nout:\n\tkfree(attr);\n\tkfree(init_attr);\n\n\treturn ret;\n}\n\n \nstatic int modify_qp_mask(enum ib_qp_type qp_type, int mask)\n{\n\tswitch (qp_type) {\n\tcase IB_QPT_XRC_INI:\n\t\treturn mask & ~(IB_QP_MAX_DEST_RD_ATOMIC | IB_QP_MIN_RNR_TIMER);\n\tcase IB_QPT_XRC_TGT:\n\t\treturn mask & ~(IB_QP_MAX_QP_RD_ATOMIC | IB_QP_RETRY_CNT |\n\t\t\t\tIB_QP_RNR_RETRY);\n\tdefault:\n\t\treturn mask;\n\t}\n}\n\nstatic void copy_ah_attr_from_uverbs(struct ib_device *dev,\n\t\t\t\t     struct rdma_ah_attr *rdma_attr,\n\t\t\t\t     struct ib_uverbs_qp_dest *uverb_attr)\n{\n\trdma_attr->type = rdma_ah_find_type(dev, uverb_attr->port_num);\n\tif (uverb_attr->is_global) {\n\t\trdma_ah_set_grh(rdma_attr, NULL,\n\t\t\t\tuverb_attr->flow_label,\n\t\t\t\tuverb_attr->sgid_index,\n\t\t\t\tuverb_attr->hop_limit,\n\t\t\t\tuverb_attr->traffic_class);\n\t\trdma_ah_set_dgid_raw(rdma_attr, uverb_attr->dgid);\n\t} else {\n\t\trdma_ah_set_ah_flags(rdma_attr, 0);\n\t}\n\trdma_ah_set_dlid(rdma_attr, uverb_attr->dlid);\n\trdma_ah_set_sl(rdma_attr, uverb_attr->sl);\n\trdma_ah_set_path_bits(rdma_attr, uverb_attr->src_path_bits);\n\trdma_ah_set_static_rate(rdma_attr, uverb_attr->static_rate);\n\trdma_ah_set_port_num(rdma_attr, uverb_attr->port_num);\n\trdma_ah_set_make_grd(rdma_attr, false);\n}\n\nstatic int modify_qp(struct uverbs_attr_bundle *attrs,\n\t\t     struct ib_uverbs_ex_modify_qp *cmd)\n{\n\tstruct ib_qp_attr *attr;\n\tstruct ib_qp *qp;\n\tint ret;\n\n\tattr = kzalloc(sizeof(*attr), GFP_KERNEL);\n\tif (!attr)\n\t\treturn -ENOMEM;\n\n\tqp = uobj_get_obj_read(qp, UVERBS_OBJECT_QP, cmd->base.qp_handle,\n\t\t\t       attrs);\n\tif (!qp) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif ((cmd->base.attr_mask & IB_QP_PORT) &&\n\t    !rdma_is_port_valid(qp->device, cmd->base.port_num)) {\n\t\tret = -EINVAL;\n\t\tgoto release_qp;\n\t}\n\n\tif ((cmd->base.attr_mask & IB_QP_AV)) {\n\t\tif (!rdma_is_port_valid(qp->device, cmd->base.dest.port_num)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto release_qp;\n\t\t}\n\n\t\tif (cmd->base.attr_mask & IB_QP_STATE &&\n\t\t    cmd->base.qp_state == IB_QPS_RTR) {\n\t\t \n\t\t\tif (cmd->base.dest.port_num != qp->real_qp->port) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto release_qp;\n\t\t\t}\n\t\t} else {\n\t\t \n\t\t\tif (((cmd->base.attr_mask & (IB_QP_AV | IB_QP_PORT))\n\t\t\t     == (IB_QP_AV | IB_QP_PORT)) &&\n\t\t\t    cmd->base.port_num != cmd->base.dest.port_num) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto release_qp;\n\t\t\t}\n\t\t\tif ((cmd->base.attr_mask & (IB_QP_AV | IB_QP_PORT))\n\t\t\t    == IB_QP_AV) {\n\t\t\t\tcmd->base.attr_mask |= IB_QP_PORT;\n\t\t\t\tcmd->base.port_num = cmd->base.dest.port_num;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ((cmd->base.attr_mask & IB_QP_ALT_PATH) &&\n\t    (!rdma_is_port_valid(qp->device, cmd->base.alt_port_num) ||\n\t    !rdma_is_port_valid(qp->device, cmd->base.alt_dest.port_num) ||\n\t    cmd->base.alt_port_num != cmd->base.alt_dest.port_num)) {\n\t\tret = -EINVAL;\n\t\tgoto release_qp;\n\t}\n\n\tif ((cmd->base.attr_mask & IB_QP_CUR_STATE &&\n\t    cmd->base.cur_qp_state > IB_QPS_ERR) ||\n\t    (cmd->base.attr_mask & IB_QP_STATE &&\n\t    cmd->base.qp_state > IB_QPS_ERR)) {\n\t\tret = -EINVAL;\n\t\tgoto release_qp;\n\t}\n\n\tif (cmd->base.attr_mask & IB_QP_STATE)\n\t\tattr->qp_state = cmd->base.qp_state;\n\tif (cmd->base.attr_mask & IB_QP_CUR_STATE)\n\t\tattr->cur_qp_state = cmd->base.cur_qp_state;\n\tif (cmd->base.attr_mask & IB_QP_PATH_MTU)\n\t\tattr->path_mtu = cmd->base.path_mtu;\n\tif (cmd->base.attr_mask & IB_QP_PATH_MIG_STATE)\n\t\tattr->path_mig_state = cmd->base.path_mig_state;\n\tif (cmd->base.attr_mask & IB_QP_QKEY) {\n\t\tif (cmd->base.qkey & IB_QP_SET_QKEY && !capable(CAP_NET_RAW)) {\n\t\t\tret = -EPERM;\n\t\t\tgoto release_qp;\n\t\t}\n\t\tattr->qkey = cmd->base.qkey;\n\t}\n\tif (cmd->base.attr_mask & IB_QP_RQ_PSN)\n\t\tattr->rq_psn = cmd->base.rq_psn;\n\tif (cmd->base.attr_mask & IB_QP_SQ_PSN)\n\t\tattr->sq_psn = cmd->base.sq_psn;\n\tif (cmd->base.attr_mask & IB_QP_DEST_QPN)\n\t\tattr->dest_qp_num = cmd->base.dest_qp_num;\n\tif (cmd->base.attr_mask & IB_QP_ACCESS_FLAGS)\n\t\tattr->qp_access_flags = cmd->base.qp_access_flags;\n\tif (cmd->base.attr_mask & IB_QP_PKEY_INDEX)\n\t\tattr->pkey_index = cmd->base.pkey_index;\n\tif (cmd->base.attr_mask & IB_QP_EN_SQD_ASYNC_NOTIFY)\n\t\tattr->en_sqd_async_notify = cmd->base.en_sqd_async_notify;\n\tif (cmd->base.attr_mask & IB_QP_MAX_QP_RD_ATOMIC)\n\t\tattr->max_rd_atomic = cmd->base.max_rd_atomic;\n\tif (cmd->base.attr_mask & IB_QP_MAX_DEST_RD_ATOMIC)\n\t\tattr->max_dest_rd_atomic = cmd->base.max_dest_rd_atomic;\n\tif (cmd->base.attr_mask & IB_QP_MIN_RNR_TIMER)\n\t\tattr->min_rnr_timer = cmd->base.min_rnr_timer;\n\tif (cmd->base.attr_mask & IB_QP_PORT)\n\t\tattr->port_num = cmd->base.port_num;\n\tif (cmd->base.attr_mask & IB_QP_TIMEOUT)\n\t\tattr->timeout = cmd->base.timeout;\n\tif (cmd->base.attr_mask & IB_QP_RETRY_CNT)\n\t\tattr->retry_cnt = cmd->base.retry_cnt;\n\tif (cmd->base.attr_mask & IB_QP_RNR_RETRY)\n\t\tattr->rnr_retry = cmd->base.rnr_retry;\n\tif (cmd->base.attr_mask & IB_QP_ALT_PATH) {\n\t\tattr->alt_port_num = cmd->base.alt_port_num;\n\t\tattr->alt_timeout = cmd->base.alt_timeout;\n\t\tattr->alt_pkey_index = cmd->base.alt_pkey_index;\n\t}\n\tif (cmd->base.attr_mask & IB_QP_RATE_LIMIT)\n\t\tattr->rate_limit = cmd->rate_limit;\n\n\tif (cmd->base.attr_mask & IB_QP_AV)\n\t\tcopy_ah_attr_from_uverbs(qp->device, &attr->ah_attr,\n\t\t\t\t\t &cmd->base.dest);\n\n\tif (cmd->base.attr_mask & IB_QP_ALT_PATH)\n\t\tcopy_ah_attr_from_uverbs(qp->device, &attr->alt_ah_attr,\n\t\t\t\t\t &cmd->base.alt_dest);\n\n\tret = ib_modify_qp_with_udata(qp, attr,\n\t\t\t\t      modify_qp_mask(qp->qp_type,\n\t\t\t\t\t\t     cmd->base.attr_mask),\n\t\t\t\t      &attrs->driver_udata);\n\nrelease_qp:\n\trdma_lookup_put_uobject(&qp->uobject->uevent.uobject,\n\t\t\t\tUVERBS_LOOKUP_READ);\nout:\n\tkfree(attr);\n\n\treturn ret;\n}\n\nstatic int ib_uverbs_modify_qp(struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uverbs_ex_modify_qp cmd;\n\tint ret;\n\n\tret = uverbs_request(attrs, &cmd.base, sizeof(cmd.base));\n\tif (ret)\n\t\treturn ret;\n\n\tif (cmd.base.attr_mask & ~IB_QP_ATTR_STANDARD_BITS)\n\t\treturn -EOPNOTSUPP;\n\n\treturn modify_qp(attrs, &cmd);\n}\n\nstatic int ib_uverbs_ex_modify_qp(struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uverbs_ex_modify_qp cmd;\n\tstruct ib_uverbs_ex_modify_qp_resp resp = {\n\t\t.response_length = uverbs_response_length(attrs, sizeof(resp))\n\t};\n\tint ret;\n\n\tret = uverbs_request(attrs, &cmd, sizeof(cmd));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (cmd.base.attr_mask & ~(IB_QP_ATTR_STANDARD_BITS | IB_QP_RATE_LIMIT))\n\t\treturn -EOPNOTSUPP;\n\n\tret = modify_qp(attrs, &cmd);\n\tif (ret)\n\t\treturn ret;\n\n\treturn uverbs_response(attrs, &resp, sizeof(resp));\n}\n\nstatic int ib_uverbs_destroy_qp(struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uverbs_destroy_qp      cmd;\n\tstruct ib_uverbs_destroy_qp_resp resp;\n\tstruct ib_uobject\t\t*uobj;\n\tstruct ib_uqp_object        \t*obj;\n\tint ret;\n\n\tret = uverbs_request(attrs, &cmd, sizeof(cmd));\n\tif (ret)\n\t\treturn ret;\n\n\tuobj = uobj_get_destroy(UVERBS_OBJECT_QP, cmd.qp_handle, attrs);\n\tif (IS_ERR(uobj))\n\t\treturn PTR_ERR(uobj);\n\n\tobj = container_of(uobj, struct ib_uqp_object, uevent.uobject);\n\tmemset(&resp, 0, sizeof(resp));\n\tresp.events_reported = obj->uevent.events_reported;\n\n\tuobj_put_destroy(uobj);\n\n\treturn uverbs_response(attrs, &resp, sizeof(resp));\n}\n\nstatic void *alloc_wr(size_t wr_size, __u32 num_sge)\n{\n\tif (num_sge >= (U32_MAX - ALIGN(wr_size, sizeof(struct ib_sge))) /\n\t\t\t       sizeof(struct ib_sge))\n\t\treturn NULL;\n\n\treturn kmalloc(ALIGN(wr_size, sizeof(struct ib_sge)) +\n\t\t\t       num_sge * sizeof(struct ib_sge),\n\t\t       GFP_KERNEL);\n}\n\nstatic int ib_uverbs_post_send(struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uverbs_post_send      cmd;\n\tstruct ib_uverbs_post_send_resp resp;\n\tstruct ib_uverbs_send_wr       *user_wr;\n\tstruct ib_send_wr              *wr = NULL, *last, *next;\n\tconst struct ib_send_wr\t       *bad_wr;\n\tstruct ib_qp                   *qp;\n\tint                             i, sg_ind;\n\tint\t\t\t\tis_ud;\n\tint ret, ret2;\n\tsize_t                          next_size;\n\tconst struct ib_sge __user *sgls;\n\tconst void __user *wqes;\n\tstruct uverbs_req_iter iter;\n\n\tret = uverbs_request_start(attrs, &iter, &cmd, sizeof(cmd));\n\tif (ret)\n\t\treturn ret;\n\twqes = uverbs_request_next_ptr(&iter, cmd.wqe_size * cmd.wr_count);\n\tif (IS_ERR(wqes))\n\t\treturn PTR_ERR(wqes);\n\tsgls = uverbs_request_next_ptr(\n\t\t&iter, cmd.sge_count * sizeof(struct ib_uverbs_sge));\n\tif (IS_ERR(sgls))\n\t\treturn PTR_ERR(sgls);\n\tret = uverbs_request_finish(&iter);\n\tif (ret)\n\t\treturn ret;\n\n\tuser_wr = kmalloc(cmd.wqe_size, GFP_KERNEL);\n\tif (!user_wr)\n\t\treturn -ENOMEM;\n\n\tqp = uobj_get_obj_read(qp, UVERBS_OBJECT_QP, cmd.qp_handle, attrs);\n\tif (!qp) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tis_ud = qp->qp_type == IB_QPT_UD;\n\tsg_ind = 0;\n\tlast = NULL;\n\tfor (i = 0; i < cmd.wr_count; ++i) {\n\t\tif (copy_from_user(user_wr, wqes + i * cmd.wqe_size,\n\t\t\t\t   cmd.wqe_size)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out_put;\n\t\t}\n\n\t\tif (user_wr->num_sge + sg_ind > cmd.sge_count) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_put;\n\t\t}\n\n\t\tif (is_ud) {\n\t\t\tstruct ib_ud_wr *ud;\n\n\t\t\tif (user_wr->opcode != IB_WR_SEND &&\n\t\t\t    user_wr->opcode != IB_WR_SEND_WITH_IMM) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out_put;\n\t\t\t}\n\n\t\t\tnext_size = sizeof(*ud);\n\t\t\tud = alloc_wr(next_size, user_wr->num_sge);\n\t\t\tif (!ud) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out_put;\n\t\t\t}\n\n\t\t\tud->ah = uobj_get_obj_read(ah, UVERBS_OBJECT_AH,\n\t\t\t\t\t\t   user_wr->wr.ud.ah, attrs);\n\t\t\tif (!ud->ah) {\n\t\t\t\tkfree(ud);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out_put;\n\t\t\t}\n\t\t\tud->remote_qpn = user_wr->wr.ud.remote_qpn;\n\t\t\tud->remote_qkey = user_wr->wr.ud.remote_qkey;\n\n\t\t\tnext = &ud->wr;\n\t\t} else if (user_wr->opcode == IB_WR_RDMA_WRITE_WITH_IMM ||\n\t\t\t   user_wr->opcode == IB_WR_RDMA_WRITE ||\n\t\t\t   user_wr->opcode == IB_WR_RDMA_READ) {\n\t\t\tstruct ib_rdma_wr *rdma;\n\n\t\t\tnext_size = sizeof(*rdma);\n\t\t\trdma = alloc_wr(next_size, user_wr->num_sge);\n\t\t\tif (!rdma) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out_put;\n\t\t\t}\n\n\t\t\trdma->remote_addr = user_wr->wr.rdma.remote_addr;\n\t\t\trdma->rkey = user_wr->wr.rdma.rkey;\n\n\t\t\tnext = &rdma->wr;\n\t\t} else if (user_wr->opcode == IB_WR_ATOMIC_CMP_AND_SWP ||\n\t\t\t   user_wr->opcode == IB_WR_ATOMIC_FETCH_AND_ADD) {\n\t\t\tstruct ib_atomic_wr *atomic;\n\n\t\t\tnext_size = sizeof(*atomic);\n\t\t\tatomic = alloc_wr(next_size, user_wr->num_sge);\n\t\t\tif (!atomic) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out_put;\n\t\t\t}\n\n\t\t\tatomic->remote_addr = user_wr->wr.atomic.remote_addr;\n\t\t\tatomic->compare_add = user_wr->wr.atomic.compare_add;\n\t\t\tatomic->swap = user_wr->wr.atomic.swap;\n\t\t\tatomic->rkey = user_wr->wr.atomic.rkey;\n\n\t\t\tnext = &atomic->wr;\n\t\t} else if (user_wr->opcode == IB_WR_SEND ||\n\t\t\t   user_wr->opcode == IB_WR_SEND_WITH_IMM ||\n\t\t\t   user_wr->opcode == IB_WR_SEND_WITH_INV) {\n\t\t\tnext_size = sizeof(*next);\n\t\t\tnext = alloc_wr(next_size, user_wr->num_sge);\n\t\t\tif (!next) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out_put;\n\t\t\t}\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_put;\n\t\t}\n\n\t\tif (user_wr->opcode == IB_WR_SEND_WITH_IMM ||\n\t\t    user_wr->opcode == IB_WR_RDMA_WRITE_WITH_IMM) {\n\t\t\tnext->ex.imm_data =\n\t\t\t\t\t(__be32 __force) user_wr->ex.imm_data;\n\t\t} else if (user_wr->opcode == IB_WR_SEND_WITH_INV) {\n\t\t\tnext->ex.invalidate_rkey = user_wr->ex.invalidate_rkey;\n\t\t}\n\n\t\tif (!last)\n\t\t\twr = next;\n\t\telse\n\t\t\tlast->next = next;\n\t\tlast = next;\n\n\t\tnext->next       = NULL;\n\t\tnext->wr_id      = user_wr->wr_id;\n\t\tnext->num_sge    = user_wr->num_sge;\n\t\tnext->opcode     = user_wr->opcode;\n\t\tnext->send_flags = user_wr->send_flags;\n\n\t\tif (next->num_sge) {\n\t\t\tnext->sg_list = (void *) next +\n\t\t\t\tALIGN(next_size, sizeof(struct ib_sge));\n\t\t\tif (copy_from_user(next->sg_list, sgls + sg_ind,\n\t\t\t\t\t   next->num_sge *\n\t\t\t\t\t\t   sizeof(struct ib_sge))) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out_put;\n\t\t\t}\n\t\t\tsg_ind += next->num_sge;\n\t\t} else\n\t\t\tnext->sg_list = NULL;\n\t}\n\n\tresp.bad_wr = 0;\n\tret = qp->device->ops.post_send(qp->real_qp, wr, &bad_wr);\n\tif (ret)\n\t\tfor (next = wr; next; next = next->next) {\n\t\t\t++resp.bad_wr;\n\t\t\tif (next == bad_wr)\n\t\t\t\tbreak;\n\t\t}\n\n\tret2 = uverbs_response(attrs, &resp, sizeof(resp));\n\tif (ret2)\n\t\tret = ret2;\n\nout_put:\n\trdma_lookup_put_uobject(&qp->uobject->uevent.uobject,\n\t\t\t\tUVERBS_LOOKUP_READ);\n\n\twhile (wr) {\n\t\tif (is_ud && ud_wr(wr)->ah)\n\t\t\tuobj_put_obj_read(ud_wr(wr)->ah);\n\t\tnext = wr->next;\n\t\tkfree(wr);\n\t\twr = next;\n\t}\n\nout:\n\tkfree(user_wr);\n\n\treturn ret;\n}\n\nstatic struct ib_recv_wr *\nib_uverbs_unmarshall_recv(struct uverbs_req_iter *iter, u32 wr_count,\n\t\t\t  u32 wqe_size, u32 sge_count)\n{\n\tstruct ib_uverbs_recv_wr *user_wr;\n\tstruct ib_recv_wr        *wr = NULL, *last, *next;\n\tint                       sg_ind;\n\tint                       i;\n\tint                       ret;\n\tconst struct ib_sge __user *sgls;\n\tconst void __user *wqes;\n\n\tif (wqe_size < sizeof(struct ib_uverbs_recv_wr))\n\t\treturn ERR_PTR(-EINVAL);\n\n\twqes = uverbs_request_next_ptr(iter, wqe_size * wr_count);\n\tif (IS_ERR(wqes))\n\t\treturn ERR_CAST(wqes);\n\tsgls = uverbs_request_next_ptr(\n\t\titer, sge_count * sizeof(struct ib_uverbs_sge));\n\tif (IS_ERR(sgls))\n\t\treturn ERR_CAST(sgls);\n\tret = uverbs_request_finish(iter);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tuser_wr = kmalloc(wqe_size, GFP_KERNEL);\n\tif (!user_wr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tsg_ind = 0;\n\tlast = NULL;\n\tfor (i = 0; i < wr_count; ++i) {\n\t\tif (copy_from_user(user_wr, wqes + i * wqe_size,\n\t\t\t\t   wqe_size)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (user_wr->num_sge + sg_ind > sge_count) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (user_wr->num_sge >=\n\t\t    (U32_MAX - ALIGN(sizeof(*next), sizeof(struct ib_sge))) /\n\t\t\t    sizeof(struct ib_sge)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tnext = kmalloc(ALIGN(sizeof(*next), sizeof(struct ib_sge)) +\n\t\t\t\t       user_wr->num_sge * sizeof(struct ib_sge),\n\t\t\t       GFP_KERNEL);\n\t\tif (!next) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (!last)\n\t\t\twr = next;\n\t\telse\n\t\t\tlast->next = next;\n\t\tlast = next;\n\n\t\tnext->next       = NULL;\n\t\tnext->wr_id      = user_wr->wr_id;\n\t\tnext->num_sge    = user_wr->num_sge;\n\n\t\tif (next->num_sge) {\n\t\t\tnext->sg_list = (void *)next +\n\t\t\t\tALIGN(sizeof(*next), sizeof(struct ib_sge));\n\t\t\tif (copy_from_user(next->sg_list, sgls + sg_ind,\n\t\t\t\t\t   next->num_sge *\n\t\t\t\t\t\t   sizeof(struct ib_sge))) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tsg_ind += next->num_sge;\n\t\t} else\n\t\t\tnext->sg_list = NULL;\n\t}\n\n\tkfree(user_wr);\n\treturn wr;\n\nerr:\n\tkfree(user_wr);\n\n\twhile (wr) {\n\t\tnext = wr->next;\n\t\tkfree(wr);\n\t\twr = next;\n\t}\n\n\treturn ERR_PTR(ret);\n}\n\nstatic int ib_uverbs_post_recv(struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uverbs_post_recv      cmd;\n\tstruct ib_uverbs_post_recv_resp resp;\n\tstruct ib_recv_wr              *wr, *next;\n\tconst struct ib_recv_wr\t       *bad_wr;\n\tstruct ib_qp                   *qp;\n\tint ret, ret2;\n\tstruct uverbs_req_iter iter;\n\n\tret = uverbs_request_start(attrs, &iter, &cmd, sizeof(cmd));\n\tif (ret)\n\t\treturn ret;\n\n\twr = ib_uverbs_unmarshall_recv(&iter, cmd.wr_count, cmd.wqe_size,\n\t\t\t\t       cmd.sge_count);\n\tif (IS_ERR(wr))\n\t\treturn PTR_ERR(wr);\n\n\tqp = uobj_get_obj_read(qp, UVERBS_OBJECT_QP, cmd.qp_handle, attrs);\n\tif (!qp) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tresp.bad_wr = 0;\n\tret = qp->device->ops.post_recv(qp->real_qp, wr, &bad_wr);\n\n\trdma_lookup_put_uobject(&qp->uobject->uevent.uobject,\n\t\t\t\tUVERBS_LOOKUP_READ);\n\tif (ret) {\n\t\tfor (next = wr; next; next = next->next) {\n\t\t\t++resp.bad_wr;\n\t\t\tif (next == bad_wr)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tret2 = uverbs_response(attrs, &resp, sizeof(resp));\n\tif (ret2)\n\t\tret = ret2;\nout:\n\twhile (wr) {\n\t\tnext = wr->next;\n\t\tkfree(wr);\n\t\twr = next;\n\t}\n\n\treturn ret;\n}\n\nstatic int ib_uverbs_post_srq_recv(struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uverbs_post_srq_recv      cmd;\n\tstruct ib_uverbs_post_srq_recv_resp resp;\n\tstruct ib_recv_wr                  *wr, *next;\n\tconst struct ib_recv_wr\t\t   *bad_wr;\n\tstruct ib_srq                      *srq;\n\tint ret, ret2;\n\tstruct uverbs_req_iter iter;\n\n\tret = uverbs_request_start(attrs, &iter, &cmd, sizeof(cmd));\n\tif (ret)\n\t\treturn ret;\n\n\twr = ib_uverbs_unmarshall_recv(&iter, cmd.wr_count, cmd.wqe_size,\n\t\t\t\t       cmd.sge_count);\n\tif (IS_ERR(wr))\n\t\treturn PTR_ERR(wr);\n\n\tsrq = uobj_get_obj_read(srq, UVERBS_OBJECT_SRQ, cmd.srq_handle, attrs);\n\tif (!srq) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tresp.bad_wr = 0;\n\tret = srq->device->ops.post_srq_recv(srq, wr, &bad_wr);\n\n\trdma_lookup_put_uobject(&srq->uobject->uevent.uobject,\n\t\t\t\tUVERBS_LOOKUP_READ);\n\n\tif (ret)\n\t\tfor (next = wr; next; next = next->next) {\n\t\t\t++resp.bad_wr;\n\t\t\tif (next == bad_wr)\n\t\t\t\tbreak;\n\t\t}\n\n\tret2 = uverbs_response(attrs, &resp, sizeof(resp));\n\tif (ret2)\n\t\tret = ret2;\n\nout:\n\twhile (wr) {\n\t\tnext = wr->next;\n\t\tkfree(wr);\n\t\twr = next;\n\t}\n\n\treturn ret;\n}\n\nstatic int ib_uverbs_create_ah(struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uverbs_create_ah\t cmd;\n\tstruct ib_uverbs_create_ah_resp\t resp;\n\tstruct ib_uobject\t\t*uobj;\n\tstruct ib_pd\t\t\t*pd;\n\tstruct ib_ah\t\t\t*ah;\n\tstruct rdma_ah_attr\t\tattr = {};\n\tint ret;\n\tstruct ib_device *ib_dev;\n\n\tret = uverbs_request(attrs, &cmd, sizeof(cmd));\n\tif (ret)\n\t\treturn ret;\n\n\tuobj = uobj_alloc(UVERBS_OBJECT_AH, attrs, &ib_dev);\n\tif (IS_ERR(uobj))\n\t\treturn PTR_ERR(uobj);\n\n\tif (!rdma_is_port_valid(ib_dev, cmd.attr.port_num)) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tpd = uobj_get_obj_read(pd, UVERBS_OBJECT_PD, cmd.pd_handle, attrs);\n\tif (!pd) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tattr.type = rdma_ah_find_type(ib_dev, cmd.attr.port_num);\n\trdma_ah_set_make_grd(&attr, false);\n\trdma_ah_set_dlid(&attr, cmd.attr.dlid);\n\trdma_ah_set_sl(&attr, cmd.attr.sl);\n\trdma_ah_set_path_bits(&attr, cmd.attr.src_path_bits);\n\trdma_ah_set_static_rate(&attr, cmd.attr.static_rate);\n\trdma_ah_set_port_num(&attr, cmd.attr.port_num);\n\n\tif (cmd.attr.is_global) {\n\t\trdma_ah_set_grh(&attr, NULL, cmd.attr.grh.flow_label,\n\t\t\t\tcmd.attr.grh.sgid_index,\n\t\t\t\tcmd.attr.grh.hop_limit,\n\t\t\t\tcmd.attr.grh.traffic_class);\n\t\trdma_ah_set_dgid_raw(&attr, cmd.attr.grh.dgid);\n\t} else {\n\t\trdma_ah_set_ah_flags(&attr, 0);\n\t}\n\n\tah = rdma_create_user_ah(pd, &attr, &attrs->driver_udata);\n\tif (IS_ERR(ah)) {\n\t\tret = PTR_ERR(ah);\n\t\tgoto err_put;\n\t}\n\n\tah->uobject  = uobj;\n\tuobj->user_handle = cmd.user_handle;\n\tuobj->object = ah;\n\tuobj_put_obj_read(pd);\n\tuobj_finalize_uobj_create(uobj, attrs);\n\n\tresp.ah_handle = uobj->id;\n\treturn uverbs_response(attrs, &resp, sizeof(resp));\n\nerr_put:\n\tuobj_put_obj_read(pd);\nerr:\n\tuobj_alloc_abort(uobj, attrs);\n\treturn ret;\n}\n\nstatic int ib_uverbs_destroy_ah(struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uverbs_destroy_ah cmd;\n\tint ret;\n\n\tret = uverbs_request(attrs, &cmd, sizeof(cmd));\n\tif (ret)\n\t\treturn ret;\n\n\treturn uobj_perform_destroy(UVERBS_OBJECT_AH, cmd.ah_handle, attrs);\n}\n\nstatic int ib_uverbs_attach_mcast(struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uverbs_attach_mcast cmd;\n\tstruct ib_qp                 *qp;\n\tstruct ib_uqp_object         *obj;\n\tstruct ib_uverbs_mcast_entry *mcast;\n\tint                           ret;\n\n\tret = uverbs_request(attrs, &cmd, sizeof(cmd));\n\tif (ret)\n\t\treturn ret;\n\n\tqp = uobj_get_obj_read(qp, UVERBS_OBJECT_QP, cmd.qp_handle, attrs);\n\tif (!qp)\n\t\treturn -EINVAL;\n\n\tobj = qp->uobject;\n\n\tmutex_lock(&obj->mcast_lock);\n\tlist_for_each_entry(mcast, &obj->mcast_list, list)\n\t\tif (cmd.mlid == mcast->lid &&\n\t\t    !memcmp(cmd.gid, mcast->gid.raw, sizeof mcast->gid.raw)) {\n\t\t\tret = 0;\n\t\t\tgoto out_put;\n\t\t}\n\n\tmcast = kmalloc(sizeof *mcast, GFP_KERNEL);\n\tif (!mcast) {\n\t\tret = -ENOMEM;\n\t\tgoto out_put;\n\t}\n\n\tmcast->lid = cmd.mlid;\n\tmemcpy(mcast->gid.raw, cmd.gid, sizeof mcast->gid.raw);\n\n\tret = ib_attach_mcast(qp, &mcast->gid, cmd.mlid);\n\tif (!ret)\n\t\tlist_add_tail(&mcast->list, &obj->mcast_list);\n\telse\n\t\tkfree(mcast);\n\nout_put:\n\tmutex_unlock(&obj->mcast_lock);\n\trdma_lookup_put_uobject(&qp->uobject->uevent.uobject,\n\t\t\t\tUVERBS_LOOKUP_READ);\n\n\treturn ret;\n}\n\nstatic int ib_uverbs_detach_mcast(struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uverbs_detach_mcast cmd;\n\tstruct ib_uqp_object         *obj;\n\tstruct ib_qp                 *qp;\n\tstruct ib_uverbs_mcast_entry *mcast;\n\tint                           ret;\n\tbool                          found = false;\n\n\tret = uverbs_request(attrs, &cmd, sizeof(cmd));\n\tif (ret)\n\t\treturn ret;\n\n\tqp = uobj_get_obj_read(qp, UVERBS_OBJECT_QP, cmd.qp_handle, attrs);\n\tif (!qp)\n\t\treturn -EINVAL;\n\n\tobj = qp->uobject;\n\tmutex_lock(&obj->mcast_lock);\n\n\tlist_for_each_entry(mcast, &obj->mcast_list, list)\n\t\tif (cmd.mlid == mcast->lid &&\n\t\t    !memcmp(cmd.gid, mcast->gid.raw, sizeof mcast->gid.raw)) {\n\t\t\tlist_del(&mcast->list);\n\t\t\tkfree(mcast);\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\n\tif (!found) {\n\t\tret = -EINVAL;\n\t\tgoto out_put;\n\t}\n\n\tret = ib_detach_mcast(qp, (union ib_gid *)cmd.gid, cmd.mlid);\n\nout_put:\n\tmutex_unlock(&obj->mcast_lock);\n\trdma_lookup_put_uobject(&qp->uobject->uevent.uobject,\n\t\t\t\tUVERBS_LOOKUP_READ);\n\treturn ret;\n}\n\nstruct ib_uflow_resources *flow_resources_alloc(size_t num_specs)\n{\n\tstruct ib_uflow_resources *resources;\n\n\tresources = kzalloc(sizeof(*resources), GFP_KERNEL);\n\n\tif (!resources)\n\t\treturn NULL;\n\n\tif (!num_specs)\n\t\tgoto out;\n\n\tresources->counters =\n\t\tkcalloc(num_specs, sizeof(*resources->counters), GFP_KERNEL);\n\tresources->collection =\n\t\tkcalloc(num_specs, sizeof(*resources->collection), GFP_KERNEL);\n\n\tif (!resources->counters || !resources->collection)\n\t\tgoto err;\n\nout:\n\tresources->max = num_specs;\n\treturn resources;\n\nerr:\n\tkfree(resources->counters);\n\tkfree(resources);\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(flow_resources_alloc);\n\nvoid ib_uverbs_flow_resources_free(struct ib_uflow_resources *uflow_res)\n{\n\tunsigned int i;\n\n\tif (!uflow_res)\n\t\treturn;\n\n\tfor (i = 0; i < uflow_res->collection_num; i++)\n\t\tatomic_dec(&uflow_res->collection[i]->usecnt);\n\n\tfor (i = 0; i < uflow_res->counters_num; i++)\n\t\tatomic_dec(&uflow_res->counters[i]->usecnt);\n\n\tkfree(uflow_res->collection);\n\tkfree(uflow_res->counters);\n\tkfree(uflow_res);\n}\nEXPORT_SYMBOL(ib_uverbs_flow_resources_free);\n\nvoid flow_resources_add(struct ib_uflow_resources *uflow_res,\n\t\t\tenum ib_flow_spec_type type,\n\t\t\tvoid *ibobj)\n{\n\tWARN_ON(uflow_res->num >= uflow_res->max);\n\n\tswitch (type) {\n\tcase IB_FLOW_SPEC_ACTION_HANDLE:\n\t\tatomic_inc(&((struct ib_flow_action *)ibobj)->usecnt);\n\t\tuflow_res->collection[uflow_res->collection_num++] =\n\t\t\t(struct ib_flow_action *)ibobj;\n\t\tbreak;\n\tcase IB_FLOW_SPEC_ACTION_COUNT:\n\t\tatomic_inc(&((struct ib_counters *)ibobj)->usecnt);\n\t\tuflow_res->counters[uflow_res->counters_num++] =\n\t\t\t(struct ib_counters *)ibobj;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n\n\tuflow_res->num++;\n}\nEXPORT_SYMBOL(flow_resources_add);\n\nstatic int kern_spec_to_ib_spec_action(struct uverbs_attr_bundle *attrs,\n\t\t\t\t       struct ib_uverbs_flow_spec *kern_spec,\n\t\t\t\t       union ib_flow_spec *ib_spec,\n\t\t\t\t       struct ib_uflow_resources *uflow_res)\n{\n\tib_spec->type = kern_spec->type;\n\tswitch (ib_spec->type) {\n\tcase IB_FLOW_SPEC_ACTION_TAG:\n\t\tif (kern_spec->flow_tag.size !=\n\t\t    sizeof(struct ib_uverbs_flow_spec_action_tag))\n\t\t\treturn -EINVAL;\n\n\t\tib_spec->flow_tag.size = sizeof(struct ib_flow_spec_action_tag);\n\t\tib_spec->flow_tag.tag_id = kern_spec->flow_tag.tag_id;\n\t\tbreak;\n\tcase IB_FLOW_SPEC_ACTION_DROP:\n\t\tif (kern_spec->drop.size !=\n\t\t    sizeof(struct ib_uverbs_flow_spec_action_drop))\n\t\t\treturn -EINVAL;\n\n\t\tib_spec->drop.size = sizeof(struct ib_flow_spec_action_drop);\n\t\tbreak;\n\tcase IB_FLOW_SPEC_ACTION_HANDLE:\n\t\tif (kern_spec->action.size !=\n\t\t    sizeof(struct ib_uverbs_flow_spec_action_handle))\n\t\t\treturn -EOPNOTSUPP;\n\t\tib_spec->action.act = uobj_get_obj_read(flow_action,\n\t\t\t\t\t\t\tUVERBS_OBJECT_FLOW_ACTION,\n\t\t\t\t\t\t\tkern_spec->action.handle,\n\t\t\t\t\t\t\tattrs);\n\t\tif (!ib_spec->action.act)\n\t\t\treturn -EINVAL;\n\t\tib_spec->action.size =\n\t\t\tsizeof(struct ib_flow_spec_action_handle);\n\t\tflow_resources_add(uflow_res,\n\t\t\t\t   IB_FLOW_SPEC_ACTION_HANDLE,\n\t\t\t\t   ib_spec->action.act);\n\t\tuobj_put_obj_read(ib_spec->action.act);\n\t\tbreak;\n\tcase IB_FLOW_SPEC_ACTION_COUNT:\n\t\tif (kern_spec->flow_count.size !=\n\t\t\tsizeof(struct ib_uverbs_flow_spec_action_count))\n\t\t\treturn -EINVAL;\n\t\tib_spec->flow_count.counters =\n\t\t\tuobj_get_obj_read(counters,\n\t\t\t\t\t  UVERBS_OBJECT_COUNTERS,\n\t\t\t\t\t  kern_spec->flow_count.handle,\n\t\t\t\t\t  attrs);\n\t\tif (!ib_spec->flow_count.counters)\n\t\t\treturn -EINVAL;\n\t\tib_spec->flow_count.size =\n\t\t\t\tsizeof(struct ib_flow_spec_action_count);\n\t\tflow_resources_add(uflow_res,\n\t\t\t\t   IB_FLOW_SPEC_ACTION_COUNT,\n\t\t\t\t   ib_spec->flow_count.counters);\n\t\tuobj_put_obj_read(ib_spec->flow_count.counters);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic ssize_t spec_filter_size(const void *kern_spec_filter, u16 kern_filter_size,\n\t\t\t\tu16 ib_real_filter_sz)\n{\n\t \n\n\tif (kern_filter_size > ib_real_filter_sz) {\n\t\tif (memchr_inv(kern_spec_filter +\n\t\t\t       ib_real_filter_sz, 0,\n\t\t\t       kern_filter_size - ib_real_filter_sz))\n\t\t\treturn -EINVAL;\n\t\treturn ib_real_filter_sz;\n\t}\n\treturn kern_filter_size;\n}\n\nint ib_uverbs_kern_spec_to_ib_spec_filter(enum ib_flow_spec_type type,\n\t\t\t\t\t  const void *kern_spec_mask,\n\t\t\t\t\t  const void *kern_spec_val,\n\t\t\t\t\t  size_t kern_filter_sz,\n\t\t\t\t\t  union ib_flow_spec *ib_spec)\n{\n\tssize_t actual_filter_sz;\n\tssize_t ib_filter_sz;\n\n\t \n\tif (kern_filter_sz != ALIGN(kern_filter_sz, 4))\n\t\treturn -EINVAL;\n\n\tib_spec->type = type;\n\n\tif (ib_spec->type == (IB_FLOW_SPEC_INNER | IB_FLOW_SPEC_VXLAN_TUNNEL))\n\t\treturn -EINVAL;\n\n\tswitch (ib_spec->type & ~IB_FLOW_SPEC_INNER) {\n\tcase IB_FLOW_SPEC_ETH:\n\t\tib_filter_sz = offsetof(struct ib_flow_eth_filter, real_sz);\n\t\tactual_filter_sz = spec_filter_size(kern_spec_mask,\n\t\t\t\t\t\t    kern_filter_sz,\n\t\t\t\t\t\t    ib_filter_sz);\n\t\tif (actual_filter_sz <= 0)\n\t\t\treturn -EINVAL;\n\t\tib_spec->size = sizeof(struct ib_flow_spec_eth);\n\t\tmemcpy(&ib_spec->eth.val, kern_spec_val, actual_filter_sz);\n\t\tmemcpy(&ib_spec->eth.mask, kern_spec_mask, actual_filter_sz);\n\t\tbreak;\n\tcase IB_FLOW_SPEC_IPV4:\n\t\tib_filter_sz = offsetof(struct ib_flow_ipv4_filter, real_sz);\n\t\tactual_filter_sz = spec_filter_size(kern_spec_mask,\n\t\t\t\t\t\t    kern_filter_sz,\n\t\t\t\t\t\t    ib_filter_sz);\n\t\tif (actual_filter_sz <= 0)\n\t\t\treturn -EINVAL;\n\t\tib_spec->size = sizeof(struct ib_flow_spec_ipv4);\n\t\tmemcpy(&ib_spec->ipv4.val, kern_spec_val, actual_filter_sz);\n\t\tmemcpy(&ib_spec->ipv4.mask, kern_spec_mask, actual_filter_sz);\n\t\tbreak;\n\tcase IB_FLOW_SPEC_IPV6:\n\t\tib_filter_sz = offsetof(struct ib_flow_ipv6_filter, real_sz);\n\t\tactual_filter_sz = spec_filter_size(kern_spec_mask,\n\t\t\t\t\t\t    kern_filter_sz,\n\t\t\t\t\t\t    ib_filter_sz);\n\t\tif (actual_filter_sz <= 0)\n\t\t\treturn -EINVAL;\n\t\tib_spec->size = sizeof(struct ib_flow_spec_ipv6);\n\t\tmemcpy(&ib_spec->ipv6.val, kern_spec_val, actual_filter_sz);\n\t\tmemcpy(&ib_spec->ipv6.mask, kern_spec_mask, actual_filter_sz);\n\n\t\tif ((ntohl(ib_spec->ipv6.mask.flow_label)) >= BIT(20) ||\n\t\t    (ntohl(ib_spec->ipv6.val.flow_label)) >= BIT(20))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase IB_FLOW_SPEC_TCP:\n\tcase IB_FLOW_SPEC_UDP:\n\t\tib_filter_sz = offsetof(struct ib_flow_tcp_udp_filter, real_sz);\n\t\tactual_filter_sz = spec_filter_size(kern_spec_mask,\n\t\t\t\t\t\t    kern_filter_sz,\n\t\t\t\t\t\t    ib_filter_sz);\n\t\tif (actual_filter_sz <= 0)\n\t\t\treturn -EINVAL;\n\t\tib_spec->size = sizeof(struct ib_flow_spec_tcp_udp);\n\t\tmemcpy(&ib_spec->tcp_udp.val, kern_spec_val, actual_filter_sz);\n\t\tmemcpy(&ib_spec->tcp_udp.mask, kern_spec_mask, actual_filter_sz);\n\t\tbreak;\n\tcase IB_FLOW_SPEC_VXLAN_TUNNEL:\n\t\tib_filter_sz = offsetof(struct ib_flow_tunnel_filter, real_sz);\n\t\tactual_filter_sz = spec_filter_size(kern_spec_mask,\n\t\t\t\t\t\t    kern_filter_sz,\n\t\t\t\t\t\t    ib_filter_sz);\n\t\tif (actual_filter_sz <= 0)\n\t\t\treturn -EINVAL;\n\t\tib_spec->tunnel.size = sizeof(struct ib_flow_spec_tunnel);\n\t\tmemcpy(&ib_spec->tunnel.val, kern_spec_val, actual_filter_sz);\n\t\tmemcpy(&ib_spec->tunnel.mask, kern_spec_mask, actual_filter_sz);\n\n\t\tif ((ntohl(ib_spec->tunnel.mask.tunnel_id)) >= BIT(24) ||\n\t\t    (ntohl(ib_spec->tunnel.val.tunnel_id)) >= BIT(24))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase IB_FLOW_SPEC_ESP:\n\t\tib_filter_sz = offsetof(struct ib_flow_esp_filter, real_sz);\n\t\tactual_filter_sz = spec_filter_size(kern_spec_mask,\n\t\t\t\t\t\t    kern_filter_sz,\n\t\t\t\t\t\t    ib_filter_sz);\n\t\tif (actual_filter_sz <= 0)\n\t\t\treturn -EINVAL;\n\t\tib_spec->esp.size = sizeof(struct ib_flow_spec_esp);\n\t\tmemcpy(&ib_spec->esp.val, kern_spec_val, actual_filter_sz);\n\t\tmemcpy(&ib_spec->esp.mask, kern_spec_mask, actual_filter_sz);\n\t\tbreak;\n\tcase IB_FLOW_SPEC_GRE:\n\t\tib_filter_sz = offsetof(struct ib_flow_gre_filter, real_sz);\n\t\tactual_filter_sz = spec_filter_size(kern_spec_mask,\n\t\t\t\t\t\t    kern_filter_sz,\n\t\t\t\t\t\t    ib_filter_sz);\n\t\tif (actual_filter_sz <= 0)\n\t\t\treturn -EINVAL;\n\t\tib_spec->gre.size = sizeof(struct ib_flow_spec_gre);\n\t\tmemcpy(&ib_spec->gre.val, kern_spec_val, actual_filter_sz);\n\t\tmemcpy(&ib_spec->gre.mask, kern_spec_mask, actual_filter_sz);\n\t\tbreak;\n\tcase IB_FLOW_SPEC_MPLS:\n\t\tib_filter_sz = offsetof(struct ib_flow_mpls_filter, real_sz);\n\t\tactual_filter_sz = spec_filter_size(kern_spec_mask,\n\t\t\t\t\t\t    kern_filter_sz,\n\t\t\t\t\t\t    ib_filter_sz);\n\t\tif (actual_filter_sz <= 0)\n\t\t\treturn -EINVAL;\n\t\tib_spec->mpls.size = sizeof(struct ib_flow_spec_mpls);\n\t\tmemcpy(&ib_spec->mpls.val, kern_spec_val, actual_filter_sz);\n\t\tmemcpy(&ib_spec->mpls.mask, kern_spec_mask, actual_filter_sz);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int kern_spec_to_ib_spec_filter(struct ib_uverbs_flow_spec *kern_spec,\n\t\t\t\t       union ib_flow_spec *ib_spec)\n{\n\tsize_t kern_filter_sz;\n\tvoid *kern_spec_mask;\n\tvoid *kern_spec_val;\n\n\tif (check_sub_overflow((size_t)kern_spec->hdr.size,\n\t\t\t       sizeof(struct ib_uverbs_flow_spec_hdr),\n\t\t\t       &kern_filter_sz))\n\t\treturn -EINVAL;\n\n\tkern_filter_sz /= 2;\n\n\tkern_spec_val = (void *)kern_spec +\n\t\tsizeof(struct ib_uverbs_flow_spec_hdr);\n\tkern_spec_mask = kern_spec_val + kern_filter_sz;\n\n\treturn ib_uverbs_kern_spec_to_ib_spec_filter(kern_spec->type,\n\t\t\t\t\t\t     kern_spec_mask,\n\t\t\t\t\t\t     kern_spec_val,\n\t\t\t\t\t\t     kern_filter_sz, ib_spec);\n}\n\nstatic int kern_spec_to_ib_spec(struct uverbs_attr_bundle *attrs,\n\t\t\t\tstruct ib_uverbs_flow_spec *kern_spec,\n\t\t\t\tunion ib_flow_spec *ib_spec,\n\t\t\t\tstruct ib_uflow_resources *uflow_res)\n{\n\tif (kern_spec->reserved)\n\t\treturn -EINVAL;\n\n\tif (kern_spec->type >= IB_FLOW_SPEC_ACTION_TAG)\n\t\treturn kern_spec_to_ib_spec_action(attrs, kern_spec, ib_spec,\n\t\t\t\t\t\t   uflow_res);\n\telse\n\t\treturn kern_spec_to_ib_spec_filter(kern_spec, ib_spec);\n}\n\nstatic int ib_uverbs_ex_create_wq(struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uverbs_ex_create_wq cmd;\n\tstruct ib_uverbs_ex_create_wq_resp resp = {};\n\tstruct ib_uwq_object           *obj;\n\tint err = 0;\n\tstruct ib_cq *cq;\n\tstruct ib_pd *pd;\n\tstruct ib_wq *wq;\n\tstruct ib_wq_init_attr wq_init_attr = {};\n\tstruct ib_device *ib_dev;\n\n\terr = uverbs_request(attrs, &cmd, sizeof(cmd));\n\tif (err)\n\t\treturn err;\n\n\tif (cmd.comp_mask)\n\t\treturn -EOPNOTSUPP;\n\n\tobj = (struct ib_uwq_object *)uobj_alloc(UVERBS_OBJECT_WQ, attrs,\n\t\t\t\t\t\t &ib_dev);\n\tif (IS_ERR(obj))\n\t\treturn PTR_ERR(obj);\n\n\tpd = uobj_get_obj_read(pd, UVERBS_OBJECT_PD, cmd.pd_handle, attrs);\n\tif (!pd) {\n\t\terr = -EINVAL;\n\t\tgoto err_uobj;\n\t}\n\n\tcq = uobj_get_obj_read(cq, UVERBS_OBJECT_CQ, cmd.cq_handle, attrs);\n\tif (!cq) {\n\t\terr = -EINVAL;\n\t\tgoto err_put_pd;\n\t}\n\n\twq_init_attr.cq = cq;\n\twq_init_attr.max_sge = cmd.max_sge;\n\twq_init_attr.max_wr = cmd.max_wr;\n\twq_init_attr.wq_type = cmd.wq_type;\n\twq_init_attr.event_handler = ib_uverbs_wq_event_handler;\n\twq_init_attr.create_flags = cmd.create_flags;\n\tINIT_LIST_HEAD(&obj->uevent.event_list);\n\tobj->uevent.uobject.user_handle = cmd.user_handle;\n\n\twq = pd->device->ops.create_wq(pd, &wq_init_attr, &attrs->driver_udata);\n\tif (IS_ERR(wq)) {\n\t\terr = PTR_ERR(wq);\n\t\tgoto err_put_cq;\n\t}\n\n\twq->uobject = obj;\n\tobj->uevent.uobject.object = wq;\n\twq->wq_type = wq_init_attr.wq_type;\n\twq->cq = cq;\n\twq->pd = pd;\n\twq->device = pd->device;\n\tatomic_set(&wq->usecnt, 0);\n\tatomic_inc(&pd->usecnt);\n\tatomic_inc(&cq->usecnt);\n\tobj->uevent.event_file = READ_ONCE(attrs->ufile->default_async_file);\n\tif (obj->uevent.event_file)\n\t\tuverbs_uobject_get(&obj->uevent.event_file->uobj);\n\n\tuobj_put_obj_read(pd);\n\trdma_lookup_put_uobject(&cq->uobject->uevent.uobject,\n\t\t\t\tUVERBS_LOOKUP_READ);\n\tuobj_finalize_uobj_create(&obj->uevent.uobject, attrs);\n\n\tresp.wq_handle = obj->uevent.uobject.id;\n\tresp.max_sge = wq_init_attr.max_sge;\n\tresp.max_wr = wq_init_attr.max_wr;\n\tresp.wqn = wq->wq_num;\n\tresp.response_length = uverbs_response_length(attrs, sizeof(resp));\n\treturn uverbs_response(attrs, &resp, sizeof(resp));\n\nerr_put_cq:\n\trdma_lookup_put_uobject(&cq->uobject->uevent.uobject,\n\t\t\t\tUVERBS_LOOKUP_READ);\nerr_put_pd:\n\tuobj_put_obj_read(pd);\nerr_uobj:\n\tuobj_alloc_abort(&obj->uevent.uobject, attrs);\n\n\treturn err;\n}\n\nstatic int ib_uverbs_ex_destroy_wq(struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uverbs_ex_destroy_wq\tcmd;\n\tstruct ib_uverbs_ex_destroy_wq_resp\tresp = {};\n\tstruct ib_uobject\t\t*uobj;\n\tstruct ib_uwq_object\t\t*obj;\n\tint\t\t\t\tret;\n\n\tret = uverbs_request(attrs, &cmd, sizeof(cmd));\n\tif (ret)\n\t\treturn ret;\n\n\tif (cmd.comp_mask)\n\t\treturn -EOPNOTSUPP;\n\n\tresp.response_length = uverbs_response_length(attrs, sizeof(resp));\n\tuobj = uobj_get_destroy(UVERBS_OBJECT_WQ, cmd.wq_handle, attrs);\n\tif (IS_ERR(uobj))\n\t\treturn PTR_ERR(uobj);\n\n\tobj = container_of(uobj, struct ib_uwq_object, uevent.uobject);\n\tresp.events_reported = obj->uevent.events_reported;\n\n\tuobj_put_destroy(uobj);\n\n\treturn uverbs_response(attrs, &resp, sizeof(resp));\n}\n\nstatic int ib_uverbs_ex_modify_wq(struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uverbs_ex_modify_wq cmd;\n\tstruct ib_wq *wq;\n\tstruct ib_wq_attr wq_attr = {};\n\tint ret;\n\n\tret = uverbs_request(attrs, &cmd, sizeof(cmd));\n\tif (ret)\n\t\treturn ret;\n\n\tif (!cmd.attr_mask)\n\t\treturn -EINVAL;\n\n\tif (cmd.attr_mask > (IB_WQ_STATE | IB_WQ_CUR_STATE | IB_WQ_FLAGS))\n\t\treturn -EINVAL;\n\n\twq = uobj_get_obj_read(wq, UVERBS_OBJECT_WQ, cmd.wq_handle, attrs);\n\tif (!wq)\n\t\treturn -EINVAL;\n\n\tif (cmd.attr_mask & IB_WQ_FLAGS) {\n\t\twq_attr.flags = cmd.flags;\n\t\twq_attr.flags_mask = cmd.flags_mask;\n\t}\n\n\tif (cmd.attr_mask & IB_WQ_CUR_STATE) {\n\t\tif (cmd.curr_wq_state > IB_WQS_ERR)\n\t\t\treturn -EINVAL;\n\n\t\twq_attr.curr_wq_state = cmd.curr_wq_state;\n\t} else {\n\t\twq_attr.curr_wq_state = wq->state;\n\t}\n\n\tif (cmd.attr_mask & IB_WQ_STATE) {\n\t\tif (cmd.wq_state > IB_WQS_ERR)\n\t\t\treturn -EINVAL;\n\n\t\twq_attr.wq_state = cmd.wq_state;\n\t} else {\n\t\twq_attr.wq_state = wq_attr.curr_wq_state;\n\t}\n\n\tret = wq->device->ops.modify_wq(wq, &wq_attr, cmd.attr_mask,\n\t\t\t\t\t&attrs->driver_udata);\n\trdma_lookup_put_uobject(&wq->uobject->uevent.uobject,\n\t\t\t\tUVERBS_LOOKUP_READ);\n\treturn ret;\n}\n\nstatic int ib_uverbs_ex_create_rwq_ind_table(struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uverbs_ex_create_rwq_ind_table cmd;\n\tstruct ib_uverbs_ex_create_rwq_ind_table_resp  resp = {};\n\tstruct ib_uobject *uobj;\n\tint err;\n\tstruct ib_rwq_ind_table_init_attr init_attr = {};\n\tstruct ib_rwq_ind_table *rwq_ind_tbl;\n\tstruct ib_wq **wqs = NULL;\n\tu32 *wqs_handles = NULL;\n\tstruct ib_wq\t*wq = NULL;\n\tint i, num_read_wqs;\n\tu32 num_wq_handles;\n\tstruct uverbs_req_iter iter;\n\tstruct ib_device *ib_dev;\n\n\terr = uverbs_request_start(attrs, &iter, &cmd, sizeof(cmd));\n\tif (err)\n\t\treturn err;\n\n\tif (cmd.comp_mask)\n\t\treturn -EOPNOTSUPP;\n\n\tif (cmd.log_ind_tbl_size > IB_USER_VERBS_MAX_LOG_IND_TBL_SIZE)\n\t\treturn -EINVAL;\n\n\tnum_wq_handles = 1 << cmd.log_ind_tbl_size;\n\twqs_handles = kcalloc(num_wq_handles, sizeof(*wqs_handles),\n\t\t\t      GFP_KERNEL);\n\tif (!wqs_handles)\n\t\treturn -ENOMEM;\n\n\terr = uverbs_request_next(&iter, wqs_handles,\n\t\t\t\t  num_wq_handles * sizeof(__u32));\n\tif (err)\n\t\tgoto err_free;\n\n\terr = uverbs_request_finish(&iter);\n\tif (err)\n\t\tgoto err_free;\n\n\twqs = kcalloc(num_wq_handles, sizeof(*wqs), GFP_KERNEL);\n\tif (!wqs) {\n\t\terr = -ENOMEM;\n\t\tgoto  err_free;\n\t}\n\n\tfor (num_read_wqs = 0; num_read_wqs < num_wq_handles;\n\t\t\tnum_read_wqs++) {\n\t\twq = uobj_get_obj_read(wq, UVERBS_OBJECT_WQ,\n\t\t\t\t       wqs_handles[num_read_wqs], attrs);\n\t\tif (!wq) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto put_wqs;\n\t\t}\n\n\t\twqs[num_read_wqs] = wq;\n\t\tatomic_inc(&wqs[num_read_wqs]->usecnt);\n\t}\n\n\tuobj = uobj_alloc(UVERBS_OBJECT_RWQ_IND_TBL, attrs, &ib_dev);\n\tif (IS_ERR(uobj)) {\n\t\terr = PTR_ERR(uobj);\n\t\tgoto put_wqs;\n\t}\n\n\trwq_ind_tbl = rdma_zalloc_drv_obj(ib_dev, ib_rwq_ind_table);\n\tif (!rwq_ind_tbl) {\n\t\terr = -ENOMEM;\n\t\tgoto err_uobj;\n\t}\n\n\tinit_attr.log_ind_tbl_size = cmd.log_ind_tbl_size;\n\tinit_attr.ind_tbl = wqs;\n\n\trwq_ind_tbl->ind_tbl = wqs;\n\trwq_ind_tbl->log_ind_tbl_size = init_attr.log_ind_tbl_size;\n\trwq_ind_tbl->uobject = uobj;\n\tuobj->object = rwq_ind_tbl;\n\trwq_ind_tbl->device = ib_dev;\n\tatomic_set(&rwq_ind_tbl->usecnt, 0);\n\n\terr = ib_dev->ops.create_rwq_ind_table(rwq_ind_tbl, &init_attr,\n\t\t\t\t\t       &attrs->driver_udata);\n\tif (err)\n\t\tgoto err_create;\n\n\tfor (i = 0; i < num_wq_handles; i++)\n\t\trdma_lookup_put_uobject(&wqs[i]->uobject->uevent.uobject,\n\t\t\t\t\tUVERBS_LOOKUP_READ);\n\tkfree(wqs_handles);\n\tuobj_finalize_uobj_create(uobj, attrs);\n\n\tresp.ind_tbl_handle = uobj->id;\n\tresp.ind_tbl_num = rwq_ind_tbl->ind_tbl_num;\n\tresp.response_length = uverbs_response_length(attrs, sizeof(resp));\n\treturn uverbs_response(attrs, &resp, sizeof(resp));\n\nerr_create:\n\tkfree(rwq_ind_tbl);\nerr_uobj:\n\tuobj_alloc_abort(uobj, attrs);\nput_wqs:\n\tfor (i = 0; i < num_read_wqs; i++) {\n\t\trdma_lookup_put_uobject(&wqs[i]->uobject->uevent.uobject,\n\t\t\t\t\tUVERBS_LOOKUP_READ);\n\t\tatomic_dec(&wqs[i]->usecnt);\n\t}\nerr_free:\n\tkfree(wqs_handles);\n\tkfree(wqs);\n\treturn err;\n}\n\nstatic int ib_uverbs_ex_destroy_rwq_ind_table(struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uverbs_ex_destroy_rwq_ind_table cmd;\n\tint ret;\n\n\tret = uverbs_request(attrs, &cmd, sizeof(cmd));\n\tif (ret)\n\t\treturn ret;\n\n\tif (cmd.comp_mask)\n\t\treturn -EOPNOTSUPP;\n\n\treturn uobj_perform_destroy(UVERBS_OBJECT_RWQ_IND_TBL,\n\t\t\t\t    cmd.ind_tbl_handle, attrs);\n}\n\nstatic int ib_uverbs_ex_create_flow(struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uverbs_create_flow\t  cmd;\n\tstruct ib_uverbs_create_flow_resp resp = {};\n\tstruct ib_uobject\t\t  *uobj;\n\tstruct ib_flow\t\t\t  *flow_id;\n\tstruct ib_uverbs_flow_attr\t  *kern_flow_attr;\n\tstruct ib_flow_attr\t\t  *flow_attr;\n\tstruct ib_qp\t\t\t  *qp;\n\tstruct ib_uflow_resources\t  *uflow_res;\n\tstruct ib_uverbs_flow_spec_hdr\t  *kern_spec;\n\tstruct uverbs_req_iter iter;\n\tint err;\n\tvoid *ib_spec;\n\tint i;\n\tstruct ib_device *ib_dev;\n\n\terr = uverbs_request_start(attrs, &iter, &cmd, sizeof(cmd));\n\tif (err)\n\t\treturn err;\n\n\tif (cmd.comp_mask)\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_NET_RAW))\n\t\treturn -EPERM;\n\n\tif (cmd.flow_attr.flags >= IB_FLOW_ATTR_FLAGS_RESERVED)\n\t\treturn -EINVAL;\n\n\tif ((cmd.flow_attr.flags & IB_FLOW_ATTR_FLAGS_DONT_TRAP) &&\n\t    ((cmd.flow_attr.type == IB_FLOW_ATTR_ALL_DEFAULT) ||\n\t     (cmd.flow_attr.type == IB_FLOW_ATTR_MC_DEFAULT)))\n\t\treturn -EINVAL;\n\n\tif (cmd.flow_attr.num_of_specs > IB_FLOW_SPEC_SUPPORT_LAYERS)\n\t\treturn -EINVAL;\n\n\tif (cmd.flow_attr.size >\n\t    (cmd.flow_attr.num_of_specs * sizeof(struct ib_uverbs_flow_spec)))\n\t\treturn -EINVAL;\n\n\tif (cmd.flow_attr.reserved[0] ||\n\t    cmd.flow_attr.reserved[1])\n\t\treturn -EINVAL;\n\n\tif (cmd.flow_attr.num_of_specs) {\n\t\tkern_flow_attr = kmalloc(sizeof(*kern_flow_attr) + cmd.flow_attr.size,\n\t\t\t\t\t GFP_KERNEL);\n\t\tif (!kern_flow_attr)\n\t\t\treturn -ENOMEM;\n\n\t\t*kern_flow_attr = cmd.flow_attr;\n\t\terr = uverbs_request_next(&iter, &kern_flow_attr->flow_specs,\n\t\t\t\t\t  cmd.flow_attr.size);\n\t\tif (err)\n\t\t\tgoto err_free_attr;\n\t} else {\n\t\tkern_flow_attr = &cmd.flow_attr;\n\t}\n\n\terr = uverbs_request_finish(&iter);\n\tif (err)\n\t\tgoto err_free_attr;\n\n\tuobj = uobj_alloc(UVERBS_OBJECT_FLOW, attrs, &ib_dev);\n\tif (IS_ERR(uobj)) {\n\t\terr = PTR_ERR(uobj);\n\t\tgoto err_free_attr;\n\t}\n\n\tif (!rdma_is_port_valid(uobj->context->device, cmd.flow_attr.port)) {\n\t\terr = -EINVAL;\n\t\tgoto err_uobj;\n\t}\n\n\tqp = uobj_get_obj_read(qp, UVERBS_OBJECT_QP, cmd.qp_handle, attrs);\n\tif (!qp) {\n\t\terr = -EINVAL;\n\t\tgoto err_uobj;\n\t}\n\n\tif (qp->qp_type != IB_QPT_UD && qp->qp_type != IB_QPT_RAW_PACKET) {\n\t\terr = -EINVAL;\n\t\tgoto err_put;\n\t}\n\n\tflow_attr = kzalloc(struct_size(flow_attr, flows,\n\t\t\t\tcmd.flow_attr.num_of_specs), GFP_KERNEL);\n\tif (!flow_attr) {\n\t\terr = -ENOMEM;\n\t\tgoto err_put;\n\t}\n\tuflow_res = flow_resources_alloc(cmd.flow_attr.num_of_specs);\n\tif (!uflow_res) {\n\t\terr = -ENOMEM;\n\t\tgoto err_free_flow_attr;\n\t}\n\n\tflow_attr->type = kern_flow_attr->type;\n\tflow_attr->priority = kern_flow_attr->priority;\n\tflow_attr->num_of_specs = kern_flow_attr->num_of_specs;\n\tflow_attr->port = kern_flow_attr->port;\n\tflow_attr->flags = kern_flow_attr->flags;\n\tflow_attr->size = sizeof(*flow_attr);\n\n\tkern_spec = kern_flow_attr->flow_specs;\n\tib_spec = flow_attr + 1;\n\tfor (i = 0; i < flow_attr->num_of_specs &&\n\t\t\tcmd.flow_attr.size >= sizeof(*kern_spec) &&\n\t\t\tcmd.flow_attr.size >= kern_spec->size;\n\t     i++) {\n\t\terr = kern_spec_to_ib_spec(\n\t\t\t\tattrs, (struct ib_uverbs_flow_spec *)kern_spec,\n\t\t\t\tib_spec, uflow_res);\n\t\tif (err)\n\t\t\tgoto err_free;\n\n\t\tflow_attr->size +=\n\t\t\t((union ib_flow_spec *) ib_spec)->size;\n\t\tcmd.flow_attr.size -= kern_spec->size;\n\t\tkern_spec = ((void *)kern_spec) + kern_spec->size;\n\t\tib_spec += ((union ib_flow_spec *) ib_spec)->size;\n\t}\n\tif (cmd.flow_attr.size || (i != flow_attr->num_of_specs)) {\n\t\tpr_warn(\"create flow failed, flow %d: %u bytes left from uverb cmd\\n\",\n\t\t\ti, cmd.flow_attr.size);\n\t\terr = -EINVAL;\n\t\tgoto err_free;\n\t}\n\n\tflow_id = qp->device->ops.create_flow(qp, flow_attr,\n\t\t\t\t\t      &attrs->driver_udata);\n\n\tif (IS_ERR(flow_id)) {\n\t\terr = PTR_ERR(flow_id);\n\t\tgoto err_free;\n\t}\n\n\tib_set_flow(uobj, flow_id, qp, qp->device, uflow_res);\n\n\trdma_lookup_put_uobject(&qp->uobject->uevent.uobject,\n\t\t\t\tUVERBS_LOOKUP_READ);\n\tkfree(flow_attr);\n\n\tif (cmd.flow_attr.num_of_specs)\n\t\tkfree(kern_flow_attr);\n\tuobj_finalize_uobj_create(uobj, attrs);\n\n\tresp.flow_handle = uobj->id;\n\treturn uverbs_response(attrs, &resp, sizeof(resp));\n\nerr_free:\n\tib_uverbs_flow_resources_free(uflow_res);\nerr_free_flow_attr:\n\tkfree(flow_attr);\nerr_put:\n\trdma_lookup_put_uobject(&qp->uobject->uevent.uobject,\n\t\t\t\tUVERBS_LOOKUP_READ);\nerr_uobj:\n\tuobj_alloc_abort(uobj, attrs);\nerr_free_attr:\n\tif (cmd.flow_attr.num_of_specs)\n\t\tkfree(kern_flow_attr);\n\treturn err;\n}\n\nstatic int ib_uverbs_ex_destroy_flow(struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uverbs_destroy_flow\tcmd;\n\tint\t\t\t\tret;\n\n\tret = uverbs_request(attrs, &cmd, sizeof(cmd));\n\tif (ret)\n\t\treturn ret;\n\n\tif (cmd.comp_mask)\n\t\treturn -EINVAL;\n\n\treturn uobj_perform_destroy(UVERBS_OBJECT_FLOW, cmd.flow_handle, attrs);\n}\n\nstatic int __uverbs_create_xsrq(struct uverbs_attr_bundle *attrs,\n\t\t\t\tstruct ib_uverbs_create_xsrq *cmd,\n\t\t\t\tstruct ib_udata *udata)\n{\n\tstruct ib_uverbs_create_srq_resp resp = {};\n\tstruct ib_usrq_object           *obj;\n\tstruct ib_pd                    *pd;\n\tstruct ib_srq                   *srq;\n\tstruct ib_srq_init_attr          attr;\n\tint ret;\n\tstruct ib_uobject *xrcd_uobj;\n\tstruct ib_device *ib_dev;\n\n\tobj = (struct ib_usrq_object *)uobj_alloc(UVERBS_OBJECT_SRQ, attrs,\n\t\t\t\t\t\t  &ib_dev);\n\tif (IS_ERR(obj))\n\t\treturn PTR_ERR(obj);\n\n\tif (cmd->srq_type == IB_SRQT_TM)\n\t\tattr.ext.tag_matching.max_num_tags = cmd->max_num_tags;\n\n\tif (cmd->srq_type == IB_SRQT_XRC) {\n\t\txrcd_uobj = uobj_get_read(UVERBS_OBJECT_XRCD, cmd->xrcd_handle,\n\t\t\t\t\t  attrs);\n\t\tif (IS_ERR(xrcd_uobj)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tattr.ext.xrc.xrcd = (struct ib_xrcd *)xrcd_uobj->object;\n\t\tif (!attr.ext.xrc.xrcd) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_put_xrcd;\n\t\t}\n\n\t\tobj->uxrcd = container_of(xrcd_uobj, struct ib_uxrcd_object, uobject);\n\t\tatomic_inc(&obj->uxrcd->refcnt);\n\t}\n\n\tif (ib_srq_has_cq(cmd->srq_type)) {\n\t\tattr.ext.cq = uobj_get_obj_read(cq, UVERBS_OBJECT_CQ,\n\t\t\t\t\t\tcmd->cq_handle, attrs);\n\t\tif (!attr.ext.cq) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_put_xrcd;\n\t\t}\n\t}\n\n\tpd = uobj_get_obj_read(pd, UVERBS_OBJECT_PD, cmd->pd_handle, attrs);\n\tif (!pd) {\n\t\tret = -EINVAL;\n\t\tgoto err_put_cq;\n\t}\n\n\tattr.event_handler  = ib_uverbs_srq_event_handler;\n\tattr.srq_type       = cmd->srq_type;\n\tattr.attr.max_wr    = cmd->max_wr;\n\tattr.attr.max_sge   = cmd->max_sge;\n\tattr.attr.srq_limit = cmd->srq_limit;\n\n\tINIT_LIST_HEAD(&obj->uevent.event_list);\n\tobj->uevent.uobject.user_handle = cmd->user_handle;\n\n\tsrq = ib_create_srq_user(pd, &attr, obj, udata);\n\tif (IS_ERR(srq)) {\n\t\tret = PTR_ERR(srq);\n\t\tgoto err_put_pd;\n\t}\n\n\tobj->uevent.uobject.object = srq;\n\tobj->uevent.uobject.user_handle = cmd->user_handle;\n\tobj->uevent.event_file = READ_ONCE(attrs->ufile->default_async_file);\n\tif (obj->uevent.event_file)\n\t\tuverbs_uobject_get(&obj->uevent.event_file->uobj);\n\n\tif (cmd->srq_type == IB_SRQT_XRC)\n\t\tresp.srqn = srq->ext.xrc.srq_num;\n\n\tif (cmd->srq_type == IB_SRQT_XRC)\n\t\tuobj_put_read(xrcd_uobj);\n\n\tif (ib_srq_has_cq(cmd->srq_type))\n\t\trdma_lookup_put_uobject(&attr.ext.cq->uobject->uevent.uobject,\n\t\t\t\t\tUVERBS_LOOKUP_READ);\n\n\tuobj_put_obj_read(pd);\n\tuobj_finalize_uobj_create(&obj->uevent.uobject, attrs);\n\n\tresp.srq_handle = obj->uevent.uobject.id;\n\tresp.max_wr = attr.attr.max_wr;\n\tresp.max_sge = attr.attr.max_sge;\n\treturn uverbs_response(attrs, &resp, sizeof(resp));\n\nerr_put_pd:\n\tuobj_put_obj_read(pd);\nerr_put_cq:\n\tif (ib_srq_has_cq(cmd->srq_type))\n\t\trdma_lookup_put_uobject(&attr.ext.cq->uobject->uevent.uobject,\n\t\t\t\t\tUVERBS_LOOKUP_READ);\n\nerr_put_xrcd:\n\tif (cmd->srq_type == IB_SRQT_XRC) {\n\t\tatomic_dec(&obj->uxrcd->refcnt);\n\t\tuobj_put_read(xrcd_uobj);\n\t}\n\nerr:\n\tuobj_alloc_abort(&obj->uevent.uobject, attrs);\n\treturn ret;\n}\n\nstatic int ib_uverbs_create_srq(struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uverbs_create_srq      cmd;\n\tstruct ib_uverbs_create_xsrq     xcmd;\n\tint ret;\n\n\tret = uverbs_request(attrs, &cmd, sizeof(cmd));\n\tif (ret)\n\t\treturn ret;\n\n\tmemset(&xcmd, 0, sizeof(xcmd));\n\txcmd.response\t = cmd.response;\n\txcmd.user_handle = cmd.user_handle;\n\txcmd.srq_type\t = IB_SRQT_BASIC;\n\txcmd.pd_handle\t = cmd.pd_handle;\n\txcmd.max_wr\t = cmd.max_wr;\n\txcmd.max_sge\t = cmd.max_sge;\n\txcmd.srq_limit\t = cmd.srq_limit;\n\n\treturn __uverbs_create_xsrq(attrs, &xcmd, &attrs->driver_udata);\n}\n\nstatic int ib_uverbs_create_xsrq(struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uverbs_create_xsrq     cmd;\n\tint ret;\n\n\tret = uverbs_request(attrs, &cmd, sizeof(cmd));\n\tif (ret)\n\t\treturn ret;\n\n\treturn __uverbs_create_xsrq(attrs, &cmd, &attrs->driver_udata);\n}\n\nstatic int ib_uverbs_modify_srq(struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uverbs_modify_srq cmd;\n\tstruct ib_srq              *srq;\n\tstruct ib_srq_attr          attr;\n\tint                         ret;\n\n\tret = uverbs_request(attrs, &cmd, sizeof(cmd));\n\tif (ret)\n\t\treturn ret;\n\n\tsrq = uobj_get_obj_read(srq, UVERBS_OBJECT_SRQ, cmd.srq_handle, attrs);\n\tif (!srq)\n\t\treturn -EINVAL;\n\n\tattr.max_wr    = cmd.max_wr;\n\tattr.srq_limit = cmd.srq_limit;\n\n\tret = srq->device->ops.modify_srq(srq, &attr, cmd.attr_mask,\n\t\t\t\t\t  &attrs->driver_udata);\n\n\trdma_lookup_put_uobject(&srq->uobject->uevent.uobject,\n\t\t\t\tUVERBS_LOOKUP_READ);\n\n\treturn ret;\n}\n\nstatic int ib_uverbs_query_srq(struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uverbs_query_srq      cmd;\n\tstruct ib_uverbs_query_srq_resp resp;\n\tstruct ib_srq_attr              attr;\n\tstruct ib_srq                   *srq;\n\tint                             ret;\n\n\tret = uverbs_request(attrs, &cmd, sizeof(cmd));\n\tif (ret)\n\t\treturn ret;\n\n\tsrq = uobj_get_obj_read(srq, UVERBS_OBJECT_SRQ, cmd.srq_handle, attrs);\n\tif (!srq)\n\t\treturn -EINVAL;\n\n\tret = ib_query_srq(srq, &attr);\n\n\trdma_lookup_put_uobject(&srq->uobject->uevent.uobject,\n\t\t\t\tUVERBS_LOOKUP_READ);\n\n\tif (ret)\n\t\treturn ret;\n\n\tmemset(&resp, 0, sizeof resp);\n\n\tresp.max_wr    = attr.max_wr;\n\tresp.max_sge   = attr.max_sge;\n\tresp.srq_limit = attr.srq_limit;\n\n\treturn uverbs_response(attrs, &resp, sizeof(resp));\n}\n\nstatic int ib_uverbs_destroy_srq(struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uverbs_destroy_srq      cmd;\n\tstruct ib_uverbs_destroy_srq_resp resp;\n\tstruct ib_uobject\t\t *uobj;\n\tstruct ib_uevent_object        \t *obj;\n\tint ret;\n\n\tret = uverbs_request(attrs, &cmd, sizeof(cmd));\n\tif (ret)\n\t\treturn ret;\n\n\tuobj = uobj_get_destroy(UVERBS_OBJECT_SRQ, cmd.srq_handle, attrs);\n\tif (IS_ERR(uobj))\n\t\treturn PTR_ERR(uobj);\n\n\tobj = container_of(uobj, struct ib_uevent_object, uobject);\n\tmemset(&resp, 0, sizeof(resp));\n\tresp.events_reported = obj->events_reported;\n\n\tuobj_put_destroy(uobj);\n\n\treturn uverbs_response(attrs, &resp, sizeof(resp));\n}\n\nstatic int ib_uverbs_ex_query_device(struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uverbs_ex_query_device_resp resp = {};\n\tstruct ib_uverbs_ex_query_device  cmd;\n\tstruct ib_device_attr attr = {0};\n\tstruct ib_ucontext *ucontext;\n\tstruct ib_device *ib_dev;\n\tint err;\n\n\tucontext = ib_uverbs_get_ucontext(attrs);\n\tif (IS_ERR(ucontext))\n\t\treturn PTR_ERR(ucontext);\n\tib_dev = ucontext->device;\n\n\terr = uverbs_request(attrs, &cmd, sizeof(cmd));\n\tif (err)\n\t\treturn err;\n\n\tif (cmd.comp_mask)\n\t\treturn -EINVAL;\n\n\tif (cmd.reserved)\n\t\treturn -EINVAL;\n\n\terr = ib_dev->ops.query_device(ib_dev, &attr, &attrs->driver_udata);\n\tif (err)\n\t\treturn err;\n\n\tcopy_query_dev_fields(ucontext, &resp.base, &attr);\n\n\tresp.odp_caps.general_caps = attr.odp_caps.general_caps;\n\tresp.odp_caps.per_transport_caps.rc_odp_caps =\n\t\tattr.odp_caps.per_transport_caps.rc_odp_caps;\n\tresp.odp_caps.per_transport_caps.uc_odp_caps =\n\t\tattr.odp_caps.per_transport_caps.uc_odp_caps;\n\tresp.odp_caps.per_transport_caps.ud_odp_caps =\n\t\tattr.odp_caps.per_transport_caps.ud_odp_caps;\n\tresp.xrc_odp_caps = attr.odp_caps.per_transport_caps.xrc_odp_caps;\n\n\tresp.timestamp_mask = attr.timestamp_mask;\n\tresp.hca_core_clock = attr.hca_core_clock;\n\tresp.device_cap_flags_ex = attr.device_cap_flags;\n\tresp.rss_caps.supported_qpts = attr.rss_caps.supported_qpts;\n\tresp.rss_caps.max_rwq_indirection_tables =\n\t\tattr.rss_caps.max_rwq_indirection_tables;\n\tresp.rss_caps.max_rwq_indirection_table_size =\n\t\tattr.rss_caps.max_rwq_indirection_table_size;\n\tresp.max_wq_type_rq = attr.max_wq_type_rq;\n\tresp.raw_packet_caps = attr.raw_packet_caps;\n\tresp.tm_caps.max_rndv_hdr_size\t= attr.tm_caps.max_rndv_hdr_size;\n\tresp.tm_caps.max_num_tags\t= attr.tm_caps.max_num_tags;\n\tresp.tm_caps.max_ops\t\t= attr.tm_caps.max_ops;\n\tresp.tm_caps.max_sge\t\t= attr.tm_caps.max_sge;\n\tresp.tm_caps.flags\t\t= attr.tm_caps.flags;\n\tresp.cq_moderation_caps.max_cq_moderation_count  =\n\t\tattr.cq_caps.max_cq_moderation_count;\n\tresp.cq_moderation_caps.max_cq_moderation_period =\n\t\tattr.cq_caps.max_cq_moderation_period;\n\tresp.max_dm_size = attr.max_dm_size;\n\tresp.response_length = uverbs_response_length(attrs, sizeof(resp));\n\n\treturn uverbs_response(attrs, &resp, sizeof(resp));\n}\n\nstatic int ib_uverbs_ex_modify_cq(struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uverbs_ex_modify_cq cmd;\n\tstruct ib_cq *cq;\n\tint ret;\n\n\tret = uverbs_request(attrs, &cmd, sizeof(cmd));\n\tif (ret)\n\t\treturn ret;\n\n\tif (!cmd.attr_mask || cmd.reserved)\n\t\treturn -EINVAL;\n\n\tif (cmd.attr_mask > IB_CQ_MODERATE)\n\t\treturn -EOPNOTSUPP;\n\n\tcq = uobj_get_obj_read(cq, UVERBS_OBJECT_CQ, cmd.cq_handle, attrs);\n\tif (!cq)\n\t\treturn -EINVAL;\n\n\tret = rdma_set_cq_moderation(cq, cmd.attr.cq_count, cmd.attr.cq_period);\n\n\trdma_lookup_put_uobject(&cq->uobject->uevent.uobject,\n\t\t\t\tUVERBS_LOOKUP_READ);\n\treturn ret;\n}\n\n \n#define UAPI_DEF_WRITE_IO(req, resp)                                           \\\n\t.write.has_resp = 1 +                                                  \\\n\t\t\t  BUILD_BUG_ON_ZERO(offsetof(req, response) != 0) +    \\\n\t\t\t  BUILD_BUG_ON_ZERO(sizeof_field(req, response) !=    \\\n\t\t\t\t\t    sizeof(u64)),                      \\\n\t.write.req_size = sizeof(req), .write.resp_size = sizeof(resp)\n\n#define UAPI_DEF_WRITE_I(req) .write.req_size = sizeof(req)\n\n#define UAPI_DEF_WRITE_UDATA_IO(req, resp)                                     \\\n\tUAPI_DEF_WRITE_IO(req, resp),                                          \\\n\t\t.write.has_udata =                                             \\\n\t\t\t1 +                                                    \\\n\t\t\tBUILD_BUG_ON_ZERO(offsetof(req, driver_data) !=        \\\n\t\t\t\t\t  sizeof(req)) +                       \\\n\t\t\tBUILD_BUG_ON_ZERO(offsetof(resp, driver_data) !=       \\\n\t\t\t\t\t  sizeof(resp))\n\n#define UAPI_DEF_WRITE_UDATA_I(req)                                            \\\n\tUAPI_DEF_WRITE_I(req),                                                 \\\n\t\t.write.has_udata =                                             \\\n\t\t\t1 + BUILD_BUG_ON_ZERO(offsetof(req, driver_data) !=    \\\n\t\t\t\t\t      sizeof(req))\n\n \n#define UAPI_DEF_WRITE_IO_EX(req, req_last_member, resp, resp_last_member)     \\\n\t.write.has_resp = 1,                                                   \\\n\t.write.req_size = offsetofend(req, req_last_member),                   \\\n\t.write.resp_size = offsetofend(resp, resp_last_member)\n\n#define UAPI_DEF_WRITE_I_EX(req, req_last_member)                              \\\n\t.write.req_size = offsetofend(req, req_last_member)\n\nconst struct uapi_definition uverbs_def_write_intf[] = {\n\tDECLARE_UVERBS_OBJECT(\n\t\tUVERBS_OBJECT_AH,\n\t\tDECLARE_UVERBS_WRITE(IB_USER_VERBS_CMD_CREATE_AH,\n\t\t\t\t     ib_uverbs_create_ah,\n\t\t\t\t     UAPI_DEF_WRITE_UDATA_IO(\n\t\t\t\t\t     struct ib_uverbs_create_ah,\n\t\t\t\t\t     struct ib_uverbs_create_ah_resp)),\n\t\tDECLARE_UVERBS_WRITE(\n\t\t\tIB_USER_VERBS_CMD_DESTROY_AH,\n\t\t\tib_uverbs_destroy_ah,\n\t\t\tUAPI_DEF_WRITE_I(struct ib_uverbs_destroy_ah)),\n\t\tUAPI_DEF_OBJ_NEEDS_FN(create_user_ah),\n\t\tUAPI_DEF_OBJ_NEEDS_FN(destroy_ah)),\n\n\tDECLARE_UVERBS_OBJECT(\n\t\tUVERBS_OBJECT_COMP_CHANNEL,\n\t\tDECLARE_UVERBS_WRITE(\n\t\t\tIB_USER_VERBS_CMD_CREATE_COMP_CHANNEL,\n\t\t\tib_uverbs_create_comp_channel,\n\t\t\tUAPI_DEF_WRITE_IO(\n\t\t\t\tstruct ib_uverbs_create_comp_channel,\n\t\t\t\tstruct ib_uverbs_create_comp_channel_resp))),\n\n\tDECLARE_UVERBS_OBJECT(\n\t\tUVERBS_OBJECT_CQ,\n\t\tDECLARE_UVERBS_WRITE(IB_USER_VERBS_CMD_CREATE_CQ,\n\t\t\t\t     ib_uverbs_create_cq,\n\t\t\t\t     UAPI_DEF_WRITE_UDATA_IO(\n\t\t\t\t\t     struct ib_uverbs_create_cq,\n\t\t\t\t\t     struct ib_uverbs_create_cq_resp),\n\t\t\t\t     UAPI_DEF_METHOD_NEEDS_FN(create_cq)),\n\t\tDECLARE_UVERBS_WRITE(\n\t\t\tIB_USER_VERBS_CMD_DESTROY_CQ,\n\t\t\tib_uverbs_destroy_cq,\n\t\t\tUAPI_DEF_WRITE_IO(struct ib_uverbs_destroy_cq,\n\t\t\t\t\t  struct ib_uverbs_destroy_cq_resp),\n\t\t\tUAPI_DEF_METHOD_NEEDS_FN(destroy_cq)),\n\t\tDECLARE_UVERBS_WRITE(\n\t\t\tIB_USER_VERBS_CMD_POLL_CQ,\n\t\t\tib_uverbs_poll_cq,\n\t\t\tUAPI_DEF_WRITE_IO(struct ib_uverbs_poll_cq,\n\t\t\t\t\t  struct ib_uverbs_poll_cq_resp),\n\t\t\tUAPI_DEF_METHOD_NEEDS_FN(poll_cq)),\n\t\tDECLARE_UVERBS_WRITE(\n\t\t\tIB_USER_VERBS_CMD_REQ_NOTIFY_CQ,\n\t\t\tib_uverbs_req_notify_cq,\n\t\t\tUAPI_DEF_WRITE_I(struct ib_uverbs_req_notify_cq),\n\t\t\tUAPI_DEF_METHOD_NEEDS_FN(req_notify_cq)),\n\t\tDECLARE_UVERBS_WRITE(IB_USER_VERBS_CMD_RESIZE_CQ,\n\t\t\t\t     ib_uverbs_resize_cq,\n\t\t\t\t     UAPI_DEF_WRITE_UDATA_IO(\n\t\t\t\t\t     struct ib_uverbs_resize_cq,\n\t\t\t\t\t     struct ib_uverbs_resize_cq_resp),\n\t\t\t\t     UAPI_DEF_METHOD_NEEDS_FN(resize_cq)),\n\t\tDECLARE_UVERBS_WRITE_EX(\n\t\t\tIB_USER_VERBS_EX_CMD_CREATE_CQ,\n\t\t\tib_uverbs_ex_create_cq,\n\t\t\tUAPI_DEF_WRITE_IO_EX(struct ib_uverbs_ex_create_cq,\n\t\t\t\t\t     reserved,\n\t\t\t\t\t     struct ib_uverbs_ex_create_cq_resp,\n\t\t\t\t\t     response_length),\n\t\t\tUAPI_DEF_METHOD_NEEDS_FN(create_cq)),\n\t\tDECLARE_UVERBS_WRITE_EX(\n\t\t\tIB_USER_VERBS_EX_CMD_MODIFY_CQ,\n\t\t\tib_uverbs_ex_modify_cq,\n\t\t\tUAPI_DEF_WRITE_I(struct ib_uverbs_ex_modify_cq),\n\t\t\tUAPI_DEF_METHOD_NEEDS_FN(modify_cq))),\n\n\tDECLARE_UVERBS_OBJECT(\n\t\tUVERBS_OBJECT_DEVICE,\n\t\tDECLARE_UVERBS_WRITE(IB_USER_VERBS_CMD_GET_CONTEXT,\n\t\t\t\t     ib_uverbs_get_context,\n\t\t\t\t     UAPI_DEF_WRITE_UDATA_IO(\n\t\t\t\t\t     struct ib_uverbs_get_context,\n\t\t\t\t\t     struct ib_uverbs_get_context_resp)),\n\t\tDECLARE_UVERBS_WRITE(\n\t\t\tIB_USER_VERBS_CMD_QUERY_DEVICE,\n\t\t\tib_uverbs_query_device,\n\t\t\tUAPI_DEF_WRITE_IO(struct ib_uverbs_query_device,\n\t\t\t\t\t  struct ib_uverbs_query_device_resp)),\n\t\tDECLARE_UVERBS_WRITE(\n\t\t\tIB_USER_VERBS_CMD_QUERY_PORT,\n\t\t\tib_uverbs_query_port,\n\t\t\tUAPI_DEF_WRITE_IO(struct ib_uverbs_query_port,\n\t\t\t\t\t  struct ib_uverbs_query_port_resp),\n\t\t\tUAPI_DEF_METHOD_NEEDS_FN(query_port)),\n\t\tDECLARE_UVERBS_WRITE_EX(\n\t\t\tIB_USER_VERBS_EX_CMD_QUERY_DEVICE,\n\t\t\tib_uverbs_ex_query_device,\n\t\t\tUAPI_DEF_WRITE_IO_EX(\n\t\t\t\tstruct ib_uverbs_ex_query_device,\n\t\t\t\treserved,\n\t\t\t\tstruct ib_uverbs_ex_query_device_resp,\n\t\t\t\tresponse_length),\n\t\t\tUAPI_DEF_METHOD_NEEDS_FN(query_device)),\n\t\tUAPI_DEF_OBJ_NEEDS_FN(alloc_ucontext),\n\t\tUAPI_DEF_OBJ_NEEDS_FN(dealloc_ucontext)),\n\n\tDECLARE_UVERBS_OBJECT(\n\t\tUVERBS_OBJECT_FLOW,\n\t\tDECLARE_UVERBS_WRITE_EX(\n\t\t\tIB_USER_VERBS_EX_CMD_CREATE_FLOW,\n\t\t\tib_uverbs_ex_create_flow,\n\t\t\tUAPI_DEF_WRITE_IO_EX(struct ib_uverbs_create_flow,\n\t\t\t\t\t     flow_attr,\n\t\t\t\t\t     struct ib_uverbs_create_flow_resp,\n\t\t\t\t\t     flow_handle),\n\t\t\tUAPI_DEF_METHOD_NEEDS_FN(create_flow)),\n\t\tDECLARE_UVERBS_WRITE_EX(\n\t\t\tIB_USER_VERBS_EX_CMD_DESTROY_FLOW,\n\t\t\tib_uverbs_ex_destroy_flow,\n\t\t\tUAPI_DEF_WRITE_I(struct ib_uverbs_destroy_flow),\n\t\t\tUAPI_DEF_METHOD_NEEDS_FN(destroy_flow))),\n\n\tDECLARE_UVERBS_OBJECT(\n\t\tUVERBS_OBJECT_MR,\n\t\tDECLARE_UVERBS_WRITE(IB_USER_VERBS_CMD_DEREG_MR,\n\t\t\t\t     ib_uverbs_dereg_mr,\n\t\t\t\t     UAPI_DEF_WRITE_I(struct ib_uverbs_dereg_mr),\n\t\t\t\t     UAPI_DEF_METHOD_NEEDS_FN(dereg_mr)),\n\t\tDECLARE_UVERBS_WRITE(\n\t\t\tIB_USER_VERBS_CMD_REG_MR,\n\t\t\tib_uverbs_reg_mr,\n\t\t\tUAPI_DEF_WRITE_UDATA_IO(struct ib_uverbs_reg_mr,\n\t\t\t\t\t\tstruct ib_uverbs_reg_mr_resp),\n\t\t\tUAPI_DEF_METHOD_NEEDS_FN(reg_user_mr)),\n\t\tDECLARE_UVERBS_WRITE(\n\t\t\tIB_USER_VERBS_CMD_REREG_MR,\n\t\t\tib_uverbs_rereg_mr,\n\t\t\tUAPI_DEF_WRITE_UDATA_IO(struct ib_uverbs_rereg_mr,\n\t\t\t\t\t\tstruct ib_uverbs_rereg_mr_resp),\n\t\t\tUAPI_DEF_METHOD_NEEDS_FN(rereg_user_mr))),\n\n\tDECLARE_UVERBS_OBJECT(\n\t\tUVERBS_OBJECT_MW,\n\t\tDECLARE_UVERBS_WRITE(\n\t\t\tIB_USER_VERBS_CMD_ALLOC_MW,\n\t\t\tib_uverbs_alloc_mw,\n\t\t\tUAPI_DEF_WRITE_UDATA_IO(struct ib_uverbs_alloc_mw,\n\t\t\t\t\t\tstruct ib_uverbs_alloc_mw_resp),\n\t\t\tUAPI_DEF_METHOD_NEEDS_FN(alloc_mw)),\n\t\tDECLARE_UVERBS_WRITE(\n\t\t\tIB_USER_VERBS_CMD_DEALLOC_MW,\n\t\t\tib_uverbs_dealloc_mw,\n\t\t\tUAPI_DEF_WRITE_I(struct ib_uverbs_dealloc_mw),\n\t\t\tUAPI_DEF_METHOD_NEEDS_FN(dealloc_mw))),\n\n\tDECLARE_UVERBS_OBJECT(\n\t\tUVERBS_OBJECT_PD,\n\t\tDECLARE_UVERBS_WRITE(\n\t\t\tIB_USER_VERBS_CMD_ALLOC_PD,\n\t\t\tib_uverbs_alloc_pd,\n\t\t\tUAPI_DEF_WRITE_UDATA_IO(struct ib_uverbs_alloc_pd,\n\t\t\t\t\t\tstruct ib_uverbs_alloc_pd_resp),\n\t\t\tUAPI_DEF_METHOD_NEEDS_FN(alloc_pd)),\n\t\tDECLARE_UVERBS_WRITE(\n\t\t\tIB_USER_VERBS_CMD_DEALLOC_PD,\n\t\t\tib_uverbs_dealloc_pd,\n\t\t\tUAPI_DEF_WRITE_I(struct ib_uverbs_dealloc_pd),\n\t\t\tUAPI_DEF_METHOD_NEEDS_FN(dealloc_pd))),\n\n\tDECLARE_UVERBS_OBJECT(\n\t\tUVERBS_OBJECT_QP,\n\t\tDECLARE_UVERBS_WRITE(\n\t\t\tIB_USER_VERBS_CMD_ATTACH_MCAST,\n\t\t\tib_uverbs_attach_mcast,\n\t\t\tUAPI_DEF_WRITE_I(struct ib_uverbs_attach_mcast),\n\t\t\tUAPI_DEF_METHOD_NEEDS_FN(attach_mcast),\n\t\t\tUAPI_DEF_METHOD_NEEDS_FN(detach_mcast)),\n\t\tDECLARE_UVERBS_WRITE(IB_USER_VERBS_CMD_CREATE_QP,\n\t\t\t\t     ib_uverbs_create_qp,\n\t\t\t\t     UAPI_DEF_WRITE_UDATA_IO(\n\t\t\t\t\t     struct ib_uverbs_create_qp,\n\t\t\t\t\t     struct ib_uverbs_create_qp_resp),\n\t\t\t\t     UAPI_DEF_METHOD_NEEDS_FN(create_qp)),\n\t\tDECLARE_UVERBS_WRITE(\n\t\t\tIB_USER_VERBS_CMD_DESTROY_QP,\n\t\t\tib_uverbs_destroy_qp,\n\t\t\tUAPI_DEF_WRITE_IO(struct ib_uverbs_destroy_qp,\n\t\t\t\t\t  struct ib_uverbs_destroy_qp_resp),\n\t\t\tUAPI_DEF_METHOD_NEEDS_FN(destroy_qp)),\n\t\tDECLARE_UVERBS_WRITE(\n\t\t\tIB_USER_VERBS_CMD_DETACH_MCAST,\n\t\t\tib_uverbs_detach_mcast,\n\t\t\tUAPI_DEF_WRITE_I(struct ib_uverbs_detach_mcast),\n\t\t\tUAPI_DEF_METHOD_NEEDS_FN(detach_mcast)),\n\t\tDECLARE_UVERBS_WRITE(\n\t\t\tIB_USER_VERBS_CMD_MODIFY_QP,\n\t\t\tib_uverbs_modify_qp,\n\t\t\tUAPI_DEF_WRITE_I(struct ib_uverbs_modify_qp),\n\t\t\tUAPI_DEF_METHOD_NEEDS_FN(modify_qp)),\n\t\tDECLARE_UVERBS_WRITE(\n\t\t\tIB_USER_VERBS_CMD_POST_RECV,\n\t\t\tib_uverbs_post_recv,\n\t\t\tUAPI_DEF_WRITE_IO(struct ib_uverbs_post_recv,\n\t\t\t\t\t  struct ib_uverbs_post_recv_resp),\n\t\t\tUAPI_DEF_METHOD_NEEDS_FN(post_recv)),\n\t\tDECLARE_UVERBS_WRITE(\n\t\t\tIB_USER_VERBS_CMD_POST_SEND,\n\t\t\tib_uverbs_post_send,\n\t\t\tUAPI_DEF_WRITE_IO(struct ib_uverbs_post_send,\n\t\t\t\t\t  struct ib_uverbs_post_send_resp),\n\t\t\tUAPI_DEF_METHOD_NEEDS_FN(post_send)),\n\t\tDECLARE_UVERBS_WRITE(\n\t\t\tIB_USER_VERBS_CMD_QUERY_QP,\n\t\t\tib_uverbs_query_qp,\n\t\t\tUAPI_DEF_WRITE_IO(struct ib_uverbs_query_qp,\n\t\t\t\t\t  struct ib_uverbs_query_qp_resp),\n\t\t\tUAPI_DEF_METHOD_NEEDS_FN(query_qp)),\n\t\tDECLARE_UVERBS_WRITE_EX(\n\t\t\tIB_USER_VERBS_EX_CMD_CREATE_QP,\n\t\t\tib_uverbs_ex_create_qp,\n\t\t\tUAPI_DEF_WRITE_IO_EX(struct ib_uverbs_ex_create_qp,\n\t\t\t\t\t     comp_mask,\n\t\t\t\t\t     struct ib_uverbs_ex_create_qp_resp,\n\t\t\t\t\t     response_length),\n\t\t\tUAPI_DEF_METHOD_NEEDS_FN(create_qp)),\n\t\tDECLARE_UVERBS_WRITE_EX(\n\t\t\tIB_USER_VERBS_EX_CMD_MODIFY_QP,\n\t\t\tib_uverbs_ex_modify_qp,\n\t\t\tUAPI_DEF_WRITE_IO_EX(struct ib_uverbs_ex_modify_qp,\n\t\t\t\t\t     base,\n\t\t\t\t\t     struct ib_uverbs_ex_modify_qp_resp,\n\t\t\t\t\t     response_length),\n\t\t\tUAPI_DEF_METHOD_NEEDS_FN(modify_qp))),\n\n\tDECLARE_UVERBS_OBJECT(\n\t\tUVERBS_OBJECT_RWQ_IND_TBL,\n\t\tDECLARE_UVERBS_WRITE_EX(\n\t\t\tIB_USER_VERBS_EX_CMD_CREATE_RWQ_IND_TBL,\n\t\t\tib_uverbs_ex_create_rwq_ind_table,\n\t\t\tUAPI_DEF_WRITE_IO_EX(\n\t\t\t\tstruct ib_uverbs_ex_create_rwq_ind_table,\n\t\t\t\tlog_ind_tbl_size,\n\t\t\t\tstruct ib_uverbs_ex_create_rwq_ind_table_resp,\n\t\t\t\tind_tbl_num),\n\t\t\tUAPI_DEF_METHOD_NEEDS_FN(create_rwq_ind_table)),\n\t\tDECLARE_UVERBS_WRITE_EX(\n\t\t\tIB_USER_VERBS_EX_CMD_DESTROY_RWQ_IND_TBL,\n\t\t\tib_uverbs_ex_destroy_rwq_ind_table,\n\t\t\tUAPI_DEF_WRITE_I(\n\t\t\t\tstruct ib_uverbs_ex_destroy_rwq_ind_table),\n\t\t\tUAPI_DEF_METHOD_NEEDS_FN(destroy_rwq_ind_table))),\n\n\tDECLARE_UVERBS_OBJECT(\n\t\tUVERBS_OBJECT_WQ,\n\t\tDECLARE_UVERBS_WRITE_EX(\n\t\t\tIB_USER_VERBS_EX_CMD_CREATE_WQ,\n\t\t\tib_uverbs_ex_create_wq,\n\t\t\tUAPI_DEF_WRITE_IO_EX(struct ib_uverbs_ex_create_wq,\n\t\t\t\t\t     max_sge,\n\t\t\t\t\t     struct ib_uverbs_ex_create_wq_resp,\n\t\t\t\t\t     wqn),\n\t\t\tUAPI_DEF_METHOD_NEEDS_FN(create_wq)),\n\t\tDECLARE_UVERBS_WRITE_EX(\n\t\t\tIB_USER_VERBS_EX_CMD_DESTROY_WQ,\n\t\t\tib_uverbs_ex_destroy_wq,\n\t\t\tUAPI_DEF_WRITE_IO_EX(struct ib_uverbs_ex_destroy_wq,\n\t\t\t\t\t     wq_handle,\n\t\t\t\t\t     struct ib_uverbs_ex_destroy_wq_resp,\n\t\t\t\t\t     reserved),\n\t\t\tUAPI_DEF_METHOD_NEEDS_FN(destroy_wq)),\n\t\tDECLARE_UVERBS_WRITE_EX(\n\t\t\tIB_USER_VERBS_EX_CMD_MODIFY_WQ,\n\t\t\tib_uverbs_ex_modify_wq,\n\t\t\tUAPI_DEF_WRITE_I_EX(struct ib_uverbs_ex_modify_wq,\n\t\t\t\t\t    curr_wq_state),\n\t\t\tUAPI_DEF_METHOD_NEEDS_FN(modify_wq))),\n\n\tDECLARE_UVERBS_OBJECT(\n\t\tUVERBS_OBJECT_SRQ,\n\t\tDECLARE_UVERBS_WRITE(IB_USER_VERBS_CMD_CREATE_SRQ,\n\t\t\t\t     ib_uverbs_create_srq,\n\t\t\t\t     UAPI_DEF_WRITE_UDATA_IO(\n\t\t\t\t\t     struct ib_uverbs_create_srq,\n\t\t\t\t\t     struct ib_uverbs_create_srq_resp),\n\t\t\t\t     UAPI_DEF_METHOD_NEEDS_FN(create_srq)),\n\t\tDECLARE_UVERBS_WRITE(IB_USER_VERBS_CMD_CREATE_XSRQ,\n\t\t\t\t     ib_uverbs_create_xsrq,\n\t\t\t\t     UAPI_DEF_WRITE_UDATA_IO(\n\t\t\t\t\t     struct ib_uverbs_create_xsrq,\n\t\t\t\t\t     struct ib_uverbs_create_srq_resp),\n\t\t\t\t     UAPI_DEF_METHOD_NEEDS_FN(create_srq)),\n\t\tDECLARE_UVERBS_WRITE(\n\t\t\tIB_USER_VERBS_CMD_DESTROY_SRQ,\n\t\t\tib_uverbs_destroy_srq,\n\t\t\tUAPI_DEF_WRITE_IO(struct ib_uverbs_destroy_srq,\n\t\t\t\t\t  struct ib_uverbs_destroy_srq_resp),\n\t\t\tUAPI_DEF_METHOD_NEEDS_FN(destroy_srq)),\n\t\tDECLARE_UVERBS_WRITE(\n\t\t\tIB_USER_VERBS_CMD_MODIFY_SRQ,\n\t\t\tib_uverbs_modify_srq,\n\t\t\tUAPI_DEF_WRITE_UDATA_I(struct ib_uverbs_modify_srq),\n\t\t\tUAPI_DEF_METHOD_NEEDS_FN(modify_srq)),\n\t\tDECLARE_UVERBS_WRITE(\n\t\t\tIB_USER_VERBS_CMD_POST_SRQ_RECV,\n\t\t\tib_uverbs_post_srq_recv,\n\t\t\tUAPI_DEF_WRITE_IO(struct ib_uverbs_post_srq_recv,\n\t\t\t\t\t  struct ib_uverbs_post_srq_recv_resp),\n\t\t\tUAPI_DEF_METHOD_NEEDS_FN(post_srq_recv)),\n\t\tDECLARE_UVERBS_WRITE(\n\t\t\tIB_USER_VERBS_CMD_QUERY_SRQ,\n\t\t\tib_uverbs_query_srq,\n\t\t\tUAPI_DEF_WRITE_IO(struct ib_uverbs_query_srq,\n\t\t\t\t\t  struct ib_uverbs_query_srq_resp),\n\t\t\tUAPI_DEF_METHOD_NEEDS_FN(query_srq))),\n\n\tDECLARE_UVERBS_OBJECT(\n\t\tUVERBS_OBJECT_XRCD,\n\t\tDECLARE_UVERBS_WRITE(\n\t\t\tIB_USER_VERBS_CMD_CLOSE_XRCD,\n\t\t\tib_uverbs_close_xrcd,\n\t\t\tUAPI_DEF_WRITE_I(struct ib_uverbs_close_xrcd)),\n\t\tDECLARE_UVERBS_WRITE(IB_USER_VERBS_CMD_OPEN_QP,\n\t\t\t\t     ib_uverbs_open_qp,\n\t\t\t\t     UAPI_DEF_WRITE_UDATA_IO(\n\t\t\t\t\t     struct ib_uverbs_open_qp,\n\t\t\t\t\t     struct ib_uverbs_create_qp_resp)),\n\t\tDECLARE_UVERBS_WRITE(IB_USER_VERBS_CMD_OPEN_XRCD,\n\t\t\t\t     ib_uverbs_open_xrcd,\n\t\t\t\t     UAPI_DEF_WRITE_UDATA_IO(\n\t\t\t\t\t     struct ib_uverbs_open_xrcd,\n\t\t\t\t\t     struct ib_uverbs_open_xrcd_resp)),\n\t\tUAPI_DEF_OBJ_NEEDS_FN(alloc_xrcd),\n\t\tUAPI_DEF_OBJ_NEEDS_FN(dealloc_xrcd)),\n\n\t{},\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}