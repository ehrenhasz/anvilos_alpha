{
  "module_name": "smi.c",
  "hash_id": "afd2975228c3470340ce7032daa7a685bd99e0b8f1b3338561efb2d7c2f6ecba",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/core/smi.c",
  "human_readable_source": " \n\n#include <rdma/ib_smi.h>\n#include \"smi.h\"\n#include \"opa_smi.h\"\n\nstatic enum smi_action __smi_handle_dr_smp_send(bool is_switch, u32 port_num,\n\t\t\t\t\t\tu8 *hop_ptr, u8 hop_cnt,\n\t\t\t\t\t\tconst u8 *initial_path,\n\t\t\t\t\t\tconst u8 *return_path,\n\t\t\t\t\t\tu8 direction,\n\t\t\t\t\t\tbool dr_dlid_is_permissive,\n\t\t\t\t\t\tbool dr_slid_is_permissive)\n{\n\t \n\t \n\tif (hop_cnt >= IB_SMP_MAX_PATH_HOPS)\n\t\treturn IB_SMI_DISCARD;\n\n\tif (!direction) {\n\t\t \n\t\tif (hop_cnt && *hop_ptr == 0) {\n\t\t\t(*hop_ptr)++;\n\t\t\treturn (initial_path[*hop_ptr] ==\n\t\t\t\tport_num ? IB_SMI_HANDLE : IB_SMI_DISCARD);\n\t\t}\n\n\t\t \n\t\tif (*hop_ptr && *hop_ptr < hop_cnt) {\n\t\t\tif (!is_switch)\n\t\t\t\treturn IB_SMI_DISCARD;\n\n\t\t\t \n\t\t\t(*hop_ptr)++;\n\t\t\treturn (initial_path[*hop_ptr] ==\n\t\t\t\tport_num ? IB_SMI_HANDLE : IB_SMI_DISCARD);\n\t\t}\n\n\t\t \n\t\tif (*hop_ptr == hop_cnt) {\n\t\t\t \n\t\t\t(*hop_ptr)++;\n\t\t\treturn (is_switch ||\n\t\t\t\tdr_dlid_is_permissive ?\n\t\t\t\tIB_SMI_HANDLE : IB_SMI_DISCARD);\n\t\t}\n\n\t\t \n\t\t \n\t\treturn (*hop_ptr == hop_cnt + 1 ? IB_SMI_HANDLE : IB_SMI_DISCARD);\n\n\t} else {\n\t\t \n\t\tif (hop_cnt && *hop_ptr == hop_cnt + 1) {\n\t\t\t(*hop_ptr)--;\n\t\t\treturn (return_path[*hop_ptr] ==\n\t\t\t\tport_num ? IB_SMI_HANDLE : IB_SMI_DISCARD);\n\t\t}\n\n\t\t \n\t\tif (2 <= *hop_ptr && *hop_ptr <= hop_cnt) {\n\t\t\tif (!is_switch)\n\t\t\t\treturn IB_SMI_DISCARD;\n\n\t\t\t(*hop_ptr)--;\n\t\t\treturn (return_path[*hop_ptr] ==\n\t\t\t\tport_num ? IB_SMI_HANDLE : IB_SMI_DISCARD);\n\t\t}\n\n\t\t \n\t\tif (*hop_ptr == 1) {\n\t\t\t(*hop_ptr)--;\n\t\t\t \n\t\t\treturn (is_switch ||\n\t\t\t\tdr_slid_is_permissive ?\n\t\t\t\tIB_SMI_HANDLE : IB_SMI_DISCARD);\n\t\t}\n\n\t\t \n\t\tif (*hop_ptr == 0)\n\t\t\treturn IB_SMI_HANDLE;\n\n\t\t \n\t\treturn IB_SMI_DISCARD;\n\t}\n}\n\n \nenum smi_action smi_handle_dr_smp_send(struct ib_smp *smp,\n\t\t\t\t       bool is_switch, u32 port_num)\n{\n\treturn __smi_handle_dr_smp_send(is_switch, port_num,\n\t\t\t\t\t&smp->hop_ptr, smp->hop_cnt,\n\t\t\t\t\tsmp->initial_path,\n\t\t\t\t\tsmp->return_path,\n\t\t\t\t\tib_get_smp_direction(smp),\n\t\t\t\t\tsmp->dr_dlid == IB_LID_PERMISSIVE,\n\t\t\t\t\tsmp->dr_slid == IB_LID_PERMISSIVE);\n}\n\nenum smi_action opa_smi_handle_dr_smp_send(struct opa_smp *smp,\n\t\t\t\t       bool is_switch, u32 port_num)\n{\n\treturn __smi_handle_dr_smp_send(is_switch, port_num,\n\t\t\t\t\t&smp->hop_ptr, smp->hop_cnt,\n\t\t\t\t\tsmp->route.dr.initial_path,\n\t\t\t\t\tsmp->route.dr.return_path,\n\t\t\t\t\topa_get_smp_direction(smp),\n\t\t\t\t\tsmp->route.dr.dr_dlid ==\n\t\t\t\t\tOPA_LID_PERMISSIVE,\n\t\t\t\t\tsmp->route.dr.dr_slid ==\n\t\t\t\t\tOPA_LID_PERMISSIVE);\n}\n\nstatic enum smi_action __smi_handle_dr_smp_recv(bool is_switch, u32 port_num,\n\t\t\t\t\t\tint phys_port_cnt,\n\t\t\t\t\t\tu8 *hop_ptr, u8 hop_cnt,\n\t\t\t\t\t\tconst u8 *initial_path,\n\t\t\t\t\t\tu8 *return_path,\n\t\t\t\t\t\tu8 direction,\n\t\t\t\t\t\tbool dr_dlid_is_permissive,\n\t\t\t\t\t\tbool dr_slid_is_permissive)\n{\n\t \n\t \n\tif (hop_cnt >= IB_SMP_MAX_PATH_HOPS)\n\t\treturn IB_SMI_DISCARD;\n\n\tif (!direction) {\n\t\t \n\t\tif (hop_cnt && *hop_ptr == 0)\n\t\t\treturn IB_SMI_DISCARD;\n\n\t\t \n\t\tif (*hop_ptr && *hop_ptr < hop_cnt) {\n\t\t\tif (!is_switch)\n\t\t\t\treturn IB_SMI_DISCARD;\n\n\t\t\treturn_path[*hop_ptr] = port_num;\n\t\t\t \n\t\t\treturn (initial_path[*hop_ptr+1] <= phys_port_cnt ?\n\t\t\t\tIB_SMI_HANDLE : IB_SMI_DISCARD);\n\t\t}\n\n\t\t \n\t\tif (*hop_ptr == hop_cnt) {\n\t\t\tif (hop_cnt)\n\t\t\t\treturn_path[*hop_ptr] = port_num;\n\t\t\t \n\n\t\t\treturn (is_switch ||\n\t\t\t\tdr_dlid_is_permissive ?\n\t\t\t\tIB_SMI_HANDLE : IB_SMI_DISCARD);\n\t\t}\n\n\t\t \n\t\t \n\t\treturn (*hop_ptr == hop_cnt + 1 ? IB_SMI_HANDLE : IB_SMI_DISCARD);\n\n\t} else {\n\n\t\t \n\t\tif (hop_cnt && *hop_ptr == hop_cnt + 1) {\n\t\t\t(*hop_ptr)--;\n\t\t\treturn (return_path[*hop_ptr] ==\n\t\t\t\tport_num ? IB_SMI_HANDLE : IB_SMI_DISCARD);\n\t\t}\n\n\t\t \n\t\tif (2 <= *hop_ptr && *hop_ptr <= hop_cnt) {\n\t\t\tif (!is_switch)\n\t\t\t\treturn IB_SMI_DISCARD;\n\n\t\t\t \n\t\t\treturn (return_path[*hop_ptr-1] <= phys_port_cnt ?\n\t\t\t\tIB_SMI_HANDLE : IB_SMI_DISCARD);\n\t\t}\n\n\t\t \n\t\tif (*hop_ptr == 1) {\n\t\t\tif (dr_slid_is_permissive) {\n\t\t\t\t \n\t\t\t\t(*hop_ptr)--;\n\t\t\t\treturn IB_SMI_HANDLE;\n\t\t\t}\n\t\t\t \n\t\t\treturn (is_switch ? IB_SMI_HANDLE : IB_SMI_DISCARD);\n\t\t}\n\n\t\t \n\t\t \n\t\treturn (*hop_ptr == 0 ? IB_SMI_HANDLE : IB_SMI_DISCARD);\n\t}\n}\n\n \nenum smi_action smi_handle_dr_smp_recv(struct ib_smp *smp, bool is_switch,\n\t\t\t\t       u32 port_num, int phys_port_cnt)\n{\n\treturn __smi_handle_dr_smp_recv(is_switch, port_num, phys_port_cnt,\n\t\t\t\t\t&smp->hop_ptr, smp->hop_cnt,\n\t\t\t\t\tsmp->initial_path,\n\t\t\t\t\tsmp->return_path,\n\t\t\t\t\tib_get_smp_direction(smp),\n\t\t\t\t\tsmp->dr_dlid == IB_LID_PERMISSIVE,\n\t\t\t\t\tsmp->dr_slid == IB_LID_PERMISSIVE);\n}\n\n \nenum smi_action opa_smi_handle_dr_smp_recv(struct opa_smp *smp, bool is_switch,\n\t\t\t\t\t   u32 port_num, int phys_port_cnt)\n{\n\treturn __smi_handle_dr_smp_recv(is_switch, port_num, phys_port_cnt,\n\t\t\t\t\t&smp->hop_ptr, smp->hop_cnt,\n\t\t\t\t\tsmp->route.dr.initial_path,\n\t\t\t\t\tsmp->route.dr.return_path,\n\t\t\t\t\topa_get_smp_direction(smp),\n\t\t\t\t\tsmp->route.dr.dr_dlid ==\n\t\t\t\t\tOPA_LID_PERMISSIVE,\n\t\t\t\t\tsmp->route.dr.dr_slid ==\n\t\t\t\t\tOPA_LID_PERMISSIVE);\n}\n\nstatic enum smi_forward_action __smi_check_forward_dr_smp(u8 hop_ptr, u8 hop_cnt,\n\t\t\t\t\t\t\t  u8 direction,\n\t\t\t\t\t\t\t  bool dr_dlid_is_permissive,\n\t\t\t\t\t\t\t  bool dr_slid_is_permissive)\n{\n\tif (!direction) {\n\t\t \n\t\tif (hop_ptr && hop_ptr < hop_cnt)\n\t\t\treturn IB_SMI_FORWARD;\n\n\t\t \n\t\tif (hop_ptr == hop_cnt)\n\t\t\treturn (dr_dlid_is_permissive ?\n\t\t\t\tIB_SMI_SEND : IB_SMI_LOCAL);\n\n\t\t \n\t\tif (hop_ptr == hop_cnt + 1)\n\t\t\treturn IB_SMI_SEND;\n\t} else {\n\t\t \n\t\tif (2 <= hop_ptr && hop_ptr <= hop_cnt)\n\t\t\treturn IB_SMI_FORWARD;\n\n\t\t \n\t\tif (hop_ptr == 1)\n\t\t\treturn (!dr_slid_is_permissive ?\n\t\t\t\tIB_SMI_SEND : IB_SMI_LOCAL);\n\t}\n\treturn IB_SMI_LOCAL;\n\n}\n\nenum smi_forward_action smi_check_forward_dr_smp(struct ib_smp *smp)\n{\n\treturn __smi_check_forward_dr_smp(smp->hop_ptr, smp->hop_cnt,\n\t\t\t\t\t  ib_get_smp_direction(smp),\n\t\t\t\t\t  smp->dr_dlid == IB_LID_PERMISSIVE,\n\t\t\t\t\t  smp->dr_slid == IB_LID_PERMISSIVE);\n}\n\nenum smi_forward_action opa_smi_check_forward_dr_smp(struct opa_smp *smp)\n{\n\treturn __smi_check_forward_dr_smp(smp->hop_ptr, smp->hop_cnt,\n\t\t\t\t\t  opa_get_smp_direction(smp),\n\t\t\t\t\t  smp->route.dr.dr_dlid ==\n\t\t\t\t\t  OPA_LID_PERMISSIVE,\n\t\t\t\t\t  smp->route.dr.dr_slid ==\n\t\t\t\t\t  OPA_LID_PERMISSIVE);\n}\n\n \nint smi_get_fwd_port(struct ib_smp *smp)\n{\n\treturn (!ib_get_smp_direction(smp) ? smp->initial_path[smp->hop_ptr+1] :\n\t\tsmp->return_path[smp->hop_ptr-1]);\n}\n\n \nint opa_smi_get_fwd_port(struct opa_smp *smp)\n{\n\treturn !opa_get_smp_direction(smp) ? smp->route.dr.initial_path[smp->hop_ptr+1] :\n\t\tsmp->route.dr.return_path[smp->hop_ptr-1];\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}