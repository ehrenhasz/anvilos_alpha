{
  "module_name": "agent.c",
  "hash_id": "d5ee033fb6b0fed726c25644fe353ed3e9f688307b53843bb0ac6caa8c06c099",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/core/agent.c",
  "human_readable_source": " \n\n#include <linux/slab.h>\n#include <linux/string.h>\n\n#include \"agent.h\"\n#include \"smi.h\"\n#include \"mad_priv.h\"\n\n#define SPFX \"ib_agent: \"\n\nstruct ib_agent_port_private {\n\tstruct list_head port_list;\n\tstruct ib_mad_agent *agent[2];\n};\n\nstatic DEFINE_SPINLOCK(ib_agent_port_list_lock);\nstatic LIST_HEAD(ib_agent_port_list);\n\nstatic struct ib_agent_port_private *\n__ib_get_agent_port(const struct ib_device *device, int port_num)\n{\n\tstruct ib_agent_port_private *entry;\n\n\tlist_for_each_entry(entry, &ib_agent_port_list, port_list) {\n\t\tif (entry->agent[1]->device == device &&\n\t\t    entry->agent[1]->port_num == port_num)\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}\n\nstatic struct ib_agent_port_private *\nib_get_agent_port(const struct ib_device *device, int port_num)\n{\n\tstruct ib_agent_port_private *entry;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ib_agent_port_list_lock, flags);\n\tentry = __ib_get_agent_port(device, port_num);\n\tspin_unlock_irqrestore(&ib_agent_port_list_lock, flags);\n\treturn entry;\n}\n\nvoid agent_send_response(const struct ib_mad_hdr *mad_hdr, const struct ib_grh *grh,\n\t\t\t const struct ib_wc *wc, const struct ib_device *device,\n\t\t\t int port_num, int qpn, size_t resp_mad_len, bool opa)\n{\n\tstruct ib_agent_port_private *port_priv;\n\tstruct ib_mad_agent *agent;\n\tstruct ib_mad_send_buf *send_buf;\n\tstruct ib_ah *ah;\n\tstruct ib_mad_send_wr_private *mad_send_wr;\n\n\tif (rdma_cap_ib_switch(device))\n\t\tport_priv = ib_get_agent_port(device, 0);\n\telse\n\t\tport_priv = ib_get_agent_port(device, port_num);\n\n\tif (!port_priv) {\n\t\tdev_err(&device->dev, \"Unable to find port agent\\n\");\n\t\treturn;\n\t}\n\n\tagent = port_priv->agent[qpn];\n\tah = ib_create_ah_from_wc(agent->qp->pd, wc, grh, port_num);\n\tif (IS_ERR(ah)) {\n\t\tdev_err(&device->dev, \"ib_create_ah_from_wc error %ld\\n\",\n\t\t\tPTR_ERR(ah));\n\t\treturn;\n\t}\n\n\tif (opa && mad_hdr->base_version != OPA_MGMT_BASE_VERSION)\n\t\tresp_mad_len = IB_MGMT_MAD_SIZE;\n\n\tsend_buf = ib_create_send_mad(agent, wc->src_qp, wc->pkey_index, 0,\n\t\t\t\t      IB_MGMT_MAD_HDR,\n\t\t\t\t      resp_mad_len - IB_MGMT_MAD_HDR,\n\t\t\t\t      GFP_KERNEL,\n\t\t\t\t      mad_hdr->base_version);\n\tif (IS_ERR(send_buf)) {\n\t\tdev_err(&device->dev, \"ib_create_send_mad error\\n\");\n\t\tgoto err1;\n\t}\n\n\tmemcpy(send_buf->mad, mad_hdr, resp_mad_len);\n\tsend_buf->ah = ah;\n\n\tif (rdma_cap_ib_switch(device)) {\n\t\tmad_send_wr = container_of(send_buf,\n\t\t\t\t\t   struct ib_mad_send_wr_private,\n\t\t\t\t\t   send_buf);\n\t\tmad_send_wr->send_wr.port_num = port_num;\n\t}\n\n\tif (ib_post_send_mad(send_buf, NULL)) {\n\t\tdev_err(&device->dev, \"ib_post_send_mad error\\n\");\n\t\tgoto err2;\n\t}\n\treturn;\nerr2:\n\tib_free_send_mad(send_buf);\nerr1:\n\trdma_destroy_ah(ah, RDMA_DESTROY_AH_SLEEPABLE);\n}\n\nstatic void agent_send_handler(struct ib_mad_agent *mad_agent,\n\t\t\t       struct ib_mad_send_wc *mad_send_wc)\n{\n\trdma_destroy_ah(mad_send_wc->send_buf->ah, RDMA_DESTROY_AH_SLEEPABLE);\n\tib_free_send_mad(mad_send_wc->send_buf);\n}\n\nint ib_agent_port_open(struct ib_device *device, int port_num)\n{\n\tstruct ib_agent_port_private *port_priv;\n\tunsigned long flags;\n\tint ret;\n\n\t \n\tport_priv = kzalloc(sizeof *port_priv, GFP_KERNEL);\n\tif (!port_priv) {\n\t\tret = -ENOMEM;\n\t\tgoto error1;\n\t}\n\n\tif (rdma_cap_ib_smi(device, port_num)) {\n\t\t \n\t\tport_priv->agent[0] = ib_register_mad_agent(device, port_num,\n\t\t\t\t\t\t\t    IB_QPT_SMI, NULL, 0,\n\t\t\t\t\t\t\t    &agent_send_handler,\n\t\t\t\t\t\t\t    NULL, NULL, 0);\n\t\tif (IS_ERR(port_priv->agent[0])) {\n\t\t\tret = PTR_ERR(port_priv->agent[0]);\n\t\t\tgoto error2;\n\t\t}\n\t}\n\n\t \n\tport_priv->agent[1] = ib_register_mad_agent(device, port_num,\n\t\t\t\t\t\t    IB_QPT_GSI, NULL, 0,\n\t\t\t\t\t\t    &agent_send_handler,\n\t\t\t\t\t\t    NULL, NULL, 0);\n\tif (IS_ERR(port_priv->agent[1])) {\n\t\tret = PTR_ERR(port_priv->agent[1]);\n\t\tgoto error3;\n\t}\n\n\tspin_lock_irqsave(&ib_agent_port_list_lock, flags);\n\tlist_add_tail(&port_priv->port_list, &ib_agent_port_list);\n\tspin_unlock_irqrestore(&ib_agent_port_list_lock, flags);\n\n\treturn 0;\n\nerror3:\n\tif (port_priv->agent[0])\n\t\tib_unregister_mad_agent(port_priv->agent[0]);\nerror2:\n\tkfree(port_priv);\nerror1:\n\treturn ret;\n}\n\nint ib_agent_port_close(struct ib_device *device, int port_num)\n{\n\tstruct ib_agent_port_private *port_priv;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ib_agent_port_list_lock, flags);\n\tport_priv = __ib_get_agent_port(device, port_num);\n\tif (port_priv == NULL) {\n\t\tspin_unlock_irqrestore(&ib_agent_port_list_lock, flags);\n\t\tdev_err(&device->dev, \"Port %d not found\\n\", port_num);\n\t\treturn -ENODEV;\n\t}\n\tlist_del(&port_priv->port_list);\n\tspin_unlock_irqrestore(&ib_agent_port_list_lock, flags);\n\n\tib_unregister_mad_agent(port_priv->agent[1]);\n\tif (port_priv->agent[0])\n\t\tib_unregister_mad_agent(port_priv->agent[0]);\n\n\tkfree(port_priv);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}