{
  "module_name": "mad_rmpp.c",
  "hash_id": "bbebd54079d266a1fa65447f786ae65db7501e7ee2507ce4ef071002e3342ec4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/core/mad_rmpp.c",
  "human_readable_source": " \n\n#include <linux/slab.h>\n\n#include \"mad_priv.h\"\n#include \"mad_rmpp.h\"\n\nenum rmpp_state {\n\tRMPP_STATE_ACTIVE,\n\tRMPP_STATE_TIMEOUT,\n\tRMPP_STATE_COMPLETE\n};\n\nstruct mad_rmpp_recv {\n\tstruct ib_mad_agent_private *agent;\n\tstruct list_head list;\n\tstruct delayed_work timeout_work;\n\tstruct delayed_work cleanup_work;\n\tstruct completion comp;\n\tenum rmpp_state state;\n\tspinlock_t lock;\n\trefcount_t refcount;\n\n\tstruct ib_ah *ah;\n\tstruct ib_mad_recv_wc *rmpp_wc;\n\tstruct ib_mad_recv_buf *cur_seg_buf;\n\tint last_ack;\n\tint seg_num;\n\tint newwin;\n\tint repwin;\n\n\t__be64 tid;\n\tu32 src_qp;\n\tu32 slid;\n\tu8 mgmt_class;\n\tu8 class_version;\n\tu8 method;\n\tu8 base_version;\n};\n\nstatic inline void deref_rmpp_recv(struct mad_rmpp_recv *rmpp_recv)\n{\n\tif (refcount_dec_and_test(&rmpp_recv->refcount))\n\t\tcomplete(&rmpp_recv->comp);\n}\n\nstatic void destroy_rmpp_recv(struct mad_rmpp_recv *rmpp_recv)\n{\n\tderef_rmpp_recv(rmpp_recv);\n\twait_for_completion(&rmpp_recv->comp);\n\trdma_destroy_ah(rmpp_recv->ah, RDMA_DESTROY_AH_SLEEPABLE);\n\tkfree(rmpp_recv);\n}\n\nvoid ib_cancel_rmpp_recvs(struct ib_mad_agent_private *agent)\n{\n\tstruct mad_rmpp_recv *rmpp_recv, *temp_rmpp_recv;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&agent->lock, flags);\n\tlist_for_each_entry(rmpp_recv, &agent->rmpp_list, list) {\n\t\tcancel_delayed_work(&rmpp_recv->timeout_work);\n\t\tcancel_delayed_work(&rmpp_recv->cleanup_work);\n\t}\n\tspin_unlock_irqrestore(&agent->lock, flags);\n\n\tflush_workqueue(agent->qp_info->port_priv->wq);\n\n\tlist_for_each_entry_safe(rmpp_recv, temp_rmpp_recv,\n\t\t\t\t &agent->rmpp_list, list) {\n\t\tlist_del(&rmpp_recv->list);\n\t\tif (rmpp_recv->state != RMPP_STATE_COMPLETE)\n\t\t\tib_free_recv_mad(rmpp_recv->rmpp_wc);\n\t\tdestroy_rmpp_recv(rmpp_recv);\n\t}\n}\n\nstatic void format_ack(struct ib_mad_send_buf *msg,\n\t\t       struct ib_rmpp_mad *data,\n\t\t       struct mad_rmpp_recv *rmpp_recv)\n{\n\tstruct ib_rmpp_mad *ack = msg->mad;\n\tunsigned long flags;\n\n\tmemcpy(ack, &data->mad_hdr, msg->hdr_len);\n\n\tack->mad_hdr.method ^= IB_MGMT_METHOD_RESP;\n\tack->rmpp_hdr.rmpp_type = IB_MGMT_RMPP_TYPE_ACK;\n\tib_set_rmpp_flags(&ack->rmpp_hdr, IB_MGMT_RMPP_FLAG_ACTIVE);\n\n\tspin_lock_irqsave(&rmpp_recv->lock, flags);\n\trmpp_recv->last_ack = rmpp_recv->seg_num;\n\tack->rmpp_hdr.seg_num = cpu_to_be32(rmpp_recv->seg_num);\n\tack->rmpp_hdr.paylen_newwin = cpu_to_be32(rmpp_recv->newwin);\n\tspin_unlock_irqrestore(&rmpp_recv->lock, flags);\n}\n\nstatic void ack_recv(struct mad_rmpp_recv *rmpp_recv,\n\t\t     struct ib_mad_recv_wc *recv_wc)\n{\n\tstruct ib_mad_send_buf *msg;\n\tint ret, hdr_len;\n\n\thdr_len = ib_get_mad_data_offset(recv_wc->recv_buf.mad->mad_hdr.mgmt_class);\n\tmsg = ib_create_send_mad(&rmpp_recv->agent->agent, recv_wc->wc->src_qp,\n\t\t\t\t recv_wc->wc->pkey_index, 1, hdr_len,\n\t\t\t\t 0, GFP_KERNEL,\n\t\t\t\t IB_MGMT_BASE_VERSION);\n\tif (IS_ERR(msg))\n\t\treturn;\n\n\tformat_ack(msg, (struct ib_rmpp_mad *) recv_wc->recv_buf.mad, rmpp_recv);\n\tmsg->ah = rmpp_recv->ah;\n\tret = ib_post_send_mad(msg, NULL);\n\tif (ret)\n\t\tib_free_send_mad(msg);\n}\n\nstatic struct ib_mad_send_buf *alloc_response_msg(struct ib_mad_agent *agent,\n\t\t\t\t\t\t  struct ib_mad_recv_wc *recv_wc)\n{\n\tstruct ib_mad_send_buf *msg;\n\tstruct ib_ah *ah;\n\tint hdr_len;\n\n\tah = ib_create_ah_from_wc(agent->qp->pd, recv_wc->wc,\n\t\t\t\t  recv_wc->recv_buf.grh, agent->port_num);\n\tif (IS_ERR(ah))\n\t\treturn (void *) ah;\n\n\thdr_len = ib_get_mad_data_offset(recv_wc->recv_buf.mad->mad_hdr.mgmt_class);\n\tmsg = ib_create_send_mad(agent, recv_wc->wc->src_qp,\n\t\t\t\t recv_wc->wc->pkey_index, 1,\n\t\t\t\t hdr_len, 0, GFP_KERNEL,\n\t\t\t\t IB_MGMT_BASE_VERSION);\n\tif (IS_ERR(msg))\n\t\trdma_destroy_ah(ah, RDMA_DESTROY_AH_SLEEPABLE);\n\telse {\n\t\tmsg->ah = ah;\n\t\tmsg->context[0] = ah;\n\t}\n\n\treturn msg;\n}\n\nstatic void ack_ds_ack(struct ib_mad_agent_private *agent,\n\t\t       struct ib_mad_recv_wc *recv_wc)\n{\n\tstruct ib_mad_send_buf *msg;\n\tstruct ib_rmpp_mad *rmpp_mad;\n\tint ret;\n\n\tmsg = alloc_response_msg(&agent->agent, recv_wc);\n\tif (IS_ERR(msg))\n\t\treturn;\n\n\trmpp_mad = msg->mad;\n\tmemcpy(rmpp_mad, recv_wc->recv_buf.mad, msg->hdr_len);\n\n\trmpp_mad->mad_hdr.method ^= IB_MGMT_METHOD_RESP;\n\tib_set_rmpp_flags(&rmpp_mad->rmpp_hdr, IB_MGMT_RMPP_FLAG_ACTIVE);\n\trmpp_mad->rmpp_hdr.seg_num = 0;\n\trmpp_mad->rmpp_hdr.paylen_newwin = cpu_to_be32(1);\n\n\tret = ib_post_send_mad(msg, NULL);\n\tif (ret) {\n\t\trdma_destroy_ah(msg->ah, RDMA_DESTROY_AH_SLEEPABLE);\n\t\tib_free_send_mad(msg);\n\t}\n}\n\nvoid ib_rmpp_send_handler(struct ib_mad_send_wc *mad_send_wc)\n{\n\tif (mad_send_wc->send_buf->context[0] == mad_send_wc->send_buf->ah)\n\t\trdma_destroy_ah(mad_send_wc->send_buf->ah,\n\t\t\t\tRDMA_DESTROY_AH_SLEEPABLE);\n\tib_free_send_mad(mad_send_wc->send_buf);\n}\n\nstatic void nack_recv(struct ib_mad_agent_private *agent,\n\t\t      struct ib_mad_recv_wc *recv_wc, u8 rmpp_status)\n{\n\tstruct ib_mad_send_buf *msg;\n\tstruct ib_rmpp_mad *rmpp_mad;\n\tint ret;\n\n\tmsg = alloc_response_msg(&agent->agent, recv_wc);\n\tif (IS_ERR(msg))\n\t\treturn;\n\n\trmpp_mad = msg->mad;\n\tmemcpy(rmpp_mad, recv_wc->recv_buf.mad, msg->hdr_len);\n\n\trmpp_mad->mad_hdr.method ^= IB_MGMT_METHOD_RESP;\n\trmpp_mad->rmpp_hdr.rmpp_version = IB_MGMT_RMPP_VERSION;\n\trmpp_mad->rmpp_hdr.rmpp_type = IB_MGMT_RMPP_TYPE_ABORT;\n\tib_set_rmpp_flags(&rmpp_mad->rmpp_hdr, IB_MGMT_RMPP_FLAG_ACTIVE);\n\trmpp_mad->rmpp_hdr.rmpp_status = rmpp_status;\n\trmpp_mad->rmpp_hdr.seg_num = 0;\n\trmpp_mad->rmpp_hdr.paylen_newwin = 0;\n\n\tret = ib_post_send_mad(msg, NULL);\n\tif (ret) {\n\t\trdma_destroy_ah(msg->ah, RDMA_DESTROY_AH_SLEEPABLE);\n\t\tib_free_send_mad(msg);\n\t}\n}\n\nstatic void recv_timeout_handler(struct work_struct *work)\n{\n\tstruct mad_rmpp_recv *rmpp_recv =\n\t\tcontainer_of(work, struct mad_rmpp_recv, timeout_work.work);\n\tstruct ib_mad_recv_wc *rmpp_wc;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rmpp_recv->agent->lock, flags);\n\tif (rmpp_recv->state != RMPP_STATE_ACTIVE) {\n\t\tspin_unlock_irqrestore(&rmpp_recv->agent->lock, flags);\n\t\treturn;\n\t}\n\trmpp_recv->state = RMPP_STATE_TIMEOUT;\n\tlist_del(&rmpp_recv->list);\n\tspin_unlock_irqrestore(&rmpp_recv->agent->lock, flags);\n\n\trmpp_wc = rmpp_recv->rmpp_wc;\n\tnack_recv(rmpp_recv->agent, rmpp_wc, IB_MGMT_RMPP_STATUS_T2L);\n\tdestroy_rmpp_recv(rmpp_recv);\n\tib_free_recv_mad(rmpp_wc);\n}\n\nstatic void recv_cleanup_handler(struct work_struct *work)\n{\n\tstruct mad_rmpp_recv *rmpp_recv =\n\t\tcontainer_of(work, struct mad_rmpp_recv, cleanup_work.work);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rmpp_recv->agent->lock, flags);\n\tlist_del(&rmpp_recv->list);\n\tspin_unlock_irqrestore(&rmpp_recv->agent->lock, flags);\n\tdestroy_rmpp_recv(rmpp_recv);\n}\n\nstatic struct mad_rmpp_recv *\ncreate_rmpp_recv(struct ib_mad_agent_private *agent,\n\t\t struct ib_mad_recv_wc *mad_recv_wc)\n{\n\tstruct mad_rmpp_recv *rmpp_recv;\n\tstruct ib_mad_hdr *mad_hdr;\n\n\trmpp_recv = kmalloc(sizeof *rmpp_recv, GFP_KERNEL);\n\tif (!rmpp_recv)\n\t\treturn NULL;\n\n\trmpp_recv->ah = ib_create_ah_from_wc(agent->agent.qp->pd,\n\t\t\t\t\t     mad_recv_wc->wc,\n\t\t\t\t\t     mad_recv_wc->recv_buf.grh,\n\t\t\t\t\t     agent->agent.port_num);\n\tif (IS_ERR(rmpp_recv->ah))\n\t\tgoto error;\n\n\trmpp_recv->agent = agent;\n\tinit_completion(&rmpp_recv->comp);\n\tINIT_DELAYED_WORK(&rmpp_recv->timeout_work, recv_timeout_handler);\n\tINIT_DELAYED_WORK(&rmpp_recv->cleanup_work, recv_cleanup_handler);\n\tspin_lock_init(&rmpp_recv->lock);\n\trmpp_recv->state = RMPP_STATE_ACTIVE;\n\trefcount_set(&rmpp_recv->refcount, 1);\n\n\trmpp_recv->rmpp_wc = mad_recv_wc;\n\trmpp_recv->cur_seg_buf = &mad_recv_wc->recv_buf;\n\trmpp_recv->newwin = 1;\n\trmpp_recv->seg_num = 1;\n\trmpp_recv->last_ack = 0;\n\trmpp_recv->repwin = 1;\n\n\tmad_hdr = &mad_recv_wc->recv_buf.mad->mad_hdr;\n\trmpp_recv->tid = mad_hdr->tid;\n\trmpp_recv->src_qp = mad_recv_wc->wc->src_qp;\n\trmpp_recv->slid = mad_recv_wc->wc->slid;\n\trmpp_recv->mgmt_class = mad_hdr->mgmt_class;\n\trmpp_recv->class_version = mad_hdr->class_version;\n\trmpp_recv->method  = mad_hdr->method;\n\trmpp_recv->base_version  = mad_hdr->base_version;\n\treturn rmpp_recv;\n\nerror:\tkfree(rmpp_recv);\n\treturn NULL;\n}\n\nstatic struct mad_rmpp_recv *\nfind_rmpp_recv(struct ib_mad_agent_private *agent,\n\t       struct ib_mad_recv_wc *mad_recv_wc)\n{\n\tstruct mad_rmpp_recv *rmpp_recv;\n\tstruct ib_mad_hdr *mad_hdr = &mad_recv_wc->recv_buf.mad->mad_hdr;\n\n\tlist_for_each_entry(rmpp_recv, &agent->rmpp_list, list) {\n\t\tif (rmpp_recv->tid == mad_hdr->tid &&\n\t\t    rmpp_recv->src_qp == mad_recv_wc->wc->src_qp &&\n\t\t    rmpp_recv->slid == mad_recv_wc->wc->slid &&\n\t\t    rmpp_recv->mgmt_class == mad_hdr->mgmt_class &&\n\t\t    rmpp_recv->class_version == mad_hdr->class_version &&\n\t\t    rmpp_recv->method == mad_hdr->method)\n\t\t\treturn rmpp_recv;\n\t}\n\treturn NULL;\n}\n\nstatic struct mad_rmpp_recv *\nacquire_rmpp_recv(struct ib_mad_agent_private *agent,\n\t\t  struct ib_mad_recv_wc *mad_recv_wc)\n{\n\tstruct mad_rmpp_recv *rmpp_recv;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&agent->lock, flags);\n\trmpp_recv = find_rmpp_recv(agent, mad_recv_wc);\n\tif (rmpp_recv)\n\t\trefcount_inc(&rmpp_recv->refcount);\n\tspin_unlock_irqrestore(&agent->lock, flags);\n\treturn rmpp_recv;\n}\n\nstatic struct mad_rmpp_recv *\ninsert_rmpp_recv(struct ib_mad_agent_private *agent,\n\t\t struct mad_rmpp_recv *rmpp_recv)\n{\n\tstruct mad_rmpp_recv *cur_rmpp_recv;\n\n\tcur_rmpp_recv = find_rmpp_recv(agent, rmpp_recv->rmpp_wc);\n\tif (!cur_rmpp_recv)\n\t\tlist_add_tail(&rmpp_recv->list, &agent->rmpp_list);\n\n\treturn cur_rmpp_recv;\n}\n\nstatic inline int get_last_flag(struct ib_mad_recv_buf *seg)\n{\n\tstruct ib_rmpp_mad *rmpp_mad;\n\n\trmpp_mad = (struct ib_rmpp_mad *) seg->mad;\n\treturn ib_get_rmpp_flags(&rmpp_mad->rmpp_hdr) & IB_MGMT_RMPP_FLAG_LAST;\n}\n\nstatic inline int get_seg_num(struct ib_mad_recv_buf *seg)\n{\n\tstruct ib_rmpp_mad *rmpp_mad;\n\n\trmpp_mad = (struct ib_rmpp_mad *) seg->mad;\n\treturn be32_to_cpu(rmpp_mad->rmpp_hdr.seg_num);\n}\n\nstatic inline struct ib_mad_recv_buf *get_next_seg(struct list_head *rmpp_list,\n\t\t\t\t\t\t   struct ib_mad_recv_buf *seg)\n{\n\tif (seg->list.next == rmpp_list)\n\t\treturn NULL;\n\n\treturn container_of(seg->list.next, struct ib_mad_recv_buf, list);\n}\n\nstatic inline int window_size(struct ib_mad_agent_private *agent)\n{\n\treturn max(agent->qp_info->recv_queue.max_active >> 3, 1);\n}\n\nstatic struct ib_mad_recv_buf *find_seg_location(struct list_head *rmpp_list,\n\t\t\t\t\t\t int seg_num)\n{\n\tstruct ib_mad_recv_buf *seg_buf;\n\tint cur_seg_num;\n\n\tlist_for_each_entry_reverse(seg_buf, rmpp_list, list) {\n\t\tcur_seg_num = get_seg_num(seg_buf);\n\t\tif (seg_num > cur_seg_num)\n\t\t\treturn seg_buf;\n\t\tif (seg_num == cur_seg_num)\n\t\t\tbreak;\n\t}\n\treturn NULL;\n}\n\nstatic void update_seg_num(struct mad_rmpp_recv *rmpp_recv,\n\t\t\t   struct ib_mad_recv_buf *new_buf)\n{\n\tstruct list_head *rmpp_list = &rmpp_recv->rmpp_wc->rmpp_list;\n\n\twhile (new_buf && (get_seg_num(new_buf) == rmpp_recv->seg_num + 1)) {\n\t\trmpp_recv->cur_seg_buf = new_buf;\n\t\trmpp_recv->seg_num++;\n\t\tnew_buf = get_next_seg(rmpp_list, new_buf);\n\t}\n}\n\nstatic inline int get_mad_len(struct mad_rmpp_recv *rmpp_recv)\n{\n\tstruct ib_rmpp_mad *rmpp_mad;\n\tint hdr_size, data_size, pad;\n\tbool opa = rdma_cap_opa_mad(rmpp_recv->agent->qp_info->port_priv->device,\n\t\t\t\t    rmpp_recv->agent->qp_info->port_priv->port_num);\n\n\trmpp_mad = (struct ib_rmpp_mad *)rmpp_recv->cur_seg_buf->mad;\n\n\thdr_size = ib_get_mad_data_offset(rmpp_mad->mad_hdr.mgmt_class);\n\tif (opa && rmpp_recv->base_version == OPA_MGMT_BASE_VERSION) {\n\t\tdata_size = sizeof(struct opa_rmpp_mad) - hdr_size;\n\t\tpad = OPA_MGMT_RMPP_DATA - be32_to_cpu(rmpp_mad->rmpp_hdr.paylen_newwin);\n\t\tif (pad > OPA_MGMT_RMPP_DATA || pad < 0)\n\t\t\tpad = 0;\n\t} else {\n\t\tdata_size = sizeof(struct ib_rmpp_mad) - hdr_size;\n\t\tpad = IB_MGMT_RMPP_DATA - be32_to_cpu(rmpp_mad->rmpp_hdr.paylen_newwin);\n\t\tif (pad > IB_MGMT_RMPP_DATA || pad < 0)\n\t\t\tpad = 0;\n\t}\n\n\treturn hdr_size + rmpp_recv->seg_num * data_size - pad;\n}\n\nstatic struct ib_mad_recv_wc *complete_rmpp(struct mad_rmpp_recv *rmpp_recv)\n{\n\tstruct ib_mad_recv_wc *rmpp_wc;\n\n\tack_recv(rmpp_recv, rmpp_recv->rmpp_wc);\n\tif (rmpp_recv->seg_num > 1)\n\t\tcancel_delayed_work(&rmpp_recv->timeout_work);\n\n\trmpp_wc = rmpp_recv->rmpp_wc;\n\trmpp_wc->mad_len = get_mad_len(rmpp_recv);\n\t \n\tqueue_delayed_work(rmpp_recv->agent->qp_info->port_priv->wq,\n\t\t\t   &rmpp_recv->cleanup_work, msecs_to_jiffies(10000));\n\treturn rmpp_wc;\n}\n\nstatic struct ib_mad_recv_wc *\ncontinue_rmpp(struct ib_mad_agent_private *agent,\n\t      struct ib_mad_recv_wc *mad_recv_wc)\n{\n\tstruct mad_rmpp_recv *rmpp_recv;\n\tstruct ib_mad_recv_buf *prev_buf;\n\tstruct ib_mad_recv_wc *done_wc;\n\tint seg_num;\n\tunsigned long flags;\n\n\trmpp_recv = acquire_rmpp_recv(agent, mad_recv_wc);\n\tif (!rmpp_recv)\n\t\tgoto drop1;\n\n\tseg_num = get_seg_num(&mad_recv_wc->recv_buf);\n\n\tspin_lock_irqsave(&rmpp_recv->lock, flags);\n\tif ((rmpp_recv->state == RMPP_STATE_TIMEOUT) ||\n\t    (seg_num > rmpp_recv->newwin))\n\t\tgoto drop3;\n\n\tif ((seg_num <= rmpp_recv->last_ack) ||\n\t    (rmpp_recv->state == RMPP_STATE_COMPLETE)) {\n\t\tspin_unlock_irqrestore(&rmpp_recv->lock, flags);\n\t\tack_recv(rmpp_recv, mad_recv_wc);\n\t\tgoto drop2;\n\t}\n\n\tprev_buf = find_seg_location(&rmpp_recv->rmpp_wc->rmpp_list, seg_num);\n\tif (!prev_buf)\n\t\tgoto drop3;\n\n\tdone_wc = NULL;\n\tlist_add(&mad_recv_wc->recv_buf.list, &prev_buf->list);\n\tif (rmpp_recv->cur_seg_buf == prev_buf) {\n\t\tupdate_seg_num(rmpp_recv, &mad_recv_wc->recv_buf);\n\t\tif (get_last_flag(rmpp_recv->cur_seg_buf)) {\n\t\t\trmpp_recv->state = RMPP_STATE_COMPLETE;\n\t\t\tspin_unlock_irqrestore(&rmpp_recv->lock, flags);\n\t\t\tdone_wc = complete_rmpp(rmpp_recv);\n\t\t\tgoto out;\n\t\t} else if (rmpp_recv->seg_num == rmpp_recv->newwin) {\n\t\t\trmpp_recv->newwin += window_size(agent);\n\t\t\tspin_unlock_irqrestore(&rmpp_recv->lock, flags);\n\t\t\tack_recv(rmpp_recv, mad_recv_wc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&rmpp_recv->lock, flags);\nout:\n\tderef_rmpp_recv(rmpp_recv);\n\treturn done_wc;\n\ndrop3:\tspin_unlock_irqrestore(&rmpp_recv->lock, flags);\ndrop2:\tderef_rmpp_recv(rmpp_recv);\ndrop1:\tib_free_recv_mad(mad_recv_wc);\n\treturn NULL;\n}\n\nstatic struct ib_mad_recv_wc *\nstart_rmpp(struct ib_mad_agent_private *agent,\n\t   struct ib_mad_recv_wc *mad_recv_wc)\n{\n\tstruct mad_rmpp_recv *rmpp_recv;\n\tunsigned long flags;\n\n\trmpp_recv = create_rmpp_recv(agent, mad_recv_wc);\n\tif (!rmpp_recv) {\n\t\tib_free_recv_mad(mad_recv_wc);\n\t\treturn NULL;\n\t}\n\n\tspin_lock_irqsave(&agent->lock, flags);\n\tif (insert_rmpp_recv(agent, rmpp_recv)) {\n\t\tspin_unlock_irqrestore(&agent->lock, flags);\n\t\t \n\t\tdestroy_rmpp_recv(rmpp_recv);\n\t\treturn continue_rmpp(agent, mad_recv_wc);\n\t}\n\trefcount_inc(&rmpp_recv->refcount);\n\n\tif (get_last_flag(&mad_recv_wc->recv_buf)) {\n\t\trmpp_recv->state = RMPP_STATE_COMPLETE;\n\t\tspin_unlock_irqrestore(&agent->lock, flags);\n\t\tcomplete_rmpp(rmpp_recv);\n\t} else {\n\t\tspin_unlock_irqrestore(&agent->lock, flags);\n\t\t \n\t\tqueue_delayed_work(agent->qp_info->port_priv->wq,\n\t\t\t\t   &rmpp_recv->timeout_work,\n\t\t\t\t   msecs_to_jiffies(40000));\n\t\trmpp_recv->newwin += window_size(agent);\n\t\tack_recv(rmpp_recv, mad_recv_wc);\n\t\tmad_recv_wc = NULL;\n\t}\n\tderef_rmpp_recv(rmpp_recv);\n\treturn mad_recv_wc;\n}\n\nstatic int send_next_seg(struct ib_mad_send_wr_private *mad_send_wr)\n{\n\tstruct ib_rmpp_mad *rmpp_mad;\n\tint timeout;\n\tu32 paylen = 0;\n\n\trmpp_mad = mad_send_wr->send_buf.mad;\n\tib_set_rmpp_flags(&rmpp_mad->rmpp_hdr, IB_MGMT_RMPP_FLAG_ACTIVE);\n\trmpp_mad->rmpp_hdr.seg_num = cpu_to_be32(++mad_send_wr->seg_num);\n\n\tif (mad_send_wr->seg_num == 1) {\n\t\trmpp_mad->rmpp_hdr.rmpp_rtime_flags |= IB_MGMT_RMPP_FLAG_FIRST;\n\t\tpaylen = (mad_send_wr->send_buf.seg_count *\n\t\t\t  mad_send_wr->send_buf.seg_rmpp_size) -\n\t\t\t  mad_send_wr->pad;\n\t}\n\n\tif (mad_send_wr->seg_num == mad_send_wr->send_buf.seg_count) {\n\t\trmpp_mad->rmpp_hdr.rmpp_rtime_flags |= IB_MGMT_RMPP_FLAG_LAST;\n\t\tpaylen = mad_send_wr->send_buf.seg_rmpp_size - mad_send_wr->pad;\n\t}\n\trmpp_mad->rmpp_hdr.paylen_newwin = cpu_to_be32(paylen);\n\n\t \n\ttimeout = mad_send_wr->send_buf.timeout_ms;\n\tif (!timeout || timeout > 2000)\n\t\tmad_send_wr->timeout = msecs_to_jiffies(2000);\n\n\treturn ib_send_mad(mad_send_wr);\n}\n\nstatic void abort_send(struct ib_mad_agent_private *agent,\n\t\t       struct ib_mad_recv_wc *mad_recv_wc, u8 rmpp_status)\n{\n\tstruct ib_mad_send_wr_private *mad_send_wr;\n\tstruct ib_mad_send_wc wc;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&agent->lock, flags);\n\tmad_send_wr = ib_find_send_mad(agent, mad_recv_wc);\n\tif (!mad_send_wr)\n\t\tgoto out;\t \n\n\tif ((mad_send_wr->last_ack == mad_send_wr->send_buf.seg_count) ||\n\t    (!mad_send_wr->timeout) || (mad_send_wr->status != IB_WC_SUCCESS))\n\t\tgoto out;\t \n\n\tib_mark_mad_done(mad_send_wr);\n\tspin_unlock_irqrestore(&agent->lock, flags);\n\n\twc.status = IB_WC_REM_ABORT_ERR;\n\twc.vendor_err = rmpp_status;\n\twc.send_buf = &mad_send_wr->send_buf;\n\tib_mad_complete_send_wr(mad_send_wr, &wc);\n\treturn;\nout:\n\tspin_unlock_irqrestore(&agent->lock, flags);\n}\n\nstatic inline void adjust_last_ack(struct ib_mad_send_wr_private *wr,\n\t\t\t\t   int seg_num)\n{\n\tstruct list_head *list;\n\n\twr->last_ack = seg_num;\n\tlist = &wr->last_ack_seg->list;\n\tlist_for_each_entry(wr->last_ack_seg, list, list)\n\t\tif (wr->last_ack_seg->num == seg_num)\n\t\t\tbreak;\n}\n\nstatic void process_ds_ack(struct ib_mad_agent_private *agent,\n\t\t\t   struct ib_mad_recv_wc *mad_recv_wc, int newwin)\n{\n\tstruct mad_rmpp_recv *rmpp_recv;\n\n\trmpp_recv = find_rmpp_recv(agent, mad_recv_wc);\n\tif (rmpp_recv && rmpp_recv->state == RMPP_STATE_COMPLETE)\n\t\trmpp_recv->repwin = newwin;\n}\n\nstatic void process_rmpp_ack(struct ib_mad_agent_private *agent,\n\t\t\t     struct ib_mad_recv_wc *mad_recv_wc)\n{\n\tstruct ib_mad_send_wr_private *mad_send_wr;\n\tstruct ib_rmpp_mad *rmpp_mad;\n\tunsigned long flags;\n\tint seg_num, newwin, ret;\n\n\trmpp_mad = (struct ib_rmpp_mad *)mad_recv_wc->recv_buf.mad;\n\tif (rmpp_mad->rmpp_hdr.rmpp_status) {\n\t\tabort_send(agent, mad_recv_wc, IB_MGMT_RMPP_STATUS_BAD_STATUS);\n\t\tnack_recv(agent, mad_recv_wc, IB_MGMT_RMPP_STATUS_BAD_STATUS);\n\t\treturn;\n\t}\n\n\tseg_num = be32_to_cpu(rmpp_mad->rmpp_hdr.seg_num);\n\tnewwin = be32_to_cpu(rmpp_mad->rmpp_hdr.paylen_newwin);\n\tif (newwin < seg_num) {\n\t\tabort_send(agent, mad_recv_wc, IB_MGMT_RMPP_STATUS_W2S);\n\t\tnack_recv(agent, mad_recv_wc, IB_MGMT_RMPP_STATUS_W2S);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&agent->lock, flags);\n\tmad_send_wr = ib_find_send_mad(agent, mad_recv_wc);\n\tif (!mad_send_wr) {\n\t\tif (!seg_num)\n\t\t\tprocess_ds_ack(agent, mad_recv_wc, newwin);\n\t\tgoto out;\t \n\t}\n\n\tif ((mad_send_wr->last_ack == mad_send_wr->send_buf.seg_count) &&\n\t    (mad_send_wr->timeout)) {\n\t\tspin_unlock_irqrestore(&agent->lock, flags);\n\t\tack_ds_ack(agent, mad_recv_wc);\n\t\treturn;\t\t \n\t}\n\n\tif ((mad_send_wr->last_ack == mad_send_wr->send_buf.seg_count) ||\n\t    (!mad_send_wr->timeout) || (mad_send_wr->status != IB_WC_SUCCESS))\n\t\tgoto out;\t \n\n\tif (seg_num > mad_send_wr->send_buf.seg_count ||\n\t    seg_num > mad_send_wr->newwin) {\n\t\tspin_unlock_irqrestore(&agent->lock, flags);\n\t\tabort_send(agent, mad_recv_wc, IB_MGMT_RMPP_STATUS_S2B);\n\t\tnack_recv(agent, mad_recv_wc, IB_MGMT_RMPP_STATUS_S2B);\n\t\treturn;\n\t}\n\n\tif (newwin < mad_send_wr->newwin || seg_num < mad_send_wr->last_ack)\n\t\tgoto out;\t \n\n\tif (seg_num > mad_send_wr->last_ack) {\n\t\tadjust_last_ack(mad_send_wr, seg_num);\n\t\tmad_send_wr->retries_left = mad_send_wr->max_retries;\n\t}\n\tmad_send_wr->newwin = newwin;\n\tif (mad_send_wr->last_ack == mad_send_wr->send_buf.seg_count) {\n\t\t \n\t\tif (!mad_send_wr->send_buf.timeout_ms) {\n\t\t\tstruct ib_mad_send_wc wc;\n\n\t\t\tib_mark_mad_done(mad_send_wr);\n\t\t\tspin_unlock_irqrestore(&agent->lock, flags);\n\n\t\t\twc.status = IB_WC_SUCCESS;\n\t\t\twc.vendor_err = 0;\n\t\t\twc.send_buf = &mad_send_wr->send_buf;\n\t\t\tib_mad_complete_send_wr(mad_send_wr, &wc);\n\t\t\treturn;\n\t\t}\n\t\tif (mad_send_wr->refcount == 1)\n\t\t\tib_reset_mad_timeout(mad_send_wr,\n\t\t\t\t\t     mad_send_wr->send_buf.timeout_ms);\n\t\tspin_unlock_irqrestore(&agent->lock, flags);\n\t\tack_ds_ack(agent, mad_recv_wc);\n\t\treturn;\n\t} else if (mad_send_wr->refcount == 1 &&\n\t\t   mad_send_wr->seg_num < mad_send_wr->newwin &&\n\t\t   mad_send_wr->seg_num < mad_send_wr->send_buf.seg_count) {\n\t\t \n\t\tret = send_next_seg(mad_send_wr);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tmad_send_wr->refcount++;\n\t\tlist_move_tail(&mad_send_wr->agent_list,\n\t\t\t      &mad_send_wr->mad_agent_priv->send_list);\n\t}\nout:\n\tspin_unlock_irqrestore(&agent->lock, flags);\n}\n\nstatic struct ib_mad_recv_wc *\nprocess_rmpp_data(struct ib_mad_agent_private *agent,\n\t\t  struct ib_mad_recv_wc *mad_recv_wc)\n{\n\tstruct ib_rmpp_hdr *rmpp_hdr;\n\tu8 rmpp_status;\n\n\trmpp_hdr = &((struct ib_rmpp_mad *)mad_recv_wc->recv_buf.mad)->rmpp_hdr;\n\n\tif (rmpp_hdr->rmpp_status) {\n\t\trmpp_status = IB_MGMT_RMPP_STATUS_BAD_STATUS;\n\t\tgoto bad;\n\t}\n\n\tif (rmpp_hdr->seg_num == cpu_to_be32(1)) {\n\t\tif (!(ib_get_rmpp_flags(rmpp_hdr) & IB_MGMT_RMPP_FLAG_FIRST)) {\n\t\t\trmpp_status = IB_MGMT_RMPP_STATUS_BAD_SEG;\n\t\t\tgoto bad;\n\t\t}\n\t\treturn start_rmpp(agent, mad_recv_wc);\n\t} else {\n\t\tif (ib_get_rmpp_flags(rmpp_hdr) & IB_MGMT_RMPP_FLAG_FIRST) {\n\t\t\trmpp_status = IB_MGMT_RMPP_STATUS_BAD_SEG;\n\t\t\tgoto bad;\n\t\t}\n\t\treturn continue_rmpp(agent, mad_recv_wc);\n\t}\nbad:\n\tnack_recv(agent, mad_recv_wc, rmpp_status);\n\tib_free_recv_mad(mad_recv_wc);\n\treturn NULL;\n}\n\nstatic void process_rmpp_stop(struct ib_mad_agent_private *agent,\n\t\t\t      struct ib_mad_recv_wc *mad_recv_wc)\n{\n\tstruct ib_rmpp_mad *rmpp_mad;\n\n\trmpp_mad = (struct ib_rmpp_mad *)mad_recv_wc->recv_buf.mad;\n\n\tif (rmpp_mad->rmpp_hdr.rmpp_status != IB_MGMT_RMPP_STATUS_RESX) {\n\t\tabort_send(agent, mad_recv_wc, IB_MGMT_RMPP_STATUS_BAD_STATUS);\n\t\tnack_recv(agent, mad_recv_wc, IB_MGMT_RMPP_STATUS_BAD_STATUS);\n\t} else\n\t\tabort_send(agent, mad_recv_wc, rmpp_mad->rmpp_hdr.rmpp_status);\n}\n\nstatic void process_rmpp_abort(struct ib_mad_agent_private *agent,\n\t\t\t       struct ib_mad_recv_wc *mad_recv_wc)\n{\n\tstruct ib_rmpp_mad *rmpp_mad;\n\n\trmpp_mad = (struct ib_rmpp_mad *)mad_recv_wc->recv_buf.mad;\n\n\tif (rmpp_mad->rmpp_hdr.rmpp_status < IB_MGMT_RMPP_STATUS_ABORT_MIN ||\n\t    rmpp_mad->rmpp_hdr.rmpp_status > IB_MGMT_RMPP_STATUS_ABORT_MAX) {\n\t\tabort_send(agent, mad_recv_wc, IB_MGMT_RMPP_STATUS_BAD_STATUS);\n\t\tnack_recv(agent, mad_recv_wc, IB_MGMT_RMPP_STATUS_BAD_STATUS);\n\t} else\n\t\tabort_send(agent, mad_recv_wc, rmpp_mad->rmpp_hdr.rmpp_status);\n}\n\nstruct ib_mad_recv_wc *\nib_process_rmpp_recv_wc(struct ib_mad_agent_private *agent,\n\t\t\tstruct ib_mad_recv_wc *mad_recv_wc)\n{\n\tstruct ib_rmpp_mad *rmpp_mad;\n\n\trmpp_mad = (struct ib_rmpp_mad *)mad_recv_wc->recv_buf.mad;\n\tif (!(rmpp_mad->rmpp_hdr.rmpp_rtime_flags & IB_MGMT_RMPP_FLAG_ACTIVE))\n\t\treturn mad_recv_wc;\n\n\tif (rmpp_mad->rmpp_hdr.rmpp_version != IB_MGMT_RMPP_VERSION) {\n\t\tabort_send(agent, mad_recv_wc, IB_MGMT_RMPP_STATUS_UNV);\n\t\tnack_recv(agent, mad_recv_wc, IB_MGMT_RMPP_STATUS_UNV);\n\t\tgoto out;\n\t}\n\n\tswitch (rmpp_mad->rmpp_hdr.rmpp_type) {\n\tcase IB_MGMT_RMPP_TYPE_DATA:\n\t\treturn process_rmpp_data(agent, mad_recv_wc);\n\tcase IB_MGMT_RMPP_TYPE_ACK:\n\t\tprocess_rmpp_ack(agent, mad_recv_wc);\n\t\tbreak;\n\tcase IB_MGMT_RMPP_TYPE_STOP:\n\t\tprocess_rmpp_stop(agent, mad_recv_wc);\n\t\tbreak;\n\tcase IB_MGMT_RMPP_TYPE_ABORT:\n\t\tprocess_rmpp_abort(agent, mad_recv_wc);\n\t\tbreak;\n\tdefault:\n\t\tabort_send(agent, mad_recv_wc, IB_MGMT_RMPP_STATUS_BADT);\n\t\tnack_recv(agent, mad_recv_wc, IB_MGMT_RMPP_STATUS_BADT);\n\t\tbreak;\n\t}\nout:\n\tib_free_recv_mad(mad_recv_wc);\n\treturn NULL;\n}\n\nstatic int init_newwin(struct ib_mad_send_wr_private *mad_send_wr)\n{\n\tstruct ib_mad_agent_private *agent = mad_send_wr->mad_agent_priv;\n\tstruct ib_mad_hdr *mad_hdr = mad_send_wr->send_buf.mad;\n\tstruct mad_rmpp_recv *rmpp_recv;\n\tstruct rdma_ah_attr ah_attr;\n\tunsigned long flags;\n\tint newwin = 1;\n\n\tif (!(mad_hdr->method & IB_MGMT_METHOD_RESP))\n\t\tgoto out;\n\n\tspin_lock_irqsave(&agent->lock, flags);\n\tlist_for_each_entry(rmpp_recv, &agent->rmpp_list, list) {\n\t\tif (rmpp_recv->tid != mad_hdr->tid ||\n\t\t    rmpp_recv->mgmt_class != mad_hdr->mgmt_class ||\n\t\t    rmpp_recv->class_version != mad_hdr->class_version ||\n\t\t    (rmpp_recv->method & IB_MGMT_METHOD_RESP))\n\t\t\tcontinue;\n\n\t\tif (rdma_query_ah(mad_send_wr->send_buf.ah, &ah_attr))\n\t\t\tcontinue;\n\n\t\tif (rmpp_recv->slid == rdma_ah_get_dlid(&ah_attr)) {\n\t\t\tnewwin = rmpp_recv->repwin;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&agent->lock, flags);\nout:\n\treturn newwin;\n}\n\nint ib_send_rmpp_mad(struct ib_mad_send_wr_private *mad_send_wr)\n{\n\tstruct ib_rmpp_mad *rmpp_mad;\n\tint ret;\n\n\trmpp_mad = mad_send_wr->send_buf.mad;\n\tif (!(ib_get_rmpp_flags(&rmpp_mad->rmpp_hdr) &\n\t      IB_MGMT_RMPP_FLAG_ACTIVE))\n\t\treturn IB_RMPP_RESULT_UNHANDLED;\n\n\tif (rmpp_mad->rmpp_hdr.rmpp_type != IB_MGMT_RMPP_TYPE_DATA) {\n\t\tmad_send_wr->seg_num = 1;\n\t\treturn IB_RMPP_RESULT_INTERNAL;\n\t}\n\n\tmad_send_wr->newwin = init_newwin(mad_send_wr);\n\n\t \n\tmad_send_wr->refcount += (mad_send_wr->timeout == 0);\n\tret = send_next_seg(mad_send_wr);\n\tif (!ret)\n\t\treturn IB_RMPP_RESULT_CONSUMED;\n\treturn ret;\n}\n\nint ib_process_rmpp_send_wc(struct ib_mad_send_wr_private *mad_send_wr,\n\t\t\t    struct ib_mad_send_wc *mad_send_wc)\n{\n\tstruct ib_rmpp_mad *rmpp_mad;\n\tint ret;\n\n\trmpp_mad = mad_send_wr->send_buf.mad;\n\tif (!(ib_get_rmpp_flags(&rmpp_mad->rmpp_hdr) &\n\t      IB_MGMT_RMPP_FLAG_ACTIVE))\n\t\treturn IB_RMPP_RESULT_UNHANDLED;  \n\n\tif (rmpp_mad->rmpp_hdr.rmpp_type != IB_MGMT_RMPP_TYPE_DATA)\n\t\treturn IB_RMPP_RESULT_INTERNAL;\t  \n\n\tif (mad_send_wc->status != IB_WC_SUCCESS ||\n\t    mad_send_wr->status != IB_WC_SUCCESS)\n\t\treturn IB_RMPP_RESULT_PROCESSED;  \n\n\tif (!mad_send_wr->timeout)\n\t\treturn IB_RMPP_RESULT_PROCESSED;  \n\n\tif (mad_send_wr->last_ack == mad_send_wr->send_buf.seg_count) {\n\t\tmad_send_wr->timeout =\n\t\t\tmsecs_to_jiffies(mad_send_wr->send_buf.timeout_ms);\n\t\treturn IB_RMPP_RESULT_PROCESSED;  \n\t}\n\n\tif (mad_send_wr->seg_num == mad_send_wr->newwin ||\n\t    mad_send_wr->seg_num == mad_send_wr->send_buf.seg_count)\n\t\treturn IB_RMPP_RESULT_PROCESSED;  \n\n\tret = send_next_seg(mad_send_wr);\n\tif (ret) {\n\t\tmad_send_wc->status = IB_WC_GENERAL_ERR;\n\t\treturn IB_RMPP_RESULT_PROCESSED;\n\t}\n\treturn IB_RMPP_RESULT_CONSUMED;\n}\n\nint ib_retry_rmpp(struct ib_mad_send_wr_private *mad_send_wr)\n{\n\tstruct ib_rmpp_mad *rmpp_mad;\n\tint ret;\n\n\trmpp_mad = mad_send_wr->send_buf.mad;\n\tif (!(ib_get_rmpp_flags(&rmpp_mad->rmpp_hdr) &\n\t      IB_MGMT_RMPP_FLAG_ACTIVE))\n\t\treturn IB_RMPP_RESULT_UNHANDLED;  \n\n\tif (mad_send_wr->last_ack == mad_send_wr->send_buf.seg_count)\n\t\treturn IB_RMPP_RESULT_PROCESSED;\n\n\tmad_send_wr->seg_num = mad_send_wr->last_ack;\n\tmad_send_wr->cur_seg = mad_send_wr->last_ack_seg;\n\n\tret = send_next_seg(mad_send_wr);\n\tif (ret)\n\t\treturn IB_RMPP_RESULT_PROCESSED;\n\n\treturn IB_RMPP_RESULT_CONSUMED;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}