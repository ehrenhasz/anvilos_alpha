{
  "module_name": "uverbs_ioctl.c",
  "hash_id": "5c272f6bfba2b0ea8a726295c8a810e4d7175a5e2e982b953de23196278d6f1d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/core/uverbs_ioctl.c",
  "human_readable_source": " \n\n#include <rdma/rdma_user_ioctl.h>\n#include <rdma/uverbs_ioctl.h>\n#include \"rdma_core.h\"\n#include \"uverbs.h\"\n\nstruct bundle_alloc_head {\n\tstruct bundle_alloc_head *next;\n\tu8 data[];\n};\n\nstruct bundle_priv {\n\t \n\tstruct bundle_alloc_head alloc_head;\n\tstruct bundle_alloc_head *allocated_mem;\n\tsize_t internal_avail;\n\tsize_t internal_used;\n\n\tstruct radix_tree_root *radix;\n\tconst struct uverbs_api_ioctl_method *method_elm;\n\tvoid __rcu **radix_slots;\n\tunsigned long radix_slots_len;\n\tu32 method_key;\n\n\tstruct ib_uverbs_attr __user *user_attrs;\n\tstruct ib_uverbs_attr *uattrs;\n\n\tDECLARE_BITMAP(uobj_finalize, UVERBS_API_ATTR_BKEY_LEN);\n\tDECLARE_BITMAP(spec_finalize, UVERBS_API_ATTR_BKEY_LEN);\n\tDECLARE_BITMAP(uobj_hw_obj_valid, UVERBS_API_ATTR_BKEY_LEN);\n\n\t \n\tstruct uverbs_attr_bundle bundle;\n\tu64 internal_buffer[32];\n};\n\n \nvoid uapi_compute_bundle_size(struct uverbs_api_ioctl_method *method_elm,\n\t\t\t      unsigned int num_attrs)\n{\n\tstruct bundle_priv *pbundle;\n\tsize_t bundle_size =\n\t\toffsetof(struct bundle_priv, internal_buffer) +\n\t\tsizeof(*pbundle->bundle.attrs) * method_elm->key_bitmap_len +\n\t\tsizeof(*pbundle->uattrs) * num_attrs;\n\n\tmethod_elm->use_stack = bundle_size <= sizeof(*pbundle);\n\tmethod_elm->bundle_size =\n\t\tALIGN(bundle_size + 256, sizeof(*pbundle->internal_buffer));\n\n\t \n\tWARN_ON_ONCE(method_elm->bundle_size > PAGE_SIZE);\n}\n\n \n__malloc void *_uverbs_alloc(struct uverbs_attr_bundle *bundle, size_t size,\n\t\t\t     gfp_t flags)\n{\n\tstruct bundle_priv *pbundle =\n\t\tcontainer_of(bundle, struct bundle_priv, bundle);\n\tsize_t new_used;\n\tvoid *res;\n\n\tif (check_add_overflow(size, pbundle->internal_used, &new_used))\n\t\treturn ERR_PTR(-EOVERFLOW);\n\n\tif (new_used > pbundle->internal_avail) {\n\t\tstruct bundle_alloc_head *buf;\n\n\t\tbuf = kvmalloc(struct_size(buf, data, size), flags);\n\t\tif (!buf)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tbuf->next = pbundle->allocated_mem;\n\t\tpbundle->allocated_mem = buf;\n\t\treturn buf->data;\n\t}\n\n\tres = (void *)pbundle->internal_buffer + pbundle->internal_used;\n\tpbundle->internal_used =\n\t\tALIGN(new_used, sizeof(*pbundle->internal_buffer));\n\tif (want_init_on_alloc(flags))\n\t\tmemset(res, 0, size);\n\treturn res;\n}\nEXPORT_SYMBOL(_uverbs_alloc);\n\nstatic bool uverbs_is_attr_cleared(const struct ib_uverbs_attr *uattr,\n\t\t\t\t   u16 len)\n{\n\tif (uattr->len > sizeof_field(struct ib_uverbs_attr, data))\n\t\treturn ib_is_buffer_cleared(u64_to_user_ptr(uattr->data) + len,\n\t\t\t\t\t    uattr->len - len);\n\n\treturn !memchr_inv((const void *)&uattr->data + len,\n\t\t\t   0, uattr->len - len);\n}\n\nstatic int uverbs_set_output(const struct uverbs_attr_bundle *bundle,\n\t\t\t     const struct uverbs_attr *attr)\n{\n\tstruct bundle_priv *pbundle =\n\t\tcontainer_of(bundle, struct bundle_priv, bundle);\n\tu16 flags;\n\n\tflags = pbundle->uattrs[attr->ptr_attr.uattr_idx].flags |\n\t\tUVERBS_ATTR_F_VALID_OUTPUT;\n\tif (put_user(flags,\n\t\t     &pbundle->user_attrs[attr->ptr_attr.uattr_idx].flags))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int uverbs_process_idrs_array(struct bundle_priv *pbundle,\n\t\t\t\t     const struct uverbs_api_attr *attr_uapi,\n\t\t\t\t     struct uverbs_objs_arr_attr *attr,\n\t\t\t\t     struct ib_uverbs_attr *uattr,\n\t\t\t\t     u32 attr_bkey)\n{\n\tconst struct uverbs_attr_spec *spec = &attr_uapi->spec;\n\tsize_t array_len;\n\tu32 *idr_vals;\n\tint ret = 0;\n\tsize_t i;\n\n\tif (uattr->attr_data.reserved)\n\t\treturn -EINVAL;\n\n\tif (uattr->len % sizeof(u32))\n\t\treturn -EINVAL;\n\n\tarray_len = uattr->len / sizeof(u32);\n\tif (array_len < spec->u2.objs_arr.min_len ||\n\t    array_len > spec->u2.objs_arr.max_len)\n\t\treturn -EINVAL;\n\n\tattr->uobjects =\n\t\tuverbs_alloc(&pbundle->bundle,\n\t\t\t     array_size(array_len, sizeof(*attr->uobjects)));\n\tif (IS_ERR(attr->uobjects))\n\t\treturn PTR_ERR(attr->uobjects);\n\n\t \n\tidr_vals = (u32 *)(attr->uobjects + array_len) - array_len;\n\n\tif (uattr->len > sizeof(uattr->data)) {\n\t\tret = copy_from_user(idr_vals, u64_to_user_ptr(uattr->data),\n\t\t\t\t     uattr->len);\n\t\tif (ret)\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tmemcpy(idr_vals, &uattr->data, uattr->len);\n\t}\n\n\tfor (i = 0; i != array_len; i++) {\n\t\tattr->uobjects[i] = uverbs_get_uobject_from_file(\n\t\t\tspec->u2.objs_arr.obj_type, spec->u2.objs_arr.access,\n\t\t\tidr_vals[i], &pbundle->bundle);\n\t\tif (IS_ERR(attr->uobjects[i])) {\n\t\t\tret = PTR_ERR(attr->uobjects[i]);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tattr->len = i;\n\t__set_bit(attr_bkey, pbundle->spec_finalize);\n\treturn ret;\n}\n\nstatic void uverbs_free_idrs_array(const struct uverbs_api_attr *attr_uapi,\n\t\t\t\t   struct uverbs_objs_arr_attr *attr,\n\t\t\t\t   bool commit,\n\t\t\t\t   struct uverbs_attr_bundle *attrs)\n{\n\tconst struct uverbs_attr_spec *spec = &attr_uapi->spec;\n\tsize_t i;\n\n\tfor (i = 0; i != attr->len; i++)\n\t\tuverbs_finalize_object(attr->uobjects[i],\n\t\t\t\t       spec->u2.objs_arr.access, false, commit,\n\t\t\t\t       attrs);\n}\n\nstatic int uverbs_process_attr(struct bundle_priv *pbundle,\n\t\t\t       const struct uverbs_api_attr *attr_uapi,\n\t\t\t       struct ib_uverbs_attr *uattr, u32 attr_bkey)\n{\n\tconst struct uverbs_attr_spec *spec = &attr_uapi->spec;\n\tstruct uverbs_attr *e = &pbundle->bundle.attrs[attr_bkey];\n\tconst struct uverbs_attr_spec *val_spec = spec;\n\tstruct uverbs_obj_attr *o_attr;\n\n\tswitch (spec->type) {\n\tcase UVERBS_ATTR_TYPE_ENUM_IN:\n\t\tif (uattr->attr_data.enum_data.elem_id >= spec->u.enum_def.num_elems)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (uattr->attr_data.enum_data.reserved)\n\t\t\treturn -EINVAL;\n\n\t\tval_spec = &spec->u2.enum_def.ids[uattr->attr_data.enum_data.elem_id];\n\n\t\t \n\t\tif (val_spec->type != UVERBS_ATTR_TYPE_PTR_IN)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\te->ptr_attr.enum_id = uattr->attr_data.enum_data.elem_id;\n\t\tfallthrough;\n\tcase UVERBS_ATTR_TYPE_PTR_IN:\n\t\t \n\t\tif (uattr->len > val_spec->u.ptr.len &&\n\t\t    val_spec->zero_trailing &&\n\t\t    !uverbs_is_attr_cleared(uattr, val_spec->u.ptr.len))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tfallthrough;\n\tcase UVERBS_ATTR_TYPE_PTR_OUT:\n\t\tif (uattr->len < val_spec->u.ptr.min_len ||\n\t\t    (!val_spec->zero_trailing &&\n\t\t     uattr->len > val_spec->u.ptr.len))\n\t\t\treturn -EINVAL;\n\n\t\tif (spec->type != UVERBS_ATTR_TYPE_ENUM_IN &&\n\t\t    uattr->attr_data.reserved)\n\t\t\treturn -EINVAL;\n\n\t\te->ptr_attr.uattr_idx = uattr - pbundle->uattrs;\n\t\te->ptr_attr.len = uattr->len;\n\n\t\tif (val_spec->alloc_and_copy && !uverbs_attr_ptr_is_inline(e)) {\n\t\t\tvoid *p;\n\n\t\t\tp = uverbs_alloc(&pbundle->bundle, uattr->len);\n\t\t\tif (IS_ERR(p))\n\t\t\t\treturn PTR_ERR(p);\n\n\t\t\te->ptr_attr.ptr = p;\n\n\t\t\tif (copy_from_user(p, u64_to_user_ptr(uattr->data),\n\t\t\t\t\t   uattr->len))\n\t\t\t\treturn -EFAULT;\n\t\t} else {\n\t\t\te->ptr_attr.data = uattr->data;\n\t\t}\n\t\tbreak;\n\n\tcase UVERBS_ATTR_TYPE_IDR:\n\tcase UVERBS_ATTR_TYPE_FD:\n\t\tif (uattr->attr_data.reserved)\n\t\t\treturn -EINVAL;\n\n\t\tif (uattr->len != 0)\n\t\t\treturn -EINVAL;\n\n\t\to_attr = &e->obj_attr;\n\t\to_attr->attr_elm = attr_uapi;\n\n\t\t \n\t\to_attr->uobject = uverbs_get_uobject_from_file(\n\t\t\tspec->u.obj.obj_type, spec->u.obj.access,\n\t\t\tuattr->data_s64, &pbundle->bundle);\n\t\tif (IS_ERR(o_attr->uobject))\n\t\t\treturn PTR_ERR(o_attr->uobject);\n\t\t__set_bit(attr_bkey, pbundle->uobj_finalize);\n\n\t\tif (spec->u.obj.access == UVERBS_ACCESS_NEW) {\n\t\t\tunsigned int uattr_idx = uattr - pbundle->uattrs;\n\t\t\ts64 id = o_attr->uobject->id;\n\n\t\t\t \n\t\t\tif (put_user(id, &pbundle->user_attrs[uattr_idx].data))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tbreak;\n\n\tcase UVERBS_ATTR_TYPE_RAW_FD:\n\t\tif (uattr->attr_data.reserved || uattr->len != 0 ||\n\t\t    uattr->data_s64 < INT_MIN || uattr->data_s64 > INT_MAX)\n\t\t\treturn -EINVAL;\n\t\t \n\t\te->ptr_attr.data = uattr->data_s64;\n\t\tbreak;\n\n\tcase UVERBS_ATTR_TYPE_IDRS_ARRAY:\n\t\treturn uverbs_process_idrs_array(pbundle, attr_uapi,\n\t\t\t\t\t\t &e->objs_arr_attr, uattr,\n\t\t\t\t\t\t attr_bkey);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void __rcu **uapi_get_attr_for_method(struct bundle_priv *pbundle,\n\t\t\t\t\t     u32 attr_key)\n{\n\tvoid __rcu **slot;\n\n\tif (likely(attr_key < pbundle->radix_slots_len)) {\n\t\tvoid *entry;\n\n\t\tslot = pbundle->radix_slots + attr_key;\n\t\tentry = rcu_dereference_raw(*slot);\n\t\tif (likely(!radix_tree_is_internal_node(entry) && entry))\n\t\t\treturn slot;\n\t}\n\n\treturn radix_tree_lookup_slot(pbundle->radix,\n\t\t\t\t      pbundle->method_key | attr_key);\n}\n\nstatic int uverbs_set_attr(struct bundle_priv *pbundle,\n\t\t\t   struct ib_uverbs_attr *uattr)\n{\n\tu32 attr_key = uapi_key_attr(uattr->attr_id);\n\tu32 attr_bkey = uapi_bkey_attr(attr_key);\n\tconst struct uverbs_api_attr *attr;\n\tvoid __rcu **slot;\n\tint ret;\n\n\tslot = uapi_get_attr_for_method(pbundle, attr_key);\n\tif (!slot) {\n\t\t \n\t\tif (uattr->flags & UVERBS_ATTR_F_MANDATORY)\n\t\t\treturn -EPROTONOSUPPORT;\n\t\treturn 0;\n\t}\n\tattr = rcu_dereference_protected(*slot, true);\n\n\t \n\tif (test_bit(attr_bkey, pbundle->bundle.attr_present))\n\t\treturn -EINVAL;\n\n\tret = uverbs_process_attr(pbundle, attr, uattr, attr_bkey);\n\tif (ret)\n\t\treturn ret;\n\n\t__set_bit(attr_bkey, pbundle->bundle.attr_present);\n\n\treturn 0;\n}\n\nstatic int ib_uverbs_run_method(struct bundle_priv *pbundle,\n\t\t\t\tunsigned int num_attrs)\n{\n\tint (*handler)(struct uverbs_attr_bundle *attrs);\n\tsize_t uattrs_size = array_size(sizeof(*pbundle->uattrs), num_attrs);\n\tunsigned int destroy_bkey = pbundle->method_elm->destroy_bkey;\n\tunsigned int i;\n\tint ret;\n\n\t \n\thandler = srcu_dereference(\n\t\tpbundle->method_elm->handler,\n\t\t&pbundle->bundle.ufile->device->disassociate_srcu);\n\tif (!handler)\n\t\treturn -EIO;\n\n\tpbundle->uattrs = uverbs_alloc(&pbundle->bundle, uattrs_size);\n\tif (IS_ERR(pbundle->uattrs))\n\t\treturn PTR_ERR(pbundle->uattrs);\n\tif (copy_from_user(pbundle->uattrs, pbundle->user_attrs, uattrs_size))\n\t\treturn -EFAULT;\n\n\tfor (i = 0; i != num_attrs; i++) {\n\t\tret = uverbs_set_attr(pbundle, &pbundle->uattrs[i]);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (unlikely(!bitmap_subset(pbundle->method_elm->attr_mandatory,\n\t\t\t\t    pbundle->bundle.attr_present,\n\t\t\t\t    pbundle->method_elm->key_bitmap_len)))\n\t\treturn -EINVAL;\n\n\tif (pbundle->method_elm->has_udata)\n\t\tuverbs_fill_udata(&pbundle->bundle,\n\t\t\t\t  &pbundle->bundle.driver_udata,\n\t\t\t\t  UVERBS_ATTR_UHW_IN, UVERBS_ATTR_UHW_OUT);\n\telse\n\t\tpbundle->bundle.driver_udata = (struct ib_udata){};\n\n\tif (destroy_bkey != UVERBS_API_ATTR_BKEY_LEN) {\n\t\tstruct uverbs_obj_attr *destroy_attr =\n\t\t\t&pbundle->bundle.attrs[destroy_bkey].obj_attr;\n\n\t\tret = uobj_destroy(destroy_attr->uobject, &pbundle->bundle);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t__clear_bit(destroy_bkey, pbundle->uobj_finalize);\n\n\t\tret = handler(&pbundle->bundle);\n\t\tuobj_put_destroy(destroy_attr->uobject);\n\t} else {\n\t\tret = handler(&pbundle->bundle);\n\t}\n\n\t \n\tif (!ret && pbundle->method_elm->has_udata) {\n\t\tconst struct uverbs_attr *attr =\n\t\t\tuverbs_attr_get(&pbundle->bundle, UVERBS_ATTR_UHW_OUT);\n\n\t\tif (!IS_ERR(attr))\n\t\t\tret = uverbs_set_output(&pbundle->bundle, attr);\n\t}\n\n\t \n\tif (WARN_ON_ONCE(ret == -EPROTONOSUPPORT))\n\t\treturn -EINVAL;\n\n\treturn ret;\n}\n\nstatic void bundle_destroy(struct bundle_priv *pbundle, bool commit)\n{\n\tunsigned int key_bitmap_len = pbundle->method_elm->key_bitmap_len;\n\tstruct bundle_alloc_head *memblock;\n\tunsigned int i;\n\n\t \n\ti = -1;\n\twhile ((i = find_next_bit(pbundle->uobj_finalize, key_bitmap_len,\n\t\t\t\t  i + 1)) < key_bitmap_len) {\n\t\tstruct uverbs_attr *attr = &pbundle->bundle.attrs[i];\n\n\t\tuverbs_finalize_object(\n\t\t\tattr->obj_attr.uobject,\n\t\t\tattr->obj_attr.attr_elm->spec.u.obj.access,\n\t\t\ttest_bit(i, pbundle->uobj_hw_obj_valid),\n\t\t\tcommit,\n\t\t\t&pbundle->bundle);\n\t}\n\n\ti = -1;\n\twhile ((i = find_next_bit(pbundle->spec_finalize, key_bitmap_len,\n\t\t\t\t  i + 1)) < key_bitmap_len) {\n\t\tstruct uverbs_attr *attr = &pbundle->bundle.attrs[i];\n\t\tconst struct uverbs_api_attr *attr_uapi;\n\t\tvoid __rcu **slot;\n\n\t\tslot = uapi_get_attr_for_method(\n\t\t\tpbundle,\n\t\t\tpbundle->method_key | uapi_bkey_to_key_attr(i));\n\t\tif (WARN_ON(!slot))\n\t\t\tcontinue;\n\n\t\tattr_uapi = rcu_dereference_protected(*slot, true);\n\n\t\tif (attr_uapi->spec.type == UVERBS_ATTR_TYPE_IDRS_ARRAY) {\n\t\t\tuverbs_free_idrs_array(attr_uapi, &attr->objs_arr_attr,\n\t\t\t\t\t       commit, &pbundle->bundle);\n\t\t}\n\t}\n\n\tfor (memblock = pbundle->allocated_mem; memblock;) {\n\t\tstruct bundle_alloc_head *tmp = memblock;\n\n\t\tmemblock = memblock->next;\n\t\tkvfree(tmp);\n\t}\n}\n\nstatic int ib_uverbs_cmd_verbs(struct ib_uverbs_file *ufile,\n\t\t\t       struct ib_uverbs_ioctl_hdr *hdr,\n\t\t\t       struct ib_uverbs_attr __user *user_attrs)\n{\n\tconst struct uverbs_api_ioctl_method *method_elm;\n\tstruct uverbs_api *uapi = ufile->device->uapi;\n\tstruct radix_tree_iter attrs_iter;\n\tstruct bundle_priv *pbundle;\n\tstruct bundle_priv onstack;\n\tvoid __rcu **slot;\n\tint ret;\n\n\tif (unlikely(hdr->driver_id != uapi->driver_id))\n\t\treturn -EINVAL;\n\n\tslot = radix_tree_iter_lookup(\n\t\t&uapi->radix, &attrs_iter,\n\t\tuapi_key_obj(hdr->object_id) |\n\t\t\tuapi_key_ioctl_method(hdr->method_id));\n\tif (unlikely(!slot))\n\t\treturn -EPROTONOSUPPORT;\n\tmethod_elm = rcu_dereference_protected(*slot, true);\n\n\tif (!method_elm->use_stack) {\n\t\tpbundle = kmalloc(method_elm->bundle_size, GFP_KERNEL);\n\t\tif (!pbundle)\n\t\t\treturn -ENOMEM;\n\t\tpbundle->internal_avail =\n\t\t\tmethod_elm->bundle_size -\n\t\t\toffsetof(struct bundle_priv, internal_buffer);\n\t\tpbundle->alloc_head.next = NULL;\n\t\tpbundle->allocated_mem = &pbundle->alloc_head;\n\t} else {\n\t\tpbundle = &onstack;\n\t\tpbundle->internal_avail = sizeof(pbundle->internal_buffer);\n\t\tpbundle->allocated_mem = NULL;\n\t}\n\n\t \n\tpbundle->method_elm = method_elm;\n\tpbundle->method_key = attrs_iter.index;\n\tpbundle->bundle.ufile = ufile;\n\tpbundle->bundle.context = NULL;  \n\tpbundle->radix = &uapi->radix;\n\tpbundle->radix_slots = slot;\n\tpbundle->radix_slots_len = radix_tree_chunk_size(&attrs_iter);\n\tpbundle->user_attrs = user_attrs;\n\n\tpbundle->internal_used = ALIGN(pbundle->method_elm->key_bitmap_len *\n\t\t\t\t\t       sizeof(*pbundle->bundle.attrs),\n\t\t\t\t       sizeof(*pbundle->internal_buffer));\n\tmemset(pbundle->bundle.attr_present, 0,\n\t       sizeof(pbundle->bundle.attr_present));\n\tmemset(pbundle->uobj_finalize, 0, sizeof(pbundle->uobj_finalize));\n\tmemset(pbundle->spec_finalize, 0, sizeof(pbundle->spec_finalize));\n\tmemset(pbundle->uobj_hw_obj_valid, 0,\n\t       sizeof(pbundle->uobj_hw_obj_valid));\n\n\tret = ib_uverbs_run_method(pbundle, hdr->num_attrs);\n\tbundle_destroy(pbundle, ret == 0);\n\treturn ret;\n}\n\nlong ib_uverbs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct ib_uverbs_file *file = filp->private_data;\n\tstruct ib_uverbs_ioctl_hdr __user *user_hdr =\n\t\t(struct ib_uverbs_ioctl_hdr __user *)arg;\n\tstruct ib_uverbs_ioctl_hdr hdr;\n\tint srcu_key;\n\tint err;\n\n\tif (unlikely(cmd != RDMA_VERBS_IOCTL))\n\t\treturn -ENOIOCTLCMD;\n\n\terr = copy_from_user(&hdr, user_hdr, sizeof(hdr));\n\tif (err)\n\t\treturn -EFAULT;\n\n\tif (hdr.length > PAGE_SIZE ||\n\t    hdr.length != struct_size(&hdr, attrs, hdr.num_attrs))\n\t\treturn -EINVAL;\n\n\tif (hdr.reserved1 || hdr.reserved2)\n\t\treturn -EPROTONOSUPPORT;\n\n\tsrcu_key = srcu_read_lock(&file->device->disassociate_srcu);\n\terr = ib_uverbs_cmd_verbs(file, &hdr, user_hdr->attrs);\n\tsrcu_read_unlock(&file->device->disassociate_srcu, srcu_key);\n\treturn err;\n}\n\nint uverbs_get_flags64(u64 *to, const struct uverbs_attr_bundle *attrs_bundle,\n\t\t       size_t idx, u64 allowed_bits)\n{\n\tconst struct uverbs_attr *attr;\n\tu64 flags;\n\n\tattr = uverbs_attr_get(attrs_bundle, idx);\n\t \n\tif (IS_ERR(attr)) {\n\t\t*to = 0;\n\t\treturn 0;\n\t}\n\n\t \n\tif (attr->ptr_attr.len == 8)\n\t\tflags = attr->ptr_attr.data;\n\telse if (attr->ptr_attr.len == 4)\n\t\tflags = *(u32 *)&attr->ptr_attr.data;\n\telse\n\t\treturn -EINVAL;\n\n\tif (flags & ~allowed_bits)\n\t\treturn -EINVAL;\n\n\t*to = flags;\n\treturn 0;\n}\nEXPORT_SYMBOL(uverbs_get_flags64);\n\nint uverbs_get_flags32(u32 *to, const struct uverbs_attr_bundle *attrs_bundle,\n\t\t       size_t idx, u64 allowed_bits)\n{\n\tu64 flags;\n\tint ret;\n\n\tret = uverbs_get_flags64(&flags, attrs_bundle, idx, allowed_bits);\n\tif (ret)\n\t\treturn ret;\n\n\tif (flags > U32_MAX)\n\t\treturn -EINVAL;\n\t*to = flags;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(uverbs_get_flags32);\n\n \nvoid uverbs_fill_udata(struct uverbs_attr_bundle *bundle,\n\t\t       struct ib_udata *udata, unsigned int attr_in,\n\t\t       unsigned int attr_out)\n{\n\tstruct bundle_priv *pbundle =\n\t\tcontainer_of(bundle, struct bundle_priv, bundle);\n\tconst struct uverbs_attr *in =\n\t\tuverbs_attr_get(&pbundle->bundle, attr_in);\n\tconst struct uverbs_attr *out =\n\t\tuverbs_attr_get(&pbundle->bundle, attr_out);\n\n\tif (!IS_ERR(in)) {\n\t\tudata->inlen = in->ptr_attr.len;\n\t\tif (uverbs_attr_ptr_is_inline(in))\n\t\t\tudata->inbuf =\n\t\t\t\t&pbundle->user_attrs[in->ptr_attr.uattr_idx]\n\t\t\t\t\t .data;\n\t\telse\n\t\t\tudata->inbuf = u64_to_user_ptr(in->ptr_attr.data);\n\t} else {\n\t\tudata->inbuf = NULL;\n\t\tudata->inlen = 0;\n\t}\n\n\tif (!IS_ERR(out)) {\n\t\tudata->outbuf = u64_to_user_ptr(out->ptr_attr.data);\n\t\tudata->outlen = out->ptr_attr.len;\n\t} else {\n\t\tudata->outbuf = NULL;\n\t\tudata->outlen = 0;\n\t}\n}\n\nint uverbs_copy_to(const struct uverbs_attr_bundle *bundle, size_t idx,\n\t\t   const void *from, size_t size)\n{\n\tconst struct uverbs_attr *attr = uverbs_attr_get(bundle, idx);\n\tsize_t min_size;\n\n\tif (IS_ERR(attr))\n\t\treturn PTR_ERR(attr);\n\n\tmin_size = min_t(size_t, attr->ptr_attr.len, size);\n\tif (copy_to_user(u64_to_user_ptr(attr->ptr_attr.data), from, min_size))\n\t\treturn -EFAULT;\n\n\treturn uverbs_set_output(bundle, attr);\n}\nEXPORT_SYMBOL(uverbs_copy_to);\n\n\n \nint uverbs_output_written(const struct uverbs_attr_bundle *bundle, size_t idx)\n{\n\tconst struct uverbs_attr *attr = uverbs_attr_get(bundle, idx);\n\n\tif (IS_ERR(attr))\n\t\treturn PTR_ERR(attr);\n\n\treturn uverbs_set_output(bundle, attr);\n}\n\nint _uverbs_get_const_signed(s64 *to,\n\t\t\t     const struct uverbs_attr_bundle *attrs_bundle,\n\t\t\t     size_t idx, s64 lower_bound, u64 upper_bound,\n\t\t\t     s64  *def_val)\n{\n\tconst struct uverbs_attr *attr;\n\n\tattr = uverbs_attr_get(attrs_bundle, idx);\n\tif (IS_ERR(attr)) {\n\t\tif ((PTR_ERR(attr) != -ENOENT) || !def_val)\n\t\t\treturn PTR_ERR(attr);\n\n\t\t*to = *def_val;\n\t} else {\n\t\t*to = attr->ptr_attr.data;\n\t}\n\n\tif (*to < lower_bound || (*to > 0 && (u64)*to > upper_bound))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(_uverbs_get_const_signed);\n\nint _uverbs_get_const_unsigned(u64 *to,\n\t\t\t       const struct uverbs_attr_bundle *attrs_bundle,\n\t\t\t       size_t idx, u64 upper_bound, u64 *def_val)\n{\n\tconst struct uverbs_attr *attr;\n\n\tattr = uverbs_attr_get(attrs_bundle, idx);\n\tif (IS_ERR(attr)) {\n\t\tif ((PTR_ERR(attr) != -ENOENT) || !def_val)\n\t\t\treturn PTR_ERR(attr);\n\n\t\t*to = *def_val;\n\t} else {\n\t\t*to = attr->ptr_attr.data;\n\t}\n\n\tif (*to > upper_bound)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(_uverbs_get_const_unsigned);\n\nint uverbs_copy_to_struct_or_zero(const struct uverbs_attr_bundle *bundle,\n\t\t\t\t  size_t idx, const void *from, size_t size)\n{\n\tconst struct uverbs_attr *attr = uverbs_attr_get(bundle, idx);\n\n\tif (IS_ERR(attr))\n\t\treturn PTR_ERR(attr);\n\n\tif (size < attr->ptr_attr.len) {\n\t\tif (clear_user(u64_to_user_ptr(attr->ptr_attr.data) + size,\n\t\t\t       attr->ptr_attr.len - size))\n\t\t\treturn -EFAULT;\n\t}\n\treturn uverbs_copy_to(bundle, idx, from, size);\n}\nEXPORT_SYMBOL(uverbs_copy_to_struct_or_zero);\n\n \nvoid uverbs_finalize_uobj_create(const struct uverbs_attr_bundle *bundle,\n\t\t\t\t u16 idx)\n{\n\tstruct bundle_priv *pbundle =\n\t\tcontainer_of(bundle, struct bundle_priv, bundle);\n\n\t__set_bit(uapi_bkey_attr(uapi_key_attr(idx)),\n\t\t  pbundle->uobj_hw_obj_valid);\n}\nEXPORT_SYMBOL(uverbs_finalize_uobj_create);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}