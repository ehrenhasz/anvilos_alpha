{
  "module_name": "cma_priv.h",
  "hash_id": "381bea88d07a4a9eac5eda0b312200f6141a01e803db2c6f5570179aae4cb8ef",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/core/cma_priv.h",
  "human_readable_source": " \n\n#ifndef _CMA_PRIV_H\n#define _CMA_PRIV_H\n\nenum rdma_cm_state {\n\tRDMA_CM_IDLE,\n\tRDMA_CM_ADDR_QUERY,\n\tRDMA_CM_ADDR_RESOLVED,\n\tRDMA_CM_ROUTE_QUERY,\n\tRDMA_CM_ROUTE_RESOLVED,\n\tRDMA_CM_CONNECT,\n\tRDMA_CM_DISCONNECT,\n\tRDMA_CM_ADDR_BOUND,\n\tRDMA_CM_LISTEN,\n\tRDMA_CM_DEVICE_REMOVAL,\n\tRDMA_CM_DESTROYING\n};\n\nstruct rdma_id_private {\n\tstruct rdma_cm_id\tid;\n\n\tstruct rdma_bind_list\t*bind_list;\n\tstruct hlist_node\tnode;\n\tunion {\n\t\tstruct list_head device_item;  \n\t\tstruct list_head listen_any_item;  \n\t};\n\tunion {\n\t\t \n\t\tstruct list_head listen_item;\n\t\tstruct list_head listen_list;\n\t};\n\tstruct list_head        id_list_entry;\n\tstruct cma_device\t*cma_dev;\n\tstruct list_head\tmc_list;\n\n\tint\t\t\tinternal_id;\n\tenum rdma_cm_state\tstate;\n\tspinlock_t\t\tlock;\n\tstruct mutex\t\tqp_mutex;\n\n\tstruct completion\tcomp;\n\trefcount_t refcount;\n\tstruct mutex\t\thandler_mutex;\n\n\tint\t\t\tbacklog;\n\tint\t\t\ttimeout_ms;\n\tstruct ib_sa_query\t*query;\n\tint\t\t\tquery_id;\n\tunion {\n\t\tstruct ib_cm_id\t*ib;\n\t\tstruct iw_cm_id\t*iw;\n\t} cm_id;\n\n\tu32\t\t\tseq_num;\n\tu32\t\t\tqkey;\n\tu32\t\t\tqp_num;\n\tu32\t\t\toptions;\n\tu8\t\t\tsrq;\n\tu8\t\t\ttos;\n\tu8\t\t\ttos_set:1;\n\tu8                      timeout_set:1;\n\tu8\t\t\tmin_rnr_timer_set:1;\n\tu8\t\t\treuseaddr;\n\tu8\t\t\tafonly;\n\tu8\t\t\ttimeout;\n\tu8\t\t\tmin_rnr_timer;\n\tu8 used_resolve_ip;\n\tenum ib_gid_type\tgid_type;\n\n\t \n\tstruct rdma_restrack_entry     res;\n\tstruct rdma_ucm_ece ece;\n};\n\n#if IS_ENABLED(CONFIG_INFINIBAND_ADDR_TRANS_CONFIGFS)\nint cma_configfs_init(void);\nvoid cma_configfs_exit(void);\n#else\nstatic inline int cma_configfs_init(void)\n{\n\treturn 0;\n}\n\nstatic inline void cma_configfs_exit(void)\n{\n}\n#endif\n\nvoid cma_dev_get(struct cma_device *dev);\nvoid cma_dev_put(struct cma_device *dev);\ntypedef bool (*cma_device_filter)(struct ib_device *, void *);\nstruct cma_device *cma_enum_devices_by_ibdev(cma_device_filter filter,\n\t\t\t\t\t     void *cookie);\nint cma_get_default_gid_type(struct cma_device *dev, u32 port);\nint cma_set_default_gid_type(struct cma_device *dev, u32 port,\n\t\t\t     enum ib_gid_type default_gid_type);\nint cma_get_default_roce_tos(struct cma_device *dev, u32 port);\nint cma_set_default_roce_tos(struct cma_device *dev, u32 port,\n\t\t\t     u8 default_roce_tos);\nstruct ib_device *cma_get_ib_dev(struct cma_device *dev);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}