{
  "module_name": "netlink.c",
  "hash_id": "9f44d8ed9c110d983f37c3bc43906bbcad8045a1a45b0ac4ef65307cb3fe43ea",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/core/netlink.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) \"%s:%s: \" fmt, KBUILD_MODNAME, __func__\n\n#include <linux/export.h>\n#include <net/netlink.h>\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n#include <net/sock.h>\n#include <rdma/rdma_netlink.h>\n#include <linux/module.h>\n#include \"core_priv.h\"\n\nstatic struct {\n\tconst struct rdma_nl_cbs *cb_table;\n\t \n\tstruct rw_semaphore sem;\n} rdma_nl_types[RDMA_NL_NUM_CLIENTS];\n\nbool rdma_nl_chk_listeners(unsigned int group)\n{\n\tstruct rdma_dev_net *rnet = rdma_net_to_dev_net(&init_net);\n\n\treturn netlink_has_listeners(rnet->nl_sock, group);\n}\nEXPORT_SYMBOL(rdma_nl_chk_listeners);\n\nstatic bool is_nl_msg_valid(unsigned int type, unsigned int op)\n{\n\tstatic const unsigned int max_num_ops[RDMA_NL_NUM_CLIENTS] = {\n\t\t[RDMA_NL_IWCM] = RDMA_NL_IWPM_NUM_OPS,\n\t\t[RDMA_NL_LS] = RDMA_NL_LS_NUM_OPS,\n\t\t[RDMA_NL_NLDEV] = RDMA_NLDEV_NUM_OPS,\n\t};\n\n\t \n\tBUILD_BUG_ON(RDMA_NL_NUM_CLIENTS != 6);\n\n\tif (type >= RDMA_NL_NUM_CLIENTS)\n\t\treturn false;\n\n\treturn op < max_num_ops[type];\n}\n\nstatic const struct rdma_nl_cbs *\nget_cb_table(const struct sk_buff *skb, unsigned int type, unsigned int op)\n{\n\tconst struct rdma_nl_cbs *cb_table;\n\n\t \n\tif (sock_net(skb->sk) != &init_net && type != RDMA_NL_NLDEV)\n\t\treturn NULL;\n\n\tcb_table = READ_ONCE(rdma_nl_types[type].cb_table);\n\tif (!cb_table) {\n\t\t \n\t\tup_read(&rdma_nl_types[type].sem);\n\n\t\trequest_module(\"rdma-netlink-subsys-%u\", type);\n\n\t\tdown_read(&rdma_nl_types[type].sem);\n\t\tcb_table = READ_ONCE(rdma_nl_types[type].cb_table);\n\t}\n\tif (!cb_table || (!cb_table[op].dump && !cb_table[op].doit))\n\t\treturn NULL;\n\treturn cb_table;\n}\n\nvoid rdma_nl_register(unsigned int index,\n\t\t      const struct rdma_nl_cbs cb_table[])\n{\n\tif (WARN_ON(!is_nl_msg_valid(index, 0)) ||\n\t    WARN_ON(READ_ONCE(rdma_nl_types[index].cb_table)))\n\t\treturn;\n\n\t \n\tsmp_store_release(&rdma_nl_types[index].cb_table, cb_table);\n}\nEXPORT_SYMBOL(rdma_nl_register);\n\nvoid rdma_nl_unregister(unsigned int index)\n{\n\tdown_write(&rdma_nl_types[index].sem);\n\trdma_nl_types[index].cb_table = NULL;\n\tup_write(&rdma_nl_types[index].sem);\n}\nEXPORT_SYMBOL(rdma_nl_unregister);\n\nvoid *ibnl_put_msg(struct sk_buff *skb, struct nlmsghdr **nlh, int seq,\n\t\t   int len, int client, int op, int flags)\n{\n\t*nlh = nlmsg_put(skb, 0, seq, RDMA_NL_GET_TYPE(client, op), len, flags);\n\tif (!*nlh)\n\t\treturn NULL;\n\treturn nlmsg_data(*nlh);\n}\nEXPORT_SYMBOL(ibnl_put_msg);\n\nint ibnl_put_attr(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t  int len, void *data, int type)\n{\n\tif (nla_put(skb, type, len, data)) {\n\t\tnlmsg_cancel(skb, nlh);\n\t\treturn -EMSGSIZE;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(ibnl_put_attr);\n\nstatic int rdma_nl_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tint type = nlh->nlmsg_type;\n\tunsigned int index = RDMA_NL_GET_CLIENT(type);\n\tunsigned int op = RDMA_NL_GET_OP(type);\n\tconst struct rdma_nl_cbs *cb_table;\n\tint err = -EINVAL;\n\n\tif (!is_nl_msg_valid(index, op))\n\t\treturn -EINVAL;\n\n\tdown_read(&rdma_nl_types[index].sem);\n\tcb_table = get_cb_table(skb, index, op);\n\tif (!cb_table)\n\t\tgoto done;\n\n\tif ((cb_table[op].flags & RDMA_NL_ADMIN_PERM) &&\n\t    !netlink_capable(skb, CAP_NET_ADMIN)) {\n\t\terr = -EPERM;\n\t\tgoto done;\n\t}\n\n\t \n\tif (index == RDMA_NL_LS) {\n\t\tif (cb_table[op].doit)\n\t\t\terr = cb_table[op].doit(skb, nlh, extack);\n\t\tgoto done;\n\t}\n\t \n\tif ((nlh->nlmsg_flags & NLM_F_DUMP) || index == RDMA_NL_IWCM) {\n\t\tstruct netlink_dump_control c = {\n\t\t\t.dump = cb_table[op].dump,\n\t\t};\n\t\tif (c.dump)\n\t\t\terr = netlink_dump_start(skb->sk, skb, nlh, &c);\n\t\tgoto done;\n\t}\n\n\tif (cb_table[op].doit)\n\t\terr = cb_table[op].doit(skb, nlh, extack);\ndone:\n\tup_read(&rdma_nl_types[index].sem);\n\treturn err;\n}\n\n \nstatic int rdma_nl_rcv_skb(struct sk_buff *skb, int (*cb)(struct sk_buff *,\n\t\t\t\t\t\t   struct nlmsghdr *,\n\t\t\t\t\t\t   struct netlink_ext_ack *))\n{\n\tstruct netlink_ext_ack extack = {};\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\twhile (skb->len >= nlmsg_total_size(0)) {\n\t\tint msglen;\n\n\t\tnlh = nlmsg_hdr(skb);\n\t\terr = 0;\n\n\t\tif (nlh->nlmsg_len < NLMSG_HDRLEN || skb->len < nlh->nlmsg_len)\n\t\t\treturn 0;\n\n\t\t \n\t\tif (!(nlh->nlmsg_flags & NLM_F_REQUEST) &&\n\t\t    (RDMA_NL_GET_CLIENT(nlh->nlmsg_type) != RDMA_NL_LS))\n\t\t\tgoto ack;\n\n\t\t \n\t\tif (nlh->nlmsg_type < NLMSG_MIN_TYPE)\n\t\t\tgoto ack;\n\n\t\terr = cb(skb, nlh, &extack);\n\t\tif (err == -EINTR)\n\t\t\tgoto skip;\n\nack:\n\t\tif (nlh->nlmsg_flags & NLM_F_ACK || err)\n\t\t\tnetlink_ack(skb, nlh, err, &extack);\n\nskip:\n\t\tmsglen = NLMSG_ALIGN(nlh->nlmsg_len);\n\t\tif (msglen > skb->len)\n\t\t\tmsglen = skb->len;\n\t\tskb_pull(skb, msglen);\n\t}\n\n\treturn 0;\n}\n\nstatic void rdma_nl_rcv(struct sk_buff *skb)\n{\n\trdma_nl_rcv_skb(skb, &rdma_nl_rcv_msg);\n}\n\nint rdma_nl_unicast(struct net *net, struct sk_buff *skb, u32 pid)\n{\n\tstruct rdma_dev_net *rnet = rdma_net_to_dev_net(net);\n\tint err;\n\n\terr = netlink_unicast(rnet->nl_sock, skb, pid, MSG_DONTWAIT);\n\treturn (err < 0) ? err : 0;\n}\nEXPORT_SYMBOL(rdma_nl_unicast);\n\nint rdma_nl_unicast_wait(struct net *net, struct sk_buff *skb, __u32 pid)\n{\n\tstruct rdma_dev_net *rnet = rdma_net_to_dev_net(net);\n\tint err;\n\n\terr = netlink_unicast(rnet->nl_sock, skb, pid, 0);\n\treturn (err < 0) ? err : 0;\n}\nEXPORT_SYMBOL(rdma_nl_unicast_wait);\n\nint rdma_nl_multicast(struct net *net, struct sk_buff *skb,\n\t\t      unsigned int group, gfp_t flags)\n{\n\tstruct rdma_dev_net *rnet = rdma_net_to_dev_net(net);\n\n\treturn nlmsg_multicast(rnet->nl_sock, skb, 0, group, flags);\n}\nEXPORT_SYMBOL(rdma_nl_multicast);\n\nvoid rdma_nl_init(void)\n{\n\tint idx;\n\n\tfor (idx = 0; idx < RDMA_NL_NUM_CLIENTS; idx++)\n\t\tinit_rwsem(&rdma_nl_types[idx].sem);\n}\n\nvoid rdma_nl_exit(void)\n{\n\tint idx;\n\n\tfor (idx = 0; idx < RDMA_NL_NUM_CLIENTS; idx++)\n\t\tWARN(rdma_nl_types[idx].cb_table,\n\t\t     \"Netlink client %d wasn't released prior to unloading %s\\n\",\n\t\t     idx, KBUILD_MODNAME);\n}\n\nint rdma_nl_net_init(struct rdma_dev_net *rnet)\n{\n\tstruct net *net = read_pnet(&rnet->net);\n\tstruct netlink_kernel_cfg cfg = {\n\t\t.input\t= rdma_nl_rcv,\n\t};\n\tstruct sock *nls;\n\n\tnls = netlink_kernel_create(net, NETLINK_RDMA, &cfg);\n\tif (!nls)\n\t\treturn -ENOMEM;\n\n\tnls->sk_sndtimeo = 10 * HZ;\n\trnet->nl_sock = nls;\n\treturn 0;\n}\n\nvoid rdma_nl_net_exit(struct rdma_dev_net *rnet)\n{\n\tnetlink_kernel_release(rnet->nl_sock);\n}\n\nMODULE_ALIAS_NET_PF_PROTO(PF_NETLINK, NETLINK_RDMA);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}