{
  "module_name": "iwpm_msg.c",
  "hash_id": "183f27a6d6cec9fdbde457f5145a5832f457ebf52d9b48343f11c38d85d75926",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/core/iwpm_msg.c",
  "human_readable_source": " \n\n#include \"iwpm_util.h\"\n\nstatic const char iwpm_ulib_name[IWPM_ULIBNAME_SIZE] = \"iWarpPortMapperUser\";\nu16 iwpm_ulib_version = IWPM_UABI_VERSION_MIN;\nstatic int iwpm_user_pid = IWPM_PID_UNDEFINED;\nstatic atomic_t echo_nlmsg_seq;\n\n \nint iwpm_valid_pid(void)\n{\n\treturn iwpm_user_pid > 0;\n}\n\n \nint iwpm_register_pid(struct iwpm_dev_data *pm_msg, u8 nl_client)\n{\n\tstruct sk_buff *skb = NULL;\n\tstruct iwpm_nlmsg_request *nlmsg_request = NULL;\n\tstruct nlmsghdr *nlh;\n\tu32 msg_seq;\n\tconst char *err_str = \"\";\n\tint ret = -EINVAL;\n\n\tif (iwpm_check_registration(nl_client, IWPM_REG_VALID) ||\n\t\t\tiwpm_user_pid == IWPM_PID_UNAVAILABLE)\n\t\treturn 0;\n\tskb = iwpm_create_nlmsg(RDMA_NL_IWPM_REG_PID, &nlh, nl_client);\n\tif (!skb) {\n\t\terr_str = \"Unable to create a nlmsg\";\n\t\tgoto pid_query_error;\n\t}\n\tnlh->nlmsg_seq = iwpm_get_nlmsg_seq();\n\tnlmsg_request = iwpm_get_nlmsg_request(nlh->nlmsg_seq, nl_client, GFP_KERNEL);\n\tif (!nlmsg_request) {\n\t\terr_str = \"Unable to allocate netlink request\";\n\t\tgoto pid_query_error;\n\t}\n\tmsg_seq = atomic_read(&echo_nlmsg_seq);\n\n\t \n\terr_str = \"Unable to put attribute of the nlmsg\";\n\tret = ibnl_put_attr(skb, nlh, sizeof(u32), &msg_seq, IWPM_NLA_REG_PID_SEQ);\n\tif (ret)\n\t\tgoto pid_query_error;\n\tret = ibnl_put_attr(skb, nlh, IFNAMSIZ,\n\t\t\t    pm_msg->if_name, IWPM_NLA_REG_IF_NAME);\n\tif (ret)\n\t\tgoto pid_query_error;\n\tret = ibnl_put_attr(skb, nlh, IWPM_DEVNAME_SIZE,\n\t\t\t\tpm_msg->dev_name, IWPM_NLA_REG_IBDEV_NAME);\n\tif (ret)\n\t\tgoto pid_query_error;\n\tret = ibnl_put_attr(skb, nlh, IWPM_ULIBNAME_SIZE,\n\t\t\t\t(char *)iwpm_ulib_name, IWPM_NLA_REG_ULIB_NAME);\n\tif (ret)\n\t\tgoto pid_query_error;\n\n\tnlmsg_end(skb, nlh);\n\n\tpr_debug(\"%s: Multicasting a nlmsg (dev = %s ifname = %s iwpm = %s)\\n\",\n\t\t__func__, pm_msg->dev_name, pm_msg->if_name, iwpm_ulib_name);\n\n\tret = rdma_nl_multicast(&init_net, skb, RDMA_NL_GROUP_IWPM, GFP_KERNEL);\n\tif (ret) {\n\t\tskb = NULL;  \n\t\tiwpm_user_pid = IWPM_PID_UNAVAILABLE;\n\t\terr_str = \"Unable to send a nlmsg\";\n\t\tgoto pid_query_error;\n\t}\n\tnlmsg_request->req_buffer = pm_msg;\n\tret = iwpm_wait_complete_req(nlmsg_request);\n\treturn ret;\npid_query_error:\n\tpr_info(\"%s: %s (client = %u)\\n\", __func__, err_str, nl_client);\n\tdev_kfree_skb(skb);\n\tif (nlmsg_request)\n\t\tiwpm_free_nlmsg_request(&nlmsg_request->kref);\n\treturn ret;\n}\n\n \nint iwpm_add_mapping(struct iwpm_sa_data *pm_msg, u8 nl_client)\n{\n\tstruct sk_buff *skb = NULL;\n\tstruct iwpm_nlmsg_request *nlmsg_request = NULL;\n\tstruct nlmsghdr *nlh;\n\tu32 msg_seq;\n\tconst char *err_str = \"\";\n\tint ret = -EINVAL;\n\n\tif (!iwpm_valid_pid())\n\t\treturn 0;\n\tif (!iwpm_check_registration(nl_client, IWPM_REG_VALID)) {\n\t\terr_str = \"Unregistered port mapper client\";\n\t\tgoto add_mapping_error;\n\t}\n\tskb = iwpm_create_nlmsg(RDMA_NL_IWPM_ADD_MAPPING, &nlh, nl_client);\n\tif (!skb) {\n\t\terr_str = \"Unable to create a nlmsg\";\n\t\tgoto add_mapping_error;\n\t}\n\tnlh->nlmsg_seq = iwpm_get_nlmsg_seq();\n\tnlmsg_request = iwpm_get_nlmsg_request(nlh->nlmsg_seq, nl_client, GFP_KERNEL);\n\tif (!nlmsg_request) {\n\t\terr_str = \"Unable to allocate netlink request\";\n\t\tgoto add_mapping_error;\n\t}\n\tmsg_seq = atomic_read(&echo_nlmsg_seq);\n\t \n\terr_str = \"Unable to put attribute of the nlmsg\";\n\tret = ibnl_put_attr(skb, nlh, sizeof(u32), &msg_seq,\n\t\t\t\tIWPM_NLA_MANAGE_MAPPING_SEQ);\n\tif (ret)\n\t\tgoto add_mapping_error;\n\tret = ibnl_put_attr(skb, nlh, sizeof(struct sockaddr_storage),\n\t\t\t\t&pm_msg->loc_addr, IWPM_NLA_MANAGE_ADDR);\n\tif (ret)\n\t\tgoto add_mapping_error;\n\n\t \n\tif (pm_msg->flags && iwpm_ulib_version == IWPM_UABI_VERSION_MIN) {\n\t\tret = -EINVAL;\n\t\tgoto add_mapping_error_nowarn;\n\t}\n\tif (iwpm_ulib_version > IWPM_UABI_VERSION_MIN) {\n\t\tret = ibnl_put_attr(skb, nlh, sizeof(u32), &pm_msg->flags,\n\t\t\t\tIWPM_NLA_MANAGE_FLAGS);\n\t\tif (ret)\n\t\t\tgoto add_mapping_error;\n\t}\n\n\tnlmsg_end(skb, nlh);\n\tnlmsg_request->req_buffer = pm_msg;\n\n\tret = rdma_nl_unicast_wait(&init_net, skb, iwpm_user_pid);\n\tif (ret) {\n\t\tskb = NULL;  \n\t\tiwpm_user_pid = IWPM_PID_UNDEFINED;\n\t\terr_str = \"Unable to send a nlmsg\";\n\t\tgoto add_mapping_error;\n\t}\n\tret = iwpm_wait_complete_req(nlmsg_request);\n\treturn ret;\nadd_mapping_error:\n\tpr_info(\"%s: %s (client = %u)\\n\", __func__, err_str, nl_client);\nadd_mapping_error_nowarn:\n\tdev_kfree_skb(skb);\n\tif (nlmsg_request)\n\t\tiwpm_free_nlmsg_request(&nlmsg_request->kref);\n\treturn ret;\n}\n\n \nint iwpm_add_and_query_mapping(struct iwpm_sa_data *pm_msg, u8 nl_client)\n{\n\tstruct sk_buff *skb = NULL;\n\tstruct iwpm_nlmsg_request *nlmsg_request = NULL;\n\tstruct nlmsghdr *nlh;\n\tu32 msg_seq;\n\tconst char *err_str = \"\";\n\tint ret = -EINVAL;\n\n\tif (!iwpm_valid_pid())\n\t\treturn 0;\n\tif (!iwpm_check_registration(nl_client, IWPM_REG_VALID)) {\n\t\terr_str = \"Unregistered port mapper client\";\n\t\tgoto query_mapping_error;\n\t}\n\tret = -ENOMEM;\n\tskb = iwpm_create_nlmsg(RDMA_NL_IWPM_QUERY_MAPPING, &nlh, nl_client);\n\tif (!skb) {\n\t\terr_str = \"Unable to create a nlmsg\";\n\t\tgoto query_mapping_error;\n\t}\n\tnlh->nlmsg_seq = iwpm_get_nlmsg_seq();\n\tnlmsg_request = iwpm_get_nlmsg_request(nlh->nlmsg_seq,\n\t\t\t\tnl_client, GFP_KERNEL);\n\tif (!nlmsg_request) {\n\t\terr_str = \"Unable to allocate netlink request\";\n\t\tgoto query_mapping_error;\n\t}\n\tmsg_seq = atomic_read(&echo_nlmsg_seq);\n\n\t \n\terr_str = \"Unable to put attribute of the nlmsg\";\n\tret = ibnl_put_attr(skb, nlh, sizeof(u32), &msg_seq,\n\t\t\t\tIWPM_NLA_QUERY_MAPPING_SEQ);\n\tif (ret)\n\t\tgoto query_mapping_error;\n\tret = ibnl_put_attr(skb, nlh, sizeof(struct sockaddr_storage),\n\t\t\t\t&pm_msg->loc_addr, IWPM_NLA_QUERY_LOCAL_ADDR);\n\tif (ret)\n\t\tgoto query_mapping_error;\n\tret = ibnl_put_attr(skb, nlh, sizeof(struct sockaddr_storage),\n\t\t\t\t&pm_msg->rem_addr, IWPM_NLA_QUERY_REMOTE_ADDR);\n\tif (ret)\n\t\tgoto query_mapping_error;\n\n\t \n\tif (pm_msg->flags && iwpm_ulib_version == IWPM_UABI_VERSION_MIN) {\n\t\tret = -EINVAL;\n\t\tgoto query_mapping_error_nowarn;\n\t}\n\tif (iwpm_ulib_version > IWPM_UABI_VERSION_MIN) {\n\t\tret = ibnl_put_attr(skb, nlh, sizeof(u32), &pm_msg->flags,\n\t\t\t\tIWPM_NLA_QUERY_FLAGS);\n\t\tif (ret)\n\t\t\tgoto query_mapping_error;\n\t}\n\n\tnlmsg_end(skb, nlh);\n\tnlmsg_request->req_buffer = pm_msg;\n\n\tret = rdma_nl_unicast_wait(&init_net, skb, iwpm_user_pid);\n\tif (ret) {\n\t\tskb = NULL;  \n\t\terr_str = \"Unable to send a nlmsg\";\n\t\tgoto query_mapping_error;\n\t}\n\tret = iwpm_wait_complete_req(nlmsg_request);\n\treturn ret;\nquery_mapping_error:\n\tpr_info(\"%s: %s (client = %u)\\n\", __func__, err_str, nl_client);\nquery_mapping_error_nowarn:\n\tdev_kfree_skb(skb);\n\tif (nlmsg_request)\n\t\tiwpm_free_nlmsg_request(&nlmsg_request->kref);\n\treturn ret;\n}\n\n \nint iwpm_remove_mapping(struct sockaddr_storage *local_addr, u8 nl_client)\n{\n\tstruct sk_buff *skb = NULL;\n\tstruct nlmsghdr *nlh;\n\tu32 msg_seq;\n\tconst char *err_str = \"\";\n\tint ret = -EINVAL;\n\n\tif (!iwpm_valid_pid())\n\t\treturn 0;\n\tif (iwpm_check_registration(nl_client, IWPM_REG_UNDEF)) {\n\t\terr_str = \"Unregistered port mapper client\";\n\t\tgoto remove_mapping_error;\n\t}\n\tskb = iwpm_create_nlmsg(RDMA_NL_IWPM_REMOVE_MAPPING, &nlh, nl_client);\n\tif (!skb) {\n\t\tret = -ENOMEM;\n\t\terr_str = \"Unable to create a nlmsg\";\n\t\tgoto remove_mapping_error;\n\t}\n\tmsg_seq = atomic_read(&echo_nlmsg_seq);\n\tnlh->nlmsg_seq = iwpm_get_nlmsg_seq();\n\terr_str = \"Unable to put attribute of the nlmsg\";\n\tret = ibnl_put_attr(skb, nlh, sizeof(u32), &msg_seq,\n\t\t\t\tIWPM_NLA_MANAGE_MAPPING_SEQ);\n\tif (ret)\n\t\tgoto remove_mapping_error;\n\tret = ibnl_put_attr(skb, nlh, sizeof(struct sockaddr_storage),\n\t\t\t\tlocal_addr, IWPM_NLA_MANAGE_ADDR);\n\tif (ret)\n\t\tgoto remove_mapping_error;\n\n\tnlmsg_end(skb, nlh);\n\n\tret = rdma_nl_unicast_wait(&init_net, skb, iwpm_user_pid);\n\tif (ret) {\n\t\tskb = NULL;  \n\t\tiwpm_user_pid = IWPM_PID_UNDEFINED;\n\t\terr_str = \"Unable to send a nlmsg\";\n\t\tgoto remove_mapping_error;\n\t}\n\tiwpm_print_sockaddr(local_addr,\n\t\t\t\"remove_mapping: Local sockaddr:\");\n\treturn 0;\nremove_mapping_error:\n\tpr_info(\"%s: %s (client = %u)\\n\", __func__, err_str, nl_client);\n\tif (skb)\n\t\tdev_kfree_skb_any(skb);\n\treturn ret;\n}\n\n \nstatic const struct nla_policy resp_reg_policy[IWPM_NLA_RREG_PID_MAX] = {\n\t[IWPM_NLA_RREG_PID_SEQ]     = { .type = NLA_U32 },\n\t[IWPM_NLA_RREG_IBDEV_NAME]  = { .type = NLA_STRING,\n\t\t\t\t\t.len = IWPM_DEVNAME_SIZE - 1 },\n\t[IWPM_NLA_RREG_ULIB_NAME]   = { .type = NLA_STRING,\n\t\t\t\t\t.len = IWPM_ULIBNAME_SIZE - 1 },\n\t[IWPM_NLA_RREG_ULIB_VER]    = { .type = NLA_U16 },\n\t[IWPM_NLA_RREG_PID_ERR]     = { .type = NLA_U16 }\n};\n\n \nint iwpm_register_pid_cb(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct iwpm_nlmsg_request *nlmsg_request = NULL;\n\tstruct nlattr *nltb[IWPM_NLA_RREG_PID_MAX];\n\tstruct iwpm_dev_data *pm_msg;\n\tchar *dev_name, *iwpm_name;\n\tu32 msg_seq;\n\tu8 nl_client;\n\tu16 iwpm_version;\n\tconst char *msg_type = \"Register Pid response\";\n\n\tif (iwpm_parse_nlmsg(cb, IWPM_NLA_RREG_PID_MAX,\n\t\t\t\tresp_reg_policy, nltb, msg_type))\n\t\treturn -EINVAL;\n\n\tmsg_seq = nla_get_u32(nltb[IWPM_NLA_RREG_PID_SEQ]);\n\tnlmsg_request = iwpm_find_nlmsg_request(msg_seq);\n\tif (!nlmsg_request) {\n\t\tpr_info(\"%s: Could not find a matching request (seq = %u)\\n\",\n\t\t\t\t __func__, msg_seq);\n\t\treturn -EINVAL;\n\t}\n\tpm_msg = nlmsg_request->req_buffer;\n\tnl_client = nlmsg_request->nl_client;\n\tdev_name = (char *)nla_data(nltb[IWPM_NLA_RREG_IBDEV_NAME]);\n\tiwpm_name = (char *)nla_data(nltb[IWPM_NLA_RREG_ULIB_NAME]);\n\tiwpm_version = nla_get_u16(nltb[IWPM_NLA_RREG_ULIB_VER]);\n\n\t \n\tif (strcmp(pm_msg->dev_name, dev_name) ||\n\t\t\tstrcmp(iwpm_ulib_name, iwpm_name) ||\n\t\t\tiwpm_version < IWPM_UABI_VERSION_MIN) {\n\n\t\tpr_info(\"%s: Incorrect info (dev = %s name = %s version = %u)\\n\",\n\t\t\t\t__func__, dev_name, iwpm_name, iwpm_version);\n\t\tnlmsg_request->err_code = IWPM_USER_LIB_INFO_ERR;\n\t\tgoto register_pid_response_exit;\n\t}\n\tiwpm_user_pid = cb->nlh->nlmsg_pid;\n\tiwpm_ulib_version = iwpm_version;\n\tif (iwpm_ulib_version < IWPM_UABI_VERSION)\n\t\tpr_warn_once(\"%s: Down level iwpmd/pid %d.  Continuing...\",\n\t\t\t__func__, iwpm_user_pid);\n\tatomic_set(&echo_nlmsg_seq, cb->nlh->nlmsg_seq);\n\tpr_debug(\"%s: iWarp Port Mapper (pid = %d) is available!\\n\",\n\t\t\t__func__, iwpm_user_pid);\n\tiwpm_set_registration(nl_client, IWPM_REG_VALID);\nregister_pid_response_exit:\n\tnlmsg_request->request_done = 1;\n\t \n\tkref_put(&nlmsg_request->kref, iwpm_free_nlmsg_request);\n\tbarrier();\n\tup(&nlmsg_request->sem);\n\treturn 0;\n}\n\n \nstatic const struct nla_policy resp_add_policy[IWPM_NLA_RMANAGE_MAPPING_MAX] = {\n\t[IWPM_NLA_RMANAGE_MAPPING_SEQ]     = { .type = NLA_U32 },\n\t[IWPM_NLA_RMANAGE_ADDR]            = {\n\t\t\t\t.len = sizeof(struct sockaddr_storage) },\n\t[IWPM_NLA_RMANAGE_MAPPED_LOC_ADDR] = {\n\t\t\t\t.len = sizeof(struct sockaddr_storage) },\n\t[IWPM_NLA_RMANAGE_MAPPING_ERR]\t   = { .type = NLA_U16 }\n};\n\n \nint iwpm_add_mapping_cb(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct iwpm_sa_data *pm_msg;\n\tstruct iwpm_nlmsg_request *nlmsg_request = NULL;\n\tstruct nlattr *nltb[IWPM_NLA_RMANAGE_MAPPING_MAX];\n\tstruct sockaddr_storage *local_sockaddr;\n\tstruct sockaddr_storage *mapped_sockaddr;\n\tconst char *msg_type;\n\tu32 msg_seq;\n\n\tmsg_type = \"Add Mapping response\";\n\tif (iwpm_parse_nlmsg(cb, IWPM_NLA_RMANAGE_MAPPING_MAX,\n\t\t\t\tresp_add_policy, nltb, msg_type))\n\t\treturn -EINVAL;\n\n\tatomic_set(&echo_nlmsg_seq, cb->nlh->nlmsg_seq);\n\n\tmsg_seq = nla_get_u32(nltb[IWPM_NLA_RMANAGE_MAPPING_SEQ]);\n\tnlmsg_request = iwpm_find_nlmsg_request(msg_seq);\n\tif (!nlmsg_request) {\n\t\tpr_info(\"%s: Could not find a matching request (seq = %u)\\n\",\n\t\t\t\t __func__, msg_seq);\n\t\treturn -EINVAL;\n\t}\n\tpm_msg = nlmsg_request->req_buffer;\n\tlocal_sockaddr = (struct sockaddr_storage *)\n\t\t\tnla_data(nltb[IWPM_NLA_RMANAGE_ADDR]);\n\tmapped_sockaddr = (struct sockaddr_storage *)\n\t\t\tnla_data(nltb[IWPM_NLA_RMANAGE_MAPPED_LOC_ADDR]);\n\n\tif (iwpm_compare_sockaddr(local_sockaddr, &pm_msg->loc_addr)) {\n\t\tnlmsg_request->err_code = IWPM_USER_LIB_INFO_ERR;\n\t\tgoto add_mapping_response_exit;\n\t}\n\tif (mapped_sockaddr->ss_family != local_sockaddr->ss_family) {\n\t\tpr_info(\"%s: Sockaddr family doesn't match the requested one\\n\",\n\t\t\t\t__func__);\n\t\tnlmsg_request->err_code = IWPM_USER_LIB_INFO_ERR;\n\t\tgoto add_mapping_response_exit;\n\t}\n\tmemcpy(&pm_msg->mapped_loc_addr, mapped_sockaddr,\n\t\t\tsizeof(*mapped_sockaddr));\n\tiwpm_print_sockaddr(&pm_msg->loc_addr,\n\t\t\t\"add_mapping: Local sockaddr:\");\n\tiwpm_print_sockaddr(&pm_msg->mapped_loc_addr,\n\t\t\t\"add_mapping: Mapped local sockaddr:\");\n\nadd_mapping_response_exit:\n\tnlmsg_request->request_done = 1;\n\t \n\tkref_put(&nlmsg_request->kref, iwpm_free_nlmsg_request);\n\tbarrier();\n\tup(&nlmsg_request->sem);\n\treturn 0;\n}\n\n \nstatic const struct nla_policy resp_query_policy[IWPM_NLA_RQUERY_MAPPING_MAX] = {\n\t[IWPM_NLA_RQUERY_MAPPING_SEQ]     = { .type = NLA_U32 },\n\t[IWPM_NLA_RQUERY_LOCAL_ADDR]      = {\n\t\t\t\t.len = sizeof(struct sockaddr_storage) },\n\t[IWPM_NLA_RQUERY_REMOTE_ADDR]     = {\n\t\t\t\t.len = sizeof(struct sockaddr_storage) },\n\t[IWPM_NLA_RQUERY_MAPPED_LOC_ADDR] = {\n\t\t\t\t.len = sizeof(struct sockaddr_storage) },\n\t[IWPM_NLA_RQUERY_MAPPED_REM_ADDR] = {\n\t\t\t\t.len = sizeof(struct sockaddr_storage) },\n\t[IWPM_NLA_RQUERY_MAPPING_ERR]\t  = { .type = NLA_U16 }\n};\n\n \nint iwpm_add_and_query_mapping_cb(struct sk_buff *skb,\n\t\t\t\tstruct netlink_callback *cb)\n{\n\tstruct iwpm_sa_data *pm_msg;\n\tstruct iwpm_nlmsg_request *nlmsg_request = NULL;\n\tstruct nlattr *nltb[IWPM_NLA_RQUERY_MAPPING_MAX];\n\tstruct sockaddr_storage *local_sockaddr, *remote_sockaddr;\n\tstruct sockaddr_storage *mapped_loc_sockaddr, *mapped_rem_sockaddr;\n\tconst char *msg_type;\n\tu32 msg_seq;\n\tu16 err_code;\n\n\tmsg_type = \"Query Mapping response\";\n\tif (iwpm_parse_nlmsg(cb, IWPM_NLA_RQUERY_MAPPING_MAX,\n\t\t\t\tresp_query_policy, nltb, msg_type))\n\t\treturn -EINVAL;\n\tatomic_set(&echo_nlmsg_seq, cb->nlh->nlmsg_seq);\n\n\tmsg_seq = nla_get_u32(nltb[IWPM_NLA_RQUERY_MAPPING_SEQ]);\n\tnlmsg_request = iwpm_find_nlmsg_request(msg_seq);\n\tif (!nlmsg_request) {\n\t\tpr_info(\"%s: Could not find a matching request (seq = %u)\\n\",\n\t\t\t\t __func__, msg_seq);\n\t\treturn -EINVAL;\n\t}\n\tpm_msg = nlmsg_request->req_buffer;\n\tlocal_sockaddr = (struct sockaddr_storage *)\n\t\t\tnla_data(nltb[IWPM_NLA_RQUERY_LOCAL_ADDR]);\n\tremote_sockaddr = (struct sockaddr_storage *)\n\t\t\tnla_data(nltb[IWPM_NLA_RQUERY_REMOTE_ADDR]);\n\tmapped_loc_sockaddr = (struct sockaddr_storage *)\n\t\t\tnla_data(nltb[IWPM_NLA_RQUERY_MAPPED_LOC_ADDR]);\n\tmapped_rem_sockaddr = (struct sockaddr_storage *)\n\t\t\tnla_data(nltb[IWPM_NLA_RQUERY_MAPPED_REM_ADDR]);\n\n\terr_code = nla_get_u16(nltb[IWPM_NLA_RQUERY_MAPPING_ERR]);\n\tif (err_code == IWPM_REMOTE_QUERY_REJECT) {\n\t\tpr_info(\"%s: Received a Reject (pid = %u, echo seq = %u)\\n\",\n\t\t\t__func__, cb->nlh->nlmsg_pid, msg_seq);\n\t\tnlmsg_request->err_code = IWPM_REMOTE_QUERY_REJECT;\n\t}\n\tif (iwpm_compare_sockaddr(local_sockaddr, &pm_msg->loc_addr) ||\n\t\tiwpm_compare_sockaddr(remote_sockaddr, &pm_msg->rem_addr)) {\n\t\tpr_info(\"%s: Incorrect local sockaddr\\n\", __func__);\n\t\tnlmsg_request->err_code = IWPM_USER_LIB_INFO_ERR;\n\t\tgoto query_mapping_response_exit;\n\t}\n\tif (mapped_loc_sockaddr->ss_family != local_sockaddr->ss_family ||\n\t\tmapped_rem_sockaddr->ss_family != remote_sockaddr->ss_family) {\n\t\tpr_info(\"%s: Sockaddr family doesn't match the requested one\\n\",\n\t\t\t\t__func__);\n\t\tnlmsg_request->err_code = IWPM_USER_LIB_INFO_ERR;\n\t\tgoto query_mapping_response_exit;\n\t}\n\tmemcpy(&pm_msg->mapped_loc_addr, mapped_loc_sockaddr,\n\t\t\tsizeof(*mapped_loc_sockaddr));\n\tmemcpy(&pm_msg->mapped_rem_addr, mapped_rem_sockaddr,\n\t\t\tsizeof(*mapped_rem_sockaddr));\n\n\tiwpm_print_sockaddr(&pm_msg->loc_addr,\n\t\t\t\"query_mapping: Local sockaddr:\");\n\tiwpm_print_sockaddr(&pm_msg->mapped_loc_addr,\n\t\t\t\"query_mapping: Mapped local sockaddr:\");\n\tiwpm_print_sockaddr(&pm_msg->rem_addr,\n\t\t\t\"query_mapping: Remote sockaddr:\");\n\tiwpm_print_sockaddr(&pm_msg->mapped_rem_addr,\n\t\t\t\"query_mapping: Mapped remote sockaddr:\");\nquery_mapping_response_exit:\n\tnlmsg_request->request_done = 1;\n\t \n\tkref_put(&nlmsg_request->kref, iwpm_free_nlmsg_request);\n\tbarrier();\n\tup(&nlmsg_request->sem);\n\treturn 0;\n}\n\n \nint iwpm_remote_info_cb(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct nlattr *nltb[IWPM_NLA_RQUERY_MAPPING_MAX];\n\tstruct sockaddr_storage *local_sockaddr, *remote_sockaddr;\n\tstruct sockaddr_storage *mapped_loc_sockaddr, *mapped_rem_sockaddr;\n\tstruct iwpm_remote_info *rem_info;\n\tconst char *msg_type;\n\tu8 nl_client;\n\tint ret = -EINVAL;\n\n\tmsg_type = \"Remote Mapping info\";\n\tif (iwpm_parse_nlmsg(cb, IWPM_NLA_RQUERY_MAPPING_MAX,\n\t\t\t\tresp_query_policy, nltb, msg_type))\n\t\treturn ret;\n\n\tnl_client = RDMA_NL_GET_CLIENT(cb->nlh->nlmsg_type);\n\tatomic_set(&echo_nlmsg_seq, cb->nlh->nlmsg_seq);\n\n\tlocal_sockaddr = (struct sockaddr_storage *)\n\t\t\tnla_data(nltb[IWPM_NLA_RQUERY_LOCAL_ADDR]);\n\tremote_sockaddr = (struct sockaddr_storage *)\n\t\t\tnla_data(nltb[IWPM_NLA_RQUERY_REMOTE_ADDR]);\n\tmapped_loc_sockaddr = (struct sockaddr_storage *)\n\t\t\tnla_data(nltb[IWPM_NLA_RQUERY_MAPPED_LOC_ADDR]);\n\tmapped_rem_sockaddr = (struct sockaddr_storage *)\n\t\t\tnla_data(nltb[IWPM_NLA_RQUERY_MAPPED_REM_ADDR]);\n\n\tif (mapped_loc_sockaddr->ss_family != local_sockaddr->ss_family ||\n\t\tmapped_rem_sockaddr->ss_family != remote_sockaddr->ss_family) {\n\t\tpr_info(\"%s: Sockaddr family doesn't match the requested one\\n\",\n\t\t\t\t__func__);\n\t\treturn ret;\n\t}\n\trem_info = kzalloc(sizeof(struct iwpm_remote_info), GFP_ATOMIC);\n\tif (!rem_info) {\n\t\tret = -ENOMEM;\n\t\treturn ret;\n\t}\n\tmemcpy(&rem_info->mapped_loc_sockaddr, mapped_loc_sockaddr,\n\t       sizeof(struct sockaddr_storage));\n\tmemcpy(&rem_info->remote_sockaddr, remote_sockaddr,\n\t       sizeof(struct sockaddr_storage));\n\tmemcpy(&rem_info->mapped_rem_sockaddr, mapped_rem_sockaddr,\n\t       sizeof(struct sockaddr_storage));\n\trem_info->nl_client = nl_client;\n\n\tiwpm_add_remote_info(rem_info);\n\n\tiwpm_print_sockaddr(local_sockaddr,\n\t\t\t\"remote_info: Local sockaddr:\");\n\tiwpm_print_sockaddr(mapped_loc_sockaddr,\n\t\t\t\"remote_info: Mapped local sockaddr:\");\n\tiwpm_print_sockaddr(remote_sockaddr,\n\t\t\t\"remote_info: Remote sockaddr:\");\n\tiwpm_print_sockaddr(mapped_rem_sockaddr,\n\t\t\t\"remote_info: Mapped remote sockaddr:\");\n\treturn ret;\n}\n\n \nstatic const struct nla_policy resp_mapinfo_policy[IWPM_NLA_MAPINFO_REQ_MAX] = {\n\t[IWPM_NLA_MAPINFO_ULIB_NAME] = { .type = NLA_STRING,\n\t\t\t\t\t.len = IWPM_ULIBNAME_SIZE - 1 },\n\t[IWPM_NLA_MAPINFO_ULIB_VER]  = { .type = NLA_U16 }\n};\n\n \nint iwpm_mapping_info_cb(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct nlattr *nltb[IWPM_NLA_MAPINFO_REQ_MAX];\n\tconst char *msg_type = \"Mapping Info response\";\n\tu8 nl_client;\n\tchar *iwpm_name;\n\tu16 iwpm_version;\n\tint ret = -EINVAL;\n\n\tif (iwpm_parse_nlmsg(cb, IWPM_NLA_MAPINFO_REQ_MAX,\n\t\t\t\tresp_mapinfo_policy, nltb, msg_type)) {\n\t\tpr_info(\"%s: Unable to parse nlmsg\\n\", __func__);\n\t\treturn ret;\n\t}\n\tiwpm_name = (char *)nla_data(nltb[IWPM_NLA_MAPINFO_ULIB_NAME]);\n\tiwpm_version = nla_get_u16(nltb[IWPM_NLA_MAPINFO_ULIB_VER]);\n\tif (strcmp(iwpm_ulib_name, iwpm_name) ||\n\t\t\tiwpm_version < IWPM_UABI_VERSION_MIN) {\n\t\tpr_info(\"%s: Invalid port mapper name = %s version = %u\\n\",\n\t\t\t\t__func__, iwpm_name, iwpm_version);\n\t\treturn ret;\n\t}\n\tnl_client = RDMA_NL_GET_CLIENT(cb->nlh->nlmsg_type);\n\tiwpm_set_registration(nl_client, IWPM_REG_INCOMPL);\n\tatomic_set(&echo_nlmsg_seq, cb->nlh->nlmsg_seq);\n\tiwpm_user_pid = cb->nlh->nlmsg_pid;\n\n\tif (iwpm_ulib_version < IWPM_UABI_VERSION)\n\t\tpr_warn_once(\"%s: Down level iwpmd/pid %d.  Continuing...\",\n\t\t\t__func__, iwpm_user_pid);\n\n\tif (!iwpm_mapinfo_available())\n\t\treturn 0;\n\tpr_debug(\"%s: iWarp Port Mapper (pid = %d) is available!\\n\",\n\t\t __func__, iwpm_user_pid);\n\tret = iwpm_send_mapinfo(nl_client, iwpm_user_pid);\n\treturn ret;\n}\n\n \nstatic const struct nla_policy ack_mapinfo_policy[IWPM_NLA_MAPINFO_NUM_MAX] = {\n\t[IWPM_NLA_MAPINFO_SEQ]    =   { .type = NLA_U32 },\n\t[IWPM_NLA_MAPINFO_SEND_NUM] = { .type = NLA_U32 },\n\t[IWPM_NLA_MAPINFO_ACK_NUM] =  { .type = NLA_U32 }\n};\n\n \nint iwpm_ack_mapping_info_cb(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct nlattr *nltb[IWPM_NLA_MAPINFO_NUM_MAX];\n\tu32 mapinfo_send, mapinfo_ack;\n\tconst char *msg_type = \"Mapping Info Ack\";\n\n\tif (iwpm_parse_nlmsg(cb, IWPM_NLA_MAPINFO_NUM_MAX,\n\t\t\t\tack_mapinfo_policy, nltb, msg_type))\n\t\treturn -EINVAL;\n\tmapinfo_send = nla_get_u32(nltb[IWPM_NLA_MAPINFO_SEND_NUM]);\n\tmapinfo_ack = nla_get_u32(nltb[IWPM_NLA_MAPINFO_ACK_NUM]);\n\tif (mapinfo_ack != mapinfo_send)\n\t\tpr_info(\"%s: Invalid mapinfo number (sent = %u ack-ed = %u)\\n\",\n\t\t\t__func__, mapinfo_send, mapinfo_ack);\n\tatomic_set(&echo_nlmsg_seq, cb->nlh->nlmsg_seq);\n\treturn 0;\n}\n\n \nstatic const struct nla_policy map_error_policy[IWPM_NLA_ERR_MAX] = {\n\t[IWPM_NLA_ERR_SEQ]        = { .type = NLA_U32 },\n\t[IWPM_NLA_ERR_CODE]       = { .type = NLA_U16 },\n};\n\n \nint iwpm_mapping_error_cb(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct iwpm_nlmsg_request *nlmsg_request = NULL;\n\tint nl_client = RDMA_NL_GET_CLIENT(cb->nlh->nlmsg_type);\n\tstruct nlattr *nltb[IWPM_NLA_ERR_MAX];\n\tu32 msg_seq;\n\tu16 err_code;\n\tconst char *msg_type = \"Mapping Error Msg\";\n\n\tif (iwpm_parse_nlmsg(cb, IWPM_NLA_ERR_MAX,\n\t\t\t\tmap_error_policy, nltb, msg_type))\n\t\treturn -EINVAL;\n\n\tmsg_seq = nla_get_u32(nltb[IWPM_NLA_ERR_SEQ]);\n\terr_code = nla_get_u16(nltb[IWPM_NLA_ERR_CODE]);\n\tpr_info(\"%s: Received msg seq = %u err code = %u client = %d\\n\",\n\t\t\t\t__func__, msg_seq, err_code, nl_client);\n\t \n\tnlmsg_request = iwpm_find_nlmsg_request(msg_seq);\n\tif (!nlmsg_request) {\n\t\t \n\t\tpr_debug(\"Could not find matching req (seq = %u)\\n\", msg_seq);\n\t\treturn 0;\n\t}\n\tatomic_set(&echo_nlmsg_seq, cb->nlh->nlmsg_seq);\n\tnlmsg_request->err_code = err_code;\n\tnlmsg_request->request_done = 1;\n\t \n\tkref_put(&nlmsg_request->kref, iwpm_free_nlmsg_request);\n\tbarrier();\n\tup(&nlmsg_request->sem);\n\treturn 0;\n}\n\n \nstatic const struct nla_policy hello_policy[IWPM_NLA_HELLO_MAX] = {\n\t[IWPM_NLA_HELLO_ABI_VERSION]     = { .type = NLA_U16 }\n};\n\n \nint iwpm_hello_cb(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct nlattr *nltb[IWPM_NLA_HELLO_MAX];\n\tconst char *msg_type = \"Hello request\";\n\tu8 nl_client;\n\tu16 abi_version;\n\tint ret = -EINVAL;\n\n\tif (iwpm_parse_nlmsg(cb, IWPM_NLA_HELLO_MAX, hello_policy, nltb,\n\t\t\t     msg_type)) {\n\t\tpr_info(\"%s: Unable to parse nlmsg\\n\", __func__);\n\t\treturn ret;\n\t}\n\tabi_version = nla_get_u16(nltb[IWPM_NLA_HELLO_ABI_VERSION]);\n\tnl_client = RDMA_NL_GET_CLIENT(cb->nlh->nlmsg_type);\n\tiwpm_set_registration(nl_client, IWPM_REG_INCOMPL);\n\tatomic_set(&echo_nlmsg_seq, cb->nlh->nlmsg_seq);\n\tiwpm_ulib_version = min_t(u16, IWPM_UABI_VERSION, abi_version);\n\tpr_debug(\"Using ABI version %u\\n\", iwpm_ulib_version);\n\tiwpm_user_pid = cb->nlh->nlmsg_pid;\n\tret = iwpm_send_hello(nl_client, iwpm_user_pid, iwpm_ulib_version);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}