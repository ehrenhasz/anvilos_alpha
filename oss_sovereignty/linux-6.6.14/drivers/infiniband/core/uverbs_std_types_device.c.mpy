{
  "module_name": "uverbs_std_types_device.c",
  "hash_id": "a6ee470a3d66c9fa3ed5ac9c4b79c06e949d82277b6982fa749797db8a811ba3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/core/uverbs_std_types_device.c",
  "human_readable_source": "\n \n\n#include <linux/overflow.h>\n#include <rdma/uverbs_std_types.h>\n#include \"rdma_core.h\"\n#include \"uverbs.h\"\n#include <rdma/uverbs_ioctl.h>\n#include <rdma/opa_addr.h>\n#include <rdma/ib_cache.h>\n\n \nstatic int UVERBS_HANDLER(UVERBS_METHOD_INVOKE_WRITE)(\n\tstruct uverbs_attr_bundle *attrs)\n{\n\tstruct uverbs_api *uapi = attrs->ufile->device->uapi;\n\tconst struct uverbs_api_write_method *method_elm;\n\tu32 cmd;\n\tint rc;\n\n\trc = uverbs_get_const(&cmd, attrs, UVERBS_ATTR_WRITE_CMD);\n\tif (rc)\n\t\treturn rc;\n\n\tmethod_elm = uapi_get_method(uapi, cmd);\n\tif (IS_ERR(method_elm))\n\t\treturn PTR_ERR(method_elm);\n\n\tuverbs_fill_udata(attrs, &attrs->ucore, UVERBS_ATTR_CORE_IN,\n\t\t\t  UVERBS_ATTR_CORE_OUT);\n\n\tif (attrs->ucore.inlen < method_elm->req_size ||\n\t    attrs->ucore.outlen < method_elm->resp_size)\n\t\treturn -ENOSPC;\n\n\tattrs->uobject = NULL;\n\trc = method_elm->handler(attrs);\n\tif (attrs->uobject)\n\t\tuverbs_finalize_object(attrs->uobject, UVERBS_ACCESS_NEW, true,\n\t\t\t\t       !rc, attrs);\n\treturn rc;\n}\n\nDECLARE_UVERBS_NAMED_METHOD(UVERBS_METHOD_INVOKE_WRITE,\n\t\t\t    UVERBS_ATTR_CONST_IN(UVERBS_ATTR_WRITE_CMD,\n\t\t\t\t\t\t enum ib_uverbs_write_cmds,\n\t\t\t\t\t\t UA_MANDATORY),\n\t\t\t    UVERBS_ATTR_PTR_IN(UVERBS_ATTR_CORE_IN,\n\t\t\t\t\t       UVERBS_ATTR_MIN_SIZE(sizeof(u32)),\n\t\t\t\t\t       UA_OPTIONAL),\n\t\t\t    UVERBS_ATTR_PTR_OUT(UVERBS_ATTR_CORE_OUT,\n\t\t\t\t\t\tUVERBS_ATTR_MIN_SIZE(0),\n\t\t\t\t\t\tUA_OPTIONAL),\n\t\t\t    UVERBS_ATTR_UHW());\n\nstatic uint32_t *\ngather_objects_handle(struct ib_uverbs_file *ufile,\n\t\t      const struct uverbs_api_object *uapi_object,\n\t\t      struct uverbs_attr_bundle *attrs,\n\t\t      ssize_t out_len,\n\t\t      u64 *total)\n{\n\tu64 max_count = out_len / sizeof(u32);\n\tstruct ib_uobject *obj;\n\tu64 count = 0;\n\tu32 *handles;\n\n\t \n\thandles = uverbs_zalloc(attrs, out_len);\n\tif (IS_ERR(handles))\n\t\treturn handles;\n\n\tspin_lock_irq(&ufile->uobjects_lock);\n\tlist_for_each_entry(obj, &ufile->uobjects, list) {\n\t\tu32 obj_id = obj->id;\n\n\t\tif (obj->uapi_object != uapi_object)\n\t\t\tcontinue;\n\n\t\tif (count >= max_count)\n\t\t\tbreak;\n\n\t\thandles[count] = obj_id;\n\t\tcount++;\n\t}\n\tspin_unlock_irq(&ufile->uobjects_lock);\n\n\t*total = count;\n\treturn handles;\n}\n\nstatic int UVERBS_HANDLER(UVERBS_METHOD_INFO_HANDLES)(\n\tstruct uverbs_attr_bundle *attrs)\n{\n\tconst struct uverbs_api_object *uapi_object;\n\tssize_t out_len;\n\tu64 total = 0;\n\tu16 object_id;\n\tu32 *handles;\n\tint ret;\n\n\tout_len = uverbs_attr_get_len(attrs, UVERBS_ATTR_INFO_HANDLES_LIST);\n\tif (out_len <= 0 || (out_len % sizeof(u32) != 0))\n\t\treturn -EINVAL;\n\n\tret = uverbs_get_const(&object_id, attrs, UVERBS_ATTR_INFO_OBJECT_ID);\n\tif (ret)\n\t\treturn ret;\n\n\tuapi_object = uapi_get_object(attrs->ufile->device->uapi, object_id);\n\tif (IS_ERR(uapi_object))\n\t\treturn PTR_ERR(uapi_object);\n\n\thandles = gather_objects_handle(attrs->ufile, uapi_object, attrs,\n\t\t\t\t\tout_len, &total);\n\tif (IS_ERR(handles))\n\t\treturn PTR_ERR(handles);\n\n\tret = uverbs_copy_to(attrs, UVERBS_ATTR_INFO_HANDLES_LIST, handles,\n\t\t\t     sizeof(u32) * total);\n\tif (ret)\n\t\tgoto err;\n\n\tret = uverbs_copy_to(attrs, UVERBS_ATTR_INFO_TOTAL_HANDLES, &total,\n\t\t\t     sizeof(total));\nerr:\n\treturn ret;\n}\n\nvoid copy_port_attr_to_resp(struct ib_port_attr *attr,\n\t\t\t    struct ib_uverbs_query_port_resp *resp,\n\t\t\t    struct ib_device *ib_dev, u8 port_num)\n{\n\tresp->state = attr->state;\n\tresp->max_mtu = attr->max_mtu;\n\tresp->active_mtu = attr->active_mtu;\n\tresp->gid_tbl_len = attr->gid_tbl_len;\n\tresp->port_cap_flags = make_port_cap_flags(attr);\n\tresp->max_msg_sz = attr->max_msg_sz;\n\tresp->bad_pkey_cntr = attr->bad_pkey_cntr;\n\tresp->qkey_viol_cntr = attr->qkey_viol_cntr;\n\tresp->pkey_tbl_len = attr->pkey_tbl_len;\n\n\tif (rdma_is_grh_required(ib_dev, port_num))\n\t\tresp->flags |= IB_UVERBS_QPF_GRH_REQUIRED;\n\n\tif (rdma_cap_opa_ah(ib_dev, port_num)) {\n\t\tresp->lid = OPA_TO_IB_UCAST_LID(attr->lid);\n\t\tresp->sm_lid = OPA_TO_IB_UCAST_LID(attr->sm_lid);\n\t} else {\n\t\tresp->lid = ib_lid_cpu16(attr->lid);\n\t\tresp->sm_lid = ib_lid_cpu16(attr->sm_lid);\n\t}\n\n\tresp->lmc = attr->lmc;\n\tresp->max_vl_num = attr->max_vl_num;\n\tresp->sm_sl = attr->sm_sl;\n\tresp->subnet_timeout = attr->subnet_timeout;\n\tresp->init_type_reply = attr->init_type_reply;\n\tresp->active_width = attr->active_width;\n\t \n\tresp->active_speed = min_t(u16, attr->active_speed, IB_SPEED_NDR);\n\tresp->phys_state = attr->phys_state;\n\tresp->link_layer = rdma_port_get_link_layer(ib_dev, port_num);\n}\n\nstatic int UVERBS_HANDLER(UVERBS_METHOD_QUERY_PORT)(\n\tstruct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_device *ib_dev;\n\tstruct ib_port_attr attr = {};\n\tstruct ib_uverbs_query_port_resp_ex resp = {};\n\tstruct ib_ucontext *ucontext;\n\tint ret;\n\tu8 port_num;\n\n\tucontext = ib_uverbs_get_ucontext(attrs);\n\tif (IS_ERR(ucontext))\n\t\treturn PTR_ERR(ucontext);\n\tib_dev = ucontext->device;\n\n\t \n\tif (!ib_dev->ops.query_port)\n\t\treturn -EOPNOTSUPP;\n\n\tret = uverbs_get_const(&port_num, attrs,\n\t\t\t       UVERBS_ATTR_QUERY_PORT_PORT_NUM);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ib_query_port(ib_dev, port_num, &attr);\n\tif (ret)\n\t\treturn ret;\n\n\tcopy_port_attr_to_resp(&attr, &resp.legacy_resp, ib_dev, port_num);\n\tresp.port_cap_flags2 = attr.port_cap_flags2;\n\n\treturn uverbs_copy_to_struct_or_zero(attrs, UVERBS_ATTR_QUERY_PORT_RESP,\n\t\t\t\t\t     &resp, sizeof(resp));\n}\n\nstatic int UVERBS_HANDLER(UVERBS_METHOD_GET_CONTEXT)(\n\tstruct uverbs_attr_bundle *attrs)\n{\n\tu32 num_comp = attrs->ufile->device->num_comp_vectors;\n\tu64 core_support = IB_UVERBS_CORE_SUPPORT_OPTIONAL_MR_ACCESS;\n\tint ret;\n\n\tret = uverbs_copy_to(attrs, UVERBS_ATTR_GET_CONTEXT_NUM_COMP_VECTORS,\n\t\t\t     &num_comp, sizeof(num_comp));\n\tif (IS_UVERBS_COPY_ERR(ret))\n\t\treturn ret;\n\n\tret = uverbs_copy_to(attrs, UVERBS_ATTR_GET_CONTEXT_CORE_SUPPORT,\n\t\t\t     &core_support, sizeof(core_support));\n\tif (IS_UVERBS_COPY_ERR(ret))\n\t\treturn ret;\n\n\tret = ib_alloc_ucontext(attrs);\n\tif (ret)\n\t\treturn ret;\n\tret = ib_init_ucontext(attrs);\n\tif (ret) {\n\t\tkfree(attrs->context);\n\t\tattrs->context = NULL;\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int UVERBS_HANDLER(UVERBS_METHOD_QUERY_CONTEXT)(\n\tstruct uverbs_attr_bundle *attrs)\n{\n\tu64 core_support = IB_UVERBS_CORE_SUPPORT_OPTIONAL_MR_ACCESS;\n\tstruct ib_ucontext *ucontext;\n\tstruct ib_device *ib_dev;\n\tu32 num_comp;\n\tint ret;\n\n\tucontext = ib_uverbs_get_ucontext(attrs);\n\tif (IS_ERR(ucontext))\n\t\treturn PTR_ERR(ucontext);\n\tib_dev = ucontext->device;\n\n\tif (!ib_dev->ops.query_ucontext)\n\t\treturn -EOPNOTSUPP;\n\n\tnum_comp = attrs->ufile->device->num_comp_vectors;\n\tret = uverbs_copy_to(attrs, UVERBS_ATTR_QUERY_CONTEXT_NUM_COMP_VECTORS,\n\t\t\t     &num_comp, sizeof(num_comp));\n\tif (IS_UVERBS_COPY_ERR(ret))\n\t\treturn ret;\n\n\tret = uverbs_copy_to(attrs, UVERBS_ATTR_QUERY_CONTEXT_CORE_SUPPORT,\n\t\t\t     &core_support, sizeof(core_support));\n\tif (IS_UVERBS_COPY_ERR(ret))\n\t\treturn ret;\n\n\treturn ucontext->device->ops.query_ucontext(ucontext, attrs);\n}\n\nstatic int copy_gid_entries_to_user(struct uverbs_attr_bundle *attrs,\n\t\t\t\t    struct ib_uverbs_gid_entry *entries,\n\t\t\t\t    size_t num_entries, size_t user_entry_size)\n{\n\tconst struct uverbs_attr *attr;\n\tvoid __user *user_entries;\n\tsize_t copy_len;\n\tint ret;\n\tint i;\n\n\tif (user_entry_size == sizeof(*entries)) {\n\t\tret = uverbs_copy_to(attrs,\n\t\t\t\t     UVERBS_ATTR_QUERY_GID_TABLE_RESP_ENTRIES,\n\t\t\t\t     entries, sizeof(*entries) * num_entries);\n\t\treturn ret;\n\t}\n\n\tcopy_len = min_t(size_t, user_entry_size, sizeof(*entries));\n\tattr = uverbs_attr_get(attrs, UVERBS_ATTR_QUERY_GID_TABLE_RESP_ENTRIES);\n\tif (IS_ERR(attr))\n\t\treturn PTR_ERR(attr);\n\n\tuser_entries = u64_to_user_ptr(attr->ptr_attr.data);\n\tfor (i = 0; i < num_entries; i++) {\n\t\tif (copy_to_user(user_entries, entries, copy_len))\n\t\t\treturn -EFAULT;\n\n\t\tif (user_entry_size > sizeof(*entries)) {\n\t\t\tif (clear_user(user_entries + sizeof(*entries),\n\t\t\t\t       user_entry_size - sizeof(*entries)))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tentries++;\n\t\tuser_entries += user_entry_size;\n\t}\n\n\treturn uverbs_output_written(attrs,\n\t\t\t\t     UVERBS_ATTR_QUERY_GID_TABLE_RESP_ENTRIES);\n}\n\nstatic int UVERBS_HANDLER(UVERBS_METHOD_QUERY_GID_TABLE)(\n\tstruct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uverbs_gid_entry *entries;\n\tstruct ib_ucontext *ucontext;\n\tstruct ib_device *ib_dev;\n\tsize_t user_entry_size;\n\tssize_t num_entries;\n\tint max_entries;\n\tu32 flags;\n\tint ret;\n\n\tret = uverbs_get_flags32(&flags, attrs,\n\t\t\t\t UVERBS_ATTR_QUERY_GID_TABLE_FLAGS, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = uverbs_get_const(&user_entry_size, attrs,\n\t\t\t       UVERBS_ATTR_QUERY_GID_TABLE_ENTRY_SIZE);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!user_entry_size)\n\t\treturn -EINVAL;\n\n\tmax_entries = uverbs_attr_ptr_get_array_size(\n\t\tattrs, UVERBS_ATTR_QUERY_GID_TABLE_RESP_ENTRIES,\n\t\tuser_entry_size);\n\tif (max_entries <= 0)\n\t\treturn max_entries ?: -EINVAL;\n\n\tucontext = ib_uverbs_get_ucontext(attrs);\n\tif (IS_ERR(ucontext))\n\t\treturn PTR_ERR(ucontext);\n\tib_dev = ucontext->device;\n\n\tentries = uverbs_kcalloc(attrs, max_entries, sizeof(*entries));\n\tif (IS_ERR(entries))\n\t\treturn PTR_ERR(entries);\n\n\tnum_entries = rdma_query_gid_table(ib_dev, entries, max_entries);\n\tif (num_entries < 0)\n\t\treturn -EINVAL;\n\n\tret = copy_gid_entries_to_user(attrs, entries, num_entries,\n\t\t\t\t       user_entry_size);\n\tif (ret)\n\t\treturn ret;\n\n\tret = uverbs_copy_to(attrs,\n\t\t\t     UVERBS_ATTR_QUERY_GID_TABLE_RESP_NUM_ENTRIES,\n\t\t\t     &num_entries, sizeof(num_entries));\n\treturn ret;\n}\n\nstatic int UVERBS_HANDLER(UVERBS_METHOD_QUERY_GID_ENTRY)(\n\tstruct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uverbs_gid_entry entry = {};\n\tconst struct ib_gid_attr *gid_attr;\n\tstruct ib_ucontext *ucontext;\n\tstruct ib_device *ib_dev;\n\tstruct net_device *ndev;\n\tu32 gid_index;\n\tu32 port_num;\n\tu32 flags;\n\tint ret;\n\n\tret = uverbs_get_flags32(&flags, attrs,\n\t\t\t\t UVERBS_ATTR_QUERY_GID_ENTRY_FLAGS, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = uverbs_get_const(&port_num, attrs,\n\t\t\t       UVERBS_ATTR_QUERY_GID_ENTRY_PORT);\n\tif (ret)\n\t\treturn ret;\n\n\tret = uverbs_get_const(&gid_index, attrs,\n\t\t\t       UVERBS_ATTR_QUERY_GID_ENTRY_GID_INDEX);\n\tif (ret)\n\t\treturn ret;\n\n\tucontext = ib_uverbs_get_ucontext(attrs);\n\tif (IS_ERR(ucontext))\n\t\treturn PTR_ERR(ucontext);\n\tib_dev = ucontext->device;\n\n\tif (!rdma_is_port_valid(ib_dev, port_num))\n\t\treturn -EINVAL;\n\n\tgid_attr = rdma_get_gid_attr(ib_dev, port_num, gid_index);\n\tif (IS_ERR(gid_attr))\n\t\treturn PTR_ERR(gid_attr);\n\n\tmemcpy(&entry.gid, &gid_attr->gid, sizeof(gid_attr->gid));\n\tentry.gid_index = gid_attr->index;\n\tentry.port_num = gid_attr->port_num;\n\tentry.gid_type = gid_attr->gid_type;\n\n\trcu_read_lock();\n\tndev = rdma_read_gid_attr_ndev_rcu(gid_attr);\n\tif (IS_ERR(ndev)) {\n\t\tif (PTR_ERR(ndev) != -ENODEV) {\n\t\t\tret = PTR_ERR(ndev);\n\t\t\trcu_read_unlock();\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tentry.netdev_ifindex = ndev->ifindex;\n\t}\n\trcu_read_unlock();\n\n\tret = uverbs_copy_to_struct_or_zero(\n\t\tattrs, UVERBS_ATTR_QUERY_GID_ENTRY_RESP_ENTRY, &entry,\n\t\tsizeof(entry));\nout:\n\trdma_put_gid_attr(gid_attr);\n\treturn ret;\n}\n\nDECLARE_UVERBS_NAMED_METHOD(\n\tUVERBS_METHOD_GET_CONTEXT,\n\tUVERBS_ATTR_PTR_OUT(UVERBS_ATTR_GET_CONTEXT_NUM_COMP_VECTORS,\n\t\t\t    UVERBS_ATTR_TYPE(u32), UA_OPTIONAL),\n\tUVERBS_ATTR_PTR_OUT(UVERBS_ATTR_GET_CONTEXT_CORE_SUPPORT,\n\t\t\t    UVERBS_ATTR_TYPE(u64), UA_OPTIONAL),\n\tUVERBS_ATTR_UHW());\n\nDECLARE_UVERBS_NAMED_METHOD(\n\tUVERBS_METHOD_QUERY_CONTEXT,\n\tUVERBS_ATTR_PTR_OUT(UVERBS_ATTR_QUERY_CONTEXT_NUM_COMP_VECTORS,\n\t\t\t    UVERBS_ATTR_TYPE(u32), UA_OPTIONAL),\n\tUVERBS_ATTR_PTR_OUT(UVERBS_ATTR_QUERY_CONTEXT_CORE_SUPPORT,\n\t\t\t    UVERBS_ATTR_TYPE(u64), UA_OPTIONAL));\n\nDECLARE_UVERBS_NAMED_METHOD(\n\tUVERBS_METHOD_INFO_HANDLES,\n\t \n\tUVERBS_ATTR_CONST_IN(UVERBS_ATTR_INFO_OBJECT_ID,\n\t\t\t     enum uverbs_default_objects, UA_MANDATORY),\n\tUVERBS_ATTR_PTR_OUT(UVERBS_ATTR_INFO_TOTAL_HANDLES,\n\t\t\t    UVERBS_ATTR_TYPE(u32), UA_OPTIONAL),\n\tUVERBS_ATTR_PTR_OUT(UVERBS_ATTR_INFO_HANDLES_LIST,\n\t\t\t    UVERBS_ATTR_MIN_SIZE(sizeof(u32)), UA_OPTIONAL));\n\nDECLARE_UVERBS_NAMED_METHOD(\n\tUVERBS_METHOD_QUERY_PORT,\n\tUVERBS_ATTR_CONST_IN(UVERBS_ATTR_QUERY_PORT_PORT_NUM, u8, UA_MANDATORY),\n\tUVERBS_ATTR_PTR_OUT(\n\t\tUVERBS_ATTR_QUERY_PORT_RESP,\n\t\tUVERBS_ATTR_STRUCT(struct ib_uverbs_query_port_resp_ex,\n\t\t\t\t   reserved),\n\t\tUA_MANDATORY));\n\nDECLARE_UVERBS_NAMED_METHOD(\n\tUVERBS_METHOD_QUERY_GID_TABLE,\n\tUVERBS_ATTR_CONST_IN(UVERBS_ATTR_QUERY_GID_TABLE_ENTRY_SIZE, u64,\n\t\t\t     UA_MANDATORY),\n\tUVERBS_ATTR_FLAGS_IN(UVERBS_ATTR_QUERY_GID_TABLE_FLAGS, u32,\n\t\t\t     UA_OPTIONAL),\n\tUVERBS_ATTR_PTR_OUT(UVERBS_ATTR_QUERY_GID_TABLE_RESP_ENTRIES,\n\t\t\t    UVERBS_ATTR_MIN_SIZE(0), UA_MANDATORY),\n\tUVERBS_ATTR_PTR_OUT(UVERBS_ATTR_QUERY_GID_TABLE_RESP_NUM_ENTRIES,\n\t\t\t    UVERBS_ATTR_TYPE(u64), UA_MANDATORY));\n\nDECLARE_UVERBS_NAMED_METHOD(\n\tUVERBS_METHOD_QUERY_GID_ENTRY,\n\tUVERBS_ATTR_CONST_IN(UVERBS_ATTR_QUERY_GID_ENTRY_PORT, u32,\n\t\t\t     UA_MANDATORY),\n\tUVERBS_ATTR_CONST_IN(UVERBS_ATTR_QUERY_GID_ENTRY_GID_INDEX, u32,\n\t\t\t     UA_MANDATORY),\n\tUVERBS_ATTR_FLAGS_IN(UVERBS_ATTR_QUERY_GID_ENTRY_FLAGS, u32,\n\t\t\t     UA_MANDATORY),\n\tUVERBS_ATTR_PTR_OUT(UVERBS_ATTR_QUERY_GID_ENTRY_RESP_ENTRY,\n\t\t\t    UVERBS_ATTR_STRUCT(struct ib_uverbs_gid_entry,\n\t\t\t\t\t       netdev_ifindex),\n\t\t\t    UA_MANDATORY));\n\nDECLARE_UVERBS_GLOBAL_METHODS(UVERBS_OBJECT_DEVICE,\n\t\t\t      &UVERBS_METHOD(UVERBS_METHOD_GET_CONTEXT),\n\t\t\t      &UVERBS_METHOD(UVERBS_METHOD_INVOKE_WRITE),\n\t\t\t      &UVERBS_METHOD(UVERBS_METHOD_INFO_HANDLES),\n\t\t\t      &UVERBS_METHOD(UVERBS_METHOD_QUERY_PORT),\n\t\t\t      &UVERBS_METHOD(UVERBS_METHOD_QUERY_CONTEXT),\n\t\t\t      &UVERBS_METHOD(UVERBS_METHOD_QUERY_GID_TABLE),\n\t\t\t      &UVERBS_METHOD(UVERBS_METHOD_QUERY_GID_ENTRY));\n\nconst struct uapi_definition uverbs_def_obj_device[] = {\n\tUAPI_DEF_CHAIN_OBJ_TREE_NAMED(UVERBS_OBJECT_DEVICE),\n\t{},\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}