{
  "module_name": "nldev.c",
  "hash_id": "14abcbcf346c3b858d568b649dc614b1e337d8155a403f242282c10dbca883ac",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/core/nldev.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/pid.h>\n#include <linux/pid_namespace.h>\n#include <linux/mutex.h>\n#include <net/netlink.h>\n#include <rdma/rdma_cm.h>\n#include <rdma/rdma_netlink.h>\n\n#include \"core_priv.h\"\n#include \"cma_priv.h\"\n#include \"restrack.h\"\n#include \"uverbs.h\"\n\ntypedef int (*res_fill_func_t)(struct sk_buff*, bool,\n\t\t\t       struct rdma_restrack_entry*, uint32_t);\n\n \nstatic const struct nla_policy nldev_policy[RDMA_NLDEV_ATTR_MAX] = {\n\t[RDMA_NLDEV_ATTR_CHARDEV]\t\t= { .type = NLA_U64 },\n\t[RDMA_NLDEV_ATTR_CHARDEV_ABI]\t\t= { .type = NLA_U64 },\n\t[RDMA_NLDEV_ATTR_CHARDEV_NAME]\t\t= { .type = NLA_NUL_STRING,\n\t\t\t\t\t.len = RDMA_NLDEV_ATTR_EMPTY_STRING },\n\t[RDMA_NLDEV_ATTR_CHARDEV_TYPE]\t\t= { .type = NLA_NUL_STRING,\n\t\t\t\t\t.len = RDMA_NLDEV_ATTR_CHARDEV_TYPE_SIZE },\n\t[RDMA_NLDEV_ATTR_DEV_DIM]               = { .type = NLA_U8 },\n\t[RDMA_NLDEV_ATTR_DEV_INDEX]\t\t= { .type = NLA_U32 },\n\t[RDMA_NLDEV_ATTR_DEV_NAME]\t\t= { .type = NLA_NUL_STRING,\n\t\t\t\t\t.len = IB_DEVICE_NAME_MAX },\n\t[RDMA_NLDEV_ATTR_DEV_NODE_TYPE]\t\t= { .type = NLA_U8 },\n\t[RDMA_NLDEV_ATTR_DEV_PROTOCOL]\t\t= { .type = NLA_NUL_STRING,\n\t\t\t\t\t.len = RDMA_NLDEV_ATTR_EMPTY_STRING },\n\t[RDMA_NLDEV_ATTR_DRIVER]\t\t= { .type = NLA_NESTED },\n\t[RDMA_NLDEV_ATTR_DRIVER_ENTRY]\t\t= { .type = NLA_NESTED },\n\t[RDMA_NLDEV_ATTR_DRIVER_PRINT_TYPE]\t= { .type = NLA_U8 },\n\t[RDMA_NLDEV_ATTR_DRIVER_STRING]\t\t= { .type = NLA_NUL_STRING,\n\t\t\t\t\t.len = RDMA_NLDEV_ATTR_EMPTY_STRING },\n\t[RDMA_NLDEV_ATTR_DRIVER_S32]\t\t= { .type = NLA_S32 },\n\t[RDMA_NLDEV_ATTR_DRIVER_S64]\t\t= { .type = NLA_S64 },\n\t[RDMA_NLDEV_ATTR_DRIVER_U32]\t\t= { .type = NLA_U32 },\n\t[RDMA_NLDEV_ATTR_DRIVER_U64]\t\t= { .type = NLA_U64 },\n\t[RDMA_NLDEV_ATTR_FW_VERSION]\t\t= { .type = NLA_NUL_STRING,\n\t\t\t\t\t.len = RDMA_NLDEV_ATTR_EMPTY_STRING },\n\t[RDMA_NLDEV_ATTR_LID]\t\t\t= { .type = NLA_U32 },\n\t[RDMA_NLDEV_ATTR_LINK_TYPE]\t\t= { .type = NLA_NUL_STRING,\n\t\t\t\t\t.len = IFNAMSIZ },\n\t[RDMA_NLDEV_ATTR_LMC]\t\t\t= { .type = NLA_U8 },\n\t[RDMA_NLDEV_ATTR_NDEV_INDEX]\t\t= { .type = NLA_U32 },\n\t[RDMA_NLDEV_ATTR_NDEV_NAME]\t\t= { .type = NLA_NUL_STRING,\n\t\t\t\t\t.len = IFNAMSIZ },\n\t[RDMA_NLDEV_ATTR_NODE_GUID]\t\t= { .type = NLA_U64 },\n\t[RDMA_NLDEV_ATTR_PORT_INDEX]\t\t= { .type = NLA_U32 },\n\t[RDMA_NLDEV_ATTR_PORT_PHYS_STATE]\t= { .type = NLA_U8 },\n\t[RDMA_NLDEV_ATTR_PORT_STATE]\t\t= { .type = NLA_U8 },\n\t[RDMA_NLDEV_ATTR_RES_CM_ID]\t\t= { .type = NLA_NESTED },\n\t[RDMA_NLDEV_ATTR_RES_CM_IDN]\t\t= { .type = NLA_U32 },\n\t[RDMA_NLDEV_ATTR_RES_CM_ID_ENTRY]\t= { .type = NLA_NESTED },\n\t[RDMA_NLDEV_ATTR_RES_CQ]\t\t= { .type = NLA_NESTED },\n\t[RDMA_NLDEV_ATTR_RES_CQE]\t\t= { .type = NLA_U32 },\n\t[RDMA_NLDEV_ATTR_RES_CQN]\t\t= { .type = NLA_U32 },\n\t[RDMA_NLDEV_ATTR_RES_CQ_ENTRY]\t\t= { .type = NLA_NESTED },\n\t[RDMA_NLDEV_ATTR_RES_CTX]\t\t= { .type = NLA_NESTED },\n\t[RDMA_NLDEV_ATTR_RES_CTXN]\t\t= { .type = NLA_U32 },\n\t[RDMA_NLDEV_ATTR_RES_CTX_ENTRY]\t\t= { .type = NLA_NESTED },\n\t[RDMA_NLDEV_ATTR_RES_DST_ADDR]\t\t= {\n\t\t\t.len = sizeof(struct __kernel_sockaddr_storage) },\n\t[RDMA_NLDEV_ATTR_RES_IOVA]\t\t= { .type = NLA_U64 },\n\t[RDMA_NLDEV_ATTR_RES_KERN_NAME]\t\t= { .type = NLA_NUL_STRING,\n\t\t\t\t\t.len = RDMA_NLDEV_ATTR_EMPTY_STRING },\n\t[RDMA_NLDEV_ATTR_RES_LKEY]\t\t= { .type = NLA_U32 },\n\t[RDMA_NLDEV_ATTR_RES_LOCAL_DMA_LKEY]\t= { .type = NLA_U32 },\n\t[RDMA_NLDEV_ATTR_RES_LQPN]\t\t= { .type = NLA_U32 },\n\t[RDMA_NLDEV_ATTR_RES_MR]\t\t= { .type = NLA_NESTED },\n\t[RDMA_NLDEV_ATTR_RES_MRLEN]\t\t= { .type = NLA_U64 },\n\t[RDMA_NLDEV_ATTR_RES_MRN]\t\t= { .type = NLA_U32 },\n\t[RDMA_NLDEV_ATTR_RES_MR_ENTRY]\t\t= { .type = NLA_NESTED },\n\t[RDMA_NLDEV_ATTR_RES_PATH_MIG_STATE]\t= { .type = NLA_U8 },\n\t[RDMA_NLDEV_ATTR_RES_PD]\t\t= { .type = NLA_NESTED },\n\t[RDMA_NLDEV_ATTR_RES_PDN]\t\t= { .type = NLA_U32 },\n\t[RDMA_NLDEV_ATTR_RES_PD_ENTRY]\t\t= { .type = NLA_NESTED },\n\t[RDMA_NLDEV_ATTR_RES_PID]\t\t= { .type = NLA_U32 },\n\t[RDMA_NLDEV_ATTR_RES_POLL_CTX]\t\t= { .type = NLA_U8 },\n\t[RDMA_NLDEV_ATTR_RES_PS]\t\t= { .type = NLA_U32 },\n\t[RDMA_NLDEV_ATTR_RES_QP]\t\t= { .type = NLA_NESTED },\n\t[RDMA_NLDEV_ATTR_RES_QP_ENTRY]\t\t= { .type = NLA_NESTED },\n\t[RDMA_NLDEV_ATTR_RES_RAW]\t\t= { .type = NLA_BINARY },\n\t[RDMA_NLDEV_ATTR_RES_RKEY]\t\t= { .type = NLA_U32 },\n\t[RDMA_NLDEV_ATTR_RES_RQPN]\t\t= { .type = NLA_U32 },\n\t[RDMA_NLDEV_ATTR_RES_RQ_PSN]\t\t= { .type = NLA_U32 },\n\t[RDMA_NLDEV_ATTR_RES_SQ_PSN]\t\t= { .type = NLA_U32 },\n\t[RDMA_NLDEV_ATTR_RES_SRC_ADDR]\t\t= {\n\t\t\t.len = sizeof(struct __kernel_sockaddr_storage) },\n\t[RDMA_NLDEV_ATTR_RES_STATE]\t\t= { .type = NLA_U8 },\n\t[RDMA_NLDEV_ATTR_RES_SUMMARY]\t\t= { .type = NLA_NESTED },\n\t[RDMA_NLDEV_ATTR_RES_SUMMARY_ENTRY]\t= { .type = NLA_NESTED },\n\t[RDMA_NLDEV_ATTR_RES_SUMMARY_ENTRY_CURR]= { .type = NLA_U64 },\n\t[RDMA_NLDEV_ATTR_RES_SUMMARY_ENTRY_NAME]= { .type = NLA_NUL_STRING,\n\t\t\t\t\t.len = RDMA_NLDEV_ATTR_EMPTY_STRING },\n\t[RDMA_NLDEV_ATTR_RES_TYPE]\t\t= { .type = NLA_U8 },\n\t[RDMA_NLDEV_ATTR_RES_UNSAFE_GLOBAL_RKEY]= { .type = NLA_U32 },\n\t[RDMA_NLDEV_ATTR_RES_USECNT]\t\t= { .type = NLA_U64 },\n\t[RDMA_NLDEV_ATTR_RES_SRQ]\t\t= { .type = NLA_NESTED },\n\t[RDMA_NLDEV_ATTR_RES_SRQN]\t\t= { .type = NLA_U32 },\n\t[RDMA_NLDEV_ATTR_RES_SRQ_ENTRY]\t\t= { .type = NLA_NESTED },\n\t[RDMA_NLDEV_ATTR_MIN_RANGE]\t\t= { .type = NLA_U32 },\n\t[RDMA_NLDEV_ATTR_MAX_RANGE]\t\t= { .type = NLA_U32 },\n\t[RDMA_NLDEV_ATTR_SM_LID]\t\t= { .type = NLA_U32 },\n\t[RDMA_NLDEV_ATTR_SUBNET_PREFIX]\t\t= { .type = NLA_U64 },\n\t[RDMA_NLDEV_ATTR_STAT_AUTO_MODE_MASK]\t= { .type = NLA_U32 },\n\t[RDMA_NLDEV_ATTR_STAT_MODE]\t\t= { .type = NLA_U32 },\n\t[RDMA_NLDEV_ATTR_STAT_RES]\t\t= { .type = NLA_U32 },\n\t[RDMA_NLDEV_ATTR_STAT_COUNTER]\t\t= { .type = NLA_NESTED },\n\t[RDMA_NLDEV_ATTR_STAT_COUNTER_ENTRY]\t= { .type = NLA_NESTED },\n\t[RDMA_NLDEV_ATTR_STAT_COUNTER_ID]       = { .type = NLA_U32 },\n\t[RDMA_NLDEV_ATTR_STAT_HWCOUNTERS]       = { .type = NLA_NESTED },\n\t[RDMA_NLDEV_ATTR_STAT_HWCOUNTER_ENTRY]  = { .type = NLA_NESTED },\n\t[RDMA_NLDEV_ATTR_STAT_HWCOUNTER_ENTRY_NAME] = { .type = NLA_NUL_STRING },\n\t[RDMA_NLDEV_ATTR_STAT_HWCOUNTER_ENTRY_VALUE] = { .type = NLA_U64 },\n\t[RDMA_NLDEV_ATTR_SYS_IMAGE_GUID]\t= { .type = NLA_U64 },\n\t[RDMA_NLDEV_ATTR_UVERBS_DRIVER_ID]\t= { .type = NLA_U32 },\n\t[RDMA_NLDEV_NET_NS_FD]\t\t\t= { .type = NLA_U32 },\n\t[RDMA_NLDEV_SYS_ATTR_NETNS_MODE]\t= { .type = NLA_U8 },\n\t[RDMA_NLDEV_SYS_ATTR_COPY_ON_FORK]\t= { .type = NLA_U8 },\n\t[RDMA_NLDEV_ATTR_STAT_HWCOUNTER_INDEX]\t= { .type = NLA_U32 },\n\t[RDMA_NLDEV_ATTR_STAT_HWCOUNTER_DYNAMIC] = { .type = NLA_U8 },\n};\n\nstatic int put_driver_name_print_type(struct sk_buff *msg, const char *name,\n\t\t\t\t      enum rdma_nldev_print_type print_type)\n{\n\tif (nla_put_string(msg, RDMA_NLDEV_ATTR_DRIVER_STRING, name))\n\t\treturn -EMSGSIZE;\n\tif (print_type != RDMA_NLDEV_PRINT_TYPE_UNSPEC &&\n\t    nla_put_u8(msg, RDMA_NLDEV_ATTR_DRIVER_PRINT_TYPE, print_type))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n\nstatic int _rdma_nl_put_driver_u32(struct sk_buff *msg, const char *name,\n\t\t\t\t   enum rdma_nldev_print_type print_type,\n\t\t\t\t   u32 value)\n{\n\tif (put_driver_name_print_type(msg, name, print_type))\n\t\treturn -EMSGSIZE;\n\tif (nla_put_u32(msg, RDMA_NLDEV_ATTR_DRIVER_U32, value))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n\nstatic int _rdma_nl_put_driver_u64(struct sk_buff *msg, const char *name,\n\t\t\t\t   enum rdma_nldev_print_type print_type,\n\t\t\t\t   u64 value)\n{\n\tif (put_driver_name_print_type(msg, name, print_type))\n\t\treturn -EMSGSIZE;\n\tif (nla_put_u64_64bit(msg, RDMA_NLDEV_ATTR_DRIVER_U64, value,\n\t\t\t      RDMA_NLDEV_ATTR_PAD))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n\nint rdma_nl_put_driver_string(struct sk_buff *msg, const char *name,\n\t\t\t      const char *str)\n{\n\tif (put_driver_name_print_type(msg, name,\n\t\t\t\t       RDMA_NLDEV_PRINT_TYPE_UNSPEC))\n\t\treturn -EMSGSIZE;\n\tif (nla_put_string(msg, RDMA_NLDEV_ATTR_DRIVER_STRING, str))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(rdma_nl_put_driver_string);\n\nint rdma_nl_put_driver_u32(struct sk_buff *msg, const char *name, u32 value)\n{\n\treturn _rdma_nl_put_driver_u32(msg, name, RDMA_NLDEV_PRINT_TYPE_UNSPEC,\n\t\t\t\t       value);\n}\nEXPORT_SYMBOL(rdma_nl_put_driver_u32);\n\nint rdma_nl_put_driver_u32_hex(struct sk_buff *msg, const char *name,\n\t\t\t       u32 value)\n{\n\treturn _rdma_nl_put_driver_u32(msg, name, RDMA_NLDEV_PRINT_TYPE_HEX,\n\t\t\t\t       value);\n}\nEXPORT_SYMBOL(rdma_nl_put_driver_u32_hex);\n\nint rdma_nl_put_driver_u64(struct sk_buff *msg, const char *name, u64 value)\n{\n\treturn _rdma_nl_put_driver_u64(msg, name, RDMA_NLDEV_PRINT_TYPE_UNSPEC,\n\t\t\t\t       value);\n}\nEXPORT_SYMBOL(rdma_nl_put_driver_u64);\n\nint rdma_nl_put_driver_u64_hex(struct sk_buff *msg, const char *name, u64 value)\n{\n\treturn _rdma_nl_put_driver_u64(msg, name, RDMA_NLDEV_PRINT_TYPE_HEX,\n\t\t\t\t       value);\n}\nEXPORT_SYMBOL(rdma_nl_put_driver_u64_hex);\n\nstatic int fill_nldev_handle(struct sk_buff *msg, struct ib_device *device)\n{\n\tif (nla_put_u32(msg, RDMA_NLDEV_ATTR_DEV_INDEX, device->index))\n\t\treturn -EMSGSIZE;\n\tif (nla_put_string(msg, RDMA_NLDEV_ATTR_DEV_NAME,\n\t\t\t   dev_name(&device->dev)))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n\nstatic int fill_dev_info(struct sk_buff *msg, struct ib_device *device)\n{\n\tchar fw[IB_FW_VERSION_NAME_MAX];\n\tint ret = 0;\n\tu32 port;\n\n\tif (fill_nldev_handle(msg, device))\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_u32(msg, RDMA_NLDEV_ATTR_PORT_INDEX, rdma_end_port(device)))\n\t\treturn -EMSGSIZE;\n\n\tBUILD_BUG_ON(sizeof(device->attrs.device_cap_flags) != sizeof(u64));\n\tif (nla_put_u64_64bit(msg, RDMA_NLDEV_ATTR_CAP_FLAGS,\n\t\t\t      device->attrs.device_cap_flags,\n\t\t\t      RDMA_NLDEV_ATTR_PAD))\n\t\treturn -EMSGSIZE;\n\n\tib_get_device_fw_str(device, fw);\n\t \n\tif (strlen(fw) && nla_put_string(msg, RDMA_NLDEV_ATTR_FW_VERSION, fw))\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_u64_64bit(msg, RDMA_NLDEV_ATTR_NODE_GUID,\n\t\t\t      be64_to_cpu(device->node_guid),\n\t\t\t      RDMA_NLDEV_ATTR_PAD))\n\t\treturn -EMSGSIZE;\n\tif (nla_put_u64_64bit(msg, RDMA_NLDEV_ATTR_SYS_IMAGE_GUID,\n\t\t\t      be64_to_cpu(device->attrs.sys_image_guid),\n\t\t\t      RDMA_NLDEV_ATTR_PAD))\n\t\treturn -EMSGSIZE;\n\tif (nla_put_u8(msg, RDMA_NLDEV_ATTR_DEV_NODE_TYPE, device->node_type))\n\t\treturn -EMSGSIZE;\n\tif (nla_put_u8(msg, RDMA_NLDEV_ATTR_DEV_DIM, device->use_cq_dim))\n\t\treturn -EMSGSIZE;\n\n\t \n\tport = rdma_start_port(device);\n\tif (rdma_cap_opa_mad(device, port))\n\t\tret = nla_put_string(msg, RDMA_NLDEV_ATTR_DEV_PROTOCOL, \"opa\");\n\telse if (rdma_protocol_ib(device, port))\n\t\tret = nla_put_string(msg, RDMA_NLDEV_ATTR_DEV_PROTOCOL, \"ib\");\n\telse if (rdma_protocol_iwarp(device, port))\n\t\tret = nla_put_string(msg, RDMA_NLDEV_ATTR_DEV_PROTOCOL, \"iw\");\n\telse if (rdma_protocol_roce(device, port))\n\t\tret = nla_put_string(msg, RDMA_NLDEV_ATTR_DEV_PROTOCOL, \"roce\");\n\telse if (rdma_protocol_usnic(device, port))\n\t\tret = nla_put_string(msg, RDMA_NLDEV_ATTR_DEV_PROTOCOL,\n\t\t\t\t     \"usnic\");\n\treturn ret;\n}\n\nstatic int fill_port_info(struct sk_buff *msg,\n\t\t\t  struct ib_device *device, u32 port,\n\t\t\t  const struct net *net)\n{\n\tstruct net_device *netdev = NULL;\n\tstruct ib_port_attr attr;\n\tint ret;\n\tu64 cap_flags = 0;\n\n\tif (fill_nldev_handle(msg, device))\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_u32(msg, RDMA_NLDEV_ATTR_PORT_INDEX, port))\n\t\treturn -EMSGSIZE;\n\n\tret = ib_query_port(device, port, &attr);\n\tif (ret)\n\t\treturn ret;\n\n\tif (rdma_protocol_ib(device, port)) {\n\t\tBUILD_BUG_ON((sizeof(attr.port_cap_flags) +\n\t\t\t\tsizeof(attr.port_cap_flags2)) > sizeof(u64));\n\t\tcap_flags = attr.port_cap_flags |\n\t\t\t((u64)attr.port_cap_flags2 << 32);\n\t\tif (nla_put_u64_64bit(msg, RDMA_NLDEV_ATTR_CAP_FLAGS,\n\t\t\t\t      cap_flags, RDMA_NLDEV_ATTR_PAD))\n\t\t\treturn -EMSGSIZE;\n\t\tif (nla_put_u64_64bit(msg, RDMA_NLDEV_ATTR_SUBNET_PREFIX,\n\t\t\t\t      attr.subnet_prefix, RDMA_NLDEV_ATTR_PAD))\n\t\t\treturn -EMSGSIZE;\n\t\tif (nla_put_u32(msg, RDMA_NLDEV_ATTR_LID, attr.lid))\n\t\t\treturn -EMSGSIZE;\n\t\tif (nla_put_u32(msg, RDMA_NLDEV_ATTR_SM_LID, attr.sm_lid))\n\t\t\treturn -EMSGSIZE;\n\t\tif (nla_put_u8(msg, RDMA_NLDEV_ATTR_LMC, attr.lmc))\n\t\t\treturn -EMSGSIZE;\n\t}\n\tif (nla_put_u8(msg, RDMA_NLDEV_ATTR_PORT_STATE, attr.state))\n\t\treturn -EMSGSIZE;\n\tif (nla_put_u8(msg, RDMA_NLDEV_ATTR_PORT_PHYS_STATE, attr.phys_state))\n\t\treturn -EMSGSIZE;\n\n\tnetdev = ib_device_get_netdev(device, port);\n\tif (netdev && net_eq(dev_net(netdev), net)) {\n\t\tret = nla_put_u32(msg,\n\t\t\t\t  RDMA_NLDEV_ATTR_NDEV_INDEX, netdev->ifindex);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tret = nla_put_string(msg,\n\t\t\t\t     RDMA_NLDEV_ATTR_NDEV_NAME, netdev->name);\n\t}\n\nout:\n\tif (netdev)\n\t\tdev_put(netdev);\n\treturn ret;\n}\n\nstatic int fill_res_info_entry(struct sk_buff *msg,\n\t\t\t       const char *name, u64 curr)\n{\n\tstruct nlattr *entry_attr;\n\n\tentry_attr = nla_nest_start_noflag(msg,\n\t\t\t\t\t   RDMA_NLDEV_ATTR_RES_SUMMARY_ENTRY);\n\tif (!entry_attr)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_string(msg, RDMA_NLDEV_ATTR_RES_SUMMARY_ENTRY_NAME, name))\n\t\tgoto err;\n\tif (nla_put_u64_64bit(msg, RDMA_NLDEV_ATTR_RES_SUMMARY_ENTRY_CURR, curr,\n\t\t\t      RDMA_NLDEV_ATTR_PAD))\n\t\tgoto err;\n\n\tnla_nest_end(msg, entry_attr);\n\treturn 0;\n\nerr:\n\tnla_nest_cancel(msg, entry_attr);\n\treturn -EMSGSIZE;\n}\n\nstatic int fill_res_info(struct sk_buff *msg, struct ib_device *device)\n{\n\tstatic const char * const names[RDMA_RESTRACK_MAX] = {\n\t\t[RDMA_RESTRACK_PD] = \"pd\",\n\t\t[RDMA_RESTRACK_CQ] = \"cq\",\n\t\t[RDMA_RESTRACK_QP] = \"qp\",\n\t\t[RDMA_RESTRACK_CM_ID] = \"cm_id\",\n\t\t[RDMA_RESTRACK_MR] = \"mr\",\n\t\t[RDMA_RESTRACK_CTX] = \"ctx\",\n\t\t[RDMA_RESTRACK_SRQ] = \"srq\",\n\t};\n\n\tstruct nlattr *table_attr;\n\tint ret, i, curr;\n\n\tif (fill_nldev_handle(msg, device))\n\t\treturn -EMSGSIZE;\n\n\ttable_attr = nla_nest_start_noflag(msg, RDMA_NLDEV_ATTR_RES_SUMMARY);\n\tif (!table_attr)\n\t\treturn -EMSGSIZE;\n\n\tfor (i = 0; i < RDMA_RESTRACK_MAX; i++) {\n\t\tif (!names[i])\n\t\t\tcontinue;\n\t\tcurr = rdma_restrack_count(device, i);\n\t\tret = fill_res_info_entry(msg, names[i], curr);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tnla_nest_end(msg, table_attr);\n\treturn 0;\n\nerr:\n\tnla_nest_cancel(msg, table_attr);\n\treturn ret;\n}\n\nstatic int fill_res_name_pid(struct sk_buff *msg,\n\t\t\t     struct rdma_restrack_entry *res)\n{\n\tint err = 0;\n\n\t \n\tif (rdma_is_kernel_res(res)) {\n\t\terr = nla_put_string(msg, RDMA_NLDEV_ATTR_RES_KERN_NAME,\n\t\t\t\t     res->kern_name);\n\t} else {\n\t\tpid_t pid;\n\n\t\tpid = task_pid_vnr(res->task);\n\t\t \n\t\tif (pid)\n\t\t\t \n\t\t\terr = nla_put_u32(msg, RDMA_NLDEV_ATTR_RES_PID, pid);\n\t}\n\n\treturn err ? -EMSGSIZE : 0;\n}\n\nstatic int fill_res_qp_entry_query(struct sk_buff *msg,\n\t\t\t\t   struct rdma_restrack_entry *res,\n\t\t\t\t   struct ib_device *dev,\n\t\t\t\t   struct ib_qp *qp)\n{\n\tstruct ib_qp_init_attr qp_init_attr;\n\tstruct ib_qp_attr qp_attr;\n\tint ret;\n\n\tret = ib_query_qp(qp, &qp_attr, 0, &qp_init_attr);\n\tif (ret)\n\t\treturn ret;\n\n\tif (qp->qp_type == IB_QPT_RC || qp->qp_type == IB_QPT_UC) {\n\t\tif (nla_put_u32(msg, RDMA_NLDEV_ATTR_RES_RQPN,\n\t\t\t\tqp_attr.dest_qp_num))\n\t\t\tgoto err;\n\t\tif (nla_put_u32(msg, RDMA_NLDEV_ATTR_RES_RQ_PSN,\n\t\t\t\tqp_attr.rq_psn))\n\t\t\tgoto err;\n\t}\n\n\tif (nla_put_u32(msg, RDMA_NLDEV_ATTR_RES_SQ_PSN, qp_attr.sq_psn))\n\t\tgoto err;\n\n\tif (qp->qp_type == IB_QPT_RC || qp->qp_type == IB_QPT_UC ||\n\t    qp->qp_type == IB_QPT_XRC_INI || qp->qp_type == IB_QPT_XRC_TGT) {\n\t\tif (nla_put_u8(msg, RDMA_NLDEV_ATTR_RES_PATH_MIG_STATE,\n\t\t\t       qp_attr.path_mig_state))\n\t\t\tgoto err;\n\t}\n\tif (nla_put_u8(msg, RDMA_NLDEV_ATTR_RES_TYPE, qp->qp_type))\n\t\tgoto err;\n\tif (nla_put_u8(msg, RDMA_NLDEV_ATTR_RES_STATE, qp_attr.qp_state))\n\t\tgoto err;\n\n\tif (dev->ops.fill_res_qp_entry)\n\t\treturn dev->ops.fill_res_qp_entry(msg, qp);\n\treturn 0;\n\nerr:\treturn -EMSGSIZE;\n}\n\nstatic int fill_res_qp_entry(struct sk_buff *msg, bool has_cap_net_admin,\n\t\t\t     struct rdma_restrack_entry *res, uint32_t port)\n{\n\tstruct ib_qp *qp = container_of(res, struct ib_qp, res);\n\tstruct ib_device *dev = qp->device;\n\tint ret;\n\n\tif (port && port != qp->port)\n\t\treturn -EAGAIN;\n\n\t \n\tif (qp->port && nla_put_u32(msg, RDMA_NLDEV_ATTR_PORT_INDEX, qp->port))\n\t\treturn -EMSGSIZE;\n\n\tret = nla_put_u32(msg, RDMA_NLDEV_ATTR_RES_LQPN, qp->qp_num);\n\tif (ret)\n\t\treturn -EMSGSIZE;\n\n\tif (!rdma_is_kernel_res(res) &&\n\t    nla_put_u32(msg, RDMA_NLDEV_ATTR_RES_PDN, qp->pd->res.id))\n\t\treturn -EMSGSIZE;\n\n\tret = fill_res_name_pid(msg, res);\n\tif (ret)\n\t\treturn -EMSGSIZE;\n\n\treturn fill_res_qp_entry_query(msg, res, dev, qp);\n}\n\nstatic int fill_res_qp_raw_entry(struct sk_buff *msg, bool has_cap_net_admin,\n\t\t\t\t struct rdma_restrack_entry *res, uint32_t port)\n{\n\tstruct ib_qp *qp = container_of(res, struct ib_qp, res);\n\tstruct ib_device *dev = qp->device;\n\n\tif (port && port != qp->port)\n\t\treturn -EAGAIN;\n\tif (!dev->ops.fill_res_qp_entry_raw)\n\t\treturn -EINVAL;\n\treturn dev->ops.fill_res_qp_entry_raw(msg, qp);\n}\n\nstatic int fill_res_cm_id_entry(struct sk_buff *msg, bool has_cap_net_admin,\n\t\t\t\tstruct rdma_restrack_entry *res, uint32_t port)\n{\n\tstruct rdma_id_private *id_priv =\n\t\t\t\tcontainer_of(res, struct rdma_id_private, res);\n\tstruct ib_device *dev = id_priv->id.device;\n\tstruct rdma_cm_id *cm_id = &id_priv->id;\n\n\tif (port && port != cm_id->port_num)\n\t\treturn -EAGAIN;\n\n\tif (cm_id->port_num &&\n\t    nla_put_u32(msg, RDMA_NLDEV_ATTR_PORT_INDEX, cm_id->port_num))\n\t\tgoto err;\n\n\tif (id_priv->qp_num) {\n\t\tif (nla_put_u32(msg, RDMA_NLDEV_ATTR_RES_LQPN, id_priv->qp_num))\n\t\t\tgoto err;\n\t\tif (nla_put_u8(msg, RDMA_NLDEV_ATTR_RES_TYPE, cm_id->qp_type))\n\t\t\tgoto err;\n\t}\n\n\tif (nla_put_u32(msg, RDMA_NLDEV_ATTR_RES_PS, cm_id->ps))\n\t\tgoto err;\n\n\tif (nla_put_u8(msg, RDMA_NLDEV_ATTR_RES_STATE, id_priv->state))\n\t\tgoto err;\n\n\tif (cm_id->route.addr.src_addr.ss_family &&\n\t    nla_put(msg, RDMA_NLDEV_ATTR_RES_SRC_ADDR,\n\t\t    sizeof(cm_id->route.addr.src_addr),\n\t\t    &cm_id->route.addr.src_addr))\n\t\tgoto err;\n\tif (cm_id->route.addr.dst_addr.ss_family &&\n\t    nla_put(msg, RDMA_NLDEV_ATTR_RES_DST_ADDR,\n\t\t    sizeof(cm_id->route.addr.dst_addr),\n\t\t    &cm_id->route.addr.dst_addr))\n\t\tgoto err;\n\n\tif (nla_put_u32(msg, RDMA_NLDEV_ATTR_RES_CM_IDN, res->id))\n\t\tgoto err;\n\n\tif (fill_res_name_pid(msg, res))\n\t\tgoto err;\n\n\tif (dev->ops.fill_res_cm_id_entry)\n\t\treturn dev->ops.fill_res_cm_id_entry(msg, cm_id);\n\treturn 0;\n\nerr: return -EMSGSIZE;\n}\n\nstatic int fill_res_cq_entry(struct sk_buff *msg, bool has_cap_net_admin,\n\t\t\t     struct rdma_restrack_entry *res, uint32_t port)\n{\n\tstruct ib_cq *cq = container_of(res, struct ib_cq, res);\n\tstruct ib_device *dev = cq->device;\n\n\tif (nla_put_u32(msg, RDMA_NLDEV_ATTR_RES_CQE, cq->cqe))\n\t\treturn -EMSGSIZE;\n\tif (nla_put_u64_64bit(msg, RDMA_NLDEV_ATTR_RES_USECNT,\n\t\t\t      atomic_read(&cq->usecnt), RDMA_NLDEV_ATTR_PAD))\n\t\treturn -EMSGSIZE;\n\n\t \n\tif (rdma_is_kernel_res(res) &&\n\t    nla_put_u8(msg, RDMA_NLDEV_ATTR_RES_POLL_CTX, cq->poll_ctx))\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_u8(msg, RDMA_NLDEV_ATTR_DEV_DIM, (cq->dim != NULL)))\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_u32(msg, RDMA_NLDEV_ATTR_RES_CQN, res->id))\n\t\treturn -EMSGSIZE;\n\tif (!rdma_is_kernel_res(res) &&\n\t    nla_put_u32(msg, RDMA_NLDEV_ATTR_RES_CTXN,\n\t\t\tcq->uobject->uevent.uobject.context->res.id))\n\t\treturn -EMSGSIZE;\n\n\tif (fill_res_name_pid(msg, res))\n\t\treturn -EMSGSIZE;\n\n\treturn (dev->ops.fill_res_cq_entry) ?\n\t\tdev->ops.fill_res_cq_entry(msg, cq) : 0;\n}\n\nstatic int fill_res_cq_raw_entry(struct sk_buff *msg, bool has_cap_net_admin,\n\t\t\t\t struct rdma_restrack_entry *res, uint32_t port)\n{\n\tstruct ib_cq *cq = container_of(res, struct ib_cq, res);\n\tstruct ib_device *dev = cq->device;\n\n\tif (!dev->ops.fill_res_cq_entry_raw)\n\t\treturn -EINVAL;\n\treturn dev->ops.fill_res_cq_entry_raw(msg, cq);\n}\n\nstatic int fill_res_mr_entry(struct sk_buff *msg, bool has_cap_net_admin,\n\t\t\t     struct rdma_restrack_entry *res, uint32_t port)\n{\n\tstruct ib_mr *mr = container_of(res, struct ib_mr, res);\n\tstruct ib_device *dev = mr->pd->device;\n\n\tif (has_cap_net_admin) {\n\t\tif (nla_put_u32(msg, RDMA_NLDEV_ATTR_RES_RKEY, mr->rkey))\n\t\t\treturn -EMSGSIZE;\n\t\tif (nla_put_u32(msg, RDMA_NLDEV_ATTR_RES_LKEY, mr->lkey))\n\t\t\treturn -EMSGSIZE;\n\t}\n\n\tif (nla_put_u64_64bit(msg, RDMA_NLDEV_ATTR_RES_MRLEN, mr->length,\n\t\t\t      RDMA_NLDEV_ATTR_PAD))\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_u32(msg, RDMA_NLDEV_ATTR_RES_MRN, res->id))\n\t\treturn -EMSGSIZE;\n\n\tif (!rdma_is_kernel_res(res) &&\n\t    nla_put_u32(msg, RDMA_NLDEV_ATTR_RES_PDN, mr->pd->res.id))\n\t\treturn -EMSGSIZE;\n\n\tif (fill_res_name_pid(msg, res))\n\t\treturn -EMSGSIZE;\n\n\treturn (dev->ops.fill_res_mr_entry) ?\n\t\t       dev->ops.fill_res_mr_entry(msg, mr) :\n\t\t       0;\n}\n\nstatic int fill_res_mr_raw_entry(struct sk_buff *msg, bool has_cap_net_admin,\n\t\t\t\t struct rdma_restrack_entry *res, uint32_t port)\n{\n\tstruct ib_mr *mr = container_of(res, struct ib_mr, res);\n\tstruct ib_device *dev = mr->pd->device;\n\n\tif (!dev->ops.fill_res_mr_entry_raw)\n\t\treturn -EINVAL;\n\treturn dev->ops.fill_res_mr_entry_raw(msg, mr);\n}\n\nstatic int fill_res_pd_entry(struct sk_buff *msg, bool has_cap_net_admin,\n\t\t\t     struct rdma_restrack_entry *res, uint32_t port)\n{\n\tstruct ib_pd *pd = container_of(res, struct ib_pd, res);\n\n\tif (has_cap_net_admin) {\n\t\tif (nla_put_u32(msg, RDMA_NLDEV_ATTR_RES_LOCAL_DMA_LKEY,\n\t\t\t\tpd->local_dma_lkey))\n\t\t\tgoto err;\n\t\tif ((pd->flags & IB_PD_UNSAFE_GLOBAL_RKEY) &&\n\t\t    nla_put_u32(msg, RDMA_NLDEV_ATTR_RES_UNSAFE_GLOBAL_RKEY,\n\t\t\t\tpd->unsafe_global_rkey))\n\t\t\tgoto err;\n\t}\n\tif (nla_put_u64_64bit(msg, RDMA_NLDEV_ATTR_RES_USECNT,\n\t\t\t      atomic_read(&pd->usecnt), RDMA_NLDEV_ATTR_PAD))\n\t\tgoto err;\n\n\tif (nla_put_u32(msg, RDMA_NLDEV_ATTR_RES_PDN, res->id))\n\t\tgoto err;\n\n\tif (!rdma_is_kernel_res(res) &&\n\t    nla_put_u32(msg, RDMA_NLDEV_ATTR_RES_CTXN,\n\t\t\tpd->uobject->context->res.id))\n\t\tgoto err;\n\n\treturn fill_res_name_pid(msg, res);\n\nerr:\treturn -EMSGSIZE;\n}\n\nstatic int fill_res_ctx_entry(struct sk_buff *msg, bool has_cap_net_admin,\n\t\t\t      struct rdma_restrack_entry *res, uint32_t port)\n{\n\tstruct ib_ucontext *ctx = container_of(res, struct ib_ucontext, res);\n\n\tif (rdma_is_kernel_res(res))\n\t\treturn 0;\n\n\tif (nla_put_u32(msg, RDMA_NLDEV_ATTR_RES_CTXN, ctx->res.id))\n\t\treturn -EMSGSIZE;\n\n\treturn fill_res_name_pid(msg, res);\n}\n\nstatic int fill_res_range_qp_entry(struct sk_buff *msg, uint32_t min_range,\n\t\t\t\t   uint32_t max_range)\n{\n\tstruct nlattr *entry_attr;\n\n\tif (!min_range)\n\t\treturn 0;\n\n\tentry_attr = nla_nest_start(msg, RDMA_NLDEV_ATTR_RES_QP_ENTRY);\n\tif (!entry_attr)\n\t\treturn -EMSGSIZE;\n\n\tif (min_range == max_range) {\n\t\tif (nla_put_u32(msg, RDMA_NLDEV_ATTR_RES_LQPN, min_range))\n\t\t\tgoto err;\n\t} else {\n\t\tif (nla_put_u32(msg, RDMA_NLDEV_ATTR_MIN_RANGE, min_range))\n\t\t\tgoto err;\n\t\tif (nla_put_u32(msg, RDMA_NLDEV_ATTR_MAX_RANGE, max_range))\n\t\t\tgoto err;\n\t}\n\tnla_nest_end(msg, entry_attr);\n\treturn 0;\n\nerr:\n\tnla_nest_cancel(msg, entry_attr);\n\treturn -EMSGSIZE;\n}\n\nstatic int fill_res_srq_qps(struct sk_buff *msg, struct ib_srq *srq)\n{\n\tuint32_t min_range = 0, prev = 0;\n\tstruct rdma_restrack_entry *res;\n\tstruct rdma_restrack_root *rt;\n\tstruct nlattr *table_attr;\n\tstruct ib_qp *qp = NULL;\n\tunsigned long id = 0;\n\n\ttable_attr = nla_nest_start(msg, RDMA_NLDEV_ATTR_RES_QP);\n\tif (!table_attr)\n\t\treturn -EMSGSIZE;\n\n\trt = &srq->device->res[RDMA_RESTRACK_QP];\n\txa_lock(&rt->xa);\n\txa_for_each(&rt->xa, id, res) {\n\t\tif (!rdma_restrack_get(res))\n\t\t\tcontinue;\n\n\t\tqp = container_of(res, struct ib_qp, res);\n\t\tif (!qp->srq || (qp->srq->res.id != srq->res.id)) {\n\t\t\trdma_restrack_put(res);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (qp->qp_num < prev)\n\t\t\t \n\t\t\tgoto err_loop;\n\n\t\tif (min_range == 0) {\n\t\t\tmin_range = qp->qp_num;\n\t\t} else if (qp->qp_num > (prev + 1)) {\n\t\t\tif (fill_res_range_qp_entry(msg, min_range, prev))\n\t\t\t\tgoto err_loop;\n\n\t\t\tmin_range = qp->qp_num;\n\t\t}\n\t\tprev = qp->qp_num;\n\t\trdma_restrack_put(res);\n\t}\n\n\txa_unlock(&rt->xa);\n\n\tif (fill_res_range_qp_entry(msg, min_range, prev))\n\t\tgoto err;\n\n\tnla_nest_end(msg, table_attr);\n\treturn 0;\n\nerr_loop:\n\trdma_restrack_put(res);\n\txa_unlock(&rt->xa);\nerr:\n\tnla_nest_cancel(msg, table_attr);\n\treturn -EMSGSIZE;\n}\n\nstatic int fill_res_srq_entry(struct sk_buff *msg, bool has_cap_net_admin,\n\t\t\t      struct rdma_restrack_entry *res, uint32_t port)\n{\n\tstruct ib_srq *srq = container_of(res, struct ib_srq, res);\n\n\tif (nla_put_u32(msg, RDMA_NLDEV_ATTR_RES_SRQN, srq->res.id))\n\t\tgoto err;\n\n\tif (nla_put_u8(msg, RDMA_NLDEV_ATTR_RES_TYPE, srq->srq_type))\n\t\tgoto err;\n\n\tif (nla_put_u32(msg, RDMA_NLDEV_ATTR_RES_PDN, srq->pd->res.id))\n\t\tgoto err;\n\n\tif (ib_srq_has_cq(srq->srq_type)) {\n\t\tif (nla_put_u32(msg, RDMA_NLDEV_ATTR_RES_CQN,\n\t\t\t\tsrq->ext.cq->res.id))\n\t\t\tgoto err;\n\t}\n\n\tif (fill_res_srq_qps(msg, srq))\n\t\tgoto err;\n\n\treturn fill_res_name_pid(msg, res);\n\nerr:\n\treturn -EMSGSIZE;\n}\n\nstatic int fill_stat_counter_mode(struct sk_buff *msg,\n\t\t\t\t  struct rdma_counter *counter)\n{\n\tstruct rdma_counter_mode *m = &counter->mode;\n\n\tif (nla_put_u32(msg, RDMA_NLDEV_ATTR_STAT_MODE, m->mode))\n\t\treturn -EMSGSIZE;\n\n\tif (m->mode == RDMA_COUNTER_MODE_AUTO) {\n\t\tif ((m->mask & RDMA_COUNTER_MASK_QP_TYPE) &&\n\t\t    nla_put_u8(msg, RDMA_NLDEV_ATTR_RES_TYPE, m->param.qp_type))\n\t\t\treturn -EMSGSIZE;\n\n\t\tif ((m->mask & RDMA_COUNTER_MASK_PID) &&\n\t\t    fill_res_name_pid(msg, &counter->res))\n\t\t\treturn -EMSGSIZE;\n\t}\n\n\treturn 0;\n}\n\nstatic int fill_stat_counter_qp_entry(struct sk_buff *msg, u32 qpn)\n{\n\tstruct nlattr *entry_attr;\n\n\tentry_attr = nla_nest_start(msg, RDMA_NLDEV_ATTR_RES_QP_ENTRY);\n\tif (!entry_attr)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_u32(msg, RDMA_NLDEV_ATTR_RES_LQPN, qpn))\n\t\tgoto err;\n\n\tnla_nest_end(msg, entry_attr);\n\treturn 0;\n\nerr:\n\tnla_nest_cancel(msg, entry_attr);\n\treturn -EMSGSIZE;\n}\n\nstatic int fill_stat_counter_qps(struct sk_buff *msg,\n\t\t\t\t struct rdma_counter *counter)\n{\n\tstruct rdma_restrack_entry *res;\n\tstruct rdma_restrack_root *rt;\n\tstruct nlattr *table_attr;\n\tstruct ib_qp *qp = NULL;\n\tunsigned long id = 0;\n\tint ret = 0;\n\n\ttable_attr = nla_nest_start(msg, RDMA_NLDEV_ATTR_RES_QP);\n\tif (!table_attr)\n\t\treturn -EMSGSIZE;\n\n\trt = &counter->device->res[RDMA_RESTRACK_QP];\n\txa_lock(&rt->xa);\n\txa_for_each(&rt->xa, id, res) {\n\t\tqp = container_of(res, struct ib_qp, res);\n\t\tif (!qp->counter || (qp->counter->id != counter->id))\n\t\t\tcontinue;\n\n\t\tret = fill_stat_counter_qp_entry(msg, qp->qp_num);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\txa_unlock(&rt->xa);\n\tnla_nest_end(msg, table_attr);\n\treturn 0;\n\nerr:\n\txa_unlock(&rt->xa);\n\tnla_nest_cancel(msg, table_attr);\n\treturn ret;\n}\n\nint rdma_nl_stat_hwcounter_entry(struct sk_buff *msg, const char *name,\n\t\t\t\t u64 value)\n{\n\tstruct nlattr *entry_attr;\n\n\tentry_attr = nla_nest_start(msg, RDMA_NLDEV_ATTR_STAT_HWCOUNTER_ENTRY);\n\tif (!entry_attr)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_string(msg, RDMA_NLDEV_ATTR_STAT_HWCOUNTER_ENTRY_NAME,\n\t\t\t   name))\n\t\tgoto err;\n\tif (nla_put_u64_64bit(msg, RDMA_NLDEV_ATTR_STAT_HWCOUNTER_ENTRY_VALUE,\n\t\t\t      value, RDMA_NLDEV_ATTR_PAD))\n\t\tgoto err;\n\n\tnla_nest_end(msg, entry_attr);\n\treturn 0;\n\nerr:\n\tnla_nest_cancel(msg, entry_attr);\n\treturn -EMSGSIZE;\n}\nEXPORT_SYMBOL(rdma_nl_stat_hwcounter_entry);\n\nstatic int fill_stat_mr_entry(struct sk_buff *msg, bool has_cap_net_admin,\n\t\t\t      struct rdma_restrack_entry *res, uint32_t port)\n{\n\tstruct ib_mr *mr = container_of(res, struct ib_mr, res);\n\tstruct ib_device *dev = mr->pd->device;\n\n\tif (nla_put_u32(msg, RDMA_NLDEV_ATTR_RES_MRN, res->id))\n\t\tgoto err;\n\n\tif (dev->ops.fill_stat_mr_entry)\n\t\treturn dev->ops.fill_stat_mr_entry(msg, mr);\n\treturn 0;\n\nerr:\n\treturn -EMSGSIZE;\n}\n\nstatic int fill_stat_counter_hwcounters(struct sk_buff *msg,\n\t\t\t\t\tstruct rdma_counter *counter)\n{\n\tstruct rdma_hw_stats *st = counter->stats;\n\tstruct nlattr *table_attr;\n\tint i;\n\n\ttable_attr = nla_nest_start(msg, RDMA_NLDEV_ATTR_STAT_HWCOUNTERS);\n\tif (!table_attr)\n\t\treturn -EMSGSIZE;\n\n\tmutex_lock(&st->lock);\n\tfor (i = 0; i < st->num_counters; i++) {\n\t\tif (test_bit(i, st->is_disabled))\n\t\t\tcontinue;\n\t\tif (rdma_nl_stat_hwcounter_entry(msg, st->descs[i].name,\n\t\t\t\t\t\t st->value[i]))\n\t\t\tgoto err;\n\t}\n\tmutex_unlock(&st->lock);\n\n\tnla_nest_end(msg, table_attr);\n\treturn 0;\n\nerr:\n\tmutex_unlock(&st->lock);\n\tnla_nest_cancel(msg, table_attr);\n\treturn -EMSGSIZE;\n}\n\nstatic int fill_res_counter_entry(struct sk_buff *msg, bool has_cap_net_admin,\n\t\t\t\t  struct rdma_restrack_entry *res,\n\t\t\t\t  uint32_t port)\n{\n\tstruct rdma_counter *counter =\n\t\tcontainer_of(res, struct rdma_counter, res);\n\n\tif (port && port != counter->port)\n\t\treturn -EAGAIN;\n\n\t \n\trdma_counter_query_stats(counter);\n\n\tif (nla_put_u32(msg, RDMA_NLDEV_ATTR_PORT_INDEX, counter->port) ||\n\t    nla_put_u32(msg, RDMA_NLDEV_ATTR_STAT_COUNTER_ID, counter->id) ||\n\t    fill_stat_counter_mode(msg, counter) ||\n\t    fill_stat_counter_qps(msg, counter) ||\n\t    fill_stat_counter_hwcounters(msg, counter))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n\nstatic int nldev_get_doit(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[RDMA_NLDEV_ATTR_MAX];\n\tstruct ib_device *device;\n\tstruct sk_buff *msg;\n\tu32 index;\n\tint err;\n\n\terr = nlmsg_parse_deprecated(nlh, 0, tb, RDMA_NLDEV_ATTR_MAX - 1,\n\t\t\t\t     nldev_policy, extack);\n\tif (err || !tb[RDMA_NLDEV_ATTR_DEV_INDEX])\n\t\treturn -EINVAL;\n\n\tindex = nla_get_u32(tb[RDMA_NLDEV_ATTR_DEV_INDEX]);\n\n\tdevice = ib_device_get_by_index(sock_net(skb->sk), index);\n\tif (!device)\n\t\treturn -EINVAL;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg) {\n\t\terr = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tnlh = nlmsg_put(msg, NETLINK_CB(skb).portid, nlh->nlmsg_seq,\n\t\t\tRDMA_NL_GET_TYPE(RDMA_NL_NLDEV, RDMA_NLDEV_CMD_GET),\n\t\t\t0, 0);\n\tif (!nlh) {\n\t\terr = -EMSGSIZE;\n\t\tgoto err_free;\n\t}\n\n\terr = fill_dev_info(msg, device);\n\tif (err)\n\t\tgoto err_free;\n\n\tnlmsg_end(msg, nlh);\n\n\tib_device_put(device);\n\treturn rdma_nl_unicast(sock_net(skb->sk), msg, NETLINK_CB(skb).portid);\n\nerr_free:\n\tnlmsg_free(msg);\nerr:\n\tib_device_put(device);\n\treturn err;\n}\n\nstatic int nldev_set_doit(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[RDMA_NLDEV_ATTR_MAX];\n\tstruct ib_device *device;\n\tu32 index;\n\tint err;\n\n\terr = nlmsg_parse_deprecated(nlh, 0, tb, RDMA_NLDEV_ATTR_MAX - 1,\n\t\t\t\t     nldev_policy, extack);\n\tif (err || !tb[RDMA_NLDEV_ATTR_DEV_INDEX])\n\t\treturn -EINVAL;\n\n\tindex = nla_get_u32(tb[RDMA_NLDEV_ATTR_DEV_INDEX]);\n\tdevice = ib_device_get_by_index(sock_net(skb->sk), index);\n\tif (!device)\n\t\treturn -EINVAL;\n\n\tif (tb[RDMA_NLDEV_ATTR_DEV_NAME]) {\n\t\tchar name[IB_DEVICE_NAME_MAX] = {};\n\n\t\tnla_strscpy(name, tb[RDMA_NLDEV_ATTR_DEV_NAME],\n\t\t\t    IB_DEVICE_NAME_MAX);\n\t\tif (strlen(name) == 0) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\t\terr = ib_device_rename(device, name);\n\t\tgoto done;\n\t}\n\n\tif (tb[RDMA_NLDEV_NET_NS_FD]) {\n\t\tu32 ns_fd;\n\n\t\tns_fd = nla_get_u32(tb[RDMA_NLDEV_NET_NS_FD]);\n\t\terr = ib_device_set_netns_put(skb, device, ns_fd);\n\t\tgoto put_done;\n\t}\n\n\tif (tb[RDMA_NLDEV_ATTR_DEV_DIM]) {\n\t\tu8 use_dim;\n\n\t\tuse_dim = nla_get_u8(tb[RDMA_NLDEV_ATTR_DEV_DIM]);\n\t\terr = ib_device_set_dim(device,  use_dim);\n\t\tgoto done;\n\t}\n\ndone:\n\tib_device_put(device);\nput_done:\n\treturn err;\n}\n\nstatic int _nldev_get_dumpit(struct ib_device *device,\n\t\t\t     struct sk_buff *skb,\n\t\t\t     struct netlink_callback *cb,\n\t\t\t     unsigned int idx)\n{\n\tint start = cb->args[0];\n\tstruct nlmsghdr *nlh;\n\n\tif (idx < start)\n\t\treturn 0;\n\n\tnlh = nlmsg_put(skb, NETLINK_CB(cb->skb).portid, cb->nlh->nlmsg_seq,\n\t\t\tRDMA_NL_GET_TYPE(RDMA_NL_NLDEV, RDMA_NLDEV_CMD_GET),\n\t\t\t0, NLM_F_MULTI);\n\n\tif (!nlh || fill_dev_info(skb, device)) {\n\t\tnlmsg_cancel(skb, nlh);\n\t\tgoto out;\n\t}\n\n\tnlmsg_end(skb, nlh);\n\n\tidx++;\n\nout:\tcb->args[0] = idx;\n\treturn skb->len;\n}\n\nstatic int nldev_get_dumpit(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\t \n\treturn ib_enum_all_devs(_nldev_get_dumpit, skb, cb);\n}\n\nstatic int nldev_port_get_doit(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[RDMA_NLDEV_ATTR_MAX];\n\tstruct ib_device *device;\n\tstruct sk_buff *msg;\n\tu32 index;\n\tu32 port;\n\tint err;\n\n\terr = nlmsg_parse_deprecated(nlh, 0, tb, RDMA_NLDEV_ATTR_MAX - 1,\n\t\t\t\t     nldev_policy, extack);\n\tif (err ||\n\t    !tb[RDMA_NLDEV_ATTR_DEV_INDEX] ||\n\t    !tb[RDMA_NLDEV_ATTR_PORT_INDEX])\n\t\treturn -EINVAL;\n\n\tindex = nla_get_u32(tb[RDMA_NLDEV_ATTR_DEV_INDEX]);\n\tdevice = ib_device_get_by_index(sock_net(skb->sk), index);\n\tif (!device)\n\t\treturn -EINVAL;\n\n\tport = nla_get_u32(tb[RDMA_NLDEV_ATTR_PORT_INDEX]);\n\tif (!rdma_is_port_valid(device, port)) {\n\t\terr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg) {\n\t\terr = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tnlh = nlmsg_put(msg, NETLINK_CB(skb).portid, nlh->nlmsg_seq,\n\t\t\tRDMA_NL_GET_TYPE(RDMA_NL_NLDEV, RDMA_NLDEV_CMD_GET),\n\t\t\t0, 0);\n\tif (!nlh) {\n\t\terr = -EMSGSIZE;\n\t\tgoto err_free;\n\t}\n\n\terr = fill_port_info(msg, device, port, sock_net(skb->sk));\n\tif (err)\n\t\tgoto err_free;\n\n\tnlmsg_end(msg, nlh);\n\tib_device_put(device);\n\n\treturn rdma_nl_unicast(sock_net(skb->sk), msg, NETLINK_CB(skb).portid);\n\nerr_free:\n\tnlmsg_free(msg);\nerr:\n\tib_device_put(device);\n\treturn err;\n}\n\nstatic int nldev_port_get_dumpit(struct sk_buff *skb,\n\t\t\t\t struct netlink_callback *cb)\n{\n\tstruct nlattr *tb[RDMA_NLDEV_ATTR_MAX];\n\tstruct ib_device *device;\n\tint start = cb->args[0];\n\tstruct nlmsghdr *nlh;\n\tu32 idx = 0;\n\tu32 ifindex;\n\tint err;\n\tunsigned int p;\n\n\terr = nlmsg_parse_deprecated(cb->nlh, 0, tb, RDMA_NLDEV_ATTR_MAX - 1,\n\t\t\t\t     nldev_policy, NULL);\n\tif (err || !tb[RDMA_NLDEV_ATTR_DEV_INDEX])\n\t\treturn -EINVAL;\n\n\tifindex = nla_get_u32(tb[RDMA_NLDEV_ATTR_DEV_INDEX]);\n\tdevice = ib_device_get_by_index(sock_net(skb->sk), ifindex);\n\tif (!device)\n\t\treturn -EINVAL;\n\n\trdma_for_each_port (device, p) {\n\t\t \n\t\tif (idx < start) {\n\t\t\tidx++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tnlh = nlmsg_put(skb, NETLINK_CB(cb->skb).portid,\n\t\t\t\tcb->nlh->nlmsg_seq,\n\t\t\t\tRDMA_NL_GET_TYPE(RDMA_NL_NLDEV,\n\t\t\t\t\t\t RDMA_NLDEV_CMD_PORT_GET),\n\t\t\t\t0, NLM_F_MULTI);\n\n\t\tif (!nlh || fill_port_info(skb, device, p, sock_net(skb->sk))) {\n\t\t\tnlmsg_cancel(skb, nlh);\n\t\t\tgoto out;\n\t\t}\n\t\tidx++;\n\t\tnlmsg_end(skb, nlh);\n\t}\n\nout:\n\tib_device_put(device);\n\tcb->args[0] = idx;\n\treturn skb->len;\n}\n\nstatic int nldev_res_get_doit(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[RDMA_NLDEV_ATTR_MAX];\n\tstruct ib_device *device;\n\tstruct sk_buff *msg;\n\tu32 index;\n\tint ret;\n\n\tret = nlmsg_parse_deprecated(nlh, 0, tb, RDMA_NLDEV_ATTR_MAX - 1,\n\t\t\t\t     nldev_policy, extack);\n\tif (ret || !tb[RDMA_NLDEV_ATTR_DEV_INDEX])\n\t\treturn -EINVAL;\n\n\tindex = nla_get_u32(tb[RDMA_NLDEV_ATTR_DEV_INDEX]);\n\tdevice = ib_device_get_by_index(sock_net(skb->sk), index);\n\tif (!device)\n\t\treturn -EINVAL;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tnlh = nlmsg_put(msg, NETLINK_CB(skb).portid, nlh->nlmsg_seq,\n\t\t\tRDMA_NL_GET_TYPE(RDMA_NL_NLDEV, RDMA_NLDEV_CMD_RES_GET),\n\t\t\t0, 0);\n\tif (!nlh) {\n\t\tret = -EMSGSIZE;\n\t\tgoto err_free;\n\t}\n\n\tret = fill_res_info(msg, device);\n\tif (ret)\n\t\tgoto err_free;\n\n\tnlmsg_end(msg, nlh);\n\tib_device_put(device);\n\treturn rdma_nl_unicast(sock_net(skb->sk), msg, NETLINK_CB(skb).portid);\n\nerr_free:\n\tnlmsg_free(msg);\nerr:\n\tib_device_put(device);\n\treturn ret;\n}\n\nstatic int _nldev_res_get_dumpit(struct ib_device *device,\n\t\t\t\t struct sk_buff *skb,\n\t\t\t\t struct netlink_callback *cb,\n\t\t\t\t unsigned int idx)\n{\n\tint start = cb->args[0];\n\tstruct nlmsghdr *nlh;\n\n\tif (idx < start)\n\t\treturn 0;\n\n\tnlh = nlmsg_put(skb, NETLINK_CB(cb->skb).portid, cb->nlh->nlmsg_seq,\n\t\t\tRDMA_NL_GET_TYPE(RDMA_NL_NLDEV, RDMA_NLDEV_CMD_RES_GET),\n\t\t\t0, NLM_F_MULTI);\n\n\tif (!nlh || fill_res_info(skb, device)) {\n\t\tnlmsg_cancel(skb, nlh);\n\t\tgoto out;\n\t}\n\tnlmsg_end(skb, nlh);\n\n\tidx++;\n\nout:\n\tcb->args[0] = idx;\n\treturn skb->len;\n}\n\nstatic int nldev_res_get_dumpit(struct sk_buff *skb,\n\t\t\t\tstruct netlink_callback *cb)\n{\n\treturn ib_enum_all_devs(_nldev_res_get_dumpit, skb, cb);\n}\n\nstruct nldev_fill_res_entry {\n\tenum rdma_nldev_attr nldev_attr;\n\tu8 flags;\n\tu32 entry;\n\tu32 id;\n};\n\nenum nldev_res_flags {\n\tNLDEV_PER_DEV = 1 << 0,\n};\n\nstatic const struct nldev_fill_res_entry fill_entries[RDMA_RESTRACK_MAX] = {\n\t[RDMA_RESTRACK_QP] = {\n\t\t.nldev_attr = RDMA_NLDEV_ATTR_RES_QP,\n\t\t.entry = RDMA_NLDEV_ATTR_RES_QP_ENTRY,\n\t\t.id = RDMA_NLDEV_ATTR_RES_LQPN,\n\t},\n\t[RDMA_RESTRACK_CM_ID] = {\n\t\t.nldev_attr = RDMA_NLDEV_ATTR_RES_CM_ID,\n\t\t.entry = RDMA_NLDEV_ATTR_RES_CM_ID_ENTRY,\n\t\t.id = RDMA_NLDEV_ATTR_RES_CM_IDN,\n\t},\n\t[RDMA_RESTRACK_CQ] = {\n\t\t.nldev_attr = RDMA_NLDEV_ATTR_RES_CQ,\n\t\t.flags = NLDEV_PER_DEV,\n\t\t.entry = RDMA_NLDEV_ATTR_RES_CQ_ENTRY,\n\t\t.id = RDMA_NLDEV_ATTR_RES_CQN,\n\t},\n\t[RDMA_RESTRACK_MR] = {\n\t\t.nldev_attr = RDMA_NLDEV_ATTR_RES_MR,\n\t\t.flags = NLDEV_PER_DEV,\n\t\t.entry = RDMA_NLDEV_ATTR_RES_MR_ENTRY,\n\t\t.id = RDMA_NLDEV_ATTR_RES_MRN,\n\t},\n\t[RDMA_RESTRACK_PD] = {\n\t\t.nldev_attr = RDMA_NLDEV_ATTR_RES_PD,\n\t\t.flags = NLDEV_PER_DEV,\n\t\t.entry = RDMA_NLDEV_ATTR_RES_PD_ENTRY,\n\t\t.id = RDMA_NLDEV_ATTR_RES_PDN,\n\t},\n\t[RDMA_RESTRACK_COUNTER] = {\n\t\t.nldev_attr = RDMA_NLDEV_ATTR_STAT_COUNTER,\n\t\t.entry = RDMA_NLDEV_ATTR_STAT_COUNTER_ENTRY,\n\t\t.id = RDMA_NLDEV_ATTR_STAT_COUNTER_ID,\n\t},\n\t[RDMA_RESTRACK_CTX] = {\n\t\t.nldev_attr = RDMA_NLDEV_ATTR_RES_CTX,\n\t\t.flags = NLDEV_PER_DEV,\n\t\t.entry = RDMA_NLDEV_ATTR_RES_CTX_ENTRY,\n\t\t.id = RDMA_NLDEV_ATTR_RES_CTXN,\n\t},\n\t[RDMA_RESTRACK_SRQ] = {\n\t\t.nldev_attr = RDMA_NLDEV_ATTR_RES_SRQ,\n\t\t.flags = NLDEV_PER_DEV,\n\t\t.entry = RDMA_NLDEV_ATTR_RES_SRQ_ENTRY,\n\t\t.id = RDMA_NLDEV_ATTR_RES_SRQN,\n\t},\n\n};\n\nstatic int res_get_common_doit(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t       struct netlink_ext_ack *extack,\n\t\t\t       enum rdma_restrack_type res_type,\n\t\t\t       res_fill_func_t fill_func)\n{\n\tconst struct nldev_fill_res_entry *fe = &fill_entries[res_type];\n\tstruct nlattr *tb[RDMA_NLDEV_ATTR_MAX];\n\tstruct rdma_restrack_entry *res;\n\tstruct ib_device *device;\n\tu32 index, id, port = 0;\n\tbool has_cap_net_admin;\n\tstruct sk_buff *msg;\n\tint ret;\n\n\tret = nlmsg_parse_deprecated(nlh, 0, tb, RDMA_NLDEV_ATTR_MAX - 1,\n\t\t\t\t     nldev_policy, extack);\n\tif (ret || !tb[RDMA_NLDEV_ATTR_DEV_INDEX] || !fe->id || !tb[fe->id])\n\t\treturn -EINVAL;\n\n\tindex = nla_get_u32(tb[RDMA_NLDEV_ATTR_DEV_INDEX]);\n\tdevice = ib_device_get_by_index(sock_net(skb->sk), index);\n\tif (!device)\n\t\treturn -EINVAL;\n\n\tif (tb[RDMA_NLDEV_ATTR_PORT_INDEX]) {\n\t\tport = nla_get_u32(tb[RDMA_NLDEV_ATTR_PORT_INDEX]);\n\t\tif (!rdma_is_port_valid(device, port)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tif ((port && fe->flags & NLDEV_PER_DEV) ||\n\t    (!port && ~fe->flags & NLDEV_PER_DEV)) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tid = nla_get_u32(tb[fe->id]);\n\tres = rdma_restrack_get_byid(device, res_type, id);\n\tif (IS_ERR(res)) {\n\t\tret = PTR_ERR(res);\n\t\tgoto err;\n\t}\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg) {\n\t\tret = -ENOMEM;\n\t\tgoto err_get;\n\t}\n\n\tnlh = nlmsg_put(msg, NETLINK_CB(skb).portid, nlh->nlmsg_seq,\n\t\t\tRDMA_NL_GET_TYPE(RDMA_NL_NLDEV,\n\t\t\t\t\t RDMA_NL_GET_OP(nlh->nlmsg_type)),\n\t\t\t0, 0);\n\n\tif (!nlh || fill_nldev_handle(msg, device)) {\n\t\tret = -EMSGSIZE;\n\t\tgoto err_free;\n\t}\n\n\thas_cap_net_admin = netlink_capable(skb, CAP_NET_ADMIN);\n\n\tret = fill_func(msg, has_cap_net_admin, res, port);\n\tif (ret)\n\t\tgoto err_free;\n\n\trdma_restrack_put(res);\n\tnlmsg_end(msg, nlh);\n\tib_device_put(device);\n\treturn rdma_nl_unicast(sock_net(skb->sk), msg, NETLINK_CB(skb).portid);\n\nerr_free:\n\tnlmsg_free(msg);\nerr_get:\n\trdma_restrack_put(res);\nerr:\n\tib_device_put(device);\n\treturn ret;\n}\n\nstatic int res_get_common_dumpit(struct sk_buff *skb,\n\t\t\t\t struct netlink_callback *cb,\n\t\t\t\t enum rdma_restrack_type res_type,\n\t\t\t\t res_fill_func_t fill_func)\n{\n\tconst struct nldev_fill_res_entry *fe = &fill_entries[res_type];\n\tstruct nlattr *tb[RDMA_NLDEV_ATTR_MAX];\n\tstruct rdma_restrack_entry *res;\n\tstruct rdma_restrack_root *rt;\n\tint err, ret = 0, idx = 0;\n\tstruct nlattr *table_attr;\n\tstruct nlattr *entry_attr;\n\tstruct ib_device *device;\n\tint start = cb->args[0];\n\tbool has_cap_net_admin;\n\tstruct nlmsghdr *nlh;\n\tunsigned long id;\n\tu32 index, port = 0;\n\tbool filled = false;\n\n\terr = nlmsg_parse_deprecated(cb->nlh, 0, tb, RDMA_NLDEV_ATTR_MAX - 1,\n\t\t\t\t     nldev_policy, NULL);\n\t \n\tif (err || !tb[RDMA_NLDEV_ATTR_DEV_INDEX])\n\t\treturn -EINVAL;\n\n\tindex = nla_get_u32(tb[RDMA_NLDEV_ATTR_DEV_INDEX]);\n\tdevice = ib_device_get_by_index(sock_net(skb->sk), index);\n\tif (!device)\n\t\treturn -EINVAL;\n\n\t \n\tif (tb[RDMA_NLDEV_ATTR_PORT_INDEX]) {\n\t\tport = nla_get_u32(tb[RDMA_NLDEV_ATTR_PORT_INDEX]);\n\t\tif (!rdma_is_port_valid(device, port)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_index;\n\t\t}\n\t}\n\n\tnlh = nlmsg_put(skb, NETLINK_CB(cb->skb).portid, cb->nlh->nlmsg_seq,\n\t\t\tRDMA_NL_GET_TYPE(RDMA_NL_NLDEV,\n\t\t\t\t\t RDMA_NL_GET_OP(cb->nlh->nlmsg_type)),\n\t\t\t0, NLM_F_MULTI);\n\n\tif (!nlh || fill_nldev_handle(skb, device)) {\n\t\tret = -EMSGSIZE;\n\t\tgoto err;\n\t}\n\n\ttable_attr = nla_nest_start_noflag(skb, fe->nldev_attr);\n\tif (!table_attr) {\n\t\tret = -EMSGSIZE;\n\t\tgoto err;\n\t}\n\n\thas_cap_net_admin = netlink_capable(cb->skb, CAP_NET_ADMIN);\n\n\trt = &device->res[res_type];\n\txa_lock(&rt->xa);\n\t \n\txa_for_each(&rt->xa, id, res) {\n\t\tif (idx < start || !rdma_restrack_get(res))\n\t\t\tgoto next;\n\n\t\txa_unlock(&rt->xa);\n\n\t\tfilled = true;\n\n\t\tentry_attr = nla_nest_start_noflag(skb, fe->entry);\n\t\tif (!entry_attr) {\n\t\t\tret = -EMSGSIZE;\n\t\t\trdma_restrack_put(res);\n\t\t\tgoto msg_full;\n\t\t}\n\n\t\tret = fill_func(skb, has_cap_net_admin, res, port);\n\n\t\trdma_restrack_put(res);\n\n\t\tif (ret) {\n\t\t\tnla_nest_cancel(skb, entry_attr);\n\t\t\tif (ret == -EMSGSIZE)\n\t\t\t\tgoto msg_full;\n\t\t\tif (ret == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tgoto res_err;\n\t\t}\n\t\tnla_nest_end(skb, entry_attr);\nagain:\t\txa_lock(&rt->xa);\nnext:\t\tidx++;\n\t}\n\txa_unlock(&rt->xa);\n\nmsg_full:\n\tnla_nest_end(skb, table_attr);\n\tnlmsg_end(skb, nlh);\n\tcb->args[0] = idx;\n\n\t \n\tif (!filled)\n\t\tgoto err;\n\n\tib_device_put(device);\n\treturn skb->len;\n\nres_err:\n\tnla_nest_cancel(skb, table_attr);\n\nerr:\n\tnlmsg_cancel(skb, nlh);\n\nerr_index:\n\tib_device_put(device);\n\treturn ret;\n}\n\n#define RES_GET_FUNCS(name, type)                                              \\\n\tstatic int nldev_res_get_##name##_dumpit(struct sk_buff *skb,          \\\n\t\t\t\t\t\t struct netlink_callback *cb)  \\\n\t{                                                                      \\\n\t\treturn res_get_common_dumpit(skb, cb, type,                    \\\n\t\t\t\t\t     fill_res_##name##_entry);         \\\n\t}                                                                      \\\n\tstatic int nldev_res_get_##name##_doit(struct sk_buff *skb,            \\\n\t\t\t\t\t       struct nlmsghdr *nlh,           \\\n\t\t\t\t\t       struct netlink_ext_ack *extack) \\\n\t{                                                                      \\\n\t\treturn res_get_common_doit(skb, nlh, extack, type,             \\\n\t\t\t\t\t   fill_res_##name##_entry);           \\\n\t}\n\nRES_GET_FUNCS(qp, RDMA_RESTRACK_QP);\nRES_GET_FUNCS(qp_raw, RDMA_RESTRACK_QP);\nRES_GET_FUNCS(cm_id, RDMA_RESTRACK_CM_ID);\nRES_GET_FUNCS(cq, RDMA_RESTRACK_CQ);\nRES_GET_FUNCS(cq_raw, RDMA_RESTRACK_CQ);\nRES_GET_FUNCS(pd, RDMA_RESTRACK_PD);\nRES_GET_FUNCS(mr, RDMA_RESTRACK_MR);\nRES_GET_FUNCS(mr_raw, RDMA_RESTRACK_MR);\nRES_GET_FUNCS(counter, RDMA_RESTRACK_COUNTER);\nRES_GET_FUNCS(ctx, RDMA_RESTRACK_CTX);\nRES_GET_FUNCS(srq, RDMA_RESTRACK_SRQ);\n\nstatic LIST_HEAD(link_ops);\nstatic DECLARE_RWSEM(link_ops_rwsem);\n\nstatic const struct rdma_link_ops *link_ops_get(const char *type)\n{\n\tconst struct rdma_link_ops *ops;\n\n\tlist_for_each_entry(ops, &link_ops, list) {\n\t\tif (!strcmp(ops->type, type))\n\t\t\tgoto out;\n\t}\n\tops = NULL;\nout:\n\treturn ops;\n}\n\nvoid rdma_link_register(struct rdma_link_ops *ops)\n{\n\tdown_write(&link_ops_rwsem);\n\tif (WARN_ON_ONCE(link_ops_get(ops->type)))\n\t\tgoto out;\n\tlist_add(&ops->list, &link_ops);\nout:\n\tup_write(&link_ops_rwsem);\n}\nEXPORT_SYMBOL(rdma_link_register);\n\nvoid rdma_link_unregister(struct rdma_link_ops *ops)\n{\n\tdown_write(&link_ops_rwsem);\n\tlist_del(&ops->list);\n\tup_write(&link_ops_rwsem);\n}\nEXPORT_SYMBOL(rdma_link_unregister);\n\nstatic int nldev_newlink(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[RDMA_NLDEV_ATTR_MAX];\n\tchar ibdev_name[IB_DEVICE_NAME_MAX];\n\tconst struct rdma_link_ops *ops;\n\tchar ndev_name[IFNAMSIZ];\n\tstruct net_device *ndev;\n\tchar type[IFNAMSIZ];\n\tint err;\n\n\terr = nlmsg_parse_deprecated(nlh, 0, tb, RDMA_NLDEV_ATTR_MAX - 1,\n\t\t\t\t     nldev_policy, extack);\n\tif (err || !tb[RDMA_NLDEV_ATTR_DEV_NAME] ||\n\t    !tb[RDMA_NLDEV_ATTR_LINK_TYPE] || !tb[RDMA_NLDEV_ATTR_NDEV_NAME])\n\t\treturn -EINVAL;\n\n\tnla_strscpy(ibdev_name, tb[RDMA_NLDEV_ATTR_DEV_NAME],\n\t\t    sizeof(ibdev_name));\n\tif (strchr(ibdev_name, '%') || strlen(ibdev_name) == 0)\n\t\treturn -EINVAL;\n\n\tnla_strscpy(type, tb[RDMA_NLDEV_ATTR_LINK_TYPE], sizeof(type));\n\tnla_strscpy(ndev_name, tb[RDMA_NLDEV_ATTR_NDEV_NAME],\n\t\t    sizeof(ndev_name));\n\n\tndev = dev_get_by_name(sock_net(skb->sk), ndev_name);\n\tif (!ndev)\n\t\treturn -ENODEV;\n\n\tdown_read(&link_ops_rwsem);\n\tops = link_ops_get(type);\n#ifdef CONFIG_MODULES\n\tif (!ops) {\n\t\tup_read(&link_ops_rwsem);\n\t\trequest_module(\"rdma-link-%s\", type);\n\t\tdown_read(&link_ops_rwsem);\n\t\tops = link_ops_get(type);\n\t}\n#endif\n\terr = ops ? ops->newlink(ibdev_name, ndev) : -EINVAL;\n\tup_read(&link_ops_rwsem);\n\tdev_put(ndev);\n\n\treturn err;\n}\n\nstatic int nldev_dellink(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[RDMA_NLDEV_ATTR_MAX];\n\tstruct ib_device *device;\n\tu32 index;\n\tint err;\n\n\terr = nlmsg_parse_deprecated(nlh, 0, tb, RDMA_NLDEV_ATTR_MAX - 1,\n\t\t\t\t     nldev_policy, extack);\n\tif (err || !tb[RDMA_NLDEV_ATTR_DEV_INDEX])\n\t\treturn -EINVAL;\n\n\tindex = nla_get_u32(tb[RDMA_NLDEV_ATTR_DEV_INDEX]);\n\tdevice = ib_device_get_by_index(sock_net(skb->sk), index);\n\tif (!device)\n\t\treturn -EINVAL;\n\n\tif (!(device->attrs.kernel_cap_flags & IBK_ALLOW_USER_UNREG)) {\n\t\tib_device_put(device);\n\t\treturn -EINVAL;\n\t}\n\n\tib_unregister_device_and_put(device);\n\treturn 0;\n}\n\nstatic int nldev_get_chardev(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[RDMA_NLDEV_ATTR_MAX];\n\tchar client_name[RDMA_NLDEV_ATTR_CHARDEV_TYPE_SIZE];\n\tstruct ib_client_nl_info data = {};\n\tstruct ib_device *ibdev = NULL;\n\tstruct sk_buff *msg;\n\tu32 index;\n\tint err;\n\n\terr = nlmsg_parse(nlh, 0, tb, RDMA_NLDEV_ATTR_MAX - 1, nldev_policy,\n\t\t\t  extack);\n\tif (err || !tb[RDMA_NLDEV_ATTR_CHARDEV_TYPE])\n\t\treturn -EINVAL;\n\n\tnla_strscpy(client_name, tb[RDMA_NLDEV_ATTR_CHARDEV_TYPE],\n\t\t    sizeof(client_name));\n\n\tif (tb[RDMA_NLDEV_ATTR_DEV_INDEX]) {\n\t\tindex = nla_get_u32(tb[RDMA_NLDEV_ATTR_DEV_INDEX]);\n\t\tibdev = ib_device_get_by_index(sock_net(skb->sk), index);\n\t\tif (!ibdev)\n\t\t\treturn -EINVAL;\n\n\t\tif (tb[RDMA_NLDEV_ATTR_PORT_INDEX]) {\n\t\t\tdata.port = nla_get_u32(tb[RDMA_NLDEV_ATTR_PORT_INDEX]);\n\t\t\tif (!rdma_is_port_valid(ibdev, data.port)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_put;\n\t\t\t}\n\t\t} else {\n\t\t\tdata.port = -1;\n\t\t}\n\t} else if (tb[RDMA_NLDEV_ATTR_PORT_INDEX]) {\n\t\treturn -EINVAL;\n\t}\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg) {\n\t\terr = -ENOMEM;\n\t\tgoto out_put;\n\t}\n\tnlh = nlmsg_put(msg, NETLINK_CB(skb).portid, nlh->nlmsg_seq,\n\t\t\tRDMA_NL_GET_TYPE(RDMA_NL_NLDEV,\n\t\t\t\t\t RDMA_NLDEV_CMD_GET_CHARDEV),\n\t\t\t0, 0);\n\tif (!nlh) {\n\t\terr = -EMSGSIZE;\n\t\tgoto out_nlmsg;\n\t}\n\n\tdata.nl_msg = msg;\n\terr = ib_get_client_nl_info(ibdev, client_name, &data);\n\tif (err)\n\t\tgoto out_nlmsg;\n\n\terr = nla_put_u64_64bit(msg, RDMA_NLDEV_ATTR_CHARDEV,\n\t\t\t\thuge_encode_dev(data.cdev->devt),\n\t\t\t\tRDMA_NLDEV_ATTR_PAD);\n\tif (err)\n\t\tgoto out_data;\n\terr = nla_put_u64_64bit(msg, RDMA_NLDEV_ATTR_CHARDEV_ABI, data.abi,\n\t\t\t\tRDMA_NLDEV_ATTR_PAD);\n\tif (err)\n\t\tgoto out_data;\n\tif (nla_put_string(msg, RDMA_NLDEV_ATTR_CHARDEV_NAME,\n\t\t\t   dev_name(data.cdev))) {\n\t\terr = -EMSGSIZE;\n\t\tgoto out_data;\n\t}\n\n\tnlmsg_end(msg, nlh);\n\tput_device(data.cdev);\n\tif (ibdev)\n\t\tib_device_put(ibdev);\n\treturn rdma_nl_unicast(sock_net(skb->sk), msg, NETLINK_CB(skb).portid);\n\nout_data:\n\tput_device(data.cdev);\nout_nlmsg:\n\tnlmsg_free(msg);\nout_put:\n\tif (ibdev)\n\t\tib_device_put(ibdev);\n\treturn err;\n}\n\nstatic int nldev_sys_get_doit(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[RDMA_NLDEV_ATTR_MAX];\n\tstruct sk_buff *msg;\n\tint err;\n\n\terr = nlmsg_parse(nlh, 0, tb, RDMA_NLDEV_ATTR_MAX - 1,\n\t\t\t  nldev_policy, extack);\n\tif (err)\n\t\treturn err;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tnlh = nlmsg_put(msg, NETLINK_CB(skb).portid, nlh->nlmsg_seq,\n\t\t\tRDMA_NL_GET_TYPE(RDMA_NL_NLDEV,\n\t\t\t\t\t RDMA_NLDEV_CMD_SYS_GET),\n\t\t\t0, 0);\n\tif (!nlh) {\n\t\tnlmsg_free(msg);\n\t\treturn -EMSGSIZE;\n\t}\n\n\terr = nla_put_u8(msg, RDMA_NLDEV_SYS_ATTR_NETNS_MODE,\n\t\t\t (u8)ib_devices_shared_netns);\n\tif (err) {\n\t\tnlmsg_free(msg);\n\t\treturn err;\n\t}\n\n\t \n\tnla_put_u8(msg, RDMA_NLDEV_SYS_ATTR_COPY_ON_FORK, 1);\n\n\tnlmsg_end(msg, nlh);\n\treturn rdma_nl_unicast(sock_net(skb->sk), msg, NETLINK_CB(skb).portid);\n}\n\nstatic int nldev_set_sys_set_doit(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[RDMA_NLDEV_ATTR_MAX];\n\tu8 enable;\n\tint err;\n\n\terr = nlmsg_parse(nlh, 0, tb, RDMA_NLDEV_ATTR_MAX - 1,\n\t\t\t  nldev_policy, extack);\n\tif (err || !tb[RDMA_NLDEV_SYS_ATTR_NETNS_MODE])\n\t\treturn -EINVAL;\n\n\tenable = nla_get_u8(tb[RDMA_NLDEV_SYS_ATTR_NETNS_MODE]);\n\t \n\tif (enable > 1)\n\t\treturn -EINVAL;\n\n\terr = rdma_compatdev_set(enable);\n\treturn err;\n}\n\nstatic int nldev_stat_set_mode_doit(struct sk_buff *msg,\n\t\t\t\t    struct netlink_ext_ack *extack,\n\t\t\t\t    struct nlattr *tb[],\n\t\t\t\t    struct ib_device *device, u32 port)\n{\n\tu32 mode, mask = 0, qpn, cntn = 0;\n\tint ret;\n\n\t \n\tif (!tb[RDMA_NLDEV_ATTR_STAT_RES] ||\n\t    nla_get_u32(tb[RDMA_NLDEV_ATTR_STAT_RES]) != RDMA_NLDEV_ATTR_RES_QP)\n\t\treturn -EINVAL;\n\n\tmode = nla_get_u32(tb[RDMA_NLDEV_ATTR_STAT_MODE]);\n\tif (mode == RDMA_COUNTER_MODE_AUTO) {\n\t\tif (tb[RDMA_NLDEV_ATTR_STAT_AUTO_MODE_MASK])\n\t\t\tmask = nla_get_u32(\n\t\t\t\ttb[RDMA_NLDEV_ATTR_STAT_AUTO_MODE_MASK]);\n\t\treturn rdma_counter_set_auto_mode(device, port, mask, extack);\n\t}\n\n\tif (!tb[RDMA_NLDEV_ATTR_RES_LQPN])\n\t\treturn -EINVAL;\n\n\tqpn = nla_get_u32(tb[RDMA_NLDEV_ATTR_RES_LQPN]);\n\tif (tb[RDMA_NLDEV_ATTR_STAT_COUNTER_ID]) {\n\t\tcntn = nla_get_u32(tb[RDMA_NLDEV_ATTR_STAT_COUNTER_ID]);\n\t\tret = rdma_counter_bind_qpn(device, port, qpn, cntn);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tret = rdma_counter_bind_qpn_alloc(device, port, qpn, &cntn);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (nla_put_u32(msg, RDMA_NLDEV_ATTR_STAT_COUNTER_ID, cntn) ||\n\t    nla_put_u32(msg, RDMA_NLDEV_ATTR_RES_LQPN, qpn)) {\n\t\tret = -EMSGSIZE;\n\t\tgoto err_fill;\n\t}\n\n\treturn 0;\n\nerr_fill:\n\trdma_counter_unbind_qpn(device, port, qpn, cntn);\n\treturn ret;\n}\n\nstatic int nldev_stat_set_counter_dynamic_doit(struct nlattr *tb[],\n\t\t\t\t\t       struct ib_device *device,\n\t\t\t\t\t       u32 port)\n{\n\tstruct rdma_hw_stats *stats;\n\tstruct nlattr *entry_attr;\n\tunsigned long *target;\n\tint rem, i, ret = 0;\n\tu32 index;\n\n\tstats = ib_get_hw_stats_port(device, port);\n\tif (!stats)\n\t\treturn -EINVAL;\n\n\ttarget = kcalloc(BITS_TO_LONGS(stats->num_counters),\n\t\t\t sizeof(*stats->is_disabled), GFP_KERNEL);\n\tif (!target)\n\t\treturn -ENOMEM;\n\n\tnla_for_each_nested(entry_attr, tb[RDMA_NLDEV_ATTR_STAT_HWCOUNTERS],\n\t\t\t    rem) {\n\t\tindex = nla_get_u32(entry_attr);\n\t\tif ((index >= stats->num_counters) ||\n\t\t    !(stats->descs[index].flags & IB_STAT_FLAG_OPTIONAL)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tset_bit(index, target);\n\t}\n\n\tfor (i = 0; i < stats->num_counters; i++) {\n\t\tif (!(stats->descs[i].flags & IB_STAT_FLAG_OPTIONAL))\n\t\t\tcontinue;\n\n\t\tret = rdma_counter_modify(device, port, i, test_bit(i, target));\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\nout:\n\tkfree(target);\n\treturn ret;\n}\n\nstatic int nldev_stat_set_doit(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[RDMA_NLDEV_ATTR_MAX];\n\tstruct ib_device *device;\n\tstruct sk_buff *msg;\n\tu32 index, port;\n\tint ret;\n\n\tret = nlmsg_parse(nlh, 0, tb, RDMA_NLDEV_ATTR_MAX - 1, nldev_policy,\n\t\t\t  extack);\n\tif (ret || !tb[RDMA_NLDEV_ATTR_DEV_INDEX] ||\n\t    !tb[RDMA_NLDEV_ATTR_PORT_INDEX])\n\t\treturn -EINVAL;\n\n\tindex = nla_get_u32(tb[RDMA_NLDEV_ATTR_DEV_INDEX]);\n\tdevice = ib_device_get_by_index(sock_net(skb->sk), index);\n\tif (!device)\n\t\treturn -EINVAL;\n\n\tport = nla_get_u32(tb[RDMA_NLDEV_ATTR_PORT_INDEX]);\n\tif (!rdma_is_port_valid(device, port)) {\n\t\tret = -EINVAL;\n\t\tgoto err_put_device;\n\t}\n\n\tif (!tb[RDMA_NLDEV_ATTR_STAT_MODE] &&\n\t    !tb[RDMA_NLDEV_ATTR_STAT_HWCOUNTERS]) {\n\t\tret = -EINVAL;\n\t\tgoto err_put_device;\n\t}\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg) {\n\t\tret = -ENOMEM;\n\t\tgoto err_put_device;\n\t}\n\tnlh = nlmsg_put(msg, NETLINK_CB(skb).portid, nlh->nlmsg_seq,\n\t\t\tRDMA_NL_GET_TYPE(RDMA_NL_NLDEV,\n\t\t\t\t\t RDMA_NLDEV_CMD_STAT_SET),\n\t\t\t0, 0);\n\tif (!nlh || fill_nldev_handle(msg, device) ||\n\t    nla_put_u32(msg, RDMA_NLDEV_ATTR_PORT_INDEX, port)) {\n\t\tret = -EMSGSIZE;\n\t\tgoto err_free_msg;\n\t}\n\n\tif (tb[RDMA_NLDEV_ATTR_STAT_MODE]) {\n\t\tret = nldev_stat_set_mode_doit(msg, extack, tb, device, port);\n\t\tif (ret)\n\t\t\tgoto err_free_msg;\n\t}\n\n\tif (tb[RDMA_NLDEV_ATTR_STAT_HWCOUNTERS]) {\n\t\tret = nldev_stat_set_counter_dynamic_doit(tb, device, port);\n\t\tif (ret)\n\t\t\tgoto err_free_msg;\n\t}\n\n\tnlmsg_end(msg, nlh);\n\tib_device_put(device);\n\treturn rdma_nl_unicast(sock_net(skb->sk), msg, NETLINK_CB(skb).portid);\n\nerr_free_msg:\n\tnlmsg_free(msg);\nerr_put_device:\n\tib_device_put(device);\n\treturn ret;\n}\n\nstatic int nldev_stat_del_doit(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[RDMA_NLDEV_ATTR_MAX];\n\tstruct ib_device *device;\n\tstruct sk_buff *msg;\n\tu32 index, port, qpn, cntn;\n\tint ret;\n\n\tret = nlmsg_parse(nlh, 0, tb, RDMA_NLDEV_ATTR_MAX - 1,\n\t\t\t  nldev_policy, extack);\n\tif (ret || !tb[RDMA_NLDEV_ATTR_STAT_RES] ||\n\t    !tb[RDMA_NLDEV_ATTR_DEV_INDEX] || !tb[RDMA_NLDEV_ATTR_PORT_INDEX] ||\n\t    !tb[RDMA_NLDEV_ATTR_STAT_COUNTER_ID] ||\n\t    !tb[RDMA_NLDEV_ATTR_RES_LQPN])\n\t\treturn -EINVAL;\n\n\tif (nla_get_u32(tb[RDMA_NLDEV_ATTR_STAT_RES]) != RDMA_NLDEV_ATTR_RES_QP)\n\t\treturn -EINVAL;\n\n\tindex = nla_get_u32(tb[RDMA_NLDEV_ATTR_DEV_INDEX]);\n\tdevice = ib_device_get_by_index(sock_net(skb->sk), index);\n\tif (!device)\n\t\treturn -EINVAL;\n\n\tport = nla_get_u32(tb[RDMA_NLDEV_ATTR_PORT_INDEX]);\n\tif (!rdma_is_port_valid(device, port)) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tnlh = nlmsg_put(msg, NETLINK_CB(skb).portid, nlh->nlmsg_seq,\n\t\t\tRDMA_NL_GET_TYPE(RDMA_NL_NLDEV,\n\t\t\t\t\t RDMA_NLDEV_CMD_STAT_SET),\n\t\t\t0, 0);\n\tif (!nlh) {\n\t\tret = -EMSGSIZE;\n\t\tgoto err_fill;\n\t}\n\n\tcntn = nla_get_u32(tb[RDMA_NLDEV_ATTR_STAT_COUNTER_ID]);\n\tqpn = nla_get_u32(tb[RDMA_NLDEV_ATTR_RES_LQPN]);\n\tif (fill_nldev_handle(msg, device) ||\n\t    nla_put_u32(msg, RDMA_NLDEV_ATTR_PORT_INDEX, port) ||\n\t    nla_put_u32(msg, RDMA_NLDEV_ATTR_STAT_COUNTER_ID, cntn) ||\n\t    nla_put_u32(msg, RDMA_NLDEV_ATTR_RES_LQPN, qpn)) {\n\t\tret = -EMSGSIZE;\n\t\tgoto err_fill;\n\t}\n\n\tret = rdma_counter_unbind_qpn(device, port, qpn, cntn);\n\tif (ret)\n\t\tgoto err_fill;\n\n\tnlmsg_end(msg, nlh);\n\tib_device_put(device);\n\treturn rdma_nl_unicast(sock_net(skb->sk), msg, NETLINK_CB(skb).portid);\n\nerr_fill:\n\tnlmsg_free(msg);\nerr:\n\tib_device_put(device);\n\treturn ret;\n}\n\nstatic int stat_get_doit_default_counter(struct sk_buff *skb,\n\t\t\t\t\t struct nlmsghdr *nlh,\n\t\t\t\t\t struct netlink_ext_ack *extack,\n\t\t\t\t\t struct nlattr *tb[])\n{\n\tstruct rdma_hw_stats *stats;\n\tstruct nlattr *table_attr;\n\tstruct ib_device *device;\n\tint ret, num_cnts, i;\n\tstruct sk_buff *msg;\n\tu32 index, port;\n\tu64 v;\n\n\tif (!tb[RDMA_NLDEV_ATTR_DEV_INDEX] || !tb[RDMA_NLDEV_ATTR_PORT_INDEX])\n\t\treturn -EINVAL;\n\n\tindex = nla_get_u32(tb[RDMA_NLDEV_ATTR_DEV_INDEX]);\n\tdevice = ib_device_get_by_index(sock_net(skb->sk), index);\n\tif (!device)\n\t\treturn -EINVAL;\n\n\tif (!device->ops.alloc_hw_port_stats || !device->ops.get_hw_stats) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tport = nla_get_u32(tb[RDMA_NLDEV_ATTR_PORT_INDEX]);\n\tstats = ib_get_hw_stats_port(device, port);\n\tif (!stats) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tnlh = nlmsg_put(msg, NETLINK_CB(skb).portid, nlh->nlmsg_seq,\n\t\t\tRDMA_NL_GET_TYPE(RDMA_NL_NLDEV,\n\t\t\t\t\t RDMA_NLDEV_CMD_STAT_GET),\n\t\t\t0, 0);\n\n\tif (!nlh || fill_nldev_handle(msg, device) ||\n\t    nla_put_u32(msg, RDMA_NLDEV_ATTR_PORT_INDEX, port)) {\n\t\tret = -EMSGSIZE;\n\t\tgoto err_msg;\n\t}\n\n\tmutex_lock(&stats->lock);\n\n\tnum_cnts = device->ops.get_hw_stats(device, stats, port, 0);\n\tif (num_cnts < 0) {\n\t\tret = -EINVAL;\n\t\tgoto err_stats;\n\t}\n\n\ttable_attr = nla_nest_start(msg, RDMA_NLDEV_ATTR_STAT_HWCOUNTERS);\n\tif (!table_attr) {\n\t\tret = -EMSGSIZE;\n\t\tgoto err_stats;\n\t}\n\tfor (i = 0; i < num_cnts; i++) {\n\t\tif (test_bit(i, stats->is_disabled))\n\t\t\tcontinue;\n\n\t\tv = stats->value[i] +\n\t\t\trdma_counter_get_hwstat_value(device, port, i);\n\t\tif (rdma_nl_stat_hwcounter_entry(msg,\n\t\t\t\t\t\t stats->descs[i].name, v)) {\n\t\t\tret = -EMSGSIZE;\n\t\t\tgoto err_table;\n\t\t}\n\t}\n\tnla_nest_end(msg, table_attr);\n\n\tmutex_unlock(&stats->lock);\n\tnlmsg_end(msg, nlh);\n\tib_device_put(device);\n\treturn rdma_nl_unicast(sock_net(skb->sk), msg, NETLINK_CB(skb).portid);\n\nerr_table:\n\tnla_nest_cancel(msg, table_attr);\nerr_stats:\n\tmutex_unlock(&stats->lock);\nerr_msg:\n\tnlmsg_free(msg);\nerr:\n\tib_device_put(device);\n\treturn ret;\n}\n\nstatic int stat_get_doit_qp(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t    struct netlink_ext_ack *extack, struct nlattr *tb[])\n\n{\n\tstatic enum rdma_nl_counter_mode mode;\n\tstatic enum rdma_nl_counter_mask mask;\n\tstruct ib_device *device;\n\tstruct sk_buff *msg;\n\tu32 index, port;\n\tint ret;\n\n\tif (tb[RDMA_NLDEV_ATTR_STAT_COUNTER_ID])\n\t\treturn nldev_res_get_counter_doit(skb, nlh, extack);\n\n\tif (!tb[RDMA_NLDEV_ATTR_STAT_MODE] ||\n\t    !tb[RDMA_NLDEV_ATTR_DEV_INDEX] || !tb[RDMA_NLDEV_ATTR_PORT_INDEX])\n\t\treturn -EINVAL;\n\n\tindex = nla_get_u32(tb[RDMA_NLDEV_ATTR_DEV_INDEX]);\n\tdevice = ib_device_get_by_index(sock_net(skb->sk), index);\n\tif (!device)\n\t\treturn -EINVAL;\n\n\tport = nla_get_u32(tb[RDMA_NLDEV_ATTR_PORT_INDEX]);\n\tif (!rdma_is_port_valid(device, port)) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tnlh = nlmsg_put(msg, NETLINK_CB(skb).portid, nlh->nlmsg_seq,\n\t\t\tRDMA_NL_GET_TYPE(RDMA_NL_NLDEV,\n\t\t\t\t\t RDMA_NLDEV_CMD_STAT_GET),\n\t\t\t0, 0);\n\tif (!nlh) {\n\t\tret = -EMSGSIZE;\n\t\tgoto err_msg;\n\t}\n\n\tret = rdma_counter_get_mode(device, port, &mode, &mask);\n\tif (ret)\n\t\tgoto err_msg;\n\n\tif (fill_nldev_handle(msg, device) ||\n\t    nla_put_u32(msg, RDMA_NLDEV_ATTR_PORT_INDEX, port) ||\n\t    nla_put_u32(msg, RDMA_NLDEV_ATTR_STAT_MODE, mode)) {\n\t\tret = -EMSGSIZE;\n\t\tgoto err_msg;\n\t}\n\n\tif ((mode == RDMA_COUNTER_MODE_AUTO) &&\n\t    nla_put_u32(msg, RDMA_NLDEV_ATTR_STAT_AUTO_MODE_MASK, mask)) {\n\t\tret = -EMSGSIZE;\n\t\tgoto err_msg;\n\t}\n\n\tnlmsg_end(msg, nlh);\n\tib_device_put(device);\n\treturn rdma_nl_unicast(sock_net(skb->sk), msg, NETLINK_CB(skb).portid);\n\nerr_msg:\n\tnlmsg_free(msg);\nerr:\n\tib_device_put(device);\n\treturn ret;\n}\n\nstatic int nldev_stat_get_doit(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[RDMA_NLDEV_ATTR_MAX];\n\tint ret;\n\n\tret = nlmsg_parse(nlh, 0, tb, RDMA_NLDEV_ATTR_MAX - 1,\n\t\t\t  nldev_policy, extack);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\tif (!tb[RDMA_NLDEV_ATTR_STAT_RES])\n\t\treturn stat_get_doit_default_counter(skb, nlh, extack, tb);\n\n\tswitch (nla_get_u32(tb[RDMA_NLDEV_ATTR_STAT_RES])) {\n\tcase RDMA_NLDEV_ATTR_RES_QP:\n\t\tret = stat_get_doit_qp(skb, nlh, extack, tb);\n\t\tbreak;\n\tcase RDMA_NLDEV_ATTR_RES_MR:\n\t\tret = res_get_common_doit(skb, nlh, extack, RDMA_RESTRACK_MR,\n\t\t\t\t\t  fill_stat_mr_entry);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int nldev_stat_get_dumpit(struct sk_buff *skb,\n\t\t\t\t struct netlink_callback *cb)\n{\n\tstruct nlattr *tb[RDMA_NLDEV_ATTR_MAX];\n\tint ret;\n\n\tret = nlmsg_parse(cb->nlh, 0, tb, RDMA_NLDEV_ATTR_MAX - 1,\n\t\t\t  nldev_policy, NULL);\n\tif (ret || !tb[RDMA_NLDEV_ATTR_STAT_RES])\n\t\treturn -EINVAL;\n\n\tswitch (nla_get_u32(tb[RDMA_NLDEV_ATTR_STAT_RES])) {\n\tcase RDMA_NLDEV_ATTR_RES_QP:\n\t\tret = nldev_res_get_counter_dumpit(skb, cb);\n\t\tbreak;\n\tcase RDMA_NLDEV_ATTR_RES_MR:\n\t\tret = res_get_common_dumpit(skb, cb, RDMA_RESTRACK_MR,\n\t\t\t\t\t    fill_stat_mr_entry);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int nldev_stat_get_counter_status_doit(struct sk_buff *skb,\n\t\t\t\t\t      struct nlmsghdr *nlh,\n\t\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[RDMA_NLDEV_ATTR_MAX], *table, *entry;\n\tstruct rdma_hw_stats *stats;\n\tstruct ib_device *device;\n\tstruct sk_buff *msg;\n\tu32 devid, port;\n\tint ret, i;\n\n\tret = nlmsg_parse(nlh, 0, tb, RDMA_NLDEV_ATTR_MAX - 1,\n\t\t\t  nldev_policy, extack);\n\tif (ret || !tb[RDMA_NLDEV_ATTR_DEV_INDEX] ||\n\t    !tb[RDMA_NLDEV_ATTR_PORT_INDEX])\n\t\treturn -EINVAL;\n\n\tdevid = nla_get_u32(tb[RDMA_NLDEV_ATTR_DEV_INDEX]);\n\tdevice = ib_device_get_by_index(sock_net(skb->sk), devid);\n\tif (!device)\n\t\treturn -EINVAL;\n\n\tport = nla_get_u32(tb[RDMA_NLDEV_ATTR_PORT_INDEX]);\n\tif (!rdma_is_port_valid(device, port)) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tstats = ib_get_hw_stats_port(device, port);\n\tif (!stats) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tnlh = nlmsg_put(\n\t\tmsg, NETLINK_CB(skb).portid, nlh->nlmsg_seq,\n\t\tRDMA_NL_GET_TYPE(RDMA_NL_NLDEV, RDMA_NLDEV_CMD_STAT_GET_STATUS),\n\t\t0, 0);\n\n\tret = -EMSGSIZE;\n\tif (!nlh || fill_nldev_handle(msg, device) ||\n\t    nla_put_u32(msg, RDMA_NLDEV_ATTR_PORT_INDEX, port))\n\t\tgoto err_msg;\n\n\ttable = nla_nest_start(msg, RDMA_NLDEV_ATTR_STAT_HWCOUNTERS);\n\tif (!table)\n\t\tgoto err_msg;\n\n\tmutex_lock(&stats->lock);\n\tfor (i = 0; i < stats->num_counters; i++) {\n\t\tentry = nla_nest_start(msg,\n\t\t\t\t       RDMA_NLDEV_ATTR_STAT_HWCOUNTER_ENTRY);\n\t\tif (!entry)\n\t\t\tgoto err_msg_table;\n\n\t\tif (nla_put_string(msg,\n\t\t\t\t   RDMA_NLDEV_ATTR_STAT_HWCOUNTER_ENTRY_NAME,\n\t\t\t\t   stats->descs[i].name) ||\n\t\t    nla_put_u32(msg, RDMA_NLDEV_ATTR_STAT_HWCOUNTER_INDEX, i))\n\t\t\tgoto err_msg_entry;\n\n\t\tif ((stats->descs[i].flags & IB_STAT_FLAG_OPTIONAL) &&\n\t\t    (nla_put_u8(msg, RDMA_NLDEV_ATTR_STAT_HWCOUNTER_DYNAMIC,\n\t\t\t\t!test_bit(i, stats->is_disabled))))\n\t\t\tgoto err_msg_entry;\n\n\t\tnla_nest_end(msg, entry);\n\t}\n\tmutex_unlock(&stats->lock);\n\n\tnla_nest_end(msg, table);\n\tnlmsg_end(msg, nlh);\n\tib_device_put(device);\n\treturn rdma_nl_unicast(sock_net(skb->sk), msg, NETLINK_CB(skb).portid);\n\nerr_msg_entry:\n\tnla_nest_cancel(msg, entry);\nerr_msg_table:\n\tmutex_unlock(&stats->lock);\n\tnla_nest_cancel(msg, table);\nerr_msg:\n\tnlmsg_free(msg);\nerr:\n\tib_device_put(device);\n\treturn ret;\n}\n\nstatic const struct rdma_nl_cbs nldev_cb_table[RDMA_NLDEV_NUM_OPS] = {\n\t[RDMA_NLDEV_CMD_GET] = {\n\t\t.doit = nldev_get_doit,\n\t\t.dump = nldev_get_dumpit,\n\t},\n\t[RDMA_NLDEV_CMD_GET_CHARDEV] = {\n\t\t.doit = nldev_get_chardev,\n\t},\n\t[RDMA_NLDEV_CMD_SET] = {\n\t\t.doit = nldev_set_doit,\n\t\t.flags = RDMA_NL_ADMIN_PERM,\n\t},\n\t[RDMA_NLDEV_CMD_NEWLINK] = {\n\t\t.doit = nldev_newlink,\n\t\t.flags = RDMA_NL_ADMIN_PERM,\n\t},\n\t[RDMA_NLDEV_CMD_DELLINK] = {\n\t\t.doit = nldev_dellink,\n\t\t.flags = RDMA_NL_ADMIN_PERM,\n\t},\n\t[RDMA_NLDEV_CMD_PORT_GET] = {\n\t\t.doit = nldev_port_get_doit,\n\t\t.dump = nldev_port_get_dumpit,\n\t},\n\t[RDMA_NLDEV_CMD_RES_GET] = {\n\t\t.doit = nldev_res_get_doit,\n\t\t.dump = nldev_res_get_dumpit,\n\t},\n\t[RDMA_NLDEV_CMD_RES_QP_GET] = {\n\t\t.doit = nldev_res_get_qp_doit,\n\t\t.dump = nldev_res_get_qp_dumpit,\n\t},\n\t[RDMA_NLDEV_CMD_RES_CM_ID_GET] = {\n\t\t.doit = nldev_res_get_cm_id_doit,\n\t\t.dump = nldev_res_get_cm_id_dumpit,\n\t},\n\t[RDMA_NLDEV_CMD_RES_CQ_GET] = {\n\t\t.doit = nldev_res_get_cq_doit,\n\t\t.dump = nldev_res_get_cq_dumpit,\n\t},\n\t[RDMA_NLDEV_CMD_RES_MR_GET] = {\n\t\t.doit = nldev_res_get_mr_doit,\n\t\t.dump = nldev_res_get_mr_dumpit,\n\t},\n\t[RDMA_NLDEV_CMD_RES_PD_GET] = {\n\t\t.doit = nldev_res_get_pd_doit,\n\t\t.dump = nldev_res_get_pd_dumpit,\n\t},\n\t[RDMA_NLDEV_CMD_RES_CTX_GET] = {\n\t\t.doit = nldev_res_get_ctx_doit,\n\t\t.dump = nldev_res_get_ctx_dumpit,\n\t},\n\t[RDMA_NLDEV_CMD_RES_SRQ_GET] = {\n\t\t.doit = nldev_res_get_srq_doit,\n\t\t.dump = nldev_res_get_srq_dumpit,\n\t},\n\t[RDMA_NLDEV_CMD_SYS_GET] = {\n\t\t.doit = nldev_sys_get_doit,\n\t},\n\t[RDMA_NLDEV_CMD_SYS_SET] = {\n\t\t.doit = nldev_set_sys_set_doit,\n\t\t.flags = RDMA_NL_ADMIN_PERM,\n\t},\n\t[RDMA_NLDEV_CMD_STAT_SET] = {\n\t\t.doit = nldev_stat_set_doit,\n\t\t.flags = RDMA_NL_ADMIN_PERM,\n\t},\n\t[RDMA_NLDEV_CMD_STAT_GET] = {\n\t\t.doit = nldev_stat_get_doit,\n\t\t.dump = nldev_stat_get_dumpit,\n\t},\n\t[RDMA_NLDEV_CMD_STAT_DEL] = {\n\t\t.doit = nldev_stat_del_doit,\n\t\t.flags = RDMA_NL_ADMIN_PERM,\n\t},\n\t[RDMA_NLDEV_CMD_RES_QP_GET_RAW] = {\n\t\t.doit = nldev_res_get_qp_raw_doit,\n\t\t.dump = nldev_res_get_qp_raw_dumpit,\n\t\t.flags = RDMA_NL_ADMIN_PERM,\n\t},\n\t[RDMA_NLDEV_CMD_RES_CQ_GET_RAW] = {\n\t\t.doit = nldev_res_get_cq_raw_doit,\n\t\t.dump = nldev_res_get_cq_raw_dumpit,\n\t\t.flags = RDMA_NL_ADMIN_PERM,\n\t},\n\t[RDMA_NLDEV_CMD_RES_MR_GET_RAW] = {\n\t\t.doit = nldev_res_get_mr_raw_doit,\n\t\t.dump = nldev_res_get_mr_raw_dumpit,\n\t\t.flags = RDMA_NL_ADMIN_PERM,\n\t},\n\t[RDMA_NLDEV_CMD_STAT_GET_STATUS] = {\n\t\t.doit = nldev_stat_get_counter_status_doit,\n\t},\n};\n\nvoid __init nldev_init(void)\n{\n\trdma_nl_register(RDMA_NL_NLDEV, nldev_cb_table);\n}\n\nvoid nldev_exit(void)\n{\n\trdma_nl_unregister(RDMA_NL_NLDEV);\n}\n\nMODULE_ALIAS_RDMA_NETLINK(RDMA_NL_NLDEV, 5);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}