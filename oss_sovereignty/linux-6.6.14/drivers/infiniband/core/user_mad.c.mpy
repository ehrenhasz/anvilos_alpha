{
  "module_name": "user_mad.c",
  "hash_id": "d8379f0e9f5d38063fdc34b9ff503fc638f3c2e245de94a989a4ac3156144a5b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/core/user_mad.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) \"user_mad: \" fmt\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/fs.h>\n#include <linux/cdev.h>\n#include <linux/dma-mapping.h>\n#include <linux/poll.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/compat.h>\n#include <linux/sched.h>\n#include <linux/semaphore.h>\n#include <linux/slab.h>\n#include <linux/nospec.h>\n\n#include <linux/uaccess.h>\n\n#include <rdma/ib_mad.h>\n#include <rdma/ib_user_mad.h>\n#include <rdma/rdma_netlink.h>\n\n#include \"core_priv.h\"\n\nMODULE_AUTHOR(\"Roland Dreier\");\nMODULE_DESCRIPTION(\"InfiniBand userspace MAD packet access\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n\nenum {\n\tIB_UMAD_MAX_PORTS  = RDMA_MAX_PORTS,\n\tIB_UMAD_MAX_AGENTS = 32,\n\n\tIB_UMAD_MAJOR      = 231,\n\tIB_UMAD_MINOR_BASE = 0,\n\tIB_UMAD_NUM_FIXED_MINOR = 64,\n\tIB_UMAD_NUM_DYNAMIC_MINOR = IB_UMAD_MAX_PORTS - IB_UMAD_NUM_FIXED_MINOR,\n\tIB_ISSM_MINOR_BASE        = IB_UMAD_NUM_FIXED_MINOR,\n};\n\n \n\nstruct ib_umad_port {\n\tstruct cdev           cdev;\n\tstruct device\t      dev;\n\tstruct cdev           sm_cdev;\n\tstruct device\t      sm_dev;\n\tstruct semaphore       sm_sem;\n\n\tstruct mutex\t       file_mutex;\n\tstruct list_head       file_list;\n\n\tstruct ib_device      *ib_dev;\n\tstruct ib_umad_device *umad_dev;\n\tint                    dev_num;\n\tu32                     port_num;\n};\n\nstruct ib_umad_device {\n\tstruct kref kref;\n\tstruct ib_umad_port ports[];\n};\n\nstruct ib_umad_file {\n\tstruct mutex\t\tmutex;\n\tstruct ib_umad_port    *port;\n\tstruct list_head\trecv_list;\n\tstruct list_head\tsend_list;\n\tstruct list_head\tport_list;\n\tspinlock_t\t\tsend_lock;\n\twait_queue_head_t\trecv_wait;\n\tstruct ib_mad_agent    *agent[IB_UMAD_MAX_AGENTS];\n\tint\t\t\tagents_dead;\n\tu8\t\t\tuse_pkey_index;\n\tu8\t\t\talready_used;\n};\n\nstruct ib_umad_packet {\n\tstruct ib_mad_send_buf *msg;\n\tstruct ib_mad_recv_wc  *recv_wc;\n\tstruct list_head   list;\n\tint\t\t   length;\n\tstruct ib_user_mad mad;\n};\n\nstruct ib_rmpp_mad_hdr {\n\tstruct ib_mad_hdr\tmad_hdr;\n\tstruct ib_rmpp_hdr      rmpp_hdr;\n} __packed;\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/ib_umad.h>\n\nstatic const dev_t base_umad_dev = MKDEV(IB_UMAD_MAJOR, IB_UMAD_MINOR_BASE);\nstatic const dev_t base_issm_dev = MKDEV(IB_UMAD_MAJOR, IB_UMAD_MINOR_BASE) +\n\t\t\t\t   IB_UMAD_NUM_FIXED_MINOR;\nstatic dev_t dynamic_umad_dev;\nstatic dev_t dynamic_issm_dev;\n\nstatic DEFINE_IDA(umad_ida);\n\nstatic int ib_umad_add_one(struct ib_device *device);\nstatic void ib_umad_remove_one(struct ib_device *device, void *client_data);\n\nstatic void ib_umad_dev_free(struct kref *kref)\n{\n\tstruct ib_umad_device *dev =\n\t\tcontainer_of(kref, struct ib_umad_device, kref);\n\n\tkfree(dev);\n}\n\nstatic void ib_umad_dev_get(struct ib_umad_device *dev)\n{\n\tkref_get(&dev->kref);\n}\n\nstatic void ib_umad_dev_put(struct ib_umad_device *dev)\n{\n\tkref_put(&dev->kref, ib_umad_dev_free);\n}\n\nstatic int hdr_size(struct ib_umad_file *file)\n{\n\treturn file->use_pkey_index ? sizeof(struct ib_user_mad_hdr) :\n\t\t\t\t      sizeof(struct ib_user_mad_hdr_old);\n}\n\n \nstatic struct ib_mad_agent *__get_agent(struct ib_umad_file *file, int id)\n{\n\treturn file->agents_dead ? NULL : file->agent[id];\n}\n\nstatic int queue_packet(struct ib_umad_file *file,\n\t\t\tstruct ib_mad_agent *agent,\n\t\t\tstruct ib_umad_packet *packet)\n{\n\tint ret = 1;\n\n\tmutex_lock(&file->mutex);\n\n\tfor (packet->mad.hdr.id = 0;\n\t     packet->mad.hdr.id < IB_UMAD_MAX_AGENTS;\n\t     packet->mad.hdr.id++)\n\t\tif (agent == __get_agent(file, packet->mad.hdr.id)) {\n\t\t\tlist_add_tail(&packet->list, &file->recv_list);\n\t\t\twake_up_interruptible(&file->recv_wait);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\tmutex_unlock(&file->mutex);\n\n\treturn ret;\n}\n\nstatic void dequeue_send(struct ib_umad_file *file,\n\t\t\t struct ib_umad_packet *packet)\n{\n\tspin_lock_irq(&file->send_lock);\n\tlist_del(&packet->list);\n\tspin_unlock_irq(&file->send_lock);\n}\n\nstatic void send_handler(struct ib_mad_agent *agent,\n\t\t\t struct ib_mad_send_wc *send_wc)\n{\n\tstruct ib_umad_file *file = agent->context;\n\tstruct ib_umad_packet *packet = send_wc->send_buf->context[0];\n\n\tdequeue_send(file, packet);\n\trdma_destroy_ah(packet->msg->ah, RDMA_DESTROY_AH_SLEEPABLE);\n\tib_free_send_mad(packet->msg);\n\n\tif (send_wc->status == IB_WC_RESP_TIMEOUT_ERR) {\n\t\tpacket->length = IB_MGMT_MAD_HDR;\n\t\tpacket->mad.hdr.status = ETIMEDOUT;\n\t\tif (!queue_packet(file, agent, packet))\n\t\t\treturn;\n\t}\n\tkfree(packet);\n}\n\nstatic void recv_handler(struct ib_mad_agent *agent,\n\t\t\t struct ib_mad_send_buf *send_buf,\n\t\t\t struct ib_mad_recv_wc *mad_recv_wc)\n{\n\tstruct ib_umad_file *file = agent->context;\n\tstruct ib_umad_packet *packet;\n\n\tif (mad_recv_wc->wc->status != IB_WC_SUCCESS)\n\t\tgoto err1;\n\n\tpacket = kzalloc(sizeof *packet, GFP_KERNEL);\n\tif (!packet)\n\t\tgoto err1;\n\n\tpacket->length = mad_recv_wc->mad_len;\n\tpacket->recv_wc = mad_recv_wc;\n\n\tpacket->mad.hdr.status\t   = 0;\n\tpacket->mad.hdr.length\t   = hdr_size(file) + mad_recv_wc->mad_len;\n\tpacket->mad.hdr.qpn\t   = cpu_to_be32(mad_recv_wc->wc->src_qp);\n\t \n\tif (rdma_cap_opa_mad(agent->device, agent->port_num))\n\t\tpacket->mad.hdr.lid = ib_lid_be16(0xFFFF &\n\t\t\t\t\t\t  mad_recv_wc->wc->slid);\n\telse\n\t\tpacket->mad.hdr.lid = ib_lid_be16(mad_recv_wc->wc->slid);\n\tpacket->mad.hdr.sl\t   = mad_recv_wc->wc->sl;\n\tpacket->mad.hdr.path_bits  = mad_recv_wc->wc->dlid_path_bits;\n\tpacket->mad.hdr.pkey_index = mad_recv_wc->wc->pkey_index;\n\tpacket->mad.hdr.grh_present = !!(mad_recv_wc->wc->wc_flags & IB_WC_GRH);\n\tif (packet->mad.hdr.grh_present) {\n\t\tstruct rdma_ah_attr ah_attr;\n\t\tconst struct ib_global_route *grh;\n\t\tint ret;\n\n\t\tret = ib_init_ah_attr_from_wc(agent->device, agent->port_num,\n\t\t\t\t\t      mad_recv_wc->wc,\n\t\t\t\t\t      mad_recv_wc->recv_buf.grh,\n\t\t\t\t\t      &ah_attr);\n\t\tif (ret)\n\t\t\tgoto err2;\n\n\t\tgrh = rdma_ah_read_grh(&ah_attr);\n\t\tpacket->mad.hdr.gid_index = grh->sgid_index;\n\t\tpacket->mad.hdr.hop_limit = grh->hop_limit;\n\t\tpacket->mad.hdr.traffic_class = grh->traffic_class;\n\t\tmemcpy(packet->mad.hdr.gid, &grh->dgid, 16);\n\t\tpacket->mad.hdr.flow_label = cpu_to_be32(grh->flow_label);\n\t\trdma_destroy_ah_attr(&ah_attr);\n\t}\n\n\tif (queue_packet(file, agent, packet))\n\t\tgoto err2;\n\treturn;\n\nerr2:\n\tkfree(packet);\nerr1:\n\tib_free_recv_mad(mad_recv_wc);\n}\n\nstatic ssize_t copy_recv_mad(struct ib_umad_file *file, char __user *buf,\n\t\t\t     struct ib_umad_packet *packet, size_t count)\n{\n\tstruct ib_mad_recv_buf *recv_buf;\n\tint left, seg_payload, offset, max_seg_payload;\n\tsize_t seg_size;\n\n\trecv_buf = &packet->recv_wc->recv_buf;\n\tseg_size = packet->recv_wc->mad_seg_size;\n\n\t \n\tif ((packet->length <= seg_size &&\n\t     count < hdr_size(file) + packet->length) ||\n\t    (packet->length > seg_size &&\n\t     count < hdr_size(file) + seg_size))\n\t\treturn -EINVAL;\n\n\tif (copy_to_user(buf, &packet->mad, hdr_size(file)))\n\t\treturn -EFAULT;\n\n\tbuf += hdr_size(file);\n\tseg_payload = min_t(int, packet->length, seg_size);\n\tif (copy_to_user(buf, recv_buf->mad, seg_payload))\n\t\treturn -EFAULT;\n\n\tif (seg_payload < packet->length) {\n\t\t \n\t\tif (count < hdr_size(file) + packet->length) {\n\t\t\t \n\t\t\treturn -ENOSPC;\n\t\t}\n\t\toffset = ib_get_mad_data_offset(recv_buf->mad->mad_hdr.mgmt_class);\n\t\tmax_seg_payload = seg_size - offset;\n\n\t\tfor (left = packet->length - seg_payload, buf += seg_payload;\n\t\t     left; left -= seg_payload, buf += seg_payload) {\n\t\t\trecv_buf = container_of(recv_buf->list.next,\n\t\t\t\t\t\tstruct ib_mad_recv_buf, list);\n\t\t\tseg_payload = min(left, max_seg_payload);\n\t\t\tif (copy_to_user(buf, ((void *) recv_buf->mad) + offset,\n\t\t\t\t\t seg_payload))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\ttrace_ib_umad_read_recv(file, &packet->mad.hdr, &recv_buf->mad->mad_hdr);\n\n\treturn hdr_size(file) + packet->length;\n}\n\nstatic ssize_t copy_send_mad(struct ib_umad_file *file, char __user *buf,\n\t\t\t     struct ib_umad_packet *packet, size_t count)\n{\n\tssize_t size = hdr_size(file) + packet->length;\n\n\tif (count < size)\n\t\treturn -EINVAL;\n\n\tif (copy_to_user(buf, &packet->mad, hdr_size(file)))\n\t\treturn -EFAULT;\n\n\tbuf += hdr_size(file);\n\n\tif (copy_to_user(buf, packet->mad.data, packet->length))\n\t\treturn -EFAULT;\n\n\ttrace_ib_umad_read_send(file, &packet->mad.hdr,\n\t\t\t\t(struct ib_mad_hdr *)&packet->mad.data);\n\n\treturn size;\n}\n\nstatic ssize_t ib_umad_read(struct file *filp, char __user *buf,\n\t\t\t    size_t count, loff_t *pos)\n{\n\tstruct ib_umad_file *file = filp->private_data;\n\tstruct ib_umad_packet *packet;\n\tssize_t ret;\n\n\tif (count < hdr_size(file))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&file->mutex);\n\n\tif (file->agents_dead) {\n\t\tmutex_unlock(&file->mutex);\n\t\treturn -EIO;\n\t}\n\n\twhile (list_empty(&file->recv_list)) {\n\t\tmutex_unlock(&file->mutex);\n\n\t\tif (filp->f_flags & O_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\n\t\tif (wait_event_interruptible(file->recv_wait,\n\t\t\t\t\t     !list_empty(&file->recv_list)))\n\t\t\treturn -ERESTARTSYS;\n\n\t\tmutex_lock(&file->mutex);\n\t}\n\n\tif (file->agents_dead) {\n\t\tmutex_unlock(&file->mutex);\n\t\treturn -EIO;\n\t}\n\n\tpacket = list_entry(file->recv_list.next, struct ib_umad_packet, list);\n\tlist_del(&packet->list);\n\n\tmutex_unlock(&file->mutex);\n\n\tif (packet->recv_wc)\n\t\tret = copy_recv_mad(file, buf, packet, count);\n\telse\n\t\tret = copy_send_mad(file, buf, packet, count);\n\n\tif (ret < 0) {\n\t\t \n\t\tmutex_lock(&file->mutex);\n\t\tlist_add(&packet->list, &file->recv_list);\n\t\tmutex_unlock(&file->mutex);\n\t} else {\n\t\tif (packet->recv_wc)\n\t\t\tib_free_recv_mad(packet->recv_wc);\n\t\tkfree(packet);\n\t}\n\treturn ret;\n}\n\nstatic int copy_rmpp_mad(struct ib_mad_send_buf *msg, const char __user *buf)\n{\n\tint left, seg;\n\n\t \n\tif ((msg->hdr_len > IB_MGMT_RMPP_HDR) &&\n\t    copy_from_user(msg->mad + IB_MGMT_RMPP_HDR, buf + IB_MGMT_RMPP_HDR,\n\t\t\t   msg->hdr_len - IB_MGMT_RMPP_HDR))\n\t\treturn -EFAULT;\n\n\t \n\tfor (seg = 1, left = msg->data_len, buf += msg->hdr_len; left > 0;\n\t     seg++, left -= msg->seg_size, buf += msg->seg_size) {\n\t\tif (copy_from_user(ib_get_rmpp_segment(msg, seg), buf,\n\t\t\t\t   min(left, msg->seg_size)))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\n\nstatic int same_destination(struct ib_user_mad_hdr *hdr1,\n\t\t\t    struct ib_user_mad_hdr *hdr2)\n{\n\tif (!hdr1->grh_present && !hdr2->grh_present)\n\t   return (hdr1->lid == hdr2->lid);\n\n\tif (hdr1->grh_present && hdr2->grh_present)\n\t   return !memcmp(hdr1->gid, hdr2->gid, 16);\n\n\treturn 0;\n}\n\nstatic int is_duplicate(struct ib_umad_file *file,\n\t\t\tstruct ib_umad_packet *packet)\n{\n\tstruct ib_umad_packet *sent_packet;\n\tstruct ib_mad_hdr *sent_hdr, *hdr;\n\n\thdr = (struct ib_mad_hdr *) packet->mad.data;\n\tlist_for_each_entry(sent_packet, &file->send_list, list) {\n\t\tsent_hdr = (struct ib_mad_hdr *) sent_packet->mad.data;\n\n\t\tif ((hdr->tid != sent_hdr->tid) ||\n\t\t    (hdr->mgmt_class != sent_hdr->mgmt_class))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!ib_response_mad(hdr)) {\n\t\t\tif (!ib_response_mad(sent_hdr))\n\t\t\t\treturn 1;\n\t\t\tcontinue;\n\t\t} else if (!ib_response_mad(sent_hdr))\n\t\t\tcontinue;\n\n\t\tif (same_destination(&packet->mad.hdr, &sent_packet->mad.hdr))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t ib_umad_write(struct file *filp, const char __user *buf,\n\t\t\t     size_t count, loff_t *pos)\n{\n\tstruct ib_umad_file *file = filp->private_data;\n\tstruct ib_rmpp_mad_hdr *rmpp_mad_hdr;\n\tstruct ib_umad_packet *packet;\n\tstruct ib_mad_agent *agent;\n\tstruct rdma_ah_attr ah_attr;\n\tstruct ib_ah *ah;\n\t__be64 *tid;\n\tint ret, data_len, hdr_len, copy_offset, rmpp_active;\n\tu8 base_version;\n\n\tif (count < hdr_size(file) + IB_MGMT_RMPP_HDR)\n\t\treturn -EINVAL;\n\n\tpacket = kzalloc(sizeof(*packet) + IB_MGMT_RMPP_HDR, GFP_KERNEL);\n\tif (!packet)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(&packet->mad, buf, hdr_size(file))) {\n\t\tret = -EFAULT;\n\t\tgoto err;\n\t}\n\n\tif (packet->mad.hdr.id >= IB_UMAD_MAX_AGENTS) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tbuf += hdr_size(file);\n\n\tif (copy_from_user(packet->mad.data, buf, IB_MGMT_RMPP_HDR)) {\n\t\tret = -EFAULT;\n\t\tgoto err;\n\t}\n\n\tmutex_lock(&file->mutex);\n\n\ttrace_ib_umad_write(file, &packet->mad.hdr,\n\t\t\t    (struct ib_mad_hdr *)&packet->mad.data);\n\n\tagent = __get_agent(file, packet->mad.hdr.id);\n\tif (!agent) {\n\t\tret = -EIO;\n\t\tgoto err_up;\n\t}\n\n\tmemset(&ah_attr, 0, sizeof ah_attr);\n\tah_attr.type = rdma_ah_find_type(agent->device,\n\t\t\t\t\t file->port->port_num);\n\trdma_ah_set_dlid(&ah_attr, be16_to_cpu(packet->mad.hdr.lid));\n\trdma_ah_set_sl(&ah_attr, packet->mad.hdr.sl);\n\trdma_ah_set_path_bits(&ah_attr, packet->mad.hdr.path_bits);\n\trdma_ah_set_port_num(&ah_attr, file->port->port_num);\n\tif (packet->mad.hdr.grh_present) {\n\t\trdma_ah_set_grh(&ah_attr, NULL,\n\t\t\t\tbe32_to_cpu(packet->mad.hdr.flow_label),\n\t\t\t\tpacket->mad.hdr.gid_index,\n\t\t\t\tpacket->mad.hdr.hop_limit,\n\t\t\t\tpacket->mad.hdr.traffic_class);\n\t\trdma_ah_set_dgid_raw(&ah_attr, packet->mad.hdr.gid);\n\t}\n\n\tah = rdma_create_user_ah(agent->qp->pd, &ah_attr, NULL);\n\tif (IS_ERR(ah)) {\n\t\tret = PTR_ERR(ah);\n\t\tgoto err_up;\n\t}\n\n\trmpp_mad_hdr = (struct ib_rmpp_mad_hdr *)packet->mad.data;\n\thdr_len = ib_get_mad_data_offset(rmpp_mad_hdr->mad_hdr.mgmt_class);\n\n\tif (ib_is_mad_class_rmpp(rmpp_mad_hdr->mad_hdr.mgmt_class)\n\t    && ib_mad_kernel_rmpp_agent(agent)) {\n\t\tcopy_offset = IB_MGMT_RMPP_HDR;\n\t\trmpp_active = ib_get_rmpp_flags(&rmpp_mad_hdr->rmpp_hdr) &\n\t\t\t\t\t\tIB_MGMT_RMPP_FLAG_ACTIVE;\n\t} else {\n\t\tcopy_offset = IB_MGMT_MAD_HDR;\n\t\trmpp_active = 0;\n\t}\n\n\tbase_version = ((struct ib_mad_hdr *)&packet->mad.data)->base_version;\n\tdata_len = count - hdr_size(file) - hdr_len;\n\tpacket->msg = ib_create_send_mad(agent,\n\t\t\t\t\t be32_to_cpu(packet->mad.hdr.qpn),\n\t\t\t\t\t packet->mad.hdr.pkey_index, rmpp_active,\n\t\t\t\t\t hdr_len, data_len, GFP_KERNEL,\n\t\t\t\t\t base_version);\n\tif (IS_ERR(packet->msg)) {\n\t\tret = PTR_ERR(packet->msg);\n\t\tgoto err_ah;\n\t}\n\n\tpacket->msg->ah\t\t= ah;\n\tpacket->msg->timeout_ms = packet->mad.hdr.timeout_ms;\n\tpacket->msg->retries\t= packet->mad.hdr.retries;\n\tpacket->msg->context[0] = packet;\n\n\t \n\tmemcpy(packet->msg->mad, packet->mad.data, IB_MGMT_MAD_HDR);\n\n\tif (!rmpp_active) {\n\t\tif (copy_from_user(packet->msg->mad + copy_offset,\n\t\t\t\t   buf + copy_offset,\n\t\t\t\t   hdr_len + data_len - copy_offset)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto err_msg;\n\t\t}\n\t} else {\n\t\tret = copy_rmpp_mad(packet->msg, buf);\n\t\tif (ret)\n\t\t\tgoto err_msg;\n\t}\n\n\t \n\tif (!ib_response_mad(packet->msg->mad)) {\n\t\ttid = &((struct ib_mad_hdr *) packet->msg->mad)->tid;\n\t\t*tid = cpu_to_be64(((u64) agent->hi_tid) << 32 |\n\t\t\t\t   (be64_to_cpup(tid) & 0xffffffff));\n\t\trmpp_mad_hdr->mad_hdr.tid = *tid;\n\t}\n\n\tif (!ib_mad_kernel_rmpp_agent(agent)\n\t    && ib_is_mad_class_rmpp(rmpp_mad_hdr->mad_hdr.mgmt_class)\n\t    && (ib_get_rmpp_flags(&rmpp_mad_hdr->rmpp_hdr) & IB_MGMT_RMPP_FLAG_ACTIVE)) {\n\t\tspin_lock_irq(&file->send_lock);\n\t\tlist_add_tail(&packet->list, &file->send_list);\n\t\tspin_unlock_irq(&file->send_lock);\n\t} else {\n\t\tspin_lock_irq(&file->send_lock);\n\t\tret = is_duplicate(file, packet);\n\t\tif (!ret)\n\t\t\tlist_add_tail(&packet->list, &file->send_list);\n\t\tspin_unlock_irq(&file->send_lock);\n\t\tif (ret) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_msg;\n\t\t}\n\t}\n\n\tret = ib_post_send_mad(packet->msg, NULL);\n\tif (ret)\n\t\tgoto err_send;\n\n\tmutex_unlock(&file->mutex);\n\treturn count;\n\nerr_send:\n\tdequeue_send(file, packet);\nerr_msg:\n\tib_free_send_mad(packet->msg);\nerr_ah:\n\trdma_destroy_ah(ah, RDMA_DESTROY_AH_SLEEPABLE);\nerr_up:\n\tmutex_unlock(&file->mutex);\nerr:\n\tkfree(packet);\n\treturn ret;\n}\n\nstatic __poll_t ib_umad_poll(struct file *filp, struct poll_table_struct *wait)\n{\n\tstruct ib_umad_file *file = filp->private_data;\n\n\t \n\t__poll_t mask = EPOLLOUT | EPOLLWRNORM;\n\n\tmutex_lock(&file->mutex);\n\tpoll_wait(filp, &file->recv_wait, wait);\n\n\tif (!list_empty(&file->recv_list))\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\tif (file->agents_dead)\n\t\tmask = EPOLLERR;\n\tmutex_unlock(&file->mutex);\n\n\treturn mask;\n}\n\nstatic int ib_umad_reg_agent(struct ib_umad_file *file, void __user *arg,\n\t\t\t     int compat_method_mask)\n{\n\tstruct ib_user_mad_reg_req ureq;\n\tstruct ib_mad_reg_req req;\n\tstruct ib_mad_agent *agent = NULL;\n\tint agent_id;\n\tint ret;\n\n\tmutex_lock(&file->port->file_mutex);\n\tmutex_lock(&file->mutex);\n\n\tif (!file->port->ib_dev) {\n\t\tdev_notice(&file->port->dev, \"%s: invalid device\\n\", __func__);\n\t\tret = -EPIPE;\n\t\tgoto out;\n\t}\n\n\tif (copy_from_user(&ureq, arg, sizeof ureq)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (ureq.qpn != 0 && ureq.qpn != 1) {\n\t\tdev_notice(&file->port->dev,\n\t\t\t   \"%s: invalid QPN %u specified\\n\", __func__,\n\t\t\t   ureq.qpn);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tfor (agent_id = 0; agent_id < IB_UMAD_MAX_AGENTS; ++agent_id)\n\t\tif (!__get_agent(file, agent_id))\n\t\t\tgoto found;\n\n\tdev_notice(&file->port->dev, \"%s: Max Agents (%u) reached\\n\", __func__,\n\t\t   IB_UMAD_MAX_AGENTS);\n\n\tret = -ENOMEM;\n\tgoto out;\n\nfound:\n\tif (ureq.mgmt_class) {\n\t\tmemset(&req, 0, sizeof(req));\n\t\treq.mgmt_class         = ureq.mgmt_class;\n\t\treq.mgmt_class_version = ureq.mgmt_class_version;\n\t\tmemcpy(req.oui, ureq.oui, sizeof req.oui);\n\n\t\tif (compat_method_mask) {\n\t\t\tu32 *umm = (u32 *) ureq.method_mask;\n\t\t\tint i;\n\n\t\t\tfor (i = 0; i < BITS_TO_LONGS(IB_MGMT_MAX_METHODS); ++i)\n\t\t\t\treq.method_mask[i] =\n\t\t\t\t\tumm[i * 2] | ((u64) umm[i * 2 + 1] << 32);\n\t\t} else\n\t\t\tmemcpy(req.method_mask, ureq.method_mask,\n\t\t\t       sizeof req.method_mask);\n\t}\n\n\tagent = ib_register_mad_agent(file->port->ib_dev, file->port->port_num,\n\t\t\t\t      ureq.qpn ? IB_QPT_GSI : IB_QPT_SMI,\n\t\t\t\t      ureq.mgmt_class ? &req : NULL,\n\t\t\t\t      ureq.rmpp_version,\n\t\t\t\t      send_handler, recv_handler, file, 0);\n\tif (IS_ERR(agent)) {\n\t\tret = PTR_ERR(agent);\n\t\tagent = NULL;\n\t\tgoto out;\n\t}\n\n\tif (put_user(agent_id,\n\t\t     (u32 __user *) (arg + offsetof(struct ib_user_mad_reg_req, id)))) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (!file->already_used) {\n\t\tfile->already_used = 1;\n\t\tif (!file->use_pkey_index) {\n\t\t\tdev_warn(&file->port->dev,\n\t\t\t\t\"process %s did not enable P_Key index support.\\n\",\n\t\t\t\tcurrent->comm);\n\t\t\tdev_warn(&file->port->dev,\n\t\t\t\t\"   Documentation/infiniband/user_mad.rst has info on the new ABI.\\n\");\n\t\t}\n\t}\n\n\tfile->agent[agent_id] = agent;\n\tret = 0;\n\nout:\n\tmutex_unlock(&file->mutex);\n\n\tif (ret && agent)\n\t\tib_unregister_mad_agent(agent);\n\n\tmutex_unlock(&file->port->file_mutex);\n\n\treturn ret;\n}\n\nstatic int ib_umad_reg_agent2(struct ib_umad_file *file, void __user *arg)\n{\n\tstruct ib_user_mad_reg_req2 ureq;\n\tstruct ib_mad_reg_req req;\n\tstruct ib_mad_agent *agent = NULL;\n\tint agent_id;\n\tint ret;\n\n\tmutex_lock(&file->port->file_mutex);\n\tmutex_lock(&file->mutex);\n\n\tif (!file->port->ib_dev) {\n\t\tdev_notice(&file->port->dev, \"%s: invalid device\\n\", __func__);\n\t\tret = -EPIPE;\n\t\tgoto out;\n\t}\n\n\tif (copy_from_user(&ureq, arg, sizeof(ureq))) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (ureq.qpn != 0 && ureq.qpn != 1) {\n\t\tdev_notice(&file->port->dev, \"%s: invalid QPN %u specified\\n\",\n\t\t\t   __func__, ureq.qpn);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (ureq.flags & ~IB_USER_MAD_REG_FLAGS_CAP) {\n\t\tdev_notice(&file->port->dev,\n\t\t\t   \"%s failed: invalid registration flags specified 0x%x; supported 0x%x\\n\",\n\t\t\t   __func__, ureq.flags, IB_USER_MAD_REG_FLAGS_CAP);\n\t\tret = -EINVAL;\n\n\t\tif (put_user((u32)IB_USER_MAD_REG_FLAGS_CAP,\n\t\t\t\t(u32 __user *) (arg + offsetof(struct\n\t\t\t\tib_user_mad_reg_req2, flags))))\n\t\t\tret = -EFAULT;\n\n\t\tgoto out;\n\t}\n\n\tfor (agent_id = 0; agent_id < IB_UMAD_MAX_AGENTS; ++agent_id)\n\t\tif (!__get_agent(file, agent_id))\n\t\t\tgoto found;\n\n\tdev_notice(&file->port->dev, \"%s: Max Agents (%u) reached\\n\", __func__,\n\t\t   IB_UMAD_MAX_AGENTS);\n\tret = -ENOMEM;\n\tgoto out;\n\nfound:\n\tif (ureq.mgmt_class) {\n\t\tmemset(&req, 0, sizeof(req));\n\t\treq.mgmt_class         = ureq.mgmt_class;\n\t\treq.mgmt_class_version = ureq.mgmt_class_version;\n\t\tif (ureq.oui & 0xff000000) {\n\t\t\tdev_notice(&file->port->dev,\n\t\t\t\t   \"%s failed: oui invalid 0x%08x\\n\", __func__,\n\t\t\t\t   ureq.oui);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\treq.oui[2] =  ureq.oui & 0x0000ff;\n\t\treq.oui[1] = (ureq.oui & 0x00ff00) >> 8;\n\t\treq.oui[0] = (ureq.oui & 0xff0000) >> 16;\n\t\tmemcpy(req.method_mask, ureq.method_mask,\n\t\t\tsizeof(req.method_mask));\n\t}\n\n\tagent = ib_register_mad_agent(file->port->ib_dev, file->port->port_num,\n\t\t\t\t      ureq.qpn ? IB_QPT_GSI : IB_QPT_SMI,\n\t\t\t\t      ureq.mgmt_class ? &req : NULL,\n\t\t\t\t      ureq.rmpp_version,\n\t\t\t\t      send_handler, recv_handler, file,\n\t\t\t\t      ureq.flags);\n\tif (IS_ERR(agent)) {\n\t\tret = PTR_ERR(agent);\n\t\tagent = NULL;\n\t\tgoto out;\n\t}\n\n\tif (put_user(agent_id,\n\t\t     (u32 __user *)(arg +\n\t\t\t\toffsetof(struct ib_user_mad_reg_req2, id)))) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (!file->already_used) {\n\t\tfile->already_used = 1;\n\t\tfile->use_pkey_index = 1;\n\t}\n\n\tfile->agent[agent_id] = agent;\n\tret = 0;\n\nout:\n\tmutex_unlock(&file->mutex);\n\n\tif (ret && agent)\n\t\tib_unregister_mad_agent(agent);\n\n\tmutex_unlock(&file->port->file_mutex);\n\n\treturn ret;\n}\n\n\nstatic int ib_umad_unreg_agent(struct ib_umad_file *file, u32 __user *arg)\n{\n\tstruct ib_mad_agent *agent = NULL;\n\tu32 id;\n\tint ret = 0;\n\n\tif (get_user(id, arg))\n\t\treturn -EFAULT;\n\tif (id >= IB_UMAD_MAX_AGENTS)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&file->port->file_mutex);\n\tmutex_lock(&file->mutex);\n\n\tid = array_index_nospec(id, IB_UMAD_MAX_AGENTS);\n\tif (!__get_agent(file, id)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tagent = file->agent[id];\n\tfile->agent[id] = NULL;\n\nout:\n\tmutex_unlock(&file->mutex);\n\n\tif (agent)\n\t\tib_unregister_mad_agent(agent);\n\n\tmutex_unlock(&file->port->file_mutex);\n\n\treturn ret;\n}\n\nstatic long ib_umad_enable_pkey(struct ib_umad_file *file)\n{\n\tint ret = 0;\n\n\tmutex_lock(&file->mutex);\n\tif (file->already_used)\n\t\tret = -EINVAL;\n\telse\n\t\tfile->use_pkey_index = 1;\n\tmutex_unlock(&file->mutex);\n\n\treturn ret;\n}\n\nstatic long ib_umad_ioctl(struct file *filp, unsigned int cmd,\n\t\t\t  unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase IB_USER_MAD_REGISTER_AGENT:\n\t\treturn ib_umad_reg_agent(filp->private_data, (void __user *) arg, 0);\n\tcase IB_USER_MAD_UNREGISTER_AGENT:\n\t\treturn ib_umad_unreg_agent(filp->private_data, (__u32 __user *) arg);\n\tcase IB_USER_MAD_ENABLE_PKEY:\n\t\treturn ib_umad_enable_pkey(filp->private_data);\n\tcase IB_USER_MAD_REGISTER_AGENT2:\n\t\treturn ib_umad_reg_agent2(filp->private_data, (void __user *) arg);\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n}\n\n#ifdef CONFIG_COMPAT\nstatic long ib_umad_compat_ioctl(struct file *filp, unsigned int cmd,\n\t\t\t\t unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase IB_USER_MAD_REGISTER_AGENT:\n\t\treturn ib_umad_reg_agent(filp->private_data, compat_ptr(arg), 1);\n\tcase IB_USER_MAD_UNREGISTER_AGENT:\n\t\treturn ib_umad_unreg_agent(filp->private_data, compat_ptr(arg));\n\tcase IB_USER_MAD_ENABLE_PKEY:\n\t\treturn ib_umad_enable_pkey(filp->private_data);\n\tcase IB_USER_MAD_REGISTER_AGENT2:\n\t\treturn ib_umad_reg_agent2(filp->private_data, compat_ptr(arg));\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n}\n#endif\n\n \nstatic int ib_umad_open(struct inode *inode, struct file *filp)\n{\n\tstruct ib_umad_port *port;\n\tstruct ib_umad_file *file;\n\tint ret = 0;\n\n\tport = container_of(inode->i_cdev, struct ib_umad_port, cdev);\n\n\tmutex_lock(&port->file_mutex);\n\n\tif (!port->ib_dev) {\n\t\tret = -ENXIO;\n\t\tgoto out;\n\t}\n\n\tif (!rdma_dev_access_netns(port->ib_dev, current->nsproxy->net_ns)) {\n\t\tret = -EPERM;\n\t\tgoto out;\n\t}\n\n\tfile = kzalloc(sizeof(*file), GFP_KERNEL);\n\tif (!file) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmutex_init(&file->mutex);\n\tspin_lock_init(&file->send_lock);\n\tINIT_LIST_HEAD(&file->recv_list);\n\tINIT_LIST_HEAD(&file->send_list);\n\tinit_waitqueue_head(&file->recv_wait);\n\n\tfile->port = port;\n\tfilp->private_data = file;\n\n\tlist_add_tail(&file->port_list, &port->file_list);\n\n\tstream_open(inode, filp);\nout:\n\tmutex_unlock(&port->file_mutex);\n\treturn ret;\n}\n\nstatic int ib_umad_close(struct inode *inode, struct file *filp)\n{\n\tstruct ib_umad_file *file = filp->private_data;\n\tstruct ib_umad_packet *packet, *tmp;\n\tint already_dead;\n\tint i;\n\n\tmutex_lock(&file->port->file_mutex);\n\tmutex_lock(&file->mutex);\n\n\talready_dead = file->agents_dead;\n\tfile->agents_dead = 1;\n\n\tlist_for_each_entry_safe(packet, tmp, &file->recv_list, list) {\n\t\tif (packet->recv_wc)\n\t\t\tib_free_recv_mad(packet->recv_wc);\n\t\tkfree(packet);\n\t}\n\n\tlist_del(&file->port_list);\n\n\tmutex_unlock(&file->mutex);\n\n\tif (!already_dead)\n\t\tfor (i = 0; i < IB_UMAD_MAX_AGENTS; ++i)\n\t\t\tif (file->agent[i])\n\t\t\t\tib_unregister_mad_agent(file->agent[i]);\n\n\tmutex_unlock(&file->port->file_mutex);\n\tmutex_destroy(&file->mutex);\n\tkfree(file);\n\treturn 0;\n}\n\nstatic const struct file_operations umad_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.read\t\t= ib_umad_read,\n\t.write\t\t= ib_umad_write,\n\t.poll\t\t= ib_umad_poll,\n\t.unlocked_ioctl = ib_umad_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t= ib_umad_compat_ioctl,\n#endif\n\t.open\t\t= ib_umad_open,\n\t.release\t= ib_umad_close,\n\t.llseek\t\t= no_llseek,\n};\n\nstatic int ib_umad_sm_open(struct inode *inode, struct file *filp)\n{\n\tstruct ib_umad_port *port;\n\tstruct ib_port_modify props = {\n\t\t.set_port_cap_mask = IB_PORT_SM\n\t};\n\tint ret;\n\n\tport = container_of(inode->i_cdev, struct ib_umad_port, sm_cdev);\n\n\tif (filp->f_flags & O_NONBLOCK) {\n\t\tif (down_trylock(&port->sm_sem)) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto fail;\n\t\t}\n\t} else {\n\t\tif (down_interruptible(&port->sm_sem)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (!rdma_dev_access_netns(port->ib_dev, current->nsproxy->net_ns)) {\n\t\tret = -EPERM;\n\t\tgoto err_up_sem;\n\t}\n\n\tret = ib_modify_port(port->ib_dev, port->port_num, 0, &props);\n\tif (ret)\n\t\tgoto err_up_sem;\n\n\tfilp->private_data = port;\n\n\tnonseekable_open(inode, filp);\n\treturn 0;\n\nerr_up_sem:\n\tup(&port->sm_sem);\n\nfail:\n\treturn ret;\n}\n\nstatic int ib_umad_sm_close(struct inode *inode, struct file *filp)\n{\n\tstruct ib_umad_port *port = filp->private_data;\n\tstruct ib_port_modify props = {\n\t\t.clr_port_cap_mask = IB_PORT_SM\n\t};\n\tint ret = 0;\n\n\tmutex_lock(&port->file_mutex);\n\tif (port->ib_dev)\n\t\tret = ib_modify_port(port->ib_dev, port->port_num, 0, &props);\n\tmutex_unlock(&port->file_mutex);\n\n\tup(&port->sm_sem);\n\n\treturn ret;\n}\n\nstatic const struct file_operations umad_sm_fops = {\n\t.owner\t = THIS_MODULE,\n\t.open\t = ib_umad_sm_open,\n\t.release = ib_umad_sm_close,\n\t.llseek\t = no_llseek,\n};\n\nstatic struct ib_umad_port *get_port(struct ib_device *ibdev,\n\t\t\t\t     struct ib_umad_device *umad_dev,\n\t\t\t\t     u32 port)\n{\n\tif (!umad_dev)\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\tif (!rdma_is_port_valid(ibdev, port))\n\t\treturn ERR_PTR(-EINVAL);\n\tif (!rdma_cap_ib_mad(ibdev, port))\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\treturn &umad_dev->ports[port - rdma_start_port(ibdev)];\n}\n\nstatic int ib_umad_get_nl_info(struct ib_device *ibdev, void *client_data,\n\t\t\t       struct ib_client_nl_info *res)\n{\n\tstruct ib_umad_port *port = get_port(ibdev, client_data, res->port);\n\n\tif (IS_ERR(port))\n\t\treturn PTR_ERR(port);\n\n\tres->abi = IB_USER_MAD_ABI_VERSION;\n\tres->cdev = &port->dev;\n\treturn 0;\n}\n\nstatic struct ib_client umad_client = {\n\t.name   = \"umad\",\n\t.add    = ib_umad_add_one,\n\t.remove = ib_umad_remove_one,\n\t.get_nl_info = ib_umad_get_nl_info,\n};\nMODULE_ALIAS_RDMA_CLIENT(\"umad\");\n\nstatic int ib_issm_get_nl_info(struct ib_device *ibdev, void *client_data,\n\t\t\t       struct ib_client_nl_info *res)\n{\n\tstruct ib_umad_port *port = get_port(ibdev, client_data, res->port);\n\n\tif (IS_ERR(port))\n\t\treturn PTR_ERR(port);\n\n\tres->abi = IB_USER_MAD_ABI_VERSION;\n\tres->cdev = &port->sm_dev;\n\treturn 0;\n}\n\nstatic struct ib_client issm_client = {\n\t.name = \"issm\",\n\t.get_nl_info = ib_issm_get_nl_info,\n};\nMODULE_ALIAS_RDMA_CLIENT(\"issm\");\n\nstatic ssize_t ibdev_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tstruct ib_umad_port *port = dev_get_drvdata(dev);\n\n\tif (!port)\n\t\treturn -ENODEV;\n\n\treturn sysfs_emit(buf, \"%s\\n\", dev_name(&port->ib_dev->dev));\n}\nstatic DEVICE_ATTR_RO(ibdev);\n\nstatic ssize_t port_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct ib_umad_port *port = dev_get_drvdata(dev);\n\n\tif (!port)\n\t\treturn -ENODEV;\n\n\treturn sysfs_emit(buf, \"%d\\n\", port->port_num);\n}\nstatic DEVICE_ATTR_RO(port);\n\nstatic struct attribute *umad_class_dev_attrs[] = {\n\t&dev_attr_ibdev.attr,\n\t&dev_attr_port.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(umad_class_dev);\n\nstatic char *umad_devnode(const struct device *dev, umode_t *mode)\n{\n\treturn kasprintf(GFP_KERNEL, \"infiniband/%s\", dev_name(dev));\n}\n\nstatic ssize_t abi_version_show(const struct class *class,\n\t\t\t\tconst struct class_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", IB_USER_MAD_ABI_VERSION);\n}\nstatic CLASS_ATTR_RO(abi_version);\n\nstatic struct attribute *umad_class_attrs[] = {\n\t&class_attr_abi_version.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(umad_class);\n\nstatic struct class umad_class = {\n\t.name\t\t= \"infiniband_mad\",\n\t.devnode\t= umad_devnode,\n\t.class_groups\t= umad_class_groups,\n\t.dev_groups\t= umad_class_dev_groups,\n};\n\nstatic void ib_umad_release_port(struct device *device)\n{\n\tstruct ib_umad_port *port = dev_get_drvdata(device);\n\tstruct ib_umad_device *umad_dev = port->umad_dev;\n\n\tib_umad_dev_put(umad_dev);\n}\n\nstatic void ib_umad_init_port_dev(struct device *dev,\n\t\t\t\t  struct ib_umad_port *port,\n\t\t\t\t  const struct ib_device *device)\n{\n\tdevice_initialize(dev);\n\tib_umad_dev_get(port->umad_dev);\n\tdev->class = &umad_class;\n\tdev->parent = device->dev.parent;\n\tdev_set_drvdata(dev, port);\n\tdev->release = ib_umad_release_port;\n}\n\nstatic int ib_umad_init_port(struct ib_device *device, int port_num,\n\t\t\t     struct ib_umad_device *umad_dev,\n\t\t\t     struct ib_umad_port *port)\n{\n\tint devnum;\n\tdev_t base_umad;\n\tdev_t base_issm;\n\tint ret;\n\n\tdevnum = ida_alloc_max(&umad_ida, IB_UMAD_MAX_PORTS - 1, GFP_KERNEL);\n\tif (devnum < 0)\n\t\treturn -1;\n\tport->dev_num = devnum;\n\tif (devnum >= IB_UMAD_NUM_FIXED_MINOR) {\n\t\tbase_umad = dynamic_umad_dev + devnum - IB_UMAD_NUM_FIXED_MINOR;\n\t\tbase_issm = dynamic_issm_dev + devnum - IB_UMAD_NUM_FIXED_MINOR;\n\t} else {\n\t\tbase_umad = devnum + base_umad_dev;\n\t\tbase_issm = devnum + base_issm_dev;\n\t}\n\n\tport->ib_dev   = device;\n\tport->umad_dev = umad_dev;\n\tport->port_num = port_num;\n\tsema_init(&port->sm_sem, 1);\n\tmutex_init(&port->file_mutex);\n\tINIT_LIST_HEAD(&port->file_list);\n\n\tib_umad_init_port_dev(&port->dev, port, device);\n\tport->dev.devt = base_umad;\n\tdev_set_name(&port->dev, \"umad%d\", port->dev_num);\n\tcdev_init(&port->cdev, &umad_fops);\n\tport->cdev.owner = THIS_MODULE;\n\n\tret = cdev_device_add(&port->cdev, &port->dev);\n\tif (ret)\n\t\tgoto err_cdev;\n\n\tib_umad_init_port_dev(&port->sm_dev, port, device);\n\tport->sm_dev.devt = base_issm;\n\tdev_set_name(&port->sm_dev, \"issm%d\", port->dev_num);\n\tcdev_init(&port->sm_cdev, &umad_sm_fops);\n\tport->sm_cdev.owner = THIS_MODULE;\n\n\tret = cdev_device_add(&port->sm_cdev, &port->sm_dev);\n\tif (ret)\n\t\tgoto err_dev;\n\n\treturn 0;\n\nerr_dev:\n\tput_device(&port->sm_dev);\n\tcdev_device_del(&port->cdev, &port->dev);\nerr_cdev:\n\tput_device(&port->dev);\n\tida_free(&umad_ida, devnum);\n\treturn ret;\n}\n\nstatic void ib_umad_kill_port(struct ib_umad_port *port)\n{\n\tstruct ib_umad_file *file;\n\tint id;\n\n\tcdev_device_del(&port->sm_cdev, &port->sm_dev);\n\tcdev_device_del(&port->cdev, &port->dev);\n\n\tmutex_lock(&port->file_mutex);\n\n\t \n\tport->ib_dev = NULL;\n\n\tlist_for_each_entry(file, &port->file_list, port_list) {\n\t\tmutex_lock(&file->mutex);\n\t\tfile->agents_dead = 1;\n\t\twake_up_interruptible(&file->recv_wait);\n\t\tmutex_unlock(&file->mutex);\n\n\t\tfor (id = 0; id < IB_UMAD_MAX_AGENTS; ++id)\n\t\t\tif (file->agent[id])\n\t\t\t\tib_unregister_mad_agent(file->agent[id]);\n\t}\n\n\tmutex_unlock(&port->file_mutex);\n\n\tida_free(&umad_ida, port->dev_num);\n\n\t \n\tput_device(&port->sm_dev);\n\tput_device(&port->dev);\n}\n\nstatic int ib_umad_add_one(struct ib_device *device)\n{\n\tstruct ib_umad_device *umad_dev;\n\tint s, e, i;\n\tint count = 0;\n\tint ret;\n\n\ts = rdma_start_port(device);\n\te = rdma_end_port(device);\n\n\tumad_dev = kzalloc(struct_size(umad_dev, ports,\n\t\t\t\t       size_add(size_sub(e, s), 1)),\n\t\t\t   GFP_KERNEL);\n\tif (!umad_dev)\n\t\treturn -ENOMEM;\n\n\tkref_init(&umad_dev->kref);\n\tfor (i = s; i <= e; ++i) {\n\t\tif (!rdma_cap_ib_mad(device, i))\n\t\t\tcontinue;\n\n\t\tret = ib_umad_init_port(device, i, umad_dev,\n\t\t\t\t\t&umad_dev->ports[i - s]);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tcount++;\n\t}\n\n\tif (!count) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto free;\n\t}\n\n\tib_set_client_data(device, &umad_client, umad_dev);\n\n\treturn 0;\n\nerr:\n\twhile (--i >= s) {\n\t\tif (!rdma_cap_ib_mad(device, i))\n\t\t\tcontinue;\n\n\t\tib_umad_kill_port(&umad_dev->ports[i - s]);\n\t}\nfree:\n\t \n\tib_umad_dev_put(umad_dev);\n\treturn ret;\n}\n\nstatic void ib_umad_remove_one(struct ib_device *device, void *client_data)\n{\n\tstruct ib_umad_device *umad_dev = client_data;\n\tunsigned int i;\n\n\trdma_for_each_port (device, i) {\n\t\tif (rdma_cap_ib_mad(device, i))\n\t\t\tib_umad_kill_port(\n\t\t\t\t&umad_dev->ports[i - rdma_start_port(device)]);\n\t}\n\t \n\tib_umad_dev_put(umad_dev);\n}\n\nstatic int __init ib_umad_init(void)\n{\n\tint ret;\n\n\tret = register_chrdev_region(base_umad_dev,\n\t\t\t\t     IB_UMAD_NUM_FIXED_MINOR * 2,\n\t\t\t\t     umad_class.name);\n\tif (ret) {\n\t\tpr_err(\"couldn't register device number\\n\");\n\t\tgoto out;\n\t}\n\n\tret = alloc_chrdev_region(&dynamic_umad_dev, 0,\n\t\t\t\t  IB_UMAD_NUM_DYNAMIC_MINOR * 2,\n\t\t\t\t  umad_class.name);\n\tif (ret) {\n\t\tpr_err(\"couldn't register dynamic device number\\n\");\n\t\tgoto out_alloc;\n\t}\n\tdynamic_issm_dev = dynamic_umad_dev + IB_UMAD_NUM_DYNAMIC_MINOR;\n\n\tret = class_register(&umad_class);\n\tif (ret) {\n\t\tpr_err(\"couldn't create class infiniband_mad\\n\");\n\t\tgoto out_chrdev;\n\t}\n\n\tret = ib_register_client(&umad_client);\n\tif (ret)\n\t\tgoto out_class;\n\n\tret = ib_register_client(&issm_client);\n\tif (ret)\n\t\tgoto out_client;\n\n\treturn 0;\n\nout_client:\n\tib_unregister_client(&umad_client);\nout_class:\n\tclass_unregister(&umad_class);\n\nout_chrdev:\n\tunregister_chrdev_region(dynamic_umad_dev,\n\t\t\t\t IB_UMAD_NUM_DYNAMIC_MINOR * 2);\n\nout_alloc:\n\tunregister_chrdev_region(base_umad_dev,\n\t\t\t\t IB_UMAD_NUM_FIXED_MINOR * 2);\n\nout:\n\treturn ret;\n}\n\nstatic void __exit ib_umad_cleanup(void)\n{\n\tib_unregister_client(&issm_client);\n\tib_unregister_client(&umad_client);\n\tclass_unregister(&umad_class);\n\tunregister_chrdev_region(base_umad_dev,\n\t\t\t\t IB_UMAD_NUM_FIXED_MINOR * 2);\n\tunregister_chrdev_region(dynamic_umad_dev,\n\t\t\t\t IB_UMAD_NUM_DYNAMIC_MINOR * 2);\n}\n\nmodule_init(ib_umad_init);\nmodule_exit(ib_umad_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}