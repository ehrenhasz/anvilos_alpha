{
  "module_name": "uverbs_std_types_counters.c",
  "hash_id": "04544fdc6bf6222e9643411844e462b53e5c943b68979a625fd15855898771bb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/core/uverbs_std_types_counters.c",
  "human_readable_source": "\n \n\n#include \"rdma_core.h\"\n#include \"uverbs.h\"\n#include <rdma/uverbs_std_types.h>\n\nstatic int uverbs_free_counters(struct ib_uobject *uobject,\n\t\t\t\tenum rdma_remove_reason why,\n\t\t\t\tstruct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_counters *counters = uobject->object;\n\tint ret;\n\n\tif (atomic_read(&counters->usecnt))\n\t\treturn -EBUSY;\n\n\tret = counters->device->ops.destroy_counters(counters);\n\tif (ret)\n\t\treturn ret;\n\tkfree(counters);\n\treturn 0;\n}\n\nstatic int UVERBS_HANDLER(UVERBS_METHOD_COUNTERS_CREATE)(\n\tstruct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uobject *uobj = uverbs_attr_get_uobject(\n\t\tattrs, UVERBS_ATTR_CREATE_COUNTERS_HANDLE);\n\tstruct ib_device *ib_dev = attrs->context->device;\n\tstruct ib_counters *counters;\n\tint ret;\n\n\t \n\tif (!ib_dev->ops.create_counters)\n\t\treturn -EOPNOTSUPP;\n\n\tcounters = rdma_zalloc_drv_obj(ib_dev, ib_counters);\n\tif (!counters)\n\t\treturn -ENOMEM;\n\n\tcounters->device = ib_dev;\n\tcounters->uobject = uobj;\n\tuobj->object = counters;\n\tatomic_set(&counters->usecnt, 0);\n\n\tret = ib_dev->ops.create_counters(counters, attrs);\n\tif (ret)\n\t\tkfree(counters);\n\n\treturn ret;\n}\n\nstatic int UVERBS_HANDLER(UVERBS_METHOD_COUNTERS_READ)(\n\tstruct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_counters_read_attr read_attr = {};\n\tconst struct uverbs_attr *uattr;\n\tstruct ib_counters *counters =\n\t\tuverbs_attr_get_obj(attrs, UVERBS_ATTR_READ_COUNTERS_HANDLE);\n\tint ret;\n\n\tif (!counters->device->ops.read_counters)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!atomic_read(&counters->usecnt))\n\t\treturn -EINVAL;\n\n\tret = uverbs_get_flags32(&read_attr.flags, attrs,\n\t\t\t\t UVERBS_ATTR_READ_COUNTERS_FLAGS,\n\t\t\t\t IB_UVERBS_READ_COUNTERS_PREFER_CACHED);\n\tif (ret)\n\t\treturn ret;\n\n\tuattr = uverbs_attr_get(attrs, UVERBS_ATTR_READ_COUNTERS_BUFF);\n\tif (IS_ERR(uattr))\n\t\treturn PTR_ERR(uattr);\n\tread_attr.ncounters = uattr->ptr_attr.len / sizeof(u64);\n\tread_attr.counters_buff = uverbs_zalloc(\n\t\tattrs, array_size(read_attr.ncounters, sizeof(u64)));\n\tif (IS_ERR(read_attr.counters_buff))\n\t\treturn PTR_ERR(read_attr.counters_buff);\n\n\tret = counters->device->ops.read_counters(counters, &read_attr, attrs);\n\tif (ret)\n\t\treturn ret;\n\n\treturn uverbs_copy_to(attrs, UVERBS_ATTR_READ_COUNTERS_BUFF,\n\t\t\t      read_attr.counters_buff,\n\t\t\t      read_attr.ncounters * sizeof(u64));\n}\n\nDECLARE_UVERBS_NAMED_METHOD(\n\tUVERBS_METHOD_COUNTERS_CREATE,\n\tUVERBS_ATTR_IDR(UVERBS_ATTR_CREATE_COUNTERS_HANDLE,\n\t\t\tUVERBS_OBJECT_COUNTERS,\n\t\t\tUVERBS_ACCESS_NEW,\n\t\t\tUA_MANDATORY));\n\nDECLARE_UVERBS_NAMED_METHOD_DESTROY(\n\tUVERBS_METHOD_COUNTERS_DESTROY,\n\tUVERBS_ATTR_IDR(UVERBS_ATTR_DESTROY_COUNTERS_HANDLE,\n\t\t\tUVERBS_OBJECT_COUNTERS,\n\t\t\tUVERBS_ACCESS_DESTROY,\n\t\t\tUA_MANDATORY));\n\nDECLARE_UVERBS_NAMED_METHOD(\n\tUVERBS_METHOD_COUNTERS_READ,\n\tUVERBS_ATTR_IDR(UVERBS_ATTR_READ_COUNTERS_HANDLE,\n\t\t\tUVERBS_OBJECT_COUNTERS,\n\t\t\tUVERBS_ACCESS_READ,\n\t\t\tUA_MANDATORY),\n\tUVERBS_ATTR_PTR_OUT(UVERBS_ATTR_READ_COUNTERS_BUFF,\n\t\t\t    UVERBS_ATTR_MIN_SIZE(0),\n\t\t\t    UA_MANDATORY),\n\tUVERBS_ATTR_FLAGS_IN(UVERBS_ATTR_READ_COUNTERS_FLAGS,\n\t\t\t     enum ib_uverbs_read_counters_flags));\n\nDECLARE_UVERBS_NAMED_OBJECT(UVERBS_OBJECT_COUNTERS,\n\t\t\t    UVERBS_TYPE_ALLOC_IDR(uverbs_free_counters),\n\t\t\t    &UVERBS_METHOD(UVERBS_METHOD_COUNTERS_CREATE),\n\t\t\t    &UVERBS_METHOD(UVERBS_METHOD_COUNTERS_DESTROY),\n\t\t\t    &UVERBS_METHOD(UVERBS_METHOD_COUNTERS_READ));\n\nconst struct uapi_definition uverbs_def_obj_counters[] = {\n\tUAPI_DEF_CHAIN_OBJ_TREE_NAMED(UVERBS_OBJECT_COUNTERS,\n\t\t\t\t      UAPI_DEF_OBJ_NEEDS_FN(destroy_counters)),\n\t{}\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}