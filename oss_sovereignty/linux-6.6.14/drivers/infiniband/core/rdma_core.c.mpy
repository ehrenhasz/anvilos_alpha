{
  "module_name": "rdma_core.c",
  "hash_id": "445bc294edbd51f7192a023da2125f7b80719c7770dd0e25662be5a94f53517d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/core/rdma_core.c",
  "human_readable_source": " \n\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/sched/mm.h>\n#include <rdma/ib_verbs.h>\n#include <rdma/uverbs_types.h>\n#include <linux/rcupdate.h>\n#include <rdma/uverbs_ioctl.h>\n#include <rdma/rdma_user_ioctl.h>\n#include \"uverbs.h\"\n#include \"core_priv.h\"\n#include \"rdma_core.h\"\n\nstatic void uverbs_uobject_free(struct kref *ref)\n{\n\tkfree_rcu(container_of(ref, struct ib_uobject, ref), rcu);\n}\n\n \nvoid uverbs_uobject_put(struct ib_uobject *uobject)\n{\n\tkref_put(&uobject->ref, uverbs_uobject_free);\n}\nEXPORT_SYMBOL(uverbs_uobject_put);\n\nstatic int uverbs_try_lock_object(struct ib_uobject *uobj,\n\t\t\t\t  enum rdma_lookup_mode mode)\n{\n\t \n\tswitch (mode) {\n\tcase UVERBS_LOOKUP_READ:\n\t\treturn atomic_fetch_add_unless(&uobj->usecnt, 1, -1) == -1 ?\n\t\t\t-EBUSY : 0;\n\tcase UVERBS_LOOKUP_WRITE:\n\t\t \n\t\treturn atomic_cmpxchg(&uobj->usecnt, 0, -1) == 0 ? 0 : -EBUSY;\n\tcase UVERBS_LOOKUP_DESTROY:\n\t\treturn 0;\n\t}\n\treturn 0;\n}\n\nstatic void assert_uverbs_usecnt(struct ib_uobject *uobj,\n\t\t\t\t enum rdma_lookup_mode mode)\n{\n#ifdef CONFIG_LOCKDEP\n\tswitch (mode) {\n\tcase UVERBS_LOOKUP_READ:\n\t\tWARN_ON(atomic_read(&uobj->usecnt) <= 0);\n\t\tbreak;\n\tcase UVERBS_LOOKUP_WRITE:\n\t\tWARN_ON(atomic_read(&uobj->usecnt) != -1);\n\t\tbreak;\n\tcase UVERBS_LOOKUP_DESTROY:\n\t\tbreak;\n\t}\n#endif\n}\n\n \nstatic int uverbs_destroy_uobject(struct ib_uobject *uobj,\n\t\t\t\t  enum rdma_remove_reason reason,\n\t\t\t\t  struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uverbs_file *ufile = attrs->ufile;\n\tunsigned long flags;\n\tint ret;\n\n\tlockdep_assert_held(&ufile->hw_destroy_rwsem);\n\tassert_uverbs_usecnt(uobj, UVERBS_LOOKUP_WRITE);\n\n\tif (reason == RDMA_REMOVE_ABORT) {\n\t\tWARN_ON(!list_empty(&uobj->list));\n\t\tWARN_ON(!uobj->context);\n\t\tuobj->uapi_object->type_class->alloc_abort(uobj);\n\t} else if (uobj->object) {\n\t\tret = uobj->uapi_object->type_class->destroy_hw(uobj, reason,\n\t\t\t\t\t\t\t\tattrs);\n\t\tif (ret)\n\t\t\t \n\t\t\treturn ret;\n\n\t\tuobj->object = NULL;\n\t}\n\n\tuobj->context = NULL;\n\n\t \n\tif (reason != RDMA_REMOVE_DESTROY)\n\t\tatomic_set(&uobj->usecnt, 0);\n\telse\n\t\tuobj->uapi_object->type_class->remove_handle(uobj);\n\n\tif (!list_empty(&uobj->list)) {\n\t\tspin_lock_irqsave(&ufile->uobjects_lock, flags);\n\t\tlist_del_init(&uobj->list);\n\t\tspin_unlock_irqrestore(&ufile->uobjects_lock, flags);\n\n\t\t \n\t\tuverbs_uobject_put(uobj);\n\t}\n\n\t \n\tif (reason == RDMA_REMOVE_ABORT)\n\t\tuverbs_uobject_put(uobj);\n\n\treturn 0;\n}\n\n \nint uobj_destroy(struct ib_uobject *uobj, struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uverbs_file *ufile = attrs->ufile;\n\tint ret;\n\n\tdown_read(&ufile->hw_destroy_rwsem);\n\n\t \n\tret = uverbs_try_lock_object(uobj, UVERBS_LOOKUP_WRITE);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = uverbs_destroy_uobject(uobj, RDMA_REMOVE_DESTROY, attrs);\n\tif (ret) {\n\t\tatomic_set(&uobj->usecnt, 0);\n\t\tgoto out_unlock;\n\t}\n\nout_unlock:\n\tup_read(&ufile->hw_destroy_rwsem);\n\treturn ret;\n}\n\n \nstruct ib_uobject *__uobj_get_destroy(const struct uverbs_api_object *obj,\n\t\t\t\t      u32 id, struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uobject *uobj;\n\tint ret;\n\n\tuobj = rdma_lookup_get_uobject(obj, attrs->ufile, id,\n\t\t\t\t       UVERBS_LOOKUP_DESTROY, attrs);\n\tif (IS_ERR(uobj))\n\t\treturn uobj;\n\n\tret = uobj_destroy(uobj, attrs);\n\tif (ret) {\n\t\trdma_lookup_put_uobject(uobj, UVERBS_LOOKUP_DESTROY);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn uobj;\n}\n\n \nint __uobj_perform_destroy(const struct uverbs_api_object *obj, u32 id,\n\t\t\t   struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uobject *uobj;\n\n\tuobj = __uobj_get_destroy(obj, id, attrs);\n\tif (IS_ERR(uobj))\n\t\treturn PTR_ERR(uobj);\n\tuobj_put_destroy(uobj);\n\treturn 0;\n}\n\n \nstatic struct ib_uobject *alloc_uobj(struct uverbs_attr_bundle *attrs,\n\t\t\t\t     const struct uverbs_api_object *obj)\n{\n\tstruct ib_uverbs_file *ufile = attrs->ufile;\n\tstruct ib_uobject *uobj;\n\n\tif (!attrs->context) {\n\t\tstruct ib_ucontext *ucontext =\n\t\t\tib_uverbs_get_ucontext_file(ufile);\n\n\t\tif (IS_ERR(ucontext))\n\t\t\treturn ERR_CAST(ucontext);\n\t\tattrs->context = ucontext;\n\t}\n\n\tuobj = kzalloc(obj->type_attrs->obj_size, GFP_KERNEL);\n\tif (!uobj)\n\t\treturn ERR_PTR(-ENOMEM);\n\t \n\tuobj->ufile = ufile;\n\tuobj->context = attrs->context;\n\tINIT_LIST_HEAD(&uobj->list);\n\tuobj->uapi_object = obj;\n\t \n\tatomic_set(&uobj->usecnt, -1);\n\tkref_init(&uobj->ref);\n\n\treturn uobj;\n}\n\nstatic int idr_add_uobj(struct ib_uobject *uobj)\n{\n        \n\treturn xa_alloc(&uobj->ufile->idr, &uobj->id, NULL, xa_limit_32b,\n\t\t\tGFP_KERNEL);\n}\n\n \nstatic struct ib_uobject *\nlookup_get_idr_uobject(const struct uverbs_api_object *obj,\n\t\t       struct ib_uverbs_file *ufile, s64 id,\n\t\t       enum rdma_lookup_mode mode)\n{\n\tstruct ib_uobject *uobj;\n\n\tif (id < 0 || id > ULONG_MAX)\n\t\treturn ERR_PTR(-EINVAL);\n\n\trcu_read_lock();\n\t \n\tuobj = xa_load(&ufile->idr, id);\n\tif (!uobj || !kref_get_unless_zero(&uobj->ref))\n\t\tuobj = ERR_PTR(-ENOENT);\n\trcu_read_unlock();\n\treturn uobj;\n}\n\nstatic struct ib_uobject *\nlookup_get_fd_uobject(const struct uverbs_api_object *obj,\n\t\t      struct ib_uverbs_file *ufile, s64 id,\n\t\t      enum rdma_lookup_mode mode)\n{\n\tconst struct uverbs_obj_fd_type *fd_type;\n\tstruct file *f;\n\tstruct ib_uobject *uobject;\n\tint fdno = id;\n\n\tif (fdno != id)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (mode != UVERBS_LOOKUP_READ)\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tif (!obj->type_attrs)\n\t\treturn ERR_PTR(-EIO);\n\tfd_type =\n\t\tcontainer_of(obj->type_attrs, struct uverbs_obj_fd_type, type);\n\n\tf = fget(fdno);\n\tif (!f)\n\t\treturn ERR_PTR(-EBADF);\n\n\tuobject = f->private_data;\n\t \n\tif (f->f_op != fd_type->fops || uobject->ufile != ufile) {\n\t\tfput(f);\n\t\treturn ERR_PTR(-EBADF);\n\t}\n\n\tuverbs_uobject_get(uobject);\n\treturn uobject;\n}\n\nstruct ib_uobject *rdma_lookup_get_uobject(const struct uverbs_api_object *obj,\n\t\t\t\t\t   struct ib_uverbs_file *ufile, s64 id,\n\t\t\t\t\t   enum rdma_lookup_mode mode,\n\t\t\t\t\t   struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uobject *uobj;\n\tint ret;\n\n\tif (obj == ERR_PTR(-ENOMSG)) {\n\t\t \n\t\tuobj = lookup_get_idr_uobject(NULL, ufile, id, mode);\n\t\tif (IS_ERR(uobj))\n\t\t\treturn uobj;\n\t} else {\n\t\tif (IS_ERR(obj))\n\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\tuobj = obj->type_class->lookup_get(obj, ufile, id, mode);\n\t\tif (IS_ERR(uobj))\n\t\t\treturn uobj;\n\n\t\tif (uobj->uapi_object != obj) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\t \n\tif (mode != UVERBS_LOOKUP_DESTROY &&\n\t    !srcu_dereference(ufile->device->ib_dev,\n\t\t\t      &ufile->device->disassociate_srcu)) {\n\t\tret = -EIO;\n\t\tgoto free;\n\t}\n\n\tret = uverbs_try_lock_object(uobj, mode);\n\tif (ret)\n\t\tgoto free;\n\tif (attrs)\n\t\tattrs->context = uobj->context;\n\n\treturn uobj;\nfree:\n\tuobj->uapi_object->type_class->lookup_put(uobj, mode);\n\tuverbs_uobject_put(uobj);\n\treturn ERR_PTR(ret);\n}\n\nstatic struct ib_uobject *\nalloc_begin_idr_uobject(const struct uverbs_api_object *obj,\n\t\t\tstruct uverbs_attr_bundle *attrs)\n{\n\tint ret;\n\tstruct ib_uobject *uobj;\n\n\tuobj = alloc_uobj(attrs, obj);\n\tif (IS_ERR(uobj))\n\t\treturn uobj;\n\n\tret = idr_add_uobj(uobj);\n\tif (ret)\n\t\tgoto uobj_put;\n\n\tret = ib_rdmacg_try_charge(&uobj->cg_obj, uobj->context->device,\n\t\t\t\t   RDMACG_RESOURCE_HCA_OBJECT);\n\tif (ret)\n\t\tgoto remove;\n\n\treturn uobj;\n\nremove:\n\txa_erase(&attrs->ufile->idr, uobj->id);\nuobj_put:\n\tuverbs_uobject_put(uobj);\n\treturn ERR_PTR(ret);\n}\n\nstatic struct ib_uobject *\nalloc_begin_fd_uobject(const struct uverbs_api_object *obj,\n\t\t       struct uverbs_attr_bundle *attrs)\n{\n\tconst struct uverbs_obj_fd_type *fd_type;\n\tint new_fd;\n\tstruct ib_uobject *uobj, *ret;\n\tstruct file *filp;\n\n\tuobj = alloc_uobj(attrs, obj);\n\tif (IS_ERR(uobj))\n\t\treturn uobj;\n\n\tfd_type =\n\t\tcontainer_of(obj->type_attrs, struct uverbs_obj_fd_type, type);\n\tif (WARN_ON(fd_type->fops->release != &uverbs_uobject_fd_release &&\n\t\t    fd_type->fops->release != &uverbs_async_event_release)) {\n\t\tret = ERR_PTR(-EINVAL);\n\t\tgoto err_fd;\n\t}\n\n\tnew_fd = get_unused_fd_flags(O_CLOEXEC);\n\tif (new_fd < 0) {\n\t\tret = ERR_PTR(new_fd);\n\t\tgoto err_fd;\n\t}\n\n\t \n\tfilp = anon_inode_getfile(fd_type->name, fd_type->fops, NULL,\n\t\t\t\t  fd_type->flags);\n\tif (IS_ERR(filp)) {\n\t\tret = ERR_CAST(filp);\n\t\tgoto err_getfile;\n\t}\n\tuobj->object = filp;\n\n\tuobj->id = new_fd;\n\treturn uobj;\n\nerr_getfile:\n\tput_unused_fd(new_fd);\nerr_fd:\n\tuverbs_uobject_put(uobj);\n\treturn ret;\n}\n\nstruct ib_uobject *rdma_alloc_begin_uobject(const struct uverbs_api_object *obj,\n\t\t\t\t\t    struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uverbs_file *ufile = attrs->ufile;\n\tstruct ib_uobject *ret;\n\n\tif (IS_ERR(obj))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\tif (!down_read_trylock(&ufile->hw_destroy_rwsem))\n\t\treturn ERR_PTR(-EIO);\n\n\tret = obj->type_class->alloc_begin(obj, attrs);\n\tif (IS_ERR(ret)) {\n\t\tup_read(&ufile->hw_destroy_rwsem);\n\t\treturn ret;\n\t}\n\treturn ret;\n}\n\nstatic void alloc_abort_idr_uobject(struct ib_uobject *uobj)\n{\n\tib_rdmacg_uncharge(&uobj->cg_obj, uobj->context->device,\n\t\t\t   RDMACG_RESOURCE_HCA_OBJECT);\n\n\txa_erase(&uobj->ufile->idr, uobj->id);\n}\n\nstatic int __must_check destroy_hw_idr_uobject(struct ib_uobject *uobj,\n\t\t\t\t\t       enum rdma_remove_reason why,\n\t\t\t\t\t       struct uverbs_attr_bundle *attrs)\n{\n\tconst struct uverbs_obj_idr_type *idr_type =\n\t\tcontainer_of(uobj->uapi_object->type_attrs,\n\t\t\t     struct uverbs_obj_idr_type, type);\n\tint ret = idr_type->destroy_object(uobj, why, attrs);\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (why == RDMA_REMOVE_ABORT)\n\t\treturn 0;\n\n\tib_rdmacg_uncharge(&uobj->cg_obj, uobj->context->device,\n\t\t\t   RDMACG_RESOURCE_HCA_OBJECT);\n\n\treturn 0;\n}\n\nstatic void remove_handle_idr_uobject(struct ib_uobject *uobj)\n{\n\txa_erase(&uobj->ufile->idr, uobj->id);\n\t \n\tuverbs_uobject_put(uobj);\n}\n\nstatic void alloc_abort_fd_uobject(struct ib_uobject *uobj)\n{\n\tstruct file *filp = uobj->object;\n\n\tfput(filp);\n\tput_unused_fd(uobj->id);\n}\n\nstatic int __must_check destroy_hw_fd_uobject(struct ib_uobject *uobj,\n\t\t\t\t\t      enum rdma_remove_reason why,\n\t\t\t\t\t      struct uverbs_attr_bundle *attrs)\n{\n\tconst struct uverbs_obj_fd_type *fd_type = container_of(\n\t\tuobj->uapi_object->type_attrs, struct uverbs_obj_fd_type, type);\n\n\tfd_type->destroy_object(uobj, why);\n\treturn 0;\n}\n\nstatic void remove_handle_fd_uobject(struct ib_uobject *uobj)\n{\n}\n\nstatic void alloc_commit_idr_uobject(struct ib_uobject *uobj)\n{\n\tstruct ib_uverbs_file *ufile = uobj->ufile;\n\tvoid *old;\n\n\t \n\told = xa_store(&ufile->idr, uobj->id, uobj, GFP_KERNEL);\n\tWARN_ON(old != NULL);\n}\n\nstatic void swap_idr_uobjects(struct ib_uobject *obj_old,\n\t\t\t     struct ib_uobject *obj_new)\n{\n\tstruct ib_uverbs_file *ufile = obj_old->ufile;\n\tvoid *old;\n\n\t \n\told = xa_cmpxchg(&ufile->idr, obj_old->id, obj_old, XA_ZERO_ENTRY,\n\t\t\t GFP_KERNEL);\n\tif (WARN_ON(old != obj_old))\n\t\treturn;\n\n\tswap(obj_old->id, obj_new->id);\n\n\told = xa_cmpxchg(&ufile->idr, obj_old->id, NULL, obj_old, GFP_KERNEL);\n\tWARN_ON(old != NULL);\n}\n\nstatic void alloc_commit_fd_uobject(struct ib_uobject *uobj)\n{\n\tint fd = uobj->id;\n\tstruct file *filp = uobj->object;\n\n\t \n\tkref_get(&uobj->ufile->ref);\n\n\t \n\tuobj->id = 0;\n\n\t \n\tfilp->private_data = uobj;\n\tfd_install(fd, filp);\n}\n\n \nvoid rdma_alloc_commit_uobject(struct ib_uobject *uobj,\n\t\t\t       struct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uverbs_file *ufile = attrs->ufile;\n\n\t \n\tuverbs_uobject_get(uobj);\n\tspin_lock_irq(&ufile->uobjects_lock);\n\tlist_add(&uobj->list, &ufile->uobjects);\n\tspin_unlock_irq(&ufile->uobjects_lock);\n\n\t \n\tatomic_set(&uobj->usecnt, 0);\n\n\t \n\tuobj->uapi_object->type_class->alloc_commit(uobj);\n\n\t \n\tup_read(&ufile->hw_destroy_rwsem);\n}\n\n \nvoid rdma_assign_uobject(struct ib_uobject *to_uobj, struct ib_uobject *new_uobj,\n\t\t\tstruct uverbs_attr_bundle *attrs)\n{\n\tassert_uverbs_usecnt(new_uobj, UVERBS_LOOKUP_WRITE);\n\n\tif (WARN_ON(to_uobj->uapi_object != new_uobj->uapi_object ||\n\t\t    !to_uobj->uapi_object->type_class->swap_uobjects))\n\t\treturn;\n\n\tto_uobj->uapi_object->type_class->swap_uobjects(to_uobj, new_uobj);\n\n\t \n\tuverbs_destroy_uobject(to_uobj, RDMA_REMOVE_DESTROY, attrs);\n}\n\n \nvoid rdma_alloc_abort_uobject(struct ib_uobject *uobj,\n\t\t\t      struct uverbs_attr_bundle *attrs,\n\t\t\t      bool hw_obj_valid)\n{\n\tstruct ib_uverbs_file *ufile = uobj->ufile;\n\tint ret;\n\n\tif (hw_obj_valid) {\n\t\tret = uobj->uapi_object->type_class->destroy_hw(\n\t\t\tuobj, RDMA_REMOVE_ABORT, attrs);\n\t\t \n\t\tif (WARN_ON(ret))\n\t\t\treturn rdma_alloc_commit_uobject(uobj, attrs);\n\t}\n\n\tuverbs_destroy_uobject(uobj, RDMA_REMOVE_ABORT, attrs);\n\n\t \n\tup_read(&ufile->hw_destroy_rwsem);\n}\n\nstatic void lookup_put_idr_uobject(struct ib_uobject *uobj,\n\t\t\t\t   enum rdma_lookup_mode mode)\n{\n}\n\nstatic void lookup_put_fd_uobject(struct ib_uobject *uobj,\n\t\t\t\t  enum rdma_lookup_mode mode)\n{\n\tstruct file *filp = uobj->object;\n\n\tWARN_ON(mode != UVERBS_LOOKUP_READ);\n\t \n\tfput(filp);\n}\n\nvoid rdma_lookup_put_uobject(struct ib_uobject *uobj,\n\t\t\t     enum rdma_lookup_mode mode)\n{\n\tassert_uverbs_usecnt(uobj, mode);\n\t \n\tswitch (mode) {\n\tcase UVERBS_LOOKUP_READ:\n\t\tatomic_dec(&uobj->usecnt);\n\t\tbreak;\n\tcase UVERBS_LOOKUP_WRITE:\n\t\tatomic_set(&uobj->usecnt, 0);\n\t\tbreak;\n\tcase UVERBS_LOOKUP_DESTROY:\n\t\tbreak;\n\t}\n\n\tuobj->uapi_object->type_class->lookup_put(uobj, mode);\n\t \n\tuverbs_uobject_put(uobj);\n}\n\nvoid setup_ufile_idr_uobject(struct ib_uverbs_file *ufile)\n{\n\txa_init_flags(&ufile->idr, XA_FLAGS_ALLOC);\n}\n\nvoid release_ufile_idr_uobject(struct ib_uverbs_file *ufile)\n{\n\tstruct ib_uobject *entry;\n\tunsigned long id;\n\n\t \n\txa_for_each(&ufile->idr, id, entry) {\n\t\tWARN_ON(entry->object);\n\t\tuverbs_uobject_put(entry);\n\t}\n\n\txa_destroy(&ufile->idr);\n}\n\nconst struct uverbs_obj_type_class uverbs_idr_class = {\n\t.alloc_begin = alloc_begin_idr_uobject,\n\t.lookup_get = lookup_get_idr_uobject,\n\t.alloc_commit = alloc_commit_idr_uobject,\n\t.alloc_abort = alloc_abort_idr_uobject,\n\t.lookup_put = lookup_put_idr_uobject,\n\t.destroy_hw = destroy_hw_idr_uobject,\n\t.remove_handle = remove_handle_idr_uobject,\n\t.swap_uobjects = swap_idr_uobjects,\n};\nEXPORT_SYMBOL(uverbs_idr_class);\n\n \nint uverbs_uobject_fd_release(struct inode *inode, struct file *filp)\n{\n\tstruct ib_uverbs_file *ufile;\n\tstruct ib_uobject *uobj;\n\n\t \n\tif (!filp->private_data)\n\t\treturn 0;\n\tuobj = filp->private_data;\n\tufile = uobj->ufile;\n\n\tif (down_read_trylock(&ufile->hw_destroy_rwsem)) {\n\t\tstruct uverbs_attr_bundle attrs = {\n\t\t\t.context = uobj->context,\n\t\t\t.ufile = ufile,\n\t\t};\n\n\t\t \n\t\tWARN_ON(uverbs_try_lock_object(uobj, UVERBS_LOOKUP_WRITE));\n\t\tuverbs_destroy_uobject(uobj, RDMA_REMOVE_CLOSE, &attrs);\n\t\tup_read(&ufile->hw_destroy_rwsem);\n\t}\n\n\t \n\tkref_put(&ufile->ref, ib_uverbs_release_file);\n\n\t \n\tuverbs_uobject_put(uobj);\n\treturn 0;\n}\nEXPORT_SYMBOL(uverbs_uobject_fd_release);\n\n \nstatic void ufile_destroy_ucontext(struct ib_uverbs_file *ufile,\n\t\t\t\t   enum rdma_remove_reason reason)\n{\n\tstruct ib_ucontext *ucontext = ufile->ucontext;\n\tstruct ib_device *ib_dev = ucontext->device;\n\n\t \n\tif (reason == RDMA_REMOVE_DRIVER_REMOVE) {\n\t\tuverbs_user_mmap_disassociate(ufile);\n\t\tif (ib_dev->ops.disassociate_ucontext)\n\t\t\tib_dev->ops.disassociate_ucontext(ucontext);\n\t}\n\n\tib_rdmacg_uncharge(&ucontext->cg_obj, ib_dev,\n\t\t\t   RDMACG_RESOURCE_HCA_HANDLE);\n\n\trdma_restrack_del(&ucontext->res);\n\n\tib_dev->ops.dealloc_ucontext(ucontext);\n\tWARN_ON(!xa_empty(&ucontext->mmap_xa));\n\tkfree(ucontext);\n\n\tufile->ucontext = NULL;\n}\n\nstatic int __uverbs_cleanup_ufile(struct ib_uverbs_file *ufile,\n\t\t\t\t  enum rdma_remove_reason reason)\n{\n\tstruct ib_uobject *obj, *next_obj;\n\tint ret = -EINVAL;\n\tstruct uverbs_attr_bundle attrs = { .ufile = ufile };\n\n\t \n\tlist_for_each_entry_safe(obj, next_obj, &ufile->uobjects, list) {\n\t\tattrs.context = obj->context;\n\t\t \n\t\tWARN_ON(uverbs_try_lock_object(obj, UVERBS_LOOKUP_WRITE));\n\t\tif (reason == RDMA_REMOVE_DRIVER_FAILURE)\n\t\t\tobj->object = NULL;\n\t\tif (!uverbs_destroy_uobject(obj, reason, &attrs))\n\t\t\tret = 0;\n\t\telse\n\t\t\tatomic_set(&obj->usecnt, 0);\n\t}\n\n\tif (reason == RDMA_REMOVE_DRIVER_FAILURE) {\n\t\tWARN_ON(!list_empty(&ufile->uobjects));\n\t\treturn 0;\n\t}\n\treturn ret;\n}\n\n \nvoid uverbs_destroy_ufile_hw(struct ib_uverbs_file *ufile,\n\t\t\t     enum rdma_remove_reason reason)\n{\n\tdown_write(&ufile->hw_destroy_rwsem);\n\n\t \n\tif (!ufile->ucontext)\n\t\tgoto done;\n\n\twhile (!list_empty(&ufile->uobjects) &&\n\t       !__uverbs_cleanup_ufile(ufile, reason)) {\n\t}\n\n\tif (WARN_ON(!list_empty(&ufile->uobjects)))\n\t\t__uverbs_cleanup_ufile(ufile, RDMA_REMOVE_DRIVER_FAILURE);\n\tufile_destroy_ucontext(ufile, reason);\n\ndone:\n\tup_write(&ufile->hw_destroy_rwsem);\n}\n\nconst struct uverbs_obj_type_class uverbs_fd_class = {\n\t.alloc_begin = alloc_begin_fd_uobject,\n\t.lookup_get = lookup_get_fd_uobject,\n\t.alloc_commit = alloc_commit_fd_uobject,\n\t.alloc_abort = alloc_abort_fd_uobject,\n\t.lookup_put = lookup_put_fd_uobject,\n\t.destroy_hw = destroy_hw_fd_uobject,\n\t.remove_handle = remove_handle_fd_uobject,\n};\nEXPORT_SYMBOL(uverbs_fd_class);\n\nstruct ib_uobject *\nuverbs_get_uobject_from_file(u16 object_id, enum uverbs_obj_access access,\n\t\t\t     s64 id, struct uverbs_attr_bundle *attrs)\n{\n\tconst struct uverbs_api_object *obj =\n\t\tuapi_get_object(attrs->ufile->device->uapi, object_id);\n\n\tswitch (access) {\n\tcase UVERBS_ACCESS_READ:\n\t\treturn rdma_lookup_get_uobject(obj, attrs->ufile, id,\n\t\t\t\t\t       UVERBS_LOOKUP_READ, attrs);\n\tcase UVERBS_ACCESS_DESTROY:\n\t\t \n\t\treturn rdma_lookup_get_uobject(obj, attrs->ufile, id,\n\t\t\t\t\t       UVERBS_LOOKUP_DESTROY, attrs);\n\tcase UVERBS_ACCESS_WRITE:\n\t\treturn rdma_lookup_get_uobject(obj, attrs->ufile, id,\n\t\t\t\t\t       UVERBS_LOOKUP_WRITE, attrs);\n\tcase UVERBS_ACCESS_NEW:\n\t\treturn rdma_alloc_begin_uobject(obj, attrs);\n\tdefault:\n\t\tWARN_ON(true);\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\t}\n}\n\nvoid uverbs_finalize_object(struct ib_uobject *uobj,\n\t\t\t    enum uverbs_obj_access access, bool hw_obj_valid,\n\t\t\t    bool commit, struct uverbs_attr_bundle *attrs)\n{\n\t \n\n\tswitch (access) {\n\tcase UVERBS_ACCESS_READ:\n\t\trdma_lookup_put_uobject(uobj, UVERBS_LOOKUP_READ);\n\t\tbreak;\n\tcase UVERBS_ACCESS_WRITE:\n\t\trdma_lookup_put_uobject(uobj, UVERBS_LOOKUP_WRITE);\n\t\tbreak;\n\tcase UVERBS_ACCESS_DESTROY:\n\t\tif (uobj)\n\t\t\trdma_lookup_put_uobject(uobj, UVERBS_LOOKUP_DESTROY);\n\t\tbreak;\n\tcase UVERBS_ACCESS_NEW:\n\t\tif (commit)\n\t\t\trdma_alloc_commit_uobject(uobj, attrs);\n\t\telse\n\t\t\trdma_alloc_abort_uobject(uobj, attrs, hw_obj_valid);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(true);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}