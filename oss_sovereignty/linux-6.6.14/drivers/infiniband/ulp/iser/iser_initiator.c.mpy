{
  "module_name": "iser_initiator.c",
  "hash_id": "f76bcd47ac7a26ea4e76963d54abceb437719a038d979b88853d8a627f73191e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/ulp/iser/iser_initiator.c",
  "human_readable_source": " \n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/scatterlist.h>\n#include <linux/kfifo.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_host.h>\n\n#include \"iscsi_iser.h\"\n\n \nstatic int iser_prepare_read_cmd(struct iscsi_task *task)\n\n{\n\tstruct iscsi_iser_task *iser_task = task->dd_data;\n\tstruct iser_mem_reg *mem_reg;\n\tint err;\n\tstruct iser_ctrl *hdr = &iser_task->desc.iser_header;\n\n\terr = iser_dma_map_task_data(iser_task,\n\t\t\t\t     ISER_DIR_IN,\n\t\t\t\t     DMA_FROM_DEVICE);\n\tif (err)\n\t\treturn err;\n\n\terr = iser_reg_mem_fastreg(iser_task, ISER_DIR_IN, false);\n\tif (err) {\n\t\tiser_err(\"Failed to set up Data-IN RDMA\\n\");\n\t\tgoto out_err;\n\t}\n\tmem_reg = &iser_task->rdma_reg[ISER_DIR_IN];\n\n\thdr->flags    |= ISER_RSV;\n\thdr->read_stag = cpu_to_be32(mem_reg->rkey);\n\thdr->read_va   = cpu_to_be64(mem_reg->sge.addr);\n\n\tiser_dbg(\"Cmd itt:%d READ tags RKEY:%#.4X VA:%#llX\\n\",\n\t\t task->itt, mem_reg->rkey,\n\t\t (unsigned long long)mem_reg->sge.addr);\n\n\treturn 0;\n\nout_err:\n\tiser_dma_unmap_task_data(iser_task, ISER_DIR_IN, DMA_FROM_DEVICE);\n\treturn err;\n}\n\n \nstatic int iser_prepare_write_cmd(struct iscsi_task *task, unsigned int imm_sz,\n\t\t\t\t  unsigned int unsol_sz, unsigned int edtl)\n{\n\tstruct iscsi_iser_task *iser_task = task->dd_data;\n\tstruct iser_mem_reg *mem_reg;\n\tint err;\n\tstruct iser_ctrl *hdr = &iser_task->desc.iser_header;\n\tstruct iser_data_buf *buf_out = &iser_task->data[ISER_DIR_OUT];\n\tstruct ib_sge *tx_dsg = &iser_task->desc.tx_sg[1];\n\n\terr = iser_dma_map_task_data(iser_task,\n\t\t\t\t     ISER_DIR_OUT,\n\t\t\t\t     DMA_TO_DEVICE);\n\tif (err)\n\t\treturn err;\n\n\terr = iser_reg_mem_fastreg(iser_task, ISER_DIR_OUT,\n\t\t\t\t   buf_out->data_len == imm_sz);\n\tif (err) {\n\t\tiser_err(\"Failed to register write cmd RDMA mem\\n\");\n\t\tgoto out_err;\n\t}\n\n\tmem_reg = &iser_task->rdma_reg[ISER_DIR_OUT];\n\n\tif (unsol_sz < edtl) {\n\t\thdr->flags     |= ISER_WSV;\n\t\tif (buf_out->data_len > imm_sz) {\n\t\t\thdr->write_stag = cpu_to_be32(mem_reg->rkey);\n\t\t\thdr->write_va = cpu_to_be64(mem_reg->sge.addr + unsol_sz);\n\t\t}\n\n\t\tiser_dbg(\"Cmd itt:%d, WRITE tags, RKEY:%#.4X VA:%#llX + unsol:%d\\n\",\n\t\t\t task->itt, mem_reg->rkey,\n\t\t\t (unsigned long long)mem_reg->sge.addr, unsol_sz);\n\t}\n\n\tif (imm_sz > 0) {\n\t\tiser_dbg(\"Cmd itt:%d, WRITE, adding imm.data sz: %d\\n\",\n\t\t\t task->itt, imm_sz);\n\t\ttx_dsg->addr = mem_reg->sge.addr;\n\t\ttx_dsg->length = imm_sz;\n\t\ttx_dsg->lkey = mem_reg->sge.lkey;\n\t\tiser_task->desc.num_sge = 2;\n\t}\n\n\treturn 0;\n\nout_err:\n\tiser_dma_unmap_task_data(iser_task, ISER_DIR_OUT, DMA_TO_DEVICE);\n\treturn err;\n}\n\n \nstatic void iser_create_send_desc(struct iser_conn *iser_conn,\n\t\tstruct iser_tx_desc *tx_desc, enum iser_desc_type type,\n\t\tvoid (*done)(struct ib_cq *cq, struct ib_wc *wc))\n{\n\tstruct iser_device *device = iser_conn->ib_conn.device;\n\n\ttx_desc->type = type;\n\ttx_desc->cqe.done = done;\n\n\tib_dma_sync_single_for_cpu(device->ib_device,\n\t\ttx_desc->dma_addr, ISER_HEADERS_LEN, DMA_TO_DEVICE);\n\n\tmemset(&tx_desc->iser_header, 0, sizeof(struct iser_ctrl));\n\ttx_desc->iser_header.flags = ISER_VER;\n\ttx_desc->num_sge = 1;\n}\n\nstatic void iser_free_login_buf(struct iser_conn *iser_conn)\n{\n\tstruct iser_device *device = iser_conn->ib_conn.device;\n\tstruct iser_login_desc *desc = &iser_conn->login_desc;\n\n\tif (!desc->req)\n\t\treturn;\n\n\tib_dma_unmap_single(device->ib_device, desc->req_dma,\n\t\t\t    ISCSI_DEF_MAX_RECV_SEG_LEN, DMA_TO_DEVICE);\n\n\tib_dma_unmap_single(device->ib_device, desc->rsp_dma,\n\t\t\t    ISER_RX_LOGIN_SIZE, DMA_FROM_DEVICE);\n\n\tkfree(desc->req);\n\tkfree(desc->rsp);\n\n\t \n\tdesc->req = NULL;\n\tdesc->rsp = NULL;\n}\n\nstatic int iser_alloc_login_buf(struct iser_conn *iser_conn)\n{\n\tstruct iser_device *device = iser_conn->ib_conn.device;\n\tstruct iser_login_desc *desc = &iser_conn->login_desc;\n\n\tdesc->req = kmalloc(ISCSI_DEF_MAX_RECV_SEG_LEN, GFP_KERNEL);\n\tif (!desc->req)\n\t\treturn -ENOMEM;\n\n\tdesc->req_dma = ib_dma_map_single(device->ib_device, desc->req,\n\t\t\t\t\t  ISCSI_DEF_MAX_RECV_SEG_LEN,\n\t\t\t\t\t  DMA_TO_DEVICE);\n\tif (ib_dma_mapping_error(device->ib_device,\n\t\t\t\tdesc->req_dma))\n\t\tgoto free_req;\n\n\tdesc->rsp = kmalloc(ISER_RX_LOGIN_SIZE, GFP_KERNEL);\n\tif (!desc->rsp)\n\t\tgoto unmap_req;\n\n\tdesc->rsp_dma = ib_dma_map_single(device->ib_device, desc->rsp,\n\t\t\t\t\t   ISER_RX_LOGIN_SIZE,\n\t\t\t\t\t   DMA_FROM_DEVICE);\n\tif (ib_dma_mapping_error(device->ib_device,\n\t\t\t\tdesc->rsp_dma))\n\t\tgoto free_rsp;\n\n\treturn 0;\n\nfree_rsp:\n\tkfree(desc->rsp);\nunmap_req:\n\tib_dma_unmap_single(device->ib_device, desc->req_dma,\n\t\t\t    ISCSI_DEF_MAX_RECV_SEG_LEN,\n\t\t\t    DMA_TO_DEVICE);\nfree_req:\n\tkfree(desc->req);\n\n\treturn -ENOMEM;\n}\n\nint iser_alloc_rx_descriptors(struct iser_conn *iser_conn,\n\t\t\t      struct iscsi_session *session)\n{\n\tint i, j;\n\tu64 dma_addr;\n\tstruct iser_rx_desc *rx_desc;\n\tstruct ib_sge       *rx_sg;\n\tstruct ib_conn *ib_conn = &iser_conn->ib_conn;\n\tstruct iser_device *device = ib_conn->device;\n\n\tiser_conn->qp_max_recv_dtos = session->cmds_max;\n\n\tif (iser_alloc_fastreg_pool(ib_conn, session->scsi_cmds_max,\n\t\t\t\t    iser_conn->pages_per_mr))\n\t\tgoto create_rdma_reg_res_failed;\n\n\tif (iser_alloc_login_buf(iser_conn))\n\t\tgoto alloc_login_buf_fail;\n\n\tiser_conn->num_rx_descs = session->cmds_max;\n\tiser_conn->rx_descs = kmalloc_array(iser_conn->num_rx_descs,\n\t\t\t\t\t    sizeof(struct iser_rx_desc),\n\t\t\t\t\t    GFP_KERNEL);\n\tif (!iser_conn->rx_descs)\n\t\tgoto rx_desc_alloc_fail;\n\n\trx_desc = iser_conn->rx_descs;\n\n\tfor (i = 0; i < iser_conn->qp_max_recv_dtos; i++, rx_desc++)  {\n\t\tdma_addr = ib_dma_map_single(device->ib_device, (void *)rx_desc,\n\t\t\t\t\tISER_RX_PAYLOAD_SIZE, DMA_FROM_DEVICE);\n\t\tif (ib_dma_mapping_error(device->ib_device, dma_addr))\n\t\t\tgoto rx_desc_dma_map_failed;\n\n\t\trx_desc->dma_addr = dma_addr;\n\t\trx_desc->cqe.done = iser_task_rsp;\n\t\trx_sg = &rx_desc->rx_sg;\n\t\trx_sg->addr = rx_desc->dma_addr;\n\t\trx_sg->length = ISER_RX_PAYLOAD_SIZE;\n\t\trx_sg->lkey = device->pd->local_dma_lkey;\n\t}\n\n\treturn 0;\n\nrx_desc_dma_map_failed:\n\trx_desc = iser_conn->rx_descs;\n\tfor (j = 0; j < i; j++, rx_desc++)\n\t\tib_dma_unmap_single(device->ib_device, rx_desc->dma_addr,\n\t\t\t\t    ISER_RX_PAYLOAD_SIZE, DMA_FROM_DEVICE);\n\tkfree(iser_conn->rx_descs);\n\tiser_conn->rx_descs = NULL;\nrx_desc_alloc_fail:\n\tiser_free_login_buf(iser_conn);\nalloc_login_buf_fail:\n\tiser_free_fastreg_pool(ib_conn);\ncreate_rdma_reg_res_failed:\n\tiser_err(\"failed allocating rx descriptors / data buffers\\n\");\n\treturn -ENOMEM;\n}\n\nvoid iser_free_rx_descriptors(struct iser_conn *iser_conn)\n{\n\tint i;\n\tstruct iser_rx_desc *rx_desc;\n\tstruct ib_conn *ib_conn = &iser_conn->ib_conn;\n\tstruct iser_device *device = ib_conn->device;\n\n\tiser_free_fastreg_pool(ib_conn);\n\n\trx_desc = iser_conn->rx_descs;\n\tfor (i = 0; i < iser_conn->qp_max_recv_dtos; i++, rx_desc++)\n\t\tib_dma_unmap_single(device->ib_device, rx_desc->dma_addr,\n\t\t\t\t    ISER_RX_PAYLOAD_SIZE, DMA_FROM_DEVICE);\n\tkfree(iser_conn->rx_descs);\n\t \n\tiser_conn->rx_descs = NULL;\n\n\tiser_free_login_buf(iser_conn);\n}\n\nstatic int iser_post_rx_bufs(struct iscsi_conn *conn, struct iscsi_hdr *req)\n{\n\tstruct iser_conn *iser_conn = conn->dd_data;\n\tstruct iscsi_session *session = conn->session;\n\tint err = 0;\n\tint i;\n\n\tiser_dbg(\"req op %x flags %x\\n\", req->opcode, req->flags);\n\t \n\tif ((req->flags & ISCSI_FULL_FEATURE_PHASE) != ISCSI_FULL_FEATURE_PHASE)\n\t\tgoto out;\n\n\tif (session->discovery_sess) {\n\t\tiser_info(\"Discovery session, re-using login RX buffer\\n\");\n\t\tgoto out;\n\t}\n\n\tiser_info(\"Normal session, posting batch of RX %d buffers\\n\",\n\t\t  iser_conn->qp_max_recv_dtos - 1);\n\n\t \n\tfor (i = 1; i < iser_conn->qp_max_recv_dtos; i++) {\n\t\terr = iser_post_recvm(iser_conn, &iser_conn->rx_descs[i]);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\nout:\n\treturn err;\n}\n\n \nint iser_send_command(struct iscsi_conn *conn, struct iscsi_task *task)\n{\n\tstruct iser_conn *iser_conn = conn->dd_data;\n\tstruct iscsi_iser_task *iser_task = task->dd_data;\n\tunsigned long edtl;\n\tint err;\n\tstruct iser_data_buf *data_buf, *prot_buf;\n\tstruct iscsi_scsi_req *hdr = (struct iscsi_scsi_req *)task->hdr;\n\tstruct scsi_cmnd *sc  =  task->sc;\n\tstruct iser_tx_desc *tx_desc = &iser_task->desc;\n\n\tedtl = ntohl(hdr->data_length);\n\n\t \n\tiser_create_send_desc(iser_conn, tx_desc, ISCSI_TX_SCSI_COMMAND,\n\t\t\t      iser_cmd_comp);\n\n\tif (hdr->flags & ISCSI_FLAG_CMD_READ) {\n\t\tdata_buf = &iser_task->data[ISER_DIR_IN];\n\t\tprot_buf = &iser_task->prot[ISER_DIR_IN];\n\t} else {\n\t\tdata_buf = &iser_task->data[ISER_DIR_OUT];\n\t\tprot_buf = &iser_task->prot[ISER_DIR_OUT];\n\t}\n\n\tif (scsi_sg_count(sc)) {  \n\t\tdata_buf->sg = scsi_sglist(sc);\n\t\tdata_buf->size = scsi_sg_count(sc);\n\t}\n\tdata_buf->data_len = scsi_bufflen(sc);\n\n\tif (scsi_prot_sg_count(sc)) {\n\t\tprot_buf->sg  = scsi_prot_sglist(sc);\n\t\tprot_buf->size = scsi_prot_sg_count(sc);\n\t\tprot_buf->data_len = (data_buf->data_len >>\n\t\t\t\t     ilog2(sc->device->sector_size)) * 8;\n\t}\n\n\tif (hdr->flags & ISCSI_FLAG_CMD_READ) {\n\t\terr = iser_prepare_read_cmd(task);\n\t\tif (err)\n\t\t\tgoto send_command_error;\n\t}\n\tif (hdr->flags & ISCSI_FLAG_CMD_WRITE) {\n\t\terr = iser_prepare_write_cmd(task,\n\t\t\t\t\t     task->imm_count,\n\t\t\t\t             task->imm_count +\n\t\t\t\t\t     task->unsol_r2t.data_length,\n\t\t\t\t\t     edtl);\n\t\tif (err)\n\t\t\tgoto send_command_error;\n\t}\n\n\tiser_task->status = ISER_TASK_STATUS_STARTED;\n\n\terr = iser_post_send(&iser_conn->ib_conn, tx_desc);\n\tif (!err)\n\t\treturn 0;\n\nsend_command_error:\n\tiser_err(\"conn %p failed task->itt %d err %d\\n\",conn, task->itt, err);\n\treturn err;\n}\n\n \nint iser_send_data_out(struct iscsi_conn *conn, struct iscsi_task *task,\n\t\t       struct iscsi_data *hdr)\n{\n\tstruct iser_conn *iser_conn = conn->dd_data;\n\tstruct iscsi_iser_task *iser_task = task->dd_data;\n\tstruct iser_tx_desc *tx_desc;\n\tstruct iser_mem_reg *mem_reg;\n\tunsigned long buf_offset;\n\tunsigned long data_seg_len;\n\tuint32_t itt;\n\tint err;\n\tstruct ib_sge *tx_dsg;\n\n\titt = (__force uint32_t)hdr->itt;\n\tdata_seg_len = ntoh24(hdr->dlength);\n\tbuf_offset   = ntohl(hdr->offset);\n\n\tiser_dbg(\"%s itt %d dseg_len %d offset %d\\n\",\n\t\t __func__,(int)itt,(int)data_seg_len,(int)buf_offset);\n\n\ttx_desc = kmem_cache_zalloc(ig.desc_cache, GFP_ATOMIC);\n\tif (!tx_desc)\n\t\treturn -ENOMEM;\n\n\ttx_desc->type = ISCSI_TX_DATAOUT;\n\ttx_desc->cqe.done = iser_dataout_comp;\n\ttx_desc->iser_header.flags = ISER_VER;\n\tmemcpy(&tx_desc->iscsi_header, hdr, sizeof(struct iscsi_hdr));\n\n\t \n\terr = iser_initialize_task_headers(task, tx_desc);\n\tif (err)\n\t\tgoto send_data_out_error;\n\n\tmem_reg = &iser_task->rdma_reg[ISER_DIR_OUT];\n\ttx_dsg = &tx_desc->tx_sg[1];\n\ttx_dsg->addr = mem_reg->sge.addr + buf_offset;\n\ttx_dsg->length = data_seg_len;\n\ttx_dsg->lkey = mem_reg->sge.lkey;\n\ttx_desc->num_sge = 2;\n\n\tif (buf_offset + data_seg_len > iser_task->data[ISER_DIR_OUT].data_len) {\n\t\tiser_err(\"Offset:%ld & DSL:%ld in Data-Out inconsistent with total len:%ld, itt:%d\\n\",\n\t\t\t buf_offset, data_seg_len,\n\t\t\t iser_task->data[ISER_DIR_OUT].data_len, itt);\n\t\terr = -EINVAL;\n\t\tgoto send_data_out_error;\n\t}\n\tiser_dbg(\"data-out itt: %d, offset: %ld, sz: %ld\\n\",\n\t\t itt, buf_offset, data_seg_len);\n\n\terr = iser_post_send(&iser_conn->ib_conn, tx_desc);\n\tif (!err)\n\t\treturn 0;\n\nsend_data_out_error:\n\tkmem_cache_free(ig.desc_cache, tx_desc);\n\tiser_err(\"conn %p failed err %d\\n\", conn, err);\n\treturn err;\n}\n\nint iser_send_control(struct iscsi_conn *conn, struct iscsi_task *task)\n{\n\tstruct iser_conn *iser_conn = conn->dd_data;\n\tstruct iscsi_iser_task *iser_task = task->dd_data;\n\tstruct iser_tx_desc *mdesc = &iser_task->desc;\n\tunsigned long data_seg_len;\n\tint err = 0;\n\tstruct iser_device *device;\n\n\t \n\tiser_create_send_desc(iser_conn, mdesc, ISCSI_TX_CONTROL,\n\t\t\t      iser_ctrl_comp);\n\n\tdevice = iser_conn->ib_conn.device;\n\n\tdata_seg_len = ntoh24(task->hdr->dlength);\n\n\tif (data_seg_len > 0) {\n\t\tstruct iser_login_desc *desc = &iser_conn->login_desc;\n\t\tstruct ib_sge *tx_dsg = &mdesc->tx_sg[1];\n\n\t\tif (task != conn->login_task) {\n\t\t\tiser_err(\"data present on non login task!!!\\n\");\n\t\t\tgoto send_control_error;\n\t\t}\n\n\t\tib_dma_sync_single_for_cpu(device->ib_device, desc->req_dma,\n\t\t\t\t\t   task->data_count, DMA_TO_DEVICE);\n\n\t\tmemcpy(desc->req, task->data, task->data_count);\n\n\t\tib_dma_sync_single_for_device(device->ib_device, desc->req_dma,\n\t\t\t\t\t      task->data_count, DMA_TO_DEVICE);\n\n\t\ttx_dsg->addr = desc->req_dma;\n\t\ttx_dsg->length = task->data_count;\n\t\ttx_dsg->lkey = device->pd->local_dma_lkey;\n\t\tmdesc->num_sge = 2;\n\t}\n\n\tif (task == conn->login_task) {\n\t\tiser_dbg(\"op %x dsl %lx, posting login rx buffer\\n\",\n\t\t\t task->hdr->opcode, data_seg_len);\n\t\terr = iser_post_recvl(iser_conn);\n\t\tif (err)\n\t\t\tgoto send_control_error;\n\t\terr = iser_post_rx_bufs(conn, task->hdr);\n\t\tif (err)\n\t\t\tgoto send_control_error;\n\t}\n\n\terr = iser_post_send(&iser_conn->ib_conn, mdesc);\n\tif (!err)\n\t\treturn 0;\n\nsend_control_error:\n\tiser_err(\"conn %p failed err %d\\n\",conn, err);\n\treturn err;\n}\n\nvoid iser_login_rsp(struct ib_cq *cq, struct ib_wc *wc)\n{\n\tstruct ib_conn *ib_conn = wc->qp->qp_context;\n\tstruct iser_conn *iser_conn = to_iser_conn(ib_conn);\n\tstruct iser_login_desc *desc = iser_login(wc->wr_cqe);\n\tstruct iscsi_hdr *hdr;\n\tchar *data;\n\tint length;\n\tbool full_feature_phase;\n\n\tif (unlikely(wc->status != IB_WC_SUCCESS)) {\n\t\tiser_err_comp(wc, \"login_rsp\");\n\t\treturn;\n\t}\n\n\tib_dma_sync_single_for_cpu(ib_conn->device->ib_device,\n\t\t\t\t   desc->rsp_dma, ISER_RX_LOGIN_SIZE,\n\t\t\t\t   DMA_FROM_DEVICE);\n\n\thdr = desc->rsp + sizeof(struct iser_ctrl);\n\tdata = desc->rsp + ISER_HEADERS_LEN;\n\tlength = wc->byte_len - ISER_HEADERS_LEN;\n\tfull_feature_phase = ((hdr->flags & ISCSI_FULL_FEATURE_PHASE) ==\n\t\t\t      ISCSI_FULL_FEATURE_PHASE) &&\n\t\t\t     (hdr->flags & ISCSI_FLAG_CMD_FINAL);\n\n\tiser_dbg(\"op 0x%x itt 0x%x dlen %d\\n\", hdr->opcode,\n\t\t hdr->itt, length);\n\n\tiscsi_iser_recv(iser_conn->iscsi_conn, hdr, data, length);\n\n\tib_dma_sync_single_for_device(ib_conn->device->ib_device,\n\t\t\t\t      desc->rsp_dma, ISER_RX_LOGIN_SIZE,\n\t\t\t\t      DMA_FROM_DEVICE);\n\n\tif (!full_feature_phase ||\n\t    iser_conn->iscsi_conn->session->discovery_sess)\n\t\treturn;\n\n\t \n\tiser_post_recvm(iser_conn, iser_conn->rx_descs);\n}\n\nstatic inline int iser_inv_desc(struct iser_fr_desc *desc, u32 rkey)\n{\n\tif (unlikely((!desc->sig_protected && rkey != desc->rsc.mr->rkey) ||\n\t\t     (desc->sig_protected && rkey != desc->rsc.sig_mr->rkey))) {\n\t\tiser_err(\"Bogus remote invalidation for rkey %#x\\n\", rkey);\n\t\treturn -EINVAL;\n\t}\n\n\tif (desc->sig_protected)\n\t\tdesc->rsc.sig_mr->need_inval = false;\n\telse\n\t\tdesc->rsc.mr->need_inval = false;\n\n\treturn 0;\n}\n\nstatic int iser_check_remote_inv(struct iser_conn *iser_conn, struct ib_wc *wc,\n\t\t\t\t struct iscsi_hdr *hdr)\n{\n\tif (wc->wc_flags & IB_WC_WITH_INVALIDATE) {\n\t\tstruct iscsi_task *task;\n\t\tu32 rkey = wc->ex.invalidate_rkey;\n\n\t\tiser_dbg(\"conn %p: remote invalidation for rkey %#x\\n\",\n\t\t\t iser_conn, rkey);\n\n\t\tif (unlikely(!iser_conn->snd_w_inv)) {\n\t\t\tiser_err(\"conn %p: unexpected remote invalidation, terminating connection\\n\",\n\t\t\t\t iser_conn);\n\t\t\treturn -EPROTO;\n\t\t}\n\n\t\ttask = iscsi_itt_to_ctask(iser_conn->iscsi_conn, hdr->itt);\n\t\tif (likely(task)) {\n\t\t\tstruct iscsi_iser_task *iser_task = task->dd_data;\n\t\t\tstruct iser_fr_desc *desc;\n\n\t\t\tif (iser_task->dir[ISER_DIR_IN]) {\n\t\t\t\tdesc = iser_task->rdma_reg[ISER_DIR_IN].desc;\n\t\t\t\tif (unlikely(iser_inv_desc(desc, rkey)))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (iser_task->dir[ISER_DIR_OUT]) {\n\t\t\t\tdesc = iser_task->rdma_reg[ISER_DIR_OUT].desc;\n\t\t\t\tif (unlikely(iser_inv_desc(desc, rkey)))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tiser_err(\"failed to get task for itt=%d\\n\", hdr->itt);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\nvoid iser_task_rsp(struct ib_cq *cq, struct ib_wc *wc)\n{\n\tstruct ib_conn *ib_conn = wc->qp->qp_context;\n\tstruct iser_conn *iser_conn = to_iser_conn(ib_conn);\n\tstruct iser_rx_desc *desc = iser_rx(wc->wr_cqe);\n\tstruct iscsi_hdr *hdr;\n\tint length, err;\n\n\tif (unlikely(wc->status != IB_WC_SUCCESS)) {\n\t\tiser_err_comp(wc, \"task_rsp\");\n\t\treturn;\n\t}\n\n\tib_dma_sync_single_for_cpu(ib_conn->device->ib_device,\n\t\t\t\t   desc->dma_addr, ISER_RX_PAYLOAD_SIZE,\n\t\t\t\t   DMA_FROM_DEVICE);\n\n\thdr = &desc->iscsi_header;\n\tlength = wc->byte_len - ISER_HEADERS_LEN;\n\n\tiser_dbg(\"op 0x%x itt 0x%x dlen %d\\n\", hdr->opcode,\n\t\t hdr->itt, length);\n\n\tif (iser_check_remote_inv(iser_conn, wc, hdr)) {\n\t\tiscsi_conn_failure(iser_conn->iscsi_conn,\n\t\t\t\t   ISCSI_ERR_CONN_FAILED);\n\t\treturn;\n\t}\n\n\tiscsi_iser_recv(iser_conn->iscsi_conn, hdr, desc->data, length);\n\n\tib_dma_sync_single_for_device(ib_conn->device->ib_device,\n\t\t\t\t      desc->dma_addr, ISER_RX_PAYLOAD_SIZE,\n\t\t\t\t      DMA_FROM_DEVICE);\n\n\terr = iser_post_recvm(iser_conn, desc);\n\tif (err)\n\t\tiser_err(\"posting rx buffer err %d\\n\", err);\n}\n\nvoid iser_cmd_comp(struct ib_cq *cq, struct ib_wc *wc)\n{\n\tif (unlikely(wc->status != IB_WC_SUCCESS))\n\t\tiser_err_comp(wc, \"command\");\n}\n\nvoid iser_ctrl_comp(struct ib_cq *cq, struct ib_wc *wc)\n{\n\tstruct iser_tx_desc *desc = iser_tx(wc->wr_cqe);\n\tstruct iscsi_task *task;\n\n\tif (unlikely(wc->status != IB_WC_SUCCESS)) {\n\t\tiser_err_comp(wc, \"control\");\n\t\treturn;\n\t}\n\n\t \n\ttask = (void *)desc - sizeof(struct iscsi_task);\n\tif (task->hdr->itt == RESERVED_ITT)\n\t\tiscsi_put_task(task);\n}\n\nvoid iser_dataout_comp(struct ib_cq *cq, struct ib_wc *wc)\n{\n\tstruct iser_tx_desc *desc = iser_tx(wc->wr_cqe);\n\tstruct ib_conn *ib_conn = wc->qp->qp_context;\n\tstruct iser_device *device = ib_conn->device;\n\n\tif (unlikely(wc->status != IB_WC_SUCCESS))\n\t\tiser_err_comp(wc, \"dataout\");\n\n\tib_dma_unmap_single(device->ib_device, desc->dma_addr,\n\t\t\t    ISER_HEADERS_LEN, DMA_TO_DEVICE);\n\tkmem_cache_free(ig.desc_cache, desc);\n}\n\nvoid iser_task_rdma_init(struct iscsi_iser_task *iser_task)\n\n{\n\tiser_task->status = ISER_TASK_STATUS_INIT;\n\n\tiser_task->dir[ISER_DIR_IN] = 0;\n\tiser_task->dir[ISER_DIR_OUT] = 0;\n\n\tiser_task->data[ISER_DIR_IN].data_len  = 0;\n\tiser_task->data[ISER_DIR_OUT].data_len = 0;\n\n\tiser_task->prot[ISER_DIR_IN].data_len  = 0;\n\tiser_task->prot[ISER_DIR_OUT].data_len = 0;\n\n\tiser_task->prot[ISER_DIR_IN].dma_nents = 0;\n\tiser_task->prot[ISER_DIR_OUT].dma_nents = 0;\n\n\tmemset(&iser_task->rdma_reg[ISER_DIR_IN], 0,\n\t       sizeof(struct iser_mem_reg));\n\tmemset(&iser_task->rdma_reg[ISER_DIR_OUT], 0,\n\t       sizeof(struct iser_mem_reg));\n}\n\nvoid iser_task_rdma_finalize(struct iscsi_iser_task *iser_task)\n{\n\n\tif (iser_task->dir[ISER_DIR_IN]) {\n\t\tiser_unreg_mem_fastreg(iser_task, ISER_DIR_IN);\n\t\tiser_dma_unmap_task_data(iser_task, ISER_DIR_IN,\n\t\t\t\t\t DMA_FROM_DEVICE);\n\t}\n\n\tif (iser_task->dir[ISER_DIR_OUT]) {\n\t\tiser_unreg_mem_fastreg(iser_task, ISER_DIR_OUT);\n\t\tiser_dma_unmap_task_data(iser_task, ISER_DIR_OUT,\n\t\t\t\t\t DMA_TO_DEVICE);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}