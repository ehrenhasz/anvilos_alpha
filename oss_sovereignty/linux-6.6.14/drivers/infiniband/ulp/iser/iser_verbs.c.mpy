{
  "module_name": "iser_verbs.c",
  "hash_id": "68a520be8b18c3cc935bdfc461e9beb1eba7c77960f5b81d39fae9eacc2016a6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/ulp/iser/iser_verbs.c",
  "human_readable_source": " \n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n\n#include \"iscsi_iser.h\"\n\nstatic void iser_qp_event_callback(struct ib_event *cause, void *context)\n{\n\tiser_err(\"qp event %s (%d)\\n\",\n\t\t ib_event_msg(cause->event), cause->event);\n}\n\nstatic void iser_event_handler(struct ib_event_handler *handler,\n\t\t\t\tstruct ib_event *event)\n{\n\tiser_err(\"async event %s (%d) on device %s port %d\\n\",\n\t\t ib_event_msg(event->event), event->event,\n\t\tdev_name(&event->device->dev), event->element.port_num);\n}\n\n \nstatic int iser_create_device_ib_res(struct iser_device *device)\n{\n\tstruct ib_device *ib_dev = device->ib_device;\n\n\tif (!(ib_dev->attrs.device_cap_flags & IB_DEVICE_MEM_MGT_EXTENSIONS)) {\n\t\tiser_err(\"IB device does not support memory registrations\\n\");\n\t\treturn -1;\n\t}\n\n\tdevice->pd = ib_alloc_pd(ib_dev,\n\t\tiser_always_reg ? 0 : IB_PD_UNSAFE_GLOBAL_RKEY);\n\tif (IS_ERR(device->pd))\n\t\tgoto pd_err;\n\n\tINIT_IB_EVENT_HANDLER(&device->event_handler, ib_dev,\n\t\t\t      iser_event_handler);\n\tib_register_event_handler(&device->event_handler);\n\treturn 0;\n\npd_err:\n\tiser_err(\"failed to allocate an IB resource\\n\");\n\treturn -1;\n}\n\n \nstatic void iser_free_device_ib_res(struct iser_device *device)\n{\n\tib_unregister_event_handler(&device->event_handler);\n\tib_dealloc_pd(device->pd);\n\n\tdevice->pd = NULL;\n}\n\nstatic struct iser_fr_desc *\niser_create_fastreg_desc(struct iser_device *device,\n\t\t\t struct ib_pd *pd,\n\t\t\t bool pi_enable,\n\t\t\t unsigned int size)\n{\n\tstruct iser_fr_desc *desc;\n\tstruct ib_device *ib_dev = device->ib_device;\n\tenum ib_mr_type mr_type;\n\tint ret;\n\n\tdesc = kzalloc(sizeof(*desc), GFP_KERNEL);\n\tif (!desc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (ib_dev->attrs.kernel_cap_flags & IBK_SG_GAPS_REG)\n\t\tmr_type = IB_MR_TYPE_SG_GAPS;\n\telse\n\t\tmr_type = IB_MR_TYPE_MEM_REG;\n\n\tdesc->rsc.mr = ib_alloc_mr(pd, mr_type, size);\n\tif (IS_ERR(desc->rsc.mr)) {\n\t\tret = PTR_ERR(desc->rsc.mr);\n\t\tiser_err(\"Failed to allocate ib_fast_reg_mr err=%d\\n\", ret);\n\t\tgoto err_alloc_mr;\n\t}\n\n\tif (pi_enable) {\n\t\tdesc->rsc.sig_mr = ib_alloc_mr_integrity(pd, size, size);\n\t\tif (IS_ERR(desc->rsc.sig_mr)) {\n\t\t\tret = PTR_ERR(desc->rsc.sig_mr);\n\t\t\tiser_err(\"Failed to allocate sig_mr err=%d\\n\", ret);\n\t\t\tgoto err_alloc_mr_integrity;\n\t\t}\n\t}\n\n\treturn desc;\n\nerr_alloc_mr_integrity:\n\tib_dereg_mr(desc->rsc.mr);\nerr_alloc_mr:\n\tkfree(desc);\n\n\treturn ERR_PTR(ret);\n}\n\nstatic void iser_destroy_fastreg_desc(struct iser_fr_desc *desc)\n{\n\tstruct iser_reg_resources *res = &desc->rsc;\n\n\tib_dereg_mr(res->mr);\n\tif (res->sig_mr) {\n\t\tib_dereg_mr(res->sig_mr);\n\t\tres->sig_mr = NULL;\n\t}\n\tkfree(desc);\n}\n\n \nint iser_alloc_fastreg_pool(struct ib_conn *ib_conn,\n\t\t\t    unsigned cmds_max,\n\t\t\t    unsigned int size)\n{\n\tstruct iser_device *device = ib_conn->device;\n\tstruct iser_fr_pool *fr_pool = &ib_conn->fr_pool;\n\tstruct iser_fr_desc *desc;\n\tint i, ret;\n\n\tINIT_LIST_HEAD(&fr_pool->list);\n\tINIT_LIST_HEAD(&fr_pool->all_list);\n\tspin_lock_init(&fr_pool->lock);\n\tfr_pool->size = 0;\n\tfor (i = 0; i < cmds_max; i++) {\n\t\tdesc = iser_create_fastreg_desc(device, device->pd,\n\t\t\t\t\t\tib_conn->pi_support, size);\n\t\tif (IS_ERR(desc)) {\n\t\t\tret = PTR_ERR(desc);\n\t\t\tgoto err;\n\t\t}\n\n\t\tlist_add_tail(&desc->list, &fr_pool->list);\n\t\tlist_add_tail(&desc->all_list, &fr_pool->all_list);\n\t\tfr_pool->size++;\n\t}\n\n\treturn 0;\n\nerr:\n\tiser_free_fastreg_pool(ib_conn);\n\treturn ret;\n}\n\n \nvoid iser_free_fastreg_pool(struct ib_conn *ib_conn)\n{\n\tstruct iser_fr_pool *fr_pool = &ib_conn->fr_pool;\n\tstruct iser_fr_desc *desc, *tmp;\n\tint i = 0;\n\n\tif (list_empty(&fr_pool->all_list))\n\t\treturn;\n\n\tiser_info(\"freeing conn %p fr pool\\n\", ib_conn);\n\n\tlist_for_each_entry_safe(desc, tmp, &fr_pool->all_list, all_list) {\n\t\tlist_del(&desc->all_list);\n\t\tiser_destroy_fastreg_desc(desc);\n\t\t++i;\n\t}\n\n\tif (i < fr_pool->size)\n\t\tiser_warn(\"pool still has %d regions registered\\n\",\n\t\t\t  fr_pool->size - i);\n}\n\n \nstatic int iser_create_ib_conn_res(struct ib_conn *ib_conn)\n{\n\tstruct iser_conn *iser_conn = to_iser_conn(ib_conn);\n\tstruct iser_device\t*device;\n\tstruct ib_device\t*ib_dev;\n\tstruct ib_qp_init_attr\tinit_attr;\n\tint\t\t\tret = -ENOMEM;\n\tunsigned int max_send_wr, cq_size;\n\n\tBUG_ON(ib_conn->device == NULL);\n\n\tdevice = ib_conn->device;\n\tib_dev = device->ib_device;\n\n\t \n\tif (ib_conn->pi_support)\n\t\tmax_send_wr = ISER_QP_SIG_MAX_REQ_DTOS + 1;\n\telse\n\t\tmax_send_wr = ISER_QP_MAX_REQ_DTOS + 1;\n\tmax_send_wr = min_t(unsigned int, max_send_wr,\n\t\t\t    (unsigned int)ib_dev->attrs.max_qp_wr);\n\n\tcq_size = max_send_wr + ISER_QP_MAX_RECV_DTOS;\n\tib_conn->cq = ib_cq_pool_get(ib_dev, cq_size, -1, IB_POLL_SOFTIRQ);\n\tif (IS_ERR(ib_conn->cq)) {\n\t\tret = PTR_ERR(ib_conn->cq);\n\t\tgoto cq_err;\n\t}\n\tib_conn->cq_size = cq_size;\n\n\tmemset(&init_attr, 0, sizeof(init_attr));\n\n\tinit_attr.event_handler = iser_qp_event_callback;\n\tinit_attr.qp_context = (void *)ib_conn;\n\tinit_attr.send_cq = ib_conn->cq;\n\tinit_attr.recv_cq = ib_conn->cq;\n\t \n\tinit_attr.cap.max_recv_wr = ISER_QP_MAX_RECV_DTOS + 1;\n\tinit_attr.cap.max_send_sge = 2;\n\tinit_attr.cap.max_recv_sge = 1;\n\tinit_attr.sq_sig_type = IB_SIGNAL_REQ_WR;\n\tinit_attr.qp_type = IB_QPT_RC;\n\tinit_attr.cap.max_send_wr = max_send_wr;\n\tif (ib_conn->pi_support)\n\t\tinit_attr.create_flags |= IB_QP_CREATE_INTEGRITY_EN;\n\tiser_conn->max_cmds = ISER_GET_MAX_XMIT_CMDS(max_send_wr - 1);\n\n\tret = rdma_create_qp(ib_conn->cma_id, device->pd, &init_attr);\n\tif (ret)\n\t\tgoto out_err;\n\n\tib_conn->qp = ib_conn->cma_id->qp;\n\tiser_info(\"setting conn %p cma_id %p qp %p max_send_wr %d\\n\", ib_conn,\n\t\t  ib_conn->cma_id, ib_conn->cma_id->qp, max_send_wr);\n\treturn ret;\n\nout_err:\n\tib_cq_pool_put(ib_conn->cq, ib_conn->cq_size);\ncq_err:\n\tiser_err(\"unable to alloc mem or create resource, err %d\\n\", ret);\n\n\treturn ret;\n}\n\n \nstatic\nstruct iser_device *iser_device_find_by_ib_device(struct rdma_cm_id *cma_id)\n{\n\tstruct iser_device *device;\n\n\tmutex_lock(&ig.device_list_mutex);\n\n\tlist_for_each_entry(device, &ig.device_list, ig_list)\n\t\t \n\t\tif (device->ib_device->node_guid == cma_id->device->node_guid)\n\t\t\tgoto inc_refcnt;\n\n\tdevice = kzalloc(sizeof *device, GFP_KERNEL);\n\tif (!device)\n\t\tgoto out;\n\n\t \n\tdevice->ib_device = cma_id->device;\n\t \n\tif (iser_create_device_ib_res(device)) {\n\t\tkfree(device);\n\t\tdevice = NULL;\n\t\tgoto out;\n\t}\n\tlist_add(&device->ig_list, &ig.device_list);\n\ninc_refcnt:\n\tdevice->refcount++;\nout:\n\tmutex_unlock(&ig.device_list_mutex);\n\treturn device;\n}\n\n \nstatic void iser_device_try_release(struct iser_device *device)\n{\n\tmutex_lock(&ig.device_list_mutex);\n\tdevice->refcount--;\n\tiser_info(\"device %p refcount %d\\n\", device, device->refcount);\n\tif (!device->refcount) {\n\t\tiser_free_device_ib_res(device);\n\t\tlist_del(&device->ig_list);\n\t\tkfree(device);\n\t}\n\tmutex_unlock(&ig.device_list_mutex);\n}\n\nvoid iser_release_work(struct work_struct *work)\n{\n\tstruct iser_conn *iser_conn;\n\n\tiser_conn = container_of(work, struct iser_conn, release_work);\n\n\t \n\twait_for_completion(&iser_conn->stop_completion);\n\t \n\twait_for_completion(&iser_conn->ib_completion);\n\n\tmutex_lock(&iser_conn->state_mutex);\n\tiser_conn->state = ISER_CONN_DOWN;\n\tmutex_unlock(&iser_conn->state_mutex);\n\n\tiser_conn_release(iser_conn);\n}\n\n \nstatic void iser_free_ib_conn_res(struct iser_conn *iser_conn, bool destroy)\n{\n\tstruct ib_conn *ib_conn = &iser_conn->ib_conn;\n\tstruct iser_device *device = ib_conn->device;\n\n\tiser_info(\"freeing conn %p cma_id %p qp %p\\n\",\n\t\t  iser_conn, ib_conn->cma_id, ib_conn->qp);\n\n\tif (ib_conn->qp) {\n\t\trdma_destroy_qp(ib_conn->cma_id);\n\t\tib_cq_pool_put(ib_conn->cq, ib_conn->cq_size);\n\t\tib_conn->qp = NULL;\n\t}\n\n\tif (destroy) {\n\t\tif (iser_conn->rx_descs)\n\t\t\tiser_free_rx_descriptors(iser_conn);\n\n\t\tif (device) {\n\t\t\tiser_device_try_release(device);\n\t\t\tib_conn->device = NULL;\n\t\t}\n\t}\n}\n\n \nvoid iser_conn_release(struct iser_conn *iser_conn)\n{\n\tstruct ib_conn *ib_conn = &iser_conn->ib_conn;\n\n\tmutex_lock(&ig.connlist_mutex);\n\tlist_del(&iser_conn->conn_list);\n\tmutex_unlock(&ig.connlist_mutex);\n\n\tmutex_lock(&iser_conn->state_mutex);\n\t \n\tif (iser_conn->state != ISER_CONN_DOWN) {\n\t\tiser_warn(\"iser conn %p state %d, expected state down.\\n\",\n\t\t\t  iser_conn, iser_conn->state);\n\t\tiscsi_destroy_endpoint(iser_conn->ep);\n\t\tiser_conn->state = ISER_CONN_DOWN;\n\t}\n\t \n\tiser_free_ib_conn_res(iser_conn, true);\n\tmutex_unlock(&iser_conn->state_mutex);\n\n\tif (ib_conn->cma_id) {\n\t\trdma_destroy_id(ib_conn->cma_id);\n\t\tib_conn->cma_id = NULL;\n\t}\n\n\tkfree(iser_conn);\n}\n\n \nint iser_conn_terminate(struct iser_conn *iser_conn)\n{\n\tstruct ib_conn *ib_conn = &iser_conn->ib_conn;\n\tint err = 0;\n\n\tlockdep_assert_held(&iser_conn->state_mutex);\n\n\t \n\tif (iser_conn->state != ISER_CONN_UP)\n\t\treturn 0;\n\n\tiser_conn->state = ISER_CONN_TERMINATING;\n\tiser_info(\"iser_conn %p state %d\\n\", iser_conn, iser_conn->state);\n\n\t \n\tif (iser_conn->iscsi_conn)\n\t\tiscsi_suspend_queue(iser_conn->iscsi_conn);\n\n\t \n\tif (ib_conn->cma_id) {\n\t\terr = rdma_disconnect(ib_conn->cma_id);\n\t\tif (err)\n\t\t\tiser_err(\"Failed to disconnect, conn: 0x%p err %d\\n\",\n\t\t\t\t iser_conn, err);\n\n\t\t \n\t\tib_drain_qp(ib_conn->qp);\n\t}\n\n\treturn 1;\n}\n\n \nstatic void iser_connect_error(struct rdma_cm_id *cma_id)\n{\n\tstruct iser_conn *iser_conn = cma_id->context;\n\n\tlockdep_assert_held(&iser_conn->state_mutex);\n\n\tiser_conn->state = ISER_CONN_TERMINATING;\n}\n\nstatic void iser_calc_scsi_params(struct iser_conn *iser_conn,\n\t\t\t\t  unsigned int max_sectors)\n{\n\tstruct iser_device *device = iser_conn->ib_conn.device;\n\tstruct ib_device_attr *attr = &device->ib_device->attrs;\n\tunsigned short sg_tablesize, sup_sg_tablesize;\n\tunsigned short reserved_mr_pages;\n\tu32 max_num_sg;\n\n\t \n\tif (attr->kernel_cap_flags & IBK_SG_GAPS_REG)\n\t\treserved_mr_pages = 0;\n\telse\n\t\treserved_mr_pages = 1;\n\n\tif (iser_conn->ib_conn.pi_support)\n\t\tmax_num_sg = attr->max_pi_fast_reg_page_list_len;\n\telse\n\t\tmax_num_sg = attr->max_fast_reg_page_list_len;\n\n\tsg_tablesize = DIV_ROUND_UP(max_sectors * SECTOR_SIZE, SZ_4K);\n\tsup_sg_tablesize = min_t(uint, ISCSI_ISER_MAX_SG_TABLESIZE,\n\t\t\t\t max_num_sg - reserved_mr_pages);\n\tiser_conn->scsi_sg_tablesize = min(sg_tablesize, sup_sg_tablesize);\n\tiser_conn->pages_per_mr =\n\t\tiser_conn->scsi_sg_tablesize + reserved_mr_pages;\n}\n\n \nstatic void iser_addr_handler(struct rdma_cm_id *cma_id)\n{\n\tstruct iser_conn *iser_conn = cma_id->context;\n\tstruct iser_device *device;\n\tstruct ib_conn *ib_conn;\n\tint    ret;\n\n\tlockdep_assert_held(&iser_conn->state_mutex);\n\n\tif (iser_conn->state != ISER_CONN_PENDING)\n\t\t \n\t\treturn;\n\n\tib_conn = &iser_conn->ib_conn;\n\tdevice = iser_device_find_by_ib_device(cma_id);\n\tif (!device) {\n\t\tiser_err(\"device lookup/creation failed\\n\");\n\t\tiser_connect_error(cma_id);\n\t\treturn;\n\t}\n\n\tib_conn->device = device;\n\n\t \n\tif (iser_pi_enable) {\n\t\tif (!(device->ib_device->attrs.kernel_cap_flags &\n\t\t      IBK_INTEGRITY_HANDOVER)) {\n\t\t\tiser_warn(\"T10-PI requested but not supported on %s, \"\n\t\t\t\t  \"continue without T10-PI\\n\",\n\t\t\t\t  dev_name(&ib_conn->device->ib_device->dev));\n\t\t\tib_conn->pi_support = false;\n\t\t} else {\n\t\t\tib_conn->pi_support = true;\n\t\t}\n\t}\n\n\tiser_calc_scsi_params(iser_conn, iser_max_sectors);\n\n\tret = rdma_resolve_route(cma_id, 1000);\n\tif (ret) {\n\t\tiser_err(\"resolve route failed: %d\\n\", ret);\n\t\tiser_connect_error(cma_id);\n\t\treturn;\n\t}\n}\n\n \nstatic void iser_route_handler(struct rdma_cm_id *cma_id)\n{\n\tstruct rdma_conn_param conn_param;\n\tint ret;\n\tstruct iser_cm_hdr req_hdr;\n\tstruct iser_conn *iser_conn = cma_id->context;\n\tstruct ib_conn *ib_conn = &iser_conn->ib_conn;\n\tstruct ib_device *ib_dev = ib_conn->device->ib_device;\n\n\tlockdep_assert_held(&iser_conn->state_mutex);\n\n\tif (iser_conn->state != ISER_CONN_PENDING)\n\t\t \n\t\treturn;\n\n\tret = iser_create_ib_conn_res(ib_conn);\n\tif (ret)\n\t\tgoto failure;\n\n\tmemset(&conn_param, 0, sizeof conn_param);\n\tconn_param.responder_resources = ib_dev->attrs.max_qp_rd_atom;\n\tconn_param.initiator_depth = 1;\n\tconn_param.retry_count = 7;\n\tconn_param.rnr_retry_count = 6;\n\n\tmemset(&req_hdr, 0, sizeof(req_hdr));\n\treq_hdr.flags = ISER_ZBVA_NOT_SUP;\n\tif (!iser_always_reg)\n\t\treq_hdr.flags |= ISER_SEND_W_INV_NOT_SUP;\n\tconn_param.private_data\t= (void *)&req_hdr;\n\tconn_param.private_data_len = sizeof(struct iser_cm_hdr);\n\n\tret = rdma_connect_locked(cma_id, &conn_param);\n\tif (ret) {\n\t\tiser_err(\"failure connecting: %d\\n\", ret);\n\t\tgoto failure;\n\t}\n\n\treturn;\nfailure:\n\tiser_connect_error(cma_id);\n}\n\n \nstatic void iser_connected_handler(struct rdma_cm_id *cma_id,\n\t\t\t\t   const void *private_data)\n{\n\tstruct iser_conn *iser_conn = cma_id->context;\n\tstruct ib_qp_attr attr;\n\tstruct ib_qp_init_attr init_attr;\n\n\tlockdep_assert_held(&iser_conn->state_mutex);\n\n\tif (iser_conn->state != ISER_CONN_PENDING)\n\t\t \n\t\treturn;\n\n\t(void)ib_query_qp(cma_id->qp, &attr, ~0, &init_attr);\n\tiser_info(\"remote qpn:%x my qpn:%x\\n\", attr.dest_qp_num, cma_id->qp->qp_num);\n\n\tif (private_data) {\n\t\tu8 flags = *(u8 *)private_data;\n\n\t\tiser_conn->snd_w_inv = !(flags & ISER_SEND_W_INV_NOT_SUP);\n\t}\n\n\tiser_info(\"conn %p: negotiated %s invalidation\\n\",\n\t\t  iser_conn, iser_conn->snd_w_inv ? \"remote\" : \"local\");\n\n\tiser_conn->state = ISER_CONN_UP;\n\tcomplete(&iser_conn->up_completion);\n}\n\n \nstatic void iser_cleanup_handler(struct rdma_cm_id *cma_id,\n\t\t\t\t bool destroy)\n{\n\tstruct iser_conn *iser_conn = cma_id->context;\n\n\tlockdep_assert_held(&iser_conn->state_mutex);\n\t \n\tif (iser_conn_terminate(iser_conn)) {\n\t\tif (iser_conn->iscsi_conn)\n\t\t\tiscsi_conn_failure(iser_conn->iscsi_conn,\n\t\t\t\t\t   ISCSI_ERR_CONN_FAILED);\n\t\telse\n\t\t\tiser_err(\"iscsi_iser connection isn't bound\\n\");\n\t}\n\tiser_free_ib_conn_res(iser_conn, destroy);\n\tcomplete(&iser_conn->ib_completion);\n}\n\nstatic int iser_cma_handler(struct rdma_cm_id *cma_id,\n\t\t\t    struct rdma_cm_event *event)\n{\n\tstruct iser_conn *iser_conn;\n\tint ret = 0;\n\n\tiser_conn = cma_id->context;\n\tiser_info(\"%s (%d): status %d conn %p id %p\\n\",\n\t\t  rdma_event_msg(event->event), event->event,\n\t\t  event->status, cma_id->context, cma_id);\n\n\tmutex_lock(&iser_conn->state_mutex);\n\tswitch (event->event) {\n\tcase RDMA_CM_EVENT_ADDR_RESOLVED:\n\t\tiser_addr_handler(cma_id);\n\t\tbreak;\n\tcase RDMA_CM_EVENT_ROUTE_RESOLVED:\n\t\tiser_route_handler(cma_id);\n\t\tbreak;\n\tcase RDMA_CM_EVENT_ESTABLISHED:\n\t\tiser_connected_handler(cma_id, event->param.conn.private_data);\n\t\tbreak;\n\tcase RDMA_CM_EVENT_REJECTED:\n\t\tiser_info(\"Connection rejected: %s\\n\",\n\t\t\t rdma_reject_msg(cma_id, event->status));\n\t\tfallthrough;\n\tcase RDMA_CM_EVENT_ADDR_ERROR:\n\tcase RDMA_CM_EVENT_ROUTE_ERROR:\n\tcase RDMA_CM_EVENT_CONNECT_ERROR:\n\tcase RDMA_CM_EVENT_UNREACHABLE:\n\t\tiser_connect_error(cma_id);\n\t\tbreak;\n\tcase RDMA_CM_EVENT_DISCONNECTED:\n\tcase RDMA_CM_EVENT_ADDR_CHANGE:\n\tcase RDMA_CM_EVENT_TIMEWAIT_EXIT:\n\t\tiser_cleanup_handler(cma_id, false);\n\t\tbreak;\n\tcase RDMA_CM_EVENT_DEVICE_REMOVAL:\n\t\t \n\t\tiser_cleanup_handler(cma_id, true);\n\t\tif (iser_conn->state != ISER_CONN_DOWN) {\n\t\t\tiser_conn->ib_conn.cma_id = NULL;\n\t\t\tret = 1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tiser_err(\"Unexpected RDMA CM event: %s (%d)\\n\",\n\t\t\t rdma_event_msg(event->event), event->event);\n\t\tbreak;\n\t}\n\tmutex_unlock(&iser_conn->state_mutex);\n\n\treturn ret;\n}\n\nvoid iser_conn_init(struct iser_conn *iser_conn)\n{\n\tstruct ib_conn *ib_conn = &iser_conn->ib_conn;\n\n\tiser_conn->state = ISER_CONN_INIT;\n\tinit_completion(&iser_conn->stop_completion);\n\tinit_completion(&iser_conn->ib_completion);\n\tinit_completion(&iser_conn->up_completion);\n\tINIT_LIST_HEAD(&iser_conn->conn_list);\n\tmutex_init(&iser_conn->state_mutex);\n\n\tib_conn->reg_cqe.done = iser_reg_comp;\n}\n\n \nint iser_connect(struct iser_conn *iser_conn, struct sockaddr *src_addr,\n\t\t struct sockaddr *dst_addr, int non_blocking)\n{\n\tstruct ib_conn *ib_conn = &iser_conn->ib_conn;\n\tint err = 0;\n\n\tmutex_lock(&iser_conn->state_mutex);\n\n\tsprintf(iser_conn->name, \"%pISp\", dst_addr);\n\n\tiser_info(\"connecting to: %s\\n\", iser_conn->name);\n\n\t \n\tib_conn->device = NULL;\n\n\tiser_conn->state = ISER_CONN_PENDING;\n\n\tib_conn->cma_id = rdma_create_id(&init_net, iser_cma_handler,\n\t\t\t\t\t iser_conn, RDMA_PS_TCP, IB_QPT_RC);\n\tif (IS_ERR(ib_conn->cma_id)) {\n\t\terr = PTR_ERR(ib_conn->cma_id);\n\t\tiser_err(\"rdma_create_id failed: %d\\n\", err);\n\t\tgoto id_failure;\n\t}\n\n\terr = rdma_resolve_addr(ib_conn->cma_id, src_addr, dst_addr, 1000);\n\tif (err) {\n\t\tiser_err(\"rdma_resolve_addr failed: %d\\n\", err);\n\t\tgoto addr_failure;\n\t}\n\n\tif (!non_blocking) {\n\t\twait_for_completion_interruptible(&iser_conn->up_completion);\n\n\t\tif (iser_conn->state != ISER_CONN_UP) {\n\t\t\terr =  -EIO;\n\t\t\tgoto connect_failure;\n\t\t}\n\t}\n\tmutex_unlock(&iser_conn->state_mutex);\n\n\tmutex_lock(&ig.connlist_mutex);\n\tlist_add(&iser_conn->conn_list, &ig.connlist);\n\tmutex_unlock(&ig.connlist_mutex);\n\treturn 0;\n\nid_failure:\n\tib_conn->cma_id = NULL;\naddr_failure:\n\tiser_conn->state = ISER_CONN_DOWN;\nconnect_failure:\n\tmutex_unlock(&iser_conn->state_mutex);\n\tiser_conn_release(iser_conn);\n\treturn err;\n}\n\nint iser_post_recvl(struct iser_conn *iser_conn)\n{\n\tstruct ib_conn *ib_conn = &iser_conn->ib_conn;\n\tstruct iser_login_desc *desc = &iser_conn->login_desc;\n\tstruct ib_recv_wr wr;\n\tint ret;\n\n\tdesc->sge.addr = desc->rsp_dma;\n\tdesc->sge.length = ISER_RX_LOGIN_SIZE;\n\tdesc->sge.lkey = ib_conn->device->pd->local_dma_lkey;\n\n\tdesc->cqe.done = iser_login_rsp;\n\twr.wr_cqe = &desc->cqe;\n\twr.sg_list = &desc->sge;\n\twr.num_sge = 1;\n\twr.next = NULL;\n\n\tret = ib_post_recv(ib_conn->qp, &wr, NULL);\n\tif (unlikely(ret))\n\t\tiser_err(\"ib_post_recv login failed ret=%d\\n\", ret);\n\n\treturn ret;\n}\n\nint iser_post_recvm(struct iser_conn *iser_conn, struct iser_rx_desc *rx_desc)\n{\n\tstruct ib_conn *ib_conn = &iser_conn->ib_conn;\n\tstruct ib_recv_wr wr;\n\tint ret;\n\n\trx_desc->cqe.done = iser_task_rsp;\n\twr.wr_cqe = &rx_desc->cqe;\n\twr.sg_list = &rx_desc->rx_sg;\n\twr.num_sge = 1;\n\twr.next = NULL;\n\n\tret = ib_post_recv(ib_conn->qp, &wr, NULL);\n\tif (unlikely(ret))\n\t\tiser_err(\"ib_post_recv failed ret=%d\\n\", ret);\n\n\treturn ret;\n}\n\n\n \nint iser_post_send(struct ib_conn *ib_conn, struct iser_tx_desc *tx_desc)\n{\n\tstruct ib_send_wr *wr = &tx_desc->send_wr;\n\tstruct ib_send_wr *first_wr;\n\tint ret;\n\n\tib_dma_sync_single_for_device(ib_conn->device->ib_device,\n\t\t\t\t      tx_desc->dma_addr, ISER_HEADERS_LEN,\n\t\t\t\t      DMA_TO_DEVICE);\n\n\twr->next = NULL;\n\twr->wr_cqe = &tx_desc->cqe;\n\twr->sg_list = tx_desc->tx_sg;\n\twr->num_sge = tx_desc->num_sge;\n\twr->opcode = IB_WR_SEND;\n\twr->send_flags = IB_SEND_SIGNALED;\n\n\tif (tx_desc->inv_wr.next)\n\t\tfirst_wr = &tx_desc->inv_wr;\n\telse if (tx_desc->reg_wr.wr.next)\n\t\tfirst_wr = &tx_desc->reg_wr.wr;\n\telse\n\t\tfirst_wr = wr;\n\n\tret = ib_post_send(ib_conn->qp, first_wr, NULL);\n\tif (unlikely(ret))\n\t\tiser_err(\"ib_post_send failed, ret:%d opcode:%d\\n\",\n\t\t\t ret, wr->opcode);\n\n\treturn ret;\n}\n\nu8 iser_check_task_pi_status(struct iscsi_iser_task *iser_task,\n\t\t\t     enum iser_data_dir cmd_dir, sector_t *sector)\n{\n\tstruct iser_mem_reg *reg = &iser_task->rdma_reg[cmd_dir];\n\tstruct iser_fr_desc *desc = reg->desc;\n\tunsigned long sector_size = iser_task->sc->device->sector_size;\n\tstruct ib_mr_status mr_status;\n\tint ret;\n\n\tif (desc && desc->sig_protected) {\n\t\tdesc->sig_protected = false;\n\t\tret = ib_check_mr_status(desc->rsc.sig_mr,\n\t\t\t\t\t IB_MR_CHECK_SIG_STATUS, &mr_status);\n\t\tif (ret) {\n\t\t\tiser_err(\"ib_check_mr_status failed, ret %d\\n\", ret);\n\t\t\t \n\t\t\t*sector = 0;\n\t\t\treturn 0x1;\n\t\t}\n\n\t\tif (mr_status.fail_status & IB_MR_CHECK_SIG_STATUS) {\n\t\t\tsector_t sector_off = mr_status.sig_err.sig_err_offset;\n\n\t\t\tsector_div(sector_off, sector_size + 8);\n\t\t\t*sector = scsi_get_sector(iser_task->sc) + sector_off;\n\n\t\t\tiser_err(\"PI error found type %d at sector %llx \"\n\t\t\t       \"expected %x vs actual %x\\n\",\n\t\t\t       mr_status.sig_err.err_type,\n\t\t\t       (unsigned long long)*sector,\n\t\t\t       mr_status.sig_err.expected,\n\t\t\t       mr_status.sig_err.actual);\n\n\t\t\tswitch (mr_status.sig_err.err_type) {\n\t\t\tcase IB_SIG_BAD_GUARD:\n\t\t\t\treturn 0x1;\n\t\t\tcase IB_SIG_BAD_REFTAG:\n\t\t\t\treturn 0x3;\n\t\t\tcase IB_SIG_BAD_APPTAG:\n\t\t\t\treturn 0x2;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid iser_err_comp(struct ib_wc *wc, const char *type)\n{\n\tif (wc->status != IB_WC_WR_FLUSH_ERR) {\n\t\tstruct iser_conn *iser_conn = to_iser_conn(wc->qp->qp_context);\n\n\t\tiser_err(\"%s failure: %s (%d) vend_err %#x\\n\", type,\n\t\t\t ib_wc_status_msg(wc->status), wc->status,\n\t\t\t wc->vendor_err);\n\n\t\tif (iser_conn->iscsi_conn)\n\t\t\tiscsi_conn_failure(iser_conn->iscsi_conn,\n\t\t\t\t\t   ISCSI_ERR_CONN_FAILED);\n\t} else {\n\t\tiser_dbg(\"%s failure: %s (%d)\\n\", type,\n\t\t\t ib_wc_status_msg(wc->status), wc->status);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}