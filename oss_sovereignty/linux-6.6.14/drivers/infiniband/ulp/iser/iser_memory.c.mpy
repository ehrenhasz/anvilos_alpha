{
  "module_name": "iser_memory.c",
  "hash_id": "2226972e3b694a0303b3650a13b3cf97c8300e44bde46b38f19c39e665913a31",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/ulp/iser/iser_memory.c",
  "human_readable_source": " \n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/scatterlist.h>\n\n#include \"iscsi_iser.h\"\n\nvoid iser_reg_comp(struct ib_cq *cq, struct ib_wc *wc)\n{\n\tiser_err_comp(wc, \"memreg\");\n}\n\nstatic struct iser_fr_desc *iser_reg_desc_get_fr(struct ib_conn *ib_conn)\n{\n\tstruct iser_fr_pool *fr_pool = &ib_conn->fr_pool;\n\tstruct iser_fr_desc *desc;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&fr_pool->lock, flags);\n\tdesc = list_first_entry(&fr_pool->list,\n\t\t\t\tstruct iser_fr_desc, list);\n\tlist_del(&desc->list);\n\tspin_unlock_irqrestore(&fr_pool->lock, flags);\n\n\treturn desc;\n}\n\nstatic void iser_reg_desc_put_fr(struct ib_conn *ib_conn,\n\t\t\t\t struct iser_fr_desc *desc)\n{\n\tstruct iser_fr_pool *fr_pool = &ib_conn->fr_pool;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&fr_pool->lock, flags);\n\tlist_add(&desc->list, &fr_pool->list);\n\tspin_unlock_irqrestore(&fr_pool->lock, flags);\n}\n\nint iser_dma_map_task_data(struct iscsi_iser_task *iser_task,\n\t\t\t   enum iser_data_dir iser_dir,\n\t\t\t   enum dma_data_direction dma_dir)\n{\n\tstruct iser_data_buf *data = &iser_task->data[iser_dir];\n\tstruct ib_device *dev;\n\n\tiser_task->dir[iser_dir] = 1;\n\tdev = iser_task->iser_conn->ib_conn.device->ib_device;\n\n\tdata->dma_nents = ib_dma_map_sg(dev, data->sg, data->size, dma_dir);\n\tif (unlikely(data->dma_nents == 0)) {\n\t\tiser_err(\"dma_map_sg failed!!!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (scsi_prot_sg_count(iser_task->sc)) {\n\t\tstruct iser_data_buf *pdata = &iser_task->prot[iser_dir];\n\n\t\tpdata->dma_nents = ib_dma_map_sg(dev, pdata->sg, pdata->size, dma_dir);\n\t\tif (unlikely(pdata->dma_nents == 0)) {\n\t\t\tiser_err(\"protection dma_map_sg failed!!!\\n\");\n\t\t\tgoto out_unmap;\n\t\t}\n\t}\n\n\treturn 0;\n\nout_unmap:\n\tib_dma_unmap_sg(dev, data->sg, data->size, dma_dir);\n\treturn -EINVAL;\n}\n\n\nvoid iser_dma_unmap_task_data(struct iscsi_iser_task *iser_task,\n\t\t\t      enum iser_data_dir iser_dir,\n\t\t\t      enum dma_data_direction dma_dir)\n{\n\tstruct iser_data_buf *data = &iser_task->data[iser_dir];\n\tstruct ib_device *dev;\n\n\tdev = iser_task->iser_conn->ib_conn.device->ib_device;\n\tib_dma_unmap_sg(dev, data->sg, data->size, dma_dir);\n\n\tif (scsi_prot_sg_count(iser_task->sc)) {\n\t\tstruct iser_data_buf *pdata = &iser_task->prot[iser_dir];\n\n\t\tib_dma_unmap_sg(dev, pdata->sg, pdata->size, dma_dir);\n\t}\n}\n\nstatic int iser_reg_dma(struct iser_device *device, struct iser_data_buf *mem,\n\t\t\tstruct iser_mem_reg *reg)\n{\n\tstruct scatterlist *sg = mem->sg;\n\n\treg->sge.lkey = device->pd->local_dma_lkey;\n\t \n\n\tif (device->pd->flags & IB_PD_UNSAFE_GLOBAL_RKEY)\n\t\treg->rkey = device->pd->unsafe_global_rkey;\n\telse\n\t\treg->rkey = 0;\n\treg->sge.addr = sg_dma_address(&sg[0]);\n\treg->sge.length = sg_dma_len(&sg[0]);\n\n\tiser_dbg(\"Single DMA entry: lkey=0x%x, rkey=0x%x, addr=0x%llx,\"\n\t\t \" length=0x%x\\n\", reg->sge.lkey, reg->rkey,\n\t\t reg->sge.addr, reg->sge.length);\n\n\treturn 0;\n}\n\nvoid iser_unreg_mem_fastreg(struct iscsi_iser_task *iser_task,\n\t\t\t    enum iser_data_dir cmd_dir)\n{\n\tstruct iser_mem_reg *reg = &iser_task->rdma_reg[cmd_dir];\n\tstruct iser_fr_desc *desc;\n\tstruct ib_mr_status mr_status;\n\n\tdesc = reg->desc;\n\tif (!desc)\n\t\treturn;\n\n\t \n\tif (unlikely(desc->sig_protected)) {\n\t\tdesc->sig_protected = false;\n\t\tib_check_mr_status(desc->rsc.sig_mr, IB_MR_CHECK_SIG_STATUS,\n\t\t\t\t   &mr_status);\n\t}\n\tiser_reg_desc_put_fr(&iser_task->iser_conn->ib_conn, reg->desc);\n\treg->desc = NULL;\n}\n\nstatic void iser_set_dif_domain(struct scsi_cmnd *sc,\n\t\t\t\tstruct ib_sig_domain *domain)\n{\n\tdomain->sig_type = IB_SIG_TYPE_T10_DIF;\n\tdomain->sig.dif.pi_interval = scsi_prot_interval(sc);\n\tdomain->sig.dif.ref_tag = t10_pi_ref_tag(scsi_cmd_to_rq(sc));\n\t \n\tdomain->sig.dif.apptag_check_mask = 0xffff;\n\tdomain->sig.dif.app_escape = true;\n\tdomain->sig.dif.ref_escape = true;\n\tif (sc->prot_flags & SCSI_PROT_REF_INCREMENT)\n\t\tdomain->sig.dif.ref_remap = true;\n}\n\nstatic int iser_set_sig_attrs(struct scsi_cmnd *sc,\n\t\t\t      struct ib_sig_attrs *sig_attrs)\n{\n\tswitch (scsi_get_prot_op(sc)) {\n\tcase SCSI_PROT_WRITE_INSERT:\n\tcase SCSI_PROT_READ_STRIP:\n\t\tsig_attrs->mem.sig_type = IB_SIG_TYPE_NONE;\n\t\tiser_set_dif_domain(sc, &sig_attrs->wire);\n\t\tsig_attrs->wire.sig.dif.bg_type = IB_T10DIF_CRC;\n\t\tbreak;\n\tcase SCSI_PROT_READ_INSERT:\n\tcase SCSI_PROT_WRITE_STRIP:\n\t\tsig_attrs->wire.sig_type = IB_SIG_TYPE_NONE;\n\t\tiser_set_dif_domain(sc, &sig_attrs->mem);\n\t\tsig_attrs->mem.sig.dif.bg_type = sc->prot_flags & SCSI_PROT_IP_CHECKSUM ?\n\t\t\t\t\t\tIB_T10DIF_CSUM : IB_T10DIF_CRC;\n\t\tbreak;\n\tcase SCSI_PROT_READ_PASS:\n\tcase SCSI_PROT_WRITE_PASS:\n\t\tiser_set_dif_domain(sc, &sig_attrs->wire);\n\t\tsig_attrs->wire.sig.dif.bg_type = IB_T10DIF_CRC;\n\t\tiser_set_dif_domain(sc, &sig_attrs->mem);\n\t\tsig_attrs->mem.sig.dif.bg_type = sc->prot_flags & SCSI_PROT_IP_CHECKSUM ?\n\t\t\t\t\t\tIB_T10DIF_CSUM : IB_T10DIF_CRC;\n\t\tbreak;\n\tdefault:\n\t\tiser_err(\"Unsupported PI operation %d\\n\",\n\t\t\t scsi_get_prot_op(sc));\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic inline void iser_set_prot_checks(struct scsi_cmnd *sc, u8 *mask)\n{\n\t*mask = 0;\n\tif (sc->prot_flags & SCSI_PROT_REF_CHECK)\n\t\t*mask |= IB_SIG_CHECK_REFTAG;\n\tif (sc->prot_flags & SCSI_PROT_GUARD_CHECK)\n\t\t*mask |= IB_SIG_CHECK_GUARD;\n}\n\nstatic inline void iser_inv_rkey(struct ib_send_wr *inv_wr, struct ib_mr *mr,\n\t\t\t\t struct ib_cqe *cqe, struct ib_send_wr *next_wr)\n{\n\tinv_wr->opcode = IB_WR_LOCAL_INV;\n\tinv_wr->wr_cqe = cqe;\n\tinv_wr->ex.invalidate_rkey = mr->rkey;\n\tinv_wr->send_flags = 0;\n\tinv_wr->num_sge = 0;\n\tinv_wr->next = next_wr;\n}\n\nstatic int iser_reg_sig_mr(struct iscsi_iser_task *iser_task,\n\t\t\t   struct iser_data_buf *mem,\n\t\t\t   struct iser_data_buf *sig_mem,\n\t\t\t   struct iser_reg_resources *rsc,\n\t\t\t   struct iser_mem_reg *sig_reg)\n{\n\tstruct iser_tx_desc *tx_desc = &iser_task->desc;\n\tstruct ib_cqe *cqe = &iser_task->iser_conn->ib_conn.reg_cqe;\n\tstruct ib_mr *mr = rsc->sig_mr;\n\tstruct ib_sig_attrs *sig_attrs = mr->sig_attrs;\n\tstruct ib_reg_wr *wr = &tx_desc->reg_wr;\n\tint ret;\n\n\tmemset(sig_attrs, 0, sizeof(*sig_attrs));\n\tret = iser_set_sig_attrs(iser_task->sc, sig_attrs);\n\tif (ret)\n\t\tgoto err;\n\n\tiser_set_prot_checks(iser_task->sc, &sig_attrs->check_mask);\n\n\tif (rsc->sig_mr->need_inval)\n\t\tiser_inv_rkey(&tx_desc->inv_wr, mr, cqe, &wr->wr);\n\n\tib_update_fast_reg_key(mr, ib_inc_rkey(mr->rkey));\n\n\tret = ib_map_mr_sg_pi(mr, mem->sg, mem->dma_nents, NULL,\n\t\t\t      sig_mem->sg, sig_mem->dma_nents, NULL, SZ_4K);\n\tif (unlikely(ret)) {\n\t\tiser_err(\"failed to map PI sg (%d)\\n\",\n\t\t\t mem->dma_nents + sig_mem->dma_nents);\n\t\tgoto err;\n\t}\n\n\tmemset(wr, 0, sizeof(*wr));\n\twr->wr.next = &tx_desc->send_wr;\n\twr->wr.opcode = IB_WR_REG_MR_INTEGRITY;\n\twr->wr.wr_cqe = cqe;\n\twr->wr.num_sge = 0;\n\twr->wr.send_flags = 0;\n\twr->mr = mr;\n\twr->key = mr->rkey;\n\twr->access = IB_ACCESS_LOCAL_WRITE |\n\t\t     IB_ACCESS_REMOTE_READ |\n\t\t     IB_ACCESS_REMOTE_WRITE;\n\trsc->sig_mr->need_inval = true;\n\n\tsig_reg->sge.lkey = mr->lkey;\n\tsig_reg->rkey = mr->rkey;\n\tsig_reg->sge.addr = mr->iova;\n\tsig_reg->sge.length = mr->length;\n\n\tiser_dbg(\"lkey=0x%x rkey=0x%x addr=0x%llx length=%u\\n\",\n\t\t sig_reg->sge.lkey, sig_reg->rkey, sig_reg->sge.addr,\n\t\t sig_reg->sge.length);\nerr:\n\treturn ret;\n}\n\nstatic int iser_fast_reg_mr(struct iscsi_iser_task *iser_task,\n\t\t\t    struct iser_data_buf *mem,\n\t\t\t    struct iser_reg_resources *rsc,\n\t\t\t    struct iser_mem_reg *reg)\n{\n\tstruct iser_tx_desc *tx_desc = &iser_task->desc;\n\tstruct ib_cqe *cqe = &iser_task->iser_conn->ib_conn.reg_cqe;\n\tstruct ib_mr *mr = rsc->mr;\n\tstruct ib_reg_wr *wr = &tx_desc->reg_wr;\n\tint n;\n\n\tif (rsc->mr->need_inval)\n\t\tiser_inv_rkey(&tx_desc->inv_wr, mr, cqe, &wr->wr);\n\n\tib_update_fast_reg_key(mr, ib_inc_rkey(mr->rkey));\n\n\tn = ib_map_mr_sg(mr, mem->sg, mem->dma_nents, NULL, SZ_4K);\n\tif (unlikely(n != mem->dma_nents)) {\n\t\tiser_err(\"failed to map sg (%d/%d)\\n\",\n\t\t\t n, mem->dma_nents);\n\t\treturn n < 0 ? n : -EINVAL;\n\t}\n\n\twr->wr.next = &tx_desc->send_wr;\n\twr->wr.opcode = IB_WR_REG_MR;\n\twr->wr.wr_cqe = cqe;\n\twr->wr.send_flags = 0;\n\twr->wr.num_sge = 0;\n\twr->mr = mr;\n\twr->key = mr->rkey;\n\twr->access = IB_ACCESS_LOCAL_WRITE  |\n\t\t     IB_ACCESS_REMOTE_WRITE |\n\t\t     IB_ACCESS_REMOTE_READ;\n\n\trsc->mr->need_inval = true;\n\n\treg->sge.lkey = mr->lkey;\n\treg->rkey = mr->rkey;\n\treg->sge.addr = mr->iova;\n\treg->sge.length = mr->length;\n\n\tiser_dbg(\"lkey=0x%x rkey=0x%x addr=0x%llx length=0x%x\\n\",\n\t\t reg->sge.lkey, reg->rkey, reg->sge.addr, reg->sge.length);\n\n\treturn 0;\n}\n\nint iser_reg_mem_fastreg(struct iscsi_iser_task *task,\n\t\t\t enum iser_data_dir dir,\n\t\t\t bool all_imm)\n{\n\tstruct ib_conn *ib_conn = &task->iser_conn->ib_conn;\n\tstruct iser_device *device = ib_conn->device;\n\tstruct iser_data_buf *mem = &task->data[dir];\n\tstruct iser_mem_reg *reg = &task->rdma_reg[dir];\n\tstruct iser_fr_desc *desc;\n\tbool use_dma_key;\n\tint err;\n\n\tuse_dma_key = mem->dma_nents == 1 && (all_imm || !iser_always_reg) &&\n\t\t      scsi_get_prot_op(task->sc) == SCSI_PROT_NORMAL;\n\tif (use_dma_key)\n\t\treturn iser_reg_dma(device, mem, reg);\n\n\tdesc = iser_reg_desc_get_fr(ib_conn);\n\tif (scsi_get_prot_op(task->sc) == SCSI_PROT_NORMAL) {\n\t\terr = iser_fast_reg_mr(task, mem, &desc->rsc, reg);\n\t\tif (unlikely(err))\n\t\t\tgoto err_reg;\n\t} else {\n\t\terr = iser_reg_sig_mr(task, mem, &task->prot[dir],\n\t\t\t\t      &desc->rsc, reg);\n\t\tif (unlikely(err))\n\t\t\tgoto err_reg;\n\n\t\tdesc->sig_protected = true;\n\t}\n\n\treg->desc = desc;\n\n\treturn 0;\n\nerr_reg:\n\tiser_reg_desc_put_fr(ib_conn, desc);\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}