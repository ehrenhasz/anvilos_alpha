{
  "module_name": "iscsi_iser.c",
  "hash_id": "b6d6caaceb39fb05ff6a234ceeb798663960146fb6aff0dbaf3cdb541b8cd832",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/ulp/iser/iscsi_iser.c",
  "human_readable_source": " \n\n#include <linux/types.h>\n#include <linux/list.h>\n#include <linux/hardirq.h>\n#include <linux/kfifo.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/cdev.h>\n#include <linux/in.h>\n#include <linux/net.h>\n#include <linux/scatterlist.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#include <net/sock.h>\n\n#include <linux/uaccess.h>\n\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_transport_iscsi.h>\n\n#include \"iscsi_iser.h\"\n\nMODULE_DESCRIPTION(\"iSER (iSCSI Extensions for RDMA) Datamover\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_AUTHOR(\"Alex Nezhinsky, Dan Bar Dov, Or Gerlitz\");\n\nstatic const struct scsi_host_template iscsi_iser_sht;\nstatic struct iscsi_transport iscsi_iser_transport;\nstatic struct scsi_transport_template *iscsi_iser_scsi_transport;\nstatic struct workqueue_struct *release_wq;\nstatic DEFINE_MUTEX(unbind_iser_conn_mutex);\nstruct iser_global ig;\n\nint iser_debug_level = 0;\nmodule_param_named(debug_level, iser_debug_level, int, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(debug_level, \"Enable debug tracing if > 0 (default:disabled)\");\n\nstatic int iscsi_iser_set(const char *val, const struct kernel_param *kp);\nstatic const struct kernel_param_ops iscsi_iser_size_ops = {\n\t.set = iscsi_iser_set,\n\t.get = param_get_uint,\n};\n\nstatic unsigned int iscsi_max_lun = 512;\nmodule_param_cb(max_lun, &iscsi_iser_size_ops, &iscsi_max_lun, S_IRUGO);\nMODULE_PARM_DESC(max_lun, \"Max LUNs to allow per session, should > 0 (default:512)\");\n\nunsigned int iser_max_sectors = ISER_DEF_MAX_SECTORS;\nmodule_param_cb(max_sectors, &iscsi_iser_size_ops, &iser_max_sectors,\n\t\tS_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(max_sectors, \"Max number of sectors in a single scsi command, should > 0 (default:1024)\");\n\nbool iser_always_reg = true;\nmodule_param_named(always_register, iser_always_reg, bool, S_IRUGO);\nMODULE_PARM_DESC(always_register,\n\t\t \"Always register memory, even for continuous memory regions (default:true)\");\n\nbool iser_pi_enable = false;\nmodule_param_named(pi_enable, iser_pi_enable, bool, S_IRUGO);\nMODULE_PARM_DESC(pi_enable, \"Enable T10-PI offload support (default:disabled)\");\n\nstatic int iscsi_iser_set(const char *val, const struct kernel_param *kp)\n{\n\tint ret;\n\tunsigned int n = 0;\n\n\tret = kstrtouint(val, 10, &n);\n\tif (ret != 0 || n == 0)\n\t\treturn -EINVAL;\n\n\treturn param_set_uint(val, kp);\n}\n\n \nvoid iscsi_iser_recv(struct iscsi_conn *conn, struct iscsi_hdr *hdr,\n\t\t     char *rx_data, int rx_data_len)\n{\n\tint rc = 0;\n\tint datalen;\n\n\t \n\tdatalen = ntoh24(hdr->dlength);\n\tif (datalen > rx_data_len || (datalen + 4) < rx_data_len) {\n\t\tiser_err(\"wrong datalen %d (hdr), %d (IB)\\n\",\n\t\t\tdatalen, rx_data_len);\n\t\trc = ISCSI_ERR_DATALEN;\n\t\tgoto error;\n\t}\n\n\tif (datalen != rx_data_len)\n\t\tiser_dbg(\"aligned datalen (%d) hdr, %d (IB)\\n\",\n\t\t\tdatalen, rx_data_len);\n\n\trc = iscsi_complete_pdu(conn, hdr, rx_data, rx_data_len);\n\tif (rc && rc != ISCSI_ERR_NO_SCSI_CMD)\n\t\tgoto error;\n\n\treturn;\nerror:\n\tiscsi_conn_failure(conn, rc);\n}\n\n \nstatic int iscsi_iser_pdu_alloc(struct iscsi_task *task, uint8_t opcode)\n{\n\tstruct iscsi_iser_task *iser_task = task->dd_data;\n\n\ttask->hdr = (struct iscsi_hdr *)&iser_task->desc.iscsi_header;\n\ttask->hdr_max = sizeof(iser_task->desc.iscsi_header);\n\n\treturn 0;\n}\n\n \nint iser_initialize_task_headers(struct iscsi_task *task,\n\t\t\t\t struct iser_tx_desc *tx_desc)\n{\n\tstruct iser_conn *iser_conn = task->conn->dd_data;\n\tstruct iser_device *device = iser_conn->ib_conn.device;\n\tstruct iscsi_iser_task *iser_task = task->dd_data;\n\tu64 dma_addr;\n\n\tif (unlikely(iser_conn->state != ISER_CONN_UP))\n\t\treturn -ENODEV;\n\n\tdma_addr = ib_dma_map_single(device->ib_device, (void *)tx_desc,\n\t\t\t\tISER_HEADERS_LEN, DMA_TO_DEVICE);\n\tif (ib_dma_mapping_error(device->ib_device, dma_addr))\n\t\treturn -ENOMEM;\n\n\ttx_desc->inv_wr.next = NULL;\n\ttx_desc->reg_wr.wr.next = NULL;\n\ttx_desc->mapped = true;\n\ttx_desc->dma_addr = dma_addr;\n\ttx_desc->tx_sg[0].addr   = tx_desc->dma_addr;\n\ttx_desc->tx_sg[0].length = ISER_HEADERS_LEN;\n\ttx_desc->tx_sg[0].lkey   = device->pd->local_dma_lkey;\n\n\tiser_task->iser_conn = iser_conn;\n\n\treturn 0;\n}\n\n \nstatic int iscsi_iser_task_init(struct iscsi_task *task)\n{\n\tstruct iscsi_iser_task *iser_task = task->dd_data;\n\tint ret;\n\n\tret = iser_initialize_task_headers(task, &iser_task->desc);\n\tif (ret) {\n\t\tiser_err(\"Failed to init task %p, err = %d\\n\",\n\t\t\t iser_task, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (!task->sc)\n\t\treturn 0;\n\n\tiser_task->command_sent = 0;\n\tiser_task_rdma_init(iser_task);\n\tiser_task->sc = task->sc;\n\n\treturn 0;\n}\n\n \nstatic int iscsi_iser_mtask_xmit(struct iscsi_conn *conn,\n\t\t\t\t struct iscsi_task *task)\n{\n\tint error = 0;\n\n\tiser_dbg(\"mtask xmit [cid %d itt 0x%x]\\n\", conn->id, task->itt);\n\n\terror = iser_send_control(conn, task);\n\n\t \n\treturn error;\n}\n\nstatic int iscsi_iser_task_xmit_unsol_data(struct iscsi_conn *conn,\n\t\t\t\t\t   struct iscsi_task *task)\n{\n\tstruct iscsi_r2t_info *r2t = &task->unsol_r2t;\n\tstruct iscsi_data hdr;\n\tint error = 0;\n\n\t \n\twhile (iscsi_task_has_unsol_data(task)) {\n\t\tiscsi_prep_data_out_pdu(task, r2t, &hdr);\n\t\tiser_dbg(\"Sending data-out: itt 0x%x, data count %d\\n\",\n\t\t\t   hdr.itt, r2t->data_count);\n\n\t\t \n\t\t \n\t\terror = iser_send_data_out(conn, task, &hdr);\n\t\tif (error) {\n\t\t\tr2t->datasn--;\n\t\t\tgoto iscsi_iser_task_xmit_unsol_data_exit;\n\t\t}\n\t\tr2t->sent += r2t->data_count;\n\t\tiser_dbg(\"Need to send %d more as data-out PDUs\\n\",\n\t\t\t   r2t->data_length - r2t->sent);\n\t}\n\niscsi_iser_task_xmit_unsol_data_exit:\n\treturn error;\n}\n\n \nstatic int iscsi_iser_task_xmit(struct iscsi_task *task)\n{\n\tstruct iscsi_conn *conn = task->conn;\n\tstruct iscsi_iser_task *iser_task = task->dd_data;\n\tint error = 0;\n\n\tif (!task->sc)\n\t\treturn iscsi_iser_mtask_xmit(conn, task);\n\n\tif (task->sc->sc_data_direction == DMA_TO_DEVICE) {\n\t\tBUG_ON(scsi_bufflen(task->sc) == 0);\n\n\t\tiser_dbg(\"cmd [itt %x total %d imm %d unsol_data %d\\n\",\n\t\t\t   task->itt, scsi_bufflen(task->sc),\n\t\t\t   task->imm_count, task->unsol_r2t.data_length);\n\t}\n\n\tiser_dbg(\"ctask xmit [cid %d itt 0x%x]\\n\",\n\t\t   conn->id, task->itt);\n\n\t \n\tif (!iser_task->command_sent) {\n\t\terror = iser_send_command(conn, task);\n\t\tif (error)\n\t\t\tgoto iscsi_iser_task_xmit_exit;\n\t\tiser_task->command_sent = 1;\n\t}\n\n\t \n\tif (iscsi_task_has_unsol_data(task))\n\t\terror = iscsi_iser_task_xmit_unsol_data(conn, task);\n\n iscsi_iser_task_xmit_exit:\n\treturn error;\n}\n\n \nstatic void iscsi_iser_cleanup_task(struct iscsi_task *task)\n{\n\tstruct iscsi_iser_task *iser_task = task->dd_data;\n\tstruct iser_tx_desc *tx_desc = &iser_task->desc;\n\tstruct iser_conn *iser_conn = task->conn->dd_data;\n\tstruct iser_device *device = iser_conn->ib_conn.device;\n\n\t \n\tif (!device)\n\t\treturn;\n\n\tif (likely(tx_desc->mapped)) {\n\t\tib_dma_unmap_single(device->ib_device, tx_desc->dma_addr,\n\t\t\t\t    ISER_HEADERS_LEN, DMA_TO_DEVICE);\n\t\ttx_desc->mapped = false;\n\t}\n\n\t \n\tif (!task->sc)\n\t\treturn;\n\n\tif (iser_task->status == ISER_TASK_STATUS_STARTED) {\n\t\tiser_task->status = ISER_TASK_STATUS_COMPLETED;\n\t\tiser_task_rdma_finalize(iser_task);\n\t}\n}\n\n \nstatic u8 iscsi_iser_check_protection(struct iscsi_task *task, sector_t *sector)\n{\n\tstruct iscsi_iser_task *iser_task = task->dd_data;\n\tenum iser_data_dir dir = iser_task->dir[ISER_DIR_IN] ?\n\t\t\t\t\tISER_DIR_IN : ISER_DIR_OUT;\n\n\treturn iser_check_task_pi_status(iser_task, dir, sector);\n}\n\n \nstatic struct iscsi_cls_conn *\niscsi_iser_conn_create(struct iscsi_cls_session *cls_session,\n\t\t       uint32_t conn_idx)\n{\n\tstruct iscsi_conn *conn;\n\tstruct iscsi_cls_conn *cls_conn;\n\n\tcls_conn = iscsi_conn_setup(cls_session, 0, conn_idx);\n\tif (!cls_conn)\n\t\treturn NULL;\n\tconn = cls_conn->dd_data;\n\n\t \n\tconn->max_recv_dlength = ISER_RECV_DATA_SEG_LEN;\n\n\treturn cls_conn;\n}\n\n \nstatic int iscsi_iser_conn_bind(struct iscsi_cls_session *cls_session,\n\t\t\t\tstruct iscsi_cls_conn *cls_conn,\n\t\t\t\tuint64_t transport_eph, int is_leading)\n{\n\tstruct iscsi_conn *conn = cls_conn->dd_data;\n\tstruct iser_conn *iser_conn;\n\tstruct iscsi_endpoint *ep;\n\tint error;\n\n\terror = iscsi_conn_bind(cls_session, cls_conn, is_leading);\n\tif (error)\n\t\treturn error;\n\n\t \n\tep = iscsi_lookup_endpoint(transport_eph);\n\tif (!ep) {\n\t\tiser_err(\"can't bind eph %llx\\n\",\n\t\t\t (unsigned long long)transport_eph);\n\t\treturn -EINVAL;\n\t}\n\tiser_conn = ep->dd_data;\n\n\tmutex_lock(&iser_conn->state_mutex);\n\tif (iser_conn->state != ISER_CONN_UP) {\n\t\terror = -EINVAL;\n\t\tiser_err(\"iser_conn %p state is %d, teardown started\\n\",\n\t\t\t iser_conn, iser_conn->state);\n\t\tgoto out;\n\t}\n\n\terror = iser_alloc_rx_descriptors(iser_conn, conn->session);\n\tif (error)\n\t\tgoto out;\n\n\t \n\tiser_info(\"binding iscsi conn %p to iser_conn %p\\n\", conn, iser_conn);\n\n\tconn->dd_data = iser_conn;\n\tiser_conn->iscsi_conn = conn;\n\nout:\n\tiscsi_put_endpoint(ep);\n\tmutex_unlock(&iser_conn->state_mutex);\n\treturn error;\n}\n\n \nstatic int iscsi_iser_conn_start(struct iscsi_cls_conn *cls_conn)\n{\n\tstruct iscsi_conn *iscsi_conn;\n\tstruct iser_conn *iser_conn;\n\n\tiscsi_conn = cls_conn->dd_data;\n\tiser_conn = iscsi_conn->dd_data;\n\treinit_completion(&iser_conn->stop_completion);\n\n\treturn iscsi_conn_start(cls_conn);\n}\n\n \nstatic void iscsi_iser_conn_stop(struct iscsi_cls_conn *cls_conn, int flag)\n{\n\tstruct iscsi_conn *conn = cls_conn->dd_data;\n\tstruct iser_conn *iser_conn = conn->dd_data;\n\n\tiser_info(\"stopping iscsi_conn: %p, iser_conn: %p\\n\", conn, iser_conn);\n\n\t \n\tif (iser_conn) {\n\t\tmutex_lock(&iser_conn->state_mutex);\n\t\tmutex_lock(&unbind_iser_conn_mutex);\n\t\tiser_conn_terminate(iser_conn);\n\t\tiscsi_conn_stop(cls_conn, flag);\n\n\t\t \n\t\tiser_conn->iscsi_conn = NULL;\n\t\tconn->dd_data = NULL;\n\t\tmutex_unlock(&unbind_iser_conn_mutex);\n\n\t\tcomplete(&iser_conn->stop_completion);\n\t\tmutex_unlock(&iser_conn->state_mutex);\n\t} else {\n\t\tiscsi_conn_stop(cls_conn, flag);\n\t}\n}\n\n \nstatic void iscsi_iser_session_destroy(struct iscsi_cls_session *cls_session)\n{\n\tstruct Scsi_Host *shost = iscsi_session_to_shost(cls_session);\n\n\tiscsi_session_teardown(cls_session);\n\tiscsi_host_remove(shost, false);\n\tiscsi_host_free(shost);\n}\n\nstatic inline unsigned int iser_dif_prot_caps(int prot_caps)\n{\n\tint ret = 0;\n\n\tif (prot_caps & IB_PROT_T10DIF_TYPE_1)\n\t\tret |= SHOST_DIF_TYPE1_PROTECTION |\n\t\t       SHOST_DIX_TYPE0_PROTECTION |\n\t\t       SHOST_DIX_TYPE1_PROTECTION;\n\tif (prot_caps & IB_PROT_T10DIF_TYPE_2)\n\t\tret |= SHOST_DIF_TYPE2_PROTECTION |\n\t\t       SHOST_DIX_TYPE2_PROTECTION;\n\tif (prot_caps & IB_PROT_T10DIF_TYPE_3)\n\t\tret |= SHOST_DIF_TYPE3_PROTECTION |\n\t\t       SHOST_DIX_TYPE3_PROTECTION;\n\n\treturn ret;\n}\n\n \nstatic struct iscsi_cls_session *\niscsi_iser_session_create(struct iscsi_endpoint *ep,\n\t\t\t  uint16_t cmds_max, uint16_t qdepth,\n\t\t\t  uint32_t initial_cmdsn)\n{\n\tstruct iscsi_cls_session *cls_session;\n\tstruct Scsi_Host *shost;\n\tstruct iser_conn *iser_conn = NULL;\n\tstruct ib_conn *ib_conn;\n\tstruct ib_device *ib_dev;\n\tu32 max_fr_sectors;\n\n\tshost = iscsi_host_alloc(&iscsi_iser_sht, 0, 0);\n\tif (!shost)\n\t\treturn NULL;\n\tshost->transportt = iscsi_iser_scsi_transport;\n\tshost->cmd_per_lun = qdepth;\n\tshost->max_lun = iscsi_max_lun;\n\tshost->max_id = 0;\n\tshost->max_channel = 0;\n\tshost->max_cmd_len = 16;\n\n\t \n\tif (ep) {\n\t\tiser_conn = ep->dd_data;\n\t\tshost->sg_tablesize = iser_conn->scsi_sg_tablesize;\n\t\tshost->can_queue = min_t(u16, cmds_max, iser_conn->max_cmds);\n\n\t\tmutex_lock(&iser_conn->state_mutex);\n\t\tif (iser_conn->state != ISER_CONN_UP) {\n\t\t\tiser_err(\"iser conn %p already started teardown\\n\",\n\t\t\t\t iser_conn);\n\t\t\tmutex_unlock(&iser_conn->state_mutex);\n\t\t\tgoto free_host;\n\t\t}\n\n\t\tib_conn = &iser_conn->ib_conn;\n\t\tib_dev = ib_conn->device->ib_device;\n\t\tif (ib_conn->pi_support) {\n\t\t\tu32 sig_caps = ib_dev->attrs.sig_prot_cap;\n\n\t\t\tshost->sg_prot_tablesize = shost->sg_tablesize;\n\t\t\tscsi_host_set_prot(shost, iser_dif_prot_caps(sig_caps));\n\t\t\tscsi_host_set_guard(shost, SHOST_DIX_GUARD_IP |\n\t\t\t\t\t\t   SHOST_DIX_GUARD_CRC);\n\t\t}\n\n\t\tif (!(ib_dev->attrs.kernel_cap_flags & IBK_SG_GAPS_REG))\n\t\t\tshost->virt_boundary_mask = SZ_4K - 1;\n\n\t\tif (iscsi_host_add(shost, ib_dev->dev.parent)) {\n\t\t\tmutex_unlock(&iser_conn->state_mutex);\n\t\t\tgoto free_host;\n\t\t}\n\t\tmutex_unlock(&iser_conn->state_mutex);\n\t} else {\n\t\tshost->can_queue = min_t(u16, cmds_max, ISER_DEF_XMIT_CMDS_MAX);\n\t\tif (iscsi_host_add(shost, NULL))\n\t\t\tgoto free_host;\n\t}\n\n\tmax_fr_sectors = (shost->sg_tablesize * PAGE_SIZE) >> 9;\n\tshost->max_sectors = min(iser_max_sectors, max_fr_sectors);\n\n\tiser_dbg(\"iser_conn %p, sg_tablesize %u, max_sectors %u\\n\",\n\t\t iser_conn, shost->sg_tablesize,\n\t\t shost->max_sectors);\n\n\tif (shost->max_sectors < iser_max_sectors)\n\t\tiser_warn(\"max_sectors was reduced from %u to %u\\n\",\n\t\t\t  iser_max_sectors, shost->max_sectors);\n\n\tcls_session = iscsi_session_setup(&iscsi_iser_transport, shost,\n\t\t\t\t\t  shost->can_queue, 0,\n\t\t\t\t\t  sizeof(struct iscsi_iser_task),\n\t\t\t\t\t  initial_cmdsn, 0);\n\tif (!cls_session)\n\t\tgoto remove_host;\n\n\treturn cls_session;\n\nremove_host:\n\tiscsi_host_remove(shost, false);\nfree_host:\n\tiscsi_host_free(shost);\n\treturn NULL;\n}\n\nstatic int iscsi_iser_set_param(struct iscsi_cls_conn *cls_conn,\n\t\t\t\tenum iscsi_param param, char *buf, int buflen)\n{\n\tint value;\n\n\tswitch (param) {\n\tcase ISCSI_PARAM_MAX_RECV_DLENGTH:\n\t\t \n\t\tbreak;\n\tcase ISCSI_PARAM_HDRDGST_EN:\n\t\tsscanf(buf, \"%d\", &value);\n\t\tif (value) {\n\t\t\tiser_err(\"DataDigest wasn't negotiated to None\\n\");\n\t\t\treturn -EPROTO;\n\t\t}\n\t\tbreak;\n\tcase ISCSI_PARAM_DATADGST_EN:\n\t\tsscanf(buf, \"%d\", &value);\n\t\tif (value) {\n\t\t\tiser_err(\"DataDigest wasn't negotiated to None\\n\");\n\t\t\treturn -EPROTO;\n\t\t}\n\t\tbreak;\n\tcase ISCSI_PARAM_IFMARKER_EN:\n\t\tsscanf(buf, \"%d\", &value);\n\t\tif (value) {\n\t\t\tiser_err(\"IFMarker wasn't negotiated to No\\n\");\n\t\t\treturn -EPROTO;\n\t\t}\n\t\tbreak;\n\tcase ISCSI_PARAM_OFMARKER_EN:\n\t\tsscanf(buf, \"%d\", &value);\n\t\tif (value) {\n\t\t\tiser_err(\"OFMarker wasn't negotiated to No\\n\");\n\t\t\treturn -EPROTO;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn iscsi_set_param(cls_conn, param, buf, buflen);\n\t}\n\n\treturn 0;\n}\n\n \nstatic void iscsi_iser_conn_get_stats(struct iscsi_cls_conn *cls_conn,\n\t\t\t\t      struct iscsi_stats *stats)\n{\n\tstruct iscsi_conn *conn = cls_conn->dd_data;\n\n\tstats->txdata_octets = conn->txdata_octets;\n\tstats->rxdata_octets = conn->rxdata_octets;\n\tstats->scsicmd_pdus = conn->scsicmd_pdus_cnt;\n\tstats->dataout_pdus = conn->dataout_pdus_cnt;\n\tstats->scsirsp_pdus = conn->scsirsp_pdus_cnt;\n\tstats->datain_pdus = conn->datain_pdus_cnt;  \n\tstats->r2t_pdus = conn->r2t_pdus_cnt;  \n\tstats->tmfcmd_pdus = conn->tmfcmd_pdus_cnt;\n\tstats->tmfrsp_pdus = conn->tmfrsp_pdus_cnt;\n\tstats->custom_length = 0;\n}\n\nstatic int iscsi_iser_get_ep_param(struct iscsi_endpoint *ep,\n\t\t\t\t   enum iscsi_param param, char *buf)\n{\n\tstruct iser_conn *iser_conn = ep->dd_data;\n\n\tswitch (param) {\n\tcase ISCSI_PARAM_CONN_PORT:\n\tcase ISCSI_PARAM_CONN_ADDRESS:\n\t\tif (!iser_conn || !iser_conn->ib_conn.cma_id)\n\t\t\treturn -ENOTCONN;\n\n\t\treturn iscsi_conn_get_addr_param((struct sockaddr_storage *)\n\t\t\t\t&iser_conn->ib_conn.cma_id->route.addr.dst_addr,\n\t\t\t\tparam, buf);\n\tdefault:\n\t\tbreak;\n\t}\n\treturn -ENOSYS;\n}\n\n \nstatic struct iscsi_endpoint *iscsi_iser_ep_connect(struct Scsi_Host *shost,\n\t\t\t\t\t\t    struct sockaddr *dst_addr,\n\t\t\t\t\t\t    int non_blocking)\n{\n\tint err;\n\tstruct iser_conn *iser_conn;\n\tstruct iscsi_endpoint *ep;\n\n\tep = iscsi_create_endpoint(0);\n\tif (!ep)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tiser_conn = kzalloc(sizeof(*iser_conn), GFP_KERNEL);\n\tif (!iser_conn) {\n\t\terr = -ENOMEM;\n\t\tgoto failure;\n\t}\n\n\tep->dd_data = iser_conn;\n\tiser_conn->ep = ep;\n\tiser_conn_init(iser_conn);\n\n\terr = iser_connect(iser_conn, NULL, dst_addr, non_blocking);\n\tif (err)\n\t\tgoto failure;\n\n\treturn ep;\nfailure:\n\tiscsi_destroy_endpoint(ep);\n\treturn ERR_PTR(err);\n}\n\n \nstatic int iscsi_iser_ep_poll(struct iscsi_endpoint *ep, int timeout_ms)\n{\n\tstruct iser_conn *iser_conn = ep->dd_data;\n\tint rc;\n\n\trc = wait_for_completion_interruptible_timeout(&iser_conn->up_completion,\n\t\t\t\t\t\t       msecs_to_jiffies(timeout_ms));\n\t \n\tif (rc == 0) {\n\t\tmutex_lock(&iser_conn->state_mutex);\n\t\tif (iser_conn->state == ISER_CONN_TERMINATING ||\n\t\t    iser_conn->state == ISER_CONN_DOWN)\n\t\t\trc = -1;\n\t\tmutex_unlock(&iser_conn->state_mutex);\n\t}\n\n\tiser_info(\"iser conn %p rc = %d\\n\", iser_conn, rc);\n\n\tif (rc > 0)\n\t\treturn 1;  \n\telse if (!rc)\n\t\treturn 0;  \n\telse\n\t\treturn rc;  \n}\n\n \nstatic void iscsi_iser_ep_disconnect(struct iscsi_endpoint *ep)\n{\n\tstruct iser_conn *iser_conn = ep->dd_data;\n\n\tiser_info(\"ep %p iser conn %p\\n\", ep, iser_conn);\n\n\tmutex_lock(&iser_conn->state_mutex);\n\tiser_conn_terminate(iser_conn);\n\n\t \n\tif (iser_conn->iscsi_conn) {\n\t\tINIT_WORK(&iser_conn->release_work, iser_release_work);\n\t\tqueue_work(release_wq, &iser_conn->release_work);\n\t\tmutex_unlock(&iser_conn->state_mutex);\n\t} else {\n\t\tiser_conn->state = ISER_CONN_DOWN;\n\t\tmutex_unlock(&iser_conn->state_mutex);\n\t\tiser_conn_release(iser_conn);\n\t}\n\n\tiscsi_destroy_endpoint(ep);\n}\n\nstatic umode_t iser_attr_is_visible(int param_type, int param)\n{\n\tswitch (param_type) {\n\tcase ISCSI_HOST_PARAM:\n\t\tswitch (param) {\n\t\tcase ISCSI_HOST_PARAM_NETDEV_NAME:\n\t\tcase ISCSI_HOST_PARAM_HWADDRESS:\n\t\tcase ISCSI_HOST_PARAM_INITIATOR_NAME:\n\t\t\treturn S_IRUGO;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\tcase ISCSI_PARAM:\n\t\tswitch (param) {\n\t\tcase ISCSI_PARAM_MAX_RECV_DLENGTH:\n\t\tcase ISCSI_PARAM_MAX_XMIT_DLENGTH:\n\t\tcase ISCSI_PARAM_HDRDGST_EN:\n\t\tcase ISCSI_PARAM_DATADGST_EN:\n\t\tcase ISCSI_PARAM_CONN_ADDRESS:\n\t\tcase ISCSI_PARAM_CONN_PORT:\n\t\tcase ISCSI_PARAM_EXP_STATSN:\n\t\tcase ISCSI_PARAM_PERSISTENT_ADDRESS:\n\t\tcase ISCSI_PARAM_PERSISTENT_PORT:\n\t\tcase ISCSI_PARAM_PING_TMO:\n\t\tcase ISCSI_PARAM_RECV_TMO:\n\t\tcase ISCSI_PARAM_INITIAL_R2T_EN:\n\t\tcase ISCSI_PARAM_MAX_R2T:\n\t\tcase ISCSI_PARAM_IMM_DATA_EN:\n\t\tcase ISCSI_PARAM_FIRST_BURST:\n\t\tcase ISCSI_PARAM_MAX_BURST:\n\t\tcase ISCSI_PARAM_PDU_INORDER_EN:\n\t\tcase ISCSI_PARAM_DATASEQ_INORDER_EN:\n\t\tcase ISCSI_PARAM_TARGET_NAME:\n\t\tcase ISCSI_PARAM_TPGT:\n\t\tcase ISCSI_PARAM_USERNAME:\n\t\tcase ISCSI_PARAM_PASSWORD:\n\t\tcase ISCSI_PARAM_USERNAME_IN:\n\t\tcase ISCSI_PARAM_PASSWORD_IN:\n\t\tcase ISCSI_PARAM_FAST_ABORT:\n\t\tcase ISCSI_PARAM_ABORT_TMO:\n\t\tcase ISCSI_PARAM_LU_RESET_TMO:\n\t\tcase ISCSI_PARAM_TGT_RESET_TMO:\n\t\tcase ISCSI_PARAM_IFACE_NAME:\n\t\tcase ISCSI_PARAM_INITIATOR_NAME:\n\t\tcase ISCSI_PARAM_DISCOVERY_SESS:\n\t\t\treturn S_IRUGO;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct scsi_host_template iscsi_iser_sht = {\n\t.module                 = THIS_MODULE,\n\t.name                   = \"iSCSI Initiator over iSER\",\n\t.queuecommand           = iscsi_queuecommand,\n\t.change_queue_depth\t= scsi_change_queue_depth,\n\t.sg_tablesize           = ISCSI_ISER_DEF_SG_TABLESIZE,\n\t.cmd_per_lun            = ISER_DEF_CMD_PER_LUN,\n\t.eh_timed_out\t\t= iscsi_eh_cmd_timed_out,\n\t.eh_abort_handler       = iscsi_eh_abort,\n\t.eh_device_reset_handler= iscsi_eh_device_reset,\n\t.eh_target_reset_handler = iscsi_eh_recover_target,\n\t.target_alloc\t\t= iscsi_target_alloc,\n\t.proc_name              = \"iscsi_iser\",\n\t.this_id                = -1,\n\t.track_queue_depth\t= 1,\n\t.cmd_size\t\t= sizeof(struct iscsi_cmd),\n};\n\nstatic struct iscsi_transport iscsi_iser_transport = {\n\t.owner                  = THIS_MODULE,\n\t.name                   = \"iser\",\n\t.caps                   = CAP_RECOVERY_L0 | CAP_MULTI_R2T | CAP_TEXT_NEGO,\n\t \n\t.create_session         = iscsi_iser_session_create,\n\t.destroy_session        = iscsi_iser_session_destroy,\n\t \n\t.create_conn            = iscsi_iser_conn_create,\n\t.bind_conn              = iscsi_iser_conn_bind,\n\t.unbind_conn\t\t= iscsi_conn_unbind,\n\t.destroy_conn           = iscsi_conn_teardown,\n\t.attr_is_visible\t= iser_attr_is_visible,\n\t.set_param              = iscsi_iser_set_param,\n\t.get_conn_param\t\t= iscsi_conn_get_param,\n\t.get_ep_param\t\t= iscsi_iser_get_ep_param,\n\t.get_session_param\t= iscsi_session_get_param,\n\t.start_conn             = iscsi_iser_conn_start,\n\t.stop_conn              = iscsi_iser_conn_stop,\n\t \n\t.get_host_param\t\t= iscsi_host_get_param,\n\t.set_host_param\t\t= iscsi_host_set_param,\n\t \n\t.send_pdu\t\t= iscsi_conn_send_pdu,\n\t.get_stats\t\t= iscsi_iser_conn_get_stats,\n\t.init_task\t\t= iscsi_iser_task_init,\n\t.xmit_task\t\t= iscsi_iser_task_xmit,\n\t.cleanup_task\t\t= iscsi_iser_cleanup_task,\n\t.alloc_pdu\t\t= iscsi_iser_pdu_alloc,\n\t.check_protection\t= iscsi_iser_check_protection,\n\t \n\t.session_recovery_timedout = iscsi_session_recovery_timedout,\n\n\t.ep_connect             = iscsi_iser_ep_connect,\n\t.ep_poll                = iscsi_iser_ep_poll,\n\t.ep_disconnect          = iscsi_iser_ep_disconnect\n};\n\nstatic int __init iser_init(void)\n{\n\tint err;\n\n\tiser_dbg(\"Starting iSER datamover...\\n\");\n\n\tmemset(&ig, 0, sizeof(struct iser_global));\n\n\tig.desc_cache = kmem_cache_create(\"iser_descriptors\",\n\t\t\t\t\t  sizeof(struct iser_tx_desc),\n\t\t\t\t\t  0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t  NULL);\n\tif (ig.desc_cache == NULL)\n\t\treturn -ENOMEM;\n\n\t \n\tmutex_init(&ig.device_list_mutex);\n\tINIT_LIST_HEAD(&ig.device_list);\n\tmutex_init(&ig.connlist_mutex);\n\tINIT_LIST_HEAD(&ig.connlist);\n\n\trelease_wq = alloc_workqueue(\"release workqueue\", 0, 0);\n\tif (!release_wq) {\n\t\tiser_err(\"failed to allocate release workqueue\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc_wq;\n\t}\n\n\tiscsi_iser_scsi_transport = iscsi_register_transport(\n\t\t\t\t\t\t\t&iscsi_iser_transport);\n\tif (!iscsi_iser_scsi_transport) {\n\t\tiser_err(\"iscsi_register_transport failed\\n\");\n\t\terr = -EINVAL;\n\t\tgoto err_reg;\n\t}\n\n\treturn 0;\n\nerr_reg:\n\tdestroy_workqueue(release_wq);\nerr_alloc_wq:\n\tkmem_cache_destroy(ig.desc_cache);\n\n\treturn err;\n}\n\nstatic void __exit iser_exit(void)\n{\n\tstruct iser_conn *iser_conn, *n;\n\tint connlist_empty;\n\n\tiser_dbg(\"Removing iSER datamover...\\n\");\n\tdestroy_workqueue(release_wq);\n\n\tmutex_lock(&ig.connlist_mutex);\n\tconnlist_empty = list_empty(&ig.connlist);\n\tmutex_unlock(&ig.connlist_mutex);\n\n\tif (!connlist_empty) {\n\t\tiser_err(\"Error cleanup stage completed but we still have iser \"\n\t\t\t \"connections, destroying them anyway\\n\");\n\t\tlist_for_each_entry_safe(iser_conn, n, &ig.connlist,\n\t\t\t\t\t conn_list) {\n\t\t\tiser_conn_release(iser_conn);\n\t\t}\n\t}\n\n\tiscsi_unregister_transport(&iscsi_iser_transport);\n\tkmem_cache_destroy(ig.desc_cache);\n}\n\nmodule_init(iser_init);\nmodule_exit(iser_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}