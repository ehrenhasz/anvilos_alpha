{
  "module_name": "opa_vnic_internal.h",
  "hash_id": "421aacfbce7b45d973705e70dda2f1834aa85638d977d2e9a153da21ca5ba904",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/ulp/opa_vnic/opa_vnic_internal.h",
  "human_readable_source": "#ifndef _OPA_VNIC_INTERNAL_H\n#define _OPA_VNIC_INTERNAL_H\n \n\n \n\n#include <linux/bitops.h>\n#include <linux/etherdevice.h>\n#include <linux/hashtable.h>\n#include <linux/sizes.h>\n#include <rdma/opa_vnic.h>\n\n#include \"opa_vnic_encap.h\"\n\n#define OPA_VNIC_VLAN_PCP(vlan_tci)  \\\n\t\t\t(((vlan_tci) & VLAN_PRIO_MASK) >> VLAN_PRIO_SHIFT)\n\n \n#define OPA_VNIC_FLOW_TBL_SIZE    32\n\n \n#define OPA_VNIC_INVALID_PORT     0xff\n\nstruct opa_vnic_adapter;\n\n \nstruct __opa_vesw_info {\n\tu16  fabric_id;\n\tu16  vesw_id;\n\n\tu8   rsvd0[6];\n\tu16  def_port_mask;\n\n\tu8   rsvd1[2];\n\tu16  pkey;\n\n\tu8   rsvd2[4];\n\tu32  u_mcast_dlid;\n\tu32  u_ucast_dlid[OPA_VESW_MAX_NUM_DEF_PORT];\n\n\tu32  rc;\n\n\tu8   rsvd3[56];\n\tu16  eth_mtu;\n\tu8   rsvd4[2];\n} __packed;\n\n \nstruct __opa_per_veswport_info {\n\tu32  port_num;\n\n\tu8   eth_link_status;\n\tu8   rsvd0[3];\n\n\tu8   base_mac_addr[ETH_ALEN];\n\tu8   config_state;\n\tu8   oper_state;\n\n\tu16  max_mac_tbl_ent;\n\tu16  max_smac_ent;\n\tu32  mac_tbl_digest;\n\tu8   rsvd1[4];\n\n\tu32  encap_slid;\n\n\tu8   pcp_to_sc_uc[OPA_VNIC_MAX_NUM_PCP];\n\tu8   pcp_to_vl_uc[OPA_VNIC_MAX_NUM_PCP];\n\tu8   pcp_to_sc_mc[OPA_VNIC_MAX_NUM_PCP];\n\tu8   pcp_to_vl_mc[OPA_VNIC_MAX_NUM_PCP];\n\n\tu8   non_vlan_sc_uc;\n\tu8   non_vlan_vl_uc;\n\tu8   non_vlan_sc_mc;\n\tu8   non_vlan_vl_mc;\n\n\tu8   rsvd2[48];\n\n\tu16  uc_macs_gen_count;\n\tu16  mc_macs_gen_count;\n\n\tu8   rsvd3[8];\n} __packed;\n\n \nstruct __opa_veswport_info {\n\tstruct __opa_vesw_info            vesw;\n\tstruct __opa_per_veswport_info    vport;\n};\n\n \nstruct __opa_veswport_trap {\n\tu16\tfabric_id;\n\tu16\tveswid;\n\tu32\tveswportnum;\n\tu16\topaportnum;\n\tu8\tveswportindex;\n\tu8\topcode;\n\tu32\treserved;\n} __packed;\n\n \nstruct opa_vnic_ctrl_port {\n\tstruct ib_device           *ibdev;\n\tstruct opa_vnic_ctrl_ops   *ops;\n\tu8                          num_ports;\n};\n\n \nstruct opa_vnic_adapter {\n\tstruct net_device             *netdev;\n\tstruct ib_device              *ibdev;\n\tstruct opa_vnic_ctrl_port     *cport;\n\tconst struct net_device_ops   *rn_ops;\n\n\tu8 port_num;\n\tu8 vport_num;\n\n\t \n\tstruct mutex lock;\n\n\tstruct __opa_veswport_info  info;\n\tu8                          vema_mac_addr[ETH_ALEN];\n\tu32                         umac_hash;\n\tu32                         mmac_hash;\n\tstruct hlist_head  __rcu   *mactbl;\n\n\t \n\tstruct mutex mactbl_lock;\n\n\t \n\tspinlock_t stats_lock;\n\n\tu8 flow_tbl[OPA_VNIC_FLOW_TBL_SIZE];\n\n\tunsigned long trap_timeout;\n\tu8            trap_count;\n};\n\n \nstruct __opa_vnic_mactable_entry {\n\tu8  mac_addr[ETH_ALEN];\n\tu8  mac_addr_mask[ETH_ALEN];\n\tu32 dlid_sd;\n} __packed;\n\n \nstruct opa_vnic_mac_tbl_node {\n\tstruct hlist_node                    hlist;\n\tu16                                  index;\n\tstruct __opa_vnic_mactable_entry     entry;\n};\n\n#define v_dbg(format, arg...) \\\n\tnetdev_dbg(adapter->netdev, format, ## arg)\n#define v_err(format, arg...) \\\n\tnetdev_err(adapter->netdev, format, ## arg)\n#define v_info(format, arg...) \\\n\tnetdev_info(adapter->netdev, format, ## arg)\n#define v_warn(format, arg...) \\\n\tnetdev_warn(adapter->netdev, format, ## arg)\n\n#define c_err(format, arg...) \\\n\tdev_err(&cport->ibdev->dev, format, ## arg)\n#define c_info(format, arg...) \\\n\tdev_info(&cport->ibdev->dev, format, ## arg)\n#define c_dbg(format, arg...) \\\n\tdev_dbg(&cport->ibdev->dev, format, ## arg)\n\n \n#define OPA_VNIC_MAC_TBL_MAX_ENTRIES  2048\n \n#define OPA_VNIC_MAX_SMAC_LIMIT       256\n\n \n#define OPA_VNIC_MAC_HASH_IDX         5\n\n \n#define OPA_VNIC_MAC_TBL_HASH_BITS    8\n#define OPA_VNIC_MAC_TBL_SIZE  BIT(OPA_VNIC_MAC_TBL_HASH_BITS)\n\n \n#define vnic_hash_init(hashtable) __hash_init(hashtable, OPA_VNIC_MAC_TBL_SIZE)\n\n#define vnic_hash_add(hashtable, node, key)                                   \\\n\thlist_add_head(node,                                                  \\\n\t\t&hashtable[hash_min(key, ilog2(OPA_VNIC_MAC_TBL_SIZE))])\n\n#define vnic_hash_for_each_safe(name, bkt, tmp, obj, member)                  \\\n\tfor ((bkt) = 0, obj = NULL;                                           \\\n\t\t    !obj && (bkt) < OPA_VNIC_MAC_TBL_SIZE; (bkt)++)           \\\n\t\thlist_for_each_entry_safe(obj, tmp, &name[bkt], member)\n\n#define vnic_hash_for_each_possible(name, obj, member, key)                   \\\n\thlist_for_each_entry(obj,                                             \\\n\t\t&name[hash_min(key, ilog2(OPA_VNIC_MAC_TBL_SIZE))], member)\n\n#define vnic_hash_for_each(name, bkt, obj, member)                            \\\n\tfor ((bkt) = 0, obj = NULL;                                           \\\n\t\t    !obj && (bkt) < OPA_VNIC_MAC_TBL_SIZE; (bkt)++)           \\\n\t\thlist_for_each_entry(obj, &name[bkt], member)\n\nextern char opa_vnic_driver_name[];\n\nstruct opa_vnic_adapter *opa_vnic_add_netdev(struct ib_device *ibdev,\n\t\t\t\t\t     u8 port_num, u8 vport_num);\nvoid opa_vnic_rem_netdev(struct opa_vnic_adapter *adapter);\nvoid opa_vnic_encap_skb(struct opa_vnic_adapter *adapter, struct sk_buff *skb);\nu8 opa_vnic_get_vl(struct opa_vnic_adapter *adapter, struct sk_buff *skb);\nu8 opa_vnic_calc_entropy(struct sk_buff *skb);\nvoid opa_vnic_process_vema_config(struct opa_vnic_adapter *adapter);\nvoid opa_vnic_release_mac_tbl(struct opa_vnic_adapter *adapter);\nvoid opa_vnic_query_mac_tbl(struct opa_vnic_adapter *adapter,\n\t\t\t    struct opa_veswport_mactable *tbl);\nint opa_vnic_update_mac_tbl(struct opa_vnic_adapter *adapter,\n\t\t\t    struct opa_veswport_mactable *tbl);\nvoid opa_vnic_query_ucast_macs(struct opa_vnic_adapter *adapter,\n\t\t\t       struct opa_veswport_iface_macs *macs);\nvoid opa_vnic_query_mcast_macs(struct opa_vnic_adapter *adapter,\n\t\t\t       struct opa_veswport_iface_macs *macs);\nvoid opa_vnic_get_summary_counters(struct opa_vnic_adapter *adapter,\n\t\t\t\t   struct opa_veswport_summary_counters *cntrs);\nvoid opa_vnic_get_error_counters(struct opa_vnic_adapter *adapter,\n\t\t\t\t struct opa_veswport_error_counters *cntrs);\nvoid opa_vnic_get_vesw_info(struct opa_vnic_adapter *adapter,\n\t\t\t    struct opa_vesw_info *info);\nvoid opa_vnic_set_vesw_info(struct opa_vnic_adapter *adapter,\n\t\t\t    struct opa_vesw_info *info);\nvoid opa_vnic_get_per_veswport_info(struct opa_vnic_adapter *adapter,\n\t\t\t\t    struct opa_per_veswport_info *info);\nvoid opa_vnic_set_per_veswport_info(struct opa_vnic_adapter *adapter,\n\t\t\t\t    struct opa_per_veswport_info *info);\nvoid opa_vnic_vema_report_event(struct opa_vnic_adapter *adapter, u8 event);\nvoid opa_vnic_set_ethtool_ops(struct net_device *netdev);\nvoid opa_vnic_vema_send_trap(struct opa_vnic_adapter *adapter,\n\t\t\t     struct __opa_veswport_trap *data, u32 lid);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}