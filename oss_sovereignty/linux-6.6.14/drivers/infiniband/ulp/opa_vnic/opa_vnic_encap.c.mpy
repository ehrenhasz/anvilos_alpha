{
  "module_name": "opa_vnic_encap.c",
  "hash_id": "d0c2a5daf4a707dd814796039dc1e5e01d94cf440b589e2d68ef12d1c5a6f419",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/ulp/opa_vnic/opa_vnic_encap.c",
  "human_readable_source": " \n\n \n\n#include <linux/if_ether.h>\n#include <linux/if_vlan.h>\n\n#include \"opa_vnic_internal.h\"\n\n \n#define OPA_16B_LID_MASK        0xFFFFFull\n#define OPA_16B_SLID_HIGH_SHFT  8\n#define OPA_16B_SLID_MASK       0xF00ull\n#define OPA_16B_DLID_MASK       0xF000ull\n#define OPA_16B_DLID_HIGH_SHFT  12\n#define OPA_16B_LEN_SHFT        20\n#define OPA_16B_SC_SHFT         20\n#define OPA_16B_RC_SHFT         25\n#define OPA_16B_PKEY_SHFT       16\n\n#define OPA_VNIC_L4_HDR_SHFT    16\n\n \n#define OPA_VNIC_HDR_QW_LEN   5\n\nstatic inline void opa_vnic_make_header(u8 *hdr, u32 slid, u32 dlid, u16 len,\n\t\t\t\t\tu16 pkey, u16 entropy, u8 sc, u8 rc,\n\t\t\t\t\tu8 l4_type, u16 l4_hdr)\n{\n\t \n\tu32 h[OPA_VNIC_HDR_QW_LEN] = {0, 0xc0000000, 0, 0, 0};\n\n\th[2] = l4_type;\n\th[3] = entropy;\n\th[4] = l4_hdr << OPA_VNIC_L4_HDR_SHFT;\n\n\t \n\th[0] |= (slid & OPA_16B_LID_MASK);\n\th[2] |= ((slid >> (20 - OPA_16B_SLID_HIGH_SHFT)) & OPA_16B_SLID_MASK);\n\n\th[1] |= (dlid & OPA_16B_LID_MASK);\n\th[2] |= ((dlid >> (20 - OPA_16B_DLID_HIGH_SHFT)) & OPA_16B_DLID_MASK);\n\n\th[0] |= (len << OPA_16B_LEN_SHFT);\n\th[1] |= (rc << OPA_16B_RC_SHFT);\n\th[1] |= (sc << OPA_16B_SC_SHFT);\n\th[2] |= ((u32)pkey << OPA_16B_PKEY_SHFT);\n\n\tmemcpy(hdr, h, OPA_VNIC_HDR_LEN);\n}\n\n \nstatic void opa_vnic_free_mac_tbl(struct hlist_head *mactbl)\n{\n\tstruct opa_vnic_mac_tbl_node *node;\n\tstruct hlist_node *tmp;\n\tint bkt;\n\n\tif (!mactbl)\n\t\treturn;\n\n\tvnic_hash_for_each_safe(mactbl, bkt, tmp, node, hlist) {\n\t\thash_del(&node->hlist);\n\t\tkfree(node);\n\t}\n\tkfree(mactbl);\n}\n\nstatic struct hlist_head *opa_vnic_alloc_mac_tbl(void)\n{\n\tu32 size = sizeof(struct hlist_head) * OPA_VNIC_MAC_TBL_SIZE;\n\tstruct hlist_head *mactbl;\n\n\tmactbl = kzalloc(size, GFP_KERNEL);\n\tif (!mactbl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tvnic_hash_init(mactbl);\n\treturn mactbl;\n}\n\n \nvoid opa_vnic_release_mac_tbl(struct opa_vnic_adapter *adapter)\n{\n\tstruct hlist_head *mactbl;\n\n\tmutex_lock(&adapter->mactbl_lock);\n\tmactbl = rcu_access_pointer(adapter->mactbl);\n\trcu_assign_pointer(adapter->mactbl, NULL);\n\tsynchronize_rcu();\n\topa_vnic_free_mac_tbl(mactbl);\n\tadapter->info.vport.mac_tbl_digest = 0;\n\tmutex_unlock(&adapter->mactbl_lock);\n}\n\n \nvoid opa_vnic_query_mac_tbl(struct opa_vnic_adapter *adapter,\n\t\t\t    struct opa_veswport_mactable *tbl)\n{\n\tstruct opa_vnic_mac_tbl_node *node;\n\tstruct hlist_head *mactbl;\n\tint bkt;\n\tu16 loffset, lnum_entries;\n\n\trcu_read_lock();\n\tmactbl = rcu_dereference(adapter->mactbl);\n\tif (!mactbl)\n\t\tgoto get_mac_done;\n\n\tloffset = be16_to_cpu(tbl->offset);\n\tlnum_entries = be16_to_cpu(tbl->num_entries);\n\n\tvnic_hash_for_each(mactbl, bkt, node, hlist) {\n\t\tstruct __opa_vnic_mactable_entry *nentry = &node->entry;\n\t\tstruct opa_veswport_mactable_entry *entry;\n\n\t\tif ((node->index < loffset) ||\n\t\t    (node->index >= (loffset + lnum_entries)))\n\t\t\tcontinue;\n\n\t\t \n\t\tentry = &tbl->tbl_entries[node->index - loffset];\n\t\tmemcpy(entry->mac_addr, nentry->mac_addr,\n\t\t       ARRAY_SIZE(entry->mac_addr));\n\t\tmemcpy(entry->mac_addr_mask, nentry->mac_addr_mask,\n\t\t       ARRAY_SIZE(entry->mac_addr_mask));\n\t\tentry->dlid_sd = cpu_to_be32(nentry->dlid_sd);\n\t}\n\ttbl->mac_tbl_digest = cpu_to_be32(adapter->info.vport.mac_tbl_digest);\nget_mac_done:\n\trcu_read_unlock();\n}\n\n \nint opa_vnic_update_mac_tbl(struct opa_vnic_adapter *adapter,\n\t\t\t    struct opa_veswport_mactable *tbl)\n{\n\tstruct opa_vnic_mac_tbl_node *node, *new_node;\n\tstruct hlist_head *new_mactbl, *old_mactbl;\n\tint i, bkt, rc = 0;\n\tu8 key;\n\tu16 loffset, lnum_entries;\n\n\tmutex_lock(&adapter->mactbl_lock);\n\t \n\tnew_mactbl = opa_vnic_alloc_mac_tbl();\n\tif (IS_ERR(new_mactbl)) {\n\t\tmutex_unlock(&adapter->mactbl_lock);\n\t\treturn PTR_ERR(new_mactbl);\n\t}\n\n\tloffset = be16_to_cpu(tbl->offset);\n\tlnum_entries = be16_to_cpu(tbl->num_entries);\n\n\t \n\tfor (i = 0; i < lnum_entries; i++) {\n\t\tstruct __opa_vnic_mactable_entry *nentry;\n\t\tstruct opa_veswport_mactable_entry *entry =\n\t\t\t\t\t\t\t&tbl->tbl_entries[i];\n\t\tu8 *mac_addr = entry->mac_addr;\n\t\tu8 empty_mac[ETH_ALEN] = { 0 };\n\n\t\tv_dbg(\"new mac entry %4d: %02x:%02x:%02x:%02x:%02x:%02x %x\\n\",\n\t\t      loffset + i, mac_addr[0], mac_addr[1], mac_addr[2],\n\t\t      mac_addr[3], mac_addr[4], mac_addr[5],\n\t\t      entry->dlid_sd);\n\n\t\t \n\t\tif (!memcmp(mac_addr, empty_mac, ARRAY_SIZE(empty_mac)))\n\t\t\tcontinue;\n\n\t\tnode = kzalloc(sizeof(*node), GFP_KERNEL);\n\t\tif (!node) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto updt_done;\n\t\t}\n\n\t\tnode->index = loffset + i;\n\t\tnentry = &node->entry;\n\t\tmemcpy(nentry->mac_addr, entry->mac_addr,\n\t\t       ARRAY_SIZE(nentry->mac_addr));\n\t\tmemcpy(nentry->mac_addr_mask, entry->mac_addr_mask,\n\t\t       ARRAY_SIZE(nentry->mac_addr_mask));\n\t\tnentry->dlid_sd = be32_to_cpu(entry->dlid_sd);\n\t\tkey = node->entry.mac_addr[OPA_VNIC_MAC_HASH_IDX];\n\t\tvnic_hash_add(new_mactbl, &node->hlist, key);\n\t}\n\n\t \n\told_mactbl = rcu_access_pointer(adapter->mactbl);\n\tif (!old_mactbl)\n\t\tgoto switch_tbl;\n\n\tvnic_hash_for_each(old_mactbl, bkt, node, hlist) {\n\t\tif ((node->index >= loffset) &&\n\t\t    (node->index < (loffset + lnum_entries)))\n\t\t\tcontinue;\n\n\t\tnew_node = kzalloc(sizeof(*new_node), GFP_KERNEL);\n\t\tif (!new_node) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto updt_done;\n\t\t}\n\n\t\tnew_node->index = node->index;\n\t\tmemcpy(&new_node->entry, &node->entry, sizeof(node->entry));\n\t\tkey = new_node->entry.mac_addr[OPA_VNIC_MAC_HASH_IDX];\n\t\tvnic_hash_add(new_mactbl, &new_node->hlist, key);\n\t}\n\nswitch_tbl:\n\t \n\trcu_assign_pointer(adapter->mactbl, new_mactbl);\n\tsynchronize_rcu();\n\n\tadapter->info.vport.mac_tbl_digest = be32_to_cpu(tbl->mac_tbl_digest);\nupdt_done:\n\t \n\tif (rc)\n\t\topa_vnic_free_mac_tbl(new_mactbl);\n\telse\n\t\topa_vnic_free_mac_tbl(old_mactbl);\n\n\tmutex_unlock(&adapter->mactbl_lock);\n\treturn rc;\n}\n\n \nstatic uint32_t opa_vnic_chk_mac_tbl(struct opa_vnic_adapter *adapter,\n\t\t\t\t     struct ethhdr *mac_hdr)\n{\n\tstruct opa_vnic_mac_tbl_node *node;\n\tstruct hlist_head *mactbl;\n\tu32 dlid = 0;\n\tu8 key;\n\n\trcu_read_lock();\n\tmactbl = rcu_dereference(adapter->mactbl);\n\tif (unlikely(!mactbl))\n\t\tgoto chk_done;\n\n\tkey = mac_hdr->h_dest[OPA_VNIC_MAC_HASH_IDX];\n\tvnic_hash_for_each_possible(mactbl, node, hlist, key) {\n\t\tstruct __opa_vnic_mactable_entry *entry = &node->entry;\n\n\t\t \n\t\tif (unlikely(OPA_VNIC_DLID_SD_IS_SRC_MAC(entry->dlid_sd)))\n\t\t\tcontinue;\n\n\t\tif (!memcmp(node->entry.mac_addr, mac_hdr->h_dest,\n\t\t\t    ARRAY_SIZE(node->entry.mac_addr))) {\n\t\t\t \n\t\t\tdlid = OPA_VNIC_DLID_SD_GET_DLID(node->entry.dlid_sd);\n\t\t\tbreak;\n\t\t}\n\t}\n\nchk_done:\n\trcu_read_unlock();\n\treturn dlid;\n}\n\n \nstatic uint32_t opa_vnic_get_dlid(struct opa_vnic_adapter *adapter,\n\t\t\t\t  struct sk_buff *skb, u8 def_port)\n{\n\tstruct __opa_veswport_info *info = &adapter->info;\n\tstruct ethhdr *mac_hdr = (struct ethhdr *)skb_mac_header(skb);\n\tu32 dlid;\n\n\tdlid = opa_vnic_chk_mac_tbl(adapter, mac_hdr);\n\tif (dlid)\n\t\treturn dlid;\n\n\tif (is_multicast_ether_addr(mac_hdr->h_dest)) {\n\t\tdlid = info->vesw.u_mcast_dlid;\n\t} else {\n\t\tif (is_local_ether_addr(mac_hdr->h_dest)) {\n\t\t\tdlid = ((uint32_t)mac_hdr->h_dest[5] << 16) |\n\t\t\t\t((uint32_t)mac_hdr->h_dest[4] << 8)  |\n\t\t\t\tmac_hdr->h_dest[3];\n\t\t\tif (unlikely(!dlid))\n\t\t\t\tv_warn(\"Null dlid in MAC address\\n\");\n\t\t} else if (def_port != OPA_VNIC_INVALID_PORT) {\n\t\t\tif (def_port < OPA_VESW_MAX_NUM_DEF_PORT)\n\t\t\t\tdlid = info->vesw.u_ucast_dlid[def_port];\n\t\t}\n\t}\n\n\treturn dlid;\n}\n\n \nstatic u8 opa_vnic_get_sc(struct __opa_veswport_info *info,\n\t\t\t  struct sk_buff *skb)\n{\n\tstruct ethhdr *mac_hdr = (struct ethhdr *)skb_mac_header(skb);\n\tu16 vlan_tci;\n\tu8 sc;\n\n\tif (!__vlan_get_tag(skb, &vlan_tci)) {\n\t\tu8 pcp = OPA_VNIC_VLAN_PCP(vlan_tci);\n\n\t\tif (is_multicast_ether_addr(mac_hdr->h_dest))\n\t\t\tsc = info->vport.pcp_to_sc_mc[pcp];\n\t\telse\n\t\t\tsc = info->vport.pcp_to_sc_uc[pcp];\n\t} else {\n\t\tif (is_multicast_ether_addr(mac_hdr->h_dest))\n\t\t\tsc = info->vport.non_vlan_sc_mc;\n\t\telse\n\t\t\tsc = info->vport.non_vlan_sc_uc;\n\t}\n\n\treturn sc;\n}\n\nu8 opa_vnic_get_vl(struct opa_vnic_adapter *adapter, struct sk_buff *skb)\n{\n\tstruct ethhdr *mac_hdr = (struct ethhdr *)skb_mac_header(skb);\n\tstruct __opa_veswport_info *info = &adapter->info;\n\tu8 vl;\n\n\tif (skb_vlan_tag_present(skb)) {\n\t\tu8 pcp = skb_vlan_tag_get(skb) >> VLAN_PRIO_SHIFT;\n\n\t\tif (is_multicast_ether_addr(mac_hdr->h_dest))\n\t\t\tvl = info->vport.pcp_to_vl_mc[pcp];\n\t\telse\n\t\t\tvl = info->vport.pcp_to_vl_uc[pcp];\n\t} else {\n\t\tif (is_multicast_ether_addr(mac_hdr->h_dest))\n\t\t\tvl = info->vport.non_vlan_vl_mc;\n\t\telse\n\t\t\tvl = info->vport.non_vlan_vl_uc;\n\t}\n\n\treturn vl;\n}\n\n \nstatic u8 opa_vnic_get_rc(struct __opa_veswport_info *info,\n\t\t\t  struct sk_buff *skb)\n{\n\tu8 proto, rout_ctrl;\n\n\tswitch (vlan_get_protocol(skb)) {\n\tcase htons(ETH_P_IPV6):\n\t\tproto = ipv6_hdr(skb)->nexthdr;\n\t\tif (proto == IPPROTO_TCP)\n\t\t\trout_ctrl = OPA_VNIC_ENCAP_RC_EXT(info->vesw.rc,\n\t\t\t\t\t\t\t  IPV6_TCP);\n\t\telse if (proto == IPPROTO_UDP)\n\t\t\trout_ctrl = OPA_VNIC_ENCAP_RC_EXT(info->vesw.rc,\n\t\t\t\t\t\t\t  IPV6_UDP);\n\t\telse\n\t\t\trout_ctrl = OPA_VNIC_ENCAP_RC_EXT(info->vesw.rc, IPV6);\n\t\tbreak;\n\tcase htons(ETH_P_IP):\n\t\tproto = ip_hdr(skb)->protocol;\n\t\tif (proto == IPPROTO_TCP)\n\t\t\trout_ctrl = OPA_VNIC_ENCAP_RC_EXT(info->vesw.rc,\n\t\t\t\t\t\t\t  IPV4_TCP);\n\t\telse if (proto == IPPROTO_UDP)\n\t\t\trout_ctrl = OPA_VNIC_ENCAP_RC_EXT(info->vesw.rc,\n\t\t\t\t\t\t\t  IPV4_UDP);\n\t\telse\n\t\t\trout_ctrl = OPA_VNIC_ENCAP_RC_EXT(info->vesw.rc, IPV4);\n\t\tbreak;\n\tdefault:\n\t\trout_ctrl = OPA_VNIC_ENCAP_RC_EXT(info->vesw.rc, DEFAULT);\n\t}\n\n\treturn rout_ctrl;\n}\n\n \nu8 opa_vnic_calc_entropy(struct sk_buff *skb)\n{\n\tu32 hash = skb_get_hash(skb);\n\n\t \n\thash ^= hash >> 8;\n\thash ^= hash >> 16;\n\n\t \n\treturn (u8)(hash & 0xFF);\n}\n\n \nstatic inline u8 opa_vnic_get_def_port(struct opa_vnic_adapter *adapter,\n\t\t\t\t       u8 entropy)\n{\n\tu8 flow_id;\n\n\t \n\tflow_id = ((entropy & 0xf) + (entropy >> 4));\n\treturn adapter->flow_tbl[flow_id & (OPA_VNIC_FLOW_TBL_SIZE - 1)];\n}\n\n \nstatic inline int opa_vnic_wire_length(struct sk_buff *skb)\n{\n\tu32 pad_len;\n\n\t \n\tpad_len = -(skb->len + OPA_VNIC_ICRC_TAIL_LEN) & 0x7;\n\tpad_len += OPA_VNIC_ICRC_TAIL_LEN;\n\n\treturn (skb->len + pad_len) >> 3;\n}\n\n \nvoid opa_vnic_encap_skb(struct opa_vnic_adapter *adapter, struct sk_buff *skb)\n{\n\tstruct __opa_veswport_info *info = &adapter->info;\n\tstruct opa_vnic_skb_mdata *mdata;\n\tu8 def_port, sc, rc, entropy, *hdr;\n\tu16 len, l4_hdr;\n\tu32 dlid;\n\n\thdr = skb_push(skb, OPA_VNIC_HDR_LEN);\n\n\tentropy = opa_vnic_calc_entropy(skb);\n\tdef_port = opa_vnic_get_def_port(adapter, entropy);\n\tlen = opa_vnic_wire_length(skb);\n\tdlid = opa_vnic_get_dlid(adapter, skb, def_port);\n\tsc = opa_vnic_get_sc(info, skb);\n\trc = opa_vnic_get_rc(info, skb);\n\tl4_hdr = info->vesw.vesw_id;\n\n\tmdata = skb_push(skb, sizeof(*mdata));\n\tmdata->vl = opa_vnic_get_vl(adapter, skb);\n\tmdata->entropy = entropy;\n\tmdata->flags = 0;\n\tif (unlikely(!dlid)) {\n\t\tmdata->flags = OPA_VNIC_SKB_MDATA_ENCAP_ERR;\n\t\treturn;\n\t}\n\n\topa_vnic_make_header(hdr, info->vport.encap_slid, dlid, len,\n\t\t\t     info->vesw.pkey, entropy, sc, rc,\n\t\t\t     OPA_VNIC_L4_ETHR, l4_hdr);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}