{
  "module_name": "opa_vnic_netdev.c",
  "hash_id": "04bd8170d36e480fe1483f2a1d88b0a5c7827d05b08ba6d81c17935a2e90638a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/ulp/opa_vnic/opa_vnic_netdev.c",
  "human_readable_source": " \n\n \n\n#include <linux/if_vlan.h>\n#include <linux/crc32.h>\n\n#include \"opa_vnic_internal.h\"\n\n#define OPA_TX_TIMEOUT_MS 1000\n\n#define OPA_VNIC_SKB_HEADROOM  \\\n\t\t\tALIGN((OPA_VNIC_HDR_LEN + OPA_VNIC_SKB_MDATA_LEN), 8)\n\n \nstatic void opa_vnic_get_stats64(struct net_device *netdev,\n\t\t\t\t struct rtnl_link_stats64 *stats)\n{\n\tstruct opa_vnic_adapter *adapter = opa_vnic_priv(netdev);\n\tstruct opa_vnic_stats vstats;\n\n\tmemset(&vstats, 0, sizeof(vstats));\n\tspin_lock(&adapter->stats_lock);\n\tadapter->rn_ops->ndo_get_stats64(netdev, &vstats.netstats);\n\tspin_unlock(&adapter->stats_lock);\n\tmemcpy(stats, &vstats.netstats, sizeof(*stats));\n}\n\n \nstatic netdev_tx_t opa_netdev_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t struct net_device *netdev)\n{\n\tstruct opa_vnic_adapter *adapter = opa_vnic_priv(netdev);\n\n\tv_dbg(\"xmit: queue %d skb len %d\\n\", skb->queue_mapping, skb->len);\n\t \n\tif (unlikely(skb->len < ETH_ZLEN)) {\n\t\tif (skb_padto(skb, ETH_ZLEN))\n\t\t\treturn NETDEV_TX_OK;\n\n\t\tskb_put(skb, ETH_ZLEN - skb->len);\n\t}\n\n\topa_vnic_encap_skb(adapter, skb);\n\treturn adapter->rn_ops->ndo_start_xmit(skb, netdev);\n}\n\nstatic u16 opa_vnic_select_queue(struct net_device *netdev, struct sk_buff *skb,\n\t\t\t\t struct net_device *sb_dev)\n{\n\tstruct opa_vnic_adapter *adapter = opa_vnic_priv(netdev);\n\tstruct opa_vnic_skb_mdata *mdata;\n\tint rc;\n\n\t \n\tmdata = skb_push(skb, sizeof(*mdata));\n\tmdata->entropy = opa_vnic_calc_entropy(skb);\n\tmdata->vl = opa_vnic_get_vl(adapter, skb);\n\trc = adapter->rn_ops->ndo_select_queue(netdev, skb, sb_dev);\n\tskb_pull(skb, sizeof(*mdata));\n\treturn rc;\n}\n\nstatic void opa_vnic_update_state(struct opa_vnic_adapter *adapter, bool up)\n{\n\tstruct __opa_veswport_info *info = &adapter->info;\n\n\tmutex_lock(&adapter->lock);\n\t \n\tif ((info->vport.config_state == OPA_VNIC_STATE_FORWARDING) && up) {\n\t\tinfo->vport.oper_state = OPA_VNIC_STATE_FORWARDING;\n\t\tinfo->vport.eth_link_status = OPA_VNIC_ETH_LINK_UP;\n\t} else {\n\t\tinfo->vport.oper_state = OPA_VNIC_STATE_DROP_ALL;\n\t\tinfo->vport.eth_link_status = OPA_VNIC_ETH_LINK_DOWN;\n\t}\n\n\tif (info->vport.config_state == OPA_VNIC_STATE_FORWARDING)\n\t\tnetif_dormant_off(adapter->netdev);\n\telse\n\t\tnetif_dormant_on(adapter->netdev);\n\tmutex_unlock(&adapter->lock);\n}\n\n \nvoid opa_vnic_process_vema_config(struct opa_vnic_adapter *adapter)\n{\n\tstruct __opa_veswport_info *info = &adapter->info;\n\tstruct rdma_netdev *rn = netdev_priv(adapter->netdev);\n\tu8 port_num[OPA_VESW_MAX_NUM_DEF_PORT] = { 0 };\n\tstruct net_device *netdev = adapter->netdev;\n\tu8 i, port_count = 0;\n\tu16 port_mask;\n\n\t \n\tif (memcmp(info->vport.base_mac_addr, adapter->vema_mac_addr,\n\t\t   ARRAY_SIZE(info->vport.base_mac_addr))) {\n\t\tstruct sockaddr saddr;\n\n\t\tmemcpy(saddr.sa_data, info->vport.base_mac_addr,\n\t\t       ARRAY_SIZE(info->vport.base_mac_addr));\n\t\tmutex_lock(&adapter->lock);\n\t\teth_commit_mac_addr_change(netdev, &saddr);\n\t\tmemcpy(adapter->vema_mac_addr,\n\t\t       info->vport.base_mac_addr, ETH_ALEN);\n\t\tmutex_unlock(&adapter->lock);\n\t}\n\n\trn->set_id(netdev, info->vesw.vesw_id);\n\n\t \n\trtnl_lock();\n\tnetdev->max_mtu = max_t(unsigned int, info->vesw.eth_mtu,\n\t\t\t\tnetdev->min_mtu);\n\tif (netdev->mtu > netdev->max_mtu)\n\t\tdev_set_mtu(netdev, netdev->max_mtu);\n\trtnl_unlock();\n\n\t \n\tport_mask = info->vesw.def_port_mask;\n\tfor (i = 0; i < OPA_VESW_MAX_NUM_DEF_PORT; i++) {\n\t\tif (port_mask & 1)\n\t\t\tport_num[port_count++] = i;\n\t\tport_mask >>= 1;\n\t}\n\n\t \n\tfor (i = 0; i < OPA_VNIC_FLOW_TBL_SIZE; i++)\n\t\tadapter->flow_tbl[i] = port_count ? port_num[i % port_count] :\n\t\t\t\t\t\t    OPA_VNIC_INVALID_PORT;\n\n\t \n\topa_vnic_update_state(adapter, !!(netdev->flags & IFF_UP));\n}\n\n \nstatic inline void opa_vnic_set_pod_values(struct opa_vnic_adapter *adapter)\n{\n\tadapter->info.vport.max_mac_tbl_ent = OPA_VNIC_MAC_TBL_MAX_ENTRIES;\n\tadapter->info.vport.max_smac_ent = OPA_VNIC_MAX_SMAC_LIMIT;\n\tadapter->info.vport.config_state = OPA_VNIC_STATE_DROP_ALL;\n\tadapter->info.vport.eth_link_status = OPA_VNIC_ETH_LINK_DOWN;\n\tadapter->info.vesw.eth_mtu = ETH_DATA_LEN;\n}\n\n \nstatic int opa_vnic_set_mac_addr(struct net_device *netdev, void *addr)\n{\n\tstruct opa_vnic_adapter *adapter = opa_vnic_priv(netdev);\n\tstruct sockaddr *sa = addr;\n\tint rc;\n\n\tif (!memcmp(netdev->dev_addr, sa->sa_data, ETH_ALEN))\n\t\treturn 0;\n\n\tmutex_lock(&adapter->lock);\n\trc = eth_mac_addr(netdev, addr);\n\tmutex_unlock(&adapter->lock);\n\tif (rc)\n\t\treturn rc;\n\n\tadapter->info.vport.uc_macs_gen_count++;\n\topa_vnic_vema_report_event(adapter,\n\t\t\t\t   OPA_VESWPORT_TRAP_IFACE_UCAST_MAC_CHANGE);\n\treturn 0;\n}\n\n \nstatic void opa_vnic_mac_send_event(struct net_device *netdev, u8 event)\n{\n\tstruct opa_vnic_adapter *adapter = opa_vnic_priv(netdev);\n\tstruct netdev_hw_addr *ha;\n\tstruct netdev_hw_addr_list *hw_list;\n\tu32 *ref_crc;\n\tu32 l, crc = 0;\n\n\tswitch (event) {\n\tcase OPA_VESWPORT_TRAP_IFACE_UCAST_MAC_CHANGE:\n\t\thw_list = &netdev->uc;\n\t\tadapter->info.vport.uc_macs_gen_count++;\n\t\tref_crc = &adapter->umac_hash;\n\t\tbreak;\n\tcase OPA_VESWPORT_TRAP_IFACE_MCAST_MAC_CHANGE:\n\t\thw_list = &netdev->mc;\n\t\tadapter->info.vport.mc_macs_gen_count++;\n\t\tref_crc = &adapter->mmac_hash;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\tnetdev_hw_addr_list_for_each(ha, hw_list) {\n\t\tcrc = crc32_le(crc, ha->addr, ETH_ALEN);\n\t}\n\tl = netdev_hw_addr_list_count(hw_list) * ETH_ALEN;\n\tcrc = ~crc32_le(crc, (void *)&l, sizeof(l));\n\n\tif (crc != *ref_crc) {\n\t\t*ref_crc = crc;\n\t\topa_vnic_vema_report_event(adapter, event);\n\t}\n}\n\n \nstatic void opa_vnic_set_rx_mode(struct net_device *netdev)\n{\n\topa_vnic_mac_send_event(netdev,\n\t\t\t\tOPA_VESWPORT_TRAP_IFACE_UCAST_MAC_CHANGE);\n\n\topa_vnic_mac_send_event(netdev,\n\t\t\t\tOPA_VESWPORT_TRAP_IFACE_MCAST_MAC_CHANGE);\n}\n\n \nstatic int opa_netdev_open(struct net_device *netdev)\n{\n\tstruct opa_vnic_adapter *adapter = opa_vnic_priv(netdev);\n\tint rc;\n\n\trc = adapter->rn_ops->ndo_open(adapter->netdev);\n\tif (rc) {\n\t\tv_dbg(\"open failed %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\t \n\topa_vnic_update_state(adapter, true);\n\topa_vnic_vema_report_event(adapter,\n\t\t\t\t   OPA_VESWPORT_TRAP_ETH_LINK_STATUS_CHANGE);\n\treturn 0;\n}\n\n \nstatic int opa_netdev_close(struct net_device *netdev)\n{\n\tstruct opa_vnic_adapter *adapter = opa_vnic_priv(netdev);\n\tint rc;\n\n\trc = adapter->rn_ops->ndo_stop(adapter->netdev);\n\tif (rc) {\n\t\tv_dbg(\"close failed %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\t \n\topa_vnic_update_state(adapter, false);\n\topa_vnic_vema_report_event(adapter,\n\t\t\t\t   OPA_VESWPORT_TRAP_ETH_LINK_STATUS_CHANGE);\n\treturn 0;\n}\n\n \nstatic const struct net_device_ops opa_netdev_ops = {\n\t.ndo_open = opa_netdev_open,\n\t.ndo_stop = opa_netdev_close,\n\t.ndo_start_xmit = opa_netdev_start_xmit,\n\t.ndo_get_stats64 = opa_vnic_get_stats64,\n\t.ndo_set_rx_mode = opa_vnic_set_rx_mode,\n\t.ndo_select_queue = opa_vnic_select_queue,\n\t.ndo_set_mac_address = opa_vnic_set_mac_addr,\n};\n\n \nstruct opa_vnic_adapter *opa_vnic_add_netdev(struct ib_device *ibdev,\n\t\t\t\t\t     u8 port_num, u8 vport_num)\n{\n\tstruct opa_vnic_adapter *adapter;\n\tstruct net_device *netdev;\n\tstruct rdma_netdev *rn;\n\tint rc;\n\n\tnetdev = ibdev->ops.alloc_rdma_netdev(ibdev, port_num,\n\t\t\t\t\t      RDMA_NETDEV_OPA_VNIC,\n\t\t\t\t\t      \"veth%d\", NET_NAME_UNKNOWN,\n\t\t\t\t\t      ether_setup);\n\tif (!netdev)\n\t\treturn ERR_PTR(-ENOMEM);\n\telse if (IS_ERR(netdev))\n\t\treturn ERR_CAST(netdev);\n\n\trn = netdev_priv(netdev);\n\tadapter = kzalloc(sizeof(*adapter), GFP_KERNEL);\n\tif (!adapter) {\n\t\trc = -ENOMEM;\n\t\tgoto adapter_err;\n\t}\n\n\trn->clnt_priv = adapter;\n\trn->hca = ibdev;\n\trn->port_num = port_num;\n\tadapter->netdev = netdev;\n\tadapter->ibdev = ibdev;\n\tadapter->port_num = port_num;\n\tadapter->vport_num = vport_num;\n\tadapter->rn_ops = netdev->netdev_ops;\n\n\tnetdev->netdev_ops = &opa_netdev_ops;\n\tnetdev->priv_flags |= IFF_LIVE_ADDR_CHANGE;\n\tnetdev->hard_header_len += OPA_VNIC_SKB_HEADROOM;\n\tmutex_init(&adapter->lock);\n\tmutex_init(&adapter->mactbl_lock);\n\tspin_lock_init(&adapter->stats_lock);\n\n\tSET_NETDEV_DEV(netdev, ibdev->dev.parent);\n\n\topa_vnic_set_ethtool_ops(netdev);\n\n\topa_vnic_set_pod_values(adapter);\n\n\trc = register_netdev(netdev);\n\tif (rc)\n\t\tgoto netdev_err;\n\n\tnetif_carrier_off(netdev);\n\tnetif_dormant_on(netdev);\n\tv_info(\"initialized\\n\");\n\n\treturn adapter;\nnetdev_err:\n\tmutex_destroy(&adapter->lock);\n\tmutex_destroy(&adapter->mactbl_lock);\n\tkfree(adapter);\nadapter_err:\n\trn->free_rdma_netdev(netdev);\n\n\treturn ERR_PTR(rc);\n}\n\n \nvoid opa_vnic_rem_netdev(struct opa_vnic_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct rdma_netdev *rn = netdev_priv(netdev);\n\n\tv_info(\"removing\\n\");\n\tunregister_netdev(netdev);\n\topa_vnic_release_mac_tbl(adapter);\n\tmutex_destroy(&adapter->lock);\n\tmutex_destroy(&adapter->mactbl_lock);\n\tkfree(adapter);\n\trn->free_rdma_netdev(netdev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}