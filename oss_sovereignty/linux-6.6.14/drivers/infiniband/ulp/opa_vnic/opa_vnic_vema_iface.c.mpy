{
  "module_name": "opa_vnic_vema_iface.c",
  "hash_id": "78138d51e1f8e06935d7b40bf743618d4c1d845e208338b0f4b72a425065732c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/ulp/opa_vnic/opa_vnic_vema_iface.c",
  "human_readable_source": " \n\n \n\n#include \"opa_vnic_internal.h\"\n\n \nvoid opa_vnic_vema_report_event(struct opa_vnic_adapter *adapter, u8 event)\n{\n\tstruct __opa_veswport_info *info = &adapter->info;\n\tstruct __opa_veswport_trap trap_data;\n\n\ttrap_data.fabric_id = info->vesw.fabric_id;\n\ttrap_data.veswid = info->vesw.vesw_id;\n\ttrap_data.veswportnum = info->vport.port_num;\n\ttrap_data.opaportnum = adapter->port_num;\n\ttrap_data.veswportindex = adapter->vport_num;\n\ttrap_data.opcode = event;\n\n\topa_vnic_vema_send_trap(adapter, &trap_data, info->vport.encap_slid);\n}\n\n \nvoid opa_vnic_get_summary_counters(struct opa_vnic_adapter *adapter,\n\t\t\t\t   struct opa_veswport_summary_counters *cntrs)\n{\n\tstruct opa_vnic_stats vstats;\n\t__be64 *dst;\n\tu64 *src;\n\n\tmemset(&vstats, 0, sizeof(vstats));\n\tspin_lock(&adapter->stats_lock);\n\tadapter->rn_ops->ndo_get_stats64(adapter->netdev, &vstats.netstats);\n\tspin_unlock(&adapter->stats_lock);\n\n\tcntrs->vp_instance = cpu_to_be16(adapter->vport_num);\n\tcntrs->vesw_id = cpu_to_be16(adapter->info.vesw.vesw_id);\n\tcntrs->veswport_num = cpu_to_be32(adapter->port_num);\n\n\tcntrs->tx_errors = cpu_to_be64(vstats.netstats.tx_errors);\n\tcntrs->rx_errors = cpu_to_be64(vstats.netstats.rx_errors);\n\tcntrs->tx_packets = cpu_to_be64(vstats.netstats.tx_packets);\n\tcntrs->rx_packets = cpu_to_be64(vstats.netstats.rx_packets);\n\tcntrs->tx_bytes = cpu_to_be64(vstats.netstats.tx_bytes);\n\tcntrs->rx_bytes = cpu_to_be64(vstats.netstats.rx_bytes);\n\n\t \n\tfor (dst = &cntrs->tx_unicast, src = &vstats.tx_grp.unicast;\n\t     dst < &cntrs->reserved[0]; dst++, src++) {\n\t\t*dst = cpu_to_be64(*src);\n\t}\n}\n\n \nvoid opa_vnic_get_error_counters(struct opa_vnic_adapter *adapter,\n\t\t\t\t struct opa_veswport_error_counters *cntrs)\n{\n\tstruct opa_vnic_stats vstats;\n\n\tmemset(&vstats, 0, sizeof(vstats));\n\tspin_lock(&adapter->stats_lock);\n\tadapter->rn_ops->ndo_get_stats64(adapter->netdev, &vstats.netstats);\n\tspin_unlock(&adapter->stats_lock);\n\n\tcntrs->vp_instance = cpu_to_be16(adapter->vport_num);\n\tcntrs->vesw_id = cpu_to_be16(adapter->info.vesw.vesw_id);\n\tcntrs->veswport_num = cpu_to_be32(adapter->port_num);\n\n\tcntrs->tx_errors = cpu_to_be64(vstats.netstats.tx_errors);\n\tcntrs->rx_errors = cpu_to_be64(vstats.netstats.rx_errors);\n\tcntrs->tx_dlid_zero = cpu_to_be64(vstats.tx_dlid_zero);\n\tcntrs->tx_drop_state = cpu_to_be64(vstats.tx_drop_state);\n\tcntrs->tx_logic = cpu_to_be64(vstats.netstats.tx_fifo_errors +\n\t\t\t\t      vstats.netstats.tx_carrier_errors);\n\n\tcntrs->rx_bad_veswid = cpu_to_be64(vstats.netstats.rx_nohandler);\n\tcntrs->rx_runt = cpu_to_be64(vstats.rx_runt);\n\tcntrs->rx_oversize = cpu_to_be64(vstats.rx_oversize);\n\tcntrs->rx_drop_state = cpu_to_be64(vstats.rx_drop_state);\n\tcntrs->rx_logic = cpu_to_be64(vstats.netstats.rx_fifo_errors);\n}\n\n \nvoid opa_vnic_get_vesw_info(struct opa_vnic_adapter *adapter,\n\t\t\t    struct opa_vesw_info *info)\n{\n\tstruct __opa_vesw_info *src = &adapter->info.vesw;\n\tint i;\n\n\tinfo->fabric_id = cpu_to_be16(src->fabric_id);\n\tinfo->vesw_id = cpu_to_be16(src->vesw_id);\n\tmemcpy(info->rsvd0, src->rsvd0, ARRAY_SIZE(src->rsvd0));\n\tinfo->def_port_mask = cpu_to_be16(src->def_port_mask);\n\tmemcpy(info->rsvd1, src->rsvd1, ARRAY_SIZE(src->rsvd1));\n\tinfo->pkey = cpu_to_be16(src->pkey);\n\n\tmemcpy(info->rsvd2, src->rsvd2, ARRAY_SIZE(src->rsvd2));\n\tinfo->u_mcast_dlid = cpu_to_be32(src->u_mcast_dlid);\n\tfor (i = 0; i < OPA_VESW_MAX_NUM_DEF_PORT; i++)\n\t\tinfo->u_ucast_dlid[i] = cpu_to_be32(src->u_ucast_dlid[i]);\n\n\tinfo->rc = cpu_to_be32(src->rc);\n\n\tmemcpy(info->rsvd3, src->rsvd3, ARRAY_SIZE(src->rsvd3));\n\tinfo->eth_mtu = cpu_to_be16(src->eth_mtu);\n\tmemcpy(info->rsvd4, src->rsvd4, ARRAY_SIZE(src->rsvd4));\n}\n\n \nvoid opa_vnic_set_vesw_info(struct opa_vnic_adapter *adapter,\n\t\t\t    struct opa_vesw_info *info)\n{\n\tstruct __opa_vesw_info *dst = &adapter->info.vesw;\n\tint i;\n\n\tdst->fabric_id = be16_to_cpu(info->fabric_id);\n\tdst->vesw_id = be16_to_cpu(info->vesw_id);\n\tmemcpy(dst->rsvd0, info->rsvd0, ARRAY_SIZE(info->rsvd0));\n\tdst->def_port_mask = be16_to_cpu(info->def_port_mask);\n\tmemcpy(dst->rsvd1, info->rsvd1, ARRAY_SIZE(info->rsvd1));\n\tdst->pkey = be16_to_cpu(info->pkey);\n\n\tmemcpy(dst->rsvd2, info->rsvd2, ARRAY_SIZE(info->rsvd2));\n\tdst->u_mcast_dlid = be32_to_cpu(info->u_mcast_dlid);\n\tfor (i = 0; i < OPA_VESW_MAX_NUM_DEF_PORT; i++)\n\t\tdst->u_ucast_dlid[i] = be32_to_cpu(info->u_ucast_dlid[i]);\n\n\tdst->rc = be32_to_cpu(info->rc);\n\n\tmemcpy(dst->rsvd3, info->rsvd3, ARRAY_SIZE(info->rsvd3));\n\tdst->eth_mtu = be16_to_cpu(info->eth_mtu);\n\tmemcpy(dst->rsvd4, info->rsvd4, ARRAY_SIZE(info->rsvd4));\n}\n\n \nvoid opa_vnic_get_per_veswport_info(struct opa_vnic_adapter *adapter,\n\t\t\t\t    struct opa_per_veswport_info *info)\n{\n\tstruct __opa_per_veswport_info *src = &adapter->info.vport;\n\n\tinfo->port_num = cpu_to_be32(src->port_num);\n\tinfo->eth_link_status = src->eth_link_status;\n\tmemcpy(info->rsvd0, src->rsvd0, ARRAY_SIZE(src->rsvd0));\n\n\tmemcpy(info->base_mac_addr, src->base_mac_addr,\n\t       ARRAY_SIZE(info->base_mac_addr));\n\tinfo->config_state = src->config_state;\n\tinfo->oper_state = src->oper_state;\n\tinfo->max_mac_tbl_ent = cpu_to_be16(src->max_mac_tbl_ent);\n\tinfo->max_smac_ent = cpu_to_be16(src->max_smac_ent);\n\tinfo->mac_tbl_digest = cpu_to_be32(src->mac_tbl_digest);\n\tmemcpy(info->rsvd1, src->rsvd1, ARRAY_SIZE(src->rsvd1));\n\n\tinfo->encap_slid = cpu_to_be32(src->encap_slid);\n\tmemcpy(info->pcp_to_sc_uc, src->pcp_to_sc_uc,\n\t       ARRAY_SIZE(info->pcp_to_sc_uc));\n\tmemcpy(info->pcp_to_vl_uc, src->pcp_to_vl_uc,\n\t       ARRAY_SIZE(info->pcp_to_vl_uc));\n\tmemcpy(info->pcp_to_sc_mc, src->pcp_to_sc_mc,\n\t       ARRAY_SIZE(info->pcp_to_sc_mc));\n\tmemcpy(info->pcp_to_vl_mc, src->pcp_to_vl_mc,\n\t       ARRAY_SIZE(info->pcp_to_vl_mc));\n\tinfo->non_vlan_sc_uc = src->non_vlan_sc_uc;\n\tinfo->non_vlan_vl_uc = src->non_vlan_vl_uc;\n\tinfo->non_vlan_sc_mc = src->non_vlan_sc_mc;\n\tinfo->non_vlan_vl_mc = src->non_vlan_vl_mc;\n\tmemcpy(info->rsvd2, src->rsvd2, ARRAY_SIZE(src->rsvd2));\n\n\tinfo->uc_macs_gen_count = cpu_to_be16(src->uc_macs_gen_count);\n\tinfo->mc_macs_gen_count = cpu_to_be16(src->mc_macs_gen_count);\n\tmemcpy(info->rsvd3, src->rsvd3, ARRAY_SIZE(src->rsvd3));\n}\n\n \nvoid opa_vnic_set_per_veswport_info(struct opa_vnic_adapter *adapter,\n\t\t\t\t    struct opa_per_veswport_info *info)\n{\n\tstruct __opa_per_veswport_info *dst = &adapter->info.vport;\n\n\tdst->port_num = be32_to_cpu(info->port_num);\n\tmemcpy(dst->rsvd0, info->rsvd0, ARRAY_SIZE(info->rsvd0));\n\n\tmemcpy(dst->base_mac_addr, info->base_mac_addr,\n\t       ARRAY_SIZE(dst->base_mac_addr));\n\tdst->config_state = info->config_state;\n\tmemcpy(dst->rsvd1, info->rsvd1, ARRAY_SIZE(info->rsvd1));\n\n\tdst->encap_slid = be32_to_cpu(info->encap_slid);\n\tmemcpy(dst->pcp_to_sc_uc, info->pcp_to_sc_uc,\n\t       ARRAY_SIZE(dst->pcp_to_sc_uc));\n\tmemcpy(dst->pcp_to_vl_uc, info->pcp_to_vl_uc,\n\t       ARRAY_SIZE(dst->pcp_to_vl_uc));\n\tmemcpy(dst->pcp_to_sc_mc, info->pcp_to_sc_mc,\n\t       ARRAY_SIZE(dst->pcp_to_sc_mc));\n\tmemcpy(dst->pcp_to_vl_mc, info->pcp_to_vl_mc,\n\t       ARRAY_SIZE(dst->pcp_to_vl_mc));\n\tdst->non_vlan_sc_uc = info->non_vlan_sc_uc;\n\tdst->non_vlan_vl_uc = info->non_vlan_vl_uc;\n\tdst->non_vlan_sc_mc = info->non_vlan_sc_mc;\n\tdst->non_vlan_vl_mc = info->non_vlan_vl_mc;\n\tmemcpy(dst->rsvd2, info->rsvd2, ARRAY_SIZE(info->rsvd2));\n\tmemcpy(dst->rsvd3, info->rsvd3, ARRAY_SIZE(info->rsvd3));\n}\n\n \nvoid opa_vnic_query_mcast_macs(struct opa_vnic_adapter *adapter,\n\t\t\t       struct opa_veswport_iface_macs *macs)\n{\n\tu16 start_idx, num_macs, idx = 0, count = 0;\n\tstruct netdev_hw_addr *ha;\n\n\tstart_idx = be16_to_cpu(macs->start_idx);\n\tnum_macs = be16_to_cpu(macs->num_macs_in_msg);\n\tnetdev_for_each_mc_addr(ha, adapter->netdev) {\n\t\tstruct opa_vnic_iface_mac_entry *entry = &macs->entry[count];\n\n\t\tif (start_idx > idx++)\n\t\t\tcontinue;\n\t\telse if (num_macs == count)\n\t\t\tbreak;\n\t\tmemcpy(entry, ha->addr, sizeof(*entry));\n\t\tcount++;\n\t}\n\n\tmacs->tot_macs_in_lst = cpu_to_be16(netdev_mc_count(adapter->netdev));\n\tmacs->num_macs_in_msg = cpu_to_be16(count);\n\tmacs->gen_count = cpu_to_be16(adapter->info.vport.mc_macs_gen_count);\n}\n\n \nvoid opa_vnic_query_ucast_macs(struct opa_vnic_adapter *adapter,\n\t\t\t       struct opa_veswport_iface_macs *macs)\n{\n\tu16 start_idx, tot_macs, num_macs, idx = 0, count = 0, em_macs = 0;\n\tstruct netdev_hw_addr *ha;\n\n\tstart_idx = be16_to_cpu(macs->start_idx);\n\tnum_macs = be16_to_cpu(macs->num_macs_in_msg);\n\t \n\tfor_each_dev_addr(adapter->netdev, ha) {\n\t\tstruct opa_vnic_iface_mac_entry *entry = &macs->entry[count];\n\n\t\t \n\t\tif (!memcmp(adapter->info.vport.base_mac_addr, ha->addr,\n\t\t\t    ARRAY_SIZE(adapter->info.vport.base_mac_addr))) {\n\t\t\tem_macs++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (start_idx > idx++)\n\t\t\tcontinue;\n\t\telse if (num_macs == count)\n\t\t\tbreak;\n\t\tmemcpy(entry, ha->addr, sizeof(*entry));\n\t\tcount++;\n\t}\n\n\t \n\tnetdev_for_each_uc_addr(ha, adapter->netdev) {\n\t\tstruct opa_vnic_iface_mac_entry *entry = &macs->entry[count];\n\n\t\tif (start_idx > idx++)\n\t\t\tcontinue;\n\t\telse if (num_macs == count)\n\t\t\tbreak;\n\t\tmemcpy(entry, ha->addr, sizeof(*entry));\n\t\tcount++;\n\t}\n\n\ttot_macs = netdev_hw_addr_list_count(&adapter->netdev->dev_addrs) +\n\t\t   netdev_uc_count(adapter->netdev) - em_macs;\n\tmacs->tot_macs_in_lst = cpu_to_be16(tot_macs);\n\tmacs->num_macs_in_msg = cpu_to_be16(count);\n\tmacs->gen_count = cpu_to_be16(adapter->info.vport.uc_macs_gen_count);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}