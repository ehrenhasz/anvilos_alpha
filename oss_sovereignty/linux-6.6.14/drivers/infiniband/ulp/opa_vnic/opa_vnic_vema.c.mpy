{
  "module_name": "opa_vnic_vema.c",
  "hash_id": "b01f56db735882f4ef5273903c8e18d8eb741010a0e03370f81dd371edf2d175",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/ulp/opa_vnic/opa_vnic_vema.c",
  "human_readable_source": " \n\n \n\n#include <linux/module.h>\n#include <linux/xarray.h>\n#include <rdma/ib_addr.h>\n#include <rdma/ib_verbs.h>\n#include <rdma/opa_smi.h>\n#include <rdma/opa_port_info.h>\n\n#include \"opa_vnic_internal.h\"\n\nchar opa_vnic_driver_name[] = \"opa_vnic\";\n\n \n#define GET_TRAP_SL_FROM_CLASS_PORT_INFO(x)  (((x) >> 3) & 0x1f)\n\n \n#define OPA_VNIC_TRAP_BURST_LIMIT 4\n\n \n#define OPA_VNIC_TRAP_TIMEOUT  ((4096 * (1UL << 18)) / 1000)\n\n#define OPA_VNIC_UNSUP_ATTR  \\\n\t\tcpu_to_be16(IB_MGMT_MAD_STATUS_UNSUPPORTED_METHOD_ATTRIB)\n\n#define OPA_VNIC_INVAL_ATTR  \\\n\t\tcpu_to_be16(IB_MGMT_MAD_STATUS_INVALID_ATTRIB_VALUE)\n\n#define OPA_VNIC_CLASS_CAP_TRAP   0x1\n\n \n#define OPA_VNIC_MAX_NUM_VPORT    255\n\n \nstruct opa_vnic_vema_port {\n\tstruct opa_vnic_ctrl_port      *cport;\n\tstruct ib_mad_agent            *mad_agent;\n\tstruct opa_class_port_info      class_port_info;\n\tu64                             tid;\n\tu8                              port_num;\n\tstruct xarray                   vports;\n\tstruct ib_event_handler         event_handler;\n\n\t \n\tstruct mutex                    lock;\n};\n\nstatic int opa_vnic_vema_add_one(struct ib_device *device);\nstatic void opa_vnic_vema_rem_one(struct ib_device *device,\n\t\t\t\t  void *client_data);\n\nstatic struct ib_client opa_vnic_client = {\n\t.name   = opa_vnic_driver_name,\n\t.add    = opa_vnic_vema_add_one,\n\t.remove = opa_vnic_vema_rem_one,\n};\n\n \nstatic inline u8 vema_get_vport_num(struct opa_vnic_vema_mad *recvd_mad)\n{\n\treturn be32_to_cpu(recvd_mad->mad_hdr.attr_mod) & 0xff;\n}\n\n \nstatic inline struct opa_vnic_adapter *\nvema_get_vport_adapter(struct opa_vnic_vema_mad *recvd_mad,\n\t\t       struct opa_vnic_vema_port *port)\n{\n\tu8 vport_num = vema_get_vport_num(recvd_mad);\n\n\treturn xa_load(&port->vports, vport_num);\n}\n\n \nstatic inline bool vema_mac_tbl_req_ok(struct opa_veswport_mactable *mac_tbl)\n{\n\tu16 offset, num_entries;\n\tu16 req_entries = ((OPA_VNIC_EMA_DATA - sizeof(*mac_tbl)) /\n\t\t\t   sizeof(mac_tbl->tbl_entries[0]));\n\n\toffset = be16_to_cpu(mac_tbl->offset);\n\tnum_entries = be16_to_cpu(mac_tbl->num_entries);\n\n\treturn ((num_entries <= req_entries) &&\n\t\t(offset + num_entries <= OPA_VNIC_MAC_TBL_MAX_ENTRIES));\n}\n\n \nstatic inline void vema_get_pod_values(struct opa_veswport_info *port_info)\n{\n\tmemset(port_info, 0, sizeof(*port_info));\n\tport_info->vport.max_mac_tbl_ent =\n\t\tcpu_to_be16(OPA_VNIC_MAC_TBL_MAX_ENTRIES);\n\tport_info->vport.max_smac_ent =\n\t\tcpu_to_be16(OPA_VNIC_MAX_SMAC_LIMIT);\n\tport_info->vport.oper_state = OPA_VNIC_STATE_DROP_ALL;\n\tport_info->vport.config_state = OPA_VNIC_STATE_DROP_ALL;\n\tport_info->vesw.eth_mtu = cpu_to_be16(ETH_DATA_LEN);\n}\n\n \nstatic struct opa_vnic_adapter *vema_add_vport(struct opa_vnic_vema_port *port,\n\t\t\t\t\t       u8 vport_num)\n{\n\tstruct opa_vnic_ctrl_port *cport = port->cport;\n\tstruct opa_vnic_adapter *adapter;\n\n\tadapter = opa_vnic_add_netdev(cport->ibdev, port->port_num, vport_num);\n\tif (!IS_ERR(adapter)) {\n\t\tint rc;\n\n\t\tadapter->cport = cport;\n\t\trc = xa_insert(&port->vports, vport_num, adapter, GFP_KERNEL);\n\t\tif (rc < 0) {\n\t\t\topa_vnic_rem_netdev(adapter);\n\t\t\tadapter = ERR_PTR(rc);\n\t\t}\n\t}\n\n\treturn adapter;\n}\n\n \nstatic void vema_get_class_port_info(struct opa_vnic_vema_port *port,\n\t\t\t\t     struct opa_vnic_vema_mad *recvd_mad,\n\t\t\t\t     struct opa_vnic_vema_mad *rsp_mad)\n{\n\tstruct opa_class_port_info *port_info;\n\n\tport_info = (struct opa_class_port_info *)rsp_mad->data;\n\tmemcpy(port_info, &port->class_port_info, sizeof(*port_info));\n\tport_info->base_version = OPA_MGMT_BASE_VERSION;\n\tport_info->class_version = OPA_EMA_CLASS_VERSION;\n\n\t \n\tport_info->cap_mask = cpu_to_be16((OPA_VNIC_CLASS_CAP_TRAP |\n\t\t\t\t\t   (OPA_VNIC_MAX_NUM_VPORT << 8)));\n\n\t \n\tport_info->cap_mask2_resp_time = cpu_to_be32(18);\n}\n\n \nstatic void vema_set_class_port_info(struct opa_vnic_vema_port *port,\n\t\t\t\t     struct opa_vnic_vema_mad *recvd_mad,\n\t\t\t\t     struct opa_vnic_vema_mad *rsp_mad)\n{\n\tmemcpy(&port->class_port_info, recvd_mad->data,\n\t       sizeof(port->class_port_info));\n\n\tvema_get_class_port_info(port, recvd_mad, rsp_mad);\n}\n\n \nstatic void vema_get_veswport_info(struct opa_vnic_vema_port *port,\n\t\t\t\t   struct opa_vnic_vema_mad *recvd_mad,\n\t\t\t\t   struct opa_vnic_vema_mad *rsp_mad)\n{\n\tstruct opa_veswport_info *port_info =\n\t\t\t\t  (struct opa_veswport_info *)rsp_mad->data;\n\tstruct opa_vnic_adapter *adapter;\n\n\tadapter = vema_get_vport_adapter(recvd_mad, port);\n\tif (adapter) {\n\t\tmemset(port_info, 0, sizeof(*port_info));\n\t\topa_vnic_get_vesw_info(adapter, &port_info->vesw);\n\t\topa_vnic_get_per_veswport_info(adapter,\n\t\t\t\t\t       &port_info->vport);\n\t} else {\n\t\tvema_get_pod_values(port_info);\n\t}\n}\n\n \nstatic void vema_set_veswport_info(struct opa_vnic_vema_port *port,\n\t\t\t\t   struct opa_vnic_vema_mad *recvd_mad,\n\t\t\t\t   struct opa_vnic_vema_mad *rsp_mad)\n{\n\tstruct opa_vnic_ctrl_port *cport = port->cport;\n\tstruct opa_veswport_info *port_info;\n\tstruct opa_vnic_adapter *adapter;\n\tu8 vport_num;\n\n\tvport_num = vema_get_vport_num(recvd_mad);\n\n\tadapter = vema_get_vport_adapter(recvd_mad, port);\n\tif (!adapter) {\n\t\tadapter = vema_add_vport(port, vport_num);\n\t\tif (IS_ERR(adapter)) {\n\t\t\tc_err(\"failed to add vport %d: %ld\\n\",\n\t\t\t      vport_num, PTR_ERR(adapter));\n\t\t\tgoto err_exit;\n\t\t}\n\t}\n\n\tport_info = (struct opa_veswport_info *)recvd_mad->data;\n\topa_vnic_set_vesw_info(adapter, &port_info->vesw);\n\topa_vnic_set_per_veswport_info(adapter, &port_info->vport);\n\n\t \n\topa_vnic_process_vema_config(adapter);\n\n\tvema_get_veswport_info(port, recvd_mad, rsp_mad);\n\treturn;\n\nerr_exit:\n\trsp_mad->mad_hdr.status = OPA_VNIC_INVAL_ATTR;\n}\n\n \nstatic void vema_get_mac_entries(struct opa_vnic_vema_port *port,\n\t\t\t\t struct opa_vnic_vema_mad *recvd_mad,\n\t\t\t\t struct opa_vnic_vema_mad *rsp_mad)\n{\n\tstruct opa_veswport_mactable *mac_tbl_in, *mac_tbl_out;\n\tstruct opa_vnic_adapter *adapter;\n\n\tadapter = vema_get_vport_adapter(recvd_mad, port);\n\tif (!adapter) {\n\t\trsp_mad->mad_hdr.status = OPA_VNIC_INVAL_ATTR;\n\t\treturn;\n\t}\n\n\tmac_tbl_in = (struct opa_veswport_mactable *)recvd_mad->data;\n\tmac_tbl_out = (struct opa_veswport_mactable *)rsp_mad->data;\n\n\tif (vema_mac_tbl_req_ok(mac_tbl_in)) {\n\t\tmac_tbl_out->offset = mac_tbl_in->offset;\n\t\tmac_tbl_out->num_entries = mac_tbl_in->num_entries;\n\t\topa_vnic_query_mac_tbl(adapter, mac_tbl_out);\n\t} else {\n\t\trsp_mad->mad_hdr.status = OPA_VNIC_INVAL_ATTR;\n\t}\n}\n\n \nstatic void vema_set_mac_entries(struct opa_vnic_vema_port *port,\n\t\t\t\t struct opa_vnic_vema_mad *recvd_mad,\n\t\t\t\t struct opa_vnic_vema_mad *rsp_mad)\n{\n\tstruct opa_veswport_mactable *mac_tbl;\n\tstruct opa_vnic_adapter *adapter;\n\n\tadapter = vema_get_vport_adapter(recvd_mad, port);\n\tif (!adapter) {\n\t\trsp_mad->mad_hdr.status = OPA_VNIC_INVAL_ATTR;\n\t\treturn;\n\t}\n\n\tmac_tbl = (struct opa_veswport_mactable *)recvd_mad->data;\n\tif (vema_mac_tbl_req_ok(mac_tbl)) {\n\t\tif (opa_vnic_update_mac_tbl(adapter, mac_tbl))\n\t\t\trsp_mad->mad_hdr.status = OPA_VNIC_UNSUP_ATTR;\n\t} else {\n\t\trsp_mad->mad_hdr.status = OPA_VNIC_UNSUP_ATTR;\n\t}\n\tvema_get_mac_entries(port, recvd_mad, rsp_mad);\n}\n\n \nstatic void vema_set_delete_vesw(struct opa_vnic_vema_port *port,\n\t\t\t\t struct opa_vnic_vema_mad *recvd_mad,\n\t\t\t\t struct opa_vnic_vema_mad *rsp_mad)\n{\n\tstruct opa_veswport_info *port_info =\n\t\t\t\t  (struct opa_veswport_info *)rsp_mad->data;\n\tstruct opa_vnic_adapter *adapter;\n\n\tadapter = vema_get_vport_adapter(recvd_mad, port);\n\tif (!adapter) {\n\t\trsp_mad->mad_hdr.status = OPA_VNIC_INVAL_ATTR;\n\t\treturn;\n\t}\n\n\tvema_get_pod_values(port_info);\n\topa_vnic_set_vesw_info(adapter, &port_info->vesw);\n\topa_vnic_set_per_veswport_info(adapter, &port_info->vport);\n\n\t \n\topa_vnic_process_vema_config(adapter);\n\n\topa_vnic_release_mac_tbl(adapter);\n\n\tvema_get_veswport_info(port, recvd_mad, rsp_mad);\n}\n\n \nstatic void vema_get_mac_list(struct opa_vnic_vema_port *port,\n\t\t\t      struct opa_vnic_vema_mad *recvd_mad,\n\t\t\t      struct opa_vnic_vema_mad *rsp_mad,\n\t\t\t      u16 attr_id)\n{\n\tstruct opa_veswport_iface_macs *macs_in, *macs_out;\n\tint max_entries = (OPA_VNIC_EMA_DATA - sizeof(*macs_out)) / ETH_ALEN;\n\tstruct opa_vnic_adapter *adapter;\n\n\tadapter = vema_get_vport_adapter(recvd_mad, port);\n\tif (!adapter) {\n\t\trsp_mad->mad_hdr.status = OPA_VNIC_INVAL_ATTR;\n\t\treturn;\n\t}\n\n\tmacs_in = (struct opa_veswport_iface_macs *)recvd_mad->data;\n\tmacs_out = (struct opa_veswport_iface_macs *)rsp_mad->data;\n\n\tmacs_out->start_idx = macs_in->start_idx;\n\tif (macs_in->num_macs_in_msg)\n\t\tmacs_out->num_macs_in_msg = macs_in->num_macs_in_msg;\n\telse\n\t\tmacs_out->num_macs_in_msg = cpu_to_be16(max_entries);\n\n\tif (attr_id == OPA_EM_ATTR_IFACE_MCAST_MACS)\n\t\topa_vnic_query_mcast_macs(adapter, macs_out);\n\telse\n\t\topa_vnic_query_ucast_macs(adapter, macs_out);\n}\n\n \nstatic void vema_get_summary_counters(struct opa_vnic_vema_port *port,\n\t\t\t\t      struct opa_vnic_vema_mad *recvd_mad,\n\t\t\t\t      struct opa_vnic_vema_mad *rsp_mad)\n{\n\tstruct opa_veswport_summary_counters *cntrs;\n\tstruct opa_vnic_adapter *adapter;\n\n\tadapter = vema_get_vport_adapter(recvd_mad, port);\n\tif (adapter) {\n\t\tcntrs = (struct opa_veswport_summary_counters *)rsp_mad->data;\n\t\topa_vnic_get_summary_counters(adapter, cntrs);\n\t} else {\n\t\trsp_mad->mad_hdr.status = OPA_VNIC_INVAL_ATTR;\n\t}\n}\n\n \nstatic void vema_get_error_counters(struct opa_vnic_vema_port *port,\n\t\t\t\t    struct opa_vnic_vema_mad *recvd_mad,\n\t\t\t\t    struct opa_vnic_vema_mad *rsp_mad)\n{\n\tstruct opa_veswport_error_counters *cntrs;\n\tstruct opa_vnic_adapter *adapter;\n\n\tadapter = vema_get_vport_adapter(recvd_mad, port);\n\tif (adapter) {\n\t\tcntrs = (struct opa_veswport_error_counters *)rsp_mad->data;\n\t\topa_vnic_get_error_counters(adapter, cntrs);\n\t} else {\n\t\trsp_mad->mad_hdr.status = OPA_VNIC_INVAL_ATTR;\n\t}\n}\n\n \nstatic void vema_get(struct opa_vnic_vema_port *port,\n\t\t     struct opa_vnic_vema_mad *recvd_mad,\n\t\t     struct opa_vnic_vema_mad *rsp_mad)\n{\n\tu16 attr_id = be16_to_cpu(recvd_mad->mad_hdr.attr_id);\n\n\tswitch (attr_id) {\n\tcase OPA_EM_ATTR_CLASS_PORT_INFO:\n\t\tvema_get_class_port_info(port, recvd_mad, rsp_mad);\n\t\tbreak;\n\tcase OPA_EM_ATTR_VESWPORT_INFO:\n\t\tvema_get_veswport_info(port, recvd_mad, rsp_mad);\n\t\tbreak;\n\tcase OPA_EM_ATTR_VESWPORT_MAC_ENTRIES:\n\t\tvema_get_mac_entries(port, recvd_mad, rsp_mad);\n\t\tbreak;\n\tcase OPA_EM_ATTR_IFACE_UCAST_MACS:\n\tcase OPA_EM_ATTR_IFACE_MCAST_MACS:\n\t\tvema_get_mac_list(port, recvd_mad, rsp_mad, attr_id);\n\t\tbreak;\n\tcase OPA_EM_ATTR_VESWPORT_SUMMARY_COUNTERS:\n\t\tvema_get_summary_counters(port, recvd_mad, rsp_mad);\n\t\tbreak;\n\tcase OPA_EM_ATTR_VESWPORT_ERROR_COUNTERS:\n\t\tvema_get_error_counters(port, recvd_mad, rsp_mad);\n\t\tbreak;\n\tdefault:\n\t\trsp_mad->mad_hdr.status = OPA_VNIC_UNSUP_ATTR;\n\t\tbreak;\n\t}\n}\n\n \nstatic void vema_set(struct opa_vnic_vema_port *port,\n\t\t     struct opa_vnic_vema_mad *recvd_mad,\n\t\t     struct opa_vnic_vema_mad *rsp_mad)\n{\n\tu16 attr_id = be16_to_cpu(recvd_mad->mad_hdr.attr_id);\n\n\tswitch (attr_id) {\n\tcase OPA_EM_ATTR_CLASS_PORT_INFO:\n\t\tvema_set_class_port_info(port, recvd_mad, rsp_mad);\n\t\tbreak;\n\tcase OPA_EM_ATTR_VESWPORT_INFO:\n\t\tvema_set_veswport_info(port, recvd_mad, rsp_mad);\n\t\tbreak;\n\tcase OPA_EM_ATTR_VESWPORT_MAC_ENTRIES:\n\t\tvema_set_mac_entries(port, recvd_mad, rsp_mad);\n\t\tbreak;\n\tcase OPA_EM_ATTR_DELETE_VESW:\n\t\tvema_set_delete_vesw(port, recvd_mad, rsp_mad);\n\t\tbreak;\n\tdefault:\n\t\trsp_mad->mad_hdr.status = OPA_VNIC_UNSUP_ATTR;\n\t\tbreak;\n\t}\n}\n\n \nstatic void vema_send(struct ib_mad_agent *mad_agent,\n\t\t      struct ib_mad_send_wc *mad_wc)\n{\n\trdma_destroy_ah(mad_wc->send_buf->ah, RDMA_DESTROY_AH_SLEEPABLE);\n\tib_free_send_mad(mad_wc->send_buf);\n}\n\n \nstatic void vema_recv(struct ib_mad_agent *mad_agent,\n\t\t      struct ib_mad_send_buf *send_buf,\n\t\t      struct ib_mad_recv_wc *mad_wc)\n{\n\tstruct opa_vnic_vema_port *port;\n\tstruct ib_ah              *ah;\n\tstruct ib_mad_send_buf    *rsp;\n\tstruct opa_vnic_vema_mad  *vema_mad;\n\n\tif (!mad_wc || !mad_wc->recv_buf.mad)\n\t\treturn;\n\n\tport = mad_agent->context;\n\tah = ib_create_ah_from_wc(mad_agent->qp->pd, mad_wc->wc,\n\t\t\t\t  mad_wc->recv_buf.grh, mad_agent->port_num);\n\tif (IS_ERR(ah))\n\t\tgoto free_recv_mad;\n\n\trsp = ib_create_send_mad(mad_agent, mad_wc->wc->src_qp,\n\t\t\t\t mad_wc->wc->pkey_index, 0,\n\t\t\t\t IB_MGMT_VENDOR_HDR, OPA_VNIC_EMA_DATA,\n\t\t\t\t GFP_KERNEL, OPA_MGMT_BASE_VERSION);\n\tif (IS_ERR(rsp))\n\t\tgoto err_rsp;\n\n\trsp->ah = ah;\n\tvema_mad = rsp->mad;\n\tmemcpy(vema_mad, mad_wc->recv_buf.mad, IB_MGMT_VENDOR_HDR);\n\tvema_mad->mad_hdr.method = IB_MGMT_METHOD_GET_RESP;\n\tvema_mad->mad_hdr.status = 0;\n\n\t \n\tmutex_lock(&port->lock);\n\n\tswitch (mad_wc->recv_buf.mad->mad_hdr.method) {\n\tcase IB_MGMT_METHOD_GET:\n\t\tvema_get(port, (struct opa_vnic_vema_mad *)mad_wc->recv_buf.mad,\n\t\t\t vema_mad);\n\t\tbreak;\n\tcase IB_MGMT_METHOD_SET:\n\t\tvema_set(port, (struct opa_vnic_vema_mad *)mad_wc->recv_buf.mad,\n\t\t\t vema_mad);\n\t\tbreak;\n\tdefault:\n\t\tvema_mad->mad_hdr.status = OPA_VNIC_UNSUP_ATTR;\n\t\tbreak;\n\t}\n\tmutex_unlock(&port->lock);\n\n\tif (!ib_post_send_mad(rsp, NULL)) {\n\t\t \n\t\tgoto free_recv_mad;\n\t}\n\n\tib_free_send_mad(rsp);\n\nerr_rsp:\n\trdma_destroy_ah(ah, RDMA_DESTROY_AH_SLEEPABLE);\nfree_recv_mad:\n\tib_free_recv_mad(mad_wc);\n}\n\n \nstatic struct opa_vnic_vema_port *\nvema_get_port(struct opa_vnic_ctrl_port *cport, u8 port_num)\n{\n\tstruct opa_vnic_vema_port *port = (void *)cport + sizeof(*cport);\n\n\tif (port_num > cport->num_ports)\n\t\treturn NULL;\n\n\treturn port + (port_num - 1);\n}\n\n \nvoid opa_vnic_vema_send_trap(struct opa_vnic_adapter *adapter,\n\t\t\t     struct __opa_veswport_trap *data, u32 lid)\n{\n\tstruct opa_vnic_ctrl_port *cport = adapter->cport;\n\tstruct ib_mad_send_buf *send_buf;\n\tstruct opa_vnic_vema_port *port;\n\tstruct ib_device *ibp;\n\tstruct opa_vnic_vema_mad_trap *trap_mad;\n\tstruct opa_class_port_info *class;\n\tstruct rdma_ah_attr ah_attr;\n\tstruct ib_ah *ah;\n\tstruct opa_veswport_trap *trap;\n\tu32 trap_lid;\n\tu16 pkey_idx;\n\n\tif (!cport)\n\t\tgoto err_exit;\n\tibp = cport->ibdev;\n\tport = vema_get_port(cport, data->opaportnum);\n\tif (!port || !port->mad_agent)\n\t\tgoto err_exit;\n\n\tif (time_before(jiffies, adapter->trap_timeout)) {\n\t\tif (adapter->trap_count == OPA_VNIC_TRAP_BURST_LIMIT) {\n\t\t\tv_warn(\"Trap rate exceeded\\n\");\n\t\t\tgoto err_exit;\n\t\t} else {\n\t\t\tadapter->trap_count++;\n\t\t}\n\t} else {\n\t\tadapter->trap_count = 0;\n\t}\n\n\tclass = &port->class_port_info;\n\t \n\tmemset(&ah_attr, 0, sizeof(ah_attr));\n\tah_attr.type = rdma_ah_find_type(ibp, port->port_num);\n\trdma_ah_set_sl(&ah_attr,\n\t\t       GET_TRAP_SL_FROM_CLASS_PORT_INFO(class->trap_sl_rsvd));\n\trdma_ah_set_port_num(&ah_attr, port->port_num);\n\ttrap_lid = be32_to_cpu(class->trap_lid);\n\t \n\tif (!trap_lid) {\n\t\tc_err(\"%s: Invalid dlid\\n\", __func__);\n\t\tgoto err_exit;\n\t}\n\n\trdma_ah_set_dlid(&ah_attr, trap_lid);\n\tah = rdma_create_ah(port->mad_agent->qp->pd, &ah_attr, 0);\n\tif (IS_ERR(ah)) {\n\t\tc_err(\"%s:Couldn't create new AH = %p\\n\", __func__, ah);\n\t\tc_err(\"%s:dlid = %d, sl = %d, port = %d\\n\", __func__,\n\t\t      rdma_ah_get_dlid(&ah_attr), rdma_ah_get_sl(&ah_attr),\n\t\t      rdma_ah_get_port_num(&ah_attr));\n\t\tgoto err_exit;\n\t}\n\n\tif (ib_find_pkey(ibp, data->opaportnum, IB_DEFAULT_PKEY_FULL,\n\t\t\t &pkey_idx) < 0) {\n\t\tc_err(\"%s:full key not found, defaulting to partial\\n\",\n\t\t      __func__);\n\t\tif (ib_find_pkey(ibp, data->opaportnum, IB_DEFAULT_PKEY_PARTIAL,\n\t\t\t\t &pkey_idx) < 0)\n\t\t\tpkey_idx = 1;\n\t}\n\n\tsend_buf = ib_create_send_mad(port->mad_agent, 1, pkey_idx, 0,\n\t\t\t\t      IB_MGMT_VENDOR_HDR, IB_MGMT_MAD_DATA,\n\t\t\t\t      GFP_ATOMIC, OPA_MGMT_BASE_VERSION);\n\tif (IS_ERR(send_buf)) {\n\t\tc_err(\"%s:Couldn't allocate send buf\\n\", __func__);\n\t\tgoto err_sndbuf;\n\t}\n\n\tsend_buf->ah = ah;\n\n\t \n\ttrap_mad = send_buf->mad;\n\ttrap_mad->mad_hdr.base_version = OPA_MGMT_BASE_VERSION;\n\ttrap_mad->mad_hdr.mgmt_class = OPA_MGMT_CLASS_INTEL_EMA;\n\ttrap_mad->mad_hdr.class_version = OPA_EMA_CLASS_VERSION;\n\ttrap_mad->mad_hdr.method = IB_MGMT_METHOD_TRAP;\n\tport->tid++;\n\ttrap_mad->mad_hdr.tid = cpu_to_be64(port->tid);\n\ttrap_mad->mad_hdr.attr_id = IB_SMP_ATTR_NOTICE;\n\n\t \n\ttrap_mad->oui[0] = INTEL_OUI_1;\n\ttrap_mad->oui[1] = INTEL_OUI_2;\n\ttrap_mad->oui[2] = INTEL_OUI_3;\n\n\t \n\ttrap_mad->notice.gen_type = OPA_INTEL_EMA_NOTICE_TYPE_INFO << 1;\n\ttrap_mad->notice.oui_1 = INTEL_OUI_1;\n\ttrap_mad->notice.oui_2 = INTEL_OUI_2;\n\ttrap_mad->notice.oui_3 = INTEL_OUI_3;\n\ttrap_mad->notice.issuer_lid = cpu_to_be32(lid);\n\n\t \n\ttrap = (struct opa_veswport_trap *)trap_mad->notice.raw_data;\n\ttrap->fabric_id = cpu_to_be16(data->fabric_id);\n\ttrap->veswid = cpu_to_be16(data->veswid);\n\ttrap->veswportnum = cpu_to_be32(data->veswportnum);\n\ttrap->opaportnum = cpu_to_be16(data->opaportnum);\n\ttrap->veswportindex = data->veswportindex;\n\ttrap->opcode = data->opcode;\n\n\t \n\tif (ib_post_send_mad(send_buf, NULL)) {\n\t\tib_free_send_mad(send_buf);\n\t} else {\n\t\tif (adapter->trap_count)\n\t\t\treturn;\n\t\tadapter->trap_timeout = jiffies +\n\t\t\t\t\tusecs_to_jiffies(OPA_VNIC_TRAP_TIMEOUT);\n\t\treturn;\n\t}\n\nerr_sndbuf:\n\trdma_destroy_ah(ah, 0);\nerr_exit:\n\tv_err(\"Aborting trap\\n\");\n}\n\nstatic void opa_vnic_event(struct ib_event_handler *handler,\n\t\t\t   struct ib_event *record)\n{\n\tstruct opa_vnic_vema_port *port =\n\t\tcontainer_of(handler, struct opa_vnic_vema_port, event_handler);\n\tstruct opa_vnic_ctrl_port *cport = port->cport;\n\tstruct opa_vnic_adapter *adapter;\n\tunsigned long index;\n\n\tif (record->element.port_num != port->port_num)\n\t\treturn;\n\n\tc_dbg(\"OPA_VNIC received event %d on device %s port %d\\n\",\n\t      record->event, dev_name(&record->device->dev),\n\t      record->element.port_num);\n\n\tif (record->event != IB_EVENT_PORT_ERR &&\n\t    record->event != IB_EVENT_PORT_ACTIVE)\n\t\treturn;\n\n\txa_for_each(&port->vports, index, adapter) {\n\t\tif (record->event == IB_EVENT_PORT_ACTIVE)\n\t\t\tnetif_carrier_on(adapter->netdev);\n\t\telse\n\t\t\tnetif_carrier_off(adapter->netdev);\n\t}\n}\n\n \nstatic void vema_unregister(struct opa_vnic_ctrl_port *cport)\n{\n\tstruct opa_vnic_adapter *adapter;\n\tunsigned long index;\n\tint i;\n\n\tfor (i = 1; i <= cport->num_ports; i++) {\n\t\tstruct opa_vnic_vema_port *port = vema_get_port(cport, i);\n\n\t\tif (!port->mad_agent)\n\t\t\tcontinue;\n\n\t\t \n\t\tmutex_lock(&port->lock);\n\t\txa_for_each(&port->vports, index, adapter)\n\t\t\topa_vnic_rem_netdev(adapter);\n\t\tmutex_unlock(&port->lock);\n\n\t\tib_unregister_mad_agent(port->mad_agent);\n\t\tport->mad_agent = NULL;\n\t\tmutex_destroy(&port->lock);\n\t\txa_destroy(&port->vports);\n\t\tib_unregister_event_handler(&port->event_handler);\n\t}\n}\n\n \nstatic int vema_register(struct opa_vnic_ctrl_port *cport)\n{\n\tstruct ib_mad_reg_req reg_req = {\n\t\t.mgmt_class = OPA_MGMT_CLASS_INTEL_EMA,\n\t\t.mgmt_class_version = OPA_MGMT_BASE_VERSION,\n\t\t.oui = { INTEL_OUI_1, INTEL_OUI_2, INTEL_OUI_3 }\n\t};\n\tint i;\n\n\tset_bit(IB_MGMT_METHOD_GET, reg_req.method_mask);\n\tset_bit(IB_MGMT_METHOD_SET, reg_req.method_mask);\n\n\t \n\tfor (i = 1; i <= cport->num_ports; i++) {\n\t\tstruct opa_vnic_vema_port *port = vema_get_port(cport, i);\n\t\tint ret;\n\n\t\tport->cport = cport;\n\t\tport->port_num = i;\n\n\t\tINIT_IB_EVENT_HANDLER(&port->event_handler,\n\t\t\t\t      cport->ibdev, opa_vnic_event);\n\t\tib_register_event_handler(&port->event_handler);\n\n\t\txa_init(&port->vports);\n\t\tmutex_init(&port->lock);\n\t\tport->mad_agent = ib_register_mad_agent(cport->ibdev, i,\n\t\t\t\t\t\t\tIB_QPT_GSI, &reg_req,\n\t\t\t\t\t\t\tIB_MGMT_RMPP_VERSION,\n\t\t\t\t\t\t\tvema_send, vema_recv,\n\t\t\t\t\t\t\tport, 0);\n\t\tif (IS_ERR(port->mad_agent)) {\n\t\t\tret = PTR_ERR(port->mad_agent);\n\t\t\tport->mad_agent = NULL;\n\t\t\tmutex_destroy(&port->lock);\n\t\t\tvema_unregister(cport);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic void opa_vnic_ctrl_config_dev(struct opa_vnic_ctrl_port *cport, bool en)\n{\n\tstruct ib_port_modify pm = { 0 };\n\tint i;\n\n\tif (en)\n\t\tpm.set_port_cap_mask = OPA_CAP_MASK3_IsEthOnFabricSupported;\n\telse\n\t\tpm.clr_port_cap_mask = OPA_CAP_MASK3_IsEthOnFabricSupported;\n\n\tfor (i = 1; i <= cport->num_ports; i++)\n\t\tib_modify_port(cport->ibdev, i, IB_PORT_OPA_MASK_CHG, &pm);\n}\n\n \nstatic int opa_vnic_vema_add_one(struct ib_device *device)\n{\n\tstruct opa_vnic_ctrl_port *cport;\n\tint rc, size = sizeof(*cport);\n\n\tif (!rdma_cap_opa_vnic(device))\n\t\treturn -EOPNOTSUPP;\n\n\tsize += device->phys_port_cnt * sizeof(struct opa_vnic_vema_port);\n\tcport = kzalloc(size, GFP_KERNEL);\n\tif (!cport)\n\t\treturn -ENOMEM;\n\n\tcport->num_ports = device->phys_port_cnt;\n\tcport->ibdev = device;\n\n\t \n\trc = vema_register(cport);\n\tif (!rc)\n\t\tc_info(\"VNIC client initialized\\n\");\n\n\tib_set_client_data(device, &opa_vnic_client, cport);\n\topa_vnic_ctrl_config_dev(cport, true);\n\treturn 0;\n}\n\n \nstatic void opa_vnic_vema_rem_one(struct ib_device *device,\n\t\t\t\t  void *client_data)\n{\n\tstruct opa_vnic_ctrl_port *cport = client_data;\n\n\tc_info(\"removing VNIC client\\n\");\n\topa_vnic_ctrl_config_dev(cport, false);\n\tvema_unregister(cport);\n\tkfree(cport);\n}\n\nstatic int __init opa_vnic_init(void)\n{\n\tint rc;\n\n\trc = ib_register_client(&opa_vnic_client);\n\tif (rc)\n\t\tpr_err(\"VNIC driver register failed %d\\n\", rc);\n\n\treturn rc;\n}\nmodule_init(opa_vnic_init);\n\nstatic void opa_vnic_deinit(void)\n{\n\tib_unregister_client(&opa_vnic_client);\n}\nmodule_exit(opa_vnic_deinit);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_AUTHOR(\"Cornelis Networks\");\nMODULE_DESCRIPTION(\"Cornelis OPX Virtual Network driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}