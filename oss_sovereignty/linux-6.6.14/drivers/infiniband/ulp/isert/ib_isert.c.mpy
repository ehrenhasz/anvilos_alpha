{
  "module_name": "ib_isert.c",
  "hash_id": "40f1152f7267a99534e0092751cb1be5df700b70d505bfceac96dd4d778e4e35",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/ulp/isert/ib_isert.c",
  "human_readable_source": "\n \n\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/scatterlist.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n#include <linux/in6.h>\n#include <rdma/ib_verbs.h>\n#include <rdma/ib_cm.h>\n#include <rdma/rdma_cm.h>\n#include <target/target_core_base.h>\n#include <target/target_core_fabric.h>\n#include <target/iscsi/iscsi_transport.h>\n#include <linux/semaphore.h>\n\n#include \"ib_isert.h\"\n\nstatic int isert_debug_level;\nmodule_param_named(debug_level, isert_debug_level, int, 0644);\nMODULE_PARM_DESC(debug_level, \"Enable debug tracing if > 0 (default:0)\");\n\nstatic int isert_sg_tablesize_set(const char *val,\n\t\t\t\t  const struct kernel_param *kp);\nstatic const struct kernel_param_ops sg_tablesize_ops = {\n\t.set = isert_sg_tablesize_set,\n\t.get = param_get_int,\n};\n\nstatic int isert_sg_tablesize = ISCSI_ISER_MIN_SG_TABLESIZE;\nmodule_param_cb(sg_tablesize, &sg_tablesize_ops, &isert_sg_tablesize, 0644);\nMODULE_PARM_DESC(sg_tablesize,\n\t\t \"Number of gather/scatter entries in a single scsi command, should >= 128 (default: 128, max: 4096)\");\n\nstatic DEFINE_MUTEX(device_list_mutex);\nstatic LIST_HEAD(device_list);\nstatic struct workqueue_struct *isert_login_wq;\nstatic struct workqueue_struct *isert_comp_wq;\nstatic struct workqueue_struct *isert_release_wq;\n\nstatic int\nisert_put_response(struct iscsit_conn *conn, struct iscsit_cmd *cmd);\nstatic int\nisert_login_post_recv(struct isert_conn *isert_conn);\nstatic int\nisert_rdma_accept(struct isert_conn *isert_conn);\nstruct rdma_cm_id *isert_setup_id(struct isert_np *isert_np);\n\nstatic void isert_release_work(struct work_struct *work);\nstatic void isert_recv_done(struct ib_cq *cq, struct ib_wc *wc);\nstatic void isert_send_done(struct ib_cq *cq, struct ib_wc *wc);\nstatic void isert_login_recv_done(struct ib_cq *cq, struct ib_wc *wc);\nstatic void isert_login_send_done(struct ib_cq *cq, struct ib_wc *wc);\n\nstatic int isert_sg_tablesize_set(const char *val, const struct kernel_param *kp)\n{\n\tint n = 0, ret;\n\n\tret = kstrtoint(val, 10, &n);\n\tif (ret != 0 || n < ISCSI_ISER_MIN_SG_TABLESIZE ||\n\t    n > ISCSI_ISER_MAX_SG_TABLESIZE)\n\t\treturn -EINVAL;\n\n\treturn param_set_int(val, kp);\n}\n\nstatic inline bool\nisert_prot_cmd(struct isert_conn *conn, struct se_cmd *cmd)\n{\n\treturn (conn->pi_support &&\n\t\tcmd->prot_op != TARGET_PROT_NORMAL);\n}\n\nstatic void\nisert_qp_event_callback(struct ib_event *e, void *context)\n{\n\tstruct isert_conn *isert_conn = context;\n\n\tisert_err(\"%s (%d): conn %p\\n\",\n\t\t  ib_event_msg(e->event), e->event, isert_conn);\n\n\tswitch (e->event) {\n\tcase IB_EVENT_COMM_EST:\n\t\trdma_notify(isert_conn->cm_id, IB_EVENT_COMM_EST);\n\t\tbreak;\n\tcase IB_EVENT_QP_LAST_WQE_REACHED:\n\t\tisert_warn(\"Reached TX IB_EVENT_QP_LAST_WQE_REACHED\\n\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic struct ib_qp *\nisert_create_qp(struct isert_conn *isert_conn,\n\t\tstruct rdma_cm_id *cma_id)\n{\n\tu32 cq_size = ISERT_QP_MAX_REQ_DTOS + ISERT_QP_MAX_RECV_DTOS + 2;\n\tstruct isert_device *device = isert_conn->device;\n\tstruct ib_device *ib_dev = device->ib_device;\n\tstruct ib_qp_init_attr attr;\n\tint ret, factor;\n\n\tisert_conn->cq = ib_cq_pool_get(ib_dev, cq_size, -1, IB_POLL_WORKQUEUE);\n\tif (IS_ERR(isert_conn->cq)) {\n\t\tisert_err(\"Unable to allocate cq\\n\");\n\t\tret = PTR_ERR(isert_conn->cq);\n\t\treturn ERR_PTR(ret);\n\t}\n\tisert_conn->cq_size = cq_size;\n\n\tmemset(&attr, 0, sizeof(struct ib_qp_init_attr));\n\tattr.event_handler = isert_qp_event_callback;\n\tattr.qp_context = isert_conn;\n\tattr.send_cq = isert_conn->cq;\n\tattr.recv_cq = isert_conn->cq;\n\tattr.cap.max_send_wr = ISERT_QP_MAX_REQ_DTOS + 1;\n\tattr.cap.max_recv_wr = ISERT_QP_MAX_RECV_DTOS + 1;\n\tfactor = rdma_rw_mr_factor(device->ib_device, cma_id->port_num,\n\t\t\t\t   isert_sg_tablesize);\n\tattr.cap.max_rdma_ctxs = ISCSI_DEF_XMIT_CMDS_MAX * factor;\n\tattr.cap.max_send_sge = device->ib_device->attrs.max_send_sge;\n\tattr.cap.max_recv_sge = 1;\n\tattr.sq_sig_type = IB_SIGNAL_REQ_WR;\n\tattr.qp_type = IB_QPT_RC;\n\tif (device->pi_capable)\n\t\tattr.create_flags |= IB_QP_CREATE_INTEGRITY_EN;\n\n\tret = rdma_create_qp(cma_id, device->pd, &attr);\n\tif (ret) {\n\t\tisert_err(\"rdma_create_qp failed for cma_id %d\\n\", ret);\n\t\tib_cq_pool_put(isert_conn->cq, isert_conn->cq_size);\n\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn cma_id->qp;\n}\n\nstatic int\nisert_alloc_rx_descriptors(struct isert_conn *isert_conn)\n{\n\tstruct isert_device *device = isert_conn->device;\n\tstruct ib_device *ib_dev = device->ib_device;\n\tstruct iser_rx_desc *rx_desc;\n\tstruct ib_sge *rx_sg;\n\tu64 dma_addr;\n\tint i, j;\n\n\tisert_conn->rx_descs = kcalloc(ISERT_QP_MAX_RECV_DTOS,\n\t\t\t\t       sizeof(struct iser_rx_desc),\n\t\t\t\t       GFP_KERNEL);\n\tif (!isert_conn->rx_descs)\n\t\treturn -ENOMEM;\n\n\trx_desc = isert_conn->rx_descs;\n\n\tfor (i = 0; i < ISERT_QP_MAX_RECV_DTOS; i++, rx_desc++)  {\n\t\tdma_addr = ib_dma_map_single(ib_dev, rx_desc->buf,\n\t\t\t\t\tISER_RX_SIZE, DMA_FROM_DEVICE);\n\t\tif (ib_dma_mapping_error(ib_dev, dma_addr))\n\t\t\tgoto dma_map_fail;\n\n\t\trx_desc->dma_addr = dma_addr;\n\n\t\trx_sg = &rx_desc->rx_sg;\n\t\trx_sg->addr = rx_desc->dma_addr + isert_get_hdr_offset(rx_desc);\n\t\trx_sg->length = ISER_RX_PAYLOAD_SIZE;\n\t\trx_sg->lkey = device->pd->local_dma_lkey;\n\t\trx_desc->rx_cqe.done = isert_recv_done;\n\t}\n\n\treturn 0;\n\ndma_map_fail:\n\trx_desc = isert_conn->rx_descs;\n\tfor (j = 0; j < i; j++, rx_desc++) {\n\t\tib_dma_unmap_single(ib_dev, rx_desc->dma_addr,\n\t\t\t\t    ISER_RX_SIZE, DMA_FROM_DEVICE);\n\t}\n\tkfree(isert_conn->rx_descs);\n\tisert_conn->rx_descs = NULL;\n\tisert_err(\"conn %p failed to allocate rx descriptors\\n\", isert_conn);\n\treturn -ENOMEM;\n}\n\nstatic void\nisert_free_rx_descriptors(struct isert_conn *isert_conn)\n{\n\tstruct ib_device *ib_dev = isert_conn->device->ib_device;\n\tstruct iser_rx_desc *rx_desc;\n\tint i;\n\n\tif (!isert_conn->rx_descs)\n\t\treturn;\n\n\trx_desc = isert_conn->rx_descs;\n\tfor (i = 0; i < ISERT_QP_MAX_RECV_DTOS; i++, rx_desc++)  {\n\t\tib_dma_unmap_single(ib_dev, rx_desc->dma_addr,\n\t\t\t\t    ISER_RX_SIZE, DMA_FROM_DEVICE);\n\t}\n\n\tkfree(isert_conn->rx_descs);\n\tisert_conn->rx_descs = NULL;\n}\n\nstatic int\nisert_create_device_ib_res(struct isert_device *device)\n{\n\tstruct ib_device *ib_dev = device->ib_device;\n\tint ret;\n\n\tisert_dbg(\"devattr->max_send_sge: %d devattr->max_recv_sge %d\\n\",\n\t\t  ib_dev->attrs.max_send_sge, ib_dev->attrs.max_recv_sge);\n\tisert_dbg(\"devattr->max_sge_rd: %d\\n\", ib_dev->attrs.max_sge_rd);\n\n\tdevice->pd = ib_alloc_pd(ib_dev, 0);\n\tif (IS_ERR(device->pd)) {\n\t\tret = PTR_ERR(device->pd);\n\t\tisert_err(\"failed to allocate pd, device %p, ret=%d\\n\",\n\t\t\t  device, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (ib_dev->attrs.kernel_cap_flags & IBK_INTEGRITY_HANDOVER)\n\t\tdevice->pi_capable = true;\n\telse\n\t\tdevice->pi_capable = false;\n\n\treturn 0;\n}\n\nstatic void\nisert_free_device_ib_res(struct isert_device *device)\n{\n\tisert_info(\"device %p\\n\", device);\n\n\tib_dealloc_pd(device->pd);\n}\n\nstatic void\nisert_device_put(struct isert_device *device)\n{\n\tmutex_lock(&device_list_mutex);\n\tdevice->refcount--;\n\tisert_info(\"device %p refcount %d\\n\", device, device->refcount);\n\tif (!device->refcount) {\n\t\tisert_free_device_ib_res(device);\n\t\tlist_del(&device->dev_node);\n\t\tkfree(device);\n\t}\n\tmutex_unlock(&device_list_mutex);\n}\n\nstatic struct isert_device *\nisert_device_get(struct rdma_cm_id *cma_id)\n{\n\tstruct isert_device *device;\n\tint ret;\n\n\tmutex_lock(&device_list_mutex);\n\tlist_for_each_entry(device, &device_list, dev_node) {\n\t\tif (device->ib_device->node_guid == cma_id->device->node_guid) {\n\t\t\tdevice->refcount++;\n\t\t\tisert_info(\"Found iser device %p refcount %d\\n\",\n\t\t\t\t   device, device->refcount);\n\t\t\tmutex_unlock(&device_list_mutex);\n\t\t\treturn device;\n\t\t}\n\t}\n\n\tdevice = kzalloc(sizeof(struct isert_device), GFP_KERNEL);\n\tif (!device) {\n\t\tmutex_unlock(&device_list_mutex);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tINIT_LIST_HEAD(&device->dev_node);\n\n\tdevice->ib_device = cma_id->device;\n\tret = isert_create_device_ib_res(device);\n\tif (ret) {\n\t\tkfree(device);\n\t\tmutex_unlock(&device_list_mutex);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tdevice->refcount++;\n\tlist_add_tail(&device->dev_node, &device_list);\n\tisert_info(\"Created a new iser device %p refcount %d\\n\",\n\t\t   device, device->refcount);\n\tmutex_unlock(&device_list_mutex);\n\n\treturn device;\n}\n\nstatic void\nisert_init_conn(struct isert_conn *isert_conn)\n{\n\tisert_conn->state = ISER_CONN_INIT;\n\tINIT_LIST_HEAD(&isert_conn->node);\n\tinit_completion(&isert_conn->login_comp);\n\tinit_completion(&isert_conn->login_req_comp);\n\tinit_waitqueue_head(&isert_conn->rem_wait);\n\tkref_init(&isert_conn->kref);\n\tmutex_init(&isert_conn->mutex);\n\tINIT_WORK(&isert_conn->release_work, isert_release_work);\n}\n\nstatic void\nisert_free_login_buf(struct isert_conn *isert_conn)\n{\n\tstruct ib_device *ib_dev = isert_conn->device->ib_device;\n\n\tib_dma_unmap_single(ib_dev, isert_conn->login_rsp_dma,\n\t\t\t    ISER_RX_PAYLOAD_SIZE, DMA_TO_DEVICE);\n\tkfree(isert_conn->login_rsp_buf);\n\n\tib_dma_unmap_single(ib_dev, isert_conn->login_desc->dma_addr,\n\t\t\t    ISER_RX_SIZE, DMA_FROM_DEVICE);\n\tkfree(isert_conn->login_desc);\n}\n\nstatic int\nisert_alloc_login_buf(struct isert_conn *isert_conn,\n\t\t      struct ib_device *ib_dev)\n{\n\tint ret;\n\n\tisert_conn->login_desc = kzalloc(sizeof(*isert_conn->login_desc),\n\t\t\tGFP_KERNEL);\n\tif (!isert_conn->login_desc)\n\t\treturn -ENOMEM;\n\n\tisert_conn->login_desc->dma_addr = ib_dma_map_single(ib_dev,\n\t\t\t\tisert_conn->login_desc->buf,\n\t\t\t\tISER_RX_SIZE, DMA_FROM_DEVICE);\n\tret = ib_dma_mapping_error(ib_dev, isert_conn->login_desc->dma_addr);\n\tif (ret) {\n\t\tisert_err(\"login_desc dma mapping error: %d\\n\", ret);\n\t\tisert_conn->login_desc->dma_addr = 0;\n\t\tgoto out_free_login_desc;\n\t}\n\n\tisert_conn->login_rsp_buf = kzalloc(ISER_RX_PAYLOAD_SIZE, GFP_KERNEL);\n\tif (!isert_conn->login_rsp_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out_unmap_login_desc;\n\t}\n\n\tisert_conn->login_rsp_dma = ib_dma_map_single(ib_dev,\n\t\t\t\t\tisert_conn->login_rsp_buf,\n\t\t\t\t\tISER_RX_PAYLOAD_SIZE, DMA_TO_DEVICE);\n\tret = ib_dma_mapping_error(ib_dev, isert_conn->login_rsp_dma);\n\tif (ret) {\n\t\tisert_err(\"login_rsp_dma mapping error: %d\\n\", ret);\n\t\tisert_conn->login_rsp_dma = 0;\n\t\tgoto out_free_login_rsp_buf;\n\t}\n\n\treturn 0;\n\nout_free_login_rsp_buf:\n\tkfree(isert_conn->login_rsp_buf);\nout_unmap_login_desc:\n\tib_dma_unmap_single(ib_dev, isert_conn->login_desc->dma_addr,\n\t\t\t    ISER_RX_SIZE, DMA_FROM_DEVICE);\nout_free_login_desc:\n\tkfree(isert_conn->login_desc);\n\treturn ret;\n}\n\nstatic void\nisert_set_nego_params(struct isert_conn *isert_conn,\n\t\t      struct rdma_conn_param *param)\n{\n\tstruct ib_device_attr *attr = &isert_conn->device->ib_device->attrs;\n\n\t \n\tisert_conn->initiator_depth = min_t(u8, param->initiator_depth,\n\t\t\t\tattr->max_qp_init_rd_atom);\n\tisert_dbg(\"Using initiator_depth: %u\\n\", isert_conn->initiator_depth);\n\n\tif (param->private_data) {\n\t\tu8 flags = *(u8 *)param->private_data;\n\n\t\t \n\t\tisert_conn->snd_w_inv = !(flags & ISER_SEND_W_INV_NOT_SUP) &&\n\t\t\t\t\t  (attr->device_cap_flags &\n\t\t\t\t\t   IB_DEVICE_MEM_MGT_EXTENSIONS);\n\t\tif (isert_conn->snd_w_inv)\n\t\t\tisert_info(\"Using remote invalidation\\n\");\n\t}\n}\n\nstatic void\nisert_destroy_qp(struct isert_conn *isert_conn)\n{\n\tib_destroy_qp(isert_conn->qp);\n\tib_cq_pool_put(isert_conn->cq, isert_conn->cq_size);\n}\n\nstatic int\nisert_connect_request(struct rdma_cm_id *cma_id, struct rdma_cm_event *event)\n{\n\tstruct isert_np *isert_np = cma_id->context;\n\tstruct iscsi_np *np = isert_np->np;\n\tstruct isert_conn *isert_conn;\n\tstruct isert_device *device;\n\tint ret = 0;\n\n\tspin_lock_bh(&np->np_thread_lock);\n\tif (!np->enabled) {\n\t\tspin_unlock_bh(&np->np_thread_lock);\n\t\tisert_dbg(\"iscsi_np is not enabled, reject connect request\\n\");\n\t\treturn rdma_reject(cma_id, NULL, 0, IB_CM_REJ_CONSUMER_DEFINED);\n\t}\n\tspin_unlock_bh(&np->np_thread_lock);\n\n\tisert_dbg(\"cma_id: %p, portal: %p\\n\",\n\t\t cma_id, cma_id->context);\n\n\tisert_conn = kzalloc(sizeof(struct isert_conn), GFP_KERNEL);\n\tif (!isert_conn)\n\t\treturn -ENOMEM;\n\n\tisert_init_conn(isert_conn);\n\tisert_conn->cm_id = cma_id;\n\n\tdevice = isert_device_get(cma_id);\n\tif (IS_ERR(device)) {\n\t\tret = PTR_ERR(device);\n\t\tgoto out;\n\t}\n\tisert_conn->device = device;\n\n\tret = isert_alloc_login_buf(isert_conn, cma_id->device);\n\tif (ret)\n\t\tgoto out_conn_dev;\n\n\tisert_set_nego_params(isert_conn, &event->param.conn);\n\n\tisert_conn->qp = isert_create_qp(isert_conn, cma_id);\n\tif (IS_ERR(isert_conn->qp)) {\n\t\tret = PTR_ERR(isert_conn->qp);\n\t\tgoto out_rsp_dma_map;\n\t}\n\n\tret = isert_login_post_recv(isert_conn);\n\tif (ret)\n\t\tgoto out_destroy_qp;\n\n\tret = isert_rdma_accept(isert_conn);\n\tif (ret)\n\t\tgoto out_destroy_qp;\n\n\tmutex_lock(&isert_np->mutex);\n\tlist_add_tail(&isert_conn->node, &isert_np->accepted);\n\tmutex_unlock(&isert_np->mutex);\n\n\treturn 0;\n\nout_destroy_qp:\n\tisert_destroy_qp(isert_conn);\nout_rsp_dma_map:\n\tisert_free_login_buf(isert_conn);\nout_conn_dev:\n\tisert_device_put(device);\nout:\n\tkfree(isert_conn);\n\trdma_reject(cma_id, NULL, 0, IB_CM_REJ_CONSUMER_DEFINED);\n\treturn ret;\n}\n\nstatic void\nisert_connect_release(struct isert_conn *isert_conn)\n{\n\tstruct isert_device *device = isert_conn->device;\n\n\tisert_dbg(\"conn %p\\n\", isert_conn);\n\n\tBUG_ON(!device);\n\n\tisert_free_rx_descriptors(isert_conn);\n\tif (isert_conn->cm_id &&\n\t    !isert_conn->dev_removed)\n\t\trdma_destroy_id(isert_conn->cm_id);\n\n\tif (isert_conn->qp)\n\t\tisert_destroy_qp(isert_conn);\n\n\tif (isert_conn->login_desc)\n\t\tisert_free_login_buf(isert_conn);\n\n\tisert_device_put(device);\n\n\tif (isert_conn->dev_removed)\n\t\twake_up_interruptible(&isert_conn->rem_wait);\n\telse\n\t\tkfree(isert_conn);\n}\n\nstatic void\nisert_connected_handler(struct rdma_cm_id *cma_id)\n{\n\tstruct isert_conn *isert_conn = cma_id->qp->qp_context;\n\tstruct isert_np *isert_np = cma_id->context;\n\n\tisert_info(\"conn %p\\n\", isert_conn);\n\n\tmutex_lock(&isert_conn->mutex);\n\tisert_conn->state = ISER_CONN_UP;\n\tkref_get(&isert_conn->kref);\n\tmutex_unlock(&isert_conn->mutex);\n\n\tmutex_lock(&isert_np->mutex);\n\tlist_move_tail(&isert_conn->node, &isert_np->pending);\n\tmutex_unlock(&isert_np->mutex);\n\n\tisert_info(\"np %p: Allow accept_np to continue\\n\", isert_np);\n\tup(&isert_np->sem);\n}\n\nstatic void\nisert_release_kref(struct kref *kref)\n{\n\tstruct isert_conn *isert_conn = container_of(kref,\n\t\t\t\tstruct isert_conn, kref);\n\n\tisert_info(\"conn %p final kref %s/%d\\n\", isert_conn, current->comm,\n\t\t   current->pid);\n\n\tisert_connect_release(isert_conn);\n}\n\nstatic void\nisert_put_conn(struct isert_conn *isert_conn)\n{\n\tkref_put(&isert_conn->kref, isert_release_kref);\n}\n\nstatic void\nisert_handle_unbound_conn(struct isert_conn *isert_conn)\n{\n\tstruct isert_np *isert_np = isert_conn->cm_id->context;\n\n\tmutex_lock(&isert_np->mutex);\n\tif (!list_empty(&isert_conn->node)) {\n\t\t \n\t\tlist_del_init(&isert_conn->node);\n\t\tisert_put_conn(isert_conn);\n\t\tqueue_work(isert_release_wq, &isert_conn->release_work);\n\t}\n\tmutex_unlock(&isert_np->mutex);\n}\n\n \nstatic void\nisert_conn_terminate(struct isert_conn *isert_conn)\n{\n\tint err;\n\n\tif (isert_conn->state >= ISER_CONN_TERMINATING)\n\t\treturn;\n\n\tisert_info(\"Terminating conn %p state %d\\n\",\n\t\t   isert_conn, isert_conn->state);\n\tisert_conn->state = ISER_CONN_TERMINATING;\n\terr = rdma_disconnect(isert_conn->cm_id);\n\tif (err)\n\t\tisert_warn(\"Failed rdma_disconnect isert_conn %p\\n\",\n\t\t\t   isert_conn);\n}\n\nstatic int\nisert_np_cma_handler(struct isert_np *isert_np,\n\t\t     enum rdma_cm_event_type event)\n{\n\tisert_dbg(\"%s (%d): isert np %p\\n\",\n\t\t  rdma_event_msg(event), event, isert_np);\n\n\tswitch (event) {\n\tcase RDMA_CM_EVENT_DEVICE_REMOVAL:\n\t\tisert_np->cm_id = NULL;\n\t\tbreak;\n\tcase RDMA_CM_EVENT_ADDR_CHANGE:\n\t\tisert_np->cm_id = isert_setup_id(isert_np);\n\t\tif (IS_ERR(isert_np->cm_id)) {\n\t\t\tisert_err(\"isert np %p setup id failed: %ld\\n\",\n\t\t\t\t  isert_np, PTR_ERR(isert_np->cm_id));\n\t\t\tisert_np->cm_id = NULL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tisert_err(\"isert np %p Unexpected event %d\\n\",\n\t\t\t  isert_np, event);\n\t}\n\n\treturn -1;\n}\n\nstatic int\nisert_disconnected_handler(struct rdma_cm_id *cma_id,\n\t\t\t   enum rdma_cm_event_type event)\n{\n\tstruct isert_conn *isert_conn = cma_id->qp->qp_context;\n\n\tmutex_lock(&isert_conn->mutex);\n\tswitch (isert_conn->state) {\n\tcase ISER_CONN_TERMINATING:\n\t\tbreak;\n\tcase ISER_CONN_UP:\n\t\tisert_conn_terminate(isert_conn);\n\t\tib_drain_qp(isert_conn->qp);\n\t\tisert_handle_unbound_conn(isert_conn);\n\t\tbreak;\n\tcase ISER_CONN_BOUND:\n\tcase ISER_CONN_FULL_FEATURE:  \n\t\tiscsit_cause_connection_reinstatement(isert_conn->conn, 0);\n\t\tbreak;\n\tdefault:\n\t\tisert_warn(\"conn %p terminating in state %d\\n\",\n\t\t\t   isert_conn, isert_conn->state);\n\t}\n\tmutex_unlock(&isert_conn->mutex);\n\n\treturn 0;\n}\n\nstatic int\nisert_connect_error(struct rdma_cm_id *cma_id)\n{\n\tstruct isert_conn *isert_conn = cma_id->qp->qp_context;\n\tstruct isert_np *isert_np = cma_id->context;\n\n\tib_drain_qp(isert_conn->qp);\n\n\tmutex_lock(&isert_np->mutex);\n\tlist_del_init(&isert_conn->node);\n\tmutex_unlock(&isert_np->mutex);\n\tisert_conn->cm_id = NULL;\n\tisert_put_conn(isert_conn);\n\n\treturn -1;\n}\n\nstatic int\nisert_cma_handler(struct rdma_cm_id *cma_id, struct rdma_cm_event *event)\n{\n\tstruct isert_np *isert_np = cma_id->context;\n\tstruct isert_conn *isert_conn;\n\tint ret = 0;\n\n\tisert_info(\"%s (%d): status %d id %p np %p\\n\",\n\t\t   rdma_event_msg(event->event), event->event,\n\t\t   event->status, cma_id, cma_id->context);\n\n\tif (isert_np->cm_id == cma_id)\n\t\treturn isert_np_cma_handler(cma_id->context, event->event);\n\n\tswitch (event->event) {\n\tcase RDMA_CM_EVENT_CONNECT_REQUEST:\n\t\tret = isert_connect_request(cma_id, event);\n\t\tif (ret)\n\t\t\tisert_err(\"failed handle connect request %d\\n\", ret);\n\t\tbreak;\n\tcase RDMA_CM_EVENT_ESTABLISHED:\n\t\tisert_connected_handler(cma_id);\n\t\tbreak;\n\tcase RDMA_CM_EVENT_ADDR_CHANGE:\n\tcase RDMA_CM_EVENT_DISCONNECTED:\n\tcase RDMA_CM_EVENT_TIMEWAIT_EXIT:   \n\t\tret = isert_disconnected_handler(cma_id, event->event);\n\t\tbreak;\n\tcase RDMA_CM_EVENT_DEVICE_REMOVAL:\n\t\tisert_conn = cma_id->qp->qp_context;\n\t\tisert_conn->dev_removed = true;\n\t\tisert_disconnected_handler(cma_id, event->event);\n\t\twait_event_interruptible(isert_conn->rem_wait,\n\t\t\t\t\t isert_conn->state == ISER_CONN_DOWN);\n\t\tkfree(isert_conn);\n\t\t \n\t\treturn 1;\n\tcase RDMA_CM_EVENT_REJECTED:\n\t\tisert_info(\"Connection rejected: %s\\n\",\n\t\t\t   rdma_reject_msg(cma_id, event->status));\n\t\tfallthrough;\n\tcase RDMA_CM_EVENT_UNREACHABLE:\n\tcase RDMA_CM_EVENT_CONNECT_ERROR:\n\t\tret = isert_connect_error(cma_id);\n\t\tbreak;\n\tdefault:\n\t\tisert_err(\"Unhandled RDMA CMA event: %d\\n\", event->event);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int\nisert_post_recvm(struct isert_conn *isert_conn, u32 count)\n{\n\tstruct ib_recv_wr *rx_wr;\n\tint i, ret;\n\tstruct iser_rx_desc *rx_desc;\n\n\tfor (rx_wr = isert_conn->rx_wr, i = 0; i < count; i++, rx_wr++) {\n\t\trx_desc = &isert_conn->rx_descs[i];\n\n\t\trx_wr->wr_cqe = &rx_desc->rx_cqe;\n\t\trx_wr->sg_list = &rx_desc->rx_sg;\n\t\trx_wr->num_sge = 1;\n\t\trx_wr->next = rx_wr + 1;\n\t\trx_desc->in_use = false;\n\t}\n\trx_wr--;\n\trx_wr->next = NULL;  \n\n\tret = ib_post_recv(isert_conn->qp, isert_conn->rx_wr, NULL);\n\tif (ret)\n\t\tisert_err(\"ib_post_recv() failed with ret: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int\nisert_post_recv(struct isert_conn *isert_conn, struct iser_rx_desc *rx_desc)\n{\n\tstruct ib_recv_wr rx_wr;\n\tint ret;\n\n\tif (!rx_desc->in_use) {\n\t\t \n\t\treturn 0;\n\t}\n\n\trx_desc->in_use = false;\n\trx_wr.wr_cqe = &rx_desc->rx_cqe;\n\trx_wr.sg_list = &rx_desc->rx_sg;\n\trx_wr.num_sge = 1;\n\trx_wr.next = NULL;\n\n\tret = ib_post_recv(isert_conn->qp, &rx_wr, NULL);\n\tif (ret)\n\t\tisert_err(\"ib_post_recv() failed with ret: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int\nisert_login_post_send(struct isert_conn *isert_conn, struct iser_tx_desc *tx_desc)\n{\n\tstruct ib_device *ib_dev = isert_conn->cm_id->device;\n\tstruct ib_send_wr send_wr;\n\tint ret;\n\n\tib_dma_sync_single_for_device(ib_dev, tx_desc->dma_addr,\n\t\t\t\t      ISER_HEADERS_LEN, DMA_TO_DEVICE);\n\n\ttx_desc->tx_cqe.done = isert_login_send_done;\n\n\tsend_wr.next\t= NULL;\n\tsend_wr.wr_cqe\t= &tx_desc->tx_cqe;\n\tsend_wr.sg_list\t= tx_desc->tx_sg;\n\tsend_wr.num_sge\t= tx_desc->num_sge;\n\tsend_wr.opcode\t= IB_WR_SEND;\n\tsend_wr.send_flags = IB_SEND_SIGNALED;\n\n\tret = ib_post_send(isert_conn->qp, &send_wr, NULL);\n\tif (ret)\n\t\tisert_err(\"ib_post_send() failed, ret: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic void\n__isert_create_send_desc(struct isert_device *device,\n\t\t\t struct iser_tx_desc *tx_desc)\n{\n\n\tmemset(&tx_desc->iser_header, 0, sizeof(struct iser_ctrl));\n\ttx_desc->iser_header.flags = ISCSI_CTRL;\n\n\ttx_desc->num_sge = 1;\n\n\tif (tx_desc->tx_sg[0].lkey != device->pd->local_dma_lkey) {\n\t\ttx_desc->tx_sg[0].lkey = device->pd->local_dma_lkey;\n\t\tisert_dbg(\"tx_desc %p lkey mismatch, fixing\\n\", tx_desc);\n\t}\n}\n\nstatic void\nisert_create_send_desc(struct isert_conn *isert_conn,\n\t\t       struct isert_cmd *isert_cmd,\n\t\t       struct iser_tx_desc *tx_desc)\n{\n\tstruct isert_device *device = isert_conn->device;\n\tstruct ib_device *ib_dev = device->ib_device;\n\n\tib_dma_sync_single_for_cpu(ib_dev, tx_desc->dma_addr,\n\t\t\t\t   ISER_HEADERS_LEN, DMA_TO_DEVICE);\n\n\t__isert_create_send_desc(device, tx_desc);\n}\n\nstatic int\nisert_init_tx_hdrs(struct isert_conn *isert_conn,\n\t\t   struct iser_tx_desc *tx_desc)\n{\n\tstruct isert_device *device = isert_conn->device;\n\tstruct ib_device *ib_dev = device->ib_device;\n\tu64 dma_addr;\n\n\tdma_addr = ib_dma_map_single(ib_dev, (void *)tx_desc,\n\t\t\tISER_HEADERS_LEN, DMA_TO_DEVICE);\n\tif (ib_dma_mapping_error(ib_dev, dma_addr)) {\n\t\tisert_err(\"ib_dma_mapping_error() failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\ttx_desc->dma_addr = dma_addr;\n\ttx_desc->tx_sg[0].addr\t= tx_desc->dma_addr;\n\ttx_desc->tx_sg[0].length = ISER_HEADERS_LEN;\n\ttx_desc->tx_sg[0].lkey = device->pd->local_dma_lkey;\n\n\tisert_dbg(\"Setup tx_sg[0].addr: 0x%llx length: %u lkey: 0x%x\\n\",\n\t\t  tx_desc->tx_sg[0].addr, tx_desc->tx_sg[0].length,\n\t\t  tx_desc->tx_sg[0].lkey);\n\n\treturn 0;\n}\n\nstatic void\nisert_init_send_wr(struct isert_conn *isert_conn, struct isert_cmd *isert_cmd,\n\t\t   struct ib_send_wr *send_wr)\n{\n\tstruct iser_tx_desc *tx_desc = &isert_cmd->tx_desc;\n\n\ttx_desc->tx_cqe.done = isert_send_done;\n\tsend_wr->wr_cqe = &tx_desc->tx_cqe;\n\n\tif (isert_conn->snd_w_inv && isert_cmd->inv_rkey) {\n\t\tsend_wr->opcode  = IB_WR_SEND_WITH_INV;\n\t\tsend_wr->ex.invalidate_rkey = isert_cmd->inv_rkey;\n\t} else {\n\t\tsend_wr->opcode = IB_WR_SEND;\n\t}\n\n\tsend_wr->sg_list = &tx_desc->tx_sg[0];\n\tsend_wr->num_sge = isert_cmd->tx_desc.num_sge;\n\tsend_wr->send_flags = IB_SEND_SIGNALED;\n}\n\nstatic int\nisert_login_post_recv(struct isert_conn *isert_conn)\n{\n\tstruct ib_recv_wr rx_wr;\n\tstruct ib_sge sge;\n\tint ret;\n\n\tmemset(&sge, 0, sizeof(struct ib_sge));\n\tsge.addr = isert_conn->login_desc->dma_addr +\n\t\tisert_get_hdr_offset(isert_conn->login_desc);\n\tsge.length = ISER_RX_PAYLOAD_SIZE;\n\tsge.lkey = isert_conn->device->pd->local_dma_lkey;\n\n\tisert_dbg(\"Setup sge: addr: %llx length: %d 0x%08x\\n\",\n\t\tsge.addr, sge.length, sge.lkey);\n\n\tisert_conn->login_desc->rx_cqe.done = isert_login_recv_done;\n\n\tmemset(&rx_wr, 0, sizeof(struct ib_recv_wr));\n\trx_wr.wr_cqe = &isert_conn->login_desc->rx_cqe;\n\trx_wr.sg_list = &sge;\n\trx_wr.num_sge = 1;\n\n\tret = ib_post_recv(isert_conn->qp, &rx_wr, NULL);\n\tif (ret)\n\t\tisert_err(\"ib_post_recv() failed: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int\nisert_put_login_tx(struct iscsit_conn *conn, struct iscsi_login *login,\n\t\t   u32 length)\n{\n\tstruct isert_conn *isert_conn = conn->context;\n\tstruct isert_device *device = isert_conn->device;\n\tstruct ib_device *ib_dev = device->ib_device;\n\tstruct iser_tx_desc *tx_desc = &isert_conn->login_tx_desc;\n\tint ret;\n\n\t__isert_create_send_desc(device, tx_desc);\n\n\tmemcpy(&tx_desc->iscsi_header, &login->rsp[0],\n\t       sizeof(struct iscsi_hdr));\n\n\tisert_init_tx_hdrs(isert_conn, tx_desc);\n\n\tif (length > 0) {\n\t\tstruct ib_sge *tx_dsg = &tx_desc->tx_sg[1];\n\n\t\tib_dma_sync_single_for_cpu(ib_dev, isert_conn->login_rsp_dma,\n\t\t\t\t\t   length, DMA_TO_DEVICE);\n\n\t\tmemcpy(isert_conn->login_rsp_buf, login->rsp_buf, length);\n\n\t\tib_dma_sync_single_for_device(ib_dev, isert_conn->login_rsp_dma,\n\t\t\t\t\t      length, DMA_TO_DEVICE);\n\n\t\ttx_dsg->addr\t= isert_conn->login_rsp_dma;\n\t\ttx_dsg->length\t= length;\n\t\ttx_dsg->lkey\t= isert_conn->device->pd->local_dma_lkey;\n\t\ttx_desc->num_sge = 2;\n\t}\n\tif (!login->login_failed) {\n\t\tif (login->login_complete) {\n\t\t\tret = isert_alloc_rx_descriptors(isert_conn);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tret = isert_post_recvm(isert_conn,\n\t\t\t\t\t       ISERT_QP_MAX_RECV_DTOS);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\t \n\t\t\tmutex_lock(&isert_conn->mutex);\n\t\t\tisert_conn->state = ISER_CONN_FULL_FEATURE;\n\t\t\tmutex_unlock(&isert_conn->mutex);\n\t\t\tgoto post_send;\n\t\t}\n\n\t\tret = isert_login_post_recv(isert_conn);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\npost_send:\n\tret = isert_login_post_send(isert_conn, tx_desc);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void\nisert_rx_login_req(struct isert_conn *isert_conn)\n{\n\tstruct iser_rx_desc *rx_desc = isert_conn->login_desc;\n\tint rx_buflen = isert_conn->login_req_len;\n\tstruct iscsit_conn *conn = isert_conn->conn;\n\tstruct iscsi_login *login = conn->conn_login;\n\tint size;\n\n\tisert_info(\"conn %p\\n\", isert_conn);\n\n\tWARN_ON_ONCE(!login);\n\n\tif (login->first_request) {\n\t\tstruct iscsi_login_req *login_req =\n\t\t\t(struct iscsi_login_req *)isert_get_iscsi_hdr(rx_desc);\n\t\t \n\t\tlogin->leading_connection = (!login_req->tsih) ? 1 : 0;\n\t\tlogin->current_stage = ISCSI_LOGIN_CURRENT_STAGE(\n\t\t\t\tlogin_req->flags);\n\t\tlogin->version_min\t= login_req->min_version;\n\t\tlogin->version_max\t= login_req->max_version;\n\t\tmemcpy(login->isid, login_req->isid, 6);\n\t\tlogin->cmd_sn\t\t= be32_to_cpu(login_req->cmdsn);\n\t\tlogin->init_task_tag\t= login_req->itt;\n\t\tlogin->initial_exp_statsn = be32_to_cpu(login_req->exp_statsn);\n\t\tlogin->cid\t\t= be16_to_cpu(login_req->cid);\n\t\tlogin->tsih\t\t= be16_to_cpu(login_req->tsih);\n\t}\n\n\tmemcpy(&login->req[0], isert_get_iscsi_hdr(rx_desc), ISCSI_HDR_LEN);\n\n\tsize = min(rx_buflen, MAX_KEY_VALUE_PAIRS);\n\tisert_dbg(\"Using login payload size: %d, rx_buflen: %d \"\n\t\t  \"MAX_KEY_VALUE_PAIRS: %d\\n\", size, rx_buflen,\n\t\t  MAX_KEY_VALUE_PAIRS);\n\tmemcpy(login->req_buf, isert_get_data(rx_desc), size);\n\n\tif (login->first_request) {\n\t\tcomplete(&isert_conn->login_comp);\n\t\treturn;\n\t}\n\tqueue_delayed_work(isert_login_wq, &conn->login_work, 0);\n}\n\nstatic struct iscsit_cmd\n*isert_allocate_cmd(struct iscsit_conn *conn, struct iser_rx_desc *rx_desc)\n{\n\tstruct isert_conn *isert_conn = conn->context;\n\tstruct isert_cmd *isert_cmd;\n\tstruct iscsit_cmd *cmd;\n\n\tcmd = iscsit_allocate_cmd(conn, TASK_INTERRUPTIBLE);\n\tif (!cmd) {\n\t\tisert_err(\"Unable to allocate iscsit_cmd + isert_cmd\\n\");\n\t\treturn NULL;\n\t}\n\tisert_cmd = iscsit_priv_cmd(cmd);\n\tisert_cmd->conn = isert_conn;\n\tisert_cmd->iscsit_cmd = cmd;\n\tisert_cmd->rx_desc = rx_desc;\n\n\treturn cmd;\n}\n\nstatic int\nisert_handle_scsi_cmd(struct isert_conn *isert_conn,\n\t\t      struct isert_cmd *isert_cmd, struct iscsit_cmd *cmd,\n\t\t      struct iser_rx_desc *rx_desc, unsigned char *buf)\n{\n\tstruct iscsit_conn *conn = isert_conn->conn;\n\tstruct iscsi_scsi_req *hdr = (struct iscsi_scsi_req *)buf;\n\tint imm_data, imm_data_len, unsol_data, sg_nents, rc;\n\tbool dump_payload = false;\n\tunsigned int data_len;\n\n\trc = iscsit_setup_scsi_cmd(conn, cmd, buf);\n\tif (rc < 0)\n\t\treturn rc;\n\n\timm_data = cmd->immediate_data;\n\timm_data_len = cmd->first_burst_len;\n\tunsol_data = cmd->unsolicited_data;\n\tdata_len = cmd->se_cmd.data_length;\n\n\tif (imm_data && imm_data_len == data_len)\n\t\tcmd->se_cmd.se_cmd_flags |= SCF_PASSTHROUGH_SG_TO_MEM_NOALLOC;\n\trc = iscsit_process_scsi_cmd(conn, cmd, hdr);\n\tif (rc < 0) {\n\t\treturn 0;\n\t} else if (rc > 0) {\n\t\tdump_payload = true;\n\t\tgoto sequence_cmd;\n\t}\n\n\tif (!imm_data)\n\t\treturn 0;\n\n\tif (imm_data_len != data_len) {\n\t\tsg_nents = max(1UL, DIV_ROUND_UP(imm_data_len, PAGE_SIZE));\n\t\tsg_copy_from_buffer(cmd->se_cmd.t_data_sg, sg_nents,\n\t\t\t\t    isert_get_data(rx_desc), imm_data_len);\n\t\tisert_dbg(\"Copy Immediate sg_nents: %u imm_data_len: %d\\n\",\n\t\t\t  sg_nents, imm_data_len);\n\t} else {\n\t\tsg_init_table(&isert_cmd->sg, 1);\n\t\tcmd->se_cmd.t_data_sg = &isert_cmd->sg;\n\t\tcmd->se_cmd.t_data_nents = 1;\n\t\tsg_set_buf(&isert_cmd->sg, isert_get_data(rx_desc),\n\t\t\t\timm_data_len);\n\t\tisert_dbg(\"Transfer Immediate imm_data_len: %d\\n\",\n\t\t\t  imm_data_len);\n\t}\n\n\tcmd->write_data_done += imm_data_len;\n\n\tif (cmd->write_data_done == cmd->se_cmd.data_length) {\n\t\tspin_lock_bh(&cmd->istate_lock);\n\t\tcmd->cmd_flags |= ICF_GOT_LAST_DATAOUT;\n\t\tcmd->i_state = ISTATE_RECEIVED_LAST_DATAOUT;\n\t\tspin_unlock_bh(&cmd->istate_lock);\n\t}\n\nsequence_cmd:\n\trc = iscsit_sequence_cmd(conn, cmd, buf, hdr->cmdsn);\n\n\tif (!rc && !dump_payload && unsol_data)\n\t\tiscsit_set_unsolicited_dataout(cmd);\n\telse if (dump_payload && imm_data)\n\t\ttarget_put_sess_cmd(&cmd->se_cmd);\n\n\treturn 0;\n}\n\nstatic int\nisert_handle_iscsi_dataout(struct isert_conn *isert_conn,\n\t\t\t   struct iser_rx_desc *rx_desc, unsigned char *buf)\n{\n\tstruct scatterlist *sg_start;\n\tstruct iscsit_conn *conn = isert_conn->conn;\n\tstruct iscsit_cmd *cmd = NULL;\n\tstruct iscsi_data *hdr = (struct iscsi_data *)buf;\n\tu32 unsol_data_len = ntoh24(hdr->dlength);\n\tint rc, sg_nents, sg_off, page_off;\n\n\trc = iscsit_check_dataout_hdr(conn, buf, &cmd);\n\tif (rc < 0)\n\t\treturn rc;\n\telse if (!cmd)\n\t\treturn 0;\n\t \n\tif (!cmd->unsolicited_data) {\n\t\tisert_err(\"Received unexpected solicited data payload\\n\");\n\t\tdump_stack();\n\t\treturn -1;\n\t}\n\n\tisert_dbg(\"Unsolicited DataOut unsol_data_len: %u, \"\n\t\t  \"write_data_done: %u, data_length: %u\\n\",\n\t\t  unsol_data_len,  cmd->write_data_done,\n\t\t  cmd->se_cmd.data_length);\n\n\tsg_off = cmd->write_data_done / PAGE_SIZE;\n\tsg_start = &cmd->se_cmd.t_data_sg[sg_off];\n\tsg_nents = max(1UL, DIV_ROUND_UP(unsol_data_len, PAGE_SIZE));\n\tpage_off = cmd->write_data_done % PAGE_SIZE;\n\t \n\tif (page_off) {\n\t\tisert_err(\"unexpected non-page aligned data payload\\n\");\n\t\tdump_stack();\n\t\treturn -1;\n\t}\n\tisert_dbg(\"Copying DataOut: sg_start: %p, sg_off: %u \"\n\t\t  \"sg_nents: %u from %p %u\\n\", sg_start, sg_off,\n\t\t  sg_nents, isert_get_data(rx_desc), unsol_data_len);\n\n\tsg_copy_from_buffer(sg_start, sg_nents, isert_get_data(rx_desc),\n\t\t\t    unsol_data_len);\n\n\trc = iscsit_check_dataout_payload(cmd, hdr, false);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\treturn isert_post_recv(isert_conn, rx_desc);\n}\n\nstatic int\nisert_handle_nop_out(struct isert_conn *isert_conn, struct isert_cmd *isert_cmd,\n\t\t     struct iscsit_cmd *cmd, struct iser_rx_desc *rx_desc,\n\t\t     unsigned char *buf)\n{\n\tstruct iscsit_conn *conn = isert_conn->conn;\n\tstruct iscsi_nopout *hdr = (struct iscsi_nopout *)buf;\n\tint rc;\n\n\trc = iscsit_setup_nop_out(conn, cmd, hdr);\n\tif (rc < 0)\n\t\treturn rc;\n\t \n\n\treturn iscsit_process_nop_out(conn, cmd, hdr);\n}\n\nstatic int\nisert_handle_text_cmd(struct isert_conn *isert_conn, struct isert_cmd *isert_cmd,\n\t\t      struct iscsit_cmd *cmd, struct iser_rx_desc *rx_desc,\n\t\t      struct iscsi_text *hdr)\n{\n\tstruct iscsit_conn *conn = isert_conn->conn;\n\tu32 payload_length = ntoh24(hdr->dlength);\n\tint rc;\n\tunsigned char *text_in = NULL;\n\n\trc = iscsit_setup_text_cmd(conn, cmd, hdr);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tif (payload_length) {\n\t\ttext_in = kzalloc(payload_length, GFP_KERNEL);\n\t\tif (!text_in)\n\t\t\treturn -ENOMEM;\n\t}\n\tcmd->text_in_ptr = text_in;\n\n\tmemcpy(cmd->text_in_ptr, isert_get_data(rx_desc), payload_length);\n\n\treturn iscsit_process_text_cmd(conn, cmd, hdr);\n}\n\nstatic int\nisert_rx_opcode(struct isert_conn *isert_conn, struct iser_rx_desc *rx_desc,\n\t\tuint32_t read_stag, uint64_t read_va,\n\t\tuint32_t write_stag, uint64_t write_va)\n{\n\tstruct iscsi_hdr *hdr = isert_get_iscsi_hdr(rx_desc);\n\tstruct iscsit_conn *conn = isert_conn->conn;\n\tstruct iscsit_cmd *cmd;\n\tstruct isert_cmd *isert_cmd;\n\tint ret = -EINVAL;\n\tu8 opcode = (hdr->opcode & ISCSI_OPCODE_MASK);\n\n\tif (conn->sess->sess_ops->SessionType &&\n\t   (!(opcode & ISCSI_OP_TEXT) || !(opcode & ISCSI_OP_LOGOUT))) {\n\t\tisert_err(\"Got illegal opcode: 0x%02x in SessionType=Discovery,\"\n\t\t\t  \" ignoring\\n\", opcode);\n\t\treturn 0;\n\t}\n\n\tswitch (opcode) {\n\tcase ISCSI_OP_SCSI_CMD:\n\t\tcmd = isert_allocate_cmd(conn, rx_desc);\n\t\tif (!cmd)\n\t\t\tbreak;\n\n\t\tisert_cmd = iscsit_priv_cmd(cmd);\n\t\tisert_cmd->read_stag = read_stag;\n\t\tisert_cmd->read_va = read_va;\n\t\tisert_cmd->write_stag = write_stag;\n\t\tisert_cmd->write_va = write_va;\n\t\tisert_cmd->inv_rkey = read_stag ? read_stag : write_stag;\n\n\t\tret = isert_handle_scsi_cmd(isert_conn, isert_cmd, cmd,\n\t\t\t\t\trx_desc, (unsigned char *)hdr);\n\t\tbreak;\n\tcase ISCSI_OP_NOOP_OUT:\n\t\tcmd = isert_allocate_cmd(conn, rx_desc);\n\t\tif (!cmd)\n\t\t\tbreak;\n\n\t\tisert_cmd = iscsit_priv_cmd(cmd);\n\t\tret = isert_handle_nop_out(isert_conn, isert_cmd, cmd,\n\t\t\t\t\t   rx_desc, (unsigned char *)hdr);\n\t\tbreak;\n\tcase ISCSI_OP_SCSI_DATA_OUT:\n\t\tret = isert_handle_iscsi_dataout(isert_conn, rx_desc,\n\t\t\t\t\t\t(unsigned char *)hdr);\n\t\tbreak;\n\tcase ISCSI_OP_SCSI_TMFUNC:\n\t\tcmd = isert_allocate_cmd(conn, rx_desc);\n\t\tif (!cmd)\n\t\t\tbreak;\n\n\t\tret = iscsit_handle_task_mgt_cmd(conn, cmd,\n\t\t\t\t\t\t(unsigned char *)hdr);\n\t\tbreak;\n\tcase ISCSI_OP_LOGOUT:\n\t\tcmd = isert_allocate_cmd(conn, rx_desc);\n\t\tif (!cmd)\n\t\t\tbreak;\n\n\t\tret = iscsit_handle_logout_cmd(conn, cmd, (unsigned char *)hdr);\n\t\tbreak;\n\tcase ISCSI_OP_TEXT:\n\t\tif (be32_to_cpu(hdr->ttt) != 0xFFFFFFFF)\n\t\t\tcmd = iscsit_find_cmd_from_itt(conn, hdr->itt);\n\t\telse\n\t\t\tcmd = isert_allocate_cmd(conn, rx_desc);\n\n\t\tif (!cmd)\n\t\t\tbreak;\n\n\t\tisert_cmd = iscsit_priv_cmd(cmd);\n\t\tret = isert_handle_text_cmd(isert_conn, isert_cmd, cmd,\n\t\t\t\t\t    rx_desc, (struct iscsi_text *)hdr);\n\t\tbreak;\n\tdefault:\n\t\tisert_err(\"Got unknown iSCSI OpCode: 0x%02x\\n\", opcode);\n\t\tdump_stack();\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic void\nisert_print_wc(struct ib_wc *wc, const char *type)\n{\n\tif (wc->status != IB_WC_WR_FLUSH_ERR)\n\t\tisert_err(\"%s failure: %s (%d) vend_err %x\\n\", type,\n\t\t\t  ib_wc_status_msg(wc->status), wc->status,\n\t\t\t  wc->vendor_err);\n\telse\n\t\tisert_dbg(\"%s failure: %s (%d)\\n\", type,\n\t\t\t  ib_wc_status_msg(wc->status), wc->status);\n}\n\nstatic void\nisert_recv_done(struct ib_cq *cq, struct ib_wc *wc)\n{\n\tstruct isert_conn *isert_conn = wc->qp->qp_context;\n\tstruct ib_device *ib_dev = isert_conn->cm_id->device;\n\tstruct iser_rx_desc *rx_desc = cqe_to_rx_desc(wc->wr_cqe);\n\tstruct iscsi_hdr *hdr = isert_get_iscsi_hdr(rx_desc);\n\tstruct iser_ctrl *iser_ctrl = isert_get_iser_hdr(rx_desc);\n\tuint64_t read_va = 0, write_va = 0;\n\tuint32_t read_stag = 0, write_stag = 0;\n\n\tif (unlikely(wc->status != IB_WC_SUCCESS)) {\n\t\tisert_print_wc(wc, \"recv\");\n\t\tif (wc->status != IB_WC_WR_FLUSH_ERR)\n\t\t\tiscsit_cause_connection_reinstatement(isert_conn->conn, 0);\n\t\treturn;\n\t}\n\n\trx_desc->in_use = true;\n\n\tib_dma_sync_single_for_cpu(ib_dev, rx_desc->dma_addr,\n\t\t\tISER_RX_SIZE, DMA_FROM_DEVICE);\n\n\tisert_dbg(\"DMA: 0x%llx, iSCSI opcode: 0x%02x, ITT: 0x%08x, flags: 0x%02x dlen: %d\\n\",\n\t\t rx_desc->dma_addr, hdr->opcode, hdr->itt, hdr->flags,\n\t\t (int)(wc->byte_len - ISER_HEADERS_LEN));\n\n\tswitch (iser_ctrl->flags & 0xF0) {\n\tcase ISCSI_CTRL:\n\t\tif (iser_ctrl->flags & ISER_RSV) {\n\t\t\tread_stag = be32_to_cpu(iser_ctrl->read_stag);\n\t\t\tread_va = be64_to_cpu(iser_ctrl->read_va);\n\t\t\tisert_dbg(\"ISER_RSV: read_stag: 0x%x read_va: 0x%llx\\n\",\n\t\t\t\t  read_stag, (unsigned long long)read_va);\n\t\t}\n\t\tif (iser_ctrl->flags & ISER_WSV) {\n\t\t\twrite_stag = be32_to_cpu(iser_ctrl->write_stag);\n\t\t\twrite_va = be64_to_cpu(iser_ctrl->write_va);\n\t\t\tisert_dbg(\"ISER_WSV: write_stag: 0x%x write_va: 0x%llx\\n\",\n\t\t\t\t  write_stag, (unsigned long long)write_va);\n\t\t}\n\n\t\tisert_dbg(\"ISER ISCSI_CTRL PDU\\n\");\n\t\tbreak;\n\tcase ISER_HELLO:\n\t\tisert_err(\"iSER Hello message\\n\");\n\t\tbreak;\n\tdefault:\n\t\tisert_warn(\"Unknown iSER hdr flags: 0x%02x\\n\", iser_ctrl->flags);\n\t\tbreak;\n\t}\n\n\tisert_rx_opcode(isert_conn, rx_desc,\n\t\t\tread_stag, read_va, write_stag, write_va);\n\n\tib_dma_sync_single_for_device(ib_dev, rx_desc->dma_addr,\n\t\t\tISER_RX_SIZE, DMA_FROM_DEVICE);\n}\n\nstatic void\nisert_login_recv_done(struct ib_cq *cq, struct ib_wc *wc)\n{\n\tstruct isert_conn *isert_conn = wc->qp->qp_context;\n\tstruct ib_device *ib_dev = isert_conn->device->ib_device;\n\n\tif (unlikely(wc->status != IB_WC_SUCCESS)) {\n\t\tisert_print_wc(wc, \"login recv\");\n\t\treturn;\n\t}\n\n\tib_dma_sync_single_for_cpu(ib_dev, isert_conn->login_desc->dma_addr,\n\t\t\tISER_RX_SIZE, DMA_FROM_DEVICE);\n\n\tisert_conn->login_req_len = wc->byte_len - ISER_HEADERS_LEN;\n\n\tif (isert_conn->conn) {\n\t\tstruct iscsi_login *login = isert_conn->conn->conn_login;\n\n\t\tif (login && !login->first_request)\n\t\t\tisert_rx_login_req(isert_conn);\n\t}\n\n\tmutex_lock(&isert_conn->mutex);\n\tcomplete(&isert_conn->login_req_comp);\n\tmutex_unlock(&isert_conn->mutex);\n\n\tib_dma_sync_single_for_device(ib_dev, isert_conn->login_desc->dma_addr,\n\t\t\t\tISER_RX_SIZE, DMA_FROM_DEVICE);\n}\n\nstatic void\nisert_rdma_rw_ctx_destroy(struct isert_cmd *cmd, struct isert_conn *conn)\n{\n\tstruct se_cmd *se_cmd = &cmd->iscsit_cmd->se_cmd;\n\tenum dma_data_direction dir = target_reverse_dma_direction(se_cmd);\n\n\tif (!cmd->rw.nr_ops)\n\t\treturn;\n\n\tif (isert_prot_cmd(conn, se_cmd)) {\n\t\trdma_rw_ctx_destroy_signature(&cmd->rw, conn->qp,\n\t\t\t\tconn->cm_id->port_num, se_cmd->t_data_sg,\n\t\t\t\tse_cmd->t_data_nents, se_cmd->t_prot_sg,\n\t\t\t\tse_cmd->t_prot_nents, dir);\n\t} else {\n\t\trdma_rw_ctx_destroy(&cmd->rw, conn->qp, conn->cm_id->port_num,\n\t\t\t\tse_cmd->t_data_sg, se_cmd->t_data_nents, dir);\n\t}\n\n\tcmd->rw.nr_ops = 0;\n}\n\nstatic void\nisert_put_cmd(struct isert_cmd *isert_cmd, bool comp_err)\n{\n\tstruct iscsit_cmd *cmd = isert_cmd->iscsit_cmd;\n\tstruct isert_conn *isert_conn = isert_cmd->conn;\n\tstruct iscsit_conn *conn = isert_conn->conn;\n\tstruct iscsi_text_rsp *hdr;\n\n\tisert_dbg(\"Cmd %p\\n\", isert_cmd);\n\n\tswitch (cmd->iscsi_opcode) {\n\tcase ISCSI_OP_SCSI_CMD:\n\t\tspin_lock_bh(&conn->cmd_lock);\n\t\tif (!list_empty(&cmd->i_conn_node))\n\t\t\tlist_del_init(&cmd->i_conn_node);\n\t\tspin_unlock_bh(&conn->cmd_lock);\n\n\t\tif (cmd->data_direction == DMA_TO_DEVICE) {\n\t\t\tiscsit_stop_dataout_timer(cmd);\n\t\t\t \n\t\t\tif (comp_err &&\n\t\t\t    cmd->se_cmd.t_state == TRANSPORT_WRITE_PENDING) {\n\t\t\t\tstruct se_cmd *se_cmd = &cmd->se_cmd;\n\n\t\t\t\ttarget_put_sess_cmd(se_cmd);\n\t\t\t}\n\t\t}\n\n\t\tisert_rdma_rw_ctx_destroy(isert_cmd, isert_conn);\n\t\ttransport_generic_free_cmd(&cmd->se_cmd, 0);\n\t\tbreak;\n\tcase ISCSI_OP_SCSI_TMFUNC:\n\t\tspin_lock_bh(&conn->cmd_lock);\n\t\tif (!list_empty(&cmd->i_conn_node))\n\t\t\tlist_del_init(&cmd->i_conn_node);\n\t\tspin_unlock_bh(&conn->cmd_lock);\n\n\t\ttransport_generic_free_cmd(&cmd->se_cmd, 0);\n\t\tbreak;\n\tcase ISCSI_OP_REJECT:\n\tcase ISCSI_OP_NOOP_OUT:\n\tcase ISCSI_OP_TEXT:\n\t\thdr = (struct iscsi_text_rsp *)&isert_cmd->tx_desc.iscsi_header;\n\t\t \n\t\tif (hdr->flags & ISCSI_FLAG_TEXT_CONTINUE)\n\t\t\tbreak;\n\n\t\tspin_lock_bh(&conn->cmd_lock);\n\t\tif (!list_empty(&cmd->i_conn_node))\n\t\t\tlist_del_init(&cmd->i_conn_node);\n\t\tspin_unlock_bh(&conn->cmd_lock);\n\n\t\t \n\t\tif (cmd->se_cmd.se_tfo != NULL) {\n\t\t\tisert_dbg(\"Calling transport_generic_free_cmd for 0x%02x\\n\",\n\t\t\t\t cmd->iscsi_opcode);\n\t\t\ttransport_generic_free_cmd(&cmd->se_cmd, 0);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tiscsit_release_cmd(cmd);\n\t\tbreak;\n\t}\n}\n\nstatic void\nisert_unmap_tx_desc(struct iser_tx_desc *tx_desc, struct ib_device *ib_dev)\n{\n\tif (tx_desc->dma_addr != 0) {\n\t\tisert_dbg(\"unmap single for tx_desc->dma_addr\\n\");\n\t\tib_dma_unmap_single(ib_dev, tx_desc->dma_addr,\n\t\t\t\t    ISER_HEADERS_LEN, DMA_TO_DEVICE);\n\t\ttx_desc->dma_addr = 0;\n\t}\n}\n\nstatic void\nisert_completion_put(struct iser_tx_desc *tx_desc, struct isert_cmd *isert_cmd,\n\t\t     struct ib_device *ib_dev, bool comp_err)\n{\n\tif (isert_cmd->pdu_buf_dma != 0) {\n\t\tisert_dbg(\"unmap single for isert_cmd->pdu_buf_dma\\n\");\n\t\tib_dma_unmap_single(ib_dev, isert_cmd->pdu_buf_dma,\n\t\t\t\t    isert_cmd->pdu_buf_len, DMA_TO_DEVICE);\n\t\tisert_cmd->pdu_buf_dma = 0;\n\t}\n\n\tisert_unmap_tx_desc(tx_desc, ib_dev);\n\tisert_put_cmd(isert_cmd, comp_err);\n}\n\nstatic int\nisert_check_pi_status(struct se_cmd *se_cmd, struct ib_mr *sig_mr)\n{\n\tstruct ib_mr_status mr_status;\n\tint ret;\n\n\tret = ib_check_mr_status(sig_mr, IB_MR_CHECK_SIG_STATUS, &mr_status);\n\tif (ret) {\n\t\tisert_err(\"ib_check_mr_status failed, ret %d\\n\", ret);\n\t\tgoto fail_mr_status;\n\t}\n\n\tif (mr_status.fail_status & IB_MR_CHECK_SIG_STATUS) {\n\t\tu64 sec_offset_err;\n\t\tu32 block_size = se_cmd->se_dev->dev_attrib.block_size + 8;\n\n\t\tswitch (mr_status.sig_err.err_type) {\n\t\tcase IB_SIG_BAD_GUARD:\n\t\t\tse_cmd->pi_err = TCM_LOGICAL_BLOCK_GUARD_CHECK_FAILED;\n\t\t\tbreak;\n\t\tcase IB_SIG_BAD_REFTAG:\n\t\t\tse_cmd->pi_err = TCM_LOGICAL_BLOCK_REF_TAG_CHECK_FAILED;\n\t\t\tbreak;\n\t\tcase IB_SIG_BAD_APPTAG:\n\t\t\tse_cmd->pi_err = TCM_LOGICAL_BLOCK_APP_TAG_CHECK_FAILED;\n\t\t\tbreak;\n\t\t}\n\t\tsec_offset_err = mr_status.sig_err.sig_err_offset;\n\t\tdo_div(sec_offset_err, block_size);\n\t\tse_cmd->sense_info = sec_offset_err + se_cmd->t_task_lba;\n\n\t\tisert_err(\"PI error found type %d at sector 0x%llx \"\n\t\t\t  \"expected 0x%x vs actual 0x%x\\n\",\n\t\t\t  mr_status.sig_err.err_type,\n\t\t\t  (unsigned long long)se_cmd->sense_info,\n\t\t\t  mr_status.sig_err.expected,\n\t\t\t  mr_status.sig_err.actual);\n\t\tret = 1;\n\t}\n\nfail_mr_status:\n\treturn ret;\n}\n\nstatic void\nisert_rdma_write_done(struct ib_cq *cq, struct ib_wc *wc)\n{\n\tstruct isert_conn *isert_conn = wc->qp->qp_context;\n\tstruct isert_device *device = isert_conn->device;\n\tstruct iser_tx_desc *desc = cqe_to_tx_desc(wc->wr_cqe);\n\tstruct isert_cmd *isert_cmd = tx_desc_to_cmd(desc);\n\tstruct se_cmd *cmd = &isert_cmd->iscsit_cmd->se_cmd;\n\tint ret = 0;\n\n\tif (unlikely(wc->status != IB_WC_SUCCESS)) {\n\t\tisert_print_wc(wc, \"rdma write\");\n\t\tif (wc->status != IB_WC_WR_FLUSH_ERR)\n\t\t\tiscsit_cause_connection_reinstatement(isert_conn->conn, 0);\n\t\tisert_completion_put(desc, isert_cmd, device->ib_device, true);\n\t\treturn;\n\t}\n\n\tisert_dbg(\"Cmd %p\\n\", isert_cmd);\n\n\tret = isert_check_pi_status(cmd, isert_cmd->rw.reg->mr);\n\tisert_rdma_rw_ctx_destroy(isert_cmd, isert_conn);\n\n\tif (ret) {\n\t\t \n\t\tkref_get(&cmd->cmd_kref);\n\t\ttransport_generic_request_failure(cmd, cmd->pi_err);\n\t} else {\n\t\t \n\t\tret = isert_put_response(isert_conn->conn, isert_cmd->iscsit_cmd);\n\t\tif (ret)\n\t\t\tpr_warn_ratelimited(\"isert_put_response() ret: %d\\n\", ret);\n\t}\n}\n\nstatic void\nisert_rdma_read_done(struct ib_cq *cq, struct ib_wc *wc)\n{\n\tstruct isert_conn *isert_conn = wc->qp->qp_context;\n\tstruct isert_device *device = isert_conn->device;\n\tstruct iser_tx_desc *desc = cqe_to_tx_desc(wc->wr_cqe);\n\tstruct isert_cmd *isert_cmd = tx_desc_to_cmd(desc);\n\tstruct iscsit_cmd *cmd = isert_cmd->iscsit_cmd;\n\tstruct se_cmd *se_cmd = &cmd->se_cmd;\n\tint ret = 0;\n\n\tif (unlikely(wc->status != IB_WC_SUCCESS)) {\n\t\tisert_print_wc(wc, \"rdma read\");\n\t\tif (wc->status != IB_WC_WR_FLUSH_ERR)\n\t\t\tiscsit_cause_connection_reinstatement(isert_conn->conn, 0);\n\t\tisert_completion_put(desc, isert_cmd, device->ib_device, true);\n\t\treturn;\n\t}\n\n\tisert_dbg(\"Cmd %p\\n\", isert_cmd);\n\n\tiscsit_stop_dataout_timer(cmd);\n\n\tif (isert_prot_cmd(isert_conn, se_cmd))\n\t\tret = isert_check_pi_status(se_cmd, isert_cmd->rw.reg->mr);\n\tisert_rdma_rw_ctx_destroy(isert_cmd, isert_conn);\n\tcmd->write_data_done = 0;\n\n\tisert_dbg(\"Cmd: %p RDMA_READ comp calling execute_cmd\\n\", isert_cmd);\n\tspin_lock_bh(&cmd->istate_lock);\n\tcmd->cmd_flags |= ICF_GOT_LAST_DATAOUT;\n\tcmd->i_state = ISTATE_RECEIVED_LAST_DATAOUT;\n\tspin_unlock_bh(&cmd->istate_lock);\n\n\t \n\tif (ret)\n\t\ttransport_generic_request_failure(se_cmd, se_cmd->pi_err);\n\telse\n\t\ttarget_execute_cmd(se_cmd);\n}\n\nstatic void\nisert_do_control_comp(struct work_struct *work)\n{\n\tstruct isert_cmd *isert_cmd = container_of(work,\n\t\t\tstruct isert_cmd, comp_work);\n\tstruct isert_conn *isert_conn = isert_cmd->conn;\n\tstruct ib_device *ib_dev = isert_conn->cm_id->device;\n\tstruct iscsit_cmd *cmd = isert_cmd->iscsit_cmd;\n\n\tisert_dbg(\"Cmd %p i_state %d\\n\", isert_cmd, cmd->i_state);\n\n\tswitch (cmd->i_state) {\n\tcase ISTATE_SEND_TASKMGTRSP:\n\t\tiscsit_tmr_post_handler(cmd, cmd->conn);\n\t\tfallthrough;\n\tcase ISTATE_SEND_REJECT:\n\tcase ISTATE_SEND_TEXTRSP:\n\t\tcmd->i_state = ISTATE_SENT_STATUS;\n\t\tisert_completion_put(&isert_cmd->tx_desc, isert_cmd,\n\t\t\t\t     ib_dev, false);\n\t\tbreak;\n\tcase ISTATE_SEND_LOGOUTRSP:\n\t\tiscsit_logout_post_handler(cmd, cmd->conn);\n\t\tbreak;\n\tdefault:\n\t\tisert_err(\"Unknown i_state %d\\n\", cmd->i_state);\n\t\tdump_stack();\n\t\tbreak;\n\t}\n}\n\nstatic void\nisert_login_send_done(struct ib_cq *cq, struct ib_wc *wc)\n{\n\tstruct isert_conn *isert_conn = wc->qp->qp_context;\n\tstruct ib_device *ib_dev = isert_conn->cm_id->device;\n\tstruct iser_tx_desc *tx_desc = cqe_to_tx_desc(wc->wr_cqe);\n\n\tif (unlikely(wc->status != IB_WC_SUCCESS)) {\n\t\tisert_print_wc(wc, \"login send\");\n\t\tif (wc->status != IB_WC_WR_FLUSH_ERR)\n\t\t\tiscsit_cause_connection_reinstatement(isert_conn->conn, 0);\n\t}\n\n\tisert_unmap_tx_desc(tx_desc, ib_dev);\n}\n\nstatic void\nisert_send_done(struct ib_cq *cq, struct ib_wc *wc)\n{\n\tstruct isert_conn *isert_conn = wc->qp->qp_context;\n\tstruct ib_device *ib_dev = isert_conn->cm_id->device;\n\tstruct iser_tx_desc *tx_desc = cqe_to_tx_desc(wc->wr_cqe);\n\tstruct isert_cmd *isert_cmd = tx_desc_to_cmd(tx_desc);\n\n\tif (unlikely(wc->status != IB_WC_SUCCESS)) {\n\t\tisert_print_wc(wc, \"send\");\n\t\tif (wc->status != IB_WC_WR_FLUSH_ERR)\n\t\t\tiscsit_cause_connection_reinstatement(isert_conn->conn, 0);\n\t\tisert_completion_put(tx_desc, isert_cmd, ib_dev, true);\n\t\treturn;\n\t}\n\n\tisert_dbg(\"Cmd %p\\n\", isert_cmd);\n\n\tswitch (isert_cmd->iscsit_cmd->i_state) {\n\tcase ISTATE_SEND_TASKMGTRSP:\n\tcase ISTATE_SEND_LOGOUTRSP:\n\tcase ISTATE_SEND_REJECT:\n\tcase ISTATE_SEND_TEXTRSP:\n\t\tisert_unmap_tx_desc(tx_desc, ib_dev);\n\n\t\tINIT_WORK(&isert_cmd->comp_work, isert_do_control_comp);\n\t\tqueue_work(isert_comp_wq, &isert_cmd->comp_work);\n\t\treturn;\n\tdefault:\n\t\tisert_cmd->iscsit_cmd->i_state = ISTATE_SENT_STATUS;\n\t\tisert_completion_put(tx_desc, isert_cmd, ib_dev, false);\n\t\tbreak;\n\t}\n}\n\nstatic int\nisert_post_response(struct isert_conn *isert_conn, struct isert_cmd *isert_cmd)\n{\n\tint ret;\n\n\tret = isert_post_recv(isert_conn, isert_cmd->rx_desc);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ib_post_send(isert_conn->qp, &isert_cmd->tx_desc.send_wr, NULL);\n\tif (ret) {\n\t\tisert_err(\"ib_post_send failed with %d\\n\", ret);\n\t\treturn ret;\n\t}\n\treturn ret;\n}\n\nstatic int\nisert_put_response(struct iscsit_conn *conn, struct iscsit_cmd *cmd)\n{\n\tstruct isert_cmd *isert_cmd = iscsit_priv_cmd(cmd);\n\tstruct isert_conn *isert_conn = conn->context;\n\tstruct ib_send_wr *send_wr = &isert_cmd->tx_desc.send_wr;\n\tstruct iscsi_scsi_rsp *hdr = (struct iscsi_scsi_rsp *)\n\t\t\t\t&isert_cmd->tx_desc.iscsi_header;\n\n\tisert_create_send_desc(isert_conn, isert_cmd, &isert_cmd->tx_desc);\n\tiscsit_build_rsp_pdu(cmd, conn, true, hdr);\n\tisert_init_tx_hdrs(isert_conn, &isert_cmd->tx_desc);\n\t \n\tif (cmd->se_cmd.sense_buffer &&\n\t    ((cmd->se_cmd.se_cmd_flags & SCF_TRANSPORT_TASK_SENSE) ||\n\t    (cmd->se_cmd.se_cmd_flags & SCF_EMULATED_TASK_SENSE))) {\n\t\tstruct isert_device *device = isert_conn->device;\n\t\tstruct ib_device *ib_dev = device->ib_device;\n\t\tstruct ib_sge *tx_dsg = &isert_cmd->tx_desc.tx_sg[1];\n\t\tu32 padding, pdu_len;\n\n\t\tput_unaligned_be16(cmd->se_cmd.scsi_sense_length,\n\t\t\t\t   cmd->sense_buffer);\n\t\tcmd->se_cmd.scsi_sense_length += sizeof(__be16);\n\n\t\tpadding = -(cmd->se_cmd.scsi_sense_length) & 3;\n\t\thton24(hdr->dlength, (u32)cmd->se_cmd.scsi_sense_length);\n\t\tpdu_len = cmd->se_cmd.scsi_sense_length + padding;\n\n\t\tisert_cmd->pdu_buf_dma = ib_dma_map_single(ib_dev,\n\t\t\t\t(void *)cmd->sense_buffer, pdu_len,\n\t\t\t\tDMA_TO_DEVICE);\n\t\tif (ib_dma_mapping_error(ib_dev, isert_cmd->pdu_buf_dma))\n\t\t\treturn -ENOMEM;\n\n\t\tisert_cmd->pdu_buf_len = pdu_len;\n\t\ttx_dsg->addr\t= isert_cmd->pdu_buf_dma;\n\t\ttx_dsg->length\t= pdu_len;\n\t\ttx_dsg->lkey\t= device->pd->local_dma_lkey;\n\t\tisert_cmd->tx_desc.num_sge = 2;\n\t}\n\n\tisert_init_send_wr(isert_conn, isert_cmd, send_wr);\n\n\tisert_dbg(\"Posting SCSI Response\\n\");\n\n\treturn isert_post_response(isert_conn, isert_cmd);\n}\n\nstatic void\nisert_aborted_task(struct iscsit_conn *conn, struct iscsit_cmd *cmd)\n{\n\tstruct isert_cmd *isert_cmd = iscsit_priv_cmd(cmd);\n\tstruct isert_conn *isert_conn = conn->context;\n\n\tspin_lock_bh(&conn->cmd_lock);\n\tif (!list_empty(&cmd->i_conn_node))\n\t\tlist_del_init(&cmd->i_conn_node);\n\tspin_unlock_bh(&conn->cmd_lock);\n\n\tif (cmd->data_direction == DMA_TO_DEVICE)\n\t\tiscsit_stop_dataout_timer(cmd);\n\tisert_rdma_rw_ctx_destroy(isert_cmd, isert_conn);\n}\n\nstatic enum target_prot_op\nisert_get_sup_prot_ops(struct iscsit_conn *conn)\n{\n\tstruct isert_conn *isert_conn = conn->context;\n\tstruct isert_device *device = isert_conn->device;\n\n\tif (conn->tpg->tpg_attrib.t10_pi) {\n\t\tif (device->pi_capable) {\n\t\t\tisert_info(\"conn %p PI offload enabled\\n\", isert_conn);\n\t\t\tisert_conn->pi_support = true;\n\t\t\treturn TARGET_PROT_ALL;\n\t\t}\n\t}\n\n\tisert_info(\"conn %p PI offload disabled\\n\", isert_conn);\n\tisert_conn->pi_support = false;\n\n\treturn TARGET_PROT_NORMAL;\n}\n\nstatic int\nisert_put_nopin(struct iscsit_cmd *cmd, struct iscsit_conn *conn,\n\t\tbool nopout_response)\n{\n\tstruct isert_cmd *isert_cmd = iscsit_priv_cmd(cmd);\n\tstruct isert_conn *isert_conn = conn->context;\n\tstruct ib_send_wr *send_wr = &isert_cmd->tx_desc.send_wr;\n\n\tisert_create_send_desc(isert_conn, isert_cmd, &isert_cmd->tx_desc);\n\tiscsit_build_nopin_rsp(cmd, conn, (struct iscsi_nopin *)\n\t\t\t       &isert_cmd->tx_desc.iscsi_header,\n\t\t\t       nopout_response);\n\tisert_init_tx_hdrs(isert_conn, &isert_cmd->tx_desc);\n\tisert_init_send_wr(isert_conn, isert_cmd, send_wr);\n\n\tisert_dbg(\"conn %p Posting NOPIN Response\\n\", isert_conn);\n\n\treturn isert_post_response(isert_conn, isert_cmd);\n}\n\nstatic int\nisert_put_logout_rsp(struct iscsit_cmd *cmd, struct iscsit_conn *conn)\n{\n\tstruct isert_cmd *isert_cmd = iscsit_priv_cmd(cmd);\n\tstruct isert_conn *isert_conn = conn->context;\n\tstruct ib_send_wr *send_wr = &isert_cmd->tx_desc.send_wr;\n\n\tisert_create_send_desc(isert_conn, isert_cmd, &isert_cmd->tx_desc);\n\tiscsit_build_logout_rsp(cmd, conn, (struct iscsi_logout_rsp *)\n\t\t\t\t&isert_cmd->tx_desc.iscsi_header);\n\tisert_init_tx_hdrs(isert_conn, &isert_cmd->tx_desc);\n\tisert_init_send_wr(isert_conn, isert_cmd, send_wr);\n\n\tisert_dbg(\"conn %p Posting Logout Response\\n\", isert_conn);\n\n\treturn isert_post_response(isert_conn, isert_cmd);\n}\n\nstatic int\nisert_put_tm_rsp(struct iscsit_cmd *cmd, struct iscsit_conn *conn)\n{\n\tstruct isert_cmd *isert_cmd = iscsit_priv_cmd(cmd);\n\tstruct isert_conn *isert_conn = conn->context;\n\tstruct ib_send_wr *send_wr = &isert_cmd->tx_desc.send_wr;\n\n\tisert_create_send_desc(isert_conn, isert_cmd, &isert_cmd->tx_desc);\n\tiscsit_build_task_mgt_rsp(cmd, conn, (struct iscsi_tm_rsp *)\n\t\t\t\t  &isert_cmd->tx_desc.iscsi_header);\n\tisert_init_tx_hdrs(isert_conn, &isert_cmd->tx_desc);\n\tisert_init_send_wr(isert_conn, isert_cmd, send_wr);\n\n\tisert_dbg(\"conn %p Posting Task Management Response\\n\", isert_conn);\n\n\treturn isert_post_response(isert_conn, isert_cmd);\n}\n\nstatic int\nisert_put_reject(struct iscsit_cmd *cmd, struct iscsit_conn *conn)\n{\n\tstruct isert_cmd *isert_cmd = iscsit_priv_cmd(cmd);\n\tstruct isert_conn *isert_conn = conn->context;\n\tstruct ib_send_wr *send_wr = &isert_cmd->tx_desc.send_wr;\n\tstruct isert_device *device = isert_conn->device;\n\tstruct ib_device *ib_dev = device->ib_device;\n\tstruct ib_sge *tx_dsg = &isert_cmd->tx_desc.tx_sg[1];\n\tstruct iscsi_reject *hdr =\n\t\t(struct iscsi_reject *)&isert_cmd->tx_desc.iscsi_header;\n\n\tisert_create_send_desc(isert_conn, isert_cmd, &isert_cmd->tx_desc);\n\tiscsit_build_reject(cmd, conn, hdr);\n\tisert_init_tx_hdrs(isert_conn, &isert_cmd->tx_desc);\n\n\thton24(hdr->dlength, ISCSI_HDR_LEN);\n\tisert_cmd->pdu_buf_dma = ib_dma_map_single(ib_dev,\n\t\t\t(void *)cmd->buf_ptr, ISCSI_HDR_LEN,\n\t\t\tDMA_TO_DEVICE);\n\tif (ib_dma_mapping_error(ib_dev, isert_cmd->pdu_buf_dma))\n\t\treturn -ENOMEM;\n\tisert_cmd->pdu_buf_len = ISCSI_HDR_LEN;\n\ttx_dsg->addr\t= isert_cmd->pdu_buf_dma;\n\ttx_dsg->length\t= ISCSI_HDR_LEN;\n\ttx_dsg->lkey\t= device->pd->local_dma_lkey;\n\tisert_cmd->tx_desc.num_sge = 2;\n\n\tisert_init_send_wr(isert_conn, isert_cmd, send_wr);\n\n\tisert_dbg(\"conn %p Posting Reject\\n\", isert_conn);\n\n\treturn isert_post_response(isert_conn, isert_cmd);\n}\n\nstatic int\nisert_put_text_rsp(struct iscsit_cmd *cmd, struct iscsit_conn *conn)\n{\n\tstruct isert_cmd *isert_cmd = iscsit_priv_cmd(cmd);\n\tstruct isert_conn *isert_conn = conn->context;\n\tstruct ib_send_wr *send_wr = &isert_cmd->tx_desc.send_wr;\n\tstruct iscsi_text_rsp *hdr =\n\t\t(struct iscsi_text_rsp *)&isert_cmd->tx_desc.iscsi_header;\n\tu32 txt_rsp_len;\n\tint rc;\n\n\tisert_create_send_desc(isert_conn, isert_cmd, &isert_cmd->tx_desc);\n\trc = iscsit_build_text_rsp(cmd, conn, hdr, ISCSI_INFINIBAND);\n\tif (rc < 0)\n\t\treturn rc;\n\n\ttxt_rsp_len = rc;\n\tisert_init_tx_hdrs(isert_conn, &isert_cmd->tx_desc);\n\n\tif (txt_rsp_len) {\n\t\tstruct isert_device *device = isert_conn->device;\n\t\tstruct ib_device *ib_dev = device->ib_device;\n\t\tstruct ib_sge *tx_dsg = &isert_cmd->tx_desc.tx_sg[1];\n\t\tvoid *txt_rsp_buf = cmd->buf_ptr;\n\n\t\tisert_cmd->pdu_buf_dma = ib_dma_map_single(ib_dev,\n\t\t\t\ttxt_rsp_buf, txt_rsp_len, DMA_TO_DEVICE);\n\t\tif (ib_dma_mapping_error(ib_dev, isert_cmd->pdu_buf_dma))\n\t\t\treturn -ENOMEM;\n\n\t\tisert_cmd->pdu_buf_len = txt_rsp_len;\n\t\ttx_dsg->addr\t= isert_cmd->pdu_buf_dma;\n\t\ttx_dsg->length\t= txt_rsp_len;\n\t\ttx_dsg->lkey\t= device->pd->local_dma_lkey;\n\t\tisert_cmd->tx_desc.num_sge = 2;\n\t}\n\tisert_init_send_wr(isert_conn, isert_cmd, send_wr);\n\n\tisert_dbg(\"conn %p Text Response\\n\", isert_conn);\n\n\treturn isert_post_response(isert_conn, isert_cmd);\n}\n\nstatic inline void\nisert_set_dif_domain(struct se_cmd *se_cmd, struct ib_sig_domain *domain)\n{\n\tdomain->sig_type = IB_SIG_TYPE_T10_DIF;\n\tdomain->sig.dif.bg_type = IB_T10DIF_CRC;\n\tdomain->sig.dif.pi_interval = se_cmd->se_dev->dev_attrib.block_size;\n\tdomain->sig.dif.ref_tag = se_cmd->reftag_seed;\n\t \n\tdomain->sig.dif.apptag_check_mask = 0xffff;\n\tdomain->sig.dif.app_escape = true;\n\tdomain->sig.dif.ref_escape = true;\n\tif (se_cmd->prot_type == TARGET_DIF_TYPE1_PROT ||\n\t    se_cmd->prot_type == TARGET_DIF_TYPE2_PROT)\n\t\tdomain->sig.dif.ref_remap = true;\n}\n\nstatic int\nisert_set_sig_attrs(struct se_cmd *se_cmd, struct ib_sig_attrs *sig_attrs)\n{\n\tmemset(sig_attrs, 0, sizeof(*sig_attrs));\n\n\tswitch (se_cmd->prot_op) {\n\tcase TARGET_PROT_DIN_INSERT:\n\tcase TARGET_PROT_DOUT_STRIP:\n\t\tsig_attrs->mem.sig_type = IB_SIG_TYPE_NONE;\n\t\tisert_set_dif_domain(se_cmd, &sig_attrs->wire);\n\t\tbreak;\n\tcase TARGET_PROT_DOUT_INSERT:\n\tcase TARGET_PROT_DIN_STRIP:\n\t\tsig_attrs->wire.sig_type = IB_SIG_TYPE_NONE;\n\t\tisert_set_dif_domain(se_cmd, &sig_attrs->mem);\n\t\tbreak;\n\tcase TARGET_PROT_DIN_PASS:\n\tcase TARGET_PROT_DOUT_PASS:\n\t\tisert_set_dif_domain(se_cmd, &sig_attrs->wire);\n\t\tisert_set_dif_domain(se_cmd, &sig_attrs->mem);\n\t\tbreak;\n\tdefault:\n\t\tisert_err(\"Unsupported PI operation %d\\n\", se_cmd->prot_op);\n\t\treturn -EINVAL;\n\t}\n\n\tif (se_cmd->prot_checks & TARGET_DIF_CHECK_GUARD)\n\t\tsig_attrs->check_mask |= IB_SIG_CHECK_GUARD;\n\tif (se_cmd->prot_checks & TARGET_DIF_CHECK_APPTAG)\n\t\tsig_attrs->check_mask |= IB_SIG_CHECK_APPTAG;\n\tif (se_cmd->prot_checks & TARGET_DIF_CHECK_REFTAG)\n\t\tsig_attrs->check_mask |= IB_SIG_CHECK_REFTAG;\n\n\treturn 0;\n}\n\nstatic int\nisert_rdma_rw_ctx_post(struct isert_cmd *cmd, struct isert_conn *conn,\n\t\tstruct ib_cqe *cqe, struct ib_send_wr *chain_wr)\n{\n\tstruct se_cmd *se_cmd = &cmd->iscsit_cmd->se_cmd;\n\tenum dma_data_direction dir = target_reverse_dma_direction(se_cmd);\n\tu8 port_num = conn->cm_id->port_num;\n\tu64 addr;\n\tu32 rkey, offset;\n\tint ret;\n\n\tif (cmd->ctx_init_done)\n\t\tgoto rdma_ctx_post;\n\n\tif (dir == DMA_FROM_DEVICE) {\n\t\taddr = cmd->write_va;\n\t\trkey = cmd->write_stag;\n\t\toffset = cmd->iscsit_cmd->write_data_done;\n\t} else {\n\t\taddr = cmd->read_va;\n\t\trkey = cmd->read_stag;\n\t\toffset = 0;\n\t}\n\n\tif (isert_prot_cmd(conn, se_cmd)) {\n\t\tstruct ib_sig_attrs sig_attrs;\n\n\t\tret = isert_set_sig_attrs(se_cmd, &sig_attrs);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tWARN_ON_ONCE(offset);\n\t\tret = rdma_rw_ctx_signature_init(&cmd->rw, conn->qp, port_num,\n\t\t\t\tse_cmd->t_data_sg, se_cmd->t_data_nents,\n\t\t\t\tse_cmd->t_prot_sg, se_cmd->t_prot_nents,\n\t\t\t\t&sig_attrs, addr, rkey, dir);\n\t} else {\n\t\tret = rdma_rw_ctx_init(&cmd->rw, conn->qp, port_num,\n\t\t\t\tse_cmd->t_data_sg, se_cmd->t_data_nents,\n\t\t\t\toffset, addr, rkey, dir);\n\t}\n\n\tif (ret < 0) {\n\t\tisert_err(\"Cmd: %p failed to prepare RDMA res\\n\", cmd);\n\t\treturn ret;\n\t}\n\n\tcmd->ctx_init_done = true;\n\nrdma_ctx_post:\n\tret = rdma_rw_ctx_post(&cmd->rw, conn->qp, port_num, cqe, chain_wr);\n\tif (ret < 0)\n\t\tisert_err(\"Cmd: %p failed to post RDMA res\\n\", cmd);\n\treturn ret;\n}\n\nstatic int\nisert_put_datain(struct iscsit_conn *conn, struct iscsit_cmd *cmd)\n{\n\tstruct se_cmd *se_cmd = &cmd->se_cmd;\n\tstruct isert_cmd *isert_cmd = iscsit_priv_cmd(cmd);\n\tstruct isert_conn *isert_conn = conn->context;\n\tstruct ib_cqe *cqe = NULL;\n\tstruct ib_send_wr *chain_wr = NULL;\n\tint rc;\n\n\tisert_dbg(\"Cmd: %p RDMA_WRITE data_length: %u\\n\",\n\t\t isert_cmd, se_cmd->data_length);\n\n\tif (isert_prot_cmd(isert_conn, se_cmd)) {\n\t\tisert_cmd->tx_desc.tx_cqe.done = isert_rdma_write_done;\n\t\tcqe = &isert_cmd->tx_desc.tx_cqe;\n\t} else {\n\t\t \n\t\tisert_create_send_desc(isert_conn, isert_cmd,\n\t\t\t\t       &isert_cmd->tx_desc);\n\t\tiscsit_build_rsp_pdu(cmd, conn, true, (struct iscsi_scsi_rsp *)\n\t\t\t\t     &isert_cmd->tx_desc.iscsi_header);\n\t\tisert_init_tx_hdrs(isert_conn, &isert_cmd->tx_desc);\n\t\tisert_init_send_wr(isert_conn, isert_cmd,\n\t\t\t\t   &isert_cmd->tx_desc.send_wr);\n\n\t\trc = isert_post_recv(isert_conn, isert_cmd->rx_desc);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tchain_wr = &isert_cmd->tx_desc.send_wr;\n\t}\n\n\trc = isert_rdma_rw_ctx_post(isert_cmd, isert_conn, cqe, chain_wr);\n\tisert_dbg(\"Cmd: %p posted RDMA_WRITE for iSER Data READ rc: %d\\n\",\n\t\t  isert_cmd, rc);\n\treturn rc;\n}\n\nstatic int\nisert_get_dataout(struct iscsit_conn *conn, struct iscsit_cmd *cmd, bool recovery)\n{\n\tstruct isert_cmd *isert_cmd = iscsit_priv_cmd(cmd);\n\tint ret;\n\n\tisert_dbg(\"Cmd: %p RDMA_READ data_length: %u write_data_done: %u\\n\",\n\t\t isert_cmd, cmd->se_cmd.data_length, cmd->write_data_done);\n\n\tisert_cmd->tx_desc.tx_cqe.done = isert_rdma_read_done;\n\tret = isert_rdma_rw_ctx_post(isert_cmd, conn->context,\n\t\t\t\t     &isert_cmd->tx_desc.tx_cqe, NULL);\n\n\tisert_dbg(\"Cmd: %p posted RDMA_READ memory for ISER Data WRITE rc: %d\\n\",\n\t\t isert_cmd, ret);\n\treturn ret;\n}\n\nstatic int\nisert_immediate_queue(struct iscsit_conn *conn, struct iscsit_cmd *cmd, int state)\n{\n\tstruct isert_cmd *isert_cmd = iscsit_priv_cmd(cmd);\n\tint ret = 0;\n\n\tswitch (state) {\n\tcase ISTATE_REMOVE:\n\t\tspin_lock_bh(&conn->cmd_lock);\n\t\tlist_del_init(&cmd->i_conn_node);\n\t\tspin_unlock_bh(&conn->cmd_lock);\n\t\tisert_put_cmd(isert_cmd, true);\n\t\tbreak;\n\tcase ISTATE_SEND_NOPIN_WANT_RESPONSE:\n\t\tret = isert_put_nopin(cmd, conn, false);\n\t\tbreak;\n\tdefault:\n\t\tisert_err(\"Unknown immediate state: 0x%02x\\n\", state);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int\nisert_response_queue(struct iscsit_conn *conn, struct iscsit_cmd *cmd, int state)\n{\n\tstruct isert_conn *isert_conn = conn->context;\n\tint ret;\n\n\tswitch (state) {\n\tcase ISTATE_SEND_LOGOUTRSP:\n\t\tret = isert_put_logout_rsp(cmd, conn);\n\t\tif (!ret)\n\t\t\tisert_conn->logout_posted = true;\n\t\tbreak;\n\tcase ISTATE_SEND_NOPIN:\n\t\tret = isert_put_nopin(cmd, conn, true);\n\t\tbreak;\n\tcase ISTATE_SEND_TASKMGTRSP:\n\t\tret = isert_put_tm_rsp(cmd, conn);\n\t\tbreak;\n\tcase ISTATE_SEND_REJECT:\n\t\tret = isert_put_reject(cmd, conn);\n\t\tbreak;\n\tcase ISTATE_SEND_TEXTRSP:\n\t\tret = isert_put_text_rsp(cmd, conn);\n\t\tbreak;\n\tcase ISTATE_SEND_STATUS:\n\t\t \n\t\tret = isert_put_response(conn, cmd);\n\t\tbreak;\n\tdefault:\n\t\tisert_err(\"Unknown response state: 0x%02x\\n\", state);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstruct rdma_cm_id *\nisert_setup_id(struct isert_np *isert_np)\n{\n\tstruct iscsi_np *np = isert_np->np;\n\tstruct rdma_cm_id *id;\n\tstruct sockaddr *sa;\n\tint ret;\n\n\tsa = (struct sockaddr *)&np->np_sockaddr;\n\tisert_dbg(\"ksockaddr: %p, sa: %p\\n\", &np->np_sockaddr, sa);\n\n\tid = rdma_create_id(&init_net, isert_cma_handler, isert_np,\n\t\t\t    RDMA_PS_TCP, IB_QPT_RC);\n\tif (IS_ERR(id)) {\n\t\tisert_err(\"rdma_create_id() failed: %ld\\n\", PTR_ERR(id));\n\t\tret = PTR_ERR(id);\n\t\tgoto out;\n\t}\n\tisert_dbg(\"id %p context %p\\n\", id, id->context);\n\n\t \n\tret = rdma_set_afonly(id, 1);\n\tif (ret) {\n\t\tisert_err(\"rdma_set_afonly() failed: %d\\n\", ret);\n\t\tgoto out_id;\n\t}\n\n\tret = rdma_bind_addr(id, sa);\n\tif (ret) {\n\t\tisert_err(\"rdma_bind_addr() failed: %d\\n\", ret);\n\t\tgoto out_id;\n\t}\n\n\tret = rdma_listen(id, 0);\n\tif (ret) {\n\t\tisert_err(\"rdma_listen() failed: %d\\n\", ret);\n\t\tgoto out_id;\n\t}\n\n\treturn id;\nout_id:\n\trdma_destroy_id(id);\nout:\n\treturn ERR_PTR(ret);\n}\n\nstatic int\nisert_setup_np(struct iscsi_np *np,\n\t       struct sockaddr_storage *ksockaddr)\n{\n\tstruct isert_np *isert_np;\n\tstruct rdma_cm_id *isert_lid;\n\tint ret;\n\n\tisert_np = kzalloc(sizeof(struct isert_np), GFP_KERNEL);\n\tif (!isert_np)\n\t\treturn -ENOMEM;\n\n\tsema_init(&isert_np->sem, 0);\n\tmutex_init(&isert_np->mutex);\n\tINIT_LIST_HEAD(&isert_np->accepted);\n\tINIT_LIST_HEAD(&isert_np->pending);\n\tisert_np->np = np;\n\n\t \n\tmemcpy(&np->np_sockaddr, ksockaddr,\n\t       sizeof(struct sockaddr_storage));\n\n\tisert_lid = isert_setup_id(isert_np);\n\tif (IS_ERR(isert_lid)) {\n\t\tret = PTR_ERR(isert_lid);\n\t\tgoto out;\n\t}\n\n\tisert_np->cm_id = isert_lid;\n\tnp->np_context = isert_np;\n\n\treturn 0;\n\nout:\n\tkfree(isert_np);\n\n\treturn ret;\n}\n\nstatic int\nisert_rdma_accept(struct isert_conn *isert_conn)\n{\n\tstruct rdma_cm_id *cm_id = isert_conn->cm_id;\n\tstruct rdma_conn_param cp;\n\tint ret;\n\tstruct iser_cm_hdr rsp_hdr;\n\n\tmemset(&cp, 0, sizeof(struct rdma_conn_param));\n\tcp.initiator_depth = isert_conn->initiator_depth;\n\tcp.retry_count = 7;\n\tcp.rnr_retry_count = 7;\n\n\tmemset(&rsp_hdr, 0, sizeof(rsp_hdr));\n\trsp_hdr.flags = ISERT_ZBVA_NOT_USED;\n\tif (!isert_conn->snd_w_inv)\n\t\trsp_hdr.flags = rsp_hdr.flags | ISERT_SEND_W_INV_NOT_USED;\n\tcp.private_data = (void *)&rsp_hdr;\n\tcp.private_data_len = sizeof(rsp_hdr);\n\n\tret = rdma_accept(cm_id, &cp);\n\tif (ret) {\n\t\tisert_err(\"rdma_accept() failed with: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nisert_get_login_rx(struct iscsit_conn *conn, struct iscsi_login *login)\n{\n\tstruct isert_conn *isert_conn = conn->context;\n\tint ret;\n\n\tisert_info(\"before login_req comp conn: %p\\n\", isert_conn);\n\tret = wait_for_completion_interruptible(&isert_conn->login_req_comp);\n\tif (ret) {\n\t\tisert_err(\"isert_conn %p interrupted before got login req\\n\",\n\t\t\t  isert_conn);\n\t\treturn ret;\n\t}\n\treinit_completion(&isert_conn->login_req_comp);\n\n\t \n\tif (!login->first_request)\n\t\treturn 0;\n\n\tisert_rx_login_req(isert_conn);\n\n\tisert_info(\"before login_comp conn: %p\\n\", conn);\n\tret = wait_for_completion_interruptible(&isert_conn->login_comp);\n\tif (ret)\n\t\treturn ret;\n\n\tisert_info(\"processing login->req: %p\\n\", login->req);\n\n\treturn 0;\n}\n\nstatic void\nisert_set_conn_info(struct iscsi_np *np, struct iscsit_conn *conn,\n\t\t    struct isert_conn *isert_conn)\n{\n\tstruct rdma_cm_id *cm_id = isert_conn->cm_id;\n\tstruct rdma_route *cm_route = &cm_id->route;\n\n\tconn->login_family = np->np_sockaddr.ss_family;\n\n\tconn->login_sockaddr = cm_route->addr.dst_addr;\n\tconn->local_sockaddr = cm_route->addr.src_addr;\n}\n\nstatic int\nisert_accept_np(struct iscsi_np *np, struct iscsit_conn *conn)\n{\n\tstruct isert_np *isert_np = np->np_context;\n\tstruct isert_conn *isert_conn;\n\tint ret;\n\naccept_wait:\n\tret = down_interruptible(&isert_np->sem);\n\tif (ret)\n\t\treturn -ENODEV;\n\n\tspin_lock_bh(&np->np_thread_lock);\n\tif (np->np_thread_state >= ISCSI_NP_THREAD_RESET) {\n\t\tspin_unlock_bh(&np->np_thread_lock);\n\t\tisert_dbg(\"np_thread_state %d\\n\",\n\t\t\t np->np_thread_state);\n\t\t \n\t\treturn -ENODEV;\n\t}\n\tspin_unlock_bh(&np->np_thread_lock);\n\n\tmutex_lock(&isert_np->mutex);\n\tif (list_empty(&isert_np->pending)) {\n\t\tmutex_unlock(&isert_np->mutex);\n\t\tgoto accept_wait;\n\t}\n\tisert_conn = list_first_entry(&isert_np->pending,\n\t\t\tstruct isert_conn, node);\n\tlist_del_init(&isert_conn->node);\n\tmutex_unlock(&isert_np->mutex);\n\n\tconn->context = isert_conn;\n\tisert_conn->conn = conn;\n\tisert_conn->state = ISER_CONN_BOUND;\n\n\tisert_set_conn_info(np, conn, isert_conn);\n\n\tisert_dbg(\"Processing isert_conn: %p\\n\", isert_conn);\n\n\treturn 0;\n}\n\nstatic void\nisert_free_np(struct iscsi_np *np)\n{\n\tstruct isert_np *isert_np = np->np_context;\n\tstruct isert_conn *isert_conn, *n;\n\tLIST_HEAD(drop_conn_list);\n\n\tif (isert_np->cm_id)\n\t\trdma_destroy_id(isert_np->cm_id);\n\n\t \n\tmutex_lock(&isert_np->mutex);\n\tif (!list_empty(&isert_np->pending)) {\n\t\tisert_info(\"Still have isert pending connections\\n\");\n\t\tlist_for_each_entry_safe(isert_conn, n,\n\t\t\t\t\t &isert_np->pending,\n\t\t\t\t\t node) {\n\t\t\tisert_info(\"cleaning isert_conn %p state (%d)\\n\",\n\t\t\t\t   isert_conn, isert_conn->state);\n\t\t\tlist_move_tail(&isert_conn->node, &drop_conn_list);\n\t\t}\n\t}\n\n\tif (!list_empty(&isert_np->accepted)) {\n\t\tisert_info(\"Still have isert accepted connections\\n\");\n\t\tlist_for_each_entry_safe(isert_conn, n,\n\t\t\t\t\t &isert_np->accepted,\n\t\t\t\t\t node) {\n\t\t\tisert_info(\"cleaning isert_conn %p state (%d)\\n\",\n\t\t\t\t   isert_conn, isert_conn->state);\n\t\t\tlist_move_tail(&isert_conn->node, &drop_conn_list);\n\t\t}\n\t}\n\tmutex_unlock(&isert_np->mutex);\n\n\tlist_for_each_entry_safe(isert_conn, n, &drop_conn_list, node) {\n\t\tlist_del_init(&isert_conn->node);\n\t\tisert_connect_release(isert_conn);\n\t}\n\n\tnp->np_context = NULL;\n\tkfree(isert_np);\n}\n\nstatic void isert_release_work(struct work_struct *work)\n{\n\tstruct isert_conn *isert_conn = container_of(work,\n\t\t\t\t\t\t     struct isert_conn,\n\t\t\t\t\t\t     release_work);\n\n\tisert_info(\"Starting release conn %p\\n\", isert_conn);\n\n\tmutex_lock(&isert_conn->mutex);\n\tisert_conn->state = ISER_CONN_DOWN;\n\tmutex_unlock(&isert_conn->mutex);\n\n\tisert_info(\"Destroying conn %p\\n\", isert_conn);\n\tisert_put_conn(isert_conn);\n}\n\nstatic void\nisert_wait4logout(struct isert_conn *isert_conn)\n{\n\tstruct iscsit_conn *conn = isert_conn->conn;\n\n\tisert_info(\"conn %p\\n\", isert_conn);\n\n\tif (isert_conn->logout_posted) {\n\t\tisert_info(\"conn %p wait for conn_logout_comp\\n\", isert_conn);\n\t\twait_for_completion_timeout(&conn->conn_logout_comp,\n\t\t\t\t\t    SECONDS_FOR_LOGOUT_COMP * HZ);\n\t}\n}\n\nstatic void\nisert_wait4cmds(struct iscsit_conn *conn)\n{\n\tisert_info(\"iscsit_conn %p\\n\", conn);\n\n\tif (conn->sess) {\n\t\ttarget_stop_cmd_counter(conn->cmd_cnt);\n\t\ttarget_wait_for_cmds(conn->cmd_cnt);\n\t}\n}\n\n \nstatic void\nisert_put_unsol_pending_cmds(struct iscsit_conn *conn)\n{\n\tstruct iscsit_cmd *cmd, *tmp;\n\tstatic LIST_HEAD(drop_cmd_list);\n\n\tspin_lock_bh(&conn->cmd_lock);\n\tlist_for_each_entry_safe(cmd, tmp, &conn->conn_cmd_list, i_conn_node) {\n\t\tif ((cmd->cmd_flags & ICF_NON_IMMEDIATE_UNSOLICITED_DATA) &&\n\t\t    (cmd->write_data_done < conn->sess->sess_ops->FirstBurstLength) &&\n\t\t    (cmd->write_data_done < cmd->se_cmd.data_length))\n\t\t\tlist_move_tail(&cmd->i_conn_node, &drop_cmd_list);\n\t}\n\tspin_unlock_bh(&conn->cmd_lock);\n\n\tlist_for_each_entry_safe(cmd, tmp, &drop_cmd_list, i_conn_node) {\n\t\tlist_del_init(&cmd->i_conn_node);\n\t\tif (cmd->i_state != ISTATE_REMOVE) {\n\t\t\tstruct isert_cmd *isert_cmd = iscsit_priv_cmd(cmd);\n\n\t\t\tisert_info(\"conn %p dropping cmd %p\\n\", conn, cmd);\n\t\t\tisert_put_cmd(isert_cmd, true);\n\t\t}\n\t}\n}\n\nstatic void isert_wait_conn(struct iscsit_conn *conn)\n{\n\tstruct isert_conn *isert_conn = conn->context;\n\n\tisert_info(\"Starting conn %p\\n\", isert_conn);\n\n\tmutex_lock(&isert_conn->mutex);\n\tisert_conn_terminate(isert_conn);\n\tmutex_unlock(&isert_conn->mutex);\n\n\tib_drain_qp(isert_conn->qp);\n\tisert_put_unsol_pending_cmds(conn);\n\tisert_wait4cmds(conn);\n\tisert_wait4logout(isert_conn);\n\n\tqueue_work(isert_release_wq, &isert_conn->release_work);\n}\n\nstatic void isert_free_conn(struct iscsit_conn *conn)\n{\n\tstruct isert_conn *isert_conn = conn->context;\n\n\tib_drain_qp(isert_conn->qp);\n\tisert_put_conn(isert_conn);\n}\n\nstatic void isert_get_rx_pdu(struct iscsit_conn *conn)\n{\n\tstruct completion comp;\n\n\tinit_completion(&comp);\n\n\twait_for_completion_interruptible(&comp);\n}\n\nstatic struct iscsit_transport iser_target_transport = {\n\t.name\t\t\t= \"IB/iSER\",\n\t.transport_type\t\t= ISCSI_INFINIBAND,\n\t.rdma_shutdown\t\t= true,\n\t.priv_size\t\t= sizeof(struct isert_cmd),\n\t.owner\t\t\t= THIS_MODULE,\n\t.iscsit_setup_np\t= isert_setup_np,\n\t.iscsit_accept_np\t= isert_accept_np,\n\t.iscsit_free_np\t\t= isert_free_np,\n\t.iscsit_wait_conn\t= isert_wait_conn,\n\t.iscsit_free_conn\t= isert_free_conn,\n\t.iscsit_get_login_rx\t= isert_get_login_rx,\n\t.iscsit_put_login_tx\t= isert_put_login_tx,\n\t.iscsit_immediate_queue\t= isert_immediate_queue,\n\t.iscsit_response_queue\t= isert_response_queue,\n\t.iscsit_get_dataout\t= isert_get_dataout,\n\t.iscsit_queue_data_in\t= isert_put_datain,\n\t.iscsit_queue_status\t= isert_put_response,\n\t.iscsit_aborted_task\t= isert_aborted_task,\n\t.iscsit_get_rx_pdu\t= isert_get_rx_pdu,\n\t.iscsit_get_sup_prot_ops = isert_get_sup_prot_ops,\n};\n\nstatic int __init isert_init(void)\n{\n\tisert_login_wq = alloc_workqueue(\"isert_login_wq\", 0, 0);\n\tif (!isert_login_wq) {\n\t\tisert_err(\"Unable to allocate isert_login_wq\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tisert_comp_wq = alloc_workqueue(\"isert_comp_wq\",\n\t\t\t\t\tWQ_UNBOUND | WQ_HIGHPRI, 0);\n\tif (!isert_comp_wq) {\n\t\tisert_err(\"Unable to allocate isert_comp_wq\\n\");\n\t\tgoto destroy_login_wq;\n\t}\n\n\tisert_release_wq = alloc_workqueue(\"isert_release_wq\", WQ_UNBOUND,\n\t\t\t\t\tWQ_UNBOUND_MAX_ACTIVE);\n\tif (!isert_release_wq) {\n\t\tisert_err(\"Unable to allocate isert_release_wq\\n\");\n\t\tgoto destroy_comp_wq;\n\t}\n\n\tiscsit_register_transport(&iser_target_transport);\n\tisert_info(\"iSER_TARGET[0] - Loaded iser_target_transport\\n\");\n\n\treturn 0;\n\ndestroy_comp_wq:\n\tdestroy_workqueue(isert_comp_wq);\ndestroy_login_wq:\n\tdestroy_workqueue(isert_login_wq);\n\n\treturn -ENOMEM;\n}\n\nstatic void __exit isert_exit(void)\n{\n\tflush_workqueue(isert_login_wq);\n\tdestroy_workqueue(isert_release_wq);\n\tdestroy_workqueue(isert_comp_wq);\n\tiscsit_unregister_transport(&iser_target_transport);\n\tisert_info(\"iSER_TARGET[0] - Released iser_target_transport\\n\");\n\tdestroy_workqueue(isert_login_wq);\n}\n\nMODULE_DESCRIPTION(\"iSER-Target for mainline target infrastructure\");\nMODULE_AUTHOR(\"nab@Linux-iSCSI.org\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(isert_init);\nmodule_exit(isert_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}