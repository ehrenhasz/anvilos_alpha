{
  "module_name": "ipoib_verbs.c",
  "hash_id": "873693abd168c757116291a631364e318807a8889df1547d0025731e67a33116",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/ulp/ipoib/ipoib_verbs.c",
  "human_readable_source": " \n\n#include <linux/slab.h>\n\n#include \"ipoib.h\"\n\nint ipoib_mcast_attach(struct net_device *dev, struct ib_device *hca,\n\t\t       union ib_gid *mgid, u16 mlid, int set_qkey, u32 qkey)\n{\n\tstruct ipoib_dev_priv *priv = ipoib_priv(dev);\n\tstruct ib_qp_attr *qp_attr = NULL;\n\tint ret;\n\tu16 pkey_index;\n\n\tif (ib_find_pkey(priv->ca, priv->port, priv->pkey, &pkey_index)) {\n\t\tclear_bit(IPOIB_PKEY_ASSIGNED, &priv->flags);\n\t\tret = -ENXIO;\n\t\tgoto out;\n\t}\n\tset_bit(IPOIB_PKEY_ASSIGNED, &priv->flags);\n\n\tif (set_qkey) {\n\t\tret = -ENOMEM;\n\t\tqp_attr = kmalloc(sizeof(*qp_attr), GFP_KERNEL);\n\t\tif (!qp_attr)\n\t\t\tgoto out;\n\n\t\t \n\t\tqp_attr->qkey = qkey;\n\t\tret = ib_modify_qp(priv->qp, qp_attr, IB_QP_QKEY);\n\t\tif (ret) {\n\t\t\tipoib_warn(priv, \"failed to modify QP, ret = %d\\n\", ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tret = ib_attach_mcast(priv->qp, mgid, mlid);\n\tif (ret)\n\t\tipoib_warn(priv, \"failed to attach to multicast group, ret = %d\\n\", ret);\n\nout:\n\tkfree(qp_attr);\n\treturn ret;\n}\n\nint ipoib_mcast_detach(struct net_device *dev, struct ib_device *hca,\n\t\t       union ib_gid *mgid, u16 mlid)\n{\n\tstruct ipoib_dev_priv *priv = ipoib_priv(dev);\n\tint ret;\n\n\tret = ib_detach_mcast(priv->qp, mgid, mlid);\n\n\treturn ret;\n}\n\nint ipoib_init_qp(struct net_device *dev)\n{\n\tstruct ipoib_dev_priv *priv = ipoib_priv(dev);\n\tint ret;\n\tstruct ib_qp_attr qp_attr;\n\tint attr_mask;\n\n\tif (!test_bit(IPOIB_PKEY_ASSIGNED, &priv->flags))\n\t\treturn -1;\n\n\tqp_attr.qp_state = IB_QPS_INIT;\n\tqp_attr.qkey = 0;\n\tqp_attr.port_num = priv->port;\n\tqp_attr.pkey_index = priv->pkey_index;\n\tattr_mask =\n\t    IB_QP_QKEY |\n\t    IB_QP_PORT |\n\t    IB_QP_PKEY_INDEX |\n\t    IB_QP_STATE;\n\tret = ib_modify_qp(priv->qp, &qp_attr, attr_mask);\n\tif (ret) {\n\t\tipoib_warn(priv, \"failed to modify QP to init, ret = %d\\n\", ret);\n\t\tgoto out_fail;\n\t}\n\n\tqp_attr.qp_state = IB_QPS_RTR;\n\t \n\tattr_mask &= ~IB_QP_PORT;\n\tret = ib_modify_qp(priv->qp, &qp_attr, attr_mask);\n\tif (ret) {\n\t\tipoib_warn(priv, \"failed to modify QP to RTR, ret = %d\\n\", ret);\n\t\tgoto out_fail;\n\t}\n\n\tqp_attr.qp_state = IB_QPS_RTS;\n\tqp_attr.sq_psn = 0;\n\tattr_mask |= IB_QP_SQ_PSN;\n\tattr_mask &= ~IB_QP_PKEY_INDEX;\n\tret = ib_modify_qp(priv->qp, &qp_attr, attr_mask);\n\tif (ret) {\n\t\tipoib_warn(priv, \"failed to modify QP to RTS, ret = %d\\n\", ret);\n\t\tgoto out_fail;\n\t}\n\n\treturn 0;\n\nout_fail:\n\tqp_attr.qp_state = IB_QPS_RESET;\n\tif (ib_modify_qp(priv->qp, &qp_attr, IB_QP_STATE))\n\t\tipoib_warn(priv, \"Failed to modify QP to RESET state\\n\");\n\n\treturn ret;\n}\n\nint ipoib_transport_dev_init(struct net_device *dev, struct ib_device *ca)\n{\n\tstruct ipoib_dev_priv *priv = ipoib_priv(dev);\n\tstruct ib_qp_init_attr init_attr = {\n\t\t.cap = {\n\t\t\t.max_send_wr  = ipoib_sendq_size,\n\t\t\t.max_recv_wr  = ipoib_recvq_size,\n\t\t\t.max_send_sge = min_t(u32, priv->ca->attrs.max_send_sge,\n\t\t\t\t\t      MAX_SKB_FRAGS + 1),\n\t\t\t.max_recv_sge = IPOIB_UD_RX_SG\n\t\t},\n\t\t.sq_sig_type = IB_SIGNAL_ALL_WR,\n\t\t.qp_type     = IB_QPT_UD\n\t};\n\tstruct ib_cq_init_attr cq_attr = {};\n\n\tint ret, size, req_vec;\n\tint i;\n\tstatic atomic_t counter;\n\n\tsize = ipoib_recvq_size + 1;\n\tret = ipoib_cm_dev_init(dev);\n\tif (!ret) {\n\t\tsize += ipoib_sendq_size;\n\t\tif (ipoib_cm_has_srq(dev))\n\t\t\tsize += ipoib_recvq_size + 1;  \n\t\telse\n\t\t\tsize += ipoib_recvq_size * ipoib_max_conn_qp;\n\t} else\n\t\tif (ret != -EOPNOTSUPP)\n\t\t\treturn ret;\n\n\treq_vec = atomic_inc_return(&counter) * 2;\n\tcq_attr.cqe = size;\n\tcq_attr.comp_vector = req_vec % priv->ca->num_comp_vectors;\n\tpriv->recv_cq = ib_create_cq(priv->ca, ipoib_ib_rx_completion, NULL,\n\t\t\t\t     priv, &cq_attr);\n\tif (IS_ERR(priv->recv_cq)) {\n\t\tpr_warn(\"%s: failed to create receive CQ\\n\", ca->name);\n\t\tgoto out_cm_dev_cleanup;\n\t}\n\n\tcq_attr.cqe = ipoib_sendq_size;\n\tcq_attr.comp_vector = (req_vec + 1) % priv->ca->num_comp_vectors;\n\tpriv->send_cq = ib_create_cq(priv->ca, ipoib_ib_tx_completion, NULL,\n\t\t\t\t     priv, &cq_attr);\n\tif (IS_ERR(priv->send_cq)) {\n\t\tpr_warn(\"%s: failed to create send CQ\\n\", ca->name);\n\t\tgoto out_free_recv_cq;\n\t}\n\n\tif (ib_req_notify_cq(priv->recv_cq, IB_CQ_NEXT_COMP))\n\t\tgoto out_free_send_cq;\n\n\tinit_attr.send_cq = priv->send_cq;\n\tinit_attr.recv_cq = priv->recv_cq;\n\n\tif (priv->kernel_caps & IBK_UD_TSO)\n\t\tinit_attr.create_flags |= IB_QP_CREATE_IPOIB_UD_LSO;\n\n\tif (priv->kernel_caps & IBK_BLOCK_MULTICAST_LOOPBACK)\n\t\tinit_attr.create_flags |= IB_QP_CREATE_BLOCK_MULTICAST_LOOPBACK;\n\n\tif (priv->hca_caps & IB_DEVICE_MANAGED_FLOW_STEERING)\n\t\tinit_attr.create_flags |= IB_QP_CREATE_NETIF_QP;\n\n\tif (priv->kernel_caps & IBK_RDMA_NETDEV_OPA)\n\t\tinit_attr.create_flags |= IB_QP_CREATE_NETDEV_USE;\n\n\tpriv->qp = ib_create_qp(priv->pd, &init_attr);\n\tif (IS_ERR(priv->qp)) {\n\t\tpr_warn(\"%s: failed to create QP\\n\", ca->name);\n\t\tgoto out_free_send_cq;\n\t}\n\n\tif (ib_req_notify_cq(priv->send_cq, IB_CQ_NEXT_COMP))\n\t\tgoto out_free_send_cq;\n\n\tfor (i = 0; i < MAX_SKB_FRAGS + 1; ++i)\n\t\tpriv->tx_sge[i].lkey = priv->pd->local_dma_lkey;\n\n\tpriv->tx_wr.wr.opcode\t\t= IB_WR_SEND;\n\tpriv->tx_wr.wr.sg_list\t\t= priv->tx_sge;\n\tpriv->tx_wr.wr.send_flags\t= IB_SEND_SIGNALED;\n\n\tpriv->rx_sge[0].lkey = priv->pd->local_dma_lkey;\n\n\tpriv->rx_sge[0].length = IPOIB_UD_BUF_SIZE(priv->max_ib_mtu);\n\tpriv->rx_wr.num_sge = 1;\n\n\tpriv->rx_wr.next = NULL;\n\tpriv->rx_wr.sg_list = priv->rx_sge;\n\n\tif (init_attr.cap.max_send_sge > 1)\n\t\tdev->features |= NETIF_F_SG;\n\n\tpriv->max_send_sge = init_attr.cap.max_send_sge;\n\n\treturn 0;\n\nout_free_send_cq:\n\tib_destroy_cq(priv->send_cq);\n\nout_free_recv_cq:\n\tib_destroy_cq(priv->recv_cq);\n\nout_cm_dev_cleanup:\n\tipoib_cm_dev_cleanup(dev);\n\n\treturn -ENODEV;\n}\n\nvoid ipoib_transport_dev_cleanup(struct net_device *dev)\n{\n\tstruct ipoib_dev_priv *priv = ipoib_priv(dev);\n\n\tif (priv->qp) {\n\t\tif (ib_destroy_qp(priv->qp))\n\t\t\tipoib_warn(priv, \"ib_qp_destroy failed\\n\");\n\n\t\tpriv->qp = NULL;\n\t}\n\n\tib_destroy_cq(priv->send_cq);\n\tib_destroy_cq(priv->recv_cq);\n}\n\nvoid ipoib_event(struct ib_event_handler *handler,\n\t\t struct ib_event *record)\n{\n\tstruct ipoib_dev_priv *priv =\n\t\tcontainer_of(handler, struct ipoib_dev_priv, event_handler);\n\n\tif (record->element.port_num != priv->port)\n\t\treturn;\n\n\tipoib_dbg(priv, \"Event %d on device %s port %d\\n\", record->event,\n\t\t  dev_name(&record->device->dev), record->element.port_num);\n\n\tif (record->event == IB_EVENT_CLIENT_REREGISTER) {\n\t\tqueue_work(ipoib_workqueue, &priv->flush_light);\n\t} else if (record->event == IB_EVENT_PORT_ERR ||\n\t\t   record->event == IB_EVENT_PORT_ACTIVE ||\n\t\t   record->event == IB_EVENT_LID_CHANGE) {\n\t\tqueue_work(ipoib_workqueue, &priv->flush_normal);\n\t} else if (record->event == IB_EVENT_PKEY_CHANGE) {\n\t\tqueue_work(ipoib_workqueue, &priv->flush_heavy);\n\t} else if (record->event == IB_EVENT_GID_CHANGE &&\n\t\t   !test_bit(IPOIB_FLAG_DEV_ADDR_SET, &priv->flags)) {\n\t\tqueue_work(ipoib_workqueue, &priv->flush_light);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}