{
  "module_name": "ipoib_netlink.c",
  "hash_id": "6512f09440da5f6a67ed7c79470568e515747c4c7429e35a5529155e8fe76bfe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/ulp/ipoib/ipoib_netlink.c",
  "human_readable_source": " \n\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>       \n#include <net/rtnetlink.h>\n#include \"ipoib.h\"\n\nstatic const struct nla_policy ipoib_policy[IFLA_IPOIB_MAX + 1] = {\n\t[IFLA_IPOIB_PKEY]\t= { .type = NLA_U16 },\n\t[IFLA_IPOIB_MODE]\t= { .type = NLA_U16 },\n\t[IFLA_IPOIB_UMCAST]\t= { .type = NLA_U16 },\n};\n\nstatic unsigned int ipoib_get_max_num_queues(void)\n{\n\treturn min_t(unsigned int, num_possible_cpus(), 128);\n}\n\nstatic int ipoib_fill_info(struct sk_buff *skb, const struct net_device *dev)\n{\n\tstruct ipoib_dev_priv *priv = ipoib_priv(dev);\n\tu16 val;\n\n\tif (nla_put_u16(skb, IFLA_IPOIB_PKEY, priv->pkey))\n\t\tgoto nla_put_failure;\n\n\tval = test_bit(IPOIB_FLAG_ADMIN_CM, &priv->flags);\n\tif (nla_put_u16(skb, IFLA_IPOIB_MODE, val))\n\t\tgoto nla_put_failure;\n\n\tval = test_bit(IPOIB_FLAG_UMCAST, &priv->flags);\n\tif (nla_put_u16(skb, IFLA_IPOIB_UMCAST, val))\n\t\tgoto nla_put_failure;\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic int ipoib_changelink(struct net_device *dev, struct nlattr *tb[],\n\t\t\t    struct nlattr *data[],\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tu16 mode, umcast;\n\tint ret = 0;\n\n\tif (data[IFLA_IPOIB_MODE]) {\n\t\tmode  = nla_get_u16(data[IFLA_IPOIB_MODE]);\n\t\tif (mode == IPOIB_MODE_DATAGRAM)\n\t\t\tret = ipoib_set_mode(dev, \"datagram\\n\");\n\t\telse if (mode == IPOIB_MODE_CONNECTED)\n\t\t\tret = ipoib_set_mode(dev, \"connected\\n\");\n\t\telse\n\t\t\tret = -EINVAL;\n\n\t\tif (ret < 0)\n\t\t\tgoto out_err;\n\t}\n\n\tif (data[IFLA_IPOIB_UMCAST]) {\n\t\tumcast = nla_get_u16(data[IFLA_IPOIB_UMCAST]);\n\t\tipoib_set_umcast(dev, umcast);\n\t}\n\nout_err:\n\treturn ret;\n}\n\nstatic int ipoib_new_child_link(struct net *src_net, struct net_device *dev,\n\t\t\t\tstruct nlattr *tb[], struct nlattr *data[],\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct net_device *pdev;\n\tstruct ipoib_dev_priv *ppriv;\n\tu16 child_pkey;\n\tint err;\n\n\tif (!tb[IFLA_LINK])\n\t\treturn -EINVAL;\n\n\tpdev = __dev_get_by_index(src_net, nla_get_u32(tb[IFLA_LINK]));\n\tif (!pdev || pdev->type != ARPHRD_INFINIBAND)\n\t\treturn -ENODEV;\n\n\tppriv = ipoib_priv(pdev);\n\n\tif (test_bit(IPOIB_FLAG_SUBINTERFACE, &ppriv->flags)) {\n\t\tipoib_warn(ppriv, \"child creation disallowed for child devices\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!data || !data[IFLA_IPOIB_PKEY]) {\n\t\tipoib_dbg(ppriv, \"no pkey specified, using parent pkey\\n\");\n\t\tchild_pkey  = ppriv->pkey;\n\t} else\n\t\tchild_pkey  = nla_get_u16(data[IFLA_IPOIB_PKEY]);\n\n\terr = ipoib_intf_init(ppriv->ca, ppriv->port, dev->name, dev);\n\tif (err) {\n\t\tipoib_warn(ppriv, \"failed to initialize pkey device\\n\");\n\t\treturn err;\n\t}\n\n\terr = __ipoib_vlan_add(ppriv, ipoib_priv(dev),\n\t\t\t       child_pkey, IPOIB_RTNL_CHILD);\n\tif (err)\n\t\treturn err;\n\n\tif (data) {\n\t\terr = ipoib_changelink(dev, tb, data, extack);\n\t\tif (err) {\n\t\t\tunregister_netdevice(dev);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void ipoib_del_child_link(struct net_device *dev, struct list_head *head)\n{\n\tstruct ipoib_dev_priv *priv = ipoib_priv(dev);\n\n\tif (!priv->parent)\n\t\treturn;\n\n\tunregister_netdevice_queue(dev, head);\n}\n\nstatic size_t ipoib_get_size(const struct net_device *dev)\n{\n\treturn nla_total_size(2) +\t \n\t\tnla_total_size(2) +\t \n\t\tnla_total_size(2);\t \n}\n\nstatic struct rtnl_link_ops ipoib_link_ops __read_mostly = {\n\t.kind\t\t= \"ipoib\",\n\t.netns_refund   = true,\n\t.maxtype\t= IFLA_IPOIB_MAX,\n\t.policy\t\t= ipoib_policy,\n\t.priv_size\t= sizeof(struct ipoib_dev_priv),\n\t.setup\t\t= ipoib_setup_common,\n\t.newlink\t= ipoib_new_child_link,\n\t.dellink\t= ipoib_del_child_link,\n\t.changelink\t= ipoib_changelink,\n\t.get_size\t= ipoib_get_size,\n\t.fill_info\t= ipoib_fill_info,\n\t.get_num_rx_queues = ipoib_get_max_num_queues,\n\t.get_num_tx_queues = ipoib_get_max_num_queues,\n};\n\nstruct rtnl_link_ops *ipoib_get_link_ops(void)\n{\n\treturn &ipoib_link_ops;\n}\n\nint __init ipoib_netlink_init(void)\n{\n\treturn rtnl_link_register(&ipoib_link_ops);\n}\n\nvoid __exit ipoib_netlink_fini(void)\n{\n\trtnl_link_unregister(&ipoib_link_ops);\n}\n\nMODULE_ALIAS_RTNL_LINK(\"ipoib\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}