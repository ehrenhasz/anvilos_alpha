{
  "module_name": "ipoib_vlan.c",
  "hash_id": "6210ce91ef15e606094f207b85c00e0286bae478de53d9b07da0f8e3403223a0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/ulp/ipoib/ipoib_vlan.c",
  "human_readable_source": " \n\n#include <linux/sched/signal.h>\n\n#include <linux/init.h>\n#include <linux/seq_file.h>\n\n#include <linux/uaccess.h>\n\n#include \"ipoib.h\"\n\nstatic ssize_t parent_show(struct device *d, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct net_device *dev = to_net_dev(d);\n\tstruct ipoib_dev_priv *priv = ipoib_priv(dev);\n\n\treturn sysfs_emit(buf, \"%s\\n\", priv->parent->name);\n}\nstatic DEVICE_ATTR_RO(parent);\n\nstatic bool is_child_unique(struct ipoib_dev_priv *ppriv,\n\t\t\t    struct ipoib_dev_priv *priv)\n{\n\tstruct ipoib_dev_priv *tpriv;\n\n\tASSERT_RTNL();\n\n\t \n\tif (priv->child_type != IPOIB_LEGACY_CHILD)\n\t\treturn true;\n\n\t \n\tif (ppriv->pkey == priv->pkey)\n\t\treturn false;\n\n\tlist_for_each_entry(tpriv, &ppriv->child_intfs, list) {\n\t\tif (tpriv->pkey == priv->pkey &&\n\t\t    tpriv->child_type == IPOIB_LEGACY_CHILD)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nint __ipoib_vlan_add(struct ipoib_dev_priv *ppriv, struct ipoib_dev_priv *priv,\n\t\t     u16 pkey, int type)\n{\n\tstruct net_device *ndev = priv->dev;\n\tint result;\n\tstruct rdma_netdev *rn = netdev_priv(ndev);\n\n\tASSERT_RTNL();\n\n\t \n\tndev->priv_destructor = ipoib_intf_free;\n\n\t \n\tWARN_ON(ppriv->dev->reg_state != NETREG_REGISTERED);\n\n\tif (pkey == 0 || pkey == 0x8000) {\n\t\tresult = -EINVAL;\n\t\tgoto out_early;\n\t}\n\n\trn->mtu = priv->mcast_mtu;\n\n\tpriv->parent = ppriv->dev;\n\tpriv->pkey = pkey;\n\tpriv->child_type = type;\n\n\tif (!is_child_unique(ppriv, priv)) {\n\t\tresult = -ENOTUNIQ;\n\t\tgoto out_early;\n\t}\n\n\tresult = register_netdevice(ndev);\n\tif (result) {\n\t\tipoib_warn(priv, \"failed to initialize; error %i\", result);\n\n\t\t \n\t\tgoto out_early;\n\t}\n\n\t \n\tif (type == IPOIB_LEGACY_CHILD) {\n\t\tif (ipoib_cm_add_mode_attr(ndev))\n\t\t\tgoto sysfs_failed;\n\t\tif (ipoib_add_pkey_attr(ndev))\n\t\t\tgoto sysfs_failed;\n\t\tif (ipoib_add_umcast_attr(ndev))\n\t\t\tgoto sysfs_failed;\n\n\t\tif (device_create_file(&ndev->dev, &dev_attr_parent))\n\t\t\tgoto sysfs_failed;\n\t}\n\n\treturn 0;\n\nsysfs_failed:\n\tunregister_netdevice(priv->dev);\n\treturn -ENOMEM;\n\nout_early:\n\tif (ndev->priv_destructor)\n\t\tndev->priv_destructor(ndev);\n\treturn result;\n}\n\nint ipoib_vlan_add(struct net_device *pdev, unsigned short pkey)\n{\n\tstruct ipoib_dev_priv *ppriv, *priv;\n\tchar intf_name[IFNAMSIZ];\n\tstruct net_device *ndev;\n\tint result;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!rtnl_trylock())\n\t\treturn restart_syscall();\n\n\tif (pdev->reg_state != NETREG_REGISTERED) {\n\t\trtnl_unlock();\n\t\treturn -EPERM;\n\t}\n\n\tppriv = ipoib_priv(pdev);\n\n\tsnprintf(intf_name, sizeof(intf_name), \"%s.%04x\",\n\t\t ppriv->dev->name, pkey);\n\n\tndev = ipoib_intf_alloc(ppriv->ca, ppriv->port, intf_name);\n\tif (IS_ERR(ndev)) {\n\t\tresult = PTR_ERR(ndev);\n\t\tgoto out;\n\t}\n\tpriv = ipoib_priv(ndev);\n\n\tndev->rtnl_link_ops = ipoib_get_link_ops();\n\n\tresult = __ipoib_vlan_add(ppriv, priv, pkey, IPOIB_LEGACY_CHILD);\n\n\tif (result && ndev->reg_state == NETREG_UNINITIALIZED)\n\t\tfree_netdev(ndev);\n\nout:\n\trtnl_unlock();\n\n\treturn result;\n}\n\nstruct ipoib_vlan_delete_work {\n\tstruct work_struct work;\n\tstruct net_device *dev;\n};\n\n \nstatic void ipoib_vlan_delete_task(struct work_struct *work)\n{\n\tstruct ipoib_vlan_delete_work *pwork =\n\t\tcontainer_of(work, struct ipoib_vlan_delete_work, work);\n\tstruct net_device *dev = pwork->dev;\n\n\trtnl_lock();\n\n\t \n\tif (dev->reg_state == NETREG_REGISTERED) {\n\t\tstruct ipoib_dev_priv *priv = ipoib_priv(dev);\n\t\tstruct ipoib_dev_priv *ppriv = ipoib_priv(priv->parent);\n\n\t\tipoib_dbg(ppriv, \"delete child vlan %s\\n\", dev->name);\n\t\tunregister_netdevice(dev);\n\t}\n\n\trtnl_unlock();\n\n\tkfree(pwork);\n}\n\nint ipoib_vlan_delete(struct net_device *pdev, unsigned short pkey)\n{\n\tstruct ipoib_dev_priv *ppriv, *priv, *tpriv;\n\tint rc;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!rtnl_trylock())\n\t\treturn restart_syscall();\n\n\tif (pdev->reg_state != NETREG_REGISTERED) {\n\t\trtnl_unlock();\n\t\treturn -EPERM;\n\t}\n\n\tppriv = ipoib_priv(pdev);\n\n\trc = -ENODEV;\n\tlist_for_each_entry_safe(priv, tpriv, &ppriv->child_intfs, list) {\n\t\tif (priv->pkey == pkey &&\n\t\t    priv->child_type == IPOIB_LEGACY_CHILD) {\n\t\t\tstruct ipoib_vlan_delete_work *work;\n\n\t\t\twork = kmalloc(sizeof(*work), GFP_KERNEL);\n\t\t\tif (!work) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tdown_write(&ppriv->vlan_rwsem);\n\t\t\tlist_del_init(&priv->list);\n\t\t\tup_write(&ppriv->vlan_rwsem);\n\t\t\twork->dev = priv->dev;\n\t\t\tINIT_WORK(&work->work, ipoib_vlan_delete_task);\n\t\t\tqueue_work(ipoib_workqueue, &work->work);\n\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\trtnl_unlock();\n\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}