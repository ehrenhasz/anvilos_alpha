{
  "module_name": "ipoib_main.c",
  "hash_id": "c21c1058c69b6f3ab45fbe461f534237dacfb3521ddfd28beb30ad19ed1d56f7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/ulp/ipoib/ipoib_main.c",
  "human_readable_source": " \n\n#include \"ipoib.h\"\n\n#include <linux/module.h>\n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/vmalloc.h>\n\n#include <linux/if_arp.h>\t \n\n#include <linux/ip.h>\n#include <linux/in.h>\n\n#include <linux/jhash.h>\n#include <net/arp.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <rdma/ib_cache.h>\n\nMODULE_AUTHOR(\"Roland Dreier\");\nMODULE_DESCRIPTION(\"IP-over-InfiniBand net driver\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n\nint ipoib_sendq_size __read_mostly = IPOIB_TX_RING_SIZE;\nint ipoib_recvq_size __read_mostly = IPOIB_RX_RING_SIZE;\n\nmodule_param_named(send_queue_size, ipoib_sendq_size, int, 0444);\nMODULE_PARM_DESC(send_queue_size, \"Number of descriptors in send queue\");\nmodule_param_named(recv_queue_size, ipoib_recvq_size, int, 0444);\nMODULE_PARM_DESC(recv_queue_size, \"Number of descriptors in receive queue\");\n\n#ifdef CONFIG_INFINIBAND_IPOIB_DEBUG\nint ipoib_debug_level;\n\nmodule_param_named(debug_level, ipoib_debug_level, int, 0644);\nMODULE_PARM_DESC(debug_level, \"Enable debug tracing if > 0\");\n#endif\n\nstruct ipoib_path_iter {\n\tstruct net_device *dev;\n\tstruct ipoib_path  path;\n};\n\nstatic const u8 ipv4_bcast_addr[] = {\n\t0x00, 0xff, 0xff, 0xff,\n\t0xff, 0x12, 0x40, 0x1b,\t0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00,\t0xff, 0xff, 0xff, 0xff\n};\n\nstruct workqueue_struct *ipoib_workqueue;\n\nstruct ib_sa_client ipoib_sa_client;\n\nstatic int ipoib_add_one(struct ib_device *device);\nstatic void ipoib_remove_one(struct ib_device *device, void *client_data);\nstatic void ipoib_neigh_reclaim(struct rcu_head *rp);\nstatic struct net_device *ipoib_get_net_dev_by_params(\n\t\tstruct ib_device *dev, u32 port, u16 pkey,\n\t\tconst union ib_gid *gid, const struct sockaddr *addr,\n\t\tvoid *client_data);\nstatic int ipoib_set_mac(struct net_device *dev, void *addr);\nstatic int ipoib_ioctl(struct net_device *dev, struct ifreq *ifr,\n\t\t       int cmd);\n\nstatic struct ib_client ipoib_client = {\n\t.name   = \"ipoib\",\n\t.add    = ipoib_add_one,\n\t.remove = ipoib_remove_one,\n\t.get_net_dev_by_params = ipoib_get_net_dev_by_params,\n};\n\n#ifdef CONFIG_INFINIBAND_IPOIB_DEBUG\nstatic int ipoib_netdev_event(struct notifier_block *this,\n\t\t\t      unsigned long event, void *ptr)\n{\n\tstruct netdev_notifier_info *ni = ptr;\n\tstruct net_device *dev = ni->dev;\n\n\tif (dev->netdev_ops->ndo_open != ipoib_open)\n\t\treturn NOTIFY_DONE;\n\n\tswitch (event) {\n\tcase NETDEV_REGISTER:\n\t\tipoib_create_debug_files(dev);\n\t\tbreak;\n\tcase NETDEV_CHANGENAME:\n\t\tipoib_delete_debug_files(dev);\n\t\tipoib_create_debug_files(dev);\n\t\tbreak;\n\tcase NETDEV_UNREGISTER:\n\t\tipoib_delete_debug_files(dev);\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n#endif\n\nint ipoib_open(struct net_device *dev)\n{\n\tstruct ipoib_dev_priv *priv = ipoib_priv(dev);\n\n\tipoib_dbg(priv, \"bringing up interface\\n\");\n\n\tnetif_carrier_off(dev);\n\n\tset_bit(IPOIB_FLAG_ADMIN_UP, &priv->flags);\n\n\tif (ipoib_ib_dev_open(dev)) {\n\t\tif (!test_bit(IPOIB_PKEY_ASSIGNED, &priv->flags))\n\t\t\treturn 0;\n\t\tgoto err_disable;\n\t}\n\n\tipoib_ib_dev_up(dev);\n\n\tif (!test_bit(IPOIB_FLAG_SUBINTERFACE, &priv->flags)) {\n\t\tstruct ipoib_dev_priv *cpriv;\n\n\t\t \n\t\tdown_read(&priv->vlan_rwsem);\n\t\tlist_for_each_entry(cpriv, &priv->child_intfs, list) {\n\t\t\tint flags;\n\n\t\t\tflags = cpriv->dev->flags;\n\t\t\tif (flags & IFF_UP)\n\t\t\t\tcontinue;\n\n\t\t\tdev_change_flags(cpriv->dev, flags | IFF_UP, NULL);\n\t\t}\n\t\tup_read(&priv->vlan_rwsem);\n\t} else if (priv->parent) {\n\t\tstruct ipoib_dev_priv *ppriv = ipoib_priv(priv->parent);\n\n\t\tif (!test_bit(IPOIB_FLAG_ADMIN_UP, &ppriv->flags))\n\t\t\tipoib_dbg(priv, \"parent device %s is not up, so child device may be not functioning.\\n\",\n\t\t\t\t  ppriv->dev->name);\n\t}\n\tnetif_start_queue(dev);\n\n\treturn 0;\n\nerr_disable:\n\tclear_bit(IPOIB_FLAG_ADMIN_UP, &priv->flags);\n\n\treturn -EINVAL;\n}\n\nstatic int ipoib_stop(struct net_device *dev)\n{\n\tstruct ipoib_dev_priv *priv = ipoib_priv(dev);\n\n\tipoib_dbg(priv, \"stopping interface\\n\");\n\n\tclear_bit(IPOIB_FLAG_ADMIN_UP, &priv->flags);\n\n\tnetif_stop_queue(dev);\n\n\tipoib_ib_dev_down(dev);\n\tipoib_ib_dev_stop(dev);\n\n\tif (!test_bit(IPOIB_FLAG_SUBINTERFACE, &priv->flags)) {\n\t\tstruct ipoib_dev_priv *cpriv;\n\n\t\t \n\t\tdown_read(&priv->vlan_rwsem);\n\t\tlist_for_each_entry(cpriv, &priv->child_intfs, list) {\n\t\t\tint flags;\n\n\t\t\tflags = cpriv->dev->flags;\n\t\t\tif (!(flags & IFF_UP))\n\t\t\t\tcontinue;\n\n\t\t\tdev_change_flags(cpriv->dev, flags & ~IFF_UP, NULL);\n\t\t}\n\t\tup_read(&priv->vlan_rwsem);\n\t}\n\n\treturn 0;\n}\n\nstatic netdev_features_t ipoib_fix_features(struct net_device *dev, netdev_features_t features)\n{\n\tstruct ipoib_dev_priv *priv = ipoib_priv(dev);\n\n\tif (test_bit(IPOIB_FLAG_ADMIN_CM, &priv->flags))\n\t\tfeatures &= ~(NETIF_F_IP_CSUM | NETIF_F_TSO);\n\n\treturn features;\n}\n\nstatic int ipoib_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tstruct ipoib_dev_priv *priv = ipoib_priv(dev);\n\tint ret = 0;\n\n\t \n\tif (ipoib_cm_admin_enabled(dev)) {\n\t\tif (new_mtu > ipoib_cm_max_mtu(dev))\n\t\t\treturn -EINVAL;\n\n\t\tif (new_mtu > priv->mcast_mtu)\n\t\t\tipoib_warn(priv, \"mtu > %d will cause multicast packet drops.\\n\",\n\t\t\t\t   priv->mcast_mtu);\n\n\t\tdev->mtu = new_mtu;\n\t\treturn 0;\n\t}\n\n\tif (new_mtu < (ETH_MIN_MTU + IPOIB_ENCAP_LEN) ||\n\t    new_mtu > IPOIB_UD_MTU(priv->max_ib_mtu))\n\t\treturn -EINVAL;\n\n\tpriv->admin_mtu = new_mtu;\n\n\tif (priv->mcast_mtu < priv->admin_mtu)\n\t\tipoib_dbg(priv, \"MTU must be smaller than the underlying \"\n\t\t\t\t\"link layer MTU - 4 (%u)\\n\", priv->mcast_mtu);\n\n\tnew_mtu = min(priv->mcast_mtu, priv->admin_mtu);\n\n\tif (priv->rn_ops->ndo_change_mtu) {\n\t\tbool carrier_status = netif_carrier_ok(dev);\n\n\t\tnetif_carrier_off(dev);\n\n\t\t \n\t\tret = priv->rn_ops->ndo_change_mtu(dev, new_mtu);\n\n\t\tif (carrier_status)\n\t\t\tnetif_carrier_on(dev);\n\t} else {\n\t\tdev->mtu = new_mtu;\n\t}\n\n\treturn ret;\n}\n\nstatic void ipoib_get_stats(struct net_device *dev,\n\t\t\t    struct rtnl_link_stats64 *stats)\n{\n\tstruct ipoib_dev_priv *priv = ipoib_priv(dev);\n\n\tif (priv->rn_ops->ndo_get_stats64)\n\t\tpriv->rn_ops->ndo_get_stats64(dev, stats);\n\telse\n\t\tnetdev_stats_to_stats64(stats, &dev->stats);\n}\n\n \nstatic bool ipoib_is_dev_match_addr_rcu(const struct sockaddr *addr,\n\t\t\t\t\tstruct net_device *dev)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct in_device *in_dev;\n\tstruct sockaddr_in *addr_in = (struct sockaddr_in *)addr;\n\tstruct sockaddr_in6 *addr_in6 = (struct sockaddr_in6 *)addr;\n\t__be32 ret_addr;\n\n\tswitch (addr->sa_family) {\n\tcase AF_INET:\n\t\tin_dev = in_dev_get(dev);\n\t\tif (!in_dev)\n\t\t\treturn false;\n\n\t\tret_addr = inet_confirm_addr(net, in_dev, 0,\n\t\t\t\t\t     addr_in->sin_addr.s_addr,\n\t\t\t\t\t     RT_SCOPE_HOST);\n\t\tin_dev_put(in_dev);\n\t\tif (ret_addr)\n\t\t\treturn true;\n\n\t\tbreak;\n\tcase AF_INET6:\n\t\tif (IS_ENABLED(CONFIG_IPV6) &&\n\t\t    ipv6_chk_addr(net, &addr_in6->sin6_addr, dev, 1))\n\t\t\treturn true;\n\n\t\tbreak;\n\t}\n\treturn false;\n}\n\n \nstatic struct net_device *ipoib_get_master_net_dev(struct net_device *dev)\n{\n\tstruct net_device *master;\n\n\trcu_read_lock();\n\tmaster = netdev_master_upper_dev_get_rcu(dev);\n\tif (master)\n\t\tdev_hold(master);\n\trcu_read_unlock();\n\n\tif (master)\n\t\treturn master;\n\n\tdev_hold(dev);\n\treturn dev;\n}\n\nstruct ipoib_walk_data {\n\tconst struct sockaddr *addr;\n\tstruct net_device *result;\n};\n\nstatic int ipoib_upper_walk(struct net_device *upper,\n\t\t\t    struct netdev_nested_priv *priv)\n{\n\tstruct ipoib_walk_data *data = (struct ipoib_walk_data *)priv->data;\n\tint ret = 0;\n\n\tif (ipoib_is_dev_match_addr_rcu(data->addr, upper)) {\n\t\tdev_hold(upper);\n\t\tdata->result = upper;\n\t\tret = 1;\n\t}\n\n\treturn ret;\n}\n\n \nstatic struct net_device *ipoib_get_net_dev_match_addr(\n\t\tconst struct sockaddr *addr, struct net_device *dev)\n{\n\tstruct netdev_nested_priv priv;\n\tstruct ipoib_walk_data data = {\n\t\t.addr = addr,\n\t};\n\n\tpriv.data = (void *)&data;\n\trcu_read_lock();\n\tif (ipoib_is_dev_match_addr_rcu(addr, dev)) {\n\t\tdev_hold(dev);\n\t\tdata.result = dev;\n\t\tgoto out;\n\t}\n\n\tnetdev_walk_all_upper_dev_rcu(dev, ipoib_upper_walk, &priv);\nout:\n\trcu_read_unlock();\n\treturn data.result;\n}\n\n \nstatic int ipoib_match_gid_pkey_addr(struct ipoib_dev_priv *priv,\n\t\t\t\t     const union ib_gid *gid,\n\t\t\t\t     u16 pkey_index,\n\t\t\t\t     const struct sockaddr *addr,\n\t\t\t\t     int nesting,\n\t\t\t\t     struct net_device **found_net_dev)\n{\n\tstruct ipoib_dev_priv *child_priv;\n\tstruct net_device *net_dev = NULL;\n\tint matches = 0;\n\n\tif (priv->pkey_index == pkey_index &&\n\t    (!gid || !memcmp(gid, &priv->local_gid, sizeof(*gid)))) {\n\t\tif (!addr) {\n\t\t\tnet_dev = ipoib_get_master_net_dev(priv->dev);\n\t\t} else {\n\t\t\t \n\t\t\tnet_dev = ipoib_get_net_dev_match_addr(addr, priv->dev);\n\t\t}\n\t\tif (net_dev) {\n\t\t\tif (!*found_net_dev)\n\t\t\t\t*found_net_dev = net_dev;\n\t\t\telse\n\t\t\t\tdev_put(net_dev);\n\t\t\t++matches;\n\t\t}\n\t}\n\n\t \n\tdown_read_nested(&priv->vlan_rwsem, nesting);\n\tlist_for_each_entry(child_priv, &priv->child_intfs, list) {\n\t\tmatches += ipoib_match_gid_pkey_addr(child_priv, gid,\n\t\t\t\t\t\t    pkey_index, addr,\n\t\t\t\t\t\t    nesting + 1,\n\t\t\t\t\t\t    found_net_dev);\n\t\tif (matches > 1)\n\t\t\tbreak;\n\t}\n\tup_read(&priv->vlan_rwsem);\n\n\treturn matches;\n}\n\n \nstatic int __ipoib_get_net_dev_by_params(struct list_head *dev_list, u32 port,\n\t\t\t\t\t u16 pkey_index,\n\t\t\t\t\t const union ib_gid *gid,\n\t\t\t\t\t const struct sockaddr *addr,\n\t\t\t\t\t struct net_device **net_dev)\n{\n\tstruct ipoib_dev_priv *priv;\n\tint matches = 0;\n\n\t*net_dev = NULL;\n\n\tlist_for_each_entry(priv, dev_list, list) {\n\t\tif (priv->port != port)\n\t\t\tcontinue;\n\n\t\tmatches += ipoib_match_gid_pkey_addr(priv, gid, pkey_index,\n\t\t\t\t\t\t     addr, 0, net_dev);\n\t\tif (matches > 1)\n\t\t\tbreak;\n\t}\n\n\treturn matches;\n}\n\nstatic struct net_device *ipoib_get_net_dev_by_params(\n\t\tstruct ib_device *dev, u32 port, u16 pkey,\n\t\tconst union ib_gid *gid, const struct sockaddr *addr,\n\t\tvoid *client_data)\n{\n\tstruct net_device *net_dev;\n\tstruct list_head *dev_list = client_data;\n\tu16 pkey_index;\n\tint matches;\n\tint ret;\n\n\tif (!rdma_protocol_ib(dev, port))\n\t\treturn NULL;\n\n\tret = ib_find_cached_pkey(dev, port, pkey, &pkey_index);\n\tif (ret)\n\t\treturn NULL;\n\n\t \n\tmatches = __ipoib_get_net_dev_by_params(dev_list, port, pkey_index,\n\t\t\t\t\t\tgid, NULL, &net_dev);\n\n\tswitch (matches) {\n\tcase 0:\n\t\treturn NULL;\n\tcase 1:\n\t\treturn net_dev;\n\t}\n\n\tdev_put(net_dev);\n\n\t \n\tmatches = __ipoib_get_net_dev_by_params(dev_list, port, pkey_index,\n\t\t\t\t\t\tgid, addr, &net_dev);\n\tswitch (matches) {\n\tcase 0:\n\t\treturn NULL;\n\tdefault:\n\t\tdev_warn_ratelimited(&dev->dev,\n\t\t\t\t     \"duplicate IP address detected\\n\");\n\t\tfallthrough;\n\tcase 1:\n\t\treturn net_dev;\n\t}\n}\n\nint ipoib_set_mode(struct net_device *dev, const char *buf)\n{\n\tstruct ipoib_dev_priv *priv = ipoib_priv(dev);\n\n\tif ((test_bit(IPOIB_FLAG_ADMIN_CM, &priv->flags) &&\n\t     !strcmp(buf, \"connected\\n\")) ||\n\t     (!test_bit(IPOIB_FLAG_ADMIN_CM, &priv->flags) &&\n\t     !strcmp(buf, \"datagram\\n\"))) {\n\t\treturn 0;\n\t}\n\n\t \n\tif (IPOIB_CM_SUPPORTED(dev->dev_addr) && !strcmp(buf, \"connected\\n\")) {\n\t\tset_bit(IPOIB_FLAG_ADMIN_CM, &priv->flags);\n\t\tipoib_warn(priv, \"enabling connected mode \"\n\t\t\t   \"will cause multicast packet drops\\n\");\n\t\tnetdev_update_features(dev);\n\t\tdev_set_mtu(dev, ipoib_cm_max_mtu(dev));\n\t\tnetif_set_real_num_tx_queues(dev, 1);\n\t\trtnl_unlock();\n\t\tpriv->tx_wr.wr.send_flags &= ~IB_SEND_IP_CSUM;\n\n\t\tipoib_flush_paths(dev);\n\t\treturn (!rtnl_trylock()) ? -EBUSY : 0;\n\t}\n\n\tif (!strcmp(buf, \"datagram\\n\")) {\n\t\tclear_bit(IPOIB_FLAG_ADMIN_CM, &priv->flags);\n\t\tnetdev_update_features(dev);\n\t\tdev_set_mtu(dev, min(priv->mcast_mtu, dev->mtu));\n\t\tnetif_set_real_num_tx_queues(dev, dev->num_tx_queues);\n\t\trtnl_unlock();\n\t\tipoib_flush_paths(dev);\n\t\treturn (!rtnl_trylock()) ? -EBUSY : 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstruct ipoib_path *__path_find(struct net_device *dev, void *gid)\n{\n\tstruct ipoib_dev_priv *priv = ipoib_priv(dev);\n\tstruct rb_node *n = priv->path_tree.rb_node;\n\tstruct ipoib_path *path;\n\tint ret;\n\n\twhile (n) {\n\t\tpath = rb_entry(n, struct ipoib_path, rb_node);\n\n\t\tret = memcmp(gid, path->pathrec.dgid.raw,\n\t\t\t     sizeof (union ib_gid));\n\n\t\tif (ret < 0)\n\t\t\tn = n->rb_left;\n\t\telse if (ret > 0)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn path;\n\t}\n\n\treturn NULL;\n}\n\nstatic int __path_add(struct net_device *dev, struct ipoib_path *path)\n{\n\tstruct ipoib_dev_priv *priv = ipoib_priv(dev);\n\tstruct rb_node **n = &priv->path_tree.rb_node;\n\tstruct rb_node *pn = NULL;\n\tstruct ipoib_path *tpath;\n\tint ret;\n\n\twhile (*n) {\n\t\tpn = *n;\n\t\ttpath = rb_entry(pn, struct ipoib_path, rb_node);\n\n\t\tret = memcmp(path->pathrec.dgid.raw, tpath->pathrec.dgid.raw,\n\t\t\t     sizeof (union ib_gid));\n\t\tif (ret < 0)\n\t\t\tn = &pn->rb_left;\n\t\telse if (ret > 0)\n\t\t\tn = &pn->rb_right;\n\t\telse\n\t\t\treturn -EEXIST;\n\t}\n\n\trb_link_node(&path->rb_node, pn, n);\n\trb_insert_color(&path->rb_node, &priv->path_tree);\n\n\tlist_add_tail(&path->list, &priv->path_list);\n\n\treturn 0;\n}\n\nstatic void path_free(struct net_device *dev, struct ipoib_path *path)\n{\n\tstruct sk_buff *skb;\n\n\twhile ((skb = __skb_dequeue(&path->queue)))\n\t\tdev_kfree_skb_irq(skb);\n\n\tipoib_dbg(ipoib_priv(dev), \"%s\\n\", __func__);\n\n\t \n\tipoib_del_neighs_by_gid(dev, path->pathrec.dgid.raw);\n\n\tif (path->ah)\n\t\tipoib_put_ah(path->ah);\n\n\tkfree(path);\n}\n\n#ifdef CONFIG_INFINIBAND_IPOIB_DEBUG\n\nstruct ipoib_path_iter *ipoib_path_iter_init(struct net_device *dev)\n{\n\tstruct ipoib_path_iter *iter;\n\n\titer = kmalloc(sizeof(*iter), GFP_KERNEL);\n\tif (!iter)\n\t\treturn NULL;\n\n\titer->dev = dev;\n\tmemset(iter->path.pathrec.dgid.raw, 0, 16);\n\n\tif (ipoib_path_iter_next(iter)) {\n\t\tkfree(iter);\n\t\treturn NULL;\n\t}\n\n\treturn iter;\n}\n\nint ipoib_path_iter_next(struct ipoib_path_iter *iter)\n{\n\tstruct ipoib_dev_priv *priv = ipoib_priv(iter->dev);\n\tstruct rb_node *n;\n\tstruct ipoib_path *path;\n\tint ret = 1;\n\n\tspin_lock_irq(&priv->lock);\n\n\tn = rb_first(&priv->path_tree);\n\n\twhile (n) {\n\t\tpath = rb_entry(n, struct ipoib_path, rb_node);\n\n\t\tif (memcmp(iter->path.pathrec.dgid.raw, path->pathrec.dgid.raw,\n\t\t\t   sizeof (union ib_gid)) < 0) {\n\t\t\titer->path = *path;\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tn = rb_next(n);\n\t}\n\n\tspin_unlock_irq(&priv->lock);\n\n\treturn ret;\n}\n\nvoid ipoib_path_iter_read(struct ipoib_path_iter *iter,\n\t\t\t  struct ipoib_path *path)\n{\n\t*path = iter->path;\n}\n\n#endif  \n\nvoid ipoib_mark_paths_invalid(struct net_device *dev)\n{\n\tstruct ipoib_dev_priv *priv = ipoib_priv(dev);\n\tstruct ipoib_path *path, *tp;\n\n\tspin_lock_irq(&priv->lock);\n\n\tlist_for_each_entry_safe(path, tp, &priv->path_list, list) {\n\t\tipoib_dbg(priv, \"mark path LID 0x%08x GID %pI6 invalid\\n\",\n\t\t\t  be32_to_cpu(sa_path_get_dlid(&path->pathrec)),\n\t\t\t  path->pathrec.dgid.raw);\n\t\tif (path->ah)\n\t\t\tpath->ah->valid = 0;\n\t}\n\n\tspin_unlock_irq(&priv->lock);\n}\n\nstatic void push_pseudo_header(struct sk_buff *skb, const char *daddr)\n{\n\tstruct ipoib_pseudo_header *phdr;\n\n\tphdr = skb_push(skb, sizeof(*phdr));\n\tmemcpy(phdr->hwaddr, daddr, INFINIBAND_ALEN);\n}\n\nvoid ipoib_flush_paths(struct net_device *dev)\n{\n\tstruct ipoib_dev_priv *priv = ipoib_priv(dev);\n\tstruct ipoib_path *path, *tp;\n\tLIST_HEAD(remove_list);\n\tunsigned long flags;\n\n\tnetif_tx_lock_bh(dev);\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tlist_splice_init(&priv->path_list, &remove_list);\n\n\tlist_for_each_entry(path, &remove_list, list)\n\t\trb_erase(&path->rb_node, &priv->path_tree);\n\n\tlist_for_each_entry_safe(path, tp, &remove_list, list) {\n\t\tif (path->query)\n\t\t\tib_sa_cancel_query(path->query_id, path->query);\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\tnetif_tx_unlock_bh(dev);\n\t\twait_for_completion(&path->done);\n\t\tpath_free(dev, path);\n\t\tnetif_tx_lock_bh(dev);\n\t\tspin_lock_irqsave(&priv->lock, flags);\n\t}\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\tnetif_tx_unlock_bh(dev);\n}\n\nstatic void path_rec_completion(int status,\n\t\t\t\tstruct sa_path_rec *pathrec,\n\t\t\t\tunsigned int num_prs, void *path_ptr)\n{\n\tstruct ipoib_path *path = path_ptr;\n\tstruct net_device *dev = path->dev;\n\tstruct ipoib_dev_priv *priv = ipoib_priv(dev);\n\tstruct ipoib_ah *ah = NULL;\n\tstruct ipoib_ah *old_ah = NULL;\n\tstruct ipoib_neigh *neigh, *tn;\n\tstruct sk_buff_head skqueue;\n\tstruct sk_buff *skb;\n\tunsigned long flags;\n\n\tif (!status)\n\t\tipoib_dbg(priv, \"PathRec LID 0x%04x for GID %pI6\\n\",\n\t\t\t  be32_to_cpu(sa_path_get_dlid(pathrec)),\n\t\t\t  pathrec->dgid.raw);\n\telse\n\t\tipoib_dbg(priv, \"PathRec status %d for GID %pI6\\n\",\n\t\t\t  status, path->pathrec.dgid.raw);\n\n\tskb_queue_head_init(&skqueue);\n\n\tif (!status) {\n\t\tstruct rdma_ah_attr av;\n\n\t\tif (!ib_init_ah_attr_from_path(priv->ca, priv->port,\n\t\t\t\t\t       pathrec, &av, NULL)) {\n\t\t\tah = ipoib_create_ah(dev, priv->pd, &av);\n\t\t\trdma_destroy_ah_attr(&av);\n\t\t}\n\t}\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tif (!IS_ERR_OR_NULL(ah)) {\n\t\t \n\t\tif (memcmp(pathrec->dgid.raw, path->pathrec.dgid.raw,\n\t\t\t   sizeof(union ib_gid))) {\n\t\t\tipoib_dbg(\n\t\t\t\tpriv,\n\t\t\t\t\"%s got PathRec for gid %pI6 while asked for %pI6\\n\",\n\t\t\t\tdev->name, pathrec->dgid.raw,\n\t\t\t\tpath->pathrec.dgid.raw);\n\t\t\tmemcpy(pathrec->dgid.raw, path->pathrec.dgid.raw,\n\t\t\t       sizeof(union ib_gid));\n\t\t}\n\n\t\tpath->pathrec = *pathrec;\n\n\t\told_ah   = path->ah;\n\t\tpath->ah = ah;\n\n\t\tipoib_dbg(priv, \"created address handle %p for LID 0x%04x, SL %d\\n\",\n\t\t\t  ah, be32_to_cpu(sa_path_get_dlid(pathrec)),\n\t\t\t  pathrec->sl);\n\n\t\twhile ((skb = __skb_dequeue(&path->queue)))\n\t\t\t__skb_queue_tail(&skqueue, skb);\n\n\t\tlist_for_each_entry_safe(neigh, tn, &path->neigh_list, list) {\n\t\t\tif (neigh->ah) {\n\t\t\t\tWARN_ON(neigh->ah != old_ah);\n\t\t\t\t \n\t\t\t\tipoib_put_ah(neigh->ah);\n\t\t\t}\n\t\t\tkref_get(&path->ah->ref);\n\t\t\tneigh->ah = path->ah;\n\n\t\t\tif (ipoib_cm_enabled(dev, neigh->daddr)) {\n\t\t\t\tif (!ipoib_cm_get(neigh))\n\t\t\t\t\tipoib_cm_set(neigh, ipoib_cm_create_tx(dev,\n\t\t\t\t\t\t\t\t\t       path,\n\t\t\t\t\t\t\t\t\t       neigh));\n\t\t\t\tif (!ipoib_cm_get(neigh)) {\n\t\t\t\t\tipoib_neigh_free(neigh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\twhile ((skb = __skb_dequeue(&neigh->queue)))\n\t\t\t\t__skb_queue_tail(&skqueue, skb);\n\t\t}\n\t\tpath->ah->valid = 1;\n\t}\n\n\tpath->query = NULL;\n\tcomplete(&path->done);\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\tif (IS_ERR_OR_NULL(ah))\n\t\tipoib_del_neighs_by_gid(dev, path->pathrec.dgid.raw);\n\n\tif (old_ah)\n\t\tipoib_put_ah(old_ah);\n\n\twhile ((skb = __skb_dequeue(&skqueue))) {\n\t\tint ret;\n\t\tskb->dev = dev;\n\t\tret = dev_queue_xmit(skb);\n\t\tif (ret)\n\t\t\tipoib_warn(priv, \"%s: dev_queue_xmit failed to re-queue packet, ret:%d\\n\",\n\t\t\t\t   __func__, ret);\n\t}\n}\n\nstatic void init_path_rec(struct ipoib_dev_priv *priv, struct ipoib_path *path,\n\t\t\t  void *gid)\n{\n\tpath->dev = priv->dev;\n\n\tif (rdma_cap_opa_ah(priv->ca, priv->port))\n\t\tpath->pathrec.rec_type = SA_PATH_REC_TYPE_OPA;\n\telse\n\t\tpath->pathrec.rec_type = SA_PATH_REC_TYPE_IB;\n\n\tmemcpy(path->pathrec.dgid.raw, gid, sizeof(union ib_gid));\n\tpath->pathrec.sgid\t    = priv->local_gid;\n\tpath->pathrec.pkey\t    = cpu_to_be16(priv->pkey);\n\tpath->pathrec.numb_path     = 1;\n\tpath->pathrec.traffic_class = priv->broadcast->mcmember.traffic_class;\n}\n\nstatic struct ipoib_path *path_rec_create(struct net_device *dev, void *gid)\n{\n\tstruct ipoib_dev_priv *priv = ipoib_priv(dev);\n\tstruct ipoib_path *path;\n\n\tif (!priv->broadcast)\n\t\treturn NULL;\n\n\tpath = kzalloc(sizeof(*path), GFP_ATOMIC);\n\tif (!path)\n\t\treturn NULL;\n\n\tskb_queue_head_init(&path->queue);\n\n\tINIT_LIST_HEAD(&path->neigh_list);\n\n\tinit_path_rec(priv, path, gid);\n\n\treturn path;\n}\n\nstatic int path_rec_start(struct net_device *dev,\n\t\t\t  struct ipoib_path *path)\n{\n\tstruct ipoib_dev_priv *priv = ipoib_priv(dev);\n\n\tipoib_dbg(priv, \"Start path record lookup for %pI6\\n\",\n\t\t  path->pathrec.dgid.raw);\n\n\tinit_completion(&path->done);\n\n\tpath->query_id =\n\t\tib_sa_path_rec_get(&ipoib_sa_client, priv->ca, priv->port,\n\t\t\t\t   &path->pathrec,\n\t\t\t\t   IB_SA_PATH_REC_DGID\t\t|\n\t\t\t\t   IB_SA_PATH_REC_SGID\t\t|\n\t\t\t\t   IB_SA_PATH_REC_NUMB_PATH\t|\n\t\t\t\t   IB_SA_PATH_REC_TRAFFIC_CLASS |\n\t\t\t\t   IB_SA_PATH_REC_PKEY,\n\t\t\t\t   1000, GFP_ATOMIC,\n\t\t\t\t   path_rec_completion,\n\t\t\t\t   path, &path->query);\n\tif (path->query_id < 0) {\n\t\tipoib_warn(priv, \"ib_sa_path_rec_get failed: %d\\n\", path->query_id);\n\t\tpath->query = NULL;\n\t\tcomplete(&path->done);\n\t\treturn path->query_id;\n\t}\n\n\treturn 0;\n}\n\nstatic void neigh_refresh_path(struct ipoib_neigh *neigh, u8 *daddr,\n\t\t\t       struct net_device *dev)\n{\n\tstruct ipoib_dev_priv *priv = ipoib_priv(dev);\n\tstruct ipoib_path *path;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tpath = __path_find(dev, daddr + 4);\n\tif (!path)\n\t\tgoto out;\n\tif (!path->query)\n\t\tpath_rec_start(dev, path);\nout:\n\tspin_unlock_irqrestore(&priv->lock, flags);\n}\n\nstatic struct ipoib_neigh *neigh_add_path(struct sk_buff *skb, u8 *daddr,\n\t\t\t\t\t  struct net_device *dev)\n{\n\tstruct ipoib_dev_priv *priv = ipoib_priv(dev);\n\tstruct rdma_netdev *rn = netdev_priv(dev);\n\tstruct ipoib_path *path;\n\tstruct ipoib_neigh *neigh;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tneigh = ipoib_neigh_alloc(daddr, dev);\n\tif (!neigh) {\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\t++dev->stats.tx_dropped;\n\t\tdev_kfree_skb_any(skb);\n\t\treturn NULL;\n\t}\n\n\t \n\tif (unlikely(!list_empty(&neigh->list))) {\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\treturn neigh;\n\t}\n\n\tpath = __path_find(dev, daddr + 4);\n\tif (!path) {\n\t\tpath = path_rec_create(dev, daddr + 4);\n\t\tif (!path)\n\t\t\tgoto err_path;\n\n\t\t__path_add(dev, path);\n\t}\n\n\tlist_add_tail(&neigh->list, &path->neigh_list);\n\n\tif (path->ah && path->ah->valid) {\n\t\tkref_get(&path->ah->ref);\n\t\tneigh->ah = path->ah;\n\n\t\tif (ipoib_cm_enabled(dev, neigh->daddr)) {\n\t\t\tif (!ipoib_cm_get(neigh))\n\t\t\t\tipoib_cm_set(neigh, ipoib_cm_create_tx(dev, path, neigh));\n\t\t\tif (!ipoib_cm_get(neigh)) {\n\t\t\t\tipoib_neigh_free(neigh);\n\t\t\t\tgoto err_drop;\n\t\t\t}\n\t\t\tif (skb_queue_len(&neigh->queue) <\n\t\t\t    IPOIB_MAX_PATH_REC_QUEUE) {\n\t\t\t\tpush_pseudo_header(skb, neigh->daddr);\n\t\t\t\t__skb_queue_tail(&neigh->queue, skb);\n\t\t\t} else {\n\t\t\t\tipoib_warn(priv, \"queue length limit %d. Packet drop.\\n\",\n\t\t\t\t\t   skb_queue_len(&neigh->queue));\n\t\t\t\tgoto err_drop;\n\t\t\t}\n\t\t} else {\n\t\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\t\tpath->ah->last_send = rn->send(dev, skb, path->ah->ah,\n\t\t\t\t\t\t       IPOIB_QPN(daddr));\n\t\t\tipoib_neigh_put(neigh);\n\t\t\treturn NULL;\n\t\t}\n\t} else {\n\t\tneigh->ah  = NULL;\n\n\t\tif (!path->query && path_rec_start(dev, path))\n\t\t\tgoto err_path;\n\t\tif (skb_queue_len(&neigh->queue) < IPOIB_MAX_PATH_REC_QUEUE) {\n\t\t\tpush_pseudo_header(skb, neigh->daddr);\n\t\t\t__skb_queue_tail(&neigh->queue, skb);\n\t\t} else {\n\t\t\tgoto err_drop;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\tipoib_neigh_put(neigh);\n\treturn NULL;\n\nerr_path:\n\tipoib_neigh_free(neigh);\nerr_drop:\n\t++dev->stats.tx_dropped;\n\tdev_kfree_skb_any(skb);\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\tipoib_neigh_put(neigh);\n\n\treturn NULL;\n}\n\nstatic void unicast_arp_send(struct sk_buff *skb, struct net_device *dev,\n\t\t\t     struct ipoib_pseudo_header *phdr)\n{\n\tstruct ipoib_dev_priv *priv = ipoib_priv(dev);\n\tstruct rdma_netdev *rn = netdev_priv(dev);\n\tstruct ipoib_path *path;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\t \n\tif (!priv->broadcast)\n\t\tgoto drop_and_unlock;\n\n\tpath = __path_find(dev, phdr->hwaddr + 4);\n\tif (!path || !path->ah || !path->ah->valid) {\n\t\tif (!path) {\n\t\t\tpath = path_rec_create(dev, phdr->hwaddr + 4);\n\t\t\tif (!path)\n\t\t\t\tgoto drop_and_unlock;\n\t\t\t__path_add(dev, path);\n\t\t} else {\n\t\t\t \n\t\t\tinit_path_rec(priv, path, phdr->hwaddr + 4);\n\t\t}\n\t\tif (!path->query && path_rec_start(dev, path)) {\n\t\t\tgoto drop_and_unlock;\n\t\t}\n\n\t\tif (skb_queue_len(&path->queue) < IPOIB_MAX_PATH_REC_QUEUE) {\n\t\t\tpush_pseudo_header(skb, phdr->hwaddr);\n\t\t\t__skb_queue_tail(&path->queue, skb);\n\t\t\tgoto unlock;\n\t\t} else {\n\t\t\tgoto drop_and_unlock;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\tipoib_dbg(priv, \"Send unicast ARP to %08x\\n\",\n\t\t  be32_to_cpu(sa_path_get_dlid(&path->pathrec)));\n\tpath->ah->last_send = rn->send(dev, skb, path->ah->ah,\n\t\t\t\t       IPOIB_QPN(phdr->hwaddr));\n\treturn;\n\ndrop_and_unlock:\n\t++dev->stats.tx_dropped;\n\tdev_kfree_skb_any(skb);\nunlock:\n\tspin_unlock_irqrestore(&priv->lock, flags);\n}\n\nstatic netdev_tx_t ipoib_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct ipoib_dev_priv *priv = ipoib_priv(dev);\n\tstruct rdma_netdev *rn = netdev_priv(dev);\n\tstruct ipoib_neigh *neigh;\n\tstruct ipoib_pseudo_header *phdr;\n\tstruct ipoib_header *header;\n\tunsigned long flags;\n\n\tphdr = (struct ipoib_pseudo_header *) skb->data;\n\tskb_pull(skb, sizeof(*phdr));\n\theader = (struct ipoib_header *) skb->data;\n\n\tif (unlikely(phdr->hwaddr[4] == 0xff)) {\n\t\t \n\t\tif ((header->proto != htons(ETH_P_IP)) &&\n\t\t    (header->proto != htons(ETH_P_IPV6)) &&\n\t\t    (header->proto != htons(ETH_P_ARP)) &&\n\t\t    (header->proto != htons(ETH_P_RARP)) &&\n\t\t    (header->proto != htons(ETH_P_TIPC))) {\n\t\t\t \n\t\t\t++dev->stats.tx_dropped;\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\treturn NETDEV_TX_OK;\n\t\t}\n\t\t \n\t\tphdr->hwaddr[8] = (priv->pkey >> 8) & 0xff;\n\t\tphdr->hwaddr[9] = priv->pkey & 0xff;\n\n\t\tneigh = ipoib_neigh_get(dev, phdr->hwaddr);\n\t\tif (likely(neigh))\n\t\t\tgoto send_using_neigh;\n\t\tipoib_mcast_send(dev, phdr->hwaddr, skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\t \n\tswitch (header->proto) {\n\tcase htons(ETH_P_IP):\n\tcase htons(ETH_P_IPV6):\n\tcase htons(ETH_P_TIPC):\n\t\tneigh = ipoib_neigh_get(dev, phdr->hwaddr);\n\t\tif (unlikely(!neigh)) {\n\t\t\tneigh = neigh_add_path(skb, phdr->hwaddr, dev);\n\t\t\tif (likely(!neigh))\n\t\t\t\treturn NETDEV_TX_OK;\n\t\t}\n\t\tbreak;\n\tcase htons(ETH_P_ARP):\n\tcase htons(ETH_P_RARP):\n\t\t \n\t\tunicast_arp_send(skb, dev, phdr);\n\t\treturn NETDEV_TX_OK;\n\tdefault:\n\t\t \n\t\t++dev->stats.tx_dropped;\n\t\tdev_kfree_skb_any(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\nsend_using_neigh:\n\t \n\tif (ipoib_cm_get(neigh)) {\n\t\tif (ipoib_cm_up(neigh)) {\n\t\t\tipoib_cm_send(dev, skb, ipoib_cm_get(neigh));\n\t\t\tgoto unref;\n\t\t}\n\t} else if (neigh->ah && neigh->ah->valid) {\n\t\tneigh->ah->last_send = rn->send(dev, skb, neigh->ah->ah,\n\t\t\t\t\t\tIPOIB_QPN(phdr->hwaddr));\n\t\tgoto unref;\n\t} else if (neigh->ah) {\n\t\tneigh_refresh_path(neigh, phdr->hwaddr, dev);\n\t}\n\n\tif (skb_queue_len(&neigh->queue) < IPOIB_MAX_PATH_REC_QUEUE) {\n\t\tpush_pseudo_header(skb, phdr->hwaddr);\n\t\tspin_lock_irqsave(&priv->lock, flags);\n\t\t__skb_queue_tail(&neigh->queue, skb);\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t} else {\n\t\t++dev->stats.tx_dropped;\n\t\tdev_kfree_skb_any(skb);\n\t}\n\nunref:\n\tipoib_neigh_put(neigh);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic void ipoib_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct ipoib_dev_priv *priv = ipoib_priv(dev);\n\tstruct rdma_netdev *rn = netdev_priv(dev);\n\n\tif (rn->tx_timeout) {\n\t\trn->tx_timeout(dev, txqueue);\n\t\treturn;\n\t}\n\tipoib_warn(priv, \"transmit timeout: latency %d msecs\\n\",\n\t\t   jiffies_to_msecs(jiffies - dev_trans_start(dev)));\n\tipoib_warn(priv,\n\t\t   \"queue stopped %d, tx_head %u, tx_tail %u, global_tx_head %u, global_tx_tail %u\\n\",\n\t\t   netif_queue_stopped(dev), priv->tx_head, priv->tx_tail,\n\t\t   priv->global_tx_head, priv->global_tx_tail);\n\n\t \n}\n\nstatic int ipoib_hard_header(struct sk_buff *skb,\n\t\t\t     struct net_device *dev,\n\t\t\t     unsigned short type,\n\t\t\t     const void *daddr,\n\t\t\t     const void *saddr,\n\t\t\t     unsigned int len)\n{\n\tstruct ipoib_header *header;\n\n\theader = skb_push(skb, sizeof(*header));\n\n\theader->proto = htons(type);\n\theader->reserved = 0;\n\n\t \n\tpush_pseudo_header(skb, daddr);\n\n\treturn IPOIB_HARD_LEN;\n}\n\nstatic void ipoib_set_mcast_list(struct net_device *dev)\n{\n\tstruct ipoib_dev_priv *priv = ipoib_priv(dev);\n\n\tif (!test_bit(IPOIB_FLAG_OPER_UP, &priv->flags)) {\n\t\tipoib_dbg(priv, \"IPOIB_FLAG_OPER_UP not set\");\n\t\treturn;\n\t}\n\n\tqueue_work(priv->wq, &priv->restart_task);\n}\n\nstatic int ipoib_get_iflink(const struct net_device *dev)\n{\n\tstruct ipoib_dev_priv *priv = ipoib_priv(dev);\n\n\t \n\tif (!test_bit(IPOIB_FLAG_SUBINTERFACE, &priv->flags))\n\t\treturn dev->ifindex;\n\n\t \n\treturn priv->parent->ifindex;\n}\n\nstatic u32 ipoib_addr_hash(struct ipoib_neigh_hash *htbl, u8 *daddr)\n{\n\t \n\t  \n\tu32 *d32 = (u32 *) daddr;\n\tu32 hv;\n\n\thv = jhash_3words(d32[3], d32[4], IPOIB_QPN_MASK & d32[0], 0);\n\treturn hv & htbl->mask;\n}\n\nstruct ipoib_neigh *ipoib_neigh_get(struct net_device *dev, u8 *daddr)\n{\n\tstruct ipoib_dev_priv *priv = ipoib_priv(dev);\n\tstruct ipoib_neigh_table *ntbl = &priv->ntbl;\n\tstruct ipoib_neigh_hash *htbl;\n\tstruct ipoib_neigh *neigh = NULL;\n\tu32 hash_val;\n\n\trcu_read_lock_bh();\n\n\thtbl = rcu_dereference_bh(ntbl->htbl);\n\n\tif (!htbl)\n\t\tgoto out_unlock;\n\n\thash_val = ipoib_addr_hash(htbl, daddr);\n\tfor (neigh = rcu_dereference_bh(htbl->buckets[hash_val]);\n\t     neigh != NULL;\n\t     neigh = rcu_dereference_bh(neigh->hnext)) {\n\t\tif (memcmp(daddr, neigh->daddr, INFINIBAND_ALEN) == 0) {\n\t\t\t \n\t\t\tif (!refcount_inc_not_zero(&neigh->refcnt)) {\n\t\t\t\t \n\t\t\t\tneigh = NULL;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\n\t\t\tif (likely(skb_queue_len(&neigh->queue) < IPOIB_MAX_PATH_REC_QUEUE))\n\t\t\t\tneigh->alive = jiffies;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\nout_unlock:\n\trcu_read_unlock_bh();\n\treturn neigh;\n}\n\nstatic void __ipoib_reap_neigh(struct ipoib_dev_priv *priv)\n{\n\tstruct ipoib_neigh_table *ntbl = &priv->ntbl;\n\tstruct ipoib_neigh_hash *htbl;\n\tunsigned long neigh_obsolete;\n\tunsigned long dt;\n\tunsigned long flags;\n\tint i;\n\tLIST_HEAD(remove_list);\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\thtbl = rcu_dereference_protected(ntbl->htbl,\n\t\t\t\t\t lockdep_is_held(&priv->lock));\n\n\tif (!htbl)\n\t\tgoto out_unlock;\n\n\t \n\tdt = 2 * arp_tbl.gc_interval;\n\tneigh_obsolete = jiffies - dt;\n\n\tfor (i = 0; i < htbl->size; i++) {\n\t\tstruct ipoib_neigh *neigh;\n\t\tstruct ipoib_neigh __rcu **np = &htbl->buckets[i];\n\n\t\twhile ((neigh = rcu_dereference_protected(*np,\n\t\t\t\t\t\t\t  lockdep_is_held(&priv->lock))) != NULL) {\n\t\t\t \n\t\t\tif (time_after(neigh_obsolete, neigh->alive)) {\n\n\t\t\t\tipoib_check_and_add_mcast_sendonly(priv, neigh->daddr + 4, &remove_list);\n\n\t\t\t\trcu_assign_pointer(*np,\n\t\t\t\t\t\t   rcu_dereference_protected(neigh->hnext,\n\t\t\t\t\t\t\t\t\t     lockdep_is_held(&priv->lock)));\n\t\t\t\t \n\t\t\t\tlist_del_init(&neigh->list);\n\t\t\t\tcall_rcu(&neigh->rcu, ipoib_neigh_reclaim);\n\t\t\t} else {\n\t\t\t\tnp = &neigh->hnext;\n\t\t\t}\n\n\t\t}\n\t}\n\nout_unlock:\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\tipoib_mcast_remove_list(&remove_list);\n}\n\nstatic void ipoib_reap_neigh(struct work_struct *work)\n{\n\tstruct ipoib_dev_priv *priv =\n\t\tcontainer_of(work, struct ipoib_dev_priv, neigh_reap_task.work);\n\n\t__ipoib_reap_neigh(priv);\n\n\tqueue_delayed_work(priv->wq, &priv->neigh_reap_task,\n\t\t\t   arp_tbl.gc_interval);\n}\n\n\nstatic struct ipoib_neigh *ipoib_neigh_ctor(u8 *daddr,\n\t\t\t\t      struct net_device *dev)\n{\n\tstruct ipoib_neigh *neigh;\n\n\tneigh = kzalloc(sizeof(*neigh), GFP_ATOMIC);\n\tif (!neigh)\n\t\treturn NULL;\n\n\tneigh->dev = dev;\n\tmemcpy(&neigh->daddr, daddr, sizeof(neigh->daddr));\n\tskb_queue_head_init(&neigh->queue);\n\tINIT_LIST_HEAD(&neigh->list);\n\tipoib_cm_set(neigh, NULL);\n\t \n\trefcount_set(&neigh->refcnt, 1);\n\n\treturn neigh;\n}\n\nstruct ipoib_neigh *ipoib_neigh_alloc(u8 *daddr,\n\t\t\t\t      struct net_device *dev)\n{\n\tstruct ipoib_dev_priv *priv = ipoib_priv(dev);\n\tstruct ipoib_neigh_table *ntbl = &priv->ntbl;\n\tstruct ipoib_neigh_hash *htbl;\n\tstruct ipoib_neigh *neigh;\n\tu32 hash_val;\n\n\thtbl = rcu_dereference_protected(ntbl->htbl,\n\t\t\t\t\t lockdep_is_held(&priv->lock));\n\tif (!htbl) {\n\t\tneigh = NULL;\n\t\tgoto out_unlock;\n\t}\n\n\t \n\thash_val = ipoib_addr_hash(htbl, daddr);\n\tfor (neigh = rcu_dereference_protected(htbl->buckets[hash_val],\n\t\t\t\t\t       lockdep_is_held(&priv->lock));\n\t     neigh != NULL;\n\t     neigh = rcu_dereference_protected(neigh->hnext,\n\t\t\t\t\t       lockdep_is_held(&priv->lock))) {\n\t\tif (memcmp(daddr, neigh->daddr, INFINIBAND_ALEN) == 0) {\n\t\t\t \n\t\t\tif (!refcount_inc_not_zero(&neigh->refcnt)) {\n\t\t\t\t \n\t\t\t\tneigh = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tneigh->alive = jiffies;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tneigh = ipoib_neigh_ctor(daddr, dev);\n\tif (!neigh)\n\t\tgoto out_unlock;\n\n\t \n\trefcount_inc(&neigh->refcnt);\n\tneigh->alive = jiffies;\n\t \n\trcu_assign_pointer(neigh->hnext,\n\t\t\t   rcu_dereference_protected(htbl->buckets[hash_val],\n\t\t\t\t\t\t     lockdep_is_held(&priv->lock)));\n\trcu_assign_pointer(htbl->buckets[hash_val], neigh);\n\tatomic_inc(&ntbl->entries);\n\nout_unlock:\n\n\treturn neigh;\n}\n\nvoid ipoib_neigh_dtor(struct ipoib_neigh *neigh)\n{\n\t \n\tstruct net_device *dev = neigh->dev;\n\tstruct ipoib_dev_priv *priv = ipoib_priv(dev);\n\tstruct sk_buff *skb;\n\tif (neigh->ah)\n\t\tipoib_put_ah(neigh->ah);\n\twhile ((skb = __skb_dequeue(&neigh->queue))) {\n\t\t++dev->stats.tx_dropped;\n\t\tdev_kfree_skb_any(skb);\n\t}\n\tif (ipoib_cm_get(neigh))\n\t\tipoib_cm_destroy_tx(ipoib_cm_get(neigh));\n\tipoib_dbg(ipoib_priv(dev),\n\t\t  \"neigh free for %06x %pI6\\n\",\n\t\t  IPOIB_QPN(neigh->daddr),\n\t\t  neigh->daddr + 4);\n\tkfree(neigh);\n\tif (atomic_dec_and_test(&priv->ntbl.entries)) {\n\t\tif (test_bit(IPOIB_NEIGH_TBL_FLUSH, &priv->flags))\n\t\t\tcomplete(&priv->ntbl.flushed);\n\t}\n}\n\nstatic void ipoib_neigh_reclaim(struct rcu_head *rp)\n{\n\t \n\tstruct ipoib_neigh *neigh = container_of(rp, struct ipoib_neigh, rcu);\n\t \n\tipoib_neigh_put(neigh);\n}\n\nvoid ipoib_neigh_free(struct ipoib_neigh *neigh)\n{\n\tstruct net_device *dev = neigh->dev;\n\tstruct ipoib_dev_priv *priv = ipoib_priv(dev);\n\tstruct ipoib_neigh_table *ntbl = &priv->ntbl;\n\tstruct ipoib_neigh_hash *htbl;\n\tstruct ipoib_neigh __rcu **np;\n\tstruct ipoib_neigh *n;\n\tu32 hash_val;\n\n\thtbl = rcu_dereference_protected(ntbl->htbl,\n\t\t\t\t\tlockdep_is_held(&priv->lock));\n\tif (!htbl)\n\t\treturn;\n\n\thash_val = ipoib_addr_hash(htbl, neigh->daddr);\n\tnp = &htbl->buckets[hash_val];\n\tfor (n = rcu_dereference_protected(*np,\n\t\t\t\t\t    lockdep_is_held(&priv->lock));\n\t     n != NULL;\n\t     n = rcu_dereference_protected(*np,\n\t\t\t\t\tlockdep_is_held(&priv->lock))) {\n\t\tif (n == neigh) {\n\t\t\t \n\t\t\trcu_assign_pointer(*np,\n\t\t\t\t\t   rcu_dereference_protected(neigh->hnext,\n\t\t\t\t\t\t\t\t     lockdep_is_held(&priv->lock)));\n\t\t\t \n\t\t\tlist_del_init(&neigh->list);\n\t\t\tcall_rcu(&neigh->rcu, ipoib_neigh_reclaim);\n\t\t\treturn;\n\t\t} else {\n\t\t\tnp = &n->hnext;\n\t\t}\n\t}\n}\n\nstatic int ipoib_neigh_hash_init(struct ipoib_dev_priv *priv)\n{\n\tstruct ipoib_neigh_table *ntbl = &priv->ntbl;\n\tstruct ipoib_neigh_hash *htbl;\n\tstruct ipoib_neigh __rcu **buckets;\n\tu32 size;\n\n\tclear_bit(IPOIB_NEIGH_TBL_FLUSH, &priv->flags);\n\tntbl->htbl = NULL;\n\thtbl = kzalloc(sizeof(*htbl), GFP_KERNEL);\n\tif (!htbl)\n\t\treturn -ENOMEM;\n\tsize = roundup_pow_of_two(arp_tbl.gc_thresh3);\n\tbuckets = kvcalloc(size, sizeof(*buckets), GFP_KERNEL);\n\tif (!buckets) {\n\t\tkfree(htbl);\n\t\treturn -ENOMEM;\n\t}\n\thtbl->size = size;\n\thtbl->mask = (size - 1);\n\thtbl->buckets = buckets;\n\tRCU_INIT_POINTER(ntbl->htbl, htbl);\n\thtbl->ntbl = ntbl;\n\tatomic_set(&ntbl->entries, 0);\n\n\t \n\tqueue_delayed_work(priv->wq, &priv->neigh_reap_task,\n\t\t\t   arp_tbl.gc_interval);\n\n\treturn 0;\n}\n\nstatic void neigh_hash_free_rcu(struct rcu_head *head)\n{\n\tstruct ipoib_neigh_hash *htbl = container_of(head,\n\t\t\t\t\t\t    struct ipoib_neigh_hash,\n\t\t\t\t\t\t    rcu);\n\tstruct ipoib_neigh __rcu **buckets = htbl->buckets;\n\tstruct ipoib_neigh_table *ntbl = htbl->ntbl;\n\n\tkvfree(buckets);\n\tkfree(htbl);\n\tcomplete(&ntbl->deleted);\n}\n\nvoid ipoib_del_neighs_by_gid(struct net_device *dev, u8 *gid)\n{\n\tstruct ipoib_dev_priv *priv = ipoib_priv(dev);\n\tstruct ipoib_neigh_table *ntbl = &priv->ntbl;\n\tstruct ipoib_neigh_hash *htbl;\n\tunsigned long flags;\n\tint i;\n\n\t \n\tspin_lock_irqsave(&priv->lock, flags);\n\n\thtbl = rcu_dereference_protected(ntbl->htbl,\n\t\t\t\t\t lockdep_is_held(&priv->lock));\n\n\tif (!htbl)\n\t\tgoto out_unlock;\n\n\tfor (i = 0; i < htbl->size; i++) {\n\t\tstruct ipoib_neigh *neigh;\n\t\tstruct ipoib_neigh __rcu **np = &htbl->buckets[i];\n\n\t\twhile ((neigh = rcu_dereference_protected(*np,\n\t\t\t\t\t\t\t  lockdep_is_held(&priv->lock))) != NULL) {\n\t\t\t \n\t\t\tif (!memcmp(gid, neigh->daddr + 4, sizeof (union ib_gid))) {\n\t\t\t\trcu_assign_pointer(*np,\n\t\t\t\t\t\t   rcu_dereference_protected(neigh->hnext,\n\t\t\t\t\t\t\t\t\t     lockdep_is_held(&priv->lock)));\n\t\t\t\t \n\t\t\t\tlist_del_init(&neigh->list);\n\t\t\t\tcall_rcu(&neigh->rcu, ipoib_neigh_reclaim);\n\t\t\t} else {\n\t\t\t\tnp = &neigh->hnext;\n\t\t\t}\n\n\t\t}\n\t}\nout_unlock:\n\tspin_unlock_irqrestore(&priv->lock, flags);\n}\n\nstatic void ipoib_flush_neighs(struct ipoib_dev_priv *priv)\n{\n\tstruct ipoib_neigh_table *ntbl = &priv->ntbl;\n\tstruct ipoib_neigh_hash *htbl;\n\tunsigned long flags;\n\tint i, wait_flushed = 0;\n\n\tinit_completion(&priv->ntbl.flushed);\n\tset_bit(IPOIB_NEIGH_TBL_FLUSH, &priv->flags);\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\thtbl = rcu_dereference_protected(ntbl->htbl,\n\t\t\t\t\tlockdep_is_held(&priv->lock));\n\tif (!htbl)\n\t\tgoto out_unlock;\n\n\twait_flushed = atomic_read(&priv->ntbl.entries);\n\tif (!wait_flushed)\n\t\tgoto free_htbl;\n\n\tfor (i = 0; i < htbl->size; i++) {\n\t\tstruct ipoib_neigh *neigh;\n\t\tstruct ipoib_neigh __rcu **np = &htbl->buckets[i];\n\n\t\twhile ((neigh = rcu_dereference_protected(*np,\n\t\t\t\t       lockdep_is_held(&priv->lock))) != NULL) {\n\t\t\trcu_assign_pointer(*np,\n\t\t\t\t\t   rcu_dereference_protected(neigh->hnext,\n\t\t\t\t\t\t\t\t     lockdep_is_held(&priv->lock)));\n\t\t\t \n\t\t\tlist_del_init(&neigh->list);\n\t\t\tcall_rcu(&neigh->rcu, ipoib_neigh_reclaim);\n\t\t}\n\t}\n\nfree_htbl:\n\trcu_assign_pointer(ntbl->htbl, NULL);\n\tcall_rcu(&htbl->rcu, neigh_hash_free_rcu);\n\nout_unlock:\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\tif (wait_flushed)\n\t\twait_for_completion(&priv->ntbl.flushed);\n}\n\nstatic void ipoib_neigh_hash_uninit(struct net_device *dev)\n{\n\tstruct ipoib_dev_priv *priv = ipoib_priv(dev);\n\n\tipoib_dbg(priv, \"%s\\n\", __func__);\n\tinit_completion(&priv->ntbl.deleted);\n\n\tcancel_delayed_work_sync(&priv->neigh_reap_task);\n\n\tipoib_flush_neighs(priv);\n\n\twait_for_completion(&priv->ntbl.deleted);\n}\n\nstatic void ipoib_napi_add(struct net_device *dev)\n{\n\tstruct ipoib_dev_priv *priv = ipoib_priv(dev);\n\n\tnetif_napi_add_weight(dev, &priv->recv_napi, ipoib_rx_poll,\n\t\t\t      IPOIB_NUM_WC);\n\tnetif_napi_add_weight(dev, &priv->send_napi, ipoib_tx_poll,\n\t\t\t      MAX_SEND_CQE);\n}\n\nstatic void ipoib_napi_del(struct net_device *dev)\n{\n\tstruct ipoib_dev_priv *priv = ipoib_priv(dev);\n\n\tnetif_napi_del(&priv->recv_napi);\n\tnetif_napi_del(&priv->send_napi);\n}\n\nstatic void ipoib_dev_uninit_default(struct net_device *dev)\n{\n\tstruct ipoib_dev_priv *priv = ipoib_priv(dev);\n\n\tipoib_transport_dev_cleanup(dev);\n\n\tipoib_napi_del(dev);\n\n\tipoib_cm_dev_cleanup(dev);\n\n\tkfree(priv->rx_ring);\n\tvfree(priv->tx_ring);\n\n\tpriv->rx_ring = NULL;\n\tpriv->tx_ring = NULL;\n}\n\nstatic int ipoib_dev_init_default(struct net_device *dev)\n{\n\tstruct ipoib_dev_priv *priv = ipoib_priv(dev);\n\tu8 addr_mod[3];\n\n\tipoib_napi_add(dev);\n\n\t \n\tpriv->rx_ring =\tkcalloc(ipoib_recvq_size,\n\t\t\t\t       sizeof(*priv->rx_ring),\n\t\t\t\t       GFP_KERNEL);\n\tif (!priv->rx_ring)\n\t\tgoto out;\n\n\tpriv->tx_ring = vzalloc(array_size(ipoib_sendq_size,\n\t\t\t\t\t   sizeof(*priv->tx_ring)));\n\tif (!priv->tx_ring) {\n\t\tpr_warn(\"%s: failed to allocate TX ring (%d entries)\\n\",\n\t\t\tpriv->ca->name, ipoib_sendq_size);\n\t\tgoto out_rx_ring_cleanup;\n\t}\n\n\t \n\n\tif (ipoib_transport_dev_init(dev, priv->ca)) {\n\t\tpr_warn(\"%s: ipoib_transport_dev_init failed\\n\",\n\t\t\tpriv->ca->name);\n\t\tgoto out_tx_ring_cleanup;\n\t}\n\n\t \n\taddr_mod[0] = (priv->qp->qp_num >> 16) & 0xff;\n\taddr_mod[1] = (priv->qp->qp_num >>  8) & 0xff;\n\taddr_mod[2] = (priv->qp->qp_num) & 0xff;\n\tdev_addr_mod(priv->dev, 1, addr_mod, sizeof(addr_mod));\n\n\treturn 0;\n\nout_tx_ring_cleanup:\n\tvfree(priv->tx_ring);\n\nout_rx_ring_cleanup:\n\tkfree(priv->rx_ring);\n\nout:\n\tipoib_napi_del(dev);\n\treturn -ENOMEM;\n}\n\nstatic int ipoib_ioctl(struct net_device *dev, struct ifreq *ifr,\n\t\t       int cmd)\n{\n\tstruct ipoib_dev_priv *priv = ipoib_priv(dev);\n\n\tif (!priv->rn_ops->ndo_eth_ioctl)\n\t\treturn -EOPNOTSUPP;\n\n\treturn priv->rn_ops->ndo_eth_ioctl(dev, ifr, cmd);\n}\n\nstatic int ipoib_dev_init(struct net_device *dev)\n{\n\tstruct ipoib_dev_priv *priv = ipoib_priv(dev);\n\tint ret = -ENOMEM;\n\n\tpriv->qp = NULL;\n\n\t \n\tpriv->wq = alloc_ordered_workqueue(\"ipoib_wq\", WQ_MEM_RECLAIM);\n\tif (!priv->wq) {\n\t\tpr_warn(\"%s: failed to allocate device WQ\\n\", dev->name);\n\t\tgoto out;\n\t}\n\n\t \n\tpriv->pd = ib_alloc_pd(priv->ca, 0);\n\tif (IS_ERR(priv->pd)) {\n\t\tpr_warn(\"%s: failed to allocate PD\\n\", priv->ca->name);\n\t\tgoto clean_wq;\n\t}\n\n\tret = priv->rn_ops->ndo_init(dev);\n\tif (ret) {\n\t\tpr_warn(\"%s failed to init HW resource\\n\", dev->name);\n\t\tgoto out_free_pd;\n\t}\n\n\tret = ipoib_neigh_hash_init(priv);\n\tif (ret) {\n\t\tpr_warn(\"%s failed to init neigh hash\\n\", dev->name);\n\t\tgoto out_dev_uninit;\n\t}\n\n\tif (dev->flags & IFF_UP) {\n\t\tif (ipoib_ib_dev_open(dev)) {\n\t\t\tpr_warn(\"%s failed to open device\\n\", dev->name);\n\t\t\tret = -ENODEV;\n\t\t\tgoto out_hash_uninit;\n\t\t}\n\t}\n\n\treturn 0;\n\nout_hash_uninit:\n\tipoib_neigh_hash_uninit(dev);\n\nout_dev_uninit:\n\tipoib_ib_dev_cleanup(dev);\n\nout_free_pd:\n\tif (priv->pd) {\n\t\tib_dealloc_pd(priv->pd);\n\t\tpriv->pd = NULL;\n\t}\n\nclean_wq:\n\tif (priv->wq) {\n\t\tdestroy_workqueue(priv->wq);\n\t\tpriv->wq = NULL;\n\t}\n\nout:\n\treturn ret;\n}\n\n \nstatic void ipoib_parent_unregister_pre(struct net_device *ndev)\n{\n\tstruct ipoib_dev_priv *priv = ipoib_priv(ndev);\n\n\t \n\trtnl_lock();\n\tdev_change_flags(priv->dev, priv->dev->flags & ~IFF_UP, NULL);\n\trtnl_unlock();\n\n\t \n\tib_unregister_event_handler(&priv->event_handler);\n\n\t \n\tflush_workqueue(ipoib_workqueue);\n}\n\nstatic void ipoib_set_dev_features(struct ipoib_dev_priv *priv)\n{\n\tpriv->hca_caps = priv->ca->attrs.device_cap_flags;\n\tpriv->kernel_caps = priv->ca->attrs.kernel_cap_flags;\n\n\tif (priv->hca_caps & IB_DEVICE_UD_IP_CSUM) {\n\t\tpriv->dev->hw_features |= NETIF_F_IP_CSUM | NETIF_F_RXCSUM;\n\n\t\tif (priv->kernel_caps & IBK_UD_TSO)\n\t\t\tpriv->dev->hw_features |= NETIF_F_TSO;\n\n\t\tpriv->dev->features |= priv->dev->hw_features;\n\t}\n}\n\nstatic int ipoib_parent_init(struct net_device *ndev)\n{\n\tstruct ipoib_dev_priv *priv = ipoib_priv(ndev);\n\tstruct ib_port_attr attr;\n\tint result;\n\n\tresult = ib_query_port(priv->ca, priv->port, &attr);\n\tif (result) {\n\t\tpr_warn(\"%s: ib_query_port %d failed\\n\", priv->ca->name,\n\t\t\tpriv->port);\n\t\treturn result;\n\t}\n\tpriv->max_ib_mtu = rdma_mtu_from_attr(priv->ca, priv->port, &attr);\n\n\tresult = ib_query_pkey(priv->ca, priv->port, 0, &priv->pkey);\n\tif (result) {\n\t\tpr_warn(\"%s: ib_query_pkey port %d failed (ret = %d)\\n\",\n\t\t\tpriv->ca->name, priv->port, result);\n\t\treturn result;\n\t}\n\n\tresult = rdma_query_gid(priv->ca, priv->port, 0, &priv->local_gid);\n\tif (result) {\n\t\tpr_warn(\"%s: rdma_query_gid port %d failed (ret = %d)\\n\",\n\t\t\tpriv->ca->name, priv->port, result);\n\t\treturn result;\n\t}\n\tdev_addr_mod(priv->dev, 4, priv->local_gid.raw, sizeof(union ib_gid));\n\n\tSET_NETDEV_DEV(priv->dev, priv->ca->dev.parent);\n\tpriv->dev->dev_port = priv->port - 1;\n\t \n\tpriv->dev->dev_id = priv->port - 1;\n\n\treturn 0;\n}\n\nstatic void ipoib_child_init(struct net_device *ndev)\n{\n\tstruct ipoib_dev_priv *priv = ipoib_priv(ndev);\n\tstruct ipoib_dev_priv *ppriv = ipoib_priv(priv->parent);\n\n\tpriv->max_ib_mtu = ppriv->max_ib_mtu;\n\tset_bit(IPOIB_FLAG_SUBINTERFACE, &priv->flags);\n\tif (memchr_inv(priv->dev->dev_addr, 0, INFINIBAND_ALEN))\n\t\tmemcpy(&priv->local_gid, priv->dev->dev_addr + 4,\n\t\t       sizeof(priv->local_gid));\n\telse {\n\t\t__dev_addr_set(priv->dev, ppriv->dev->dev_addr,\n\t\t\t       INFINIBAND_ALEN);\n\t\tmemcpy(&priv->local_gid, &ppriv->local_gid,\n\t\t       sizeof(priv->local_gid));\n\t}\n}\n\nstatic int ipoib_ndo_init(struct net_device *ndev)\n{\n\tstruct ipoib_dev_priv *priv = ipoib_priv(ndev);\n\tint rc;\n\tstruct rdma_netdev *rn = netdev_priv(ndev);\n\n\tif (priv->parent) {\n\t\tipoib_child_init(ndev);\n\t} else {\n\t\trc = ipoib_parent_init(ndev);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\t \n\tndev->mtu = IPOIB_UD_MTU(priv->max_ib_mtu);\n\tpriv->mcast_mtu = priv->admin_mtu = ndev->mtu;\n\trn->mtu = priv->mcast_mtu;\n\tndev->max_mtu = IPOIB_CM_MTU;\n\n\tndev->neigh_priv_len = sizeof(struct ipoib_neigh);\n\n\t \n\tpriv->pkey |= 0x8000;\n\n\tndev->broadcast[8] = priv->pkey >> 8;\n\tndev->broadcast[9] = priv->pkey & 0xff;\n\tset_bit(IPOIB_FLAG_DEV_ADDR_SET, &priv->flags);\n\n\tipoib_set_dev_features(priv);\n\n\trc = ipoib_dev_init(ndev);\n\tif (rc) {\n\t\tpr_warn(\"%s: failed to initialize device: %s port %d (ret = %d)\\n\",\n\t\t\tpriv->ca->name, priv->dev->name, priv->port, rc);\n\t\treturn rc;\n\t}\n\n\tif (priv->parent) {\n\t\tstruct ipoib_dev_priv *ppriv = ipoib_priv(priv->parent);\n\n\t\tdev_hold(priv->parent);\n\n\t\tdown_write(&ppriv->vlan_rwsem);\n\t\tlist_add_tail(&priv->list, &ppriv->child_intfs);\n\t\tup_write(&ppriv->vlan_rwsem);\n\t}\n\n\treturn 0;\n}\n\nstatic void ipoib_ndo_uninit(struct net_device *dev)\n{\n\tstruct ipoib_dev_priv *priv = ipoib_priv(dev);\n\n\tASSERT_RTNL();\n\n\t \n\tWARN_ON(!list_empty(&priv->child_intfs));\n\n\tif (priv->parent) {\n\t\tstruct ipoib_dev_priv *ppriv = ipoib_priv(priv->parent);\n\n\t\tdown_write(&ppriv->vlan_rwsem);\n\t\tlist_del(&priv->list);\n\t\tup_write(&ppriv->vlan_rwsem);\n\t}\n\n\tipoib_neigh_hash_uninit(dev);\n\n\tipoib_ib_dev_cleanup(dev);\n\n\t \n\tif (priv->wq) {\n\t\t \n\t\tWARN_ON(test_bit(IPOIB_FLAG_OPER_UP, &priv->flags));\n\t\tdestroy_workqueue(priv->wq);\n\t\tpriv->wq = NULL;\n\t}\n\n\tif (priv->parent)\n\t\tdev_put(priv->parent);\n}\n\nstatic int ipoib_set_vf_link_state(struct net_device *dev, int vf, int link_state)\n{\n\tstruct ipoib_dev_priv *priv = ipoib_priv(dev);\n\n\treturn ib_set_vf_link_state(priv->ca, vf, priv->port, link_state);\n}\n\nstatic int ipoib_get_vf_config(struct net_device *dev, int vf,\n\t\t\t       struct ifla_vf_info *ivf)\n{\n\tstruct ipoib_dev_priv *priv = ipoib_priv(dev);\n\tint err;\n\n\terr = ib_get_vf_config(priv->ca, vf, priv->port, ivf);\n\tif (err)\n\t\treturn err;\n\n\tivf->vf = vf;\n\tmemcpy(ivf->mac, dev->dev_addr, dev->addr_len);\n\n\treturn 0;\n}\n\nstatic int ipoib_set_vf_guid(struct net_device *dev, int vf, u64 guid, int type)\n{\n\tstruct ipoib_dev_priv *priv = ipoib_priv(dev);\n\n\tif (type != IFLA_VF_IB_NODE_GUID && type != IFLA_VF_IB_PORT_GUID)\n\t\treturn -EINVAL;\n\n\treturn ib_set_vf_guid(priv->ca, vf, priv->port, guid, type);\n}\n\nstatic int ipoib_get_vf_guid(struct net_device *dev, int vf,\n\t\t\t     struct ifla_vf_guid *node_guid,\n\t\t\t     struct ifla_vf_guid *port_guid)\n{\n\tstruct ipoib_dev_priv *priv = ipoib_priv(dev);\n\n\treturn ib_get_vf_guid(priv->ca, vf, priv->port, node_guid, port_guid);\n}\n\nstatic int ipoib_get_vf_stats(struct net_device *dev, int vf,\n\t\t\t      struct ifla_vf_stats *vf_stats)\n{\n\tstruct ipoib_dev_priv *priv = ipoib_priv(dev);\n\n\treturn ib_get_vf_stats(priv->ca, vf, priv->port, vf_stats);\n}\n\nstatic const struct header_ops ipoib_header_ops = {\n\t.create\t= ipoib_hard_header,\n};\n\nstatic const struct net_device_ops ipoib_netdev_ops_pf = {\n\t.ndo_init\t\t = ipoib_ndo_init,\n\t.ndo_uninit\t\t = ipoib_ndo_uninit,\n\t.ndo_open\t\t = ipoib_open,\n\t.ndo_stop\t\t = ipoib_stop,\n\t.ndo_change_mtu\t\t = ipoib_change_mtu,\n\t.ndo_fix_features\t = ipoib_fix_features,\n\t.ndo_start_xmit\t\t = ipoib_start_xmit,\n\t.ndo_tx_timeout\t\t = ipoib_timeout,\n\t.ndo_set_rx_mode\t = ipoib_set_mcast_list,\n\t.ndo_get_iflink\t\t = ipoib_get_iflink,\n\t.ndo_set_vf_link_state\t = ipoib_set_vf_link_state,\n\t.ndo_get_vf_config\t = ipoib_get_vf_config,\n\t.ndo_get_vf_stats\t = ipoib_get_vf_stats,\n\t.ndo_get_vf_guid\t = ipoib_get_vf_guid,\n\t.ndo_set_vf_guid\t = ipoib_set_vf_guid,\n\t.ndo_set_mac_address\t = ipoib_set_mac,\n\t.ndo_get_stats64\t = ipoib_get_stats,\n\t.ndo_eth_ioctl\t\t = ipoib_ioctl,\n};\n\nstatic const struct net_device_ops ipoib_netdev_ops_vf = {\n\t.ndo_init\t\t = ipoib_ndo_init,\n\t.ndo_uninit\t\t = ipoib_ndo_uninit,\n\t.ndo_open\t\t = ipoib_open,\n\t.ndo_stop\t\t = ipoib_stop,\n\t.ndo_change_mtu\t\t = ipoib_change_mtu,\n\t.ndo_fix_features\t = ipoib_fix_features,\n\t.ndo_start_xmit\t \t = ipoib_start_xmit,\n\t.ndo_tx_timeout\t\t = ipoib_timeout,\n\t.ndo_set_rx_mode\t = ipoib_set_mcast_list,\n\t.ndo_get_iflink\t\t = ipoib_get_iflink,\n\t.ndo_get_stats64\t = ipoib_get_stats,\n\t.ndo_eth_ioctl\t\t = ipoib_ioctl,\n};\n\nstatic const struct net_device_ops ipoib_netdev_default_pf = {\n\t.ndo_init\t\t = ipoib_dev_init_default,\n\t.ndo_uninit\t\t = ipoib_dev_uninit_default,\n\t.ndo_open\t\t = ipoib_ib_dev_open_default,\n\t.ndo_stop\t\t = ipoib_ib_dev_stop_default,\n};\n\nvoid ipoib_setup_common(struct net_device *dev)\n{\n\tdev->header_ops\t\t = &ipoib_header_ops;\n\tdev->netdev_ops          = &ipoib_netdev_default_pf;\n\n\tipoib_set_ethtool_ops(dev);\n\n\tdev->watchdog_timeo\t = HZ;\n\n\tdev->flags\t\t|= IFF_BROADCAST | IFF_MULTICAST;\n\n\tdev->hard_header_len\t = IPOIB_HARD_LEN;\n\tdev->addr_len\t\t = INFINIBAND_ALEN;\n\tdev->type\t\t = ARPHRD_INFINIBAND;\n\tdev->tx_queue_len\t = ipoib_sendq_size * 2;\n\tdev->features\t\t = (NETIF_F_VLAN_CHALLENGED\t|\n\t\t\t\t    NETIF_F_HIGHDMA);\n\tnetif_keep_dst(dev);\n\n\tmemcpy(dev->broadcast, ipv4_bcast_addr, INFINIBAND_ALEN);\n\n\t \n\tdev->needs_free_netdev = true;\n}\n\nstatic void ipoib_build_priv(struct net_device *dev)\n{\n\tstruct ipoib_dev_priv *priv = ipoib_priv(dev);\n\n\tpriv->dev = dev;\n\tspin_lock_init(&priv->lock);\n\tinit_rwsem(&priv->vlan_rwsem);\n\tmutex_init(&priv->mcast_mutex);\n\n\tINIT_LIST_HEAD(&priv->path_list);\n\tINIT_LIST_HEAD(&priv->child_intfs);\n\tINIT_LIST_HEAD(&priv->dead_ahs);\n\tINIT_LIST_HEAD(&priv->multicast_list);\n\n\tINIT_DELAYED_WORK(&priv->mcast_task,   ipoib_mcast_join_task);\n\tINIT_WORK(&priv->carrier_on_task, ipoib_mcast_carrier_on_task);\n\tINIT_WORK(&priv->flush_light,   ipoib_ib_dev_flush_light);\n\tINIT_WORK(&priv->flush_normal,   ipoib_ib_dev_flush_normal);\n\tINIT_WORK(&priv->flush_heavy,   ipoib_ib_dev_flush_heavy);\n\tINIT_WORK(&priv->restart_task, ipoib_mcast_restart_task);\n\tINIT_DELAYED_WORK(&priv->ah_reap_task, ipoib_reap_ah);\n\tINIT_DELAYED_WORK(&priv->neigh_reap_task, ipoib_reap_neigh);\n}\n\nstatic struct net_device *ipoib_alloc_netdev(struct ib_device *hca, u32 port,\n\t\t\t\t\t     const char *name)\n{\n\tstruct net_device *dev;\n\n\tdev = rdma_alloc_netdev(hca, port, RDMA_NETDEV_IPOIB, name,\n\t\t\t\tNET_NAME_UNKNOWN, ipoib_setup_common);\n\tif (!IS_ERR(dev) || PTR_ERR(dev) != -EOPNOTSUPP)\n\t\treturn dev;\n\n\tdev = alloc_netdev(sizeof(struct rdma_netdev), name, NET_NAME_UNKNOWN,\n\t\t\t   ipoib_setup_common);\n\tif (!dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\treturn dev;\n}\n\nint ipoib_intf_init(struct ib_device *hca, u32 port, const char *name,\n\t\t    struct net_device *dev)\n{\n\tstruct rdma_netdev *rn = netdev_priv(dev);\n\tstruct ipoib_dev_priv *priv;\n\tint rc;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->ca = hca;\n\tpriv->port = port;\n\n\trc = rdma_init_netdev(hca, port, RDMA_NETDEV_IPOIB, name,\n\t\t\t      NET_NAME_UNKNOWN, ipoib_setup_common, dev);\n\tif (rc) {\n\t\tif (rc != -EOPNOTSUPP)\n\t\t\tgoto out;\n\n\t\trn->send = ipoib_send;\n\t\trn->attach_mcast = ipoib_mcast_attach;\n\t\trn->detach_mcast = ipoib_mcast_detach;\n\t\trn->hca = hca;\n\n\t\trc = netif_set_real_num_tx_queues(dev, 1);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\trc = netif_set_real_num_rx_queues(dev, 1);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\tpriv->rn_ops = dev->netdev_ops;\n\n\tif (hca->attrs.kernel_cap_flags & IBK_VIRTUAL_FUNCTION)\n\t\tdev->netdev_ops\t= &ipoib_netdev_ops_vf;\n\telse\n\t\tdev->netdev_ops\t= &ipoib_netdev_ops_pf;\n\n\trn->clnt_priv = priv;\n\t \n\tpriv->next_priv_destructor = dev->priv_destructor;\n\tdev->priv_destructor = NULL;\n\n\tipoib_build_priv(dev);\n\n\treturn 0;\n\nout:\n\tkfree(priv);\n\treturn rc;\n}\n\nstruct net_device *ipoib_intf_alloc(struct ib_device *hca, u32 port,\n\t\t\t\t    const char *name)\n{\n\tstruct net_device *dev;\n\tint rc;\n\n\tdev = ipoib_alloc_netdev(hca, port, name);\n\tif (IS_ERR(dev))\n\t\treturn dev;\n\n\trc = ipoib_intf_init(hca, port, name, dev);\n\tif (rc) {\n\t\tfree_netdev(dev);\n\t\treturn ERR_PTR(rc);\n\t}\n\n\t \n\treturn dev;\n}\n\nvoid ipoib_intf_free(struct net_device *dev)\n{\n\tstruct ipoib_dev_priv *priv = ipoib_priv(dev);\n\tstruct rdma_netdev *rn = netdev_priv(dev);\n\n\tdev->priv_destructor = priv->next_priv_destructor;\n\tif (dev->priv_destructor)\n\t\tdev->priv_destructor(dev);\n\n\t \n\tdev->priv_destructor = NULL;\n\n\t \n\trn->clnt_priv = NULL;\n\n\tkfree(priv);\n}\n\nstatic ssize_t pkey_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct net_device *ndev = to_net_dev(dev);\n\tstruct ipoib_dev_priv *priv = ipoib_priv(ndev);\n\n\treturn sysfs_emit(buf, \"0x%04x\\n\", priv->pkey);\n}\nstatic DEVICE_ATTR_RO(pkey);\n\nstatic ssize_t umcast_show(struct device *dev, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct net_device *ndev = to_net_dev(dev);\n\tstruct ipoib_dev_priv *priv = ipoib_priv(ndev);\n\n\treturn sysfs_emit(buf, \"%d\\n\",\n\t\t\t  test_bit(IPOIB_FLAG_UMCAST, &priv->flags));\n}\n\nvoid ipoib_set_umcast(struct net_device *ndev, int umcast_val)\n{\n\tstruct ipoib_dev_priv *priv = ipoib_priv(ndev);\n\n\tif (umcast_val > 0) {\n\t\tset_bit(IPOIB_FLAG_UMCAST, &priv->flags);\n\t\tipoib_warn(priv, \"ignoring multicast groups joined directly \"\n\t\t\t\t\"by userspace\\n\");\n\t} else\n\t\tclear_bit(IPOIB_FLAG_UMCAST, &priv->flags);\n}\n\nstatic ssize_t umcast_store(struct device *dev, struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tunsigned long umcast_val = simple_strtoul(buf, NULL, 0);\n\n\tipoib_set_umcast(to_net_dev(dev), umcast_val);\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(umcast);\n\nint ipoib_add_umcast_attr(struct net_device *dev)\n{\n\treturn device_create_file(&dev->dev, &dev_attr_umcast);\n}\n\nstatic void set_base_guid(struct ipoib_dev_priv *priv, union ib_gid *gid)\n{\n\tstruct ipoib_dev_priv *child_priv;\n\tstruct net_device *netdev = priv->dev;\n\n\tnetif_addr_lock_bh(netdev);\n\n\tmemcpy(&priv->local_gid.global.interface_id,\n\t       &gid->global.interface_id,\n\t       sizeof(gid->global.interface_id));\n\tdev_addr_mod(netdev, 4, (u8 *)&priv->local_gid, sizeof(priv->local_gid));\n\tclear_bit(IPOIB_FLAG_DEV_ADDR_SET, &priv->flags);\n\n\tnetif_addr_unlock_bh(netdev);\n\n\tif (!test_bit(IPOIB_FLAG_SUBINTERFACE, &priv->flags)) {\n\t\tdown_read(&priv->vlan_rwsem);\n\t\tlist_for_each_entry(child_priv, &priv->child_intfs, list)\n\t\t\tset_base_guid(child_priv, gid);\n\t\tup_read(&priv->vlan_rwsem);\n\t}\n}\n\nstatic int ipoib_check_lladdr(struct net_device *dev,\n\t\t\t      struct sockaddr_storage *ss)\n{\n\tunion ib_gid *gid = (union ib_gid *)(ss->__data + 4);\n\tint ret = 0;\n\n\tnetif_addr_lock_bh(dev);\n\n\t \n\tif (memcmp(dev->dev_addr, ss->__data,\n\t\t   4 + sizeof(gid->global.subnet_prefix)) ||\n\t    gid->global.interface_id == 0)\n\t\tret = -EINVAL;\n\n\tnetif_addr_unlock_bh(dev);\n\n\treturn ret;\n}\n\nstatic int ipoib_set_mac(struct net_device *dev, void *addr)\n{\n\tstruct ipoib_dev_priv *priv = ipoib_priv(dev);\n\tstruct sockaddr_storage *ss = addr;\n\tint ret;\n\n\tif (!(dev->priv_flags & IFF_LIVE_ADDR_CHANGE) && netif_running(dev))\n\t\treturn -EBUSY;\n\n\tret = ipoib_check_lladdr(dev, ss);\n\tif (ret)\n\t\treturn ret;\n\n\tset_base_guid(priv, (union ib_gid *)(ss->__data + 4));\n\n\tqueue_work(ipoib_workqueue, &priv->flush_light);\n\n\treturn 0;\n}\n\nstatic ssize_t create_child_store(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tint pkey;\n\tint ret;\n\n\tif (sscanf(buf, \"%i\", &pkey) != 1)\n\t\treturn -EINVAL;\n\n\tif (pkey <= 0 || pkey > 0xffff || pkey == 0x8000)\n\t\treturn -EINVAL;\n\n\tret = ipoib_vlan_add(to_net_dev(dev), pkey);\n\n\treturn ret ? ret : count;\n}\nstatic DEVICE_ATTR_WO(create_child);\n\nstatic ssize_t delete_child_store(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tint pkey;\n\tint ret;\n\n\tif (sscanf(buf, \"%i\", &pkey) != 1)\n\t\treturn -EINVAL;\n\n\tif (pkey < 0 || pkey > 0xffff)\n\t\treturn -EINVAL;\n\n\tret = ipoib_vlan_delete(to_net_dev(dev), pkey);\n\n\treturn ret ? ret : count;\n\n}\nstatic DEVICE_ATTR_WO(delete_child);\n\nint ipoib_add_pkey_attr(struct net_device *dev)\n{\n\treturn device_create_file(&dev->dev, &dev_attr_pkey);\n}\n\n \nstatic ssize_t dev_id_show(struct device *dev,\n\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct net_device *ndev = to_net_dev(dev);\n\n\t \n\tif (ndev->dev_port && ndev->dev_id == ndev->dev_port)\n\t\tnetdev_info_once(ndev,\n\t\t\t\"\\\"%s\\\" wants to know my dev_id. Should it look at dev_port instead? See Documentation/ABI/testing/sysfs-class-net for more info.\\n\",\n\t\t\tcurrent->comm);\n\n\treturn sysfs_emit(buf, \"%#x\\n\", ndev->dev_id);\n}\nstatic DEVICE_ATTR_RO(dev_id);\n\nstatic int ipoib_intercept_dev_id_attr(struct net_device *dev)\n{\n\tdevice_remove_file(&dev->dev, &dev_attr_dev_id);\n\treturn device_create_file(&dev->dev, &dev_attr_dev_id);\n}\n\nstatic struct net_device *ipoib_add_port(const char *format,\n\t\t\t\t\t struct ib_device *hca, u32 port)\n{\n\tstruct rtnl_link_ops *ops = ipoib_get_link_ops();\n\tstruct rdma_netdev_alloc_params params;\n\tstruct ipoib_dev_priv *priv;\n\tstruct net_device *ndev;\n\tint result;\n\n\tndev = ipoib_intf_alloc(hca, port, format);\n\tif (IS_ERR(ndev)) {\n\t\tpr_warn(\"%s, %d: ipoib_intf_alloc failed %ld\\n\", hca->name, port,\n\t\t\tPTR_ERR(ndev));\n\t\treturn ndev;\n\t}\n\tpriv = ipoib_priv(ndev);\n\n\tINIT_IB_EVENT_HANDLER(&priv->event_handler,\n\t\t\t      priv->ca, ipoib_event);\n\tib_register_event_handler(&priv->event_handler);\n\n\t \n\tqueue_work(ipoib_workqueue, &priv->flush_heavy);\n\n\tndev->rtnl_link_ops = ipoib_get_link_ops();\n\n\tresult = register_netdev(ndev);\n\tif (result) {\n\t\tpr_warn(\"%s: couldn't register ipoib port %d; error %d\\n\",\n\t\t\thca->name, port, result);\n\n\t\tipoib_parent_unregister_pre(ndev);\n\t\tipoib_intf_free(ndev);\n\t\tfree_netdev(ndev);\n\n\t\treturn ERR_PTR(result);\n\t}\n\n\tif (hca->ops.rdma_netdev_get_params) {\n\t\tint rc = hca->ops.rdma_netdev_get_params(hca, port,\n\t\t\t\t\t\t     RDMA_NETDEV_IPOIB,\n\t\t\t\t\t\t     &params);\n\n\t\tif (!rc && ops->priv_size < params.sizeof_priv)\n\t\t\tops->priv_size = params.sizeof_priv;\n\t}\n\t \n\tndev->priv_destructor = ipoib_intf_free;\n\n\tif (ipoib_intercept_dev_id_attr(ndev))\n\t\tgoto sysfs_failed;\n\tif (ipoib_cm_add_mode_attr(ndev))\n\t\tgoto sysfs_failed;\n\tif (ipoib_add_pkey_attr(ndev))\n\t\tgoto sysfs_failed;\n\tif (ipoib_add_umcast_attr(ndev))\n\t\tgoto sysfs_failed;\n\tif (device_create_file(&ndev->dev, &dev_attr_create_child))\n\t\tgoto sysfs_failed;\n\tif (device_create_file(&ndev->dev, &dev_attr_delete_child))\n\t\tgoto sysfs_failed;\n\n\treturn ndev;\n\nsysfs_failed:\n\tipoib_parent_unregister_pre(ndev);\n\tunregister_netdev(ndev);\n\treturn ERR_PTR(-ENOMEM);\n}\n\nstatic int ipoib_add_one(struct ib_device *device)\n{\n\tstruct list_head *dev_list;\n\tstruct net_device *dev;\n\tstruct ipoib_dev_priv *priv;\n\tunsigned int p;\n\tint count = 0;\n\n\tdev_list = kmalloc(sizeof(*dev_list), GFP_KERNEL);\n\tif (!dev_list)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(dev_list);\n\n\trdma_for_each_port (device, p) {\n\t\tif (!rdma_protocol_ib(device, p))\n\t\t\tcontinue;\n\t\tdev = ipoib_add_port(\"ib%d\", device, p);\n\t\tif (!IS_ERR(dev)) {\n\t\t\tpriv = ipoib_priv(dev);\n\t\t\tlist_add_tail(&priv->list, dev_list);\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tif (!count) {\n\t\tkfree(dev_list);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tib_set_client_data(device, &ipoib_client, dev_list);\n\treturn 0;\n}\n\nstatic void ipoib_remove_one(struct ib_device *device, void *client_data)\n{\n\tstruct ipoib_dev_priv *priv, *tmp, *cpriv, *tcpriv;\n\tstruct list_head *dev_list = client_data;\n\n\tlist_for_each_entry_safe(priv, tmp, dev_list, list) {\n\t\tLIST_HEAD(head);\n\t\tipoib_parent_unregister_pre(priv->dev);\n\n\t\trtnl_lock();\n\n\t\tlist_for_each_entry_safe(cpriv, tcpriv, &priv->child_intfs,\n\t\t\t\t\t list)\n\t\t\tunregister_netdevice_queue(cpriv->dev, &head);\n\t\tunregister_netdevice_queue(priv->dev, &head);\n\t\tunregister_netdevice_many(&head);\n\n\t\trtnl_unlock();\n\t}\n\n\tkfree(dev_list);\n}\n\n#ifdef CONFIG_INFINIBAND_IPOIB_DEBUG\nstatic struct notifier_block ipoib_netdev_notifier = {\n\t.notifier_call = ipoib_netdev_event,\n};\n#endif\n\nstatic int __init ipoib_init_module(void)\n{\n\tint ret;\n\n\tipoib_recvq_size = roundup_pow_of_two(ipoib_recvq_size);\n\tipoib_recvq_size = min(ipoib_recvq_size, IPOIB_MAX_QUEUE_SIZE);\n\tipoib_recvq_size = max(ipoib_recvq_size, IPOIB_MIN_QUEUE_SIZE);\n\n\tipoib_sendq_size = roundup_pow_of_two(ipoib_sendq_size);\n\tipoib_sendq_size = min(ipoib_sendq_size, IPOIB_MAX_QUEUE_SIZE);\n\tipoib_sendq_size = max3(ipoib_sendq_size, 2 * MAX_SEND_CQE, IPOIB_MIN_QUEUE_SIZE);\n#ifdef CONFIG_INFINIBAND_IPOIB_CM\n\tipoib_max_conn_qp = min(ipoib_max_conn_qp, IPOIB_CM_MAX_CONN_QP);\n\tipoib_max_conn_qp = max(ipoib_max_conn_qp, 0);\n#endif\n\n\t \n\tBUILD_BUG_ON(IPOIB_CM_COPYBREAK > IPOIB_CM_HEAD_SIZE);\n\n\tipoib_register_debugfs();\n\n\t \n\tipoib_workqueue = alloc_ordered_workqueue(\"ipoib_flush\", 0);\n\tif (!ipoib_workqueue) {\n\t\tret = -ENOMEM;\n\t\tgoto err_fs;\n\t}\n\n\tib_sa_register_client(&ipoib_sa_client);\n\n\tret = ib_register_client(&ipoib_client);\n\tif (ret)\n\t\tgoto err_sa;\n\n\tret = ipoib_netlink_init();\n\tif (ret)\n\t\tgoto err_client;\n\n#ifdef CONFIG_INFINIBAND_IPOIB_DEBUG\n\tregister_netdevice_notifier(&ipoib_netdev_notifier);\n#endif\n\treturn 0;\n\nerr_client:\n\tib_unregister_client(&ipoib_client);\n\nerr_sa:\n\tib_sa_unregister_client(&ipoib_sa_client);\n\tdestroy_workqueue(ipoib_workqueue);\n\nerr_fs:\n\tipoib_unregister_debugfs();\n\n\treturn ret;\n}\n\nstatic void __exit ipoib_cleanup_module(void)\n{\n#ifdef CONFIG_INFINIBAND_IPOIB_DEBUG\n\tunregister_netdevice_notifier(&ipoib_netdev_notifier);\n#endif\n\tipoib_netlink_fini();\n\tib_unregister_client(&ipoib_client);\n\tib_sa_unregister_client(&ipoib_sa_client);\n\tipoib_unregister_debugfs();\n\tdestroy_workqueue(ipoib_workqueue);\n}\n\nmodule_init(ipoib_init_module);\nmodule_exit(ipoib_cleanup_module);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}