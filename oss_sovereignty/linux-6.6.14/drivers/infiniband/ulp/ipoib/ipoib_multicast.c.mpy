{
  "module_name": "ipoib_multicast.c",
  "hash_id": "4f88b3cb11cbccba70fb09645a2d4b2bf0bb8a9fafecdd5b7dac556736415ad6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/ulp/ipoib/ipoib_multicast.c",
  "human_readable_source": " \n\n#include <linux/skbuff.h>\n#include <linux/rtnetlink.h>\n#include <linux/moduleparam.h>\n#include <linux/ip.h>\n#include <linux/in.h>\n#include <linux/igmp.h>\n#include <linux/inetdevice.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n\n#include <net/dst.h>\n\n#include \"ipoib.h\"\n\n#ifdef CONFIG_INFINIBAND_IPOIB_DEBUG\nstatic int mcast_debug_level;\n\nmodule_param(mcast_debug_level, int, 0644);\nMODULE_PARM_DESC(mcast_debug_level,\n\t\t \"Enable multicast debug tracing if > 0\");\n#endif\n\nstruct ipoib_mcast_iter {\n\tstruct net_device *dev;\n\tunion ib_gid       mgid;\n\tunsigned long      created;\n\tunsigned int       queuelen;\n\tunsigned int       complete;\n\tunsigned int       send_only;\n};\n\n \n#define SENDONLY_FULLMEMBER_JOIN\t8\n\n \nstatic void __ipoib_mcast_schedule_join_thread(struct ipoib_dev_priv *priv,\n\t\t\t\t\t       struct ipoib_mcast *mcast,\n\t\t\t\t\t       bool delay)\n{\n\tif (!test_bit(IPOIB_FLAG_OPER_UP, &priv->flags))\n\t\treturn;\n\n\t \n\tcancel_delayed_work(&priv->mcast_task);\n\tif (mcast && delay) {\n\t\t \n\t\tmcast->backoff *= 2;\n\t\tif (mcast->backoff > IPOIB_MAX_BACKOFF_SECONDS)\n\t\t\tmcast->backoff = IPOIB_MAX_BACKOFF_SECONDS;\n\t\tmcast->delay_until = jiffies + (mcast->backoff * HZ);\n\t\t \n\t\tqueue_delayed_work(priv->wq, &priv->mcast_task, 0);\n\t} else if (delay) {\n\t\t \n\t\tqueue_delayed_work(priv->wq, &priv->mcast_task, HZ);\n\t} else\n\t\tqueue_delayed_work(priv->wq, &priv->mcast_task, 0);\n}\n\nstatic void ipoib_mcast_free(struct ipoib_mcast *mcast)\n{\n\tstruct net_device *dev = mcast->dev;\n\tint tx_dropped = 0;\n\n\tipoib_dbg_mcast(ipoib_priv(dev), \"deleting multicast group %pI6\\n\",\n\t\t\tmcast->mcmember.mgid.raw);\n\n\t \n\tipoib_del_neighs_by_gid(dev, mcast->mcmember.mgid.raw);\n\n\tif (mcast->ah)\n\t\tipoib_put_ah(mcast->ah);\n\n\twhile (!skb_queue_empty(&mcast->pkt_queue)) {\n\t\t++tx_dropped;\n\t\tdev_kfree_skb_any(skb_dequeue(&mcast->pkt_queue));\n\t}\n\n\tnetif_tx_lock_bh(dev);\n\tdev->stats.tx_dropped += tx_dropped;\n\tnetif_tx_unlock_bh(dev);\n\n\tkfree(mcast);\n}\n\nstatic struct ipoib_mcast *ipoib_mcast_alloc(struct net_device *dev)\n{\n\tstruct ipoib_mcast *mcast;\n\n\tmcast = kzalloc(sizeof(*mcast), GFP_ATOMIC);\n\tif (!mcast)\n\t\treturn NULL;\n\n\tmcast->dev = dev;\n\tmcast->created = jiffies;\n\tmcast->delay_until = jiffies;\n\tmcast->backoff = 1;\n\n\tINIT_LIST_HEAD(&mcast->list);\n\tINIT_LIST_HEAD(&mcast->neigh_list);\n\tskb_queue_head_init(&mcast->pkt_queue);\n\n\treturn mcast;\n}\n\nstatic struct ipoib_mcast *__ipoib_mcast_find(struct net_device *dev, void *mgid)\n{\n\tstruct ipoib_dev_priv *priv = ipoib_priv(dev);\n\tstruct rb_node *n = priv->multicast_tree.rb_node;\n\n\twhile (n) {\n\t\tstruct ipoib_mcast *mcast;\n\t\tint ret;\n\n\t\tmcast = rb_entry(n, struct ipoib_mcast, rb_node);\n\n\t\tret = memcmp(mgid, mcast->mcmember.mgid.raw,\n\t\t\t     sizeof (union ib_gid));\n\t\tif (ret < 0)\n\t\t\tn = n->rb_left;\n\t\telse if (ret > 0)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn mcast;\n\t}\n\n\treturn NULL;\n}\n\nstatic int __ipoib_mcast_add(struct net_device *dev, struct ipoib_mcast *mcast)\n{\n\tstruct ipoib_dev_priv *priv = ipoib_priv(dev);\n\tstruct rb_node **n = &priv->multicast_tree.rb_node, *pn = NULL;\n\n\twhile (*n) {\n\t\tstruct ipoib_mcast *tmcast;\n\t\tint ret;\n\n\t\tpn = *n;\n\t\ttmcast = rb_entry(pn, struct ipoib_mcast, rb_node);\n\n\t\tret = memcmp(mcast->mcmember.mgid.raw, tmcast->mcmember.mgid.raw,\n\t\t\t     sizeof (union ib_gid));\n\t\tif (ret < 0)\n\t\t\tn = &pn->rb_left;\n\t\telse if (ret > 0)\n\t\t\tn = &pn->rb_right;\n\t\telse\n\t\t\treturn -EEXIST;\n\t}\n\n\trb_link_node(&mcast->rb_node, pn, n);\n\trb_insert_color(&mcast->rb_node, &priv->multicast_tree);\n\n\treturn 0;\n}\n\nstatic int ipoib_mcast_join_finish(struct ipoib_mcast *mcast,\n\t\t\t\t   struct ib_sa_mcmember_rec *mcmember)\n{\n\tstruct net_device *dev = mcast->dev;\n\tstruct ipoib_dev_priv *priv = ipoib_priv(dev);\n\tstruct rdma_netdev *rn = netdev_priv(dev);\n\tstruct ipoib_ah *ah;\n\tstruct rdma_ah_attr av;\n\tint ret;\n\tint set_qkey = 0;\n\tint mtu;\n\n\tmcast->mcmember = *mcmember;\n\n\t \n\tif (!memcmp(mcast->mcmember.mgid.raw, priv->dev->broadcast + 4,\n\t\t    sizeof (union ib_gid))) {\n\t\tspin_lock_irq(&priv->lock);\n\t\tif (!priv->broadcast) {\n\t\t\tspin_unlock_irq(&priv->lock);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\t \n\t\tpriv->broadcast->mcmember.qkey = mcmember->qkey;\n\t\tpriv->broadcast->mcmember.mtu = mcmember->mtu;\n\t\tpriv->broadcast->mcmember.traffic_class = mcmember->traffic_class;\n\t\tpriv->broadcast->mcmember.rate = mcmember->rate;\n\t\tpriv->broadcast->mcmember.sl = mcmember->sl;\n\t\tpriv->broadcast->mcmember.flow_label = mcmember->flow_label;\n\t\tpriv->broadcast->mcmember.hop_limit = mcmember->hop_limit;\n\t\t \n\t\tmtu = rdma_mtu_enum_to_int(priv->ca,  priv->port,\n\t\t\t\t\t   priv->broadcast->mcmember.mtu);\n\t\tif (priv->mcast_mtu == priv->admin_mtu)\n\t\t\tpriv->admin_mtu = IPOIB_UD_MTU(mtu);\n\t\tpriv->mcast_mtu = IPOIB_UD_MTU(mtu);\n\t\trn->mtu = priv->mcast_mtu;\n\n\t\tpriv->qkey = be32_to_cpu(priv->broadcast->mcmember.qkey);\n\t\tspin_unlock_irq(&priv->lock);\n\t\tpriv->tx_wr.remote_qkey = priv->qkey;\n\t\tset_qkey = 1;\n\t}\n\n\tif (!test_bit(IPOIB_MCAST_FLAG_SENDONLY, &mcast->flags)) {\n\t\tif (test_and_set_bit(IPOIB_MCAST_FLAG_ATTACHED, &mcast->flags)) {\n\t\t\tipoib_warn(priv, \"multicast group %pI6 already attached\\n\",\n\t\t\t\t   mcast->mcmember.mgid.raw);\n\n\t\t\treturn 0;\n\t\t}\n\n\t\tret = rn->attach_mcast(dev, priv->ca, &mcast->mcmember.mgid,\n\t\t\t\t       be16_to_cpu(mcast->mcmember.mlid),\n\t\t\t\t       set_qkey, priv->qkey);\n\t\tif (ret < 0) {\n\t\t\tipoib_warn(priv, \"couldn't attach QP to multicast group %pI6\\n\",\n\t\t\t\t   mcast->mcmember.mgid.raw);\n\n\t\t\tclear_bit(IPOIB_MCAST_FLAG_ATTACHED, &mcast->flags);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tmemset(&av, 0, sizeof(av));\n\tav.type = rdma_ah_find_type(priv->ca, priv->port);\n\trdma_ah_set_dlid(&av, be16_to_cpu(mcast->mcmember.mlid));\n\trdma_ah_set_port_num(&av, priv->port);\n\trdma_ah_set_sl(&av, mcast->mcmember.sl);\n\trdma_ah_set_static_rate(&av, mcast->mcmember.rate);\n\n\trdma_ah_set_grh(&av, &mcast->mcmember.mgid,\n\t\t\tbe32_to_cpu(mcast->mcmember.flow_label),\n\t\t\t0, mcast->mcmember.hop_limit,\n\t\t\tmcast->mcmember.traffic_class);\n\n\tah = ipoib_create_ah(dev, priv->pd, &av);\n\tif (IS_ERR(ah)) {\n\t\tipoib_warn(priv, \"ib_address_create failed %ld\\n\",\n\t\t\t   -PTR_ERR(ah));\n\t\t \n\t\treturn PTR_ERR(ah);\n\t}\n\tspin_lock_irq(&priv->lock);\n\tmcast->ah = ah;\n\tspin_unlock_irq(&priv->lock);\n\n\tipoib_dbg_mcast(priv, \"MGID %pI6 AV %p, LID 0x%04x, SL %d\\n\",\n\t\t\tmcast->mcmember.mgid.raw,\n\t\t\tmcast->ah->ah,\n\t\t\tbe16_to_cpu(mcast->mcmember.mlid),\n\t\t\tmcast->mcmember.sl);\n\n\t \n\tnetif_tx_lock_bh(dev);\n\twhile (!skb_queue_empty(&mcast->pkt_queue)) {\n\t\tstruct sk_buff *skb = skb_dequeue(&mcast->pkt_queue);\n\n\t\tnetif_tx_unlock_bh(dev);\n\n\t\tskb->dev = dev;\n\n\t\tret = dev_queue_xmit(skb);\n\t\tif (ret)\n\t\t\tipoib_warn(priv, \"%s:dev_queue_xmit failed to re-queue packet, ret:%d\\n\",\n\t\t\t\t   __func__, ret);\n\t\tnetif_tx_lock_bh(dev);\n\t}\n\tnetif_tx_unlock_bh(dev);\n\n\treturn 0;\n}\n\nvoid ipoib_mcast_carrier_on_task(struct work_struct *work)\n{\n\tstruct ipoib_dev_priv *priv = container_of(work, struct ipoib_dev_priv,\n\t\t\t\t\t\t   carrier_on_task);\n\tstruct ib_port_attr attr;\n\n\tif (ib_query_port(priv->ca, priv->port, &attr) ||\n\t    attr.state != IB_PORT_ACTIVE) {\n\t\tipoib_dbg(priv, \"Keeping carrier off until IB port is active\\n\");\n\t\treturn;\n\t}\n\t \n\twhile (!rtnl_trylock()) {\n\t\tif (!test_bit(IPOIB_FLAG_OPER_UP, &priv->flags))\n\t\t\treturn;\n\t\telse\n\t\t\tmsleep(20);\n\t}\n\tif (!ipoib_cm_admin_enabled(priv->dev))\n\t\tdev_set_mtu(priv->dev, min(priv->mcast_mtu, priv->admin_mtu));\n\tnetif_carrier_on(priv->dev);\n\trtnl_unlock();\n}\n\nstatic int ipoib_mcast_join_complete(int status,\n\t\t\t\t     struct ib_sa_multicast *multicast)\n{\n\tstruct ipoib_mcast *mcast = multicast->context;\n\tstruct net_device *dev = mcast->dev;\n\tstruct ipoib_dev_priv *priv = ipoib_priv(dev);\n\n\tipoib_dbg_mcast(priv, \"%sjoin completion for %pI6 (status %d)\\n\",\n\t\t\ttest_bit(IPOIB_MCAST_FLAG_SENDONLY, &mcast->flags) ?\n\t\t\t\"sendonly \" : \"\",\n\t\t\tmcast->mcmember.mgid.raw, status);\n\n\t \n\tif (status == -ENETRESET) {\n\t\tstatus = 0;\n\t\tgoto out;\n\t}\n\n\tif (!status)\n\t\tstatus = ipoib_mcast_join_finish(mcast, &multicast->rec);\n\n\tif (!status) {\n\t\tmcast->backoff = 1;\n\t\tmcast->delay_until = jiffies;\n\n\t\t \n\t\tif (mcast == priv->broadcast) {\n\t\t\tspin_lock_irq(&priv->lock);\n\t\t\tqueue_work(priv->wq, &priv->carrier_on_task);\n\t\t\t__ipoib_mcast_schedule_join_thread(priv, NULL, 0);\n\t\t\tgoto out_locked;\n\t\t}\n\t} else {\n\t\tbool silent_fail =\n\t\t    test_bit(IPOIB_MCAST_FLAG_SENDONLY, &mcast->flags) &&\n\t\t    status == -EINVAL;\n\n\t\tif (mcast->logcount < 20) {\n\t\t\tif (status == -ETIMEDOUT || status == -EAGAIN ||\n\t\t\t    silent_fail) {\n\t\t\t\tipoib_dbg_mcast(priv, \"%smulticast join failed for %pI6, status %d\\n\",\n\t\t\t\t\t\ttest_bit(IPOIB_MCAST_FLAG_SENDONLY, &mcast->flags) ? \"sendonly \" : \"\",\n\t\t\t\t\t\tmcast->mcmember.mgid.raw, status);\n\t\t\t} else {\n\t\t\t\tipoib_warn(priv, \"%smulticast join failed for %pI6, status %d\\n\",\n\t\t\t\t\t\ttest_bit(IPOIB_MCAST_FLAG_SENDONLY, &mcast->flags) ? \"sendonly \" : \"\",\n\t\t\t\t\t   mcast->mcmember.mgid.raw, status);\n\t\t\t}\n\n\t\t\tif (!silent_fail)\n\t\t\t\tmcast->logcount++;\n\t\t}\n\n\t\tif (test_bit(IPOIB_MCAST_FLAG_SENDONLY, &mcast->flags) &&\n\t\t    mcast->backoff >= 2) {\n\t\t\t \n\t\t\tmcast->backoff = 1;\n\t\t\tnetif_tx_lock_bh(dev);\n\t\t\twhile (!skb_queue_empty(&mcast->pkt_queue)) {\n\t\t\t\t++dev->stats.tx_dropped;\n\t\t\t\tdev_kfree_skb_any(skb_dequeue(&mcast->pkt_queue));\n\t\t\t}\n\t\t\tnetif_tx_unlock_bh(dev);\n\t\t} else {\n\t\t\tspin_lock_irq(&priv->lock);\n\t\t\t \n\t\t\t__ipoib_mcast_schedule_join_thread(priv, mcast, 1);\n\t\t\tgoto out_locked;\n\t\t}\n\t}\nout:\n\tspin_lock_irq(&priv->lock);\nout_locked:\n\t \n\tif (status)\n\t\tmcast->mc = NULL;\n\telse\n\t\tmcast->mc = multicast;\n\tclear_bit(IPOIB_MCAST_FLAG_BUSY, &mcast->flags);\n\tspin_unlock_irq(&priv->lock);\n\tcomplete(&mcast->done);\n\n\treturn status;\n}\n\n \nstatic int ipoib_mcast_join(struct net_device *dev, struct ipoib_mcast *mcast)\n{\n\tstruct ipoib_dev_priv *priv = ipoib_priv(dev);\n\tstruct ib_sa_multicast *multicast;\n\tstruct ib_sa_mcmember_rec rec = {\n\t\t.join_state = 1\n\t};\n\tib_sa_comp_mask comp_mask;\n\tint ret = 0;\n\n\tif (!priv->broadcast ||\n\t    !test_bit(IPOIB_FLAG_OPER_UP, &priv->flags))\n\t\treturn -EINVAL;\n\n\tinit_completion(&mcast->done);\n\tset_bit(IPOIB_MCAST_FLAG_BUSY, &mcast->flags);\n\n\tipoib_dbg_mcast(priv, \"joining MGID %pI6\\n\", mcast->mcmember.mgid.raw);\n\n\trec.mgid     = mcast->mcmember.mgid;\n\trec.port_gid = priv->local_gid;\n\trec.pkey     = cpu_to_be16(priv->pkey);\n\n\tcomp_mask =\n\t\tIB_SA_MCMEMBER_REC_MGID\t\t|\n\t\tIB_SA_MCMEMBER_REC_PORT_GID\t|\n\t\tIB_SA_MCMEMBER_REC_PKEY\t\t|\n\t\tIB_SA_MCMEMBER_REC_JOIN_STATE;\n\n\tif (mcast != priv->broadcast) {\n\t\t \n\t\tcomp_mask |=\n\t\t\tIB_SA_MCMEMBER_REC_QKEY\t\t\t|\n\t\t\tIB_SA_MCMEMBER_REC_MTU_SELECTOR\t\t|\n\t\t\tIB_SA_MCMEMBER_REC_MTU\t\t\t|\n\t\t\tIB_SA_MCMEMBER_REC_TRAFFIC_CLASS\t|\n\t\t\tIB_SA_MCMEMBER_REC_RATE_SELECTOR\t|\n\t\t\tIB_SA_MCMEMBER_REC_RATE\t\t\t|\n\t\t\tIB_SA_MCMEMBER_REC_SL\t\t\t|\n\t\t\tIB_SA_MCMEMBER_REC_FLOW_LABEL\t\t|\n\t\t\tIB_SA_MCMEMBER_REC_HOP_LIMIT;\n\n\t\trec.qkey\t  = priv->broadcast->mcmember.qkey;\n\t\trec.mtu_selector  = IB_SA_EQ;\n\t\trec.mtu\t\t  = priv->broadcast->mcmember.mtu;\n\t\trec.traffic_class = priv->broadcast->mcmember.traffic_class;\n\t\trec.rate_selector = IB_SA_EQ;\n\t\trec.rate\t  = priv->broadcast->mcmember.rate;\n\t\trec.sl\t\t  = priv->broadcast->mcmember.sl;\n\t\trec.flow_label\t  = priv->broadcast->mcmember.flow_label;\n\t\trec.hop_limit\t  = priv->broadcast->mcmember.hop_limit;\n\n\t\t \n\t\tif (test_bit(IPOIB_MCAST_FLAG_SENDONLY, &mcast->flags))\n\t\t\trec.join_state = SENDONLY_FULLMEMBER_JOIN;\n\t}\n\tspin_unlock_irq(&priv->lock);\n\n\tmulticast = ib_sa_join_multicast(&ipoib_sa_client, priv->ca, priv->port,\n\t\t\t\t\t &rec, comp_mask, GFP_KERNEL,\n\t\t\t\t\t ipoib_mcast_join_complete, mcast);\n\tspin_lock_irq(&priv->lock);\n\tif (IS_ERR(multicast)) {\n\t\tret = PTR_ERR(multicast);\n\t\tipoib_warn(priv, \"ib_sa_join_multicast failed, status %d\\n\", ret);\n\t\t \n\t\t__ipoib_mcast_schedule_join_thread(priv, mcast, 1);\n\t\tclear_bit(IPOIB_MCAST_FLAG_BUSY, &mcast->flags);\n\t\tspin_unlock_irq(&priv->lock);\n\t\tcomplete(&mcast->done);\n\t\tspin_lock_irq(&priv->lock);\n\t}\n\treturn 0;\n}\n\nvoid ipoib_mcast_join_task(struct work_struct *work)\n{\n\tstruct ipoib_dev_priv *priv =\n\t\tcontainer_of(work, struct ipoib_dev_priv, mcast_task.work);\n\tstruct net_device *dev = priv->dev;\n\tstruct ib_port_attr port_attr;\n\tunsigned long delay_until = 0;\n\tstruct ipoib_mcast *mcast = NULL;\n\n\tif (!test_bit(IPOIB_FLAG_OPER_UP, &priv->flags))\n\t\treturn;\n\n\tif (ib_query_port(priv->ca, priv->port, &port_attr)) {\n\t\tipoib_dbg(priv, \"ib_query_port() failed\\n\");\n\t\treturn;\n\t}\n\tif (port_attr.state != IB_PORT_ACTIVE) {\n\t\tipoib_dbg(priv, \"port state is not ACTIVE (state = %d) suspending join task\\n\",\n\t\t\t  port_attr.state);\n\t\treturn;\n\t}\n\tpriv->local_lid = port_attr.lid;\n\tnetif_addr_lock_bh(dev);\n\n\tif (!test_bit(IPOIB_FLAG_DEV_ADDR_SET, &priv->flags)) {\n\t\tnetif_addr_unlock_bh(dev);\n\t\treturn;\n\t}\n\tnetif_addr_unlock_bh(dev);\n\n\tspin_lock_irq(&priv->lock);\n\tif (!test_bit(IPOIB_FLAG_OPER_UP, &priv->flags))\n\t\tgoto out;\n\n\tif (!priv->broadcast) {\n\t\tstruct ipoib_mcast *broadcast;\n\n\t\tbroadcast = ipoib_mcast_alloc(dev);\n\t\tif (!broadcast) {\n\t\t\tipoib_warn(priv, \"failed to allocate broadcast group\\n\");\n\t\t\t \n\t\t\t__ipoib_mcast_schedule_join_thread(priv, NULL, 1);\n\t\t\tgoto out;\n\t\t}\n\n\t\tmemcpy(broadcast->mcmember.mgid.raw, priv->dev->broadcast + 4,\n\t\t       sizeof (union ib_gid));\n\t\tpriv->broadcast = broadcast;\n\n\t\t__ipoib_mcast_add(dev, priv->broadcast);\n\t}\n\n\tif (!test_bit(IPOIB_MCAST_FLAG_ATTACHED, &priv->broadcast->flags)) {\n\t\tif (IS_ERR_OR_NULL(priv->broadcast->mc) &&\n\t\t    !test_bit(IPOIB_MCAST_FLAG_BUSY, &priv->broadcast->flags)) {\n\t\t\tmcast = priv->broadcast;\n\t\t\tif (mcast->backoff > 1 &&\n\t\t\t    time_before(jiffies, mcast->delay_until)) {\n\t\t\t\tdelay_until = mcast->delay_until;\n\t\t\t\tmcast = NULL;\n\t\t\t}\n\t\t}\n\t\tgoto out;\n\t}\n\n\t \n\tlist_for_each_entry(mcast, &priv->multicast_list, list) {\n\t\tif (IS_ERR_OR_NULL(mcast->mc) &&\n\t\t    !test_bit(IPOIB_MCAST_FLAG_BUSY, &mcast->flags) &&\n\t\t    (!test_bit(IPOIB_MCAST_FLAG_SENDONLY, &mcast->flags) ||\n\t\t     !skb_queue_empty(&mcast->pkt_queue))) {\n\t\t\tif (mcast->backoff == 1 ||\n\t\t\t    time_after_eq(jiffies, mcast->delay_until)) {\n\t\t\t\t \n\t\t\t\tif (ipoib_mcast_join(dev, mcast)) {\n\t\t\t\t\tspin_unlock_irq(&priv->lock);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else if (!delay_until ||\n\t\t\t\t time_before(mcast->delay_until, delay_until))\n\t\t\t\tdelay_until = mcast->delay_until;\n\t\t}\n\t}\n\n\tmcast = NULL;\n\tipoib_dbg_mcast(priv, \"successfully started all multicast joins\\n\");\n\nout:\n\tif (delay_until) {\n\t\tcancel_delayed_work(&priv->mcast_task);\n\t\tqueue_delayed_work(priv->wq, &priv->mcast_task,\n\t\t\t\t   delay_until - jiffies);\n\t}\n\tif (mcast)\n\t\tipoib_mcast_join(dev, mcast);\n\n\tspin_unlock_irq(&priv->lock);\n}\n\nvoid ipoib_mcast_start_thread(struct net_device *dev)\n{\n\tstruct ipoib_dev_priv *priv = ipoib_priv(dev);\n\tunsigned long flags;\n\n\tipoib_dbg_mcast(priv, \"starting multicast thread\\n\");\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\t__ipoib_mcast_schedule_join_thread(priv, NULL, 0);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n}\n\nvoid ipoib_mcast_stop_thread(struct net_device *dev)\n{\n\tstruct ipoib_dev_priv *priv = ipoib_priv(dev);\n\n\tipoib_dbg_mcast(priv, \"stopping multicast thread\\n\");\n\n\tcancel_delayed_work_sync(&priv->mcast_task);\n}\n\nstatic int ipoib_mcast_leave(struct net_device *dev, struct ipoib_mcast *mcast)\n{\n\tstruct ipoib_dev_priv *priv = ipoib_priv(dev);\n\tstruct rdma_netdev *rn = netdev_priv(dev);\n\tint ret = 0;\n\n\tif (test_and_clear_bit(IPOIB_MCAST_FLAG_BUSY, &mcast->flags))\n\t\tipoib_warn(priv, \"ipoib_mcast_leave on an in-flight join\\n\");\n\n\tif (!IS_ERR_OR_NULL(mcast->mc))\n\t\tib_sa_free_multicast(mcast->mc);\n\n\tif (test_and_clear_bit(IPOIB_MCAST_FLAG_ATTACHED, &mcast->flags)) {\n\t\tipoib_dbg_mcast(priv, \"leaving MGID %pI6\\n\",\n\t\t\t\tmcast->mcmember.mgid.raw);\n\n\t\t \n\t\tret = rn->detach_mcast(dev, priv->ca, &mcast->mcmember.mgid,\n\t\t\t\t       be16_to_cpu(mcast->mcmember.mlid));\n\t\tif (ret)\n\t\t\tipoib_warn(priv, \"ib_detach_mcast failed (result = %d)\\n\", ret);\n\t} else if (!test_bit(IPOIB_MCAST_FLAG_SENDONLY, &mcast->flags))\n\t\tipoib_dbg(priv, \"leaving with no mcmember but not a \"\n\t\t\t  \"SENDONLY join\\n\");\n\n\treturn 0;\n}\n\n \nvoid ipoib_check_and_add_mcast_sendonly(struct ipoib_dev_priv *priv, u8 *mgid,\n\t\t\t\tstruct list_head *remove_list)\n{\n\t \n\tif (*mgid == 0xff) {\n\t\tstruct ipoib_mcast *mcast = __ipoib_mcast_find(priv->dev, mgid);\n\n\t\tif (mcast && test_bit(IPOIB_MCAST_FLAG_SENDONLY, &mcast->flags)) {\n\t\t\tlist_del(&mcast->list);\n\t\t\trb_erase(&mcast->rb_node, &priv->multicast_tree);\n\t\t\tlist_add_tail(&mcast->list, remove_list);\n\t\t}\n\t}\n}\n\nvoid ipoib_mcast_remove_list(struct list_head *remove_list)\n{\n\tstruct ipoib_mcast *mcast, *tmcast;\n\n\t \n\tlist_for_each_entry_safe(mcast, tmcast, remove_list, list)\n\t\tif (test_bit(IPOIB_MCAST_FLAG_BUSY, &mcast->flags))\n\t\t\twait_for_completion(&mcast->done);\n\n\tlist_for_each_entry_safe(mcast, tmcast, remove_list, list) {\n\t\tipoib_mcast_leave(mcast->dev, mcast);\n\t\tipoib_mcast_free(mcast);\n\t}\n}\n\nvoid ipoib_mcast_send(struct net_device *dev, u8 *daddr, struct sk_buff *skb)\n{\n\tstruct ipoib_dev_priv *priv = ipoib_priv(dev);\n\tstruct rdma_netdev *rn = netdev_priv(dev);\n\tstruct ipoib_mcast *mcast;\n\tunsigned long flags;\n\tvoid *mgid = daddr + 4;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tif (!test_bit(IPOIB_FLAG_OPER_UP, &priv->flags)\t\t||\n\t    !priv->broadcast\t\t\t\t\t||\n\t    !test_bit(IPOIB_MCAST_FLAG_ATTACHED, &priv->broadcast->flags)) {\n\t\t++dev->stats.tx_dropped;\n\t\tdev_kfree_skb_any(skb);\n\t\tgoto unlock;\n\t}\n\n\tmcast = __ipoib_mcast_find(dev, mgid);\n\tif (!mcast || !mcast->ah) {\n\t\tif (!mcast) {\n\t\t\t \n\t\t\tipoib_dbg_mcast(priv, \"setting up send only multicast group for %pI6\\n\",\n\t\t\t\t\tmgid);\n\n\t\t\tmcast = ipoib_mcast_alloc(dev);\n\t\t\tif (!mcast) {\n\t\t\t\tipoib_warn(priv, \"unable to allocate memory \"\n\t\t\t\t\t   \"for multicast structure\\n\");\n\t\t\t\t++dev->stats.tx_dropped;\n\t\t\t\tdev_kfree_skb_any(skb);\n\t\t\t\tgoto unlock;\n\t\t\t}\n\n\t\t\tset_bit(IPOIB_MCAST_FLAG_SENDONLY, &mcast->flags);\n\t\t\tmemcpy(mcast->mcmember.mgid.raw, mgid,\n\t\t\t       sizeof (union ib_gid));\n\t\t\t__ipoib_mcast_add(dev, mcast);\n\t\t\tlist_add_tail(&mcast->list, &priv->multicast_list);\n\t\t}\n\t\tif (skb_queue_len(&mcast->pkt_queue) < IPOIB_MAX_MCAST_QUEUE) {\n\t\t\t \n\t\t\tskb_push(skb, sizeof(struct ipoib_pseudo_header));\n\t\t\tskb_queue_tail(&mcast->pkt_queue, skb);\n\t\t} else {\n\t\t\t++dev->stats.tx_dropped;\n\t\t\tdev_kfree_skb_any(skb);\n\t\t}\n\t\tif (!test_bit(IPOIB_MCAST_FLAG_BUSY, &mcast->flags)) {\n\t\t\t__ipoib_mcast_schedule_join_thread(priv, NULL, 0);\n\t\t}\n\t} else {\n\t\tstruct ipoib_neigh *neigh;\n\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\tneigh = ipoib_neigh_get(dev, daddr);\n\t\tspin_lock_irqsave(&priv->lock, flags);\n\t\tif (!neigh) {\n\t\t\tneigh = ipoib_neigh_alloc(daddr, dev);\n\t\t\t \n\t\t\tif (neigh && list_empty(&neigh->list)) {\n\t\t\t\tkref_get(&mcast->ah->ref);\n\t\t\t\tneigh->ah\t= mcast->ah;\n\t\t\t\tneigh->ah->valid = 1;\n\t\t\t\tlist_add_tail(&neigh->list, &mcast->neigh_list);\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\tmcast->ah->last_send = rn->send(dev, skb, mcast->ah->ah,\n\t\t\t\t\t\tIB_MULTICAST_QPN);\n\t\tif (neigh)\n\t\t\tipoib_neigh_put(neigh);\n\t\treturn;\n\t}\n\nunlock:\n\tspin_unlock_irqrestore(&priv->lock, flags);\n}\n\nvoid ipoib_mcast_dev_flush(struct net_device *dev)\n{\n\tstruct ipoib_dev_priv *priv = ipoib_priv(dev);\n\tLIST_HEAD(remove_list);\n\tstruct ipoib_mcast *mcast, *tmcast;\n\tunsigned long flags;\n\n\tmutex_lock(&priv->mcast_mutex);\n\tipoib_dbg_mcast(priv, \"flushing multicast list\\n\");\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tlist_for_each_entry_safe(mcast, tmcast, &priv->multicast_list, list) {\n\t\tlist_del(&mcast->list);\n\t\trb_erase(&mcast->rb_node, &priv->multicast_tree);\n\t\tlist_add_tail(&mcast->list, &remove_list);\n\t}\n\n\tif (priv->broadcast) {\n\t\trb_erase(&priv->broadcast->rb_node, &priv->multicast_tree);\n\t\tlist_add_tail(&priv->broadcast->list, &remove_list);\n\t\tpriv->broadcast = NULL;\n\t}\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\tipoib_mcast_remove_list(&remove_list);\n\tmutex_unlock(&priv->mcast_mutex);\n}\n\nstatic int ipoib_mcast_addr_is_valid(const u8 *addr, const u8 *broadcast)\n{\n\t \n\tif (memcmp(addr, broadcast, 6))\n\t\treturn 0;\n\t \n\tif (memcmp(addr + 7, broadcast + 7, 3))\n\t\treturn 0;\n\treturn 1;\n}\n\nvoid ipoib_mcast_restart_task(struct work_struct *work)\n{\n\tstruct ipoib_dev_priv *priv =\n\t\tcontainer_of(work, struct ipoib_dev_priv, restart_task);\n\tstruct net_device *dev = priv->dev;\n\tstruct netdev_hw_addr *ha;\n\tstruct ipoib_mcast *mcast, *tmcast;\n\tLIST_HEAD(remove_list);\n\tstruct ib_sa_mcmember_rec rec;\n\n\tif (!test_bit(IPOIB_FLAG_OPER_UP, &priv->flags))\n\t\t \n\t\treturn;\n\n\tipoib_dbg_mcast(priv, \"restarting multicast task\\n\");\n\n\tnetif_addr_lock_bh(dev);\n\tspin_lock_irq(&priv->lock);\n\n\t \n\n\t \n\tlist_for_each_entry(mcast, &priv->multicast_list, list)\n\t\tclear_bit(IPOIB_MCAST_FLAG_FOUND, &mcast->flags);\n\n\t \n\tnetdev_for_each_mc_addr(ha, dev) {\n\t\tunion ib_gid mgid;\n\n\t\tif (!ipoib_mcast_addr_is_valid(ha->addr, dev->broadcast))\n\t\t\tcontinue;\n\n\t\tmemcpy(mgid.raw, ha->addr + 4, sizeof(mgid));\n\n\t\tmcast = __ipoib_mcast_find(dev, &mgid);\n\t\tif (!mcast || test_bit(IPOIB_MCAST_FLAG_SENDONLY, &mcast->flags)) {\n\t\t\tstruct ipoib_mcast *nmcast;\n\n\t\t\t \n\t\t\tif (test_bit(IPOIB_FLAG_UMCAST, &priv->flags) &&\n\t\t\t    !ib_sa_get_mcmember_rec(priv->ca, priv->port, &mgid, &rec)) {\n\t\t\t\tipoib_dbg_mcast(priv, \"ignoring multicast entry for mgid %pI6\\n\",\n\t\t\t\t\t\tmgid.raw);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tipoib_dbg_mcast(priv, \"adding multicast entry for mgid %pI6\\n\",\n\t\t\t\t\tmgid.raw);\n\n\t\t\tnmcast = ipoib_mcast_alloc(dev);\n\t\t\tif (!nmcast) {\n\t\t\t\tipoib_warn(priv, \"unable to allocate memory for multicast structure\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tset_bit(IPOIB_MCAST_FLAG_FOUND, &nmcast->flags);\n\n\t\t\tnmcast->mcmember.mgid = mgid;\n\n\t\t\tif (mcast) {\n\t\t\t\t \n\t\t\t\tlist_move_tail(&mcast->list, &remove_list);\n\n\t\t\t\trb_replace_node(&mcast->rb_node,\n\t\t\t\t\t\t&nmcast->rb_node,\n\t\t\t\t\t\t&priv->multicast_tree);\n\t\t\t} else\n\t\t\t\t__ipoib_mcast_add(dev, nmcast);\n\n\t\t\tlist_add_tail(&nmcast->list, &priv->multicast_list);\n\t\t}\n\n\t\tif (mcast)\n\t\t\tset_bit(IPOIB_MCAST_FLAG_FOUND, &mcast->flags);\n\t}\n\n\t \n\tlist_for_each_entry_safe(mcast, tmcast, &priv->multicast_list, list) {\n\t\tif (!test_bit(IPOIB_MCAST_FLAG_FOUND, &mcast->flags) &&\n\t\t    !test_bit(IPOIB_MCAST_FLAG_SENDONLY, &mcast->flags)) {\n\t\t\tipoib_dbg_mcast(priv, \"deleting multicast group %pI6\\n\",\n\t\t\t\t\tmcast->mcmember.mgid.raw);\n\n\t\t\trb_erase(&mcast->rb_node, &priv->multicast_tree);\n\n\t\t\t \n\t\t\tlist_move_tail(&mcast->list, &remove_list);\n\t\t}\n\t}\n\n\tspin_unlock_irq(&priv->lock);\n\tnetif_addr_unlock_bh(dev);\n\n\tipoib_mcast_remove_list(&remove_list);\n\n\t \n\tif (test_bit(IPOIB_FLAG_OPER_UP, &priv->flags)) {\n\t\tspin_lock_irq(&priv->lock);\n\t\t__ipoib_mcast_schedule_join_thread(priv, NULL, 0);\n\t\tspin_unlock_irq(&priv->lock);\n\t}\n}\n\n#ifdef CONFIG_INFINIBAND_IPOIB_DEBUG\n\nstruct ipoib_mcast_iter *ipoib_mcast_iter_init(struct net_device *dev)\n{\n\tstruct ipoib_mcast_iter *iter;\n\n\titer = kmalloc(sizeof(*iter), GFP_KERNEL);\n\tif (!iter)\n\t\treturn NULL;\n\n\titer->dev = dev;\n\tmemset(iter->mgid.raw, 0, 16);\n\n\tif (ipoib_mcast_iter_next(iter)) {\n\t\tkfree(iter);\n\t\treturn NULL;\n\t}\n\n\treturn iter;\n}\n\nint ipoib_mcast_iter_next(struct ipoib_mcast_iter *iter)\n{\n\tstruct ipoib_dev_priv *priv = ipoib_priv(iter->dev);\n\tstruct rb_node *n;\n\tstruct ipoib_mcast *mcast;\n\tint ret = 1;\n\n\tspin_lock_irq(&priv->lock);\n\n\tn = rb_first(&priv->multicast_tree);\n\n\twhile (n) {\n\t\tmcast = rb_entry(n, struct ipoib_mcast, rb_node);\n\n\t\tif (memcmp(iter->mgid.raw, mcast->mcmember.mgid.raw,\n\t\t\t   sizeof (union ib_gid)) < 0) {\n\t\t\titer->mgid      = mcast->mcmember.mgid;\n\t\t\titer->created   = mcast->created;\n\t\t\titer->queuelen  = skb_queue_len(&mcast->pkt_queue);\n\t\t\titer->complete  = !!mcast->ah;\n\t\t\titer->send_only = !!(mcast->flags & (1 << IPOIB_MCAST_FLAG_SENDONLY));\n\n\t\t\tret = 0;\n\n\t\t\tbreak;\n\t\t}\n\n\t\tn = rb_next(n);\n\t}\n\n\tspin_unlock_irq(&priv->lock);\n\n\treturn ret;\n}\n\nvoid ipoib_mcast_iter_read(struct ipoib_mcast_iter *iter,\n\t\t\t   union ib_gid *mgid,\n\t\t\t   unsigned long *created,\n\t\t\t   unsigned int *queuelen,\n\t\t\t   unsigned int *complete,\n\t\t\t   unsigned int *send_only)\n{\n\t*mgid      = iter->mgid;\n\t*created   = iter->created;\n\t*queuelen  = iter->queuelen;\n\t*complete  = iter->complete;\n\t*send_only = iter->send_only;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}