{
  "module_name": "rtrs-srv-sysfs.c",
  "hash_id": "12a5a4970ca73a2f114670e17495d2ea1e6d8f7857eb6e05fc0917b68bc25779",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/ulp/rtrs/rtrs-srv-sysfs.c",
  "human_readable_source": "\n \n#undef pr_fmt\n#define pr_fmt(fmt) KBUILD_MODNAME \" L\" __stringify(__LINE__) \": \" fmt\n\n#include \"rtrs-pri.h\"\n#include \"rtrs-srv.h\"\n#include \"rtrs-log.h\"\n\nstatic void rtrs_srv_release(struct kobject *kobj)\n{\n\tstruct rtrs_srv_path *srv_path;\n\n\tsrv_path = container_of(kobj, struct rtrs_srv_path, kobj);\n\tkfree(srv_path);\n}\n\nstatic struct kobj_type ktype = {\n\t.sysfs_ops\t= &kobj_sysfs_ops,\n\t.release\t= rtrs_srv_release,\n};\n\nstatic ssize_t rtrs_srv_disconnect_show(struct kobject *kobj,\n\t\t\t\t\tstruct kobj_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"Usage: echo 1 > %s\\n\", attr->attr.name);\n}\n\nstatic ssize_t rtrs_srv_disconnect_store(struct kobject *kobj,\n\t\t\t\t\t  struct kobj_attribute *attr,\n\t\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct rtrs_srv_path *srv_path;\n\tstruct rtrs_path *s;\n\tchar str[MAXHOSTNAMELEN];\n\n\tsrv_path = container_of(kobj, struct rtrs_srv_path, kobj);\n\ts = &srv_path->s;\n\tif (!sysfs_streq(buf, \"1\")) {\n\t\trtrs_err(s, \"%s: invalid value: '%s'\\n\",\n\t\t\t  attr->attr.name, buf);\n\t\treturn -EINVAL;\n\t}\n\n\tsockaddr_to_str((struct sockaddr *)&srv_path->s.dst_addr, str,\n\t\t\tsizeof(str));\n\n\trtrs_info(s, \"disconnect for path %s requested\\n\", str);\n\t \n\tsysfs_remove_file_self(&srv_path->kobj, &attr->attr);\n\tclose_path(srv_path);\n\n\treturn count;\n}\n\nstatic struct kobj_attribute rtrs_srv_disconnect_attr =\n\t__ATTR(disconnect, 0644,\n\t       rtrs_srv_disconnect_show, rtrs_srv_disconnect_store);\n\nstatic ssize_t rtrs_srv_hca_port_show(struct kobject *kobj,\n\t\t\t\t       struct kobj_attribute *attr,\n\t\t\t\t       char *page)\n{\n\tstruct rtrs_srv_path *srv_path;\n\tstruct rtrs_con *usr_con;\n\n\tsrv_path = container_of(kobj, typeof(*srv_path), kobj);\n\tusr_con = srv_path->s.con[0];\n\n\treturn sysfs_emit(page, \"%u\\n\", usr_con->cm_id->port_num);\n}\n\nstatic struct kobj_attribute rtrs_srv_hca_port_attr =\n\t__ATTR(hca_port, 0444, rtrs_srv_hca_port_show, NULL);\n\nstatic ssize_t rtrs_srv_hca_name_show(struct kobject *kobj,\n\t\t\t\t       struct kobj_attribute *attr,\n\t\t\t\t       char *page)\n{\n\tstruct rtrs_srv_path *srv_path;\n\n\tsrv_path = container_of(kobj, struct rtrs_srv_path, kobj);\n\n\treturn sysfs_emit(page, \"%s\\n\", srv_path->s.dev->ib_dev->name);\n}\n\nstatic struct kobj_attribute rtrs_srv_hca_name_attr =\n\t__ATTR(hca_name, 0444, rtrs_srv_hca_name_show, NULL);\n\nstatic ssize_t rtrs_srv_src_addr_show(struct kobject *kobj,\n\t\t\t\t       struct kobj_attribute *attr,\n\t\t\t\t       char *page)\n{\n\tstruct rtrs_srv_path *srv_path;\n\tint cnt;\n\n\tsrv_path = container_of(kobj, struct rtrs_srv_path, kobj);\n\tcnt = sockaddr_to_str((struct sockaddr *)&srv_path->s.dst_addr,\n\t\t\t      page, PAGE_SIZE);\n\treturn cnt + sysfs_emit_at(page, cnt, \"\\n\");\n}\n\nstatic struct kobj_attribute rtrs_srv_src_addr_attr =\n\t__ATTR(src_addr, 0444, rtrs_srv_src_addr_show, NULL);\n\nstatic ssize_t rtrs_srv_dst_addr_show(struct kobject *kobj,\n\t\t\t\t       struct kobj_attribute *attr,\n\t\t\t\t       char *page)\n{\n\tstruct rtrs_srv_path *srv_path;\n\tint len;\n\n\tsrv_path = container_of(kobj, struct rtrs_srv_path, kobj);\n\tlen = sockaddr_to_str((struct sockaddr *)&srv_path->s.src_addr, page,\n\t\t\t      PAGE_SIZE);\n\tlen += sysfs_emit_at(page, len, \"\\n\");\n\treturn len;\n}\n\nstatic struct kobj_attribute rtrs_srv_dst_addr_attr =\n\t__ATTR(dst_addr, 0444, rtrs_srv_dst_addr_show, NULL);\n\nstatic struct attribute *rtrs_srv_path_attrs[] = {\n\t&rtrs_srv_hca_name_attr.attr,\n\t&rtrs_srv_hca_port_attr.attr,\n\t&rtrs_srv_src_addr_attr.attr,\n\t&rtrs_srv_dst_addr_attr.attr,\n\t&rtrs_srv_disconnect_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group rtrs_srv_path_attr_group = {\n\t.attrs = rtrs_srv_path_attrs,\n};\n\nSTAT_ATTR(struct rtrs_srv_stats, rdma,\n\t  rtrs_srv_stats_rdma_to_str,\n\t  rtrs_srv_reset_rdma_stats);\n\nstatic struct attribute *rtrs_srv_stats_attrs[] = {\n\t&rdma_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group rtrs_srv_stats_attr_group = {\n\t.attrs = rtrs_srv_stats_attrs,\n};\n\nstatic int rtrs_srv_create_once_sysfs_root_folders(struct rtrs_srv_path *srv_path)\n{\n\tstruct rtrs_srv_sess *srv = srv_path->srv;\n\tint err = 0;\n\n\tmutex_lock(&srv->paths_mutex);\n\tif (srv->dev_ref++) {\n\t\t \n\t\tgoto unlock;\n\t}\n\tsrv->dev.class = &rtrs_dev_class;\n\terr = dev_set_name(&srv->dev, \"%s\", srv_path->s.sessname);\n\tif (err)\n\t\tgoto unlock;\n\n\t \n\tdev_set_uevent_suppress(&srv->dev, true);\n\terr = device_add(&srv->dev);\n\tif (err) {\n\t\tpr_err(\"device_add(): %d\\n\", err);\n\t\tput_device(&srv->dev);\n\t\tgoto unlock;\n\t}\n\tsrv->kobj_paths = kobject_create_and_add(\"paths\", &srv->dev.kobj);\n\tif (!srv->kobj_paths) {\n\t\terr = -ENOMEM;\n\t\tpr_err(\"kobject_create_and_add(): %d\\n\", err);\n\t\tdevice_del(&srv->dev);\n\t\tput_device(&srv->dev);\n\t\tgoto unlock;\n\t}\n\tdev_set_uevent_suppress(&srv->dev, false);\n\tkobject_uevent(&srv->dev.kobj, KOBJ_ADD);\nunlock:\n\tmutex_unlock(&srv->paths_mutex);\n\n\treturn err;\n}\n\nstatic void\nrtrs_srv_destroy_once_sysfs_root_folders(struct rtrs_srv_path *srv_path)\n{\n\tstruct rtrs_srv_sess *srv = srv_path->srv;\n\n\tmutex_lock(&srv->paths_mutex);\n\tif (!--srv->dev_ref) {\n\t\tkobject_put(srv->kobj_paths);\n\t\tmutex_unlock(&srv->paths_mutex);\n\t\tdevice_del(&srv->dev);\n\t\tput_device(&srv->dev);\n\t} else {\n\t\tput_device(&srv->dev);\n\t\tmutex_unlock(&srv->paths_mutex);\n\t}\n}\n\nstatic void rtrs_srv_path_stats_release(struct kobject *kobj)\n{\n\tstruct rtrs_srv_stats *stats;\n\n\tstats = container_of(kobj, struct rtrs_srv_stats, kobj_stats);\n\n\tfree_percpu(stats->rdma_stats);\n\n\tkfree(stats);\n}\n\nstatic struct kobj_type ktype_stats = {\n\t.sysfs_ops = &kobj_sysfs_ops,\n\t.release = rtrs_srv_path_stats_release,\n};\n\nstatic int rtrs_srv_create_stats_files(struct rtrs_srv_path *srv_path)\n{\n\tint err;\n\tstruct rtrs_path *s = &srv_path->s;\n\n\terr = kobject_init_and_add(&srv_path->stats->kobj_stats, &ktype_stats,\n\t\t\t\t   &srv_path->kobj, \"stats\");\n\tif (err) {\n\t\trtrs_err(s, \"kobject_init_and_add(): %d\\n\", err);\n\t\tkobject_put(&srv_path->stats->kobj_stats);\n\t\treturn err;\n\t}\n\terr = sysfs_create_group(&srv_path->stats->kobj_stats,\n\t\t\t\t &rtrs_srv_stats_attr_group);\n\tif (err) {\n\t\trtrs_err(s, \"sysfs_create_group(): %d\\n\", err);\n\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tkobject_del(&srv_path->stats->kobj_stats);\n\tkobject_put(&srv_path->stats->kobj_stats);\n\n\treturn err;\n}\n\nint rtrs_srv_create_path_files(struct rtrs_srv_path *srv_path)\n{\n\tstruct rtrs_srv_sess *srv = srv_path->srv;\n\tstruct rtrs_path *s = &srv_path->s;\n\tchar str[NAME_MAX];\n\tint err;\n\tstruct rtrs_addr path = {\n\t\t.src = &srv_path->s.dst_addr,\n\t\t.dst = &srv_path->s.src_addr,\n\t};\n\n\trtrs_addr_to_str(&path, str, sizeof(str));\n\terr = rtrs_srv_create_once_sysfs_root_folders(srv_path);\n\tif (err)\n\t\treturn err;\n\n\terr = kobject_init_and_add(&srv_path->kobj, &ktype, srv->kobj_paths,\n\t\t\t\t   \"%s\", str);\n\tif (err) {\n\t\trtrs_err(s, \"kobject_init_and_add(): %d\\n\", err);\n\t\tgoto destroy_root;\n\t}\n\terr = sysfs_create_group(&srv_path->kobj, &rtrs_srv_path_attr_group);\n\tif (err) {\n\t\trtrs_err(s, \"sysfs_create_group(): %d\\n\", err);\n\t\tgoto put_kobj;\n\t}\n\terr = rtrs_srv_create_stats_files(srv_path);\n\tif (err)\n\t\tgoto remove_group;\n\n\treturn 0;\n\nremove_group:\n\tsysfs_remove_group(&srv_path->kobj, &rtrs_srv_path_attr_group);\nput_kobj:\n\tkobject_del(&srv_path->kobj);\ndestroy_root:\n\tkobject_put(&srv_path->kobj);\n\trtrs_srv_destroy_once_sysfs_root_folders(srv_path);\n\n\treturn err;\n}\n\nvoid rtrs_srv_destroy_path_files(struct rtrs_srv_path *srv_path)\n{\n\tif (srv_path->stats->kobj_stats.state_in_sysfs) {\n\t\tsysfs_remove_group(&srv_path->stats->kobj_stats,\n\t\t\t\t   &rtrs_srv_stats_attr_group);\n\t\tkobject_del(&srv_path->stats->kobj_stats);\n\t\tkobject_put(&srv_path->stats->kobj_stats);\n\t}\n\n\tif (srv_path->kobj.state_in_sysfs) {\n\t\tsysfs_remove_group(&srv_path->kobj, &rtrs_srv_path_attr_group);\n\t\tkobject_put(&srv_path->kobj);\n\t\trtrs_srv_destroy_once_sysfs_root_folders(srv_path);\n\t}\n\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}