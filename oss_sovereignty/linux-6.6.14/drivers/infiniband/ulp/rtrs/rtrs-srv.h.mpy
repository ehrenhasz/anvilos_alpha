{
  "module_name": "rtrs-srv.h",
  "hash_id": "8a1390d919fcc7488546cf35b61dce2865caa90d3f26c04d023a6a5b082731f5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/ulp/rtrs/rtrs-srv.h",
  "human_readable_source": " \n \n\n#ifndef RTRS_SRV_H\n#define RTRS_SRV_H\n\n#include <linux/device.h>\n#include <linux/refcount.h>\n#include <linux/percpu.h>\n#include \"rtrs-pri.h\"\n\n \nenum rtrs_srv_state {\n\tRTRS_SRV_CONNECTING,\n\tRTRS_SRV_CONNECTED,\n\tRTRS_SRV_CLOSING,\n\tRTRS_SRV_CLOSED,\n};\n\n \nstruct rtrs_srv_stats_rdma_stats {\n\tstruct {\n\t\tu64 cnt;\n\t\tu64 size_total;\n\t} dir[2];\n};\n\nstruct rtrs_srv_stats {\n\tstruct kobject\t\t\t\t\tkobj_stats;\n\tstruct rtrs_srv_stats_rdma_stats __percpu\t*rdma_stats;\n\tstruct rtrs_srv_path\t\t\t\t*srv_path;\n};\n\nstruct rtrs_srv_con {\n\tstruct rtrs_con\t\tc;\n\tstruct list_head\trsp_wr_wait_list;\n\tspinlock_t\t\trsp_wr_wait_lock;\n};\n\n \nstruct rtrs_srv_op {\n\tstruct rtrs_srv_con\t\t*con;\n\tu32\t\t\t\tmsg_id;\n\tu8\t\t\t\tdir;\n\tstruct rtrs_msg_rdma_read\t*rd_msg;\n\tstruct ib_rdma_wr\t\ttx_wr;\n\tstruct ib_sge\t\t\ttx_sg;\n\tstruct list_head\t\twait_list;\n\tint\t\t\t\tstatus;\n};\n\n \nstruct rtrs_srv_mr {\n\tstruct ib_mr\t*mr;\n\tstruct sg_table\tsgt;\n\tstruct ib_cqe\tinv_cqe;\t \n\tu32\t\tmsg_id;\t\t \n\tu32\t\tmsg_off;\t \n\tstruct rtrs_iu\t*iu;\t\t \n};\n\nstruct rtrs_srv_path {\n\tstruct rtrs_path\ts;\n\tstruct rtrs_srv_sess\t*srv;\n\tstruct work_struct\tclose_work;\n\tenum rtrs_srv_state\tstate;\n\tspinlock_t\t\tstate_lock;\n\tint\t\t\tcur_cq_vector;\n\tstruct rtrs_srv_op\t**ops_ids;\n\tstruct percpu_ref       ids_inflight_ref;\n\tstruct completion       complete_done;\n\tstruct rtrs_srv_mr\t*mrs;\n\tunsigned int\t\tmrs_num;\n\tdma_addr_t\t\t*dma_addr;\n\tbool\t\t\testablished;\n\tunsigned int\t\tmem_bits;\n\tstruct kobject\t\tkobj;\n\tstruct rtrs_srv_stats\t*stats;\n};\n\nstatic inline struct rtrs_srv_path *to_srv_path(struct rtrs_path *s)\n{\n\treturn container_of(s, struct rtrs_srv_path, s);\n}\n\nstruct rtrs_srv_sess {\n\tstruct list_head\tpaths_list;\n\tint\t\t\tpaths_up;\n\tstruct mutex\t\tpaths_ev_mutex;\n\tsize_t\t\t\tpaths_num;\n\tstruct mutex\t\tpaths_mutex;\n\tuuid_t\t\t\tpaths_uuid;\n\trefcount_t\t\trefcount;\n\tstruct rtrs_srv_ctx\t*ctx;\n\tstruct list_head\tctx_list;\n\tvoid\t\t\t*priv;\n\tsize_t\t\t\tqueue_depth;\n\tstruct page\t\t**chunks;\n\tstruct device\t\tdev;\n\tunsigned int\t\tdev_ref;\n\tstruct kobject\t\t*kobj_paths;\n};\n\nstruct rtrs_srv_ctx {\n\tstruct rtrs_srv_ops ops;\n\tstruct rdma_cm_id *cm_id_ip;\n\tstruct rdma_cm_id *cm_id_ib;\n\tstruct mutex srv_mutex;\n\tstruct list_head srv_list;\n};\n\nstruct rtrs_srv_ib_ctx {\n\tstruct rtrs_srv_ctx\t*srv_ctx;\n\tu16\t\t\tport;\n\tstruct mutex            ib_dev_mutex;\n\tint\t\t\tib_dev_count;\n};\n\nextern const struct class rtrs_dev_class;\n\nvoid close_path(struct rtrs_srv_path *srv_path);\n\nstatic inline void rtrs_srv_update_rdma_stats(struct rtrs_srv_stats *s,\n\t\t\t\t\t      size_t size, int d)\n{\n\tthis_cpu_inc(s->rdma_stats->dir[d].cnt);\n\tthis_cpu_add(s->rdma_stats->dir[d].size_total, size);\n}\n\n \nint rtrs_srv_reset_rdma_stats(struct rtrs_srv_stats *stats, bool enable);\nssize_t rtrs_srv_stats_rdma_to_str(struct rtrs_srv_stats *stats, char *page);\nint rtrs_srv_reset_all_stats(struct rtrs_srv_stats *stats, bool enable);\nssize_t rtrs_srv_reset_all_help(struct rtrs_srv_stats *stats,\n\t\t\t\t char *page, size_t len);\n\n \nint rtrs_srv_create_path_files(struct rtrs_srv_path *srv_path);\nvoid rtrs_srv_destroy_path_files(struct rtrs_srv_path *srv_path);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}