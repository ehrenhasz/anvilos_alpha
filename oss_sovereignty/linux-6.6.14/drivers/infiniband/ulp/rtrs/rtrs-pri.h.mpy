{
  "module_name": "rtrs-pri.h",
  "hash_id": "c78064eb3199ab530b50e1185235d54816e6d70e6f0e0ac6c00cb63ac5f4421b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/ulp/rtrs/rtrs-pri.h",
  "human_readable_source": " \n \n\n#ifndef RTRS_PRI_H\n#define RTRS_PRI_H\n\n#include <linux/uuid.h>\n#include <rdma/rdma_cm.h>\n#include <rdma/ib_verbs.h>\n#include <rdma/ib.h>\n\n#include \"rtrs.h\"\n\n#define RTRS_PROTO_VER_MAJOR 2\n#define RTRS_PROTO_VER_MINOR 0\n\n#define RTRS_PROTO_VER_STRING __stringify(RTRS_PROTO_VER_MAJOR) \".\" \\\n\t\t\t       __stringify(RTRS_PROTO_VER_MINOR)\n\n \n#define MAX_SESS_QUEUE_DEPTH 65535\n\nenum rtrs_imm_const {\n\tMAX_IMM_TYPE_BITS = 4,\n\tMAX_IMM_TYPE_MASK = ((1 << MAX_IMM_TYPE_BITS) - 1),\n\tMAX_IMM_PAYL_BITS = 28,\n\tMAX_IMM_PAYL_MASK = ((1 << MAX_IMM_PAYL_BITS) - 1),\n};\n\nenum rtrs_imm_type {\n\tRTRS_IO_REQ_IMM       = 0,  \n\tRTRS_IO_RSP_IMM       = 1,  \n\tRTRS_IO_RSP_W_INV_IMM = 2,  \n\n\tRTRS_HB_MSG_IMM = 8,  \n\tRTRS_HB_ACK_IMM = 9,\n\n\tRTRS_LAST_IMM,\n};\n\nenum {\n\tSERVICE_CON_QUEUE_DEPTH = 512,\n\n\tMAX_PATHS_NUM = 128,\n\n\tMIN_CHUNK_SIZE = 8192,\n\n\tRTRS_HB_INTERVAL_MS = 5000,\n\tRTRS_HB_MISSED_MAX = 5,\n\n\tRTRS_MAGIC = 0x1BBD,\n\tRTRS_PROTO_VER = (RTRS_PROTO_VER_MAJOR << 8) | RTRS_PROTO_VER_MINOR,\n};\n\nstruct rtrs_ib_dev;\n\nstruct rtrs_rdma_dev_pd_ops {\n\tint (*init)(struct rtrs_ib_dev *dev);\n};\n\nstruct rtrs_rdma_dev_pd {\n\tstruct mutex\t\tmutex;\n\tstruct list_head\tlist;\n\tenum ib_pd_flags\tpd_flags;\n\tconst struct rtrs_rdma_dev_pd_ops *ops;\n};\n\nstruct rtrs_ib_dev {\n\tstruct ib_device\t *ib_dev;\n\tstruct ib_pd\t\t *ib_pd;\n\tstruct kref\t\t ref;\n\tstruct list_head\t entry;\n\tstruct rtrs_rdma_dev_pd *pool;\n};\n\nstruct rtrs_con {\n\tstruct rtrs_path\t*path;\n\tstruct ib_qp\t\t*qp;\n\tstruct ib_cq\t\t*cq;\n\tstruct rdma_cm_id\t*cm_id;\n\tunsigned int\t\tcid;\n\tint                     nr_cqe;\n\tatomic_t\t\twr_cnt;\n\tatomic_t\t\tsq_wr_avail;\n};\n\nstruct rtrs_path {\n\tstruct list_head\tentry;\n\tstruct sockaddr_storage dst_addr;\n\tstruct sockaddr_storage src_addr;\n\tchar\t\t\tsessname[NAME_MAX];\n\tuuid_t\t\t\tuuid;\n\tstruct rtrs_con\t**con;\n\tunsigned int\t\tcon_num;\n\tunsigned int\t\tirq_con_num;\n\tunsigned int\t\trecon_cnt;\n\tunsigned int\t\tsignal_interval;\n\tstruct rtrs_ib_dev\t*dev;\n\tint\t\t\tdev_ref;\n\tstruct ib_cqe\t\t*hb_cqe;\n\tvoid\t\t\t(*hb_err_handler)(struct rtrs_con *con);\n\tstruct workqueue_struct *hb_wq;\n\tstruct delayed_work\thb_dwork;\n\tunsigned int\t\thb_interval_ms;\n\tunsigned int\t\thb_missed_cnt;\n\tunsigned int\t\thb_missed_max;\n\tktime_t\t\t\thb_last_sent;\n\tktime_t\t\t\thb_cur_latency;\n};\n\n \nstruct rtrs_iu {\n\tstruct ib_cqe           cqe;\n\tdma_addr_t              dma_addr;\n\tvoid                    *buf;\n\tsize_t                  size;\n\tenum dma_data_direction direction;\n};\n\n \nenum rtrs_msg_types {\n\tRTRS_MSG_INFO_REQ,\n\tRTRS_MSG_INFO_RSP,\n\tRTRS_MSG_WRITE,\n\tRTRS_MSG_READ,\n\tRTRS_MSG_RKEY_RSP,\n};\n\n \nenum rtrs_msg_flags {\n\tRTRS_MSG_NEED_INVAL_F = 1 << 0,\n\tRTRS_MSG_NEW_RKEY_F = 1 << 1,\n};\n\n \nstruct rtrs_sg_desc {\n\t__le64\t\t\taddr;\n\t__le32\t\t\tkey;\n\t__le32\t\t\tlen;\n};\n\n \nstruct rtrs_msg_conn_req {\n\t \n\tu8\t\t__cma_version;\n\t \n\tu8\t\t__ip_version;\n\t__le16\t\tmagic;\n\t__le16\t\tversion;\n\t__le16\t\tcid;\n\t__le16\t\tcid_num;\n\t__le16\t\trecon_cnt;\n\tuuid_t\t\tsess_uuid;\n\tuuid_t\t\tpaths_uuid;\n\tu8\t\tfirst_conn : 1;\n\tu8\t\treserved_bits : 7;\n\tu8\t\treserved[11];\n};\n\n \nstruct rtrs_msg_conn_rsp {\n\t__le16\t\tmagic;\n\t__le16\t\tversion;\n\t__le16\t\terrno;\n\t__le16\t\tqueue_depth;\n\t__le32\t\tmax_io_size;\n\t__le32\t\tmax_hdr_size;\n\t__le32\t\tflags;\n\tu8\t\treserved[36];\n};\n\n \nstruct rtrs_msg_info_req {\n\t__le16\t\ttype;\n\tu8\t\tpathname[NAME_MAX];\n\tu8\t\treserved[15];\n};\n\n \nstruct rtrs_msg_info_rsp {\n\t__le16\t\ttype;\n\t__le16          sg_cnt;\n\tu8              reserved[4];\n\tstruct rtrs_sg_desc desc[];\n};\n\n \nstruct rtrs_msg_rkey_rsp {\n\t__le16\t\ttype;\n\t__le16          buf_id;\n\t__le32\t\trkey;\n};\n\n \nstruct rtrs_msg_rdma_read {\n\t__le16\t\t\ttype;\n\t__le16\t\t\tusr_len;\n\t__le16\t\t\tflags;\n\t__le16\t\t\tsg_cnt;\n\tstruct rtrs_sg_desc    desc[];\n};\n\n \nstruct rtrs_msg_rdma_write {\n\t__le16\t\t\ttype;\n\t__le16\t\t\tusr_len;\n};\n\n \nstruct rtrs_msg_rdma_hdr {\n\t__le16\t\t\ttype;\n};\n\n \n\nstruct rtrs_iu *rtrs_iu_alloc(u32 queue_num, size_t size, gfp_t t,\n\t\t\t      struct ib_device *dev, enum dma_data_direction,\n\t\t\t      void (*done)(struct ib_cq *cq, struct ib_wc *wc));\nvoid rtrs_iu_free(struct rtrs_iu *iu, struct ib_device *dev, u32 queue_num);\nint rtrs_iu_post_recv(struct rtrs_con *con, struct rtrs_iu *iu);\nint rtrs_iu_post_send(struct rtrs_con *con, struct rtrs_iu *iu, size_t size,\n\t\t      struct ib_send_wr *head);\nint rtrs_iu_post_rdma_write_imm(struct rtrs_con *con, struct rtrs_iu *iu,\n\t\t\t\tstruct ib_sge *sge, unsigned int num_sge,\n\t\t\t\tu32 rkey, u64 rdma_addr, u32 imm_data,\n\t\t\t\tenum ib_send_flags flags,\n\t\t\t\tstruct ib_send_wr *head,\n\t\t\t\tstruct ib_send_wr *tail);\n\nint rtrs_post_recv_empty(struct rtrs_con *con, struct ib_cqe *cqe);\n\nint rtrs_cq_qp_create(struct rtrs_path *path, struct rtrs_con *con,\n\t\t      u32 max_send_sge, int cq_vector, int nr_cqe,\n\t\t      u32 max_send_wr, u32 max_recv_wr,\n\t\t      enum ib_poll_context poll_ctx);\nvoid rtrs_cq_qp_destroy(struct rtrs_con *con);\n\nvoid rtrs_init_hb(struct rtrs_path *path, struct ib_cqe *cqe,\n\t\t  unsigned int interval_ms, unsigned int missed_max,\n\t\t  void (*err_handler)(struct rtrs_con *con),\n\t\t  struct workqueue_struct *wq);\nvoid rtrs_start_hb(struct rtrs_path *path);\nvoid rtrs_stop_hb(struct rtrs_path *path);\nvoid rtrs_send_hb_ack(struct rtrs_path *path);\n\nvoid rtrs_rdma_dev_pd_init(enum ib_pd_flags pd_flags,\n\t\t\t   struct rtrs_rdma_dev_pd *pool);\nvoid rtrs_rdma_dev_pd_deinit(struct rtrs_rdma_dev_pd *pool);\n\nstruct rtrs_ib_dev *rtrs_ib_dev_find_or_add(struct ib_device *ib_dev,\n\t\t\t\t\t    struct rtrs_rdma_dev_pd *pool);\nint rtrs_ib_dev_put(struct rtrs_ib_dev *dev);\n\nstatic inline u32 rtrs_to_imm(u32 type, u32 payload)\n{\n\tBUILD_BUG_ON(MAX_IMM_PAYL_BITS + MAX_IMM_TYPE_BITS != 32);\n\tBUILD_BUG_ON(RTRS_LAST_IMM > (1<<MAX_IMM_TYPE_BITS));\n\treturn ((type & MAX_IMM_TYPE_MASK) << MAX_IMM_PAYL_BITS) |\n\t\t(payload & MAX_IMM_PAYL_MASK);\n}\n\nstatic inline void rtrs_from_imm(u32 imm, u32 *type, u32 *payload)\n{\n\t*payload = imm & MAX_IMM_PAYL_MASK;\n\t*type = imm >> MAX_IMM_PAYL_BITS;\n}\n\nstatic inline u32 rtrs_to_io_req_imm(u32 addr)\n{\n\treturn rtrs_to_imm(RTRS_IO_REQ_IMM, addr);\n}\n\nstatic inline u32 rtrs_to_io_rsp_imm(u32 msg_id, int errno, bool w_inval)\n{\n\tenum rtrs_imm_type type;\n\tu32 payload;\n\n\t \n\tpayload = (abs(errno) & 0x1ff) << 19 | (msg_id & 0x7ffff);\n\ttype = w_inval ? RTRS_IO_RSP_W_INV_IMM : RTRS_IO_RSP_IMM;\n\n\treturn rtrs_to_imm(type, payload);\n}\n\nstatic inline void rtrs_from_io_rsp_imm(u32 payload, u32 *msg_id, int *errno)\n{\n\t \n\t*msg_id = payload & 0x7ffff;\n\t*errno = -(int)((payload >> 19) & 0x1ff);\n}\n\n#define STAT_STORE_FUNC(type, set_value, reset)\t\t\t\t\\\nstatic ssize_t set_value##_store(struct kobject *kobj,\t\t\t\\\n\t\t\t     struct kobj_attribute *attr,\t\t\\\n\t\t\t     const char *buf, size_t count)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tint ret = -EINVAL;\t\t\t\t\t\t\\\n\ttype *stats = container_of(kobj, type, kobj_stats);\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (sysfs_streq(buf, \"1\"))\t\t\t\t\t\\\n\t\tret = reset(stats, true);\t\t\t\\\n\telse if (sysfs_streq(buf, \"0\"))\t\t\t\t\t\\\n\t\tret = reset(stats, false);\t\t\t\\\n\tif (ret)\t\t\t\t\t\t\t\\\n\t\treturn ret;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn count;\t\t\t\t\t\t\t\\\n}\n\n#define STAT_SHOW_FUNC(type, get_value, print)\t\t\t\t\\\nstatic ssize_t get_value##_show(struct kobject *kobj,\t\t\t\\\n\t\t\t   struct kobj_attribute *attr,\t\t\t\\\n\t\t\t   char *page)\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\ttype *stats = container_of(kobj, type, kobj_stats);\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn print(stats, page);\t\t\t\\\n}\n\n#define STAT_ATTR(type, stat, print, reset)\t\t\t\t\\\nSTAT_STORE_FUNC(type, stat, reset)\t\t\t\t\t\\\nSTAT_SHOW_FUNC(type, stat, print)\t\t\t\t\t\\\nstatic struct kobj_attribute stat##_attr = __ATTR_RW(stat)\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}