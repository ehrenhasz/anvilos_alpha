{
  "module_name": "rtrs.h",
  "hash_id": "0fda271caee567449283c762634e0dc4d02397334cc0ce8e7f5ef4ab7ae4ad9b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/ulp/rtrs/rtrs.h",
  "human_readable_source": " \n \n#ifndef RTRS_H\n#define RTRS_H\n\n#include <linux/socket.h>\n#include <linux/scatterlist.h>\n\nstruct rtrs_permit;\nstruct rtrs_clt_sess;\nstruct rtrs_srv_ctx;\nstruct rtrs_srv_sess;\nstruct rtrs_srv_op;\n\n \n\n \nenum rtrs_clt_link_ev {\n\tRTRS_CLT_LINK_EV_RECONNECTED,\n\tRTRS_CLT_LINK_EV_DISCONNECTED,\n};\n\n \nstruct rtrs_addr {\n\tstruct sockaddr_storage *src;\n\tstruct sockaddr_storage *dst;\n};\n\n \nstruct rtrs_clt_ops {\n\tvoid\t*priv;\n\tvoid\t(*link_ev)(void *priv, enum rtrs_clt_link_ev ev);\n};\n\nstruct rtrs_clt_sess *rtrs_clt_open(struct rtrs_clt_ops *ops,\n\t\t\t\t const char *pathname,\n\t\t\t\t const struct rtrs_addr *paths,\n\t\t\t\t size_t path_cnt, u16 port,\n\t\t\t\t size_t pdu_sz, u8 reconnect_delay_sec,\n\t\t\t\t s16 max_reconnect_attempts, u32 nr_poll_queues);\n\nvoid rtrs_clt_close(struct rtrs_clt_sess *clt);\n\nenum wait_type {\n\tRTRS_PERMIT_NOWAIT = 0,\n\tRTRS_PERMIT_WAIT   = 1\n};\n\n \nenum rtrs_clt_con_type {\n\tRTRS_ADMIN_CON,\n\tRTRS_IO_CON\n};\n\nstruct rtrs_permit *rtrs_clt_get_permit(struct rtrs_clt_sess *sess,\n\t\t\t\t\tenum rtrs_clt_con_type con_type,\n\t\t\t\t\tenum wait_type wait);\n\nvoid rtrs_clt_put_permit(struct rtrs_clt_sess *sess,\n\t\t\t struct rtrs_permit *permit);\n\n \nstruct rtrs_clt_req_ops {\n\tvoid\t*priv;\n\tvoid\t(*conf_fn)(void *priv, int errno);\n};\n\nint rtrs_clt_request(int dir, struct rtrs_clt_req_ops *ops,\n\t\t     struct rtrs_clt_sess *sess, struct rtrs_permit *permit,\n\t\t     const struct kvec *vec, size_t nr, size_t len,\n\t\t     struct scatterlist *sg, unsigned int sg_cnt);\nint rtrs_clt_rdma_cq_direct(struct rtrs_clt_sess *clt, unsigned int index);\n\n \nstruct rtrs_attrs {\n\tu32\t\tqueue_depth;\n\tu32\t\tmax_io_size;\n\tu32\t\tmax_segments;\n};\n\nint rtrs_clt_query(struct rtrs_clt_sess *sess, struct rtrs_attrs *attr);\n\n \n\n \nenum rtrs_srv_link_ev {\n\tRTRS_SRV_LINK_EV_CONNECTED,\n\tRTRS_SRV_LINK_EV_DISCONNECTED,\n};\n\nstruct rtrs_srv_ops {\n\t \n\tint (*rdma_ev)(void *priv,\n\t\t       struct rtrs_srv_op *id,\n\t\t       void *data, size_t datalen, const void *usr,\n\t\t       size_t usrlen);\n\t \n\tint (*link_ev)(struct rtrs_srv_sess *sess, enum rtrs_srv_link_ev ev,\n\t\t       void *priv);\n};\n\nstruct rtrs_srv_ctx *rtrs_srv_open(struct rtrs_srv_ops *ops, u16 port);\n\nvoid rtrs_srv_close(struct rtrs_srv_ctx *ctx);\n\nbool rtrs_srv_resp_rdma(struct rtrs_srv_op *id, int errno);\n\nvoid rtrs_srv_set_sess_priv(struct rtrs_srv_sess *sess, void *priv);\n\nint rtrs_srv_get_path_name(struct rtrs_srv_sess *sess, char *pathname,\n\t\t\t   size_t len);\n\nint rtrs_srv_get_queue_depth(struct rtrs_srv_sess *sess);\n\nint rtrs_addr_to_sockaddr(const char *str, size_t len, u16 port,\n\t\t\t  struct rtrs_addr *addr);\n\nint sockaddr_to_str(const struct sockaddr *addr, char *buf, size_t len);\nint rtrs_addr_to_str(const struct rtrs_addr *addr, char *buf, size_t len);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}