{
  "module_name": "rtrs-clt-sysfs.c",
  "hash_id": "1ac627e9c264fa2934c38bffb3b1b51e33dbaa376903430629d0fcb550f8c643",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/ulp/rtrs/rtrs-clt-sysfs.c",
  "human_readable_source": "\n \n#undef pr_fmt\n#define pr_fmt(fmt) KBUILD_MODNAME \" L\" __stringify(__LINE__) \": \" fmt\n\n#include \"rtrs-pri.h\"\n#include \"rtrs-clt.h\"\n#include \"rtrs-log.h\"\n\n#define MIN_MAX_RECONN_ATT -1\n#define MAX_MAX_RECONN_ATT 9999\n\nstatic void rtrs_clt_path_release(struct kobject *kobj)\n{\n\tstruct rtrs_clt_path *clt_path;\n\n\tclt_path = container_of(kobj, struct rtrs_clt_path, kobj);\n\n\tfree_path(clt_path);\n}\n\nstatic struct kobj_type ktype_sess = {\n\t.sysfs_ops = &kobj_sysfs_ops,\n\t.release = rtrs_clt_path_release\n};\n\nstatic void rtrs_clt_path_stats_release(struct kobject *kobj)\n{\n\tstruct rtrs_clt_stats *stats;\n\n\tstats = container_of(kobj, struct rtrs_clt_stats, kobj_stats);\n\n\tfree_percpu(stats->pcpu_stats);\n\n\tkfree(stats);\n}\n\nstatic struct kobj_type ktype_stats = {\n\t.sysfs_ops = &kobj_sysfs_ops,\n\t.release = rtrs_clt_path_stats_release,\n};\n\nstatic ssize_t max_reconnect_attempts_show(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   char *page)\n{\n\tstruct rtrs_clt_sess *clt = container_of(dev, struct rtrs_clt_sess,\n\t\t\t\t\t\t dev);\n\n\treturn sysfs_emit(page, \"%d\\n\",\n\t\t\t  rtrs_clt_get_max_reconnect_attempts(clt));\n}\n\nstatic ssize_t max_reconnect_attempts_store(struct device *dev,\n\t\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t\t    const char *buf,\n\t\t\t\t\t    size_t count)\n{\n\tint value;\n\tint ret;\n\tstruct rtrs_clt_sess *clt  = container_of(dev, struct rtrs_clt_sess,\n\t\t\t\t\t\t  dev);\n\n\tret = kstrtoint(buf, 10, &value);\n\tif (ret) {\n\t\trtrs_err(clt, \"%s: failed to convert string '%s' to int\\n\",\n\t\t\t  attr->attr.name, buf);\n\t\treturn ret;\n\t}\n\tif (value > MAX_MAX_RECONN_ATT ||\n\t\t     value < MIN_MAX_RECONN_ATT) {\n\t\trtrs_err(clt,\n\t\t\t  \"%s: invalid range (provided: '%s', accepted: min: %d, max: %d)\\n\",\n\t\t\t  attr->attr.name, buf, MIN_MAX_RECONN_ATT,\n\t\t\t  MAX_MAX_RECONN_ATT);\n\t\treturn -EINVAL;\n\t}\n\trtrs_clt_set_max_reconnect_attempts(clt, value);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(max_reconnect_attempts);\n\nstatic ssize_t mpath_policy_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t char *page)\n{\n\tstruct rtrs_clt_sess *clt;\n\n\tclt = container_of(dev, struct rtrs_clt_sess, dev);\n\n\tswitch (clt->mp_policy) {\n\tcase MP_POLICY_RR:\n\t\treturn sysfs_emit(page, \"round-robin (RR: %d)\\n\",\n\t\t\t\t  clt->mp_policy);\n\tcase MP_POLICY_MIN_INFLIGHT:\n\t\treturn sysfs_emit(page, \"min-inflight (MI: %d)\\n\",\n\t\t\t\t  clt->mp_policy);\n\tcase MP_POLICY_MIN_LATENCY:\n\t\treturn sysfs_emit(page, \"min-latency (ML: %d)\\n\",\n\t\t\t\t  clt->mp_policy);\n\tdefault:\n\t\treturn sysfs_emit(page, \"Unknown (%d)\\n\", clt->mp_policy);\n\t}\n}\n\nstatic ssize_t mpath_policy_store(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf,\n\t\t\t\t  size_t count)\n{\n\tstruct rtrs_clt_sess *clt;\n\tint value;\n\tint ret;\n\tsize_t len = 0;\n\n\tclt = container_of(dev, struct rtrs_clt_sess, dev);\n\n\tret = kstrtoint(buf, 10, &value);\n\tif (!ret && (value == MP_POLICY_RR ||\n\t\t     value == MP_POLICY_MIN_INFLIGHT ||\n\t\t     value == MP_POLICY_MIN_LATENCY)) {\n\t\tclt->mp_policy = value;\n\t\treturn count;\n\t}\n\n\t \n\tlen = strnlen(buf, NAME_MAX);\n\tif (buf[len - 1] == '\\n')\n\t\tlen--;\n\n\tif (!strncasecmp(buf, \"round-robin\", 11) ||\n\t    (len == 2 && !strncasecmp(buf, \"rr\", 2)))\n\t\tclt->mp_policy = MP_POLICY_RR;\n\telse if (!strncasecmp(buf, \"min-inflight\", 12) ||\n\t\t (len == 2 && !strncasecmp(buf, \"mi\", 2)))\n\t\tclt->mp_policy = MP_POLICY_MIN_INFLIGHT;\n\telse if (!strncasecmp(buf, \"min-latency\", 11) ||\n\t\t (len == 2 && !strncasecmp(buf, \"ml\", 2)))\n\t\tclt->mp_policy = MP_POLICY_MIN_LATENCY;\n\telse\n\t\treturn -EINVAL;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(mpath_policy);\n\nstatic ssize_t add_path_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *page)\n{\n\treturn sysfs_emit(page,\n\t\t\"Usage: echo [<source addr>@]<destination addr> > %s\\n\\n*addr ::= [ ip:<ipv4|ipv6> | gid:<gid> ]\\n\",\n\t\tattr->attr.name);\n}\n\nstatic ssize_t add_path_store(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      const char *buf, size_t count)\n{\n\tstruct sockaddr_storage srcaddr, dstaddr;\n\tstruct rtrs_addr addr = {\n\t\t.src = &srcaddr,\n\t\t.dst = &dstaddr\n\t};\n\tstruct rtrs_clt_sess *clt;\n\tconst char *nl;\n\tsize_t len;\n\tint err;\n\n\tclt = container_of(dev, struct rtrs_clt_sess, dev);\n\n\tnl = strchr(buf, '\\n');\n\tif (nl)\n\t\tlen = nl - buf;\n\telse\n\t\tlen = count;\n\terr = rtrs_addr_to_sockaddr(buf, len, clt->port, &addr);\n\tif (err)\n\t\treturn -EINVAL;\n\n\terr = rtrs_clt_create_path_from_sysfs(clt, &addr);\n\tif (err)\n\t\treturn err;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(add_path);\n\nstatic ssize_t rtrs_clt_state_show(struct kobject *kobj,\n\t\t\t\t    struct kobj_attribute *attr, char *page)\n{\n\tstruct rtrs_clt_path *clt_path;\n\n\tclt_path = container_of(kobj, struct rtrs_clt_path, kobj);\n\tif (clt_path->state == RTRS_CLT_CONNECTED)\n\t\treturn sysfs_emit(page, \"connected\\n\");\n\n\treturn sysfs_emit(page, \"disconnected\\n\");\n}\n\nstatic struct kobj_attribute rtrs_clt_state_attr =\n\t__ATTR(state, 0444, rtrs_clt_state_show, NULL);\n\nstatic ssize_t rtrs_clt_reconnect_show(struct kobject *kobj,\n\t\t\t\t       struct kobj_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"Usage: echo 1 > %s\\n\", attr->attr.name);\n}\n\nstatic ssize_t rtrs_clt_reconnect_store(struct kobject *kobj,\n\t\t\t\t\t struct kobj_attribute *attr,\n\t\t\t\t\t const char *buf, size_t count)\n{\n\tstruct rtrs_clt_path *clt_path;\n\tint ret;\n\n\tclt_path = container_of(kobj, struct rtrs_clt_path, kobj);\n\tif (!sysfs_streq(buf, \"1\")) {\n\t\trtrs_err(clt_path->clt, \"%s: unknown value: '%s'\\n\",\n\t\t\t  attr->attr.name, buf);\n\t\treturn -EINVAL;\n\t}\n\tret = rtrs_clt_reconnect_from_sysfs(clt_path);\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic struct kobj_attribute rtrs_clt_reconnect_attr =\n\t__ATTR(reconnect, 0644, rtrs_clt_reconnect_show,\n\t       rtrs_clt_reconnect_store);\n\nstatic ssize_t rtrs_clt_disconnect_show(struct kobject *kobj,\n\t\t\t\t\tstruct kobj_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"Usage: echo 1 > %s\\n\", attr->attr.name);\n}\n\nstatic ssize_t rtrs_clt_disconnect_store(struct kobject *kobj,\n\t\t\t\t\t  struct kobj_attribute *attr,\n\t\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct rtrs_clt_path *clt_path;\n\n\tclt_path = container_of(kobj, struct rtrs_clt_path, kobj);\n\tif (!sysfs_streq(buf, \"1\")) {\n\t\trtrs_err(clt_path->clt, \"%s: unknown value: '%s'\\n\",\n\t\t\t  attr->attr.name, buf);\n\t\treturn -EINVAL;\n\t}\n\trtrs_clt_close_conns(clt_path, true);\n\n\treturn count;\n}\n\nstatic struct kobj_attribute rtrs_clt_disconnect_attr =\n\t__ATTR(disconnect, 0644, rtrs_clt_disconnect_show,\n\t       rtrs_clt_disconnect_store);\n\nstatic ssize_t rtrs_clt_remove_path_show(struct kobject *kobj,\n\t\t\t\t\t struct kobj_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"Usage: echo 1 > %s\\n\", attr->attr.name);\n}\n\nstatic ssize_t rtrs_clt_remove_path_store(struct kobject *kobj,\n\t\t\t\t\t   struct kobj_attribute *attr,\n\t\t\t\t\t   const char *buf, size_t count)\n{\n\tstruct rtrs_clt_path *clt_path;\n\tint ret;\n\n\tclt_path = container_of(kobj, struct rtrs_clt_path, kobj);\n\tif (!sysfs_streq(buf, \"1\")) {\n\t\trtrs_err(clt_path->clt, \"%s: unknown value: '%s'\\n\",\n\t\t\t  attr->attr.name, buf);\n\t\treturn -EINVAL;\n\t}\n\tret = rtrs_clt_remove_path_from_sysfs(clt_path, &attr->attr);\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic struct kobj_attribute rtrs_clt_remove_path_attr =\n\t__ATTR(remove_path, 0644, rtrs_clt_remove_path_show,\n\t       rtrs_clt_remove_path_store);\n\nSTAT_ATTR(struct rtrs_clt_stats, cpu_migration_from,\n\t  rtrs_clt_stats_migration_from_cnt_to_str,\n\t  rtrs_clt_reset_cpu_migr_stats);\n\nSTAT_ATTR(struct rtrs_clt_stats, cpu_migration_to,\n\t  rtrs_clt_stats_migration_to_cnt_to_str,\n\t  rtrs_clt_reset_cpu_migr_stats);\n\nSTAT_ATTR(struct rtrs_clt_stats, reconnects,\n\t  rtrs_clt_stats_reconnects_to_str,\n\t  rtrs_clt_reset_reconnects_stat);\n\nSTAT_ATTR(struct rtrs_clt_stats, rdma,\n\t  rtrs_clt_stats_rdma_to_str,\n\t  rtrs_clt_reset_rdma_stats);\n\nSTAT_ATTR(struct rtrs_clt_stats, reset_all,\n\t  rtrs_clt_reset_all_help,\n\t  rtrs_clt_reset_all_stats);\n\nstatic struct attribute *rtrs_clt_stats_attrs[] = {\n\t&cpu_migration_from_attr.attr,\n\t&cpu_migration_to_attr.attr,\n\t&reconnects_attr.attr,\n\t&rdma_attr.attr,\n\t&reset_all_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group rtrs_clt_stats_attr_group = {\n\t.attrs = rtrs_clt_stats_attrs,\n};\n\nstatic ssize_t rtrs_clt_hca_port_show(struct kobject *kobj,\n\t\t\t\t       struct kobj_attribute *attr,\n\t\t\t\t       char *page)\n{\n\tstruct rtrs_clt_path *clt_path;\n\n\tclt_path = container_of(kobj, typeof(*clt_path), kobj);\n\n\treturn sysfs_emit(page, \"%u\\n\", clt_path->hca_port);\n}\n\nstatic struct kobj_attribute rtrs_clt_hca_port_attr =\n\t__ATTR(hca_port, 0444, rtrs_clt_hca_port_show, NULL);\n\nstatic ssize_t rtrs_clt_hca_name_show(struct kobject *kobj,\n\t\t\t\t       struct kobj_attribute *attr,\n\t\t\t\t       char *page)\n{\n\tstruct rtrs_clt_path *clt_path;\n\n\tclt_path = container_of(kobj, struct rtrs_clt_path, kobj);\n\n\treturn sysfs_emit(page, \"%s\\n\", clt_path->hca_name);\n}\n\nstatic struct kobj_attribute rtrs_clt_hca_name_attr =\n\t__ATTR(hca_name, 0444, rtrs_clt_hca_name_show, NULL);\n\nstatic ssize_t rtrs_clt_cur_latency_show(struct kobject *kobj,\n\t\t\t\t    struct kobj_attribute *attr,\n\t\t\t\t    char *page)\n{\n\tstruct rtrs_clt_path *clt_path;\n\n\tclt_path = container_of(kobj, struct rtrs_clt_path, kobj);\n\n\treturn sysfs_emit(page, \"%lld ns\\n\",\n\t\t\t  ktime_to_ns(clt_path->s.hb_cur_latency));\n}\n\nstatic struct kobj_attribute rtrs_clt_cur_latency_attr =\n\t__ATTR(cur_latency, 0444, rtrs_clt_cur_latency_show, NULL);\n\nstatic ssize_t rtrs_clt_src_addr_show(struct kobject *kobj,\n\t\t\t\t       struct kobj_attribute *attr,\n\t\t\t\t       char *page)\n{\n\tstruct rtrs_clt_path *clt_path;\n\tint len;\n\n\tclt_path = container_of(kobj, struct rtrs_clt_path, kobj);\n\tlen = sockaddr_to_str((struct sockaddr *)&clt_path->s.src_addr, page,\n\t\t\t      PAGE_SIZE);\n\tlen += sysfs_emit_at(page, len, \"\\n\");\n\treturn len;\n}\n\nstatic struct kobj_attribute rtrs_clt_src_addr_attr =\n\t__ATTR(src_addr, 0444, rtrs_clt_src_addr_show, NULL);\n\nstatic ssize_t rtrs_clt_dst_addr_show(struct kobject *kobj,\n\t\t\t\t       struct kobj_attribute *attr,\n\t\t\t\t       char *page)\n{\n\tstruct rtrs_clt_path *clt_path;\n\tint len;\n\n\tclt_path = container_of(kobj, struct rtrs_clt_path, kobj);\n\tlen = sockaddr_to_str((struct sockaddr *)&clt_path->s.dst_addr, page,\n\t\t\t      PAGE_SIZE);\n\tlen += sysfs_emit_at(page, len, \"\\n\");\n\treturn len;\n}\n\nstatic struct kobj_attribute rtrs_clt_dst_addr_attr =\n\t__ATTR(dst_addr, 0444, rtrs_clt_dst_addr_show, NULL);\n\nstatic struct attribute *rtrs_clt_path_attrs[] = {\n\t&rtrs_clt_hca_name_attr.attr,\n\t&rtrs_clt_hca_port_attr.attr,\n\t&rtrs_clt_src_addr_attr.attr,\n\t&rtrs_clt_dst_addr_attr.attr,\n\t&rtrs_clt_state_attr.attr,\n\t&rtrs_clt_reconnect_attr.attr,\n\t&rtrs_clt_disconnect_attr.attr,\n\t&rtrs_clt_remove_path_attr.attr,\n\t&rtrs_clt_cur_latency_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group rtrs_clt_path_attr_group = {\n\t.attrs = rtrs_clt_path_attrs,\n};\n\nint rtrs_clt_create_path_files(struct rtrs_clt_path *clt_path)\n{\n\tstruct rtrs_clt_sess *clt = clt_path->clt;\n\tchar str[NAME_MAX];\n\tint err;\n\tstruct rtrs_addr path = {\n\t\t.src = &clt_path->s.src_addr,\n\t\t.dst = &clt_path->s.dst_addr,\n\t};\n\n\trtrs_addr_to_str(&path, str, sizeof(str));\n\terr = kobject_init_and_add(&clt_path->kobj, &ktype_sess,\n\t\t\t\t   clt->kobj_paths,\n\t\t\t\t   \"%s\", str);\n\tif (err) {\n\t\tpr_err(\"kobject_init_and_add: %d\\n\", err);\n\t\tkobject_put(&clt_path->kobj);\n\t\treturn err;\n\t}\n\terr = sysfs_create_group(&clt_path->kobj, &rtrs_clt_path_attr_group);\n\tif (err) {\n\t\tpr_err(\"sysfs_create_group(): %d\\n\", err);\n\t\tgoto put_kobj;\n\t}\n\terr = kobject_init_and_add(&clt_path->stats->kobj_stats, &ktype_stats,\n\t\t\t\t   &clt_path->kobj, \"stats\");\n\tif (err) {\n\t\tpr_err(\"kobject_init_and_add: %d\\n\", err);\n\t\tkobject_put(&clt_path->stats->kobj_stats);\n\t\tgoto remove_group;\n\t}\n\n\terr = sysfs_create_group(&clt_path->stats->kobj_stats,\n\t\t\t\t &rtrs_clt_stats_attr_group);\n\tif (err) {\n\t\tpr_err(\"failed to create stats sysfs group, err: %d\\n\", err);\n\t\tgoto put_kobj_stats;\n\t}\n\n\treturn 0;\n\nput_kobj_stats:\n\tkobject_del(&clt_path->stats->kobj_stats);\n\tkobject_put(&clt_path->stats->kobj_stats);\nremove_group:\n\tsysfs_remove_group(&clt_path->kobj, &rtrs_clt_path_attr_group);\nput_kobj:\n\tkobject_del(&clt_path->kobj);\n\tkobject_put(&clt_path->kobj);\n\n\treturn err;\n}\n\nvoid rtrs_clt_destroy_path_files(struct rtrs_clt_path *clt_path,\n\t\t\t\t  const struct attribute *sysfs_self)\n{\n\tkobject_del(&clt_path->stats->kobj_stats);\n\tkobject_put(&clt_path->stats->kobj_stats);\n\tif (sysfs_self)\n\t\tsysfs_remove_file_self(&clt_path->kobj, sysfs_self);\n\tkobject_del(&clt_path->kobj);\n}\n\nstatic struct attribute *rtrs_clt_attrs[] = {\n\t&dev_attr_max_reconnect_attempts.attr,\n\t&dev_attr_mpath_policy.attr,\n\t&dev_attr_add_path.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group rtrs_clt_attr_group = {\n\t.attrs = rtrs_clt_attrs,\n};\n\nint rtrs_clt_create_sysfs_root_files(struct rtrs_clt_sess *clt)\n{\n\treturn sysfs_create_group(&clt->dev.kobj, &rtrs_clt_attr_group);\n}\n\nvoid rtrs_clt_destroy_sysfs_root(struct rtrs_clt_sess *clt)\n{\n\tsysfs_remove_group(&clt->dev.kobj, &rtrs_clt_attr_group);\n\n\tif (clt->kobj_paths) {\n\t\tkobject_del(clt->kobj_paths);\n\t\tkobject_put(clt->kobj_paths);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}