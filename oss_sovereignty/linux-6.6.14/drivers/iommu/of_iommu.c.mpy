{
  "module_name": "of_iommu.c",
  "hash_id": "5d01ed343dde28bceff414f4c174162884831c32aba84331ffaa9e40fa97dbac",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iommu/of_iommu.c",
  "human_readable_source": "\n \n\n#include <linux/export.h>\n#include <linux/iommu.h>\n#include <linux/limits.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_iommu.h>\n#include <linux/of_pci.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/fsl/mc.h>\n\n#define NO_IOMMU\t1\n\nstatic int of_iommu_xlate(struct device *dev,\n\t\t\t  struct of_phandle_args *iommu_spec)\n{\n\tconst struct iommu_ops *ops;\n\tstruct fwnode_handle *fwnode = &iommu_spec->np->fwnode;\n\tint ret;\n\n\tops = iommu_ops_from_fwnode(fwnode);\n\tif ((ops && !ops->of_xlate) ||\n\t    !of_device_is_available(iommu_spec->np))\n\t\treturn NO_IOMMU;\n\n\tret = iommu_fwspec_init(dev, &iommu_spec->np->fwnode, ops);\n\tif (ret)\n\t\treturn ret;\n\t \n\tif (!ops)\n\t\treturn driver_deferred_probe_check_state(dev);\n\n\tif (!try_module_get(ops->owner))\n\t\treturn -ENODEV;\n\n\tret = ops->of_xlate(dev, iommu_spec);\n\tmodule_put(ops->owner);\n\treturn ret;\n}\n\nstatic int of_iommu_configure_dev_id(struct device_node *master_np,\n\t\t\t\t     struct device *dev,\n\t\t\t\t     const u32 *id)\n{\n\tstruct of_phandle_args iommu_spec = { .args_count = 1 };\n\tint err;\n\n\terr = of_map_id(master_np, *id, \"iommu-map\",\n\t\t\t \"iommu-map-mask\", &iommu_spec.np,\n\t\t\t iommu_spec.args);\n\tif (err)\n\t\treturn err == -ENODEV ? NO_IOMMU : err;\n\n\terr = of_iommu_xlate(dev, &iommu_spec);\n\tof_node_put(iommu_spec.np);\n\treturn err;\n}\n\nstatic int of_iommu_configure_dev(struct device_node *master_np,\n\t\t\t\t  struct device *dev)\n{\n\tstruct of_phandle_args iommu_spec;\n\tint err = NO_IOMMU, idx = 0;\n\n\twhile (!of_parse_phandle_with_args(master_np, \"iommus\",\n\t\t\t\t\t   \"#iommu-cells\",\n\t\t\t\t\t   idx, &iommu_spec)) {\n\t\terr = of_iommu_xlate(dev, &iommu_spec);\n\t\tof_node_put(iommu_spec.np);\n\t\tidx++;\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstruct of_pci_iommu_alias_info {\n\tstruct device *dev;\n\tstruct device_node *np;\n};\n\nstatic int of_pci_iommu_init(struct pci_dev *pdev, u16 alias, void *data)\n{\n\tstruct of_pci_iommu_alias_info *info = data;\n\tu32 input_id = alias;\n\n\treturn of_iommu_configure_dev_id(info->np, info->dev, &input_id);\n}\n\nstatic int of_iommu_configure_device(struct device_node *master_np,\n\t\t\t\t     struct device *dev, const u32 *id)\n{\n\treturn (id) ? of_iommu_configure_dev_id(master_np, dev, id) :\n\t\t      of_iommu_configure_dev(master_np, dev);\n}\n\nconst struct iommu_ops *of_iommu_configure(struct device *dev,\n\t\t\t\t\t   struct device_node *master_np,\n\t\t\t\t\t   const u32 *id)\n{\n\tconst struct iommu_ops *ops = NULL;\n\tstruct iommu_fwspec *fwspec;\n\tint err = NO_IOMMU;\n\n\tif (!master_np)\n\t\treturn NULL;\n\n\t \n\tmutex_lock(&iommu_probe_device_lock);\n\tfwspec = dev_iommu_fwspec_get(dev);\n\tif (fwspec) {\n\t\tif (fwspec->ops) {\n\t\t\tmutex_unlock(&iommu_probe_device_lock);\n\t\t\treturn fwspec->ops;\n\t\t}\n\t\t \n\t\tiommu_fwspec_free(dev);\n\t}\n\n\t \n\tif (dev_is_pci(dev)) {\n\t\tstruct of_pci_iommu_alias_info info = {\n\t\t\t.dev = dev,\n\t\t\t.np = master_np,\n\t\t};\n\n\t\tpci_request_acs();\n\t\terr = pci_for_each_dma_alias(to_pci_dev(dev),\n\t\t\t\t\t     of_pci_iommu_init, &info);\n\t} else {\n\t\terr = of_iommu_configure_device(master_np, dev, id);\n\t}\n\n\t \n\tif (!err) {\n\t\t \n\t\tfwspec = dev_iommu_fwspec_get(dev);\n\t\tops    = fwspec->ops;\n\t}\n\tmutex_unlock(&iommu_probe_device_lock);\n\n\t \n\tif (!err && dev->bus)\n\t\terr = iommu_probe_device(dev);\n\n\t \n\tif (err == -EPROBE_DEFER) {\n\t\tops = ERR_PTR(err);\n\t} else if (err < 0) {\n\t\tdev_dbg(dev, \"Adding to IOMMU failed: %d\\n\", err);\n\t\tops = NULL;\n\t}\n\n\treturn ops;\n}\n\nstatic enum iommu_resv_type __maybe_unused\niommu_resv_region_get_type(struct device *dev,\n\t\t\t   struct resource *phys,\n\t\t\t   phys_addr_t start, size_t length)\n{\n\tphys_addr_t end = start + length - 1;\n\n\t \n\tif (phys->start >= phys->end)\n\t\treturn IOMMU_RESV_RESERVED;\n\n\t \n\tif (start == phys->start && end == phys->end)\n\t\treturn IOMMU_RESV_DIRECT;\n\n\tdev_warn(dev, \"treating non-direct mapping [%pr] -> [%pap-%pap] as reservation\\n\", phys,\n\t\t &start, &end);\n\treturn IOMMU_RESV_RESERVED;\n}\n\n \nvoid of_iommu_get_resv_regions(struct device *dev, struct list_head *list)\n{\n#if IS_ENABLED(CONFIG_OF_ADDRESS)\n\tstruct of_phandle_iterator it;\n\tint err;\n\n\tof_for_each_phandle(&it, err, dev->of_node, \"memory-region\", NULL, 0) {\n\t\tconst __be32 *maps, *end;\n\t\tstruct resource phys;\n\t\tint size;\n\n\t\tmemset(&phys, 0, sizeof(phys));\n\n\t\t \n\t\tif (of_find_property(it.node, \"reg\", NULL)) {\n\t\t\terr = of_address_to_resource(it.node, 0, &phys);\n\t\t\tif (err < 0) {\n\t\t\t\tdev_err(dev, \"failed to parse memory region %pOF: %d\\n\",\n\t\t\t\t\tit.node, err);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tmaps = of_get_property(it.node, \"iommu-addresses\", &size);\n\t\tif (!maps)\n\t\t\tcontinue;\n\n\t\tend = maps + size / sizeof(__be32);\n\n\t\twhile (maps < end) {\n\t\t\tstruct device_node *np;\n\t\t\tu32 phandle;\n\n\t\t\tphandle = be32_to_cpup(maps++);\n\t\t\tnp = of_find_node_by_phandle(phandle);\n\n\t\t\tif (np == dev->of_node) {\n\t\t\t\tint prot = IOMMU_READ | IOMMU_WRITE;\n\t\t\t\tstruct iommu_resv_region *region;\n\t\t\t\tenum iommu_resv_type type;\n\t\t\t\tphys_addr_t iova;\n\t\t\t\tsize_t length;\n\n\t\t\t\tif (of_dma_is_coherent(dev->of_node))\n\t\t\t\t\tprot |= IOMMU_CACHE;\n\n\t\t\t\tmaps = of_translate_dma_region(np, maps, &iova, &length);\n\t\t\t\tif (length == 0) {\n\t\t\t\t\tdev_warn(dev, \"Cannot reserve IOVA region of 0 size\\n\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ttype = iommu_resv_region_get_type(dev, &phys, iova, length);\n\n\t\t\t\tregion = iommu_alloc_resv_region(iova, length, prot, type,\n\t\t\t\t\t\t\t\t GFP_KERNEL);\n\t\t\t\tif (region)\n\t\t\t\t\tlist_add_tail(&region->list, list);\n\t\t\t}\n\t\t}\n\t}\n#endif\n}\nEXPORT_SYMBOL(of_iommu_get_resv_regions);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}