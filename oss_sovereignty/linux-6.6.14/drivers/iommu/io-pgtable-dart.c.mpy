{
  "module_name": "io-pgtable-dart.c",
  "hash_id": "39e1b2e2cca5721b2efa53641ae1966b1a5e8ffc9141c2d6a55e17640c735531",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iommu/io-pgtable-dart.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\t\"dart io-pgtable: \" fmt\n\n#include <linux/atomic.h>\n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/io-pgtable.h>\n#include <linux/kernel.h>\n#include <linux/sizes.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#include <asm/barrier.h>\n\n#define DART1_MAX_ADDR_BITS\t36\n\n#define DART_MAX_TABLES\t\t4\n#define DART_LEVELS\t\t2\n\n \n#define io_pgtable_to_data(x)\t\t\t\t\t\t\\\n\tcontainer_of((x), struct dart_io_pgtable, iop)\n\n#define io_pgtable_ops_to_data(x)\t\t\t\t\t\\\n\tio_pgtable_to_data(io_pgtable_ops_to_pgtable(x))\n\n#define DART_GRANULE(d)\t\t\t\t\t\t\\\n\t(sizeof(dart_iopte) << (d)->bits_per_level)\n#define DART_PTES_PER_TABLE(d)\t\t\t\t\t\\\n\t(DART_GRANULE(d) >> ilog2(sizeof(dart_iopte)))\n\n#define APPLE_DART_PTE_SUBPAGE_START   GENMASK_ULL(63, 52)\n#define APPLE_DART_PTE_SUBPAGE_END     GENMASK_ULL(51, 40)\n\n#define APPLE_DART1_PADDR_MASK\tGENMASK_ULL(35, 12)\n#define APPLE_DART2_PADDR_MASK\tGENMASK_ULL(37, 10)\n#define APPLE_DART2_PADDR_SHIFT\t(4)\n\n \n#define APPLE_DART1_PTE_PROT_NO_READ\tBIT(8)\n#define APPLE_DART1_PTE_PROT_NO_WRITE\tBIT(7)\n#define APPLE_DART1_PTE_PROT_SP_DIS\tBIT(1)\n\n \n#define APPLE_DART2_PTE_PROT_NO_READ\tBIT(3)\n#define APPLE_DART2_PTE_PROT_NO_WRITE\tBIT(2)\n#define APPLE_DART2_PTE_PROT_NO_CACHE\tBIT(1)\n\n \n#define APPLE_DART_PTE_VALID\t\tBIT(0)\n\n \n#define iopte_deref(pte, d) __va(iopte_to_paddr(pte, d))\n\nstruct dart_io_pgtable {\n\tstruct io_pgtable\tiop;\n\n\tint\t\t\ttbl_bits;\n\tint\t\t\tbits_per_level;\n\n\tvoid\t\t\t*pgd[DART_MAX_TABLES];\n};\n\ntypedef u64 dart_iopte;\n\n\nstatic dart_iopte paddr_to_iopte(phys_addr_t paddr,\n\t\t\t\t     struct dart_io_pgtable *data)\n{\n\tdart_iopte pte;\n\n\tif (data->iop.fmt == APPLE_DART)\n\t\treturn paddr & APPLE_DART1_PADDR_MASK;\n\n\t \n\tpte = paddr >> APPLE_DART2_PADDR_SHIFT;\n\tpte &= APPLE_DART2_PADDR_MASK;\n\n\treturn pte;\n}\n\nstatic phys_addr_t iopte_to_paddr(dart_iopte pte,\n\t\t\t\t  struct dart_io_pgtable *data)\n{\n\tu64 paddr;\n\n\tif (data->iop.fmt == APPLE_DART)\n\t\treturn pte & APPLE_DART1_PADDR_MASK;\n\n\t \n\tpaddr = pte & APPLE_DART2_PADDR_MASK;\n\tpaddr <<= APPLE_DART2_PADDR_SHIFT;\n\n\treturn paddr;\n}\n\nstatic void *__dart_alloc_pages(size_t size, gfp_t gfp,\n\t\t\t\t    struct io_pgtable_cfg *cfg)\n{\n\tint order = get_order(size);\n\tstruct page *p;\n\n\tVM_BUG_ON((gfp & __GFP_HIGHMEM));\n\tp = alloc_pages(gfp | __GFP_ZERO, order);\n\tif (!p)\n\t\treturn NULL;\n\n\treturn page_address(p);\n}\n\nstatic int dart_init_pte(struct dart_io_pgtable *data,\n\t\t\t     unsigned long iova, phys_addr_t paddr,\n\t\t\t     dart_iopte prot, int num_entries,\n\t\t\t     dart_iopte *ptep)\n{\n\tint i;\n\tdart_iopte pte = prot;\n\tsize_t sz = data->iop.cfg.pgsize_bitmap;\n\n\tfor (i = 0; i < num_entries; i++)\n\t\tif (ptep[i] & APPLE_DART_PTE_VALID) {\n\t\t\t \n\t\t\tWARN_ON(ptep[i] & APPLE_DART_PTE_VALID);\n\t\t\treturn -EEXIST;\n\t\t}\n\n\t \n\tpte |= FIELD_PREP(APPLE_DART_PTE_SUBPAGE_START, 0);\n\tpte |= FIELD_PREP(APPLE_DART_PTE_SUBPAGE_END, 0xfff);\n\n\tpte |= APPLE_DART1_PTE_PROT_SP_DIS;\n\tpte |= APPLE_DART_PTE_VALID;\n\n\tfor (i = 0; i < num_entries; i++)\n\t\tptep[i] = pte | paddr_to_iopte(paddr + i * sz, data);\n\n\treturn 0;\n}\n\nstatic dart_iopte dart_install_table(dart_iopte *table,\n\t\t\t\t\t     dart_iopte *ptep,\n\t\t\t\t\t     dart_iopte curr,\n\t\t\t\t\t     struct dart_io_pgtable *data)\n{\n\tdart_iopte old, new;\n\n\tnew = paddr_to_iopte(__pa(table), data) | APPLE_DART_PTE_VALID;\n\n\t \n\tdma_wmb();\n\n\told = cmpxchg64_relaxed(ptep, curr, new);\n\n\treturn old;\n}\n\nstatic int dart_get_table(struct dart_io_pgtable *data, unsigned long iova)\n{\n\treturn (iova >> (3 * data->bits_per_level + ilog2(sizeof(dart_iopte)))) &\n\t\t((1 << data->tbl_bits) - 1);\n}\n\nstatic int dart_get_l1_index(struct dart_io_pgtable *data, unsigned long iova)\n{\n\n\treturn (iova >> (2 * data->bits_per_level + ilog2(sizeof(dart_iopte)))) &\n\t\t ((1 << data->bits_per_level) - 1);\n}\n\nstatic int dart_get_l2_index(struct dart_io_pgtable *data, unsigned long iova)\n{\n\n\treturn (iova >> (data->bits_per_level + ilog2(sizeof(dart_iopte)))) &\n\t\t ((1 << data->bits_per_level) - 1);\n}\n\nstatic  dart_iopte *dart_get_l2(struct dart_io_pgtable *data, unsigned long iova)\n{\n\tdart_iopte pte, *ptep;\n\tint tbl = dart_get_table(data, iova);\n\n\tptep = data->pgd[tbl];\n\tif (!ptep)\n\t\treturn NULL;\n\n\tptep += dart_get_l1_index(data, iova);\n\tpte = READ_ONCE(*ptep);\n\n\t \n\tif (!pte)\n\t\treturn NULL;\n\n\t \n\treturn iopte_deref(pte, data);\n}\n\nstatic dart_iopte dart_prot_to_pte(struct dart_io_pgtable *data,\n\t\t\t\t\t   int prot)\n{\n\tdart_iopte pte = 0;\n\n\tif (data->iop.fmt == APPLE_DART) {\n\t\tif (!(prot & IOMMU_WRITE))\n\t\t\tpte |= APPLE_DART1_PTE_PROT_NO_WRITE;\n\t\tif (!(prot & IOMMU_READ))\n\t\t\tpte |= APPLE_DART1_PTE_PROT_NO_READ;\n\t}\n\tif (data->iop.fmt == APPLE_DART2) {\n\t\tif (!(prot & IOMMU_WRITE))\n\t\t\tpte |= APPLE_DART2_PTE_PROT_NO_WRITE;\n\t\tif (!(prot & IOMMU_READ))\n\t\t\tpte |= APPLE_DART2_PTE_PROT_NO_READ;\n\t\tif (!(prot & IOMMU_CACHE))\n\t\t\tpte |= APPLE_DART2_PTE_PROT_NO_CACHE;\n\t}\n\n\treturn pte;\n}\n\nstatic int dart_map_pages(struct io_pgtable_ops *ops, unsigned long iova,\n\t\t\t      phys_addr_t paddr, size_t pgsize, size_t pgcount,\n\t\t\t      int iommu_prot, gfp_t gfp, size_t *mapped)\n{\n\tstruct dart_io_pgtable *data = io_pgtable_ops_to_data(ops);\n\tstruct io_pgtable_cfg *cfg = &data->iop.cfg;\n\tsize_t tblsz = DART_GRANULE(data);\n\tint ret = 0, tbl, num_entries, max_entries, map_idx_start;\n\tdart_iopte pte, *cptep, *ptep;\n\tdart_iopte prot;\n\n\tif (WARN_ON(pgsize != cfg->pgsize_bitmap))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(paddr >> cfg->oas))\n\t\treturn -ERANGE;\n\n\t \n\tif (!(iommu_prot & (IOMMU_READ | IOMMU_WRITE)))\n\t\treturn 0;\n\n\ttbl = dart_get_table(data, iova);\n\n\tptep = data->pgd[tbl];\n\tptep += dart_get_l1_index(data, iova);\n\tpte = READ_ONCE(*ptep);\n\n\t \n\tif (!pte) {\n\t\tcptep = __dart_alloc_pages(tblsz, gfp, cfg);\n\t\tif (!cptep)\n\t\t\treturn -ENOMEM;\n\n\t\tpte = dart_install_table(cptep, ptep, 0, data);\n\t\tif (pte)\n\t\t\tfree_pages((unsigned long)cptep, get_order(tblsz));\n\n\t\t \n\t\tpte = READ_ONCE(*ptep);\n\t}\n\n\tptep = iopte_deref(pte, data);\n\n\t \n\tprot = dart_prot_to_pte(data, iommu_prot);\n\tmap_idx_start = dart_get_l2_index(data, iova);\n\tmax_entries = DART_PTES_PER_TABLE(data) - map_idx_start;\n\tnum_entries = min_t(int, pgcount, max_entries);\n\tptep += map_idx_start;\n\tret = dart_init_pte(data, iova, paddr, prot, num_entries, ptep);\n\tif (!ret && mapped)\n\t\t*mapped += num_entries * pgsize;\n\n\t \n\twmb();\n\n\treturn ret;\n}\n\nstatic size_t dart_unmap_pages(struct io_pgtable_ops *ops, unsigned long iova,\n\t\t\t\t   size_t pgsize, size_t pgcount,\n\t\t\t\t   struct iommu_iotlb_gather *gather)\n{\n\tstruct dart_io_pgtable *data = io_pgtable_ops_to_data(ops);\n\tstruct io_pgtable_cfg *cfg = &data->iop.cfg;\n\tint i = 0, num_entries, max_entries, unmap_idx_start;\n\tdart_iopte pte, *ptep;\n\n\tif (WARN_ON(pgsize != cfg->pgsize_bitmap || !pgcount))\n\t\treturn 0;\n\n\tptep = dart_get_l2(data, iova);\n\n\t \n\tif (WARN_ON(!ptep))\n\t\treturn 0;\n\n\tunmap_idx_start = dart_get_l2_index(data, iova);\n\tptep += unmap_idx_start;\n\n\tmax_entries = DART_PTES_PER_TABLE(data) - unmap_idx_start;\n\tnum_entries = min_t(int, pgcount, max_entries);\n\n\twhile (i < num_entries) {\n\t\tpte = READ_ONCE(*ptep);\n\t\tif (WARN_ON(!pte))\n\t\t\tbreak;\n\n\t\t \n\t\t*ptep = 0;\n\n\t\tif (!iommu_iotlb_gather_queued(gather))\n\t\t\tio_pgtable_tlb_add_page(&data->iop, gather,\n\t\t\t\t\t\tiova + i * pgsize, pgsize);\n\n\t\tptep++;\n\t\ti++;\n\t}\n\n\treturn i * pgsize;\n}\n\nstatic phys_addr_t dart_iova_to_phys(struct io_pgtable_ops *ops,\n\t\t\t\t\t unsigned long iova)\n{\n\tstruct dart_io_pgtable *data = io_pgtable_ops_to_data(ops);\n\tdart_iopte pte, *ptep;\n\n\tptep = dart_get_l2(data, iova);\n\n\t \n\tif (!ptep)\n\t\treturn 0;\n\n\tptep += dart_get_l2_index(data, iova);\n\n\tpte = READ_ONCE(*ptep);\n\t \n\tif (pte) {\n\t\tiova &= (data->iop.cfg.pgsize_bitmap - 1);\n\t\treturn iopte_to_paddr(pte, data) | iova;\n\t}\n\n\t \n\treturn 0;\n}\n\nstatic struct dart_io_pgtable *\ndart_alloc_pgtable(struct io_pgtable_cfg *cfg)\n{\n\tstruct dart_io_pgtable *data;\n\tint tbl_bits, bits_per_level, va_bits, pg_shift;\n\n\tpg_shift = __ffs(cfg->pgsize_bitmap);\n\tbits_per_level = pg_shift - ilog2(sizeof(dart_iopte));\n\n\tva_bits = cfg->ias - pg_shift;\n\n\ttbl_bits = max_t(int, 0, va_bits - (bits_per_level * DART_LEVELS));\n\tif ((1 << tbl_bits) > DART_MAX_TABLES)\n\t\treturn NULL;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn NULL;\n\n\tdata->tbl_bits = tbl_bits;\n\tdata->bits_per_level = bits_per_level;\n\n\tdata->iop.ops = (struct io_pgtable_ops) {\n\t\t.map_pages\t= dart_map_pages,\n\t\t.unmap_pages\t= dart_unmap_pages,\n\t\t.iova_to_phys\t= dart_iova_to_phys,\n\t};\n\n\treturn data;\n}\n\nstatic struct io_pgtable *\napple_dart_alloc_pgtable(struct io_pgtable_cfg *cfg, void *cookie)\n{\n\tstruct dart_io_pgtable *data;\n\tint i;\n\n\tif (!cfg->coherent_walk)\n\t\treturn NULL;\n\n\tif (cfg->oas != 36 && cfg->oas != 42)\n\t\treturn NULL;\n\n\tif (cfg->ias > cfg->oas)\n\t\treturn NULL;\n\n\tif (!(cfg->pgsize_bitmap == SZ_4K || cfg->pgsize_bitmap == SZ_16K))\n\t\treturn NULL;\n\n\tdata = dart_alloc_pgtable(cfg);\n\tif (!data)\n\t\treturn NULL;\n\n\tcfg->apple_dart_cfg.n_ttbrs = 1 << data->tbl_bits;\n\n\tfor (i = 0; i < cfg->apple_dart_cfg.n_ttbrs; ++i) {\n\t\tdata->pgd[i] = __dart_alloc_pages(DART_GRANULE(data), GFP_KERNEL,\n\t\t\t\t\t   cfg);\n\t\tif (!data->pgd[i])\n\t\t\tgoto out_free_data;\n\t\tcfg->apple_dart_cfg.ttbr[i] = virt_to_phys(data->pgd[i]);\n\t}\n\n\treturn &data->iop;\n\nout_free_data:\n\twhile (--i >= 0)\n\t\tfree_pages((unsigned long)data->pgd[i],\n\t\t\t   get_order(DART_GRANULE(data)));\n\tkfree(data);\n\treturn NULL;\n}\n\nstatic void apple_dart_free_pgtable(struct io_pgtable *iop)\n{\n\tstruct dart_io_pgtable *data = io_pgtable_to_data(iop);\n\tdart_iopte *ptep, *end;\n\tint i;\n\n\tfor (i = 0; i < (1 << data->tbl_bits) && data->pgd[i]; ++i) {\n\t\tptep = data->pgd[i];\n\t\tend = (void *)ptep + DART_GRANULE(data);\n\n\t\twhile (ptep != end) {\n\t\t\tdart_iopte pte = *ptep++;\n\n\t\t\tif (pte) {\n\t\t\t\tunsigned long page =\n\t\t\t\t\t(unsigned long)iopte_deref(pte, data);\n\n\t\t\t\tfree_pages(page, get_order(DART_GRANULE(data)));\n\t\t\t}\n\t\t}\n\t\tfree_pages((unsigned long)data->pgd[i],\n\t\t\t   get_order(DART_GRANULE(data)));\n\t}\n\n\tkfree(data);\n}\n\nstruct io_pgtable_init_fns io_pgtable_apple_dart_init_fns = {\n\t.alloc\t= apple_dart_alloc_pgtable,\n\t.free\t= apple_dart_free_pgtable,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}