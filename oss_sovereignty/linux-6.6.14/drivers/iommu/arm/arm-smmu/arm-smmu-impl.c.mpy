{
  "module_name": "arm-smmu-impl.c",
  "hash_id": "cc7ea14b6b38a015656d51c551ce121619efcc54f13ea3c5bef9e7e34276bc90",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iommu/arm/arm-smmu/arm-smmu-impl.c",
  "human_readable_source": "\n\n\n\n#define pr_fmt(fmt) \"arm-smmu: \" fmt\n\n#include <linux/bitfield.h>\n#include <linux/of.h>\n\n#include \"arm-smmu.h\"\n\n\nstatic int arm_smmu_gr0_ns(int offset)\n{\n\tswitch (offset) {\n\tcase ARM_SMMU_GR0_sCR0:\n\tcase ARM_SMMU_GR0_sACR:\n\tcase ARM_SMMU_GR0_sGFSR:\n\tcase ARM_SMMU_GR0_sGFSYNR0:\n\tcase ARM_SMMU_GR0_sGFSYNR1:\n\tcase ARM_SMMU_GR0_sGFSYNR2:\n\t\treturn offset + 0x400;\n\tdefault:\n\t\treturn offset;\n\t}\n}\n\nstatic u32 arm_smmu_read_ns(struct arm_smmu_device *smmu, int page,\n\t\t\t    int offset)\n{\n\tif (page == ARM_SMMU_GR0)\n\t\toffset = arm_smmu_gr0_ns(offset);\n\treturn readl_relaxed(arm_smmu_page(smmu, page) + offset);\n}\n\nstatic void arm_smmu_write_ns(struct arm_smmu_device *smmu, int page,\n\t\t\t      int offset, u32 val)\n{\n\tif (page == ARM_SMMU_GR0)\n\t\toffset = arm_smmu_gr0_ns(offset);\n\twritel_relaxed(val, arm_smmu_page(smmu, page) + offset);\n}\n\n \nstatic const struct arm_smmu_impl calxeda_impl = {\n\t.read_reg = arm_smmu_read_ns,\n\t.write_reg = arm_smmu_write_ns,\n};\n\n\nstruct cavium_smmu {\n\tstruct arm_smmu_device smmu;\n\tu32 id_base;\n};\n\nstatic int cavium_cfg_probe(struct arm_smmu_device *smmu)\n{\n\tstatic atomic_t context_count = ATOMIC_INIT(0);\n\tstruct cavium_smmu *cs = container_of(smmu, struct cavium_smmu, smmu);\n\t \n\tcs->id_base = atomic_fetch_add(smmu->num_context_banks, &context_count);\n\tdev_notice(smmu->dev, \"\\tenabling workaround for Cavium erratum 27704\\n\");\n\n\treturn 0;\n}\n\nstatic int cavium_init_context(struct arm_smmu_domain *smmu_domain,\n\t\tstruct io_pgtable_cfg *pgtbl_cfg, struct device *dev)\n{\n\tstruct cavium_smmu *cs = container_of(smmu_domain->smmu,\n\t\t\t\t\t      struct cavium_smmu, smmu);\n\n\tif (smmu_domain->stage == ARM_SMMU_DOMAIN_S2)\n\t\tsmmu_domain->cfg.vmid += cs->id_base;\n\telse\n\t\tsmmu_domain->cfg.asid += cs->id_base;\n\n\treturn 0;\n}\n\nstatic const struct arm_smmu_impl cavium_impl = {\n\t.cfg_probe = cavium_cfg_probe,\n\t.init_context = cavium_init_context,\n};\n\nstatic struct arm_smmu_device *cavium_smmu_impl_init(struct arm_smmu_device *smmu)\n{\n\tstruct cavium_smmu *cs;\n\n\tcs = devm_krealloc(smmu->dev, smmu, sizeof(*cs), GFP_KERNEL);\n\tif (!cs)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcs->smmu.impl = &cavium_impl;\n\n\treturn &cs->smmu;\n}\n\n\n#define ARM_MMU500_ACTLR_CPRE\t\t(1 << 1)\n\n#define ARM_MMU500_ACR_CACHE_LOCK\t(1 << 26)\n#define ARM_MMU500_ACR_S2CRB_TLBEN\t(1 << 10)\n#define ARM_MMU500_ACR_SMTNMB_TLBEN\t(1 << 8)\n\nint arm_mmu500_reset(struct arm_smmu_device *smmu)\n{\n\tu32 reg, major;\n\tint i;\n\t \n\treg = arm_smmu_gr0_read(smmu, ARM_SMMU_GR0_ID7);\n\tmajor = FIELD_GET(ARM_SMMU_ID7_MAJOR, reg);\n\treg = arm_smmu_gr0_read(smmu, ARM_SMMU_GR0_sACR);\n\tif (major >= 2)\n\t\treg &= ~ARM_MMU500_ACR_CACHE_LOCK;\n\t \n\treg |= ARM_MMU500_ACR_SMTNMB_TLBEN | ARM_MMU500_ACR_S2CRB_TLBEN;\n\tarm_smmu_gr0_write(smmu, ARM_SMMU_GR0_sACR, reg);\n\n\t \n\tfor (i = 0; i < smmu->num_context_banks; ++i) {\n\t\treg = arm_smmu_cb_read(smmu, i, ARM_SMMU_CB_ACTLR);\n\t\treg &= ~ARM_MMU500_ACTLR_CPRE;\n\t\tarm_smmu_cb_write(smmu, i, ARM_SMMU_CB_ACTLR, reg);\n\t\treg = arm_smmu_cb_read(smmu, i, ARM_SMMU_CB_ACTLR);\n\t\tif (reg & ARM_MMU500_ACTLR_CPRE)\n\t\t\tdev_warn_once(smmu->dev, \"Failed to disable prefetcher [errata #841119 and #826419], check ACR.CACHE_LOCK\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic const struct arm_smmu_impl arm_mmu500_impl = {\n\t.reset = arm_mmu500_reset,\n};\n\nstatic u64 mrvl_mmu500_readq(struct arm_smmu_device *smmu, int page, int off)\n{\n\t \n\treturn hi_lo_readq_relaxed(arm_smmu_page(smmu, page) + off);\n}\n\nstatic void mrvl_mmu500_writeq(struct arm_smmu_device *smmu, int page, int off,\n\t\t\t       u64 val)\n{\n\t \n\thi_lo_writeq_relaxed(val, arm_smmu_page(smmu, page) + off);\n}\n\nstatic int mrvl_mmu500_cfg_probe(struct arm_smmu_device *smmu)\n{\n\n\t \n\tsmmu->features &= ~(ARM_SMMU_FEAT_FMT_AARCH64_4K |\n\t\t\t    ARM_SMMU_FEAT_FMT_AARCH64_16K |\n\t\t\t    ARM_SMMU_FEAT_FMT_AARCH64_64K);\n\n\treturn 0;\n}\n\nstatic const struct arm_smmu_impl mrvl_mmu500_impl = {\n\t.read_reg64 = mrvl_mmu500_readq,\n\t.write_reg64 = mrvl_mmu500_writeq,\n\t.cfg_probe = mrvl_mmu500_cfg_probe,\n\t.reset = arm_mmu500_reset,\n};\n\n\nstruct arm_smmu_device *arm_smmu_impl_init(struct arm_smmu_device *smmu)\n{\n\tconst struct device_node *np = smmu->dev->of_node;\n\n\t \n\tswitch (smmu->model) {\n\tcase ARM_MMU500:\n\t\tsmmu->impl = &arm_mmu500_impl;\n\t\tbreak;\n\tcase CAVIUM_SMMUV2:\n\t\treturn cavium_smmu_impl_init(smmu);\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tif (of_property_read_bool(np, \"calxeda,smmu-secure-config-access\"))\n\t\tsmmu->impl = &calxeda_impl;\n\n\tif (of_device_is_compatible(np, \"nvidia,tegra234-smmu\") ||\n\t    of_device_is_compatible(np, \"nvidia,tegra194-smmu\") ||\n\t    of_device_is_compatible(np, \"nvidia,tegra186-smmu\"))\n\t\treturn nvidia_smmu_impl_init(smmu);\n\n\tif (IS_ENABLED(CONFIG_ARM_SMMU_QCOM))\n\t\tsmmu = qcom_smmu_impl_init(smmu);\n\n\tif (of_device_is_compatible(np, \"marvell,ap806-smmu-500\"))\n\t\tsmmu->impl = &mrvl_mmu500_impl;\n\n\treturn smmu;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}