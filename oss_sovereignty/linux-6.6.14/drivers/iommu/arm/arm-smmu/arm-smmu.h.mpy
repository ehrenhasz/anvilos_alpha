{
  "module_name": "arm-smmu.h",
  "hash_id": "b18bf1b72fbbec7fedd1fa7d1eb450d41982b9bc740a485079df11b614f95835",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iommu/arm/arm-smmu/arm-smmu.h",
  "human_readable_source": " \n \n\n#ifndef _ARM_SMMU_H\n#define _ARM_SMMU_H\n\n#include <linux/atomic.h>\n#include <linux/bitfield.h>\n#include <linux/bits.h>\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/io-64-nonatomic-hi-lo.h>\n#include <linux/io-pgtable.h>\n#include <linux/iommu.h>\n#include <linux/irqreturn.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n\n \n#define ARM_SMMU_GR0_sCR0\t\t0x0\n#define ARM_SMMU_sCR0_VMID16EN\t\tBIT(31)\n#define ARM_SMMU_sCR0_BSU\t\tGENMASK(15, 14)\n#define ARM_SMMU_sCR0_FB\t\tBIT(13)\n#define ARM_SMMU_sCR0_PTM\t\tBIT(12)\n#define ARM_SMMU_sCR0_VMIDPNE\t\tBIT(11)\n#define ARM_SMMU_sCR0_USFCFG\t\tBIT(10)\n#define ARM_SMMU_sCR0_GCFGFIE\t\tBIT(5)\n#define ARM_SMMU_sCR0_GCFGFRE\t\tBIT(4)\n#define ARM_SMMU_sCR0_EXIDENABLE\tBIT(3)\n#define ARM_SMMU_sCR0_GFIE\t\tBIT(2)\n#define ARM_SMMU_sCR0_GFRE\t\tBIT(1)\n#define ARM_SMMU_sCR0_CLIENTPD\t\tBIT(0)\n\n \n#define ARM_SMMU_GR0_sACR\t\t0x10\n\n \n#define ARM_SMMU_GR0_ID0\t\t0x20\n#define ARM_SMMU_ID0_S1TS\t\tBIT(30)\n#define ARM_SMMU_ID0_S2TS\t\tBIT(29)\n#define ARM_SMMU_ID0_NTS\t\tBIT(28)\n#define ARM_SMMU_ID0_SMS\t\tBIT(27)\n#define ARM_SMMU_ID0_ATOSNS\t\tBIT(26)\n#define ARM_SMMU_ID0_PTFS_NO_AARCH32\tBIT(25)\n#define ARM_SMMU_ID0_PTFS_NO_AARCH32S\tBIT(24)\n#define ARM_SMMU_ID0_NUMIRPT\t\tGENMASK(23, 16)\n#define ARM_SMMU_ID0_CTTW\t\tBIT(14)\n#define ARM_SMMU_ID0_NUMSIDB\t\tGENMASK(12, 9)\n#define ARM_SMMU_ID0_EXIDS\t\tBIT(8)\n#define ARM_SMMU_ID0_NUMSMRG\t\tGENMASK(7, 0)\n\n#define ARM_SMMU_GR0_ID1\t\t0x24\n#define ARM_SMMU_ID1_PAGESIZE\t\tBIT(31)\n#define ARM_SMMU_ID1_NUMPAGENDXB\tGENMASK(30, 28)\n#define ARM_SMMU_ID1_NUMS2CB\t\tGENMASK(23, 16)\n#define ARM_SMMU_ID1_NUMCB\t\tGENMASK(7, 0)\n\n#define ARM_SMMU_GR0_ID2\t\t0x28\n#define ARM_SMMU_ID2_VMID16\t\tBIT(15)\n#define ARM_SMMU_ID2_PTFS_64K\t\tBIT(14)\n#define ARM_SMMU_ID2_PTFS_16K\t\tBIT(13)\n#define ARM_SMMU_ID2_PTFS_4K\t\tBIT(12)\n#define ARM_SMMU_ID2_UBS\t\tGENMASK(11, 8)\n#define ARM_SMMU_ID2_OAS\t\tGENMASK(7, 4)\n#define ARM_SMMU_ID2_IAS\t\tGENMASK(3, 0)\n\n#define ARM_SMMU_GR0_ID3\t\t0x2c\n#define ARM_SMMU_GR0_ID4\t\t0x30\n#define ARM_SMMU_GR0_ID5\t\t0x34\n#define ARM_SMMU_GR0_ID6\t\t0x38\n\n#define ARM_SMMU_GR0_ID7\t\t0x3c\n#define ARM_SMMU_ID7_MAJOR\t\tGENMASK(7, 4)\n#define ARM_SMMU_ID7_MINOR\t\tGENMASK(3, 0)\n\n#define ARM_SMMU_GR0_sGFSR\t\t0x48\n#define ARM_SMMU_sGFSR_USF\t\tBIT(1)\n\n#define ARM_SMMU_GR0_sGFSYNR0\t\t0x50\n#define ARM_SMMU_GR0_sGFSYNR1\t\t0x54\n#define ARM_SMMU_GR0_sGFSYNR2\t\t0x58\n\n \n#define ARM_SMMU_GR0_TLBIVMID\t\t0x64\n#define ARM_SMMU_GR0_TLBIALLNSNH\t0x68\n#define ARM_SMMU_GR0_TLBIALLH\t\t0x6c\n#define ARM_SMMU_GR0_sTLBGSYNC\t\t0x70\n\n#define ARM_SMMU_GR0_sTLBGSTATUS\t0x74\n#define ARM_SMMU_sTLBGSTATUS_GSACTIVE\tBIT(0)\n\n \n#define ARM_SMMU_GR0_SMR(n)\t\t(0x800 + ((n) << 2))\n#define ARM_SMMU_SMR_VALID\t\tBIT(31)\n#define ARM_SMMU_SMR_MASK\t\tGENMASK(31, 16)\n#define ARM_SMMU_SMR_ID\t\t\tGENMASK(15, 0)\n\n#define ARM_SMMU_GR0_S2CR(n)\t\t(0xc00 + ((n) << 2))\n#define ARM_SMMU_S2CR_PRIVCFG\t\tGENMASK(25, 24)\nenum arm_smmu_s2cr_privcfg {\n\tS2CR_PRIVCFG_DEFAULT,\n\tS2CR_PRIVCFG_DIPAN,\n\tS2CR_PRIVCFG_UNPRIV,\n\tS2CR_PRIVCFG_PRIV,\n};\n#define ARM_SMMU_S2CR_TYPE\t\tGENMASK(17, 16)\nenum arm_smmu_s2cr_type {\n\tS2CR_TYPE_TRANS,\n\tS2CR_TYPE_BYPASS,\n\tS2CR_TYPE_FAULT,\n};\n#define ARM_SMMU_S2CR_EXIDVALID\t\tBIT(10)\n#define ARM_SMMU_S2CR_CBNDX\t\tGENMASK(7, 0)\n\n \n#define ARM_SMMU_GR1_CBAR(n)\t\t(0x0 + ((n) << 2))\n#define ARM_SMMU_CBAR_IRPTNDX\t\tGENMASK(31, 24)\n#define ARM_SMMU_CBAR_TYPE\t\tGENMASK(17, 16)\nenum arm_smmu_cbar_type {\n\tCBAR_TYPE_S2_TRANS,\n\tCBAR_TYPE_S1_TRANS_S2_BYPASS,\n\tCBAR_TYPE_S1_TRANS_S2_FAULT,\n\tCBAR_TYPE_S1_TRANS_S2_TRANS,\n};\n#define ARM_SMMU_CBAR_S1_MEMATTR\tGENMASK(15, 12)\n#define ARM_SMMU_CBAR_S1_MEMATTR_WB\t0xf\n#define ARM_SMMU_CBAR_S1_BPSHCFG\tGENMASK(9, 8)\n#define ARM_SMMU_CBAR_S1_BPSHCFG_NSH\t3\n#define ARM_SMMU_CBAR_VMID\t\tGENMASK(7, 0)\n\n#define ARM_SMMU_GR1_CBFRSYNRA(n)\t(0x400 + ((n) << 2))\n\n#define ARM_SMMU_GR1_CBA2R(n)\t\t(0x800 + ((n) << 2))\n#define ARM_SMMU_CBA2R_VMID16\t\tGENMASK(31, 16)\n#define ARM_SMMU_CBA2R_VA64\t\tBIT(0)\n\n#define ARM_SMMU_CB_SCTLR\t\t0x0\n#define ARM_SMMU_SCTLR_S1_ASIDPNE\tBIT(12)\n#define ARM_SMMU_SCTLR_CFCFG\t\tBIT(7)\n#define ARM_SMMU_SCTLR_HUPCF\t\tBIT(8)\n#define ARM_SMMU_SCTLR_CFIE\t\tBIT(6)\n#define ARM_SMMU_SCTLR_CFRE\t\tBIT(5)\n#define ARM_SMMU_SCTLR_E\t\tBIT(4)\n#define ARM_SMMU_SCTLR_AFE\t\tBIT(2)\n#define ARM_SMMU_SCTLR_TRE\t\tBIT(1)\n#define ARM_SMMU_SCTLR_M\t\tBIT(0)\n\n#define ARM_SMMU_CB_ACTLR\t\t0x4\n\n#define ARM_SMMU_CB_RESUME\t\t0x8\n#define ARM_SMMU_RESUME_TERMINATE\tBIT(0)\n\n#define ARM_SMMU_CB_TCR2\t\t0x10\n#define ARM_SMMU_TCR2_SEP\t\tGENMASK(17, 15)\n#define ARM_SMMU_TCR2_SEP_UPSTREAM\t0x7\n#define ARM_SMMU_TCR2_AS\t\tBIT(4)\n#define ARM_SMMU_TCR2_PASIZE\t\tGENMASK(3, 0)\n\n#define ARM_SMMU_CB_TTBR0\t\t0x20\n#define ARM_SMMU_CB_TTBR1\t\t0x28\n#define ARM_SMMU_TTBRn_ASID\t\tGENMASK_ULL(63, 48)\n\n#define ARM_SMMU_CB_TCR\t\t\t0x30\n#define ARM_SMMU_TCR_EAE\t\tBIT(31)\n#define ARM_SMMU_TCR_EPD1\t\tBIT(23)\n#define ARM_SMMU_TCR_A1\t\t\tBIT(22)\n#define ARM_SMMU_TCR_TG0\t\tGENMASK(15, 14)\n#define ARM_SMMU_TCR_SH0\t\tGENMASK(13, 12)\n#define ARM_SMMU_TCR_ORGN0\t\tGENMASK(11, 10)\n#define ARM_SMMU_TCR_IRGN0\t\tGENMASK(9, 8)\n#define ARM_SMMU_TCR_EPD0\t\tBIT(7)\n#define ARM_SMMU_TCR_T0SZ\t\tGENMASK(5, 0)\n\n#define ARM_SMMU_VTCR_RES1\t\tBIT(31)\n#define ARM_SMMU_VTCR_PS\t\tGENMASK(18, 16)\n#define ARM_SMMU_VTCR_TG0\t\tARM_SMMU_TCR_TG0\n#define ARM_SMMU_VTCR_SH0\t\tARM_SMMU_TCR_SH0\n#define ARM_SMMU_VTCR_ORGN0\t\tARM_SMMU_TCR_ORGN0\n#define ARM_SMMU_VTCR_IRGN0\t\tARM_SMMU_TCR_IRGN0\n#define ARM_SMMU_VTCR_SL0\t\tGENMASK(7, 6)\n#define ARM_SMMU_VTCR_T0SZ\t\tARM_SMMU_TCR_T0SZ\n\n#define ARM_SMMU_CB_CONTEXTIDR\t\t0x34\n#define ARM_SMMU_CB_S1_MAIR0\t\t0x38\n#define ARM_SMMU_CB_S1_MAIR1\t\t0x3c\n\n#define ARM_SMMU_CB_PAR\t\t\t0x50\n#define ARM_SMMU_CB_PAR_F\t\tBIT(0)\n\n#define ARM_SMMU_CB_FSR\t\t\t0x58\n#define ARM_SMMU_FSR_MULTI\t\tBIT(31)\n#define ARM_SMMU_FSR_SS\t\t\tBIT(30)\n#define ARM_SMMU_FSR_UUT\t\tBIT(8)\n#define ARM_SMMU_FSR_ASF\t\tBIT(7)\n#define ARM_SMMU_FSR_TLBLKF\t\tBIT(6)\n#define ARM_SMMU_FSR_TLBMCF\t\tBIT(5)\n#define ARM_SMMU_FSR_EF\t\t\tBIT(4)\n#define ARM_SMMU_FSR_PF\t\t\tBIT(3)\n#define ARM_SMMU_FSR_AFF\t\tBIT(2)\n#define ARM_SMMU_FSR_TF\t\t\tBIT(1)\n\n#define ARM_SMMU_FSR_IGN\t\t(ARM_SMMU_FSR_AFF |\t\t\\\n\t\t\t\t\t ARM_SMMU_FSR_ASF |\t\t\\\n\t\t\t\t\t ARM_SMMU_FSR_TLBMCF |\t\t\\\n\t\t\t\t\t ARM_SMMU_FSR_TLBLKF)\n\n#define ARM_SMMU_FSR_FAULT\t\t(ARM_SMMU_FSR_MULTI |\t\t\\\n\t\t\t\t\t ARM_SMMU_FSR_SS |\t\t\\\n\t\t\t\t\t ARM_SMMU_FSR_UUT |\t\t\\\n\t\t\t\t\t ARM_SMMU_FSR_EF |\t\t\\\n\t\t\t\t\t ARM_SMMU_FSR_PF |\t\t\\\n\t\t\t\t\t ARM_SMMU_FSR_TF |\t\t\\\n\t\t\t\t\t ARM_SMMU_FSR_IGN)\n\n#define ARM_SMMU_CB_FAR\t\t\t0x60\n\n#define ARM_SMMU_CB_FSYNR0\t\t0x68\n#define ARM_SMMU_FSYNR0_WNR\t\tBIT(4)\n\n#define ARM_SMMU_CB_FSYNR1\t\t0x6c\n\n#define ARM_SMMU_CB_S1_TLBIVA\t\t0x600\n#define ARM_SMMU_CB_S1_TLBIASID\t\t0x610\n#define ARM_SMMU_CB_S1_TLBIVAL\t\t0x620\n#define ARM_SMMU_CB_S2_TLBIIPAS2\t0x630\n#define ARM_SMMU_CB_S2_TLBIIPAS2L\t0x638\n#define ARM_SMMU_CB_TLBSYNC\t\t0x7f0\n#define ARM_SMMU_CB_TLBSTATUS\t\t0x7f4\n#define ARM_SMMU_CB_ATS1PR\t\t0x800\n\n#define ARM_SMMU_CB_ATSR\t\t0x8f0\n#define ARM_SMMU_ATSR_ACTIVE\t\tBIT(0)\n\n\n \n#define ARM_SMMU_MAX_CBS\t\t128\n\n#define TLB_LOOP_TIMEOUT\t\t1000000\t \n#define TLB_SPIN_COUNT\t\t\t10\n\n \nenum arm_smmu_arch_version {\n\tARM_SMMU_V1,\n\tARM_SMMU_V1_64K,\n\tARM_SMMU_V2,\n};\n\nenum arm_smmu_implementation {\n\tGENERIC_SMMU,\n\tARM_MMU500,\n\tCAVIUM_SMMUV2,\n\tQCOM_SMMUV2,\n};\n\nstruct arm_smmu_s2cr {\n\tstruct iommu_group\t\t*group;\n\tint\t\t\t\tcount;\n\tenum arm_smmu_s2cr_type\t\ttype;\n\tenum arm_smmu_s2cr_privcfg\tprivcfg;\n\tu8\t\t\t\tcbndx;\n};\n\nstruct arm_smmu_smr {\n\tu16\t\t\t\tmask;\n\tu16\t\t\t\tid;\n\tbool\t\t\t\tvalid;\n\tbool\t\t\t\tpinned;\n};\n\nstruct arm_smmu_device {\n\tstruct device\t\t\t*dev;\n\n\tvoid __iomem\t\t\t*base;\n\tphys_addr_t\t\t\tioaddr;\n\tunsigned int\t\t\tnumpage;\n\tunsigned int\t\t\tpgshift;\n\n#define ARM_SMMU_FEAT_COHERENT_WALK\t(1 << 0)\n#define ARM_SMMU_FEAT_STREAM_MATCH\t(1 << 1)\n#define ARM_SMMU_FEAT_TRANS_S1\t\t(1 << 2)\n#define ARM_SMMU_FEAT_TRANS_S2\t\t(1 << 3)\n#define ARM_SMMU_FEAT_TRANS_NESTED\t(1 << 4)\n#define ARM_SMMU_FEAT_TRANS_OPS\t\t(1 << 5)\n#define ARM_SMMU_FEAT_VMID16\t\t(1 << 6)\n#define ARM_SMMU_FEAT_FMT_AARCH64_4K\t(1 << 7)\n#define ARM_SMMU_FEAT_FMT_AARCH64_16K\t(1 << 8)\n#define ARM_SMMU_FEAT_FMT_AARCH64_64K\t(1 << 9)\n#define ARM_SMMU_FEAT_FMT_AARCH32_L\t(1 << 10)\n#define ARM_SMMU_FEAT_FMT_AARCH32_S\t(1 << 11)\n#define ARM_SMMU_FEAT_EXIDS\t\t(1 << 12)\n\tu32\t\t\t\tfeatures;\n\n\tenum arm_smmu_arch_version\tversion;\n\tenum arm_smmu_implementation\tmodel;\n\tconst struct arm_smmu_impl\t*impl;\n\n\tu32\t\t\t\tnum_context_banks;\n\tu32\t\t\t\tnum_s2_context_banks;\n\tDECLARE_BITMAP(context_map, ARM_SMMU_MAX_CBS);\n\tstruct arm_smmu_cb\t\t*cbs;\n\tatomic_t\t\t\tirptndx;\n\n\tu32\t\t\t\tnum_mapping_groups;\n\tu16\t\t\t\tstreamid_mask;\n\tu16\t\t\t\tsmr_mask_mask;\n\tstruct arm_smmu_smr\t\t*smrs;\n\tstruct arm_smmu_s2cr\t\t*s2crs;\n\tstruct mutex\t\t\tstream_map_mutex;\n\n\tunsigned long\t\t\tva_size;\n\tunsigned long\t\t\tipa_size;\n\tunsigned long\t\t\tpa_size;\n\tunsigned long\t\t\tpgsize_bitmap;\n\n\tint\t\t\t\tnum_context_irqs;\n\tint\t\t\t\tnum_clks;\n\tunsigned int\t\t\t*irqs;\n\tstruct clk_bulk_data\t\t*clks;\n\n\tspinlock_t\t\t\tglobal_sync_lock;\n\n\t \n\tstruct iommu_device\t\tiommu;\n};\n\nenum arm_smmu_context_fmt {\n\tARM_SMMU_CTX_FMT_NONE,\n\tARM_SMMU_CTX_FMT_AARCH64,\n\tARM_SMMU_CTX_FMT_AARCH32_L,\n\tARM_SMMU_CTX_FMT_AARCH32_S,\n};\n\nstruct arm_smmu_cfg {\n\tu8\t\t\t\tcbndx;\n\tu8\t\t\t\tirptndx;\n\tunion {\n\t\tu16\t\t\tasid;\n\t\tu16\t\t\tvmid;\n\t};\n\tenum arm_smmu_cbar_type\t\tcbar;\n\tenum arm_smmu_context_fmt\tfmt;\n\tbool\t\t\t\tflush_walk_prefer_tlbiasid;\n};\n#define ARM_SMMU_INVALID_IRPTNDX\t0xff\n\nstruct arm_smmu_cb {\n\tu64\t\t\t\tttbr[2];\n\tu32\t\t\t\ttcr[2];\n\tu32\t\t\t\tmair[2];\n\tstruct arm_smmu_cfg\t\t*cfg;\n};\n\nenum arm_smmu_domain_stage {\n\tARM_SMMU_DOMAIN_S1 = 0,\n\tARM_SMMU_DOMAIN_S2,\n\tARM_SMMU_DOMAIN_NESTED,\n\tARM_SMMU_DOMAIN_BYPASS,\n};\n\nstruct arm_smmu_domain {\n\tstruct arm_smmu_device\t\t*smmu;\n\tstruct io_pgtable_ops\t\t*pgtbl_ops;\n\tunsigned long\t\t\tpgtbl_quirks;\n\tconst struct iommu_flush_ops\t*flush_ops;\n\tstruct arm_smmu_cfg\t\tcfg;\n\tenum arm_smmu_domain_stage\tstage;\n\tstruct mutex\t\t\tinit_mutex;  \n\tspinlock_t\t\t\tcb_lock;  \n\tstruct iommu_domain\t\tdomain;\n};\n\nstruct arm_smmu_master_cfg {\n\tstruct arm_smmu_device\t\t*smmu;\n\ts16\t\t\t\tsmendx[];\n};\n\nstatic inline u32 arm_smmu_lpae_tcr(const struct io_pgtable_cfg *cfg)\n{\n\tu32 tcr = FIELD_PREP(ARM_SMMU_TCR_TG0, cfg->arm_lpae_s1_cfg.tcr.tg) |\n\t\tFIELD_PREP(ARM_SMMU_TCR_SH0, cfg->arm_lpae_s1_cfg.tcr.sh) |\n\t\tFIELD_PREP(ARM_SMMU_TCR_ORGN0, cfg->arm_lpae_s1_cfg.tcr.orgn) |\n\t\tFIELD_PREP(ARM_SMMU_TCR_IRGN0, cfg->arm_lpae_s1_cfg.tcr.irgn) |\n\t\tFIELD_PREP(ARM_SMMU_TCR_T0SZ, cfg->arm_lpae_s1_cfg.tcr.tsz);\n\n        \n\tif (cfg->quirks & IO_PGTABLE_QUIRK_ARM_TTBR1) {\n\t\ttcr = (tcr << 16) & ~ARM_SMMU_TCR_A1;\n\t\ttcr |= ARM_SMMU_TCR_EPD0;\n\t} else\n\t\ttcr |= ARM_SMMU_TCR_EPD1;\n\n\treturn tcr;\n}\n\nstatic inline u32 arm_smmu_lpae_tcr2(const struct io_pgtable_cfg *cfg)\n{\n\treturn FIELD_PREP(ARM_SMMU_TCR2_PASIZE, cfg->arm_lpae_s1_cfg.tcr.ips) |\n\t       FIELD_PREP(ARM_SMMU_TCR2_SEP, ARM_SMMU_TCR2_SEP_UPSTREAM);\n}\n\nstatic inline u32 arm_smmu_lpae_vtcr(const struct io_pgtable_cfg *cfg)\n{\n\treturn ARM_SMMU_VTCR_RES1 |\n\t       FIELD_PREP(ARM_SMMU_VTCR_PS, cfg->arm_lpae_s2_cfg.vtcr.ps) |\n\t       FIELD_PREP(ARM_SMMU_VTCR_TG0, cfg->arm_lpae_s2_cfg.vtcr.tg) |\n\t       FIELD_PREP(ARM_SMMU_VTCR_SH0, cfg->arm_lpae_s2_cfg.vtcr.sh) |\n\t       FIELD_PREP(ARM_SMMU_VTCR_ORGN0, cfg->arm_lpae_s2_cfg.vtcr.orgn) |\n\t       FIELD_PREP(ARM_SMMU_VTCR_IRGN0, cfg->arm_lpae_s2_cfg.vtcr.irgn) |\n\t       FIELD_PREP(ARM_SMMU_VTCR_SL0, cfg->arm_lpae_s2_cfg.vtcr.sl) |\n\t       FIELD_PREP(ARM_SMMU_VTCR_T0SZ, cfg->arm_lpae_s2_cfg.vtcr.tsz);\n}\n\n \nstruct arm_smmu_impl {\n\tu32 (*read_reg)(struct arm_smmu_device *smmu, int page, int offset);\n\tvoid (*write_reg)(struct arm_smmu_device *smmu, int page, int offset,\n\t\t\t  u32 val);\n\tu64 (*read_reg64)(struct arm_smmu_device *smmu, int page, int offset);\n\tvoid (*write_reg64)(struct arm_smmu_device *smmu, int page, int offset,\n\t\t\t    u64 val);\n\tint (*cfg_probe)(struct arm_smmu_device *smmu);\n\tint (*reset)(struct arm_smmu_device *smmu);\n\tint (*init_context)(struct arm_smmu_domain *smmu_domain,\n\t\t\tstruct io_pgtable_cfg *cfg, struct device *dev);\n\tvoid (*tlb_sync)(struct arm_smmu_device *smmu, int page, int sync,\n\t\t\t int status);\n\tint (*def_domain_type)(struct device *dev);\n\tirqreturn_t (*global_fault)(int irq, void *dev);\n\tirqreturn_t (*context_fault)(int irq, void *dev);\n\tint (*alloc_context_bank)(struct arm_smmu_domain *smmu_domain,\n\t\t\t\t  struct arm_smmu_device *smmu,\n\t\t\t\t  struct device *dev, int start);\n\tvoid (*write_s2cr)(struct arm_smmu_device *smmu, int idx);\n\tvoid (*write_sctlr)(struct arm_smmu_device *smmu, int idx, u32 reg);\n\tvoid (*probe_finalize)(struct arm_smmu_device *smmu, struct device *dev);\n};\n\n#define INVALID_SMENDX\t\t\t-1\n#define cfg_smendx(cfg, fw, i) \\\n\t(i >= fw->num_ids ? INVALID_SMENDX : cfg->smendx[i])\n#define for_each_cfg_sme(cfg, fw, i, idx) \\\n\tfor (i = 0; idx = cfg_smendx(cfg, fw, i), i < fw->num_ids; ++i)\n\nstatic inline int __arm_smmu_alloc_bitmap(unsigned long *map, int start, int end)\n{\n\tint idx;\n\n\tdo {\n\t\tidx = find_next_zero_bit(map, end, start);\n\t\tif (idx == end)\n\t\t\treturn -ENOSPC;\n\t} while (test_and_set_bit(idx, map));\n\n\treturn idx;\n}\n\nstatic inline void __iomem *arm_smmu_page(struct arm_smmu_device *smmu, int n)\n{\n\treturn smmu->base + (n << smmu->pgshift);\n}\n\nstatic inline u32 arm_smmu_readl(struct arm_smmu_device *smmu, int page, int offset)\n{\n\tif (smmu->impl && unlikely(smmu->impl->read_reg))\n\t\treturn smmu->impl->read_reg(smmu, page, offset);\n\treturn readl_relaxed(arm_smmu_page(smmu, page) + offset);\n}\n\nstatic inline void arm_smmu_writel(struct arm_smmu_device *smmu, int page,\n\t\t\t\t   int offset, u32 val)\n{\n\tif (smmu->impl && unlikely(smmu->impl->write_reg))\n\t\tsmmu->impl->write_reg(smmu, page, offset, val);\n\telse\n\t\twritel_relaxed(val, arm_smmu_page(smmu, page) + offset);\n}\n\nstatic inline u64 arm_smmu_readq(struct arm_smmu_device *smmu, int page, int offset)\n{\n\tif (smmu->impl && unlikely(smmu->impl->read_reg64))\n\t\treturn smmu->impl->read_reg64(smmu, page, offset);\n\treturn readq_relaxed(arm_smmu_page(smmu, page) + offset);\n}\n\nstatic inline void arm_smmu_writeq(struct arm_smmu_device *smmu, int page,\n\t\t\t\t   int offset, u64 val)\n{\n\tif (smmu->impl && unlikely(smmu->impl->write_reg64))\n\t\tsmmu->impl->write_reg64(smmu, page, offset, val);\n\telse\n\t\twriteq_relaxed(val, arm_smmu_page(smmu, page) + offset);\n}\n\n#define ARM_SMMU_GR0\t\t0\n#define ARM_SMMU_GR1\t\t1\n#define ARM_SMMU_CB(s, n)\t((s)->numpage + (n))\n\n#define arm_smmu_gr0_read(s, o)\t\t\\\n\tarm_smmu_readl((s), ARM_SMMU_GR0, (o))\n#define arm_smmu_gr0_write(s, o, v)\t\\\n\tarm_smmu_writel((s), ARM_SMMU_GR0, (o), (v))\n\n#define arm_smmu_gr1_read(s, o)\t\t\\\n\tarm_smmu_readl((s), ARM_SMMU_GR1, (o))\n#define arm_smmu_gr1_write(s, o, v)\t\\\n\tarm_smmu_writel((s), ARM_SMMU_GR1, (o), (v))\n\n#define arm_smmu_cb_read(s, n, o)\t\\\n\tarm_smmu_readl((s), ARM_SMMU_CB((s), (n)), (o))\n#define arm_smmu_cb_write(s, n, o, v)\t\\\n\tarm_smmu_writel((s), ARM_SMMU_CB((s), (n)), (o), (v))\n#define arm_smmu_cb_readq(s, n, o)\t\\\n\tarm_smmu_readq((s), ARM_SMMU_CB((s), (n)), (o))\n#define arm_smmu_cb_writeq(s, n, o, v)\t\\\n\tarm_smmu_writeq((s), ARM_SMMU_CB((s), (n)), (o), (v))\n\nstruct arm_smmu_device *arm_smmu_impl_init(struct arm_smmu_device *smmu);\nstruct arm_smmu_device *nvidia_smmu_impl_init(struct arm_smmu_device *smmu);\nstruct arm_smmu_device *qcom_smmu_impl_init(struct arm_smmu_device *smmu);\n\nvoid arm_smmu_write_context_bank(struct arm_smmu_device *smmu, int idx);\nint arm_mmu500_reset(struct arm_smmu_device *smmu);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}