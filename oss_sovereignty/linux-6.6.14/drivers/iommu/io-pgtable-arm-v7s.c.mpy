{
  "module_name": "io-pgtable-arm-v7s.c",
  "hash_id": "b917517d33e27cf6da8d33402c394f1745e68e0cdb930d1a19b056b3232156e5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iommu/io-pgtable-arm-v7s.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\t\"arm-v7s io-pgtable: \" fmt\n\n#include <linux/atomic.h>\n#include <linux/dma-mapping.h>\n#include <linux/gfp.h>\n#include <linux/io-pgtable.h>\n#include <linux/iommu.h>\n#include <linux/kernel.h>\n#include <linux/kmemleak.h>\n#include <linux/sizes.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n\n#include <asm/barrier.h>\n\n \n#define io_pgtable_to_data(x)\t\t\t\t\t\t\\\n\tcontainer_of((x), struct arm_v7s_io_pgtable, iop)\n\n#define io_pgtable_ops_to_data(x)\t\t\t\t\t\\\n\tio_pgtable_to_data(io_pgtable_ops_to_pgtable(x))\n\n \n#define ARM_V7S_ADDR_BITS\t\t32\n#define _ARM_V7S_LVL_BITS(lvl, cfg)\t((lvl) == 1 ? ((cfg)->ias - 20) : 8)\n#define ARM_V7S_LVL_SHIFT(lvl)\t\t((lvl) == 1 ? 20 : 12)\n#define ARM_V7S_TABLE_SHIFT\t\t10\n\n#define ARM_V7S_PTES_PER_LVL(lvl, cfg)\t(1 << _ARM_V7S_LVL_BITS(lvl, cfg))\n#define ARM_V7S_TABLE_SIZE(lvl, cfg)\t\t\t\t\t\t\\\n\t(ARM_V7S_PTES_PER_LVL(lvl, cfg) * sizeof(arm_v7s_iopte))\n\n#define ARM_V7S_BLOCK_SIZE(lvl)\t\t(1UL << ARM_V7S_LVL_SHIFT(lvl))\n#define ARM_V7S_LVL_MASK(lvl)\t\t((u32)(~0U << ARM_V7S_LVL_SHIFT(lvl)))\n#define ARM_V7S_TABLE_MASK\t\t((u32)(~0U << ARM_V7S_TABLE_SHIFT))\n#define _ARM_V7S_IDX_MASK(lvl, cfg)\t(ARM_V7S_PTES_PER_LVL(lvl, cfg) - 1)\n#define ARM_V7S_LVL_IDX(addr, lvl, cfg)\t({\t\t\t\t\\\n\tint _l = lvl;\t\t\t\t\t\t\t\\\n\t((addr) >> ARM_V7S_LVL_SHIFT(_l)) & _ARM_V7S_IDX_MASK(_l, cfg); \\\n})\n\n \n#define ARM_V7S_CONT_PAGES\t\t16\n\n \n#define ARM_V7S_PTE_TYPE_TABLE\t\t0x1\n#define ARM_V7S_PTE_TYPE_PAGE\t\t0x2\n#define ARM_V7S_PTE_TYPE_CONT_PAGE\t0x1\n\n#define ARM_V7S_PTE_IS_VALID(pte)\t(((pte) & 0x3) != 0)\n#define ARM_V7S_PTE_IS_TABLE(pte, lvl) \\\n\t((lvl) == 1 && (((pte) & 0x3) == ARM_V7S_PTE_TYPE_TABLE))\n\n \n#define ARM_V7S_ATTR_XN(lvl)\t\tBIT(4 * (2 - (lvl)))\n#define ARM_V7S_ATTR_B\t\t\tBIT(2)\n#define ARM_V7S_ATTR_C\t\t\tBIT(3)\n#define ARM_V7S_ATTR_NS_TABLE\t\tBIT(3)\n#define ARM_V7S_ATTR_NS_SECTION\t\tBIT(19)\n\n#define ARM_V7S_CONT_SECTION\t\tBIT(18)\n#define ARM_V7S_CONT_PAGE_XN_SHIFT\t15\n\n \n#define ARM_V7S_ATTR_SHIFT(lvl)\t\t(16 - (lvl) * 6)\n\n#define ARM_V7S_ATTR_MASK\t\t0xff\n#define ARM_V7S_ATTR_AP0\t\tBIT(0)\n#define ARM_V7S_ATTR_AP1\t\tBIT(1)\n#define ARM_V7S_ATTR_AP2\t\tBIT(5)\n#define ARM_V7S_ATTR_S\t\t\tBIT(6)\n#define ARM_V7S_ATTR_NG\t\t\tBIT(7)\n#define ARM_V7S_TEX_SHIFT\t\t2\n#define ARM_V7S_TEX_MASK\t\t0x7\n#define ARM_V7S_ATTR_TEX(val)\t\t(((val) & ARM_V7S_TEX_MASK) << ARM_V7S_TEX_SHIFT)\n\n \n#define ARM_V7S_ATTR_MTK_PA_BIT32\tBIT(9)\n#define ARM_V7S_ATTR_MTK_PA_BIT33\tBIT(4)\n#define ARM_V7S_ATTR_MTK_PA_BIT34\tBIT(5)\n\n \n#define ARM_V7S_CONT_PAGE_TEX_SHIFT\t6\n#define ARM_V7S_CONT_PAGE_TEX_MASK\t(ARM_V7S_TEX_MASK << ARM_V7S_CONT_PAGE_TEX_SHIFT)\n\n \n#define ARM_V7S_PTE_AF\t\t\tARM_V7S_ATTR_AP0\n#define ARM_V7S_PTE_AP_UNPRIV\t\tARM_V7S_ATTR_AP1\n#define ARM_V7S_PTE_AP_RDONLY\t\tARM_V7S_ATTR_AP2\n\n \n#define ARM_V7S_RGN_NC\t\t\t0\n#define ARM_V7S_RGN_WBWA\t\t1\n#define ARM_V7S_RGN_WT\t\t\t2\n#define ARM_V7S_RGN_WB\t\t\t3\n\n#define ARM_V7S_PRRR_TYPE_DEVICE\t1\n#define ARM_V7S_PRRR_TYPE_NORMAL\t2\n#define ARM_V7S_PRRR_TR(n, type)\t(((type) & 0x3) << ((n) * 2))\n#define ARM_V7S_PRRR_DS0\t\tBIT(16)\n#define ARM_V7S_PRRR_DS1\t\tBIT(17)\n#define ARM_V7S_PRRR_NS0\t\tBIT(18)\n#define ARM_V7S_PRRR_NS1\t\tBIT(19)\n#define ARM_V7S_PRRR_NOS(n)\t\tBIT((n) + 24)\n\n#define ARM_V7S_NMRR_IR(n, attr)\t(((attr) & 0x3) << ((n) * 2))\n#define ARM_V7S_NMRR_OR(n, attr)\t(((attr) & 0x3) << ((n) * 2 + 16))\n\n#define ARM_V7S_TTBR_S\t\t\tBIT(1)\n#define ARM_V7S_TTBR_NOS\t\tBIT(5)\n#define ARM_V7S_TTBR_ORGN_ATTR(attr)\t(((attr) & 0x3) << 3)\n#define ARM_V7S_TTBR_IRGN_ATTR(attr)\t\t\t\t\t\\\n\t((((attr) & 0x1) << 6) | (((attr) & 0x2) >> 1))\n\n#ifdef CONFIG_ZONE_DMA32\n#define ARM_V7S_TABLE_GFP_DMA GFP_DMA32\n#define ARM_V7S_TABLE_SLAB_FLAGS SLAB_CACHE_DMA32\n#else\n#define ARM_V7S_TABLE_GFP_DMA GFP_DMA\n#define ARM_V7S_TABLE_SLAB_FLAGS SLAB_CACHE_DMA\n#endif\n\ntypedef u32 arm_v7s_iopte;\n\nstatic bool selftest_running;\n\nstruct arm_v7s_io_pgtable {\n\tstruct io_pgtable\tiop;\n\n\tarm_v7s_iopte\t\t*pgd;\n\tstruct kmem_cache\t*l2_tables;\n\tspinlock_t\t\tsplit_lock;\n};\n\nstatic bool arm_v7s_pte_is_cont(arm_v7s_iopte pte, int lvl);\n\nstatic dma_addr_t __arm_v7s_dma_addr(void *pages)\n{\n\treturn (dma_addr_t)virt_to_phys(pages);\n}\n\nstatic bool arm_v7s_is_mtk_enabled(struct io_pgtable_cfg *cfg)\n{\n\treturn IS_ENABLED(CONFIG_PHYS_ADDR_T_64BIT) &&\n\t\t(cfg->quirks & IO_PGTABLE_QUIRK_ARM_MTK_EXT);\n}\n\nstatic arm_v7s_iopte to_mtk_iopte(phys_addr_t paddr, arm_v7s_iopte pte)\n{\n\tif (paddr & BIT_ULL(32))\n\t\tpte |= ARM_V7S_ATTR_MTK_PA_BIT32;\n\tif (paddr & BIT_ULL(33))\n\t\tpte |= ARM_V7S_ATTR_MTK_PA_BIT33;\n\tif (paddr & BIT_ULL(34))\n\t\tpte |= ARM_V7S_ATTR_MTK_PA_BIT34;\n\treturn pte;\n}\n\nstatic arm_v7s_iopte paddr_to_iopte(phys_addr_t paddr, int lvl,\n\t\t\t\t    struct io_pgtable_cfg *cfg)\n{\n\tarm_v7s_iopte pte = paddr & ARM_V7S_LVL_MASK(lvl);\n\n\tif (arm_v7s_is_mtk_enabled(cfg))\n\t\treturn to_mtk_iopte(paddr, pte);\n\n\treturn pte;\n}\n\nstatic phys_addr_t iopte_to_paddr(arm_v7s_iopte pte, int lvl,\n\t\t\t\t  struct io_pgtable_cfg *cfg)\n{\n\tarm_v7s_iopte mask;\n\tphys_addr_t paddr;\n\n\tif (ARM_V7S_PTE_IS_TABLE(pte, lvl))\n\t\tmask = ARM_V7S_TABLE_MASK;\n\telse if (arm_v7s_pte_is_cont(pte, lvl))\n\t\tmask = ARM_V7S_LVL_MASK(lvl) * ARM_V7S_CONT_PAGES;\n\telse\n\t\tmask = ARM_V7S_LVL_MASK(lvl);\n\n\tpaddr = pte & mask;\n\tif (!arm_v7s_is_mtk_enabled(cfg))\n\t\treturn paddr;\n\n\tif (pte & ARM_V7S_ATTR_MTK_PA_BIT32)\n\t\tpaddr |= BIT_ULL(32);\n\tif (pte & ARM_V7S_ATTR_MTK_PA_BIT33)\n\t\tpaddr |= BIT_ULL(33);\n\tif (pte & ARM_V7S_ATTR_MTK_PA_BIT34)\n\t\tpaddr |= BIT_ULL(34);\n\treturn paddr;\n}\n\nstatic arm_v7s_iopte *iopte_deref(arm_v7s_iopte pte, int lvl,\n\t\t\t\t  struct arm_v7s_io_pgtable *data)\n{\n\treturn phys_to_virt(iopte_to_paddr(pte, lvl, &data->iop.cfg));\n}\n\nstatic void *__arm_v7s_alloc_table(int lvl, gfp_t gfp,\n\t\t\t\t   struct arm_v7s_io_pgtable *data)\n{\n\tstruct io_pgtable_cfg *cfg = &data->iop.cfg;\n\tstruct device *dev = cfg->iommu_dev;\n\tphys_addr_t phys;\n\tdma_addr_t dma;\n\tsize_t size = ARM_V7S_TABLE_SIZE(lvl, cfg);\n\tvoid *table = NULL;\n\tgfp_t gfp_l1;\n\n\t \n\tgfp_l1 = cfg->quirks & IO_PGTABLE_QUIRK_ARM_MTK_TTBR_EXT ?\n\t\t GFP_KERNEL : ARM_V7S_TABLE_GFP_DMA;\n\n\tif (lvl == 1)\n\t\ttable = (void *)__get_free_pages(gfp_l1 | __GFP_ZERO, get_order(size));\n\telse if (lvl == 2)\n\t\ttable = kmem_cache_zalloc(data->l2_tables, gfp);\n\n\tif (!table)\n\t\treturn NULL;\n\n\tphys = virt_to_phys(table);\n\tif (cfg->quirks & IO_PGTABLE_QUIRK_ARM_MTK_TTBR_EXT ?\n\t    phys >= (1ULL << cfg->oas) : phys != (arm_v7s_iopte)phys) {\n\t\t \n\t\tdev_err(dev, \"Page table does not fit in PTE: %pa\", &phys);\n\t\tgoto out_free;\n\t}\n\tif (!cfg->coherent_walk) {\n\t\tdma = dma_map_single(dev, table, size, DMA_TO_DEVICE);\n\t\tif (dma_mapping_error(dev, dma))\n\t\t\tgoto out_free;\n\t\t \n\t\tif (dma != phys)\n\t\t\tgoto out_unmap;\n\t}\n\tif (lvl == 2)\n\t\tkmemleak_ignore(table);\n\treturn table;\n\nout_unmap:\n\tdev_err(dev, \"Cannot accommodate DMA translation for IOMMU page tables\\n\");\n\tdma_unmap_single(dev, dma, size, DMA_TO_DEVICE);\nout_free:\n\tif (lvl == 1)\n\t\tfree_pages((unsigned long)table, get_order(size));\n\telse\n\t\tkmem_cache_free(data->l2_tables, table);\n\treturn NULL;\n}\n\nstatic void __arm_v7s_free_table(void *table, int lvl,\n\t\t\t\t struct arm_v7s_io_pgtable *data)\n{\n\tstruct io_pgtable_cfg *cfg = &data->iop.cfg;\n\tstruct device *dev = cfg->iommu_dev;\n\tsize_t size = ARM_V7S_TABLE_SIZE(lvl, cfg);\n\n\tif (!cfg->coherent_walk)\n\t\tdma_unmap_single(dev, __arm_v7s_dma_addr(table), size,\n\t\t\t\t DMA_TO_DEVICE);\n\tif (lvl == 1)\n\t\tfree_pages((unsigned long)table, get_order(size));\n\telse\n\t\tkmem_cache_free(data->l2_tables, table);\n}\n\nstatic void __arm_v7s_pte_sync(arm_v7s_iopte *ptep, int num_entries,\n\t\t\t       struct io_pgtable_cfg *cfg)\n{\n\tif (cfg->coherent_walk)\n\t\treturn;\n\n\tdma_sync_single_for_device(cfg->iommu_dev, __arm_v7s_dma_addr(ptep),\n\t\t\t\t   num_entries * sizeof(*ptep), DMA_TO_DEVICE);\n}\nstatic void __arm_v7s_set_pte(arm_v7s_iopte *ptep, arm_v7s_iopte pte,\n\t\t\t      int num_entries, struct io_pgtable_cfg *cfg)\n{\n\tint i;\n\n\tfor (i = 0; i < num_entries; i++)\n\t\tptep[i] = pte;\n\n\t__arm_v7s_pte_sync(ptep, num_entries, cfg);\n}\n\nstatic arm_v7s_iopte arm_v7s_prot_to_pte(int prot, int lvl,\n\t\t\t\t\t struct io_pgtable_cfg *cfg)\n{\n\tbool ap = !(cfg->quirks & IO_PGTABLE_QUIRK_NO_PERMS);\n\tarm_v7s_iopte pte = ARM_V7S_ATTR_NG | ARM_V7S_ATTR_S;\n\n\tif (!(prot & IOMMU_MMIO))\n\t\tpte |= ARM_V7S_ATTR_TEX(1);\n\tif (ap) {\n\t\tpte |= ARM_V7S_PTE_AF;\n\t\tif (!(prot & IOMMU_PRIV))\n\t\t\tpte |= ARM_V7S_PTE_AP_UNPRIV;\n\t\tif (!(prot & IOMMU_WRITE))\n\t\t\tpte |= ARM_V7S_PTE_AP_RDONLY;\n\t}\n\tpte <<= ARM_V7S_ATTR_SHIFT(lvl);\n\n\tif ((prot & IOMMU_NOEXEC) && ap)\n\t\tpte |= ARM_V7S_ATTR_XN(lvl);\n\tif (prot & IOMMU_MMIO)\n\t\tpte |= ARM_V7S_ATTR_B;\n\telse if (prot & IOMMU_CACHE)\n\t\tpte |= ARM_V7S_ATTR_B | ARM_V7S_ATTR_C;\n\n\tpte |= ARM_V7S_PTE_TYPE_PAGE;\n\tif (lvl == 1 && (cfg->quirks & IO_PGTABLE_QUIRK_ARM_NS))\n\t\tpte |= ARM_V7S_ATTR_NS_SECTION;\n\n\treturn pte;\n}\n\nstatic int arm_v7s_pte_to_prot(arm_v7s_iopte pte, int lvl)\n{\n\tint prot = IOMMU_READ;\n\tarm_v7s_iopte attr = pte >> ARM_V7S_ATTR_SHIFT(lvl);\n\n\tif (!(attr & ARM_V7S_PTE_AP_RDONLY))\n\t\tprot |= IOMMU_WRITE;\n\tif (!(attr & ARM_V7S_PTE_AP_UNPRIV))\n\t\tprot |= IOMMU_PRIV;\n\tif ((attr & (ARM_V7S_TEX_MASK << ARM_V7S_TEX_SHIFT)) == 0)\n\t\tprot |= IOMMU_MMIO;\n\telse if (pte & ARM_V7S_ATTR_C)\n\t\tprot |= IOMMU_CACHE;\n\tif (pte & ARM_V7S_ATTR_XN(lvl))\n\t\tprot |= IOMMU_NOEXEC;\n\n\treturn prot;\n}\n\nstatic arm_v7s_iopte arm_v7s_pte_to_cont(arm_v7s_iopte pte, int lvl)\n{\n\tif (lvl == 1) {\n\t\tpte |= ARM_V7S_CONT_SECTION;\n\t} else if (lvl == 2) {\n\t\tarm_v7s_iopte xn = pte & ARM_V7S_ATTR_XN(lvl);\n\t\tarm_v7s_iopte tex = pte & ARM_V7S_CONT_PAGE_TEX_MASK;\n\n\t\tpte ^= xn | tex | ARM_V7S_PTE_TYPE_PAGE;\n\t\tpte |= (xn << ARM_V7S_CONT_PAGE_XN_SHIFT) |\n\t\t       (tex << ARM_V7S_CONT_PAGE_TEX_SHIFT) |\n\t\t       ARM_V7S_PTE_TYPE_CONT_PAGE;\n\t}\n\treturn pte;\n}\n\nstatic arm_v7s_iopte arm_v7s_cont_to_pte(arm_v7s_iopte pte, int lvl)\n{\n\tif (lvl == 1) {\n\t\tpte &= ~ARM_V7S_CONT_SECTION;\n\t} else if (lvl == 2) {\n\t\tarm_v7s_iopte xn = pte & BIT(ARM_V7S_CONT_PAGE_XN_SHIFT);\n\t\tarm_v7s_iopte tex = pte & (ARM_V7S_CONT_PAGE_TEX_MASK <<\n\t\t\t\t\t   ARM_V7S_CONT_PAGE_TEX_SHIFT);\n\n\t\tpte ^= xn | tex | ARM_V7S_PTE_TYPE_CONT_PAGE;\n\t\tpte |= (xn >> ARM_V7S_CONT_PAGE_XN_SHIFT) |\n\t\t       (tex >> ARM_V7S_CONT_PAGE_TEX_SHIFT) |\n\t\t       ARM_V7S_PTE_TYPE_PAGE;\n\t}\n\treturn pte;\n}\n\nstatic bool arm_v7s_pte_is_cont(arm_v7s_iopte pte, int lvl)\n{\n\tif (lvl == 1 && !ARM_V7S_PTE_IS_TABLE(pte, lvl))\n\t\treturn pte & ARM_V7S_CONT_SECTION;\n\telse if (lvl == 2)\n\t\treturn !(pte & ARM_V7S_PTE_TYPE_PAGE);\n\treturn false;\n}\n\nstatic size_t __arm_v7s_unmap(struct arm_v7s_io_pgtable *,\n\t\t\t      struct iommu_iotlb_gather *, unsigned long,\n\t\t\t      size_t, int, arm_v7s_iopte *);\n\nstatic int arm_v7s_init_pte(struct arm_v7s_io_pgtable *data,\n\t\t\t    unsigned long iova, phys_addr_t paddr, int prot,\n\t\t\t    int lvl, int num_entries, arm_v7s_iopte *ptep)\n{\n\tstruct io_pgtable_cfg *cfg = &data->iop.cfg;\n\tarm_v7s_iopte pte;\n\tint i;\n\n\tfor (i = 0; i < num_entries; i++)\n\t\tif (ARM_V7S_PTE_IS_TABLE(ptep[i], lvl)) {\n\t\t\t \n\t\t\tarm_v7s_iopte *tblp;\n\t\t\tsize_t sz = ARM_V7S_BLOCK_SIZE(lvl);\n\n\t\t\ttblp = ptep - ARM_V7S_LVL_IDX(iova, lvl, cfg);\n\t\t\tif (WARN_ON(__arm_v7s_unmap(data, NULL, iova + i * sz,\n\t\t\t\t\t\t    sz, lvl, tblp) != sz))\n\t\t\t\treturn -EINVAL;\n\t\t} else if (ptep[i]) {\n\t\t\t \n\t\t\tWARN_ON(!selftest_running);\n\t\t\treturn -EEXIST;\n\t\t}\n\n\tpte = arm_v7s_prot_to_pte(prot, lvl, cfg);\n\tif (num_entries > 1)\n\t\tpte = arm_v7s_pte_to_cont(pte, lvl);\n\n\tpte |= paddr_to_iopte(paddr, lvl, cfg);\n\n\t__arm_v7s_set_pte(ptep, pte, num_entries, cfg);\n\treturn 0;\n}\n\nstatic arm_v7s_iopte arm_v7s_install_table(arm_v7s_iopte *table,\n\t\t\t\t\t   arm_v7s_iopte *ptep,\n\t\t\t\t\t   arm_v7s_iopte curr,\n\t\t\t\t\t   struct io_pgtable_cfg *cfg)\n{\n\tphys_addr_t phys = virt_to_phys(table);\n\tarm_v7s_iopte old, new;\n\n\tnew = phys | ARM_V7S_PTE_TYPE_TABLE;\n\n\tif (cfg->quirks & IO_PGTABLE_QUIRK_ARM_MTK_TTBR_EXT)\n\t\tnew = to_mtk_iopte(phys, new);\n\n\tif (cfg->quirks & IO_PGTABLE_QUIRK_ARM_NS)\n\t\tnew |= ARM_V7S_ATTR_NS_TABLE;\n\n\t \n\tdma_wmb();\n\n\told = cmpxchg_relaxed(ptep, curr, new);\n\t__arm_v7s_pte_sync(ptep, 1, cfg);\n\n\treturn old;\n}\n\nstatic int __arm_v7s_map(struct arm_v7s_io_pgtable *data, unsigned long iova,\n\t\t\t phys_addr_t paddr, size_t size, int prot,\n\t\t\t int lvl, arm_v7s_iopte *ptep, gfp_t gfp)\n{\n\tstruct io_pgtable_cfg *cfg = &data->iop.cfg;\n\tarm_v7s_iopte pte, *cptep;\n\tint num_entries = size >> ARM_V7S_LVL_SHIFT(lvl);\n\n\t \n\tptep += ARM_V7S_LVL_IDX(iova, lvl, cfg);\n\n\t \n\tif (num_entries)\n\t\treturn arm_v7s_init_pte(data, iova, paddr, prot,\n\t\t\t\t\tlvl, num_entries, ptep);\n\n\t \n\tif (WARN_ON(lvl == 2))\n\t\treturn -EINVAL;\n\n\t \n\tpte = READ_ONCE(*ptep);\n\tif (!pte) {\n\t\tcptep = __arm_v7s_alloc_table(lvl + 1, gfp, data);\n\t\tif (!cptep)\n\t\t\treturn -ENOMEM;\n\n\t\tpte = arm_v7s_install_table(cptep, ptep, 0, cfg);\n\t\tif (pte)\n\t\t\t__arm_v7s_free_table(cptep, lvl + 1, data);\n\t} else {\n\t\t \n\t\t__arm_v7s_pte_sync(ptep, 1, cfg);\n\t}\n\n\tif (ARM_V7S_PTE_IS_TABLE(pte, lvl)) {\n\t\tcptep = iopte_deref(pte, lvl, data);\n\t} else if (pte) {\n\t\t \n\t\tWARN_ON(!selftest_running);\n\t\treturn -EEXIST;\n\t}\n\n\t \n\treturn __arm_v7s_map(data, iova, paddr, size, prot, lvl + 1, cptep, gfp);\n}\n\nstatic int arm_v7s_map_pages(struct io_pgtable_ops *ops, unsigned long iova,\n\t\t\t     phys_addr_t paddr, size_t pgsize, size_t pgcount,\n\t\t\t     int prot, gfp_t gfp, size_t *mapped)\n{\n\tstruct arm_v7s_io_pgtable *data = io_pgtable_ops_to_data(ops);\n\tint ret = -EINVAL;\n\n\tif (WARN_ON(iova >= (1ULL << data->iop.cfg.ias) ||\n\t\t    paddr >= (1ULL << data->iop.cfg.oas)))\n\t\treturn -ERANGE;\n\n\t \n\tif (!(prot & (IOMMU_READ | IOMMU_WRITE)))\n\t\treturn 0;\n\n\twhile (pgcount--) {\n\t\tret = __arm_v7s_map(data, iova, paddr, pgsize, prot, 1, data->pgd,\n\t\t\t\t    gfp);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tiova += pgsize;\n\t\tpaddr += pgsize;\n\t\t*mapped += pgsize;\n\t}\n\t \n\twmb();\n\n\treturn ret;\n}\n\nstatic void arm_v7s_free_pgtable(struct io_pgtable *iop)\n{\n\tstruct arm_v7s_io_pgtable *data = io_pgtable_to_data(iop);\n\tint i;\n\n\tfor (i = 0; i < ARM_V7S_PTES_PER_LVL(1, &data->iop.cfg); i++) {\n\t\tarm_v7s_iopte pte = data->pgd[i];\n\n\t\tif (ARM_V7S_PTE_IS_TABLE(pte, 1))\n\t\t\t__arm_v7s_free_table(iopte_deref(pte, 1, data),\n\t\t\t\t\t     2, data);\n\t}\n\t__arm_v7s_free_table(data->pgd, 1, data);\n\tkmem_cache_destroy(data->l2_tables);\n\tkfree(data);\n}\n\nstatic arm_v7s_iopte arm_v7s_split_cont(struct arm_v7s_io_pgtable *data,\n\t\t\t\t\tunsigned long iova, int idx, int lvl,\n\t\t\t\t\tarm_v7s_iopte *ptep)\n{\n\tstruct io_pgtable *iop = &data->iop;\n\tarm_v7s_iopte pte;\n\tsize_t size = ARM_V7S_BLOCK_SIZE(lvl);\n\tint i;\n\n\t \n\tpte = *ptep;\n\tif (!arm_v7s_pte_is_cont(pte, lvl))\n\t\treturn pte;\n\n\tptep -= idx & (ARM_V7S_CONT_PAGES - 1);\n\tpte = arm_v7s_cont_to_pte(pte, lvl);\n\tfor (i = 0; i < ARM_V7S_CONT_PAGES; i++)\n\t\tptep[i] = pte + i * size;\n\n\t__arm_v7s_pte_sync(ptep, ARM_V7S_CONT_PAGES, &iop->cfg);\n\n\tsize *= ARM_V7S_CONT_PAGES;\n\tio_pgtable_tlb_flush_walk(iop, iova, size, size);\n\treturn pte;\n}\n\nstatic size_t arm_v7s_split_blk_unmap(struct arm_v7s_io_pgtable *data,\n\t\t\t\t      struct iommu_iotlb_gather *gather,\n\t\t\t\t      unsigned long iova, size_t size,\n\t\t\t\t      arm_v7s_iopte blk_pte,\n\t\t\t\t      arm_v7s_iopte *ptep)\n{\n\tstruct io_pgtable_cfg *cfg = &data->iop.cfg;\n\tarm_v7s_iopte pte, *tablep;\n\tint i, unmap_idx, num_entries, num_ptes;\n\n\ttablep = __arm_v7s_alloc_table(2, GFP_ATOMIC, data);\n\tif (!tablep)\n\t\treturn 0;  \n\n\tnum_ptes = ARM_V7S_PTES_PER_LVL(2, cfg);\n\tnum_entries = size >> ARM_V7S_LVL_SHIFT(2);\n\tunmap_idx = ARM_V7S_LVL_IDX(iova, 2, cfg);\n\n\tpte = arm_v7s_prot_to_pte(arm_v7s_pte_to_prot(blk_pte, 1), 2, cfg);\n\tif (num_entries > 1)\n\t\tpte = arm_v7s_pte_to_cont(pte, 2);\n\n\tfor (i = 0; i < num_ptes; i += num_entries, pte += size) {\n\t\t \n\t\tif (i == unmap_idx)\n\t\t\tcontinue;\n\n\t\t__arm_v7s_set_pte(&tablep[i], pte, num_entries, cfg);\n\t}\n\n\tpte = arm_v7s_install_table(tablep, ptep, blk_pte, cfg);\n\tif (pte != blk_pte) {\n\t\t__arm_v7s_free_table(tablep, 2, data);\n\n\t\tif (!ARM_V7S_PTE_IS_TABLE(pte, 1))\n\t\t\treturn 0;\n\n\t\ttablep = iopte_deref(pte, 1, data);\n\t\treturn __arm_v7s_unmap(data, gather, iova, size, 2, tablep);\n\t}\n\n\tio_pgtable_tlb_add_page(&data->iop, gather, iova, size);\n\treturn size;\n}\n\nstatic size_t __arm_v7s_unmap(struct arm_v7s_io_pgtable *data,\n\t\t\t      struct iommu_iotlb_gather *gather,\n\t\t\t      unsigned long iova, size_t size, int lvl,\n\t\t\t      arm_v7s_iopte *ptep)\n{\n\tarm_v7s_iopte pte[ARM_V7S_CONT_PAGES];\n\tstruct io_pgtable *iop = &data->iop;\n\tint idx, i = 0, num_entries = size >> ARM_V7S_LVL_SHIFT(lvl);\n\n\t \n\tif (WARN_ON(lvl > 2))\n\t\treturn 0;\n\n\tidx = ARM_V7S_LVL_IDX(iova, lvl, &iop->cfg);\n\tptep += idx;\n\tdo {\n\t\tpte[i] = READ_ONCE(ptep[i]);\n\t\tif (WARN_ON(!ARM_V7S_PTE_IS_VALID(pte[i])))\n\t\t\treturn 0;\n\t} while (++i < num_entries);\n\n\t \n\tif (num_entries <= 1 && arm_v7s_pte_is_cont(pte[0], lvl)) {\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&data->split_lock, flags);\n\t\tpte[0] = arm_v7s_split_cont(data, iova, idx, lvl, ptep);\n\t\tspin_unlock_irqrestore(&data->split_lock, flags);\n\t}\n\n\t \n\tif (num_entries) {\n\t\tsize_t blk_size = ARM_V7S_BLOCK_SIZE(lvl);\n\n\t\t__arm_v7s_set_pte(ptep, 0, num_entries, &iop->cfg);\n\n\t\tfor (i = 0; i < num_entries; i++) {\n\t\t\tif (ARM_V7S_PTE_IS_TABLE(pte[i], lvl)) {\n\t\t\t\t \n\t\t\t\tio_pgtable_tlb_flush_walk(iop, iova, blk_size,\n\t\t\t\t\t\tARM_V7S_BLOCK_SIZE(lvl + 1));\n\t\t\t\tptep = iopte_deref(pte[i], lvl, data);\n\t\t\t\t__arm_v7s_free_table(ptep, lvl + 1, data);\n\t\t\t} else if (!iommu_iotlb_gather_queued(gather)) {\n\t\t\t\tio_pgtable_tlb_add_page(iop, gather, iova, blk_size);\n\t\t\t}\n\t\t\tiova += blk_size;\n\t\t}\n\t\treturn size;\n\t} else if (lvl == 1 && !ARM_V7S_PTE_IS_TABLE(pte[0], lvl)) {\n\t\t \n\t\treturn arm_v7s_split_blk_unmap(data, gather, iova, size, pte[0],\n\t\t\t\t\t       ptep);\n\t}\n\n\t \n\tptep = iopte_deref(pte[0], lvl, data);\n\treturn __arm_v7s_unmap(data, gather, iova, size, lvl + 1, ptep);\n}\n\nstatic size_t arm_v7s_unmap_pages(struct io_pgtable_ops *ops, unsigned long iova,\n\t\t\t\t  size_t pgsize, size_t pgcount,\n\t\t\t\t  struct iommu_iotlb_gather *gather)\n{\n\tstruct arm_v7s_io_pgtable *data = io_pgtable_ops_to_data(ops);\n\tsize_t unmapped = 0, ret;\n\n\tif (WARN_ON(iova >= (1ULL << data->iop.cfg.ias)))\n\t\treturn 0;\n\n\twhile (pgcount--) {\n\t\tret = __arm_v7s_unmap(data, gather, iova, pgsize, 1, data->pgd);\n\t\tif (!ret)\n\t\t\tbreak;\n\n\t\tunmapped += pgsize;\n\t\tiova += pgsize;\n\t}\n\n\treturn unmapped;\n}\n\nstatic phys_addr_t arm_v7s_iova_to_phys(struct io_pgtable_ops *ops,\n\t\t\t\t\tunsigned long iova)\n{\n\tstruct arm_v7s_io_pgtable *data = io_pgtable_ops_to_data(ops);\n\tarm_v7s_iopte *ptep = data->pgd, pte;\n\tint lvl = 0;\n\tu32 mask;\n\n\tdo {\n\t\tptep += ARM_V7S_LVL_IDX(iova, ++lvl, &data->iop.cfg);\n\t\tpte = READ_ONCE(*ptep);\n\t\tptep = iopte_deref(pte, lvl, data);\n\t} while (ARM_V7S_PTE_IS_TABLE(pte, lvl));\n\n\tif (!ARM_V7S_PTE_IS_VALID(pte))\n\t\treturn 0;\n\n\tmask = ARM_V7S_LVL_MASK(lvl);\n\tif (arm_v7s_pte_is_cont(pte, lvl))\n\t\tmask *= ARM_V7S_CONT_PAGES;\n\treturn iopte_to_paddr(pte, lvl, &data->iop.cfg) | (iova & ~mask);\n}\n\nstatic struct io_pgtable *arm_v7s_alloc_pgtable(struct io_pgtable_cfg *cfg,\n\t\t\t\t\t\tvoid *cookie)\n{\n\tstruct arm_v7s_io_pgtable *data;\n\tslab_flags_t slab_flag;\n\tphys_addr_t paddr;\n\n\tif (cfg->ias > (arm_v7s_is_mtk_enabled(cfg) ? 34 : ARM_V7S_ADDR_BITS))\n\t\treturn NULL;\n\n\tif (cfg->oas > (arm_v7s_is_mtk_enabled(cfg) ? 35 : ARM_V7S_ADDR_BITS))\n\t\treturn NULL;\n\n\tif (cfg->quirks & ~(IO_PGTABLE_QUIRK_ARM_NS |\n\t\t\t    IO_PGTABLE_QUIRK_NO_PERMS |\n\t\t\t    IO_PGTABLE_QUIRK_ARM_MTK_EXT |\n\t\t\t    IO_PGTABLE_QUIRK_ARM_MTK_TTBR_EXT))\n\t\treturn NULL;\n\n\t \n\tif (cfg->quirks & IO_PGTABLE_QUIRK_ARM_MTK_EXT &&\n\t    !(cfg->quirks & IO_PGTABLE_QUIRK_NO_PERMS))\n\t\t\treturn NULL;\n\n\tif ((cfg->quirks & IO_PGTABLE_QUIRK_ARM_MTK_TTBR_EXT) &&\n\t    !arm_v7s_is_mtk_enabled(cfg))\n\t\treturn NULL;\n\n\tdata = kmalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn NULL;\n\n\tspin_lock_init(&data->split_lock);\n\n\t \n\tslab_flag = cfg->quirks & IO_PGTABLE_QUIRK_ARM_MTK_TTBR_EXT ?\n\t\t    0 : ARM_V7S_TABLE_SLAB_FLAGS;\n\n\tdata->l2_tables = kmem_cache_create(\"io-pgtable_armv7s_l2\",\n\t\t\t\t\t    ARM_V7S_TABLE_SIZE(2, cfg),\n\t\t\t\t\t    ARM_V7S_TABLE_SIZE(2, cfg),\n\t\t\t\t\t    slab_flag, NULL);\n\tif (!data->l2_tables)\n\t\tgoto out_free_data;\n\n\tdata->iop.ops = (struct io_pgtable_ops) {\n\t\t.map_pages\t= arm_v7s_map_pages,\n\t\t.unmap_pages\t= arm_v7s_unmap_pages,\n\t\t.iova_to_phys\t= arm_v7s_iova_to_phys,\n\t};\n\n\t \n\tdata->iop.cfg = *cfg;\n\n\t \n\tcfg->pgsize_bitmap &= SZ_4K | SZ_64K | SZ_1M | SZ_16M;\n\n\t \n\tcfg->arm_v7s_cfg.tcr = 0;\n\n\t \n\tcfg->arm_v7s_cfg.prrr = ARM_V7S_PRRR_TR(1, ARM_V7S_PRRR_TYPE_DEVICE) |\n\t\t\t\tARM_V7S_PRRR_TR(4, ARM_V7S_PRRR_TYPE_NORMAL) |\n\t\t\t\tARM_V7S_PRRR_TR(7, ARM_V7S_PRRR_TYPE_NORMAL) |\n\t\t\t\tARM_V7S_PRRR_DS0 | ARM_V7S_PRRR_DS1 |\n\t\t\t\tARM_V7S_PRRR_NS1 | ARM_V7S_PRRR_NOS(7);\n\tcfg->arm_v7s_cfg.nmrr = ARM_V7S_NMRR_IR(7, ARM_V7S_RGN_WBWA) |\n\t\t\t\tARM_V7S_NMRR_OR(7, ARM_V7S_RGN_WBWA);\n\n\t \n\tdata->pgd = __arm_v7s_alloc_table(1, GFP_KERNEL, data);\n\tif (!data->pgd)\n\t\tgoto out_free_data;\n\n\t \n\twmb();\n\n\t \n\tpaddr = virt_to_phys(data->pgd);\n\tif (arm_v7s_is_mtk_enabled(cfg))\n\t\tcfg->arm_v7s_cfg.ttbr = paddr | upper_32_bits(paddr);\n\telse\n\t\tcfg->arm_v7s_cfg.ttbr = paddr | ARM_V7S_TTBR_S |\n\t\t\t\t\t(cfg->coherent_walk ? (ARM_V7S_TTBR_NOS |\n\t\t\t\t\t ARM_V7S_TTBR_IRGN_ATTR(ARM_V7S_RGN_WBWA) |\n\t\t\t\t\t ARM_V7S_TTBR_ORGN_ATTR(ARM_V7S_RGN_WBWA)) :\n\t\t\t\t\t(ARM_V7S_TTBR_IRGN_ATTR(ARM_V7S_RGN_NC) |\n\t\t\t\t\t ARM_V7S_TTBR_ORGN_ATTR(ARM_V7S_RGN_NC)));\n\treturn &data->iop;\n\nout_free_data:\n\tkmem_cache_destroy(data->l2_tables);\n\tkfree(data);\n\treturn NULL;\n}\n\nstruct io_pgtable_init_fns io_pgtable_arm_v7s_init_fns = {\n\t.alloc\t= arm_v7s_alloc_pgtable,\n\t.free\t= arm_v7s_free_pgtable,\n};\n\n#ifdef CONFIG_IOMMU_IO_PGTABLE_ARMV7S_SELFTEST\n\nstatic struct io_pgtable_cfg *cfg_cookie __initdata;\n\nstatic void __init dummy_tlb_flush_all(void *cookie)\n{\n\tWARN_ON(cookie != cfg_cookie);\n}\n\nstatic void __init dummy_tlb_flush(unsigned long iova, size_t size,\n\t\t\t\t   size_t granule, void *cookie)\n{\n\tWARN_ON(cookie != cfg_cookie);\n\tWARN_ON(!(size & cfg_cookie->pgsize_bitmap));\n}\n\nstatic void __init dummy_tlb_add_page(struct iommu_iotlb_gather *gather,\n\t\t\t\t      unsigned long iova, size_t granule,\n\t\t\t\t      void *cookie)\n{\n\tdummy_tlb_flush(iova, granule, granule, cookie);\n}\n\nstatic const struct iommu_flush_ops dummy_tlb_ops __initconst = {\n\t.tlb_flush_all\t= dummy_tlb_flush_all,\n\t.tlb_flush_walk\t= dummy_tlb_flush,\n\t.tlb_add_page\t= dummy_tlb_add_page,\n};\n\n#define __FAIL(ops)\t({\t\t\t\t\\\n\t\tWARN(1, \"selftest: test failed\\n\");\t\\\n\t\tselftest_running = false;\t\t\\\n\t\t-EFAULT;\t\t\t\t\\\n})\n\nstatic int __init arm_v7s_do_selftests(void)\n{\n\tstruct io_pgtable_ops *ops;\n\tstruct io_pgtable_cfg cfg = {\n\t\t.tlb = &dummy_tlb_ops,\n\t\t.oas = 32,\n\t\t.ias = 32,\n\t\t.coherent_walk = true,\n\t\t.quirks = IO_PGTABLE_QUIRK_ARM_NS,\n\t\t.pgsize_bitmap = SZ_4K | SZ_64K | SZ_1M | SZ_16M,\n\t};\n\tunsigned int iova, size, iova_start;\n\tunsigned int i, loopnr = 0;\n\tsize_t mapped;\n\n\tselftest_running = true;\n\n\tcfg_cookie = &cfg;\n\n\tops = alloc_io_pgtable_ops(ARM_V7S, &cfg, &cfg);\n\tif (!ops) {\n\t\tpr_err(\"selftest: failed to allocate io pgtable ops\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (ops->iova_to_phys(ops, 42))\n\t\treturn __FAIL(ops);\n\n\tif (ops->iova_to_phys(ops, SZ_1G + 42))\n\t\treturn __FAIL(ops);\n\n\tif (ops->iova_to_phys(ops, SZ_2G + 42))\n\t\treturn __FAIL(ops);\n\n\t \n\tiova = 0;\n\tfor_each_set_bit(i, &cfg.pgsize_bitmap, BITS_PER_LONG) {\n\t\tsize = 1UL << i;\n\t\tif (ops->map_pages(ops, iova, iova, size, 1,\n\t\t\t\t   IOMMU_READ | IOMMU_WRITE |\n\t\t\t\t   IOMMU_NOEXEC | IOMMU_CACHE,\n\t\t\t\t   GFP_KERNEL, &mapped))\n\t\t\treturn __FAIL(ops);\n\n\t\t \n\t\tif (!ops->map_pages(ops, iova, iova + size, size, 1,\n\t\t\t\t    IOMMU_READ | IOMMU_NOEXEC, GFP_KERNEL,\n\t\t\t\t    &mapped))\n\t\t\treturn __FAIL(ops);\n\n\t\tif (ops->iova_to_phys(ops, iova + 42) != (iova + 42))\n\t\t\treturn __FAIL(ops);\n\n\t\tiova += SZ_16M;\n\t\tloopnr++;\n\t}\n\n\t \n\ti = 1;\n\tsize = 1UL << __ffs(cfg.pgsize_bitmap);\n\twhile (i < loopnr) {\n\t\tiova_start = i * SZ_16M;\n\t\tif (ops->unmap_pages(ops, iova_start + size, size, 1, NULL) != size)\n\t\t\treturn __FAIL(ops);\n\n\t\t \n\t\tif (ops->map_pages(ops, iova_start + size, size, size, 1,\n\t\t\t\t   IOMMU_READ, GFP_KERNEL, &mapped))\n\t\t\treturn __FAIL(ops);\n\n\t\tif (ops->iova_to_phys(ops, iova_start + size + 42)\n\t\t    != (size + 42))\n\t\t\treturn __FAIL(ops);\n\t\ti++;\n\t}\n\n\t \n\tiova = 0;\n\tfor_each_set_bit(i, &cfg.pgsize_bitmap, BITS_PER_LONG) {\n\t\tsize = 1UL << i;\n\n\t\tif (ops->unmap_pages(ops, iova, size, 1, NULL) != size)\n\t\t\treturn __FAIL(ops);\n\n\t\tif (ops->iova_to_phys(ops, iova + 42))\n\t\t\treturn __FAIL(ops);\n\n\t\t \n\t\tif (ops->map_pages(ops, iova, iova, size, 1, IOMMU_WRITE,\n\t\t\t\t   GFP_KERNEL, &mapped))\n\t\t\treturn __FAIL(ops);\n\n\t\tif (ops->iova_to_phys(ops, iova + 42) != (iova + 42))\n\t\t\treturn __FAIL(ops);\n\n\t\tiova += SZ_16M;\n\t}\n\n\tfree_io_pgtable_ops(ops);\n\n\tselftest_running = false;\n\n\tpr_info(\"self test ok\\n\");\n\treturn 0;\n}\nsubsys_initcall(arm_v7s_do_selftests);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}