{
  "module_name": "mtk_iommu.c",
  "hash_id": "c4d3372335056fbbb1f1ccb936d48c879c4a5e201a9eb0ed46be7cc2da316f7e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iommu/mtk_iommu.c",
  "human_readable_source": "\n \n#include <linux/arm-smccc.h>\n#include <linux/bitfield.h>\n#include <linux/bug.h>\n#include <linux/clk.h>\n#include <linux/component.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iommu.h>\n#include <linux/iopoll.h>\n#include <linux/io-pgtable.h>\n#include <linux/list.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/of_platform.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/soc/mediatek/infracfg.h>\n#include <linux/soc/mediatek/mtk_sip_svc.h>\n#include <asm/barrier.h>\n#include <soc/mediatek/smi.h>\n\n#include <dt-bindings/memory/mtk-memory-port.h>\n\n#define REG_MMU_PT_BASE_ADDR\t\t\t0x000\n\n#define REG_MMU_INVALIDATE\t\t\t0x020\n#define F_ALL_INVLD\t\t\t\t0x2\n#define F_MMU_INV_RANGE\t\t\t\t0x1\n\n#define REG_MMU_INVLD_START_A\t\t\t0x024\n#define REG_MMU_INVLD_END_A\t\t\t0x028\n\n#define REG_MMU_INV_SEL_GEN2\t\t\t0x02c\n#define REG_MMU_INV_SEL_GEN1\t\t\t0x038\n#define F_INVLD_EN0\t\t\t\tBIT(0)\n#define F_INVLD_EN1\t\t\t\tBIT(1)\n\n#define REG_MMU_MISC_CTRL\t\t\t0x048\n#define F_MMU_IN_ORDER_WR_EN_MASK\t\t(BIT(1) | BIT(17))\n#define F_MMU_STANDARD_AXI_MODE_MASK\t\t(BIT(3) | BIT(19))\n\n#define REG_MMU_DCM_DIS\t\t\t\t0x050\n#define F_MMU_DCM\t\t\t\tBIT(8)\n\n#define REG_MMU_WR_LEN_CTRL\t\t\t0x054\n#define F_MMU_WR_THROT_DIS_MASK\t\t\t(BIT(5) | BIT(21))\n\n#define REG_MMU_CTRL_REG\t\t\t0x110\n#define F_MMU_TF_PROT_TO_PROGRAM_ADDR\t\t(2 << 4)\n#define F_MMU_PREFETCH_RT_REPLACE_MOD\t\tBIT(4)\n#define F_MMU_TF_PROT_TO_PROGRAM_ADDR_MT8173\t(2 << 5)\n\n#define REG_MMU_IVRP_PADDR\t\t\t0x114\n\n#define REG_MMU_VLD_PA_RNG\t\t\t0x118\n#define F_MMU_VLD_PA_RNG(EA, SA)\t\t(((EA) << 8) | (SA))\n\n#define REG_MMU_INT_CONTROL0\t\t\t0x120\n#define F_L2_MULIT_HIT_EN\t\t\tBIT(0)\n#define F_TABLE_WALK_FAULT_INT_EN\t\tBIT(1)\n#define F_PREETCH_FIFO_OVERFLOW_INT_EN\t\tBIT(2)\n#define F_MISS_FIFO_OVERFLOW_INT_EN\t\tBIT(3)\n#define F_PREFETCH_FIFO_ERR_INT_EN\t\tBIT(5)\n#define F_MISS_FIFO_ERR_INT_EN\t\t\tBIT(6)\n#define F_INT_CLR_BIT\t\t\t\tBIT(12)\n\n#define REG_MMU_INT_MAIN_CONTROL\t\t0x124\n\t\t\t\t\t\t \n#define F_INT_TRANSLATION_FAULT\t\t\t(BIT(0) | BIT(7))\n#define F_INT_MAIN_MULTI_HIT_FAULT\t\t(BIT(1) | BIT(8))\n#define F_INT_INVALID_PA_FAULT\t\t\t(BIT(2) | BIT(9))\n#define F_INT_ENTRY_REPLACEMENT_FAULT\t\t(BIT(3) | BIT(10))\n#define F_INT_TLB_MISS_FAULT\t\t\t(BIT(4) | BIT(11))\n#define F_INT_MISS_TRANSACTION_FIFO_FAULT\t(BIT(5) | BIT(12))\n#define F_INT_PRETETCH_TRANSATION_FIFO_FAULT\t(BIT(6) | BIT(13))\n\n#define REG_MMU_CPE_DONE\t\t\t0x12C\n\n#define REG_MMU_FAULT_ST1\t\t\t0x134\n#define F_REG_MMU0_FAULT_MASK\t\t\tGENMASK(6, 0)\n#define F_REG_MMU1_FAULT_MASK\t\t\tGENMASK(13, 7)\n\n#define REG_MMU0_FAULT_VA\t\t\t0x13c\n#define F_MMU_INVAL_VA_31_12_MASK\t\tGENMASK(31, 12)\n#define F_MMU_INVAL_VA_34_32_MASK\t\tGENMASK(11, 9)\n#define F_MMU_INVAL_PA_34_32_MASK\t\tGENMASK(8, 6)\n#define F_MMU_FAULT_VA_WRITE_BIT\t\tBIT(1)\n#define F_MMU_FAULT_VA_LAYER_BIT\t\tBIT(0)\n\n#define REG_MMU0_INVLD_PA\t\t\t0x140\n#define REG_MMU1_FAULT_VA\t\t\t0x144\n#define REG_MMU1_INVLD_PA\t\t\t0x148\n#define REG_MMU0_INT_ID\t\t\t\t0x150\n#define REG_MMU1_INT_ID\t\t\t\t0x154\n#define F_MMU_INT_ID_COMM_ID(a)\t\t\t(((a) >> 9) & 0x7)\n#define F_MMU_INT_ID_SUB_COMM_ID(a)\t\t(((a) >> 7) & 0x3)\n#define F_MMU_INT_ID_COMM_ID_EXT(a)\t\t(((a) >> 10) & 0x7)\n#define F_MMU_INT_ID_SUB_COMM_ID_EXT(a)\t\t(((a) >> 7) & 0x7)\n \n#define F_MMU_INT_ID_LARB_ID(a)\t\t\t(((a) >> 7) & 0x7)\n#define F_MMU_INT_ID_PORT_ID(a)\t\t\t(((a) >> 2) & 0x1f)\n \n#define F_MMU_INT_ID_LARB_ID_WID_6(a)\t\t(((a) >> 8) & 0x7)\n#define F_MMU_INT_ID_PORT_ID_WID_6(a)\t\t(((a) >> 2) & 0x3f)\n\n#define MTK_PROTECT_PA_ALIGN\t\t\t256\n#define MTK_IOMMU_BANK_SZ\t\t\t0x1000\n\n#define PERICFG_IOMMU_1\t\t\t\t0x714\n\n#define HAS_4GB_MODE\t\t\tBIT(0)\n \n#define HAS_BCLK\t\t\tBIT(1)\n#define HAS_VLD_PA_RNG\t\t\tBIT(2)\n#define RESET_AXI\t\t\tBIT(3)\n#define OUT_ORDER_WR_EN\t\t\tBIT(4)\n#define HAS_SUB_COMM_2BITS\t\tBIT(5)\n#define HAS_SUB_COMM_3BITS\t\tBIT(6)\n#define WR_THROT_EN\t\t\tBIT(7)\n#define HAS_LEGACY_IVRP_PADDR\t\tBIT(8)\n#define IOVA_34_EN\t\t\tBIT(9)\n#define SHARE_PGTABLE\t\t\tBIT(10)  \n#define DCM_DISABLE\t\t\tBIT(11)\n#define STD_AXI_MODE\t\t\tBIT(12)  \n \n#define MTK_IOMMU_TYPE_MM\t\t(0x0 << 13)\n#define MTK_IOMMU_TYPE_INFRA\t\t(0x1 << 13)\n#define MTK_IOMMU_TYPE_MASK\t\t(0x3 << 13)\n \n#define PM_CLK_AO\t\t\tBIT(15)\n#define IFA_IOMMU_PCIE_SUPPORT\t\tBIT(16)\n#define PGTABLE_PA_35_EN\t\tBIT(17)\n#define TF_PORT_TO_ADDR_MT8173\t\tBIT(18)\n#define INT_ID_PORT_WIDTH_6\t\tBIT(19)\n#define CFG_IFA_MASTER_IN_ATF\t\tBIT(20)\n\n#define MTK_IOMMU_HAS_FLAG_MASK(pdata, _x, mask)\t\\\n\t\t\t\t((((pdata)->flags) & (mask)) == (_x))\n\n#define MTK_IOMMU_HAS_FLAG(pdata, _x)\tMTK_IOMMU_HAS_FLAG_MASK(pdata, _x, _x)\n#define MTK_IOMMU_IS_TYPE(pdata, _x)\tMTK_IOMMU_HAS_FLAG_MASK(pdata, _x,\\\n\t\t\t\t\t\t\tMTK_IOMMU_TYPE_MASK)\n\n#define MTK_INVALID_LARBID\t\tMTK_LARB_NR_MAX\n\n#define MTK_LARB_COM_MAX\t8\n#define MTK_LARB_SUBCOM_MAX\t8\n\n#define MTK_IOMMU_GROUP_MAX\t8\n#define MTK_IOMMU_BANK_MAX\t5\n\nenum mtk_iommu_plat {\n\tM4U_MT2712,\n\tM4U_MT6779,\n\tM4U_MT6795,\n\tM4U_MT8167,\n\tM4U_MT8173,\n\tM4U_MT8183,\n\tM4U_MT8186,\n\tM4U_MT8188,\n\tM4U_MT8192,\n\tM4U_MT8195,\n\tM4U_MT8365,\n};\n\nstruct mtk_iommu_iova_region {\n\tdma_addr_t\t\tiova_base;\n\tunsigned long long\tsize;\n};\n\nstruct mtk_iommu_suspend_reg {\n\tu32\t\t\tmisc_ctrl;\n\tu32\t\t\tdcm_dis;\n\tu32\t\t\tctrl_reg;\n\tu32\t\t\tvld_pa_rng;\n\tu32\t\t\twr_len_ctrl;\n\n\tu32\t\t\tint_control[MTK_IOMMU_BANK_MAX];\n\tu32\t\t\tint_main_control[MTK_IOMMU_BANK_MAX];\n\tu32\t\t\tivrp_paddr[MTK_IOMMU_BANK_MAX];\n};\n\nstruct mtk_iommu_plat_data {\n\tenum mtk_iommu_plat\tm4u_plat;\n\tu32\t\t\tflags;\n\tu32\t\t\tinv_sel_reg;\n\n\tchar\t\t\t*pericfg_comp_str;\n\tstruct list_head\t*hw_list;\n\n\t \n\tstruct {\n\t\tunsigned int\tiova_region_nr;\n\t\tconst struct mtk_iommu_iova_region\t*iova_region;\n\t\t \n\t\tconst u32\t(*iova_region_larb_msk)[MTK_LARB_NR_MAX];\n\t};\n\n\t \n\tstruct {\n\t\tu8\t\tbanks_num;\n\t\tbool\t\tbanks_enable[MTK_IOMMU_BANK_MAX];\n\t\tunsigned int\tbanks_portmsk[MTK_IOMMU_BANK_MAX];\n\t};\n\n\tunsigned char       larbid_remap[MTK_LARB_COM_MAX][MTK_LARB_SUBCOM_MAX];\n};\n\nstruct mtk_iommu_bank_data {\n\tvoid __iomem\t\t\t*base;\n\tint\t\t\t\tirq;\n\tu8\t\t\t\tid;\n\tstruct device\t\t\t*parent_dev;\n\tstruct mtk_iommu_data\t\t*parent_data;\n\tspinlock_t\t\t\ttlb_lock;  \n\tstruct mtk_iommu_domain\t\t*m4u_dom;  \n};\n\nstruct mtk_iommu_data {\n\tstruct device\t\t\t*dev;\n\tstruct clk\t\t\t*bclk;\n\tphys_addr_t\t\t\tprotect_base;  \n\tstruct mtk_iommu_suspend_reg\treg;\n\tstruct iommu_group\t\t*m4u_group[MTK_IOMMU_GROUP_MAX];\n\tbool                            enable_4GB;\n\n\tstruct iommu_device\t\tiommu;\n\tconst struct mtk_iommu_plat_data *plat_data;\n\tstruct device\t\t\t*smicomm_dev;\n\n\tstruct mtk_iommu_bank_data\t*bank;\n\tstruct mtk_iommu_domain\t\t*share_dom;\n\n\tstruct regmap\t\t\t*pericfg;\n\tstruct mutex\t\t\tmutex;  \n\n\t \n\tstruct list_head\t\t*hw_list;\n\tstruct list_head\t\thw_list_head;\n\tstruct list_head\t\tlist;\n\tstruct mtk_smi_larb_iommu\tlarb_imu[MTK_LARB_NR_MAX];\n};\n\nstruct mtk_iommu_domain {\n\tstruct io_pgtable_cfg\t\tcfg;\n\tstruct io_pgtable_ops\t\t*iop;\n\n\tstruct mtk_iommu_bank_data\t*bank;\n\tstruct iommu_domain\t\tdomain;\n\n\tstruct mutex\t\t\tmutex;  \n};\n\nstatic int mtk_iommu_bind(struct device *dev)\n{\n\tstruct mtk_iommu_data *data = dev_get_drvdata(dev);\n\n\treturn component_bind_all(dev, &data->larb_imu);\n}\n\nstatic void mtk_iommu_unbind(struct device *dev)\n{\n\tstruct mtk_iommu_data *data = dev_get_drvdata(dev);\n\n\tcomponent_unbind_all(dev, &data->larb_imu);\n}\n\nstatic const struct iommu_ops mtk_iommu_ops;\n\nstatic int mtk_iommu_hw_init(const struct mtk_iommu_data *data, unsigned int bankid);\n\n#define MTK_IOMMU_TLB_ADDR(iova) ({\t\t\t\t\t\\\n\tdma_addr_t _addr = iova;\t\t\t\t\t\\\n\t((lower_32_bits(_addr) & GENMASK(31, 12)) | upper_32_bits(_addr));\\\n})\n\n \n#define MTK_IOMMU_4GB_MODE_REMAP_BASE\t 0x140000000UL\n\nstatic LIST_HEAD(m4ulist);\t \n\n#define for_each_m4u(data, head)  list_for_each_entry(data, head, list)\n\n#define MTK_IOMMU_IOVA_SZ_4G\t\t(SZ_4G - SZ_8M)  \n\nstatic const struct mtk_iommu_iova_region single_domain[] = {\n\t{.iova_base = 0,\t\t.size = MTK_IOMMU_IOVA_SZ_4G},\n};\n\n#define MT8192_MULTI_REGION_NR_MAX\t6\n\n#define MT8192_MULTI_REGION_NR\t(IS_ENABLED(CONFIG_ARCH_DMA_ADDR_T_64BIT) ? \\\n\t\t\t\t MT8192_MULTI_REGION_NR_MAX : 1)\n\nstatic const struct mtk_iommu_iova_region mt8192_multi_dom[MT8192_MULTI_REGION_NR] = {\n\t{ .iova_base = 0x0,\t\t.size = MTK_IOMMU_IOVA_SZ_4G},\t \n\t#if IS_ENABLED(CONFIG_ARCH_DMA_ADDR_T_64BIT)\n\t{ .iova_base = SZ_4G,\t\t.size = MTK_IOMMU_IOVA_SZ_4G},\t \n\t{ .iova_base = SZ_4G * 2,\t.size = MTK_IOMMU_IOVA_SZ_4G},\t \n\t{ .iova_base = SZ_4G * 3,\t.size = MTK_IOMMU_IOVA_SZ_4G},\t \n\n\t{ .iova_base = 0x240000000ULL,\t.size = 0x4000000},\t \n\t{ .iova_base = 0x244000000ULL,\t.size = 0x4000000},\t \n\t#endif\n};\n\n \nstatic struct mtk_iommu_data *mtk_iommu_get_frst_data(struct list_head *hwlist)\n{\n\treturn list_first_entry(hwlist, struct mtk_iommu_data, list);\n}\n\nstatic struct mtk_iommu_domain *to_mtk_domain(struct iommu_domain *dom)\n{\n\treturn container_of(dom, struct mtk_iommu_domain, domain);\n}\n\nstatic void mtk_iommu_tlb_flush_all(struct mtk_iommu_data *data)\n{\n\t \n\tstruct mtk_iommu_bank_data *bank = &data->bank[0];\n\tvoid __iomem *base = bank->base;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&bank->tlb_lock, flags);\n\twritel_relaxed(F_INVLD_EN1 | F_INVLD_EN0, base + data->plat_data->inv_sel_reg);\n\twritel_relaxed(F_ALL_INVLD, base + REG_MMU_INVALIDATE);\n\twmb();  \n\tspin_unlock_irqrestore(&bank->tlb_lock, flags);\n}\n\nstatic void mtk_iommu_tlb_flush_range_sync(unsigned long iova, size_t size,\n\t\t\t\t\t   struct mtk_iommu_bank_data *bank)\n{\n\tstruct list_head *head = bank->parent_data->hw_list;\n\tstruct mtk_iommu_bank_data *curbank;\n\tstruct mtk_iommu_data *data;\n\tbool check_pm_status;\n\tunsigned long flags;\n\tvoid __iomem *base;\n\tint ret;\n\tu32 tmp;\n\n\tfor_each_m4u(data, head) {\n\t\t \n\t\tcheck_pm_status = !MTK_IOMMU_HAS_FLAG(data->plat_data, PM_CLK_AO);\n\n\t\tif (check_pm_status) {\n\t\t\tif (pm_runtime_get_if_in_use(data->dev) <= 0)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tcurbank = &data->bank[bank->id];\n\t\tbase = curbank->base;\n\n\t\tspin_lock_irqsave(&curbank->tlb_lock, flags);\n\t\twritel_relaxed(F_INVLD_EN1 | F_INVLD_EN0,\n\t\t\t       base + data->plat_data->inv_sel_reg);\n\n\t\twritel_relaxed(MTK_IOMMU_TLB_ADDR(iova), base + REG_MMU_INVLD_START_A);\n\t\twritel_relaxed(MTK_IOMMU_TLB_ADDR(iova + size - 1),\n\t\t\t       base + REG_MMU_INVLD_END_A);\n\t\twritel_relaxed(F_MMU_INV_RANGE, base + REG_MMU_INVALIDATE);\n\n\t\t \n\t\tret = readl_poll_timeout_atomic(base + REG_MMU_CPE_DONE,\n\t\t\t\t\t\ttmp, tmp != 0, 10, 1000);\n\n\t\t \n\t\twritel_relaxed(0, base + REG_MMU_CPE_DONE);\n\t\tspin_unlock_irqrestore(&curbank->tlb_lock, flags);\n\n\t\tif (ret) {\n\t\t\tdev_warn(data->dev,\n\t\t\t\t \"Partial TLB flush timed out, falling back to full flush\\n\");\n\t\t\tmtk_iommu_tlb_flush_all(data);\n\t\t}\n\n\t\tif (check_pm_status)\n\t\t\tpm_runtime_put(data->dev);\n\t}\n}\n\nstatic irqreturn_t mtk_iommu_isr(int irq, void *dev_id)\n{\n\tstruct mtk_iommu_bank_data *bank = dev_id;\n\tstruct mtk_iommu_data *data = bank->parent_data;\n\tstruct mtk_iommu_domain *dom = bank->m4u_dom;\n\tunsigned int fault_larb = MTK_INVALID_LARBID, fault_port = 0, sub_comm = 0;\n\tu32 int_state, regval, va34_32, pa34_32;\n\tconst struct mtk_iommu_plat_data *plat_data = data->plat_data;\n\tvoid __iomem *base = bank->base;\n\tu64 fault_iova, fault_pa;\n\tbool layer, write;\n\n\t \n\tint_state = readl_relaxed(base + REG_MMU_FAULT_ST1);\n\tif (int_state & F_REG_MMU0_FAULT_MASK) {\n\t\tregval = readl_relaxed(base + REG_MMU0_INT_ID);\n\t\tfault_iova = readl_relaxed(base + REG_MMU0_FAULT_VA);\n\t\tfault_pa = readl_relaxed(base + REG_MMU0_INVLD_PA);\n\t} else {\n\t\tregval = readl_relaxed(base + REG_MMU1_INT_ID);\n\t\tfault_iova = readl_relaxed(base + REG_MMU1_FAULT_VA);\n\t\tfault_pa = readl_relaxed(base + REG_MMU1_INVLD_PA);\n\t}\n\tlayer = fault_iova & F_MMU_FAULT_VA_LAYER_BIT;\n\twrite = fault_iova & F_MMU_FAULT_VA_WRITE_BIT;\n\tif (MTK_IOMMU_HAS_FLAG(plat_data, IOVA_34_EN)) {\n\t\tva34_32 = FIELD_GET(F_MMU_INVAL_VA_34_32_MASK, fault_iova);\n\t\tfault_iova = fault_iova & F_MMU_INVAL_VA_31_12_MASK;\n\t\tfault_iova |= (u64)va34_32 << 32;\n\t}\n\tpa34_32 = FIELD_GET(F_MMU_INVAL_PA_34_32_MASK, fault_iova);\n\tfault_pa |= (u64)pa34_32 << 32;\n\n\tif (MTK_IOMMU_IS_TYPE(plat_data, MTK_IOMMU_TYPE_MM)) {\n\t\tif (MTK_IOMMU_HAS_FLAG(plat_data, HAS_SUB_COMM_2BITS)) {\n\t\t\tfault_larb = F_MMU_INT_ID_COMM_ID(regval);\n\t\t\tsub_comm = F_MMU_INT_ID_SUB_COMM_ID(regval);\n\t\t\tfault_port = F_MMU_INT_ID_PORT_ID(regval);\n\t\t} else if (MTK_IOMMU_HAS_FLAG(plat_data, HAS_SUB_COMM_3BITS)) {\n\t\t\tfault_larb = F_MMU_INT_ID_COMM_ID_EXT(regval);\n\t\t\tsub_comm = F_MMU_INT_ID_SUB_COMM_ID_EXT(regval);\n\t\t\tfault_port = F_MMU_INT_ID_PORT_ID(regval);\n\t\t} else if (MTK_IOMMU_HAS_FLAG(plat_data, INT_ID_PORT_WIDTH_6)) {\n\t\t\tfault_port = F_MMU_INT_ID_PORT_ID_WID_6(regval);\n\t\t\tfault_larb = F_MMU_INT_ID_LARB_ID_WID_6(regval);\n\t\t} else {\n\t\t\tfault_port = F_MMU_INT_ID_PORT_ID(regval);\n\t\t\tfault_larb = F_MMU_INT_ID_LARB_ID(regval);\n\t\t}\n\t\tfault_larb = data->plat_data->larbid_remap[fault_larb][sub_comm];\n\t}\n\n\tif (!dom || report_iommu_fault(&dom->domain, bank->parent_dev, fault_iova,\n\t\t\t       write ? IOMMU_FAULT_WRITE : IOMMU_FAULT_READ)) {\n\t\tdev_err_ratelimited(\n\t\t\tbank->parent_dev,\n\t\t\t\"fault type=0x%x iova=0x%llx pa=0x%llx master=0x%x(larb=%d port=%d) layer=%d %s\\n\",\n\t\t\tint_state, fault_iova, fault_pa, regval, fault_larb, fault_port,\n\t\t\tlayer, write ? \"write\" : \"read\");\n\t}\n\n\t \n\tregval = readl_relaxed(base + REG_MMU_INT_CONTROL0);\n\tregval |= F_INT_CLR_BIT;\n\twritel_relaxed(regval, base + REG_MMU_INT_CONTROL0);\n\n\tmtk_iommu_tlb_flush_all(data);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic unsigned int mtk_iommu_get_bank_id(struct device *dev,\n\t\t\t\t\t  const struct mtk_iommu_plat_data *plat_data)\n{\n\tstruct iommu_fwspec *fwspec = dev_iommu_fwspec_get(dev);\n\tunsigned int i, portmsk = 0, bankid = 0;\n\n\tif (plat_data->banks_num == 1)\n\t\treturn bankid;\n\n\tfor (i = 0; i < fwspec->num_ids; i++)\n\t\tportmsk |= BIT(MTK_M4U_TO_PORT(fwspec->ids[i]));\n\n\tfor (i = 0; i < plat_data->banks_num && i < MTK_IOMMU_BANK_MAX; i++) {\n\t\tif (!plat_data->banks_enable[i])\n\t\t\tcontinue;\n\n\t\tif (portmsk & plat_data->banks_portmsk[i]) {\n\t\t\tbankid = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn bankid;  \n}\n\nstatic int mtk_iommu_get_iova_region_id(struct device *dev,\n\t\t\t\t\tconst struct mtk_iommu_plat_data *plat_data)\n{\n\tstruct iommu_fwspec *fwspec = dev_iommu_fwspec_get(dev);\n\tunsigned int portidmsk = 0, larbid;\n\tconst u32 *rgn_larb_msk;\n\tint i;\n\n\tif (plat_data->iova_region_nr == 1)\n\t\treturn 0;\n\n\tlarbid = MTK_M4U_TO_LARB(fwspec->ids[0]);\n\tfor (i = 0; i < fwspec->num_ids; i++)\n\t\tportidmsk |= BIT(MTK_M4U_TO_PORT(fwspec->ids[i]));\n\n\tfor (i = 0; i < plat_data->iova_region_nr; i++) {\n\t\trgn_larb_msk = plat_data->iova_region_larb_msk[i];\n\t\tif (!rgn_larb_msk)\n\t\t\tcontinue;\n\n\t\tif ((rgn_larb_msk[larbid] & portidmsk) == portidmsk)\n\t\t\treturn i;\n\t}\n\n\tdev_err(dev, \"Can NOT find the region for larb(%d-%x).\\n\",\n\t\tlarbid, portidmsk);\n\treturn -EINVAL;\n}\n\nstatic int mtk_iommu_config(struct mtk_iommu_data *data, struct device *dev,\n\t\t\t    bool enable, unsigned int regionid)\n{\n\tstruct mtk_smi_larb_iommu    *larb_mmu;\n\tunsigned int                 larbid, portid;\n\tstruct iommu_fwspec *fwspec = dev_iommu_fwspec_get(dev);\n\tconst struct mtk_iommu_iova_region *region;\n\tunsigned long portid_msk = 0;\n\tstruct arm_smccc_res res;\n\tint i, ret = 0;\n\n\tfor (i = 0; i < fwspec->num_ids; ++i) {\n\t\tportid = MTK_M4U_TO_PORT(fwspec->ids[i]);\n\t\tportid_msk |= BIT(portid);\n\t}\n\n\tif (MTK_IOMMU_IS_TYPE(data->plat_data, MTK_IOMMU_TYPE_MM)) {\n\t\t \n\t\tlarbid = MTK_M4U_TO_LARB(fwspec->ids[0]);\n\t\tlarb_mmu = &data->larb_imu[larbid];\n\t\tregion = data->plat_data->iova_region + regionid;\n\n\t\tfor_each_set_bit(portid, &portid_msk, 32)\n\t\t\tlarb_mmu->bank[portid] = upper_32_bits(region->iova_base);\n\n\t\tdev_dbg(dev, \"%s iommu for larb(%s) port 0x%lx region %d rgn-bank %d.\\n\",\n\t\t\tenable ? \"enable\" : \"disable\", dev_name(larb_mmu->dev),\n\t\t\tportid_msk, regionid, upper_32_bits(region->iova_base));\n\n\t\tif (enable)\n\t\t\tlarb_mmu->mmu |= portid_msk;\n\t\telse\n\t\t\tlarb_mmu->mmu &= ~portid_msk;\n\t} else if (MTK_IOMMU_IS_TYPE(data->plat_data, MTK_IOMMU_TYPE_INFRA)) {\n\t\tif (MTK_IOMMU_HAS_FLAG(data->plat_data, CFG_IFA_MASTER_IN_ATF)) {\n\t\t\tarm_smccc_smc(MTK_SIP_KERNEL_IOMMU_CONTROL,\n\t\t\t\t      IOMMU_ATF_CMD_CONFIG_INFRA_IOMMU,\n\t\t\t\t      portid_msk, enable, 0, 0, 0, 0, &res);\n\t\t\tret = res.a0;\n\t\t} else {\n\t\t\t \n\t\t\tif (dev_is_pci(dev)) {\n\t\t\t\tif (fwspec->num_ids != 1) {\n\t\t\t\t\tdev_err(dev, \"PCI dev can only have one port.\\n\");\n\t\t\t\t\treturn -ENODEV;\n\t\t\t\t}\n\t\t\t\tportid_msk |= BIT(portid + 1);\n\t\t\t}\n\n\t\t\tret = regmap_update_bits(data->pericfg, PERICFG_IOMMU_1,\n\t\t\t\t\t\t (u32)portid_msk, enable ? (u32)portid_msk : 0);\n\t\t}\n\t\tif (ret)\n\t\t\tdev_err(dev, \"%s iommu(%s) inframaster 0x%lx fail(%d).\\n\",\n\t\t\t\tenable ? \"enable\" : \"disable\",\n\t\t\t\tdev_name(data->dev), portid_msk, ret);\n\t}\n\treturn ret;\n}\n\nstatic int mtk_iommu_domain_finalise(struct mtk_iommu_domain *dom,\n\t\t\t\t     struct mtk_iommu_data *data,\n\t\t\t\t     unsigned int region_id)\n{\n\tstruct mtk_iommu_domain\t*share_dom = data->share_dom;\n\tconst struct mtk_iommu_iova_region *region;\n\n\t \n\tif (share_dom) {\n\t\tdom->iop = share_dom->iop;\n\t\tdom->cfg = share_dom->cfg;\n\t\tdom->domain.pgsize_bitmap = share_dom->cfg.pgsize_bitmap;\n\t\tgoto update_iova_region;\n\t}\n\n\tdom->cfg = (struct io_pgtable_cfg) {\n\t\t.quirks = IO_PGTABLE_QUIRK_ARM_NS |\n\t\t\tIO_PGTABLE_QUIRK_NO_PERMS |\n\t\t\tIO_PGTABLE_QUIRK_ARM_MTK_EXT,\n\t\t.pgsize_bitmap = mtk_iommu_ops.pgsize_bitmap,\n\t\t.ias = MTK_IOMMU_HAS_FLAG(data->plat_data, IOVA_34_EN) ? 34 : 32,\n\t\t.iommu_dev = data->dev,\n\t};\n\n\tif (MTK_IOMMU_HAS_FLAG(data->plat_data, PGTABLE_PA_35_EN))\n\t\tdom->cfg.quirks |= IO_PGTABLE_QUIRK_ARM_MTK_TTBR_EXT;\n\n\tif (MTK_IOMMU_HAS_FLAG(data->plat_data, HAS_4GB_MODE))\n\t\tdom->cfg.oas = data->enable_4GB ? 33 : 32;\n\telse\n\t\tdom->cfg.oas = 35;\n\n\tdom->iop = alloc_io_pgtable_ops(ARM_V7S, &dom->cfg, data);\n\tif (!dom->iop) {\n\t\tdev_err(data->dev, \"Failed to alloc io pgtable\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tdom->domain.pgsize_bitmap = dom->cfg.pgsize_bitmap;\n\n\tdata->share_dom = dom;\n\nupdate_iova_region:\n\t \n\tregion = data->plat_data->iova_region + region_id;\n\tdom->domain.geometry.aperture_start = region->iova_base;\n\tdom->domain.geometry.aperture_end = region->iova_base + region->size - 1;\n\tdom->domain.geometry.force_aperture = true;\n\treturn 0;\n}\n\nstatic struct iommu_domain *mtk_iommu_domain_alloc(unsigned type)\n{\n\tstruct mtk_iommu_domain *dom;\n\n\tif (type != IOMMU_DOMAIN_DMA && type != IOMMU_DOMAIN_UNMANAGED)\n\t\treturn NULL;\n\n\tdom = kzalloc(sizeof(*dom), GFP_KERNEL);\n\tif (!dom)\n\t\treturn NULL;\n\tmutex_init(&dom->mutex);\n\n\treturn &dom->domain;\n}\n\nstatic void mtk_iommu_domain_free(struct iommu_domain *domain)\n{\n\tkfree(to_mtk_domain(domain));\n}\n\nstatic int mtk_iommu_attach_device(struct iommu_domain *domain,\n\t\t\t\t   struct device *dev)\n{\n\tstruct mtk_iommu_data *data = dev_iommu_priv_get(dev), *frstdata;\n\tstruct mtk_iommu_domain *dom = to_mtk_domain(domain);\n\tstruct list_head *hw_list = data->hw_list;\n\tstruct device *m4udev = data->dev;\n\tstruct mtk_iommu_bank_data *bank;\n\tunsigned int bankid;\n\tint ret, region_id;\n\n\tregion_id = mtk_iommu_get_iova_region_id(dev, data->plat_data);\n\tif (region_id < 0)\n\t\treturn region_id;\n\n\tbankid = mtk_iommu_get_bank_id(dev, data->plat_data);\n\tmutex_lock(&dom->mutex);\n\tif (!dom->bank) {\n\t\t \n\t\tfrstdata = mtk_iommu_get_frst_data(hw_list);\n\n\t\tmutex_lock(&frstdata->mutex);\n\t\tret = mtk_iommu_domain_finalise(dom, frstdata, region_id);\n\t\tmutex_unlock(&frstdata->mutex);\n\t\tif (ret) {\n\t\t\tmutex_unlock(&dom->mutex);\n\t\t\treturn ret;\n\t\t}\n\t\tdom->bank = &data->bank[bankid];\n\t}\n\tmutex_unlock(&dom->mutex);\n\n\tmutex_lock(&data->mutex);\n\tbank = &data->bank[bankid];\n\tif (!bank->m4u_dom) {  \n\t\tret = pm_runtime_resume_and_get(m4udev);\n\t\tif (ret < 0) {\n\t\t\tdev_err(m4udev, \"pm get fail(%d) in attach.\\n\", ret);\n\t\t\tgoto err_unlock;\n\t\t}\n\n\t\tret = mtk_iommu_hw_init(data, bankid);\n\t\tif (ret) {\n\t\t\tpm_runtime_put(m4udev);\n\t\t\tgoto err_unlock;\n\t\t}\n\t\tbank->m4u_dom = dom;\n\t\twritel(dom->cfg.arm_v7s_cfg.ttbr, bank->base + REG_MMU_PT_BASE_ADDR);\n\n\t\tpm_runtime_put(m4udev);\n\t}\n\tmutex_unlock(&data->mutex);\n\n\tif (region_id > 0) {\n\t\tret = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(34));\n\t\tif (ret) {\n\t\t\tdev_err(m4udev, \"Failed to set dma_mask for %s(%d).\\n\", dev_name(dev), ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn mtk_iommu_config(data, dev, true, region_id);\n\nerr_unlock:\n\tmutex_unlock(&data->mutex);\n\treturn ret;\n}\n\nstatic int mtk_iommu_map(struct iommu_domain *domain, unsigned long iova,\n\t\t\t phys_addr_t paddr, size_t pgsize, size_t pgcount,\n\t\t\t int prot, gfp_t gfp, size_t *mapped)\n{\n\tstruct mtk_iommu_domain *dom = to_mtk_domain(domain);\n\n\t \n\tif (dom->bank->parent_data->enable_4GB)\n\t\tpaddr |= BIT_ULL(32);\n\n\t \n\treturn dom->iop->map_pages(dom->iop, iova, paddr, pgsize, pgcount, prot, gfp, mapped);\n}\n\nstatic size_t mtk_iommu_unmap(struct iommu_domain *domain,\n\t\t\t      unsigned long iova, size_t pgsize, size_t pgcount,\n\t\t\t      struct iommu_iotlb_gather *gather)\n{\n\tstruct mtk_iommu_domain *dom = to_mtk_domain(domain);\n\n\tiommu_iotlb_gather_add_range(gather, iova, pgsize * pgcount);\n\treturn dom->iop->unmap_pages(dom->iop, iova, pgsize, pgcount, gather);\n}\n\nstatic void mtk_iommu_flush_iotlb_all(struct iommu_domain *domain)\n{\n\tstruct mtk_iommu_domain *dom = to_mtk_domain(domain);\n\n\tif (dom->bank)\n\t\tmtk_iommu_tlb_flush_all(dom->bank->parent_data);\n}\n\nstatic void mtk_iommu_iotlb_sync(struct iommu_domain *domain,\n\t\t\t\t struct iommu_iotlb_gather *gather)\n{\n\tstruct mtk_iommu_domain *dom = to_mtk_domain(domain);\n\tsize_t length = gather->end - gather->start + 1;\n\n\tmtk_iommu_tlb_flush_range_sync(gather->start, length, dom->bank);\n}\n\nstatic void mtk_iommu_sync_map(struct iommu_domain *domain, unsigned long iova,\n\t\t\t       size_t size)\n{\n\tstruct mtk_iommu_domain *dom = to_mtk_domain(domain);\n\n\tmtk_iommu_tlb_flush_range_sync(iova, size, dom->bank);\n}\n\nstatic phys_addr_t mtk_iommu_iova_to_phys(struct iommu_domain *domain,\n\t\t\t\t\t  dma_addr_t iova)\n{\n\tstruct mtk_iommu_domain *dom = to_mtk_domain(domain);\n\tphys_addr_t pa;\n\n\tpa = dom->iop->iova_to_phys(dom->iop, iova);\n\tif (IS_ENABLED(CONFIG_PHYS_ADDR_T_64BIT) &&\n\t    dom->bank->parent_data->enable_4GB &&\n\t    pa >= MTK_IOMMU_4GB_MODE_REMAP_BASE)\n\t\tpa &= ~BIT_ULL(32);\n\n\treturn pa;\n}\n\nstatic struct iommu_device *mtk_iommu_probe_device(struct device *dev)\n{\n\tstruct iommu_fwspec *fwspec = dev_iommu_fwspec_get(dev);\n\tstruct mtk_iommu_data *data;\n\tstruct device_link *link;\n\tstruct device *larbdev;\n\tunsigned int larbid, larbidx, i;\n\n\tif (!fwspec || fwspec->ops != &mtk_iommu_ops)\n\t\treturn ERR_PTR(-ENODEV);  \n\n\tdata = dev_iommu_priv_get(dev);\n\n\tif (!MTK_IOMMU_IS_TYPE(data->plat_data, MTK_IOMMU_TYPE_MM))\n\t\treturn &data->iommu;\n\n\t \n\tlarbid = MTK_M4U_TO_LARB(fwspec->ids[0]);\n\tif (larbid >= MTK_LARB_NR_MAX)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tfor (i = 1; i < fwspec->num_ids; i++) {\n\t\tlarbidx = MTK_M4U_TO_LARB(fwspec->ids[i]);\n\t\tif (larbid != larbidx) {\n\t\t\tdev_err(dev, \"Can only use one larb. Fail@larb%d-%d.\\n\",\n\t\t\t\tlarbid, larbidx);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t}\n\tlarbdev = data->larb_imu[larbid].dev;\n\tif (!larbdev)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tlink = device_link_add(dev, larbdev,\n\t\t\t       DL_FLAG_PM_RUNTIME | DL_FLAG_STATELESS);\n\tif (!link)\n\t\tdev_err(dev, \"Unable to link %s\\n\", dev_name(larbdev));\n\treturn &data->iommu;\n}\n\nstatic void mtk_iommu_release_device(struct device *dev)\n{\n\tstruct iommu_fwspec *fwspec = dev_iommu_fwspec_get(dev);\n\tstruct mtk_iommu_data *data;\n\tstruct device *larbdev;\n\tunsigned int larbid;\n\n\tdata = dev_iommu_priv_get(dev);\n\tif (MTK_IOMMU_IS_TYPE(data->plat_data, MTK_IOMMU_TYPE_MM)) {\n\t\tlarbid = MTK_M4U_TO_LARB(fwspec->ids[0]);\n\t\tlarbdev = data->larb_imu[larbid].dev;\n\t\tdevice_link_remove(dev, larbdev);\n\t}\n}\n\nstatic int mtk_iommu_get_group_id(struct device *dev, const struct mtk_iommu_plat_data *plat_data)\n{\n\tunsigned int bankid;\n\n\t \n\tbankid = mtk_iommu_get_bank_id(dev, plat_data);\n\tif (bankid)\n\t\treturn bankid;\n\n\treturn mtk_iommu_get_iova_region_id(dev, plat_data);\n}\n\nstatic struct iommu_group *mtk_iommu_device_group(struct device *dev)\n{\n\tstruct mtk_iommu_data *c_data = dev_iommu_priv_get(dev), *data;\n\tstruct list_head *hw_list = c_data->hw_list;\n\tstruct iommu_group *group;\n\tint groupid;\n\n\tdata = mtk_iommu_get_frst_data(hw_list);\n\tif (!data)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tgroupid = mtk_iommu_get_group_id(dev, data->plat_data);\n\tif (groupid < 0)\n\t\treturn ERR_PTR(groupid);\n\n\tmutex_lock(&data->mutex);\n\tgroup = data->m4u_group[groupid];\n\tif (!group) {\n\t\tgroup = iommu_group_alloc();\n\t\tif (!IS_ERR(group))\n\t\t\tdata->m4u_group[groupid] = group;\n\t} else {\n\t\tiommu_group_ref_get(group);\n\t}\n\tmutex_unlock(&data->mutex);\n\treturn group;\n}\n\nstatic int mtk_iommu_of_xlate(struct device *dev, struct of_phandle_args *args)\n{\n\tstruct platform_device *m4updev;\n\n\tif (args->args_count != 1) {\n\t\tdev_err(dev, \"invalid #iommu-cells(%d) property for IOMMU\\n\",\n\t\t\targs->args_count);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!dev_iommu_priv_get(dev)) {\n\t\t \n\t\tm4updev = of_find_device_by_node(args->np);\n\t\tif (WARN_ON(!m4updev))\n\t\t\treturn -EINVAL;\n\n\t\tdev_iommu_priv_set(dev, platform_get_drvdata(m4updev));\n\t}\n\n\treturn iommu_fwspec_add_ids(dev, args->args, 1);\n}\n\nstatic void mtk_iommu_get_resv_regions(struct device *dev,\n\t\t\t\t       struct list_head *head)\n{\n\tstruct mtk_iommu_data *data = dev_iommu_priv_get(dev);\n\tunsigned int regionid = mtk_iommu_get_iova_region_id(dev, data->plat_data), i;\n\tconst struct mtk_iommu_iova_region *resv, *curdom;\n\tstruct iommu_resv_region *region;\n\tint prot = IOMMU_WRITE | IOMMU_READ;\n\n\tif ((int)regionid < 0)\n\t\treturn;\n\tcurdom = data->plat_data->iova_region + regionid;\n\tfor (i = 0; i < data->plat_data->iova_region_nr; i++) {\n\t\tresv = data->plat_data->iova_region + i;\n\n\t\t \n\t\tif (resv->iova_base <= curdom->iova_base ||\n\t\t    resv->iova_base + resv->size >= curdom->iova_base + curdom->size)\n\t\t\tcontinue;\n\n\t\tregion = iommu_alloc_resv_region(resv->iova_base, resv->size,\n\t\t\t\t\t\t prot, IOMMU_RESV_RESERVED,\n\t\t\t\t\t\t GFP_KERNEL);\n\t\tif (!region)\n\t\t\treturn;\n\n\t\tlist_add_tail(&region->list, head);\n\t}\n}\n\nstatic const struct iommu_ops mtk_iommu_ops = {\n\t.domain_alloc\t= mtk_iommu_domain_alloc,\n\t.probe_device\t= mtk_iommu_probe_device,\n\t.release_device\t= mtk_iommu_release_device,\n\t.device_group\t= mtk_iommu_device_group,\n\t.of_xlate\t= mtk_iommu_of_xlate,\n\t.get_resv_regions = mtk_iommu_get_resv_regions,\n\t.pgsize_bitmap\t= SZ_4K | SZ_64K | SZ_1M | SZ_16M,\n\t.owner\t\t= THIS_MODULE,\n\t.default_domain_ops = &(const struct iommu_domain_ops) {\n\t\t.attach_dev\t= mtk_iommu_attach_device,\n\t\t.map_pages\t= mtk_iommu_map,\n\t\t.unmap_pages\t= mtk_iommu_unmap,\n\t\t.flush_iotlb_all = mtk_iommu_flush_iotlb_all,\n\t\t.iotlb_sync\t= mtk_iommu_iotlb_sync,\n\t\t.iotlb_sync_map\t= mtk_iommu_sync_map,\n\t\t.iova_to_phys\t= mtk_iommu_iova_to_phys,\n\t\t.free\t\t= mtk_iommu_domain_free,\n\t}\n};\n\nstatic int mtk_iommu_hw_init(const struct mtk_iommu_data *data, unsigned int bankid)\n{\n\tconst struct mtk_iommu_bank_data *bankx = &data->bank[bankid];\n\tconst struct mtk_iommu_bank_data *bank0 = &data->bank[0];\n\tu32 regval;\n\n\t \n\tif (MTK_IOMMU_HAS_FLAG(data->plat_data, TF_PORT_TO_ADDR_MT8173)) {\n\t\tregval = F_MMU_PREFETCH_RT_REPLACE_MOD |\n\t\t\t F_MMU_TF_PROT_TO_PROGRAM_ADDR_MT8173;\n\t} else {\n\t\tregval = readl_relaxed(bank0->base + REG_MMU_CTRL_REG);\n\t\tregval |= F_MMU_TF_PROT_TO_PROGRAM_ADDR;\n\t}\n\twritel_relaxed(regval, bank0->base + REG_MMU_CTRL_REG);\n\n\tif (data->enable_4GB &&\n\t    MTK_IOMMU_HAS_FLAG(data->plat_data, HAS_VLD_PA_RNG)) {\n\t\t \n\t\tregval = F_MMU_VLD_PA_RNG(7, 4);\n\t\twritel_relaxed(regval, bank0->base + REG_MMU_VLD_PA_RNG);\n\t}\n\tif (MTK_IOMMU_HAS_FLAG(data->plat_data, DCM_DISABLE))\n\t\twritel_relaxed(F_MMU_DCM, bank0->base + REG_MMU_DCM_DIS);\n\telse\n\t\twritel_relaxed(0, bank0->base + REG_MMU_DCM_DIS);\n\n\tif (MTK_IOMMU_HAS_FLAG(data->plat_data, WR_THROT_EN)) {\n\t\t \n\t\tregval = readl_relaxed(bank0->base + REG_MMU_WR_LEN_CTRL);\n\t\tregval &= ~F_MMU_WR_THROT_DIS_MASK;\n\t\twritel_relaxed(regval, bank0->base + REG_MMU_WR_LEN_CTRL);\n\t}\n\n\tif (MTK_IOMMU_HAS_FLAG(data->plat_data, RESET_AXI)) {\n\t\t \n\t\tregval = 0;\n\t} else {\n\t\tregval = readl_relaxed(bank0->base + REG_MMU_MISC_CTRL);\n\t\tif (!MTK_IOMMU_HAS_FLAG(data->plat_data, STD_AXI_MODE))\n\t\t\tregval &= ~F_MMU_STANDARD_AXI_MODE_MASK;\n\t\tif (MTK_IOMMU_HAS_FLAG(data->plat_data, OUT_ORDER_WR_EN))\n\t\t\tregval &= ~F_MMU_IN_ORDER_WR_EN_MASK;\n\t}\n\twritel_relaxed(regval, bank0->base + REG_MMU_MISC_CTRL);\n\n\t \n\tregval = F_L2_MULIT_HIT_EN |\n\t\tF_TABLE_WALK_FAULT_INT_EN |\n\t\tF_PREETCH_FIFO_OVERFLOW_INT_EN |\n\t\tF_MISS_FIFO_OVERFLOW_INT_EN |\n\t\tF_PREFETCH_FIFO_ERR_INT_EN |\n\t\tF_MISS_FIFO_ERR_INT_EN;\n\twritel_relaxed(regval, bankx->base + REG_MMU_INT_CONTROL0);\n\n\tregval = F_INT_TRANSLATION_FAULT |\n\t\tF_INT_MAIN_MULTI_HIT_FAULT |\n\t\tF_INT_INVALID_PA_FAULT |\n\t\tF_INT_ENTRY_REPLACEMENT_FAULT |\n\t\tF_INT_TLB_MISS_FAULT |\n\t\tF_INT_MISS_TRANSACTION_FIFO_FAULT |\n\t\tF_INT_PRETETCH_TRANSATION_FIFO_FAULT;\n\twritel_relaxed(regval, bankx->base + REG_MMU_INT_MAIN_CONTROL);\n\n\tif (MTK_IOMMU_HAS_FLAG(data->plat_data, HAS_LEGACY_IVRP_PADDR))\n\t\tregval = (data->protect_base >> 1) | (data->enable_4GB << 31);\n\telse\n\t\tregval = lower_32_bits(data->protect_base) |\n\t\t\t upper_32_bits(data->protect_base);\n\twritel_relaxed(regval, bankx->base + REG_MMU_IVRP_PADDR);\n\n\tif (devm_request_irq(bankx->parent_dev, bankx->irq, mtk_iommu_isr, 0,\n\t\t\t     dev_name(bankx->parent_dev), (void *)bankx)) {\n\t\twritel_relaxed(0, bankx->base + REG_MMU_PT_BASE_ADDR);\n\t\tdev_err(bankx->parent_dev, \"Failed @ IRQ-%d Request\\n\", bankx->irq);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct component_master_ops mtk_iommu_com_ops = {\n\t.bind\t\t= mtk_iommu_bind,\n\t.unbind\t\t= mtk_iommu_unbind,\n};\n\nstatic int mtk_iommu_mm_dts_parse(struct device *dev, struct component_match **match,\n\t\t\t\t  struct mtk_iommu_data *data)\n{\n\tstruct device_node *larbnode, *frst_avail_smicomm_node = NULL;\n\tstruct platform_device *plarbdev, *pcommdev;\n\tstruct device_link *link;\n\tint i, larb_nr, ret;\n\n\tlarb_nr = of_count_phandle_with_args(dev->of_node, \"mediatek,larbs\", NULL);\n\tif (larb_nr < 0)\n\t\treturn larb_nr;\n\tif (larb_nr == 0 || larb_nr > MTK_LARB_NR_MAX)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < larb_nr; i++) {\n\t\tstruct device_node *smicomm_node, *smi_subcomm_node;\n\t\tu32 id;\n\n\t\tlarbnode = of_parse_phandle(dev->of_node, \"mediatek,larbs\", i);\n\t\tif (!larbnode) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_larbdev_put;\n\t\t}\n\n\t\tif (!of_device_is_available(larbnode)) {\n\t\t\tof_node_put(larbnode);\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = of_property_read_u32(larbnode, \"mediatek,larb-id\", &id);\n\t\tif (ret) \n\t\t\tid = i;\n\t\tif (id >= MTK_LARB_NR_MAX) {\n\t\t\tof_node_put(larbnode);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_larbdev_put;\n\t\t}\n\n\t\tplarbdev = of_find_device_by_node(larbnode);\n\t\tof_node_put(larbnode);\n\t\tif (!plarbdev) {\n\t\t\tret = -ENODEV;\n\t\t\tgoto err_larbdev_put;\n\t\t}\n\t\tif (data->larb_imu[id].dev) {\n\t\t\tplatform_device_put(plarbdev);\n\t\t\tret = -EEXIST;\n\t\t\tgoto err_larbdev_put;\n\t\t}\n\t\tdata->larb_imu[id].dev = &plarbdev->dev;\n\n\t\tif (!plarbdev->dev.driver) {\n\t\t\tret = -EPROBE_DEFER;\n\t\t\tgoto err_larbdev_put;\n\t\t}\n\n\t\t \n\t\tsmi_subcomm_node = of_parse_phandle(larbnode, \"mediatek,smi\", 0);\n\t\tif (!smi_subcomm_node) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_larbdev_put;\n\t\t}\n\n\t\t \n\t\tsmicomm_node = of_parse_phandle(smi_subcomm_node, \"mediatek,smi\", 0);\n\t\tif (smicomm_node)\n\t\t\tof_node_put(smi_subcomm_node);\n\t\telse\n\t\t\tsmicomm_node = smi_subcomm_node;\n\n\t\t \n\t\tif (!frst_avail_smicomm_node) {\n\t\t\tfrst_avail_smicomm_node = smicomm_node;\n\t\t} else if (frst_avail_smicomm_node != smicomm_node) {\n\t\t\tdev_err(dev, \"mediatek,smi property is not right @larb%d.\", id);\n\t\t\tof_node_put(smicomm_node);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_larbdev_put;\n\t\t} else {\n\t\t\tof_node_put(smicomm_node);\n\t\t}\n\n\t\tcomponent_match_add(dev, match, component_compare_dev, &plarbdev->dev);\n\t\tplatform_device_put(plarbdev);\n\t}\n\n\tif (!frst_avail_smicomm_node)\n\t\treturn -EINVAL;\n\n\tpcommdev = of_find_device_by_node(frst_avail_smicomm_node);\n\tof_node_put(frst_avail_smicomm_node);\n\tif (!pcommdev)\n\t\treturn -ENODEV;\n\tdata->smicomm_dev = &pcommdev->dev;\n\n\tlink = device_link_add(data->smicomm_dev, dev,\n\t\t\t       DL_FLAG_STATELESS | DL_FLAG_PM_RUNTIME);\n\tplatform_device_put(pcommdev);\n\tif (!link) {\n\t\tdev_err(dev, \"Unable to link %s.\\n\", dev_name(data->smicomm_dev));\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n\nerr_larbdev_put:\n\tfor (i = MTK_LARB_NR_MAX - 1; i >= 0; i--) {\n\t\tif (!data->larb_imu[i].dev)\n\t\t\tcontinue;\n\t\tput_device(data->larb_imu[i].dev);\n\t}\n\treturn ret;\n}\n\nstatic int mtk_iommu_probe(struct platform_device *pdev)\n{\n\tstruct mtk_iommu_data   *data;\n\tstruct device           *dev = &pdev->dev;\n\tstruct resource         *res;\n\tresource_size_t\t\tioaddr;\n\tstruct component_match  *match = NULL;\n\tstruct regmap\t\t*infracfg;\n\tvoid                    *protect;\n\tint                     ret, banks_num, i = 0;\n\tu32\t\t\tval;\n\tchar                    *p;\n\tstruct mtk_iommu_bank_data *bank;\n\tvoid __iomem\t\t*base;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\tdata->dev = dev;\n\tdata->plat_data = of_device_get_match_data(dev);\n\n\t \n\tprotect = devm_kzalloc(dev, MTK_PROTECT_PA_ALIGN * 2, GFP_KERNEL);\n\tif (!protect)\n\t\treturn -ENOMEM;\n\tdata->protect_base = ALIGN(virt_to_phys(protect), MTK_PROTECT_PA_ALIGN);\n\n\tif (MTK_IOMMU_HAS_FLAG(data->plat_data, HAS_4GB_MODE)) {\n\t\tinfracfg = syscon_regmap_lookup_by_phandle(dev->of_node, \"mediatek,infracfg\");\n\t\tif (IS_ERR(infracfg)) {\n\t\t\t \n\t\t\tswitch (data->plat_data->m4u_plat) {\n\t\t\tcase M4U_MT2712:\n\t\t\t\tp = \"mediatek,mt2712-infracfg\";\n\t\t\t\tbreak;\n\t\t\tcase M4U_MT8173:\n\t\t\t\tp = \"mediatek,mt8173-infracfg\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tp = NULL;\n\t\t\t}\n\n\t\t\tinfracfg = syscon_regmap_lookup_by_compatible(p);\n\t\t\tif (IS_ERR(infracfg))\n\t\t\t\treturn PTR_ERR(infracfg);\n\t\t}\n\n\t\tret = regmap_read(infracfg, REG_INFRA_MISC, &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tdata->enable_4GB = !!(val & F_DDR_4GB_SUPPORT_EN);\n\t}\n\n\tbanks_num = data->plat_data->banks_num;\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -EINVAL;\n\tif (resource_size(res) < banks_num * MTK_IOMMU_BANK_SZ) {\n\t\tdev_err(dev, \"banknr %d. res %pR is not enough.\\n\", banks_num, res);\n\t\treturn -EINVAL;\n\t}\n\tbase = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\tioaddr = res->start;\n\n\tdata->bank = devm_kmalloc(dev, banks_num * sizeof(*data->bank), GFP_KERNEL);\n\tif (!data->bank)\n\t\treturn -ENOMEM;\n\n\tdo {\n\t\tif (!data->plat_data->banks_enable[i])\n\t\t\tcontinue;\n\t\tbank = &data->bank[i];\n\t\tbank->id = i;\n\t\tbank->base = base + i * MTK_IOMMU_BANK_SZ;\n\t\tbank->m4u_dom = NULL;\n\n\t\tbank->irq = platform_get_irq(pdev, i);\n\t\tif (bank->irq < 0)\n\t\t\treturn bank->irq;\n\t\tbank->parent_dev = dev;\n\t\tbank->parent_data = data;\n\t\tspin_lock_init(&bank->tlb_lock);\n\t} while (++i < banks_num);\n\n\tif (MTK_IOMMU_HAS_FLAG(data->plat_data, HAS_BCLK)) {\n\t\tdata->bclk = devm_clk_get(dev, \"bclk\");\n\t\tif (IS_ERR(data->bclk))\n\t\t\treturn PTR_ERR(data->bclk);\n\t}\n\n\tif (MTK_IOMMU_HAS_FLAG(data->plat_data, PGTABLE_PA_35_EN)) {\n\t\tret = dma_set_mask(dev, DMA_BIT_MASK(35));\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to set dma_mask 35.\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpm_runtime_enable(dev);\n\n\tif (MTK_IOMMU_IS_TYPE(data->plat_data, MTK_IOMMU_TYPE_MM)) {\n\t\tret = mtk_iommu_mm_dts_parse(dev, &match, data);\n\t\tif (ret) {\n\t\t\tdev_err_probe(dev, ret, \"mm dts parse fail\\n\");\n\t\t\tgoto out_runtime_disable;\n\t\t}\n\t} else if (MTK_IOMMU_IS_TYPE(data->plat_data, MTK_IOMMU_TYPE_INFRA) &&\n\t\t   !MTK_IOMMU_HAS_FLAG(data->plat_data, CFG_IFA_MASTER_IN_ATF)) {\n\t\tp = data->plat_data->pericfg_comp_str;\n\t\tdata->pericfg = syscon_regmap_lookup_by_compatible(p);\n\t\tif (IS_ERR(data->pericfg)) {\n\t\t\tret = PTR_ERR(data->pericfg);\n\t\t\tgoto out_runtime_disable;\n\t\t}\n\t}\n\n\tplatform_set_drvdata(pdev, data);\n\tmutex_init(&data->mutex);\n\n\tret = iommu_device_sysfs_add(&data->iommu, dev, NULL,\n\t\t\t\t     \"mtk-iommu.%pa\", &ioaddr);\n\tif (ret)\n\t\tgoto out_link_remove;\n\n\tret = iommu_device_register(&data->iommu, &mtk_iommu_ops, dev);\n\tif (ret)\n\t\tgoto out_sysfs_remove;\n\n\tif (MTK_IOMMU_HAS_FLAG(data->plat_data, SHARE_PGTABLE)) {\n\t\tlist_add_tail(&data->list, data->plat_data->hw_list);\n\t\tdata->hw_list = data->plat_data->hw_list;\n\t} else {\n\t\tINIT_LIST_HEAD(&data->hw_list_head);\n\t\tlist_add_tail(&data->list, &data->hw_list_head);\n\t\tdata->hw_list = &data->hw_list_head;\n\t}\n\n\tif (MTK_IOMMU_IS_TYPE(data->plat_data, MTK_IOMMU_TYPE_MM)) {\n\t\tret = component_master_add_with_match(dev, &mtk_iommu_com_ops, match);\n\t\tif (ret)\n\t\t\tgoto out_list_del;\n\t}\n\treturn ret;\n\nout_list_del:\n\tlist_del(&data->list);\n\tiommu_device_unregister(&data->iommu);\nout_sysfs_remove:\n\tiommu_device_sysfs_remove(&data->iommu);\nout_link_remove:\n\tif (MTK_IOMMU_IS_TYPE(data->plat_data, MTK_IOMMU_TYPE_MM))\n\t\tdevice_link_remove(data->smicomm_dev, dev);\nout_runtime_disable:\n\tpm_runtime_disable(dev);\n\treturn ret;\n}\n\nstatic void mtk_iommu_remove(struct platform_device *pdev)\n{\n\tstruct mtk_iommu_data *data = platform_get_drvdata(pdev);\n\tstruct mtk_iommu_bank_data *bank;\n\tint i;\n\n\tiommu_device_sysfs_remove(&data->iommu);\n\tiommu_device_unregister(&data->iommu);\n\n\tlist_del(&data->list);\n\n\tif (MTK_IOMMU_IS_TYPE(data->plat_data, MTK_IOMMU_TYPE_MM)) {\n\t\tdevice_link_remove(data->smicomm_dev, &pdev->dev);\n\t\tcomponent_master_del(&pdev->dev, &mtk_iommu_com_ops);\n\t}\n\tpm_runtime_disable(&pdev->dev);\n\tfor (i = 0; i < data->plat_data->banks_num; i++) {\n\t\tbank = &data->bank[i];\n\t\tif (!bank->m4u_dom)\n\t\t\tcontinue;\n\t\tdevm_free_irq(&pdev->dev, bank->irq, bank);\n\t}\n}\n\nstatic int __maybe_unused mtk_iommu_runtime_suspend(struct device *dev)\n{\n\tstruct mtk_iommu_data *data = dev_get_drvdata(dev);\n\tstruct mtk_iommu_suspend_reg *reg = &data->reg;\n\tvoid __iomem *base;\n\tint i = 0;\n\n\tbase = data->bank[i].base;\n\treg->wr_len_ctrl = readl_relaxed(base + REG_MMU_WR_LEN_CTRL);\n\treg->misc_ctrl = readl_relaxed(base + REG_MMU_MISC_CTRL);\n\treg->dcm_dis = readl_relaxed(base + REG_MMU_DCM_DIS);\n\treg->ctrl_reg = readl_relaxed(base + REG_MMU_CTRL_REG);\n\treg->vld_pa_rng = readl_relaxed(base + REG_MMU_VLD_PA_RNG);\n\tdo {\n\t\tif (!data->plat_data->banks_enable[i])\n\t\t\tcontinue;\n\t\tbase = data->bank[i].base;\n\t\treg->int_control[i] = readl_relaxed(base + REG_MMU_INT_CONTROL0);\n\t\treg->int_main_control[i] = readl_relaxed(base + REG_MMU_INT_MAIN_CONTROL);\n\t\treg->ivrp_paddr[i] = readl_relaxed(base + REG_MMU_IVRP_PADDR);\n\t} while (++i < data->plat_data->banks_num);\n\tclk_disable_unprepare(data->bclk);\n\treturn 0;\n}\n\nstatic int __maybe_unused mtk_iommu_runtime_resume(struct device *dev)\n{\n\tstruct mtk_iommu_data *data = dev_get_drvdata(dev);\n\tstruct mtk_iommu_suspend_reg *reg = &data->reg;\n\tstruct mtk_iommu_domain *m4u_dom;\n\tvoid __iomem *base;\n\tint ret, i = 0;\n\n\tret = clk_prepare_enable(data->bclk);\n\tif (ret) {\n\t\tdev_err(data->dev, \"Failed to enable clk(%d) in resume\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (!reg->wr_len_ctrl)\n\t\treturn 0;\n\n\tbase = data->bank[i].base;\n\twritel_relaxed(reg->wr_len_ctrl, base + REG_MMU_WR_LEN_CTRL);\n\twritel_relaxed(reg->misc_ctrl, base + REG_MMU_MISC_CTRL);\n\twritel_relaxed(reg->dcm_dis, base + REG_MMU_DCM_DIS);\n\twritel_relaxed(reg->ctrl_reg, base + REG_MMU_CTRL_REG);\n\twritel_relaxed(reg->vld_pa_rng, base + REG_MMU_VLD_PA_RNG);\n\tdo {\n\t\tm4u_dom = data->bank[i].m4u_dom;\n\t\tif (!data->plat_data->banks_enable[i] || !m4u_dom)\n\t\t\tcontinue;\n\t\tbase = data->bank[i].base;\n\t\twritel_relaxed(reg->int_control[i], base + REG_MMU_INT_CONTROL0);\n\t\twritel_relaxed(reg->int_main_control[i], base + REG_MMU_INT_MAIN_CONTROL);\n\t\twritel_relaxed(reg->ivrp_paddr[i], base + REG_MMU_IVRP_PADDR);\n\t\twritel(m4u_dom->cfg.arm_v7s_cfg.ttbr, base + REG_MMU_PT_BASE_ADDR);\n\t} while (++i < data->plat_data->banks_num);\n\n\t \n\tmtk_iommu_tlb_flush_all(data);\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops mtk_iommu_pm_ops = {\n\tSET_RUNTIME_PM_OPS(mtk_iommu_runtime_suspend, mtk_iommu_runtime_resume, NULL)\n\tSET_LATE_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\t     pm_runtime_force_resume)\n};\n\nstatic const struct mtk_iommu_plat_data mt2712_data = {\n\t.m4u_plat     = M4U_MT2712,\n\t.flags        = HAS_4GB_MODE | HAS_BCLK | HAS_VLD_PA_RNG | SHARE_PGTABLE |\n\t\t\tMTK_IOMMU_TYPE_MM,\n\t.hw_list      = &m4ulist,\n\t.inv_sel_reg  = REG_MMU_INV_SEL_GEN1,\n\t.iova_region  = single_domain,\n\t.banks_num    = 1,\n\t.banks_enable = {true},\n\t.iova_region_nr = ARRAY_SIZE(single_domain),\n\t.larbid_remap = {{0}, {1}, {2}, {3}, {4}, {5}, {6}, {7}},\n};\n\nstatic const struct mtk_iommu_plat_data mt6779_data = {\n\t.m4u_plat      = M4U_MT6779,\n\t.flags         = HAS_SUB_COMM_2BITS | OUT_ORDER_WR_EN | WR_THROT_EN |\n\t\t\t MTK_IOMMU_TYPE_MM | PGTABLE_PA_35_EN,\n\t.inv_sel_reg   = REG_MMU_INV_SEL_GEN2,\n\t.banks_num    = 1,\n\t.banks_enable = {true},\n\t.iova_region   = single_domain,\n\t.iova_region_nr = ARRAY_SIZE(single_domain),\n\t.larbid_remap  = {{0}, {1}, {2}, {3}, {5}, {7, 8}, {10}, {9}},\n};\n\nstatic const struct mtk_iommu_plat_data mt6795_data = {\n\t.m4u_plat     = M4U_MT6795,\n\t.flags\t      = HAS_4GB_MODE | HAS_BCLK | RESET_AXI |\n\t\t\tHAS_LEGACY_IVRP_PADDR | MTK_IOMMU_TYPE_MM |\n\t\t\tTF_PORT_TO_ADDR_MT8173,\n\t.inv_sel_reg  = REG_MMU_INV_SEL_GEN1,\n\t.banks_num    = 1,\n\t.banks_enable = {true},\n\t.iova_region  = single_domain,\n\t.iova_region_nr = ARRAY_SIZE(single_domain),\n\t.larbid_remap = {{0}, {1}, {2}, {3}, {4}},  \n};\n\nstatic const struct mtk_iommu_plat_data mt8167_data = {\n\t.m4u_plat     = M4U_MT8167,\n\t.flags        = RESET_AXI | HAS_LEGACY_IVRP_PADDR | MTK_IOMMU_TYPE_MM,\n\t.inv_sel_reg  = REG_MMU_INV_SEL_GEN1,\n\t.banks_num    = 1,\n\t.banks_enable = {true},\n\t.iova_region  = single_domain,\n\t.iova_region_nr = ARRAY_SIZE(single_domain),\n\t.larbid_remap = {{0}, {1}, {2}},  \n};\n\nstatic const struct mtk_iommu_plat_data mt8173_data = {\n\t.m4u_plat     = M4U_MT8173,\n\t.flags\t      = HAS_4GB_MODE | HAS_BCLK | RESET_AXI |\n\t\t\tHAS_LEGACY_IVRP_PADDR | MTK_IOMMU_TYPE_MM |\n\t\t\tTF_PORT_TO_ADDR_MT8173,\n\t.inv_sel_reg  = REG_MMU_INV_SEL_GEN1,\n\t.banks_num    = 1,\n\t.banks_enable = {true},\n\t.iova_region  = single_domain,\n\t.iova_region_nr = ARRAY_SIZE(single_domain),\n\t.larbid_remap = {{0}, {1}, {2}, {3}, {4}, {5}},  \n};\n\nstatic const struct mtk_iommu_plat_data mt8183_data = {\n\t.m4u_plat     = M4U_MT8183,\n\t.flags        = RESET_AXI | MTK_IOMMU_TYPE_MM,\n\t.inv_sel_reg  = REG_MMU_INV_SEL_GEN1,\n\t.banks_num    = 1,\n\t.banks_enable = {true},\n\t.iova_region  = single_domain,\n\t.iova_region_nr = ARRAY_SIZE(single_domain),\n\t.larbid_remap = {{0}, {4}, {5}, {6}, {7}, {2}, {3}, {1}},\n};\n\nstatic const unsigned int mt8186_larb_region_msk[MT8192_MULTI_REGION_NR_MAX][MTK_LARB_NR_MAX] = {\n\t[0] = {~0, ~0, ~0},\t\t\t \n\t[1] = {0, 0, 0, 0, ~0, 0, 0, ~0},\t \n\t[2] = {0, 0, 0, 0, 0, 0, 0, 0,\t\t \n\t       ~0, ~0, 0, ~0, 0, ~(u32)(BIT(9) | BIT(10)), 0, 0,\n\t\t\t\t\t\t \n\t       ~0, ~0, 0, ~0, ~0},\n\t[3] = {0},\n\t[4] = {[13] = BIT(9) | BIT(10)},\t \n\t[5] = {[14] = ~0},\t\t\t \n};\n\nstatic const struct mtk_iommu_plat_data mt8186_data_mm = {\n\t.m4u_plat       = M4U_MT8186,\n\t.flags          = HAS_BCLK | HAS_SUB_COMM_2BITS | OUT_ORDER_WR_EN |\n\t\t\t  WR_THROT_EN | IOVA_34_EN | MTK_IOMMU_TYPE_MM,\n\t.larbid_remap   = {{0}, {1, MTK_INVALID_LARBID, 8}, {4}, {7}, {2}, {9, 11, 19, 20},\n\t\t\t   {MTK_INVALID_LARBID, 14, 16},\n\t\t\t   {MTK_INVALID_LARBID, 13, MTK_INVALID_LARBID, 17}},\n\t.inv_sel_reg    = REG_MMU_INV_SEL_GEN2,\n\t.banks_num      = 1,\n\t.banks_enable   = {true},\n\t.iova_region    = mt8192_multi_dom,\n\t.iova_region_nr = ARRAY_SIZE(mt8192_multi_dom),\n\t.iova_region_larb_msk = mt8186_larb_region_msk,\n};\n\nstatic const struct mtk_iommu_plat_data mt8188_data_infra = {\n\t.m4u_plat         = M4U_MT8188,\n\t.flags            = WR_THROT_EN | DCM_DISABLE | STD_AXI_MODE | PM_CLK_AO |\n\t\t\t    MTK_IOMMU_TYPE_INFRA | IFA_IOMMU_PCIE_SUPPORT |\n\t\t\t    PGTABLE_PA_35_EN | CFG_IFA_MASTER_IN_ATF,\n\t.inv_sel_reg      = REG_MMU_INV_SEL_GEN2,\n\t.banks_num        = 1,\n\t.banks_enable     = {true},\n\t.iova_region      = single_domain,\n\t.iova_region_nr   = ARRAY_SIZE(single_domain),\n};\n\nstatic const u32 mt8188_larb_region_msk[MT8192_MULTI_REGION_NR_MAX][MTK_LARB_NR_MAX] = {\n\t[0] = {~0, ~0, ~0, ~0},                \n\t[1] = {0, 0, 0, 0, 0, 0, 0, 0,\n\t       0, 0, 0, 0, 0, 0, 0, 0,\n\t       0, 0, 0, 0, 0, ~0, ~0, ~0},     \n\t[2] = {0, 0, 0, 0, ~0, ~0, ~0, ~0,     \n\t       ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0,\n\t       ~0, ~0, ~0, ~0, ~0, 0, 0, 0,\n\t       0, ~0},\n\t[3] = {0},\n\t[4] = {[24] = BIT(0) | BIT(1)},        \n\t[5] = {[24] = BIT(2) | BIT(3)},        \n};\n\nstatic const struct mtk_iommu_plat_data mt8188_data_vdo = {\n\t.m4u_plat       = M4U_MT8188,\n\t.flags          = HAS_BCLK | HAS_SUB_COMM_3BITS | OUT_ORDER_WR_EN |\n\t\t\t  WR_THROT_EN | IOVA_34_EN | SHARE_PGTABLE |\n\t\t\t  PGTABLE_PA_35_EN | MTK_IOMMU_TYPE_MM,\n\t.hw_list        = &m4ulist,\n\t.inv_sel_reg    = REG_MMU_INV_SEL_GEN2,\n\t.banks_num      = 1,\n\t.banks_enable   = {true},\n\t.iova_region    = mt8192_multi_dom,\n\t.iova_region_nr = ARRAY_SIZE(mt8192_multi_dom),\n\t.iova_region_larb_msk = mt8188_larb_region_msk,\n\t.larbid_remap   = {{2}, {0}, {21}, {0}, {19}, {9, 10,\n\t\t\t   11  , 25  },\n\t\t\t   {13, 0, 29  , 30  , 0}, {5}},\n};\n\nstatic const struct mtk_iommu_plat_data mt8188_data_vpp = {\n\t.m4u_plat       = M4U_MT8188,\n\t.flags          = HAS_BCLK | HAS_SUB_COMM_3BITS | OUT_ORDER_WR_EN |\n\t\t\t  WR_THROT_EN | IOVA_34_EN | SHARE_PGTABLE |\n\t\t\t  PGTABLE_PA_35_EN | MTK_IOMMU_TYPE_MM,\n\t.hw_list        = &m4ulist,\n\t.inv_sel_reg    = REG_MMU_INV_SEL_GEN2,\n\t.banks_num      = 1,\n\t.banks_enable   = {true},\n\t.iova_region    = mt8192_multi_dom,\n\t.iova_region_nr = ARRAY_SIZE(mt8192_multi_dom),\n\t.iova_region_larb_msk = mt8188_larb_region_msk,\n\t.larbid_remap   = {{1}, {3}, {23}, {7}, {MTK_INVALID_LARBID},\n\t\t\t   {12, 15, 24  }, {14, MTK_INVALID_LARBID,\n\t\t\t   16  , 17  , MTK_INVALID_LARBID,\n\t\t\t   27, 28  , MTK_INVALID_LARBID}, {4, 6}},\n};\n\nstatic const unsigned int mt8192_larb_region_msk[MT8192_MULTI_REGION_NR_MAX][MTK_LARB_NR_MAX] = {\n\t[0] = {~0, ~0},\t\t\t\t \n\t[1] = {0, 0, 0, 0, ~0, ~0, 0, ~0},\t \n\t[2] = {0, 0, ~0, 0, 0, 0, 0, 0,\t\t \n\t       0, ~0, 0, ~0, 0, ~(u32)(BIT(9) | BIT(10)), ~(u32)(BIT(4) | BIT(5)), 0,\n\t       ~0, ~0, ~0, ~0, ~0},\n\t[3] = {0},\n\t[4] = {[13] = BIT(9) | BIT(10)},\t \n\t[5] = {[14] = BIT(4) | BIT(5)},\t\t \n};\n\nstatic const struct mtk_iommu_plat_data mt8192_data = {\n\t.m4u_plat       = M4U_MT8192,\n\t.flags          = HAS_BCLK | HAS_SUB_COMM_2BITS | OUT_ORDER_WR_EN |\n\t\t\t  WR_THROT_EN | IOVA_34_EN | MTK_IOMMU_TYPE_MM,\n\t.inv_sel_reg    = REG_MMU_INV_SEL_GEN2,\n\t.banks_num      = 1,\n\t.banks_enable   = {true},\n\t.iova_region    = mt8192_multi_dom,\n\t.iova_region_nr = ARRAY_SIZE(mt8192_multi_dom),\n\t.iova_region_larb_msk = mt8192_larb_region_msk,\n\t.larbid_remap   = {{0}, {1}, {4, 5}, {7}, {2}, {9, 11, 19, 20},\n\t\t\t   {0, 14, 16}, {0, 13, 18, 17}},\n};\n\nstatic const struct mtk_iommu_plat_data mt8195_data_infra = {\n\t.m4u_plat\t  = M4U_MT8195,\n\t.flags            = WR_THROT_EN | DCM_DISABLE | STD_AXI_MODE | PM_CLK_AO |\n\t\t\t    MTK_IOMMU_TYPE_INFRA | IFA_IOMMU_PCIE_SUPPORT,\n\t.pericfg_comp_str = \"mediatek,mt8195-pericfg_ao\",\n\t.inv_sel_reg      = REG_MMU_INV_SEL_GEN2,\n\t.banks_num\t  = 5,\n\t.banks_enable     = {true, false, false, false, true},\n\t.banks_portmsk    = {[0] = GENMASK(19, 16),      \n\t\t\t     [4] = GENMASK(31, 20),      \n\t\t\t    },\n\t.iova_region      = single_domain,\n\t.iova_region_nr   = ARRAY_SIZE(single_domain),\n};\n\nstatic const unsigned int mt8195_larb_region_msk[MT8192_MULTI_REGION_NR_MAX][MTK_LARB_NR_MAX] = {\n\t[0] = {~0, ~0, ~0, ~0},                \n\t[1] = {0, 0, 0, 0, 0, 0, 0, 0,\n\t       0, 0, 0, 0, 0, 0, 0, 0,\n\t       0, 0, 0, ~0, ~0, ~0, ~0, ~0,    \n\t       ~0},\n\t[2] = {0, 0, 0, 0, ~0, ~0, ~0, ~0,     \n\t       ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0,\n\t       ~0, ~0, 0, 0, 0, 0, 0, 0,\n\t       0, ~0, ~0, ~0, ~0},\n\t[3] = {0},\n\t[4] = {[18] = BIT(0) | BIT(1)},        \n\t[5] = {[18] = BIT(2) | BIT(3)},        \n};\n\nstatic const struct mtk_iommu_plat_data mt8195_data_vdo = {\n\t.m4u_plat\t= M4U_MT8195,\n\t.flags          = HAS_BCLK | HAS_SUB_COMM_2BITS | OUT_ORDER_WR_EN |\n\t\t\t  WR_THROT_EN | IOVA_34_EN | SHARE_PGTABLE | MTK_IOMMU_TYPE_MM,\n\t.hw_list        = &m4ulist,\n\t.inv_sel_reg    = REG_MMU_INV_SEL_GEN2,\n\t.banks_num      = 1,\n\t.banks_enable   = {true},\n\t.iova_region\t= mt8192_multi_dom,\n\t.iova_region_nr\t= ARRAY_SIZE(mt8192_multi_dom),\n\t.iova_region_larb_msk = mt8195_larb_region_msk,\n\t.larbid_remap   = {{2, 0}, {21}, {24}, {7}, {19}, {9, 10, 11},\n\t\t\t   {13, 17, 15 , 25}, {5}},\n};\n\nstatic const struct mtk_iommu_plat_data mt8195_data_vpp = {\n\t.m4u_plat\t= M4U_MT8195,\n\t.flags          = HAS_BCLK | HAS_SUB_COMM_3BITS | OUT_ORDER_WR_EN |\n\t\t\t  WR_THROT_EN | IOVA_34_EN | SHARE_PGTABLE | MTK_IOMMU_TYPE_MM,\n\t.hw_list        = &m4ulist,\n\t.inv_sel_reg    = REG_MMU_INV_SEL_GEN2,\n\t.banks_num      = 1,\n\t.banks_enable   = {true},\n\t.iova_region\t= mt8192_multi_dom,\n\t.iova_region_nr\t= ARRAY_SIZE(mt8192_multi_dom),\n\t.iova_region_larb_msk = mt8195_larb_region_msk,\n\t.larbid_remap   = {{1}, {3},\n\t\t\t   {22, MTK_INVALID_LARBID, MTK_INVALID_LARBID, MTK_INVALID_LARBID, 23},\n\t\t\t   {8}, {20}, {12},\n\t\t\t    \n\t\t\t   {14, 16, 29, 26, 30, 31, 18},\n\t\t\t   {4, MTK_INVALID_LARBID, MTK_INVALID_LARBID, MTK_INVALID_LARBID, 6}},\n};\n\nstatic const struct mtk_iommu_plat_data mt8365_data = {\n\t.m4u_plat\t= M4U_MT8365,\n\t.flags\t\t= RESET_AXI | INT_ID_PORT_WIDTH_6,\n\t.inv_sel_reg\t= REG_MMU_INV_SEL_GEN1,\n\t.banks_num\t= 1,\n\t.banks_enable\t= {true},\n\t.iova_region\t= single_domain,\n\t.iova_region_nr\t= ARRAY_SIZE(single_domain),\n\t.larbid_remap\t= {{0}, {1}, {2}, {3}, {4}, {5}},  \n};\n\nstatic const struct of_device_id mtk_iommu_of_ids[] = {\n\t{ .compatible = \"mediatek,mt2712-m4u\", .data = &mt2712_data},\n\t{ .compatible = \"mediatek,mt6779-m4u\", .data = &mt6779_data},\n\t{ .compatible = \"mediatek,mt6795-m4u\", .data = &mt6795_data},\n\t{ .compatible = \"mediatek,mt8167-m4u\", .data = &mt8167_data},\n\t{ .compatible = \"mediatek,mt8173-m4u\", .data = &mt8173_data},\n\t{ .compatible = \"mediatek,mt8183-m4u\", .data = &mt8183_data},\n\t{ .compatible = \"mediatek,mt8186-iommu-mm\",    .data = &mt8186_data_mm},  \n\t{ .compatible = \"mediatek,mt8188-iommu-infra\", .data = &mt8188_data_infra},\n\t{ .compatible = \"mediatek,mt8188-iommu-vdo\",   .data = &mt8188_data_vdo},\n\t{ .compatible = \"mediatek,mt8188-iommu-vpp\",   .data = &mt8188_data_vpp},\n\t{ .compatible = \"mediatek,mt8192-m4u\", .data = &mt8192_data},\n\t{ .compatible = \"mediatek,mt8195-iommu-infra\", .data = &mt8195_data_infra},\n\t{ .compatible = \"mediatek,mt8195-iommu-vdo\",   .data = &mt8195_data_vdo},\n\t{ .compatible = \"mediatek,mt8195-iommu-vpp\",   .data = &mt8195_data_vpp},\n\t{ .compatible = \"mediatek,mt8365-m4u\", .data = &mt8365_data},\n\t{}\n};\n\nstatic struct platform_driver mtk_iommu_driver = {\n\t.probe\t= mtk_iommu_probe,\n\t.remove_new = mtk_iommu_remove,\n\t.driver\t= {\n\t\t.name = \"mtk-iommu\",\n\t\t.of_match_table = mtk_iommu_of_ids,\n\t\t.pm = &mtk_iommu_pm_ops,\n\t}\n};\nmodule_platform_driver(mtk_iommu_driver);\n\nMODULE_DESCRIPTION(\"IOMMU API for MediaTek M4U implementations\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}