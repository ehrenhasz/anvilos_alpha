{
  "module_name": "omap-iommu-debug.c",
  "hash_id": "8b6d7c8b3b545a981cf744543ad810beb463d3094a8b96b23fe82dacb4a5ee85",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iommu/omap-iommu-debug.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/pm_runtime.h>\n#include <linux/debugfs.h>\n#include <linux/platform_data/iommu-omap.h>\n\n#include \"omap-iopgtable.h\"\n#include \"omap-iommu.h\"\n\nstatic DEFINE_MUTEX(iommu_debug_lock);\n\nstatic struct dentry *iommu_debug_root;\n\nstatic inline bool is_omap_iommu_detached(struct omap_iommu *obj)\n{\n\treturn !obj->domain;\n}\n\n#define pr_reg(name)\t\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tssize_t bytes;\t\t\t\t\t\t\\\n\t\tconst char *str = \"%20s: %08x\\n\";\t\t\t\\\n\t\tconst int maxcol = 32;\t\t\t\t\t\\\n\t\tif (len < maxcol)\t\t\t\t\t\\\n\t\t\tgoto out;\t\t\t\t\t\\\n\t\tbytes = scnprintf(p, maxcol, str, __stringify(name),\t\\\n\t\t\t\t iommu_read_reg(obj, MMU_##name));\t\\\n\t\tp += bytes;\t\t\t\t\t\t\\\n\t\tlen -= bytes;\t\t\t\t\t\t\\\n\t} while (0)\n\nstatic ssize_t\nomap2_iommu_dump_ctx(struct omap_iommu *obj, char *buf, ssize_t len)\n{\n\tchar *p = buf;\n\n\tpr_reg(REVISION);\n\tpr_reg(IRQSTATUS);\n\tpr_reg(IRQENABLE);\n\tpr_reg(WALKING_ST);\n\tpr_reg(CNTL);\n\tpr_reg(FAULT_AD);\n\tpr_reg(TTB);\n\tpr_reg(LOCK);\n\tpr_reg(LD_TLB);\n\tpr_reg(CAM);\n\tpr_reg(RAM);\n\tpr_reg(GFLUSH);\n\tpr_reg(FLUSH_ENTRY);\n\tpr_reg(READ_CAM);\n\tpr_reg(READ_RAM);\n\tpr_reg(EMU_FAULT_AD);\nout:\n\treturn p - buf;\n}\n\nstatic ssize_t omap_iommu_dump_ctx(struct omap_iommu *obj, char *buf,\n\t\t\t\t   ssize_t bytes)\n{\n\tif (!obj || !buf)\n\t\treturn -EINVAL;\n\n\tpm_runtime_get_sync(obj->dev);\n\n\tbytes = omap2_iommu_dump_ctx(obj, buf, bytes);\n\n\tpm_runtime_put_sync(obj->dev);\n\n\treturn bytes;\n}\n\nstatic ssize_t debug_read_regs(struct file *file, char __user *userbuf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct omap_iommu *obj = file->private_data;\n\tchar *p, *buf;\n\tssize_t bytes;\n\n\tif (is_omap_iommu_detached(obj))\n\t\treturn -EPERM;\n\n\tbuf = kmalloc(count, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tp = buf;\n\n\tmutex_lock(&iommu_debug_lock);\n\n\tbytes = omap_iommu_dump_ctx(obj, p, count);\n\tif (bytes < 0)\n\t\tgoto err;\n\tbytes = simple_read_from_buffer(userbuf, count, ppos, buf, bytes);\n\nerr:\n\tmutex_unlock(&iommu_debug_lock);\n\tkfree(buf);\n\n\treturn bytes;\n}\n\nstatic int\n__dump_tlb_entries(struct omap_iommu *obj, struct cr_regs *crs, int num)\n{\n\tint i;\n\tstruct iotlb_lock saved;\n\tstruct cr_regs tmp;\n\tstruct cr_regs *p = crs;\n\n\tpm_runtime_get_sync(obj->dev);\n\tiotlb_lock_get(obj, &saved);\n\n\tfor_each_iotlb_cr(obj, num, i, tmp) {\n\t\tif (!iotlb_cr_valid(&tmp))\n\t\t\tcontinue;\n\t\t*p++ = tmp;\n\t}\n\n\tiotlb_lock_set(obj, &saved);\n\tpm_runtime_put_sync(obj->dev);\n\n\treturn  p - crs;\n}\n\nstatic ssize_t iotlb_dump_cr(struct omap_iommu *obj, struct cr_regs *cr,\n\t\t\t     struct seq_file *s)\n{\n\tseq_printf(s, \"%08x %08x %01x\\n\", cr->cam, cr->ram,\n\t\t   (cr->cam & MMU_CAM_P) ? 1 : 0);\n\treturn 0;\n}\n\nstatic size_t omap_dump_tlb_entries(struct omap_iommu *obj, struct seq_file *s)\n{\n\tint i, num;\n\tstruct cr_regs *cr;\n\n\tnum = obj->nr_tlb_entries;\n\n\tcr = kcalloc(num, sizeof(*cr), GFP_KERNEL);\n\tif (!cr)\n\t\treturn 0;\n\n\tnum = __dump_tlb_entries(obj, cr, num);\n\tfor (i = 0; i < num; i++)\n\t\tiotlb_dump_cr(obj, cr + i, s);\n\tkfree(cr);\n\n\treturn 0;\n}\n\nstatic int tlb_show(struct seq_file *s, void *data)\n{\n\tstruct omap_iommu *obj = s->private;\n\n\tif (is_omap_iommu_detached(obj))\n\t\treturn -EPERM;\n\n\tmutex_lock(&iommu_debug_lock);\n\n\tseq_printf(s, \"%8s %8s\\n\", \"cam:\", \"ram:\");\n\tseq_puts(s, \"-----------------------------------------\\n\");\n\tomap_dump_tlb_entries(obj, s);\n\n\tmutex_unlock(&iommu_debug_lock);\n\n\treturn 0;\n}\n\nstatic void dump_ioptable(struct seq_file *s)\n{\n\tint i, j;\n\tu32 da;\n\tu32 *iopgd, *iopte;\n\tstruct omap_iommu *obj = s->private;\n\n\tspin_lock(&obj->page_table_lock);\n\n\tiopgd = iopgd_offset(obj, 0);\n\tfor (i = 0; i < PTRS_PER_IOPGD; i++, iopgd++) {\n\t\tif (!*iopgd)\n\t\t\tcontinue;\n\n\t\tif (!(*iopgd & IOPGD_TABLE)) {\n\t\t\tda = i << IOPGD_SHIFT;\n\t\t\tseq_printf(s, \"1: 0x%08x 0x%08x\\n\", da, *iopgd);\n\t\t\tcontinue;\n\t\t}\n\n\t\tiopte = iopte_offset(iopgd, 0);\n\t\tfor (j = 0; j < PTRS_PER_IOPTE; j++, iopte++) {\n\t\t\tif (!*iopte)\n\t\t\t\tcontinue;\n\n\t\t\tda = (i << IOPGD_SHIFT) + (j << IOPTE_SHIFT);\n\t\t\tseq_printf(s, \"2: 0x%08x 0x%08x\\n\", da, *iopte);\n\t\t}\n\t}\n\n\tspin_unlock(&obj->page_table_lock);\n}\n\nstatic int pagetable_show(struct seq_file *s, void *data)\n{\n\tstruct omap_iommu *obj = s->private;\n\n\tif (is_omap_iommu_detached(obj))\n\t\treturn -EPERM;\n\n\tmutex_lock(&iommu_debug_lock);\n\n\tseq_printf(s, \"L: %8s %8s\\n\", \"da:\", \"pte:\");\n\tseq_puts(s, \"--------------------------\\n\");\n\tdump_ioptable(s);\n\n\tmutex_unlock(&iommu_debug_lock);\n\n\treturn 0;\n}\n\n#define DEBUG_FOPS_RO(name)\t\t\t\t\t\t\\\n\tstatic const struct file_operations name##_fops = {\t        \\\n\t\t.open = simple_open,\t\t\t\t\t\\\n\t\t.read = debug_read_##name,\t\t\t\t\\\n\t\t.llseek = generic_file_llseek,\t\t\t\t\\\n\t}\n\nDEBUG_FOPS_RO(regs);\nDEFINE_SHOW_ATTRIBUTE(tlb);\nDEFINE_SHOW_ATTRIBUTE(pagetable);\n\nvoid omap_iommu_debugfs_add(struct omap_iommu *obj)\n{\n\tstruct dentry *d;\n\n\tif (!iommu_debug_root)\n\t\treturn;\n\n\td = debugfs_create_dir(obj->name, iommu_debug_root);\n\tobj->debug_dir = d;\n\n\tdebugfs_create_u32(\"nr_tlb_entries\", 0400, d, &obj->nr_tlb_entries);\n\tdebugfs_create_file(\"regs\", 0400, d, obj, &regs_fops);\n\tdebugfs_create_file(\"tlb\", 0400, d, obj, &tlb_fops);\n\tdebugfs_create_file(\"pagetable\", 0400, d, obj, &pagetable_fops);\n}\n\nvoid omap_iommu_debugfs_remove(struct omap_iommu *obj)\n{\n\tif (!obj->debug_dir)\n\t\treturn;\n\n\tdebugfs_remove_recursive(obj->debug_dir);\n}\n\nvoid __init omap_iommu_debugfs_init(void)\n{\n\tiommu_debug_root = debugfs_create_dir(\"omap_iommu\", NULL);\n}\n\nvoid __exit omap_iommu_debugfs_exit(void)\n{\n\tdebugfs_remove(iommu_debug_root);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}