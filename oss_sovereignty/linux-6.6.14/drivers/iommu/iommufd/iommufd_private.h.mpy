{
  "module_name": "iommufd_private.h",
  "hash_id": "15716c603a6ca01632cc9b2621c52d2f84bf3130756af0eb888e3707f855d369",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iommu/iommufd/iommufd_private.h",
  "human_readable_source": " \n \n#ifndef __IOMMUFD_PRIVATE_H\n#define __IOMMUFD_PRIVATE_H\n\n#include <linux/rwsem.h>\n#include <linux/xarray.h>\n#include <linux/refcount.h>\n#include <linux/uaccess.h>\n\nstruct iommu_domain;\nstruct iommu_group;\nstruct iommu_option;\nstruct iommufd_device;\n\nstruct iommufd_ctx {\n\tstruct file *file;\n\tstruct xarray objects;\n\tstruct xarray groups;\n\n\tu8 account_mode;\n\t \n\tu8 no_iommu_mode;\n\tstruct iommufd_ioas *vfio_ioas;\n};\n\n \nstruct io_pagetable {\n\tstruct rw_semaphore domains_rwsem;\n\tstruct xarray domains;\n\tstruct xarray access_list;\n\tunsigned int next_domain_id;\n\n\tstruct rw_semaphore iova_rwsem;\n\tstruct rb_root_cached area_itree;\n\t \n\tstruct rb_root_cached allowed_itree;\n\t \n\tstruct rb_root_cached reserved_itree;\n\tu8 disable_large_pages;\n\tunsigned long iova_alignment;\n};\n\nvoid iopt_init_table(struct io_pagetable *iopt);\nvoid iopt_destroy_table(struct io_pagetable *iopt);\nint iopt_get_pages(struct io_pagetable *iopt, unsigned long iova,\n\t\t   unsigned long length, struct list_head *pages_list);\nvoid iopt_free_pages_list(struct list_head *pages_list);\nenum {\n\tIOPT_ALLOC_IOVA = 1 << 0,\n};\nint iopt_map_user_pages(struct iommufd_ctx *ictx, struct io_pagetable *iopt,\n\t\t\tunsigned long *iova, void __user *uptr,\n\t\t\tunsigned long length, int iommu_prot,\n\t\t\tunsigned int flags);\nint iopt_map_pages(struct io_pagetable *iopt, struct list_head *pages_list,\n\t\t   unsigned long length, unsigned long *dst_iova,\n\t\t   int iommu_prot, unsigned int flags);\nint iopt_unmap_iova(struct io_pagetable *iopt, unsigned long iova,\n\t\t    unsigned long length, unsigned long *unmapped);\nint iopt_unmap_all(struct io_pagetable *iopt, unsigned long *unmapped);\n\nvoid iommufd_access_notify_unmap(struct io_pagetable *iopt, unsigned long iova,\n\t\t\t\t unsigned long length);\nint iopt_table_add_domain(struct io_pagetable *iopt,\n\t\t\t  struct iommu_domain *domain);\nvoid iopt_table_remove_domain(struct io_pagetable *iopt,\n\t\t\t      struct iommu_domain *domain);\nint iopt_table_enforce_dev_resv_regions(struct io_pagetable *iopt,\n\t\t\t\t\tstruct device *dev,\n\t\t\t\t\tphys_addr_t *sw_msi_start);\nint iopt_set_allow_iova(struct io_pagetable *iopt,\n\t\t\tstruct rb_root_cached *allowed_iova);\nint iopt_reserve_iova(struct io_pagetable *iopt, unsigned long start,\n\t\t      unsigned long last, void *owner);\nvoid iopt_remove_reserved_iova(struct io_pagetable *iopt, void *owner);\nint iopt_cut_iova(struct io_pagetable *iopt, unsigned long *iovas,\n\t\t  size_t num_iovas);\nvoid iopt_enable_large_pages(struct io_pagetable *iopt);\nint iopt_disable_large_pages(struct io_pagetable *iopt);\n\nstruct iommufd_ucmd {\n\tstruct iommufd_ctx *ictx;\n\tvoid __user *ubuffer;\n\tu32 user_size;\n\tvoid *cmd;\n};\n\nint iommufd_vfio_ioctl(struct iommufd_ctx *ictx, unsigned int cmd,\n\t\t       unsigned long arg);\n\n \nstatic inline int iommufd_ucmd_respond(struct iommufd_ucmd *ucmd,\n\t\t\t\t       size_t cmd_len)\n{\n\tif (copy_to_user(ucmd->ubuffer, ucmd->cmd,\n\t\t\t min_t(size_t, ucmd->user_size, cmd_len)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nenum iommufd_object_type {\n\tIOMMUFD_OBJ_NONE,\n\tIOMMUFD_OBJ_ANY = IOMMUFD_OBJ_NONE,\n\tIOMMUFD_OBJ_DEVICE,\n\tIOMMUFD_OBJ_HW_PAGETABLE,\n\tIOMMUFD_OBJ_IOAS,\n\tIOMMUFD_OBJ_ACCESS,\n#ifdef CONFIG_IOMMUFD_TEST\n\tIOMMUFD_OBJ_SELFTEST,\n#endif\n\tIOMMUFD_OBJ_MAX,\n};\n\n \nstruct iommufd_object {\n\tstruct rw_semaphore destroy_rwsem;\n\trefcount_t users;\n\tenum iommufd_object_type type;\n\tunsigned int id;\n};\n\nstatic inline bool iommufd_lock_obj(struct iommufd_object *obj)\n{\n\tif (!down_read_trylock(&obj->destroy_rwsem))\n\t\treturn false;\n\tif (!refcount_inc_not_zero(&obj->users)) {\n\t\tup_read(&obj->destroy_rwsem);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstruct iommufd_object *iommufd_get_object(struct iommufd_ctx *ictx, u32 id,\n\t\t\t\t\t  enum iommufd_object_type type);\nstatic inline void iommufd_put_object(struct iommufd_object *obj)\n{\n\trefcount_dec(&obj->users);\n\tup_read(&obj->destroy_rwsem);\n}\n\nvoid iommufd_object_abort(struct iommufd_ctx *ictx, struct iommufd_object *obj);\nvoid iommufd_object_abort_and_destroy(struct iommufd_ctx *ictx,\n\t\t\t\t      struct iommufd_object *obj);\nvoid iommufd_object_finalize(struct iommufd_ctx *ictx,\n\t\t\t     struct iommufd_object *obj);\nvoid __iommufd_object_destroy_user(struct iommufd_ctx *ictx,\n\t\t\t\t   struct iommufd_object *obj, bool allow_fail);\nstatic inline void iommufd_object_destroy_user(struct iommufd_ctx *ictx,\n\t\t\t\t\t       struct iommufd_object *obj)\n{\n\t__iommufd_object_destroy_user(ictx, obj, false);\n}\nstatic inline void iommufd_object_deref_user(struct iommufd_ctx *ictx,\n\t\t\t\t\t     struct iommufd_object *obj)\n{\n\t__iommufd_object_destroy_user(ictx, obj, true);\n}\n\nstruct iommufd_object *_iommufd_object_alloc(struct iommufd_ctx *ictx,\n\t\t\t\t\t     size_t size,\n\t\t\t\t\t     enum iommufd_object_type type);\n\n#define iommufd_object_alloc(ictx, ptr, type)                                  \\\n\tcontainer_of(_iommufd_object_alloc(                                    \\\n\t\t\t     ictx,                                             \\\n\t\t\t     sizeof(*(ptr)) + BUILD_BUG_ON_ZERO(               \\\n\t\t\t\t\t\t      offsetof(typeof(*(ptr)), \\\n\t\t\t\t\t\t\t       obj) != 0),     \\\n\t\t\t     type),                                            \\\n\t\t     typeof(*(ptr)), obj)\n\n \nstruct iommufd_ioas {\n\tstruct iommufd_object obj;\n\tstruct io_pagetable iopt;\n\tstruct mutex mutex;\n\tstruct list_head hwpt_list;\n};\n\nstatic inline struct iommufd_ioas *iommufd_get_ioas(struct iommufd_ctx *ictx,\n\t\t\t\t\t\t    u32 id)\n{\n\treturn container_of(iommufd_get_object(ictx, id,\n\t\t\t\t\t       IOMMUFD_OBJ_IOAS),\n\t\t\t    struct iommufd_ioas, obj);\n}\n\nstruct iommufd_ioas *iommufd_ioas_alloc(struct iommufd_ctx *ictx);\nint iommufd_ioas_alloc_ioctl(struct iommufd_ucmd *ucmd);\nvoid iommufd_ioas_destroy(struct iommufd_object *obj);\nint iommufd_ioas_iova_ranges(struct iommufd_ucmd *ucmd);\nint iommufd_ioas_allow_iovas(struct iommufd_ucmd *ucmd);\nint iommufd_ioas_map(struct iommufd_ucmd *ucmd);\nint iommufd_ioas_copy(struct iommufd_ucmd *ucmd);\nint iommufd_ioas_unmap(struct iommufd_ucmd *ucmd);\nint iommufd_ioas_option(struct iommufd_ucmd *ucmd);\nint iommufd_option_rlimit_mode(struct iommu_option *cmd,\n\t\t\t       struct iommufd_ctx *ictx);\n\nint iommufd_vfio_ioas(struct iommufd_ucmd *ucmd);\n\n \nstruct iommufd_hw_pagetable {\n\tstruct iommufd_object obj;\n\tstruct iommufd_ioas *ioas;\n\tstruct iommu_domain *domain;\n\tbool auto_domain : 1;\n\tbool enforce_cache_coherency : 1;\n\tbool msi_cookie : 1;\n\t \n\tstruct list_head hwpt_item;\n};\n\nstruct iommufd_hw_pagetable *\niommufd_hw_pagetable_alloc(struct iommufd_ctx *ictx, struct iommufd_ioas *ioas,\n\t\t\t   struct iommufd_device *idev, bool immediate_attach);\nint iommufd_hw_pagetable_enforce_cc(struct iommufd_hw_pagetable *hwpt);\nint iommufd_hw_pagetable_attach(struct iommufd_hw_pagetable *hwpt,\n\t\t\t\tstruct iommufd_device *idev);\nstruct iommufd_hw_pagetable *\niommufd_hw_pagetable_detach(struct iommufd_device *idev);\nvoid iommufd_hw_pagetable_destroy(struct iommufd_object *obj);\nvoid iommufd_hw_pagetable_abort(struct iommufd_object *obj);\nint iommufd_hwpt_alloc(struct iommufd_ucmd *ucmd);\n\nstatic inline void iommufd_hw_pagetable_put(struct iommufd_ctx *ictx,\n\t\t\t\t\t    struct iommufd_hw_pagetable *hwpt)\n{\n\tlockdep_assert_not_held(&hwpt->ioas->mutex);\n\tif (hwpt->auto_domain)\n\t\tiommufd_object_deref_user(ictx, &hwpt->obj);\n\telse\n\t\trefcount_dec(&hwpt->obj.users);\n}\n\nstruct iommufd_group {\n\tstruct kref ref;\n\tstruct mutex lock;\n\tstruct iommufd_ctx *ictx;\n\tstruct iommu_group *group;\n\tstruct iommufd_hw_pagetable *hwpt;\n\tstruct list_head device_list;\n\tphys_addr_t sw_msi_start;\n};\n\n \nstruct iommufd_device {\n\tstruct iommufd_object obj;\n\tstruct iommufd_ctx *ictx;\n\tstruct iommufd_group *igroup;\n\tstruct list_head group_item;\n\t \n\tstruct device *dev;\n\tbool enforce_cache_coherency;\n};\n\nstatic inline struct iommufd_device *\niommufd_get_device(struct iommufd_ucmd *ucmd, u32 id)\n{\n\treturn container_of(iommufd_get_object(ucmd->ictx, id,\n\t\t\t\t\t       IOMMUFD_OBJ_DEVICE),\n\t\t\t    struct iommufd_device, obj);\n}\n\nvoid iommufd_device_destroy(struct iommufd_object *obj);\nint iommufd_get_hw_info(struct iommufd_ucmd *ucmd);\n\nstruct iommufd_access {\n\tstruct iommufd_object obj;\n\tstruct iommufd_ctx *ictx;\n\tstruct iommufd_ioas *ioas;\n\tstruct iommufd_ioas *ioas_unpin;\n\tstruct mutex ioas_lock;\n\tconst struct iommufd_access_ops *ops;\n\tvoid *data;\n\tunsigned long iova_alignment;\n\tu32 iopt_access_list_id;\n};\n\nint iopt_add_access(struct io_pagetable *iopt, struct iommufd_access *access);\nvoid iopt_remove_access(struct io_pagetable *iopt,\n\t\t\tstruct iommufd_access *access,\n\t\t\tu32 iopt_access_list_id);\nvoid iommufd_access_destroy_object(struct iommufd_object *obj);\n\n#ifdef CONFIG_IOMMUFD_TEST\nint iommufd_test(struct iommufd_ucmd *ucmd);\nvoid iommufd_selftest_destroy(struct iommufd_object *obj);\nextern size_t iommufd_test_memory_limit;\nvoid iommufd_test_syz_conv_iova_id(struct iommufd_ucmd *ucmd,\n\t\t\t\t   unsigned int ioas_id, u64 *iova, u32 *flags);\nbool iommufd_should_fail(void);\nint __init iommufd_test_init(void);\nvoid iommufd_test_exit(void);\nbool iommufd_selftest_is_mock_dev(struct device *dev);\n#else\nstatic inline void iommufd_test_syz_conv_iova_id(struct iommufd_ucmd *ucmd,\n\t\t\t\t\t\t unsigned int ioas_id,\n\t\t\t\t\t\t u64 *iova, u32 *flags)\n{\n}\nstatic inline bool iommufd_should_fail(void)\n{\n\treturn false;\n}\nstatic inline int __init iommufd_test_init(void)\n{\n\treturn 0;\n}\nstatic inline void iommufd_test_exit(void)\n{\n}\nstatic inline bool iommufd_selftest_is_mock_dev(struct device *dev)\n{\n\treturn false;\n}\n#endif\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}