{
  "module_name": "hw_pagetable.c",
  "hash_id": "f24ddd4edd92cc1fb10a678f1f5038bb21a869d2ae09ef0f4e2107d4f2c527f6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iommu/iommufd/hw_pagetable.c",
  "human_readable_source": "\n \n#include <linux/iommu.h>\n#include <uapi/linux/iommufd.h>\n\n#include \"iommufd_private.h\"\n\nvoid iommufd_hw_pagetable_destroy(struct iommufd_object *obj)\n{\n\tstruct iommufd_hw_pagetable *hwpt =\n\t\tcontainer_of(obj, struct iommufd_hw_pagetable, obj);\n\n\tif (!list_empty(&hwpt->hwpt_item)) {\n\t\tmutex_lock(&hwpt->ioas->mutex);\n\t\tlist_del(&hwpt->hwpt_item);\n\t\tmutex_unlock(&hwpt->ioas->mutex);\n\n\t\tiopt_table_remove_domain(&hwpt->ioas->iopt, hwpt->domain);\n\t}\n\n\tif (hwpt->domain)\n\t\tiommu_domain_free(hwpt->domain);\n\n\trefcount_dec(&hwpt->ioas->obj.users);\n}\n\nvoid iommufd_hw_pagetable_abort(struct iommufd_object *obj)\n{\n\tstruct iommufd_hw_pagetable *hwpt =\n\t\tcontainer_of(obj, struct iommufd_hw_pagetable, obj);\n\n\t \n\tlockdep_assert_held(&hwpt->ioas->mutex);\n\n\tif (!list_empty(&hwpt->hwpt_item)) {\n\t\tlist_del_init(&hwpt->hwpt_item);\n\t\tiopt_table_remove_domain(&hwpt->ioas->iopt, hwpt->domain);\n\t}\n\tiommufd_hw_pagetable_destroy(obj);\n}\n\nint iommufd_hw_pagetable_enforce_cc(struct iommufd_hw_pagetable *hwpt)\n{\n\tif (hwpt->enforce_cache_coherency)\n\t\treturn 0;\n\n\tif (hwpt->domain->ops->enforce_cache_coherency)\n\t\thwpt->enforce_cache_coherency =\n\t\t\thwpt->domain->ops->enforce_cache_coherency(\n\t\t\t\thwpt->domain);\n\tif (!hwpt->enforce_cache_coherency)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\n \nstruct iommufd_hw_pagetable *\niommufd_hw_pagetable_alloc(struct iommufd_ctx *ictx, struct iommufd_ioas *ioas,\n\t\t\t   struct iommufd_device *idev, bool immediate_attach)\n{\n\tstruct iommufd_hw_pagetable *hwpt;\n\tint rc;\n\n\tlockdep_assert_held(&ioas->mutex);\n\n\thwpt = iommufd_object_alloc(ictx, hwpt, IOMMUFD_OBJ_HW_PAGETABLE);\n\tif (IS_ERR(hwpt))\n\t\treturn hwpt;\n\n\tINIT_LIST_HEAD(&hwpt->hwpt_item);\n\t \n\trefcount_inc(&ioas->obj.users);\n\thwpt->ioas = ioas;\n\n\thwpt->domain = iommu_domain_alloc(idev->dev->bus);\n\tif (!hwpt->domain) {\n\t\trc = -ENOMEM;\n\t\tgoto out_abort;\n\t}\n\n\t \n\tif (idev->enforce_cache_coherency) {\n\t\trc = iommufd_hw_pagetable_enforce_cc(hwpt);\n\t\tif (WARN_ON(rc))\n\t\t\tgoto out_abort;\n\t}\n\n\t \n\tif (immediate_attach) {\n\t\trc = iommufd_hw_pagetable_attach(hwpt, idev);\n\t\tif (rc)\n\t\t\tgoto out_abort;\n\t}\n\n\trc = iopt_table_add_domain(&hwpt->ioas->iopt, hwpt->domain);\n\tif (rc)\n\t\tgoto out_detach;\n\tlist_add_tail(&hwpt->hwpt_item, &hwpt->ioas->hwpt_list);\n\treturn hwpt;\n\nout_detach:\n\tif (immediate_attach)\n\t\tiommufd_hw_pagetable_detach(idev);\nout_abort:\n\tiommufd_object_abort_and_destroy(ictx, &hwpt->obj);\n\treturn ERR_PTR(rc);\n}\n\nint iommufd_hwpt_alloc(struct iommufd_ucmd *ucmd)\n{\n\tstruct iommu_hwpt_alloc *cmd = ucmd->cmd;\n\tstruct iommufd_hw_pagetable *hwpt;\n\tstruct iommufd_device *idev;\n\tstruct iommufd_ioas *ioas;\n\tint rc;\n\n\tif (cmd->flags || cmd->__reserved)\n\t\treturn -EOPNOTSUPP;\n\n\tidev = iommufd_get_device(ucmd, cmd->dev_id);\n\tif (IS_ERR(idev))\n\t\treturn PTR_ERR(idev);\n\n\tioas = iommufd_get_ioas(ucmd->ictx, cmd->pt_id);\n\tif (IS_ERR(ioas)) {\n\t\trc = PTR_ERR(ioas);\n\t\tgoto out_put_idev;\n\t}\n\n\tmutex_lock(&ioas->mutex);\n\thwpt = iommufd_hw_pagetable_alloc(ucmd->ictx, ioas, idev, false);\n\tif (IS_ERR(hwpt)) {\n\t\trc = PTR_ERR(hwpt);\n\t\tgoto out_unlock;\n\t}\n\n\tcmd->out_hwpt_id = hwpt->obj.id;\n\trc = iommufd_ucmd_respond(ucmd, sizeof(*cmd));\n\tif (rc)\n\t\tgoto out_hwpt;\n\tiommufd_object_finalize(ucmd->ictx, &hwpt->obj);\n\tgoto out_unlock;\n\nout_hwpt:\n\tiommufd_object_abort_and_destroy(ucmd->ictx, &hwpt->obj);\nout_unlock:\n\tmutex_unlock(&ioas->mutex);\n\tiommufd_put_object(&ioas->obj);\nout_put_idev:\n\tiommufd_put_object(&idev->obj);\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}