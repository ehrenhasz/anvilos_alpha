{
  "module_name": "vfio_compat.c",
  "hash_id": "3e788b549a274d47aa8742dadefb00b8c12da6cbe985d53607f703f92c5fbb65",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iommu/iommufd/vfio_compat.c",
  "human_readable_source": "\n \n#include <linux/file.h>\n#include <linux/interval_tree.h>\n#include <linux/iommu.h>\n#include <linux/iommufd.h>\n#include <linux/slab.h>\n#include <linux/vfio.h>\n#include <uapi/linux/vfio.h>\n#include <uapi/linux/iommufd.h>\n\n#include \"iommufd_private.h\"\n\nstatic struct iommufd_ioas *get_compat_ioas(struct iommufd_ctx *ictx)\n{\n\tstruct iommufd_ioas *ioas = ERR_PTR(-ENODEV);\n\n\txa_lock(&ictx->objects);\n\tif (!ictx->vfio_ioas || !iommufd_lock_obj(&ictx->vfio_ioas->obj))\n\t\tgoto out_unlock;\n\tioas = ictx->vfio_ioas;\nout_unlock:\n\txa_unlock(&ictx->objects);\n\treturn ioas;\n}\n\n \nint iommufd_vfio_compat_ioas_get_id(struct iommufd_ctx *ictx, u32 *out_ioas_id)\n{\n\tstruct iommufd_ioas *ioas;\n\n\tioas = get_compat_ioas(ictx);\n\tif (IS_ERR(ioas))\n\t\treturn PTR_ERR(ioas);\n\t*out_ioas_id = ioas->obj.id;\n\tiommufd_put_object(&ioas->obj);\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(iommufd_vfio_compat_ioas_get_id, IOMMUFD_VFIO);\n\n \nint iommufd_vfio_compat_set_no_iommu(struct iommufd_ctx *ictx)\n{\n\tint ret;\n\n\txa_lock(&ictx->objects);\n\tif (!ictx->vfio_ioas) {\n\t\tictx->no_iommu_mode = 1;\n\t\tret = 0;\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\txa_unlock(&ictx->objects);\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(iommufd_vfio_compat_set_no_iommu, IOMMUFD_VFIO);\n\n \nint iommufd_vfio_compat_ioas_create(struct iommufd_ctx *ictx)\n{\n\tstruct iommufd_ioas *ioas = NULL;\n\tint ret;\n\n\tioas = iommufd_ioas_alloc(ictx);\n\tif (IS_ERR(ioas))\n\t\treturn PTR_ERR(ioas);\n\n\txa_lock(&ictx->objects);\n\t \n\tif (ictx->no_iommu_mode) {\n\t\tret = -EINVAL;\n\t\tgoto out_abort;\n\t}\n\n\tif (ictx->vfio_ioas && iommufd_lock_obj(&ictx->vfio_ioas->obj)) {\n\t\tret = 0;\n\t\tiommufd_put_object(&ictx->vfio_ioas->obj);\n\t\tgoto out_abort;\n\t}\n\tictx->vfio_ioas = ioas;\n\txa_unlock(&ictx->objects);\n\n\t \n\tiommufd_object_finalize(ictx, &ioas->obj);\n\treturn 0;\n\nout_abort:\n\txa_unlock(&ictx->objects);\n\tiommufd_object_abort(ictx, &ioas->obj);\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(iommufd_vfio_compat_ioas_create, IOMMUFD_VFIO);\n\nint iommufd_vfio_ioas(struct iommufd_ucmd *ucmd)\n{\n\tstruct iommu_vfio_ioas *cmd = ucmd->cmd;\n\tstruct iommufd_ioas *ioas;\n\n\tif (cmd->__reserved)\n\t\treturn -EOPNOTSUPP;\n\tswitch (cmd->op) {\n\tcase IOMMU_VFIO_IOAS_GET:\n\t\tioas = get_compat_ioas(ucmd->ictx);\n\t\tif (IS_ERR(ioas))\n\t\t\treturn PTR_ERR(ioas);\n\t\tcmd->ioas_id = ioas->obj.id;\n\t\tiommufd_put_object(&ioas->obj);\n\t\treturn iommufd_ucmd_respond(ucmd, sizeof(*cmd));\n\n\tcase IOMMU_VFIO_IOAS_SET:\n\t\tioas = iommufd_get_ioas(ucmd->ictx, cmd->ioas_id);\n\t\tif (IS_ERR(ioas))\n\t\t\treturn PTR_ERR(ioas);\n\t\txa_lock(&ucmd->ictx->objects);\n\t\tucmd->ictx->vfio_ioas = ioas;\n\t\txa_unlock(&ucmd->ictx->objects);\n\t\tiommufd_put_object(&ioas->obj);\n\t\treturn 0;\n\n\tcase IOMMU_VFIO_IOAS_CLEAR:\n\t\txa_lock(&ucmd->ictx->objects);\n\t\tucmd->ictx->vfio_ioas = NULL;\n\t\txa_unlock(&ucmd->ictx->objects);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int iommufd_vfio_map_dma(struct iommufd_ctx *ictx, unsigned int cmd,\n\t\t\t\tvoid __user *arg)\n{\n\tu32 supported_flags = VFIO_DMA_MAP_FLAG_READ | VFIO_DMA_MAP_FLAG_WRITE;\n\tsize_t minsz = offsetofend(struct vfio_iommu_type1_dma_map, size);\n\tstruct vfio_iommu_type1_dma_map map;\n\tint iommu_prot = IOMMU_CACHE;\n\tstruct iommufd_ioas *ioas;\n\tunsigned long iova;\n\tint rc;\n\n\tif (copy_from_user(&map, arg, minsz))\n\t\treturn -EFAULT;\n\n\tif (map.argsz < minsz || map.flags & ~supported_flags)\n\t\treturn -EINVAL;\n\n\tif (map.flags & VFIO_DMA_MAP_FLAG_READ)\n\t\tiommu_prot |= IOMMU_READ;\n\tif (map.flags & VFIO_DMA_MAP_FLAG_WRITE)\n\t\tiommu_prot |= IOMMU_WRITE;\n\n\tioas = get_compat_ioas(ictx);\n\tif (IS_ERR(ioas))\n\t\treturn PTR_ERR(ioas);\n\n\t \n\tiova = map.iova;\n\trc = iopt_map_user_pages(ictx, &ioas->iopt, &iova, u64_to_user_ptr(map.vaddr),\n\t\t\t\t map.size, iommu_prot, 0);\n\tiommufd_put_object(&ioas->obj);\n\treturn rc;\n}\n\nstatic int iommufd_vfio_unmap_dma(struct iommufd_ctx *ictx, unsigned int cmd,\n\t\t\t\t  void __user *arg)\n{\n\tsize_t minsz = offsetofend(struct vfio_iommu_type1_dma_unmap, size);\n\t \n\tu32 supported_flags = VFIO_DMA_UNMAP_FLAG_ALL;\n\tstruct vfio_iommu_type1_dma_unmap unmap;\n\tunsigned long unmapped = 0;\n\tstruct iommufd_ioas *ioas;\n\tint rc;\n\n\tif (copy_from_user(&unmap, arg, minsz))\n\t\treturn -EFAULT;\n\n\tif (unmap.argsz < minsz || unmap.flags & ~supported_flags)\n\t\treturn -EINVAL;\n\n\tioas = get_compat_ioas(ictx);\n\tif (IS_ERR(ioas))\n\t\treturn PTR_ERR(ioas);\n\n\tif (unmap.flags & VFIO_DMA_UNMAP_FLAG_ALL) {\n\t\tif (unmap.iova != 0 || unmap.size != 0) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto err_put;\n\t\t}\n\t\trc = iopt_unmap_all(&ioas->iopt, &unmapped);\n\t} else {\n\t\tif (READ_ONCE(ioas->iopt.disable_large_pages)) {\n\t\t\t \n\t\t\tunsigned long iovas[] = { unmap.iova + unmap.size - 1,\n\t\t\t\t\t\t  unmap.iova - 1 };\n\n\t\t\trc = iopt_cut_iova(&ioas->iopt, iovas,\n\t\t\t\t\t   unmap.iova ? 2 : 1);\n\t\t\tif (rc)\n\t\t\t\tgoto err_put;\n\t\t}\n\t\trc = iopt_unmap_iova(&ioas->iopt, unmap.iova, unmap.size,\n\t\t\t\t     &unmapped);\n\t}\n\tunmap.size = unmapped;\n\tif (copy_to_user(arg, &unmap, minsz))\n\t\trc = -EFAULT;\n\nerr_put:\n\tiommufd_put_object(&ioas->obj);\n\treturn rc;\n}\n\nstatic int iommufd_vfio_cc_iommu(struct iommufd_ctx *ictx)\n{\n\tstruct iommufd_hw_pagetable *hwpt;\n\tstruct iommufd_ioas *ioas;\n\tint rc = 1;\n\n\tioas = get_compat_ioas(ictx);\n\tif (IS_ERR(ioas))\n\t\treturn PTR_ERR(ioas);\n\n\tmutex_lock(&ioas->mutex);\n\tlist_for_each_entry(hwpt, &ioas->hwpt_list, hwpt_item) {\n\t\tif (!hwpt->enforce_cache_coherency) {\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&ioas->mutex);\n\n\tiommufd_put_object(&ioas->obj);\n\treturn rc;\n}\n\nstatic int iommufd_vfio_check_extension(struct iommufd_ctx *ictx,\n\t\t\t\t\tunsigned long type)\n{\n\tswitch (type) {\n\tcase VFIO_TYPE1_IOMMU:\n\tcase VFIO_TYPE1v2_IOMMU:\n\tcase VFIO_UNMAP_ALL:\n\t\treturn 1;\n\n\tcase VFIO_NOIOMMU_IOMMU:\n\t\treturn IS_ENABLED(CONFIG_VFIO_NOIOMMU);\n\n\tcase VFIO_DMA_CC_IOMMU:\n\t\treturn iommufd_vfio_cc_iommu(ictx);\n\n\t \n\tcase VFIO_TYPE1_NESTING_IOMMU:\n\t\treturn 0;\n\n\t \n\tcase VFIO_UPDATE_VADDR:\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int iommufd_vfio_set_iommu(struct iommufd_ctx *ictx, unsigned long type)\n{\n\tbool no_iommu_mode = READ_ONCE(ictx->no_iommu_mode);\n\tstruct iommufd_ioas *ioas = NULL;\n\tint rc = 0;\n\n\t \n\tif (IS_ENABLED(CONFIG_VFIO_NOIOMMU) && type == VFIO_NOIOMMU_IOMMU &&\n\t    no_iommu_mode) {\n\t\tif (!capable(CAP_SYS_RAWIO))\n\t\t\treturn -EPERM;\n\t\treturn 0;\n\t}\n\n\tif ((type != VFIO_TYPE1_IOMMU && type != VFIO_TYPE1v2_IOMMU) ||\n\t    no_iommu_mode)\n\t\treturn -EINVAL;\n\n\t \n\tioas = get_compat_ioas(ictx);\n\tif (IS_ERR(ioas))\n\t\treturn PTR_ERR(ioas);\n\n\t \n\tif (type == VFIO_TYPE1_IOMMU)\n\t\trc = iopt_disable_large_pages(&ioas->iopt);\n\tiommufd_put_object(&ioas->obj);\n\treturn rc;\n}\n\nstatic unsigned long iommufd_get_pagesizes(struct iommufd_ioas *ioas)\n{\n\tstruct io_pagetable *iopt = &ioas->iopt;\n\tunsigned long pgsize_bitmap = ULONG_MAX;\n\tstruct iommu_domain *domain;\n\tunsigned long index;\n\n\tdown_read(&iopt->domains_rwsem);\n\txa_for_each(&iopt->domains, index, domain)\n\t\tpgsize_bitmap &= domain->pgsize_bitmap;\n\n\t \n\tif (pgsize_bitmap & ~PAGE_MASK) {\n\t\tpgsize_bitmap &= PAGE_MASK;\n\t\tpgsize_bitmap |= PAGE_SIZE;\n\t}\n\tpgsize_bitmap = max(pgsize_bitmap, ioas->iopt.iova_alignment);\n\tup_read(&iopt->domains_rwsem);\n\treturn pgsize_bitmap;\n}\n\nstatic int iommufd_fill_cap_iova(struct iommufd_ioas *ioas,\n\t\t\t\t struct vfio_info_cap_header __user *cur,\n\t\t\t\t size_t avail)\n{\n\tstruct vfio_iommu_type1_info_cap_iova_range __user *ucap_iovas =\n\t\tcontainer_of(cur,\n\t\t\t     struct vfio_iommu_type1_info_cap_iova_range __user,\n\t\t\t     header);\n\tstruct vfio_iommu_type1_info_cap_iova_range cap_iovas = {\n\t\t.header = {\n\t\t\t.id = VFIO_IOMMU_TYPE1_INFO_CAP_IOVA_RANGE,\n\t\t\t.version = 1,\n\t\t},\n\t};\n\tstruct interval_tree_span_iter span;\n\n\tinterval_tree_for_each_span(&span, &ioas->iopt.reserved_itree, 0,\n\t\t\t\t    ULONG_MAX) {\n\t\tstruct vfio_iova_range range;\n\n\t\tif (!span.is_hole)\n\t\t\tcontinue;\n\t\trange.start = span.start_hole;\n\t\trange.end = span.last_hole;\n\t\tif (avail >= struct_size(&cap_iovas, iova_ranges,\n\t\t\t\t\t cap_iovas.nr_iovas + 1) &&\n\t\t    copy_to_user(&ucap_iovas->iova_ranges[cap_iovas.nr_iovas],\n\t\t\t\t &range, sizeof(range)))\n\t\t\treturn -EFAULT;\n\t\tcap_iovas.nr_iovas++;\n\t}\n\tif (avail >= struct_size(&cap_iovas, iova_ranges, cap_iovas.nr_iovas) &&\n\t    copy_to_user(ucap_iovas, &cap_iovas, sizeof(cap_iovas)))\n\t\treturn -EFAULT;\n\treturn struct_size(&cap_iovas, iova_ranges, cap_iovas.nr_iovas);\n}\n\nstatic int iommufd_fill_cap_dma_avail(struct iommufd_ioas *ioas,\n\t\t\t\t      struct vfio_info_cap_header __user *cur,\n\t\t\t\t      size_t avail)\n{\n\tstruct vfio_iommu_type1_info_dma_avail cap_dma = {\n\t\t.header = {\n\t\t\t.id = VFIO_IOMMU_TYPE1_INFO_DMA_AVAIL,\n\t\t\t.version = 1,\n\t\t},\n\t\t \n\t\t.avail = U32_MAX,\n\t};\n\n\tif (avail >= sizeof(cap_dma) &&\n\t    copy_to_user(cur, &cap_dma, sizeof(cap_dma)))\n\t\treturn -EFAULT;\n\treturn sizeof(cap_dma);\n}\n\nstatic int iommufd_vfio_iommu_get_info(struct iommufd_ctx *ictx,\n\t\t\t\t       void __user *arg)\n{\n\ttypedef int (*fill_cap_fn)(struct iommufd_ioas *ioas,\n\t\t\t\t   struct vfio_info_cap_header __user *cur,\n\t\t\t\t   size_t avail);\n\tstatic const fill_cap_fn fill_fns[] = {\n\t\tiommufd_fill_cap_dma_avail,\n\t\tiommufd_fill_cap_iova,\n\t};\n\tsize_t minsz = offsetofend(struct vfio_iommu_type1_info, iova_pgsizes);\n\tstruct vfio_info_cap_header __user *last_cap = NULL;\n\tstruct vfio_iommu_type1_info info = {};\n\tstruct iommufd_ioas *ioas;\n\tsize_t total_cap_size;\n\tint rc;\n\tint i;\n\n\tif (copy_from_user(&info, arg, minsz))\n\t\treturn -EFAULT;\n\n\tif (info.argsz < minsz)\n\t\treturn -EINVAL;\n\tminsz = min_t(size_t, info.argsz, sizeof(info));\n\n\tioas = get_compat_ioas(ictx);\n\tif (IS_ERR(ioas))\n\t\treturn PTR_ERR(ioas);\n\n\tinfo.flags = VFIO_IOMMU_INFO_PGSIZES;\n\tinfo.iova_pgsizes = iommufd_get_pagesizes(ioas);\n\tinfo.cap_offset = 0;\n\n\tdown_read(&ioas->iopt.iova_rwsem);\n\ttotal_cap_size = sizeof(info);\n\tfor (i = 0; i != ARRAY_SIZE(fill_fns); i++) {\n\t\tint cap_size;\n\n\t\tif (info.argsz > total_cap_size)\n\t\t\tcap_size = fill_fns[i](ioas, arg + total_cap_size,\n\t\t\t\t\t       info.argsz - total_cap_size);\n\t\telse\n\t\t\tcap_size = fill_fns[i](ioas, NULL, 0);\n\t\tif (cap_size < 0) {\n\t\t\trc = cap_size;\n\t\t\tgoto out_put;\n\t\t}\n\t\tcap_size = ALIGN(cap_size, sizeof(u64));\n\n\t\tif (last_cap && info.argsz >= total_cap_size &&\n\t\t    put_user(total_cap_size, &last_cap->next)) {\n\t\t\trc = -EFAULT;\n\t\t\tgoto out_put;\n\t\t}\n\t\tlast_cap = arg + total_cap_size;\n\t\ttotal_cap_size += cap_size;\n\t}\n\n\t \n\tif (info.argsz >= total_cap_size)\n\t\tinfo.cap_offset = sizeof(info);\n\tinfo.argsz = total_cap_size;\n\tinfo.flags |= VFIO_IOMMU_INFO_CAPS;\n\tif (copy_to_user(arg, &info, minsz)) {\n\t\trc = -EFAULT;\n\t\tgoto out_put;\n\t}\n\trc = 0;\n\nout_put:\n\tup_read(&ioas->iopt.iova_rwsem);\n\tiommufd_put_object(&ioas->obj);\n\treturn rc;\n}\n\nint iommufd_vfio_ioctl(struct iommufd_ctx *ictx, unsigned int cmd,\n\t\t       unsigned long arg)\n{\n\tvoid __user *uarg = (void __user *)arg;\n\n\tswitch (cmd) {\n\tcase VFIO_GET_API_VERSION:\n\t\treturn VFIO_API_VERSION;\n\tcase VFIO_SET_IOMMU:\n\t\treturn iommufd_vfio_set_iommu(ictx, arg);\n\tcase VFIO_CHECK_EXTENSION:\n\t\treturn iommufd_vfio_check_extension(ictx, arg);\n\tcase VFIO_IOMMU_GET_INFO:\n\t\treturn iommufd_vfio_iommu_get_info(ictx, uarg);\n\tcase VFIO_IOMMU_MAP_DMA:\n\t\treturn iommufd_vfio_map_dma(ictx, cmd, uarg);\n\tcase VFIO_IOMMU_UNMAP_DMA:\n\t\treturn iommufd_vfio_unmap_dma(ictx, cmd, uarg);\n\tcase VFIO_IOMMU_DIRTY_PAGES:\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\treturn -ENOIOCTLCMD;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}