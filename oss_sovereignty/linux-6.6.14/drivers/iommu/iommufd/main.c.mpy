{
  "module_name": "main.c",
  "hash_id": "ffcae8225c710fe53fc66b0317c55c8f62659383dced4d4dc98036cd11dc0efb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iommu/iommufd/main.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) \"iommufd: \" fmt\n\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/miscdevice.h>\n#include <linux/mutex.h>\n#include <linux/bug.h>\n#include <uapi/linux/iommufd.h>\n#include <linux/iommufd.h>\n\n#include \"io_pagetable.h\"\n#include \"iommufd_private.h\"\n#include \"iommufd_test.h\"\n\nstruct iommufd_object_ops {\n\tvoid (*destroy)(struct iommufd_object *obj);\n\tvoid (*abort)(struct iommufd_object *obj);\n};\nstatic const struct iommufd_object_ops iommufd_object_ops[];\nstatic struct miscdevice vfio_misc_dev;\n\nstruct iommufd_object *_iommufd_object_alloc(struct iommufd_ctx *ictx,\n\t\t\t\t\t     size_t size,\n\t\t\t\t\t     enum iommufd_object_type type)\n{\n\tstatic struct lock_class_key obj_keys[IOMMUFD_OBJ_MAX];\n\tstruct iommufd_object *obj;\n\tint rc;\n\n\tobj = kzalloc(size, GFP_KERNEL_ACCOUNT);\n\tif (!obj)\n\t\treturn ERR_PTR(-ENOMEM);\n\tobj->type = type;\n\t \n\t__init_rwsem(&obj->destroy_rwsem, \"iommufd_object::destroy_rwsem\",\n\t\t     &obj_keys[type]);\n\trefcount_set(&obj->users, 1);\n\n\t \n\trc = xa_alloc(&ictx->objects, &obj->id, XA_ZERO_ENTRY,\n\t\t      xa_limit_31b, GFP_KERNEL_ACCOUNT);\n\tif (rc)\n\t\tgoto out_free;\n\treturn obj;\nout_free:\n\tkfree(obj);\n\treturn ERR_PTR(rc);\n}\n\n \nvoid iommufd_object_finalize(struct iommufd_ctx *ictx,\n\t\t\t     struct iommufd_object *obj)\n{\n\tvoid *old;\n\n\told = xa_store(&ictx->objects, obj->id, obj, GFP_KERNEL);\n\t \n\tWARN_ON(old);\n}\n\n \nvoid iommufd_object_abort(struct iommufd_ctx *ictx, struct iommufd_object *obj)\n{\n\tvoid *old;\n\n\told = xa_erase(&ictx->objects, obj->id);\n\tWARN_ON(old);\n\tkfree(obj);\n}\n\n \nvoid iommufd_object_abort_and_destroy(struct iommufd_ctx *ictx,\n\t\t\t\t      struct iommufd_object *obj)\n{\n\tif (iommufd_object_ops[obj->type].abort)\n\t\tiommufd_object_ops[obj->type].abort(obj);\n\telse\n\t\tiommufd_object_ops[obj->type].destroy(obj);\n\tiommufd_object_abort(ictx, obj);\n}\n\nstruct iommufd_object *iommufd_get_object(struct iommufd_ctx *ictx, u32 id,\n\t\t\t\t\t  enum iommufd_object_type type)\n{\n\tstruct iommufd_object *obj;\n\n\tif (iommufd_should_fail())\n\t\treturn ERR_PTR(-ENOENT);\n\n\txa_lock(&ictx->objects);\n\tobj = xa_load(&ictx->objects, id);\n\tif (!obj || (type != IOMMUFD_OBJ_ANY && obj->type != type) ||\n\t    !iommufd_lock_obj(obj))\n\t\tobj = ERR_PTR(-ENOENT);\n\txa_unlock(&ictx->objects);\n\treturn obj;\n}\n\n \nstatic struct iommufd_object *iommufd_object_remove(struct iommufd_ctx *ictx,\n\t\t\t\t\t\t    u32 id, bool extra_put)\n{\n\tstruct iommufd_object *obj;\n\tXA_STATE(xas, &ictx->objects, id);\n\n\txa_lock(&ictx->objects);\n\tobj = xas_load(&xas);\n\tif (xa_is_zero(obj) || !obj) {\n\t\tobj = ERR_PTR(-ENOENT);\n\t\tgoto out_xa;\n\t}\n\n\t \n\tif (extra_put)\n\t\trefcount_dec(&obj->users);\n\n\tif (!refcount_dec_if_one(&obj->users)) {\n\t\tobj = ERR_PTR(-EBUSY);\n\t\tgoto out_xa;\n\t}\n\n\txas_store(&xas, NULL);\n\tif (ictx->vfio_ioas == container_of(obj, struct iommufd_ioas, obj))\n\t\tictx->vfio_ioas = NULL;\n\nout_xa:\n\txa_unlock(&ictx->objects);\n\n\t \n\treturn obj;\n}\n\n \nvoid __iommufd_object_destroy_user(struct iommufd_ctx *ictx,\n\t\t\t\t   struct iommufd_object *obj, bool allow_fail)\n{\n\tstruct iommufd_object *ret;\n\n\t \n\tdown_write(&obj->destroy_rwsem);\n\tret = iommufd_object_remove(ictx, obj->id, true);\n\tup_write(&obj->destroy_rwsem);\n\n\tif (allow_fail && IS_ERR(ret))\n\t\treturn;\n\n\t \n\tif (WARN_ON(IS_ERR(ret)))\n\t\treturn;\n\n\tiommufd_object_ops[obj->type].destroy(obj);\n\tkfree(obj);\n}\n\nstatic int iommufd_destroy(struct iommufd_ucmd *ucmd)\n{\n\tstruct iommu_destroy *cmd = ucmd->cmd;\n\tstruct iommufd_object *obj;\n\n\tobj = iommufd_object_remove(ucmd->ictx, cmd->id, false);\n\tif (IS_ERR(obj))\n\t\treturn PTR_ERR(obj);\n\tiommufd_object_ops[obj->type].destroy(obj);\n\tkfree(obj);\n\treturn 0;\n}\n\nstatic int iommufd_fops_open(struct inode *inode, struct file *filp)\n{\n\tstruct iommufd_ctx *ictx;\n\n\tictx = kzalloc(sizeof(*ictx), GFP_KERNEL_ACCOUNT);\n\tif (!ictx)\n\t\treturn -ENOMEM;\n\n\t \n\tif (IS_ENABLED(CONFIG_IOMMUFD_VFIO_CONTAINER) &&\n\t    filp->private_data == &vfio_misc_dev) {\n\t\tictx->account_mode = IOPT_PAGES_ACCOUNT_MM;\n\t\tpr_info_once(\"IOMMUFD is providing /dev/vfio/vfio, not VFIO.\\n\");\n\t}\n\n\txa_init_flags(&ictx->objects, XA_FLAGS_ALLOC1 | XA_FLAGS_ACCOUNT);\n\txa_init(&ictx->groups);\n\tictx->file = filp;\n\tfilp->private_data = ictx;\n\treturn 0;\n}\n\nstatic int iommufd_fops_release(struct inode *inode, struct file *filp)\n{\n\tstruct iommufd_ctx *ictx = filp->private_data;\n\tstruct iommufd_object *obj;\n\n\t \n\twhile (!xa_empty(&ictx->objects)) {\n\t\tunsigned int destroyed = 0;\n\t\tunsigned long index;\n\n\t\txa_for_each(&ictx->objects, index, obj) {\n\t\t\tif (!refcount_dec_if_one(&obj->users))\n\t\t\t\tcontinue;\n\t\t\tdestroyed++;\n\t\t\txa_erase(&ictx->objects, index);\n\t\t\tiommufd_object_ops[obj->type].destroy(obj);\n\t\t\tkfree(obj);\n\t\t}\n\t\t \n\t\tif (WARN_ON(!destroyed))\n\t\t\tbreak;\n\t}\n\tWARN_ON(!xa_empty(&ictx->groups));\n\tkfree(ictx);\n\treturn 0;\n}\n\nstatic int iommufd_option(struct iommufd_ucmd *ucmd)\n{\n\tstruct iommu_option *cmd = ucmd->cmd;\n\tint rc;\n\n\tif (cmd->__reserved)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (cmd->option_id) {\n\tcase IOMMU_OPTION_RLIMIT_MODE:\n\t\trc = iommufd_option_rlimit_mode(cmd, ucmd->ictx);\n\t\tbreak;\n\tcase IOMMU_OPTION_HUGE_PAGES:\n\t\trc = iommufd_ioas_option(ucmd);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif (rc)\n\t\treturn rc;\n\tif (copy_to_user(&((struct iommu_option __user *)ucmd->ubuffer)->val64,\n\t\t\t &cmd->val64, sizeof(cmd->val64)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nunion ucmd_buffer {\n\tstruct iommu_destroy destroy;\n\tstruct iommu_hw_info info;\n\tstruct iommu_hwpt_alloc hwpt;\n\tstruct iommu_ioas_alloc alloc;\n\tstruct iommu_ioas_allow_iovas allow_iovas;\n\tstruct iommu_ioas_copy ioas_copy;\n\tstruct iommu_ioas_iova_ranges iova_ranges;\n\tstruct iommu_ioas_map map;\n\tstruct iommu_ioas_unmap unmap;\n\tstruct iommu_option option;\n\tstruct iommu_vfio_ioas vfio_ioas;\n#ifdef CONFIG_IOMMUFD_TEST\n\tstruct iommu_test_cmd test;\n#endif\n};\n\nstruct iommufd_ioctl_op {\n\tunsigned int size;\n\tunsigned int min_size;\n\tunsigned int ioctl_num;\n\tint (*execute)(struct iommufd_ucmd *ucmd);\n};\n\n#define IOCTL_OP(_ioctl, _fn, _struct, _last)                                  \\\n\t[_IOC_NR(_ioctl) - IOMMUFD_CMD_BASE] = {                               \\\n\t\t.size = sizeof(_struct) +                                      \\\n\t\t\tBUILD_BUG_ON_ZERO(sizeof(union ucmd_buffer) <          \\\n\t\t\t\t\t  sizeof(_struct)),                    \\\n\t\t.min_size = offsetofend(_struct, _last),                       \\\n\t\t.ioctl_num = _ioctl,                                           \\\n\t\t.execute = _fn,                                                \\\n\t}\nstatic const struct iommufd_ioctl_op iommufd_ioctl_ops[] = {\n\tIOCTL_OP(IOMMU_DESTROY, iommufd_destroy, struct iommu_destroy, id),\n\tIOCTL_OP(IOMMU_GET_HW_INFO, iommufd_get_hw_info, struct iommu_hw_info,\n\t\t __reserved),\n\tIOCTL_OP(IOMMU_HWPT_ALLOC, iommufd_hwpt_alloc, struct iommu_hwpt_alloc,\n\t\t __reserved),\n\tIOCTL_OP(IOMMU_IOAS_ALLOC, iommufd_ioas_alloc_ioctl,\n\t\t struct iommu_ioas_alloc, out_ioas_id),\n\tIOCTL_OP(IOMMU_IOAS_ALLOW_IOVAS, iommufd_ioas_allow_iovas,\n\t\t struct iommu_ioas_allow_iovas, allowed_iovas),\n\tIOCTL_OP(IOMMU_IOAS_COPY, iommufd_ioas_copy, struct iommu_ioas_copy,\n\t\t src_iova),\n\tIOCTL_OP(IOMMU_IOAS_IOVA_RANGES, iommufd_ioas_iova_ranges,\n\t\t struct iommu_ioas_iova_ranges, out_iova_alignment),\n\tIOCTL_OP(IOMMU_IOAS_MAP, iommufd_ioas_map, struct iommu_ioas_map,\n\t\t iova),\n\tIOCTL_OP(IOMMU_IOAS_UNMAP, iommufd_ioas_unmap, struct iommu_ioas_unmap,\n\t\t length),\n\tIOCTL_OP(IOMMU_OPTION, iommufd_option, struct iommu_option,\n\t\t val64),\n\tIOCTL_OP(IOMMU_VFIO_IOAS, iommufd_vfio_ioas, struct iommu_vfio_ioas,\n\t\t __reserved),\n#ifdef CONFIG_IOMMUFD_TEST\n\tIOCTL_OP(IOMMU_TEST_CMD, iommufd_test, struct iommu_test_cmd, last),\n#endif\n};\n\nstatic long iommufd_fops_ioctl(struct file *filp, unsigned int cmd,\n\t\t\t       unsigned long arg)\n{\n\tstruct iommufd_ctx *ictx = filp->private_data;\n\tconst struct iommufd_ioctl_op *op;\n\tstruct iommufd_ucmd ucmd = {};\n\tunion ucmd_buffer buf;\n\tunsigned int nr;\n\tint ret;\n\n\tnr = _IOC_NR(cmd);\n\tif (nr < IOMMUFD_CMD_BASE ||\n\t    (nr - IOMMUFD_CMD_BASE) >= ARRAY_SIZE(iommufd_ioctl_ops))\n\t\treturn iommufd_vfio_ioctl(ictx, cmd, arg);\n\n\tucmd.ictx = ictx;\n\tucmd.ubuffer = (void __user *)arg;\n\tret = get_user(ucmd.user_size, (u32 __user *)ucmd.ubuffer);\n\tif (ret)\n\t\treturn ret;\n\n\top = &iommufd_ioctl_ops[nr - IOMMUFD_CMD_BASE];\n\tif (op->ioctl_num != cmd)\n\t\treturn -ENOIOCTLCMD;\n\tif (ucmd.user_size < op->min_size)\n\t\treturn -EINVAL;\n\n\tucmd.cmd = &buf;\n\tret = copy_struct_from_user(ucmd.cmd, op->size, ucmd.ubuffer,\n\t\t\t\t    ucmd.user_size);\n\tif (ret)\n\t\treturn ret;\n\tret = op->execute(&ucmd);\n\treturn ret;\n}\n\nstatic const struct file_operations iommufd_fops = {\n\t.owner = THIS_MODULE,\n\t.open = iommufd_fops_open,\n\t.release = iommufd_fops_release,\n\t.unlocked_ioctl = iommufd_fops_ioctl,\n};\n\n \nvoid iommufd_ctx_get(struct iommufd_ctx *ictx)\n{\n\tget_file(ictx->file);\n}\nEXPORT_SYMBOL_NS_GPL(iommufd_ctx_get, IOMMUFD);\n\n \nstruct iommufd_ctx *iommufd_ctx_from_file(struct file *file)\n{\n\tstruct iommufd_ctx *ictx;\n\n\tif (file->f_op != &iommufd_fops)\n\t\treturn ERR_PTR(-EBADFD);\n\tictx = file->private_data;\n\tiommufd_ctx_get(ictx);\n\treturn ictx;\n}\nEXPORT_SYMBOL_NS_GPL(iommufd_ctx_from_file, IOMMUFD);\n\n \nstruct iommufd_ctx *iommufd_ctx_from_fd(int fd)\n{\n\tstruct file *file;\n\n\tfile = fget(fd);\n\tif (!file)\n\t\treturn ERR_PTR(-EBADF);\n\n\tif (file->f_op != &iommufd_fops) {\n\t\tfput(file);\n\t\treturn ERR_PTR(-EBADFD);\n\t}\n\t \n\treturn file->private_data;\n}\nEXPORT_SYMBOL_NS_GPL(iommufd_ctx_from_fd, IOMMUFD);\n\n \nvoid iommufd_ctx_put(struct iommufd_ctx *ictx)\n{\n\tfput(ictx->file);\n}\nEXPORT_SYMBOL_NS_GPL(iommufd_ctx_put, IOMMUFD);\n\nstatic const struct iommufd_object_ops iommufd_object_ops[] = {\n\t[IOMMUFD_OBJ_ACCESS] = {\n\t\t.destroy = iommufd_access_destroy_object,\n\t},\n\t[IOMMUFD_OBJ_DEVICE] = {\n\t\t.destroy = iommufd_device_destroy,\n\t},\n\t[IOMMUFD_OBJ_IOAS] = {\n\t\t.destroy = iommufd_ioas_destroy,\n\t},\n\t[IOMMUFD_OBJ_HW_PAGETABLE] = {\n\t\t.destroy = iommufd_hw_pagetable_destroy,\n\t\t.abort = iommufd_hw_pagetable_abort,\n\t},\n#ifdef CONFIG_IOMMUFD_TEST\n\t[IOMMUFD_OBJ_SELFTEST] = {\n\t\t.destroy = iommufd_selftest_destroy,\n\t},\n#endif\n};\n\nstatic struct miscdevice iommu_misc_dev = {\n\t.minor = MISC_DYNAMIC_MINOR,\n\t.name = \"iommu\",\n\t.fops = &iommufd_fops,\n\t.nodename = \"iommu\",\n\t.mode = 0660,\n};\n\n\nstatic struct miscdevice vfio_misc_dev = {\n\t.minor = VFIO_MINOR,\n\t.name = \"vfio\",\n\t.fops = &iommufd_fops,\n\t.nodename = \"vfio/vfio\",\n\t.mode = 0666,\n};\n\nstatic int __init iommufd_init(void)\n{\n\tint ret;\n\n\tret = misc_register(&iommu_misc_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (IS_ENABLED(CONFIG_IOMMUFD_VFIO_CONTAINER)) {\n\t\tret = misc_register(&vfio_misc_dev);\n\t\tif (ret)\n\t\t\tgoto err_misc;\n\t}\n\tret = iommufd_test_init();\n\tif (ret)\n\t\tgoto err_vfio_misc;\n\treturn 0;\n\nerr_vfio_misc:\n\tif (IS_ENABLED(CONFIG_IOMMUFD_VFIO_CONTAINER))\n\t\tmisc_deregister(&vfio_misc_dev);\nerr_misc:\n\tmisc_deregister(&iommu_misc_dev);\n\treturn ret;\n}\n\nstatic void __exit iommufd_exit(void)\n{\n\tiommufd_test_exit();\n\tif (IS_ENABLED(CONFIG_IOMMUFD_VFIO_CONTAINER))\n\t\tmisc_deregister(&vfio_misc_dev);\n\tmisc_deregister(&iommu_misc_dev);\n}\n\nmodule_init(iommufd_init);\nmodule_exit(iommufd_exit);\n\n#if IS_ENABLED(CONFIG_IOMMUFD_VFIO_CONTAINER)\nMODULE_ALIAS_MISCDEV(VFIO_MINOR);\nMODULE_ALIAS(\"devname:vfio/vfio\");\n#endif\nMODULE_IMPORT_NS(IOMMUFD_INTERNAL);\nMODULE_DESCRIPTION(\"I/O Address Space Management for passthrough devices\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}