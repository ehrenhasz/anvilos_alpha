{
  "module_name": "ioas.c",
  "hash_id": "35fd0acf16b0573fa67e89a36085aa6b54a6dfba1833c6a01cc70c848dbde0a4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iommu/iommufd/ioas.c",
  "human_readable_source": "\n \n#include <linux/interval_tree.h>\n#include <linux/iommufd.h>\n#include <linux/iommu.h>\n#include <uapi/linux/iommufd.h>\n\n#include \"io_pagetable.h\"\n\nvoid iommufd_ioas_destroy(struct iommufd_object *obj)\n{\n\tstruct iommufd_ioas *ioas = container_of(obj, struct iommufd_ioas, obj);\n\tint rc;\n\n\trc = iopt_unmap_all(&ioas->iopt, NULL);\n\tWARN_ON(rc && rc != -ENOENT);\n\tiopt_destroy_table(&ioas->iopt);\n\tmutex_destroy(&ioas->mutex);\n}\n\nstruct iommufd_ioas *iommufd_ioas_alloc(struct iommufd_ctx *ictx)\n{\n\tstruct iommufd_ioas *ioas;\n\n\tioas = iommufd_object_alloc(ictx, ioas, IOMMUFD_OBJ_IOAS);\n\tif (IS_ERR(ioas))\n\t\treturn ioas;\n\n\tiopt_init_table(&ioas->iopt);\n\tINIT_LIST_HEAD(&ioas->hwpt_list);\n\tmutex_init(&ioas->mutex);\n\treturn ioas;\n}\n\nint iommufd_ioas_alloc_ioctl(struct iommufd_ucmd *ucmd)\n{\n\tstruct iommu_ioas_alloc *cmd = ucmd->cmd;\n\tstruct iommufd_ioas *ioas;\n\tint rc;\n\n\tif (cmd->flags)\n\t\treturn -EOPNOTSUPP;\n\n\tioas = iommufd_ioas_alloc(ucmd->ictx);\n\tif (IS_ERR(ioas))\n\t\treturn PTR_ERR(ioas);\n\n\tcmd->out_ioas_id = ioas->obj.id;\n\trc = iommufd_ucmd_respond(ucmd, sizeof(*cmd));\n\tif (rc)\n\t\tgoto out_table;\n\tiommufd_object_finalize(ucmd->ictx, &ioas->obj);\n\treturn 0;\n\nout_table:\n\tiommufd_object_abort_and_destroy(ucmd->ictx, &ioas->obj);\n\treturn rc;\n}\n\nint iommufd_ioas_iova_ranges(struct iommufd_ucmd *ucmd)\n{\n\tstruct iommu_iova_range __user *ranges;\n\tstruct iommu_ioas_iova_ranges *cmd = ucmd->cmd;\n\tstruct iommufd_ioas *ioas;\n\tstruct interval_tree_span_iter span;\n\tu32 max_iovas;\n\tint rc;\n\n\tif (cmd->__reserved)\n\t\treturn -EOPNOTSUPP;\n\n\tioas = iommufd_get_ioas(ucmd->ictx, cmd->ioas_id);\n\tif (IS_ERR(ioas))\n\t\treturn PTR_ERR(ioas);\n\n\tdown_read(&ioas->iopt.iova_rwsem);\n\tmax_iovas = cmd->num_iovas;\n\tranges = u64_to_user_ptr(cmd->allowed_iovas);\n\tcmd->num_iovas = 0;\n\tcmd->out_iova_alignment = ioas->iopt.iova_alignment;\n\tinterval_tree_for_each_span(&span, &ioas->iopt.reserved_itree, 0,\n\t\t\t\t    ULONG_MAX) {\n\t\tif (!span.is_hole)\n\t\t\tcontinue;\n\t\tif (cmd->num_iovas < max_iovas) {\n\t\t\tstruct iommu_iova_range elm = {\n\t\t\t\t.start = span.start_hole,\n\t\t\t\t.last = span.last_hole,\n\t\t\t};\n\n\t\t\tif (copy_to_user(&ranges[cmd->num_iovas], &elm,\n\t\t\t\t\t sizeof(elm))) {\n\t\t\t\trc = -EFAULT;\n\t\t\t\tgoto out_put;\n\t\t\t}\n\t\t}\n\t\tcmd->num_iovas++;\n\t}\n\trc = iommufd_ucmd_respond(ucmd, sizeof(*cmd));\n\tif (rc)\n\t\tgoto out_put;\n\tif (cmd->num_iovas > max_iovas)\n\t\trc = -EMSGSIZE;\nout_put:\n\tup_read(&ioas->iopt.iova_rwsem);\n\tiommufd_put_object(&ioas->obj);\n\treturn rc;\n}\n\nstatic int iommufd_ioas_load_iovas(struct rb_root_cached *itree,\n\t\t\t\t   struct iommu_iova_range __user *ranges,\n\t\t\t\t   u32 num)\n{\n\tu32 i;\n\n\tfor (i = 0; i != num; i++) {\n\t\tstruct iommu_iova_range range;\n\t\tstruct iopt_allowed *allowed;\n\n\t\tif (copy_from_user(&range, ranges + i, sizeof(range)))\n\t\t\treturn -EFAULT;\n\n\t\tif (range.start >= range.last)\n\t\t\treturn -EINVAL;\n\n\t\tif (interval_tree_iter_first(itree, range.start, range.last))\n\t\t\treturn -EINVAL;\n\n\t\tallowed = kzalloc(sizeof(*allowed), GFP_KERNEL_ACCOUNT);\n\t\tif (!allowed)\n\t\t\treturn -ENOMEM;\n\t\tallowed->node.start = range.start;\n\t\tallowed->node.last = range.last;\n\n\t\tinterval_tree_insert(&allowed->node, itree);\n\t}\n\treturn 0;\n}\n\nint iommufd_ioas_allow_iovas(struct iommufd_ucmd *ucmd)\n{\n\tstruct iommu_ioas_allow_iovas *cmd = ucmd->cmd;\n\tstruct rb_root_cached allowed_iova = RB_ROOT_CACHED;\n\tstruct interval_tree_node *node;\n\tstruct iommufd_ioas *ioas;\n\tstruct io_pagetable *iopt;\n\tint rc = 0;\n\n\tif (cmd->__reserved)\n\t\treturn -EOPNOTSUPP;\n\n\tioas = iommufd_get_ioas(ucmd->ictx, cmd->ioas_id);\n\tif (IS_ERR(ioas))\n\t\treturn PTR_ERR(ioas);\n\tiopt = &ioas->iopt;\n\n\trc = iommufd_ioas_load_iovas(&allowed_iova,\n\t\t\t\t     u64_to_user_ptr(cmd->allowed_iovas),\n\t\t\t\t     cmd->num_iovas);\n\tif (rc)\n\t\tgoto out_free;\n\n\t \n\trc = iopt_set_allow_iova(iopt, &allowed_iova);\nout_free:\n\twhile ((node = interval_tree_iter_first(&allowed_iova, 0, ULONG_MAX))) {\n\t\tinterval_tree_remove(node, &allowed_iova);\n\t\tkfree(container_of(node, struct iopt_allowed, node));\n\t}\n\tiommufd_put_object(&ioas->obj);\n\treturn rc;\n}\n\nstatic int conv_iommu_prot(u32 map_flags)\n{\n\t \n\tint iommu_prot = IOMMU_CACHE;\n\n\tif (map_flags & IOMMU_IOAS_MAP_WRITEABLE)\n\t\tiommu_prot |= IOMMU_WRITE;\n\tif (map_flags & IOMMU_IOAS_MAP_READABLE)\n\t\tiommu_prot |= IOMMU_READ;\n\treturn iommu_prot;\n}\n\nint iommufd_ioas_map(struct iommufd_ucmd *ucmd)\n{\n\tstruct iommu_ioas_map *cmd = ucmd->cmd;\n\tunsigned long iova = cmd->iova;\n\tstruct iommufd_ioas *ioas;\n\tunsigned int flags = 0;\n\tint rc;\n\n\tif ((cmd->flags &\n\t     ~(IOMMU_IOAS_MAP_FIXED_IOVA | IOMMU_IOAS_MAP_WRITEABLE |\n\t       IOMMU_IOAS_MAP_READABLE)) ||\n\t    cmd->__reserved)\n\t\treturn -EOPNOTSUPP;\n\tif (cmd->iova >= ULONG_MAX || cmd->length >= ULONG_MAX)\n\t\treturn -EOVERFLOW;\n\n\tioas = iommufd_get_ioas(ucmd->ictx, cmd->ioas_id);\n\tif (IS_ERR(ioas))\n\t\treturn PTR_ERR(ioas);\n\n\tif (!(cmd->flags & IOMMU_IOAS_MAP_FIXED_IOVA))\n\t\tflags = IOPT_ALLOC_IOVA;\n\trc = iopt_map_user_pages(ucmd->ictx, &ioas->iopt, &iova,\n\t\t\t\t u64_to_user_ptr(cmd->user_va), cmd->length,\n\t\t\t\t conv_iommu_prot(cmd->flags), flags);\n\tif (rc)\n\t\tgoto out_put;\n\n\tcmd->iova = iova;\n\trc = iommufd_ucmd_respond(ucmd, sizeof(*cmd));\nout_put:\n\tiommufd_put_object(&ioas->obj);\n\treturn rc;\n}\n\nint iommufd_ioas_copy(struct iommufd_ucmd *ucmd)\n{\n\tstruct iommu_ioas_copy *cmd = ucmd->cmd;\n\tstruct iommufd_ioas *src_ioas;\n\tstruct iommufd_ioas *dst_ioas;\n\tunsigned int flags = 0;\n\tLIST_HEAD(pages_list);\n\tunsigned long iova;\n\tint rc;\n\n\tiommufd_test_syz_conv_iova_id(ucmd, cmd->src_ioas_id, &cmd->src_iova,\n\t\t\t\t      &cmd->flags);\n\n\tif ((cmd->flags &\n\t     ~(IOMMU_IOAS_MAP_FIXED_IOVA | IOMMU_IOAS_MAP_WRITEABLE |\n\t       IOMMU_IOAS_MAP_READABLE)))\n\t\treturn -EOPNOTSUPP;\n\tif (cmd->length >= ULONG_MAX || cmd->src_iova >= ULONG_MAX ||\n\t    cmd->dst_iova >= ULONG_MAX)\n\t\treturn -EOVERFLOW;\n\n\tsrc_ioas = iommufd_get_ioas(ucmd->ictx, cmd->src_ioas_id);\n\tif (IS_ERR(src_ioas))\n\t\treturn PTR_ERR(src_ioas);\n\trc = iopt_get_pages(&src_ioas->iopt, cmd->src_iova, cmd->length,\n\t\t\t    &pages_list);\n\tiommufd_put_object(&src_ioas->obj);\n\tif (rc)\n\t\treturn rc;\n\n\tdst_ioas = iommufd_get_ioas(ucmd->ictx, cmd->dst_ioas_id);\n\tif (IS_ERR(dst_ioas)) {\n\t\trc = PTR_ERR(dst_ioas);\n\t\tgoto out_pages;\n\t}\n\n\tif (!(cmd->flags & IOMMU_IOAS_MAP_FIXED_IOVA))\n\t\tflags = IOPT_ALLOC_IOVA;\n\tiova = cmd->dst_iova;\n\trc = iopt_map_pages(&dst_ioas->iopt, &pages_list, cmd->length, &iova,\n\t\t\t    conv_iommu_prot(cmd->flags), flags);\n\tif (rc)\n\t\tgoto out_put_dst;\n\n\tcmd->dst_iova = iova;\n\trc = iommufd_ucmd_respond(ucmd, sizeof(*cmd));\nout_put_dst:\n\tiommufd_put_object(&dst_ioas->obj);\nout_pages:\n\tiopt_free_pages_list(&pages_list);\n\treturn rc;\n}\n\nint iommufd_ioas_unmap(struct iommufd_ucmd *ucmd)\n{\n\tstruct iommu_ioas_unmap *cmd = ucmd->cmd;\n\tstruct iommufd_ioas *ioas;\n\tunsigned long unmapped = 0;\n\tint rc;\n\n\tioas = iommufd_get_ioas(ucmd->ictx, cmd->ioas_id);\n\tif (IS_ERR(ioas))\n\t\treturn PTR_ERR(ioas);\n\n\tif (cmd->iova == 0 && cmd->length == U64_MAX) {\n\t\trc = iopt_unmap_all(&ioas->iopt, &unmapped);\n\t\tif (rc)\n\t\t\tgoto out_put;\n\t} else {\n\t\tif (cmd->iova >= ULONG_MAX || cmd->length >= ULONG_MAX) {\n\t\t\trc = -EOVERFLOW;\n\t\t\tgoto out_put;\n\t\t}\n\t\trc = iopt_unmap_iova(&ioas->iopt, cmd->iova, cmd->length,\n\t\t\t\t     &unmapped);\n\t\tif (rc)\n\t\t\tgoto out_put;\n\t}\n\n\tcmd->length = unmapped;\n\trc = iommufd_ucmd_respond(ucmd, sizeof(*cmd));\n\nout_put:\n\tiommufd_put_object(&ioas->obj);\n\treturn rc;\n}\n\nint iommufd_option_rlimit_mode(struct iommu_option *cmd,\n\t\t\t       struct iommufd_ctx *ictx)\n{\n\tif (cmd->object_id)\n\t\treturn -EOPNOTSUPP;\n\n\tif (cmd->op == IOMMU_OPTION_OP_GET) {\n\t\tcmd->val64 = ictx->account_mode == IOPT_PAGES_ACCOUNT_MM;\n\t\treturn 0;\n\t}\n\tif (cmd->op == IOMMU_OPTION_OP_SET) {\n\t\tint rc = 0;\n\n\t\tif (!capable(CAP_SYS_RESOURCE))\n\t\t\treturn -EPERM;\n\n\t\txa_lock(&ictx->objects);\n\t\tif (!xa_empty(&ictx->objects)) {\n\t\t\trc = -EBUSY;\n\t\t} else {\n\t\t\tif (cmd->val64 == 0)\n\t\t\t\tictx->account_mode = IOPT_PAGES_ACCOUNT_USER;\n\t\t\telse if (cmd->val64 == 1)\n\t\t\t\tictx->account_mode = IOPT_PAGES_ACCOUNT_MM;\n\t\t\telse\n\t\t\t\trc = -EINVAL;\n\t\t}\n\t\txa_unlock(&ictx->objects);\n\n\t\treturn rc;\n\t}\n\treturn -EOPNOTSUPP;\n}\n\nstatic int iommufd_ioas_option_huge_pages(struct iommu_option *cmd,\n\t\t\t\t\t  struct iommufd_ioas *ioas)\n{\n\tif (cmd->op == IOMMU_OPTION_OP_GET) {\n\t\tcmd->val64 = !ioas->iopt.disable_large_pages;\n\t\treturn 0;\n\t}\n\tif (cmd->op == IOMMU_OPTION_OP_SET) {\n\t\tif (cmd->val64 == 0)\n\t\t\treturn iopt_disable_large_pages(&ioas->iopt);\n\t\tif (cmd->val64 == 1) {\n\t\t\tiopt_enable_large_pages(&ioas->iopt);\n\t\t\treturn 0;\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\treturn -EOPNOTSUPP;\n}\n\nint iommufd_ioas_option(struct iommufd_ucmd *ucmd)\n{\n\tstruct iommu_option *cmd = ucmd->cmd;\n\tstruct iommufd_ioas *ioas;\n\tint rc = 0;\n\n\tif (cmd->__reserved)\n\t\treturn -EOPNOTSUPP;\n\n\tioas = iommufd_get_ioas(ucmd->ictx, cmd->object_id);\n\tif (IS_ERR(ioas))\n\t\treturn PTR_ERR(ioas);\n\n\tswitch (cmd->option_id) {\n\tcase IOMMU_OPTION_HUGE_PAGES:\n\t\trc = iommufd_ioas_option_huge_pages(cmd, ioas);\n\t\tbreak;\n\tdefault:\n\t\trc = -EOPNOTSUPP;\n\t}\n\n\tiommufd_put_object(&ioas->obj);\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}