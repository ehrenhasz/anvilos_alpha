{
  "module_name": "selftest.c",
  "hash_id": "2118be009add4e6f1f6f78d7c4a8d866d161cd0bc71b94eb0520fb8d91b7e859",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iommu/iommufd/selftest.c",
  "human_readable_source": "\n \n#include <linux/slab.h>\n#include <linux/iommu.h>\n#include <linux/xarray.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/fault-inject.h>\n#include <linux/platform_device.h>\n#include <uapi/linux/iommufd.h>\n\n#include \"../iommu-priv.h\"\n#include \"io_pagetable.h\"\n#include \"iommufd_private.h\"\n#include \"iommufd_test.h\"\n\nstatic DECLARE_FAULT_ATTR(fail_iommufd);\nstatic struct dentry *dbgfs_root;\nstatic struct platform_device *selftest_iommu_dev;\n\nsize_t iommufd_test_memory_limit = 65536;\n\nenum {\n\tMOCK_IO_PAGE_SIZE = PAGE_SIZE / 2,\n\n\t \n\tMOCK_PFN_MASK = ULONG_MAX / MOCK_IO_PAGE_SIZE,\n\n\t_MOCK_PFN_START = MOCK_PFN_MASK + 1,\n\tMOCK_PFN_START_IOVA = _MOCK_PFN_START,\n\tMOCK_PFN_LAST_IOVA = _MOCK_PFN_START,\n};\n\n \nstatic unsigned long iommufd_test_syz_conv_iova(struct io_pagetable *iopt,\n\t\t\t\t\t\tu64 *iova)\n{\n\tstruct syz_layout {\n\t\t__u32 nth_area;\n\t\t__u32 offset;\n\t};\n\tstruct syz_layout *syz = (void *)iova;\n\tunsigned int nth = syz->nth_area;\n\tstruct iopt_area *area;\n\n\tdown_read(&iopt->iova_rwsem);\n\tfor (area = iopt_area_iter_first(iopt, 0, ULONG_MAX); area;\n\t     area = iopt_area_iter_next(area, 0, ULONG_MAX)) {\n\t\tif (nth == 0) {\n\t\t\tup_read(&iopt->iova_rwsem);\n\t\t\treturn iopt_area_iova(area) + syz->offset;\n\t\t}\n\t\tnth--;\n\t}\n\tup_read(&iopt->iova_rwsem);\n\n\treturn 0;\n}\n\nvoid iommufd_test_syz_conv_iova_id(struct iommufd_ucmd *ucmd,\n\t\t\t\t   unsigned int ioas_id, u64 *iova, u32 *flags)\n{\n\tstruct iommufd_ioas *ioas;\n\n\tif (!(*flags & MOCK_FLAGS_ACCESS_SYZ))\n\t\treturn;\n\t*flags &= ~(u32)MOCK_FLAGS_ACCESS_SYZ;\n\n\tioas = iommufd_get_ioas(ucmd->ictx, ioas_id);\n\tif (IS_ERR(ioas))\n\t\treturn;\n\t*iova = iommufd_test_syz_conv_iova(&ioas->iopt, iova);\n\tiommufd_put_object(&ioas->obj);\n}\n\nstruct mock_iommu_domain {\n\tstruct iommu_domain domain;\n\tstruct xarray pfns;\n};\n\nenum selftest_obj_type {\n\tTYPE_IDEV,\n};\n\nstruct mock_dev {\n\tstruct device dev;\n};\n\nstruct selftest_obj {\n\tstruct iommufd_object obj;\n\tenum selftest_obj_type type;\n\n\tunion {\n\t\tstruct {\n\t\t\tstruct iommufd_device *idev;\n\t\t\tstruct iommufd_ctx *ictx;\n\t\t\tstruct mock_dev *mock_dev;\n\t\t} idev;\n\t};\n};\n\nstatic void mock_domain_blocking_free(struct iommu_domain *domain)\n{\n}\n\nstatic int mock_domain_nop_attach(struct iommu_domain *domain,\n\t\t\t\t  struct device *dev)\n{\n\treturn 0;\n}\n\nstatic const struct iommu_domain_ops mock_blocking_ops = {\n\t.free = mock_domain_blocking_free,\n\t.attach_dev = mock_domain_nop_attach,\n};\n\nstatic struct iommu_domain mock_blocking_domain = {\n\t.type = IOMMU_DOMAIN_BLOCKED,\n\t.ops = &mock_blocking_ops,\n};\n\nstatic void *mock_domain_hw_info(struct device *dev, u32 *length, u32 *type)\n{\n\tstruct iommu_test_hw_info *info;\n\n\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinfo->test_reg = IOMMU_HW_INFO_SELFTEST_REGVAL;\n\t*length = sizeof(*info);\n\t*type = IOMMU_HW_INFO_TYPE_SELFTEST;\n\n\treturn info;\n}\n\nstatic struct iommu_domain *mock_domain_alloc(unsigned int iommu_domain_type)\n{\n\tstruct mock_iommu_domain *mock;\n\n\tif (iommu_domain_type == IOMMU_DOMAIN_BLOCKED)\n\t\treturn &mock_blocking_domain;\n\n\tif (iommu_domain_type != IOMMU_DOMAIN_UNMANAGED)\n\t\treturn NULL;\n\n\tmock = kzalloc(sizeof(*mock), GFP_KERNEL);\n\tif (!mock)\n\t\treturn NULL;\n\tmock->domain.geometry.aperture_start = MOCK_APERTURE_START;\n\tmock->domain.geometry.aperture_end = MOCK_APERTURE_LAST;\n\tmock->domain.pgsize_bitmap = MOCK_IO_PAGE_SIZE;\n\txa_init(&mock->pfns);\n\treturn &mock->domain;\n}\n\nstatic void mock_domain_free(struct iommu_domain *domain)\n{\n\tstruct mock_iommu_domain *mock =\n\t\tcontainer_of(domain, struct mock_iommu_domain, domain);\n\n\tWARN_ON(!xa_empty(&mock->pfns));\n\tkfree(mock);\n}\n\nstatic int mock_domain_map_pages(struct iommu_domain *domain,\n\t\t\t\t unsigned long iova, phys_addr_t paddr,\n\t\t\t\t size_t pgsize, size_t pgcount, int prot,\n\t\t\t\t gfp_t gfp, size_t *mapped)\n{\n\tstruct mock_iommu_domain *mock =\n\t\tcontainer_of(domain, struct mock_iommu_domain, domain);\n\tunsigned long flags = MOCK_PFN_START_IOVA;\n\tunsigned long start_iova = iova;\n\n\t \n\tif (iommufd_should_fail())\n\t\treturn -ENOENT;\n\n\tWARN_ON(iova % MOCK_IO_PAGE_SIZE);\n\tWARN_ON(pgsize % MOCK_IO_PAGE_SIZE);\n\tfor (; pgcount; pgcount--) {\n\t\tsize_t cur;\n\n\t\tfor (cur = 0; cur != pgsize; cur += MOCK_IO_PAGE_SIZE) {\n\t\t\tvoid *old;\n\n\t\t\tif (pgcount == 1 && cur + MOCK_IO_PAGE_SIZE == pgsize)\n\t\t\t\tflags = MOCK_PFN_LAST_IOVA;\n\t\t\told = xa_store(&mock->pfns, iova / MOCK_IO_PAGE_SIZE,\n\t\t\t\t       xa_mk_value((paddr / MOCK_IO_PAGE_SIZE) |\n\t\t\t\t\t\t   flags),\n\t\t\t\t       gfp);\n\t\t\tif (xa_is_err(old)) {\n\t\t\t\tfor (; start_iova != iova;\n\t\t\t\t     start_iova += MOCK_IO_PAGE_SIZE)\n\t\t\t\t\txa_erase(&mock->pfns,\n\t\t\t\t\t\t start_iova /\n\t\t\t\t\t\t\t MOCK_IO_PAGE_SIZE);\n\t\t\t\treturn xa_err(old);\n\t\t\t}\n\t\t\tWARN_ON(old);\n\t\t\tiova += MOCK_IO_PAGE_SIZE;\n\t\t\tpaddr += MOCK_IO_PAGE_SIZE;\n\t\t\t*mapped += MOCK_IO_PAGE_SIZE;\n\t\t\tflags = 0;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic size_t mock_domain_unmap_pages(struct iommu_domain *domain,\n\t\t\t\t      unsigned long iova, size_t pgsize,\n\t\t\t\t      size_t pgcount,\n\t\t\t\t      struct iommu_iotlb_gather *iotlb_gather)\n{\n\tstruct mock_iommu_domain *mock =\n\t\tcontainer_of(domain, struct mock_iommu_domain, domain);\n\tbool first = true;\n\tsize_t ret = 0;\n\tvoid *ent;\n\n\tWARN_ON(iova % MOCK_IO_PAGE_SIZE);\n\tWARN_ON(pgsize % MOCK_IO_PAGE_SIZE);\n\n\tfor (; pgcount; pgcount--) {\n\t\tsize_t cur;\n\n\t\tfor (cur = 0; cur != pgsize; cur += MOCK_IO_PAGE_SIZE) {\n\t\t\tent = xa_erase(&mock->pfns, iova / MOCK_IO_PAGE_SIZE);\n\t\t\tWARN_ON(!ent);\n\t\t\t \n\t\t\tif (first) {\n\t\t\t\tWARN_ON(!(xa_to_value(ent) &\n\t\t\t\t\t  MOCK_PFN_START_IOVA));\n\t\t\t\tfirst = false;\n\t\t\t}\n\t\t\tif (pgcount == 1 && cur + MOCK_IO_PAGE_SIZE == pgsize)\n\t\t\t\tWARN_ON(!(xa_to_value(ent) &\n\t\t\t\t\t  MOCK_PFN_LAST_IOVA));\n\n\t\t\tiova += MOCK_IO_PAGE_SIZE;\n\t\t\tret += MOCK_IO_PAGE_SIZE;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic phys_addr_t mock_domain_iova_to_phys(struct iommu_domain *domain,\n\t\t\t\t\t    dma_addr_t iova)\n{\n\tstruct mock_iommu_domain *mock =\n\t\tcontainer_of(domain, struct mock_iommu_domain, domain);\n\tvoid *ent;\n\n\tWARN_ON(iova % MOCK_IO_PAGE_SIZE);\n\tent = xa_load(&mock->pfns, iova / MOCK_IO_PAGE_SIZE);\n\tWARN_ON(!ent);\n\treturn (xa_to_value(ent) & MOCK_PFN_MASK) * MOCK_IO_PAGE_SIZE;\n}\n\nstatic bool mock_domain_capable(struct device *dev, enum iommu_cap cap)\n{\n\treturn cap == IOMMU_CAP_CACHE_COHERENCY;\n}\n\nstatic void mock_domain_set_plaform_dma_ops(struct device *dev)\n{\n\t \n}\n\nstatic struct iommu_device mock_iommu_device = {\n};\n\nstatic struct iommu_device *mock_probe_device(struct device *dev)\n{\n\treturn &mock_iommu_device;\n}\n\nstatic const struct iommu_ops mock_ops = {\n\t.owner = THIS_MODULE,\n\t.pgsize_bitmap = MOCK_IO_PAGE_SIZE,\n\t.hw_info = mock_domain_hw_info,\n\t.domain_alloc = mock_domain_alloc,\n\t.capable = mock_domain_capable,\n\t.set_platform_dma_ops = mock_domain_set_plaform_dma_ops,\n\t.device_group = generic_device_group,\n\t.probe_device = mock_probe_device,\n\t.default_domain_ops =\n\t\t&(struct iommu_domain_ops){\n\t\t\t.free = mock_domain_free,\n\t\t\t.attach_dev = mock_domain_nop_attach,\n\t\t\t.map_pages = mock_domain_map_pages,\n\t\t\t.unmap_pages = mock_domain_unmap_pages,\n\t\t\t.iova_to_phys = mock_domain_iova_to_phys,\n\t\t},\n};\n\nstatic inline struct iommufd_hw_pagetable *\nget_md_pagetable(struct iommufd_ucmd *ucmd, u32 mockpt_id,\n\t\t struct mock_iommu_domain **mock)\n{\n\tstruct iommufd_hw_pagetable *hwpt;\n\tstruct iommufd_object *obj;\n\n\tobj = iommufd_get_object(ucmd->ictx, mockpt_id,\n\t\t\t\t IOMMUFD_OBJ_HW_PAGETABLE);\n\tif (IS_ERR(obj))\n\t\treturn ERR_CAST(obj);\n\thwpt = container_of(obj, struct iommufd_hw_pagetable, obj);\n\tif (hwpt->domain->ops != mock_ops.default_domain_ops) {\n\t\tiommufd_put_object(&hwpt->obj);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\t*mock = container_of(hwpt->domain, struct mock_iommu_domain, domain);\n\treturn hwpt;\n}\n\nstruct mock_bus_type {\n\tstruct bus_type bus;\n\tstruct notifier_block nb;\n};\n\nstatic struct mock_bus_type iommufd_mock_bus_type = {\n\t.bus = {\n\t\t.name = \"iommufd_mock\",\n\t},\n};\n\nstatic atomic_t mock_dev_num;\n\nstatic void mock_dev_release(struct device *dev)\n{\n\tstruct mock_dev *mdev = container_of(dev, struct mock_dev, dev);\n\n\tatomic_dec(&mock_dev_num);\n\tkfree(mdev);\n}\n\nstatic struct mock_dev *mock_dev_create(void)\n{\n\tstruct mock_dev *mdev;\n\tint rc;\n\n\tmdev = kzalloc(sizeof(*mdev), GFP_KERNEL);\n\tif (!mdev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdevice_initialize(&mdev->dev);\n\tmdev->dev.release = mock_dev_release;\n\tmdev->dev.bus = &iommufd_mock_bus_type.bus;\n\n\trc = dev_set_name(&mdev->dev, \"iommufd_mock%u\",\n\t\t\t  atomic_inc_return(&mock_dev_num));\n\tif (rc)\n\t\tgoto err_put;\n\n\trc = device_add(&mdev->dev);\n\tif (rc)\n\t\tgoto err_put;\n\treturn mdev;\n\nerr_put:\n\tput_device(&mdev->dev);\n\treturn ERR_PTR(rc);\n}\n\nstatic void mock_dev_destroy(struct mock_dev *mdev)\n{\n\tdevice_unregister(&mdev->dev);\n}\n\nbool iommufd_selftest_is_mock_dev(struct device *dev)\n{\n\treturn dev->release == mock_dev_release;\n}\n\n \nstatic int iommufd_test_mock_domain(struct iommufd_ucmd *ucmd,\n\t\t\t\t    struct iommu_test_cmd *cmd)\n{\n\tstruct iommufd_device *idev;\n\tstruct selftest_obj *sobj;\n\tu32 pt_id = cmd->id;\n\tu32 idev_id;\n\tint rc;\n\n\tsobj = iommufd_object_alloc(ucmd->ictx, sobj, IOMMUFD_OBJ_SELFTEST);\n\tif (IS_ERR(sobj))\n\t\treturn PTR_ERR(sobj);\n\n\tsobj->idev.ictx = ucmd->ictx;\n\tsobj->type = TYPE_IDEV;\n\n\tsobj->idev.mock_dev = mock_dev_create();\n\tif (IS_ERR(sobj->idev.mock_dev)) {\n\t\trc = PTR_ERR(sobj->idev.mock_dev);\n\t\tgoto out_sobj;\n\t}\n\n\tidev = iommufd_device_bind(ucmd->ictx, &sobj->idev.mock_dev->dev,\n\t\t\t\t   &idev_id);\n\tif (IS_ERR(idev)) {\n\t\trc = PTR_ERR(idev);\n\t\tgoto out_mdev;\n\t}\n\tsobj->idev.idev = idev;\n\n\trc = iommufd_device_attach(idev, &pt_id);\n\tif (rc)\n\t\tgoto out_unbind;\n\n\t \n\tcmd->mock_domain.out_hwpt_id = pt_id;\n\tcmd->mock_domain.out_stdev_id = sobj->obj.id;\n\tcmd->mock_domain.out_idev_id = idev_id;\n\trc = iommufd_ucmd_respond(ucmd, sizeof(*cmd));\n\tif (rc)\n\t\tgoto out_detach;\n\tiommufd_object_finalize(ucmd->ictx, &sobj->obj);\n\treturn 0;\n\nout_detach:\n\tiommufd_device_detach(idev);\nout_unbind:\n\tiommufd_device_unbind(idev);\nout_mdev:\n\tmock_dev_destroy(sobj->idev.mock_dev);\nout_sobj:\n\tiommufd_object_abort(ucmd->ictx, &sobj->obj);\n\treturn rc;\n}\n\n \nstatic int iommufd_test_mock_domain_replace(struct iommufd_ucmd *ucmd,\n\t\t\t\t\t    unsigned int device_id, u32 pt_id,\n\t\t\t\t\t    struct iommu_test_cmd *cmd)\n{\n\tstruct iommufd_object *dev_obj;\n\tstruct selftest_obj *sobj;\n\tint rc;\n\n\t \n\tdev_obj =\n\t\tiommufd_get_object(ucmd->ictx, device_id, IOMMUFD_OBJ_SELFTEST);\n\tif (IS_ERR(dev_obj))\n\t\treturn PTR_ERR(dev_obj);\n\n\tsobj = container_of(dev_obj, struct selftest_obj, obj);\n\tif (sobj->type != TYPE_IDEV) {\n\t\trc = -EINVAL;\n\t\tgoto out_dev_obj;\n\t}\n\n\trc = iommufd_device_replace(sobj->idev.idev, &pt_id);\n\tif (rc)\n\t\tgoto out_dev_obj;\n\n\tcmd->mock_domain_replace.pt_id = pt_id;\n\trc = iommufd_ucmd_respond(ucmd, sizeof(*cmd));\n\nout_dev_obj:\n\tiommufd_put_object(dev_obj);\n\treturn rc;\n}\n\n \nstatic int iommufd_test_add_reserved(struct iommufd_ucmd *ucmd,\n\t\t\t\t     unsigned int mockpt_id,\n\t\t\t\t     unsigned long start, size_t length)\n{\n\tstruct iommufd_ioas *ioas;\n\tint rc;\n\n\tioas = iommufd_get_ioas(ucmd->ictx, mockpt_id);\n\tif (IS_ERR(ioas))\n\t\treturn PTR_ERR(ioas);\n\tdown_write(&ioas->iopt.iova_rwsem);\n\trc = iopt_reserve_iova(&ioas->iopt, start, start + length - 1, NULL);\n\tup_write(&ioas->iopt.iova_rwsem);\n\tiommufd_put_object(&ioas->obj);\n\treturn rc;\n}\n\n \nstatic int iommufd_test_md_check_pa(struct iommufd_ucmd *ucmd,\n\t\t\t\t    unsigned int mockpt_id, unsigned long iova,\n\t\t\t\t    size_t length, void __user *uptr)\n{\n\tstruct iommufd_hw_pagetable *hwpt;\n\tstruct mock_iommu_domain *mock;\n\tuintptr_t end;\n\tint rc;\n\n\tif (iova % MOCK_IO_PAGE_SIZE || length % MOCK_IO_PAGE_SIZE ||\n\t    (uintptr_t)uptr % MOCK_IO_PAGE_SIZE ||\n\t    check_add_overflow((uintptr_t)uptr, (uintptr_t)length, &end))\n\t\treturn -EINVAL;\n\n\thwpt = get_md_pagetable(ucmd, mockpt_id, &mock);\n\tif (IS_ERR(hwpt))\n\t\treturn PTR_ERR(hwpt);\n\n\tfor (; length; length -= MOCK_IO_PAGE_SIZE) {\n\t\tstruct page *pages[1];\n\t\tunsigned long pfn;\n\t\tlong npages;\n\t\tvoid *ent;\n\n\t\tnpages = get_user_pages_fast((uintptr_t)uptr & PAGE_MASK, 1, 0,\n\t\t\t\t\t     pages);\n\t\tif (npages < 0) {\n\t\t\trc = npages;\n\t\t\tgoto out_put;\n\t\t}\n\t\tif (WARN_ON(npages != 1)) {\n\t\t\trc = -EFAULT;\n\t\t\tgoto out_put;\n\t\t}\n\t\tpfn = page_to_pfn(pages[0]);\n\t\tput_page(pages[0]);\n\n\t\tent = xa_load(&mock->pfns, iova / MOCK_IO_PAGE_SIZE);\n\t\tif (!ent ||\n\t\t    (xa_to_value(ent) & MOCK_PFN_MASK) * MOCK_IO_PAGE_SIZE !=\n\t\t\t    pfn * PAGE_SIZE + ((uintptr_t)uptr % PAGE_SIZE)) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out_put;\n\t\t}\n\t\tiova += MOCK_IO_PAGE_SIZE;\n\t\tuptr += MOCK_IO_PAGE_SIZE;\n\t}\n\trc = 0;\n\nout_put:\n\tiommufd_put_object(&hwpt->obj);\n\treturn rc;\n}\n\n \nstatic int iommufd_test_md_check_refs(struct iommufd_ucmd *ucmd,\n\t\t\t\t      void __user *uptr, size_t length,\n\t\t\t\t      unsigned int refs)\n{\n\tuintptr_t end;\n\n\tif (length % PAGE_SIZE || (uintptr_t)uptr % PAGE_SIZE ||\n\t    check_add_overflow((uintptr_t)uptr, (uintptr_t)length, &end))\n\t\treturn -EINVAL;\n\n\tfor (; length; length -= PAGE_SIZE) {\n\t\tstruct page *pages[1];\n\t\tlong npages;\n\n\t\tnpages = get_user_pages_fast((uintptr_t)uptr, 1, 0, pages);\n\t\tif (npages < 0)\n\t\t\treturn npages;\n\t\tif (WARN_ON(npages != 1))\n\t\t\treturn -EFAULT;\n\t\tif (!PageCompound(pages[0])) {\n\t\t\tunsigned int count;\n\n\t\t\tcount = page_ref_count(pages[0]);\n\t\t\tif (count / GUP_PIN_COUNTING_BIAS != refs) {\n\t\t\t\tput_page(pages[0]);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\t\tput_page(pages[0]);\n\t\tuptr += PAGE_SIZE;\n\t}\n\treturn 0;\n}\n\nstruct selftest_access {\n\tstruct iommufd_access *access;\n\tstruct file *file;\n\tstruct mutex lock;\n\tstruct list_head items;\n\tunsigned int next_id;\n\tbool destroying;\n};\n\nstruct selftest_access_item {\n\tstruct list_head items_elm;\n\tunsigned long iova;\n\tsize_t length;\n\tunsigned int id;\n};\n\nstatic const struct file_operations iommfd_test_staccess_fops;\n\nstatic struct selftest_access *iommufd_access_get(int fd)\n{\n\tstruct file *file;\n\n\tfile = fget(fd);\n\tif (!file)\n\t\treturn ERR_PTR(-EBADFD);\n\n\tif (file->f_op != &iommfd_test_staccess_fops) {\n\t\tfput(file);\n\t\treturn ERR_PTR(-EBADFD);\n\t}\n\treturn file->private_data;\n}\n\nstatic void iommufd_test_access_unmap(void *data, unsigned long iova,\n\t\t\t\t      unsigned long length)\n{\n\tunsigned long iova_last = iova + length - 1;\n\tstruct selftest_access *staccess = data;\n\tstruct selftest_access_item *item;\n\tstruct selftest_access_item *tmp;\n\n\tmutex_lock(&staccess->lock);\n\tlist_for_each_entry_safe(item, tmp, &staccess->items, items_elm) {\n\t\tif (iova > item->iova + item->length - 1 ||\n\t\t    iova_last < item->iova)\n\t\t\tcontinue;\n\t\tlist_del(&item->items_elm);\n\t\tiommufd_access_unpin_pages(staccess->access, item->iova,\n\t\t\t\t\t   item->length);\n\t\tkfree(item);\n\t}\n\tmutex_unlock(&staccess->lock);\n}\n\nstatic int iommufd_test_access_item_destroy(struct iommufd_ucmd *ucmd,\n\t\t\t\t\t    unsigned int access_id,\n\t\t\t\t\t    unsigned int item_id)\n{\n\tstruct selftest_access_item *item;\n\tstruct selftest_access *staccess;\n\n\tstaccess = iommufd_access_get(access_id);\n\tif (IS_ERR(staccess))\n\t\treturn PTR_ERR(staccess);\n\n\tmutex_lock(&staccess->lock);\n\tlist_for_each_entry(item, &staccess->items, items_elm) {\n\t\tif (item->id == item_id) {\n\t\t\tlist_del(&item->items_elm);\n\t\t\tiommufd_access_unpin_pages(staccess->access, item->iova,\n\t\t\t\t\t\t   item->length);\n\t\t\tmutex_unlock(&staccess->lock);\n\t\t\tkfree(item);\n\t\t\tfput(staccess->file);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tmutex_unlock(&staccess->lock);\n\tfput(staccess->file);\n\treturn -ENOENT;\n}\n\nstatic int iommufd_test_staccess_release(struct inode *inode,\n\t\t\t\t\t struct file *filep)\n{\n\tstruct selftest_access *staccess = filep->private_data;\n\n\tif (staccess->access) {\n\t\tiommufd_test_access_unmap(staccess, 0, ULONG_MAX);\n\t\tiommufd_access_destroy(staccess->access);\n\t}\n\tmutex_destroy(&staccess->lock);\n\tkfree(staccess);\n\treturn 0;\n}\n\nstatic const struct iommufd_access_ops selftest_access_ops_pin = {\n\t.needs_pin_pages = 1,\n\t.unmap = iommufd_test_access_unmap,\n};\n\nstatic const struct iommufd_access_ops selftest_access_ops = {\n\t.unmap = iommufd_test_access_unmap,\n};\n\nstatic const struct file_operations iommfd_test_staccess_fops = {\n\t.release = iommufd_test_staccess_release,\n};\n\nstatic struct selftest_access *iommufd_test_alloc_access(void)\n{\n\tstruct selftest_access *staccess;\n\tstruct file *filep;\n\n\tstaccess = kzalloc(sizeof(*staccess), GFP_KERNEL_ACCOUNT);\n\tif (!staccess)\n\t\treturn ERR_PTR(-ENOMEM);\n\tINIT_LIST_HEAD(&staccess->items);\n\tmutex_init(&staccess->lock);\n\n\tfilep = anon_inode_getfile(\"[iommufd_test_staccess]\",\n\t\t\t\t   &iommfd_test_staccess_fops, staccess,\n\t\t\t\t   O_RDWR);\n\tif (IS_ERR(filep)) {\n\t\tkfree(staccess);\n\t\treturn ERR_CAST(filep);\n\t}\n\tstaccess->file = filep;\n\treturn staccess;\n}\n\nstatic int iommufd_test_create_access(struct iommufd_ucmd *ucmd,\n\t\t\t\t      unsigned int ioas_id, unsigned int flags)\n{\n\tstruct iommu_test_cmd *cmd = ucmd->cmd;\n\tstruct selftest_access *staccess;\n\tstruct iommufd_access *access;\n\tu32 id;\n\tint fdno;\n\tint rc;\n\n\tif (flags & ~MOCK_FLAGS_ACCESS_CREATE_NEEDS_PIN_PAGES)\n\t\treturn -EOPNOTSUPP;\n\n\tstaccess = iommufd_test_alloc_access();\n\tif (IS_ERR(staccess))\n\t\treturn PTR_ERR(staccess);\n\n\tfdno = get_unused_fd_flags(O_CLOEXEC);\n\tif (fdno < 0) {\n\t\trc = -ENOMEM;\n\t\tgoto out_free_staccess;\n\t}\n\n\taccess = iommufd_access_create(\n\t\tucmd->ictx,\n\t\t(flags & MOCK_FLAGS_ACCESS_CREATE_NEEDS_PIN_PAGES) ?\n\t\t\t&selftest_access_ops_pin :\n\t\t\t&selftest_access_ops,\n\t\tstaccess, &id);\n\tif (IS_ERR(access)) {\n\t\trc = PTR_ERR(access);\n\t\tgoto out_put_fdno;\n\t}\n\trc = iommufd_access_attach(access, ioas_id);\n\tif (rc)\n\t\tgoto out_destroy;\n\tcmd->create_access.out_access_fd = fdno;\n\trc = iommufd_ucmd_respond(ucmd, sizeof(*cmd));\n\tif (rc)\n\t\tgoto out_destroy;\n\n\tstaccess->access = access;\n\tfd_install(fdno, staccess->file);\n\treturn 0;\n\nout_destroy:\n\tiommufd_access_destroy(access);\nout_put_fdno:\n\tput_unused_fd(fdno);\nout_free_staccess:\n\tfput(staccess->file);\n\treturn rc;\n}\n\nstatic int iommufd_test_access_replace_ioas(struct iommufd_ucmd *ucmd,\n\t\t\t\t\t    unsigned int access_id,\n\t\t\t\t\t    unsigned int ioas_id)\n{\n\tstruct selftest_access *staccess;\n\tint rc;\n\n\tstaccess = iommufd_access_get(access_id);\n\tif (IS_ERR(staccess))\n\t\treturn PTR_ERR(staccess);\n\n\trc = iommufd_access_replace(staccess->access, ioas_id);\n\tfput(staccess->file);\n\treturn rc;\n}\n\n \nstatic int iommufd_test_check_pages(void __user *uptr, struct page **pages,\n\t\t\t\t    size_t npages)\n{\n\tfor (; npages; npages--) {\n\t\tstruct page *tmp_pages[1];\n\t\tlong rc;\n\n\t\trc = get_user_pages_fast((uintptr_t)uptr, 1, 0, tmp_pages);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\tif (WARN_ON(rc != 1))\n\t\t\treturn -EFAULT;\n\t\tput_page(tmp_pages[0]);\n\t\tif (tmp_pages[0] != *pages)\n\t\t\treturn -EBADE;\n\t\tpages++;\n\t\tuptr += PAGE_SIZE;\n\t}\n\treturn 0;\n}\n\nstatic int iommufd_test_access_pages(struct iommufd_ucmd *ucmd,\n\t\t\t\t     unsigned int access_id, unsigned long iova,\n\t\t\t\t     size_t length, void __user *uptr,\n\t\t\t\t     u32 flags)\n{\n\tstruct iommu_test_cmd *cmd = ucmd->cmd;\n\tstruct selftest_access_item *item;\n\tstruct selftest_access *staccess;\n\tstruct page **pages;\n\tsize_t npages;\n\tint rc;\n\n\t \n\tif (length > 16*1024*1024)\n\t\treturn -ENOMEM;\n\n\tif (flags & ~(MOCK_FLAGS_ACCESS_WRITE | MOCK_FLAGS_ACCESS_SYZ))\n\t\treturn -EOPNOTSUPP;\n\n\tstaccess = iommufd_access_get(access_id);\n\tif (IS_ERR(staccess))\n\t\treturn PTR_ERR(staccess);\n\n\tif (staccess->access->ops != &selftest_access_ops_pin) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto out_put;\n\t}\n\n\tif (flags & MOCK_FLAGS_ACCESS_SYZ)\n\t\tiova = iommufd_test_syz_conv_iova(&staccess->access->ioas->iopt,\n\t\t\t\t\t&cmd->access_pages.iova);\n\n\tnpages = (ALIGN(iova + length, PAGE_SIZE) -\n\t\t  ALIGN_DOWN(iova, PAGE_SIZE)) /\n\t\t PAGE_SIZE;\n\tpages = kvcalloc(npages, sizeof(*pages), GFP_KERNEL_ACCOUNT);\n\tif (!pages) {\n\t\trc = -ENOMEM;\n\t\tgoto out_put;\n\t}\n\n\t \n\tmutex_lock(&staccess->lock);\n\trc = iommufd_access_pin_pages(staccess->access, iova, length, pages,\n\t\t\t\t      flags & MOCK_FLAGS_ACCESS_WRITE);\n\tif (rc)\n\t\tgoto out_unlock;\n\n\t \n\tif (uptr) {\n\t\trc = iommufd_test_check_pages(\n\t\t\tuptr - (iova - ALIGN_DOWN(iova, PAGE_SIZE)), pages,\n\t\t\tnpages);\n\t\tif (rc)\n\t\t\tgoto out_unaccess;\n\t}\n\n\titem = kzalloc(sizeof(*item), GFP_KERNEL_ACCOUNT);\n\tif (!item) {\n\t\trc = -ENOMEM;\n\t\tgoto out_unaccess;\n\t}\n\n\titem->iova = iova;\n\titem->length = length;\n\titem->id = staccess->next_id++;\n\tlist_add_tail(&item->items_elm, &staccess->items);\n\n\tcmd->access_pages.out_access_pages_id = item->id;\n\trc = iommufd_ucmd_respond(ucmd, sizeof(*cmd));\n\tif (rc)\n\t\tgoto out_free_item;\n\tgoto out_unlock;\n\nout_free_item:\n\tlist_del(&item->items_elm);\n\tkfree(item);\nout_unaccess:\n\tiommufd_access_unpin_pages(staccess->access, iova, length);\nout_unlock:\n\tmutex_unlock(&staccess->lock);\n\tkvfree(pages);\nout_put:\n\tfput(staccess->file);\n\treturn rc;\n}\n\nstatic int iommufd_test_access_rw(struct iommufd_ucmd *ucmd,\n\t\t\t\t  unsigned int access_id, unsigned long iova,\n\t\t\t\t  size_t length, void __user *ubuf,\n\t\t\t\t  unsigned int flags)\n{\n\tstruct iommu_test_cmd *cmd = ucmd->cmd;\n\tstruct selftest_access *staccess;\n\tvoid *tmp;\n\tint rc;\n\n\t \n\tif (length > 16*1024*1024)\n\t\treturn -ENOMEM;\n\n\tif (flags & ~(MOCK_ACCESS_RW_WRITE | MOCK_ACCESS_RW_SLOW_PATH |\n\t\t      MOCK_FLAGS_ACCESS_SYZ))\n\t\treturn -EOPNOTSUPP;\n\n\tstaccess = iommufd_access_get(access_id);\n\tif (IS_ERR(staccess))\n\t\treturn PTR_ERR(staccess);\n\n\ttmp = kvzalloc(length, GFP_KERNEL_ACCOUNT);\n\tif (!tmp) {\n\t\trc = -ENOMEM;\n\t\tgoto out_put;\n\t}\n\n\tif (flags & MOCK_ACCESS_RW_WRITE) {\n\t\tif (copy_from_user(tmp, ubuf, length)) {\n\t\t\trc = -EFAULT;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\tif (flags & MOCK_FLAGS_ACCESS_SYZ)\n\t\tiova = iommufd_test_syz_conv_iova(&staccess->access->ioas->iopt,\n\t\t\t\t\t&cmd->access_rw.iova);\n\n\trc = iommufd_access_rw(staccess->access, iova, tmp, length, flags);\n\tif (rc)\n\t\tgoto out_free;\n\tif (!(flags & MOCK_ACCESS_RW_WRITE)) {\n\t\tif (copy_to_user(ubuf, tmp, length)) {\n\t\t\trc = -EFAULT;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\nout_free:\n\tkvfree(tmp);\nout_put:\n\tfput(staccess->file);\n\treturn rc;\n}\nstatic_assert((unsigned int)MOCK_ACCESS_RW_WRITE == IOMMUFD_ACCESS_RW_WRITE);\nstatic_assert((unsigned int)MOCK_ACCESS_RW_SLOW_PATH ==\n\t      __IOMMUFD_ACCESS_RW_SLOW_PATH);\n\nvoid iommufd_selftest_destroy(struct iommufd_object *obj)\n{\n\tstruct selftest_obj *sobj = container_of(obj, struct selftest_obj, obj);\n\n\tswitch (sobj->type) {\n\tcase TYPE_IDEV:\n\t\tiommufd_device_detach(sobj->idev.idev);\n\t\tiommufd_device_unbind(sobj->idev.idev);\n\t\tmock_dev_destroy(sobj->idev.mock_dev);\n\t\tbreak;\n\t}\n}\n\nint iommufd_test(struct iommufd_ucmd *ucmd)\n{\n\tstruct iommu_test_cmd *cmd = ucmd->cmd;\n\n\tswitch (cmd->op) {\n\tcase IOMMU_TEST_OP_ADD_RESERVED:\n\t\treturn iommufd_test_add_reserved(ucmd, cmd->id,\n\t\t\t\t\t\t cmd->add_reserved.start,\n\t\t\t\t\t\t cmd->add_reserved.length);\n\tcase IOMMU_TEST_OP_MOCK_DOMAIN:\n\t\treturn iommufd_test_mock_domain(ucmd, cmd);\n\tcase IOMMU_TEST_OP_MOCK_DOMAIN_REPLACE:\n\t\treturn iommufd_test_mock_domain_replace(\n\t\t\tucmd, cmd->id, cmd->mock_domain_replace.pt_id, cmd);\n\tcase IOMMU_TEST_OP_MD_CHECK_MAP:\n\t\treturn iommufd_test_md_check_pa(\n\t\t\tucmd, cmd->id, cmd->check_map.iova,\n\t\t\tcmd->check_map.length,\n\t\t\tu64_to_user_ptr(cmd->check_map.uptr));\n\tcase IOMMU_TEST_OP_MD_CHECK_REFS:\n\t\treturn iommufd_test_md_check_refs(\n\t\t\tucmd, u64_to_user_ptr(cmd->check_refs.uptr),\n\t\t\tcmd->check_refs.length, cmd->check_refs.refs);\n\tcase IOMMU_TEST_OP_CREATE_ACCESS:\n\t\treturn iommufd_test_create_access(ucmd, cmd->id,\n\t\t\t\t\t\t  cmd->create_access.flags);\n\tcase IOMMU_TEST_OP_ACCESS_REPLACE_IOAS:\n\t\treturn iommufd_test_access_replace_ioas(\n\t\t\tucmd, cmd->id, cmd->access_replace_ioas.ioas_id);\n\tcase IOMMU_TEST_OP_ACCESS_PAGES:\n\t\treturn iommufd_test_access_pages(\n\t\t\tucmd, cmd->id, cmd->access_pages.iova,\n\t\t\tcmd->access_pages.length,\n\t\t\tu64_to_user_ptr(cmd->access_pages.uptr),\n\t\t\tcmd->access_pages.flags);\n\tcase IOMMU_TEST_OP_ACCESS_RW:\n\t\treturn iommufd_test_access_rw(\n\t\t\tucmd, cmd->id, cmd->access_rw.iova,\n\t\t\tcmd->access_rw.length,\n\t\t\tu64_to_user_ptr(cmd->access_rw.uptr),\n\t\t\tcmd->access_rw.flags);\n\tcase IOMMU_TEST_OP_DESTROY_ACCESS_PAGES:\n\t\treturn iommufd_test_access_item_destroy(\n\t\t\tucmd, cmd->id, cmd->destroy_access_pages.access_pages_id);\n\tcase IOMMU_TEST_OP_SET_TEMP_MEMORY_LIMIT:\n\t\t \n\t\tif (cmd->memory_limit.limit <\n\t\t    sizeof(unsigned long) + sizeof(u32))\n\t\t\treturn -EINVAL;\n\t\tiommufd_test_memory_limit = cmd->memory_limit.limit;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nbool iommufd_should_fail(void)\n{\n\treturn should_fail(&fail_iommufd, 1);\n}\n\nint __init iommufd_test_init(void)\n{\n\tstruct platform_device_info pdevinfo = {\n\t\t.name = \"iommufd_selftest_iommu\",\n\t};\n\tint rc;\n\n\tdbgfs_root =\n\t\tfault_create_debugfs_attr(\"fail_iommufd\", NULL, &fail_iommufd);\n\n\tselftest_iommu_dev = platform_device_register_full(&pdevinfo);\n\tif (IS_ERR(selftest_iommu_dev)) {\n\t\trc = PTR_ERR(selftest_iommu_dev);\n\t\tgoto err_dbgfs;\n\t}\n\n\trc = bus_register(&iommufd_mock_bus_type.bus);\n\tif (rc)\n\t\tgoto err_platform;\n\n\trc = iommu_device_sysfs_add(&mock_iommu_device,\n\t\t\t\t    &selftest_iommu_dev->dev, NULL, \"%s\",\n\t\t\t\t    dev_name(&selftest_iommu_dev->dev));\n\tif (rc)\n\t\tgoto err_bus;\n\n\trc = iommu_device_register_bus(&mock_iommu_device, &mock_ops,\n\t\t\t\t  &iommufd_mock_bus_type.bus,\n\t\t\t\t  &iommufd_mock_bus_type.nb);\n\tif (rc)\n\t\tgoto err_sysfs;\n\treturn 0;\n\nerr_sysfs:\n\tiommu_device_sysfs_remove(&mock_iommu_device);\nerr_bus:\n\tbus_unregister(&iommufd_mock_bus_type.bus);\nerr_platform:\n\tplatform_device_unregister(selftest_iommu_dev);\nerr_dbgfs:\n\tdebugfs_remove_recursive(dbgfs_root);\n\treturn rc;\n}\n\nvoid iommufd_test_exit(void)\n{\n\tiommu_device_sysfs_remove(&mock_iommu_device);\n\tiommu_device_unregister_bus(&mock_iommu_device,\n\t\t\t\t    &iommufd_mock_bus_type.bus,\n\t\t\t\t    &iommufd_mock_bus_type.nb);\n\tbus_unregister(&iommufd_mock_bus_type.bus);\n\tplatform_device_unregister(selftest_iommu_dev);\n\tdebugfs_remove_recursive(dbgfs_root);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}