{
  "module_name": "amd_iommu.h",
  "hash_id": "bd1561f9a9bb31637a33b579476b07f8ee4c7ec5f371b3e9a320e1bc6fd8acc3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iommu/amd/amd_iommu.h",
  "human_readable_source": " \n \n\n#ifndef AMD_IOMMU_H\n#define AMD_IOMMU_H\n\n#include <linux/iommu.h>\n\n#include \"amd_iommu_types.h\"\n\nirqreturn_t amd_iommu_int_thread(int irq, void *data);\nirqreturn_t amd_iommu_int_thread_evtlog(int irq, void *data);\nirqreturn_t amd_iommu_int_thread_pprlog(int irq, void *data);\nirqreturn_t amd_iommu_int_thread_galog(int irq, void *data);\nirqreturn_t amd_iommu_int_handler(int irq, void *data);\nvoid amd_iommu_apply_erratum_63(struct amd_iommu *iommu, u16 devid);\nvoid amd_iommu_restart_event_logging(struct amd_iommu *iommu);\nvoid amd_iommu_restart_ga_log(struct amd_iommu *iommu);\nvoid amd_iommu_restart_ppr_log(struct amd_iommu *iommu);\nvoid amd_iommu_set_rlookup_table(struct amd_iommu *iommu, u16 devid);\n\n#ifdef CONFIG_AMD_IOMMU_DEBUGFS\nvoid amd_iommu_debugfs_setup(struct amd_iommu *iommu);\n#else\nstatic inline void amd_iommu_debugfs_setup(struct amd_iommu *iommu) {}\n#endif\n\n \nint amd_iommu_prepare(void);\nint amd_iommu_enable(void);\nvoid amd_iommu_disable(void);\nint amd_iommu_reenable(int mode);\nint amd_iommu_enable_faulting(void);\nextern int amd_iommu_guest_ir;\nextern enum io_pgtable_fmt amd_iommu_pgtable;\nextern int amd_iommu_gpt_level;\n\n \nstruct iommu_domain;\n\nbool amd_iommu_v2_supported(void);\nstruct amd_iommu *get_amd_iommu(unsigned int idx);\nu8 amd_iommu_pc_get_max_banks(unsigned int idx);\nbool amd_iommu_pc_supported(void);\nu8 amd_iommu_pc_get_max_counters(unsigned int idx);\nint amd_iommu_pc_get_reg(struct amd_iommu *iommu, u8 bank, u8 cntr,\n\t\t\t u8 fxn, u64 *value);\nint amd_iommu_pc_set_reg(struct amd_iommu *iommu, u8 bank, u8 cntr,\n\t\t\t u8 fxn, u64 *value);\n\nint amd_iommu_register_ppr_notifier(struct notifier_block *nb);\nint amd_iommu_unregister_ppr_notifier(struct notifier_block *nb);\nvoid amd_iommu_domain_direct_map(struct iommu_domain *dom);\nint amd_iommu_domain_enable_v2(struct iommu_domain *dom, int pasids);\nint amd_iommu_flush_page(struct iommu_domain *dom, u32 pasid, u64 address);\nvoid amd_iommu_update_and_flush_device_table(struct protection_domain *domain);\nvoid amd_iommu_domain_update(struct protection_domain *domain);\nvoid amd_iommu_domain_flush_complete(struct protection_domain *domain);\nvoid amd_iommu_domain_flush_tlb_pde(struct protection_domain *domain);\nint amd_iommu_flush_tlb(struct iommu_domain *dom, u32 pasid);\nint amd_iommu_domain_set_gcr3(struct iommu_domain *dom, u32 pasid,\n\t\t\t      unsigned long cr3);\nint amd_iommu_domain_clear_gcr3(struct iommu_domain *dom, u32 pasid);\n\n#ifdef CONFIG_IRQ_REMAP\nint amd_iommu_create_irq_domain(struct amd_iommu *iommu);\n#else\nstatic inline int amd_iommu_create_irq_domain(struct amd_iommu *iommu)\n{\n\treturn 0;\n}\n#endif\n\n#define PPR_SUCCESS\t\t\t0x0\n#define PPR_INVALID\t\t\t0x1\n#define PPR_FAILURE\t\t\t0xf\n\nint amd_iommu_complete_ppr(struct pci_dev *pdev, u32 pasid,\n\t\t\t   int status, int tag);\n\nstatic inline bool is_rd890_iommu(struct pci_dev *pdev)\n{\n\treturn (pdev->vendor == PCI_VENDOR_ID_ATI) &&\n\t       (pdev->device == PCI_DEVICE_ID_RD890_IOMMU);\n}\n\nstatic inline bool iommu_feature(struct amd_iommu *iommu, u64 mask)\n{\n\treturn !!(iommu->features & mask);\n}\n\nstatic inline u64 iommu_virt_to_phys(void *vaddr)\n{\n\treturn (u64)__sme_set(virt_to_phys(vaddr));\n}\n\nstatic inline void *iommu_phys_to_virt(unsigned long paddr)\n{\n\treturn phys_to_virt(__sme_clr(paddr));\n}\n\nstatic inline\nvoid amd_iommu_domain_set_pt_root(struct protection_domain *domain, u64 root)\n{\n\tatomic64_set(&domain->iop.pt_root, root);\n\tdomain->iop.root = (u64 *)(root & PAGE_MASK);\n\tdomain->iop.mode = root & 7;  \n}\n\nstatic inline\nvoid amd_iommu_domain_clr_pt_root(struct protection_domain *domain)\n{\n\tamd_iommu_domain_set_pt_root(domain, 0);\n}\n\nstatic inline int get_pci_sbdf_id(struct pci_dev *pdev)\n{\n\tint seg = pci_domain_nr(pdev->bus);\n\tu16 devid = pci_dev_id(pdev);\n\n\treturn PCI_SEG_DEVID_TO_SBDF(seg, devid);\n}\n\nstatic inline void *alloc_pgtable_page(int nid, gfp_t gfp)\n{\n\tstruct page *page;\n\n\tpage = alloc_pages_node(nid, gfp | __GFP_ZERO, 0);\n\treturn page ? page_address(page) : NULL;\n}\n\nbool translation_pre_enabled(struct amd_iommu *iommu);\nbool amd_iommu_is_attach_deferred(struct device *dev);\nint __init add_special_device(u8 type, u8 id, u32 *devid, bool cmd_line);\n\n#ifdef CONFIG_DMI\nvoid amd_iommu_apply_ivrs_quirks(void);\n#else\nstatic inline void amd_iommu_apply_ivrs_quirks(void) { }\n#endif\n\nvoid amd_iommu_domain_set_pgtable(struct protection_domain *domain,\n\t\t\t\t  u64 *root, int mode);\nstruct dev_table_entry *get_dev_table(struct amd_iommu *iommu);\n\nextern u64 amd_iommu_efr;\nextern u64 amd_iommu_efr2;\n\nextern bool amd_iommu_snp_en;\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}