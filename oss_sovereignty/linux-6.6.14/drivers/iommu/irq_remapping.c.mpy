{
  "module_name": "irq_remapping.c",
  "hash_id": "4e7f2ac87a219949786e3d0a175d3e07c2cd2335c43a3c9d264634ca7b19c1a5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iommu/irq_remapping.c",
  "human_readable_source": "\n#include <linux/cpumask.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n#include <linux/pci.h>\n#include <linux/irqdomain.h>\n\n#include <asm/hw_irq.h>\n#include <asm/irq_remapping.h>\n#include <asm/processor.h>\n#include <asm/x86_init.h>\n#include <asm/apic.h>\n#include <asm/hpet.h>\n\n#include \"irq_remapping.h\"\n\nint irq_remapping_enabled;\nint irq_remap_broken;\nint disable_sourceid_checking;\nint no_x2apic_optout;\n\nint disable_irq_post = 0;\n\nstatic int disable_irq_remap;\nstatic struct irq_remap_ops *remap_ops;\n\nstatic void irq_remapping_restore_boot_irq_mode(void)\n{\n\t \n\tif (boot_cpu_has(X86_FEATURE_APIC) || apic_from_smp_config())\n\t\tdisconnect_bsp_APIC(0);\n}\n\nstatic void __init irq_remapping_modify_x86_ops(void)\n{\n\tx86_apic_ops.restore = irq_remapping_restore_boot_irq_mode;\n}\n\nstatic __init int setup_nointremap(char *str)\n{\n\tdisable_irq_remap = 1;\n\treturn 0;\n}\nearly_param(\"nointremap\", setup_nointremap);\n\nstatic __init int setup_irqremap(char *str)\n{\n\tif (!str)\n\t\treturn -EINVAL;\n\n\twhile (*str) {\n\t\tif (!strncmp(str, \"on\", 2)) {\n\t\t\tdisable_irq_remap = 0;\n\t\t\tdisable_irq_post = 0;\n\t\t} else if (!strncmp(str, \"off\", 3)) {\n\t\t\tdisable_irq_remap = 1;\n\t\t\tdisable_irq_post = 1;\n\t\t} else if (!strncmp(str, \"nosid\", 5))\n\t\t\tdisable_sourceid_checking = 1;\n\t\telse if (!strncmp(str, \"no_x2apic_optout\", 16))\n\t\t\tno_x2apic_optout = 1;\n\t\telse if (!strncmp(str, \"nopost\", 6))\n\t\t\tdisable_irq_post = 1;\n\n\t\tstr += strcspn(str, \",\");\n\t\twhile (*str == ',')\n\t\t\tstr++;\n\t}\n\n\treturn 0;\n}\nearly_param(\"intremap\", setup_irqremap);\n\nvoid set_irq_remapping_broken(void)\n{\n\tirq_remap_broken = 1;\n}\n\nbool irq_remapping_cap(enum irq_remap_cap cap)\n{\n\tif (!remap_ops || disable_irq_post)\n\t\treturn false;\n\n\treturn (remap_ops->capability & (1 << cap));\n}\nEXPORT_SYMBOL_GPL(irq_remapping_cap);\n\nint __init irq_remapping_prepare(void)\n{\n\tif (disable_irq_remap)\n\t\treturn -ENOSYS;\n\n\tif (intel_irq_remap_ops.prepare() == 0)\n\t\tremap_ops = &intel_irq_remap_ops;\n\telse if (IS_ENABLED(CONFIG_AMD_IOMMU) &&\n\t\t amd_iommu_irq_ops.prepare() == 0)\n\t\tremap_ops = &amd_iommu_irq_ops;\n\telse if (IS_ENABLED(CONFIG_HYPERV_IOMMU) &&\n\t\t hyperv_irq_remap_ops.prepare() == 0)\n\t\tremap_ops = &hyperv_irq_remap_ops;\n\telse\n\t\treturn -ENOSYS;\n\n\treturn 0;\n}\n\nint __init irq_remapping_enable(void)\n{\n\tint ret;\n\n\tif (!remap_ops->enable)\n\t\treturn -ENODEV;\n\n\tret = remap_ops->enable();\n\n\tif (irq_remapping_enabled)\n\t\tirq_remapping_modify_x86_ops();\n\n\treturn ret;\n}\n\nvoid irq_remapping_disable(void)\n{\n\tif (irq_remapping_enabled && remap_ops->disable)\n\t\tremap_ops->disable();\n}\n\nint irq_remapping_reenable(int mode)\n{\n\tif (irq_remapping_enabled && remap_ops->reenable)\n\t\treturn remap_ops->reenable(mode);\n\n\treturn 0;\n}\n\nint __init irq_remap_enable_fault_handling(void)\n{\n\tif (!irq_remapping_enabled)\n\t\treturn 0;\n\n\tif (!remap_ops->enable_faulting)\n\t\treturn -ENODEV;\n\n\treturn remap_ops->enable_faulting();\n}\n\nvoid panic_if_irq_remap(const char *msg)\n{\n\tif (irq_remapping_enabled)\n\t\tpanic(msg);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}