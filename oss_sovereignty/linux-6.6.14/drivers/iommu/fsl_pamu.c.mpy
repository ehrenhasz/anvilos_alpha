{
  "module_name": "fsl_pamu.c",
  "hash_id": "9ea39f32d04ffc7793750363a4115d6576bb265c30f6af3faff3fe1d98058f92",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iommu/fsl_pamu.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)    \"fsl-pamu: %s: \" fmt, __func__\n\n#include \"fsl_pamu.h\"\n\n#include <linux/fsl/guts.h>\n#include <linux/interrupt.h>\n#include <linux/genalloc.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n\n#include <asm/mpc85xx.h>\n\n \n#define OMI_QMAN        0x00\n#define OMI_FMAN        0x01\n#define OMI_QMAN_PRIV   0x02\n#define OMI_CAAM        0x03\n\n#define make64(high, low) (((u64)(high) << 32) | (low))\n\nstruct pamu_isr_data {\n\tvoid __iomem *pamu_reg_base;\t \n\tunsigned int count;\t\t \n};\n\nstatic struct paace *ppaact;\nstatic struct paace *spaact;\n\nstatic bool probed;\t\t\t \n\n \nstatic const struct of_device_id guts_device_ids[] = {\n\t{ .compatible = \"fsl,qoriq-device-config-1.0\", },\n\t{ .compatible = \"fsl,qoriq-device-config-2.0\", },\n\t{}\n};\n\n \nstatic const struct of_device_id l3_device_ids[] = {\n\t{ .compatible = \"fsl,t4240-l3-cache-controller\", },\n\t{ .compatible = \"fsl,b4860-l3-cache-controller\", },\n\t{ .compatible = \"fsl,p4080-l3-cache-controller\", },\n\t{}\n};\n\n \nstatic u32 max_subwindow_count;\n\n \nstatic struct paace *pamu_get_ppaace(int liodn)\n{\n\tif (!ppaact || liodn >= PAACE_NUMBER_ENTRIES) {\n\t\tpr_debug(\"PPAACT doesn't exist\\n\");\n\t\treturn NULL;\n\t}\n\n\treturn &ppaact[liodn];\n}\n\n \nint pamu_enable_liodn(int liodn)\n{\n\tstruct paace *ppaace;\n\n\tppaace = pamu_get_ppaace(liodn);\n\tif (!ppaace) {\n\t\tpr_debug(\"Invalid primary paace entry\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tif (!get_bf(ppaace->addr_bitfields, PPAACE_AF_WSE)) {\n\t\tpr_debug(\"liodn %d not configured\\n\", liodn);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tmb();\n\n\tset_bf(ppaace->addr_bitfields, PAACE_AF_V, PAACE_V_VALID);\n\tmb();\n\n\treturn 0;\n}\n\n \nint pamu_disable_liodn(int liodn)\n{\n\tstruct paace *ppaace;\n\n\tppaace = pamu_get_ppaace(liodn);\n\tif (!ppaace) {\n\t\tpr_debug(\"Invalid primary paace entry\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tset_bf(ppaace->addr_bitfields, PAACE_AF_V, PAACE_V_INVALID);\n\tmb();\n\n\treturn 0;\n}\n\n \nstatic unsigned int map_addrspace_size_to_wse(phys_addr_t addrspace_size)\n{\n\t \n\tBUG_ON(addrspace_size & (addrspace_size - 1));\n\n\t \n\treturn fls64(addrspace_size) - 2;\n}\n\n \nstatic void pamu_init_ppaace(struct paace *ppaace)\n{\n\tset_bf(ppaace->addr_bitfields, PAACE_AF_PT, PAACE_PT_PRIMARY);\n\n\tset_bf(ppaace->domain_attr.to_host.coherency_required, PAACE_DA_HOST_CR,\n\t       PAACE_M_COHERENCE_REQ);\n}\n\n \nint pamu_update_paace_stash(int liodn, u32 value)\n{\n\tstruct paace *paace;\n\n\tpaace = pamu_get_ppaace(liodn);\n\tif (!paace) {\n\t\tpr_debug(\"Invalid liodn entry\\n\");\n\t\treturn -ENOENT;\n\t}\n\tset_bf(paace->impl_attr, PAACE_IA_CID, value);\n\n\tmb();\n\n\treturn 0;\n}\n\n \nint pamu_config_ppaace(int liodn, u32 omi, u32 stashid, int prot)\n{\n\tstruct paace *ppaace;\n\n\tppaace = pamu_get_ppaace(liodn);\n\tif (!ppaace)\n\t\treturn -ENOENT;\n\n\t \n\tset_bf(ppaace->addr_bitfields, PPAACE_AF_WSE,\n\t       map_addrspace_size_to_wse(1ULL << 36));\n\n\tpamu_init_ppaace(ppaace);\n\n\tppaace->wbah = 0;\n\tset_bf(ppaace->addr_bitfields, PPAACE_AF_WBAL, 0);\n\n\t \n\tif (omi < OME_NUMBER_ENTRIES) {\n\t\tset_bf(ppaace->impl_attr, PAACE_IA_OTM, PAACE_OTM_INDEXED);\n\t\tppaace->op_encode.index_ot.omi = omi;\n\t} else if (~omi != 0) {\n\t\tpr_debug(\"bad operation mapping index: %d\\n\", omi);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (~stashid != 0)\n\t\tset_bf(ppaace->impl_attr, PAACE_IA_CID, stashid);\n\n\tset_bf(ppaace->impl_attr, PAACE_IA_ATM, PAACE_ATM_WINDOW_XLATE);\n\tppaace->twbah = 0;\n\tset_bf(ppaace->win_bitfields, PAACE_WIN_TWBAL, 0);\n\tset_bf(ppaace->addr_bitfields, PAACE_AF_AP, prot);\n\tset_bf(ppaace->impl_attr, PAACE_IA_WCE, 0);\n\tset_bf(ppaace->addr_bitfields, PPAACE_AF_MW, 0);\n\tmb();\n\n\treturn 0;\n}\n\n \nvoid get_ome_index(u32 *omi_index, struct device *dev)\n{\n\tif (of_device_is_compatible(dev->of_node, \"fsl,qman-portal\"))\n\t\t*omi_index = OMI_QMAN;\n\tif (of_device_is_compatible(dev->of_node, \"fsl,qman\"))\n\t\t*omi_index = OMI_QMAN_PRIV;\n}\n\n \nu32 get_stash_id(u32 stash_dest_hint, u32 vcpu)\n{\n\tconst u32 *prop;\n\tstruct device_node *node;\n\tu32 cache_level;\n\tint len, found = 0;\n\tint i;\n\n\t \n\tif (stash_dest_hint == PAMU_ATTR_CACHE_L3) {\n\t\tnode = of_find_matching_node(NULL, l3_device_ids);\n\t\tif (node) {\n\t\t\tprop = of_get_property(node, \"cache-stash-id\", NULL);\n\t\t\tif (!prop) {\n\t\t\t\tpr_debug(\"missing cache-stash-id at %pOF\\n\",\n\t\t\t\t\t node);\n\t\t\t\tof_node_put(node);\n\t\t\t\treturn ~(u32)0;\n\t\t\t}\n\t\t\tof_node_put(node);\n\t\t\treturn be32_to_cpup(prop);\n\t\t}\n\t\treturn ~(u32)0;\n\t}\n\n\tfor_each_of_cpu_node(node) {\n\t\tprop = of_get_property(node, \"reg\", &len);\n\t\tfor (i = 0; i < len / sizeof(u32); i++) {\n\t\t\tif (be32_to_cpup(&prop[i]) == vcpu) {\n\t\t\t\tfound = 1;\n\t\t\t\tgoto found_cpu_node;\n\t\t\t}\n\t\t}\n\t}\nfound_cpu_node:\n\n\t \n\tfor (cache_level = PAMU_ATTR_CACHE_L1; (cache_level < PAMU_ATTR_CACHE_L3) && found; cache_level++) {\n\t\tif (stash_dest_hint == cache_level) {\n\t\t\tprop = of_get_property(node, \"cache-stash-id\", NULL);\n\t\t\tif (!prop) {\n\t\t\t\tpr_debug(\"missing cache-stash-id at %pOF\\n\",\n\t\t\t\t\t node);\n\t\t\t\tof_node_put(node);\n\t\t\t\treturn ~(u32)0;\n\t\t\t}\n\t\t\tof_node_put(node);\n\t\t\treturn be32_to_cpup(prop);\n\t\t}\n\n\t\tprop = of_get_property(node, \"next-level-cache\", NULL);\n\t\tif (!prop) {\n\t\t\tpr_debug(\"can't find next-level-cache at %pOF\\n\", node);\n\t\t\tof_node_put(node);\n\t\t\treturn ~(u32)0;   \n\t\t}\n\t\tof_node_put(node);\n\n\t\t \n\t\tnode = of_find_node_by_phandle(*prop);\n\t\tif (!node) {\n\t\t\tpr_debug(\"Invalid node for cache hierarchy\\n\");\n\t\t\treturn ~(u32)0;\n\t\t}\n\t}\n\n\tpr_debug(\"stash dest not found for %d on vcpu %d\\n\",\n\t\t stash_dest_hint, vcpu);\n\treturn ~(u32)0;\n}\n\n \n#define QMAN_PAACE 1\n#define QMAN_PORTAL_PAACE 2\n#define BMAN_PAACE 3\n\n \nstatic void setup_qbman_paace(struct paace *ppaace, int  paace_type)\n{\n\tswitch (paace_type) {\n\tcase QMAN_PAACE:\n\t\tset_bf(ppaace->impl_attr, PAACE_IA_OTM, PAACE_OTM_INDEXED);\n\t\tppaace->op_encode.index_ot.omi = OMI_QMAN_PRIV;\n\t\t \n\t\tset_bf(ppaace->impl_attr, PAACE_IA_CID, get_stash_id(PAMU_ATTR_CACHE_L3, 0));\n\t\tset_bf(ppaace->domain_attr.to_host.coherency_required, PAACE_DA_HOST_CR,\n\t\t       0);\n\t\tbreak;\n\tcase QMAN_PORTAL_PAACE:\n\t\tset_bf(ppaace->impl_attr, PAACE_IA_OTM, PAACE_OTM_INDEXED);\n\t\tppaace->op_encode.index_ot.omi = OMI_QMAN;\n\t\t \n\t\tset_bf(ppaace->impl_attr, PAACE_IA_CID, get_stash_id(PAMU_ATTR_CACHE_L3, 0));\n\t\tbreak;\n\tcase BMAN_PAACE:\n\t\tset_bf(ppaace->domain_attr.to_host.coherency_required, PAACE_DA_HOST_CR,\n\t\t       0);\n\t\tbreak;\n\t}\n}\n\n \nstatic void setup_omt(struct ome *omt)\n{\n\tstruct ome *ome;\n\n\t \n\tome = &omt[OMI_QMAN];\n\n\tome->moe[IOE_READ_IDX] = EOE_VALID | EOE_READ;\n\tome->moe[IOE_EREAD0_IDX] = EOE_VALID | EOE_RSA;\n\tome->moe[IOE_WRITE_IDX] = EOE_VALID | EOE_WRITE;\n\tome->moe[IOE_EWRITE0_IDX] = EOE_VALID | EOE_WWSAO;\n\n\tome->moe[IOE_DIRECT0_IDX] = EOE_VALID | EOE_LDEC;\n\tome->moe[IOE_DIRECT1_IDX] = EOE_VALID | EOE_LDECPE;\n\n\t \n\tome = &omt[OMI_FMAN];\n\tome->moe[IOE_READ_IDX]  = EOE_VALID | EOE_READI;\n\tome->moe[IOE_WRITE_IDX] = EOE_VALID | EOE_WRITE;\n\n\t \n\tome = &omt[OMI_QMAN_PRIV];\n\tome->moe[IOE_READ_IDX]  = EOE_VALID | EOE_READ;\n\tome->moe[IOE_WRITE_IDX] = EOE_VALID | EOE_WRITE;\n\tome->moe[IOE_EREAD0_IDX] = EOE_VALID | EOE_RSA;\n\tome->moe[IOE_EWRITE0_IDX] = EOE_VALID | EOE_WWSA;\n\n\t \n\tome = &omt[OMI_CAAM];\n\tome->moe[IOE_READ_IDX]  = EOE_VALID | EOE_READI;\n\tome->moe[IOE_WRITE_IDX] = EOE_VALID | EOE_WRITE;\n}\n\n \nstatic void get_pamu_cap_values(unsigned long pamu_reg_base)\n{\n\tu32 pc_val;\n\n\tpc_val = in_be32((u32 *)(pamu_reg_base + PAMU_PC3));\n\t \n\tmax_subwindow_count = 1 << (1 + PAMU_PC3_MWCE(pc_val));\n}\n\n \nstatic int setup_one_pamu(unsigned long pamu_reg_base, unsigned long pamu_reg_size,\n\t\t\t  phys_addr_t ppaact_phys, phys_addr_t spaact_phys,\n\t\t\t  phys_addr_t omt_phys)\n{\n\tu32 *pc;\n\tstruct pamu_mmap_regs *pamu_regs;\n\n\tpc = (u32 *) (pamu_reg_base + PAMU_PC);\n\tpamu_regs = (struct pamu_mmap_regs *)\n\t\t(pamu_reg_base + PAMU_MMAP_REGS_BASE);\n\n\t \n\n\tout_be32(&pamu_regs->ppbah, upper_32_bits(ppaact_phys));\n\tout_be32(&pamu_regs->ppbal, lower_32_bits(ppaact_phys));\n\tppaact_phys = ppaact_phys + PAACT_SIZE;\n\tout_be32(&pamu_regs->pplah, upper_32_bits(ppaact_phys));\n\tout_be32(&pamu_regs->pplal, lower_32_bits(ppaact_phys));\n\n\tout_be32(&pamu_regs->spbah, upper_32_bits(spaact_phys));\n\tout_be32(&pamu_regs->spbal, lower_32_bits(spaact_phys));\n\tspaact_phys = spaact_phys + SPAACT_SIZE;\n\tout_be32(&pamu_regs->splah, upper_32_bits(spaact_phys));\n\tout_be32(&pamu_regs->splal, lower_32_bits(spaact_phys));\n\n\tout_be32(&pamu_regs->obah, upper_32_bits(omt_phys));\n\tout_be32(&pamu_regs->obal, lower_32_bits(omt_phys));\n\tomt_phys = omt_phys + OMT_SIZE;\n\tout_be32(&pamu_regs->olah, upper_32_bits(omt_phys));\n\tout_be32(&pamu_regs->olal, lower_32_bits(omt_phys));\n\n\t \n\n\tout_be32((u32 *)(pamu_reg_base + PAMU_PICS),\n\t\t PAMU_ACCESS_VIOLATION_ENABLE);\n\tout_be32(pc, PAMU_PC_PE | PAMU_PC_OCE | PAMU_PC_SPCC | PAMU_PC_PPCC);\n\treturn 0;\n}\n\n \nstatic void setup_liodns(void)\n{\n\tint i, len;\n\tstruct paace *ppaace;\n\tstruct device_node *node = NULL;\n\tconst u32 *prop;\n\n\tfor_each_node_with_property(node, \"fsl,liodn\") {\n\t\tprop = of_get_property(node, \"fsl,liodn\", &len);\n\t\tfor (i = 0; i < len / sizeof(u32); i++) {\n\t\t\tint liodn;\n\n\t\t\tliodn = be32_to_cpup(&prop[i]);\n\t\t\tif (liodn >= PAACE_NUMBER_ENTRIES) {\n\t\t\t\tpr_debug(\"Invalid LIODN value %d\\n\", liodn);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tppaace = pamu_get_ppaace(liodn);\n\t\t\tpamu_init_ppaace(ppaace);\n\t\t\t \n\t\t\tset_bf(ppaace->addr_bitfields, PPAACE_AF_WSE, 35);\n\t\t\tppaace->wbah = 0;\n\t\t\tset_bf(ppaace->addr_bitfields, PPAACE_AF_WBAL, 0);\n\t\t\tset_bf(ppaace->impl_attr, PAACE_IA_ATM,\n\t\t\t       PAACE_ATM_NO_XLATE);\n\t\t\tset_bf(ppaace->addr_bitfields, PAACE_AF_AP,\n\t\t\t       PAACE_AP_PERMS_ALL);\n\t\t\tif (of_device_is_compatible(node, \"fsl,qman-portal\"))\n\t\t\t\tsetup_qbman_paace(ppaace, QMAN_PORTAL_PAACE);\n\t\t\tif (of_device_is_compatible(node, \"fsl,qman\"))\n\t\t\t\tsetup_qbman_paace(ppaace, QMAN_PAACE);\n\t\t\tif (of_device_is_compatible(node, \"fsl,bman\"))\n\t\t\t\tsetup_qbman_paace(ppaace, BMAN_PAACE);\n\t\t\tmb();\n\t\t\tpamu_enable_liodn(liodn);\n\t\t}\n\t}\n}\n\nstatic irqreturn_t pamu_av_isr(int irq, void *arg)\n{\n\tstruct pamu_isr_data *data = arg;\n\tphys_addr_t phys;\n\tunsigned int i, j, ret;\n\n\tpr_emerg(\"access violation interrupt\\n\");\n\n\tfor (i = 0; i < data->count; i++) {\n\t\tvoid __iomem *p = data->pamu_reg_base + i * PAMU_OFFSET;\n\t\tu32 pics = in_be32(p + PAMU_PICS);\n\n\t\tif (pics & PAMU_ACCESS_VIOLATION_STAT) {\n\t\t\tu32 avs1 = in_be32(p + PAMU_AVS1);\n\t\t\tstruct paace *paace;\n\n\t\t\tpr_emerg(\"POES1=%08x\\n\", in_be32(p + PAMU_POES1));\n\t\t\tpr_emerg(\"POES2=%08x\\n\", in_be32(p + PAMU_POES2));\n\t\t\tpr_emerg(\"AVS1=%08x\\n\", avs1);\n\t\t\tpr_emerg(\"AVS2=%08x\\n\", in_be32(p + PAMU_AVS2));\n\t\t\tpr_emerg(\"AVA=%016llx\\n\",\n\t\t\t\t make64(in_be32(p + PAMU_AVAH),\n\t\t\t\t\tin_be32(p + PAMU_AVAL)));\n\t\t\tpr_emerg(\"UDAD=%08x\\n\", in_be32(p + PAMU_UDAD));\n\t\t\tpr_emerg(\"POEA=%016llx\\n\",\n\t\t\t\t make64(in_be32(p + PAMU_POEAH),\n\t\t\t\t\tin_be32(p + PAMU_POEAL)));\n\n\t\t\tphys = make64(in_be32(p + PAMU_POEAH),\n\t\t\t\t      in_be32(p + PAMU_POEAL));\n\n\t\t\t \n\t\t\tif (phys) {\n\t\t\t\tu32 *paace = phys_to_virt(phys);\n\n\t\t\t\t \n\t\t\t\tfor (j = 0; j < 4; j++)\n\t\t\t\t\tpr_emerg(\"PAACE[%u]=%08x\\n\",\n\t\t\t\t\t\t j, in_be32(paace + j));\n\t\t\t}\n\n\t\t\t \n\t\t\tout_be32(p + PAMU_AVS1, avs1 & PAMU_AV_MASK);\n\t\t\tpaace = pamu_get_ppaace(avs1 >> PAMU_AVS1_LIODN_SHIFT);\n\t\t\tBUG_ON(!paace);\n\t\t\t \n\t\t\tif (!get_bf(paace->addr_bitfields, PAACE_AF_V)) {\n\t\t\t\t \n\t\t\t\tpics &= ~PAMU_ACCESS_VIOLATION_ENABLE;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tret = pamu_disable_liodn(avs1 >> PAMU_AVS1_LIODN_SHIFT);\n\t\t\t\tBUG_ON(ret);\n\t\t\t\tpr_emerg(\"Disabling liodn %x\\n\",\n\t\t\t\t\t avs1 >> PAMU_AVS1_LIODN_SHIFT);\n\t\t\t}\n\t\t\tout_be32((p + PAMU_PICS), pics);\n\t\t}\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n#define LAWAR_EN\t\t0x80000000\n#define LAWAR_TARGET_MASK\t0x0FF00000\n#define LAWAR_TARGET_SHIFT\t20\n#define LAWAR_SIZE_MASK\t\t0x0000003F\n#define LAWAR_CSDID_MASK\t0x000FF000\n#define LAWAR_CSDID_SHIFT\t12\n\n#define LAW_SIZE_4K\t\t0xb\n\nstruct ccsr_law {\n\tu32\tlawbarh;\t \n\tu32\tlawbarl;\t \n\tu32\tlawar;\t\t \n\tu32\treserved;\n};\n\n \nstatic int create_csd(phys_addr_t phys, size_t size, u32 csd_port_id)\n{\n\tstruct device_node *np;\n\tconst __be32 *iprop;\n\tvoid __iomem *lac = NULL;\t \n\tstruct ccsr_law __iomem *law;\n\tvoid __iomem *ccm = NULL;\n\tu32 __iomem *csdids;\n\tunsigned int i, num_laws, num_csds;\n\tu32 law_target = 0;\n\tu32 csd_id = 0;\n\tint ret = 0;\n\n\tnp = of_find_compatible_node(NULL, NULL, \"fsl,corenet-law\");\n\tif (!np)\n\t\treturn -ENODEV;\n\n\tiprop = of_get_property(np, \"fsl,num-laws\", NULL);\n\tif (!iprop) {\n\t\tret = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tnum_laws = be32_to_cpup(iprop);\n\tif (!num_laws) {\n\t\tret = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tlac = of_iomap(np, 0);\n\tif (!lac) {\n\t\tret = -ENODEV;\n\t\tgoto error;\n\t}\n\n\t \n\tlaw = lac + 0xC00;\n\n\tof_node_put(np);\n\n\tnp = of_find_compatible_node(NULL, NULL, \"fsl,corenet-cf\");\n\tif (!np) {\n\t\tret = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tiprop = of_get_property(np, \"fsl,ccf-num-csdids\", NULL);\n\tif (!iprop) {\n\t\tret = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tnum_csds = be32_to_cpup(iprop);\n\tif (!num_csds) {\n\t\tret = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tccm = of_iomap(np, 0);\n\tif (!ccm) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\t \n\tcsdids = ccm + 0x600;\n\n\tof_node_put(np);\n\tnp = NULL;\n\n\t \n\tfor (csd_id = 0; csd_id < num_csds; csd_id++) {\n\t\tif (!csdids[csd_id])\n\t\t\tbreak;\n\t}\n\n\t \n\tcsdids[csd_id] = csd_port_id;\n\n\t \n\tfor (i = 0; i < num_laws; i++) {\n\t\tif (law[i].lawar & LAWAR_EN) {\n\t\t\tphys_addr_t law_start, law_end;\n\n\t\t\tlaw_start = make64(law[i].lawbarh, law[i].lawbarl);\n\t\t\tlaw_end = law_start +\n\t\t\t\t(2ULL << (law[i].lawar & LAWAR_SIZE_MASK));\n\n\t\t\tif (law_start <= phys && phys < law_end) {\n\t\t\t\tlaw_target = law[i].lawar & LAWAR_TARGET_MASK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (i == 0 || i == num_laws) {\n\t\t \n\t\tret = -ENOENT;\n\t\tgoto error;\n\t}\n\n\t \n\twhile (law[--i].lawar & LAWAR_EN) {\n\t\tif (i == 0) {\n\t\t\t \n\t\t\tret = -ENOENT;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tlaw[i].lawbarh = upper_32_bits(phys);\n\tlaw[i].lawbarl = lower_32_bits(phys);\n\twmb();\n\tlaw[i].lawar = LAWAR_EN | law_target | (csd_id << LAWAR_CSDID_SHIFT) |\n\t\t(LAW_SIZE_4K + get_order(size));\n\twmb();\n\nerror:\n\tif (ccm)\n\t\tiounmap(ccm);\n\n\tif (lac)\n\t\tiounmap(lac);\n\n\tif (np)\n\t\tof_node_put(np);\n\n\treturn ret;\n}\n\n \nstatic const struct {\n\tu32 svr;\n\tu32 port_id;\n} port_id_map[] = {\n\t{(SVR_P2040 << 8) | 0x10, 0xFF000000},\t \n\t{(SVR_P2040 << 8) | 0x11, 0xFF000000},\t \n\t{(SVR_P2041 << 8) | 0x10, 0xFF000000},\t \n\t{(SVR_P2041 << 8) | 0x11, 0xFF000000},\t \n\t{(SVR_P3041 << 8) | 0x10, 0xFF000000},\t \n\t{(SVR_P3041 << 8) | 0x11, 0xFF000000},\t \n\t{(SVR_P4040 << 8) | 0x20, 0xFFF80000},\t \n\t{(SVR_P4080 << 8) | 0x20, 0xFFF80000},\t \n\t{(SVR_P5010 << 8) | 0x10, 0xFC000000},\t \n\t{(SVR_P5010 << 8) | 0x20, 0xFC000000},\t \n\t{(SVR_P5020 << 8) | 0x10, 0xFC000000},\t \n\t{(SVR_P5021 << 8) | 0x10, 0xFF800000},\t \n\t{(SVR_P5040 << 8) | 0x10, 0xFF800000},\t \n};\n\n#define SVR_SECURITY\t0x80000\t \n\nstatic int fsl_pamu_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tvoid __iomem *pamu_regs = NULL;\n\tstruct ccsr_guts __iomem *guts_regs = NULL;\n\tu32 pamubypenr, pamu_counter;\n\tunsigned long pamu_reg_off;\n\tunsigned long pamu_reg_base;\n\tstruct pamu_isr_data *data = NULL;\n\tstruct device_node *guts_node;\n\tu64 size;\n\tstruct page *p;\n\tint ret = 0;\n\tint irq;\n\tphys_addr_t ppaact_phys;\n\tphys_addr_t spaact_phys;\n\tstruct ome *omt;\n\tphys_addr_t omt_phys;\n\tsize_t mem_size = 0;\n\tunsigned int order = 0;\n\tu32 csd_port_id = 0;\n\tunsigned i;\n\t \n\n\tif (WARN_ON(probed))\n\t\treturn -EBUSY;\n\n\tpamu_regs = of_iomap(dev->of_node, 0);\n\tif (!pamu_regs) {\n\t\tdev_err(dev, \"ioremap of PAMU node failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tof_get_address(dev->of_node, 0, &size, NULL);\n\n\tirq = irq_of_parse_and_map(dev->of_node, 0);\n\tif (!irq) {\n\t\tdev_warn(dev, \"no interrupts listed in PAMU node\\n\");\n\t\tgoto error;\n\t}\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\tdata->pamu_reg_base = pamu_regs;\n\tdata->count = size / PAMU_OFFSET;\n\n\t \n\tret = request_irq(irq, pamu_av_isr, 0, \"pamu\", data);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"error %i installing ISR for irq %i\\n\", ret, irq);\n\t\tgoto error;\n\t}\n\n\tguts_node = of_find_matching_node(NULL, guts_device_ids);\n\tif (!guts_node) {\n\t\tdev_err(dev, \"could not find GUTS node %pOF\\n\", dev->of_node);\n\t\tret = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tguts_regs = of_iomap(guts_node, 0);\n\tof_node_put(guts_node);\n\tif (!guts_regs) {\n\t\tdev_err(dev, \"ioremap of GUTS node failed\\n\");\n\t\tret = -ENODEV;\n\t\tgoto error;\n\t}\n\n\t \n\tget_pamu_cap_values((unsigned long)pamu_regs);\n\t \n\t \n\tmem_size = (PAGE_SIZE << get_order(PAACT_SIZE)) +\n\t\t(PAGE_SIZE << get_order(SPAACT_SIZE)) +\n\t\t(PAGE_SIZE << get_order(OMT_SIZE));\n\torder = get_order(mem_size);\n\n\tp = alloc_pages(GFP_KERNEL | __GFP_ZERO, order);\n\tif (!p) {\n\t\tdev_err(dev, \"unable to allocate PAACT/SPAACT/OMT block\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tppaact = page_address(p);\n\tppaact_phys = page_to_phys(p);\n\n\t \n\tif (ppaact_phys & ((PAGE_SIZE << order) - 1)) {\n\t\tdev_err(dev, \"PAACT/OMT block is unaligned\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tspaact = (void *)ppaact + (PAGE_SIZE << get_order(PAACT_SIZE));\n\tomt = (void *)spaact + (PAGE_SIZE << get_order(SPAACT_SIZE));\n\n\tdev_dbg(dev, \"ppaact virt=%p phys=%pa\\n\", ppaact, &ppaact_phys);\n\n\t \n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(port_id_map); i++) {\n\t\tif (port_id_map[i].svr == (mfspr(SPRN_SVR) & ~SVR_SECURITY)) {\n\t\t\tcsd_port_id = port_id_map[i].port_id;\n\t\t\tdev_dbg(dev, \"found matching SVR %08x\\n\",\n\t\t\t\tport_id_map[i].svr);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (csd_port_id) {\n\t\tdev_dbg(dev, \"creating coherency subdomain at address %pa, size %zu, port id 0x%08x\",\n\t\t\t&ppaact_phys, mem_size, csd_port_id);\n\n\t\tret = create_csd(ppaact_phys, mem_size, csd_port_id);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"could not create coherence subdomain\\n\");\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tspaact_phys = virt_to_phys(spaact);\n\tomt_phys = virt_to_phys(omt);\n\n\tpamubypenr = in_be32(&guts_regs->pamubypenr);\n\n\tfor (pamu_reg_off = 0, pamu_counter = 0x80000000; pamu_reg_off < size;\n\t     pamu_reg_off += PAMU_OFFSET, pamu_counter >>= 1) {\n\n\t\tpamu_reg_base = (unsigned long)pamu_regs + pamu_reg_off;\n\t\tsetup_one_pamu(pamu_reg_base, pamu_reg_off, ppaact_phys,\n\t\t\t       spaact_phys, omt_phys);\n\t\t \n\t\tpamubypenr &= ~pamu_counter;\n\t}\n\n\tsetup_omt(omt);\n\n\t \n\tout_be32(&guts_regs->pamubypenr, pamubypenr);\n\n\tiounmap(guts_regs);\n\n\t \n\n\tsetup_liodns();\n\n\tprobed = true;\n\n\treturn 0;\n\nerror:\n\tif (irq)\n\t\tfree_irq(irq, data);\n\n\tkfree_sensitive(data);\n\n\tif (pamu_regs)\n\t\tiounmap(pamu_regs);\n\n\tif (guts_regs)\n\t\tiounmap(guts_regs);\n\n\tif (ppaact)\n\t\tfree_pages((unsigned long)ppaact, order);\n\n\tppaact = NULL;\n\n\treturn ret;\n}\n\nstatic struct platform_driver fsl_of_pamu_driver = {\n\t.driver = {\n\t\t.name = \"fsl-of-pamu\",\n\t},\n\t.probe = fsl_pamu_probe,\n};\n\nstatic __init int fsl_pamu_init(void)\n{\n\tstruct platform_device *pdev = NULL;\n\tstruct device_node *np;\n\tint ret;\n\n\t \n\n\t \n\n\tnp = of_find_compatible_node(NULL, NULL, \"fsl,pamu\");\n\tif (!np) {\n\t\tpr_err(\"could not find a PAMU node\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = platform_driver_register(&fsl_of_pamu_driver);\n\tif (ret) {\n\t\tpr_err(\"could not register driver (err=%i)\\n\", ret);\n\t\tgoto error_driver_register;\n\t}\n\n\tpdev = platform_device_alloc(\"fsl-of-pamu\", 0);\n\tif (!pdev) {\n\t\tpr_err(\"could not allocate device %pOF\\n\", np);\n\t\tret = -ENOMEM;\n\t\tgoto error_device_alloc;\n\t}\n\tpdev->dev.of_node = of_node_get(np);\n\n\tret = pamu_domain_init();\n\tif (ret)\n\t\tgoto error_device_add;\n\n\tret = platform_device_add(pdev);\n\tif (ret) {\n\t\tpr_err(\"could not add device %pOF (err=%i)\\n\", np, ret);\n\t\tgoto error_device_add;\n\t}\n\n\treturn 0;\n\nerror_device_add:\n\tof_node_put(pdev->dev.of_node);\n\tpdev->dev.of_node = NULL;\n\n\tplatform_device_put(pdev);\n\nerror_device_alloc:\n\tplatform_driver_unregister(&fsl_of_pamu_driver);\n\nerror_driver_register:\n\tof_node_put(np);\n\n\treturn ret;\n}\narch_initcall(fsl_pamu_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}