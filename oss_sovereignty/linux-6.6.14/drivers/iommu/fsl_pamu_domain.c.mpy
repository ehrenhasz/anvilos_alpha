{
  "module_name": "fsl_pamu_domain.c",
  "hash_id": "554438d2acc22a42858d7b3ec264d15940416f23b8f1324f209c8a8374c5e7e7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iommu/fsl_pamu_domain.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)    \"fsl-pamu-domain: %s: \" fmt, __func__\n\n#include \"fsl_pamu_domain.h\"\n\n#include <linux/platform_device.h>\n#include <sysdev/fsl_pci.h>\n\n \nstatic DEFINE_SPINLOCK(iommu_lock);\n\nstatic struct kmem_cache *fsl_pamu_domain_cache;\nstatic struct kmem_cache *iommu_devinfo_cache;\nstatic DEFINE_SPINLOCK(device_domain_lock);\n\nstruct iommu_device pamu_iommu;\t \n\nstatic struct fsl_dma_domain *to_fsl_dma_domain(struct iommu_domain *dom)\n{\n\treturn container_of(dom, struct fsl_dma_domain, iommu_domain);\n}\n\nstatic int __init iommu_init_mempool(void)\n{\n\tfsl_pamu_domain_cache = kmem_cache_create(\"fsl_pamu_domain\",\n\t\t\t\t\t\t  sizeof(struct fsl_dma_domain),\n\t\t\t\t\t\t  0,\n\t\t\t\t\t\t  SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t\t  NULL);\n\tif (!fsl_pamu_domain_cache) {\n\t\tpr_debug(\"Couldn't create fsl iommu_domain cache\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tiommu_devinfo_cache = kmem_cache_create(\"iommu_devinfo\",\n\t\t\t\t\t\tsizeof(struct device_domain_info),\n\t\t\t\t\t\t0,\n\t\t\t\t\t\tSLAB_HWCACHE_ALIGN,\n\t\t\t\t\t\tNULL);\n\tif (!iommu_devinfo_cache) {\n\t\tpr_debug(\"Couldn't create devinfo cache\\n\");\n\t\tkmem_cache_destroy(fsl_pamu_domain_cache);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic int update_liodn_stash(int liodn, struct fsl_dma_domain *dma_domain,\n\t\t\t      u32 val)\n{\n\tint ret = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&iommu_lock, flags);\n\tret = pamu_update_paace_stash(liodn, val);\n\tif (ret) {\n\t\tpr_debug(\"Failed to update SPAACE for liodn %d\\n \", liodn);\n\t\tspin_unlock_irqrestore(&iommu_lock, flags);\n\t\treturn ret;\n\t}\n\n\tspin_unlock_irqrestore(&iommu_lock, flags);\n\n\treturn ret;\n}\n\n \nstatic int pamu_set_liodn(struct fsl_dma_domain *dma_domain, struct device *dev,\n\t\t\t  int liodn)\n{\n\tu32 omi_index = ~(u32)0;\n\tunsigned long flags;\n\tint ret;\n\n\t \n\tget_ome_index(&omi_index, dev);\n\n\tspin_lock_irqsave(&iommu_lock, flags);\n\tret = pamu_disable_liodn(liodn);\n\tif (ret)\n\t\tgoto out_unlock;\n\tret = pamu_config_ppaace(liodn, omi_index, dma_domain->stash_id, 0);\n\tif (ret)\n\t\tgoto out_unlock;\n\tret = pamu_config_ppaace(liodn, ~(u32)0, dma_domain->stash_id,\n\t\t\t\t PAACE_AP_PERMS_QUERY | PAACE_AP_PERMS_UPDATE);\nout_unlock:\n\tspin_unlock_irqrestore(&iommu_lock, flags);\n\tif (ret) {\n\t\tpr_debug(\"PAACE configuration failed for liodn %d\\n\",\n\t\t\t liodn);\n\t}\n\treturn ret;\n}\n\nstatic void remove_device_ref(struct device_domain_info *info)\n{\n\tunsigned long flags;\n\n\tlist_del(&info->link);\n\tspin_lock_irqsave(&iommu_lock, flags);\n\tpamu_disable_liodn(info->liodn);\n\tspin_unlock_irqrestore(&iommu_lock, flags);\n\tspin_lock_irqsave(&device_domain_lock, flags);\n\tdev_iommu_priv_set(info->dev, NULL);\n\tkmem_cache_free(iommu_devinfo_cache, info);\n\tspin_unlock_irqrestore(&device_domain_lock, flags);\n}\n\nstatic void detach_device(struct device *dev, struct fsl_dma_domain *dma_domain)\n{\n\tstruct device_domain_info *info, *tmp;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dma_domain->domain_lock, flags);\n\t \n\tlist_for_each_entry_safe(info, tmp, &dma_domain->devices, link) {\n\t\tif (!dev || (info->dev == dev))\n\t\t\tremove_device_ref(info);\n\t}\n\tspin_unlock_irqrestore(&dma_domain->domain_lock, flags);\n}\n\nstatic void attach_device(struct fsl_dma_domain *dma_domain, int liodn, struct device *dev)\n{\n\tstruct device_domain_info *info, *old_domain_info;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&device_domain_lock, flags);\n\t \n\told_domain_info = dev_iommu_priv_get(dev);\n\tif (old_domain_info && old_domain_info->domain != dma_domain) {\n\t\tspin_unlock_irqrestore(&device_domain_lock, flags);\n\t\tdetach_device(dev, old_domain_info->domain);\n\t\tspin_lock_irqsave(&device_domain_lock, flags);\n\t}\n\n\tinfo = kmem_cache_zalloc(iommu_devinfo_cache, GFP_ATOMIC);\n\n\tinfo->dev = dev;\n\tinfo->liodn = liodn;\n\tinfo->domain = dma_domain;\n\n\tlist_add(&info->link, &dma_domain->devices);\n\t \n\tif (!dev_iommu_priv_get(dev))\n\t\tdev_iommu_priv_set(dev, info);\n\tspin_unlock_irqrestore(&device_domain_lock, flags);\n}\n\nstatic phys_addr_t fsl_pamu_iova_to_phys(struct iommu_domain *domain,\n\t\t\t\t\t dma_addr_t iova)\n{\n\tif (iova < domain->geometry.aperture_start ||\n\t    iova > domain->geometry.aperture_end)\n\t\treturn 0;\n\treturn iova;\n}\n\nstatic bool fsl_pamu_capable(struct device *dev, enum iommu_cap cap)\n{\n\treturn cap == IOMMU_CAP_CACHE_COHERENCY;\n}\n\nstatic void fsl_pamu_domain_free(struct iommu_domain *domain)\n{\n\tstruct fsl_dma_domain *dma_domain = to_fsl_dma_domain(domain);\n\n\t \n\tdetach_device(NULL, dma_domain);\n\tkmem_cache_free(fsl_pamu_domain_cache, dma_domain);\n}\n\nstatic struct iommu_domain *fsl_pamu_domain_alloc(unsigned type)\n{\n\tstruct fsl_dma_domain *dma_domain;\n\n\tif (type != IOMMU_DOMAIN_UNMANAGED)\n\t\treturn NULL;\n\n\tdma_domain = kmem_cache_zalloc(fsl_pamu_domain_cache, GFP_KERNEL);\n\tif (!dma_domain)\n\t\treturn NULL;\n\n\tdma_domain->stash_id = ~(u32)0;\n\tINIT_LIST_HEAD(&dma_domain->devices);\n\tspin_lock_init(&dma_domain->domain_lock);\n\n\t \n\tdma_domain->iommu_domain. geometry.aperture_start = 0;\n\tdma_domain->iommu_domain.geometry.aperture_end = (1ULL << 36) - 1;\n\tdma_domain->iommu_domain.geometry.force_aperture = true;\n\n\treturn &dma_domain->iommu_domain;\n}\n\n \nstatic int update_domain_stash(struct fsl_dma_domain *dma_domain, u32 val)\n{\n\tstruct device_domain_info *info;\n\tint ret = 0;\n\n\tlist_for_each_entry(info, &dma_domain->devices, link) {\n\t\tret = update_liodn_stash(info->liodn, dma_domain, val);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int fsl_pamu_attach_device(struct iommu_domain *domain,\n\t\t\t\t  struct device *dev)\n{\n\tstruct fsl_dma_domain *dma_domain = to_fsl_dma_domain(domain);\n\tunsigned long flags;\n\tint len, ret = 0, i;\n\tconst u32 *liodn;\n\tstruct pci_dev *pdev = NULL;\n\tstruct pci_controller *pci_ctl;\n\n\t \n\tif (dev_is_pci(dev)) {\n\t\tpdev = to_pci_dev(dev);\n\t\tpci_ctl = pci_bus_to_host(pdev->bus);\n\t\t \n\t\tdev = pci_ctl->parent;\n\t}\n\n\tliodn = of_get_property(dev->of_node, \"fsl,liodn\", &len);\n\tif (!liodn) {\n\t\tpr_debug(\"missing fsl,liodn property at %pOF\\n\", dev->of_node);\n\t\treturn -ENODEV;\n\t}\n\n\tspin_lock_irqsave(&dma_domain->domain_lock, flags);\n\tfor (i = 0; i < len / sizeof(u32); i++) {\n\t\t \n\t\tif (liodn[i] >= PAACE_NUMBER_ENTRIES) {\n\t\t\tpr_debug(\"Invalid liodn %d, attach device failed for %pOF\\n\",\n\t\t\t\t liodn[i], dev->of_node);\n\t\t\tret = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\n\t\tattach_device(dma_domain, liodn[i], dev);\n\t\tret = pamu_set_liodn(dma_domain, dev, liodn[i]);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = pamu_enable_liodn(liodn[i]);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&dma_domain->domain_lock, flags);\n\treturn ret;\n}\n\nstatic void fsl_pamu_set_platform_dma(struct device *dev)\n{\n\tstruct iommu_domain *domain = iommu_get_domain_for_dev(dev);\n\tstruct fsl_dma_domain *dma_domain = to_fsl_dma_domain(domain);\n\tconst u32 *prop;\n\tint len;\n\tstruct pci_dev *pdev = NULL;\n\tstruct pci_controller *pci_ctl;\n\n\t \n\tif (dev_is_pci(dev)) {\n\t\tpdev = to_pci_dev(dev);\n\t\tpci_ctl = pci_bus_to_host(pdev->bus);\n\t\t \n\t\tdev = pci_ctl->parent;\n\t}\n\n\tprop = of_get_property(dev->of_node, \"fsl,liodn\", &len);\n\tif (prop)\n\t\tdetach_device(dev, dma_domain);\n\telse\n\t\tpr_debug(\"missing fsl,liodn property at %pOF\\n\", dev->of_node);\n}\n\n \nint fsl_pamu_configure_l1_stash(struct iommu_domain *domain, u32 cpu)\n{\n\tstruct fsl_dma_domain *dma_domain = to_fsl_dma_domain(domain);\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&dma_domain->domain_lock, flags);\n\tdma_domain->stash_id = get_stash_id(PAMU_ATTR_CACHE_L1, cpu);\n\tif (dma_domain->stash_id == ~(u32)0) {\n\t\tpr_debug(\"Invalid stash attributes\\n\");\n\t\tspin_unlock_irqrestore(&dma_domain->domain_lock, flags);\n\t\treturn -EINVAL;\n\t}\n\tret = update_domain_stash(dma_domain, dma_domain->stash_id);\n\tspin_unlock_irqrestore(&dma_domain->domain_lock, flags);\n\n\treturn ret;\n}\n\nstatic  bool check_pci_ctl_endpt_part(struct pci_controller *pci_ctl)\n{\n\tu32 version;\n\n\t \n\tversion = in_be32(pci_ctl->cfg_addr + (PCI_FSL_BRR1 >> 2));\n\tversion &= PCI_FSL_BRR1_VER;\n\t \n\treturn version >= 0x204;\n}\n\nstatic struct iommu_group *fsl_pamu_device_group(struct device *dev)\n{\n\tstruct iommu_group *group;\n\tstruct pci_dev *pdev;\n\n\t \n\tif (!dev_is_pci(dev))\n\t\treturn generic_device_group(dev);\n\n\t \n\tpdev = to_pci_dev(dev);\n\tif (check_pci_ctl_endpt_part(pci_bus_to_host(pdev->bus)))\n\t\treturn pci_device_group(&pdev->dev);\n\n\t \n\tgroup = iommu_group_get(pci_bus_to_host(pdev->bus)->parent);\n\tif (WARN_ON(!group))\n\t\treturn ERR_PTR(-EINVAL);\n\treturn group;\n}\n\nstatic struct iommu_device *fsl_pamu_probe_device(struct device *dev)\n{\n\tint len;\n\n\t \n\tif (!dev_is_pci(dev) &&\n\t    !of_get_property(dev->of_node, \"fsl,liodn\", &len))\n\t\treturn ERR_PTR(-ENODEV);\n\n\treturn &pamu_iommu;\n}\n\nstatic const struct iommu_ops fsl_pamu_ops = {\n\t.capable\t= fsl_pamu_capable,\n\t.domain_alloc\t= fsl_pamu_domain_alloc,\n\t.probe_device\t= fsl_pamu_probe_device,\n\t.device_group   = fsl_pamu_device_group,\n\t.set_platform_dma_ops = fsl_pamu_set_platform_dma,\n\t.default_domain_ops = &(const struct iommu_domain_ops) {\n\t\t.attach_dev\t= fsl_pamu_attach_device,\n\t\t.iova_to_phys\t= fsl_pamu_iova_to_phys,\n\t\t.free\t\t= fsl_pamu_domain_free,\n\t}\n};\n\nint __init pamu_domain_init(void)\n{\n\tint ret = 0;\n\n\tret = iommu_init_mempool();\n\tif (ret)\n\t\treturn ret;\n\n\tret = iommu_device_sysfs_add(&pamu_iommu, NULL, NULL, \"iommu0\");\n\tif (ret)\n\t\treturn ret;\n\n\tret = iommu_device_register(&pamu_iommu, &fsl_pamu_ops, NULL);\n\tif (ret) {\n\t\tiommu_device_sysfs_remove(&pamu_iommu);\n\t\tpr_err(\"Can't register iommu device\\n\");\n\t}\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}