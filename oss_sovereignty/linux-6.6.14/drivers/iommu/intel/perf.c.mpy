{
  "module_name": "perf.c",
  "hash_id": "430f2adc73abf81c440203ab3c91e838a4a4db0a5f3fda6ea61fa0d87438ec12",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iommu/intel/perf.c",
  "human_readable_source": "\n \n\n#include <linux/spinlock.h>\n\n#include \"iommu.h\"\n#include \"perf.h\"\n\nstatic DEFINE_SPINLOCK(latency_lock);\n\nbool dmar_latency_enabled(struct intel_iommu *iommu, enum latency_type type)\n{\n\tstruct latency_statistic *lstat = iommu->perf_statistic;\n\n\treturn lstat && lstat[type].enabled;\n}\n\nint dmar_latency_enable(struct intel_iommu *iommu, enum latency_type type)\n{\n\tstruct latency_statistic *lstat;\n\tunsigned long flags;\n\tint ret = -EBUSY;\n\n\tif (dmar_latency_enabled(iommu, type))\n\t\treturn 0;\n\n\tspin_lock_irqsave(&latency_lock, flags);\n\tif (!iommu->perf_statistic) {\n\t\tiommu->perf_statistic = kzalloc(sizeof(*lstat) * DMAR_LATENCY_NUM,\n\t\t\t\t\t\tGFP_ATOMIC);\n\t\tif (!iommu->perf_statistic) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto unlock_out;\n\t\t}\n\t}\n\n\tlstat = iommu->perf_statistic;\n\n\tif (!lstat[type].enabled) {\n\t\tlstat[type].enabled = true;\n\t\tlstat[type].counter[COUNTS_MIN] = UINT_MAX;\n\t\tret = 0;\n\t}\nunlock_out:\n\tspin_unlock_irqrestore(&latency_lock, flags);\n\n\treturn ret;\n}\n\nvoid dmar_latency_disable(struct intel_iommu *iommu, enum latency_type type)\n{\n\tstruct latency_statistic *lstat = iommu->perf_statistic;\n\tunsigned long flags;\n\n\tif (!dmar_latency_enabled(iommu, type))\n\t\treturn;\n\n\tspin_lock_irqsave(&latency_lock, flags);\n\tmemset(&lstat[type], 0, sizeof(*lstat) * DMAR_LATENCY_NUM);\n\tspin_unlock_irqrestore(&latency_lock, flags);\n}\n\nvoid dmar_latency_update(struct intel_iommu *iommu, enum latency_type type, u64 latency)\n{\n\tstruct latency_statistic *lstat = iommu->perf_statistic;\n\tunsigned long flags;\n\tu64 min, max;\n\n\tif (!dmar_latency_enabled(iommu, type))\n\t\treturn;\n\n\tspin_lock_irqsave(&latency_lock, flags);\n\tif (latency < 100)\n\t\tlstat[type].counter[COUNTS_10e2]++;\n\telse if (latency < 1000)\n\t\tlstat[type].counter[COUNTS_10e3]++;\n\telse if (latency < 10000)\n\t\tlstat[type].counter[COUNTS_10e4]++;\n\telse if (latency < 100000)\n\t\tlstat[type].counter[COUNTS_10e5]++;\n\telse if (latency < 1000000)\n\t\tlstat[type].counter[COUNTS_10e6]++;\n\telse if (latency < 10000000)\n\t\tlstat[type].counter[COUNTS_10e7]++;\n\telse\n\t\tlstat[type].counter[COUNTS_10e8_plus]++;\n\n\tmin = lstat[type].counter[COUNTS_MIN];\n\tmax = lstat[type].counter[COUNTS_MAX];\n\tlstat[type].counter[COUNTS_MIN] = min_t(u64, min, latency);\n\tlstat[type].counter[COUNTS_MAX] = max_t(u64, max, latency);\n\tlstat[type].counter[COUNTS_SUM] += latency;\n\tlstat[type].samples++;\n\tspin_unlock_irqrestore(&latency_lock, flags);\n}\n\nstatic char *latency_counter_names[] = {\n\t\"                  <0.1us\",\n\t\"   0.1us-1us\", \"    1us-10us\", \"  10us-100us\",\n\t\"   100us-1ms\", \"    1ms-10ms\", \"      >=10ms\",\n\t\"     min(us)\", \"     max(us)\", \" average(us)\"\n};\n\nstatic char *latency_type_names[] = {\n\t\"   inv_iotlb\", \"  inv_devtlb\", \"     inv_iec\",\n\t\"     svm_prq\"\n};\n\nint dmar_latency_snapshot(struct intel_iommu *iommu, char *str, size_t size)\n{\n\tstruct latency_statistic *lstat = iommu->perf_statistic;\n\tunsigned long flags;\n\tint bytes = 0, i, j;\n\n\tmemset(str, 0, size);\n\n\tfor (i = 0; i < COUNTS_NUM; i++)\n\t\tbytes += snprintf(str + bytes, size - bytes,\n\t\t\t\t  \"%s\", latency_counter_names[i]);\n\n\tspin_lock_irqsave(&latency_lock, flags);\n\tfor (i = 0; i < DMAR_LATENCY_NUM; i++) {\n\t\tif (!dmar_latency_enabled(iommu, i))\n\t\t\tcontinue;\n\n\t\tbytes += snprintf(str + bytes, size - bytes,\n\t\t\t\t  \"\\n%s\", latency_type_names[i]);\n\n\t\tfor (j = 0; j < COUNTS_NUM; j++) {\n\t\t\tu64 val = lstat[i].counter[j];\n\n\t\t\tswitch (j) {\n\t\t\tcase COUNTS_MIN:\n\t\t\t\tif (val == UINT_MAX)\n\t\t\t\t\tval = 0;\n\t\t\t\telse\n\t\t\t\t\tval = div_u64(val, 1000);\n\t\t\t\tbreak;\n\t\t\tcase COUNTS_MAX:\n\t\t\t\tval = div_u64(val, 1000);\n\t\t\t\tbreak;\n\t\t\tcase COUNTS_SUM:\n\t\t\t\tif (lstat[i].samples)\n\t\t\t\t\tval = div_u64(val, (lstat[i].samples * 1000));\n\t\t\t\telse\n\t\t\t\t\tval = 0;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbytes += snprintf(str + bytes, size - bytes,\n\t\t\t\t\t  \"%12lld\", val);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&latency_lock, flags);\n\n\treturn bytes;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}