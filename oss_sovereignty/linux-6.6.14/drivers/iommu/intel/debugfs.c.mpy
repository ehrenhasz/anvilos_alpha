{
  "module_name": "debugfs.c",
  "hash_id": "5ef582066cbb4836cf177be15c53276aa9a0c63127d04cfc3cf5e8f2d2e36d1e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iommu/intel/debugfs.c",
  "human_readable_source": "\n \n\n#include <linux/debugfs.h>\n#include <linux/dmar.h>\n#include <linux/pci.h>\n\n#include <asm/irq_remapping.h>\n\n#include \"iommu.h\"\n#include \"pasid.h\"\n#include \"perf.h\"\n\nstruct tbl_walk {\n\tu16 bus;\n\tu16 devfn;\n\tu32 pasid;\n\tstruct root_entry *rt_entry;\n\tstruct context_entry *ctx_entry;\n\tstruct pasid_entry *pasid_tbl_entry;\n};\n\nstruct iommu_regset {\n\tint offset;\n\tconst char *regs;\n};\n\n#define DEBUG_BUFFER_SIZE\t1024\nstatic char debug_buf[DEBUG_BUFFER_SIZE];\n\n#define IOMMU_REGSET_ENTRY(_reg_)\t\t\t\t\t\\\n\t{ DMAR_##_reg_##_REG, __stringify(_reg_) }\n\nstatic const struct iommu_regset iommu_regs_32[] = {\n\tIOMMU_REGSET_ENTRY(VER),\n\tIOMMU_REGSET_ENTRY(GCMD),\n\tIOMMU_REGSET_ENTRY(GSTS),\n\tIOMMU_REGSET_ENTRY(FSTS),\n\tIOMMU_REGSET_ENTRY(FECTL),\n\tIOMMU_REGSET_ENTRY(FEDATA),\n\tIOMMU_REGSET_ENTRY(FEADDR),\n\tIOMMU_REGSET_ENTRY(FEUADDR),\n\tIOMMU_REGSET_ENTRY(PMEN),\n\tIOMMU_REGSET_ENTRY(PLMBASE),\n\tIOMMU_REGSET_ENTRY(PLMLIMIT),\n\tIOMMU_REGSET_ENTRY(ICS),\n\tIOMMU_REGSET_ENTRY(PRS),\n\tIOMMU_REGSET_ENTRY(PECTL),\n\tIOMMU_REGSET_ENTRY(PEDATA),\n\tIOMMU_REGSET_ENTRY(PEADDR),\n\tIOMMU_REGSET_ENTRY(PEUADDR),\n};\n\nstatic const struct iommu_regset iommu_regs_64[] = {\n\tIOMMU_REGSET_ENTRY(CAP),\n\tIOMMU_REGSET_ENTRY(ECAP),\n\tIOMMU_REGSET_ENTRY(RTADDR),\n\tIOMMU_REGSET_ENTRY(CCMD),\n\tIOMMU_REGSET_ENTRY(AFLOG),\n\tIOMMU_REGSET_ENTRY(PHMBASE),\n\tIOMMU_REGSET_ENTRY(PHMLIMIT),\n\tIOMMU_REGSET_ENTRY(IQH),\n\tIOMMU_REGSET_ENTRY(IQT),\n\tIOMMU_REGSET_ENTRY(IQA),\n\tIOMMU_REGSET_ENTRY(IRTA),\n\tIOMMU_REGSET_ENTRY(PQH),\n\tIOMMU_REGSET_ENTRY(PQT),\n\tIOMMU_REGSET_ENTRY(PQA),\n\tIOMMU_REGSET_ENTRY(MTRRCAP),\n\tIOMMU_REGSET_ENTRY(MTRRDEF),\n\tIOMMU_REGSET_ENTRY(MTRR_FIX64K_00000),\n\tIOMMU_REGSET_ENTRY(MTRR_FIX16K_80000),\n\tIOMMU_REGSET_ENTRY(MTRR_FIX16K_A0000),\n\tIOMMU_REGSET_ENTRY(MTRR_FIX4K_C0000),\n\tIOMMU_REGSET_ENTRY(MTRR_FIX4K_C8000),\n\tIOMMU_REGSET_ENTRY(MTRR_FIX4K_D0000),\n\tIOMMU_REGSET_ENTRY(MTRR_FIX4K_D8000),\n\tIOMMU_REGSET_ENTRY(MTRR_FIX4K_E0000),\n\tIOMMU_REGSET_ENTRY(MTRR_FIX4K_E8000),\n\tIOMMU_REGSET_ENTRY(MTRR_FIX4K_F0000),\n\tIOMMU_REGSET_ENTRY(MTRR_FIX4K_F8000),\n\tIOMMU_REGSET_ENTRY(MTRR_PHYSBASE0),\n\tIOMMU_REGSET_ENTRY(MTRR_PHYSMASK0),\n\tIOMMU_REGSET_ENTRY(MTRR_PHYSBASE1),\n\tIOMMU_REGSET_ENTRY(MTRR_PHYSMASK1),\n\tIOMMU_REGSET_ENTRY(MTRR_PHYSBASE2),\n\tIOMMU_REGSET_ENTRY(MTRR_PHYSMASK2),\n\tIOMMU_REGSET_ENTRY(MTRR_PHYSBASE3),\n\tIOMMU_REGSET_ENTRY(MTRR_PHYSMASK3),\n\tIOMMU_REGSET_ENTRY(MTRR_PHYSBASE4),\n\tIOMMU_REGSET_ENTRY(MTRR_PHYSMASK4),\n\tIOMMU_REGSET_ENTRY(MTRR_PHYSBASE5),\n\tIOMMU_REGSET_ENTRY(MTRR_PHYSMASK5),\n\tIOMMU_REGSET_ENTRY(MTRR_PHYSBASE6),\n\tIOMMU_REGSET_ENTRY(MTRR_PHYSMASK6),\n\tIOMMU_REGSET_ENTRY(MTRR_PHYSBASE7),\n\tIOMMU_REGSET_ENTRY(MTRR_PHYSMASK7),\n\tIOMMU_REGSET_ENTRY(MTRR_PHYSBASE8),\n\tIOMMU_REGSET_ENTRY(MTRR_PHYSMASK8),\n\tIOMMU_REGSET_ENTRY(MTRR_PHYSBASE9),\n\tIOMMU_REGSET_ENTRY(MTRR_PHYSMASK9),\n\tIOMMU_REGSET_ENTRY(VCCAP),\n\tIOMMU_REGSET_ENTRY(VCMD),\n\tIOMMU_REGSET_ENTRY(VCRSP),\n};\n\nstatic int iommu_regset_show(struct seq_file *m, void *unused)\n{\n\tstruct dmar_drhd_unit *drhd;\n\tstruct intel_iommu *iommu;\n\tunsigned long flag;\n\tint i, ret = 0;\n\tu64 value;\n\n\trcu_read_lock();\n\tfor_each_active_iommu(iommu, drhd) {\n\t\tif (!drhd->reg_base_addr) {\n\t\t\tseq_puts(m, \"IOMMU: Invalid base address\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tseq_printf(m, \"IOMMU: %s Register Base Address: %llx\\n\",\n\t\t\t   iommu->name, drhd->reg_base_addr);\n\t\tseq_puts(m, \"Name\\t\\t\\tOffset\\t\\tContents\\n\");\n\t\t \n\t\traw_spin_lock_irqsave(&iommu->register_lock, flag);\n\t\tfor (i = 0 ; i < ARRAY_SIZE(iommu_regs_32); i++) {\n\t\t\tvalue = dmar_readl(iommu->reg + iommu_regs_32[i].offset);\n\t\t\tseq_printf(m, \"%-16s\\t0x%02x\\t\\t0x%016llx\\n\",\n\t\t\t\t   iommu_regs_32[i].regs, iommu_regs_32[i].offset,\n\t\t\t\t   value);\n\t\t}\n\t\tfor (i = 0 ; i < ARRAY_SIZE(iommu_regs_64); i++) {\n\t\t\tvalue = dmar_readq(iommu->reg + iommu_regs_64[i].offset);\n\t\t\tseq_printf(m, \"%-16s\\t0x%02x\\t\\t0x%016llx\\n\",\n\t\t\t\t   iommu_regs_64[i].regs, iommu_regs_64[i].offset,\n\t\t\t\t   value);\n\t\t}\n\t\traw_spin_unlock_irqrestore(&iommu->register_lock, flag);\n\t\tseq_putc(m, '\\n');\n\t}\nout:\n\trcu_read_unlock();\n\n\treturn ret;\n}\nDEFINE_SHOW_ATTRIBUTE(iommu_regset);\n\nstatic inline void print_tbl_walk(struct seq_file *m)\n{\n\tstruct tbl_walk *tbl_wlk = m->private;\n\n\tseq_printf(m, \"%02x:%02x.%x\\t0x%016llx:0x%016llx\\t0x%016llx:0x%016llx\\t\",\n\t\t   tbl_wlk->bus, PCI_SLOT(tbl_wlk->devfn),\n\t\t   PCI_FUNC(tbl_wlk->devfn), tbl_wlk->rt_entry->hi,\n\t\t   tbl_wlk->rt_entry->lo, tbl_wlk->ctx_entry->hi,\n\t\t   tbl_wlk->ctx_entry->lo);\n\n\t \n\tif (!tbl_wlk->pasid_tbl_entry)\n\t\tseq_printf(m, \"%-6d\\t0x%016llx:0x%016llx:0x%016llx\\n\", -1,\n\t\t\t   (u64)0, (u64)0, (u64)0);\n\telse\n\t\tseq_printf(m, \"%-6d\\t0x%016llx:0x%016llx:0x%016llx\\n\",\n\t\t\t   tbl_wlk->pasid, tbl_wlk->pasid_tbl_entry->val[2],\n\t\t\t   tbl_wlk->pasid_tbl_entry->val[1],\n\t\t\t   tbl_wlk->pasid_tbl_entry->val[0]);\n}\n\nstatic void pasid_tbl_walk(struct seq_file *m, struct pasid_entry *tbl_entry,\n\t\t\t   u16 dir_idx)\n{\n\tstruct tbl_walk *tbl_wlk = m->private;\n\tu8 tbl_idx;\n\n\tfor (tbl_idx = 0; tbl_idx < PASID_TBL_ENTRIES; tbl_idx++) {\n\t\tif (pasid_pte_is_present(tbl_entry)) {\n\t\t\ttbl_wlk->pasid_tbl_entry = tbl_entry;\n\t\t\ttbl_wlk->pasid = (dir_idx << PASID_PDE_SHIFT) + tbl_idx;\n\t\t\tprint_tbl_walk(m);\n\t\t}\n\n\t\ttbl_entry++;\n\t}\n}\n\nstatic void pasid_dir_walk(struct seq_file *m, u64 pasid_dir_ptr,\n\t\t\t   u16 pasid_dir_size)\n{\n\tstruct pasid_dir_entry *dir_entry = phys_to_virt(pasid_dir_ptr);\n\tstruct pasid_entry *pasid_tbl;\n\tu16 dir_idx;\n\n\tfor (dir_idx = 0; dir_idx < pasid_dir_size; dir_idx++) {\n\t\tpasid_tbl = get_pasid_table_from_pde(dir_entry);\n\t\tif (pasid_tbl)\n\t\t\tpasid_tbl_walk(m, pasid_tbl, dir_idx);\n\n\t\tdir_entry++;\n\t}\n}\n\nstatic void ctx_tbl_walk(struct seq_file *m, struct intel_iommu *iommu, u16 bus)\n{\n\tstruct context_entry *context;\n\tu16 devfn, pasid_dir_size;\n\tu64 pasid_dir_ptr;\n\n\tfor (devfn = 0; devfn < 256; devfn++) {\n\t\tstruct tbl_walk tbl_wlk = {0};\n\n\t\t \n\t\tcontext = iommu_context_addr(iommu, bus, devfn, 0);\n\t\tif (!context)\n\t\t\treturn;\n\n\t\tif (!context_present(context))\n\t\t\tcontinue;\n\n\t\ttbl_wlk.bus = bus;\n\t\ttbl_wlk.devfn = devfn;\n\t\ttbl_wlk.rt_entry = &iommu->root_entry[bus];\n\t\ttbl_wlk.ctx_entry = context;\n\t\tm->private = &tbl_wlk;\n\n\t\tif (dmar_readq(iommu->reg + DMAR_RTADDR_REG) & DMA_RTADDR_SMT) {\n\t\t\tpasid_dir_ptr = context->lo & VTD_PAGE_MASK;\n\t\t\tpasid_dir_size = get_pasid_dir_size(context);\n\t\t\tpasid_dir_walk(m, pasid_dir_ptr, pasid_dir_size);\n\t\t\tcontinue;\n\t\t}\n\n\t\tprint_tbl_walk(m);\n\t}\n}\n\nstatic void root_tbl_walk(struct seq_file *m, struct intel_iommu *iommu)\n{\n\tu16 bus;\n\n\tspin_lock(&iommu->lock);\n\tseq_printf(m, \"IOMMU %s: Root Table Address: 0x%llx\\n\", iommu->name,\n\t\t   (u64)virt_to_phys(iommu->root_entry));\n\tseq_puts(m, \"B.D.F\\tRoot_entry\\t\\t\\t\\tContext_entry\\t\\t\\t\\tPASID\\tPASID_table_entry\\n\");\n\n\t \n\tfor (bus = 0; bus < 256; bus++)\n\t\tctx_tbl_walk(m, iommu, bus);\n\tspin_unlock(&iommu->lock);\n}\n\nstatic int dmar_translation_struct_show(struct seq_file *m, void *unused)\n{\n\tstruct dmar_drhd_unit *drhd;\n\tstruct intel_iommu *iommu;\n\tu32 sts;\n\n\trcu_read_lock();\n\tfor_each_active_iommu(iommu, drhd) {\n\t\tsts = dmar_readl(iommu->reg + DMAR_GSTS_REG);\n\t\tif (!(sts & DMA_GSTS_TES)) {\n\t\t\tseq_printf(m, \"DMA Remapping is not enabled on %s\\n\",\n\t\t\t\t   iommu->name);\n\t\t\tcontinue;\n\t\t}\n\t\troot_tbl_walk(m, iommu);\n\t\tseq_putc(m, '\\n');\n\t}\n\trcu_read_unlock();\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(dmar_translation_struct);\n\nstatic inline unsigned long level_to_directory_size(int level)\n{\n\treturn BIT_ULL(VTD_PAGE_SHIFT + VTD_STRIDE_SHIFT * (level - 1));\n}\n\nstatic inline void\ndump_page_info(struct seq_file *m, unsigned long iova, u64 *path)\n{\n\tseq_printf(m, \"0x%013lx |\\t0x%016llx\\t0x%016llx\\t0x%016llx\\t0x%016llx\\t0x%016llx\\n\",\n\t\t   iova >> VTD_PAGE_SHIFT, path[5], path[4],\n\t\t   path[3], path[2], path[1]);\n}\n\nstatic void pgtable_walk_level(struct seq_file *m, struct dma_pte *pde,\n\t\t\t       int level, unsigned long start,\n\t\t\t       u64 *path)\n{\n\tint i;\n\n\tif (level > 5 || level < 1)\n\t\treturn;\n\n\tfor (i = 0; i < BIT_ULL(VTD_STRIDE_SHIFT);\n\t\t\ti++, pde++, start += level_to_directory_size(level)) {\n\t\tif (!dma_pte_present(pde))\n\t\t\tcontinue;\n\n\t\tpath[level] = pde->val;\n\t\tif (dma_pte_superpage(pde) || level == 1)\n\t\t\tdump_page_info(m, start, path);\n\t\telse\n\t\t\tpgtable_walk_level(m, phys_to_virt(dma_pte_addr(pde)),\n\t\t\t\t\t   level - 1, start, path);\n\t\tpath[level] = 0;\n\t}\n}\n\nstatic int __show_device_domain_translation(struct device *dev, void *data)\n{\n\tstruct dmar_domain *domain;\n\tstruct seq_file *m = data;\n\tu64 path[6] = { 0 };\n\n\tdomain = to_dmar_domain(iommu_get_domain_for_dev(dev));\n\tif (!domain)\n\t\treturn 0;\n\n\tseq_printf(m, \"Device %s @0x%llx\\n\", dev_name(dev),\n\t\t   (u64)virt_to_phys(domain->pgd));\n\tseq_puts(m, \"IOVA_PFN\\t\\tPML5E\\t\\t\\tPML4E\\t\\t\\tPDPE\\t\\t\\tPDE\\t\\t\\tPTE\\n\");\n\n\tpgtable_walk_level(m, domain->pgd, domain->agaw + 2, 0, path);\n\tseq_putc(m, '\\n');\n\n\t \n\treturn 1;\n}\n\nstatic int show_device_domain_translation(struct device *dev, void *data)\n{\n\tstruct iommu_group *group;\n\n\tgroup = iommu_group_get(dev);\n\tif (group) {\n\t\t \n\t\tiommu_group_for_each_dev(group, data,\n\t\t\t\t\t __show_device_domain_translation);\n\t\tiommu_group_put(group);\n\t}\n\n\treturn 0;\n}\n\nstatic int domain_translation_struct_show(struct seq_file *m, void *unused)\n{\n\treturn bus_for_each_dev(&pci_bus_type, NULL, m,\n\t\t\t\tshow_device_domain_translation);\n}\nDEFINE_SHOW_ATTRIBUTE(domain_translation_struct);\n\nstatic void invalidation_queue_entry_show(struct seq_file *m,\n\t\t\t\t\t  struct intel_iommu *iommu)\n{\n\tint index, shift = qi_shift(iommu);\n\tstruct qi_desc *desc;\n\tint offset;\n\n\tif (ecap_smts(iommu->ecap))\n\t\tseq_puts(m, \"Index\\t\\tqw0\\t\\t\\tqw1\\t\\t\\tqw2\\t\\t\\tqw3\\t\\t\\tstatus\\n\");\n\telse\n\t\tseq_puts(m, \"Index\\t\\tqw0\\t\\t\\tqw1\\t\\t\\tstatus\\n\");\n\n\tfor (index = 0; index < QI_LENGTH; index++) {\n\t\toffset = index << shift;\n\t\tdesc = iommu->qi->desc + offset;\n\t\tif (ecap_smts(iommu->ecap))\n\t\t\tseq_printf(m, \"%5d\\t%016llx\\t%016llx\\t%016llx\\t%016llx\\t%016x\\n\",\n\t\t\t\t   index, desc->qw0, desc->qw1,\n\t\t\t\t   desc->qw2, desc->qw3,\n\t\t\t\t   iommu->qi->desc_status[index]);\n\t\telse\n\t\t\tseq_printf(m, \"%5d\\t%016llx\\t%016llx\\t%016x\\n\",\n\t\t\t\t   index, desc->qw0, desc->qw1,\n\t\t\t\t   iommu->qi->desc_status[index]);\n\t}\n}\n\nstatic int invalidation_queue_show(struct seq_file *m, void *unused)\n{\n\tstruct dmar_drhd_unit *drhd;\n\tstruct intel_iommu *iommu;\n\tunsigned long flags;\n\tstruct q_inval *qi;\n\tint shift;\n\n\trcu_read_lock();\n\tfor_each_active_iommu(iommu, drhd) {\n\t\tqi = iommu->qi;\n\t\tshift = qi_shift(iommu);\n\n\t\tif (!qi || !ecap_qis(iommu->ecap))\n\t\t\tcontinue;\n\n\t\tseq_printf(m, \"Invalidation queue on IOMMU: %s\\n\", iommu->name);\n\n\t\traw_spin_lock_irqsave(&qi->q_lock, flags);\n\t\tseq_printf(m, \" Base: 0x%llx\\tHead: %lld\\tTail: %lld\\n\",\n\t\t\t   (u64)virt_to_phys(qi->desc),\n\t\t\t   dmar_readq(iommu->reg + DMAR_IQH_REG) >> shift,\n\t\t\t   dmar_readq(iommu->reg + DMAR_IQT_REG) >> shift);\n\t\tinvalidation_queue_entry_show(m, iommu);\n\t\traw_spin_unlock_irqrestore(&qi->q_lock, flags);\n\t\tseq_putc(m, '\\n');\n\t}\n\trcu_read_unlock();\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(invalidation_queue);\n\n#ifdef CONFIG_IRQ_REMAP\nstatic void ir_tbl_remap_entry_show(struct seq_file *m,\n\t\t\t\t    struct intel_iommu *iommu)\n{\n\tstruct irte *ri_entry;\n\tunsigned long flags;\n\tint idx;\n\n\tseq_puts(m, \" Entry SrcID   DstID    Vct IRTE_high\\t\\tIRTE_low\\n\");\n\n\traw_spin_lock_irqsave(&irq_2_ir_lock, flags);\n\tfor (idx = 0; idx < INTR_REMAP_TABLE_ENTRIES; idx++) {\n\t\tri_entry = &iommu->ir_table->base[idx];\n\t\tif (!ri_entry->present || ri_entry->p_pst)\n\t\t\tcontinue;\n\n\t\tseq_printf(m, \" %-5d %02x:%02x.%01x %08x %02x  %016llx\\t%016llx\\n\",\n\t\t\t   idx, PCI_BUS_NUM(ri_entry->sid),\n\t\t\t   PCI_SLOT(ri_entry->sid), PCI_FUNC(ri_entry->sid),\n\t\t\t   ri_entry->dest_id, ri_entry->vector,\n\t\t\t   ri_entry->high, ri_entry->low);\n\t}\n\traw_spin_unlock_irqrestore(&irq_2_ir_lock, flags);\n}\n\nstatic void ir_tbl_posted_entry_show(struct seq_file *m,\n\t\t\t\t     struct intel_iommu *iommu)\n{\n\tstruct irte *pi_entry;\n\tunsigned long flags;\n\tint idx;\n\n\tseq_puts(m, \" Entry SrcID   PDA_high PDA_low  Vct IRTE_high\\t\\tIRTE_low\\n\");\n\n\traw_spin_lock_irqsave(&irq_2_ir_lock, flags);\n\tfor (idx = 0; idx < INTR_REMAP_TABLE_ENTRIES; idx++) {\n\t\tpi_entry = &iommu->ir_table->base[idx];\n\t\tif (!pi_entry->present || !pi_entry->p_pst)\n\t\t\tcontinue;\n\n\t\tseq_printf(m, \" %-5d %02x:%02x.%01x %08x %08x %02x  %016llx\\t%016llx\\n\",\n\t\t\t   idx, PCI_BUS_NUM(pi_entry->sid),\n\t\t\t   PCI_SLOT(pi_entry->sid), PCI_FUNC(pi_entry->sid),\n\t\t\t   pi_entry->pda_h, pi_entry->pda_l << 6,\n\t\t\t   pi_entry->vector, pi_entry->high,\n\t\t\t   pi_entry->low);\n\t}\n\traw_spin_unlock_irqrestore(&irq_2_ir_lock, flags);\n}\n\n \nstatic int ir_translation_struct_show(struct seq_file *m, void *unused)\n{\n\tstruct dmar_drhd_unit *drhd;\n\tstruct intel_iommu *iommu;\n\tu64 irta;\n\tu32 sts;\n\n\trcu_read_lock();\n\tfor_each_active_iommu(iommu, drhd) {\n\t\tif (!ecap_ir_support(iommu->ecap))\n\t\t\tcontinue;\n\n\t\tseq_printf(m, \"Remapped Interrupt supported on IOMMU: %s\\n\",\n\t\t\t   iommu->name);\n\n\t\tsts = dmar_readl(iommu->reg + DMAR_GSTS_REG);\n\t\tif (iommu->ir_table && (sts & DMA_GSTS_IRES)) {\n\t\t\tirta = virt_to_phys(iommu->ir_table->base);\n\t\t\tseq_printf(m, \" IR table address:%llx\\n\", irta);\n\t\t\tir_tbl_remap_entry_show(m, iommu);\n\t\t} else {\n\t\t\tseq_puts(m, \"Interrupt Remapping is not enabled\\n\");\n\t\t}\n\t\tseq_putc(m, '\\n');\n\t}\n\n\tseq_puts(m, \"****\\n\\n\");\n\n\tfor_each_active_iommu(iommu, drhd) {\n\t\tif (!cap_pi_support(iommu->cap))\n\t\t\tcontinue;\n\n\t\tseq_printf(m, \"Posted Interrupt supported on IOMMU: %s\\n\",\n\t\t\t   iommu->name);\n\n\t\tif (iommu->ir_table) {\n\t\t\tirta = virt_to_phys(iommu->ir_table->base);\n\t\t\tseq_printf(m, \" IR table address:%llx\\n\", irta);\n\t\t\tir_tbl_posted_entry_show(m, iommu);\n\t\t} else {\n\t\t\tseq_puts(m, \"Interrupt Remapping is not enabled\\n\");\n\t\t}\n\t\tseq_putc(m, '\\n');\n\t}\n\trcu_read_unlock();\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(ir_translation_struct);\n#endif\n\nstatic void latency_show_one(struct seq_file *m, struct intel_iommu *iommu,\n\t\t\t     struct dmar_drhd_unit *drhd)\n{\n\tint ret;\n\n\tseq_printf(m, \"IOMMU: %s Register Base Address: %llx\\n\",\n\t\t   iommu->name, drhd->reg_base_addr);\n\n\tret = dmar_latency_snapshot(iommu, debug_buf, DEBUG_BUFFER_SIZE);\n\tif (ret < 0)\n\t\tseq_puts(m, \"Failed to get latency snapshot\");\n\telse\n\t\tseq_puts(m, debug_buf);\n\tseq_puts(m, \"\\n\");\n}\n\nstatic int latency_show(struct seq_file *m, void *v)\n{\n\tstruct dmar_drhd_unit *drhd;\n\tstruct intel_iommu *iommu;\n\n\trcu_read_lock();\n\tfor_each_active_iommu(iommu, drhd)\n\t\tlatency_show_one(m, iommu, drhd);\n\trcu_read_unlock();\n\n\treturn 0;\n}\n\nstatic int dmar_perf_latency_open(struct inode *inode, struct file *filp)\n{\n\treturn single_open(filp, latency_show, NULL);\n}\n\nstatic ssize_t dmar_perf_latency_write(struct file *filp,\n\t\t\t\t       const char __user *ubuf,\n\t\t\t\t       size_t cnt, loff_t *ppos)\n{\n\tstruct dmar_drhd_unit *drhd;\n\tstruct intel_iommu *iommu;\n\tint counting;\n\tchar buf[64];\n\n\tif (cnt > 63)\n\t\tcnt = 63;\n\n\tif (copy_from_user(&buf, ubuf, cnt))\n\t\treturn -EFAULT;\n\n\tbuf[cnt] = 0;\n\n\tif (kstrtoint(buf, 0, &counting))\n\t\treturn -EINVAL;\n\n\tswitch (counting) {\n\tcase 0:\n\t\trcu_read_lock();\n\t\tfor_each_active_iommu(iommu, drhd) {\n\t\t\tdmar_latency_disable(iommu, DMAR_LATENCY_INV_IOTLB);\n\t\t\tdmar_latency_disable(iommu, DMAR_LATENCY_INV_DEVTLB);\n\t\t\tdmar_latency_disable(iommu, DMAR_LATENCY_INV_IEC);\n\t\t\tdmar_latency_disable(iommu, DMAR_LATENCY_PRQ);\n\t\t}\n\t\trcu_read_unlock();\n\t\tbreak;\n\tcase 1:\n\t\trcu_read_lock();\n\t\tfor_each_active_iommu(iommu, drhd)\n\t\t\tdmar_latency_enable(iommu, DMAR_LATENCY_INV_IOTLB);\n\t\trcu_read_unlock();\n\t\tbreak;\n\tcase 2:\n\t\trcu_read_lock();\n\t\tfor_each_active_iommu(iommu, drhd)\n\t\t\tdmar_latency_enable(iommu, DMAR_LATENCY_INV_DEVTLB);\n\t\trcu_read_unlock();\n\t\tbreak;\n\tcase 3:\n\t\trcu_read_lock();\n\t\tfor_each_active_iommu(iommu, drhd)\n\t\t\tdmar_latency_enable(iommu, DMAR_LATENCY_INV_IEC);\n\t\trcu_read_unlock();\n\t\tbreak;\n\tcase 4:\n\t\trcu_read_lock();\n\t\tfor_each_active_iommu(iommu, drhd)\n\t\t\tdmar_latency_enable(iommu, DMAR_LATENCY_PRQ);\n\t\trcu_read_unlock();\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t*ppos += cnt;\n\treturn cnt;\n}\n\nstatic const struct file_operations dmar_perf_latency_fops = {\n\t.open\t\t= dmar_perf_latency_open,\n\t.write\t\t= dmar_perf_latency_write,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\nvoid __init intel_iommu_debugfs_init(void)\n{\n\tstruct dentry *intel_iommu_debug = debugfs_create_dir(\"intel\",\n\t\t\t\t\t\tiommu_debugfs_dir);\n\n\tdebugfs_create_file(\"iommu_regset\", 0444, intel_iommu_debug, NULL,\n\t\t\t    &iommu_regset_fops);\n\tdebugfs_create_file(\"dmar_translation_struct\", 0444, intel_iommu_debug,\n\t\t\t    NULL, &dmar_translation_struct_fops);\n\tdebugfs_create_file(\"domain_translation_struct\", 0444,\n\t\t\t    intel_iommu_debug, NULL,\n\t\t\t    &domain_translation_struct_fops);\n\tdebugfs_create_file(\"invalidation_queue\", 0444, intel_iommu_debug,\n\t\t\t    NULL, &invalidation_queue_fops);\n#ifdef CONFIG_IRQ_REMAP\n\tdebugfs_create_file(\"ir_translation_struct\", 0444, intel_iommu_debug,\n\t\t\t    NULL, &ir_translation_struct_fops);\n#endif\n\tdebugfs_create_file(\"dmar_perf_latency\", 0644, intel_iommu_debug,\n\t\t\t    NULL, &dmar_perf_latency_fops);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}