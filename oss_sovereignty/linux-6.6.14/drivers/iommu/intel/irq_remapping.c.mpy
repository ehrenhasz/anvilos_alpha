{
  "module_name": "irq_remapping.c",
  "hash_id": "97a7d84334a666a1031f4932216d931f705bdbca2dc68a9165af5986f76fe9b2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iommu/intel/irq_remapping.c",
  "human_readable_source": "\n\n#define pr_fmt(fmt)     \"DMAR-IR: \" fmt\n\n#include <linux/interrupt.h>\n#include <linux/dmar.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/hpet.h>\n#include <linux/pci.h>\n#include <linux/irq.h>\n#include <linux/acpi.h>\n#include <linux/irqdomain.h>\n#include <linux/crash_dump.h>\n#include <asm/io_apic.h>\n#include <asm/apic.h>\n#include <asm/smp.h>\n#include <asm/cpu.h>\n#include <asm/irq_remapping.h>\n#include <asm/pci-direct.h>\n\n#include \"iommu.h\"\n#include \"../irq_remapping.h\"\n#include \"cap_audit.h\"\n\nenum irq_mode {\n\tIRQ_REMAPPING,\n\tIRQ_POSTING,\n};\n\nstruct ioapic_scope {\n\tstruct intel_iommu *iommu;\n\tunsigned int id;\n\tunsigned int bus;\t \n\tunsigned int devfn;\t \n};\n\nstruct hpet_scope {\n\tstruct intel_iommu *iommu;\n\tu8 id;\n\tunsigned int bus;\n\tunsigned int devfn;\n};\n\nstruct irq_2_iommu {\n\tstruct intel_iommu *iommu;\n\tu16 irte_index;\n\tu16 sub_handle;\n\tu8  irte_mask;\n\tenum irq_mode mode;\n};\n\nstruct intel_ir_data {\n\tstruct irq_2_iommu\t\t\tirq_2_iommu;\n\tstruct irte\t\t\t\tirte_entry;\n\tunion {\n\t\tstruct msi_msg\t\t\tmsi_entry;\n\t};\n};\n\n#define IR_X2APIC_MODE(mode) (mode ? (1 << 11) : 0)\n#define IRTE_DEST(dest) ((eim_mode) ? dest : dest << 8)\n\nstatic int __read_mostly eim_mode;\nstatic struct ioapic_scope ir_ioapic[MAX_IO_APICS];\nstatic struct hpet_scope ir_hpet[MAX_HPET_TBS];\n\n \nDEFINE_RAW_SPINLOCK(irq_2_ir_lock);\nstatic const struct irq_domain_ops intel_ir_domain_ops;\n\nstatic void iommu_disable_irq_remapping(struct intel_iommu *iommu);\nstatic int __init parse_ioapics_under_ir(void);\nstatic const struct msi_parent_ops dmar_msi_parent_ops, virt_dmar_msi_parent_ops;\n\nstatic bool ir_pre_enabled(struct intel_iommu *iommu)\n{\n\treturn (iommu->flags & VTD_FLAG_IRQ_REMAP_PRE_ENABLED);\n}\n\nstatic void clear_ir_pre_enabled(struct intel_iommu *iommu)\n{\n\tiommu->flags &= ~VTD_FLAG_IRQ_REMAP_PRE_ENABLED;\n}\n\nstatic void init_ir_status(struct intel_iommu *iommu)\n{\n\tu32 gsts;\n\n\tgsts = readl(iommu->reg + DMAR_GSTS_REG);\n\tif (gsts & DMA_GSTS_IRES)\n\t\tiommu->flags |= VTD_FLAG_IRQ_REMAP_PRE_ENABLED;\n}\n\nstatic int alloc_irte(struct intel_iommu *iommu,\n\t\t      struct irq_2_iommu *irq_iommu, u16 count)\n{\n\tstruct ir_table *table = iommu->ir_table;\n\tunsigned int mask = 0;\n\tunsigned long flags;\n\tint index;\n\n\tif (!count || !irq_iommu)\n\t\treturn -1;\n\n\tif (count > 1) {\n\t\tcount = __roundup_pow_of_two(count);\n\t\tmask = ilog2(count);\n\t}\n\n\tif (mask > ecap_max_handle_mask(iommu->ecap)) {\n\t\tpr_err(\"Requested mask %x exceeds the max invalidation handle\"\n\t\t       \" mask value %Lx\\n\", mask,\n\t\t       ecap_max_handle_mask(iommu->ecap));\n\t\treturn -1;\n\t}\n\n\traw_spin_lock_irqsave(&irq_2_ir_lock, flags);\n\tindex = bitmap_find_free_region(table->bitmap,\n\t\t\t\t\tINTR_REMAP_TABLE_ENTRIES, mask);\n\tif (index < 0) {\n\t\tpr_warn(\"IR%d: can't allocate an IRTE\\n\", iommu->seq_id);\n\t} else {\n\t\tirq_iommu->iommu = iommu;\n\t\tirq_iommu->irte_index =  index;\n\t\tirq_iommu->sub_handle = 0;\n\t\tirq_iommu->irte_mask = mask;\n\t\tirq_iommu->mode = IRQ_REMAPPING;\n\t}\n\traw_spin_unlock_irqrestore(&irq_2_ir_lock, flags);\n\n\treturn index;\n}\n\nstatic int qi_flush_iec(struct intel_iommu *iommu, int index, int mask)\n{\n\tstruct qi_desc desc;\n\n\tdesc.qw0 = QI_IEC_IIDEX(index) | QI_IEC_TYPE | QI_IEC_IM(mask)\n\t\t   | QI_IEC_SELECTIVE;\n\tdesc.qw1 = 0;\n\tdesc.qw2 = 0;\n\tdesc.qw3 = 0;\n\n\treturn qi_submit_sync(iommu, &desc, 1, 0);\n}\n\nstatic int modify_irte(struct irq_2_iommu *irq_iommu,\n\t\t       struct irte *irte_modified)\n{\n\tstruct intel_iommu *iommu;\n\tunsigned long flags;\n\tstruct irte *irte;\n\tint rc, index;\n\n\tif (!irq_iommu)\n\t\treturn -1;\n\n\traw_spin_lock_irqsave(&irq_2_ir_lock, flags);\n\n\tiommu = irq_iommu->iommu;\n\n\tindex = irq_iommu->irte_index + irq_iommu->sub_handle;\n\tirte = &iommu->ir_table->base[index];\n\n\tif ((irte->pst == 1) || (irte_modified->pst == 1)) {\n\t\t \n\t\tu128 old = irte->irte;\n\t\tWARN_ON(!try_cmpxchg128(&irte->irte, &old, irte_modified->irte));\n\t} else {\n\t\tWRITE_ONCE(irte->low, irte_modified->low);\n\t\tWRITE_ONCE(irte->high, irte_modified->high);\n\t}\n\t__iommu_flush_cache(iommu, irte, sizeof(*irte));\n\n\trc = qi_flush_iec(iommu, index, 0);\n\n\t \n\tirq_iommu->mode = irte->pst ? IRQ_POSTING : IRQ_REMAPPING;\n\traw_spin_unlock_irqrestore(&irq_2_ir_lock, flags);\n\n\treturn rc;\n}\n\nstatic struct intel_iommu *map_hpet_to_iommu(u8 hpet_id)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_HPET_TBS; i++) {\n\t\tif (ir_hpet[i].id == hpet_id && ir_hpet[i].iommu)\n\t\t\treturn ir_hpet[i].iommu;\n\t}\n\treturn NULL;\n}\n\nstatic struct intel_iommu *map_ioapic_to_iommu(int apic)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_IO_APICS; i++) {\n\t\tif (ir_ioapic[i].id == apic && ir_ioapic[i].iommu)\n\t\t\treturn ir_ioapic[i].iommu;\n\t}\n\treturn NULL;\n}\n\nstatic struct irq_domain *map_dev_to_ir(struct pci_dev *dev)\n{\n\tstruct dmar_drhd_unit *drhd = dmar_find_matched_drhd_unit(dev);\n\n\treturn drhd ? drhd->iommu->ir_domain : NULL;\n}\n\nstatic int clear_entries(struct irq_2_iommu *irq_iommu)\n{\n\tstruct irte *start, *entry, *end;\n\tstruct intel_iommu *iommu;\n\tint index;\n\n\tif (irq_iommu->sub_handle)\n\t\treturn 0;\n\n\tiommu = irq_iommu->iommu;\n\tindex = irq_iommu->irte_index;\n\n\tstart = iommu->ir_table->base + index;\n\tend = start + (1 << irq_iommu->irte_mask);\n\n\tfor (entry = start; entry < end; entry++) {\n\t\tWRITE_ONCE(entry->low, 0);\n\t\tWRITE_ONCE(entry->high, 0);\n\t}\n\tbitmap_release_region(iommu->ir_table->bitmap, index,\n\t\t\t      irq_iommu->irte_mask);\n\n\treturn qi_flush_iec(iommu, index, irq_iommu->irte_mask);\n}\n\n \n#define SVT_NO_VERIFY\t\t0x0   \n#define SVT_VERIFY_SID_SQ\t0x1   \n#define SVT_VERIFY_BUS\t\t0x2   \n\n \n#define SQ_ALL_16\t0x0   \n#define SQ_13_IGNORE_1\t0x1   \n#define SQ_13_IGNORE_2\t0x2   \n#define SQ_13_IGNORE_3\t0x3   \n\n \nstatic void set_irte_sid(struct irte *irte, unsigned int svt,\n\t\t\t unsigned int sq, unsigned int sid)\n{\n\tif (disable_sourceid_checking)\n\t\tsvt = SVT_NO_VERIFY;\n\tirte->svt = svt;\n\tirte->sq = sq;\n\tirte->sid = sid;\n}\n\n \nstatic void set_irte_verify_bus(struct irte *irte, unsigned int start_bus,\n\t\t\t\tunsigned int end_bus)\n{\n\tset_irte_sid(irte, SVT_VERIFY_BUS, SQ_ALL_16,\n\t\t     (start_bus << 8) | end_bus);\n}\n\nstatic int set_ioapic_sid(struct irte *irte, int apic)\n{\n\tint i;\n\tu16 sid = 0;\n\n\tif (!irte)\n\t\treturn -1;\n\n\tfor (i = 0; i < MAX_IO_APICS; i++) {\n\t\tif (ir_ioapic[i].iommu && ir_ioapic[i].id == apic) {\n\t\t\tsid = (ir_ioapic[i].bus << 8) | ir_ioapic[i].devfn;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (sid == 0) {\n\t\tpr_warn(\"Failed to set source-id of IOAPIC (%d)\\n\", apic);\n\t\treturn -1;\n\t}\n\n\tset_irte_sid(irte, SVT_VERIFY_SID_SQ, SQ_ALL_16, sid);\n\n\treturn 0;\n}\n\nstatic int set_hpet_sid(struct irte *irte, u8 id)\n{\n\tint i;\n\tu16 sid = 0;\n\n\tif (!irte)\n\t\treturn -1;\n\n\tfor (i = 0; i < MAX_HPET_TBS; i++) {\n\t\tif (ir_hpet[i].iommu && ir_hpet[i].id == id) {\n\t\t\tsid = (ir_hpet[i].bus << 8) | ir_hpet[i].devfn;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (sid == 0) {\n\t\tpr_warn(\"Failed to set source-id of HPET block (%d)\\n\", id);\n\t\treturn -1;\n\t}\n\n\t \n\tset_irte_sid(irte, SVT_VERIFY_SID_SQ, SQ_13_IGNORE_3, sid);\n\n\treturn 0;\n}\n\nstruct set_msi_sid_data {\n\tstruct pci_dev *pdev;\n\tu16 alias;\n\tint count;\n\tint busmatch_count;\n};\n\nstatic int set_msi_sid_cb(struct pci_dev *pdev, u16 alias, void *opaque)\n{\n\tstruct set_msi_sid_data *data = opaque;\n\n\tif (data->count == 0 || PCI_BUS_NUM(alias) == PCI_BUS_NUM(data->alias))\n\t\tdata->busmatch_count++;\n\n\tdata->pdev = pdev;\n\tdata->alias = alias;\n\tdata->count++;\n\n\treturn 0;\n}\n\nstatic int set_msi_sid(struct irte *irte, struct pci_dev *dev)\n{\n\tstruct set_msi_sid_data data;\n\n\tif (!irte || !dev)\n\t\treturn -1;\n\n\tdata.count = 0;\n\tdata.busmatch_count = 0;\n\tpci_for_each_dma_alias(dev, set_msi_sid_cb, &data);\n\n\t \n\tif (PCI_BUS_NUM(data.alias) != data.pdev->bus->number)\n\t\tset_irte_verify_bus(irte, PCI_BUS_NUM(data.alias),\n\t\t\t\t    dev->bus->number);\n\telse if (data.count >= 2 && data.busmatch_count == data.count)\n\t\tset_irte_verify_bus(irte, dev->bus->number, dev->bus->number);\n\telse if (data.pdev->bus->number != dev->bus->number)\n\t\tset_irte_sid(irte, SVT_VERIFY_SID_SQ, SQ_ALL_16, data.alias);\n\telse\n\t\tset_irte_sid(irte, SVT_VERIFY_SID_SQ, SQ_ALL_16,\n\t\t\t     pci_dev_id(dev));\n\n\treturn 0;\n}\n\nstatic int iommu_load_old_irte(struct intel_iommu *iommu)\n{\n\tstruct irte *old_ir_table;\n\tphys_addr_t irt_phys;\n\tunsigned int i;\n\tsize_t size;\n\tu64 irta;\n\n\t \n\tirta = dmar_readq(iommu->reg + DMAR_IRTA_REG);\n\tif ((irta & INTR_REMAP_TABLE_REG_SIZE_MASK)\n\t     != INTR_REMAP_TABLE_REG_SIZE)\n\t\treturn -EINVAL;\n\n\tirt_phys = irta & VTD_PAGE_MASK;\n\tsize     = INTR_REMAP_TABLE_ENTRIES*sizeof(struct irte);\n\n\t \n\told_ir_table = memremap(irt_phys, size, MEMREMAP_WB);\n\tif (!old_ir_table)\n\t\treturn -ENOMEM;\n\n\t \n\tmemcpy(iommu->ir_table->base, old_ir_table, size);\n\n\t__iommu_flush_cache(iommu, iommu->ir_table->base, size);\n\n\t \n\tfor (i = 0; i < INTR_REMAP_TABLE_ENTRIES; i++) {\n\t\tif (iommu->ir_table->base[i].present)\n\t\t\tbitmap_set(iommu->ir_table->bitmap, i, 1);\n\t}\n\n\tmemunmap(old_ir_table);\n\n\treturn 0;\n}\n\n\nstatic void iommu_set_irq_remapping(struct intel_iommu *iommu, int mode)\n{\n\tunsigned long flags;\n\tu64 addr;\n\tu32 sts;\n\n\taddr = virt_to_phys((void *)iommu->ir_table->base);\n\n\traw_spin_lock_irqsave(&iommu->register_lock, flags);\n\n\tdmar_writeq(iommu->reg + DMAR_IRTA_REG,\n\t\t    (addr) | IR_X2APIC_MODE(mode) | INTR_REMAP_TABLE_REG_SIZE);\n\n\t \n\twritel(iommu->gcmd | DMA_GCMD_SIRTP, iommu->reg + DMAR_GCMD_REG);\n\n\tIOMMU_WAIT_OP(iommu, DMAR_GSTS_REG,\n\t\t      readl, (sts & DMA_GSTS_IRTPS), sts);\n\traw_spin_unlock_irqrestore(&iommu->register_lock, flags);\n\n\t \n\tif (!cap_esirtps(iommu->cap))\n\t\tqi_global_iec(iommu);\n}\n\nstatic void iommu_enable_irq_remapping(struct intel_iommu *iommu)\n{\n\tunsigned long flags;\n\tu32 sts;\n\n\traw_spin_lock_irqsave(&iommu->register_lock, flags);\n\n\t \n\tiommu->gcmd |= DMA_GCMD_IRE;\n\twritel(iommu->gcmd, iommu->reg + DMAR_GCMD_REG);\n\tIOMMU_WAIT_OP(iommu, DMAR_GSTS_REG,\n\t\t      readl, (sts & DMA_GSTS_IRES), sts);\n\n\t \n\tif (sts & DMA_GSTS_CFIS) {\n\t\tiommu->gcmd &= ~DMA_GCMD_CFI;\n\t\twritel(iommu->gcmd, iommu->reg + DMAR_GCMD_REG);\n\t\tIOMMU_WAIT_OP(iommu, DMAR_GSTS_REG,\n\t\t\t      readl, !(sts & DMA_GSTS_CFIS), sts);\n\t}\n\n\t \n\tif (sts & DMA_GSTS_CFIS)\n\t\tWARN(1, KERN_WARNING\n\t\t\t\"Compatibility-format IRQs enabled despite intr remapping;\\n\"\n\t\t\t\"you are vulnerable to IRQ injection.\\n\");\n\n\traw_spin_unlock_irqrestore(&iommu->register_lock, flags);\n}\n\nstatic int intel_setup_irq_remapping(struct intel_iommu *iommu)\n{\n\tstruct ir_table *ir_table;\n\tstruct fwnode_handle *fn;\n\tunsigned long *bitmap;\n\tstruct page *pages;\n\n\tif (iommu->ir_table)\n\t\treturn 0;\n\n\tir_table = kzalloc(sizeof(struct ir_table), GFP_KERNEL);\n\tif (!ir_table)\n\t\treturn -ENOMEM;\n\n\tpages = alloc_pages_node(iommu->node, GFP_KERNEL | __GFP_ZERO,\n\t\t\t\t INTR_REMAP_PAGE_ORDER);\n\tif (!pages) {\n\t\tpr_err(\"IR%d: failed to allocate pages of order %d\\n\",\n\t\t       iommu->seq_id, INTR_REMAP_PAGE_ORDER);\n\t\tgoto out_free_table;\n\t}\n\n\tbitmap = bitmap_zalloc(INTR_REMAP_TABLE_ENTRIES, GFP_KERNEL);\n\tif (bitmap == NULL) {\n\t\tpr_err(\"IR%d: failed to allocate bitmap\\n\", iommu->seq_id);\n\t\tgoto out_free_pages;\n\t}\n\n\tfn = irq_domain_alloc_named_id_fwnode(\"INTEL-IR\", iommu->seq_id);\n\tif (!fn)\n\t\tgoto out_free_bitmap;\n\n\tiommu->ir_domain =\n\t\tirq_domain_create_hierarchy(arch_get_ir_parent_domain(),\n\t\t\t\t\t    0, INTR_REMAP_TABLE_ENTRIES,\n\t\t\t\t\t    fn, &intel_ir_domain_ops,\n\t\t\t\t\t    iommu);\n\tif (!iommu->ir_domain) {\n\t\tpr_err(\"IR%d: failed to allocate irqdomain\\n\", iommu->seq_id);\n\t\tgoto out_free_fwnode;\n\t}\n\n\tirq_domain_update_bus_token(iommu->ir_domain,  DOMAIN_BUS_DMAR);\n\tiommu->ir_domain->flags |= IRQ_DOMAIN_FLAG_MSI_PARENT |\n\t\t\t\t   IRQ_DOMAIN_FLAG_ISOLATED_MSI;\n\n\tif (cap_caching_mode(iommu->cap))\n\t\tiommu->ir_domain->msi_parent_ops = &virt_dmar_msi_parent_ops;\n\telse\n\t\tiommu->ir_domain->msi_parent_ops = &dmar_msi_parent_ops;\n\n\tir_table->base = page_address(pages);\n\tir_table->bitmap = bitmap;\n\tiommu->ir_table = ir_table;\n\n\t \n\tif (!iommu->qi) {\n\t\t \n\t\tdmar_fault(-1, iommu);\n\t\tdmar_disable_qi(iommu);\n\n\t\tif (dmar_enable_qi(iommu)) {\n\t\t\tpr_err(\"Failed to enable queued invalidation\\n\");\n\t\t\tgoto out_free_ir_domain;\n\t\t}\n\t}\n\n\tinit_ir_status(iommu);\n\n\tif (ir_pre_enabled(iommu)) {\n\t\tif (!is_kdump_kernel()) {\n\t\t\tpr_warn(\"IRQ remapping was enabled on %s but we are not in kdump mode\\n\",\n\t\t\t\tiommu->name);\n\t\t\tclear_ir_pre_enabled(iommu);\n\t\t\tiommu_disable_irq_remapping(iommu);\n\t\t} else if (iommu_load_old_irte(iommu))\n\t\t\tpr_err(\"Failed to copy IR table for %s from previous kernel\\n\",\n\t\t\t       iommu->name);\n\t\telse\n\t\t\tpr_info(\"Copied IR table for %s from previous kernel\\n\",\n\t\t\t\tiommu->name);\n\t}\n\n\tiommu_set_irq_remapping(iommu, eim_mode);\n\n\treturn 0;\n\nout_free_ir_domain:\n\tirq_domain_remove(iommu->ir_domain);\n\tiommu->ir_domain = NULL;\nout_free_fwnode:\n\tirq_domain_free_fwnode(fn);\nout_free_bitmap:\n\tbitmap_free(bitmap);\nout_free_pages:\n\t__free_pages(pages, INTR_REMAP_PAGE_ORDER);\nout_free_table:\n\tkfree(ir_table);\n\n\tiommu->ir_table  = NULL;\n\n\treturn -ENOMEM;\n}\n\nstatic void intel_teardown_irq_remapping(struct intel_iommu *iommu)\n{\n\tstruct fwnode_handle *fn;\n\n\tif (iommu && iommu->ir_table) {\n\t\tif (iommu->ir_domain) {\n\t\t\tfn = iommu->ir_domain->fwnode;\n\n\t\t\tirq_domain_remove(iommu->ir_domain);\n\t\t\tirq_domain_free_fwnode(fn);\n\t\t\tiommu->ir_domain = NULL;\n\t\t}\n\t\tfree_pages((unsigned long)iommu->ir_table->base,\n\t\t\t   INTR_REMAP_PAGE_ORDER);\n\t\tbitmap_free(iommu->ir_table->bitmap);\n\t\tkfree(iommu->ir_table);\n\t\tiommu->ir_table = NULL;\n\t}\n}\n\n \nstatic void iommu_disable_irq_remapping(struct intel_iommu *iommu)\n{\n\tunsigned long flags;\n\tu32 sts;\n\n\tif (!ecap_ir_support(iommu->ecap))\n\t\treturn;\n\n\t \n\tif (!cap_esirtps(iommu->cap))\n\t\tqi_global_iec(iommu);\n\n\traw_spin_lock_irqsave(&iommu->register_lock, flags);\n\n\tsts = readl(iommu->reg + DMAR_GSTS_REG);\n\tif (!(sts & DMA_GSTS_IRES))\n\t\tgoto end;\n\n\tiommu->gcmd &= ~DMA_GCMD_IRE;\n\twritel(iommu->gcmd, iommu->reg + DMAR_GCMD_REG);\n\n\tIOMMU_WAIT_OP(iommu, DMAR_GSTS_REG,\n\t\t      readl, !(sts & DMA_GSTS_IRES), sts);\n\nend:\n\traw_spin_unlock_irqrestore(&iommu->register_lock, flags);\n}\n\nstatic int __init dmar_x2apic_optout(void)\n{\n\tstruct acpi_table_dmar *dmar;\n\tdmar = (struct acpi_table_dmar *)dmar_tbl;\n\tif (!dmar || no_x2apic_optout)\n\t\treturn 0;\n\treturn dmar->flags & DMAR_X2APIC_OPT_OUT;\n}\n\nstatic void __init intel_cleanup_irq_remapping(void)\n{\n\tstruct dmar_drhd_unit *drhd;\n\tstruct intel_iommu *iommu;\n\n\tfor_each_iommu(iommu, drhd) {\n\t\tif (ecap_ir_support(iommu->ecap)) {\n\t\t\tiommu_disable_irq_remapping(iommu);\n\t\t\tintel_teardown_irq_remapping(iommu);\n\t\t}\n\t}\n\n\tif (x2apic_supported())\n\t\tpr_warn(\"Failed to enable irq remapping. You are vulnerable to irq-injection attacks.\\n\");\n}\n\nstatic int __init intel_prepare_irq_remapping(void)\n{\n\tstruct dmar_drhd_unit *drhd;\n\tstruct intel_iommu *iommu;\n\tint eim = 0;\n\n\tif (irq_remap_broken) {\n\t\tpr_warn(\"This system BIOS has enabled interrupt remapping\\n\"\n\t\t\t\"on a chipset that contains an erratum making that\\n\"\n\t\t\t\"feature unstable.  To maintain system stability\\n\"\n\t\t\t\"interrupt remapping is being disabled.  Please\\n\"\n\t\t\t\"contact your BIOS vendor for an update\\n\");\n\t\tadd_taint(TAINT_FIRMWARE_WORKAROUND, LOCKDEP_STILL_OK);\n\t\treturn -ENODEV;\n\t}\n\n\tif (dmar_table_init() < 0)\n\t\treturn -ENODEV;\n\n\tif (intel_cap_audit(CAP_AUDIT_STATIC_IRQR, NULL))\n\t\treturn -ENODEV;\n\n\tif (!dmar_ir_support())\n\t\treturn -ENODEV;\n\n\tif (parse_ioapics_under_ir()) {\n\t\tpr_info(\"Not enabling interrupt remapping\\n\");\n\t\tgoto error;\n\t}\n\n\t \n\tfor_each_iommu(iommu, drhd)\n\t\tif (!ecap_ir_support(iommu->ecap))\n\t\t\tgoto error;\n\n\t \n\tif (x2apic_supported()) {\n\t\teim = !dmar_x2apic_optout();\n\t\tif (!eim) {\n\t\t\tpr_info(\"x2apic is disabled because BIOS sets x2apic opt out bit.\");\n\t\t\tpr_info(\"Use 'intremap=no_x2apic_optout' to override the BIOS setting.\\n\");\n\t\t}\n\t}\n\n\tfor_each_iommu(iommu, drhd) {\n\t\tif (eim && !ecap_eim_support(iommu->ecap)) {\n\t\t\tpr_info(\"%s does not support EIM\\n\", iommu->name);\n\t\t\teim = 0;\n\t\t}\n\t}\n\n\teim_mode = eim;\n\tif (eim)\n\t\tpr_info(\"Queued invalidation will be enabled to support x2apic and Intr-remapping.\\n\");\n\n\t \n\tfor_each_iommu(iommu, drhd) {\n\t\tif (intel_setup_irq_remapping(iommu)) {\n\t\t\tpr_err(\"Failed to setup irq remapping for %s\\n\",\n\t\t\t       iommu->name);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\treturn 0;\n\nerror:\n\tintel_cleanup_irq_remapping();\n\treturn -ENODEV;\n}\n\n \nstatic inline void set_irq_posting_cap(void)\n{\n\tstruct dmar_drhd_unit *drhd;\n\tstruct intel_iommu *iommu;\n\n\tif (!disable_irq_post) {\n\t\t \n\t\tif (boot_cpu_has(X86_FEATURE_CX16))\n\t\t\tintel_irq_remap_ops.capability |= 1 << IRQ_POSTING_CAP;\n\n\t\tfor_each_iommu(iommu, drhd)\n\t\t\tif (!cap_pi_support(iommu->cap)) {\n\t\t\t\tintel_irq_remap_ops.capability &=\n\t\t\t\t\t\t~(1 << IRQ_POSTING_CAP);\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n}\n\nstatic int __init intel_enable_irq_remapping(void)\n{\n\tstruct dmar_drhd_unit *drhd;\n\tstruct intel_iommu *iommu;\n\tbool setup = false;\n\n\t \n\tfor_each_iommu(iommu, drhd) {\n\t\tif (!ir_pre_enabled(iommu))\n\t\t\tiommu_enable_irq_remapping(iommu);\n\t\tsetup = true;\n\t}\n\n\tif (!setup)\n\t\tgoto error;\n\n\tirq_remapping_enabled = 1;\n\n\tset_irq_posting_cap();\n\n\tpr_info(\"Enabled IRQ remapping in %s mode\\n\", eim_mode ? \"x2apic\" : \"xapic\");\n\n\treturn eim_mode ? IRQ_REMAP_X2APIC_MODE : IRQ_REMAP_XAPIC_MODE;\n\nerror:\n\tintel_cleanup_irq_remapping();\n\treturn -1;\n}\n\nstatic int ir_parse_one_hpet_scope(struct acpi_dmar_device_scope *scope,\n\t\t\t\t   struct intel_iommu *iommu,\n\t\t\t\t   struct acpi_dmar_hardware_unit *drhd)\n{\n\tstruct acpi_dmar_pci_path *path;\n\tu8 bus;\n\tint count, free = -1;\n\n\tbus = scope->bus;\n\tpath = (struct acpi_dmar_pci_path *)(scope + 1);\n\tcount = (scope->length - sizeof(struct acpi_dmar_device_scope))\n\t\t/ sizeof(struct acpi_dmar_pci_path);\n\n\twhile (--count > 0) {\n\t\t \n\t\tbus = read_pci_config_byte(bus, path->device, path->function,\n\t\t\t\t\t   PCI_SECONDARY_BUS);\n\t\tpath++;\n\t}\n\n\tfor (count = 0; count < MAX_HPET_TBS; count++) {\n\t\tif (ir_hpet[count].iommu == iommu &&\n\t\t    ir_hpet[count].id == scope->enumeration_id)\n\t\t\treturn 0;\n\t\telse if (ir_hpet[count].iommu == NULL && free == -1)\n\t\t\tfree = count;\n\t}\n\tif (free == -1) {\n\t\tpr_warn(\"Exceeded Max HPET blocks\\n\");\n\t\treturn -ENOSPC;\n\t}\n\n\tir_hpet[free].iommu = iommu;\n\tir_hpet[free].id    = scope->enumeration_id;\n\tir_hpet[free].bus   = bus;\n\tir_hpet[free].devfn = PCI_DEVFN(path->device, path->function);\n\tpr_info(\"HPET id %d under DRHD base 0x%Lx\\n\",\n\t\tscope->enumeration_id, drhd->address);\n\n\treturn 0;\n}\n\nstatic int ir_parse_one_ioapic_scope(struct acpi_dmar_device_scope *scope,\n\t\t\t\t     struct intel_iommu *iommu,\n\t\t\t\t     struct acpi_dmar_hardware_unit *drhd)\n{\n\tstruct acpi_dmar_pci_path *path;\n\tu8 bus;\n\tint count, free = -1;\n\n\tbus = scope->bus;\n\tpath = (struct acpi_dmar_pci_path *)(scope + 1);\n\tcount = (scope->length - sizeof(struct acpi_dmar_device_scope))\n\t\t/ sizeof(struct acpi_dmar_pci_path);\n\n\twhile (--count > 0) {\n\t\t \n\t\tbus = read_pci_config_byte(bus, path->device, path->function,\n\t\t\t\t\t   PCI_SECONDARY_BUS);\n\t\tpath++;\n\t}\n\n\tfor (count = 0; count < MAX_IO_APICS; count++) {\n\t\tif (ir_ioapic[count].iommu == iommu &&\n\t\t    ir_ioapic[count].id == scope->enumeration_id)\n\t\t\treturn 0;\n\t\telse if (ir_ioapic[count].iommu == NULL && free == -1)\n\t\t\tfree = count;\n\t}\n\tif (free == -1) {\n\t\tpr_warn(\"Exceeded Max IO APICS\\n\");\n\t\treturn -ENOSPC;\n\t}\n\n\tir_ioapic[free].bus   = bus;\n\tir_ioapic[free].devfn = PCI_DEVFN(path->device, path->function);\n\tir_ioapic[free].iommu = iommu;\n\tir_ioapic[free].id    = scope->enumeration_id;\n\tpr_info(\"IOAPIC id %d under DRHD base  0x%Lx IOMMU %d\\n\",\n\t\tscope->enumeration_id, drhd->address, iommu->seq_id);\n\n\treturn 0;\n}\n\nstatic int ir_parse_ioapic_hpet_scope(struct acpi_dmar_header *header,\n\t\t\t\t      struct intel_iommu *iommu)\n{\n\tint ret = 0;\n\tstruct acpi_dmar_hardware_unit *drhd;\n\tstruct acpi_dmar_device_scope *scope;\n\tvoid *start, *end;\n\n\tdrhd = (struct acpi_dmar_hardware_unit *)header;\n\tstart = (void *)(drhd + 1);\n\tend = ((void *)drhd) + header->length;\n\n\twhile (start < end && ret == 0) {\n\t\tscope = start;\n\t\tif (scope->entry_type == ACPI_DMAR_SCOPE_TYPE_IOAPIC)\n\t\t\tret = ir_parse_one_ioapic_scope(scope, iommu, drhd);\n\t\telse if (scope->entry_type == ACPI_DMAR_SCOPE_TYPE_HPET)\n\t\t\tret = ir_parse_one_hpet_scope(scope, iommu, drhd);\n\t\tstart += scope->length;\n\t}\n\n\treturn ret;\n}\n\nstatic void ir_remove_ioapic_hpet_scope(struct intel_iommu *iommu)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_HPET_TBS; i++)\n\t\tif (ir_hpet[i].iommu == iommu)\n\t\t\tir_hpet[i].iommu = NULL;\n\n\tfor (i = 0; i < MAX_IO_APICS; i++)\n\t\tif (ir_ioapic[i].iommu == iommu)\n\t\t\tir_ioapic[i].iommu = NULL;\n}\n\n \nstatic int __init parse_ioapics_under_ir(void)\n{\n\tstruct dmar_drhd_unit *drhd;\n\tstruct intel_iommu *iommu;\n\tbool ir_supported = false;\n\tint ioapic_idx;\n\n\tfor_each_iommu(iommu, drhd) {\n\t\tint ret;\n\n\t\tif (!ecap_ir_support(iommu->ecap))\n\t\t\tcontinue;\n\n\t\tret = ir_parse_ioapic_hpet_scope(drhd->hdr, iommu);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tir_supported = true;\n\t}\n\n\tif (!ir_supported)\n\t\treturn -ENODEV;\n\n\tfor (ioapic_idx = 0; ioapic_idx < nr_ioapics; ioapic_idx++) {\n\t\tint ioapic_id = mpc_ioapic_id(ioapic_idx);\n\t\tif (!map_ioapic_to_iommu(ioapic_id)) {\n\t\t\tpr_err(FW_BUG \"ioapic %d has no mapping iommu, \"\n\t\t\t       \"interrupt remapping will be disabled\\n\",\n\t\t\t       ioapic_id);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int __init ir_dev_scope_init(void)\n{\n\tint ret;\n\n\tif (!irq_remapping_enabled)\n\t\treturn 0;\n\n\tdown_write(&dmar_global_lock);\n\tret = dmar_dev_scope_init();\n\tup_write(&dmar_global_lock);\n\n\treturn ret;\n}\nrootfs_initcall(ir_dev_scope_init);\n\nstatic void disable_irq_remapping(void)\n{\n\tstruct dmar_drhd_unit *drhd;\n\tstruct intel_iommu *iommu = NULL;\n\n\t \n\tfor_each_iommu(iommu, drhd) {\n\t\tif (!ecap_ir_support(iommu->ecap))\n\t\t\tcontinue;\n\n\t\tiommu_disable_irq_remapping(iommu);\n\t}\n\n\t \n\tif (!disable_irq_post)\n\t\tintel_irq_remap_ops.capability &= ~(1 << IRQ_POSTING_CAP);\n}\n\nstatic int reenable_irq_remapping(int eim)\n{\n\tstruct dmar_drhd_unit *drhd;\n\tbool setup = false;\n\tstruct intel_iommu *iommu = NULL;\n\n\tfor_each_iommu(iommu, drhd)\n\t\tif (iommu->qi)\n\t\t\tdmar_reenable_qi(iommu);\n\n\t \n\tfor_each_iommu(iommu, drhd) {\n\t\tif (!ecap_ir_support(iommu->ecap))\n\t\t\tcontinue;\n\n\t\t \n\t\tiommu_set_irq_remapping(iommu, eim);\n\t\tiommu_enable_irq_remapping(iommu);\n\t\tsetup = true;\n\t}\n\n\tif (!setup)\n\t\tgoto error;\n\n\tset_irq_posting_cap();\n\n\treturn 0;\n\nerror:\n\t \n\treturn -1;\n}\n\n \nvoid intel_irq_remap_add_device(struct dmar_pci_notify_info *info)\n{\n\tif (!irq_remapping_enabled || !pci_dev_has_default_msi_parent_domain(info->dev))\n\t\treturn;\n\n\tdev_set_msi_domain(&info->dev->dev, map_dev_to_ir(info->dev));\n}\n\nstatic void prepare_irte(struct irte *irte, int vector, unsigned int dest)\n{\n\tmemset(irte, 0, sizeof(*irte));\n\n\tirte->present = 1;\n\tirte->dst_mode = apic->dest_mode_logical;\n\t \n\tirte->trigger_mode = 0;\n\tirte->dlvry_mode = apic->delivery_mode;\n\tirte->vector = vector;\n\tirte->dest_id = IRTE_DEST(dest);\n\tirte->redir_hint = 1;\n}\n\nstruct irq_remap_ops intel_irq_remap_ops = {\n\t.prepare\t\t= intel_prepare_irq_remapping,\n\t.enable\t\t\t= intel_enable_irq_remapping,\n\t.disable\t\t= disable_irq_remapping,\n\t.reenable\t\t= reenable_irq_remapping,\n\t.enable_faulting\t= enable_drhd_fault_handling,\n};\n\nstatic void intel_ir_reconfigure_irte(struct irq_data *irqd, bool force)\n{\n\tstruct intel_ir_data *ir_data = irqd->chip_data;\n\tstruct irte *irte = &ir_data->irte_entry;\n\tstruct irq_cfg *cfg = irqd_cfg(irqd);\n\n\t \n\tirte->vector = cfg->vector;\n\tirte->dest_id = IRTE_DEST(cfg->dest_apicid);\n\n\t \n\tif (force || ir_data->irq_2_iommu.mode == IRQ_REMAPPING)\n\t\tmodify_irte(&ir_data->irq_2_iommu, irte);\n}\n\n \nstatic int\nintel_ir_set_affinity(struct irq_data *data, const struct cpumask *mask,\n\t\t      bool force)\n{\n\tstruct irq_data *parent = data->parent_data;\n\tstruct irq_cfg *cfg = irqd_cfg(data);\n\tint ret;\n\n\tret = parent->chip->irq_set_affinity(parent, mask, force);\n\tif (ret < 0 || ret == IRQ_SET_MASK_OK_DONE)\n\t\treturn ret;\n\n\tintel_ir_reconfigure_irte(data, false);\n\t \n\tvector_schedule_cleanup(cfg);\n\n\treturn IRQ_SET_MASK_OK_DONE;\n}\n\nstatic void intel_ir_compose_msi_msg(struct irq_data *irq_data,\n\t\t\t\t     struct msi_msg *msg)\n{\n\tstruct intel_ir_data *ir_data = irq_data->chip_data;\n\n\t*msg = ir_data->msi_entry;\n}\n\nstatic int intel_ir_set_vcpu_affinity(struct irq_data *data, void *info)\n{\n\tstruct intel_ir_data *ir_data = data->chip_data;\n\tstruct vcpu_data *vcpu_pi_info = info;\n\n\t \n\tif (!vcpu_pi_info) {\n\t\tmodify_irte(&ir_data->irq_2_iommu, &ir_data->irte_entry);\n\t} else {\n\t\tstruct irte irte_pi;\n\n\t\t \n\t\tmemset(&irte_pi, 0, sizeof(irte_pi));\n\t\tdmar_copy_shared_irte(&irte_pi, &ir_data->irte_entry);\n\n\t\t \n\t\tirte_pi.p_pst = 1;\n\t\tirte_pi.p_urgent = 0;\n\t\tirte_pi.p_vector = vcpu_pi_info->vector;\n\t\tirte_pi.pda_l = (vcpu_pi_info->pi_desc_addr >>\n\t\t\t\t(32 - PDA_LOW_BIT)) & ~(-1UL << PDA_LOW_BIT);\n\t\tirte_pi.pda_h = (vcpu_pi_info->pi_desc_addr >> 32) &\n\t\t\t\t~(-1UL << PDA_HIGH_BIT);\n\n\t\tmodify_irte(&ir_data->irq_2_iommu, &irte_pi);\n\t}\n\n\treturn 0;\n}\n\nstatic struct irq_chip intel_ir_chip = {\n\t.name\t\t\t= \"INTEL-IR\",\n\t.irq_ack\t\t= apic_ack_irq,\n\t.irq_set_affinity\t= intel_ir_set_affinity,\n\t.irq_compose_msi_msg\t= intel_ir_compose_msi_msg,\n\t.irq_set_vcpu_affinity\t= intel_ir_set_vcpu_affinity,\n};\n\nstatic void fill_msi_msg(struct msi_msg *msg, u32 index, u32 subhandle)\n{\n\tmemset(msg, 0, sizeof(*msg));\n\n\tmsg->arch_addr_lo.dmar_base_address = X86_MSI_BASE_ADDRESS_LOW;\n\tmsg->arch_addr_lo.dmar_subhandle_valid = true;\n\tmsg->arch_addr_lo.dmar_format = true;\n\tmsg->arch_addr_lo.dmar_index_0_14 = index & 0x7FFF;\n\tmsg->arch_addr_lo.dmar_index_15 = !!(index & 0x8000);\n\n\tmsg->address_hi = X86_MSI_BASE_ADDRESS_HIGH;\n\n\tmsg->arch_data.dmar_subhandle = subhandle;\n}\n\nstatic void intel_irq_remapping_prepare_irte(struct intel_ir_data *data,\n\t\t\t\t\t     struct irq_cfg *irq_cfg,\n\t\t\t\t\t     struct irq_alloc_info *info,\n\t\t\t\t\t     int index, int sub_handle)\n{\n\tstruct irte *irte = &data->irte_entry;\n\n\tprepare_irte(irte, irq_cfg->vector, irq_cfg->dest_apicid);\n\n\tswitch (info->type) {\n\tcase X86_IRQ_ALLOC_TYPE_IOAPIC:\n\t\t \n\t\tset_ioapic_sid(irte, info->devid);\n\t\tapic_printk(APIC_VERBOSE, KERN_DEBUG \"IOAPIC[%d]: Set IRTE entry (P:%d FPD:%d Dst_Mode:%d Redir_hint:%d Trig_Mode:%d Dlvry_Mode:%X Avail:%X Vector:%02X Dest:%08X SID:%04X SQ:%X SVT:%X)\\n\",\n\t\t\tinfo->devid, irte->present, irte->fpd,\n\t\t\tirte->dst_mode, irte->redir_hint,\n\t\t\tirte->trigger_mode, irte->dlvry_mode,\n\t\t\tirte->avail, irte->vector, irte->dest_id,\n\t\t\tirte->sid, irte->sq, irte->svt);\n\t\tsub_handle = info->ioapic.pin;\n\t\tbreak;\n\tcase X86_IRQ_ALLOC_TYPE_HPET:\n\t\tset_hpet_sid(irte, info->devid);\n\t\tbreak;\n\tcase X86_IRQ_ALLOC_TYPE_PCI_MSI:\n\tcase X86_IRQ_ALLOC_TYPE_PCI_MSIX:\n\t\tset_msi_sid(irte,\n\t\t\t    pci_real_dma_dev(msi_desc_to_pci_dev(info->desc)));\n\t\tbreak;\n\tdefault:\n\t\tBUG_ON(1);\n\t\tbreak;\n\t}\n\tfill_msi_msg(&data->msi_entry, index, sub_handle);\n}\n\nstatic void intel_free_irq_resources(struct irq_domain *domain,\n\t\t\t\t     unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *irq_data;\n\tstruct intel_ir_data *data;\n\tstruct irq_2_iommu *irq_iommu;\n\tunsigned long flags;\n\tint i;\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_data = irq_domain_get_irq_data(domain, virq  + i);\n\t\tif (irq_data && irq_data->chip_data) {\n\t\t\tdata = irq_data->chip_data;\n\t\t\tirq_iommu = &data->irq_2_iommu;\n\t\t\traw_spin_lock_irqsave(&irq_2_ir_lock, flags);\n\t\t\tclear_entries(irq_iommu);\n\t\t\traw_spin_unlock_irqrestore(&irq_2_ir_lock, flags);\n\t\t\tirq_domain_reset_irq_data(irq_data);\n\t\t\tkfree(data);\n\t\t}\n\t}\n}\n\nstatic int intel_irq_remapping_alloc(struct irq_domain *domain,\n\t\t\t\t     unsigned int virq, unsigned int nr_irqs,\n\t\t\t\t     void *arg)\n{\n\tstruct intel_iommu *iommu = domain->host_data;\n\tstruct irq_alloc_info *info = arg;\n\tstruct intel_ir_data *data, *ird;\n\tstruct irq_data *irq_data;\n\tstruct irq_cfg *irq_cfg;\n\tint i, ret, index;\n\n\tif (!info || !iommu)\n\t\treturn -EINVAL;\n\tif (nr_irqs > 1 && info->type != X86_IRQ_ALLOC_TYPE_PCI_MSI)\n\t\treturn -EINVAL;\n\n\tret = irq_domain_alloc_irqs_parent(domain, virq, nr_irqs, arg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = -ENOMEM;\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\tgoto out_free_parent;\n\n\tindex = alloc_irte(iommu, &data->irq_2_iommu, nr_irqs);\n\tif (index < 0) {\n\t\tpr_warn(\"Failed to allocate IRTE\\n\");\n\t\tkfree(data);\n\t\tgoto out_free_parent;\n\t}\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_data = irq_domain_get_irq_data(domain, virq + i);\n\t\tirq_cfg = irqd_cfg(irq_data);\n\t\tif (!irq_data || !irq_cfg) {\n\t\t\tif (!i)\n\t\t\t\tkfree(data);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_free_data;\n\t\t}\n\n\t\tif (i > 0) {\n\t\t\tird = kzalloc(sizeof(*ird), GFP_KERNEL);\n\t\t\tif (!ird)\n\t\t\t\tgoto out_free_data;\n\t\t\t \n\t\t\tird->irq_2_iommu = data->irq_2_iommu;\n\t\t\tird->irq_2_iommu.sub_handle = i;\n\t\t} else {\n\t\t\tird = data;\n\t\t}\n\n\t\tirq_data->hwirq = (index << 16) + i;\n\t\tirq_data->chip_data = ird;\n\t\tirq_data->chip = &intel_ir_chip;\n\t\tintel_irq_remapping_prepare_irte(ird, irq_cfg, info, index, i);\n\t\tirq_set_status_flags(virq + i, IRQ_MOVE_PCNTXT);\n\t}\n\treturn 0;\n\nout_free_data:\n\tintel_free_irq_resources(domain, virq, i);\nout_free_parent:\n\tirq_domain_free_irqs_common(domain, virq, nr_irqs);\n\treturn ret;\n}\n\nstatic void intel_irq_remapping_free(struct irq_domain *domain,\n\t\t\t\t     unsigned int virq, unsigned int nr_irqs)\n{\n\tintel_free_irq_resources(domain, virq, nr_irqs);\n\tirq_domain_free_irqs_common(domain, virq, nr_irqs);\n}\n\nstatic int intel_irq_remapping_activate(struct irq_domain *domain,\n\t\t\t\t\tstruct irq_data *irq_data, bool reserve)\n{\n\tintel_ir_reconfigure_irte(irq_data, true);\n\treturn 0;\n}\n\nstatic void intel_irq_remapping_deactivate(struct irq_domain *domain,\n\t\t\t\t\t   struct irq_data *irq_data)\n{\n\tstruct intel_ir_data *data = irq_data->chip_data;\n\tstruct irte entry;\n\n\tmemset(&entry, 0, sizeof(entry));\n\tmodify_irte(&data->irq_2_iommu, &entry);\n}\n\nstatic int intel_irq_remapping_select(struct irq_domain *d,\n\t\t\t\t      struct irq_fwspec *fwspec,\n\t\t\t\t      enum irq_domain_bus_token bus_token)\n{\n\tstruct intel_iommu *iommu = NULL;\n\n\tif (x86_fwspec_is_ioapic(fwspec))\n\t\tiommu = map_ioapic_to_iommu(fwspec->param[0]);\n\telse if (x86_fwspec_is_hpet(fwspec))\n\t\tiommu = map_hpet_to_iommu(fwspec->param[0]);\n\n\treturn iommu && d == iommu->ir_domain;\n}\n\nstatic const struct irq_domain_ops intel_ir_domain_ops = {\n\t.select = intel_irq_remapping_select,\n\t.alloc = intel_irq_remapping_alloc,\n\t.free = intel_irq_remapping_free,\n\t.activate = intel_irq_remapping_activate,\n\t.deactivate = intel_irq_remapping_deactivate,\n};\n\nstatic const struct msi_parent_ops dmar_msi_parent_ops = {\n\t.supported_flags\t= X86_VECTOR_MSI_FLAGS_SUPPORTED |\n\t\t\t\t  MSI_FLAG_MULTI_PCI_MSI |\n\t\t\t\t  MSI_FLAG_PCI_IMS,\n\t.prefix\t\t\t= \"IR-\",\n\t.init_dev_msi_info\t= msi_parent_init_dev_msi_info,\n};\n\nstatic const struct msi_parent_ops virt_dmar_msi_parent_ops = {\n\t.supported_flags\t= X86_VECTOR_MSI_FLAGS_SUPPORTED |\n\t\t\t\t  MSI_FLAG_MULTI_PCI_MSI,\n\t.prefix\t\t\t= \"vIR-\",\n\t.init_dev_msi_info\t= msi_parent_init_dev_msi_info,\n};\n\n \nstatic int dmar_ir_add(struct dmar_drhd_unit *dmaru, struct intel_iommu *iommu)\n{\n\tint ret;\n\tint eim = x2apic_enabled();\n\n\tret = intel_cap_audit(CAP_AUDIT_HOTPLUG_IRQR, iommu);\n\tif (ret)\n\t\treturn ret;\n\n\tif (eim && !ecap_eim_support(iommu->ecap)) {\n\t\tpr_info(\"DRHD %Lx: EIM not supported by DRHD, ecap %Lx\\n\",\n\t\t\tiommu->reg_phys, iommu->ecap);\n\t\treturn -ENODEV;\n\t}\n\n\tif (ir_parse_ioapic_hpet_scope(dmaru->hdr, iommu)) {\n\t\tpr_warn(\"DRHD %Lx: failed to parse managed IOAPIC/HPET\\n\",\n\t\t\tiommu->reg_phys);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\n\t \n\tret = intel_setup_irq_remapping(iommu);\n\tif (ret) {\n\t\tpr_err(\"Failed to setup irq remapping for %s\\n\",\n\t\t       iommu->name);\n\t\tintel_teardown_irq_remapping(iommu);\n\t\tir_remove_ioapic_hpet_scope(iommu);\n\t} else {\n\t\tiommu_enable_irq_remapping(iommu);\n\t}\n\n\treturn ret;\n}\n\nint dmar_ir_hotplug(struct dmar_drhd_unit *dmaru, bool insert)\n{\n\tint ret = 0;\n\tstruct intel_iommu *iommu = dmaru->iommu;\n\n\tif (!irq_remapping_enabled)\n\t\treturn 0;\n\tif (iommu == NULL)\n\t\treturn -EINVAL;\n\tif (!ecap_ir_support(iommu->ecap))\n\t\treturn 0;\n\tif (irq_remapping_cap(IRQ_POSTING_CAP) &&\n\t    !cap_pi_support(iommu->cap))\n\t\treturn -EBUSY;\n\n\tif (insert) {\n\t\tif (!iommu->ir_table)\n\t\t\tret = dmar_ir_add(dmaru, iommu);\n\t} else {\n\t\tif (iommu->ir_table) {\n\t\t\tif (!bitmap_empty(iommu->ir_table->bitmap,\n\t\t\t\t\t  INTR_REMAP_TABLE_ENTRIES)) {\n\t\t\t\tret = -EBUSY;\n\t\t\t} else {\n\t\t\t\tiommu_disable_irq_remapping(iommu);\n\t\t\t\tintel_teardown_irq_remapping(iommu);\n\t\t\t\tir_remove_ioapic_hpet_scope(iommu);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}