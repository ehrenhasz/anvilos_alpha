{
  "module_name": "iommu-sva.c",
  "hash_id": "42e1a1206ca89d9a48a853e52e1f478825ae55e91e39f44e33d681f6e7c12444",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iommu/iommu-sva.c",
  "human_readable_source": "\n \n#include <linux/mmu_context.h>\n#include <linux/mutex.h>\n#include <linux/sched/mm.h>\n#include <linux/iommu.h>\n\n#include \"iommu-sva.h\"\n\nstatic DEFINE_MUTEX(iommu_sva_lock);\n\n \nstatic int iommu_sva_alloc_pasid(struct mm_struct *mm, struct device *dev)\n{\n\tioasid_t pasid;\n\tint ret = 0;\n\n\tif (!arch_pgtable_dma_compat(mm))\n\t\treturn -EBUSY;\n\n\tmutex_lock(&iommu_sva_lock);\n\t \n\tif (mm_valid_pasid(mm)) {\n\t\tif (mm->pasid >= dev->iommu->max_pasids)\n\t\t\tret = -EOVERFLOW;\n\t\tgoto out;\n\t}\n\n\tpasid = iommu_alloc_global_pasid(dev);\n\tif (pasid == IOMMU_PASID_INVALID) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\tmm->pasid = pasid;\n\tret = 0;\nout:\n\tmutex_unlock(&iommu_sva_lock);\n\treturn ret;\n}\n\n \nstruct iommu_sva *iommu_sva_bind_device(struct device *dev, struct mm_struct *mm)\n{\n\tstruct iommu_domain *domain;\n\tstruct iommu_sva *handle;\n\tint ret;\n\n\t \n\tret = iommu_sva_alloc_pasid(mm, dev);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\thandle = kzalloc(sizeof(*handle), GFP_KERNEL);\n\tif (!handle)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_lock(&iommu_sva_lock);\n\t \n\tdomain = iommu_get_domain_for_dev_pasid(dev, mm->pasid,\n\t\t\t\t\t\tIOMMU_DOMAIN_SVA);\n\tif (IS_ERR(domain)) {\n\t\tret = PTR_ERR(domain);\n\t\tgoto out_unlock;\n\t}\n\n\tif (domain) {\n\t\tdomain->users++;\n\t\tgoto out;\n\t}\n\n\t \n\tdomain = iommu_sva_domain_alloc(dev, mm);\n\tif (!domain) {\n\t\tret = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\tret = iommu_attach_device_pasid(domain, dev, mm->pasid);\n\tif (ret)\n\t\tgoto out_free_domain;\n\tdomain->users = 1;\nout:\n\tmutex_unlock(&iommu_sva_lock);\n\thandle->dev = dev;\n\thandle->domain = domain;\n\n\treturn handle;\n\nout_free_domain:\n\tiommu_domain_free(domain);\nout_unlock:\n\tmutex_unlock(&iommu_sva_lock);\n\tkfree(handle);\n\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL_GPL(iommu_sva_bind_device);\n\n \nvoid iommu_sva_unbind_device(struct iommu_sva *handle)\n{\n\tstruct iommu_domain *domain = handle->domain;\n\tioasid_t pasid = domain->mm->pasid;\n\tstruct device *dev = handle->dev;\n\n\tmutex_lock(&iommu_sva_lock);\n\tif (--domain->users == 0) {\n\t\tiommu_detach_device_pasid(domain, dev, pasid);\n\t\tiommu_domain_free(domain);\n\t}\n\tmutex_unlock(&iommu_sva_lock);\n\tkfree(handle);\n}\nEXPORT_SYMBOL_GPL(iommu_sva_unbind_device);\n\nu32 iommu_sva_get_pasid(struct iommu_sva *handle)\n{\n\tstruct iommu_domain *domain = handle->domain;\n\n\treturn domain->mm->pasid;\n}\nEXPORT_SYMBOL_GPL(iommu_sva_get_pasid);\n\n \nenum iommu_page_response_code\niommu_sva_handle_iopf(struct iommu_fault *fault, void *data)\n{\n\tvm_fault_t ret;\n\tstruct vm_area_struct *vma;\n\tstruct mm_struct *mm = data;\n\tunsigned int access_flags = 0;\n\tunsigned int fault_flags = FAULT_FLAG_REMOTE;\n\tstruct iommu_fault_page_request *prm = &fault->prm;\n\tenum iommu_page_response_code status = IOMMU_PAGE_RESP_INVALID;\n\n\tif (!(prm->flags & IOMMU_FAULT_PAGE_REQUEST_PASID_VALID))\n\t\treturn status;\n\n\tif (!mmget_not_zero(mm))\n\t\treturn status;\n\n\tmmap_read_lock(mm);\n\n\tvma = vma_lookup(mm, prm->addr);\n\tif (!vma)\n\t\t \n\t\tgoto out_put_mm;\n\n\tif (prm->perm & IOMMU_FAULT_PERM_READ)\n\t\taccess_flags |= VM_READ;\n\n\tif (prm->perm & IOMMU_FAULT_PERM_WRITE) {\n\t\taccess_flags |= VM_WRITE;\n\t\tfault_flags |= FAULT_FLAG_WRITE;\n\t}\n\n\tif (prm->perm & IOMMU_FAULT_PERM_EXEC) {\n\t\taccess_flags |= VM_EXEC;\n\t\tfault_flags |= FAULT_FLAG_INSTRUCTION;\n\t}\n\n\tif (!(prm->perm & IOMMU_FAULT_PERM_PRIV))\n\t\tfault_flags |= FAULT_FLAG_USER;\n\n\tif (access_flags & ~vma->vm_flags)\n\t\t \n\t\tgoto out_put_mm;\n\n\tret = handle_mm_fault(vma, prm->addr, fault_flags, NULL);\n\tstatus = ret & VM_FAULT_ERROR ? IOMMU_PAGE_RESP_INVALID :\n\t\tIOMMU_PAGE_RESP_SUCCESS;\n\nout_put_mm:\n\tmmap_read_unlock(mm);\n\tmmput(mm);\n\n\treturn status;\n}\n\nvoid mm_pasid_drop(struct mm_struct *mm)\n{\n\tif (likely(!mm_valid_pasid(mm)))\n\t\treturn;\n\n\tiommu_free_global_pasid(mm->pasid);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}