{
  "module_name": "apple-dart.c",
  "hash_id": "e5f2a9f5d1e9ae02e44aee5cd7085021cb9eabbceaf59f8b199815289a1d7c1f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iommu/apple-dart.c",
  "human_readable_source": "\n \n\n#include <linux/atomic.h>\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/dev_printk.h>\n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/io-pgtable.h>\n#include <linux/iommu.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_iommu.h>\n#include <linux/of_platform.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/swab.h>\n#include <linux/types.h>\n\n#include \"dma-iommu.h\"\n\n#define DART_MAX_STREAMS 256\n#define DART_MAX_TTBR 4\n#define MAX_DARTS_PER_DEVICE 2\n\n \n\n#define DART_PARAMS1 0x00\n#define DART_PARAMS1_PAGE_SHIFT GENMASK(27, 24)\n\n#define DART_PARAMS2 0x04\n#define DART_PARAMS2_BYPASS_SUPPORT BIT(0)\n\n \n\n#define DART_T8020_STREAM_COMMAND 0x20\n#define DART_T8020_STREAM_COMMAND_BUSY BIT(2)\n#define DART_T8020_STREAM_COMMAND_INVALIDATE BIT(20)\n\n#define DART_T8020_STREAM_SELECT 0x34\n\n#define DART_T8020_ERROR 0x40\n#define DART_T8020_ERROR_STREAM GENMASK(27, 24)\n#define DART_T8020_ERROR_CODE GENMASK(11, 0)\n#define DART_T8020_ERROR_FLAG BIT(31)\n\n#define DART_T8020_ERROR_READ_FAULT BIT(4)\n#define DART_T8020_ERROR_WRITE_FAULT BIT(3)\n#define DART_T8020_ERROR_NO_PTE BIT(2)\n#define DART_T8020_ERROR_NO_PMD BIT(1)\n#define DART_T8020_ERROR_NO_TTBR BIT(0)\n\n#define DART_T8020_CONFIG 0x60\n#define DART_T8020_CONFIG_LOCK BIT(15)\n\n#define DART_STREAM_COMMAND_BUSY_TIMEOUT 100\n\n#define DART_T8020_ERROR_ADDR_HI 0x54\n#define DART_T8020_ERROR_ADDR_LO 0x50\n\n#define DART_T8020_STREAMS_ENABLE 0xfc\n\n#define DART_T8020_TCR                  0x100\n#define DART_T8020_TCR_TRANSLATE_ENABLE BIT(7)\n#define DART_T8020_TCR_BYPASS_DART      BIT(8)\n#define DART_T8020_TCR_BYPASS_DAPF      BIT(12)\n\n#define DART_T8020_TTBR       0x200\n#define DART_T8020_TTBR_VALID BIT(31)\n#define DART_T8020_TTBR_ADDR_FIELD_SHIFT 0\n#define DART_T8020_TTBR_SHIFT 12\n\n \n\n#define DART_T8110_PARAMS3 0x08\n#define DART_T8110_PARAMS3_PA_WIDTH GENMASK(29, 24)\n#define DART_T8110_PARAMS3_VA_WIDTH GENMASK(21, 16)\n#define DART_T8110_PARAMS3_VER_MAJ GENMASK(15, 8)\n#define DART_T8110_PARAMS3_VER_MIN GENMASK(7, 0)\n\n#define DART_T8110_PARAMS4 0x0c\n#define DART_T8110_PARAMS4_NUM_CLIENTS GENMASK(24, 16)\n#define DART_T8110_PARAMS4_NUM_SIDS GENMASK(8, 0)\n\n#define DART_T8110_TLB_CMD              0x80\n#define DART_T8110_TLB_CMD_BUSY         BIT(31)\n#define DART_T8110_TLB_CMD_OP           GENMASK(10, 8)\n#define DART_T8110_TLB_CMD_OP_FLUSH_ALL 0\n#define DART_T8110_TLB_CMD_OP_FLUSH_SID 1\n#define DART_T8110_TLB_CMD_STREAM       GENMASK(7, 0)\n\n#define DART_T8110_ERROR 0x100\n#define DART_T8110_ERROR_STREAM GENMASK(27, 20)\n#define DART_T8110_ERROR_CODE GENMASK(14, 0)\n#define DART_T8110_ERROR_FLAG BIT(31)\n\n#define DART_T8110_ERROR_MASK 0x104\n\n#define DART_T8110_ERROR_READ_FAULT BIT(5)\n#define DART_T8110_ERROR_WRITE_FAULT BIT(4)\n#define DART_T8110_ERROR_NO_PTE BIT(3)\n#define DART_T8110_ERROR_NO_PMD BIT(2)\n#define DART_T8110_ERROR_NO_PGD BIT(1)\n#define DART_T8110_ERROR_NO_TTBR BIT(0)\n\n#define DART_T8110_ERROR_ADDR_LO 0x170\n#define DART_T8110_ERROR_ADDR_HI 0x174\n\n#define DART_T8110_PROTECT 0x200\n#define DART_T8110_UNPROTECT 0x204\n#define DART_T8110_PROTECT_LOCK 0x208\n#define DART_T8110_PROTECT_TTBR_TCR BIT(0)\n\n#define DART_T8110_ENABLE_STREAMS  0xc00\n#define DART_T8110_DISABLE_STREAMS 0xc20\n\n#define DART_T8110_TCR                  0x1000\n#define DART_T8110_TCR_REMAP            GENMASK(11, 8)\n#define DART_T8110_TCR_REMAP_EN         BIT(7)\n#define DART_T8110_TCR_BYPASS_DAPF      BIT(2)\n#define DART_T8110_TCR_BYPASS_DART      BIT(1)\n#define DART_T8110_TCR_TRANSLATE_ENABLE BIT(0)\n\n#define DART_T8110_TTBR       0x1400\n#define DART_T8110_TTBR_VALID BIT(0)\n#define DART_T8110_TTBR_ADDR_FIELD_SHIFT 2\n#define DART_T8110_TTBR_SHIFT 14\n\n#define DART_TCR(dart, sid) ((dart)->hw->tcr + ((sid) << 2))\n\n#define DART_TTBR(dart, sid, idx) ((dart)->hw->ttbr + \\\n\t\t\t\t   (((dart)->hw->ttbr_count * (sid)) << 2) + \\\n\t\t\t\t   ((idx) << 2))\n\nstruct apple_dart_stream_map;\n\nenum dart_type {\n\tDART_T8020,\n\tDART_T6000,\n\tDART_T8110,\n};\n\nstruct apple_dart_hw {\n\tenum dart_type type;\n\tirqreturn_t (*irq_handler)(int irq, void *dev);\n\tint (*invalidate_tlb)(struct apple_dart_stream_map *stream_map);\n\n\tu32 oas;\n\tenum io_pgtable_fmt fmt;\n\n\tint max_sid_count;\n\n\tu64 lock;\n\tu64 lock_bit;\n\n\tu64 error;\n\n\tu64 enable_streams;\n\n\tu64 tcr;\n\tu64 tcr_enabled;\n\tu64 tcr_disabled;\n\tu64 tcr_bypass;\n\n\tu64 ttbr;\n\tu64 ttbr_valid;\n\tu64 ttbr_addr_field_shift;\n\tu64 ttbr_shift;\n\tint ttbr_count;\n};\n\n \nstruct apple_dart {\n\tstruct device *dev;\n\tconst struct apple_dart_hw *hw;\n\n\tvoid __iomem *regs;\n\n\tint irq;\n\tstruct clk_bulk_data *clks;\n\tint num_clks;\n\n\tspinlock_t lock;\n\n\tu32 ias;\n\tu32 oas;\n\tu32 pgsize;\n\tu32 num_streams;\n\tu32 supports_bypass : 1;\n\tu32 force_bypass : 1;\n\n\tstruct iommu_group *sid2group[DART_MAX_STREAMS];\n\tstruct iommu_device iommu;\n\n\tu32 save_tcr[DART_MAX_STREAMS];\n\tu32 save_ttbr[DART_MAX_STREAMS][DART_MAX_TTBR];\n};\n\n \nstruct apple_dart_stream_map {\n\tstruct apple_dart *dart;\n\tDECLARE_BITMAP(sidmap, DART_MAX_STREAMS);\n};\nstruct apple_dart_atomic_stream_map {\n\tstruct apple_dart *dart;\n\tatomic_long_t sidmap[BITS_TO_LONGS(DART_MAX_STREAMS)];\n};\n\n \nstruct apple_dart_domain {\n\tstruct io_pgtable_ops *pgtbl_ops;\n\n\tbool finalized;\n\tstruct mutex init_lock;\n\tstruct apple_dart_atomic_stream_map stream_maps[MAX_DARTS_PER_DEVICE];\n\n\tstruct iommu_domain domain;\n};\n\n \nstruct apple_dart_master_cfg {\n\tstruct apple_dart_stream_map stream_maps[MAX_DARTS_PER_DEVICE];\n};\n\n \n#define for_each_stream_map(i, base, stream_map)                               \\\n\tfor (i = 0, stream_map = &(base)->stream_maps[0];                      \\\n\t     i < MAX_DARTS_PER_DEVICE && stream_map->dart;                     \\\n\t     stream_map = &(base)->stream_maps[++i])\n\nstatic struct platform_driver apple_dart_driver;\nstatic const struct iommu_ops apple_dart_iommu_ops;\n\nstatic struct apple_dart_domain *to_dart_domain(struct iommu_domain *dom)\n{\n\treturn container_of(dom, struct apple_dart_domain, domain);\n}\n\nstatic void\napple_dart_hw_enable_translation(struct apple_dart_stream_map *stream_map)\n{\n\tstruct apple_dart *dart = stream_map->dart;\n\tint sid;\n\n\tfor_each_set_bit(sid, stream_map->sidmap, dart->num_streams)\n\t\twritel(dart->hw->tcr_enabled, dart->regs + DART_TCR(dart, sid));\n}\n\nstatic void apple_dart_hw_disable_dma(struct apple_dart_stream_map *stream_map)\n{\n\tstruct apple_dart *dart = stream_map->dart;\n\tint sid;\n\n\tfor_each_set_bit(sid, stream_map->sidmap, dart->num_streams)\n\t\twritel(dart->hw->tcr_disabled, dart->regs + DART_TCR(dart, sid));\n}\n\nstatic void\napple_dart_hw_enable_bypass(struct apple_dart_stream_map *stream_map)\n{\n\tstruct apple_dart *dart = stream_map->dart;\n\tint sid;\n\n\tWARN_ON(!stream_map->dart->supports_bypass);\n\tfor_each_set_bit(sid, stream_map->sidmap, dart->num_streams)\n\t\twritel(dart->hw->tcr_bypass,\n\t\t       dart->regs + DART_TCR(dart, sid));\n}\n\nstatic void apple_dart_hw_set_ttbr(struct apple_dart_stream_map *stream_map,\n\t\t\t\t   u8 idx, phys_addr_t paddr)\n{\n\tstruct apple_dart *dart = stream_map->dart;\n\tint sid;\n\n\tWARN_ON(paddr & ((1 << dart->hw->ttbr_shift) - 1));\n\tfor_each_set_bit(sid, stream_map->sidmap, dart->num_streams)\n\t\twritel(dart->hw->ttbr_valid |\n\t\t       (paddr >> dart->hw->ttbr_shift) << dart->hw->ttbr_addr_field_shift,\n\t\t       dart->regs + DART_TTBR(dart, sid, idx));\n}\n\nstatic void apple_dart_hw_clear_ttbr(struct apple_dart_stream_map *stream_map,\n\t\t\t\t     u8 idx)\n{\n\tstruct apple_dart *dart = stream_map->dart;\n\tint sid;\n\n\tfor_each_set_bit(sid, stream_map->sidmap, dart->num_streams)\n\t\twritel(0, dart->regs + DART_TTBR(dart, sid, idx));\n}\n\nstatic void\napple_dart_hw_clear_all_ttbrs(struct apple_dart_stream_map *stream_map)\n{\n\tint i;\n\n\tfor (i = 0; i < stream_map->dart->hw->ttbr_count; ++i)\n\t\tapple_dart_hw_clear_ttbr(stream_map, i);\n}\n\nstatic int\napple_dart_t8020_hw_stream_command(struct apple_dart_stream_map *stream_map,\n\t\t\t     u32 command)\n{\n\tunsigned long flags;\n\tint ret;\n\tu32 command_reg;\n\n\tspin_lock_irqsave(&stream_map->dart->lock, flags);\n\n\twritel(stream_map->sidmap[0], stream_map->dart->regs + DART_T8020_STREAM_SELECT);\n\twritel(command, stream_map->dart->regs + DART_T8020_STREAM_COMMAND);\n\n\tret = readl_poll_timeout_atomic(\n\t\tstream_map->dart->regs + DART_T8020_STREAM_COMMAND, command_reg,\n\t\t!(command_reg & DART_T8020_STREAM_COMMAND_BUSY), 1,\n\t\tDART_STREAM_COMMAND_BUSY_TIMEOUT);\n\n\tspin_unlock_irqrestore(&stream_map->dart->lock, flags);\n\n\tif (ret) {\n\t\tdev_err(stream_map->dart->dev,\n\t\t\t\"busy bit did not clear after command %x for streams %lx\\n\",\n\t\t\tcommand, stream_map->sidmap[0]);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int\napple_dart_t8110_hw_tlb_command(struct apple_dart_stream_map *stream_map,\n\t\t\t\tu32 command)\n{\n\tstruct apple_dart *dart = stream_map->dart;\n\tunsigned long flags;\n\tint ret = 0;\n\tint sid;\n\n\tspin_lock_irqsave(&dart->lock, flags);\n\n\tfor_each_set_bit(sid, stream_map->sidmap, dart->num_streams) {\n\t\tu32 val = FIELD_PREP(DART_T8110_TLB_CMD_OP, command) |\n\t\t\tFIELD_PREP(DART_T8110_TLB_CMD_STREAM, sid);\n\t\twritel(val, dart->regs + DART_T8110_TLB_CMD);\n\n\t\tret = readl_poll_timeout_atomic(\n\t\t\tdart->regs + DART_T8110_TLB_CMD, val,\n\t\t\t!(val & DART_T8110_TLB_CMD_BUSY), 1,\n\t\t\tDART_STREAM_COMMAND_BUSY_TIMEOUT);\n\n\t\tif (ret)\n\t\t\tbreak;\n\n\t}\n\n\tspin_unlock_irqrestore(&dart->lock, flags);\n\n\tif (ret) {\n\t\tdev_err(stream_map->dart->dev,\n\t\t\t\"busy bit did not clear after command %x for stream %d\\n\",\n\t\t\tcommand, sid);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int\napple_dart_t8020_hw_invalidate_tlb(struct apple_dart_stream_map *stream_map)\n{\n\treturn apple_dart_t8020_hw_stream_command(\n\t\tstream_map, DART_T8020_STREAM_COMMAND_INVALIDATE);\n}\n\nstatic int\napple_dart_t8110_hw_invalidate_tlb(struct apple_dart_stream_map *stream_map)\n{\n\treturn apple_dart_t8110_hw_tlb_command(\n\t\tstream_map, DART_T8110_TLB_CMD_OP_FLUSH_SID);\n}\n\nstatic int apple_dart_hw_reset(struct apple_dart *dart)\n{\n\tu32 config;\n\tstruct apple_dart_stream_map stream_map;\n\tint i;\n\n\tconfig = readl(dart->regs + dart->hw->lock);\n\tif (config & dart->hw->lock_bit) {\n\t\tdev_err(dart->dev, \"DART is locked down until reboot: %08x\\n\",\n\t\t\tconfig);\n\t\treturn -EINVAL;\n\t}\n\n\tstream_map.dart = dart;\n\tbitmap_zero(stream_map.sidmap, DART_MAX_STREAMS);\n\tbitmap_set(stream_map.sidmap, 0, dart->num_streams);\n\tapple_dart_hw_disable_dma(&stream_map);\n\tapple_dart_hw_clear_all_ttbrs(&stream_map);\n\n\t \n\tfor (i = 0; i < BITS_TO_U32(dart->num_streams); i++)\n\t\twritel(U32_MAX, dart->regs + dart->hw->enable_streams + 4 * i);\n\n\t \n\twritel(readl(dart->regs + dart->hw->error), dart->regs + dart->hw->error);\n\n\tif (dart->hw->type == DART_T8110)\n\t\twritel(0,  dart->regs + DART_T8110_ERROR_MASK);\n\n\treturn dart->hw->invalidate_tlb(&stream_map);\n}\n\nstatic void apple_dart_domain_flush_tlb(struct apple_dart_domain *domain)\n{\n\tint i, j;\n\tstruct apple_dart_atomic_stream_map *domain_stream_map;\n\tstruct apple_dart_stream_map stream_map;\n\n\tfor_each_stream_map(i, domain, domain_stream_map) {\n\t\tstream_map.dart = domain_stream_map->dart;\n\n\t\tfor (j = 0; j < BITS_TO_LONGS(stream_map.dart->num_streams); j++)\n\t\t\tstream_map.sidmap[j] = atomic_long_read(&domain_stream_map->sidmap[j]);\n\n\t\tstream_map.dart->hw->invalidate_tlb(&stream_map);\n\t}\n}\n\nstatic void apple_dart_flush_iotlb_all(struct iommu_domain *domain)\n{\n\tapple_dart_domain_flush_tlb(to_dart_domain(domain));\n}\n\nstatic void apple_dart_iotlb_sync(struct iommu_domain *domain,\n\t\t\t\t  struct iommu_iotlb_gather *gather)\n{\n\tapple_dart_domain_flush_tlb(to_dart_domain(domain));\n}\n\nstatic void apple_dart_iotlb_sync_map(struct iommu_domain *domain,\n\t\t\t\t      unsigned long iova, size_t size)\n{\n\tapple_dart_domain_flush_tlb(to_dart_domain(domain));\n}\n\nstatic phys_addr_t apple_dart_iova_to_phys(struct iommu_domain *domain,\n\t\t\t\t\t   dma_addr_t iova)\n{\n\tstruct apple_dart_domain *dart_domain = to_dart_domain(domain);\n\tstruct io_pgtable_ops *ops = dart_domain->pgtbl_ops;\n\n\tif (!ops)\n\t\treturn 0;\n\n\treturn ops->iova_to_phys(ops, iova);\n}\n\nstatic int apple_dart_map_pages(struct iommu_domain *domain, unsigned long iova,\n\t\t\t\tphys_addr_t paddr, size_t pgsize,\n\t\t\t\tsize_t pgcount, int prot, gfp_t gfp,\n\t\t\t\tsize_t *mapped)\n{\n\tstruct apple_dart_domain *dart_domain = to_dart_domain(domain);\n\tstruct io_pgtable_ops *ops = dart_domain->pgtbl_ops;\n\n\tif (!ops)\n\t\treturn -ENODEV;\n\n\treturn ops->map_pages(ops, iova, paddr, pgsize, pgcount, prot, gfp,\n\t\t\t      mapped);\n}\n\nstatic size_t apple_dart_unmap_pages(struct iommu_domain *domain,\n\t\t\t\t     unsigned long iova, size_t pgsize,\n\t\t\t\t     size_t pgcount,\n\t\t\t\t     struct iommu_iotlb_gather *gather)\n{\n\tstruct apple_dart_domain *dart_domain = to_dart_domain(domain);\n\tstruct io_pgtable_ops *ops = dart_domain->pgtbl_ops;\n\n\treturn ops->unmap_pages(ops, iova, pgsize, pgcount, gather);\n}\n\nstatic void\napple_dart_setup_translation(struct apple_dart_domain *domain,\n\t\t\t     struct apple_dart_stream_map *stream_map)\n{\n\tint i;\n\tstruct io_pgtable_cfg *pgtbl_cfg =\n\t\t&io_pgtable_ops_to_pgtable(domain->pgtbl_ops)->cfg;\n\n\tfor (i = 0; i < pgtbl_cfg->apple_dart_cfg.n_ttbrs; ++i)\n\t\tapple_dart_hw_set_ttbr(stream_map, i,\n\t\t\t\t       pgtbl_cfg->apple_dart_cfg.ttbr[i]);\n\tfor (; i < stream_map->dart->hw->ttbr_count; ++i)\n\t\tapple_dart_hw_clear_ttbr(stream_map, i);\n\n\tapple_dart_hw_enable_translation(stream_map);\n\tstream_map->dart->hw->invalidate_tlb(stream_map);\n}\n\nstatic int apple_dart_finalize_domain(struct iommu_domain *domain,\n\t\t\t\t      struct apple_dart_master_cfg *cfg)\n{\n\tstruct apple_dart_domain *dart_domain = to_dart_domain(domain);\n\tstruct apple_dart *dart = cfg->stream_maps[0].dart;\n\tstruct io_pgtable_cfg pgtbl_cfg;\n\tint ret = 0;\n\tint i, j;\n\n\tmutex_lock(&dart_domain->init_lock);\n\n\tif (dart_domain->finalized)\n\t\tgoto done;\n\n\tfor (i = 0; i < MAX_DARTS_PER_DEVICE; ++i) {\n\t\tdart_domain->stream_maps[i].dart = cfg->stream_maps[i].dart;\n\t\tfor (j = 0; j < BITS_TO_LONGS(dart->num_streams); j++)\n\t\t\tatomic_long_set(&dart_domain->stream_maps[i].sidmap[j],\n\t\t\t\t\tcfg->stream_maps[i].sidmap[j]);\n\t}\n\n\tpgtbl_cfg = (struct io_pgtable_cfg){\n\t\t.pgsize_bitmap = dart->pgsize,\n\t\t.ias = dart->ias,\n\t\t.oas = dart->oas,\n\t\t.coherent_walk = 1,\n\t\t.iommu_dev = dart->dev,\n\t};\n\n\tdart_domain->pgtbl_ops =\n\t\talloc_io_pgtable_ops(dart->hw->fmt, &pgtbl_cfg, domain);\n\tif (!dart_domain->pgtbl_ops) {\n\t\tret = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\tdomain->pgsize_bitmap = pgtbl_cfg.pgsize_bitmap;\n\tdomain->geometry.aperture_start = 0;\n\tdomain->geometry.aperture_end = (dma_addr_t)DMA_BIT_MASK(dart->ias);\n\tdomain->geometry.force_aperture = true;\n\n\tdart_domain->finalized = true;\n\ndone:\n\tmutex_unlock(&dart_domain->init_lock);\n\treturn ret;\n}\n\nstatic int\napple_dart_mod_streams(struct apple_dart_atomic_stream_map *domain_maps,\n\t\t       struct apple_dart_stream_map *master_maps,\n\t\t       bool add_streams)\n{\n\tint i, j;\n\n\tfor (i = 0; i < MAX_DARTS_PER_DEVICE; ++i) {\n\t\tif (domain_maps[i].dart != master_maps[i].dart)\n\t\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < MAX_DARTS_PER_DEVICE; ++i) {\n\t\tif (!domain_maps[i].dart)\n\t\t\tbreak;\n\t\tfor (j = 0; j < BITS_TO_LONGS(domain_maps[i].dart->num_streams); j++) {\n\t\t\tif (add_streams)\n\t\t\t\tatomic_long_or(master_maps[i].sidmap[j],\n\t\t\t\t\t       &domain_maps[i].sidmap[j]);\n\t\t\telse\n\t\t\t\tatomic_long_and(~master_maps[i].sidmap[j],\n\t\t\t\t\t\t&domain_maps[i].sidmap[j]);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int apple_dart_domain_add_streams(struct apple_dart_domain *domain,\n\t\t\t\t\t struct apple_dart_master_cfg *cfg)\n{\n\treturn apple_dart_mod_streams(domain->stream_maps, cfg->stream_maps,\n\t\t\t\t      true);\n}\n\nstatic int apple_dart_attach_dev(struct iommu_domain *domain,\n\t\t\t\t struct device *dev)\n{\n\tint ret, i;\n\tstruct apple_dart_stream_map *stream_map;\n\tstruct apple_dart_master_cfg *cfg = dev_iommu_priv_get(dev);\n\tstruct apple_dart_domain *dart_domain = to_dart_domain(domain);\n\n\tif (cfg->stream_maps[0].dart->force_bypass &&\n\t    domain->type != IOMMU_DOMAIN_IDENTITY)\n\t\treturn -EINVAL;\n\tif (!cfg->stream_maps[0].dart->supports_bypass &&\n\t    domain->type == IOMMU_DOMAIN_IDENTITY)\n\t\treturn -EINVAL;\n\n\tret = apple_dart_finalize_domain(domain, cfg);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (domain->type) {\n\tdefault:\n\t\tret = apple_dart_domain_add_streams(dart_domain, cfg);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tfor_each_stream_map(i, cfg, stream_map)\n\t\t\tapple_dart_setup_translation(dart_domain, stream_map);\n\t\tbreak;\n\tcase IOMMU_DOMAIN_BLOCKED:\n\t\tfor_each_stream_map(i, cfg, stream_map)\n\t\t\tapple_dart_hw_disable_dma(stream_map);\n\t\tbreak;\n\tcase IOMMU_DOMAIN_IDENTITY:\n\t\tfor_each_stream_map(i, cfg, stream_map)\n\t\t\tapple_dart_hw_enable_bypass(stream_map);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic struct iommu_device *apple_dart_probe_device(struct device *dev)\n{\n\tstruct apple_dart_master_cfg *cfg = dev_iommu_priv_get(dev);\n\tstruct apple_dart_stream_map *stream_map;\n\tint i;\n\n\tif (!cfg)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tfor_each_stream_map(i, cfg, stream_map)\n\t\tdevice_link_add(\n\t\t\tdev, stream_map->dart->dev,\n\t\t\tDL_FLAG_PM_RUNTIME | DL_FLAG_AUTOREMOVE_SUPPLIER);\n\n\treturn &cfg->stream_maps[0].dart->iommu;\n}\n\nstatic void apple_dart_release_device(struct device *dev)\n{\n\tstruct apple_dart_master_cfg *cfg = dev_iommu_priv_get(dev);\n\n\tdev_iommu_priv_set(dev, NULL);\n\tkfree(cfg);\n}\n\nstatic struct iommu_domain *apple_dart_domain_alloc(unsigned int type)\n{\n\tstruct apple_dart_domain *dart_domain;\n\n\tif (type != IOMMU_DOMAIN_DMA && type != IOMMU_DOMAIN_UNMANAGED &&\n\t    type != IOMMU_DOMAIN_IDENTITY && type != IOMMU_DOMAIN_BLOCKED)\n\t\treturn NULL;\n\n\tdart_domain = kzalloc(sizeof(*dart_domain), GFP_KERNEL);\n\tif (!dart_domain)\n\t\treturn NULL;\n\n\tmutex_init(&dart_domain->init_lock);\n\n\t \n\tif (type == IOMMU_DOMAIN_IDENTITY || type == IOMMU_DOMAIN_BLOCKED)\n\t\tdart_domain->finalized = true;\n\n\treturn &dart_domain->domain;\n}\n\nstatic void apple_dart_domain_free(struct iommu_domain *domain)\n{\n\tstruct apple_dart_domain *dart_domain = to_dart_domain(domain);\n\n\tif (dart_domain->pgtbl_ops)\n\t\tfree_io_pgtable_ops(dart_domain->pgtbl_ops);\n\n\tkfree(dart_domain);\n}\n\nstatic int apple_dart_of_xlate(struct device *dev, struct of_phandle_args *args)\n{\n\tstruct apple_dart_master_cfg *cfg = dev_iommu_priv_get(dev);\n\tstruct platform_device *iommu_pdev = of_find_device_by_node(args->np);\n\tstruct apple_dart *dart = platform_get_drvdata(iommu_pdev);\n\tstruct apple_dart *cfg_dart;\n\tint i, sid;\n\n\tif (args->args_count != 1)\n\t\treturn -EINVAL;\n\tsid = args->args[0];\n\n\tif (!cfg)\n\t\tcfg = kzalloc(sizeof(*cfg), GFP_KERNEL);\n\tif (!cfg)\n\t\treturn -ENOMEM;\n\tdev_iommu_priv_set(dev, cfg);\n\n\tcfg_dart = cfg->stream_maps[0].dart;\n\tif (cfg_dart) {\n\t\tif (cfg_dart->supports_bypass != dart->supports_bypass)\n\t\t\treturn -EINVAL;\n\t\tif (cfg_dart->force_bypass != dart->force_bypass)\n\t\t\treturn -EINVAL;\n\t\tif (cfg_dart->pgsize != dart->pgsize)\n\t\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < MAX_DARTS_PER_DEVICE; ++i) {\n\t\tif (cfg->stream_maps[i].dart == dart) {\n\t\t\tset_bit(sid, cfg->stream_maps[i].sidmap);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor (i = 0; i < MAX_DARTS_PER_DEVICE; ++i) {\n\t\tif (!cfg->stream_maps[i].dart) {\n\t\t\tcfg->stream_maps[i].dart = dart;\n\t\t\tset_bit(sid, cfg->stream_maps[i].sidmap);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic DEFINE_MUTEX(apple_dart_groups_lock);\n\nstatic void apple_dart_release_group(void *iommu_data)\n{\n\tint i, sid;\n\tstruct apple_dart_stream_map *stream_map;\n\tstruct apple_dart_master_cfg *group_master_cfg = iommu_data;\n\n\tmutex_lock(&apple_dart_groups_lock);\n\n\tfor_each_stream_map(i, group_master_cfg, stream_map)\n\t\tfor_each_set_bit(sid, stream_map->sidmap, stream_map->dart->num_streams)\n\t\t\tstream_map->dart->sid2group[sid] = NULL;\n\n\tkfree(iommu_data);\n\tmutex_unlock(&apple_dart_groups_lock);\n}\n\nstatic int apple_dart_merge_master_cfg(struct apple_dart_master_cfg *dst,\n\t\t\t\t       struct apple_dart_master_cfg *src)\n{\n\t \n\tif (src->stream_maps[1].dart)\n\t\treturn -EINVAL;\n\tif (dst->stream_maps[1].dart)\n\t\treturn -EINVAL;\n\tif (src->stream_maps[0].dart != dst->stream_maps[0].dart)\n\t\treturn -EINVAL;\n\n\tbitmap_or(dst->stream_maps[0].sidmap,\n\t\t  dst->stream_maps[0].sidmap,\n\t\t  src->stream_maps[0].sidmap,\n\t\t  dst->stream_maps[0].dart->num_streams);\n\treturn 0;\n}\n\nstatic struct iommu_group *apple_dart_device_group(struct device *dev)\n{\n\tint i, sid;\n\tstruct apple_dart_master_cfg *cfg = dev_iommu_priv_get(dev);\n\tstruct apple_dart_stream_map *stream_map;\n\tstruct apple_dart_master_cfg *group_master_cfg;\n\tstruct iommu_group *group = NULL;\n\tstruct iommu_group *res = ERR_PTR(-EINVAL);\n\n\tmutex_lock(&apple_dart_groups_lock);\n\n\tfor_each_stream_map(i, cfg, stream_map) {\n\t\tfor_each_set_bit(sid, stream_map->sidmap, stream_map->dart->num_streams) {\n\t\t\tstruct iommu_group *stream_group =\n\t\t\t\tstream_map->dart->sid2group[sid];\n\n\t\t\tif (group && group != stream_group) {\n\t\t\t\tres = ERR_PTR(-EINVAL);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tgroup = stream_group;\n\t\t}\n\t}\n\n\tif (group) {\n\t\tres = iommu_group_ref_get(group);\n\t\tgoto out;\n\t}\n\n#ifdef CONFIG_PCI\n\tif (dev_is_pci(dev))\n\t\tgroup = pci_device_group(dev);\n\telse\n#endif\n\t\tgroup = generic_device_group(dev);\n\n\tres = ERR_PTR(-ENOMEM);\n\tif (!group)\n\t\tgoto out;\n\n\tgroup_master_cfg = iommu_group_get_iommudata(group);\n\tif (group_master_cfg) {\n\t\tint ret;\n\n\t\tret = apple_dart_merge_master_cfg(group_master_cfg, cfg);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to merge DART IOMMU grups.\\n\");\n\t\t\tiommu_group_put(group);\n\t\t\tres = ERR_PTR(ret);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tgroup_master_cfg = kmemdup(cfg, sizeof(*group_master_cfg),\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!group_master_cfg) {\n\t\t\tiommu_group_put(group);\n\t\t\tgoto out;\n\t\t}\n\n\t\tiommu_group_set_iommudata(group, group_master_cfg,\n\t\t\tapple_dart_release_group);\n\t}\n\n\tfor_each_stream_map(i, cfg, stream_map)\n\t\tfor_each_set_bit(sid, stream_map->sidmap, stream_map->dart->num_streams)\n\t\t\tstream_map->dart->sid2group[sid] = group;\n\n\tres = group;\n\nout:\n\tmutex_unlock(&apple_dart_groups_lock);\n\treturn res;\n}\n\nstatic int apple_dart_def_domain_type(struct device *dev)\n{\n\tstruct apple_dart_master_cfg *cfg = dev_iommu_priv_get(dev);\n\n\tif (cfg->stream_maps[0].dart->force_bypass)\n\t\treturn IOMMU_DOMAIN_IDENTITY;\n\tif (!cfg->stream_maps[0].dart->supports_bypass)\n\t\treturn IOMMU_DOMAIN_DMA;\n\n\treturn 0;\n}\n\n#ifndef CONFIG_PCIE_APPLE_MSI_DOORBELL_ADDR\n \n#define CONFIG_PCIE_APPLE_MSI_DOORBELL_ADDR\t0\n#endif\n#define DOORBELL_ADDR\t(CONFIG_PCIE_APPLE_MSI_DOORBELL_ADDR & PAGE_MASK)\n\nstatic void apple_dart_get_resv_regions(struct device *dev,\n\t\t\t\t\tstruct list_head *head)\n{\n\tif (IS_ENABLED(CONFIG_PCIE_APPLE) && dev_is_pci(dev)) {\n\t\tstruct iommu_resv_region *region;\n\t\tint prot = IOMMU_WRITE | IOMMU_NOEXEC | IOMMU_MMIO;\n\n\t\tregion = iommu_alloc_resv_region(DOORBELL_ADDR,\n\t\t\t\t\t\t PAGE_SIZE, prot,\n\t\t\t\t\t\t IOMMU_RESV_MSI, GFP_KERNEL);\n\t\tif (!region)\n\t\t\treturn;\n\n\t\tlist_add_tail(&region->list, head);\n\t}\n\n\tiommu_dma_get_resv_regions(dev, head);\n}\n\nstatic const struct iommu_ops apple_dart_iommu_ops = {\n\t.domain_alloc = apple_dart_domain_alloc,\n\t.probe_device = apple_dart_probe_device,\n\t.release_device = apple_dart_release_device,\n\t.device_group = apple_dart_device_group,\n\t.of_xlate = apple_dart_of_xlate,\n\t.def_domain_type = apple_dart_def_domain_type,\n\t.get_resv_regions = apple_dart_get_resv_regions,\n\t.pgsize_bitmap = -1UL,  \n\t.owner = THIS_MODULE,\n\t.default_domain_ops = &(const struct iommu_domain_ops) {\n\t\t.attach_dev\t= apple_dart_attach_dev,\n\t\t.map_pages\t= apple_dart_map_pages,\n\t\t.unmap_pages\t= apple_dart_unmap_pages,\n\t\t.flush_iotlb_all = apple_dart_flush_iotlb_all,\n\t\t.iotlb_sync\t= apple_dart_iotlb_sync,\n\t\t.iotlb_sync_map\t= apple_dart_iotlb_sync_map,\n\t\t.iova_to_phys\t= apple_dart_iova_to_phys,\n\t\t.free\t\t= apple_dart_domain_free,\n\t}\n};\n\nstatic irqreturn_t apple_dart_t8020_irq(int irq, void *dev)\n{\n\tstruct apple_dart *dart = dev;\n\tconst char *fault_name = NULL;\n\tu32 error = readl(dart->regs + DART_T8020_ERROR);\n\tu32 error_code = FIELD_GET(DART_T8020_ERROR_CODE, error);\n\tu32 addr_lo = readl(dart->regs + DART_T8020_ERROR_ADDR_LO);\n\tu32 addr_hi = readl(dart->regs + DART_T8020_ERROR_ADDR_HI);\n\tu64 addr = addr_lo | (((u64)addr_hi) << 32);\n\tu8 stream_idx = FIELD_GET(DART_T8020_ERROR_STREAM, error);\n\n\tif (!(error & DART_T8020_ERROR_FLAG))\n\t\treturn IRQ_NONE;\n\n\t \n\tif (error_code == DART_T8020_ERROR_READ_FAULT)\n\t\tfault_name = \"READ FAULT\";\n\telse if (error_code == DART_T8020_ERROR_WRITE_FAULT)\n\t\tfault_name = \"WRITE FAULT\";\n\telse if (error_code == DART_T8020_ERROR_NO_PTE)\n\t\tfault_name = \"NO PTE FOR IOVA\";\n\telse if (error_code == DART_T8020_ERROR_NO_PMD)\n\t\tfault_name = \"NO PMD FOR IOVA\";\n\telse if (error_code == DART_T8020_ERROR_NO_TTBR)\n\t\tfault_name = \"NO TTBR FOR IOVA\";\n\telse\n\t\tfault_name = \"unknown\";\n\n\tdev_err_ratelimited(\n\t\tdart->dev,\n\t\t\"translation fault: status:0x%x stream:%d code:0x%x (%s) at 0x%llx\",\n\t\terror, stream_idx, error_code, fault_name, addr);\n\n\twritel(error, dart->regs + DART_T8020_ERROR);\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t apple_dart_t8110_irq(int irq, void *dev)\n{\n\tstruct apple_dart *dart = dev;\n\tconst char *fault_name = NULL;\n\tu32 error = readl(dart->regs + DART_T8110_ERROR);\n\tu32 error_code = FIELD_GET(DART_T8110_ERROR_CODE, error);\n\tu32 addr_lo = readl(dart->regs + DART_T8110_ERROR_ADDR_LO);\n\tu32 addr_hi = readl(dart->regs + DART_T8110_ERROR_ADDR_HI);\n\tu64 addr = addr_lo | (((u64)addr_hi) << 32);\n\tu8 stream_idx = FIELD_GET(DART_T8110_ERROR_STREAM, error);\n\n\tif (!(error & DART_T8110_ERROR_FLAG))\n\t\treturn IRQ_NONE;\n\n\t \n\tif (error_code == DART_T8110_ERROR_READ_FAULT)\n\t\tfault_name = \"READ FAULT\";\n\telse if (error_code == DART_T8110_ERROR_WRITE_FAULT)\n\t\tfault_name = \"WRITE FAULT\";\n\telse if (error_code == DART_T8110_ERROR_NO_PTE)\n\t\tfault_name = \"NO PTE FOR IOVA\";\n\telse if (error_code == DART_T8110_ERROR_NO_PMD)\n\t\tfault_name = \"NO PMD FOR IOVA\";\n\telse if (error_code == DART_T8110_ERROR_NO_PGD)\n\t\tfault_name = \"NO PGD FOR IOVA\";\n\telse if (error_code == DART_T8110_ERROR_NO_TTBR)\n\t\tfault_name = \"NO TTBR FOR IOVA\";\n\telse\n\t\tfault_name = \"unknown\";\n\n\tdev_err_ratelimited(\n\t\tdart->dev,\n\t\t\"translation fault: status:0x%x stream:%d code:0x%x (%s) at 0x%llx\",\n\t\terror, stream_idx, error_code, fault_name, addr);\n\n\twritel(error, dart->regs + DART_T8110_ERROR);\n\treturn IRQ_HANDLED;\n}\n\nstatic int apple_dart_probe(struct platform_device *pdev)\n{\n\tint ret;\n\tu32 dart_params[4];\n\tstruct resource *res;\n\tstruct apple_dart *dart;\n\tstruct device *dev = &pdev->dev;\n\n\tdart = devm_kzalloc(dev, sizeof(*dart), GFP_KERNEL);\n\tif (!dart)\n\t\treturn -ENOMEM;\n\n\tdart->dev = dev;\n\tdart->hw = of_device_get_match_data(dev);\n\tspin_lock_init(&dart->lock);\n\n\tdart->regs = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(dart->regs))\n\t\treturn PTR_ERR(dart->regs);\n\n\tif (resource_size(res) < 0x4000) {\n\t\tdev_err(dev, \"MMIO region too small (%pr)\\n\", res);\n\t\treturn -EINVAL;\n\t}\n\n\tdart->irq = platform_get_irq(pdev, 0);\n\tif (dart->irq < 0)\n\t\treturn -ENODEV;\n\n\tret = devm_clk_bulk_get_all(dev, &dart->clks);\n\tif (ret < 0)\n\t\treturn ret;\n\tdart->num_clks = ret;\n\n\tret = clk_bulk_prepare_enable(dart->num_clks, dart->clks);\n\tif (ret)\n\t\treturn ret;\n\n\tdart_params[0] = readl(dart->regs + DART_PARAMS1);\n\tdart_params[1] = readl(dart->regs + DART_PARAMS2);\n\tdart->pgsize = 1 << FIELD_GET(DART_PARAMS1_PAGE_SHIFT, dart_params[0]);\n\tdart->supports_bypass = dart_params[1] & DART_PARAMS2_BYPASS_SUPPORT;\n\n\tswitch (dart->hw->type) {\n\tcase DART_T8020:\n\tcase DART_T6000:\n\t\tdart->ias = 32;\n\t\tdart->oas = dart->hw->oas;\n\t\tdart->num_streams = dart->hw->max_sid_count;\n\t\tbreak;\n\n\tcase DART_T8110:\n\t\tdart_params[2] = readl(dart->regs + DART_T8110_PARAMS3);\n\t\tdart_params[3] = readl(dart->regs + DART_T8110_PARAMS4);\n\t\tdart->ias = FIELD_GET(DART_T8110_PARAMS3_VA_WIDTH, dart_params[2]);\n\t\tdart->oas = FIELD_GET(DART_T8110_PARAMS3_PA_WIDTH, dart_params[2]);\n\t\tdart->num_streams = FIELD_GET(DART_T8110_PARAMS4_NUM_SIDS, dart_params[3]);\n\t\tbreak;\n\t}\n\n\tif (dart->num_streams > DART_MAX_STREAMS) {\n\t\tdev_err(&pdev->dev, \"Too many streams (%d > %d)\\n\",\n\t\t\tdart->num_streams, DART_MAX_STREAMS);\n\t\tret = -EINVAL;\n\t\tgoto err_clk_disable;\n\t}\n\n\tdart->force_bypass = dart->pgsize > PAGE_SIZE;\n\n\tret = apple_dart_hw_reset(dart);\n\tif (ret)\n\t\tgoto err_clk_disable;\n\n\tret = request_irq(dart->irq, dart->hw->irq_handler, IRQF_SHARED,\n\t\t\t  \"apple-dart fault handler\", dart);\n\tif (ret)\n\t\tgoto err_clk_disable;\n\n\tplatform_set_drvdata(pdev, dart);\n\n\tret = iommu_device_sysfs_add(&dart->iommu, dev, NULL, \"apple-dart.%s\",\n\t\t\t\t     dev_name(&pdev->dev));\n\tif (ret)\n\t\tgoto err_free_irq;\n\n\tret = iommu_device_register(&dart->iommu, &apple_dart_iommu_ops, dev);\n\tif (ret)\n\t\tgoto err_sysfs_remove;\n\n\tdev_info(\n\t\t&pdev->dev,\n\t\t\"DART [pagesize %x, %d streams, bypass support: %d, bypass forced: %d] initialized\\n\",\n\t\tdart->pgsize, dart->num_streams, dart->supports_bypass, dart->force_bypass);\n\treturn 0;\n\nerr_sysfs_remove:\n\tiommu_device_sysfs_remove(&dart->iommu);\nerr_free_irq:\n\tfree_irq(dart->irq, dart);\nerr_clk_disable:\n\tclk_bulk_disable_unprepare(dart->num_clks, dart->clks);\n\n\treturn ret;\n}\n\nstatic void apple_dart_remove(struct platform_device *pdev)\n{\n\tstruct apple_dart *dart = platform_get_drvdata(pdev);\n\n\tapple_dart_hw_reset(dart);\n\tfree_irq(dart->irq, dart);\n\n\tiommu_device_unregister(&dart->iommu);\n\tiommu_device_sysfs_remove(&dart->iommu);\n\n\tclk_bulk_disable_unprepare(dart->num_clks, dart->clks);\n}\n\nstatic const struct apple_dart_hw apple_dart_hw_t8103 = {\n\t.type = DART_T8020,\n\t.irq_handler = apple_dart_t8020_irq,\n\t.invalidate_tlb = apple_dart_t8020_hw_invalidate_tlb,\n\t.oas = 36,\n\t.fmt = APPLE_DART,\n\t.max_sid_count = 16,\n\n\t.enable_streams = DART_T8020_STREAMS_ENABLE,\n\t.lock = DART_T8020_CONFIG,\n\t.lock_bit = DART_T8020_CONFIG_LOCK,\n\n\t.error = DART_T8020_ERROR,\n\n\t.tcr = DART_T8020_TCR,\n\t.tcr_enabled = DART_T8020_TCR_TRANSLATE_ENABLE,\n\t.tcr_disabled = 0,\n\t.tcr_bypass = DART_T8020_TCR_BYPASS_DAPF | DART_T8020_TCR_BYPASS_DART,\n\n\t.ttbr = DART_T8020_TTBR,\n\t.ttbr_valid = DART_T8020_TTBR_VALID,\n\t.ttbr_addr_field_shift = DART_T8020_TTBR_ADDR_FIELD_SHIFT,\n\t.ttbr_shift = DART_T8020_TTBR_SHIFT,\n\t.ttbr_count = 4,\n};\nstatic const struct apple_dart_hw apple_dart_hw_t6000 = {\n\t.type = DART_T6000,\n\t.irq_handler = apple_dart_t8020_irq,\n\t.invalidate_tlb = apple_dart_t8020_hw_invalidate_tlb,\n\t.oas = 42,\n\t.fmt = APPLE_DART2,\n\t.max_sid_count = 16,\n\n\t.enable_streams = DART_T8020_STREAMS_ENABLE,\n\t.lock = DART_T8020_CONFIG,\n\t.lock_bit = DART_T8020_CONFIG_LOCK,\n\n\t.error = DART_T8020_ERROR,\n\n\t.tcr = DART_T8020_TCR,\n\t.tcr_enabled = DART_T8020_TCR_TRANSLATE_ENABLE,\n\t.tcr_disabled = 0,\n\t.tcr_bypass = DART_T8020_TCR_BYPASS_DAPF | DART_T8020_TCR_BYPASS_DART,\n\n\t.ttbr = DART_T8020_TTBR,\n\t.ttbr_valid = DART_T8020_TTBR_VALID,\n\t.ttbr_addr_field_shift = DART_T8020_TTBR_ADDR_FIELD_SHIFT,\n\t.ttbr_shift = DART_T8020_TTBR_SHIFT,\n\t.ttbr_count = 4,\n};\n\nstatic const struct apple_dart_hw apple_dart_hw_t8110 = {\n\t.type = DART_T8110,\n\t.irq_handler = apple_dart_t8110_irq,\n\t.invalidate_tlb = apple_dart_t8110_hw_invalidate_tlb,\n\t.fmt = APPLE_DART2,\n\t.max_sid_count = 256,\n\n\t.enable_streams = DART_T8110_ENABLE_STREAMS,\n\t.lock = DART_T8110_PROTECT,\n\t.lock_bit = DART_T8110_PROTECT_TTBR_TCR,\n\n\t.error = DART_T8110_ERROR,\n\n\t.tcr = DART_T8110_TCR,\n\t.tcr_enabled = DART_T8110_TCR_TRANSLATE_ENABLE,\n\t.tcr_disabled = 0,\n\t.tcr_bypass = DART_T8110_TCR_BYPASS_DAPF | DART_T8110_TCR_BYPASS_DART,\n\n\t.ttbr = DART_T8110_TTBR,\n\t.ttbr_valid = DART_T8110_TTBR_VALID,\n\t.ttbr_addr_field_shift = DART_T8110_TTBR_ADDR_FIELD_SHIFT,\n\t.ttbr_shift = DART_T8110_TTBR_SHIFT,\n\t.ttbr_count = 1,\n};\n\nstatic __maybe_unused int apple_dart_suspend(struct device *dev)\n{\n\tstruct apple_dart *dart = dev_get_drvdata(dev);\n\tunsigned int sid, idx;\n\n\tfor (sid = 0; sid < dart->num_streams; sid++) {\n\t\tdart->save_tcr[sid] = readl_relaxed(dart->regs + DART_TCR(dart, sid));\n\t\tfor (idx = 0; idx < dart->hw->ttbr_count; idx++)\n\t\t\tdart->save_ttbr[sid][idx] =\n\t\t\t\treadl(dart->regs + DART_TTBR(dart, sid, idx));\n\t}\n\n\treturn 0;\n}\n\nstatic __maybe_unused int apple_dart_resume(struct device *dev)\n{\n\tstruct apple_dart *dart = dev_get_drvdata(dev);\n\tunsigned int sid, idx;\n\tint ret;\n\n\tret = apple_dart_hw_reset(dart);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to reset DART on resume\\n\");\n\t\treturn ret;\n\t}\n\n\tfor (sid = 0; sid < dart->num_streams; sid++) {\n\t\tfor (idx = 0; idx < dart->hw->ttbr_count; idx++)\n\t\t\twritel(dart->save_ttbr[sid][idx],\n\t\t\t       dart->regs + DART_TTBR(dart, sid, idx));\n\t\twritel(dart->save_tcr[sid], dart->regs + DART_TCR(dart, sid));\n\t}\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(apple_dart_pm_ops, apple_dart_suspend, apple_dart_resume);\n\nstatic const struct of_device_id apple_dart_of_match[] = {\n\t{ .compatible = \"apple,t8103-dart\", .data = &apple_dart_hw_t8103 },\n\t{ .compatible = \"apple,t8110-dart\", .data = &apple_dart_hw_t8110 },\n\t{ .compatible = \"apple,t6000-dart\", .data = &apple_dart_hw_t6000 },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, apple_dart_of_match);\n\nstatic struct platform_driver apple_dart_driver = {\n\t.driver\t= {\n\t\t.name\t\t\t= \"apple-dart\",\n\t\t.of_match_table\t\t= apple_dart_of_match,\n\t\t.suppress_bind_attrs    = true,\n\t\t.pm\t\t\t= pm_sleep_ptr(&apple_dart_pm_ops),\n\t},\n\t.probe\t= apple_dart_probe,\n\t.remove_new = apple_dart_remove,\n};\n\nmodule_platform_driver(apple_dart_driver);\n\nMODULE_DESCRIPTION(\"IOMMU API for Apple's DART\");\nMODULE_AUTHOR(\"Sven Peter <sven@svenpeter.dev>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}