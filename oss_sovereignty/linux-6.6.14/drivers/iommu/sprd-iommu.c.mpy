{
  "module_name": "sprd-iommu.c",
  "hash_id": "722367e1f2be0a6a533d6d2ff6a9e94bed9a47250b9b11a3b1c64e4348bcbe5d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iommu/sprd-iommu.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/errno.h>\n#include <linux/iommu.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n#define SPRD_IOMMU_PAGE_SHIFT\t12\n#define SPRD_IOMMU_PAGE_SIZE\tSZ_4K\n\n#define SPRD_EX_CFG\t\t0x0\n#define SPRD_IOMMU_VAOR_BYPASS\tBIT(4)\n#define SPRD_IOMMU_GATE_EN\tBIT(1)\n#define SPRD_IOMMU_EN\t\tBIT(0)\n#define SPRD_EX_UPDATE\t\t0x4\n#define SPRD_EX_FIRST_VPN\t0x8\n#define SPRD_EX_VPN_RANGE\t0xc\n#define SPRD_EX_FIRST_PPN\t0x10\n#define SPRD_EX_DEFAULT_PPN\t0x14\n\n#define SPRD_IOMMU_VERSION\t0x0\n#define SPRD_VERSION_MASK\tGENMASK(15, 8)\n#define SPRD_VERSION_SHIFT\t0x8\n#define SPRD_VAU_CFG\t\t0x4\n#define SPRD_VAU_UPDATE\t\t0x8\n#define SPRD_VAU_AUTH_CFG\t0xc\n#define SPRD_VAU_FIRST_PPN\t0x10\n#define SPRD_VAU_DEFAULT_PPN_RD\t0x14\n#define SPRD_VAU_DEFAULT_PPN_WR\t0x18\n#define SPRD_VAU_FIRST_VPN\t0x1c\n#define SPRD_VAU_VPN_RANGE\t0x20\n\nenum sprd_iommu_version {\n\tSPRD_IOMMU_EX,\n\tSPRD_IOMMU_VAU,\n};\n\n \nstruct sprd_iommu_device {\n\tstruct sprd_iommu_domain\t*dom;\n\tenum sprd_iommu_version\tver;\n\tu32\t\t\t*prot_page_va;\n\tdma_addr_t\t\tprot_page_pa;\n\tvoid __iomem\t\t*base;\n\tstruct device\t\t*dev;\n\tstruct iommu_device\tiommu;\n\tstruct iommu_group\t*group;\n\tstruct clk\t\t*eb;\n};\n\nstruct sprd_iommu_domain {\n\tspinlock_t\t\tpgtlock;  \n\tstruct iommu_domain\tdomain;\n\tu32\t\t\t*pgt_va;  \n\tdma_addr_t\t\tpgt_pa;  \n\tstruct sprd_iommu_device\t*sdev;\n};\n\nstatic const struct iommu_ops sprd_iommu_ops;\n\nstatic struct sprd_iommu_domain *to_sprd_domain(struct iommu_domain *dom)\n{\n\treturn container_of(dom, struct sprd_iommu_domain, domain);\n}\n\nstatic inline void\nsprd_iommu_write(struct sprd_iommu_device *sdev, unsigned int reg, u32 val)\n{\n\twritel_relaxed(val, sdev->base + reg);\n}\n\nstatic inline u32\nsprd_iommu_read(struct sprd_iommu_device *sdev, unsigned int reg)\n{\n\treturn readl_relaxed(sdev->base + reg);\n}\n\nstatic inline void\nsprd_iommu_update_bits(struct sprd_iommu_device *sdev, unsigned int reg,\n\t\t  u32 mask, u32 shift, u32 val)\n{\n\tu32 t = sprd_iommu_read(sdev, reg);\n\n\tt = (t & (~(mask << shift))) | ((val & mask) << shift);\n\tsprd_iommu_write(sdev, reg, t);\n}\n\nstatic inline int\nsprd_iommu_get_version(struct sprd_iommu_device *sdev)\n{\n\tint ver = (sprd_iommu_read(sdev, SPRD_IOMMU_VERSION) &\n\t\t   SPRD_VERSION_MASK) >> SPRD_VERSION_SHIFT;\n\n\tswitch (ver) {\n\tcase SPRD_IOMMU_EX:\n\tcase SPRD_IOMMU_VAU:\n\t\treturn ver;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic size_t\nsprd_iommu_pgt_size(struct iommu_domain *domain)\n{\n\treturn ((domain->geometry.aperture_end -\n\t\t domain->geometry.aperture_start + 1) >>\n\t\tSPRD_IOMMU_PAGE_SHIFT) * sizeof(u32);\n}\n\nstatic struct iommu_domain *sprd_iommu_domain_alloc(unsigned int domain_type)\n{\n\tstruct sprd_iommu_domain *dom;\n\n\tif (domain_type != IOMMU_DOMAIN_DMA && domain_type != IOMMU_DOMAIN_UNMANAGED)\n\t\treturn NULL;\n\n\tdom = kzalloc(sizeof(*dom), GFP_KERNEL);\n\tif (!dom)\n\t\treturn NULL;\n\n\tspin_lock_init(&dom->pgtlock);\n\n\tdom->domain.geometry.aperture_start = 0;\n\tdom->domain.geometry.aperture_end = SZ_256M - 1;\n\tdom->domain.geometry.force_aperture = true;\n\n\treturn &dom->domain;\n}\n\nstatic void sprd_iommu_first_vpn(struct sprd_iommu_domain *dom)\n{\n\tstruct sprd_iommu_device *sdev = dom->sdev;\n\tu32 val;\n\tunsigned int reg;\n\n\tif (sdev->ver == SPRD_IOMMU_EX)\n\t\treg = SPRD_EX_FIRST_VPN;\n\telse\n\t\treg = SPRD_VAU_FIRST_VPN;\n\n\tval = dom->domain.geometry.aperture_start >> SPRD_IOMMU_PAGE_SHIFT;\n\tsprd_iommu_write(sdev, reg, val);\n}\n\nstatic void sprd_iommu_vpn_range(struct sprd_iommu_domain *dom)\n{\n\tstruct sprd_iommu_device *sdev = dom->sdev;\n\tu32 val;\n\tunsigned int reg;\n\n\tif (sdev->ver == SPRD_IOMMU_EX)\n\t\treg = SPRD_EX_VPN_RANGE;\n\telse\n\t\treg = SPRD_VAU_VPN_RANGE;\n\n\tval = (dom->domain.geometry.aperture_end -\n\t       dom->domain.geometry.aperture_start) >> SPRD_IOMMU_PAGE_SHIFT;\n\tsprd_iommu_write(sdev, reg, val);\n}\n\nstatic void sprd_iommu_first_ppn(struct sprd_iommu_domain *dom)\n{\n\tu32 val = dom->pgt_pa >> SPRD_IOMMU_PAGE_SHIFT;\n\tstruct sprd_iommu_device *sdev = dom->sdev;\n\tunsigned int reg;\n\n\tif (sdev->ver == SPRD_IOMMU_EX)\n\t\treg = SPRD_EX_FIRST_PPN;\n\telse\n\t\treg = SPRD_VAU_FIRST_PPN;\n\n\tsprd_iommu_write(sdev, reg, val);\n}\n\nstatic void sprd_iommu_default_ppn(struct sprd_iommu_device *sdev)\n{\n\tu32 val = sdev->prot_page_pa >> SPRD_IOMMU_PAGE_SHIFT;\n\n\tif (sdev->ver == SPRD_IOMMU_EX) {\n\t\tsprd_iommu_write(sdev, SPRD_EX_DEFAULT_PPN, val);\n\t} else if (sdev->ver == SPRD_IOMMU_VAU) {\n\t\tsprd_iommu_write(sdev, SPRD_VAU_DEFAULT_PPN_RD, val);\n\t\tsprd_iommu_write(sdev, SPRD_VAU_DEFAULT_PPN_WR, val);\n\t}\n}\n\nstatic void sprd_iommu_hw_en(struct sprd_iommu_device *sdev, bool en)\n{\n\tunsigned int reg_cfg;\n\tu32 mask, val;\n\n\tif (sdev->ver == SPRD_IOMMU_EX)\n\t\treg_cfg = SPRD_EX_CFG;\n\telse\n\t\treg_cfg = SPRD_VAU_CFG;\n\n\tmask = SPRD_IOMMU_EN | SPRD_IOMMU_GATE_EN;\n\tval = en ? mask : 0;\n\tsprd_iommu_update_bits(sdev, reg_cfg, mask, 0, val);\n}\n\nstatic void sprd_iommu_cleanup(struct sprd_iommu_domain *dom)\n{\n\tsize_t pgt_size;\n\n\t \n\tif (!dom->sdev)\n\t\treturn;\n\n\tpgt_size = sprd_iommu_pgt_size(&dom->domain);\n\tdma_free_coherent(dom->sdev->dev, pgt_size, dom->pgt_va, dom->pgt_pa);\n\tdom->sdev = NULL;\n\tsprd_iommu_hw_en(dom->sdev, false);\n}\n\nstatic void sprd_iommu_domain_free(struct iommu_domain *domain)\n{\n\tstruct sprd_iommu_domain *dom = to_sprd_domain(domain);\n\n\tsprd_iommu_cleanup(dom);\n\tkfree(dom);\n}\n\nstatic int sprd_iommu_attach_device(struct iommu_domain *domain,\n\t\t\t\t    struct device *dev)\n{\n\tstruct sprd_iommu_device *sdev = dev_iommu_priv_get(dev);\n\tstruct sprd_iommu_domain *dom = to_sprd_domain(domain);\n\tsize_t pgt_size = sprd_iommu_pgt_size(domain);\n\n\t \n\tif (sdev->dom == dom)\n\t\treturn 0;\n\n\t \n\tif (!dom->pgt_va) {\n\t\tdom->pgt_va = dma_alloc_coherent(sdev->dev, pgt_size, &dom->pgt_pa, GFP_KERNEL);\n\t\tif (!dom->pgt_va)\n\t\t\treturn -ENOMEM;\n\n\t\tdom->sdev = sdev;\n\t}\n\n\tsdev->dom = dom;\n\n\t \n\tsprd_iommu_hw_en(sdev, false);\n\tsprd_iommu_first_ppn(dom);\n\tsprd_iommu_first_vpn(dom);\n\tsprd_iommu_vpn_range(dom);\n\tsprd_iommu_default_ppn(sdev);\n\tsprd_iommu_hw_en(sdev, true);\n\n\treturn 0;\n}\n\nstatic int sprd_iommu_map(struct iommu_domain *domain, unsigned long iova,\n\t\t\t  phys_addr_t paddr, size_t pgsize, size_t pgcount,\n\t\t\t  int prot, gfp_t gfp, size_t *mapped)\n{\n\tstruct sprd_iommu_domain *dom = to_sprd_domain(domain);\n\tsize_t size = pgcount * SPRD_IOMMU_PAGE_SIZE;\n\tunsigned long flags;\n\tunsigned int i;\n\tu32 *pgt_base_iova;\n\tu32 pabase = (u32)paddr;\n\tunsigned long start = domain->geometry.aperture_start;\n\tunsigned long end = domain->geometry.aperture_end;\n\n\tif (!dom->sdev) {\n\t\tpr_err(\"No sprd_iommu_device attached to the domain\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (iova < start || (iova + size) > (end + 1)) {\n\t\tdev_err(dom->sdev->dev, \"(iova(0x%lx) + size(%zx)) are not in the range!\\n\",\n\t\t\tiova, size);\n\t\treturn -EINVAL;\n\t}\n\n\tpgt_base_iova = dom->pgt_va + ((iova - start) >> SPRD_IOMMU_PAGE_SHIFT);\n\n\tspin_lock_irqsave(&dom->pgtlock, flags);\n\tfor (i = 0; i < pgcount; i++) {\n\t\tpgt_base_iova[i] = pabase >> SPRD_IOMMU_PAGE_SHIFT;\n\t\tpabase += SPRD_IOMMU_PAGE_SIZE;\n\t}\n\tspin_unlock_irqrestore(&dom->pgtlock, flags);\n\n\t*mapped = size;\n\treturn 0;\n}\n\nstatic size_t sprd_iommu_unmap(struct iommu_domain *domain, unsigned long iova,\n\t\t\t       size_t pgsize, size_t pgcount,\n\t\t\t       struct iommu_iotlb_gather *iotlb_gather)\n{\n\tstruct sprd_iommu_domain *dom = to_sprd_domain(domain);\n\tunsigned long flags;\n\tu32 *pgt_base_iova;\n\tsize_t size = pgcount * SPRD_IOMMU_PAGE_SIZE;\n\tunsigned long start = domain->geometry.aperture_start;\n\tunsigned long end = domain->geometry.aperture_end;\n\n\tif (iova < start || (iova + size) > (end + 1))\n\t\treturn 0;\n\n\tpgt_base_iova = dom->pgt_va + ((iova - start) >> SPRD_IOMMU_PAGE_SHIFT);\n\n\tspin_lock_irqsave(&dom->pgtlock, flags);\n\tmemset(pgt_base_iova, 0, pgcount * sizeof(u32));\n\tspin_unlock_irqrestore(&dom->pgtlock, flags);\n\n\treturn size;\n}\n\nstatic void sprd_iommu_sync_map(struct iommu_domain *domain,\n\t\t\t\tunsigned long iova, size_t size)\n{\n\tstruct sprd_iommu_domain *dom = to_sprd_domain(domain);\n\tunsigned int reg;\n\n\tif (dom->sdev->ver == SPRD_IOMMU_EX)\n\t\treg = SPRD_EX_UPDATE;\n\telse\n\t\treg = SPRD_VAU_UPDATE;\n\n\t \n\tsprd_iommu_write(dom->sdev, reg, 0xffffffff);\n}\n\nstatic void sprd_iommu_sync(struct iommu_domain *domain,\n\t\t\t    struct iommu_iotlb_gather *iotlb_gather)\n{\n\tsprd_iommu_sync_map(domain, 0, 0);\n}\n\nstatic phys_addr_t sprd_iommu_iova_to_phys(struct iommu_domain *domain,\n\t\t\t\t\t   dma_addr_t iova)\n{\n\tstruct sprd_iommu_domain *dom = to_sprd_domain(domain);\n\tunsigned long flags;\n\tphys_addr_t pa;\n\tunsigned long start = domain->geometry.aperture_start;\n\tunsigned long end = domain->geometry.aperture_end;\n\n\tif (WARN_ON(iova < start || iova > end))\n\t\treturn 0;\n\n\tspin_lock_irqsave(&dom->pgtlock, flags);\n\tpa = *(dom->pgt_va + ((iova - start) >> SPRD_IOMMU_PAGE_SHIFT));\n\tpa = (pa << SPRD_IOMMU_PAGE_SHIFT) + ((iova - start) & (SPRD_IOMMU_PAGE_SIZE - 1));\n\tspin_unlock_irqrestore(&dom->pgtlock, flags);\n\n\treturn pa;\n}\n\nstatic struct iommu_device *sprd_iommu_probe_device(struct device *dev)\n{\n\tstruct iommu_fwspec *fwspec = dev_iommu_fwspec_get(dev);\n\tstruct sprd_iommu_device *sdev;\n\n\tif (!fwspec || fwspec->ops != &sprd_iommu_ops)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tsdev = dev_iommu_priv_get(dev);\n\n\treturn &sdev->iommu;\n}\n\nstatic struct iommu_group *sprd_iommu_device_group(struct device *dev)\n{\n\tstruct sprd_iommu_device *sdev = dev_iommu_priv_get(dev);\n\n\treturn iommu_group_ref_get(sdev->group);\n}\n\nstatic int sprd_iommu_of_xlate(struct device *dev, struct of_phandle_args *args)\n{\n\tstruct platform_device *pdev;\n\n\tif (!dev_iommu_priv_get(dev)) {\n\t\tpdev = of_find_device_by_node(args->np);\n\t\tdev_iommu_priv_set(dev, platform_get_drvdata(pdev));\n\t\tplatform_device_put(pdev);\n\t}\n\n\treturn 0;\n}\n\n\nstatic const struct iommu_ops sprd_iommu_ops = {\n\t.domain_alloc\t= sprd_iommu_domain_alloc,\n\t.probe_device\t= sprd_iommu_probe_device,\n\t.device_group\t= sprd_iommu_device_group,\n\t.of_xlate\t= sprd_iommu_of_xlate,\n\t.pgsize_bitmap\t= SPRD_IOMMU_PAGE_SIZE,\n\t.owner\t\t= THIS_MODULE,\n\t.default_domain_ops = &(const struct iommu_domain_ops) {\n\t\t.attach_dev\t= sprd_iommu_attach_device,\n\t\t.map_pages\t= sprd_iommu_map,\n\t\t.unmap_pages\t= sprd_iommu_unmap,\n\t\t.iotlb_sync_map\t= sprd_iommu_sync_map,\n\t\t.iotlb_sync\t= sprd_iommu_sync,\n\t\t.iova_to_phys\t= sprd_iommu_iova_to_phys,\n\t\t.free\t\t= sprd_iommu_domain_free,\n\t}\n};\n\nstatic const struct of_device_id sprd_iommu_of_match[] = {\n\t{ .compatible = \"sprd,iommu-v1\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, sprd_iommu_of_match);\n\n \nstatic int sprd_iommu_clk_enable(struct sprd_iommu_device *sdev)\n{\n\tstruct clk *eb;\n\n\teb = devm_clk_get_optional(sdev->dev, NULL);\n\tif (!eb)\n\t\treturn 0;\n\n\tif (IS_ERR(eb))\n\t\treturn PTR_ERR(eb);\n\n\tsdev->eb = eb;\n\treturn clk_prepare_enable(eb);\n}\n\nstatic void sprd_iommu_clk_disable(struct sprd_iommu_device *sdev)\n{\n\tif (sdev->eb)\n\t\tclk_disable_unprepare(sdev->eb);\n}\n\nstatic int sprd_iommu_probe(struct platform_device *pdev)\n{\n\tstruct sprd_iommu_device *sdev;\n\tstruct device *dev = &pdev->dev;\n\tvoid __iomem *base;\n\tint ret;\n\n\tsdev = devm_kzalloc(dev, sizeof(*sdev), GFP_KERNEL);\n\tif (!sdev)\n\t\treturn -ENOMEM;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base)) {\n\t\tdev_err(dev, \"Failed to get ioremap resource.\\n\");\n\t\treturn PTR_ERR(base);\n\t}\n\tsdev->base = base;\n\n\tsdev->prot_page_va = dma_alloc_coherent(dev, SPRD_IOMMU_PAGE_SIZE,\n\t\t\t\t\t\t&sdev->prot_page_pa, GFP_KERNEL);\n\tif (!sdev->prot_page_va)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, sdev);\n\tsdev->dev = dev;\n\n\t \n\tsdev->group = iommu_group_alloc();\n\tif (IS_ERR(sdev->group)) {\n\t\tret = PTR_ERR(sdev->group);\n\t\tgoto free_page;\n\t}\n\n\tret = iommu_device_sysfs_add(&sdev->iommu, dev, NULL, dev_name(dev));\n\tif (ret)\n\t\tgoto put_group;\n\n\tret = iommu_device_register(&sdev->iommu, &sprd_iommu_ops, dev);\n\tif (ret)\n\t\tgoto remove_sysfs;\n\n\tret = sprd_iommu_clk_enable(sdev);\n\tif (ret)\n\t\tgoto unregister_iommu;\n\n\tret = sprd_iommu_get_version(sdev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"IOMMU version(%d) is invalid.\\n\", ret);\n\t\tgoto disable_clk;\n\t}\n\tsdev->ver = ret;\n\n\treturn 0;\n\ndisable_clk:\n\tsprd_iommu_clk_disable(sdev);\nunregister_iommu:\n\tiommu_device_unregister(&sdev->iommu);\nremove_sysfs:\n\tiommu_device_sysfs_remove(&sdev->iommu);\nput_group:\n\tiommu_group_put(sdev->group);\nfree_page:\n\tdma_free_coherent(sdev->dev, SPRD_IOMMU_PAGE_SIZE, sdev->prot_page_va, sdev->prot_page_pa);\n\treturn ret;\n}\n\nstatic void sprd_iommu_remove(struct platform_device *pdev)\n{\n\tstruct sprd_iommu_device *sdev = platform_get_drvdata(pdev);\n\n\tdma_free_coherent(sdev->dev, SPRD_IOMMU_PAGE_SIZE, sdev->prot_page_va, sdev->prot_page_pa);\n\n\tiommu_group_put(sdev->group);\n\tsdev->group = NULL;\n\n\tplatform_set_drvdata(pdev, NULL);\n\tiommu_device_sysfs_remove(&sdev->iommu);\n\tiommu_device_unregister(&sdev->iommu);\n}\n\nstatic struct platform_driver sprd_iommu_driver = {\n\t.driver\t= {\n\t\t.name\t\t= \"sprd-iommu\",\n\t\t.of_match_table\t= sprd_iommu_of_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe\t= sprd_iommu_probe,\n\t.remove_new = sprd_iommu_remove,\n};\nmodule_platform_driver(sprd_iommu_driver);\n\nMODULE_DESCRIPTION(\"IOMMU driver for Unisoc SoCs\");\nMODULE_ALIAS(\"platform:sprd-iommu\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}