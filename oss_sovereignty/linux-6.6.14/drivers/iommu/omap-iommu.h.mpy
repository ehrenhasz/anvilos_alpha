{
  "module_name": "omap-iommu.h",
  "hash_id": "fa7467bbb228c6a22a05b77423cca64af17d772620eacf0bfd8e69a09977824d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iommu/omap-iommu.h",
  "human_readable_source": " \n \n\n#ifndef _OMAP_IOMMU_H\n#define _OMAP_IOMMU_H\n\n#include <linux/bitops.h>\n#include <linux/iommu.h>\n\n#define for_each_iotlb_cr(obj, n, __i, cr)\t\t\t\t\\\n\tfor (__i = 0;\t\t\t\t\t\t\t\\\n\t     (__i < (n)) && (cr = __iotlb_read_cr((obj), __i), true);\t\\\n\t     __i++)\n\nstruct iotlb_entry {\n\tu32 da;\n\tu32 pa;\n\tu32 pgsz, prsvd, valid;\n\tu32 endian, elsz, mixed;\n};\n\n \nstruct omap_iommu_device {\n\tu32 *pgtable;\n\tstruct omap_iommu *iommu_dev;\n};\n\n \nstruct omap_iommu_domain {\n\tu32 num_iommus;\n\tstruct omap_iommu_device *iommus;\n\tstruct device *dev;\n\tspinlock_t lock;\n\tstruct iommu_domain domain;\n};\n\nstruct omap_iommu {\n\tconst char\t*name;\n\tvoid __iomem\t*regbase;\n\tstruct regmap\t*syscfg;\n\tstruct device\t*dev;\n\tstruct iommu_domain *domain;\n\tstruct dentry\t*debug_dir;\n\n\tspinlock_t\tiommu_lock;\t \n\n\t \n\tu32\t\t*iopgd;\n\tspinlock_t\tpage_table_lock;  \n\tdma_addr_t\tpd_dma;\n\n\tint\t\tnr_tlb_entries;\n\n\tvoid *ctx;  \n\n\tstruct cr_regs *cr_ctx;\n\tu32 num_cr_ctx;\n\n\tint has_bus_err_back;\n\tu32 id;\n\n\tstruct iommu_device iommu;\n\tstruct iommu_group *group;\n\n\tu8 pwrst;\n};\n\n \nstruct omap_iommu_arch_data {\n\tstruct omap_iommu *iommu_dev;\n\tstruct device *dev;\n};\n\nstruct cr_regs {\n\tu32 cam;\n\tu32 ram;\n};\n\nstruct iotlb_lock {\n\tshort base;\n\tshort vict;\n};\n\n \n#define MMU_REVISION\t\t0x00\n#define MMU_IRQSTATUS\t\t0x18\n#define MMU_IRQENABLE\t\t0x1c\n#define MMU_WALKING_ST\t\t0x40\n#define MMU_CNTL\t\t0x44\n#define MMU_FAULT_AD\t\t0x48\n#define MMU_TTB\t\t\t0x4c\n#define MMU_LOCK\t\t0x50\n#define MMU_LD_TLB\t\t0x54\n#define MMU_CAM\t\t\t0x58\n#define MMU_RAM\t\t\t0x5c\n#define MMU_GFLUSH\t\t0x60\n#define MMU_FLUSH_ENTRY\t\t0x64\n#define MMU_READ_CAM\t\t0x68\n#define MMU_READ_RAM\t\t0x6c\n#define MMU_EMU_FAULT_AD\t0x70\n#define MMU_GP_REG\t\t0x88\n\n#define MMU_REG_SIZE\t\t256\n\n \n \n#define MMU_IRQ_MULTIHITFAULT\tBIT(4)\n#define MMU_IRQ_TABLEWALKFAULT\tBIT(3)\n#define MMU_IRQ_EMUMISS\t\tBIT(2)\n#define MMU_IRQ_TRANSLATIONFAULT\tBIT(1)\n#define MMU_IRQ_TLBMISS\t\tBIT(0)\n\n#define __MMU_IRQ_FAULT\t\t\\\n\t(MMU_IRQ_MULTIHITFAULT | MMU_IRQ_EMUMISS | MMU_IRQ_TRANSLATIONFAULT)\n#define MMU_IRQ_MASK\t\t\\\n\t(__MMU_IRQ_FAULT | MMU_IRQ_TABLEWALKFAULT | MMU_IRQ_TLBMISS)\n#define MMU_IRQ_TWL_MASK\t(__MMU_IRQ_FAULT | MMU_IRQ_TABLEWALKFAULT)\n#define MMU_IRQ_TLB_MISS_MASK\t(__MMU_IRQ_FAULT | MMU_IRQ_TLBMISS)\n\n \n#define MMU_CNTL_SHIFT\t\t1\n#define MMU_CNTL_MASK\t\t(7 << MMU_CNTL_SHIFT)\n#define MMU_CNTL_EML_TLB\tBIT(3)\n#define MMU_CNTL_TWL_EN\t\tBIT(2)\n#define MMU_CNTL_MMU_EN\t\tBIT(1)\n\n \n#define MMU_CAM_VATAG_SHIFT\t12\n#define MMU_CAM_VATAG_MASK \\\n\t((~0UL >> MMU_CAM_VATAG_SHIFT) << MMU_CAM_VATAG_SHIFT)\n#define MMU_CAM_P\t\tBIT(3)\n#define MMU_CAM_V\t\tBIT(2)\n#define MMU_CAM_PGSZ_MASK\t3\n#define MMU_CAM_PGSZ_1M\t\t(0 << 0)\n#define MMU_CAM_PGSZ_64K\t(1 << 0)\n#define MMU_CAM_PGSZ_4K\t\t(2 << 0)\n#define MMU_CAM_PGSZ_16M\t(3 << 0)\n\n \n#define MMU_RAM_PADDR_SHIFT\t12\n#define MMU_RAM_PADDR_MASK \\\n\t((~0UL >> MMU_RAM_PADDR_SHIFT) << MMU_RAM_PADDR_SHIFT)\n\n#define MMU_RAM_ENDIAN_SHIFT\t9\n#define MMU_RAM_ENDIAN_MASK\tBIT(MMU_RAM_ENDIAN_SHIFT)\n#define MMU_RAM_ENDIAN_LITTLE\t(0 << MMU_RAM_ENDIAN_SHIFT)\n#define MMU_RAM_ENDIAN_BIG\tBIT(MMU_RAM_ENDIAN_SHIFT)\n\n#define MMU_RAM_ELSZ_SHIFT\t7\n#define MMU_RAM_ELSZ_MASK\t(3 << MMU_RAM_ELSZ_SHIFT)\n#define MMU_RAM_ELSZ_8\t\t(0 << MMU_RAM_ELSZ_SHIFT)\n#define MMU_RAM_ELSZ_16\t\t(1 << MMU_RAM_ELSZ_SHIFT)\n#define MMU_RAM_ELSZ_32\t\t(2 << MMU_RAM_ELSZ_SHIFT)\n#define MMU_RAM_ELSZ_NONE\t(3 << MMU_RAM_ELSZ_SHIFT)\n#define MMU_RAM_MIXED_SHIFT\t6\n#define MMU_RAM_MIXED_MASK\tBIT(MMU_RAM_MIXED_SHIFT)\n#define MMU_RAM_MIXED\t\tMMU_RAM_MIXED_MASK\n\n#define MMU_GP_REG_BUS_ERR_BACK_EN\t0x1\n\n#define get_cam_va_mask(pgsz)\t\t\t\t\\\n\t(((pgsz) == MMU_CAM_PGSZ_16M) ? 0xff000000 :\t\\\n\t ((pgsz) == MMU_CAM_PGSZ_1M)  ? 0xfff00000 :\t\\\n\t ((pgsz) == MMU_CAM_PGSZ_64K) ? 0xffff0000 :\t\\\n\t ((pgsz) == MMU_CAM_PGSZ_4K)  ? 0xfffff000 : 0)\n\n \n#define DSP_SYS_REVISION\t\t0x00\n#define DSP_SYS_MMU_CONFIG\t\t0x18\n#define DSP_SYS_MMU_CONFIG_EN_SHIFT\t4\n\n \n\n#define iopgsz_max(bytes)\t\t\t\\\n\t(((bytes) >= SZ_16M) ? SZ_16M :\t\t\\\n\t ((bytes) >= SZ_1M)  ? SZ_1M  :\t\t\\\n\t ((bytes) >= SZ_64K) ? SZ_64K :\t\t\\\n\t ((bytes) >= SZ_4K)  ? SZ_4K  :\t0)\n\n#define bytes_to_iopgsz(bytes)\t\t\t\t\\\n\t(((bytes) == SZ_16M) ? MMU_CAM_PGSZ_16M :\t\\\n\t ((bytes) == SZ_1M)  ? MMU_CAM_PGSZ_1M  :\t\\\n\t ((bytes) == SZ_64K) ? MMU_CAM_PGSZ_64K :\t\\\n\t ((bytes) == SZ_4K)  ? MMU_CAM_PGSZ_4K  : -1)\n\n#define iopgsz_to_bytes(iopgsz)\t\t\t\t\\\n\t(((iopgsz) == MMU_CAM_PGSZ_16M)\t? SZ_16M :\t\\\n\t ((iopgsz) == MMU_CAM_PGSZ_1M)\t? SZ_1M  :\t\\\n\t ((iopgsz) == MMU_CAM_PGSZ_64K)\t? SZ_64K :\t\\\n\t ((iopgsz) == MMU_CAM_PGSZ_4K)\t? SZ_4K  : 0)\n\n#define iopgsz_ok(bytes) (bytes_to_iopgsz(bytes) >= 0)\n\n \n\nstruct cr_regs __iotlb_read_cr(struct omap_iommu *obj, int n);\nvoid iotlb_lock_get(struct omap_iommu *obj, struct iotlb_lock *l);\nvoid iotlb_lock_set(struct omap_iommu *obj, struct iotlb_lock *l);\n\n#ifdef CONFIG_OMAP_IOMMU_DEBUG\nvoid omap_iommu_debugfs_init(void);\nvoid omap_iommu_debugfs_exit(void);\n\nvoid omap_iommu_debugfs_add(struct omap_iommu *obj);\nvoid omap_iommu_debugfs_remove(struct omap_iommu *obj);\n#else\nstatic inline void omap_iommu_debugfs_init(void) { }\nstatic inline void omap_iommu_debugfs_exit(void) { }\n\nstatic inline void omap_iommu_debugfs_add(struct omap_iommu *obj) { }\nstatic inline void omap_iommu_debugfs_remove(struct omap_iommu *obj) { }\n#endif\n\n \nstatic inline u32 iommu_read_reg(struct omap_iommu *obj, size_t offs)\n{\n\treturn __raw_readl(obj->regbase + offs);\n}\n\nstatic inline void iommu_write_reg(struct omap_iommu *obj, u32 val, size_t offs)\n{\n\t__raw_writel(val, obj->regbase + offs);\n}\n\nstatic inline int iotlb_cr_valid(struct cr_regs *cr)\n{\n\tif (!cr)\n\t\treturn -EINVAL;\n\n\treturn cr->cam & MMU_CAM_V;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}