{
  "module_name": "hyperv-iommu.c",
  "hash_id": "3282ce186a3f7464272e9ffb85dbde58e72f35a5fd4bda708600687499589349",
  "original_prompt": "Ingested from linux-6.6.14/drivers/iommu/hyperv-iommu.c",
  "human_readable_source": "\n\n \n\n#include <linux/types.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/iommu.h>\n#include <linux/module.h>\n\n#include <asm/apic.h>\n#include <asm/cpu.h>\n#include <asm/hw_irq.h>\n#include <asm/io_apic.h>\n#include <asm/irq_remapping.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n\n#include \"irq_remapping.h\"\n\n#ifdef CONFIG_IRQ_REMAP\n\n \n#define IOAPIC_REMAPPING_ENTRY 24\n\nstatic cpumask_t ioapic_max_cpumask = { CPU_BITS_NONE };\nstatic struct irq_domain *ioapic_ir_domain;\n\nstatic int hyperv_ir_set_affinity(struct irq_data *data,\n\t\tconst struct cpumask *mask, bool force)\n{\n\tstruct irq_data *parent = data->parent_data;\n\tstruct irq_cfg *cfg = irqd_cfg(data);\n\tint ret;\n\n\t \n\tif (!cpumask_subset(mask, &ioapic_max_cpumask))\n\t\treturn -EINVAL;\n\n\tret = parent->chip->irq_set_affinity(parent, mask, force);\n\tif (ret < 0 || ret == IRQ_SET_MASK_OK_DONE)\n\t\treturn ret;\n\n\tvector_schedule_cleanup(cfg);\n\n\treturn 0;\n}\n\nstatic struct irq_chip hyperv_ir_chip = {\n\t.name\t\t\t= \"HYPERV-IR\",\n\t.irq_ack\t\t= apic_ack_irq,\n\t.irq_set_affinity\t= hyperv_ir_set_affinity,\n};\n\nstatic int hyperv_irq_remapping_alloc(struct irq_domain *domain,\n\t\t\t\t     unsigned int virq, unsigned int nr_irqs,\n\t\t\t\t     void *arg)\n{\n\tstruct irq_alloc_info *info = arg;\n\tstruct irq_data *irq_data;\n\tint ret = 0;\n\n\tif (!info || info->type != X86_IRQ_ALLOC_TYPE_IOAPIC || nr_irqs > 1)\n\t\treturn -EINVAL;\n\n\tret = irq_domain_alloc_irqs_parent(domain, virq, nr_irqs, arg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tirq_data = irq_domain_get_irq_data(domain, virq);\n\tif (!irq_data) {\n\t\tirq_domain_free_irqs_common(domain, virq, nr_irqs);\n\t\treturn -EINVAL;\n\t}\n\n\tirq_data->chip = &hyperv_ir_chip;\n\n\t \n\tirq_data_update_affinity(irq_data, &ioapic_max_cpumask);\n\n\treturn 0;\n}\n\nstatic void hyperv_irq_remapping_free(struct irq_domain *domain,\n\t\t\t\t unsigned int virq, unsigned int nr_irqs)\n{\n\tirq_domain_free_irqs_common(domain, virq, nr_irqs);\n}\n\nstatic int hyperv_irq_remapping_select(struct irq_domain *d,\n\t\t\t\t       struct irq_fwspec *fwspec,\n\t\t\t\t       enum irq_domain_bus_token bus_token)\n{\n\t \n\treturn x86_fwspec_is_ioapic(fwspec);\n}\n\nstatic const struct irq_domain_ops hyperv_ir_domain_ops = {\n\t.select = hyperv_irq_remapping_select,\n\t.alloc = hyperv_irq_remapping_alloc,\n\t.free = hyperv_irq_remapping_free,\n};\n\nstatic const struct irq_domain_ops hyperv_root_ir_domain_ops;\nstatic int __init hyperv_prepare_irq_remapping(void)\n{\n\tstruct fwnode_handle *fn;\n\tint i;\n\tconst char *name;\n\tconst struct irq_domain_ops *ops;\n\n\t \n\tif (!hypervisor_is_type(X86_HYPER_MS_HYPERV) ||\n\t    x86_init.hyper.msi_ext_dest_id())\n\t\treturn -ENODEV;\n\n\tif (hv_root_partition) {\n\t\tname = \"HYPERV-ROOT-IR\";\n\t\tops = &hyperv_root_ir_domain_ops;\n\t} else {\n\t\tname = \"HYPERV-IR\";\n\t\tops = &hyperv_ir_domain_ops;\n\t}\n\n\tfn = irq_domain_alloc_named_id_fwnode(name, 0);\n\tif (!fn)\n\t\treturn -ENOMEM;\n\n\tioapic_ir_domain =\n\t\tirq_domain_create_hierarchy(arch_get_ir_parent_domain(),\n\t\t\t\t0, IOAPIC_REMAPPING_ENTRY, fn, ops, NULL);\n\n\tif (!ioapic_ir_domain) {\n\t\tirq_domain_free_fwnode(fn);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (hv_root_partition)\n\t\treturn 0;  \n\n\t \n\tfor (i = min_t(unsigned int, num_possible_cpus() - 1, 255); i >= 0; i--)\n\t\tif (cpu_physical_id(i) < 256)\n\t\t\tcpumask_set_cpu(i, &ioapic_max_cpumask);\n\n\treturn 0;\n}\n\nstatic int __init hyperv_enable_irq_remapping(void)\n{\n\tif (x2apic_supported())\n\t\treturn IRQ_REMAP_X2APIC_MODE;\n\treturn IRQ_REMAP_XAPIC_MODE;\n}\n\nstruct irq_remap_ops hyperv_irq_remap_ops = {\n\t.prepare\t\t= hyperv_prepare_irq_remapping,\n\t.enable\t\t\t= hyperv_enable_irq_remapping,\n};\n\n \nstruct hyperv_root_ir_data {\n\tu8 ioapic_id;\n\tbool is_level;\n\tstruct hv_interrupt_entry entry;\n};\n\nstatic void\nhyperv_root_ir_compose_msi_msg(struct irq_data *irq_data, struct msi_msg *msg)\n{\n\tu64 status;\n\tu32 vector;\n\tstruct irq_cfg *cfg;\n\tint ioapic_id;\n\tconst struct cpumask *affinity;\n\tint cpu;\n\tstruct hv_interrupt_entry entry;\n\tstruct hyperv_root_ir_data *data = irq_data->chip_data;\n\tstruct IO_APIC_route_entry e;\n\n\tcfg = irqd_cfg(irq_data);\n\taffinity = irq_data_get_effective_affinity_mask(irq_data);\n\tcpu = cpumask_first_and(affinity, cpu_online_mask);\n\n\tvector = cfg->vector;\n\tioapic_id = data->ioapic_id;\n\n\tif (data->entry.source == HV_DEVICE_TYPE_IOAPIC\n\t    && data->entry.ioapic_rte.as_uint64) {\n\t\tentry = data->entry;\n\n\t\tstatus = hv_unmap_ioapic_interrupt(ioapic_id, &entry);\n\n\t\tif (status != HV_STATUS_SUCCESS)\n\t\t\tpr_debug(\"%s: unexpected unmap status %lld\\n\", __func__, status);\n\n\t\tdata->entry.ioapic_rte.as_uint64 = 0;\n\t\tdata->entry.source = 0;  \n\t}\n\n\n\tstatus = hv_map_ioapic_interrupt(ioapic_id, data->is_level, cpu,\n\t\t\t\t\tvector, &entry);\n\n\tif (status != HV_STATUS_SUCCESS) {\n\t\tpr_err(\"%s: map hypercall failed, status %lld\\n\", __func__, status);\n\t\treturn;\n\t}\n\n\tdata->entry = entry;\n\n\t \n\te.w1 = entry.ioapic_rte.low_uint32;\n\te.w2 = entry.ioapic_rte.high_uint32;\n\n\tmemset(msg, 0, sizeof(*msg));\n\tmsg->arch_data.vector = e.vector;\n\tmsg->arch_data.delivery_mode = e.delivery_mode;\n\tmsg->arch_addr_lo.dest_mode_logical = e.dest_mode_logical;\n\tmsg->arch_addr_lo.dmar_format = e.ir_format;\n\tmsg->arch_addr_lo.dmar_index_0_14 = e.ir_index_0_14;\n}\n\nstatic int hyperv_root_ir_set_affinity(struct irq_data *data,\n\t\tconst struct cpumask *mask, bool force)\n{\n\tstruct irq_data *parent = data->parent_data;\n\tstruct irq_cfg *cfg = irqd_cfg(data);\n\tint ret;\n\n\tret = parent->chip->irq_set_affinity(parent, mask, force);\n\tif (ret < 0 || ret == IRQ_SET_MASK_OK_DONE)\n\t\treturn ret;\n\n\tvector_schedule_cleanup(cfg);\n\n\treturn 0;\n}\n\nstatic struct irq_chip hyperv_root_ir_chip = {\n\t.name\t\t\t= \"HYPERV-ROOT-IR\",\n\t.irq_ack\t\t= apic_ack_irq,\n\t.irq_set_affinity\t= hyperv_root_ir_set_affinity,\n\t.irq_compose_msi_msg\t= hyperv_root_ir_compose_msi_msg,\n};\n\nstatic int hyperv_root_irq_remapping_alloc(struct irq_domain *domain,\n\t\t\t\t     unsigned int virq, unsigned int nr_irqs,\n\t\t\t\t     void *arg)\n{\n\tstruct irq_alloc_info *info = arg;\n\tstruct irq_data *irq_data;\n\tstruct hyperv_root_ir_data *data;\n\tint ret = 0;\n\n\tif (!info || info->type != X86_IRQ_ALLOC_TYPE_IOAPIC || nr_irqs > 1)\n\t\treturn -EINVAL;\n\n\tret = irq_domain_alloc_irqs_parent(domain, virq, nr_irqs, arg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data) {\n\t\tirq_domain_free_irqs_common(domain, virq, nr_irqs);\n\t\treturn -ENOMEM;\n\t}\n\n\tirq_data = irq_domain_get_irq_data(domain, virq);\n\tif (!irq_data) {\n\t\tkfree(data);\n\t\tirq_domain_free_irqs_common(domain, virq, nr_irqs);\n\t\treturn -EINVAL;\n\t}\n\n\tdata->ioapic_id = info->devid;\n\tdata->is_level = info->ioapic.is_level;\n\n\tirq_data->chip = &hyperv_root_ir_chip;\n\tirq_data->chip_data = data;\n\n\treturn 0;\n}\n\nstatic void hyperv_root_irq_remapping_free(struct irq_domain *domain,\n\t\t\t\t unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *irq_data;\n\tstruct hyperv_root_ir_data *data;\n\tstruct hv_interrupt_entry *e;\n\tint i;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_data = irq_domain_get_irq_data(domain, virq + i);\n\n\t\tif (irq_data && irq_data->chip_data) {\n\t\t\tdata = irq_data->chip_data;\n\t\t\te = &data->entry;\n\n\t\t\tif (e->source == HV_DEVICE_TYPE_IOAPIC\n\t\t\t      && e->ioapic_rte.as_uint64)\n\t\t\t\thv_unmap_ioapic_interrupt(data->ioapic_id,\n\t\t\t\t\t\t\t&data->entry);\n\n\t\t\tkfree(data);\n\t\t}\n\t}\n\n\tirq_domain_free_irqs_common(domain, virq, nr_irqs);\n}\n\nstatic const struct irq_domain_ops hyperv_root_ir_domain_ops = {\n\t.select = hyperv_irq_remapping_select,\n\t.alloc = hyperv_root_irq_remapping_alloc,\n\t.free = hyperv_root_irq_remapping_free,\n};\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}