{
  "module_name": "pinctrl-da9062.c",
  "hash_id": "b702d403fd0483293100786ce7aa459ec53b146497124b0f26e0e21a241b8943",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/pinctrl-da9062.c",
  "human_readable_source": "\n \n#include <linux/bits.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n\n#include <linux/gpio/driver.h>\n\n#include <linux/mfd/da9062/core.h>\n#include <linux/mfd/da9062/registers.h>\n\n \n#include \"../gpio/gpiolib.h\"\n\n#define DA9062_TYPE(offset)\t\t(4 * (offset % 2))\n#define DA9062_PIN_SHIFT(offset)\t(4 * (offset % 2))\n#define DA9062_PIN_ALTERNATE\t\t0x00  \n#define DA9062_PIN_GPI\t\t\t0x01  \n#define DA9062_PIN_GPO_OD\t\t0x02  \n#define DA9062_PIN_GPO_PP\t\t0x03  \n#define DA9062_GPIO_NUM\t\t\t5\n\nstruct da9062_pctl {\n\tstruct da9062 *da9062;\n\tstruct gpio_chip gc;\n\tunsigned int pin_config[DA9062_GPIO_NUM];\n};\n\nstatic int da9062_pctl_get_pin_mode(struct da9062_pctl *pctl,\n\t\t\t\t    unsigned int offset)\n{\n\tstruct regmap *regmap = pctl->da9062->regmap;\n\tint ret, val;\n\n\tret = regmap_read(regmap, DA9062AA_GPIO_0_1 + (offset >> 1), &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tval >>= DA9062_PIN_SHIFT(offset);\n\tval &= DA9062AA_GPIO0_PIN_MASK;\n\n\treturn val;\n}\n\nstatic int da9062_pctl_set_pin_mode(struct da9062_pctl *pctl,\n\t\t\t\t    unsigned int offset, unsigned int mode_req)\n{\n\tstruct regmap *regmap = pctl->da9062->regmap;\n\tunsigned int mode = mode_req;\n\tunsigned int mask;\n\tint ret;\n\n\tmode &= DA9062AA_GPIO0_PIN_MASK;\n\tmode <<= DA9062_PIN_SHIFT(offset);\n\tmask = DA9062AA_GPIO0_PIN_MASK << DA9062_PIN_SHIFT(offset);\n\n\tret = regmap_update_bits(regmap, DA9062AA_GPIO_0_1 + (offset >> 1),\n\t\t\t\t mask, mode);\n\tif (!ret)\n\t\tpctl->pin_config[offset] = mode_req;\n\n\treturn ret;\n}\n\nstatic int da9062_gpio_get(struct gpio_chip *gc, unsigned int offset)\n{\n\tstruct da9062_pctl *pctl = gpiochip_get_data(gc);\n\tstruct regmap *regmap = pctl->da9062->regmap;\n\tint gpio_mode, val;\n\tint ret;\n\n\tgpio_mode = da9062_pctl_get_pin_mode(pctl, offset);\n\tif (gpio_mode < 0)\n\t\treturn gpio_mode;\n\n\tswitch (gpio_mode) {\n\tcase DA9062_PIN_ALTERNATE:\n\t\treturn -ENOTSUPP;\n\tcase DA9062_PIN_GPI:\n\t\tret = regmap_read(regmap, DA9062AA_STATUS_B, &val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase DA9062_PIN_GPO_OD:\n\tcase DA9062_PIN_GPO_PP:\n\t\tret = regmap_read(regmap, DA9062AA_GPIO_MODE0_4, &val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn !!(val & BIT(offset));\n}\n\nstatic void da9062_gpio_set(struct gpio_chip *gc, unsigned int offset,\n\t\t\t    int value)\n{\n\tstruct da9062_pctl *pctl = gpiochip_get_data(gc);\n\tstruct regmap *regmap = pctl->da9062->regmap;\n\n\tregmap_update_bits(regmap, DA9062AA_GPIO_MODE0_4, BIT(offset),\n\t\t\t   value << offset);\n}\n\nstatic int da9062_gpio_get_direction(struct gpio_chip *gc, unsigned int offset)\n{\n\tstruct da9062_pctl *pctl = gpiochip_get_data(gc);\n\tint gpio_mode;\n\n\tgpio_mode = da9062_pctl_get_pin_mode(pctl, offset);\n\tif (gpio_mode < 0)\n\t\treturn gpio_mode;\n\n\tswitch (gpio_mode) {\n\tcase DA9062_PIN_ALTERNATE:\n\t\treturn -ENOTSUPP;\n\tcase DA9062_PIN_GPI:\n\t\treturn GPIO_LINE_DIRECTION_IN;\n\tcase DA9062_PIN_GPO_OD:\n\tcase DA9062_PIN_GPO_PP:\n\t\treturn GPIO_LINE_DIRECTION_OUT;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int da9062_gpio_direction_input(struct gpio_chip *gc,\n\t\t\t\t       unsigned int offset)\n{\n\tstruct da9062_pctl *pctl = gpiochip_get_data(gc);\n\tstruct regmap *regmap = pctl->da9062->regmap;\n\tstruct gpio_desc *desc = gpiochip_get_desc(gc, offset);\n\tunsigned int gpi_type;\n\tint ret;\n\n\tret = da9062_pctl_set_pin_mode(pctl, offset, DA9062_PIN_GPI);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tgpi_type = !gpiod_is_active_low(desc);\n\n\treturn regmap_update_bits(regmap, DA9062AA_GPIO_0_1 + (offset >> 1),\n\t\t\t\tDA9062AA_GPIO0_TYPE_MASK << DA9062_TYPE(offset),\n\t\t\t\tgpi_type << DA9062_TYPE(offset));\n}\n\nstatic int da9062_gpio_direction_output(struct gpio_chip *gc,\n\t\t\t\t\tunsigned int offset, int value)\n{\n\tstruct da9062_pctl *pctl = gpiochip_get_data(gc);\n\tunsigned int pin_config = pctl->pin_config[offset];\n\tint ret;\n\n\tret = da9062_pctl_set_pin_mode(pctl, offset, pin_config);\n\tif (ret)\n\t\treturn ret;\n\n\tda9062_gpio_set(gc, offset, value);\n\n\treturn 0;\n}\n\nstatic int da9062_gpio_set_config(struct gpio_chip *gc, unsigned int offset,\n\t\t\t\t  unsigned long config)\n{\n\tstruct da9062_pctl *pctl = gpiochip_get_data(gc);\n\tstruct regmap *regmap = pctl->da9062->regmap;\n\tint gpio_mode;\n\n\t \n\n\tswitch (pinconf_to_config_param(config)) {\n\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\treturn regmap_update_bits(regmap, DA9062AA_CONFIG_K,\n\t\t\t\t\t  BIT(offset), 0);\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\tgpio_mode = da9062_pctl_get_pin_mode(pctl, offset);\n\t\tif (gpio_mode < 0)\n\t\t\treturn -EINVAL;\n\t\telse if (gpio_mode != DA9062_PIN_GPI)\n\t\t\treturn -ENOTSUPP;\n\t\treturn regmap_update_bits(regmap, DA9062AA_CONFIG_K,\n\t\t\t\t\t  BIT(offset), BIT(offset));\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\tgpio_mode = da9062_pctl_get_pin_mode(pctl, offset);\n\t\tif (gpio_mode < 0)\n\t\t\treturn -EINVAL;\n\t\telse if (gpio_mode != DA9062_PIN_GPO_OD)\n\t\t\treturn -ENOTSUPP;\n\t\treturn regmap_update_bits(regmap, DA9062AA_CONFIG_K,\n\t\t\t\t\t  BIT(offset), BIT(offset));\n\tcase PIN_CONFIG_DRIVE_OPEN_DRAIN:\n\t\treturn da9062_pctl_set_pin_mode(pctl, offset,\n\t\t\t\t\t\tDA9062_PIN_GPO_OD);\n\tcase PIN_CONFIG_DRIVE_PUSH_PULL:\n\t\treturn da9062_pctl_set_pin_mode(pctl, offset,\n\t\t\t\t\t\tDA9062_PIN_GPO_PP);\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n}\n\nstatic int da9062_gpio_to_irq(struct gpio_chip *gc, unsigned int offset)\n{\n\tstruct da9062_pctl *pctl = gpiochip_get_data(gc);\n\tstruct da9062 *da9062 = pctl->da9062;\n\n\treturn regmap_irq_get_virq(da9062->regmap_irq,\n\t\t\t\t   DA9062_IRQ_GPI0 + offset);\n}\n\nstatic const struct gpio_chip reference_gc = {\n\t.owner = THIS_MODULE,\n\t.get = da9062_gpio_get,\n\t.set = da9062_gpio_set,\n\t.get_direction = da9062_gpio_get_direction,\n\t.direction_input = da9062_gpio_direction_input,\n\t.direction_output = da9062_gpio_direction_output,\n\t.set_config = da9062_gpio_set_config,\n\t.to_irq = da9062_gpio_to_irq,\n\t.can_sleep = true,\n\t.ngpio = DA9062_GPIO_NUM,\n\t.base = -1,\n};\n\nstatic int da9062_pctl_probe(struct platform_device *pdev)\n{\n\tstruct device *parent = pdev->dev.parent;\n\tstruct da9062_pctl *pctl;\n\tint i;\n\n\tdevice_set_node(&pdev->dev, dev_fwnode(pdev->dev.parent));\n\n\tpctl = devm_kzalloc(&pdev->dev, sizeof(*pctl), GFP_KERNEL);\n\tif (!pctl)\n\t\treturn -ENOMEM;\n\n\tpctl->da9062 = dev_get_drvdata(parent);\n\tif (!pctl->da9062)\n\t\treturn -EINVAL;\n\n\tif (!device_property_present(parent, \"gpio-controller\"))\n\t\treturn 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(pctl->pin_config); i++)\n\t\tpctl->pin_config[i] = DA9062_PIN_GPO_PP;\n\n\t \n\tpctl->gc = reference_gc;\n\tpctl->gc.label = dev_name(&pdev->dev);\n\tpctl->gc.parent = &pdev->dev;\n\n\tplatform_set_drvdata(pdev, pctl);\n\n\treturn devm_gpiochip_add_data(&pdev->dev, &pctl->gc, pctl);\n}\n\nstatic struct platform_driver da9062_pctl_driver = {\n\t.probe = da9062_pctl_probe,\n\t.driver = {\n\t\t.name\t= \"da9062-gpio\",\n\t},\n};\nmodule_platform_driver(da9062_pctl_driver);\n\nMODULE_AUTHOR(\"Marco Felsch <kernel@pengutronix.de>\");\nMODULE_DESCRIPTION(\"DA9062 PMIC pinctrl and GPIO Driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:da9062-gpio\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}