{
  "module_name": "pinctrl-as3722.c",
  "hash_id": "1ae9a9ee6d1513c47ceb3f40765f8782d8567a623baaadc72efc853c83168454",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/pinctrl-as3722.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/gpio/driver.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/mfd/as3722.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/property.h>\n#include <linux/slab.h>\n\n#include <linux/pinctrl/consumer.h>\n#include <linux/pinctrl/machine.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinconf-generic.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinmux.h>\n\n#include \"core.h\"\n#include \"pinconf.h\"\n#include \"pinctrl-utils.h\"\n\n#define AS3722_PIN_GPIO0\t\t0\n#define AS3722_PIN_GPIO1\t\t1\n#define AS3722_PIN_GPIO2\t\t2\n#define AS3722_PIN_GPIO3\t\t3\n#define AS3722_PIN_GPIO4\t\t4\n#define AS3722_PIN_GPIO5\t\t5\n#define AS3722_PIN_GPIO6\t\t6\n#define AS3722_PIN_GPIO7\t\t7\n#define AS3722_PIN_NUM\t\t\t(AS3722_PIN_GPIO7 + 1)\n\n#define AS3722_GPIO_MODE_PULL_UP           BIT(PIN_CONFIG_BIAS_PULL_UP)\n#define AS3722_GPIO_MODE_PULL_DOWN         BIT(PIN_CONFIG_BIAS_PULL_DOWN)\n#define AS3722_GPIO_MODE_HIGH_IMPED        BIT(PIN_CONFIG_BIAS_HIGH_IMPEDANCE)\n#define AS3722_GPIO_MODE_OPEN_DRAIN        BIT(PIN_CONFIG_DRIVE_OPEN_DRAIN)\n\nstruct as3722_pin_function {\n\tconst char *name;\n\tconst char * const *groups;\n\tunsigned ngroups;\n\tint mux_option;\n};\n\nstruct as3722_gpio_pin_control {\n\tunsigned mode_prop;\n\tint io_function;\n};\n\nstruct as3722_pingroup {\n\tconst char *name;\n\tconst unsigned pins[1];\n\tunsigned npins;\n};\n\nstruct as3722_pctrl_info {\n\tstruct device *dev;\n\tstruct pinctrl_dev *pctl;\n\tstruct as3722 *as3722;\n\tstruct gpio_chip gpio_chip;\n\tint pins_current_opt[AS3722_PIN_NUM];\n\tconst struct as3722_pin_function *functions;\n\tunsigned num_functions;\n\tconst struct as3722_pingroup *pin_groups;\n\tint num_pin_groups;\n\tconst struct pinctrl_pin_desc *pins;\n\tunsigned num_pins;\n\tstruct as3722_gpio_pin_control gpio_control[AS3722_PIN_NUM];\n};\n\nstatic const struct pinctrl_pin_desc as3722_pins_desc[] = {\n\tPINCTRL_PIN(AS3722_PIN_GPIO0, \"gpio0\"),\n\tPINCTRL_PIN(AS3722_PIN_GPIO1, \"gpio1\"),\n\tPINCTRL_PIN(AS3722_PIN_GPIO2, \"gpio2\"),\n\tPINCTRL_PIN(AS3722_PIN_GPIO3, \"gpio3\"),\n\tPINCTRL_PIN(AS3722_PIN_GPIO4, \"gpio4\"),\n\tPINCTRL_PIN(AS3722_PIN_GPIO5, \"gpio5\"),\n\tPINCTRL_PIN(AS3722_PIN_GPIO6, \"gpio6\"),\n\tPINCTRL_PIN(AS3722_PIN_GPIO7, \"gpio7\"),\n};\n\nstatic const char * const gpio_groups[] = {\n\t\"gpio0\",\n\t\"gpio1\",\n\t\"gpio2\",\n\t\"gpio3\",\n\t\"gpio4\",\n\t\"gpio5\",\n\t\"gpio6\",\n\t\"gpio7\",\n};\n\nenum as3722_pinmux_option {\n\tAS3722_PINMUX_GPIO\t\t\t= 0,\n\tAS3722_PINMUX_INTERRUPT_OUT\t\t= 1,\n\tAS3722_PINMUX_VSUB_VBAT_UNDEB_LOW_OUT\t= 2,\n\tAS3722_PINMUX_GPIO_INTERRUPT\t\t= 3,\n\tAS3722_PINMUX_PWM_INPUT\t\t\t= 4,\n\tAS3722_PINMUX_VOLTAGE_IN_STBY\t\t= 5,\n\tAS3722_PINMUX_OC_PG_SD0\t\t\t= 6,\n\tAS3722_PINMUX_PG_OUT\t\t\t= 7,\n\tAS3722_PINMUX_CLK32K_OUT\t\t= 8,\n\tAS3722_PINMUX_WATCHDOG_INPUT\t\t= 9,\n\tAS3722_PINMUX_SOFT_RESET_IN\t\t= 11,\n\tAS3722_PINMUX_PWM_OUTPUT\t\t= 12,\n\tAS3722_PINMUX_VSUB_VBAT_LOW_DEB_OUT\t= 13,\n\tAS3722_PINMUX_OC_PG_SD6\t\t\t= 14,\n};\n\n#define FUNCTION_GROUP(fname, mux)\t\t\t\\\n\t{\t\t\t\t\t\t\\\n\t\t.name = #fname,\t\t\t\t\\\n\t\t.groups = gpio_groups,\t\t\t\\\n\t\t.ngroups = ARRAY_SIZE(gpio_groups),\t\\\n\t\t.mux_option = AS3722_PINMUX_##mux,\t\\\n\t}\n\nstatic const struct as3722_pin_function as3722_pin_function[] = {\n\tFUNCTION_GROUP(gpio, GPIO),\n\tFUNCTION_GROUP(interrupt-out, INTERRUPT_OUT),\n\tFUNCTION_GROUP(gpio-in-interrupt, GPIO_INTERRUPT),\n\tFUNCTION_GROUP(vsup-vbat-low-undebounce-out, VSUB_VBAT_UNDEB_LOW_OUT),\n\tFUNCTION_GROUP(vsup-vbat-low-debounce-out, VSUB_VBAT_LOW_DEB_OUT),\n\tFUNCTION_GROUP(voltage-in-standby, VOLTAGE_IN_STBY),\n\tFUNCTION_GROUP(oc-pg-sd0, OC_PG_SD0),\n\tFUNCTION_GROUP(oc-pg-sd6, OC_PG_SD6),\n\tFUNCTION_GROUP(powergood-out, PG_OUT),\n\tFUNCTION_GROUP(pwm-in, PWM_INPUT),\n\tFUNCTION_GROUP(pwm-out, PWM_OUTPUT),\n\tFUNCTION_GROUP(clk32k-out, CLK32K_OUT),\n\tFUNCTION_GROUP(watchdog-in, WATCHDOG_INPUT),\n\tFUNCTION_GROUP(soft-reset-in, SOFT_RESET_IN),\n};\n\n#define AS3722_PINGROUP(pg_name, pin_id) \\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.name = #pg_name,\t\t\t\t\t\\\n\t\t.pins = {AS3722_PIN_##pin_id},\t\t\t\t\\\n\t\t.npins = 1,\t\t\t\t\t\t\\\n\t}\n\nstatic const struct as3722_pingroup as3722_pingroups[] = {\n\tAS3722_PINGROUP(gpio0,\tGPIO0),\n\tAS3722_PINGROUP(gpio1,\tGPIO1),\n\tAS3722_PINGROUP(gpio2,\tGPIO2),\n\tAS3722_PINGROUP(gpio3,\tGPIO3),\n\tAS3722_PINGROUP(gpio4,\tGPIO4),\n\tAS3722_PINGROUP(gpio5,\tGPIO5),\n\tAS3722_PINGROUP(gpio6,\tGPIO6),\n\tAS3722_PINGROUP(gpio7,\tGPIO7),\n};\n\nstatic int as3722_pinctrl_get_groups_count(struct pinctrl_dev *pctldev)\n{\n\tstruct as3722_pctrl_info *as_pci = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn as_pci->num_pin_groups;\n}\n\nstatic const char *as3722_pinctrl_get_group_name(struct pinctrl_dev *pctldev,\n\t\tunsigned group)\n{\n\tstruct as3722_pctrl_info *as_pci = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn as_pci->pin_groups[group].name;\n}\n\nstatic int as3722_pinctrl_get_group_pins(struct pinctrl_dev *pctldev,\n\t\tunsigned group, const unsigned **pins, unsigned *num_pins)\n{\n\tstruct as3722_pctrl_info *as_pci = pinctrl_dev_get_drvdata(pctldev);\n\n\t*pins = as_pci->pin_groups[group].pins;\n\t*num_pins = as_pci->pin_groups[group].npins;\n\treturn 0;\n}\n\nstatic const struct pinctrl_ops as3722_pinctrl_ops = {\n\t.get_groups_count = as3722_pinctrl_get_groups_count,\n\t.get_group_name = as3722_pinctrl_get_group_name,\n\t.get_group_pins = as3722_pinctrl_get_group_pins,\n\t.dt_node_to_map = pinconf_generic_dt_node_to_map_pin,\n\t.dt_free_map = pinctrl_utils_free_map,\n};\n\nstatic int as3722_pinctrl_get_funcs_count(struct pinctrl_dev *pctldev)\n{\n\tstruct as3722_pctrl_info *as_pci = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn as_pci->num_functions;\n}\n\nstatic const char *as3722_pinctrl_get_func_name(struct pinctrl_dev *pctldev,\n\t\t\tunsigned function)\n{\n\tstruct as3722_pctrl_info *as_pci = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn as_pci->functions[function].name;\n}\n\nstatic int as3722_pinctrl_get_func_groups(struct pinctrl_dev *pctldev,\n\t\tunsigned function, const char * const **groups,\n\t\tunsigned * const num_groups)\n{\n\tstruct as3722_pctrl_info *as_pci = pinctrl_dev_get_drvdata(pctldev);\n\n\t*groups = as_pci->functions[function].groups;\n\t*num_groups = as_pci->functions[function].ngroups;\n\treturn 0;\n}\n\nstatic int as3722_pinctrl_set(struct pinctrl_dev *pctldev, unsigned function,\n\t\tunsigned group)\n{\n\tstruct as3722_pctrl_info *as_pci = pinctrl_dev_get_drvdata(pctldev);\n\tint gpio_cntr_reg = AS3722_GPIOn_CONTROL_REG(group);\n\tu8 val = AS3722_GPIO_IOSF_VAL(as_pci->functions[function].mux_option);\n\tint ret;\n\n\tdev_dbg(as_pci->dev, \"%s(): GPIO %u pin to function %u and val %u\\n\",\n\t\t__func__, group, function, val);\n\n\tret = as3722_update_bits(as_pci->as3722, gpio_cntr_reg,\n\t\t\tAS3722_GPIO_IOSF_MASK, val);\n\tif (ret < 0) {\n\t\tdev_err(as_pci->dev, \"GPIO%d_CTRL_REG update failed %d\\n\",\n\t\t\tgroup, ret);\n\t\treturn ret;\n\t}\n\tas_pci->gpio_control[group].io_function = function;\n\n\tswitch (val) {\n\tcase AS3722_GPIO_IOSF_SD0_OUT:\n\tcase AS3722_GPIO_IOSF_PWR_GOOD_OUT:\n\tcase AS3722_GPIO_IOSF_Q32K_OUT:\n\tcase AS3722_GPIO_IOSF_PWM_OUT:\n\tcase AS3722_GPIO_IOSF_SD6_LOW_VOLT_LOW:\n\t\tret = as3722_update_bits(as_pci->as3722, gpio_cntr_reg,\n\t\t\tAS3722_GPIO_MODE_MASK, AS3722_GPIO_MODE_OUTPUT_VDDH);\n\t\tif (ret < 0) {\n\t\t\tdev_err(as_pci->dev, \"GPIO%d_CTRL update failed %d\\n\",\n\t\t\t\tgroup, ret);\n\t\t\treturn ret;\n\t\t}\n\t\tas_pci->gpio_control[group].mode_prop =\n\t\t\t\tAS3722_GPIO_MODE_OUTPUT_VDDH;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int as3722_pinctrl_gpio_get_mode(unsigned gpio_mode_prop, bool input)\n{\n\tif (gpio_mode_prop & AS3722_GPIO_MODE_HIGH_IMPED)\n\t\treturn -EINVAL;\n\n\tif (gpio_mode_prop & AS3722_GPIO_MODE_OPEN_DRAIN) {\n\t\tif (gpio_mode_prop & AS3722_GPIO_MODE_PULL_UP)\n\t\t\treturn AS3722_GPIO_MODE_IO_OPEN_DRAIN_PULL_UP;\n\t\treturn AS3722_GPIO_MODE_IO_OPEN_DRAIN;\n\t}\n\tif (input) {\n\t\tif (gpio_mode_prop & AS3722_GPIO_MODE_PULL_UP)\n\t\t\treturn AS3722_GPIO_MODE_INPUT_PULL_UP;\n\t\telse if (gpio_mode_prop & AS3722_GPIO_MODE_PULL_DOWN)\n\t\t\treturn AS3722_GPIO_MODE_INPUT_PULL_DOWN;\n\t\treturn AS3722_GPIO_MODE_INPUT;\n\t}\n\tif (gpio_mode_prop & AS3722_GPIO_MODE_PULL_DOWN)\n\t\treturn AS3722_GPIO_MODE_OUTPUT_VDDL;\n\treturn AS3722_GPIO_MODE_OUTPUT_VDDH;\n}\n\nstatic int as3722_pinctrl_gpio_request_enable(struct pinctrl_dev *pctldev,\n\t\tstruct pinctrl_gpio_range *range, unsigned offset)\n{\n\tstruct as3722_pctrl_info *as_pci = pinctrl_dev_get_drvdata(pctldev);\n\n\tif (as_pci->gpio_control[offset].io_function)\n\t\treturn -EBUSY;\n\treturn 0;\n}\n\nstatic int as3722_pinctrl_gpio_set_direction(struct pinctrl_dev *pctldev,\n\t\tstruct pinctrl_gpio_range *range, unsigned offset, bool input)\n{\n\tstruct as3722_pctrl_info *as_pci = pinctrl_dev_get_drvdata(pctldev);\n\tstruct as3722 *as3722 = as_pci->as3722;\n\tint mode;\n\n\tmode = as3722_pinctrl_gpio_get_mode(\n\t\t\tas_pci->gpio_control[offset].mode_prop, input);\n\tif (mode < 0) {\n\t\tdev_err(as_pci->dev, \"%s direction for GPIO %d not supported\\n\",\n\t\t\t(input) ? \"Input\" : \"Output\", offset);\n\t\treturn mode;\n\t}\n\n\treturn as3722_update_bits(as3722, AS3722_GPIOn_CONTROL_REG(offset),\n\t\t\t\tAS3722_GPIO_MODE_MASK, mode);\n}\n\nstatic const struct pinmux_ops as3722_pinmux_ops = {\n\t.get_functions_count\t= as3722_pinctrl_get_funcs_count,\n\t.get_function_name\t= as3722_pinctrl_get_func_name,\n\t.get_function_groups\t= as3722_pinctrl_get_func_groups,\n\t.set_mux\t\t= as3722_pinctrl_set,\n\t.gpio_request_enable\t= as3722_pinctrl_gpio_request_enable,\n\t.gpio_set_direction\t= as3722_pinctrl_gpio_set_direction,\n};\n\nstatic int as3722_pinconf_get(struct pinctrl_dev *pctldev,\n\t\t\tunsigned pin, unsigned long *config)\n{\n\tstruct as3722_pctrl_info *as_pci = pinctrl_dev_get_drvdata(pctldev);\n\tenum pin_config_param param = pinconf_to_config_param(*config);\n\tint arg = 0;\n\tu16 prop;\n\n\tswitch (param) {\n\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\tprop = AS3722_GPIO_MODE_PULL_UP |\n\t\t\t\tAS3722_GPIO_MODE_PULL_DOWN;\n\t\tif (!(as_pci->gpio_control[pin].mode_prop & prop))\n\t\t\targ = 1;\n\t\tprop = 0;\n\t\tbreak;\n\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\tprop = AS3722_GPIO_MODE_PULL_UP;\n\t\tbreak;\n\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\tprop = AS3722_GPIO_MODE_PULL_DOWN;\n\t\tbreak;\n\n\tcase PIN_CONFIG_DRIVE_OPEN_DRAIN:\n\t\tprop = AS3722_GPIO_MODE_OPEN_DRAIN;\n\t\tbreak;\n\n\tcase PIN_CONFIG_BIAS_HIGH_IMPEDANCE:\n\t\tprop = AS3722_GPIO_MODE_HIGH_IMPED;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(as_pci->dev, \"Properties not supported\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tif (as_pci->gpio_control[pin].mode_prop & prop)\n\t\targ = 1;\n\n\t*config = pinconf_to_config_packed(param, (u16)arg);\n\treturn 0;\n}\n\nstatic int as3722_pinconf_set(struct pinctrl_dev *pctldev,\n\t\t\tunsigned pin, unsigned long *configs,\n\t\t\tunsigned num_configs)\n{\n\tstruct as3722_pctrl_info *as_pci = pinctrl_dev_get_drvdata(pctldev);\n\tenum pin_config_param param;\n\tint mode_prop;\n\tint i;\n\n\tfor (i = 0; i < num_configs; i++) {\n\t\tparam = pinconf_to_config_param(configs[i]);\n\t\tmode_prop = as_pci->gpio_control[pin].mode_prop;\n\n\t\tswitch (param) {\n\t\tcase PIN_CONFIG_BIAS_PULL_PIN_DEFAULT:\n\t\t\tbreak;\n\n\t\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\t\tmode_prop &= ~(AS3722_GPIO_MODE_PULL_UP |\n\t\t\t\t\tAS3722_GPIO_MODE_PULL_DOWN);\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\t\tmode_prop |= AS3722_GPIO_MODE_PULL_UP;\n\t\t\tbreak;\n\n\t\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\t\tmode_prop |= AS3722_GPIO_MODE_PULL_DOWN;\n\t\t\tbreak;\n\n\t\tcase PIN_CONFIG_BIAS_HIGH_IMPEDANCE:\n\t\t\tmode_prop |= AS3722_GPIO_MODE_HIGH_IMPED;\n\t\t\tbreak;\n\n\t\tcase PIN_CONFIG_DRIVE_OPEN_DRAIN:\n\t\t\tmode_prop |= AS3722_GPIO_MODE_OPEN_DRAIN;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_err(as_pci->dev, \"Properties not supported\\n\");\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\n\t\tas_pci->gpio_control[pin].mode_prop = mode_prop;\n\t}\n\treturn 0;\n}\n\nstatic const struct pinconf_ops as3722_pinconf_ops = {\n\t.pin_config_get = as3722_pinconf_get,\n\t.pin_config_set = as3722_pinconf_set,\n};\n\nstatic struct pinctrl_desc as3722_pinctrl_desc = {\n\t.pctlops = &as3722_pinctrl_ops,\n\t.pmxops = &as3722_pinmux_ops,\n\t.confops = &as3722_pinconf_ops,\n\t.owner = THIS_MODULE,\n};\n\nstatic int as3722_gpio_get(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct as3722_pctrl_info *as_pci = gpiochip_get_data(chip);\n\tstruct as3722 *as3722 = as_pci->as3722;\n\tint ret;\n\tu32 reg;\n\tu32 control;\n\tu32 val;\n\tint mode;\n\tint invert_enable;\n\n\tret = as3722_read(as3722, AS3722_GPIOn_CONTROL_REG(offset), &control);\n\tif (ret < 0) {\n\t\tdev_err(as_pci->dev,\n\t\t\t\"GPIO_CONTROL%d_REG read failed: %d\\n\", offset, ret);\n\t\treturn ret;\n\t}\n\n\tinvert_enable = !!(control & AS3722_GPIO_INV);\n\tmode = control & AS3722_GPIO_MODE_MASK;\n\tswitch (mode) {\n\tcase AS3722_GPIO_MODE_INPUT:\n\tcase AS3722_GPIO_MODE_INPUT_PULL_UP:\n\tcase AS3722_GPIO_MODE_INPUT_PULL_DOWN:\n\tcase AS3722_GPIO_MODE_IO_OPEN_DRAIN:\n\tcase AS3722_GPIO_MODE_IO_OPEN_DRAIN_PULL_UP:\n\t\treg = AS3722_GPIO_SIGNAL_IN_REG;\n\t\tbreak;\n\tcase AS3722_GPIO_MODE_OUTPUT_VDDH:\n\tcase AS3722_GPIO_MODE_OUTPUT_VDDL:\n\t\treg = AS3722_GPIO_SIGNAL_OUT_REG;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = as3722_read(as3722, reg, &val);\n\tif (ret < 0) {\n\t\tdev_err(as_pci->dev,\n\t\t\t\"GPIO_SIGNAL_IN_REG read failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tval = !!(val & AS3722_GPIOn_SIGNAL(offset));\n\treturn (invert_enable) ? !val : val;\n}\n\nstatic void as3722_gpio_set(struct gpio_chip *chip, unsigned offset,\n\t\tint value)\n{\n\tstruct as3722_pctrl_info *as_pci = gpiochip_get_data(chip);\n\tstruct as3722 *as3722 = as_pci->as3722;\n\tint en_invert;\n\tu32 val;\n\tint ret;\n\n\tret = as3722_read(as3722, AS3722_GPIOn_CONTROL_REG(offset), &val);\n\tif (ret < 0) {\n\t\tdev_err(as_pci->dev,\n\t\t\t\"GPIO_CONTROL%d_REG read failed: %d\\n\", offset, ret);\n\t\treturn;\n\t}\n\ten_invert = !!(val & AS3722_GPIO_INV);\n\n\tif (value)\n\t\tval = (en_invert) ? 0 : AS3722_GPIOn_SIGNAL(offset);\n\telse\n\t\tval = (en_invert) ? AS3722_GPIOn_SIGNAL(offset) : 0;\n\n\tret = as3722_update_bits(as3722, AS3722_GPIO_SIGNAL_OUT_REG,\n\t\t\tAS3722_GPIOn_SIGNAL(offset), val);\n\tif (ret < 0)\n\t\tdev_err(as_pci->dev,\n\t\t\t\"GPIO_SIGNAL_OUT_REG update failed: %d\\n\", ret);\n}\n\nstatic int as3722_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\n{\n\treturn pinctrl_gpio_direction_input(chip->base + offset);\n}\n\nstatic int as3722_gpio_direction_output(struct gpio_chip *chip,\n\t\tunsigned offset, int value)\n{\n\tas3722_gpio_set(chip, offset, value);\n\treturn pinctrl_gpio_direction_output(chip->base + offset);\n}\n\nstatic int as3722_gpio_to_irq(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct as3722_pctrl_info *as_pci = gpiochip_get_data(chip);\n\n\treturn as3722_irq_get_virq(as_pci->as3722, offset);\n}\n\nstatic const struct gpio_chip as3722_gpio_chip = {\n\t.label\t\t\t= \"as3722-gpio\",\n\t.owner\t\t\t= THIS_MODULE,\n\t.request\t\t= gpiochip_generic_request,\n\t.free\t\t\t= gpiochip_generic_free,\n\t.get\t\t\t= as3722_gpio_get,\n\t.set\t\t\t= as3722_gpio_set,\n\t.direction_input\t= as3722_gpio_direction_input,\n\t.direction_output\t= as3722_gpio_direction_output,\n\t.to_irq\t\t\t= as3722_gpio_to_irq,\n\t.can_sleep\t\t= true,\n\t.ngpio\t\t\t= AS3722_PIN_NUM,\n\t.base\t\t\t= -1,\n};\n\nstatic int as3722_pinctrl_probe(struct platform_device *pdev)\n{\n\tstruct as3722_pctrl_info *as_pci;\n\tint ret;\n\n\tdevice_set_node(&pdev->dev, dev_fwnode(pdev->dev.parent));\n\n\tas_pci = devm_kzalloc(&pdev->dev, sizeof(*as_pci), GFP_KERNEL);\n\tif (!as_pci)\n\t\treturn -ENOMEM;\n\n\tas_pci->dev = &pdev->dev;\n\tas_pci->as3722 = dev_get_drvdata(pdev->dev.parent);\n\tplatform_set_drvdata(pdev, as_pci);\n\n\tas_pci->pins = as3722_pins_desc;\n\tas_pci->num_pins = ARRAY_SIZE(as3722_pins_desc);\n\tas_pci->functions = as3722_pin_function;\n\tas_pci->num_functions = ARRAY_SIZE(as3722_pin_function);\n\tas_pci->pin_groups = as3722_pingroups;\n\tas_pci->num_pin_groups = ARRAY_SIZE(as3722_pingroups);\n\tas3722_pinctrl_desc.name = dev_name(&pdev->dev);\n\tas3722_pinctrl_desc.pins = as3722_pins_desc;\n\tas3722_pinctrl_desc.npins = ARRAY_SIZE(as3722_pins_desc);\n\tas_pci->pctl = devm_pinctrl_register(&pdev->dev, &as3722_pinctrl_desc,\n\t\t\t\t\t     as_pci);\n\tif (IS_ERR(as_pci->pctl)) {\n\t\tdev_err(&pdev->dev, \"Couldn't register pinctrl driver\\n\");\n\t\treturn PTR_ERR(as_pci->pctl);\n\t}\n\n\tas_pci->gpio_chip = as3722_gpio_chip;\n\tas_pci->gpio_chip.parent = &pdev->dev;\n\tret = gpiochip_add_data(&as_pci->gpio_chip, as_pci);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Couldn't register gpiochip, %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = gpiochip_add_pin_range(&as_pci->gpio_chip, dev_name(&pdev->dev),\n\t\t\t\t0, 0, AS3722_PIN_NUM);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Couldn't add pin range, %d\\n\", ret);\n\t\tgoto fail_range_add;\n\t}\n\n\treturn 0;\n\nfail_range_add:\n\tgpiochip_remove(&as_pci->gpio_chip);\n\treturn ret;\n}\n\nstatic int as3722_pinctrl_remove(struct platform_device *pdev)\n{\n\tstruct as3722_pctrl_info *as_pci = platform_get_drvdata(pdev);\n\n\tgpiochip_remove(&as_pci->gpio_chip);\n\treturn 0;\n}\n\nstatic const struct of_device_id as3722_pinctrl_of_match[] = {\n\t{ .compatible = \"ams,as3722-pinctrl\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, as3722_pinctrl_of_match);\n\nstatic struct platform_driver as3722_pinctrl_driver = {\n\t.driver = {\n\t\t.name = \"as3722-pinctrl\",\n\t\t.of_match_table = as3722_pinctrl_of_match,\n\t},\n\t.probe = as3722_pinctrl_probe,\n\t.remove = as3722_pinctrl_remove,\n};\nmodule_platform_driver(as3722_pinctrl_driver);\n\nMODULE_ALIAS(\"platform:as3722-pinctrl\");\nMODULE_DESCRIPTION(\"AS3722 pin control and GPIO driver\");\nMODULE_AUTHOR(\"Laxman Dewangan<ldewangan@nvidia.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}