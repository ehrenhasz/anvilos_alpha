{
  "module_name": "pinctrl-exynos.c",
  "hash_id": "76d95ed118467e9d01fcfa4d73a76a0573662a85a616236bec70f23aca8774e7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/samsung/pinctrl-exynos.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include <linux/device.h>\n#include <linux/interrupt.h>\n#include <linux/irqdomain.h>\n#include <linux/irq.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/regmap.h>\n#include <linux/err.h>\n#include <linux/soc/samsung/exynos-pmu.h>\n#include <linux/soc/samsung/exynos-regs-pmu.h>\n\n#include \"pinctrl-samsung.h\"\n#include \"pinctrl-exynos.h\"\n\nstruct exynos_irq_chip {\n\tstruct irq_chip chip;\n\n\tu32 eint_con;\n\tu32 eint_mask;\n\tu32 eint_pend;\n\tu32 *eint_wake_mask_value;\n\tu32 eint_wake_mask_reg;\n\tvoid (*set_eint_wakeup_mask)(struct samsung_pinctrl_drv_data *drvdata,\n\t\t\t\t     struct exynos_irq_chip *irq_chip);\n};\n\nstatic inline struct exynos_irq_chip *to_exynos_irq_chip(struct irq_chip *chip)\n{\n\treturn container_of(chip, struct exynos_irq_chip, chip);\n}\n\nstatic void exynos_irq_mask(struct irq_data *irqd)\n{\n\tstruct irq_chip *chip = irq_data_get_irq_chip(irqd);\n\tstruct exynos_irq_chip *our_chip = to_exynos_irq_chip(chip);\n\tstruct samsung_pin_bank *bank = irq_data_get_irq_chip_data(irqd);\n\tunsigned long reg_mask = our_chip->eint_mask + bank->eint_offset;\n\tunsigned int mask;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&bank->slock, flags);\n\n\tmask = readl(bank->eint_base + reg_mask);\n\tmask |= 1 << irqd->hwirq;\n\twritel(mask, bank->eint_base + reg_mask);\n\n\traw_spin_unlock_irqrestore(&bank->slock, flags);\n}\n\nstatic void exynos_irq_ack(struct irq_data *irqd)\n{\n\tstruct irq_chip *chip = irq_data_get_irq_chip(irqd);\n\tstruct exynos_irq_chip *our_chip = to_exynos_irq_chip(chip);\n\tstruct samsung_pin_bank *bank = irq_data_get_irq_chip_data(irqd);\n\tunsigned long reg_pend = our_chip->eint_pend + bank->eint_offset;\n\n\twritel(1 << irqd->hwirq, bank->eint_base + reg_pend);\n}\n\nstatic void exynos_irq_unmask(struct irq_data *irqd)\n{\n\tstruct irq_chip *chip = irq_data_get_irq_chip(irqd);\n\tstruct exynos_irq_chip *our_chip = to_exynos_irq_chip(chip);\n\tstruct samsung_pin_bank *bank = irq_data_get_irq_chip_data(irqd);\n\tunsigned long reg_mask = our_chip->eint_mask + bank->eint_offset;\n\tunsigned int mask;\n\tunsigned long flags;\n\n\t \n\tif (irqd_get_trigger_type(irqd) & IRQ_TYPE_LEVEL_MASK)\n\t\texynos_irq_ack(irqd);\n\n\traw_spin_lock_irqsave(&bank->slock, flags);\n\n\tmask = readl(bank->eint_base + reg_mask);\n\tmask &= ~(1 << irqd->hwirq);\n\twritel(mask, bank->eint_base + reg_mask);\n\n\traw_spin_unlock_irqrestore(&bank->slock, flags);\n}\n\nstatic int exynos_irq_set_type(struct irq_data *irqd, unsigned int type)\n{\n\tstruct irq_chip *chip = irq_data_get_irq_chip(irqd);\n\tstruct exynos_irq_chip *our_chip = to_exynos_irq_chip(chip);\n\tstruct samsung_pin_bank *bank = irq_data_get_irq_chip_data(irqd);\n\tunsigned int shift = EXYNOS_EINT_CON_LEN * irqd->hwirq;\n\tunsigned int con, trig_type;\n\tunsigned long reg_con = our_chip->eint_con + bank->eint_offset;\n\n\tswitch (type) {\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\ttrig_type = EXYNOS_EINT_EDGE_RISING;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\ttrig_type = EXYNOS_EINT_EDGE_FALLING;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\ttrig_type = EXYNOS_EINT_EDGE_BOTH;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\ttrig_type = EXYNOS_EINT_LEVEL_HIGH;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\ttrig_type = EXYNOS_EINT_LEVEL_LOW;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"unsupported external interrupt type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (type & IRQ_TYPE_EDGE_BOTH)\n\t\tirq_set_handler_locked(irqd, handle_edge_irq);\n\telse\n\t\tirq_set_handler_locked(irqd, handle_level_irq);\n\n\tcon = readl(bank->eint_base + reg_con);\n\tcon &= ~(EXYNOS_EINT_CON_MASK << shift);\n\tcon |= trig_type << shift;\n\twritel(con, bank->eint_base + reg_con);\n\n\treturn 0;\n}\n\nstatic int exynos_irq_request_resources(struct irq_data *irqd)\n{\n\tstruct samsung_pin_bank *bank = irq_data_get_irq_chip_data(irqd);\n\tconst struct samsung_pin_bank_type *bank_type = bank->type;\n\tunsigned long reg_con, flags;\n\tunsigned int shift, mask, con;\n\tint ret;\n\n\tret = gpiochip_lock_as_irq(&bank->gpio_chip, irqd->hwirq);\n\tif (ret) {\n\t\tdev_err(bank->gpio_chip.parent,\n\t\t\t\"unable to lock pin %s-%lu IRQ\\n\",\n\t\t\tbank->name, irqd->hwirq);\n\t\treturn ret;\n\t}\n\n\treg_con = bank->pctl_offset + bank_type->reg_offset[PINCFG_TYPE_FUNC];\n\tshift = irqd->hwirq * bank_type->fld_width[PINCFG_TYPE_FUNC];\n\tmask = (1 << bank_type->fld_width[PINCFG_TYPE_FUNC]) - 1;\n\n\traw_spin_lock_irqsave(&bank->slock, flags);\n\n\tcon = readl(bank->pctl_base + reg_con);\n\tcon &= ~(mask << shift);\n\tcon |= EXYNOS_PIN_CON_FUNC_EINT << shift;\n\twritel(con, bank->pctl_base + reg_con);\n\n\traw_spin_unlock_irqrestore(&bank->slock, flags);\n\n\treturn 0;\n}\n\nstatic void exynos_irq_release_resources(struct irq_data *irqd)\n{\n\tstruct samsung_pin_bank *bank = irq_data_get_irq_chip_data(irqd);\n\tconst struct samsung_pin_bank_type *bank_type = bank->type;\n\tunsigned long reg_con, flags;\n\tunsigned int shift, mask, con;\n\n\treg_con = bank->pctl_offset + bank_type->reg_offset[PINCFG_TYPE_FUNC];\n\tshift = irqd->hwirq * bank_type->fld_width[PINCFG_TYPE_FUNC];\n\tmask = (1 << bank_type->fld_width[PINCFG_TYPE_FUNC]) - 1;\n\n\traw_spin_lock_irqsave(&bank->slock, flags);\n\n\tcon = readl(bank->pctl_base + reg_con);\n\tcon &= ~(mask << shift);\n\tcon |= PIN_CON_FUNC_INPUT << shift;\n\twritel(con, bank->pctl_base + reg_con);\n\n\traw_spin_unlock_irqrestore(&bank->slock, flags);\n\n\tgpiochip_unlock_as_irq(&bank->gpio_chip, irqd->hwirq);\n}\n\n \nstatic const struct exynos_irq_chip exynos_gpio_irq_chip __initconst = {\n\t.chip = {\n\t\t.name = \"exynos_gpio_irq_chip\",\n\t\t.irq_unmask = exynos_irq_unmask,\n\t\t.irq_mask = exynos_irq_mask,\n\t\t.irq_ack = exynos_irq_ack,\n\t\t.irq_set_type = exynos_irq_set_type,\n\t\t.irq_request_resources = exynos_irq_request_resources,\n\t\t.irq_release_resources = exynos_irq_release_resources,\n\t},\n\t.eint_con = EXYNOS_GPIO_ECON_OFFSET,\n\t.eint_mask = EXYNOS_GPIO_EMASK_OFFSET,\n\t.eint_pend = EXYNOS_GPIO_EPEND_OFFSET,\n\t \n};\n\nstatic int exynos_eint_irq_map(struct irq_domain *h, unsigned int virq,\n\t\t\t\t\tirq_hw_number_t hw)\n{\n\tstruct samsung_pin_bank *b = h->host_data;\n\n\tirq_set_chip_data(virq, b);\n\tirq_set_chip_and_handler(virq, &b->irq_chip->chip,\n\t\t\t\t\thandle_level_irq);\n\treturn 0;\n}\n\n \nstatic const struct irq_domain_ops exynos_eint_irqd_ops = {\n\t.map\t= exynos_eint_irq_map,\n\t.xlate\t= irq_domain_xlate_twocell,\n};\n\nstatic irqreturn_t exynos_eint_gpio_irq(int irq, void *data)\n{\n\tstruct samsung_pinctrl_drv_data *d = data;\n\tstruct samsung_pin_bank *bank = d->pin_banks;\n\tunsigned int svc, group, pin;\n\tint ret;\n\n\tsvc = readl(bank->eint_base + EXYNOS_SVC_OFFSET);\n\tgroup = EXYNOS_SVC_GROUP(svc);\n\tpin = svc & EXYNOS_SVC_NUM_MASK;\n\n\tif (!group)\n\t\treturn IRQ_HANDLED;\n\tbank += (group - 1);\n\n\tret = generic_handle_domain_irq(bank->irq_domain, pin);\n\tif (ret)\n\t\treturn IRQ_NONE;\n\n\treturn IRQ_HANDLED;\n}\n\nstruct exynos_eint_gpio_save {\n\tu32 eint_con;\n\tu32 eint_fltcon0;\n\tu32 eint_fltcon1;\n\tu32 eint_mask;\n};\n\n \n__init int exynos_eint_gpio_init(struct samsung_pinctrl_drv_data *d)\n{\n\tstruct samsung_pin_bank *bank;\n\tstruct device *dev = d->dev;\n\tint ret;\n\tint i;\n\n\tif (!d->irq) {\n\t\tdev_err(dev, \"irq number not available\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = devm_request_irq(dev, d->irq, exynos_eint_gpio_irq,\n\t\t\t\t\t0, dev_name(dev), d);\n\tif (ret) {\n\t\tdev_err(dev, \"irq request failed\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tbank = d->pin_banks;\n\tfor (i = 0; i < d->nr_banks; ++i, ++bank) {\n\t\tif (bank->eint_type != EINT_TYPE_GPIO)\n\t\t\tcontinue;\n\n\t\tbank->irq_chip = devm_kmemdup(dev, &exynos_gpio_irq_chip,\n\t\t\t\t\t   sizeof(*bank->irq_chip), GFP_KERNEL);\n\t\tif (!bank->irq_chip) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_domains;\n\t\t}\n\t\tbank->irq_chip->chip.name = bank->name;\n\n\t\tbank->irq_domain = irq_domain_create_linear(bank->fwnode,\n\t\t\t\tbank->nr_pins, &exynos_eint_irqd_ops, bank);\n\t\tif (!bank->irq_domain) {\n\t\t\tdev_err(dev, \"gpio irq domain add failed\\n\");\n\t\t\tret = -ENXIO;\n\t\t\tgoto err_domains;\n\t\t}\n\n\t\tbank->soc_priv = devm_kzalloc(d->dev,\n\t\t\tsizeof(struct exynos_eint_gpio_save), GFP_KERNEL);\n\t\tif (!bank->soc_priv) {\n\t\t\tirq_domain_remove(bank->irq_domain);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_domains;\n\t\t}\n\n\t}\n\n\treturn 0;\n\nerr_domains:\n\tfor (--i, --bank; i >= 0; --i, --bank) {\n\t\tif (bank->eint_type != EINT_TYPE_GPIO)\n\t\t\tcontinue;\n\t\tirq_domain_remove(bank->irq_domain);\n\t}\n\n\treturn ret;\n}\n\nstatic int exynos_wkup_irq_set_wake(struct irq_data *irqd, unsigned int on)\n{\n\tstruct irq_chip *chip = irq_data_get_irq_chip(irqd);\n\tstruct exynos_irq_chip *our_chip = to_exynos_irq_chip(chip);\n\tstruct samsung_pin_bank *bank = irq_data_get_irq_chip_data(irqd);\n\tunsigned long bit = 1UL << (2 * bank->eint_offset + irqd->hwirq);\n\n\tpr_info(\"wake %s for irq %u (%s-%lu)\\n\", on ? \"enabled\" : \"disabled\",\n\t\tirqd->irq, bank->name, irqd->hwirq);\n\n\tif (!on)\n\t\t*our_chip->eint_wake_mask_value |= bit;\n\telse\n\t\t*our_chip->eint_wake_mask_value &= ~bit;\n\n\treturn 0;\n}\n\nstatic void\nexynos_pinctrl_set_eint_wakeup_mask(struct samsung_pinctrl_drv_data *drvdata,\n\t\t\t\t    struct exynos_irq_chip *irq_chip)\n{\n\tstruct regmap *pmu_regs;\n\n\tif (!drvdata->retention_ctrl || !drvdata->retention_ctrl->priv) {\n\t\tdev_warn(drvdata->dev,\n\t\t\t \"No retention data configured bank with external wakeup interrupt. Wake-up mask will not be set.\\n\");\n\t\treturn;\n\t}\n\n\tpmu_regs = drvdata->retention_ctrl->priv;\n\tdev_info(drvdata->dev,\n\t\t \"Setting external wakeup interrupt mask: 0x%x\\n\",\n\t\t *irq_chip->eint_wake_mask_value);\n\n\tregmap_write(pmu_regs, irq_chip->eint_wake_mask_reg,\n\t\t     *irq_chip->eint_wake_mask_value);\n}\n\nstatic void\ns5pv210_pinctrl_set_eint_wakeup_mask(struct samsung_pinctrl_drv_data *drvdata,\n\t\t\t\t    struct exynos_irq_chip *irq_chip)\n\n{\n\tvoid __iomem *clk_base;\n\n\tif (!drvdata->retention_ctrl || !drvdata->retention_ctrl->priv) {\n\t\tdev_warn(drvdata->dev,\n\t\t\t \"No retention data configured bank with external wakeup interrupt. Wake-up mask will not be set.\\n\");\n\t\treturn;\n\t}\n\n\n\tclk_base = (void __iomem *) drvdata->retention_ctrl->priv;\n\n\t__raw_writel(*irq_chip->eint_wake_mask_value,\n\t\t     clk_base + irq_chip->eint_wake_mask_reg);\n}\n\nstatic u32 eint_wake_mask_value = EXYNOS_EINT_WAKEUP_MASK_DISABLED;\n \nstatic const struct exynos_irq_chip s5pv210_wkup_irq_chip __initconst = {\n\t.chip = {\n\t\t.name = \"s5pv210_wkup_irq_chip\",\n\t\t.irq_unmask = exynos_irq_unmask,\n\t\t.irq_mask = exynos_irq_mask,\n\t\t.irq_ack = exynos_irq_ack,\n\t\t.irq_set_type = exynos_irq_set_type,\n\t\t.irq_set_wake = exynos_wkup_irq_set_wake,\n\t\t.irq_request_resources = exynos_irq_request_resources,\n\t\t.irq_release_resources = exynos_irq_release_resources,\n\t},\n\t.eint_con = EXYNOS_WKUP_ECON_OFFSET,\n\t.eint_mask = EXYNOS_WKUP_EMASK_OFFSET,\n\t.eint_pend = EXYNOS_WKUP_EPEND_OFFSET,\n\t.eint_wake_mask_value = &eint_wake_mask_value,\n\t \n\t.eint_wake_mask_reg = S5PV210_EINT_WAKEUP_MASK,\n\t.set_eint_wakeup_mask = s5pv210_pinctrl_set_eint_wakeup_mask,\n};\n\nstatic const struct exynos_irq_chip exynos4210_wkup_irq_chip __initconst = {\n\t.chip = {\n\t\t.name = \"exynos4210_wkup_irq_chip\",\n\t\t.irq_unmask = exynos_irq_unmask,\n\t\t.irq_mask = exynos_irq_mask,\n\t\t.irq_ack = exynos_irq_ack,\n\t\t.irq_set_type = exynos_irq_set_type,\n\t\t.irq_set_wake = exynos_wkup_irq_set_wake,\n\t\t.irq_request_resources = exynos_irq_request_resources,\n\t\t.irq_release_resources = exynos_irq_release_resources,\n\t},\n\t.eint_con = EXYNOS_WKUP_ECON_OFFSET,\n\t.eint_mask = EXYNOS_WKUP_EMASK_OFFSET,\n\t.eint_pend = EXYNOS_WKUP_EPEND_OFFSET,\n\t.eint_wake_mask_value = &eint_wake_mask_value,\n\t.eint_wake_mask_reg = EXYNOS_EINT_WAKEUP_MASK,\n\t.set_eint_wakeup_mask = exynos_pinctrl_set_eint_wakeup_mask,\n};\n\nstatic const struct exynos_irq_chip exynos7_wkup_irq_chip __initconst = {\n\t.chip = {\n\t\t.name = \"exynos7_wkup_irq_chip\",\n\t\t.irq_unmask = exynos_irq_unmask,\n\t\t.irq_mask = exynos_irq_mask,\n\t\t.irq_ack = exynos_irq_ack,\n\t\t.irq_set_type = exynos_irq_set_type,\n\t\t.irq_set_wake = exynos_wkup_irq_set_wake,\n\t\t.irq_request_resources = exynos_irq_request_resources,\n\t\t.irq_release_resources = exynos_irq_release_resources,\n\t},\n\t.eint_con = EXYNOS7_WKUP_ECON_OFFSET,\n\t.eint_mask = EXYNOS7_WKUP_EMASK_OFFSET,\n\t.eint_pend = EXYNOS7_WKUP_EPEND_OFFSET,\n\t.eint_wake_mask_value = &eint_wake_mask_value,\n\t.eint_wake_mask_reg = EXYNOS5433_EINT_WAKEUP_MASK,\n\t.set_eint_wakeup_mask = exynos_pinctrl_set_eint_wakeup_mask,\n};\n\n \nstatic const struct of_device_id exynos_wkup_irq_ids[] = {\n\t{ .compatible = \"samsung,s5pv210-wakeup-eint\",\n\t\t\t.data = &s5pv210_wkup_irq_chip },\n\t{ .compatible = \"samsung,exynos4210-wakeup-eint\",\n\t\t\t.data = &exynos4210_wkup_irq_chip },\n\t{ .compatible = \"samsung,exynos7-wakeup-eint\",\n\t\t\t.data = &exynos7_wkup_irq_chip },\n\t{ .compatible = \"samsung,exynos850-wakeup-eint\",\n\t\t\t.data = &exynos7_wkup_irq_chip },\n\t{ .compatible = \"samsung,exynosautov9-wakeup-eint\",\n\t\t\t.data = &exynos7_wkup_irq_chip },\n\t{ }\n};\n\n \nstatic void exynos_irq_eint0_15(struct irq_desc *desc)\n{\n\tstruct exynos_weint_data *eintd = irq_desc_get_handler_data(desc);\n\tstruct samsung_pin_bank *bank = eintd->bank;\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\n\tchained_irq_enter(chip, desc);\n\n\tgeneric_handle_domain_irq(bank->irq_domain, eintd->irq);\n\n\tchained_irq_exit(chip, desc);\n}\n\nstatic inline void exynos_irq_demux_eint(unsigned int pend,\n\t\t\t\t\t\tstruct irq_domain *domain)\n{\n\tunsigned int irq;\n\n\twhile (pend) {\n\t\tirq = fls(pend) - 1;\n\t\tgeneric_handle_domain_irq(domain, irq);\n\t\tpend &= ~(1 << irq);\n\t}\n}\n\n \nstatic void exynos_irq_demux_eint16_31(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tstruct exynos_muxed_weint_data *eintd = irq_desc_get_handler_data(desc);\n\tunsigned int pend;\n\tunsigned int mask;\n\tint i;\n\n\tchained_irq_enter(chip, desc);\n\n\tfor (i = 0; i < eintd->nr_banks; ++i) {\n\t\tstruct samsung_pin_bank *b = eintd->banks[i];\n\t\tpend = readl(b->eint_base + b->irq_chip->eint_pend\n\t\t\t\t+ b->eint_offset);\n\t\tmask = readl(b->eint_base + b->irq_chip->eint_mask\n\t\t\t\t+ b->eint_offset);\n\t\texynos_irq_demux_eint(pend & ~mask, b->irq_domain);\n\t}\n\n\tchained_irq_exit(chip, desc);\n}\n\n \n__init int exynos_eint_wkup_init(struct samsung_pinctrl_drv_data *d)\n{\n\tstruct device *dev = d->dev;\n\tstruct device_node *wkup_np = NULL;\n\tstruct device_node *np;\n\tstruct samsung_pin_bank *bank;\n\tstruct exynos_weint_data *weint_data;\n\tstruct exynos_muxed_weint_data *muxed_data;\n\tconst struct exynos_irq_chip *irq_chip;\n\tunsigned int muxed_banks = 0;\n\tunsigned int i;\n\tint idx, irq;\n\n\tfor_each_child_of_node(dev->of_node, np) {\n\t\tconst struct of_device_id *match;\n\n\t\tmatch = of_match_node(exynos_wkup_irq_ids, np);\n\t\tif (match) {\n\t\t\tirq_chip = match->data;\n\t\t\twkup_np = np;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!wkup_np)\n\t\treturn -ENODEV;\n\n\tbank = d->pin_banks;\n\tfor (i = 0; i < d->nr_banks; ++i, ++bank) {\n\t\tif (bank->eint_type != EINT_TYPE_WKUP)\n\t\t\tcontinue;\n\n\t\tbank->irq_chip = devm_kmemdup(dev, irq_chip, sizeof(*irq_chip),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!bank->irq_chip) {\n\t\t\tof_node_put(wkup_np);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tbank->irq_chip->chip.name = bank->name;\n\n\t\tbank->irq_domain = irq_domain_create_linear(bank->fwnode,\n\t\t\t\tbank->nr_pins, &exynos_eint_irqd_ops, bank);\n\t\tif (!bank->irq_domain) {\n\t\t\tdev_err(dev, \"wkup irq domain add failed\\n\");\n\t\t\tof_node_put(wkup_np);\n\t\t\treturn -ENXIO;\n\t\t}\n\n\t\tif (!fwnode_property_present(bank->fwnode, \"interrupts\")) {\n\t\t\tbank->eint_type = EINT_TYPE_WKUP_MUX;\n\t\t\t++muxed_banks;\n\t\t\tcontinue;\n\t\t}\n\n\t\tweint_data = devm_kcalloc(dev,\n\t\t\t\t\t  bank->nr_pins, sizeof(*weint_data),\n\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!weint_data) {\n\t\t\tof_node_put(wkup_np);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tfor (idx = 0; idx < bank->nr_pins; ++idx) {\n\t\t\tirq = irq_of_parse_and_map(to_of_node(bank->fwnode), idx);\n\t\t\tif (!irq) {\n\t\t\t\tdev_err(dev, \"irq number for eint-%s-%d not found\\n\",\n\t\t\t\t\t\t\tbank->name, idx);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tweint_data[idx].irq = idx;\n\t\t\tweint_data[idx].bank = bank;\n\t\t\tirq_set_chained_handler_and_data(irq,\n\t\t\t\t\t\t\t exynos_irq_eint0_15,\n\t\t\t\t\t\t\t &weint_data[idx]);\n\t\t}\n\t}\n\n\tif (!muxed_banks) {\n\t\tof_node_put(wkup_np);\n\t\treturn 0;\n\t}\n\n\tirq = irq_of_parse_and_map(wkup_np, 0);\n\tof_node_put(wkup_np);\n\tif (!irq) {\n\t\tdev_err(dev, \"irq number for muxed EINTs not found\\n\");\n\t\treturn 0;\n\t}\n\n\tmuxed_data = devm_kzalloc(dev, sizeof(*muxed_data)\n\t\t+ muxed_banks*sizeof(struct samsung_pin_bank *), GFP_KERNEL);\n\tif (!muxed_data)\n\t\treturn -ENOMEM;\n\n\tirq_set_chained_handler_and_data(irq, exynos_irq_demux_eint16_31,\n\t\t\t\t\t muxed_data);\n\n\tbank = d->pin_banks;\n\tidx = 0;\n\tfor (i = 0; i < d->nr_banks; ++i, ++bank) {\n\t\tif (bank->eint_type != EINT_TYPE_WKUP_MUX)\n\t\t\tcontinue;\n\n\t\tmuxed_data->banks[idx++] = bank;\n\t}\n\tmuxed_data->nr_banks = muxed_banks;\n\n\treturn 0;\n}\n\nstatic void exynos_pinctrl_suspend_bank(\n\t\t\t\tstruct samsung_pinctrl_drv_data *drvdata,\n\t\t\t\tstruct samsung_pin_bank *bank)\n{\n\tstruct exynos_eint_gpio_save *save = bank->soc_priv;\n\tvoid __iomem *regs = bank->eint_base;\n\n\tsave->eint_con = readl(regs + EXYNOS_GPIO_ECON_OFFSET\n\t\t\t\t\t\t+ bank->eint_offset);\n\tsave->eint_fltcon0 = readl(regs + EXYNOS_GPIO_EFLTCON_OFFSET\n\t\t\t\t\t\t+ 2 * bank->eint_offset);\n\tsave->eint_fltcon1 = readl(regs + EXYNOS_GPIO_EFLTCON_OFFSET\n\t\t\t\t\t\t+ 2 * bank->eint_offset + 4);\n\tsave->eint_mask = readl(regs + bank->irq_chip->eint_mask\n\t\t\t\t\t\t+ bank->eint_offset);\n\n\tpr_debug(\"%s: save     con %#010x\\n\", bank->name, save->eint_con);\n\tpr_debug(\"%s: save fltcon0 %#010x\\n\", bank->name, save->eint_fltcon0);\n\tpr_debug(\"%s: save fltcon1 %#010x\\n\", bank->name, save->eint_fltcon1);\n\tpr_debug(\"%s: save    mask %#010x\\n\", bank->name, save->eint_mask);\n}\n\nvoid exynos_pinctrl_suspend(struct samsung_pinctrl_drv_data *drvdata)\n{\n\tstruct samsung_pin_bank *bank = drvdata->pin_banks;\n\tstruct exynos_irq_chip *irq_chip = NULL;\n\tint i;\n\n\tfor (i = 0; i < drvdata->nr_banks; ++i, ++bank) {\n\t\tif (bank->eint_type == EINT_TYPE_GPIO)\n\t\t\texynos_pinctrl_suspend_bank(drvdata, bank);\n\t\telse if (bank->eint_type == EINT_TYPE_WKUP) {\n\t\t\tif (!irq_chip) {\n\t\t\t\tirq_chip = bank->irq_chip;\n\t\t\t\tirq_chip->set_eint_wakeup_mask(drvdata,\n\t\t\t\t\t\t\t       irq_chip);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void exynos_pinctrl_resume_bank(\n\t\t\t\tstruct samsung_pinctrl_drv_data *drvdata,\n\t\t\t\tstruct samsung_pin_bank *bank)\n{\n\tstruct exynos_eint_gpio_save *save = bank->soc_priv;\n\tvoid __iomem *regs = bank->eint_base;\n\n\tpr_debug(\"%s:     con %#010x => %#010x\\n\", bank->name,\n\t\t\treadl(regs + EXYNOS_GPIO_ECON_OFFSET\n\t\t\t+ bank->eint_offset), save->eint_con);\n\tpr_debug(\"%s: fltcon0 %#010x => %#010x\\n\", bank->name,\n\t\t\treadl(regs + EXYNOS_GPIO_EFLTCON_OFFSET\n\t\t\t+ 2 * bank->eint_offset), save->eint_fltcon0);\n\tpr_debug(\"%s: fltcon1 %#010x => %#010x\\n\", bank->name,\n\t\t\treadl(regs + EXYNOS_GPIO_EFLTCON_OFFSET\n\t\t\t+ 2 * bank->eint_offset + 4), save->eint_fltcon1);\n\tpr_debug(\"%s:    mask %#010x => %#010x\\n\", bank->name,\n\t\t\treadl(regs + bank->irq_chip->eint_mask\n\t\t\t+ bank->eint_offset), save->eint_mask);\n\n\twritel(save->eint_con, regs + EXYNOS_GPIO_ECON_OFFSET\n\t\t\t\t\t\t+ bank->eint_offset);\n\twritel(save->eint_fltcon0, regs + EXYNOS_GPIO_EFLTCON_OFFSET\n\t\t\t\t\t\t+ 2 * bank->eint_offset);\n\twritel(save->eint_fltcon1, regs + EXYNOS_GPIO_EFLTCON_OFFSET\n\t\t\t\t\t\t+ 2 * bank->eint_offset + 4);\n\twritel(save->eint_mask, regs + bank->irq_chip->eint_mask\n\t\t\t\t\t\t+ bank->eint_offset);\n}\n\nvoid exynos_pinctrl_resume(struct samsung_pinctrl_drv_data *drvdata)\n{\n\tstruct samsung_pin_bank *bank = drvdata->pin_banks;\n\tint i;\n\n\tfor (i = 0; i < drvdata->nr_banks; ++i, ++bank)\n\t\tif (bank->eint_type == EINT_TYPE_GPIO)\n\t\t\texynos_pinctrl_resume_bank(drvdata, bank);\n}\n\nstatic void exynos_retention_enable(struct samsung_pinctrl_drv_data *drvdata)\n{\n\tif (drvdata->retention_ctrl->refcnt)\n\t\tatomic_inc(drvdata->retention_ctrl->refcnt);\n}\n\nstatic void exynos_retention_disable(struct samsung_pinctrl_drv_data *drvdata)\n{\n\tstruct samsung_retention_ctrl *ctrl = drvdata->retention_ctrl;\n\tstruct regmap *pmu_regs = ctrl->priv;\n\tint i;\n\n\tif (ctrl->refcnt && !atomic_dec_and_test(ctrl->refcnt))\n\t\treturn;\n\n\tfor (i = 0; i < ctrl->nr_regs; i++)\n\t\tregmap_write(pmu_regs, ctrl->regs[i], ctrl->value);\n}\n\nstruct samsung_retention_ctrl *\nexynos_retention_init(struct samsung_pinctrl_drv_data *drvdata,\n\t\t      const struct samsung_retention_data *data)\n{\n\tstruct samsung_retention_ctrl *ctrl;\n\tstruct regmap *pmu_regs;\n\tint i;\n\n\tctrl = devm_kzalloc(drvdata->dev, sizeof(*ctrl), GFP_KERNEL);\n\tif (!ctrl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpmu_regs = exynos_get_pmu_regmap();\n\tif (IS_ERR(pmu_regs))\n\t\treturn ERR_CAST(pmu_regs);\n\n\tctrl->priv = pmu_regs;\n\tctrl->regs = data->regs;\n\tctrl->nr_regs = data->nr_regs;\n\tctrl->value = data->value;\n\tctrl->refcnt = data->refcnt;\n\tctrl->enable = exynos_retention_enable;\n\tctrl->disable = exynos_retention_disable;\n\n\t \n\tfor (i = 0; i < ctrl->nr_regs; i++)\n\t\tregmap_write(pmu_regs, ctrl->regs[i], ctrl->value);\n\n\treturn ctrl;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}