{
  "module_name": "pinctrl-s3c64xx.c",
  "hash_id": "c03639aa1c3ae22810b40b87a7610280d262bcb26899cfa3e132852e98939051",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/samsung/pinctrl-s3c64xx.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/interrupt.h>\n#include <linux/irqdomain.h>\n#include <linux/irq.h>\n#include <linux/of_irq.h>\n#include <linux/io.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\n#include \"pinctrl-samsung.h\"\n\n#define NUM_EINT0\t\t28\n#define NUM_EINT0_IRQ\t\t4\n#define EINT_MAX_PER_REG\t16\n#define EINT_MAX_PER_GROUP\t16\n\n \n#define SVC_GROUP_SHIFT\t\t4\n#define SVC_GROUP_MASK\t\t0xf\n#define SVC_NUM_MASK\t\t0xf\n#define SVC_GROUP(x)\t\t((x >> SVC_GROUP_SHIFT) & \\\n\t\t\t\t\t\tSVC_GROUP_MASK)\n\n#define EINT12CON_REG\t\t0x200\n#define EINT12MASK_REG\t\t0x240\n#define EINT12PEND_REG\t\t0x260\n\n#define EINT_OFFS(i)\t\t((i) % (2 * EINT_MAX_PER_GROUP))\n#define EINT_GROUP(i)\t\t((i) / EINT_MAX_PER_GROUP)\n#define EINT_REG(g)\t\t(4 * ((g) / 2))\n\n#define EINTCON_REG(i)\t\t(EINT12CON_REG + EINT_REG(EINT_GROUP(i)))\n#define EINTMASK_REG(i)\t\t(EINT12MASK_REG + EINT_REG(EINT_GROUP(i)))\n#define EINTPEND_REG(i)\t\t(EINT12PEND_REG + EINT_REG(EINT_GROUP(i)))\n\n#define SERVICE_REG\t\t0x284\n#define SERVICEPEND_REG\t\t0x288\n\n#define EINT0CON0_REG\t\t0x900\n#define EINT0MASK_REG\t\t0x920\n#define EINT0PEND_REG\t\t0x924\n\n \n#define EINT_LEVEL_LOW\t\t0\n#define EINT_LEVEL_HIGH\t\t1\n#define EINT_EDGE_FALLING\t2\n#define EINT_EDGE_RISING\t4\n#define EINT_EDGE_BOTH\t\t6\n#define EINT_CON_MASK\t\t0xF\n#define EINT_CON_LEN\t\t4\n\nstatic const struct samsung_pin_bank_type bank_type_4bit_off = {\n\t.fld_width = { 4, 1, 2, 0, 2, 2, },\n\t.reg_offset = { 0x00, 0x04, 0x08, 0, 0x0c, 0x10, },\n};\n\nstatic const struct samsung_pin_bank_type bank_type_4bit_alive = {\n\t.fld_width = { 4, 1, 2, },\n\t.reg_offset = { 0x00, 0x04, 0x08, },\n};\n\nstatic const struct samsung_pin_bank_type bank_type_4bit2_off = {\n\t.fld_width = { 4, 1, 2, 0, 2, 2, },\n\t.reg_offset = { 0x00, 0x08, 0x0c, 0, 0x10, 0x14, },\n};\n\nstatic const struct samsung_pin_bank_type bank_type_4bit2_alive = {\n\t.fld_width = { 4, 1, 2, },\n\t.reg_offset = { 0x00, 0x08, 0x0c, },\n};\n\nstatic const struct samsung_pin_bank_type bank_type_2bit_off = {\n\t.fld_width = { 2, 1, 2, 0, 2, 2, },\n\t.reg_offset = { 0x00, 0x04, 0x08, 0, 0x0c, 0x10, },\n};\n\nstatic const struct samsung_pin_bank_type bank_type_2bit_alive = {\n\t.fld_width = { 2, 1, 2, },\n\t.reg_offset = { 0x00, 0x04, 0x08, },\n};\n\n#define PIN_BANK_4BIT(pins, reg, id)\t\t\t\\\n\t{\t\t\t\t\t\t\\\n\t\t.type\t\t= &bank_type_4bit_off,\t\\\n\t\t.pctl_offset\t= reg,\t\t\t\\\n\t\t.nr_pins\t= pins,\t\t\t\\\n\t\t.eint_type\t= EINT_TYPE_NONE,\t\\\n\t\t.name\t\t= id\t\t\t\\\n\t}\n\n#define PIN_BANK_4BIT_EINTG(pins, reg, id, eoffs)\t\\\n\t{\t\t\t\t\t\t\\\n\t\t.type\t\t= &bank_type_4bit_off,\t\\\n\t\t.pctl_offset\t= reg,\t\t\t\\\n\t\t.nr_pins\t= pins,\t\t\t\\\n\t\t.eint_type\t= EINT_TYPE_GPIO,\t\\\n\t\t.eint_func\t= 7,\t\t\t\\\n\t\t.eint_mask\t= (1 << (pins)) - 1,\t\\\n\t\t.eint_offset\t= eoffs,\t\t\\\n\t\t.name\t\t= id\t\t\t\\\n\t}\n\n#define PIN_BANK_4BIT_EINTW(pins, reg, id, eoffs, emask) \\\n\t{\t\t\t\t\t\t\\\n\t\t.type\t\t= &bank_type_4bit_alive,\\\n\t\t.pctl_offset\t= reg,\t\t\t\\\n\t\t.nr_pins\t= pins,\t\t\t\\\n\t\t.eint_type\t= EINT_TYPE_WKUP,\t\\\n\t\t.eint_func\t= 3,\t\t\t\\\n\t\t.eint_mask\t= emask,\t\t\\\n\t\t.eint_offset\t= eoffs,\t\t\\\n\t\t.name\t\t= id\t\t\t\\\n\t}\n\n#define PIN_BANK_4BIT2_EINTG(pins, reg, id, eoffs)\t\\\n\t{\t\t\t\t\t\t\\\n\t\t.type\t\t= &bank_type_4bit2_off,\t\\\n\t\t.pctl_offset\t= reg,\t\t\t\\\n\t\t.nr_pins\t= pins,\t\t\t\\\n\t\t.eint_type\t= EINT_TYPE_GPIO,\t\\\n\t\t.eint_func\t= 7,\t\t\t\\\n\t\t.eint_mask\t= (1 << (pins)) - 1,\t\\\n\t\t.eint_offset\t= eoffs,\t\t\\\n\t\t.name\t\t= id\t\t\t\\\n\t}\n\n#define PIN_BANK_4BIT2_EINTW(pins, reg, id, eoffs, emask) \\\n\t{\t\t\t\t\t\t\\\n\t\t.type\t\t= &bank_type_4bit2_alive,\\\n\t\t.pctl_offset\t= reg,\t\t\t\\\n\t\t.nr_pins\t= pins,\t\t\t\\\n\t\t.eint_type\t= EINT_TYPE_WKUP,\t\\\n\t\t.eint_func\t= 3,\t\t\t\\\n\t\t.eint_mask\t= emask,\t\t\\\n\t\t.eint_offset\t= eoffs,\t\t\\\n\t\t.name\t\t= id\t\t\t\\\n\t}\n\n#define PIN_BANK_4BIT2_ALIVE(pins, reg, id)\t\t\\\n\t{\t\t\t\t\t\t\\\n\t\t.type\t\t= &bank_type_4bit2_alive,\\\n\t\t.pctl_offset\t= reg,\t\t\t\\\n\t\t.nr_pins\t= pins,\t\t\t\\\n\t\t.eint_type\t= EINT_TYPE_NONE,\t\\\n\t\t.name\t\t= id\t\t\t\\\n\t}\n\n#define PIN_BANK_2BIT(pins, reg, id)\t\t\t\\\n\t{\t\t\t\t\t\t\\\n\t\t.type\t\t= &bank_type_2bit_off,\t\\\n\t\t.pctl_offset\t= reg,\t\t\t\\\n\t\t.nr_pins\t= pins,\t\t\t\\\n\t\t.eint_type\t= EINT_TYPE_NONE,\t\\\n\t\t.name\t\t= id\t\t\t\\\n\t}\n\n#define PIN_BANK_2BIT_EINTG(pins, reg, id, eoffs, emask) \\\n\t{\t\t\t\t\t\t\\\n\t\t.type\t\t= &bank_type_2bit_off,\t\\\n\t\t.pctl_offset\t= reg,\t\t\t\\\n\t\t.nr_pins\t= pins,\t\t\t\\\n\t\t.eint_type\t= EINT_TYPE_GPIO,\t\\\n\t\t.eint_func\t= 3,\t\t\t\\\n\t\t.eint_mask\t= emask,\t\t\\\n\t\t.eint_offset\t= eoffs,\t\t\\\n\t\t.name\t\t= id\t\t\t\\\n\t}\n\n#define PIN_BANK_2BIT_EINTW(pins, reg, id, eoffs)\t\\\n\t{\t\t\t\t\t\t\\\n\t\t.type\t\t= &bank_type_2bit_alive,\\\n\t\t.pctl_offset\t= reg,\t\t\t\\\n\t\t.nr_pins\t= pins,\t\t\t\\\n\t\t.eint_type\t= EINT_TYPE_WKUP,\t\\\n\t\t.eint_func\t= 2,\t\t\t\\\n\t\t.eint_mask\t= (1 << (pins)) - 1,\t\\\n\t\t.eint_offset\t= eoffs,\t\t\\\n\t\t.name\t\t= id\t\t\t\\\n\t}\n\n \nstruct s3c64xx_eint0_data {\n\tstruct samsung_pinctrl_drv_data *drvdata;\n\tstruct irq_domain *domains[NUM_EINT0];\n\tu8 pins[NUM_EINT0];\n};\n\n \nstruct s3c64xx_eint0_domain_data {\n\tstruct samsung_pin_bank *bank;\n\tu8 eints[];\n};\n\n \nstruct s3c64xx_eint_gpio_data {\n\tstruct samsung_pinctrl_drv_data *drvdata;\n\tstruct irq_domain *domains[];\n};\n\n \n\nstatic int s3c64xx_irq_get_trigger(unsigned int type)\n{\n\tint trigger;\n\n\tswitch (type) {\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\ttrigger = EINT_EDGE_RISING;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\ttrigger = EINT_EDGE_FALLING;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\ttrigger = EINT_EDGE_BOTH;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\ttrigger = EINT_LEVEL_HIGH;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\ttrigger = EINT_LEVEL_LOW;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn trigger;\n}\n\nstatic void s3c64xx_irq_set_handler(struct irq_data *d, unsigned int type)\n{\n\t \n\tif (type & IRQ_TYPE_EDGE_BOTH)\n\t\tirq_set_handler_locked(d, handle_edge_irq);\n\telse\n\t\tirq_set_handler_locked(d, handle_level_irq);\n}\n\nstatic void s3c64xx_irq_set_function(struct samsung_pinctrl_drv_data *d,\n\t\t\t\t\tstruct samsung_pin_bank *bank, int pin)\n{\n\tconst struct samsung_pin_bank_type *bank_type = bank->type;\n\tunsigned long flags;\n\tvoid __iomem *reg;\n\tu8 shift;\n\tu32 mask;\n\tu32 val;\n\n\t \n\treg = d->virt_base + bank->pctl_offset;\n\tshift = pin;\n\tif (bank_type->fld_width[PINCFG_TYPE_FUNC] * shift >= 32) {\n\t\t \n\t\treg += 4;\n\t\tshift -= 8;\n\t}\n\n\tshift = shift * bank_type->fld_width[PINCFG_TYPE_FUNC];\n\tmask = (1 << bank_type->fld_width[PINCFG_TYPE_FUNC]) - 1;\n\n\traw_spin_lock_irqsave(&bank->slock, flags);\n\n\tval = readl(reg);\n\tval &= ~(mask << shift);\n\tval |= bank->eint_func << shift;\n\twritel(val, reg);\n\n\traw_spin_unlock_irqrestore(&bank->slock, flags);\n}\n\n \n\nstatic inline void s3c64xx_gpio_irq_set_mask(struct irq_data *irqd, bool mask)\n{\n\tstruct samsung_pin_bank *bank = irq_data_get_irq_chip_data(irqd);\n\tstruct samsung_pinctrl_drv_data *d = bank->drvdata;\n\tunsigned char index = EINT_OFFS(bank->eint_offset) + irqd->hwirq;\n\tvoid __iomem *reg = d->virt_base + EINTMASK_REG(bank->eint_offset);\n\tu32 val;\n\n\tval = readl(reg);\n\tif (mask)\n\t\tval |= 1 << index;\n\telse\n\t\tval &= ~(1 << index);\n\twritel(val, reg);\n}\n\nstatic void s3c64xx_gpio_irq_unmask(struct irq_data *irqd)\n{\n\ts3c64xx_gpio_irq_set_mask(irqd, false);\n}\n\nstatic void s3c64xx_gpio_irq_mask(struct irq_data *irqd)\n{\n\ts3c64xx_gpio_irq_set_mask(irqd, true);\n}\n\nstatic void s3c64xx_gpio_irq_ack(struct irq_data *irqd)\n{\n\tstruct samsung_pin_bank *bank = irq_data_get_irq_chip_data(irqd);\n\tstruct samsung_pinctrl_drv_data *d = bank->drvdata;\n\tunsigned char index = EINT_OFFS(bank->eint_offset) + irqd->hwirq;\n\tvoid __iomem *reg = d->virt_base + EINTPEND_REG(bank->eint_offset);\n\n\twritel(1 << index, reg);\n}\n\nstatic int s3c64xx_gpio_irq_set_type(struct irq_data *irqd, unsigned int type)\n{\n\tstruct samsung_pin_bank *bank = irq_data_get_irq_chip_data(irqd);\n\tstruct samsung_pinctrl_drv_data *d = bank->drvdata;\n\tvoid __iomem *reg;\n\tint trigger;\n\tu8 shift;\n\tu32 val;\n\n\ttrigger = s3c64xx_irq_get_trigger(type);\n\tif (trigger < 0) {\n\t\tpr_err(\"unsupported external interrupt type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ts3c64xx_irq_set_handler(irqd, type);\n\n\t \n\treg = d->virt_base + EINTCON_REG(bank->eint_offset);\n\tshift = EINT_OFFS(bank->eint_offset) + irqd->hwirq;\n\tshift = 4 * (shift / 4);  \n\n\tval = readl(reg);\n\tval &= ~(EINT_CON_MASK << shift);\n\tval |= trigger << shift;\n\twritel(val, reg);\n\n\ts3c64xx_irq_set_function(d, bank, irqd->hwirq);\n\n\treturn 0;\n}\n\n \nstatic struct irq_chip s3c64xx_gpio_irq_chip = {\n\t.name\t\t= \"GPIO\",\n\t.irq_unmask\t= s3c64xx_gpio_irq_unmask,\n\t.irq_mask\t= s3c64xx_gpio_irq_mask,\n\t.irq_ack\t= s3c64xx_gpio_irq_ack,\n\t.irq_set_type\t= s3c64xx_gpio_irq_set_type,\n};\n\nstatic int s3c64xx_gpio_irq_map(struct irq_domain *h, unsigned int virq,\n\t\t\t\t\tirq_hw_number_t hw)\n{\n\tstruct samsung_pin_bank *bank = h->host_data;\n\n\tif (!(bank->eint_mask & (1 << hw)))\n\t\treturn -EINVAL;\n\n\tirq_set_chip_and_handler(virq,\n\t\t\t\t&s3c64xx_gpio_irq_chip, handle_level_irq);\n\tirq_set_chip_data(virq, bank);\n\n\treturn 0;\n}\n\n \nstatic const struct irq_domain_ops s3c64xx_gpio_irqd_ops = {\n\t.map\t= s3c64xx_gpio_irq_map,\n\t.xlate\t= irq_domain_xlate_twocell,\n};\n\nstatic void s3c64xx_eint_gpio_irq(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tstruct s3c64xx_eint_gpio_data *data = irq_desc_get_handler_data(desc);\n\tstruct samsung_pinctrl_drv_data *drvdata = data->drvdata;\n\n\tchained_irq_enter(chip, desc);\n\n\tdo {\n\t\tunsigned int svc;\n\t\tunsigned int group;\n\t\tunsigned int pin;\n\t\tint ret;\n\n\t\tsvc = readl(drvdata->virt_base + SERVICE_REG);\n\t\tgroup = SVC_GROUP(svc);\n\t\tpin = svc & SVC_NUM_MASK;\n\n\t\tif (!group)\n\t\t\tbreak;\n\n\t\t \n\t\tif (group == 1) {\n\t\t\tif (pin < 8)\n\t\t\t\tgroup = 0;\n\t\t\telse\n\t\t\t\tpin -= 8;\n\t\t}\n\n\t\tret = generic_handle_domain_irq(data->domains[group], pin);\n\t\t \n\t\tBUG_ON(ret);\n\t} while (1);\n\n\tchained_irq_exit(chip, desc);\n}\n\n \nstatic int s3c64xx_eint_gpio_init(struct samsung_pinctrl_drv_data *d)\n{\n\tstruct s3c64xx_eint_gpio_data *data;\n\tstruct samsung_pin_bank *bank;\n\tstruct device *dev = d->dev;\n\tunsigned int nr_domains;\n\tunsigned int i;\n\n\tif (!d->irq) {\n\t\tdev_err(dev, \"irq number not available\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tnr_domains = 0;\n\tbank = d->pin_banks;\n\tfor (i = 0; i < d->nr_banks; ++i, ++bank) {\n\t\tunsigned int nr_eints;\n\t\tunsigned int mask;\n\n\t\tif (bank->eint_type != EINT_TYPE_GPIO)\n\t\t\tcontinue;\n\n\t\tmask = bank->eint_mask;\n\t\tnr_eints = fls(mask);\n\n\t\tbank->irq_domain = irq_domain_create_linear(bank->fwnode,\n\t\t\t\t\tnr_eints, &s3c64xx_gpio_irqd_ops, bank);\n\t\tif (!bank->irq_domain) {\n\t\t\tdev_err(dev, \"gpio irq domain add failed\\n\");\n\t\t\treturn -ENXIO;\n\t\t}\n\n\t\t++nr_domains;\n\t}\n\n\tdata = devm_kzalloc(dev, struct_size(data, domains, nr_domains),\n\t\t\t    GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\tdata->drvdata = d;\n\n\tbank = d->pin_banks;\n\tnr_domains = 0;\n\tfor (i = 0; i < d->nr_banks; ++i, ++bank) {\n\t\tif (bank->eint_type != EINT_TYPE_GPIO)\n\t\t\tcontinue;\n\n\t\tdata->domains[nr_domains++] = bank->irq_domain;\n\t}\n\n\tirq_set_chained_handler_and_data(d->irq, s3c64xx_eint_gpio_irq, data);\n\n\treturn 0;\n}\n\n \n\nstatic inline void s3c64xx_eint0_irq_set_mask(struct irq_data *irqd, bool mask)\n{\n\tstruct s3c64xx_eint0_domain_data *ddata =\n\t\t\t\t\tirq_data_get_irq_chip_data(irqd);\n\tstruct samsung_pinctrl_drv_data *d = ddata->bank->drvdata;\n\tu32 val;\n\n\tval = readl(d->virt_base + EINT0MASK_REG);\n\tif (mask)\n\t\tval |= 1 << ddata->eints[irqd->hwirq];\n\telse\n\t\tval &= ~(1 << ddata->eints[irqd->hwirq]);\n\twritel(val, d->virt_base + EINT0MASK_REG);\n}\n\nstatic void s3c64xx_eint0_irq_unmask(struct irq_data *irqd)\n{\n\ts3c64xx_eint0_irq_set_mask(irqd, false);\n}\n\nstatic void s3c64xx_eint0_irq_mask(struct irq_data *irqd)\n{\n\ts3c64xx_eint0_irq_set_mask(irqd, true);\n}\n\nstatic void s3c64xx_eint0_irq_ack(struct irq_data *irqd)\n{\n\tstruct s3c64xx_eint0_domain_data *ddata =\n\t\t\t\t\tirq_data_get_irq_chip_data(irqd);\n\tstruct samsung_pinctrl_drv_data *d = ddata->bank->drvdata;\n\n\twritel(1 << ddata->eints[irqd->hwirq],\n\t\t\t\t\td->virt_base + EINT0PEND_REG);\n}\n\nstatic int s3c64xx_eint0_irq_set_type(struct irq_data *irqd, unsigned int type)\n{\n\tstruct s3c64xx_eint0_domain_data *ddata =\n\t\t\t\t\tirq_data_get_irq_chip_data(irqd);\n\tstruct samsung_pin_bank *bank = ddata->bank;\n\tstruct samsung_pinctrl_drv_data *d = bank->drvdata;\n\tvoid __iomem *reg;\n\tint trigger;\n\tu8 shift;\n\tu32 val;\n\n\ttrigger = s3c64xx_irq_get_trigger(type);\n\tif (trigger < 0) {\n\t\tpr_err(\"unsupported external interrupt type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ts3c64xx_irq_set_handler(irqd, type);\n\n\t \n\treg = d->virt_base + EINT0CON0_REG;\n\tshift = ddata->eints[irqd->hwirq];\n\tif (shift >= EINT_MAX_PER_REG) {\n\t\treg += 4;\n\t\tshift -= EINT_MAX_PER_REG;\n\t}\n\tshift = EINT_CON_LEN * (shift / 2);\n\n\tval = readl(reg);\n\tval &= ~(EINT_CON_MASK << shift);\n\tval |= trigger << shift;\n\twritel(val, reg);\n\n\ts3c64xx_irq_set_function(d, bank, irqd->hwirq);\n\n\treturn 0;\n}\n\n \nstatic struct irq_chip s3c64xx_eint0_irq_chip = {\n\t.name\t\t= \"EINT0\",\n\t.irq_unmask\t= s3c64xx_eint0_irq_unmask,\n\t.irq_mask\t= s3c64xx_eint0_irq_mask,\n\t.irq_ack\t= s3c64xx_eint0_irq_ack,\n\t.irq_set_type\t= s3c64xx_eint0_irq_set_type,\n};\n\nstatic inline void s3c64xx_irq_demux_eint(struct irq_desc *desc, u32 range)\n{\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tstruct s3c64xx_eint0_data *data = irq_desc_get_handler_data(desc);\n\tstruct samsung_pinctrl_drv_data *drvdata = data->drvdata;\n\tunsigned int pend, mask;\n\n\tchained_irq_enter(chip, desc);\n\n\tpend = readl(drvdata->virt_base + EINT0PEND_REG);\n\tmask = readl(drvdata->virt_base + EINT0MASK_REG);\n\n\tpend = pend & range & ~mask;\n\tpend &= range;\n\n\twhile (pend) {\n\t\tunsigned int irq;\n\t\tint ret;\n\n\t\tirq = fls(pend) - 1;\n\t\tpend &= ~(1 << irq);\n\t\tret = generic_handle_domain_irq(data->domains[irq], data->pins[irq]);\n\t\t \n\t\tBUG_ON(ret);\n\t}\n\n\tchained_irq_exit(chip, desc);\n}\n\nstatic void s3c64xx_demux_eint0_3(struct irq_desc *desc)\n{\n\ts3c64xx_irq_demux_eint(desc, 0xf);\n}\n\nstatic void s3c64xx_demux_eint4_11(struct irq_desc *desc)\n{\n\ts3c64xx_irq_demux_eint(desc, 0xff0);\n}\n\nstatic void s3c64xx_demux_eint12_19(struct irq_desc *desc)\n{\n\ts3c64xx_irq_demux_eint(desc, 0xff000);\n}\n\nstatic void s3c64xx_demux_eint20_27(struct irq_desc *desc)\n{\n\ts3c64xx_irq_demux_eint(desc, 0xff00000);\n}\n\nstatic irq_flow_handler_t s3c64xx_eint0_handlers[NUM_EINT0_IRQ] = {\n\ts3c64xx_demux_eint0_3,\n\ts3c64xx_demux_eint4_11,\n\ts3c64xx_demux_eint12_19,\n\ts3c64xx_demux_eint20_27,\n};\n\nstatic int s3c64xx_eint0_irq_map(struct irq_domain *h, unsigned int virq,\n\t\t\t\t\tirq_hw_number_t hw)\n{\n\tstruct s3c64xx_eint0_domain_data *ddata = h->host_data;\n\tstruct samsung_pin_bank *bank = ddata->bank;\n\n\tif (!(bank->eint_mask & (1 << hw)))\n\t\treturn -EINVAL;\n\n\tirq_set_chip_and_handler(virq,\n\t\t\t\t&s3c64xx_eint0_irq_chip, handle_level_irq);\n\tirq_set_chip_data(virq, ddata);\n\n\treturn 0;\n}\n\n \nstatic const struct irq_domain_ops s3c64xx_eint0_irqd_ops = {\n\t.map\t= s3c64xx_eint0_irq_map,\n\t.xlate\t= irq_domain_xlate_twocell,\n};\n\n \nstatic const struct of_device_id s3c64xx_eint0_irq_ids[] = {\n\t{ .compatible = \"samsung,s3c64xx-wakeup-eint\", },\n\t{ }\n};\n\n \nstatic int s3c64xx_eint_eint0_init(struct samsung_pinctrl_drv_data *d)\n{\n\tstruct device *dev = d->dev;\n\tstruct device_node *eint0_np = NULL;\n\tstruct device_node *np;\n\tstruct samsung_pin_bank *bank;\n\tstruct s3c64xx_eint0_data *data;\n\tunsigned int i;\n\n\tfor_each_child_of_node(dev->of_node, np) {\n\t\tif (of_match_node(s3c64xx_eint0_irq_ids, np)) {\n\t\t\teint0_np = np;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!eint0_np)\n\t\treturn -ENODEV;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data) {\n\t\tof_node_put(eint0_np);\n\t\treturn -ENOMEM;\n\t}\n\tdata->drvdata = d;\n\n\tfor (i = 0; i < NUM_EINT0_IRQ; ++i) {\n\t\tunsigned int irq;\n\n\t\tirq = irq_of_parse_and_map(eint0_np, i);\n\t\tif (!irq) {\n\t\t\tdev_err(dev, \"failed to get wakeup EINT IRQ %d\\n\", i);\n\t\t\tof_node_put(eint0_np);\n\t\t\treturn -ENXIO;\n\t\t}\n\n\t\tirq_set_chained_handler_and_data(irq,\n\t\t\t\t\t\t s3c64xx_eint0_handlers[i],\n\t\t\t\t\t\t data);\n\t}\n\tof_node_put(eint0_np);\n\n\tbank = d->pin_banks;\n\tfor (i = 0; i < d->nr_banks; ++i, ++bank) {\n\t\tstruct s3c64xx_eint0_domain_data *ddata;\n\t\tunsigned int nr_eints;\n\t\tunsigned int mask;\n\t\tunsigned int irq;\n\t\tunsigned int pin;\n\n\t\tif (bank->eint_type != EINT_TYPE_WKUP)\n\t\t\tcontinue;\n\n\t\tmask = bank->eint_mask;\n\t\tnr_eints = fls(mask);\n\n\t\tddata = devm_kzalloc(dev,\n\t\t\t\tsizeof(*ddata) + nr_eints, GFP_KERNEL);\n\t\tif (!ddata)\n\t\t\treturn -ENOMEM;\n\t\tddata->bank = bank;\n\n\t\tbank->irq_domain = irq_domain_create_linear(bank->fwnode,\n\t\t\t\tnr_eints, &s3c64xx_eint0_irqd_ops, ddata);\n\t\tif (!bank->irq_domain) {\n\t\t\tdev_err(dev, \"wkup irq domain add failed\\n\");\n\t\t\treturn -ENXIO;\n\t\t}\n\n\t\tirq = bank->eint_offset;\n\t\tmask = bank->eint_mask;\n\t\tfor (pin = 0; mask; ++pin, mask >>= 1) {\n\t\t\tif (!(mask & 1))\n\t\t\t\tcontinue;\n\t\t\tdata->domains[irq] = bank->irq_domain;\n\t\t\tdata->pins[irq] = pin;\n\t\t\tddata->eints[pin] = irq;\n\t\t\t++irq;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic const struct samsung_pin_bank_data s3c64xx_pin_banks0[] __initconst = {\n\tPIN_BANK_4BIT_EINTG(8, 0x000, \"gpa\", 0),\n\tPIN_BANK_4BIT_EINTG(7, 0x020, \"gpb\", 8),\n\tPIN_BANK_4BIT_EINTG(8, 0x040, \"gpc\", 16),\n\tPIN_BANK_4BIT_EINTG(5, 0x060, \"gpd\", 32),\n\tPIN_BANK_4BIT(5, 0x080, \"gpe\"),\n\tPIN_BANK_2BIT_EINTG(16, 0x0a0, \"gpf\", 48, 0x3fff),\n\tPIN_BANK_4BIT_EINTG(7, 0x0c0, \"gpg\", 64),\n\tPIN_BANK_4BIT2_EINTG(10, 0x0e0, \"gph\", 80),\n\tPIN_BANK_2BIT(16, 0x100, \"gpi\"),\n\tPIN_BANK_2BIT(12, 0x120, \"gpj\"),\n\tPIN_BANK_4BIT2_ALIVE(16, 0x800, \"gpk\"),\n\tPIN_BANK_4BIT2_EINTW(15, 0x810, \"gpl\", 16, 0x7f00),\n\tPIN_BANK_4BIT_EINTW(6, 0x820, \"gpm\", 23, 0x1f),\n\tPIN_BANK_2BIT_EINTW(16, 0x830, \"gpn\", 0),\n\tPIN_BANK_2BIT_EINTG(16, 0x140, \"gpo\", 96, 0xffff),\n\tPIN_BANK_2BIT_EINTG(15, 0x160, \"gpp\", 112, 0x7fff),\n\tPIN_BANK_2BIT_EINTG(9, 0x180, \"gpq\", 128, 0x1ff),\n};\n\n \nstatic const struct samsung_pin_ctrl s3c64xx_pin_ctrl[] __initconst = {\n\t{\n\t\t \n\t\t.pin_banks\t= s3c64xx_pin_banks0,\n\t\t.nr_banks\t= ARRAY_SIZE(s3c64xx_pin_banks0),\n\t\t.eint_gpio_init = s3c64xx_eint_gpio_init,\n\t\t.eint_wkup_init = s3c64xx_eint_eint0_init,\n\t},\n};\n\nconst struct samsung_pinctrl_of_match_data s3c64xx_of_data __initconst = {\n\t.ctrl\t\t= s3c64xx_pin_ctrl,\n\t.num_ctrl\t= ARRAY_SIZE(s3c64xx_pin_ctrl),\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}