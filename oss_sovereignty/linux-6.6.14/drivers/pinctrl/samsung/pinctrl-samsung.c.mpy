{
  "module_name": "pinctrl-samsung.c",
  "hash_id": "c401f3cf72f3a8caa15851dd548e8119d1d9f36200ba926b4e635854f65c7207",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/samsung/pinctrl-samsung.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include <linux/err.h>\n#include <linux/gpio/driver.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/irqdomain.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\n#include \"../core.h\"\n#include \"pinctrl-samsung.h\"\n\n \n#define\tSAMSUNG_PINCTRL_NUM_RESOURCES\t2\n\n \nstatic struct pin_config {\n\tconst char *property;\n\tenum pincfg_type param;\n} cfg_params[] = {\n\t{ \"samsung,pin-pud\", PINCFG_TYPE_PUD },\n\t{ \"samsung,pin-drv\", PINCFG_TYPE_DRV },\n\t{ \"samsung,pin-con-pdn\", PINCFG_TYPE_CON_PDN },\n\t{ \"samsung,pin-pud-pdn\", PINCFG_TYPE_PUD_PDN },\n\t{ \"samsung,pin-val\", PINCFG_TYPE_DAT },\n};\n\nstatic unsigned int pin_base;\n\nstatic int samsung_get_group_count(struct pinctrl_dev *pctldev)\n{\n\tstruct samsung_pinctrl_drv_data *pmx = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pmx->nr_groups;\n}\n\nstatic const char *samsung_get_group_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t\tunsigned group)\n{\n\tstruct samsung_pinctrl_drv_data *pmx = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pmx->pin_groups[group].name;\n}\n\nstatic int samsung_get_group_pins(struct pinctrl_dev *pctldev,\n\t\t\t\t\tunsigned group,\n\t\t\t\t\tconst unsigned **pins,\n\t\t\t\t\tunsigned *num_pins)\n{\n\tstruct samsung_pinctrl_drv_data *pmx = pinctrl_dev_get_drvdata(pctldev);\n\n\t*pins = pmx->pin_groups[group].pins;\n\t*num_pins = pmx->pin_groups[group].num_pins;\n\n\treturn 0;\n}\n\nstatic int reserve_map(struct device *dev, struct pinctrl_map **map,\n\t\t       unsigned *reserved_maps, unsigned *num_maps,\n\t\t       unsigned reserve)\n{\n\tunsigned old_num = *reserved_maps;\n\tunsigned new_num = *num_maps + reserve;\n\tstruct pinctrl_map *new_map;\n\n\tif (old_num >= new_num)\n\t\treturn 0;\n\n\tnew_map = krealloc(*map, sizeof(*new_map) * new_num, GFP_KERNEL);\n\tif (!new_map)\n\t\treturn -ENOMEM;\n\n\tmemset(new_map + old_num, 0, (new_num - old_num) * sizeof(*new_map));\n\n\t*map = new_map;\n\t*reserved_maps = new_num;\n\n\treturn 0;\n}\n\nstatic int add_map_mux(struct pinctrl_map **map, unsigned *reserved_maps,\n\t\t       unsigned *num_maps, const char *group,\n\t\t       const char *function)\n{\n\tif (WARN_ON(*num_maps == *reserved_maps))\n\t\treturn -ENOSPC;\n\n\t(*map)[*num_maps].type = PIN_MAP_TYPE_MUX_GROUP;\n\t(*map)[*num_maps].data.mux.group = group;\n\t(*map)[*num_maps].data.mux.function = function;\n\t(*num_maps)++;\n\n\treturn 0;\n}\n\nstatic int add_map_configs(struct device *dev, struct pinctrl_map **map,\n\t\t\t   unsigned *reserved_maps, unsigned *num_maps,\n\t\t\t   const char *group, unsigned long *configs,\n\t\t\t   unsigned num_configs)\n{\n\tunsigned long *dup_configs;\n\n\tif (WARN_ON(*num_maps == *reserved_maps))\n\t\treturn -ENOSPC;\n\n\tdup_configs = kmemdup(configs, num_configs * sizeof(*dup_configs),\n\t\t\t      GFP_KERNEL);\n\tif (!dup_configs)\n\t\treturn -ENOMEM;\n\n\t(*map)[*num_maps].type = PIN_MAP_TYPE_CONFIGS_GROUP;\n\t(*map)[*num_maps].data.configs.group_or_pin = group;\n\t(*map)[*num_maps].data.configs.configs = dup_configs;\n\t(*map)[*num_maps].data.configs.num_configs = num_configs;\n\t(*num_maps)++;\n\n\treturn 0;\n}\n\nstatic int add_config(struct device *dev, unsigned long **configs,\n\t\t      unsigned *num_configs, unsigned long config)\n{\n\tunsigned old_num = *num_configs;\n\tunsigned new_num = old_num + 1;\n\tunsigned long *new_configs;\n\n\tnew_configs = krealloc(*configs, sizeof(*new_configs) * new_num,\n\t\t\t       GFP_KERNEL);\n\tif (!new_configs)\n\t\treturn -ENOMEM;\n\n\tnew_configs[old_num] = config;\n\n\t*configs = new_configs;\n\t*num_configs = new_num;\n\n\treturn 0;\n}\n\nstatic void samsung_dt_free_map(struct pinctrl_dev *pctldev,\n\t\t\t\t      struct pinctrl_map *map,\n\t\t\t\t      unsigned num_maps)\n{\n\tint i;\n\n\tfor (i = 0; i < num_maps; i++)\n\t\tif (map[i].type == PIN_MAP_TYPE_CONFIGS_GROUP)\n\t\t\tkfree(map[i].data.configs.configs);\n\n\tkfree(map);\n}\n\nstatic int samsung_dt_subnode_to_map(struct samsung_pinctrl_drv_data *drvdata,\n\t\t\t\t     struct device *dev,\n\t\t\t\t     struct device_node *np,\n\t\t\t\t     struct pinctrl_map **map,\n\t\t\t\t     unsigned *reserved_maps,\n\t\t\t\t     unsigned *num_maps)\n{\n\tint ret, i;\n\tu32 val;\n\tunsigned long config;\n\tunsigned long *configs = NULL;\n\tunsigned num_configs = 0;\n\tunsigned reserve;\n\tstruct property *prop;\n\tconst char *group;\n\tbool has_func = false;\n\n\tret = of_property_read_u32(np, \"samsung,pin-function\", &val);\n\tif (!ret)\n\t\thas_func = true;\n\n\tfor (i = 0; i < ARRAY_SIZE(cfg_params); i++) {\n\t\tret = of_property_read_u32(np, cfg_params[i].property, &val);\n\t\tif (!ret) {\n\t\t\tconfig = PINCFG_PACK(cfg_params[i].param, val);\n\t\t\tret = add_config(dev, &configs, &num_configs, config);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto exit;\n\t\t \n\t\t} else if (ret != -EINVAL) {\n\t\t\tdev_err(dev, \"could not parse property %s\\n\",\n\t\t\t\tcfg_params[i].property);\n\t\t}\n\t}\n\n\treserve = 0;\n\tif (has_func)\n\t\treserve++;\n\tif (num_configs)\n\t\treserve++;\n\tret = of_property_count_strings(np, \"samsung,pins\");\n\tif (ret < 0) {\n\t\tdev_err(dev, \"could not parse property samsung,pins\\n\");\n\t\tgoto exit;\n\t}\n\treserve *= ret;\n\n\tret = reserve_map(dev, map, reserved_maps, num_maps, reserve);\n\tif (ret < 0)\n\t\tgoto exit;\n\n\tof_property_for_each_string(np, \"samsung,pins\", prop, group) {\n\t\tif (has_func) {\n\t\t\tret = add_map_mux(map, reserved_maps,\n\t\t\t\t\t\tnum_maps, group, np->full_name);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto exit;\n\t\t}\n\n\t\tif (num_configs) {\n\t\t\tret = add_map_configs(dev, map, reserved_maps,\n\t\t\t\t\t      num_maps, group, configs,\n\t\t\t\t\t      num_configs);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tret = 0;\n\nexit:\n\tkfree(configs);\n\treturn ret;\n}\n\nstatic int samsung_dt_node_to_map(struct pinctrl_dev *pctldev,\n\t\t\t\t\tstruct device_node *np_config,\n\t\t\t\t\tstruct pinctrl_map **map,\n\t\t\t\t\tunsigned *num_maps)\n{\n\tstruct samsung_pinctrl_drv_data *drvdata;\n\tunsigned reserved_maps;\n\tstruct device_node *np;\n\tint ret;\n\n\tdrvdata = pinctrl_dev_get_drvdata(pctldev);\n\n\treserved_maps = 0;\n\t*map = NULL;\n\t*num_maps = 0;\n\n\tif (!of_get_child_count(np_config))\n\t\treturn samsung_dt_subnode_to_map(drvdata, pctldev->dev,\n\t\t\t\t\t\t\tnp_config, map,\n\t\t\t\t\t\t\t&reserved_maps,\n\t\t\t\t\t\t\tnum_maps);\n\n\tfor_each_child_of_node(np_config, np) {\n\t\tret = samsung_dt_subnode_to_map(drvdata, pctldev->dev, np, map,\n\t\t\t\t\t\t&reserved_maps, num_maps);\n\t\tif (ret < 0) {\n\t\t\tsamsung_dt_free_map(pctldev, *map, *num_maps);\n\t\t\tof_node_put(np);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_DEBUG_FS\n \nstatic int samsung_pinconf_get(struct pinctrl_dev *pctldev, unsigned int pin,\n\t\t\t\t\tunsigned long *config);\nstatic const char * const reg_names[] = {\"CON\", \"DAT\", \"PUD\", \"DRV\", \"CON_PDN\",\n\t\t\t\t\t \"PUD_PDN\"};\n\nstatic void samsung_pin_dbg_show(struct pinctrl_dev *pctldev,\n\t\t\t\tstruct seq_file *s, unsigned int pin)\n{\n\tenum pincfg_type cfg_type;\n\tunsigned long config;\n\tint ret;\n\n\tfor (cfg_type = 0; cfg_type < PINCFG_TYPE_NUM; cfg_type++) {\n\t\tconfig = PINCFG_PACK(cfg_type, 0);\n\t\tret = samsung_pinconf_get(pctldev, pin, &config);\n\t\tif (ret < 0)\n\t\t\tcontinue;\n\n\t\tseq_printf(s, \" %s(0x%lx)\", reg_names[cfg_type],\n\t\t\t   PINCFG_UNPACK_VALUE(config));\n\t}\n}\n#endif\n\n \nstatic const struct pinctrl_ops samsung_pctrl_ops = {\n\t.get_groups_count\t= samsung_get_group_count,\n\t.get_group_name\t\t= samsung_get_group_name,\n\t.get_group_pins\t\t= samsung_get_group_pins,\n\t.dt_node_to_map\t\t= samsung_dt_node_to_map,\n\t.dt_free_map\t\t= samsung_dt_free_map,\n#ifdef CONFIG_DEBUG_FS\n\t.pin_dbg_show\t\t= samsung_pin_dbg_show,\n#endif\n};\n\n \nstatic int samsung_get_functions_count(struct pinctrl_dev *pctldev)\n{\n\tstruct samsung_pinctrl_drv_data *drvdata;\n\n\tdrvdata = pinctrl_dev_get_drvdata(pctldev);\n\treturn drvdata->nr_functions;\n}\n\n \nstatic const char *samsung_pinmux_get_fname(struct pinctrl_dev *pctldev,\n\t\t\t\t\t\tunsigned selector)\n{\n\tstruct samsung_pinctrl_drv_data *drvdata;\n\n\tdrvdata = pinctrl_dev_get_drvdata(pctldev);\n\treturn drvdata->pmx_functions[selector].name;\n}\n\n \nstatic int samsung_pinmux_get_groups(struct pinctrl_dev *pctldev,\n\t\tunsigned selector, const char * const **groups,\n\t\tunsigned * const num_groups)\n{\n\tstruct samsung_pinctrl_drv_data *drvdata;\n\n\tdrvdata = pinctrl_dev_get_drvdata(pctldev);\n\t*groups = drvdata->pmx_functions[selector].groups;\n\t*num_groups = drvdata->pmx_functions[selector].num_groups;\n\treturn 0;\n}\n\n \nstatic void pin_to_reg_bank(struct samsung_pinctrl_drv_data *drvdata,\n\t\t\tunsigned pin, void __iomem **reg, u32 *offset,\n\t\t\tstruct samsung_pin_bank **bank)\n{\n\tstruct samsung_pin_bank *b;\n\n\tb = drvdata->pin_banks;\n\n\twhile ((pin >= b->pin_base) &&\n\t\t\t((b->pin_base + b->nr_pins - 1) < pin))\n\t\tb++;\n\n\t*reg = b->pctl_base + b->pctl_offset;\n\t*offset = pin - b->pin_base;\n\tif (bank)\n\t\t*bank = b;\n}\n\n \nstatic void samsung_pinmux_setup(struct pinctrl_dev *pctldev, unsigned selector,\n\t\t\t\t\tunsigned group)\n{\n\tstruct samsung_pinctrl_drv_data *drvdata;\n\tconst struct samsung_pin_bank_type *type;\n\tstruct samsung_pin_bank *bank;\n\tvoid __iomem *reg;\n\tu32 mask, shift, data, pin_offset;\n\tunsigned long flags;\n\tconst struct samsung_pmx_func *func;\n\tconst struct samsung_pin_group *grp;\n\n\tdrvdata = pinctrl_dev_get_drvdata(pctldev);\n\tfunc = &drvdata->pmx_functions[selector];\n\tgrp = &drvdata->pin_groups[group];\n\n\tpin_to_reg_bank(drvdata, grp->pins[0] - drvdata->pin_base,\n\t\t\t&reg, &pin_offset, &bank);\n\ttype = bank->type;\n\tmask = (1 << type->fld_width[PINCFG_TYPE_FUNC]) - 1;\n\tshift = pin_offset * type->fld_width[PINCFG_TYPE_FUNC];\n\tif (shift >= 32) {\n\t\t \n\t\tshift -= 32;\n\t\treg += 4;\n\t}\n\n\traw_spin_lock_irqsave(&bank->slock, flags);\n\n\tdata = readl(reg + type->reg_offset[PINCFG_TYPE_FUNC]);\n\tdata &= ~(mask << shift);\n\tdata |= func->val << shift;\n\twritel(data, reg + type->reg_offset[PINCFG_TYPE_FUNC]);\n\n\traw_spin_unlock_irqrestore(&bank->slock, flags);\n}\n\n \nstatic int samsung_pinmux_set_mux(struct pinctrl_dev *pctldev,\n\t\t\t\t  unsigned selector,\n\t\t\t\t  unsigned group)\n{\n\tsamsung_pinmux_setup(pctldev, selector, group);\n\treturn 0;\n}\n\n \nstatic const struct pinmux_ops samsung_pinmux_ops = {\n\t.get_functions_count\t= samsung_get_functions_count,\n\t.get_function_name\t= samsung_pinmux_get_fname,\n\t.get_function_groups\t= samsung_pinmux_get_groups,\n\t.set_mux\t\t= samsung_pinmux_set_mux,\n};\n\n \nstatic int samsung_pinconf_rw(struct pinctrl_dev *pctldev, unsigned int pin,\n\t\t\t\tunsigned long *config, bool set)\n{\n\tstruct samsung_pinctrl_drv_data *drvdata;\n\tconst struct samsung_pin_bank_type *type;\n\tstruct samsung_pin_bank *bank;\n\tvoid __iomem *reg_base;\n\tenum pincfg_type cfg_type = PINCFG_UNPACK_TYPE(*config);\n\tu32 data, width, pin_offset, mask, shift;\n\tu32 cfg_value, cfg_reg;\n\tunsigned long flags;\n\n\tdrvdata = pinctrl_dev_get_drvdata(pctldev);\n\tpin_to_reg_bank(drvdata, pin - drvdata->pin_base, &reg_base,\n\t\t\t\t\t&pin_offset, &bank);\n\ttype = bank->type;\n\n\tif (cfg_type >= PINCFG_TYPE_NUM || !type->fld_width[cfg_type])\n\t\treturn -EINVAL;\n\n\twidth = type->fld_width[cfg_type];\n\tcfg_reg = type->reg_offset[cfg_type];\n\n\traw_spin_lock_irqsave(&bank->slock, flags);\n\n\tmask = (1 << width) - 1;\n\tshift = pin_offset * width;\n\tdata = readl(reg_base + cfg_reg);\n\n\tif (set) {\n\t\tcfg_value = PINCFG_UNPACK_VALUE(*config);\n\t\tdata &= ~(mask << shift);\n\t\tdata |= (cfg_value << shift);\n\t\twritel(data, reg_base + cfg_reg);\n\t} else {\n\t\tdata >>= shift;\n\t\tdata &= mask;\n\t\t*config = PINCFG_PACK(cfg_type, data);\n\t}\n\n\traw_spin_unlock_irqrestore(&bank->slock, flags);\n\n\treturn 0;\n}\n\n \nstatic int samsung_pinconf_set(struct pinctrl_dev *pctldev, unsigned int pin,\n\t\t\t\tunsigned long *configs, unsigned num_configs)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < num_configs; i++) {\n\t\tret = samsung_pinconf_rw(pctldev, pin, &configs[i], true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}  \n\n\treturn 0;\n}\n\n \nstatic int samsung_pinconf_get(struct pinctrl_dev *pctldev, unsigned int pin,\n\t\t\t\t\tunsigned long *config)\n{\n\treturn samsung_pinconf_rw(pctldev, pin, config, false);\n}\n\n \nstatic int samsung_pinconf_group_set(struct pinctrl_dev *pctldev,\n\t\t\tunsigned group, unsigned long *configs,\n\t\t\tunsigned num_configs)\n{\n\tstruct samsung_pinctrl_drv_data *drvdata;\n\tconst unsigned int *pins;\n\tunsigned int cnt;\n\n\tdrvdata = pinctrl_dev_get_drvdata(pctldev);\n\tpins = drvdata->pin_groups[group].pins;\n\n\tfor (cnt = 0; cnt < drvdata->pin_groups[group].num_pins; cnt++)\n\t\tsamsung_pinconf_set(pctldev, pins[cnt], configs, num_configs);\n\n\treturn 0;\n}\n\n \nstatic int samsung_pinconf_group_get(struct pinctrl_dev *pctldev,\n\t\t\t\tunsigned int group, unsigned long *config)\n{\n\tstruct samsung_pinctrl_drv_data *drvdata;\n\tconst unsigned int *pins;\n\n\tdrvdata = pinctrl_dev_get_drvdata(pctldev);\n\tpins = drvdata->pin_groups[group].pins;\n\tsamsung_pinconf_get(pctldev, pins[0], config);\n\treturn 0;\n}\n\n \nstatic const struct pinconf_ops samsung_pinconf_ops = {\n\t.pin_config_get\t\t= samsung_pinconf_get,\n\t.pin_config_set\t\t= samsung_pinconf_set,\n\t.pin_config_group_get\t= samsung_pinconf_group_get,\n\t.pin_config_group_set\t= samsung_pinconf_group_set,\n};\n\n \nstatic void samsung_gpio_set_value(struct gpio_chip *gc,\n\t\t\t\t\t  unsigned offset, int value)\n{\n\tstruct samsung_pin_bank *bank = gpiochip_get_data(gc);\n\tconst struct samsung_pin_bank_type *type = bank->type;\n\tvoid __iomem *reg;\n\tu32 data;\n\n\treg = bank->pctl_base + bank->pctl_offset;\n\n\tdata = readl(reg + type->reg_offset[PINCFG_TYPE_DAT]);\n\tdata &= ~(1 << offset);\n\tif (value)\n\t\tdata |= 1 << offset;\n\twritel(data, reg + type->reg_offset[PINCFG_TYPE_DAT]);\n}\n\n \nstatic void samsung_gpio_set(struct gpio_chip *gc, unsigned offset, int value)\n{\n\tstruct samsung_pin_bank *bank = gpiochip_get_data(gc);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&bank->slock, flags);\n\tsamsung_gpio_set_value(gc, offset, value);\n\traw_spin_unlock_irqrestore(&bank->slock, flags);\n}\n\n \nstatic int samsung_gpio_get(struct gpio_chip *gc, unsigned offset)\n{\n\tvoid __iomem *reg;\n\tu32 data;\n\tstruct samsung_pin_bank *bank = gpiochip_get_data(gc);\n\tconst struct samsung_pin_bank_type *type = bank->type;\n\n\treg = bank->pctl_base + bank->pctl_offset;\n\n\tdata = readl(reg + type->reg_offset[PINCFG_TYPE_DAT]);\n\tdata >>= offset;\n\tdata &= 1;\n\treturn data;\n}\n\n \nstatic int samsung_gpio_set_direction(struct gpio_chip *gc,\n\t\t\t\t\t     unsigned offset, bool input)\n{\n\tconst struct samsung_pin_bank_type *type;\n\tstruct samsung_pin_bank *bank;\n\tvoid __iomem *reg;\n\tu32 data, mask, shift;\n\n\tbank = gpiochip_get_data(gc);\n\ttype = bank->type;\n\n\treg = bank->pctl_base + bank->pctl_offset\n\t\t\t+ type->reg_offset[PINCFG_TYPE_FUNC];\n\n\tmask = (1 << type->fld_width[PINCFG_TYPE_FUNC]) - 1;\n\tshift = offset * type->fld_width[PINCFG_TYPE_FUNC];\n\tif (shift >= 32) {\n\t\t \n\t\tshift -= 32;\n\t\treg += 4;\n\t}\n\n\tdata = readl(reg);\n\tdata &= ~(mask << shift);\n\tif (!input)\n\t\tdata |= PIN_CON_FUNC_OUTPUT << shift;\n\twritel(data, reg);\n\n\treturn 0;\n}\n\n \nstatic int samsung_gpio_direction_input(struct gpio_chip *gc, unsigned offset)\n{\n\tstruct samsung_pin_bank *bank = gpiochip_get_data(gc);\n\tunsigned long flags;\n\tint ret;\n\n\traw_spin_lock_irqsave(&bank->slock, flags);\n\tret = samsung_gpio_set_direction(gc, offset, true);\n\traw_spin_unlock_irqrestore(&bank->slock, flags);\n\treturn ret;\n}\n\n \nstatic int samsung_gpio_direction_output(struct gpio_chip *gc, unsigned offset,\n\t\t\t\t\t\t\tint value)\n{\n\tstruct samsung_pin_bank *bank = gpiochip_get_data(gc);\n\tunsigned long flags;\n\tint ret;\n\n\traw_spin_lock_irqsave(&bank->slock, flags);\n\tsamsung_gpio_set_value(gc, offset, value);\n\tret = samsung_gpio_set_direction(gc, offset, false);\n\traw_spin_unlock_irqrestore(&bank->slock, flags);\n\n\treturn ret;\n}\n\n \nstatic int samsung_gpio_to_irq(struct gpio_chip *gc, unsigned offset)\n{\n\tstruct samsung_pin_bank *bank = gpiochip_get_data(gc);\n\tunsigned int virq;\n\n\tif (!bank->irq_domain)\n\t\treturn -ENXIO;\n\n\tvirq = irq_create_mapping(bank->irq_domain, offset);\n\n\treturn (virq) ? : -ENXIO;\n}\n\nstatic struct samsung_pin_group *samsung_pinctrl_create_groups(\n\t\t\t\tstruct device *dev,\n\t\t\t\tstruct samsung_pinctrl_drv_data *drvdata,\n\t\t\t\tunsigned int *cnt)\n{\n\tstruct pinctrl_desc *ctrldesc = &drvdata->pctl;\n\tstruct samsung_pin_group *groups, *grp;\n\tconst struct pinctrl_pin_desc *pdesc;\n\tint i;\n\n\tgroups = devm_kcalloc(dev, ctrldesc->npins, sizeof(*groups),\n\t\t\t\tGFP_KERNEL);\n\tif (!groups)\n\t\treturn ERR_PTR(-EINVAL);\n\tgrp = groups;\n\n\tpdesc = ctrldesc->pins;\n\tfor (i = 0; i < ctrldesc->npins; ++i, ++pdesc, ++grp) {\n\t\tgrp->name = pdesc->name;\n\t\tgrp->pins = &pdesc->number;\n\t\tgrp->num_pins = 1;\n\t}\n\n\t*cnt = ctrldesc->npins;\n\treturn groups;\n}\n\nstatic int samsung_pinctrl_create_function(struct device *dev,\n\t\t\t\tstruct samsung_pinctrl_drv_data *drvdata,\n\t\t\t\tstruct device_node *func_np,\n\t\t\t\tstruct samsung_pmx_func *func)\n{\n\tint npins;\n\tint ret;\n\tint i;\n\n\tif (of_property_read_u32(func_np, \"samsung,pin-function\", &func->val))\n\t\treturn 0;\n\n\tnpins = of_property_count_strings(func_np, \"samsung,pins\");\n\tif (npins < 1) {\n\t\tdev_err(dev, \"invalid pin list in %pOFn node\", func_np);\n\t\treturn -EINVAL;\n\t}\n\n\tfunc->name = func_np->full_name;\n\n\tfunc->groups = devm_kcalloc(dev, npins, sizeof(char *), GFP_KERNEL);\n\tif (!func->groups)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < npins; ++i) {\n\t\tconst char *gname;\n\n\t\tret = of_property_read_string_index(func_np, \"samsung,pins\",\n\t\t\t\t\t\t\ti, &gname);\n\t\tif (ret) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"failed to read pin name %d from %pOFn node\\n\",\n\t\t\t\ti, func_np);\n\t\t\treturn ret;\n\t\t}\n\n\t\tfunc->groups[i] = gname;\n\t}\n\n\tfunc->num_groups = npins;\n\treturn 1;\n}\n\nstatic struct samsung_pmx_func *samsung_pinctrl_create_functions(\n\t\t\t\tstruct device *dev,\n\t\t\t\tstruct samsung_pinctrl_drv_data *drvdata,\n\t\t\t\tunsigned int *cnt)\n{\n\tstruct samsung_pmx_func *functions, *func;\n\tstruct device_node *dev_np = dev->of_node;\n\tstruct device_node *cfg_np;\n\tunsigned int func_cnt = 0;\n\tint ret;\n\n\t \n\tfor_each_child_of_node(dev_np, cfg_np) {\n\t\tstruct device_node *func_np;\n\n\t\tif (!of_get_child_count(cfg_np)) {\n\t\t\tif (!of_find_property(cfg_np,\n\t\t\t    \"samsung,pin-function\", NULL))\n\t\t\t\tcontinue;\n\t\t\t++func_cnt;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor_each_child_of_node(cfg_np, func_np) {\n\t\t\tif (!of_find_property(func_np,\n\t\t\t    \"samsung,pin-function\", NULL))\n\t\t\t\tcontinue;\n\t\t\t++func_cnt;\n\t\t}\n\t}\n\n\tfunctions = devm_kcalloc(dev, func_cnt, sizeof(*functions),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!functions)\n\t\treturn ERR_PTR(-ENOMEM);\n\tfunc = functions;\n\n\t \n\tfunc_cnt = 0;\n\tfor_each_child_of_node(dev_np, cfg_np) {\n\t\tstruct device_node *func_np;\n\n\t\tif (!of_get_child_count(cfg_np)) {\n\t\t\tret = samsung_pinctrl_create_function(dev, drvdata,\n\t\t\t\t\t\t\tcfg_np, func);\n\t\t\tif (ret < 0) {\n\t\t\t\tof_node_put(cfg_np);\n\t\t\t\treturn ERR_PTR(ret);\n\t\t\t}\n\t\t\tif (ret > 0) {\n\t\t\t\t++func;\n\t\t\t\t++func_cnt;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor_each_child_of_node(cfg_np, func_np) {\n\t\t\tret = samsung_pinctrl_create_function(dev, drvdata,\n\t\t\t\t\t\tfunc_np, func);\n\t\t\tif (ret < 0) {\n\t\t\t\tof_node_put(func_np);\n\t\t\t\tof_node_put(cfg_np);\n\t\t\t\treturn ERR_PTR(ret);\n\t\t\t}\n\t\t\tif (ret > 0) {\n\t\t\t\t++func;\n\t\t\t\t++func_cnt;\n\t\t\t}\n\t\t}\n\t}\n\n\t*cnt = func_cnt;\n\treturn functions;\n}\n\n \n\nstatic int samsung_pinctrl_parse_dt(struct platform_device *pdev,\n\t\t\t\t    struct samsung_pinctrl_drv_data *drvdata)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct samsung_pin_group *groups;\n\tstruct samsung_pmx_func *functions;\n\tunsigned int grp_cnt = 0, func_cnt = 0;\n\n\tgroups = samsung_pinctrl_create_groups(dev, drvdata, &grp_cnt);\n\tif (IS_ERR(groups)) {\n\t\tdev_err(dev, \"failed to parse pin groups\\n\");\n\t\treturn PTR_ERR(groups);\n\t}\n\n\tfunctions = samsung_pinctrl_create_functions(dev, drvdata, &func_cnt);\n\tif (IS_ERR(functions)) {\n\t\tdev_err(dev, \"failed to parse pin functions\\n\");\n\t\treturn PTR_ERR(functions);\n\t}\n\n\tdrvdata->pin_groups = groups;\n\tdrvdata->nr_groups = grp_cnt;\n\tdrvdata->pmx_functions = functions;\n\tdrvdata->nr_functions = func_cnt;\n\n\treturn 0;\n}\n\n \nstatic int samsung_pinctrl_register(struct platform_device *pdev,\n\t\t\t\t    struct samsung_pinctrl_drv_data *drvdata)\n{\n\tstruct pinctrl_desc *ctrldesc = &drvdata->pctl;\n\tstruct pinctrl_pin_desc *pindesc, *pdesc;\n\tstruct samsung_pin_bank *pin_bank;\n\tchar *pin_names;\n\tint pin, bank, ret;\n\n\tctrldesc->name = \"samsung-pinctrl\";\n\tctrldesc->owner = THIS_MODULE;\n\tctrldesc->pctlops = &samsung_pctrl_ops;\n\tctrldesc->pmxops = &samsung_pinmux_ops;\n\tctrldesc->confops = &samsung_pinconf_ops;\n\n\tpindesc = devm_kcalloc(&pdev->dev,\n\t\t\t       drvdata->nr_pins, sizeof(*pindesc),\n\t\t\t       GFP_KERNEL);\n\tif (!pindesc)\n\t\treturn -ENOMEM;\n\tctrldesc->pins = pindesc;\n\tctrldesc->npins = drvdata->nr_pins;\n\n\t \n\tfor (pin = 0, pdesc = pindesc; pin < ctrldesc->npins; pin++, pdesc++)\n\t\tpdesc->number = pin + drvdata->pin_base;\n\n\t \n\tpin_names = devm_kzalloc(&pdev->dev,\n\t\t\t\t array3_size(sizeof(char), PIN_NAME_LENGTH,\n\t\t\t\t\t     drvdata->nr_pins),\n\t\t\t\t GFP_KERNEL);\n\tif (!pin_names)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (bank = 0; bank < drvdata->nr_banks; bank++) {\n\t\tpin_bank = &drvdata->pin_banks[bank];\n\t\tfor (pin = 0; pin < pin_bank->nr_pins; pin++) {\n\t\t\tsprintf(pin_names, \"%s-%d\", pin_bank->name, pin);\n\t\t\tpdesc = pindesc + pin_bank->pin_base + pin;\n\t\t\tpdesc->name = pin_names;\n\t\t\tpin_names += PIN_NAME_LENGTH;\n\t\t}\n\t}\n\n\tret = samsung_pinctrl_parse_dt(pdev, drvdata);\n\tif (ret)\n\t\treturn ret;\n\n\tdrvdata->pctl_dev = devm_pinctrl_register(&pdev->dev, ctrldesc,\n\t\t\t\t\t\t  drvdata);\n\tif (IS_ERR(drvdata->pctl_dev)) {\n\t\tdev_err(&pdev->dev, \"could not register pinctrl driver\\n\");\n\t\treturn PTR_ERR(drvdata->pctl_dev);\n\t}\n\n\tfor (bank = 0; bank < drvdata->nr_banks; ++bank) {\n\t\tpin_bank = &drvdata->pin_banks[bank];\n\t\tpin_bank->grange.name = pin_bank->name;\n\t\tpin_bank->grange.id = bank;\n\t\tpin_bank->grange.pin_base = drvdata->pin_base\n\t\t\t\t\t\t+ pin_bank->pin_base;\n\t\tpin_bank->grange.base = pin_bank->grange.pin_base;\n\t\tpin_bank->grange.npins = pin_bank->nr_pins;\n\t\tpin_bank->grange.gc = &pin_bank->gpio_chip;\n\t\tpinctrl_add_gpio_range(drvdata->pctl_dev, &pin_bank->grange);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int samsung_pinctrl_unregister(struct platform_device *pdev,\n\t\t\t\t      struct samsung_pinctrl_drv_data *drvdata)\n{\n\tstruct samsung_pin_bank *bank = drvdata->pin_banks;\n\tint i;\n\n\tfor (i = 0; i < drvdata->nr_banks; ++i, ++bank)\n\t\tpinctrl_remove_gpio_range(drvdata->pctl_dev, &bank->grange);\n\n\treturn 0;\n}\n\nstatic const struct gpio_chip samsung_gpiolib_chip = {\n\t.request = gpiochip_generic_request,\n\t.free = gpiochip_generic_free,\n\t.set = samsung_gpio_set,\n\t.get = samsung_gpio_get,\n\t.direction_input = samsung_gpio_direction_input,\n\t.direction_output = samsung_gpio_direction_output,\n\t.to_irq = samsung_gpio_to_irq,\n\t.owner = THIS_MODULE,\n};\n\n \nstatic int samsung_gpiolib_register(struct platform_device *pdev,\n\t\t\t\t    struct samsung_pinctrl_drv_data *drvdata)\n{\n\tstruct samsung_pin_bank *bank = drvdata->pin_banks;\n\tstruct gpio_chip *gc;\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < drvdata->nr_banks; ++i, ++bank) {\n\t\tbank->gpio_chip = samsung_gpiolib_chip;\n\n\t\tgc = &bank->gpio_chip;\n\t\tgc->base = bank->grange.base;\n\t\tgc->ngpio = bank->nr_pins;\n\t\tgc->parent = &pdev->dev;\n\t\tgc->fwnode = bank->fwnode;\n\t\tgc->label = bank->name;\n\n\t\tret = devm_gpiochip_add_data(&pdev->dev, gc, bank);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"failed to register gpio_chip %s, error code: %d\\n\",\n\t\t\t\t\t\t\tgc->label, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct samsung_pin_ctrl *\nsamsung_pinctrl_get_soc_data_for_of_alias(struct platform_device *pdev)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tconst struct samsung_pinctrl_of_match_data *of_data;\n\tint id;\n\n\tid = of_alias_get_id(node, \"pinctrl\");\n\tif (id < 0) {\n\t\tdev_err(&pdev->dev, \"failed to get alias id\\n\");\n\t\treturn NULL;\n\t}\n\n\tof_data = of_device_get_match_data(&pdev->dev);\n\tif (id >= of_data->num_ctrl) {\n\t\tdev_err(&pdev->dev, \"invalid alias id %d\\n\", id);\n\t\treturn NULL;\n\t}\n\n\treturn &(of_data->ctrl[id]);\n}\n\nstatic void samsung_banks_node_put(struct samsung_pinctrl_drv_data *d)\n{\n\tstruct samsung_pin_bank *bank;\n\tunsigned int i;\n\n\tbank = d->pin_banks;\n\tfor (i = 0; i < d->nr_banks; ++i, ++bank)\n\t\tfwnode_handle_put(bank->fwnode);\n}\n\n \nstatic void samsung_banks_node_get(struct device *dev, struct samsung_pinctrl_drv_data *d)\n{\n\tconst char *suffix = \"-gpio-bank\";\n\tstruct samsung_pin_bank *bank;\n\tstruct fwnode_handle *child;\n\t \n\tchar node_name[20];\n\tunsigned int i;\n\tsize_t len;\n\n\tbank = d->pin_banks;\n\tfor (i = 0; i < d->nr_banks; ++i, ++bank) {\n\t\tstrscpy(node_name, bank->name, sizeof(node_name));\n\t\tlen = strlcat(node_name, suffix, sizeof(node_name));\n\t\tif (len >= sizeof(node_name)) {\n\t\t\tdev_err(dev, \"Too long pin bank name '%s', ignoring\\n\",\n\t\t\t\tbank->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor_each_gpiochip_node(dev, child) {\n\t\t\tstruct device_node *np = to_of_node(child);\n\n\t\t\tif (of_node_name_eq(np, node_name))\n\t\t\t\tbreak;\n\t\t\tif (of_node_name_eq(np, bank->name))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (child)\n\t\t\tbank->fwnode = child;\n\t\telse\n\t\t\tdev_warn(dev, \"Missing node for bank %s - invalid DTB\\n\",\n\t\t\t\t bank->name);\n\t\t \n\t}\n}\n\n \nstatic const struct samsung_pin_ctrl *\nsamsung_pinctrl_get_soc_data(struct samsung_pinctrl_drv_data *d,\n\t\t\t     struct platform_device *pdev)\n{\n\tconst struct samsung_pin_bank_data *bdata;\n\tconst struct samsung_pin_ctrl *ctrl;\n\tstruct samsung_pin_bank *bank;\n\tstruct resource *res;\n\tvoid __iomem *virt_base[SAMSUNG_PINCTRL_NUM_RESOURCES];\n\tunsigned int i;\n\n\tctrl = samsung_pinctrl_get_soc_data_for_of_alias(pdev);\n\tif (!ctrl)\n\t\treturn ERR_PTR(-ENOENT);\n\n\td->suspend = ctrl->suspend;\n\td->resume = ctrl->resume;\n\td->nr_banks = ctrl->nr_banks;\n\td->pin_banks = devm_kcalloc(&pdev->dev, d->nr_banks,\n\t\t\t\t\tsizeof(*d->pin_banks), GFP_KERNEL);\n\tif (!d->pin_banks)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (ctrl->nr_ext_resources + 1 > SAMSUNG_PINCTRL_NUM_RESOURCES)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tfor (i = 0; i < ctrl->nr_ext_resources + 1; i++) {\n\t\tres = platform_get_resource(pdev, IORESOURCE_MEM, i);\n\t\tif (!res) {\n\t\t\tdev_err(&pdev->dev, \"failed to get mem%d resource\\n\", i);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\tvirt_base[i] = devm_ioremap(&pdev->dev, res->start,\n\t\t\t\t\t\tresource_size(res));\n\t\tif (!virt_base[i]) {\n\t\t\tdev_err(&pdev->dev, \"failed to ioremap %pR\\n\", res);\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\n\t}\n\n\tbank = d->pin_banks;\n\tbdata = ctrl->pin_banks;\n\tfor (i = 0; i < ctrl->nr_banks; ++i, ++bdata, ++bank) {\n\t\tbank->type = bdata->type;\n\t\tbank->pctl_offset = bdata->pctl_offset;\n\t\tbank->nr_pins = bdata->nr_pins;\n\t\tbank->eint_func = bdata->eint_func;\n\t\tbank->eint_type = bdata->eint_type;\n\t\tbank->eint_mask = bdata->eint_mask;\n\t\tbank->eint_offset = bdata->eint_offset;\n\t\tbank->name = bdata->name;\n\n\t\traw_spin_lock_init(&bank->slock);\n\t\tbank->drvdata = d;\n\t\tbank->pin_base = d->nr_pins;\n\t\td->nr_pins += bank->nr_pins;\n\n\t\tbank->eint_base = virt_base[0];\n\t\tbank->pctl_base = virt_base[bdata->pctl_res_idx];\n\t}\n\t \n\td->virt_base = virt_base[0];\n\n\tsamsung_banks_node_get(&pdev->dev, d);\n\n\td->pin_base = pin_base;\n\tpin_base += d->nr_pins;\n\n\treturn ctrl;\n}\n\nstatic int samsung_pinctrl_probe(struct platform_device *pdev)\n{\n\tstruct samsung_pinctrl_drv_data *drvdata;\n\tconst struct samsung_pin_ctrl *ctrl;\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\n\tdrvdata = devm_kzalloc(dev, sizeof(*drvdata), GFP_KERNEL);\n\tif (!drvdata)\n\t\treturn -ENOMEM;\n\n\tctrl = samsung_pinctrl_get_soc_data(drvdata, pdev);\n\tif (IS_ERR(ctrl)) {\n\t\tdev_err(&pdev->dev, \"driver data not available\\n\");\n\t\treturn PTR_ERR(ctrl);\n\t}\n\tdrvdata->dev = dev;\n\n\tret = platform_get_irq_optional(pdev, 0);\n\tif (ret < 0 && ret != -ENXIO)\n\t\treturn ret;\n\tif (ret > 0)\n\t\tdrvdata->irq = ret;\n\n\tif (ctrl->retention_data) {\n\t\tdrvdata->retention_ctrl = ctrl->retention_data->init(drvdata,\n\t\t\t\t\t\t\t  ctrl->retention_data);\n\t\tif (IS_ERR(drvdata->retention_ctrl)) {\n\t\t\tret = PTR_ERR(drvdata->retention_ctrl);\n\t\t\tgoto err_put_banks;\n\t\t}\n\t}\n\n\tret = samsung_pinctrl_register(pdev, drvdata);\n\tif (ret)\n\t\tgoto err_put_banks;\n\n\tif (ctrl->eint_gpio_init)\n\t\tctrl->eint_gpio_init(drvdata);\n\tif (ctrl->eint_wkup_init)\n\t\tctrl->eint_wkup_init(drvdata);\n\n\tret = samsung_gpiolib_register(pdev, drvdata);\n\tif (ret)\n\t\tgoto err_unregister;\n\n\tplatform_set_drvdata(pdev, drvdata);\n\n\treturn 0;\n\nerr_unregister:\n\tsamsung_pinctrl_unregister(pdev, drvdata);\nerr_put_banks:\n\tsamsung_banks_node_put(drvdata);\n\treturn ret;\n}\n\n \nstatic int __maybe_unused samsung_pinctrl_suspend(struct device *dev)\n{\n\tstruct samsung_pinctrl_drv_data *drvdata = dev_get_drvdata(dev);\n\tint i;\n\n\tfor (i = 0; i < drvdata->nr_banks; i++) {\n\t\tstruct samsung_pin_bank *bank = &drvdata->pin_banks[i];\n\t\tvoid __iomem *reg = bank->pctl_base + bank->pctl_offset;\n\t\tconst u8 *offs = bank->type->reg_offset;\n\t\tconst u8 *widths = bank->type->fld_width;\n\t\tenum pincfg_type type;\n\n\t\t \n\t\tif (!widths[PINCFG_TYPE_CON_PDN])\n\t\t\tcontinue;\n\n\t\tfor (type = 0; type < PINCFG_TYPE_NUM; type++)\n\t\t\tif (widths[type])\n\t\t\t\tbank->pm_save[type] = readl(reg + offs[type]);\n\n\t\tif (widths[PINCFG_TYPE_FUNC] * bank->nr_pins > 32) {\n\t\t\t \n\t\t\tbank->pm_save[PINCFG_TYPE_NUM] =\n\t\t\t\treadl(reg + offs[PINCFG_TYPE_FUNC] + 4);\n\t\t\tpr_debug(\"Save %s @ %p (con %#010x %08x)\\n\",\n\t\t\t\t bank->name, reg,\n\t\t\t\t bank->pm_save[PINCFG_TYPE_FUNC],\n\t\t\t\t bank->pm_save[PINCFG_TYPE_NUM]);\n\t\t} else {\n\t\t\tpr_debug(\"Save %s @ %p (con %#010x)\\n\", bank->name,\n\t\t\t\t reg, bank->pm_save[PINCFG_TYPE_FUNC]);\n\t\t}\n\t}\n\n\tif (drvdata->suspend)\n\t\tdrvdata->suspend(drvdata);\n\tif (drvdata->retention_ctrl && drvdata->retention_ctrl->enable)\n\t\tdrvdata->retention_ctrl->enable(drvdata);\n\n\treturn 0;\n}\n\n \nstatic int __maybe_unused samsung_pinctrl_resume(struct device *dev)\n{\n\tstruct samsung_pinctrl_drv_data *drvdata = dev_get_drvdata(dev);\n\tint i;\n\n\tif (drvdata->resume)\n\t\tdrvdata->resume(drvdata);\n\n\tfor (i = 0; i < drvdata->nr_banks; i++) {\n\t\tstruct samsung_pin_bank *bank = &drvdata->pin_banks[i];\n\t\tvoid __iomem *reg = bank->pctl_base + bank->pctl_offset;\n\t\tconst u8 *offs = bank->type->reg_offset;\n\t\tconst u8 *widths = bank->type->fld_width;\n\t\tenum pincfg_type type;\n\n\t\t \n\t\tif (!widths[PINCFG_TYPE_CON_PDN])\n\t\t\tcontinue;\n\n\t\tif (widths[PINCFG_TYPE_FUNC] * bank->nr_pins > 32) {\n\t\t\t \n\t\t\tpr_debug(\"%s @ %p (con %#010x %08x => %#010x %08x)\\n\",\n\t\t\t\t bank->name, reg,\n\t\t\t\t readl(reg + offs[PINCFG_TYPE_FUNC]),\n\t\t\t\t readl(reg + offs[PINCFG_TYPE_FUNC] + 4),\n\t\t\t\t bank->pm_save[PINCFG_TYPE_FUNC],\n\t\t\t\t bank->pm_save[PINCFG_TYPE_NUM]);\n\t\t\twritel(bank->pm_save[PINCFG_TYPE_NUM],\n\t\t\t       reg + offs[PINCFG_TYPE_FUNC] + 4);\n\t\t} else {\n\t\t\tpr_debug(\"%s @ %p (con %#010x => %#010x)\\n\", bank->name,\n\t\t\t\t reg, readl(reg + offs[PINCFG_TYPE_FUNC]),\n\t\t\t\t bank->pm_save[PINCFG_TYPE_FUNC]);\n\t\t}\n\t\tfor (type = 0; type < PINCFG_TYPE_NUM; type++)\n\t\t\tif (widths[type])\n\t\t\t\twritel(bank->pm_save[type], reg + offs[type]);\n\t}\n\n\tif (drvdata->retention_ctrl && drvdata->retention_ctrl->disable)\n\t\tdrvdata->retention_ctrl->disable(drvdata);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id samsung_pinctrl_dt_match[] = {\n#ifdef CONFIG_PINCTRL_EXYNOS_ARM\n\t{ .compatible = \"samsung,exynos3250-pinctrl\",\n\t\t.data = &exynos3250_of_data },\n\t{ .compatible = \"samsung,exynos4210-pinctrl\",\n\t\t.data = &exynos4210_of_data },\n\t{ .compatible = \"samsung,exynos4x12-pinctrl\",\n\t\t.data = &exynos4x12_of_data },\n\t{ .compatible = \"samsung,exynos5250-pinctrl\",\n\t\t.data = &exynos5250_of_data },\n\t{ .compatible = \"samsung,exynos5260-pinctrl\",\n\t\t.data = &exynos5260_of_data },\n\t{ .compatible = \"samsung,exynos5410-pinctrl\",\n\t\t.data = &exynos5410_of_data },\n\t{ .compatible = \"samsung,exynos5420-pinctrl\",\n\t\t.data = &exynos5420_of_data },\n\t{ .compatible = \"samsung,s5pv210-pinctrl\",\n\t\t.data = &s5pv210_of_data },\n#endif\n#ifdef CONFIG_PINCTRL_EXYNOS_ARM64\n\t{ .compatible = \"samsung,exynos5433-pinctrl\",\n\t\t.data = &exynos5433_of_data },\n\t{ .compatible = \"samsung,exynos7-pinctrl\",\n\t\t.data = &exynos7_of_data },\n\t{ .compatible = \"samsung,exynos7885-pinctrl\",\n\t\t.data = &exynos7885_of_data },\n\t{ .compatible = \"samsung,exynos850-pinctrl\",\n\t\t.data = &exynos850_of_data },\n\t{ .compatible = \"samsung,exynosautov9-pinctrl\",\n\t\t.data = &exynosautov9_of_data },\n\t{ .compatible = \"tesla,fsd-pinctrl\",\n\t\t.data = &fsd_of_data },\n#endif\n#ifdef CONFIG_PINCTRL_S3C64XX\n\t{ .compatible = \"samsung,s3c64xx-pinctrl\",\n\t\t.data = &s3c64xx_of_data },\n#endif\n\t{},\n};\n\nstatic const struct dev_pm_ops samsung_pinctrl_pm_ops = {\n\tSET_LATE_SYSTEM_SLEEP_PM_OPS(samsung_pinctrl_suspend,\n\t\t\t\t     samsung_pinctrl_resume)\n};\n\nstatic struct platform_driver samsung_pinctrl_driver = {\n\t.probe\t\t= samsung_pinctrl_probe,\n\t.driver = {\n\t\t.name\t= \"samsung-pinctrl\",\n\t\t.of_match_table = samsung_pinctrl_dt_match,\n\t\t.suppress_bind_attrs = true,\n\t\t.pm = &samsung_pinctrl_pm_ops,\n\t},\n};\n\nstatic int __init samsung_pinctrl_drv_register(void)\n{\n\treturn platform_driver_register(&samsung_pinctrl_driver);\n}\npostcore_initcall(samsung_pinctrl_drv_register);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}