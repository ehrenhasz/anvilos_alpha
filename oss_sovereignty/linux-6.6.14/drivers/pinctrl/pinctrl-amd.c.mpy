{
  "module_name": "pinctrl-amd.c",
  "hash_id": "0b3f58b4adfe27211da844d9ceb3946b451e9f50164801d6d4780b6da8d06280",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/pinctrl-amd.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/bug.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/log2.h>\n#include <linux/io.h>\n#include <linux/gpio/driver.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/acpi.h>\n#include <linux/seq_file.h>\n#include <linux/interrupt.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinconf-generic.h>\n#include <linux/pinctrl/pinmux.h>\n#include <linux/suspend.h>\n\n#include \"core.h\"\n#include \"pinctrl-utils.h\"\n#include \"pinctrl-amd.h\"\n\nstatic int amd_gpio_get_direction(struct gpio_chip *gc, unsigned offset)\n{\n\tunsigned long flags;\n\tu32 pin_reg;\n\tstruct amd_gpio *gpio_dev = gpiochip_get_data(gc);\n\n\traw_spin_lock_irqsave(&gpio_dev->lock, flags);\n\tpin_reg = readl(gpio_dev->base + offset * 4);\n\traw_spin_unlock_irqrestore(&gpio_dev->lock, flags);\n\n\tif (pin_reg & BIT(OUTPUT_ENABLE_OFF))\n\t\treturn GPIO_LINE_DIRECTION_OUT;\n\n\treturn GPIO_LINE_DIRECTION_IN;\n}\n\nstatic int amd_gpio_direction_input(struct gpio_chip *gc, unsigned offset)\n{\n\tunsigned long flags;\n\tu32 pin_reg;\n\tstruct amd_gpio *gpio_dev = gpiochip_get_data(gc);\n\n\traw_spin_lock_irqsave(&gpio_dev->lock, flags);\n\tpin_reg = readl(gpio_dev->base + offset * 4);\n\tpin_reg &= ~BIT(OUTPUT_ENABLE_OFF);\n\twritel(pin_reg, gpio_dev->base + offset * 4);\n\traw_spin_unlock_irqrestore(&gpio_dev->lock, flags);\n\n\treturn 0;\n}\n\nstatic int amd_gpio_direction_output(struct gpio_chip *gc, unsigned offset,\n\t\tint value)\n{\n\tu32 pin_reg;\n\tunsigned long flags;\n\tstruct amd_gpio *gpio_dev = gpiochip_get_data(gc);\n\n\traw_spin_lock_irqsave(&gpio_dev->lock, flags);\n\tpin_reg = readl(gpio_dev->base + offset * 4);\n\tpin_reg |= BIT(OUTPUT_ENABLE_OFF);\n\tif (value)\n\t\tpin_reg |= BIT(OUTPUT_VALUE_OFF);\n\telse\n\t\tpin_reg &= ~BIT(OUTPUT_VALUE_OFF);\n\twritel(pin_reg, gpio_dev->base + offset * 4);\n\traw_spin_unlock_irqrestore(&gpio_dev->lock, flags);\n\n\treturn 0;\n}\n\nstatic int amd_gpio_get_value(struct gpio_chip *gc, unsigned offset)\n{\n\tu32 pin_reg;\n\tunsigned long flags;\n\tstruct amd_gpio *gpio_dev = gpiochip_get_data(gc);\n\n\traw_spin_lock_irqsave(&gpio_dev->lock, flags);\n\tpin_reg = readl(gpio_dev->base + offset * 4);\n\traw_spin_unlock_irqrestore(&gpio_dev->lock, flags);\n\n\treturn !!(pin_reg & BIT(PIN_STS_OFF));\n}\n\nstatic void amd_gpio_set_value(struct gpio_chip *gc, unsigned offset, int value)\n{\n\tu32 pin_reg;\n\tunsigned long flags;\n\tstruct amd_gpio *gpio_dev = gpiochip_get_data(gc);\n\n\traw_spin_lock_irqsave(&gpio_dev->lock, flags);\n\tpin_reg = readl(gpio_dev->base + offset * 4);\n\tif (value)\n\t\tpin_reg |= BIT(OUTPUT_VALUE_OFF);\n\telse\n\t\tpin_reg &= ~BIT(OUTPUT_VALUE_OFF);\n\twritel(pin_reg, gpio_dev->base + offset * 4);\n\traw_spin_unlock_irqrestore(&gpio_dev->lock, flags);\n}\n\nstatic int amd_gpio_set_debounce(struct amd_gpio *gpio_dev, unsigned int offset,\n\t\t\t\t unsigned int debounce)\n{\n\tu32 time;\n\tu32 pin_reg;\n\tint ret = 0;\n\n\t \n\tif (offset == 0) {\n\t\tpin_reg = readl(gpio_dev->base + WAKE_INT_MASTER_REG);\n\t\tif (pin_reg & INTERNAL_GPIO0_DEBOUNCE)\n\t\t\tdebounce = 0;\n\t}\n\n\tpin_reg = readl(gpio_dev->base + offset * 4);\n\n\tif (debounce) {\n\t\tpin_reg |= DB_TYPE_REMOVE_GLITCH << DB_CNTRL_OFF;\n\t\tpin_reg &= ~DB_TMR_OUT_MASK;\n\t\t \n\n\t\tif (debounce < 61) {\n\t\t\tpin_reg |= 1;\n\t\t\tpin_reg &= ~BIT(DB_TMR_OUT_UNIT_OFF);\n\t\t\tpin_reg &= ~BIT(DB_TMR_LARGE_OFF);\n\t\t} else if (debounce < 976) {\n\t\t\ttime = debounce / 61;\n\t\t\tpin_reg |= time & DB_TMR_OUT_MASK;\n\t\t\tpin_reg &= ~BIT(DB_TMR_OUT_UNIT_OFF);\n\t\t\tpin_reg &= ~BIT(DB_TMR_LARGE_OFF);\n\t\t} else if (debounce < 3900) {\n\t\t\ttime = debounce / 244;\n\t\t\tpin_reg |= time & DB_TMR_OUT_MASK;\n\t\t\tpin_reg |= BIT(DB_TMR_OUT_UNIT_OFF);\n\t\t\tpin_reg &= ~BIT(DB_TMR_LARGE_OFF);\n\t\t} else if (debounce < 250000) {\n\t\t\ttime = debounce / 15625;\n\t\t\tpin_reg |= time & DB_TMR_OUT_MASK;\n\t\t\tpin_reg &= ~BIT(DB_TMR_OUT_UNIT_OFF);\n\t\t\tpin_reg |= BIT(DB_TMR_LARGE_OFF);\n\t\t} else if (debounce < 1000000) {\n\t\t\ttime = debounce / 62500;\n\t\t\tpin_reg |= time & DB_TMR_OUT_MASK;\n\t\t\tpin_reg |= BIT(DB_TMR_OUT_UNIT_OFF);\n\t\t\tpin_reg |= BIT(DB_TMR_LARGE_OFF);\n\t\t} else {\n\t\t\tpin_reg &= ~(DB_CNTRl_MASK << DB_CNTRL_OFF);\n\t\t\tret = -EINVAL;\n\t\t}\n\t} else {\n\t\tpin_reg &= ~BIT(DB_TMR_OUT_UNIT_OFF);\n\t\tpin_reg &= ~BIT(DB_TMR_LARGE_OFF);\n\t\tpin_reg &= ~DB_TMR_OUT_MASK;\n\t\tpin_reg &= ~(DB_CNTRl_MASK << DB_CNTRL_OFF);\n\t}\n\twritel(pin_reg, gpio_dev->base + offset * 4);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic void amd_gpio_dbg_show(struct seq_file *s, struct gpio_chip *gc)\n{\n\tu32 pin_reg;\n\tu32 db_cntrl;\n\tunsigned long flags;\n\tunsigned int bank, i, pin_num;\n\tstruct amd_gpio *gpio_dev = gpiochip_get_data(gc);\n\n\tbool tmr_out_unit;\n\tbool tmr_large;\n\n\tchar *level_trig;\n\tchar *active_level;\n\tchar *interrupt_mask;\n\tchar *wake_cntrl0;\n\tchar *wake_cntrl1;\n\tchar *wake_cntrl2;\n\tchar *pin_sts;\n\tchar *interrupt_sts;\n\tchar *wake_sts;\n\tchar *orientation;\n\tchar debounce_value[40];\n\tchar *debounce_enable;\n\tchar *wake_cntrlz;\n\n\tseq_printf(s, \"WAKE_INT_MASTER_REG: 0x%08x\\n\", readl(gpio_dev->base + WAKE_INT_MASTER_REG));\n\tfor (bank = 0; bank < gpio_dev->hwbank_num; bank++) {\n\t\tunsigned int time = 0;\n\t\tunsigned int unit = 0;\n\n\t\tswitch (bank) {\n\t\tcase 0:\n\t\t\ti = 0;\n\t\t\tpin_num = AMD_GPIO_PINS_BANK0;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\ti = 64;\n\t\t\tpin_num = AMD_GPIO_PINS_BANK1 + i;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\ti = 128;\n\t\t\tpin_num = AMD_GPIO_PINS_BANK2 + i;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\ti = 192;\n\t\t\tpin_num = AMD_GPIO_PINS_BANK3 + i;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\t\tseq_printf(s, \"GPIO bank%d\\n\", bank);\n\t\tseq_puts(s, \"gpio\\t  int|active|trigger|S0i3| S3|S4/S5| Z|wake|pull|  orient|       debounce|reg\\n\");\n\t\tfor (; i < pin_num; i++) {\n\t\t\tseq_printf(s, \"#%d\\t\", i);\n\t\t\traw_spin_lock_irqsave(&gpio_dev->lock, flags);\n\t\t\tpin_reg = readl(gpio_dev->base + i * 4);\n\t\t\traw_spin_unlock_irqrestore(&gpio_dev->lock, flags);\n\n\t\t\tif (pin_reg & BIT(INTERRUPT_ENABLE_OFF)) {\n\t\t\t\tu8 level = (pin_reg >> ACTIVE_LEVEL_OFF) &\n\t\t\t\t\t\tACTIVE_LEVEL_MASK;\n\n\t\t\t\tif (level == ACTIVE_LEVEL_HIGH)\n\t\t\t\t\tactive_level = \"\u2191\";\n\t\t\t\telse if (level == ACTIVE_LEVEL_LOW)\n\t\t\t\t\tactive_level = \"\u2193\";\n\t\t\t\telse if (!(pin_reg & BIT(LEVEL_TRIG_OFF)) &&\n\t\t\t\t\t level == ACTIVE_LEVEL_BOTH)\n\t\t\t\t\tactive_level = \"b\";\n\t\t\t\telse\n\t\t\t\t\tactive_level = \"?\";\n\n\t\t\t\tif (pin_reg & BIT(LEVEL_TRIG_OFF))\n\t\t\t\t\tlevel_trig = \"level\";\n\t\t\t\telse\n\t\t\t\t\tlevel_trig = \" edge\";\n\n\t\t\t\tif (pin_reg & BIT(INTERRUPT_MASK_OFF))\n\t\t\t\t\tinterrupt_mask = \"\ud83d\ude1b\";\n\t\t\t\telse\n\t\t\t\t\tinterrupt_mask = \"\ud83d\ude37\";\n\n\t\t\t\tif (pin_reg & BIT(INTERRUPT_STS_OFF))\n\t\t\t\t\tinterrupt_sts = \"\ud83d\udd25\";\n\t\t\t\telse\n\t\t\t\t\tinterrupt_sts = \"  \";\n\n\t\t\t\tseq_printf(s, \"%s %s|     %s|  %s|\",\n\t\t\t\t   interrupt_sts,\n\t\t\t\t   interrupt_mask,\n\t\t\t\t   active_level,\n\t\t\t\t   level_trig);\n\t\t\t} else\n\t\t\t\tseq_puts(s, \"    \u2205|      |       |\");\n\n\t\t\tif (pin_reg & BIT(WAKE_CNTRL_OFF_S0I3))\n\t\t\t\twake_cntrl0 = \"\u23f0\";\n\t\t\telse\n\t\t\t\twake_cntrl0 = \"  \";\n\t\t\tseq_printf(s, \"  %s| \", wake_cntrl0);\n\n\t\t\tif (pin_reg & BIT(WAKE_CNTRL_OFF_S3))\n\t\t\t\twake_cntrl1 = \"\u23f0\";\n\t\t\telse\n\t\t\t\twake_cntrl1 = \"  \";\n\t\t\tseq_printf(s, \"%s|\", wake_cntrl1);\n\n\t\t\tif (pin_reg & BIT(WAKE_CNTRL_OFF_S4))\n\t\t\t\twake_cntrl2 = \"\u23f0\";\n\t\t\telse\n\t\t\t\twake_cntrl2 = \"  \";\n\t\t\tseq_printf(s, \"   %s|\", wake_cntrl2);\n\n\t\t\tif (pin_reg & BIT(WAKECNTRL_Z_OFF))\n\t\t\t\twake_cntrlz = \"\u23f0\";\n\t\t\telse\n\t\t\t\twake_cntrlz = \"  \";\n\t\t\tseq_printf(s, \"%s|\", wake_cntrlz);\n\n\t\t\tif (pin_reg & BIT(WAKE_STS_OFF))\n\t\t\t\twake_sts = \"\ud83d\udd25\";\n\t\t\telse\n\t\t\t\twake_sts = \" \";\n\t\t\tseq_printf(s, \"   %s|\", wake_sts);\n\n\t\t\tif (pin_reg & BIT(PULL_UP_ENABLE_OFF)) {\n\t\t\t\tseq_puts(s, \"  \u2191 |\");\n\t\t\t} else if (pin_reg & BIT(PULL_DOWN_ENABLE_OFF)) {\n\t\t\t\tseq_puts(s, \"  \u2193 |\");\n\t\t\t} else  {\n\t\t\t\tseq_puts(s, \"    |\");\n\t\t\t}\n\n\t\t\tif (pin_reg & BIT(OUTPUT_ENABLE_OFF)) {\n\t\t\t\tpin_sts = \"output\";\n\t\t\t\tif (pin_reg & BIT(OUTPUT_VALUE_OFF))\n\t\t\t\t\torientation = \"\u2191\";\n\t\t\t\telse\n\t\t\t\t\torientation = \"\u2193\";\n\t\t\t} else {\n\t\t\t\tpin_sts = \"input \";\n\t\t\t\tif (pin_reg & BIT(PIN_STS_OFF))\n\t\t\t\t\torientation = \"\u2191\";\n\t\t\t\telse\n\t\t\t\t\torientation = \"\u2193\";\n\t\t\t}\n\t\t\tseq_printf(s, \"%s %s|\", pin_sts, orientation);\n\n\t\t\tdb_cntrl = (DB_CNTRl_MASK << DB_CNTRL_OFF) & pin_reg;\n\t\t\tif (db_cntrl) {\n\t\t\t\ttmr_out_unit = pin_reg & BIT(DB_TMR_OUT_UNIT_OFF);\n\t\t\t\ttmr_large = pin_reg & BIT(DB_TMR_LARGE_OFF);\n\t\t\t\ttime = pin_reg & DB_TMR_OUT_MASK;\n\t\t\t\tif (tmr_large) {\n\t\t\t\t\tif (tmr_out_unit)\n\t\t\t\t\t\tunit = 62500;\n\t\t\t\t\telse\n\t\t\t\t\t\tunit = 15625;\n\t\t\t\t} else {\n\t\t\t\t\tif (tmr_out_unit)\n\t\t\t\t\t\tunit = 244;\n\t\t\t\t\telse\n\t\t\t\t\t\tunit = 61;\n\t\t\t\t}\n\t\t\t\tif ((DB_TYPE_REMOVE_GLITCH << DB_CNTRL_OFF) == db_cntrl)\n\t\t\t\t\tdebounce_enable = \"b\";\n\t\t\t\telse if ((DB_TYPE_PRESERVE_LOW_GLITCH << DB_CNTRL_OFF) == db_cntrl)\n\t\t\t\t\tdebounce_enable = \"\u2193\";\n\t\t\t\telse\n\t\t\t\t\tdebounce_enable = \"\u2191\";\n\t\t\t\tsnprintf(debounce_value, sizeof(debounce_value), \"%06u\", time * unit);\n\t\t\t\tseq_printf(s, \"%s (\ud83d\udd51 %sus)|\", debounce_enable, debounce_value);\n\t\t\t} else {\n\t\t\t\tseq_puts(s, \"               |\");\n\t\t\t}\n\t\t\tseq_printf(s, \"0x%x\\n\", pin_reg);\n\t\t}\n\t}\n}\n#else\n#define amd_gpio_dbg_show NULL\n#endif\n\nstatic void amd_gpio_irq_enable(struct irq_data *d)\n{\n\tu32 pin_reg;\n\tunsigned long flags;\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct amd_gpio *gpio_dev = gpiochip_get_data(gc);\n\n\tgpiochip_enable_irq(gc, d->hwirq);\n\n\traw_spin_lock_irqsave(&gpio_dev->lock, flags);\n\tpin_reg = readl(gpio_dev->base + (d->hwirq)*4);\n\tpin_reg |= BIT(INTERRUPT_ENABLE_OFF);\n\tpin_reg |= BIT(INTERRUPT_MASK_OFF);\n\twritel(pin_reg, gpio_dev->base + (d->hwirq)*4);\n\traw_spin_unlock_irqrestore(&gpio_dev->lock, flags);\n}\n\nstatic void amd_gpio_irq_disable(struct irq_data *d)\n{\n\tu32 pin_reg;\n\tunsigned long flags;\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct amd_gpio *gpio_dev = gpiochip_get_data(gc);\n\n\traw_spin_lock_irqsave(&gpio_dev->lock, flags);\n\tpin_reg = readl(gpio_dev->base + (d->hwirq)*4);\n\tpin_reg &= ~BIT(INTERRUPT_ENABLE_OFF);\n\tpin_reg &= ~BIT(INTERRUPT_MASK_OFF);\n\twritel(pin_reg, gpio_dev->base + (d->hwirq)*4);\n\traw_spin_unlock_irqrestore(&gpio_dev->lock, flags);\n\n\tgpiochip_disable_irq(gc, d->hwirq);\n}\n\nstatic void amd_gpio_irq_mask(struct irq_data *d)\n{\n\tu32 pin_reg;\n\tunsigned long flags;\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct amd_gpio *gpio_dev = gpiochip_get_data(gc);\n\n\traw_spin_lock_irqsave(&gpio_dev->lock, flags);\n\tpin_reg = readl(gpio_dev->base + (d->hwirq)*4);\n\tpin_reg &= ~BIT(INTERRUPT_MASK_OFF);\n\twritel(pin_reg, gpio_dev->base + (d->hwirq)*4);\n\traw_spin_unlock_irqrestore(&gpio_dev->lock, flags);\n}\n\nstatic void amd_gpio_irq_unmask(struct irq_data *d)\n{\n\tu32 pin_reg;\n\tunsigned long flags;\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct amd_gpio *gpio_dev = gpiochip_get_data(gc);\n\n\traw_spin_lock_irqsave(&gpio_dev->lock, flags);\n\tpin_reg = readl(gpio_dev->base + (d->hwirq)*4);\n\tpin_reg |= BIT(INTERRUPT_MASK_OFF);\n\twritel(pin_reg, gpio_dev->base + (d->hwirq)*4);\n\traw_spin_unlock_irqrestore(&gpio_dev->lock, flags);\n}\n\nstatic int amd_gpio_irq_set_wake(struct irq_data *d, unsigned int on)\n{\n\tu32 pin_reg;\n\tunsigned long flags;\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct amd_gpio *gpio_dev = gpiochip_get_data(gc);\n\tu32 wake_mask = BIT(WAKE_CNTRL_OFF_S0I3) | BIT(WAKE_CNTRL_OFF_S3);\n\tint err;\n\n\traw_spin_lock_irqsave(&gpio_dev->lock, flags);\n\tpin_reg = readl(gpio_dev->base + (d->hwirq)*4);\n\n\tif (on)\n\t\tpin_reg |= wake_mask;\n\telse\n\t\tpin_reg &= ~wake_mask;\n\n\twritel(pin_reg, gpio_dev->base + (d->hwirq)*4);\n\traw_spin_unlock_irqrestore(&gpio_dev->lock, flags);\n\n\tif (on)\n\t\terr = enable_irq_wake(gpio_dev->irq);\n\telse\n\t\terr = disable_irq_wake(gpio_dev->irq);\n\n\tif (err)\n\t\tdev_err(&gpio_dev->pdev->dev, \"failed to %s wake-up interrupt\\n\",\n\t\t\ton ? \"enable\" : \"disable\");\n\n\treturn 0;\n}\n\nstatic void amd_gpio_irq_eoi(struct irq_data *d)\n{\n\tu32 reg;\n\tunsigned long flags;\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct amd_gpio *gpio_dev = gpiochip_get_data(gc);\n\n\traw_spin_lock_irqsave(&gpio_dev->lock, flags);\n\treg = readl(gpio_dev->base + WAKE_INT_MASTER_REG);\n\treg |= EOI_MASK;\n\twritel(reg, gpio_dev->base + WAKE_INT_MASTER_REG);\n\traw_spin_unlock_irqrestore(&gpio_dev->lock, flags);\n}\n\nstatic int amd_gpio_irq_set_type(struct irq_data *d, unsigned int type)\n{\n\tint ret = 0;\n\tu32 pin_reg, pin_reg_irq_en, mask;\n\tunsigned long flags;\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct amd_gpio *gpio_dev = gpiochip_get_data(gc);\n\n\traw_spin_lock_irqsave(&gpio_dev->lock, flags);\n\tpin_reg = readl(gpio_dev->base + (d->hwirq)*4);\n\n\tswitch (type & IRQ_TYPE_SENSE_MASK) {\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tpin_reg &= ~BIT(LEVEL_TRIG_OFF);\n\t\tpin_reg &= ~(ACTIVE_LEVEL_MASK << ACTIVE_LEVEL_OFF);\n\t\tpin_reg |= ACTIVE_HIGH << ACTIVE_LEVEL_OFF;\n\t\tirq_set_handler_locked(d, handle_edge_irq);\n\t\tbreak;\n\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tpin_reg &= ~BIT(LEVEL_TRIG_OFF);\n\t\tpin_reg &= ~(ACTIVE_LEVEL_MASK << ACTIVE_LEVEL_OFF);\n\t\tpin_reg |= ACTIVE_LOW << ACTIVE_LEVEL_OFF;\n\t\tirq_set_handler_locked(d, handle_edge_irq);\n\t\tbreak;\n\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\tpin_reg &= ~BIT(LEVEL_TRIG_OFF);\n\t\tpin_reg &= ~(ACTIVE_LEVEL_MASK << ACTIVE_LEVEL_OFF);\n\t\tpin_reg |= BOTH_EADGE << ACTIVE_LEVEL_OFF;\n\t\tirq_set_handler_locked(d, handle_edge_irq);\n\t\tbreak;\n\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tpin_reg |= LEVEL_TRIGGER << LEVEL_TRIG_OFF;\n\t\tpin_reg &= ~(ACTIVE_LEVEL_MASK << ACTIVE_LEVEL_OFF);\n\t\tpin_reg |= ACTIVE_HIGH << ACTIVE_LEVEL_OFF;\n\t\tirq_set_handler_locked(d, handle_level_irq);\n\t\tbreak;\n\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tpin_reg |= LEVEL_TRIGGER << LEVEL_TRIG_OFF;\n\t\tpin_reg &= ~(ACTIVE_LEVEL_MASK << ACTIVE_LEVEL_OFF);\n\t\tpin_reg |= ACTIVE_LOW << ACTIVE_LEVEL_OFF;\n\t\tirq_set_handler_locked(d, handle_level_irq);\n\t\tbreak;\n\n\tcase IRQ_TYPE_NONE:\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(&gpio_dev->pdev->dev, \"Invalid type value\\n\");\n\t\tret = -EINVAL;\n\t}\n\n\tpin_reg |= CLR_INTR_STAT << INTERRUPT_STS_OFF;\n\t \n\tmask = BIT(INTERRUPT_ENABLE_OFF);\n\tpin_reg_irq_en = pin_reg;\n\tpin_reg_irq_en |= mask;\n\tpin_reg_irq_en &= ~BIT(INTERRUPT_MASK_OFF);\n\twritel(pin_reg_irq_en, gpio_dev->base + (d->hwirq)*4);\n\twhile ((readl(gpio_dev->base + (d->hwirq)*4) & mask) != mask)\n\t\tcontinue;\n\twritel(pin_reg, gpio_dev->base + (d->hwirq)*4);\n\traw_spin_unlock_irqrestore(&gpio_dev->lock, flags);\n\n\treturn ret;\n}\n\nstatic void amd_irq_ack(struct irq_data *d)\n{\n\t \n}\n\nstatic const struct irq_chip amd_gpio_irqchip = {\n\t.name         = \"amd_gpio\",\n\t.irq_ack      = amd_irq_ack,\n\t.irq_enable   = amd_gpio_irq_enable,\n\t.irq_disable  = amd_gpio_irq_disable,\n\t.irq_mask     = amd_gpio_irq_mask,\n\t.irq_unmask   = amd_gpio_irq_unmask,\n\t.irq_set_wake = amd_gpio_irq_set_wake,\n\t.irq_eoi      = amd_gpio_irq_eoi,\n\t.irq_set_type = amd_gpio_irq_set_type,\n\t \n\t.flags        = IRQCHIP_ENABLE_WAKEUP_ON_SUSPEND | IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\n#define PIN_IRQ_PENDING\t(BIT(INTERRUPT_STS_OFF) | BIT(WAKE_STS_OFF))\n\nstatic bool do_amd_gpio_irq_handler(int irq, void *dev_id)\n{\n\tstruct amd_gpio *gpio_dev = dev_id;\n\tstruct gpio_chip *gc = &gpio_dev->gc;\n\tunsigned int i, irqnr;\n\tunsigned long flags;\n\tu32 __iomem *regs;\n\tbool ret = false;\n\tu32  regval;\n\tu64 status, mask;\n\n\t \n\traw_spin_lock_irqsave(&gpio_dev->lock, flags);\n\tstatus = readl(gpio_dev->base + WAKE_INT_STATUS_REG1);\n\tstatus <<= 32;\n\tstatus |= readl(gpio_dev->base + WAKE_INT_STATUS_REG0);\n\traw_spin_unlock_irqrestore(&gpio_dev->lock, flags);\n\n\t \n\tstatus &= (1ULL << 46) - 1;\n\tregs = gpio_dev->base;\n\tfor (mask = 1, irqnr = 0; status; mask <<= 1, regs += 4, irqnr += 4) {\n\t\tif (!(status & mask))\n\t\t\tcontinue;\n\t\tstatus &= ~mask;\n\n\t\t \n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tregval = readl(regs + i);\n\n\t\t\tif (regval & PIN_IRQ_PENDING)\n\t\t\t\tpm_pr_dbg(\"GPIO %d is active: 0x%x\",\n\t\t\t\t\t  irqnr + i, regval);\n\n\t\t\t \n\t\t\tif (irq < 0 && (regval & BIT(WAKE_STS_OFF)))\n\t\t\t\treturn true;\n\n\t\t\tif (!(regval & PIN_IRQ_PENDING) ||\n\t\t\t    !(regval & BIT(INTERRUPT_MASK_OFF)))\n\t\t\t\tcontinue;\n\t\t\tgeneric_handle_domain_irq_safe(gc->irq.domain, irqnr + i);\n\n\t\t\t \n\t\t\traw_spin_lock_irqsave(&gpio_dev->lock, flags);\n\t\t\tregval = readl(regs + i);\n\t\t\tif (!gpiochip_line_is_irq(gc, irqnr + i)) {\n\t\t\t\tregval &= ~BIT(INTERRUPT_MASK_OFF);\n\t\t\t\tdev_dbg(&gpio_dev->pdev->dev,\n\t\t\t\t\t\"Disabling spurious GPIO IRQ %d\\n\",\n\t\t\t\t\tirqnr + i);\n\t\t\t} else {\n\t\t\t\tret = true;\n\t\t\t}\n\t\t\twritel(regval, regs + i);\n\t\t\traw_spin_unlock_irqrestore(&gpio_dev->lock, flags);\n\t\t}\n\t}\n\t \n\tif (irq < 0)\n\t\treturn false;\n\n\t \n\traw_spin_lock_irqsave(&gpio_dev->lock, flags);\n\tregval = readl(gpio_dev->base + WAKE_INT_MASTER_REG);\n\tregval |= EOI_MASK;\n\twritel(regval, gpio_dev->base + WAKE_INT_MASTER_REG);\n\traw_spin_unlock_irqrestore(&gpio_dev->lock, flags);\n\n\treturn ret;\n}\n\nstatic irqreturn_t amd_gpio_irq_handler(int irq, void *dev_id)\n{\n\treturn IRQ_RETVAL(do_amd_gpio_irq_handler(irq, dev_id));\n}\n\nstatic bool __maybe_unused amd_gpio_check_wake(void *dev_id)\n{\n\treturn do_amd_gpio_irq_handler(-1, dev_id);\n}\n\nstatic int amd_get_groups_count(struct pinctrl_dev *pctldev)\n{\n\tstruct amd_gpio *gpio_dev = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn gpio_dev->ngroups;\n}\n\nstatic const char *amd_get_group_name(struct pinctrl_dev *pctldev,\n\t\t\t\t      unsigned group)\n{\n\tstruct amd_gpio *gpio_dev = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn gpio_dev->groups[group].name;\n}\n\nstatic int amd_get_group_pins(struct pinctrl_dev *pctldev,\n\t\t\t      unsigned group,\n\t\t\t      const unsigned **pins,\n\t\t\t      unsigned *num_pins)\n{\n\tstruct amd_gpio *gpio_dev = pinctrl_dev_get_drvdata(pctldev);\n\n\t*pins = gpio_dev->groups[group].pins;\n\t*num_pins = gpio_dev->groups[group].npins;\n\treturn 0;\n}\n\nstatic const struct pinctrl_ops amd_pinctrl_ops = {\n\t.get_groups_count\t= amd_get_groups_count,\n\t.get_group_name\t\t= amd_get_group_name,\n\t.get_group_pins\t\t= amd_get_group_pins,\n#ifdef CONFIG_OF\n\t.dt_node_to_map\t\t= pinconf_generic_dt_node_to_map_group,\n\t.dt_free_map\t\t= pinctrl_utils_free_map,\n#endif\n};\n\nstatic int amd_pinconf_get(struct pinctrl_dev *pctldev,\n\t\t\t  unsigned int pin,\n\t\t\t  unsigned long *config)\n{\n\tu32 pin_reg;\n\tunsigned arg;\n\tunsigned long flags;\n\tstruct amd_gpio *gpio_dev = pinctrl_dev_get_drvdata(pctldev);\n\tenum pin_config_param param = pinconf_to_config_param(*config);\n\n\traw_spin_lock_irqsave(&gpio_dev->lock, flags);\n\tpin_reg = readl(gpio_dev->base + pin*4);\n\traw_spin_unlock_irqrestore(&gpio_dev->lock, flags);\n\tswitch (param) {\n\tcase PIN_CONFIG_INPUT_DEBOUNCE:\n\t\targ = pin_reg & DB_TMR_OUT_MASK;\n\t\tbreak;\n\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\targ = (pin_reg >> PULL_DOWN_ENABLE_OFF) & BIT(0);\n\t\tbreak;\n\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\targ = (pin_reg >> PULL_UP_ENABLE_OFF) & BIT(0);\n\t\tbreak;\n\n\tcase PIN_CONFIG_DRIVE_STRENGTH:\n\t\targ = (pin_reg >> DRV_STRENGTH_SEL_OFF) & DRV_STRENGTH_SEL_MASK;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_dbg(&gpio_dev->pdev->dev, \"Invalid config param %04x\\n\",\n\t\t\tparam);\n\t\treturn -ENOTSUPP;\n\t}\n\n\t*config = pinconf_to_config_packed(param, arg);\n\n\treturn 0;\n}\n\nstatic int amd_pinconf_set(struct pinctrl_dev *pctldev, unsigned int pin,\n\t\t\t   unsigned long *configs, unsigned int num_configs)\n{\n\tint i;\n\tu32 arg;\n\tint ret = 0;\n\tu32 pin_reg;\n\tunsigned long flags;\n\tenum pin_config_param param;\n\tstruct amd_gpio *gpio_dev = pinctrl_dev_get_drvdata(pctldev);\n\n\traw_spin_lock_irqsave(&gpio_dev->lock, flags);\n\tfor (i = 0; i < num_configs; i++) {\n\t\tparam = pinconf_to_config_param(configs[i]);\n\t\targ = pinconf_to_config_argument(configs[i]);\n\t\tpin_reg = readl(gpio_dev->base + pin*4);\n\n\t\tswitch (param) {\n\t\tcase PIN_CONFIG_INPUT_DEBOUNCE:\n\t\t\tret = amd_gpio_set_debounce(gpio_dev, pin, arg);\n\t\t\tgoto out_unlock;\n\n\t\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\t\tpin_reg &= ~BIT(PULL_DOWN_ENABLE_OFF);\n\t\t\tpin_reg |= (arg & BIT(0)) << PULL_DOWN_ENABLE_OFF;\n\t\t\tbreak;\n\n\t\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\t\tpin_reg &= ~BIT(PULL_UP_ENABLE_OFF);\n\t\t\tpin_reg |= (arg & BIT(0)) << PULL_UP_ENABLE_OFF;\n\t\t\tbreak;\n\n\t\tcase PIN_CONFIG_DRIVE_STRENGTH:\n\t\t\tpin_reg &= ~(DRV_STRENGTH_SEL_MASK\n\t\t\t\t\t<< DRV_STRENGTH_SEL_OFF);\n\t\t\tpin_reg |= (arg & DRV_STRENGTH_SEL_MASK)\n\t\t\t\t\t<< DRV_STRENGTH_SEL_OFF;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_dbg(&gpio_dev->pdev->dev,\n\t\t\t\t\"Invalid config param %04x\\n\", param);\n\t\t\tret = -ENOTSUPP;\n\t\t}\n\n\t\twritel(pin_reg, gpio_dev->base + pin*4);\n\t}\nout_unlock:\n\traw_spin_unlock_irqrestore(&gpio_dev->lock, flags);\n\n\treturn ret;\n}\n\nstatic int amd_pinconf_group_get(struct pinctrl_dev *pctldev,\n\t\t\t\tunsigned int group,\n\t\t\t\tunsigned long *config)\n{\n\tconst unsigned *pins;\n\tunsigned npins;\n\tint ret;\n\n\tret = amd_get_group_pins(pctldev, group, &pins, &npins);\n\tif (ret)\n\t\treturn ret;\n\n\tif (amd_pinconf_get(pctldev, pins[0], config))\n\t\t\treturn -ENOTSUPP;\n\n\treturn 0;\n}\n\nstatic int amd_pinconf_group_set(struct pinctrl_dev *pctldev,\n\t\t\t\tunsigned group, unsigned long *configs,\n\t\t\t\tunsigned num_configs)\n{\n\tconst unsigned *pins;\n\tunsigned npins;\n\tint i, ret;\n\n\tret = amd_get_group_pins(pctldev, group, &pins, &npins);\n\tif (ret)\n\t\treturn ret;\n\tfor (i = 0; i < npins; i++) {\n\t\tif (amd_pinconf_set(pctldev, pins[i], configs, num_configs))\n\t\t\treturn -ENOTSUPP;\n\t}\n\treturn 0;\n}\n\nstatic int amd_gpio_set_config(struct gpio_chip *gc, unsigned int pin,\n\t\t\t       unsigned long config)\n{\n\tstruct amd_gpio *gpio_dev = gpiochip_get_data(gc);\n\n\treturn amd_pinconf_set(gpio_dev->pctrl, pin, &config, 1);\n}\n\nstatic const struct pinconf_ops amd_pinconf_ops = {\n\t.pin_config_get\t\t= amd_pinconf_get,\n\t.pin_config_set\t\t= amd_pinconf_set,\n\t.pin_config_group_get = amd_pinconf_group_get,\n\t.pin_config_group_set = amd_pinconf_group_set,\n};\n\nstatic void amd_gpio_irq_init(struct amd_gpio *gpio_dev)\n{\n\tstruct pinctrl_desc *desc = gpio_dev->pctrl->desc;\n\tunsigned long flags;\n\tu32 pin_reg, mask;\n\tint i;\n\n\tmask = BIT(WAKE_CNTRL_OFF_S0I3) | BIT(WAKE_CNTRL_OFF_S3) |\n\t\tBIT(WAKE_CNTRL_OFF_S4);\n\n\tfor (i = 0; i < desc->npins; i++) {\n\t\tint pin = desc->pins[i].number;\n\t\tconst struct pin_desc *pd = pin_desc_get(gpio_dev->pctrl, pin);\n\n\t\tif (!pd)\n\t\t\tcontinue;\n\n\t\traw_spin_lock_irqsave(&gpio_dev->lock, flags);\n\n\t\tpin_reg = readl(gpio_dev->base + pin * 4);\n\t\tpin_reg &= ~mask;\n\t\twritel(pin_reg, gpio_dev->base + pin * 4);\n\n\t\traw_spin_unlock_irqrestore(&gpio_dev->lock, flags);\n\t}\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic bool amd_gpio_should_save(struct amd_gpio *gpio_dev, unsigned int pin)\n{\n\tconst struct pin_desc *pd = pin_desc_get(gpio_dev->pctrl, pin);\n\n\tif (!pd)\n\t\treturn false;\n\n\t \n\tif (pd->mux_owner || pd->gpio_owner ||\n\t    gpiochip_line_is_irq(&gpio_dev->gc, pin))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int amd_gpio_suspend(struct device *dev)\n{\n\tstruct amd_gpio *gpio_dev = dev_get_drvdata(dev);\n\tstruct pinctrl_desc *desc = gpio_dev->pctrl->desc;\n\tunsigned long flags;\n\tint i;\n\n\tfor (i = 0; i < desc->npins; i++) {\n\t\tint pin = desc->pins[i].number;\n\n\t\tif (!amd_gpio_should_save(gpio_dev, pin))\n\t\t\tcontinue;\n\n\t\traw_spin_lock_irqsave(&gpio_dev->lock, flags);\n\t\tgpio_dev->saved_regs[i] = readl(gpio_dev->base + pin * 4) & ~PIN_IRQ_PENDING;\n\n\t\t \n\t\tif (!(gpio_dev->saved_regs[i] & WAKE_SOURCE)) {\n\t\t\twritel(gpio_dev->saved_regs[i] & ~BIT(INTERRUPT_MASK_OFF),\n\t\t\t       gpio_dev->base + pin * 4);\n\t\t\tpm_pr_dbg(\"Disabling GPIO #%d interrupt for suspend.\\n\",\n\t\t\t\t  pin);\n\t\t}\n\n\t\traw_spin_unlock_irqrestore(&gpio_dev->lock, flags);\n\t}\n\n\treturn 0;\n}\n\nstatic int amd_gpio_resume(struct device *dev)\n{\n\tstruct amd_gpio *gpio_dev = dev_get_drvdata(dev);\n\tstruct pinctrl_desc *desc = gpio_dev->pctrl->desc;\n\tunsigned long flags;\n\tint i;\n\n\tfor (i = 0; i < desc->npins; i++) {\n\t\tint pin = desc->pins[i].number;\n\n\t\tif (!amd_gpio_should_save(gpio_dev, pin))\n\t\t\tcontinue;\n\n\t\traw_spin_lock_irqsave(&gpio_dev->lock, flags);\n\t\tgpio_dev->saved_regs[i] |= readl(gpio_dev->base + pin * 4) & PIN_IRQ_PENDING;\n\t\twritel(gpio_dev->saved_regs[i], gpio_dev->base + pin * 4);\n\t\traw_spin_unlock_irqrestore(&gpio_dev->lock, flags);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops amd_gpio_pm_ops = {\n\tSET_LATE_SYSTEM_SLEEP_PM_OPS(amd_gpio_suspend,\n\t\t\t\t     amd_gpio_resume)\n};\n#endif\n\nstatic int amd_get_functions_count(struct pinctrl_dev *pctldev)\n{\n\treturn ARRAY_SIZE(pmx_functions);\n}\n\nstatic const char *amd_get_fname(struct pinctrl_dev *pctrldev, unsigned int selector)\n{\n\treturn pmx_functions[selector].name;\n}\n\nstatic int amd_get_groups(struct pinctrl_dev *pctrldev, unsigned int selector,\n\t\t\t  const char * const **groups,\n\t\t\t  unsigned int * const num_groups)\n{\n\tstruct amd_gpio *gpio_dev = pinctrl_dev_get_drvdata(pctrldev);\n\n\tif (!gpio_dev->iomux_base) {\n\t\tdev_err(&gpio_dev->pdev->dev, \"iomux function %d group not supported\\n\", selector);\n\t\treturn -EINVAL;\n\t}\n\n\t*groups = pmx_functions[selector].groups;\n\t*num_groups = pmx_functions[selector].ngroups;\n\treturn 0;\n}\n\nstatic int amd_set_mux(struct pinctrl_dev *pctrldev, unsigned int function, unsigned int group)\n{\n\tstruct amd_gpio *gpio_dev = pinctrl_dev_get_drvdata(pctrldev);\n\tstruct device *dev = &gpio_dev->pdev->dev;\n\tstruct pin_desc *pd;\n\tint ind, index;\n\n\tif (!gpio_dev->iomux_base)\n\t\treturn -EINVAL;\n\n\tfor (index = 0; index < NSELECTS; index++) {\n\t\tif (strcmp(gpio_dev->groups[group].name,  pmx_functions[function].groups[index]))\n\t\t\tcontinue;\n\n\t\tif (readb(gpio_dev->iomux_base + pmx_functions[function].index) ==\n\t\t\t\tFUNCTION_INVALID) {\n\t\t\tdev_err(dev, \"IOMUX_GPIO 0x%x not present or supported\\n\",\n\t\t\t\tpmx_functions[function].index);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\twriteb(index, gpio_dev->iomux_base + pmx_functions[function].index);\n\n\t\tif (index != (readb(gpio_dev->iomux_base + pmx_functions[function].index) &\n\t\t\t\t\tFUNCTION_MASK)) {\n\t\t\tdev_err(dev, \"IOMUX_GPIO 0x%x not present or supported\\n\",\n\t\t\t\tpmx_functions[function].index);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfor (ind = 0; ind < gpio_dev->groups[group].npins; ind++) {\n\t\t\tif (strncmp(gpio_dev->groups[group].name, \"IMX_F\", strlen(\"IMX_F\")))\n\t\t\t\tcontinue;\n\n\t\t\tpd = pin_desc_get(gpio_dev->pctrl, gpio_dev->groups[group].pins[ind]);\n\t\t\tpd->mux_owner = gpio_dev->groups[group].name;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct pinmux_ops amd_pmxops = {\n\t.get_functions_count = amd_get_functions_count,\n\t.get_function_name = amd_get_fname,\n\t.get_function_groups = amd_get_groups,\n\t.set_mux = amd_set_mux,\n};\n\nstatic struct pinctrl_desc amd_pinctrl_desc = {\n\t.pins\t= kerncz_pins,\n\t.npins = ARRAY_SIZE(kerncz_pins),\n\t.pctlops = &amd_pinctrl_ops,\n\t.pmxops = &amd_pmxops,\n\t.confops = &amd_pinconf_ops,\n\t.owner = THIS_MODULE,\n};\n\nstatic void amd_get_iomux_res(struct amd_gpio *gpio_dev)\n{\n\tstruct pinctrl_desc *desc = &amd_pinctrl_desc;\n\tstruct device *dev = &gpio_dev->pdev->dev;\n\tint index;\n\n\tindex = device_property_match_string(dev, \"pinctrl-resource-names\",  \"iomux\");\n\tif (index < 0) {\n\t\tdev_dbg(dev, \"iomux not supported\\n\");\n\t\tgoto out_no_pinmux;\n\t}\n\n\tgpio_dev->iomux_base = devm_platform_ioremap_resource(gpio_dev->pdev, index);\n\tif (IS_ERR(gpio_dev->iomux_base)) {\n\t\tdev_dbg(dev, \"iomux not supported %d io resource\\n\", index);\n\t\tgoto out_no_pinmux;\n\t}\n\n\treturn;\n\nout_no_pinmux:\n\tdesc->pmxops = NULL;\n}\n\nstatic int amd_gpio_probe(struct platform_device *pdev)\n{\n\tint ret = 0;\n\tstruct resource *res;\n\tstruct amd_gpio *gpio_dev;\n\tstruct gpio_irq_chip *girq;\n\n\tgpio_dev = devm_kzalloc(&pdev->dev,\n\t\t\t\tsizeof(struct amd_gpio), GFP_KERNEL);\n\tif (!gpio_dev)\n\t\treturn -ENOMEM;\n\n\traw_spin_lock_init(&gpio_dev->lock);\n\n\tgpio_dev->base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(gpio_dev->base)) {\n\t\tdev_err(&pdev->dev, \"Failed to get gpio io resource.\\n\");\n\t\treturn PTR_ERR(gpio_dev->base);\n\t}\n\n\tgpio_dev->irq = platform_get_irq(pdev, 0);\n\tif (gpio_dev->irq < 0)\n\t\treturn gpio_dev->irq;\n\n#ifdef CONFIG_PM_SLEEP\n\tgpio_dev->saved_regs = devm_kcalloc(&pdev->dev, amd_pinctrl_desc.npins,\n\t\t\t\t\t    sizeof(*gpio_dev->saved_regs),\n\t\t\t\t\t    GFP_KERNEL);\n\tif (!gpio_dev->saved_regs)\n\t\treturn -ENOMEM;\n#endif\n\n\tgpio_dev->pdev = pdev;\n\tgpio_dev->gc.get_direction\t= amd_gpio_get_direction;\n\tgpio_dev->gc.direction_input\t= amd_gpio_direction_input;\n\tgpio_dev->gc.direction_output\t= amd_gpio_direction_output;\n\tgpio_dev->gc.get\t\t\t= amd_gpio_get_value;\n\tgpio_dev->gc.set\t\t\t= amd_gpio_set_value;\n\tgpio_dev->gc.set_config\t\t= amd_gpio_set_config;\n\tgpio_dev->gc.dbg_show\t\t= amd_gpio_dbg_show;\n\n\tgpio_dev->gc.base\t\t= -1;\n\tgpio_dev->gc.label\t\t\t= pdev->name;\n\tgpio_dev->gc.owner\t\t\t= THIS_MODULE;\n\tgpio_dev->gc.parent\t\t\t= &pdev->dev;\n\tgpio_dev->gc.ngpio\t\t\t= resource_size(res) / 4;\n\n\tgpio_dev->hwbank_num = gpio_dev->gc.ngpio / 64;\n\tgpio_dev->groups = kerncz_groups;\n\tgpio_dev->ngroups = ARRAY_SIZE(kerncz_groups);\n\n\tamd_pinctrl_desc.name = dev_name(&pdev->dev);\n\tamd_get_iomux_res(gpio_dev);\n\tgpio_dev->pctrl = devm_pinctrl_register(&pdev->dev, &amd_pinctrl_desc,\n\t\t\t\t\t\tgpio_dev);\n\tif (IS_ERR(gpio_dev->pctrl)) {\n\t\tdev_err(&pdev->dev, \"Couldn't register pinctrl driver\\n\");\n\t\treturn PTR_ERR(gpio_dev->pctrl);\n\t}\n\n\t \n\tamd_gpio_irq_init(gpio_dev);\n\n\tgirq = &gpio_dev->gc.irq;\n\tgpio_irq_chip_set_chip(girq, &amd_gpio_irqchip);\n\t \n\tgirq->parent_handler = NULL;\n\tgirq->num_parents = 0;\n\tgirq->parents = NULL;\n\tgirq->default_type = IRQ_TYPE_NONE;\n\tgirq->handler = handle_simple_irq;\n\n\tret = gpiochip_add_data(&gpio_dev->gc, gpio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = gpiochip_add_pin_range(&gpio_dev->gc, dev_name(&pdev->dev),\n\t\t\t\t0, 0, gpio_dev->gc.ngpio);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to add pin range\\n\");\n\t\tgoto out2;\n\t}\n\n\tret = devm_request_irq(&pdev->dev, gpio_dev->irq, amd_gpio_irq_handler,\n\t\t\t       IRQF_SHARED, KBUILD_MODNAME, gpio_dev);\n\tif (ret)\n\t\tgoto out2;\n\n\tplatform_set_drvdata(pdev, gpio_dev);\n\tacpi_register_wakeup_handler(gpio_dev->irq, amd_gpio_check_wake, gpio_dev);\n\n\tdev_dbg(&pdev->dev, \"amd gpio driver loaded\\n\");\n\treturn ret;\n\nout2:\n\tgpiochip_remove(&gpio_dev->gc);\n\n\treturn ret;\n}\n\nstatic int amd_gpio_remove(struct platform_device *pdev)\n{\n\tstruct amd_gpio *gpio_dev;\n\n\tgpio_dev = platform_get_drvdata(pdev);\n\n\tgpiochip_remove(&gpio_dev->gc);\n\tacpi_unregister_wakeup_handler(amd_gpio_check_wake, gpio_dev);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id amd_gpio_acpi_match[] = {\n\t{ \"AMD0030\", 0 },\n\t{ \"AMDI0030\", 0},\n\t{ \"AMDI0031\", 0},\n\t{ },\n};\nMODULE_DEVICE_TABLE(acpi, amd_gpio_acpi_match);\n#endif\n\nstatic struct platform_driver amd_gpio_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"amd_gpio\",\n\t\t.acpi_match_table = ACPI_PTR(amd_gpio_acpi_match),\n#ifdef CONFIG_PM_SLEEP\n\t\t.pm\t= &amd_gpio_pm_ops,\n#endif\n\t},\n\t.probe\t\t= amd_gpio_probe,\n\t.remove\t\t= amd_gpio_remove,\n};\n\nmodule_platform_driver(amd_gpio_driver);\n\nMODULE_AUTHOR(\"Ken Xue <Ken.Xue@amd.com>, Jeff Wu <Jeff.Wu@amd.com>\");\nMODULE_DESCRIPTION(\"AMD GPIO pinctrl driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}