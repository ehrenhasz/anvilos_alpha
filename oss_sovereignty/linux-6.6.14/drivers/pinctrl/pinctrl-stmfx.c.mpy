{
  "module_name": "pinctrl-stmfx.c",
  "hash_id": "3007f80a4888e41b217f322e4d1faebf6540a6951cb889b50db6a247d35fdfb2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/pinctrl-stmfx.c",
  "human_readable_source": "\n \n#include <linux/gpio/driver.h>\n#include <linux/interrupt.h>\n#include <linux/mfd/stmfx.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/seq_file.h>\n\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinmux.h>\n\n#include \"core.h\"\n#include \"pinctrl-utils.h\"\n\n \n \n#define STMFX_REG_GPIO_STATE\t\tSTMFX_REG_GPIO_STATE1  \n \n#define STMFX_REG_GPIO_DIR\t\tSTMFX_REG_GPIO_DIR1  \n \n#define STMFX_REG_GPIO_TYPE\t\tSTMFX_REG_GPIO_TYPE1  \n \n#define STMFX_REG_GPIO_PUPD\t\tSTMFX_REG_GPIO_PUPD1  \n \n#define STMFX_REG_GPO_SET\t\tSTMFX_REG_GPO_SET1  \n \n#define STMFX_REG_GPO_CLR\t\tSTMFX_REG_GPO_CLR1  \n \n#define STMFX_REG_IRQ_GPI_SRC\t\tSTMFX_REG_IRQ_GPI_SRC1  \n \n#define STMFX_REG_IRQ_GPI_EVT\t\tSTMFX_REG_IRQ_GPI_EVT1  \n \n#define STMFX_REG_IRQ_GPI_TYPE\t\tSTMFX_REG_IRQ_GPI_TYPE1  \n \n#define STMFX_REG_IRQ_GPI_PENDING\tSTMFX_REG_IRQ_GPI_PENDING1  \n \n#define STMFX_REG_IRQ_GPI_ACK\t\tSTMFX_REG_IRQ_GPI_ACK1  \n\n#define NR_GPIO_REGS\t\t\t3\n#define NR_GPIOS_PER_REG\t\t8\n#define get_reg(offset)\t\t\t((offset) / NR_GPIOS_PER_REG)\n#define get_shift(offset)\t\t((offset) % NR_GPIOS_PER_REG)\n#define get_mask(offset)\t\t(BIT(get_shift(offset)))\n\n \nstatic const struct pinctrl_pin_desc stmfx_pins[] = {\n\tPINCTRL_PIN(0, \"gpio0\"),\n\tPINCTRL_PIN(1, \"gpio1\"),\n\tPINCTRL_PIN(2, \"gpio2\"),\n\tPINCTRL_PIN(3, \"gpio3\"),\n\tPINCTRL_PIN(4, \"gpio4\"),\n\tPINCTRL_PIN(5, \"gpio5\"),\n\tPINCTRL_PIN(6, \"gpio6\"),\n\tPINCTRL_PIN(7, \"gpio7\"),\n\tPINCTRL_PIN(8, \"gpio8\"),\n\tPINCTRL_PIN(9, \"gpio9\"),\n\tPINCTRL_PIN(10, \"gpio10\"),\n\tPINCTRL_PIN(11, \"gpio11\"),\n\tPINCTRL_PIN(12, \"gpio12\"),\n\tPINCTRL_PIN(13, \"gpio13\"),\n\tPINCTRL_PIN(14, \"gpio14\"),\n\tPINCTRL_PIN(15, \"gpio15\"),\n\tPINCTRL_PIN(16, \"agpio0\"),\n\tPINCTRL_PIN(17, \"agpio1\"),\n\tPINCTRL_PIN(18, \"agpio2\"),\n\tPINCTRL_PIN(19, \"agpio3\"),\n\tPINCTRL_PIN(20, \"agpio4\"),\n\tPINCTRL_PIN(21, \"agpio5\"),\n\tPINCTRL_PIN(22, \"agpio6\"),\n\tPINCTRL_PIN(23, \"agpio7\"),\n};\n\nstruct stmfx_pinctrl {\n\tstruct device *dev;\n\tstruct stmfx *stmfx;\n\tstruct pinctrl_dev *pctl_dev;\n\tstruct pinctrl_desc pctl_desc;\n\tstruct gpio_chip gpio_chip;\n\tstruct mutex lock;  \n\tunsigned long gpio_valid_mask;\n\t \n\tu8 irq_gpi_src[NR_GPIO_REGS];\n\tu8 irq_gpi_type[NR_GPIO_REGS];\n\tu8 irq_gpi_evt[NR_GPIO_REGS];\n\tu8 irq_toggle_edge[NR_GPIO_REGS];\n#ifdef CONFIG_PM\n\t \n\tu8 bkp_gpio_state[NR_GPIO_REGS];\n\tu8 bkp_gpio_dir[NR_GPIO_REGS];\n\tu8 bkp_gpio_type[NR_GPIO_REGS];\n\tu8 bkp_gpio_pupd[NR_GPIO_REGS];\n#endif\n};\n\nstatic int stmfx_gpio_get(struct gpio_chip *gc, unsigned int offset)\n{\n\tstruct stmfx_pinctrl *pctl = gpiochip_get_data(gc);\n\tu32 reg = STMFX_REG_GPIO_STATE + get_reg(offset);\n\tu32 mask = get_mask(offset);\n\tu32 value;\n\tint ret;\n\n\tret = regmap_read(pctl->stmfx->map, reg, &value);\n\n\treturn ret ? ret : !!(value & mask);\n}\n\nstatic void stmfx_gpio_set(struct gpio_chip *gc, unsigned int offset, int value)\n{\n\tstruct stmfx_pinctrl *pctl = gpiochip_get_data(gc);\n\tu32 reg = value ? STMFX_REG_GPO_SET : STMFX_REG_GPO_CLR;\n\tu32 mask = get_mask(offset);\n\n\tregmap_write_bits(pctl->stmfx->map, reg + get_reg(offset),\n\t\t\t  mask, mask);\n}\n\nstatic int stmfx_gpio_get_direction(struct gpio_chip *gc, unsigned int offset)\n{\n\tstruct stmfx_pinctrl *pctl = gpiochip_get_data(gc);\n\tu32 reg = STMFX_REG_GPIO_DIR + get_reg(offset);\n\tu32 mask = get_mask(offset);\n\tu32 val;\n\tint ret;\n\n\tret = regmap_read(pctl->stmfx->map, reg, &val);\n\t \n\tif (ret)\n\t\treturn ret;\n\n\tif (val & mask)\n\t\treturn GPIO_LINE_DIRECTION_OUT;\n\n\treturn GPIO_LINE_DIRECTION_IN;\n}\n\nstatic int stmfx_gpio_direction_input(struct gpio_chip *gc, unsigned int offset)\n{\n\tstruct stmfx_pinctrl *pctl = gpiochip_get_data(gc);\n\tu32 reg = STMFX_REG_GPIO_DIR + get_reg(offset);\n\tu32 mask = get_mask(offset);\n\n\treturn regmap_write_bits(pctl->stmfx->map, reg, mask, 0);\n}\n\nstatic int stmfx_gpio_direction_output(struct gpio_chip *gc,\n\t\t\t\t       unsigned int offset, int value)\n{\n\tstruct stmfx_pinctrl *pctl = gpiochip_get_data(gc);\n\tu32 reg = STMFX_REG_GPIO_DIR + get_reg(offset);\n\tu32 mask = get_mask(offset);\n\n\tstmfx_gpio_set(gc, offset, value);\n\n\treturn regmap_write_bits(pctl->stmfx->map, reg, mask, mask);\n}\n\nstatic int stmfx_pinconf_get_pupd(struct stmfx_pinctrl *pctl,\n\t\t\t\t  unsigned int offset)\n{\n\tu32 reg = STMFX_REG_GPIO_PUPD + get_reg(offset);\n\tu32 pupd, mask = get_mask(offset);\n\tint ret;\n\n\tret = regmap_read(pctl->stmfx->map, reg, &pupd);\n\tif (ret)\n\t\treturn ret;\n\n\treturn !!(pupd & mask);\n}\n\nstatic int stmfx_pinconf_set_pupd(struct stmfx_pinctrl *pctl,\n\t\t\t\t  unsigned int offset, u32 pupd)\n{\n\tu32 reg = STMFX_REG_GPIO_PUPD + get_reg(offset);\n\tu32 mask = get_mask(offset);\n\n\treturn regmap_write_bits(pctl->stmfx->map, reg, mask, pupd ? mask : 0);\n}\n\nstatic int stmfx_pinconf_get_type(struct stmfx_pinctrl *pctl,\n\t\t\t\t  unsigned int offset)\n{\n\tu32 reg = STMFX_REG_GPIO_TYPE + get_reg(offset);\n\tu32 type, mask = get_mask(offset);\n\tint ret;\n\n\tret = regmap_read(pctl->stmfx->map, reg, &type);\n\tif (ret)\n\t\treturn ret;\n\n\treturn !!(type & mask);\n}\n\nstatic int stmfx_pinconf_set_type(struct stmfx_pinctrl *pctl,\n\t\t\t\t  unsigned int offset, u32 type)\n{\n\tu32 reg = STMFX_REG_GPIO_TYPE + get_reg(offset);\n\tu32 mask = get_mask(offset);\n\n\treturn regmap_write_bits(pctl->stmfx->map, reg, mask, type ? mask : 0);\n}\n\nstatic int stmfx_pinconf_get(struct pinctrl_dev *pctldev,\n\t\t\t     unsigned int pin, unsigned long *config)\n{\n\tstruct stmfx_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tu32 param = pinconf_to_config_param(*config);\n\tstruct pinctrl_gpio_range *range;\n\tu32 arg = 0;\n\tint ret, dir, type, pupd;\n\n\trange = pinctrl_find_gpio_range_from_pin_nolock(pctldev, pin);\n\tif (!range)\n\t\treturn -EINVAL;\n\n\tdir = stmfx_gpio_get_direction(&pctl->gpio_chip, pin);\n\tif (dir < 0)\n\t\treturn dir;\n\n\t \n\tdir = (dir == GPIO_LINE_DIRECTION_IN) ? 1 : 0;\n\n\ttype = stmfx_pinconf_get_type(pctl, pin);\n\tif (type < 0)\n\t\treturn type;\n\tpupd = stmfx_pinconf_get_pupd(pctl, pin);\n\tif (pupd < 0)\n\t\treturn pupd;\n\n\tswitch (param) {\n\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\tif ((!dir && (!type || !pupd)) || (dir && !type))\n\t\t\targ = 1;\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\tif (dir && type && !pupd)\n\t\t\targ = 1;\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\tif (type && pupd)\n\t\t\targ = 1;\n\t\tbreak;\n\tcase PIN_CONFIG_DRIVE_OPEN_DRAIN:\n\t\tif ((!dir && type) || (dir && !type))\n\t\t\targ = 1;\n\t\tbreak;\n\tcase PIN_CONFIG_DRIVE_PUSH_PULL:\n\t\tif ((!dir && !type) || (dir && type))\n\t\t\targ = 1;\n\t\tbreak;\n\tcase PIN_CONFIG_OUTPUT:\n\t\tif (dir)\n\t\t\treturn -EINVAL;\n\n\t\tret = stmfx_gpio_get(&pctl->gpio_chip, pin);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\targ = ret;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\t*config = pinconf_to_config_packed(param, arg);\n\n\treturn 0;\n}\n\nstatic int stmfx_pinconf_set(struct pinctrl_dev *pctldev, unsigned int pin,\n\t\t\t     unsigned long *configs, unsigned int num_configs)\n{\n\tstruct stmfx_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct pinctrl_gpio_range *range;\n\tenum pin_config_param param;\n\tu32 arg;\n\tint i, ret;\n\n\trange = pinctrl_find_gpio_range_from_pin_nolock(pctldev, pin);\n\tif (!range) {\n\t\tdev_err(pctldev->dev, \"pin %d is not available\\n\", pin);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < num_configs; i++) {\n\t\tparam = pinconf_to_config_param(configs[i]);\n\t\targ = pinconf_to_config_argument(configs[i]);\n\n\t\tswitch (param) {\n\t\tcase PIN_CONFIG_BIAS_PULL_PIN_DEFAULT:\n\t\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\tcase PIN_CONFIG_DRIVE_PUSH_PULL:\n\t\t\tret = stmfx_pinconf_set_type(pctl, pin, 0);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\t\tret = stmfx_pinconf_set_type(pctl, pin, 1);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tret = stmfx_pinconf_set_pupd(pctl, pin, 0);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\t\tret = stmfx_pinconf_set_type(pctl, pin, 1);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tret = stmfx_pinconf_set_pupd(pctl, pin, 1);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_DRIVE_OPEN_DRAIN:\n\t\t\tret = stmfx_pinconf_set_type(pctl, pin, 1);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_OUTPUT:\n\t\t\tret = stmfx_gpio_direction_output(&pctl->gpio_chip,\n\t\t\t\t\t\t\t  pin, arg);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void stmfx_pinconf_dbg_show(struct pinctrl_dev *pctldev,\n\t\t\t\t   struct seq_file *s, unsigned int offset)\n{\n\tstruct stmfx_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct pinctrl_gpio_range *range;\n\tint dir, type, pupd, val;\n\n\trange = pinctrl_find_gpio_range_from_pin_nolock(pctldev, offset);\n\tif (!range)\n\t\treturn;\n\n\tdir = stmfx_gpio_get_direction(&pctl->gpio_chip, offset);\n\tif (dir < 0)\n\t\treturn;\n\ttype = stmfx_pinconf_get_type(pctl, offset);\n\tif (type < 0)\n\t\treturn;\n\tpupd = stmfx_pinconf_get_pupd(pctl, offset);\n\tif (pupd < 0)\n\t\treturn;\n\tval = stmfx_gpio_get(&pctl->gpio_chip, offset);\n\tif (val < 0)\n\t\treturn;\n\n\tif (dir == GPIO_LINE_DIRECTION_OUT) {\n\t\tseq_printf(s, \"output %s \", val ? \"high\" : \"low\");\n\t\tif (type)\n\t\t\tseq_printf(s, \"open drain %s internal pull-up \",\n\t\t\t\t   pupd ? \"with\" : \"without\");\n\t\telse\n\t\t\tseq_puts(s, \"push pull no pull \");\n\t} else {\n\t\tseq_printf(s, \"input %s \", val ? \"high\" : \"low\");\n\t\tif (type)\n\t\t\tseq_printf(s, \"with internal pull-%s \",\n\t\t\t\t   pupd ? \"up\" : \"down\");\n\t\telse\n\t\t\tseq_printf(s, \"%s \", pupd ? \"floating\" : \"analog\");\n\t}\n}\n\nstatic const struct pinconf_ops stmfx_pinconf_ops = {\n\t.pin_config_get\t\t= stmfx_pinconf_get,\n\t.pin_config_set\t\t= stmfx_pinconf_set,\n\t.pin_config_dbg_show\t= stmfx_pinconf_dbg_show,\n};\n\nstatic int stmfx_pinctrl_get_groups_count(struct pinctrl_dev *pctldev)\n{\n\treturn 0;\n}\n\nstatic const char *stmfx_pinctrl_get_group_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t\tunsigned int selector)\n{\n\treturn NULL;\n}\n\nstatic int stmfx_pinctrl_get_group_pins(struct pinctrl_dev *pctldev,\n\t\t\t\t\tunsigned int selector,\n\t\t\t\t\tconst unsigned int **pins,\n\t\t\t\t\tunsigned int *num_pins)\n{\n\treturn -ENOTSUPP;\n}\n\nstatic const struct pinctrl_ops stmfx_pinctrl_ops = {\n\t.get_groups_count = stmfx_pinctrl_get_groups_count,\n\t.get_group_name = stmfx_pinctrl_get_group_name,\n\t.get_group_pins = stmfx_pinctrl_get_group_pins,\n\t.dt_node_to_map = pinconf_generic_dt_node_to_map_pin,\n\t.dt_free_map = pinctrl_utils_free_map,\n};\n\nstatic void stmfx_pinctrl_irq_mask(struct irq_data *data)\n{\n\tstruct gpio_chip *gpio_chip = irq_data_get_irq_chip_data(data);\n\tstruct stmfx_pinctrl *pctl = gpiochip_get_data(gpio_chip);\n\tu32 reg = get_reg(data->hwirq);\n\tu32 mask = get_mask(data->hwirq);\n\n\tpctl->irq_gpi_src[reg] &= ~mask;\n\tgpiochip_disable_irq(gpio_chip, irqd_to_hwirq(data));\n}\n\nstatic void stmfx_pinctrl_irq_unmask(struct irq_data *data)\n{\n\tstruct gpio_chip *gpio_chip = irq_data_get_irq_chip_data(data);\n\tstruct stmfx_pinctrl *pctl = gpiochip_get_data(gpio_chip);\n\tu32 reg = get_reg(data->hwirq);\n\tu32 mask = get_mask(data->hwirq);\n\n\tgpiochip_enable_irq(gpio_chip, irqd_to_hwirq(data));\n\tpctl->irq_gpi_src[reg] |= mask;\n}\n\nstatic int stmfx_pinctrl_irq_set_type(struct irq_data *data, unsigned int type)\n{\n\tstruct gpio_chip *gpio_chip = irq_data_get_irq_chip_data(data);\n\tstruct stmfx_pinctrl *pctl = gpiochip_get_data(gpio_chip);\n\tu32 reg = get_reg(data->hwirq);\n\tu32 mask = get_mask(data->hwirq);\n\n\tif (type == IRQ_TYPE_NONE)\n\t\treturn -EINVAL;\n\n\tif (type & IRQ_TYPE_EDGE_BOTH) {\n\t\tpctl->irq_gpi_evt[reg] |= mask;\n\t\tirq_set_handler_locked(data, handle_edge_irq);\n\t} else {\n\t\tpctl->irq_gpi_evt[reg] &= ~mask;\n\t\tirq_set_handler_locked(data, handle_level_irq);\n\t}\n\n\tif ((type & IRQ_TYPE_EDGE_RISING) || (type & IRQ_TYPE_LEVEL_HIGH))\n\t\tpctl->irq_gpi_type[reg] |= mask;\n\telse\n\t\tpctl->irq_gpi_type[reg] &= ~mask;\n\n\t \n\n\tif ((type & IRQ_TYPE_EDGE_BOTH) == IRQ_TYPE_EDGE_BOTH)\n\t\tpctl->irq_toggle_edge[reg] |= mask;\n\telse\n\t\tpctl->irq_toggle_edge[reg] &= mask;\n\n\treturn 0;\n}\n\nstatic void stmfx_pinctrl_irq_bus_lock(struct irq_data *data)\n{\n\tstruct gpio_chip *gpio_chip = irq_data_get_irq_chip_data(data);\n\tstruct stmfx_pinctrl *pctl = gpiochip_get_data(gpio_chip);\n\n\tmutex_lock(&pctl->lock);\n}\n\nstatic void stmfx_pinctrl_irq_bus_sync_unlock(struct irq_data *data)\n{\n\tstruct gpio_chip *gpio_chip = irq_data_get_irq_chip_data(data);\n\tstruct stmfx_pinctrl *pctl = gpiochip_get_data(gpio_chip);\n\tu32 reg = get_reg(data->hwirq);\n\tu32 mask = get_mask(data->hwirq);\n\n\t \n\tif (pctl->irq_toggle_edge[reg] & mask) {\n\t\tif (stmfx_gpio_get(gpio_chip, data->hwirq))\n\t\t\tpctl->irq_gpi_type[reg] &= ~mask;\n\t\telse\n\t\t\tpctl->irq_gpi_type[reg] |= mask;\n\t}\n\n\tregmap_bulk_write(pctl->stmfx->map, STMFX_REG_IRQ_GPI_EVT,\n\t\t\t  pctl->irq_gpi_evt, NR_GPIO_REGS);\n\tregmap_bulk_write(pctl->stmfx->map, STMFX_REG_IRQ_GPI_TYPE,\n\t\t\t  pctl->irq_gpi_type, NR_GPIO_REGS);\n\tregmap_bulk_write(pctl->stmfx->map, STMFX_REG_IRQ_GPI_SRC,\n\t\t\t  pctl->irq_gpi_src, NR_GPIO_REGS);\n\n\tmutex_unlock(&pctl->lock);\n}\n\nstatic int stmfx_gpio_irq_request_resources(struct irq_data *data)\n{\n\tstruct gpio_chip *gpio_chip = irq_data_get_irq_chip_data(data);\n\tint ret;\n\n\tret = stmfx_gpio_direction_input(gpio_chip, data->hwirq);\n\tif (ret)\n\t\treturn ret;\n\n\treturn gpiochip_reqres_irq(gpio_chip, data->hwirq);\n}\n\nstatic void stmfx_gpio_irq_release_resources(struct irq_data *data)\n{\n\tstruct gpio_chip *gpio_chip = irq_data_get_irq_chip_data(data);\n\n\treturn gpiochip_relres_irq(gpio_chip, data->hwirq);\n}\n\nstatic void stmfx_pinctrl_irq_toggle_trigger(struct stmfx_pinctrl *pctl,\n\t\t\t\t\t     unsigned int offset)\n{\n\tu32 reg = get_reg(offset);\n\tu32 mask = get_mask(offset);\n\tint val;\n\n\tif (!(pctl->irq_toggle_edge[reg] & mask))\n\t\treturn;\n\n\tval = stmfx_gpio_get(&pctl->gpio_chip, offset);\n\tif (val < 0)\n\t\treturn;\n\n\tif (val) {\n\t\tpctl->irq_gpi_type[reg] &= mask;\n\t\tregmap_write_bits(pctl->stmfx->map,\n\t\t\t\t  STMFX_REG_IRQ_GPI_TYPE + reg,\n\t\t\t\t  mask, 0);\n\n\t} else {\n\t\tpctl->irq_gpi_type[reg] |= mask;\n\t\tregmap_write_bits(pctl->stmfx->map,\n\t\t\t\t  STMFX_REG_IRQ_GPI_TYPE + reg,\n\t\t\t\t  mask, mask);\n\t}\n}\n\nstatic irqreturn_t stmfx_pinctrl_irq_thread_fn(int irq, void *dev_id)\n{\n\tstruct stmfx_pinctrl *pctl = (struct stmfx_pinctrl *)dev_id;\n\tstruct gpio_chip *gc = &pctl->gpio_chip;\n\tu8 pending[NR_GPIO_REGS];\n\tu8 src[NR_GPIO_REGS] = {0, 0, 0};\n\tunsigned long n, status;\n\tint i, ret;\n\n\tret = regmap_bulk_read(pctl->stmfx->map, STMFX_REG_IRQ_GPI_PENDING,\n\t\t\t       &pending, NR_GPIO_REGS);\n\tif (ret)\n\t\treturn IRQ_NONE;\n\n\tregmap_bulk_write(pctl->stmfx->map, STMFX_REG_IRQ_GPI_SRC,\n\t\t\t  src, NR_GPIO_REGS);\n\n\tBUILD_BUG_ON(NR_GPIO_REGS > sizeof(status));\n\tfor (i = 0, status = 0; i < NR_GPIO_REGS; i++)\n\t\tstatus |= (unsigned long)pending[i] << (i * 8);\n\tfor_each_set_bit(n, &status, gc->ngpio) {\n\t\thandle_nested_irq(irq_find_mapping(gc->irq.domain, n));\n\t\tstmfx_pinctrl_irq_toggle_trigger(pctl, n);\n\t}\n\n\tregmap_bulk_write(pctl->stmfx->map, STMFX_REG_IRQ_GPI_SRC,\n\t\t\t  pctl->irq_gpi_src, NR_GPIO_REGS);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void stmfx_pinctrl_irq_print_chip(struct irq_data *d, struct seq_file *p)\n{\n\tstruct gpio_chip *gpio_chip = irq_data_get_irq_chip_data(d);\n\tstruct stmfx_pinctrl *pctl = gpiochip_get_data(gpio_chip);\n\n\tseq_printf(p, dev_name(pctl->dev));\n}\n\nstatic const struct irq_chip stmfx_pinctrl_irq_chip = {\n\t.irq_mask = stmfx_pinctrl_irq_mask,\n\t.irq_unmask = stmfx_pinctrl_irq_unmask,\n\t.irq_set_type = stmfx_pinctrl_irq_set_type,\n\t.irq_bus_lock = stmfx_pinctrl_irq_bus_lock,\n\t.irq_bus_sync_unlock = stmfx_pinctrl_irq_bus_sync_unlock,\n\t.irq_request_resources = stmfx_gpio_irq_request_resources,\n\t.irq_release_resources = stmfx_gpio_irq_release_resources,\n\t.irq_print_chip = stmfx_pinctrl_irq_print_chip,\n\t.flags = IRQCHIP_IMMUTABLE,\n};\n\nstatic int stmfx_pinctrl_gpio_function_enable(struct stmfx_pinctrl *pctl)\n{\n\tstruct pinctrl_gpio_range *gpio_range;\n\tstruct pinctrl_dev *pctl_dev = pctl->pctl_dev;\n\tu32 func = STMFX_FUNC_GPIO;\n\n\tpctl->gpio_valid_mask = GENMASK(15, 0);\n\n\tgpio_range = pinctrl_find_gpio_range_from_pin(pctl_dev, 16);\n\tif (gpio_range) {\n\t\tfunc |= STMFX_FUNC_ALTGPIO_LOW;\n\t\tpctl->gpio_valid_mask |= GENMASK(19, 16);\n\t}\n\n\tgpio_range = pinctrl_find_gpio_range_from_pin(pctl_dev, 20);\n\tif (gpio_range) {\n\t\tfunc |= STMFX_FUNC_ALTGPIO_HIGH;\n\t\tpctl->gpio_valid_mask |= GENMASK(23, 20);\n\t}\n\n\treturn stmfx_function_enable(pctl->stmfx, func);\n}\n\nstatic int stmfx_pinctrl_probe(struct platform_device *pdev)\n{\n\tstruct stmfx *stmfx = dev_get_drvdata(pdev->dev.parent);\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct stmfx_pinctrl *pctl;\n\tstruct gpio_irq_chip *girq;\n\tint irq, ret;\n\n\tpctl = devm_kzalloc(stmfx->dev, sizeof(*pctl), GFP_KERNEL);\n\tif (!pctl)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, pctl);\n\n\tpctl->dev = &pdev->dev;\n\tpctl->stmfx = stmfx;\n\n\tif (!of_property_present(np, \"gpio-ranges\")) {\n\t\tdev_err(pctl->dev, \"missing required gpio-ranges property\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tmutex_init(&pctl->lock);\n\n\t \n\tpctl->pctl_desc.name = \"stmfx-pinctrl\";\n\tpctl->pctl_desc.pctlops = &stmfx_pinctrl_ops;\n\tpctl->pctl_desc.confops = &stmfx_pinconf_ops;\n\tpctl->pctl_desc.pins = stmfx_pins;\n\tpctl->pctl_desc.npins = ARRAY_SIZE(stmfx_pins);\n\tpctl->pctl_desc.owner = THIS_MODULE;\n\tpctl->pctl_desc.link_consumers = true;\n\n\tret = devm_pinctrl_register_and_init(pctl->dev, &pctl->pctl_desc,\n\t\t\t\t\t     pctl, &pctl->pctl_dev);\n\tif (ret) {\n\t\tdev_err(pctl->dev, \"pinctrl registration failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = pinctrl_enable(pctl->pctl_dev);\n\tif (ret) {\n\t\tdev_err(pctl->dev, \"pinctrl enable failed\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tpctl->gpio_chip.label = \"stmfx-gpio\";\n\tpctl->gpio_chip.parent = pctl->dev;\n\tpctl->gpio_chip.get_direction = stmfx_gpio_get_direction;\n\tpctl->gpio_chip.direction_input = stmfx_gpio_direction_input;\n\tpctl->gpio_chip.direction_output = stmfx_gpio_direction_output;\n\tpctl->gpio_chip.get = stmfx_gpio_get;\n\tpctl->gpio_chip.set = stmfx_gpio_set;\n\tpctl->gpio_chip.set_config = gpiochip_generic_config;\n\tpctl->gpio_chip.base = -1;\n\tpctl->gpio_chip.ngpio = pctl->pctl_desc.npins;\n\tpctl->gpio_chip.can_sleep = true;\n\n\tgirq = &pctl->gpio_chip.irq;\n\tgpio_irq_chip_set_chip(girq, &stmfx_pinctrl_irq_chip);\n\t \n\tgirq->parent_handler = NULL;\n\tgirq->num_parents = 0;\n\tgirq->parents = NULL;\n\tgirq->default_type = IRQ_TYPE_NONE;\n\tgirq->handler = handle_bad_irq;\n\tgirq->threaded = true;\n\n\tret = devm_gpiochip_add_data(pctl->dev, &pctl->gpio_chip, pctl);\n\tif (ret) {\n\t\tdev_err(pctl->dev, \"gpio_chip registration failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = stmfx_pinctrl_gpio_function_enable(pctl);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_request_threaded_irq(pctl->dev, irq, NULL,\n\t\t\t\t\tstmfx_pinctrl_irq_thread_fn,\n\t\t\t\t\tIRQF_ONESHOT,\n\t\t\t\t\tdev_name(pctl->dev), pctl);\n\tif (ret) {\n\t\tdev_err(pctl->dev, \"cannot request irq%d\\n\", irq);\n\t\treturn ret;\n\t}\n\n\tdev_info(pctl->dev,\n\t\t \"%ld GPIOs available\\n\", hweight_long(pctl->gpio_valid_mask));\n\n\treturn 0;\n}\n\nstatic int stmfx_pinctrl_remove(struct platform_device *pdev)\n{\n\tstruct stmfx *stmfx = dev_get_drvdata(pdev->dev.parent);\n\n\treturn stmfx_function_disable(stmfx,\n\t\t\t\t      STMFX_FUNC_GPIO |\n\t\t\t\t      STMFX_FUNC_ALTGPIO_LOW |\n\t\t\t\t      STMFX_FUNC_ALTGPIO_HIGH);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int stmfx_pinctrl_backup_regs(struct stmfx_pinctrl *pctl)\n{\n\tint ret;\n\n\tret = regmap_bulk_read(pctl->stmfx->map, STMFX_REG_GPIO_STATE,\n\t\t\t       &pctl->bkp_gpio_state, NR_GPIO_REGS);\n\tif (ret)\n\t\treturn ret;\n\tret = regmap_bulk_read(pctl->stmfx->map, STMFX_REG_GPIO_DIR,\n\t\t\t       &pctl->bkp_gpio_dir, NR_GPIO_REGS);\n\tif (ret)\n\t\treturn ret;\n\tret = regmap_bulk_read(pctl->stmfx->map, STMFX_REG_GPIO_TYPE,\n\t\t\t       &pctl->bkp_gpio_type, NR_GPIO_REGS);\n\tif (ret)\n\t\treturn ret;\n\tret = regmap_bulk_read(pctl->stmfx->map, STMFX_REG_GPIO_PUPD,\n\t\t\t       &pctl->bkp_gpio_pupd, NR_GPIO_REGS);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int stmfx_pinctrl_restore_regs(struct stmfx_pinctrl *pctl)\n{\n\tint ret;\n\n\tret = regmap_bulk_write(pctl->stmfx->map, STMFX_REG_GPIO_DIR,\n\t\t\t\tpctl->bkp_gpio_dir, NR_GPIO_REGS);\n\tif (ret)\n\t\treturn ret;\n\tret = regmap_bulk_write(pctl->stmfx->map, STMFX_REG_GPIO_TYPE,\n\t\t\t\tpctl->bkp_gpio_type, NR_GPIO_REGS);\n\tif (ret)\n\t\treturn ret;\n\tret = regmap_bulk_write(pctl->stmfx->map, STMFX_REG_GPIO_PUPD,\n\t\t\t\tpctl->bkp_gpio_pupd, NR_GPIO_REGS);\n\tif (ret)\n\t\treturn ret;\n\tret = regmap_bulk_write(pctl->stmfx->map, STMFX_REG_GPO_SET,\n\t\t\t\tpctl->bkp_gpio_state, NR_GPIO_REGS);\n\tif (ret)\n\t\treturn ret;\n\tret = regmap_bulk_write(pctl->stmfx->map, STMFX_REG_IRQ_GPI_EVT,\n\t\t\t\tpctl->irq_gpi_evt, NR_GPIO_REGS);\n\tif (ret)\n\t\treturn ret;\n\tret = regmap_bulk_write(pctl->stmfx->map, STMFX_REG_IRQ_GPI_TYPE,\n\t\t\t\tpctl->irq_gpi_type, NR_GPIO_REGS);\n\tif (ret)\n\t\treturn ret;\n\tret = regmap_bulk_write(pctl->stmfx->map, STMFX_REG_IRQ_GPI_SRC,\n\t\t\t\tpctl->irq_gpi_src, NR_GPIO_REGS);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int stmfx_pinctrl_suspend(struct device *dev)\n{\n\tstruct stmfx_pinctrl *pctl = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = stmfx_pinctrl_backup_regs(pctl);\n\tif (ret) {\n\t\tdev_err(pctl->dev, \"registers backup failure\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int stmfx_pinctrl_resume(struct device *dev)\n{\n\tstruct stmfx_pinctrl *pctl = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = stmfx_pinctrl_restore_regs(pctl);\n\tif (ret) {\n\t\tdev_err(pctl->dev, \"registers restoration failure\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(stmfx_pinctrl_dev_pm_ops,\n\t\t\t stmfx_pinctrl_suspend, stmfx_pinctrl_resume);\n\nstatic const struct of_device_id stmfx_pinctrl_of_match[] = {\n\t{ .compatible = \"st,stmfx-0300-pinctrl\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, stmfx_pinctrl_of_match);\n\nstatic struct platform_driver stmfx_pinctrl_driver = {\n\t.driver = {\n\t\t.name = \"stmfx-pinctrl\",\n\t\t.of_match_table = stmfx_pinctrl_of_match,\n\t\t.pm = &stmfx_pinctrl_dev_pm_ops,\n\t},\n\t.probe = stmfx_pinctrl_probe,\n\t.remove = stmfx_pinctrl_remove,\n};\nmodule_platform_driver(stmfx_pinctrl_driver);\n\nMODULE_DESCRIPTION(\"STMFX pinctrl/GPIO driver\");\nMODULE_AUTHOR(\"Amelie Delaunay <amelie.delaunay@st.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}