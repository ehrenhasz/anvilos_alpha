{
  "module_name": "pinctrl-s32cc.c",
  "hash_id": "713a7b6ecaaa90c08a44f4133c8596e9a6b0183037e8d797b2805768d9c321ee",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/nxp/pinctrl-s32cc.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/err.h>\n#include <linux/gpio/driver.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pinctrl/machine.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinmux.h>\n#include <linux/regmap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n\n#include \"../core.h\"\n#include \"../pinconf.h\"\n#include \"../pinctrl-utils.h\"\n#include \"pinctrl-s32.h\"\n\n#define S32_PIN_ID_SHIFT\t4\n#define S32_PIN_ID_MASK\t\tGENMASK(31, S32_PIN_ID_SHIFT)\n\n#define S32_MSCR_SSS_MASK\tGENMASK(2, 0)\n#define S32_MSCR_PUS\t\tBIT(12)\n#define S32_MSCR_PUE\t\tBIT(13)\n#define S32_MSCR_SRE(X)\t\t(((X) & GENMASK(3, 0)) << 14)\n#define S32_MSCR_IBE\t\tBIT(19)\n#define S32_MSCR_ODE\t\tBIT(20)\n#define S32_MSCR_OBE\t\tBIT(21)\n\nstatic struct regmap_config s32_regmap_config = {\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n};\n\nstatic u32 get_pin_no(u32 pinmux)\n{\n\treturn (pinmux & S32_PIN_ID_MASK) >> S32_PIN_ID_SHIFT;\n}\n\nstatic u32 get_pin_func(u32 pinmux)\n{\n\treturn pinmux & GENMASK(3, 0);\n}\n\nstruct s32_pinctrl_mem_region {\n\tstruct regmap *map;\n\tconst struct s32_pin_range *pin_range;\n\tchar name[8];\n};\n\n \nstruct gpio_pin_config {\n\tunsigned int pin_id;\n\tunsigned int config;\n\tstruct list_head list;\n};\n\n \nstruct s32_pinctrl_context {\n\tunsigned int *pads;\n};\n\n \nstruct s32_pinctrl {\n\tstruct device *dev;\n\tstruct pinctrl_dev *pctl;\n\tstruct s32_pinctrl_mem_region *regions;\n\tstruct s32_pinctrl_soc_info *info;\n\tstruct list_head gpio_configs;\n\tspinlock_t gpio_configs_lock;\n#ifdef CONFIG_PM_SLEEP\n\tstruct s32_pinctrl_context saved_context;\n#endif\n};\n\nstatic struct s32_pinctrl_mem_region *\ns32_get_region(struct pinctrl_dev *pctldev, unsigned int pin)\n{\n\tstruct s32_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct s32_pin_range *pin_range;\n\tunsigned int mem_regions = ipctl->info->soc_data->mem_regions;\n\tunsigned int i;\n\n\tfor (i = 0; i < mem_regions; i++) {\n\t\tpin_range = ipctl->regions[i].pin_range;\n\t\tif (pin >= pin_range->start && pin <= pin_range->end)\n\t\t\treturn &ipctl->regions[i];\n\t}\n\n\treturn NULL;\n}\n\nstatic inline int s32_check_pin(struct pinctrl_dev *pctldev,\n\t\t\t\tunsigned int pin)\n{\n\treturn s32_get_region(pctldev, pin) ? 0 : -EINVAL;\n}\n\nstatic inline int s32_regmap_read(struct pinctrl_dev *pctldev,\n\t\t\t   unsigned int pin, unsigned int *val)\n{\n\tstruct s32_pinctrl_mem_region *region;\n\tunsigned int offset;\n\n\tregion = s32_get_region(pctldev, pin);\n\tif (!region)\n\t\treturn -EINVAL;\n\n\toffset = (pin - region->pin_range->start) *\n\t\t\tregmap_get_reg_stride(region->map);\n\n\treturn regmap_read(region->map, offset, val);\n}\n\nstatic inline int s32_regmap_write(struct pinctrl_dev *pctldev,\n\t\t\t    unsigned int pin,\n\t\t\t    unsigned int val)\n{\n\tstruct s32_pinctrl_mem_region *region;\n\tunsigned int offset;\n\n\tregion = s32_get_region(pctldev, pin);\n\tif (!region)\n\t\treturn -EINVAL;\n\n\toffset = (pin - region->pin_range->start) *\n\t\t\tregmap_get_reg_stride(region->map);\n\n\treturn regmap_write(region->map, offset, val);\n\n}\n\nstatic inline int s32_regmap_update(struct pinctrl_dev *pctldev, unsigned int pin,\n\t\t\t     unsigned int mask, unsigned int val)\n{\n\tstruct s32_pinctrl_mem_region *region;\n\tunsigned int offset;\n\n\tregion = s32_get_region(pctldev, pin);\n\tif (!region)\n\t\treturn -EINVAL;\n\n\toffset = (pin - region->pin_range->start) *\n\t\t\tregmap_get_reg_stride(region->map);\n\n\treturn regmap_update_bits(region->map, offset, mask, val);\n}\n\nstatic int s32_get_groups_count(struct pinctrl_dev *pctldev)\n{\n\tstruct s32_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct s32_pinctrl_soc_info *info = ipctl->info;\n\n\treturn info->ngroups;\n}\n\nstatic const char *s32_get_group_name(struct pinctrl_dev *pctldev,\n\t\t\t\t      unsigned int selector)\n{\n\tstruct s32_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct s32_pinctrl_soc_info *info = ipctl->info;\n\n\treturn info->groups[selector].data.name;\n}\n\nstatic int s32_get_group_pins(struct pinctrl_dev *pctldev,\n\t\t\t      unsigned int selector, const unsigned int **pins,\n\t\t\t      unsigned int *npins)\n{\n\tstruct s32_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct s32_pinctrl_soc_info *info = ipctl->info;\n\n\t*pins = info->groups[selector].data.pins;\n\t*npins = info->groups[selector].data.npins;\n\n\treturn 0;\n}\n\nstatic void s32_pin_dbg_show(struct pinctrl_dev *pctldev, struct seq_file *s,\n\t\t\t     unsigned int offset)\n{\n\tseq_printf(s, \"%s\", dev_name(pctldev->dev));\n}\n\nstatic int s32_dt_group_node_to_map(struct pinctrl_dev *pctldev,\n\t\t\t\t    struct device_node *np,\n\t\t\t\t    struct pinctrl_map **map,\n\t\t\t\t    unsigned int *reserved_maps,\n\t\t\t\t    unsigned int *num_maps,\n\t\t\t\t    const char *func_name)\n{\n\tstruct s32_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct device *dev = ipctl->dev;\n\tunsigned long *cfgs = NULL;\n\tunsigned int n_cfgs, reserve = 1;\n\tint n_pins, ret;\n\n\tn_pins = of_property_count_elems_of_size(np, \"pinmux\", sizeof(u32));\n\tif (n_pins < 0) {\n\t\tdev_warn(dev, \"Can't find 'pinmux' property in node %pOFn\\n\", np);\n\t} else if (!n_pins) {\n\t\treturn -EINVAL;\n\t}\n\n\tret = pinconf_generic_parse_dt_config(np, pctldev, &cfgs, &n_cfgs);\n\tif (ret) {\n\t\tdev_err(dev, \"%pOF: could not parse node property\\n\", np);\n\t\treturn ret;\n\t}\n\n\tif (n_cfgs)\n\t\treserve++;\n\n\tret = pinctrl_utils_reserve_map(pctldev, map, reserved_maps, num_maps,\n\t\t\t\t\treserve);\n\tif (ret < 0)\n\t\tgoto free_cfgs;\n\n\tret = pinctrl_utils_add_map_mux(pctldev, map, reserved_maps, num_maps,\n\t\t\t\t\tnp->name, func_name);\n\tif (ret < 0)\n\t\tgoto free_cfgs;\n\n\tif (n_cfgs) {\n\t\tret = pinctrl_utils_add_map_configs(pctldev, map, reserved_maps,\n\t\t\t\t\t\t    num_maps, np->name, cfgs, n_cfgs,\n\t\t\t\t\t\t    PIN_MAP_TYPE_CONFIGS_GROUP);\n\t\tif (ret < 0)\n\t\t\tgoto free_cfgs;\n\t}\n\nfree_cfgs:\n\tkfree(cfgs);\n\treturn ret;\n}\n\nstatic int s32_dt_node_to_map(struct pinctrl_dev *pctldev,\n\t\t\t      struct device_node *np_config,\n\t\t\t      struct pinctrl_map **map,\n\t\t\t      unsigned int *num_maps)\n{\n\tunsigned int reserved_maps;\n\tstruct device_node *np;\n\tint ret = 0;\n\n\treserved_maps = 0;\n\t*map = NULL;\n\t*num_maps = 0;\n\n\tfor_each_available_child_of_node(np_config, np) {\n\t\tret = s32_dt_group_node_to_map(pctldev, np, map,\n\t\t\t\t\t       &reserved_maps, num_maps,\n\t\t\t\t\t       np_config->name);\n\t\tif (ret < 0) {\n\t\t\tof_node_put(np);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret)\n\t\tpinctrl_utils_free_map(pctldev, *map, *num_maps);\n\n\treturn ret;\n\n}\n\nstatic const struct pinctrl_ops s32_pctrl_ops = {\n\t.get_groups_count = s32_get_groups_count,\n\t.get_group_name = s32_get_group_name,\n\t.get_group_pins = s32_get_group_pins,\n\t.pin_dbg_show = s32_pin_dbg_show,\n\t.dt_node_to_map = s32_dt_node_to_map,\n\t.dt_free_map = pinctrl_utils_free_map,\n};\n\nstatic int s32_pmx_set(struct pinctrl_dev *pctldev, unsigned int selector,\n\t\t       unsigned int group)\n{\n\tstruct s32_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct s32_pinctrl_soc_info *info = ipctl->info;\n\tint i, ret;\n\tstruct s32_pin_group *grp;\n\n\t \n\tgrp = &info->groups[group];\n\n\tdev_dbg(ipctl->dev, \"set mux for function %s group %s\\n\",\n\t\tinfo->functions[selector].name, grp->data.name);\n\n\t \n\tfor (i = 0; i < grp->data.npins; i++) {\n\t\tif (s32_check_pin(pctldev, grp->data.pins[i]) != 0) {\n\t\t\tdev_err(info->dev, \"invalid pin: %u in group: %u\\n\",\n\t\t\t\tgrp->data.pins[i], group);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tfor (i = 0, ret = 0; i < grp->data.npins && !ret; i++) {\n\t\tret = s32_regmap_update(pctldev, grp->data.pins[i],\n\t\t\t\t\tS32_MSCR_SSS_MASK, grp->pin_sss[i]);\n\t\tif (ret) {\n\t\t\tdev_err(info->dev, \"Failed to set pin %u\\n\",\n\t\t\t\tgrp->data.pins[i]);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int s32_pmx_get_funcs_count(struct pinctrl_dev *pctldev)\n{\n\tstruct s32_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct s32_pinctrl_soc_info *info = ipctl->info;\n\n\treturn info->nfunctions;\n}\n\nstatic const char *s32_pmx_get_func_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t unsigned int selector)\n{\n\tstruct s32_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct s32_pinctrl_soc_info *info = ipctl->info;\n\n\treturn info->functions[selector].name;\n}\n\nstatic int s32_pmx_get_groups(struct pinctrl_dev *pctldev,\n\t\t\t      unsigned int selector,\n\t\t\t      const char * const **groups,\n\t\t\t      unsigned int * const num_groups)\n{\n\tstruct s32_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct s32_pinctrl_soc_info *info = ipctl->info;\n\n\t*groups = info->functions[selector].groups;\n\t*num_groups = info->functions[selector].ngroups;\n\n\treturn 0;\n}\n\nstatic int s32_pmx_gpio_request_enable(struct pinctrl_dev *pctldev,\n\t\t\t\t       struct pinctrl_gpio_range *range,\n\t\t\t\t       unsigned int offset)\n{\n\tstruct s32_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct gpio_pin_config *gpio_pin;\n\tunsigned int config;\n\tunsigned long flags;\n\tint ret;\n\n\tret = s32_regmap_read(pctldev, offset, &config);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tgpio_pin = kmalloc(sizeof(*gpio_pin), GFP_KERNEL);\n\tif (!gpio_pin)\n\t\treturn -ENOMEM;\n\n\tgpio_pin->pin_id = offset;\n\tgpio_pin->config = config;\n\n\tspin_lock_irqsave(&ipctl->gpio_configs_lock, flags);\n\tlist_add(&gpio_pin->list, &ipctl->gpio_configs);\n\tspin_unlock_irqrestore(&ipctl->gpio_configs_lock, flags);\n\n\t \n\tconfig &= ~S32_MSCR_SSS_MASK;\n\n\treturn s32_regmap_write(pctldev, offset, config);\n}\n\nstatic void s32_pmx_gpio_disable_free(struct pinctrl_dev *pctldev,\n\t\t\t\t      struct pinctrl_gpio_range *range,\n\t\t\t\t      unsigned int offset)\n{\n\tstruct s32_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct gpio_pin_config *gpio_pin, *tmp;\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&ipctl->gpio_configs_lock, flags);\n\n\tlist_for_each_entry_safe(gpio_pin, tmp, &ipctl->gpio_configs, list) {\n\t\tif (gpio_pin->pin_id == offset) {\n\t\t\tret = s32_regmap_write(pctldev, gpio_pin->pin_id,\n\t\t\t\t\t\t gpio_pin->config);\n\t\t\tif (ret != 0)\n\t\t\t\tgoto unlock;\n\n\t\t\tlist_del(&gpio_pin->list);\n\t\t\tkfree(gpio_pin);\n\t\t\tbreak;\n\t\t}\n\t}\n\nunlock:\n\tspin_unlock_irqrestore(&ipctl->gpio_configs_lock, flags);\n}\n\nstatic int s32_pmx_gpio_set_direction(struct pinctrl_dev *pctldev,\n\t\t\t\t      struct pinctrl_gpio_range *range,\n\t\t\t\t      unsigned int offset,\n\t\t\t\t      bool input)\n{\n\tunsigned int config;\n\tunsigned int mask = S32_MSCR_IBE | S32_MSCR_OBE;\n\n\tif (input) {\n\t\t \n\t\tconfig = S32_MSCR_IBE;\n\t} else {\n\t\t \n\t\tconfig = S32_MSCR_OBE;\n\t}\n\n\treturn s32_regmap_update(pctldev, offset, mask, config);\n}\n\nstatic const struct pinmux_ops s32_pmx_ops = {\n\t.get_functions_count = s32_pmx_get_funcs_count,\n\t.get_function_name = s32_pmx_get_func_name,\n\t.get_function_groups = s32_pmx_get_groups,\n\t.set_mux = s32_pmx_set,\n\t.gpio_request_enable = s32_pmx_gpio_request_enable,\n\t.gpio_disable_free = s32_pmx_gpio_disable_free,\n\t.gpio_set_direction = s32_pmx_gpio_set_direction,\n};\n\n \nstatic const int support_slew[] = {208, -1, -1, -1, 166, 150, 133, 83};\n\nstatic int s32_get_slew_regval(int arg)\n{\n\tunsigned int i;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(support_slew); i++) {\n\t\tif (arg == support_slew[i])\n\t\t\treturn i;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic inline void s32_pin_set_pull(enum pin_config_param param,\n\t\t\t\t   unsigned int *mask, unsigned int *config)\n{\n\tswitch (param) {\n\tcase PIN_CONFIG_BIAS_DISABLE:\n\tcase PIN_CONFIG_BIAS_HIGH_IMPEDANCE:\n\t\t*config &= ~(S32_MSCR_PUS | S32_MSCR_PUE);\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\t*config |= S32_MSCR_PUS | S32_MSCR_PUE;\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\t*config &= ~S32_MSCR_PUS;\n\t\t*config |= S32_MSCR_PUE;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\t*mask |= S32_MSCR_PUS | S32_MSCR_PUE;\n}\n\nstatic int s32_parse_pincfg(unsigned long pincfg, unsigned int *mask,\n\t\t\t    unsigned int *config)\n{\n\tenum pin_config_param param;\n\tu32 arg;\n\tint ret;\n\n\tparam = pinconf_to_config_param(pincfg);\n\targ = pinconf_to_config_argument(pincfg);\n\n\tswitch (param) {\n\t \n\tcase PIN_CONFIG_PERSIST_STATE:\n\t\treturn 0;\n\tcase PIN_CONFIG_DRIVE_OPEN_DRAIN:\n\t\t*config |= S32_MSCR_ODE;\n\t\t*mask |= S32_MSCR_ODE;\n\t\tbreak;\n\tcase PIN_CONFIG_OUTPUT_ENABLE:\n\t\tif (arg)\n\t\t\t*config |= S32_MSCR_OBE;\n\t\telse\n\t\t\t*config &= ~S32_MSCR_OBE;\n\t\t*mask |= S32_MSCR_OBE;\n\t\tbreak;\n\tcase PIN_CONFIG_INPUT_ENABLE:\n\t\tif (arg)\n\t\t\t*config |= S32_MSCR_IBE;\n\t\telse\n\t\t\t*config &= ~S32_MSCR_IBE;\n\t\t*mask |= S32_MSCR_IBE;\n\t\tbreak;\n\tcase PIN_CONFIG_SLEW_RATE:\n\t\tret = s32_get_slew_regval(arg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*config |= S32_MSCR_SRE((u32)ret);\n\t\t*mask |= S32_MSCR_SRE(~0);\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_DISABLE:\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\ts32_pin_set_pull(param, mask, config);\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_HIGH_IMPEDANCE:\n\t\t*config &= ~(S32_MSCR_ODE | S32_MSCR_OBE | S32_MSCR_IBE);\n\t\t*mask |= S32_MSCR_ODE | S32_MSCR_OBE | S32_MSCR_IBE;\n\t\ts32_pin_set_pull(param, mask, config);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int s32_pinconf_mscr_update(struct pinctrl_dev *pctldev,\n\t\t\t\t   unsigned int pin_id,\n\t\t\t\t   unsigned long *configs,\n\t\t\t\t   unsigned int num_configs)\n{\n\tstruct s32_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\n\tunsigned int config = 0, mask = 0;\n\tint i, ret;\n\n\tret = s32_check_pin(pctldev, pin_id);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_dbg(ipctl->dev, \"pinconf set pin %s with %u configs\\n\",\n\t\tpin_get_name(pctldev, pin_id), num_configs);\n\n\tfor (i = 0; i < num_configs; i++) {\n\t\tret = s32_parse_pincfg(configs[i], &mask, &config);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (!config && !mask)\n\t\treturn 0;\n\n\tdev_dbg(ipctl->dev, \"update: pin %u cfg 0x%x\\n\", pin_id, config);\n\n\treturn s32_regmap_update(pctldev, pin_id, mask, config);\n}\n\nstatic int s32_pinconf_get(struct pinctrl_dev *pctldev,\n\t\t\t   unsigned int pin_id,\n\t\t\t   unsigned long *config)\n{\n\treturn s32_regmap_read(pctldev, pin_id, (unsigned int *)config);\n}\n\nstatic int s32_pinconf_set(struct pinctrl_dev *pctldev,\n\t\t\t   unsigned int pin_id, unsigned long *configs,\n\t\t\t   unsigned int num_configs)\n{\n\treturn s32_pinconf_mscr_update(pctldev, pin_id, configs,\n\t\t\t\t       num_configs);\n}\n\nstatic int s32_pconf_group_set(struct pinctrl_dev *pctldev, unsigned int selector,\n\t\t\t       unsigned long *configs, unsigned int num_configs)\n{\n\tstruct s32_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct s32_pinctrl_soc_info *info = ipctl->info;\n\tstruct s32_pin_group *grp;\n\tint i, ret;\n\n\tgrp = &info->groups[selector];\n\tfor (i = 0; i < grp->data.npins; i++) {\n\t\tret = s32_pinconf_mscr_update(pctldev, grp->data.pins[i],\n\t\t\t\t\t      configs, num_configs);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void s32_pinconf_dbg_show(struct pinctrl_dev *pctldev,\n\t\t\t\t struct seq_file *s, unsigned int pin_id)\n{\n\tunsigned int config;\n\tint ret;\n\n\tret = s32_regmap_read(pctldev, pin_id, &config);\n\tif (ret)\n\t\treturn;\n\n\tseq_printf(s, \"0x%x\", config);\n}\n\nstatic void s32_pinconf_group_dbg_show(struct pinctrl_dev *pctldev,\n\t\t\t\t       struct seq_file *s, unsigned int selector)\n{\n\tstruct s32_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct s32_pinctrl_soc_info *info = ipctl->info;\n\tstruct s32_pin_group *grp;\n\tunsigned int config;\n\tconst char *name;\n\tint i, ret;\n\n\tseq_puts(s, \"\\n\");\n\tgrp = &info->groups[selector];\n\tfor (i = 0; i < grp->data.npins; i++) {\n\t\tname = pin_get_name(pctldev, grp->data.pins[i]);\n\t\tret = s32_regmap_read(pctldev, grp->data.pins[i], &config);\n\t\tif (ret)\n\t\t\treturn;\n\t\tseq_printf(s, \"%s: 0x%x\\n\", name, config);\n\t}\n}\n\nstatic const struct pinconf_ops s32_pinconf_ops = {\n\t.pin_config_get = s32_pinconf_get,\n\t.pin_config_set\t= s32_pinconf_set,\n\t.pin_config_group_set = s32_pconf_group_set,\n\t.pin_config_dbg_show = s32_pinconf_dbg_show,\n\t.pin_config_group_dbg_show = s32_pinconf_group_dbg_show,\n};\n\n#ifdef CONFIG_PM_SLEEP\nstatic bool s32_pinctrl_should_save(struct s32_pinctrl *ipctl,\n\t\t\t\t    unsigned int pin)\n{\n\tconst struct pin_desc *pd = pin_desc_get(ipctl->pctl, pin);\n\n\tif (!pd)\n\t\treturn false;\n\n\t \n\tif (pd->mux_owner || pd->gpio_owner)\n\t\treturn true;\n\n\treturn false;\n}\n\nint s32_pinctrl_suspend(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct s32_pinctrl *ipctl = platform_get_drvdata(pdev);\n\tconst struct pinctrl_pin_desc *pin;\n\tconst struct s32_pinctrl_soc_info *info = ipctl->info;\n\tstruct s32_pinctrl_context *saved_context = &ipctl->saved_context;\n\tint i;\n\tint ret;\n\tunsigned int config;\n\n\tfor (i = 0; i < info->soc_data->npins; i++) {\n\t\tpin = &info->soc_data->pins[i];\n\n\t\tif (!s32_pinctrl_should_save(ipctl, pin->number))\n\t\t\tcontinue;\n\n\t\tret = s32_regmap_read(ipctl->pctl, pin->number, &config);\n\t\tif (ret)\n\t\t\treturn -EINVAL;\n\n\t\tsaved_context->pads[i] = config;\n\t}\n\n\treturn 0;\n}\n\nint s32_pinctrl_resume(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct s32_pinctrl *ipctl = platform_get_drvdata(pdev);\n\tconst struct s32_pinctrl_soc_info *info = ipctl->info;\n\tconst struct pinctrl_pin_desc *pin;\n\tstruct s32_pinctrl_context *saved_context = &ipctl->saved_context;\n\tint ret, i;\n\n\tfor (i = 0; i < info->soc_data->npins; i++) {\n\t\tpin = &info->soc_data->pins[i];\n\n\t\tif (!s32_pinctrl_should_save(ipctl, pin->number))\n\t\t\tcontinue;\n\n\t\tret = s32_regmap_write(ipctl->pctl, pin->number,\n\t\t\t\t\t saved_context->pads[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic int s32_pinctrl_parse_groups(struct device_node *np,\n\t\t\t\t     struct s32_pin_group *grp,\n\t\t\t\t     struct s32_pinctrl_soc_info *info)\n{\n\tconst __be32 *p;\n\tstruct device *dev;\n\tstruct property *prop;\n\tunsigned int *pins, *sss;\n\tint i, npins;\n\tu32 pinmux;\n\n\tdev = info->dev;\n\n\tdev_dbg(dev, \"group: %pOFn\\n\", np);\n\n\t \n\tgrp->data.name = np->name;\n\n\tnpins = of_property_count_elems_of_size(np, \"pinmux\", sizeof(u32));\n\tif (npins < 0) {\n\t\tdev_err(dev, \"Failed to read 'pinmux' property in node %s.\\n\",\n\t\t\tgrp->data.name);\n\t\treturn -EINVAL;\n\t}\n\tif (!npins) {\n\t\tdev_err(dev, \"The group %s has no pins.\\n\", grp->data.name);\n\t\treturn -EINVAL;\n\t}\n\n\tgrp->data.npins = npins;\n\n\tpins = devm_kcalloc(info->dev, npins, sizeof(*pins), GFP_KERNEL);\n\tsss = devm_kcalloc(info->dev, npins, sizeof(*sss), GFP_KERNEL);\n\tif (!pins || !sss)\n\t\treturn -ENOMEM;\n\n\ti = 0;\n\tof_property_for_each_u32(np, \"pinmux\", prop, p, pinmux) {\n\t\tpins[i] = get_pin_no(pinmux);\n\t\tsss[i] = get_pin_func(pinmux);\n\n\t\tdev_dbg(info->dev, \"pin: 0x%x, sss: 0x%x\", pins[i], sss[i]);\n\t\ti++;\n\t}\n\n\tgrp->data.pins = pins;\n\tgrp->pin_sss = sss;\n\n\treturn 0;\n}\n\nstatic int s32_pinctrl_parse_functions(struct device_node *np,\n\t\t\t\t\tstruct s32_pinctrl_soc_info *info,\n\t\t\t\t\tu32 index)\n{\n\tstruct device_node *child;\n\tstruct pinfunction *func;\n\tstruct s32_pin_group *grp;\n\tconst char **groups;\n\tu32 i = 0;\n\tint ret = 0;\n\n\tdev_dbg(info->dev, \"parse function(%u): %pOFn\\n\", index, np);\n\n\tfunc = &info->functions[index];\n\n\t \n\tfunc->name = np->name;\n\tfunc->ngroups = of_get_child_count(np);\n\tif (func->ngroups == 0) {\n\t\tdev_err(info->dev, \"no groups defined in %pOF\\n\", np);\n\t\treturn -EINVAL;\n\t}\n\n\tgroups = devm_kcalloc(info->dev, func->ngroups,\n\t\t\t\t    sizeof(*func->groups), GFP_KERNEL);\n\tif (!groups)\n\t\treturn -ENOMEM;\n\n\tfor_each_child_of_node(np, child) {\n\t\tgroups[i] = child->name;\n\t\tgrp = &info->groups[info->grp_index++];\n\t\tret = s32_pinctrl_parse_groups(child, grp, info);\n\t\tif (ret) {\n\t\t\tof_node_put(child);\n\t\t\treturn ret;\n\t\t}\n\t\ti++;\n\t}\n\n\tfunc->groups = groups;\n\n\treturn 0;\n}\n\nstatic int s32_pinctrl_probe_dt(struct platform_device *pdev,\n\t\t\t\tstruct s32_pinctrl *ipctl)\n{\n\tstruct s32_pinctrl_soc_info *info = ipctl->info;\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct device_node *child;\n\tstruct resource *res;\n\tstruct regmap *map;\n\tvoid __iomem *base;\n\tunsigned int mem_regions = info->soc_data->mem_regions;\n\tint ret;\n\tu32 nfuncs = 0;\n\tu32 i = 0;\n\n\tif (!np)\n\t\treturn -ENODEV;\n\n\tif (mem_regions == 0 || mem_regions >= 10000) {\n\t\tdev_err(&pdev->dev, \"mem_regions is invalid: %u\\n\", mem_regions);\n\t\treturn -EINVAL;\n\t}\n\n\tipctl->regions = devm_kcalloc(&pdev->dev, mem_regions,\n\t\t\t\t      sizeof(*ipctl->regions), GFP_KERNEL);\n\tif (!ipctl->regions)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < mem_regions; i++) {\n\t\tbase = devm_platform_get_and_ioremap_resource(pdev, i, &res);\n\t\tif (IS_ERR(base))\n\t\t\treturn PTR_ERR(base);\n\n\t\tsnprintf(ipctl->regions[i].name,\n\t\t\t sizeof(ipctl->regions[i].name), \"map%u\", i);\n\n\t\ts32_regmap_config.name = ipctl->regions[i].name;\n\t\ts32_regmap_config.max_register = resource_size(res) -\n\t\t\t\t\t\t s32_regmap_config.reg_stride;\n\n\t\tmap = devm_regmap_init_mmio(&pdev->dev, base,\n\t\t\t\t\t\t&s32_regmap_config);\n\t\tif (IS_ERR(map)) {\n\t\t\tdev_err(&pdev->dev, \"Failed to init regmap[%u]\\n\", i);\n\t\t\treturn PTR_ERR(map);\n\t\t}\n\n\t\tipctl->regions[i].map = map;\n\t\tipctl->regions[i].pin_range = &info->soc_data->mem_pin_ranges[i];\n\t}\n\n\tnfuncs = of_get_child_count(np);\n\tif (nfuncs <= 0) {\n\t\tdev_err(&pdev->dev, \"no functions defined\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tinfo->nfunctions = nfuncs;\n\tinfo->functions = devm_kcalloc(&pdev->dev, nfuncs,\n\t\t\t\t       sizeof(*info->functions), GFP_KERNEL);\n\tif (!info->functions)\n\t\treturn -ENOMEM;\n\n\tinfo->ngroups = 0;\n\tfor_each_child_of_node(np, child)\n\t\tinfo->ngroups += of_get_child_count(child);\n\n\tinfo->groups = devm_kcalloc(&pdev->dev, info->ngroups,\n\t\t\t\t    sizeof(*info->groups), GFP_KERNEL);\n\tif (!info->groups)\n\t\treturn -ENOMEM;\n\n\ti = 0;\n\tfor_each_child_of_node(np, child) {\n\t\tret = s32_pinctrl_parse_functions(child, info, i++);\n\t\tif (ret) {\n\t\t\tof_node_put(child);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint s32_pinctrl_probe(struct platform_device *pdev,\n\t\t      const struct s32_pinctrl_soc_data *soc_data)\n{\n\tstruct s32_pinctrl *ipctl;\n\tint ret;\n\tstruct pinctrl_desc *s32_pinctrl_desc;\n\tstruct s32_pinctrl_soc_info *info;\n#ifdef CONFIG_PM_SLEEP\n\tstruct s32_pinctrl_context *saved_context;\n#endif\n\n\tif (!soc_data || !soc_data->pins || !soc_data->npins) {\n\t\tdev_err(&pdev->dev, \"wrong pinctrl info\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tinfo = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinfo->soc_data = soc_data;\n\tinfo->dev = &pdev->dev;\n\n\t \n\tipctl = devm_kzalloc(&pdev->dev, sizeof(*ipctl), GFP_KERNEL);\n\tif (!ipctl)\n\t\treturn -ENOMEM;\n\n\tipctl->info = info;\n\tipctl->dev = info->dev;\n\tplatform_set_drvdata(pdev, ipctl);\n\n\tINIT_LIST_HEAD(&ipctl->gpio_configs);\n\tspin_lock_init(&ipctl->gpio_configs_lock);\n\n\ts32_pinctrl_desc =\n\t\tdevm_kmalloc(&pdev->dev, sizeof(*s32_pinctrl_desc), GFP_KERNEL);\n\tif (!s32_pinctrl_desc)\n\t\treturn -ENOMEM;\n\n\ts32_pinctrl_desc->name = dev_name(&pdev->dev);\n\ts32_pinctrl_desc->pins = info->soc_data->pins;\n\ts32_pinctrl_desc->npins = info->soc_data->npins;\n\ts32_pinctrl_desc->pctlops = &s32_pctrl_ops;\n\ts32_pinctrl_desc->pmxops = &s32_pmx_ops;\n\ts32_pinctrl_desc->confops = &s32_pinconf_ops;\n\ts32_pinctrl_desc->owner = THIS_MODULE;\n\n\tret = s32_pinctrl_probe_dt(pdev, ipctl);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"fail to probe dt properties\\n\");\n\t\treturn ret;\n\t}\n\n\tipctl->pctl = devm_pinctrl_register(&pdev->dev, s32_pinctrl_desc,\n\t\t\t\t\t    ipctl);\n\tif (IS_ERR(ipctl->pctl))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(ipctl->pctl),\n\t\t\t\t     \"could not register s32 pinctrl driver\\n\");\n\n#ifdef CONFIG_PM_SLEEP\n\tsaved_context = &ipctl->saved_context;\n\tsaved_context->pads =\n\t\tdevm_kcalloc(&pdev->dev, info->soc_data->npins,\n\t\t\t     sizeof(*saved_context->pads),\n\t\t\t     GFP_KERNEL);\n\tif (!saved_context->pads)\n\t\treturn -ENOMEM;\n#endif\n\n\tdev_info(&pdev->dev, \"initialized s32 pinctrl driver\\n\");\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}