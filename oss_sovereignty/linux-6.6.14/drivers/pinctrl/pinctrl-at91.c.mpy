{
  "module_name": "pinctrl-at91.c",
  "hash_id": "c8eb540380dd60afc4a0590a4a89d137f8cdd2440200330f6482b14742510ad3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/pinctrl-at91.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/gpio/driver.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_device.h>\n#include <linux/of_irq.h>\n#include <linux/pm.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/string_helpers.h>\n\n \n#include <linux/pinctrl/consumer.h>\n#include <linux/pinctrl/machine.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinmux.h>\n\n#include \"pinctrl-at91.h\"\n#include \"core.h\"\n\n#define MAX_GPIO_BANKS\t\t5\n#define MAX_NB_GPIO_PER_BANK\t32\n\nstruct at91_pinctrl_mux_ops;\n\n \nstruct at91_gpio_chip {\n\tstruct gpio_chip\tchip;\n\tstruct pinctrl_gpio_range range;\n\tstruct at91_gpio_chip\t*next;\n\tint\t\t\tpioc_hwirq;\n\tint\t\t\tpioc_virq;\n\tvoid __iomem\t\t*regbase;\n\tstruct clk\t\t*clock;\n\tconst struct at91_pinctrl_mux_ops *ops;\n\tu32\t\t\twakeups;\n\tu32\t\t\tbackups;\n\tu32\t\t\tid;\n};\n\nstatic struct at91_gpio_chip *gpio_chips[MAX_GPIO_BANKS];\n\nstatic int gpio_banks;\n\n#define PULL_UP\t\t(1 << 0)\n#define MULTI_DRIVE\t(1 << 1)\n#define DEGLITCH\t(1 << 2)\n#define PULL_DOWN\t(1 << 3)\n#define DIS_SCHMIT\t(1 << 4)\n#define DRIVE_STRENGTH_SHIFT\t5\n#define DRIVE_STRENGTH_MASK\t\t0x3\n#define DRIVE_STRENGTH   (DRIVE_STRENGTH_MASK << DRIVE_STRENGTH_SHIFT)\n#define OUTPUT\t\t(1 << 7)\n#define OUTPUT_VAL_SHIFT\t8\n#define OUTPUT_VAL\t(0x1 << OUTPUT_VAL_SHIFT)\n#define SLEWRATE_SHIFT\t9\n#define SLEWRATE_MASK\t0x1\n#define SLEWRATE\t(SLEWRATE_MASK << SLEWRATE_SHIFT)\n#define DEBOUNCE\t(1 << 16)\n#define DEBOUNCE_VAL_SHIFT\t17\n#define DEBOUNCE_VAL\t(0x3fff << DEBOUNCE_VAL_SHIFT)\n\n \nenum drive_strength_bit {\n\tDRIVE_STRENGTH_BIT_DEF,\n\tDRIVE_STRENGTH_BIT_LOW,\n\tDRIVE_STRENGTH_BIT_MED,\n\tDRIVE_STRENGTH_BIT_HI,\n};\n\n#define DRIVE_STRENGTH_BIT_MSK(name)\t(DRIVE_STRENGTH_BIT_##name << \\\n\t\t\t\t\t DRIVE_STRENGTH_SHIFT)\n\nenum slewrate_bit {\n\tSLEWRATE_BIT_ENA,\n\tSLEWRATE_BIT_DIS,\n};\n\n#define SLEWRATE_BIT_MSK(name)\t\t(SLEWRATE_BIT_##name << SLEWRATE_SHIFT)\n\n \nstruct at91_pmx_func {\n\tconst char\t*name;\n\tconst char\t**groups;\n\tunsigned\tngroups;\n};\n\nenum at91_mux {\n\tAT91_MUX_GPIO = 0,\n\tAT91_MUX_PERIPH_A = 1,\n\tAT91_MUX_PERIPH_B = 2,\n\tAT91_MUX_PERIPH_C = 3,\n\tAT91_MUX_PERIPH_D = 4,\n};\n\n \nstruct at91_pmx_pin {\n\tuint32_t\tbank;\n\tuint32_t\tpin;\n\tenum at91_mux\tmux;\n\tunsigned long\tconf;\n};\n\n \nstruct at91_pin_group {\n\tconst char\t\t*name;\n\tstruct at91_pmx_pin\t*pins_conf;\n\tunsigned int\t\t*pins;\n\tunsigned\t\tnpins;\n};\n\n \nstruct at91_pinctrl_mux_ops {\n\tenum at91_mux (*get_periph)(void __iomem *pio, unsigned mask);\n\tvoid (*mux_A_periph)(void __iomem *pio, unsigned mask);\n\tvoid (*mux_B_periph)(void __iomem *pio, unsigned mask);\n\tvoid (*mux_C_periph)(void __iomem *pio, unsigned mask);\n\tvoid (*mux_D_periph)(void __iomem *pio, unsigned mask);\n\tbool (*get_deglitch)(void __iomem *pio, unsigned pin);\n\tvoid (*set_deglitch)(void __iomem *pio, unsigned mask, bool is_on);\n\tbool (*get_debounce)(void __iomem *pio, unsigned pin, u32 *div);\n\tvoid (*set_debounce)(void __iomem *pio, unsigned mask, bool is_on, u32 div);\n\tbool (*get_pulldown)(void __iomem *pio, unsigned pin);\n\tvoid (*set_pulldown)(void __iomem *pio, unsigned mask, bool is_on);\n\tbool (*get_schmitt_trig)(void __iomem *pio, unsigned pin);\n\tvoid (*disable_schmitt_trig)(void __iomem *pio, unsigned mask);\n\tunsigned (*get_drivestrength)(void __iomem *pio, unsigned pin);\n\tvoid (*set_drivestrength)(void __iomem *pio, unsigned pin,\n\t\t\t\t\tu32 strength);\n\tunsigned (*get_slewrate)(void __iomem *pio, unsigned pin);\n\tvoid (*set_slewrate)(void __iomem *pio, unsigned pin, u32 slewrate);\n\t \n\tint (*irq_type)(struct irq_data *d, unsigned type);\n};\n\nstatic int gpio_irq_type(struct irq_data *d, unsigned type);\nstatic int alt_gpio_irq_type(struct irq_data *d, unsigned type);\n\nstruct at91_pinctrl {\n\tstruct device\t\t*dev;\n\tstruct pinctrl_dev\t*pctl;\n\n\tint\t\t\tnactive_banks;\n\n\tuint32_t\t\t*mux_mask;\n\tint\t\t\tnmux;\n\n\tstruct at91_pmx_func\t*functions;\n\tint\t\t\tnfunctions;\n\n\tstruct at91_pin_group\t*groups;\n\tint\t\t\tngroups;\n\n\tconst struct at91_pinctrl_mux_ops *ops;\n};\n\nstatic inline const struct at91_pin_group *at91_pinctrl_find_group_by_name(\n\t\t\t\tconst struct at91_pinctrl *info,\n\t\t\t\tconst char *name)\n{\n\tconst struct at91_pin_group *grp = NULL;\n\tint i;\n\n\tfor (i = 0; i < info->ngroups; i++) {\n\t\tif (strcmp(info->groups[i].name, name))\n\t\t\tcontinue;\n\n\t\tgrp = &info->groups[i];\n\t\tdev_dbg(info->dev, \"%s: %d 0:%d\\n\", name, grp->npins, grp->pins[0]);\n\t\tbreak;\n\t}\n\n\treturn grp;\n}\n\nstatic int at91_get_groups_count(struct pinctrl_dev *pctldev)\n{\n\tstruct at91_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn info->ngroups;\n}\n\nstatic const char *at91_get_group_name(struct pinctrl_dev *pctldev,\n\t\t\t\t       unsigned selector)\n{\n\tstruct at91_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn info->groups[selector].name;\n}\n\nstatic int at91_get_group_pins(struct pinctrl_dev *pctldev, unsigned selector,\n\t\t\t       const unsigned **pins,\n\t\t\t       unsigned *npins)\n{\n\tstruct at91_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\n\n\tif (selector >= info->ngroups)\n\t\treturn -EINVAL;\n\n\t*pins = info->groups[selector].pins;\n\t*npins = info->groups[selector].npins;\n\n\treturn 0;\n}\n\nstatic void at91_pin_dbg_show(struct pinctrl_dev *pctldev, struct seq_file *s,\n\t\t   unsigned offset)\n{\n\tseq_printf(s, \"%s\", dev_name(pctldev->dev));\n}\n\nstatic int at91_dt_node_to_map(struct pinctrl_dev *pctldev,\n\t\t\tstruct device_node *np,\n\t\t\tstruct pinctrl_map **map, unsigned *num_maps)\n{\n\tstruct at91_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct at91_pin_group *grp;\n\tstruct pinctrl_map *new_map;\n\tstruct device_node *parent;\n\tint map_num = 1;\n\tint i;\n\n\t \n\tgrp = at91_pinctrl_find_group_by_name(info, np->name);\n\tif (!grp) {\n\t\tdev_err(info->dev, \"unable to find group for node %pOFn\\n\",\n\t\t\tnp);\n\t\treturn -EINVAL;\n\t}\n\n\tmap_num += grp->npins;\n\tnew_map = devm_kcalloc(pctldev->dev, map_num, sizeof(*new_map),\n\t\t\t       GFP_KERNEL);\n\tif (!new_map)\n\t\treturn -ENOMEM;\n\n\t*map = new_map;\n\t*num_maps = map_num;\n\n\t \n\tparent = of_get_parent(np);\n\tif (!parent) {\n\t\tdevm_kfree(pctldev->dev, new_map);\n\t\treturn -EINVAL;\n\t}\n\tnew_map[0].type = PIN_MAP_TYPE_MUX_GROUP;\n\tnew_map[0].data.mux.function = parent->name;\n\tnew_map[0].data.mux.group = np->name;\n\tof_node_put(parent);\n\n\t \n\tnew_map++;\n\tfor (i = 0; i < grp->npins; i++) {\n\t\tnew_map[i].type = PIN_MAP_TYPE_CONFIGS_PIN;\n\t\tnew_map[i].data.configs.group_or_pin =\n\t\t\t\tpin_get_name(pctldev, grp->pins[i]);\n\t\tnew_map[i].data.configs.configs = &grp->pins_conf[i].conf;\n\t\tnew_map[i].data.configs.num_configs = 1;\n\t}\n\n\tdev_dbg(pctldev->dev, \"maps: function %s group %s num %d\\n\",\n\t\t(*map)->data.mux.function, (*map)->data.mux.group, map_num);\n\n\treturn 0;\n}\n\nstatic void at91_dt_free_map(struct pinctrl_dev *pctldev,\n\t\t\t\tstruct pinctrl_map *map, unsigned num_maps)\n{\n}\n\nstatic const struct pinctrl_ops at91_pctrl_ops = {\n\t.get_groups_count\t= at91_get_groups_count,\n\t.get_group_name\t\t= at91_get_group_name,\n\t.get_group_pins\t\t= at91_get_group_pins,\n\t.pin_dbg_show\t\t= at91_pin_dbg_show,\n\t.dt_node_to_map\t\t= at91_dt_node_to_map,\n\t.dt_free_map\t\t= at91_dt_free_map,\n};\n\nstatic void __iomem *pin_to_controller(struct at91_pinctrl *info,\n\t\t\t\t unsigned int bank)\n{\n\tif (!gpio_chips[bank])\n\t\treturn NULL;\n\n\treturn gpio_chips[bank]->regbase;\n}\n\nstatic inline int pin_to_bank(unsigned pin)\n{\n\treturn pin /= MAX_NB_GPIO_PER_BANK;\n}\n\nstatic unsigned pin_to_mask(unsigned int pin)\n{\n\treturn 1 << pin;\n}\n\nstatic unsigned two_bit_pin_value_shift_amount(unsigned int pin)\n{\n\t \n\treturn 2*((pin >= MAX_NB_GPIO_PER_BANK/2)\n\t\t\t? pin - MAX_NB_GPIO_PER_BANK/2 : pin);\n}\n\nstatic unsigned sama5d3_get_drive_register(unsigned int pin)\n{\n\t \n\treturn (pin >= MAX_NB_GPIO_PER_BANK/2)\n\t\t\t? SAMA5D3_PIO_DRIVER2 : SAMA5D3_PIO_DRIVER1;\n}\n\nstatic unsigned at91sam9x5_get_drive_register(unsigned int pin)\n{\n\t \n\treturn (pin >= MAX_NB_GPIO_PER_BANK/2)\n\t\t\t? AT91SAM9X5_PIO_DRIVER2 : AT91SAM9X5_PIO_DRIVER1;\n}\n\nstatic void at91_mux_disable_interrupt(void __iomem *pio, unsigned mask)\n{\n\twritel_relaxed(mask, pio + PIO_IDR);\n}\n\nstatic unsigned at91_mux_get_pullup(void __iomem *pio, unsigned pin)\n{\n\treturn !((readl_relaxed(pio + PIO_PUSR) >> pin) & 0x1);\n}\n\nstatic void at91_mux_set_pullup(void __iomem *pio, unsigned mask, bool on)\n{\n\tif (on)\n\t\twritel_relaxed(mask, pio + PIO_PPDDR);\n\n\twritel_relaxed(mask, pio + (on ? PIO_PUER : PIO_PUDR));\n}\n\nstatic bool at91_mux_get_output(void __iomem *pio, unsigned int pin, bool *val)\n{\n\t*val = (readl_relaxed(pio + PIO_ODSR) >> pin) & 0x1;\n\treturn (readl_relaxed(pio + PIO_OSR) >> pin) & 0x1;\n}\n\nstatic void at91_mux_set_output(void __iomem *pio, unsigned int mask,\n\t\t\t\tbool is_on, bool val)\n{\n\twritel_relaxed(mask, pio + (val ? PIO_SODR : PIO_CODR));\n\twritel_relaxed(mask, pio + (is_on ? PIO_OER : PIO_ODR));\n}\n\nstatic unsigned at91_mux_get_multidrive(void __iomem *pio, unsigned pin)\n{\n\treturn (readl_relaxed(pio + PIO_MDSR) >> pin) & 0x1;\n}\n\nstatic void at91_mux_set_multidrive(void __iomem *pio, unsigned mask, bool on)\n{\n\twritel_relaxed(mask, pio + (on ? PIO_MDER : PIO_MDDR));\n}\n\nstatic void at91_mux_set_A_periph(void __iomem *pio, unsigned mask)\n{\n\twritel_relaxed(mask, pio + PIO_ASR);\n}\n\nstatic void at91_mux_set_B_periph(void __iomem *pio, unsigned mask)\n{\n\twritel_relaxed(mask, pio + PIO_BSR);\n}\n\nstatic void at91_mux_pio3_set_A_periph(void __iomem *pio, unsigned mask)\n{\n\n\twritel_relaxed(readl_relaxed(pio + PIO_ABCDSR1) & ~mask,\n\t\t\t\t\t\tpio + PIO_ABCDSR1);\n\twritel_relaxed(readl_relaxed(pio + PIO_ABCDSR2) & ~mask,\n\t\t\t\t\t\tpio + PIO_ABCDSR2);\n}\n\nstatic void at91_mux_pio3_set_B_periph(void __iomem *pio, unsigned mask)\n{\n\twritel_relaxed(readl_relaxed(pio + PIO_ABCDSR1) | mask,\n\t\t\t\t\t\tpio + PIO_ABCDSR1);\n\twritel_relaxed(readl_relaxed(pio + PIO_ABCDSR2) & ~mask,\n\t\t\t\t\t\tpio + PIO_ABCDSR2);\n}\n\nstatic void at91_mux_pio3_set_C_periph(void __iomem *pio, unsigned mask)\n{\n\twritel_relaxed(readl_relaxed(pio + PIO_ABCDSR1) & ~mask, pio + PIO_ABCDSR1);\n\twritel_relaxed(readl_relaxed(pio + PIO_ABCDSR2) | mask, pio + PIO_ABCDSR2);\n}\n\nstatic void at91_mux_pio3_set_D_periph(void __iomem *pio, unsigned mask)\n{\n\twritel_relaxed(readl_relaxed(pio + PIO_ABCDSR1) | mask, pio + PIO_ABCDSR1);\n\twritel_relaxed(readl_relaxed(pio + PIO_ABCDSR2) | mask, pio + PIO_ABCDSR2);\n}\n\nstatic enum at91_mux at91_mux_pio3_get_periph(void __iomem *pio, unsigned mask)\n{\n\tunsigned select;\n\n\tif (readl_relaxed(pio + PIO_PSR) & mask)\n\t\treturn AT91_MUX_GPIO;\n\n\tselect = !!(readl_relaxed(pio + PIO_ABCDSR1) & mask);\n\tselect |= (!!(readl_relaxed(pio + PIO_ABCDSR2) & mask) << 1);\n\n\treturn select + 1;\n}\n\nstatic enum at91_mux at91_mux_get_periph(void __iomem *pio, unsigned mask)\n{\n\tunsigned select;\n\n\tif (readl_relaxed(pio + PIO_PSR) & mask)\n\t\treturn AT91_MUX_GPIO;\n\n\tselect = readl_relaxed(pio + PIO_ABSR) & mask;\n\n\treturn select + 1;\n}\n\nstatic bool at91_mux_get_deglitch(void __iomem *pio, unsigned pin)\n{\n\treturn (readl_relaxed(pio + PIO_IFSR) >> pin) & 0x1;\n}\n\nstatic void at91_mux_set_deglitch(void __iomem *pio, unsigned mask, bool is_on)\n{\n\twritel_relaxed(mask, pio + (is_on ? PIO_IFER : PIO_IFDR));\n}\n\nstatic bool at91_mux_pio3_get_deglitch(void __iomem *pio, unsigned pin)\n{\n\tif ((readl_relaxed(pio + PIO_IFSR) >> pin) & 0x1)\n\t\treturn !((readl_relaxed(pio + PIO_IFSCSR) >> pin) & 0x1);\n\n\treturn false;\n}\n\nstatic void at91_mux_pio3_set_deglitch(void __iomem *pio, unsigned mask, bool is_on)\n{\n\tif (is_on)\n\t\twritel_relaxed(mask, pio + PIO_IFSCDR);\n\tat91_mux_set_deglitch(pio, mask, is_on);\n}\n\nstatic bool at91_mux_pio3_get_debounce(void __iomem *pio, unsigned pin, u32 *div)\n{\n\t*div = readl_relaxed(pio + PIO_SCDR);\n\n\treturn ((readl_relaxed(pio + PIO_IFSR) >> pin) & 0x1) &&\n\t       ((readl_relaxed(pio + PIO_IFSCSR) >> pin) & 0x1);\n}\n\nstatic void at91_mux_pio3_set_debounce(void __iomem *pio, unsigned mask,\n\t\t\t\tbool is_on, u32 div)\n{\n\tif (is_on) {\n\t\twritel_relaxed(mask, pio + PIO_IFSCER);\n\t\twritel_relaxed(div & PIO_SCDR_DIV, pio + PIO_SCDR);\n\t\twritel_relaxed(mask, pio + PIO_IFER);\n\t} else\n\t\twritel_relaxed(mask, pio + PIO_IFSCDR);\n}\n\nstatic bool at91_mux_pio3_get_pulldown(void __iomem *pio, unsigned pin)\n{\n\treturn !((readl_relaxed(pio + PIO_PPDSR) >> pin) & 0x1);\n}\n\nstatic void at91_mux_pio3_set_pulldown(void __iomem *pio, unsigned mask, bool is_on)\n{\n\tif (is_on)\n\t\twritel_relaxed(mask, pio + PIO_PUDR);\n\n\twritel_relaxed(mask, pio + (is_on ? PIO_PPDER : PIO_PPDDR));\n}\n\nstatic void at91_mux_pio3_disable_schmitt_trig(void __iomem *pio, unsigned mask)\n{\n\twritel_relaxed(readl_relaxed(pio + PIO_SCHMITT) | mask, pio + PIO_SCHMITT);\n}\n\nstatic bool at91_mux_pio3_get_schmitt_trig(void __iomem *pio, unsigned pin)\n{\n\treturn (readl_relaxed(pio + PIO_SCHMITT) >> pin) & 0x1;\n}\n\nstatic inline u32 read_drive_strength(void __iomem *reg, unsigned pin)\n{\n\tunsigned tmp = readl_relaxed(reg);\n\n\ttmp = tmp >> two_bit_pin_value_shift_amount(pin);\n\n\treturn tmp & DRIVE_STRENGTH_MASK;\n}\n\nstatic unsigned at91_mux_sama5d3_get_drivestrength(void __iomem *pio,\n\t\t\t\t\t\t\tunsigned pin)\n{\n\tunsigned tmp = read_drive_strength(pio +\n\t\t\t\t\tsama5d3_get_drive_register(pin), pin);\n\n\t \n\tif (!tmp)\n\t\ttmp = DRIVE_STRENGTH_BIT_MSK(LOW);\n\n\treturn tmp;\n}\n\nstatic unsigned at91_mux_sam9x5_get_drivestrength(void __iomem *pio,\n\t\t\t\t\t\t\tunsigned pin)\n{\n\tunsigned tmp = read_drive_strength(pio +\n\t\t\t\tat91sam9x5_get_drive_register(pin), pin);\n\n\t \n\ttmp = DRIVE_STRENGTH_BIT_MSK(HI) - tmp;\n\n\treturn tmp;\n}\n\nstatic unsigned at91_mux_sam9x60_get_drivestrength(void __iomem *pio,\n\t\t\t\t\t\t   unsigned pin)\n{\n\tunsigned tmp = readl_relaxed(pio + SAM9X60_PIO_DRIVER1);\n\n\tif (tmp & BIT(pin))\n\t\treturn DRIVE_STRENGTH_BIT_HI;\n\n\treturn DRIVE_STRENGTH_BIT_LOW;\n}\n\nstatic unsigned at91_mux_sam9x60_get_slewrate(void __iomem *pio, unsigned pin)\n{\n\tunsigned tmp = readl_relaxed(pio + SAM9X60_PIO_SLEWR);\n\n\tif ((tmp & BIT(pin)))\n\t\treturn SLEWRATE_BIT_ENA;\n\n\treturn SLEWRATE_BIT_DIS;\n}\n\nstatic void set_drive_strength(void __iomem *reg, unsigned pin, u32 strength)\n{\n\tunsigned tmp = readl_relaxed(reg);\n\tunsigned shift = two_bit_pin_value_shift_amount(pin);\n\n\ttmp &= ~(DRIVE_STRENGTH_MASK  <<  shift);\n\ttmp |= strength << shift;\n\n\twritel_relaxed(tmp, reg);\n}\n\nstatic void at91_mux_sama5d3_set_drivestrength(void __iomem *pio, unsigned pin,\n\t\t\t\t\t\tu32 setting)\n{\n\t \n\tif (!setting)\n\t\treturn;\n\n\t \n\tset_drive_strength(pio + sama5d3_get_drive_register(pin), pin, setting);\n}\n\nstatic void at91_mux_sam9x5_set_drivestrength(void __iomem *pio, unsigned pin,\n\t\t\t\t\t\tu32 setting)\n{\n\t \n\tif (!setting)\n\t\treturn;\n\n\t \n\tsetting = DRIVE_STRENGTH_BIT_MSK(HI) - setting;\n\n\tset_drive_strength(pio + at91sam9x5_get_drive_register(pin), pin,\n\t\t\t\tsetting);\n}\n\nstatic void at91_mux_sam9x60_set_drivestrength(void __iomem *pio, unsigned pin,\n\t\t\t\t\t       u32 setting)\n{\n\tunsigned int tmp;\n\n\tif (setting <= DRIVE_STRENGTH_BIT_DEF ||\n\t    setting == DRIVE_STRENGTH_BIT_MED ||\n\t    setting > DRIVE_STRENGTH_BIT_HI)\n\t\treturn;\n\n\ttmp = readl_relaxed(pio + SAM9X60_PIO_DRIVER1);\n\n\t \n\tif (setting == DRIVE_STRENGTH_BIT_LOW)\n\t\ttmp &= ~BIT(pin);\n\telse\n\t\ttmp |= BIT(pin);\n\n\twritel_relaxed(tmp, pio + SAM9X60_PIO_DRIVER1);\n}\n\nstatic void at91_mux_sam9x60_set_slewrate(void __iomem *pio, unsigned pin,\n\t\t\t\t\t  u32 setting)\n{\n\tunsigned int tmp;\n\n\tif (setting < SLEWRATE_BIT_ENA || setting > SLEWRATE_BIT_DIS)\n\t\treturn;\n\n\ttmp = readl_relaxed(pio + SAM9X60_PIO_SLEWR);\n\n\tif (setting == SLEWRATE_BIT_DIS)\n\t\ttmp &= ~BIT(pin);\n\telse\n\t\ttmp |= BIT(pin);\n\n\twritel_relaxed(tmp, pio + SAM9X60_PIO_SLEWR);\n}\n\nstatic const struct at91_pinctrl_mux_ops at91rm9200_ops = {\n\t.get_periph\t= at91_mux_get_periph,\n\t.mux_A_periph\t= at91_mux_set_A_periph,\n\t.mux_B_periph\t= at91_mux_set_B_periph,\n\t.get_deglitch\t= at91_mux_get_deglitch,\n\t.set_deglitch\t= at91_mux_set_deglitch,\n\t.irq_type\t= gpio_irq_type,\n};\n\nstatic const struct at91_pinctrl_mux_ops at91sam9x5_ops = {\n\t.get_periph\t= at91_mux_pio3_get_periph,\n\t.mux_A_periph\t= at91_mux_pio3_set_A_periph,\n\t.mux_B_periph\t= at91_mux_pio3_set_B_periph,\n\t.mux_C_periph\t= at91_mux_pio3_set_C_periph,\n\t.mux_D_periph\t= at91_mux_pio3_set_D_periph,\n\t.get_deglitch\t= at91_mux_pio3_get_deglitch,\n\t.set_deglitch\t= at91_mux_pio3_set_deglitch,\n\t.get_debounce\t= at91_mux_pio3_get_debounce,\n\t.set_debounce\t= at91_mux_pio3_set_debounce,\n\t.get_pulldown\t= at91_mux_pio3_get_pulldown,\n\t.set_pulldown\t= at91_mux_pio3_set_pulldown,\n\t.get_schmitt_trig = at91_mux_pio3_get_schmitt_trig,\n\t.disable_schmitt_trig = at91_mux_pio3_disable_schmitt_trig,\n\t.get_drivestrength = at91_mux_sam9x5_get_drivestrength,\n\t.set_drivestrength = at91_mux_sam9x5_set_drivestrength,\n\t.irq_type\t= alt_gpio_irq_type,\n};\n\nstatic const struct at91_pinctrl_mux_ops sam9x60_ops = {\n\t.get_periph\t= at91_mux_pio3_get_periph,\n\t.mux_A_periph\t= at91_mux_pio3_set_A_periph,\n\t.mux_B_periph\t= at91_mux_pio3_set_B_periph,\n\t.mux_C_periph\t= at91_mux_pio3_set_C_periph,\n\t.mux_D_periph\t= at91_mux_pio3_set_D_periph,\n\t.get_deglitch\t= at91_mux_pio3_get_deglitch,\n\t.set_deglitch\t= at91_mux_pio3_set_deglitch,\n\t.get_debounce\t= at91_mux_pio3_get_debounce,\n\t.set_debounce\t= at91_mux_pio3_set_debounce,\n\t.get_pulldown\t= at91_mux_pio3_get_pulldown,\n\t.set_pulldown\t= at91_mux_pio3_set_pulldown,\n\t.get_schmitt_trig = at91_mux_pio3_get_schmitt_trig,\n\t.disable_schmitt_trig = at91_mux_pio3_disable_schmitt_trig,\n\t.get_drivestrength = at91_mux_sam9x60_get_drivestrength,\n\t.set_drivestrength = at91_mux_sam9x60_set_drivestrength,\n\t.get_slewrate   = at91_mux_sam9x60_get_slewrate,\n\t.set_slewrate   = at91_mux_sam9x60_set_slewrate,\n\t.irq_type\t= alt_gpio_irq_type,\n};\n\nstatic const struct at91_pinctrl_mux_ops sama5d3_ops = {\n\t.get_periph\t= at91_mux_pio3_get_periph,\n\t.mux_A_periph\t= at91_mux_pio3_set_A_periph,\n\t.mux_B_periph\t= at91_mux_pio3_set_B_periph,\n\t.mux_C_periph\t= at91_mux_pio3_set_C_periph,\n\t.mux_D_periph\t= at91_mux_pio3_set_D_periph,\n\t.get_deglitch\t= at91_mux_pio3_get_deglitch,\n\t.set_deglitch\t= at91_mux_pio3_set_deglitch,\n\t.get_debounce\t= at91_mux_pio3_get_debounce,\n\t.set_debounce\t= at91_mux_pio3_set_debounce,\n\t.get_pulldown\t= at91_mux_pio3_get_pulldown,\n\t.set_pulldown\t= at91_mux_pio3_set_pulldown,\n\t.get_schmitt_trig = at91_mux_pio3_get_schmitt_trig,\n\t.disable_schmitt_trig = at91_mux_pio3_disable_schmitt_trig,\n\t.get_drivestrength = at91_mux_sama5d3_get_drivestrength,\n\t.set_drivestrength = at91_mux_sama5d3_set_drivestrength,\n\t.irq_type\t= alt_gpio_irq_type,\n};\n\nstatic void at91_pin_dbg(const struct device *dev, const struct at91_pmx_pin *pin)\n{\n\tif (pin->mux) {\n\t\tdev_dbg(dev, \"pio%c%d configured as periph%c with conf = 0x%lx\\n\",\n\t\t\tpin->bank + 'A', pin->pin, pin->mux - 1 + 'A', pin->conf);\n\t} else {\n\t\tdev_dbg(dev, \"pio%c%d configured as gpio with conf = 0x%lx\\n\",\n\t\t\tpin->bank + 'A', pin->pin, pin->conf);\n\t}\n}\n\nstatic int pin_check_config(struct at91_pinctrl *info, const char *name,\n\t\t\t    int index, const struct at91_pmx_pin *pin)\n{\n\tint mux;\n\n\t \n\tif (pin->bank >= gpio_banks) {\n\t\tdev_err(info->dev, \"%s: pin conf %d bank_id %d >= nbanks %d\\n\",\n\t\t\tname, index, pin->bank, gpio_banks);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!gpio_chips[pin->bank]) {\n\t\tdev_err(info->dev, \"%s: pin conf %d bank_id %d not enabled\\n\",\n\t\t\tname, index, pin->bank);\n\t\treturn -ENXIO;\n\t}\n\n\tif (pin->pin >= MAX_NB_GPIO_PER_BANK) {\n\t\tdev_err(info->dev, \"%s: pin conf %d pin_bank_id %d >= %d\\n\",\n\t\t\tname, index, pin->pin, MAX_NB_GPIO_PER_BANK);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!pin->mux)\n\t\treturn 0;\n\n\tmux = pin->mux - 1;\n\n\tif (mux >= info->nmux) {\n\t\tdev_err(info->dev, \"%s: pin conf %d mux_id %d >= nmux %d\\n\",\n\t\t\tname, index, mux, info->nmux);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!(info->mux_mask[pin->bank * info->nmux + mux] & 1 << pin->pin)) {\n\t\tdev_err(info->dev, \"%s: pin conf %d mux_id %d not supported for pio%c%d\\n\",\n\t\t\tname, index, mux, pin->bank + 'A', pin->pin);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void at91_mux_gpio_disable(void __iomem *pio, unsigned mask)\n{\n\twritel_relaxed(mask, pio + PIO_PDR);\n}\n\nstatic void at91_mux_gpio_enable(void __iomem *pio, unsigned mask, bool input)\n{\n\twritel_relaxed(mask, pio + PIO_PER);\n\twritel_relaxed(mask, pio + (input ? PIO_ODR : PIO_OER));\n}\n\nstatic int at91_pmx_set(struct pinctrl_dev *pctldev, unsigned selector,\n\t\t\tunsigned group)\n{\n\tstruct at91_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct at91_pmx_pin *pins_conf = info->groups[group].pins_conf;\n\tconst struct at91_pmx_pin *pin;\n\tuint32_t npins = info->groups[group].npins;\n\tint i, ret;\n\tunsigned mask;\n\tvoid __iomem *pio;\n\n\tdev_dbg(info->dev, \"enable function %s group %s\\n\",\n\t\tinfo->functions[selector].name, info->groups[group].name);\n\n\t \n\tfor (i = 0; i < npins; i++) {\n\t\tpin = &pins_conf[i];\n\t\tret = pin_check_config(info, info->groups[group].name, i, pin);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < npins; i++) {\n\t\tpin = &pins_conf[i];\n\t\tat91_pin_dbg(info->dev, pin);\n\t\tpio = pin_to_controller(info, pin->bank);\n\n\t\tif (!pio)\n\t\t\tcontinue;\n\n\t\tmask = pin_to_mask(pin->pin);\n\t\tat91_mux_disable_interrupt(pio, mask);\n\t\tswitch (pin->mux) {\n\t\tcase AT91_MUX_GPIO:\n\t\t\tat91_mux_gpio_enable(pio, mask, 1);\n\t\t\tbreak;\n\t\tcase AT91_MUX_PERIPH_A:\n\t\t\tinfo->ops->mux_A_periph(pio, mask);\n\t\t\tbreak;\n\t\tcase AT91_MUX_PERIPH_B:\n\t\t\tinfo->ops->mux_B_periph(pio, mask);\n\t\t\tbreak;\n\t\tcase AT91_MUX_PERIPH_C:\n\t\t\tif (!info->ops->mux_C_periph)\n\t\t\t\treturn -EINVAL;\n\t\t\tinfo->ops->mux_C_periph(pio, mask);\n\t\t\tbreak;\n\t\tcase AT91_MUX_PERIPH_D:\n\t\t\tif (!info->ops->mux_D_periph)\n\t\t\t\treturn -EINVAL;\n\t\t\tinfo->ops->mux_D_periph(pio, mask);\n\t\t\tbreak;\n\t\t}\n\t\tif (pin->mux)\n\t\t\tat91_mux_gpio_disable(pio, mask);\n\t}\n\n\treturn 0;\n}\n\nstatic int at91_pmx_get_funcs_count(struct pinctrl_dev *pctldev)\n{\n\tstruct at91_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn info->nfunctions;\n}\n\nstatic const char *at91_pmx_get_func_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t  unsigned selector)\n{\n\tstruct at91_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn info->functions[selector].name;\n}\n\nstatic int at91_pmx_get_groups(struct pinctrl_dev *pctldev, unsigned selector,\n\t\t\t       const char * const **groups,\n\t\t\t       unsigned * const num_groups)\n{\n\tstruct at91_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\n\n\t*groups = info->functions[selector].groups;\n\t*num_groups = info->functions[selector].ngroups;\n\n\treturn 0;\n}\n\nstatic int at91_gpio_request_enable(struct pinctrl_dev *pctldev,\n\t\t\t\t    struct pinctrl_gpio_range *range,\n\t\t\t\t    unsigned offset)\n{\n\tstruct at91_pinctrl *npct = pinctrl_dev_get_drvdata(pctldev);\n\tstruct at91_gpio_chip *at91_chip;\n\tstruct gpio_chip *chip;\n\tunsigned mask;\n\n\tif (!range) {\n\t\tdev_err(npct->dev, \"invalid range\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (!range->gc) {\n\t\tdev_err(npct->dev, \"missing GPIO chip in range\\n\");\n\t\treturn -EINVAL;\n\t}\n\tchip = range->gc;\n\tat91_chip = gpiochip_get_data(chip);\n\n\tdev_dbg(npct->dev, \"enable pin %u as GPIO\\n\", offset);\n\n\tmask = 1 << (offset - chip->base);\n\n\tdev_dbg(npct->dev, \"enable pin %u as PIO%c%d 0x%x\\n\",\n\t\toffset, 'A' + range->id, offset - chip->base, mask);\n\n\twritel_relaxed(mask, at91_chip->regbase + PIO_PER);\n\n\treturn 0;\n}\n\nstatic void at91_gpio_disable_free(struct pinctrl_dev *pctldev,\n\t\t\t\t   struct pinctrl_gpio_range *range,\n\t\t\t\t   unsigned offset)\n{\n\tstruct at91_pinctrl *npct = pinctrl_dev_get_drvdata(pctldev);\n\n\tdev_dbg(npct->dev, \"disable pin %u as GPIO\\n\", offset);\n\t \n}\n\nstatic const struct pinmux_ops at91_pmx_ops = {\n\t.get_functions_count\t= at91_pmx_get_funcs_count,\n\t.get_function_name\t= at91_pmx_get_func_name,\n\t.get_function_groups\t= at91_pmx_get_groups,\n\t.set_mux\t\t= at91_pmx_set,\n\t.gpio_request_enable\t= at91_gpio_request_enable,\n\t.gpio_disable_free\t= at91_gpio_disable_free,\n};\n\nstatic int at91_pinconf_get(struct pinctrl_dev *pctldev,\n\t\t\t     unsigned pin_id, unsigned long *config)\n{\n\tstruct at91_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\n\tvoid __iomem *pio;\n\tunsigned pin;\n\tint div;\n\tbool out;\n\n\t*config = 0;\n\tdev_dbg(info->dev, \"%s:%d, pin_id=%d\", __func__, __LINE__, pin_id);\n\tpio = pin_to_controller(info, pin_to_bank(pin_id));\n\n\tif (!pio)\n\t\treturn -EINVAL;\n\n\tpin = pin_id % MAX_NB_GPIO_PER_BANK;\n\n\tif (at91_mux_get_multidrive(pio, pin))\n\t\t*config |= MULTI_DRIVE;\n\n\tif (at91_mux_get_pullup(pio, pin))\n\t\t*config |= PULL_UP;\n\n\tif (info->ops->get_deglitch && info->ops->get_deglitch(pio, pin))\n\t\t*config |= DEGLITCH;\n\tif (info->ops->get_debounce && info->ops->get_debounce(pio, pin, &div))\n\t\t*config |= DEBOUNCE | (div << DEBOUNCE_VAL_SHIFT);\n\tif (info->ops->get_pulldown && info->ops->get_pulldown(pio, pin))\n\t\t*config |= PULL_DOWN;\n\tif (info->ops->get_schmitt_trig && info->ops->get_schmitt_trig(pio, pin))\n\t\t*config |= DIS_SCHMIT;\n\tif (info->ops->get_drivestrength)\n\t\t*config |= (info->ops->get_drivestrength(pio, pin)\n\t\t\t\t<< DRIVE_STRENGTH_SHIFT);\n\tif (info->ops->get_slewrate)\n\t\t*config |= (info->ops->get_slewrate(pio, pin) << SLEWRATE_SHIFT);\n\tif (at91_mux_get_output(pio, pin, &out))\n\t\t*config |= OUTPUT | (out << OUTPUT_VAL_SHIFT);\n\n\treturn 0;\n}\n\nstatic int at91_pinconf_set(struct pinctrl_dev *pctldev,\n\t\t\t     unsigned pin_id, unsigned long *configs,\n\t\t\t     unsigned num_configs)\n{\n\tstruct at91_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\n\tunsigned mask;\n\tvoid __iomem *pio;\n\tint i;\n\tunsigned long config;\n\tunsigned pin;\n\n\tfor (i = 0; i < num_configs; i++) {\n\t\tconfig = configs[i];\n\n\t\tdev_dbg(info->dev,\n\t\t\t\"%s:%d, pin_id=%d, config=0x%lx\",\n\t\t\t__func__, __LINE__, pin_id, config);\n\t\tpio = pin_to_controller(info, pin_to_bank(pin_id));\n\n\t\tif (!pio)\n\t\t\treturn -EINVAL;\n\n\t\tpin = pin_id % MAX_NB_GPIO_PER_BANK;\n\t\tmask = pin_to_mask(pin);\n\n\t\tif (config & PULL_UP && config & PULL_DOWN)\n\t\t\treturn -EINVAL;\n\n\t\tat91_mux_set_output(pio, mask, config & OUTPUT,\n\t\t\t\t    (config & OUTPUT_VAL) >> OUTPUT_VAL_SHIFT);\n\t\tat91_mux_set_pullup(pio, mask, config & PULL_UP);\n\t\tat91_mux_set_multidrive(pio, mask, config & MULTI_DRIVE);\n\t\tif (info->ops->set_deglitch)\n\t\t\tinfo->ops->set_deglitch(pio, mask, config & DEGLITCH);\n\t\tif (info->ops->set_debounce)\n\t\t\tinfo->ops->set_debounce(pio, mask, config & DEBOUNCE,\n\t\t\t\t(config & DEBOUNCE_VAL) >> DEBOUNCE_VAL_SHIFT);\n\t\tif (info->ops->set_pulldown)\n\t\t\tinfo->ops->set_pulldown(pio, mask, config & PULL_DOWN);\n\t\tif (info->ops->disable_schmitt_trig && config & DIS_SCHMIT)\n\t\t\tinfo->ops->disable_schmitt_trig(pio, mask);\n\t\tif (info->ops->set_drivestrength)\n\t\t\tinfo->ops->set_drivestrength(pio, pin,\n\t\t\t\t(config & DRIVE_STRENGTH)\n\t\t\t\t\t>> DRIVE_STRENGTH_SHIFT);\n\t\tif (info->ops->set_slewrate)\n\t\t\tinfo->ops->set_slewrate(pio, pin,\n\t\t\t\t(config & SLEWRATE) >> SLEWRATE_SHIFT);\n\n\t}  \n\n\treturn 0;\n}\n\n#define DBG_SHOW_FLAG(flag) do {\t\t\\\n\tif (config & flag) {\t\t\t\\\n\t\tif (num_conf)\t\t\t\\\n\t\t\tseq_puts(s, \"|\");\t\\\n\t\tseq_puts(s, #flag);\t\t\\\n\t\tnum_conf++;\t\t\t\\\n\t}\t\t\t\t\t\\\n} while (0)\n\n#define DBG_SHOW_FLAG_MASKED(mask, flag, name) do { \\\n\tif ((config & mask) == flag) {\t\t\\\n\t\tif (num_conf)\t\t\t\\\n\t\t\tseq_puts(s, \"|\");\t\\\n\t\tseq_puts(s, #name);\t\t\\\n\t\tnum_conf++;\t\t\t\\\n\t}\t\t\t\t\t\\\n} while (0)\n\nstatic void at91_pinconf_dbg_show(struct pinctrl_dev *pctldev,\n\t\t\t\t   struct seq_file *s, unsigned pin_id)\n{\n\tunsigned long config;\n\tint val, num_conf = 0;\n\n\tat91_pinconf_get(pctldev, pin_id, &config);\n\n\tDBG_SHOW_FLAG(MULTI_DRIVE);\n\tDBG_SHOW_FLAG(PULL_UP);\n\tDBG_SHOW_FLAG(PULL_DOWN);\n\tDBG_SHOW_FLAG(DIS_SCHMIT);\n\tDBG_SHOW_FLAG(DEGLITCH);\n\tDBG_SHOW_FLAG_MASKED(DRIVE_STRENGTH, DRIVE_STRENGTH_BIT_MSK(LOW),\n\t\t\t     DRIVE_STRENGTH_LOW);\n\tDBG_SHOW_FLAG_MASKED(DRIVE_STRENGTH, DRIVE_STRENGTH_BIT_MSK(MED),\n\t\t\t     DRIVE_STRENGTH_MED);\n\tDBG_SHOW_FLAG_MASKED(DRIVE_STRENGTH, DRIVE_STRENGTH_BIT_MSK(HI),\n\t\t\t     DRIVE_STRENGTH_HI);\n\tDBG_SHOW_FLAG(SLEWRATE);\n\tDBG_SHOW_FLAG(DEBOUNCE);\n\tif (config & DEBOUNCE) {\n\t\tval = config >> DEBOUNCE_VAL_SHIFT;\n\t\tseq_printf(s, \"(%d)\", val);\n\t}\n\n\treturn;\n}\n\nstatic void at91_pinconf_group_dbg_show(struct pinctrl_dev *pctldev,\n\t\t\t\t\t struct seq_file *s, unsigned group)\n{\n}\n\nstatic const struct pinconf_ops at91_pinconf_ops = {\n\t.pin_config_get\t\t\t= at91_pinconf_get,\n\t.pin_config_set\t\t\t= at91_pinconf_set,\n\t.pin_config_dbg_show\t\t= at91_pinconf_dbg_show,\n\t.pin_config_group_dbg_show\t= at91_pinconf_group_dbg_show,\n};\n\nstatic struct pinctrl_desc at91_pinctrl_desc = {\n\t.pctlops\t= &at91_pctrl_ops,\n\t.pmxops\t\t= &at91_pmx_ops,\n\t.confops\t= &at91_pinconf_ops,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic const char *gpio_compat = \"atmel,at91rm9200-gpio\";\n\nstatic void at91_pinctrl_child_count(struct at91_pinctrl *info,\n\t\t\t\t     struct device_node *np)\n{\n\tstruct device_node *child;\n\n\tfor_each_child_of_node(np, child) {\n\t\tif (of_device_is_compatible(child, gpio_compat)) {\n\t\t\tif (of_device_is_available(child))\n\t\t\t\tinfo->nactive_banks++;\n\t\t} else {\n\t\t\tinfo->nfunctions++;\n\t\t\tinfo->ngroups += of_get_child_count(child);\n\t\t}\n\t}\n}\n\nstatic int at91_pinctrl_mux_mask(struct at91_pinctrl *info,\n\t\t\t\t struct device_node *np)\n{\n\tint ret = 0;\n\tint size;\n\tconst __be32 *list;\n\n\tlist = of_get_property(np, \"atmel,mux-mask\", &size);\n\tif (!list) {\n\t\tdev_err(info->dev, \"can not read the mux-mask of %d\\n\", size);\n\t\treturn -EINVAL;\n\t}\n\n\tsize /= sizeof(*list);\n\tif (!size || size % gpio_banks) {\n\t\tdev_err(info->dev, \"wrong mux mask array should be by %d\\n\", gpio_banks);\n\t\treturn -EINVAL;\n\t}\n\tinfo->nmux = size / gpio_banks;\n\n\tinfo->mux_mask = devm_kcalloc(info->dev, size, sizeof(u32),\n\t\t\t\t      GFP_KERNEL);\n\tif (!info->mux_mask)\n\t\treturn -ENOMEM;\n\n\tret = of_property_read_u32_array(np, \"atmel,mux-mask\",\n\t\t\t\t\t  info->mux_mask, size);\n\tif (ret)\n\t\tdev_err(info->dev, \"can not read the mux-mask of %d\\n\", size);\n\treturn ret;\n}\n\nstatic int at91_pinctrl_parse_groups(struct device_node *np,\n\t\t\t\t     struct at91_pin_group *grp,\n\t\t\t\t     struct at91_pinctrl *info, u32 index)\n{\n\tstruct at91_pmx_pin *pin;\n\tint size;\n\tconst __be32 *list;\n\tint i, j;\n\n\tdev_dbg(info->dev, \"group(%d): %pOFn\\n\", index, np);\n\n\t \n\tgrp->name = np->name;\n\n\t \n\tlist = of_get_property(np, \"atmel,pins\", &size);\n\t \n\tsize /= sizeof(*list);\n\tif (!size || size % 4) {\n\t\tdev_err(info->dev, \"wrong pins number or pins and configs should be by 4\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tgrp->npins = size / 4;\n\tpin = grp->pins_conf = devm_kcalloc(info->dev,\n\t\t\t\t\t    grp->npins,\n\t\t\t\t\t    sizeof(struct at91_pmx_pin),\n\t\t\t\t\t    GFP_KERNEL);\n\tgrp->pins = devm_kcalloc(info->dev, grp->npins, sizeof(unsigned int),\n\t\t\t\t GFP_KERNEL);\n\tif (!grp->pins_conf || !grp->pins)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0, j = 0; i < size; i += 4, j++) {\n\t\tpin->bank = be32_to_cpu(*list++);\n\t\tpin->pin = be32_to_cpu(*list++);\n\t\tgrp->pins[j] = pin->bank * MAX_NB_GPIO_PER_BANK + pin->pin;\n\t\tpin->mux = be32_to_cpu(*list++);\n\t\tpin->conf = be32_to_cpu(*list++);\n\n\t\tat91_pin_dbg(info->dev, pin);\n\t\tpin++;\n\t}\n\n\treturn 0;\n}\n\nstatic int at91_pinctrl_parse_functions(struct device_node *np,\n\t\t\t\t\tstruct at91_pinctrl *info, u32 index)\n{\n\tstruct device_node *child;\n\tstruct at91_pmx_func *func;\n\tstruct at91_pin_group *grp;\n\tint ret;\n\tstatic u32 grp_index;\n\tu32 i = 0;\n\n\tdev_dbg(info->dev, \"parse function(%d): %pOFn\\n\", index, np);\n\n\tfunc = &info->functions[index];\n\n\t \n\tfunc->name = np->name;\n\tfunc->ngroups = of_get_child_count(np);\n\tif (func->ngroups == 0) {\n\t\tdev_err(info->dev, \"no groups defined\\n\");\n\t\treturn -EINVAL;\n\t}\n\tfunc->groups = devm_kcalloc(info->dev,\n\t\t\tfunc->ngroups, sizeof(char *), GFP_KERNEL);\n\tif (!func->groups)\n\t\treturn -ENOMEM;\n\n\tfor_each_child_of_node(np, child) {\n\t\tfunc->groups[i] = child->name;\n\t\tgrp = &info->groups[grp_index++];\n\t\tret = at91_pinctrl_parse_groups(child, grp, info, i++);\n\t\tif (ret) {\n\t\t\tof_node_put(child);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id at91_pinctrl_of_match[] = {\n\t{ .compatible = \"atmel,sama5d3-pinctrl\", .data = &sama5d3_ops },\n\t{ .compatible = \"atmel,at91sam9x5-pinctrl\", .data = &at91sam9x5_ops },\n\t{ .compatible = \"atmel,at91rm9200-pinctrl\", .data = &at91rm9200_ops },\n\t{ .compatible = \"microchip,sam9x60-pinctrl\", .data = &sam9x60_ops },\n\t{   }\n};\n\nstatic int at91_pinctrl_probe_dt(struct platform_device *pdev,\n\t\t\t\t struct at91_pinctrl *info)\n{\n\tstruct device *dev = &pdev->dev;\n\tint ret = 0;\n\tint i, j, ngpio_chips_enabled = 0;\n\tuint32_t *tmp;\n\tstruct device_node *np = dev->of_node;\n\tstruct device_node *child;\n\n\tif (!np)\n\t\treturn -ENODEV;\n\n\tinfo->dev = dev;\n\tinfo->ops = of_device_get_match_data(dev);\n\tat91_pinctrl_child_count(info, np);\n\n\t \n\tfor (i = 0; i < MAX_GPIO_BANKS; i++)\n\t\tif (gpio_chips[i])\n\t\t\tngpio_chips_enabled++;\n\n\tif (ngpio_chips_enabled < info->nactive_banks)\n\t\treturn -EPROBE_DEFER;\n\n\tret = at91_pinctrl_mux_mask(info, np);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_dbg(dev, \"nmux = %d\\n\", info->nmux);\n\n\tdev_dbg(dev, \"mux-mask\\n\");\n\ttmp = info->mux_mask;\n\tfor (i = 0; i < gpio_banks; i++) {\n\t\tfor (j = 0; j < info->nmux; j++, tmp++) {\n\t\t\tdev_dbg(dev, \"%d:%d\\t0x%x\\n\", i, j, tmp[0]);\n\t\t}\n\t}\n\n\tdev_dbg(dev, \"nfunctions = %d\\n\", info->nfunctions);\n\tdev_dbg(dev, \"ngroups = %d\\n\", info->ngroups);\n\tinfo->functions = devm_kcalloc(dev, info->nfunctions, sizeof(*info->functions),\n\t\t\t\t       GFP_KERNEL);\n\tif (!info->functions)\n\t\treturn -ENOMEM;\n\n\tinfo->groups = devm_kcalloc(dev, info->ngroups, sizeof(*info->groups),\n\t\t\t\t    GFP_KERNEL);\n\tif (!info->groups)\n\t\treturn -ENOMEM;\n\n\tdev_dbg(dev, \"nbanks = %d\\n\", gpio_banks);\n\tdev_dbg(dev, \"nfunctions = %d\\n\", info->nfunctions);\n\tdev_dbg(dev, \"ngroups = %d\\n\", info->ngroups);\n\n\ti = 0;\n\n\tfor_each_child_of_node(np, child) {\n\t\tif (of_device_is_compatible(child, gpio_compat))\n\t\t\tcontinue;\n\t\tret = at91_pinctrl_parse_functions(child, info, i++);\n\t\tif (ret) {\n\t\t\tof_node_put(child);\n\t\t\treturn dev_err_probe(dev, ret, \"failed to parse function\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int at91_pinctrl_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct at91_pinctrl *info;\n\tstruct pinctrl_pin_desc *pdesc;\n\tint ret, i, j, k;\n\n\tinfo = devm_kzalloc(dev, sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tret = at91_pinctrl_probe_dt(pdev, info);\n\tif (ret)\n\t\treturn ret;\n\n\tat91_pinctrl_desc.name = dev_name(dev);\n\tat91_pinctrl_desc.npins = gpio_banks * MAX_NB_GPIO_PER_BANK;\n\tat91_pinctrl_desc.pins = pdesc =\n\t\tdevm_kcalloc(dev, at91_pinctrl_desc.npins, sizeof(*pdesc), GFP_KERNEL);\n\tif (!at91_pinctrl_desc.pins)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0, k = 0; i < gpio_banks; i++) {\n\t\tchar **names;\n\n\t\tnames = devm_kasprintf_strarray(dev, \"pio\", MAX_NB_GPIO_PER_BANK);\n\t\tif (IS_ERR(names))\n\t\t\treturn PTR_ERR(names);\n\n\t\tfor (j = 0; j < MAX_NB_GPIO_PER_BANK; j++, k++) {\n\t\t\tchar *name = names[j];\n\n\t\t\tstrreplace(name, '-', i + 'A');\n\n\t\t\tpdesc->number = k;\n\t\t\tpdesc->name = name;\n\t\t\tpdesc++;\n\t\t}\n\t}\n\n\tplatform_set_drvdata(pdev, info);\n\tinfo->pctl = devm_pinctrl_register(dev, &at91_pinctrl_desc, info);\n\tif (IS_ERR(info->pctl))\n\t\treturn dev_err_probe(dev, PTR_ERR(info->pctl), \"could not register AT91 pinctrl driver\\n\");\n\n\t \n\tfor (i = 0; i < gpio_banks; i++)\n\t\tif (gpio_chips[i])\n\t\t\tpinctrl_add_gpio_range(info->pctl, &gpio_chips[i]->range);\n\n\tdev_info(dev, \"initialized AT91 pinctrl driver\\n\");\n\n\treturn 0;\n}\n\nstatic int at91_gpio_get_direction(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct at91_gpio_chip *at91_gpio = gpiochip_get_data(chip);\n\tvoid __iomem *pio = at91_gpio->regbase;\n\tunsigned mask = 1 << offset;\n\tu32 osr;\n\n\tosr = readl_relaxed(pio + PIO_OSR);\n\tif (osr & mask)\n\t\treturn GPIO_LINE_DIRECTION_OUT;\n\n\treturn GPIO_LINE_DIRECTION_IN;\n}\n\nstatic int at91_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct at91_gpio_chip *at91_gpio = gpiochip_get_data(chip);\n\tvoid __iomem *pio = at91_gpio->regbase;\n\tunsigned mask = 1 << offset;\n\n\twritel_relaxed(mask, pio + PIO_ODR);\n\treturn 0;\n}\n\nstatic int at91_gpio_get(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct at91_gpio_chip *at91_gpio = gpiochip_get_data(chip);\n\tvoid __iomem *pio = at91_gpio->regbase;\n\tunsigned mask = 1 << offset;\n\tu32 pdsr;\n\n\tpdsr = readl_relaxed(pio + PIO_PDSR);\n\treturn (pdsr & mask) != 0;\n}\n\nstatic void at91_gpio_set(struct gpio_chip *chip, unsigned offset,\n\t\t\t\tint val)\n{\n\tstruct at91_gpio_chip *at91_gpio = gpiochip_get_data(chip);\n\tvoid __iomem *pio = at91_gpio->regbase;\n\tunsigned mask = 1 << offset;\n\n\twritel_relaxed(mask, pio + (val ? PIO_SODR : PIO_CODR));\n}\n\nstatic void at91_gpio_set_multiple(struct gpio_chip *chip,\n\t\t\t\t      unsigned long *mask, unsigned long *bits)\n{\n\tstruct at91_gpio_chip *at91_gpio = gpiochip_get_data(chip);\n\tvoid __iomem *pio = at91_gpio->regbase;\n\n#define BITS_MASK(bits) (((bits) == 32) ? ~0U : (BIT(bits) - 1))\n\t \n\tuint32_t set_mask = (*mask & *bits) & BITS_MASK(chip->ngpio);\n\tuint32_t clear_mask = (*mask & ~(*bits)) & BITS_MASK(chip->ngpio);\n\n\twritel_relaxed(set_mask, pio + PIO_SODR);\n\twritel_relaxed(clear_mask, pio + PIO_CODR);\n}\n\nstatic int at91_gpio_direction_output(struct gpio_chip *chip, unsigned offset,\n\t\t\t\tint val)\n{\n\tstruct at91_gpio_chip *at91_gpio = gpiochip_get_data(chip);\n\tvoid __iomem *pio = at91_gpio->regbase;\n\tunsigned mask = 1 << offset;\n\n\twritel_relaxed(mask, pio + (val ? PIO_SODR : PIO_CODR));\n\twritel_relaxed(mask, pio + PIO_OER);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic void at91_gpio_dbg_show(struct seq_file *s, struct gpio_chip *chip)\n{\n\tenum at91_mux mode;\n\tint i;\n\tstruct at91_gpio_chip *at91_gpio = gpiochip_get_data(chip);\n\tvoid __iomem *pio = at91_gpio->regbase;\n\tconst char *gpio_label;\n\n\tfor_each_requested_gpio(chip, i, gpio_label) {\n\t\tunsigned mask = pin_to_mask(i);\n\n\t\tmode = at91_gpio->ops->get_periph(pio, mask);\n\t\tseq_printf(s, \"[%s] GPIO%s%d: \",\n\t\t\t   gpio_label, chip->label, i);\n\t\tif (mode == AT91_MUX_GPIO) {\n\t\t\tseq_printf(s, \"[gpio] \");\n\t\t\tseq_printf(s, \"%s \",\n\t\t\t\t      readl_relaxed(pio + PIO_OSR) & mask ?\n\t\t\t\t      \"output\" : \"input\");\n\t\t\tseq_printf(s, \"%s\\n\",\n\t\t\t\t      readl_relaxed(pio + PIO_PDSR) & mask ?\n\t\t\t\t      \"set\" : \"clear\");\n\t\t} else {\n\t\t\tseq_printf(s, \"[periph %c]\\n\",\n\t\t\t\t   mode + 'A' - 1);\n\t\t}\n\t}\n}\n#else\n#define at91_gpio_dbg_show\tNULL\n#endif\n\nstatic int gpio_irq_request_resources(struct irq_data *d)\n{\n\tstruct at91_gpio_chip *at91_gpio = irq_data_get_irq_chip_data(d);\n\n\treturn gpiochip_lock_as_irq(&at91_gpio->chip, irqd_to_hwirq(d));\n}\n\nstatic void gpio_irq_release_resources(struct irq_data *d)\n{\n\tstruct at91_gpio_chip *at91_gpio = irq_data_get_irq_chip_data(d);\n\n\tgpiochip_unlock_as_irq(&at91_gpio->chip, irqd_to_hwirq(d));\n}\n\n \n\nstatic void gpio_irq_mask(struct irq_data *d)\n{\n\tstruct at91_gpio_chip *at91_gpio = irq_data_get_irq_chip_data(d);\n\tvoid __iomem\t*pio = at91_gpio->regbase;\n\tunsigned\tmask = 1 << d->hwirq;\n\tunsigned        gpio = irqd_to_hwirq(d);\n\n\tgpiochip_disable_irq(&at91_gpio->chip, gpio);\n\n\tif (pio)\n\t\twritel_relaxed(mask, pio + PIO_IDR);\n}\n\nstatic void gpio_irq_unmask(struct irq_data *d)\n{\n\tstruct at91_gpio_chip *at91_gpio = irq_data_get_irq_chip_data(d);\n\tvoid __iomem\t*pio = at91_gpio->regbase;\n\tunsigned\tmask = 1 << d->hwirq;\n\tunsigned        gpio = irqd_to_hwirq(d);\n\n\tgpiochip_enable_irq(&at91_gpio->chip, gpio);\n\n\tif (pio)\n\t\twritel_relaxed(mask, pio + PIO_IER);\n}\n\nstatic int gpio_irq_type(struct irq_data *d, unsigned type)\n{\n\tswitch (type) {\n\tcase IRQ_TYPE_NONE:\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n \nstatic int alt_gpio_irq_type(struct irq_data *d, unsigned type)\n{\n\tstruct at91_gpio_chip *at91_gpio = irq_data_get_irq_chip_data(d);\n\tvoid __iomem\t*pio = at91_gpio->regbase;\n\tunsigned\tmask = 1 << d->hwirq;\n\n\tswitch (type) {\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tirq_set_handler_locked(d, handle_simple_irq);\n\t\twritel_relaxed(mask, pio + PIO_ESR);\n\t\twritel_relaxed(mask, pio + PIO_REHLSR);\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tirq_set_handler_locked(d, handle_simple_irq);\n\t\twritel_relaxed(mask, pio + PIO_ESR);\n\t\twritel_relaxed(mask, pio + PIO_FELLSR);\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tirq_set_handler_locked(d, handle_level_irq);\n\t\twritel_relaxed(mask, pio + PIO_LSR);\n\t\twritel_relaxed(mask, pio + PIO_FELLSR);\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tirq_set_handler_locked(d, handle_level_irq);\n\t\twritel_relaxed(mask, pio + PIO_LSR);\n\t\twritel_relaxed(mask, pio + PIO_REHLSR);\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\t \n\t\tirq_set_handler_locked(d, handle_simple_irq);\n\t\twritel_relaxed(mask, pio + PIO_AIMDR);\n\t\treturn 0;\n\tcase IRQ_TYPE_NONE:\n\tdefault:\n\t\tpr_warn(\"AT91: No type for GPIO irq offset %d\\n\", d->irq);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\twritel_relaxed(mask, pio + PIO_AIMER);\n\n\treturn 0;\n}\n\nstatic void gpio_irq_ack(struct irq_data *d)\n{\n\t \n}\n\nstatic int gpio_irq_set_wake(struct irq_data *d, unsigned state)\n{\n\tstruct at91_gpio_chip *at91_gpio = irq_data_get_irq_chip_data(d);\n\tunsigned mask = 1 << d->hwirq;\n\n\tif (state)\n\t\tat91_gpio->wakeups |= mask;\n\telse\n\t\tat91_gpio->wakeups &= ~mask;\n\n\tirq_set_irq_wake(at91_gpio->pioc_virq, state);\n\n\treturn 0;\n}\n\nstatic int at91_gpio_suspend(struct device *dev)\n{\n\tstruct at91_gpio_chip *at91_chip = dev_get_drvdata(dev);\n\tvoid __iomem *pio = at91_chip->regbase;\n\n\tat91_chip->backups = readl_relaxed(pio + PIO_IMR);\n\twritel_relaxed(at91_chip->backups, pio + PIO_IDR);\n\twritel_relaxed(at91_chip->wakeups, pio + PIO_IER);\n\n\tif (!at91_chip->wakeups)\n\t\tclk_disable_unprepare(at91_chip->clock);\n\telse\n\t\tdev_dbg(dev, \"GPIO-%c may wake for %08x\\n\",\n\t\t\t'A' + at91_chip->id, at91_chip->wakeups);\n\n\treturn 0;\n}\n\nstatic int at91_gpio_resume(struct device *dev)\n{\n\tstruct at91_gpio_chip *at91_chip = dev_get_drvdata(dev);\n\tvoid __iomem *pio = at91_chip->regbase;\n\n\tif (!at91_chip->wakeups)\n\t\tclk_prepare_enable(at91_chip->clock);\n\n\twritel_relaxed(at91_chip->wakeups, pio + PIO_IDR);\n\twritel_relaxed(at91_chip->backups, pio + PIO_IER);\n\n\treturn 0;\n}\n\nstatic void gpio_irq_handler(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tstruct gpio_chip *gpio_chip = irq_desc_get_handler_data(desc);\n\tstruct at91_gpio_chip *at91_gpio = gpiochip_get_data(gpio_chip);\n\tvoid __iomem\t*pio = at91_gpio->regbase;\n\tunsigned long\tisr;\n\tint\t\tn;\n\n\tchained_irq_enter(chip, desc);\n\tfor (;;) {\n\t\t \n\t\tisr = readl_relaxed(pio + PIO_ISR) & readl_relaxed(pio + PIO_IMR);\n\t\tif (!isr) {\n\t\t\tif (!at91_gpio->next)\n\t\t\t\tbreak;\n\t\t\tat91_gpio = at91_gpio->next;\n\t\t\tpio = at91_gpio->regbase;\n\t\t\tgpio_chip = &at91_gpio->chip;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor_each_set_bit(n, &isr, BITS_PER_LONG)\n\t\t\tgeneric_handle_domain_irq(gpio_chip->irq.domain, n);\n\t}\n\tchained_irq_exit(chip, desc);\n\t \n}\n\nstatic int at91_gpio_of_irq_setup(struct platform_device *pdev,\n\t\t\t\t  struct at91_gpio_chip *at91_gpio)\n{\n\tstruct device\t\t*dev = &pdev->dev;\n\tstruct gpio_chip\t*gpiochip_prev = NULL;\n\tstruct at91_gpio_chip   *prev = NULL;\n\tstruct irq_data\t\t*d = irq_get_irq_data(at91_gpio->pioc_virq);\n\tstruct irq_chip\t\t*gpio_irqchip;\n\tstruct gpio_irq_chip\t*girq;\n\tint i;\n\n\tgpio_irqchip = devm_kzalloc(dev, sizeof(*gpio_irqchip), GFP_KERNEL);\n\tif (!gpio_irqchip)\n\t\treturn -ENOMEM;\n\n\tat91_gpio->pioc_hwirq = irqd_to_hwirq(d);\n\n\tgpio_irqchip->name = \"GPIO\";\n\tgpio_irqchip->irq_request_resources = gpio_irq_request_resources;\n\tgpio_irqchip->irq_release_resources = gpio_irq_release_resources;\n\tgpio_irqchip->irq_ack = gpio_irq_ack;\n\tgpio_irqchip->irq_disable = gpio_irq_mask;\n\tgpio_irqchip->irq_mask = gpio_irq_mask;\n\tgpio_irqchip->irq_unmask = gpio_irq_unmask;\n\tgpio_irqchip->irq_set_wake = pm_ptr(gpio_irq_set_wake);\n\tgpio_irqchip->irq_set_type = at91_gpio->ops->irq_type;\n\tgpio_irqchip->flags = IRQCHIP_IMMUTABLE;\n\n\t \n\twritel_relaxed(~0, at91_gpio->regbase + PIO_IDR);\n\n\t \n\tgirq = &at91_gpio->chip.irq;\n\tgpio_irq_chip_set_chip(girq, gpio_irqchip);\n\tgirq->default_type = IRQ_TYPE_NONE;\n\tgirq->handler = handle_edge_irq;\n\n\t \n\tgpiochip_prev = irq_get_handler_data(at91_gpio->pioc_virq);\n\tif (!gpiochip_prev) {\n\t\tgirq->parent_handler = gpio_irq_handler;\n\t\tgirq->num_parents = 1;\n\t\tgirq->parents = devm_kcalloc(dev, girq->num_parents,\n\t\t\t\t\t     sizeof(*girq->parents),\n\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!girq->parents)\n\t\t\treturn -ENOMEM;\n\t\tgirq->parents[0] = at91_gpio->pioc_virq;\n\t\treturn 0;\n\t}\n\n\tprev = gpiochip_get_data(gpiochip_prev);\n\t \n\tfor (i = 0; i < 2; i++) {\n\t\tif (prev->next) {\n\t\t\tprev = prev->next;\n\t\t} else {\n\t\t\tprev->next = at91_gpio;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\n \nstatic const struct gpio_chip at91_gpio_template = {\n\t.request\t\t= gpiochip_generic_request,\n\t.free\t\t\t= gpiochip_generic_free,\n\t.get_direction\t\t= at91_gpio_get_direction,\n\t.direction_input\t= at91_gpio_direction_input,\n\t.get\t\t\t= at91_gpio_get,\n\t.direction_output\t= at91_gpio_direction_output,\n\t.set\t\t\t= at91_gpio_set,\n\t.set_multiple\t\t= at91_gpio_set_multiple,\n\t.dbg_show\t\t= at91_gpio_dbg_show,\n\t.can_sleep\t\t= false,\n\t.ngpio\t\t\t= MAX_NB_GPIO_PER_BANK,\n};\n\nstatic const struct of_device_id at91_gpio_of_match[] = {\n\t{ .compatible = \"atmel,at91sam9x5-gpio\", .data = &at91sam9x5_ops, },\n\t{ .compatible = \"atmel,at91rm9200-gpio\", .data = &at91rm9200_ops },\n\t{ .compatible = \"microchip,sam9x60-gpio\", .data = &sam9x60_ops },\n\t{   }\n};\n\nstatic int at91_gpio_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct at91_gpio_chip *at91_chip = NULL;\n\tstruct gpio_chip *chip;\n\tstruct pinctrl_gpio_range *range;\n\tint ret = 0;\n\tint irq, i;\n\tint alias_idx = of_alias_get_id(np, \"gpio\");\n\tuint32_t ngpio;\n\tchar **names;\n\n\tBUG_ON(alias_idx >= ARRAY_SIZE(gpio_chips));\n\tif (gpio_chips[alias_idx])\n\t\treturn dev_err_probe(dev, -EBUSY, \"%d slot is occupied.\\n\", alias_idx);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tat91_chip = devm_kzalloc(dev, sizeof(*at91_chip), GFP_KERNEL);\n\tif (!at91_chip)\n\t\treturn -ENOMEM;\n\n\tat91_chip->regbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(at91_chip->regbase))\n\t\treturn PTR_ERR(at91_chip->regbase);\n\n\tat91_chip->ops = of_device_get_match_data(dev);\n\tat91_chip->pioc_virq = irq;\n\n\tat91_chip->clock = devm_clk_get_enabled(dev, NULL);\n\tif (IS_ERR(at91_chip->clock))\n\t\treturn dev_err_probe(dev, PTR_ERR(at91_chip->clock), \"failed to get clock, ignoring.\\n\");\n\n\tat91_chip->chip = at91_gpio_template;\n\tat91_chip->id = alias_idx;\n\n\tchip = &at91_chip->chip;\n\tchip->label = dev_name(dev);\n\tchip->parent = dev;\n\tchip->owner = THIS_MODULE;\n\tchip->base = alias_idx * MAX_NB_GPIO_PER_BANK;\n\n\tif (!of_property_read_u32(np, \"#gpio-lines\", &ngpio)) {\n\t\tif (ngpio >= MAX_NB_GPIO_PER_BANK)\n\t\t\tdev_err(dev, \"at91_gpio.%d, gpio-nb >= %d failback to %d\\n\",\n\t\t\t\talias_idx, MAX_NB_GPIO_PER_BANK, MAX_NB_GPIO_PER_BANK);\n\t\telse\n\t\t\tchip->ngpio = ngpio;\n\t}\n\n\tnames = devm_kasprintf_strarray(dev, \"pio\", chip->ngpio);\n\tif (IS_ERR(names))\n\t\treturn PTR_ERR(names);\n\n\tfor (i = 0; i < chip->ngpio; i++)\n\t\tstrreplace(names[i], '-', alias_idx + 'A');\n\n\tchip->names = (const char *const *)names;\n\n\trange = &at91_chip->range;\n\trange->name = chip->label;\n\trange->id = alias_idx;\n\trange->pin_base = range->base = range->id * MAX_NB_GPIO_PER_BANK;\n\n\trange->npins = chip->ngpio;\n\trange->gc = chip;\n\n\tret = at91_gpio_of_irq_setup(pdev, at91_chip);\n\tif (ret)\n\t\treturn ret;\n\n\tret = gpiochip_add_data(chip, at91_chip);\n\tif (ret)\n\t\treturn ret;\n\n\tgpio_chips[alias_idx] = at91_chip;\n\tplatform_set_drvdata(pdev, at91_chip);\n\tgpio_banks = max(gpio_banks, alias_idx + 1);\n\n\tdev_info(dev, \"at address %p\\n\", at91_chip->regbase);\n\n\treturn 0;\n}\n\nstatic DEFINE_NOIRQ_DEV_PM_OPS(at91_gpio_pm_ops, at91_gpio_suspend, at91_gpio_resume);\n\nstatic struct platform_driver at91_gpio_driver = {\n\t.driver = {\n\t\t.name = \"gpio-at91\",\n\t\t.of_match_table = at91_gpio_of_match,\n\t\t.pm = pm_sleep_ptr(&at91_gpio_pm_ops),\n\t},\n\t.probe = at91_gpio_probe,\n};\n\nstatic struct platform_driver at91_pinctrl_driver = {\n\t.driver = {\n\t\t.name = \"pinctrl-at91\",\n\t\t.of_match_table = at91_pinctrl_of_match,\n\t},\n\t.probe = at91_pinctrl_probe,\n};\n\nstatic struct platform_driver * const drivers[] = {\n\t&at91_gpio_driver,\n\t&at91_pinctrl_driver,\n};\n\nstatic int __init at91_pinctrl_init(void)\n{\n\treturn platform_register_drivers(drivers, ARRAY_SIZE(drivers));\n}\narch_initcall(at91_pinctrl_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}