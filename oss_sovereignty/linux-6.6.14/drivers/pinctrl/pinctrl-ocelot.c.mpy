{
  "module_name": "pinctrl-ocelot.c",
  "hash_id": "0ecd37857d4706814132f723985db57f183ef6f464e28d01cb1faa81ed6ddc41",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/pinctrl-ocelot.c",
  "human_readable_source": "\n \n\n#include <linux/gpio/driver.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/mfd/ocelot.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n#include <linux/slab.h>\n\n#include <linux/pinctrl/consumer.h>\n#include <linux/pinctrl/pinconf-generic.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinmux.h>\n\n#include \"core.h\"\n#include \"pinconf.h\"\n#include \"pinmux.h\"\n\n#define ocelot_clrsetbits(addr, clear, set) \\\n\twritel((readl(addr) & ~(clear)) | (set), (addr))\n\nenum {\n\tPINCONF_BIAS,\n\tPINCONF_SCHMITT,\n\tPINCONF_DRIVE_STRENGTH,\n};\n\n \n#define OCELOT_GPIO_OUT_SET\t0x0\n#define OCELOT_GPIO_OUT_CLR\t0x4\n#define OCELOT_GPIO_OUT\t\t0x8\n#define OCELOT_GPIO_IN\t\t0xc\n#define OCELOT_GPIO_OE\t\t0x10\n#define OCELOT_GPIO_INTR\t0x14\n#define OCELOT_GPIO_INTR_ENA\t0x18\n#define OCELOT_GPIO_INTR_IDENT\t0x1c\n#define OCELOT_GPIO_ALT0\t0x20\n#define OCELOT_GPIO_ALT1\t0x24\n#define OCELOT_GPIO_SD_MAP\t0x28\n\n#define OCELOT_FUNC_PER_PIN\t4\n\nenum {\n\tFUNC_CAN0_a,\n\tFUNC_CAN0_b,\n\tFUNC_CAN1,\n\tFUNC_CLKMON,\n\tFUNC_NONE,\n\tFUNC_FC0_a,\n\tFUNC_FC0_b,\n\tFUNC_FC0_c,\n\tFUNC_FC1_a,\n\tFUNC_FC1_b,\n\tFUNC_FC1_c,\n\tFUNC_FC2_a,\n\tFUNC_FC2_b,\n\tFUNC_FC3_a,\n\tFUNC_FC3_b,\n\tFUNC_FC3_c,\n\tFUNC_FC4_a,\n\tFUNC_FC4_b,\n\tFUNC_FC4_c,\n\tFUNC_FC_SHRD0,\n\tFUNC_FC_SHRD1,\n\tFUNC_FC_SHRD2,\n\tFUNC_FC_SHRD3,\n\tFUNC_FC_SHRD4,\n\tFUNC_FC_SHRD5,\n\tFUNC_FC_SHRD6,\n\tFUNC_FC_SHRD7,\n\tFUNC_FC_SHRD8,\n\tFUNC_FC_SHRD9,\n\tFUNC_FC_SHRD10,\n\tFUNC_FC_SHRD11,\n\tFUNC_FC_SHRD12,\n\tFUNC_FC_SHRD13,\n\tFUNC_FC_SHRD14,\n\tFUNC_FC_SHRD15,\n\tFUNC_FC_SHRD16,\n\tFUNC_FC_SHRD17,\n\tFUNC_FC_SHRD18,\n\tFUNC_FC_SHRD19,\n\tFUNC_FC_SHRD20,\n\tFUNC_GPIO,\n\tFUNC_IB_TRG_a,\n\tFUNC_IB_TRG_b,\n\tFUNC_IB_TRG_c,\n\tFUNC_IRQ0,\n\tFUNC_IRQ_IN_a,\n\tFUNC_IRQ_IN_b,\n\tFUNC_IRQ_IN_c,\n\tFUNC_IRQ0_IN,\n\tFUNC_IRQ_OUT_a,\n\tFUNC_IRQ_OUT_b,\n\tFUNC_IRQ_OUT_c,\n\tFUNC_IRQ0_OUT,\n\tFUNC_IRQ1,\n\tFUNC_IRQ1_IN,\n\tFUNC_IRQ1_OUT,\n\tFUNC_EXT_IRQ,\n\tFUNC_MIIM,\n\tFUNC_MIIM_a,\n\tFUNC_MIIM_b,\n\tFUNC_MIIM_c,\n\tFUNC_MIIM_Sa,\n\tFUNC_MIIM_Sb,\n\tFUNC_OB_TRG,\n\tFUNC_OB_TRG_a,\n\tFUNC_OB_TRG_b,\n\tFUNC_PHY_LED,\n\tFUNC_PCI_WAKE,\n\tFUNC_MD,\n\tFUNC_PTP0,\n\tFUNC_PTP1,\n\tFUNC_PTP2,\n\tFUNC_PTP3,\n\tFUNC_PTPSYNC_0,\n\tFUNC_PTPSYNC_1,\n\tFUNC_PTPSYNC_2,\n\tFUNC_PTPSYNC_3,\n\tFUNC_PTPSYNC_4,\n\tFUNC_PTPSYNC_5,\n\tFUNC_PTPSYNC_6,\n\tFUNC_PTPSYNC_7,\n\tFUNC_PWM,\n\tFUNC_PWM_a,\n\tFUNC_PWM_b,\n\tFUNC_QSPI1,\n\tFUNC_QSPI2,\n\tFUNC_R,\n\tFUNC_RECO_a,\n\tFUNC_RECO_b,\n\tFUNC_RECO_CLK,\n\tFUNC_SD,\n\tFUNC_SFP,\n\tFUNC_SFP_SD,\n\tFUNC_SG0,\n\tFUNC_SG1,\n\tFUNC_SG2,\n\tFUNC_SGPIO_a,\n\tFUNC_SGPIO_b,\n\tFUNC_SI,\n\tFUNC_SI2,\n\tFUNC_TACHO,\n\tFUNC_TACHO_a,\n\tFUNC_TACHO_b,\n\tFUNC_TWI,\n\tFUNC_TWI2,\n\tFUNC_TWI3,\n\tFUNC_TWI_SCL_M,\n\tFUNC_TWI_SLC_GATE,\n\tFUNC_TWI_SLC_GATE_AD,\n\tFUNC_UART,\n\tFUNC_UART2,\n\tFUNC_UART3,\n\tFUNC_USB_H_a,\n\tFUNC_USB_H_b,\n\tFUNC_USB_H_c,\n\tFUNC_USB_S_a,\n\tFUNC_USB_S_b,\n\tFUNC_USB_S_c,\n\tFUNC_PLL_STAT,\n\tFUNC_EMMC,\n\tFUNC_EMMC_SD,\n\tFUNC_REF_CLK,\n\tFUNC_RCVRD_CLK,\n\tFUNC_MAX\n};\n\nstatic const char *const ocelot_function_names[] = {\n\t[FUNC_CAN0_a]\t\t= \"can0_a\",\n\t[FUNC_CAN0_b]\t\t= \"can0_b\",\n\t[FUNC_CAN1]\t\t= \"can1\",\n\t[FUNC_CLKMON]\t\t= \"clkmon\",\n\t[FUNC_NONE]\t\t= \"none\",\n\t[FUNC_FC0_a]\t\t= \"fc0_a\",\n\t[FUNC_FC0_b]\t\t= \"fc0_b\",\n\t[FUNC_FC0_c]\t\t= \"fc0_c\",\n\t[FUNC_FC1_a]\t\t= \"fc1_a\",\n\t[FUNC_FC1_b]\t\t= \"fc1_b\",\n\t[FUNC_FC1_c]\t\t= \"fc1_c\",\n\t[FUNC_FC2_a]\t\t= \"fc2_a\",\n\t[FUNC_FC2_b]\t\t= \"fc2_b\",\n\t[FUNC_FC3_a]\t\t= \"fc3_a\",\n\t[FUNC_FC3_b]\t\t= \"fc3_b\",\n\t[FUNC_FC3_c]\t\t= \"fc3_c\",\n\t[FUNC_FC4_a]\t\t= \"fc4_a\",\n\t[FUNC_FC4_b]\t\t= \"fc4_b\",\n\t[FUNC_FC4_c]\t\t= \"fc4_c\",\n\t[FUNC_FC_SHRD0]\t\t= \"fc_shrd0\",\n\t[FUNC_FC_SHRD1]\t\t= \"fc_shrd1\",\n\t[FUNC_FC_SHRD2]\t\t= \"fc_shrd2\",\n\t[FUNC_FC_SHRD3]\t\t= \"fc_shrd3\",\n\t[FUNC_FC_SHRD4]\t\t= \"fc_shrd4\",\n\t[FUNC_FC_SHRD5]\t\t= \"fc_shrd5\",\n\t[FUNC_FC_SHRD6]\t\t= \"fc_shrd6\",\n\t[FUNC_FC_SHRD7]\t\t= \"fc_shrd7\",\n\t[FUNC_FC_SHRD8]\t\t= \"fc_shrd8\",\n\t[FUNC_FC_SHRD9]\t\t= \"fc_shrd9\",\n\t[FUNC_FC_SHRD10]\t= \"fc_shrd10\",\n\t[FUNC_FC_SHRD11]\t= \"fc_shrd11\",\n\t[FUNC_FC_SHRD12]\t= \"fc_shrd12\",\n\t[FUNC_FC_SHRD13]\t= \"fc_shrd13\",\n\t[FUNC_FC_SHRD14]\t= \"fc_shrd14\",\n\t[FUNC_FC_SHRD15]\t= \"fc_shrd15\",\n\t[FUNC_FC_SHRD16]\t= \"fc_shrd16\",\n\t[FUNC_FC_SHRD17]\t= \"fc_shrd17\",\n\t[FUNC_FC_SHRD18]\t= \"fc_shrd18\",\n\t[FUNC_FC_SHRD19]\t= \"fc_shrd19\",\n\t[FUNC_FC_SHRD20]\t= \"fc_shrd20\",\n\t[FUNC_GPIO]\t\t= \"gpio\",\n\t[FUNC_IB_TRG_a]\t\t= \"ib_trig_a\",\n\t[FUNC_IB_TRG_b]\t\t= \"ib_trig_b\",\n\t[FUNC_IB_TRG_c]\t\t= \"ib_trig_c\",\n\t[FUNC_IRQ0]\t\t= \"irq0\",\n\t[FUNC_IRQ_IN_a]\t\t= \"irq_in_a\",\n\t[FUNC_IRQ_IN_b]\t\t= \"irq_in_b\",\n\t[FUNC_IRQ_IN_c]\t\t= \"irq_in_c\",\n\t[FUNC_IRQ0_IN]\t\t= \"irq0_in\",\n\t[FUNC_IRQ_OUT_a]\t= \"irq_out_a\",\n\t[FUNC_IRQ_OUT_b]\t= \"irq_out_b\",\n\t[FUNC_IRQ_OUT_c]\t= \"irq_out_c\",\n\t[FUNC_IRQ0_OUT]\t\t= \"irq0_out\",\n\t[FUNC_IRQ1]\t\t= \"irq1\",\n\t[FUNC_IRQ1_IN]\t\t= \"irq1_in\",\n\t[FUNC_IRQ1_OUT]\t\t= \"irq1_out\",\n\t[FUNC_EXT_IRQ]\t\t= \"ext_irq\",\n\t[FUNC_MIIM]\t\t= \"miim\",\n\t[FUNC_MIIM_a]\t\t= \"miim_a\",\n\t[FUNC_MIIM_b]\t\t= \"miim_b\",\n\t[FUNC_MIIM_c]\t\t= \"miim_c\",\n\t[FUNC_MIIM_Sa]\t\t= \"miim_slave_a\",\n\t[FUNC_MIIM_Sb]\t\t= \"miim_slave_b\",\n\t[FUNC_PHY_LED]\t\t= \"phy_led\",\n\t[FUNC_PCI_WAKE]\t\t= \"pci_wake\",\n\t[FUNC_MD]\t\t= \"md\",\n\t[FUNC_OB_TRG]\t\t= \"ob_trig\",\n\t[FUNC_OB_TRG_a]\t\t= \"ob_trig_a\",\n\t[FUNC_OB_TRG_b]\t\t= \"ob_trig_b\",\n\t[FUNC_PTP0]\t\t= \"ptp0\",\n\t[FUNC_PTP1]\t\t= \"ptp1\",\n\t[FUNC_PTP2]\t\t= \"ptp2\",\n\t[FUNC_PTP3]\t\t= \"ptp3\",\n\t[FUNC_PTPSYNC_0]\t= \"ptpsync_0\",\n\t[FUNC_PTPSYNC_1]\t= \"ptpsync_1\",\n\t[FUNC_PTPSYNC_2]\t= \"ptpsync_2\",\n\t[FUNC_PTPSYNC_3]\t= \"ptpsync_3\",\n\t[FUNC_PTPSYNC_4]\t= \"ptpsync_4\",\n\t[FUNC_PTPSYNC_5]\t= \"ptpsync_5\",\n\t[FUNC_PTPSYNC_6]\t= \"ptpsync_6\",\n\t[FUNC_PTPSYNC_7]\t= \"ptpsync_7\",\n\t[FUNC_PWM]\t\t= \"pwm\",\n\t[FUNC_PWM_a]\t\t= \"pwm_a\",\n\t[FUNC_PWM_b]\t\t= \"pwm_b\",\n\t[FUNC_QSPI1]\t\t= \"qspi1\",\n\t[FUNC_QSPI2]\t\t= \"qspi2\",\n\t[FUNC_R]\t\t= \"reserved\",\n\t[FUNC_RECO_a]\t\t= \"reco_a\",\n\t[FUNC_RECO_b]\t\t= \"reco_b\",\n\t[FUNC_RECO_CLK]\t\t= \"reco_clk\",\n\t[FUNC_SD]\t\t= \"sd\",\n\t[FUNC_SFP]\t\t= \"sfp\",\n\t[FUNC_SFP_SD]\t\t= \"sfp_sd\",\n\t[FUNC_SG0]\t\t= \"sg0\",\n\t[FUNC_SG1]\t\t= \"sg1\",\n\t[FUNC_SG2]\t\t= \"sg2\",\n\t[FUNC_SGPIO_a]\t\t= \"sgpio_a\",\n\t[FUNC_SGPIO_b]\t\t= \"sgpio_b\",\n\t[FUNC_SI]\t\t= \"si\",\n\t[FUNC_SI2]\t\t= \"si2\",\n\t[FUNC_TACHO]\t\t= \"tacho\",\n\t[FUNC_TACHO_a]\t\t= \"tacho_a\",\n\t[FUNC_TACHO_b]\t\t= \"tacho_b\",\n\t[FUNC_TWI]\t\t= \"twi\",\n\t[FUNC_TWI2]\t\t= \"twi2\",\n\t[FUNC_TWI3]\t\t= \"twi3\",\n\t[FUNC_TWI_SCL_M]\t= \"twi_scl_m\",\n\t[FUNC_TWI_SLC_GATE]\t= \"twi_slc_gate\",\n\t[FUNC_TWI_SLC_GATE_AD]\t= \"twi_slc_gate_ad\",\n\t[FUNC_USB_H_a]\t\t= \"usb_host_a\",\n\t[FUNC_USB_H_b]\t\t= \"usb_host_b\",\n\t[FUNC_USB_H_c]\t\t= \"usb_host_c\",\n\t[FUNC_USB_S_a]\t\t= \"usb_slave_a\",\n\t[FUNC_USB_S_b]\t\t= \"usb_slave_b\",\n\t[FUNC_USB_S_c]\t\t= \"usb_slave_c\",\n\t[FUNC_UART]\t\t= \"uart\",\n\t[FUNC_UART2]\t\t= \"uart2\",\n\t[FUNC_UART3]\t\t= \"uart3\",\n\t[FUNC_PLL_STAT]\t\t= \"pll_stat\",\n\t[FUNC_EMMC]\t\t= \"emmc\",\n\t[FUNC_EMMC_SD]\t\t= \"emmc_sd\",\n\t[FUNC_REF_CLK]\t\t= \"ref_clk\",\n\t[FUNC_RCVRD_CLK]\t= \"rcvrd_clk\",\n};\n\nstruct ocelot_pmx_func {\n\tconst char **groups;\n\tunsigned int ngroups;\n};\n\nstruct ocelot_pin_caps {\n\tunsigned int pin;\n\tunsigned char functions[OCELOT_FUNC_PER_PIN];\n\tunsigned char a_functions[OCELOT_FUNC_PER_PIN];\t \n};\n\nstruct ocelot_pincfg_data {\n\tu8 pd_bit;\n\tu8 pu_bit;\n\tu8 drive_bits;\n\tu8 schmitt_bit;\n};\n\nstruct ocelot_pinctrl {\n\tstruct device *dev;\n\tstruct pinctrl_dev *pctl;\n\tstruct gpio_chip gpio_chip;\n\tstruct regmap *map;\n\tstruct regmap *pincfg;\n\tstruct pinctrl_desc *desc;\n\tconst struct ocelot_pincfg_data *pincfg_data;\n\tstruct ocelot_pmx_func func[FUNC_MAX];\n\tu8 stride;\n\tstruct workqueue_struct *wq;\n};\n\nstruct ocelot_match_data {\n\tstruct pinctrl_desc desc;\n\tstruct ocelot_pincfg_data pincfg_data;\n};\n\nstruct ocelot_irq_work {\n\tstruct work_struct irq_work;\n\tstruct irq_desc *irq_desc;\n};\n\n#define LUTON_P(p, f0, f1)\t\t\t\t\t\t\\\nstatic struct ocelot_pin_caps luton_pin_##p = {\t\t\t\t\\\n\t.pin = p,\t\t\t\t\t\t\t\\\n\t.functions = {\t\t\t\t\t\t\t\\\n\t\t\tFUNC_GPIO, FUNC_##f0, FUNC_##f1, FUNC_NONE,\t\\\n\t},\t\t\t\t\t\t\t\t\\\n}\n\nLUTON_P(0,  SG0,       NONE);\nLUTON_P(1,  SG0,       NONE);\nLUTON_P(2,  SG0,       NONE);\nLUTON_P(3,  SG0,       NONE);\nLUTON_P(4,  TACHO,     NONE);\nLUTON_P(5,  TWI,       PHY_LED);\nLUTON_P(6,  TWI,       PHY_LED);\nLUTON_P(7,  NONE,      PHY_LED);\nLUTON_P(8,  EXT_IRQ,   PHY_LED);\nLUTON_P(9,  EXT_IRQ,   PHY_LED);\nLUTON_P(10, SFP,       PHY_LED);\nLUTON_P(11, SFP,       PHY_LED);\nLUTON_P(12, SFP,       PHY_LED);\nLUTON_P(13, SFP,       PHY_LED);\nLUTON_P(14, SI,        PHY_LED);\nLUTON_P(15, SI,        PHY_LED);\nLUTON_P(16, SI,        PHY_LED);\nLUTON_P(17, SFP,       PHY_LED);\nLUTON_P(18, SFP,       PHY_LED);\nLUTON_P(19, SFP,       PHY_LED);\nLUTON_P(20, SFP,       PHY_LED);\nLUTON_P(21, SFP,       PHY_LED);\nLUTON_P(22, SFP,       PHY_LED);\nLUTON_P(23, SFP,       PHY_LED);\nLUTON_P(24, SFP,       PHY_LED);\nLUTON_P(25, SFP,       PHY_LED);\nLUTON_P(26, SFP,       PHY_LED);\nLUTON_P(27, SFP,       PHY_LED);\nLUTON_P(28, SFP,       PHY_LED);\nLUTON_P(29, PWM,       NONE);\nLUTON_P(30, UART,      NONE);\nLUTON_P(31, UART,      NONE);\n\n#define LUTON_PIN(n) {\t\t\t\t\t\t\\\n\t.number = n,\t\t\t\t\t\t\\\n\t.name = \"GPIO_\"#n,\t\t\t\t\t\\\n\t.drv_data = &luton_pin_##n\t\t\t\t\\\n}\n\nstatic const struct pinctrl_pin_desc luton_pins[] = {\n\tLUTON_PIN(0),\n\tLUTON_PIN(1),\n\tLUTON_PIN(2),\n\tLUTON_PIN(3),\n\tLUTON_PIN(4),\n\tLUTON_PIN(5),\n\tLUTON_PIN(6),\n\tLUTON_PIN(7),\n\tLUTON_PIN(8),\n\tLUTON_PIN(9),\n\tLUTON_PIN(10),\n\tLUTON_PIN(11),\n\tLUTON_PIN(12),\n\tLUTON_PIN(13),\n\tLUTON_PIN(14),\n\tLUTON_PIN(15),\n\tLUTON_PIN(16),\n\tLUTON_PIN(17),\n\tLUTON_PIN(18),\n\tLUTON_PIN(19),\n\tLUTON_PIN(20),\n\tLUTON_PIN(21),\n\tLUTON_PIN(22),\n\tLUTON_PIN(23),\n\tLUTON_PIN(24),\n\tLUTON_PIN(25),\n\tLUTON_PIN(26),\n\tLUTON_PIN(27),\n\tLUTON_PIN(28),\n\tLUTON_PIN(29),\n\tLUTON_PIN(30),\n\tLUTON_PIN(31),\n};\n\n#define SERVAL_P(p, f0, f1, f2)\t\t\t\t\t\t\\\nstatic struct ocelot_pin_caps serval_pin_##p = {\t\t\t\\\n\t.pin = p,\t\t\t\t\t\t\t\\\n\t.functions = {\t\t\t\t\t\t\t\\\n\t\t\tFUNC_GPIO, FUNC_##f0, FUNC_##f1, FUNC_##f2,\t\\\n\t},\t\t\t\t\t\t\t\t\\\n}\n\nSERVAL_P(0,  SG0,       NONE,      NONE);\nSERVAL_P(1,  SG0,       NONE,      NONE);\nSERVAL_P(2,  SG0,       NONE,      NONE);\nSERVAL_P(3,  SG0,       NONE,      NONE);\nSERVAL_P(4,  TACHO,     NONE,      NONE);\nSERVAL_P(5,  PWM,       NONE,      NONE);\nSERVAL_P(6,  TWI,       NONE,      NONE);\nSERVAL_P(7,  TWI,       NONE,      NONE);\nSERVAL_P(8,  SI,        NONE,      NONE);\nSERVAL_P(9,  SI,        MD,        NONE);\nSERVAL_P(10, SI,        MD,        NONE);\nSERVAL_P(11, SFP,       MD,        TWI_SCL_M);\nSERVAL_P(12, SFP,       MD,        TWI_SCL_M);\nSERVAL_P(13, SFP,       UART2,     TWI_SCL_M);\nSERVAL_P(14, SFP,       UART2,     TWI_SCL_M);\nSERVAL_P(15, SFP,       PTP0,      TWI_SCL_M);\nSERVAL_P(16, SFP,       PTP0,      TWI_SCL_M);\nSERVAL_P(17, SFP,       PCI_WAKE,  TWI_SCL_M);\nSERVAL_P(18, SFP,       NONE,      TWI_SCL_M);\nSERVAL_P(19, SFP,       NONE,      TWI_SCL_M);\nSERVAL_P(20, SFP,       NONE,      TWI_SCL_M);\nSERVAL_P(21, SFP,       NONE,      TWI_SCL_M);\nSERVAL_P(22, NONE,      NONE,      NONE);\nSERVAL_P(23, NONE,      NONE,      NONE);\nSERVAL_P(24, NONE,      NONE,      NONE);\nSERVAL_P(25, NONE,      NONE,      NONE);\nSERVAL_P(26, UART,      NONE,      NONE);\nSERVAL_P(27, UART,      NONE,      NONE);\nSERVAL_P(28, IRQ0,      NONE,      NONE);\nSERVAL_P(29, IRQ1,      NONE,      NONE);\nSERVAL_P(30, PTP0,      NONE,      NONE);\nSERVAL_P(31, PTP0,      NONE,      NONE);\n\n#define SERVAL_PIN(n) {\t\t\t\t\t\t\\\n\t.number = n,\t\t\t\t\t\t\\\n\t.name = \"GPIO_\"#n,\t\t\t\t\t\\\n\t.drv_data = &serval_pin_##n\t\t\t\t\\\n}\n\nstatic const struct pinctrl_pin_desc serval_pins[] = {\n\tSERVAL_PIN(0),\n\tSERVAL_PIN(1),\n\tSERVAL_PIN(2),\n\tSERVAL_PIN(3),\n\tSERVAL_PIN(4),\n\tSERVAL_PIN(5),\n\tSERVAL_PIN(6),\n\tSERVAL_PIN(7),\n\tSERVAL_PIN(8),\n\tSERVAL_PIN(9),\n\tSERVAL_PIN(10),\n\tSERVAL_PIN(11),\n\tSERVAL_PIN(12),\n\tSERVAL_PIN(13),\n\tSERVAL_PIN(14),\n\tSERVAL_PIN(15),\n\tSERVAL_PIN(16),\n\tSERVAL_PIN(17),\n\tSERVAL_PIN(18),\n\tSERVAL_PIN(19),\n\tSERVAL_PIN(20),\n\tSERVAL_PIN(21),\n\tSERVAL_PIN(22),\n\tSERVAL_PIN(23),\n\tSERVAL_PIN(24),\n\tSERVAL_PIN(25),\n\tSERVAL_PIN(26),\n\tSERVAL_PIN(27),\n\tSERVAL_PIN(28),\n\tSERVAL_PIN(29),\n\tSERVAL_PIN(30),\n\tSERVAL_PIN(31),\n};\n\n#define OCELOT_P(p, f0, f1, f2)\t\t\t\t\t\t\\\nstatic struct ocelot_pin_caps ocelot_pin_##p = {\t\t\t\\\n\t.pin = p,\t\t\t\t\t\t\t\\\n\t.functions = {\t\t\t\t\t\t\t\\\n\t\t\tFUNC_GPIO, FUNC_##f0, FUNC_##f1, FUNC_##f2,\t\\\n\t},\t\t\t\t\t\t\t\t\\\n}\n\nOCELOT_P(0,  SG0,       NONE,      NONE);\nOCELOT_P(1,  SG0,       NONE,      NONE);\nOCELOT_P(2,  SG0,       NONE,      NONE);\nOCELOT_P(3,  SG0,       NONE,      NONE);\nOCELOT_P(4,  IRQ0_IN,   IRQ0_OUT,  TWI_SCL_M);\nOCELOT_P(5,  IRQ1_IN,   IRQ1_OUT,  PCI_WAKE);\nOCELOT_P(6,  UART,      TWI_SCL_M, NONE);\nOCELOT_P(7,  UART,      TWI_SCL_M, NONE);\nOCELOT_P(8,  SI,        TWI_SCL_M, IRQ0_OUT);\nOCELOT_P(9,  SI,        TWI_SCL_M, IRQ1_OUT);\nOCELOT_P(10, PTP2,      TWI_SCL_M, SFP);\nOCELOT_P(11, PTP3,      TWI_SCL_M, SFP);\nOCELOT_P(12, UART2,     TWI_SCL_M, SFP);\nOCELOT_P(13, UART2,     TWI_SCL_M, SFP);\nOCELOT_P(14, MIIM,      TWI_SCL_M, SFP);\nOCELOT_P(15, MIIM,      TWI_SCL_M, SFP);\nOCELOT_P(16, TWI,       NONE,      SI);\nOCELOT_P(17, TWI,       TWI_SCL_M, SI);\nOCELOT_P(18, PTP0,      TWI_SCL_M, NONE);\nOCELOT_P(19, PTP1,      TWI_SCL_M, NONE);\nOCELOT_P(20, RECO_CLK,  TACHO,     TWI_SCL_M);\nOCELOT_P(21, RECO_CLK,  PWM,       TWI_SCL_M);\n\n#define OCELOT_PIN(n) {\t\t\t\t\t\t\\\n\t.number = n,\t\t\t\t\t\t\\\n\t.name = \"GPIO_\"#n,\t\t\t\t\t\\\n\t.drv_data = &ocelot_pin_##n\t\t\t\t\\\n}\n\nstatic const struct pinctrl_pin_desc ocelot_pins[] = {\n\tOCELOT_PIN(0),\n\tOCELOT_PIN(1),\n\tOCELOT_PIN(2),\n\tOCELOT_PIN(3),\n\tOCELOT_PIN(4),\n\tOCELOT_PIN(5),\n\tOCELOT_PIN(6),\n\tOCELOT_PIN(7),\n\tOCELOT_PIN(8),\n\tOCELOT_PIN(9),\n\tOCELOT_PIN(10),\n\tOCELOT_PIN(11),\n\tOCELOT_PIN(12),\n\tOCELOT_PIN(13),\n\tOCELOT_PIN(14),\n\tOCELOT_PIN(15),\n\tOCELOT_PIN(16),\n\tOCELOT_PIN(17),\n\tOCELOT_PIN(18),\n\tOCELOT_PIN(19),\n\tOCELOT_PIN(20),\n\tOCELOT_PIN(21),\n};\n\n#define JAGUAR2_P(p, f0, f1)\t\t\t\t\t\t\\\nstatic struct ocelot_pin_caps jaguar2_pin_##p = {\t\t\t\\\n\t.pin = p,\t\t\t\t\t\t\t\\\n\t.functions = {\t\t\t\t\t\t\t\\\n\t\t\tFUNC_GPIO, FUNC_##f0, FUNC_##f1, FUNC_NONE\t\\\n\t},\t\t\t\t\t\t\t\t\\\n}\n\nJAGUAR2_P(0,  SG0,       NONE);\nJAGUAR2_P(1,  SG0,       NONE);\nJAGUAR2_P(2,  SG0,       NONE);\nJAGUAR2_P(3,  SG0,       NONE);\nJAGUAR2_P(4,  SG1,       NONE);\nJAGUAR2_P(5,  SG1,       NONE);\nJAGUAR2_P(6,  IRQ0_IN,   IRQ0_OUT);\nJAGUAR2_P(7,  IRQ1_IN,   IRQ1_OUT);\nJAGUAR2_P(8,  PTP0,      NONE);\nJAGUAR2_P(9,  PTP1,      NONE);\nJAGUAR2_P(10, UART,      NONE);\nJAGUAR2_P(11, UART,      NONE);\nJAGUAR2_P(12, SG1,       NONE);\nJAGUAR2_P(13, SG1,       NONE);\nJAGUAR2_P(14, TWI,       TWI_SCL_M);\nJAGUAR2_P(15, TWI,       NONE);\nJAGUAR2_P(16, SI,        TWI_SCL_M);\nJAGUAR2_P(17, SI,        TWI_SCL_M);\nJAGUAR2_P(18, SI,        TWI_SCL_M);\nJAGUAR2_P(19, PCI_WAKE,  NONE);\nJAGUAR2_P(20, IRQ0_OUT,  TWI_SCL_M);\nJAGUAR2_P(21, IRQ1_OUT,  TWI_SCL_M);\nJAGUAR2_P(22, TACHO,     NONE);\nJAGUAR2_P(23, PWM,       NONE);\nJAGUAR2_P(24, UART2,     NONE);\nJAGUAR2_P(25, UART2,     SI);\nJAGUAR2_P(26, PTP2,      SI);\nJAGUAR2_P(27, PTP3,      SI);\nJAGUAR2_P(28, TWI2,      SI);\nJAGUAR2_P(29, TWI2,      SI);\nJAGUAR2_P(30, SG2,       SI);\nJAGUAR2_P(31, SG2,       SI);\nJAGUAR2_P(32, SG2,       SI);\nJAGUAR2_P(33, SG2,       SI);\nJAGUAR2_P(34, NONE,      TWI_SCL_M);\nJAGUAR2_P(35, NONE,      TWI_SCL_M);\nJAGUAR2_P(36, NONE,      TWI_SCL_M);\nJAGUAR2_P(37, NONE,      TWI_SCL_M);\nJAGUAR2_P(38, NONE,      TWI_SCL_M);\nJAGUAR2_P(39, NONE,      TWI_SCL_M);\nJAGUAR2_P(40, NONE,      TWI_SCL_M);\nJAGUAR2_P(41, NONE,      TWI_SCL_M);\nJAGUAR2_P(42, NONE,      TWI_SCL_M);\nJAGUAR2_P(43, NONE,      TWI_SCL_M);\nJAGUAR2_P(44, NONE,      SFP);\nJAGUAR2_P(45, NONE,      SFP);\nJAGUAR2_P(46, NONE,      SFP);\nJAGUAR2_P(47, NONE,      SFP);\nJAGUAR2_P(48, SFP,       NONE);\nJAGUAR2_P(49, SFP,       SI);\nJAGUAR2_P(50, SFP,       SI);\nJAGUAR2_P(51, SFP,       SI);\nJAGUAR2_P(52, SFP,       NONE);\nJAGUAR2_P(53, SFP,       NONE);\nJAGUAR2_P(54, SFP,       NONE);\nJAGUAR2_P(55, SFP,       NONE);\nJAGUAR2_P(56, MIIM,      SFP);\nJAGUAR2_P(57, MIIM,      SFP);\nJAGUAR2_P(58, MIIM,      SFP);\nJAGUAR2_P(59, MIIM,      SFP);\nJAGUAR2_P(60, NONE,      NONE);\nJAGUAR2_P(61, NONE,      NONE);\nJAGUAR2_P(62, NONE,      NONE);\nJAGUAR2_P(63, NONE,      NONE);\n\n#define JAGUAR2_PIN(n) {\t\t\t\t\t\\\n\t.number = n,\t\t\t\t\t\t\\\n\t.name = \"GPIO_\"#n,\t\t\t\t\t\\\n\t.drv_data = &jaguar2_pin_##n\t\t\t\t\\\n}\n\nstatic const struct pinctrl_pin_desc jaguar2_pins[] = {\n\tJAGUAR2_PIN(0),\n\tJAGUAR2_PIN(1),\n\tJAGUAR2_PIN(2),\n\tJAGUAR2_PIN(3),\n\tJAGUAR2_PIN(4),\n\tJAGUAR2_PIN(5),\n\tJAGUAR2_PIN(6),\n\tJAGUAR2_PIN(7),\n\tJAGUAR2_PIN(8),\n\tJAGUAR2_PIN(9),\n\tJAGUAR2_PIN(10),\n\tJAGUAR2_PIN(11),\n\tJAGUAR2_PIN(12),\n\tJAGUAR2_PIN(13),\n\tJAGUAR2_PIN(14),\n\tJAGUAR2_PIN(15),\n\tJAGUAR2_PIN(16),\n\tJAGUAR2_PIN(17),\n\tJAGUAR2_PIN(18),\n\tJAGUAR2_PIN(19),\n\tJAGUAR2_PIN(20),\n\tJAGUAR2_PIN(21),\n\tJAGUAR2_PIN(22),\n\tJAGUAR2_PIN(23),\n\tJAGUAR2_PIN(24),\n\tJAGUAR2_PIN(25),\n\tJAGUAR2_PIN(26),\n\tJAGUAR2_PIN(27),\n\tJAGUAR2_PIN(28),\n\tJAGUAR2_PIN(29),\n\tJAGUAR2_PIN(30),\n\tJAGUAR2_PIN(31),\n\tJAGUAR2_PIN(32),\n\tJAGUAR2_PIN(33),\n\tJAGUAR2_PIN(34),\n\tJAGUAR2_PIN(35),\n\tJAGUAR2_PIN(36),\n\tJAGUAR2_PIN(37),\n\tJAGUAR2_PIN(38),\n\tJAGUAR2_PIN(39),\n\tJAGUAR2_PIN(40),\n\tJAGUAR2_PIN(41),\n\tJAGUAR2_PIN(42),\n\tJAGUAR2_PIN(43),\n\tJAGUAR2_PIN(44),\n\tJAGUAR2_PIN(45),\n\tJAGUAR2_PIN(46),\n\tJAGUAR2_PIN(47),\n\tJAGUAR2_PIN(48),\n\tJAGUAR2_PIN(49),\n\tJAGUAR2_PIN(50),\n\tJAGUAR2_PIN(51),\n\tJAGUAR2_PIN(52),\n\tJAGUAR2_PIN(53),\n\tJAGUAR2_PIN(54),\n\tJAGUAR2_PIN(55),\n\tJAGUAR2_PIN(56),\n\tJAGUAR2_PIN(57),\n\tJAGUAR2_PIN(58),\n\tJAGUAR2_PIN(59),\n\tJAGUAR2_PIN(60),\n\tJAGUAR2_PIN(61),\n\tJAGUAR2_PIN(62),\n\tJAGUAR2_PIN(63),\n};\n\n#define SERVALT_P(p, f0, f1, f2)\t\t\t\t\t\\\nstatic struct ocelot_pin_caps servalt_pin_##p = {\t\t\t\\\n\t.pin = p,\t\t\t\t\t\t\t\\\n\t.functions = {\t\t\t\t\t\t\t\\\n\t\tFUNC_GPIO, FUNC_##f0, FUNC_##f1, FUNC_##f2\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n}\n\nSERVALT_P(0,  SG0,        NONE,      NONE);\nSERVALT_P(1,  SG0,        NONE,      NONE);\nSERVALT_P(2,  SG0,        NONE,      NONE);\nSERVALT_P(3,  SG0,        NONE,      NONE);\nSERVALT_P(4,  IRQ0_IN,    IRQ0_OUT,  TWI_SCL_M);\nSERVALT_P(5,  IRQ1_IN,    IRQ1_OUT,  TWI_SCL_M);\nSERVALT_P(6,  UART,       NONE,      NONE);\nSERVALT_P(7,  UART,       NONE,      NONE);\nSERVALT_P(8,  SI,         SFP,       TWI_SCL_M);\nSERVALT_P(9,  PCI_WAKE,   SFP,       SI);\nSERVALT_P(10, PTP0,       SFP,       TWI_SCL_M);\nSERVALT_P(11, PTP1,       SFP,       TWI_SCL_M);\nSERVALT_P(12, REF_CLK,    SFP,       TWI_SCL_M);\nSERVALT_P(13, REF_CLK,    SFP,       TWI_SCL_M);\nSERVALT_P(14, REF_CLK,    IRQ0_OUT,  SI);\nSERVALT_P(15, REF_CLK,    IRQ1_OUT,  SI);\nSERVALT_P(16, TACHO,      SFP,       SI);\nSERVALT_P(17, PWM,        NONE,      TWI_SCL_M);\nSERVALT_P(18, PTP2,       SFP,       SI);\nSERVALT_P(19, PTP3,       SFP,       SI);\nSERVALT_P(20, UART2,      SFP,       SI);\nSERVALT_P(21, UART2,      NONE,      NONE);\nSERVALT_P(22, MIIM,       SFP,       TWI2);\nSERVALT_P(23, MIIM,       SFP,       TWI2);\nSERVALT_P(24, TWI,        NONE,      NONE);\nSERVALT_P(25, TWI,        SFP,       TWI_SCL_M);\nSERVALT_P(26, TWI_SCL_M,  SFP,       SI);\nSERVALT_P(27, TWI_SCL_M,  SFP,       SI);\nSERVALT_P(28, TWI_SCL_M,  SFP,       SI);\nSERVALT_P(29, TWI_SCL_M,  NONE,      NONE);\nSERVALT_P(30, TWI_SCL_M,  NONE,      NONE);\nSERVALT_P(31, TWI_SCL_M,  NONE,      NONE);\nSERVALT_P(32, TWI_SCL_M,  NONE,      NONE);\nSERVALT_P(33, RCVRD_CLK,  NONE,      NONE);\nSERVALT_P(34, RCVRD_CLK,  NONE,      NONE);\nSERVALT_P(35, RCVRD_CLK,  NONE,      NONE);\nSERVALT_P(36, RCVRD_CLK,  NONE,      NONE);\n\n#define SERVALT_PIN(n) {\t\t\t\t\t\\\n\t.number = n,\t\t\t\t\t\t\\\n\t.name = \"GPIO_\"#n,\t\t\t\t\t\\\n\t.drv_data = &servalt_pin_##n\t\t\t\t\\\n}\n\nstatic const struct pinctrl_pin_desc servalt_pins[] = {\n\tSERVALT_PIN(0),\n\tSERVALT_PIN(1),\n\tSERVALT_PIN(2),\n\tSERVALT_PIN(3),\n\tSERVALT_PIN(4),\n\tSERVALT_PIN(5),\n\tSERVALT_PIN(6),\n\tSERVALT_PIN(7),\n\tSERVALT_PIN(8),\n\tSERVALT_PIN(9),\n\tSERVALT_PIN(10),\n\tSERVALT_PIN(11),\n\tSERVALT_PIN(12),\n\tSERVALT_PIN(13),\n\tSERVALT_PIN(14),\n\tSERVALT_PIN(15),\n\tSERVALT_PIN(16),\n\tSERVALT_PIN(17),\n\tSERVALT_PIN(18),\n\tSERVALT_PIN(19),\n\tSERVALT_PIN(20),\n\tSERVALT_PIN(21),\n\tSERVALT_PIN(22),\n\tSERVALT_PIN(23),\n\tSERVALT_PIN(24),\n\tSERVALT_PIN(25),\n\tSERVALT_PIN(26),\n\tSERVALT_PIN(27),\n\tSERVALT_PIN(28),\n\tSERVALT_PIN(29),\n\tSERVALT_PIN(30),\n\tSERVALT_PIN(31),\n\tSERVALT_PIN(32),\n\tSERVALT_PIN(33),\n\tSERVALT_PIN(34),\n\tSERVALT_PIN(35),\n\tSERVALT_PIN(36),\n};\n\n#define SPARX5_P(p, f0, f1, f2)\t\t\t\t\t\\\nstatic struct ocelot_pin_caps sparx5_pin_##p = {\t\t\t\\\n\t.pin = p,\t\t\t\t\t\t\t\\\n\t.functions = {\t\t\t\t\t\t\t\\\n\t\tFUNC_GPIO, FUNC_##f0, FUNC_##f1, FUNC_##f2\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n}\n\nSPARX5_P(0,  SG0,       PLL_STAT,  NONE);\nSPARX5_P(1,  SG0,       NONE,      NONE);\nSPARX5_P(2,  SG0,       NONE,      NONE);\nSPARX5_P(3,  SG0,       NONE,      NONE);\nSPARX5_P(4,  SG1,       NONE,      NONE);\nSPARX5_P(5,  SG1,       NONE,      NONE);\nSPARX5_P(6,  IRQ0_IN,   IRQ0_OUT,  SFP);\nSPARX5_P(7,  IRQ1_IN,   IRQ1_OUT,  SFP);\nSPARX5_P(8,  PTP0,      NONE,      SFP);\nSPARX5_P(9,  PTP1,      SFP,       TWI_SCL_M);\nSPARX5_P(10, UART,      NONE,      NONE);\nSPARX5_P(11, UART,      NONE,      NONE);\nSPARX5_P(12, SG1,       NONE,      NONE);\nSPARX5_P(13, SG1,       NONE,      NONE);\nSPARX5_P(14, TWI,       TWI_SCL_M, NONE);\nSPARX5_P(15, TWI,       NONE,      NONE);\nSPARX5_P(16, SI,        TWI_SCL_M, SFP);\nSPARX5_P(17, SI,        TWI_SCL_M, SFP);\nSPARX5_P(18, SI,        TWI_SCL_M, SFP);\nSPARX5_P(19, PCI_WAKE,  TWI_SCL_M, SFP);\nSPARX5_P(20, IRQ0_OUT,  TWI_SCL_M, SFP);\nSPARX5_P(21, IRQ1_OUT,  TACHO,     SFP);\nSPARX5_P(22, TACHO,     IRQ0_OUT,  TWI_SCL_M);\nSPARX5_P(23, PWM,       UART3,     TWI_SCL_M);\nSPARX5_P(24, PTP2,      UART3,     TWI_SCL_M);\nSPARX5_P(25, PTP3,      SI,        TWI_SCL_M);\nSPARX5_P(26, UART2,     SI,        TWI_SCL_M);\nSPARX5_P(27, UART2,     SI,        TWI_SCL_M);\nSPARX5_P(28, TWI2,      SI,        SFP);\nSPARX5_P(29, TWI2,      SI,        SFP);\nSPARX5_P(30, SG2,       SI,        PWM);\nSPARX5_P(31, SG2,       SI,        TWI_SCL_M);\nSPARX5_P(32, SG2,       SI,        TWI_SCL_M);\nSPARX5_P(33, SG2,       SI,        SFP);\nSPARX5_P(34, NONE,      TWI_SCL_M, EMMC);\nSPARX5_P(35, SFP,       TWI_SCL_M, EMMC);\nSPARX5_P(36, SFP,       TWI_SCL_M, EMMC);\nSPARX5_P(37, SFP,       NONE,      EMMC);\nSPARX5_P(38, NONE,      TWI_SCL_M, EMMC);\nSPARX5_P(39, SI2,       TWI_SCL_M, EMMC);\nSPARX5_P(40, SI2,       TWI_SCL_M, EMMC);\nSPARX5_P(41, SI2,       TWI_SCL_M, EMMC);\nSPARX5_P(42, SI2,       TWI_SCL_M, EMMC);\nSPARX5_P(43, SI2,       TWI_SCL_M, EMMC);\nSPARX5_P(44, SI,        SFP,       EMMC);\nSPARX5_P(45, SI,        SFP,       EMMC);\nSPARX5_P(46, NONE,      SFP,       EMMC);\nSPARX5_P(47, NONE,      SFP,       EMMC);\nSPARX5_P(48, TWI3,      SI,        SFP);\nSPARX5_P(49, TWI3,      NONE,      SFP);\nSPARX5_P(50, SFP,       NONE,      TWI_SCL_M);\nSPARX5_P(51, SFP,       SI,        TWI_SCL_M);\nSPARX5_P(52, SFP,       MIIM,      TWI_SCL_M);\nSPARX5_P(53, SFP,       MIIM,      TWI_SCL_M);\nSPARX5_P(54, SFP,       PTP2,      TWI_SCL_M);\nSPARX5_P(55, SFP,       PTP3,      PCI_WAKE);\nSPARX5_P(56, MIIM,      SFP,       TWI_SCL_M);\nSPARX5_P(57, MIIM,      SFP,       TWI_SCL_M);\nSPARX5_P(58, MIIM,      SFP,       TWI_SCL_M);\nSPARX5_P(59, MIIM,      SFP,       NONE);\nSPARX5_P(60, RECO_CLK,  NONE,      NONE);\nSPARX5_P(61, RECO_CLK,  NONE,      NONE);\nSPARX5_P(62, RECO_CLK,  PLL_STAT,  NONE);\nSPARX5_P(63, RECO_CLK,  NONE,      NONE);\n\n#define SPARX5_PIN(n) {\t\t\t\t\t\\\n\t.number = n,\t\t\t\t\t\t\\\n\t.name = \"GPIO_\"#n,\t\t\t\t\t\\\n\t.drv_data = &sparx5_pin_##n\t\t\t\t\\\n}\n\nstatic const struct pinctrl_pin_desc sparx5_pins[] = {\n\tSPARX5_PIN(0),\n\tSPARX5_PIN(1),\n\tSPARX5_PIN(2),\n\tSPARX5_PIN(3),\n\tSPARX5_PIN(4),\n\tSPARX5_PIN(5),\n\tSPARX5_PIN(6),\n\tSPARX5_PIN(7),\n\tSPARX5_PIN(8),\n\tSPARX5_PIN(9),\n\tSPARX5_PIN(10),\n\tSPARX5_PIN(11),\n\tSPARX5_PIN(12),\n\tSPARX5_PIN(13),\n\tSPARX5_PIN(14),\n\tSPARX5_PIN(15),\n\tSPARX5_PIN(16),\n\tSPARX5_PIN(17),\n\tSPARX5_PIN(18),\n\tSPARX5_PIN(19),\n\tSPARX5_PIN(20),\n\tSPARX5_PIN(21),\n\tSPARX5_PIN(22),\n\tSPARX5_PIN(23),\n\tSPARX5_PIN(24),\n\tSPARX5_PIN(25),\n\tSPARX5_PIN(26),\n\tSPARX5_PIN(27),\n\tSPARX5_PIN(28),\n\tSPARX5_PIN(29),\n\tSPARX5_PIN(30),\n\tSPARX5_PIN(31),\n\tSPARX5_PIN(32),\n\tSPARX5_PIN(33),\n\tSPARX5_PIN(34),\n\tSPARX5_PIN(35),\n\tSPARX5_PIN(36),\n\tSPARX5_PIN(37),\n\tSPARX5_PIN(38),\n\tSPARX5_PIN(39),\n\tSPARX5_PIN(40),\n\tSPARX5_PIN(41),\n\tSPARX5_PIN(42),\n\tSPARX5_PIN(43),\n\tSPARX5_PIN(44),\n\tSPARX5_PIN(45),\n\tSPARX5_PIN(46),\n\tSPARX5_PIN(47),\n\tSPARX5_PIN(48),\n\tSPARX5_PIN(49),\n\tSPARX5_PIN(50),\n\tSPARX5_PIN(51),\n\tSPARX5_PIN(52),\n\tSPARX5_PIN(53),\n\tSPARX5_PIN(54),\n\tSPARX5_PIN(55),\n\tSPARX5_PIN(56),\n\tSPARX5_PIN(57),\n\tSPARX5_PIN(58),\n\tSPARX5_PIN(59),\n\tSPARX5_PIN(60),\n\tSPARX5_PIN(61),\n\tSPARX5_PIN(62),\n\tSPARX5_PIN(63),\n};\n\n#define LAN966X_P(p, f0, f1, f2, f3, f4, f5, f6, f7)           \\\nstatic struct ocelot_pin_caps lan966x_pin_##p = {              \\\n\t.pin = p,                                              \\\n\t.functions = {                                         \\\n\t\tFUNC_##f0, FUNC_##f1, FUNC_##f2,               \\\n\t\tFUNC_##f3                                      \\\n\t},                                                     \\\n\t.a_functions = {                                       \\\n\t\tFUNC_##f4, FUNC_##f5, FUNC_##f6,               \\\n\t\tFUNC_##f7                                      \\\n\t},                                                     \\\n}\n\n \n \nLAN966X_P(0,    GPIO,    NONE,     NONE,      NONE,     NONE,     NONE,      NONE,        R);\nLAN966X_P(1,    GPIO,    NONE,     NONE,      NONE,     NONE,     NONE,      NONE,        R);\nLAN966X_P(2,    GPIO,    NONE,     NONE,      NONE,     NONE,     NONE,      NONE,        R);\nLAN966X_P(3,    GPIO,    NONE,     NONE,      NONE,     NONE,     NONE,      NONE,        R);\nLAN966X_P(4,    GPIO,    NONE,     NONE,      NONE,     NONE,     NONE,      NONE,        R);\nLAN966X_P(5,    GPIO,    NONE,     NONE,      NONE,     NONE,     NONE,      NONE,        R);\nLAN966X_P(6,    GPIO,    NONE,     NONE,      NONE,     NONE,     NONE,      NONE,        R);\nLAN966X_P(7,    GPIO,    NONE,     NONE,      NONE,     NONE,     NONE,      NONE,        R);\nLAN966X_P(8,    GPIO,   FC0_a,  USB_H_b,      NONE,  USB_S_b,     NONE,      NONE,        R);\nLAN966X_P(9,    GPIO,   FC0_a,  USB_H_b,      NONE,     NONE,     NONE,      NONE,        R);\nLAN966X_P(10,   GPIO,   FC0_a,     NONE,      NONE,     NONE,     NONE,      NONE,        R);\nLAN966X_P(11,   GPIO,   FC1_a,     NONE,      NONE,     NONE,     NONE,      NONE,        R);\nLAN966X_P(12,   GPIO,   FC1_a,     NONE,      NONE,     NONE,     NONE,      NONE,        R);\nLAN966X_P(13,   GPIO,   FC1_a,     NONE,      NONE,     NONE,     NONE,      NONE,        R);\nLAN966X_P(14,   GPIO,   FC2_a,     NONE,      NONE,     NONE,     NONE,      NONE,        R);\nLAN966X_P(15,   GPIO,   FC2_a,     NONE,      NONE,     NONE,     NONE,      NONE,        R);\nLAN966X_P(16,   GPIO,   FC2_a, IB_TRG_a,      NONE, OB_TRG_a, IRQ_IN_c, IRQ_OUT_c,        R);\nLAN966X_P(17,   GPIO,   FC3_a, IB_TRG_a,      NONE, OB_TRG_a, IRQ_IN_c, IRQ_OUT_c,        R);\nLAN966X_P(18,   GPIO,   FC3_a, IB_TRG_a,      NONE, OB_TRG_a, IRQ_IN_c, IRQ_OUT_c,        R);\nLAN966X_P(19,   GPIO,   FC3_a, IB_TRG_a,      NONE, OB_TRG_a, IRQ_IN_c, IRQ_OUT_c,        R);\nLAN966X_P(20,   GPIO,   FC4_a, IB_TRG_a,      NONE, OB_TRG_a, IRQ_IN_c,      NONE,        R);\nLAN966X_P(21,   GPIO,   FC4_a,     NONE,      NONE, OB_TRG_a,     NONE,      NONE,        R);\nLAN966X_P(22,   GPIO,   FC4_a,     NONE,      NONE, OB_TRG_a,     NONE,      NONE,        R);\nLAN966X_P(23,   GPIO,    NONE,     NONE,      NONE, OB_TRG_a,     NONE,      NONE,        R);\nLAN966X_P(24,   GPIO,   FC0_b, IB_TRG_a,   USB_H_c, OB_TRG_a, IRQ_IN_c,   TACHO_a,        R);\nLAN966X_P(25,   GPIO,   FC0_b, IB_TRG_a,   USB_H_c, OB_TRG_a, IRQ_OUT_c,   SFP_SD,        R);\nLAN966X_P(26,   GPIO,   FC0_b, IB_TRG_a,   USB_S_c, OB_TRG_a,   CAN0_a,    SFP_SD,        R);\nLAN966X_P(27,   GPIO,    NONE,     NONE,      NONE, OB_TRG_a,   CAN0_a,     PWM_a,        R);\nLAN966X_P(28,   GPIO,  MIIM_a,     NONE,      NONE, OB_TRG_a, IRQ_OUT_c,   SFP_SD,        R);\nLAN966X_P(29,   GPIO,  MIIM_a,     NONE,      NONE, OB_TRG_a,     NONE,      NONE,        R);\nLAN966X_P(30,   GPIO,   FC3_c,     CAN1,    CLKMON,   OB_TRG,   RECO_b,      NONE,        R);\nLAN966X_P(31,   GPIO,   FC3_c,     CAN1,    CLKMON,   OB_TRG,   RECO_b,      NONE,        R);\nLAN966X_P(32,   GPIO,   FC3_c,     NONE,   SGPIO_a,     NONE,  MIIM_Sa,      NONE,        R);\nLAN966X_P(33,   GPIO,   FC1_b,     NONE,   SGPIO_a,     NONE,  MIIM_Sa,    MIIM_b,        R);\nLAN966X_P(34,   GPIO,   FC1_b,     NONE,   SGPIO_a,     NONE,  MIIM_Sa,    MIIM_b,        R);\nLAN966X_P(35,   GPIO,   FC1_b,  PTPSYNC_0, SGPIO_a,   CAN0_b,     NONE,      NONE,        R);\nLAN966X_P(36,   GPIO,    NONE,  PTPSYNC_1,    NONE,   CAN0_b,     NONE,      NONE,        R);\nLAN966X_P(37,   GPIO, FC_SHRD0, PTPSYNC_2, TWI_SLC_GATE_AD, NONE, NONE,      NONE,        R);\nLAN966X_P(38,   GPIO,    NONE,  PTPSYNC_3,    NONE,     NONE,     NONE,      NONE,        R);\nLAN966X_P(39,   GPIO,    NONE,  PTPSYNC_4,    NONE,     NONE,     NONE,      NONE,        R);\nLAN966X_P(40,   GPIO, FC_SHRD1, PTPSYNC_5,    NONE,     NONE,     NONE,      NONE,        R);\nLAN966X_P(41,   GPIO, FC_SHRD2, PTPSYNC_6, TWI_SLC_GATE_AD, NONE, NONE,      NONE,        R);\nLAN966X_P(42,   GPIO, FC_SHRD3, PTPSYNC_7, TWI_SLC_GATE_AD, NONE, NONE,      NONE,        R);\nLAN966X_P(43,   GPIO,   FC2_b,   OB_TRG_b, IB_TRG_b, IRQ_OUT_a,  RECO_a,  IRQ_IN_a,       R);\nLAN966X_P(44,   GPIO,   FC2_b,   OB_TRG_b, IB_TRG_b, IRQ_OUT_a,  RECO_a,  IRQ_IN_a,       R);\nLAN966X_P(45,   GPIO,   FC2_b,   OB_TRG_b, IB_TRG_b, IRQ_OUT_a,    NONE,  IRQ_IN_a,       R);\nLAN966X_P(46,   GPIO,   FC1_c,   OB_TRG_b, IB_TRG_b, IRQ_OUT_a, FC_SHRD4, IRQ_IN_a,       R);\nLAN966X_P(47,   GPIO,   FC1_c,   OB_TRG_b, IB_TRG_b, IRQ_OUT_a, FC_SHRD5, IRQ_IN_a,       R);\nLAN966X_P(48,   GPIO,   FC1_c,   OB_TRG_b, IB_TRG_b, IRQ_OUT_a, FC_SHRD6, IRQ_IN_a,       R);\nLAN966X_P(49,   GPIO, FC_SHRD7,  OB_TRG_b, IB_TRG_b, IRQ_OUT_a, TWI_SLC_GATE, IRQ_IN_a,   R);\nLAN966X_P(50,   GPIO, FC_SHRD16, OB_TRG_b, IB_TRG_b, IRQ_OUT_a, TWI_SLC_GATE, NONE,       R);\nLAN966X_P(51,   GPIO,   FC3_b,   OB_TRG_b, IB_TRG_c, IRQ_OUT_b,   PWM_b,  IRQ_IN_b,       R);\nLAN966X_P(52,   GPIO,   FC3_b,   OB_TRG_b, IB_TRG_c, IRQ_OUT_b, TACHO_b,  IRQ_IN_b,       R);\nLAN966X_P(53,   GPIO,   FC3_b,   OB_TRG_b, IB_TRG_c, IRQ_OUT_b,    NONE,  IRQ_IN_b,       R);\nLAN966X_P(54,   GPIO, FC_SHRD8,  OB_TRG_b, IB_TRG_c, IRQ_OUT_b, TWI_SLC_GATE, IRQ_IN_b,   R);\nLAN966X_P(55,   GPIO, FC_SHRD9,  OB_TRG_b, IB_TRG_c, IRQ_OUT_b, TWI_SLC_GATE, IRQ_IN_b,   R);\nLAN966X_P(56,   GPIO,   FC4_b,   OB_TRG_b, IB_TRG_c, IRQ_OUT_b, FC_SHRD10,    IRQ_IN_b,   R);\nLAN966X_P(57,   GPIO,   FC4_b, TWI_SLC_GATE, IB_TRG_c, IRQ_OUT_b, FC_SHRD11, IRQ_IN_b,    R);\nLAN966X_P(58,   GPIO,   FC4_b, TWI_SLC_GATE, IB_TRG_c, IRQ_OUT_b, FC_SHRD12, IRQ_IN_b,    R);\nLAN966X_P(59,   GPIO,   QSPI1,   MIIM_c,      NONE,     NONE,  MIIM_Sb,      NONE,        R);\nLAN966X_P(60,   GPIO,   QSPI1,   MIIM_c,      NONE,     NONE,  MIIM_Sb,      NONE,        R);\nLAN966X_P(61,   GPIO,   QSPI1,     NONE,   SGPIO_b,    FC0_c,  MIIM_Sb,      NONE,        R);\nLAN966X_P(62,   GPIO,   QSPI1, FC_SHRD13,  SGPIO_b,    FC0_c, TWI_SLC_GATE,  SFP_SD,      R);\nLAN966X_P(63,   GPIO,   QSPI1, FC_SHRD14,  SGPIO_b,    FC0_c, TWI_SLC_GATE,  SFP_SD,      R);\nLAN966X_P(64,   GPIO,   QSPI1,    FC4_c,   SGPIO_b, FC_SHRD15, TWI_SLC_GATE, SFP_SD,      R);\nLAN966X_P(65,   GPIO, USB_H_a,    FC4_c,      NONE, IRQ_OUT_c, TWI_SLC_GATE_AD, NONE,     R);\nLAN966X_P(66,   GPIO, USB_H_a,    FC4_c,   USB_S_a, IRQ_OUT_c, IRQ_IN_c,     NONE,        R);\nLAN966X_P(67,   GPIO, EMMC_SD,     NONE,     QSPI2,     NONE,     NONE,      NONE,        R);\nLAN966X_P(68,   GPIO, EMMC_SD,     NONE,     QSPI2,     NONE,     NONE,      NONE,        R);\nLAN966X_P(69,   GPIO, EMMC_SD,     NONE,     QSPI2,     NONE,     NONE,      NONE,        R);\nLAN966X_P(70,   GPIO, EMMC_SD,     NONE,     QSPI2,     NONE,     NONE,      NONE,        R);\nLAN966X_P(71,   GPIO, EMMC_SD,     NONE,     QSPI2,     NONE,     NONE,      NONE,        R);\nLAN966X_P(72,   GPIO, EMMC_SD,     NONE,     QSPI2,     NONE,     NONE,      NONE,        R);\nLAN966X_P(73,   GPIO,    EMMC,     NONE,      NONE,       SD,     NONE,      NONE,        R);\nLAN966X_P(74,   GPIO,    EMMC,     NONE, FC_SHRD17,       SD, TWI_SLC_GATE,  NONE,        R);\nLAN966X_P(75,   GPIO,    EMMC,     NONE, FC_SHRD18,       SD, TWI_SLC_GATE,  NONE,        R);\nLAN966X_P(76,   GPIO,    EMMC,     NONE, FC_SHRD19,       SD, TWI_SLC_GATE,  NONE,        R);\nLAN966X_P(77,   GPIO, EMMC_SD,     NONE, FC_SHRD20,     NONE, TWI_SLC_GATE,  NONE,        R);\n\n#define LAN966X_PIN(n) {                                       \\\n\t.number = n,                                           \\\n\t.name = \"GPIO_\"#n,                                     \\\n\t.drv_data = &lan966x_pin_##n                           \\\n}\n\nstatic const struct pinctrl_pin_desc lan966x_pins[] = {\n\tLAN966X_PIN(0),\n\tLAN966X_PIN(1),\n\tLAN966X_PIN(2),\n\tLAN966X_PIN(3),\n\tLAN966X_PIN(4),\n\tLAN966X_PIN(5),\n\tLAN966X_PIN(6),\n\tLAN966X_PIN(7),\n\tLAN966X_PIN(8),\n\tLAN966X_PIN(9),\n\tLAN966X_PIN(10),\n\tLAN966X_PIN(11),\n\tLAN966X_PIN(12),\n\tLAN966X_PIN(13),\n\tLAN966X_PIN(14),\n\tLAN966X_PIN(15),\n\tLAN966X_PIN(16),\n\tLAN966X_PIN(17),\n\tLAN966X_PIN(18),\n\tLAN966X_PIN(19),\n\tLAN966X_PIN(20),\n\tLAN966X_PIN(21),\n\tLAN966X_PIN(22),\n\tLAN966X_PIN(23),\n\tLAN966X_PIN(24),\n\tLAN966X_PIN(25),\n\tLAN966X_PIN(26),\n\tLAN966X_PIN(27),\n\tLAN966X_PIN(28),\n\tLAN966X_PIN(29),\n\tLAN966X_PIN(30),\n\tLAN966X_PIN(31),\n\tLAN966X_PIN(32),\n\tLAN966X_PIN(33),\n\tLAN966X_PIN(34),\n\tLAN966X_PIN(35),\n\tLAN966X_PIN(36),\n\tLAN966X_PIN(37),\n\tLAN966X_PIN(38),\n\tLAN966X_PIN(39),\n\tLAN966X_PIN(40),\n\tLAN966X_PIN(41),\n\tLAN966X_PIN(42),\n\tLAN966X_PIN(43),\n\tLAN966X_PIN(44),\n\tLAN966X_PIN(45),\n\tLAN966X_PIN(46),\n\tLAN966X_PIN(47),\n\tLAN966X_PIN(48),\n\tLAN966X_PIN(49),\n\tLAN966X_PIN(50),\n\tLAN966X_PIN(51),\n\tLAN966X_PIN(52),\n\tLAN966X_PIN(53),\n\tLAN966X_PIN(54),\n\tLAN966X_PIN(55),\n\tLAN966X_PIN(56),\n\tLAN966X_PIN(57),\n\tLAN966X_PIN(58),\n\tLAN966X_PIN(59),\n\tLAN966X_PIN(60),\n\tLAN966X_PIN(61),\n\tLAN966X_PIN(62),\n\tLAN966X_PIN(63),\n\tLAN966X_PIN(64),\n\tLAN966X_PIN(65),\n\tLAN966X_PIN(66),\n\tLAN966X_PIN(67),\n\tLAN966X_PIN(68),\n\tLAN966X_PIN(69),\n\tLAN966X_PIN(70),\n\tLAN966X_PIN(71),\n\tLAN966X_PIN(72),\n\tLAN966X_PIN(73),\n\tLAN966X_PIN(74),\n\tLAN966X_PIN(75),\n\tLAN966X_PIN(76),\n\tLAN966X_PIN(77),\n};\n\nstatic int ocelot_get_functions_count(struct pinctrl_dev *pctldev)\n{\n\treturn ARRAY_SIZE(ocelot_function_names);\n}\n\nstatic const char *ocelot_get_function_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t    unsigned int function)\n{\n\treturn ocelot_function_names[function];\n}\n\nstatic int ocelot_get_function_groups(struct pinctrl_dev *pctldev,\n\t\t\t\t      unsigned int function,\n\t\t\t\t      const char *const **groups,\n\t\t\t\t      unsigned *const num_groups)\n{\n\tstruct ocelot_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\n\n\t*groups  = info->func[function].groups;\n\t*num_groups = info->func[function].ngroups;\n\n\treturn 0;\n}\n\nstatic int ocelot_pin_function_idx(struct ocelot_pinctrl *info,\n\t\t\t\t   unsigned int pin, unsigned int function)\n{\n\tstruct ocelot_pin_caps *p = info->desc->pins[pin].drv_data;\n\tint i;\n\n\tfor (i = 0; i < OCELOT_FUNC_PER_PIN; i++) {\n\t\tif (function == p->functions[i])\n\t\t\treturn i;\n\n\t\tif (function == p->a_functions[i])\n\t\t\treturn i + OCELOT_FUNC_PER_PIN;\n\t}\n\n\treturn -1;\n}\n\n#define REG_ALT(msb, info, p) (OCELOT_GPIO_ALT0 * (info)->stride + 4 * ((msb) + ((info)->stride * ((p) / 32))))\n\nstatic int ocelot_pinmux_set_mux(struct pinctrl_dev *pctldev,\n\t\t\t\t unsigned int selector, unsigned int group)\n{\n\tstruct ocelot_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\n\tstruct ocelot_pin_caps *pin = info->desc->pins[group].drv_data;\n\tunsigned int p = pin->pin % 32;\n\tint f;\n\n\tf = ocelot_pin_function_idx(info, group, selector);\n\tif (f < 0)\n\t\treturn -EINVAL;\n\n\t \n\tregmap_update_bits(info->map, REG_ALT(0, info, pin->pin),\n\t\t\t   BIT(p), f << p);\n\tregmap_update_bits(info->map, REG_ALT(1, info, pin->pin),\n\t\t\t   BIT(p), (f >> 1) << p);\n\n\treturn 0;\n}\n\nstatic int lan966x_pinmux_set_mux(struct pinctrl_dev *pctldev,\n\t\t\t\t  unsigned int selector, unsigned int group)\n{\n\tstruct ocelot_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\n\tstruct ocelot_pin_caps *pin = info->desc->pins[group].drv_data;\n\tunsigned int p = pin->pin % 32;\n\tint f;\n\n\tf = ocelot_pin_function_idx(info, group, selector);\n\tif (f < 0)\n\t\treturn -EINVAL;\n\n\t \n\tregmap_update_bits(info->map, REG_ALT(0, info, pin->pin),\n\t\t\t   BIT(p), f << p);\n\tregmap_update_bits(info->map, REG_ALT(1, info, pin->pin),\n\t\t\t   BIT(p), (f >> 1) << p);\n\tregmap_update_bits(info->map, REG_ALT(2, info, pin->pin),\n\t\t\t   BIT(p), (f >> 2) << p);\n\n\treturn 0;\n}\n\n#define REG(r, info, p) ((r) * (info)->stride + (4 * ((p) / 32)))\n\nstatic int ocelot_gpio_set_direction(struct pinctrl_dev *pctldev,\n\t\t\t\t     struct pinctrl_gpio_range *range,\n\t\t\t\t     unsigned int pin, bool input)\n{\n\tstruct ocelot_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\n\tunsigned int p = pin % 32;\n\n\tregmap_update_bits(info->map, REG(OCELOT_GPIO_OE, info, pin), BIT(p),\n\t\t\t   input ? 0 : BIT(p));\n\n\treturn 0;\n}\n\nstatic int ocelot_gpio_request_enable(struct pinctrl_dev *pctldev,\n\t\t\t\t      struct pinctrl_gpio_range *range,\n\t\t\t\t      unsigned int offset)\n{\n\tstruct ocelot_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\n\tunsigned int p = offset % 32;\n\n\tregmap_update_bits(info->map, REG_ALT(0, info, offset),\n\t\t\t   BIT(p), 0);\n\tregmap_update_bits(info->map, REG_ALT(1, info, offset),\n\t\t\t   BIT(p), 0);\n\n\treturn 0;\n}\n\nstatic int lan966x_gpio_request_enable(struct pinctrl_dev *pctldev,\n\t\t\t\t       struct pinctrl_gpio_range *range,\n\t\t\t\t       unsigned int offset)\n{\n\tstruct ocelot_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\n\tunsigned int p = offset % 32;\n\n\tregmap_update_bits(info->map, REG_ALT(0, info, offset),\n\t\t\t   BIT(p), 0);\n\tregmap_update_bits(info->map, REG_ALT(1, info, offset),\n\t\t\t   BIT(p), 0);\n\tregmap_update_bits(info->map, REG_ALT(2, info, offset),\n\t\t\t   BIT(p), 0);\n\n\treturn 0;\n}\n\nstatic const struct pinmux_ops ocelot_pmx_ops = {\n\t.get_functions_count = ocelot_get_functions_count,\n\t.get_function_name = ocelot_get_function_name,\n\t.get_function_groups = ocelot_get_function_groups,\n\t.set_mux = ocelot_pinmux_set_mux,\n\t.gpio_set_direction = ocelot_gpio_set_direction,\n\t.gpio_request_enable = ocelot_gpio_request_enable,\n};\n\nstatic const struct pinmux_ops lan966x_pmx_ops = {\n\t.get_functions_count = ocelot_get_functions_count,\n\t.get_function_name = ocelot_get_function_name,\n\t.get_function_groups = ocelot_get_function_groups,\n\t.set_mux = lan966x_pinmux_set_mux,\n\t.gpio_set_direction = ocelot_gpio_set_direction,\n\t.gpio_request_enable = lan966x_gpio_request_enable,\n};\n\nstatic int ocelot_pctl_get_groups_count(struct pinctrl_dev *pctldev)\n{\n\tstruct ocelot_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn info->desc->npins;\n}\n\nstatic const char *ocelot_pctl_get_group_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t      unsigned int group)\n{\n\tstruct ocelot_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn info->desc->pins[group].name;\n}\n\nstatic int ocelot_pctl_get_group_pins(struct pinctrl_dev *pctldev,\n\t\t\t\t      unsigned int group,\n\t\t\t\t      const unsigned int **pins,\n\t\t\t\t      unsigned int *num_pins)\n{\n\tstruct ocelot_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\n\n\t*pins = &info->desc->pins[group].number;\n\t*num_pins = 1;\n\n\treturn 0;\n}\n\nstatic int ocelot_hw_get_value(struct ocelot_pinctrl *info,\n\t\t\t       unsigned int pin,\n\t\t\t       unsigned int reg,\n\t\t\t       int *val)\n{\n\tint ret = -EOPNOTSUPP;\n\n\tif (info->pincfg) {\n\t\tconst struct ocelot_pincfg_data *opd = info->pincfg_data;\n\t\tu32 regcfg;\n\n\t\tret = regmap_read(info->pincfg,\n\t\t\t\t  pin * regmap_get_reg_stride(info->pincfg),\n\t\t\t\t  &regcfg);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = 0;\n\t\tswitch (reg) {\n\t\tcase PINCONF_BIAS:\n\t\t\t*val = regcfg & (opd->pd_bit | opd->pu_bit);\n\t\t\tbreak;\n\n\t\tcase PINCONF_SCHMITT:\n\t\t\t*val = regcfg & opd->schmitt_bit;\n\t\t\tbreak;\n\n\t\tcase PINCONF_DRIVE_STRENGTH:\n\t\t\t*val = regcfg & opd->drive_bits;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int ocelot_pincfg_clrsetbits(struct ocelot_pinctrl *info, u32 regaddr,\n\t\t\t\t    u32 clrbits, u32 setbits)\n{\n\tu32 val;\n\tint ret;\n\n\tret = regmap_read(info->pincfg,\n\t\t\t  regaddr * regmap_get_reg_stride(info->pincfg),\n\t\t\t  &val);\n\tif (ret)\n\t\treturn ret;\n\n\tval &= ~clrbits;\n\tval |= setbits;\n\n\tret = regmap_write(info->pincfg,\n\t\t\t   regaddr * regmap_get_reg_stride(info->pincfg),\n\t\t\t   val);\n\n\treturn ret;\n}\n\nstatic int ocelot_hw_set_value(struct ocelot_pinctrl *info,\n\t\t\t       unsigned int pin,\n\t\t\t       unsigned int reg,\n\t\t\t       int val)\n{\n\tint ret = -EOPNOTSUPP;\n\n\tif (info->pincfg) {\n\t\tconst struct ocelot_pincfg_data *opd = info->pincfg_data;\n\n\t\tret = 0;\n\t\tswitch (reg) {\n\t\tcase PINCONF_BIAS:\n\t\t\tret = ocelot_pincfg_clrsetbits(info, pin,\n\t\t\t\t\t\t       opd->pd_bit | opd->pu_bit,\n\t\t\t\t\t\t       val);\n\t\t\tbreak;\n\n\t\tcase PINCONF_SCHMITT:\n\t\t\tret = ocelot_pincfg_clrsetbits(info, pin,\n\t\t\t\t\t\t       opd->schmitt_bit,\n\t\t\t\t\t\t       val);\n\t\t\tbreak;\n\n\t\tcase PINCONF_DRIVE_STRENGTH:\n\t\t\tif (val <= 3)\n\t\t\t\tret = ocelot_pincfg_clrsetbits(info, pin,\n\t\t\t\t\t\t\t       opd->drive_bits,\n\t\t\t\t\t\t\t       val);\n\t\t\telse\n\t\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int ocelot_pinconf_get(struct pinctrl_dev *pctldev,\n\t\t\t      unsigned int pin, unsigned long *config)\n{\n\tstruct ocelot_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\n\tu32 param = pinconf_to_config_param(*config);\n\tint val, err;\n\n\tswitch (param) {\n\tcase PIN_CONFIG_BIAS_DISABLE:\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\terr = ocelot_hw_get_value(info, pin, PINCONF_BIAS, &val);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (param == PIN_CONFIG_BIAS_DISABLE)\n\t\t\tval = (val == 0);\n\t\telse if (param == PIN_CONFIG_BIAS_PULL_DOWN)\n\t\t\tval = !!(val & info->pincfg_data->pd_bit);\n\t\telse     \n\t\t\tval = !!(val & info->pincfg_data->pu_bit);\n\t\tbreak;\n\n\tcase PIN_CONFIG_INPUT_SCHMITT_ENABLE:\n\t\tif (!info->pincfg_data->schmitt_bit)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\terr = ocelot_hw_get_value(info, pin, PINCONF_SCHMITT, &val);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tval = !!(val & info->pincfg_data->schmitt_bit);\n\t\tbreak;\n\n\tcase PIN_CONFIG_DRIVE_STRENGTH:\n\t\terr = ocelot_hw_get_value(info, pin, PINCONF_DRIVE_STRENGTH,\n\t\t\t\t\t  &val);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\n\tcase PIN_CONFIG_OUTPUT:\n\t\terr = regmap_read(info->map, REG(OCELOT_GPIO_OUT, info, pin),\n\t\t\t\t  &val);\n\t\tif (err)\n\t\t\treturn err;\n\t\tval = !!(val & BIT(pin % 32));\n\t\tbreak;\n\n\tcase PIN_CONFIG_INPUT_ENABLE:\n\tcase PIN_CONFIG_OUTPUT_ENABLE:\n\t\terr = regmap_read(info->map, REG(OCELOT_GPIO_OE, info, pin),\n\t\t\t\t  &val);\n\t\tif (err)\n\t\t\treturn err;\n\t\tval = val & BIT(pin % 32);\n\t\tif (param == PIN_CONFIG_OUTPUT_ENABLE)\n\t\t\tval = !!val;\n\t\telse\n\t\t\tval = !val;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t*config = pinconf_to_config_packed(param, val);\n\n\treturn 0;\n}\n\nstatic int ocelot_pinconf_set(struct pinctrl_dev *pctldev, unsigned int pin,\n\t\t\t      unsigned long *configs, unsigned int num_configs)\n{\n\tstruct ocelot_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct ocelot_pincfg_data *opd = info->pincfg_data;\n\tu32 param, arg, p;\n\tint cfg, err = 0;\n\n\tfor (cfg = 0; cfg < num_configs; cfg++) {\n\t\tparam = pinconf_to_config_param(configs[cfg]);\n\t\targ = pinconf_to_config_argument(configs[cfg]);\n\n\t\tswitch (param) {\n\t\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\t\targ = (param == PIN_CONFIG_BIAS_DISABLE) ? 0 :\n\t\t\t      (param == PIN_CONFIG_BIAS_PULL_UP) ?\n\t\t\t\topd->pu_bit : opd->pd_bit;\n\n\t\t\terr = ocelot_hw_set_value(info, pin, PINCONF_BIAS, arg);\n\t\t\tif (err)\n\t\t\t\tgoto err;\n\n\t\t\tbreak;\n\n\t\tcase PIN_CONFIG_INPUT_SCHMITT_ENABLE:\n\t\t\tif (!opd->schmitt_bit)\n\t\t\t\treturn -EOPNOTSUPP;\n\n\t\t\targ = arg ? opd->schmitt_bit : 0;\n\t\t\terr = ocelot_hw_set_value(info, pin, PINCONF_SCHMITT,\n\t\t\t\t\t\t  arg);\n\t\t\tif (err)\n\t\t\t\tgoto err;\n\n\t\t\tbreak;\n\n\t\tcase PIN_CONFIG_DRIVE_STRENGTH:\n\t\t\terr = ocelot_hw_set_value(info, pin,\n\t\t\t\t\t\t  PINCONF_DRIVE_STRENGTH,\n\t\t\t\t\t\t  arg);\n\t\t\tif (err)\n\t\t\t\tgoto err;\n\n\t\t\tbreak;\n\n\t\tcase PIN_CONFIG_OUTPUT_ENABLE:\n\t\tcase PIN_CONFIG_INPUT_ENABLE:\n\t\tcase PIN_CONFIG_OUTPUT:\n\t\t\tp = pin % 32;\n\t\t\tif (arg)\n\t\t\t\tregmap_write(info->map,\n\t\t\t\t\t     REG(OCELOT_GPIO_OUT_SET, info,\n\t\t\t\t\t\t pin),\n\t\t\t\t\t     BIT(p));\n\t\t\telse\n\t\t\t\tregmap_write(info->map,\n\t\t\t\t\t     REG(OCELOT_GPIO_OUT_CLR, info,\n\t\t\t\t\t\t pin),\n\t\t\t\t\t     BIT(p));\n\t\t\tregmap_update_bits(info->map,\n\t\t\t\t\t   REG(OCELOT_GPIO_OE, info, pin),\n\t\t\t\t\t   BIT(p),\n\t\t\t\t\t   param == PIN_CONFIG_INPUT_ENABLE ?\n\t\t\t\t\t   0 : BIT(p));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\terr = -EOPNOTSUPP;\n\t\t}\n\t}\nerr:\n\treturn err;\n}\n\nstatic const struct pinconf_ops ocelot_confops = {\n\t.is_generic = true,\n\t.pin_config_get = ocelot_pinconf_get,\n\t.pin_config_set = ocelot_pinconf_set,\n\t.pin_config_config_dbg_show = pinconf_generic_dump_config,\n};\n\nstatic const struct pinctrl_ops ocelot_pctl_ops = {\n\t.get_groups_count = ocelot_pctl_get_groups_count,\n\t.get_group_name = ocelot_pctl_get_group_name,\n\t.get_group_pins = ocelot_pctl_get_group_pins,\n\t.dt_node_to_map = pinconf_generic_dt_node_to_map_pin,\n\t.dt_free_map = pinconf_generic_dt_free_map,\n};\n\nstatic struct ocelot_match_data luton_desc = {\n\t.desc = {\n\t\t.name = \"luton-pinctrl\",\n\t\t.pins = luton_pins,\n\t\t.npins = ARRAY_SIZE(luton_pins),\n\t\t.pctlops = &ocelot_pctl_ops,\n\t\t.pmxops = &ocelot_pmx_ops,\n\t\t.owner = THIS_MODULE,\n\t},\n};\n\nstatic struct ocelot_match_data serval_desc = {\n\t.desc = {\n\t\t.name = \"serval-pinctrl\",\n\t\t.pins = serval_pins,\n\t\t.npins = ARRAY_SIZE(serval_pins),\n\t\t.pctlops = &ocelot_pctl_ops,\n\t\t.pmxops = &ocelot_pmx_ops,\n\t\t.owner = THIS_MODULE,\n\t},\n};\n\nstatic struct ocelot_match_data ocelot_desc = {\n\t.desc = {\n\t\t.name = \"ocelot-pinctrl\",\n\t\t.pins = ocelot_pins,\n\t\t.npins = ARRAY_SIZE(ocelot_pins),\n\t\t.pctlops = &ocelot_pctl_ops,\n\t\t.pmxops = &ocelot_pmx_ops,\n\t\t.owner = THIS_MODULE,\n\t},\n};\n\nstatic struct ocelot_match_data jaguar2_desc = {\n\t.desc = {\n\t\t.name = \"jaguar2-pinctrl\",\n\t\t.pins = jaguar2_pins,\n\t\t.npins = ARRAY_SIZE(jaguar2_pins),\n\t\t.pctlops = &ocelot_pctl_ops,\n\t\t.pmxops = &ocelot_pmx_ops,\n\t\t.owner = THIS_MODULE,\n\t},\n};\n\nstatic struct ocelot_match_data servalt_desc = {\n\t.desc = {\n\t\t.name = \"servalt-pinctrl\",\n\t\t.pins = servalt_pins,\n\t\t.npins = ARRAY_SIZE(servalt_pins),\n\t\t.pctlops = &ocelot_pctl_ops,\n\t\t.pmxops = &ocelot_pmx_ops,\n\t\t.owner = THIS_MODULE,\n\t},\n};\n\nstatic struct ocelot_match_data sparx5_desc = {\n\t.desc = {\n\t\t.name = \"sparx5-pinctrl\",\n\t\t.pins = sparx5_pins,\n\t\t.npins = ARRAY_SIZE(sparx5_pins),\n\t\t.pctlops = &ocelot_pctl_ops,\n\t\t.pmxops = &ocelot_pmx_ops,\n\t\t.confops = &ocelot_confops,\n\t\t.owner = THIS_MODULE,\n\t},\n\t.pincfg_data = {\n\t\t.pd_bit = BIT(4),\n\t\t.pu_bit = BIT(3),\n\t\t.drive_bits = GENMASK(1, 0),\n\t\t.schmitt_bit = BIT(2),\n\t},\n};\n\nstatic struct ocelot_match_data lan966x_desc = {\n\t.desc = {\n\t\t.name = \"lan966x-pinctrl\",\n\t\t.pins = lan966x_pins,\n\t\t.npins = ARRAY_SIZE(lan966x_pins),\n\t\t.pctlops = &ocelot_pctl_ops,\n\t\t.pmxops = &lan966x_pmx_ops,\n\t\t.confops = &ocelot_confops,\n\t\t.owner = THIS_MODULE,\n\t},\n\t.pincfg_data = {\n\t\t.pd_bit = BIT(3),\n\t\t.pu_bit = BIT(2),\n\t\t.drive_bits = GENMASK(1, 0),\n\t},\n};\n\nstatic int ocelot_create_group_func_map(struct device *dev,\n\t\t\t\t\tstruct ocelot_pinctrl *info)\n{\n\tint f, npins, i;\n\tu8 *pins = kcalloc(info->desc->npins, sizeof(u8), GFP_KERNEL);\n\n\tif (!pins)\n\t\treturn -ENOMEM;\n\n\tfor (f = 0; f < FUNC_MAX; f++) {\n\t\tfor (npins = 0, i = 0; i < info->desc->npins; i++) {\n\t\t\tif (ocelot_pin_function_idx(info, i, f) >= 0)\n\t\t\t\tpins[npins++] = i;\n\t\t}\n\n\t\tif (!npins)\n\t\t\tcontinue;\n\n\t\tinfo->func[f].ngroups = npins;\n\t\tinfo->func[f].groups = devm_kcalloc(dev, npins, sizeof(char *),\n\t\t\t\t\t\t    GFP_KERNEL);\n\t\tif (!info->func[f].groups) {\n\t\t\tkfree(pins);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tfor (i = 0; i < npins; i++)\n\t\t\tinfo->func[f].groups[i] =\n\t\t\t\tinfo->desc->pins[pins[i]].name;\n\t}\n\n\tkfree(pins);\n\n\treturn 0;\n}\n\nstatic int ocelot_pinctrl_register(struct platform_device *pdev,\n\t\t\t\t   struct ocelot_pinctrl *info)\n{\n\tint ret;\n\n\tret = ocelot_create_group_func_map(&pdev->dev, info);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Unable to create group func map.\\n\");\n\t\treturn ret;\n\t}\n\n\tinfo->pctl = devm_pinctrl_register(&pdev->dev, info->desc, info);\n\tif (IS_ERR(info->pctl)) {\n\t\tdev_err(&pdev->dev, \"Failed to register pinctrl\\n\");\n\t\treturn PTR_ERR(info->pctl);\n\t}\n\n\treturn 0;\n}\n\nstatic int ocelot_gpio_get(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct ocelot_pinctrl *info = gpiochip_get_data(chip);\n\tunsigned int val;\n\n\tregmap_read(info->map, REG(OCELOT_GPIO_IN, info, offset), &val);\n\n\treturn !!(val & BIT(offset % 32));\n}\n\nstatic void ocelot_gpio_set(struct gpio_chip *chip, unsigned int offset,\n\t\t\t    int value)\n{\n\tstruct ocelot_pinctrl *info = gpiochip_get_data(chip);\n\n\tif (value)\n\t\tregmap_write(info->map, REG(OCELOT_GPIO_OUT_SET, info, offset),\n\t\t\t     BIT(offset % 32));\n\telse\n\t\tregmap_write(info->map, REG(OCELOT_GPIO_OUT_CLR, info, offset),\n\t\t\t     BIT(offset % 32));\n}\n\nstatic int ocelot_gpio_get_direction(struct gpio_chip *chip,\n\t\t\t\t     unsigned int offset)\n{\n\tstruct ocelot_pinctrl *info = gpiochip_get_data(chip);\n\tunsigned int val;\n\n\tregmap_read(info->map, REG(OCELOT_GPIO_OE, info, offset), &val);\n\n\tif (val & BIT(offset % 32))\n\t\treturn GPIO_LINE_DIRECTION_OUT;\n\n\treturn GPIO_LINE_DIRECTION_IN;\n}\n\nstatic int ocelot_gpio_direction_input(struct gpio_chip *chip,\n\t\t\t\t       unsigned int offset)\n{\n\treturn pinctrl_gpio_direction_input(chip->base + offset);\n}\n\nstatic int ocelot_gpio_direction_output(struct gpio_chip *chip,\n\t\t\t\t\tunsigned int offset, int value)\n{\n\tstruct ocelot_pinctrl *info = gpiochip_get_data(chip);\n\tunsigned int pin = BIT(offset % 32);\n\n\tif (value)\n\t\tregmap_write(info->map, REG(OCELOT_GPIO_OUT_SET, info, offset),\n\t\t\t     pin);\n\telse\n\t\tregmap_write(info->map, REG(OCELOT_GPIO_OUT_CLR, info, offset),\n\t\t\t     pin);\n\n\treturn pinctrl_gpio_direction_output(chip->base + offset);\n}\n\nstatic const struct gpio_chip ocelot_gpiolib_chip = {\n\t.request = gpiochip_generic_request,\n\t.free = gpiochip_generic_free,\n\t.set = ocelot_gpio_set,\n\t.get = ocelot_gpio_get,\n\t.get_direction = ocelot_gpio_get_direction,\n\t.direction_input = ocelot_gpio_direction_input,\n\t.direction_output = ocelot_gpio_direction_output,\n\t.owner = THIS_MODULE,\n};\n\nstatic void ocelot_irq_mask(struct irq_data *data)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\n\tstruct ocelot_pinctrl *info = gpiochip_get_data(chip);\n\tunsigned int gpio = irqd_to_hwirq(data);\n\n\tregmap_update_bits(info->map, REG(OCELOT_GPIO_INTR_ENA, info, gpio),\n\t\t\t   BIT(gpio % 32), 0);\n\tgpiochip_disable_irq(chip, gpio);\n}\n\nstatic void ocelot_irq_work(struct work_struct *work)\n{\n\tstruct ocelot_irq_work *w = container_of(work, struct ocelot_irq_work, irq_work);\n\tstruct irq_chip *parent_chip = irq_desc_get_chip(w->irq_desc);\n\tstruct gpio_chip *chip = irq_desc_get_chip_data(w->irq_desc);\n\tstruct irq_data *data = irq_desc_get_irq_data(w->irq_desc);\n\tunsigned int gpio = irqd_to_hwirq(data);\n\n\tlocal_irq_disable();\n\tchained_irq_enter(parent_chip, w->irq_desc);\n\tgeneric_handle_domain_irq(chip->irq.domain, gpio);\n\tchained_irq_exit(parent_chip, w->irq_desc);\n\tlocal_irq_enable();\n\n\tkfree(w);\n}\n\nstatic void ocelot_irq_unmask_level(struct irq_data *data)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\n\tstruct ocelot_pinctrl *info = gpiochip_get_data(chip);\n\tstruct irq_desc *desc = irq_data_to_desc(data);\n\tunsigned int gpio = irqd_to_hwirq(data);\n\tunsigned int bit = BIT(gpio % 32);\n\tbool ack = false, active = false;\n\tu8 trigger_level;\n\tint val;\n\n\ttrigger_level = irqd_get_trigger_type(data);\n\n\t \n\tregmap_read(info->map, REG(OCELOT_GPIO_IN, info, gpio), &val);\n\tif ((!(val & bit) && trigger_level == IRQ_TYPE_LEVEL_LOW) ||\n\t      (val & bit && trigger_level == IRQ_TYPE_LEVEL_HIGH))\n\t\tactive = true;\n\n\t \n\tregmap_read(info->map, REG(OCELOT_GPIO_INTR, info, gpio), &val);\n\tif (val & bit)\n\t\tack = true;\n\n\t \n\tif (!active && ack)\n\t\tregmap_write_bits(info->map, REG(OCELOT_GPIO_INTR, info, gpio),\n\t\t\t\t  bit, bit);\n\n\t \n\tgpiochip_enable_irq(chip, gpio);\n\tregmap_update_bits(info->map, REG(OCELOT_GPIO_INTR_ENA, info, gpio),\n\t\t\t   bit, bit);\n\n\t \n\tregmap_read(info->map, REG(OCELOT_GPIO_IN, info, gpio), &val);\n\tif ((!(val & bit) && trigger_level == IRQ_TYPE_LEVEL_LOW) ||\n\t      (val & bit && trigger_level == IRQ_TYPE_LEVEL_HIGH))\n\t\tactive = true;\n\n\tif (active) {\n\t\tstruct ocelot_irq_work *work;\n\n\t\twork = kmalloc(sizeof(*work), GFP_ATOMIC);\n\t\tif (!work)\n\t\t\treturn;\n\n\t\twork->irq_desc = desc;\n\t\tINIT_WORK(&work->irq_work, ocelot_irq_work);\n\t\tqueue_work(info->wq, &work->irq_work);\n\t}\n}\n\nstatic void ocelot_irq_unmask(struct irq_data *data)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\n\tstruct ocelot_pinctrl *info = gpiochip_get_data(chip);\n\tunsigned int gpio = irqd_to_hwirq(data);\n\n\tgpiochip_enable_irq(chip, gpio);\n\tregmap_update_bits(info->map, REG(OCELOT_GPIO_INTR_ENA, info, gpio),\n\t\t\t   BIT(gpio % 32), BIT(gpio % 32));\n}\n\nstatic void ocelot_irq_ack(struct irq_data *data)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\n\tstruct ocelot_pinctrl *info = gpiochip_get_data(chip);\n\tunsigned int gpio = irqd_to_hwirq(data);\n\n\tregmap_write_bits(info->map, REG(OCELOT_GPIO_INTR, info, gpio),\n\t\t\t  BIT(gpio % 32), BIT(gpio % 32));\n}\n\nstatic int ocelot_irq_set_type(struct irq_data *data, unsigned int type);\n\nstatic struct irq_chip ocelot_level_irqchip = {\n\t.name\t\t= \"gpio\",\n\t.irq_mask\t= ocelot_irq_mask,\n\t.irq_ack\t= ocelot_irq_ack,\n\t.irq_unmask\t= ocelot_irq_unmask_level,\n\t.flags\t\t= IRQCHIP_IMMUTABLE,\n\t.irq_set_type\t= ocelot_irq_set_type,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS\n};\n\nstatic struct irq_chip ocelot_irqchip = {\n\t.name\t\t= \"gpio\",\n\t.irq_mask\t= ocelot_irq_mask,\n\t.irq_ack\t= ocelot_irq_ack,\n\t.irq_unmask\t= ocelot_irq_unmask,\n\t.irq_set_type\t= ocelot_irq_set_type,\n\t.flags          = IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS\n};\n\nstatic int ocelot_irq_set_type(struct irq_data *data, unsigned int type)\n{\n\tif (type & (IRQ_TYPE_LEVEL_HIGH | IRQ_TYPE_LEVEL_LOW))\n\t\tirq_set_chip_handler_name_locked(data, &ocelot_level_irqchip,\n\t\t\t\t\t\t handle_level_irq, NULL);\n\tif (type & IRQ_TYPE_EDGE_BOTH)\n\t\tirq_set_chip_handler_name_locked(data, &ocelot_irqchip,\n\t\t\t\t\t\t handle_edge_irq, NULL);\n\n\treturn 0;\n}\n\nstatic void ocelot_irq_handler(struct irq_desc *desc)\n{\n\tstruct irq_chip *parent_chip = irq_desc_get_chip(desc);\n\tstruct gpio_chip *chip = irq_desc_get_handler_data(desc);\n\tstruct ocelot_pinctrl *info = gpiochip_get_data(chip);\n\tunsigned int id_reg = OCELOT_GPIO_INTR_IDENT * info->stride;\n\tunsigned int reg = 0, irq, i;\n\tunsigned long irqs;\n\n\tfor (i = 0; i < info->stride; i++) {\n\t\tregmap_read(info->map, id_reg + 4 * i, &reg);\n\t\tif (!reg)\n\t\t\tcontinue;\n\n\t\tchained_irq_enter(parent_chip, desc);\n\n\t\tirqs = reg;\n\n\t\tfor_each_set_bit(irq, &irqs,\n\t\t\t\t min(32U, info->desc->npins - 32 * i))\n\t\t\tgeneric_handle_domain_irq(chip->irq.domain, irq + 32 * i);\n\n\t\tchained_irq_exit(parent_chip, desc);\n\t}\n}\n\nstatic int ocelot_gpiochip_register(struct platform_device *pdev,\n\t\t\t\t    struct ocelot_pinctrl *info)\n{\n\tstruct gpio_chip *gc;\n\tstruct gpio_irq_chip *girq;\n\tint irq;\n\n\tinfo->gpio_chip = ocelot_gpiolib_chip;\n\n\tgc = &info->gpio_chip;\n\tgc->ngpio = info->desc->npins;\n\tgc->parent = &pdev->dev;\n\tgc->base = -1;\n\tgc->label = \"ocelot-gpio\";\n\n\tirq = platform_get_irq_optional(pdev, 0);\n\tif (irq > 0) {\n\t\tgirq = &gc->irq;\n\t\tgpio_irq_chip_set_chip(girq, &ocelot_irqchip);\n\t\tgirq->parent_handler = ocelot_irq_handler;\n\t\tgirq->num_parents = 1;\n\t\tgirq->parents = devm_kcalloc(&pdev->dev, 1,\n\t\t\t\t\t     sizeof(*girq->parents),\n\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!girq->parents)\n\t\t\treturn -ENOMEM;\n\t\tgirq->parents[0] = irq;\n\t\tgirq->default_type = IRQ_TYPE_NONE;\n\t\tgirq->handler = handle_edge_irq;\n\t}\n\n\treturn devm_gpiochip_add_data(&pdev->dev, gc, info);\n}\n\nstatic const struct of_device_id ocelot_pinctrl_of_match[] = {\n\t{ .compatible = \"mscc,luton-pinctrl\", .data = &luton_desc },\n\t{ .compatible = \"mscc,serval-pinctrl\", .data = &serval_desc },\n\t{ .compatible = \"mscc,ocelot-pinctrl\", .data = &ocelot_desc },\n\t{ .compatible = \"mscc,jaguar2-pinctrl\", .data = &jaguar2_desc },\n\t{ .compatible = \"mscc,servalt-pinctrl\", .data = &servalt_desc },\n\t{ .compatible = \"microchip,sparx5-pinctrl\", .data = &sparx5_desc },\n\t{ .compatible = \"microchip,lan966x-pinctrl\", .data = &lan966x_desc },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ocelot_pinctrl_of_match);\n\nstatic struct regmap *ocelot_pinctrl_create_pincfg(struct platform_device *pdev,\n\t\t\t\t\t\t   const struct ocelot_pinctrl *info)\n{\n\tvoid __iomem *base;\n\n\tconst struct regmap_config regmap_config = {\n\t\t.reg_bits = 32,\n\t\t.val_bits = 32,\n\t\t.reg_stride = 4,\n\t\t.max_register = info->desc->npins * 4,\n\t\t.name = \"pincfg\",\n\t};\n\n\tbase = devm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(base)) {\n\t\tdev_dbg(&pdev->dev, \"Failed to ioremap config registers (no extended pinconf)\\n\");\n\t\treturn NULL;\n\t}\n\n\treturn devm_regmap_init_mmio(&pdev->dev, base, &regmap_config);\n}\n\nstatic void ocelot_destroy_workqueue(void *data)\n{\n\tdestroy_workqueue(data);\n}\n\nstatic int ocelot_pinctrl_probe(struct platform_device *pdev)\n{\n\tconst struct ocelot_match_data *data;\n\tstruct device *dev = &pdev->dev;\n\tstruct ocelot_pinctrl *info;\n\tstruct reset_control *reset;\n\tstruct regmap *pincfg;\n\tint ret;\n\tstruct regmap_config regmap_config = {\n\t\t.reg_bits = 32,\n\t\t.val_bits = 32,\n\t\t.reg_stride = 4,\n\t};\n\n\tinfo = devm_kzalloc(dev, sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tdata = device_get_match_data(dev);\n\tif (!data)\n\t\treturn -EINVAL;\n\n\tinfo->desc = devm_kmemdup(dev, &data->desc, sizeof(*info->desc),\n\t\t\t\t  GFP_KERNEL);\n\tif (!info->desc)\n\t\treturn -ENOMEM;\n\n\tinfo->wq = alloc_ordered_workqueue(\"ocelot_ordered\", 0);\n\tif (!info->wq)\n\t\treturn -ENOMEM;\n\n\tret = devm_add_action_or_reset(dev, ocelot_destroy_workqueue,\n\t\t\t\t       info->wq);\n\tif (ret)\n\t\treturn ret;\n\n\tinfo->pincfg_data = &data->pincfg_data;\n\n\treset = devm_reset_control_get_optional_shared(dev, \"switch\");\n\tif (IS_ERR(reset))\n\t\treturn dev_err_probe(dev, PTR_ERR(reset),\n\t\t\t\t     \"Failed to get reset\\n\");\n\treset_control_reset(reset);\n\n\tinfo->stride = 1 + (info->desc->npins - 1) / 32;\n\n\tregmap_config.max_register = OCELOT_GPIO_SD_MAP * info->stride + 15 * 4;\n\n\tinfo->map = ocelot_regmap_from_resource(pdev, 0, &regmap_config);\n\tif (IS_ERR(info->map))\n\t\treturn dev_err_probe(dev, PTR_ERR(info->map),\n\t\t\t\t     \"Failed to create regmap\\n\");\n\tdev_set_drvdata(dev, info);\n\tinfo->dev = dev;\n\n\t \n\tif (info->desc->confops) {\n\t\tpincfg = ocelot_pinctrl_create_pincfg(pdev, info);\n\t\tif (IS_ERR(pincfg))\n\t\t\tdev_dbg(dev, \"Failed to create pincfg regmap\\n\");\n\t\telse\n\t\t\tinfo->pincfg = pincfg;\n\t}\n\n\tret = ocelot_pinctrl_register(pdev, info);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ocelot_gpiochip_register(pdev, info);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_info(dev, \"driver registered\\n\");\n\n\treturn 0;\n}\n\nstatic struct platform_driver ocelot_pinctrl_driver = {\n\t.driver = {\n\t\t.name = \"pinctrl-ocelot\",\n\t\t.of_match_table = of_match_ptr(ocelot_pinctrl_of_match),\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe = ocelot_pinctrl_probe,\n};\nmodule_platform_driver(ocelot_pinctrl_driver);\n\nMODULE_DESCRIPTION(\"Ocelot Chip Pinctrl Driver\");\nMODULE_LICENSE(\"Dual MIT/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}