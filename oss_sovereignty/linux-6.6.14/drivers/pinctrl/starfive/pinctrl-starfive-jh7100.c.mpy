{
  "module_name": "pinctrl-starfive-jh7100.c",
  "hash_id": "781ad503ea295deb32137f2ef3e0844bf5227c3999c65384c7e55332bace7a1c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/starfive/pinctrl-starfive-jh7100.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/clk.h>\n#include <linux/gpio/driver.h>\n#include <linux/io.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n#include <linux/seq_file.h>\n#include <linux/spinlock.h>\n\n#include <linux/pinctrl/consumer.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinmux.h>\n\n#include <dt-bindings/pinctrl/pinctrl-starfive-jh7100.h>\n\n#include \"../core.h\"\n#include \"../pinctrl-utils.h\"\n#include \"../pinmux.h\"\n#include \"../pinconf.h\"\n\n#define DRIVER_NAME \"pinctrl-starfive\"\n\n \n#define NR_GPIOS\t64\n\n \n#define GPIOEN\t\t0x000\n\n \n\n \n#define GPIOIS\t\t0x010\n\n \n#define GPIOIBE\t\t0x018\n\n \n#define GPIOIEV\t\t0x020\n\n \n#define GPIOIE\t\t0x028\n\n \n#define GPIOIC\t\t0x030\n\n \n#define GPIORIS\t\t0x038\n\n \n#define GPIOMIS\t\t0x040\n\n \n#define GPIODIN\t\t0x048\n\n \n#define GPON_DOUT_CFG\t0x050\n#define GPON_DOEN_CFG\t0x054\n\n \n#define GPI_CFG_OFFSET\t0x250\n\n \n#define PAD_SLEW_RATE_MASK\t\tGENMASK(11, 9)\n#define PAD_SLEW_RATE_POS\t\t9\n#define PAD_BIAS_STRONG_PULL_UP\t\tBIT(8)\n#define PAD_INPUT_ENABLE\t\tBIT(7)\n#define PAD_INPUT_SCHMITT_ENABLE\tBIT(6)\n#define PAD_BIAS_DISABLE\t\tBIT(5)\n#define PAD_BIAS_PULL_DOWN\t\tBIT(4)\n#define PAD_BIAS_MASK \\\n\t(PAD_BIAS_STRONG_PULL_UP | \\\n\t PAD_BIAS_DISABLE | \\\n\t PAD_BIAS_PULL_DOWN)\n#define PAD_DRIVE_STRENGTH_MASK\t\tGENMASK(3, 0)\n#define PAD_DRIVE_STRENGTH_POS\t\t0\n\n \n#define IO_PADSHARE_SEL\t\t\t0x1a0\n\n \n#define PAD_INVALID_GPIO\t\t0x10000\n\n \nstatic unsigned int starfive_pinmux_to_gpio(u32 v)\n{\n\treturn v & (NR_GPIOS - 1);\n}\n\nstatic u32 starfive_pinmux_to_dout(u32 v)\n{\n\treturn ((v & BIT(7)) << (31 - 7)) | ((v >> 24) & GENMASK(7, 0));\n}\n\nstatic u32 starfive_pinmux_to_doen(u32 v)\n{\n\treturn ((v & BIT(6)) << (31 - 6)) | ((v >> 16) & GENMASK(7, 0));\n}\n\nstatic u32 starfive_pinmux_to_din(u32 v)\n{\n\treturn (v >> 8) & GENMASK(7, 0);\n}\n\n \nstatic u32 starfive_drive_strength_to_max_mA(u16 ds)\n{\n\treturn 7 * ds + 14;\n}\n\nstatic u16 starfive_drive_strength_from_max_mA(u32 i)\n{\n\treturn (clamp(i, 14U, 63U) - 14) / 7;\n}\n\nstruct starfive_pinctrl {\n\tstruct gpio_chip gc;\n\tstruct pinctrl_gpio_range gpios;\n\traw_spinlock_t lock;\n\tvoid __iomem *base;\n\tvoid __iomem *padctl;\n\tstruct pinctrl_dev *pctl;\n\tstruct mutex mutex;  \n};\n\nstatic inline unsigned int starfive_pin_to_gpio(const struct starfive_pinctrl *sfp,\n\t\t\t\t\t\tunsigned int pin)\n{\n\treturn pin - sfp->gpios.pin_base;\n}\n\nstatic inline unsigned int starfive_gpio_to_pin(const struct starfive_pinctrl *sfp,\n\t\t\t\t\t\tunsigned int gpio)\n{\n\treturn sfp->gpios.pin_base + gpio;\n}\n\nstatic struct starfive_pinctrl *starfive_from_irq_data(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\n\treturn container_of(gc, struct starfive_pinctrl, gc);\n}\n\nstatic struct starfive_pinctrl *starfive_from_irq_desc(struct irq_desc *desc)\n{\n\tstruct gpio_chip *gc = irq_desc_get_handler_data(desc);\n\n\treturn container_of(gc, struct starfive_pinctrl, gc);\n}\n\nstatic const struct pinctrl_pin_desc starfive_pins[] = {\n\tPINCTRL_PIN(PAD_GPIO(0), \"GPIO[0]\"),\n\tPINCTRL_PIN(PAD_GPIO(1), \"GPIO[1]\"),\n\tPINCTRL_PIN(PAD_GPIO(2), \"GPIO[2]\"),\n\tPINCTRL_PIN(PAD_GPIO(3), \"GPIO[3]\"),\n\tPINCTRL_PIN(PAD_GPIO(4), \"GPIO[4]\"),\n\tPINCTRL_PIN(PAD_GPIO(5), \"GPIO[5]\"),\n\tPINCTRL_PIN(PAD_GPIO(6), \"GPIO[6]\"),\n\tPINCTRL_PIN(PAD_GPIO(7), \"GPIO[7]\"),\n\tPINCTRL_PIN(PAD_GPIO(8), \"GPIO[8]\"),\n\tPINCTRL_PIN(PAD_GPIO(9), \"GPIO[9]\"),\n\tPINCTRL_PIN(PAD_GPIO(10), \"GPIO[10]\"),\n\tPINCTRL_PIN(PAD_GPIO(11), \"GPIO[11]\"),\n\tPINCTRL_PIN(PAD_GPIO(12), \"GPIO[12]\"),\n\tPINCTRL_PIN(PAD_GPIO(13), \"GPIO[13]\"),\n\tPINCTRL_PIN(PAD_GPIO(14), \"GPIO[14]\"),\n\tPINCTRL_PIN(PAD_GPIO(15), \"GPIO[15]\"),\n\tPINCTRL_PIN(PAD_GPIO(16), \"GPIO[16]\"),\n\tPINCTRL_PIN(PAD_GPIO(17), \"GPIO[17]\"),\n\tPINCTRL_PIN(PAD_GPIO(18), \"GPIO[18]\"),\n\tPINCTRL_PIN(PAD_GPIO(19), \"GPIO[19]\"),\n\tPINCTRL_PIN(PAD_GPIO(20), \"GPIO[20]\"),\n\tPINCTRL_PIN(PAD_GPIO(21), \"GPIO[21]\"),\n\tPINCTRL_PIN(PAD_GPIO(22), \"GPIO[22]\"),\n\tPINCTRL_PIN(PAD_GPIO(23), \"GPIO[23]\"),\n\tPINCTRL_PIN(PAD_GPIO(24), \"GPIO[24]\"),\n\tPINCTRL_PIN(PAD_GPIO(25), \"GPIO[25]\"),\n\tPINCTRL_PIN(PAD_GPIO(26), \"GPIO[26]\"),\n\tPINCTRL_PIN(PAD_GPIO(27), \"GPIO[27]\"),\n\tPINCTRL_PIN(PAD_GPIO(28), \"GPIO[28]\"),\n\tPINCTRL_PIN(PAD_GPIO(29), \"GPIO[29]\"),\n\tPINCTRL_PIN(PAD_GPIO(30), \"GPIO[30]\"),\n\tPINCTRL_PIN(PAD_GPIO(31), \"GPIO[31]\"),\n\tPINCTRL_PIN(PAD_GPIO(32), \"GPIO[32]\"),\n\tPINCTRL_PIN(PAD_GPIO(33), \"GPIO[33]\"),\n\tPINCTRL_PIN(PAD_GPIO(34), \"GPIO[34]\"),\n\tPINCTRL_PIN(PAD_GPIO(35), \"GPIO[35]\"),\n\tPINCTRL_PIN(PAD_GPIO(36), \"GPIO[36]\"),\n\tPINCTRL_PIN(PAD_GPIO(37), \"GPIO[37]\"),\n\tPINCTRL_PIN(PAD_GPIO(38), \"GPIO[38]\"),\n\tPINCTRL_PIN(PAD_GPIO(39), \"GPIO[39]\"),\n\tPINCTRL_PIN(PAD_GPIO(40), \"GPIO[40]\"),\n\tPINCTRL_PIN(PAD_GPIO(41), \"GPIO[41]\"),\n\tPINCTRL_PIN(PAD_GPIO(42), \"GPIO[42]\"),\n\tPINCTRL_PIN(PAD_GPIO(43), \"GPIO[43]\"),\n\tPINCTRL_PIN(PAD_GPIO(44), \"GPIO[44]\"),\n\tPINCTRL_PIN(PAD_GPIO(45), \"GPIO[45]\"),\n\tPINCTRL_PIN(PAD_GPIO(46), \"GPIO[46]\"),\n\tPINCTRL_PIN(PAD_GPIO(47), \"GPIO[47]\"),\n\tPINCTRL_PIN(PAD_GPIO(48), \"GPIO[48]\"),\n\tPINCTRL_PIN(PAD_GPIO(49), \"GPIO[49]\"),\n\tPINCTRL_PIN(PAD_GPIO(50), \"GPIO[50]\"),\n\tPINCTRL_PIN(PAD_GPIO(51), \"GPIO[51]\"),\n\tPINCTRL_PIN(PAD_GPIO(52), \"GPIO[52]\"),\n\tPINCTRL_PIN(PAD_GPIO(53), \"GPIO[53]\"),\n\tPINCTRL_PIN(PAD_GPIO(54), \"GPIO[54]\"),\n\tPINCTRL_PIN(PAD_GPIO(55), \"GPIO[55]\"),\n\tPINCTRL_PIN(PAD_GPIO(56), \"GPIO[56]\"),\n\tPINCTRL_PIN(PAD_GPIO(57), \"GPIO[57]\"),\n\tPINCTRL_PIN(PAD_GPIO(58), \"GPIO[58]\"),\n\tPINCTRL_PIN(PAD_GPIO(59), \"GPIO[59]\"),\n\tPINCTRL_PIN(PAD_GPIO(60), \"GPIO[60]\"),\n\tPINCTRL_PIN(PAD_GPIO(61), \"GPIO[61]\"),\n\tPINCTRL_PIN(PAD_GPIO(62), \"GPIO[62]\"),\n\tPINCTRL_PIN(PAD_GPIO(63), \"GPIO[63]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(0), \"FUNC_SHARE[0]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(1), \"FUNC_SHARE[1]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(2), \"FUNC_SHARE[2]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(3), \"FUNC_SHARE[3]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(4), \"FUNC_SHARE[4]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(5), \"FUNC_SHARE[5]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(6), \"FUNC_SHARE[6]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(7), \"FUNC_SHARE[7]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(8), \"FUNC_SHARE[8]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(9), \"FUNC_SHARE[9]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(10), \"FUNC_SHARE[10]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(11), \"FUNC_SHARE[11]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(12), \"FUNC_SHARE[12]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(13), \"FUNC_SHARE[13]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(14), \"FUNC_SHARE[14]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(15), \"FUNC_SHARE[15]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(16), \"FUNC_SHARE[16]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(17), \"FUNC_SHARE[17]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(18), \"FUNC_SHARE[18]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(19), \"FUNC_SHARE[19]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(20), \"FUNC_SHARE[20]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(21), \"FUNC_SHARE[21]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(22), \"FUNC_SHARE[22]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(23), \"FUNC_SHARE[23]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(24), \"FUNC_SHARE[24]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(25), \"FUNC_SHARE[25]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(26), \"FUNC_SHARE[26]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(27), \"FUNC_SHARE[27]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(28), \"FUNC_SHARE[28]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(29), \"FUNC_SHARE[29]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(30), \"FUNC_SHARE[30]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(31), \"FUNC_SHARE[31]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(32), \"FUNC_SHARE[32]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(33), \"FUNC_SHARE[33]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(34), \"FUNC_SHARE[34]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(35), \"FUNC_SHARE[35]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(36), \"FUNC_SHARE[36]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(37), \"FUNC_SHARE[37]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(38), \"FUNC_SHARE[38]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(39), \"FUNC_SHARE[39]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(40), \"FUNC_SHARE[40]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(41), \"FUNC_SHARE[41]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(42), \"FUNC_SHARE[42]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(43), \"FUNC_SHARE[43]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(44), \"FUNC_SHARE[44]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(45), \"FUNC_SHARE[45]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(46), \"FUNC_SHARE[46]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(47), \"FUNC_SHARE[47]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(48), \"FUNC_SHARE[48]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(49), \"FUNC_SHARE[49]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(50), \"FUNC_SHARE[50]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(51), \"FUNC_SHARE[51]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(52), \"FUNC_SHARE[52]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(53), \"FUNC_SHARE[53]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(54), \"FUNC_SHARE[54]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(55), \"FUNC_SHARE[55]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(56), \"FUNC_SHARE[56]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(57), \"FUNC_SHARE[57]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(58), \"FUNC_SHARE[58]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(59), \"FUNC_SHARE[59]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(60), \"FUNC_SHARE[60]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(61), \"FUNC_SHARE[61]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(62), \"FUNC_SHARE[62]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(63), \"FUNC_SHARE[63]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(64), \"FUNC_SHARE[64]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(65), \"FUNC_SHARE[65]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(66), \"FUNC_SHARE[66]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(67), \"FUNC_SHARE[67]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(68), \"FUNC_SHARE[68]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(69), \"FUNC_SHARE[69]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(70), \"FUNC_SHARE[70]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(71), \"FUNC_SHARE[71]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(72), \"FUNC_SHARE[72]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(73), \"FUNC_SHARE[73]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(74), \"FUNC_SHARE[74]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(75), \"FUNC_SHARE[75]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(76), \"FUNC_SHARE[76]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(77), \"FUNC_SHARE[77]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(78), \"FUNC_SHARE[78]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(79), \"FUNC_SHARE[79]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(80), \"FUNC_SHARE[80]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(81), \"FUNC_SHARE[81]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(82), \"FUNC_SHARE[82]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(83), \"FUNC_SHARE[83]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(84), \"FUNC_SHARE[84]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(85), \"FUNC_SHARE[85]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(86), \"FUNC_SHARE[86]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(87), \"FUNC_SHARE[87]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(88), \"FUNC_SHARE[88]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(89), \"FUNC_SHARE[89]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(90), \"FUNC_SHARE[90]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(91), \"FUNC_SHARE[91]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(92), \"FUNC_SHARE[92]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(93), \"FUNC_SHARE[93]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(94), \"FUNC_SHARE[94]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(95), \"FUNC_SHARE[95]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(96), \"FUNC_SHARE[96]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(97), \"FUNC_SHARE[97]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(98), \"FUNC_SHARE[98]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(99), \"FUNC_SHARE[99]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(100), \"FUNC_SHARE[100]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(101), \"FUNC_SHARE[101]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(102), \"FUNC_SHARE[102]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(103), \"FUNC_SHARE[103]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(104), \"FUNC_SHARE[104]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(105), \"FUNC_SHARE[105]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(106), \"FUNC_SHARE[106]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(107), \"FUNC_SHARE[107]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(108), \"FUNC_SHARE[108]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(109), \"FUNC_SHARE[109]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(110), \"FUNC_SHARE[110]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(111), \"FUNC_SHARE[111]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(112), \"FUNC_SHARE[112]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(113), \"FUNC_SHARE[113]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(114), \"FUNC_SHARE[114]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(115), \"FUNC_SHARE[115]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(116), \"FUNC_SHARE[116]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(117), \"FUNC_SHARE[117]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(118), \"FUNC_SHARE[118]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(119), \"FUNC_SHARE[119]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(120), \"FUNC_SHARE[120]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(121), \"FUNC_SHARE[121]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(122), \"FUNC_SHARE[122]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(123), \"FUNC_SHARE[123]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(124), \"FUNC_SHARE[124]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(125), \"FUNC_SHARE[125]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(126), \"FUNC_SHARE[126]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(127), \"FUNC_SHARE[127]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(128), \"FUNC_SHARE[128]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(129), \"FUNC_SHARE[129]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(130), \"FUNC_SHARE[130]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(131), \"FUNC_SHARE[131]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(132), \"FUNC_SHARE[132]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(133), \"FUNC_SHARE[133]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(134), \"FUNC_SHARE[134]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(135), \"FUNC_SHARE[135]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(136), \"FUNC_SHARE[136]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(137), \"FUNC_SHARE[137]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(138), \"FUNC_SHARE[138]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(139), \"FUNC_SHARE[139]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(140), \"FUNC_SHARE[140]\"),\n\tPINCTRL_PIN(PAD_FUNC_SHARE(141), \"FUNC_SHARE[141]\"),\n};\n\n#ifdef CONFIG_DEBUG_FS\nstatic void starfive_pin_dbg_show(struct pinctrl_dev *pctldev,\n\t\t\t\t  struct seq_file *s,\n\t\t\t\t  unsigned int pin)\n{\n\tstruct starfive_pinctrl *sfp = pinctrl_dev_get_drvdata(pctldev);\n\tunsigned int gpio = starfive_pin_to_gpio(sfp, pin);\n\tvoid __iomem *reg;\n\tu32 dout, doen;\n\n\tif (gpio >= NR_GPIOS)\n\t\treturn;\n\n\treg = sfp->base + GPON_DOUT_CFG + 8 * gpio;\n\tdout = readl_relaxed(reg + 0x000);\n\tdoen = readl_relaxed(reg + 0x004);\n\n\tseq_printf(s, \"dout=%lu%s doen=%lu%s\",\n\t\t   dout & GENMASK(7, 0), (dout & BIT(31)) ? \"r\" : \"\",\n\t\t   doen & GENMASK(7, 0), (doen & BIT(31)) ? \"r\" : \"\");\n}\n#else\n#define starfive_pin_dbg_show NULL\n#endif\n\nstatic int starfive_dt_node_to_map(struct pinctrl_dev *pctldev,\n\t\t\t\t   struct device_node *np,\n\t\t\t\t   struct pinctrl_map **maps,\n\t\t\t\t   unsigned int *num_maps)\n{\n\tstruct starfive_pinctrl *sfp = pinctrl_dev_get_drvdata(pctldev);\n\tstruct device *dev = sfp->gc.parent;\n\tstruct device_node *child;\n\tstruct pinctrl_map *map;\n\tconst char **pgnames;\n\tconst char *grpname;\n\tu32 *pinmux;\n\tint ngroups;\n\tint *pins;\n\tint nmaps;\n\tint ret;\n\n\tnmaps = 0;\n\tngroups = 0;\n\tfor_each_available_child_of_node(np, child) {\n\t\tint npinmux = of_property_count_u32_elems(child, \"pinmux\");\n\t\tint npins   = of_property_count_u32_elems(child, \"pins\");\n\n\t\tif (npinmux > 0 && npins > 0) {\n\t\t\tdev_err(dev, \"invalid pinctrl group %pOFn.%pOFn: both pinmux and pins set\\n\",\n\t\t\t\tnp, child);\n\t\t\tof_node_put(child);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (npinmux == 0 && npins == 0) {\n\t\t\tdev_err(dev, \"invalid pinctrl group %pOFn.%pOFn: neither pinmux nor pins set\\n\",\n\t\t\t\tnp, child);\n\t\t\tof_node_put(child);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (npinmux > 0)\n\t\t\tnmaps += 2;\n\t\telse\n\t\t\tnmaps += 1;\n\t\tngroups += 1;\n\t}\n\n\tpgnames = devm_kcalloc(dev, ngroups, sizeof(*pgnames), GFP_KERNEL);\n\tif (!pgnames)\n\t\treturn -ENOMEM;\n\n\tmap = kcalloc(nmaps, sizeof(*map), GFP_KERNEL);\n\tif (!map)\n\t\treturn -ENOMEM;\n\n\tnmaps = 0;\n\tngroups = 0;\n\tmutex_lock(&sfp->mutex);\n\tfor_each_available_child_of_node(np, child) {\n\t\tint npins;\n\t\tint i;\n\n\t\tgrpname = devm_kasprintf(dev, GFP_KERNEL, \"%pOFn.%pOFn\", np, child);\n\t\tif (!grpname) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto put_child;\n\t\t}\n\n\t\tpgnames[ngroups++] = grpname;\n\n\t\tif ((npins = of_property_count_u32_elems(child, \"pinmux\")) > 0) {\n\t\t\tpins = devm_kcalloc(dev, npins, sizeof(*pins), GFP_KERNEL);\n\t\t\tif (!pins) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto put_child;\n\t\t\t}\n\n\t\t\tpinmux = devm_kcalloc(dev, npins, sizeof(*pinmux), GFP_KERNEL);\n\t\t\tif (!pinmux) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto put_child;\n\t\t\t}\n\n\t\t\tret = of_property_read_u32_array(child, \"pinmux\", pinmux, npins);\n\t\t\tif (ret)\n\t\t\t\tgoto put_child;\n\n\t\t\tfor (i = 0; i < npins; i++) {\n\t\t\t\tunsigned int gpio = starfive_pinmux_to_gpio(pinmux[i]);\n\n\t\t\t\tpins[i] = starfive_gpio_to_pin(sfp, gpio);\n\t\t\t}\n\n\t\t\tmap[nmaps].type = PIN_MAP_TYPE_MUX_GROUP;\n\t\t\tmap[nmaps].data.mux.function = np->name;\n\t\t\tmap[nmaps].data.mux.group = grpname;\n\t\t\tnmaps += 1;\n\t\t} else if ((npins = of_property_count_u32_elems(child, \"pins\")) > 0) {\n\t\t\tpins = devm_kcalloc(dev, npins, sizeof(*pins), GFP_KERNEL);\n\t\t\tif (!pins) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto put_child;\n\t\t\t}\n\n\t\t\tpinmux = NULL;\n\n\t\t\tfor (i = 0; i < npins; i++) {\n\t\t\t\tu32 v;\n\n\t\t\t\tret = of_property_read_u32_index(child, \"pins\", i, &v);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto put_child;\n\t\t\t\tpins[i] = v;\n\t\t\t}\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t\tgoto put_child;\n\t\t}\n\n\t\tret = pinctrl_generic_add_group(pctldev, grpname, pins, npins, pinmux);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"error adding group %s: %d\\n\", grpname, ret);\n\t\t\tgoto put_child;\n\t\t}\n\n\t\tret = pinconf_generic_parse_dt_config(child, pctldev,\n\t\t\t\t\t\t      &map[nmaps].data.configs.configs,\n\t\t\t\t\t\t      &map[nmaps].data.configs.num_configs);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"error parsing pin config of group %s: %d\\n\",\n\t\t\t\tgrpname, ret);\n\t\t\tgoto put_child;\n\t\t}\n\n\t\t \n\t\tif (map[nmaps].data.configs.num_configs == 0)\n\t\t\tcontinue;\n\n\t\tmap[nmaps].type = PIN_MAP_TYPE_CONFIGS_GROUP;\n\t\tmap[nmaps].data.configs.group_or_pin = grpname;\n\t\tnmaps += 1;\n\t}\n\n\tret = pinmux_generic_add_function(pctldev, np->name, pgnames, ngroups, NULL);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"error adding function %s: %d\\n\", np->name, ret);\n\t\tgoto free_map;\n\t}\n\n\t*maps = map;\n\t*num_maps = nmaps;\n\tmutex_unlock(&sfp->mutex);\n\treturn 0;\n\nput_child:\n\tof_node_put(child);\nfree_map:\n\tpinctrl_utils_free_map(pctldev, map, nmaps);\n\tmutex_unlock(&sfp->mutex);\n\treturn ret;\n}\n\nstatic const struct pinctrl_ops starfive_pinctrl_ops = {\n\t.get_groups_count = pinctrl_generic_get_group_count,\n\t.get_group_name = pinctrl_generic_get_group_name,\n\t.get_group_pins = pinctrl_generic_get_group_pins,\n\t.pin_dbg_show = starfive_pin_dbg_show,\n\t.dt_node_to_map = starfive_dt_node_to_map,\n\t.dt_free_map = pinctrl_utils_free_map,\n};\n\nstatic int starfive_set_mux(struct pinctrl_dev *pctldev,\n\t\t\t    unsigned int fsel, unsigned int gsel)\n{\n\tstruct starfive_pinctrl *sfp = pinctrl_dev_get_drvdata(pctldev);\n\tstruct device *dev = sfp->gc.parent;\n\tconst struct group_desc *group;\n\tconst u32 *pinmux;\n\tunsigned int i;\n\n\tgroup = pinctrl_generic_get_group(pctldev, gsel);\n\tif (!group)\n\t\treturn -EINVAL;\n\n\tpinmux = group->data;\n\tfor (i = 0; i < group->num_pins; i++) {\n\t\tu32 v = pinmux[i];\n\t\tunsigned int gpio = starfive_pinmux_to_gpio(v);\n\t\tu32 dout = starfive_pinmux_to_dout(v);\n\t\tu32 doen = starfive_pinmux_to_doen(v);\n\t\tu32 din = starfive_pinmux_to_din(v);\n\t\tvoid __iomem *reg_dout;\n\t\tvoid __iomem *reg_doen;\n\t\tvoid __iomem *reg_din;\n\t\tunsigned long flags;\n\n\t\tdev_dbg(dev, \"GPIO%u: dout=0x%x doen=0x%x din=0x%x\\n\",\n\t\t\tgpio, dout, doen, din);\n\n\t\treg_dout = sfp->base + GPON_DOUT_CFG + 8 * gpio;\n\t\treg_doen = sfp->base + GPON_DOEN_CFG + 8 * gpio;\n\t\tif (din != GPI_NONE)\n\t\t\treg_din = sfp->base + GPI_CFG_OFFSET + 4 * din;\n\t\telse\n\t\t\treg_din = NULL;\n\n\t\traw_spin_lock_irqsave(&sfp->lock, flags);\n\t\twritel_relaxed(dout, reg_dout);\n\t\twritel_relaxed(doen, reg_doen);\n\t\tif (reg_din)\n\t\t\twritel_relaxed(gpio + 2, reg_din);\n\t\traw_spin_unlock_irqrestore(&sfp->lock, flags);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct pinmux_ops starfive_pinmux_ops = {\n\t.get_functions_count = pinmux_generic_get_function_count,\n\t.get_function_name = pinmux_generic_get_function_name,\n\t.get_function_groups = pinmux_generic_get_function_groups,\n\t.set_mux = starfive_set_mux,\n\t.strict = true,\n};\n\nstatic u16 starfive_padctl_get(struct starfive_pinctrl *sfp,\n\t\t\t       unsigned int pin)\n{\n\tvoid __iomem *reg = sfp->padctl + 4 * (pin / 2);\n\tint shift = 16 * (pin % 2);\n\n\treturn readl_relaxed(reg) >> shift;\n}\n\nstatic void starfive_padctl_rmw(struct starfive_pinctrl *sfp,\n\t\t\t\tunsigned int pin,\n\t\t\t\tu16 _mask, u16 _value)\n{\n\tvoid __iomem *reg = sfp->padctl + 4 * (pin / 2);\n\tint shift = 16 * (pin % 2);\n\tu32 mask = (u32)_mask << shift;\n\tu32 value = (u32)_value << shift;\n\tunsigned long flags;\n\n\tdev_dbg(sfp->gc.parent, \"padctl_rmw(%u, 0x%03x, 0x%03x)\\n\", pin, _mask, _value);\n\n\traw_spin_lock_irqsave(&sfp->lock, flags);\n\tvalue |= readl_relaxed(reg) & ~mask;\n\twritel_relaxed(value, reg);\n\traw_spin_unlock_irqrestore(&sfp->lock, flags);\n}\n\n#define PIN_CONFIG_STARFIVE_STRONG_PULL_UP\t(PIN_CONFIG_END + 1)\n\nstatic const struct pinconf_generic_params starfive_pinconf_custom_params[] = {\n\t{ \"starfive,strong-pull-up\", PIN_CONFIG_STARFIVE_STRONG_PULL_UP, 1 },\n};\n\n#ifdef CONFIG_DEBUG_FS\nstatic const struct pin_config_item starfive_pinconf_custom_conf_items[] = {\n\tPCONFDUMP(PIN_CONFIG_STARFIVE_STRONG_PULL_UP, \"input bias strong pull-up\", NULL, false),\n};\n\nstatic_assert(ARRAY_SIZE(starfive_pinconf_custom_conf_items) ==\n\t      ARRAY_SIZE(starfive_pinconf_custom_params));\n#else\n#define starfive_pinconf_custom_conf_items NULL\n#endif\n\nstatic int starfive_pinconf_get(struct pinctrl_dev *pctldev,\n\t\t\t\tunsigned int pin, unsigned long *config)\n{\n\tstruct starfive_pinctrl *sfp = pinctrl_dev_get_drvdata(pctldev);\n\tint param = pinconf_to_config_param(*config);\n\tu16 value = starfive_padctl_get(sfp, pin);\n\tbool enabled;\n\tu32 arg;\n\n\tswitch (param) {\n\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\tenabled = value & PAD_BIAS_DISABLE;\n\t\targ = 0;\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\tenabled = value & PAD_BIAS_PULL_DOWN;\n\t\targ = 1;\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\tenabled = !(value & PAD_BIAS_MASK);\n\t\targ = 1;\n\t\tbreak;\n\tcase PIN_CONFIG_DRIVE_STRENGTH:\n\t\tenabled = value & PAD_DRIVE_STRENGTH_MASK;\n\t\targ = starfive_drive_strength_to_max_mA(value & PAD_DRIVE_STRENGTH_MASK);\n\t\tbreak;\n\tcase PIN_CONFIG_INPUT_ENABLE:\n\t\tenabled = value & PAD_INPUT_ENABLE;\n\t\targ = enabled;\n\t\tbreak;\n\tcase PIN_CONFIG_INPUT_SCHMITT_ENABLE:\n\t\tenabled = value & PAD_INPUT_SCHMITT_ENABLE;\n\t\targ = enabled;\n\t\tbreak;\n\tcase PIN_CONFIG_SLEW_RATE:\n\t\tenabled = value & PAD_SLEW_RATE_MASK;\n\t\targ = (value & PAD_SLEW_RATE_MASK) >> PAD_SLEW_RATE_POS;\n\t\tbreak;\n\tcase PIN_CONFIG_STARFIVE_STRONG_PULL_UP:\n\t\tenabled = value & PAD_BIAS_STRONG_PULL_UP;\n\t\targ = enabled;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\t*config = pinconf_to_config_packed(param, arg);\n\treturn enabled ? 0 : -EINVAL;\n}\n\nstatic int starfive_pinconf_group_get(struct pinctrl_dev *pctldev,\n\t\t\t\t      unsigned int gsel, unsigned long *config)\n{\n\tconst struct group_desc *group;\n\n\tgroup = pinctrl_generic_get_group(pctldev, gsel);\n\tif (!group)\n\t\treturn -EINVAL;\n\n\treturn starfive_pinconf_get(pctldev, group->pins[0], config);\n}\n\nstatic int starfive_pinconf_group_set(struct pinctrl_dev *pctldev,\n\t\t\t\t      unsigned int gsel,\n\t\t\t\t      unsigned long *configs,\n\t\t\t\t      unsigned int num_configs)\n{\n\tstruct starfive_pinctrl *sfp = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct group_desc *group;\n\tu16 mask, value;\n\tint i;\n\n\tgroup = pinctrl_generic_get_group(pctldev, gsel);\n\tif (!group)\n\t\treturn -EINVAL;\n\n\tmask = 0;\n\tvalue = 0;\n\tfor (i = 0; i < num_configs; i++) {\n\t\tint param = pinconf_to_config_param(configs[i]);\n\t\tu32 arg = pinconf_to_config_argument(configs[i]);\n\n\t\tswitch (param) {\n\t\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\t\tmask |= PAD_BIAS_MASK;\n\t\t\tvalue = (value & ~PAD_BIAS_MASK) | PAD_BIAS_DISABLE;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\t\tif (arg == 0)\n\t\t\t\treturn -ENOTSUPP;\n\t\t\tmask |= PAD_BIAS_MASK;\n\t\t\tvalue = (value & ~PAD_BIAS_MASK) | PAD_BIAS_PULL_DOWN;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\t\tif (arg == 0)\n\t\t\t\treturn -ENOTSUPP;\n\t\t\tmask |= PAD_BIAS_MASK;\n\t\t\tvalue = value & ~PAD_BIAS_MASK;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_DRIVE_STRENGTH:\n\t\t\tmask |= PAD_DRIVE_STRENGTH_MASK;\n\t\t\tvalue = (value & ~PAD_DRIVE_STRENGTH_MASK) |\n\t\t\t\tstarfive_drive_strength_from_max_mA(arg);\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_INPUT_ENABLE:\n\t\t\tmask |= PAD_INPUT_ENABLE;\n\t\t\tif (arg)\n\t\t\t\tvalue |= PAD_INPUT_ENABLE;\n\t\t\telse\n\t\t\t\tvalue &= ~PAD_INPUT_ENABLE;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_INPUT_SCHMITT_ENABLE:\n\t\t\tmask |= PAD_INPUT_SCHMITT_ENABLE;\n\t\t\tif (arg)\n\t\t\t\tvalue |= PAD_INPUT_SCHMITT_ENABLE;\n\t\t\telse\n\t\t\t\tvalue &= ~PAD_INPUT_SCHMITT_ENABLE;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_SLEW_RATE:\n\t\t\tmask |= PAD_SLEW_RATE_MASK;\n\t\t\tvalue = (value & ~PAD_SLEW_RATE_MASK) |\n\t\t\t\t((arg << PAD_SLEW_RATE_POS) & PAD_SLEW_RATE_MASK);\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_STARFIVE_STRONG_PULL_UP:\n\t\t\tif (arg) {\n\t\t\t\tmask |= PAD_BIAS_MASK;\n\t\t\t\tvalue = (value & ~PAD_BIAS_MASK) |\n\t\t\t\t\tPAD_BIAS_STRONG_PULL_UP;\n\t\t\t} else {\n\t\t\t\tmask |= PAD_BIAS_STRONG_PULL_UP;\n\t\t\t\tvalue = value & ~PAD_BIAS_STRONG_PULL_UP;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t}\n\n\tfor (i = 0; i < group->num_pins; i++)\n\t\tstarfive_padctl_rmw(sfp, group->pins[i], mask, value);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic void starfive_pinconf_dbg_show(struct pinctrl_dev *pctldev,\n\t\t\t\t      struct seq_file *s, unsigned int pin)\n{\n\tstruct starfive_pinctrl *sfp = pinctrl_dev_get_drvdata(pctldev);\n\tu16 value = starfive_padctl_get(sfp, pin);\n\n\tseq_printf(s, \" (0x%03x)\", value);\n}\n#else\n#define starfive_pinconf_dbg_show NULL\n#endif\n\nstatic const struct pinconf_ops starfive_pinconf_ops = {\n\t.pin_config_get = starfive_pinconf_get,\n\t.pin_config_group_get = starfive_pinconf_group_get,\n\t.pin_config_group_set = starfive_pinconf_group_set,\n\t.pin_config_dbg_show = starfive_pinconf_dbg_show,\n\t.is_generic = true,\n};\n\nstatic struct pinctrl_desc starfive_desc = {\n\t.name = DRIVER_NAME,\n\t.pins = starfive_pins,\n\t.npins = ARRAY_SIZE(starfive_pins),\n\t.pctlops = &starfive_pinctrl_ops,\n\t.pmxops = &starfive_pinmux_ops,\n\t.confops = &starfive_pinconf_ops,\n\t.owner = THIS_MODULE,\n\t.num_custom_params = ARRAY_SIZE(starfive_pinconf_custom_params),\n\t.custom_params = starfive_pinconf_custom_params,\n\t.custom_conf_items = starfive_pinconf_custom_conf_items,\n};\n\nstatic int starfive_gpio_request(struct gpio_chip *gc, unsigned int gpio)\n{\n\treturn pinctrl_gpio_request(gc->base + gpio);\n}\n\nstatic void starfive_gpio_free(struct gpio_chip *gc, unsigned int gpio)\n{\n\tpinctrl_gpio_free(gc->base + gpio);\n}\n\nstatic int starfive_gpio_get_direction(struct gpio_chip *gc, unsigned int gpio)\n{\n\tstruct starfive_pinctrl *sfp = container_of(gc, struct starfive_pinctrl, gc);\n\tvoid __iomem *doen = sfp->base + GPON_DOEN_CFG + 8 * gpio;\n\n\tif (readl_relaxed(doen) == GPO_ENABLE)\n\t\treturn GPIO_LINE_DIRECTION_OUT;\n\n\treturn GPIO_LINE_DIRECTION_IN;\n}\n\nstatic int starfive_gpio_direction_input(struct gpio_chip *gc,\n\t\t\t\t\t unsigned int gpio)\n{\n\tstruct starfive_pinctrl *sfp = container_of(gc, struct starfive_pinctrl, gc);\n\tvoid __iomem *doen = sfp->base + GPON_DOEN_CFG + 8 * gpio;\n\tunsigned long flags;\n\n\t \n\tstarfive_padctl_rmw(sfp, starfive_gpio_to_pin(sfp, gpio),\n\t\t\t    PAD_INPUT_ENABLE | PAD_INPUT_SCHMITT_ENABLE,\n\t\t\t    PAD_INPUT_ENABLE | PAD_INPUT_SCHMITT_ENABLE);\n\n\traw_spin_lock_irqsave(&sfp->lock, flags);\n\twritel_relaxed(GPO_DISABLE, doen);\n\traw_spin_unlock_irqrestore(&sfp->lock, flags);\n\treturn 0;\n}\n\nstatic int starfive_gpio_direction_output(struct gpio_chip *gc,\n\t\t\t\t\t  unsigned int gpio, int value)\n{\n\tstruct starfive_pinctrl *sfp = container_of(gc, struct starfive_pinctrl, gc);\n\tvoid __iomem *dout = sfp->base + GPON_DOUT_CFG + 8 * gpio;\n\tvoid __iomem *doen = sfp->base + GPON_DOEN_CFG + 8 * gpio;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&sfp->lock, flags);\n\twritel_relaxed(value, dout);\n\twritel_relaxed(GPO_ENABLE, doen);\n\traw_spin_unlock_irqrestore(&sfp->lock, flags);\n\n\t \n\tstarfive_padctl_rmw(sfp, starfive_gpio_to_pin(sfp, gpio),\n\t\t\t    PAD_BIAS_MASK | PAD_INPUT_ENABLE | PAD_INPUT_SCHMITT_ENABLE,\n\t\t\t    PAD_BIAS_DISABLE);\n\n\treturn 0;\n}\n\nstatic int starfive_gpio_get(struct gpio_chip *gc, unsigned int gpio)\n{\n\tstruct starfive_pinctrl *sfp = container_of(gc, struct starfive_pinctrl, gc);\n\tvoid __iomem *din = sfp->base + GPIODIN + 4 * (gpio / 32);\n\n\treturn !!(readl_relaxed(din) & BIT(gpio % 32));\n}\n\nstatic void starfive_gpio_set(struct gpio_chip *gc, unsigned int gpio,\n\t\t\t      int value)\n{\n\tstruct starfive_pinctrl *sfp = container_of(gc, struct starfive_pinctrl, gc);\n\tvoid __iomem *dout = sfp->base + GPON_DOUT_CFG + 8 * gpio;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&sfp->lock, flags);\n\twritel_relaxed(value, dout);\n\traw_spin_unlock_irqrestore(&sfp->lock, flags);\n}\n\nstatic int starfive_gpio_set_config(struct gpio_chip *gc, unsigned int gpio,\n\t\t\t\t    unsigned long config)\n{\n\tstruct starfive_pinctrl *sfp = container_of(gc, struct starfive_pinctrl, gc);\n\tu32 arg = pinconf_to_config_argument(config);\n\tu16 value;\n\tu16 mask;\n\n\tswitch (pinconf_to_config_param(config)) {\n\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\tmask  = PAD_BIAS_MASK;\n\t\tvalue = PAD_BIAS_DISABLE;\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\tif (arg == 0)\n\t\t\treturn -ENOTSUPP;\n\t\tmask  = PAD_BIAS_MASK;\n\t\tvalue = PAD_BIAS_PULL_DOWN;\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\tif (arg == 0)\n\t\t\treturn -ENOTSUPP;\n\t\tmask  = PAD_BIAS_MASK;\n\t\tvalue = 0;\n\t\tbreak;\n\tcase PIN_CONFIG_DRIVE_PUSH_PULL:\n\t\treturn 0;\n\tcase PIN_CONFIG_INPUT_ENABLE:\n\t\tmask  = PAD_INPUT_ENABLE;\n\t\tvalue = arg ? PAD_INPUT_ENABLE : 0;\n\t\tbreak;\n\tcase PIN_CONFIG_INPUT_SCHMITT_ENABLE:\n\t\tmask  = PAD_INPUT_SCHMITT_ENABLE;\n\t\tvalue = arg ? PAD_INPUT_SCHMITT_ENABLE : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\tstarfive_padctl_rmw(sfp, starfive_gpio_to_pin(sfp, gpio), mask, value);\n\treturn 0;\n}\n\nstatic int starfive_gpio_add_pin_ranges(struct gpio_chip *gc)\n{\n\tstruct starfive_pinctrl *sfp = container_of(gc, struct starfive_pinctrl, gc);\n\n\tsfp->gpios.name = sfp->gc.label;\n\tsfp->gpios.base = sfp->gc.base;\n\t \n\tsfp->gpios.npins = NR_GPIOS;\n\tsfp->gpios.gc = &sfp->gc;\n\tpinctrl_add_gpio_range(sfp->pctl, &sfp->gpios);\n\treturn 0;\n}\n\nstatic void starfive_irq_ack(struct irq_data *d)\n{\n\tstruct starfive_pinctrl *sfp = starfive_from_irq_data(d);\n\tirq_hw_number_t gpio = irqd_to_hwirq(d);\n\tvoid __iomem *ic = sfp->base + GPIOIC + 4 * (gpio / 32);\n\tu32 mask = BIT(gpio % 32);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&sfp->lock, flags);\n\twritel_relaxed(mask, ic);\n\traw_spin_unlock_irqrestore(&sfp->lock, flags);\n}\n\nstatic void starfive_irq_mask(struct irq_data *d)\n{\n\tstruct starfive_pinctrl *sfp = starfive_from_irq_data(d);\n\tirq_hw_number_t gpio = irqd_to_hwirq(d);\n\tvoid __iomem *ie = sfp->base + GPIOIE + 4 * (gpio / 32);\n\tu32 mask = BIT(gpio % 32);\n\tunsigned long flags;\n\tu32 value;\n\n\traw_spin_lock_irqsave(&sfp->lock, flags);\n\tvalue = readl_relaxed(ie) & ~mask;\n\twritel_relaxed(value, ie);\n\traw_spin_unlock_irqrestore(&sfp->lock, flags);\n\n\tgpiochip_disable_irq(&sfp->gc, gpio);\n}\n\nstatic void starfive_irq_mask_ack(struct irq_data *d)\n{\n\tstruct starfive_pinctrl *sfp = starfive_from_irq_data(d);\n\tirq_hw_number_t gpio = irqd_to_hwirq(d);\n\tvoid __iomem *ie = sfp->base + GPIOIE + 4 * (gpio / 32);\n\tvoid __iomem *ic = sfp->base + GPIOIC + 4 * (gpio / 32);\n\tu32 mask = BIT(gpio % 32);\n\tunsigned long flags;\n\tu32 value;\n\n\traw_spin_lock_irqsave(&sfp->lock, flags);\n\tvalue = readl_relaxed(ie) & ~mask;\n\twritel_relaxed(value, ie);\n\twritel_relaxed(mask, ic);\n\traw_spin_unlock_irqrestore(&sfp->lock, flags);\n}\n\nstatic void starfive_irq_unmask(struct irq_data *d)\n{\n\tstruct starfive_pinctrl *sfp = starfive_from_irq_data(d);\n\tirq_hw_number_t gpio = irqd_to_hwirq(d);\n\tvoid __iomem *ie = sfp->base + GPIOIE + 4 * (gpio / 32);\n\tu32 mask = BIT(gpio % 32);\n\tunsigned long flags;\n\tu32 value;\n\n\tgpiochip_enable_irq(&sfp->gc, gpio);\n\n\traw_spin_lock_irqsave(&sfp->lock, flags);\n\tvalue = readl_relaxed(ie) | mask;\n\twritel_relaxed(value, ie);\n\traw_spin_unlock_irqrestore(&sfp->lock, flags);\n}\n\nstatic int starfive_irq_set_type(struct irq_data *d, unsigned int trigger)\n{\n\tstruct starfive_pinctrl *sfp = starfive_from_irq_data(d);\n\tirq_hw_number_t gpio = irqd_to_hwirq(d);\n\tvoid __iomem *base = sfp->base + 4 * (gpio / 32);\n\tu32 mask = BIT(gpio % 32);\n\tu32 irq_type, edge_both, polarity;\n\tunsigned long flags;\n\n\tswitch (trigger) {\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tirq_type  = mask;  \n\t\tedge_both = 0;     \n\t\tpolarity  = mask;  \n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tirq_type  = mask;  \n\t\tedge_both = 0;     \n\t\tpolarity  = 0;     \n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\tirq_type  = mask;  \n\t\tedge_both = mask;  \n\t\tpolarity  = 0;     \n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tirq_type  = 0;     \n\t\tedge_both = 0;     \n\t\tpolarity  = mask;  \n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tirq_type  = 0;     \n\t\tedge_both = 0;     \n\t\tpolarity  = 0;     \n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (trigger & IRQ_TYPE_EDGE_BOTH)\n\t\tirq_set_handler_locked(d, handle_edge_irq);\n\telse\n\t\tirq_set_handler_locked(d, handle_level_irq);\n\n\traw_spin_lock_irqsave(&sfp->lock, flags);\n\tirq_type |= readl_relaxed(base + GPIOIS) & ~mask;\n\twritel_relaxed(irq_type, base + GPIOIS);\n\tedge_both |= readl_relaxed(base + GPIOIBE) & ~mask;\n\twritel_relaxed(edge_both, base + GPIOIBE);\n\tpolarity |= readl_relaxed(base + GPIOIEV) & ~mask;\n\twritel_relaxed(polarity, base + GPIOIEV);\n\traw_spin_unlock_irqrestore(&sfp->lock, flags);\n\treturn 0;\n}\n\nstatic const struct irq_chip starfive_irq_chip = {\n\t.name = \"StarFive GPIO\",\n\t.irq_ack = starfive_irq_ack,\n\t.irq_mask = starfive_irq_mask,\n\t.irq_mask_ack = starfive_irq_mask_ack,\n\t.irq_unmask = starfive_irq_unmask,\n\t.irq_set_type = starfive_irq_set_type,\n\t.flags = IRQCHIP_IMMUTABLE | IRQCHIP_SET_TYPE_MASKED,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic void starfive_gpio_irq_handler(struct irq_desc *desc)\n{\n\tstruct starfive_pinctrl *sfp = starfive_from_irq_desc(desc);\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tunsigned long mis;\n\tunsigned int pin;\n\n\tchained_irq_enter(chip, desc);\n\n\tmis = readl_relaxed(sfp->base + GPIOMIS + 0);\n\tfor_each_set_bit(pin, &mis, 32)\n\t\tgeneric_handle_domain_irq(sfp->gc.irq.domain, pin);\n\n\tmis = readl_relaxed(sfp->base + GPIOMIS + 4);\n\tfor_each_set_bit(pin, &mis, 32)\n\t\tgeneric_handle_domain_irq(sfp->gc.irq.domain, pin + 32);\n\n\tchained_irq_exit(chip, desc);\n}\n\nstatic int starfive_gpio_init_hw(struct gpio_chip *gc)\n{\n\tstruct starfive_pinctrl *sfp = container_of(gc, struct starfive_pinctrl, gc);\n\n\t \n\twritel(0, sfp->base + GPIOIE + 0);\n\twritel(0, sfp->base + GPIOIE + 4);\n\t \n\twritel(~0U, sfp->base + GPIOIC + 0);\n\twritel(~0U, sfp->base + GPIOIC + 4);\n\t \n\twritel(1, sfp->base + GPIOEN);\n\treturn 0;\n}\n\nstatic void starfive_disable_clock(void *data)\n{\n\tclk_disable_unprepare(data);\n}\n\nstatic int starfive_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct starfive_pinctrl *sfp;\n\tstruct reset_control *rst;\n\tstruct clk *clk;\n\tu32 value;\n\tint ret;\n\n\tsfp = devm_kzalloc(dev, sizeof(*sfp), GFP_KERNEL);\n\tif (!sfp)\n\t\treturn -ENOMEM;\n\n\tsfp->base = devm_platform_ioremap_resource_byname(pdev, \"gpio\");\n\tif (IS_ERR(sfp->base))\n\t\treturn PTR_ERR(sfp->base);\n\n\tsfp->padctl = devm_platform_ioremap_resource_byname(pdev, \"padctl\");\n\tif (IS_ERR(sfp->padctl))\n\t\treturn PTR_ERR(sfp->padctl);\n\n\tclk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(clk), \"could not get clock\\n\");\n\n\trst = devm_reset_control_get_exclusive(dev, NULL);\n\tif (IS_ERR(rst))\n\t\treturn dev_err_probe(dev, PTR_ERR(rst), \"could not get reset\\n\");\n\n\tret = clk_prepare_enable(clk);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"could not enable clock\\n\");\n\n\tret = devm_add_action_or_reset(dev, starfive_disable_clock, clk);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = reset_control_deassert(rst);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"could not deassert reset\\n\");\n\n\tplatform_set_drvdata(pdev, sfp);\n\tsfp->gc.parent = dev;\n\traw_spin_lock_init(&sfp->lock);\n\tmutex_init(&sfp->mutex);\n\n\tret = devm_pinctrl_register_and_init(dev, &starfive_desc, sfp, &sfp->pctl);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"could not register pinctrl driver\\n\");\n\n\tif (!of_property_read_u32(dev->of_node, \"starfive,signal-group\", &value)) {\n\t\tif (value > 6)\n\t\t\treturn dev_err_probe(dev, -EINVAL, \"invalid signal group %u\\n\", value);\n\t\twritel(value, sfp->padctl + IO_PADSHARE_SEL);\n\t}\n\n\tvalue = readl(sfp->padctl + IO_PADSHARE_SEL);\n\tswitch (value) {\n\tcase 0:\n\t\tsfp->gpios.pin_base = PAD_INVALID_GPIO;\n\t\tgoto out_pinctrl_enable;\n\tcase 1:\n\t\tsfp->gpios.pin_base = PAD_GPIO(0);\n\t\tbreak;\n\tcase 2:\n\t\tsfp->gpios.pin_base = PAD_FUNC_SHARE(72);\n\t\tbreak;\n\tcase 3:\n\t\tsfp->gpios.pin_base = PAD_FUNC_SHARE(70);\n\t\tbreak;\n\tcase 4: case 5: case 6:\n\t\tsfp->gpios.pin_base = PAD_FUNC_SHARE(0);\n\t\tbreak;\n\tdefault:\n\t\treturn dev_err_probe(dev, -EINVAL, \"invalid signal group %u\\n\", value);\n\t}\n\n\tsfp->gc.label = dev_name(dev);\n\tsfp->gc.owner = THIS_MODULE;\n\tsfp->gc.request = starfive_gpio_request;\n\tsfp->gc.free = starfive_gpio_free;\n\tsfp->gc.get_direction = starfive_gpio_get_direction;\n\tsfp->gc.direction_input = starfive_gpio_direction_input;\n\tsfp->gc.direction_output = starfive_gpio_direction_output;\n\tsfp->gc.get = starfive_gpio_get;\n\tsfp->gc.set = starfive_gpio_set;\n\tsfp->gc.set_config = starfive_gpio_set_config;\n\tsfp->gc.add_pin_ranges = starfive_gpio_add_pin_ranges;\n\tsfp->gc.base = -1;\n\tsfp->gc.ngpio = NR_GPIOS;\n\n\tgpio_irq_chip_set_chip(&sfp->gc.irq, &starfive_irq_chip);\n\tsfp->gc.irq.parent_handler = starfive_gpio_irq_handler;\n\tsfp->gc.irq.num_parents = 1;\n\tsfp->gc.irq.parents = devm_kcalloc(dev, sfp->gc.irq.num_parents,\n\t\t\t\t\t   sizeof(*sfp->gc.irq.parents), GFP_KERNEL);\n\tif (!sfp->gc.irq.parents)\n\t\treturn -ENOMEM;\n\tsfp->gc.irq.default_type = IRQ_TYPE_NONE;\n\tsfp->gc.irq.handler = handle_bad_irq;\n\tsfp->gc.irq.init_hw = starfive_gpio_init_hw;\n\n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\tsfp->gc.irq.parents[0] = ret;\n\n\tret = devm_gpiochip_add_data(dev, &sfp->gc, sfp);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"could not register gpiochip\\n\");\n\n\tirq_domain_set_pm_device(sfp->gc.irq.domain, dev);\n\nout_pinctrl_enable:\n\treturn pinctrl_enable(sfp->pctl);\n}\n\nstatic const struct of_device_id starfive_of_match[] = {\n\t{ .compatible = \"starfive,jh7100-pinctrl\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, starfive_of_match);\n\nstatic struct platform_driver starfive_pinctrl_driver = {\n\t.probe = starfive_probe,\n\t.driver = {\n\t\t.name = DRIVER_NAME,\n\t\t.of_match_table = starfive_of_match,\n\t},\n};\nmodule_platform_driver(starfive_pinctrl_driver);\n\nMODULE_DESCRIPTION(\"Pinctrl driver for StarFive SoCs\");\nMODULE_AUTHOR(\"Emil Renner Berthing <kernel@esmil.dk>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}