{
  "module_name": "pinctrl-starfive-jh7110.c",
  "hash_id": "ae1b46ddf645638012a7eb45c836db26b15db72758d7c4f2a91c333fb6213f59",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/starfive/pinctrl-starfive-jh7110.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/clk.h>\n#include <linux/gpio/driver.h>\n#include <linux/io.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n#include <linux/seq_file.h>\n#include <linux/spinlock.h>\n\n#include <linux/pinctrl/consumer.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinmux.h>\n\n#include <dt-bindings/pinctrl/starfive,jh7110-pinctrl.h>\n\n#include \"../core.h\"\n#include \"../pinctrl-utils.h\"\n#include \"../pinmux.h\"\n#include \"../pinconf.h\"\n#include \"pinctrl-starfive-jh7110.h\"\n\n \n#define JH7110_PADCFG_POS\tBIT(7)\n#define JH7110_PADCFG_SMT\tBIT(6)\n#define JH7110_PADCFG_SLEW\tBIT(5)\n#define JH7110_PADCFG_PD\tBIT(4)\n#define JH7110_PADCFG_PU\tBIT(3)\n#define JH7110_PADCFG_BIAS\t(JH7110_PADCFG_PD | JH7110_PADCFG_PU)\n#define JH7110_PADCFG_DS_MASK\tGENMASK(2, 1)\n#define JH7110_PADCFG_DS_2MA\t(0U << 1)\n#define JH7110_PADCFG_DS_4MA\tBIT(1)\n#define JH7110_PADCFG_DS_8MA\t(2U << 1)\n#define JH7110_PADCFG_DS_12MA\t(3U << 1)\n#define JH7110_PADCFG_IE\tBIT(0)\n\n \nstatic unsigned int jh7110_pinmux_din(u32 v)\n{\n\treturn (v & GENMASK(31, 24)) >> 24;\n}\n\nstatic u32 jh7110_pinmux_dout(u32 v)\n{\n\treturn (v & GENMASK(23, 16)) >> 16;\n}\n\nstatic u32 jh7110_pinmux_doen(u32 v)\n{\n\treturn (v & GENMASK(15, 10)) >> 10;\n}\n\nstatic u32 jh7110_pinmux_function(u32 v)\n{\n\treturn (v & GENMASK(9, 8)) >> 8;\n}\n\nstatic unsigned int jh7110_pinmux_pin(u32 v)\n{\n\treturn v & GENMASK(7, 0);\n}\n\nstatic struct jh7110_pinctrl *jh7110_from_irq_data(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\n\treturn container_of(gc, struct jh7110_pinctrl, gc);\n}\n\nstruct jh7110_pinctrl *jh7110_from_irq_desc(struct irq_desc *desc)\n{\n\tstruct gpio_chip *gc = irq_desc_get_handler_data(desc);\n\n\treturn container_of(gc, struct jh7110_pinctrl, gc);\n}\nEXPORT_SYMBOL_GPL(jh7110_from_irq_desc);\n\n#ifdef CONFIG_DEBUG_FS\nstatic void jh7110_pin_dbg_show(struct pinctrl_dev *pctldev,\n\t\t\t\tstruct seq_file *s, unsigned int pin)\n{\n\tstruct jh7110_pinctrl *sfp = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct jh7110_pinctrl_soc_info *info = sfp->info;\n\n\tseq_printf(s, \"%s\", dev_name(pctldev->dev));\n\n\tif (pin < sfp->gc.ngpio) {\n\t\tunsigned int offset = 4 * (pin / 4);\n\t\tunsigned int shift  = 8 * (pin % 4);\n\t\tu32 dout = readl_relaxed(sfp->base + info->dout_reg_base + offset);\n\t\tu32 doen = readl_relaxed(sfp->base + info->doen_reg_base + offset);\n\t\tu32 gpi = readl_relaxed(sfp->base + info->gpi_reg_base + offset);\n\n\t\tdout = (dout >> shift) & info->dout_mask;\n\t\tdoen = (doen >> shift) & info->doen_mask;\n\t\tgpi = ((gpi >> shift) - 2) & info->gpi_mask;\n\n\t\tseq_printf(s, \" dout=%u doen=%u din=%u\", dout, doen, gpi);\n\t}\n}\n#else\n#define jh7110_pin_dbg_show NULL\n#endif\n\nstatic int jh7110_dt_node_to_map(struct pinctrl_dev *pctldev,\n\t\t\t\t struct device_node *np,\n\t\t\t\t struct pinctrl_map **maps,\n\t\t\t\t unsigned int *num_maps)\n{\n\tstruct jh7110_pinctrl *sfp = pinctrl_dev_get_drvdata(pctldev);\n\tstruct device *dev = sfp->gc.parent;\n\tstruct device_node *child;\n\tstruct pinctrl_map *map;\n\tconst char **pgnames;\n\tconst char *grpname;\n\tint ngroups;\n\tint nmaps;\n\tint ret;\n\n\tngroups = 0;\n\tfor_each_available_child_of_node(np, child)\n\t\tngroups += 1;\n\tnmaps = 2 * ngroups;\n\n\tpgnames = devm_kcalloc(dev, ngroups, sizeof(*pgnames), GFP_KERNEL);\n\tif (!pgnames)\n\t\treturn -ENOMEM;\n\n\tmap = kcalloc(nmaps, sizeof(*map), GFP_KERNEL);\n\tif (!map)\n\t\treturn -ENOMEM;\n\n\tnmaps = 0;\n\tngroups = 0;\n\tmutex_lock(&sfp->mutex);\n\tfor_each_available_child_of_node(np, child) {\n\t\tint npins = of_property_count_u32_elems(child, \"pinmux\");\n\t\tint *pins;\n\t\tu32 *pinmux;\n\t\tint i;\n\n\t\tif (npins < 1) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"invalid pinctrl group %pOFn.%pOFn: pinmux not set\\n\",\n\t\t\t\tnp, child);\n\t\t\tret = -EINVAL;\n\t\t\tgoto put_child;\n\t\t}\n\n\t\tgrpname = devm_kasprintf(dev, GFP_KERNEL, \"%pOFn.%pOFn\", np, child);\n\t\tif (!grpname) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto put_child;\n\t\t}\n\n\t\tpgnames[ngroups++] = grpname;\n\n\t\tpins = devm_kcalloc(dev, npins, sizeof(*pins), GFP_KERNEL);\n\t\tif (!pins) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto put_child;\n\t\t}\n\n\t\tpinmux = devm_kcalloc(dev, npins, sizeof(*pinmux), GFP_KERNEL);\n\t\tif (!pinmux) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto put_child;\n\t\t}\n\n\t\tret = of_property_read_u32_array(child, \"pinmux\", pinmux, npins);\n\t\tif (ret)\n\t\t\tgoto put_child;\n\n\t\tfor (i = 0; i < npins; i++)\n\t\t\tpins[i] = jh7110_pinmux_pin(pinmux[i]);\n\n\t\tmap[nmaps].type = PIN_MAP_TYPE_MUX_GROUP;\n\t\tmap[nmaps].data.mux.function = np->name;\n\t\tmap[nmaps].data.mux.group = grpname;\n\t\tnmaps += 1;\n\n\t\tret = pinctrl_generic_add_group(pctldev, grpname,\n\t\t\t\t\t\tpins, npins, pinmux);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"error adding group %s: %d\\n\", grpname, ret);\n\t\t\tgoto put_child;\n\t\t}\n\n\t\tret = pinconf_generic_parse_dt_config(child, pctldev,\n\t\t\t\t\t\t      &map[nmaps].data.configs.configs,\n\t\t\t\t\t\t      &map[nmaps].data.configs.num_configs);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"error parsing pin config of group %s: %d\\n\",\n\t\t\t\tgrpname, ret);\n\t\t\tgoto put_child;\n\t\t}\n\n\t\t \n\t\tif (map[nmaps].data.configs.num_configs == 0)\n\t\t\tcontinue;\n\n\t\tmap[nmaps].type = PIN_MAP_TYPE_CONFIGS_GROUP;\n\t\tmap[nmaps].data.configs.group_or_pin = grpname;\n\t\tnmaps += 1;\n\t}\n\n\tret = pinmux_generic_add_function(pctldev, np->name,\n\t\t\t\t\t  pgnames, ngroups, NULL);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"error adding function %s: %d\\n\", np->name, ret);\n\t\tgoto free_map;\n\t}\n\tmutex_unlock(&sfp->mutex);\n\n\t*maps = map;\n\t*num_maps = nmaps;\n\treturn 0;\n\nput_child:\n\tof_node_put(child);\nfree_map:\n\tpinctrl_utils_free_map(pctldev, map, nmaps);\n\tmutex_unlock(&sfp->mutex);\n\treturn ret;\n}\n\nstatic const struct pinctrl_ops jh7110_pinctrl_ops = {\n\t.get_groups_count = pinctrl_generic_get_group_count,\n\t.get_group_name\t  = pinctrl_generic_get_group_name,\n\t.get_group_pins   = pinctrl_generic_get_group_pins,\n\t.pin_dbg_show\t  = jh7110_pin_dbg_show,\n\t.dt_node_to_map\t  = jh7110_dt_node_to_map,\n\t.dt_free_map\t  = pinctrl_utils_free_map,\n};\n\nvoid jh7110_set_gpiomux(struct jh7110_pinctrl *sfp, unsigned int pin,\n\t\t\tunsigned int din, u32 dout, u32 doen)\n{\n\tconst struct jh7110_pinctrl_soc_info *info = sfp->info;\n\n\tunsigned int offset = 4 * (pin / 4);\n\tunsigned int shift  = 8 * (pin % 4);\n\tu32 dout_mask = info->dout_mask << shift;\n\tu32 done_mask = info->doen_mask << shift;\n\tu32 ival, imask;\n\tvoid __iomem *reg_dout;\n\tvoid __iomem *reg_doen;\n\tvoid __iomem *reg_din;\n\tunsigned long flags;\n\n\treg_dout = sfp->base + info->dout_reg_base + offset;\n\treg_doen = sfp->base + info->doen_reg_base + offset;\n\tdout <<= shift;\n\tdoen <<= shift;\n\tif (din != GPI_NONE) {\n\t\tunsigned int ioffset = 4 * (din / 4);\n\t\tunsigned int ishift  = 8 * (din % 4);\n\n\t\treg_din = sfp->base + info->gpi_reg_base + ioffset;\n\t\tival = (pin + 2) << ishift;\n\t\timask = info->gpi_mask << ishift;\n\t} else {\n\t\treg_din = NULL;\n\t}\n\n\traw_spin_lock_irqsave(&sfp->lock, flags);\n\tdout |= readl_relaxed(reg_dout) & ~dout_mask;\n\twritel_relaxed(dout, reg_dout);\n\tdoen |= readl_relaxed(reg_doen) & ~done_mask;\n\twritel_relaxed(doen, reg_doen);\n\tif (reg_din) {\n\t\tival |= readl_relaxed(reg_din) & ~imask;\n\t\twritel_relaxed(ival, reg_din);\n\t}\n\traw_spin_unlock_irqrestore(&sfp->lock, flags);\n}\nEXPORT_SYMBOL_GPL(jh7110_set_gpiomux);\n\nstatic int jh7110_set_mux(struct pinctrl_dev *pctldev,\n\t\t\t  unsigned int fsel, unsigned int gsel)\n{\n\tstruct jh7110_pinctrl *sfp = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct jh7110_pinctrl_soc_info *info = sfp->info;\n\tconst struct group_desc *group;\n\tconst u32 *pinmux;\n\tunsigned int i;\n\n\tgroup = pinctrl_generic_get_group(pctldev, gsel);\n\tif (!group)\n\t\treturn -EINVAL;\n\n\tpinmux = group->data;\n\tfor (i = 0; i < group->num_pins; i++) {\n\t\tu32 v = pinmux[i];\n\n\t\tif (info->jh7110_set_one_pin_mux)\n\t\t\tinfo->jh7110_set_one_pin_mux(sfp,\n\t\t\t\t\tjh7110_pinmux_pin(v),\n\t\t\t\t\tjh7110_pinmux_din(v),\n\t\t\t\t\tjh7110_pinmux_dout(v),\n\t\t\t\t\tjh7110_pinmux_doen(v),\n\t\t\t\t\tjh7110_pinmux_function(v));\n\t}\n\n\treturn 0;\n}\n\nstatic const struct pinmux_ops jh7110_pinmux_ops = {\n\t.get_functions_count = pinmux_generic_get_function_count,\n\t.get_function_name   = pinmux_generic_get_function_name,\n\t.get_function_groups = pinmux_generic_get_function_groups,\n\t.set_mux\t     = jh7110_set_mux,\n\t.strict\t\t     = true,\n};\n\nstatic const u8 jh7110_drive_strength_mA[4] = { 2, 4, 8, 12 };\n\nstatic u32 jh7110_padcfg_ds_to_mA(u32 padcfg)\n{\n\treturn jh7110_drive_strength_mA[(padcfg >> 1) & 3U];\n}\n\nstatic u32 jh7110_padcfg_ds_from_mA(u32 v)\n{\n\tint i;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tif (v <= jh7110_drive_strength_mA[i])\n\t\t\tbreak;\n\t}\n\treturn i << 1;\n}\n\nstatic void jh7110_padcfg_rmw(struct jh7110_pinctrl *sfp,\n\t\t\t      unsigned int pin, u32 mask, u32 value)\n{\n\tconst struct jh7110_pinctrl_soc_info *info = sfp->info;\n\tvoid __iomem *reg;\n\tunsigned long flags;\n\tint padcfg_base;\n\n\tif (!info->jh7110_get_padcfg_base)\n\t\treturn;\n\n\tpadcfg_base = info->jh7110_get_padcfg_base(sfp, pin);\n\tif (padcfg_base < 0)\n\t\treturn;\n\n\treg = sfp->base + padcfg_base + 4 * pin;\n\tvalue &= mask;\n\n\traw_spin_lock_irqsave(&sfp->lock, flags);\n\tvalue |= readl_relaxed(reg) & ~mask;\n\twritel_relaxed(value, reg);\n\traw_spin_unlock_irqrestore(&sfp->lock, flags);\n}\n\nstatic int jh7110_pinconf_get(struct pinctrl_dev *pctldev,\n\t\t\t      unsigned int pin, unsigned long *config)\n{\n\tstruct jh7110_pinctrl *sfp = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct jh7110_pinctrl_soc_info *info = sfp->info;\n\tint param = pinconf_to_config_param(*config);\n\tu32 padcfg, arg;\n\tbool enabled;\n\tint padcfg_base;\n\n\tif (!info->jh7110_get_padcfg_base)\n\t\treturn 0;\n\n\tpadcfg_base = info->jh7110_get_padcfg_base(sfp, pin);\n\tif (padcfg_base < 0)\n\t\treturn 0;\n\n\tpadcfg = readl_relaxed(sfp->base + padcfg_base + 4 * pin);\n\tswitch (param) {\n\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\tenabled = !(padcfg & JH7110_PADCFG_BIAS);\n\t\targ = 0;\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\tenabled = padcfg & JH7110_PADCFG_PD;\n\t\targ = 1;\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\tenabled = padcfg & JH7110_PADCFG_PU;\n\t\targ = 1;\n\t\tbreak;\n\tcase PIN_CONFIG_DRIVE_STRENGTH:\n\t\tenabled = true;\n\t\targ = jh7110_padcfg_ds_to_mA(padcfg);\n\t\tbreak;\n\tcase PIN_CONFIG_INPUT_ENABLE:\n\t\tenabled = padcfg & JH7110_PADCFG_IE;\n\t\targ = enabled;\n\t\tbreak;\n\tcase PIN_CONFIG_INPUT_SCHMITT_ENABLE:\n\t\tenabled = padcfg & JH7110_PADCFG_SMT;\n\t\targ = enabled;\n\t\tbreak;\n\tcase PIN_CONFIG_SLEW_RATE:\n\t\tenabled = true;\n\t\targ = !!(padcfg & JH7110_PADCFG_SLEW);\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\t*config = pinconf_to_config_packed(param, arg);\n\treturn enabled ? 0 : -EINVAL;\n}\n\nstatic int jh7110_pinconf_group_get(struct pinctrl_dev *pctldev,\n\t\t\t\t    unsigned int gsel,\n\t\t\t\t    unsigned long *config)\n{\n\tconst struct group_desc *group;\n\n\tgroup = pinctrl_generic_get_group(pctldev, gsel);\n\tif (!group)\n\t\treturn -EINVAL;\n\n\treturn jh7110_pinconf_get(pctldev, group->pins[0], config);\n}\n\nstatic int jh7110_pinconf_group_set(struct pinctrl_dev *pctldev,\n\t\t\t\t    unsigned int gsel,\n\t\t\t\t    unsigned long *configs,\n\t\t\t\t    unsigned int num_configs)\n{\n\tstruct jh7110_pinctrl *sfp = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct group_desc *group;\n\tu16 mask, value;\n\tint i;\n\n\tgroup = pinctrl_generic_get_group(pctldev, gsel);\n\tif (!group)\n\t\treturn -EINVAL;\n\n\tmask = 0;\n\tvalue = 0;\n\tfor (i = 0; i < num_configs; i++) {\n\t\tint param = pinconf_to_config_param(configs[i]);\n\t\tu32 arg = pinconf_to_config_argument(configs[i]);\n\n\t\tswitch (param) {\n\t\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\t\tmask |= JH7110_PADCFG_BIAS;\n\t\t\tvalue &= ~JH7110_PADCFG_BIAS;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\t\tif (arg == 0)\n\t\t\t\treturn -ENOTSUPP;\n\t\t\tmask |= JH7110_PADCFG_BIAS;\n\t\t\tvalue = (value & ~JH7110_PADCFG_BIAS) | JH7110_PADCFG_PD;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\t\tif (arg == 0)\n\t\t\t\treturn -ENOTSUPP;\n\t\t\tmask |= JH7110_PADCFG_BIAS;\n\t\t\tvalue = (value & ~JH7110_PADCFG_BIAS) | JH7110_PADCFG_PU;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_DRIVE_STRENGTH:\n\t\t\tmask |= JH7110_PADCFG_DS_MASK;\n\t\t\tvalue = (value & ~JH7110_PADCFG_DS_MASK) |\n\t\t\t\tjh7110_padcfg_ds_from_mA(arg);\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_INPUT_ENABLE:\n\t\t\tmask |= JH7110_PADCFG_IE;\n\t\t\tif (arg)\n\t\t\t\tvalue |= JH7110_PADCFG_IE;\n\t\t\telse\n\t\t\t\tvalue &= ~JH7110_PADCFG_IE;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_INPUT_SCHMITT_ENABLE:\n\t\t\tmask |= JH7110_PADCFG_SMT;\n\t\t\tif (arg)\n\t\t\t\tvalue |= JH7110_PADCFG_SMT;\n\t\t\telse\n\t\t\t\tvalue &= ~JH7110_PADCFG_SMT;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_SLEW_RATE:\n\t\t\tmask |= JH7110_PADCFG_SLEW;\n\t\t\tif (arg)\n\t\t\t\tvalue |= JH7110_PADCFG_SLEW;\n\t\t\telse\n\t\t\t\tvalue &= ~JH7110_PADCFG_SLEW;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t}\n\n\tfor (i = 0; i < group->num_pins; i++)\n\t\tjh7110_padcfg_rmw(sfp, group->pins[i], mask, value);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic void jh7110_pinconf_dbg_show(struct pinctrl_dev *pctldev,\n\t\t\t\t    struct seq_file *s, unsigned int pin)\n{\n\tstruct jh7110_pinctrl *sfp = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct jh7110_pinctrl_soc_info *info = sfp->info;\n\tu32 value;\n\tint padcfg_base;\n\n\tif (!info->jh7110_get_padcfg_base)\n\t\treturn;\n\n\tpadcfg_base = info->jh7110_get_padcfg_base(sfp, pin);\n\tif (padcfg_base < 0)\n\t\treturn;\n\n\tvalue = readl_relaxed(sfp->base + padcfg_base + 4 * pin);\n\tseq_printf(s, \" (0x%02x)\", value);\n}\n#else\n#define jh7110_pinconf_dbg_show NULL\n#endif\n\nstatic const struct pinconf_ops jh7110_pinconf_ops = {\n\t.pin_config_get\t\t= jh7110_pinconf_get,\n\t.pin_config_group_get\t= jh7110_pinconf_group_get,\n\t.pin_config_group_set\t= jh7110_pinconf_group_set,\n\t.pin_config_dbg_show\t= jh7110_pinconf_dbg_show,\n\t.is_generic\t\t= true,\n};\n\nstatic int jh7110_gpio_request(struct gpio_chip *gc, unsigned int gpio)\n{\n\treturn pinctrl_gpio_request(gc->base + gpio);\n}\n\nstatic void jh7110_gpio_free(struct gpio_chip *gc, unsigned int gpio)\n{\n\tpinctrl_gpio_free(gc->base + gpio);\n}\n\nstatic int jh7110_gpio_get_direction(struct gpio_chip *gc,\n\t\t\t\t     unsigned int gpio)\n{\n\tstruct jh7110_pinctrl *sfp = container_of(gc,\n\t\t\tstruct jh7110_pinctrl, gc);\n\tconst struct jh7110_pinctrl_soc_info *info = sfp->info;\n\tunsigned int offset = 4 * (gpio / 4);\n\tunsigned int shift  = 8 * (gpio % 4);\n\tu32 doen = readl_relaxed(sfp->base + info->doen_reg_base + offset);\n\n\tdoen = (doen >> shift) & info->doen_mask;\n\n\treturn doen == GPOEN_ENABLE ?\n\t\tGPIO_LINE_DIRECTION_OUT : GPIO_LINE_DIRECTION_IN;\n}\n\nstatic int jh7110_gpio_direction_input(struct gpio_chip *gc,\n\t\t\t\t       unsigned int gpio)\n{\n\tstruct jh7110_pinctrl *sfp = container_of(gc,\n\t\t\tstruct jh7110_pinctrl, gc);\n\tconst struct jh7110_pinctrl_soc_info *info = sfp->info;\n\n\t \n\tjh7110_padcfg_rmw(sfp, gpio,\n\t\t\t  JH7110_PADCFG_IE | JH7110_PADCFG_SMT,\n\t\t\t  JH7110_PADCFG_IE | JH7110_PADCFG_SMT);\n\n\tif (info->jh7110_set_one_pin_mux)\n\t\tinfo->jh7110_set_one_pin_mux(sfp, gpio,\n\t\t\t\tGPI_NONE, GPOUT_LOW, GPOEN_DISABLE, 0);\n\n\treturn 0;\n}\n\nstatic int jh7110_gpio_direction_output(struct gpio_chip *gc,\n\t\t\t\t\tunsigned int gpio, int value)\n{\n\tstruct jh7110_pinctrl *sfp = container_of(gc,\n\t\t\tstruct jh7110_pinctrl, gc);\n\tconst struct jh7110_pinctrl_soc_info *info = sfp->info;\n\n\tif (info->jh7110_set_one_pin_mux)\n\t\tinfo->jh7110_set_one_pin_mux(sfp, gpio,\n\t\t\t\tGPI_NONE, value ? GPOUT_HIGH : GPOUT_LOW,\n\t\t\t\tGPOEN_ENABLE, 0);\n\n\t \n\tjh7110_padcfg_rmw(sfp, gpio,\n\t\t\t  JH7110_PADCFG_IE | JH7110_PADCFG_SMT |\n\t\t\t  JH7110_PADCFG_BIAS, 0);\n\treturn 0;\n}\n\nstatic int jh7110_gpio_get(struct gpio_chip *gc, unsigned int gpio)\n{\n\tstruct jh7110_pinctrl *sfp = container_of(gc,\n\t\t\tstruct jh7110_pinctrl, gc);\n\tconst struct jh7110_pinctrl_soc_info *info = sfp->info;\n\tvoid __iomem *reg = sfp->base + info->gpioin_reg_base\n\t\t\t+ 4 * (gpio / 32);\n\n\treturn !!(readl_relaxed(reg) & BIT(gpio % 32));\n}\n\nstatic void jh7110_gpio_set(struct gpio_chip *gc,\n\t\t\t    unsigned int gpio, int value)\n{\n\tstruct jh7110_pinctrl *sfp = container_of(gc,\n\t\t\tstruct jh7110_pinctrl, gc);\n\tconst struct jh7110_pinctrl_soc_info *info = sfp->info;\n\tunsigned int offset = 4 * (gpio / 4);\n\tunsigned int shift  = 8 * (gpio % 4);\n\tvoid __iomem *reg_dout = sfp->base + info->dout_reg_base + offset;\n\tu32 dout = (value ? GPOUT_HIGH : GPOUT_LOW) << shift;\n\tu32 mask = info->dout_mask << shift;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&sfp->lock, flags);\n\tdout |= readl_relaxed(reg_dout) & ~mask;\n\twritel_relaxed(dout, reg_dout);\n\traw_spin_unlock_irqrestore(&sfp->lock, flags);\n}\n\nstatic int jh7110_gpio_set_config(struct gpio_chip *gc,\n\t\t\t\t  unsigned int gpio, unsigned long config)\n{\n\tstruct jh7110_pinctrl *sfp = container_of(gc,\n\t\t\tstruct jh7110_pinctrl, gc);\n\tu32 arg = pinconf_to_config_argument(config);\n\tu32 value;\n\tu32 mask;\n\n\tswitch (pinconf_to_config_param(config)) {\n\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\tmask  = JH7110_PADCFG_BIAS;\n\t\tvalue = 0;\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\tif (arg == 0)\n\t\t\treturn -ENOTSUPP;\n\t\tmask  = JH7110_PADCFG_BIAS;\n\t\tvalue = JH7110_PADCFG_PD;\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\tif (arg == 0)\n\t\t\treturn -ENOTSUPP;\n\t\tmask  = JH7110_PADCFG_BIAS;\n\t\tvalue = JH7110_PADCFG_PU;\n\t\tbreak;\n\tcase PIN_CONFIG_DRIVE_PUSH_PULL:\n\t\treturn 0;\n\tcase PIN_CONFIG_INPUT_ENABLE:\n\t\tmask  = JH7110_PADCFG_IE;\n\t\tvalue = arg ? JH7110_PADCFG_IE : 0;\n\t\tbreak;\n\tcase PIN_CONFIG_INPUT_SCHMITT_ENABLE:\n\t\tmask  = JH7110_PADCFG_SMT;\n\t\tvalue = arg ? JH7110_PADCFG_SMT : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\tjh7110_padcfg_rmw(sfp, gpio, mask, value);\n\treturn 0;\n}\n\nstatic int jh7110_gpio_add_pin_ranges(struct gpio_chip *gc)\n{\n\tstruct jh7110_pinctrl *sfp = container_of(gc,\n\t\t\tstruct jh7110_pinctrl, gc);\n\n\tsfp->gpios.name = sfp->gc.label;\n\tsfp->gpios.base = sfp->gc.base;\n\tsfp->gpios.pin_base = 0;\n\tsfp->gpios.npins = sfp->gc.ngpio;\n\tsfp->gpios.gc = &sfp->gc;\n\tpinctrl_add_gpio_range(sfp->pctl, &sfp->gpios);\n\treturn 0;\n}\n\nstatic void jh7110_irq_ack(struct irq_data *d)\n{\n\tstruct jh7110_pinctrl *sfp = jh7110_from_irq_data(d);\n\tconst struct jh7110_gpio_irq_reg *irq_reg = sfp->info->irq_reg;\n\tirq_hw_number_t gpio = irqd_to_hwirq(d);\n\tvoid __iomem *ic = sfp->base + irq_reg->ic_reg_base\n\t\t+ 4 * (gpio / 32);\n\tu32 mask = BIT(gpio % 32);\n\tunsigned long flags;\n\tu32 value;\n\n\traw_spin_lock_irqsave(&sfp->lock, flags);\n\tvalue = readl_relaxed(ic) & ~mask;\n\twritel_relaxed(value, ic);\n\twritel_relaxed(value | mask, ic);\n\traw_spin_unlock_irqrestore(&sfp->lock, flags);\n}\n\nstatic void jh7110_irq_mask(struct irq_data *d)\n{\n\tstruct jh7110_pinctrl *sfp = jh7110_from_irq_data(d);\n\tconst struct jh7110_gpio_irq_reg *irq_reg = sfp->info->irq_reg;\n\tirq_hw_number_t gpio = irqd_to_hwirq(d);\n\tvoid __iomem *ie = sfp->base + irq_reg->ie_reg_base\n\t\t+ 4 * (gpio / 32);\n\tu32 mask = BIT(gpio % 32);\n\tunsigned long flags;\n\tu32 value;\n\n\traw_spin_lock_irqsave(&sfp->lock, flags);\n\tvalue = readl_relaxed(ie) & ~mask;\n\twritel_relaxed(value, ie);\n\traw_spin_unlock_irqrestore(&sfp->lock, flags);\n\n\tgpiochip_disable_irq(&sfp->gc, d->hwirq);\n}\n\nstatic void jh7110_irq_mask_ack(struct irq_data *d)\n{\n\tstruct jh7110_pinctrl *sfp = jh7110_from_irq_data(d);\n\tconst struct jh7110_gpio_irq_reg *irq_reg = sfp->info->irq_reg;\n\tirq_hw_number_t gpio = irqd_to_hwirq(d);\n\tvoid __iomem *ie = sfp->base + irq_reg->ie_reg_base\n\t\t+ 4 * (gpio / 32);\n\tvoid __iomem *ic = sfp->base + irq_reg->ic_reg_base\n\t\t+ 4 * (gpio / 32);\n\tu32 mask = BIT(gpio % 32);\n\tunsigned long flags;\n\tu32 value;\n\n\traw_spin_lock_irqsave(&sfp->lock, flags);\n\tvalue = readl_relaxed(ie) & ~mask;\n\twritel_relaxed(value, ie);\n\n\tvalue = readl_relaxed(ic) & ~mask;\n\twritel_relaxed(value, ic);\n\twritel_relaxed(value | mask, ic);\n\traw_spin_unlock_irqrestore(&sfp->lock, flags);\n}\n\nstatic void jh7110_irq_unmask(struct irq_data *d)\n{\n\tstruct jh7110_pinctrl *sfp = jh7110_from_irq_data(d);\n\tconst struct jh7110_gpio_irq_reg *irq_reg = sfp->info->irq_reg;\n\tirq_hw_number_t gpio = irqd_to_hwirq(d);\n\tvoid __iomem *ie = sfp->base + irq_reg->ie_reg_base\n\t\t+ 4 * (gpio / 32);\n\tu32 mask = BIT(gpio % 32);\n\tunsigned long flags;\n\tu32 value;\n\n\tgpiochip_enable_irq(&sfp->gc, d->hwirq);\n\n\traw_spin_lock_irqsave(&sfp->lock, flags);\n\tvalue = readl_relaxed(ie) | mask;\n\twritel_relaxed(value, ie);\n\traw_spin_unlock_irqrestore(&sfp->lock, flags);\n}\n\nstatic int jh7110_irq_set_type(struct irq_data *d, unsigned int trigger)\n{\n\tstruct jh7110_pinctrl *sfp = jh7110_from_irq_data(d);\n\tconst struct jh7110_gpio_irq_reg *irq_reg = sfp->info->irq_reg;\n\tirq_hw_number_t gpio = irqd_to_hwirq(d);\n\tvoid __iomem *base = sfp->base + 4 * (gpio / 32);\n\tu32 mask = BIT(gpio % 32);\n\tu32 irq_type, edge_both, polarity;\n\tunsigned long flags;\n\n\tswitch (trigger) {\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tirq_type  = mask;  \n\t\tedge_both = 0;     \n\t\tpolarity  = mask;  \n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tirq_type  = mask;  \n\t\tedge_both = 0;     \n\t\tpolarity  = 0;     \n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\tirq_type  = mask;  \n\t\tedge_both = mask;  \n\t\tpolarity  = 0;     \n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tirq_type  = 0;     \n\t\tedge_both = 0;     \n\t\tpolarity  = mask;  \n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tirq_type  = 0;     \n\t\tedge_both = 0;     \n\t\tpolarity  = 0;     \n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (trigger & IRQ_TYPE_EDGE_BOTH)\n\t\tirq_set_handler_locked(d, handle_edge_irq);\n\telse\n\t\tirq_set_handler_locked(d, handle_level_irq);\n\n\traw_spin_lock_irqsave(&sfp->lock, flags);\n\tirq_type |= readl_relaxed(base + irq_reg->is_reg_base) & ~mask;\n\twritel_relaxed(irq_type, base + irq_reg->is_reg_base);\n\n\tedge_both |= readl_relaxed(base + irq_reg->ibe_reg_base) & ~mask;\n\twritel_relaxed(edge_both, base + irq_reg->ibe_reg_base);\n\n\tpolarity |= readl_relaxed(base + irq_reg->iev_reg_base) & ~mask;\n\twritel_relaxed(polarity, base + irq_reg->iev_reg_base);\n\traw_spin_unlock_irqrestore(&sfp->lock, flags);\n\treturn 0;\n}\n\nstatic struct irq_chip jh7110_irq_chip = {\n\t.irq_ack      = jh7110_irq_ack,\n\t.irq_mask     = jh7110_irq_mask,\n\t.irq_mask_ack = jh7110_irq_mask_ack,\n\t.irq_unmask   = jh7110_irq_unmask,\n\t.irq_set_type = jh7110_irq_set_type,\n\t.flags\t      = IRQCHIP_IMMUTABLE | IRQCHIP_SET_TYPE_MASKED,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic void jh7110_disable_clock(void *data)\n{\n\tclk_disable_unprepare(data);\n}\n\nint jh7110_pinctrl_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tconst struct jh7110_pinctrl_soc_info *info;\n\tstruct jh7110_pinctrl *sfp;\n\tstruct pinctrl_desc *jh7110_pinctrl_desc;\n\tstruct reset_control *rst;\n\tstruct clk *clk;\n\tint ret;\n\n\tinfo = of_device_get_match_data(&pdev->dev);\n\tif (!info)\n\t\treturn -ENODEV;\n\n\tif (!info->pins || !info->npins) {\n\t\tdev_err(dev, \"wrong pinctrl info\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsfp = devm_kzalloc(dev, sizeof(*sfp), GFP_KERNEL);\n\tif (!sfp)\n\t\treturn -ENOMEM;\n\n#if IS_ENABLED(CONFIG_PM_SLEEP)\n\tsfp->saved_regs = devm_kcalloc(dev, info->nsaved_regs,\n\t\t\t\t       sizeof(*sfp->saved_regs), GFP_KERNEL);\n\tif (!sfp->saved_regs)\n\t\treturn -ENOMEM;\n#endif\n\n\tsfp->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(sfp->base))\n\t\treturn PTR_ERR(sfp->base);\n\n\tclk = devm_clk_get_optional(dev, NULL);\n\tif (IS_ERR(clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(clk), \"could not get clock\\n\");\n\n\trst = devm_reset_control_get_exclusive(dev, NULL);\n\tif (IS_ERR(rst))\n\t\treturn dev_err_probe(dev, PTR_ERR(rst), \"could not get reset\\n\");\n\n\t \n\tret = reset_control_deassert(rst);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"could not deassert reset\\n\");\n\n\tif (clk) {\n\t\tret = clk_prepare_enable(clk);\n\t\tif (ret)\n\t\t\treturn dev_err_probe(dev, ret, \"could not enable clock\\n\");\n\n\t\tret = devm_add_action_or_reset(dev, jh7110_disable_clock, clk);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tjh7110_pinctrl_desc = devm_kzalloc(&pdev->dev,\n\t\t\t\t\t   sizeof(*jh7110_pinctrl_desc),\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!jh7110_pinctrl_desc)\n\t\treturn -ENOMEM;\n\n\tjh7110_pinctrl_desc->name = dev_name(dev);\n\tjh7110_pinctrl_desc->pins = info->pins;\n\tjh7110_pinctrl_desc->npins = info->npins;\n\tjh7110_pinctrl_desc->pctlops = &jh7110_pinctrl_ops;\n\tjh7110_pinctrl_desc->pmxops = &jh7110_pinmux_ops;\n\tjh7110_pinctrl_desc->confops = &jh7110_pinconf_ops;\n\tjh7110_pinctrl_desc->owner = THIS_MODULE;\n\n\tsfp->info = info;\n\tsfp->dev = dev;\n\tplatform_set_drvdata(pdev, sfp);\n\tsfp->gc.parent = dev;\n\traw_spin_lock_init(&sfp->lock);\n\tmutex_init(&sfp->mutex);\n\n\tret = devm_pinctrl_register_and_init(dev,\n\t\t\t\t\t     jh7110_pinctrl_desc,\n\t\t\t\t\t     sfp, &sfp->pctl);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t\"could not register pinctrl driver\\n\");\n\n\tsfp->gc.label = dev_name(dev);\n\tsfp->gc.owner = THIS_MODULE;\n\tsfp->gc.request = jh7110_gpio_request;\n\tsfp->gc.free = jh7110_gpio_free;\n\tsfp->gc.get_direction = jh7110_gpio_get_direction;\n\tsfp->gc.direction_input = jh7110_gpio_direction_input;\n\tsfp->gc.direction_output = jh7110_gpio_direction_output;\n\tsfp->gc.get = jh7110_gpio_get;\n\tsfp->gc.set = jh7110_gpio_set;\n\tsfp->gc.set_config = jh7110_gpio_set_config;\n\tsfp->gc.add_pin_ranges = jh7110_gpio_add_pin_ranges;\n\tsfp->gc.base = info->gc_base;\n\tsfp->gc.ngpio = info->ngpios;\n\n\tjh7110_irq_chip.name = sfp->gc.label;\n\tgpio_irq_chip_set_chip(&sfp->gc.irq, &jh7110_irq_chip);\n\tsfp->gc.irq.parent_handler = info->jh7110_gpio_irq_handler;\n\tsfp->gc.irq.num_parents = 1;\n\tsfp->gc.irq.parents = devm_kcalloc(dev, sfp->gc.irq.num_parents,\n\t\t\t\t\t   sizeof(*sfp->gc.irq.parents),\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!sfp->gc.irq.parents)\n\t\treturn -ENOMEM;\n\tsfp->gc.irq.default_type = IRQ_TYPE_NONE;\n\tsfp->gc.irq.handler = handle_bad_irq;\n\tsfp->gc.irq.init_hw = info->jh7110_gpio_init_hw;\n\n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\tsfp->gc.irq.parents[0] = ret;\n\n\tret = devm_gpiochip_add_data(dev, &sfp->gc, sfp);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"could not register gpiochip\\n\");\n\n\tdev_info(dev, \"StarFive GPIO chip registered %d GPIOs\\n\", sfp->gc.ngpio);\n\n\treturn pinctrl_enable(sfp->pctl);\n}\nEXPORT_SYMBOL_GPL(jh7110_pinctrl_probe);\n\nstatic int jh7110_pinctrl_suspend(struct device *dev)\n{\n\tstruct jh7110_pinctrl *sfp = dev_get_drvdata(dev);\n\tunsigned long flags;\n\tunsigned int i;\n\n\traw_spin_lock_irqsave(&sfp->lock, flags);\n\tfor (i = 0 ; i < sfp->info->nsaved_regs ; i++)\n\t\tsfp->saved_regs[i] = readl_relaxed(sfp->base + 4 * i);\n\n\traw_spin_unlock_irqrestore(&sfp->lock, flags);\n\treturn 0;\n}\n\nstatic int jh7110_pinctrl_resume(struct device *dev)\n{\n\tstruct jh7110_pinctrl *sfp = dev_get_drvdata(dev);\n\tunsigned long flags;\n\tunsigned int i;\n\n\traw_spin_lock_irqsave(&sfp->lock, flags);\n\tfor (i = 0 ; i < sfp->info->nsaved_regs ; i++)\n\t\twritel_relaxed(sfp->saved_regs[i], sfp->base + 4 * i);\n\n\traw_spin_unlock_irqrestore(&sfp->lock, flags);\n\treturn 0;\n}\n\nconst struct dev_pm_ops jh7110_pinctrl_pm_ops = {\n\tLATE_SYSTEM_SLEEP_PM_OPS(jh7110_pinctrl_suspend, jh7110_pinctrl_resume)\n};\nEXPORT_SYMBOL_GPL(jh7110_pinctrl_pm_ops);\n\nMODULE_DESCRIPTION(\"Pinctrl driver for the StarFive JH7110 SoC\");\nMODULE_AUTHOR(\"Emil Renner Berthing <kernel@esmil.dk>\");\nMODULE_AUTHOR(\"Jianlong Huang <jianlong.huang@starfivetech.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}