{
  "module_name": "pinctrl-equilibrium.c",
  "hash_id": "eb48815cc3c3d131e461c503c3c610c96edc0680fd8d1c1a4b1faaf943eac1bc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/pinctrl-equilibrium.c",
  "human_readable_source": "\n \n\n#include <linux/gpio/driver.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinconf-generic.h>\n#include <linux/pinctrl/pinmux.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n\n#include \"core.h\"\n#include \"pinconf.h\"\n#include \"pinmux.h\"\n#include \"pinctrl-equilibrium.h\"\n\n#define PIN_NAME_FMT\t\"io-%d\"\n#define PIN_NAME_LEN\t10\n#define PAD_REG_OFF\t0x100\n\nstatic void eqbr_gpio_disable_irq(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct eqbr_gpio_ctrl *gctrl = gpiochip_get_data(gc);\n\tunsigned int offset = irqd_to_hwirq(d);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&gctrl->lock, flags);\n\twritel(BIT(offset), gctrl->membase + GPIO_IRNENCLR);\n\traw_spin_unlock_irqrestore(&gctrl->lock, flags);\n\tgpiochip_disable_irq(gc, offset);\n}\n\nstatic void eqbr_gpio_enable_irq(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct eqbr_gpio_ctrl *gctrl = gpiochip_get_data(gc);\n\tunsigned int offset = irqd_to_hwirq(d);\n\tunsigned long flags;\n\n\tgc->direction_input(gc, offset);\n\tgpiochip_enable_irq(gc, offset);\n\traw_spin_lock_irqsave(&gctrl->lock, flags);\n\twritel(BIT(offset), gctrl->membase + GPIO_IRNRNSET);\n\traw_spin_unlock_irqrestore(&gctrl->lock, flags);\n}\n\nstatic void eqbr_gpio_ack_irq(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct eqbr_gpio_ctrl *gctrl = gpiochip_get_data(gc);\n\tunsigned int offset = irqd_to_hwirq(d);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&gctrl->lock, flags);\n\twritel(BIT(offset), gctrl->membase + GPIO_IRNCR);\n\traw_spin_unlock_irqrestore(&gctrl->lock, flags);\n}\n\nstatic void eqbr_gpio_mask_ack_irq(struct irq_data *d)\n{\n\teqbr_gpio_disable_irq(d);\n\teqbr_gpio_ack_irq(d);\n}\n\nstatic inline void eqbr_cfg_bit(void __iomem *addr,\n\t\t\t\tunsigned int offset, unsigned int set)\n{\n\tif (set)\n\t\twritel(readl(addr) | BIT(offset), addr);\n\telse\n\t\twritel(readl(addr) & ~BIT(offset), addr);\n}\n\nstatic int eqbr_irq_type_cfg(struct gpio_irq_type *type,\n\t\t\t     struct eqbr_gpio_ctrl *gctrl,\n\t\t\t     unsigned int offset)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&gctrl->lock, flags);\n\teqbr_cfg_bit(gctrl->membase + GPIO_IRNCFG, offset, type->trig_type);\n\teqbr_cfg_bit(gctrl->membase + GPIO_EXINTCR1, offset, type->trig_type);\n\teqbr_cfg_bit(gctrl->membase + GPIO_EXINTCR0, offset, type->logic_type);\n\traw_spin_unlock_irqrestore(&gctrl->lock, flags);\n\n\treturn 0;\n}\n\nstatic int eqbr_gpio_set_irq_type(struct irq_data *d, unsigned int type)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct eqbr_gpio_ctrl *gctrl = gpiochip_get_data(gc);\n\tunsigned int offset = irqd_to_hwirq(d);\n\tstruct gpio_irq_type it;\n\n\tmemset(&it, 0, sizeof(it));\n\n\tif ((type & IRQ_TYPE_SENSE_MASK) == IRQ_TYPE_NONE)\n\t\treturn 0;\n\n\tswitch (type) {\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tit.trig_type = GPIO_EDGE_TRIG;\n\t\tit.edge_type = GPIO_SINGLE_EDGE;\n\t\tit.logic_type = GPIO_POSITIVE_TRIG;\n\t\tbreak;\n\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tit.trig_type = GPIO_EDGE_TRIG;\n\t\tit.edge_type = GPIO_SINGLE_EDGE;\n\t\tit.logic_type = GPIO_NEGATIVE_TRIG;\n\t\tbreak;\n\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\tit.trig_type = GPIO_EDGE_TRIG;\n\t\tit.edge_type = GPIO_BOTH_EDGE;\n\t\tit.logic_type = GPIO_POSITIVE_TRIG;\n\t\tbreak;\n\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tit.trig_type = GPIO_LEVEL_TRIG;\n\t\tit.edge_type = GPIO_SINGLE_EDGE;\n\t\tit.logic_type = GPIO_POSITIVE_TRIG;\n\t\tbreak;\n\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tit.trig_type = GPIO_LEVEL_TRIG;\n\t\tit.edge_type = GPIO_SINGLE_EDGE;\n\t\tit.logic_type = GPIO_NEGATIVE_TRIG;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\teqbr_irq_type_cfg(&it, gctrl, offset);\n\tif (it.trig_type == GPIO_EDGE_TRIG)\n\t\tirq_set_handler_locked(d, handle_edge_irq);\n\telse\n\t\tirq_set_handler_locked(d, handle_level_irq);\n\n\treturn 0;\n}\n\nstatic void eqbr_irq_handler(struct irq_desc *desc)\n{\n\tstruct gpio_chip *gc = irq_desc_get_handler_data(desc);\n\tstruct eqbr_gpio_ctrl *gctrl = gpiochip_get_data(gc);\n\tstruct irq_chip *ic = irq_desc_get_chip(desc);\n\tunsigned long pins, offset;\n\n\tchained_irq_enter(ic, desc);\n\tpins = readl(gctrl->membase + GPIO_IRNCR);\n\n\tfor_each_set_bit(offset, &pins, gc->ngpio)\n\t\tgeneric_handle_domain_irq(gc->irq.domain, offset);\n\n\tchained_irq_exit(ic, desc);\n}\n\nstatic const struct irq_chip eqbr_irq_chip = {\n\t.name = \"gpio_irq\",\n\t.irq_mask = eqbr_gpio_disable_irq,\n\t.irq_unmask = eqbr_gpio_enable_irq,\n\t.irq_ack = eqbr_gpio_ack_irq,\n\t.irq_mask_ack = eqbr_gpio_mask_ack_irq,\n\t.irq_set_type = eqbr_gpio_set_irq_type,\n\t.flags = IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic int gpiochip_setup(struct device *dev, struct eqbr_gpio_ctrl *gctrl)\n{\n\tstruct gpio_irq_chip *girq;\n\tstruct gpio_chip *gc;\n\n\tgc = &gctrl->chip;\n\tgc->label = gctrl->name;\n\tgc->fwnode = gctrl->fwnode;\n\n\tif (!fwnode_property_read_bool(gctrl->fwnode, \"interrupt-controller\")) {\n\t\tdev_dbg(dev, \"gc %s: doesn't act as interrupt controller!\\n\",\n\t\t\tgctrl->name);\n\t\treturn 0;\n\t}\n\n\tgirq = &gctrl->chip.irq;\n\tgpio_irq_chip_set_chip(girq, &eqbr_irq_chip);\n\tgirq->parent_handler = eqbr_irq_handler;\n\tgirq->num_parents = 1;\n\tgirq->parents = devm_kcalloc(dev, 1, sizeof(*girq->parents), GFP_KERNEL);\n\tif (!girq->parents)\n\t\treturn -ENOMEM;\n\n\tgirq->default_type = IRQ_TYPE_NONE;\n\tgirq->handler = handle_bad_irq;\n\tgirq->parents[0] = gctrl->virq;\n\n\treturn 0;\n}\n\nstatic int gpiolib_reg(struct eqbr_pinctrl_drv_data *drvdata)\n{\n\tstruct device *dev = drvdata->dev;\n\tstruct eqbr_gpio_ctrl *gctrl;\n\tstruct device_node *np;\n\tstruct resource res;\n\tint i, ret;\n\n\tfor (i = 0; i < drvdata->nr_gpio_ctrls; i++) {\n\t\tgctrl = drvdata->gpio_ctrls + i;\n\t\tnp = to_of_node(gctrl->fwnode);\n\n\t\tgctrl->name = devm_kasprintf(dev, GFP_KERNEL, \"gpiochip%d\", i);\n\t\tif (!gctrl->name)\n\t\t\treturn -ENOMEM;\n\n\t\tif (of_address_to_resource(np, 0, &res)) {\n\t\t\tdev_err(dev, \"Failed to get GPIO register address\\n\");\n\t\t\treturn -ENXIO;\n\t\t}\n\n\t\tgctrl->membase = devm_ioremap_resource(dev, &res);\n\t\tif (IS_ERR(gctrl->membase))\n\t\t\treturn PTR_ERR(gctrl->membase);\n\n\t\tgctrl->virq = irq_of_parse_and_map(np, 0);\n\t\tif (!gctrl->virq) {\n\t\t\tdev_err(dev, \"%s: failed to parse and map irq\\n\",\n\t\t\t\tgctrl->name);\n\t\t\treturn -ENXIO;\n\t\t}\n\t\traw_spin_lock_init(&gctrl->lock);\n\n\t\tret = bgpio_init(&gctrl->chip, dev, gctrl->bank->nr_pins / 8,\n\t\t\t\t gctrl->membase + GPIO_IN,\n\t\t\t\t gctrl->membase + GPIO_OUTSET,\n\t\t\t\t gctrl->membase + GPIO_OUTCLR,\n\t\t\t\t gctrl->membase + GPIO_DIR,\n\t\t\t\t NULL, 0);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"unable to init generic GPIO\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = gpiochip_setup(dev, gctrl);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = devm_gpiochip_add_data(dev, &gctrl->chip, gctrl);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic inline struct eqbr_pin_bank\n*find_pinbank_via_pin(struct eqbr_pinctrl_drv_data *pctl, unsigned int pin)\n{\n\tstruct eqbr_pin_bank *bank;\n\tint i;\n\n\tfor (i = 0; i < pctl->nr_banks; i++) {\n\t\tbank = &pctl->pin_banks[i];\n\t\tif (pin >= bank->pin_base &&\n\t\t    (pin - bank->pin_base) < bank->nr_pins)\n\t\t\treturn bank;\n\t}\n\n\treturn NULL;\n}\n\nstatic const struct pinctrl_ops eqbr_pctl_ops = {\n\t.get_groups_count\t= pinctrl_generic_get_group_count,\n\t.get_group_name\t\t= pinctrl_generic_get_group_name,\n\t.get_group_pins\t\t= pinctrl_generic_get_group_pins,\n\t.dt_node_to_map\t\t= pinconf_generic_dt_node_to_map_all,\n\t.dt_free_map\t\t= pinconf_generic_dt_free_map,\n};\n\nstatic int eqbr_set_pin_mux(struct eqbr_pinctrl_drv_data *pctl,\n\t\t\t    unsigned int pmx, unsigned int pin)\n{\n\tstruct eqbr_pin_bank *bank;\n\tunsigned long flags;\n\tunsigned int offset;\n\tvoid __iomem *mem;\n\n\tbank = find_pinbank_via_pin(pctl, pin);\n\tif (!bank) {\n\t\tdev_err(pctl->dev, \"Couldn't find pin bank for pin %u\\n\", pin);\n\t\treturn -ENODEV;\n\t}\n\tmem = bank->membase;\n\toffset = pin - bank->pin_base;\n\n\tif (!(bank->aval_pinmap & BIT(offset))) {\n\t\tdev_err(pctl->dev,\n\t\t\t\"PIN: %u is not valid, pinbase: %u, bitmap: %u\\n\",\n\t\t\tpin, bank->pin_base, bank->aval_pinmap);\n\t\treturn -ENODEV;\n\t}\n\n\traw_spin_lock_irqsave(&pctl->lock, flags);\n\twritel(pmx, mem + (offset * 4));\n\traw_spin_unlock_irqrestore(&pctl->lock, flags);\n\treturn 0;\n}\n\nstatic int eqbr_pinmux_set_mux(struct pinctrl_dev *pctldev,\n\t\t\t       unsigned int selector, unsigned int group)\n{\n\tstruct eqbr_pinctrl_drv_data *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct function_desc *func;\n\tstruct group_desc *grp;\n\tunsigned int *pinmux;\n\tint i;\n\n\tfunc = pinmux_generic_get_function(pctldev, selector);\n\tif (!func)\n\t\treturn -EINVAL;\n\n\tgrp = pinctrl_generic_get_group(pctldev, group);\n\tif (!grp)\n\t\treturn -EINVAL;\n\n\tpinmux = grp->data;\n\tfor (i = 0; i < grp->num_pins; i++)\n\t\teqbr_set_pin_mux(pctl, pinmux[i], grp->pins[i]);\n\n\treturn 0;\n}\n\nstatic int eqbr_pinmux_gpio_request(struct pinctrl_dev *pctldev,\n\t\t\t\t    struct pinctrl_gpio_range *range,\n\t\t\t\t    unsigned int pin)\n{\n\tstruct eqbr_pinctrl_drv_data *pctl = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn eqbr_set_pin_mux(pctl, EQBR_GPIO_MODE, pin);\n}\n\nstatic const struct pinmux_ops eqbr_pinmux_ops = {\n\t.get_functions_count\t= pinmux_generic_get_function_count,\n\t.get_function_name\t= pinmux_generic_get_function_name,\n\t.get_function_groups\t= pinmux_generic_get_function_groups,\n\t.set_mux\t\t= eqbr_pinmux_set_mux,\n\t.gpio_request_enable\t= eqbr_pinmux_gpio_request,\n\t.strict\t\t\t= true,\n};\n\nstatic int get_drv_cur(void __iomem *mem, unsigned int offset)\n{\n\tunsigned int idx = offset / DRV_CUR_PINS;  \n\tunsigned int pin_offset = offset % DRV_CUR_PINS;\n\n\treturn PARSE_DRV_CURRENT(readl(mem + REG_DRCC(idx)), pin_offset);\n}\n\nstatic struct eqbr_gpio_ctrl\n*get_gpio_ctrls_via_bank(struct eqbr_pinctrl_drv_data *pctl,\n\t\t\tstruct eqbr_pin_bank *bank)\n{\n\tint i;\n\n\tfor (i = 0; i < pctl->nr_gpio_ctrls; i++) {\n\t\tif (pctl->gpio_ctrls[i].bank == bank)\n\t\t\treturn &pctl->gpio_ctrls[i];\n\t}\n\n\treturn NULL;\n}\n\nstatic int eqbr_pinconf_get(struct pinctrl_dev *pctldev, unsigned int pin,\n\t\t\t    unsigned long *config)\n{\n\tstruct eqbr_pinctrl_drv_data *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tenum pin_config_param param = pinconf_to_config_param(*config);\n\tstruct eqbr_gpio_ctrl *gctrl;\n\tstruct eqbr_pin_bank *bank;\n\tunsigned long flags;\n\tunsigned int offset;\n\tvoid __iomem *mem;\n\tu32 val;\n\n\tbank = find_pinbank_via_pin(pctl, pin);\n\tif (!bank) {\n\t\tdev_err(pctl->dev, \"Couldn't find pin bank for pin %u\\n\", pin);\n\t\treturn -ENODEV;\n\t}\n\tmem = bank->membase;\n\toffset = pin - bank->pin_base;\n\n\tif (!(bank->aval_pinmap & BIT(offset))) {\n\t\tdev_err(pctl->dev,\n\t\t\t\"PIN: %u is not valid, pinbase: %u, bitmap: %u\\n\",\n\t\t\tpin, bank->pin_base, bank->aval_pinmap);\n\t\treturn -ENODEV;\n\t}\n\n\traw_spin_lock_irqsave(&pctl->lock, flags);\n\tswitch (param) {\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\tval = !!(readl(mem + REG_PUEN) & BIT(offset));\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\tval = !!(readl(mem + REG_PDEN) & BIT(offset));\n\t\tbreak;\n\tcase PIN_CONFIG_DRIVE_OPEN_DRAIN:\n\t\tval = !!(readl(mem + REG_OD) & BIT(offset));\n\t\tbreak;\n\tcase PIN_CONFIG_DRIVE_STRENGTH:\n\t\tval = get_drv_cur(mem, offset);\n\t\tbreak;\n\tcase PIN_CONFIG_SLEW_RATE:\n\t\tval = !!(readl(mem + REG_SRC) & BIT(offset));\n\t\tbreak;\n\tcase PIN_CONFIG_OUTPUT_ENABLE:\n\t\tgctrl = get_gpio_ctrls_via_bank(pctl, bank);\n\t\tif (!gctrl) {\n\t\t\tdev_err(pctl->dev, \"Failed to find gpio via bank pinbase: %u, pin: %u\\n\",\n\t\t\t\tbank->pin_base, pin);\n\t\t\traw_spin_unlock_irqrestore(&pctl->lock, flags);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tval = !!(readl(gctrl->membase + GPIO_DIR) & BIT(offset));\n\t\tbreak;\n\tdefault:\n\t\traw_spin_unlock_irqrestore(&pctl->lock, flags);\n\t\treturn -ENOTSUPP;\n\t}\n\traw_spin_unlock_irqrestore(&pctl->lock, flags);\n\t*config = pinconf_to_config_packed(param, val);\n;\n\treturn 0;\n}\n\nstatic int eqbr_pinconf_set(struct pinctrl_dev *pctldev, unsigned int pin,\n\t\t\t    unsigned long *configs, unsigned int num_configs)\n{\n\tstruct eqbr_pinctrl_drv_data *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct eqbr_gpio_ctrl *gctrl;\n\tenum pin_config_param param;\n\tstruct eqbr_pin_bank *bank;\n\tunsigned int val, offset;\n\tstruct gpio_chip *gc;\n\tunsigned long flags;\n\tvoid __iomem *mem;\n\tu32 regval, mask;\n\tint i;\n\n\tfor (i = 0; i < num_configs; i++) {\n\t\tparam = pinconf_to_config_param(configs[i]);\n\t\tval = pinconf_to_config_argument(configs[i]);\n\n\t\tbank = find_pinbank_via_pin(pctl, pin);\n\t\tif (!bank) {\n\t\t\tdev_err(pctl->dev,\n\t\t\t\t\"Couldn't find pin bank for pin %u\\n\", pin);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tmem = bank->membase;\n\t\toffset = pin - bank->pin_base;\n\n\t\tswitch (param) {\n\t\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\t\tmem += REG_PUEN;\n\t\t\tmask = BIT(offset);\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\t\tmem += REG_PDEN;\n\t\t\tmask = BIT(offset);\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_DRIVE_OPEN_DRAIN:\n\t\t\tmem += REG_OD;\n\t\t\tmask = BIT(offset);\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_DRIVE_STRENGTH:\n\t\t\tmem += REG_DRCC(offset / DRV_CUR_PINS);\n\t\t\toffset = (offset % DRV_CUR_PINS) * 2;\n\t\t\tmask = GENMASK(1, 0) << offset;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_SLEW_RATE:\n\t\t\tmem += REG_SRC;\n\t\t\tmask = BIT(offset);\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_OUTPUT_ENABLE:\n\t\t\tgctrl = get_gpio_ctrls_via_bank(pctl, bank);\n\t\t\tif (!gctrl) {\n\t\t\t\tdev_err(pctl->dev, \"Failed to find gpio via bank pinbase: %u, pin: %u\\n\",\n\t\t\t\t\tbank->pin_base, pin);\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\t\t\tgc = &gctrl->chip;\n\t\t\tgc->direction_output(gc, offset, 0);\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\n\t\traw_spin_lock_irqsave(&pctl->lock, flags);\n\t\tregval = readl(mem);\n\t\tregval = (regval & ~mask) | ((val << offset) & mask);\n\t\twritel(regval, mem);\n\t\traw_spin_unlock_irqrestore(&pctl->lock, flags);\n\t}\n\n\treturn 0;\n}\n\nstatic int eqbr_pinconf_group_get(struct pinctrl_dev *pctldev,\n\t\t\t\t  unsigned int group, unsigned long *config)\n{\n\tunsigned int i, npins, old = 0;\n\tconst unsigned int *pins;\n\tint ret;\n\n\tret = pinctrl_generic_get_group_pins(pctldev, group, &pins, &npins);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < npins; i++) {\n\t\tif (eqbr_pinconf_get(pctldev, pins[i], config))\n\t\t\treturn -ENOTSUPP;\n\n\t\tif (i && old != *config)\n\t\t\treturn -ENOTSUPP;\n\n\t\told = *config;\n\t}\n\treturn 0;\n}\n\nstatic int eqbr_pinconf_group_set(struct pinctrl_dev *pctldev,\n\t\t\t\t  unsigned int group, unsigned long *configs,\n\t\t\t\t  unsigned int num_configs)\n{\n\tconst unsigned int *pins;\n\tunsigned int i, npins;\n\tint ret;\n\n\tret = pinctrl_generic_get_group_pins(pctldev, group, &pins, &npins);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < npins; i++) {\n\t\tret = eqbr_pinconf_set(pctldev, pins[i], configs, num_configs);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic const struct pinconf_ops eqbr_pinconf_ops = {\n\t.is_generic\t\t\t= true,\n\t.pin_config_get\t\t\t= eqbr_pinconf_get,\n\t.pin_config_set\t\t\t= eqbr_pinconf_set,\n\t.pin_config_group_get\t\t= eqbr_pinconf_group_get,\n\t.pin_config_group_set\t\t= eqbr_pinconf_group_set,\n\t.pin_config_config_dbg_show\t= pinconf_generic_dump_config,\n};\n\nstatic bool is_func_exist(struct eqbr_pmx_func *funcs, const char *name,\n\t\t\t unsigned int nr_funcs, unsigned int *idx)\n{\n\tint i;\n\n\tif (!funcs)\n\t\treturn false;\n\n\tfor (i = 0; i < nr_funcs; i++) {\n\t\tif (funcs[i].name && !strcmp(funcs[i].name, name)) {\n\t\t\t*idx = i;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic int funcs_utils(struct device *dev, struct eqbr_pmx_func *funcs,\n\t\t       unsigned int *nr_funcs, funcs_util_ops op)\n{\n\tstruct device_node *node = dev->of_node;\n\tstruct device_node *np;\n\tstruct property *prop;\n\tconst char *fn_name;\n\tunsigned int fid;\n\tint i, j;\n\n\ti = 0;\n\tfor_each_child_of_node(node, np) {\n\t\tprop = of_find_property(np, \"groups\", NULL);\n\t\tif (!prop)\n\t\t\tcontinue;\n\n\t\tif (of_property_read_string(np, \"function\", &fn_name)) {\n\t\t\t \n\t\t\tdev_dbg(dev, \"Group %s: not function binded!\\n\",\n\t\t\t\t(char *)prop->value);\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (op) {\n\t\tcase OP_COUNT_NR_FUNCS:\n\t\t\tif (!is_func_exist(funcs, fn_name, *nr_funcs, &fid))\n\t\t\t\t*nr_funcs = *nr_funcs + 1;\n\t\t\tbreak;\n\n\t\tcase OP_ADD_FUNCS:\n\t\t\tif (!is_func_exist(funcs, fn_name, *nr_funcs, &fid))\n\t\t\t\tfuncs[i].name = fn_name;\n\t\t\tbreak;\n\n\t\tcase OP_COUNT_NR_FUNC_GRPS:\n\t\t\tif (is_func_exist(funcs, fn_name, *nr_funcs, &fid))\n\t\t\t\tfuncs[fid].nr_groups++;\n\t\t\tbreak;\n\n\t\tcase OP_ADD_FUNC_GRPS:\n\t\t\tif (is_func_exist(funcs, fn_name, *nr_funcs, &fid)) {\n\t\t\t\tfor (j = 0; j < funcs[fid].nr_groups; j++)\n\t\t\t\t\tif (!funcs[fid].groups[j])\n\t\t\t\t\t\tbreak;\n\t\t\t\tfuncs[fid].groups[j] = prop->value;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tof_node_put(np);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ti++;\n\t}\n\n\treturn 0;\n}\n\nstatic int eqbr_build_functions(struct eqbr_pinctrl_drv_data *drvdata)\n{\n\tstruct device *dev = drvdata->dev;\n\tstruct eqbr_pmx_func *funcs = NULL;\n\tunsigned int nr_funcs = 0;\n\tint i, ret;\n\n\tret = funcs_utils(dev, funcs, &nr_funcs, OP_COUNT_NR_FUNCS);\n\tif (ret)\n\t\treturn ret;\n\n\tfuncs = devm_kcalloc(dev, nr_funcs, sizeof(*funcs), GFP_KERNEL);\n\tif (!funcs)\n\t\treturn -ENOMEM;\n\n\tret = funcs_utils(dev, funcs, &nr_funcs, OP_ADD_FUNCS);\n\tif (ret)\n\t\treturn ret;\n\n\tret = funcs_utils(dev, funcs, &nr_funcs, OP_COUNT_NR_FUNC_GRPS);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < nr_funcs; i++) {\n\t\tif (!funcs[i].nr_groups)\n\t\t\tcontinue;\n\t\tfuncs[i].groups = devm_kcalloc(dev, funcs[i].nr_groups,\n\t\t\t\t\t       sizeof(*(funcs[i].groups)),\n\t\t\t\t\t       GFP_KERNEL);\n\t\tif (!funcs[i].groups)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tret = funcs_utils(dev, funcs, &nr_funcs, OP_ADD_FUNC_GRPS);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < nr_funcs; i++) {\n\n\t\t \n\t\tif (funcs[i].name == NULL)\n\t\t\tcontinue;\n\n\t\tret = pinmux_generic_add_function(drvdata->pctl_dev,\n\t\t\t\t\t\t  funcs[i].name,\n\t\t\t\t\t\t  funcs[i].groups,\n\t\t\t\t\t\t  funcs[i].nr_groups,\n\t\t\t\t\t\t  drvdata);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Failed to register function %s\\n\",\n\t\t\t\tfuncs[i].name);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int eqbr_build_groups(struct eqbr_pinctrl_drv_data *drvdata)\n{\n\tstruct device *dev = drvdata->dev;\n\tstruct device_node *node = dev->of_node;\n\tunsigned int *pinmux, pin_id, pinmux_id;\n\tstruct group_desc group;\n\tstruct device_node *np;\n\tstruct property *prop;\n\tint j, err;\n\n\tfor_each_child_of_node(node, np) {\n\t\tprop = of_find_property(np, \"groups\", NULL);\n\t\tif (!prop)\n\t\t\tcontinue;\n\n\t\tgroup.num_pins = of_property_count_u32_elems(np, \"pins\");\n\t\tif (group.num_pins < 0) {\n\t\t\tdev_err(dev, \"No pins in the group: %s\\n\", prop->name);\n\t\t\tof_node_put(np);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tgroup.name = prop->value;\n\t\tgroup.pins = devm_kcalloc(dev, group.num_pins,\n\t\t\t\t\t  sizeof(*(group.pins)), GFP_KERNEL);\n\t\tif (!group.pins) {\n\t\t\tof_node_put(np);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tpinmux = devm_kcalloc(dev, group.num_pins, sizeof(*pinmux),\n\t\t\t\t      GFP_KERNEL);\n\t\tif (!pinmux) {\n\t\t\tof_node_put(np);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tfor (j = 0; j < group.num_pins; j++) {\n\t\t\tif (of_property_read_u32_index(np, \"pins\", j, &pin_id)) {\n\t\t\t\tdev_err(dev, \"Group %s: Read intel pins id failed\\n\",\n\t\t\t\t\tgroup.name);\n\t\t\t\tof_node_put(np);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (pin_id >= drvdata->pctl_desc.npins) {\n\t\t\t\tdev_err(dev, \"Group %s: Invalid pin ID, idx: %d, pin %u\\n\",\n\t\t\t\t\tgroup.name, j, pin_id);\n\t\t\t\tof_node_put(np);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tgroup.pins[j] = pin_id;\n\t\t\tif (of_property_read_u32_index(np, \"pinmux\", j, &pinmux_id)) {\n\t\t\t\tdev_err(dev, \"Group %s: Read intel pinmux id failed\\n\",\n\t\t\t\t\tgroup.name);\n\t\t\t\tof_node_put(np);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tpinmux[j] = pinmux_id;\n\t\t}\n\n\t\terr = pinctrl_generic_add_group(drvdata->pctl_dev, group.name,\n\t\t\t\t\t\tgroup.pins, group.num_pins,\n\t\t\t\t\t\tpinmux);\n\t\tif (err < 0) {\n\t\t\tdev_err(dev, \"Failed to register group %s\\n\", group.name);\n\t\t\tof_node_put(np);\n\t\t\treturn err;\n\t\t}\n\t\tmemset(&group, 0, sizeof(group));\n\t\tpinmux = NULL;\n\t}\n\n\treturn 0;\n}\n\nstatic int pinctrl_reg(struct eqbr_pinctrl_drv_data *drvdata)\n{\n\tstruct pinctrl_desc *pctl_desc;\n\tstruct pinctrl_pin_desc *pdesc;\n\tstruct device *dev;\n\tunsigned int nr_pins;\n\tchar *pin_names;\n\tint i, ret;\n\n\tdev = drvdata->dev;\n\tpctl_desc = &drvdata->pctl_desc;\n\tpctl_desc->name = \"eqbr-pinctrl\";\n\tpctl_desc->owner = THIS_MODULE;\n\tpctl_desc->pctlops = &eqbr_pctl_ops;\n\tpctl_desc->pmxops = &eqbr_pinmux_ops;\n\tpctl_desc->confops = &eqbr_pinconf_ops;\n\traw_spin_lock_init(&drvdata->lock);\n\n\tfor (i = 0, nr_pins = 0; i < drvdata->nr_banks; i++)\n\t\tnr_pins += drvdata->pin_banks[i].nr_pins;\n\n\tpdesc = devm_kcalloc(dev, nr_pins, sizeof(*pdesc), GFP_KERNEL);\n\tif (!pdesc)\n\t\treturn -ENOMEM;\n\tpin_names = devm_kcalloc(dev, nr_pins, PIN_NAME_LEN, GFP_KERNEL);\n\tif (!pin_names)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < nr_pins; i++) {\n\t\tsprintf(pin_names, PIN_NAME_FMT, i);\n\t\tpdesc[i].number = i;\n\t\tpdesc[i].name = pin_names;\n\t\tpin_names += PIN_NAME_LEN;\n\t}\n\tpctl_desc->pins = pdesc;\n\tpctl_desc->npins = nr_pins;\n\tdev_dbg(dev, \"pinctrl total pin number: %u\\n\", nr_pins);\n\n\tret = devm_pinctrl_register_and_init(dev, pctl_desc, drvdata,\n\t\t\t\t\t     &drvdata->pctl_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = eqbr_build_groups(drvdata);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to build groups\\n\");\n\t\treturn ret;\n\t}\n\n\tret = eqbr_build_functions(drvdata);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to build functions\\n\");\n\t\treturn ret;\n\t}\n\n\treturn pinctrl_enable(drvdata->pctl_dev);\n}\n\nstatic int pinbank_init(struct device_node *np,\n\t\t\tstruct eqbr_pinctrl_drv_data *drvdata,\n\t\t\tstruct eqbr_pin_bank *bank, unsigned int id)\n{\n\tstruct device *dev = drvdata->dev;\n\tstruct of_phandle_args spec;\n\tint ret;\n\n\tbank->membase = drvdata->membase + id * PAD_REG_OFF;\n\n\tret = of_parse_phandle_with_fixed_args(np, \"gpio-ranges\", 3, 0, &spec);\n\tif (ret) {\n\t\tdev_err(dev, \"gpio-range not available!\\n\");\n\t\treturn ret;\n\t}\n\n\tbank->pin_base = spec.args[1];\n\tbank->nr_pins = spec.args[2];\n\n\tbank->aval_pinmap = readl(bank->membase + REG_AVAIL);\n\tbank->id = id;\n\n\tdev_dbg(dev, \"pinbank id: %d, reg: %px, pinbase: %u, pin number: %u, pinmap: 0x%x\\n\",\n\t\tid, bank->membase, bank->pin_base,\n\t\tbank->nr_pins, bank->aval_pinmap);\n\n\treturn ret;\n}\n\nstatic int pinbank_probe(struct eqbr_pinctrl_drv_data *drvdata)\n{\n\tstruct device *dev = drvdata->dev;\n\tstruct device_node *np_gpio;\n\tstruct eqbr_gpio_ctrl *gctrls;\n\tstruct eqbr_pin_bank *banks;\n\tint i, nr_gpio;\n\n\t \n\tnr_gpio = 0;\n\tfor_each_node_by_name(np_gpio, \"gpio\") {\n\t\tif (of_device_is_available(np_gpio))\n\t\t\tnr_gpio++;\n\t}\n\n\tif (!nr_gpio) {\n\t\tdev_err(dev, \"NO pin bank available!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tbanks = devm_kcalloc(dev, nr_gpio, sizeof(*banks), GFP_KERNEL);\n\tif (!banks)\n\t\treturn -ENOMEM;\n\n\tgctrls = devm_kcalloc(dev, nr_gpio, sizeof(*gctrls), GFP_KERNEL);\n\tif (!gctrls)\n\t\treturn -ENOMEM;\n\n\tdev_dbg(dev, \"found %d gpio controller!\\n\", nr_gpio);\n\n\t \n\ti = 0;\n\tfor_each_node_by_name(np_gpio, \"gpio\") {\n\t\tif (!of_device_is_available(np_gpio))\n\t\t\tcontinue;\n\n\t\tpinbank_init(np_gpio, drvdata, banks + i, i);\n\n\t\tgctrls[i].fwnode = of_fwnode_handle(np_gpio);\n\t\tgctrls[i].bank = banks + i;\n\t\ti++;\n\t}\n\n\tdrvdata->pin_banks = banks;\n\tdrvdata->nr_banks = nr_gpio;\n\tdrvdata->gpio_ctrls = gctrls;\n\tdrvdata->nr_gpio_ctrls = nr_gpio;\n\n\treturn 0;\n}\n\nstatic int eqbr_pinctrl_probe(struct platform_device *pdev)\n{\n\tstruct eqbr_pinctrl_drv_data *drvdata;\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\n\tdrvdata = devm_kzalloc(dev, sizeof(*drvdata), GFP_KERNEL);\n\tif (!drvdata)\n\t\treturn -ENOMEM;\n\n\tdrvdata->dev = dev;\n\n\tdrvdata->membase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(drvdata->membase))\n\t\treturn PTR_ERR(drvdata->membase);\n\n\tret = pinbank_probe(drvdata);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pinctrl_reg(drvdata);\n\tif (ret)\n\t\treturn ret;\n\n\tret = gpiolib_reg(drvdata);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, drvdata);\n\treturn 0;\n}\n\nstatic const struct of_device_id eqbr_pinctrl_dt_match[] = {\n\t{ .compatible = \"intel,lgm-io\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, eqbr_pinctrl_dt_match);\n\nstatic struct platform_driver eqbr_pinctrl_driver = {\n\t.probe\t= eqbr_pinctrl_probe,\n\t.driver = {\n\t\t.name = \"eqbr-pinctrl\",\n\t\t.of_match_table = eqbr_pinctrl_dt_match,\n\t},\n};\n\nmodule_platform_driver(eqbr_pinctrl_driver);\n\nMODULE_AUTHOR(\"Zhu Yixin <yixin.zhu@intel.com>, Rahul Tanwar <rahul.tanwar@intel.com>\");\nMODULE_DESCRIPTION(\"Pinctrl Driver for LGM SoC (Equilibrium)\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}