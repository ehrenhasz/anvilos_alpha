{
  "module_name": "pinctrl-mcp23s08_spi.c",
  "hash_id": "c8e6d04c81029bdc959a9e8417151a8e05efd49eb49cc23edf07ea9a9c1d0494",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/pinctrl-mcp23s08_spi.c",
  "human_readable_source": "\n \n\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/spi/spi.h>\n\n#include \"pinctrl-mcp23s08.h\"\n\n#define MCP_MAX_DEV_PER_CS\t8\n\n \nstruct mcp23s08_driver_data {\n\tunsigned\t\tngpio;\n\tstruct mcp23s08\t\t*mcp[8];\n\tstruct mcp23s08\t\tchip[];\n};\n\nstatic int mcp23sxx_spi_write(void *context, const void *data, size_t count)\n{\n\tstruct mcp23s08 *mcp = context;\n\tstruct spi_device *spi = to_spi_device(mcp->dev);\n\tstruct spi_message m;\n\tstruct spi_transfer t[2] = { { .tx_buf = &mcp->addr, .len = 1, },\n\t\t\t\t     { .tx_buf = data, .len = count, }, };\n\n\tspi_message_init(&m);\n\tspi_message_add_tail(&t[0], &m);\n\tspi_message_add_tail(&t[1], &m);\n\n\treturn spi_sync(spi, &m);\n}\n\nstatic int mcp23sxx_spi_gather_write(void *context,\n\t\t\t\tconst void *reg, size_t reg_size,\n\t\t\t\tconst void *val, size_t val_size)\n{\n\tstruct mcp23s08 *mcp = context;\n\tstruct spi_device *spi = to_spi_device(mcp->dev);\n\tstruct spi_message m;\n\tstruct spi_transfer t[3] = { { .tx_buf = &mcp->addr, .len = 1, },\n\t\t\t\t     { .tx_buf = reg, .len = reg_size, },\n\t\t\t\t     { .tx_buf = val, .len = val_size, }, };\n\n\tspi_message_init(&m);\n\tspi_message_add_tail(&t[0], &m);\n\tspi_message_add_tail(&t[1], &m);\n\tspi_message_add_tail(&t[2], &m);\n\n\treturn spi_sync(spi, &m);\n}\n\nstatic int mcp23sxx_spi_read(void *context, const void *reg, size_t reg_size,\n\t\t\t\tvoid *val, size_t val_size)\n{\n\tstruct mcp23s08 *mcp = context;\n\tstruct spi_device *spi = to_spi_device(mcp->dev);\n\tu8 tx[2];\n\n\tif (reg_size != 1)\n\t\treturn -EINVAL;\n\n\ttx[0] = mcp->addr | 0x01;\n\ttx[1] = *((u8 *) reg);\n\n\treturn spi_write_then_read(spi, tx, sizeof(tx), val, val_size);\n}\n\nstatic const struct regmap_bus mcp23sxx_spi_regmap = {\n\t.write = mcp23sxx_spi_write,\n\t.gather_write = mcp23sxx_spi_gather_write,\n\t.read = mcp23sxx_spi_read,\n};\n\nstatic int mcp23s08_spi_regmap_init(struct mcp23s08 *mcp, struct device *dev,\n\t\t\t\t    unsigned int addr, unsigned int type)\n{\n\tconst struct regmap_config *config;\n\tstruct regmap_config *copy;\n\tconst char *name;\n\n\tswitch (type) {\n\tcase MCP_TYPE_S08:\n\t\tmcp->reg_shift = 0;\n\t\tmcp->chip.ngpio = 8;\n\t\tmcp->chip.label = devm_kasprintf(dev, GFP_KERNEL, \"mcp23s08.%d\", addr);\n\t\tif (!mcp->chip.label)\n\t\t\treturn -ENOMEM;\n\n\t\tconfig = &mcp23x08_regmap;\n\t\tname = devm_kasprintf(dev, GFP_KERNEL, \"%d\", addr);\n\t\tif (!name)\n\t\t\treturn -ENOMEM;\n\n\t\tbreak;\n\n\tcase MCP_TYPE_S17:\n\t\tmcp->reg_shift = 1;\n\t\tmcp->chip.ngpio = 16;\n\t\tmcp->chip.label = devm_kasprintf(dev, GFP_KERNEL, \"mcp23s17.%d\", addr);\n\t\tif (!mcp->chip.label)\n\t\t\treturn -ENOMEM;\n\n\t\tconfig = &mcp23x17_regmap;\n\t\tname = devm_kasprintf(dev, GFP_KERNEL, \"%d\", addr);\n\t\tif (!name)\n\t\t\treturn -ENOMEM;\n\n\t\tbreak;\n\n\tcase MCP_TYPE_S18:\n\t\tmcp->reg_shift = 1;\n\t\tmcp->chip.ngpio = 16;\n\t\tmcp->chip.label = \"mcp23s18\";\n\n\t\tconfig = &mcp23x17_regmap;\n\t\tname = config->name;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"invalid device type (%d)\\n\", type);\n\t\treturn -EINVAL;\n\t}\n\n\tcopy = devm_kmemdup(dev, config, sizeof(*config), GFP_KERNEL);\n\tif (!copy)\n\t\treturn -ENOMEM;\n\n\tcopy->name = name;\n\n\tmcp->regmap = devm_regmap_init(dev, &mcp23sxx_spi_regmap, mcp, copy);\n\tif (IS_ERR(mcp->regmap))\n\t\tdev_err(dev, \"regmap init failed for %s\\n\", mcp->chip.label);\n\treturn PTR_ERR_OR_ZERO(mcp->regmap);\n}\n\nstatic int mcp23s08_probe(struct spi_device *spi)\n{\n\tstruct device *dev = &spi->dev;\n\tstruct mcp23s08_driver_data *data;\n\tunsigned long spi_present_mask;\n\tconst void *match;\n\tunsigned int addr;\n\tunsigned int ngpio = 0;\n\tint chips;\n\tint type;\n\tint ret;\n\tu32 v;\n\n\tmatch = device_get_match_data(dev);\n\tif (match)\n\t\ttype = (int)(uintptr_t)match;\n\telse\n\t\ttype = spi_get_device_id(spi)->driver_data;\n\n\tret = device_property_read_u32(dev, \"microchip,spi-present-mask\", &v);\n\tif (ret) {\n\t\tret = device_property_read_u32(dev, \"mcp,spi-present-mask\", &v);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"missing spi-present-mask\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\tspi_present_mask = v;\n\n\tif (!spi_present_mask || spi_present_mask >= BIT(MCP_MAX_DEV_PER_CS)) {\n\t\tdev_err(dev, \"invalid spi-present-mask\");\n\t\treturn -ENODEV;\n\t}\n\n\tchips = hweight_long(spi_present_mask);\n\n\tdata = devm_kzalloc(dev, struct_size(data, chip, chips), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tspi_set_drvdata(spi, data);\n\n\tfor_each_set_bit(addr, &spi_present_mask, MCP_MAX_DEV_PER_CS) {\n\t\tdata->mcp[addr] = &data->chip[--chips];\n\t\tdata->mcp[addr]->irq = spi->irq;\n\n\t\tret = mcp23s08_spi_regmap_init(data->mcp[addr], dev, addr, type);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdata->mcp[addr]->pinctrl_desc.name = devm_kasprintf(dev, GFP_KERNEL,\n\t\t\t\t\t\t\t\t    \"mcp23xxx-pinctrl.%d\",\n\t\t\t\t\t\t\t\t    addr);\n\t\tif (!data->mcp[addr]->pinctrl_desc.name)\n\t\t\treturn -ENOMEM;\n\n\t\tret = mcp23s08_probe_one(data->mcp[addr], dev, 0x40 | (addr << 1), type, -1);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tngpio += data->mcp[addr]->chip.ngpio;\n\t}\n\tdata->ngpio = ngpio;\n\n\treturn 0;\n}\n\nstatic const struct spi_device_id mcp23s08_ids[] = {\n\t{ \"mcp23s08\", MCP_TYPE_S08 },\n\t{ \"mcp23s17\", MCP_TYPE_S17 },\n\t{ \"mcp23s18\", MCP_TYPE_S18 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(spi, mcp23s08_ids);\n\nstatic const struct of_device_id mcp23s08_spi_of_match[] = {\n\t{\n\t\t.compatible = \"microchip,mcp23s08\",\n\t\t.data = (void *) MCP_TYPE_S08,\n\t},\n\t{\n\t\t.compatible = \"microchip,mcp23s17\",\n\t\t.data = (void *) MCP_TYPE_S17,\n\t},\n\t{\n\t\t.compatible = \"microchip,mcp23s18\",\n\t\t.data = (void *) MCP_TYPE_S18,\n\t},\n \n\t{\n\t\t.compatible = \"mcp,mcp23s08\",\n\t\t.data = (void *) MCP_TYPE_S08,\n\t},\n\t{\n\t\t.compatible = \"mcp,mcp23s17\",\n\t\t.data = (void *) MCP_TYPE_S17,\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, mcp23s08_spi_of_match);\n\nstatic struct spi_driver mcp23s08_driver = {\n\t.probe\t\t= mcp23s08_probe,\n\t.id_table\t= mcp23s08_ids,\n\t.driver = {\n\t\t.name\t= \"mcp23s08\",\n\t\t.of_match_table = mcp23s08_spi_of_match,\n\t},\n};\n\nstatic int __init mcp23s08_spi_init(void)\n{\n\treturn spi_register_driver(&mcp23s08_driver);\n}\n\n \nsubsys_initcall(mcp23s08_spi_init);\n\nstatic void mcp23s08_spi_exit(void)\n{\n\tspi_unregister_driver(&mcp23s08_driver);\n}\nmodule_exit(mcp23s08_spi_exit);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}