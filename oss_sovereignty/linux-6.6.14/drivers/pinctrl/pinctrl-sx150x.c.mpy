{
  "module_name": "pinctrl-sx150x.c",
  "hash_id": "6c989b716b59860cd4406c2873410adc509e9fb55cdbd6edd2f51ae3c6c469b0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/pinctrl-sx150x.c",
  "human_readable_source": "\n \n\n#include <linux/regmap.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/gpio/driver.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinmux.h>\n#include <linux/pinctrl/pinconf-generic.h>\n\n#include \"core.h\"\n#include \"pinconf.h\"\n#include \"pinctrl-utils.h\"\n\n \nenum {\n\tSX150X_123 = 0,\n\tSX150X_456,\n\tSX150X_789,\n};\nenum {\n\tSX150X_789_REG_MISC_AUTOCLEAR_OFF = 1 << 0,\n\tSX150X_MAX_REGISTER = 0xad,\n\tSX150X_IRQ_TYPE_EDGE_RISING = 0x1,\n\tSX150X_IRQ_TYPE_EDGE_FALLING = 0x2,\n\tSX150X_789_RESET_KEY1 = 0x12,\n\tSX150X_789_RESET_KEY2 = 0x34,\n};\n\nstruct sx150x_123_pri {\n\tu8 reg_pld_mode;\n\tu8 reg_pld_table0;\n\tu8 reg_pld_table1;\n\tu8 reg_pld_table2;\n\tu8 reg_pld_table3;\n\tu8 reg_pld_table4;\n\tu8 reg_advanced;\n};\n\nstruct sx150x_456_pri {\n\tu8 reg_pld_mode;\n\tu8 reg_pld_table0;\n\tu8 reg_pld_table1;\n\tu8 reg_pld_table2;\n\tu8 reg_pld_table3;\n\tu8 reg_pld_table4;\n\tu8 reg_advanced;\n};\n\nstruct sx150x_789_pri {\n\tu8 reg_drain;\n\tu8 reg_polarity;\n\tu8 reg_clock;\n\tu8 reg_misc;\n\tu8 reg_reset;\n\tu8 ngpios;\n};\n\nstruct sx150x_device_data {\n\tu8 model;\n\tu8 reg_pullup;\n\tu8 reg_pulldn;\n\tu8 reg_dir;\n\tu8 reg_data;\n\tu8 reg_irq_mask;\n\tu8 reg_irq_src;\n\tu8 reg_sense;\n\tu8 ngpios;\n\tunion {\n\t\tstruct sx150x_123_pri x123;\n\t\tstruct sx150x_456_pri x456;\n\t\tstruct sx150x_789_pri x789;\n\t} pri;\n\tconst struct pinctrl_pin_desc *pins;\n\tunsigned int npins;\n};\n\nstruct sx150x_pinctrl {\n\tstruct device *dev;\n\tstruct i2c_client *client;\n\tstruct pinctrl_dev *pctldev;\n\tstruct pinctrl_desc pinctrl_desc;\n\tstruct gpio_chip gpio;\n\tstruct regmap *regmap;\n\tstruct {\n\t\tu32 sense;\n\t\tu32 masked;\n\t} irq;\n\tstruct mutex lock;\n\tconst struct sx150x_device_data *data;\n};\n\nstatic const struct pinctrl_pin_desc sx150x_4_pins[] = {\n\tPINCTRL_PIN(0, \"gpio0\"),\n\tPINCTRL_PIN(1, \"gpio1\"),\n\tPINCTRL_PIN(2, \"gpio2\"),\n\tPINCTRL_PIN(3, \"gpio3\"),\n\tPINCTRL_PIN(4, \"oscio\"),\n};\n\nstatic const struct pinctrl_pin_desc sx150x_8_pins[] = {\n\tPINCTRL_PIN(0, \"gpio0\"),\n\tPINCTRL_PIN(1, \"gpio1\"),\n\tPINCTRL_PIN(2, \"gpio2\"),\n\tPINCTRL_PIN(3, \"gpio3\"),\n\tPINCTRL_PIN(4, \"gpio4\"),\n\tPINCTRL_PIN(5, \"gpio5\"),\n\tPINCTRL_PIN(6, \"gpio6\"),\n\tPINCTRL_PIN(7, \"gpio7\"),\n\tPINCTRL_PIN(8, \"oscio\"),\n};\n\nstatic const struct pinctrl_pin_desc sx150x_16_pins[] = {\n\tPINCTRL_PIN(0, \"gpio0\"),\n\tPINCTRL_PIN(1, \"gpio1\"),\n\tPINCTRL_PIN(2, \"gpio2\"),\n\tPINCTRL_PIN(3, \"gpio3\"),\n\tPINCTRL_PIN(4, \"gpio4\"),\n\tPINCTRL_PIN(5, \"gpio5\"),\n\tPINCTRL_PIN(6, \"gpio6\"),\n\tPINCTRL_PIN(7, \"gpio7\"),\n\tPINCTRL_PIN(8, \"gpio8\"),\n\tPINCTRL_PIN(9, \"gpio9\"),\n\tPINCTRL_PIN(10, \"gpio10\"),\n\tPINCTRL_PIN(11, \"gpio11\"),\n\tPINCTRL_PIN(12, \"gpio12\"),\n\tPINCTRL_PIN(13, \"gpio13\"),\n\tPINCTRL_PIN(14, \"gpio14\"),\n\tPINCTRL_PIN(15, \"gpio15\"),\n\tPINCTRL_PIN(16, \"oscio\"),\n};\n\nstatic const struct sx150x_device_data sx1501q_device_data = {\n\t.model = SX150X_123,\n\t.reg_pullup\t= 0x02,\n\t.reg_pulldn\t= 0x03,\n\t.reg_dir\t= 0x01,\n\t.reg_data\t= 0x00,\n\t.reg_irq_mask\t= 0x05,\n\t.reg_irq_src\t= 0x08,\n\t.reg_sense\t= 0x07,\n\t.pri.x123 = {\n\t\t.reg_pld_mode\t= 0x10,\n\t\t.reg_pld_table0\t= 0x11,\n\t\t.reg_pld_table2\t= 0x13,\n\t\t.reg_advanced\t= 0xad,\n\t},\n\t.ngpios\t= 4,\n\t.pins = sx150x_4_pins,\n\t.npins = 4,  \n};\n\nstatic const struct sx150x_device_data sx1502q_device_data = {\n\t.model = SX150X_123,\n\t.reg_pullup\t= 0x02,\n\t.reg_pulldn\t= 0x03,\n\t.reg_dir\t= 0x01,\n\t.reg_data\t= 0x00,\n\t.reg_irq_mask\t= 0x05,\n\t.reg_irq_src\t= 0x08,\n\t.reg_sense\t= 0x06,\n\t.pri.x123 = {\n\t\t.reg_pld_mode\t= 0x10,\n\t\t.reg_pld_table0\t= 0x11,\n\t\t.reg_pld_table1\t= 0x12,\n\t\t.reg_pld_table2\t= 0x13,\n\t\t.reg_pld_table3\t= 0x14,\n\t\t.reg_pld_table4\t= 0x15,\n\t\t.reg_advanced\t= 0xad,\n\t},\n\t.ngpios\t= 8,\n\t.pins = sx150x_8_pins,\n\t.npins = 8,  \n};\n\nstatic const struct sx150x_device_data sx1503q_device_data = {\n\t.model = SX150X_123,\n\t.reg_pullup\t= 0x04,\n\t.reg_pulldn\t= 0x06,\n\t.reg_dir\t= 0x02,\n\t.reg_data\t= 0x00,\n\t.reg_irq_mask\t= 0x08,\n\t.reg_irq_src\t= 0x0e,\n\t.reg_sense\t= 0x0a,\n\t.pri.x123 = {\n\t\t.reg_pld_mode\t= 0x20,\n\t\t.reg_pld_table0\t= 0x22,\n\t\t.reg_pld_table1\t= 0x24,\n\t\t.reg_pld_table2\t= 0x26,\n\t\t.reg_pld_table3\t= 0x28,\n\t\t.reg_pld_table4\t= 0x2a,\n\t\t.reg_advanced\t= 0xad,\n\t},\n\t.ngpios\t= 16,\n\t.pins = sx150x_16_pins,\n\t.npins  = 16,  \n};\n\nstatic const struct sx150x_device_data sx1504q_device_data = {\n\t.model = SX150X_456,\n\t.reg_pullup\t= 0x02,\n\t.reg_pulldn\t= 0x03,\n\t.reg_dir\t= 0x01,\n\t.reg_data\t= 0x00,\n\t.reg_irq_mask\t= 0x05,\n\t.reg_irq_src\t= 0x08,\n\t.reg_sense\t= 0x07,\n\t.pri.x456 = {\n\t\t.reg_pld_mode\t= 0x10,\n\t\t.reg_pld_table0\t= 0x11,\n\t\t.reg_pld_table2\t= 0x13,\n\t},\n\t.ngpios\t= 4,\n\t.pins = sx150x_4_pins,\n\t.npins = 4,  \n};\n\nstatic const struct sx150x_device_data sx1505q_device_data = {\n\t.model = SX150X_456,\n\t.reg_pullup\t= 0x02,\n\t.reg_pulldn\t= 0x03,\n\t.reg_dir\t= 0x01,\n\t.reg_data\t= 0x00,\n\t.reg_irq_mask\t= 0x05,\n\t.reg_irq_src\t= 0x08,\n\t.reg_sense\t= 0x06,\n\t.pri.x456 = {\n\t\t.reg_pld_mode\t= 0x10,\n\t\t.reg_pld_table0\t= 0x11,\n\t\t.reg_pld_table1\t= 0x12,\n\t\t.reg_pld_table2\t= 0x13,\n\t\t.reg_pld_table3\t= 0x14,\n\t\t.reg_pld_table4\t= 0x15,\n\t},\n\t.ngpios\t= 8,\n\t.pins = sx150x_8_pins,\n\t.npins = 8,  \n};\n\nstatic const struct sx150x_device_data sx1506q_device_data = {\n\t.model = SX150X_456,\n\t.reg_pullup\t= 0x04,\n\t.reg_pulldn\t= 0x06,\n\t.reg_dir\t= 0x02,\n\t.reg_data\t= 0x00,\n\t.reg_irq_mask\t= 0x08,\n\t.reg_irq_src\t= 0x0e,\n\t.reg_sense\t= 0x0a,\n\t.pri.x456 = {\n\t\t.reg_pld_mode\t= 0x20,\n\t\t.reg_pld_table0\t= 0x22,\n\t\t.reg_pld_table1\t= 0x24,\n\t\t.reg_pld_table2\t= 0x26,\n\t\t.reg_pld_table3\t= 0x28,\n\t\t.reg_pld_table4\t= 0x2a,\n\t\t.reg_advanced\t= 0xad,\n\t},\n\t.ngpios\t= 16,\n\t.pins = sx150x_16_pins,\n\t.npins = 16,  \n};\n\nstatic const struct sx150x_device_data sx1507q_device_data = {\n\t.model = SX150X_789,\n\t.reg_pullup\t= 0x03,\n\t.reg_pulldn\t= 0x04,\n\t.reg_dir\t= 0x07,\n\t.reg_data\t= 0x08,\n\t.reg_irq_mask\t= 0x09,\n\t.reg_irq_src\t= 0x0b,\n\t.reg_sense\t= 0x0a,\n\t.pri.x789 = {\n\t\t.reg_drain\t= 0x05,\n\t\t.reg_polarity\t= 0x06,\n\t\t.reg_clock\t= 0x0d,\n\t\t.reg_misc\t= 0x0e,\n\t\t.reg_reset\t= 0x7d,\n\t},\n\t.ngpios = 4,\n\t.pins = sx150x_4_pins,\n\t.npins = ARRAY_SIZE(sx150x_4_pins),\n};\n\nstatic const struct sx150x_device_data sx1508q_device_data = {\n\t.model = SX150X_789,\n\t.reg_pullup\t= 0x03,\n\t.reg_pulldn\t= 0x04,\n\t.reg_dir\t= 0x07,\n\t.reg_data\t= 0x08,\n\t.reg_irq_mask\t= 0x09,\n\t.reg_irq_src\t= 0x0c,\n\t.reg_sense\t= 0x0a,\n\t.pri.x789 = {\n\t\t.reg_drain\t= 0x05,\n\t\t.reg_polarity\t= 0x06,\n\t\t.reg_clock\t= 0x0f,\n\t\t.reg_misc\t= 0x10,\n\t\t.reg_reset\t= 0x7d,\n\t},\n\t.ngpios = 8,\n\t.pins = sx150x_8_pins,\n\t.npins = ARRAY_SIZE(sx150x_8_pins),\n};\n\nstatic const struct sx150x_device_data sx1509q_device_data = {\n\t.model = SX150X_789,\n\t.reg_pullup\t= 0x06,\n\t.reg_pulldn\t= 0x08,\n\t.reg_dir\t= 0x0e,\n\t.reg_data\t= 0x10,\n\t.reg_irq_mask\t= 0x12,\n\t.reg_irq_src\t= 0x18,\n\t.reg_sense\t= 0x14,\n\t.pri.x789 = {\n\t\t.reg_drain\t= 0x0a,\n\t\t.reg_polarity\t= 0x0c,\n\t\t.reg_clock\t= 0x1e,\n\t\t.reg_misc\t= 0x1f,\n\t\t.reg_reset\t= 0x7d,\n\t},\n\t.ngpios\t= 16,\n\t.pins = sx150x_16_pins,\n\t.npins = ARRAY_SIZE(sx150x_16_pins),\n};\n\nstatic int sx150x_pinctrl_get_groups_count(struct pinctrl_dev *pctldev)\n{\n\treturn 0;\n}\n\nstatic const char *sx150x_pinctrl_get_group_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t\tunsigned int group)\n{\n\treturn NULL;\n}\n\nstatic int sx150x_pinctrl_get_group_pins(struct pinctrl_dev *pctldev,\n\t\t\t\t\tunsigned int group,\n\t\t\t\t\tconst unsigned int **pins,\n\t\t\t\t\tunsigned int *num_pins)\n{\n\treturn -ENOTSUPP;\n}\n\nstatic const struct pinctrl_ops sx150x_pinctrl_ops = {\n\t.get_groups_count = sx150x_pinctrl_get_groups_count,\n\t.get_group_name = sx150x_pinctrl_get_group_name,\n\t.get_group_pins = sx150x_pinctrl_get_group_pins,\n#ifdef CONFIG_OF\n\t.dt_node_to_map = pinconf_generic_dt_node_to_map_pin,\n\t.dt_free_map = pinctrl_utils_free_map,\n#endif\n};\n\nstatic bool sx150x_pin_is_oscio(struct sx150x_pinctrl *pctl, unsigned int pin)\n{\n\tif (pin >= pctl->data->npins)\n\t\treturn false;\n\n\t \n\tif (pctl->data->model != SX150X_789)\n\t\treturn false;\n\n\treturn !strcmp(pctl->data->pins[pin].name, \"oscio\");\n}\n\nstatic int sx150x_gpio_get_direction(struct gpio_chip *chip,\n\t\t\t\t      unsigned int offset)\n{\n\tstruct sx150x_pinctrl *pctl = gpiochip_get_data(chip);\n\tunsigned int value;\n\tint ret;\n\n\tif (sx150x_pin_is_oscio(pctl, offset))\n\t\treturn GPIO_LINE_DIRECTION_OUT;\n\n\tret = regmap_read(pctl->regmap, pctl->data->reg_dir, &value);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (value & BIT(offset))\n\t\treturn GPIO_LINE_DIRECTION_IN;\n\n\treturn GPIO_LINE_DIRECTION_OUT;\n}\n\nstatic int sx150x_gpio_get(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct sx150x_pinctrl *pctl = gpiochip_get_data(chip);\n\tunsigned int value;\n\tint ret;\n\n\tif (sx150x_pin_is_oscio(pctl, offset))\n\t\treturn -EINVAL;\n\n\tret = regmap_read(pctl->regmap, pctl->data->reg_data, &value);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn !!(value & BIT(offset));\n}\n\nstatic int __sx150x_gpio_set(struct sx150x_pinctrl *pctl, unsigned int offset,\n\t\t\t     int value)\n{\n\treturn regmap_write_bits(pctl->regmap, pctl->data->reg_data,\n\t\t\t\t BIT(offset), value ? BIT(offset) : 0);\n}\n\nstatic int sx150x_gpio_oscio_set(struct sx150x_pinctrl *pctl,\n\t\t\t\t int value)\n{\n\treturn regmap_write(pctl->regmap,\n\t\t\t    pctl->data->pri.x789.reg_clock,\n\t\t\t    (value ? 0x1f : 0x10));\n}\n\nstatic void sx150x_gpio_set(struct gpio_chip *chip, unsigned int offset,\n\t\t\t    int value)\n{\n\tstruct sx150x_pinctrl *pctl = gpiochip_get_data(chip);\n\n\tif (sx150x_pin_is_oscio(pctl, offset))\n\t\tsx150x_gpio_oscio_set(pctl, value);\n\telse\n\t\t__sx150x_gpio_set(pctl, offset, value);\n}\n\nstatic void sx150x_gpio_set_multiple(struct gpio_chip *chip,\n\t\t\t\t     unsigned long *mask,\n\t\t\t\t     unsigned long *bits)\n{\n\tstruct sx150x_pinctrl *pctl = gpiochip_get_data(chip);\n\n\tregmap_write_bits(pctl->regmap, pctl->data->reg_data, *mask, *bits);\n}\n\nstatic int sx150x_gpio_direction_input(struct gpio_chip *chip,\n\t\t\t\t       unsigned int offset)\n{\n\tstruct sx150x_pinctrl *pctl = gpiochip_get_data(chip);\n\n\tif (sx150x_pin_is_oscio(pctl, offset))\n\t\treturn -EINVAL;\n\n\treturn regmap_write_bits(pctl->regmap,\n\t\t\t\t pctl->data->reg_dir,\n\t\t\t\t BIT(offset), BIT(offset));\n}\n\nstatic int sx150x_gpio_direction_output(struct gpio_chip *chip,\n\t\t\t\t\tunsigned int offset, int value)\n{\n\tstruct sx150x_pinctrl *pctl = gpiochip_get_data(chip);\n\tint ret;\n\n\tif (sx150x_pin_is_oscio(pctl, offset))\n\t\treturn sx150x_gpio_oscio_set(pctl, value);\n\n\tret = __sx150x_gpio_set(pctl, offset, value);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn regmap_write_bits(pctl->regmap,\n\t\t\t\t pctl->data->reg_dir,\n\t\t\t\t BIT(offset), 0);\n}\n\nstatic void sx150x_irq_mask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct sx150x_pinctrl *pctl = gpiochip_get_data(gc);\n\tunsigned int n = irqd_to_hwirq(d);\n\n\tpctl->irq.masked |= BIT(n);\n\tgpiochip_disable_irq(gc, n);\n}\n\nstatic void sx150x_irq_unmask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct sx150x_pinctrl *pctl = gpiochip_get_data(gc);\n\tunsigned int n = irqd_to_hwirq(d);\n\n\tgpiochip_enable_irq(gc, n);\n\tpctl->irq.masked &= ~BIT(n);\n}\n\nstatic void sx150x_irq_set_sense(struct sx150x_pinctrl *pctl,\n\t\t\t\t unsigned int line, unsigned int sense)\n{\n\t \n\tconst unsigned int n = line * 2;\n\tconst unsigned int mask = ~((SX150X_IRQ_TYPE_EDGE_RISING |\n\t\t\t\t     SX150X_IRQ_TYPE_EDGE_FALLING) << n);\n\n\tpctl->irq.sense &= mask;\n\tpctl->irq.sense |= sense << n;\n}\n\nstatic int sx150x_irq_set_type(struct irq_data *d, unsigned int flow_type)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct sx150x_pinctrl *pctl = gpiochip_get_data(gc);\n\tunsigned int n, val = 0;\n\n\tif (flow_type & (IRQ_TYPE_LEVEL_HIGH | IRQ_TYPE_LEVEL_LOW))\n\t\treturn -EINVAL;\n\n\tn = irqd_to_hwirq(d);\n\n\tif (flow_type & IRQ_TYPE_EDGE_RISING)\n\t\tval |= SX150X_IRQ_TYPE_EDGE_RISING;\n\tif (flow_type & IRQ_TYPE_EDGE_FALLING)\n\t\tval |= SX150X_IRQ_TYPE_EDGE_FALLING;\n\n\tsx150x_irq_set_sense(pctl, n, val);\n\treturn 0;\n}\n\nstatic irqreturn_t sx150x_irq_thread_fn(int irq, void *dev_id)\n{\n\tstruct sx150x_pinctrl *pctl = (struct sx150x_pinctrl *)dev_id;\n\tunsigned long n, status;\n\tunsigned int val;\n\tint err;\n\n\terr = regmap_read(pctl->regmap, pctl->data->reg_irq_src, &val);\n\tif (err < 0)\n\t\treturn IRQ_NONE;\n\n\terr = regmap_write(pctl->regmap, pctl->data->reg_irq_src, val);\n\tif (err < 0)\n\t\treturn IRQ_NONE;\n\n\tstatus = val;\n\tfor_each_set_bit(n, &status, pctl->data->ngpios)\n\t\thandle_nested_irq(irq_find_mapping(pctl->gpio.irq.domain, n));\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void sx150x_irq_bus_lock(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct sx150x_pinctrl *pctl = gpiochip_get_data(gc);\n\n\tmutex_lock(&pctl->lock);\n}\n\nstatic void sx150x_irq_bus_sync_unlock(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct sx150x_pinctrl *pctl = gpiochip_get_data(gc);\n\n\tregmap_write(pctl->regmap, pctl->data->reg_irq_mask, pctl->irq.masked);\n\tregmap_write(pctl->regmap, pctl->data->reg_sense, pctl->irq.sense);\n\tmutex_unlock(&pctl->lock);\n}\n\n\nstatic void sx150x_irq_print_chip(struct irq_data *d, struct seq_file *p)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct sx150x_pinctrl *pctl = gpiochip_get_data(gc);\n\n\tseq_printf(p, pctl->client->name);\n}\n\nstatic const struct irq_chip sx150x_irq_chip = {\n\t.irq_mask = sx150x_irq_mask,\n\t.irq_unmask = sx150x_irq_unmask,\n\t.irq_set_type = sx150x_irq_set_type,\n\t.irq_bus_lock = sx150x_irq_bus_lock,\n\t.irq_bus_sync_unlock = sx150x_irq_bus_sync_unlock,\n\t.irq_print_chip = sx150x_irq_print_chip,\n\t.flags = IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic int sx150x_pinconf_get(struct pinctrl_dev *pctldev, unsigned int pin,\n\t\t\t      unsigned long *config)\n{\n\tstruct sx150x_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tunsigned int param = pinconf_to_config_param(*config);\n\tint ret;\n\tu32 arg;\n\tunsigned int data;\n\n\tif (sx150x_pin_is_oscio(pctl, pin)) {\n\t\tswitch (param) {\n\t\tcase PIN_CONFIG_DRIVE_PUSH_PULL:\n\t\tcase PIN_CONFIG_OUTPUT:\n\t\t\tret = regmap_read(pctl->regmap,\n\t\t\t\t\t  pctl->data->pri.x789.reg_clock,\n\t\t\t\t\t  &data);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tif (param == PIN_CONFIG_DRIVE_PUSH_PULL)\n\t\t\t\targ = (data & 0x1f) ? 1 : 0;\n\t\t\telse {\n\t\t\t\tif ((data & 0x1f) == 0x1f)\n\t\t\t\t\targ = 1;\n\t\t\t\telse if ((data & 0x1f) == 0x10)\n\t\t\t\t\targ = 0;\n\t\t\t\telse\n\t\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\n\t\tgoto out;\n\t}\n\n\tswitch (param) {\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\tret = regmap_read(pctl->regmap,\n\t\t\t\t  pctl->data->reg_pulldn,\n\t\t\t\t  &data);\n\t\tdata &= BIT(pin);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (!ret)\n\t\t\treturn -EINVAL;\n\n\t\targ = 1;\n\t\tbreak;\n\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\tret = regmap_read(pctl->regmap,\n\t\t\t\t  pctl->data->reg_pullup,\n\t\t\t\t  &data);\n\t\tdata &= BIT(pin);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (!ret)\n\t\t\treturn -EINVAL;\n\n\t\targ = 1;\n\t\tbreak;\n\n\tcase PIN_CONFIG_DRIVE_OPEN_DRAIN:\n\t\tif (pctl->data->model != SX150X_789)\n\t\t\treturn -ENOTSUPP;\n\n\t\tret = regmap_read(pctl->regmap,\n\t\t\t\t  pctl->data->pri.x789.reg_drain,\n\t\t\t\t  &data);\n\t\tdata &= BIT(pin);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (!data)\n\t\t\treturn -EINVAL;\n\n\t\targ = 1;\n\t\tbreak;\n\n\tcase PIN_CONFIG_DRIVE_PUSH_PULL:\n\t\tif (pctl->data->model != SX150X_789)\n\t\t\targ = true;\n\t\telse {\n\t\t\tret = regmap_read(pctl->regmap,\n\t\t\t\t\t  pctl->data->pri.x789.reg_drain,\n\t\t\t\t\t  &data);\n\t\t\tdata &= BIT(pin);\n\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tif (data)\n\t\t\t\treturn -EINVAL;\n\n\t\t\targ = 1;\n\t\t}\n\t\tbreak;\n\n\tcase PIN_CONFIG_OUTPUT:\n\t\tret = sx150x_gpio_get_direction(&pctl->gpio, pin);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (ret == GPIO_LINE_DIRECTION_IN)\n\t\t\treturn -EINVAL;\n\n\t\tret = sx150x_gpio_get(&pctl->gpio, pin);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\targ = ret;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\nout:\n\t*config = pinconf_to_config_packed(param, arg);\n\n\treturn 0;\n}\n\nstatic int sx150x_pinconf_set(struct pinctrl_dev *pctldev, unsigned int pin,\n\t\t\t      unsigned long *configs, unsigned int num_configs)\n{\n\tstruct sx150x_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tenum pin_config_param param;\n\tu32 arg;\n\tint i;\n\tint ret;\n\n\tfor (i = 0; i < num_configs; i++) {\n\t\tparam = pinconf_to_config_param(configs[i]);\n\t\targ = pinconf_to_config_argument(configs[i]);\n\n\t\tif (sx150x_pin_is_oscio(pctl, pin)) {\n\t\t\tif (param == PIN_CONFIG_OUTPUT) {\n\t\t\t\tret = sx150x_gpio_direction_output(&pctl->gpio,\n\t\t\t\t\t\t\t\t   pin, arg);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn ret;\n\n\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\treturn -ENOTSUPP;\n\t\t}\n\n\t\tswitch (param) {\n\t\tcase PIN_CONFIG_BIAS_PULL_PIN_DEFAULT:\n\t\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\t\tret = regmap_write_bits(pctl->regmap,\n\t\t\t\t\t\tpctl->data->reg_pulldn,\n\t\t\t\t\t\tBIT(pin), 0);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tret = regmap_write_bits(pctl->regmap,\n\t\t\t\t\t\tpctl->data->reg_pullup,\n\t\t\t\t\t\tBIT(pin), 0);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tbreak;\n\n\t\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\t\tret = regmap_write_bits(pctl->regmap,\n\t\t\t\t\t\tpctl->data->reg_pullup,\n\t\t\t\t\t\tBIT(pin), BIT(pin));\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tbreak;\n\n\t\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\t\tret = regmap_write_bits(pctl->regmap,\n\t\t\t\t\t\tpctl->data->reg_pulldn,\n\t\t\t\t\t\tBIT(pin), BIT(pin));\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tbreak;\n\n\t\tcase PIN_CONFIG_DRIVE_OPEN_DRAIN:\n\t\t\tif (pctl->data->model != SX150X_789 ||\n\t\t\t    sx150x_pin_is_oscio(pctl, pin))\n\t\t\t\treturn -ENOTSUPP;\n\n\t\t\tret = regmap_write_bits(pctl->regmap,\n\t\t\t\t\t\tpctl->data->pri.x789.reg_drain,\n\t\t\t\t\t\tBIT(pin), BIT(pin));\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tbreak;\n\n\t\tcase PIN_CONFIG_DRIVE_PUSH_PULL:\n\t\t\tif (pctl->data->model != SX150X_789 ||\n\t\t\t    sx150x_pin_is_oscio(pctl, pin))\n\t\t\t\treturn 0;\n\n\t\t\tret = regmap_write_bits(pctl->regmap,\n\t\t\t\t\t\tpctl->data->pri.x789.reg_drain,\n\t\t\t\t\t\tBIT(pin), 0);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tbreak;\n\n\t\tcase PIN_CONFIG_OUTPUT:\n\t\t\tret = sx150x_gpio_direction_output(&pctl->gpio,\n\t\t\t\t\t\t\t   pin, arg);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t}  \n\n\treturn 0;\n}\n\nstatic const struct pinconf_ops sx150x_pinconf_ops = {\n\t.pin_config_get = sx150x_pinconf_get,\n\t.pin_config_set = sx150x_pinconf_set,\n\t.is_generic = true,\n};\n\nstatic const struct i2c_device_id sx150x_id[] = {\n\t{\"sx1501q\", (kernel_ulong_t) &sx1501q_device_data },\n\t{\"sx1502q\", (kernel_ulong_t) &sx1502q_device_data },\n\t{\"sx1503q\", (kernel_ulong_t) &sx1503q_device_data },\n\t{\"sx1504q\", (kernel_ulong_t) &sx1504q_device_data },\n\t{\"sx1505q\", (kernel_ulong_t) &sx1505q_device_data },\n\t{\"sx1506q\", (kernel_ulong_t) &sx1506q_device_data },\n\t{\"sx1507q\", (kernel_ulong_t) &sx1507q_device_data },\n\t{\"sx1508q\", (kernel_ulong_t) &sx1508q_device_data },\n\t{\"sx1509q\", (kernel_ulong_t) &sx1509q_device_data },\n\t{}\n};\n\nstatic const struct of_device_id sx150x_of_match[] = {\n\t{ .compatible = \"semtech,sx1501q\", .data = &sx1501q_device_data },\n\t{ .compatible = \"semtech,sx1502q\", .data = &sx1502q_device_data },\n\t{ .compatible = \"semtech,sx1503q\", .data = &sx1503q_device_data },\n\t{ .compatible = \"semtech,sx1504q\", .data = &sx1504q_device_data },\n\t{ .compatible = \"semtech,sx1505q\", .data = &sx1505q_device_data },\n\t{ .compatible = \"semtech,sx1506q\", .data = &sx1506q_device_data },\n\t{ .compatible = \"semtech,sx1507q\", .data = &sx1507q_device_data },\n\t{ .compatible = \"semtech,sx1508q\", .data = &sx1508q_device_data },\n\t{ .compatible = \"semtech,sx1509q\", .data = &sx1509q_device_data },\n\t{},\n};\n\nstatic int sx150x_reset(struct sx150x_pinctrl *pctl)\n{\n\tint err;\n\n\terr = i2c_smbus_write_byte_data(pctl->client,\n\t\t\t\t\tpctl->data->pri.x789.reg_reset,\n\t\t\t\t\tSX150X_789_RESET_KEY1);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = i2c_smbus_write_byte_data(pctl->client,\n\t\t\t\t\tpctl->data->pri.x789.reg_reset,\n\t\t\t\t\tSX150X_789_RESET_KEY2);\n\treturn err;\n}\n\nstatic int sx150x_init_misc(struct sx150x_pinctrl *pctl)\n{\n\tu8 reg, value;\n\n\tswitch (pctl->data->model) {\n\tcase SX150X_789:\n\t\treg   = pctl->data->pri.x789.reg_misc;\n\t\tvalue = SX150X_789_REG_MISC_AUTOCLEAR_OFF;\n\t\tbreak;\n\tcase SX150X_456:\n\t\treg   = pctl->data->pri.x456.reg_advanced;\n\t\tvalue = 0x00;\n\n\t\t \n\t\tif (!reg)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase SX150X_123:\n\t\treg   = pctl->data->pri.x123.reg_advanced;\n\t\tvalue = 0x00;\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"Unknown chip model %d\\n\", pctl->data->model);\n\t\treturn -EINVAL;\n\t}\n\n\treturn regmap_write(pctl->regmap, reg, value);\n}\n\nstatic int sx150x_init_hw(struct sx150x_pinctrl *pctl)\n{\n\tconst u8 reg[] = {\n\t\t[SX150X_789] = pctl->data->pri.x789.reg_polarity,\n\t\t[SX150X_456] = pctl->data->pri.x456.reg_pld_mode,\n\t\t[SX150X_123] = pctl->data->pri.x123.reg_pld_mode,\n\t};\n\tint err;\n\n\tif (pctl->data->model == SX150X_789 &&\n\t    of_property_read_bool(pctl->dev->of_node, \"semtech,probe-reset\")) {\n\t\terr = sx150x_reset(pctl);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\terr = sx150x_init_misc(pctl);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\treturn regmap_write(pctl->regmap, reg[pctl->data->model], 0);\n}\n\nstatic int sx150x_regmap_reg_width(struct sx150x_pinctrl *pctl,\n\t\t\t\t   unsigned int reg)\n{\n\tconst struct sx150x_device_data *data = pctl->data;\n\n\tif (reg == data->reg_sense) {\n\t\t \n\t\treturn 2 * data->ngpios;\n\t} else if ((data->model == SX150X_789 &&\n\t\t    (reg == data->pri.x789.reg_misc ||\n\t\t     reg == data->pri.x789.reg_clock ||\n\t\t     reg == data->pri.x789.reg_reset))\n\t\t   ||\n\t\t   (data->model == SX150X_123 &&\n\t\t    reg == data->pri.x123.reg_advanced)\n\t\t   ||\n\t\t   (data->model == SX150X_456 &&\n\t\t    data->pri.x456.reg_advanced &&\n\t\t    reg == data->pri.x456.reg_advanced)) {\n\t\treturn 8;\n\t} else {\n\t\treturn data->ngpios;\n\t}\n}\n\nstatic unsigned int sx150x_maybe_swizzle(struct sx150x_pinctrl *pctl,\n\t\t\t\t\t unsigned int reg, unsigned int val)\n{\n\tunsigned int a, b;\n\tconst struct sx150x_device_data *data = pctl->data;\n\n\t \n\n\tif (reg == data->reg_sense &&\n\t    data->ngpios == 16 &&\n\t    (data->model == SX150X_123 ||\n\t     data->model == SX150X_456)) {\n\t\ta = val & 0x00ff0000;\n\t\tb = val & 0x0000ff00;\n\n\t\tval &= 0xff0000ff;\n\t\tval |= b << 8;\n\t\tval |= a >> 8;\n\t}\n\n\treturn val;\n}\n\n \nstatic int sx150x_regmap_reg_read(void *context, unsigned int reg,\n\t\t\t\t  unsigned int *result)\n{\n\tint ret, n;\n\tstruct sx150x_pinctrl *pctl = context;\n\tstruct i2c_client *i2c = pctl->client;\n\tconst int width = sx150x_regmap_reg_width(pctl, reg);\n\tunsigned int idx, val;\n\n\t \n\n\tfor (n = width, val = 0, idx = reg; n > 0; n -= 8, idx++) {\n\t\tval <<= 8;\n\n\t\tret = i2c_smbus_read_byte_data(i2c, idx);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tval |= ret;\n\t}\n\n\t*result = sx150x_maybe_swizzle(pctl, reg, val);\n\n\treturn 0;\n}\n\nstatic int sx150x_regmap_reg_write(void *context, unsigned int reg,\n\t\t\t\t   unsigned int val)\n{\n\tint ret, n;\n\tstruct sx150x_pinctrl *pctl = context;\n\tstruct i2c_client *i2c = pctl->client;\n\tconst int width = sx150x_regmap_reg_width(pctl, reg);\n\n\tval = sx150x_maybe_swizzle(pctl, reg, val);\n\n\tn = (width - 1) & ~7;\n\tdo {\n\t\tconst u8 byte = (val >> n) & 0xff;\n\n\t\tret = i2c_smbus_write_byte_data(i2c, reg, byte);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\treg++;\n\t\tn -= 8;\n\t} while (n >= 0);\n\n\treturn 0;\n}\n\nstatic bool sx150x_reg_volatile(struct device *dev, unsigned int reg)\n{\n\tstruct sx150x_pinctrl *pctl = i2c_get_clientdata(to_i2c_client(dev));\n\n\treturn reg == pctl->data->reg_irq_src || reg == pctl->data->reg_data;\n}\n\nstatic const struct regmap_config sx150x_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 32,\n\n\t.cache_type = REGCACHE_RBTREE,\n\n\t.reg_read = sx150x_regmap_reg_read,\n\t.reg_write = sx150x_regmap_reg_write,\n\n\t.max_register = SX150X_MAX_REGISTER,\n\t.volatile_reg = sx150x_reg_volatile,\n};\n\nstatic int sx150x_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstatic const u32 i2c_funcs = I2C_FUNC_SMBUS_BYTE_DATA |\n\t\t\t\t     I2C_FUNC_SMBUS_WRITE_WORD_DATA;\n\tstruct device *dev = &client->dev;\n\tstruct sx150x_pinctrl *pctl;\n\tint ret;\n\n\tif (!i2c_check_functionality(client->adapter, i2c_funcs))\n\t\treturn -ENOSYS;\n\n\tpctl = devm_kzalloc(dev, sizeof(*pctl), GFP_KERNEL);\n\tif (!pctl)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, pctl);\n\n\tpctl->dev = dev;\n\tpctl->client = client;\n\n\tif (dev->of_node)\n\t\tpctl->data = of_device_get_match_data(dev);\n\telse\n\t\tpctl->data = (struct sx150x_device_data *)id->driver_data;\n\n\tif (!pctl->data)\n\t\treturn -EINVAL;\n\n\tpctl->regmap = devm_regmap_init(dev, NULL, pctl,\n\t\t\t\t\t&sx150x_regmap_config);\n\tif (IS_ERR(pctl->regmap)) {\n\t\tret = PTR_ERR(pctl->regmap);\n\t\tdev_err(dev, \"Failed to allocate register map: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tmutex_init(&pctl->lock);\n\n\tret = sx150x_init_hw(pctl);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tpctl->pinctrl_desc.name = \"sx150x-pinctrl\";\n\tpctl->pinctrl_desc.pctlops = &sx150x_pinctrl_ops;\n\tpctl->pinctrl_desc.confops = &sx150x_pinconf_ops;\n\tpctl->pinctrl_desc.pins = pctl->data->pins;\n\tpctl->pinctrl_desc.npins = pctl->data->npins;\n\tpctl->pinctrl_desc.owner = THIS_MODULE;\n\n\tret = devm_pinctrl_register_and_init(dev, &pctl->pinctrl_desc,\n\t\t\t\t\t     pctl, &pctl->pctldev);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to register pinctrl device\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tpctl->gpio.base = -1;\n\tpctl->gpio.ngpio = pctl->data->npins;\n\tpctl->gpio.get_direction = sx150x_gpio_get_direction;\n\tpctl->gpio.direction_input = sx150x_gpio_direction_input;\n\tpctl->gpio.direction_output = sx150x_gpio_direction_output;\n\tpctl->gpio.get = sx150x_gpio_get;\n\tpctl->gpio.set = sx150x_gpio_set;\n\tpctl->gpio.set_config = gpiochip_generic_config;\n\tpctl->gpio.parent = dev;\n\tpctl->gpio.can_sleep = true;\n\tpctl->gpio.label = devm_kstrdup(dev, client->name, GFP_KERNEL);\n\tif (!pctl->gpio.label)\n\t\treturn -ENOMEM;\n\n\t \n\tif (pctl->data->model != SX150X_789)\n\t\tpctl->gpio.set_multiple = sx150x_gpio_set_multiple;\n\n\t \n\tif (client->irq > 0) {\n\t\tstruct gpio_irq_chip *girq;\n\n\t\tpctl->irq.masked = ~0;\n\t\tpctl->irq.sense = 0;\n\t\t \n\t\tgirq = &pctl->gpio.irq;\n\t\tgpio_irq_chip_set_chip(girq, &sx150x_irq_chip);\n\t\t \n\t\tgirq->parent_handler = NULL;\n\t\tgirq->num_parents = 0;\n\t\tgirq->parents = NULL;\n\t\tgirq->default_type = IRQ_TYPE_NONE;\n\t\tgirq->handler = handle_bad_irq;\n\t\tgirq->threaded = true;\n\n\t\tret = devm_request_threaded_irq(dev, client->irq, NULL,\n\t\t\t\t\t\tsx150x_irq_thread_fn,\n\t\t\t\t\t\tIRQF_ONESHOT | IRQF_SHARED |\n\t\t\t\t\t\tIRQF_TRIGGER_FALLING,\n\t\t\t\t\t\tclient->name, pctl);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tret = devm_gpiochip_add_data(dev, &pctl->gpio, pctl);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = pinctrl_enable(pctl->pctldev);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to enable pinctrl device\\n\");\n\t\treturn ret;\n\t}\n\n\tret = gpiochip_add_pin_range(&pctl->gpio, dev_name(dev),\n\t\t\t\t     0, 0, pctl->data->npins);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic struct i2c_driver sx150x_driver = {\n\t.driver = {\n\t\t.name = \"sx150x-pinctrl\",\n\t\t.of_match_table = sx150x_of_match,\n\t},\n\t.probe = sx150x_probe,\n\t.id_table = sx150x_id,\n};\n\nstatic int __init sx150x_init(void)\n{\n\treturn i2c_add_driver(&sx150x_driver);\n}\nsubsys_initcall(sx150x_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}