{
  "module_name": "pinctrl-axp209.c",
  "hash_id": "a38f974612c57ab20598562a5729076a15080cdd172d920e8897304f6135b8c8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/pinctrl-axp209.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/device.h>\n#include <linux/gpio/driver.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/mfd/axp20x.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n#include <linux/pinctrl/consumer.h>\n#include <linux/pinctrl/pinconf-generic.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinmux.h>\n\n#define AXP20X_GPIO_FUNCTIONS\t\t0x7\n#define AXP20X_GPIO_FUNCTION_OUT_LOW\t0\n#define AXP20X_GPIO_FUNCTION_OUT_HIGH\t1\n#define AXP20X_GPIO_FUNCTION_INPUT\t2\n\n#define AXP20X_GPIO3_FUNCTIONS\t\tGENMASK(2, 1)\n#define AXP20X_GPIO3_FUNCTION_OUT_LOW\t0\n#define AXP20X_GPIO3_FUNCTION_OUT_HIGH\t2\n#define AXP20X_GPIO3_FUNCTION_INPUT\t4\n\n#define AXP20X_FUNC_GPIO_OUT\t\t0\n#define AXP20X_FUNC_GPIO_IN\t\t1\n#define AXP20X_FUNC_LDO\t\t\t2\n#define AXP20X_FUNC_ADC\t\t\t3\n#define AXP20X_FUNCS_NB\t\t\t4\n\n#define AXP20X_MUX_GPIO_OUT\t\t0\n#define AXP20X_MUX_GPIO_IN\t\tBIT(1)\n#define AXP20X_MUX_ADC\t\t\tBIT(2)\n\n#define AXP813_MUX_ADC\t\t\t(BIT(2) | BIT(0))\n\nstruct axp20x_pctrl_desc {\n\tconst struct pinctrl_pin_desc\t*pins;\n\tunsigned int\t\t\tnpins;\n\t \n\tu8\t\t\t\tldo_mask;\n\t \n\tu8\t\t\t\tadc_mask;\n\tu8\t\t\t\tgpio_status_offset;\n\tu8\t\t\t\tadc_mux;\n};\n\nstruct axp20x_pinctrl_function {\n\tconst char\t*name;\n\tunsigned int\tmuxval;\n\tconst char\t**groups;\n\tunsigned int\tngroups;\n};\n\nstruct axp20x_pctl {\n\tstruct gpio_chip\tchip;\n\tstruct regmap\t\t*regmap;\n\tstruct pinctrl_dev\t\t\t*pctl_dev;\n\tstruct device\t\t\t\t*dev;\n\tconst struct axp20x_pctrl_desc\t\t*desc;\n\tstruct axp20x_pinctrl_function\t\tfuncs[AXP20X_FUNCS_NB];\n};\n\nstatic const struct pinctrl_pin_desc axp209_pins[] = {\n\tPINCTRL_PIN(0, \"GPIO0\"),\n\tPINCTRL_PIN(1, \"GPIO1\"),\n\tPINCTRL_PIN(2, \"GPIO2\"),\n\tPINCTRL_PIN(3, \"GPIO3\"),\n};\n\nstatic const struct pinctrl_pin_desc axp22x_pins[] = {\n\tPINCTRL_PIN(0, \"GPIO0\"),\n\tPINCTRL_PIN(1, \"GPIO1\"),\n};\n\nstatic const struct axp20x_pctrl_desc axp20x_data = {\n\t.pins\t= axp209_pins,\n\t.npins\t= ARRAY_SIZE(axp209_pins),\n\t.ldo_mask = BIT(0) | BIT(1),\n\t.adc_mask = BIT(0) | BIT(1),\n\t.gpio_status_offset = 4,\n\t.adc_mux = AXP20X_MUX_ADC,\n};\n\nstatic const struct axp20x_pctrl_desc axp22x_data = {\n\t.pins\t= axp22x_pins,\n\t.npins\t= ARRAY_SIZE(axp22x_pins),\n\t.ldo_mask = BIT(0) | BIT(1),\n\t.gpio_status_offset = 0,\n};\n\nstatic const struct axp20x_pctrl_desc axp813_data = {\n\t.pins\t= axp22x_pins,\n\t.npins\t= ARRAY_SIZE(axp22x_pins),\n\t.ldo_mask = BIT(0) | BIT(1),\n\t.adc_mask = BIT(0),\n\t.gpio_status_offset = 0,\n\t.adc_mux = AXP813_MUX_ADC,\n};\n\nstatic int axp20x_gpio_get_reg(unsigned int offset)\n{\n\tswitch (offset) {\n\tcase 0:\n\t\treturn AXP20X_GPIO0_CTRL;\n\tcase 1:\n\t\treturn AXP20X_GPIO1_CTRL;\n\tcase 2:\n\t\treturn AXP20X_GPIO2_CTRL;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int axp20x_gpio_input(struct gpio_chip *chip, unsigned int offset)\n{\n\treturn pinctrl_gpio_direction_input(chip->base + offset);\n}\n\nstatic int axp20x_gpio_get(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct axp20x_pctl *pctl = gpiochip_get_data(chip);\n\tunsigned int val;\n\tint ret;\n\n\t \n\tif (offset == 3) {\n\t\tret = regmap_read(pctl->regmap, AXP20X_GPIO3_CTRL, &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\treturn !!(val & BIT(0));\n\t}\n\n\tret = regmap_read(pctl->regmap, AXP20X_GPIO20_SS, &val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn !!(val & BIT(offset + pctl->desc->gpio_status_offset));\n}\n\nstatic int axp20x_gpio_get_direction(struct gpio_chip *chip,\n\t\t\t\t     unsigned int offset)\n{\n\tstruct axp20x_pctl *pctl = gpiochip_get_data(chip);\n\tunsigned int val;\n\tint reg, ret;\n\n\t \n\tif (offset == 3) {\n\t\tret = regmap_read(pctl->regmap, AXP20X_GPIO3_CTRL, &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (val & AXP20X_GPIO3_FUNCTION_INPUT)\n\t\t\treturn GPIO_LINE_DIRECTION_IN;\n\n\t\treturn GPIO_LINE_DIRECTION_OUT;\n\t}\n\n\treg = axp20x_gpio_get_reg(offset);\n\tif (reg < 0)\n\t\treturn reg;\n\n\tret = regmap_read(pctl->regmap, reg, &val);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif ((val & AXP20X_GPIO_FUNCTIONS) > 2)\n\t\treturn GPIO_LINE_DIRECTION_OUT;\n\n\t \n\tif (val & 2)\n\t\treturn GPIO_LINE_DIRECTION_IN;\n\n\treturn GPIO_LINE_DIRECTION_OUT;\n}\n\nstatic int axp20x_gpio_output(struct gpio_chip *chip, unsigned int offset,\n\t\t\t      int value)\n{\n\tchip->set(chip, offset, value);\n\n\treturn 0;\n}\n\nstatic void axp20x_gpio_set(struct gpio_chip *chip, unsigned int offset,\n\t\t\t    int value)\n{\n\tstruct axp20x_pctl *pctl = gpiochip_get_data(chip);\n\tint reg;\n\n\t \n\tif (offset == 3) {\n\t\tregmap_update_bits(pctl->regmap, AXP20X_GPIO3_CTRL,\n\t\t\t\t   AXP20X_GPIO3_FUNCTIONS,\n\t\t\t\t   value ? AXP20X_GPIO3_FUNCTION_OUT_HIGH :\n\t\t\t\t   AXP20X_GPIO3_FUNCTION_OUT_LOW);\n\t\treturn;\n\t}\n\n\treg = axp20x_gpio_get_reg(offset);\n\tif (reg < 0)\n\t\treturn;\n\n\tregmap_update_bits(pctl->regmap, reg,\n\t\t\t   AXP20X_GPIO_FUNCTIONS,\n\t\t\t   value ? AXP20X_GPIO_FUNCTION_OUT_HIGH :\n\t\t\t   AXP20X_GPIO_FUNCTION_OUT_LOW);\n}\n\nstatic int axp20x_pmx_set(struct pinctrl_dev *pctldev, unsigned int offset,\n\t\t\t  u8 config)\n{\n\tstruct axp20x_pctl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tint reg;\n\n\t \n\tif (offset == 3) {\n\t\treturn regmap_update_bits(pctl->regmap, AXP20X_GPIO3_CTRL,\n\t\t\t\t   AXP20X_GPIO3_FUNCTIONS,\n\t\t\t\t   config == AXP20X_MUX_GPIO_OUT ? AXP20X_GPIO3_FUNCTION_OUT_LOW :\n\t\t\t\t   AXP20X_GPIO3_FUNCTION_INPUT);\n\t}\n\n\treg = axp20x_gpio_get_reg(offset);\n\tif (reg < 0)\n\t\treturn reg;\n\n\treturn regmap_update_bits(pctl->regmap, reg, AXP20X_GPIO_FUNCTIONS,\n\t\t\t\t  config);\n}\n\nstatic int axp20x_pmx_func_cnt(struct pinctrl_dev *pctldev)\n{\n\tstruct axp20x_pctl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn ARRAY_SIZE(pctl->funcs);\n}\n\nstatic const char *axp20x_pmx_func_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\tunsigned int selector)\n{\n\tstruct axp20x_pctl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pctl->funcs[selector].name;\n}\n\nstatic int axp20x_pmx_func_groups(struct pinctrl_dev *pctldev,\n\t\t\t\t  unsigned int selector,\n\t\t\t\t  const char * const **groups,\n\t\t\t\t  unsigned int *num_groups)\n{\n\tstruct axp20x_pctl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\n\t*groups = pctl->funcs[selector].groups;\n\t*num_groups = pctl->funcs[selector].ngroups;\n\n\treturn 0;\n}\n\nstatic int axp20x_pmx_set_mux(struct pinctrl_dev *pctldev,\n\t\t\t      unsigned int function, unsigned int group)\n{\n\tstruct axp20x_pctl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tunsigned int mask;\n\n\t \n\tif (function <= AXP20X_FUNC_GPIO_IN)\n\t\treturn axp20x_pmx_set(pctldev, group,\n\t\t\t\t      pctl->funcs[function].muxval);\n\n\tif (function == AXP20X_FUNC_LDO)\n\t\tmask = pctl->desc->ldo_mask;\n\telse\n\t\tmask = pctl->desc->adc_mask;\n\n\tif (!(BIT(group) & mask))\n\t\treturn -EINVAL;\n\n\t \n\tif (function == AXP20X_FUNC_LDO)\n\t\treturn 0;\n\n\treturn axp20x_pmx_set(pctldev, group, pctl->funcs[function].muxval);\n}\n\nstatic int axp20x_pmx_gpio_set_direction(struct pinctrl_dev *pctldev,\n\t\t\t\t\t struct pinctrl_gpio_range *range,\n\t\t\t\t\t unsigned int offset, bool input)\n{\n\tstruct axp20x_pctl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\n\tif (input)\n\t\treturn axp20x_pmx_set(pctldev, offset,\n\t\t\t\t      pctl->funcs[AXP20X_FUNC_GPIO_IN].muxval);\n\n\treturn axp20x_pmx_set(pctldev, offset,\n\t\t\t      pctl->funcs[AXP20X_FUNC_GPIO_OUT].muxval);\n}\n\nstatic const struct pinmux_ops axp20x_pmx_ops = {\n\t.get_functions_count\t= axp20x_pmx_func_cnt,\n\t.get_function_name\t= axp20x_pmx_func_name,\n\t.get_function_groups\t= axp20x_pmx_func_groups,\n\t.set_mux\t\t= axp20x_pmx_set_mux,\n\t.gpio_set_direction\t= axp20x_pmx_gpio_set_direction,\n\t.strict\t\t\t= true,\n};\n\nstatic int axp20x_groups_cnt(struct pinctrl_dev *pctldev)\n{\n\tstruct axp20x_pctl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pctl->desc->npins;\n}\n\nstatic int axp20x_group_pins(struct pinctrl_dev *pctldev, unsigned int selector,\n\t\t\t     const unsigned int **pins, unsigned int *num_pins)\n{\n\tstruct axp20x_pctl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\n\t*pins = (unsigned int *)&pctl->desc->pins[selector];\n\t*num_pins = 1;\n\n\treturn 0;\n}\n\nstatic const char *axp20x_group_name(struct pinctrl_dev *pctldev,\n\t\t\t\t     unsigned int selector)\n{\n\tstruct axp20x_pctl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pctl->desc->pins[selector].name;\n}\n\nstatic const struct pinctrl_ops axp20x_pctrl_ops = {\n\t.dt_node_to_map\t\t= pinconf_generic_dt_node_to_map_group,\n\t.dt_free_map\t\t= pinconf_generic_dt_free_map,\n\t.get_groups_count\t= axp20x_groups_cnt,\n\t.get_group_name\t\t= axp20x_group_name,\n\t.get_group_pins\t\t= axp20x_group_pins,\n};\n\nstatic int axp20x_funcs_groups_from_mask(struct device *dev, unsigned int mask,\n\t\t\t\t\t  unsigned int mask_len,\n\t\t\t\t\t  struct axp20x_pinctrl_function *func,\n\t\t\t\t\t  const struct pinctrl_pin_desc *pins)\n{\n\tunsigned long int mask_cpy = mask;\n\tconst char **group;\n\tunsigned int ngroups = hweight8(mask);\n\tint bit;\n\n\tfunc->ngroups = ngroups;\n\tif (func->ngroups > 0) {\n\t\tfunc->groups = devm_kcalloc(dev,\n\t\t\t\t\t    ngroups, sizeof(const char *),\n\t\t\t\t\t    GFP_KERNEL);\n\t\tif (!func->groups)\n\t\t\treturn -ENOMEM;\n\t\tgroup = func->groups;\n\t\tfor_each_set_bit(bit, &mask_cpy, mask_len) {\n\t\t\t*group = pins[bit].name;\n\t\t\tgroup++;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int axp20x_build_funcs_groups(struct platform_device *pdev)\n{\n\tstruct axp20x_pctl *pctl = platform_get_drvdata(pdev);\n\tint i, ret, pin, npins = pctl->desc->npins;\n\n\tpctl->funcs[AXP20X_FUNC_GPIO_OUT].name = \"gpio_out\";\n\tpctl->funcs[AXP20X_FUNC_GPIO_OUT].muxval = AXP20X_MUX_GPIO_OUT;\n\tpctl->funcs[AXP20X_FUNC_GPIO_IN].name = \"gpio_in\";\n\tpctl->funcs[AXP20X_FUNC_GPIO_IN].muxval = AXP20X_MUX_GPIO_IN;\n\tpctl->funcs[AXP20X_FUNC_LDO].name = \"ldo\";\n\t \n\tpctl->funcs[AXP20X_FUNC_ADC].name = \"adc\";\n\tpctl->funcs[AXP20X_FUNC_ADC].muxval = pctl->desc->adc_mux;\n\n\t \n\tfor (i = 0; i <= AXP20X_FUNC_GPIO_IN; i++) {\n\t\tpctl->funcs[i].ngroups = npins;\n\t\tpctl->funcs[i].groups = devm_kcalloc(&pdev->dev,\n\t\t\t\t\t\t     npins, sizeof(char *),\n\t\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!pctl->funcs[i].groups)\n\t\t\treturn -ENOMEM;\n\t\tfor (pin = 0; pin < npins; pin++)\n\t\t\tpctl->funcs[i].groups[pin] = pctl->desc->pins[pin].name;\n\t}\n\n\tret = axp20x_funcs_groups_from_mask(&pdev->dev, pctl->desc->ldo_mask,\n\t\t\t\t      npins, &pctl->funcs[AXP20X_FUNC_LDO],\n\t\t\t\t      pctl->desc->pins);\n\tif (ret)\n\t\treturn ret;\n\n\tret = axp20x_funcs_groups_from_mask(&pdev->dev, pctl->desc->adc_mask,\n\t\t\t\t      npins, &pctl->funcs[AXP20X_FUNC_ADC],\n\t\t\t\t      pctl->desc->pins);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic const struct of_device_id axp20x_pctl_match[] = {\n\t{ .compatible = \"x-powers,axp209-gpio\", .data = &axp20x_data, },\n\t{ .compatible = \"x-powers,axp221-gpio\", .data = &axp22x_data, },\n\t{ .compatible = \"x-powers,axp813-gpio\", .data = &axp813_data, },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, axp20x_pctl_match);\n\nstatic int axp20x_pctl_probe(struct platform_device *pdev)\n{\n\tstruct axp20x_dev *axp20x = dev_get_drvdata(pdev->dev.parent);\n\tstruct axp20x_pctl *pctl;\n\tstruct device *dev = &pdev->dev;\n\tstruct pinctrl_desc *pctrl_desc;\n\tint ret;\n\n\tif (!of_device_is_available(pdev->dev.of_node))\n\t\treturn -ENODEV;\n\n\tif (!axp20x) {\n\t\tdev_err(&pdev->dev, \"Parent drvdata not set\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpctl = devm_kzalloc(&pdev->dev, sizeof(*pctl), GFP_KERNEL);\n\tif (!pctl)\n\t\treturn -ENOMEM;\n\n\tpctl->chip.base\t\t\t= -1;\n\tpctl->chip.can_sleep\t\t= true;\n\tpctl->chip.request\t\t= gpiochip_generic_request;\n\tpctl->chip.free\t\t\t= gpiochip_generic_free;\n\tpctl->chip.parent\t\t= &pdev->dev;\n\tpctl->chip.label\t\t= dev_name(&pdev->dev);\n\tpctl->chip.owner\t\t= THIS_MODULE;\n\tpctl->chip.get\t\t\t= axp20x_gpio_get;\n\tpctl->chip.get_direction\t= axp20x_gpio_get_direction;\n\tpctl->chip.set\t\t\t= axp20x_gpio_set;\n\tpctl->chip.direction_input\t= axp20x_gpio_input;\n\tpctl->chip.direction_output\t= axp20x_gpio_output;\n\n\tpctl->desc = of_device_get_match_data(dev);\n\n\tpctl->chip.ngpio\t\t= pctl->desc->npins;\n\n\tpctl->regmap = axp20x->regmap;\n\tpctl->dev = &pdev->dev;\n\n\tplatform_set_drvdata(pdev, pctl);\n\n\tret = axp20x_build_funcs_groups(pdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to build groups\\n\");\n\t\treturn ret;\n\t}\n\n\tpctrl_desc = devm_kzalloc(&pdev->dev, sizeof(*pctrl_desc), GFP_KERNEL);\n\tif (!pctrl_desc)\n\t\treturn -ENOMEM;\n\n\tpctrl_desc->name = dev_name(&pdev->dev);\n\tpctrl_desc->owner = THIS_MODULE;\n\tpctrl_desc->pins = pctl->desc->pins;\n\tpctrl_desc->npins = pctl->desc->npins;\n\tpctrl_desc->pctlops = &axp20x_pctrl_ops;\n\tpctrl_desc->pmxops = &axp20x_pmx_ops;\n\n\tpctl->pctl_dev = devm_pinctrl_register(&pdev->dev, pctrl_desc, pctl);\n\tif (IS_ERR(pctl->pctl_dev)) {\n\t\tdev_err(&pdev->dev, \"couldn't register pinctrl driver\\n\");\n\t\treturn PTR_ERR(pctl->pctl_dev);\n\t}\n\n\tret = devm_gpiochip_add_data(&pdev->dev, &pctl->chip, pctl);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to register GPIO chip\\n\");\n\t\treturn ret;\n\t}\n\n\tret = gpiochip_add_pin_range(&pctl->chip, dev_name(&pdev->dev),\n\t\t\t\t     pctl->desc->pins->number,\n\t\t\t\t     pctl->desc->pins->number,\n\t\t\t\t     pctl->desc->npins);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to add pin range\\n\");\n\t\treturn ret;\n\t}\n\n\tdev_info(&pdev->dev, \"AXP209 pinctrl and GPIO driver loaded\\n\");\n\n\treturn 0;\n}\n\nstatic struct platform_driver axp20x_pctl_driver = {\n\t.probe\t\t= axp20x_pctl_probe,\n\t.driver = {\n\t\t.name\t\t= \"axp20x-gpio\",\n\t\t.of_match_table\t= axp20x_pctl_match,\n\t},\n};\n\nmodule_platform_driver(axp20x_pctl_driver);\n\nMODULE_AUTHOR(\"Maxime Ripard <maxime.ripard@free-electrons.com>\");\nMODULE_AUTHOR(\"Quentin Schulz <quentin.schulz@free-electrons.com>\");\nMODULE_DESCRIPTION(\"AXP20x PMIC pinctrl and GPIO driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}