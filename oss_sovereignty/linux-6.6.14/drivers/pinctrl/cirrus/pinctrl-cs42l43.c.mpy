{
  "module_name": "pinctrl-cs42l43.c",
  "hash_id": "a6d86c52d2df023ab71aba02f82ce3d496da09f6ed6ee57d0f303b5c212faaf6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/cirrus/pinctrl-cs42l43.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/bits.h>\n#include <linux/build_bug.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/gpio/driver.h>\n#include <linux/mfd/cs42l43.h>\n#include <linux/mfd/cs42l43-regs.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/string_helpers.h>\n\n#include <linux/pinctrl/consumer.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinconf-generic.h>\n#include <linux/pinctrl/pinmux.h>\n\n#include \"../pinctrl-utils.h\"\n\n#define CS42L43_NUM_GPIOS 3\n\nstruct cs42l43_pin {\n\tstruct gpio_chip gpio_chip;\n\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tbool shutters_locked;\n};\n\nstruct cs42l43_pin_data {\n\tunsigned int reg;\n\tunsigned int shift;\n\tunsigned int mask;\n};\n\n#define CS42L43_PIN(_number, _name, _reg, _field) { \\\n\t.number = _number, .name = _name, \\\n\t.drv_data = &((struct cs42l43_pin_data){ \\\n\t\t.reg = CS42L43_##_reg, \\\n\t\t.shift = CS42L43_##_field##_DRV_SHIFT, \\\n\t\t.mask = CS42L43_##_field##_DRV_MASK, \\\n\t}), \\\n}\n\nstatic const struct pinctrl_pin_desc cs42l43_pin_pins[] = {\n\tCS42L43_PIN(0,\t\"gpio1\",\tDRV_CTRL4,\tGPIO1),\n\tCS42L43_PIN(1,\t\"gpio2\",\tDRV_CTRL4,\tGPIO2),\n\tCS42L43_PIN(2,\t\"gpio3\",\tDRV_CTRL4,\tGPIO3),\n\tCS42L43_PIN(3,\t\"asp_dout\",\tDRV_CTRL1,\tASP_DOUT),\n\tCS42L43_PIN(4,\t\"asp_fsync\",\tDRV_CTRL1,\tASP_FSYNC),\n\tCS42L43_PIN(5,\t\"asp_bclk\",\tDRV_CTRL1,\tASP_BCLK),\n\tCS42L43_PIN(6,\t\"pdmout2_clk\",\tDRV_CTRL3,\tPDMOUT2_CLK),\n\tCS42L43_PIN(7,\t\"pdmout2_data\",\tDRV_CTRL3,\tPDMOUT2_DATA),\n\tCS42L43_PIN(8,\t\"pdmout1_clk\",\tDRV_CTRL3,\tPDMOUT1_CLK),\n\tCS42L43_PIN(9,\t\"pdmout1_data\",\tDRV_CTRL3,\tPDMOUT1_DATA),\n\tCS42L43_PIN(10,\t\"i2c_sda\",\tDRV_CTRL3,\tI2C_SDA),\n\tCS42L43_PIN(11,\t\"i2c_scl\",\tDRV_CTRL_5,\tI2C_SCL),\n\tCS42L43_PIN(12,\t\"spi_miso\",\tDRV_CTRL3,\tSPI_MISO),\n\tCS42L43_PIN(13,\t\"spi_sck\",\tDRV_CTRL_5,\tSPI_SCK),\n\tCS42L43_PIN(14,\t\"spi_ssb\",\tDRV_CTRL_5,\tSPI_SSB),\n};\n\nstatic const unsigned int cs42l43_pin_gpio1_pins[] = { 0 };\nstatic const unsigned int cs42l43_pin_gpio2_pins[] = { 1 };\nstatic const unsigned int cs42l43_pin_gpio3_pins[] = { 2 };\nstatic const unsigned int cs42l43_pin_asp_pins[] = { 3, 4, 5 };\nstatic const unsigned int cs42l43_pin_pdmout2_pins[] = { 6, 7 };\nstatic const unsigned int cs42l43_pin_pdmout1_pins[] = { 8, 9 };\nstatic const unsigned int cs42l43_pin_i2c_pins[] = { 10, 11 };\nstatic const unsigned int cs42l43_pin_spi_pins[] = { 12, 13, 14 };\n\n#define CS42L43_PINGROUP(_name) \\\n\tPINCTRL_PINGROUP(#_name, cs42l43_pin_##_name##_pins, \\\n\t\t\t ARRAY_SIZE(cs42l43_pin_##_name##_pins))\n\nstatic const struct pingroup cs42l43_pin_groups[] = {\n\tCS42L43_PINGROUP(gpio1),\n\tCS42L43_PINGROUP(gpio2),\n\tCS42L43_PINGROUP(gpio3),\n\tCS42L43_PINGROUP(asp),\n\tCS42L43_PINGROUP(pdmout2),\n\tCS42L43_PINGROUP(pdmout1),\n\tCS42L43_PINGROUP(i2c),\n\tCS42L43_PINGROUP(spi),\n};\n\nstatic int cs42l43_pin_get_groups_count(struct pinctrl_dev *pctldev)\n{\n\treturn ARRAY_SIZE(cs42l43_pin_groups);\n}\n\nstatic const char *cs42l43_pin_get_group_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t      unsigned int group_idx)\n{\n\treturn cs42l43_pin_groups[group_idx].name;\n}\n\nstatic int cs42l43_pin_get_group_pins(struct pinctrl_dev *pctldev,\n\t\t\t\t      unsigned int group_idx,\n\t\t\t\t      const unsigned int **pins,\n\t\t\t\t      unsigned int *num_pins)\n{\n\t*pins = cs42l43_pin_groups[group_idx].pins;\n\t*num_pins = cs42l43_pin_groups[group_idx].npins;\n\n\treturn 0;\n}\n\nstatic const struct pinctrl_ops cs42l43_pin_group_ops = {\n\t.get_groups_count = cs42l43_pin_get_groups_count,\n\t.get_group_name = cs42l43_pin_get_group_name,\n\t.get_group_pins = cs42l43_pin_get_group_pins,\n#if IS_ENABLED(CONFIG_OF)\n\t.dt_node_to_map = pinconf_generic_dt_node_to_map_all,\n\t.dt_free_map = pinconf_generic_dt_free_map,\n#endif\n};\n\nenum cs42l43_pin_funcs {\n\tCS42L43_FUNC_GPIO,\n\tCS42L43_FUNC_SPDIF,\n\tCS42L43_FUNC_IRQ,\n\tCS42L43_FUNC_MIC_SHT,\n\tCS42L43_FUNC_SPK_SHT,\n\tCS42L43_FUNC_MAX\n};\n\nstatic const char * const cs42l43_pin_funcs[] = {\n\t\"gpio\", \"spdif\", \"irq\", \"mic-shutter\", \"spk-shutter\",\n};\n\nstatic const char * const cs42l43_pin_gpio_groups[] = { \"gpio1\", \"gpio3\" };\nstatic const char * const cs42l43_pin_spdif_groups[] = { \"gpio3\" };\nstatic const char * const cs42l43_pin_irq_groups[] = { \"gpio1\" };\nstatic const char * const cs42l43_pin_shutter_groups[] = { \"gpio1\", \"gpio2\", \"gpio3\" };\n\nstatic const struct pinfunction cs42l43_pin_func_groups[] = {\n\tPINCTRL_PINFUNCTION(\"gpio\", cs42l43_pin_gpio_groups,\n\t\t\t    ARRAY_SIZE(cs42l43_pin_gpio_groups)),\n\tPINCTRL_PINFUNCTION(\"spdif\", cs42l43_pin_spdif_groups,\n\t\t\t    ARRAY_SIZE(cs42l43_pin_spdif_groups)),\n\tPINCTRL_PINFUNCTION(\"irq\",  cs42l43_pin_irq_groups,\n\t\t\t    ARRAY_SIZE(cs42l43_pin_irq_groups)),\n\tPINCTRL_PINFUNCTION(\"mic-shutter\", cs42l43_pin_shutter_groups,\n\t\t\t    ARRAY_SIZE(cs42l43_pin_shutter_groups)),\n\tPINCTRL_PINFUNCTION(\"spk-shutter\", cs42l43_pin_shutter_groups,\n\t\t\t    ARRAY_SIZE(cs42l43_pin_shutter_groups)),\n};\n\nstatic_assert(ARRAY_SIZE(cs42l43_pin_funcs) == CS42L43_FUNC_MAX);\nstatic_assert(ARRAY_SIZE(cs42l43_pin_func_groups) == CS42L43_FUNC_MAX);\n\nstatic int cs42l43_pin_get_func_count(struct pinctrl_dev *pctldev)\n{\n\treturn ARRAY_SIZE(cs42l43_pin_funcs);\n}\n\nstatic const char *cs42l43_pin_get_func_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t     unsigned int func_idx)\n{\n\treturn cs42l43_pin_funcs[func_idx];\n}\n\nstatic int cs42l43_pin_get_func_groups(struct pinctrl_dev *pctldev,\n\t\t\t\t       unsigned int func_idx,\n\t\t\t\t       const char * const **groups,\n\t\t\t\t       unsigned int * const num_groups)\n{\n\t*groups = cs42l43_pin_func_groups[func_idx].groups;\n\t*num_groups = cs42l43_pin_func_groups[func_idx].ngroups;\n\n\treturn 0;\n}\n\nstatic int cs42l43_pin_set_mux(struct pinctrl_dev *pctldev,\n\t\t\t       unsigned int func_idx, unsigned int group_idx)\n{\n\tstruct cs42l43_pin *priv = pinctrl_dev_get_drvdata(pctldev);\n\tunsigned int reg, mask, val;\n\n\tdev_dbg(priv->dev, \"Setting %s to %s\\n\",\n\t\tcs42l43_pin_groups[group_idx].name, cs42l43_pin_funcs[func_idx]);\n\n\tswitch (func_idx) {\n\tcase CS42L43_FUNC_MIC_SHT:\n\t\treg = CS42L43_SHUTTER_CONTROL;\n\t\tmask = CS42L43_MIC_SHUTTER_CFG_MASK;\n\t\tval = 0x2 << (group_idx + CS42L43_MIC_SHUTTER_CFG_SHIFT);\n\t\tbreak;\n\tcase CS42L43_FUNC_SPK_SHT:\n\t\treg = CS42L43_SHUTTER_CONTROL;\n\t\tmask = CS42L43_SPK_SHUTTER_CFG_MASK;\n\t\tval = 0x2 << (group_idx + CS42L43_SPK_SHUTTER_CFG_SHIFT);\n\t\tbreak;\n\tdefault:\n\t\treg = CS42L43_GPIO_FN_SEL;\n\t\tmask = BIT(group_idx + CS42L43_GPIO1_FN_SEL_SHIFT);\n\t\tval = (func_idx == CS42L43_FUNC_GPIO) ?\n\t\t\t\t(0x1 << (group_idx + CS42L43_GPIO1_FN_SEL_SHIFT)) : 0;\n\t\tbreak;\n\t}\n\n\tif (priv->shutters_locked && reg == CS42L43_SHUTTER_CONTROL) {\n\t\tdev_err(priv->dev, \"Shutter configuration not available\\n\");\n\t\treturn -EPERM;\n\t}\n\n\treturn regmap_update_bits(priv->regmap, reg, mask, val);\n}\n\nstatic int cs42l43_gpio_set_direction(struct pinctrl_dev *pctldev,\n\t\t\t\t      struct pinctrl_gpio_range *range,\n\t\t\t\t      unsigned int offset, bool input)\n{\n\tstruct cs42l43_pin *priv = pinctrl_dev_get_drvdata(pctldev);\n\tunsigned int shift = offset + CS42L43_GPIO1_DIR_SHIFT;\n\tint ret;\n\n\tdev_dbg(priv->dev, \"Setting gpio%d to %s\\n\",\n\t\toffset + 1, input ? \"input\" : \"output\");\n\n\tret = pm_runtime_resume_and_get(priv->dev);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"Failed to resume for direction: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_update_bits(priv->regmap, CS42L43_GPIO_CTRL1,\n\t\t\t\t BIT(shift), !!input << shift);\n\tif (ret)\n\t\tdev_err(priv->dev, \"Failed to set gpio%d direction: %d\\n\",\n\t\t\toffset + 1, ret);\n\n\tpm_runtime_put(priv->dev);\n\n\treturn ret;\n}\n\nstatic int cs42l43_gpio_request_enable(struct pinctrl_dev *pctldev,\n\t\t\t\t       struct pinctrl_gpio_range *range,\n\t\t\t\t       unsigned int offset)\n{\n\treturn cs42l43_pin_set_mux(pctldev, 0, offset);\n}\n\nstatic void cs42l43_gpio_disable_free(struct pinctrl_dev *pctldev,\n\t\t\t\t      struct pinctrl_gpio_range *range,\n\t\t\t\t      unsigned int offset)\n{\n\tcs42l43_gpio_set_direction(pctldev, range, offset, true);\n}\n\nstatic const struct pinmux_ops cs42l43_pin_mux_ops = {\n\t.get_functions_count\t= cs42l43_pin_get_func_count,\n\t.get_function_name\t= cs42l43_pin_get_func_name,\n\t.get_function_groups\t= cs42l43_pin_get_func_groups,\n\n\t.set_mux\t\t= cs42l43_pin_set_mux,\n\n\t.gpio_request_enable\t= cs42l43_gpio_request_enable,\n\t.gpio_disable_free\t= cs42l43_gpio_disable_free,\n\t.gpio_set_direction\t= cs42l43_gpio_set_direction,\n\n\t.strict\t\t\t= true,\n};\n\nstatic const unsigned int cs42l43_pin_drv_str_ma[] = { 1, 2, 4, 8, 9, 10, 12, 16 };\n\nstatic inline int cs42l43_pin_get_drv_str(struct cs42l43_pin *priv, unsigned int pin)\n{\n\tconst struct cs42l43_pin_data *pdat = cs42l43_pin_pins[pin].drv_data;\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read(priv->regmap, pdat->reg, &val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn cs42l43_pin_drv_str_ma[(val & pdat->mask) >> pdat->shift];\n}\n\nstatic inline int cs42l43_pin_set_drv_str(struct cs42l43_pin *priv, unsigned int pin,\n\t\t\t\t\t  unsigned int ma)\n{\n\tconst struct cs42l43_pin_data *pdat = cs42l43_pin_pins[pin].drv_data;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(cs42l43_pin_drv_str_ma); i++) {\n\t\tif (ma == cs42l43_pin_drv_str_ma[i]) {\n\t\t\tif ((i << pdat->shift) > pdat->mask)\n\t\t\t\tgoto err;\n\n\t\t\tdev_dbg(priv->dev, \"Set drive strength for %s to %d mA\\n\",\n\t\t\t\tcs42l43_pin_pins[pin].name, ma);\n\n\t\t\treturn regmap_update_bits(priv->regmap, pdat->reg,\n\t\t\t\t\t\t  pdat->mask, i << pdat->shift);\n\t\t}\n\t}\n\nerr:\n\tdev_err(priv->dev, \"Invalid drive strength for %s: %d mA\\n\",\n\t\tcs42l43_pin_pins[pin].name, ma);\n\treturn -EINVAL;\n}\n\nstatic inline int cs42l43_pin_get_db(struct cs42l43_pin *priv, unsigned int pin)\n{\n\tunsigned int val;\n\tint ret;\n\n\tif (pin >= CS42L43_NUM_GPIOS)\n\t\treturn -ENOTSUPP;\n\n\tret = regmap_read(priv->regmap, CS42L43_GPIO_CTRL2, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val & (CS42L43_GPIO1_DEGLITCH_BYP_MASK << pin))\n\t\treturn 0;\n\n\treturn 85; \n}\n\nstatic inline int cs42l43_pin_set_db(struct cs42l43_pin *priv, unsigned int pin,\n\t\t\t\t     unsigned int us)\n{\n\tif (pin >= CS42L43_NUM_GPIOS)\n\t\treturn -ENOTSUPP;\n\n\tdev_dbg(priv->dev, \"Set debounce %s for %s\\n\",\n\t\tstr_on_off(us), cs42l43_pin_pins[pin].name);\n\n\treturn regmap_update_bits(priv->regmap, CS42L43_GPIO_CTRL2,\n\t\t\t\t  CS42L43_GPIO1_DEGLITCH_BYP_MASK << pin,\n\t\t\t\t  !!us << pin);\n}\n\nstatic int cs42l43_pin_config_get(struct pinctrl_dev *pctldev,\n\t\t\t\t  unsigned int pin, unsigned long *config)\n{\n\tstruct cs42l43_pin *priv = pinctrl_dev_get_drvdata(pctldev);\n\tunsigned int param = pinconf_to_config_param(*config);\n\tint ret;\n\n\tswitch (param) {\n\tcase PIN_CONFIG_DRIVE_STRENGTH:\n\t\tret = cs42l43_pin_get_drv_str(priv, pin);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase PIN_CONFIG_INPUT_DEBOUNCE:\n\t\tret = cs42l43_pin_get_db(priv, pin);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\t*config = pinconf_to_config_packed(param, ret);\n\n\treturn 0;\n}\n\nstatic int cs42l43_pin_config_set(struct pinctrl_dev *pctldev, unsigned int pin,\n\t\t\t\t  unsigned long *configs, unsigned int num_configs)\n{\n\tstruct cs42l43_pin *priv = pinctrl_dev_get_drvdata(pctldev);\n\tunsigned int val;\n\tint ret;\n\n\twhile (num_configs) {\n\t\tval = pinconf_to_config_argument(*configs);\n\n\t\tswitch (pinconf_to_config_param(*configs)) {\n\t\tcase PIN_CONFIG_DRIVE_STRENGTH:\n\t\t\tret = cs42l43_pin_set_drv_str(priv, pin, val);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_INPUT_DEBOUNCE:\n\t\t\tret = cs42l43_pin_set_db(priv, pin, val);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\n\t\tconfigs++;\n\t\tnum_configs--;\n\t}\n\n\treturn 0;\n}\n\nstatic int cs42l43_pin_config_group_get(struct pinctrl_dev *pctldev,\n\t\t\t\t\tunsigned int selector, unsigned long *config)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < cs42l43_pin_groups[selector].npins; ++i) {\n\t\tret = cs42l43_pin_config_get(pctldev,\n\t\t\t\t\t     cs42l43_pin_groups[selector].pins[i],\n\t\t\t\t\t     config);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int cs42l43_pin_config_group_set(struct pinctrl_dev *pctldev,\n\t\t\t\t\tunsigned int selector,\n\t\t\t\t\tunsigned long *configs,\n\t\t\t\t\tunsigned int num_configs)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < cs42l43_pin_groups[selector].npins; ++i) {\n\t\tret = cs42l43_pin_config_set(pctldev,\n\t\t\t\t\t     cs42l43_pin_groups[selector].pins[i],\n\t\t\t\t\t     configs, num_configs);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct pinconf_ops cs42l43_pin_conf_ops = {\n\t.is_generic\t\t= true,\n\n\t.pin_config_get\t\t= cs42l43_pin_config_get,\n\t.pin_config_set\t\t= cs42l43_pin_config_set,\n\t.pin_config_group_get\t= cs42l43_pin_config_group_get,\n\t.pin_config_group_set\t= cs42l43_pin_config_group_set,\n};\n\nstatic struct pinctrl_desc cs42l43_pin_desc = {\n\t.name\t\t= \"cs42l43-pinctrl\",\n\t.owner\t\t= THIS_MODULE,\n\n\t.pins\t\t= cs42l43_pin_pins,\n\t.npins\t\t= ARRAY_SIZE(cs42l43_pin_pins),\n\n\t.pctlops\t= &cs42l43_pin_group_ops,\n\t.pmxops\t\t= &cs42l43_pin_mux_ops,\n\t.confops\t= &cs42l43_pin_conf_ops,\n};\n\nstatic int cs42l43_gpio_get(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct cs42l43_pin *priv = gpiochip_get_data(chip);\n\tunsigned int val;\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(priv->dev);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"Failed to resume for get: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_read(priv->regmap, CS42L43_GPIO_STS, &val);\n\tif (ret)\n\t\tdev_err(priv->dev, \"Failed to get gpio%d: %d\\n\", offset + 1, ret);\n\telse\n\t\tret = !!(val & BIT(offset + CS42L43_GPIO1_STS_SHIFT));\n\n\tpm_runtime_put(priv->dev);\n\n\treturn ret;\n}\n\nstatic void cs42l43_gpio_set(struct gpio_chip *chip, unsigned int offset, int value)\n{\n\tstruct cs42l43_pin *priv = gpiochip_get_data(chip);\n\tunsigned int shift = offset + CS42L43_GPIO1_LVL_SHIFT;\n\tint ret;\n\n\tdev_dbg(priv->dev, \"Setting gpio%d to %s\\n\",\n\t\toffset + 1, value ? \"high\" : \"low\");\n\n\tret = pm_runtime_resume_and_get(priv->dev);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"Failed to resume for set: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tret = regmap_update_bits(priv->regmap, CS42L43_GPIO_CTRL1,\n\t\t\t\t BIT(shift), value << shift);\n\tif (ret)\n\t\tdev_err(priv->dev, \"Failed to set gpio%d: %d\\n\", offset + 1, ret);\n\n\tpm_runtime_put(priv->dev);\n}\n\nstatic int cs42l43_gpio_direction_in(struct gpio_chip *chip, unsigned int offset)\n{\n\treturn pinctrl_gpio_direction_input(chip->base + offset);\n}\n\nstatic int cs42l43_gpio_direction_out(struct gpio_chip *chip,\n\t\t\t\t      unsigned int offset, int value)\n{\n\tcs42l43_gpio_set(chip, offset, value);\n\n\treturn pinctrl_gpio_direction_output(chip->base + offset);\n}\n\nstatic int cs42l43_gpio_add_pin_ranges(struct gpio_chip *chip)\n{\n\tstruct cs42l43_pin *priv = gpiochip_get_data(chip);\n\tint ret;\n\n\tret = gpiochip_add_pin_range(&priv->gpio_chip, priv->gpio_chip.label,\n\t\t\t\t     0, 0, CS42L43_NUM_GPIOS);\n\tif (ret)\n\t\tdev_err(priv->dev, \"Failed to add GPIO pin range: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int cs42l43_pin_probe(struct platform_device *pdev)\n{\n\tstruct cs42l43 *cs42l43 = dev_get_drvdata(pdev->dev.parent);\n\tstruct cs42l43_pin *priv;\n\tstruct pinctrl_dev *pctldev;\n\tstruct fwnode_handle *fwnode = dev_fwnode(cs42l43->dev);\n\tint ret;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->dev = &pdev->dev;\n\tpriv->regmap = cs42l43->regmap;\n\n\tpriv->shutters_locked = cs42l43->hw_lock;\n\n\tpriv->gpio_chip.request = gpiochip_generic_request;\n\tpriv->gpio_chip.free = gpiochip_generic_free;\n\tpriv->gpio_chip.direction_input = cs42l43_gpio_direction_in;\n\tpriv->gpio_chip.direction_output = cs42l43_gpio_direction_out;\n\tpriv->gpio_chip.add_pin_ranges = cs42l43_gpio_add_pin_ranges;\n\tpriv->gpio_chip.get = cs42l43_gpio_get;\n\tpriv->gpio_chip.set = cs42l43_gpio_set;\n\tpriv->gpio_chip.label = dev_name(priv->dev);\n\tpriv->gpio_chip.parent = priv->dev;\n\tpriv->gpio_chip.can_sleep = true;\n\tpriv->gpio_chip.base = -1;\n\tpriv->gpio_chip.ngpio = CS42L43_NUM_GPIOS;\n\n\tif (is_of_node(fwnode)) {\n\t\tfwnode = fwnode_get_named_child_node(fwnode, \"pinctrl\");\n\n\t\tif (fwnode && !fwnode->dev)\n\t\t\tfwnode->dev = priv->dev;\n\t}\n\n\tpriv->gpio_chip.fwnode = fwnode;\n\n\tdevice_set_node(priv->dev, fwnode);\n\n\tdevm_pm_runtime_enable(priv->dev);\n\tpm_runtime_idle(priv->dev);\n\n\tpctldev = devm_pinctrl_register(priv->dev, &cs42l43_pin_desc, priv);\n\tif (IS_ERR(pctldev))\n\t\treturn dev_err_probe(priv->dev, PTR_ERR(pctldev),\n\t\t\t\t     \"Failed to register pinctrl\\n\");\n\n\tret = devm_gpiochip_add_data(priv->dev, &priv->gpio_chip, priv);\n\tif (ret)\n\t\treturn dev_err_probe(priv->dev, ret,\n\t\t\t\t     \"Failed to register gpiochip\\n\");\n\n\treturn 0;\n}\n\nstatic const struct platform_device_id cs42l43_pin_id_table[] = {\n\t{ \"cs42l43-pinctrl\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(platform, cs42l43_pin_id_table);\n\nstatic struct platform_driver cs42l43_pin_driver = {\n\t.driver = {\n\t\t.name\t= \"cs42l43-pinctrl\",\n\t},\n\t.probe\t\t= cs42l43_pin_probe,\n\t.id_table\t= cs42l43_pin_id_table,\n};\nmodule_platform_driver(cs42l43_pin_driver);\n\nMODULE_DESCRIPTION(\"CS42L43 Pinctrl Driver\");\nMODULE_AUTHOR(\"Charles Keepax <ckeepax@opensource.cirrus.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}