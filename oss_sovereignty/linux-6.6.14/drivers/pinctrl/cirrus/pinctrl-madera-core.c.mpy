{
  "module_name": "pinctrl-madera-core.c",
  "hash_id": "9ad68ba939a1a601c20d3d0a69d6a8215cb43db9b754c21c64248ca2fc953904",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/cirrus/pinctrl-madera-core.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n\n#include <linux/pinctrl/machine.h>\n#include <linux/pinctrl/pinconf-generic.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinmux.h>\n\n#include <linux/mfd/madera/core.h>\n#include <linux/mfd/madera/registers.h>\n\n#include \"../pinctrl-utils.h\"\n\n#include \"pinctrl-madera.h\"\n\n \nstatic const struct pinctrl_pin_desc madera_pins[] = {\n\tPINCTRL_PIN(0, \"gpio1\"),\n\tPINCTRL_PIN(1, \"gpio2\"),\n\tPINCTRL_PIN(2, \"gpio3\"),\n\tPINCTRL_PIN(3, \"gpio4\"),\n\tPINCTRL_PIN(4, \"gpio5\"),\n\tPINCTRL_PIN(5, \"gpio6\"),\n\tPINCTRL_PIN(6, \"gpio7\"),\n\tPINCTRL_PIN(7, \"gpio8\"),\n\tPINCTRL_PIN(8, \"gpio9\"),\n\tPINCTRL_PIN(9, \"gpio10\"),\n\tPINCTRL_PIN(10, \"gpio11\"),\n\tPINCTRL_PIN(11, \"gpio12\"),\n\tPINCTRL_PIN(12, \"gpio13\"),\n\tPINCTRL_PIN(13, \"gpio14\"),\n\tPINCTRL_PIN(14, \"gpio15\"),\n\tPINCTRL_PIN(15, \"gpio16\"),\n\tPINCTRL_PIN(16, \"gpio17\"),\n\tPINCTRL_PIN(17, \"gpio18\"),\n\tPINCTRL_PIN(18, \"gpio19\"),\n\tPINCTRL_PIN(19, \"gpio20\"),\n\tPINCTRL_PIN(20, \"gpio21\"),\n\tPINCTRL_PIN(21, \"gpio22\"),\n\tPINCTRL_PIN(22, \"gpio23\"),\n\tPINCTRL_PIN(23, \"gpio24\"),\n\tPINCTRL_PIN(24, \"gpio25\"),\n\tPINCTRL_PIN(25, \"gpio26\"),\n\tPINCTRL_PIN(26, \"gpio27\"),\n\tPINCTRL_PIN(27, \"gpio28\"),\n\tPINCTRL_PIN(28, \"gpio29\"),\n\tPINCTRL_PIN(29, \"gpio30\"),\n\tPINCTRL_PIN(30, \"gpio31\"),\n\tPINCTRL_PIN(31, \"gpio32\"),\n\tPINCTRL_PIN(32, \"gpio33\"),\n\tPINCTRL_PIN(33, \"gpio34\"),\n\tPINCTRL_PIN(34, \"gpio35\"),\n\tPINCTRL_PIN(35, \"gpio36\"),\n\tPINCTRL_PIN(36, \"gpio37\"),\n\tPINCTRL_PIN(37, \"gpio38\"),\n\tPINCTRL_PIN(38, \"gpio39\"),\n\tPINCTRL_PIN(39, \"gpio40\"),\n};\n\n \nstatic const char * const madera_pin_single_group_names[] = {\n\t\"gpio1\",  \"gpio2\",  \"gpio3\",  \"gpio4\",  \"gpio5\",  \"gpio6\",  \"gpio7\",\n\t\"gpio8\",  \"gpio9\",  \"gpio10\", \"gpio11\", \"gpio12\", \"gpio13\", \"gpio14\",\n\t\"gpio15\", \"gpio16\", \"gpio17\", \"gpio18\", \"gpio19\", \"gpio20\", \"gpio21\",\n\t\"gpio22\", \"gpio23\", \"gpio24\", \"gpio25\", \"gpio26\", \"gpio27\", \"gpio28\",\n\t\"gpio29\", \"gpio30\", \"gpio31\", \"gpio32\", \"gpio33\", \"gpio34\", \"gpio35\",\n\t\"gpio36\", \"gpio37\", \"gpio38\", \"gpio39\", \"gpio40\",\n};\n\n \nstatic const unsigned int madera_pin_single_group_pins[] = {\n\t  0,  1,  2,  3,  4,  5,  6,\n\t  7,  8,  9, 10, 11, 12, 13,\n\t 14, 15, 16, 17, 18, 19, 20,\n\t 21, 22, 23, 24, 25, 26, 27,\n\t 28, 29, 30, 31, 32, 33, 34,\n\t 35, 36, 37, 38, 39,\n};\n\nstatic const char * const madera_aif1_group_names[] = { \"aif1\" };\nstatic const char * const madera_aif2_group_names[] = { \"aif2\" };\nstatic const char * const madera_aif3_group_names[] = { \"aif3\" };\nstatic const char * const madera_aif4_group_names[] = { \"aif4\" };\nstatic const char * const madera_mif1_group_names[] = { \"mif1\" };\nstatic const char * const madera_mif2_group_names[] = { \"mif2\" };\nstatic const char * const madera_mif3_group_names[] = { \"mif3\" };\nstatic const char * const madera_dmic3_group_names[] = { \"dmic3\" };\nstatic const char * const madera_dmic4_group_names[] = { \"dmic4\" };\nstatic const char * const madera_dmic5_group_names[] = { \"dmic5\" };\nstatic const char * const madera_dmic6_group_names[] = { \"dmic6\" };\nstatic const char * const madera_spk1_group_names[] = { \"pdmspk1\" };\nstatic const char * const madera_spk2_group_names[] = { \"pdmspk2\" };\n\n \nstatic const struct {\n\tconst char *name;\n\tconst char * const *group_names;\n\tu32 func;\n} madera_mux_funcs[] = {\n\t{\n\t\t.name = \"aif1\",\n\t\t.group_names = madera_aif1_group_names,\n\t\t.func = 0x000\n\t},\n\t{\n\t\t.name = \"aif2\",\n\t\t.group_names = madera_aif2_group_names,\n\t\t.func = 0x000\n\t},\n\t{\n\t\t.name = \"aif3\",\n\t\t.group_names = madera_aif3_group_names,\n\t\t.func = 0x000\n\t},\n\t{\n\t\t.name = \"aif4\",\n\t\t.group_names = madera_aif4_group_names,\n\t\t.func = 0x000\n\t},\n\t{\n\t\t.name = \"mif1\",\n\t\t.group_names = madera_mif1_group_names,\n\t\t.func = 0x000\n\t},\n\t{\n\t\t.name = \"mif2\",\n\t\t.group_names = madera_mif2_group_names,\n\t\t.func = 0x000\n\t},\n\t{\n\t\t.name = \"mif3\",\n\t\t.group_names = madera_mif3_group_names,\n\t\t.func = 0x000\n\t},\n\t{\n\t\t.name = \"dmic3\",\n\t\t.group_names = madera_dmic3_group_names,\n\t\t.func = 0x000\n\t},\n\t{\n\t\t.name = \"dmic4\",\n\t\t.group_names = madera_dmic4_group_names,\n\t\t.func = 0x000\n\t},\n\t{\n\t\t.name = \"dmic5\",\n\t\t.group_names = madera_dmic5_group_names,\n\t\t.func = 0x000\n\t},\n\t{\n\t\t.name = \"dmic6\",\n\t\t.group_names = madera_dmic6_group_names,\n\t\t.func = 0x000\n\t},\n\t{\n\t\t.name = \"pdmspk1\",\n\t\t.group_names = madera_spk1_group_names,\n\t\t.func = 0x000\n\t},\n\t{\n\t\t.name = \"pdmspk2\",\n\t\t.group_names = madera_spk2_group_names,\n\t\t.func = 0x000\n\t},\n\t{\n\t\t.name = \"io\",\n\t\t.group_names = madera_pin_single_group_names,\n\t\t.func = 0x001\n\t},\n\t{\n\t\t.name = \"dsp-gpio\",\n\t\t.group_names = madera_pin_single_group_names,\n\t\t.func = 0x002\n\t},\n\t{\n\t\t.name = \"irq1\",\n\t\t.group_names = madera_pin_single_group_names,\n\t\t.func = 0x003\n\t},\n\t{\n\t\t.name = \"irq2\",\n\t\t.group_names = madera_pin_single_group_names,\n\t\t.func = 0x004\n\t},\n\t{\n\t\t.name = \"fll1-clk\",\n\t\t.group_names = madera_pin_single_group_names,\n\t\t.func = 0x010\n\t},\n\t{\n\t\t.name = \"fll2-clk\",\n\t\t.group_names = madera_pin_single_group_names,\n\t\t.func = 0x011\n\t},\n\t{\n\t\t.name = \"fll3-clk\",\n\t\t.group_names = madera_pin_single_group_names,\n\t\t.func = 0x012\n\t},\n\t{\n\t\t.name = \"fllao-clk\",\n\t\t.group_names = madera_pin_single_group_names,\n\t\t.func = 0x013\n\t},\n\t{\n\t\t.name = \"fll1-lock\",\n\t\t.group_names = madera_pin_single_group_names,\n\t\t.func = 0x018\n\t},\n\t{\n\t\t.name = \"fll2-lock\",\n\t\t.group_names = madera_pin_single_group_names,\n\t\t.func = 0x019\n\t},\n\t{\n\t\t.name = \"fll3-lock\",\n\t\t.group_names = madera_pin_single_group_names,\n\t\t.func = 0x01a\n\t},\n\t{\n\t\t.name = \"fllao-lock\",\n\t\t.group_names = madera_pin_single_group_names,\n\t\t.func = 0x01b\n\t},\n\t{\n\t\t.name = \"opclk\",\n\t\t.group_names = madera_pin_single_group_names,\n\t\t.func = 0x040\n\t},\n\t{\n\t\t.name = \"opclk-async\",\n\t\t.group_names = madera_pin_single_group_names,\n\t\t.func = 0x041\n\t},\n\t{\n\t\t.name = \"pwm1\",\n\t\t.group_names = madera_pin_single_group_names,\n\t\t.func = 0x048\n\t},\n\t{\n\t\t.name = \"pwm2\",\n\t\t.group_names = madera_pin_single_group_names,\n\t\t.func = 0x049\n\t},\n\t{\n\t\t.name = \"spdif\",\n\t\t.group_names = madera_pin_single_group_names,\n\t\t.func = 0x04c\n\t},\n\t{\n\t\t.name = \"asrc1-in1-lock\",\n\t\t.group_names = madera_pin_single_group_names,\n\t\t.func = 0x088\n\t},\n\t{\n\t\t.name = \"asrc1-in2-lock\",\n\t\t.group_names = madera_pin_single_group_names,\n\t\t.func = 0x089\n\t},\n\t{\n\t\t.name = \"asrc2-in1-lock\",\n\t\t.group_names = madera_pin_single_group_names,\n\t\t.func = 0x08a\n\t},\n\t{\n\t\t.name = \"asrc2-in2-lock\",\n\t\t.group_names = madera_pin_single_group_names,\n\t\t.func = 0x08b\n\t},\n\t{\n\t\t.name = \"spkl-short-circuit\",\n\t\t.group_names = madera_pin_single_group_names,\n\t\t.func = 0x0b6\n\t},\n\t{\n\t\t.name = \"spkr-short-circuit\",\n\t\t.group_names = madera_pin_single_group_names,\n\t\t.func = 0x0b7\n\t},\n\t{\n\t\t.name = \"spk-shutdown\",\n\t\t.group_names = madera_pin_single_group_names,\n\t\t.func = 0x0e0\n\t},\n\t{\n\t\t.name = \"spk-overheat-shutdown\",\n\t\t.group_names = madera_pin_single_group_names,\n\t\t.func = 0x0e1\n\t},\n\t{\n\t\t.name = \"spk-overheat-warn\",\n\t\t.group_names = madera_pin_single_group_names,\n\t\t.func = 0x0e2\n\t},\n\t{\n\t\t.name = \"timer1-sts\",\n\t\t.group_names = madera_pin_single_group_names,\n\t\t.func = 0x140\n\t},\n\t{\n\t\t.name = \"timer2-sts\",\n\t\t.group_names = madera_pin_single_group_names,\n\t\t.func = 0x141\n\t},\n\t{\n\t\t.name = \"timer3-sts\",\n\t\t.group_names = madera_pin_single_group_names,\n\t\t.func = 0x142\n\t},\n\t{\n\t\t.name = \"timer4-sts\",\n\t\t.group_names = madera_pin_single_group_names,\n\t\t.func = 0x143\n\t},\n\t{\n\t\t.name = \"timer5-sts\",\n\t\t.group_names = madera_pin_single_group_names,\n\t\t.func = 0x144\n\t},\n\t{\n\t\t.name = \"timer6-sts\",\n\t\t.group_names = madera_pin_single_group_names,\n\t\t.func = 0x145\n\t},\n\t{\n\t\t.name = \"timer7-sts\",\n\t\t.group_names = madera_pin_single_group_names,\n\t\t.func = 0x146\n\t},\n\t{\n\t\t.name = \"timer8-sts\",\n\t\t.group_names = madera_pin_single_group_names,\n\t\t.func = 0x147\n\t},\n\t{\n\t\t.name = \"log1-fifo-ne\",\n\t\t.group_names = madera_pin_single_group_names,\n\t\t.func = 0x150\n\t},\n\t{\n\t\t.name = \"log2-fifo-ne\",\n\t\t.group_names = madera_pin_single_group_names,\n\t\t.func = 0x151\n\t},\n\t{\n\t\t.name = \"log3-fifo-ne\",\n\t\t.group_names = madera_pin_single_group_names,\n\t\t.func = 0x152\n\t},\n\t{\n\t\t.name = \"log4-fifo-ne\",\n\t\t.group_names = madera_pin_single_group_names,\n\t\t.func = 0x153\n\t},\n\t{\n\t\t.name = \"log5-fifo-ne\",\n\t\t.group_names = madera_pin_single_group_names,\n\t\t.func = 0x154\n\t},\n\t{\n\t\t.name = \"log6-fifo-ne\",\n\t\t.group_names = madera_pin_single_group_names,\n\t\t.func = 0x155\n\t},\n\t{\n\t\t.name = \"log7-fifo-ne\",\n\t\t.group_names = madera_pin_single_group_names,\n\t\t.func = 0x156\n\t},\n\t{\n\t\t.name = \"log8-fifo-ne\",\n\t\t.group_names = madera_pin_single_group_names,\n\t\t.func = 0x157\n\t},\n\t{\n\t\t.name = \"aux-pdm-clk\",\n\t\t.group_names = madera_pin_single_group_names,\n\t\t.func = 0x280\n\t},\n\t{\n\t\t.name = \"aux-pdm-dat\",\n\t\t.group_names = madera_pin_single_group_names,\n\t\t.func = 0x281\n\t},\n};\n\nstatic u16 madera_pin_make_drv_str(struct madera_pin_private *priv,\n\t\t\t\t      unsigned int milliamps)\n{\n\tswitch (milliamps) {\n\tcase 4:\n\t\treturn 0;\n\tcase 8:\n\t\treturn 2 << MADERA_GP1_DRV_STR_SHIFT;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tdev_warn(priv->dev, \"%u mA not a valid drive strength\", milliamps);\n\n\treturn 0;\n}\n\nstatic unsigned int madera_pin_unmake_drv_str(struct madera_pin_private *priv,\n\t\t\t\t\t      u16 regval)\n{\n\tregval = (regval & MADERA_GP1_DRV_STR_MASK) >> MADERA_GP1_DRV_STR_SHIFT;\n\n\tswitch (regval) {\n\tcase 0:\n\t\treturn 4;\n\tcase 2:\n\t\treturn 8;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int madera_get_groups_count(struct pinctrl_dev *pctldev)\n{\n\tstruct madera_pin_private *priv = pinctrl_dev_get_drvdata(pctldev);\n\n\t \n\treturn priv->chip->n_pin_groups + priv->chip->n_pins;\n}\n\nstatic const char *madera_get_group_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t unsigned int selector)\n{\n\tstruct madera_pin_private *priv = pinctrl_dev_get_drvdata(pctldev);\n\n\tif (selector < priv->chip->n_pin_groups)\n\t\treturn priv->chip->pin_groups[selector].name;\n\n\tselector -= priv->chip->n_pin_groups;\n\treturn madera_pin_single_group_names[selector];\n}\n\nstatic int madera_get_group_pins(struct pinctrl_dev *pctldev,\n\t\t\t\t unsigned int selector,\n\t\t\t\t const unsigned int **pins,\n\t\t\t\t unsigned int *num_pins)\n{\n\tstruct madera_pin_private *priv = pinctrl_dev_get_drvdata(pctldev);\n\n\tif (selector < priv->chip->n_pin_groups) {\n\t\t*pins = priv->chip->pin_groups[selector].pins;\n\t\t*num_pins = priv->chip->pin_groups[selector].n_pins;\n\t} else {\n\t\t \n\t\tselector -= priv->chip->n_pin_groups;\n\t\t*pins = &madera_pin_single_group_pins[selector];\n\t\t*num_pins = 1;\n\t}\n\treturn 0;\n}\n\nstatic void madera_pin_dbg_show_fn(struct madera_pin_private *priv,\n\t\t\t\t   struct seq_file *s,\n\t\t\t\t   unsigned int pin, unsigned int fn)\n{\n\tconst struct madera_pin_chip *chip = priv->chip;\n\tint i, g_pin;\n\n\tif (fn != 0) {\n\t\tfor (i = 0; i < ARRAY_SIZE(madera_mux_funcs); ++i) {\n\t\t\tif (madera_mux_funcs[i].func == fn) {\n\t\t\t\tseq_printf(s, \" FN=%s\",\n\t\t\t\t\t   madera_mux_funcs[i].name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\treturn;\t \n\t}\n\n\t \n\tfor (i = 0; i < chip->n_pin_groups; ++i) {\n\t\tfor (g_pin = 0; g_pin < chip->pin_groups[i].n_pins; ++g_pin) {\n\t\t\tif (chip->pin_groups[i].pins[g_pin] == pin) {\n\t\t\t\tseq_printf(s, \" FN=%s\",\n\t\t\t\t\t   chip->pin_groups[i].name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void __maybe_unused madera_pin_dbg_show(struct pinctrl_dev *pctldev,\n\t\t\t\t\t       struct seq_file *s,\n\t\t\t\t\t       unsigned int pin)\n{\n\tstruct madera_pin_private *priv = pinctrl_dev_get_drvdata(pctldev);\n\tunsigned int conf[2];\n\tunsigned int reg = MADERA_GPIO1_CTRL_1 + (2 * pin);\n\tunsigned int fn;\n\tint ret;\n\n\tret = regmap_read(priv->madera->regmap, reg, &conf[0]);\n\tif (ret)\n\t\treturn;\n\n\tret = regmap_read(priv->madera->regmap, reg + 1, &conf[1]);\n\tif (ret)\n\t\treturn;\n\n\tseq_printf(s, \"%04x:%04x\", conf[0], conf[1]);\n\n\tfn = (conf[0] & MADERA_GP1_FN_MASK) >> MADERA_GP1_FN_SHIFT;\n\tmadera_pin_dbg_show_fn(priv, s, pin, fn);\n\n\t \n\tif (fn == 1) {\n\t\tif (conf[1] & MADERA_GP1_DIR_MASK)\n\t\t\tseq_puts(s, \" IN\");\n\t\telse\n\t\t\tseq_puts(s, \" OUT\");\n\t}\n\n\tif (conf[1] & MADERA_GP1_PU_MASK)\n\t\tseq_puts(s, \" PU\");\n\n\tif (conf[1] & MADERA_GP1_PD_MASK)\n\t\tseq_puts(s, \" PD\");\n\n\tif (conf[0] & MADERA_GP1_DB_MASK)\n\t\tseq_puts(s, \" DB\");\n\n\tif (conf[0] & MADERA_GP1_OP_CFG_MASK)\n\t\tseq_puts(s, \" OD\");\n\telse\n\t\tseq_puts(s, \" CMOS\");\n\n\tseq_printf(s, \" DRV=%umA\", madera_pin_unmake_drv_str(priv, conf[1]));\n\n\tif (conf[0] & MADERA_GP1_IP_CFG_MASK)\n\t\tseq_puts(s, \" SCHMITT\");\n}\n\nstatic const struct pinctrl_ops madera_pin_group_ops = {\n\t.get_groups_count = madera_get_groups_count,\n\t.get_group_name = madera_get_group_name,\n\t.get_group_pins = madera_get_group_pins,\n#if IS_ENABLED(CONFIG_OF)\n\t.dt_node_to_map = pinconf_generic_dt_node_to_map_all,\n\t.dt_free_map = pinctrl_utils_free_map,\n#endif\n#if IS_ENABLED(CONFIG_DEBUG_FS)\n\t.pin_dbg_show = madera_pin_dbg_show,\n#endif\n};\n\nstatic int madera_mux_get_funcs_count(struct pinctrl_dev *pctldev)\n{\n\treturn ARRAY_SIZE(madera_mux_funcs);\n}\n\nstatic const char *madera_mux_get_func_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t    unsigned int selector)\n{\n\treturn madera_mux_funcs[selector].name;\n}\n\nstatic int madera_mux_get_groups(struct pinctrl_dev *pctldev,\n\t\t\t\t unsigned int selector,\n\t\t\t\t const char * const **groups,\n\t\t\t\t unsigned int * const num_groups)\n{\n\tstruct madera_pin_private *priv = pinctrl_dev_get_drvdata(pctldev);\n\n\t*groups = madera_mux_funcs[selector].group_names;\n\n\tif (madera_mux_funcs[selector].func == 0) {\n\t\t \n\t\t*num_groups = 1;\n\t} else {\n\t\t \n\t\t*num_groups = priv->chip->n_pins;\n\t}\n\n\treturn 0;\n}\n\nstatic int madera_mux_set_mux(struct pinctrl_dev *pctldev,\n\t\t\t      unsigned int selector,\n\t\t\t      unsigned int group)\n{\n\tstruct madera_pin_private *priv = pinctrl_dev_get_drvdata(pctldev);\n\tstruct madera *madera = priv->madera;\n\tconst struct madera_pin_groups *pin_group = priv->chip->pin_groups;\n\tunsigned int n_chip_groups = priv->chip->n_pin_groups;\n\tconst char *func_name = madera_mux_funcs[selector].name;\n\tunsigned int reg;\n\tint i, ret = 0;\n\n\tdev_dbg(priv->dev, \"%s selecting %u (%s) for group %u (%s)\\n\",\n\t\t__func__, selector, func_name, group,\n\t\tmadera_get_group_name(pctldev, group));\n\n\tif (madera_mux_funcs[selector].func == 0) {\n\t\t \n\t\tfor (i = 0; i < n_chip_groups; ++i) {\n\t\t\tif (strcmp(func_name, pin_group->name) == 0)\n\t\t\t\tbreak;\n\n\t\t\t++pin_group;\n\t\t}\n\n\t\tif (i == n_chip_groups)\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < pin_group->n_pins; ++i) {\n\t\t\treg = MADERA_GPIO1_CTRL_1 + (2 * pin_group->pins[i]);\n\n\t\t\tdev_dbg(priv->dev, \"%s setting 0x%x func bits to 0\\n\",\n\t\t\t\t__func__, reg);\n\n\t\t\tret = regmap_update_bits(madera->regmap, reg,\n\t\t\t\t\t\t MADERA_GP1_FN_MASK, 0);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t}\n\t} else {\n\t\t \n\t\tgroup -= n_chip_groups;\n\t\treg = MADERA_GPIO1_CTRL_1 + (2 * group);\n\n\t\tdev_dbg(priv->dev, \"%s setting 0x%x func bits to 0x%x\\n\",\n\t\t\t__func__, reg, madera_mux_funcs[selector].func);\n\n\t\tret = regmap_update_bits(madera->regmap,\n\t\t\t\t\t reg,\n\t\t\t\t\t MADERA_GP1_FN_MASK,\n\t\t\t\t\t madera_mux_funcs[selector].func);\n\t}\n\n\tif (ret)\n\t\tdev_err(priv->dev, \"Failed to write to 0x%x (%d)\\n\", reg, ret);\n\n\treturn ret;\n}\n\nstatic int madera_gpio_set_direction(struct pinctrl_dev *pctldev,\n\t\t\t\t     struct pinctrl_gpio_range *range,\n\t\t\t\t     unsigned int offset,\n\t\t\t\t     bool input)\n{\n\tstruct madera_pin_private *priv = pinctrl_dev_get_drvdata(pctldev);\n\tstruct madera *madera = priv->madera;\n\tunsigned int reg = MADERA_GPIO1_CTRL_2 + (2 * offset);\n\tunsigned int val;\n\tint ret;\n\n\tif (input)\n\t\tval = MADERA_GP1_DIR;\n\telse\n\t\tval = 0;\n\n\tret = regmap_update_bits(madera->regmap, reg, MADERA_GP1_DIR_MASK, val);\n\tif (ret)\n\t\tdev_err(priv->dev, \"Failed to write to 0x%x (%d)\\n\", reg, ret);\n\n\treturn ret;\n}\n\nstatic int madera_gpio_request_enable(struct pinctrl_dev *pctldev,\n\t\t\t\t      struct pinctrl_gpio_range *range,\n\t\t\t\t      unsigned int offset)\n{\n\tstruct madera_pin_private *priv = pinctrl_dev_get_drvdata(pctldev);\n\tstruct madera *madera = priv->madera;\n\tunsigned int reg = MADERA_GPIO1_CTRL_1 + (2 * offset);\n\tint ret;\n\n\t \n\tret = regmap_update_bits(madera->regmap, reg, MADERA_GP1_FN_MASK, 1);\n\tif (ret)\n\t\tdev_err(priv->dev, \"Failed to write to 0x%x (%d)\\n\", reg, ret);\n\n\treturn ret;\n}\n\nstatic void madera_gpio_disable_free(struct pinctrl_dev *pctldev,\n\t\t\t\t     struct pinctrl_gpio_range *range,\n\t\t\t\t     unsigned int offset)\n{\n\tstruct madera_pin_private *priv = pinctrl_dev_get_drvdata(pctldev);\n\tstruct madera *madera = priv->madera;\n\tunsigned int reg = MADERA_GPIO1_CTRL_1 + (2 * offset);\n\tint ret;\n\n\t \n\tmadera_gpio_set_direction(pctldev, range, offset, true);\n\n\tret = regmap_update_bits(madera->regmap, reg, MADERA_GP1_FN_MASK, 1);\n\tif (ret)\n\t\tdev_err(priv->dev, \"Failed to write to 0x%x (%d)\\n\", reg, ret);\n}\n\nstatic const struct pinmux_ops madera_pin_mux_ops = {\n\t.get_functions_count = madera_mux_get_funcs_count,\n\t.get_function_name = madera_mux_get_func_name,\n\t.get_function_groups = madera_mux_get_groups,\n\t.set_mux = madera_mux_set_mux,\n\t.gpio_request_enable = madera_gpio_request_enable,\n\t.gpio_disable_free = madera_gpio_disable_free,\n\t.gpio_set_direction = madera_gpio_set_direction,\n\t.strict = true,  \n};\n\nstatic int madera_pin_conf_get(struct pinctrl_dev *pctldev, unsigned int pin,\n\t\t\t       unsigned long *config)\n{\n\tstruct madera_pin_private *priv = pinctrl_dev_get_drvdata(pctldev);\n\tunsigned int param = pinconf_to_config_param(*config);\n\tunsigned int result = 0;\n\tunsigned int reg = MADERA_GPIO1_CTRL_1 + (2 * pin);\n\tunsigned int conf[2];\n\tint ret;\n\n\tret = regmap_read(priv->madera->regmap, reg, &conf[0]);\n\tif (!ret)\n\t\tret = regmap_read(priv->madera->regmap, reg + 1, &conf[1]);\n\n\tif (ret) {\n\t\tdev_err(priv->dev, \"Failed to read GP%d conf (%d)\\n\",\n\t\t\tpin + 1, ret);\n\t\treturn ret;\n\t}\n\n\tswitch (param) {\n\tcase PIN_CONFIG_BIAS_BUS_HOLD:\n\t\tconf[1] &= MADERA_GP1_PU_MASK | MADERA_GP1_PD_MASK;\n\t\tif (conf[1] == (MADERA_GP1_PU | MADERA_GP1_PD))\n\t\t\tresult = 1;\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\tconf[1] &= MADERA_GP1_PU_MASK | MADERA_GP1_PD_MASK;\n\t\tif (!conf[1])\n\t\t\tresult = 1;\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\tconf[1] &= MADERA_GP1_PU_MASK | MADERA_GP1_PD_MASK;\n\t\tif (conf[1] == MADERA_GP1_PD_MASK)\n\t\t\tresult = 1;\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\tconf[1] &= MADERA_GP1_PU_MASK | MADERA_GP1_PD_MASK;\n\t\tif (conf[1] == MADERA_GP1_PU_MASK)\n\t\t\tresult = 1;\n\t\tbreak;\n\tcase PIN_CONFIG_DRIVE_OPEN_DRAIN:\n\t\tif (conf[0] & MADERA_GP1_OP_CFG_MASK)\n\t\t\tresult = 1;\n\t\tbreak;\n\tcase PIN_CONFIG_DRIVE_PUSH_PULL:\n\t\tif (!(conf[0] & MADERA_GP1_OP_CFG_MASK))\n\t\t\tresult = 1;\n\t\tbreak;\n\tcase PIN_CONFIG_DRIVE_STRENGTH:\n\t\tresult = madera_pin_unmake_drv_str(priv, conf[1]);\n\t\tbreak;\n\tcase PIN_CONFIG_INPUT_DEBOUNCE:\n\t\tif (conf[0] & MADERA_GP1_DB_MASK)\n\t\t\tresult = 1;\n\t\tbreak;\n\tcase PIN_CONFIG_INPUT_ENABLE:\n\t\tif (conf[0] & MADERA_GP1_DIR_MASK)\n\t\t\tresult = 1;\n\t\tbreak;\n\tcase PIN_CONFIG_INPUT_SCHMITT:\n\tcase PIN_CONFIG_INPUT_SCHMITT_ENABLE:\n\t\tif (conf[0] & MADERA_GP1_IP_CFG_MASK)\n\t\t\tresult = 1;\n\t\tbreak;\n\tcase PIN_CONFIG_OUTPUT:\n\t\tif ((conf[1] & MADERA_GP1_DIR_MASK) &&\n\t\t    (conf[0] & MADERA_GP1_LVL_MASK))\n\t\t\tresult = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\t*config = pinconf_to_config_packed(param, result);\n\n\treturn 0;\n}\n\nstatic int madera_pin_conf_set(struct pinctrl_dev *pctldev, unsigned int pin,\n\t\t\t       unsigned long *configs, unsigned int num_configs)\n{\n\tstruct madera_pin_private *priv = pinctrl_dev_get_drvdata(pctldev);\n\tu16 conf[2] = {0, 0};\n\tu16 mask[2] = {0, 0};\n\tunsigned int reg = MADERA_GPIO1_CTRL_1 + (2 * pin);\n\tunsigned int val;\n\tint ret;\n\n\twhile (num_configs) {\n\t\tdev_dbg(priv->dev, \"%s config 0x%lx\\n\", __func__, *configs);\n\n\t\tswitch (pinconf_to_config_param(*configs)) {\n\t\tcase PIN_CONFIG_BIAS_BUS_HOLD:\n\t\t\tmask[1] |= MADERA_GP1_PU_MASK | MADERA_GP1_PD_MASK;\n\t\t\tconf[1] |= MADERA_GP1_PU | MADERA_GP1_PD;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\t\tmask[1] |= MADERA_GP1_PU_MASK | MADERA_GP1_PD_MASK;\n\t\t\tconf[1] &= ~(MADERA_GP1_PU | MADERA_GP1_PD);\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\t\tmask[1] |= MADERA_GP1_PU_MASK | MADERA_GP1_PD_MASK;\n\t\t\tconf[1] |= MADERA_GP1_PD;\n\t\t\tconf[1] &= ~MADERA_GP1_PU;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\t\tmask[1] |= MADERA_GP1_PU_MASK | MADERA_GP1_PD_MASK;\n\t\t\tconf[1] |= MADERA_GP1_PU;\n\t\t\tconf[1] &= ~MADERA_GP1_PD;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_DRIVE_OPEN_DRAIN:\n\t\t\tmask[0] |= MADERA_GP1_OP_CFG_MASK;\n\t\t\tconf[0] |= MADERA_GP1_OP_CFG;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_DRIVE_PUSH_PULL:\n\t\t\tmask[0] |= MADERA_GP1_OP_CFG_MASK;\n\t\t\tconf[0] &= ~MADERA_GP1_OP_CFG;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_DRIVE_STRENGTH:\n\t\t\tval = pinconf_to_config_argument(*configs);\n\t\t\tmask[1] |= MADERA_GP1_DRV_STR_MASK;\n\t\t\tconf[1] &= ~MADERA_GP1_DRV_STR_MASK;\n\t\t\tconf[1] |= madera_pin_make_drv_str(priv, val);\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_INPUT_DEBOUNCE:\n\t\t\tmask[0] |= MADERA_GP1_DB_MASK;\n\n\t\t\t \n\t\t\tval = pinconf_to_config_argument(*configs);\n\t\t\tif (val)\n\t\t\t\tconf[0] |= MADERA_GP1_DB;\n\t\t\telse\n\t\t\t\tconf[0] &= ~MADERA_GP1_DB;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_INPUT_ENABLE:\n\t\t\tval = pinconf_to_config_argument(*configs);\n\t\t\tmask[1] |= MADERA_GP1_DIR_MASK;\n\t\t\tif (val)\n\t\t\t\tconf[1] |= MADERA_GP1_DIR;\n\t\t\telse\n\t\t\t\tconf[1] &= ~MADERA_GP1_DIR;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_INPUT_SCHMITT:\n\t\t\tval = pinconf_to_config_argument(*configs);\n\t\t\tmask[0] |= MADERA_GP1_IP_CFG;\n\t\t\tif (val)\n\t\t\t\tconf[0] |= MADERA_GP1_IP_CFG;\n\t\t\telse\n\t\t\t\tconf[0] &= ~MADERA_GP1_IP_CFG;\n\n\t\t\tmask[1] |= MADERA_GP1_DIR_MASK;\n\t\t\tconf[1] |= MADERA_GP1_DIR;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_INPUT_SCHMITT_ENABLE:\n\t\t\tmask[0] |= MADERA_GP1_IP_CFG;\n\t\t\tconf[0] |= MADERA_GP1_IP_CFG;\n\t\t\tmask[1] |= MADERA_GP1_DIR_MASK;\n\t\t\tconf[1] |= MADERA_GP1_DIR;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_OUTPUT:\n\t\t\tval = pinconf_to_config_argument(*configs);\n\t\t\tmask[0] |= MADERA_GP1_LVL_MASK;\n\t\t\tif (val)\n\t\t\t\tconf[0] |= MADERA_GP1_LVL;\n\t\t\telse\n\t\t\t\tconf[0] &= ~MADERA_GP1_LVL;\n\n\t\t\tmask[1] |= MADERA_GP1_DIR_MASK;\n\t\t\tconf[1] &= ~MADERA_GP1_DIR;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\n\t\t++configs;\n\t\t--num_configs;\n\t}\n\n\tdev_dbg(priv->dev,\n\t\t\"%s gpio%d 0x%x:0x%x 0x%x:0x%x\\n\",\n\t\t__func__, pin + 1, reg, conf[0], reg + 1, conf[1]);\n\n\tret = regmap_update_bits(priv->madera->regmap, reg, mask[0], conf[0]);\n\tif (ret)\n\t\tgoto err;\n\n\t++reg;\n\tret = regmap_update_bits(priv->madera->regmap, reg, mask[1], conf[1]);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tdev_err(priv->dev,\n\t\t\"Failed to write GPIO%d conf (%d) reg 0x%x\\n\",\n\t\tpin + 1, ret, reg);\n\n\treturn ret;\n}\n\nstatic int madera_pin_conf_group_set(struct pinctrl_dev *pctldev,\n\t\t\t\t     unsigned int selector,\n\t\t\t\t     unsigned long *configs,\n\t\t\t\t     unsigned int num_configs)\n{\n\tstruct madera_pin_private *priv = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct madera_pin_groups *pin_group;\n\tunsigned int n_groups = priv->chip->n_pin_groups;\n\tint i, ret;\n\n\tdev_dbg(priv->dev, \"%s setting group %s\\n\", __func__,\n\t\tmadera_get_group_name(pctldev, selector));\n\n\tif (selector >= n_groups) {\n\t\t \n\t\treturn madera_pin_conf_set(pctldev,\n\t\t\t\t\t   selector - n_groups,\n\t\t\t\t\t   configs,\n\t\t\t\t\t   num_configs);\n\t} else {\n\t\tpin_group = &priv->chip->pin_groups[selector];\n\n\t\tfor (i = 0; i < pin_group->n_pins; ++i) {\n\t\t\tret = madera_pin_conf_set(pctldev,\n\t\t\t\t\t\t  pin_group->pins[i],\n\t\t\t\t\t\t  configs,\n\t\t\t\t\t\t  num_configs);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct pinconf_ops madera_pin_conf_ops = {\n\t.is_generic = true,\n\t.pin_config_get = madera_pin_conf_get,\n\t.pin_config_set = madera_pin_conf_set,\n\t.pin_config_group_set = madera_pin_conf_group_set,\n};\n\nstatic struct pinctrl_desc madera_pin_desc = {\n\t.name = \"madera-pinctrl\",\n\t.pins = madera_pins,\n\t.pctlops = &madera_pin_group_ops,\n\t.pmxops = &madera_pin_mux_ops,\n\t.confops = &madera_pin_conf_ops,\n\t.owner = THIS_MODULE,\n};\n\nstatic int madera_pin_probe(struct platform_device *pdev)\n{\n\tstruct madera *madera = dev_get_drvdata(pdev->dev.parent);\n\tconst struct madera_pdata *pdata = &madera->pdata;\n\tstruct madera_pin_private *priv;\n\tint ret;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(madera_pin_single_group_names) !=\n\t\t     ARRAY_SIZE(madera_pin_single_group_pins));\n\n\tdev_dbg(&pdev->dev, \"%s\\n\", __func__);\n\n\tdevice_set_node(&pdev->dev, dev_fwnode(pdev->dev.parent));\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->dev = &pdev->dev;\n\tpriv->madera = madera;\n\n\tswitch (madera->type) {\n\tcase CS47L15:\n\t\tif (IS_ENABLED(CONFIG_PINCTRL_CS47L15))\n\t\t\tpriv->chip = &cs47l15_pin_chip;\n\t\tbreak;\n\tcase CS47L35:\n\t\tif (IS_ENABLED(CONFIG_PINCTRL_CS47L35))\n\t\t\tpriv->chip = &cs47l35_pin_chip;\n\t\tbreak;\n\tcase CS47L85:\n\tcase WM1840:\n\t\tif (IS_ENABLED(CONFIG_PINCTRL_CS47L85))\n\t\t\tpriv->chip = &cs47l85_pin_chip;\n\t\tbreak;\n\tcase CS47L90:\n\tcase CS47L91:\n\t\tif (IS_ENABLED(CONFIG_PINCTRL_CS47L90))\n\t\t\tpriv->chip = &cs47l90_pin_chip;\n\t\tbreak;\n\tcase CS42L92:\n\tcase CS47L92:\n\tcase CS47L93:\n\t\tif (IS_ENABLED(CONFIG_PINCTRL_CS47L92))\n\t\t\tpriv->chip = &cs47l92_pin_chip;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!priv->chip)\n\t\treturn -ENODEV;\n\n\tmadera_pin_desc.npins = priv->chip->n_pins;\n\n\tret = devm_pinctrl_register_and_init(&pdev->dev,\n\t\t\t\t\t     &madera_pin_desc,\n\t\t\t\t\t     priv,\n\t\t\t\t\t     &priv->pctl);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"Failed pinctrl register (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (pdata->gpio_configs) {\n\t\tret = pinctrl_register_mappings(pdata->gpio_configs,\n\t\t\t\t\t\tpdata->n_gpio_configs);\n\t\tif (ret) {\n\t\t\tdev_err(priv->dev,\n\t\t\t\t\"Failed to register pdata mappings (%d)\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = pinctrl_enable(priv->pctl);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"Failed to enable pinctrl (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tdev_dbg(priv->dev, \"pinctrl probed ok\\n\");\n\n\treturn 0;\n}\n\nstatic int madera_pin_remove(struct platform_device *pdev)\n{\n\tstruct madera_pin_private *priv = platform_get_drvdata(pdev);\n\n\tif (priv->madera->pdata.gpio_configs)\n\t\tpinctrl_unregister_mappings(priv->madera->pdata.gpio_configs);\n\n\treturn 0;\n}\n\nstatic struct platform_driver madera_pin_driver = {\n\t.probe = madera_pin_probe,\n\t.remove = madera_pin_remove,\n\t.driver = {\n\t\t.name = \"madera-pinctrl\",\n\t},\n};\n\nmodule_platform_driver(madera_pin_driver);\n\nMODULE_DESCRIPTION(\"Madera pinctrl driver\");\nMODULE_AUTHOR(\"Richard Fitzgerald <rf@opensource.cirrus.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}