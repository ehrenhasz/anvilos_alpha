{
  "module_name": "pinctrl-at91-pio4.c",
  "hash_id": "150501c18cbd41ade28ce015429c85b29404b8991569eeb6a4fc9b7b95c30bc8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/pinctrl-at91-pio4.c",
  "human_readable_source": "\n \n\n#include <dt-bindings/pinctrl/at91.h>\n\n#include <linux/clk.h>\n#include <linux/gpio/driver.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n\n#include <linux/pinctrl/pinconf-generic.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinmux.h>\n\n#include \"core.h\"\n#include \"pinconf.h\"\n#include \"pinctrl-utils.h\"\n\n \n\n#define ATMEL_PIO_MSKR\t\t0x0000\n#define ATMEL_PIO_CFGR\t\t0x0004\n#define\t\tATMEL_PIO_CFGR_FUNC_MASK\tGENMASK(2, 0)\n#define\t\tATMEL_PIO_DIR_MASK\t\tBIT(8)\n#define\t\tATMEL_PIO_PUEN_MASK\t\tBIT(9)\n#define\t\tATMEL_PIO_PDEN_MASK\t\tBIT(10)\n#define\t\tATMEL_PIO_SR_MASK\t\tBIT(11)\n#define\t\tATMEL_PIO_IFEN_MASK\t\tBIT(12)\n#define\t\tATMEL_PIO_IFSCEN_MASK\t\tBIT(13)\n#define\t\tATMEL_PIO_OPD_MASK\t\tBIT(14)\n#define\t\tATMEL_PIO_SCHMITT_MASK\t\tBIT(15)\n#define\t\tATMEL_PIO_DRVSTR_MASK\t\tGENMASK(17, 16)\n#define\t\tATMEL_PIO_DRVSTR_OFFSET\t\t16\n#define\t\tATMEL_PIO_CFGR_EVTSEL_MASK\tGENMASK(26, 24)\n#define\t\tATMEL_PIO_CFGR_EVTSEL_FALLING\t(0 << 24)\n#define\t\tATMEL_PIO_CFGR_EVTSEL_RISING\t(1 << 24)\n#define\t\tATMEL_PIO_CFGR_EVTSEL_BOTH\t(2 << 24)\n#define\t\tATMEL_PIO_CFGR_EVTSEL_LOW\t(3 << 24)\n#define\t\tATMEL_PIO_CFGR_EVTSEL_HIGH\t(4 << 24)\n#define ATMEL_PIO_PDSR\t\t0x0008\n#define ATMEL_PIO_LOCKSR\t0x000C\n#define ATMEL_PIO_SODR\t\t0x0010\n#define ATMEL_PIO_CODR\t\t0x0014\n#define ATMEL_PIO_ODSR\t\t0x0018\n#define ATMEL_PIO_IER\t\t0x0020\n#define ATMEL_PIO_IDR\t\t0x0024\n#define ATMEL_PIO_IMR\t\t0x0028\n#define ATMEL_PIO_ISR\t\t0x002C\n#define ATMEL_PIO_IOFR\t\t0x003C\n\n#define ATMEL_PIO_NPINS_PER_BANK\t32\n#define ATMEL_PIO_BANK(pin_id)\t\t(pin_id / ATMEL_PIO_NPINS_PER_BANK)\n#define ATMEL_PIO_LINE(pin_id)\t\t(pin_id % ATMEL_PIO_NPINS_PER_BANK)\n#define ATMEL_PIO_BANK_OFFSET\t\t0x40\n\n#define ATMEL_GET_PIN_NO(pinfunc)\t((pinfunc) & 0xff)\n#define ATMEL_GET_PIN_FUNC(pinfunc)\t((pinfunc >> 16) & 0xf)\n#define ATMEL_GET_PIN_IOSET(pinfunc)\t((pinfunc >> 20) & 0xf)\n\n \n#define ATMEL_PIN_CONFIG_DRIVE_STRENGTH\t(PIN_CONFIG_END + 1)\n\n \nstruct atmel_pioctrl_data {\n\tunsigned int nbanks;\n\tunsigned int last_bank_count;\n\tunsigned int slew_rate_support;\n};\n\nstruct atmel_group {\n\tconst char *name;\n\tu32 pin;\n};\n\nstruct atmel_pin {\n\tunsigned int pin_id;\n\tunsigned int mux;\n\tunsigned int ioset;\n\tunsigned int bank;\n\tunsigned int line;\n\tconst char *device;\n};\n\n \nstruct atmel_pioctrl {\n\tvoid __iomem\t\t*reg_base;\n\tstruct clk\t\t*clk;\n\tunsigned int\t\tnbanks;\n\tstruct pinctrl_dev\t*pinctrl_dev;\n\tstruct atmel_group\t*groups;\n\tconst char * const\t*group_names;\n\tstruct atmel_pin\t**pins;\n\tunsigned int\t\tnpins;\n\tstruct gpio_chip\t*gpio_chip;\n\tstruct irq_domain\t*irq_domain;\n\tint\t\t\t*irqs;\n\tunsigned int\t\t*pm_wakeup_sources;\n\tstruct {\n\t\tu32\t\timr;\n\t\tu32\t\todsr;\n\t\tu32\t\tcfgr[ATMEL_PIO_NPINS_PER_BANK];\n\t} *pm_suspend_backup;\n\tstruct device\t\t*dev;\n\tstruct device_node\t*node;\n\tunsigned int\t\tslew_rate_support;\n};\n\nstatic const char * const atmel_functions[] = {\n\t\"GPIO\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"\n};\n\nstatic const struct pinconf_generic_params atmel_custom_bindings[] = {\n\t{\"atmel,drive-strength\", ATMEL_PIN_CONFIG_DRIVE_STRENGTH, 0},\n};\n\n \nstatic unsigned int atmel_gpio_read(struct atmel_pioctrl *atmel_pioctrl,\n\t\t\t\t    unsigned int bank, unsigned int reg)\n{\n\treturn readl_relaxed(atmel_pioctrl->reg_base\n\t\t\t     + ATMEL_PIO_BANK_OFFSET * bank + reg);\n}\n\nstatic void atmel_gpio_write(struct atmel_pioctrl *atmel_pioctrl,\n\t\t\t     unsigned int bank, unsigned int reg,\n\t\t\t     unsigned int val)\n{\n\twritel_relaxed(val, atmel_pioctrl->reg_base\n\t\t       + ATMEL_PIO_BANK_OFFSET * bank + reg);\n}\n\nstatic void atmel_gpio_irq_ack(struct irq_data *d)\n{\n\t \n}\n\nstatic int atmel_gpio_irq_set_type(struct irq_data *d, unsigned int type)\n{\n\tstruct atmel_pioctrl *atmel_pioctrl = irq_data_get_irq_chip_data(d);\n\tstruct atmel_pin *pin = atmel_pioctrl->pins[d->hwirq];\n\tunsigned int reg;\n\n\tatmel_gpio_write(atmel_pioctrl, pin->bank, ATMEL_PIO_MSKR,\n\t\t\t BIT(pin->line));\n\treg = atmel_gpio_read(atmel_pioctrl, pin->bank, ATMEL_PIO_CFGR);\n\treg &= (~ATMEL_PIO_CFGR_EVTSEL_MASK);\n\n\tswitch (type) {\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tirq_set_handler_locked(d, handle_edge_irq);\n\t\treg |= ATMEL_PIO_CFGR_EVTSEL_RISING;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tirq_set_handler_locked(d, handle_edge_irq);\n\t\treg |= ATMEL_PIO_CFGR_EVTSEL_FALLING;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\tirq_set_handler_locked(d, handle_edge_irq);\n\t\treg |= ATMEL_PIO_CFGR_EVTSEL_BOTH;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tirq_set_handler_locked(d, handle_level_irq);\n\t\treg |= ATMEL_PIO_CFGR_EVTSEL_LOW;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tirq_set_handler_locked(d, handle_level_irq);\n\t\treg |= ATMEL_PIO_CFGR_EVTSEL_HIGH;\n\t\tbreak;\n\tcase IRQ_TYPE_NONE:\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tatmel_gpio_write(atmel_pioctrl, pin->bank, ATMEL_PIO_CFGR, reg);\n\n\treturn 0;\n}\n\nstatic void atmel_gpio_irq_mask(struct irq_data *d)\n{\n\tstruct atmel_pioctrl *atmel_pioctrl = irq_data_get_irq_chip_data(d);\n\tstruct atmel_pin *pin = atmel_pioctrl->pins[d->hwirq];\n\n\tatmel_gpio_write(atmel_pioctrl, pin->bank, ATMEL_PIO_IDR,\n\t\t\t BIT(pin->line));\n}\n\nstatic void atmel_gpio_irq_unmask(struct irq_data *d)\n{\n\tstruct atmel_pioctrl *atmel_pioctrl = irq_data_get_irq_chip_data(d);\n\tstruct atmel_pin *pin = atmel_pioctrl->pins[d->hwirq];\n\n\tatmel_gpio_write(atmel_pioctrl, pin->bank, ATMEL_PIO_IER,\n\t\t\t BIT(pin->line));\n}\n\nstatic int atmel_gpio_irq_set_wake(struct irq_data *d, unsigned int on)\n{\n\tstruct atmel_pioctrl *atmel_pioctrl = irq_data_get_irq_chip_data(d);\n\tint bank = ATMEL_PIO_BANK(d->hwirq);\n\tint line = ATMEL_PIO_LINE(d->hwirq);\n\n\t \n\tirq_set_irq_wake(atmel_pioctrl->irqs[bank], on);\n\n\tif (on)\n\t\tatmel_pioctrl->pm_wakeup_sources[bank] |= BIT(line);\n\telse\n\t\tatmel_pioctrl->pm_wakeup_sources[bank] &= ~(BIT(line));\n\n\treturn 0;\n}\n\nstatic struct irq_chip atmel_gpio_irq_chip = {\n\t.name\t\t= \"GPIO\",\n\t.irq_ack\t= atmel_gpio_irq_ack,\n\t.irq_mask\t= atmel_gpio_irq_mask,\n\t.irq_unmask\t= atmel_gpio_irq_unmask,\n\t.irq_set_type\t= atmel_gpio_irq_set_type,\n\t.irq_set_wake\t= pm_sleep_ptr(atmel_gpio_irq_set_wake),\n};\n\nstatic int atmel_gpio_to_irq(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct atmel_pioctrl *atmel_pioctrl = gpiochip_get_data(chip);\n\n\treturn irq_find_mapping(atmel_pioctrl->irq_domain, offset);\n}\n\nstatic void atmel_gpio_irq_handler(struct irq_desc *desc)\n{\n\tunsigned int irq = irq_desc_get_irq(desc);\n\tstruct atmel_pioctrl *atmel_pioctrl = irq_desc_get_handler_data(desc);\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tunsigned long isr;\n\tint n, bank = -1;\n\n\t \n\tfor (n = 0; n < atmel_pioctrl->nbanks; n++) {\n\t\tif (atmel_pioctrl->irqs[n] == irq) {\n\t\t\tbank = n;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (bank < 0) {\n\t\tdev_err(atmel_pioctrl->dev,\n\t\t\t\"no bank associated to irq %u\\n\", irq);\n\t\treturn;\n\t}\n\n\tchained_irq_enter(chip, desc);\n\n\tfor (;;) {\n\t\tisr = (unsigned long)atmel_gpio_read(atmel_pioctrl, bank,\n\t\t\t\t\t\t     ATMEL_PIO_ISR);\n\t\tisr &= (unsigned long)atmel_gpio_read(atmel_pioctrl, bank,\n\t\t\t\t\t\t      ATMEL_PIO_IMR);\n\t\tif (!isr)\n\t\t\tbreak;\n\n\t\tfor_each_set_bit(n, &isr, BITS_PER_LONG)\n\t\t\tgeneric_handle_irq(atmel_gpio_to_irq(\n\t\t\t\t\tatmel_pioctrl->gpio_chip,\n\t\t\t\t\tbank * ATMEL_PIO_NPINS_PER_BANK + n));\n\t}\n\n\tchained_irq_exit(chip, desc);\n}\n\nstatic int atmel_gpio_direction_input(struct gpio_chip *chip,\n\t\t\t\t      unsigned int offset)\n{\n\tstruct atmel_pioctrl *atmel_pioctrl = gpiochip_get_data(chip);\n\tstruct atmel_pin *pin = atmel_pioctrl->pins[offset];\n\tunsigned int reg;\n\n\tatmel_gpio_write(atmel_pioctrl, pin->bank, ATMEL_PIO_MSKR,\n\t\t\t BIT(pin->line));\n\treg = atmel_gpio_read(atmel_pioctrl, pin->bank, ATMEL_PIO_CFGR);\n\treg &= ~ATMEL_PIO_DIR_MASK;\n\tatmel_gpio_write(atmel_pioctrl, pin->bank, ATMEL_PIO_CFGR, reg);\n\n\treturn 0;\n}\n\nstatic int atmel_gpio_get(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct atmel_pioctrl *atmel_pioctrl = gpiochip_get_data(chip);\n\tstruct atmel_pin *pin = atmel_pioctrl->pins[offset];\n\tunsigned int reg;\n\n\treg = atmel_gpio_read(atmel_pioctrl, pin->bank, ATMEL_PIO_PDSR);\n\n\treturn !!(reg & BIT(pin->line));\n}\n\nstatic int atmel_gpio_get_multiple(struct gpio_chip *chip, unsigned long *mask,\n\t\t\t\t   unsigned long *bits)\n{\n\tstruct atmel_pioctrl *atmel_pioctrl = gpiochip_get_data(chip);\n\tunsigned int bank;\n\n\tbitmap_zero(bits, atmel_pioctrl->npins);\n\n\tfor (bank = 0; bank < atmel_pioctrl->nbanks; bank++) {\n\t\tunsigned int word = bank;\n\t\tunsigned int offset = 0;\n\t\tunsigned int reg;\n\n#if ATMEL_PIO_NPINS_PER_BANK != BITS_PER_LONG\n\t\tword = BIT_WORD(bank * ATMEL_PIO_NPINS_PER_BANK);\n\t\toffset = bank * ATMEL_PIO_NPINS_PER_BANK % BITS_PER_LONG;\n#endif\n\t\tif (!mask[word])\n\t\t\tcontinue;\n\n\t\treg = atmel_gpio_read(atmel_pioctrl, bank, ATMEL_PIO_PDSR);\n\t\tbits[word] |= mask[word] & (reg << offset);\n\t}\n\n\treturn 0;\n}\n\nstatic int atmel_gpio_direction_output(struct gpio_chip *chip,\n\t\t\t\t       unsigned int offset,\n\t\t\t\t       int value)\n{\n\tstruct atmel_pioctrl *atmel_pioctrl = gpiochip_get_data(chip);\n\tstruct atmel_pin *pin = atmel_pioctrl->pins[offset];\n\tunsigned int reg;\n\n\tatmel_gpio_write(atmel_pioctrl, pin->bank,\n\t\t\t value ? ATMEL_PIO_SODR : ATMEL_PIO_CODR,\n\t\t\t BIT(pin->line));\n\n\tatmel_gpio_write(atmel_pioctrl, pin->bank, ATMEL_PIO_MSKR,\n\t\t\t BIT(pin->line));\n\treg = atmel_gpio_read(atmel_pioctrl, pin->bank, ATMEL_PIO_CFGR);\n\treg |= ATMEL_PIO_DIR_MASK;\n\tatmel_gpio_write(atmel_pioctrl, pin->bank, ATMEL_PIO_CFGR, reg);\n\n\treturn 0;\n}\n\nstatic void atmel_gpio_set(struct gpio_chip *chip, unsigned int offset, int val)\n{\n\tstruct atmel_pioctrl *atmel_pioctrl = gpiochip_get_data(chip);\n\tstruct atmel_pin *pin = atmel_pioctrl->pins[offset];\n\n\tatmel_gpio_write(atmel_pioctrl, pin->bank,\n\t\t\t val ? ATMEL_PIO_SODR : ATMEL_PIO_CODR,\n\t\t\t BIT(pin->line));\n}\n\nstatic void atmel_gpio_set_multiple(struct gpio_chip *chip, unsigned long *mask,\n\t\t\t\t    unsigned long *bits)\n{\n\tstruct atmel_pioctrl *atmel_pioctrl = gpiochip_get_data(chip);\n\tunsigned int bank;\n\n\tfor (bank = 0; bank < atmel_pioctrl->nbanks; bank++) {\n\t\tunsigned int bitmask;\n\t\tunsigned int word = bank;\n\n \n#if ATMEL_PIO_NPINS_PER_BANK != BITS_PER_LONG\n\t\tword = BIT_WORD(bank * ATMEL_PIO_NPINS_PER_BANK);\n#endif\n\t\tif (!mask[word])\n\t\t\tcontinue;\n\n\t\tbitmask = mask[word] & bits[word];\n\t\tatmel_gpio_write(atmel_pioctrl, bank, ATMEL_PIO_SODR, bitmask);\n\n\t\tbitmask = mask[word] & ~bits[word];\n\t\tatmel_gpio_write(atmel_pioctrl, bank, ATMEL_PIO_CODR, bitmask);\n\n#if ATMEL_PIO_NPINS_PER_BANK != BITS_PER_LONG\n\t\tmask[word] >>= ATMEL_PIO_NPINS_PER_BANK;\n\t\tbits[word] >>= ATMEL_PIO_NPINS_PER_BANK;\n#endif\n\t}\n}\n\nstatic struct gpio_chip atmel_gpio_chip = {\n\t.direction_input        = atmel_gpio_direction_input,\n\t.get                    = atmel_gpio_get,\n\t.get_multiple           = atmel_gpio_get_multiple,\n\t.direction_output       = atmel_gpio_direction_output,\n\t.set                    = atmel_gpio_set,\n\t.set_multiple           = atmel_gpio_set_multiple,\n\t.to_irq                 = atmel_gpio_to_irq,\n\t.base                   = 0,\n};\n\n \nstatic unsigned int atmel_pin_config_read(struct pinctrl_dev *pctldev,\n\t\t\t\t\t  unsigned int pin_id)\n{\n\tstruct atmel_pioctrl *atmel_pioctrl = pinctrl_dev_get_drvdata(pctldev);\n\tunsigned int bank = atmel_pioctrl->pins[pin_id]->bank;\n\tunsigned int line = atmel_pioctrl->pins[pin_id]->line;\n\tvoid __iomem *addr = atmel_pioctrl->reg_base\n\t\t\t     + bank * ATMEL_PIO_BANK_OFFSET;\n\n\twritel_relaxed(BIT(line), addr + ATMEL_PIO_MSKR);\n\t \n\twmb();\n\n\treturn readl_relaxed(addr + ATMEL_PIO_CFGR);\n}\n\nstatic void atmel_pin_config_write(struct pinctrl_dev *pctldev,\n\t\t\t\t   unsigned int pin_id, u32 conf)\n{\n\tstruct atmel_pioctrl *atmel_pioctrl = pinctrl_dev_get_drvdata(pctldev);\n\tunsigned int bank = atmel_pioctrl->pins[pin_id]->bank;\n\tunsigned int line = atmel_pioctrl->pins[pin_id]->line;\n\tvoid __iomem *addr = atmel_pioctrl->reg_base\n\t\t\t     + bank * ATMEL_PIO_BANK_OFFSET;\n\n\twritel_relaxed(BIT(line), addr + ATMEL_PIO_MSKR);\n\t \n\twmb();\n\twritel_relaxed(conf, addr + ATMEL_PIO_CFGR);\n}\n\nstatic int atmel_pctl_get_groups_count(struct pinctrl_dev *pctldev)\n{\n\tstruct atmel_pioctrl *atmel_pioctrl = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn atmel_pioctrl->npins;\n}\n\nstatic const char *atmel_pctl_get_group_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t     unsigned int selector)\n{\n\tstruct atmel_pioctrl *atmel_pioctrl = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn atmel_pioctrl->groups[selector].name;\n}\n\nstatic int atmel_pctl_get_group_pins(struct pinctrl_dev *pctldev,\n\t\t\t\t     unsigned int selector,\n\t\t\t\t     const unsigned int **pins,\n\t\t\t\t     unsigned int *num_pins)\n{\n\tstruct atmel_pioctrl *atmel_pioctrl = pinctrl_dev_get_drvdata(pctldev);\n\n\t*pins = (unsigned int *)&atmel_pioctrl->groups[selector].pin;\n\t*num_pins = 1;\n\n\treturn 0;\n}\n\nstatic struct atmel_group *\natmel_pctl_find_group_by_pin(struct pinctrl_dev *pctldev, unsigned int pin)\n{\n\tstruct atmel_pioctrl *atmel_pioctrl = pinctrl_dev_get_drvdata(pctldev);\n\tint i;\n\n\tfor (i = 0; i < atmel_pioctrl->npins; i++) {\n\t\tstruct atmel_group *grp = atmel_pioctrl->groups + i;\n\n\t\tif (grp->pin == pin)\n\t\t\treturn grp;\n\t}\n\n\treturn NULL;\n}\n\nstatic int atmel_pctl_xlate_pinfunc(struct pinctrl_dev *pctldev,\n\t\t\t\t    struct device_node *np,\n\t\t\t\t    u32 pinfunc, const char **grp_name,\n\t\t\t\t    const char **func_name)\n{\n\tstruct atmel_pioctrl *atmel_pioctrl = pinctrl_dev_get_drvdata(pctldev);\n\tunsigned int pin_id, func_id;\n\tstruct atmel_group *grp;\n\n\tpin_id = ATMEL_GET_PIN_NO(pinfunc);\n\tfunc_id = ATMEL_GET_PIN_FUNC(pinfunc);\n\n\tif (func_id >= ARRAY_SIZE(atmel_functions))\n\t\treturn -EINVAL;\n\n\t*func_name = atmel_functions[func_id];\n\n\tgrp = atmel_pctl_find_group_by_pin(pctldev, pin_id);\n\tif (!grp)\n\t\treturn -EINVAL;\n\t*grp_name = grp->name;\n\n\tatmel_pioctrl->pins[pin_id]->mux = func_id;\n\tatmel_pioctrl->pins[pin_id]->ioset = ATMEL_GET_PIN_IOSET(pinfunc);\n\t \n\tif (np->parent == atmel_pioctrl->node)\n\t\tatmel_pioctrl->pins[pin_id]->device = np->name;\n\telse\n\t\tatmel_pioctrl->pins[pin_id]->device = np->parent->name;\n\n\treturn 0;\n}\n\nstatic int atmel_pctl_dt_subnode_to_map(struct pinctrl_dev *pctldev,\n\t\t\t\t\tstruct device_node *np,\n\t\t\t\t\tstruct pinctrl_map **map,\n\t\t\t\t\tunsigned int *reserved_maps,\n\t\t\t\t\tunsigned int *num_maps)\n{\n\tunsigned int num_pins, num_configs, reserve;\n\tunsigned long *configs;\n\tstruct property\t*pins;\n\tu32 pinfunc;\n\tint ret, i;\n\n\tpins = of_find_property(np, \"pinmux\", NULL);\n\tif (!pins)\n\t\treturn -EINVAL;\n\n\tret = pinconf_generic_parse_dt_config(np, pctldev, &configs,\n\t\t\t\t\t      &num_configs);\n\tif (ret < 0) {\n\t\tdev_err(pctldev->dev, \"%pOF: could not parse node property\\n\",\n\t\t\tnp);\n\t\treturn ret;\n\t}\n\n\tnum_pins = pins->length / sizeof(u32);\n\tif (!num_pins) {\n\t\tdev_err(pctldev->dev, \"no pins found in node %pOF\\n\", np);\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\t \n\treserve = 1;\n\tif (num_configs)\n\t\treserve++;\n\treserve *= num_pins;\n\tret = pinctrl_utils_reserve_map(pctldev, map, reserved_maps, num_maps,\n\t\t\t\t\treserve);\n\tif (ret < 0)\n\t\tgoto exit;\n\n\tfor (i = 0; i < num_pins; i++) {\n\t\tconst char *group, *func;\n\n\t\tret = of_property_read_u32_index(np, \"pinmux\", i, &pinfunc);\n\t\tif (ret)\n\t\t\tgoto exit;\n\n\t\tret = atmel_pctl_xlate_pinfunc(pctldev, np, pinfunc, &group,\n\t\t\t\t\t       &func);\n\t\tif (ret)\n\t\t\tgoto exit;\n\n\t\tpinctrl_utils_add_map_mux(pctldev, map, reserved_maps, num_maps,\n\t\t\t\t\t  group, func);\n\n\t\tif (num_configs) {\n\t\t\tret = pinctrl_utils_add_map_configs(pctldev, map,\n\t\t\t\t\treserved_maps, num_maps, group,\n\t\t\t\t\tconfigs, num_configs,\n\t\t\t\t\tPIN_MAP_TYPE_CONFIGS_GROUP);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto exit;\n\t\t}\n\t}\n\nexit:\n\tkfree(configs);\n\treturn ret;\n}\n\nstatic int atmel_pctl_dt_node_to_map(struct pinctrl_dev *pctldev,\n\t\t\t\t     struct device_node *np_config,\n\t\t\t\t     struct pinctrl_map **map,\n\t\t\t\t     unsigned int *num_maps)\n{\n\tstruct device_node *np;\n\tunsigned int reserved_maps;\n\tint ret;\n\n\t*map = NULL;\n\t*num_maps = 0;\n\treserved_maps = 0;\n\n\t \n\tret = atmel_pctl_dt_subnode_to_map(pctldev, np_config, map,\n\t\t\t\t\t   &reserved_maps, num_maps);\n\tif (ret) {\n\t\tfor_each_child_of_node(np_config, np) {\n\t\t\tret = atmel_pctl_dt_subnode_to_map(pctldev, np, map,\n\t\t\t\t\t\t    &reserved_maps, num_maps);\n\t\t\tif (ret < 0) {\n\t\t\t\tof_node_put(np);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ret < 0) {\n\t\tpinctrl_utils_free_map(pctldev, *map, *num_maps);\n\t\tdev_err(pctldev->dev, \"can't create maps for node %pOF\\n\",\n\t\t\tnp_config);\n\t}\n\n\treturn ret;\n}\n\nstatic const struct pinctrl_ops atmel_pctlops = {\n\t.get_groups_count\t= atmel_pctl_get_groups_count,\n\t.get_group_name\t\t= atmel_pctl_get_group_name,\n\t.get_group_pins\t\t= atmel_pctl_get_group_pins,\n\t.dt_node_to_map\t\t= atmel_pctl_dt_node_to_map,\n\t.dt_free_map\t\t= pinctrl_utils_free_map,\n};\n\nstatic int atmel_pmx_get_functions_count(struct pinctrl_dev *pctldev)\n{\n\treturn ARRAY_SIZE(atmel_functions);\n}\n\nstatic const char *atmel_pmx_get_function_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t       unsigned int selector)\n{\n\treturn atmel_functions[selector];\n}\n\nstatic int atmel_pmx_get_function_groups(struct pinctrl_dev *pctldev,\n\t\t\t\t\t unsigned int selector,\n\t\t\t\t\t const char * const **groups,\n\t\t\t\t\t unsigned * const num_groups)\n{\n\tstruct atmel_pioctrl *atmel_pioctrl = pinctrl_dev_get_drvdata(pctldev);\n\n\t*groups = atmel_pioctrl->group_names;\n\t*num_groups = atmel_pioctrl->npins;\n\n\treturn 0;\n}\n\nstatic int atmel_pmx_set_mux(struct pinctrl_dev *pctldev,\n\t\t\t     unsigned int function,\n\t\t\t     unsigned int group)\n{\n\tstruct atmel_pioctrl *atmel_pioctrl = pinctrl_dev_get_drvdata(pctldev);\n\tunsigned int pin;\n\tu32 conf;\n\n\tdev_dbg(pctldev->dev, \"enable function %s group %s\\n\",\n\t\tatmel_functions[function], atmel_pioctrl->groups[group].name);\n\n\tpin = atmel_pioctrl->groups[group].pin;\n\tconf = atmel_pin_config_read(pctldev, pin);\n\tconf &= (~ATMEL_PIO_CFGR_FUNC_MASK);\n\tconf |= (function & ATMEL_PIO_CFGR_FUNC_MASK);\n\tdev_dbg(pctldev->dev, \"pin: %u, conf: 0x%08x\\n\", pin, conf);\n\tatmel_pin_config_write(pctldev, pin, conf);\n\n\treturn 0;\n}\n\nstatic const struct pinmux_ops atmel_pmxops = {\n\t.get_functions_count\t= atmel_pmx_get_functions_count,\n\t.get_function_name\t= atmel_pmx_get_function_name,\n\t.get_function_groups\t= atmel_pmx_get_function_groups,\n\t.set_mux\t\t= atmel_pmx_set_mux,\n};\n\nstatic int atmel_conf_pin_config_group_get(struct pinctrl_dev *pctldev,\n\t\t\t\t\t   unsigned int group,\n\t\t\t\t\t   unsigned long *config)\n{\n\tstruct atmel_pioctrl *atmel_pioctrl = pinctrl_dev_get_drvdata(pctldev);\n\tunsigned int param = pinconf_to_config_param(*config), arg = 0;\n\tstruct atmel_group *grp = atmel_pioctrl->groups + group;\n\tunsigned int pin_id = grp->pin;\n\tu32 res;\n\n\tres = atmel_pin_config_read(pctldev, pin_id);\n\n\tswitch (param) {\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\tif (!(res & ATMEL_PIO_PUEN_MASK))\n\t\t\treturn -EINVAL;\n\t\targ = 1;\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\tif ((res & ATMEL_PIO_PUEN_MASK) ||\n\t\t    (!(res & ATMEL_PIO_PDEN_MASK)))\n\t\t\treturn -EINVAL;\n\t\targ = 1;\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\tif ((res & ATMEL_PIO_PUEN_MASK) ||\n\t\t    ((res & ATMEL_PIO_PDEN_MASK)))\n\t\t\treturn -EINVAL;\n\t\targ = 1;\n\t\tbreak;\n\tcase PIN_CONFIG_DRIVE_OPEN_DRAIN:\n\t\tif (!(res & ATMEL_PIO_OPD_MASK))\n\t\t\treturn -EINVAL;\n\t\targ = 1;\n\t\tbreak;\n\tcase PIN_CONFIG_DRIVE_PUSH_PULL:\n\t\tif (res & ATMEL_PIO_OPD_MASK)\n\t\t\treturn -EINVAL;\n\t\targ = 1;\n\t\tbreak;\n\tcase PIN_CONFIG_INPUT_SCHMITT_ENABLE:\n\t\tif (!(res & ATMEL_PIO_SCHMITT_MASK))\n\t\t\treturn -EINVAL;\n\t\targ = 1;\n\t\tbreak;\n\tcase PIN_CONFIG_SLEW_RATE:\n\t\tif (!atmel_pioctrl->slew_rate_support)\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (!(res & ATMEL_PIO_SR_MASK))\n\t\t\treturn -EINVAL;\n\t\targ = 1;\n\t\tbreak;\n\tcase ATMEL_PIN_CONFIG_DRIVE_STRENGTH:\n\t\tif (!(res & ATMEL_PIO_DRVSTR_MASK))\n\t\t\treturn -EINVAL;\n\t\targ = (res & ATMEL_PIO_DRVSTR_MASK) >> ATMEL_PIO_DRVSTR_OFFSET;\n\t\tbreak;\n\tcase PIN_CONFIG_PERSIST_STATE:\n\t\treturn -ENOTSUPP;\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\t*config = pinconf_to_config_packed(param, arg);\n\treturn 0;\n}\n\nstatic int atmel_conf_pin_config_group_set(struct pinctrl_dev *pctldev,\n\t\t\t\t\t   unsigned int group,\n\t\t\t\t\t   unsigned long *configs,\n\t\t\t\t\t   unsigned int num_configs)\n{\n\tstruct atmel_pioctrl *atmel_pioctrl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct atmel_group *grp = atmel_pioctrl->groups + group;\n\tunsigned int bank, pin, pin_id = grp->pin;\n\tu32 mask, conf = 0;\n\tint i;\n\n\tconf = atmel_pin_config_read(pctldev, pin_id);\n\n\t \n\tif (atmel_pioctrl->slew_rate_support)\n\t\tconf |= ATMEL_PIO_SR_MASK;\n\n\tfor (i = 0; i < num_configs; i++) {\n\t\tunsigned int param = pinconf_to_config_param(configs[i]);\n\t\tunsigned int arg = pinconf_to_config_argument(configs[i]);\n\n\t\tdev_dbg(pctldev->dev, \"%s: pin=%u, config=0x%lx\\n\",\n\t\t\t__func__, pin_id, configs[i]);\n\n\t\tswitch (param) {\n\t\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\t\tconf &= (~ATMEL_PIO_PUEN_MASK);\n\t\t\tconf &= (~ATMEL_PIO_PDEN_MASK);\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\t\tconf |= ATMEL_PIO_PUEN_MASK;\n\t\t\tconf &= (~ATMEL_PIO_PDEN_MASK);\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\t\tconf |= ATMEL_PIO_PDEN_MASK;\n\t\t\tconf &= (~ATMEL_PIO_PUEN_MASK);\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_DRIVE_OPEN_DRAIN:\n\t\t\tconf |= ATMEL_PIO_OPD_MASK;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_DRIVE_PUSH_PULL:\n\t\t\tconf &= ~ATMEL_PIO_OPD_MASK;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_INPUT_SCHMITT_ENABLE:\n\t\t\tif (arg == 0)\n\t\t\t\tconf |= ATMEL_PIO_SCHMITT_MASK;\n\t\t\telse\n\t\t\t\tconf &= (~ATMEL_PIO_SCHMITT_MASK);\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_INPUT_DEBOUNCE:\n\t\t\tif (arg == 0) {\n\t\t\t\tconf &= (~ATMEL_PIO_IFEN_MASK);\n\t\t\t\tconf &= (~ATMEL_PIO_IFSCEN_MASK);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tconf |= ATMEL_PIO_IFEN_MASK;\n\t\t\t\tconf |= ATMEL_PIO_IFSCEN_MASK;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_OUTPUT:\n\t\t\tconf |= ATMEL_PIO_DIR_MASK;\n\t\t\tbank = ATMEL_PIO_BANK(pin_id);\n\t\t\tpin = ATMEL_PIO_LINE(pin_id);\n\t\t\tmask = 1 << pin;\n\n\t\t\tif (arg == 0) {\n\t\t\t\twritel_relaxed(mask, atmel_pioctrl->reg_base +\n\t\t\t\t\tbank * ATMEL_PIO_BANK_OFFSET +\n\t\t\t\t\tATMEL_PIO_CODR);\n\t\t\t} else {\n\t\t\t\twritel_relaxed(mask, atmel_pioctrl->reg_base +\n\t\t\t\t\tbank * ATMEL_PIO_BANK_OFFSET +\n\t\t\t\t\tATMEL_PIO_SODR);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_SLEW_RATE:\n\t\t\tif (!atmel_pioctrl->slew_rate_support)\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tif (arg == 0)\n\t\t\t\tconf &= ~ATMEL_PIO_SR_MASK;\n\t\t\tbreak;\n\t\tcase ATMEL_PIN_CONFIG_DRIVE_STRENGTH:\n\t\t\tswitch (arg) {\n\t\t\tcase ATMEL_PIO_DRVSTR_LO:\n\t\t\tcase ATMEL_PIO_DRVSTR_ME:\n\t\t\tcase ATMEL_PIO_DRVSTR_HI:\n\t\t\t\tconf &= (~ATMEL_PIO_DRVSTR_MASK);\n\t\t\t\tconf |= arg << ATMEL_PIO_DRVSTR_OFFSET;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdev_warn(pctldev->dev, \"drive strength not updated (incorrect value)\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_PERSIST_STATE:\n\t\t\treturn -ENOTSUPP;\n\t\tdefault:\n\t\t\tdev_warn(pctldev->dev,\n\t\t\t\t \"unsupported configuration parameter: %u\\n\",\n\t\t\t\t param);\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tdev_dbg(pctldev->dev, \"%s: reg=0x%08x\\n\", __func__, conf);\n\tatmel_pin_config_write(pctldev, pin_id, conf);\n\n\treturn 0;\n}\n\nstatic int atmel_conf_pin_config_set(struct pinctrl_dev *pctldev,\n\t\t\t\t     unsigned pin,\n\t\t\t\t     unsigned long *configs,\n\t\t\t\t     unsigned num_configs)\n{\n\tstruct atmel_group *grp = atmel_pctl_find_group_by_pin(pctldev, pin);\n\n\treturn atmel_conf_pin_config_group_set(pctldev, grp->pin, configs, num_configs);\n}\n\nstatic int atmel_conf_pin_config_get(struct pinctrl_dev *pctldev,\n\t\t\t\t     unsigned pin,\n\t\t\t\t     unsigned long *configs)\n{\n\tstruct atmel_group *grp = atmel_pctl_find_group_by_pin(pctldev, pin);\n\n\treturn atmel_conf_pin_config_group_get(pctldev, grp->pin, configs);\n}\n\nstatic void atmel_conf_pin_config_dbg_show(struct pinctrl_dev *pctldev,\n\t\t\t\t\t   struct seq_file *s,\n\t\t\t\t\t   unsigned int pin_id)\n{\n\tstruct atmel_pioctrl *atmel_pioctrl = pinctrl_dev_get_drvdata(pctldev);\n\tu32 conf;\n\n\tif (!atmel_pioctrl->pins[pin_id]->device)\n\t\treturn;\n\n\tseq_printf(s, \" (%s, ioset %u) \",\n\t\t   atmel_pioctrl->pins[pin_id]->device,\n\t\t   atmel_pioctrl->pins[pin_id]->ioset);\n\n\tconf = atmel_pin_config_read(pctldev, pin_id);\n\tif (conf & ATMEL_PIO_PUEN_MASK)\n\t\tseq_printf(s, \"%s \", \"pull-up\");\n\tif (conf & ATMEL_PIO_PDEN_MASK)\n\t\tseq_printf(s, \"%s \", \"pull-down\");\n\tif (conf & ATMEL_PIO_IFEN_MASK)\n\t\tseq_printf(s, \"%s \", \"debounce\");\n\tif (conf & ATMEL_PIO_OPD_MASK)\n\t\tseq_printf(s, \"%s \", \"open-drain\");\n\telse\n\t\tseq_printf(s, \"%s \", \"push-pull\");\n\tif (conf & ATMEL_PIO_SCHMITT_MASK)\n\t\tseq_printf(s, \"%s \", \"schmitt\");\n\tif (atmel_pioctrl->slew_rate_support && (conf & ATMEL_PIO_SR_MASK))\n\t\tseq_printf(s, \"%s \", \"slew-rate\");\n\tif (conf & ATMEL_PIO_DRVSTR_MASK) {\n\t\tswitch ((conf & ATMEL_PIO_DRVSTR_MASK) >> ATMEL_PIO_DRVSTR_OFFSET) {\n\t\tcase ATMEL_PIO_DRVSTR_ME:\n\t\t\tseq_printf(s, \"%s \", \"medium-drive\");\n\t\t\tbreak;\n\t\tcase ATMEL_PIO_DRVSTR_HI:\n\t\t\tseq_printf(s, \"%s \", \"high-drive\");\n\t\t\tbreak;\n\t\t \n\t\tdefault:\n\t\t\tseq_printf(s, \"%s \", \"low-drive\");\n\t\t}\n\t}\n}\n\nstatic const struct pinconf_ops atmel_confops = {\n\t.pin_config_group_get\t= atmel_conf_pin_config_group_get,\n\t.pin_config_group_set\t= atmel_conf_pin_config_group_set,\n\t.pin_config_dbg_show\t= atmel_conf_pin_config_dbg_show,\n\t.pin_config_set\t        = atmel_conf_pin_config_set,\n\t.pin_config_get\t        = atmel_conf_pin_config_get,\n};\n\nstatic struct pinctrl_desc atmel_pinctrl_desc = {\n\t.name\t\t= \"atmel_pinctrl\",\n\t.confops\t= &atmel_confops,\n\t.pctlops\t= &atmel_pctlops,\n\t.pmxops\t\t= &atmel_pmxops,\n};\n\nstatic int __maybe_unused atmel_pctrl_suspend(struct device *dev)\n{\n\tstruct atmel_pioctrl *atmel_pioctrl = dev_get_drvdata(dev);\n\tint i, j;\n\n\t \n\tfor (i = 0; i < atmel_pioctrl->nbanks; i++) {\n\t\tatmel_pioctrl->pm_suspend_backup[i].imr =\n\t\t\tatmel_gpio_read(atmel_pioctrl, i, ATMEL_PIO_IMR);\n\t\tatmel_gpio_write(atmel_pioctrl, i, ATMEL_PIO_IDR,\n\t\t\t\t ~atmel_pioctrl->pm_wakeup_sources[i]);\n\t\tatmel_pioctrl->pm_suspend_backup[i].odsr =\n\t\t\tatmel_gpio_read(atmel_pioctrl, i, ATMEL_PIO_ODSR);\n\t\tfor (j = 0; j < ATMEL_PIO_NPINS_PER_BANK; j++) {\n\t\t\tatmel_gpio_write(atmel_pioctrl, i,\n\t\t\t\t\t ATMEL_PIO_MSKR, BIT(j));\n\t\t\tatmel_pioctrl->pm_suspend_backup[i].cfgr[j] =\n\t\t\t\tatmel_gpio_read(atmel_pioctrl, i,\n\t\t\t\t\t\tATMEL_PIO_CFGR);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused atmel_pctrl_resume(struct device *dev)\n{\n\tstruct atmel_pioctrl *atmel_pioctrl = dev_get_drvdata(dev);\n\tint i, j;\n\n\tfor (i = 0; i < atmel_pioctrl->nbanks; i++) {\n\t\tatmel_gpio_write(atmel_pioctrl, i, ATMEL_PIO_IER,\n\t\t\t\t atmel_pioctrl->pm_suspend_backup[i].imr);\n\t\tatmel_gpio_write(atmel_pioctrl, i, ATMEL_PIO_SODR,\n\t\t\t\t atmel_pioctrl->pm_suspend_backup[i].odsr);\n\t\tfor (j = 0; j < ATMEL_PIO_NPINS_PER_BANK; j++) {\n\t\t\tatmel_gpio_write(atmel_pioctrl, i,\n\t\t\t\t\t ATMEL_PIO_MSKR, BIT(j));\n\t\t\tatmel_gpio_write(atmel_pioctrl, i, ATMEL_PIO_CFGR,\n\t\t\t\t\t atmel_pioctrl->pm_suspend_backup[i].cfgr[j]);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops atmel_pctrl_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(atmel_pctrl_suspend, atmel_pctrl_resume)\n};\n\n \nstatic const struct atmel_pioctrl_data atmel_sama5d2_pioctrl_data = {\n\t.nbanks\t\t\t= 4,\n\t.last_bank_count\t= ATMEL_PIO_NPINS_PER_BANK,\n};\n\nstatic const struct atmel_pioctrl_data microchip_sama7g5_pioctrl_data = {\n\t.nbanks\t\t\t= 5,\n\t.last_bank_count\t= 8,  \n\t.slew_rate_support\t= 1,\n};\n\nstatic const struct of_device_id atmel_pctrl_of_match[] = {\n\t{\n\t\t.compatible = \"atmel,sama5d2-pinctrl\",\n\t\t.data = &atmel_sama5d2_pioctrl_data,\n\t}, {\n\t\t.compatible = \"microchip,sama7g5-pinctrl\",\n\t\t.data = &microchip_sama7g5_pioctrl_data,\n\t}, {\n\t\t \n\t}\n};\n\n \nstatic struct lock_class_key atmel_lock_key;\nstatic struct lock_class_key atmel_request_key;\n\nstatic int atmel_pinctrl_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct pinctrl_pin_desc\t*pin_desc;\n\tconst char **group_names;\n\tint i, ret;\n\tstruct atmel_pioctrl *atmel_pioctrl;\n\tconst struct atmel_pioctrl_data *atmel_pioctrl_data;\n\n\tatmel_pioctrl = devm_kzalloc(dev, sizeof(*atmel_pioctrl), GFP_KERNEL);\n\tif (!atmel_pioctrl)\n\t\treturn -ENOMEM;\n\tatmel_pioctrl->dev = dev;\n\tatmel_pioctrl->node = dev->of_node;\n\tplatform_set_drvdata(pdev, atmel_pioctrl);\n\n\tatmel_pioctrl_data = device_get_match_data(dev);\n\tif (!atmel_pioctrl_data)\n\t\treturn dev_err_probe(dev, -ENODEV, \"Invalid device data\\n\");\n\n\tatmel_pioctrl->nbanks = atmel_pioctrl_data->nbanks;\n\tatmel_pioctrl->npins = atmel_pioctrl->nbanks * ATMEL_PIO_NPINS_PER_BANK;\n\t \n\tif (atmel_pioctrl_data->last_bank_count != ATMEL_PIO_NPINS_PER_BANK) {\n\t\tatmel_pioctrl->npins -= ATMEL_PIO_NPINS_PER_BANK;\n\t\tatmel_pioctrl->npins += atmel_pioctrl_data->last_bank_count;\n\t}\n\tatmel_pioctrl->slew_rate_support = atmel_pioctrl_data->slew_rate_support;\n\n\tatmel_pioctrl->reg_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(atmel_pioctrl->reg_base))\n\t\treturn PTR_ERR(atmel_pioctrl->reg_base);\n\n\tatmel_pioctrl->clk = devm_clk_get_enabled(dev, NULL);\n\tif (IS_ERR(atmel_pioctrl->clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(atmel_pioctrl->clk), \"failed to get clock\\n\");\n\n\tatmel_pioctrl->pins = devm_kcalloc(dev,\n\t\t\t\t\t   atmel_pioctrl->npins,\n\t\t\t\t\t   sizeof(*atmel_pioctrl->pins),\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!atmel_pioctrl->pins)\n\t\treturn -ENOMEM;\n\n\tpin_desc = devm_kcalloc(dev, atmel_pioctrl->npins, sizeof(*pin_desc),\n\t\t\t\tGFP_KERNEL);\n\tif (!pin_desc)\n\t\treturn -ENOMEM;\n\tatmel_pinctrl_desc.pins = pin_desc;\n\tatmel_pinctrl_desc.npins = atmel_pioctrl->npins;\n\tatmel_pinctrl_desc.num_custom_params = ARRAY_SIZE(atmel_custom_bindings);\n\tatmel_pinctrl_desc.custom_params = atmel_custom_bindings;\n\n\t \n\tgroup_names = devm_kcalloc(dev,\n\t\t\t\t   atmel_pioctrl->npins, sizeof(*group_names),\n\t\t\t\t   GFP_KERNEL);\n\tif (!group_names)\n\t\treturn -ENOMEM;\n\tatmel_pioctrl->group_names = group_names;\n\n\tatmel_pioctrl->groups = devm_kcalloc(&pdev->dev,\n\t\t\tatmel_pioctrl->npins, sizeof(*atmel_pioctrl->groups),\n\t\t\tGFP_KERNEL);\n\tif (!atmel_pioctrl->groups)\n\t\treturn -ENOMEM;\n\tfor (i = 0 ; i < atmel_pioctrl->npins; i++) {\n\t\tstruct atmel_group *group = atmel_pioctrl->groups + i;\n\t\tunsigned int bank = ATMEL_PIO_BANK(i);\n\t\tunsigned int line = ATMEL_PIO_LINE(i);\n\n\t\tatmel_pioctrl->pins[i] = devm_kzalloc(dev,\n\t\t\t\tsizeof(**atmel_pioctrl->pins), GFP_KERNEL);\n\t\tif (!atmel_pioctrl->pins[i])\n\t\t\treturn -ENOMEM;\n\n\t\tatmel_pioctrl->pins[i]->pin_id = i;\n\t\tatmel_pioctrl->pins[i]->bank = bank;\n\t\tatmel_pioctrl->pins[i]->line = line;\n\n\t\tpin_desc[i].number = i;\n\t\t \n\t\tpin_desc[i].name = devm_kasprintf(&pdev->dev, GFP_KERNEL, \"P%c%u\",\n\t\t\t\t\t\t  bank + 'A', line);\n\t\tif (!pin_desc[i].name)\n\t\t\treturn -ENOMEM;\n\n\t\tgroup->name = group_names[i] = pin_desc[i].name;\n\t\tgroup->pin = pin_desc[i].number;\n\n\t\tdev_dbg(dev, \"pin_id=%u, bank=%u, line=%u\", i, bank, line);\n\t}\n\n\tatmel_pioctrl->gpio_chip = &atmel_gpio_chip;\n\tatmel_pioctrl->gpio_chip->ngpio = atmel_pioctrl->npins;\n\tatmel_pioctrl->gpio_chip->label = dev_name(dev);\n\tatmel_pioctrl->gpio_chip->parent = dev;\n\tatmel_pioctrl->gpio_chip->names = atmel_pioctrl->group_names;\n\tatmel_pioctrl->gpio_chip->set_config = gpiochip_generic_config;\n\n\tatmel_pioctrl->pm_wakeup_sources = devm_kcalloc(dev,\n\t\t\tatmel_pioctrl->nbanks,\n\t\t\tsizeof(*atmel_pioctrl->pm_wakeup_sources),\n\t\t\tGFP_KERNEL);\n\tif (!atmel_pioctrl->pm_wakeup_sources)\n\t\treturn -ENOMEM;\n\n\tatmel_pioctrl->pm_suspend_backup = devm_kcalloc(dev,\n\t\t\tatmel_pioctrl->nbanks,\n\t\t\tsizeof(*atmel_pioctrl->pm_suspend_backup),\n\t\t\tGFP_KERNEL);\n\tif (!atmel_pioctrl->pm_suspend_backup)\n\t\treturn -ENOMEM;\n\n\tatmel_pioctrl->irqs = devm_kcalloc(dev,\n\t\t\t\t\t   atmel_pioctrl->nbanks,\n\t\t\t\t\t   sizeof(*atmel_pioctrl->irqs),\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!atmel_pioctrl->irqs)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = 0; i < atmel_pioctrl->nbanks; i++) {\n\t\tret = platform_get_irq(pdev, i);\n\t\tif (ret < 0) {\n\t\t\tdev_dbg(dev, \"missing irq resource for group %c\\n\",\n\t\t\t\t'A' + i);\n\t\t\treturn ret;\n\t\t}\n\t\tatmel_pioctrl->irqs[i] = ret;\n\t\tirq_set_chained_handler_and_data(ret, atmel_gpio_irq_handler, atmel_pioctrl);\n\t\tdev_dbg(dev, \"bank %i: irq=%d\\n\", i, ret);\n\t}\n\n\tatmel_pioctrl->irq_domain = irq_domain_add_linear(dev->of_node,\n\t\t\tatmel_pioctrl->gpio_chip->ngpio,\n\t\t\t&irq_domain_simple_ops, NULL);\n\tif (!atmel_pioctrl->irq_domain)\n\t\treturn dev_err_probe(dev, -ENODEV, \"can't add the irq domain\\n\");\n\n\tfor (i = 0; i < atmel_pioctrl->npins; i++) {\n\t\tint irq = irq_create_mapping(atmel_pioctrl->irq_domain, i);\n\n\t\tirq_set_chip_and_handler(irq, &atmel_gpio_irq_chip,\n\t\t\t\t\t handle_simple_irq);\n\t\tirq_set_chip_data(irq, atmel_pioctrl);\n\t\tirq_set_lockdep_class(irq, &atmel_lock_key, &atmel_request_key);\n\t\tdev_dbg(dev,\n\t\t\t\"atmel gpio irq domain: hwirq: %d, linux irq: %d\\n\",\n\t\t\ti, irq);\n\t}\n\n\tatmel_pioctrl->pinctrl_dev = devm_pinctrl_register(&pdev->dev,\n\t\t\t\t\t\t\t   &atmel_pinctrl_desc,\n\t\t\t\t\t\t\t   atmel_pioctrl);\n\tif (IS_ERR(atmel_pioctrl->pinctrl_dev)) {\n\t\tret = PTR_ERR(atmel_pioctrl->pinctrl_dev);\n\t\tdev_err(dev, \"pinctrl registration failed\\n\");\n\t\tgoto irq_domain_remove_error;\n\t}\n\n\tret = gpiochip_add_data(atmel_pioctrl->gpio_chip, atmel_pioctrl);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to add gpiochip\\n\");\n\t\tgoto irq_domain_remove_error;\n\t}\n\n\tret = gpiochip_add_pin_range(atmel_pioctrl->gpio_chip, dev_name(dev),\n\t\t\t\t     0, 0, atmel_pioctrl->gpio_chip->ngpio);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to add gpio pin range\\n\");\n\t\tgoto gpiochip_add_pin_range_error;\n\t}\n\n\tdev_info(&pdev->dev, \"atmel pinctrl initialized\\n\");\n\n\treturn 0;\n\ngpiochip_add_pin_range_error:\n\tgpiochip_remove(atmel_pioctrl->gpio_chip);\n\nirq_domain_remove_error:\n\tirq_domain_remove(atmel_pioctrl->irq_domain);\n\n\treturn ret;\n}\n\nstatic struct platform_driver atmel_pinctrl_driver = {\n\t.driver = {\n\t\t.name = \"pinctrl-at91-pio4\",\n\t\t.of_match_table = atmel_pctrl_of_match,\n\t\t.pm = &atmel_pctrl_pm_ops,\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe = atmel_pinctrl_probe,\n};\nbuiltin_platform_driver(atmel_pinctrl_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}