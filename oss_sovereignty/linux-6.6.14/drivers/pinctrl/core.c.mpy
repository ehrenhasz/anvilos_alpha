{
  "module_name": "core.c",
  "hash_id": "768d4a95d0a37cce0a6eca87f4c2c252f67fcaa0ed0ccb2eeb92bcc88bc4e67a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/core.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) \"pinctrl core: \" fmt\n\n#include <linux/debugfs.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/list.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n\n#include <linux/pinctrl/consumer.h>\n#include <linux/pinctrl/devinfo.h>\n#include <linux/pinctrl/machine.h>\n#include <linux/pinctrl/pinctrl.h>\n\n#ifdef CONFIG_GPIOLIB\n#include \"../gpio/gpiolib.h\"\n#endif\n\n#include \"core.h\"\n#include \"devicetree.h\"\n#include \"pinconf.h\"\n#include \"pinmux.h\"\n\nstatic bool pinctrl_dummy_state;\n\n \nstatic DEFINE_MUTEX(pinctrl_list_mutex);\n\n \nDEFINE_MUTEX(pinctrl_maps_mutex);\n\n \nstatic DEFINE_MUTEX(pinctrldev_list_mutex);\n\n \nstatic LIST_HEAD(pinctrldev_list);\n\n \nstatic LIST_HEAD(pinctrl_list);\n\n \nLIST_HEAD(pinctrl_maps);\n\n\n \nvoid pinctrl_provide_dummies(void)\n{\n\tpinctrl_dummy_state = true;\n}\n\nconst char *pinctrl_dev_get_name(struct pinctrl_dev *pctldev)\n{\n\t \n\treturn pctldev->desc->name;\n}\nEXPORT_SYMBOL_GPL(pinctrl_dev_get_name);\n\nconst char *pinctrl_dev_get_devname(struct pinctrl_dev *pctldev)\n{\n\treturn dev_name(pctldev->dev);\n}\nEXPORT_SYMBOL_GPL(pinctrl_dev_get_devname);\n\nvoid *pinctrl_dev_get_drvdata(struct pinctrl_dev *pctldev)\n{\n\treturn pctldev->driver_data;\n}\nEXPORT_SYMBOL_GPL(pinctrl_dev_get_drvdata);\n\n \nstruct pinctrl_dev *get_pinctrl_dev_from_devname(const char *devname)\n{\n\tstruct pinctrl_dev *pctldev;\n\n\tif (!devname)\n\t\treturn NULL;\n\n\tmutex_lock(&pinctrldev_list_mutex);\n\n\tlist_for_each_entry(pctldev, &pinctrldev_list, node) {\n\t\tif (!strcmp(dev_name(pctldev->dev), devname)) {\n\t\t\t \n\t\t\tmutex_unlock(&pinctrldev_list_mutex);\n\t\t\treturn pctldev;\n\t\t}\n\t}\n\n\tmutex_unlock(&pinctrldev_list_mutex);\n\n\treturn NULL;\n}\n\nstruct pinctrl_dev *get_pinctrl_dev_from_of_node(struct device_node *np)\n{\n\tstruct pinctrl_dev *pctldev;\n\n\tmutex_lock(&pinctrldev_list_mutex);\n\n\tlist_for_each_entry(pctldev, &pinctrldev_list, node)\n\t\tif (device_match_of_node(pctldev->dev, np)) {\n\t\t\tmutex_unlock(&pinctrldev_list_mutex);\n\t\t\treturn pctldev;\n\t\t}\n\n\tmutex_unlock(&pinctrldev_list_mutex);\n\n\treturn NULL;\n}\n\n \nint pin_get_from_name(struct pinctrl_dev *pctldev, const char *name)\n{\n\tunsigned i, pin;\n\n\t \n\tfor (i = 0; i < pctldev->desc->npins; i++) {\n\t\tstruct pin_desc *desc;\n\n\t\tpin = pctldev->desc->pins[i].number;\n\t\tdesc = pin_desc_get(pctldev, pin);\n\t\t \n\t\tif (desc && !strcmp(name, desc->name))\n\t\t\treturn pin;\n\t}\n\n\treturn -EINVAL;\n}\n\n \nconst char *pin_get_name(struct pinctrl_dev *pctldev, const unsigned pin)\n{\n\tconst struct pin_desc *desc;\n\n\tdesc = pin_desc_get(pctldev, pin);\n\tif (!desc) {\n\t\tdev_err(pctldev->dev, \"failed to get pin(%d) name\\n\",\n\t\t\tpin);\n\t\treturn NULL;\n\t}\n\n\treturn desc->name;\n}\nEXPORT_SYMBOL_GPL(pin_get_name);\n\n \nstatic void pinctrl_free_pindescs(struct pinctrl_dev *pctldev,\n\t\t\t\t  const struct pinctrl_pin_desc *pins,\n\t\t\t\t  unsigned num_pins)\n{\n\tint i;\n\n\tfor (i = 0; i < num_pins; i++) {\n\t\tstruct pin_desc *pindesc;\n\n\t\tpindesc = radix_tree_lookup(&pctldev->pin_desc_tree,\n\t\t\t\t\t    pins[i].number);\n\t\tif (pindesc) {\n\t\t\tradix_tree_delete(&pctldev->pin_desc_tree,\n\t\t\t\t\t  pins[i].number);\n\t\t\tif (pindesc->dynamic_name)\n\t\t\t\tkfree(pindesc->name);\n\t\t}\n\t\tkfree(pindesc);\n\t}\n}\n\nstatic int pinctrl_register_one_pin(struct pinctrl_dev *pctldev,\n\t\t\t\t    const struct pinctrl_pin_desc *pin)\n{\n\tstruct pin_desc *pindesc;\n\tint error;\n\n\tpindesc = pin_desc_get(pctldev, pin->number);\n\tif (pindesc) {\n\t\tdev_err(pctldev->dev, \"pin %d already registered\\n\",\n\t\t\tpin->number);\n\t\treturn -EINVAL;\n\t}\n\n\tpindesc = kzalloc(sizeof(*pindesc), GFP_KERNEL);\n\tif (!pindesc)\n\t\treturn -ENOMEM;\n\n\t \n\tpindesc->pctldev = pctldev;\n\n\t \n\tif (pin->name) {\n\t\tpindesc->name = pin->name;\n\t} else {\n\t\tpindesc->name = kasprintf(GFP_KERNEL, \"PIN%u\", pin->number);\n\t\tif (!pindesc->name) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto failed;\n\t\t}\n\t\tpindesc->dynamic_name = true;\n\t}\n\n\tpindesc->drv_data = pin->drv_data;\n\n\terror = radix_tree_insert(&pctldev->pin_desc_tree, pin->number, pindesc);\n\tif (error)\n\t\tgoto failed;\n\n\tpr_debug(\"registered pin %d (%s) on %s\\n\",\n\t\t pin->number, pindesc->name, pctldev->desc->name);\n\treturn 0;\n\nfailed:\n\tkfree(pindesc);\n\treturn error;\n}\n\nstatic int pinctrl_register_pins(struct pinctrl_dev *pctldev,\n\t\t\t\t const struct pinctrl_pin_desc *pins,\n\t\t\t\t unsigned num_descs)\n{\n\tunsigned i;\n\tint ret = 0;\n\n\tfor (i = 0; i < num_descs; i++) {\n\t\tret = pinctrl_register_one_pin(pctldev, &pins[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic inline int gpio_to_pin(struct pinctrl_gpio_range *range,\n\t\t\t\tunsigned int gpio)\n{\n\tunsigned int offset = gpio - range->base;\n\tif (range->pins)\n\t\treturn range->pins[offset];\n\telse\n\t\treturn range->pin_base + offset;\n}\n\n \nstatic struct pinctrl_gpio_range *\npinctrl_match_gpio_range(struct pinctrl_dev *pctldev, unsigned gpio)\n{\n\tstruct pinctrl_gpio_range *range;\n\n\tmutex_lock(&pctldev->mutex);\n\t \n\tlist_for_each_entry(range, &pctldev->gpio_ranges, node) {\n\t\t \n\t\tif (gpio >= range->base &&\n\t\t    gpio < range->base + range->npins) {\n\t\t\tmutex_unlock(&pctldev->mutex);\n\t\t\treturn range;\n\t\t}\n\t}\n\tmutex_unlock(&pctldev->mutex);\n\treturn NULL;\n}\n\n \n#ifdef CONFIG_GPIOLIB\nstatic bool pinctrl_ready_for_gpio_range(unsigned gpio)\n{\n\tstruct pinctrl_dev *pctldev;\n\tstruct pinctrl_gpio_range *range = NULL;\n\t \n\tstruct gpio_chip *chip = gpiod_to_chip(gpio_to_desc(gpio));\n\n\tif (WARN(!chip, \"no gpio_chip for gpio%i?\", gpio))\n\t\treturn false;\n\n\tmutex_lock(&pinctrldev_list_mutex);\n\n\t \n\tlist_for_each_entry(pctldev, &pinctrldev_list, node) {\n\t\t \n\t\tmutex_lock(&pctldev->mutex);\n\t\tlist_for_each_entry(range, &pctldev->gpio_ranges, node) {\n\t\t\t \n\t\t\tif (range->base + range->npins - 1 < chip->base ||\n\t\t\t    range->base > chip->base + chip->ngpio - 1)\n\t\t\t\tcontinue;\n\t\t\tmutex_unlock(&pctldev->mutex);\n\t\t\tmutex_unlock(&pinctrldev_list_mutex);\n\t\t\treturn true;\n\t\t}\n\t\tmutex_unlock(&pctldev->mutex);\n\t}\n\n\tmutex_unlock(&pinctrldev_list_mutex);\n\n\treturn false;\n}\n#else\nstatic bool pinctrl_ready_for_gpio_range(unsigned gpio) { return true; }\n#endif\n\n \nstatic int pinctrl_get_device_gpio_range(unsigned gpio,\n\t\t\t\t\t struct pinctrl_dev **outdev,\n\t\t\t\t\t struct pinctrl_gpio_range **outrange)\n{\n\tstruct pinctrl_dev *pctldev;\n\n\tmutex_lock(&pinctrldev_list_mutex);\n\n\t \n\tlist_for_each_entry(pctldev, &pinctrldev_list, node) {\n\t\tstruct pinctrl_gpio_range *range;\n\n\t\trange = pinctrl_match_gpio_range(pctldev, gpio);\n\t\tif (range) {\n\t\t\t*outdev = pctldev;\n\t\t\t*outrange = range;\n\t\t\tmutex_unlock(&pinctrldev_list_mutex);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tmutex_unlock(&pinctrldev_list_mutex);\n\n\treturn -EPROBE_DEFER;\n}\n\n \nvoid pinctrl_add_gpio_range(struct pinctrl_dev *pctldev,\n\t\t\t    struct pinctrl_gpio_range *range)\n{\n\tmutex_lock(&pctldev->mutex);\n\tlist_add_tail(&range->node, &pctldev->gpio_ranges);\n\tmutex_unlock(&pctldev->mutex);\n}\nEXPORT_SYMBOL_GPL(pinctrl_add_gpio_range);\n\nvoid pinctrl_add_gpio_ranges(struct pinctrl_dev *pctldev,\n\t\t\t     struct pinctrl_gpio_range *ranges,\n\t\t\t     unsigned nranges)\n{\n\tint i;\n\n\tfor (i = 0; i < nranges; i++)\n\t\tpinctrl_add_gpio_range(pctldev, &ranges[i]);\n}\nEXPORT_SYMBOL_GPL(pinctrl_add_gpio_ranges);\n\nstruct pinctrl_dev *pinctrl_find_and_add_gpio_range(const char *devname,\n\t\tstruct pinctrl_gpio_range *range)\n{\n\tstruct pinctrl_dev *pctldev;\n\n\tpctldev = get_pinctrl_dev_from_devname(devname);\n\n\t \n\tif (!pctldev) {\n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\t}\n\tpinctrl_add_gpio_range(pctldev, range);\n\n\treturn pctldev;\n}\nEXPORT_SYMBOL_GPL(pinctrl_find_and_add_gpio_range);\n\nint pinctrl_get_group_pins(struct pinctrl_dev *pctldev, const char *pin_group,\n\t\t\t\tconst unsigned **pins, unsigned *num_pins)\n{\n\tconst struct pinctrl_ops *pctlops = pctldev->desc->pctlops;\n\tint gs;\n\n\tif (!pctlops->get_group_pins)\n\t\treturn -EINVAL;\n\n\tgs = pinctrl_get_group_selector(pctldev, pin_group);\n\tif (gs < 0)\n\t\treturn gs;\n\n\treturn pctlops->get_group_pins(pctldev, gs, pins, num_pins);\n}\nEXPORT_SYMBOL_GPL(pinctrl_get_group_pins);\n\nstruct pinctrl_gpio_range *\npinctrl_find_gpio_range_from_pin_nolock(struct pinctrl_dev *pctldev,\n\t\t\t\t\tunsigned int pin)\n{\n\tstruct pinctrl_gpio_range *range;\n\n\t \n\tlist_for_each_entry(range, &pctldev->gpio_ranges, node) {\n\t\t \n\t\tif (range->pins) {\n\t\t\tint a;\n\t\t\tfor (a = 0; a < range->npins; a++) {\n\t\t\t\tif (range->pins[a] == pin)\n\t\t\t\t\treturn range;\n\t\t\t}\n\t\t} else if (pin >= range->pin_base &&\n\t\t\t   pin < range->pin_base + range->npins)\n\t\t\treturn range;\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(pinctrl_find_gpio_range_from_pin_nolock);\n\n \nstruct pinctrl_gpio_range *\npinctrl_find_gpio_range_from_pin(struct pinctrl_dev *pctldev,\n\t\t\t\t unsigned int pin)\n{\n\tstruct pinctrl_gpio_range *range;\n\n\tmutex_lock(&pctldev->mutex);\n\trange = pinctrl_find_gpio_range_from_pin_nolock(pctldev, pin);\n\tmutex_unlock(&pctldev->mutex);\n\n\treturn range;\n}\nEXPORT_SYMBOL_GPL(pinctrl_find_gpio_range_from_pin);\n\n \nvoid pinctrl_remove_gpio_range(struct pinctrl_dev *pctldev,\n\t\t\t       struct pinctrl_gpio_range *range)\n{\n\tmutex_lock(&pctldev->mutex);\n\tlist_del(&range->node);\n\tmutex_unlock(&pctldev->mutex);\n}\nEXPORT_SYMBOL_GPL(pinctrl_remove_gpio_range);\n\n#ifdef CONFIG_GENERIC_PINCTRL_GROUPS\n\n \nint pinctrl_generic_get_group_count(struct pinctrl_dev *pctldev)\n{\n\treturn pctldev->num_groups;\n}\nEXPORT_SYMBOL_GPL(pinctrl_generic_get_group_count);\n\n \nconst char *pinctrl_generic_get_group_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t   unsigned int selector)\n{\n\tstruct group_desc *group;\n\n\tgroup = radix_tree_lookup(&pctldev->pin_group_tree,\n\t\t\t\t  selector);\n\tif (!group)\n\t\treturn NULL;\n\n\treturn group->name;\n}\nEXPORT_SYMBOL_GPL(pinctrl_generic_get_group_name);\n\n \nint pinctrl_generic_get_group_pins(struct pinctrl_dev *pctldev,\n\t\t\t\t   unsigned int selector,\n\t\t\t\t   const unsigned int **pins,\n\t\t\t\t   unsigned int *num_pins)\n{\n\tstruct group_desc *group;\n\n\tgroup = radix_tree_lookup(&pctldev->pin_group_tree,\n\t\t\t\t  selector);\n\tif (!group) {\n\t\tdev_err(pctldev->dev, \"%s could not find pingroup%i\\n\",\n\t\t\t__func__, selector);\n\t\treturn -EINVAL;\n\t}\n\n\t*pins = group->pins;\n\t*num_pins = group->num_pins;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(pinctrl_generic_get_group_pins);\n\n \nstruct group_desc *pinctrl_generic_get_group(struct pinctrl_dev *pctldev,\n\t\t\t\t\t     unsigned int selector)\n{\n\tstruct group_desc *group;\n\n\tgroup = radix_tree_lookup(&pctldev->pin_group_tree,\n\t\t\t\t  selector);\n\tif (!group)\n\t\treturn NULL;\n\n\treturn group;\n}\nEXPORT_SYMBOL_GPL(pinctrl_generic_get_group);\n\nstatic int pinctrl_generic_group_name_to_selector(struct pinctrl_dev *pctldev,\n\t\t\t\t\t\t  const char *function)\n{\n\tconst struct pinctrl_ops *ops = pctldev->desc->pctlops;\n\tint ngroups = ops->get_groups_count(pctldev);\n\tint selector = 0;\n\n\t \n\twhile (selector < ngroups) {\n\t\tconst char *gname = ops->get_group_name(pctldev, selector);\n\n\t\tif (gname && !strcmp(function, gname))\n\t\t\treturn selector;\n\n\t\tselector++;\n\t}\n\n\treturn -EINVAL;\n}\n\n \nint pinctrl_generic_add_group(struct pinctrl_dev *pctldev, const char *name,\n\t\t\t      int *pins, int num_pins, void *data)\n{\n\tstruct group_desc *group;\n\tint selector, error;\n\n\tif (!name)\n\t\treturn -EINVAL;\n\n\tselector = pinctrl_generic_group_name_to_selector(pctldev, name);\n\tif (selector >= 0)\n\t\treturn selector;\n\n\tselector = pctldev->num_groups;\n\n\tgroup = devm_kzalloc(pctldev->dev, sizeof(*group), GFP_KERNEL);\n\tif (!group)\n\t\treturn -ENOMEM;\n\n\tgroup->name = name;\n\tgroup->pins = pins;\n\tgroup->num_pins = num_pins;\n\tgroup->data = data;\n\n\terror = radix_tree_insert(&pctldev->pin_group_tree, selector, group);\n\tif (error)\n\t\treturn error;\n\n\tpctldev->num_groups++;\n\n\treturn selector;\n}\nEXPORT_SYMBOL_GPL(pinctrl_generic_add_group);\n\n \nint pinctrl_generic_remove_group(struct pinctrl_dev *pctldev,\n\t\t\t\t unsigned int selector)\n{\n\tstruct group_desc *group;\n\n\tgroup = radix_tree_lookup(&pctldev->pin_group_tree,\n\t\t\t\t  selector);\n\tif (!group)\n\t\treturn -ENOENT;\n\n\tradix_tree_delete(&pctldev->pin_group_tree, selector);\n\tdevm_kfree(pctldev->dev, group);\n\n\tpctldev->num_groups--;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(pinctrl_generic_remove_group);\n\n \nstatic void pinctrl_generic_free_groups(struct pinctrl_dev *pctldev)\n{\n\tstruct radix_tree_iter iter;\n\tvoid __rcu **slot;\n\n\tradix_tree_for_each_slot(slot, &pctldev->pin_group_tree, &iter, 0)\n\t\tradix_tree_delete(&pctldev->pin_group_tree, iter.index);\n\n\tpctldev->num_groups = 0;\n}\n\n#else\nstatic inline void pinctrl_generic_free_groups(struct pinctrl_dev *pctldev)\n{\n}\n#endif  \n\n \nint pinctrl_get_group_selector(struct pinctrl_dev *pctldev,\n\t\t\t       const char *pin_group)\n{\n\tconst struct pinctrl_ops *pctlops = pctldev->desc->pctlops;\n\tunsigned ngroups = pctlops->get_groups_count(pctldev);\n\tunsigned group_selector = 0;\n\n\twhile (group_selector < ngroups) {\n\t\tconst char *gname = pctlops->get_group_name(pctldev,\n\t\t\t\t\t\t\t    group_selector);\n\t\tif (gname && !strcmp(gname, pin_group)) {\n\t\t\tdev_dbg(pctldev->dev,\n\t\t\t\t\"found group selector %u for %s\\n\",\n\t\t\t\tgroup_selector,\n\t\t\t\tpin_group);\n\t\t\treturn group_selector;\n\t\t}\n\n\t\tgroup_selector++;\n\t}\n\n\tdev_err(pctldev->dev, \"does not have pin group %s\\n\",\n\t\tpin_group);\n\n\treturn -EINVAL;\n}\n\nbool pinctrl_gpio_can_use_line(unsigned gpio)\n{\n\tstruct pinctrl_dev *pctldev;\n\tstruct pinctrl_gpio_range *range;\n\tbool result;\n\tint pin;\n\n\t \n\tif (pinctrl_get_device_gpio_range(gpio, &pctldev, &range))\n\t\treturn true;\n\n\tmutex_lock(&pctldev->mutex);\n\n\t \n\tpin = gpio_to_pin(range, gpio);\n\n\tresult = pinmux_can_be_used_for_gpio(pctldev, pin);\n\n\tmutex_unlock(&pctldev->mutex);\n\n\treturn result;\n}\nEXPORT_SYMBOL_GPL(pinctrl_gpio_can_use_line);\n\n \nint pinctrl_gpio_request(unsigned gpio)\n{\n\tstruct pinctrl_dev *pctldev;\n\tstruct pinctrl_gpio_range *range;\n\tint ret;\n\tint pin;\n\n\tret = pinctrl_get_device_gpio_range(gpio, &pctldev, &range);\n\tif (ret) {\n\t\tif (pinctrl_ready_for_gpio_range(gpio))\n\t\t\tret = 0;\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&pctldev->mutex);\n\n\t \n\tpin = gpio_to_pin(range, gpio);\n\n\tret = pinmux_request_gpio(pctldev, range, pin, gpio);\n\n\tmutex_unlock(&pctldev->mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(pinctrl_gpio_request);\n\n \nvoid pinctrl_gpio_free(unsigned gpio)\n{\n\tstruct pinctrl_dev *pctldev;\n\tstruct pinctrl_gpio_range *range;\n\tint ret;\n\tint pin;\n\n\tret = pinctrl_get_device_gpio_range(gpio, &pctldev, &range);\n\tif (ret) {\n\t\treturn;\n\t}\n\tmutex_lock(&pctldev->mutex);\n\n\t \n\tpin = gpio_to_pin(range, gpio);\n\n\tpinmux_free_gpio(pctldev, pin, range);\n\n\tmutex_unlock(&pctldev->mutex);\n}\nEXPORT_SYMBOL_GPL(pinctrl_gpio_free);\n\nstatic int pinctrl_gpio_direction(unsigned gpio, bool input)\n{\n\tstruct pinctrl_dev *pctldev;\n\tstruct pinctrl_gpio_range *range;\n\tint ret;\n\tint pin;\n\n\tret = pinctrl_get_device_gpio_range(gpio, &pctldev, &range);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&pctldev->mutex);\n\n\t \n\tpin = gpio_to_pin(range, gpio);\n\tret = pinmux_gpio_direction(pctldev, range, pin, input);\n\n\tmutex_unlock(&pctldev->mutex);\n\n\treturn ret;\n}\n\n \nint pinctrl_gpio_direction_input(unsigned gpio)\n{\n\treturn pinctrl_gpio_direction(gpio, true);\n}\nEXPORT_SYMBOL_GPL(pinctrl_gpio_direction_input);\n\n \nint pinctrl_gpio_direction_output(unsigned gpio)\n{\n\treturn pinctrl_gpio_direction(gpio, false);\n}\nEXPORT_SYMBOL_GPL(pinctrl_gpio_direction_output);\n\n \nint pinctrl_gpio_set_config(unsigned gpio, unsigned long config)\n{\n\tunsigned long configs[] = { config };\n\tstruct pinctrl_gpio_range *range;\n\tstruct pinctrl_dev *pctldev;\n\tint ret, pin;\n\n\tret = pinctrl_get_device_gpio_range(gpio, &pctldev, &range);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&pctldev->mutex);\n\tpin = gpio_to_pin(range, gpio);\n\tret = pinconf_set_config(pctldev, pin, configs, ARRAY_SIZE(configs));\n\tmutex_unlock(&pctldev->mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(pinctrl_gpio_set_config);\n\nstatic struct pinctrl_state *find_state(struct pinctrl *p,\n\t\t\t\t\tconst char *name)\n{\n\tstruct pinctrl_state *state;\n\n\tlist_for_each_entry(state, &p->states, node)\n\t\tif (!strcmp(state->name, name))\n\t\t\treturn state;\n\n\treturn NULL;\n}\n\nstatic struct pinctrl_state *create_state(struct pinctrl *p,\n\t\t\t\t\t  const char *name)\n{\n\tstruct pinctrl_state *state;\n\n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstate->name = name;\n\tINIT_LIST_HEAD(&state->settings);\n\n\tlist_add_tail(&state->node, &p->states);\n\n\treturn state;\n}\n\nstatic int add_setting(struct pinctrl *p, struct pinctrl_dev *pctldev,\n\t\t       const struct pinctrl_map *map)\n{\n\tstruct pinctrl_state *state;\n\tstruct pinctrl_setting *setting;\n\tint ret;\n\n\tstate = find_state(p, map->name);\n\tif (!state)\n\t\tstate = create_state(p, map->name);\n\tif (IS_ERR(state))\n\t\treturn PTR_ERR(state);\n\n\tif (map->type == PIN_MAP_TYPE_DUMMY_STATE)\n\t\treturn 0;\n\n\tsetting = kzalloc(sizeof(*setting), GFP_KERNEL);\n\tif (!setting)\n\t\treturn -ENOMEM;\n\n\tsetting->type = map->type;\n\n\tif (pctldev)\n\t\tsetting->pctldev = pctldev;\n\telse\n\t\tsetting->pctldev =\n\t\t\tget_pinctrl_dev_from_devname(map->ctrl_dev_name);\n\tif (!setting->pctldev) {\n\t\tkfree(setting);\n\t\t \n\t\tif (!strcmp(map->ctrl_dev_name, map->dev_name))\n\t\t\treturn -ENODEV;\n\t\t \n\t\tdev_info(p->dev, \"unknown pinctrl device %s in map entry, deferring probe\",\n\t\t\tmap->ctrl_dev_name);\n\t\treturn -EPROBE_DEFER;\n\t}\n\n\tsetting->dev_name = map->dev_name;\n\n\tswitch (map->type) {\n\tcase PIN_MAP_TYPE_MUX_GROUP:\n\t\tret = pinmux_map_to_setting(map, setting);\n\t\tbreak;\n\tcase PIN_MAP_TYPE_CONFIGS_PIN:\n\tcase PIN_MAP_TYPE_CONFIGS_GROUP:\n\t\tret = pinconf_map_to_setting(map, setting);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\tif (ret < 0) {\n\t\tkfree(setting);\n\t\treturn ret;\n\t}\n\n\tlist_add_tail(&setting->node, &state->settings);\n\n\treturn 0;\n}\n\nstatic struct pinctrl *find_pinctrl(struct device *dev)\n{\n\tstruct pinctrl *p;\n\n\tmutex_lock(&pinctrl_list_mutex);\n\tlist_for_each_entry(p, &pinctrl_list, node)\n\t\tif (p->dev == dev) {\n\t\t\tmutex_unlock(&pinctrl_list_mutex);\n\t\t\treturn p;\n\t\t}\n\n\tmutex_unlock(&pinctrl_list_mutex);\n\treturn NULL;\n}\n\nstatic void pinctrl_free(struct pinctrl *p, bool inlist);\n\nstatic struct pinctrl *create_pinctrl(struct device *dev,\n\t\t\t\t      struct pinctrl_dev *pctldev)\n{\n\tstruct pinctrl *p;\n\tconst char *devname;\n\tstruct pinctrl_maps *maps_node;\n\tconst struct pinctrl_map *map;\n\tint ret;\n\n\t \n\tp = kzalloc(sizeof(*p), GFP_KERNEL);\n\tif (!p)\n\t\treturn ERR_PTR(-ENOMEM);\n\tp->dev = dev;\n\tINIT_LIST_HEAD(&p->states);\n\tINIT_LIST_HEAD(&p->dt_maps);\n\n\tret = pinctrl_dt_to_map(p, pctldev);\n\tif (ret < 0) {\n\t\tkfree(p);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tdevname = dev_name(dev);\n\n\tmutex_lock(&pinctrl_maps_mutex);\n\t \n\tfor_each_pin_map(maps_node, map) {\n\t\t \n\t\tif (strcmp(map->dev_name, devname))\n\t\t\tcontinue;\n\t\t \n\t\tif (pctldev &&\n\t\t    strcmp(dev_name(pctldev->dev), map->ctrl_dev_name))\n\t\t\tcontinue;\n\n\t\tret = add_setting(p, pctldev, map);\n\t\t \n\t\tif (ret == -EPROBE_DEFER) {\n\t\t\tpinctrl_free(p, false);\n\t\t\tmutex_unlock(&pinctrl_maps_mutex);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t}\n\tmutex_unlock(&pinctrl_maps_mutex);\n\n\tif (ret < 0) {\n\t\t \n\t\tpinctrl_free(p, false);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tkref_init(&p->users);\n\n\t \n\tmutex_lock(&pinctrl_list_mutex);\n\tlist_add_tail(&p->node, &pinctrl_list);\n\tmutex_unlock(&pinctrl_list_mutex);\n\n\treturn p;\n}\n\n \nstruct pinctrl *pinctrl_get(struct device *dev)\n{\n\tstruct pinctrl *p;\n\n\tif (WARN_ON(!dev))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\tp = find_pinctrl(dev);\n\tif (p) {\n\t\tdev_dbg(dev, \"obtain a copy of previously claimed pinctrl\\n\");\n\t\tkref_get(&p->users);\n\t\treturn p;\n\t}\n\n\treturn create_pinctrl(dev, NULL);\n}\nEXPORT_SYMBOL_GPL(pinctrl_get);\n\nstatic void pinctrl_free_setting(bool disable_setting,\n\t\t\t\t struct pinctrl_setting *setting)\n{\n\tswitch (setting->type) {\n\tcase PIN_MAP_TYPE_MUX_GROUP:\n\t\tif (disable_setting)\n\t\t\tpinmux_disable_setting(setting);\n\t\tpinmux_free_setting(setting);\n\t\tbreak;\n\tcase PIN_MAP_TYPE_CONFIGS_PIN:\n\tcase PIN_MAP_TYPE_CONFIGS_GROUP:\n\t\tpinconf_free_setting(setting);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void pinctrl_free(struct pinctrl *p, bool inlist)\n{\n\tstruct pinctrl_state *state, *n1;\n\tstruct pinctrl_setting *setting, *n2;\n\n\tmutex_lock(&pinctrl_list_mutex);\n\tlist_for_each_entry_safe(state, n1, &p->states, node) {\n\t\tlist_for_each_entry_safe(setting, n2, &state->settings, node) {\n\t\t\tpinctrl_free_setting(state == p->state, setting);\n\t\t\tlist_del(&setting->node);\n\t\t\tkfree(setting);\n\t\t}\n\t\tlist_del(&state->node);\n\t\tkfree(state);\n\t}\n\n\tpinctrl_dt_free_maps(p);\n\n\tif (inlist)\n\t\tlist_del(&p->node);\n\tkfree(p);\n\tmutex_unlock(&pinctrl_list_mutex);\n}\n\n \nstatic void pinctrl_release(struct kref *kref)\n{\n\tstruct pinctrl *p = container_of(kref, struct pinctrl, users);\n\n\tpinctrl_free(p, true);\n}\n\n \nvoid pinctrl_put(struct pinctrl *p)\n{\n\tkref_put(&p->users, pinctrl_release);\n}\nEXPORT_SYMBOL_GPL(pinctrl_put);\n\n \nstruct pinctrl_state *pinctrl_lookup_state(struct pinctrl *p,\n\t\t\t\t\t\t const char *name)\n{\n\tstruct pinctrl_state *state;\n\n\tstate = find_state(p, name);\n\tif (!state) {\n\t\tif (pinctrl_dummy_state) {\n\t\t\t \n\t\t\tdev_dbg(p->dev, \"using pinctrl dummy state (%s)\\n\",\n\t\t\t\tname);\n\t\t\tstate = create_state(p, name);\n\t\t} else\n\t\t\tstate = ERR_PTR(-ENODEV);\n\t}\n\n\treturn state;\n}\nEXPORT_SYMBOL_GPL(pinctrl_lookup_state);\n\nstatic void pinctrl_link_add(struct pinctrl_dev *pctldev,\n\t\t\t     struct device *consumer)\n{\n\tif (pctldev->desc->link_consumers)\n\t\tdevice_link_add(consumer, pctldev->dev,\n\t\t\t\tDL_FLAG_PM_RUNTIME |\n\t\t\t\tDL_FLAG_AUTOREMOVE_CONSUMER);\n}\n\n \nstatic int pinctrl_commit_state(struct pinctrl *p, struct pinctrl_state *state)\n{\n\tstruct pinctrl_setting *setting, *setting2;\n\tstruct pinctrl_state *old_state = READ_ONCE(p->state);\n\tint ret;\n\n\tif (old_state) {\n\t\t \n\t\tlist_for_each_entry(setting, &old_state->settings, node) {\n\t\t\tif (setting->type != PIN_MAP_TYPE_MUX_GROUP)\n\t\t\t\tcontinue;\n\t\t\tpinmux_disable_setting(setting);\n\t\t}\n\t}\n\n\tp->state = NULL;\n\n\t \n\tlist_for_each_entry(setting, &state->settings, node) {\n\t\tswitch (setting->type) {\n\t\tcase PIN_MAP_TYPE_MUX_GROUP:\n\t\t\tret = pinmux_enable_setting(setting);\n\t\t\tbreak;\n\t\tcase PIN_MAP_TYPE_CONFIGS_PIN:\n\t\tcase PIN_MAP_TYPE_CONFIGS_GROUP:\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ret < 0)\n\t\t\tgoto unapply_new_state;\n\n\t\t \n\t\tif (p != setting->pctldev->p)\n\t\t\tpinctrl_link_add(setting->pctldev, p->dev);\n\t}\n\n\t \n\tlist_for_each_entry(setting, &state->settings, node) {\n\t\tswitch (setting->type) {\n\t\tcase PIN_MAP_TYPE_MUX_GROUP:\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\tcase PIN_MAP_TYPE_CONFIGS_PIN:\n\t\tcase PIN_MAP_TYPE_CONFIGS_GROUP:\n\t\t\tret = pinconf_apply_setting(setting);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ret < 0) {\n\t\t\tgoto unapply_new_state;\n\t\t}\n\n\t\t \n\t\tif (p != setting->pctldev->p)\n\t\t\tpinctrl_link_add(setting->pctldev, p->dev);\n\t}\n\n\tp->state = state;\n\n\treturn 0;\n\nunapply_new_state:\n\tdev_err(p->dev, \"Error applying setting, reverse things back\\n\");\n\n\tlist_for_each_entry(setting2, &state->settings, node) {\n\t\tif (&setting2->node == &setting->node)\n\t\t\tbreak;\n\t\t \n\t\tif (setting2->type == PIN_MAP_TYPE_MUX_GROUP)\n\t\t\tpinmux_disable_setting(setting2);\n\t}\n\n\t \n\tif (old_state)\n\t\tpinctrl_select_state(p, old_state);\n\n\treturn ret;\n}\n\n \nint pinctrl_select_state(struct pinctrl *p, struct pinctrl_state *state)\n{\n\tif (p->state == state)\n\t\treturn 0;\n\n\treturn pinctrl_commit_state(p, state);\n}\nEXPORT_SYMBOL_GPL(pinctrl_select_state);\n\nstatic void devm_pinctrl_release(struct device *dev, void *res)\n{\n\tpinctrl_put(*(struct pinctrl **)res);\n}\n\n \nstruct pinctrl *devm_pinctrl_get(struct device *dev)\n{\n\tstruct pinctrl **ptr, *p;\n\n\tptr = devres_alloc(devm_pinctrl_release, sizeof(*ptr), GFP_KERNEL);\n\tif (!ptr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tp = pinctrl_get(dev);\n\tif (!IS_ERR(p)) {\n\t\t*ptr = p;\n\t\tdevres_add(dev, ptr);\n\t} else {\n\t\tdevres_free(ptr);\n\t}\n\n\treturn p;\n}\nEXPORT_SYMBOL_GPL(devm_pinctrl_get);\n\nstatic int devm_pinctrl_match(struct device *dev, void *res, void *data)\n{\n\tstruct pinctrl **p = res;\n\n\treturn *p == data;\n}\n\n \nvoid devm_pinctrl_put(struct pinctrl *p)\n{\n\tWARN_ON(devres_release(p->dev, devm_pinctrl_release,\n\t\t\t       devm_pinctrl_match, p));\n}\nEXPORT_SYMBOL_GPL(devm_pinctrl_put);\n\n \nint pinctrl_register_mappings(const struct pinctrl_map *maps,\n\t\t\t      unsigned num_maps)\n{\n\tint i, ret;\n\tstruct pinctrl_maps *maps_node;\n\n\tpr_debug(\"add %u pinctrl maps\\n\", num_maps);\n\n\t \n\tfor (i = 0; i < num_maps; i++) {\n\t\tif (!maps[i].dev_name) {\n\t\t\tpr_err(\"failed to register map %s (%d): no device given\\n\",\n\t\t\t       maps[i].name, i);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!maps[i].name) {\n\t\t\tpr_err(\"failed to register map %d: no map name given\\n\",\n\t\t\t       i);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (maps[i].type != PIN_MAP_TYPE_DUMMY_STATE &&\n\t\t\t\t!maps[i].ctrl_dev_name) {\n\t\t\tpr_err(\"failed to register map %s (%d): no pin control device given\\n\",\n\t\t\t       maps[i].name, i);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tswitch (maps[i].type) {\n\t\tcase PIN_MAP_TYPE_DUMMY_STATE:\n\t\t\tbreak;\n\t\tcase PIN_MAP_TYPE_MUX_GROUP:\n\t\t\tret = pinmux_validate_map(&maps[i], i);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tcase PIN_MAP_TYPE_CONFIGS_PIN:\n\t\tcase PIN_MAP_TYPE_CONFIGS_GROUP:\n\t\t\tret = pinconf_validate_map(&maps[i], i);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"failed to register map %s (%d): invalid type given\\n\",\n\t\t\t       maps[i].name, i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tmaps_node = kzalloc(sizeof(*maps_node), GFP_KERNEL);\n\tif (!maps_node)\n\t\treturn -ENOMEM;\n\n\tmaps_node->maps = maps;\n\tmaps_node->num_maps = num_maps;\n\n\tmutex_lock(&pinctrl_maps_mutex);\n\tlist_add_tail(&maps_node->node, &pinctrl_maps);\n\tmutex_unlock(&pinctrl_maps_mutex);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(pinctrl_register_mappings);\n\n \nvoid pinctrl_unregister_mappings(const struct pinctrl_map *map)\n{\n\tstruct pinctrl_maps *maps_node;\n\n\tmutex_lock(&pinctrl_maps_mutex);\n\tlist_for_each_entry(maps_node, &pinctrl_maps, node) {\n\t\tif (maps_node->maps == map) {\n\t\t\tlist_del(&maps_node->node);\n\t\t\tkfree(maps_node);\n\t\t\tmutex_unlock(&pinctrl_maps_mutex);\n\t\t\treturn;\n\t\t}\n\t}\n\tmutex_unlock(&pinctrl_maps_mutex);\n}\nEXPORT_SYMBOL_GPL(pinctrl_unregister_mappings);\n\n \nint pinctrl_force_sleep(struct pinctrl_dev *pctldev)\n{\n\tif (!IS_ERR(pctldev->p) && !IS_ERR(pctldev->hog_sleep))\n\t\treturn pinctrl_commit_state(pctldev->p, pctldev->hog_sleep);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(pinctrl_force_sleep);\n\n \nint pinctrl_force_default(struct pinctrl_dev *pctldev)\n{\n\tif (!IS_ERR(pctldev->p) && !IS_ERR(pctldev->hog_default))\n\t\treturn pinctrl_commit_state(pctldev->p, pctldev->hog_default);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(pinctrl_force_default);\n\n \nint pinctrl_init_done(struct device *dev)\n{\n\tstruct dev_pin_info *pins = dev->pins;\n\tint ret;\n\n\tif (!pins)\n\t\treturn 0;\n\n\tif (IS_ERR(pins->init_state))\n\t\treturn 0;  \n\n\tif (pins->p->state != pins->init_state)\n\t\treturn 0;  \n\n\tif (IS_ERR(pins->default_state))\n\t\treturn 0;  \n\n\tret = pinctrl_select_state(pins->p, pins->default_state);\n\tif (ret)\n\t\tdev_err(dev, \"failed to activate default pinctrl state\\n\");\n\n\treturn ret;\n}\n\nstatic int pinctrl_select_bound_state(struct device *dev,\n\t\t\t\t      struct pinctrl_state *state)\n{\n\tstruct dev_pin_info *pins = dev->pins;\n\tint ret;\n\n\tif (IS_ERR(state))\n\t\treturn 0;  \n\tret = pinctrl_select_state(pins->p, state);\n\tif (ret)\n\t\tdev_err(dev, \"failed to activate pinctrl state %s\\n\",\n\t\t\tstate->name);\n\treturn ret;\n}\n\n \nint pinctrl_select_default_state(struct device *dev)\n{\n\tif (!dev->pins)\n\t\treturn 0;\n\n\treturn pinctrl_select_bound_state(dev, dev->pins->default_state);\n}\nEXPORT_SYMBOL_GPL(pinctrl_select_default_state);\n\n#ifdef CONFIG_PM\n\n \nint pinctrl_pm_select_default_state(struct device *dev)\n{\n\treturn pinctrl_select_default_state(dev);\n}\nEXPORT_SYMBOL_GPL(pinctrl_pm_select_default_state);\n\n \nint pinctrl_pm_select_sleep_state(struct device *dev)\n{\n\tif (!dev->pins)\n\t\treturn 0;\n\n\treturn pinctrl_select_bound_state(dev, dev->pins->sleep_state);\n}\nEXPORT_SYMBOL_GPL(pinctrl_pm_select_sleep_state);\n\n \nint pinctrl_pm_select_idle_state(struct device *dev)\n{\n\tif (!dev->pins)\n\t\treturn 0;\n\n\treturn pinctrl_select_bound_state(dev, dev->pins->idle_state);\n}\nEXPORT_SYMBOL_GPL(pinctrl_pm_select_idle_state);\n#endif\n\n#ifdef CONFIG_DEBUG_FS\n\nstatic int pinctrl_pins_show(struct seq_file *s, void *what)\n{\n\tstruct pinctrl_dev *pctldev = s->private;\n\tconst struct pinctrl_ops *ops = pctldev->desc->pctlops;\n\tunsigned i, pin;\n#ifdef CONFIG_GPIOLIB\n\tstruct pinctrl_gpio_range *range;\n\tstruct gpio_chip *chip;\n\tint gpio_num;\n#endif\n\n\tseq_printf(s, \"registered pins: %d\\n\", pctldev->desc->npins);\n\n\tmutex_lock(&pctldev->mutex);\n\n\t \n\tfor (i = 0; i < pctldev->desc->npins; i++) {\n\t\tstruct pin_desc *desc;\n\n\t\tpin = pctldev->desc->pins[i].number;\n\t\tdesc = pin_desc_get(pctldev, pin);\n\t\t \n\t\tif (!desc)\n\t\t\tcontinue;\n\n\t\tseq_printf(s, \"pin %d (%s) \", pin, desc->name);\n\n#ifdef CONFIG_GPIOLIB\n\t\tgpio_num = -1;\n\t\tlist_for_each_entry(range, &pctldev->gpio_ranges, node) {\n\t\t\tif ((pin >= range->pin_base) &&\n\t\t\t    (pin < (range->pin_base + range->npins))) {\n\t\t\t\tgpio_num = range->base + (pin - range->pin_base);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (gpio_num >= 0)\n\t\t\t \n\t\t\tchip = gpiod_to_chip(gpio_to_desc(gpio_num));\n\t\telse\n\t\t\tchip = NULL;\n\t\tif (chip)\n\t\t\tseq_printf(s, \"%u:%s \", gpio_num - chip->gpiodev->base, chip->label);\n\t\telse\n\t\t\tseq_puts(s, \"0:? \");\n#endif\n\n\t\t \n\t\tif (ops->pin_dbg_show)\n\t\t\tops->pin_dbg_show(pctldev, s, pin);\n\n\t\tseq_puts(s, \"\\n\");\n\t}\n\n\tmutex_unlock(&pctldev->mutex);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(pinctrl_pins);\n\nstatic int pinctrl_groups_show(struct seq_file *s, void *what)\n{\n\tstruct pinctrl_dev *pctldev = s->private;\n\tconst struct pinctrl_ops *ops = pctldev->desc->pctlops;\n\tunsigned ngroups, selector = 0;\n\n\tmutex_lock(&pctldev->mutex);\n\n\tngroups = ops->get_groups_count(pctldev);\n\n\tseq_puts(s, \"registered pin groups:\\n\");\n\twhile (selector < ngroups) {\n\t\tconst unsigned *pins = NULL;\n\t\tunsigned num_pins = 0;\n\t\tconst char *gname = ops->get_group_name(pctldev, selector);\n\t\tconst char *pname;\n\t\tint ret = 0;\n\t\tint i;\n\n\t\tif (ops->get_group_pins)\n\t\t\tret = ops->get_group_pins(pctldev, selector,\n\t\t\t\t\t\t  &pins, &num_pins);\n\t\tif (ret)\n\t\t\tseq_printf(s, \"%s [ERROR GETTING PINS]\\n\",\n\t\t\t\t   gname);\n\t\telse {\n\t\t\tseq_printf(s, \"group: %s\\n\", gname);\n\t\t\tfor (i = 0; i < num_pins; i++) {\n\t\t\t\tpname = pin_get_name(pctldev, pins[i]);\n\t\t\t\tif (WARN_ON(!pname)) {\n\t\t\t\t\tmutex_unlock(&pctldev->mutex);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tseq_printf(s, \"pin %d (%s)\\n\", pins[i], pname);\n\t\t\t}\n\t\t\tseq_puts(s, \"\\n\");\n\t\t}\n\t\tselector++;\n\t}\n\n\tmutex_unlock(&pctldev->mutex);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(pinctrl_groups);\n\nstatic int pinctrl_gpioranges_show(struct seq_file *s, void *what)\n{\n\tstruct pinctrl_dev *pctldev = s->private;\n\tstruct pinctrl_gpio_range *range;\n\n\tseq_puts(s, \"GPIO ranges handled:\\n\");\n\n\tmutex_lock(&pctldev->mutex);\n\n\t \n\tlist_for_each_entry(range, &pctldev->gpio_ranges, node) {\n\t\tif (range->pins) {\n\t\t\tint a;\n\t\t\tseq_printf(s, \"%u: %s GPIOS [%u - %u] PINS {\",\n\t\t\t\trange->id, range->name,\n\t\t\t\trange->base, (range->base + range->npins - 1));\n\t\t\tfor (a = 0; a < range->npins - 1; a++)\n\t\t\t\tseq_printf(s, \"%u, \", range->pins[a]);\n\t\t\tseq_printf(s, \"%u}\\n\", range->pins[a]);\n\t\t}\n\t\telse\n\t\t\tseq_printf(s, \"%u: %s GPIOS [%u - %u] PINS [%u - %u]\\n\",\n\t\t\t\trange->id, range->name,\n\t\t\t\trange->base, (range->base + range->npins - 1),\n\t\t\t\trange->pin_base,\n\t\t\t\t(range->pin_base + range->npins - 1));\n\t}\n\n\tmutex_unlock(&pctldev->mutex);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(pinctrl_gpioranges);\n\nstatic int pinctrl_devices_show(struct seq_file *s, void *what)\n{\n\tstruct pinctrl_dev *pctldev;\n\n\tseq_puts(s, \"name [pinmux] [pinconf]\\n\");\n\n\tmutex_lock(&pinctrldev_list_mutex);\n\n\tlist_for_each_entry(pctldev, &pinctrldev_list, node) {\n\t\tseq_printf(s, \"%s \", pctldev->desc->name);\n\t\tif (pctldev->desc->pmxops)\n\t\t\tseq_puts(s, \"yes \");\n\t\telse\n\t\t\tseq_puts(s, \"no \");\n\t\tif (pctldev->desc->confops)\n\t\t\tseq_puts(s, \"yes\");\n\t\telse\n\t\t\tseq_puts(s, \"no\");\n\t\tseq_puts(s, \"\\n\");\n\t}\n\n\tmutex_unlock(&pinctrldev_list_mutex);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(pinctrl_devices);\n\nstatic inline const char *map_type(enum pinctrl_map_type type)\n{\n\tstatic const char * const names[] = {\n\t\t\"INVALID\",\n\t\t\"DUMMY_STATE\",\n\t\t\"MUX_GROUP\",\n\t\t\"CONFIGS_PIN\",\n\t\t\"CONFIGS_GROUP\",\n\t};\n\n\tif (type >= ARRAY_SIZE(names))\n\t\treturn \"UNKNOWN\";\n\n\treturn names[type];\n}\n\nstatic int pinctrl_maps_show(struct seq_file *s, void *what)\n{\n\tstruct pinctrl_maps *maps_node;\n\tconst struct pinctrl_map *map;\n\n\tseq_puts(s, \"Pinctrl maps:\\n\");\n\n\tmutex_lock(&pinctrl_maps_mutex);\n\tfor_each_pin_map(maps_node, map) {\n\t\tseq_printf(s, \"device %s\\nstate %s\\ntype %s (%d)\\n\",\n\t\t\t   map->dev_name, map->name, map_type(map->type),\n\t\t\t   map->type);\n\n\t\tif (map->type != PIN_MAP_TYPE_DUMMY_STATE)\n\t\t\tseq_printf(s, \"controlling device %s\\n\",\n\t\t\t\t   map->ctrl_dev_name);\n\n\t\tswitch (map->type) {\n\t\tcase PIN_MAP_TYPE_MUX_GROUP:\n\t\t\tpinmux_show_map(s, map);\n\t\t\tbreak;\n\t\tcase PIN_MAP_TYPE_CONFIGS_PIN:\n\t\tcase PIN_MAP_TYPE_CONFIGS_GROUP:\n\t\t\tpinconf_show_map(s, map);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tseq_putc(s, '\\n');\n\t}\n\tmutex_unlock(&pinctrl_maps_mutex);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(pinctrl_maps);\n\nstatic int pinctrl_show(struct seq_file *s, void *what)\n{\n\tstruct pinctrl *p;\n\tstruct pinctrl_state *state;\n\tstruct pinctrl_setting *setting;\n\n\tseq_puts(s, \"Requested pin control handlers their pinmux maps:\\n\");\n\n\tmutex_lock(&pinctrl_list_mutex);\n\n\tlist_for_each_entry(p, &pinctrl_list, node) {\n\t\tseq_printf(s, \"device: %s current state: %s\\n\",\n\t\t\t   dev_name(p->dev),\n\t\t\t   p->state ? p->state->name : \"none\");\n\n\t\tlist_for_each_entry(state, &p->states, node) {\n\t\t\tseq_printf(s, \"  state: %s\\n\", state->name);\n\n\t\t\tlist_for_each_entry(setting, &state->settings, node) {\n\t\t\t\tstruct pinctrl_dev *pctldev = setting->pctldev;\n\n\t\t\t\tseq_printf(s, \"    type: %s controller %s \",\n\t\t\t\t\t   map_type(setting->type),\n\t\t\t\t\t   pinctrl_dev_get_name(pctldev));\n\n\t\t\t\tswitch (setting->type) {\n\t\t\t\tcase PIN_MAP_TYPE_MUX_GROUP:\n\t\t\t\t\tpinmux_show_setting(s, setting);\n\t\t\t\t\tbreak;\n\t\t\t\tcase PIN_MAP_TYPE_CONFIGS_PIN:\n\t\t\t\tcase PIN_MAP_TYPE_CONFIGS_GROUP:\n\t\t\t\t\tpinconf_show_setting(s, setting);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tmutex_unlock(&pinctrl_list_mutex);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(pinctrl);\n\nstatic struct dentry *debugfs_root;\n\nstatic void pinctrl_init_device_debugfs(struct pinctrl_dev *pctldev)\n{\n\tstruct dentry *device_root;\n\tconst char *debugfs_name;\n\n\tif (pctldev->desc->name &&\n\t\t\tstrcmp(dev_name(pctldev->dev), pctldev->desc->name)) {\n\t\tdebugfs_name = devm_kasprintf(pctldev->dev, GFP_KERNEL,\n\t\t\t\t\"%s-%s\", dev_name(pctldev->dev),\n\t\t\t\tpctldev->desc->name);\n\t\tif (!debugfs_name) {\n\t\t\tpr_warn(\"failed to determine debugfs dir name for %s\\n\",\n\t\t\t\tdev_name(pctldev->dev));\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tdebugfs_name = dev_name(pctldev->dev);\n\t}\n\n\tdevice_root = debugfs_create_dir(debugfs_name, debugfs_root);\n\tpctldev->device_root = device_root;\n\n\tif (IS_ERR(device_root) || !device_root) {\n\t\tpr_warn(\"failed to create debugfs directory for %s\\n\",\n\t\t\tdev_name(pctldev->dev));\n\t\treturn;\n\t}\n\tdebugfs_create_file(\"pins\", 0444,\n\t\t\t    device_root, pctldev, &pinctrl_pins_fops);\n\tdebugfs_create_file(\"pingroups\", 0444,\n\t\t\t    device_root, pctldev, &pinctrl_groups_fops);\n\tdebugfs_create_file(\"gpio-ranges\", 0444,\n\t\t\t    device_root, pctldev, &pinctrl_gpioranges_fops);\n\tif (pctldev->desc->pmxops)\n\t\tpinmux_init_device_debugfs(device_root, pctldev);\n\tif (pctldev->desc->confops)\n\t\tpinconf_init_device_debugfs(device_root, pctldev);\n}\n\nstatic void pinctrl_remove_device_debugfs(struct pinctrl_dev *pctldev)\n{\n\tdebugfs_remove_recursive(pctldev->device_root);\n}\n\nstatic void pinctrl_init_debugfs(void)\n{\n\tdebugfs_root = debugfs_create_dir(\"pinctrl\", NULL);\n\tif (IS_ERR(debugfs_root) || !debugfs_root) {\n\t\tpr_warn(\"failed to create debugfs directory\\n\");\n\t\tdebugfs_root = NULL;\n\t\treturn;\n\t}\n\n\tdebugfs_create_file(\"pinctrl-devices\", 0444,\n\t\t\t    debugfs_root, NULL, &pinctrl_devices_fops);\n\tdebugfs_create_file(\"pinctrl-maps\", 0444,\n\t\t\t    debugfs_root, NULL, &pinctrl_maps_fops);\n\tdebugfs_create_file(\"pinctrl-handles\", 0444,\n\t\t\t    debugfs_root, NULL, &pinctrl_fops);\n}\n\n#else  \n\nstatic void pinctrl_init_device_debugfs(struct pinctrl_dev *pctldev)\n{\n}\n\nstatic void pinctrl_init_debugfs(void)\n{\n}\n\nstatic void pinctrl_remove_device_debugfs(struct pinctrl_dev *pctldev)\n{\n}\n\n#endif\n\nstatic int pinctrl_check_ops(struct pinctrl_dev *pctldev)\n{\n\tconst struct pinctrl_ops *ops = pctldev->desc->pctlops;\n\n\tif (!ops ||\n\t    !ops->get_groups_count ||\n\t    !ops->get_group_name)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nstatic struct pinctrl_dev *\npinctrl_init_controller(struct pinctrl_desc *pctldesc, struct device *dev,\n\t\t\tvoid *driver_data)\n{\n\tstruct pinctrl_dev *pctldev;\n\tint ret;\n\n\tif (!pctldesc)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (!pctldesc->name)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tpctldev = kzalloc(sizeof(*pctldev), GFP_KERNEL);\n\tif (!pctldev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tpctldev->owner = pctldesc->owner;\n\tpctldev->desc = pctldesc;\n\tpctldev->driver_data = driver_data;\n\tINIT_RADIX_TREE(&pctldev->pin_desc_tree, GFP_KERNEL);\n#ifdef CONFIG_GENERIC_PINCTRL_GROUPS\n\tINIT_RADIX_TREE(&pctldev->pin_group_tree, GFP_KERNEL);\n#endif\n#ifdef CONFIG_GENERIC_PINMUX_FUNCTIONS\n\tINIT_RADIX_TREE(&pctldev->pin_function_tree, GFP_KERNEL);\n#endif\n\tINIT_LIST_HEAD(&pctldev->gpio_ranges);\n\tINIT_LIST_HEAD(&pctldev->node);\n\tpctldev->dev = dev;\n\tmutex_init(&pctldev->mutex);\n\n\t \n\tret = pinctrl_check_ops(pctldev);\n\tif (ret) {\n\t\tdev_err(dev, \"pinctrl ops lacks necessary functions\\n\");\n\t\tgoto out_err;\n\t}\n\n\t \n\tif (pctldesc->pmxops) {\n\t\tret = pinmux_check_ops(pctldev);\n\t\tif (ret)\n\t\t\tgoto out_err;\n\t}\n\n\t \n\tif (pctldesc->confops) {\n\t\tret = pinconf_check_ops(pctldev);\n\t\tif (ret)\n\t\t\tgoto out_err;\n\t}\n\n\t \n\tdev_dbg(dev, \"try to register %d pins ...\\n\",  pctldesc->npins);\n\tret = pinctrl_register_pins(pctldev, pctldesc->pins, pctldesc->npins);\n\tif (ret) {\n\t\tdev_err(dev, \"error during pin registration\\n\");\n\t\tpinctrl_free_pindescs(pctldev, pctldesc->pins,\n\t\t\t\t      pctldesc->npins);\n\t\tgoto out_err;\n\t}\n\n\treturn pctldev;\n\nout_err:\n\tmutex_destroy(&pctldev->mutex);\n\tkfree(pctldev);\n\treturn ERR_PTR(ret);\n}\n\nstatic int pinctrl_claim_hogs(struct pinctrl_dev *pctldev)\n{\n\tpctldev->p = create_pinctrl(pctldev->dev, pctldev);\n\tif (PTR_ERR(pctldev->p) == -ENODEV) {\n\t\tdev_dbg(pctldev->dev, \"no hogs found\\n\");\n\n\t\treturn 0;\n\t}\n\n\tif (IS_ERR(pctldev->p)) {\n\t\tdev_err(pctldev->dev, \"error claiming hogs: %li\\n\",\n\t\t\tPTR_ERR(pctldev->p));\n\n\t\treturn PTR_ERR(pctldev->p);\n\t}\n\n\tpctldev->hog_default =\n\t\tpinctrl_lookup_state(pctldev->p, PINCTRL_STATE_DEFAULT);\n\tif (IS_ERR(pctldev->hog_default)) {\n\t\tdev_dbg(pctldev->dev,\n\t\t\t\"failed to lookup the default state\\n\");\n\t} else {\n\t\tif (pinctrl_select_state(pctldev->p,\n\t\t\t\t\t pctldev->hog_default))\n\t\t\tdev_err(pctldev->dev,\n\t\t\t\t\"failed to select default state\\n\");\n\t}\n\n\tpctldev->hog_sleep =\n\t\tpinctrl_lookup_state(pctldev->p,\n\t\t\t\t     PINCTRL_STATE_SLEEP);\n\tif (IS_ERR(pctldev->hog_sleep))\n\t\tdev_dbg(pctldev->dev,\n\t\t\t\"failed to lookup the sleep state\\n\");\n\n\treturn 0;\n}\n\nint pinctrl_enable(struct pinctrl_dev *pctldev)\n{\n\tint error;\n\n\terror = pinctrl_claim_hogs(pctldev);\n\tif (error) {\n\t\tdev_err(pctldev->dev, \"could not claim hogs: %i\\n\",\n\t\t\terror);\n\t\tpinctrl_free_pindescs(pctldev, pctldev->desc->pins,\n\t\t\t\t      pctldev->desc->npins);\n\t\tmutex_destroy(&pctldev->mutex);\n\t\tkfree(pctldev);\n\n\t\treturn error;\n\t}\n\n\tmutex_lock(&pinctrldev_list_mutex);\n\tlist_add_tail(&pctldev->node, &pinctrldev_list);\n\tmutex_unlock(&pinctrldev_list_mutex);\n\n\tpinctrl_init_device_debugfs(pctldev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(pinctrl_enable);\n\n \nstruct pinctrl_dev *pinctrl_register(struct pinctrl_desc *pctldesc,\n\t\t\t\t    struct device *dev, void *driver_data)\n{\n\tstruct pinctrl_dev *pctldev;\n\tint error;\n\n\tpctldev = pinctrl_init_controller(pctldesc, dev, driver_data);\n\tif (IS_ERR(pctldev))\n\t\treturn pctldev;\n\n\terror = pinctrl_enable(pctldev);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\treturn pctldev;\n}\nEXPORT_SYMBOL_GPL(pinctrl_register);\n\n \nint pinctrl_register_and_init(struct pinctrl_desc *pctldesc,\n\t\t\t      struct device *dev, void *driver_data,\n\t\t\t      struct pinctrl_dev **pctldev)\n{\n\tstruct pinctrl_dev *p;\n\n\tp = pinctrl_init_controller(pctldesc, dev, driver_data);\n\tif (IS_ERR(p))\n\t\treturn PTR_ERR(p);\n\n\t \n\t*pctldev = p;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(pinctrl_register_and_init);\n\n \nvoid pinctrl_unregister(struct pinctrl_dev *pctldev)\n{\n\tstruct pinctrl_gpio_range *range, *n;\n\n\tif (!pctldev)\n\t\treturn;\n\n\tmutex_lock(&pctldev->mutex);\n\tpinctrl_remove_device_debugfs(pctldev);\n\tmutex_unlock(&pctldev->mutex);\n\n\tif (!IS_ERR_OR_NULL(pctldev->p))\n\t\tpinctrl_put(pctldev->p);\n\n\tmutex_lock(&pinctrldev_list_mutex);\n\tmutex_lock(&pctldev->mutex);\n\t \n\tlist_del(&pctldev->node);\n\tpinmux_generic_free_functions(pctldev);\n\tpinctrl_generic_free_groups(pctldev);\n\t \n\tpinctrl_free_pindescs(pctldev, pctldev->desc->pins,\n\t\t\t      pctldev->desc->npins);\n\t \n\tlist_for_each_entry_safe(range, n, &pctldev->gpio_ranges, node)\n\t\tlist_del(&range->node);\n\n\tmutex_unlock(&pctldev->mutex);\n\tmutex_destroy(&pctldev->mutex);\n\tkfree(pctldev);\n\tmutex_unlock(&pinctrldev_list_mutex);\n}\nEXPORT_SYMBOL_GPL(pinctrl_unregister);\n\nstatic void devm_pinctrl_dev_release(struct device *dev, void *res)\n{\n\tstruct pinctrl_dev *pctldev = *(struct pinctrl_dev **)res;\n\n\tpinctrl_unregister(pctldev);\n}\n\nstatic int devm_pinctrl_dev_match(struct device *dev, void *res, void *data)\n{\n\tstruct pctldev **r = res;\n\n\tif (WARN_ON(!r || !*r))\n\t\treturn 0;\n\n\treturn *r == data;\n}\n\n \nstruct pinctrl_dev *devm_pinctrl_register(struct device *dev,\n\t\t\t\t\t  struct pinctrl_desc *pctldesc,\n\t\t\t\t\t  void *driver_data)\n{\n\tstruct pinctrl_dev **ptr, *pctldev;\n\n\tptr = devres_alloc(devm_pinctrl_dev_release, sizeof(*ptr), GFP_KERNEL);\n\tif (!ptr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpctldev = pinctrl_register(pctldesc, dev, driver_data);\n\tif (IS_ERR(pctldev)) {\n\t\tdevres_free(ptr);\n\t\treturn pctldev;\n\t}\n\n\t*ptr = pctldev;\n\tdevres_add(dev, ptr);\n\n\treturn pctldev;\n}\nEXPORT_SYMBOL_GPL(devm_pinctrl_register);\n\n \nint devm_pinctrl_register_and_init(struct device *dev,\n\t\t\t\t   struct pinctrl_desc *pctldesc,\n\t\t\t\t   void *driver_data,\n\t\t\t\t   struct pinctrl_dev **pctldev)\n{\n\tstruct pinctrl_dev **ptr;\n\tint error;\n\n\tptr = devres_alloc(devm_pinctrl_dev_release, sizeof(*ptr), GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\n\terror = pinctrl_register_and_init(pctldesc, dev, driver_data, pctldev);\n\tif (error) {\n\t\tdevres_free(ptr);\n\t\treturn error;\n\t}\n\n\t*ptr = *pctldev;\n\tdevres_add(dev, ptr);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(devm_pinctrl_register_and_init);\n\n \nvoid devm_pinctrl_unregister(struct device *dev, struct pinctrl_dev *pctldev)\n{\n\tWARN_ON(devres_release(dev, devm_pinctrl_dev_release,\n\t\t\t       devm_pinctrl_dev_match, pctldev));\n}\nEXPORT_SYMBOL_GPL(devm_pinctrl_unregister);\n\nstatic int __init pinctrl_init(void)\n{\n\tpr_info(\"initialized pinctrl subsystem\\n\");\n\tpinctrl_init_debugfs();\n\treturn 0;\n}\n\n \ncore_initcall(pinctrl_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}