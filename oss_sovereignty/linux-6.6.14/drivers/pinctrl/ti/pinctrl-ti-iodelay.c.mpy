{
  "module_name": "pinctrl-ti-iodelay.c",
  "hash_id": "51649a95f5eea6ce667acc97861638984f8fd99649bf90395d6793b8f81599da",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/ti/pinctrl-ti-iodelay.c",
  "human_readable_source": " \n\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/regmap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n\n#include <linux/pinctrl/pinconf-generic.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinctrl.h>\n\n#include \"../core.h\"\n#include \"../devicetree.h\"\n\n#define DRIVER_NAME\t\"ti-iodelay\"\n\n \nstruct ti_iodelay_reg_data {\n\tu32 signature_mask;\n\tu32 signature_value;\n\tu32 lock_mask;\n\tu32 lock_val;\n\tu32 unlock_val;\n\tu32 binary_data_coarse_mask;\n\tu32 binary_data_fine_mask;\n\n\tu32 reg_refclk_offset;\n\tu32 refclk_period_mask;\n\n\tu32 reg_coarse_offset;\n\tu32 coarse_delay_count_mask;\n\tu32 coarse_ref_count_mask;\n\n\tu32 reg_fine_offset;\n\tu32 fine_delay_count_mask;\n\tu32 fine_ref_count_mask;\n\n\tu32 reg_global_lock_offset;\n\tu32 global_lock_mask;\n\tu32 global_unlock_val;\n\tu32 global_lock_val;\n\n\tu32 reg_start_offset;\n\tu32 reg_nr_per_pin;\n\n\tstruct regmap_config *regmap_config;\n};\n\n \nstruct ti_iodelay_reg_values {\n\tu16 coarse_ref_count;\n\tu16 coarse_delay_count;\n\n\tu16 fine_ref_count;\n\tu16 fine_delay_count;\n\n\tu16 ref_clk_period;\n\n\tu32 cdpe;\n\tu32 fdpe;\n};\n\n \nstruct ti_iodelay_cfg {\n\tu16 offset;\n\tu16 a_delay;\n\tu16 g_delay;\n};\n\n \nstruct ti_iodelay_pingroup {\n\tstruct ti_iodelay_cfg *cfg;\n\tint ncfg;\n\tunsigned long config;\n};\n\n \nstruct ti_iodelay_device {\n\tstruct device *dev;\n\tunsigned long phys_base;\n\tvoid __iomem *reg_base;\n\tstruct regmap *regmap;\n\n\tstruct pinctrl_dev *pctl;\n\tstruct pinctrl_desc desc;\n\tstruct pinctrl_pin_desc *pa;\n\n\tconst struct ti_iodelay_reg_data *reg_data;\n\tstruct ti_iodelay_reg_values reg_init_conf_values;\n};\n\n \nstatic inline u32 ti_iodelay_extract(u32 val, u32 mask)\n{\n\treturn (val & mask) >> __ffs(mask);\n}\n\n \nstatic inline u32 ti_iodelay_compute_dpe(u16 period, u16 ref, u16 delay,\n\t\t\t\t\t u16 delay_m)\n{\n\tu64 m, d;\n\n\t \n\tm = 10 * (u64)period * (u64)ref;\n\td = 2 * (u64)delay * (u64)delay_m;\n\n\t \n\treturn div64_u64(m, d);\n}\n\n \nstatic int ti_iodelay_pinconf_set(struct ti_iodelay_device *iod,\n\t\t\t\t  struct ti_iodelay_cfg *cfg)\n{\n\tconst struct ti_iodelay_reg_data *reg = iod->reg_data;\n\tstruct ti_iodelay_reg_values *ival = &iod->reg_init_conf_values;\n\tstruct device *dev = iod->dev;\n\tu32 g_delay_coarse, g_delay_fine;\n\tu32 a_delay_coarse, a_delay_fine;\n\tu32 c_elements, f_elements;\n\tu32 total_delay;\n\tu32 reg_mask, reg_val, tmp_val;\n\tint r;\n\n\t \n\tg_delay_coarse = cfg->g_delay / 920;\n\tg_delay_fine = ((cfg->g_delay % 920) * 10) / 60;\n\n\ta_delay_coarse = cfg->a_delay / ival->cdpe;\n\ta_delay_fine = ((cfg->a_delay % ival->cdpe) * 10) / ival->fdpe;\n\n\tc_elements = g_delay_coarse + a_delay_coarse;\n\tf_elements = (g_delay_fine + a_delay_fine) / 10;\n\n\tif (f_elements > 22) {\n\t\ttotal_delay = c_elements * ival->cdpe + f_elements * ival->fdpe;\n\t\tc_elements = total_delay / ival->cdpe;\n\t\tf_elements = (total_delay % ival->cdpe) / ival->fdpe;\n\t}\n\n\treg_mask = reg->signature_mask;\n\treg_val = reg->signature_value << __ffs(reg->signature_mask);\n\n\treg_mask |= reg->binary_data_coarse_mask;\n\ttmp_val = c_elements << __ffs(reg->binary_data_coarse_mask);\n\tif (tmp_val & ~reg->binary_data_coarse_mask) {\n\t\tdev_err(dev, \"Masking overflow of coarse elements %08x\\n\",\n\t\t\ttmp_val);\n\t\ttmp_val &= reg->binary_data_coarse_mask;\n\t}\n\treg_val |= tmp_val;\n\n\treg_mask |= reg->binary_data_fine_mask;\n\ttmp_val = f_elements << __ffs(reg->binary_data_fine_mask);\n\tif (tmp_val & ~reg->binary_data_fine_mask) {\n\t\tdev_err(dev, \"Masking overflow of fine elements %08x\\n\",\n\t\t\ttmp_val);\n\t\ttmp_val &= reg->binary_data_fine_mask;\n\t}\n\treg_val |= tmp_val;\n\n\t \n\treg_mask |= reg->lock_mask;\n\treg_val |= reg->unlock_val << __ffs(reg->lock_mask);\n\tr = regmap_update_bits(iod->regmap, cfg->offset, reg_mask, reg_val);\n\n\tdev_dbg(dev, \"Set reg 0x%x Delay(a: %d g: %d), Elements(C=%d F=%d)0x%x\\n\",\n\t\tcfg->offset, cfg->a_delay, cfg->g_delay, c_elements,\n\t\tf_elements, reg_val);\n\n\treturn r;\n}\n\n \nstatic int ti_iodelay_pinconf_init_dev(struct ti_iodelay_device *iod)\n{\n\tconst struct ti_iodelay_reg_data *reg = iod->reg_data;\n\tstruct device *dev = iod->dev;\n\tstruct ti_iodelay_reg_values *ival = &iod->reg_init_conf_values;\n\tu32 val;\n\tint r;\n\n\t \n\tr = regmap_update_bits(iod->regmap, reg->reg_global_lock_offset,\n\t\t\t       reg->global_lock_mask, reg->global_unlock_val);\n\tif (r)\n\t\treturn r;\n\n\t \n\tr = regmap_read(iod->regmap, reg->reg_refclk_offset, &val);\n\tif (r)\n\t\treturn r;\n\tival->ref_clk_period = ti_iodelay_extract(val, reg->refclk_period_mask);\n\tdev_dbg(dev, \"refclk_period=0x%04x\\n\", ival->ref_clk_period);\n\n\tr = regmap_read(iod->regmap, reg->reg_coarse_offset, &val);\n\tif (r)\n\t\treturn r;\n\tival->coarse_ref_count =\n\t    ti_iodelay_extract(val, reg->coarse_ref_count_mask);\n\tival->coarse_delay_count =\n\t    ti_iodelay_extract(val, reg->coarse_delay_count_mask);\n\tif (!ival->coarse_delay_count) {\n\t\tdev_err(dev, \"Invalid Coarse delay count (0) (reg=0x%08x)\\n\",\n\t\t\tval);\n\t\treturn -EINVAL;\n\t}\n\tival->cdpe = ti_iodelay_compute_dpe(ival->ref_clk_period,\n\t\t\t\t\t    ival->coarse_ref_count,\n\t\t\t\t\t    ival->coarse_delay_count, 88);\n\tif (!ival->cdpe) {\n\t\tdev_err(dev, \"Invalid cdpe computed params = %d %d %d\\n\",\n\t\t\tival->ref_clk_period, ival->coarse_ref_count,\n\t\t\tival->coarse_delay_count);\n\t\treturn -EINVAL;\n\t}\n\tdev_dbg(iod->dev, \"coarse: ref=0x%04x delay=0x%04x cdpe=0x%08x\\n\",\n\t\tival->coarse_ref_count, ival->coarse_delay_count, ival->cdpe);\n\n\tr = regmap_read(iod->regmap, reg->reg_fine_offset, &val);\n\tif (r)\n\t\treturn r;\n\tival->fine_ref_count =\n\t    ti_iodelay_extract(val, reg->fine_ref_count_mask);\n\tival->fine_delay_count =\n\t    ti_iodelay_extract(val, reg->fine_delay_count_mask);\n\tif (!ival->fine_delay_count) {\n\t\tdev_err(dev, \"Invalid Fine delay count (0) (reg=0x%08x)\\n\",\n\t\t\tval);\n\t\treturn -EINVAL;\n\t}\n\tival->fdpe = ti_iodelay_compute_dpe(ival->ref_clk_period,\n\t\t\t\t\t    ival->fine_ref_count,\n\t\t\t\t\t    ival->fine_delay_count, 264);\n\tif (!ival->fdpe) {\n\t\tdev_err(dev, \"Invalid fdpe(0) computed params = %d %d %d\\n\",\n\t\t\tival->ref_clk_period, ival->fine_ref_count,\n\t\t\tival->fine_delay_count);\n\t\treturn -EINVAL;\n\t}\n\tdev_dbg(iod->dev, \"fine: ref=0x%04x delay=0x%04x fdpe=0x%08x\\n\",\n\t\tival->fine_ref_count, ival->fine_delay_count, ival->fdpe);\n\n\treturn 0;\n}\n\n \nstatic void ti_iodelay_pinconf_deinit_dev(struct ti_iodelay_device *iod)\n{\n\tconst struct ti_iodelay_reg_data *reg = iod->reg_data;\n\n\t \n\tregmap_update_bits(iod->regmap, reg->reg_global_lock_offset,\n\t\t\t   reg->global_lock_mask, reg->global_lock_val);\n}\n\n \nstatic struct ti_iodelay_pingroup *\nti_iodelay_get_pingroup(struct ti_iodelay_device *iod, unsigned int selector)\n{\n\tstruct group_desc *g;\n\n\tg = pinctrl_generic_get_group(iod->pctl, selector);\n\tif (!g) {\n\t\tdev_err(iod->dev, \"%s could not find pingroup %i\\n\", __func__,\n\t\t\tselector);\n\n\t\treturn NULL;\n\t}\n\n\treturn g->data;\n}\n\n \nstatic int ti_iodelay_offset_to_pin(struct ti_iodelay_device *iod,\n\t\t\t\t    unsigned int offset)\n{\n\tconst struct ti_iodelay_reg_data *r = iod->reg_data;\n\tunsigned int index;\n\n\tif (offset > r->regmap_config->max_register) {\n\t\tdev_err(iod->dev, \"mux offset out of range: 0x%x (0x%x)\\n\",\n\t\t\toffset, r->regmap_config->max_register);\n\t\treturn -EINVAL;\n\t}\n\n\tindex = (offset - r->reg_start_offset) / r->regmap_config->reg_stride;\n\tindex /= r->reg_nr_per_pin;\n\n\treturn index;\n}\n\n \nstatic int ti_iodelay_node_iterator(struct pinctrl_dev *pctldev,\n\t\t\t\t    struct device_node *np,\n\t\t\t\t    const struct of_phandle_args *pinctrl_spec,\n\t\t\t\t    int *pins, int pin_index, void *data)\n{\n\tstruct ti_iodelay_device *iod;\n\tstruct ti_iodelay_cfg *cfg = data;\n\tconst struct ti_iodelay_reg_data *r;\n\tstruct pinctrl_pin_desc *pd;\n\tint pin;\n\n\tiod = pinctrl_dev_get_drvdata(pctldev);\n\tif (!iod)\n\t\treturn -EINVAL;\n\n\tr = iod->reg_data;\n\n\tif (pinctrl_spec->args_count < r->reg_nr_per_pin) {\n\t\tdev_err(iod->dev, \"invalid args_count for spec: %i\\n\",\n\t\t\tpinctrl_spec->args_count);\n\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tcfg[pin_index].offset = pinctrl_spec->args[0];\n\tcfg[pin_index].a_delay = pinctrl_spec->args[1] & 0xffff;\n\tcfg[pin_index].g_delay = pinctrl_spec->args[2] & 0xffff;\n\n\tpin = ti_iodelay_offset_to_pin(iod, cfg[pin_index].offset);\n\tif (pin < 0) {\n\t\tdev_err(iod->dev, \"could not add functions for %pOFn %ux\\n\",\n\t\t\tnp, cfg[pin_index].offset);\n\t\treturn -ENODEV;\n\t}\n\tpins[pin_index] = pin;\n\n\tpd = &iod->pa[pin];\n\tpd->drv_data = &cfg[pin_index];\n\n\tdev_dbg(iod->dev, \"%pOFn offset=%x a_delay = %d g_delay = %d\\n\",\n\t\tnp, cfg[pin_index].offset, cfg[pin_index].a_delay,\n\t\tcfg[pin_index].g_delay);\n\n\treturn 0;\n}\n\n \nstatic int ti_iodelay_dt_node_to_map(struct pinctrl_dev *pctldev,\n\t\t\t\t     struct device_node *np,\n\t\t\t\t     struct pinctrl_map **map,\n\t\t\t\t     unsigned int *num_maps)\n{\n\tstruct ti_iodelay_device *iod;\n\tstruct ti_iodelay_cfg *cfg;\n\tstruct ti_iodelay_pingroup *g;\n\tconst char *name = \"pinctrl-pin-array\";\n\tint rows, *pins, error = -EINVAL, i;\n\n\tiod = pinctrl_dev_get_drvdata(pctldev);\n\tif (!iod)\n\t\treturn -EINVAL;\n\n\trows = pinctrl_count_index_with_args(np, name);\n\tif (rows < 0)\n\t\treturn rows;\n\n\t*map = devm_kzalloc(iod->dev, sizeof(**map), GFP_KERNEL);\n\tif (!*map)\n\t\treturn -ENOMEM;\n\t*num_maps = 0;\n\n\tg = devm_kzalloc(iod->dev, sizeof(*g), GFP_KERNEL);\n\tif (!g) {\n\t\terror = -ENOMEM;\n\t\tgoto free_map;\n\t}\n\n\tpins = devm_kcalloc(iod->dev, rows, sizeof(*pins), GFP_KERNEL);\n\tif (!pins) {\n\t\terror = -ENOMEM;\n\t\tgoto free_group;\n\t}\n\n\tcfg = devm_kcalloc(iod->dev, rows, sizeof(*cfg), GFP_KERNEL);\n\tif (!cfg) {\n\t\terror = -ENOMEM;\n\t\tgoto free_pins;\n\t}\n\n\tfor (i = 0; i < rows; i++) {\n\t\tstruct of_phandle_args pinctrl_spec;\n\n\t\terror = pinctrl_parse_index_with_args(np, name, i,\n\t\t\t\t\t\t      &pinctrl_spec);\n\t\tif (error)\n\t\t\tgoto free_data;\n\n\t\terror = ti_iodelay_node_iterator(pctldev, np, &pinctrl_spec,\n\t\t\t\t\t\t pins, i, cfg);\n\t\tif (error)\n\t\t\tgoto free_data;\n\t}\n\n\tg->cfg = cfg;\n\tg->ncfg = i;\n\tg->config = PIN_CONFIG_END;\n\n\terror = pinctrl_generic_add_group(iod->pctl, np->name, pins, i, g);\n\tif (error < 0)\n\t\tgoto free_data;\n\n\t(*map)->type = PIN_MAP_TYPE_CONFIGS_GROUP;\n\t(*map)->data.configs.group_or_pin = np->name;\n\t(*map)->data.configs.configs = &g->config;\n\t(*map)->data.configs.num_configs = 1;\n\t*num_maps = 1;\n\n\treturn 0;\n\nfree_data:\n\tdevm_kfree(iod->dev, cfg);\nfree_pins:\n\tdevm_kfree(iod->dev, pins);\nfree_group:\n\tdevm_kfree(iod->dev, g);\nfree_map:\n\tdevm_kfree(iod->dev, *map);\n\n\treturn error;\n}\n\n \nstatic int ti_iodelay_pinconf_group_get(struct pinctrl_dev *pctldev,\n\t\t\t\t\tunsigned int selector,\n\t\t\t\t\tunsigned long *config)\n{\n\tstruct ti_iodelay_device *iod;\n\tstruct ti_iodelay_pingroup *group;\n\n\tiod = pinctrl_dev_get_drvdata(pctldev);\n\tgroup = ti_iodelay_get_pingroup(iod, selector);\n\n\tif (!group)\n\t\treturn -EINVAL;\n\n\t*config = group->config;\n\treturn 0;\n}\n\n \nstatic int ti_iodelay_pinconf_group_set(struct pinctrl_dev *pctldev,\n\t\t\t\t\tunsigned int selector,\n\t\t\t\t\tunsigned long *configs,\n\t\t\t\t\tunsigned int num_configs)\n{\n\tstruct ti_iodelay_device *iod;\n\tstruct device *dev;\n\tstruct ti_iodelay_pingroup *group;\n\tint i;\n\n\tiod = pinctrl_dev_get_drvdata(pctldev);\n\tdev = iod->dev;\n\tgroup = ti_iodelay_get_pingroup(iod, selector);\n\n\tif (num_configs != 1) {\n\t\tdev_err(dev, \"Unsupported number of configurations %d\\n\",\n\t\t\tnum_configs);\n\t\treturn -EINVAL;\n\t}\n\n\tif (*configs != PIN_CONFIG_END) {\n\t\tdev_err(dev, \"Unsupported configuration\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < group->ncfg; i++) {\n\t\tif (ti_iodelay_pinconf_set(iod, &group->cfg[i]))\n\t\t\treturn -ENOTSUPP;\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_DEBUG_FS\n \nstatic unsigned int ti_iodelay_pin_to_offset(struct ti_iodelay_device *iod,\n\t\t\t\t\t     unsigned int selector)\n{\n\tconst struct ti_iodelay_reg_data *r = iod->reg_data;\n\tunsigned int offset;\n\n\toffset = selector * r->regmap_config->reg_stride;\n\toffset *= r->reg_nr_per_pin;\n\toffset += r->reg_start_offset;\n\n\treturn offset;\n}\n\nstatic void ti_iodelay_pin_dbg_show(struct pinctrl_dev *pctldev,\n\t\t\t\t    struct seq_file *s,\n\t\t\t\t    unsigned int pin)\n{\n\tstruct ti_iodelay_device *iod;\n\tstruct pinctrl_pin_desc *pd;\n\tstruct ti_iodelay_cfg *cfg;\n\tconst struct ti_iodelay_reg_data *r;\n\tunsigned long offset;\n\tu32 in, oen, out;\n\n\tiod = pinctrl_dev_get_drvdata(pctldev);\n\tr = iod->reg_data;\n\n\toffset = ti_iodelay_pin_to_offset(iod, pin);\n\tpd = &iod->pa[pin];\n\tcfg = pd->drv_data;\n\n\tregmap_read(iod->regmap, offset, &in);\n\tregmap_read(iod->regmap, offset + r->regmap_config->reg_stride, &oen);\n\tregmap_read(iod->regmap, offset + r->regmap_config->reg_stride * 2,\n\t\t    &out);\n\n\tseq_printf(s, \"%lx a: %i g: %i (%08x %08x %08x) %s \",\n\t\t   iod->phys_base + offset,\n\t\t   cfg ? cfg->a_delay : -1,\n\t\t   cfg ? cfg->g_delay : -1,\n\t\t   in, oen, out, DRIVER_NAME);\n}\n\n \nstatic void ti_iodelay_pinconf_group_dbg_show(struct pinctrl_dev *pctldev,\n\t\t\t\t\t      struct seq_file *s,\n\t\t\t\t\t      unsigned int selector)\n{\n\tstruct ti_iodelay_device *iod;\n\tstruct ti_iodelay_pingroup *group;\n\tint i;\n\n\tiod = pinctrl_dev_get_drvdata(pctldev);\n\tgroup = ti_iodelay_get_pingroup(iod, selector);\n\tif (!group)\n\t\treturn;\n\n\tfor (i = 0; i < group->ncfg; i++) {\n\t\tstruct ti_iodelay_cfg *cfg;\n\t\tu32 reg = 0;\n\n\t\tcfg = &group->cfg[i];\n\t\tregmap_read(iod->regmap, cfg->offset, &reg);\n\t\tseq_printf(s, \"\\n\\t0x%08x = 0x%08x (%3d, %3d)\",\n\t\t\tcfg->offset, reg, cfg->a_delay, cfg->g_delay);\n\t}\n}\n#endif\n\nstatic const struct pinctrl_ops ti_iodelay_pinctrl_ops = {\n\t.get_groups_count = pinctrl_generic_get_group_count,\n\t.get_group_name = pinctrl_generic_get_group_name,\n\t.get_group_pins = pinctrl_generic_get_group_pins,\n#ifdef CONFIG_DEBUG_FS\n\t.pin_dbg_show = ti_iodelay_pin_dbg_show,\n#endif\n\t.dt_node_to_map = ti_iodelay_dt_node_to_map,\n};\n\nstatic const struct pinconf_ops ti_iodelay_pinctrl_pinconf_ops = {\n\t.pin_config_group_get = ti_iodelay_pinconf_group_get,\n\t.pin_config_group_set = ti_iodelay_pinconf_group_set,\n#ifdef CONFIG_DEBUG_FS\n\t.pin_config_group_dbg_show = ti_iodelay_pinconf_group_dbg_show,\n#endif\n};\n\n \nstatic int ti_iodelay_alloc_pins(struct device *dev,\n\t\t\t\t struct ti_iodelay_device *iod, u32 base_phy)\n{\n\tconst struct ti_iodelay_reg_data *r = iod->reg_data;\n\tstruct pinctrl_pin_desc *pin;\n\tu32 phy_reg;\n\tint nr_pins, i;\n\n\tnr_pins = ti_iodelay_offset_to_pin(iod, r->regmap_config->max_register);\n\tdev_dbg(dev, \"Allocating %i pins\\n\", nr_pins);\n\n\tiod->pa = devm_kcalloc(dev, nr_pins, sizeof(*iod->pa), GFP_KERNEL);\n\tif (!iod->pa)\n\t\treturn -ENOMEM;\n\n\tiod->desc.pins = iod->pa;\n\tiod->desc.npins = nr_pins;\n\n\tphy_reg = r->reg_start_offset + base_phy;\n\n\tfor (i = 0; i < nr_pins; i++, phy_reg += 4) {\n\t\tpin = &iod->pa[i];\n\t\tpin->number = i;\n\t}\n\n\treturn 0;\n}\n\nstatic struct regmap_config dra7_iodelay_regmap_config = {\n\t.reg_bits = 32,\n\t.reg_stride = 4,\n\t.val_bits = 32,\n\t.max_register = 0xd1c,\n};\n\nstatic struct ti_iodelay_reg_data dra7_iodelay_data = {\n\t.signature_mask = 0x0003f000,\n\t.signature_value = 0x29,\n\t.lock_mask = 0x00000400,\n\t.lock_val = 1,\n\t.unlock_val = 0,\n\t.binary_data_coarse_mask = 0x000003e0,\n\t.binary_data_fine_mask = 0x0000001f,\n\n\t.reg_refclk_offset = 0x14,\n\t.refclk_period_mask = 0xffff,\n\n\t.reg_coarse_offset = 0x18,\n\t.coarse_delay_count_mask = 0xffff0000,\n\t.coarse_ref_count_mask = 0x0000ffff,\n\n\t.reg_fine_offset = 0x1C,\n\t.fine_delay_count_mask = 0xffff0000,\n\t.fine_ref_count_mask = 0x0000ffff,\n\n\t.reg_global_lock_offset = 0x2c,\n\t.global_lock_mask = 0x0000ffff,\n\t.global_unlock_val = 0x0000aaaa,\n\t.global_lock_val = 0x0000aaab,\n\n\t.reg_start_offset = 0x30,\n\t.reg_nr_per_pin = 3,\n\t.regmap_config = &dra7_iodelay_regmap_config,\n};\n\nstatic const struct of_device_id ti_iodelay_of_match[] = {\n\t{.compatible = \"ti,dra7-iodelay\", .data = &dra7_iodelay_data},\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, ti_iodelay_of_match);\n\n \nstatic int ti_iodelay_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = of_node_get(dev->of_node);\n\tconst struct of_device_id *match;\n\tstruct resource *res;\n\tstruct ti_iodelay_device *iod;\n\tint ret = 0;\n\n\tif (!np) {\n\t\tret = -EINVAL;\n\t\tdev_err(dev, \"No OF node\\n\");\n\t\tgoto exit_out;\n\t}\n\n\tmatch = of_match_device(ti_iodelay_of_match, dev);\n\tif (!match) {\n\t\tret = -EINVAL;\n\t\tdev_err(dev, \"No DATA match\\n\");\n\t\tgoto exit_out;\n\t}\n\n\tiod = devm_kzalloc(dev, sizeof(*iod), GFP_KERNEL);\n\tif (!iod) {\n\t\tret = -ENOMEM;\n\t\tgoto exit_out;\n\t}\n\tiod->dev = dev;\n\tiod->reg_data = match->data;\n\n\t \n\tiod->reg_base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(iod->reg_base)) {\n\t\tret = PTR_ERR(iod->reg_base);\n\t\tgoto exit_out;\n\t}\n\tiod->phys_base = res->start;\n\n\tiod->regmap = devm_regmap_init_mmio(dev, iod->reg_base,\n\t\t\t\t\t    iod->reg_data->regmap_config);\n\tif (IS_ERR(iod->regmap)) {\n\t\tdev_err(dev, \"Regmap MMIO init failed.\\n\");\n\t\tret = PTR_ERR(iod->regmap);\n\t\tgoto exit_out;\n\t}\n\n\tret = ti_iodelay_pinconf_init_dev(iod);\n\tif (ret)\n\t\tgoto exit_out;\n\n\tret = ti_iodelay_alloc_pins(dev, iod, res->start);\n\tif (ret)\n\t\tgoto exit_out;\n\n\tiod->desc.pctlops = &ti_iodelay_pinctrl_ops;\n\t \n\tiod->desc.confops = &ti_iodelay_pinctrl_pinconf_ops;\n\tiod->desc.name = dev_name(dev);\n\tiod->desc.owner = THIS_MODULE;\n\n\tret = pinctrl_register_and_init(&iod->desc, dev, iod, &iod->pctl);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to register pinctrl\\n\");\n\t\tgoto exit_out;\n\t}\n\n\tplatform_set_drvdata(pdev, iod);\n\n\treturn pinctrl_enable(iod->pctl);\n\nexit_out:\n\tof_node_put(np);\n\treturn ret;\n}\n\n \nstatic int ti_iodelay_remove(struct platform_device *pdev)\n{\n\tstruct ti_iodelay_device *iod = platform_get_drvdata(pdev);\n\n\tif (!iod)\n\t\treturn 0;\n\n\tif (iod->pctl)\n\t\tpinctrl_unregister(iod->pctl);\n\n\tti_iodelay_pinconf_deinit_dev(iod);\n\n\t \n\n\treturn 0;\n}\n\nstatic struct platform_driver ti_iodelay_driver = {\n\t.probe = ti_iodelay_probe,\n\t.remove = ti_iodelay_remove,\n\t.driver = {\n\t\t   .name = DRIVER_NAME,\n\t\t   .of_match_table = ti_iodelay_of_match,\n\t},\n};\nmodule_platform_driver(ti_iodelay_driver);\n\nMODULE_AUTHOR(\"Texas Instruments, Inc.\");\nMODULE_DESCRIPTION(\"Pinconf driver for TI's IO Delay module\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}