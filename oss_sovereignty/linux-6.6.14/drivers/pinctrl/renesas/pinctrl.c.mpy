{
  "module_name": "pinctrl.c",
  "hash_id": "961b152371bc7590ed8b381dd9ba07e87ece4ac1416f6ce6b6d4ca36c54ad082",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/renesas/pinctrl.c",
  "human_readable_source": "\n \n\n#define DRV_NAME \"sh-pfc\"\n\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\n#include <linux/pinctrl/consumer.h>\n#include <linux/pinctrl/machine.h>\n#include <linux/pinctrl/pinconf-generic.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinmux.h>\n\n#include \"core.h\"\n#include \"../core.h\"\n#include \"../pinconf.h\"\n\nstruct sh_pfc_pin_config {\n\tu16 gpio_enabled:1;\n\tu16 mux_mark:15;\n};\n\nstruct sh_pfc_pinctrl {\n\tstruct pinctrl_dev *pctl;\n\tstruct pinctrl_desc pctl_desc;\n\n\tstruct sh_pfc *pfc;\n\n\tstruct pinctrl_pin_desc *pins;\n\tstruct sh_pfc_pin_config *configs;\n};\n\nstatic int sh_pfc_get_groups_count(struct pinctrl_dev *pctldev)\n{\n\tstruct sh_pfc_pinctrl *pmx = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pmx->pfc->info->nr_groups;\n}\n\nstatic const char *sh_pfc_get_group_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t unsigned selector)\n{\n\tstruct sh_pfc_pinctrl *pmx = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pmx->pfc->info->groups[selector].name;\n}\n\nstatic int sh_pfc_get_group_pins(struct pinctrl_dev *pctldev, unsigned selector,\n\t\t\t\t const unsigned **pins, unsigned *num_pins)\n{\n\tstruct sh_pfc_pinctrl *pmx = pinctrl_dev_get_drvdata(pctldev);\n\n\t*pins = pmx->pfc->info->groups[selector].pins;\n\t*num_pins = pmx->pfc->info->groups[selector].nr_pins;\n\n\treturn 0;\n}\n\nstatic void sh_pfc_pin_dbg_show(struct pinctrl_dev *pctldev, struct seq_file *s,\n\t\t\t\tunsigned offset)\n{\n\tseq_puts(s, DRV_NAME);\n}\n\n#ifdef CONFIG_OF\nstatic int sh_pfc_map_add_config(struct pinctrl_map *map,\n\t\t\t\t const char *group_or_pin,\n\t\t\t\t enum pinctrl_map_type type,\n\t\t\t\t unsigned long *configs,\n\t\t\t\t unsigned int num_configs)\n{\n\tunsigned long *cfgs;\n\n\tcfgs = kmemdup(configs, num_configs * sizeof(*cfgs),\n\t\t       GFP_KERNEL);\n\tif (cfgs == NULL)\n\t\treturn -ENOMEM;\n\n\tmap->type = type;\n\tmap->data.configs.group_or_pin = group_or_pin;\n\tmap->data.configs.configs = cfgs;\n\tmap->data.configs.num_configs = num_configs;\n\n\treturn 0;\n}\n\nstatic int sh_pfc_dt_subnode_to_map(struct pinctrl_dev *pctldev,\n\t\t\t\t    struct device_node *np,\n\t\t\t\t    struct pinctrl_map **map,\n\t\t\t\t    unsigned int *num_maps, unsigned int *index)\n{\n\tstruct sh_pfc_pinctrl *pmx = pinctrl_dev_get_drvdata(pctldev);\n\tstruct device *dev = pmx->pfc->dev;\n\tstruct pinctrl_map *maps = *map;\n\tunsigned int nmaps = *num_maps;\n\tunsigned int idx = *index;\n\tunsigned int num_configs;\n\tconst char *function = NULL;\n\tunsigned long *configs;\n\tstruct property *prop;\n\tunsigned int num_groups;\n\tunsigned int num_pins;\n\tconst char *group;\n\tconst char *pin;\n\tint ret;\n\n\t \n\tret = of_property_read_string(np, \"function\", &function);\n\tif (ret < 0 && ret != -EINVAL) {\n\t\tdev_err(dev, \"Invalid function in DT\\n\");\n\t\treturn ret;\n\t}\n\n\tret = pinconf_generic_parse_dt_config(np, NULL, &configs, &num_configs);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!function && num_configs == 0) {\n\t\tdev_err(dev,\n\t\t\t\"DT node must contain at least a function or config\\n\");\n\t\tret = -ENODEV;\n\t\tgoto done;\n\t}\n\n\t \n\tret = of_property_count_strings(np, \"pins\");\n\tif (ret == -EINVAL) {\n\t\tnum_pins = 0;\n\t} else if (ret < 0) {\n\t\tdev_err(dev, \"Invalid pins list in DT\\n\");\n\t\tgoto done;\n\t} else {\n\t\tnum_pins = ret;\n\t}\n\n\tret = of_property_count_strings(np, \"groups\");\n\tif (ret == -EINVAL) {\n\t\tnum_groups = 0;\n\t} else if (ret < 0) {\n\t\tdev_err(dev, \"Invalid pin groups list in DT\\n\");\n\t\tgoto done;\n\t} else {\n\t\tnum_groups = ret;\n\t}\n\n\tif (!num_pins && !num_groups) {\n\t\tdev_err(dev, \"No pin or group provided in DT node\\n\");\n\t\tret = -ENODEV;\n\t\tgoto done;\n\t}\n\n\tif (function)\n\t\tnmaps += num_groups;\n\tif (configs)\n\t\tnmaps += num_pins + num_groups;\n\n\tmaps = krealloc(maps, sizeof(*maps) * nmaps, GFP_KERNEL);\n\tif (maps == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\t*map = maps;\n\t*num_maps = nmaps;\n\n\t \n\tof_property_for_each_string(np, \"groups\", prop, group) {\n\t\tif (function) {\n\t\t\tmaps[idx].type = PIN_MAP_TYPE_MUX_GROUP;\n\t\t\tmaps[idx].data.mux.group = group;\n\t\t\tmaps[idx].data.mux.function = function;\n\t\t\tidx++;\n\t\t}\n\n\t\tif (configs) {\n\t\t\tret = sh_pfc_map_add_config(&maps[idx], group,\n\t\t\t\t\t\t    PIN_MAP_TYPE_CONFIGS_GROUP,\n\t\t\t\t\t\t    configs, num_configs);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto done;\n\n\t\t\tidx++;\n\t\t}\n\t}\n\n\tif (!configs) {\n\t\tret = 0;\n\t\tgoto done;\n\t}\n\n\tof_property_for_each_string(np, \"pins\", prop, pin) {\n\t\tret = sh_pfc_map_add_config(&maps[idx], pin,\n\t\t\t\t\t    PIN_MAP_TYPE_CONFIGS_PIN,\n\t\t\t\t\t    configs, num_configs);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\n\t\tidx++;\n\t}\n\ndone:\n\t*index = idx;\n\tkfree(configs);\n\treturn ret;\n}\n\nstatic void sh_pfc_dt_free_map(struct pinctrl_dev *pctldev,\n\t\t\t       struct pinctrl_map *map, unsigned num_maps)\n{\n\tunsigned int i;\n\n\tif (map == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < num_maps; ++i) {\n\t\tif (map[i].type == PIN_MAP_TYPE_CONFIGS_GROUP ||\n\t\t    map[i].type == PIN_MAP_TYPE_CONFIGS_PIN)\n\t\t\tkfree(map[i].data.configs.configs);\n\t}\n\n\tkfree(map);\n}\n\nstatic int sh_pfc_dt_node_to_map(struct pinctrl_dev *pctldev,\n\t\t\t\t struct device_node *np,\n\t\t\t\t struct pinctrl_map **map, unsigned *num_maps)\n{\n\tstruct sh_pfc_pinctrl *pmx = pinctrl_dev_get_drvdata(pctldev);\n\tstruct device *dev = pmx->pfc->dev;\n\tstruct device_node *child;\n\tunsigned int index;\n\tint ret;\n\n\t*map = NULL;\n\t*num_maps = 0;\n\tindex = 0;\n\n\tfor_each_child_of_node(np, child) {\n\t\tret = sh_pfc_dt_subnode_to_map(pctldev, child, map, num_maps,\n\t\t\t\t\t       &index);\n\t\tif (ret < 0) {\n\t\t\tof_node_put(child);\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t \n\tif (*num_maps == 0) {\n\t\tret = sh_pfc_dt_subnode_to_map(pctldev, np, map, num_maps,\n\t\t\t\t\t       &index);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\t}\n\n\tif (*num_maps)\n\t\treturn 0;\n\n\tdev_err(dev, \"no mapping found in node %pOF\\n\", np);\n\tret = -EINVAL;\n\ndone:\n\tif (ret < 0)\n\t\tsh_pfc_dt_free_map(pctldev, *map, *num_maps);\n\n\treturn ret;\n}\n#endif  \n\nstatic const struct pinctrl_ops sh_pfc_pinctrl_ops = {\n\t.get_groups_count\t= sh_pfc_get_groups_count,\n\t.get_group_name\t\t= sh_pfc_get_group_name,\n\t.get_group_pins\t\t= sh_pfc_get_group_pins,\n\t.pin_dbg_show\t\t= sh_pfc_pin_dbg_show,\n#ifdef CONFIG_OF\n\t.dt_node_to_map\t\t= sh_pfc_dt_node_to_map,\n\t.dt_free_map\t\t= sh_pfc_dt_free_map,\n#endif\n};\n\nstatic int sh_pfc_get_functions_count(struct pinctrl_dev *pctldev)\n{\n\tstruct sh_pfc_pinctrl *pmx = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pmx->pfc->info->nr_functions;\n}\n\nstatic const char *sh_pfc_get_function_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t    unsigned selector)\n{\n\tstruct sh_pfc_pinctrl *pmx = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pmx->pfc->info->functions[selector].name;\n}\n\nstatic int sh_pfc_get_function_groups(struct pinctrl_dev *pctldev,\n\t\t\t\t      unsigned selector,\n\t\t\t\t      const char * const **groups,\n\t\t\t\t      unsigned * const num_groups)\n{\n\tstruct sh_pfc_pinctrl *pmx = pinctrl_dev_get_drvdata(pctldev);\n\n\t*groups = pmx->pfc->info->functions[selector].groups;\n\t*num_groups = pmx->pfc->info->functions[selector].nr_groups;\n\n\treturn 0;\n}\n\nstatic int sh_pfc_func_set_mux(struct pinctrl_dev *pctldev, unsigned selector,\n\t\t\t       unsigned group)\n{\n\tstruct sh_pfc_pinctrl *pmx = pinctrl_dev_get_drvdata(pctldev);\n\tstruct sh_pfc *pfc = pmx->pfc;\n\tconst struct sh_pfc_pin_group *grp = &pfc->info->groups[group];\n\tunsigned long flags;\n\tunsigned int i;\n\tint ret = 0;\n\n\tdev_dbg(pctldev->dev, \"Configuring pin group %s\\n\", grp->name);\n\n\tspin_lock_irqsave(&pfc->lock, flags);\n\n\tfor (i = 0; i < grp->nr_pins; ++i) {\n\t\tint idx = sh_pfc_get_pin_index(pfc, grp->pins[i]);\n\t\tstruct sh_pfc_pin_config *cfg = &pmx->configs[idx];\n\n\t\t \n\t\tif (cfg->gpio_enabled) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto done;\n\t\t}\n\n\t\tret = sh_pfc_config_mux(pfc, grp->mux[i], PINMUX_TYPE_FUNCTION);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\t}\n\n\t \n\tfor (i = 0; i < grp->nr_pins; ++i) {\n\t\tint idx = sh_pfc_get_pin_index(pfc, grp->pins[i]);\n\t\tstruct sh_pfc_pin_config *cfg = &pmx->configs[idx];\n\n\t\tcfg->mux_mark = grp->mux[i];\n\t}\n\ndone:\n\tspin_unlock_irqrestore(&pfc->lock, flags);\n\treturn ret;\n}\n\nstatic int sh_pfc_gpio_request_enable(struct pinctrl_dev *pctldev,\n\t\t\t\t      struct pinctrl_gpio_range *range,\n\t\t\t\t      unsigned offset)\n{\n\tstruct sh_pfc_pinctrl *pmx = pinctrl_dev_get_drvdata(pctldev);\n\tstruct sh_pfc *pfc = pmx->pfc;\n\tint idx = sh_pfc_get_pin_index(pfc, offset);\n\tstruct sh_pfc_pin_config *cfg = &pmx->configs[idx];\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&pfc->lock, flags);\n\n\tif (!pfc->gpio && !cfg->mux_mark) {\n\t\t \n\t\tconst struct sh_pfc_pin *pin = &pfc->info->pins[idx];\n\n\t\tret = sh_pfc_config_mux(pfc, pin->enum_id, PINMUX_TYPE_GPIO);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\t}\n\n\tcfg->gpio_enabled = true;\n\n\tret = 0;\n\ndone:\n\tspin_unlock_irqrestore(&pfc->lock, flags);\n\n\treturn ret;\n}\n\nstatic void sh_pfc_gpio_disable_free(struct pinctrl_dev *pctldev,\n\t\t\t\t     struct pinctrl_gpio_range *range,\n\t\t\t\t     unsigned offset)\n{\n\tstruct sh_pfc_pinctrl *pmx = pinctrl_dev_get_drvdata(pctldev);\n\tstruct sh_pfc *pfc = pmx->pfc;\n\tint idx = sh_pfc_get_pin_index(pfc, offset);\n\tstruct sh_pfc_pin_config *cfg = &pmx->configs[idx];\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pfc->lock, flags);\n\tcfg->gpio_enabled = false;\n\t \n\tif (cfg->mux_mark)\n\t\tsh_pfc_config_mux(pfc, cfg->mux_mark, PINMUX_TYPE_FUNCTION);\n\tspin_unlock_irqrestore(&pfc->lock, flags);\n}\n\n#ifdef CONFIG_PINCTRL_SH_PFC_GPIO\nstatic int sh_pfc_gpio_set_direction(struct pinctrl_dev *pctldev,\n\t\t\t\t     struct pinctrl_gpio_range *range,\n\t\t\t\t     unsigned offset, bool input)\n{\n\tstruct sh_pfc_pinctrl *pmx = pinctrl_dev_get_drvdata(pctldev);\n\tstruct sh_pfc *pfc = pmx->pfc;\n\tint new_type = input ? PINMUX_TYPE_INPUT : PINMUX_TYPE_OUTPUT;\n\tint idx = sh_pfc_get_pin_index(pfc, offset);\n\tconst struct sh_pfc_pin *pin = &pfc->info->pins[idx];\n\tunsigned long flags;\n\tunsigned int dir;\n\tint ret;\n\n\t \n\tif (pin->configs) {\n\t\tdir = input ? SH_PFC_PIN_CFG_INPUT : SH_PFC_PIN_CFG_OUTPUT;\n\t\tif (!(pin->configs & dir))\n\t\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(&pfc->lock, flags);\n\tret = sh_pfc_config_mux(pfc, pin->enum_id, new_type);\n\tspin_unlock_irqrestore(&pfc->lock, flags);\n\treturn ret;\n}\n#else\n#define sh_pfc_gpio_set_direction\tNULL\n#endif\n\nstatic const struct pinmux_ops sh_pfc_pinmux_ops = {\n\t.get_functions_count\t= sh_pfc_get_functions_count,\n\t.get_function_name\t= sh_pfc_get_function_name,\n\t.get_function_groups\t= sh_pfc_get_function_groups,\n\t.set_mux\t\t= sh_pfc_func_set_mux,\n\t.gpio_request_enable\t= sh_pfc_gpio_request_enable,\n\t.gpio_disable_free\t= sh_pfc_gpio_disable_free,\n\t.gpio_set_direction\t= sh_pfc_gpio_set_direction,\n};\n\nstatic u32 sh_pfc_pinconf_find_drive_strength_reg(struct sh_pfc *pfc,\n\t\tunsigned int pin, unsigned int *offset, unsigned int *size)\n{\n\tconst struct pinmux_drive_reg_field *field;\n\tconst struct pinmux_drive_reg *reg;\n\tunsigned int i;\n\n\tfor (reg = pfc->info->drive_regs; reg->reg; ++reg) {\n\t\tfor (i = 0; i < ARRAY_SIZE(reg->fields); ++i) {\n\t\t\tfield = &reg->fields[i];\n\n\t\t\tif (field->size && field->pin == pin) {\n\t\t\t\t*offset = field->offset;\n\t\t\t\t*size = field->size;\n\n\t\t\t\treturn reg->reg;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int sh_pfc_pinconf_get_drive_strength(struct sh_pfc *pfc,\n\t\t\t\t\t     unsigned int pin)\n{\n\tunsigned int offset;\n\tunsigned int size;\n\tu32 reg;\n\tu32 val;\n\n\treg = sh_pfc_pinconf_find_drive_strength_reg(pfc, pin, &offset, &size);\n\tif (!reg)\n\t\treturn -EINVAL;\n\n\tval = (sh_pfc_read(pfc, reg) >> offset) & GENMASK(size - 1, 0);\n\n\t \n\treturn (val + 1) * (size == 2 ? 6 : 3);\n}\n\nstatic int sh_pfc_pinconf_set_drive_strength(struct sh_pfc *pfc,\n\t\t\t\t\t     unsigned int pin, u16 strength)\n{\n\tunsigned long flags;\n\tunsigned int offset;\n\tunsigned int size;\n\tunsigned int step;\n\tu32 reg;\n\tu32 val;\n\n\treg = sh_pfc_pinconf_find_drive_strength_reg(pfc, pin, &offset, &size);\n\tif (!reg)\n\t\treturn -EINVAL;\n\n\tstep = size == 2 ? 6 : 3;\n\n\tif (strength < step || strength > 24)\n\t\treturn -EINVAL;\n\n\t \n\tstrength = strength / step - 1;\n\n\tspin_lock_irqsave(&pfc->lock, flags);\n\n\tval = sh_pfc_read(pfc, reg);\n\tval &= ~GENMASK(offset + size - 1, offset);\n\tval |= strength << offset;\n\n\tsh_pfc_write(pfc, reg, val);\n\n\tspin_unlock_irqrestore(&pfc->lock, flags);\n\n\treturn 0;\n}\n\n \nstatic bool sh_pfc_pinconf_validate(struct sh_pfc *pfc, unsigned int _pin,\n\t\t\t\t    enum pin_config_param param)\n{\n\tint idx = sh_pfc_get_pin_index(pfc, _pin);\n\tconst struct sh_pfc_pin *pin = &pfc->info->pins[idx];\n\n\tswitch (param) {\n\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\treturn pin->configs & SH_PFC_PIN_CFG_PULL_UP_DOWN;\n\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\treturn pin->configs & SH_PFC_PIN_CFG_PULL_UP;\n\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\treturn pin->configs & SH_PFC_PIN_CFG_PULL_DOWN;\n\n\tcase PIN_CONFIG_DRIVE_STRENGTH:\n\t\treturn pin->configs & SH_PFC_PIN_CFG_DRIVE_STRENGTH;\n\n\tcase PIN_CONFIG_POWER_SOURCE:\n\t\treturn pin->configs & SH_PFC_PIN_CFG_IO_VOLTAGE_MASK;\n\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int sh_pfc_pinconf_get(struct pinctrl_dev *pctldev, unsigned _pin,\n\t\t\t      unsigned long *config)\n{\n\tstruct sh_pfc_pinctrl *pmx = pinctrl_dev_get_drvdata(pctldev);\n\tstruct sh_pfc *pfc = pmx->pfc;\n\tenum pin_config_param param = pinconf_to_config_param(*config);\n\tunsigned long flags;\n\tunsigned int arg;\n\n\tif (!sh_pfc_pinconf_validate(pfc, _pin, param))\n\t\treturn -ENOTSUPP;\n\n\tswitch (param) {\n\tcase PIN_CONFIG_BIAS_DISABLE:\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\tcase PIN_CONFIG_BIAS_PULL_DOWN: {\n\t\tunsigned int bias;\n\n\t\tif (!pfc->info->ops || !pfc->info->ops->get_bias)\n\t\t\treturn -ENOTSUPP;\n\n\t\tspin_lock_irqsave(&pfc->lock, flags);\n\t\tbias = pfc->info->ops->get_bias(pfc, _pin);\n\t\tspin_unlock_irqrestore(&pfc->lock, flags);\n\n\t\tif (bias != param)\n\t\t\treturn -EINVAL;\n\n\t\targ = 0;\n\t\tbreak;\n\t}\n\n\tcase PIN_CONFIG_DRIVE_STRENGTH: {\n\t\tint ret;\n\n\t\tret = sh_pfc_pinconf_get_drive_strength(pfc, _pin);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\targ = ret;\n\t\tbreak;\n\t}\n\n\tcase PIN_CONFIG_POWER_SOURCE: {\n\t\tint idx = sh_pfc_get_pin_index(pfc, _pin);\n\t\tconst struct sh_pfc_pin *pin = &pfc->info->pins[idx];\n\t\tunsigned int mode, lo, hi;\n\t\tu32 pocctrl, val;\n\t\tint bit;\n\n\t\tif (!pfc->info->ops || !pfc->info->ops->pin_to_pocctrl)\n\t\t\treturn -ENOTSUPP;\n\n\t\tbit = pfc->info->ops->pin_to_pocctrl(_pin, &pocctrl);\n\t\tif (WARN(bit < 0, \"invalid pin %#x\", _pin))\n\t\t\treturn bit;\n\n\t\tval = sh_pfc_read(pfc, pocctrl);\n\n\t\tmode = pin->configs & SH_PFC_PIN_CFG_IO_VOLTAGE_MASK;\n\t\tlo = mode <= SH_PFC_PIN_CFG_IO_VOLTAGE_18_33 ? 1800 : 2500;\n\t\thi = mode >= SH_PFC_PIN_CFG_IO_VOLTAGE_18_33 ? 3300 : 2500;\n\n\t\targ = (val & BIT(bit)) ? hi : lo;\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\t*config = pinconf_to_config_packed(param, arg);\n\treturn 0;\n}\n\nstatic int sh_pfc_pinconf_set(struct pinctrl_dev *pctldev, unsigned _pin,\n\t\t\t      unsigned long *configs, unsigned num_configs)\n{\n\tstruct sh_pfc_pinctrl *pmx = pinctrl_dev_get_drvdata(pctldev);\n\tstruct sh_pfc *pfc = pmx->pfc;\n\tenum pin_config_param param;\n\tunsigned long flags;\n\tunsigned int i;\n\n\tfor (i = 0; i < num_configs; i++) {\n\t\tparam = pinconf_to_config_param(configs[i]);\n\n\t\tif (!sh_pfc_pinconf_validate(pfc, _pin, param))\n\t\t\treturn -ENOTSUPP;\n\n\t\tswitch (param) {\n\t\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\t\tif (!pfc->info->ops || !pfc->info->ops->set_bias)\n\t\t\t\treturn -ENOTSUPP;\n\n\t\t\tspin_lock_irqsave(&pfc->lock, flags);\n\t\t\tpfc->info->ops->set_bias(pfc, _pin, param);\n\t\t\tspin_unlock_irqrestore(&pfc->lock, flags);\n\n\t\t\tbreak;\n\n\t\tcase PIN_CONFIG_DRIVE_STRENGTH: {\n\t\t\tunsigned int arg =\n\t\t\t\tpinconf_to_config_argument(configs[i]);\n\t\t\tint ret;\n\n\t\t\tret = sh_pfc_pinconf_set_drive_strength(pfc, _pin, arg);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tbreak;\n\t\t}\n\n\t\tcase PIN_CONFIG_POWER_SOURCE: {\n\t\t\tunsigned int mV = pinconf_to_config_argument(configs[i]);\n\t\t\tint idx = sh_pfc_get_pin_index(pfc, _pin);\n\t\t\tconst struct sh_pfc_pin *pin = &pfc->info->pins[idx];\n\t\t\tunsigned int mode, lo, hi;\n\t\t\tu32 pocctrl, val;\n\t\t\tint bit;\n\n\t\t\tif (!pfc->info->ops || !pfc->info->ops->pin_to_pocctrl)\n\t\t\t\treturn -ENOTSUPP;\n\n\t\t\tbit = pfc->info->ops->pin_to_pocctrl(_pin, &pocctrl);\n\t\t\tif (WARN(bit < 0, \"invalid pin %#x\", _pin))\n\t\t\t\treturn bit;\n\n\t\t\tmode = pin->configs & SH_PFC_PIN_CFG_IO_VOLTAGE_MASK;\n\t\t\tlo = mode <= SH_PFC_PIN_CFG_IO_VOLTAGE_18_33 ? 1800 : 2500;\n\t\t\thi = mode >= SH_PFC_PIN_CFG_IO_VOLTAGE_18_33 ? 3300 : 2500;\n\n\t\t\tif (mV != lo && mV != hi)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tspin_lock_irqsave(&pfc->lock, flags);\n\t\t\tval = sh_pfc_read(pfc, pocctrl);\n\t\t\tif (mV == hi)\n\t\t\t\tval |= BIT(bit);\n\t\t\telse\n\t\t\t\tval &= ~BIT(bit);\n\t\t\tsh_pfc_write(pfc, pocctrl, val);\n\t\t\tspin_unlock_irqrestore(&pfc->lock, flags);\n\n\t\t\tbreak;\n\t\t}\n\n\t\tdefault:\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t}  \n\n\treturn 0;\n}\n\nstatic int sh_pfc_pinconf_group_set(struct pinctrl_dev *pctldev, unsigned group,\n\t\t\t\t    unsigned long *configs,\n\t\t\t\t    unsigned num_configs)\n{\n\tstruct sh_pfc_pinctrl *pmx = pinctrl_dev_get_drvdata(pctldev);\n\tconst unsigned int *pins;\n\tunsigned int num_pins;\n\tunsigned int i, ret;\n\n\tpins = pmx->pfc->info->groups[group].pins;\n\tnum_pins = pmx->pfc->info->groups[group].nr_pins;\n\n\tfor (i = 0; i < num_pins; ++i) {\n\t\tret = sh_pfc_pinconf_set(pctldev, pins[i], configs, num_configs);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct pinconf_ops sh_pfc_pinconf_ops = {\n\t.is_generic\t\t\t= true,\n\t.pin_config_get\t\t\t= sh_pfc_pinconf_get,\n\t.pin_config_set\t\t\t= sh_pfc_pinconf_set,\n\t.pin_config_group_set\t\t= sh_pfc_pinconf_group_set,\n\t.pin_config_config_dbg_show\t= pinconf_generic_dump_config,\n};\n\n \nstatic int sh_pfc_map_pins(struct sh_pfc *pfc, struct sh_pfc_pinctrl *pmx)\n{\n\tunsigned int i;\n\n\t \n\tpmx->pins = devm_kcalloc(pfc->dev,\n\t\t\t\t pfc->info->nr_pins, sizeof(*pmx->pins),\n\t\t\t\t GFP_KERNEL);\n\tif (unlikely(!pmx->pins))\n\t\treturn -ENOMEM;\n\n\tpmx->configs = devm_kcalloc(pfc->dev,\n\t\t\t\t    pfc->info->nr_pins, sizeof(*pmx->configs),\n\t\t\t\t    GFP_KERNEL);\n\tif (unlikely(!pmx->configs))\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < pfc->info->nr_pins; ++i) {\n\t\tconst struct sh_pfc_pin *info = &pfc->info->pins[i];\n\t\tstruct pinctrl_pin_desc *pin = &pmx->pins[i];\n\n\t\t \n\t\tpin->number = info->pin != (u16)-1 ? info->pin : i;\n\t\tpin->name = info->name;\n\t}\n\n\treturn 0;\n}\n\nint sh_pfc_register_pinctrl(struct sh_pfc *pfc)\n{\n\tstruct sh_pfc_pinctrl *pmx;\n\tint ret;\n\n\tpmx = devm_kzalloc(pfc->dev, sizeof(*pmx), GFP_KERNEL);\n\tif (unlikely(!pmx))\n\t\treturn -ENOMEM;\n\n\tpmx->pfc = pfc;\n\n\tret = sh_pfc_map_pins(pfc, pmx);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpmx->pctl_desc.name = DRV_NAME;\n\tpmx->pctl_desc.owner = THIS_MODULE;\n\tpmx->pctl_desc.pctlops = &sh_pfc_pinctrl_ops;\n\tpmx->pctl_desc.pmxops = &sh_pfc_pinmux_ops;\n\tpmx->pctl_desc.confops = &sh_pfc_pinconf_ops;\n\tpmx->pctl_desc.pins = pmx->pins;\n\tpmx->pctl_desc.npins = pfc->info->nr_pins;\n\n\tret = devm_pinctrl_register_and_init(pfc->dev, &pmx->pctl_desc, pmx,\n\t\t\t\t\t     &pmx->pctl);\n\tif (ret) {\n\t\tdev_err(pfc->dev, \"could not register: %i\\n\", ret);\n\n\t\treturn ret;\n\t}\n\n\treturn pinctrl_enable(pmx->pctl);\n}\n\nconst struct pinmux_bias_reg *\nrcar_pin_to_bias_reg(const struct sh_pfc_soc_info *info, unsigned int pin,\n\t\t     unsigned int *bit)\n{\n\tunsigned int i, j;\n\n\tfor (i = 0; info->bias_regs[i].puen || info->bias_regs[i].pud; i++) {\n\t\tfor (j = 0; j < ARRAY_SIZE(info->bias_regs[i].pins); j++) {\n\t\t\tif (info->bias_regs[i].pins[j] == pin) {\n\t\t\t\t*bit = j;\n\t\t\t\treturn &info->bias_regs[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tWARN_ONCE(1, \"Pin %u is not in bias info list\\n\", pin);\n\n\treturn NULL;\n}\n\nunsigned int rcar_pinmux_get_bias(struct sh_pfc *pfc, unsigned int pin)\n{\n\tconst struct pinmux_bias_reg *reg;\n\tunsigned int bit;\n\n\treg = rcar_pin_to_bias_reg(pfc->info, pin, &bit);\n\tif (!reg)\n\t\treturn PIN_CONFIG_BIAS_DISABLE;\n\n\tif (reg->puen) {\n\t\tif (!(sh_pfc_read(pfc, reg->puen) & BIT(bit)))\n\t\t\treturn PIN_CONFIG_BIAS_DISABLE;\n\t\telse if (!reg->pud || (sh_pfc_read(pfc, reg->pud) & BIT(bit)))\n\t\t\treturn PIN_CONFIG_BIAS_PULL_UP;\n\t\telse\n\t\t\treturn PIN_CONFIG_BIAS_PULL_DOWN;\n\t} else {\n\t\tif (sh_pfc_read(pfc, reg->pud) & BIT(bit))\n\t\t\treturn PIN_CONFIG_BIAS_PULL_DOWN;\n\t\telse\n\t\t\treturn PIN_CONFIG_BIAS_DISABLE;\n\t}\n}\n\nvoid rcar_pinmux_set_bias(struct sh_pfc *pfc, unsigned int pin,\n\t\t\t  unsigned int bias)\n{\n\tconst struct pinmux_bias_reg *reg;\n\tu32 enable, updown;\n\tunsigned int bit;\n\n\treg = rcar_pin_to_bias_reg(pfc->info, pin, &bit);\n\tif (!reg)\n\t\treturn;\n\n\tif (reg->puen) {\n\t\tenable = sh_pfc_read(pfc, reg->puen) & ~BIT(bit);\n\t\tif (bias != PIN_CONFIG_BIAS_DISABLE) {\n\t\t\tenable |= BIT(bit);\n\n\t\t\tif (reg->pud) {\n\t\t\t\tupdown = sh_pfc_read(pfc, reg->pud) & ~BIT(bit);\n\t\t\t\tif (bias == PIN_CONFIG_BIAS_PULL_UP)\n\t\t\t\t\tupdown |= BIT(bit);\n\n\t\t\t\tsh_pfc_write(pfc, reg->pud, updown);\n\t\t\t}\n\t\t}\n\t\tsh_pfc_write(pfc, reg->puen, enable);\n\t} else {\n\t\tenable = sh_pfc_read(pfc, reg->pud) & ~BIT(bit);\n\t\tif (bias == PIN_CONFIG_BIAS_PULL_DOWN)\n\t\t\tenable |= BIT(bit);\n\n\t\tsh_pfc_write(pfc, reg->pud, enable);\n\t}\n}\n\n#define PORTnCR_PULMD_OFF\t(0 << 6)\n#define PORTnCR_PULMD_DOWN\t(2 << 6)\n#define PORTnCR_PULMD_UP\t(3 << 6)\n#define PORTnCR_PULMD_MASK\t(3 << 6)\n\nunsigned int rmobile_pinmux_get_bias(struct sh_pfc *pfc, unsigned int pin)\n{\n\tvoid __iomem *reg = pfc->windows->virt +\n\t\t\t    pfc->info->ops->pin_to_portcr(pin);\n\tu32 value = ioread8(reg) & PORTnCR_PULMD_MASK;\n\n\tswitch (value) {\n\tcase PORTnCR_PULMD_UP:\n\t\treturn PIN_CONFIG_BIAS_PULL_UP;\n\tcase PORTnCR_PULMD_DOWN:\n\t\treturn PIN_CONFIG_BIAS_PULL_DOWN;\n\tcase PORTnCR_PULMD_OFF:\n\tdefault:\n\t\treturn PIN_CONFIG_BIAS_DISABLE;\n\t}\n}\n\nvoid rmobile_pinmux_set_bias(struct sh_pfc *pfc, unsigned int pin,\n\t\t\t     unsigned int bias)\n{\n\tvoid __iomem *reg = pfc->windows->virt +\n\t\t\t    pfc->info->ops->pin_to_portcr(pin);\n\tu32 value = ioread8(reg) & ~PORTnCR_PULMD_MASK;\n\n\tswitch (bias) {\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\tvalue |= PORTnCR_PULMD_UP;\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\tvalue |= PORTnCR_PULMD_DOWN;\n\t\tbreak;\n\t}\n\n\tiowrite8(value, reg);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}