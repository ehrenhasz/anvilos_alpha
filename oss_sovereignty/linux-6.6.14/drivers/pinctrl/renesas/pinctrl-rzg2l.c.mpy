{
  "module_name": "pinctrl-rzg2l.c",
  "hash_id": "92c129ce236a50990a52c9ed581d29b754e125d8a540a7e3216fe95253814b41",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/renesas/pinctrl-rzg2l.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/gpio/driver.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/seq_file.h>\n#include <linux/spinlock.h>\n\n#include <linux/pinctrl/consumer.h>\n#include <linux/pinctrl/pinconf-generic.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinmux.h>\n\n#include <dt-bindings/pinctrl/rzg2l-pinctrl.h>\n\n#include \"../core.h\"\n#include \"../pinconf.h\"\n#include \"../pinmux.h\"\n\n#define DRV_NAME\t\"pinctrl-rzg2l\"\n\n \n#define MUX_PIN_ID_MASK\t\tGENMASK(15, 0)\n#define MUX_FUNC_MASK\t\tGENMASK(31, 16)\n#define MUX_FUNC_OFFS\t\t16\n#define MUX_FUNC(pinconf)\t(((pinconf) & MUX_FUNC_MASK) >> MUX_FUNC_OFFS)\n\n \n#define PIN_CFG_IOLH_A\t\t\tBIT(0)\n#define PIN_CFG_IOLH_B\t\t\tBIT(1)\n#define PIN_CFG_SR\t\t\tBIT(2)\n#define PIN_CFG_IEN\t\t\tBIT(3)\n#define PIN_CFG_PUPD\t\t\tBIT(4)\n#define PIN_CFG_IO_VMC_SD0\t\tBIT(5)\n#define PIN_CFG_IO_VMC_SD1\t\tBIT(6)\n#define PIN_CFG_IO_VMC_QSPI\t\tBIT(7)\n#define PIN_CFG_IO_VMC_ETH0\t\tBIT(8)\n#define PIN_CFG_IO_VMC_ETH1\t\tBIT(9)\n#define PIN_CFG_FILONOFF\t\tBIT(10)\n#define PIN_CFG_FILNUM\t\t\tBIT(11)\n#define PIN_CFG_FILCLKSEL\t\tBIT(12)\n\n#define RZG2L_MPXED_PIN_FUNCS\t\t(PIN_CFG_IOLH_A | \\\n\t\t\t\t\t PIN_CFG_SR | \\\n\t\t\t\t\t PIN_CFG_PUPD | \\\n\t\t\t\t\t PIN_CFG_FILONOFF | \\\n\t\t\t\t\t PIN_CFG_FILNUM | \\\n\t\t\t\t\t PIN_CFG_FILCLKSEL)\n\n#define RZG2L_MPXED_ETH_PIN_FUNCS(x)\t((x) | \\\n\t\t\t\t\t PIN_CFG_FILONOFF | \\\n\t\t\t\t\t PIN_CFG_FILNUM | \\\n\t\t\t\t\t PIN_CFG_FILCLKSEL)\n\n \n#define RZG2L_GPIO_PORT_PACK(n, a, f)\t(((n) << 28) | ((a) << 20) | (f))\n#define RZG2L_GPIO_PORT_GET_PINCNT(x)\t(((x) & GENMASK(30, 28)) >> 28)\n#define RZG2L_GPIO_PORT_GET_INDEX(x)\t(((x) & GENMASK(26, 20)) >> 20)\n#define RZG2L_GPIO_PORT_GET_CFGS(x)\t((x) & GENMASK(19, 0))\n\n \n#define RZG2L_SINGLE_PIN\t\tBIT(31)\n#define RZG2L_SINGLE_PIN_PACK(p, b, f)\t(RZG2L_SINGLE_PIN | \\\n\t\t\t\t\t ((p) << 24) | ((b) << 20) | (f))\n#define RZG2L_SINGLE_PIN_GET_PORT_OFFSET(x)\t(((x) & GENMASK(30, 24)) >> 24)\n#define RZG2L_SINGLE_PIN_GET_BIT(x)\t(((x) & GENMASK(22, 20)) >> 20)\n#define RZG2L_SINGLE_PIN_GET_CFGS(x)\t((x) & GENMASK(19, 0))\n\n#define P(n)\t\t\t(0x0000 + 0x10 + (n))\n#define PM(n)\t\t\t(0x0100 + 0x20 + (n) * 2)\n#define PMC(n)\t\t\t(0x0200 + 0x10 + (n))\n#define PFC(n)\t\t\t(0x0400 + 0x40 + (n) * 4)\n#define PIN(n)\t\t\t(0x0800 + 0x10 + (n))\n#define IOLH(n)\t\t\t(0x1000 + (n) * 8)\n#define IEN(n)\t\t\t(0x1800 + (n) * 8)\n#define ISEL(n)\t\t\t(0x2c80 + (n) * 8)\n#define PWPR\t\t\t(0x3014)\n#define SD_CH(n)\t\t(0x3000 + (n) * 4)\n#define QSPI\t\t\t(0x3008)\n\n#define PVDD_1800\t\t1\t \n#define PVDD_3300\t\t0\t \n\n#define PWPR_B0WI\t\tBIT(7)\t \n#define PWPR_PFCWE\t\tBIT(6)\t \n\n#define PM_MASK\t\t\t0x03\n#define PVDD_MASK\t\t0x01\n#define PFC_MASK\t\t0x07\n#define IEN_MASK\t\t0x01\n#define IOLH_MASK\t\t0x03\n\n#define PM_INPUT\t\t0x1\n#define PM_OUTPUT\t\t0x2\n\n#define RZG2L_PIN_ID_TO_PORT(id)\t((id) / RZG2L_PINS_PER_PORT)\n#define RZG2L_PIN_ID_TO_PORT_OFFSET(id)\t(RZG2L_PIN_ID_TO_PORT(id) + 0x10)\n#define RZG2L_PIN_ID_TO_PIN(id)\t\t((id) % RZG2L_PINS_PER_PORT)\n\n#define RZG2L_TINT_MAX_INTERRUPT\t32\n#define RZG2L_TINT_IRQ_START_INDEX\t9\n#define RZG2L_PACK_HWIRQ(t, i)\t\t(((t) << 16) | (i))\n\nstruct rzg2l_dedicated_configs {\n\tconst char *name;\n\tu32 config;\n};\n\nstruct rzg2l_pinctrl_data {\n\tconst char * const *port_pins;\n\tconst u32 *port_pin_configs;\n\tunsigned int n_ports;\n\tstruct rzg2l_dedicated_configs *dedicated_pins;\n\tunsigned int n_port_pins;\n\tunsigned int n_dedicated_pins;\n};\n\nstruct rzg2l_pinctrl {\n\tstruct pinctrl_dev\t\t*pctl;\n\tstruct pinctrl_desc\t\tdesc;\n\tstruct pinctrl_pin_desc\t\t*pins;\n\n\tconst struct rzg2l_pinctrl_data\t*data;\n\tvoid __iomem\t\t\t*base;\n\tstruct device\t\t\t*dev;\n\n\tstruct gpio_chip\t\tgpio_chip;\n\tstruct pinctrl_gpio_range\tgpio_range;\n\tDECLARE_BITMAP(tint_slot, RZG2L_TINT_MAX_INTERRUPT);\n\tspinlock_t\t\t\tbitmap_lock;  \n\tunsigned int\t\t\thwirq[RZG2L_TINT_MAX_INTERRUPT];\n\n\tspinlock_t\t\t\tlock;  \n\tstruct mutex\t\t\tmutex;  \n};\n\nstatic const unsigned int iolh_groupa_mA[] = { 2, 4, 8, 12 };\nstatic const unsigned int iolh_groupb_oi[] = { 100, 66, 50, 33 };\n\nstatic void rzg2l_pinctrl_set_pfc_mode(struct rzg2l_pinctrl *pctrl,\n\t\t\t\t       u8 port, u8 pin, u8 func)\n{\n\tunsigned long flags;\n\tu32 reg;\n\n\tspin_lock_irqsave(&pctrl->lock, flags);\n\n\t \n\treg = readw(pctrl->base + PM(port));\n\treg &= ~(PM_MASK << (pin * 2));\n\twritew(reg, pctrl->base + PM(port));\n\n\t \n\treg = readb(pctrl->base + PMC(port));\n\twriteb(reg & ~BIT(pin), pctrl->base + PMC(port));\n\n\t \n\twritel(0x0, pctrl->base + PWPR);         \n\twritel(PWPR_PFCWE, pctrl->base + PWPR);   \n\n\t \n\treg = readl(pctrl->base + PFC(port));\n\treg &= ~(PFC_MASK << (pin * 4));\n\twritel(reg | (func << (pin * 4)), pctrl->base + PFC(port));\n\n\t \n\twritel(0x0, pctrl->base + PWPR);         \n\twritel(PWPR_B0WI, pctrl->base + PWPR);   \n\n\t \n\treg = readb(pctrl->base + PMC(port));\n\twriteb(reg | BIT(pin), pctrl->base + PMC(port));\n\n\tspin_unlock_irqrestore(&pctrl->lock, flags);\n};\n\nstatic int rzg2l_pinctrl_set_mux(struct pinctrl_dev *pctldev,\n\t\t\t\t unsigned int func_selector,\n\t\t\t\t unsigned int group_selector)\n{\n\tstruct rzg2l_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct function_desc *func;\n\tunsigned int i, *psel_val;\n\tstruct group_desc *group;\n\tint *pins;\n\n\tfunc = pinmux_generic_get_function(pctldev, func_selector);\n\tif (!func)\n\t\treturn -EINVAL;\n\tgroup = pinctrl_generic_get_group(pctldev, group_selector);\n\tif (!group)\n\t\treturn -EINVAL;\n\n\tpsel_val = func->data;\n\tpins = group->pins;\n\n\tfor (i = 0; i < group->num_pins; i++) {\n\t\tdev_dbg(pctrl->dev, \"port:%u pin: %u PSEL:%u\\n\",\n\t\t\tRZG2L_PIN_ID_TO_PORT(pins[i]), RZG2L_PIN_ID_TO_PIN(pins[i]),\n\t\t\tpsel_val[i]);\n\t\trzg2l_pinctrl_set_pfc_mode(pctrl, RZG2L_PIN_ID_TO_PORT(pins[i]),\n\t\t\t\t\t   RZG2L_PIN_ID_TO_PIN(pins[i]), psel_val[i]);\n\t}\n\n\treturn 0;\n};\n\nstatic int rzg2l_map_add_config(struct pinctrl_map *map,\n\t\t\t\tconst char *group_or_pin,\n\t\t\t\tenum pinctrl_map_type type,\n\t\t\t\tunsigned long *configs,\n\t\t\t\tunsigned int num_configs)\n{\n\tunsigned long *cfgs;\n\n\tcfgs = kmemdup(configs, num_configs * sizeof(*cfgs),\n\t\t       GFP_KERNEL);\n\tif (!cfgs)\n\t\treturn -ENOMEM;\n\n\tmap->type = type;\n\tmap->data.configs.group_or_pin = group_or_pin;\n\tmap->data.configs.configs = cfgs;\n\tmap->data.configs.num_configs = num_configs;\n\n\treturn 0;\n}\n\nstatic int rzg2l_dt_subnode_to_map(struct pinctrl_dev *pctldev,\n\t\t\t\t   struct device_node *np,\n\t\t\t\t   struct device_node *parent,\n\t\t\t\t   struct pinctrl_map **map,\n\t\t\t\t   unsigned int *num_maps,\n\t\t\t\t   unsigned int *index)\n{\n\tstruct rzg2l_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct pinctrl_map *maps = *map;\n\tunsigned int nmaps = *num_maps;\n\tunsigned long *configs = NULL;\n\tunsigned int *pins, *psel_val;\n\tunsigned int num_pinmux = 0;\n\tunsigned int idx = *index;\n\tunsigned int num_pins, i;\n\tunsigned int num_configs;\n\tstruct property *pinmux;\n\tstruct property *prop;\n\tint ret, gsel, fsel;\n\tconst char **pin_fn;\n\tconst char *name;\n\tconst char *pin;\n\n\tpinmux = of_find_property(np, \"pinmux\", NULL);\n\tif (pinmux)\n\t\tnum_pinmux = pinmux->length / sizeof(u32);\n\n\tret = of_property_count_strings(np, \"pins\");\n\tif (ret == -EINVAL) {\n\t\tnum_pins = 0;\n\t} else if (ret < 0) {\n\t\tdev_err(pctrl->dev, \"Invalid pins list in DT\\n\");\n\t\treturn ret;\n\t} else {\n\t\tnum_pins = ret;\n\t}\n\n\tif (!num_pinmux && !num_pins)\n\t\treturn 0;\n\n\tif (num_pinmux && num_pins) {\n\t\tdev_err(pctrl->dev,\n\t\t\t\"DT node must contain either a pinmux or pins and not both\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = pinconf_generic_parse_dt_config(np, NULL, &configs, &num_configs);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (num_pins && !num_configs) {\n\t\tdev_err(pctrl->dev, \"DT node must contain a config\\n\");\n\t\tret = -ENODEV;\n\t\tgoto done;\n\t}\n\n\tif (num_pinmux)\n\t\tnmaps += 1;\n\n\tif (num_pins)\n\t\tnmaps += num_pins;\n\n\tmaps = krealloc_array(maps, nmaps, sizeof(*maps), GFP_KERNEL);\n\tif (!maps) {\n\t\tret = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\t*map = maps;\n\t*num_maps = nmaps;\n\tif (num_pins) {\n\t\tof_property_for_each_string(np, \"pins\", prop, pin) {\n\t\t\tret = rzg2l_map_add_config(&maps[idx], pin,\n\t\t\t\t\t\t   PIN_MAP_TYPE_CONFIGS_PIN,\n\t\t\t\t\t\t   configs, num_configs);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto done;\n\n\t\t\tidx++;\n\t\t}\n\t\tret = 0;\n\t\tgoto done;\n\t}\n\n\tpins = devm_kcalloc(pctrl->dev, num_pinmux, sizeof(*pins), GFP_KERNEL);\n\tpsel_val = devm_kcalloc(pctrl->dev, num_pinmux, sizeof(*psel_val),\n\t\t\t\tGFP_KERNEL);\n\tpin_fn = devm_kzalloc(pctrl->dev, sizeof(*pin_fn), GFP_KERNEL);\n\tif (!pins || !psel_val || !pin_fn) {\n\t\tret = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\t \n\tfor (i = 0; i < num_pinmux; ++i) {\n\t\tu32 value;\n\n\t\tret = of_property_read_u32_index(np, \"pinmux\", i, &value);\n\t\tif (ret)\n\t\t\tgoto done;\n\t\tpins[i] = value & MUX_PIN_ID_MASK;\n\t\tpsel_val[i] = MUX_FUNC(value);\n\t}\n\n\tif (parent) {\n\t\tname = devm_kasprintf(pctrl->dev, GFP_KERNEL, \"%pOFn.%pOFn\",\n\t\t\t\t      parent, np);\n\t\tif (!name) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto done;\n\t\t}\n\t} else {\n\t\tname = np->name;\n\t}\n\n\tmutex_lock(&pctrl->mutex);\n\n\t \n\tgsel = pinctrl_generic_add_group(pctldev, name, pins, num_pinmux, NULL);\n\tif (gsel < 0) {\n\t\tret = gsel;\n\t\tgoto unlock;\n\t}\n\n\t \n\tpin_fn[0] = name;\n\tfsel = pinmux_generic_add_function(pctldev, name, pin_fn, 1, psel_val);\n\tif (fsel < 0) {\n\t\tret = fsel;\n\t\tgoto remove_group;\n\t}\n\n\tmutex_unlock(&pctrl->mutex);\n\n\tmaps[idx].type = PIN_MAP_TYPE_MUX_GROUP;\n\tmaps[idx].data.mux.group = name;\n\tmaps[idx].data.mux.function = name;\n\tidx++;\n\n\tdev_dbg(pctrl->dev, \"Parsed %pOF with %d pins\\n\", np, num_pinmux);\n\tret = 0;\n\tgoto done;\n\nremove_group:\n\tpinctrl_generic_remove_group(pctldev, gsel);\nunlock:\n\tmutex_unlock(&pctrl->mutex);\ndone:\n\t*index = idx;\n\tkfree(configs);\n\treturn ret;\n}\n\nstatic void rzg2l_dt_free_map(struct pinctrl_dev *pctldev,\n\t\t\t      struct pinctrl_map *map,\n\t\t\t      unsigned int num_maps)\n{\n\tunsigned int i;\n\n\tif (!map)\n\t\treturn;\n\n\tfor (i = 0; i < num_maps; ++i) {\n\t\tif (map[i].type == PIN_MAP_TYPE_CONFIGS_GROUP ||\n\t\t    map[i].type == PIN_MAP_TYPE_CONFIGS_PIN)\n\t\t\tkfree(map[i].data.configs.configs);\n\t}\n\tkfree(map);\n}\n\nstatic int rzg2l_dt_node_to_map(struct pinctrl_dev *pctldev,\n\t\t\t\tstruct device_node *np,\n\t\t\t\tstruct pinctrl_map **map,\n\t\t\t\tunsigned int *num_maps)\n{\n\tstruct rzg2l_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct device_node *child;\n\tunsigned int index;\n\tint ret;\n\n\t*map = NULL;\n\t*num_maps = 0;\n\tindex = 0;\n\n\tfor_each_child_of_node(np, child) {\n\t\tret = rzg2l_dt_subnode_to_map(pctldev, child, np, map,\n\t\t\t\t\t      num_maps, &index);\n\t\tif (ret < 0) {\n\t\t\tof_node_put(child);\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif (*num_maps == 0) {\n\t\tret = rzg2l_dt_subnode_to_map(pctldev, np, NULL, map,\n\t\t\t\t\t      num_maps, &index);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\t}\n\n\tif (*num_maps)\n\t\treturn 0;\n\n\tdev_err(pctrl->dev, \"no mapping found in node %pOF\\n\", np);\n\tret = -EINVAL;\n\ndone:\n\trzg2l_dt_free_map(pctldev, *map, *num_maps);\n\n\treturn ret;\n}\n\nstatic int rzg2l_validate_gpio_pin(struct rzg2l_pinctrl *pctrl,\n\t\t\t\t   u32 cfg, u32 port, u8 bit)\n{\n\tu8 pincount = RZG2L_GPIO_PORT_GET_PINCNT(cfg);\n\tu32 port_index = RZG2L_GPIO_PORT_GET_INDEX(cfg);\n\tu32 data;\n\n\tif (bit >= pincount || port >= pctrl->data->n_port_pins)\n\t\treturn -EINVAL;\n\n\tdata = pctrl->data->port_pin_configs[port];\n\tif (port_index != RZG2L_GPIO_PORT_GET_INDEX(data))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic u32 rzg2l_read_pin_config(struct rzg2l_pinctrl *pctrl, u32 offset,\n\t\t\t\t u8 bit, u32 mask)\n{\n\tvoid __iomem *addr = pctrl->base + offset;\n\n\t \n\tif (bit >= 4) {\n\t\tbit -= 4;\n\t\taddr += 4;\n\t}\n\n\treturn (readl(addr) >> (bit * 8)) & mask;\n}\n\nstatic void rzg2l_rmw_pin_config(struct rzg2l_pinctrl *pctrl, u32 offset,\n\t\t\t\t u8 bit, u32 mask, u32 val)\n{\n\tvoid __iomem *addr = pctrl->base + offset;\n\tunsigned long flags;\n\tu32 reg;\n\n\t \n\tif (bit >= 4) {\n\t\tbit -= 4;\n\t\taddr += 4;\n\t}\n\n\tspin_lock_irqsave(&pctrl->lock, flags);\n\treg = readl(addr) & ~(mask << (bit * 8));\n\twritel(reg | (val << (bit * 8)), addr);\n\tspin_unlock_irqrestore(&pctrl->lock, flags);\n}\n\nstatic int rzg2l_pinctrl_pinconf_get(struct pinctrl_dev *pctldev,\n\t\t\t\t     unsigned int _pin,\n\t\t\t\t     unsigned long *config)\n{\n\tstruct rzg2l_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\tenum pin_config_param param = pinconf_to_config_param(*config);\n\tconst struct pinctrl_pin_desc *pin = &pctrl->desc.pins[_pin];\n\tunsigned int *pin_data = pin->drv_data;\n\tunsigned int arg = 0;\n\tunsigned long flags;\n\tvoid __iomem *addr;\n\tu32 port_offset;\n\tu32 cfg = 0;\n\tu8 bit = 0;\n\n\tif (!pin_data)\n\t\treturn -EINVAL;\n\n\tif (*pin_data & RZG2L_SINGLE_PIN) {\n\t\tport_offset = RZG2L_SINGLE_PIN_GET_PORT_OFFSET(*pin_data);\n\t\tcfg = RZG2L_SINGLE_PIN_GET_CFGS(*pin_data);\n\t\tbit = RZG2L_SINGLE_PIN_GET_BIT(*pin_data);\n\t} else {\n\t\tcfg = RZG2L_GPIO_PORT_GET_CFGS(*pin_data);\n\t\tport_offset = RZG2L_PIN_ID_TO_PORT_OFFSET(_pin);\n\t\tbit = RZG2L_PIN_ID_TO_PIN(_pin);\n\n\t\tif (rzg2l_validate_gpio_pin(pctrl, *pin_data, RZG2L_PIN_ID_TO_PORT(_pin), bit))\n\t\t\treturn -EINVAL;\n\t}\n\n\tswitch (param) {\n\tcase PIN_CONFIG_INPUT_ENABLE:\n\t\tif (!(cfg & PIN_CFG_IEN))\n\t\t\treturn -EINVAL;\n\t\targ = rzg2l_read_pin_config(pctrl, IEN(port_offset), bit, IEN_MASK);\n\t\tif (!arg)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\tcase PIN_CONFIG_POWER_SOURCE: {\n\t\tu32 pwr_reg = 0x0;\n\n\t\tif (cfg & PIN_CFG_IO_VMC_SD0)\n\t\t\tpwr_reg = SD_CH(0);\n\t\telse if (cfg & PIN_CFG_IO_VMC_SD1)\n\t\t\tpwr_reg = SD_CH(1);\n\t\telse if (cfg & PIN_CFG_IO_VMC_QSPI)\n\t\t\tpwr_reg = QSPI;\n\t\telse\n\t\t\treturn -EINVAL;\n\n\t\tspin_lock_irqsave(&pctrl->lock, flags);\n\t\taddr = pctrl->base + pwr_reg;\n\t\targ = (readl(addr) & PVDD_MASK) ? 1800 : 3300;\n\t\tspin_unlock_irqrestore(&pctrl->lock, flags);\n\t\tbreak;\n\t}\n\n\tcase PIN_CONFIG_DRIVE_STRENGTH: {\n\t\tunsigned int index;\n\n\t\tif (!(cfg & PIN_CFG_IOLH_A))\n\t\t\treturn -EINVAL;\n\n\t\tindex = rzg2l_read_pin_config(pctrl, IOLH(port_offset), bit, IOLH_MASK);\n\t\targ = iolh_groupa_mA[index];\n\t\tbreak;\n\t}\n\n\tcase PIN_CONFIG_OUTPUT_IMPEDANCE_OHMS: {\n\t\tunsigned int index;\n\n\t\tif (!(cfg & PIN_CFG_IOLH_B))\n\t\t\treturn -EINVAL;\n\n\t\tindex = rzg2l_read_pin_config(pctrl, IOLH(port_offset), bit, IOLH_MASK);\n\t\targ = iolh_groupb_oi[index];\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\t*config = pinconf_to_config_packed(param, arg);\n\n\treturn 0;\n};\n\nstatic int rzg2l_pinctrl_pinconf_set(struct pinctrl_dev *pctldev,\n\t\t\t\t     unsigned int _pin,\n\t\t\t\t     unsigned long *_configs,\n\t\t\t\t     unsigned int num_configs)\n{\n\tstruct rzg2l_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct pinctrl_pin_desc *pin = &pctrl->desc.pins[_pin];\n\tunsigned int *pin_data = pin->drv_data;\n\tenum pin_config_param param;\n\tunsigned long flags;\n\tvoid __iomem *addr;\n\tu32 port_offset;\n\tunsigned int i;\n\tu32 cfg = 0;\n\tu8 bit = 0;\n\n\tif (!pin_data)\n\t\treturn -EINVAL;\n\n\tif (*pin_data & RZG2L_SINGLE_PIN) {\n\t\tport_offset = RZG2L_SINGLE_PIN_GET_PORT_OFFSET(*pin_data);\n\t\tcfg = RZG2L_SINGLE_PIN_GET_CFGS(*pin_data);\n\t\tbit = RZG2L_SINGLE_PIN_GET_BIT(*pin_data);\n\t} else {\n\t\tcfg = RZG2L_GPIO_PORT_GET_CFGS(*pin_data);\n\t\tport_offset = RZG2L_PIN_ID_TO_PORT_OFFSET(_pin);\n\t\tbit = RZG2L_PIN_ID_TO_PIN(_pin);\n\n\t\tif (rzg2l_validate_gpio_pin(pctrl, *pin_data, RZG2L_PIN_ID_TO_PORT(_pin), bit))\n\t\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < num_configs; i++) {\n\t\tparam = pinconf_to_config_param(_configs[i]);\n\t\tswitch (param) {\n\t\tcase PIN_CONFIG_INPUT_ENABLE: {\n\t\t\tunsigned int arg =\n\t\t\t\t\tpinconf_to_config_argument(_configs[i]);\n\n\t\t\tif (!(cfg & PIN_CFG_IEN))\n\t\t\t\treturn -EINVAL;\n\n\t\t\trzg2l_rmw_pin_config(pctrl, IEN(port_offset), bit, IEN_MASK, !!arg);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase PIN_CONFIG_POWER_SOURCE: {\n\t\t\tunsigned int mV = pinconf_to_config_argument(_configs[i]);\n\t\t\tu32 pwr_reg = 0x0;\n\n\t\t\tif (mV != 1800 && mV != 3300)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (cfg & PIN_CFG_IO_VMC_SD0)\n\t\t\t\tpwr_reg = SD_CH(0);\n\t\t\telse if (cfg & PIN_CFG_IO_VMC_SD1)\n\t\t\t\tpwr_reg = SD_CH(1);\n\t\t\telse if (cfg & PIN_CFG_IO_VMC_QSPI)\n\t\t\t\tpwr_reg = QSPI;\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\n\t\t\taddr = pctrl->base + pwr_reg;\n\t\t\tspin_lock_irqsave(&pctrl->lock, flags);\n\t\t\twritel((mV == 1800) ? PVDD_1800 : PVDD_3300, addr);\n\t\t\tspin_unlock_irqrestore(&pctrl->lock, flags);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase PIN_CONFIG_DRIVE_STRENGTH: {\n\t\t\tunsigned int arg = pinconf_to_config_argument(_configs[i]);\n\t\t\tunsigned int index;\n\n\t\t\tif (!(cfg & PIN_CFG_IOLH_A))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tfor (index = 0; index < ARRAY_SIZE(iolh_groupa_mA); index++) {\n\t\t\t\tif (arg == iolh_groupa_mA[index])\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (index >= ARRAY_SIZE(iolh_groupa_mA))\n\t\t\t\treturn -EINVAL;\n\n\t\t\trzg2l_rmw_pin_config(pctrl, IOLH(port_offset), bit, IOLH_MASK, index);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase PIN_CONFIG_OUTPUT_IMPEDANCE_OHMS: {\n\t\t\tunsigned int arg = pinconf_to_config_argument(_configs[i]);\n\t\t\tunsigned int index;\n\n\t\t\tif (!(cfg & PIN_CFG_IOLH_B))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tfor (index = 0; index < ARRAY_SIZE(iolh_groupb_oi); index++) {\n\t\t\t\tif (arg == iolh_groupb_oi[index])\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (index >= ARRAY_SIZE(iolh_groupb_oi))\n\t\t\t\treturn -EINVAL;\n\n\t\t\trzg2l_rmw_pin_config(pctrl, IOLH(port_offset), bit, IOLH_MASK, index);\n\t\t\tbreak;\n\t\t}\n\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int rzg2l_pinctrl_pinconf_group_set(struct pinctrl_dev *pctldev,\n\t\t\t\t\t   unsigned int group,\n\t\t\t\t\t   unsigned long *configs,\n\t\t\t\t\t   unsigned int num_configs)\n{\n\tconst unsigned int *pins;\n\tunsigned int i, npins;\n\tint ret;\n\n\tret = pinctrl_generic_get_group_pins(pctldev, group, &pins, &npins);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < npins; i++) {\n\t\tret = rzg2l_pinctrl_pinconf_set(pctldev, pins[i], configs,\n\t\t\t\t\t\tnum_configs);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n};\n\nstatic int rzg2l_pinctrl_pinconf_group_get(struct pinctrl_dev *pctldev,\n\t\t\t\t\t   unsigned int group,\n\t\t\t\t\t   unsigned long *config)\n{\n\tconst unsigned int *pins;\n\tunsigned int i, npins, prev_config = 0;\n\tint ret;\n\n\tret = pinctrl_generic_get_group_pins(pctldev, group, &pins, &npins);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < npins; i++) {\n\t\tret = rzg2l_pinctrl_pinconf_get(pctldev, pins[i], config);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tif (i && prev_config != *config)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tprev_config = *config;\n\t}\n\n\treturn 0;\n};\n\nstatic const struct pinctrl_ops rzg2l_pinctrl_pctlops = {\n\t.get_groups_count = pinctrl_generic_get_group_count,\n\t.get_group_name = pinctrl_generic_get_group_name,\n\t.get_group_pins = pinctrl_generic_get_group_pins,\n\t.dt_node_to_map = rzg2l_dt_node_to_map,\n\t.dt_free_map = rzg2l_dt_free_map,\n};\n\nstatic const struct pinmux_ops rzg2l_pinctrl_pmxops = {\n\t.get_functions_count = pinmux_generic_get_function_count,\n\t.get_function_name = pinmux_generic_get_function_name,\n\t.get_function_groups = pinmux_generic_get_function_groups,\n\t.set_mux = rzg2l_pinctrl_set_mux,\n\t.strict = true,\n};\n\nstatic const struct pinconf_ops rzg2l_pinctrl_confops = {\n\t.is_generic = true,\n\t.pin_config_get = rzg2l_pinctrl_pinconf_get,\n\t.pin_config_set = rzg2l_pinctrl_pinconf_set,\n\t.pin_config_group_set = rzg2l_pinctrl_pinconf_group_set,\n\t.pin_config_group_get = rzg2l_pinctrl_pinconf_group_get,\n\t.pin_config_config_dbg_show = pinconf_generic_dump_config,\n};\n\nstatic int rzg2l_gpio_request(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct rzg2l_pinctrl *pctrl = gpiochip_get_data(chip);\n\tu32 port = RZG2L_PIN_ID_TO_PORT(offset);\n\tu8 bit = RZG2L_PIN_ID_TO_PIN(offset);\n\tunsigned long flags;\n\tu8 reg8;\n\tint ret;\n\n\tret = pinctrl_gpio_request(chip->base + offset);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock_irqsave(&pctrl->lock, flags);\n\n\t \n\treg8 = readb(pctrl->base + PMC(port));\n\treg8 &= ~BIT(bit);\n\twriteb(reg8, pctrl->base + PMC(port));\n\n\tspin_unlock_irqrestore(&pctrl->lock, flags);\n\n\treturn 0;\n}\n\nstatic void rzg2l_gpio_set_direction(struct rzg2l_pinctrl *pctrl, u32 port,\n\t\t\t\t     u8 bit, bool output)\n{\n\tunsigned long flags;\n\tu16 reg16;\n\n\tspin_lock_irqsave(&pctrl->lock, flags);\n\n\treg16 = readw(pctrl->base + PM(port));\n\treg16 &= ~(PM_MASK << (bit * 2));\n\n\treg16 |= (output ? PM_OUTPUT : PM_INPUT) << (bit * 2);\n\twritew(reg16, pctrl->base + PM(port));\n\n\tspin_unlock_irqrestore(&pctrl->lock, flags);\n}\n\nstatic int rzg2l_gpio_get_direction(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct rzg2l_pinctrl *pctrl = gpiochip_get_data(chip);\n\tu32 port = RZG2L_PIN_ID_TO_PORT(offset);\n\tu8 bit = RZG2L_PIN_ID_TO_PIN(offset);\n\n\tif (!(readb(pctrl->base + PMC(port)) & BIT(bit))) {\n\t\tu16 reg16;\n\n\t\treg16 = readw(pctrl->base + PM(port));\n\t\treg16 = (reg16 >> (bit * 2)) & PM_MASK;\n\t\tif (reg16 == PM_OUTPUT)\n\t\t\treturn GPIO_LINE_DIRECTION_OUT;\n\t}\n\n\treturn GPIO_LINE_DIRECTION_IN;\n}\n\nstatic int rzg2l_gpio_direction_input(struct gpio_chip *chip,\n\t\t\t\t      unsigned int offset)\n{\n\tstruct rzg2l_pinctrl *pctrl = gpiochip_get_data(chip);\n\tu32 port = RZG2L_PIN_ID_TO_PORT(offset);\n\tu8 bit = RZG2L_PIN_ID_TO_PIN(offset);\n\n\trzg2l_gpio_set_direction(pctrl, port, bit, false);\n\n\treturn 0;\n}\n\nstatic void rzg2l_gpio_set(struct gpio_chip *chip, unsigned int offset,\n\t\t\t   int value)\n{\n\tstruct rzg2l_pinctrl *pctrl = gpiochip_get_data(chip);\n\tu32 port = RZG2L_PIN_ID_TO_PORT(offset);\n\tu8 bit = RZG2L_PIN_ID_TO_PIN(offset);\n\tunsigned long flags;\n\tu8 reg8;\n\n\tspin_lock_irqsave(&pctrl->lock, flags);\n\n\treg8 = readb(pctrl->base + P(port));\n\n\tif (value)\n\t\twriteb(reg8 | BIT(bit), pctrl->base + P(port));\n\telse\n\t\twriteb(reg8 & ~BIT(bit), pctrl->base + P(port));\n\n\tspin_unlock_irqrestore(&pctrl->lock, flags);\n}\n\nstatic int rzg2l_gpio_direction_output(struct gpio_chip *chip,\n\t\t\t\t       unsigned int offset, int value)\n{\n\tstruct rzg2l_pinctrl *pctrl = gpiochip_get_data(chip);\n\tu32 port = RZG2L_PIN_ID_TO_PORT(offset);\n\tu8 bit = RZG2L_PIN_ID_TO_PIN(offset);\n\n\trzg2l_gpio_set(chip, offset, value);\n\trzg2l_gpio_set_direction(pctrl, port, bit, true);\n\n\treturn 0;\n}\n\nstatic int rzg2l_gpio_get(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct rzg2l_pinctrl *pctrl = gpiochip_get_data(chip);\n\tu32 port = RZG2L_PIN_ID_TO_PORT(offset);\n\tu8 bit = RZG2L_PIN_ID_TO_PIN(offset);\n\tu16 reg16;\n\n\treg16 = readw(pctrl->base + PM(port));\n\treg16 = (reg16 >> (bit * 2)) & PM_MASK;\n\n\tif (reg16 == PM_INPUT)\n\t\treturn !!(readb(pctrl->base + PIN(port)) & BIT(bit));\n\telse if (reg16 == PM_OUTPUT)\n\t\treturn !!(readb(pctrl->base + P(port)) & BIT(bit));\n\telse\n\t\treturn -EINVAL;\n}\n\nstatic void rzg2l_gpio_free(struct gpio_chip *chip, unsigned int offset)\n{\n\tunsigned int virq;\n\n\tpinctrl_gpio_free(chip->base + offset);\n\n\tvirq = irq_find_mapping(chip->irq.domain, offset);\n\tif (virq)\n\t\tirq_dispose_mapping(virq);\n\n\t \n\trzg2l_gpio_direction_input(chip, offset);\n}\n\nstatic const char * const rzg2l_gpio_names[] = {\n\t\"P0_0\", \"P0_1\", \"P0_2\", \"P0_3\", \"P0_4\", \"P0_5\", \"P0_6\", \"P0_7\",\n\t\"P1_0\", \"P1_1\", \"P1_2\", \"P1_3\", \"P1_4\", \"P1_5\", \"P1_6\", \"P1_7\",\n\t\"P2_0\", \"P2_1\", \"P2_2\", \"P2_3\", \"P2_4\", \"P2_5\", \"P2_6\", \"P2_7\",\n\t\"P3_0\", \"P3_1\", \"P3_2\", \"P3_3\", \"P3_4\", \"P3_5\", \"P3_6\", \"P3_7\",\n\t\"P4_0\", \"P4_1\", \"P4_2\", \"P4_3\", \"P4_4\", \"P4_5\", \"P4_6\", \"P4_7\",\n\t\"P5_0\", \"P5_1\", \"P5_2\", \"P5_3\", \"P5_4\", \"P5_5\", \"P5_6\", \"P5_7\",\n\t\"P6_0\", \"P6_1\", \"P6_2\", \"P6_3\", \"P6_4\", \"P6_5\", \"P6_6\", \"P6_7\",\n\t\"P7_0\", \"P7_1\", \"P7_2\", \"P7_3\", \"P7_4\", \"P7_5\", \"P7_6\", \"P7_7\",\n\t\"P8_0\", \"P8_1\", \"P8_2\", \"P8_3\", \"P8_4\", \"P8_5\", \"P8_6\", \"P8_7\",\n\t\"P9_0\", \"P9_1\", \"P9_2\", \"P9_3\", \"P9_4\", \"P9_5\", \"P9_6\", \"P9_7\",\n\t\"P10_0\", \"P10_1\", \"P10_2\", \"P10_3\", \"P10_4\", \"P10_5\", \"P10_6\", \"P10_7\",\n\t\"P11_0\", \"P11_1\", \"P11_2\", \"P11_3\", \"P11_4\", \"P11_5\", \"P11_6\", \"P11_7\",\n\t\"P12_0\", \"P12_1\", \"P12_2\", \"P12_3\", \"P12_4\", \"P12_5\", \"P12_6\", \"P12_7\",\n\t\"P13_0\", \"P13_1\", \"P13_2\", \"P13_3\", \"P13_4\", \"P13_5\", \"P13_6\", \"P13_7\",\n\t\"P14_0\", \"P14_1\", \"P14_2\", \"P14_3\", \"P14_4\", \"P14_5\", \"P14_6\", \"P14_7\",\n\t\"P15_0\", \"P15_1\", \"P15_2\", \"P15_3\", \"P15_4\", \"P15_5\", \"P15_6\", \"P15_7\",\n\t\"P16_0\", \"P16_1\", \"P16_2\", \"P16_3\", \"P16_4\", \"P16_5\", \"P16_6\", \"P16_7\",\n\t\"P17_0\", \"P17_1\", \"P17_2\", \"P17_3\", \"P17_4\", \"P17_5\", \"P17_6\", \"P17_7\",\n\t\"P18_0\", \"P18_1\", \"P18_2\", \"P18_3\", \"P18_4\", \"P18_5\", \"P18_6\", \"P18_7\",\n\t\"P19_0\", \"P19_1\", \"P19_2\", \"P19_3\", \"P19_4\", \"P19_5\", \"P19_6\", \"P19_7\",\n\t\"P20_0\", \"P20_1\", \"P20_2\", \"P20_3\", \"P20_4\", \"P20_5\", \"P20_6\", \"P20_7\",\n\t\"P21_0\", \"P21_1\", \"P21_2\", \"P21_3\", \"P21_4\", \"P21_5\", \"P21_6\", \"P21_7\",\n\t\"P22_0\", \"P22_1\", \"P22_2\", \"P22_3\", \"P22_4\", \"P22_5\", \"P22_6\", \"P22_7\",\n\t\"P23_0\", \"P23_1\", \"P23_2\", \"P23_3\", \"P23_4\", \"P23_5\", \"P23_6\", \"P23_7\",\n\t\"P24_0\", \"P24_1\", \"P24_2\", \"P24_3\", \"P24_4\", \"P24_5\", \"P24_6\", \"P24_7\",\n\t\"P25_0\", \"P25_1\", \"P25_2\", \"P25_3\", \"P25_4\", \"P25_5\", \"P25_6\", \"P25_7\",\n\t\"P26_0\", \"P26_1\", \"P26_2\", \"P26_3\", \"P26_4\", \"P26_5\", \"P26_6\", \"P26_7\",\n\t\"P27_0\", \"P27_1\", \"P27_2\", \"P27_3\", \"P27_4\", \"P27_5\", \"P27_6\", \"P27_7\",\n\t\"P28_0\", \"P28_1\", \"P28_2\", \"P28_3\", \"P28_4\", \"P28_5\", \"P28_6\", \"P28_7\",\n\t\"P29_0\", \"P29_1\", \"P29_2\", \"P29_3\", \"P29_4\", \"P29_5\", \"P29_6\", \"P29_7\",\n\t\"P30_0\", \"P30_1\", \"P30_2\", \"P30_3\", \"P30_4\", \"P30_5\", \"P30_6\", \"P30_7\",\n\t\"P31_0\", \"P31_1\", \"P31_2\", \"P31_3\", \"P31_4\", \"P31_5\", \"P31_6\", \"P31_7\",\n\t\"P32_0\", \"P32_1\", \"P32_2\", \"P32_3\", \"P32_4\", \"P32_5\", \"P32_6\", \"P32_7\",\n\t\"P33_0\", \"P33_1\", \"P33_2\", \"P33_3\", \"P33_4\", \"P33_5\", \"P33_6\", \"P33_7\",\n\t\"P34_0\", \"P34_1\", \"P34_2\", \"P34_3\", \"P34_4\", \"P34_5\", \"P34_6\", \"P34_7\",\n\t\"P35_0\", \"P35_1\", \"P35_2\", \"P35_3\", \"P35_4\", \"P35_5\", \"P35_6\", \"P35_7\",\n\t\"P36_0\", \"P36_1\", \"P36_2\", \"P36_3\", \"P36_4\", \"P36_5\", \"P36_6\", \"P36_7\",\n\t\"P37_0\", \"P37_1\", \"P37_2\", \"P37_3\", \"P37_4\", \"P37_5\", \"P37_6\", \"P37_7\",\n\t\"P38_0\", \"P38_1\", \"P38_2\", \"P38_3\", \"P38_4\", \"P38_5\", \"P38_6\", \"P38_7\",\n\t\"P39_0\", \"P39_1\", \"P39_2\", \"P39_3\", \"P39_4\", \"P39_5\", \"P39_6\", \"P39_7\",\n\t\"P40_0\", \"P40_1\", \"P40_2\", \"P40_3\", \"P40_4\", \"P40_5\", \"P40_6\", \"P40_7\",\n\t\"P41_0\", \"P41_1\", \"P41_2\", \"P41_3\", \"P41_4\", \"P41_5\", \"P41_6\", \"P41_7\",\n\t\"P42_0\", \"P42_1\", \"P42_2\", \"P42_3\", \"P42_4\", \"P42_5\", \"P42_6\", \"P42_7\",\n\t\"P43_0\", \"P43_1\", \"P43_2\", \"P43_3\", \"P43_4\", \"P43_5\", \"P43_6\", \"P43_7\",\n\t\"P44_0\", \"P44_1\", \"P44_2\", \"P44_3\", \"P44_4\", \"P44_5\", \"P44_6\", \"P44_7\",\n\t\"P45_0\", \"P45_1\", \"P45_2\", \"P45_3\", \"P45_4\", \"P45_5\", \"P45_6\", \"P45_7\",\n\t\"P46_0\", \"P46_1\", \"P46_2\", \"P46_3\", \"P46_4\", \"P46_5\", \"P46_6\", \"P46_7\",\n\t\"P47_0\", \"P47_1\", \"P47_2\", \"P47_3\", \"P47_4\", \"P47_5\", \"P47_6\", \"P47_7\",\n\t\"P48_0\", \"P48_1\", \"P48_2\", \"P48_3\", \"P48_4\", \"P48_5\", \"P48_6\", \"P48_7\",\n};\n\nstatic const u32 rzg2l_gpio_configs[] = {\n\tRZG2L_GPIO_PORT_PACK(2, 0x10, RZG2L_MPXED_PIN_FUNCS),\n\tRZG2L_GPIO_PORT_PACK(2, 0x11, RZG2L_MPXED_PIN_FUNCS),\n\tRZG2L_GPIO_PORT_PACK(2, 0x12, RZG2L_MPXED_PIN_FUNCS),\n\tRZG2L_GPIO_PORT_PACK(2, 0x13, RZG2L_MPXED_PIN_FUNCS),\n\tRZG2L_GPIO_PORT_PACK(2, 0x14, RZG2L_MPXED_PIN_FUNCS),\n\tRZG2L_GPIO_PORT_PACK(3, 0x15, RZG2L_MPXED_PIN_FUNCS),\n\tRZG2L_GPIO_PORT_PACK(2, 0x16, RZG2L_MPXED_PIN_FUNCS),\n\tRZG2L_GPIO_PORT_PACK(3, 0x17, RZG2L_MPXED_PIN_FUNCS),\n\tRZG2L_GPIO_PORT_PACK(3, 0x18, RZG2L_MPXED_PIN_FUNCS),\n\tRZG2L_GPIO_PORT_PACK(2, 0x19, RZG2L_MPXED_PIN_FUNCS),\n\tRZG2L_GPIO_PORT_PACK(2, 0x1a, RZG2L_MPXED_PIN_FUNCS),\n\tRZG2L_GPIO_PORT_PACK(2, 0x1b, RZG2L_MPXED_PIN_FUNCS),\n\tRZG2L_GPIO_PORT_PACK(2, 0x1c, RZG2L_MPXED_PIN_FUNCS),\n\tRZG2L_GPIO_PORT_PACK(3, 0x1d, RZG2L_MPXED_PIN_FUNCS),\n\tRZG2L_GPIO_PORT_PACK(2, 0x1e, RZG2L_MPXED_PIN_FUNCS),\n\tRZG2L_GPIO_PORT_PACK(2, 0x1f, RZG2L_MPXED_PIN_FUNCS),\n\tRZG2L_GPIO_PORT_PACK(2, 0x20, RZG2L_MPXED_PIN_FUNCS),\n\tRZG2L_GPIO_PORT_PACK(3, 0x21, RZG2L_MPXED_PIN_FUNCS),\n\tRZG2L_GPIO_PORT_PACK(2, 0x22, RZG2L_MPXED_PIN_FUNCS),\n\tRZG2L_GPIO_PORT_PACK(2, 0x23, RZG2L_MPXED_PIN_FUNCS),\n\tRZG2L_GPIO_PORT_PACK(3, 0x24, RZG2L_MPXED_ETH_PIN_FUNCS(PIN_CFG_IO_VMC_ETH0)),\n\tRZG2L_GPIO_PORT_PACK(2, 0x25, RZG2L_MPXED_ETH_PIN_FUNCS(PIN_CFG_IO_VMC_ETH0)),\n\tRZG2L_GPIO_PORT_PACK(2, 0x26, RZG2L_MPXED_ETH_PIN_FUNCS(PIN_CFG_IO_VMC_ETH0)),\n\tRZG2L_GPIO_PORT_PACK(2, 0x27, RZG2L_MPXED_ETH_PIN_FUNCS(PIN_CFG_IO_VMC_ETH0)),\n\tRZG2L_GPIO_PORT_PACK(2, 0x28, RZG2L_MPXED_ETH_PIN_FUNCS(PIN_CFG_IO_VMC_ETH0)),\n\tRZG2L_GPIO_PORT_PACK(2, 0x29, RZG2L_MPXED_ETH_PIN_FUNCS(PIN_CFG_IO_VMC_ETH0)),\n\tRZG2L_GPIO_PORT_PACK(2, 0x2a, RZG2L_MPXED_ETH_PIN_FUNCS(PIN_CFG_IO_VMC_ETH0)),\n\tRZG2L_GPIO_PORT_PACK(2, 0x2b, RZG2L_MPXED_ETH_PIN_FUNCS(PIN_CFG_IO_VMC_ETH0)),\n\tRZG2L_GPIO_PORT_PACK(2, 0x2c, RZG2L_MPXED_ETH_PIN_FUNCS(PIN_CFG_IO_VMC_ETH0)),\n\tRZG2L_GPIO_PORT_PACK(2, 0x2d, RZG2L_MPXED_ETH_PIN_FUNCS(PIN_CFG_IO_VMC_ETH1)),\n\tRZG2L_GPIO_PORT_PACK(2, 0x2e, RZG2L_MPXED_ETH_PIN_FUNCS(PIN_CFG_IO_VMC_ETH1)),\n\tRZG2L_GPIO_PORT_PACK(2, 0x2f, RZG2L_MPXED_ETH_PIN_FUNCS(PIN_CFG_IO_VMC_ETH1)),\n\tRZG2L_GPIO_PORT_PACK(2, 0x30, RZG2L_MPXED_ETH_PIN_FUNCS(PIN_CFG_IO_VMC_ETH1)),\n\tRZG2L_GPIO_PORT_PACK(2, 0x31, RZG2L_MPXED_ETH_PIN_FUNCS(PIN_CFG_IO_VMC_ETH1)),\n\tRZG2L_GPIO_PORT_PACK(2, 0x32, RZG2L_MPXED_ETH_PIN_FUNCS(PIN_CFG_IO_VMC_ETH1)),\n\tRZG2L_GPIO_PORT_PACK(2, 0x33, RZG2L_MPXED_ETH_PIN_FUNCS(PIN_CFG_IO_VMC_ETH1)),\n\tRZG2L_GPIO_PORT_PACK(2, 0x34, RZG2L_MPXED_ETH_PIN_FUNCS(PIN_CFG_IO_VMC_ETH1)),\n\tRZG2L_GPIO_PORT_PACK(3, 0x35, RZG2L_MPXED_ETH_PIN_FUNCS(PIN_CFG_IO_VMC_ETH1)),\n\tRZG2L_GPIO_PORT_PACK(2, 0x36, RZG2L_MPXED_PIN_FUNCS),\n\tRZG2L_GPIO_PORT_PACK(3, 0x37, RZG2L_MPXED_PIN_FUNCS),\n\tRZG2L_GPIO_PORT_PACK(3, 0x38, RZG2L_MPXED_PIN_FUNCS),\n\tRZG2L_GPIO_PORT_PACK(2, 0x39, RZG2L_MPXED_PIN_FUNCS),\n\tRZG2L_GPIO_PORT_PACK(5, 0x3a, RZG2L_MPXED_PIN_FUNCS),\n\tRZG2L_GPIO_PORT_PACK(4, 0x3b, RZG2L_MPXED_PIN_FUNCS),\n\tRZG2L_GPIO_PORT_PACK(4, 0x3c, RZG2L_MPXED_PIN_FUNCS),\n\tRZG2L_GPIO_PORT_PACK(4, 0x3d, RZG2L_MPXED_PIN_FUNCS),\n\tRZG2L_GPIO_PORT_PACK(4, 0x3e, RZG2L_MPXED_PIN_FUNCS),\n\tRZG2L_GPIO_PORT_PACK(4, 0x3f, RZG2L_MPXED_PIN_FUNCS),\n\tRZG2L_GPIO_PORT_PACK(5, 0x40, RZG2L_MPXED_PIN_FUNCS),\n};\n\nstatic const u32 r9a07g043_gpio_configs[] = {\n\tRZG2L_GPIO_PORT_PACK(4, 0x10, RZG2L_MPXED_PIN_FUNCS),\n\tRZG2L_GPIO_PORT_PACK(5, 0x11, RZG2L_MPXED_ETH_PIN_FUNCS(PIN_CFG_IO_VMC_ETH0)),\n\tRZG2L_GPIO_PORT_PACK(4, 0x12, RZG2L_MPXED_ETH_PIN_FUNCS(PIN_CFG_IO_VMC_ETH0)),\n\tRZG2L_GPIO_PORT_PACK(4, 0x13, RZG2L_MPXED_ETH_PIN_FUNCS(PIN_CFG_IO_VMC_ETH0)),\n\tRZG2L_GPIO_PORT_PACK(6, 0x14, RZG2L_MPXED_ETH_PIN_FUNCS(PIN_CFG_IO_VMC_ETH0)),\n\tRZG2L_GPIO_PORT_PACK(5, 0x15, RZG2L_MPXED_PIN_FUNCS),\n\tRZG2L_GPIO_PORT_PACK(5, 0x16, RZG2L_MPXED_PIN_FUNCS),\n\tRZG2L_GPIO_PORT_PACK(5, 0x17, RZG2L_MPXED_ETH_PIN_FUNCS(PIN_CFG_IO_VMC_ETH1)),\n\tRZG2L_GPIO_PORT_PACK(5, 0x18, RZG2L_MPXED_ETH_PIN_FUNCS(PIN_CFG_IO_VMC_ETH1)),\n\tRZG2L_GPIO_PORT_PACK(4, 0x19, RZG2L_MPXED_ETH_PIN_FUNCS(PIN_CFG_IO_VMC_ETH1)),\n\tRZG2L_GPIO_PORT_PACK(5, 0x1a, RZG2L_MPXED_ETH_PIN_FUNCS(PIN_CFG_IO_VMC_ETH1)),\n\tRZG2L_GPIO_PORT_PACK(4, 0x1b, RZG2L_MPXED_PIN_FUNCS),\n\tRZG2L_GPIO_PORT_PACK(2, 0x1c, RZG2L_MPXED_PIN_FUNCS),\n\tRZG2L_GPIO_PORT_PACK(5, 0x1d, RZG2L_MPXED_PIN_FUNCS),\n\tRZG2L_GPIO_PORT_PACK(3, 0x1e, RZG2L_MPXED_PIN_FUNCS),\n\tRZG2L_GPIO_PORT_PACK(4, 0x1f, RZG2L_MPXED_PIN_FUNCS),\n\tRZG2L_GPIO_PORT_PACK(2, 0x20, RZG2L_MPXED_PIN_FUNCS),\n\tRZG2L_GPIO_PORT_PACK(4, 0x21, RZG2L_MPXED_PIN_FUNCS),\n\tRZG2L_GPIO_PORT_PACK(6, 0x22, RZG2L_MPXED_PIN_FUNCS),\n};\n\nstatic struct {\n\tstruct rzg2l_dedicated_configs common[35];\n\tstruct rzg2l_dedicated_configs rzg2l_pins[7];\n} rzg2l_dedicated_pins = {\n\t.common = {\n\t\t{ \"NMI\", RZG2L_SINGLE_PIN_PACK(0x1, 0,\n\t\t (PIN_CFG_FILONOFF | PIN_CFG_FILNUM | PIN_CFG_FILCLKSEL)) },\n\t\t{ \"TMS/SWDIO\", RZG2L_SINGLE_PIN_PACK(0x2, 0,\n\t\t (PIN_CFG_IOLH_A | PIN_CFG_SR | PIN_CFG_IEN)) },\n\t\t{ \"TDO\", RZG2L_SINGLE_PIN_PACK(0x3, 0,\n\t\t (PIN_CFG_IOLH_A | PIN_CFG_SR | PIN_CFG_IEN)) },\n\t\t{ \"AUDIO_CLK1\", RZG2L_SINGLE_PIN_PACK(0x4, 0, PIN_CFG_IEN) },\n\t\t{ \"AUDIO_CLK2\", RZG2L_SINGLE_PIN_PACK(0x4, 1, PIN_CFG_IEN) },\n\t\t{ \"SD0_CLK\", RZG2L_SINGLE_PIN_PACK(0x6, 0,\n\t\t (PIN_CFG_IOLH_B | PIN_CFG_SR | PIN_CFG_IO_VMC_SD0)) },\n\t\t{ \"SD0_CMD\", RZG2L_SINGLE_PIN_PACK(0x6, 1,\n\t\t (PIN_CFG_IOLH_B | PIN_CFG_SR | PIN_CFG_IEN | PIN_CFG_IO_VMC_SD0)) },\n\t\t{ \"SD0_RST#\", RZG2L_SINGLE_PIN_PACK(0x6, 2,\n\t\t (PIN_CFG_IOLH_B | PIN_CFG_SR | PIN_CFG_IO_VMC_SD0)) },\n\t\t{ \"SD0_DATA0\", RZG2L_SINGLE_PIN_PACK(0x7, 0,\n\t\t (PIN_CFG_IOLH_B | PIN_CFG_SR | PIN_CFG_IEN | PIN_CFG_IO_VMC_SD0)) },\n\t\t{ \"SD0_DATA1\", RZG2L_SINGLE_PIN_PACK(0x7, 1,\n\t\t (PIN_CFG_IOLH_B | PIN_CFG_SR | PIN_CFG_IEN | PIN_CFG_IO_VMC_SD0)) },\n\t\t{ \"SD0_DATA2\", RZG2L_SINGLE_PIN_PACK(0x7, 2,\n\t\t (PIN_CFG_IOLH_B | PIN_CFG_SR | PIN_CFG_IEN | PIN_CFG_IO_VMC_SD0)) },\n\t\t{ \"SD0_DATA3\", RZG2L_SINGLE_PIN_PACK(0x7, 3,\n\t\t (PIN_CFG_IOLH_B | PIN_CFG_SR | PIN_CFG_IEN | PIN_CFG_IO_VMC_SD0)) },\n\t\t{ \"SD0_DATA4\", RZG2L_SINGLE_PIN_PACK(0x7, 4,\n\t\t (PIN_CFG_IOLH_B | PIN_CFG_SR | PIN_CFG_IEN | PIN_CFG_IO_VMC_SD0)) },\n\t\t{ \"SD0_DATA5\", RZG2L_SINGLE_PIN_PACK(0x7, 5,\n\t\t (PIN_CFG_IOLH_B | PIN_CFG_SR | PIN_CFG_IEN | PIN_CFG_IO_VMC_SD0)) },\n\t\t{ \"SD0_DATA6\", RZG2L_SINGLE_PIN_PACK(0x7, 6,\n\t\t (PIN_CFG_IOLH_B | PIN_CFG_SR | PIN_CFG_IEN | PIN_CFG_IO_VMC_SD0)) },\n\t\t{ \"SD0_DATA7\", RZG2L_SINGLE_PIN_PACK(0x7, 7,\n\t\t (PIN_CFG_IOLH_B | PIN_CFG_SR | PIN_CFG_IEN | PIN_CFG_IO_VMC_SD0)) },\n\t\t{ \"SD1_CLK\", RZG2L_SINGLE_PIN_PACK(0x8, 0,\n\t\t (PIN_CFG_IOLH_B | PIN_CFG_SR | PIN_CFG_IO_VMC_SD1)) },\n\t\t{ \"SD1_CMD\", RZG2L_SINGLE_PIN_PACK(0x8, 1,\n\t\t (PIN_CFG_IOLH_B | PIN_CFG_SR | PIN_CFG_IEN | PIN_CFG_IO_VMC_SD1)) },\n\t\t{ \"SD1_DATA0\", RZG2L_SINGLE_PIN_PACK(0x9, 0,\n\t\t (PIN_CFG_IOLH_B | PIN_CFG_SR | PIN_CFG_IEN | PIN_CFG_IO_VMC_SD1)) },\n\t\t{ \"SD1_DATA1\", RZG2L_SINGLE_PIN_PACK(0x9, 1,\n\t\t (PIN_CFG_IOLH_B | PIN_CFG_SR | PIN_CFG_IEN | PIN_CFG_IO_VMC_SD1)) },\n\t\t{ \"SD1_DATA2\", RZG2L_SINGLE_PIN_PACK(0x9, 2,\n\t\t (PIN_CFG_IOLH_B | PIN_CFG_SR | PIN_CFG_IEN | PIN_CFG_IO_VMC_SD1)) },\n\t\t{ \"SD1_DATA3\", RZG2L_SINGLE_PIN_PACK(0x9, 3,\n\t\t (PIN_CFG_IOLH_B | PIN_CFG_SR | PIN_CFG_IEN | PIN_CFG_IO_VMC_SD1)) },\n\t\t{ \"QSPI0_SPCLK\", RZG2L_SINGLE_PIN_PACK(0xa, 0,\n\t\t (PIN_CFG_IOLH_B | PIN_CFG_SR | PIN_CFG_IO_VMC_QSPI)) },\n\t\t{ \"QSPI0_IO0\", RZG2L_SINGLE_PIN_PACK(0xa, 1,\n\t\t (PIN_CFG_IOLH_B | PIN_CFG_SR | PIN_CFG_IO_VMC_QSPI)) },\n\t\t{ \"QSPI0_IO1\", RZG2L_SINGLE_PIN_PACK(0xa, 2,\n\t\t (PIN_CFG_IOLH_B | PIN_CFG_SR | PIN_CFG_IO_VMC_QSPI)) },\n\t\t{ \"QSPI0_IO2\", RZG2L_SINGLE_PIN_PACK(0xa, 3,\n\t\t (PIN_CFG_IOLH_B | PIN_CFG_SR | PIN_CFG_IO_VMC_QSPI)) },\n\t\t{ \"QSPI0_IO3\", RZG2L_SINGLE_PIN_PACK(0xa, 4,\n\t\t (PIN_CFG_IOLH_B | PIN_CFG_SR | PIN_CFG_IO_VMC_QSPI)) },\n\t\t{ \"QSPI0_SSL\", RZG2L_SINGLE_PIN_PACK(0xa, 5,\n\t\t (PIN_CFG_IOLH_B | PIN_CFG_SR | PIN_CFG_IO_VMC_QSPI)) },\n\t\t{ \"QSPI_RESET#\", RZG2L_SINGLE_PIN_PACK(0xc, 0,\n\t\t (PIN_CFG_IOLH_B | PIN_CFG_SR | PIN_CFG_IO_VMC_QSPI)) },\n\t\t{ \"QSPI_WP#\", RZG2L_SINGLE_PIN_PACK(0xc, 1,\n\t\t (PIN_CFG_IOLH_B | PIN_CFG_SR | PIN_CFG_IO_VMC_QSPI)) },\n\t\t{ \"WDTOVF_PERROUT#\", RZG2L_SINGLE_PIN_PACK(0xd, 0, (PIN_CFG_IOLH_A | PIN_CFG_SR)) },\n\t\t{ \"RIIC0_SDA\", RZG2L_SINGLE_PIN_PACK(0xe, 0, PIN_CFG_IEN) },\n\t\t{ \"RIIC0_SCL\", RZG2L_SINGLE_PIN_PACK(0xe, 1, PIN_CFG_IEN) },\n\t\t{ \"RIIC1_SDA\", RZG2L_SINGLE_PIN_PACK(0xe, 2, PIN_CFG_IEN) },\n\t\t{ \"RIIC1_SCL\", RZG2L_SINGLE_PIN_PACK(0xe, 3, PIN_CFG_IEN) },\n\t},\n\t.rzg2l_pins = {\n\t\t{ \"QSPI_INT#\", RZG2L_SINGLE_PIN_PACK(0xc, 2, (PIN_CFG_SR | PIN_CFG_IO_VMC_QSPI)) },\n\t\t{ \"QSPI1_SPCLK\", RZG2L_SINGLE_PIN_PACK(0xb, 0,\n\t\t (PIN_CFG_IOLH_B | PIN_CFG_SR | PIN_CFG_IO_VMC_QSPI)) },\n\t\t{ \"QSPI1_IO0\", RZG2L_SINGLE_PIN_PACK(0xb, 1,\n\t\t (PIN_CFG_IOLH_B | PIN_CFG_SR | PIN_CFG_IO_VMC_QSPI)) },\n\t\t{ \"QSPI1_IO1\", RZG2L_SINGLE_PIN_PACK(0xb, 2,\n\t\t (PIN_CFG_IOLH_B | PIN_CFG_SR | PIN_CFG_IO_VMC_QSPI)) },\n\t\t{ \"QSPI1_IO2\", RZG2L_SINGLE_PIN_PACK(0xb, 3,\n\t\t (PIN_CFG_IOLH_B | PIN_CFG_SR | PIN_CFG_IO_VMC_QSPI)) },\n\t\t{ \"QSPI1_IO3\", RZG2L_SINGLE_PIN_PACK(0xb, 4,\n\t\t (PIN_CFG_IOLH_B | PIN_CFG_SR  | PIN_CFG_IO_VMC_QSPI)) },\n\t\t{ \"QSPI1_SSL\", RZG2L_SINGLE_PIN_PACK(0xb, 5,\n\t\t (PIN_CFG_IOLH_B | PIN_CFG_SR | PIN_CFG_IO_VMC_QSPI)) },\n\t}\n};\n\nstatic int rzg2l_gpio_get_gpioint(unsigned int virq, const struct rzg2l_pinctrl_data *data)\n{\n\tunsigned int gpioint;\n\tunsigned int i;\n\tu32 port, bit;\n\n\tport = virq / 8;\n\tbit = virq % 8;\n\n\tif (port >= data->n_ports ||\n\t    bit >= RZG2L_GPIO_PORT_GET_PINCNT(data->port_pin_configs[port]))\n\t\treturn -EINVAL;\n\n\tgpioint = bit;\n\tfor (i = 0; i < port; i++)\n\t\tgpioint += RZG2L_GPIO_PORT_GET_PINCNT(data->port_pin_configs[i]);\n\n\treturn gpioint;\n}\n\nstatic void rzg2l_gpio_irq_disable(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct rzg2l_pinctrl *pctrl = container_of(gc, struct rzg2l_pinctrl, gpio_chip);\n\tunsigned int hwirq = irqd_to_hwirq(d);\n\tunsigned long flags;\n\tvoid __iomem *addr;\n\tu32 port;\n\tu8 bit;\n\n\tirq_chip_disable_parent(d);\n\n\tport = RZG2L_PIN_ID_TO_PORT(hwirq);\n\tbit = RZG2L_PIN_ID_TO_PIN(hwirq);\n\n\taddr = pctrl->base + ISEL(port);\n\tif (bit >= 4) {\n\t\tbit -= 4;\n\t\taddr += 4;\n\t}\n\n\tspin_lock_irqsave(&pctrl->lock, flags);\n\twritel(readl(addr) & ~BIT(bit * 8), addr);\n\tspin_unlock_irqrestore(&pctrl->lock, flags);\n\n\tgpiochip_disable_irq(gc, hwirq);\n}\n\nstatic void rzg2l_gpio_irq_enable(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct rzg2l_pinctrl *pctrl = container_of(gc, struct rzg2l_pinctrl, gpio_chip);\n\tunsigned int hwirq = irqd_to_hwirq(d);\n\tunsigned long flags;\n\tvoid __iomem *addr;\n\tu32 port;\n\tu8 bit;\n\n\tgpiochip_enable_irq(gc, hwirq);\n\n\tport = RZG2L_PIN_ID_TO_PORT(hwirq);\n\tbit = RZG2L_PIN_ID_TO_PIN(hwirq);\n\n\taddr = pctrl->base + ISEL(port);\n\tif (bit >= 4) {\n\t\tbit -= 4;\n\t\taddr += 4;\n\t}\n\n\tspin_lock_irqsave(&pctrl->lock, flags);\n\twritel(readl(addr) | BIT(bit * 8), addr);\n\tspin_unlock_irqrestore(&pctrl->lock, flags);\n\n\tirq_chip_enable_parent(d);\n}\n\nstatic int rzg2l_gpio_irq_set_type(struct irq_data *d, unsigned int type)\n{\n\treturn irq_chip_set_type_parent(d, type);\n}\n\nstatic void rzg2l_gpio_irqc_eoi(struct irq_data *d)\n{\n\tirq_chip_eoi_parent(d);\n}\n\nstatic void rzg2l_gpio_irq_print_chip(struct irq_data *data, struct seq_file *p)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(data);\n\n\tseq_printf(p, dev_name(gc->parent));\n}\n\nstatic const struct irq_chip rzg2l_gpio_irqchip = {\n\t.name = \"rzg2l-gpio\",\n\t.irq_disable = rzg2l_gpio_irq_disable,\n\t.irq_enable = rzg2l_gpio_irq_enable,\n\t.irq_mask = irq_chip_mask_parent,\n\t.irq_unmask = irq_chip_unmask_parent,\n\t.irq_set_type = rzg2l_gpio_irq_set_type,\n\t.irq_eoi = rzg2l_gpio_irqc_eoi,\n\t.irq_print_chip = rzg2l_gpio_irq_print_chip,\n\t.flags = IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic int rzg2l_gpio_child_to_parent_hwirq(struct gpio_chip *gc,\n\t\t\t\t\t    unsigned int child,\n\t\t\t\t\t    unsigned int child_type,\n\t\t\t\t\t    unsigned int *parent,\n\t\t\t\t\t    unsigned int *parent_type)\n{\n\tstruct rzg2l_pinctrl *pctrl = gpiochip_get_data(gc);\n\tunsigned long flags;\n\tint gpioint, irq;\n\n\tgpioint = rzg2l_gpio_get_gpioint(child, pctrl->data);\n\tif (gpioint < 0)\n\t\treturn gpioint;\n\n\tspin_lock_irqsave(&pctrl->bitmap_lock, flags);\n\tirq = bitmap_find_free_region(pctrl->tint_slot, RZG2L_TINT_MAX_INTERRUPT, get_order(1));\n\tspin_unlock_irqrestore(&pctrl->bitmap_lock, flags);\n\tif (irq < 0)\n\t\treturn -ENOSPC;\n\tpctrl->hwirq[irq] = child;\n\tirq += RZG2L_TINT_IRQ_START_INDEX;\n\n\t \n\t*parent_type = IRQ_TYPE_LEVEL_HIGH;\n\t*parent = RZG2L_PACK_HWIRQ(gpioint, irq);\n\treturn 0;\n}\n\nstatic int rzg2l_gpio_populate_parent_fwspec(struct gpio_chip *chip,\n\t\t\t\t\t     union gpio_irq_fwspec *gfwspec,\n\t\t\t\t\t     unsigned int parent_hwirq,\n\t\t\t\t\t     unsigned int parent_type)\n{\n\tstruct irq_fwspec *fwspec = &gfwspec->fwspec;\n\n\tfwspec->fwnode = chip->irq.parent_domain->fwnode;\n\tfwspec->param_count = 2;\n\tfwspec->param[0] = parent_hwirq;\n\tfwspec->param[1] = parent_type;\n\n\treturn 0;\n}\n\nstatic void rzg2l_gpio_irq_domain_free(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t       unsigned int nr_irqs)\n{\n\tstruct irq_data *d;\n\n\td = irq_domain_get_irq_data(domain, virq);\n\tif (d) {\n\t\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\t\tstruct rzg2l_pinctrl *pctrl = container_of(gc, struct rzg2l_pinctrl, gpio_chip);\n\t\tirq_hw_number_t hwirq = irqd_to_hwirq(d);\n\t\tunsigned long flags;\n\t\tunsigned int i;\n\n\t\tfor (i = 0; i < RZG2L_TINT_MAX_INTERRUPT; i++) {\n\t\t\tif (pctrl->hwirq[i] == hwirq) {\n\t\t\t\tspin_lock_irqsave(&pctrl->bitmap_lock, flags);\n\t\t\t\tbitmap_release_region(pctrl->tint_slot, i, get_order(1));\n\t\t\t\tspin_unlock_irqrestore(&pctrl->bitmap_lock, flags);\n\t\t\t\tpctrl->hwirq[i] = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tirq_domain_free_irqs_common(domain, virq, nr_irqs);\n}\n\nstatic void rzg2l_init_irq_valid_mask(struct gpio_chip *gc,\n\t\t\t\t      unsigned long *valid_mask,\n\t\t\t\t      unsigned int ngpios)\n{\n\tstruct rzg2l_pinctrl *pctrl = gpiochip_get_data(gc);\n\tstruct gpio_chip *chip = &pctrl->gpio_chip;\n\tunsigned int offset;\n\n\t \n\tfor (offset = 0; offset < chip->ngpio; offset++) {\n\t\tu32 port, bit;\n\n\t\tport = offset / 8;\n\t\tbit = offset % 8;\n\n\t\tif (port >= pctrl->data->n_ports ||\n\t\t    bit >= RZG2L_GPIO_PORT_GET_PINCNT(pctrl->data->port_pin_configs[port]))\n\t\t\tclear_bit(offset, valid_mask);\n\t}\n}\n\nstatic int rzg2l_gpio_register(struct rzg2l_pinctrl *pctrl)\n{\n\tstruct device_node *np = pctrl->dev->of_node;\n\tstruct gpio_chip *chip = &pctrl->gpio_chip;\n\tconst char *name = dev_name(pctrl->dev);\n\tstruct irq_domain *parent_domain;\n\tstruct of_phandle_args of_args;\n\tstruct device_node *parent_np;\n\tstruct gpio_irq_chip *girq;\n\tint ret;\n\n\tparent_np = of_irq_find_parent(np);\n\tif (!parent_np)\n\t\treturn -ENXIO;\n\n\tparent_domain = irq_find_host(parent_np);\n\tof_node_put(parent_np);\n\tif (!parent_domain)\n\t\treturn -EPROBE_DEFER;\n\n\tret = of_parse_phandle_with_fixed_args(np, \"gpio-ranges\", 3, 0, &of_args);\n\tif (ret) {\n\t\tdev_err(pctrl->dev, \"Unable to parse gpio-ranges\\n\");\n\t\treturn ret;\n\t}\n\n\tif (of_args.args[0] != 0 || of_args.args[1] != 0 ||\n\t    of_args.args[2] != pctrl->data->n_port_pins) {\n\t\tdev_err(pctrl->dev, \"gpio-ranges does not match selected SOC\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tchip->names = pctrl->data->port_pins;\n\tchip->request = rzg2l_gpio_request;\n\tchip->free = rzg2l_gpio_free;\n\tchip->get_direction = rzg2l_gpio_get_direction;\n\tchip->direction_input = rzg2l_gpio_direction_input;\n\tchip->direction_output = rzg2l_gpio_direction_output;\n\tchip->get = rzg2l_gpio_get;\n\tchip->set = rzg2l_gpio_set;\n\tchip->label = name;\n\tchip->parent = pctrl->dev;\n\tchip->owner = THIS_MODULE;\n\tchip->base = -1;\n\tchip->ngpio = of_args.args[2];\n\n\tgirq = &chip->irq;\n\tgpio_irq_chip_set_chip(girq, &rzg2l_gpio_irqchip);\n\tgirq->fwnode = of_node_to_fwnode(np);\n\tgirq->parent_domain = parent_domain;\n\tgirq->child_to_parent_hwirq = rzg2l_gpio_child_to_parent_hwirq;\n\tgirq->populate_parent_alloc_arg = rzg2l_gpio_populate_parent_fwspec;\n\tgirq->child_irq_domain_ops.free = rzg2l_gpio_irq_domain_free;\n\tgirq->init_valid_mask = rzg2l_init_irq_valid_mask;\n\n\tpctrl->gpio_range.id = 0;\n\tpctrl->gpio_range.pin_base = 0;\n\tpctrl->gpio_range.base = 0;\n\tpctrl->gpio_range.npins = chip->ngpio;\n\tpctrl->gpio_range.name = chip->label;\n\tpctrl->gpio_range.gc = chip;\n\tret = devm_gpiochip_add_data(pctrl->dev, chip, pctrl);\n\tif (ret) {\n\t\tdev_err(pctrl->dev, \"failed to add GPIO controller\\n\");\n\t\treturn ret;\n\t}\n\n\tdev_dbg(pctrl->dev, \"Registered gpio controller\\n\");\n\n\treturn 0;\n}\n\nstatic int rzg2l_pinctrl_register(struct rzg2l_pinctrl *pctrl)\n{\n\tstruct pinctrl_pin_desc *pins;\n\tunsigned int i, j;\n\tu32 *pin_data;\n\tint ret;\n\n\tpctrl->desc.name = DRV_NAME;\n\tpctrl->desc.npins = pctrl->data->n_port_pins + pctrl->data->n_dedicated_pins;\n\tpctrl->desc.pctlops = &rzg2l_pinctrl_pctlops;\n\tpctrl->desc.pmxops = &rzg2l_pinctrl_pmxops;\n\tpctrl->desc.confops = &rzg2l_pinctrl_confops;\n\tpctrl->desc.owner = THIS_MODULE;\n\n\tpins = devm_kcalloc(pctrl->dev, pctrl->desc.npins, sizeof(*pins), GFP_KERNEL);\n\tif (!pins)\n\t\treturn -ENOMEM;\n\n\tpin_data = devm_kcalloc(pctrl->dev, pctrl->desc.npins,\n\t\t\t\tsizeof(*pin_data), GFP_KERNEL);\n\tif (!pin_data)\n\t\treturn -ENOMEM;\n\n\tpctrl->pins = pins;\n\tpctrl->desc.pins = pins;\n\n\tfor (i = 0, j = 0; i < pctrl->data->n_port_pins; i++) {\n\t\tpins[i].number = i;\n\t\tpins[i].name = pctrl->data->port_pins[i];\n\t\tif (i && !(i % RZG2L_PINS_PER_PORT))\n\t\t\tj++;\n\t\tpin_data[i] = pctrl->data->port_pin_configs[j];\n\t\tpins[i].drv_data = &pin_data[i];\n\t}\n\n\tfor (i = 0; i < pctrl->data->n_dedicated_pins; i++) {\n\t\tunsigned int index = pctrl->data->n_port_pins + i;\n\n\t\tpins[index].number = index;\n\t\tpins[index].name = pctrl->data->dedicated_pins[i].name;\n\t\tpin_data[index] = pctrl->data->dedicated_pins[i].config;\n\t\tpins[index].drv_data = &pin_data[index];\n\t}\n\n\tret = devm_pinctrl_register_and_init(pctrl->dev, &pctrl->desc, pctrl,\n\t\t\t\t\t     &pctrl->pctl);\n\tif (ret) {\n\t\tdev_err(pctrl->dev, \"pinctrl registration failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = pinctrl_enable(pctrl->pctl);\n\tif (ret) {\n\t\tdev_err(pctrl->dev, \"pinctrl enable failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = rzg2l_gpio_register(pctrl);\n\tif (ret) {\n\t\tdev_err(pctrl->dev, \"failed to add GPIO chip: %i\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int rzg2l_pinctrl_probe(struct platform_device *pdev)\n{\n\tstruct rzg2l_pinctrl *pctrl;\n\tstruct clk *clk;\n\tint ret;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(rzg2l_gpio_configs) * RZG2L_PINS_PER_PORT >\n\t\t     ARRAY_SIZE(rzg2l_gpio_names));\n\n\tBUILD_BUG_ON(ARRAY_SIZE(r9a07g043_gpio_configs) * RZG2L_PINS_PER_PORT >\n\t\t     ARRAY_SIZE(rzg2l_gpio_names));\n\n\tpctrl = devm_kzalloc(&pdev->dev, sizeof(*pctrl), GFP_KERNEL);\n\tif (!pctrl)\n\t\treturn -ENOMEM;\n\n\tpctrl->dev = &pdev->dev;\n\n\tpctrl->data = of_device_get_match_data(&pdev->dev);\n\tif (!pctrl->data)\n\t\treturn -EINVAL;\n\n\tpctrl->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(pctrl->base))\n\t\treturn PTR_ERR(pctrl->base);\n\n\tclk = devm_clk_get_enabled(pctrl->dev, NULL);\n\tif (IS_ERR(clk))\n\t\treturn dev_err_probe(pctrl->dev, PTR_ERR(clk),\n\t\t\t\t     \"failed to enable GPIO clk\\n\");\n\n\tspin_lock_init(&pctrl->lock);\n\tspin_lock_init(&pctrl->bitmap_lock);\n\tmutex_init(&pctrl->mutex);\n\n\tplatform_set_drvdata(pdev, pctrl);\n\n\tret = rzg2l_pinctrl_register(pctrl);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_info(pctrl->dev, \"%s support registered\\n\", DRV_NAME);\n\treturn 0;\n}\n\nstatic struct rzg2l_pinctrl_data r9a07g043_data = {\n\t.port_pins = rzg2l_gpio_names,\n\t.port_pin_configs = r9a07g043_gpio_configs,\n\t.n_ports = ARRAY_SIZE(r9a07g043_gpio_configs),\n\t.dedicated_pins = rzg2l_dedicated_pins.common,\n\t.n_port_pins = ARRAY_SIZE(r9a07g043_gpio_configs) * RZG2L_PINS_PER_PORT,\n\t.n_dedicated_pins = ARRAY_SIZE(rzg2l_dedicated_pins.common),\n};\n\nstatic struct rzg2l_pinctrl_data r9a07g044_data = {\n\t.port_pins = rzg2l_gpio_names,\n\t.port_pin_configs = rzg2l_gpio_configs,\n\t.n_ports = ARRAY_SIZE(rzg2l_gpio_configs),\n\t.dedicated_pins = rzg2l_dedicated_pins.common,\n\t.n_port_pins = ARRAY_SIZE(rzg2l_gpio_configs) * RZG2L_PINS_PER_PORT,\n\t.n_dedicated_pins = ARRAY_SIZE(rzg2l_dedicated_pins.common) +\n\t\tARRAY_SIZE(rzg2l_dedicated_pins.rzg2l_pins),\n};\n\nstatic const struct of_device_id rzg2l_pinctrl_of_table[] = {\n\t{\n\t\t.compatible = \"renesas,r9a07g043-pinctrl\",\n\t\t.data = &r9a07g043_data,\n\t},\n\t{\n\t\t.compatible = \"renesas,r9a07g044-pinctrl\",\n\t\t.data = &r9a07g044_data,\n\t},\n\t{   }\n};\n\nstatic struct platform_driver rzg2l_pinctrl_driver = {\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.of_match_table = of_match_ptr(rzg2l_pinctrl_of_table),\n\t},\n\t.probe = rzg2l_pinctrl_probe,\n};\n\nstatic int __init rzg2l_pinctrl_init(void)\n{\n\treturn platform_driver_register(&rzg2l_pinctrl_driver);\n}\ncore_initcall(rzg2l_pinctrl_init);\n\nMODULE_AUTHOR(\"Lad Prabhakar <prabhakar.mahadev-lad.rj@bp.renesas.com>\");\nMODULE_DESCRIPTION(\"Pin and gpio controller driver for RZ/G2L family\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}