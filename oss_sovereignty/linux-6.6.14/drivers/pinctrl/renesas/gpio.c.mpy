{
  "module_name": "gpio.c",
  "hash_id": "4bcaf1c374a172ff6d212d254216168e059f52e2ce12c047fe2682a02a0e6708",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/renesas/gpio.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/gpio/driver.h>\n#include <linux/module.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\n#include \"core.h\"\n\nstruct sh_pfc_gpio_data_reg {\n\tconst struct pinmux_data_reg *info;\n\tu32 shadow;\n};\n\nstruct sh_pfc_gpio_pin {\n\tu8 dbit;\n\tu8 dreg;\n};\n\nstruct sh_pfc_chip {\n\tstruct sh_pfc\t\t\t*pfc;\n\tstruct gpio_chip\t\tgpio_chip;\n\n\tstruct sh_pfc_window\t\t*mem;\n\tstruct sh_pfc_gpio_data_reg\t*regs;\n\tstruct sh_pfc_gpio_pin\t\t*pins;\n};\n\nstatic struct sh_pfc *gpio_to_pfc(struct gpio_chip *gc)\n{\n\tstruct sh_pfc_chip *chip = gpiochip_get_data(gc);\n\treturn chip->pfc;\n}\n\nstatic void gpio_get_data_reg(struct sh_pfc_chip *chip, unsigned int offset,\n\t\t\t      struct sh_pfc_gpio_data_reg **reg,\n\t\t\t      unsigned int *bit)\n{\n\tint idx = sh_pfc_get_pin_index(chip->pfc, offset);\n\tstruct sh_pfc_gpio_pin *gpio_pin = &chip->pins[idx];\n\n\t*reg = &chip->regs[gpio_pin->dreg];\n\t*bit = gpio_pin->dbit;\n}\n\nstatic u32 gpio_read_data_reg(struct sh_pfc_chip *chip,\n\t\t\t      const struct pinmux_data_reg *dreg)\n{\n\tphys_addr_t address = dreg->reg;\n\tvoid __iomem *mem = address - chip->mem->phys + chip->mem->virt;\n\n\treturn sh_pfc_read_raw_reg(mem, dreg->reg_width);\n}\n\nstatic void gpio_write_data_reg(struct sh_pfc_chip *chip,\n\t\t\t\tconst struct pinmux_data_reg *dreg, u32 value)\n{\n\tphys_addr_t address = dreg->reg;\n\tvoid __iomem *mem = address - chip->mem->phys + chip->mem->virt;\n\n\tsh_pfc_write_raw_reg(mem, dreg->reg_width, value);\n}\n\nstatic void gpio_setup_data_reg(struct sh_pfc_chip *chip, unsigned idx)\n{\n\tstruct sh_pfc *pfc = chip->pfc;\n\tstruct sh_pfc_gpio_pin *gpio_pin = &chip->pins[idx];\n\tconst struct sh_pfc_pin *pin = &pfc->info->pins[idx];\n\tconst struct pinmux_data_reg *dreg;\n\tunsigned int bit;\n\tunsigned int i;\n\n\tfor (i = 0, dreg = pfc->info->data_regs; dreg->reg_width; ++i, ++dreg) {\n\t\tfor (bit = 0; bit < dreg->reg_width; bit++) {\n\t\t\tif (dreg->enum_ids[bit] == pin->enum_id) {\n\t\t\t\tgpio_pin->dreg = i;\n\t\t\t\tgpio_pin->dbit = bit;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tBUG();\n}\n\nstatic int gpio_setup_data_regs(struct sh_pfc_chip *chip)\n{\n\tstruct sh_pfc *pfc = chip->pfc;\n\tconst struct pinmux_data_reg *dreg;\n\tunsigned int i;\n\n\t \n\tfor (i = 0; pfc->info->data_regs[i].reg_width; ++i)\n\t\t;\n\n\tchip->regs = devm_kcalloc(pfc->dev, i, sizeof(*chip->regs),\n\t\t\t\t  GFP_KERNEL);\n\tif (chip->regs == NULL)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0, dreg = pfc->info->data_regs; dreg->reg_width; ++i, ++dreg) {\n\t\tchip->regs[i].info = dreg;\n\t\tchip->regs[i].shadow = gpio_read_data_reg(chip, dreg);\n\t}\n\n\tfor (i = 0; i < pfc->info->nr_pins; i++) {\n\t\tif (pfc->info->pins[i].enum_id == 0)\n\t\t\tcontinue;\n\n\t\tgpio_setup_data_reg(chip, i);\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int gpio_pin_request(struct gpio_chip *gc, unsigned offset)\n{\n\tstruct sh_pfc *pfc = gpio_to_pfc(gc);\n\tint idx = sh_pfc_get_pin_index(pfc, offset);\n\n\tif (idx < 0 || pfc->info->pins[idx].enum_id == 0)\n\t\treturn -EINVAL;\n\n\treturn pinctrl_gpio_request(gc->base + offset);\n}\n\nstatic void gpio_pin_free(struct gpio_chip *gc, unsigned offset)\n{\n\treturn pinctrl_gpio_free(gc->base + offset);\n}\n\nstatic void gpio_pin_set_value(struct sh_pfc_chip *chip, unsigned offset,\n\t\t\t       int value)\n{\n\tstruct sh_pfc_gpio_data_reg *reg;\n\tunsigned int bit;\n\tunsigned int pos;\n\n\tgpio_get_data_reg(chip, offset, &reg, &bit);\n\n\tpos = reg->info->reg_width - (bit + 1);\n\n\tif (value)\n\t\treg->shadow |= BIT(pos);\n\telse\n\t\treg->shadow &= ~BIT(pos);\n\n\tgpio_write_data_reg(chip, reg->info, reg->shadow);\n}\n\nstatic int gpio_pin_direction_input(struct gpio_chip *gc, unsigned offset)\n{\n\treturn pinctrl_gpio_direction_input(gc->base + offset);\n}\n\nstatic int gpio_pin_direction_output(struct gpio_chip *gc, unsigned offset,\n\t\t\t\t    int value)\n{\n\tgpio_pin_set_value(gpiochip_get_data(gc), offset, value);\n\n\treturn pinctrl_gpio_direction_output(gc->base + offset);\n}\n\nstatic int gpio_pin_get(struct gpio_chip *gc, unsigned offset)\n{\n\tstruct sh_pfc_chip *chip = gpiochip_get_data(gc);\n\tstruct sh_pfc_gpio_data_reg *reg;\n\tunsigned int bit;\n\tunsigned int pos;\n\n\tgpio_get_data_reg(chip, offset, &reg, &bit);\n\n\tpos = reg->info->reg_width - (bit + 1);\n\n\treturn (gpio_read_data_reg(chip, reg->info) >> pos) & 1;\n}\n\nstatic void gpio_pin_set(struct gpio_chip *gc, unsigned offset, int value)\n{\n\tgpio_pin_set_value(gpiochip_get_data(gc), offset, value);\n}\n\nstatic int gpio_pin_to_irq(struct gpio_chip *gc, unsigned offset)\n{\n\tstruct sh_pfc *pfc = gpio_to_pfc(gc);\n\tunsigned int i, k;\n\n\tfor (i = 0; i < pfc->info->gpio_irq_size; i++) {\n\t\tconst short *gpios = pfc->info->gpio_irq[i].gpios;\n\n\t\tfor (k = 0; gpios[k] >= 0; k++) {\n\t\t\tif (gpios[k] == offset)\n\t\t\t\treturn pfc->irqs[i];\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int gpio_pin_setup(struct sh_pfc_chip *chip)\n{\n\tstruct sh_pfc *pfc = chip->pfc;\n\tstruct gpio_chip *gc = &chip->gpio_chip;\n\tint ret;\n\n\tchip->pins = devm_kcalloc(pfc->dev,\n\t\t\t\t  pfc->info->nr_pins, sizeof(*chip->pins),\n\t\t\t\t  GFP_KERNEL);\n\tif (chip->pins == NULL)\n\t\treturn -ENOMEM;\n\n\tret = gpio_setup_data_regs(chip);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tgc->request = gpio_pin_request;\n\tgc->free = gpio_pin_free;\n\tgc->direction_input = gpio_pin_direction_input;\n\tgc->get = gpio_pin_get;\n\tgc->direction_output = gpio_pin_direction_output;\n\tgc->set = gpio_pin_set;\n\tgc->to_irq = gpio_pin_to_irq;\n\n\tgc->label = pfc->info->name;\n\tgc->parent = pfc->dev;\n\tgc->owner = THIS_MODULE;\n\tgc->base = IS_ENABLED(CONFIG_PINCTRL_SH_FUNC_GPIO) ? 0 : -1;\n\tgc->ngpio = pfc->nr_gpio_pins;\n\n\treturn 0;\n}\n\n \n\n#ifdef CONFIG_PINCTRL_SH_FUNC_GPIO\nstatic int gpio_function_request(struct gpio_chip *gc, unsigned offset)\n{\n\tstruct sh_pfc *pfc = gpio_to_pfc(gc);\n\tunsigned int mark = pfc->info->func_gpios[offset].enum_id;\n\tunsigned long flags;\n\tint ret;\n\n\tdev_notice_once(pfc->dev,\n\t\t\t\"Use of GPIO API for function requests is deprecated, convert to pinctrl\\n\");\n\n\tif (mark == 0)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&pfc->lock, flags);\n\tret = sh_pfc_config_mux(pfc, mark, PINMUX_TYPE_FUNCTION);\n\tspin_unlock_irqrestore(&pfc->lock, flags);\n\n\treturn ret;\n}\n\nstatic int gpio_function_setup(struct sh_pfc_chip *chip)\n{\n\tstruct sh_pfc *pfc = chip->pfc;\n\tstruct gpio_chip *gc = &chip->gpio_chip;\n\n\tgc->request = gpio_function_request;\n\n\tgc->label = pfc->info->name;\n\tgc->owner = THIS_MODULE;\n\tgc->base = pfc->nr_gpio_pins;\n\tgc->ngpio = pfc->info->nr_func_gpios;\n\n\treturn 0;\n}\n#endif  \n\n \n\nstatic struct sh_pfc_chip *\nsh_pfc_add_gpiochip(struct sh_pfc *pfc, int(*setup)(struct sh_pfc_chip *),\n\t\t    struct sh_pfc_window *mem)\n{\n\tstruct sh_pfc_chip *chip;\n\tint ret;\n\n\tchip = devm_kzalloc(pfc->dev, sizeof(*chip), GFP_KERNEL);\n\tif (unlikely(!chip))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tchip->mem = mem;\n\tchip->pfc = pfc;\n\n\tret = setup(chip);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\tret = devm_gpiochip_add_data(pfc->dev, &chip->gpio_chip, chip);\n\tif (unlikely(ret < 0))\n\t\treturn ERR_PTR(ret);\n\n\tdev_info(pfc->dev, \"%s handling gpio %u -> %u\\n\",\n\t\t chip->gpio_chip.label, chip->gpio_chip.base,\n\t\t chip->gpio_chip.base + chip->gpio_chip.ngpio - 1);\n\n\treturn chip;\n}\n\nint sh_pfc_register_gpiochip(struct sh_pfc *pfc)\n{\n\tstruct sh_pfc_chip *chip;\n\tphys_addr_t address;\n\tunsigned int i;\n\n\tif (pfc->info->data_regs == NULL)\n\t\treturn 0;\n\n\t \n\taddress = pfc->info->data_regs[0].reg;\n\tfor (i = 0; i < pfc->num_windows; ++i) {\n\t\tstruct sh_pfc_window *window = &pfc->windows[i];\n\n\t\tif (address >= window->phys &&\n\t\t    address < window->phys + window->size)\n\t\t\tbreak;\n\t}\n\n\tif (i == pfc->num_windows)\n\t\treturn 0;\n\n\t \n\tif (pfc->num_irqs != pfc->info->gpio_irq_size) {\n\t\tdev_err(pfc->dev, \"invalid number of IRQ resources\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tchip = sh_pfc_add_gpiochip(pfc, gpio_pin_setup, &pfc->windows[i]);\n\tif (IS_ERR(chip))\n\t\treturn PTR_ERR(chip);\n\n\tpfc->gpio = chip;\n\n\tif (IS_ENABLED(CONFIG_OF) && pfc->dev->of_node)\n\t\treturn 0;\n\n#ifdef CONFIG_PINCTRL_SH_FUNC_GPIO\n\t \n\tfor (i = 0; i < pfc->nr_ranges; ++i) {\n\t\tconst struct sh_pfc_pin_range *range = &pfc->ranges[i];\n\t\tint ret;\n\n\t\tif (range->start >= pfc->nr_gpio_pins)\n\t\t\tbreak;\n\n\t\tret = gpiochip_add_pin_range(&chip->gpio_chip,\n\t\t\tdev_name(pfc->dev), range->start, range->start,\n\t\t\trange->end - range->start + 1);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (pfc->info->nr_func_gpios) {\n\t\tchip = sh_pfc_add_gpiochip(pfc, gpio_function_setup, NULL);\n\t\tif (IS_ERR(chip))\n\t\t\treturn PTR_ERR(chip);\n\t}\n#endif  \n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}