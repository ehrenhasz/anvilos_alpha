{
  "module_name": "pinctrl-rza2.c",
  "hash_id": "06689d3b3553233439753760fcc7e37a9522e84161c2ad89413a2c94fa958b36",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/renesas/pinctrl-rza2.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/bitops.h>\n#include <linux/gpio/driver.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/pinctrl/pinmux.h>\n#include <linux/platform_device.h>\n\n#include \"../core.h\"\n#include \"../pinmux.h\"\n\n#define DRIVER_NAME\t\t\"pinctrl-rza2\"\n\n#define RZA2_PINS_PER_PORT\t8\n#define RZA2_PIN_ID_TO_PORT(id)\t((id) / RZA2_PINS_PER_PORT)\n#define RZA2_PIN_ID_TO_PIN(id)\t((id) % RZA2_PINS_PER_PORT)\n\n \n#define MUX_PIN_ID_MASK\t\tGENMASK(15, 0)\n#define MUX_FUNC_MASK\t\tGENMASK(31, 16)\n#define MUX_FUNC_OFFS\t\t16\n#define MUX_FUNC(pinconf)\t((pinconf & MUX_FUNC_MASK) >> MUX_FUNC_OFFS)\n\nstatic const char port_names[] = \"0123456789ABCDEFGHJKLM\";\n\nstruct rza2_pinctrl_priv {\n\tstruct device *dev;\n\tvoid __iomem *base;\n\n\tstruct pinctrl_pin_desc *pins;\n\tstruct pinctrl_desc desc;\n\tstruct pinctrl_dev *pctl;\n\tstruct pinctrl_gpio_range gpio_range;\n\tint npins;\n\tstruct mutex mutex;  \n};\n\n#define RZA2_PDR(port)\t\t(0x0000 + (port) * 2)\t \n#define RZA2_PODR(port)\t\t(0x0040 + (port))\t \n#define RZA2_PIDR(port)\t\t(0x0060 + (port))\t \n#define RZA2_PMR(port)\t\t(0x0080 + (port))\t \n#define RZA2_DSCR(port)\t\t(0x0140 + (port) * 2)\t \n#define RZA2_PFS(port, pin)\t(0x0200 + ((port) * 8) + (pin))\t \n\n#define RZA2_PWPR\t\t0x02ff\t \n#define RZA2_PFENET\t\t0x0820\t \n#define RZA2_PPOC\t\t0x0900\t \n#define RZA2_PHMOMO\t\t0x0980\t \n#define RZA2_PCKIO\t\t0x09d0\t \n\n#define RZA2_PDR_INPUT\t\t0x02\n#define RZA2_PDR_OUTPUT\t\t0x03\n#define RZA2_PDR_MASK\t\t0x03\n\n#define PWPR_B0WI\t\tBIT(7)\t \n#define PWPR_PFSWE\t\tBIT(6)\t \n#define PFS_ISEL\t\tBIT(6)\t \n\nstatic void rza2_set_pin_function(void __iomem *pfc_base, u8 port, u8 pin,\n\t\t\t\t  u8 func)\n{\n\tu16 mask16;\n\tu16 reg16;\n\tu8 reg8;\n\n\t \n\treg16 = readw(pfc_base + RZA2_PDR(port));\n\tmask16 = RZA2_PDR_MASK << (pin * 2);\n\treg16 &= ~mask16;\n\twritew(reg16, pfc_base + RZA2_PDR(port));\n\n\t \n\treg8 = readb(pfc_base + RZA2_PMR(port));\n\treg8 &= ~BIT(pin);\n\twriteb(reg8, pfc_base + RZA2_PMR(port));\n\n\t \n\twriteb(0x00, pfc_base + RZA2_PWPR);\t\t \n\twriteb(PWPR_PFSWE, pfc_base + RZA2_PWPR);\t \n\n\t \n\twriteb(func, pfc_base + RZA2_PFS(port, pin));\n\n\t \n\twriteb(0x00, pfc_base + RZA2_PWPR);\t \n\twriteb(0x80, pfc_base + RZA2_PWPR);\t \n\n\t \n\treg8 = readb(pfc_base + RZA2_PMR(port));\n\treg8 |= BIT(pin);\n\twriteb(reg8, pfc_base + RZA2_PMR(port));\n}\n\nstatic void rza2_pin_to_gpio(void __iomem *pfc_base, unsigned int offset,\n\t\t\t     u8 dir)\n{\n\tu8 port = RZA2_PIN_ID_TO_PORT(offset);\n\tu8 pin = RZA2_PIN_ID_TO_PIN(offset);\n\tu16 mask16;\n\tu16 reg16;\n\n\treg16 = readw(pfc_base + RZA2_PDR(port));\n\tmask16 = RZA2_PDR_MASK << (pin * 2);\n\treg16 &= ~mask16;\n\n\tif (dir)\n\t\treg16 |= RZA2_PDR_INPUT << (pin * 2);\t \n\telse\n\t\treg16 |= RZA2_PDR_OUTPUT << (pin * 2);\t \n\n\twritew(reg16, pfc_base + RZA2_PDR(port));\n}\n\nstatic int rza2_chip_get_direction(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct rza2_pinctrl_priv *priv = gpiochip_get_data(chip);\n\tu8 port = RZA2_PIN_ID_TO_PORT(offset);\n\tu8 pin = RZA2_PIN_ID_TO_PIN(offset);\n\tu16 reg16;\n\n\treg16 = readw(priv->base + RZA2_PDR(port));\n\treg16 = (reg16 >> (pin * 2)) & RZA2_PDR_MASK;\n\n\tif (reg16 == RZA2_PDR_OUTPUT)\n\t\treturn GPIO_LINE_DIRECTION_OUT;\n\n\tif (reg16 == RZA2_PDR_INPUT)\n\t\treturn GPIO_LINE_DIRECTION_IN;\n\n\t \n\trza2_pin_to_gpio(priv->base, offset, 1);\n\n\treturn GPIO_LINE_DIRECTION_IN;\n}\n\nstatic int rza2_chip_direction_input(struct gpio_chip *chip,\n\t\t\t\t     unsigned int offset)\n{\n\tstruct rza2_pinctrl_priv *priv = gpiochip_get_data(chip);\n\n\trza2_pin_to_gpio(priv->base, offset, 1);\n\n\treturn 0;\n}\n\nstatic int rza2_chip_get(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct rza2_pinctrl_priv *priv = gpiochip_get_data(chip);\n\tu8 port = RZA2_PIN_ID_TO_PORT(offset);\n\tu8 pin = RZA2_PIN_ID_TO_PIN(offset);\n\n\treturn !!(readb(priv->base + RZA2_PIDR(port)) & BIT(pin));\n}\n\nstatic void rza2_chip_set(struct gpio_chip *chip, unsigned int offset,\n\t\t\t  int value)\n{\n\tstruct rza2_pinctrl_priv *priv = gpiochip_get_data(chip);\n\tu8 port = RZA2_PIN_ID_TO_PORT(offset);\n\tu8 pin = RZA2_PIN_ID_TO_PIN(offset);\n\tu8 new_value;\n\n\tnew_value = readb(priv->base + RZA2_PODR(port));\n\n\tif (value)\n\t\tnew_value |= BIT(pin);\n\telse\n\t\tnew_value &= ~BIT(pin);\n\n\twriteb(new_value, priv->base + RZA2_PODR(port));\n}\n\nstatic int rza2_chip_direction_output(struct gpio_chip *chip,\n\t\t\t\t      unsigned int offset, int val)\n{\n\tstruct rza2_pinctrl_priv *priv = gpiochip_get_data(chip);\n\n\trza2_chip_set(chip, offset, val);\n\trza2_pin_to_gpio(priv->base, offset, 0);\n\n\treturn 0;\n}\n\nstatic const char * const rza2_gpio_names[] = {\n\t\"P0_0\", \"P0_1\", \"P0_2\", \"P0_3\", \"P0_4\", \"P0_5\", \"P0_6\", \"P0_7\",\n\t\"P1_0\", \"P1_1\", \"P1_2\", \"P1_3\", \"P1_4\", \"P1_5\", \"P1_6\", \"P1_7\",\n\t\"P2_0\", \"P2_1\", \"P2_2\", \"P2_3\", \"P2_4\", \"P2_5\", \"P2_6\", \"P2_7\",\n\t\"P3_0\", \"P3_1\", \"P3_2\", \"P3_3\", \"P3_4\", \"P3_5\", \"P3_6\", \"P3_7\",\n\t\"P4_0\", \"P4_1\", \"P4_2\", \"P4_3\", \"P4_4\", \"P4_5\", \"P4_6\", \"P4_7\",\n\t\"P5_0\", \"P5_1\", \"P5_2\", \"P5_3\", \"P5_4\", \"P5_5\", \"P5_6\", \"P5_7\",\n\t\"P6_0\", \"P6_1\", \"P6_2\", \"P6_3\", \"P6_4\", \"P6_5\", \"P6_6\", \"P6_7\",\n\t\"P7_0\", \"P7_1\", \"P7_2\", \"P7_3\", \"P7_4\", \"P7_5\", \"P7_6\", \"P7_7\",\n\t\"P8_0\", \"P8_1\", \"P8_2\", \"P8_3\", \"P8_4\", \"P8_5\", \"P8_6\", \"P8_7\",\n\t\"P9_0\", \"P9_1\", \"P9_2\", \"P9_3\", \"P9_4\", \"P9_5\", \"P9_6\", \"P9_7\",\n\t\"PA_0\", \"PA_1\", \"PA_2\", \"PA_3\", \"PA_4\", \"PA_5\", \"PA_6\", \"PA_7\",\n\t\"PB_0\", \"PB_1\", \"PB_2\", \"PB_3\", \"PB_4\", \"PB_5\", \"PB_6\", \"PB_7\",\n\t\"PC_0\", \"PC_1\", \"PC_2\", \"PC_3\", \"PC_4\", \"PC_5\", \"PC_6\", \"PC_7\",\n\t\"PD_0\", \"PD_1\", \"PD_2\", \"PD_3\", \"PD_4\", \"PD_5\", \"PD_6\", \"PD_7\",\n\t\"PE_0\", \"PE_1\", \"PE_2\", \"PE_3\", \"PE_4\", \"PE_5\", \"PE_6\", \"PE_7\",\n\t\"PF_0\", \"PF_1\", \"PF_2\", \"PF_3\", \"PF_4\", \"PF_5\", \"PF_6\", \"PF_7\",\n\t\"PG_0\", \"PG_1\", \"PG_2\", \"PG_3\", \"PG_4\", \"PG_5\", \"PG_6\", \"PG_7\",\n\t\"PH_0\", \"PH_1\", \"PH_2\", \"PH_3\", \"PH_4\", \"PH_5\", \"PH_6\", \"PH_7\",\n\t \n\t\"PJ_0\", \"PJ_1\", \"PJ_2\", \"PJ_3\", \"PJ_4\", \"PJ_5\", \"PJ_6\", \"PJ_7\",\n\t\"PK_0\", \"PK_1\", \"PK_2\", \"PK_3\", \"PK_4\", \"PK_5\", \"PK_6\", \"PK_7\",\n\t\"PL_0\", \"PL_1\", \"PL_2\", \"PL_3\", \"PL_4\", \"PL_5\", \"PL_6\", \"PL_7\",\n\t\"PM_0\", \"PM_1\", \"PM_2\", \"PM_3\", \"PM_4\", \"PM_5\", \"PM_6\", \"PM_7\",\n};\n\nstatic struct gpio_chip chip = {\n\t.names = rza2_gpio_names,\n\t.base = -1,\n\t.get_direction = rza2_chip_get_direction,\n\t.direction_input = rza2_chip_direction_input,\n\t.direction_output = rza2_chip_direction_output,\n\t.get = rza2_chip_get,\n\t.set = rza2_chip_set,\n};\n\nstatic int rza2_gpio_register(struct rza2_pinctrl_priv *priv)\n{\n\tstruct device_node *np = priv->dev->of_node;\n\tstruct of_phandle_args of_args;\n\tint ret;\n\n\tchip.label = devm_kasprintf(priv->dev, GFP_KERNEL, \"%pOFn\", np);\n\tchip.parent = priv->dev;\n\tchip.ngpio = priv->npins;\n\n\tret = of_parse_phandle_with_fixed_args(np, \"gpio-ranges\", 3, 0,\n\t\t\t\t\t       &of_args);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"Unable to parse gpio-ranges\\n\");\n\t\treturn ret;\n\t}\n\n\tif ((of_args.args[0] != 0) ||\n\t    (of_args.args[1] != 0) ||\n\t    (of_args.args[2] != priv->npins)) {\n\t\tdev_err(priv->dev, \"gpio-ranges does not match selected SOC\\n\");\n\t\treturn -EINVAL;\n\t}\n\tpriv->gpio_range.id = 0;\n\tpriv->gpio_range.pin_base = priv->gpio_range.base = 0;\n\tpriv->gpio_range.npins = priv->npins;\n\tpriv->gpio_range.name = chip.label;\n\tpriv->gpio_range.gc = &chip;\n\n\t \n\tret = devm_gpiochip_add_data(priv->dev, &chip, priv);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tpinctrl_add_gpio_range(priv->pctl, &priv->gpio_range);\n\n\tdev_dbg(priv->dev, \"Registered gpio controller\\n\");\n\n\treturn 0;\n}\n\nstatic int rza2_pinctrl_register(struct rza2_pinctrl_priv *priv)\n{\n\tstruct pinctrl_pin_desc *pins;\n\tunsigned int i;\n\tint ret;\n\n\tpins = devm_kcalloc(priv->dev, priv->npins, sizeof(*pins), GFP_KERNEL);\n\tif (!pins)\n\t\treturn -ENOMEM;\n\n\tpriv->pins = pins;\n\tpriv->desc.pins = pins;\n\tpriv->desc.npins = priv->npins;\n\n\tfor (i = 0; i < priv->npins; i++) {\n\t\tpins[i].number = i;\n\t\tpins[i].name = rza2_gpio_names[i];\n\t}\n\n\tret = devm_pinctrl_register_and_init(priv->dev, &priv->desc, priv,\n\t\t\t\t\t     &priv->pctl);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"pinctrl registration failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = pinctrl_enable(priv->pctl);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"pinctrl enable failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = rza2_gpio_register(priv);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"GPIO registration failed\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int rza2_dt_node_to_map(struct pinctrl_dev *pctldev,\n\t\t\t       struct device_node *np,\n\t\t\t       struct pinctrl_map **map,\n\t\t\t       unsigned int *num_maps)\n{\n\tstruct rza2_pinctrl_priv *priv = pinctrl_dev_get_drvdata(pctldev);\n\tunsigned int *pins, *psel_val;\n\tint i, ret, npins, gsel, fsel;\n\tstruct property *of_pins;\n\tconst char **pin_fn;\n\n\t \n\tof_pins = of_find_property(np, \"pinmux\", NULL);\n\tif (!of_pins) {\n\t\tdev_info(priv->dev, \"Missing pinmux property\\n\");\n\t\treturn -ENOENT;\n\t}\n\tnpins = of_pins->length / sizeof(u32);\n\n\tpins = devm_kcalloc(priv->dev, npins, sizeof(*pins), GFP_KERNEL);\n\tpsel_val = devm_kcalloc(priv->dev, npins, sizeof(*psel_val),\n\t\t\t\tGFP_KERNEL);\n\tpin_fn = devm_kzalloc(priv->dev, sizeof(*pin_fn), GFP_KERNEL);\n\tif (!pins || !psel_val || !pin_fn)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = 0; i < npins; ++i) {\n\t\tu32 value;\n\n\t\tret = of_property_read_u32_index(np, \"pinmux\", i, &value);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tpins[i] = value & MUX_PIN_ID_MASK;\n\t\tpsel_val[i] = MUX_FUNC(value);\n\t}\n\n\tmutex_lock(&priv->mutex);\n\n\t \n\tgsel = pinctrl_generic_add_group(pctldev, np->name, pins, npins, NULL);\n\tif (gsel < 0) {\n\t\tret = gsel;\n\t\tgoto unlock;\n\t}\n\n\t \n\tpin_fn[0] = np->name;\n\tfsel = pinmux_generic_add_function(pctldev, np->name, pin_fn, 1,\n\t\t\t\t\t   psel_val);\n\tif (fsel < 0) {\n\t\tret = fsel;\n\t\tgoto remove_group;\n\t}\n\n\tdev_dbg(priv->dev, \"Parsed %pOF with %d pins\\n\", np, npins);\n\n\t \n\t*num_maps = 0;\n\t*map = kzalloc(sizeof(**map), GFP_KERNEL);\n\tif (!*map) {\n\t\tret = -ENOMEM;\n\t\tgoto remove_function;\n\t}\n\n\t(*map)->type = PIN_MAP_TYPE_MUX_GROUP;\n\t(*map)->data.mux.group = np->name;\n\t(*map)->data.mux.function = np->name;\n\t*num_maps = 1;\n\n\tmutex_unlock(&priv->mutex);\n\n\treturn 0;\n\nremove_function:\n\tpinmux_generic_remove_function(pctldev, fsel);\n\nremove_group:\n\tpinctrl_generic_remove_group(pctldev, gsel);\n\nunlock:\n\tmutex_unlock(&priv->mutex);\n\n\tdev_err(priv->dev, \"Unable to parse DT node %s\\n\", np->name);\n\n\treturn ret;\n}\n\nstatic void rza2_dt_free_map(struct pinctrl_dev *pctldev,\n\t\t\t     struct pinctrl_map *map, unsigned int num_maps)\n{\n\tkfree(map);\n}\n\nstatic const struct pinctrl_ops rza2_pinctrl_ops = {\n\t.get_groups_count\t= pinctrl_generic_get_group_count,\n\t.get_group_name\t\t= pinctrl_generic_get_group_name,\n\t.get_group_pins\t\t= pinctrl_generic_get_group_pins,\n\t.dt_node_to_map\t\t= rza2_dt_node_to_map,\n\t.dt_free_map\t\t= rza2_dt_free_map,\n};\n\nstatic int rza2_set_mux(struct pinctrl_dev *pctldev, unsigned int selector,\n\t\t\tunsigned int group)\n{\n\tstruct rza2_pinctrl_priv *priv = pinctrl_dev_get_drvdata(pctldev);\n\tstruct function_desc *func;\n\tunsigned int i, *psel_val;\n\tstruct group_desc *grp;\n\n\tgrp = pinctrl_generic_get_group(pctldev, group);\n\tif (!grp)\n\t\treturn -EINVAL;\n\n\tfunc = pinmux_generic_get_function(pctldev, selector);\n\tif (!func)\n\t\treturn -EINVAL;\n\n\tpsel_val = func->data;\n\n\tfor (i = 0; i < grp->num_pins; ++i) {\n\t\tdev_dbg(priv->dev, \"Setting P%c_%d to PSEL=%d\\n\",\n\t\t\tport_names[RZA2_PIN_ID_TO_PORT(grp->pins[i])],\n\t\t\tRZA2_PIN_ID_TO_PIN(grp->pins[i]),\n\t\t\tpsel_val[i]);\n\t\trza2_set_pin_function(\n\t\t\tpriv->base,\n\t\t\tRZA2_PIN_ID_TO_PORT(grp->pins[i]),\n\t\t\tRZA2_PIN_ID_TO_PIN(grp->pins[i]),\n\t\t\tpsel_val[i]);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct pinmux_ops rza2_pinmux_ops = {\n\t.get_functions_count\t= pinmux_generic_get_function_count,\n\t.get_function_name\t= pinmux_generic_get_function_name,\n\t.get_function_groups\t= pinmux_generic_get_function_groups,\n\t.set_mux\t\t= rza2_set_mux,\n\t.strict\t\t\t= true,\n};\n\nstatic int rza2_pinctrl_probe(struct platform_device *pdev)\n{\n\tstruct rza2_pinctrl_priv *priv;\n\tint ret;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->dev = &pdev->dev;\n\n\tpriv->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->base))\n\t\treturn PTR_ERR(priv->base);\n\n\tmutex_init(&priv->mutex);\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tpriv->npins = (int)(uintptr_t)of_device_get_match_data(&pdev->dev) *\n\t\t      RZA2_PINS_PER_PORT;\n\n\tpriv->desc.name\t\t= DRIVER_NAME;\n\tpriv->desc.pctlops\t= &rza2_pinctrl_ops;\n\tpriv->desc.pmxops\t= &rza2_pinmux_ops;\n\tpriv->desc.owner\t= THIS_MODULE;\n\n\tret = rza2_pinctrl_register(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_info(&pdev->dev, \"Registered ports P0 - P%c\\n\",\n\t\t port_names[priv->desc.npins / RZA2_PINS_PER_PORT - 1]);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id rza2_pinctrl_of_match[] = {\n\t{ .compatible = \"renesas,r7s9210-pinctrl\", .data = (void *)22, },\n\t{   }\n};\n\nstatic struct platform_driver rza2_pinctrl_driver = {\n\t.driver = {\n\t\t.name = DRIVER_NAME,\n\t\t.of_match_table = rza2_pinctrl_of_match,\n\t},\n\t.probe = rza2_pinctrl_probe,\n};\n\nstatic int __init rza2_pinctrl_init(void)\n{\n\treturn platform_driver_register(&rza2_pinctrl_driver);\n}\ncore_initcall(rza2_pinctrl_init);\n\nMODULE_AUTHOR(\"Chris Brandt <chris.brandt@renesas.com>\");\nMODULE_DESCRIPTION(\"Pin and gpio controller driver for RZ/A2 SoC\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}