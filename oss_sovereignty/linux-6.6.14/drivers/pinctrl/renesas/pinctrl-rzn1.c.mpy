{
  "module_name": "pinctrl-rzn1.c",
  "hash_id": "fb2909ff2df92a06a92af0cd7c533cc661e224fa989efb5e16d27dd1b054fda9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/renesas/pinctrl-rzn1.c",
  "human_readable_source": "\n \n\n#include <dt-bindings/pinctrl/rzn1-pinctrl.h>\n\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include <linux/pinctrl/pinconf-generic.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinmux.h>\n\n#include \"../core.h\"\n#include \"../pinconf.h\"\n#include \"../pinctrl-utils.h\"\n\n \n#define RZN1_L1_PIN_DRIVE_STRENGTH\t10\n#define RZN1_L1_PIN_DRIVE_STRENGTH_4MA\t0\n#define RZN1_L1_PIN_DRIVE_STRENGTH_6MA\t1\n#define RZN1_L1_PIN_DRIVE_STRENGTH_8MA\t2\n#define RZN1_L1_PIN_DRIVE_STRENGTH_12MA\t3\n#define RZN1_L1_PIN_PULL\t\t8\n#define RZN1_L1_PIN_PULL_NONE\t\t0\n#define RZN1_L1_PIN_PULL_UP\t\t1\n#define RZN1_L1_PIN_PULL_DOWN\t\t3\n#define RZN1_L1_FUNCTION\t\t0\n#define RZN1_L1_FUNC_MASK\t\t0xf\n#define RZN1_L1_FUNCTION_L2\t\t0xf\n\n \n\n \nstruct rzn1_pinctrl_regs {\n\tu32\tconf[170];\n\tu32\tpad0[86];\n\tu32\tstatus_protect;\t \n\t \n\tu32\tl2_mdio[2];\n};\n\n \nstruct rzn1_pmx_func {\n\tconst char *name;\n\tconst char **groups;\n\tunsigned int num_groups;\n};\n\n \nstruct rzn1_pin_group {\n\tconst char *name;\n\tconst char *func;\n\tunsigned int npins;\n\tunsigned int *pins;\n\tu8 *pin_ids;\n};\n\nstruct rzn1_pinctrl {\n\tstruct device *dev;\n\tstruct clk *clk;\n\tstruct pinctrl_dev *pctl;\n\tstruct rzn1_pinctrl_regs __iomem *lev1;\n\tstruct rzn1_pinctrl_regs __iomem *lev2;\n\tu32 lev1_protect_phys;\n\tu32 lev2_protect_phys;\n\tint mdio_func[2];\n\n\tstruct rzn1_pin_group *groups;\n\tunsigned int ngroups;\n\n\tstruct rzn1_pmx_func *functions;\n\tunsigned int nfunctions;\n};\n\n#define RZN1_PINS_PROP \"pinmux\"\n\n#define RZN1_PIN(pin) PINCTRL_PIN(pin, \"pl_gpio\"#pin)\n\nstatic const struct pinctrl_pin_desc rzn1_pins[] = {\n\tRZN1_PIN(0), RZN1_PIN(1), RZN1_PIN(2), RZN1_PIN(3), RZN1_PIN(4),\n\tRZN1_PIN(5), RZN1_PIN(6), RZN1_PIN(7), RZN1_PIN(8), RZN1_PIN(9),\n\tRZN1_PIN(10), RZN1_PIN(11), RZN1_PIN(12), RZN1_PIN(13), RZN1_PIN(14),\n\tRZN1_PIN(15), RZN1_PIN(16), RZN1_PIN(17), RZN1_PIN(18), RZN1_PIN(19),\n\tRZN1_PIN(20), RZN1_PIN(21), RZN1_PIN(22), RZN1_PIN(23), RZN1_PIN(24),\n\tRZN1_PIN(25), RZN1_PIN(26), RZN1_PIN(27), RZN1_PIN(28), RZN1_PIN(29),\n\tRZN1_PIN(30), RZN1_PIN(31), RZN1_PIN(32), RZN1_PIN(33), RZN1_PIN(34),\n\tRZN1_PIN(35), RZN1_PIN(36), RZN1_PIN(37), RZN1_PIN(38), RZN1_PIN(39),\n\tRZN1_PIN(40), RZN1_PIN(41), RZN1_PIN(42), RZN1_PIN(43), RZN1_PIN(44),\n\tRZN1_PIN(45), RZN1_PIN(46), RZN1_PIN(47), RZN1_PIN(48), RZN1_PIN(49),\n\tRZN1_PIN(50), RZN1_PIN(51), RZN1_PIN(52), RZN1_PIN(53), RZN1_PIN(54),\n\tRZN1_PIN(55), RZN1_PIN(56), RZN1_PIN(57), RZN1_PIN(58), RZN1_PIN(59),\n\tRZN1_PIN(60), RZN1_PIN(61), RZN1_PIN(62), RZN1_PIN(63), RZN1_PIN(64),\n\tRZN1_PIN(65), RZN1_PIN(66), RZN1_PIN(67), RZN1_PIN(68), RZN1_PIN(69),\n\tRZN1_PIN(70), RZN1_PIN(71), RZN1_PIN(72), RZN1_PIN(73), RZN1_PIN(74),\n\tRZN1_PIN(75), RZN1_PIN(76), RZN1_PIN(77), RZN1_PIN(78), RZN1_PIN(79),\n\tRZN1_PIN(80), RZN1_PIN(81), RZN1_PIN(82), RZN1_PIN(83), RZN1_PIN(84),\n\tRZN1_PIN(85), RZN1_PIN(86), RZN1_PIN(87), RZN1_PIN(88), RZN1_PIN(89),\n\tRZN1_PIN(90), RZN1_PIN(91), RZN1_PIN(92), RZN1_PIN(93), RZN1_PIN(94),\n\tRZN1_PIN(95), RZN1_PIN(96), RZN1_PIN(97), RZN1_PIN(98), RZN1_PIN(99),\n\tRZN1_PIN(100), RZN1_PIN(101), RZN1_PIN(102), RZN1_PIN(103),\n\tRZN1_PIN(104), RZN1_PIN(105), RZN1_PIN(106), RZN1_PIN(107),\n\tRZN1_PIN(108), RZN1_PIN(109), RZN1_PIN(110), RZN1_PIN(111),\n\tRZN1_PIN(112), RZN1_PIN(113), RZN1_PIN(114), RZN1_PIN(115),\n\tRZN1_PIN(116), RZN1_PIN(117), RZN1_PIN(118), RZN1_PIN(119),\n\tRZN1_PIN(120), RZN1_PIN(121), RZN1_PIN(122), RZN1_PIN(123),\n\tRZN1_PIN(124), RZN1_PIN(125), RZN1_PIN(126), RZN1_PIN(127),\n\tRZN1_PIN(128), RZN1_PIN(129), RZN1_PIN(130), RZN1_PIN(131),\n\tRZN1_PIN(132), RZN1_PIN(133), RZN1_PIN(134), RZN1_PIN(135),\n\tRZN1_PIN(136), RZN1_PIN(137), RZN1_PIN(138), RZN1_PIN(139),\n\tRZN1_PIN(140), RZN1_PIN(141), RZN1_PIN(142), RZN1_PIN(143),\n\tRZN1_PIN(144), RZN1_PIN(145), RZN1_PIN(146), RZN1_PIN(147),\n\tRZN1_PIN(148), RZN1_PIN(149), RZN1_PIN(150), RZN1_PIN(151),\n\tRZN1_PIN(152), RZN1_PIN(153), RZN1_PIN(154), RZN1_PIN(155),\n\tRZN1_PIN(156), RZN1_PIN(157), RZN1_PIN(158), RZN1_PIN(159),\n\tRZN1_PIN(160), RZN1_PIN(161), RZN1_PIN(162), RZN1_PIN(163),\n\tRZN1_PIN(164), RZN1_PIN(165), RZN1_PIN(166), RZN1_PIN(167),\n\tRZN1_PIN(168), RZN1_PIN(169),\n};\n\nenum {\n\tLOCK_LEVEL1 = 0x1,\n\tLOCK_LEVEL2 = 0x2,\n\tLOCK_ALL = LOCK_LEVEL1 | LOCK_LEVEL2,\n};\n\nstatic void rzn1_hw_set_lock(struct rzn1_pinctrl *ipctl, u8 lock, u8 value)\n{\n\t \n\tif (lock & LOCK_LEVEL1) {\n\t\tu32 val = ipctl->lev1_protect_phys | !(value & LOCK_LEVEL1);\n\n\t\twritel(val, &ipctl->lev1->status_protect);\n\t}\n\n\tif (lock & LOCK_LEVEL2) {\n\t\tu32 val = ipctl->lev2_protect_phys | !(value & LOCK_LEVEL2);\n\n\t\twritel(val, &ipctl->lev2->status_protect);\n\t}\n}\n\nstatic void rzn1_pinctrl_mdio_select(struct rzn1_pinctrl *ipctl, int mdio,\n\t\t\t\t     u32 func)\n{\n\tif (ipctl->mdio_func[mdio] >= 0 && ipctl->mdio_func[mdio] != func)\n\t\tdev_warn(ipctl->dev, \"conflicting setting for mdio%d!\\n\", mdio);\n\tipctl->mdio_func[mdio] = func;\n\n\tdev_dbg(ipctl->dev, \"setting mdio%d to %u\\n\", mdio, func);\n\n\twritel(func, &ipctl->lev2->l2_mdio[mdio]);\n}\n\n \nstatic int rzn1_set_hw_pin_func(struct rzn1_pinctrl *ipctl, unsigned int pin,\n\t\t\t\tu32 pin_config, u8 use_locks)\n{\n\tu32 l1_cache;\n\tu32 l2_cache;\n\tu32 l1;\n\tu32 l2;\n\n\t \n\tif (pin_config >= RZN1_FUNC_MDIO0_HIGHZ &&\n\t    pin_config <= RZN1_FUNC_MDIO1_E1_SWITCH) {\n\t\tint mdio_channel;\n\t\tu32 mdio_func;\n\n\t\tif (pin_config <= RZN1_FUNC_MDIO1_HIGHZ)\n\t\t\tmdio_channel = 0;\n\t\telse\n\t\t\tmdio_channel = 1;\n\n\t\t \n\t\tif (pin_config <= RZN1_FUNC_MDIO0_SWITCH) {\n\t\t\tmdio_func = pin_config - RZN1_FUNC_MDIO0_HIGHZ;\n\t\t\tpin_config = RZN1_FUNC_ETH_MDIO;\n\t\t} else if (pin_config <= RZN1_FUNC_MDIO0_E1_SWITCH) {\n\t\t\tmdio_func = pin_config - RZN1_FUNC_MDIO0_E1_HIGHZ;\n\t\t\tpin_config = RZN1_FUNC_ETH_MDIO_E1;\n\t\t} else if (pin_config <= RZN1_FUNC_MDIO1_SWITCH) {\n\t\t\tmdio_func = pin_config - RZN1_FUNC_MDIO1_HIGHZ;\n\t\t\tpin_config = RZN1_FUNC_ETH_MDIO;\n\t\t} else {\n\t\t\tmdio_func = pin_config - RZN1_FUNC_MDIO1_E1_HIGHZ;\n\t\t\tpin_config = RZN1_FUNC_ETH_MDIO_E1;\n\t\t}\n\t\trzn1_pinctrl_mdio_select(ipctl, mdio_channel, mdio_func);\n\t}\n\n\t \n\tif (pin >= ARRAY_SIZE(ipctl->lev1->conf) ||\n\t    pin_config >= RZN1_FUNC_MDIO0_HIGHZ)\n\t\treturn -EINVAL;\n\n\tl1 = readl(&ipctl->lev1->conf[pin]);\n\tl1_cache = l1;\n\tl2 = readl(&ipctl->lev2->conf[pin]);\n\tl2_cache = l2;\n\n\tdev_dbg(ipctl->dev, \"setting func for pin %u to %u\\n\", pin, pin_config);\n\n\tl1 &= ~(RZN1_L1_FUNC_MASK << RZN1_L1_FUNCTION);\n\n\tif (pin_config < RZN1_FUNC_L2_OFFSET) {\n\t\tl1 |= (pin_config << RZN1_L1_FUNCTION);\n\t} else {\n\t\tl1 |= (RZN1_L1_FUNCTION_L2 << RZN1_L1_FUNCTION);\n\n\t\tl2 = pin_config - RZN1_FUNC_L2_OFFSET;\n\t}\n\n\t \n\tif (l1 != l1_cache || l2 != l2_cache) {\n\t\twritel(l1, &ipctl->lev1->conf[pin]);\n\t\twritel(l2, &ipctl->lev2->conf[pin]);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct rzn1_pin_group *rzn1_pinctrl_find_group_by_name(\n\tconst struct rzn1_pinctrl *ipctl, const char *name)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ipctl->ngroups; i++) {\n\t\tif (!strcmp(ipctl->groups[i].name, name))\n\t\t\treturn &ipctl->groups[i];\n\t}\n\n\treturn NULL;\n}\n\nstatic int rzn1_get_groups_count(struct pinctrl_dev *pctldev)\n{\n\tstruct rzn1_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn ipctl->ngroups;\n}\n\nstatic const char *rzn1_get_group_name(struct pinctrl_dev *pctldev,\n\t\t\t\t       unsigned int selector)\n{\n\tstruct rzn1_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn ipctl->groups[selector].name;\n}\n\nstatic int rzn1_get_group_pins(struct pinctrl_dev *pctldev,\n\t\t\t       unsigned int selector, const unsigned int **pins,\n\t\t\t       unsigned int *npins)\n{\n\tstruct rzn1_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\n\n\tif (selector >= ipctl->ngroups)\n\t\treturn -EINVAL;\n\n\t*pins = ipctl->groups[selector].pins;\n\t*npins = ipctl->groups[selector].npins;\n\n\treturn 0;\n}\n\n \nstatic int rzn1_dt_node_to_map_one(struct pinctrl_dev *pctldev,\n\t\t\t\t   struct device_node *np,\n\t\t\t\t   struct pinctrl_map **map,\n\t\t\t\t   unsigned int *num_maps)\n{\n\tstruct rzn1_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct rzn1_pin_group *grp;\n\tunsigned long *configs = NULL;\n\tunsigned int reserved_maps = *num_maps;\n\tunsigned int num_configs = 0;\n\tunsigned int reserve = 1;\n\tint ret;\n\n\tdev_dbg(ipctl->dev, \"processing node %pOF\\n\", np);\n\n\tgrp = rzn1_pinctrl_find_group_by_name(ipctl, np->name);\n\tif (!grp) {\n\t\tdev_err(ipctl->dev, \"unable to find group for node %pOF\\n\", np);\n\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = pinconf_generic_parse_dt_config(np, pctldev, &configs,\n\t\t\t\t\t      &num_configs);\n\tif (ret < 0) {\n\t\tdev_err(ipctl->dev, \"%pOF: could not parse property\\n\", np);\n\n\t\treturn ret;\n\t}\n\n\tif (num_configs)\n\t\treserve++;\n\n\t \n\tret = pinctrl_utils_reserve_map(pctldev, map, &reserved_maps, num_maps,\n\t\t\t\t\treserve);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tret = pinctrl_utils_add_map_mux(pctldev, map, &reserved_maps, num_maps,\n\t\t\t\t\tgrp->name, grp->func);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (num_configs) {\n\t\t \n\t\tret = pinctrl_utils_add_map_configs(pctldev, map,\n\t\t\t\t&reserved_maps, num_maps, grp->name,\n\t\t\t\tconfigs, num_configs,\n\t\t\t\tPIN_MAP_TYPE_CONFIGS_GROUP);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tdev_dbg(pctldev->dev, \"maps: function %s group %s (%d pins)\\n\",\n\t\tgrp->func, grp->name, grp->npins);\n\nout:\n\tkfree(configs);\n\n\treturn ret;\n}\n\nstatic int rzn1_dt_node_to_map(struct pinctrl_dev *pctldev,\n\t\t\t       struct device_node *np,\n\t\t\t       struct pinctrl_map **map,\n\t\t\t       unsigned int *num_maps)\n{\n\tstruct device_node *child;\n\tint ret;\n\n\t*map = NULL;\n\t*num_maps = 0;\n\n\tret = rzn1_dt_node_to_map_one(pctldev, np, map, num_maps);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor_each_child_of_node(np, child) {\n\t\tret = rzn1_dt_node_to_map_one(pctldev, child, map, num_maps);\n\t\tif (ret < 0) {\n\t\t\tof_node_put(child);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct pinctrl_ops rzn1_pctrl_ops = {\n\t.get_groups_count = rzn1_get_groups_count,\n\t.get_group_name = rzn1_get_group_name,\n\t.get_group_pins = rzn1_get_group_pins,\n\t.dt_node_to_map = rzn1_dt_node_to_map,\n\t.dt_free_map = pinctrl_utils_free_map,\n};\n\nstatic int rzn1_pmx_get_funcs_count(struct pinctrl_dev *pctldev)\n{\n\tstruct rzn1_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn ipctl->nfunctions;\n}\n\nstatic const char *rzn1_pmx_get_func_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t  unsigned int selector)\n{\n\tstruct rzn1_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn ipctl->functions[selector].name;\n}\n\nstatic int rzn1_pmx_get_groups(struct pinctrl_dev *pctldev,\n\t\t\t       unsigned int selector,\n\t\t\t       const char * const **groups,\n\t\t\t       unsigned int * const num_groups)\n{\n\tstruct rzn1_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\n\n\t*groups = ipctl->functions[selector].groups;\n\t*num_groups = ipctl->functions[selector].num_groups;\n\n\treturn 0;\n}\n\nstatic int rzn1_set_mux(struct pinctrl_dev *pctldev, unsigned int selector,\n\t\t\tunsigned int group)\n{\n\tstruct rzn1_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct rzn1_pin_group *grp = &ipctl->groups[group];\n\tunsigned int i, grp_pins = grp->npins;\n\n\tdev_dbg(ipctl->dev, \"set mux %s(%d) group %s(%d)\\n\",\n\t\tipctl->functions[selector].name, selector, grp->name, group);\n\n\trzn1_hw_set_lock(ipctl, LOCK_ALL, LOCK_ALL);\n\tfor (i = 0; i < grp_pins; i++)\n\t\trzn1_set_hw_pin_func(ipctl, grp->pins[i], grp->pin_ids[i], 0);\n\trzn1_hw_set_lock(ipctl, LOCK_ALL, 0);\n\n\treturn 0;\n}\n\nstatic const struct pinmux_ops rzn1_pmx_ops = {\n\t.get_functions_count = rzn1_pmx_get_funcs_count,\n\t.get_function_name = rzn1_pmx_get_func_name,\n\t.get_function_groups = rzn1_pmx_get_groups,\n\t.set_mux = rzn1_set_mux,\n};\n\nstatic int rzn1_pinconf_get(struct pinctrl_dev *pctldev, unsigned int pin,\n\t\t\t    unsigned long *config)\n{\n\tstruct rzn1_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\n\tenum pin_config_param param = pinconf_to_config_param(*config);\n\tstatic const u32 reg_drive[4] = { 4, 6, 8, 12 };\n\tu32 pull, drive, l1mux;\n\tu32 l1, l2, arg = 0;\n\n\tif (pin >= ARRAY_SIZE(ipctl->lev1->conf))\n\t\treturn -EINVAL;\n\n\tl1 = readl(&ipctl->lev1->conf[pin]);\n\n\tl1mux = l1 & RZN1_L1_FUNC_MASK;\n\tpull = (l1 >> RZN1_L1_PIN_PULL) & 0x3;\n\tdrive = (l1 >> RZN1_L1_PIN_DRIVE_STRENGTH) & 0x3;\n\n\tswitch (param) {\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\tif (pull != RZN1_L1_PIN_PULL_UP)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\tif (pull != RZN1_L1_PIN_PULL_DOWN)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\tif (pull != RZN1_L1_PIN_PULL_NONE)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase PIN_CONFIG_DRIVE_STRENGTH:\n\t\targ = reg_drive[drive];\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_HIGH_IMPEDANCE:\n\t\tl2 = readl(&ipctl->lev2->conf[pin]);\n\t\tif (l1mux == RZN1_L1_FUNCTION_L2) {\n\t\t\tif (l2 != 0)\n\t\t\t\treturn -EINVAL;\n\t\t} else if (l1mux != RZN1_FUNC_HIGHZ) {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\t*config = pinconf_to_config_packed(param, arg);\n\n\treturn 0;\n}\n\nstatic int rzn1_pinconf_set(struct pinctrl_dev *pctldev, unsigned int pin,\n\t\t\t    unsigned long *configs, unsigned int num_configs)\n{\n\tstruct rzn1_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\n\tenum pin_config_param param;\n\tunsigned int i;\n\tu32 l1, l1_cache;\n\tu32 drv;\n\tu32 arg;\n\n\tif (pin >= ARRAY_SIZE(ipctl->lev1->conf))\n\t\treturn -EINVAL;\n\n\tl1 = readl(&ipctl->lev1->conf[pin]);\n\tl1_cache = l1;\n\n\tfor (i = 0; i < num_configs; i++) {\n\t\tparam = pinconf_to_config_param(configs[i]);\n\t\targ = pinconf_to_config_argument(configs[i]);\n\n\t\tswitch (param) {\n\t\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\t\tdev_dbg(ipctl->dev, \"set pin %d pull up\\n\", pin);\n\t\t\tl1 &= ~(0x3 << RZN1_L1_PIN_PULL);\n\t\t\tl1 |= (RZN1_L1_PIN_PULL_UP << RZN1_L1_PIN_PULL);\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\t\tdev_dbg(ipctl->dev, \"set pin %d pull down\\n\", pin);\n\t\t\tl1 &= ~(0x3 << RZN1_L1_PIN_PULL);\n\t\t\tl1 |= (RZN1_L1_PIN_PULL_DOWN << RZN1_L1_PIN_PULL);\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\t\tdev_dbg(ipctl->dev, \"set pin %d bias off\\n\", pin);\n\t\t\tl1 &= ~(0x3 << RZN1_L1_PIN_PULL);\n\t\t\tl1 |= (RZN1_L1_PIN_PULL_NONE << RZN1_L1_PIN_PULL);\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_DRIVE_STRENGTH:\n\t\t\tdev_dbg(ipctl->dev, \"set pin %d drv %umA\\n\", pin, arg);\n\t\t\tswitch (arg) {\n\t\t\tcase 4:\n\t\t\t\tdrv = RZN1_L1_PIN_DRIVE_STRENGTH_4MA;\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tdrv = RZN1_L1_PIN_DRIVE_STRENGTH_6MA;\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\tdrv = RZN1_L1_PIN_DRIVE_STRENGTH_8MA;\n\t\t\t\tbreak;\n\t\t\tcase 12:\n\t\t\t\tdrv = RZN1_L1_PIN_DRIVE_STRENGTH_12MA;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdev_err(ipctl->dev,\n\t\t\t\t\t\"Drive strength %umA not supported\\n\",\n\t\t\t\t\targ);\n\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tl1 &= ~(0x3 << RZN1_L1_PIN_DRIVE_STRENGTH);\n\t\t\tl1 |= (drv << RZN1_L1_PIN_DRIVE_STRENGTH);\n\t\t\tbreak;\n\n\t\tcase PIN_CONFIG_BIAS_HIGH_IMPEDANCE:\n\t\t\tdev_dbg(ipctl->dev, \"set pin %d High-Z\\n\", pin);\n\t\t\tl1 &= ~RZN1_L1_FUNC_MASK;\n\t\t\tl1 |= RZN1_FUNC_HIGHZ;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t}\n\n\tif (l1 != l1_cache) {\n\t\trzn1_hw_set_lock(ipctl, LOCK_LEVEL1, LOCK_LEVEL1);\n\t\twritel(l1, &ipctl->lev1->conf[pin]);\n\t\trzn1_hw_set_lock(ipctl, LOCK_LEVEL1, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic int rzn1_pinconf_group_get(struct pinctrl_dev *pctldev,\n\t\t\t\t  unsigned int selector,\n\t\t\t\t  unsigned long *config)\n{\n\tstruct rzn1_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct rzn1_pin_group *grp = &ipctl->groups[selector];\n\tunsigned long old = 0;\n\tunsigned int i;\n\n\tdev_dbg(ipctl->dev, \"group get %s selector:%u\\n\", grp->name, selector);\n\n\tfor (i = 0; i < grp->npins; i++) {\n\t\tif (rzn1_pinconf_get(pctldev, grp->pins[i], config))\n\t\t\treturn -ENOTSUPP;\n\n\t\t \n\t\tif (i && (old != *config))\n\t\t\treturn -ENOTSUPP;\n\n\t\told = *config;\n\t}\n\n\treturn 0;\n}\n\nstatic int rzn1_pinconf_group_set(struct pinctrl_dev *pctldev,\n\t\t\t\t  unsigned int selector,\n\t\t\t\t  unsigned long *configs,\n\t\t\t\t  unsigned int num_configs)\n{\n\tstruct rzn1_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct rzn1_pin_group *grp = &ipctl->groups[selector];\n\tunsigned int i;\n\tint ret;\n\n\tdev_dbg(ipctl->dev, \"group set %s selector:%u configs:%p/%d\\n\",\n\t\tgrp->name, selector, configs, num_configs);\n\n\tfor (i = 0; i < grp->npins; i++) {\n\t\tunsigned int pin = grp->pins[i];\n\n\t\tret = rzn1_pinconf_set(pctldev, pin, configs, num_configs);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct pinconf_ops rzn1_pinconf_ops = {\n\t.is_generic = true,\n\t.pin_config_get = rzn1_pinconf_get,\n\t.pin_config_set = rzn1_pinconf_set,\n\t.pin_config_group_get = rzn1_pinconf_group_get,\n\t.pin_config_group_set = rzn1_pinconf_group_set,\n\t.pin_config_config_dbg_show = pinconf_generic_dump_config,\n};\n\nstatic struct pinctrl_desc rzn1_pinctrl_desc = {\n\t.pctlops = &rzn1_pctrl_ops,\n\t.pmxops = &rzn1_pmx_ops,\n\t.confops = &rzn1_pinconf_ops,\n\t.owner = THIS_MODULE,\n};\n\nstatic int rzn1_pinctrl_parse_groups(struct device_node *np,\n\t\t\t\t     struct rzn1_pin_group *grp,\n\t\t\t\t     struct rzn1_pinctrl *ipctl)\n{\n\tconst __be32 *list;\n\tunsigned int i;\n\tint size;\n\n\tdev_dbg(ipctl->dev, \"%s: %s\\n\", __func__, np->name);\n\n\t \n\tgrp->name = np->name;\n\n\t \n\tlist = of_get_property(np, RZN1_PINS_PROP, &size);\n\tif (!list) {\n\t\tdev_err(ipctl->dev,\n\t\t\t\"no \" RZN1_PINS_PROP \" property in node %pOF\\n\", np);\n\n\t\treturn -EINVAL;\n\t}\n\n\tif (!size) {\n\t\tdev_err(ipctl->dev, \"Invalid \" RZN1_PINS_PROP \" in node %pOF\\n\",\n\t\t\tnp);\n\n\t\treturn -EINVAL;\n\t}\n\n\tgrp->npins = size / sizeof(list[0]);\n\tgrp->pin_ids = devm_kmalloc_array(ipctl->dev,\n\t\t\t\t\t  grp->npins, sizeof(grp->pin_ids[0]),\n\t\t\t\t\t  GFP_KERNEL);\n\tgrp->pins = devm_kmalloc_array(ipctl->dev,\n\t\t\t\t       grp->npins, sizeof(grp->pins[0]),\n\t\t\t\t       GFP_KERNEL);\n\tif (!grp->pin_ids || !grp->pins)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < grp->npins; i++) {\n\t\tu32 pin_id = be32_to_cpu(*list++);\n\n\t\tgrp->pins[i] = pin_id & 0xff;\n\t\tgrp->pin_ids[i] = (pin_id >> 8) & 0x7f;\n\t}\n\n\treturn grp->npins;\n}\n\nstatic int rzn1_pinctrl_count_function_groups(struct device_node *np)\n{\n\tstruct device_node *child;\n\tint count = 0;\n\n\tif (of_property_count_u32_elems(np, RZN1_PINS_PROP) > 0)\n\t\tcount++;\n\n\tfor_each_child_of_node(np, child) {\n\t\tif (of_property_count_u32_elems(child, RZN1_PINS_PROP) > 0)\n\t\t\tcount++;\n\t}\n\n\treturn count;\n}\n\nstatic int rzn1_pinctrl_parse_functions(struct device_node *np,\n\t\t\t\t\tstruct rzn1_pinctrl *ipctl,\n\t\t\t\t\tunsigned int index)\n{\n\tstruct rzn1_pmx_func *func;\n\tstruct rzn1_pin_group *grp;\n\tstruct device_node *child;\n\tunsigned int i = 0;\n\tint ret;\n\n\tfunc = &ipctl->functions[index];\n\n\t \n\tfunc->name = np->name;\n\tfunc->num_groups = rzn1_pinctrl_count_function_groups(np);\n\tif (func->num_groups == 0) {\n\t\tdev_err(ipctl->dev, \"no groups defined in %pOF\\n\", np);\n\t\treturn -EINVAL;\n\t}\n\tdev_dbg(ipctl->dev, \"function %s has %d groups\\n\",\n\t\tnp->name, func->num_groups);\n\n\tfunc->groups = devm_kmalloc_array(ipctl->dev,\n\t\t\t\t\t  func->num_groups, sizeof(char *),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!func->groups)\n\t\treturn -ENOMEM;\n\n\tif (of_property_count_u32_elems(np, RZN1_PINS_PROP) > 0) {\n\t\tfunc->groups[i] = np->name;\n\t\tgrp = &ipctl->groups[ipctl->ngroups];\n\t\tgrp->func = func->name;\n\t\tret = rzn1_pinctrl_parse_groups(np, grp, ipctl);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\ti++;\n\t\tipctl->ngroups++;\n\t}\n\n\tfor_each_child_of_node(np, child) {\n\t\tfunc->groups[i] = child->name;\n\t\tgrp = &ipctl->groups[ipctl->ngroups];\n\t\tgrp->func = func->name;\n\t\tret = rzn1_pinctrl_parse_groups(child, grp, ipctl);\n\t\tif (ret < 0) {\n\t\t\tof_node_put(child);\n\t\t\treturn ret;\n\t\t}\n\t\ti++;\n\t\tipctl->ngroups++;\n\t}\n\n\tdev_dbg(ipctl->dev, \"function %s parsed %u/%u groups\\n\",\n\t\tnp->name, i, func->num_groups);\n\n\treturn 0;\n}\n\nstatic int rzn1_pinctrl_probe_dt(struct platform_device *pdev,\n\t\t\t\t struct rzn1_pinctrl *ipctl)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct device_node *child;\n\tunsigned int maxgroups = 0;\n\tunsigned int i = 0;\n\tint nfuncs = 0;\n\tint ret;\n\n\tnfuncs = of_get_child_count(np);\n\tif (nfuncs <= 0)\n\t\treturn 0;\n\n\tipctl->nfunctions = nfuncs;\n\tipctl->functions = devm_kmalloc_array(&pdev->dev, nfuncs,\n\t\t\t\t\t      sizeof(*ipctl->functions),\n\t\t\t\t\t      GFP_KERNEL);\n\tif (!ipctl->functions)\n\t\treturn -ENOMEM;\n\n\tipctl->ngroups = 0;\n\tfor_each_child_of_node(np, child)\n\t\tmaxgroups += rzn1_pinctrl_count_function_groups(child);\n\n\tipctl->groups = devm_kmalloc_array(&pdev->dev,\n\t\t\t\t\t   maxgroups,\n\t\t\t\t\t   sizeof(*ipctl->groups),\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!ipctl->groups)\n\t\treturn -ENOMEM;\n\n\tfor_each_child_of_node(np, child) {\n\t\tret = rzn1_pinctrl_parse_functions(child, ipctl, i++);\n\t\tif (ret < 0) {\n\t\t\tof_node_put(child);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int rzn1_pinctrl_probe(struct platform_device *pdev)\n{\n\tstruct rzn1_pinctrl *ipctl;\n\tstruct resource *res;\n\tint ret;\n\n\t \n\tipctl = devm_kzalloc(&pdev->dev, sizeof(*ipctl), GFP_KERNEL);\n\tif (!ipctl)\n\t\treturn -ENOMEM;\n\n\tipctl->mdio_func[0] = -1;\n\tipctl->mdio_func[1] = -1;\n\n\tipctl->lev1 = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(ipctl->lev1))\n\t\treturn PTR_ERR(ipctl->lev1);\n\tipctl->lev1_protect_phys = (u32)res->start + 0x400;\n\n\tipctl->lev2 = devm_platform_get_and_ioremap_resource(pdev, 1, &res);\n\tif (IS_ERR(ipctl->lev2))\n\t\treturn PTR_ERR(ipctl->lev2);\n\tipctl->lev2_protect_phys = (u32)res->start + 0x400;\n\n\tipctl->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(ipctl->clk))\n\t\treturn PTR_ERR(ipctl->clk);\n\tret = clk_prepare_enable(ipctl->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tipctl->dev = &pdev->dev;\n\trzn1_pinctrl_desc.name = dev_name(&pdev->dev);\n\trzn1_pinctrl_desc.pins = rzn1_pins;\n\trzn1_pinctrl_desc.npins = ARRAY_SIZE(rzn1_pins);\n\n\tret = rzn1_pinctrl_probe_dt(pdev, ipctl);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"fail to probe dt properties\\n\");\n\t\tgoto err_clk;\n\t}\n\n\tplatform_set_drvdata(pdev, ipctl);\n\n\tret = devm_pinctrl_register_and_init(&pdev->dev, &rzn1_pinctrl_desc,\n\t\t\t\t\t     ipctl, &ipctl->pctl);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"could not register rzn1 pinctrl driver\\n\");\n\t\tgoto err_clk;\n\t}\n\n\tret = pinctrl_enable(ipctl->pctl);\n\tif (ret)\n\t\tgoto err_clk;\n\n\tdev_info(&pdev->dev, \"probed\\n\");\n\n\treturn 0;\n\nerr_clk:\n\tclk_disable_unprepare(ipctl->clk);\n\n\treturn ret;\n}\n\nstatic int rzn1_pinctrl_remove(struct platform_device *pdev)\n{\n\tstruct rzn1_pinctrl *ipctl = platform_get_drvdata(pdev);\n\n\tclk_disable_unprepare(ipctl->clk);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id rzn1_pinctrl_match[] = {\n\t{ .compatible = \"renesas,rzn1-pinctrl\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, rzn1_pinctrl_match);\n\nstatic struct platform_driver rzn1_pinctrl_driver = {\n\t.probe\t= rzn1_pinctrl_probe,\n\t.remove = rzn1_pinctrl_remove,\n\t.driver\t= {\n\t\t.name\t\t= \"rzn1-pinctrl\",\n\t\t.of_match_table\t= rzn1_pinctrl_match,\n\t},\n};\n\nstatic int __init _pinctrl_drv_register(void)\n{\n\treturn platform_driver_register(&rzn1_pinctrl_driver);\n}\nsubsys_initcall(_pinctrl_drv_register);\n\nMODULE_AUTHOR(\"Phil Edworthy <phil.edworthy@renesas.com>\");\nMODULE_DESCRIPTION(\"Renesas RZ/N1 pinctrl driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}