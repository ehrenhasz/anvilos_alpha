{
  "module_name": "pinctrl-rzv2m.c",
  "hash_id": "4a46c08843f9ec42760372955dc8030c2f8080d000753b1197f13476fc0ae8b9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/renesas/pinctrl-rzv2m.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/gpio/driver.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/spinlock.h>\n\n#include <linux/pinctrl/consumer.h>\n#include <linux/pinctrl/pinconf-generic.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinmux.h>\n\n#include <dt-bindings/pinctrl/rzv2m-pinctrl.h>\n\n#include \"../core.h\"\n#include \"../pinconf.h\"\n#include \"../pinmux.h\"\n\n#define DRV_NAME\t\"pinctrl-rzv2m\"\n\n \n#define MUX_PIN_ID_MASK\t\tGENMASK(15, 0)\n#define MUX_FUNC_MASK\t\tGENMASK(31, 16)\n#define MUX_FUNC(pinconf)\tFIELD_GET(MUX_FUNC_MASK, (pinconf))\n\n \n#define PIN_CFG_GRP_1_8V_2\t\t1\n#define PIN_CFG_GRP_1_8V_3\t\t2\n#define PIN_CFG_GRP_SWIO_1\t\t3\n#define PIN_CFG_GRP_SWIO_2\t\t4\n#define PIN_CFG_GRP_3_3V\t\t5\n#define PIN_CFG_GRP_MASK\t\tGENMASK(2, 0)\n#define PIN_CFG_BIAS\t\t\tBIT(3)\n#define PIN_CFG_DRV\t\t\tBIT(4)\n#define PIN_CFG_SLEW\t\t\tBIT(5)\n\n#define RZV2M_MPXED_PIN_FUNCS\t\t(PIN_CFG_BIAS | \\\n\t\t\t\t\t PIN_CFG_DRV | \\\n\t\t\t\t\t PIN_CFG_SLEW)\n\n \n#define RZV2M_GPIO_PORT_PACK(n, a, f)\t(((n) << 24) | ((a) << 16) | (f))\n#define RZV2M_GPIO_PORT_GET_PINCNT(x)\tFIELD_GET(GENMASK(31, 24), (x))\n#define RZV2M_GPIO_PORT_GET_INDEX(x)\tFIELD_GET(GENMASK(23, 16), (x))\n#define RZV2M_GPIO_PORT_GET_CFGS(x)\tFIELD_GET(GENMASK(15, 0), (x))\n\n#define RZV2M_DEDICATED_PORT_IDX\t22\n\n \n#define RZV2M_SINGLE_PIN\t\tBIT(31)\n#define RZV2M_SINGLE_PIN_PACK(b, f)\t(RZV2M_SINGLE_PIN | \\\n\t\t\t\t\t ((RZV2M_DEDICATED_PORT_IDX) << 24) | \\\n\t\t\t\t\t ((b) << 16) | (f))\n#define RZV2M_SINGLE_PIN_GET_PORT(x)\tFIELD_GET(GENMASK(30, 24), (x))\n#define RZV2M_SINGLE_PIN_GET_BIT(x)\tFIELD_GET(GENMASK(23, 16), (x))\n#define RZV2M_SINGLE_PIN_GET_CFGS(x)\tFIELD_GET(GENMASK(15, 0), (x))\n\n#define RZV2M_PIN_ID_TO_PORT(id)\t((id) / RZV2M_PINS_PER_PORT)\n#define RZV2M_PIN_ID_TO_PIN(id)\t\t((id) % RZV2M_PINS_PER_PORT)\n\n#define DO(n)\t\t(0x00 + (n) * 0x40)\n#define OE(n)\t\t(0x04 + (n) * 0x40)\n#define IE(n)\t\t(0x08 + (n) * 0x40)\n#define PFSEL(n)\t(0x10 + (n) * 0x40)\n#define DI(n)\t\t(0x20 + (n) * 0x40)\n#define PUPD(n)\t\t(0x24 + (n) * 0x40)\n#define DRV(n)\t\t((n) < RZV2M_DEDICATED_PORT_IDX ? (0x28 + (n) * 0x40) \\\n\t\t\t\t\t\t\t: 0x590)\n#define SR(n)\t\t((n) < RZV2M_DEDICATED_PORT_IDX ? (0x2c + (n) * 0x40) \\\n\t\t\t\t\t\t\t: 0x594)\n#define DI_MSK(n)\t(0x30 + (n) * 0x40)\n#define EN_MSK(n)\t(0x34 + (n) * 0x40)\n\n#define PFC_MASK\t0x07\n#define PUPD_MASK\t0x03\n#define DRV_MASK\t0x03\n\nstruct rzv2m_dedicated_configs {\n\tconst char *name;\n\tu32 config;\n};\n\nstruct rzv2m_pinctrl_data {\n\tconst char * const *port_pins;\n\tconst u32 *port_pin_configs;\n\tconst struct rzv2m_dedicated_configs *dedicated_pins;\n\tunsigned int n_port_pins;\n\tunsigned int n_dedicated_pins;\n};\n\nstruct rzv2m_pinctrl {\n\tstruct pinctrl_dev\t\t*pctl;\n\tstruct pinctrl_desc\t\tdesc;\n\tstruct pinctrl_pin_desc\t\t*pins;\n\n\tconst struct rzv2m_pinctrl_data\t*data;\n\tvoid __iomem\t\t\t*base;\n\tstruct device\t\t\t*dev;\n\n\tstruct gpio_chip\t\tgpio_chip;\n\tstruct pinctrl_gpio_range\tgpio_range;\n\n\tspinlock_t\t\t\tlock;  \n\tstruct mutex\t\t\tmutex;  \n};\n\nstatic const unsigned int drv_1_8V_group2_uA[] = { 1800, 3800, 7800, 11000 };\nstatic const unsigned int drv_1_8V_group3_uA[] = { 1600, 3200, 6400, 9600 };\nstatic const unsigned int drv_SWIO_group2_3_3V_uA[] = { 9000, 11000, 13000, 18000 };\nstatic const unsigned int drv_3_3V_group_uA[] = { 2000, 4000, 8000, 12000 };\n\n \nstatic void rzv2m_writel_we(void __iomem *addr, u8 shift, u8 value)\n{\n\twritel((BIT(16) | value) << shift, addr);\n}\n\nstatic void rzv2m_pinctrl_set_pfc_mode(struct rzv2m_pinctrl *pctrl,\n\t\t\t\t       u8 port, u8 pin, u8 func)\n{\n\tvoid __iomem *addr;\n\n\t \n\trzv2m_writel_we(pctrl->base + DI_MSK(port), pin, 1);\n\trzv2m_writel_we(pctrl->base + EN_MSK(port), pin, 1);\n\n\t \n\taddr = pctrl->base + PFSEL(port) + (pin / 4) * 4;\n\twritel(((PFC_MASK << 16) | func) << ((pin % 4) * 4), addr);\n\n\t \n\trzv2m_writel_we(pctrl->base + EN_MSK(port), pin, 0);\n\trzv2m_writel_we(pctrl->base + DI_MSK(port), pin, 0);\n};\n\nstatic int rzv2m_pinctrl_set_mux(struct pinctrl_dev *pctldev,\n\t\t\t\t unsigned int func_selector,\n\t\t\t\t unsigned int group_selector)\n{\n\tstruct rzv2m_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct function_desc *func;\n\tunsigned int i, *psel_val;\n\tstruct group_desc *group;\n\tint *pins;\n\n\tfunc = pinmux_generic_get_function(pctldev, func_selector);\n\tif (!func)\n\t\treturn -EINVAL;\n\tgroup = pinctrl_generic_get_group(pctldev, group_selector);\n\tif (!group)\n\t\treturn -EINVAL;\n\n\tpsel_val = func->data;\n\tpins = group->pins;\n\n\tfor (i = 0; i < group->num_pins; i++) {\n\t\tdev_dbg(pctrl->dev, \"port:%u pin: %u PSEL:%u\\n\",\n\t\t\tRZV2M_PIN_ID_TO_PORT(pins[i]), RZV2M_PIN_ID_TO_PIN(pins[i]),\n\t\t\tpsel_val[i]);\n\t\trzv2m_pinctrl_set_pfc_mode(pctrl, RZV2M_PIN_ID_TO_PORT(pins[i]),\n\t\t\t\t\t   RZV2M_PIN_ID_TO_PIN(pins[i]), psel_val[i]);\n\t}\n\n\treturn 0;\n};\n\nstatic int rzv2m_map_add_config(struct pinctrl_map *map,\n\t\t\t\tconst char *group_or_pin,\n\t\t\t\tenum pinctrl_map_type type,\n\t\t\t\tunsigned long *configs,\n\t\t\t\tunsigned int num_configs)\n{\n\tunsigned long *cfgs;\n\n\tcfgs = kmemdup(configs, num_configs * sizeof(*cfgs),\n\t\t       GFP_KERNEL);\n\tif (!cfgs)\n\t\treturn -ENOMEM;\n\n\tmap->type = type;\n\tmap->data.configs.group_or_pin = group_or_pin;\n\tmap->data.configs.configs = cfgs;\n\tmap->data.configs.num_configs = num_configs;\n\n\treturn 0;\n}\n\nstatic int rzv2m_dt_subnode_to_map(struct pinctrl_dev *pctldev,\n\t\t\t\t   struct device_node *np,\n\t\t\t\t   struct device_node *parent,\n\t\t\t\t   struct pinctrl_map **map,\n\t\t\t\t   unsigned int *num_maps,\n\t\t\t\t   unsigned int *index)\n{\n\tstruct rzv2m_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct pinctrl_map *maps = *map;\n\tunsigned int nmaps = *num_maps;\n\tunsigned long *configs = NULL;\n\tunsigned int *pins, *psel_val;\n\tunsigned int num_pinmux = 0;\n\tunsigned int idx = *index;\n\tunsigned int num_pins, i;\n\tunsigned int num_configs;\n\tstruct property *pinmux;\n\tstruct property *prop;\n\tint ret, gsel, fsel;\n\tconst char **pin_fn;\n\tconst char *name;\n\tconst char *pin;\n\n\tpinmux = of_find_property(np, \"pinmux\", NULL);\n\tif (pinmux)\n\t\tnum_pinmux = pinmux->length / sizeof(u32);\n\n\tret = of_property_count_strings(np, \"pins\");\n\tif (ret == -EINVAL) {\n\t\tnum_pins = 0;\n\t} else if (ret < 0) {\n\t\tdev_err(pctrl->dev, \"Invalid pins list in DT\\n\");\n\t\treturn ret;\n\t} else {\n\t\tnum_pins = ret;\n\t}\n\n\tif (!num_pinmux && !num_pins)\n\t\treturn 0;\n\n\tif (num_pinmux && num_pins) {\n\t\tdev_err(pctrl->dev,\n\t\t\t\"DT node must contain either a pinmux or pins and not both\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = pinconf_generic_parse_dt_config(np, NULL, &configs, &num_configs);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (num_pins && !num_configs) {\n\t\tdev_err(pctrl->dev, \"DT node must contain a config\\n\");\n\t\tret = -ENODEV;\n\t\tgoto done;\n\t}\n\n\tif (num_pinmux)\n\t\tnmaps += 1;\n\n\tif (num_pins)\n\t\tnmaps += num_pins;\n\n\tmaps = krealloc_array(maps, nmaps, sizeof(*maps), GFP_KERNEL);\n\tif (!maps) {\n\t\tret = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\t*map = maps;\n\t*num_maps = nmaps;\n\tif (num_pins) {\n\t\tof_property_for_each_string(np, \"pins\", prop, pin) {\n\t\t\tret = rzv2m_map_add_config(&maps[idx], pin,\n\t\t\t\t\t\t   PIN_MAP_TYPE_CONFIGS_PIN,\n\t\t\t\t\t\t   configs, num_configs);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto done;\n\n\t\t\tidx++;\n\t\t}\n\t\tret = 0;\n\t\tgoto done;\n\t}\n\n\tpins = devm_kcalloc(pctrl->dev, num_pinmux, sizeof(*pins), GFP_KERNEL);\n\tpsel_val = devm_kcalloc(pctrl->dev, num_pinmux, sizeof(*psel_val),\n\t\t\t\tGFP_KERNEL);\n\tpin_fn = devm_kzalloc(pctrl->dev, sizeof(*pin_fn), GFP_KERNEL);\n\tif (!pins || !psel_val || !pin_fn) {\n\t\tret = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\t \n\tfor (i = 0; i < num_pinmux; ++i) {\n\t\tu32 value;\n\n\t\tret = of_property_read_u32_index(np, \"pinmux\", i, &value);\n\t\tif (ret)\n\t\t\tgoto done;\n\t\tpins[i] = value & MUX_PIN_ID_MASK;\n\t\tpsel_val[i] = MUX_FUNC(value);\n\t}\n\n\tif (parent) {\n\t\tname = devm_kasprintf(pctrl->dev, GFP_KERNEL, \"%pOFn.%pOFn\",\n\t\t\t\t      parent, np);\n\t\tif (!name) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto done;\n\t\t}\n\t} else {\n\t\tname = np->name;\n\t}\n\n\tmutex_lock(&pctrl->mutex);\n\n\t \n\tgsel = pinctrl_generic_add_group(pctldev, name, pins, num_pinmux, NULL);\n\tif (gsel < 0) {\n\t\tret = gsel;\n\t\tgoto unlock;\n\t}\n\n\t \n\tpin_fn[0] = name;\n\tfsel = pinmux_generic_add_function(pctldev, name, pin_fn, 1, psel_val);\n\tif (fsel < 0) {\n\t\tret = fsel;\n\t\tgoto remove_group;\n\t}\n\n\tmutex_unlock(&pctrl->mutex);\n\n\tmaps[idx].type = PIN_MAP_TYPE_MUX_GROUP;\n\tmaps[idx].data.mux.group = name;\n\tmaps[idx].data.mux.function = name;\n\tidx++;\n\n\tdev_dbg(pctrl->dev, \"Parsed %pOF with %d pins\\n\", np, num_pinmux);\n\tret = 0;\n\tgoto done;\n\nremove_group:\n\tpinctrl_generic_remove_group(pctldev, gsel);\nunlock:\n\tmutex_unlock(&pctrl->mutex);\ndone:\n\t*index = idx;\n\tkfree(configs);\n\treturn ret;\n}\n\nstatic void rzv2m_dt_free_map(struct pinctrl_dev *pctldev,\n\t\t\t      struct pinctrl_map *map,\n\t\t\t      unsigned int num_maps)\n{\n\tunsigned int i;\n\n\tif (!map)\n\t\treturn;\n\n\tfor (i = 0; i < num_maps; ++i) {\n\t\tif (map[i].type == PIN_MAP_TYPE_CONFIGS_GROUP ||\n\t\t    map[i].type == PIN_MAP_TYPE_CONFIGS_PIN)\n\t\t\tkfree(map[i].data.configs.configs);\n\t}\n\tkfree(map);\n}\n\nstatic int rzv2m_dt_node_to_map(struct pinctrl_dev *pctldev,\n\t\t\t\tstruct device_node *np,\n\t\t\t\tstruct pinctrl_map **map,\n\t\t\t\tunsigned int *num_maps)\n{\n\tstruct rzv2m_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct device_node *child;\n\tunsigned int index;\n\tint ret;\n\n\t*map = NULL;\n\t*num_maps = 0;\n\tindex = 0;\n\n\tfor_each_child_of_node(np, child) {\n\t\tret = rzv2m_dt_subnode_to_map(pctldev, child, np, map,\n\t\t\t\t\t      num_maps, &index);\n\t\tif (ret < 0) {\n\t\t\tof_node_put(child);\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif (*num_maps == 0) {\n\t\tret = rzv2m_dt_subnode_to_map(pctldev, np, NULL, map,\n\t\t\t\t\t      num_maps, &index);\n\t\tif (ret < 0)\n\t\t\tgoto done;\n\t}\n\n\tif (*num_maps)\n\t\treturn 0;\n\n\tdev_err(pctrl->dev, \"no mapping found in node %pOF\\n\", np);\n\tret = -EINVAL;\n\ndone:\n\trzv2m_dt_free_map(pctldev, *map, *num_maps);\n\n\treturn ret;\n}\n\nstatic int rzv2m_validate_gpio_pin(struct rzv2m_pinctrl *pctrl,\n\t\t\t\t   u32 cfg, u32 port, u8 bit)\n{\n\tu8 pincount = RZV2M_GPIO_PORT_GET_PINCNT(cfg);\n\tu32 port_index = RZV2M_GPIO_PORT_GET_INDEX(cfg);\n\tu32 data;\n\n\tif (bit >= pincount || port >= pctrl->data->n_port_pins)\n\t\treturn -EINVAL;\n\n\tdata = pctrl->data->port_pin_configs[port];\n\tif (port_index != RZV2M_GPIO_PORT_GET_INDEX(data))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void rzv2m_rmw_pin_config(struct rzv2m_pinctrl *pctrl, u32 offset,\n\t\t\t\t u8 shift, u32 mask, u32 val)\n{\n\tvoid __iomem *addr = pctrl->base + offset;\n\tunsigned long flags;\n\tu32 reg;\n\n\tspin_lock_irqsave(&pctrl->lock, flags);\n\treg = readl(addr) & ~(mask << shift);\n\twritel(reg | (val << shift), addr);\n\tspin_unlock_irqrestore(&pctrl->lock, flags);\n}\n\nstatic int rzv2m_pinctrl_pinconf_get(struct pinctrl_dev *pctldev,\n\t\t\t\t     unsigned int _pin,\n\t\t\t\t     unsigned long *config)\n{\n\tstruct rzv2m_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\tenum pin_config_param param = pinconf_to_config_param(*config);\n\tconst struct pinctrl_pin_desc *pin = &pctrl->desc.pins[_pin];\n\tunsigned int *pin_data = pin->drv_data;\n\tunsigned int arg = 0;\n\tu32 port;\n\tu32 cfg;\n\tu8 bit;\n\tu32 val;\n\n\tif (!pin_data)\n\t\treturn -EINVAL;\n\n\tif (*pin_data & RZV2M_SINGLE_PIN) {\n\t\tport = RZV2M_SINGLE_PIN_GET_PORT(*pin_data);\n\t\tcfg = RZV2M_SINGLE_PIN_GET_CFGS(*pin_data);\n\t\tbit = RZV2M_SINGLE_PIN_GET_BIT(*pin_data);\n\t} else {\n\t\tcfg = RZV2M_GPIO_PORT_GET_CFGS(*pin_data);\n\t\tport = RZV2M_PIN_ID_TO_PORT(_pin);\n\t\tbit = RZV2M_PIN_ID_TO_PIN(_pin);\n\n\t\tif (rzv2m_validate_gpio_pin(pctrl, *pin_data, RZV2M_PIN_ID_TO_PORT(_pin), bit))\n\t\t\treturn -EINVAL;\n\t}\n\n\tswitch (param) {\n\tcase PIN_CONFIG_BIAS_DISABLE:\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\tcase PIN_CONFIG_BIAS_PULL_DOWN: {\n\t\tenum pin_config_param bias;\n\n\t\tif (!(cfg & PIN_CFG_BIAS))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tbit *= 2;\n\n\t\tswitch ((readl(pctrl->base + PUPD(port)) >> bit) & PUPD_MASK) {\n\t\tcase 0:\n\t\t\tbias = PIN_CONFIG_BIAS_PULL_DOWN;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tbias = PIN_CONFIG_BIAS_PULL_UP;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbias = PIN_CONFIG_BIAS_DISABLE;\n\t\t}\n\n\t\tif (bias != param)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\n\tcase PIN_CONFIG_DRIVE_STRENGTH_UA:\n\t\tif (!(cfg & PIN_CFG_DRV))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tbit *= 2;\n\n\t\tval = (readl(pctrl->base + DRV(port)) >> bit) & DRV_MASK;\n\n\t\tswitch (cfg & PIN_CFG_GRP_MASK) {\n\t\tcase PIN_CFG_GRP_1_8V_2:\n\t\t\targ = drv_1_8V_group2_uA[val];\n\t\t\tbreak;\n\t\tcase PIN_CFG_GRP_1_8V_3:\n\t\t\targ = drv_1_8V_group3_uA[val];\n\t\t\tbreak;\n\t\tcase PIN_CFG_GRP_SWIO_2:\n\t\t\targ = drv_SWIO_group2_3_3V_uA[val];\n\t\t\tbreak;\n\t\tcase PIN_CFG_GRP_SWIO_1:\n\t\tcase PIN_CFG_GRP_3_3V:\n\t\t\targ = drv_3_3V_group_uA[val];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tbreak;\n\n\tcase PIN_CONFIG_SLEW_RATE:\n\t\tif (!(cfg & PIN_CFG_SLEW))\n\t\t\treturn -EINVAL;\n\n\t\targ = readl(pctrl->base + SR(port)) & BIT(bit);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\t*config = pinconf_to_config_packed(param, arg);\n\n\treturn 0;\n};\n\nstatic int rzv2m_pinctrl_pinconf_set(struct pinctrl_dev *pctldev,\n\t\t\t\t     unsigned int _pin,\n\t\t\t\t     unsigned long *_configs,\n\t\t\t\t     unsigned int num_configs)\n{\n\tstruct rzv2m_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct pinctrl_pin_desc *pin = &pctrl->desc.pins[_pin];\n\tunsigned int *pin_data = pin->drv_data;\n\tenum pin_config_param param;\n\tu32 port;\n\tunsigned int i;\n\tu32 cfg;\n\tu8 bit;\n\tu32 val;\n\n\tif (!pin_data)\n\t\treturn -EINVAL;\n\n\tif (*pin_data & RZV2M_SINGLE_PIN) {\n\t\tport = RZV2M_SINGLE_PIN_GET_PORT(*pin_data);\n\t\tcfg = RZV2M_SINGLE_PIN_GET_CFGS(*pin_data);\n\t\tbit = RZV2M_SINGLE_PIN_GET_BIT(*pin_data);\n\t} else {\n\t\tcfg = RZV2M_GPIO_PORT_GET_CFGS(*pin_data);\n\t\tport = RZV2M_PIN_ID_TO_PORT(_pin);\n\t\tbit = RZV2M_PIN_ID_TO_PIN(_pin);\n\n\t\tif (rzv2m_validate_gpio_pin(pctrl, *pin_data, RZV2M_PIN_ID_TO_PORT(_pin), bit))\n\t\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < num_configs; i++) {\n\t\tparam = pinconf_to_config_param(_configs[i]);\n\t\tswitch (param) {\n\t\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\t\tif (!(cfg & PIN_CFG_BIAS))\n\t\t\t\treturn -EINVAL;\n\n\t\t\t \n\t\t\tbit *= 2;\n\n\t\t\tswitch (param) {\n\t\t\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\t\t\tval = 0;\n\t\t\t\tbreak;\n\t\t\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\t\t\tval = 2;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tval = 1;\n\t\t\t}\n\n\t\t\trzv2m_rmw_pin_config(pctrl, PUPD(port), bit, PUPD_MASK, val);\n\t\t\tbreak;\n\n\t\tcase PIN_CONFIG_DRIVE_STRENGTH_UA: {\n\t\t\tunsigned int arg = pinconf_to_config_argument(_configs[i]);\n\t\t\tconst unsigned int *drv_strengths;\n\t\t\tunsigned int index;\n\n\t\t\tif (!(cfg & PIN_CFG_DRV))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tswitch (cfg & PIN_CFG_GRP_MASK) {\n\t\t\tcase PIN_CFG_GRP_1_8V_2:\n\t\t\t\tdrv_strengths = drv_1_8V_group2_uA;\n\t\t\t\tbreak;\n\t\t\tcase PIN_CFG_GRP_1_8V_3:\n\t\t\t\tdrv_strengths = drv_1_8V_group3_uA;\n\t\t\t\tbreak;\n\t\t\tcase PIN_CFG_GRP_SWIO_2:\n\t\t\t\tdrv_strengths = drv_SWIO_group2_3_3V_uA;\n\t\t\t\tbreak;\n\t\t\tcase PIN_CFG_GRP_SWIO_1:\n\t\t\tcase PIN_CFG_GRP_3_3V:\n\t\t\t\tdrv_strengths = drv_3_3V_group_uA;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tfor (index = 0; index < 4; index++) {\n\t\t\t\tif (arg == drv_strengths[index])\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (index >= 4)\n\t\t\t\treturn -EINVAL;\n\n\t\t\t \n\t\t\tbit *= 2;\n\n\t\t\trzv2m_rmw_pin_config(pctrl, DRV(port), bit, DRV_MASK, index);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase PIN_CONFIG_SLEW_RATE: {\n\t\t\tunsigned int arg = pinconf_to_config_argument(_configs[i]);\n\n\t\t\tif (!(cfg & PIN_CFG_SLEW))\n\t\t\t\treturn -EINVAL;\n\n\t\t\trzv2m_writel_we(pctrl->base + SR(port), bit, !arg);\n\t\t\tbreak;\n\t\t}\n\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int rzv2m_pinctrl_pinconf_group_set(struct pinctrl_dev *pctldev,\n\t\t\t\t\t   unsigned int group,\n\t\t\t\t\t   unsigned long *configs,\n\t\t\t\t\t   unsigned int num_configs)\n{\n\tconst unsigned int *pins;\n\tunsigned int i, npins;\n\tint ret;\n\n\tret = pinctrl_generic_get_group_pins(pctldev, group, &pins, &npins);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < npins; i++) {\n\t\tret = rzv2m_pinctrl_pinconf_set(pctldev, pins[i], configs,\n\t\t\t\t\t\tnum_configs);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n};\n\nstatic int rzv2m_pinctrl_pinconf_group_get(struct pinctrl_dev *pctldev,\n\t\t\t\t\t   unsigned int group,\n\t\t\t\t\t   unsigned long *config)\n{\n\tconst unsigned int *pins;\n\tunsigned int i, npins, prev_config = 0;\n\tint ret;\n\n\tret = pinctrl_generic_get_group_pins(pctldev, group, &pins, &npins);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < npins; i++) {\n\t\tret = rzv2m_pinctrl_pinconf_get(pctldev, pins[i], config);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tif (i && prev_config != *config)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tprev_config = *config;\n\t}\n\n\treturn 0;\n};\n\nstatic const struct pinctrl_ops rzv2m_pinctrl_pctlops = {\n\t.get_groups_count = pinctrl_generic_get_group_count,\n\t.get_group_name = pinctrl_generic_get_group_name,\n\t.get_group_pins = pinctrl_generic_get_group_pins,\n\t.dt_node_to_map = rzv2m_dt_node_to_map,\n\t.dt_free_map = rzv2m_dt_free_map,\n};\n\nstatic const struct pinmux_ops rzv2m_pinctrl_pmxops = {\n\t.get_functions_count = pinmux_generic_get_function_count,\n\t.get_function_name = pinmux_generic_get_function_name,\n\t.get_function_groups = pinmux_generic_get_function_groups,\n\t.set_mux = rzv2m_pinctrl_set_mux,\n\t.strict = true,\n};\n\nstatic const struct pinconf_ops rzv2m_pinctrl_confops = {\n\t.is_generic = true,\n\t.pin_config_get = rzv2m_pinctrl_pinconf_get,\n\t.pin_config_set = rzv2m_pinctrl_pinconf_set,\n\t.pin_config_group_set = rzv2m_pinctrl_pinconf_group_set,\n\t.pin_config_group_get = rzv2m_pinctrl_pinconf_group_get,\n\t.pin_config_config_dbg_show = pinconf_generic_dump_config,\n};\n\nstatic int rzv2m_gpio_request(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct rzv2m_pinctrl *pctrl = gpiochip_get_data(chip);\n\tu32 port = RZV2M_PIN_ID_TO_PORT(offset);\n\tu8 bit = RZV2M_PIN_ID_TO_PIN(offset);\n\tint ret;\n\n\tret = pinctrl_gpio_request(chip->base + offset);\n\tif (ret)\n\t\treturn ret;\n\n\trzv2m_pinctrl_set_pfc_mode(pctrl, port, bit, 0);\n\n\treturn 0;\n}\n\nstatic void rzv2m_gpio_set_direction(struct rzv2m_pinctrl *pctrl, u32 port,\n\t\t\t\t     u8 bit, bool output)\n{\n\trzv2m_writel_we(pctrl->base + OE(port), bit, output);\n\trzv2m_writel_we(pctrl->base + IE(port), bit, !output);\n}\n\nstatic int rzv2m_gpio_get_direction(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct rzv2m_pinctrl *pctrl = gpiochip_get_data(chip);\n\tu32 port = RZV2M_PIN_ID_TO_PORT(offset);\n\tu8 bit = RZV2M_PIN_ID_TO_PIN(offset);\n\n\tif (!(readl(pctrl->base + IE(port)) & BIT(bit)))\n\t\treturn GPIO_LINE_DIRECTION_OUT;\n\n\treturn GPIO_LINE_DIRECTION_IN;\n}\n\nstatic int rzv2m_gpio_direction_input(struct gpio_chip *chip,\n\t\t\t\t      unsigned int offset)\n{\n\tstruct rzv2m_pinctrl *pctrl = gpiochip_get_data(chip);\n\tu32 port = RZV2M_PIN_ID_TO_PORT(offset);\n\tu8 bit = RZV2M_PIN_ID_TO_PIN(offset);\n\n\trzv2m_gpio_set_direction(pctrl, port, bit, false);\n\n\treturn 0;\n}\n\nstatic void rzv2m_gpio_set(struct gpio_chip *chip, unsigned int offset,\n\t\t\t   int value)\n{\n\tstruct rzv2m_pinctrl *pctrl = gpiochip_get_data(chip);\n\tu32 port = RZV2M_PIN_ID_TO_PORT(offset);\n\tu8 bit = RZV2M_PIN_ID_TO_PIN(offset);\n\n\trzv2m_writel_we(pctrl->base + DO(port), bit, !!value);\n}\n\nstatic int rzv2m_gpio_direction_output(struct gpio_chip *chip,\n\t\t\t\t       unsigned int offset, int value)\n{\n\tstruct rzv2m_pinctrl *pctrl = gpiochip_get_data(chip);\n\tu32 port = RZV2M_PIN_ID_TO_PORT(offset);\n\tu8 bit = RZV2M_PIN_ID_TO_PIN(offset);\n\n\trzv2m_gpio_set(chip, offset, value);\n\trzv2m_gpio_set_direction(pctrl, port, bit, true);\n\n\treturn 0;\n}\n\nstatic int rzv2m_gpio_get(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct rzv2m_pinctrl *pctrl = gpiochip_get_data(chip);\n\tu32 port = RZV2M_PIN_ID_TO_PORT(offset);\n\tu8 bit = RZV2M_PIN_ID_TO_PIN(offset);\n\tint direction = rzv2m_gpio_get_direction(chip, offset);\n\n\tif (direction == GPIO_LINE_DIRECTION_IN)\n\t\treturn !!(readl(pctrl->base + DI(port)) & BIT(bit));\n\telse\n\t\treturn !!(readl(pctrl->base + DO(port)) & BIT(bit));\n}\n\nstatic void rzv2m_gpio_free(struct gpio_chip *chip, unsigned int offset)\n{\n\tpinctrl_gpio_free(chip->base + offset);\n\n\t \n\trzv2m_gpio_direction_input(chip, offset);\n}\n\nstatic const char * const rzv2m_gpio_names[] = {\n\t\"P0_0\", \"P0_1\", \"P0_2\", \"P0_3\", \"P0_4\", \"P0_5\", \"P0_6\", \"P0_7\",\n\t\"P0_8\", \"P0_9\", \"P0_10\", \"P0_11\", \"P0_12\", \"P0_13\", \"P0_14\", \"P0_15\",\n\t\"P1_0\", \"P1_1\", \"P1_2\", \"P1_3\", \"P1_4\", \"P1_5\", \"P1_6\", \"P1_7\",\n\t\"P1_8\", \"P1_9\", \"P1_10\", \"P1_11\", \"P1_12\", \"P1_13\", \"P1_14\", \"P1_15\",\n\t\"P2_0\", \"P2_1\", \"P2_2\", \"P2_3\", \"P2_4\", \"P2_5\", \"P2_6\", \"P2_7\",\n\t\"P2_8\", \"P2_9\", \"P2_10\", \"P2_11\", \"P2_12\", \"P2_13\", \"P2_14\", \"P2_15\",\n\t\"P3_0\", \"P3_1\", \"P3_2\", \"P3_3\", \"P3_4\", \"P3_5\", \"P3_6\", \"P3_7\",\n\t\"P3_8\", \"P3_9\", \"P3_10\", \"P3_11\", \"P3_12\", \"P3_13\", \"P3_14\", \"P3_15\",\n\t\"P4_0\", \"P4_1\", \"P4_2\", \"P4_3\", \"P4_4\", \"P4_5\", \"P4_6\", \"P4_7\",\n\t\"P4_8\", \"P4_9\", \"P4_10\", \"P4_11\", \"P4_12\", \"P4_13\", \"P4_14\", \"P4_15\",\n\t\"P5_0\", \"P5_1\", \"P5_2\", \"P5_3\", \"P5_4\", \"P5_5\", \"P5_6\", \"P5_7\",\n\t\"P5_8\", \"P5_9\", \"P5_10\", \"P5_11\", \"P5_12\", \"P5_13\", \"P5_14\", \"P5_15\",\n\t\"P6_0\", \"P6_1\", \"P6_2\", \"P6_3\", \"P6_4\", \"P6_5\", \"P6_6\", \"P6_7\",\n\t\"P6_8\", \"P6_9\", \"P6_10\", \"P6_11\", \"P6_12\", \"P6_13\", \"P6_14\", \"P6_15\",\n\t\"P7_0\", \"P7_1\", \"P7_2\", \"P7_3\", \"P7_4\", \"P7_5\", \"P7_6\", \"P7_7\",\n\t\"P7_8\", \"P7_9\", \"P7_10\", \"P7_11\", \"P7_12\", \"P7_13\", \"P7_14\", \"P7_15\",\n\t\"P8_0\", \"P8_1\", \"P8_2\", \"P8_3\", \"P8_4\", \"P8_5\", \"P8_6\", \"P8_7\",\n\t\"P8_8\", \"P8_9\", \"P8_10\", \"P8_11\", \"P8_12\", \"P8_13\", \"P8_14\", \"P8_15\",\n\t\"P9_0\", \"P9_1\", \"P9_2\", \"P9_3\", \"P9_4\", \"P9_5\", \"P9_6\", \"P9_7\",\n\t\"P9_8\", \"P9_9\", \"P9_10\", \"P9_11\", \"P9_12\", \"P9_13\", \"P9_14\", \"P9_15\",\n\t\"P10_0\", \"P10_1\", \"P10_2\", \"P10_3\", \"P10_4\", \"P10_5\", \"P10_6\", \"P10_7\",\n\t\"P10_8\", \"P10_9\", \"P10_10\", \"P10_11\", \"P10_12\", \"P10_13\", \"P10_14\", \"P10_15\",\n\t\"P11_0\", \"P11_1\", \"P11_2\", \"P11_3\", \"P11_4\", \"P11_5\", \"P11_6\", \"P11_7\",\n\t\"P11_8\", \"P11_9\", \"P11_10\", \"P11_11\", \"P11_12\", \"P11_13\", \"P11_14\", \"P11_15\",\n\t\"P12_0\", \"P12_1\", \"P12_2\", \"P12_3\", \"P12_4\", \"P12_5\", \"P12_6\", \"P12_7\",\n\t\"P12_8\", \"P12_9\", \"P12_10\", \"P12_11\", \"P12_12\", \"P12_13\", \"P12_14\", \"P12_15\",\n\t\"P13_0\", \"P13_1\", \"P13_2\", \"P13_3\", \"P13_4\", \"P13_5\", \"P13_6\", \"P13_7\",\n\t\"P13_8\", \"P13_9\", \"P13_10\", \"P13_11\", \"P13_12\", \"P13_13\", \"P13_14\", \"P13_15\",\n\t\"P14_0\", \"P14_1\", \"P14_2\", \"P14_3\", \"P14_4\", \"P14_5\", \"P14_6\", \"P14_7\",\n\t\"P14_8\", \"P14_9\", \"P14_10\", \"P14_11\", \"P14_12\", \"P14_13\", \"P14_14\", \"P14_15\",\n\t\"P15_0\", \"P15_1\", \"P15_2\", \"P15_3\", \"P15_4\", \"P15_5\", \"P15_6\", \"P15_7\",\n\t\"P15_8\", \"P15_9\", \"P15_10\", \"P15_11\", \"P15_12\", \"P15_13\", \"P15_14\", \"P15_15\",\n\t\"P16_0\", \"P16_1\", \"P16_2\", \"P16_3\", \"P16_4\", \"P16_5\", \"P16_6\", \"P16_7\",\n\t\"P16_8\", \"P16_9\", \"P16_10\", \"P16_11\", \"P16_12\", \"P16_13\", \"P16_14\", \"P16_15\",\n\t\"P17_0\", \"P17_1\", \"P17_2\", \"P17_3\", \"P17_4\", \"P17_5\", \"P17_6\", \"P17_7\",\n\t\"P17_8\", \"P17_9\", \"P17_10\", \"P17_11\", \"P17_12\", \"P17_13\", \"P17_14\", \"P17_15\",\n\t\"P18_0\", \"P18_1\", \"P18_2\", \"P18_3\", \"P18_4\", \"P18_5\", \"P18_6\", \"P18_7\",\n\t\"P18_8\", \"P18_9\", \"P18_10\", \"P18_11\", \"P18_12\", \"P18_13\", \"P18_14\", \"P18_15\",\n\t\"P19_0\", \"P19_1\", \"P19_2\", \"P19_3\", \"P19_4\", \"P19_5\", \"P19_6\", \"P19_7\",\n\t\"P19_8\", \"P19_9\", \"P19_10\", \"P19_11\", \"P19_12\", \"P19_13\", \"P19_14\", \"P19_15\",\n\t\"P20_0\", \"P20_1\", \"P20_2\", \"P20_3\", \"P20_4\", \"P20_5\", \"P20_6\", \"P20_7\",\n\t\"P20_8\", \"P20_9\", \"P20_10\", \"P20_11\", \"P20_12\", \"P20_13\", \"P20_14\", \"P20_15\",\n\t\"P21_0\", \"P21_1\", \"P21_2\", \"P21_3\", \"P21_4\", \"P21_5\", \"P21_6\", \"P21_7\",\n\t\"P21_8\", \"P21_9\", \"P21_10\", \"P21_11\", \"P21_12\", \"P21_13\", \"P21_14\", \"P21_15\",\n};\n\nstatic const u32 rzv2m_gpio_configs[] = {\n\tRZV2M_GPIO_PORT_PACK(14, 0, PIN_CFG_GRP_SWIO_2 | RZV2M_MPXED_PIN_FUNCS),\n\tRZV2M_GPIO_PORT_PACK(16, 1, PIN_CFG_GRP_SWIO_1 | RZV2M_MPXED_PIN_FUNCS),\n\tRZV2M_GPIO_PORT_PACK(8,  2, PIN_CFG_GRP_1_8V_3 | RZV2M_MPXED_PIN_FUNCS),\n\tRZV2M_GPIO_PORT_PACK(16, 3, PIN_CFG_GRP_SWIO_1 | RZV2M_MPXED_PIN_FUNCS),\n\tRZV2M_GPIO_PORT_PACK(8,  4, PIN_CFG_GRP_SWIO_1 | RZV2M_MPXED_PIN_FUNCS),\n\tRZV2M_GPIO_PORT_PACK(4,  5, PIN_CFG_GRP_1_8V_3 | RZV2M_MPXED_PIN_FUNCS),\n\tRZV2M_GPIO_PORT_PACK(12, 6, PIN_CFG_GRP_SWIO_1 | RZV2M_MPXED_PIN_FUNCS),\n\tRZV2M_GPIO_PORT_PACK(6,  7, PIN_CFG_GRP_SWIO_1 | RZV2M_MPXED_PIN_FUNCS),\n\tRZV2M_GPIO_PORT_PACK(8,  8, PIN_CFG_GRP_SWIO_2 | RZV2M_MPXED_PIN_FUNCS),\n\tRZV2M_GPIO_PORT_PACK(8,  9, PIN_CFG_GRP_SWIO_2 | RZV2M_MPXED_PIN_FUNCS),\n\tRZV2M_GPIO_PORT_PACK(9,  10, PIN_CFG_GRP_SWIO_1 | RZV2M_MPXED_PIN_FUNCS),\n\tRZV2M_GPIO_PORT_PACK(9,  11, PIN_CFG_GRP_SWIO_1 | RZV2M_MPXED_PIN_FUNCS),\n\tRZV2M_GPIO_PORT_PACK(4,  12, PIN_CFG_GRP_3_3V | RZV2M_MPXED_PIN_FUNCS),\n\tRZV2M_GPIO_PORT_PACK(12, 13, PIN_CFG_GRP_3_3V | RZV2M_MPXED_PIN_FUNCS),\n\tRZV2M_GPIO_PORT_PACK(8,  14, PIN_CFG_GRP_3_3V | RZV2M_MPXED_PIN_FUNCS),\n\tRZV2M_GPIO_PORT_PACK(16, 15, PIN_CFG_GRP_SWIO_2 | RZV2M_MPXED_PIN_FUNCS),\n\tRZV2M_GPIO_PORT_PACK(14, 16, PIN_CFG_GRP_SWIO_2 | RZV2M_MPXED_PIN_FUNCS),\n\tRZV2M_GPIO_PORT_PACK(1,  17, PIN_CFG_GRP_SWIO_2 | RZV2M_MPXED_PIN_FUNCS),\n\tRZV2M_GPIO_PORT_PACK(0,  18, 0),\n\tRZV2M_GPIO_PORT_PACK(0,  19, 0),\n\tRZV2M_GPIO_PORT_PACK(3,  20, PIN_CFG_GRP_1_8V_2 | PIN_CFG_DRV),\n\tRZV2M_GPIO_PORT_PACK(1,  21, PIN_CFG_GRP_SWIO_1 | PIN_CFG_DRV | PIN_CFG_SLEW),\n};\n\nstatic const struct rzv2m_dedicated_configs rzv2m_dedicated_pins[] = {\n\t{ \"NAWPN\", RZV2M_SINGLE_PIN_PACK(0,\n\t\t(PIN_CFG_GRP_SWIO_2 | PIN_CFG_DRV | PIN_CFG_SLEW)) },\n\t{ \"IM0CLK\", RZV2M_SINGLE_PIN_PACK(1,\n\t\t(PIN_CFG_GRP_SWIO_1 | PIN_CFG_DRV | PIN_CFG_SLEW)) },\n\t{ \"IM1CLK\", RZV2M_SINGLE_PIN_PACK(2,\n\t\t(PIN_CFG_GRP_SWIO_1 | PIN_CFG_DRV | PIN_CFG_SLEW)) },\n\t{ \"DETDO\", RZV2M_SINGLE_PIN_PACK(5,\n\t\t(PIN_CFG_GRP_1_8V_3 | PIN_CFG_DRV | PIN_CFG_SLEW)) },\n\t{ \"DETMS\", RZV2M_SINGLE_PIN_PACK(6,\n\t\t(PIN_CFG_GRP_1_8V_3 | PIN_CFG_DRV | PIN_CFG_SLEW)) },\n\t{ \"PCRSTOUTB\", RZV2M_SINGLE_PIN_PACK(12,\n\t\t(PIN_CFG_GRP_3_3V | PIN_CFG_DRV | PIN_CFG_SLEW)) },\n\t{ \"USPWEN\", RZV2M_SINGLE_PIN_PACK(14,\n\t\t(PIN_CFG_GRP_3_3V | PIN_CFG_DRV | PIN_CFG_SLEW)) },\n};\n\nstatic int rzv2m_gpio_register(struct rzv2m_pinctrl *pctrl)\n{\n\tstruct device_node *np = pctrl->dev->of_node;\n\tstruct gpio_chip *chip = &pctrl->gpio_chip;\n\tconst char *name = dev_name(pctrl->dev);\n\tstruct of_phandle_args of_args;\n\tint ret;\n\n\tret = of_parse_phandle_with_fixed_args(np, \"gpio-ranges\", 3, 0, &of_args);\n\tif (ret) {\n\t\tdev_err(pctrl->dev, \"Unable to parse gpio-ranges\\n\");\n\t\treturn ret;\n\t}\n\n\tif (of_args.args[0] != 0 || of_args.args[1] != 0 ||\n\t    of_args.args[2] != pctrl->data->n_port_pins) {\n\t\tdev_err(pctrl->dev, \"gpio-ranges does not match selected SOC\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tchip->names = pctrl->data->port_pins;\n\tchip->request = rzv2m_gpio_request;\n\tchip->free = rzv2m_gpio_free;\n\tchip->get_direction = rzv2m_gpio_get_direction;\n\tchip->direction_input = rzv2m_gpio_direction_input;\n\tchip->direction_output = rzv2m_gpio_direction_output;\n\tchip->get = rzv2m_gpio_get;\n\tchip->set = rzv2m_gpio_set;\n\tchip->label = name;\n\tchip->parent = pctrl->dev;\n\tchip->owner = THIS_MODULE;\n\tchip->base = -1;\n\tchip->ngpio = of_args.args[2];\n\n\tpctrl->gpio_range.id = 0;\n\tpctrl->gpio_range.pin_base = 0;\n\tpctrl->gpio_range.base = 0;\n\tpctrl->gpio_range.npins = chip->ngpio;\n\tpctrl->gpio_range.name = chip->label;\n\tpctrl->gpio_range.gc = chip;\n\tret = devm_gpiochip_add_data(pctrl->dev, chip, pctrl);\n\tif (ret) {\n\t\tdev_err(pctrl->dev, \"failed to add GPIO controller\\n\");\n\t\treturn ret;\n\t}\n\n\tdev_dbg(pctrl->dev, \"Registered gpio controller\\n\");\n\n\treturn 0;\n}\n\nstatic int rzv2m_pinctrl_register(struct rzv2m_pinctrl *pctrl)\n{\n\tstruct pinctrl_pin_desc *pins;\n\tunsigned int i, j;\n\tu32 *pin_data;\n\tint ret;\n\n\tpctrl->desc.name = DRV_NAME;\n\tpctrl->desc.npins = pctrl->data->n_port_pins + pctrl->data->n_dedicated_pins;\n\tpctrl->desc.pctlops = &rzv2m_pinctrl_pctlops;\n\tpctrl->desc.pmxops = &rzv2m_pinctrl_pmxops;\n\tpctrl->desc.confops = &rzv2m_pinctrl_confops;\n\tpctrl->desc.owner = THIS_MODULE;\n\n\tpins = devm_kcalloc(pctrl->dev, pctrl->desc.npins, sizeof(*pins), GFP_KERNEL);\n\tif (!pins)\n\t\treturn -ENOMEM;\n\n\tpin_data = devm_kcalloc(pctrl->dev, pctrl->desc.npins,\n\t\t\t\tsizeof(*pin_data), GFP_KERNEL);\n\tif (!pin_data)\n\t\treturn -ENOMEM;\n\n\tpctrl->pins = pins;\n\tpctrl->desc.pins = pins;\n\n\tfor (i = 0, j = 0; i < pctrl->data->n_port_pins; i++) {\n\t\tpins[i].number = i;\n\t\tpins[i].name = pctrl->data->port_pins[i];\n\t\tif (i && !(i % RZV2M_PINS_PER_PORT))\n\t\t\tj++;\n\t\tpin_data[i] = pctrl->data->port_pin_configs[j];\n\t\tpins[i].drv_data = &pin_data[i];\n\t}\n\n\tfor (i = 0; i < pctrl->data->n_dedicated_pins; i++) {\n\t\tunsigned int index = pctrl->data->n_port_pins + i;\n\n\t\tpins[index].number = index;\n\t\tpins[index].name = pctrl->data->dedicated_pins[i].name;\n\t\tpin_data[index] = pctrl->data->dedicated_pins[i].config;\n\t\tpins[index].drv_data = &pin_data[index];\n\t}\n\n\tret = devm_pinctrl_register_and_init(pctrl->dev, &pctrl->desc, pctrl,\n\t\t\t\t\t     &pctrl->pctl);\n\tif (ret) {\n\t\tdev_err(pctrl->dev, \"pinctrl registration failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = pinctrl_enable(pctrl->pctl);\n\tif (ret) {\n\t\tdev_err(pctrl->dev, \"pinctrl enable failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = rzv2m_gpio_register(pctrl);\n\tif (ret) {\n\t\tdev_err(pctrl->dev, \"failed to add GPIO chip: %i\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int rzv2m_pinctrl_probe(struct platform_device *pdev)\n{\n\tstruct rzv2m_pinctrl *pctrl;\n\tstruct clk *clk;\n\tint ret;\n\n\tpctrl = devm_kzalloc(&pdev->dev, sizeof(*pctrl), GFP_KERNEL);\n\tif (!pctrl)\n\t\treturn -ENOMEM;\n\n\tpctrl->dev = &pdev->dev;\n\n\tpctrl->data = of_device_get_match_data(&pdev->dev);\n\tif (!pctrl->data)\n\t\treturn -EINVAL;\n\n\tpctrl->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(pctrl->base))\n\t\treturn PTR_ERR(pctrl->base);\n\n\tclk = devm_clk_get_enabled(pctrl->dev, NULL);\n\tif (IS_ERR(clk))\n\t\treturn dev_err_probe(pctrl->dev, PTR_ERR(clk),\n\t\t\t\t     \"failed to enable GPIO clk\\n\");\n\n\tspin_lock_init(&pctrl->lock);\n\tmutex_init(&pctrl->mutex);\n\n\tplatform_set_drvdata(pdev, pctrl);\n\n\tret = rzv2m_pinctrl_register(pctrl);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_info(pctrl->dev, \"%s support registered\\n\", DRV_NAME);\n\treturn 0;\n}\n\nstatic struct rzv2m_pinctrl_data r9a09g011_data = {\n\t.port_pins = rzv2m_gpio_names,\n\t.port_pin_configs = rzv2m_gpio_configs,\n\t.dedicated_pins = rzv2m_dedicated_pins,\n\t.n_port_pins = ARRAY_SIZE(rzv2m_gpio_configs) * RZV2M_PINS_PER_PORT,\n\t.n_dedicated_pins = ARRAY_SIZE(rzv2m_dedicated_pins),\n};\n\nstatic const struct of_device_id rzv2m_pinctrl_of_table[] = {\n\t{\n\t\t.compatible = \"renesas,r9a09g011-pinctrl\",\n\t\t.data = &r9a09g011_data,\n\t},\n\t{   }\n};\n\nstatic struct platform_driver rzv2m_pinctrl_driver = {\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.of_match_table = of_match_ptr(rzv2m_pinctrl_of_table),\n\t},\n\t.probe = rzv2m_pinctrl_probe,\n};\n\nstatic int __init rzv2m_pinctrl_init(void)\n{\n\treturn platform_driver_register(&rzv2m_pinctrl_driver);\n}\ncore_initcall(rzv2m_pinctrl_init);\n\nMODULE_AUTHOR(\"Phil Edworthy <phil.edworthy@renesas.com>\");\nMODULE_DESCRIPTION(\"Pin and gpio controller driver for RZ/V2M\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}