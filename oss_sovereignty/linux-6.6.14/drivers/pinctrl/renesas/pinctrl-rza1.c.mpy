{
  "module_name": "pinctrl-rza1.c",
  "hash_id": "1a973be88d191008ff5bc426dbf0d076eb4568d99910f358ca539bd20a867beb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/renesas/pinctrl-rza1.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/bitops.h>\n#include <linux/err.h>\n#include <linux/gpio/driver.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/pinctrl/pinconf-generic.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinmux.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/slab.h>\n\n#include \"../core.h\"\n#include \"../devicetree.h\"\n#include \"../pinconf.h\"\n#include \"../pinmux.h\"\n\n#define DRIVER_NAME\t\t\t\"pinctrl-rza1\"\n\n#define RZA1_P_REG\t\t\t0x0000\n#define RZA1_PPR_REG\t\t\t0x0200\n#define RZA1_PM_REG\t\t\t0x0300\n#define RZA1_PMC_REG\t\t\t0x0400\n#define RZA1_PFC_REG\t\t\t0x0500\n#define RZA1_PFCE_REG\t\t\t0x0600\n#define RZA1_PFCEA_REG\t\t\t0x0a00\n#define RZA1_PIBC_REG\t\t\t0x4000\n#define RZA1_PBDC_REG\t\t\t0x4100\n#define RZA1_PIPC_REG\t\t\t0x4200\n\n#define RZA1_ADDR(mem, reg, port)\t((mem) + (reg) + ((port) * 4))\n\n#define RZA1_NPORTS\t\t\t12\n#define RZA1_PINS_PER_PORT\t\t16\n#define RZA1_NPINS\t\t\t(RZA1_PINS_PER_PORT * RZA1_NPORTS)\n#define RZA1_PIN_ID_TO_PORT(id)\t\t((id) / RZA1_PINS_PER_PORT)\n#define RZA1_PIN_ID_TO_PIN(id)\t\t((id) % RZA1_PINS_PER_PORT)\n\n \n#define MUX_PIN_ID_MASK\t\t\tGENMASK(15, 0)\n#define MUX_FUNC_MASK\t\t\tGENMASK(31, 16)\n\n#define MUX_FUNC_OFFS\t\t\t16\n#define MUX_FUNC(pinconf)\t\t\\\n\t((pinconf & MUX_FUNC_MASK) >> MUX_FUNC_OFFS)\n#define MUX_FUNC_PFC_MASK\t\tBIT(0)\n#define MUX_FUNC_PFCE_MASK\t\tBIT(1)\n#define MUX_FUNC_PFCEA_MASK\t\tBIT(2)\n\n \n#define MUX_FLAGS_BIDIR\t\t\tBIT(0)\n#define MUX_FLAGS_SWIO_INPUT\t\tBIT(1)\n#define MUX_FLAGS_SWIO_OUTPUT\t\tBIT(2)\n\n \n\n \nstruct rza1_bidir_pin {\n\tu8 pin: 4;\n\tu8 func: 4;\n};\n\n \nstruct rza1_bidir_entry {\n\tconst unsigned int npins;\n\tconst struct rza1_bidir_pin *pins;\n};\n\n \nstruct rza1_swio_pin {\n\tu16 pin: 4;\n\tu16 port: 4;\n\tu16 func: 4;\n\tu16 input: 1;\n};\n\n \nstruct rza1_swio_entry {\n\tconst unsigned int npins;\n\tconst struct rza1_swio_pin *pins;\n};\n\n \nstruct rza1_pinmux_conf {\n\tconst struct rza1_bidir_entry *bidir_entries;\n\tconst struct rza1_swio_entry *swio_entries;\n};\n\n \n\nstatic const struct rza1_bidir_pin rza1h_bidir_pins_p1[] = {\n\t{ .pin = 0, .func = 1 },\n\t{ .pin = 1, .func = 1 },\n\t{ .pin = 2, .func = 1 },\n\t{ .pin = 3, .func = 1 },\n\t{ .pin = 4, .func = 1 },\n\t{ .pin = 5, .func = 1 },\n\t{ .pin = 6, .func = 1 },\n\t{ .pin = 7, .func = 1 },\n};\n\nstatic const struct rza1_bidir_pin rza1h_bidir_pins_p2[] = {\n\t{ .pin = 0, .func = 1 },\n\t{ .pin = 1, .func = 1 },\n\t{ .pin = 2, .func = 1 },\n\t{ .pin = 3, .func = 1 },\n\t{ .pin = 4, .func = 1 },\n\t{ .pin = 0, .func = 4 },\n\t{ .pin = 1, .func = 4 },\n\t{ .pin = 2, .func = 4 },\n\t{ .pin = 3, .func = 4 },\n\t{ .pin = 5, .func = 1 },\n\t{ .pin = 6, .func = 1 },\n\t{ .pin = 7, .func = 1 },\n\t{ .pin = 8, .func = 1 },\n\t{ .pin = 9, .func = 1 },\n\t{ .pin = 10, .func = 1 },\n\t{ .pin = 11, .func = 1 },\n\t{ .pin = 12, .func = 1 },\n\t{ .pin = 13, .func = 1 },\n\t{ .pin = 14, .func = 1 },\n\t{ .pin = 15, .func = 1 },\n\t{ .pin = 12, .func = 4 },\n\t{ .pin = 13, .func = 4 },\n\t{ .pin = 14, .func = 4 },\n\t{ .pin = 15, .func = 4 },\n};\n\nstatic const struct rza1_bidir_pin rza1h_bidir_pins_p3[] = {\n\t{ .pin = 3, .func = 2 },\n\t{ .pin = 10, .func = 7 },\n\t{ .pin = 11, .func = 7 },\n\t{ .pin = 13, .func = 7 },\n\t{ .pin = 14, .func = 7 },\n\t{ .pin = 15, .func = 7 },\n\t{ .pin = 10, .func = 8 },\n\t{ .pin = 11, .func = 8 },\n\t{ .pin = 13, .func = 8 },\n\t{ .pin = 14, .func = 8 },\n\t{ .pin = 15, .func = 8 },\n};\n\nstatic const struct rza1_bidir_pin rza1h_bidir_pins_p4[] = {\n\t{ .pin = 0, .func = 8 },\n\t{ .pin = 1, .func = 8 },\n\t{ .pin = 2, .func = 8 },\n\t{ .pin = 3, .func = 8 },\n\t{ .pin = 10, .func = 3 },\n\t{ .pin = 11, .func = 3 },\n\t{ .pin = 13, .func = 3 },\n\t{ .pin = 14, .func = 3 },\n\t{ .pin = 15, .func = 3 },\n\t{ .pin = 10, .func = 4 },\n\t{ .pin = 11, .func = 4 },\n\t{ .pin = 13, .func = 4 },\n\t{ .pin = 14, .func = 4 },\n\t{ .pin = 15, .func = 4 },\n\t{ .pin = 12, .func = 5 },\n\t{ .pin = 13, .func = 5 },\n\t{ .pin = 14, .func = 5 },\n\t{ .pin = 15, .func = 5 },\n};\n\nstatic const struct rza1_bidir_pin rza1h_bidir_pins_p6[] = {\n\t{ .pin = 0, .func = 1 },\n\t{ .pin = 1, .func = 1 },\n\t{ .pin = 2, .func = 1 },\n\t{ .pin = 3, .func = 1 },\n\t{ .pin = 4, .func = 1 },\n\t{ .pin = 5, .func = 1 },\n\t{ .pin = 6, .func = 1 },\n\t{ .pin = 7, .func = 1 },\n\t{ .pin = 8, .func = 1 },\n\t{ .pin = 9, .func = 1 },\n\t{ .pin = 10, .func = 1 },\n\t{ .pin = 11, .func = 1 },\n\t{ .pin = 12, .func = 1 },\n\t{ .pin = 13, .func = 1 },\n\t{ .pin = 14, .func = 1 },\n\t{ .pin = 15, .func = 1 },\n};\n\nstatic const struct rza1_bidir_pin rza1h_bidir_pins_p7[] = {\n\t{ .pin = 13, .func = 3 },\n};\n\nstatic const struct rza1_bidir_pin rza1h_bidir_pins_p8[] = {\n\t{ .pin = 8, .func = 3 },\n\t{ .pin = 9, .func = 3 },\n\t{ .pin = 10, .func = 3 },\n\t{ .pin = 11, .func = 3 },\n\t{ .pin = 14, .func = 2 },\n\t{ .pin = 15, .func = 2 },\n\t{ .pin = 14, .func = 3 },\n\t{ .pin = 15, .func = 3 },\n};\n\nstatic const struct rza1_bidir_pin rza1h_bidir_pins_p9[] = {\n\t{ .pin = 0, .func = 2 },\n\t{ .pin = 1, .func = 2 },\n\t{ .pin = 4, .func = 2 },\n\t{ .pin = 5, .func = 2 },\n\t{ .pin = 6, .func = 2 },\n\t{ .pin = 7, .func = 2 },\n};\n\nstatic const struct rza1_bidir_pin rza1h_bidir_pins_p11[] = {\n\t{ .pin = 6, .func = 2 },\n\t{ .pin = 7, .func = 2 },\n\t{ .pin = 9, .func = 2 },\n\t{ .pin = 6, .func = 4 },\n\t{ .pin = 7, .func = 4 },\n\t{ .pin = 9, .func = 4 },\n\t{ .pin = 10, .func = 2 },\n\t{ .pin = 11, .func = 2 },\n\t{ .pin = 10, .func = 4 },\n\t{ .pin = 11, .func = 4 },\n\t{ .pin = 12, .func = 4 },\n\t{ .pin = 13, .func = 4 },\n\t{ .pin = 14, .func = 4 },\n\t{ .pin = 15, .func = 4 },\n};\n\nstatic const struct rza1_swio_pin rza1h_swio_pins[] = {\n\t{ .port = 2, .pin = 7, .func = 4, .input = 0 },\n\t{ .port = 2, .pin = 11, .func = 4, .input = 0 },\n\t{ .port = 3, .pin = 7, .func = 3, .input = 0 },\n\t{ .port = 3, .pin = 7, .func = 8, .input = 0 },\n\t{ .port = 4, .pin = 7, .func = 5, .input = 0 },\n\t{ .port = 4, .pin = 7, .func = 11, .input = 0 },\n\t{ .port = 4, .pin = 15, .func = 6, .input = 0 },\n\t{ .port = 5, .pin = 0, .func = 1, .input = 1 },\n\t{ .port = 5, .pin = 1, .func = 1, .input = 1 },\n\t{ .port = 5, .pin = 2, .func = 1, .input = 1 },\n\t{ .port = 5, .pin = 3, .func = 1, .input = 1 },\n\t{ .port = 5, .pin = 4, .func = 1, .input = 1 },\n\t{ .port = 5, .pin = 5, .func = 1, .input = 1 },\n\t{ .port = 5, .pin = 6, .func = 1, .input = 1 },\n\t{ .port = 5, .pin = 7, .func = 1, .input = 1 },\n\t{ .port = 7, .pin = 4, .func = 6, .input = 0 },\n\t{ .port = 7, .pin = 11, .func = 2, .input = 0 },\n\t{ .port = 8, .pin = 10, .func = 8, .input = 0 },\n\t{ .port = 10, .pin = 15, .func = 2, .input = 0 },\n};\n\nstatic const struct rza1_bidir_entry rza1h_bidir_entries[RZA1_NPORTS] = {\n\t[1] = { ARRAY_SIZE(rza1h_bidir_pins_p1), rza1h_bidir_pins_p1 },\n\t[2] = { ARRAY_SIZE(rza1h_bidir_pins_p2), rza1h_bidir_pins_p2 },\n\t[3] = { ARRAY_SIZE(rza1h_bidir_pins_p3), rza1h_bidir_pins_p3 },\n\t[4] = { ARRAY_SIZE(rza1h_bidir_pins_p4), rza1h_bidir_pins_p4 },\n\t[6] = { ARRAY_SIZE(rza1h_bidir_pins_p6), rza1h_bidir_pins_p6 },\n\t[7] = { ARRAY_SIZE(rza1h_bidir_pins_p7), rza1h_bidir_pins_p7 },\n\t[8] = { ARRAY_SIZE(rza1h_bidir_pins_p8), rza1h_bidir_pins_p8 },\n\t[9] = { ARRAY_SIZE(rza1h_bidir_pins_p9), rza1h_bidir_pins_p9 },\n\t[11] = { ARRAY_SIZE(rza1h_bidir_pins_p11), rza1h_bidir_pins_p11 },\n};\n\nstatic const struct rza1_swio_entry rza1h_swio_entries[] = {\n\t[0] = { ARRAY_SIZE(rza1h_swio_pins), rza1h_swio_pins },\n};\n\n \nstatic const struct rza1_pinmux_conf rza1h_pmx_conf = {\n\t.bidir_entries\t= rza1h_bidir_entries,\n\t.swio_entries\t= rza1h_swio_entries,\n};\n\n \n\nstatic const struct rza1_bidir_pin rza1l_bidir_pins_p1[] = {\n\t{ .pin = 0, .func = 1 },\n\t{ .pin = 1, .func = 1 },\n\t{ .pin = 2, .func = 1 },\n\t{ .pin = 3, .func = 1 },\n\t{ .pin = 4, .func = 1 },\n\t{ .pin = 5, .func = 1 },\n\t{ .pin = 6, .func = 1 },\n\t{ .pin = 7, .func = 1 },\n};\n\nstatic const struct rza1_bidir_pin rza1l_bidir_pins_p3[] = {\n\t{ .pin = 0, .func = 2 },\n\t{ .pin = 1, .func = 2 },\n\t{ .pin = 2, .func = 2 },\n\t{ .pin = 4, .func = 2 },\n\t{ .pin = 5, .func = 2 },\n\t{ .pin = 10, .func = 2 },\n\t{ .pin = 11, .func = 2 },\n\t{ .pin = 12, .func = 2 },\n\t{ .pin = 13, .func = 2 },\n};\n\nstatic const struct rza1_bidir_pin rza1l_bidir_pins_p4[] = {\n\t{ .pin = 1, .func = 4 },\n\t{ .pin = 2, .func = 2 },\n\t{ .pin = 3, .func = 2 },\n\t{ .pin = 6, .func = 2 },\n\t{ .pin = 7, .func = 2 },\n};\n\nstatic const struct rza1_bidir_pin rza1l_bidir_pins_p5[] = {\n\t{ .pin = 0, .func = 1 },\n\t{ .pin = 1, .func = 1 },\n\t{ .pin = 2, .func = 1 },\n\t{ .pin = 3, .func = 1 },\n\t{ .pin = 4, .func = 1 },\n\t{ .pin = 5, .func = 1 },\n\t{ .pin = 6, .func = 1 },\n\t{ .pin = 7, .func = 1 },\n\t{ .pin = 8, .func = 1 },\n\t{ .pin = 9, .func = 1 },\n\t{ .pin = 10, .func = 1 },\n\t{ .pin = 11, .func = 1 },\n\t{ .pin = 12, .func = 1 },\n\t{ .pin = 13, .func = 1 },\n\t{ .pin = 14, .func = 1 },\n\t{ .pin = 15, .func = 1 },\n\t{ .pin = 0, .func = 2 },\n\t{ .pin = 1, .func = 2 },\n\t{ .pin = 2, .func = 2 },\n\t{ .pin = 3, .func = 2 },\n};\n\nstatic const struct rza1_bidir_pin rza1l_bidir_pins_p6[] = {\n\t{ .pin = 0, .func = 1 },\n\t{ .pin = 1, .func = 1 },\n\t{ .pin = 2, .func = 1 },\n\t{ .pin = 3, .func = 1 },\n\t{ .pin = 4, .func = 1 },\n\t{ .pin = 5, .func = 1 },\n\t{ .pin = 6, .func = 1 },\n\t{ .pin = 7, .func = 1 },\n\t{ .pin = 8, .func = 1 },\n\t{ .pin = 9, .func = 1 },\n\t{ .pin = 10, .func = 1 },\n\t{ .pin = 11, .func = 1 },\n\t{ .pin = 12, .func = 1 },\n\t{ .pin = 13, .func = 1 },\n\t{ .pin = 14, .func = 1 },\n\t{ .pin = 15, .func = 1 },\n};\n\nstatic const struct rza1_bidir_pin rza1l_bidir_pins_p7[] = {\n\t{ .pin = 2, .func = 2 },\n\t{ .pin = 3, .func = 2 },\n\t{ .pin = 5, .func = 2 },\n\t{ .pin = 6, .func = 2 },\n\t{ .pin = 7, .func = 2 },\n\t{ .pin = 2, .func = 3 },\n\t{ .pin = 3, .func = 3 },\n\t{ .pin = 5, .func = 3 },\n\t{ .pin = 6, .func = 3 },\n\t{ .pin = 7, .func = 3 },\n};\n\nstatic const struct rza1_bidir_pin rza1l_bidir_pins_p9[] = {\n\t{ .pin = 1, .func = 2 },\n\t{ .pin = 0, .func = 3 },\n\t{ .pin = 1, .func = 3 },\n\t{ .pin = 3, .func = 3 },\n\t{ .pin = 4, .func = 3 },\n\t{ .pin = 5, .func = 3 },\n};\n\nstatic const struct rza1_swio_pin rza1l_swio_pins[] = {\n\t{ .port = 2, .pin = 8, .func = 2, .input = 0 },\n\t{ .port = 5, .pin = 6, .func = 3, .input = 0 },\n\t{ .port = 6, .pin = 6, .func = 3, .input = 0 },\n\t{ .port = 6, .pin = 10, .func = 3, .input = 0 },\n\t{ .port = 7, .pin = 10, .func = 2, .input = 0 },\n\t{ .port = 8, .pin = 2, .func = 3, .input = 0 },\n};\n\nstatic const struct rza1_bidir_entry rza1l_bidir_entries[RZA1_NPORTS] = {\n\t[1] = { ARRAY_SIZE(rza1l_bidir_pins_p1), rza1l_bidir_pins_p1 },\n\t[3] = { ARRAY_SIZE(rza1l_bidir_pins_p3), rza1l_bidir_pins_p3 },\n\t[4] = { ARRAY_SIZE(rza1l_bidir_pins_p4), rza1l_bidir_pins_p4 },\n\t[5] = { ARRAY_SIZE(rza1l_bidir_pins_p4), rza1l_bidir_pins_p5 },\n\t[6] = { ARRAY_SIZE(rza1l_bidir_pins_p6), rza1l_bidir_pins_p6 },\n\t[7] = { ARRAY_SIZE(rza1l_bidir_pins_p7), rza1l_bidir_pins_p7 },\n\t[9] = { ARRAY_SIZE(rza1l_bidir_pins_p9), rza1l_bidir_pins_p9 },\n};\n\nstatic const struct rza1_swio_entry rza1l_swio_entries[] = {\n\t[0] = { ARRAY_SIZE(rza1l_swio_pins), rza1l_swio_pins },\n};\n\n \nstatic const struct rza1_pinmux_conf rza1l_pmx_conf = {\n\t.bidir_entries\t= rza1l_bidir_entries,\n\t.swio_entries\t= rza1l_swio_entries,\n};\n\n \n \nstruct rza1_mux_conf {\n\tu16 id;\n\tu8 port;\n\tu8 pin;\n\tu8 mux_func;\n\tu8 mux_flags;\n\tu8 value;\n};\n\n \nstruct rza1_port {\n\tspinlock_t lock;\n\tunsigned int id;\n\tvoid __iomem *base;\n\tstruct pinctrl_pin_desc *pins;\n};\n\n \nstruct rza1_pinctrl {\n\tstruct device *dev;\n\n\tstruct mutex mutex;\n\n\tvoid __iomem *base;\n\n\tunsigned int nport;\n\tstruct rza1_port *ports;\n\n\tstruct pinctrl_pin_desc *pins;\n\tstruct pinctrl_desc desc;\n\tstruct pinctrl_dev *pctl;\n\n\tconst void *data;\n};\n\n \nstatic inline bool rza1_pinmux_get_bidir(unsigned int port,\n\t\t\t\t\t unsigned int pin,\n\t\t\t\t\t unsigned int func,\n\t\t\t\t\t const struct rza1_bidir_entry *table)\n{\n\tconst struct rza1_bidir_entry *entry = &table[port];\n\tconst struct rza1_bidir_pin *bidir_pin;\n\tunsigned int i;\n\n\tfor (i = 0; i < entry->npins; ++i) {\n\t\tbidir_pin = &entry->pins[i];\n\t\tif (bidir_pin->pin == pin && bidir_pin->func == func)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic inline int rza1_pinmux_get_swio(unsigned int port,\n\t\t\t\t       unsigned int pin,\n\t\t\t\t       unsigned int func,\n\t\t\t\t       const struct rza1_swio_entry *table)\n{\n\tconst struct rza1_swio_pin *swio_pin;\n\tunsigned int i;\n\n\n\tfor (i = 0; i < table->npins; ++i) {\n\t\tswio_pin = &table->pins[i];\n\t\tif (swio_pin->port == port && swio_pin->pin == pin &&\n\t\t    swio_pin->func == func)\n\t\t\treturn swio_pin->input;\n\t}\n\n\treturn -ENOENT;\n}\n\n \nstatic unsigned int rza1_pinmux_get_flags(unsigned int port, unsigned int pin,\n\t\t\t\t\t  unsigned int func,\n\t\t\t\t\t  struct rza1_pinctrl *rza1_pctl)\n\n{\n\tconst struct rza1_pinmux_conf *pmx_conf = rza1_pctl->data;\n\tconst struct rza1_bidir_entry *bidir_entries = pmx_conf->bidir_entries;\n\tconst struct rza1_swio_entry *swio_entries = pmx_conf->swio_entries;\n\tunsigned int pmx_flags = 0;\n\tint ret;\n\n\tif (rza1_pinmux_get_bidir(port, pin, func, bidir_entries))\n\t\tpmx_flags |= MUX_FLAGS_BIDIR;\n\n\tret = rza1_pinmux_get_swio(port, pin, func, swio_entries);\n\tif (ret == 0)\n\t\tpmx_flags |= MUX_FLAGS_SWIO_OUTPUT;\n\telse if (ret > 0)\n\t\tpmx_flags |= MUX_FLAGS_SWIO_INPUT;\n\n\treturn pmx_flags;\n}\n\n \n\n \nstatic inline void rza1_set_bit(struct rza1_port *port, unsigned int reg,\n\t\t\t\tunsigned int bit, bool set)\n{\n\tvoid __iomem *mem = RZA1_ADDR(port->base, reg, port->id);\n\tu16 val = ioread16(mem);\n\n\tif (set)\n\t\tval |= BIT(bit);\n\telse\n\t\tval &= ~BIT(bit);\n\n\tiowrite16(val, mem);\n}\n\nstatic inline unsigned int rza1_get_bit(struct rza1_port *port,\n\t\t\t\t\tunsigned int reg, unsigned int bit)\n{\n\tvoid __iomem *mem = RZA1_ADDR(port->base, reg, port->id);\n\n\treturn ioread16(mem) & BIT(bit);\n}\n\n \nstatic void rza1_pin_reset(struct rza1_port *port, unsigned int pin)\n{\n\tunsigned long irqflags;\n\n\tspin_lock_irqsave(&port->lock, irqflags);\n\trza1_set_bit(port, RZA1_PIBC_REG, pin, 0);\n\trza1_set_bit(port, RZA1_PBDC_REG, pin, 0);\n\n\trza1_set_bit(port, RZA1_PM_REG, pin, 1);\n\trza1_set_bit(port, RZA1_PMC_REG, pin, 0);\n\trza1_set_bit(port, RZA1_PIPC_REG, pin, 0);\n\tspin_unlock_irqrestore(&port->lock, irqflags);\n}\n\n \nstatic inline void rza1_pin_set_direction(struct rza1_port *port,\n\t\t\t\t\t  unsigned int pin, bool input)\n{\n\tunsigned long irqflags;\n\n\tspin_lock_irqsave(&port->lock, irqflags);\n\n\trza1_set_bit(port, RZA1_PIBC_REG, pin, 1);\n\tif (input) {\n\t\trza1_set_bit(port, RZA1_PM_REG, pin, 1);\n\t\trza1_set_bit(port, RZA1_PBDC_REG, pin, 0);\n\t} else {\n\t\trza1_set_bit(port, RZA1_PM_REG, pin, 0);\n\t\trza1_set_bit(port, RZA1_PBDC_REG, pin, 1);\n\t}\n\n\tspin_unlock_irqrestore(&port->lock, irqflags);\n}\n\nstatic inline void rza1_pin_set(struct rza1_port *port, unsigned int pin,\n\t\t\t\tunsigned int value)\n{\n\tunsigned long irqflags;\n\n\tspin_lock_irqsave(&port->lock, irqflags);\n\trza1_set_bit(port, RZA1_P_REG, pin, !!value);\n\tspin_unlock_irqrestore(&port->lock, irqflags);\n}\n\nstatic inline int rza1_pin_get(struct rza1_port *port, unsigned int pin)\n{\n\treturn rza1_get_bit(port, RZA1_PPR_REG, pin);\n}\n\n \nstatic int rza1_pin_mux_single(struct rza1_pinctrl *rza1_pctl,\n\t\t\t       struct rza1_mux_conf *mux_conf)\n{\n\tstruct rza1_port *port = &rza1_pctl->ports[mux_conf->port];\n\tunsigned int pin = mux_conf->pin;\n\tu8 mux_func = mux_conf->mux_func;\n\tu8 mux_flags = mux_conf->mux_flags;\n\tu8 mux_flags_from_table;\n\n\trza1_pin_reset(port, pin);\n\n\t \n\tmux_flags_from_table = rza1_pinmux_get_flags(port->id, pin, mux_func,\n\t\t\t\t\t\t     rza1_pctl);\n\tif (mux_flags)\n\t\tmux_flags |= (mux_flags_from_table & MUX_FLAGS_BIDIR);\n\telse\n\t\tmux_flags = mux_flags_from_table;\n\n\tif (mux_flags & MUX_FLAGS_BIDIR)\n\t\trza1_set_bit(port, RZA1_PBDC_REG, pin, 1);\n\n\t \n\tmux_func -= 1;\n\trza1_set_bit(port, RZA1_PFC_REG, pin, mux_func & MUX_FUNC_PFC_MASK);\n\trza1_set_bit(port, RZA1_PFCE_REG, pin, mux_func & MUX_FUNC_PFCE_MASK);\n\trza1_set_bit(port, RZA1_PFCEA_REG, pin, mux_func & MUX_FUNC_PFCEA_MASK);\n\n\t \n\tif (mux_flags & (MUX_FLAGS_SWIO_INPUT | MUX_FLAGS_SWIO_OUTPUT))\n\t\trza1_set_bit(port, RZA1_PM_REG, pin,\n\t\t\t     mux_flags & MUX_FLAGS_SWIO_INPUT);\n\telse\n\t\trza1_set_bit(port, RZA1_PIPC_REG, pin, 1);\n\n\trza1_set_bit(port, RZA1_PMC_REG, pin, 1);\n\n\treturn 0;\n}\n\n \n\n \nstatic int rza1_gpio_request(struct gpio_chip *chip, unsigned int gpio)\n{\n\tstruct rza1_port *port = gpiochip_get_data(chip);\n\n\trza1_pin_reset(port, gpio);\n\n\treturn 0;\n}\n\n \nstatic void rza1_gpio_free(struct gpio_chip *chip, unsigned int gpio)\n{\n\tstruct rza1_port *port = gpiochip_get_data(chip);\n\n\trza1_pin_reset(port, gpio);\n}\n\nstatic int rza1_gpio_get_direction(struct gpio_chip *chip, unsigned int gpio)\n{\n\tstruct rza1_port *port = gpiochip_get_data(chip);\n\n\tif (rza1_get_bit(port, RZA1_PM_REG, gpio))\n\t\treturn GPIO_LINE_DIRECTION_IN;\n\n\treturn GPIO_LINE_DIRECTION_OUT;\n}\n\nstatic int rza1_gpio_direction_input(struct gpio_chip *chip,\n\t\t\t\t     unsigned int gpio)\n{\n\tstruct rza1_port *port = gpiochip_get_data(chip);\n\n\trza1_pin_set_direction(port, gpio, true);\n\n\treturn 0;\n}\n\nstatic int rza1_gpio_direction_output(struct gpio_chip *chip,\n\t\t\t\t      unsigned int gpio,\n\t\t\t\t      int value)\n{\n\tstruct rza1_port *port = gpiochip_get_data(chip);\n\n\t \n\trza1_pin_set(port, gpio, value);\n\trza1_pin_set_direction(port, gpio, false);\n\n\treturn 0;\n}\n\n \nstatic int rza1_gpio_get(struct gpio_chip *chip, unsigned int gpio)\n{\n\tstruct rza1_port *port = gpiochip_get_data(chip);\n\n\treturn rza1_pin_get(port, gpio);\n}\n\nstatic void rza1_gpio_set(struct gpio_chip *chip, unsigned int gpio,\n\t\t\t  int value)\n{\n\tstruct rza1_port *port = gpiochip_get_data(chip);\n\n\trza1_pin_set(port, gpio, value);\n}\n\nstatic const struct gpio_chip rza1_gpiochip_template = {\n\t.request\t\t= rza1_gpio_request,\n\t.free\t\t\t= rza1_gpio_free,\n\t.get_direction\t\t= rza1_gpio_get_direction,\n\t.direction_input\t= rza1_gpio_direction_input,\n\t.direction_output\t= rza1_gpio_direction_output,\n\t.get\t\t\t= rza1_gpio_get,\n\t.set\t\t\t= rza1_gpio_set,\n};\n \n\n \nstatic int rza1_dt_node_pin_count(struct device_node *np)\n{\n\tstruct device_node *child;\n\tstruct property *of_pins;\n\tunsigned int npins;\n\n\tof_pins = of_find_property(np, \"pinmux\", NULL);\n\tif (of_pins)\n\t\treturn of_pins->length / sizeof(u32);\n\n\tnpins = 0;\n\tfor_each_child_of_node(np, child) {\n\t\tof_pins = of_find_property(child, \"pinmux\", NULL);\n\t\tif (!of_pins) {\n\t\t\tof_node_put(child);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tnpins += of_pins->length / sizeof(u32);\n\t}\n\n\treturn npins;\n}\n\n \nstatic int rza1_parse_pinmux_node(struct rza1_pinctrl *rza1_pctl,\n\t\t\t\t  struct device_node *np,\n\t\t\t\t  struct rza1_mux_conf *mux_confs,\n\t\t\t\t  unsigned int *grpins)\n{\n\tstruct pinctrl_dev *pctldev = rza1_pctl->pctl;\n\tchar const *prop_name = \"pinmux\";\n\tunsigned long *pin_configs;\n\tunsigned int npin_configs;\n\tstruct property *of_pins;\n\tunsigned int npins;\n\tu8 pinmux_flags;\n\tunsigned int i;\n\tint ret;\n\n\tof_pins = of_find_property(np, prop_name, NULL);\n\tif (!of_pins) {\n\t\tdev_dbg(rza1_pctl->dev, \"Missing %s property\\n\", prop_name);\n\t\treturn -ENOENT;\n\t}\n\tnpins = of_pins->length / sizeof(u32);\n\n\t \n\tret = pinconf_generic_parse_dt_config(np, pctldev, &pin_configs,\n\t\t\t\t\t      &npin_configs);\n\tif (ret) {\n\t\tdev_err(rza1_pctl->dev,\n\t\t\t\"Unable to parse pin configuration options for %pOFn\\n\",\n\t\t\tnp);\n\t\treturn ret;\n\t}\n\n\t \n\tpinmux_flags = 0;\n\tfor (i = 0; i < npin_configs && pinmux_flags == 0; i++)\n\t\tswitch (pinconf_to_config_param(pin_configs[i])) {\n\t\tcase PIN_CONFIG_INPUT_ENABLE:\n\t\t\tpinmux_flags |= MUX_FLAGS_SWIO_INPUT;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_OUTPUT:\t \n\t\tcase PIN_CONFIG_OUTPUT_ENABLE:\n\t\t\tpinmux_flags |= MUX_FLAGS_SWIO_OUTPUT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\n\t\t}\n\n\tkfree(pin_configs);\n\n\t \n\tfor (i = 0; i < npins; ++i) {\n\t\tu32 of_pinconf;\n\t\tstruct rza1_mux_conf *mux_conf = &mux_confs[i];\n\n\t\tret = of_property_read_u32_index(np, prop_name, i, &of_pinconf);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tmux_conf->id\t\t= of_pinconf & MUX_PIN_ID_MASK;\n\t\tmux_conf->port\t\t= RZA1_PIN_ID_TO_PORT(mux_conf->id);\n\t\tmux_conf->pin\t\t= RZA1_PIN_ID_TO_PIN(mux_conf->id);\n\t\tmux_conf->mux_func\t= MUX_FUNC(of_pinconf);\n\t\tmux_conf->mux_flags\t= pinmux_flags;\n\n\t\tif (mux_conf->port >= RZA1_NPORTS ||\n\t\t    mux_conf->pin >= RZA1_PINS_PER_PORT) {\n\t\t\tdev_err(rza1_pctl->dev,\n\t\t\t\t\"Wrong port %u pin %u for %s property\\n\",\n\t\t\t\tmux_conf->port, mux_conf->pin, prop_name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tgrpins[i] = mux_conf->id;\n\t}\n\n\treturn npins;\n}\n\n \nstatic int rza1_dt_node_to_map(struct pinctrl_dev *pctldev,\n\t\t\t       struct device_node *np,\n\t\t\t       struct pinctrl_map **map,\n\t\t\t       unsigned int *num_maps)\n{\n\tstruct rza1_pinctrl *rza1_pctl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct rza1_mux_conf *mux_confs, *mux_conf;\n\tunsigned int *grpins, *grpin;\n\tstruct device_node *child;\n\tconst char *grpname;\n\tconst char **fngrps;\n\tint ret, npins;\n\tint gsel, fsel;\n\n\tnpins = rza1_dt_node_pin_count(np);\n\tif (npins < 0) {\n\t\tdev_err(rza1_pctl->dev, \"invalid pinmux node structure\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tmux_confs = devm_kcalloc(rza1_pctl->dev, npins, sizeof(*mux_confs),\n\t\t\t\t GFP_KERNEL);\n\tgrpins = devm_kcalloc(rza1_pctl->dev, npins, sizeof(*grpins),\n\t\t\t      GFP_KERNEL);\n\tfngrps = devm_kzalloc(rza1_pctl->dev, sizeof(*fngrps), GFP_KERNEL);\n\n\tif (!mux_confs || !grpins || !fngrps)\n\t\treturn -ENOMEM;\n\n\t \n\tmux_conf = &mux_confs[0];\n\tgrpin = &grpins[0];\n\n\tret = rza1_parse_pinmux_node(rza1_pctl, np, mux_conf, grpin);\n\tif (ret == -ENOENT)\n\t\tfor_each_child_of_node(np, child) {\n\t\t\tret = rza1_parse_pinmux_node(rza1_pctl, child, mux_conf,\n\t\t\t\t\t\t     grpin);\n\t\t\tif (ret < 0) {\n\t\t\t\tof_node_put(child);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tgrpin += ret;\n\t\t\tmux_conf += ret;\n\t\t}\n\telse if (ret < 0)\n\t\treturn ret;\n\n\t \n\tgrpname\t= np->name;\n\tfngrps[0] = grpname;\n\n\tmutex_lock(&rza1_pctl->mutex);\n\tgsel = pinctrl_generic_add_group(pctldev, grpname, grpins, npins,\n\t\t\t\t\t NULL);\n\tif (gsel < 0) {\n\t\tmutex_unlock(&rza1_pctl->mutex);\n\t\treturn gsel;\n\t}\n\n\tfsel = pinmux_generic_add_function(pctldev, grpname, fngrps, 1,\n\t\t\t\t\t   mux_confs);\n\tif (fsel < 0) {\n\t\tret = fsel;\n\t\tgoto remove_group;\n\t}\n\n\tdev_info(rza1_pctl->dev, \"Parsed function and group %s with %d pins\\n\",\n\t\t\t\t grpname, npins);\n\n\t \n\t*num_maps = 0;\n\t*map = kzalloc(sizeof(**map), GFP_KERNEL);\n\tif (!*map) {\n\t\tret = -ENOMEM;\n\t\tgoto remove_function;\n\t}\n\n\t(*map)->type = PIN_MAP_TYPE_MUX_GROUP;\n\t(*map)->data.mux.group = np->name;\n\t(*map)->data.mux.function = np->name;\n\t*num_maps = 1;\n\tmutex_unlock(&rza1_pctl->mutex);\n\n\treturn 0;\n\nremove_function:\n\tpinmux_generic_remove_function(pctldev, fsel);\n\nremove_group:\n\tpinctrl_generic_remove_group(pctldev, gsel);\n\tmutex_unlock(&rza1_pctl->mutex);\n\n\tdev_info(rza1_pctl->dev, \"Unable to parse function and group %s\\n\",\n\t\t\t\t grpname);\n\n\treturn ret;\n}\n\nstatic void rza1_dt_free_map(struct pinctrl_dev *pctldev,\n\t\t\t     struct pinctrl_map *map, unsigned int num_maps)\n{\n\tkfree(map);\n}\n\nstatic const struct pinctrl_ops rza1_pinctrl_ops = {\n\t.get_groups_count\t= pinctrl_generic_get_group_count,\n\t.get_group_name\t\t= pinctrl_generic_get_group_name,\n\t.get_group_pins\t\t= pinctrl_generic_get_group_pins,\n\t.dt_node_to_map\t\t= rza1_dt_node_to_map,\n\t.dt_free_map\t\t= rza1_dt_free_map,\n};\n\n \n\n \nstatic int rza1_set_mux(struct pinctrl_dev *pctldev, unsigned int selector,\n\t\t\t   unsigned int group)\n{\n\tstruct rza1_pinctrl *rza1_pctl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct rza1_mux_conf *mux_confs;\n\tstruct function_desc *func;\n\tstruct group_desc *grp;\n\tint i;\n\n\tgrp = pinctrl_generic_get_group(pctldev, group);\n\tif (!grp)\n\t\treturn -EINVAL;\n\n\tfunc = pinmux_generic_get_function(pctldev, selector);\n\tif (!func)\n\t\treturn -EINVAL;\n\n\tmux_confs = (struct rza1_mux_conf *)func->data;\n\tfor (i = 0; i < grp->num_pins; ++i) {\n\t\tint ret;\n\n\t\tret = rza1_pin_mux_single(rza1_pctl, &mux_confs[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct pinmux_ops rza1_pinmux_ops = {\n\t.get_functions_count\t= pinmux_generic_get_function_count,\n\t.get_function_name\t= pinmux_generic_get_function_name,\n\t.get_function_groups\t= pinmux_generic_get_function_groups,\n\t.set_mux\t\t= rza1_set_mux,\n\t.strict\t\t\t= true,\n};\n\n \n\n \nstatic int rza1_parse_gpiochip(struct rza1_pinctrl *rza1_pctl,\n\t\t\t       struct fwnode_handle *fwnode,\n\t\t\t       struct gpio_chip *chip,\n\t\t\t       struct pinctrl_gpio_range *range)\n{\n\tconst char *list_name = \"gpio-ranges\";\n\tstruct fwnode_reference_args args;\n\tunsigned int gpioport;\n\tu32 pinctrl_base;\n\tint ret;\n\n\tret = fwnode_property_get_reference_args(fwnode, list_name, NULL, 3, 0, &args);\n\tif (ret) {\n\t\tdev_err(rza1_pctl->dev, \"Unable to parse %s list property\\n\",\n\t\t\tlist_name);\n\t\treturn ret;\n\t}\n\n\t \n\tpinctrl_base = args.args[1];\n\tgpioport = RZA1_PIN_ID_TO_PORT(pinctrl_base);\n\tif (gpioport >= RZA1_NPORTS) {\n\t\tdev_err(rza1_pctl->dev,\n\t\t\t\"Invalid values in property %s\\n\", list_name);\n\t\treturn -EINVAL;\n\t}\n\n\t*chip\t\t= rza1_gpiochip_template;\n\tchip->base\t= -1;\n\tchip->ngpio\t= args.args[2];\n\tchip->label\t= devm_kasprintf(rza1_pctl->dev, GFP_KERNEL, \"%pfwP\", fwnode);\n\tif (!chip->label)\n\t\treturn -ENOMEM;\n\n\tchip->fwnode\t= fwnode;\n\tchip->parent\t= rza1_pctl->dev;\n\n\trange->id\t= gpioport;\n\trange->name\t= chip->label;\n\trange->pin_base\t= range->base = pinctrl_base;\n\trange->npins\t= args.args[2];\n\trange->gc\t= chip;\n\n\tret = devm_gpiochip_add_data(rza1_pctl->dev, chip,\n\t\t\t\t     &rza1_pctl->ports[gpioport]);\n\tif (ret)\n\t\treturn ret;\n\n\tpinctrl_add_gpio_range(rza1_pctl->pctl, range);\n\n\tdev_dbg(rza1_pctl->dev, \"Parsed gpiochip %s with %d pins\\n\",\n\t\tchip->label, chip->ngpio);\n\n\treturn 0;\n}\n\n \nstatic int rza1_gpio_register(struct rza1_pinctrl *rza1_pctl)\n{\n\tstruct pinctrl_gpio_range *gpio_ranges;\n\tstruct gpio_chip *gpio_chips;\n\tstruct fwnode_handle *child;\n\tunsigned int ngpiochips;\n\tunsigned int i;\n\tint ret;\n\n\tngpiochips = gpiochip_node_count(rza1_pctl->dev);\n\tif (ngpiochips == 0) {\n\t\tdev_dbg(rza1_pctl->dev, \"No gpiochip registered\\n\");\n\t\treturn 0;\n\t}\n\n\tgpio_chips = devm_kcalloc(rza1_pctl->dev, ngpiochips,\n\t\t\t\t  sizeof(*gpio_chips), GFP_KERNEL);\n\tgpio_ranges = devm_kcalloc(rza1_pctl->dev, ngpiochips,\n\t\t\t\t   sizeof(*gpio_ranges), GFP_KERNEL);\n\tif (!gpio_chips || !gpio_ranges)\n\t\treturn -ENOMEM;\n\n\ti = 0;\n\tfor_each_gpiochip_node(rza1_pctl->dev, child) {\n\t\tret = rza1_parse_gpiochip(rza1_pctl, child, &gpio_chips[i],\n\t\t\t\t\t  &gpio_ranges[i]);\n\t\tif (ret) {\n\t\t\tfwnode_handle_put(child);\n\t\t\treturn ret;\n\t\t}\n\n\t\t++i;\n\t}\n\n\tdev_info(rza1_pctl->dev, \"Registered %u gpio controllers\\n\", i);\n\n\treturn 0;\n}\n\n \nstatic int rza1_pinctrl_register(struct rza1_pinctrl *rza1_pctl)\n{\n\tstruct pinctrl_pin_desc *pins;\n\tstruct rza1_port *ports;\n\tunsigned int i;\n\tint ret;\n\n\tpins = devm_kcalloc(rza1_pctl->dev, RZA1_NPINS, sizeof(*pins),\n\t\t\t    GFP_KERNEL);\n\tports = devm_kcalloc(rza1_pctl->dev, RZA1_NPORTS, sizeof(*ports),\n\t\t\t     GFP_KERNEL);\n\tif (!pins || !ports)\n\t\treturn -ENOMEM;\n\n\trza1_pctl->pins\t\t= pins;\n\trza1_pctl->desc.pins\t= pins;\n\trza1_pctl->desc.npins\t= RZA1_NPINS;\n\trza1_pctl->ports\t= ports;\n\n\tfor (i = 0; i < RZA1_NPINS; ++i) {\n\t\tunsigned int pin = RZA1_PIN_ID_TO_PIN(i);\n\t\tunsigned int port = RZA1_PIN_ID_TO_PORT(i);\n\n\t\tpins[i].number = i;\n\t\tpins[i].name = devm_kasprintf(rza1_pctl->dev, GFP_KERNEL,\n\t\t\t\t\t      \"P%u-%u\", port, pin);\n\t\tif (!pins[i].name)\n\t\t\treturn -ENOMEM;\n\n\t\tif (i % RZA1_PINS_PER_PORT == 0) {\n\t\t\t \n\t\t\tunsigned int port_id = RZA1_PIN_ID_TO_PORT(i);\n\n\t\t\tports[port_id].id\t= port_id;\n\t\t\tports[port_id].base\t= rza1_pctl->base;\n\t\t\tports[port_id].pins\t= &pins[i];\n\t\t\tspin_lock_init(&ports[port_id].lock);\n\t\t}\n\t}\n\n\tret = devm_pinctrl_register_and_init(rza1_pctl->dev, &rza1_pctl->desc,\n\t\t\t\t\t     rza1_pctl, &rza1_pctl->pctl);\n\tif (ret) {\n\t\tdev_err(rza1_pctl->dev,\n\t\t\t\"RZ/A1 pin controller registration failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = pinctrl_enable(rza1_pctl->pctl);\n\tif (ret) {\n\t\tdev_err(rza1_pctl->dev,\n\t\t\t\"RZ/A1 pin controller failed to start\\n\");\n\t\treturn ret;\n\t}\n\n\tret = rza1_gpio_register(rza1_pctl);\n\tif (ret) {\n\t\tdev_err(rza1_pctl->dev, \"RZ/A1 GPIO registration failed\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int rza1_pinctrl_probe(struct platform_device *pdev)\n{\n\tstruct rza1_pinctrl *rza1_pctl;\n\tint ret;\n\n\trza1_pctl = devm_kzalloc(&pdev->dev, sizeof(*rza1_pctl), GFP_KERNEL);\n\tif (!rza1_pctl)\n\t\treturn -ENOMEM;\n\n\trza1_pctl->dev = &pdev->dev;\n\n\trza1_pctl->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(rza1_pctl->base))\n\t\treturn PTR_ERR(rza1_pctl->base);\n\n\tmutex_init(&rza1_pctl->mutex);\n\n\tplatform_set_drvdata(pdev, rza1_pctl);\n\n\trza1_pctl->desc.name\t= DRIVER_NAME;\n\trza1_pctl->desc.pctlops\t= &rza1_pinctrl_ops;\n\trza1_pctl->desc.pmxops\t= &rza1_pinmux_ops;\n\trza1_pctl->desc.owner\t= THIS_MODULE;\n\trza1_pctl->data\t\t= of_device_get_match_data(&pdev->dev);\n\n\tret = rza1_pinctrl_register(rza1_pctl);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_info(&pdev->dev,\n\t\t \"RZ/A1 pin controller and gpio successfully registered\\n\");\n\n\treturn 0;\n}\n\nstatic const struct of_device_id rza1_pinctrl_of_match[] = {\n\t{\n\t\t \n\t\t.compatible\t= \"renesas,r7s72100-ports\",\n\t\t.data\t\t= &rza1h_pmx_conf,\n\t},\n\t{\n\t\t \n\t\t.compatible\t= \"renesas,r7s72102-ports\",\n\t\t.data\t\t= &rza1l_pmx_conf,\n\t},\n\t{   }\n};\n\nstatic struct platform_driver rza1_pinctrl_driver = {\n\t.driver = {\n\t\t.name = DRIVER_NAME,\n\t\t.of_match_table = rza1_pinctrl_of_match,\n\t},\n\t.probe = rza1_pinctrl_probe,\n};\n\nstatic int __init rza1_pinctrl_init(void)\n{\n\treturn platform_driver_register(&rza1_pinctrl_driver);\n}\ncore_initcall(rza1_pinctrl_init);\n\nMODULE_AUTHOR(\"Jacopo Mondi <jacopo+renesas@jmondi.org\");\nMODULE_DESCRIPTION(\"Pin and gpio controller driver for Reneas RZ/A1 SoC\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}