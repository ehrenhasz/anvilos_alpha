{
  "module_name": "core.c",
  "hash_id": "ab75cb9810d9662f398aae82c9d6a446434b0156ca2cc215917d8c32d406efb3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/renesas/core.c",
  "human_readable_source": "\n \n\n#define DRV_NAME \"sh-pfc\"\n\n#include <linux/bitops.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/kernel.h>\n#include <linux/math.h>\n#include <linux/of.h>\n#include <linux/pinctrl/machine.h>\n#include <linux/platform_device.h>\n#include <linux/psci.h>\n#include <linux/slab.h>\n#include <linux/sys_soc.h>\n\n#include \"core.h\"\n\nstatic int sh_pfc_map_resources(struct sh_pfc *pfc,\n\t\t\t\tstruct platform_device *pdev)\n{\n\tstruct sh_pfc_window *windows;\n\tunsigned int *irqs = NULL;\n\tunsigned int num_windows;\n\tstruct resource *res;\n\tunsigned int i;\n\tint num_irqs;\n\n\t \n\tfor (num_windows = 0;; num_windows++) {\n\t\tres = platform_get_resource(pdev, IORESOURCE_MEM, num_windows);\n\t\tif (!res)\n\t\t\tbreak;\n\t}\n\tif (num_windows == 0)\n\t\treturn -EINVAL;\n\n\tnum_irqs = platform_irq_count(pdev);\n\tif (num_irqs < 0)\n\t\treturn num_irqs;\n\n\t \n\twindows = devm_kcalloc(pfc->dev, num_windows, sizeof(*windows),\n\t\t\t       GFP_KERNEL);\n\tif (windows == NULL)\n\t\treturn -ENOMEM;\n\n\tpfc->num_windows = num_windows;\n\tpfc->windows = windows;\n\n\tif (num_irqs) {\n\t\tirqs = devm_kcalloc(pfc->dev, num_irqs, sizeof(*irqs),\n\t\t\t\t    GFP_KERNEL);\n\t\tif (irqs == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tpfc->num_irqs = num_irqs;\n\t\tpfc->irqs = irqs;\n\t}\n\n\t \n\tfor (i = 0; i < num_windows; i++) {\n\t\twindows->virt = devm_platform_get_and_ioremap_resource(pdev, i, &res);\n\t\tif (IS_ERR(windows->virt))\n\t\t\treturn -ENOMEM;\n\t\twindows->phys = res->start;\n\t\twindows->size = resource_size(res);\n\t\twindows++;\n\t}\n\tfor (i = 0; i < num_irqs; i++)\n\t\t*irqs++ = platform_get_irq(pdev, i);\n\n\treturn 0;\n}\n\nstatic void __iomem *sh_pfc_phys_to_virt(struct sh_pfc *pfc, u32 reg)\n{\n\tstruct sh_pfc_window *window;\n\tphys_addr_t address = reg;\n\tunsigned int i;\n\n\t \n\tfor (i = 0; i < pfc->num_windows; i++) {\n\t\twindow = pfc->windows + i;\n\n\t\tif (address < window->phys)\n\t\t\tcontinue;\n\n\t\tif (address >= (window->phys + window->size))\n\t\t\tcontinue;\n\n\t\treturn window->virt + (address - window->phys);\n\t}\n\n\tBUG();\n\treturn NULL;\n}\n\nint sh_pfc_get_pin_index(struct sh_pfc *pfc, unsigned int pin)\n{\n\tunsigned int offset;\n\tunsigned int i;\n\n\tfor (i = 0, offset = 0; i < pfc->nr_ranges; ++i) {\n\t\tconst struct sh_pfc_pin_range *range = &pfc->ranges[i];\n\n\t\tif (pin <= range->end)\n\t\t\treturn pin >= range->start\n\t\t\t     ? offset + pin - range->start : -1;\n\n\t\toffset += range->end - range->start + 1;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int sh_pfc_enum_in_range(u16 enum_id, const struct pinmux_range *r)\n{\n\tif (enum_id < r->begin)\n\t\treturn 0;\n\n\tif (enum_id > r->end)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nu32 sh_pfc_read_raw_reg(void __iomem *mapped_reg, unsigned int reg_width)\n{\n\tswitch (reg_width) {\n\tcase 8:\n\t\treturn ioread8(mapped_reg);\n\tcase 16:\n\t\treturn ioread16(mapped_reg);\n\tcase 32:\n\t\treturn ioread32(mapped_reg);\n\t}\n\n\tBUG();\n\treturn 0;\n}\n\nvoid sh_pfc_write_raw_reg(void __iomem *mapped_reg, unsigned int reg_width,\n\t\t\t  u32 data)\n{\n\tswitch (reg_width) {\n\tcase 8:\n\t\tiowrite8(data, mapped_reg);\n\t\treturn;\n\tcase 16:\n\t\tiowrite16(data, mapped_reg);\n\t\treturn;\n\tcase 32:\n\t\tiowrite32(data, mapped_reg);\n\t\treturn;\n\t}\n\n\tBUG();\n}\n\nu32 sh_pfc_read(struct sh_pfc *pfc, u32 reg)\n{\n\treturn sh_pfc_read_raw_reg(sh_pfc_phys_to_virt(pfc, reg), 32);\n}\n\nstatic void sh_pfc_unlock_reg(struct sh_pfc *pfc, u32 reg, u32 data)\n{\n\tu32 unlock;\n\n\tif (!pfc->info->unlock_reg)\n\t\treturn;\n\n\tif (pfc->info->unlock_reg >= 0x80000000UL)\n\t\tunlock = pfc->info->unlock_reg;\n\telse\n\t\t \n\t\tunlock = reg & ~pfc->info->unlock_reg;\n\n\tsh_pfc_write_raw_reg(sh_pfc_phys_to_virt(pfc, unlock), 32, ~data);\n}\n\nvoid sh_pfc_write(struct sh_pfc *pfc, u32 reg, u32 data)\n{\n\tsh_pfc_unlock_reg(pfc, reg, data);\n\tsh_pfc_write_raw_reg(sh_pfc_phys_to_virt(pfc, reg), 32, data);\n}\n\nstatic void sh_pfc_config_reg_helper(struct sh_pfc *pfc,\n\t\t\t\t     const struct pinmux_cfg_reg *crp,\n\t\t\t\t     unsigned int in_pos,\n\t\t\t\t     void __iomem **mapped_regp, u32 *maskp,\n\t\t\t\t     unsigned int *posp)\n{\n\tunsigned int k;\n\n\t*mapped_regp = sh_pfc_phys_to_virt(pfc, crp->reg);\n\n\tif (crp->field_width) {\n\t\t*maskp = (1 << crp->field_width) - 1;\n\t\t*posp = crp->reg_width - ((in_pos + 1) * crp->field_width);\n\t} else {\n\t\t*maskp = (1 << crp->var_field_width[in_pos]) - 1;\n\t\t*posp = crp->reg_width;\n\t\tfor (k = 0; k <= in_pos; k++)\n\t\t\t*posp -= abs(crp->var_field_width[k]);\n\t}\n}\n\nstatic void sh_pfc_write_config_reg(struct sh_pfc *pfc,\n\t\t\t\t    const struct pinmux_cfg_reg *crp,\n\t\t\t\t    unsigned int field, u32 value)\n{\n\tvoid __iomem *mapped_reg;\n\tunsigned int pos;\n\tu32 mask, data;\n\n\tsh_pfc_config_reg_helper(pfc, crp, field, &mapped_reg, &mask, &pos);\n\n\tdev_dbg(pfc->dev, \"write_reg addr = %x, value = 0x%x, field = %u, \"\n\t\t\"r_width = %u, f_width = %u\\n\",\n\t\tcrp->reg, value, field, crp->reg_width, hweight32(mask));\n\n\tmask = ~(mask << pos);\n\tvalue = value << pos;\n\n\tdata = sh_pfc_read_raw_reg(mapped_reg, crp->reg_width);\n\tdata &= mask;\n\tdata |= value;\n\n\tsh_pfc_unlock_reg(pfc, crp->reg, data);\n\tsh_pfc_write_raw_reg(mapped_reg, crp->reg_width, data);\n}\n\nstatic int sh_pfc_get_config_reg(struct sh_pfc *pfc, u16 enum_id,\n\t\t\t\t const struct pinmux_cfg_reg **crp,\n\t\t\t\t unsigned int *fieldp, u32 *valuep)\n{\n\tunsigned int k = 0;\n\n\twhile (1) {\n\t\tconst struct pinmux_cfg_reg *config_reg =\n\t\t\tpfc->info->cfg_regs + k;\n\t\tunsigned int r_width = config_reg->reg_width;\n\t\tunsigned int f_width = config_reg->field_width;\n\t\tunsigned int curr_width;\n\t\tunsigned int bit_pos;\n\t\tunsigned int pos = 0;\n\t\tunsigned int m = 0;\n\n\t\tif (!r_width)\n\t\t\tbreak;\n\n\t\tfor (bit_pos = 0; bit_pos < r_width; bit_pos += curr_width, m++) {\n\t\t\tu32 ncomb;\n\t\t\tu32 n;\n\n\t\t\tif (f_width) {\n\t\t\t\tcurr_width = f_width;\n\t\t\t} else {\n\t\t\t\tcurr_width = abs(config_reg->var_field_width[m]);\n\t\t\t\tif (config_reg->var_field_width[m] < 0)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tncomb = 1 << curr_width;\n\t\t\tfor (n = 0; n < ncomb; n++) {\n\t\t\t\tif (config_reg->enum_ids[pos + n] == enum_id) {\n\t\t\t\t\t*crp = config_reg;\n\t\t\t\t\t*fieldp = m;\n\t\t\t\t\t*valuep = n;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpos += ncomb;\n\t\t}\n\t\tk++;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int sh_pfc_mark_to_enum(struct sh_pfc *pfc, u16 mark, int pos,\n\t\t\t      u16 *enum_idp)\n{\n\tconst u16 *data = pfc->info->pinmux_data;\n\tunsigned int k;\n\n\tif (pos) {\n\t\t*enum_idp = data[pos + 1];\n\t\treturn pos + 1;\n\t}\n\n\tfor (k = 0; k < pfc->info->pinmux_data_size; k++) {\n\t\tif (data[k] == mark) {\n\t\t\t*enum_idp = data[k + 1];\n\t\t\treturn k + 1;\n\t\t}\n\t}\n\n\tdev_err(pfc->dev, \"cannot locate data/mark enum_id for mark %d\\n\",\n\t\tmark);\n\treturn -EINVAL;\n}\n\nint sh_pfc_config_mux(struct sh_pfc *pfc, unsigned mark, int pinmux_type)\n{\n\tconst struct pinmux_range *range;\n\tint pos = 0;\n\n\tswitch (pinmux_type) {\n\tcase PINMUX_TYPE_GPIO:\n\tcase PINMUX_TYPE_FUNCTION:\n\t\trange = NULL;\n\t\tbreak;\n\n#ifdef CONFIG_PINCTRL_SH_PFC_GPIO\n\tcase PINMUX_TYPE_OUTPUT:\n\t\trange = &pfc->info->output;\n\t\tbreak;\n\n\tcase PINMUX_TYPE_INPUT:\n\t\trange = &pfc->info->input;\n\t\tbreak;\n#endif  \n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\twhile (1) {\n\t\tconst struct pinmux_cfg_reg *cr;\n\t\tunsigned int field;\n\t\tu16 enum_id;\n\t\tu32 value;\n\t\tint in_range;\n\t\tint ret;\n\n\t\tpos = sh_pfc_mark_to_enum(pfc, mark, pos, &enum_id);\n\t\tif (pos < 0)\n\t\t\treturn pos;\n\n\t\tif (!enum_id)\n\t\t\tbreak;\n\n\t\t \n\t\tin_range = sh_pfc_enum_in_range(enum_id, &pfc->info->function);\n\t\tif (!in_range) {\n\t\t\tif (pinmux_type == PINMUX_TYPE_FUNCTION) {\n\t\t\t\t \n\t\t\t\tin_range = 1;\n\t\t\t} else if (pinmux_type != PINMUX_TYPE_GPIO) {\n\t\t\t\t \n\t\t\t\tin_range = sh_pfc_enum_in_range(enum_id, range);\n\n\t\t\t\t \n\t\t\t\tif (in_range && enum_id == range->force)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t \n\t\t}\n\n\t\tif (!in_range)\n\t\t\tcontinue;\n\n\t\tret = sh_pfc_get_config_reg(pfc, enum_id, &cr, &field, &value);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tsh_pfc_write_config_reg(pfc, cr, field, value);\n\t}\n\n\treturn 0;\n}\n\nstatic int sh_pfc_init_ranges(struct sh_pfc *pfc)\n{\n\tstruct sh_pfc_pin_range *range;\n\tunsigned int nr_ranges;\n\tunsigned int i;\n\n\tif (pfc->info->pins[0].pin == (u16)-1) {\n\t\t \n\t\tpfc->nr_ranges = 1;\n\t\tpfc->ranges = devm_kzalloc(pfc->dev, sizeof(*pfc->ranges),\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (pfc->ranges == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tpfc->ranges->start = 0;\n\t\tpfc->ranges->end = pfc->info->nr_pins - 1;\n\t\tpfc->nr_gpio_pins = pfc->info->nr_pins;\n\n\t\treturn 0;\n\t}\n\n\t \n\tfor (i = 1, nr_ranges = 1; i < pfc->info->nr_pins; ++i) {\n\t\tif (pfc->info->pins[i-1].pin != pfc->info->pins[i].pin - 1)\n\t\t\tnr_ranges++;\n\t}\n\n\tpfc->nr_ranges = nr_ranges;\n\tpfc->ranges = devm_kcalloc(pfc->dev, nr_ranges, sizeof(*pfc->ranges),\n\t\t\t\t   GFP_KERNEL);\n\tif (pfc->ranges == NULL)\n\t\treturn -ENOMEM;\n\n\trange = pfc->ranges;\n\trange->start = pfc->info->pins[0].pin;\n\n\tfor (i = 1; i < pfc->info->nr_pins; ++i) {\n\t\tif (pfc->info->pins[i-1].pin == pfc->info->pins[i].pin - 1)\n\t\t\tcontinue;\n\n\t\trange->end = pfc->info->pins[i-1].pin;\n\t\tif (!(pfc->info->pins[i-1].configs & SH_PFC_PIN_CFG_NO_GPIO))\n\t\t\tpfc->nr_gpio_pins = range->end + 1;\n\n\t\trange++;\n\t\trange->start = pfc->info->pins[i].pin;\n\t}\n\n\trange->end = pfc->info->pins[i-1].pin;\n\tif (!(pfc->info->pins[i-1].configs & SH_PFC_PIN_CFG_NO_GPIO))\n\t\tpfc->nr_gpio_pins = range->end + 1;\n\n\treturn 0;\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id sh_pfc_of_table[] = {\n#ifdef CONFIG_PINCTRL_PFC_EMEV2\n\t{\n\t\t.compatible = \"renesas,pfc-emev2\",\n\t\t.data = &emev2_pinmux_info,\n\t},\n#endif\n#ifdef CONFIG_PINCTRL_PFC_R8A73A4\n\t{\n\t\t.compatible = \"renesas,pfc-r8a73a4\",\n\t\t.data = &r8a73a4_pinmux_info,\n\t},\n#endif\n#ifdef CONFIG_PINCTRL_PFC_R8A7740\n\t{\n\t\t.compatible = \"renesas,pfc-r8a7740\",\n\t\t.data = &r8a7740_pinmux_info,\n\t},\n#endif\n#ifdef CONFIG_PINCTRL_PFC_R8A7742\n\t{\n\t\t.compatible = \"renesas,pfc-r8a7742\",\n\t\t.data = &r8a7742_pinmux_info,\n\t},\n#endif\n#ifdef CONFIG_PINCTRL_PFC_R8A7743\n\t{\n\t\t.compatible = \"renesas,pfc-r8a7743\",\n\t\t.data = &r8a7743_pinmux_info,\n\t},\n#endif\n#ifdef CONFIG_PINCTRL_PFC_R8A7744\n\t{\n\t\t.compatible = \"renesas,pfc-r8a7744\",\n\t\t.data = &r8a7744_pinmux_info,\n\t},\n#endif\n#ifdef CONFIG_PINCTRL_PFC_R8A7745\n\t{\n\t\t.compatible = \"renesas,pfc-r8a7745\",\n\t\t.data = &r8a7745_pinmux_info,\n\t},\n#endif\n#ifdef CONFIG_PINCTRL_PFC_R8A77470\n\t{\n\t\t.compatible = \"renesas,pfc-r8a77470\",\n\t\t.data = &r8a77470_pinmux_info,\n\t},\n#endif\n#ifdef CONFIG_PINCTRL_PFC_R8A774A1\n\t{\n\t\t.compatible = \"renesas,pfc-r8a774a1\",\n\t\t.data = &r8a774a1_pinmux_info,\n\t},\n#endif\n#ifdef CONFIG_PINCTRL_PFC_R8A774B1\n\t{\n\t\t.compatible = \"renesas,pfc-r8a774b1\",\n\t\t.data = &r8a774b1_pinmux_info,\n\t},\n#endif\n#ifdef CONFIG_PINCTRL_PFC_R8A774C0\n\t{\n\t\t.compatible = \"renesas,pfc-r8a774c0\",\n\t\t.data = &r8a774c0_pinmux_info,\n\t},\n#endif\n#ifdef CONFIG_PINCTRL_PFC_R8A774E1\n\t{\n\t\t.compatible = \"renesas,pfc-r8a774e1\",\n\t\t.data = &r8a774e1_pinmux_info,\n\t},\n#endif\n#ifdef CONFIG_PINCTRL_PFC_R8A7778\n\t{\n\t\t.compatible = \"renesas,pfc-r8a7778\",\n\t\t.data = &r8a7778_pinmux_info,\n\t},\n#endif\n#ifdef CONFIG_PINCTRL_PFC_R8A7779\n\t{\n\t\t.compatible = \"renesas,pfc-r8a7779\",\n\t\t.data = &r8a7779_pinmux_info,\n\t},\n#endif\n#ifdef CONFIG_PINCTRL_PFC_R8A7790\n\t{\n\t\t.compatible = \"renesas,pfc-r8a7790\",\n\t\t.data = &r8a7790_pinmux_info,\n\t},\n#endif\n#ifdef CONFIG_PINCTRL_PFC_R8A7791\n\t{\n\t\t.compatible = \"renesas,pfc-r8a7791\",\n\t\t.data = &r8a7791_pinmux_info,\n\t},\n#endif\n#ifdef CONFIG_PINCTRL_PFC_R8A7792\n\t{\n\t\t.compatible = \"renesas,pfc-r8a7792\",\n\t\t.data = &r8a7792_pinmux_info,\n\t},\n#endif\n#ifdef CONFIG_PINCTRL_PFC_R8A7793\n\t{\n\t\t.compatible = \"renesas,pfc-r8a7793\",\n\t\t.data = &r8a7793_pinmux_info,\n\t},\n#endif\n#ifdef CONFIG_PINCTRL_PFC_R8A7794\n\t{\n\t\t.compatible = \"renesas,pfc-r8a7794\",\n\t\t.data = &r8a7794_pinmux_info,\n\t},\n#endif\n#ifdef CONFIG_PINCTRL_PFC_R8A77951\n\t{\n\t\t.compatible = \"renesas,pfc-r8a7795\",\n\t\t.data = &r8a77951_pinmux_info,\n\t},\n#endif\n#ifdef CONFIG_PINCTRL_PFC_R8A77960\n\t{\n\t\t.compatible = \"renesas,pfc-r8a7796\",\n\t\t.data = &r8a77960_pinmux_info,\n\t},\n#endif\n#ifdef CONFIG_PINCTRL_PFC_R8A77961\n\t{\n\t\t.compatible = \"renesas,pfc-r8a77961\",\n\t\t.data = &r8a77961_pinmux_info,\n\t},\n#endif\n#ifdef CONFIG_PINCTRL_PFC_R8A77965\n\t{\n\t\t.compatible = \"renesas,pfc-r8a77965\",\n\t\t.data = &r8a77965_pinmux_info,\n\t},\n#endif\n#ifdef CONFIG_PINCTRL_PFC_R8A77970\n\t{\n\t\t.compatible = \"renesas,pfc-r8a77970\",\n\t\t.data = &r8a77970_pinmux_info,\n\t},\n#endif\n#ifdef CONFIG_PINCTRL_PFC_R8A77980\n\t{\n\t\t.compatible = \"renesas,pfc-r8a77980\",\n\t\t.data = &r8a77980_pinmux_info,\n\t},\n#endif\n#ifdef CONFIG_PINCTRL_PFC_R8A77990\n\t{\n\t\t.compatible = \"renesas,pfc-r8a77990\",\n\t\t.data = &r8a77990_pinmux_info,\n\t},\n#endif\n#ifdef CONFIG_PINCTRL_PFC_R8A77995\n\t{\n\t\t.compatible = \"renesas,pfc-r8a77995\",\n\t\t.data = &r8a77995_pinmux_info,\n\t},\n#endif\n#ifdef CONFIG_PINCTRL_PFC_R8A779A0\n\t{\n\t\t.compatible = \"renesas,pfc-r8a779a0\",\n\t\t.data = &r8a779a0_pinmux_info,\n\t},\n#endif\n#ifdef CONFIG_PINCTRL_PFC_R8A779F0\n\t{\n\t\t.compatible = \"renesas,pfc-r8a779f0\",\n\t\t.data = &r8a779f0_pinmux_info,\n\t},\n#endif\n#ifdef CONFIG_PINCTRL_PFC_R8A779G0\n\t{\n\t\t.compatible = \"renesas,pfc-r8a779g0\",\n\t\t.data = &r8a779g0_pinmux_info,\n\t},\n#endif\n#ifdef CONFIG_PINCTRL_PFC_SH73A0\n\t{\n\t\t.compatible = \"renesas,pfc-sh73a0\",\n\t\t.data = &sh73a0_pinmux_info,\n\t},\n#endif\n\t{   }\n};\n#endif\n\n#if defined(CONFIG_ARM_PSCI_FW)\nstatic void sh_pfc_nop_reg(struct sh_pfc *pfc, u32 reg, unsigned int idx)\n{\n}\n\nstatic void sh_pfc_save_reg(struct sh_pfc *pfc, u32 reg, unsigned int idx)\n{\n\tpfc->saved_regs[idx] = sh_pfc_read(pfc, reg);\n}\n\nstatic void sh_pfc_restore_reg(struct sh_pfc *pfc, u32 reg, unsigned int idx)\n{\n\tsh_pfc_write(pfc, reg, pfc->saved_regs[idx]);\n}\n\nstatic unsigned int sh_pfc_walk_regs(struct sh_pfc *pfc,\n\tvoid (*do_reg)(struct sh_pfc *pfc, u32 reg, unsigned int idx))\n{\n\tunsigned int i, n = 0;\n\n\tif (pfc->info->cfg_regs)\n\t\tfor (i = 0; pfc->info->cfg_regs[i].reg; i++)\n\t\t\tdo_reg(pfc, pfc->info->cfg_regs[i].reg, n++);\n\n\tif (pfc->info->drive_regs)\n\t\tfor (i = 0; pfc->info->drive_regs[i].reg; i++)\n\t\t\tdo_reg(pfc, pfc->info->drive_regs[i].reg, n++);\n\n\tif (pfc->info->bias_regs)\n\t\tfor (i = 0; pfc->info->bias_regs[i].puen ||\n\t\t\t    pfc->info->bias_regs[i].pud; i++) {\n\t\t\tif (pfc->info->bias_regs[i].puen)\n\t\t\t\tdo_reg(pfc, pfc->info->bias_regs[i].puen, n++);\n\t\t\tif (pfc->info->bias_regs[i].pud)\n\t\t\t\tdo_reg(pfc, pfc->info->bias_regs[i].pud, n++);\n\t\t}\n\n\tif (pfc->info->ioctrl_regs)\n\t\tfor (i = 0; pfc->info->ioctrl_regs[i].reg; i++)\n\t\t\tdo_reg(pfc, pfc->info->ioctrl_regs[i].reg, n++);\n\n\treturn n;\n}\n\nstatic int sh_pfc_suspend_init(struct sh_pfc *pfc)\n{\n\tunsigned int n;\n\n\t \n\tif (!psci_ops.cpu_suspend)\n\t\treturn 0;\n\n\tn = sh_pfc_walk_regs(pfc, sh_pfc_nop_reg);\n\tif (!n)\n\t\treturn 0;\n\n\tpfc->saved_regs = devm_kmalloc_array(pfc->dev, n,\n\t\t\t\t\t     sizeof(*pfc->saved_regs),\n\t\t\t\t\t     GFP_KERNEL);\n\tif (!pfc->saved_regs)\n\t\treturn -ENOMEM;\n\n\tdev_dbg(pfc->dev, \"Allocated space to save %u regs\\n\", n);\n\treturn 0;\n}\n\nstatic int sh_pfc_suspend_noirq(struct device *dev)\n{\n\tstruct sh_pfc *pfc = dev_get_drvdata(dev);\n\n\tif (pfc->saved_regs)\n\t\tsh_pfc_walk_regs(pfc, sh_pfc_save_reg);\n\treturn 0;\n}\n\nstatic int sh_pfc_resume_noirq(struct device *dev)\n{\n\tstruct sh_pfc *pfc = dev_get_drvdata(dev);\n\n\tif (pfc->saved_regs)\n\t\tsh_pfc_walk_regs(pfc, sh_pfc_restore_reg);\n\treturn 0;\n}\n#else\nstatic int sh_pfc_suspend_init(struct sh_pfc *pfc) { return 0; }\nstatic int sh_pfc_suspend_noirq(struct device *dev) { return 0; }\nstatic int sh_pfc_resume_noirq(struct device *dev) { return 0; }\n#endif\t \n\nstatic DEFINE_NOIRQ_DEV_PM_OPS(sh_pfc_pm, sh_pfc_suspend_noirq, sh_pfc_resume_noirq);\n\n#ifdef DEBUG\n#define SH_PFC_MAX_REGS\t\t300\n#define SH_PFC_MAX_ENUMS\t5000\n\nstatic unsigned int sh_pfc_errors __initdata;\nstatic unsigned int sh_pfc_warnings __initdata;\nstatic bool sh_pfc_bias_done __initdata;\nstatic bool sh_pfc_drive_done __initdata;\nstatic bool sh_pfc_power_done __initdata;\nstatic struct {\n\tu32 reg;\n\tu32 bits;\n} *sh_pfc_regs __initdata;\nstatic u32 sh_pfc_num_regs __initdata;\nstatic u16 *sh_pfc_enums __initdata;\nstatic u32 sh_pfc_num_enums __initdata;\n\n#define sh_pfc_err(fmt, ...)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tpr_err(\"%s: \" fmt, drvname, ##__VA_ARGS__);\t\\\n\t\tsh_pfc_errors++;\t\t\t\t\\\n\t} while (0)\n\n#define sh_pfc_err_once(type, fmt, ...)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tif (!sh_pfc_ ## type ## _done) {\t\t\\\n\t\t\tsh_pfc_ ## type ## _done = true;\t\\\n\t\t\tsh_pfc_err(fmt, ##__VA_ARGS__);\t\t\\\n\t\t}\t\t\t\t\t\t\\\n\t} while (0)\n\n#define sh_pfc_warn(fmt, ...)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tpr_warn(\"%s: \" fmt, drvname, ##__VA_ARGS__);\t\\\n\t\tsh_pfc_warnings++;\t\t\t\t\\\n\t} while (0)\n\nstatic bool __init is0s(const u16 *enum_ids, unsigned int n)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < n; i++)\n\t\tif (enum_ids[i])\n\t\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool __init same_name(const char *a, const char *b)\n{\n\treturn a && b && !strcmp(a, b);\n}\n\nstatic void __init sh_pfc_check_reg(const char *drvname, u32 reg, u32 bits)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < sh_pfc_num_regs; i++) {\n\t\tif (reg != sh_pfc_regs[i].reg)\n\t\t\tcontinue;\n\n\t\tif (bits & sh_pfc_regs[i].bits)\n\t\t\tsh_pfc_err(\"reg 0x%x: bits 0x%x conflict\\n\", reg,\n\t\t\t\t   bits & sh_pfc_regs[i].bits);\n\n\t\tsh_pfc_regs[i].bits |= bits;\n\t\treturn;\n\t}\n\n\tif (sh_pfc_num_regs == SH_PFC_MAX_REGS) {\n\t\tpr_warn_once(\"%s: Please increase SH_PFC_MAX_REGS\\n\", drvname);\n\t\treturn;\n\t}\n\n\tsh_pfc_regs[sh_pfc_num_regs].reg = reg;\n\tsh_pfc_regs[sh_pfc_num_regs].bits = bits;\n\tsh_pfc_num_regs++;\n}\n\nstatic int __init sh_pfc_check_enum(const char *drvname, u16 enum_id)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < sh_pfc_num_enums; i++) {\n\t\tif (enum_id == sh_pfc_enums[i])\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (sh_pfc_num_enums == SH_PFC_MAX_ENUMS) {\n\t\tpr_warn_once(\"%s: Please increase SH_PFC_MAX_ENUMS\\n\", drvname);\n\t\treturn 0;\n\t}\n\n\tsh_pfc_enums[sh_pfc_num_enums++] = enum_id;\n\treturn 0;\n}\n\nstatic void __init sh_pfc_check_reg_enums(const char *drvname, u32 reg,\n\t\t\t\t\t  const u16 *enums, unsigned int n)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (enums[i] && sh_pfc_check_enum(drvname, enums[i]))\n\t\t\tsh_pfc_err(\"reg 0x%x enum_id %u conflict\\n\", reg,\n\t\t\t\t   enums[i]);\n\t}\n}\n\nstatic const struct sh_pfc_pin __init *sh_pfc_find_pin(\n\tconst struct sh_pfc_soc_info *info, u32 reg, unsigned int pin)\n{\n\tconst char *drvname = info->name;\n\tunsigned int i;\n\n\tif (pin == SH_PFC_PIN_NONE)\n\t\treturn NULL;\n\n\tfor (i = 0; i < info->nr_pins; i++) {\n\t\tif (pin == info->pins[i].pin)\n\t\t\treturn &info->pins[i];\n\t}\n\n\tsh_pfc_err(\"reg 0x%x: pin %u not found\\n\", reg, pin);\n\treturn NULL;\n}\n\nstatic void __init sh_pfc_check_cfg_reg(const char *drvname,\n\t\t\t\t\tconst struct pinmux_cfg_reg *cfg_reg)\n{\n\tunsigned int i, n, rw, r;\n\tint fw;\n\n\tsh_pfc_check_reg(drvname, cfg_reg->reg,\n\t\t\t GENMASK(cfg_reg->reg_width - 1, 0));\n\n\tif (cfg_reg->field_width) {\n\t\tfw = cfg_reg->field_width;\n\t\tn = (cfg_reg->reg_width / fw) << fw;\n\t\tfor (i = 0, r = 0; i < n; i += 1 << fw) {\n\t\t\tif (is0s(&cfg_reg->enum_ids[i], 1 << fw))\n\t\t\t\tr++;\n\t\t}\n\n\t\tif ((r << fw) * sizeof(u16) > cfg_reg->reg_width / fw)\n\t\t\tsh_pfc_warn(\"reg 0x%x can be described with variable-width reserved fields\\n\",\n\t\t\t\t    cfg_reg->reg);\n\n\t\t \n\t\tgoto check_enum_ids;\n\t}\n\n\tfor (i = 0, n = 0, rw = 0; (fw = cfg_reg->var_field_width[i]); i++) {\n\t\tif (fw < 0) {\n\t\t\trw += -fw;\n\t\t} else {\n\t\t\tif (is0s(&cfg_reg->enum_ids[n], 1 << fw))\n\t\t\t\tsh_pfc_warn(\"reg 0x%x: field [%u:%u] can be described as reserved\\n\",\n\t\t\t\t\t    cfg_reg->reg, rw, rw + fw - 1);\n\t\t\tn += 1 << fw;\n\t\t\trw += fw;\n\t\t}\n\t}\n\n\tif (rw != cfg_reg->reg_width)\n\t\tsh_pfc_err(\"reg 0x%x: var_field_width declares %u instead of %u bits\\n\",\n\t\t\t   cfg_reg->reg, rw, cfg_reg->reg_width);\n\n\tif (n != cfg_reg->nr_enum_ids)\n\t\tsh_pfc_err(\"reg 0x%x: enum_ids[] has %u instead of %u values\\n\",\n\t\t\t   cfg_reg->reg, cfg_reg->nr_enum_ids, n);\n\ncheck_enum_ids:\n\tsh_pfc_check_reg_enums(drvname, cfg_reg->reg, cfg_reg->enum_ids, n);\n}\n\nstatic void __init sh_pfc_check_drive_reg(const struct sh_pfc_soc_info *info,\n\t\t\t\t\t  const struct pinmux_drive_reg *drive)\n{\n\tconst char *drvname = info->name;\n\tconst struct sh_pfc_pin *pin;\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(drive->fields); i++) {\n\t\tconst struct pinmux_drive_reg_field *field = &drive->fields[i];\n\n\t\tif (!field->pin && !field->offset && !field->size)\n\t\t\tcontinue;\n\n\t\tsh_pfc_check_reg(info->name, drive->reg,\n\t\t\t\t GENMASK(field->offset + field->size - 1,\n\t\t\t\t\t field->offset));\n\n\t\tpin = sh_pfc_find_pin(info, drive->reg, field->pin);\n\t\tif (pin && !(pin->configs & SH_PFC_PIN_CFG_DRIVE_STRENGTH))\n\t\t\tsh_pfc_err(\"drive_reg 0x%x: field %u: pin %s lacks SH_PFC_PIN_CFG_DRIVE_STRENGTH flag\\n\",\n\t\t\t\t   drive->reg, i, pin->name);\n\t}\n}\n\nstatic void __init sh_pfc_check_bias_reg(const struct sh_pfc_soc_info *info,\n\t\t\t\t\t const struct pinmux_bias_reg *bias)\n{\n\tconst char *drvname = info->name;\n\tconst struct sh_pfc_pin *pin;\n\tunsigned int i;\n\tu32 bits;\n\n\tfor (i = 0, bits = 0; i < ARRAY_SIZE(bias->pins); i++)\n\t\tif (bias->pins[i] != SH_PFC_PIN_NONE)\n\t\t\tbits |= BIT(i);\n\n\tif (bias->puen)\n\t\tsh_pfc_check_reg(info->name, bias->puen, bits);\n\tif (bias->pud)\n\t\tsh_pfc_check_reg(info->name, bias->pud, bits);\n\tfor (i = 0; i < ARRAY_SIZE(bias->pins); i++) {\n\t\tpin = sh_pfc_find_pin(info, bias->puen, bias->pins[i]);\n\t\tif (!pin)\n\t\t\tcontinue;\n\n\t\tif (bias->puen && bias->pud) {\n\t\t\t \n\t\t\tif (!(pin->configs & SH_PFC_PIN_CFG_PULL_UP_DOWN))\n\t\t\t\tsh_pfc_err(\"bias_reg 0x%x:%u: pin %s lacks one or more SH_PFC_PIN_CFG_PULL_* flags\\n\",\n\t\t\t\t\t   bias->puen, i, pin->name);\n\t\t} else if (bias->puen) {\n\t\t\t \n\t\t\tif (!(pin->configs & SH_PFC_PIN_CFG_PULL_UP))\n\t\t\t\tsh_pfc_err(\"bias_reg 0x%x:%u: pin %s lacks SH_PFC_PIN_CFG_PULL_UP flag\\n\",\n\t\t\t\t\t   bias->puen, i, pin->name);\n\t\t} else if (bias->pud) {\n\t\t\t \n\t\t\tif (!(pin->configs & SH_PFC_PIN_CFG_PULL_DOWN))\n\t\t\t\tsh_pfc_err(\"bias_reg 0x%x:%u: pin %s lacks SH_PFC_PIN_CFG_PULL_DOWN flag\\n\",\n\t\t\t\t\t   bias->pud, i, pin->name);\n\t\t}\n\t}\n}\n\nstatic void __init sh_pfc_compare_groups(const char *drvname,\n\t\t\t\t\t const struct sh_pfc_pin_group *a,\n\t\t\t\t\t const struct sh_pfc_pin_group *b)\n{\n\tunsigned int i;\n\tsize_t len;\n\n\tif (same_name(a->name, b->name))\n\t\tsh_pfc_err(\"group %s: name conflict\\n\", a->name);\n\n\tif (a->nr_pins > b->nr_pins)\n\t\tswap(a, b);\n\n\tlen = a->nr_pins * sizeof(a->pins[0]);\n\tfor (i = 0; i <= b->nr_pins - a->nr_pins; i++) {\n\t\tif (a->pins == b->pins + i || a->mux == b->mux + i ||\n\t\t    memcmp(a->pins, b->pins + i, len) ||\n\t\t    memcmp(a->mux, b->mux + i, len))\n\t\t\tcontinue;\n\n\t\tif (a->nr_pins == b->nr_pins)\n\t\t\tsh_pfc_warn(\"group %s can be an alias for %s\\n\",\n\t\t\t\t    a->name, b->name);\n\t\telse\n\t\t\tsh_pfc_warn(\"group %s is a subset of %s\\n\", a->name,\n\t\t\t\t    b->name);\n\t}\n}\n\nstatic void __init sh_pfc_check_info(const struct sh_pfc_soc_info *info)\n{\n\tconst struct pinmux_drive_reg *drive_regs = info->drive_regs;\n#define drive_nfields\tARRAY_SIZE(drive_regs->fields)\n#define drive_ofs(i)\tdrive_regs[(i) / drive_nfields]\n#define drive_reg(i)\tdrive_ofs(i).reg\n#define drive_bit(i)\t((i) % drive_nfields)\n#define drive_field(i)\tdrive_ofs(i).fields[drive_bit(i)]\n\tconst struct pinmux_bias_reg *bias_regs = info->bias_regs;\n#define bias_npins\tARRAY_SIZE(bias_regs->pins)\n#define bias_ofs(i)\tbias_regs[(i) / bias_npins]\n#define bias_puen(i)\tbias_ofs(i).puen\n#define bias_pud(i)\tbias_ofs(i).pud\n#define bias_bit(i)\t((i) % bias_npins)\n#define bias_pin(i)\tbias_ofs(i).pins[bias_bit(i)]\n\tconst char *drvname = info->name;\n\tunsigned int *refcnts;\n\tunsigned int i, j, k;\n\n\tpr_info(\"sh_pfc: Checking %s\\n\", drvname);\n\tsh_pfc_num_regs = 0;\n\tsh_pfc_num_enums = 0;\n\tsh_pfc_bias_done = false;\n\tsh_pfc_drive_done = false;\n\tsh_pfc_power_done = false;\n\n\t \n\tfor (i = 0; i < info->nr_pins; i++) {\n\t\tconst struct sh_pfc_pin *pin = &info->pins[i];\n\t\tunsigned int x;\n\n\t\tif (!pin->name) {\n\t\t\tsh_pfc_err(\"empty pin %u\\n\", i);\n\t\t\tcontinue;\n\t\t}\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tconst struct sh_pfc_pin *pin2 = &info->pins[j];\n\n\t\t\tif (same_name(pin->name, pin2->name))\n\t\t\t\tsh_pfc_err(\"pin %s: name conflict\\n\",\n\t\t\t\t\t   pin->name);\n\n\t\t\tif (pin->pin != (u16)-1 && pin->pin == pin2->pin)\n\t\t\t\tsh_pfc_err(\"pin %s/%s: pin %u conflict\\n\",\n\t\t\t\t\t   pin->name, pin2->name, pin->pin);\n\n\t\t\tif (pin->enum_id && pin->enum_id == pin2->enum_id)\n\t\t\t\tsh_pfc_err(\"pin %s/%s: enum_id %u conflict\\n\",\n\t\t\t\t\t   pin->name, pin2->name,\n\t\t\t\t\t   pin->enum_id);\n\t\t}\n\n\t\tif (pin->configs & SH_PFC_PIN_CFG_PULL_UP_DOWN) {\n\t\t\tif (!info->ops || !info->ops->get_bias ||\n\t\t\t    !info->ops->set_bias)\n\t\t\t\tsh_pfc_err_once(bias, \"SH_PFC_PIN_CFG_PULL_* flag set but .[gs]et_bias() not implemented\\n\");\n\n\t\t\tif (!bias_regs &&\n\t\t\t     (!info->ops || !info->ops->pin_to_portcr))\n\t\t\t\tsh_pfc_err_once(bias, \"SH_PFC_PIN_CFG_PULL_UP flag set but no bias_regs defined and .pin_to_portcr() not implemented\\n\");\n\t\t}\n\n\t\tif ((pin->configs & SH_PFC_PIN_CFG_PULL_UP_DOWN) && bias_regs) {\n\t\t\tconst struct pinmux_bias_reg *bias_reg =\n\t\t\t\trcar_pin_to_bias_reg(info, pin->pin, &x);\n\n\t\t\tif (!bias_reg ||\n\t\t\t    ((pin->configs & SH_PFC_PIN_CFG_PULL_UP) &&\n\t\t\t     !bias_reg->puen))\n\t\t\t\tsh_pfc_err(\"pin %s: SH_PFC_PIN_CFG_PULL_UP flag set but pin not in bias_regs\\n\",\n\t\t\t\t\t   pin->name);\n\n\t\t\tif (!bias_reg ||\n\t\t\t    ((pin->configs & SH_PFC_PIN_CFG_PULL_DOWN) &&\n\t\t\t     !bias_reg->pud))\n\t\t\t\tsh_pfc_err(\"pin %s: SH_PFC_PIN_CFG_PULL_DOWN flag set but pin not in bias_regs\\n\",\n\t\t\t\t\t   pin->name);\n\t\t}\n\n\t\tif (pin->configs & SH_PFC_PIN_CFG_DRIVE_STRENGTH) {\n\t\t\tif (!drive_regs) {\n\t\t\t\tsh_pfc_err_once(drive, \"SH_PFC_PIN_CFG_DRIVE_STRENGTH flag set but drive_regs missing\\n\");\n\t\t\t} else {\n\t\t\t\tfor (j = 0; drive_reg(j); j++) {\n\t\t\t\t\tif (!drive_field(j).pin &&\n\t\t\t\t\t    !drive_field(j).offset &&\n\t\t\t\t\t    !drive_field(j).size)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (drive_field(j).pin == pin->pin)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (!drive_reg(j))\n\t\t\t\t\tsh_pfc_err(\"pin %s: SH_PFC_PIN_CFG_DRIVE_STRENGTH flag set but not in drive_regs\\n\",\n\t\t\t\t\t\t   pin->name);\n\t\t\t}\n\t\t}\n\n\t\tif (pin->configs & SH_PFC_PIN_CFG_IO_VOLTAGE_MASK) {\n\t\t\tif (!info->ops || !info->ops->pin_to_pocctrl)\n\t\t\t\tsh_pfc_err_once(power, \"SH_PFC_PIN_CFG_IO_VOLTAGE set but .pin_to_pocctrl() not implemented\\n\");\n\t\t\telse if (info->ops->pin_to_pocctrl(pin->pin, &x) < 0)\n\t\t\t\tsh_pfc_err(\"pin %s: SH_PFC_PIN_CFG_IO_VOLTAGE set but invalid pin_to_pocctrl()\\n\",\n\t\t\t\t\t   pin->name);\n\t\t} else if (info->ops && info->ops->pin_to_pocctrl &&\n\t\t\t   info->ops->pin_to_pocctrl(pin->pin, &x) >= 0) {\n\t\t\tsh_pfc_warn(\"pin %s: SH_PFC_PIN_CFG_IO_VOLTAGE not set but valid pin_to_pocctrl()\\n\",\n\t\t\t\t    pin->name);\n\t\t}\n\t}\n\n\t \n\trefcnts = kcalloc(info->nr_groups, sizeof(*refcnts), GFP_KERNEL);\n\tif (!refcnts)\n\t\treturn;\n\n\tfor (i = 0; i < info->nr_functions; i++) {\n\t\tconst struct sh_pfc_function *func = &info->functions[i];\n\n\t\tif (!func->name) {\n\t\t\tsh_pfc_err(\"empty function %u\\n\", i);\n\t\t\tcontinue;\n\t\t}\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tif (same_name(func->name, info->functions[j].name))\n\t\t\t\tsh_pfc_err(\"function %s: name conflict\\n\",\n\t\t\t\t\t   func->name);\n\t\t}\n\t\tfor (j = 0; j < func->nr_groups; j++) {\n\t\t\tfor (k = 0; k < info->nr_groups; k++) {\n\t\t\t\tif (same_name(func->groups[j],\n\t\t\t\t\t      info->groups[k].name)) {\n\t\t\t\t\trefcnts[k]++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (k == info->nr_groups)\n\t\t\t\tsh_pfc_err(\"function %s: group %s not found\\n\",\n\t\t\t\t\t   func->name, func->groups[j]);\n\t\t}\n\t}\n\n\tfor (i = 0; i < info->nr_groups; i++) {\n\t\tconst struct sh_pfc_pin_group *group = &info->groups[i];\n\n\t\tif (!group->name) {\n\t\t\tsh_pfc_err(\"empty group %u\\n\", i);\n\t\t\tcontinue;\n\t\t}\n\t\tfor (j = 0; j < i; j++)\n\t\t\tsh_pfc_compare_groups(drvname, group, &info->groups[j]);\n\n\t\tif (!refcnts[i])\n\t\t\tsh_pfc_err(\"orphan group %s\\n\", group->name);\n\t\telse if (refcnts[i] > 1)\n\t\t\tsh_pfc_warn(\"group %s referenced by %u functions\\n\",\n\t\t\t\t    group->name, refcnts[i]);\n\t}\n\n\tkfree(refcnts);\n\n\t \n\tfor (i = 0; info->cfg_regs && info->cfg_regs[i].reg; i++)\n\t\tsh_pfc_check_cfg_reg(drvname, &info->cfg_regs[i]);\n\n\t \n\tfor (i = 0; drive_regs && drive_regs[i].reg; i++)\n\t\tsh_pfc_check_drive_reg(info, &drive_regs[i]);\n\n\tfor (i = 0; drive_regs && drive_reg(i); i++) {\n\t\tif (!drive_field(i).pin && !drive_field(i).offset &&\n\t\t    !drive_field(i).size)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tif (drive_field(i).pin == drive_field(j).pin &&\n\t\t\t    drive_field(j).offset && drive_field(j).size) {\n\t\t\t\tsh_pfc_err(\"drive_reg 0x%x:%zu/0x%x:%zu: pin conflict\\n\",\n\t\t\t\t\t   drive_reg(i), drive_bit(i),\n\t\t\t\t\t   drive_reg(j), drive_bit(j));\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; bias_regs && (bias_regs[i].puen || bias_regs[i].pud); i++)\n\t\tsh_pfc_check_bias_reg(info, &bias_regs[i]);\n\n\tfor (i = 0; bias_regs && (bias_puen(i) || bias_pud(i)); i++) {\n\t\tif (bias_pin(i) == SH_PFC_PIN_NONE)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tif (bias_pin(i) != bias_pin(j))\n\t\t\t\tcontinue;\n\n\t\t\tif (bias_puen(i) && bias_puen(j))\n\t\t\t\tsh_pfc_err(\"bias_reg 0x%x:%zu/0x%x:%zu: pin conflict\\n\",\n\t\t\t\t\t   bias_puen(i), bias_bit(i),\n\t\t\t\t\t   bias_puen(j), bias_bit(j));\n\t\t\tif (bias_pud(i) && bias_pud(j))\n\t\t\t\tsh_pfc_err(\"bias_reg 0x%x:%zu/0x%x:%zu: pin conflict\\n\",\n\t\t\t\t\t   bias_pud(i), bias_bit(i),\n\t\t\t\t\t   bias_pud(j), bias_bit(j));\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; info->ioctrl_regs && info->ioctrl_regs[i].reg; i++)\n\t\tsh_pfc_check_reg(drvname, info->ioctrl_regs[i].reg, U32_MAX);\n\n\t \n\tfor (i = 0; info->data_regs && info->data_regs[i].reg; i++) {\n\t\tsh_pfc_check_reg(drvname, info->data_regs[i].reg,\n\t\t\t\t GENMASK(info->data_regs[i].reg_width - 1, 0));\n\t\tsh_pfc_check_reg_enums(drvname, info->data_regs[i].reg,\n\t\t\t\t       info->data_regs[i].enum_ids,\n\t\t\t\t       info->data_regs[i].reg_width);\n\t}\n\n#ifdef CONFIG_PINCTRL_SH_FUNC_GPIO\n\t \n\tfor (i = 0; i < info->nr_func_gpios; i++) {\n\t\tconst struct pinmux_func *func = &info->func_gpios[i];\n\n\t\tif (!func->name) {\n\t\t\tsh_pfc_err(\"empty function gpio %u\\n\", i);\n\t\t\tcontinue;\n\t\t}\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tif (same_name(func->name, info->func_gpios[j].name))\n\t\t\t\tsh_pfc_err(\"func_gpio %s: name conflict\\n\",\n\t\t\t\t\t   func->name);\n\t\t}\n\t\tif (sh_pfc_check_enum(drvname, func->enum_id))\n\t\t\tsh_pfc_err(\"%s enum_id %u conflict\\n\", func->name,\n\t\t\t\t   func->enum_id);\n\t}\n#endif\n}\n\nstatic void __init sh_pfc_check_driver(const struct platform_driver *pdrv)\n{\n\tunsigned int i;\n\n\tif (!IS_ENABLED(CONFIG_SUPERH) &&\n\t    !of_find_matching_node(NULL, pdrv->driver.of_match_table))\n\t\treturn;\n\n\tsh_pfc_regs = kcalloc(SH_PFC_MAX_REGS, sizeof(*sh_pfc_regs),\n\t\t\t      GFP_KERNEL);\n\tif (!sh_pfc_regs)\n\t\treturn;\n\n\tsh_pfc_enums = kcalloc(SH_PFC_MAX_ENUMS, sizeof(*sh_pfc_enums),\n\t\t\t      GFP_KERNEL);\n\tif (!sh_pfc_enums)\n\t\tgoto free_regs;\n\n\tpr_warn(\"sh_pfc: Checking builtin pinmux tables\\n\");\n\n\tfor (i = 0; pdrv->id_table[i].name[0]; i++)\n\t\tsh_pfc_check_info((void *)pdrv->id_table[i].driver_data);\n\n#ifdef CONFIG_OF\n\tfor (i = 0; pdrv->driver.of_match_table[i].compatible[0]; i++)\n\t\tsh_pfc_check_info(pdrv->driver.of_match_table[i].data);\n#endif\n\n\tpr_warn(\"sh_pfc: Detected %u errors and %u warnings\\n\", sh_pfc_errors,\n\t\tsh_pfc_warnings);\n\n\tkfree(sh_pfc_enums);\nfree_regs:\n\tkfree(sh_pfc_regs);\n}\n\n#else  \nstatic inline void sh_pfc_check_driver(struct platform_driver *pdrv) {}\n#endif  \n\nstatic int sh_pfc_probe(struct platform_device *pdev)\n{\n\tconst struct sh_pfc_soc_info *info;\n\tstruct sh_pfc *pfc;\n\tint ret;\n\n\tif (pdev->dev.of_node)\n\t\tinfo = of_device_get_match_data(&pdev->dev);\n\telse\n\t\tinfo = (const void *)platform_get_device_id(pdev)->driver_data;\n\n\tpfc = devm_kzalloc(&pdev->dev, sizeof(*pfc), GFP_KERNEL);\n\tif (pfc == NULL)\n\t\treturn -ENOMEM;\n\n\tpfc->info = info;\n\tpfc->dev = &pdev->dev;\n\n\tret = sh_pfc_map_resources(pfc, pdev);\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\n\tspin_lock_init(&pfc->lock);\n\n\tif (info->ops && info->ops->init) {\n\t\tret = info->ops->init(pfc);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tinfo = pfc->info;\n\t}\n\n\tret = sh_pfc_suspend_init(pfc);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (!of_have_populated_dt())\n\t\tpinctrl_provide_dummies();\n\n\tret = sh_pfc_init_ranges(pfc);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = sh_pfc_register_pinctrl(pfc);\n\tif (unlikely(ret != 0))\n\t\treturn ret;\n\n#ifdef CONFIG_PINCTRL_SH_PFC_GPIO\n\t \n\tret = sh_pfc_register_gpiochip(pfc);\n\tif (unlikely(ret != 0)) {\n\t\t \n\t\tdev_notice(pfc->dev, \"failed to init GPIO chip, ignoring...\\n\");\n\t}\n#endif\n\n\tplatform_set_drvdata(pdev, pfc);\n\n\tdev_info(pfc->dev, \"%s support registered\\n\", info->name);\n\n\treturn 0;\n}\n\nstatic const struct platform_device_id sh_pfc_id_table[] = {\n#ifdef CONFIG_PINCTRL_PFC_SH7203\n\t{ \"pfc-sh7203\", (kernel_ulong_t)&sh7203_pinmux_info },\n#endif\n#ifdef CONFIG_PINCTRL_PFC_SH7264\n\t{ \"pfc-sh7264\", (kernel_ulong_t)&sh7264_pinmux_info },\n#endif\n#ifdef CONFIG_PINCTRL_PFC_SH7269\n\t{ \"pfc-sh7269\", (kernel_ulong_t)&sh7269_pinmux_info },\n#endif\n#ifdef CONFIG_PINCTRL_PFC_SH7720\n\t{ \"pfc-sh7720\", (kernel_ulong_t)&sh7720_pinmux_info },\n#endif\n#ifdef CONFIG_PINCTRL_PFC_SH7722\n\t{ \"pfc-sh7722\", (kernel_ulong_t)&sh7722_pinmux_info },\n#endif\n#ifdef CONFIG_PINCTRL_PFC_SH7723\n\t{ \"pfc-sh7723\", (kernel_ulong_t)&sh7723_pinmux_info },\n#endif\n#ifdef CONFIG_PINCTRL_PFC_SH7724\n\t{ \"pfc-sh7724\", (kernel_ulong_t)&sh7724_pinmux_info },\n#endif\n#ifdef CONFIG_PINCTRL_PFC_SH7734\n\t{ \"pfc-sh7734\", (kernel_ulong_t)&sh7734_pinmux_info },\n#endif\n#ifdef CONFIG_PINCTRL_PFC_SH7757\n\t{ \"pfc-sh7757\", (kernel_ulong_t)&sh7757_pinmux_info },\n#endif\n#ifdef CONFIG_PINCTRL_PFC_SH7785\n\t{ \"pfc-sh7785\", (kernel_ulong_t)&sh7785_pinmux_info },\n#endif\n#ifdef CONFIG_PINCTRL_PFC_SH7786\n\t{ \"pfc-sh7786\", (kernel_ulong_t)&sh7786_pinmux_info },\n#endif\n#ifdef CONFIG_PINCTRL_PFC_SHX3\n\t{ \"pfc-shx3\", (kernel_ulong_t)&shx3_pinmux_info },\n#endif\n\t{   }\n};\n\nstatic struct platform_driver sh_pfc_driver = {\n\t.probe\t\t= sh_pfc_probe,\n\t.id_table\t= sh_pfc_id_table,\n\t.driver\t\t= {\n\t\t.name\t= DRV_NAME,\n\t\t.of_match_table = of_match_ptr(sh_pfc_of_table),\n\t\t.pm\t= pm_sleep_ptr(&sh_pfc_pm),\n\t},\n};\n\nstatic int __init sh_pfc_init(void)\n{\n\tsh_pfc_check_driver(&sh_pfc_driver);\n\treturn platform_driver_register(&sh_pfc_driver);\n}\npostcore_initcall(sh_pfc_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}