{
  "module_name": "pinctrl-palmas.c",
  "hash_id": "b4e25d0d77cddc9636788e76b3f9c28e8fe792bac6af5c14befee2c2143ac07e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/pinctrl-palmas.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/mfd/palmas.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pinctrl/machine.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinconf-generic.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinmux.h>\n#include <linux/pm.h>\n#include <linux/slab.h>\n\n#include \"core.h\"\n#include \"pinconf.h\"\n#include \"pinctrl-utils.h\"\n\n#define PALMAS_PIN_GPIO0_ID\t\t\t\t0\n#define PALMAS_PIN_GPIO1_VBUS_LED1_PWM1\t\t\t1\n#define PALMAS_PIN_GPIO2_REGEN_LED2_PWM2\t\t2\n#define PALMAS_PIN_GPIO3_CHRG_DET\t\t\t3\n#define PALMAS_PIN_GPIO4_SYSEN1\t\t\t\t4\n#define PALMAS_PIN_GPIO5_CLK32KGAUDIO_USB_PSEL\t\t5\n#define PALMAS_PIN_GPIO6_SYSEN2\t\t\t\t6\n#define PALMAS_PIN_GPIO7_MSECURE_PWRHOLD\t\t7\n#define PALMAS_PIN_GPIO8_SIM1RSTI\t\t\t8\n#define PALMAS_PIN_GPIO9_LOW_VBAT\t\t\t9\n#define PALMAS_PIN_GPIO10_WIRELESS_CHRG1\t\t10\n#define PALMAS_PIN_GPIO11_RCM\t\t\t\t11\n#define PALMAS_PIN_GPIO12_SIM2RSTO\t\t\t12\n#define PALMAS_PIN_GPIO13\t\t\t\t13\n#define PALMAS_PIN_GPIO14\t\t\t\t14\n#define PALMAS_PIN_GPIO15_SIM2RSTI\t\t\t15\n#define PALMAS_PIN_VAC\t\t\t\t\t16\n#define PALMAS_PIN_POWERGOOD_USB_PSEL\t\t\t17\n#define PALMAS_PIN_NRESWARM\t\t\t\t18\n#define PALMAS_PIN_PWRDOWN\t\t\t\t19\n#define PALMAS_PIN_GPADC_START\t\t\t\t20\n#define PALMAS_PIN_RESET_IN\t\t\t\t21\n#define PALMAS_PIN_NSLEEP\t\t\t\t22\n#define PALMAS_PIN_ENABLE1\t\t\t\t23\n#define PALMAS_PIN_ENABLE2\t\t\t\t24\n#define PALMAS_PIN_INT\t\t\t\t\t25\n#define PALMAS_PIN_NUM\t\t\t\t\t(PALMAS_PIN_INT + 1)\n\nstruct palmas_pin_function {\n\tconst char *name;\n\tconst char * const *groups;\n\tunsigned ngroups;\n};\n\nstruct palmas_pctrl_chip_info {\n\tstruct device *dev;\n\tstruct pinctrl_dev *pctl;\n\tstruct palmas *palmas;\n\tint pins_current_opt[PALMAS_PIN_NUM];\n\tconst struct palmas_pin_function *functions;\n\tunsigned num_functions;\n\tconst struct palmas_pingroup *pin_groups;\n\tint num_pin_groups;\n\tconst struct pinctrl_pin_desc *pins;\n\tunsigned num_pins;\n};\n\nstatic const struct pinctrl_pin_desc palmas_pins_desc[] = {\n\tPINCTRL_PIN(PALMAS_PIN_GPIO0_ID, \"gpio0\"),\n\tPINCTRL_PIN(PALMAS_PIN_GPIO1_VBUS_LED1_PWM1, \"gpio1\"),\n\tPINCTRL_PIN(PALMAS_PIN_GPIO2_REGEN_LED2_PWM2, \"gpio2\"),\n\tPINCTRL_PIN(PALMAS_PIN_GPIO3_CHRG_DET, \"gpio3\"),\n\tPINCTRL_PIN(PALMAS_PIN_GPIO4_SYSEN1, \"gpio4\"),\n\tPINCTRL_PIN(PALMAS_PIN_GPIO5_CLK32KGAUDIO_USB_PSEL, \"gpio5\"),\n\tPINCTRL_PIN(PALMAS_PIN_GPIO6_SYSEN2, \"gpio6\"),\n\tPINCTRL_PIN(PALMAS_PIN_GPIO7_MSECURE_PWRHOLD, \"gpio7\"),\n\tPINCTRL_PIN(PALMAS_PIN_GPIO8_SIM1RSTI, \"gpio8\"),\n\tPINCTRL_PIN(PALMAS_PIN_GPIO9_LOW_VBAT, \"gpio9\"),\n\tPINCTRL_PIN(PALMAS_PIN_GPIO10_WIRELESS_CHRG1, \"gpio10\"),\n\tPINCTRL_PIN(PALMAS_PIN_GPIO11_RCM, \"gpio11\"),\n\tPINCTRL_PIN(PALMAS_PIN_GPIO12_SIM2RSTO, \"gpio12\"),\n\tPINCTRL_PIN(PALMAS_PIN_GPIO13, \"gpio13\"),\n\tPINCTRL_PIN(PALMAS_PIN_GPIO14, \"gpio14\"),\n\tPINCTRL_PIN(PALMAS_PIN_GPIO15_SIM2RSTI, \"gpio15\"),\n\tPINCTRL_PIN(PALMAS_PIN_VAC, \"vac\"),\n\tPINCTRL_PIN(PALMAS_PIN_POWERGOOD_USB_PSEL, \"powergood\"),\n\tPINCTRL_PIN(PALMAS_PIN_NRESWARM, \"nreswarm\"),\n\tPINCTRL_PIN(PALMAS_PIN_PWRDOWN, \"pwrdown\"),\n\tPINCTRL_PIN(PALMAS_PIN_GPADC_START, \"gpadc_start\"),\n\tPINCTRL_PIN(PALMAS_PIN_RESET_IN, \"reset_in\"),\n\tPINCTRL_PIN(PALMAS_PIN_NSLEEP, \"nsleep\"),\n\tPINCTRL_PIN(PALMAS_PIN_ENABLE1, \"enable1\"),\n\tPINCTRL_PIN(PALMAS_PIN_ENABLE2, \"enable2\"),\n\tPINCTRL_PIN(PALMAS_PIN_INT, \"int\"),\n};\n\nstatic const char * const opt0_groups[] = {\n\t\"gpio0\",\n\t\"gpio1\",\n\t\"gpio2\",\n\t\"gpio3\",\n\t\"gpio4\",\n\t\"gpio5\",\n\t\"gpio6\",\n\t\"gpio7\",\n\t\"gpio8\",\n\t\"gpio9\",\n\t\"gpio10\",\n\t\"gpio11\",\n\t\"gpio12\",\n\t\"gpio13\",\n\t\"gpio14\",\n\t\"gpio15\",\n\t\"vac\",\n\t\"powergood\",\n\t\"nreswarm\",\n\t\"pwrdown\",\n\t\"gpadc_start\",\n\t\"reset_in\",\n\t\"nsleep\",\n\t\"enable1\",\n\t\"enable2\",\n\t\"int\",\n};\n\nstatic const char * const opt1_groups[] = {\n\t\"gpio0\",\n\t\"gpio1\",\n\t\"gpio2\",\n\t\"gpio3\",\n\t\"gpio4\",\n\t\"gpio5\",\n\t\"gpio6\",\n\t\"gpio7\",\n\t\"gpio8\",\n\t\"gpio9\",\n\t\"gpio10\",\n\t\"gpio11\",\n\t\"gpio12\",\n\t\"gpio15\",\n\t\"vac\",\n\t\"powergood\",\n};\n\nstatic const char * const opt2_groups[] = {\n\t\"gpio1\",\n\t\"gpio2\",\n\t\"gpio5\",\n\t\"gpio7\",\n};\n\nstatic const char * const opt3_groups[] = {\n\t\"gpio1\",\n\t\"gpio2\",\n};\n\nstatic const char * const gpio_groups[] = {\n\t\"gpio0\",\n\t\"gpio1\",\n\t\"gpio2\",\n\t\"gpio3\",\n\t\"gpio4\",\n\t\"gpio5\",\n\t\"gpio6\",\n\t\"gpio7\",\n\t\"gpio8\",\n\t\"gpio9\",\n\t\"gpio10\",\n\t\"gpio11\",\n\t\"gpio12\",\n\t\"gpio13\",\n\t\"gpio14\",\n\t\"gpio15\",\n};\n\nstatic const char * const led_groups[] = {\n\t\"gpio1\",\n\t\"gpio2\",\n};\n\nstatic const char * const pwm_groups[] = {\n\t\"gpio1\",\n\t\"gpio2\",\n};\n\nstatic const char * const regen_groups[] = {\n\t\"gpio2\",\n};\n\nstatic const char * const sysen_groups[] = {\n\t\"gpio4\",\n\t\"gpio6\",\n};\n\nstatic const char * const clk32kgaudio_groups[] = {\n\t\"gpio5\",\n};\n\nstatic const char * const id_groups[] = {\n\t\"gpio0\",\n};\n\nstatic const char * const vbus_det_groups[] = {\n\t\"gpio1\",\n};\n\nstatic const char * const chrg_det_groups[] = {\n\t\"gpio3\",\n};\n\nstatic const char * const vac_groups[] = {\n\t\"vac\",\n};\n\nstatic const char * const vacok_groups[] = {\n\t\"vac\",\n};\n\nstatic const char * const powergood_groups[] = {\n\t\"powergood\",\n};\n\nstatic const char * const usb_psel_groups[] = {\n\t\"gpio5\",\n\t\"powergood\",\n};\n\nstatic const char * const msecure_groups[] = {\n\t\"gpio7\",\n};\n\nstatic const char * const pwrhold_groups[] = {\n\t\"gpio7\",\n};\n\nstatic const char * const int_groups[] = {\n\t\"int\",\n};\n\nstatic const char * const nreswarm_groups[] = {\n\t\"nreswarm\",\n};\n\nstatic const char * const simrsto_groups[] = {\n\t\"gpio12\",\n};\n\nstatic const char * const simrsti_groups[] = {\n\t\"gpio8\",\n\t\"gpio15\",\n};\n\nstatic const char * const low_vbat_groups[] = {\n\t\"gpio9\",\n};\n\nstatic const char * const wireless_chrg1_groups[] = {\n\t\"gpio10\",\n};\n\nstatic const char * const rcm_groups[] = {\n\t\"gpio11\",\n};\n\nstatic const char * const pwrdown_groups[] = {\n\t\"pwrdown\",\n};\n\nstatic const char * const gpadc_start_groups[] = {\n\t\"gpadc_start\",\n};\n\nstatic const char * const reset_in_groups[] = {\n\t\"reset_in\",\n};\n\nstatic const char * const nsleep_groups[] = {\n\t\"nsleep\",\n};\n\nstatic const char * const enable_groups[] = {\n\t\"enable1\",\n\t\"enable2\",\n};\n\n#define FUNCTION_GROUPS\t\t\t\t\t\\\n\tFUNCTION_GROUP(opt0, OPTION0),\t\t\t\\\n\tFUNCTION_GROUP(opt1, OPTION1),\t\t\t\\\n\tFUNCTION_GROUP(opt2, OPTION2),\t\t\t\\\n\tFUNCTION_GROUP(opt3, OPTION3),\t\t\t\\\n\tFUNCTION_GROUP(gpio, GPIO),\t\t\t\\\n\tFUNCTION_GROUP(led, LED),\t\t\t\\\n\tFUNCTION_GROUP(pwm, PWM),\t\t\t\\\n\tFUNCTION_GROUP(regen, REGEN),\t\t\t\\\n\tFUNCTION_GROUP(sysen, SYSEN),\t\t\t\\\n\tFUNCTION_GROUP(clk32kgaudio, CLK32KGAUDIO),\t\\\n\tFUNCTION_GROUP(id, ID),\t\t\t\t\\\n\tFUNCTION_GROUP(vbus_det, VBUS_DET),\t\t\\\n\tFUNCTION_GROUP(chrg_det, CHRG_DET),\t\t\\\n\tFUNCTION_GROUP(vac, VAC),\t\t\t\\\n\tFUNCTION_GROUP(vacok, VACOK),\t\t\t\\\n\tFUNCTION_GROUP(powergood, POWERGOOD),\t\t\\\n\tFUNCTION_GROUP(usb_psel, USB_PSEL),\t\t\\\n\tFUNCTION_GROUP(msecure, MSECURE),\t\t\\\n\tFUNCTION_GROUP(pwrhold, PWRHOLD),\t\t\\\n\tFUNCTION_GROUP(int, INT),\t\t\t\\\n\tFUNCTION_GROUP(nreswarm, NRESWARM),\t\t\\\n\tFUNCTION_GROUP(simrsto, SIMRSTO),\t\t\\\n\tFUNCTION_GROUP(simrsti, SIMRSTI),\t\t\\\n\tFUNCTION_GROUP(low_vbat, LOW_VBAT),\t\t\\\n\tFUNCTION_GROUP(wireless_chrg1, WIRELESS_CHRG1),\t\\\n\tFUNCTION_GROUP(rcm, RCM),\t\t\t\\\n\tFUNCTION_GROUP(pwrdown, PWRDOWN),\t\t\\\n\tFUNCTION_GROUP(gpadc_start, GPADC_START),\t\\\n\tFUNCTION_GROUP(reset_in, RESET_IN),\t\t\\\n\tFUNCTION_GROUP(nsleep, NSLEEP),\t\t\t\\\n\tFUNCTION_GROUP(enable, ENABLE)\n\nstatic const struct palmas_pin_function palmas_pin_function[] = {\n#undef FUNCTION_GROUP\n#define FUNCTION_GROUP(fname, mux)\t\t\t\\\n\t{\t\t\t\t\t\t\\\n\t\t.name = #fname,\t\t\t\t\\\n\t\t.groups = fname##_groups,\t\t\\\n\t\t.ngroups = ARRAY_SIZE(fname##_groups),\t\\\n\t}\n\n\tFUNCTION_GROUPS,\n};\n\nenum palmas_pinmux {\n#undef FUNCTION_GROUP\n#define FUNCTION_GROUP(fname, mux)\tPALMAS_PINMUX_##mux\n\tFUNCTION_GROUPS,\n\tPALMAS_PINMUX_NA = 0xFFFF,\n};\n\nstruct palmas_pins_pullup_dn_info {\n\tint pullup_dn_reg_base;\n\tint pullup_dn_reg_add;\n\tint pullup_dn_mask;\n\tint normal_val;\n\tint pull_up_val;\n\tint pull_dn_val;\n};\n\nstruct palmas_pins_od_info {\n\tint od_reg_base;\n\tint od_reg_add;\n\tint od_mask;\n\tint od_enable;\n\tint od_disable;\n};\n\nstruct palmas_pin_info {\n\tenum palmas_pinmux mux_opt;\n\tconst struct palmas_pins_pullup_dn_info *pud_info;\n\tconst struct palmas_pins_od_info *od_info;\n};\n\nstruct palmas_pingroup {\n\tconst char *name;\n\tconst unsigned pins[1];\n\tunsigned npins;\n\tunsigned mux_reg_base;\n\tunsigned mux_reg_add;\n\tunsigned mux_reg_mask;\n\tunsigned mux_bit_shift;\n\tconst struct palmas_pin_info *opt[4];\n};\n\n#define PULL_UP_DN(_name, _rbase, _add, _mask, _nv, _uv, _dv)\t\t\\\nstatic const struct palmas_pins_pullup_dn_info pud_##_name##_info = {\t\\\n\t.pullup_dn_reg_base = PALMAS_##_rbase##_BASE,\t\t\t\\\n\t.pullup_dn_reg_add = _add,\t\t\t\t\t\\\n\t.pullup_dn_mask = _mask,\t\t\t\t\t\\\n\t.normal_val = _nv,\t\t\t\t\t\t\\\n\t.pull_up_val = _uv,\t\t\t\t\t\t\\\n\t.pull_dn_val = _dv,\t\t\t\t\t\t\\\n}\n\nPULL_UP_DN(nreswarm,\tPU_PD_OD,\tPALMAS_PU_PD_INPUT_CTRL1,\t0x2,\t0x0,\t0x2,\t-1);\nPULL_UP_DN(pwrdown,\tPU_PD_OD,\tPALMAS_PU_PD_INPUT_CTRL1,\t0x4,\t0x0,\t-1,\t0x4);\nPULL_UP_DN(gpadc_start,\tPU_PD_OD,\tPALMAS_PU_PD_INPUT_CTRL1,\t0x30,\t0x0,\t0x20,\t0x10);\nPULL_UP_DN(reset_in,\tPU_PD_OD,\tPALMAS_PU_PD_INPUT_CTRL1,\t0x40,\t0x0,\t-1,\t0x40);\nPULL_UP_DN(nsleep,\tPU_PD_OD,\tPALMAS_PU_PD_INPUT_CTRL2,\t0x3,\t0x0,\t0x2,\t0x1);\nPULL_UP_DN(enable1,\tPU_PD_OD,\tPALMAS_PU_PD_INPUT_CTRL2,\t0xC,\t0x0,\t0x8,\t0x4);\nPULL_UP_DN(enable2,\tPU_PD_OD,\tPALMAS_PU_PD_INPUT_CTRL2,\t0x30,\t0x0,\t0x20,\t0x10);\nPULL_UP_DN(vacok,\tPU_PD_OD,\tPALMAS_PU_PD_INPUT_CTRL3,\t0x40,\t0x0,\t-1,\t0x40);\nPULL_UP_DN(chrg_det,\tPU_PD_OD,\tPALMAS_PU_PD_INPUT_CTRL3,\t0x10,\t0x0,\t-1,\t0x10);\nPULL_UP_DN(pwrhold,\tPU_PD_OD,\tPALMAS_PU_PD_INPUT_CTRL3,\t0x4,\t0x0,\t-1,\t0x4);\nPULL_UP_DN(msecure,\tPU_PD_OD,\tPALMAS_PU_PD_INPUT_CTRL3,\t0x1,\t0x0,\t-1,\t0x1);\nPULL_UP_DN(id,\t\tUSB_OTG,\tPALMAS_USB_ID_CTRL_SET,\t\t0x40,\t0x0,\t0x40,\t-1);\nPULL_UP_DN(gpio0,\tGPIO,\t\tPALMAS_PU_PD_GPIO_CTRL1,\t0x04,\t0,\t-1,\t1);\nPULL_UP_DN(gpio1,\tGPIO,\t\tPALMAS_PU_PD_GPIO_CTRL1,\t0x0C,\t0,\t0x8,\t0x4);\nPULL_UP_DN(gpio2,\tGPIO,\t\tPALMAS_PU_PD_GPIO_CTRL1,\t0x30,\t0x0,\t0x20,\t0x10);\nPULL_UP_DN(gpio3,\tGPIO,\t\tPALMAS_PU_PD_GPIO_CTRL1,\t0x40,\t0x0,\t-1,\t0x40);\nPULL_UP_DN(gpio4,\tGPIO,\t\tPALMAS_PU_PD_GPIO_CTRL2,\t0x03,\t0x0,\t0x2,\t0x1);\nPULL_UP_DN(gpio5,\tGPIO,\t\tPALMAS_PU_PD_GPIO_CTRL2,\t0x0c,\t0x0,\t0x8,\t0x4);\nPULL_UP_DN(gpio6,\tGPIO,\t\tPALMAS_PU_PD_GPIO_CTRL2,\t0x30,\t0x0,\t0x20,\t0x10);\nPULL_UP_DN(gpio7,\tGPIO,\t\tPALMAS_PU_PD_GPIO_CTRL2,\t0x40,\t0x0,\t-1,\t0x40);\nPULL_UP_DN(gpio9,\tGPIO,\t\tPALMAS_PU_PD_GPIO_CTRL3,\t0x0C,\t0x0,\t0x8,\t0x4);\nPULL_UP_DN(gpio10,\tGPIO,\t\tPALMAS_PU_PD_GPIO_CTRL3,\t0x30,\t0x0,\t0x20,\t0x10);\nPULL_UP_DN(gpio11,\tGPIO,\t\tPALMAS_PU_PD_GPIO_CTRL3,\t0xC0,\t0x0,\t0x80,\t0x40);\nPULL_UP_DN(gpio13,\tGPIO,\t\tPALMAS_PU_PD_GPIO_CTRL4,\t0x04,\t0x0,\t-1,\t0x04);\nPULL_UP_DN(gpio14,\tGPIO,\t\tPALMAS_PU_PD_GPIO_CTRL4,\t0x30,\t0x0,\t0x20,\t0x10);\n\n#define OD_INFO(_name, _rbase, _add, _mask, _ev, _dv)\t\t\\\nstatic const struct palmas_pins_od_info od_##_name##_info = {\t\\\n\t.od_reg_base = PALMAS_##_rbase##_BASE,\t\t\t\\\n\t.od_reg_add = _add,\t\t\t\t\t\\\n\t.od_mask = _mask,\t\t\t\t\t\\\n\t.od_enable = _ev,\t\t\t\t\t\\\n\t.od_disable = _dv,\t\t\t\t\t\\\n}\n\nOD_INFO(gpio1,\tGPIO,\tPALMAS_OD_OUTPUT_GPIO_CTRL,\t0x1,\t0x1,\t0x0);\nOD_INFO(gpio2,\tGPIO,\tPALMAS_OD_OUTPUT_GPIO_CTRL,\t0x2,\t0x2,\t0x0);\nOD_INFO(gpio5,\tGPIO,\tPALMAS_OD_OUTPUT_GPIO_CTRL,\t0x20,\t0x20,\t0x0);\nOD_INFO(gpio10,\tGPIO,\tPALMAS_OD_OUTPUT_GPIO_CTRL2,\t0x04,\t0x04,\t0x0);\nOD_INFO(gpio13,\tGPIO,\tPALMAS_OD_OUTPUT_GPIO_CTRL2,\t0x20,\t0x20,\t0x0);\nOD_INFO(int,\t\tPU_PD_OD,\tPALMAS_OD_OUTPUT_CTRL,\t0x8,\t0x8,\t0x0);\nOD_INFO(pwm1,\t\tPU_PD_OD,\tPALMAS_OD_OUTPUT_CTRL,\t0x20,\t0x20,\t0x0);\nOD_INFO(pwm2,\t\tPU_PD_OD,\tPALMAS_OD_OUTPUT_CTRL,\t0x80,\t0x80,\t0x0);\nOD_INFO(vbus_det,\tPU_PD_OD,\tPALMAS_OD_OUTPUT_CTRL,\t0x40,\t0x40,\t0x0);\n\n#define PIN_INFO(_name, _id, _pud_info, _od_info)\t\t\\\nstatic const struct palmas_pin_info pin_##_name##_info = {\t\\\n\t.mux_opt = PALMAS_PINMUX_##_id,\t\t\t\t\\\n\t.pud_info = _pud_info,\t\t\t\t\t\\\n\t.od_info = _od_info\t\t\t\t\t\\\n}\n\nPIN_INFO(gpio0,\t\tGPIO,\t\t&pud_gpio0_info,\tNULL);\nPIN_INFO(gpio1,\t\tGPIO,\t\t&pud_gpio1_info,\t&od_gpio1_info);\nPIN_INFO(gpio2,\t\tGPIO,\t\t&pud_gpio2_info,\t&od_gpio2_info);\nPIN_INFO(gpio3,\t\tGPIO,\t\t&pud_gpio3_info,\tNULL);\nPIN_INFO(gpio4,\t\tGPIO,\t\t&pud_gpio4_info,\tNULL);\nPIN_INFO(gpio5,\t\tGPIO,\t\t&pud_gpio5_info,\t&od_gpio5_info);\nPIN_INFO(gpio6,\t\tGPIO,\t\t&pud_gpio6_info,\tNULL);\nPIN_INFO(gpio7,\t\tGPIO,\t\t&pud_gpio7_info,\tNULL);\nPIN_INFO(gpio8,\t\tGPIO,\t\tNULL,\t\t\tNULL);\nPIN_INFO(gpio9,\t\tGPIO,\t\t&pud_gpio9_info,\tNULL);\nPIN_INFO(gpio10,\tGPIO,\t\t&pud_gpio10_info,\t&od_gpio10_info);\nPIN_INFO(gpio11,\tGPIO,\t\t&pud_gpio11_info,\tNULL);\nPIN_INFO(gpio12,\tGPIO,\t\tNULL,\t\t\tNULL);\nPIN_INFO(gpio13,\tGPIO,\t\t&pud_gpio13_info,\t&od_gpio13_info);\nPIN_INFO(gpio14,\tGPIO,\t\t&pud_gpio14_info,\tNULL);\nPIN_INFO(gpio15,\tGPIO,\t\tNULL,\t\t\tNULL);\nPIN_INFO(id,\t\tID,\t\t&pud_id_info,\t\tNULL);\nPIN_INFO(led1,\t\tLED,\t\tNULL,\t\t\tNULL);\nPIN_INFO(led2,\t\tLED,\t\tNULL,\t\t\tNULL);\nPIN_INFO(regen,\t\tREGEN,\t\tNULL,\t\t\tNULL);\nPIN_INFO(sysen1,\tSYSEN,\t\tNULL,\t\t\tNULL);\nPIN_INFO(sysen2,\tSYSEN,\t\tNULL,\t\t\tNULL);\nPIN_INFO(int,\t\tINT,\t\tNULL,\t\t\t&od_int_info);\nPIN_INFO(pwm1,\t\tPWM,\t\tNULL,\t\t\t&od_pwm1_info);\nPIN_INFO(pwm2,\t\tPWM,\t\tNULL,\t\t\t&od_pwm2_info);\nPIN_INFO(vacok,\t\tVACOK,\t\t&pud_vacok_info,\tNULL);\nPIN_INFO(chrg_det,\tCHRG_DET,\t&pud_chrg_det_info,\tNULL);\nPIN_INFO(pwrhold,\tPWRHOLD,\t&pud_pwrhold_info,\tNULL);\nPIN_INFO(msecure,\tMSECURE,\t&pud_msecure_info,\tNULL);\nPIN_INFO(nreswarm,\tNA,\t\t&pud_nreswarm_info,\tNULL);\nPIN_INFO(pwrdown,\tNA,\t\t&pud_pwrdown_info,\tNULL);\nPIN_INFO(gpadc_start,\tNA,\t\t&pud_gpadc_start_info,\tNULL);\nPIN_INFO(reset_in,\tNA,\t\t&pud_reset_in_info,\tNULL);\nPIN_INFO(nsleep,\tNA,\t\t&pud_nsleep_info,\tNULL);\nPIN_INFO(enable1,\tNA,\t\t&pud_enable1_info,\tNULL);\nPIN_INFO(enable2,\tNA,\t\t&pud_enable2_info,\tNULL);\nPIN_INFO(clk32kgaudio,\tCLK32KGAUDIO,\tNULL,\t\t\tNULL);\nPIN_INFO(usb_psel,\tUSB_PSEL,\tNULL,\t\t\tNULL);\nPIN_INFO(vac,\t\tVAC,\t\tNULL,\t\t\tNULL);\nPIN_INFO(powergood,\tPOWERGOOD,\tNULL,\t\t\tNULL);\nPIN_INFO(vbus_det,\tVBUS_DET,\tNULL,\t\t\t&od_vbus_det_info);\nPIN_INFO(sim1rsti,\tSIMRSTI,\tNULL,\t\t\tNULL);\nPIN_INFO(low_vbat,\tLOW_VBAT,\tNULL,\t\t\tNULL);\nPIN_INFO(rcm,\t\tRCM,\t\tNULL,\t\t\tNULL);\nPIN_INFO(sim2rsto,\tSIMRSTO,\tNULL,\t\t\tNULL);\nPIN_INFO(sim2rsti,\tSIMRSTI,\tNULL,\t\t\tNULL);\nPIN_INFO(wireless_chrg1,\tWIRELESS_CHRG1,\tNULL,\t\tNULL);\n\n#define PALMAS_PRIMARY_SECONDARY_NONE\t0\n#define PALMAS_NONE_BASE\t\t0\n#define PALMAS_PRIMARY_SECONDARY_INPUT3 PALMAS_PU_PD_INPUT_CTRL3\n\n#define PALMAS_PINGROUP(pg_name, pin_id, base, reg, _mask, _bshift, o0, o1, o2, o3)  \\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.name = #pg_name,\t\t\t\t\t\\\n\t\t.pins = {PALMAS_PIN_##pin_id},\t\t\t\t\\\n\t\t.npins = 1,\t\t\t\t\t\t\\\n\t\t.mux_reg_base = PALMAS_##base##_BASE,\t\t\t\\\n\t\t.mux_reg_add = PALMAS_PRIMARY_SECONDARY_##reg,\t\t\\\n\t\t.mux_reg_mask = _mask,\t\t\t\t\t\\\n\t\t.mux_bit_shift = _bshift,\t\t\t\t\\\n\t\t.opt = {\t\t\t\t\t\t\\\n\t\t\to0,\t\t\t\t\t\t\\\n\t\t\to1,\t\t\t\t\t\t\\\n\t\t\to2,\t\t\t\t\t\t\\\n\t\t\to3,\t\t\t\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t}\n\nstatic const struct palmas_pingroup tps65913_pingroups[] = {\n\tPALMAS_PINGROUP(gpio0,\tGPIO0_ID,\t\t\tPU_PD_OD,\tPAD1,\t0x4,\t0x2,\t&pin_gpio0_info,\t&pin_id_info,\t\tNULL,\t\tNULL),\n\tPALMAS_PINGROUP(gpio1,\tGPIO1_VBUS_LED1_PWM1,\t\tPU_PD_OD,\tPAD1,\t0x18,\t0x3,\t&pin_gpio1_info,\t&pin_vbus_det_info,\t&pin_led1_info,\t&pin_pwm1_info),\n\tPALMAS_PINGROUP(gpio2,\tGPIO2_REGEN_LED2_PWM2,\t\tPU_PD_OD,\tPAD1,\t0x60,\t0x5,\t&pin_gpio2_info,\t&pin_regen_info,\t&pin_led2_info,\t&pin_pwm2_info),\n\tPALMAS_PINGROUP(gpio3,\tGPIO3_CHRG_DET,\t\t\tPU_PD_OD,\tPAD1,\t0x80,\t0x7,\t&pin_gpio3_info,\t&pin_chrg_det_info,\tNULL,\t\tNULL),\n\tPALMAS_PINGROUP(gpio4,\tGPIO4_SYSEN1,\t\t\tPU_PD_OD,\tPAD1,\t0x01,\t0x0,\t&pin_gpio4_info,\t&pin_sysen1_info,\tNULL,\t\tNULL),\n\tPALMAS_PINGROUP(gpio5,\tGPIO5_CLK32KGAUDIO_USB_PSEL,\tPU_PD_OD,\tPAD2,\t0x6,\t0x1,\t&pin_gpio5_info,\t&pin_clk32kgaudio_info,\t&pin_usb_psel_info,\tNULL),\n\tPALMAS_PINGROUP(gpio6,\tGPIO6_SYSEN2,\t\t\tPU_PD_OD,\tPAD2,\t0x08,\t0x3,\t&pin_gpio6_info,\t&pin_sysen2_info,\tNULL,\t\tNULL),\n\tPALMAS_PINGROUP(gpio7,\tGPIO7_MSECURE_PWRHOLD,\t\tPU_PD_OD,\tPAD2,\t0x30,\t0x4,\t&pin_gpio7_info,\t&pin_msecure_info,\t&pin_pwrhold_info,\tNULL),\n\tPALMAS_PINGROUP(vac,\tVAC,\t\t\t\tPU_PD_OD,\tPAD1,\t0x02,\t0x1,\t&pin_vac_info,\t\t&pin_vacok_info,\tNULL,\t\tNULL),\n\tPALMAS_PINGROUP(powergood,\tPOWERGOOD_USB_PSEL,\tPU_PD_OD,\tPAD1,\t0x01,\t0x0,\t&pin_powergood_info,\t&pin_usb_psel_info,\tNULL,\tNULL),\n\tPALMAS_PINGROUP(nreswarm,\tNRESWARM,\t\tNONE,\t\tNONE,\t0x0,\t0x0,\t&pin_nreswarm_info,\tNULL,\t\t\tNULL,\t\tNULL),\n\tPALMAS_PINGROUP(pwrdown,\tPWRDOWN,\t\tNONE,\t\tNONE,\t0x0,\t0x0,\t&pin_pwrdown_info,\tNULL,\t\t\tNULL,\t\tNULL),\n\tPALMAS_PINGROUP(gpadc_start,\tGPADC_START,\t\tNONE,\t\tNONE,\t0x0,\t0x0,\t&pin_gpadc_start_info,\tNULL,\t\t\tNULL,\t\tNULL),\n\tPALMAS_PINGROUP(reset_in,\tRESET_IN,\t\tNONE,\t\tNONE,\t0x0,\t0x0,\t&pin_reset_in_info,\tNULL,\t\t\tNULL,\t\tNULL),\n\tPALMAS_PINGROUP(nsleep,\t\tNSLEEP,\t\t\tNONE,\t\tNONE,\t0x0,\t0x0,\t&pin_nsleep_info,\tNULL,\t\t\tNULL,\t\tNULL),\n\tPALMAS_PINGROUP(enable1,\tENABLE1,\t\tNONE,\t\tNONE,\t0x0,\t0x0,\t&pin_enable1_info,\tNULL,\t\t\tNULL,\t\tNULL),\n\tPALMAS_PINGROUP(enable2,\tENABLE2,\t\tNONE,\t\tNONE,\t0x0,\t0x0,\t&pin_enable2_info,\tNULL,\t\t\tNULL,\t\tNULL),\n\tPALMAS_PINGROUP(int,\t\tINT,\t\t\tNONE,\t\tNONE,\t0x0,\t0x0,\t&pin_int_info,\t\tNULL,\t\t\tNULL,\t\tNULL),\n};\n\nstatic const struct palmas_pingroup tps80036_pingroups[] = {\n\tPALMAS_PINGROUP(gpio0,\tGPIO0_ID,\t\t\tPU_PD_OD,\tPAD1,\t0x4,\t0x2,\t&pin_gpio0_info,\t&pin_id_info,\t\tNULL,\t\tNULL),\n\tPALMAS_PINGROUP(gpio1,\tGPIO1_VBUS_LED1_PWM1,\t\tPU_PD_OD,\tPAD1,\t0x18,\t0x3,\t&pin_gpio1_info,\t&pin_vbus_det_info,\t&pin_led1_info,\t&pin_pwm1_info),\n\tPALMAS_PINGROUP(gpio2,\tGPIO2_REGEN_LED2_PWM2,\t\tPU_PD_OD,\tPAD1,\t0x60,\t0x5,\t&pin_gpio2_info,\t&pin_regen_info,\t&pin_led2_info,\t&pin_pwm2_info),\n\tPALMAS_PINGROUP(gpio3,\tGPIO3_CHRG_DET,\t\t\tPU_PD_OD,\tPAD1,\t0x80,\t0x7,\t&pin_gpio3_info,\t&pin_chrg_det_info,\tNULL,\t\tNULL),\n\tPALMAS_PINGROUP(gpio4,\tGPIO4_SYSEN1,\t\t\tPU_PD_OD,\tPAD1,\t0x01,\t0x0,\t&pin_gpio4_info,\t&pin_sysen1_info,\tNULL,\t\tNULL),\n\tPALMAS_PINGROUP(gpio5,\tGPIO5_CLK32KGAUDIO_USB_PSEL,\tPU_PD_OD,\tPAD2,\t0x6,\t0x1,\t&pin_gpio5_info,\t&pin_clk32kgaudio_info,\t&pin_usb_psel_info,\tNULL),\n\tPALMAS_PINGROUP(gpio6,\tGPIO6_SYSEN2,\t\t\tPU_PD_OD,\tPAD2,\t0x08,\t0x3,\t&pin_gpio6_info,\t&pin_sysen2_info,\tNULL,\t\tNULL),\n\tPALMAS_PINGROUP(gpio7,\tGPIO7_MSECURE_PWRHOLD,\t\tPU_PD_OD,\tPAD2,\t0x30,\t0x4,\t&pin_gpio7_info,\t&pin_msecure_info,\t&pin_pwrhold_info,\tNULL),\n\tPALMAS_PINGROUP(gpio8,\tGPIO8_SIM1RSTI,\t\t\tPU_PD_OD,\tPAD4,\t0x01,\t0x0,\t&pin_gpio8_info,\t&pin_sim1rsti_info,\tNULL,\t\tNULL),\n\tPALMAS_PINGROUP(gpio9,\tGPIO9_LOW_VBAT,\t\t\tPU_PD_OD,\tPAD4,\t0x02,\t0x1,\t&pin_gpio9_info,\t&pin_low_vbat_info,\tNULL,\t\tNULL),\n\tPALMAS_PINGROUP(gpio10,\tGPIO10_WIRELESS_CHRG1,\t\tPU_PD_OD,\tPAD4,\t0x04,\t0x2,\t&pin_gpio10_info,\t&pin_wireless_chrg1_info,\tNULL,\tNULL),\n\tPALMAS_PINGROUP(gpio11,\tGPIO11_RCM,\t\t\tPU_PD_OD,\tPAD4,\t0x08,\t0x3,\t&pin_gpio11_info,\t&pin_rcm_info,\t\tNULL,\t\tNULL),\n\tPALMAS_PINGROUP(gpio12,\tGPIO12_SIM2RSTO,\t\tPU_PD_OD,\tPAD4,\t0x10,\t0x4,\t&pin_gpio12_info,\t&pin_sim2rsto_info,\tNULL,\t\tNULL),\n\tPALMAS_PINGROUP(gpio13,\tGPIO13,\t\t\t\tNONE,\t\tNONE,\t0x00,\t0x0,\t&pin_gpio13_info,\tNULL,\t\t\tNULL,\t\tNULL),\n\tPALMAS_PINGROUP(gpio14,\tGPIO14,\t\t\t\tNONE,\t\tNONE,\t0x00,\t0x0,\t&pin_gpio14_info,\tNULL,\t\t\tNULL,\t\tNULL),\n\tPALMAS_PINGROUP(gpio15,\tGPIO15_SIM2RSTI,\t\tPU_PD_OD,\tPAD4,\t0x80,\t0x7,\t&pin_gpio15_info,\t&pin_sim2rsti_info,\tNULL,\t\tNULL),\n\tPALMAS_PINGROUP(vac,\tVAC,\t\t\t\tPU_PD_OD,\tPAD1,\t0x02,\t0x1,\t&pin_vac_info,\t\t&pin_vacok_info,\tNULL,\t\tNULL),\n\tPALMAS_PINGROUP(powergood,\tPOWERGOOD_USB_PSEL,\tPU_PD_OD,\tPAD1,\t0x01,\t0x0,\t&pin_powergood_info,\t&pin_usb_psel_info,\tNULL,\tNULL),\n\tPALMAS_PINGROUP(nreswarm,\tNRESWARM,\t\tNONE,\t\tNONE,\t0x0,\t0x0,\t&pin_nreswarm_info,\tNULL,\t\t\tNULL,\t\tNULL),\n\tPALMAS_PINGROUP(pwrdown,\tPWRDOWN,\t\tNONE,\t\tNONE,\t0x0,\t0x0,\t&pin_pwrdown_info,\tNULL,\t\t\tNULL,\t\tNULL),\n\tPALMAS_PINGROUP(gpadc_start,\tGPADC_START,\t\tNONE,\t\tNONE,\t0x0,\t0x0,\t&pin_gpadc_start_info,\tNULL,\t\t\tNULL,\t\tNULL),\n\tPALMAS_PINGROUP(reset_in,\tRESET_IN,\t\tNONE,\t\tNONE,\t0x0,\t0x0,\t&pin_reset_in_info,\tNULL,\t\t\tNULL,\t\tNULL),\n\tPALMAS_PINGROUP(nsleep,\t\tNSLEEP,\t\t\tNONE,\t\tNONE,\t0x0,\t0x0,\t&pin_nsleep_info,\tNULL,\t\t\tNULL,\t\tNULL),\n\tPALMAS_PINGROUP(enable1,\tENABLE1,\t\tNONE,\t\tNONE,\t0x0,\t0x0,\t&pin_enable1_info,\tNULL,\t\t\tNULL,\t\tNULL),\n\tPALMAS_PINGROUP(enable2,\tENABLE2,\t\tNONE,\t\tNONE,\t0x0,\t0x0,\t&pin_enable2_info,\tNULL,\t\t\tNULL,\t\tNULL),\n\tPALMAS_PINGROUP(int,\t\tINT,\t\t\tNONE,\t\tNONE,\t0x0,\t0x0,\t&pin_int_info,\t\tNULL,\t\t\tNULL,\t\tNULL),\n};\n\nstatic int palmas_pinctrl_get_pin_mux(struct palmas_pctrl_chip_info *pci)\n{\n\tconst struct palmas_pingroup *g;\n\tunsigned int val;\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < pci->num_pin_groups; ++i) {\n\t\tg = &pci->pin_groups[i];\n\t\tif (g->mux_reg_base == PALMAS_NONE_BASE) {\n\t\t\tpci->pins_current_opt[i] = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tret = palmas_read(pci->palmas, g->mux_reg_base,\n\t\t\t\tg->mux_reg_add, &val);\n\t\tif (ret < 0) {\n\t\t\tdev_err(pci->dev, \"mux_reg 0x%02x read failed: %d\\n\",\n\t\t\t\t\tg->mux_reg_add, ret);\n\t\t\treturn ret;\n\t\t}\n\t\tval &= g->mux_reg_mask;\n\t\tpci->pins_current_opt[i] = val >> g->mux_bit_shift;\n\t}\n\treturn 0;\n}\n\nstatic int palmas_pinctrl_set_dvfs1(struct palmas_pctrl_chip_info *pci,\n\t\tbool enable)\n{\n\tint ret;\n\tint val;\n\n\tval = enable ? PALMAS_PRIMARY_SECONDARY_PAD3_DVFS1 : 0;\n\tret = palmas_update_bits(pci->palmas, PALMAS_PU_PD_OD_BASE,\n\t\t\tPALMAS_PRIMARY_SECONDARY_PAD3,\n\t\t\tPALMAS_PRIMARY_SECONDARY_PAD3_DVFS1, val);\n\tif (ret < 0)\n\t\tdev_err(pci->dev, \"SECONDARY_PAD3 update failed %d\\n\", ret);\n\treturn ret;\n}\n\nstatic int palmas_pinctrl_set_dvfs2(struct palmas_pctrl_chip_info *pci,\n\t\tbool enable)\n{\n\tint ret;\n\tint val;\n\n\tval = enable ? PALMAS_PRIMARY_SECONDARY_PAD3_DVFS2 : 0;\n\tret = palmas_update_bits(pci->palmas, PALMAS_PU_PD_OD_BASE,\n\t\t\tPALMAS_PRIMARY_SECONDARY_PAD3,\n\t\t\tPALMAS_PRIMARY_SECONDARY_PAD3_DVFS2, val);\n\tif (ret < 0)\n\t\tdev_err(pci->dev, \"SECONDARY_PAD3 update failed %d\\n\", ret);\n\treturn ret;\n}\n\nstatic int palmas_pinctrl_get_groups_count(struct pinctrl_dev *pctldev)\n{\n\tstruct palmas_pctrl_chip_info *pci = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pci->num_pin_groups;\n}\n\nstatic const char *palmas_pinctrl_get_group_name(struct pinctrl_dev *pctldev,\n\t\tunsigned group)\n{\n\tstruct palmas_pctrl_chip_info *pci = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pci->pin_groups[group].name;\n}\n\nstatic int palmas_pinctrl_get_group_pins(struct pinctrl_dev *pctldev,\n\t\tunsigned group, const unsigned **pins, unsigned *num_pins)\n{\n\tstruct palmas_pctrl_chip_info *pci = pinctrl_dev_get_drvdata(pctldev);\n\n\t*pins = pci->pin_groups[group].pins;\n\t*num_pins = pci->pin_groups[group].npins;\n\treturn 0;\n}\n\nstatic const struct pinctrl_ops palmas_pinctrl_ops = {\n\t.get_groups_count = palmas_pinctrl_get_groups_count,\n\t.get_group_name = palmas_pinctrl_get_group_name,\n\t.get_group_pins = palmas_pinctrl_get_group_pins,\n\t.dt_node_to_map = pinconf_generic_dt_node_to_map_pin,\n\t.dt_free_map = pinctrl_utils_free_map,\n};\n\nstatic int palmas_pinctrl_get_funcs_count(struct pinctrl_dev *pctldev)\n{\n\tstruct palmas_pctrl_chip_info *pci = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pci->num_functions;\n}\n\nstatic const char *palmas_pinctrl_get_func_name(struct pinctrl_dev *pctldev,\n\t\t\tunsigned function)\n{\n\tstruct palmas_pctrl_chip_info *pci = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pci->functions[function].name;\n}\n\nstatic int palmas_pinctrl_get_func_groups(struct pinctrl_dev *pctldev,\n\t\tunsigned function, const char * const **groups,\n\t\tunsigned * const num_groups)\n{\n\tstruct palmas_pctrl_chip_info *pci = pinctrl_dev_get_drvdata(pctldev);\n\n\t*groups = pci->functions[function].groups;\n\t*num_groups = pci->functions[function].ngroups;\n\treturn 0;\n}\n\nstatic int palmas_pinctrl_set_mux(struct pinctrl_dev *pctldev,\n\t\tunsigned function,\n\t\tunsigned group)\n{\n\tstruct palmas_pctrl_chip_info *pci = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct palmas_pingroup *g;\n\tint i;\n\tint ret;\n\n\tg = &pci->pin_groups[group];\n\n\t \n\tif (function <= PALMAS_PINMUX_OPTION3) {\n\t\tif (!g->opt[function]) {\n\t\t\tdev_err(pci->dev, \"Pin %s does not support option %d\\n\",\n\t\t\t\tg->name, function);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ti = function;\n\t} else {\n\t\tfor (i = 0; i < ARRAY_SIZE(g->opt); i++) {\n\t\t\tif (!g->opt[i])\n\t\t\t\tcontinue;\n\t\t\tif (g->opt[i]->mux_opt == function)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (WARN_ON(i == ARRAY_SIZE(g->opt))) {\n\t\t\tdev_err(pci->dev, \"Pin %s does not support option %d\\n\",\n\t\t\t\tg->name, function);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (g->mux_reg_base == PALMAS_NONE_BASE) {\n\t\tif (WARN_ON(i != 0))\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n\n\tdev_dbg(pci->dev, \"%s(): Base0x%02x:0x%02x:0x%02x:0x%02x\\n\",\n\t\t\t__func__, g->mux_reg_base, g->mux_reg_add,\n\t\t\tg->mux_reg_mask, i << g->mux_bit_shift);\n\n\tret = palmas_update_bits(pci->palmas, g->mux_reg_base, g->mux_reg_add,\n\t\t\tg->mux_reg_mask, i << g->mux_bit_shift);\n\tif (ret < 0) {\n\t\tdev_err(pci->dev, \"Reg 0x%02x update failed: %d\\n\",\n\t\t\t\tg->mux_reg_add, ret);\n\t\treturn ret;\n\t}\n\tpci->pins_current_opt[group] = i;\n\treturn 0;\n}\n\nstatic const struct pinmux_ops palmas_pinmux_ops = {\n\t.get_functions_count = palmas_pinctrl_get_funcs_count,\n\t.get_function_name = palmas_pinctrl_get_func_name,\n\t.get_function_groups = palmas_pinctrl_get_func_groups,\n\t.set_mux = palmas_pinctrl_set_mux,\n};\n\nstatic int palmas_pinconf_get(struct pinctrl_dev *pctldev,\n\t\t\tunsigned pin, unsigned long *config)\n{\n\tstruct palmas_pctrl_chip_info *pci = pinctrl_dev_get_drvdata(pctldev);\n\tenum pin_config_param param = pinconf_to_config_param(*config);\n\tconst struct palmas_pingroup *g;\n\tconst struct palmas_pin_info *opt;\n\tunsigned int val;\n\tint ret;\n\tint base, add;\n\tint rval;\n\tint arg;\n\tint group_nr;\n\n\tfor (group_nr = 0; group_nr < pci->num_pin_groups; ++group_nr) {\n\t\tif (pci->pin_groups[group_nr].pins[0] == pin)\n\t\t\tbreak;\n\t}\n\n\tif (group_nr == pci->num_pin_groups) {\n\t\tdev_err(pci->dev,\n\t\t\t\"Pinconf is not supported for pin-id %d\\n\", pin);\n\t\treturn -ENOTSUPP;\n\t}\n\n\tg = &pci->pin_groups[group_nr];\n\topt = g->opt[pci->pins_current_opt[group_nr]];\n\tif (!opt) {\n\t\tdev_err(pci->dev,\n\t\t\t\"Pinconf is not supported for pin %s\\n\", g->name);\n\t\treturn -ENOTSUPP;\n\t}\n\n\tswitch (param) {\n\tcase PIN_CONFIG_BIAS_DISABLE:\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\tif (!opt->pud_info) {\n\t\t\tdev_err(pci->dev,\n\t\t\t\t\"PULL control not supported for pin %s\\n\",\n\t\t\t\tg->name);\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t\tbase = opt->pud_info->pullup_dn_reg_base;\n\t\tadd = opt->pud_info->pullup_dn_reg_add;\n\t\tret = palmas_read(pci->palmas, base, add, &val);\n\t\tif (ret < 0) {\n\t\t\tdev_err(pci->dev, \"Reg 0x%02x read failed: %d\\n\",\n\t\t\t\tadd, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\trval = val & opt->pud_info->pullup_dn_mask;\n\t\targ = 0;\n\t\tif ((opt->pud_info->normal_val >= 0) &&\n\t\t\t\t(opt->pud_info->normal_val == rval) &&\n\t\t\t\t(param == PIN_CONFIG_BIAS_DISABLE))\n\t\t\targ = 1;\n\t\telse if ((opt->pud_info->pull_up_val >= 0) &&\n\t\t\t\t(opt->pud_info->pull_up_val == rval) &&\n\t\t\t\t(param == PIN_CONFIG_BIAS_PULL_UP))\n\t\t\targ = 1;\n\t\telse if ((opt->pud_info->pull_dn_val >= 0) &&\n\t\t\t\t(opt->pud_info->pull_dn_val == rval) &&\n\t\t\t\t(param == PIN_CONFIG_BIAS_PULL_DOWN))\n\t\t\targ = 1;\n\t\tbreak;\n\n\tcase PIN_CONFIG_DRIVE_OPEN_DRAIN:\n\t\tif (!opt->od_info) {\n\t\t\tdev_err(pci->dev,\n\t\t\t\t\"OD control not supported for pin %s\\n\",\n\t\t\t\tg->name);\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t\tbase = opt->od_info->od_reg_base;\n\t\tadd = opt->od_info->od_reg_add;\n\t\tret = palmas_read(pci->palmas, base, add, &val);\n\t\tif (ret < 0) {\n\t\t\tdev_err(pci->dev, \"Reg 0x%02x read failed: %d\\n\",\n\t\t\t\tadd, ret);\n\t\t\treturn ret;\n\t\t}\n\t\trval = val & opt->od_info->od_mask;\n\t\targ = -1;\n\t\tif ((opt->od_info->od_disable >= 0) &&\n\t\t\t\t(opt->od_info->od_disable == rval))\n\t\t\targ = 0;\n\t\telse if ((opt->od_info->od_enable >= 0) &&\n\t\t\t\t\t(opt->od_info->od_enable == rval))\n\t\t\targ = 1;\n\t\tif (arg < 0) {\n\t\t\tdev_err(pci->dev,\n\t\t\t\t\"OD control not supported for pin %s\\n\",\n\t\t\t\tg->name);\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(pci->dev, \"Properties not supported\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\t*config = pinconf_to_config_packed(param, (u16)arg);\n\treturn 0;\n}\n\nstatic int palmas_pinconf_set(struct pinctrl_dev *pctldev,\n\t\t\tunsigned pin, unsigned long *configs,\n\t\t\tunsigned num_configs)\n{\n\tstruct palmas_pctrl_chip_info *pci = pinctrl_dev_get_drvdata(pctldev);\n\tenum pin_config_param param;\n\tu32 param_val;\n\tconst struct palmas_pingroup *g;\n\tconst struct palmas_pin_info *opt;\n\tint ret;\n\tint base, add, mask;\n\tint rval;\n\tint group_nr;\n\tint i;\n\n\tfor (group_nr = 0; group_nr < pci->num_pin_groups; ++group_nr) {\n\t\tif (pci->pin_groups[group_nr].pins[0] == pin)\n\t\t\tbreak;\n\t}\n\n\tif (group_nr == pci->num_pin_groups) {\n\t\tdev_err(pci->dev,\n\t\t\t\"Pinconf is not supported for pin-id %d\\n\", pin);\n\t\treturn -ENOTSUPP;\n\t}\n\n\tg = &pci->pin_groups[group_nr];\n\topt = g->opt[pci->pins_current_opt[group_nr]];\n\tif (!opt) {\n\t\tdev_err(pci->dev,\n\t\t\t\"Pinconf is not supported for pin %s\\n\", g->name);\n\t\treturn -ENOTSUPP;\n\t}\n\n\tfor (i = 0; i < num_configs; i++) {\n\t\tparam = pinconf_to_config_param(configs[i]);\n\t\tparam_val = pinconf_to_config_argument(configs[i]);\n\n\t\tswitch (param) {\n\t\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\t\tif (!opt->pud_info) {\n\t\t\t\tdev_err(pci->dev,\n\t\t\t\t\t\"PULL control not supported for pin %s\\n\",\n\t\t\t\t\tg->name);\n\t\t\t\treturn -ENOTSUPP;\n\t\t\t}\n\t\t\tbase = opt->pud_info->pullup_dn_reg_base;\n\t\t\tadd = opt->pud_info->pullup_dn_reg_add;\n\t\t\tmask = opt->pud_info->pullup_dn_mask;\n\n\t\t\tif (param == PIN_CONFIG_BIAS_DISABLE)\n\t\t\t\trval = opt->pud_info->normal_val;\n\t\t\telse if (param == PIN_CONFIG_BIAS_PULL_UP)\n\t\t\t\trval = opt->pud_info->pull_up_val;\n\t\t\telse\n\t\t\t\trval = opt->pud_info->pull_dn_val;\n\n\t\t\tif (rval < 0) {\n\t\t\t\tdev_err(pci->dev,\n\t\t\t\t\t\"PULL control not supported for pin %s\\n\",\n\t\t\t\t\tg->name);\n\t\t\t\treturn -ENOTSUPP;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase PIN_CONFIG_DRIVE_OPEN_DRAIN:\n\t\t\tif (!opt->od_info) {\n\t\t\t\tdev_err(pci->dev,\n\t\t\t\t\t\"OD control not supported for pin %s\\n\",\n\t\t\t\t\tg->name);\n\t\t\t\treturn -ENOTSUPP;\n\t\t\t}\n\t\t\tbase = opt->od_info->od_reg_base;\n\t\t\tadd = opt->od_info->od_reg_add;\n\t\t\tmask = opt->od_info->od_mask;\n\t\t\tif (param_val == 0)\n\t\t\t\trval = opt->od_info->od_disable;\n\t\t\telse\n\t\t\t\trval = opt->od_info->od_enable;\n\t\t\tif (rval < 0) {\n\t\t\t\tdev_err(pci->dev,\n\t\t\t\t\t\"OD control not supported for pin %s\\n\",\n\t\t\t\t\tg->name);\n\t\t\t\treturn -ENOTSUPP;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(pci->dev, \"Properties not supported\\n\");\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\n\t\tdev_dbg(pci->dev, \"%s(): Add0x%02x:0x%02x:0x%02x:0x%02x\\n\",\n\t\t\t\t__func__, base, add, mask, rval);\n\t\tret = palmas_update_bits(pci->palmas, base, add, mask, rval);\n\t\tif (ret < 0) {\n\t\t\tdev_err(pci->dev, \"Reg 0x%02x update failed: %d\\n\",\n\t\t\t\tadd, ret);\n\t\t\treturn ret;\n\t\t}\n\t}  \n\n\treturn 0;\n}\n\nstatic const struct pinconf_ops palmas_pinconf_ops = {\n\t.pin_config_get = palmas_pinconf_get,\n\t.pin_config_set = palmas_pinconf_set,\n};\n\nstatic struct pinctrl_desc palmas_pinctrl_desc = {\n\t.pctlops = &palmas_pinctrl_ops,\n\t.pmxops = &palmas_pinmux_ops,\n\t.confops = &palmas_pinconf_ops,\n\t.owner = THIS_MODULE,\n};\n\nstruct palmas_pinctrl_data {\n\tconst struct palmas_pingroup *pin_groups;\n\tint num_pin_groups;\n};\n\nstatic struct palmas_pinctrl_data tps65913_pinctrl_data = {\n\t.pin_groups = tps65913_pingroups,\n\t.num_pin_groups = ARRAY_SIZE(tps65913_pingroups),\n};\n\nstatic struct palmas_pinctrl_data tps80036_pinctrl_data = {\n\t.pin_groups = tps80036_pingroups,\n\t.num_pin_groups = ARRAY_SIZE(tps80036_pingroups),\n};\n\nstatic const struct of_device_id palmas_pinctrl_of_match[] = {\n\t{ .compatible = \"ti,palmas-pinctrl\", .data = &tps65913_pinctrl_data},\n\t{ .compatible = \"ti,tps65913-pinctrl\", .data = &tps65913_pinctrl_data},\n\t{ .compatible = \"ti,tps80036-pinctrl\", .data = &tps80036_pinctrl_data},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, palmas_pinctrl_of_match);\n\nstatic int palmas_pinctrl_probe(struct platform_device *pdev)\n{\n\tstruct palmas_pctrl_chip_info *pci;\n\tconst struct palmas_pinctrl_data *pinctrl_data = &tps65913_pinctrl_data;\n\tint ret;\n\tbool enable_dvfs1 = false;\n\tbool enable_dvfs2 = false;\n\n\tif (pdev->dev.of_node) {\n\t\tpinctrl_data = of_device_get_match_data(&pdev->dev);\n\t\tenable_dvfs1 = of_property_read_bool(pdev->dev.of_node,\n\t\t\t\t\t\"ti,palmas-enable-dvfs1\");\n\t\tenable_dvfs2 = of_property_read_bool(pdev->dev.of_node,\n\t\t\t\t\t\"ti,palmas-enable-dvfs2\");\n\t}\n\n\tpci = devm_kzalloc(&pdev->dev, sizeof(*pci), GFP_KERNEL);\n\tif (!pci)\n\t\treturn -ENOMEM;\n\n\tpci->dev = &pdev->dev;\n\tpci->palmas = dev_get_drvdata(pdev->dev.parent);\n\n\tpci->pins = palmas_pins_desc;\n\tpci->num_pins = ARRAY_SIZE(palmas_pins_desc);\n\tpci->functions = palmas_pin_function;\n\tpci->num_functions = ARRAY_SIZE(palmas_pin_function);\n\tpci->pin_groups = pinctrl_data->pin_groups;\n\tpci->num_pin_groups = pinctrl_data->num_pin_groups;\n\n\tplatform_set_drvdata(pdev, pci);\n\n\tpalmas_pinctrl_set_dvfs1(pci, enable_dvfs1);\n\tpalmas_pinctrl_set_dvfs2(pci, enable_dvfs2);\n\tret = palmas_pinctrl_get_pin_mux(pci);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Reading pinctrol option register failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpalmas_pinctrl_desc.name = dev_name(&pdev->dev);\n\tpalmas_pinctrl_desc.pins = palmas_pins_desc;\n\tpalmas_pinctrl_desc.npins = ARRAY_SIZE(palmas_pins_desc);\n\tpci->pctl = devm_pinctrl_register(&pdev->dev, &palmas_pinctrl_desc,\n\t\t\t\t\t  pci);\n\tif (IS_ERR(pci->pctl)) {\n\t\tdev_err(&pdev->dev, \"Couldn't register pinctrl driver\\n\");\n\t\treturn PTR_ERR(pci->pctl);\n\t}\n\treturn 0;\n}\n\nstatic struct platform_driver palmas_pinctrl_driver = {\n\t.driver = {\n\t\t.name = \"palmas-pinctrl\",\n\t\t.of_match_table = palmas_pinctrl_of_match,\n\t},\n\t.probe = palmas_pinctrl_probe,\n};\n\nmodule_platform_driver(palmas_pinctrl_driver);\n\nMODULE_DESCRIPTION(\"Palmas pin control driver\");\nMODULE_AUTHOR(\"Laxman Dewangan<ldewangan@nvidia.com>\");\nMODULE_ALIAS(\"platform:palmas-pinctrl\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}