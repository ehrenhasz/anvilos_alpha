{
  "module_name": "pinctrl-common.c",
  "hash_id": "428c572a7dcb86f21fb66648f77a2cc906ef52d7f56b18b329fcee3139eb7ba0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/visconti/pinctrl-common.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/platform_device.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinmux.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinconf-generic.h>\n#include \"pinctrl-common.h\"\n#include \"../core.h\"\n#include \"../pinconf.h\"\n#include \"../pinctrl-utils.h\"\n\n#define DSEL_MASK GENMASK(3, 0)\n\n \nstruct visconti_pinctrl {\n\tvoid __iomem *base;\n\tstruct device *dev;\n\tstruct pinctrl_dev *pctl;\n\tstruct pinctrl_desc pctl_desc;\n\n\tconst struct visconti_pinctrl_devdata  *devdata;\n\n\tspinlock_t lock;  \n};\n\n \nstatic int visconti_pin_config_set(struct pinctrl_dev *pctldev,\n\t\t\t\t  unsigned int _pin,\n\t\t\t\t  unsigned long *configs,\n\t\t\t\t  unsigned int num_configs)\n{\n\tstruct visconti_pinctrl *priv = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct visconti_desc_pin *pin = &priv->devdata->pins[_pin];\n\tenum pin_config_param param;\n\tunsigned int arg;\n\tint i, ret = 0;\n\tunsigned int val, set_val, pude_val;\n\tunsigned long flags;\n\n\tdev_dbg(priv->dev, \"%s: pin = %d (%s)\\n\", __func__, _pin, pin->pin.name);\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tfor (i = 0; i < num_configs; i++) {\n\t\tset_val = 0;\n\t\tpude_val = 0;\n\n\t\tparam = pinconf_to_config_param(configs[i]);\n\t\tswitch (param) {\n\t\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\t\tset_val = 1;\n\t\t\tfallthrough;\n\t\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\t\t \n\t\t\tval = readl(priv->base + pin->pudsel_offset);\n\t\t\tval &= ~BIT(pin->pud_shift);\n\t\t\tval |= set_val << pin->pud_shift;\n\t\t\twritel(val, priv->base + pin->pudsel_offset);\n\t\t\tpude_val = 1;\n\t\t\tfallthrough;\n\t\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\t\t \n\t\t\tval = readl(priv->base + pin->pude_offset);\n\t\t\tval &= ~BIT(pin->pud_shift);\n\t\t\tval |= pude_val << pin->pud_shift;\n\t\t\twritel(val, priv->base + pin->pude_offset);\n\t\t\tdev_dbg(priv->dev, \"BIAS(%d): off = 0x%x val = 0x%x\\n\",\n\t\t\t\tparam, pin->pude_offset, val);\n\t\t\tbreak;\n\n\t\tcase PIN_CONFIG_DRIVE_STRENGTH:\n\t\t\targ = pinconf_to_config_argument(configs[i]);\n\t\t\tdev_dbg(priv->dev, \"DRV_STR arg = %d\\n\", arg);\n\t\t\tswitch (arg) {\n\t\t\tcase 2:\n\t\t\tcase 4:\n\t\t\tcase 8:\n\t\t\tcase 16:\n\t\t\tcase 24:\n\t\t\tcase 32:\n\t\t\t\t \n\t\t\t\tset_val = DIV_ROUND_CLOSEST(arg, 2) - 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\t \n\t\t\tval = readl(priv->base + pin->dsel_offset);\n\t\t\tval &= ~(DSEL_MASK << pin->dsel_shift);\n\t\t\tval |= set_val << pin->dsel_shift;\n\t\t\twritel(val, priv->base + pin->dsel_offset);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto err;\n\t\t}\n\t}\nerr:\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\treturn ret;\n}\n\nstatic int visconti_pin_config_group_set(struct pinctrl_dev *pctldev,\n\t\t\t\t\tunsigned int selector,\n\t\t\t\t\tunsigned long *configs,\n\t\t\t\t\tunsigned int num_configs)\n{\n\tstruct visconti_pinctrl *priv = pinctrl_dev_get_drvdata(pctldev);\n\tconst unsigned int *pins;\n\tunsigned int num_pins;\n\tint i, ret;\n\n\tpins = priv->devdata->groups[selector].pins;\n\tnum_pins = priv->devdata->groups[selector].nr_pins;\n\n\tdev_dbg(priv->dev, \"%s: select = %d, n_pin = %d, n_config = %d\\n\",\n\t\t__func__, selector, num_pins, num_configs);\n\n\tfor (i = 0; i < num_pins; i++) {\n\t\tret = visconti_pin_config_set(pctldev, pins[i],\n\t\t\t\t\t     configs, num_configs);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nstatic const struct pinconf_ops visconti_pinconf_ops = {\n\t.is_generic\t\t\t= true,\n\t.pin_config_set\t\t\t= visconti_pin_config_set,\n\t.pin_config_group_set\t\t= visconti_pin_config_group_set,\n\t.pin_config_config_dbg_show\t= pinconf_generic_dump_config,\n};\n\n \nstatic int visconti_get_groups_count(struct pinctrl_dev *pctldev)\n{\n\tstruct visconti_pinctrl *priv = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn priv->devdata->nr_groups;\n}\n\nstatic const char *visconti_get_group_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t      unsigned int selector)\n{\n\tstruct visconti_pinctrl *priv = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn priv->devdata->groups[selector].name;\n}\n\nstatic int visconti_get_group_pins(struct pinctrl_dev *pctldev,\n\t\t\t\t      unsigned int selector,\n\t\t\t\t      const unsigned int **pins,\n\t\t\t\t      unsigned int *num_pins)\n{\n\tstruct visconti_pinctrl *priv = pinctrl_dev_get_drvdata(pctldev);\n\n\t*pins = priv->devdata->groups[selector].pins;\n\t*num_pins = priv->devdata->groups[selector].nr_pins;\n\n\treturn 0;\n}\n\nstatic const struct pinctrl_ops visconti_pinctrl_ops = {\n\t.get_groups_count\t= visconti_get_groups_count,\n\t.get_group_name\t\t= visconti_get_group_name,\n\t.get_group_pins\t\t= visconti_get_group_pins,\n\t.dt_node_to_map\t\t= pinconf_generic_dt_node_to_map_group,\n\t.dt_free_map\t\t= pinctrl_utils_free_map,\n};\n\n \nstatic int visconti_get_functions_count(struct pinctrl_dev *pctldev)\n{\n\tstruct visconti_pinctrl *priv = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn priv->devdata->nr_functions;\n}\n\nstatic const char *visconti_get_function_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t     unsigned int selector)\n{\n\tstruct visconti_pinctrl *priv = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn priv->devdata->functions[selector].name;\n}\n\nstatic int visconti_get_function_groups(struct pinctrl_dev *pctldev,\n\t\t\t\t       unsigned int selector,\n\t\t\t\t       const char * const **groups,\n\t\t\t\t       unsigned * const num_groups)\n{\n\tstruct visconti_pinctrl *priv = pinctrl_dev_get_drvdata(pctldev);\n\n\t*groups = priv->devdata->functions[selector].groups;\n\t*num_groups = priv->devdata->functions[selector].nr_groups;\n\n\treturn 0;\n}\n\nstatic int visconti_set_mux(struct pinctrl_dev *pctldev,\n\t\t\t   unsigned int function, unsigned int group)\n{\n\tstruct visconti_pinctrl *priv = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct visconti_pin_function *func = &priv->devdata->functions[function];\n\tconst struct visconti_pin_group *grp = &priv->devdata->groups[group];\n\tconst struct visconti_mux *mux = &grp->mux;\n\tunsigned int val;\n\tunsigned long flags;\n\n\tdev_dbg(priv->dev, \"%s: function = %d(%s) group = %d(%s)\\n\", __func__,\n\t\tfunction, func->name, group, grp->name);\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\t \n\tval = readl(priv->base + mux->offset);\n\tval &= ~mux->mask;\n\tval |= mux->val;\n\twritel(val, priv->base + mux->offset);\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\tdev_dbg(priv->dev, \"[%x]: 0x%x\\n\", mux->offset, val);\n\n\treturn 0;\n}\n\nstatic int visconti_gpio_request_enable(struct pinctrl_dev *pctldev,\n\t\t\t\t      struct pinctrl_gpio_range *range,\n\t\t\t\t      unsigned int pin)\n{\n\tstruct visconti_pinctrl *priv = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct visconti_mux *gpio_mux = &priv->devdata->gpio_mux[pin];\n\tunsigned long flags;\n\tunsigned int val;\n\n\tdev_dbg(priv->dev, \"%s: pin = %d\\n\", __func__, pin);\n\n\t \n\tspin_lock_irqsave(&priv->lock, flags);\n\tval = readl(priv->base + gpio_mux->offset);\n\tval &= ~gpio_mux->mask;\n\tval |= gpio_mux->val;\n\twritel(val, priv->base + gpio_mux->offset);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct pinmux_ops visconti_pinmux_ops = {\n\t.get_functions_count\t= visconti_get_functions_count,\n\t.get_function_name\t= visconti_get_function_name,\n\t.get_function_groups\t= visconti_get_function_groups,\n\t.set_mux\t\t= visconti_set_mux,\n\t.gpio_request_enable\t= visconti_gpio_request_enable,\n\t.strict\t\t\t= true,\n};\n\nint visconti_pinctrl_probe(struct platform_device *pdev,\n\t\t\t  const struct visconti_pinctrl_devdata *devdata)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct visconti_pinctrl *priv;\n\tstruct pinctrl_pin_desc *pins;\n\tint i, ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->dev = dev;\n\tpriv->devdata = devdata;\n\tspin_lock_init(&priv->lock);\n\n\tpriv->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->base)) {\n\t\tdev_err(dev, \"unable to map I/O space\\n\");\n\t\treturn PTR_ERR(priv->base);\n\t}\n\n\tpins = devm_kcalloc(dev, devdata->nr_pins,\n\t\t\t    sizeof(*pins), GFP_KERNEL);\n\tif (!pins)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < devdata->nr_pins; i++)\n\t\tpins[i] = devdata->pins[i].pin;\n\n\tpriv->pctl_desc.name = dev_name(dev);\n\tpriv->pctl_desc.owner = THIS_MODULE;\n\tpriv->pctl_desc.pins = pins;\n\tpriv->pctl_desc.npins = devdata->nr_pins;\n\tpriv->pctl_desc.confops = &visconti_pinconf_ops;\n\tpriv->pctl_desc.pctlops = &visconti_pinctrl_ops;\n\tpriv->pctl_desc.pmxops = &visconti_pinmux_ops;\n\n\tret = devm_pinctrl_register_and_init(dev, &priv->pctl_desc,\n\t\t\t\t\t     priv, &priv->pctl);\n\tif (ret) {\n\t\tdev_err(dev, \"couldn't register pinctrl: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (devdata->unlock)\n\t\tdevdata->unlock(priv->base);\n\n\treturn pinctrl_enable(priv->pctl);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}