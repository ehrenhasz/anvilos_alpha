{
  "module_name": "pinctrl-microchip-sgpio.c",
  "hash_id": "853b1bfad20eff27b9dffcaf67a16e6ba788e98094f58b9e7cd63d5147eb0556",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/pinctrl-microchip-sgpio.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bits.h>\n#include <linux/clk.h>\n#include <linux/gpio/driver.h>\n#include <linux/io.h>\n#include <linux/mfd/ocelot.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n#include <linux/spinlock.h>\n\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinmux.h>\n\n#include \"core.h\"\n#include \"pinconf.h\"\n\n#define SGPIO_BITS_PER_WORD\t32\n#define SGPIO_MAX_BITS\t\t4\n#define SGPIO_SRC_BITS\t\t3  \n\nenum {\n\tREG_INPUT_DATA,\n\tREG_PORT_CONFIG,\n\tREG_PORT_ENABLE,\n\tREG_SIO_CONFIG,\n\tREG_SIO_CLOCK,\n\tREG_INT_POLARITY,\n\tREG_INT_TRIGGER,\n\tREG_INT_ACK,\n\tREG_INT_ENABLE,\n\tREG_INT_IDENT,\n\tMAXREG\n};\n\nenum {\n\tSGPIO_ARCH_LUTON,\n\tSGPIO_ARCH_OCELOT,\n\tSGPIO_ARCH_SPARX5,\n};\n\nenum {\n\tSGPIO_FLAGS_HAS_IRQ\t= BIT(0),\n};\n\nstruct sgpio_properties {\n\tint arch;\n\tint flags;\n\tu8 regoff[MAXREG];\n};\n\n#define SGPIO_LUTON_AUTO_REPEAT  BIT(5)\n#define SGPIO_LUTON_PORT_WIDTH   GENMASK(3, 2)\n#define SGPIO_LUTON_CLK_FREQ     GENMASK(11, 0)\n#define SGPIO_LUTON_BIT_SOURCE   GENMASK(11, 0)\n\n#define SGPIO_OCELOT_AUTO_REPEAT BIT(10)\n#define SGPIO_OCELOT_SINGLE_SHOT BIT(11)\n#define SGPIO_OCELOT_PORT_WIDTH  GENMASK(8, 7)\n#define SGPIO_OCELOT_CLK_FREQ    GENMASK(19, 8)\n#define SGPIO_OCELOT_BIT_SOURCE  GENMASK(23, 12)\n\n#define SGPIO_SPARX5_AUTO_REPEAT BIT(6)\n#define SGPIO_SPARX5_SINGLE_SHOT BIT(7)\n#define SGPIO_SPARX5_PORT_WIDTH  GENMASK(4, 3)\n#define SGPIO_SPARX5_CLK_FREQ    GENMASK(19, 8)\n#define SGPIO_SPARX5_BIT_SOURCE  GENMASK(23, 12)\n\n#define SGPIO_MASTER_INTR_ENA    BIT(0)\n\n#define SGPIO_INT_TRG_LEVEL\t0\n#define SGPIO_INT_TRG_EDGE\t1\n#define SGPIO_INT_TRG_EDGE_FALL\t2\n#define SGPIO_INT_TRG_EDGE_RISE\t3\n\n#define SGPIO_TRG_LEVEL_HIGH\t0\n#define SGPIO_TRG_LEVEL_LOW\t1\n\nstatic const struct sgpio_properties properties_luton = {\n\t.arch   = SGPIO_ARCH_LUTON,\n\t.regoff = { 0x00, 0x09, 0x29, 0x2a, 0x2b },\n};\n\nstatic const struct sgpio_properties properties_ocelot = {\n\t.arch   = SGPIO_ARCH_OCELOT,\n\t.regoff = { 0x00, 0x06, 0x26, 0x04, 0x05 },\n};\n\nstatic const struct sgpio_properties properties_sparx5 = {\n\t.arch   = SGPIO_ARCH_SPARX5,\n\t.flags  = SGPIO_FLAGS_HAS_IRQ,\n\t.regoff = { 0x00, 0x06, 0x26, 0x04, 0x05, 0x2a, 0x32, 0x3a, 0x3e, 0x42 },\n};\n\nstatic const char * const functions[] = { \"gpio\" };\n\nstruct sgpio_bank {\n\tstruct sgpio_priv *priv;\n\tbool is_input;\n\tstruct gpio_chip gpio;\n\tstruct pinctrl_desc pctl_desc;\n};\n\nstruct sgpio_priv {\n\tstruct device *dev;\n\tstruct sgpio_bank in;\n\tstruct sgpio_bank out;\n\tu32 bitcount;\n\tu32 ports;\n\tu32 clock;\n\tstruct regmap *regs;\n\tconst struct sgpio_properties *properties;\n\tspinlock_t lock;\n\t \n\tstruct mutex poll_lock;\n};\n\nstruct sgpio_port_addr {\n\tu8 port;\n\tu8 bit;\n};\n\nstatic inline void sgpio_pin_to_addr(struct sgpio_priv *priv, int pin,\n\t\t\t\t     struct sgpio_port_addr *addr)\n{\n\taddr->port = pin / priv->bitcount;\n\taddr->bit = pin % priv->bitcount;\n}\n\nstatic inline int sgpio_addr_to_pin(struct sgpio_priv *priv, int port, int bit)\n{\n\treturn bit + port * priv->bitcount;\n}\n\nstatic inline u32 sgpio_get_addr(struct sgpio_priv *priv, u32 rno, u32 off)\n{\n\treturn (priv->properties->regoff[rno] + off) *\n\t\tregmap_get_reg_stride(priv->regs);\n}\n\nstatic u32 sgpio_readl(struct sgpio_priv *priv, u32 rno, u32 off)\n{\n\tu32 addr = sgpio_get_addr(priv, rno, off);\n\tu32 val = 0;\n\tint ret;\n\n\tret = regmap_read(priv->regs, addr, &val);\n\tWARN_ONCE(ret, \"error reading sgpio reg %d\\n\", ret);\n\n\treturn val;\n}\n\nstatic void sgpio_writel(struct sgpio_priv *priv,\n\t\t\t\tu32 val, u32 rno, u32 off)\n{\n\tu32 addr = sgpio_get_addr(priv, rno, off);\n\tint ret;\n\n\tret = regmap_write(priv->regs, addr, val);\n\tWARN_ONCE(ret, \"error writing sgpio reg %d\\n\", ret);\n}\n\nstatic inline void sgpio_clrsetbits(struct sgpio_priv *priv,\n\t\t\t\t    u32 rno, u32 off, u32 clear, u32 set)\n{\n\tu32 addr = sgpio_get_addr(priv, rno, off);\n\tint ret;\n\n\tret = regmap_update_bits(priv->regs, addr, clear | set, set);\n\tWARN_ONCE(ret, \"error updating sgpio reg %d\\n\", ret);\n}\n\nstatic inline void sgpio_configure_bitstream(struct sgpio_priv *priv)\n{\n\tint width = priv->bitcount - 1;\n\tu32 clr, set;\n\n\tswitch (priv->properties->arch) {\n\tcase SGPIO_ARCH_LUTON:\n\t\tclr = SGPIO_LUTON_PORT_WIDTH;\n\t\tset = SGPIO_LUTON_AUTO_REPEAT |\n\t\t\tFIELD_PREP(SGPIO_LUTON_PORT_WIDTH, width);\n\t\tbreak;\n\tcase SGPIO_ARCH_OCELOT:\n\t\tclr = SGPIO_OCELOT_PORT_WIDTH;\n\t\tset = SGPIO_OCELOT_AUTO_REPEAT |\n\t\t\tFIELD_PREP(SGPIO_OCELOT_PORT_WIDTH, width);\n\t\tbreak;\n\tcase SGPIO_ARCH_SPARX5:\n\t\tclr = SGPIO_SPARX5_PORT_WIDTH;\n\t\tset = SGPIO_SPARX5_AUTO_REPEAT |\n\t\t\tFIELD_PREP(SGPIO_SPARX5_PORT_WIDTH, width);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\tsgpio_clrsetbits(priv, REG_SIO_CONFIG, 0, clr, set);\n}\n\nstatic inline void sgpio_configure_clock(struct sgpio_priv *priv, u32 clkfrq)\n{\n\tu32 clr, set;\n\n\tswitch (priv->properties->arch) {\n\tcase SGPIO_ARCH_LUTON:\n\t\tclr = SGPIO_LUTON_CLK_FREQ;\n\t\tset = FIELD_PREP(SGPIO_LUTON_CLK_FREQ, clkfrq);\n\t\tbreak;\n\tcase SGPIO_ARCH_OCELOT:\n\t\tclr = SGPIO_OCELOT_CLK_FREQ;\n\t\tset = FIELD_PREP(SGPIO_OCELOT_CLK_FREQ, clkfrq);\n\t\tbreak;\n\tcase SGPIO_ARCH_SPARX5:\n\t\tclr = SGPIO_SPARX5_CLK_FREQ;\n\t\tset = FIELD_PREP(SGPIO_SPARX5_CLK_FREQ, clkfrq);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\tsgpio_clrsetbits(priv, REG_SIO_CLOCK, 0, clr, set);\n}\n\nstatic int sgpio_single_shot(struct sgpio_priv *priv)\n{\n\tu32 addr = sgpio_get_addr(priv, REG_SIO_CONFIG, 0);\n\tint ret, ret2;\n\tu32 ctrl;\n\tunsigned int single_shot;\n\tunsigned int auto_repeat;\n\n\tswitch (priv->properties->arch) {\n\tcase SGPIO_ARCH_LUTON:\n\t\t \n\t\treturn 0;\n\tcase SGPIO_ARCH_OCELOT:\n\t\tsingle_shot = SGPIO_OCELOT_SINGLE_SHOT;\n\t\tauto_repeat = SGPIO_OCELOT_AUTO_REPEAT;\n\t\tbreak;\n\tcase SGPIO_ARCH_SPARX5:\n\t\tsingle_shot = SGPIO_SPARX5_SINGLE_SHOT;\n\t\tauto_repeat = SGPIO_SPARX5_AUTO_REPEAT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tmutex_lock(&priv->poll_lock);\n\tret = regmap_update_bits(priv->regs, addr, single_shot | auto_repeat,\n\t\t\t\t single_shot);\n\tif (ret)\n\t\tgoto out;\n\n\tret = regmap_read_poll_timeout(priv->regs, addr, ctrl,\n\t\t\t\t       !(ctrl & single_shot), 100, 60000);\n\n\t \n\tret2 = regmap_update_bits(priv->regs, addr, auto_repeat, auto_repeat);\nout:\n\tmutex_unlock(&priv->poll_lock);\n\n\treturn ret ?: ret2;\n}\n\nstatic int sgpio_output_set(struct sgpio_priv *priv,\n\t\t\t    struct sgpio_port_addr *addr,\n\t\t\t    int value)\n{\n\tunsigned int bit = SGPIO_SRC_BITS * addr->bit;\n\tu32 reg = sgpio_get_addr(priv, REG_PORT_CONFIG, addr->port);\n\tbool changed;\n\tu32 clr, set;\n\tint ret;\n\n\tswitch (priv->properties->arch) {\n\tcase SGPIO_ARCH_LUTON:\n\t\tclr = FIELD_PREP(SGPIO_LUTON_BIT_SOURCE, BIT(bit));\n\t\tset = FIELD_PREP(SGPIO_LUTON_BIT_SOURCE, value << bit);\n\t\tbreak;\n\tcase SGPIO_ARCH_OCELOT:\n\t\tclr = FIELD_PREP(SGPIO_OCELOT_BIT_SOURCE, BIT(bit));\n\t\tset = FIELD_PREP(SGPIO_OCELOT_BIT_SOURCE, value << bit);\n\t\tbreak;\n\tcase SGPIO_ARCH_SPARX5:\n\t\tclr = FIELD_PREP(SGPIO_SPARX5_BIT_SOURCE, BIT(bit));\n\t\tset = FIELD_PREP(SGPIO_SPARX5_BIT_SOURCE, value << bit);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = regmap_update_bits_check(priv->regs, reg, clr | set, set,\n\t\t\t\t       &changed);\n\tif (ret)\n\t\treturn ret;\n\n\tif (changed) {\n\t\tret = sgpio_single_shot(priv);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int sgpio_output_get(struct sgpio_priv *priv,\n\t\t\t    struct sgpio_port_addr *addr)\n{\n\tu32 val, portval = sgpio_readl(priv, REG_PORT_CONFIG, addr->port);\n\tunsigned int bit = SGPIO_SRC_BITS * addr->bit;\n\n\tswitch (priv->properties->arch) {\n\tcase SGPIO_ARCH_LUTON:\n\t\tval = FIELD_GET(SGPIO_LUTON_BIT_SOURCE, portval);\n\t\tbreak;\n\tcase SGPIO_ARCH_OCELOT:\n\t\tval = FIELD_GET(SGPIO_OCELOT_BIT_SOURCE, portval);\n\t\tbreak;\n\tcase SGPIO_ARCH_SPARX5:\n\t\tval = FIELD_GET(SGPIO_SPARX5_BIT_SOURCE, portval);\n\t\tbreak;\n\tdefault:\n\t\tval = 0;\n\t\tbreak;\n\t}\n\treturn !!(val & BIT(bit));\n}\n\nstatic int sgpio_input_get(struct sgpio_priv *priv,\n\t\t\t   struct sgpio_port_addr *addr)\n{\n\treturn !!(sgpio_readl(priv, REG_INPUT_DATA, addr->bit) & BIT(addr->port));\n}\n\nstatic int sgpio_pinconf_get(struct pinctrl_dev *pctldev,\n\t\t\t     unsigned int pin, unsigned long *config)\n{\n\tstruct sgpio_bank *bank = pinctrl_dev_get_drvdata(pctldev);\n\tu32 param = pinconf_to_config_param(*config);\n\tstruct sgpio_priv *priv = bank->priv;\n\tstruct sgpio_port_addr addr;\n\tint val;\n\n\tsgpio_pin_to_addr(priv, pin, &addr);\n\n\tswitch (param) {\n\tcase PIN_CONFIG_INPUT_ENABLE:\n\t\tval = bank->is_input;\n\t\tbreak;\n\n\tcase PIN_CONFIG_OUTPUT_ENABLE:\n\t\tval = !bank->is_input;\n\t\tbreak;\n\n\tcase PIN_CONFIG_OUTPUT:\n\t\tif (bank->is_input)\n\t\t\treturn -EINVAL;\n\t\tval = sgpio_output_get(priv, &addr);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\t*config = pinconf_to_config_packed(param, val);\n\n\treturn 0;\n}\n\nstatic int sgpio_pinconf_set(struct pinctrl_dev *pctldev, unsigned int pin,\n\t\t\t     unsigned long *configs, unsigned int num_configs)\n{\n\tstruct sgpio_bank *bank = pinctrl_dev_get_drvdata(pctldev);\n\tstruct sgpio_priv *priv = bank->priv;\n\tstruct sgpio_port_addr addr;\n\tint cfg, err = 0;\n\tu32 param, arg;\n\n\tsgpio_pin_to_addr(priv, pin, &addr);\n\n\tfor (cfg = 0; cfg < num_configs; cfg++) {\n\t\tparam = pinconf_to_config_param(configs[cfg]);\n\t\targ = pinconf_to_config_argument(configs[cfg]);\n\n\t\tswitch (param) {\n\t\tcase PIN_CONFIG_OUTPUT:\n\t\t\tif (bank->is_input)\n\t\t\t\treturn -EINVAL;\n\t\t\terr = sgpio_output_set(priv, &addr, arg);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\terr = -ENOTSUPP;\n\t\t}\n\t}\n\n\treturn err;\n}\n\nstatic const struct pinconf_ops sgpio_confops = {\n\t.is_generic = true,\n\t.pin_config_get = sgpio_pinconf_get,\n\t.pin_config_set = sgpio_pinconf_set,\n\t.pin_config_config_dbg_show = pinconf_generic_dump_config,\n};\n\nstatic int sgpio_get_functions_count(struct pinctrl_dev *pctldev)\n{\n\treturn 1;\n}\n\nstatic const char *sgpio_get_function_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t   unsigned int function)\n{\n\treturn functions[0];\n}\n\nstatic int sgpio_get_function_groups(struct pinctrl_dev *pctldev,\n\t\t\t\t     unsigned int function,\n\t\t\t\t     const char *const **groups,\n\t\t\t\t     unsigned *const num_groups)\n{\n\t*groups  = functions;\n\t*num_groups = ARRAY_SIZE(functions);\n\n\treturn 0;\n}\n\nstatic int sgpio_pinmux_set_mux(struct pinctrl_dev *pctldev,\n\t\t\t\tunsigned int selector, unsigned int group)\n{\n\treturn 0;\n}\n\nstatic int sgpio_gpio_set_direction(struct pinctrl_dev *pctldev,\n\t\t\t\t    struct pinctrl_gpio_range *range,\n\t\t\t\t    unsigned int pin, bool input)\n{\n\tstruct sgpio_bank *bank = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn (input == bank->is_input) ? 0 : -EINVAL;\n}\n\nstatic int sgpio_gpio_request_enable(struct pinctrl_dev *pctldev,\n\t\t\t\t     struct pinctrl_gpio_range *range,\n\t\t\t\t     unsigned int offset)\n{\n\tstruct sgpio_bank *bank = pinctrl_dev_get_drvdata(pctldev);\n\tstruct sgpio_priv *priv = bank->priv;\n\tstruct sgpio_port_addr addr;\n\n\tsgpio_pin_to_addr(priv, offset, &addr);\n\n\tif ((priv->ports & BIT(addr.port)) == 0) {\n\t\tdev_warn(priv->dev, \"Request port %d.%d: Port is not enabled\\n\",\n\t\t\t addr.port, addr.bit);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct pinmux_ops sgpio_pmx_ops = {\n\t.get_functions_count = sgpio_get_functions_count,\n\t.get_function_name = sgpio_get_function_name,\n\t.get_function_groups = sgpio_get_function_groups,\n\t.set_mux = sgpio_pinmux_set_mux,\n\t.gpio_set_direction = sgpio_gpio_set_direction,\n\t.gpio_request_enable = sgpio_gpio_request_enable,\n};\n\nstatic int sgpio_pctl_get_groups_count(struct pinctrl_dev *pctldev)\n{\n\tstruct sgpio_bank *bank = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn bank->pctl_desc.npins;\n}\n\nstatic const char *sgpio_pctl_get_group_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t     unsigned int group)\n{\n\tstruct sgpio_bank *bank = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn bank->pctl_desc.pins[group].name;\n}\n\nstatic int sgpio_pctl_get_group_pins(struct pinctrl_dev *pctldev,\n\t\t\t\t     unsigned int group,\n\t\t\t\t     const unsigned int **pins,\n\t\t\t\t     unsigned int *num_pins)\n{\n\tstruct sgpio_bank *bank = pinctrl_dev_get_drvdata(pctldev);\n\n\t*pins = &bank->pctl_desc.pins[group].number;\n\t*num_pins = 1;\n\n\treturn 0;\n}\n\nstatic const struct pinctrl_ops sgpio_pctl_ops = {\n\t.get_groups_count = sgpio_pctl_get_groups_count,\n\t.get_group_name = sgpio_pctl_get_group_name,\n\t.get_group_pins = sgpio_pctl_get_group_pins,\n\t.dt_node_to_map = pinconf_generic_dt_node_to_map_pin,\n\t.dt_free_map = pinconf_generic_dt_free_map,\n};\n\nstatic int microchip_sgpio_direction_input(struct gpio_chip *gc, unsigned int gpio)\n{\n\tstruct sgpio_bank *bank = gpiochip_get_data(gc);\n\n\t \n\treturn bank->is_input ? 0 : -EINVAL;\n}\n\nstatic int microchip_sgpio_direction_output(struct gpio_chip *gc,\n\t\t\t\t       unsigned int gpio, int value)\n{\n\tstruct sgpio_bank *bank = gpiochip_get_data(gc);\n\tstruct sgpio_priv *priv = bank->priv;\n\tstruct sgpio_port_addr addr;\n\n\t \n\tif (bank->is_input)\n\t\treturn -EINVAL;\n\n\tsgpio_pin_to_addr(priv, gpio, &addr);\n\n\treturn sgpio_output_set(priv, &addr, value);\n}\n\nstatic int microchip_sgpio_get_direction(struct gpio_chip *gc, unsigned int gpio)\n{\n\tstruct sgpio_bank *bank = gpiochip_get_data(gc);\n\n\treturn bank->is_input ? GPIO_LINE_DIRECTION_IN : GPIO_LINE_DIRECTION_OUT;\n}\n\nstatic void microchip_sgpio_set_value(struct gpio_chip *gc,\n\t\t\t\tunsigned int gpio, int value)\n{\n\tmicrochip_sgpio_direction_output(gc, gpio, value);\n}\n\nstatic int microchip_sgpio_get_value(struct gpio_chip *gc, unsigned int gpio)\n{\n\tstruct sgpio_bank *bank = gpiochip_get_data(gc);\n\tstruct sgpio_priv *priv = bank->priv;\n\tstruct sgpio_port_addr addr;\n\n\tsgpio_pin_to_addr(priv, gpio, &addr);\n\n\treturn bank->is_input ? sgpio_input_get(priv, &addr) : sgpio_output_get(priv, &addr);\n}\n\nstatic int microchip_sgpio_of_xlate(struct gpio_chip *gc,\n\t\t\t       const struct of_phandle_args *gpiospec,\n\t\t\t       u32 *flags)\n{\n\tstruct sgpio_bank *bank = gpiochip_get_data(gc);\n\tstruct sgpio_priv *priv = bank->priv;\n\tint pin;\n\n\t \n\tif (gpiospec->args[0] > SGPIO_BITS_PER_WORD ||\n\t    gpiospec->args[1] > priv->bitcount)\n\t\treturn -EINVAL;\n\n\tpin = sgpio_addr_to_pin(priv, gpiospec->args[0], gpiospec->args[1]);\n\n\tif (pin > gc->ngpio)\n\t\treturn -EINVAL;\n\n\tif (flags)\n\t\t*flags = gpiospec->args[2];\n\n\treturn pin;\n}\n\nstatic int microchip_sgpio_get_ports(struct sgpio_priv *priv)\n{\n\tconst char *range_property_name = \"microchip,sgpio-port-ranges\";\n\tstruct device *dev = priv->dev;\n\tu32 range_params[64];\n\tint i, nranges, ret;\n\n\t \n\tnranges = device_property_count_u32(dev, range_property_name);\n\tif (nranges < 2 || nranges % 2 || nranges > ARRAY_SIZE(range_params)) {\n\t\tdev_err(dev, \"%s port range: '%s' property\\n\",\n\t\t\tnranges == -EINVAL ? \"Missing\" : \"Invalid\",\n\t\t\trange_property_name);\n\t\treturn -EINVAL;\n\t}\n\n\tret = device_property_read_u32_array(dev, range_property_name,\n\t\t\t\t\t     range_params, nranges);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to parse '%s' property: %d\\n\",\n\t\t\trange_property_name, ret);\n\t\treturn ret;\n\t}\n\tfor (i = 0; i < nranges; i += 2) {\n\t\tint start, end;\n\n\t\tstart = range_params[i];\n\t\tend = range_params[i + 1];\n\t\tif (start > end || end >= SGPIO_BITS_PER_WORD) {\n\t\t\tdev_err(dev, \"Ill-formed port-range [%d:%d]\\n\",\n\t\t\t\tstart, end);\n\t\t}\n\t\tpriv->ports |= GENMASK(end, start);\n\t}\n\n\treturn 0;\n}\n\nstatic void microchip_sgpio_irq_settype(struct irq_data *data,\n\t\t\t\t\tint type,\n\t\t\t\t\tint polarity)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\n\tstruct sgpio_bank *bank = gpiochip_get_data(chip);\n\tunsigned int gpio = irqd_to_hwirq(data);\n\tstruct sgpio_port_addr addr;\n\tunsigned long flags;\n\tu32 ena;\n\n\tsgpio_pin_to_addr(bank->priv, gpio, &addr);\n\n\tspin_lock_irqsave(&bank->priv->lock, flags);\n\n\t \n\tena = sgpio_readl(bank->priv, REG_INT_ENABLE, addr.bit);\n\tsgpio_writel(bank->priv, ena & ~BIT(addr.port), REG_INT_ENABLE, addr.bit);\n\n\t \n\tsgpio_clrsetbits(bank->priv, REG_INT_TRIGGER, addr.bit,\n\t\t\t BIT(addr.port), (!!(type & 0x1)) << addr.port);\n\tsgpio_clrsetbits(bank->priv, REG_INT_TRIGGER, SGPIO_MAX_BITS + addr.bit,\n\t\t\t BIT(addr.port), (!!(type & 0x2)) << addr.port);\n\n\tif (type == SGPIO_INT_TRG_LEVEL)\n\t\tsgpio_clrsetbits(bank->priv, REG_INT_POLARITY, addr.bit,\n\t\t\t\t BIT(addr.port), polarity << addr.port);\n\n\t \n\tsgpio_writel(bank->priv, ena, REG_INT_ENABLE, addr.bit);\n\n\tspin_unlock_irqrestore(&bank->priv->lock, flags);\n}\n\nstatic void microchip_sgpio_irq_setreg(struct irq_data *data,\n\t\t\t\t       int reg,\n\t\t\t\t       bool clear)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\n\tstruct sgpio_bank *bank = gpiochip_get_data(chip);\n\tunsigned int gpio = irqd_to_hwirq(data);\n\tstruct sgpio_port_addr addr;\n\n\tsgpio_pin_to_addr(bank->priv, gpio, &addr);\n\n\tif (clear)\n\t\tsgpio_clrsetbits(bank->priv, reg, addr.bit, BIT(addr.port), 0);\n\telse\n\t\tsgpio_clrsetbits(bank->priv, reg, addr.bit, 0, BIT(addr.port));\n}\n\nstatic void microchip_sgpio_irq_mask(struct irq_data *data)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\n\n\tmicrochip_sgpio_irq_setreg(data, REG_INT_ENABLE, true);\n\tgpiochip_disable_irq(chip, data->hwirq);\n}\n\nstatic void microchip_sgpio_irq_unmask(struct irq_data *data)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\n\n\tgpiochip_enable_irq(chip, data->hwirq);\n\tmicrochip_sgpio_irq_setreg(data, REG_INT_ENABLE, false);\n}\n\nstatic void microchip_sgpio_irq_ack(struct irq_data *data)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\n\tstruct sgpio_bank *bank = gpiochip_get_data(chip);\n\tunsigned int gpio = irqd_to_hwirq(data);\n\tstruct sgpio_port_addr addr;\n\n\tsgpio_pin_to_addr(bank->priv, gpio, &addr);\n\n\tsgpio_writel(bank->priv, BIT(addr.port), REG_INT_ACK, addr.bit);\n}\n\nstatic int microchip_sgpio_irq_set_type(struct irq_data *data, unsigned int type)\n{\n\tswitch (type) {\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\tirq_set_handler_locked(data, handle_edge_irq);\n\t\tmicrochip_sgpio_irq_settype(data, SGPIO_INT_TRG_EDGE, 0);\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tirq_set_handler_locked(data, handle_edge_irq);\n\t\tmicrochip_sgpio_irq_settype(data, SGPIO_INT_TRG_EDGE_RISE, 0);\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tirq_set_handler_locked(data, handle_edge_irq);\n\t\tmicrochip_sgpio_irq_settype(data, SGPIO_INT_TRG_EDGE_FALL, 0);\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tirq_set_handler_locked(data, handle_level_irq);\n\t\tmicrochip_sgpio_irq_settype(data, SGPIO_INT_TRG_LEVEL, SGPIO_TRG_LEVEL_HIGH);\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tirq_set_handler_locked(data, handle_level_irq);\n\t\tmicrochip_sgpio_irq_settype(data, SGPIO_INT_TRG_LEVEL, SGPIO_TRG_LEVEL_LOW);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct irq_chip microchip_sgpio_irqchip = {\n\t.name\t\t= \"gpio\",\n\t.irq_mask\t= microchip_sgpio_irq_mask,\n\t.irq_ack\t= microchip_sgpio_irq_ack,\n\t.irq_unmask\t= microchip_sgpio_irq_unmask,\n\t.irq_set_type\t= microchip_sgpio_irq_set_type,\n\t.flags\t\t= IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic void sgpio_irq_handler(struct irq_desc *desc)\n{\n\tstruct irq_chip *parent_chip = irq_desc_get_chip(desc);\n\tstruct gpio_chip *chip = irq_desc_get_handler_data(desc);\n\tstruct sgpio_bank *bank = gpiochip_get_data(chip);\n\tstruct sgpio_priv *priv = bank->priv;\n\tint bit, port, gpio;\n\tlong val;\n\n\tfor (bit = 0; bit < priv->bitcount; bit++) {\n\t\tval = sgpio_readl(priv, REG_INT_IDENT, bit);\n\t\tif (!val)\n\t\t\tcontinue;\n\n\t\tchained_irq_enter(parent_chip, desc);\n\n\t\tfor_each_set_bit(port, &val, SGPIO_BITS_PER_WORD) {\n\t\t\tgpio = sgpio_addr_to_pin(priv, port, bit);\n\t\t\tgeneric_handle_domain_irq(chip->irq.domain, gpio);\n\t\t}\n\n\t\tchained_irq_exit(parent_chip, desc);\n\t}\n}\n\nstatic int microchip_sgpio_register_bank(struct device *dev,\n\t\t\t\t\t struct sgpio_priv *priv,\n\t\t\t\t\t struct fwnode_handle *fwnode,\n\t\t\t\t\t int bankno)\n{\n\tstruct pinctrl_pin_desc *pins;\n\tstruct pinctrl_desc *pctl_desc;\n\tstruct pinctrl_dev *pctldev;\n\tstruct sgpio_bank *bank;\n\tstruct gpio_chip *gc;\n\tu32 ngpios;\n\tint i, ret;\n\n\t \n\tbank = (bankno == 0) ? &priv->in : &priv->out;\n\tbank->priv = priv;\n\n\tif (fwnode_property_read_u32(fwnode, \"ngpios\", &ngpios)) {\n\t\tdev_info(dev, \"failed to get number of gpios for bank%d\\n\",\n\t\t\t bankno);\n\t\tngpios = 64;\n\t}\n\n\tpriv->bitcount = ngpios / SGPIO_BITS_PER_WORD;\n\tif (priv->bitcount > SGPIO_MAX_BITS) {\n\t\tdev_err(dev, \"Bit width exceeds maximum (%d)\\n\",\n\t\t\tSGPIO_MAX_BITS);\n\t\treturn -EINVAL;\n\t}\n\n\tpctl_desc = &bank->pctl_desc;\n\tpctl_desc->name = devm_kasprintf(dev, GFP_KERNEL, \"%s-%sput\",\n\t\t\t\t\t dev_name(dev),\n\t\t\t\t\t bank->is_input ? \"in\" : \"out\");\n\tif (!pctl_desc->name)\n\t\treturn -ENOMEM;\n\n\tpctl_desc->pctlops = &sgpio_pctl_ops;\n\tpctl_desc->pmxops = &sgpio_pmx_ops;\n\tpctl_desc->confops = &sgpio_confops;\n\tpctl_desc->owner = THIS_MODULE;\n\n\tpins = devm_kzalloc(dev, sizeof(*pins)*ngpios, GFP_KERNEL);\n\tif (!pins)\n\t\treturn -ENOMEM;\n\n\tpctl_desc->npins = ngpios;\n\tpctl_desc->pins = pins;\n\n\tfor (i = 0; i < ngpios; i++) {\n\t\tstruct sgpio_port_addr addr;\n\n\t\tsgpio_pin_to_addr(priv, i, &addr);\n\n\t\tpins[i].number = i;\n\t\tpins[i].name = devm_kasprintf(dev, GFP_KERNEL,\n\t\t\t\t\t      \"SGPIO_%c_p%db%d\",\n\t\t\t\t\t      bank->is_input ? 'I' : 'O',\n\t\t\t\t\t      addr.port, addr.bit);\n\t\tif (!pins[i].name)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tpctldev = devm_pinctrl_register(dev, pctl_desc, bank);\n\tif (IS_ERR(pctldev))\n\t\treturn dev_err_probe(dev, PTR_ERR(pctldev), \"Failed to register pinctrl\\n\");\n\n\tgc\t\t\t= &bank->gpio;\n\tgc->label\t\t= pctl_desc->name;\n\tgc->parent\t\t= dev;\n\tgc->fwnode\t\t= fwnode;\n\tgc->owner\t\t= THIS_MODULE;\n\tgc->get_direction\t= microchip_sgpio_get_direction;\n\tgc->direction_input\t= microchip_sgpio_direction_input;\n\tgc->direction_output\t= microchip_sgpio_direction_output;\n\tgc->get\t\t\t= microchip_sgpio_get_value;\n\tgc->set\t\t\t= microchip_sgpio_set_value;\n\tgc->request\t\t= gpiochip_generic_request;\n\tgc->free\t\t= gpiochip_generic_free;\n\tgc->of_xlate\t\t= microchip_sgpio_of_xlate;\n\tgc->of_gpio_n_cells     = 3;\n\tgc->base\t\t= -1;\n\tgc->ngpio\t\t= ngpios;\n\tgc->can_sleep\t\t= !bank->is_input;\n\n\tif (bank->is_input && priv->properties->flags & SGPIO_FLAGS_HAS_IRQ) {\n\t\tint irq;\n\n\t\tirq = fwnode_irq_get(fwnode, 0);\n\t\tif (irq > 0) {\n\t\t\tstruct gpio_irq_chip *girq = &gc->irq;\n\n\t\t\tgpio_irq_chip_set_chip(girq, &microchip_sgpio_irqchip);\n\t\t\tgirq->parent_handler = sgpio_irq_handler;\n\t\t\tgirq->num_parents = 1;\n\t\t\tgirq->parents = devm_kcalloc(dev, 1,\n\t\t\t\t\t\t     sizeof(*girq->parents),\n\t\t\t\t\t\t     GFP_KERNEL);\n\t\t\tif (!girq->parents)\n\t\t\t\treturn -ENOMEM;\n\t\t\tgirq->parents[0] = irq;\n\t\t\tgirq->default_type = IRQ_TYPE_NONE;\n\t\t\tgirq->handler = handle_bad_irq;\n\n\t\t\t \n\t\t\tfor (i = 0; i < SGPIO_MAX_BITS; i++)\n\t\t\t\tsgpio_writel(priv, 0, REG_INT_ENABLE, i);\n\t\t\t \n\t\t\tsgpio_clrsetbits(priv, REG_SIO_CONFIG, 0, 0, SGPIO_MASTER_INTR_ENA);\n\t\t}\n\t}\n\n\tret = devm_gpiochip_add_data(dev, gc, bank);\n\tif (ret)\n\t\tdev_err(dev, \"Failed to register: ret %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int microchip_sgpio_probe(struct platform_device *pdev)\n{\n\tint div_clock = 0, ret, port, i, nbanks;\n\tstruct device *dev = &pdev->dev;\n\tstruct fwnode_handle *fwnode;\n\tstruct reset_control *reset;\n\tstruct sgpio_priv *priv;\n\tstruct clk *clk;\n\tu32 val;\n\tstruct regmap_config regmap_config = {\n\t\t.reg_bits = 32,\n\t\t.val_bits = 32,\n\t\t.reg_stride = 4,\n\t};\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->dev = dev;\n\tspin_lock_init(&priv->lock);\n\tmutex_init(&priv->poll_lock);\n\n\treset = devm_reset_control_get_optional_shared(&pdev->dev, \"switch\");\n\tif (IS_ERR(reset))\n\t\treturn dev_err_probe(dev, PTR_ERR(reset), \"Failed to get reset\\n\");\n\treset_control_reset(reset);\n\n\tclk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(clk), \"Failed to get clock\\n\");\n\n\tdiv_clock = clk_get_rate(clk);\n\tif (device_property_read_u32(dev, \"bus-frequency\", &priv->clock))\n\t\tpriv->clock = 12500000;\n\tif (priv->clock == 0 || priv->clock > (div_clock / 2)) {\n\t\tdev_err(dev, \"Invalid frequency %d\\n\", priv->clock);\n\t\treturn -EINVAL;\n\t}\n\n\tpriv->regs = ocelot_regmap_from_resource(pdev, 0, &regmap_config);\n\tif (IS_ERR(priv->regs))\n\t\treturn PTR_ERR(priv->regs);\n\n\tpriv->properties = device_get_match_data(dev);\n\tpriv->in.is_input = true;\n\n\t \n\tret = microchip_sgpio_get_ports(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tnbanks = device_get_child_node_count(dev);\n\tif (nbanks != 2) {\n\t\tdev_err(dev, \"Must have 2 banks (have %d)\\n\", nbanks);\n\t\treturn -EINVAL;\n\t}\n\n\ti = 0;\n\tdevice_for_each_child_node(dev, fwnode) {\n\t\tret = microchip_sgpio_register_bank(dev, priv, fwnode, i++);\n\t\tif (ret) {\n\t\t\tfwnode_handle_put(fwnode);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (priv->in.gpio.ngpio != priv->out.gpio.ngpio) {\n\t\tdev_err(dev, \"Banks must have same GPIO count\\n\");\n\t\treturn -ERANGE;\n\t}\n\n\tsgpio_configure_bitstream(priv);\n\n\tval = max(2U, div_clock / priv->clock);\n\tsgpio_configure_clock(priv, val);\n\n\tfor (port = 0; port < SGPIO_BITS_PER_WORD; port++)\n\t\tsgpio_writel(priv, 0, REG_PORT_CONFIG, port);\n\tsgpio_writel(priv, priv->ports, REG_PORT_ENABLE, 0);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id microchip_sgpio_gpio_of_match[] = {\n\t{\n\t\t.compatible = \"microchip,sparx5-sgpio\",\n\t\t.data = &properties_sparx5,\n\t}, {\n\t\t.compatible = \"mscc,luton-sgpio\",\n\t\t.data = &properties_luton,\n\t}, {\n\t\t.compatible = \"mscc,ocelot-sgpio\",\n\t\t.data = &properties_ocelot,\n\t}, {\n\t\t \n\t}\n};\nMODULE_DEVICE_TABLE(of, microchip_sgpio_gpio_of_match);\n\nstatic struct platform_driver microchip_sgpio_pinctrl_driver = {\n\t.driver = {\n\t\t.name = \"pinctrl-microchip-sgpio\",\n\t\t.of_match_table = microchip_sgpio_gpio_of_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe = microchip_sgpio_probe,\n};\nmodule_platform_driver(microchip_sgpio_pinctrl_driver);\n\nMODULE_DESCRIPTION(\"Microchip SGPIO Pinctrl Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}