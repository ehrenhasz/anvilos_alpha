{
  "module_name": "pinctrl-pxa2xx.c",
  "hash_id": "30fbc0daced48479cbb908a0474990d2f4ac56a44055459adb15d8b9b6d5bbc7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/pxa/pinctrl-pxa2xx.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/module.h>\n#include <linux/pinctrl/machine.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinconf-generic.h>\n#include <linux/pinctrl/pinmux.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include \"../pinctrl-utils.h\"\n#include \"pinctrl-pxa2xx.h\"\n\nstatic int pxa2xx_pctrl_get_groups_count(struct pinctrl_dev *pctldev)\n{\n\tstruct pxa_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pctl->ngroups;\n}\n\nstatic const char *pxa2xx_pctrl_get_group_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t       unsigned tgroup)\n{\n\tstruct pxa_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct pxa_pinctrl_group *group = pctl->groups + tgroup;\n\n\treturn group->name;\n}\n\nstatic int pxa2xx_pctrl_get_group_pins(struct pinctrl_dev *pctldev,\n\t\t\t\t       unsigned tgroup,\n\t\t\t\t       const unsigned **pins,\n\t\t\t\t       unsigned *num_pins)\n{\n\tstruct pxa_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct pxa_pinctrl_group *group = pctl->groups + tgroup;\n\n\t*pins = (unsigned *)&group->pin;\n\t*num_pins = 1;\n\n\treturn 0;\n}\n\nstatic const struct pinctrl_ops pxa2xx_pctl_ops = {\n#ifdef CONFIG_OF\n\t.dt_node_to_map\t\t= pinconf_generic_dt_node_to_map_all,\n\t.dt_free_map\t\t= pinctrl_utils_free_map,\n#endif\n\t.get_groups_count\t= pxa2xx_pctrl_get_groups_count,\n\t.get_group_name\t\t= pxa2xx_pctrl_get_group_name,\n\t.get_group_pins\t\t= pxa2xx_pctrl_get_group_pins,\n};\n\nstatic struct pxa_desc_function *\npxa_desc_by_func_group(struct pxa_pinctrl *pctl, const char *pin_name,\n\t\t       const char *func_name)\n{\n\tint i;\n\tstruct pxa_desc_function *df;\n\n\tfor (i = 0; i < pctl->npins; i++) {\n\t\tconst struct pxa_desc_pin *pin = pctl->ppins + i;\n\n\t\tif (!strcmp(pin->pin.name, pin_name))\n\t\t\tfor (df = pin->functions; df->name; df++)\n\t\t\t\tif (!strcmp(df->name, func_name))\n\t\t\t\t\treturn df;\n\t}\n\n\treturn NULL;\n}\n\nstatic int pxa2xx_pmx_gpio_set_direction(struct pinctrl_dev *pctldev,\n\t\t\t\t\t struct pinctrl_gpio_range *range,\n\t\t\t\t\t unsigned pin,\n\t\t\t\t\t bool input)\n{\n\tstruct pxa_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tunsigned long flags;\n\tuint32_t val;\n\tvoid __iomem *gpdr;\n\n\tgpdr = pctl->base_gpdr[pin / 32];\n\tdev_dbg(pctl->dev, \"set_direction(pin=%d): dir=%d\\n\",\n\t\tpin, !input);\n\n\tspin_lock_irqsave(&pctl->lock, flags);\n\n\tval = readl_relaxed(gpdr);\n\tval = (val & ~BIT(pin % 32)) | (input ? 0 : BIT(pin % 32));\n\twritel_relaxed(val, gpdr);\n\n\tspin_unlock_irqrestore(&pctl->lock, flags);\n\n\treturn 0;\n}\n\nstatic const char *pxa2xx_pmx_get_func_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t    unsigned function)\n{\n\tstruct pxa_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct pxa_pinctrl_function *pf = pctl->functions + function;\n\n\treturn pf->name;\n}\n\nstatic int pxa2xx_get_functions_count(struct pinctrl_dev *pctldev)\n{\n\tstruct pxa_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pctl->nfuncs;\n}\n\nstatic int pxa2xx_pmx_get_func_groups(struct pinctrl_dev *pctldev,\n\t\t\t\t      unsigned function,\n\t\t\t\t      const char * const **groups,\n\t\t\t\t      unsigned * const num_groups)\n{\n\tstruct pxa_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct pxa_pinctrl_function *pf = pctl->functions + function;\n\n\t*groups = pf->groups;\n\t*num_groups = pf->ngroups;\n\n\treturn 0;\n}\n\nstatic int pxa2xx_pmx_set_mux(struct pinctrl_dev *pctldev, unsigned function,\n\t\t\t      unsigned tgroup)\n{\n\tstruct pxa_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct pxa_pinctrl_group *group = pctl->groups + tgroup;\n\tstruct pxa_desc_function *df;\n\tint pin, shift;\n\tunsigned long flags;\n\tvoid __iomem *gafr, *gpdr;\n\tu32 val;\n\n\n\tdf = pxa_desc_by_func_group(pctl, group->name,\n\t\t\t\t    (pctl->functions + function)->name);\n\tif (!df)\n\t\treturn -EINVAL;\n\n\tpin = group->pin;\n\tgafr = pctl->base_gafr[pin / 16];\n\tgpdr = pctl->base_gpdr[pin / 32];\n\tshift = (pin % 16) << 1;\n\tdev_dbg(pctl->dev, \"set_mux(pin=%d): af=%d dir=%d\\n\",\n\t\tpin, df->muxval >> 1, df->muxval & 0x1);\n\n\tspin_lock_irqsave(&pctl->lock, flags);\n\n\tval = readl_relaxed(gafr);\n\tval = (val & ~(0x3 << shift)) | ((df->muxval >> 1) << shift);\n\twritel_relaxed(val, gafr);\n\n\tval = readl_relaxed(gpdr);\n\tval = (val & ~BIT(pin % 32)) | ((df->muxval & 1) ? BIT(pin % 32) : 0);\n\twritel_relaxed(val, gpdr);\n\n\tspin_unlock_irqrestore(&pctl->lock, flags);\n\n\treturn 0;\n}\nstatic const struct pinmux_ops pxa2xx_pinmux_ops = {\n\t.get_functions_count = pxa2xx_get_functions_count,\n\t.get_function_name = pxa2xx_pmx_get_func_name,\n\t.get_function_groups = pxa2xx_pmx_get_func_groups,\n\t.set_mux = pxa2xx_pmx_set_mux,\n\t.gpio_set_direction = pxa2xx_pmx_gpio_set_direction,\n};\n\nstatic int pxa2xx_pconf_group_get(struct pinctrl_dev *pctldev,\n\t\t\t\t  unsigned group,\n\t\t\t\t  unsigned long *config)\n{\n\tstruct pxa_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct pxa_pinctrl_group *g = pctl->groups + group;\n\tunsigned long flags;\n\tunsigned pin = g->pin;\n\tvoid __iomem *pgsr = pctl->base_pgsr[pin / 32];\n\tu32 val;\n\n\tspin_lock_irqsave(&pctl->lock, flags);\n\tval = readl_relaxed(pgsr) & BIT(pin % 32);\n\t*config = val ? PIN_CONFIG_MODE_LOW_POWER : 0;\n\tspin_unlock_irqrestore(&pctl->lock, flags);\n\n\tdev_dbg(pctl->dev, \"get sleep gpio state(pin=%d) %d\\n\",\n\t\tpin, !!val);\n\treturn 0;\n}\n\nstatic int pxa2xx_pconf_group_set(struct pinctrl_dev *pctldev,\n\t\t\t\t  unsigned group,\n\t\t\t\t  unsigned long *configs,\n\t\t\t\t  unsigned num_configs)\n{\n\tstruct pxa_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct pxa_pinctrl_group *g = pctl->groups + group;\n\tunsigned long flags;\n\tunsigned pin = g->pin;\n\tvoid __iomem *pgsr = pctl->base_pgsr[pin / 32];\n\tint i, is_set = 0;\n\tu32 val;\n\n\tfor (i = 0; i < num_configs; i++) {\n\t\tswitch (pinconf_to_config_param(configs[i])) {\n\t\tcase PIN_CONFIG_MODE_LOW_POWER:\n\t\t\tis_set = pinconf_to_config_argument(configs[i]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tdev_dbg(pctl->dev, \"set sleep gpio state(pin=%d) %d\\n\",\n\t\tpin, is_set);\n\n\tspin_lock_irqsave(&pctl->lock, flags);\n\tval = readl_relaxed(pgsr);\n\tval = (val & ~BIT(pin % 32)) | (is_set ? BIT(pin % 32) : 0);\n\twritel_relaxed(val, pgsr);\n\tspin_unlock_irqrestore(&pctl->lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct pinconf_ops pxa2xx_pconf_ops = {\n\t.pin_config_group_get\t= pxa2xx_pconf_group_get,\n\t.pin_config_group_set\t= pxa2xx_pconf_group_set,\n\t.is_generic\t\t= true,\n};\n\nstatic struct pinctrl_desc pxa2xx_pinctrl_desc = {\n\t.confops\t= &pxa2xx_pconf_ops,\n\t.pctlops\t= &pxa2xx_pctl_ops,\n\t.pmxops\t\t= &pxa2xx_pinmux_ops,\n};\n\nstatic const struct pxa_pinctrl_function *\npxa2xx_find_function(struct pxa_pinctrl *pctl, const char *fname,\n\t\t     const struct pxa_pinctrl_function *functions)\n{\n\tconst struct pxa_pinctrl_function *func;\n\n\tfor (func = functions; func->name; func++)\n\t\tif (!strcmp(fname, func->name))\n\t\t\treturn func;\n\n\treturn NULL;\n}\n\nstatic int pxa2xx_build_functions(struct pxa_pinctrl *pctl)\n{\n\tint i;\n\tstruct pxa_pinctrl_function *functions;\n\tstruct pxa_desc_function *df;\n\n\t \n\tfunctions = devm_kcalloc(pctl->dev, pctl->npins * 6,\n\t\t\t\t sizeof(*functions), GFP_KERNEL);\n\tif (!functions)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < pctl->npins; i++)\n\t\tfor (df = pctl->ppins[i].functions; df->name; df++)\n\t\t\tif (!pxa2xx_find_function(pctl, df->name, functions))\n\t\t\t\t(functions + pctl->nfuncs++)->name = df->name;\n\tpctl->functions = devm_kmemdup(pctl->dev, functions,\n\t\t\t\t       pctl->nfuncs * sizeof(*functions),\n\t\t\t\t       GFP_KERNEL);\n\tif (!pctl->functions)\n\t\treturn -ENOMEM;\n\n\tdevm_kfree(pctl->dev, functions);\n\treturn 0;\n}\n\nstatic int pxa2xx_build_groups(struct pxa_pinctrl *pctl)\n{\n\tint i, j, ngroups;\n\tstruct pxa_pinctrl_function *func;\n\tstruct pxa_desc_function *df;\n\tchar **gtmp;\n\n\tgtmp = devm_kmalloc_array(pctl->dev, pctl->npins, sizeof(*gtmp),\n\t\t\t\t  GFP_KERNEL);\n\tif (!gtmp)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < pctl->nfuncs; i++) {\n\t\tngroups = 0;\n\t\tfor (j = 0; j < pctl->npins; j++)\n\t\t\tfor (df = pctl->ppins[j].functions; df->name;\n\t\t\t     df++)\n\t\t\t\tif (!strcmp(pctl->functions[i].name,\n\t\t\t\t\t    df->name))\n\t\t\t\t\tgtmp[ngroups++] = (char *)\n\t\t\t\t\t\tpctl->ppins[j].pin.name;\n\t\tfunc = pctl->functions + i;\n\t\tfunc->ngroups = ngroups;\n\t\tfunc->groups =\n\t\t\tdevm_kmalloc_array(pctl->dev, ngroups,\n\t\t\t\t\t   sizeof(char *), GFP_KERNEL);\n\t\tif (!func->groups)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(func->groups, gtmp, ngroups * sizeof(*gtmp));\n\t}\n\n\tdevm_kfree(pctl->dev, gtmp);\n\treturn 0;\n}\n\nstatic int pxa2xx_build_state(struct pxa_pinctrl *pctl,\n\t\t\t      const struct pxa_desc_pin *ppins, int npins)\n{\n\tstruct pxa_pinctrl_group *group;\n\tstruct pinctrl_pin_desc *pins;\n\tint ret, i;\n\n\tpctl->npins = npins;\n\tpctl->ppins = ppins;\n\tpctl->ngroups = npins;\n\n\tpctl->desc.npins = npins;\n\tpins = devm_kcalloc(pctl->dev, npins, sizeof(*pins), GFP_KERNEL);\n\tif (!pins)\n\t\treturn -ENOMEM;\n\n\tpctl->desc.pins = pins;\n\tfor (i = 0; i < npins; i++)\n\t\tpins[i] = ppins[i].pin;\n\n\tpctl->groups = devm_kmalloc_array(pctl->dev, pctl->ngroups,\n\t\t\t\t\t  sizeof(*pctl->groups), GFP_KERNEL);\n\tif (!pctl->groups)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < npins; i++) {\n\t\tgroup = pctl->groups + i;\n\t\tgroup->name = ppins[i].pin.name;\n\t\tgroup->pin = ppins[i].pin.number;\n\t}\n\n\tret = pxa2xx_build_functions(pctl);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pxa2xx_build_groups(pctl);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nint pxa2xx_pinctrl_init(struct platform_device *pdev,\n\t\t\tconst struct pxa_desc_pin *ppins, int npins,\n\t\t\tvoid __iomem *base_gafr[], void __iomem *base_gpdr[],\n\t\t\tvoid __iomem *base_pgsr[])\n{\n\tstruct pxa_pinctrl *pctl;\n\tint ret, i, maxpin = 0;\n\n\tfor (i = 0; i < npins; i++)\n\t\tmaxpin = max_t(int, ppins[i].pin.number, maxpin);\n\n\tpctl = devm_kzalloc(&pdev->dev, sizeof(*pctl), GFP_KERNEL);\n\tif (!pctl)\n\t\treturn -ENOMEM;\n\tpctl->base_gafr = devm_kcalloc(&pdev->dev, roundup(maxpin, 16),\n\t\t\t\t       sizeof(*pctl->base_gafr), GFP_KERNEL);\n\tpctl->base_gpdr = devm_kcalloc(&pdev->dev, roundup(maxpin, 32),\n\t\t\t\t       sizeof(*pctl->base_gpdr), GFP_KERNEL);\n\tpctl->base_pgsr = devm_kcalloc(&pdev->dev, roundup(maxpin, 32),\n\t\t\t\t       sizeof(*pctl->base_pgsr), GFP_KERNEL);\n\tif (!pctl->base_gafr || !pctl->base_gpdr || !pctl->base_pgsr)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, pctl);\n\tspin_lock_init(&pctl->lock);\n\n\tpctl->dev = &pdev->dev;\n\tpctl->desc = pxa2xx_pinctrl_desc;\n\tpctl->desc.name = dev_name(&pdev->dev);\n\tpctl->desc.owner = THIS_MODULE;\n\n\tfor (i = 0; i < roundup(maxpin, 16); i += 16)\n\t\tpctl->base_gafr[i / 16] = base_gafr[i / 16];\n\tfor (i = 0; i < roundup(maxpin, 32); i += 32) {\n\t\tpctl->base_gpdr[i / 32] = base_gpdr[i / 32];\n\t\tpctl->base_pgsr[i / 32] = base_pgsr[i / 32];\n\t}\n\n\tret = pxa2xx_build_state(pctl, ppins, npins);\n\tif (ret)\n\t\treturn ret;\n\n\tpctl->pctl_dev = devm_pinctrl_register(&pdev->dev, &pctl->desc, pctl);\n\tif (IS_ERR(pctl->pctl_dev)) {\n\t\tdev_err(&pdev->dev, \"couldn't register pinctrl driver\\n\");\n\t\treturn PTR_ERR(pctl->pctl_dev);\n\t}\n\n\tdev_info(&pdev->dev, \"initialized pxa2xx pinctrl driver\\n\");\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(pxa2xx_pinctrl_init);\n\nMODULE_AUTHOR(\"Robert Jarzmik <robert.jarzmik@free.fr>\");\nMODULE_DESCRIPTION(\"Marvell PXA2xx pinctrl driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}