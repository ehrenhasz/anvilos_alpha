{
  "module_name": "berlin.c",
  "hash_id": "6fc6f215e10023adbdff736582490294b0b460a62505c77036edbdd27762a8e1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/berlin/berlin.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_device.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinmux.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n#include \"../core.h\"\n#include \"../pinctrl-utils.h\"\n#include \"berlin.h\"\n\nstruct berlin_pinctrl {\n\tstruct regmap *regmap;\n\tstruct device *dev;\n\tconst struct berlin_pinctrl_desc *desc;\n\tstruct berlin_pinctrl_function *functions;\n\tunsigned nfunctions;\n\tstruct pinctrl_dev *pctrl_dev;\n};\n\nstatic int berlin_pinctrl_get_group_count(struct pinctrl_dev *pctrl_dev)\n{\n\tstruct berlin_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctrl_dev);\n\n\treturn pctrl->desc->ngroups;\n}\n\nstatic const char *berlin_pinctrl_get_group_name(struct pinctrl_dev *pctrl_dev,\n\t\t\t\t\t\t unsigned group)\n{\n\tstruct berlin_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctrl_dev);\n\n\treturn pctrl->desc->groups[group].name;\n}\n\nstatic int berlin_pinctrl_dt_node_to_map(struct pinctrl_dev *pctrl_dev,\n\t\t\t\t\t struct device_node *node,\n\t\t\t\t\t struct pinctrl_map **map,\n\t\t\t\t\t unsigned *num_maps)\n{\n\tstruct berlin_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctrl_dev);\n\tstruct property *prop;\n\tconst char *function_name, *group_name;\n\tunsigned reserved_maps = 0;\n\tint ret, ngroups;\n\n\t*map = NULL;\n\t*num_maps = 0;\n\n\tret = of_property_read_string(node, \"function\", &function_name);\n\tif (ret) {\n\t\tdev_err(pctrl->dev,\n\t\t\t\"missing function property in node %pOFn\\n\", node);\n\t\treturn -EINVAL;\n\t}\n\n\tngroups = of_property_count_strings(node, \"groups\");\n\tif (ngroups < 0) {\n\t\tdev_err(pctrl->dev,\n\t\t\t\"missing groups property in node %pOFn\\n\", node);\n\t\treturn -EINVAL;\n\t}\n\n\tret = pinctrl_utils_reserve_map(pctrl_dev, map, &reserved_maps,\n\t\t\t\t\tnum_maps, ngroups);\n\tif (ret) {\n\t\tdev_err(pctrl->dev, \"can't reserve map: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tof_property_for_each_string(node, \"groups\", prop, group_name) {\n\t\tret = pinctrl_utils_add_map_mux(pctrl_dev, map, &reserved_maps,\n\t\t\t\t\t\tnum_maps, group_name,\n\t\t\t\t\t\tfunction_name);\n\t\tif (ret) {\n\t\t\tdev_err(pctrl->dev, \"can't add map: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct pinctrl_ops berlin_pinctrl_ops = {\n\t.get_groups_count\t= &berlin_pinctrl_get_group_count,\n\t.get_group_name\t\t= &berlin_pinctrl_get_group_name,\n\t.dt_node_to_map\t\t= &berlin_pinctrl_dt_node_to_map,\n\t.dt_free_map\t\t= &pinctrl_utils_free_map,\n};\n\nstatic int berlin_pinmux_get_functions_count(struct pinctrl_dev *pctrl_dev)\n{\n\tstruct berlin_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctrl_dev);\n\n\treturn pctrl->nfunctions;\n}\n\nstatic const char *berlin_pinmux_get_function_name(struct pinctrl_dev *pctrl_dev,\n\t\t\t\t\t\t   unsigned function)\n{\n\tstruct berlin_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctrl_dev);\n\n\treturn pctrl->functions[function].name;\n}\n\nstatic int berlin_pinmux_get_function_groups(struct pinctrl_dev *pctrl_dev,\n\t\t\t\t\t     unsigned function,\n\t\t\t\t\t     const char * const **groups,\n\t\t\t\t\t     unsigned * const num_groups)\n{\n\tstruct berlin_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctrl_dev);\n\n\t*groups = pctrl->functions[function].groups;\n\t*num_groups = pctrl->functions[function].ngroups;\n\n\treturn 0;\n}\n\nstatic struct berlin_desc_function *\nberlin_pinctrl_find_function_by_name(struct berlin_pinctrl *pctrl,\n\t\t\t\t     const struct berlin_desc_group *group,\n\t\t\t\t     const char *fname)\n{\n\tstruct berlin_desc_function *function = group->functions;\n\n\twhile (function->name) {\n\t\tif (!strcmp(function->name, fname))\n\t\t\treturn function;\n\n\t\tfunction++;\n\t}\n\n\treturn NULL;\n}\n\nstatic int berlin_pinmux_set(struct pinctrl_dev *pctrl_dev,\n\t\t\t     unsigned function,\n\t\t\t     unsigned group)\n{\n\tstruct berlin_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctrl_dev);\n\tconst struct berlin_desc_group *group_desc = pctrl->desc->groups + group;\n\tstruct berlin_pinctrl_function *func = pctrl->functions + function;\n\tstruct berlin_desc_function *function_desc =\n\t\tberlin_pinctrl_find_function_by_name(pctrl, group_desc,\n\t\t\t\t\t\t     func->name);\n\tu32 mask, val;\n\n\tif (!function_desc)\n\t\treturn -EINVAL;\n\n\tmask = GENMASK(group_desc->lsb + group_desc->bit_width - 1,\n\t\t       group_desc->lsb);\n\tval = function_desc->muxval << group_desc->lsb;\n\tregmap_update_bits(pctrl->regmap, group_desc->offset, mask, val);\n\n\treturn 0;\n}\n\nstatic const struct pinmux_ops berlin_pinmux_ops = {\n\t.get_functions_count\t= &berlin_pinmux_get_functions_count,\n\t.get_function_name\t= &berlin_pinmux_get_function_name,\n\t.get_function_groups\t= &berlin_pinmux_get_function_groups,\n\t.set_mux\t\t= &berlin_pinmux_set,\n};\n\nstatic int berlin_pinctrl_add_function(struct berlin_pinctrl *pctrl,\n\t\t\t\t       const char *name)\n{\n\tstruct berlin_pinctrl_function *function = pctrl->functions;\n\n\twhile (function->name) {\n\t\tif (!strcmp(function->name, name)) {\n\t\t\tfunction->ngroups++;\n\t\t\treturn -EEXIST;\n\t\t}\n\t\tfunction++;\n\t}\n\n\tfunction->name = name;\n\tfunction->ngroups = 1;\n\n\tpctrl->nfunctions++;\n\n\treturn 0;\n}\n\nstatic int berlin_pinctrl_build_state(struct platform_device *pdev)\n{\n\tstruct berlin_pinctrl *pctrl = platform_get_drvdata(pdev);\n\tconst struct berlin_desc_group *desc_group;\n\tconst struct berlin_desc_function *desc_function;\n\tint i, max_functions = 0;\n\n\tpctrl->nfunctions = 0;\n\n\tfor (i = 0; i < pctrl->desc->ngroups; i++) {\n\t\tdesc_group = pctrl->desc->groups + i;\n\t\t \n\t\tmax_functions += 1 << (desc_group->bit_width + 1);\n\t}\n\n\t \n\tpctrl->functions = kcalloc(max_functions,\n\t\t\t\t   sizeof(*pctrl->functions), GFP_KERNEL);\n\tif (!pctrl->functions)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = 0; i < pctrl->desc->ngroups; i++) {\n\t\tdesc_group = pctrl->desc->groups + i;\n\t\tdesc_function = desc_group->functions;\n\n\t\twhile (desc_function->name) {\n\t\t\tberlin_pinctrl_add_function(pctrl, desc_function->name);\n\t\t\tdesc_function++;\n\t\t}\n\t}\n\n\tpctrl->functions = krealloc(pctrl->functions,\n\t\t\t\t    pctrl->nfunctions * sizeof(*pctrl->functions),\n\t\t\t\t    GFP_KERNEL);\n\tif (!pctrl->functions)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = 0; i < pctrl->desc->ngroups; i++) {\n\t\tdesc_group = pctrl->desc->groups + i;\n\t\tdesc_function = desc_group->functions;\n\n\t\twhile (desc_function->name) {\n\t\t\tstruct berlin_pinctrl_function\n\t\t\t\t*function = pctrl->functions;\n\t\t\tconst char **groups;\n\t\t\tbool found = false;\n\n\t\t\twhile (function->name) {\n\t\t\t\tif (!strcmp(desc_function->name, function->name)) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfunction++;\n\t\t\t}\n\n\t\t\tif (!found) {\n\t\t\t\tkfree(pctrl->functions);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (!function->groups) {\n\t\t\t\tfunction->groups =\n\t\t\t\t\tdevm_kcalloc(&pdev->dev,\n\t\t\t\t\t\t     function->ngroups,\n\t\t\t\t\t\t     sizeof(char *),\n\t\t\t\t\t\t     GFP_KERNEL);\n\n\t\t\t\tif (!function->groups) {\n\t\t\t\t\tkfree(pctrl->functions);\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tgroups = function->groups;\n\t\t\twhile (*groups)\n\t\t\t\tgroups++;\n\n\t\t\t*groups = desc_group->name;\n\n\t\t\tdesc_function++;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct pinctrl_desc berlin_pctrl_desc = {\n\t.name\t\t= \"berlin-pinctrl\",\n\t.pctlops\t= &berlin_pinctrl_ops,\n\t.pmxops\t\t= &berlin_pinmux_ops,\n\t.owner\t\t= THIS_MODULE,\n};\n\nint berlin_pinctrl_probe_regmap(struct platform_device *pdev,\n\t\t\t\tconst struct berlin_pinctrl_desc *desc,\n\t\t\t\tstruct regmap *regmap)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct berlin_pinctrl *pctrl;\n\tint ret;\n\n\tpctrl = devm_kzalloc(dev, sizeof(*pctrl), GFP_KERNEL);\n\tif (!pctrl)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, pctrl);\n\n\tpctrl->regmap = regmap;\n\tpctrl->dev = &pdev->dev;\n\tpctrl->desc = desc;\n\n\tret = berlin_pinctrl_build_state(pdev);\n\tif (ret) {\n\t\tdev_err(dev, \"cannot build driver state: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpctrl->pctrl_dev = devm_pinctrl_register(dev, &berlin_pctrl_desc,\n\t\t\t\t\t\t pctrl);\n\tif (IS_ERR(pctrl->pctrl_dev)) {\n\t\tdev_err(dev, \"failed to register pinctrl driver\\n\");\n\t\treturn PTR_ERR(pctrl->pctrl_dev);\n\t}\n\n\treturn 0;\n}\n\nint berlin_pinctrl_probe(struct platform_device *pdev,\n\t\t\t const struct berlin_pinctrl_desc *desc)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *parent_np = of_get_parent(dev->of_node);\n\tstruct regmap *regmap = syscon_node_to_regmap(parent_np);\n\n\tof_node_put(parent_np);\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\treturn berlin_pinctrl_probe_regmap(pdev, desc, regmap);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}