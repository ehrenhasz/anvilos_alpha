{
  "module_name": "pinctrl-digicolor.c",
  "hash_id": "dfd2c60a9f7969eb066cde37084a1ae7b81461bd7c14852ce5bc12bb478c3d71",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/pinctrl-digicolor.c",
  "human_readable_source": "\n \n\n#include <linux/gpio/driver.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/spinlock.h>\n\n#include <linux/pinctrl/machine.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinconf-generic.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinmux.h>\n\n#include \"pinctrl-utils.h\"\n\n#define DRIVER_NAME\t\"pinctrl-digicolor\"\n\n#define GP_CLIENTSEL(clct)\t((clct)*8 + 0x20)\n#define GP_DRIVE0(clct)\t\t(GP_CLIENTSEL(clct) + 2)\n#define GP_OUTPUT0(clct)\t(GP_CLIENTSEL(clct) + 3)\n#define GP_INPUT(clct)\t\t(GP_CLIENTSEL(clct) + 6)\n\n#define PIN_COLLECTIONS\t\t('R' - 'A' + 1)\n#define PINS_PER_COLLECTION\t8\n#define PINS_COUNT\t\t(PIN_COLLECTIONS * PINS_PER_COLLECTION)\n\nstruct dc_pinmap {\n\tvoid __iomem\t\t*regs;\n\tstruct device\t\t*dev;\n\tstruct pinctrl_dev\t*pctl;\n\n\tstruct pinctrl_desc\t*desc;\n\tconst char\t\t*pin_names[PINS_COUNT];\n\n\tstruct gpio_chip\tchip;\n\tspinlock_t\t\tlock;\n};\n\nstatic int dc_get_groups_count(struct pinctrl_dev *pctldev)\n{\n\treturn PINS_COUNT;\n}\n\nstatic const char *dc_get_group_name(struct pinctrl_dev *pctldev,\n\t\t\t\t     unsigned selector)\n{\n\tstruct dc_pinmap *pmap = pinctrl_dev_get_drvdata(pctldev);\n\n\t \n\treturn pmap->desc->pins[selector].name;\n}\n\nstatic int dc_get_group_pins(struct pinctrl_dev *pctldev, unsigned selector,\n\t\t\t     const unsigned **pins,\n\t\t\t     unsigned *num_pins)\n{\n\tstruct dc_pinmap *pmap = pinctrl_dev_get_drvdata(pctldev);\n\n\t*pins = &pmap->desc->pins[selector].number;\n\t*num_pins = 1;\n\n\treturn 0;\n}\n\nstatic const struct pinctrl_ops dc_pinctrl_ops = {\n\t.get_groups_count\t= dc_get_groups_count,\n\t.get_group_name\t\t= dc_get_group_name,\n\t.get_group_pins\t\t= dc_get_group_pins,\n\t.dt_node_to_map\t\t= pinconf_generic_dt_node_to_map_pin,\n\t.dt_free_map\t\t= pinctrl_utils_free_map,\n};\n\nstatic const char *const dc_functions[] = {\n\t\"gpio\",\n\t\"client_a\",\n\t\"client_b\",\n\t\"client_c\",\n};\n\nstatic int dc_get_functions_count(struct pinctrl_dev *pctldev)\n{\n\treturn ARRAY_SIZE(dc_functions);\n}\n\nstatic const char *dc_get_fname(struct pinctrl_dev *pctldev, unsigned selector)\n{\n\treturn dc_functions[selector];\n}\n\nstatic int dc_get_groups(struct pinctrl_dev *pctldev, unsigned selector,\n\t\t\t const char * const **groups,\n\t\t\t unsigned * const num_groups)\n{\n\tstruct dc_pinmap *pmap = pinctrl_dev_get_drvdata(pctldev);\n\n\t*groups = pmap->pin_names;\n\t*num_groups = PINS_COUNT;\n\n\treturn 0;\n}\n\nstatic void dc_client_sel(int pin_num, int *reg, int *bit)\n{\n\t*bit = (pin_num % PINS_PER_COLLECTION) * 2;\n\t*reg = GP_CLIENTSEL(pin_num/PINS_PER_COLLECTION);\n\n\tif (*bit >= PINS_PER_COLLECTION) {\n\t\t*bit -= PINS_PER_COLLECTION;\n\t\t*reg += 1;\n\t}\n}\n\nstatic int dc_set_mux(struct pinctrl_dev *pctldev, unsigned selector,\n\t\t      unsigned group)\n{\n\tstruct dc_pinmap *pmap = pinctrl_dev_get_drvdata(pctldev);\n\tint bit_off, reg_off;\n\tu8 reg;\n\n\tdc_client_sel(group, &reg_off, &bit_off);\n\n\treg = readb_relaxed(pmap->regs + reg_off);\n\treg &= ~(3 << bit_off);\n\treg |= (selector << bit_off);\n\twriteb_relaxed(reg, pmap->regs + reg_off);\n\n\treturn 0;\n}\n\nstatic int dc_pmx_request_gpio(struct pinctrl_dev *pcdev,\n\t\t\t       struct pinctrl_gpio_range *range,\n\t\t\t       unsigned offset)\n{\n\tstruct dc_pinmap *pmap = pinctrl_dev_get_drvdata(pcdev);\n\tint bit_off, reg_off;\n\tu8 reg;\n\n\tdc_client_sel(offset, &reg_off, &bit_off);\n\n\treg = readb_relaxed(pmap->regs + reg_off);\n\tif ((reg & (3 << bit_off)) != 0)\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n\nstatic const struct pinmux_ops dc_pmxops = {\n\t.get_functions_count\t= dc_get_functions_count,\n\t.get_function_name\t= dc_get_fname,\n\t.get_function_groups\t= dc_get_groups,\n\t.set_mux\t\t= dc_set_mux,\n\t.gpio_request_enable\t= dc_pmx_request_gpio,\n};\n\nstatic int dc_gpio_direction_input(struct gpio_chip *chip, unsigned gpio)\n{\n\tstruct dc_pinmap *pmap = gpiochip_get_data(chip);\n\tint reg_off = GP_DRIVE0(gpio/PINS_PER_COLLECTION);\n\tint bit_off = gpio % PINS_PER_COLLECTION;\n\tu8 drive;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pmap->lock, flags);\n\tdrive = readb_relaxed(pmap->regs + reg_off);\n\tdrive &= ~BIT(bit_off);\n\twriteb_relaxed(drive, pmap->regs + reg_off);\n\tspin_unlock_irqrestore(&pmap->lock, flags);\n\n\treturn 0;\n}\n\nstatic void dc_gpio_set(struct gpio_chip *chip, unsigned gpio, int value);\n\nstatic int dc_gpio_direction_output(struct gpio_chip *chip, unsigned gpio,\n\t\t\t\t    int value)\n{\n\tstruct dc_pinmap *pmap = gpiochip_get_data(chip);\n\tint reg_off = GP_DRIVE0(gpio/PINS_PER_COLLECTION);\n\tint bit_off = gpio % PINS_PER_COLLECTION;\n\tu8 drive;\n\tunsigned long flags;\n\n\tdc_gpio_set(chip, gpio, value);\n\n\tspin_lock_irqsave(&pmap->lock, flags);\n\tdrive = readb_relaxed(pmap->regs + reg_off);\n\tdrive |= BIT(bit_off);\n\twriteb_relaxed(drive, pmap->regs + reg_off);\n\tspin_unlock_irqrestore(&pmap->lock, flags);\n\n\treturn 0;\n}\n\nstatic int dc_gpio_get(struct gpio_chip *chip, unsigned gpio)\n{\n\tstruct dc_pinmap *pmap = gpiochip_get_data(chip);\n\tint reg_off = GP_INPUT(gpio/PINS_PER_COLLECTION);\n\tint bit_off = gpio % PINS_PER_COLLECTION;\n\tu8 input;\n\n\tinput = readb_relaxed(pmap->regs + reg_off);\n\n\treturn !!(input & BIT(bit_off));\n}\n\nstatic void dc_gpio_set(struct gpio_chip *chip, unsigned gpio, int value)\n{\n\tstruct dc_pinmap *pmap = gpiochip_get_data(chip);\n\tint reg_off = GP_OUTPUT0(gpio/PINS_PER_COLLECTION);\n\tint bit_off = gpio % PINS_PER_COLLECTION;\n\tu8 output;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pmap->lock, flags);\n\toutput = readb_relaxed(pmap->regs + reg_off);\n\tif (value)\n\t\toutput |= BIT(bit_off);\n\telse\n\t\toutput &= ~BIT(bit_off);\n\twriteb_relaxed(output, pmap->regs + reg_off);\n\tspin_unlock_irqrestore(&pmap->lock, flags);\n}\n\nstatic int dc_gpiochip_add(struct dc_pinmap *pmap)\n{\n\tstruct gpio_chip *chip = &pmap->chip;\n\tint ret;\n\n\tchip->label\t\t= DRIVER_NAME;\n\tchip->parent\t\t= pmap->dev;\n\tchip->request\t\t= gpiochip_generic_request;\n\tchip->free\t\t= gpiochip_generic_free;\n\tchip->direction_input\t= dc_gpio_direction_input;\n\tchip->direction_output\t= dc_gpio_direction_output;\n\tchip->get\t\t= dc_gpio_get;\n\tchip->set\t\t= dc_gpio_set;\n\tchip->base\t\t= -1;\n\tchip->ngpio\t\t= PINS_COUNT;\n\n\tspin_lock_init(&pmap->lock);\n\n\tret = gpiochip_add_data(chip, pmap);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = gpiochip_add_pin_range(chip, dev_name(pmap->dev), 0, 0,\n\t\t\t\t     PINS_COUNT);\n\tif (ret < 0) {\n\t\tgpiochip_remove(chip);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int dc_pinctrl_probe(struct platform_device *pdev)\n{\n\tstruct dc_pinmap *pmap;\n\tstruct pinctrl_pin_desc *pins;\n\tstruct pinctrl_desc *pctl_desc;\n\tchar *pin_names;\n\tint name_len = strlen(\"GP_xx\") + 1;\n\tint i, j;\n\n\tpmap = devm_kzalloc(&pdev->dev, sizeof(*pmap), GFP_KERNEL);\n\tif (!pmap)\n\t\treturn -ENOMEM;\n\n\tpmap->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(pmap->regs))\n\t\treturn PTR_ERR(pmap->regs);\n\n\tpins = devm_kcalloc(&pdev->dev, PINS_COUNT, sizeof(*pins),\n\t\t\t    GFP_KERNEL);\n\tif (!pins)\n\t\treturn -ENOMEM;\n\tpin_names = devm_kcalloc(&pdev->dev, PINS_COUNT, name_len,\n\t\t\t\t GFP_KERNEL);\n\tif (!pin_names)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < PIN_COLLECTIONS; i++) {\n\t\tfor (j = 0; j < PINS_PER_COLLECTION; j++) {\n\t\t\tint pin_id = i*PINS_PER_COLLECTION + j;\n\t\t\tchar *name = &pin_names[pin_id * name_len];\n\n\t\t\tsnprintf(name, name_len, \"GP_%c%c\", 'A'+i, '0'+j);\n\n\t\t\tpins[pin_id].number = pin_id;\n\t\t\tpins[pin_id].name = name;\n\t\t\tpmap->pin_names[pin_id] = name;\n\t\t}\n\t}\n\n\tpctl_desc = devm_kzalloc(&pdev->dev, sizeof(*pctl_desc), GFP_KERNEL);\n\tif (!pctl_desc)\n\t\treturn -ENOMEM;\n\n\tpctl_desc->name\t= DRIVER_NAME,\n\tpctl_desc->owner = THIS_MODULE,\n\tpctl_desc->pctlops = &dc_pinctrl_ops,\n\tpctl_desc->pmxops = &dc_pmxops,\n\tpctl_desc->npins = PINS_COUNT;\n\tpctl_desc->pins = pins;\n\tpmap->desc = pctl_desc;\n\n\tpmap->dev = &pdev->dev;\n\n\tpmap->pctl = devm_pinctrl_register(&pdev->dev, pctl_desc, pmap);\n\tif (IS_ERR(pmap->pctl)) {\n\t\tdev_err(&pdev->dev, \"pinctrl driver registration failed\\n\");\n\t\treturn PTR_ERR(pmap->pctl);\n\t}\n\n\treturn dc_gpiochip_add(pmap);\n}\n\nstatic const struct of_device_id dc_pinctrl_ids[] = {\n\t{ .compatible = \"cnxt,cx92755-pinctrl\" },\n\t{   }\n};\n\nstatic struct platform_driver dc_pinctrl_driver = {\n\t.driver = {\n\t\t.name = DRIVER_NAME,\n\t\t.of_match_table = dc_pinctrl_ids,\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe = dc_pinctrl_probe,\n};\nbuiltin_platform_driver(dc_pinctrl_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}