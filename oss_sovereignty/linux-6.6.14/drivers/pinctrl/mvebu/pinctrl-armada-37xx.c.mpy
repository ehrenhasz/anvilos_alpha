{
  "module_name": "pinctrl-armada-37xx.c",
  "hash_id": "7ab16d49bc185d425dda19e7d5a47475eba8040a2c31c9c081c9b285f9fe9848",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c",
  "human_readable_source": " \n\n#include <linux/gpio/driver.h>\n#include <linux/mfd/syscon.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/pinctrl/pinconf-generic.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinmux.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/string_helpers.h>\n\n#include \"../pinctrl-utils.h\"\n\n#define OUTPUT_EN\t0x0\n#define INPUT_VAL\t0x10\n#define OUTPUT_VAL\t0x18\n#define OUTPUT_CTL\t0x20\n#define SELECTION\t0x30\n\n#define IRQ_EN\t\t0x0\n#define IRQ_POL\t\t0x08\n#define IRQ_STATUS\t0x10\n#define IRQ_WKUP\t0x18\n\n#define NB_FUNCS 3\n#define GPIO_PER_REG\t32\n\n \nstruct armada_37xx_pin_group {\n\tconst char\t*name;\n\tunsigned int\tstart_pin;\n\tunsigned int\tnpins;\n\tu32\t\treg_mask;\n\tu32\t\tval[NB_FUNCS];\n\tunsigned int\textra_pin;\n\tunsigned int\textra_npins;\n\tconst char\t*funcs[NB_FUNCS];\n\tunsigned int\t*pins;\n};\n\nstruct armada_37xx_pin_data {\n\tu8\t\t\t\tnr_pins;\n\tchar\t\t\t\t*name;\n\tstruct armada_37xx_pin_group\t*groups;\n\tint\t\t\t\tngroups;\n};\n\nstruct armada_37xx_pmx_func {\n\tconst char\t\t*name;\n\tconst char\t\t**groups;\n\tunsigned int\t\tngroups;\n};\n\nstruct armada_37xx_pm_state {\n\tu32 out_en_l;\n\tu32 out_en_h;\n\tu32 out_val_l;\n\tu32 out_val_h;\n\tu32 irq_en_l;\n\tu32 irq_en_h;\n\tu32 irq_pol_l;\n\tu32 irq_pol_h;\n\tu32 selection;\n};\n\nstruct armada_37xx_pinctrl {\n\tstruct regmap\t\t\t*regmap;\n\tvoid __iomem\t\t\t*base;\n\tconst struct armada_37xx_pin_data\t*data;\n\tstruct device\t\t\t*dev;\n\tstruct gpio_chip\t\tgpio_chip;\n\traw_spinlock_t\t\t\tirq_lock;\n\tstruct pinctrl_desc\t\tpctl;\n\tstruct pinctrl_dev\t\t*pctl_dev;\n\tstruct armada_37xx_pin_group\t*groups;\n\tunsigned int\t\t\tngroups;\n\tstruct armada_37xx_pmx_func\t*funcs;\n\tunsigned int\t\t\tnfuncs;\n\tstruct armada_37xx_pm_state\tpm;\n};\n\n#define PIN_GRP_GPIO_0(_name, _start, _nr)\t\\\n\t{\t\t\t\t\t\\\n\t\t.name = _name,\t\t\t\\\n\t\t.start_pin = _start,\t\t\\\n\t\t.npins = _nr,\t\t\t\\\n\t\t.reg_mask = 0,\t\t\t\\\n\t\t.val = {0},\t\t\t\\\n\t\t.funcs = {\"gpio\"}\t\t\\\n\t}\n\n#define PIN_GRP_GPIO(_name, _start, _nr, _mask, _func1)\t\\\n\t{\t\t\t\t\t\\\n\t\t.name = _name,\t\t\t\\\n\t\t.start_pin = _start,\t\t\\\n\t\t.npins = _nr,\t\t\t\\\n\t\t.reg_mask = _mask,\t\t\\\n\t\t.val = {0, _mask},\t\t\\\n\t\t.funcs = {_func1, \"gpio\"}\t\\\n\t}\n\n#define PIN_GRP_GPIO_2(_name, _start, _nr, _mask, _val1, _val2, _func1)   \\\n\t{\t\t\t\t\t\\\n\t\t.name = _name,\t\t\t\\\n\t\t.start_pin = _start,\t\t\\\n\t\t.npins = _nr,\t\t\t\\\n\t\t.reg_mask = _mask,\t\t\\\n\t\t.val = {_val1, _val2},\t\t\\\n\t\t.funcs = {_func1, \"gpio\"}\t\\\n\t}\n\n#define PIN_GRP_GPIO_3(_name, _start, _nr, _mask, _v1, _v2, _v3, _f1, _f2) \\\n\t{\t\t\t\t\t\\\n\t\t.name = _name,\t\t\t\\\n\t\t.start_pin = _start,\t\t\\\n\t\t.npins = _nr,\t\t\t\\\n\t\t.reg_mask = _mask,\t\t\\\n\t\t.val = {_v1, _v2, _v3},\t\\\n\t\t.funcs = {_f1, _f2, \"gpio\"}\t\\\n\t}\n\n#define PIN_GRP_EXTRA(_name, _start, _nr, _mask, _v1, _v2, _start2, _nr2, \\\n\t\t      _f1, _f2)\t\t\t\t\\\n\t{\t\t\t\t\t\t\\\n\t\t.name = _name,\t\t\t\t\\\n\t\t.start_pin = _start,\t\t\t\\\n\t\t.npins = _nr,\t\t\t\t\\\n\t\t.reg_mask = _mask,\t\t\t\\\n\t\t.val = {_v1, _v2},\t\t\t\\\n\t\t.extra_pin = _start2,\t\t\t\\\n\t\t.extra_npins = _nr2,\t\t\t\\\n\t\t.funcs = {_f1, _f2}\t\t\t\\\n\t}\n\nstatic struct armada_37xx_pin_group armada_37xx_nb_groups[] = {\n\tPIN_GRP_GPIO(\"jtag\", 20, 5, BIT(0), \"jtag\"),\n\tPIN_GRP_GPIO(\"sdio0\", 8, 3, BIT(1), \"sdio\"),\n\tPIN_GRP_GPIO(\"emmc_nb\", 27, 9, BIT(2), \"emmc\"),\n\tPIN_GRP_GPIO_3(\"pwm0\", 11, 1, BIT(3) | BIT(20), 0, BIT(20), BIT(3),\n\t\t       \"pwm\", \"led\"),\n\tPIN_GRP_GPIO_3(\"pwm1\", 12, 1, BIT(4) | BIT(21), 0, BIT(21), BIT(4),\n\t\t       \"pwm\", \"led\"),\n\tPIN_GRP_GPIO_3(\"pwm2\", 13, 1, BIT(5) | BIT(22), 0, BIT(22), BIT(5),\n\t\t       \"pwm\", \"led\"),\n\tPIN_GRP_GPIO_3(\"pwm3\", 14, 1, BIT(6) | BIT(23), 0, BIT(23), BIT(6),\n\t\t       \"pwm\", \"led\"),\n\tPIN_GRP_GPIO(\"pmic1\", 7, 1, BIT(7), \"pmic\"),\n\tPIN_GRP_GPIO(\"pmic0\", 6, 1, BIT(8), \"pmic\"),\n\tPIN_GRP_GPIO_0(\"gpio1_5\", 5, 1),\n\tPIN_GRP_GPIO(\"i2c2\", 2, 2, BIT(9), \"i2c\"),\n\tPIN_GRP_GPIO(\"i2c1\", 0, 2, BIT(10), \"i2c\"),\n\tPIN_GRP_GPIO(\"spi_cs1\", 17, 1, BIT(12), \"spi\"),\n\tPIN_GRP_GPIO_2(\"spi_cs2\", 18, 1, BIT(13) | BIT(19), 0, BIT(13), \"spi\"),\n\tPIN_GRP_GPIO_2(\"spi_cs3\", 19, 1, BIT(14) | BIT(19), 0, BIT(14), \"spi\"),\n\tPIN_GRP_GPIO(\"onewire\", 4, 1, BIT(16), \"onewire\"),\n\tPIN_GRP_GPIO(\"uart1\", 25, 2, BIT(17), \"uart\"),\n\tPIN_GRP_GPIO(\"spi_quad\", 15, 2, BIT(18), \"spi\"),\n\tPIN_GRP_EXTRA(\"uart2\", 9, 2, BIT(1) | BIT(13) | BIT(14) | BIT(19),\n\t\t      BIT(1) | BIT(13) | BIT(14), BIT(1) | BIT(19),\n\t\t      18, 2, \"gpio\", \"uart\"),\n};\n\nstatic struct armada_37xx_pin_group armada_37xx_sb_groups[] = {\n\tPIN_GRP_GPIO(\"usb32_drvvbus0\", 0, 1, BIT(0), \"drvbus\"),\n\tPIN_GRP_GPIO(\"usb2_drvvbus1\", 1, 1, BIT(1), \"drvbus\"),\n\tPIN_GRP_GPIO_0(\"gpio2_2\", 2, 1),\n\tPIN_GRP_GPIO(\"sdio_sb\", 24, 6, BIT(2), \"sdio\"),\n\tPIN_GRP_GPIO(\"rgmii\", 6, 12, BIT(3), \"mii\"),\n\tPIN_GRP_GPIO(\"smi\", 18, 2, BIT(4), \"smi\"),\n\tPIN_GRP_GPIO(\"pcie1\", 3, 1, BIT(5), \"pcie\"),  \n\tPIN_GRP_GPIO(\"pcie1_clkreq\", 4, 1, BIT(9), \"pcie\"),\n\tPIN_GRP_GPIO(\"pcie1_wakeup\", 5, 1, BIT(10), \"pcie\"),\n\tPIN_GRP_GPIO(\"ptp\", 20, 1, BIT(11), \"ptp\"),\n\tPIN_GRP_GPIO_3(\"ptp_clk\", 21, 1, BIT(6) | BIT(12), 0, BIT(6), BIT(12),\n\t\t       \"ptp\", \"mii\"),\n\tPIN_GRP_GPIO_3(\"ptp_trig\", 22, 1, BIT(7) | BIT(13), 0, BIT(7), BIT(13),\n\t\t       \"ptp\", \"mii\"),\n\tPIN_GRP_GPIO_3(\"mii_col\", 23, 1, BIT(8) | BIT(14), 0, BIT(8), BIT(14),\n\t\t       \"mii\", \"mii_err\"),\n};\n\nstatic const struct armada_37xx_pin_data armada_37xx_pin_nb = {\n\t.nr_pins = 36,\n\t.name = \"GPIO1\",\n\t.groups = armada_37xx_nb_groups,\n\t.ngroups = ARRAY_SIZE(armada_37xx_nb_groups),\n};\n\nstatic const struct armada_37xx_pin_data armada_37xx_pin_sb = {\n\t.nr_pins = 30,\n\t.name = \"GPIO2\",\n\t.groups = armada_37xx_sb_groups,\n\t.ngroups = ARRAY_SIZE(armada_37xx_sb_groups),\n};\n\nstatic inline void armada_37xx_update_reg(unsigned int *reg,\n\t\t\t\t\t  unsigned int *offset)\n{\n\t \n\tif (*offset >= GPIO_PER_REG) {\n\t\t*offset -= GPIO_PER_REG;\n\t\t*reg += sizeof(u32);\n\t}\n}\n\nstatic struct armada_37xx_pin_group *armada_37xx_find_next_grp_by_pin(\n\tstruct armada_37xx_pinctrl *info, int pin, int *grp)\n{\n\twhile (*grp < info->ngroups) {\n\t\tstruct armada_37xx_pin_group *group = &info->groups[*grp];\n\t\tint j;\n\n\t\t*grp = *grp + 1;\n\t\tfor (j = 0; j < (group->npins + group->extra_npins); j++)\n\t\t\tif (group->pins[j] == pin)\n\t\t\t\treturn group;\n\t}\n\treturn NULL;\n}\n\nstatic int armada_37xx_pin_config_group_get(struct pinctrl_dev *pctldev,\n\t\t\t    unsigned int selector, unsigned long *config)\n{\n\treturn -ENOTSUPP;\n}\n\nstatic int armada_37xx_pin_config_group_set(struct pinctrl_dev *pctldev,\n\t\t\t    unsigned int selector, unsigned long *configs,\n\t\t\t    unsigned int num_configs)\n{\n\treturn -ENOTSUPP;\n}\n\nstatic const struct pinconf_ops armada_37xx_pinconf_ops = {\n\t.is_generic = true,\n\t.pin_config_group_get = armada_37xx_pin_config_group_get,\n\t.pin_config_group_set = armada_37xx_pin_config_group_set,\n};\n\nstatic int armada_37xx_get_groups_count(struct pinctrl_dev *pctldev)\n{\n\tstruct armada_37xx_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn info->ngroups;\n}\n\nstatic const char *armada_37xx_get_group_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t      unsigned int group)\n{\n\tstruct armada_37xx_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn info->groups[group].name;\n}\n\nstatic int armada_37xx_get_group_pins(struct pinctrl_dev *pctldev,\n\t\t\t\t      unsigned int selector,\n\t\t\t\t      const unsigned int **pins,\n\t\t\t\t      unsigned int *npins)\n{\n\tstruct armada_37xx_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\n\n\tif (selector >= info->ngroups)\n\t\treturn -EINVAL;\n\n\t*pins = info->groups[selector].pins;\n\t*npins = info->groups[selector].npins +\n\t\tinfo->groups[selector].extra_npins;\n\n\treturn 0;\n}\n\nstatic const struct pinctrl_ops armada_37xx_pctrl_ops = {\n\t.get_groups_count\t= armada_37xx_get_groups_count,\n\t.get_group_name\t\t= armada_37xx_get_group_name,\n\t.get_group_pins\t\t= armada_37xx_get_group_pins,\n\t.dt_node_to_map\t\t= pinconf_generic_dt_node_to_map_group,\n\t.dt_free_map\t\t= pinctrl_utils_free_map,\n};\n\n \n\nstatic int armada_37xx_pmx_get_funcs_count(struct pinctrl_dev *pctldev)\n{\n\tstruct armada_37xx_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn info->nfuncs;\n}\n\nstatic const char *armada_37xx_pmx_get_func_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t\t unsigned int selector)\n{\n\tstruct armada_37xx_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn info->funcs[selector].name;\n}\n\nstatic int armada_37xx_pmx_get_groups(struct pinctrl_dev *pctldev,\n\t\t\t\t      unsigned int selector,\n\t\t\t\t      const char * const **groups,\n\t\t\t\t      unsigned int * const num_groups)\n{\n\tstruct armada_37xx_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\n\n\t*groups = info->funcs[selector].groups;\n\t*num_groups = info->funcs[selector].ngroups;\n\n\treturn 0;\n}\n\nstatic int armada_37xx_pmx_set_by_name(struct pinctrl_dev *pctldev,\n\t\t\t\t       const char *name,\n\t\t\t\t       struct armada_37xx_pin_group *grp)\n{\n\tstruct armada_37xx_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\n\tstruct device *dev = info->dev;\n\tunsigned int reg = SELECTION;\n\tunsigned int mask = grp->reg_mask;\n\tint func, val;\n\n\tdev_dbg(dev, \"enable function %s group %s\\n\", name, grp->name);\n\n\tfunc = match_string(grp->funcs, NB_FUNCS, name);\n\tif (func < 0)\n\t\treturn -ENOTSUPP;\n\n\tval = grp->val[func];\n\n\tregmap_update_bits(info->regmap, reg, mask, val);\n\n\treturn 0;\n}\n\nstatic int armada_37xx_pmx_set(struct pinctrl_dev *pctldev,\n\t\t\t       unsigned int selector,\n\t\t\t       unsigned int group)\n{\n\n\tstruct armada_37xx_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\n\tstruct armada_37xx_pin_group *grp = &info->groups[group];\n\tconst char *name = info->funcs[selector].name;\n\n\treturn armada_37xx_pmx_set_by_name(pctldev, name, grp);\n}\n\nstatic inline void armada_37xx_irq_update_reg(unsigned int *reg,\n\t\t\t\t\t  struct irq_data *d)\n{\n\tint offset = irqd_to_hwirq(d);\n\n\tarmada_37xx_update_reg(reg, &offset);\n}\n\nstatic int armada_37xx_gpio_direction_input(struct gpio_chip *chip,\n\t\t\t\t\t    unsigned int offset)\n{\n\tstruct armada_37xx_pinctrl *info = gpiochip_get_data(chip);\n\tunsigned int reg = OUTPUT_EN;\n\tunsigned int mask;\n\n\tarmada_37xx_update_reg(&reg, &offset);\n\tmask = BIT(offset);\n\n\treturn regmap_update_bits(info->regmap, reg, mask, 0);\n}\n\nstatic int armada_37xx_gpio_get_direction(struct gpio_chip *chip,\n\t\t\t\t\t  unsigned int offset)\n{\n\tstruct armada_37xx_pinctrl *info = gpiochip_get_data(chip);\n\tunsigned int reg = OUTPUT_EN;\n\tunsigned int val, mask;\n\n\tarmada_37xx_update_reg(&reg, &offset);\n\tmask = BIT(offset);\n\tregmap_read(info->regmap, reg, &val);\n\n\tif (val & mask)\n\t\treturn GPIO_LINE_DIRECTION_OUT;\n\n\treturn GPIO_LINE_DIRECTION_IN;\n}\n\nstatic int armada_37xx_gpio_direction_output(struct gpio_chip *chip,\n\t\t\t\t\t     unsigned int offset, int value)\n{\n\tstruct armada_37xx_pinctrl *info = gpiochip_get_data(chip);\n\tunsigned int reg = OUTPUT_EN;\n\tunsigned int mask, val, ret;\n\n\tarmada_37xx_update_reg(&reg, &offset);\n\tmask = BIT(offset);\n\n\tret = regmap_update_bits(info->regmap, reg, mask, mask);\n\n\tif (ret)\n\t\treturn ret;\n\n\treg = OUTPUT_VAL;\n\tval = value ? mask : 0;\n\tregmap_update_bits(info->regmap, reg, mask, val);\n\n\treturn 0;\n}\n\nstatic int armada_37xx_gpio_get(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct armada_37xx_pinctrl *info = gpiochip_get_data(chip);\n\tunsigned int reg = INPUT_VAL;\n\tunsigned int val, mask;\n\n\tarmada_37xx_update_reg(&reg, &offset);\n\tmask = BIT(offset);\n\n\tregmap_read(info->regmap, reg, &val);\n\n\treturn (val & mask) != 0;\n}\n\nstatic void armada_37xx_gpio_set(struct gpio_chip *chip, unsigned int offset,\n\t\t\t\t int value)\n{\n\tstruct armada_37xx_pinctrl *info = gpiochip_get_data(chip);\n\tunsigned int reg = OUTPUT_VAL;\n\tunsigned int mask, val;\n\n\tarmada_37xx_update_reg(&reg, &offset);\n\tmask = BIT(offset);\n\tval = value ? mask : 0;\n\n\tregmap_update_bits(info->regmap, reg, mask, val);\n}\n\nstatic int armada_37xx_pmx_gpio_set_direction(struct pinctrl_dev *pctldev,\n\t\t\t\t\t      struct pinctrl_gpio_range *range,\n\t\t\t\t\t      unsigned int offset, bool input)\n{\n\tstruct armada_37xx_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\n\tstruct gpio_chip *chip = range->gc;\n\n\tdev_dbg(info->dev, \"gpio_direction for pin %u as %s-%d to %s\\n\",\n\t\toffset, range->name, offset, input ? \"input\" : \"output\");\n\n\tif (input)\n\t\tarmada_37xx_gpio_direction_input(chip, offset);\n\telse\n\t\tarmada_37xx_gpio_direction_output(chip, offset, 0);\n\n\treturn 0;\n}\n\nstatic int armada_37xx_gpio_request_enable(struct pinctrl_dev *pctldev,\n\t\t\t\t\t   struct pinctrl_gpio_range *range,\n\t\t\t\t\t   unsigned int offset)\n{\n\tstruct armada_37xx_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\n\tstruct armada_37xx_pin_group *group;\n\tint grp = 0;\n\tint ret;\n\n\tdev_dbg(info->dev, \"requesting gpio %d\\n\", offset);\n\n\twhile ((group = armada_37xx_find_next_grp_by_pin(info, offset, &grp))) {\n\t\tret = armada_37xx_pmx_set_by_name(pctldev, \"gpio\", group);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct pinmux_ops armada_37xx_pmx_ops = {\n\t.get_functions_count\t= armada_37xx_pmx_get_funcs_count,\n\t.get_function_name\t= armada_37xx_pmx_get_func_name,\n\t.get_function_groups\t= armada_37xx_pmx_get_groups,\n\t.set_mux\t\t= armada_37xx_pmx_set,\n\t.gpio_request_enable\t= armada_37xx_gpio_request_enable,\n\t.gpio_set_direction\t= armada_37xx_pmx_gpio_set_direction,\n};\n\nstatic const struct gpio_chip armada_37xx_gpiolib_chip = {\n\t.request = gpiochip_generic_request,\n\t.free = gpiochip_generic_free,\n\t.set = armada_37xx_gpio_set,\n\t.get = armada_37xx_gpio_get,\n\t.get_direction\t= armada_37xx_gpio_get_direction,\n\t.direction_input = armada_37xx_gpio_direction_input,\n\t.direction_output = armada_37xx_gpio_direction_output,\n\t.owner = THIS_MODULE,\n};\n\nstatic void armada_37xx_irq_ack(struct irq_data *d)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(d);\n\tstruct armada_37xx_pinctrl *info = gpiochip_get_data(chip);\n\tu32 reg = IRQ_STATUS;\n\tunsigned long flags;\n\n\tarmada_37xx_irq_update_reg(&reg, d);\n\traw_spin_lock_irqsave(&info->irq_lock, flags);\n\twritel(d->mask, info->base + reg);\n\traw_spin_unlock_irqrestore(&info->irq_lock, flags);\n}\n\nstatic void armada_37xx_irq_mask(struct irq_data *d)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(d);\n\tstruct armada_37xx_pinctrl *info = gpiochip_get_data(chip);\n\tu32 val, reg = IRQ_EN;\n\tunsigned long flags;\n\n\tarmada_37xx_irq_update_reg(&reg, d);\n\traw_spin_lock_irqsave(&info->irq_lock, flags);\n\tval = readl(info->base + reg);\n\twritel(val & ~d->mask, info->base + reg);\n\traw_spin_unlock_irqrestore(&info->irq_lock, flags);\n\tgpiochip_disable_irq(chip, irqd_to_hwirq(d));\n}\n\nstatic void armada_37xx_irq_unmask(struct irq_data *d)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(d);\n\tstruct armada_37xx_pinctrl *info = gpiochip_get_data(chip);\n\tu32 val, reg = IRQ_EN;\n\tunsigned long flags;\n\n\tgpiochip_enable_irq(chip, irqd_to_hwirq(d));\n\tarmada_37xx_irq_update_reg(&reg, d);\n\traw_spin_lock_irqsave(&info->irq_lock, flags);\n\tval = readl(info->base + reg);\n\twritel(val | d->mask, info->base + reg);\n\traw_spin_unlock_irqrestore(&info->irq_lock, flags);\n}\n\nstatic int armada_37xx_irq_set_wake(struct irq_data *d, unsigned int on)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(d);\n\tstruct armada_37xx_pinctrl *info = gpiochip_get_data(chip);\n\tu32 val, reg = IRQ_WKUP;\n\tunsigned long flags;\n\n\tarmada_37xx_irq_update_reg(&reg, d);\n\traw_spin_lock_irqsave(&info->irq_lock, flags);\n\tval = readl(info->base + reg);\n\tif (on)\n\t\tval |= (BIT(d->hwirq % GPIO_PER_REG));\n\telse\n\t\tval &= ~(BIT(d->hwirq % GPIO_PER_REG));\n\twritel(val, info->base + reg);\n\traw_spin_unlock_irqrestore(&info->irq_lock, flags);\n\n\treturn 0;\n}\n\nstatic int armada_37xx_irq_set_type(struct irq_data *d, unsigned int type)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(d);\n\tstruct armada_37xx_pinctrl *info = gpiochip_get_data(chip);\n\tu32 val, reg = IRQ_POL;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&info->irq_lock, flags);\n\tarmada_37xx_irq_update_reg(&reg, d);\n\tval = readl(info->base + reg);\n\tswitch (type) {\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tval &= ~(BIT(d->hwirq % GPIO_PER_REG));\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tval |= (BIT(d->hwirq % GPIO_PER_REG));\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_BOTH: {\n\t\tu32 in_val, in_reg = INPUT_VAL;\n\n\t\tarmada_37xx_irq_update_reg(&in_reg, d);\n\t\tregmap_read(info->regmap, in_reg, &in_val);\n\n\t\t \n\t\tif (in_val & BIT(d->hwirq % GPIO_PER_REG))\n\t\t\tval |= BIT(d->hwirq % GPIO_PER_REG);\t \n\t\telse\n\t\t\tval &= ~(BIT(d->hwirq % GPIO_PER_REG));\t \n\t\tbreak;\n\t}\n\tdefault:\n\t\traw_spin_unlock_irqrestore(&info->irq_lock, flags);\n\t\treturn -EINVAL;\n\t}\n\twritel(val, info->base + reg);\n\traw_spin_unlock_irqrestore(&info->irq_lock, flags);\n\n\treturn 0;\n}\n\nstatic int armada_37xx_edge_both_irq_swap_pol(struct armada_37xx_pinctrl *info,\n\t\t\t\t\t     u32 pin_idx)\n{\n\tu32 reg_idx = pin_idx / GPIO_PER_REG;\n\tu32 bit_num = pin_idx % GPIO_PER_REG;\n\tu32 p, l, ret;\n\tunsigned long flags;\n\n\tregmap_read(info->regmap, INPUT_VAL + 4*reg_idx, &l);\n\n\traw_spin_lock_irqsave(&info->irq_lock, flags);\n\tp = readl(info->base + IRQ_POL + 4 * reg_idx);\n\tif ((p ^ l) & (1 << bit_num)) {\n\t\t \n\t\tp ^= 1 << bit_num;\n\t\twritel(p, info->base + IRQ_POL + 4 * reg_idx);\n\t\tret = 0;\n\t} else {\n\t\t \n\t\tret = -1;\n\t}\n\n\traw_spin_unlock_irqrestore(&info->irq_lock, flags);\n\treturn ret;\n}\n\nstatic void armada_37xx_irq_handler(struct irq_desc *desc)\n{\n\tstruct gpio_chip *gc = irq_desc_get_handler_data(desc);\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tstruct armada_37xx_pinctrl *info = gpiochip_get_data(gc);\n\tstruct irq_domain *d = gc->irq.domain;\n\tint i;\n\n\tchained_irq_enter(chip, desc);\n\tfor (i = 0; i <= d->revmap_size / GPIO_PER_REG; i++) {\n\t\tu32 status;\n\t\tunsigned long flags;\n\n\t\traw_spin_lock_irqsave(&info->irq_lock, flags);\n\t\tstatus = readl_relaxed(info->base + IRQ_STATUS + 4 * i);\n\t\t \n\t\tstatus &= readl_relaxed(info->base + IRQ_EN + 4 * i);\n\t\traw_spin_unlock_irqrestore(&info->irq_lock, flags);\n\t\twhile (status) {\n\t\t\tu32 hwirq = ffs(status) - 1;\n\t\t\tu32 virq = irq_find_mapping(d, hwirq +\n\t\t\t\t\t\t     i * GPIO_PER_REG);\n\t\t\tu32 t = irq_get_trigger_type(virq);\n\n\t\t\tif ((t & IRQ_TYPE_SENSE_MASK) == IRQ_TYPE_EDGE_BOTH) {\n\t\t\t\t \n\t\t\t\tif (armada_37xx_edge_both_irq_swap_pol(info,\n\t\t\t\t\thwirq + i * GPIO_PER_REG)) {\n\t\t\t\t\t \n\t\t\t\t\twritel(1 << hwirq,\n\t\t\t\t\t       info->base +\n\t\t\t\t\t       IRQ_STATUS + 4 * i);\n\t\t\t\t\tgoto update_status;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tgeneric_handle_irq(virq);\n\nupdate_status:\n\t\t\t \n\t\t\traw_spin_lock_irqsave(&info->irq_lock, flags);\n\t\t\tstatus = readl_relaxed(info->base +\n\t\t\t\t\t       IRQ_STATUS + 4 * i);\n\t\t\t \n\t\t\tstatus &= readl_relaxed(info->base + IRQ_EN + 4 * i);\n\t\t\traw_spin_unlock_irqrestore(&info->irq_lock, flags);\n\t\t}\n\t}\n\tchained_irq_exit(chip, desc);\n}\n\nstatic unsigned int armada_37xx_irq_startup(struct irq_data *d)\n{\n\t \n\td->mask = BIT(d->hwirq % GPIO_PER_REG);\n\n\tarmada_37xx_irq_unmask(d);\n\n\treturn 0;\n}\n\nstatic void armada_37xx_irq_print_chip(struct irq_data *d, struct seq_file *p)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(d);\n\tstruct armada_37xx_pinctrl *info = gpiochip_get_data(chip);\n\n\tseq_printf(p, info->data->name);\n}\n\nstatic const struct irq_chip armada_37xx_irqchip = {\n\t.irq_ack = armada_37xx_irq_ack,\n\t.irq_mask = armada_37xx_irq_mask,\n\t.irq_unmask = armada_37xx_irq_unmask,\n\t.irq_set_wake = armada_37xx_irq_set_wake,\n\t.irq_set_type = armada_37xx_irq_set_type,\n\t.irq_startup = armada_37xx_irq_startup,\n\t.irq_print_chip = armada_37xx_irq_print_chip,\n\t.flags = IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic int armada_37xx_irqchip_register(struct platform_device *pdev,\n\t\t\t\t\tstruct armada_37xx_pinctrl *info)\n{\n\tstruct gpio_chip *gc = &info->gpio_chip;\n\tstruct gpio_irq_chip *girq = &gc->irq;\n\tstruct device_node *np = to_of_node(gc->fwnode);\n\tstruct device *dev = &pdev->dev;\n\tunsigned int i, nr_irq_parent;\n\n\traw_spin_lock_init(&info->irq_lock);\n\n\tnr_irq_parent = of_irq_count(np);\n\tif (!nr_irq_parent) {\n\t\tdev_err(dev, \"invalid or no IRQ\\n\");\n\t\treturn 0;\n\t}\n\n\tinfo->base = devm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(info->base))\n\t\treturn PTR_ERR(info->base);\n\n\tgpio_irq_chip_set_chip(girq, &armada_37xx_irqchip);\n\tgirq->parent_handler = armada_37xx_irq_handler;\n\t \n\tgirq->num_parents = nr_irq_parent;\n\tgirq->parents = devm_kcalloc(dev, nr_irq_parent, sizeof(*girq->parents), GFP_KERNEL);\n\tif (!girq->parents)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < nr_irq_parent; i++) {\n\t\tint irq = irq_of_parse_and_map(np, i);\n\n\t\tif (!irq)\n\t\t\tcontinue;\n\t\tgirq->parents[i] = irq;\n\t}\n\tgirq->default_type = IRQ_TYPE_NONE;\n\tgirq->handler = handle_edge_irq;\n\n\treturn 0;\n}\n\nstatic int armada_37xx_gpiochip_register(struct platform_device *pdev,\n\t\t\t\t\tstruct armada_37xx_pinctrl *info)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct fwnode_handle *fwnode;\n\tstruct gpio_chip *gc;\n\tint ret;\n\n\tfwnode = gpiochip_node_get_first(dev);\n\tif (!fwnode)\n\t\treturn -ENODEV;\n\n\tinfo->gpio_chip = armada_37xx_gpiolib_chip;\n\n\tgc = &info->gpio_chip;\n\tgc->ngpio = info->data->nr_pins;\n\tgc->parent = dev;\n\tgc->base = -1;\n\tgc->fwnode = fwnode;\n\tgc->label = info->data->name;\n\n\tret = armada_37xx_irqchip_register(pdev, info);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_gpiochip_add_data(dev, gc, info);\n}\n\n \nstatic int armada_37xx_add_function(struct armada_37xx_pmx_func *funcs,\n\t\t\t\t    int *funcsize, const char *name)\n{\n\tint i = 0;\n\n\tif (*funcsize <= 0)\n\t\treturn -EOVERFLOW;\n\n\twhile (funcs->ngroups) {\n\t\t \n\t\tif (strcmp(funcs->name, name) == 0) {\n\t\t\tfuncs->ngroups++;\n\n\t\t\treturn -EEXIST;\n\t\t}\n\t\tfuncs++;\n\t\ti++;\n\t}\n\n\t \n\tfuncs->name = name;\n\tfuncs->ngroups = 1;\n\t(*funcsize)--;\n\n\treturn 0;\n}\n\n \nstatic int armada_37xx_fill_group(struct armada_37xx_pinctrl *info)\n{\n\tint n, num = 0, funcsize = info->data->nr_pins;\n\tstruct device *dev = info->dev;\n\n\tfor (n = 0; n < info->ngroups; n++) {\n\t\tstruct armada_37xx_pin_group *grp = &info->groups[n];\n\t\tint i, j, f;\n\n\t\tgrp->pins = devm_kcalloc(dev, grp->npins + grp->extra_npins,\n\t\t\t\t\t sizeof(*grp->pins),\n\t\t\t\t\t GFP_KERNEL);\n\t\tif (!grp->pins)\n\t\t\treturn -ENOMEM;\n\n\t\tfor (i = 0; i < grp->npins; i++)\n\t\t\tgrp->pins[i] = grp->start_pin + i;\n\n\t\tfor (j = 0; j < grp->extra_npins; j++)\n\t\t\tgrp->pins[i+j] = grp->extra_pin + j;\n\n\t\tfor (f = 0; (f < NB_FUNCS) && grp->funcs[f]; f++) {\n\t\t\tint ret;\n\t\t\t \n\t\t\tret = armada_37xx_add_function(info->funcs, &funcsize,\n\t\t\t\t\t    grp->funcs[f]);\n\t\t\tif (ret == -EOVERFLOW)\n\t\t\t\tdev_err(dev, \"More functions than pins(%d)\\n\",\n\t\t\t\t\tinfo->data->nr_pins);\n\t\t\tif (ret < 0)\n\t\t\t\tcontinue;\n\t\t\tnum++;\n\t\t}\n\t}\n\n\tinfo->nfuncs = num;\n\n\treturn 0;\n}\n\n \nstatic int armada_37xx_fill_func(struct armada_37xx_pinctrl *info)\n{\n\tstruct armada_37xx_pmx_func *funcs = info->funcs;\n\tstruct device *dev = info->dev;\n\tint n;\n\n\tfor (n = 0; n < info->nfuncs; n++) {\n\t\tconst char *name = funcs[n].name;\n\t\tconst char **groups;\n\t\tint g;\n\n\t\tfuncs[n].groups = devm_kcalloc(dev, funcs[n].ngroups,\n\t\t\t\t\t       sizeof(*(funcs[n].groups)),\n\t\t\t\t\t       GFP_KERNEL);\n\t\tif (!funcs[n].groups)\n\t\t\treturn -ENOMEM;\n\n\t\tgroups = funcs[n].groups;\n\n\t\tfor (g = 0; g < info->ngroups; g++) {\n\t\t\tstruct armada_37xx_pin_group *gp = &info->groups[g];\n\t\t\tint f;\n\n\t\t\tf = match_string(gp->funcs, NB_FUNCS, name);\n\t\t\tif (f < 0)\n\t\t\t\tcontinue;\n\n\t\t\t*groups = gp->name;\n\t\t\tgroups++;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int armada_37xx_pinctrl_register(struct platform_device *pdev,\n\t\t\t\t\tstruct armada_37xx_pinctrl *info)\n{\n\tconst struct armada_37xx_pin_data *pin_data = info->data;\n\tstruct pinctrl_desc *ctrldesc = &info->pctl;\n\tstruct pinctrl_pin_desc *pindesc, *pdesc;\n\tstruct device *dev = &pdev->dev;\n\tchar **pin_names;\n\tint pin, ret;\n\n\tinfo->groups = pin_data->groups;\n\tinfo->ngroups = pin_data->ngroups;\n\n\tctrldesc->name = \"armada_37xx-pinctrl\";\n\tctrldesc->owner = THIS_MODULE;\n\tctrldesc->pctlops = &armada_37xx_pctrl_ops;\n\tctrldesc->pmxops = &armada_37xx_pmx_ops;\n\tctrldesc->confops = &armada_37xx_pinconf_ops;\n\n\tpindesc = devm_kcalloc(dev, pin_data->nr_pins, sizeof(*pindesc), GFP_KERNEL);\n\tif (!pindesc)\n\t\treturn -ENOMEM;\n\n\tctrldesc->pins = pindesc;\n\tctrldesc->npins = pin_data->nr_pins;\n\n\tpin_names = devm_kasprintf_strarray(dev, pin_data->name, pin_data->nr_pins);\n\tif (IS_ERR(pin_names))\n\t\treturn PTR_ERR(pin_names);\n\n\tpdesc = pindesc;\n\tfor (pin = 0; pin < pin_data->nr_pins; pin++) {\n\t\tpdesc->number = pin;\n\t\tpdesc->name = pin_names[pin];\n\t\tpdesc++;\n\t}\n\n\t \n\tinfo->funcs = devm_kcalloc(dev, pin_data->nr_pins, sizeof(*info->funcs), GFP_KERNEL);\n\tif (!info->funcs)\n\t\treturn -ENOMEM;\n\n\tret = armada_37xx_fill_group(info);\n\tif (ret)\n\t\treturn ret;\n\n\tret = armada_37xx_fill_func(info);\n\tif (ret)\n\t\treturn ret;\n\n\tinfo->pctl_dev = devm_pinctrl_register(dev, ctrldesc, info);\n\tif (IS_ERR(info->pctl_dev))\n\t\treturn dev_err_probe(dev, PTR_ERR(info->pctl_dev), \"could not register pinctrl driver\\n\");\n\n\treturn 0;\n}\n\nstatic int armada_3700_pinctrl_suspend(struct device *dev)\n{\n\tstruct armada_37xx_pinctrl *info = dev_get_drvdata(dev);\n\n\t \n\tregmap_read(info->regmap, OUTPUT_EN, &info->pm.out_en_l);\n\tregmap_read(info->regmap, OUTPUT_EN + sizeof(u32), &info->pm.out_en_h);\n\tregmap_read(info->regmap, OUTPUT_VAL, &info->pm.out_val_l);\n\tregmap_read(info->regmap, OUTPUT_VAL + sizeof(u32),\n\t\t    &info->pm.out_val_h);\n\n\tinfo->pm.irq_en_l = readl(info->base + IRQ_EN);\n\tinfo->pm.irq_en_h = readl(info->base + IRQ_EN + sizeof(u32));\n\tinfo->pm.irq_pol_l = readl(info->base + IRQ_POL);\n\tinfo->pm.irq_pol_h = readl(info->base + IRQ_POL + sizeof(u32));\n\n\t \n\tregmap_read(info->regmap, SELECTION, &info->pm.selection);\n\n\treturn 0;\n}\n\nstatic int armada_3700_pinctrl_resume(struct device *dev)\n{\n\tstruct armada_37xx_pinctrl *info = dev_get_drvdata(dev);\n\tstruct gpio_chip *gc;\n\tstruct irq_domain *d;\n\tint i;\n\n\t \n\tregmap_write(info->regmap, OUTPUT_EN, info->pm.out_en_l);\n\tregmap_write(info->regmap, OUTPUT_EN + sizeof(u32),\n\t\t     info->pm.out_en_h);\n\tregmap_write(info->regmap, OUTPUT_VAL, info->pm.out_val_l);\n\tregmap_write(info->regmap, OUTPUT_VAL + sizeof(u32),\n\t\t     info->pm.out_val_h);\n\n\t \n\tgc = &info->gpio_chip;\n\td = gc->irq.domain;\n\tfor (i = 0; i < gc->ngpio; i++) {\n\t\tu32 irq_bit = BIT(i % GPIO_PER_REG);\n\t\tu32 mask, *irq_pol, input_reg, virq, type, level;\n\n\t\tif (i < GPIO_PER_REG) {\n\t\t\tmask = info->pm.irq_en_l;\n\t\t\tirq_pol = &info->pm.irq_pol_l;\n\t\t\tinput_reg = INPUT_VAL;\n\t\t} else {\n\t\t\tmask = info->pm.irq_en_h;\n\t\t\tirq_pol = &info->pm.irq_pol_h;\n\t\t\tinput_reg = INPUT_VAL + sizeof(u32);\n\t\t}\n\n\t\tif (!(mask & irq_bit))\n\t\t\tcontinue;\n\n\t\tvirq = irq_find_mapping(d, i);\n\t\ttype = irq_get_trigger_type(virq);\n\n\t\t \n\t\tif ((type & IRQ_TYPE_SENSE_MASK) ==\n\t\t    IRQ_TYPE_EDGE_BOTH) {\n\t\t\tregmap_read(info->regmap, input_reg, &level);\n\t\t\tif ((*irq_pol ^ level) & irq_bit)\n\t\t\t\t*irq_pol ^= irq_bit;\n\t\t}\n\t}\n\n\twritel(info->pm.irq_en_l, info->base + IRQ_EN);\n\twritel(info->pm.irq_en_h, info->base + IRQ_EN + sizeof(u32));\n\twritel(info->pm.irq_pol_l, info->base + IRQ_POL);\n\twritel(info->pm.irq_pol_h, info->base + IRQ_POL + sizeof(u32));\n\n\t \n\tregmap_write(info->regmap, SELECTION, info->pm.selection);\n\n\treturn 0;\n}\n\n \nstatic DEFINE_NOIRQ_DEV_PM_OPS(armada_3700_pinctrl_pm_ops,\n\t\t\t       armada_3700_pinctrl_suspend, armada_3700_pinctrl_resume);\n\nstatic const struct of_device_id armada_37xx_pinctrl_of_match[] = {\n\t{\n\t\t.compatible = \"marvell,armada3710-sb-pinctrl\",\n\t\t.data = &armada_37xx_pin_sb,\n\t},\n\t{\n\t\t.compatible = \"marvell,armada3710-nb-pinctrl\",\n\t\t.data = &armada_37xx_pin_nb,\n\t},\n\t{ },\n};\n\nstatic const struct regmap_config armada_37xx_pinctrl_regmap_config = {\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n\t.use_raw_spinlock = true,\n};\n\nstatic int __init armada_37xx_pinctrl_probe(struct platform_device *pdev)\n{\n\tstruct armada_37xx_pinctrl *info;\n\tstruct device *dev = &pdev->dev;\n\tstruct regmap *regmap;\n\tvoid __iomem *base;\n\tint ret;\n\n\tbase = devm_platform_get_and_ioremap_resource(pdev, 0, NULL);\n\tif (IS_ERR(base)) {\n\t\tdev_err(dev, \"failed to ioremap base address: %pe\\n\", base);\n\t\treturn PTR_ERR(base);\n\t}\n\n\tregmap = devm_regmap_init_mmio(dev, base,\n\t\t\t\t       &armada_37xx_pinctrl_regmap_config);\n\tif (IS_ERR(regmap)) {\n\t\tdev_err(dev, \"failed to create regmap: %pe\\n\", regmap);\n\t\treturn PTR_ERR(regmap);\n\t}\n\n\tinfo = devm_kzalloc(dev, sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinfo->dev = dev;\n\tinfo->regmap = regmap;\n\tinfo->data = of_device_get_match_data(dev);\n\n\tret = armada_37xx_pinctrl_register(pdev, info);\n\tif (ret)\n\t\treturn ret;\n\n\tret = armada_37xx_gpiochip_register(pdev, info);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, info);\n\n\treturn 0;\n}\n\nstatic struct platform_driver armada_37xx_pinctrl_driver = {\n\t.driver = {\n\t\t.name = \"armada-37xx-pinctrl\",\n\t\t.of_match_table = armada_37xx_pinctrl_of_match,\n\t\t.pm = pm_sleep_ptr(&armada_3700_pinctrl_pm_ops),\n\t},\n};\n\nbuiltin_platform_driver_probe(armada_37xx_pinctrl_driver,\n\t\t\t      armada_37xx_pinctrl_probe);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}