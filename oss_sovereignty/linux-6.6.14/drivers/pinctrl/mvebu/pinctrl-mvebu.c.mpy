{
  "module_name": "pinctrl-mvebu.c",
  "hash_id": "ada92fe1d0b2c6a500f4a368ccd60b7d22d786e8cd88039172c57d23b714399e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/mvebu/pinctrl-mvebu.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/gpio/driver.h>\n#include <linux/io.h>\n#include <linux/mfd/syscon.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n\n#include <linux/pinctrl/machine.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinmux.h>\n\n#include \"pinctrl-mvebu.h\"\n\n#define MPPS_PER_REG\t8\n#define MPP_BITS\t4\n#define MPP_MASK\t0xf\n\nstruct mvebu_pinctrl_function {\n\tconst char *name;\n\tconst char **groups;\n\tunsigned num_groups;\n};\n\nstruct mvebu_pinctrl_group {\n\tconst char *name;\n\tconst struct mvebu_mpp_ctrl *ctrl;\n\tstruct mvebu_mpp_ctrl_data *data;\n\tstruct mvebu_mpp_ctrl_setting *settings;\n\tunsigned num_settings;\n\tunsigned gid;\n\tunsigned *pins;\n\tunsigned npins;\n};\n\nstruct mvebu_pinctrl {\n\tstruct device *dev;\n\tstruct pinctrl_dev *pctldev;\n\tstruct pinctrl_desc desc;\n\tstruct mvebu_pinctrl_group *groups;\n\tunsigned num_groups;\n\tstruct mvebu_pinctrl_function *functions;\n\tunsigned num_functions;\n\tu8 variant;\n};\n\nint mvebu_mmio_mpp_ctrl_get(struct mvebu_mpp_ctrl_data *data,\n\t\t\t     unsigned int pid, unsigned long *config)\n{\n\tunsigned off = (pid / MVEBU_MPPS_PER_REG) * MVEBU_MPP_BITS;\n\tunsigned shift = (pid % MVEBU_MPPS_PER_REG) * MVEBU_MPP_BITS;\n\n\t*config = (readl(data->base + off) >> shift) & MVEBU_MPP_MASK;\n\n\treturn 0;\n}\n\nint mvebu_mmio_mpp_ctrl_set(struct mvebu_mpp_ctrl_data *data,\n\t\t\t     unsigned int pid, unsigned long config)\n{\n\tunsigned off = (pid / MVEBU_MPPS_PER_REG) * MVEBU_MPP_BITS;\n\tunsigned shift = (pid % MVEBU_MPPS_PER_REG) * MVEBU_MPP_BITS;\n\tunsigned long reg;\n\n\treg = readl(data->base + off) & ~(MVEBU_MPP_MASK << shift);\n\twritel(reg | (config << shift), data->base + off);\n\n\treturn 0;\n}\n\nstatic struct mvebu_pinctrl_group *mvebu_pinctrl_find_group_by_pid(\n\tstruct mvebu_pinctrl *pctl, unsigned pid)\n{\n\tunsigned n;\n\tfor (n = 0; n < pctl->num_groups; n++) {\n\t\tif (pid >= pctl->groups[n].pins[0] &&\n\t\t    pid < pctl->groups[n].pins[0] +\n\t\t\tpctl->groups[n].npins)\n\t\t\treturn &pctl->groups[n];\n\t}\n\treturn NULL;\n}\n\nstatic struct mvebu_pinctrl_group *mvebu_pinctrl_find_group_by_name(\n\tstruct mvebu_pinctrl *pctl, const char *name)\n{\n\tunsigned n;\n\n\tfor (n = 0; n < pctl->num_groups; n++) {\n\t\tif (strcmp(name, pctl->groups[n].name) == 0)\n\t\t\treturn &pctl->groups[n];\n\t}\n\n\treturn NULL;\n}\n\nstatic struct mvebu_mpp_ctrl_setting *mvebu_pinctrl_find_setting_by_val(\n\tstruct mvebu_pinctrl *pctl, struct mvebu_pinctrl_group *grp,\n\tunsigned long config)\n{\n\tunsigned n;\n\n\tfor (n = 0; n < grp->num_settings; n++) {\n\t\tif (config == grp->settings[n].val) {\n\t\t\tif (!pctl->variant || (pctl->variant &\n\t\t\t\t\t       grp->settings[n].variant))\n\t\t\t\treturn &grp->settings[n];\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic struct mvebu_mpp_ctrl_setting *mvebu_pinctrl_find_setting_by_name(\n\tstruct mvebu_pinctrl *pctl, struct mvebu_pinctrl_group *grp,\n\tconst char *name)\n{\n\tunsigned n;\n\n\tfor (n = 0; n < grp->num_settings; n++) {\n\t\tif (strcmp(name, grp->settings[n].name) == 0) {\n\t\t\tif (!pctl->variant || (pctl->variant &\n\t\t\t\t\t       grp->settings[n].variant))\n\t\t\t\treturn &grp->settings[n];\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic struct mvebu_mpp_ctrl_setting *mvebu_pinctrl_find_gpio_setting(\n\tstruct mvebu_pinctrl *pctl, struct mvebu_pinctrl_group *grp)\n{\n\tunsigned n;\n\n\tfor (n = 0; n < grp->num_settings; n++) {\n\t\tif (grp->settings[n].flags &\n\t\t\t(MVEBU_SETTING_GPO | MVEBU_SETTING_GPI)) {\n\t\t\tif (!pctl->variant || (pctl->variant &\n\t\t\t\t\t\tgrp->settings[n].variant))\n\t\t\t\treturn &grp->settings[n];\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic struct mvebu_pinctrl_function *mvebu_pinctrl_find_function_by_name(\n\tstruct mvebu_pinctrl *pctl, const char *name)\n{\n\tunsigned n;\n\n\tfor (n = 0; n < pctl->num_functions; n++) {\n\t\tif (strcmp(name, pctl->functions[n].name) == 0)\n\t\t\treturn &pctl->functions[n];\n\t}\n\n\treturn NULL;\n}\n\nstatic int mvebu_pinconf_group_get(struct pinctrl_dev *pctldev,\n\t\t\t\tunsigned gid, unsigned long *config)\n{\n\tstruct mvebu_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct mvebu_pinctrl_group *grp = &pctl->groups[gid];\n\n\tif (!grp->ctrl)\n\t\treturn -EINVAL;\n\n\treturn grp->ctrl->mpp_get(grp->data, grp->pins[0], config);\n}\n\nstatic int mvebu_pinconf_group_set(struct pinctrl_dev *pctldev,\n\t\t\t\tunsigned gid, unsigned long *configs,\n\t\t\t\tunsigned num_configs)\n{\n\tstruct mvebu_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct mvebu_pinctrl_group *grp = &pctl->groups[gid];\n\tint i, ret;\n\n\tif (!grp->ctrl)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < num_configs; i++) {\n\t\tret = grp->ctrl->mpp_set(grp->data, grp->pins[0], configs[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}  \n\n\treturn 0;\n}\n\nstatic void mvebu_pinconf_group_dbg_show(struct pinctrl_dev *pctldev,\n\t\t\t\t\tstruct seq_file *s, unsigned gid)\n{\n\tstruct mvebu_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct mvebu_pinctrl_group *grp = &pctl->groups[gid];\n\tstruct mvebu_mpp_ctrl_setting *curr;\n\tunsigned long config;\n\tunsigned n;\n\n\tif (mvebu_pinconf_group_get(pctldev, gid, &config))\n\t\treturn;\n\n\tcurr = mvebu_pinctrl_find_setting_by_val(pctl, grp, config);\n\n\tif (curr) {\n\t\tseq_printf(s, \"current: %s\", curr->name);\n\t\tif (curr->subname)\n\t\t\tseq_printf(s, \"(%s)\", curr->subname);\n\t\tif (curr->flags & (MVEBU_SETTING_GPO | MVEBU_SETTING_GPI)) {\n\t\t\tseq_putc(s, '(');\n\t\t\tif (curr->flags & MVEBU_SETTING_GPI)\n\t\t\t\tseq_putc(s, 'i');\n\t\t\tif (curr->flags & MVEBU_SETTING_GPO)\n\t\t\t\tseq_putc(s, 'o');\n\t\t\tseq_putc(s, ')');\n\t\t}\n\t} else {\n\t\tseq_puts(s, \"current: UNKNOWN\");\n\t}\n\n\tif (grp->num_settings > 1) {\n\t\tseq_puts(s, \", available = [\");\n\t\tfor (n = 0; n < grp->num_settings; n++) {\n\t\t\tif (curr == &grp->settings[n])\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (pctl->variant &&\n\t\t\t    !(pctl->variant & grp->settings[n].variant))\n\t\t\t\tcontinue;\n\n\t\t\tseq_printf(s, \" %s\", grp->settings[n].name);\n\t\t\tif (grp->settings[n].subname)\n\t\t\t\tseq_printf(s, \"(%s)\", grp->settings[n].subname);\n\t\t\tif (grp->settings[n].flags &\n\t\t\t\t(MVEBU_SETTING_GPO | MVEBU_SETTING_GPI)) {\n\t\t\t\tseq_putc(s, '(');\n\t\t\t\tif (grp->settings[n].flags & MVEBU_SETTING_GPI)\n\t\t\t\t\tseq_putc(s, 'i');\n\t\t\t\tif (grp->settings[n].flags & MVEBU_SETTING_GPO)\n\t\t\t\t\tseq_putc(s, 'o');\n\t\t\t\tseq_putc(s, ')');\n\t\t\t}\n\t\t}\n\t\tseq_puts(s, \" ]\");\n\t}\n}\n\nstatic const struct pinconf_ops mvebu_pinconf_ops = {\n\t.pin_config_group_get = mvebu_pinconf_group_get,\n\t.pin_config_group_set = mvebu_pinconf_group_set,\n\t.pin_config_group_dbg_show = mvebu_pinconf_group_dbg_show,\n};\n\nstatic int mvebu_pinmux_get_funcs_count(struct pinctrl_dev *pctldev)\n{\n\tstruct mvebu_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pctl->num_functions;\n}\n\nstatic const char *mvebu_pinmux_get_func_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\tunsigned fid)\n{\n\tstruct mvebu_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pctl->functions[fid].name;\n}\n\nstatic int mvebu_pinmux_get_groups(struct pinctrl_dev *pctldev, unsigned fid,\n\t\t\t\tconst char * const **groups,\n\t\t\t\tunsigned * const num_groups)\n{\n\tstruct mvebu_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\n\t*groups = pctl->functions[fid].groups;\n\t*num_groups = pctl->functions[fid].num_groups;\n\treturn 0;\n}\n\nstatic int mvebu_pinmux_set(struct pinctrl_dev *pctldev, unsigned fid,\n\t\t\t    unsigned gid)\n{\n\tstruct mvebu_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct mvebu_pinctrl_function *func = &pctl->functions[fid];\n\tstruct mvebu_pinctrl_group *grp = &pctl->groups[gid];\n\tstruct mvebu_mpp_ctrl_setting *setting;\n\tint ret;\n\tunsigned long config;\n\n\tsetting = mvebu_pinctrl_find_setting_by_name(pctl, grp,\n\t\t\t\t\t\t     func->name);\n\tif (!setting) {\n\t\tdev_err(pctl->dev,\n\t\t\t\"unable to find setting %s in group %s\\n\",\n\t\t\tfunc->name, func->groups[gid]);\n\t\treturn -EINVAL;\n\t}\n\n\tconfig = setting->val;\n\tret = mvebu_pinconf_group_set(pctldev, grp->gid, &config, 1);\n\tif (ret) {\n\t\tdev_err(pctl->dev, \"cannot set group %s to %s\\n\",\n\t\t\tfunc->groups[gid], func->name);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int mvebu_pinmux_gpio_request_enable(struct pinctrl_dev *pctldev,\n\t\t\tstruct pinctrl_gpio_range *range, unsigned offset)\n{\n\tstruct mvebu_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct mvebu_pinctrl_group *grp;\n\tstruct mvebu_mpp_ctrl_setting *setting;\n\tunsigned long config;\n\n\tgrp = mvebu_pinctrl_find_group_by_pid(pctl, offset);\n\tif (!grp)\n\t\treturn -EINVAL;\n\n\tif (grp->ctrl->mpp_gpio_req)\n\t\treturn grp->ctrl->mpp_gpio_req(grp->data, offset);\n\n\tsetting = mvebu_pinctrl_find_gpio_setting(pctl, grp);\n\tif (!setting)\n\t\treturn -ENOTSUPP;\n\n\tconfig = setting->val;\n\n\treturn mvebu_pinconf_group_set(pctldev, grp->gid, &config, 1);\n}\n\nstatic int mvebu_pinmux_gpio_set_direction(struct pinctrl_dev *pctldev,\n\t   struct pinctrl_gpio_range *range, unsigned offset, bool input)\n{\n\tstruct mvebu_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct mvebu_pinctrl_group *grp;\n\tstruct mvebu_mpp_ctrl_setting *setting;\n\n\tgrp = mvebu_pinctrl_find_group_by_pid(pctl, offset);\n\tif (!grp)\n\t\treturn -EINVAL;\n\n\tif (grp->ctrl->mpp_gpio_dir)\n\t\treturn grp->ctrl->mpp_gpio_dir(grp->data, offset, input);\n\n\tsetting = mvebu_pinctrl_find_gpio_setting(pctl, grp);\n\tif (!setting)\n\t\treturn -ENOTSUPP;\n\n\tif ((input && (setting->flags & MVEBU_SETTING_GPI)) ||\n\t    (!input && (setting->flags & MVEBU_SETTING_GPO)))\n\t\treturn 0;\n\n\treturn -ENOTSUPP;\n}\n\nstatic const struct pinmux_ops mvebu_pinmux_ops = {\n\t.get_functions_count = mvebu_pinmux_get_funcs_count,\n\t.get_function_name = mvebu_pinmux_get_func_name,\n\t.get_function_groups = mvebu_pinmux_get_groups,\n\t.gpio_request_enable = mvebu_pinmux_gpio_request_enable,\n\t.gpio_set_direction = mvebu_pinmux_gpio_set_direction,\n\t.set_mux = mvebu_pinmux_set,\n};\n\nstatic int mvebu_pinctrl_get_groups_count(struct pinctrl_dev *pctldev)\n{\n\tstruct mvebu_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\treturn pctl->num_groups;\n}\n\nstatic const char *mvebu_pinctrl_get_group_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t\tunsigned gid)\n{\n\tstruct mvebu_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\treturn pctl->groups[gid].name;\n}\n\nstatic int mvebu_pinctrl_get_group_pins(struct pinctrl_dev *pctldev,\n\t\t\t\t\tunsigned gid, const unsigned **pins,\n\t\t\t\t\tunsigned *num_pins)\n{\n\tstruct mvebu_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\t*pins = pctl->groups[gid].pins;\n\t*num_pins = pctl->groups[gid].npins;\n\treturn 0;\n}\n\nstatic int mvebu_pinctrl_dt_node_to_map(struct pinctrl_dev *pctldev,\n\t\t\t\t\tstruct device_node *np,\n\t\t\t\t\tstruct pinctrl_map **map,\n\t\t\t\t\tunsigned *num_maps)\n{\n\tstruct mvebu_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct property *prop;\n\tconst char *function;\n\tconst char *group;\n\tint ret, nmaps, n;\n\n\t*map = NULL;\n\t*num_maps = 0;\n\n\tret = of_property_read_string(np, \"marvell,function\", &function);\n\tif (ret) {\n\t\tdev_err(pctl->dev,\n\t\t\t\"missing marvell,function in node %pOFn\\n\", np);\n\t\treturn 0;\n\t}\n\n\tnmaps = of_property_count_strings(np, \"marvell,pins\");\n\tif (nmaps < 0) {\n\t\tdev_err(pctl->dev,\n\t\t\t\"missing marvell,pins in node %pOFn\\n\", np);\n\t\treturn 0;\n\t}\n\n\t*map = kmalloc_array(nmaps, sizeof(**map), GFP_KERNEL);\n\tif (!*map)\n\t\treturn -ENOMEM;\n\n\tn = 0;\n\tof_property_for_each_string(np, \"marvell,pins\", prop, group) {\n\t\tstruct mvebu_pinctrl_group *grp =\n\t\t\tmvebu_pinctrl_find_group_by_name(pctl, group);\n\n\t\tif (!grp) {\n\t\t\tdev_err(pctl->dev, \"unknown pin %s\", group);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!mvebu_pinctrl_find_setting_by_name(pctl, grp, function)) {\n\t\t\tdev_err(pctl->dev, \"unsupported function %s on pin %s\",\n\t\t\t\tfunction, group);\n\t\t\tcontinue;\n\t\t}\n\n\t\t(*map)[n].type = PIN_MAP_TYPE_MUX_GROUP;\n\t\t(*map)[n].data.mux.group = group;\n\t\t(*map)[n].data.mux.function = function;\n\t\tn++;\n\t}\n\n\t*num_maps = nmaps;\n\n\treturn 0;\n}\n\nstatic void mvebu_pinctrl_dt_free_map(struct pinctrl_dev *pctldev,\n\t\t\t\tstruct pinctrl_map *map, unsigned num_maps)\n{\n\tkfree(map);\n}\n\nstatic const struct pinctrl_ops mvebu_pinctrl_ops = {\n\t.get_groups_count = mvebu_pinctrl_get_groups_count,\n\t.get_group_name = mvebu_pinctrl_get_group_name,\n\t.get_group_pins = mvebu_pinctrl_get_group_pins,\n\t.dt_node_to_map = mvebu_pinctrl_dt_node_to_map,\n\t.dt_free_map = mvebu_pinctrl_dt_free_map,\n};\n\nstatic int _add_function(struct mvebu_pinctrl_function *funcs, int *funcsize,\n\t\t\tconst char *name)\n{\n\tif (*funcsize <= 0)\n\t\treturn -EOVERFLOW;\n\n\twhile (funcs->num_groups) {\n\t\t \n\t\tif (strcmp(funcs->name, name) == 0) {\n\t\t\tfuncs->num_groups++;\n\t\t\treturn -EEXIST;\n\t\t}\n\t\tfuncs++;\n\t}\n\n\t \n\tfuncs->name = name;\n\tfuncs->num_groups = 1;\n\t(*funcsize)--;\n\n\treturn 0;\n}\n\nstatic int mvebu_pinctrl_build_functions(struct platform_device *pdev,\n\t\t\t\t\t struct mvebu_pinctrl *pctl)\n{\n\tstruct mvebu_pinctrl_function *funcs;\n\tint num = 0, funcsize = pctl->desc.npins;\n\tint n, s;\n\n\t \n\tfuncs = devm_kcalloc(&pdev->dev,\n\t\t\t     funcsize, sizeof(struct mvebu_pinctrl_function),\n\t\t\t     GFP_KERNEL);\n\tif (!funcs)\n\t\treturn -ENOMEM;\n\n\tfor (n = 0; n < pctl->num_groups; n++) {\n\t\tstruct mvebu_pinctrl_group *grp = &pctl->groups[n];\n\t\tfor (s = 0; s < grp->num_settings; s++) {\n\t\t\tint ret;\n\n\t\t\t \n\t\t\tif (pctl->variant &&\n\t\t\t    !(pctl->variant & grp->settings[s].variant))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tret = _add_function(funcs, &funcsize,\n\t\t\t\t\t    grp->settings[s].name);\n\t\t\tif (ret == -EOVERFLOW)\n\t\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\t\"More functions than pins(%d)\\n\",\n\t\t\t\t\tpctl->desc.npins);\n\t\t\tif (ret < 0)\n\t\t\t\tcontinue;\n\n\t\t\tnum++;\n\t\t}\n\t}\n\n\tpctl->num_functions = num;\n\tpctl->functions = funcs;\n\n\tfor (n = 0; n < pctl->num_groups; n++) {\n\t\tstruct mvebu_pinctrl_group *grp = &pctl->groups[n];\n\t\tfor (s = 0; s < grp->num_settings; s++) {\n\t\t\tstruct mvebu_pinctrl_function *f;\n\t\t\tconst char **groups;\n\n\t\t\t \n\t\t\tif (pctl->variant &&\n\t\t\t    !(pctl->variant & grp->settings[s].variant))\n\t\t\t\tcontinue;\n\n\t\t\tf = mvebu_pinctrl_find_function_by_name(pctl,\n\t\t\t\t\t\t\tgrp->settings[s].name);\n\n\t\t\t \n\t\t\tif (!f->groups) {\n\t\t\t\tf->groups = devm_kcalloc(&pdev->dev,\n\t\t\t\t\t\t f->num_groups,\n\t\t\t\t\t\t sizeof(char *),\n\t\t\t\t\t\t GFP_KERNEL);\n\t\t\t\tif (!f->groups)\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\t \n\t\t\tgroups = f->groups;\n\t\t\twhile (*groups)\n\t\t\t\tgroups++;\n\t\t\t*groups = grp->name;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint mvebu_pinctrl_probe(struct platform_device *pdev)\n{\n\tstruct mvebu_pinctrl_soc_info *soc = dev_get_platdata(&pdev->dev);\n\tstruct mvebu_pinctrl *pctl;\n\tstruct pinctrl_pin_desc *pdesc;\n\tunsigned gid, n, k;\n\tunsigned size, noname = 0;\n\tchar *noname_buf;\n\tvoid *p;\n\tint ret;\n\n\tif (!soc || !soc->controls || !soc->modes) {\n\t\tdev_err(&pdev->dev, \"wrong pinctrl soc info\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpctl = devm_kzalloc(&pdev->dev, sizeof(struct mvebu_pinctrl),\n\t\t\tGFP_KERNEL);\n\tif (!pctl)\n\t\treturn -ENOMEM;\n\n\tpctl->desc.name = dev_name(&pdev->dev);\n\tpctl->desc.owner = THIS_MODULE;\n\tpctl->desc.pctlops = &mvebu_pinctrl_ops;\n\tpctl->desc.pmxops = &mvebu_pinmux_ops;\n\tpctl->desc.confops = &mvebu_pinconf_ops;\n\tpctl->variant = soc->variant;\n\tpctl->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, pctl);\n\n\t \n\tpctl->num_groups = 0;\n\tpctl->desc.npins = 0;\n\tfor (n = 0; n < soc->ncontrols; n++) {\n\t\tconst struct mvebu_mpp_ctrl *ctrl = &soc->controls[n];\n\n\t\tpctl->desc.npins += ctrl->npins;\n\t\t \n\t\tfor (k = 0; k < ctrl->npins; k++)\n\t\t\tctrl->pins[k] = ctrl->pid + k;\n\n\t\t \n\t\tif (!ctrl->name) {\n\t\t\tpctl->num_groups += ctrl->npins;\n\t\t\tnoname += ctrl->npins;\n\t\t} else {\n\t\t\tpctl->num_groups += 1;\n\t\t}\n\t}\n\n\tpdesc = devm_kcalloc(&pdev->dev,\n\t\t\t     pctl->desc.npins,\n\t\t\t     sizeof(struct pinctrl_pin_desc),\n\t\t\t     GFP_KERNEL);\n\tif (!pdesc)\n\t\treturn -ENOMEM;\n\n\tfor (n = 0; n < pctl->desc.npins; n++)\n\t\tpdesc[n].number = n;\n\tpctl->desc.pins = pdesc;\n\n\t \n\tsize = pctl->num_groups * sizeof(*pctl->groups) + noname * 8;\n\tp = devm_kzalloc(&pdev->dev, size, GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tpctl->groups = p;\n\tnoname_buf = p + pctl->num_groups * sizeof(*pctl->groups);\n\n\t \n\tgid = 0;\n\tfor (n = 0; n < soc->ncontrols; n++) {\n\t\tconst struct mvebu_mpp_ctrl *ctrl = &soc->controls[n];\n\t\tstruct mvebu_mpp_ctrl_data *data = soc->control_data ?\n\t\t\t\t\t\t   &soc->control_data[n] : NULL;\n\n\t\tpctl->groups[gid].gid = gid;\n\t\tpctl->groups[gid].ctrl = ctrl;\n\t\tpctl->groups[gid].data = data;\n\t\tpctl->groups[gid].name = ctrl->name;\n\t\tpctl->groups[gid].pins = ctrl->pins;\n\t\tpctl->groups[gid].npins = ctrl->npins;\n\n\t\t \n\t\tif (!ctrl->name) {\n\t\t\tpctl->groups[gid].name = noname_buf;\n\t\t\tpctl->groups[gid].npins = 1;\n\t\t\tsprintf(noname_buf, \"mpp%d\", ctrl->pid+0);\n\t\t\tnoname_buf += 8;\n\n\t\t\tfor (k = 1; k < ctrl->npins; k++) {\n\t\t\t\tgid++;\n\t\t\t\tpctl->groups[gid].gid = gid;\n\t\t\t\tpctl->groups[gid].ctrl = ctrl;\n\t\t\t\tpctl->groups[gid].data = data;\n\t\t\t\tpctl->groups[gid].name = noname_buf;\n\t\t\t\tpctl->groups[gid].pins = &ctrl->pins[k];\n\t\t\t\tpctl->groups[gid].npins = 1;\n\t\t\t\tsprintf(noname_buf, \"mpp%d\", ctrl->pid+k);\n\t\t\t\tnoname_buf += 8;\n\t\t\t}\n\t\t}\n\t\tgid++;\n\t}\n\n\t \n\tfor (n = 0; n < soc->nmodes; n++) {\n\t\tstruct mvebu_mpp_mode *mode = &soc->modes[n];\n\t\tstruct mvebu_mpp_ctrl_setting *set = &mode->settings[0];\n\t\tstruct mvebu_pinctrl_group *grp;\n\t\tunsigned num_settings;\n\t\tunsigned supp_settings;\n\n\t\tfor (num_settings = 0, supp_settings = 0; ; set++) {\n\t\t\tif (!set->name)\n\t\t\t\tbreak;\n\n\t\t\tnum_settings++;\n\n\t\t\t \n\t\t\tif (pctl->variant && !(pctl->variant & set->variant))\n\t\t\t\tcontinue;\n\n\t\t\tsupp_settings++;\n\n\t\t\t \n\t\t\tif (strcmp(set->name, \"gpio\") == 0)\n\t\t\t\tset->flags = MVEBU_SETTING_GPI |\n\t\t\t\t\tMVEBU_SETTING_GPO;\n\t\t\telse if (strcmp(set->name, \"gpo\") == 0)\n\t\t\t\tset->flags = MVEBU_SETTING_GPO;\n\t\t\telse if (strcmp(set->name, \"gpi\") == 0)\n\t\t\t\tset->flags = MVEBU_SETTING_GPI;\n\t\t}\n\n\t\t \n\t\tif (!supp_settings)\n\t\t\tcontinue;\n\n\t\tgrp = mvebu_pinctrl_find_group_by_pid(pctl, mode->pid);\n\t\tif (!grp) {\n\t\t\tdev_warn(&pdev->dev, \"unknown pinctrl group %d\\n\",\n\t\t\t\tmode->pid);\n\t\t\tcontinue;\n\t\t}\n\n\t\tgrp->settings = mode->settings;\n\t\tgrp->num_settings = num_settings;\n\t}\n\n\tret = mvebu_pinctrl_build_functions(pdev, pctl);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"unable to build functions\\n\");\n\t\treturn ret;\n\t}\n\n\tpctl->pctldev = devm_pinctrl_register(&pdev->dev, &pctl->desc, pctl);\n\tif (IS_ERR(pctl->pctldev)) {\n\t\tdev_err(&pdev->dev, \"unable to register pinctrl driver\\n\");\n\t\treturn PTR_ERR(pctl->pctldev);\n\t}\n\n\tdev_info(&pdev->dev, \"registered pinctrl driver\\n\");\n\n\t \n\tfor (n = 0; n < soc->ngpioranges; n++)\n\t\tpinctrl_add_gpio_range(pctl->pctldev, &soc->gpioranges[n]);\n\n\treturn 0;\n}\n\n \nint mvebu_pinctrl_simple_mmio_probe(struct platform_device *pdev)\n{\n\tstruct mvebu_pinctrl_soc_info *soc = dev_get_platdata(&pdev->dev);\n\tstruct mvebu_mpp_ctrl_data *mpp_data;\n\tvoid __iomem *base;\n\tint i;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tmpp_data = devm_kcalloc(&pdev->dev, soc->ncontrols, sizeof(*mpp_data),\n\t\t\t\tGFP_KERNEL);\n\tif (!mpp_data)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < soc->ncontrols; i++)\n\t\tmpp_data[i].base = base;\n\n\tsoc->control_data = mpp_data;\n\n\treturn mvebu_pinctrl_probe(pdev);\n}\n\nint mvebu_regmap_mpp_ctrl_get(struct mvebu_mpp_ctrl_data *data,\n\t\t\t      unsigned int pid, unsigned long *config)\n{\n\tunsigned off = (pid / MVEBU_MPPS_PER_REG) * MVEBU_MPP_BITS;\n\tunsigned shift = (pid % MVEBU_MPPS_PER_REG) * MVEBU_MPP_BITS;\n\tunsigned int val;\n\tint err;\n\n\terr = regmap_read(data->regmap.map, data->regmap.offset + off, &val);\n\tif (err)\n\t\treturn err;\n\n\t*config = (val >> shift) & MVEBU_MPP_MASK;\n\n\treturn 0;\n}\n\nint mvebu_regmap_mpp_ctrl_set(struct mvebu_mpp_ctrl_data *data,\n\t\t\t      unsigned int pid, unsigned long config)\n{\n\tunsigned off = (pid / MVEBU_MPPS_PER_REG) * MVEBU_MPP_BITS;\n\tunsigned shift = (pid % MVEBU_MPPS_PER_REG) * MVEBU_MPP_BITS;\n\n\treturn regmap_update_bits(data->regmap.map, data->regmap.offset + off,\n\t\t\t\t  MVEBU_MPP_MASK << shift, config << shift);\n}\n\nint mvebu_pinctrl_simple_regmap_probe(struct platform_device *pdev,\n\t\t\t\t      struct device *syscon_dev, u32 offset)\n{\n\tstruct mvebu_pinctrl_soc_info *soc = dev_get_platdata(&pdev->dev);\n\tstruct mvebu_mpp_ctrl_data *mpp_data;\n\tstruct regmap *regmap;\n\tint i;\n\n\tregmap = syscon_node_to_regmap(syscon_dev->of_node);\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\tmpp_data = devm_kcalloc(&pdev->dev, soc->ncontrols, sizeof(*mpp_data),\n\t\t\t\tGFP_KERNEL);\n\tif (!mpp_data)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < soc->ncontrols; i++) {\n\t\tmpp_data[i].regmap.map = regmap;\n\t\tmpp_data[i].regmap.offset = offset;\n\t}\n\n\tsoc->control_data = mpp_data;\n\n\treturn mvebu_pinctrl_probe(pdev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}