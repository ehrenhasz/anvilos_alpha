{
  "module_name": "pinctrl-sunxi.c",
  "hash_id": "56b039356b04f90c06d94d93c1be47b846cd8bb68197f6bcc654146afec44fd5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/sunxi/pinctrl-sunxi.c",
  "human_readable_source": " \n\n#include <linux/clk.h>\n#include <linux/export.h>\n#include <linux/gpio/driver.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/irqdomain.h>\n#include <linux/of.h>\n#include <linux/of_clk.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n\n#include <linux/pinctrl/consumer.h>\n#include <linux/pinctrl/machine.h>\n#include <linux/pinctrl/pinconf-generic.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinmux.h>\n\n#include <dt-bindings/pinctrl/sun4i-a10.h>\n\n#include \"../core.h\"\n#include \"pinctrl-sunxi.h\"\n\n \nstatic struct lock_class_key sunxi_pinctrl_irq_lock_class;\nstatic struct lock_class_key sunxi_pinctrl_irq_request_class;\n\nstatic struct irq_chip sunxi_pinctrl_edge_irq_chip;\nstatic struct irq_chip sunxi_pinctrl_level_irq_chip;\n\n \nstatic void sunxi_mux_reg(const struct sunxi_pinctrl *pctl,\n\t\t\t  u32 pin, u32 *reg, u32 *shift, u32 *mask)\n{\n\tu32 bank   = pin / PINS_PER_BANK;\n\tu32 offset = pin % PINS_PER_BANK * MUX_FIELD_WIDTH;\n\n\t*reg   = bank * pctl->bank_mem_size + MUX_REGS_OFFSET +\n\t\t offset / BITS_PER_TYPE(u32) * sizeof(u32);\n\t*shift = offset % BITS_PER_TYPE(u32);\n\t*mask  = (BIT(MUX_FIELD_WIDTH) - 1) << *shift;\n}\n\nstatic void sunxi_data_reg(const struct sunxi_pinctrl *pctl,\n\t\t\t   u32 pin, u32 *reg, u32 *shift, u32 *mask)\n{\n\tu32 bank   = pin / PINS_PER_BANK;\n\tu32 offset = pin % PINS_PER_BANK * DATA_FIELD_WIDTH;\n\n\t*reg   = bank * pctl->bank_mem_size + DATA_REGS_OFFSET +\n\t\t offset / BITS_PER_TYPE(u32) * sizeof(u32);\n\t*shift = offset % BITS_PER_TYPE(u32);\n\t*mask  = (BIT(DATA_FIELD_WIDTH) - 1) << *shift;\n}\n\nstatic void sunxi_dlevel_reg(const struct sunxi_pinctrl *pctl,\n\t\t\t     u32 pin, u32 *reg, u32 *shift, u32 *mask)\n{\n\tu32 bank   = pin / PINS_PER_BANK;\n\tu32 offset = pin % PINS_PER_BANK * pctl->dlevel_field_width;\n\n\t*reg   = bank * pctl->bank_mem_size + DLEVEL_REGS_OFFSET +\n\t\t offset / BITS_PER_TYPE(u32) * sizeof(u32);\n\t*shift = offset % BITS_PER_TYPE(u32);\n\t*mask  = (BIT(pctl->dlevel_field_width) - 1) << *shift;\n}\n\nstatic void sunxi_pull_reg(const struct sunxi_pinctrl *pctl,\n\t\t\t   u32 pin, u32 *reg, u32 *shift, u32 *mask)\n{\n\tu32 bank   = pin / PINS_PER_BANK;\n\tu32 offset = pin % PINS_PER_BANK * PULL_FIELD_WIDTH;\n\n\t*reg   = bank * pctl->bank_mem_size + pctl->pull_regs_offset +\n\t\t offset / BITS_PER_TYPE(u32) * sizeof(u32);\n\t*shift = offset % BITS_PER_TYPE(u32);\n\t*mask  = (BIT(PULL_FIELD_WIDTH) - 1) << *shift;\n}\n\nstatic struct sunxi_pinctrl_group *\nsunxi_pinctrl_find_group_by_name(struct sunxi_pinctrl *pctl, const char *group)\n{\n\tint i;\n\n\tfor (i = 0; i < pctl->ngroups; i++) {\n\t\tstruct sunxi_pinctrl_group *grp = pctl->groups + i;\n\n\t\tif (!strcmp(grp->name, group))\n\t\t\treturn grp;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct sunxi_pinctrl_function *\nsunxi_pinctrl_find_function_by_name(struct sunxi_pinctrl *pctl,\n\t\t\t\t    const char *name)\n{\n\tstruct sunxi_pinctrl_function *func = pctl->functions;\n\tint i;\n\n\tfor (i = 0; i < pctl->nfunctions; i++) {\n\t\tif (!func[i].name)\n\t\t\tbreak;\n\n\t\tif (!strcmp(func[i].name, name))\n\t\t\treturn func + i;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct sunxi_desc_function *\nsunxi_pinctrl_desc_find_function_by_name(struct sunxi_pinctrl *pctl,\n\t\t\t\t\t const char *pin_name,\n\t\t\t\t\t const char *func_name)\n{\n\tint i;\n\n\tfor (i = 0; i < pctl->desc->npins; i++) {\n\t\tconst struct sunxi_desc_pin *pin = pctl->desc->pins + i;\n\n\t\tif (!strcmp(pin->pin.name, pin_name)) {\n\t\t\tstruct sunxi_desc_function *func = pin->functions;\n\n\t\t\twhile (func->name) {\n\t\t\t\tif (!strcmp(func->name, func_name) &&\n\t\t\t\t\t(!func->variant ||\n\t\t\t\t\tfunc->variant & pctl->variant))\n\t\t\t\t\treturn func;\n\n\t\t\t\tfunc++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic struct sunxi_desc_function *\nsunxi_pinctrl_desc_find_function_by_pin(struct sunxi_pinctrl *pctl,\n\t\t\t\t\tconst u16 pin_num,\n\t\t\t\t\tconst char *func_name)\n{\n\tint i;\n\n\tfor (i = 0; i < pctl->desc->npins; i++) {\n\t\tconst struct sunxi_desc_pin *pin = pctl->desc->pins + i;\n\n\t\tif (pin->pin.number == pin_num) {\n\t\t\tstruct sunxi_desc_function *func = pin->functions;\n\n\t\t\twhile (func->name) {\n\t\t\t\tif (!strcmp(func->name, func_name))\n\t\t\t\t\treturn func;\n\n\t\t\t\tfunc++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic int sunxi_pctrl_get_groups_count(struct pinctrl_dev *pctldev)\n{\n\tstruct sunxi_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pctl->ngroups;\n}\n\nstatic const char *sunxi_pctrl_get_group_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t      unsigned group)\n{\n\tstruct sunxi_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pctl->groups[group].name;\n}\n\nstatic int sunxi_pctrl_get_group_pins(struct pinctrl_dev *pctldev,\n\t\t\t\t      unsigned group,\n\t\t\t\t      const unsigned **pins,\n\t\t\t\t      unsigned *num_pins)\n{\n\tstruct sunxi_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\n\t*pins = (unsigned *)&pctl->groups[group].pin;\n\t*num_pins = 1;\n\n\treturn 0;\n}\n\nstatic bool sunxi_pctrl_has_bias_prop(struct device_node *node)\n{\n\treturn of_property_present(node, \"bias-pull-up\") ||\n\t\tof_property_present(node, \"bias-pull-down\") ||\n\t\tof_property_present(node, \"bias-disable\") ||\n\t\tof_property_present(node, \"allwinner,pull\");\n}\n\nstatic bool sunxi_pctrl_has_drive_prop(struct device_node *node)\n{\n\treturn of_property_present(node, \"drive-strength\") ||\n\t\tof_property_present(node, \"allwinner,drive\");\n}\n\nstatic int sunxi_pctrl_parse_bias_prop(struct device_node *node)\n{\n\tu32 val;\n\n\t \n\tif (of_property_present(node, \"bias-pull-up\"))\n\t\treturn PIN_CONFIG_BIAS_PULL_UP;\n\n\tif (of_property_present(node, \"bias-pull-down\"))\n\t\treturn PIN_CONFIG_BIAS_PULL_DOWN;\n\n\tif (of_property_present(node, \"bias-disable\"))\n\t\treturn PIN_CONFIG_BIAS_DISABLE;\n\n\t \n\tif (of_property_read_u32(node, \"allwinner,pull\", &val))\n\t\treturn -EINVAL;\n\n\tswitch (val) {\n\tcase SUN4I_PINCTRL_NO_PULL:\n\t\treturn PIN_CONFIG_BIAS_DISABLE;\n\tcase SUN4I_PINCTRL_PULL_UP:\n\t\treturn PIN_CONFIG_BIAS_PULL_UP;\n\tcase SUN4I_PINCTRL_PULL_DOWN:\n\t\treturn PIN_CONFIG_BIAS_PULL_DOWN;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int sunxi_pctrl_parse_drive_prop(struct device_node *node)\n{\n\tu32 val;\n\n\t \n\tif (!of_property_read_u32(node, \"drive-strength\", &val)) {\n\t\t \n\t\tif (val < 10)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (val > 40)\n\t\t\tval = 40;\n\n\t\t \n\t\treturn rounddown(val, 10);\n\t}\n\n\t \n\tif (of_property_read_u32(node, \"allwinner,drive\", &val))\n\t\treturn -EINVAL;\n\n\treturn (val + 1) * 10;\n}\n\nstatic const char *sunxi_pctrl_parse_function_prop(struct device_node *node)\n{\n\tconst char *function;\n\tint ret;\n\n\t \n\tret = of_property_read_string(node, \"function\", &function);\n\tif (!ret)\n\t\treturn function;\n\n\t \n\tret = of_property_read_string(node, \"allwinner,function\", &function);\n\tif (!ret)\n\t\treturn function;\n\n\treturn NULL;\n}\n\nstatic const char *sunxi_pctrl_find_pins_prop(struct device_node *node,\n\t\t\t\t\t      int *npins)\n{\n\tint count;\n\n\t \n\tcount = of_property_count_strings(node, \"pins\");\n\tif (count > 0) {\n\t\t*npins = count;\n\t\treturn \"pins\";\n\t}\n\n\t \n\tcount = of_property_count_strings(node, \"allwinner,pins\");\n\tif (count > 0) {\n\t\t*npins = count;\n\t\treturn \"allwinner,pins\";\n\t}\n\n\treturn NULL;\n}\n\nstatic unsigned long *sunxi_pctrl_build_pin_config(struct device_node *node,\n\t\t\t\t\t\t   unsigned int *len)\n{\n\tunsigned long *pinconfig;\n\tunsigned int configlen = 0, idx = 0;\n\tint ret;\n\n\tif (sunxi_pctrl_has_drive_prop(node))\n\t\tconfiglen++;\n\tif (sunxi_pctrl_has_bias_prop(node))\n\t\tconfiglen++;\n\n\t \n\tif (!configlen)\n\t\treturn NULL;\n\n\tpinconfig = kcalloc(configlen, sizeof(*pinconfig), GFP_KERNEL);\n\tif (!pinconfig)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (sunxi_pctrl_has_drive_prop(node)) {\n\t\tint drive = sunxi_pctrl_parse_drive_prop(node);\n\t\tif (drive < 0) {\n\t\t\tret = drive;\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tpinconfig[idx++] = pinconf_to_config_packed(PIN_CONFIG_DRIVE_STRENGTH,\n\t\t\t\t\t\t\t  drive);\n\t}\n\n\tif (sunxi_pctrl_has_bias_prop(node)) {\n\t\tint pull = sunxi_pctrl_parse_bias_prop(node);\n\t\tint arg = 0;\n\t\tif (pull < 0) {\n\t\t\tret = pull;\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tif (pull != PIN_CONFIG_BIAS_DISABLE)\n\t\t\targ = 1;  \n\n\t\tpinconfig[idx++] = pinconf_to_config_packed(pull, arg);\n\t}\n\n\n\t*len = configlen;\n\treturn pinconfig;\n\nerr_free:\n\tkfree(pinconfig);\n\treturn ERR_PTR(ret);\n}\n\nstatic int sunxi_pctrl_dt_node_to_map(struct pinctrl_dev *pctldev,\n\t\t\t\t      struct device_node *node,\n\t\t\t\t      struct pinctrl_map **map,\n\t\t\t\t      unsigned *num_maps)\n{\n\tstruct sunxi_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tunsigned long *pinconfig;\n\tstruct property *prop;\n\tconst char *function, *pin_prop;\n\tconst char *group;\n\tint ret, npins, nmaps, configlen = 0, i = 0;\n\n\t*map = NULL;\n\t*num_maps = 0;\n\n\tfunction = sunxi_pctrl_parse_function_prop(node);\n\tif (!function) {\n\t\tdev_err(pctl->dev, \"missing function property in node %pOFn\\n\",\n\t\t\tnode);\n\t\treturn -EINVAL;\n\t}\n\n\tpin_prop = sunxi_pctrl_find_pins_prop(node, &npins);\n\tif (!pin_prop) {\n\t\tdev_err(pctl->dev, \"missing pins property in node %pOFn\\n\",\n\t\t\tnode);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tnmaps = npins * 2;\n\t*map = kmalloc_array(nmaps, sizeof(struct pinctrl_map), GFP_KERNEL);\n\tif (!*map)\n\t\treturn -ENOMEM;\n\n\tpinconfig = sunxi_pctrl_build_pin_config(node, &configlen);\n\tif (IS_ERR(pinconfig)) {\n\t\tret = PTR_ERR(pinconfig);\n\t\tgoto err_free_map;\n\t}\n\n\tof_property_for_each_string(node, pin_prop, prop, group) {\n\t\tstruct sunxi_pinctrl_group *grp =\n\t\t\tsunxi_pinctrl_find_group_by_name(pctl, group);\n\n\t\tif (!grp) {\n\t\t\tdev_err(pctl->dev, \"unknown pin %s\", group);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!sunxi_pinctrl_desc_find_function_by_name(pctl,\n\t\t\t\t\t\t\t      grp->name,\n\t\t\t\t\t\t\t      function)) {\n\t\t\tdev_err(pctl->dev, \"unsupported function %s on pin %s\",\n\t\t\t\tfunction, group);\n\t\t\tcontinue;\n\t\t}\n\n\t\t(*map)[i].type = PIN_MAP_TYPE_MUX_GROUP;\n\t\t(*map)[i].data.mux.group = group;\n\t\t(*map)[i].data.mux.function = function;\n\n\t\ti++;\n\n\t\tif (pinconfig) {\n\t\t\t(*map)[i].type = PIN_MAP_TYPE_CONFIGS_GROUP;\n\t\t\t(*map)[i].data.configs.group_or_pin = group;\n\t\t\t(*map)[i].data.configs.configs = pinconfig;\n\t\t\t(*map)[i].data.configs.num_configs = configlen;\n\t\t\ti++;\n\t\t}\n\t}\n\n\t*num_maps = i;\n\n\t \n\t*map = krealloc(*map, i * sizeof(struct pinctrl_map), GFP_KERNEL);\n\tif (!*map)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n\nerr_free_map:\n\tkfree(*map);\n\t*map = NULL;\n\treturn ret;\n}\n\nstatic void sunxi_pctrl_dt_free_map(struct pinctrl_dev *pctldev,\n\t\t\t\t    struct pinctrl_map *map,\n\t\t\t\t    unsigned num_maps)\n{\n\tint i;\n\n\t \n\tfor (i = 1; i < num_maps; i++) {\n\t\tif (map[i].type != PIN_MAP_TYPE_CONFIGS_GROUP)\n\t\t\tcontinue;\n\n\t\t \n\t\tkfree(map[i].data.configs.configs);\n\t\tbreak;\n\t}\n\n\tkfree(map);\n}\n\nstatic const struct pinctrl_ops sunxi_pctrl_ops = {\n\t.dt_node_to_map\t\t= sunxi_pctrl_dt_node_to_map,\n\t.dt_free_map\t\t= sunxi_pctrl_dt_free_map,\n\t.get_groups_count\t= sunxi_pctrl_get_groups_count,\n\t.get_group_name\t\t= sunxi_pctrl_get_group_name,\n\t.get_group_pins\t\t= sunxi_pctrl_get_group_pins,\n};\n\nstatic int sunxi_pconf_reg(const struct sunxi_pinctrl *pctl,\n\t\t\t   u32 pin, enum pin_config_param param,\n\t\t\t   u32 *reg, u32 *shift, u32 *mask)\n{\n\tswitch (param) {\n\tcase PIN_CONFIG_DRIVE_STRENGTH:\n\t\tsunxi_dlevel_reg(pctl, pin, reg, shift, mask);\n\t\tbreak;\n\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\tsunxi_pull_reg(pctl, pin, reg, shift, mask);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int sunxi_pconf_get(struct pinctrl_dev *pctldev, unsigned pin,\n\t\t\t   unsigned long *config)\n{\n\tstruct sunxi_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tenum pin_config_param param = pinconf_to_config_param(*config);\n\tu32 reg, shift, mask, val;\n\tu16 arg;\n\tint ret;\n\n\tpin -= pctl->desc->pin_base;\n\n\tret = sunxi_pconf_reg(pctl, pin, param, &reg, &shift, &mask);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tval = (readl(pctl->membase + reg) & mask) >> shift;\n\n\tswitch (pinconf_to_config_param(*config)) {\n\tcase PIN_CONFIG_DRIVE_STRENGTH:\n\t\targ = (val + 1) * 10;\n\t\tbreak;\n\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\tif (val != SUN4I_PINCTRL_PULL_UP)\n\t\t\treturn -EINVAL;\n\t\targ = 1;  \n\t\tbreak;\n\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\tif (val != SUN4I_PINCTRL_PULL_DOWN)\n\t\t\treturn -EINVAL;\n\t\targ = 1;  \n\t\tbreak;\n\n\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\tif (val != SUN4I_PINCTRL_NO_PULL)\n\t\t\treturn -EINVAL;\n\t\targ = 0;\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tWARN_ON(1);\n\t\treturn -ENOTSUPP;\n\t}\n\n\t*config = pinconf_to_config_packed(param, arg);\n\n\treturn 0;\n}\n\nstatic int sunxi_pconf_group_get(struct pinctrl_dev *pctldev,\n\t\t\t\t unsigned group,\n\t\t\t\t unsigned long *config)\n{\n\tstruct sunxi_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct sunxi_pinctrl_group *g = &pctl->groups[group];\n\n\t \n\treturn sunxi_pconf_get(pctldev, g->pin, config);\n}\n\nstatic int sunxi_pconf_set(struct pinctrl_dev *pctldev, unsigned pin,\n\t\t\t   unsigned long *configs, unsigned num_configs)\n{\n\tstruct sunxi_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tint i;\n\n\tpin -= pctl->desc->pin_base;\n\n\tfor (i = 0; i < num_configs; i++) {\n\t\tu32 arg, reg, shift, mask, val;\n\t\tenum pin_config_param param;\n\t\tunsigned long flags;\n\t\tint ret;\n\n\t\tparam = pinconf_to_config_param(configs[i]);\n\t\targ = pinconf_to_config_argument(configs[i]);\n\n\t\tret = sunxi_pconf_reg(pctl, pin, param, &reg, &shift, &mask);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tswitch (param) {\n\t\tcase PIN_CONFIG_DRIVE_STRENGTH:\n\t\t\tif (arg < 10 || arg > 40)\n\t\t\t\treturn -EINVAL;\n\t\t\t \n\t\t\tval = arg / 10 - 1;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\t\tval = 0;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\t\tif (arg == 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tval = 1;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\t\tif (arg == 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tval = 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tWARN_ON(1);\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\n\t\traw_spin_lock_irqsave(&pctl->lock, flags);\n\t\twritel((readl(pctl->membase + reg) & ~mask) | val << shift,\n\t\t       pctl->membase + reg);\n\t\traw_spin_unlock_irqrestore(&pctl->lock, flags);\n\t}  \n\n\treturn 0;\n}\n\nstatic int sunxi_pconf_group_set(struct pinctrl_dev *pctldev, unsigned group,\n\t\t\t\t unsigned long *configs, unsigned num_configs)\n{\n\tstruct sunxi_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct sunxi_pinctrl_group *g = &pctl->groups[group];\n\n\t \n\treturn sunxi_pconf_set(pctldev, g->pin, configs, num_configs);\n}\n\nstatic const struct pinconf_ops sunxi_pconf_ops = {\n\t.is_generic\t\t= true,\n\t.pin_config_get\t\t= sunxi_pconf_get,\n\t.pin_config_set\t\t= sunxi_pconf_set,\n\t.pin_config_group_get\t= sunxi_pconf_group_get,\n\t.pin_config_group_set\t= sunxi_pconf_group_set,\n};\n\nstatic int sunxi_pinctrl_set_io_bias_cfg(struct sunxi_pinctrl *pctl,\n\t\t\t\t\t unsigned pin,\n\t\t\t\t\t struct regulator *supply)\n{\n\tunsigned short bank;\n\tunsigned long flags;\n\tu32 val, reg;\n\tint uV;\n\n\tif (!pctl->desc->io_bias_cfg_variant)\n\t\treturn 0;\n\n\tuV = regulator_get_voltage(supply);\n\tif (uV < 0)\n\t\treturn uV;\n\n\t \n\tif (uV == 0)\n\t\treturn 0;\n\n\tpin -= pctl->desc->pin_base;\n\tbank = pin / PINS_PER_BANK;\n\n\tswitch (pctl->desc->io_bias_cfg_variant) {\n\tcase BIAS_VOLTAGE_GRP_CONFIG:\n\t\t \n\t\tif (uV <= 1800000)\n\t\t\tval = 0x0;  \n\t\telse if (uV <= 2500000)\n\t\t\tval = 0x6;  \n\t\telse if (uV <= 2800000)\n\t\t\tval = 0x9;  \n\t\telse if (uV <= 3000000)\n\t\t\tval = 0xA;  \n\t\telse\n\t\t\tval = 0xD;  \n\n\t\treg = readl(pctl->membase + sunxi_grp_config_reg(pin));\n\t\treg &= ~IO_BIAS_MASK;\n\t\twritel(reg | val, pctl->membase + sunxi_grp_config_reg(pin));\n\t\treturn 0;\n\tcase BIAS_VOLTAGE_PIO_POW_MODE_CTL:\n\t\tval = uV > 1800000 && uV <= 2500000 ? BIT(bank) : 0;\n\n\t\traw_spin_lock_irqsave(&pctl->lock, flags);\n\t\treg = readl(pctl->membase + PIO_POW_MOD_CTL_REG);\n\t\treg &= ~BIT(bank);\n\t\twritel(reg | val, pctl->membase + PIO_POW_MOD_CTL_REG);\n\t\traw_spin_unlock_irqrestore(&pctl->lock, flags);\n\n\t\tfallthrough;\n\tcase BIAS_VOLTAGE_PIO_POW_MODE_SEL:\n\t\tval = uV <= 1800000 ? 1 : 0;\n\n\t\traw_spin_lock_irqsave(&pctl->lock, flags);\n\t\treg = readl(pctl->membase + PIO_POW_MOD_SEL_REG);\n\t\treg &= ~(1 << bank);\n\t\twritel(reg | val << bank, pctl->membase + PIO_POW_MOD_SEL_REG);\n\t\traw_spin_unlock_irqrestore(&pctl->lock, flags);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int sunxi_pmx_get_funcs_cnt(struct pinctrl_dev *pctldev)\n{\n\tstruct sunxi_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pctl->nfunctions;\n}\n\nstatic const char *sunxi_pmx_get_func_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t   unsigned function)\n{\n\tstruct sunxi_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pctl->functions[function].name;\n}\n\nstatic int sunxi_pmx_get_func_groups(struct pinctrl_dev *pctldev,\n\t\t\t\t     unsigned function,\n\t\t\t\t     const char * const **groups,\n\t\t\t\t     unsigned * const num_groups)\n{\n\tstruct sunxi_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\n\t*groups = pctl->functions[function].groups;\n\t*num_groups = pctl->functions[function].ngroups;\n\n\treturn 0;\n}\n\nstatic void sunxi_pmx_set(struct pinctrl_dev *pctldev,\n\t\t\t\t unsigned pin,\n\t\t\t\t u8 config)\n{\n\tstruct sunxi_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tu32 reg, shift, mask;\n\tunsigned long flags;\n\n\tpin -= pctl->desc->pin_base;\n\tsunxi_mux_reg(pctl, pin, &reg, &shift, &mask);\n\n\traw_spin_lock_irqsave(&pctl->lock, flags);\n\n\twritel((readl(pctl->membase + reg) & ~mask) | config << shift,\n\t       pctl->membase + reg);\n\n\traw_spin_unlock_irqrestore(&pctl->lock, flags);\n}\n\nstatic int sunxi_pmx_set_mux(struct pinctrl_dev *pctldev,\n\t\t\t     unsigned function,\n\t\t\t     unsigned group)\n{\n\tstruct sunxi_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct sunxi_pinctrl_group *g = pctl->groups + group;\n\tstruct sunxi_pinctrl_function *func = pctl->functions + function;\n\tstruct sunxi_desc_function *desc =\n\t\tsunxi_pinctrl_desc_find_function_by_name(pctl,\n\t\t\t\t\t\t\t g->name,\n\t\t\t\t\t\t\t func->name);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\tsunxi_pmx_set(pctldev, g->pin, desc->muxval);\n\n\treturn 0;\n}\n\nstatic int\nsunxi_pmx_gpio_set_direction(struct pinctrl_dev *pctldev,\n\t\t\tstruct pinctrl_gpio_range *range,\n\t\t\tunsigned offset,\n\t\t\tbool input)\n{\n\tstruct sunxi_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct sunxi_desc_function *desc;\n\tconst char *func;\n\n\tif (input)\n\t\tfunc = \"gpio_in\";\n\telse\n\t\tfunc = \"gpio_out\";\n\n\tdesc = sunxi_pinctrl_desc_find_function_by_pin(pctl, offset, func);\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\tsunxi_pmx_set(pctldev, offset, desc->muxval);\n\n\treturn 0;\n}\n\nstatic int sunxi_pmx_request(struct pinctrl_dev *pctldev, unsigned offset)\n{\n\tstruct sunxi_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tunsigned short bank = offset / PINS_PER_BANK;\n\tunsigned short bank_offset = bank - pctl->desc->pin_base /\n\t\t\t\t\t    PINS_PER_BANK;\n\tstruct sunxi_pinctrl_regulator *s_reg = &pctl->regulators[bank_offset];\n\tstruct regulator *reg = s_reg->regulator;\n\tchar supply[16];\n\tint ret;\n\n\tif (WARN_ON_ONCE(bank_offset >= ARRAY_SIZE(pctl->regulators)))\n\t\treturn -EINVAL;\n\n\tif (reg) {\n\t\trefcount_inc(&s_reg->refcount);\n\t\treturn 0;\n\t}\n\n\tsnprintf(supply, sizeof(supply), \"vcc-p%c\", 'a' + bank);\n\treg = regulator_get(pctl->dev, supply);\n\tif (IS_ERR(reg))\n\t\treturn dev_err_probe(pctl->dev, PTR_ERR(reg),\n\t\t\t\t     \"Couldn't get bank P%c regulator\\n\",\n\t\t\t\t     'A' + bank);\n\n\tret = regulator_enable(reg);\n\tif (ret) {\n\t\tdev_err(pctl->dev,\n\t\t\t\"Couldn't enable bank P%c regulator\\n\", 'A' + bank);\n\t\tgoto out;\n\t}\n\n\tsunxi_pinctrl_set_io_bias_cfg(pctl, offset, reg);\n\n\ts_reg->regulator = reg;\n\trefcount_set(&s_reg->refcount, 1);\n\n\treturn 0;\n\nout:\n\tregulator_put(s_reg->regulator);\n\n\treturn ret;\n}\n\nstatic int sunxi_pmx_free(struct pinctrl_dev *pctldev, unsigned offset)\n{\n\tstruct sunxi_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tunsigned short bank = offset / PINS_PER_BANK;\n\tunsigned short bank_offset = bank - pctl->desc->pin_base /\n\t\t\t\t\t    PINS_PER_BANK;\n\tstruct sunxi_pinctrl_regulator *s_reg = &pctl->regulators[bank_offset];\n\n\tif (!refcount_dec_and_test(&s_reg->refcount))\n\t\treturn 0;\n\n\tregulator_disable(s_reg->regulator);\n\tregulator_put(s_reg->regulator);\n\ts_reg->regulator = NULL;\n\n\treturn 0;\n}\n\nstatic const struct pinmux_ops sunxi_pmx_ops = {\n\t.get_functions_count\t= sunxi_pmx_get_funcs_cnt,\n\t.get_function_name\t= sunxi_pmx_get_func_name,\n\t.get_function_groups\t= sunxi_pmx_get_func_groups,\n\t.set_mux\t\t= sunxi_pmx_set_mux,\n\t.gpio_set_direction\t= sunxi_pmx_gpio_set_direction,\n\t.request\t\t= sunxi_pmx_request,\n\t.free\t\t\t= sunxi_pmx_free,\n\t.strict\t\t\t= true,\n};\n\nstatic int sunxi_pinctrl_gpio_direction_input(struct gpio_chip *chip,\n\t\t\t\t\tunsigned offset)\n{\n\tstruct sunxi_pinctrl *pctl = gpiochip_get_data(chip);\n\n\treturn sunxi_pmx_gpio_set_direction(pctl->pctl_dev, NULL,\n\t\t\t\t\t    chip->base + offset, true);\n}\n\nstatic int sunxi_pinctrl_gpio_get(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct sunxi_pinctrl *pctl = gpiochip_get_data(chip);\n\tbool set_mux = pctl->desc->irq_read_needs_mux &&\n\t\tgpiochip_line_is_irq(chip, offset);\n\tu32 pin = offset + chip->base;\n\tu32 reg, shift, mask, val;\n\n\tsunxi_data_reg(pctl, offset, &reg, &shift, &mask);\n\n\tif (set_mux)\n\t\tsunxi_pmx_set(pctl->pctl_dev, pin, SUN4I_FUNC_INPUT);\n\n\tval = (readl(pctl->membase + reg) & mask) >> shift;\n\n\tif (set_mux)\n\t\tsunxi_pmx_set(pctl->pctl_dev, pin, SUN4I_FUNC_IRQ);\n\n\treturn val;\n}\n\nstatic void sunxi_pinctrl_gpio_set(struct gpio_chip *chip,\n\t\t\t\tunsigned offset, int value)\n{\n\tstruct sunxi_pinctrl *pctl = gpiochip_get_data(chip);\n\tu32 reg, shift, mask, val;\n\tunsigned long flags;\n\n\tsunxi_data_reg(pctl, offset, &reg, &shift, &mask);\n\n\traw_spin_lock_irqsave(&pctl->lock, flags);\n\n\tval = readl(pctl->membase + reg);\n\n\tif (value)\n\t\tval |= mask;\n\telse\n\t\tval &= ~mask;\n\n\twritel(val, pctl->membase + reg);\n\n\traw_spin_unlock_irqrestore(&pctl->lock, flags);\n}\n\nstatic int sunxi_pinctrl_gpio_direction_output(struct gpio_chip *chip,\n\t\t\t\t\tunsigned offset, int value)\n{\n\tstruct sunxi_pinctrl *pctl = gpiochip_get_data(chip);\n\n\tsunxi_pinctrl_gpio_set(chip, offset, value);\n\treturn sunxi_pmx_gpio_set_direction(pctl->pctl_dev, NULL,\n\t\t\t\t\t    chip->base + offset, false);\n}\n\nstatic int sunxi_pinctrl_gpio_of_xlate(struct gpio_chip *gc,\n\t\t\t\tconst struct of_phandle_args *gpiospec,\n\t\t\t\tu32 *flags)\n{\n\tint pin, base;\n\n\tbase = PINS_PER_BANK * gpiospec->args[0];\n\tpin = base + gpiospec->args[1];\n\n\tif (pin > gc->ngpio)\n\t\treturn -EINVAL;\n\n\tif (flags)\n\t\t*flags = gpiospec->args[2];\n\n\treturn pin;\n}\n\nstatic int sunxi_pinctrl_gpio_to_irq(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct sunxi_pinctrl *pctl = gpiochip_get_data(chip);\n\tstruct sunxi_desc_function *desc;\n\tunsigned pinnum = pctl->desc->pin_base + offset;\n\tunsigned irqnum;\n\n\tif (offset >= chip->ngpio)\n\t\treturn -ENXIO;\n\n\tdesc = sunxi_pinctrl_desc_find_function_by_pin(pctl, pinnum, \"irq\");\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\tirqnum = desc->irqbank * IRQ_PER_BANK + desc->irqnum;\n\n\tdev_dbg(chip->parent, \"%s: request IRQ for GPIO %d, return %d\\n\",\n\t\tchip->label, offset + chip->base, irqnum);\n\n\treturn irq_find_mapping(pctl->domain, irqnum);\n}\n\nstatic int sunxi_pinctrl_irq_request_resources(struct irq_data *d)\n{\n\tstruct sunxi_pinctrl *pctl = irq_data_get_irq_chip_data(d);\n\tstruct sunxi_desc_function *func;\n\tint ret;\n\n\tfunc = sunxi_pinctrl_desc_find_function_by_pin(pctl,\n\t\t\t\t\tpctl->irq_array[d->hwirq], \"irq\");\n\tif (!func)\n\t\treturn -EINVAL;\n\n\tret = gpiochip_lock_as_irq(pctl->chip,\n\t\t\tpctl->irq_array[d->hwirq] - pctl->desc->pin_base);\n\tif (ret) {\n\t\tdev_err(pctl->dev, \"unable to lock HW IRQ %lu for IRQ\\n\",\n\t\t\tirqd_to_hwirq(d));\n\t\treturn ret;\n\t}\n\n\t \n\tsunxi_pmx_set(pctl->pctl_dev, pctl->irq_array[d->hwirq], func->muxval);\n\n\treturn 0;\n}\n\nstatic void sunxi_pinctrl_irq_release_resources(struct irq_data *d)\n{\n\tstruct sunxi_pinctrl *pctl = irq_data_get_irq_chip_data(d);\n\n\tgpiochip_unlock_as_irq(pctl->chip,\n\t\t\t      pctl->irq_array[d->hwirq] - pctl->desc->pin_base);\n}\n\nstatic int sunxi_pinctrl_irq_set_type(struct irq_data *d, unsigned int type)\n{\n\tstruct sunxi_pinctrl *pctl = irq_data_get_irq_chip_data(d);\n\tu32 reg = sunxi_irq_cfg_reg(pctl->desc, d->hwirq);\n\tu8 index = sunxi_irq_cfg_offset(d->hwirq);\n\tunsigned long flags;\n\tu32 regval;\n\tu8 mode;\n\n\tswitch (type) {\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tmode = IRQ_EDGE_RISING;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tmode = IRQ_EDGE_FALLING;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\tmode = IRQ_EDGE_BOTH;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tmode = IRQ_LEVEL_HIGH;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tmode = IRQ_LEVEL_LOW;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\traw_spin_lock_irqsave(&pctl->lock, flags);\n\n\tif (type & IRQ_TYPE_LEVEL_MASK)\n\t\tirq_set_chip_handler_name_locked(d, &sunxi_pinctrl_level_irq_chip,\n\t\t\t\t\t\t handle_fasteoi_irq, NULL);\n\telse\n\t\tirq_set_chip_handler_name_locked(d, &sunxi_pinctrl_edge_irq_chip,\n\t\t\t\t\t\t handle_edge_irq, NULL);\n\n\tregval = readl(pctl->membase + reg);\n\tregval &= ~(IRQ_CFG_IRQ_MASK << index);\n\twritel(regval | (mode << index), pctl->membase + reg);\n\n\traw_spin_unlock_irqrestore(&pctl->lock, flags);\n\n\treturn 0;\n}\n\nstatic void sunxi_pinctrl_irq_ack(struct irq_data *d)\n{\n\tstruct sunxi_pinctrl *pctl = irq_data_get_irq_chip_data(d);\n\tu32 status_reg = sunxi_irq_status_reg(pctl->desc, d->hwirq);\n\tu8 status_idx = sunxi_irq_status_offset(d->hwirq);\n\n\t \n\twritel(1 << status_idx, pctl->membase + status_reg);\n}\n\nstatic void sunxi_pinctrl_irq_mask(struct irq_data *d)\n{\n\tstruct sunxi_pinctrl *pctl = irq_data_get_irq_chip_data(d);\n\tu32 reg = sunxi_irq_ctrl_reg(pctl->desc, d->hwirq);\n\tu8 idx = sunxi_irq_ctrl_offset(d->hwirq);\n\tunsigned long flags;\n\tu32 val;\n\n\traw_spin_lock_irqsave(&pctl->lock, flags);\n\n\t \n\tval = readl(pctl->membase + reg);\n\twritel(val & ~(1 << idx), pctl->membase + reg);\n\n\traw_spin_unlock_irqrestore(&pctl->lock, flags);\n}\n\nstatic void sunxi_pinctrl_irq_unmask(struct irq_data *d)\n{\n\tstruct sunxi_pinctrl *pctl = irq_data_get_irq_chip_data(d);\n\tu32 reg = sunxi_irq_ctrl_reg(pctl->desc, d->hwirq);\n\tu8 idx = sunxi_irq_ctrl_offset(d->hwirq);\n\tunsigned long flags;\n\tu32 val;\n\n\traw_spin_lock_irqsave(&pctl->lock, flags);\n\n\t \n\tval = readl(pctl->membase + reg);\n\twritel(val | (1 << idx), pctl->membase + reg);\n\n\traw_spin_unlock_irqrestore(&pctl->lock, flags);\n}\n\nstatic void sunxi_pinctrl_irq_ack_unmask(struct irq_data *d)\n{\n\tsunxi_pinctrl_irq_ack(d);\n\tsunxi_pinctrl_irq_unmask(d);\n}\n\nstatic int sunxi_pinctrl_irq_set_wake(struct irq_data *d, unsigned int on)\n{\n\tstruct sunxi_pinctrl *pctl = irq_data_get_irq_chip_data(d);\n\tu8 bank = d->hwirq / IRQ_PER_BANK;\n\n\treturn irq_set_irq_wake(pctl->irq[bank], on);\n}\n\nstatic struct irq_chip sunxi_pinctrl_edge_irq_chip = {\n\t.name\t\t= \"sunxi_pio_edge\",\n\t.irq_ack\t= sunxi_pinctrl_irq_ack,\n\t.irq_mask\t= sunxi_pinctrl_irq_mask,\n\t.irq_unmask\t= sunxi_pinctrl_irq_unmask,\n\t.irq_request_resources = sunxi_pinctrl_irq_request_resources,\n\t.irq_release_resources = sunxi_pinctrl_irq_release_resources,\n\t.irq_set_type\t= sunxi_pinctrl_irq_set_type,\n\t.irq_set_wake\t= sunxi_pinctrl_irq_set_wake,\n\t.flags\t\t= IRQCHIP_MASK_ON_SUSPEND,\n};\n\nstatic struct irq_chip sunxi_pinctrl_level_irq_chip = {\n\t.name\t\t= \"sunxi_pio_level\",\n\t.irq_eoi\t= sunxi_pinctrl_irq_ack,\n\t.irq_mask\t= sunxi_pinctrl_irq_mask,\n\t.irq_unmask\t= sunxi_pinctrl_irq_unmask,\n\t \n\t.irq_enable\t= sunxi_pinctrl_irq_ack_unmask,\n\t.irq_disable\t= sunxi_pinctrl_irq_mask,\n\t.irq_request_resources = sunxi_pinctrl_irq_request_resources,\n\t.irq_release_resources = sunxi_pinctrl_irq_release_resources,\n\t.irq_set_type\t= sunxi_pinctrl_irq_set_type,\n\t.irq_set_wake\t= sunxi_pinctrl_irq_set_wake,\n\t.flags\t\t= IRQCHIP_EOI_THREADED |\n\t\t\t  IRQCHIP_MASK_ON_SUSPEND |\n\t\t\t  IRQCHIP_EOI_IF_HANDLED,\n};\n\nstatic int sunxi_pinctrl_irq_of_xlate(struct irq_domain *d,\n\t\t\t\t      struct device_node *node,\n\t\t\t\t      const u32 *intspec,\n\t\t\t\t      unsigned int intsize,\n\t\t\t\t      unsigned long *out_hwirq,\n\t\t\t\t      unsigned int *out_type)\n{\n\tstruct sunxi_pinctrl *pctl = d->host_data;\n\tstruct sunxi_desc_function *desc;\n\tint pin, base;\n\n\tif (intsize < 3)\n\t\treturn -EINVAL;\n\n\tbase = PINS_PER_BANK * intspec[0];\n\tpin = pctl->desc->pin_base + base + intspec[1];\n\n\tdesc = sunxi_pinctrl_desc_find_function_by_pin(pctl, pin, \"irq\");\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\t*out_hwirq = desc->irqbank * PINS_PER_BANK + desc->irqnum;\n\t*out_type = intspec[2];\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops sunxi_pinctrl_irq_domain_ops = {\n\t.xlate\t\t= sunxi_pinctrl_irq_of_xlate,\n};\n\nstatic void sunxi_pinctrl_irq_handler(struct irq_desc *desc)\n{\n\tunsigned int irq = irq_desc_get_irq(desc);\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tstruct sunxi_pinctrl *pctl = irq_desc_get_handler_data(desc);\n\tunsigned long bank, reg, val;\n\n\tfor (bank = 0; bank < pctl->desc->irq_banks; bank++)\n\t\tif (irq == pctl->irq[bank])\n\t\t\tbreak;\n\n\tWARN_ON(bank == pctl->desc->irq_banks);\n\n\tchained_irq_enter(chip, desc);\n\n\treg = sunxi_irq_status_reg_from_bank(pctl->desc, bank);\n\tval = readl(pctl->membase + reg);\n\n\tif (val) {\n\t\tint irqoffset;\n\n\t\tfor_each_set_bit(irqoffset, &val, IRQ_PER_BANK)\n\t\t\tgeneric_handle_domain_irq(pctl->domain,\n\t\t\t\t\t\t  bank * IRQ_PER_BANK + irqoffset);\n\t}\n\n\tchained_irq_exit(chip, desc);\n}\n\nstatic int sunxi_pinctrl_add_function(struct sunxi_pinctrl *pctl,\n\t\t\t\t\tconst char *name)\n{\n\tstruct sunxi_pinctrl_function *func = pctl->functions;\n\n\twhile (func->name) {\n\t\t \n\t\tif (strcmp(func->name, name) == 0) {\n\t\t\tfunc->ngroups++;\n\t\t\treturn -EEXIST;\n\t\t}\n\t\tfunc++;\n\t}\n\n\tfunc->name = name;\n\tfunc->ngroups = 1;\n\n\tpctl->nfunctions++;\n\n\treturn 0;\n}\n\nstatic int sunxi_pinctrl_build_state(struct platform_device *pdev)\n{\n\tstruct sunxi_pinctrl *pctl = platform_get_drvdata(pdev);\n\tvoid *ptr;\n\tint i;\n\n\t \n\tpctl->groups = devm_kcalloc(&pdev->dev,\n\t\t\t\t    pctl->desc->npins, sizeof(*pctl->groups),\n\t\t\t\t    GFP_KERNEL);\n\tif (!pctl->groups)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < pctl->desc->npins; i++) {\n\t\tconst struct sunxi_desc_pin *pin = pctl->desc->pins + i;\n\t\tstruct sunxi_pinctrl_group *group = pctl->groups + pctl->ngroups;\n\n\t\tif (pin->variant && !(pctl->variant & pin->variant))\n\t\t\tcontinue;\n\n\t\tgroup->name = pin->pin.name;\n\t\tgroup->pin = pin->pin.number;\n\n\t\t \n\t\tpctl->ngroups++;\n\t}\n\n\t \n\tpctl->functions = kcalloc(7 * pctl->ngroups + 4,\n\t\t\t\t  sizeof(*pctl->functions),\n\t\t\t\t  GFP_KERNEL);\n\tif (!pctl->functions)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = 0; i < pctl->desc->npins; i++) {\n\t\tconst struct sunxi_desc_pin *pin = pctl->desc->pins + i;\n\t\tstruct sunxi_desc_function *func;\n\n\t\tif (pin->variant && !(pctl->variant & pin->variant))\n\t\t\tcontinue;\n\n\t\tfor (func = pin->functions; func->name; func++) {\n\t\t\tif (func->variant && !(pctl->variant & func->variant))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (!strcmp(func->name, \"irq\")) {\n\t\t\t\tint irqnum = func->irqnum + func->irqbank * IRQ_PER_BANK;\n\t\t\t\tpctl->irq_array[irqnum] = pin->pin.number;\n\t\t\t}\n\n\t\t\tsunxi_pinctrl_add_function(pctl, func->name);\n\t\t}\n\t}\n\n\t \n\tptr = krealloc(pctl->functions,\n\t\t       pctl->nfunctions * sizeof(*pctl->functions),\n\t\t       GFP_KERNEL);\n\tif (!ptr) {\n\t\tkfree(pctl->functions);\n\t\tpctl->functions = NULL;\n\t\treturn -ENOMEM;\n\t}\n\tpctl->functions = ptr;\n\n\tfor (i = 0; i < pctl->desc->npins; i++) {\n\t\tconst struct sunxi_desc_pin *pin = pctl->desc->pins + i;\n\t\tstruct sunxi_desc_function *func;\n\n\t\tif (pin->variant && !(pctl->variant & pin->variant))\n\t\t\tcontinue;\n\n\t\tfor (func = pin->functions; func->name; func++) {\n\t\t\tstruct sunxi_pinctrl_function *func_item;\n\t\t\tconst char **func_grp;\n\n\t\t\tif (func->variant && !(pctl->variant & func->variant))\n\t\t\t\tcontinue;\n\n\t\t\tfunc_item = sunxi_pinctrl_find_function_by_name(pctl,\n\t\t\t\t\t\t\t\t\tfunc->name);\n\t\t\tif (!func_item) {\n\t\t\t\tkfree(pctl->functions);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (!func_item->groups) {\n\t\t\t\tfunc_item->groups =\n\t\t\t\t\tdevm_kcalloc(&pdev->dev,\n\t\t\t\t\t\t     func_item->ngroups,\n\t\t\t\t\t\t     sizeof(*func_item->groups),\n\t\t\t\t\t\t     GFP_KERNEL);\n\t\t\t\tif (!func_item->groups) {\n\t\t\t\t\tkfree(pctl->functions);\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunc_grp = func_item->groups;\n\t\t\twhile (*func_grp)\n\t\t\t\tfunc_grp++;\n\n\t\t\t*func_grp = pin->pin.name;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int sunxi_pinctrl_get_debounce_div(struct clk *clk, int freq, int *diff)\n{\n\tunsigned long clock = clk_get_rate(clk);\n\tunsigned int best_diff, best_div;\n\tint i;\n\n\tbest_diff = abs(freq - clock);\n\tbest_div = 0;\n\n\tfor (i = 1; i < 8; i++) {\n\t\tint cur_diff = abs(freq - (clock >> i));\n\n\t\tif (cur_diff < best_diff) {\n\t\t\tbest_diff = cur_diff;\n\t\t\tbest_div = i;\n\t\t}\n\t}\n\n\t*diff = best_diff;\n\treturn best_div;\n}\n\nstatic int sunxi_pinctrl_setup_debounce(struct sunxi_pinctrl *pctl,\n\t\t\t\t\tstruct device_node *node)\n{\n\tunsigned int hosc_diff, losc_diff;\n\tunsigned int hosc_div, losc_div;\n\tstruct clk *hosc, *losc;\n\tu8 div, src;\n\tint i, ret;\n\n\t \n\tif (of_clk_get_parent_count(node) != 3)\n\t\treturn 0;\n\n\t \n\tif (!of_property_present(node, \"input-debounce\"))\n\t\treturn 0;\n\n\tlosc = devm_clk_get(pctl->dev, \"losc\");\n\tif (IS_ERR(losc))\n\t\treturn PTR_ERR(losc);\n\n\thosc = devm_clk_get(pctl->dev, \"hosc\");\n\tif (IS_ERR(hosc))\n\t\treturn PTR_ERR(hosc);\n\n\tfor (i = 0; i < pctl->desc->irq_banks; i++) {\n\t\tunsigned long debounce_freq;\n\t\tu32 debounce;\n\n\t\tret = of_property_read_u32_index(node, \"input-debounce\",\n\t\t\t\t\t\t i, &debounce);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (!debounce)\n\t\t\tcontinue;\n\n\t\tdebounce_freq = DIV_ROUND_CLOSEST(USEC_PER_SEC, debounce);\n\t\tlosc_div = sunxi_pinctrl_get_debounce_div(losc,\n\t\t\t\t\t\t\t  debounce_freq,\n\t\t\t\t\t\t\t  &losc_diff);\n\n\t\thosc_div = sunxi_pinctrl_get_debounce_div(hosc,\n\t\t\t\t\t\t\t  debounce_freq,\n\t\t\t\t\t\t\t  &hosc_diff);\n\n\t\tif (hosc_diff < losc_diff) {\n\t\t\tdiv = hosc_div;\n\t\t\tsrc = 1;\n\t\t} else {\n\t\t\tdiv = losc_div;\n\t\t\tsrc = 0;\n\t\t}\n\n\t\twritel(src | div << 4,\n\t\t       pctl->membase +\n\t\t       sunxi_irq_debounce_reg_from_bank(pctl->desc, i));\n\t}\n\n\treturn 0;\n}\n\nint sunxi_pinctrl_init_with_variant(struct platform_device *pdev,\n\t\t\t\t    const struct sunxi_pinctrl_desc *desc,\n\t\t\t\t    unsigned long variant)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct pinctrl_desc *pctrl_desc;\n\tstruct pinctrl_pin_desc *pins;\n\tstruct sunxi_pinctrl *pctl;\n\tstruct pinmux_ops *pmxops;\n\tint i, ret, last_pin, pin_idx;\n\tstruct clk *clk;\n\n\tpctl = devm_kzalloc(&pdev->dev, sizeof(*pctl), GFP_KERNEL);\n\tif (!pctl)\n\t\treturn -ENOMEM;\n\tplatform_set_drvdata(pdev, pctl);\n\n\traw_spin_lock_init(&pctl->lock);\n\n\tpctl->membase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(pctl->membase))\n\t\treturn PTR_ERR(pctl->membase);\n\n\tpctl->dev = &pdev->dev;\n\tpctl->desc = desc;\n\tpctl->variant = variant;\n\tif (pctl->variant >= PINCTRL_SUN20I_D1) {\n\t\tpctl->bank_mem_size = D1_BANK_MEM_SIZE;\n\t\tpctl->pull_regs_offset = D1_PULL_REGS_OFFSET;\n\t\tpctl->dlevel_field_width = D1_DLEVEL_FIELD_WIDTH;\n\t} else {\n\t\tpctl->bank_mem_size = BANK_MEM_SIZE;\n\t\tpctl->pull_regs_offset = PULL_REGS_OFFSET;\n\t\tpctl->dlevel_field_width = DLEVEL_FIELD_WIDTH;\n\t}\n\n\tpctl->irq_array = devm_kcalloc(&pdev->dev,\n\t\t\t\t       IRQ_PER_BANK * pctl->desc->irq_banks,\n\t\t\t\t       sizeof(*pctl->irq_array),\n\t\t\t\t       GFP_KERNEL);\n\tif (!pctl->irq_array)\n\t\treturn -ENOMEM;\n\n\tret = sunxi_pinctrl_build_state(pdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"dt probe failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpins = devm_kcalloc(&pdev->dev,\n\t\t\t    pctl->desc->npins, sizeof(*pins),\n\t\t\t    GFP_KERNEL);\n\tif (!pins)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0, pin_idx = 0; i < pctl->desc->npins; i++) {\n\t\tconst struct sunxi_desc_pin *pin = pctl->desc->pins + i;\n\n\t\tif (pin->variant && !(pctl->variant & pin->variant))\n\t\t\tcontinue;\n\n\t\tpins[pin_idx++] = pin->pin;\n\t}\n\n\tpctrl_desc = devm_kzalloc(&pdev->dev,\n\t\t\t\t  sizeof(*pctrl_desc),\n\t\t\t\t  GFP_KERNEL);\n\tif (!pctrl_desc)\n\t\treturn -ENOMEM;\n\n\tpctrl_desc->name = dev_name(&pdev->dev);\n\tpctrl_desc->owner = THIS_MODULE;\n\tpctrl_desc->pins = pins;\n\tpctrl_desc->npins = pctl->ngroups;\n\tpctrl_desc->confops = &sunxi_pconf_ops;\n\tpctrl_desc->pctlops = &sunxi_pctrl_ops;\n\n\tpmxops = devm_kmemdup(&pdev->dev, &sunxi_pmx_ops, sizeof(sunxi_pmx_ops),\n\t\t\t      GFP_KERNEL);\n\tif (!pmxops)\n\t\treturn -ENOMEM;\n\n\tif (desc->disable_strict_mode)\n\t\tpmxops->strict = false;\n\n\tpctrl_desc->pmxops = pmxops;\n\n\tpctl->pctl_dev = devm_pinctrl_register(&pdev->dev, pctrl_desc, pctl);\n\tif (IS_ERR(pctl->pctl_dev)) {\n\t\tdev_err(&pdev->dev, \"couldn't register pinctrl driver\\n\");\n\t\treturn PTR_ERR(pctl->pctl_dev);\n\t}\n\n\tpctl->chip = devm_kzalloc(&pdev->dev, sizeof(*pctl->chip), GFP_KERNEL);\n\tif (!pctl->chip)\n\t\treturn -ENOMEM;\n\n\tlast_pin = pctl->desc->pins[pctl->desc->npins - 1].pin.number;\n\tpctl->chip->owner = THIS_MODULE;\n\tpctl->chip->request = gpiochip_generic_request;\n\tpctl->chip->free = gpiochip_generic_free;\n\tpctl->chip->set_config = gpiochip_generic_config;\n\tpctl->chip->direction_input = sunxi_pinctrl_gpio_direction_input;\n\tpctl->chip->direction_output = sunxi_pinctrl_gpio_direction_output;\n\tpctl->chip->get = sunxi_pinctrl_gpio_get;\n\tpctl->chip->set = sunxi_pinctrl_gpio_set;\n\tpctl->chip->of_xlate = sunxi_pinctrl_gpio_of_xlate;\n\tpctl->chip->to_irq = sunxi_pinctrl_gpio_to_irq;\n\tpctl->chip->of_gpio_n_cells = 3;\n\tpctl->chip->can_sleep = false;\n\tpctl->chip->ngpio = round_up(last_pin, PINS_PER_BANK) -\n\t\t\t    pctl->desc->pin_base;\n\tpctl->chip->label = dev_name(&pdev->dev);\n\tpctl->chip->parent = &pdev->dev;\n\tpctl->chip->base = pctl->desc->pin_base;\n\n\tret = gpiochip_add_data(pctl->chip, pctl);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < pctl->desc->npins; i++) {\n\t\tconst struct sunxi_desc_pin *pin = pctl->desc->pins + i;\n\n\t\tret = gpiochip_add_pin_range(pctl->chip, dev_name(&pdev->dev),\n\t\t\t\t\t     pin->pin.number - pctl->desc->pin_base,\n\t\t\t\t\t     pin->pin.number, 1);\n\t\tif (ret)\n\t\t\tgoto gpiochip_error;\n\t}\n\n\tret = of_clk_get_parent_count(node);\n\tclk = devm_clk_get(&pdev->dev, ret == 1 ? NULL : \"apb\");\n\tif (IS_ERR(clk)) {\n\t\tret = PTR_ERR(clk);\n\t\tgoto gpiochip_error;\n\t}\n\n\tret = clk_prepare_enable(clk);\n\tif (ret)\n\t\tgoto gpiochip_error;\n\n\tpctl->irq = devm_kcalloc(&pdev->dev,\n\t\t\t\t pctl->desc->irq_banks,\n\t\t\t\t sizeof(*pctl->irq),\n\t\t\t\t GFP_KERNEL);\n\tif (!pctl->irq) {\n\t\tret = -ENOMEM;\n\t\tgoto clk_error;\n\t}\n\n\tfor (i = 0; i < pctl->desc->irq_banks; i++) {\n\t\tpctl->irq[i] = platform_get_irq(pdev, i);\n\t\tif (pctl->irq[i] < 0) {\n\t\t\tret = pctl->irq[i];\n\t\t\tgoto clk_error;\n\t\t}\n\t}\n\n\tpctl->domain = irq_domain_add_linear(node,\n\t\t\t\t\t     pctl->desc->irq_banks * IRQ_PER_BANK,\n\t\t\t\t\t     &sunxi_pinctrl_irq_domain_ops,\n\t\t\t\t\t     pctl);\n\tif (!pctl->domain) {\n\t\tdev_err(&pdev->dev, \"Couldn't register IRQ domain\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto clk_error;\n\t}\n\n\tfor (i = 0; i < (pctl->desc->irq_banks * IRQ_PER_BANK); i++) {\n\t\tint irqno = irq_create_mapping(pctl->domain, i);\n\n\t\tirq_set_lockdep_class(irqno, &sunxi_pinctrl_irq_lock_class,\n\t\t\t\t      &sunxi_pinctrl_irq_request_class);\n\t\tirq_set_chip_and_handler(irqno, &sunxi_pinctrl_edge_irq_chip,\n\t\t\t\t\t handle_edge_irq);\n\t\tirq_set_chip_data(irqno, pctl);\n\t}\n\n\tfor (i = 0; i < pctl->desc->irq_banks; i++) {\n\t\t \n\t\twritel(0, pctl->membase +\n\t\t\t  sunxi_irq_ctrl_reg_from_bank(pctl->desc, i));\n\t\twritel(0xffffffff,\n\t\t       pctl->membase +\n\t\t       sunxi_irq_status_reg_from_bank(pctl->desc, i));\n\n\t\tirq_set_chained_handler_and_data(pctl->irq[i],\n\t\t\t\t\t\t sunxi_pinctrl_irq_handler,\n\t\t\t\t\t\t pctl);\n\t}\n\n\tsunxi_pinctrl_setup_debounce(pctl, node);\n\n\tdev_info(&pdev->dev, \"initialized sunXi PIO driver\\n\");\n\n\treturn 0;\n\nclk_error:\n\tclk_disable_unprepare(clk);\ngpiochip_error:\n\tgpiochip_remove(pctl->chip);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}