{
  "module_name": "pinctrl-uniphier-core.c",
  "hash_id": "7b0bcda8e7f81f22dc1cd60ae346ea252bd3c98fa91fec0f0b076ca510cdf90f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/uniphier/pinctrl-uniphier-core.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/list.h>\n#include <linux/mfd/syscon.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/seq_file.h>\n\n#include <linux/pinctrl/pinconf-generic.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinmux.h>\n\n#include \"../core.h\"\n#include \"../pinctrl-utils.h\"\n#include \"pinctrl-uniphier.h\"\n\n#define UNIPHIER_PINCTRL_PINMUX_BASE\t0x1000\n#define UNIPHIER_PINCTRL_LOAD_PINMUX\t0x1700\n#define UNIPHIER_PINCTRL_DRVCTRL_BASE\t0x1800\n#define UNIPHIER_PINCTRL_DRV2CTRL_BASE\t0x1900\n#define UNIPHIER_PINCTRL_DRV3CTRL_BASE\t0x1980\n#define UNIPHIER_PINCTRL_PUPDCTRL_BASE\t0x1a00\n#define UNIPHIER_PINCTRL_IECTRL_BASE\t0x1d00\n\nstruct uniphier_pinctrl_reg_region {\n\tstruct list_head node;\n\tunsigned int base;\n\tunsigned int nregs;\n\tu32 vals[];\n};\n\nstruct uniphier_pinctrl_priv {\n\tstruct pinctrl_desc pctldesc;\n\tstruct pinctrl_dev *pctldev;\n\tstruct regmap *regmap;\n\tconst struct uniphier_pinctrl_socdata *socdata;\n\tstruct list_head reg_regions;\n};\n\nstatic int uniphier_pctl_get_groups_count(struct pinctrl_dev *pctldev)\n{\n\tstruct uniphier_pinctrl_priv *priv = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn priv->socdata->groups_count;\n}\n\nstatic const char *uniphier_pctl_get_group_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t\tunsigned selector)\n{\n\tstruct uniphier_pinctrl_priv *priv = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn priv->socdata->groups[selector].name;\n}\n\nstatic int uniphier_pctl_get_group_pins(struct pinctrl_dev *pctldev,\n\t\t\t\t\tunsigned selector,\n\t\t\t\t\tconst unsigned **pins,\n\t\t\t\t\tunsigned *num_pins)\n{\n\tstruct uniphier_pinctrl_priv *priv = pinctrl_dev_get_drvdata(pctldev);\n\n\t*pins = priv->socdata->groups[selector].pins;\n\t*num_pins = priv->socdata->groups[selector].num_pins;\n\n\treturn 0;\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic void uniphier_pctl_pin_dbg_show(struct pinctrl_dev *pctldev,\n\t\t\t\t       struct seq_file *s, unsigned offset)\n{\n\tconst struct pin_desc *desc = pin_desc_get(pctldev, offset);\n\tconst char *pull_dir, *drv_type;\n\n\tswitch (uniphier_pin_get_pull_dir(desc->drv_data)) {\n\tcase UNIPHIER_PIN_PULL_UP:\n\t\tpull_dir = \"UP\";\n\t\tbreak;\n\tcase UNIPHIER_PIN_PULL_DOWN:\n\t\tpull_dir = \"DOWN\";\n\t\tbreak;\n\tcase UNIPHIER_PIN_PULL_UP_FIXED:\n\t\tpull_dir = \"UP(FIXED)\";\n\t\tbreak;\n\tcase UNIPHIER_PIN_PULL_DOWN_FIXED:\n\t\tpull_dir = \"DOWN(FIXED)\";\n\t\tbreak;\n\tcase UNIPHIER_PIN_PULL_NONE:\n\t\tpull_dir = \"NONE\";\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tswitch (uniphier_pin_get_drv_type(desc->drv_data)) {\n\tcase UNIPHIER_PIN_DRV_1BIT:\n\t\tdrv_type = \"4/8(mA)\";\n\t\tbreak;\n\tcase UNIPHIER_PIN_DRV_2BIT:\n\t\tdrv_type = \"8/12/16/20(mA)\";\n\t\tbreak;\n\tcase UNIPHIER_PIN_DRV_3BIT:\n\t\tdrv_type = \"4/5/7/9/11/12/14/16(mA)\";\n\t\tbreak;\n\tcase UNIPHIER_PIN_DRV_FIXED4:\n\t\tdrv_type = \"4(mA)\";\n\t\tbreak;\n\tcase UNIPHIER_PIN_DRV_FIXED5:\n\t\tdrv_type = \"5(mA)\";\n\t\tbreak;\n\tcase UNIPHIER_PIN_DRV_FIXED8:\n\t\tdrv_type = \"8(mA)\";\n\t\tbreak;\n\tcase UNIPHIER_PIN_DRV_NONE:\n\t\tdrv_type = \"NONE\";\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tseq_printf(s, \" PULL_DIR=%s  DRV_TYPE=%s\", pull_dir, drv_type);\n}\n#endif\n\nstatic const struct pinctrl_ops uniphier_pctlops = {\n\t.get_groups_count = uniphier_pctl_get_groups_count,\n\t.get_group_name = uniphier_pctl_get_group_name,\n\t.get_group_pins = uniphier_pctl_get_group_pins,\n#ifdef CONFIG_DEBUG_FS\n\t.pin_dbg_show = uniphier_pctl_pin_dbg_show,\n#endif\n\t.dt_node_to_map = pinconf_generic_dt_node_to_map_all,\n\t.dt_free_map = pinctrl_utils_free_map,\n};\n\nstatic const unsigned int uniphier_conf_drv_strengths_1bit[] = {4, 8};\nstatic const unsigned int uniphier_conf_drv_strengths_2bit[] = {8, 12, 16, 20};\nstatic const unsigned int uniphier_conf_drv_strengths_3bit[] = {4, 5, 7, 9, 11,\n\t\t\t\t\t\t\t\t12, 14, 16};\nstatic const unsigned int uniphier_conf_drv_strengths_fixed4[] = {4};\nstatic const unsigned int uniphier_conf_drv_strengths_fixed5[] = {5};\nstatic const unsigned int uniphier_conf_drv_strengths_fixed8[] = {8};\n\nstatic int uniphier_conf_get_drvctrl_data(struct pinctrl_dev *pctldev,\n\t\t\t\t\t  unsigned int pin, unsigned int *reg,\n\t\t\t\t\t  unsigned int *shift,\n\t\t\t\t\t  unsigned int *mask,\n\t\t\t\t\t  const unsigned int **strengths)\n{\n\tconst struct pin_desc *desc = pin_desc_get(pctldev, pin);\n\tenum uniphier_pin_drv_type type =\n\t\t\t\tuniphier_pin_get_drv_type(desc->drv_data);\n\tunsigned int base = 0;\n\tunsigned int stride = 0;\n\tunsigned int width = 0;\n\tunsigned int drvctrl;\n\n\tswitch (type) {\n\tcase UNIPHIER_PIN_DRV_1BIT:\n\t\t*strengths = uniphier_conf_drv_strengths_1bit;\n\t\tbase = UNIPHIER_PINCTRL_DRVCTRL_BASE;\n\t\tstride = 1;\n\t\twidth = 1;\n\t\tbreak;\n\tcase UNIPHIER_PIN_DRV_2BIT:\n\t\t*strengths = uniphier_conf_drv_strengths_2bit;\n\t\tbase = UNIPHIER_PINCTRL_DRV2CTRL_BASE;\n\t\tstride = 2;\n\t\twidth = 2;\n\t\tbreak;\n\tcase UNIPHIER_PIN_DRV_3BIT:\n\t\t*strengths = uniphier_conf_drv_strengths_3bit;\n\t\tbase = UNIPHIER_PINCTRL_DRV3CTRL_BASE;\n\t\tstride = 4;\n\t\twidth = 3;\n\t\tbreak;\n\tcase UNIPHIER_PIN_DRV_FIXED4:\n\t\t*strengths = uniphier_conf_drv_strengths_fixed4;\n\t\tbreak;\n\tcase UNIPHIER_PIN_DRV_FIXED5:\n\t\t*strengths = uniphier_conf_drv_strengths_fixed5;\n\t\tbreak;\n\tcase UNIPHIER_PIN_DRV_FIXED8:\n\t\t*strengths = uniphier_conf_drv_strengths_fixed8;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\tdrvctrl = uniphier_pin_get_drvctrl(desc->drv_data);\n\tdrvctrl *= stride;\n\n\t*reg = base + drvctrl / 32 * 4;\n\t*shift = drvctrl % 32;\n\t*mask = (1U << width) - 1;\n\n\treturn 0;\n}\n\nstatic int uniphier_conf_pin_bias_get(struct pinctrl_dev *pctldev,\n\t\t\t\t      unsigned int pin,\n\t\t\t\t      enum pin_config_param param)\n{\n\tstruct uniphier_pinctrl_priv *priv = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct pin_desc *desc = pin_desc_get(pctldev, pin);\n\tenum uniphier_pin_pull_dir pull_dir =\n\t\t\t\tuniphier_pin_get_pull_dir(desc->drv_data);\n\tunsigned int pupdctrl, reg, shift, val;\n\tunsigned int expected = 1;\n\tint ret;\n\n\tswitch (param) {\n\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\tif (pull_dir == UNIPHIER_PIN_PULL_NONE)\n\t\t\treturn 0;\n\t\tif (pull_dir == UNIPHIER_PIN_PULL_UP_FIXED ||\n\t\t    pull_dir == UNIPHIER_PIN_PULL_DOWN_FIXED)\n\t\t\treturn -EINVAL;\n\t\texpected = 0;\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\tif (pull_dir == UNIPHIER_PIN_PULL_UP_FIXED)\n\t\t\treturn 0;\n\t\tif (pull_dir != UNIPHIER_PIN_PULL_UP)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\tif (pull_dir == UNIPHIER_PIN_PULL_DOWN_FIXED)\n\t\t\treturn 0;\n\t\tif (pull_dir != UNIPHIER_PIN_PULL_DOWN)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tpupdctrl = uniphier_pin_get_pupdctrl(desc->drv_data);\n\n\treg = UNIPHIER_PINCTRL_PUPDCTRL_BASE + pupdctrl / 32 * 4;\n\tshift = pupdctrl % 32;\n\n\tret = regmap_read(priv->regmap, reg, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tval = (val >> shift) & 1;\n\n\treturn (val == expected) ? 0 : -EINVAL;\n}\n\nstatic int uniphier_conf_pin_drive_get(struct pinctrl_dev *pctldev,\n\t\t\t\t       unsigned int pin, u32 *strength)\n{\n\tstruct uniphier_pinctrl_priv *priv = pinctrl_dev_get_drvdata(pctldev);\n\tunsigned int reg, shift, mask, val;\n\tconst unsigned int *strengths;\n\tint ret;\n\n\tret = uniphier_conf_get_drvctrl_data(pctldev, pin, &reg, &shift,\n\t\t\t\t\t     &mask, &strengths);\n\tif (ret)\n\t\treturn ret;\n\n\tif (mask) {\n\t\tret = regmap_read(priv->regmap, reg, &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tval = 0;\n\t}\n\n\t*strength = strengths[(val >> shift) & mask];\n\n\treturn 0;\n}\n\nstatic int uniphier_conf_pin_input_enable_get(struct pinctrl_dev *pctldev,\n\t\t\t\t\t      unsigned int pin)\n{\n\tstruct uniphier_pinctrl_priv *priv = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct pin_desc *desc = pin_desc_get(pctldev, pin);\n\tunsigned int iectrl = uniphier_pin_get_iectrl(desc->drv_data);\n\tunsigned int reg, mask, val;\n\tint ret;\n\n\tif (iectrl == UNIPHIER_PIN_IECTRL_NONE)\n\t\t \n\t\treturn 0;\n\n\tif (priv->socdata->caps & UNIPHIER_PINCTRL_CAPS_PERPIN_IECTRL)\n\t\tiectrl = pin;\n\n\treg = UNIPHIER_PINCTRL_IECTRL_BASE + iectrl / 32 * 4;\n\tmask = BIT(iectrl % 32);\n\n\tret = regmap_read(priv->regmap, reg, &val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn val & mask ? 0 : -EINVAL;\n}\n\nstatic int uniphier_conf_pin_config_get(struct pinctrl_dev *pctldev,\n\t\t\t\t\tunsigned pin,\n\t\t\t\t\tunsigned long *configs)\n{\n\tenum pin_config_param param = pinconf_to_config_param(*configs);\n\tbool has_arg = false;\n\tu32 arg;\n\tint ret;\n\n\tswitch (param) {\n\tcase PIN_CONFIG_BIAS_DISABLE:\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\tret = uniphier_conf_pin_bias_get(pctldev, pin, param);\n\t\tbreak;\n\tcase PIN_CONFIG_DRIVE_STRENGTH:\n\t\tret = uniphier_conf_pin_drive_get(pctldev, pin, &arg);\n\t\thas_arg = true;\n\t\tbreak;\n\tcase PIN_CONFIG_INPUT_ENABLE:\n\t\tret = uniphier_conf_pin_input_enable_get(pctldev, pin);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (ret == 0 && has_arg)\n\t\t*configs = pinconf_to_config_packed(param, arg);\n\n\treturn ret;\n}\n\nstatic int uniphier_conf_pin_bias_set(struct pinctrl_dev *pctldev,\n\t\t\t\t      unsigned int pin,\n\t\t\t\t      enum pin_config_param param, u32 arg)\n{\n\tstruct uniphier_pinctrl_priv *priv = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct pin_desc *desc = pin_desc_get(pctldev, pin);\n\tenum uniphier_pin_pull_dir pull_dir =\n\t\t\t\tuniphier_pin_get_pull_dir(desc->drv_data);\n\tunsigned int pupdctrl, reg, shift;\n\tunsigned int val = 1;\n\n\tswitch (param) {\n\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\tif (pull_dir == UNIPHIER_PIN_PULL_NONE)\n\t\t\treturn 0;\n\t\tif (pull_dir == UNIPHIER_PIN_PULL_UP_FIXED ||\n\t\t    pull_dir == UNIPHIER_PIN_PULL_DOWN_FIXED) {\n\t\t\tdev_err(pctldev->dev,\n\t\t\t\t\"can not disable pull register for pin %s\\n\",\n\t\t\t\tdesc->name);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tval = 0;\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\tif (pull_dir == UNIPHIER_PIN_PULL_UP_FIXED && arg != 0)\n\t\t\treturn 0;\n\t\tif (pull_dir != UNIPHIER_PIN_PULL_UP) {\n\t\t\tdev_err(pctldev->dev,\n\t\t\t\t\"pull-up is unsupported for pin %s\\n\",\n\t\t\t\tdesc->name);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (arg == 0) {\n\t\t\tdev_err(pctldev->dev, \"pull-up can not be total\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\tif (pull_dir == UNIPHIER_PIN_PULL_DOWN_FIXED && arg != 0)\n\t\t\treturn 0;\n\t\tif (pull_dir != UNIPHIER_PIN_PULL_DOWN) {\n\t\t\tdev_err(pctldev->dev,\n\t\t\t\t\"pull-down is unsupported for pin %s\\n\",\n\t\t\t\tdesc->name);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (arg == 0) {\n\t\t\tdev_err(pctldev->dev, \"pull-down can not be total\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_PULL_PIN_DEFAULT:\n\t\tif (pull_dir == UNIPHIER_PIN_PULL_NONE) {\n\t\t\tdev_err(pctldev->dev,\n\t\t\t\t\"pull-up/down is unsupported for pin %s\\n\",\n\t\t\t\tdesc->name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (arg == 0)\n\t\t\treturn 0;  \n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tpupdctrl = uniphier_pin_get_pupdctrl(desc->drv_data);\n\n\treg = UNIPHIER_PINCTRL_PUPDCTRL_BASE + pupdctrl / 32 * 4;\n\tshift = pupdctrl % 32;\n\n\treturn regmap_update_bits(priv->regmap, reg, 1 << shift, val << shift);\n}\n\nstatic int uniphier_conf_pin_drive_set(struct pinctrl_dev *pctldev,\n\t\t\t\t       unsigned int pin, u32 strength)\n{\n\tstruct uniphier_pinctrl_priv *priv = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct pin_desc *desc = pin_desc_get(pctldev, pin);\n\tunsigned int reg, shift, mask, val;\n\tconst unsigned int *strengths;\n\tint ret;\n\n\tret = uniphier_conf_get_drvctrl_data(pctldev, pin, &reg, &shift,\n\t\t\t\t\t     &mask, &strengths);\n\tif (ret) {\n\t\tdev_err(pctldev->dev, \"cannot set drive strength for pin %s\\n\",\n\t\t\tdesc->name);\n\t\treturn ret;\n\t}\n\n\tfor (val = 0; val <= mask; val++) {\n\t\tif (strengths[val] > strength)\n\t\t\tbreak;\n\t}\n\n\tif (val == 0) {\n\t\tdev_err(pctldev->dev,\n\t\t\t\"unsupported drive strength %u mA for pin %s\\n\",\n\t\t\tstrength, desc->name);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!mask)\n\t\treturn 0;\n\n\tval--;\n\n\treturn regmap_update_bits(priv->regmap, reg,\n\t\t\t\t  mask << shift, val << shift);\n}\n\nstatic int uniphier_conf_pin_input_enable(struct pinctrl_dev *pctldev,\n\t\t\t\t\t  unsigned int pin, u32 enable)\n{\n\tstruct uniphier_pinctrl_priv *priv = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct pin_desc *desc = pin_desc_get(pctldev, pin);\n\tunsigned int iectrl = uniphier_pin_get_iectrl(desc->drv_data);\n\tunsigned int reg, mask;\n\n\t \n\tif (!(priv->socdata->caps & UNIPHIER_PINCTRL_CAPS_PERPIN_IECTRL) &&\n\t    !enable)\n\t\treturn -EINVAL;\n\n\t \n\tif (iectrl == UNIPHIER_PIN_IECTRL_NONE)\n\t\treturn enable ? 0 : -EINVAL;\n\n\tif (priv->socdata->caps & UNIPHIER_PINCTRL_CAPS_PERPIN_IECTRL)\n\t\tiectrl = pin;\n\n\treg = UNIPHIER_PINCTRL_IECTRL_BASE + iectrl / 32 * 4;\n\tmask = BIT(iectrl % 32);\n\n\treturn regmap_update_bits(priv->regmap, reg, mask, enable ? mask : 0);\n}\n\nstatic int uniphier_conf_pin_config_set(struct pinctrl_dev *pctldev,\n\t\t\t\t\tunsigned pin,\n\t\t\t\t\tunsigned long *configs,\n\t\t\t\t\tunsigned num_configs)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < num_configs; i++) {\n\t\tenum pin_config_param param =\n\t\t\t\t\tpinconf_to_config_param(configs[i]);\n\t\tu32 arg = pinconf_to_config_argument(configs[i]);\n\n\t\tswitch (param) {\n\t\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\tcase PIN_CONFIG_BIAS_PULL_PIN_DEFAULT:\n\t\t\tret = uniphier_conf_pin_bias_set(pctldev, pin,\n\t\t\t\t\t\t\t param, arg);\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_DRIVE_STRENGTH:\n\t\t\tret = uniphier_conf_pin_drive_set(pctldev, pin, arg);\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_INPUT_ENABLE:\n\t\t\tret = uniphier_conf_pin_input_enable(pctldev, pin, arg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(pctldev->dev,\n\t\t\t\t\"unsupported configuration parameter %u\\n\",\n\t\t\t\tparam);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int uniphier_conf_pin_config_group_set(struct pinctrl_dev *pctldev,\n\t\t\t\t\t      unsigned selector,\n\t\t\t\t\t      unsigned long *configs,\n\t\t\t\t\t      unsigned num_configs)\n{\n\tstruct uniphier_pinctrl_priv *priv = pinctrl_dev_get_drvdata(pctldev);\n\tconst unsigned *pins = priv->socdata->groups[selector].pins;\n\tunsigned num_pins = priv->socdata->groups[selector].num_pins;\n\tint i, ret;\n\n\tfor (i = 0; i < num_pins; i++) {\n\t\tret = uniphier_conf_pin_config_set(pctldev, pins[i],\n\t\t\t\t\t\t   configs, num_configs);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct pinconf_ops uniphier_confops = {\n\t.is_generic = true,\n\t.pin_config_get = uniphier_conf_pin_config_get,\n\t.pin_config_set = uniphier_conf_pin_config_set,\n\t.pin_config_group_set = uniphier_conf_pin_config_group_set,\n};\n\nstatic int uniphier_pmx_get_functions_count(struct pinctrl_dev *pctldev)\n{\n\tstruct uniphier_pinctrl_priv *priv = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn priv->socdata->functions_count;\n}\n\nstatic const char *uniphier_pmx_get_function_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t\t  unsigned selector)\n{\n\tstruct uniphier_pinctrl_priv *priv = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn priv->socdata->functions[selector].name;\n}\n\nstatic int uniphier_pmx_get_function_groups(struct pinctrl_dev *pctldev,\n\t\t\t\t\t    unsigned selector,\n\t\t\t\t\t    const char * const **groups,\n\t\t\t\t\t    unsigned *num_groups)\n{\n\tstruct uniphier_pinctrl_priv *priv = pinctrl_dev_get_drvdata(pctldev);\n\n\t*groups = priv->socdata->functions[selector].groups;\n\t*num_groups = priv->socdata->functions[selector].num_groups;\n\n\treturn 0;\n}\n\nstatic int uniphier_pmx_set_one_mux(struct pinctrl_dev *pctldev, unsigned pin,\n\t\t\t\t    int muxval)\n{\n\tstruct uniphier_pinctrl_priv *priv = pinctrl_dev_get_drvdata(pctldev);\n\tunsigned int mux_bits, reg_stride, reg, reg_end, shift, mask;\n\tbool load_pinctrl;\n\tint ret;\n\n\t \n\tret = uniphier_conf_pin_input_enable(pctldev, pin, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tif (muxval < 0)\n\t\treturn 0;\t \n\n\tif (priv->socdata->caps & UNIPHIER_PINCTRL_CAPS_DBGMUX_SEPARATE) {\n\t\t \n\t\tmux_bits = 4;\n\t\treg_stride = 8;\n\t\tload_pinctrl = true;\n\t} else {\n\t\t \n\t\tmux_bits = 8;\n\t\treg_stride = 4;\n\t\tload_pinctrl = false;\n\t}\n\n\treg = UNIPHIER_PINCTRL_PINMUX_BASE + pin * mux_bits / 32 * reg_stride;\n\treg_end = reg + reg_stride;\n\tshift = pin * mux_bits % 32;\n\tmask = (1U << mux_bits) - 1;\n\n\t \n\tfor (; reg < reg_end; reg += 4) {\n\t\tret = regmap_update_bits(priv->regmap, reg,\n\t\t\t\t\t mask << shift, muxval << shift);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tmuxval >>= mux_bits;\n\t}\n\n\tif (load_pinctrl) {\n\t\tret = regmap_write(priv->regmap,\n\t\t\t\t   UNIPHIER_PINCTRL_LOAD_PINMUX, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int uniphier_pmx_set_mux(struct pinctrl_dev *pctldev,\n\t\t\t\tunsigned func_selector,\n\t\t\t\tunsigned group_selector)\n{\n\tstruct uniphier_pinctrl_priv *priv = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct uniphier_pinctrl_group *grp =\n\t\t\t\t\t&priv->socdata->groups[group_selector];\n\tint i;\n\tint ret;\n\n\tfor (i = 0; i < grp->num_pins; i++) {\n\t\tret = uniphier_pmx_set_one_mux(pctldev, grp->pins[i],\n\t\t\t\t\t       grp->muxvals[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int uniphier_pmx_gpio_request_enable(struct pinctrl_dev *pctldev,\n\t\t\t\t\t    struct pinctrl_gpio_range *range,\n\t\t\t\t\t    unsigned offset)\n{\n\tstruct uniphier_pinctrl_priv *priv = pinctrl_dev_get_drvdata(pctldev);\n\tunsigned int gpio_offset;\n\tint muxval, i;\n\n\tif (range->pins) {\n\t\tfor (i = 0; i < range->npins; i++)\n\t\t\tif (range->pins[i] == offset)\n\t\t\t\tbreak;\n\n\t\tif (WARN_ON(i == range->npins))\n\t\t\treturn -EINVAL;\n\n\t\tgpio_offset = i;\n\t} else {\n\t\tgpio_offset = offset - range->pin_base;\n\t}\n\n\tgpio_offset += range->id;\n\n\tmuxval = priv->socdata->get_gpio_muxval(offset, gpio_offset);\n\n\treturn uniphier_pmx_set_one_mux(pctldev, offset, muxval);\n}\n\nstatic const struct pinmux_ops uniphier_pmxops = {\n\t.get_functions_count = uniphier_pmx_get_functions_count,\n\t.get_function_name = uniphier_pmx_get_function_name,\n\t.get_function_groups = uniphier_pmx_get_function_groups,\n\t.set_mux = uniphier_pmx_set_mux,\n\t.gpio_request_enable = uniphier_pmx_gpio_request_enable,\n\t.strict = true,\n};\n\n#ifdef CONFIG_PM_SLEEP\nstatic int uniphier_pinctrl_suspend(struct device *dev)\n{\n\tstruct uniphier_pinctrl_priv *priv = dev_get_drvdata(dev);\n\tstruct uniphier_pinctrl_reg_region *r;\n\tint ret;\n\n\tlist_for_each_entry(r, &priv->reg_regions, node) {\n\t\tret = regmap_bulk_read(priv->regmap, r->base, r->vals,\n\t\t\t\t       r->nregs);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int uniphier_pinctrl_resume(struct device *dev)\n{\n\tstruct uniphier_pinctrl_priv *priv = dev_get_drvdata(dev);\n\tstruct uniphier_pinctrl_reg_region *r;\n\tint ret;\n\n\tlist_for_each_entry(r, &priv->reg_regions, node) {\n\t\tret = regmap_bulk_write(priv->regmap, r->base, r->vals,\n\t\t\t\t\tr->nregs);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (priv->socdata->caps & UNIPHIER_PINCTRL_CAPS_DBGMUX_SEPARATE) {\n\t\tret = regmap_write(priv->regmap,\n\t\t\t\t   UNIPHIER_PINCTRL_LOAD_PINMUX, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int uniphier_pinctrl_add_reg_region(struct device *dev,\n\t\t\t\t\t   struct uniphier_pinctrl_priv *priv,\n\t\t\t\t\t   unsigned int base,\n\t\t\t\t\t   unsigned int count,\n\t\t\t\t\t   unsigned int width)\n{\n\tstruct uniphier_pinctrl_reg_region *region;\n\tunsigned int nregs;\n\n\tif (!count)\n\t\treturn 0;\n\n\tnregs = DIV_ROUND_UP(count * width, 32);\n\n\tregion = devm_kzalloc(dev, struct_size(region, vals, nregs),\n\t\t\t      GFP_KERNEL);\n\tif (!region)\n\t\treturn -ENOMEM;\n\n\tregion->base = base;\n\tregion->nregs = nregs;\n\n\tlist_add_tail(&region->node, &priv->reg_regions);\n\n\treturn 0;\n}\n#endif\n\nstatic int uniphier_pinctrl_pm_init(struct device *dev,\n\t\t\t\t    struct uniphier_pinctrl_priv *priv)\n{\n#ifdef CONFIG_PM_SLEEP\n\tconst struct uniphier_pinctrl_socdata *socdata = priv->socdata;\n\tunsigned int num_drvctrl = 0;\n\tunsigned int num_drv2ctrl = 0;\n\tunsigned int num_drv3ctrl = 0;\n\tunsigned int num_pupdctrl = 0;\n\tunsigned int num_iectrl = 0;\n\tunsigned int iectrl, drvctrl, pupdctrl;\n\tenum uniphier_pin_drv_type drv_type;\n\tenum uniphier_pin_pull_dir pull_dir;\n\tint i, ret;\n\n\tfor (i = 0; i < socdata->npins; i++) {\n\t\tvoid *drv_data = socdata->pins[i].drv_data;\n\n\t\tdrvctrl = uniphier_pin_get_drvctrl(drv_data);\n\t\tdrv_type = uniphier_pin_get_drv_type(drv_data);\n\t\tpupdctrl = uniphier_pin_get_pupdctrl(drv_data);\n\t\tpull_dir = uniphier_pin_get_pull_dir(drv_data);\n\t\tiectrl = uniphier_pin_get_iectrl(drv_data);\n\n\t\tswitch (drv_type) {\n\t\tcase UNIPHIER_PIN_DRV_1BIT:\n\t\t\tnum_drvctrl = max(num_drvctrl, drvctrl + 1);\n\t\t\tbreak;\n\t\tcase UNIPHIER_PIN_DRV_2BIT:\n\t\t\tnum_drv2ctrl = max(num_drv2ctrl, drvctrl + 1);\n\t\t\tbreak;\n\t\tcase UNIPHIER_PIN_DRV_3BIT:\n\t\t\tnum_drv3ctrl = max(num_drv3ctrl, drvctrl + 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (pull_dir == UNIPHIER_PIN_PULL_UP ||\n\t\t    pull_dir == UNIPHIER_PIN_PULL_DOWN)\n\t\t\tnum_pupdctrl = max(num_pupdctrl, pupdctrl + 1);\n\n\t\tif (iectrl != UNIPHIER_PIN_IECTRL_NONE) {\n\t\t\tif (socdata->caps & UNIPHIER_PINCTRL_CAPS_PERPIN_IECTRL)\n\t\t\t\tiectrl = i;\n\t\t\tnum_iectrl = max(num_iectrl, iectrl + 1);\n\t\t}\n\t}\n\n\tINIT_LIST_HEAD(&priv->reg_regions);\n\n\tret = uniphier_pinctrl_add_reg_region(dev, priv,\n\t\t\t\t\t      UNIPHIER_PINCTRL_PINMUX_BASE,\n\t\t\t\t\t      socdata->npins, 8);\n\tif (ret)\n\t\treturn ret;\n\n\tret = uniphier_pinctrl_add_reg_region(dev, priv,\n\t\t\t\t\t      UNIPHIER_PINCTRL_DRVCTRL_BASE,\n\t\t\t\t\t      num_drvctrl, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = uniphier_pinctrl_add_reg_region(dev, priv,\n\t\t\t\t\t      UNIPHIER_PINCTRL_DRV2CTRL_BASE,\n\t\t\t\t\t      num_drv2ctrl, 2);\n\tif (ret)\n\t\treturn ret;\n\n\tret = uniphier_pinctrl_add_reg_region(dev, priv,\n\t\t\t\t\t      UNIPHIER_PINCTRL_DRV3CTRL_BASE,\n\t\t\t\t\t      num_drv3ctrl, 3);\n\tif (ret)\n\t\treturn ret;\n\n\tret = uniphier_pinctrl_add_reg_region(dev, priv,\n\t\t\t\t\t      UNIPHIER_PINCTRL_PUPDCTRL_BASE,\n\t\t\t\t\t      num_pupdctrl, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = uniphier_pinctrl_add_reg_region(dev, priv,\n\t\t\t\t\t      UNIPHIER_PINCTRL_IECTRL_BASE,\n\t\t\t\t\t      num_iectrl, 1);\n\tif (ret)\n\t\treturn ret;\n#endif\n\treturn 0;\n}\n\nconst struct dev_pm_ops uniphier_pinctrl_pm_ops = {\n\tSET_LATE_SYSTEM_SLEEP_PM_OPS(uniphier_pinctrl_suspend,\n\t\t\t\t     uniphier_pinctrl_resume)\n};\n\nint uniphier_pinctrl_probe(struct platform_device *pdev,\n\t\t\t   const struct uniphier_pinctrl_socdata *socdata)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct uniphier_pinctrl_priv *priv;\n\tstruct device_node *parent;\n\tint ret;\n\n\tif (!socdata ||\n\t    !socdata->pins || !socdata->npins ||\n\t    !socdata->groups || !socdata->groups_count ||\n\t    !socdata->functions || !socdata->functions_count) {\n\t\tdev_err(dev, \"pinctrl socdata lacks necessary members\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tparent = of_get_parent(dev->of_node);\n\tpriv->regmap = syscon_node_to_regmap(parent);\n\tof_node_put(parent);\n\n\tif (IS_ERR(priv->regmap)) {\n\t\tdev_err(dev, \"failed to get regmap\\n\");\n\t\treturn PTR_ERR(priv->regmap);\n\t}\n\n\tpriv->socdata = socdata;\n\tpriv->pctldesc.name = dev->driver->name;\n\tpriv->pctldesc.pins = socdata->pins;\n\tpriv->pctldesc.npins = socdata->npins;\n\tpriv->pctldesc.pctlops = &uniphier_pctlops;\n\tpriv->pctldesc.pmxops = &uniphier_pmxops;\n\tpriv->pctldesc.confops = &uniphier_confops;\n\tpriv->pctldesc.owner = dev->driver->owner;\n\n\tret = uniphier_pinctrl_pm_init(dev, priv);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->pctldev = devm_pinctrl_register(dev, &priv->pctldesc, priv);\n\tif (IS_ERR(priv->pctldev)) {\n\t\tdev_err(dev, \"failed to register UniPhier pinctrl driver\\n\");\n\t\treturn PTR_ERR(priv->pctldev);\n\t}\n\n\tplatform_set_drvdata(pdev, priv);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}