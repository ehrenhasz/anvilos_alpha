{
  "module_name": "pinmux.c",
  "hash_id": "de5774aa153279be3b5e46b6932b61eb2f965ba2427780486f4cde0ac3f7c360",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/pinmux.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) \"pinmux core: \" fmt\n\n#include <linux/ctype.h>\n#include <linux/debugfs.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/radix-tree.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\n#include <linux/pinctrl/machine.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinmux.h>\n\n#include \"core.h\"\n#include \"pinmux.h\"\n\nint pinmux_check_ops(struct pinctrl_dev *pctldev)\n{\n\tconst struct pinmux_ops *ops = pctldev->desc->pmxops;\n\tunsigned nfuncs;\n\tunsigned selector = 0;\n\n\t \n\tif (!ops ||\n\t    !ops->get_functions_count ||\n\t    !ops->get_function_name ||\n\t    !ops->get_function_groups ||\n\t    !ops->set_mux) {\n\t\tdev_err(pctldev->dev, \"pinmux ops lacks necessary functions\\n\");\n\t\treturn -EINVAL;\n\t}\n\t \n\tnfuncs = ops->get_functions_count(pctldev);\n\twhile (selector < nfuncs) {\n\t\tconst char *fname = ops->get_function_name(pctldev,\n\t\t\t\t\t\t\t   selector);\n\t\tif (!fname) {\n\t\t\tdev_err(pctldev->dev, \"pinmux ops has no name for function%u\\n\",\n\t\t\t\tselector);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tselector++;\n\t}\n\n\treturn 0;\n}\n\nint pinmux_validate_map(const struct pinctrl_map *map, int i)\n{\n\tif (!map->data.mux.function) {\n\t\tpr_err(\"failed to register map %s (%d): no function given\\n\",\n\t\t       map->name, i);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nbool pinmux_can_be_used_for_gpio(struct pinctrl_dev *pctldev, unsigned pin)\n{\n\tstruct pin_desc *desc = pin_desc_get(pctldev, pin);\n\tconst struct pinmux_ops *ops = pctldev->desc->pmxops;\n\n\t \n\tif (!desc || !ops)\n\t\treturn true;\n\n\tif (ops->strict && desc->mux_usecount)\n\t\treturn false;\n\n\treturn !(ops->strict && !!desc->gpio_owner);\n}\n\n \nstatic int pin_request(struct pinctrl_dev *pctldev,\n\t\t       int pin, const char *owner,\n\t\t       struct pinctrl_gpio_range *gpio_range)\n{\n\tstruct pin_desc *desc;\n\tconst struct pinmux_ops *ops = pctldev->desc->pmxops;\n\tint status = -EINVAL;\n\n\tdesc = pin_desc_get(pctldev, pin);\n\tif (desc == NULL) {\n\t\tdev_err(pctldev->dev,\n\t\t\t\"pin %d is not registered so it cannot be requested\\n\",\n\t\t\tpin);\n\t\tgoto out;\n\t}\n\n\tdev_dbg(pctldev->dev, \"request pin %d (%s) for %s\\n\",\n\t\tpin, desc->name, owner);\n\n\tif ((!gpio_range || ops->strict) &&\n\t    desc->mux_usecount && strcmp(desc->mux_owner, owner)) {\n\t\tdev_err(pctldev->dev,\n\t\t\t\"pin %s already requested by %s; cannot claim for %s\\n\",\n\t\t\tdesc->name, desc->mux_owner, owner);\n\t\tgoto out;\n\t}\n\n\tif ((gpio_range || ops->strict) && desc->gpio_owner) {\n\t\tdev_err(pctldev->dev,\n\t\t\t\"pin %s already requested by %s; cannot claim for %s\\n\",\n\t\t\tdesc->name, desc->gpio_owner, owner);\n\t\tgoto out;\n\t}\n\n\tif (gpio_range) {\n\t\tdesc->gpio_owner = owner;\n\t} else {\n\t\tdesc->mux_usecount++;\n\t\tif (desc->mux_usecount > 1)\n\t\t\treturn 0;\n\n\t\tdesc->mux_owner = owner;\n\t}\n\n\t \n\tif (!try_module_get(pctldev->owner)) {\n\t\tdev_err(pctldev->dev,\n\t\t\t\"could not increase module refcount for pin %d\\n\",\n\t\t\tpin);\n\t\tstatus = -EINVAL;\n\t\tgoto out_free_pin;\n\t}\n\n\t \n\tif (gpio_range && ops->gpio_request_enable)\n\t\t \n\t\tstatus = ops->gpio_request_enable(pctldev, gpio_range, pin);\n\telse if (ops->request)\n\t\tstatus = ops->request(pctldev, pin);\n\telse\n\t\tstatus = 0;\n\n\tif (status) {\n\t\tdev_err(pctldev->dev, \"request() failed for pin %d\\n\", pin);\n\t\tmodule_put(pctldev->owner);\n\t}\n\nout_free_pin:\n\tif (status) {\n\t\tif (gpio_range) {\n\t\t\tdesc->gpio_owner = NULL;\n\t\t} else {\n\t\t\tdesc->mux_usecount--;\n\t\t\tif (!desc->mux_usecount)\n\t\t\t\tdesc->mux_owner = NULL;\n\t\t}\n\t}\nout:\n\tif (status)\n\t\tdev_err(pctldev->dev, \"pin-%d (%s) status %d\\n\",\n\t\t\tpin, owner, status);\n\n\treturn status;\n}\n\n \nstatic const char *pin_free(struct pinctrl_dev *pctldev, int pin,\n\t\t\t    struct pinctrl_gpio_range *gpio_range)\n{\n\tconst struct pinmux_ops *ops = pctldev->desc->pmxops;\n\tstruct pin_desc *desc;\n\tconst char *owner;\n\n\tdesc = pin_desc_get(pctldev, pin);\n\tif (desc == NULL) {\n\t\tdev_err(pctldev->dev,\n\t\t\t\"pin is not registered so it cannot be freed\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (!gpio_range) {\n\t\t \n\t\tif (WARN_ON(!desc->mux_usecount))\n\t\t\treturn NULL;\n\t\tdesc->mux_usecount--;\n\t\tif (desc->mux_usecount)\n\t\t\treturn NULL;\n\t}\n\n\t \n\tif (gpio_range && ops->gpio_disable_free)\n\t\tops->gpio_disable_free(pctldev, gpio_range, pin);\n\telse if (ops->free)\n\t\tops->free(pctldev, pin);\n\n\tif (gpio_range) {\n\t\towner = desc->gpio_owner;\n\t\tdesc->gpio_owner = NULL;\n\t} else {\n\t\towner = desc->mux_owner;\n\t\tdesc->mux_owner = NULL;\n\t\tdesc->mux_setting = NULL;\n\t}\n\n\tmodule_put(pctldev->owner);\n\n\treturn owner;\n}\n\n \nint pinmux_request_gpio(struct pinctrl_dev *pctldev,\n\t\t\tstruct pinctrl_gpio_range *range,\n\t\t\tunsigned pin, unsigned gpio)\n{\n\tconst char *owner;\n\tint ret;\n\n\t \n\towner = kasprintf(GFP_KERNEL, \"%s:%d\", range->name, gpio);\n\tif (!owner)\n\t\treturn -ENOMEM;\n\n\tret = pin_request(pctldev, pin, owner, range);\n\tif (ret < 0)\n\t\tkfree(owner);\n\n\treturn ret;\n}\n\n \nvoid pinmux_free_gpio(struct pinctrl_dev *pctldev, unsigned pin,\n\t\t      struct pinctrl_gpio_range *range)\n{\n\tconst char *owner;\n\n\towner = pin_free(pctldev, pin, range);\n\tkfree(owner);\n}\n\n \nint pinmux_gpio_direction(struct pinctrl_dev *pctldev,\n\t\t\t  struct pinctrl_gpio_range *range,\n\t\t\t  unsigned pin, bool input)\n{\n\tconst struct pinmux_ops *ops;\n\tint ret;\n\n\tops = pctldev->desc->pmxops;\n\n\tif (ops->gpio_set_direction)\n\t\tret = ops->gpio_set_direction(pctldev, range, pin, input);\n\telse\n\t\tret = 0;\n\n\treturn ret;\n}\n\nstatic int pinmux_func_name_to_selector(struct pinctrl_dev *pctldev,\n\t\t\t\t\tconst char *function)\n{\n\tconst struct pinmux_ops *ops = pctldev->desc->pmxops;\n\tunsigned nfuncs = ops->get_functions_count(pctldev);\n\tunsigned selector = 0;\n\n\t \n\twhile (selector < nfuncs) {\n\t\tconst char *fname = ops->get_function_name(pctldev, selector);\n\n\t\tif (!strcmp(function, fname))\n\t\t\treturn selector;\n\n\t\tselector++;\n\t}\n\n\treturn -EINVAL;\n}\n\nint pinmux_map_to_setting(const struct pinctrl_map *map,\n\t\t\t  struct pinctrl_setting *setting)\n{\n\tstruct pinctrl_dev *pctldev = setting->pctldev;\n\tconst struct pinmux_ops *pmxops = pctldev->desc->pmxops;\n\tchar const * const *groups;\n\tunsigned num_groups;\n\tint ret;\n\tconst char *group;\n\n\tif (!pmxops) {\n\t\tdev_err(pctldev->dev, \"does not support mux function\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = pinmux_func_name_to_selector(pctldev, map->data.mux.function);\n\tif (ret < 0) {\n\t\tdev_err(pctldev->dev, \"invalid function %s in map table\\n\",\n\t\t\tmap->data.mux.function);\n\t\treturn ret;\n\t}\n\tsetting->data.mux.func = ret;\n\n\tret = pmxops->get_function_groups(pctldev, setting->data.mux.func,\n\t\t\t\t\t  &groups, &num_groups);\n\tif (ret < 0) {\n\t\tdev_err(pctldev->dev, \"can't query groups for function %s\\n\",\n\t\t\tmap->data.mux.function);\n\t\treturn ret;\n\t}\n\tif (!num_groups) {\n\t\tdev_err(pctldev->dev,\n\t\t\t\"function %s can't be selected on any group\\n\",\n\t\t\tmap->data.mux.function);\n\t\treturn -EINVAL;\n\t}\n\tif (map->data.mux.group) {\n\t\tgroup = map->data.mux.group;\n\t\tret = match_string(groups, num_groups, group);\n\t\tif (ret < 0) {\n\t\t\tdev_err(pctldev->dev,\n\t\t\t\t\"invalid group \\\"%s\\\" for function \\\"%s\\\"\\n\",\n\t\t\t\tgroup, map->data.mux.function);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tgroup = groups[0];\n\t}\n\n\tret = pinctrl_get_group_selector(pctldev, group);\n\tif (ret < 0) {\n\t\tdev_err(pctldev->dev, \"invalid group %s in map table\\n\",\n\t\t\tmap->data.mux.group);\n\t\treturn ret;\n\t}\n\tsetting->data.mux.group = ret;\n\n\treturn 0;\n}\n\nvoid pinmux_free_setting(const struct pinctrl_setting *setting)\n{\n\t \n}\n\nint pinmux_enable_setting(const struct pinctrl_setting *setting)\n{\n\tstruct pinctrl_dev *pctldev = setting->pctldev;\n\tconst struct pinctrl_ops *pctlops = pctldev->desc->pctlops;\n\tconst struct pinmux_ops *ops = pctldev->desc->pmxops;\n\tint ret = 0;\n\tconst unsigned *pins = NULL;\n\tunsigned num_pins = 0;\n\tint i;\n\tstruct pin_desc *desc;\n\n\tif (pctlops->get_group_pins)\n\t\tret = pctlops->get_group_pins(pctldev, setting->data.mux.group,\n\t\t\t\t\t      &pins, &num_pins);\n\n\tif (ret) {\n\t\tconst char *gname;\n\n\t\t \n\t\tgname = pctlops->get_group_name(pctldev,\n\t\t\t\t\t\tsetting->data.mux.group);\n\t\tdev_warn(pctldev->dev,\n\t\t\t \"could not get pins for group %s\\n\",\n\t\t\t gname);\n\t\tnum_pins = 0;\n\t}\n\n\t \n\tfor (i = 0; i < num_pins; i++) {\n\t\tret = pin_request(pctldev, pins[i], setting->dev_name, NULL);\n\t\tif (ret) {\n\t\t\tconst char *gname;\n\t\t\tconst char *pname;\n\n\t\t\tdesc = pin_desc_get(pctldev, pins[i]);\n\t\t\tpname = desc ? desc->name : \"non-existing\";\n\t\t\tgname = pctlops->get_group_name(pctldev,\n\t\t\t\t\t\tsetting->data.mux.group);\n\t\t\tdev_err(pctldev->dev,\n\t\t\t\t\"could not request pin %d (%s) from group %s \"\n\t\t\t\t\" on device %s\\n\",\n\t\t\t\tpins[i], pname, gname,\n\t\t\t\tpinctrl_dev_get_name(pctldev));\n\t\t\tgoto err_pin_request;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < num_pins; i++) {\n\t\tdesc = pin_desc_get(pctldev, pins[i]);\n\t\tif (desc == NULL) {\n\t\t\tdev_warn(pctldev->dev,\n\t\t\t\t \"could not get pin desc for pin %d\\n\",\n\t\t\t\t pins[i]);\n\t\t\tcontinue;\n\t\t}\n\t\tdesc->mux_setting = &(setting->data.mux);\n\t}\n\n\tret = ops->set_mux(pctldev, setting->data.mux.func,\n\t\t\t   setting->data.mux.group);\n\n\tif (ret)\n\t\tgoto err_set_mux;\n\n\treturn 0;\n\nerr_set_mux:\n\tfor (i = 0; i < num_pins; i++) {\n\t\tdesc = pin_desc_get(pctldev, pins[i]);\n\t\tif (desc)\n\t\t\tdesc->mux_setting = NULL;\n\t}\nerr_pin_request:\n\t \n\twhile (--i >= 0)\n\t\tpin_free(pctldev, pins[i], NULL);\n\n\treturn ret;\n}\n\nvoid pinmux_disable_setting(const struct pinctrl_setting *setting)\n{\n\tstruct pinctrl_dev *pctldev = setting->pctldev;\n\tconst struct pinctrl_ops *pctlops = pctldev->desc->pctlops;\n\tint ret = 0;\n\tconst unsigned *pins = NULL;\n\tunsigned num_pins = 0;\n\tint i;\n\tstruct pin_desc *desc;\n\n\tif (pctlops->get_group_pins)\n\t\tret = pctlops->get_group_pins(pctldev, setting->data.mux.group,\n\t\t\t\t\t      &pins, &num_pins);\n\tif (ret) {\n\t\tconst char *gname;\n\n\t\t \n\t\tgname = pctlops->get_group_name(pctldev,\n\t\t\t\t\t\tsetting->data.mux.group);\n\t\tdev_warn(pctldev->dev,\n\t\t\t \"could not get pins for group %s\\n\",\n\t\t\t gname);\n\t\tnum_pins = 0;\n\t}\n\n\t \n\tfor (i = 0; i < num_pins; i++) {\n\t\tdesc = pin_desc_get(pctldev, pins[i]);\n\t\tif (desc == NULL) {\n\t\t\tdev_warn(pctldev->dev,\n\t\t\t\t \"could not get pin desc for pin %d\\n\",\n\t\t\t\t pins[i]);\n\t\t\tcontinue;\n\t\t}\n\t\tif (desc->mux_setting == &(setting->data.mux)) {\n\t\t\tpin_free(pctldev, pins[i], NULL);\n\t\t} else {\n\t\t\tconst char *gname;\n\n\t\t\tgname = pctlops->get_group_name(pctldev,\n\t\t\t\t\t\tsetting->data.mux.group);\n\t\t\tdev_warn(pctldev->dev,\n\t\t\t\t \"not freeing pin %d (%s) as part of \"\n\t\t\t\t \"deactivating group %s - it is already \"\n\t\t\t\t \"used for some other setting\",\n\t\t\t\t pins[i], desc->name, gname);\n\t\t}\n\t}\n}\n\n#ifdef CONFIG_DEBUG_FS\n\n \nstatic int pinmux_functions_show(struct seq_file *s, void *what)\n{\n\tstruct pinctrl_dev *pctldev = s->private;\n\tconst struct pinmux_ops *pmxops = pctldev->desc->pmxops;\n\tunsigned nfuncs;\n\tunsigned func_selector = 0;\n\n\tif (!pmxops)\n\t\treturn 0;\n\n\tmutex_lock(&pctldev->mutex);\n\tnfuncs = pmxops->get_functions_count(pctldev);\n\twhile (func_selector < nfuncs) {\n\t\tconst char *func = pmxops->get_function_name(pctldev,\n\t\t\t\t\t\t\t  func_selector);\n\t\tconst char * const *groups;\n\t\tunsigned num_groups;\n\t\tint ret;\n\t\tint i;\n\n\t\tret = pmxops->get_function_groups(pctldev, func_selector,\n\t\t\t\t\t\t  &groups, &num_groups);\n\t\tif (ret) {\n\t\t\tseq_printf(s, \"function %s: COULD NOT GET GROUPS\\n\",\n\t\t\t\t   func);\n\t\t\tfunc_selector++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tseq_printf(s, \"function %d: %s, groups = [ \", func_selector, func);\n\t\tfor (i = 0; i < num_groups; i++)\n\t\t\tseq_printf(s, \"%s \", groups[i]);\n\t\tseq_puts(s, \"]\\n\");\n\n\t\tfunc_selector++;\n\t}\n\n\tmutex_unlock(&pctldev->mutex);\n\n\treturn 0;\n}\n\nstatic int pinmux_pins_show(struct seq_file *s, void *what)\n{\n\tstruct pinctrl_dev *pctldev = s->private;\n\tconst struct pinctrl_ops *pctlops = pctldev->desc->pctlops;\n\tconst struct pinmux_ops *pmxops = pctldev->desc->pmxops;\n\tunsigned i, pin;\n\n\tif (!pmxops)\n\t\treturn 0;\n\n\tseq_puts(s, \"Pinmux settings per pin\\n\");\n\tif (pmxops->strict)\n\t\tseq_puts(s,\n\t\t \"Format: pin (name): mux_owner|gpio_owner (strict) hog?\\n\");\n\telse\n\t\tseq_puts(s,\n\t\t\"Format: pin (name): mux_owner gpio_owner hog?\\n\");\n\n\tmutex_lock(&pctldev->mutex);\n\n\t \n\tfor (i = 0; i < pctldev->desc->npins; i++) {\n\t\tstruct pin_desc *desc;\n\t\tbool is_hog = false;\n\n\t\tpin = pctldev->desc->pins[i].number;\n\t\tdesc = pin_desc_get(pctldev, pin);\n\t\t \n\t\tif (desc == NULL)\n\t\t\tcontinue;\n\n\t\tif (desc->mux_owner &&\n\t\t    !strcmp(desc->mux_owner, pinctrl_dev_get_name(pctldev)))\n\t\t\tis_hog = true;\n\n\t\tif (pmxops->strict) {\n\t\t\tif (desc->mux_owner)\n\t\t\t\tseq_printf(s, \"pin %d (%s): device %s%s\",\n\t\t\t\t\t   pin, desc->name, desc->mux_owner,\n\t\t\t\t\t   is_hog ? \" (HOG)\" : \"\");\n\t\t\telse if (desc->gpio_owner)\n\t\t\t\tseq_printf(s, \"pin %d (%s): GPIO %s\",\n\t\t\t\t\t   pin, desc->name, desc->gpio_owner);\n\t\t\telse\n\t\t\t\tseq_printf(s, \"pin %d (%s): UNCLAIMED\",\n\t\t\t\t\t   pin, desc->name);\n\t\t} else {\n\t\t\t \n\t\t\tseq_printf(s, \"pin %d (%s): %s %s%s\", pin, desc->name,\n\t\t\t\t   desc->mux_owner ? desc->mux_owner\n\t\t\t\t   : \"(MUX UNCLAIMED)\",\n\t\t\t\t   desc->gpio_owner ? desc->gpio_owner\n\t\t\t\t   : \"(GPIO UNCLAIMED)\",\n\t\t\t\t   is_hog ? \" (HOG)\" : \"\");\n\t\t}\n\n\t\t \n\t\tif (desc->mux_setting)\n\t\t\tseq_printf(s, \" function %s group %s\\n\",\n\t\t\t\t   pmxops->get_function_name(pctldev,\n\t\t\t\t\tdesc->mux_setting->func),\n\t\t\t\t   pctlops->get_group_name(pctldev,\n\t\t\t\t\tdesc->mux_setting->group));\n\t\telse\n\t\t\tseq_putc(s, '\\n');\n\t}\n\n\tmutex_unlock(&pctldev->mutex);\n\n\treturn 0;\n}\n\nvoid pinmux_show_map(struct seq_file *s, const struct pinctrl_map *map)\n{\n\tseq_printf(s, \"group %s\\nfunction %s\\n\",\n\t\tmap->data.mux.group ? map->data.mux.group : \"(default)\",\n\t\tmap->data.mux.function);\n}\n\nvoid pinmux_show_setting(struct seq_file *s,\n\t\t\t const struct pinctrl_setting *setting)\n{\n\tstruct pinctrl_dev *pctldev = setting->pctldev;\n\tconst struct pinmux_ops *pmxops = pctldev->desc->pmxops;\n\tconst struct pinctrl_ops *pctlops = pctldev->desc->pctlops;\n\n\tseq_printf(s, \"group: %s (%u) function: %s (%u)\\n\",\n\t\t   pctlops->get_group_name(pctldev, setting->data.mux.group),\n\t\t   setting->data.mux.group,\n\t\t   pmxops->get_function_name(pctldev, setting->data.mux.func),\n\t\t   setting->data.mux.func);\n}\n\nDEFINE_SHOW_ATTRIBUTE(pinmux_functions);\nDEFINE_SHOW_ATTRIBUTE(pinmux_pins);\n\nstatic ssize_t pinmux_select(struct file *file, const char __user *user_buf,\n\t\t\t\t   size_t len, loff_t *ppos)\n{\n\tstruct seq_file *sfile = file->private_data;\n\tstruct pinctrl_dev *pctldev = sfile->private;\n\tconst struct pinmux_ops *pmxops = pctldev->desc->pmxops;\n\tconst char *const *groups;\n\tchar *buf, *gname, *fname;\n\tunsigned int num_groups;\n\tint fsel, gsel, ret;\n\n\tbuf = memdup_user_nul(user_buf, len);\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\t \n\tgname = strstrip(buf);\n\tif (*gname == '\\0') {\n\t\tret = -EINVAL;\n\t\tgoto exit_free_buf;\n\t}\n\n\t \n\tfor (fname = gname; !isspace(*fname); fname++) {\n\t\tif (*fname == '\\0') {\n\t\t\tret = -EINVAL;\n\t\t\tgoto exit_free_buf;\n\t\t}\n\t}\n\t*fname = '\\0';\n\n\t \n\tfname = skip_spaces(fname + 1);\n\tif (*fname == '\\0') {\n\t\tret = -EINVAL;\n\t\tgoto exit_free_buf;\n\t}\n\n\tret = pinmux_func_name_to_selector(pctldev, fname);\n\tif (ret < 0) {\n\t\tdev_err(pctldev->dev, \"invalid function %s in map table\\n\", fname);\n\t\tgoto exit_free_buf;\n\t}\n\tfsel = ret;\n\n\tret = pmxops->get_function_groups(pctldev, fsel, &groups, &num_groups);\n\tif (ret) {\n\t\tdev_err(pctldev->dev, \"no groups for function %d (%s)\", fsel, fname);\n\t\tgoto exit_free_buf;\n\t}\n\n\tret = match_string(groups, num_groups, gname);\n\tif (ret < 0) {\n\t\tdev_err(pctldev->dev, \"invalid group %s\", gname);\n\t\tgoto exit_free_buf;\n\t}\n\n\tret = pinctrl_get_group_selector(pctldev, gname);\n\tif (ret < 0)\n\t\tgoto exit_free_buf;\n\tgsel = ret;\n\n\tret = pmxops->set_mux(pctldev, fsel, gsel);\n\tif (ret) {\n\t\tdev_err(pctldev->dev, \"set_mux() failed: %d\", ret);\n\t\tgoto exit_free_buf;\n\t}\n\tret = len;\n\nexit_free_buf:\n\tkfree(buf);\n\n\treturn ret;\n}\n\nstatic int pinmux_select_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, NULL, inode->i_private);\n}\n\nstatic const struct file_operations pinmux_select_ops = {\n\t.owner = THIS_MODULE,\n\t.open = pinmux_select_open,\n\t.write = pinmux_select,\n\t.llseek = no_llseek,\n\t.release = single_release,\n};\n\nvoid pinmux_init_device_debugfs(struct dentry *devroot,\n\t\t\t struct pinctrl_dev *pctldev)\n{\n\tdebugfs_create_file(\"pinmux-functions\", 0444,\n\t\t\t    devroot, pctldev, &pinmux_functions_fops);\n\tdebugfs_create_file(\"pinmux-pins\", 0444,\n\t\t\t    devroot, pctldev, &pinmux_pins_fops);\n\tdebugfs_create_file(\"pinmux-select\", 0200,\n\t\t\t    devroot, pctldev, &pinmux_select_ops);\n}\n\n#endif  \n\n#ifdef CONFIG_GENERIC_PINMUX_FUNCTIONS\n\n \nint pinmux_generic_get_function_count(struct pinctrl_dev *pctldev)\n{\n\treturn pctldev->num_functions;\n}\nEXPORT_SYMBOL_GPL(pinmux_generic_get_function_count);\n\n \nconst char *\npinmux_generic_get_function_name(struct pinctrl_dev *pctldev,\n\t\t\t\t unsigned int selector)\n{\n\tstruct function_desc *function;\n\n\tfunction = radix_tree_lookup(&pctldev->pin_function_tree,\n\t\t\t\t     selector);\n\tif (!function)\n\t\treturn NULL;\n\n\treturn function->name;\n}\nEXPORT_SYMBOL_GPL(pinmux_generic_get_function_name);\n\n \nint pinmux_generic_get_function_groups(struct pinctrl_dev *pctldev,\n\t\t\t\t       unsigned int selector,\n\t\t\t\t       const char * const **groups,\n\t\t\t\t       unsigned * const num_groups)\n{\n\tstruct function_desc *function;\n\n\tfunction = radix_tree_lookup(&pctldev->pin_function_tree,\n\t\t\t\t     selector);\n\tif (!function) {\n\t\tdev_err(pctldev->dev, \"%s could not find function%i\\n\",\n\t\t\t__func__, selector);\n\t\treturn -EINVAL;\n\t}\n\t*groups = function->group_names;\n\t*num_groups = function->num_group_names;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(pinmux_generic_get_function_groups);\n\n \nstruct function_desc *pinmux_generic_get_function(struct pinctrl_dev *pctldev,\n\t\t\t\t\t\t  unsigned int selector)\n{\n\tstruct function_desc *function;\n\n\tfunction = radix_tree_lookup(&pctldev->pin_function_tree,\n\t\t\t\t     selector);\n\tif (!function)\n\t\treturn NULL;\n\n\treturn function;\n}\nEXPORT_SYMBOL_GPL(pinmux_generic_get_function);\n\n \nint pinmux_generic_add_function(struct pinctrl_dev *pctldev,\n\t\t\t\tconst char *name,\n\t\t\t\tconst char * const *groups,\n\t\t\t\tconst unsigned int num_groups,\n\t\t\t\tvoid *data)\n{\n\tstruct function_desc *function;\n\tint selector, error;\n\n\tif (!name)\n\t\treturn -EINVAL;\n\n\tselector = pinmux_func_name_to_selector(pctldev, name);\n\tif (selector >= 0)\n\t\treturn selector;\n\n\tselector = pctldev->num_functions;\n\n\tfunction = devm_kzalloc(pctldev->dev, sizeof(*function), GFP_KERNEL);\n\tif (!function)\n\t\treturn -ENOMEM;\n\n\tfunction->name = name;\n\tfunction->group_names = groups;\n\tfunction->num_group_names = num_groups;\n\tfunction->data = data;\n\n\terror = radix_tree_insert(&pctldev->pin_function_tree, selector, function);\n\tif (error)\n\t\treturn error;\n\n\tpctldev->num_functions++;\n\n\treturn selector;\n}\nEXPORT_SYMBOL_GPL(pinmux_generic_add_function);\n\n \nint pinmux_generic_remove_function(struct pinctrl_dev *pctldev,\n\t\t\t\t   unsigned int selector)\n{\n\tstruct function_desc *function;\n\n\tfunction = radix_tree_lookup(&pctldev->pin_function_tree,\n\t\t\t\t     selector);\n\tif (!function)\n\t\treturn -ENOENT;\n\n\tradix_tree_delete(&pctldev->pin_function_tree, selector);\n\tdevm_kfree(pctldev->dev, function);\n\n\tpctldev->num_functions--;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(pinmux_generic_remove_function);\n\n \nvoid pinmux_generic_free_functions(struct pinctrl_dev *pctldev)\n{\n\tstruct radix_tree_iter iter;\n\tvoid __rcu **slot;\n\n\tradix_tree_for_each_slot(slot, &pctldev->pin_function_tree, &iter, 0)\n\t\tradix_tree_delete(&pctldev->pin_function_tree, iter.index);\n\n\tpctldev->num_functions = 0;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}