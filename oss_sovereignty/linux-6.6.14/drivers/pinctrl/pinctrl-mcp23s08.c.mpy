{
  "module_name": "pinctrl-mcp23s08.c",
  "hash_id": "7d7fd430884cb07b6eccfd7cb1ba49a3cdc8217c18331ad49c35bab19dc73f79",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/pinctrl-mcp23s08.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/mutex.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/export.h>\n#include <linux/gpio/driver.h>\n#include <linux/gpio/consumer.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <asm/byteorder.h>\n#include <linux/interrupt.h>\n#include <linux/regmap.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinconf-generic.h>\n\n#include \"pinctrl-mcp23s08.h\"\n\n \n#define MCP_IODIR\t0x00\t\t \n#define MCP_IPOL\t0x01\n#define MCP_GPINTEN\t0x02\n#define MCP_DEFVAL\t0x03\n#define MCP_INTCON\t0x04\n#define MCP_IOCON\t0x05\n#\tdefine IOCON_MIRROR\t(1 << 6)\n#\tdefine IOCON_SEQOP\t(1 << 5)\n#\tdefine IOCON_HAEN\t(1 << 3)\n#\tdefine IOCON_ODR\t(1 << 2)\n#\tdefine IOCON_INTPOL\t(1 << 1)\n#\tdefine IOCON_INTCC\t(1)\n#define MCP_GPPU\t0x06\n#define MCP_INTF\t0x07\n#define MCP_INTCAP\t0x08\n#define MCP_GPIO\t0x09\n#define MCP_OLAT\t0x0a\n\nstatic const struct reg_default mcp23x08_defaults[] = {\n\t{.reg = MCP_IODIR,\t\t.def = 0xff},\n\t{.reg = MCP_IPOL,\t\t.def = 0x00},\n\t{.reg = MCP_GPINTEN,\t\t.def = 0x00},\n\t{.reg = MCP_DEFVAL,\t\t.def = 0x00},\n\t{.reg = MCP_INTCON,\t\t.def = 0x00},\n\t{.reg = MCP_IOCON,\t\t.def = 0x00},\n\t{.reg = MCP_GPPU,\t\t.def = 0x00},\n\t{.reg = MCP_OLAT,\t\t.def = 0x00},\n};\n\nstatic const struct regmap_range mcp23x08_volatile_range = {\n\t.range_min = MCP_INTF,\n\t.range_max = MCP_GPIO,\n};\n\nstatic const struct regmap_access_table mcp23x08_volatile_table = {\n\t.yes_ranges = &mcp23x08_volatile_range,\n\t.n_yes_ranges = 1,\n};\n\nstatic const struct regmap_range mcp23x08_precious_range = {\n\t.range_min = MCP_GPIO,\n\t.range_max = MCP_GPIO,\n};\n\nstatic const struct regmap_access_table mcp23x08_precious_table = {\n\t.yes_ranges = &mcp23x08_precious_range,\n\t.n_yes_ranges = 1,\n};\n\nconst struct regmap_config mcp23x08_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.reg_stride = 1,\n\t.volatile_table = &mcp23x08_volatile_table,\n\t.precious_table = &mcp23x08_precious_table,\n\t.reg_defaults = mcp23x08_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(mcp23x08_defaults),\n\t.cache_type = REGCACHE_FLAT,\n\t.max_register = MCP_OLAT,\n};\nEXPORT_SYMBOL_GPL(mcp23x08_regmap);\n\nstatic const struct reg_default mcp23x17_defaults[] = {\n\t{.reg = MCP_IODIR << 1,\t\t.def = 0xffff},\n\t{.reg = MCP_IPOL << 1,\t\t.def = 0x0000},\n\t{.reg = MCP_GPINTEN << 1,\t.def = 0x0000},\n\t{.reg = MCP_DEFVAL << 1,\t.def = 0x0000},\n\t{.reg = MCP_INTCON << 1,\t.def = 0x0000},\n\t{.reg = MCP_IOCON << 1,\t\t.def = 0x0000},\n\t{.reg = MCP_GPPU << 1,\t\t.def = 0x0000},\n\t{.reg = MCP_OLAT << 1,\t\t.def = 0x0000},\n};\n\nstatic const struct regmap_range mcp23x17_volatile_range = {\n\t.range_min = MCP_INTF << 1,\n\t.range_max = MCP_GPIO << 1,\n};\n\nstatic const struct regmap_access_table mcp23x17_volatile_table = {\n\t.yes_ranges = &mcp23x17_volatile_range,\n\t.n_yes_ranges = 1,\n};\n\nstatic const struct regmap_range mcp23x17_precious_range = {\n\t.range_min = MCP_INTCAP << 1,\n\t.range_max = MCP_GPIO << 1,\n};\n\nstatic const struct regmap_access_table mcp23x17_precious_table = {\n\t.yes_ranges = &mcp23x17_precious_range,\n\t.n_yes_ranges = 1,\n};\n\nconst struct regmap_config mcp23x17_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 16,\n\n\t.reg_stride = 2,\n\t.max_register = MCP_OLAT << 1,\n\t.volatile_table = &mcp23x17_volatile_table,\n\t.precious_table = &mcp23x17_precious_table,\n\t.reg_defaults = mcp23x17_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(mcp23x17_defaults),\n\t.cache_type = REGCACHE_FLAT,\n\t.val_format_endian = REGMAP_ENDIAN_LITTLE,\n};\nEXPORT_SYMBOL_GPL(mcp23x17_regmap);\n\nstatic int mcp_read(struct mcp23s08 *mcp, unsigned int reg, unsigned int *val)\n{\n\treturn regmap_read(mcp->regmap, reg << mcp->reg_shift, val);\n}\n\nstatic int mcp_write(struct mcp23s08 *mcp, unsigned int reg, unsigned int val)\n{\n\treturn regmap_write(mcp->regmap, reg << mcp->reg_shift, val);\n}\n\nstatic int mcp_update_bits(struct mcp23s08 *mcp, unsigned int reg,\n\t\t\t   unsigned int mask, unsigned int val)\n{\n\treturn regmap_update_bits(mcp->regmap, reg << mcp->reg_shift,\n\t\t\t\t  mask, val);\n}\n\nstatic int mcp_set_bit(struct mcp23s08 *mcp, unsigned int reg,\n\t\t       unsigned int pin, bool enabled)\n{\n\tu16 mask = BIT(pin);\n\treturn mcp_update_bits(mcp, reg, mask, enabled ? mask : 0);\n}\n\nstatic const struct pinctrl_pin_desc mcp23x08_pins[] = {\n\tPINCTRL_PIN(0, \"gpio0\"),\n\tPINCTRL_PIN(1, \"gpio1\"),\n\tPINCTRL_PIN(2, \"gpio2\"),\n\tPINCTRL_PIN(3, \"gpio3\"),\n\tPINCTRL_PIN(4, \"gpio4\"),\n\tPINCTRL_PIN(5, \"gpio5\"),\n\tPINCTRL_PIN(6, \"gpio6\"),\n\tPINCTRL_PIN(7, \"gpio7\"),\n};\n\nstatic const struct pinctrl_pin_desc mcp23x17_pins[] = {\n\tPINCTRL_PIN(0, \"gpio0\"),\n\tPINCTRL_PIN(1, \"gpio1\"),\n\tPINCTRL_PIN(2, \"gpio2\"),\n\tPINCTRL_PIN(3, \"gpio3\"),\n\tPINCTRL_PIN(4, \"gpio4\"),\n\tPINCTRL_PIN(5, \"gpio5\"),\n\tPINCTRL_PIN(6, \"gpio6\"),\n\tPINCTRL_PIN(7, \"gpio7\"),\n\tPINCTRL_PIN(8, \"gpio8\"),\n\tPINCTRL_PIN(9, \"gpio9\"),\n\tPINCTRL_PIN(10, \"gpio10\"),\n\tPINCTRL_PIN(11, \"gpio11\"),\n\tPINCTRL_PIN(12, \"gpio12\"),\n\tPINCTRL_PIN(13, \"gpio13\"),\n\tPINCTRL_PIN(14, \"gpio14\"),\n\tPINCTRL_PIN(15, \"gpio15\"),\n};\n\nstatic int mcp_pinctrl_get_groups_count(struct pinctrl_dev *pctldev)\n{\n\treturn 0;\n}\n\nstatic const char *mcp_pinctrl_get_group_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t\tunsigned int group)\n{\n\treturn NULL;\n}\n\nstatic int mcp_pinctrl_get_group_pins(struct pinctrl_dev *pctldev,\n\t\t\t\t\tunsigned int group,\n\t\t\t\t\tconst unsigned int **pins,\n\t\t\t\t\tunsigned int *num_pins)\n{\n\treturn -ENOTSUPP;\n}\n\nstatic const struct pinctrl_ops mcp_pinctrl_ops = {\n\t.get_groups_count = mcp_pinctrl_get_groups_count,\n\t.get_group_name = mcp_pinctrl_get_group_name,\n\t.get_group_pins = mcp_pinctrl_get_group_pins,\n#ifdef CONFIG_OF\n\t.dt_node_to_map = pinconf_generic_dt_node_to_map_pin,\n\t.dt_free_map = pinconf_generic_dt_free_map,\n#endif\n};\n\nstatic int mcp_pinconf_get(struct pinctrl_dev *pctldev, unsigned int pin,\n\t\t\t      unsigned long *config)\n{\n\tstruct mcp23s08 *mcp = pinctrl_dev_get_drvdata(pctldev);\n\tenum pin_config_param param = pinconf_to_config_param(*config);\n\tunsigned int data, status;\n\tint ret;\n\n\tswitch (param) {\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\tret = mcp_read(mcp, MCP_GPPU, &data);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tstatus = (data & BIT(pin)) ? 1 : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\t*config = 0;\n\n\treturn status ? 0 : -EINVAL;\n}\n\nstatic int mcp_pinconf_set(struct pinctrl_dev *pctldev, unsigned int pin,\n\t\t\t      unsigned long *configs, unsigned int num_configs)\n{\n\tstruct mcp23s08 *mcp = pinctrl_dev_get_drvdata(pctldev);\n\tenum pin_config_param param;\n\tu32 arg;\n\tint ret = 0;\n\tint i;\n\n\tfor (i = 0; i < num_configs; i++) {\n\t\tparam = pinconf_to_config_param(configs[i]);\n\t\targ = pinconf_to_config_argument(configs[i]);\n\n\t\tswitch (param) {\n\t\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\t\tret = mcp_set_bit(mcp, MCP_GPPU, pin, arg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_dbg(mcp->dev, \"Invalid config param %04x\\n\", param);\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic const struct pinconf_ops mcp_pinconf_ops = {\n\t.pin_config_get = mcp_pinconf_get,\n\t.pin_config_set = mcp_pinconf_set,\n\t.is_generic = true,\n};\n\n \n\nstatic int mcp23s08_direction_input(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct mcp23s08\t*mcp = gpiochip_get_data(chip);\n\tint status;\n\n\tmutex_lock(&mcp->lock);\n\tstatus = mcp_set_bit(mcp, MCP_IODIR, offset, true);\n\tmutex_unlock(&mcp->lock);\n\n\treturn status;\n}\n\nstatic int mcp23s08_get(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct mcp23s08\t*mcp = gpiochip_get_data(chip);\n\tint status, ret;\n\n\tmutex_lock(&mcp->lock);\n\n\t \n\tret = mcp_read(mcp, MCP_GPIO, &status);\n\tif (ret < 0)\n\t\tstatus = 0;\n\telse {\n\t\tmcp->cached_gpio = status;\n\t\tstatus = !!(status & (1 << offset));\n\t}\n\n\tmutex_unlock(&mcp->lock);\n\treturn status;\n}\n\nstatic int mcp23s08_get_multiple(struct gpio_chip *chip,\n\t\t\t\t unsigned long *mask, unsigned long *bits)\n{\n\tstruct mcp23s08 *mcp = gpiochip_get_data(chip);\n\tunsigned int status;\n\tint ret;\n\n\tmutex_lock(&mcp->lock);\n\n\t \n\tret = mcp_read(mcp, MCP_GPIO, &status);\n\tif (ret < 0)\n\t\tstatus = 0;\n\telse {\n\t\tmcp->cached_gpio = status;\n\t\t*bits = status;\n\t}\n\n\tmutex_unlock(&mcp->lock);\n\treturn ret;\n}\n\nstatic int __mcp23s08_set(struct mcp23s08 *mcp, unsigned mask, bool value)\n{\n\treturn mcp_update_bits(mcp, MCP_OLAT, mask, value ? mask : 0);\n}\n\nstatic void mcp23s08_set(struct gpio_chip *chip, unsigned offset, int value)\n{\n\tstruct mcp23s08\t*mcp = gpiochip_get_data(chip);\n\tunsigned mask = BIT(offset);\n\n\tmutex_lock(&mcp->lock);\n\t__mcp23s08_set(mcp, mask, !!value);\n\tmutex_unlock(&mcp->lock);\n}\n\nstatic void mcp23s08_set_multiple(struct gpio_chip *chip,\n\t\t\t\t  unsigned long *mask, unsigned long *bits)\n{\n\tstruct mcp23s08\t*mcp = gpiochip_get_data(chip);\n\n\tmutex_lock(&mcp->lock);\n\tmcp_update_bits(mcp, MCP_OLAT, *mask, *bits);\n\tmutex_unlock(&mcp->lock);\n}\n\nstatic int\nmcp23s08_direction_output(struct gpio_chip *chip, unsigned offset, int value)\n{\n\tstruct mcp23s08\t*mcp = gpiochip_get_data(chip);\n\tunsigned mask = BIT(offset);\n\tint status;\n\n\tmutex_lock(&mcp->lock);\n\tstatus = __mcp23s08_set(mcp, mask, value);\n\tif (status == 0) {\n\t\tstatus = mcp_update_bits(mcp, MCP_IODIR, mask, 0);\n\t}\n\tmutex_unlock(&mcp->lock);\n\treturn status;\n}\n\n \nstatic irqreturn_t mcp23s08_irq(int irq, void *data)\n{\n\tstruct mcp23s08 *mcp = data;\n\tint intcap, intcon, intf, i, gpio, gpio_orig, intcap_mask, defval;\n\tunsigned int child_irq;\n\tbool intf_set, intcap_changed, gpio_bit_changed,\n\t\tdefval_changed, gpio_set;\n\n\tmutex_lock(&mcp->lock);\n\tif (mcp_read(mcp, MCP_INTF, &intf))\n\t\tgoto unlock;\n\n\tif (intf == 0) {\n\t\t \n\t\tgoto unlock;\n\t}\n\n\tif (mcp_read(mcp, MCP_INTCAP, &intcap))\n\t\tgoto unlock;\n\n\tif (mcp_read(mcp, MCP_INTCON, &intcon))\n\t\tgoto unlock;\n\n\tif (mcp_read(mcp, MCP_DEFVAL, &defval))\n\t\tgoto unlock;\n\n\t \n\tif (mcp_read(mcp, MCP_GPIO, &gpio))\n\t\tgoto unlock;\n\n\tgpio_orig = mcp->cached_gpio;\n\tmcp->cached_gpio = gpio;\n\tmutex_unlock(&mcp->lock);\n\n\tdev_dbg(mcp->chip.parent,\n\t\t\"intcap 0x%04X intf 0x%04X gpio_orig 0x%04X gpio 0x%04X\\n\",\n\t\tintcap, intf, gpio_orig, gpio);\n\n\tfor (i = 0; i < mcp->chip.ngpio; i++) {\n\t\t \n\n\t\tintf_set = intf & BIT(i);\n\t\tif (i < 8 && intf_set)\n\t\t\tintcap_mask = 0x00FF;\n\t\telse if (i >= 8 && intf_set)\n\t\t\tintcap_mask = 0xFF00;\n\t\telse\n\t\t\tintcap_mask = 0x00;\n\n\t\tintcap_changed = (intcap_mask &\n\t\t\t(intcap & BIT(i))) !=\n\t\t\t(intcap_mask & (BIT(i) & gpio_orig));\n\t\tgpio_set = BIT(i) & gpio;\n\t\tgpio_bit_changed = (BIT(i) & gpio_orig) !=\n\t\t\t(BIT(i) & gpio);\n\t\tdefval_changed = (BIT(i) & intcon) &&\n\t\t\t((BIT(i) & gpio) !=\n\t\t\t(BIT(i) & defval));\n\n\t\tif (((gpio_bit_changed || intcap_changed) &&\n\t\t\t(BIT(i) & mcp->irq_rise) && gpio_set) ||\n\t\t    ((gpio_bit_changed || intcap_changed) &&\n\t\t\t(BIT(i) & mcp->irq_fall) && !gpio_set) ||\n\t\t    defval_changed) {\n\t\t\tchild_irq = irq_find_mapping(mcp->chip.irq.domain, i);\n\t\t\thandle_nested_irq(child_irq);\n\t\t}\n\t}\n\n\treturn IRQ_HANDLED;\n\nunlock:\n\tmutex_unlock(&mcp->lock);\n\treturn IRQ_HANDLED;\n}\n\nstatic void mcp23s08_irq_mask(struct irq_data *data)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(data);\n\tstruct mcp23s08 *mcp = gpiochip_get_data(gc);\n\tunsigned int pos = irqd_to_hwirq(data);\n\n\tmcp_set_bit(mcp, MCP_GPINTEN, pos, false);\n\tgpiochip_disable_irq(gc, pos);\n}\n\nstatic void mcp23s08_irq_unmask(struct irq_data *data)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(data);\n\tstruct mcp23s08 *mcp = gpiochip_get_data(gc);\n\tunsigned int pos = irqd_to_hwirq(data);\n\n\tgpiochip_enable_irq(gc, pos);\n\tmcp_set_bit(mcp, MCP_GPINTEN, pos, true);\n}\n\nstatic int mcp23s08_irq_set_type(struct irq_data *data, unsigned int type)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(data);\n\tstruct mcp23s08 *mcp = gpiochip_get_data(gc);\n\tunsigned int pos = irqd_to_hwirq(data);\n\n\tif ((type & IRQ_TYPE_EDGE_BOTH) == IRQ_TYPE_EDGE_BOTH) {\n\t\tmcp_set_bit(mcp, MCP_INTCON, pos, false);\n\t\tmcp->irq_rise |= BIT(pos);\n\t\tmcp->irq_fall |= BIT(pos);\n\t} else if (type & IRQ_TYPE_EDGE_RISING) {\n\t\tmcp_set_bit(mcp, MCP_INTCON, pos, false);\n\t\tmcp->irq_rise |= BIT(pos);\n\t\tmcp->irq_fall &= ~BIT(pos);\n\t} else if (type & IRQ_TYPE_EDGE_FALLING) {\n\t\tmcp_set_bit(mcp, MCP_INTCON, pos, false);\n\t\tmcp->irq_rise &= ~BIT(pos);\n\t\tmcp->irq_fall |= BIT(pos);\n\t} else if (type & IRQ_TYPE_LEVEL_HIGH) {\n\t\tmcp_set_bit(mcp, MCP_INTCON, pos, true);\n\t\tmcp_set_bit(mcp, MCP_DEFVAL, pos, false);\n\t} else if (type & IRQ_TYPE_LEVEL_LOW) {\n\t\tmcp_set_bit(mcp, MCP_INTCON, pos, true);\n\t\tmcp_set_bit(mcp, MCP_DEFVAL, pos, true);\n\t} else\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void mcp23s08_irq_bus_lock(struct irq_data *data)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(data);\n\tstruct mcp23s08 *mcp = gpiochip_get_data(gc);\n\n\tmutex_lock(&mcp->lock);\n\tregcache_cache_only(mcp->regmap, true);\n}\n\nstatic void mcp23s08_irq_bus_unlock(struct irq_data *data)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(data);\n\tstruct mcp23s08 *mcp = gpiochip_get_data(gc);\n\n\tregcache_cache_only(mcp->regmap, false);\n\tregcache_sync(mcp->regmap);\n\n\tmutex_unlock(&mcp->lock);\n}\n\nstatic int mcp23s08_irq_setup(struct mcp23s08 *mcp)\n{\n\tstruct gpio_chip *chip = &mcp->chip;\n\tint err;\n\tunsigned long irqflags = IRQF_ONESHOT | IRQF_SHARED;\n\n\tif (mcp->irq_active_high)\n\t\tirqflags |= IRQF_TRIGGER_HIGH;\n\telse\n\t\tirqflags |= IRQF_TRIGGER_LOW;\n\n\terr = devm_request_threaded_irq(chip->parent, mcp->irq, NULL,\n\t\t\t\t\tmcp23s08_irq,\n\t\t\t\t\tirqflags, dev_name(chip->parent), mcp);\n\tif (err != 0) {\n\t\tdev_err(chip->parent, \"unable to request IRQ#%d: %d\\n\",\n\t\t\tmcp->irq, err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void mcp23s08_irq_print_chip(struct irq_data *d, struct seq_file *p)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct mcp23s08 *mcp = gpiochip_get_data(gc);\n\n\tseq_printf(p, dev_name(mcp->dev));\n}\n\nstatic const struct irq_chip mcp23s08_irq_chip = {\n\t.irq_mask = mcp23s08_irq_mask,\n\t.irq_unmask = mcp23s08_irq_unmask,\n\t.irq_set_type = mcp23s08_irq_set_type,\n\t.irq_bus_lock = mcp23s08_irq_bus_lock,\n\t.irq_bus_sync_unlock = mcp23s08_irq_bus_unlock,\n\t.irq_print_chip = mcp23s08_irq_print_chip,\n\t.flags = IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\n \n\nint mcp23s08_probe_one(struct mcp23s08 *mcp, struct device *dev,\n\t\t       unsigned int addr, unsigned int type, unsigned int base)\n{\n\tint status, ret;\n\tbool mirror = false;\n\tbool open_drain = false;\n\n\tmutex_init(&mcp->lock);\n\n\tmcp->dev = dev;\n\tmcp->addr = addr;\n\n\tmcp->irq_active_high = false;\n\n\tmcp->chip.direction_input = mcp23s08_direction_input;\n\tmcp->chip.get = mcp23s08_get;\n\tmcp->chip.get_multiple = mcp23s08_get_multiple;\n\tmcp->chip.direction_output = mcp23s08_direction_output;\n\tmcp->chip.set = mcp23s08_set;\n\tmcp->chip.set_multiple = mcp23s08_set_multiple;\n\n\tmcp->chip.base = base;\n\tmcp->chip.can_sleep = true;\n\tmcp->chip.parent = dev;\n\tmcp->chip.owner = THIS_MODULE;\n\n\tmcp->reset_gpio = devm_gpiod_get_optional(dev, \"reset\", GPIOD_OUT_LOW);\n\n\t \n\n\tret = mcp_read(mcp, MCP_IOCON, &status);\n\tif (ret < 0)\n\t\treturn dev_err_probe(dev, ret, \"can't identify chip %d\\n\", addr);\n\n\tmcp->irq_controller =\n\t\tdevice_property_read_bool(dev, \"interrupt-controller\");\n\tif (mcp->irq && mcp->irq_controller) {\n\t\tmcp->irq_active_high =\n\t\t\tdevice_property_read_bool(dev,\n\t\t\t\t\t      \"microchip,irq-active-high\");\n\n\t\tmirror = device_property_read_bool(dev, \"microchip,irq-mirror\");\n\t\topen_drain = device_property_read_bool(dev, \"drive-open-drain\");\n\t}\n\n\tif ((status & IOCON_SEQOP) || !(status & IOCON_HAEN) || mirror ||\n\t     mcp->irq_active_high || open_drain) {\n\t\t \n\t\tstatus &= ~(IOCON_SEQOP | (IOCON_SEQOP << 8));\n\t\tstatus |= IOCON_HAEN | (IOCON_HAEN << 8);\n\t\tif (mcp->irq_active_high)\n\t\t\tstatus |= IOCON_INTPOL | (IOCON_INTPOL << 8);\n\t\telse\n\t\t\tstatus &= ~(IOCON_INTPOL | (IOCON_INTPOL << 8));\n\n\t\tif (mirror)\n\t\t\tstatus |= IOCON_MIRROR | (IOCON_MIRROR << 8);\n\n\t\tif (open_drain)\n\t\t\tstatus |= IOCON_ODR | (IOCON_ODR << 8);\n\n\t\tif (type == MCP_TYPE_S18 || type == MCP_TYPE_018)\n\t\t\tstatus |= IOCON_INTCC | (IOCON_INTCC << 8);\n\n\t\tret = mcp_write(mcp, MCP_IOCON, status);\n\t\tif (ret < 0)\n\t\t\treturn dev_err_probe(dev, ret, \"can't write IOCON %d\\n\", addr);\n\t}\n\n\tif (mcp->irq && mcp->irq_controller) {\n\t\tstruct gpio_irq_chip *girq = &mcp->chip.irq;\n\n\t\tgpio_irq_chip_set_chip(girq, &mcp23s08_irq_chip);\n\t\t \n\t\tgirq->parent_handler = NULL;\n\t\tgirq->num_parents = 0;\n\t\tgirq->parents = NULL;\n\t\tgirq->default_type = IRQ_TYPE_NONE;\n\t\tgirq->handler = handle_simple_irq;\n\t\tgirq->threaded = true;\n\t}\n\n\tret = devm_gpiochip_add_data(dev, &mcp->chip, mcp);\n\tif (ret < 0)\n\t\treturn dev_err_probe(dev, ret, \"can't add GPIO chip\\n\");\n\n\tmcp->pinctrl_desc.pctlops = &mcp_pinctrl_ops;\n\tmcp->pinctrl_desc.confops = &mcp_pinconf_ops;\n\tmcp->pinctrl_desc.npins = mcp->chip.ngpio;\n\tif (mcp->pinctrl_desc.npins == 8)\n\t\tmcp->pinctrl_desc.pins = mcp23x08_pins;\n\telse if (mcp->pinctrl_desc.npins == 16)\n\t\tmcp->pinctrl_desc.pins = mcp23x17_pins;\n\tmcp->pinctrl_desc.owner = THIS_MODULE;\n\n\tmcp->pctldev = devm_pinctrl_register(dev, &mcp->pinctrl_desc, mcp);\n\tif (IS_ERR(mcp->pctldev))\n\t\treturn dev_err_probe(dev, PTR_ERR(mcp->pctldev), \"can't register controller\\n\");\n\n\tif (mcp->irq) {\n\t\tret = mcp23s08_irq_setup(mcp);\n\t\tif (ret)\n\t\t\treturn dev_err_probe(dev, ret, \"can't setup IRQ\\n\");\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mcp23s08_probe_one);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}