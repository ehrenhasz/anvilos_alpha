{
  "module_name": "pinctrl-falcon.c",
  "hash_id": "f3d1e77ef6ef7fdae40902428942a81b9373d7c4299a6a0cb4766f9c21d183d3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/pinctrl-falcon.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/gpio/driver.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n\n#include \"pinctrl-lantiq.h\"\n\n#include <lantiq_soc.h>\n\n \n#define LTQ_PADC_MUX(x)         (x * 0x4)\n \n#define LTQ_PADC_PUEN\t\t0x80\n \n#define LTQ_PADC_PDEN\t\t0x84\n \n#define LTQ_PADC_SRC\t\t0x88\n \n#define LTQ_PADC_DCC\t\t0x8C\n \n#define LTQ_PADC_AVAIL          0xF0\n\n#define pad_r32(p, reg)\t\tltq_r32(p + reg)\n#define pad_w32(p, val, reg)\tltq_w32(val, p + reg)\n#define pad_w32_mask(c, clear, set, reg) \\\n\t\tpad_w32(c, (pad_r32(c, reg) & ~(clear)) | (set), reg)\n\n#define pad_getbit(m, r, p)\t(!!(ltq_r32(m + r) & (1 << p)))\n\n#define PORTS\t\t\t5\n#define PINS\t\t\t32\n#define PORT(x)                 (x / PINS)\n#define PORT_PIN(x)             (x % PINS)\n\n#define MFP_FALCON(a, f0, f1, f2, f3)\t\t\\\n{\t\t\t\t\t\t\\\n\t.name = #a,\t\t\t\t\\\n\t.pin = a,\t\t\t\t\\\n\t.func = {\t\t\t\t\\\n\t\tFALCON_MUX_##f0,\t\t\\\n\t\tFALCON_MUX_##f1,\t\t\\\n\t\tFALCON_MUX_##f2,\t\t\\\n\t\tFALCON_MUX_##f3,\t\t\\\n\t},\t\t\t\t\t\\\n}\n\n#define GRP_MUX(a, m, p)\t\\\n{\t\t\t\t\\\n\t.name = a,\t\t\\\n\t.mux = FALCON_MUX_##m,\t\\\n\t.pins = p,\t\t\\\n\t.npins = ARRAY_SIZE(p),\t\\\n}\n\nenum falcon_mux {\n\tFALCON_MUX_GPIO = 0,\n\tFALCON_MUX_RST,\n\tFALCON_MUX_NTR,\n\tFALCON_MUX_PPS,\n\tFALCON_MUX_MDIO,\n\tFALCON_MUX_LED,\n\tFALCON_MUX_SPI,\n\tFALCON_MUX_ASC,\n\tFALCON_MUX_I2C,\n\tFALCON_MUX_HOSTIF,\n\tFALCON_MUX_SLIC,\n\tFALCON_MUX_JTAG,\n\tFALCON_MUX_PCM,\n\tFALCON_MUX_MII,\n\tFALCON_MUX_PHY,\n\tFALCON_MUX_NONE = 0xffff,\n};\n\nstatic struct pinctrl_pin_desc falcon_pads[PORTS * PINS];\nstatic int pad_count[PORTS];\n\nstatic void lantiq_load_pin_desc(struct pinctrl_pin_desc *d, int bank, int len)\n{\n\tint base = bank * PINS;\n\tint i;\n\n\tfor (i = 0; i < len; i++) {\n\t\td[i].number = base + i;\n\t\td[i].name = kasprintf(GFP_KERNEL, \"io%d\", base + i);\n\t}\n\tpad_count[bank] = len;\n}\n\nstatic struct ltq_mfp_pin falcon_mfp[] = {\n\t \n\tMFP_FALCON(GPIO0,\tRST,\tGPIO,   NONE,   NONE),\n\tMFP_FALCON(GPIO1,\tGPIO,\tGPIO,   NONE,   NONE),\n\tMFP_FALCON(GPIO2,\tGPIO,\tGPIO,   NONE,   NONE),\n\tMFP_FALCON(GPIO3,\tGPIO,\tGPIO,   NONE,   NONE),\n\tMFP_FALCON(GPIO4,\tNTR,\tGPIO,   NONE,   NONE),\n\tMFP_FALCON(GPIO5,\tNTR,\tGPIO,   PPS,    NONE),\n\tMFP_FALCON(GPIO6,\tRST,\tGPIO,   NONE,   NONE),\n\tMFP_FALCON(GPIO7,\tMDIO,\tGPIO,   NONE,   NONE),\n\tMFP_FALCON(GPIO8,\tMDIO,\tGPIO,   NONE,   NONE),\n\tMFP_FALCON(GPIO9,\tLED,\tGPIO,   NONE,   NONE),\n\tMFP_FALCON(GPIO10,\tLED,\tGPIO,   NONE,   NONE),\n\tMFP_FALCON(GPIO11,\tLED,\tGPIO,   NONE,   NONE),\n\tMFP_FALCON(GPIO12,\tLED,\tGPIO,   NONE,   NONE),\n\tMFP_FALCON(GPIO13,\tLED,\tGPIO,   NONE,   NONE),\n\tMFP_FALCON(GPIO14,\tLED,\tGPIO,   NONE,   NONE),\n\tMFP_FALCON(GPIO32,\tASC,\tGPIO,   NONE,   NONE),\n\tMFP_FALCON(GPIO33,\tASC,\tGPIO,   NONE,   NONE),\n\tMFP_FALCON(GPIO34,\tSPI,\tGPIO,\tNONE,\tNONE),\n\tMFP_FALCON(GPIO35,\tSPI,\tGPIO,\tNONE,\tNONE),\n\tMFP_FALCON(GPIO36,\tSPI,\tGPIO,\tNONE,\tNONE),\n\tMFP_FALCON(GPIO37,\tSPI,\tGPIO,\tNONE,\tNONE),\n\tMFP_FALCON(GPIO38,\tSPI,\tGPIO,\tNONE,\tNONE),\n\tMFP_FALCON(GPIO39,\tI2C,\tGPIO,\tNONE,\tNONE),\n\tMFP_FALCON(GPIO40,\tI2C,\tGPIO,\tNONE,\tNONE),\n\tMFP_FALCON(GPIO41,\tHOSTIF,\tGPIO,\tHOSTIF,\tJTAG),\n\tMFP_FALCON(GPIO42,\tHOSTIF,\tGPIO,\tHOSTIF,\tNONE),\n\tMFP_FALCON(GPIO43,\tSLIC,\tGPIO,\tNONE,\tNONE),\n\tMFP_FALCON(GPIO44,\tSLIC,\tGPIO,\tPCM,\tASC),\n\tMFP_FALCON(GPIO45,\tSLIC,\tGPIO,\tPCM,\tASC),\n\tMFP_FALCON(GPIO64,\tMII,\tGPIO,\tNONE,\tNONE),\n\tMFP_FALCON(GPIO65,\tMII,\tGPIO,\tNONE,\tNONE),\n\tMFP_FALCON(GPIO66,\tMII,\tGPIO,\tNONE,\tNONE),\n\tMFP_FALCON(GPIO67,\tMII,\tGPIO,\tNONE,\tNONE),\n\tMFP_FALCON(GPIO68,\tMII,\tGPIO,\tNONE,\tNONE),\n\tMFP_FALCON(GPIO69,\tMII,\tGPIO,\tNONE,\tNONE),\n\tMFP_FALCON(GPIO70,\tMII,\tGPIO,\tNONE,\tNONE),\n\tMFP_FALCON(GPIO71,\tMII,\tGPIO,\tNONE,\tNONE),\n\tMFP_FALCON(GPIO72,\tMII,\tGPIO,\tNONE,\tNONE),\n\tMFP_FALCON(GPIO73,\tMII,\tGPIO,\tNONE,\tNONE),\n\tMFP_FALCON(GPIO74,\tMII,\tGPIO,\tNONE,\tNONE),\n\tMFP_FALCON(GPIO75,\tMII,\tGPIO,\tNONE,\tNONE),\n\tMFP_FALCON(GPIO76,\tMII,\tGPIO,\tNONE,\tNONE),\n\tMFP_FALCON(GPIO77,\tMII,\tGPIO,\tNONE,\tNONE),\n\tMFP_FALCON(GPIO78,\tMII,\tGPIO,\tNONE,\tNONE),\n\tMFP_FALCON(GPIO79,\tMII,\tGPIO,\tNONE,\tNONE),\n\tMFP_FALCON(GPIO80,\tMII,\tGPIO,\tNONE,\tNONE),\n\tMFP_FALCON(GPIO81,\tMII,\tGPIO,\tNONE,\tNONE),\n\tMFP_FALCON(GPIO82,\tMII,\tGPIO,\tNONE,\tNONE),\n\tMFP_FALCON(GPIO83,\tMII,\tGPIO,\tNONE,\tNONE),\n\tMFP_FALCON(GPIO84,\tMII,\tGPIO,\tNONE,\tNONE),\n\tMFP_FALCON(GPIO85,\tMII,\tGPIO,\tNONE,\tNONE),\n\tMFP_FALCON(GPIO86,\tMII,\tGPIO,\tNONE,\tNONE),\n\tMFP_FALCON(GPIO87,\tMII,\tGPIO,\tNONE,\tNONE),\n\tMFP_FALCON(GPIO88,\tPHY,\tGPIO,\tNONE,\tNONE),\n};\n\nstatic const unsigned pins_por[] = {GPIO0};\nstatic const unsigned pins_ntr[] = {GPIO4};\nstatic const unsigned pins_ntr8k[] = {GPIO5};\nstatic const unsigned pins_pps[] = {GPIO5};\nstatic const unsigned pins_hrst[] = {GPIO6};\nstatic const unsigned pins_mdio[] = {GPIO7, GPIO8};\nstatic const unsigned pins_bled[] = {GPIO9, GPIO10, GPIO11,\n\t\t\t\t\tGPIO12, GPIO13, GPIO14};\nstatic const unsigned pins_asc0[] = {GPIO32, GPIO33};\nstatic const unsigned pins_spi[] = {GPIO34, GPIO35, GPIO36};\nstatic const unsigned pins_spi_cs0[] = {GPIO37};\nstatic const unsigned pins_spi_cs1[] = {GPIO38};\nstatic const unsigned pins_i2c[] = {GPIO39, GPIO40};\nstatic const unsigned pins_jtag[] = {GPIO41};\nstatic const unsigned pins_slic[] = {GPIO43, GPIO44, GPIO45};\nstatic const unsigned pins_pcm[] = {GPIO44, GPIO45};\nstatic const unsigned pins_asc1[] = {GPIO44, GPIO45};\n\nstatic struct ltq_pin_group falcon_grps[] = {\n\tGRP_MUX(\"por\", RST, pins_por),\n\tGRP_MUX(\"ntr\", NTR, pins_ntr),\n\tGRP_MUX(\"ntr8k\", NTR, pins_ntr8k),\n\tGRP_MUX(\"pps\", PPS, pins_pps),\n\tGRP_MUX(\"hrst\", RST, pins_hrst),\n\tGRP_MUX(\"mdio\", MDIO, pins_mdio),\n\tGRP_MUX(\"bootled\", LED, pins_bled),\n\tGRP_MUX(\"asc0\", ASC, pins_asc0),\n\tGRP_MUX(\"spi\", SPI, pins_spi),\n\tGRP_MUX(\"spi cs0\", SPI, pins_spi_cs0),\n\tGRP_MUX(\"spi cs1\", SPI, pins_spi_cs1),\n\tGRP_MUX(\"i2c\", I2C, pins_i2c),\n\tGRP_MUX(\"jtag\", JTAG, pins_jtag),\n\tGRP_MUX(\"slic\", SLIC, pins_slic),\n\tGRP_MUX(\"pcm\", PCM, pins_pcm),\n\tGRP_MUX(\"asc1\", ASC, pins_asc1),\n};\n\nstatic const char * const ltq_rst_grps[] = {\"por\", \"hrst\"};\nstatic const char * const ltq_ntr_grps[] = {\"ntr\", \"ntr8k\", \"pps\"};\nstatic const char * const ltq_mdio_grps[] = {\"mdio\"};\nstatic const char * const ltq_bled_grps[] = {\"bootled\"};\nstatic const char * const ltq_asc_grps[] = {\"asc0\", \"asc1\"};\nstatic const char * const ltq_spi_grps[] = {\"spi\", \"spi cs0\", \"spi cs1\"};\nstatic const char * const ltq_i2c_grps[] = {\"i2c\"};\nstatic const char * const ltq_jtag_grps[] = {\"jtag\"};\nstatic const char * const ltq_slic_grps[] = {\"slic\"};\nstatic const char * const ltq_pcm_grps[] = {\"pcm\"};\n\nstatic struct ltq_pmx_func falcon_funcs[] = {\n\t{\"rst\",\t\tARRAY_AND_SIZE(ltq_rst_grps)},\n\t{\"ntr\",\t\tARRAY_AND_SIZE(ltq_ntr_grps)},\n\t{\"mdio\",\tARRAY_AND_SIZE(ltq_mdio_grps)},\n\t{\"led\",\t\tARRAY_AND_SIZE(ltq_bled_grps)},\n\t{\"asc\",\t\tARRAY_AND_SIZE(ltq_asc_grps)},\n\t{\"spi\",\t\tARRAY_AND_SIZE(ltq_spi_grps)},\n\t{\"i2c\",\t\tARRAY_AND_SIZE(ltq_i2c_grps)},\n\t{\"jtag\",\tARRAY_AND_SIZE(ltq_jtag_grps)},\n\t{\"slic\",\tARRAY_AND_SIZE(ltq_slic_grps)},\n\t{\"pcm\",\t\tARRAY_AND_SIZE(ltq_pcm_grps)},\n};\n\n\n\n\n \nstatic int falcon_pinconf_group_get(struct pinctrl_dev *pctrldev,\n\t\t\t\tunsigned group, unsigned long *config)\n{\n\treturn -ENOTSUPP;\n}\n\nstatic int falcon_pinconf_group_set(struct pinctrl_dev *pctrldev,\n\t\t\t\tunsigned group, unsigned long *configs,\n\t\t\t\tunsigned num_configs)\n{\n\treturn -ENOTSUPP;\n}\n\nstatic int falcon_pinconf_get(struct pinctrl_dev *pctrldev,\n\t\t\t\tunsigned pin, unsigned long *config)\n{\n\tstruct ltq_pinmux_info *info = pinctrl_dev_get_drvdata(pctrldev);\n\tenum ltq_pinconf_param param = LTQ_PINCONF_UNPACK_PARAM(*config);\n\tvoid __iomem *mem = info->membase[PORT(pin)];\n\n\tswitch (param) {\n\tcase LTQ_PINCONF_PARAM_DRIVE_CURRENT:\n\t\t*config = LTQ_PINCONF_PACK(param,\n\t\t\t!!pad_getbit(mem, LTQ_PADC_DCC, PORT_PIN(pin)));\n\t\tbreak;\n\n\tcase LTQ_PINCONF_PARAM_SLEW_RATE:\n\t\t*config = LTQ_PINCONF_PACK(param,\n\t\t\t!!pad_getbit(mem, LTQ_PADC_SRC, PORT_PIN(pin)));\n\t\tbreak;\n\n\tcase LTQ_PINCONF_PARAM_PULL:\n\t\tif (pad_getbit(mem, LTQ_PADC_PDEN, PORT_PIN(pin)))\n\t\t\t*config = LTQ_PINCONF_PACK(param, 1);\n\t\telse if (pad_getbit(mem, LTQ_PADC_PUEN, PORT_PIN(pin)))\n\t\t\t*config = LTQ_PINCONF_PACK(param, 2);\n\t\telse\n\t\t\t*config = LTQ_PINCONF_PACK(param, 0);\n\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int falcon_pinconf_set(struct pinctrl_dev *pctrldev,\n\t\t\tunsigned pin, unsigned long *configs,\n\t\t\tunsigned num_configs)\n{\n\tenum ltq_pinconf_param param;\n\tint arg;\n\tstruct ltq_pinmux_info *info = pinctrl_dev_get_drvdata(pctrldev);\n\tvoid __iomem *mem = info->membase[PORT(pin)];\n\tu32 reg;\n\tint i;\n\n\tfor (i = 0; i < num_configs; i++) {\n\t\tparam = LTQ_PINCONF_UNPACK_PARAM(configs[i]);\n\t\targ = LTQ_PINCONF_UNPACK_ARG(configs[i]);\n\n\t\tswitch (param) {\n\t\tcase LTQ_PINCONF_PARAM_DRIVE_CURRENT:\n\t\t\treg = LTQ_PADC_DCC;\n\t\t\tbreak;\n\n\t\tcase LTQ_PINCONF_PARAM_SLEW_RATE:\n\t\t\treg = LTQ_PADC_SRC;\n\t\t\tbreak;\n\n\t\tcase LTQ_PINCONF_PARAM_PULL:\n\t\t\tif (arg == 1)\n\t\t\t\treg = LTQ_PADC_PDEN;\n\t\t\telse\n\t\t\t\treg = LTQ_PADC_PUEN;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpr_err(\"%s: Invalid config param %04x\\n\",\n\t\t\tpinctrl_dev_get_name(pctrldev), param);\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\n\t\tpad_w32(mem, BIT(PORT_PIN(pin)), reg);\n\t\tif (!(pad_r32(mem, reg) & BIT(PORT_PIN(pin))))\n\t\t\treturn -ENOTSUPP;\n\t}  \n\n\treturn 0;\n}\n\nstatic void falcon_pinconf_dbg_show(struct pinctrl_dev *pctrldev,\n\t\t\tstruct seq_file *s, unsigned offset)\n{\n\tunsigned long config;\n\tstruct pin_desc *desc;\n\n\tstruct ltq_pinmux_info *info = pinctrl_dev_get_drvdata(pctrldev);\n\tint port = PORT(offset);\n\n\tseq_printf(s, \" (port %d) mux %d -- \", port,\n\t\tpad_r32(info->membase[port], LTQ_PADC_MUX(PORT_PIN(offset))));\n\n\tconfig = LTQ_PINCONF_PACK(LTQ_PINCONF_PARAM_PULL, 0);\n\tif (!falcon_pinconf_get(pctrldev, offset, &config))\n\t\tseq_printf(s, \"pull %d \",\n\t\t\t(int)LTQ_PINCONF_UNPACK_ARG(config));\n\n\tconfig = LTQ_PINCONF_PACK(LTQ_PINCONF_PARAM_DRIVE_CURRENT, 0);\n\tif (!falcon_pinconf_get(pctrldev, offset, &config))\n\t\tseq_printf(s, \"drive-current %d \",\n\t\t\t(int)LTQ_PINCONF_UNPACK_ARG(config));\n\n\tconfig = LTQ_PINCONF_PACK(LTQ_PINCONF_PARAM_SLEW_RATE, 0);\n\tif (!falcon_pinconf_get(pctrldev, offset, &config))\n\t\tseq_printf(s, \"slew-rate %d \",\n\t\t\t(int)LTQ_PINCONF_UNPACK_ARG(config));\n\n\tdesc = pin_desc_get(pctrldev, offset);\n\tif (desc) {\n\t\tif (desc->gpio_owner)\n\t\t\tseq_printf(s, \" owner: %s\", desc->gpio_owner);\n\t} else {\n\t\tseq_printf(s, \" not registered\");\n\t}\n}\n\nstatic void falcon_pinconf_group_dbg_show(struct pinctrl_dev *pctrldev,\n\t\t\tstruct seq_file *s, unsigned selector)\n{\n}\n\nstatic const struct pinconf_ops falcon_pinconf_ops = {\n\t.pin_config_get\t\t\t= falcon_pinconf_get,\n\t.pin_config_set\t\t\t= falcon_pinconf_set,\n\t.pin_config_group_get\t\t= falcon_pinconf_group_get,\n\t.pin_config_group_set\t\t= falcon_pinconf_group_set,\n\t.pin_config_dbg_show\t\t= falcon_pinconf_dbg_show,\n\t.pin_config_group_dbg_show\t= falcon_pinconf_group_dbg_show,\n};\n\nstatic struct pinctrl_desc falcon_pctrl_desc = {\n\t.owner\t\t= THIS_MODULE,\n\t.pins\t\t= falcon_pads,\n\t.confops\t= &falcon_pinconf_ops,\n};\n\nstatic inline int falcon_mux_apply(struct pinctrl_dev *pctrldev,\n\t\t\tint mfp, int mux)\n{\n\tstruct ltq_pinmux_info *info = pinctrl_dev_get_drvdata(pctrldev);\n\tint port = PORT(info->mfp[mfp].pin);\n\n\tif ((port >= PORTS) || (!info->membase[port]))\n\t\treturn -ENODEV;\n\n\tpad_w32(info->membase[port], mux,\n\t\tLTQ_PADC_MUX(PORT_PIN(info->mfp[mfp].pin)));\n\treturn 0;\n}\n\nstatic const struct ltq_cfg_param falcon_cfg_params[] = {\n\t{\"lantiq,pull\",\t\t\tLTQ_PINCONF_PARAM_PULL},\n\t{\"lantiq,drive-current\",\tLTQ_PINCONF_PARAM_DRIVE_CURRENT},\n\t{\"lantiq,slew-rate\",\t\tLTQ_PINCONF_PARAM_SLEW_RATE},\n};\n\nstatic struct ltq_pinmux_info falcon_info = {\n\t.desc\t\t= &falcon_pctrl_desc,\n\t.apply_mux\t= falcon_mux_apply,\n\t.params\t\t= falcon_cfg_params,\n\t.num_params\t= ARRAY_SIZE(falcon_cfg_params),\n};\n\n\n\n\n \n\nint pinctrl_falcon_get_range_size(int id)\n{\n\tu32 avail;\n\n\tif ((id >= PORTS) || (!falcon_info.membase[id]))\n\t\treturn -EINVAL;\n\n\tavail = pad_r32(falcon_info.membase[id], LTQ_PADC_AVAIL);\n\n\treturn fls(avail);\n}\n\nvoid pinctrl_falcon_add_gpio_range(struct pinctrl_gpio_range *range)\n{\n\tpinctrl_add_gpio_range(falcon_info.pctrl, range);\n}\n\nstatic int pinctrl_falcon_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np;\n\tint pad_count = 0;\n\tint ret = 0;\n\n\t \n\tfor_each_compatible_node(np, NULL, \"lantiq,pad-falcon\") {\n\t\tconst __be32 *bank = of_get_property(np, \"lantiq,bank\", NULL);\n\t\tstruct resource res;\n\t\tstruct platform_device *ppdev;\n\t\tu32 avail;\n\t\tint pins;\n\n\t\tif (!of_device_is_available(np))\n\t\t\tcontinue;\n\n\t\tif (!bank || *bank >= PORTS)\n\t\t\tcontinue;\n\t\tif (of_address_to_resource(np, 0, &res))\n\t\t\tcontinue;\n\n\t\tppdev = of_find_device_by_node(np);\n\t\tif (!ppdev) {\n\t\t\tdev_err(&pdev->dev, \"failed to find pad pdev\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tfalcon_info.clk[*bank] = clk_get(&ppdev->dev, NULL);\n\t\tput_device(&ppdev->dev);\n\t\tif (IS_ERR(falcon_info.clk[*bank])) {\n\t\t\tdev_err(&ppdev->dev, \"failed to get clock\\n\");\n\t\t\tof_node_put(np);\n\t\t\treturn PTR_ERR(falcon_info.clk[*bank]);\n\t\t}\n\t\tfalcon_info.membase[*bank] = devm_ioremap_resource(&pdev->dev,\n\t\t\t\t\t\t\t\t   &res);\n\t\tif (IS_ERR(falcon_info.membase[*bank])) {\n\t\t\tof_node_put(np);\n\t\t\treturn PTR_ERR(falcon_info.membase[*bank]);\n\t\t}\n\n\t\tavail = pad_r32(falcon_info.membase[*bank],\n\t\t\t\t\tLTQ_PADC_AVAIL);\n\t\tpins = fls(avail);\n\t\tlantiq_load_pin_desc(&falcon_pads[pad_count], *bank, pins);\n\t\tpad_count += pins;\n\t\tclk_enable(falcon_info.clk[*bank]);\n\t\tdev_dbg(&pdev->dev, \"found %s with %d pads\\n\",\n\t\t\t\tres.name, pins);\n\t}\n\tdev_dbg(&pdev->dev, \"found a total of %d pads\\n\", pad_count);\n\tfalcon_pctrl_desc.name\t= dev_name(&pdev->dev);\n\tfalcon_pctrl_desc.npins\t= pad_count;\n\n\tfalcon_info.mfp\t\t= falcon_mfp;\n\tfalcon_info.num_mfp\t= ARRAY_SIZE(falcon_mfp);\n\tfalcon_info.grps\t= falcon_grps;\n\tfalcon_info.num_grps\t= ARRAY_SIZE(falcon_grps);\n\tfalcon_info.funcs\t= falcon_funcs;\n\tfalcon_info.num_funcs\t= ARRAY_SIZE(falcon_funcs);\n\n\tret = ltq_pinctrl_register(pdev, &falcon_info);\n\tif (!ret)\n\t\tdev_info(&pdev->dev, \"Init done\\n\");\n\treturn ret;\n}\n\nstatic const struct of_device_id falcon_match[] = {\n\t{ .compatible = \"lantiq,pinctrl-falcon\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, falcon_match);\n\nstatic struct platform_driver pinctrl_falcon_driver = {\n\t.probe = pinctrl_falcon_probe,\n\t.driver = {\n\t\t.name = \"pinctrl-falcon\",\n\t\t.of_match_table = falcon_match,\n\t},\n};\n\nint __init pinctrl_falcon_init(void)\n{\n\treturn platform_driver_register(&pinctrl_falcon_driver);\n}\n\ncore_initcall_sync(pinctrl_falcon_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}