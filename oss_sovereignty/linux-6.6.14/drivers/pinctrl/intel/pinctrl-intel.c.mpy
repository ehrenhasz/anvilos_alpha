{
  "module_name": "pinctrl-intel.c",
  "hash_id": "e13aef21cc951a214a898d240d0bcc9bc4daccd5b94c63edd5c07777e5344215",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/intel/pinctrl-intel.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/gpio/driver.h>\n#include <linux/interrupt.h>\n#include <linux/log2.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/seq_file.h>\n#include <linux/string_helpers.h>\n#include <linux/time.h>\n\n#include <linux/pinctrl/consumer.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinconf-generic.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinmux.h>\n\n#include <linux/platform_data/x86/pwm-lpss.h>\n\n#include \"../core.h\"\n#include \"pinctrl-intel.h\"\n\n \n#define REVID\t\t\t\t0x000\n#define REVID_SHIFT\t\t\t16\n#define REVID_MASK\t\t\tGENMASK(31, 16)\n\n#define CAPLIST\t\t\t\t0x004\n#define CAPLIST_ID_SHIFT\t\t16\n#define CAPLIST_ID_MASK\t\t\tGENMASK(23, 16)\n#define CAPLIST_ID_GPIO_HW_INFO\t\t1\n#define CAPLIST_ID_PWM\t\t\t2\n#define CAPLIST_ID_BLINK\t\t3\n#define CAPLIST_ID_EXP\t\t\t4\n#define CAPLIST_NEXT_SHIFT\t\t0\n#define CAPLIST_NEXT_MASK\t\tGENMASK(15, 0)\n\n#define PADBAR\t\t\t\t0x00c\n\n#define PADOWN_BITS\t\t\t4\n#define PADOWN_SHIFT(p)\t\t\t((p) % 8 * PADOWN_BITS)\n#define PADOWN_MASK(p)\t\t\t(GENMASK(3, 0) << PADOWN_SHIFT(p))\n#define PADOWN_GPP(p)\t\t\t((p) / 8)\n\n#define PWMC\t\t\t\t0x204\n\n \n#define PADCFG0\t\t\t\t0x000\n#define PADCFG0_RXEVCFG_MASK\t\tGENMASK(26, 25)\n#define PADCFG0_RXEVCFG_LEVEL\t\t(0 << 25)\n#define PADCFG0_RXEVCFG_EDGE\t\t(1 << 25)\n#define PADCFG0_RXEVCFG_DISABLED\t(2 << 25)\n#define PADCFG0_RXEVCFG_EDGE_BOTH\t(3 << 25)\n#define PADCFG0_PREGFRXSEL\t\tBIT(24)\n#define PADCFG0_RXINV\t\t\tBIT(23)\n#define PADCFG0_GPIROUTIOXAPIC\t\tBIT(20)\n#define PADCFG0_GPIROUTSCI\t\tBIT(19)\n#define PADCFG0_GPIROUTSMI\t\tBIT(18)\n#define PADCFG0_GPIROUTNMI\t\tBIT(17)\n#define PADCFG0_PMODE_SHIFT\t\t10\n#define PADCFG0_PMODE_MASK\t\tGENMASK(13, 10)\n#define PADCFG0_PMODE_GPIO\t\t0\n#define PADCFG0_GPIORXDIS\t\tBIT(9)\n#define PADCFG0_GPIOTXDIS\t\tBIT(8)\n#define PADCFG0_GPIORXSTATE\t\tBIT(1)\n#define PADCFG0_GPIOTXSTATE\t\tBIT(0)\n\n#define PADCFG1\t\t\t\t0x004\n#define PADCFG1_TERM_UP\t\t\tBIT(13)\n#define PADCFG1_TERM_SHIFT\t\t10\n#define PADCFG1_TERM_MASK\t\tGENMASK(12, 10)\n#define PADCFG1_TERM_20K\t\tBIT(2)\n#define PADCFG1_TERM_5K\t\t\tBIT(1)\n#define PADCFG1_TERM_4K\t\t\t(BIT(2) | BIT(1))\n#define PADCFG1_TERM_1K\t\t\tBIT(0)\n#define PADCFG1_TERM_952\t\t(BIT(2) | BIT(0))\n#define PADCFG1_TERM_833\t\t(BIT(1) | BIT(0))\n#define PADCFG1_TERM_800\t\t(BIT(2) | BIT(1) | BIT(0))\n\n#define PADCFG2\t\t\t\t0x008\n#define PADCFG2_DEBOUNCE_SHIFT\t\t1\n#define PADCFG2_DEBOUNCE_MASK\t\tGENMASK(4, 1)\n#define PADCFG2_DEBEN\t\t\tBIT(0)\n\n#define DEBOUNCE_PERIOD_NSEC\t\t31250\n\nstruct intel_pad_context {\n\tu32 padcfg0;\n\tu32 padcfg1;\n\tu32 padcfg2;\n};\n\nstruct intel_community_context {\n\tu32 *intmask;\n\tu32 *hostown;\n};\n\n#define pin_to_padno(c, p)\t((p) - (c)->pin_base)\n#define padgroup_offset(g, p)\t((p) - (g)->base)\n\nstruct intel_community *intel_get_community(struct intel_pinctrl *pctrl, unsigned int pin)\n{\n\tstruct intel_community *community;\n\tint i;\n\n\tfor (i = 0; i < pctrl->ncommunities; i++) {\n\t\tcommunity = &pctrl->communities[i];\n\t\tif (pin >= community->pin_base &&\n\t\t    pin < community->pin_base + community->npins)\n\t\t\treturn community;\n\t}\n\n\tdev_warn(pctrl->dev, \"failed to find community for pin %u\\n\", pin);\n\treturn NULL;\n}\nEXPORT_SYMBOL_NS_GPL(intel_get_community, PINCTRL_INTEL);\n\nstatic const struct intel_padgroup *\nintel_community_get_padgroup(const struct intel_community *community,\n\t\t\t     unsigned int pin)\n{\n\tint i;\n\n\tfor (i = 0; i < community->ngpps; i++) {\n\t\tconst struct intel_padgroup *padgrp = &community->gpps[i];\n\n\t\tif (pin >= padgrp->base && pin < padgrp->base + padgrp->size)\n\t\t\treturn padgrp;\n\t}\n\n\treturn NULL;\n}\n\nstatic void __iomem *intel_get_padcfg(struct intel_pinctrl *pctrl,\n\t\t\t\t      unsigned int pin, unsigned int reg)\n{\n\tconst struct intel_community *community;\n\tunsigned int padno;\n\tsize_t nregs;\n\n\tcommunity = intel_get_community(pctrl, pin);\n\tif (!community)\n\t\treturn NULL;\n\n\tpadno = pin_to_padno(community, pin);\n\tnregs = (community->features & PINCTRL_FEATURE_DEBOUNCE) ? 4 : 2;\n\n\tif (reg >= nregs * 4)\n\t\treturn NULL;\n\n\treturn community->pad_regs + reg + padno * nregs * 4;\n}\n\nstatic bool intel_pad_owned_by_host(struct intel_pinctrl *pctrl, unsigned int pin)\n{\n\tconst struct intel_community *community;\n\tconst struct intel_padgroup *padgrp;\n\tunsigned int gpp, offset, gpp_offset;\n\tvoid __iomem *padown;\n\n\tcommunity = intel_get_community(pctrl, pin);\n\tif (!community)\n\t\treturn false;\n\tif (!community->padown_offset)\n\t\treturn true;\n\n\tpadgrp = intel_community_get_padgroup(community, pin);\n\tif (!padgrp)\n\t\treturn false;\n\n\tgpp_offset = padgroup_offset(padgrp, pin);\n\tgpp = PADOWN_GPP(gpp_offset);\n\toffset = community->padown_offset + padgrp->padown_num * 4 + gpp * 4;\n\tpadown = community->regs + offset;\n\n\treturn !(readl(padown) & PADOWN_MASK(gpp_offset));\n}\n\nstatic bool intel_pad_acpi_mode(struct intel_pinctrl *pctrl, unsigned int pin)\n{\n\tconst struct intel_community *community;\n\tconst struct intel_padgroup *padgrp;\n\tunsigned int offset, gpp_offset;\n\tvoid __iomem *hostown;\n\n\tcommunity = intel_get_community(pctrl, pin);\n\tif (!community)\n\t\treturn true;\n\tif (!community->hostown_offset)\n\t\treturn false;\n\n\tpadgrp = intel_community_get_padgroup(community, pin);\n\tif (!padgrp)\n\t\treturn true;\n\n\tgpp_offset = padgroup_offset(padgrp, pin);\n\toffset = community->hostown_offset + padgrp->reg_num * 4;\n\thostown = community->regs + offset;\n\n\treturn !(readl(hostown) & BIT(gpp_offset));\n}\n\n \nenum {\n\tPAD_UNLOCKED\t= 0,\n\tPAD_LOCKED\t= 1,\n\tPAD_LOCKED_TX\t= 2,\n\tPAD_LOCKED_FULL\t= PAD_LOCKED | PAD_LOCKED_TX,\n};\n\nstatic int intel_pad_locked(struct intel_pinctrl *pctrl, unsigned int pin)\n{\n\tstruct intel_community *community;\n\tconst struct intel_padgroup *padgrp;\n\tunsigned int offset, gpp_offset;\n\tu32 value;\n\tint ret = PAD_UNLOCKED;\n\n\tcommunity = intel_get_community(pctrl, pin);\n\tif (!community)\n\t\treturn PAD_LOCKED_FULL;\n\tif (!community->padcfglock_offset)\n\t\treturn PAD_UNLOCKED;\n\n\tpadgrp = intel_community_get_padgroup(community, pin);\n\tif (!padgrp)\n\t\treturn PAD_LOCKED_FULL;\n\n\tgpp_offset = padgroup_offset(padgrp, pin);\n\n\t \n\toffset = community->padcfglock_offset + 0 + padgrp->reg_num * 8;\n\tvalue = readl(community->regs + offset);\n\tif (value & BIT(gpp_offset))\n\t\tret |= PAD_LOCKED;\n\n\toffset = community->padcfglock_offset + 4 + padgrp->reg_num * 8;\n\tvalue = readl(community->regs + offset);\n\tif (value & BIT(gpp_offset))\n\t\tret |= PAD_LOCKED_TX;\n\n\treturn ret;\n}\n\nstatic bool intel_pad_is_unlocked(struct intel_pinctrl *pctrl, unsigned int pin)\n{\n\treturn (intel_pad_locked(pctrl, pin) & PAD_LOCKED) == PAD_UNLOCKED;\n}\n\nstatic bool intel_pad_usable(struct intel_pinctrl *pctrl, unsigned int pin)\n{\n\treturn intel_pad_owned_by_host(pctrl, pin) && intel_pad_is_unlocked(pctrl, pin);\n}\n\nint intel_get_groups_count(struct pinctrl_dev *pctldev)\n{\n\tstruct intel_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pctrl->soc->ngroups;\n}\nEXPORT_SYMBOL_NS_GPL(intel_get_groups_count, PINCTRL_INTEL);\n\nconst char *intel_get_group_name(struct pinctrl_dev *pctldev, unsigned int group)\n{\n\tstruct intel_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pctrl->soc->groups[group].grp.name;\n}\nEXPORT_SYMBOL_NS_GPL(intel_get_group_name, PINCTRL_INTEL);\n\nint intel_get_group_pins(struct pinctrl_dev *pctldev, unsigned int group,\n\t\t\t const unsigned int **pins, unsigned int *npins)\n{\n\tstruct intel_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\n\t*pins = pctrl->soc->groups[group].grp.pins;\n\t*npins = pctrl->soc->groups[group].grp.npins;\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(intel_get_group_pins, PINCTRL_INTEL);\n\nstatic void intel_pin_dbg_show(struct pinctrl_dev *pctldev, struct seq_file *s,\n\t\t\t       unsigned int pin)\n{\n\tstruct intel_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\tvoid __iomem *padcfg;\n\tu32 cfg0, cfg1, mode;\n\tint locked;\n\tbool acpi;\n\n\tif (!intel_pad_owned_by_host(pctrl, pin)) {\n\t\tseq_puts(s, \"not available\");\n\t\treturn;\n\t}\n\n\tcfg0 = readl(intel_get_padcfg(pctrl, pin, PADCFG0));\n\tcfg1 = readl(intel_get_padcfg(pctrl, pin, PADCFG1));\n\n\tmode = (cfg0 & PADCFG0_PMODE_MASK) >> PADCFG0_PMODE_SHIFT;\n\tif (mode == PADCFG0_PMODE_GPIO)\n\t\tseq_puts(s, \"GPIO \");\n\telse\n\t\tseq_printf(s, \"mode %d \", mode);\n\n\tseq_printf(s, \"0x%08x 0x%08x\", cfg0, cfg1);\n\n\t \n\tpadcfg = intel_get_padcfg(pctrl, pin, PADCFG2);\n\tif (padcfg)\n\t\tseq_printf(s, \" 0x%08x\", readl(padcfg));\n\n\tlocked = intel_pad_locked(pctrl, pin);\n\tacpi = intel_pad_acpi_mode(pctrl, pin);\n\n\tif (locked || acpi) {\n\t\tseq_puts(s, \" [\");\n\t\tif (locked)\n\t\t\tseq_puts(s, \"LOCKED\");\n\t\tif ((locked & PAD_LOCKED_FULL) == PAD_LOCKED_TX)\n\t\t\tseq_puts(s, \" tx\");\n\t\telse if ((locked & PAD_LOCKED_FULL) == PAD_LOCKED_FULL)\n\t\t\tseq_puts(s, \" full\");\n\n\t\tif (locked && acpi)\n\t\t\tseq_puts(s, \", \");\n\n\t\tif (acpi)\n\t\t\tseq_puts(s, \"ACPI\");\n\t\tseq_puts(s, \"]\");\n\t}\n}\n\nstatic const struct pinctrl_ops intel_pinctrl_ops = {\n\t.get_groups_count = intel_get_groups_count,\n\t.get_group_name = intel_get_group_name,\n\t.get_group_pins = intel_get_group_pins,\n\t.pin_dbg_show = intel_pin_dbg_show,\n};\n\nint intel_get_functions_count(struct pinctrl_dev *pctldev)\n{\n\tstruct intel_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pctrl->soc->nfunctions;\n}\nEXPORT_SYMBOL_NS_GPL(intel_get_functions_count, PINCTRL_INTEL);\n\nconst char *intel_get_function_name(struct pinctrl_dev *pctldev, unsigned int function)\n{\n\tstruct intel_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pctrl->soc->functions[function].func.name;\n}\nEXPORT_SYMBOL_NS_GPL(intel_get_function_name, PINCTRL_INTEL);\n\nint intel_get_function_groups(struct pinctrl_dev *pctldev, unsigned int function,\n\t\t\t      const char * const **groups, unsigned int * const ngroups)\n{\n\tstruct intel_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\n\t*groups = pctrl->soc->functions[function].func.groups;\n\t*ngroups = pctrl->soc->functions[function].func.ngroups;\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(intel_get_function_groups, PINCTRL_INTEL);\n\nstatic int intel_pinmux_set_mux(struct pinctrl_dev *pctldev,\n\t\t\t\tunsigned int function, unsigned int group)\n{\n\tstruct intel_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct intel_pingroup *grp = &pctrl->soc->groups[group];\n\tunsigned long flags;\n\tint i;\n\n\traw_spin_lock_irqsave(&pctrl->lock, flags);\n\n\t \n\tfor (i = 0; i < grp->grp.npins; i++) {\n\t\tif (!intel_pad_usable(pctrl, grp->grp.pins[i])) {\n\t\t\traw_spin_unlock_irqrestore(&pctrl->lock, flags);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < grp->grp.npins; i++) {\n\t\tvoid __iomem *padcfg0;\n\t\tu32 value, pmode;\n\n\t\tpadcfg0 = intel_get_padcfg(pctrl, grp->grp.pins[i], PADCFG0);\n\n\t\tvalue = readl(padcfg0);\n\t\tvalue &= ~PADCFG0_PMODE_MASK;\n\n\t\tif (grp->modes)\n\t\t\tpmode = grp->modes[i];\n\t\telse\n\t\t\tpmode = grp->mode;\n\n\t\tvalue |= pmode << PADCFG0_PMODE_SHIFT;\n\t\twritel(value, padcfg0);\n\t}\n\n\traw_spin_unlock_irqrestore(&pctrl->lock, flags);\n\n\treturn 0;\n}\n\nstatic void __intel_gpio_set_direction(void __iomem *padcfg0, bool input)\n{\n\tu32 value;\n\n\tvalue = readl(padcfg0);\n\tif (input) {\n\t\tvalue &= ~PADCFG0_GPIORXDIS;\n\t\tvalue |= PADCFG0_GPIOTXDIS;\n\t} else {\n\t\tvalue &= ~PADCFG0_GPIOTXDIS;\n\t\tvalue |= PADCFG0_GPIORXDIS;\n\t}\n\twritel(value, padcfg0);\n}\n\nstatic int __intel_gpio_get_gpio_mode(u32 value)\n{\n\treturn (value & PADCFG0_PMODE_MASK) >> PADCFG0_PMODE_SHIFT;\n}\n\nstatic int intel_gpio_get_gpio_mode(void __iomem *padcfg0)\n{\n\treturn __intel_gpio_get_gpio_mode(readl(padcfg0));\n}\n\nstatic void intel_gpio_set_gpio_mode(void __iomem *padcfg0)\n{\n\tu32 value;\n\n\tvalue = readl(padcfg0);\n\n\t \n\tvalue &= ~PADCFG0_PMODE_MASK;\n\tvalue |= PADCFG0_PMODE_GPIO;\n\n\t \n\tvalue &= ~PADCFG0_GPIORXDIS;\n\tvalue |= PADCFG0_GPIOTXDIS;\n\n\t \n\tvalue &= ~(PADCFG0_GPIROUTIOXAPIC | PADCFG0_GPIROUTSCI);\n\tvalue &= ~(PADCFG0_GPIROUTSMI | PADCFG0_GPIROUTNMI);\n\n\twritel(value, padcfg0);\n}\n\nstatic int intel_gpio_request_enable(struct pinctrl_dev *pctldev,\n\t\t\t\t     struct pinctrl_gpio_range *range,\n\t\t\t\t     unsigned int pin)\n{\n\tstruct intel_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\tvoid __iomem *padcfg0;\n\tunsigned long flags;\n\n\tpadcfg0 = intel_get_padcfg(pctrl, pin, PADCFG0);\n\n\traw_spin_lock_irqsave(&pctrl->lock, flags);\n\n\tif (!intel_pad_owned_by_host(pctrl, pin)) {\n\t\traw_spin_unlock_irqrestore(&pctrl->lock, flags);\n\t\treturn -EBUSY;\n\t}\n\n\tif (!intel_pad_is_unlocked(pctrl, pin)) {\n\t\traw_spin_unlock_irqrestore(&pctrl->lock, flags);\n\t\treturn 0;\n\t}\n\n\t \n\tif (intel_gpio_get_gpio_mode(padcfg0) == PADCFG0_PMODE_GPIO) {\n\t\traw_spin_unlock_irqrestore(&pctrl->lock, flags);\n\t\treturn 0;\n\t}\n\n\tintel_gpio_set_gpio_mode(padcfg0);\n\n\traw_spin_unlock_irqrestore(&pctrl->lock, flags);\n\n\treturn 0;\n}\n\nstatic int intel_gpio_set_direction(struct pinctrl_dev *pctldev,\n\t\t\t\t    struct pinctrl_gpio_range *range,\n\t\t\t\t    unsigned int pin, bool input)\n{\n\tstruct intel_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\tvoid __iomem *padcfg0;\n\tunsigned long flags;\n\n\tpadcfg0 = intel_get_padcfg(pctrl, pin, PADCFG0);\n\n\traw_spin_lock_irqsave(&pctrl->lock, flags);\n\t__intel_gpio_set_direction(padcfg0, input);\n\traw_spin_unlock_irqrestore(&pctrl->lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct pinmux_ops intel_pinmux_ops = {\n\t.get_functions_count = intel_get_functions_count,\n\t.get_function_name = intel_get_function_name,\n\t.get_function_groups = intel_get_function_groups,\n\t.set_mux = intel_pinmux_set_mux,\n\t.gpio_request_enable = intel_gpio_request_enable,\n\t.gpio_set_direction = intel_gpio_set_direction,\n};\n\nstatic int intel_config_get_pull(struct intel_pinctrl *pctrl, unsigned int pin,\n\t\t\t\t enum pin_config_param param, u32 *arg)\n{\n\tconst struct intel_community *community;\n\tvoid __iomem *padcfg1;\n\tunsigned long flags;\n\tu32 value, term;\n\n\tcommunity = intel_get_community(pctrl, pin);\n\tpadcfg1 = intel_get_padcfg(pctrl, pin, PADCFG1);\n\n\traw_spin_lock_irqsave(&pctrl->lock, flags);\n\tvalue = readl(padcfg1);\n\traw_spin_unlock_irqrestore(&pctrl->lock, flags);\n\n\tterm = (value & PADCFG1_TERM_MASK) >> PADCFG1_TERM_SHIFT;\n\n\tswitch (param) {\n\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\tif (term)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\tif (!term || !(value & PADCFG1_TERM_UP))\n\t\t\treturn -EINVAL;\n\n\t\tswitch (term) {\n\t\tcase PADCFG1_TERM_833:\n\t\t\t*arg = 833;\n\t\t\tbreak;\n\t\tcase PADCFG1_TERM_1K:\n\t\t\t*arg = 1000;\n\t\t\tbreak;\n\t\tcase PADCFG1_TERM_4K:\n\t\t\t*arg = 4000;\n\t\t\tbreak;\n\t\tcase PADCFG1_TERM_5K:\n\t\t\t*arg = 5000;\n\t\t\tbreak;\n\t\tcase PADCFG1_TERM_20K:\n\t\t\t*arg = 20000;\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\tif (!term || value & PADCFG1_TERM_UP)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (term) {\n\t\tcase PADCFG1_TERM_833:\n\t\t\tif (!(community->features & PINCTRL_FEATURE_1K_PD))\n\t\t\t\treturn -EINVAL;\n\t\t\t*arg = 833;\n\t\t\tbreak;\n\t\tcase PADCFG1_TERM_1K:\n\t\t\tif (!(community->features & PINCTRL_FEATURE_1K_PD))\n\t\t\t\treturn -EINVAL;\n\t\t\t*arg = 1000;\n\t\t\tbreak;\n\t\tcase PADCFG1_TERM_4K:\n\t\t\t*arg = 4000;\n\t\t\tbreak;\n\t\tcase PADCFG1_TERM_5K:\n\t\t\t*arg = 5000;\n\t\t\tbreak;\n\t\tcase PADCFG1_TERM_20K:\n\t\t\t*arg = 20000;\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int intel_config_get_debounce(struct intel_pinctrl *pctrl, unsigned int pin,\n\t\t\t\t     enum pin_config_param param, u32 *arg)\n{\n\tvoid __iomem *padcfg2;\n\tunsigned long flags;\n\tunsigned long v;\n\tu32 value2;\n\n\tpadcfg2 = intel_get_padcfg(pctrl, pin, PADCFG2);\n\tif (!padcfg2)\n\t\treturn -ENOTSUPP;\n\n\traw_spin_lock_irqsave(&pctrl->lock, flags);\n\tvalue2 = readl(padcfg2);\n\traw_spin_unlock_irqrestore(&pctrl->lock, flags);\n\tif (!(value2 & PADCFG2_DEBEN))\n\t\treturn -EINVAL;\n\n\tv = (value2 & PADCFG2_DEBOUNCE_MASK) >> PADCFG2_DEBOUNCE_SHIFT;\n\t*arg = BIT(v) * DEBOUNCE_PERIOD_NSEC / NSEC_PER_USEC;\n\n\treturn 0;\n}\n\nstatic int intel_config_get(struct pinctrl_dev *pctldev, unsigned int pin,\n\t\t\t    unsigned long *config)\n{\n\tstruct intel_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\tenum pin_config_param param = pinconf_to_config_param(*config);\n\tu32 arg = 0;\n\tint ret;\n\n\tif (!intel_pad_owned_by_host(pctrl, pin))\n\t\treturn -ENOTSUPP;\n\n\tswitch (param) {\n\tcase PIN_CONFIG_BIAS_DISABLE:\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\tret = intel_config_get_pull(pctrl, pin, param, &arg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\n\tcase PIN_CONFIG_INPUT_DEBOUNCE:\n\t\tret = intel_config_get_debounce(pctrl, pin, param, &arg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\t*config = pinconf_to_config_packed(param, arg);\n\treturn 0;\n}\n\nstatic int intel_config_set_pull(struct intel_pinctrl *pctrl, unsigned int pin,\n\t\t\t\t unsigned long config)\n{\n\tunsigned int param = pinconf_to_config_param(config);\n\tunsigned int arg = pinconf_to_config_argument(config);\n\tconst struct intel_community *community;\n\tvoid __iomem *padcfg1;\n\tunsigned long flags;\n\tint ret = 0;\n\tu32 value;\n\n\tcommunity = intel_get_community(pctrl, pin);\n\tpadcfg1 = intel_get_padcfg(pctrl, pin, PADCFG1);\n\n\traw_spin_lock_irqsave(&pctrl->lock, flags);\n\n\tvalue = readl(padcfg1);\n\tvalue &= ~(PADCFG1_TERM_MASK | PADCFG1_TERM_UP);\n\n\t \n\tif (arg == 1)\n\t\targ = 5000;\n\n\tswitch (param) {\n\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\tbreak;\n\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\tswitch (arg) {\n\t\tcase 20000:\n\t\t\tvalue |= PADCFG1_TERM_20K << PADCFG1_TERM_SHIFT;\n\t\t\tbreak;\n\t\tcase 5000:\n\t\t\tvalue |= PADCFG1_TERM_5K << PADCFG1_TERM_SHIFT;\n\t\t\tbreak;\n\t\tcase 4000:\n\t\t\tvalue |= PADCFG1_TERM_4K << PADCFG1_TERM_SHIFT;\n\t\t\tbreak;\n\t\tcase 1000:\n\t\t\tvalue |= PADCFG1_TERM_1K << PADCFG1_TERM_SHIFT;\n\t\t\tbreak;\n\t\tcase 833:\n\t\t\tvalue |= PADCFG1_TERM_833 << PADCFG1_TERM_SHIFT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tvalue |= PADCFG1_TERM_UP;\n\t\tbreak;\n\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\tswitch (arg) {\n\t\tcase 20000:\n\t\t\tvalue |= PADCFG1_TERM_20K << PADCFG1_TERM_SHIFT;\n\t\t\tbreak;\n\t\tcase 5000:\n\t\t\tvalue |= PADCFG1_TERM_5K << PADCFG1_TERM_SHIFT;\n\t\t\tbreak;\n\t\tcase 4000:\n\t\t\tvalue |= PADCFG1_TERM_4K << PADCFG1_TERM_SHIFT;\n\t\t\tbreak;\n\t\tcase 1000:\n\t\t\tif (!(community->features & PINCTRL_FEATURE_1K_PD)) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvalue |= PADCFG1_TERM_1K << PADCFG1_TERM_SHIFT;\n\t\t\tbreak;\n\t\tcase 833:\n\t\t\tif (!(community->features & PINCTRL_FEATURE_1K_PD)) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvalue |= PADCFG1_TERM_833 << PADCFG1_TERM_SHIFT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (!ret)\n\t\twritel(value, padcfg1);\n\n\traw_spin_unlock_irqrestore(&pctrl->lock, flags);\n\n\treturn ret;\n}\n\nstatic int intel_config_set_debounce(struct intel_pinctrl *pctrl,\n\t\t\t\t     unsigned int pin, unsigned int debounce)\n{\n\tvoid __iomem *padcfg0, *padcfg2;\n\tunsigned long flags;\n\tu32 value0, value2;\n\n\tpadcfg2 = intel_get_padcfg(pctrl, pin, PADCFG2);\n\tif (!padcfg2)\n\t\treturn -ENOTSUPP;\n\n\tpadcfg0 = intel_get_padcfg(pctrl, pin, PADCFG0);\n\n\traw_spin_lock_irqsave(&pctrl->lock, flags);\n\n\tvalue0 = readl(padcfg0);\n\tvalue2 = readl(padcfg2);\n\n\t \n\tvalue0 &= ~PADCFG0_PREGFRXSEL;\n\tvalue2 &= ~(PADCFG2_DEBEN | PADCFG2_DEBOUNCE_MASK);\n\n\tif (debounce) {\n\t\tunsigned long v;\n\n\t\tv = order_base_2(debounce * NSEC_PER_USEC / DEBOUNCE_PERIOD_NSEC);\n\t\tif (v < 3 || v > 15) {\n\t\t\traw_spin_unlock_irqrestore(&pctrl->lock, flags);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tvalue0 |= PADCFG0_PREGFRXSEL;\n\t\tvalue2 |= v << PADCFG2_DEBOUNCE_SHIFT;\n\t\tvalue2 |= PADCFG2_DEBEN;\n\t}\n\n\twritel(value0, padcfg0);\n\twritel(value2, padcfg2);\n\n\traw_spin_unlock_irqrestore(&pctrl->lock, flags);\n\n\treturn 0;\n}\n\nstatic int intel_config_set(struct pinctrl_dev *pctldev, unsigned int pin,\n\t\t\t  unsigned long *configs, unsigned int nconfigs)\n{\n\tstruct intel_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\tint i, ret;\n\n\tif (!intel_pad_usable(pctrl, pin))\n\t\treturn -ENOTSUPP;\n\n\tfor (i = 0; i < nconfigs; i++) {\n\t\tswitch (pinconf_to_config_param(configs[i])) {\n\t\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\t\tret = intel_config_set_pull(pctrl, pin, configs[i]);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\n\t\tcase PIN_CONFIG_INPUT_DEBOUNCE:\n\t\t\tret = intel_config_set_debounce(pctrl, pin,\n\t\t\t\tpinconf_to_config_argument(configs[i]));\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct pinconf_ops intel_pinconf_ops = {\n\t.is_generic = true,\n\t.pin_config_get = intel_config_get,\n\t.pin_config_set = intel_config_set,\n};\n\nstatic const struct pinctrl_desc intel_pinctrl_desc = {\n\t.pctlops = &intel_pinctrl_ops,\n\t.pmxops = &intel_pinmux_ops,\n\t.confops = &intel_pinconf_ops,\n\t.owner = THIS_MODULE,\n};\n\n \nstatic int intel_gpio_to_pin(struct intel_pinctrl *pctrl, unsigned int offset,\n\t\t\t     const struct intel_community **community,\n\t\t\t     const struct intel_padgroup **padgrp)\n{\n\tint i;\n\n\tfor (i = 0; i < pctrl->ncommunities; i++) {\n\t\tconst struct intel_community *comm = &pctrl->communities[i];\n\t\tint j;\n\n\t\tfor (j = 0; j < comm->ngpps; j++) {\n\t\t\tconst struct intel_padgroup *pgrp = &comm->gpps[j];\n\n\t\t\tif (pgrp->gpio_base == INTEL_GPIO_BASE_NOMAP)\n\t\t\t\tcontinue;\n\n\t\t\tif (offset >= pgrp->gpio_base &&\n\t\t\t    offset < pgrp->gpio_base + pgrp->size) {\n\t\t\t\tint pin;\n\n\t\t\t\tpin = pgrp->base + offset - pgrp->gpio_base;\n\t\t\t\tif (community)\n\t\t\t\t\t*community = comm;\n\t\t\t\tif (padgrp)\n\t\t\t\t\t*padgrp = pgrp;\n\n\t\t\t\treturn pin;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\n \nstatic __maybe_unused int intel_pin_to_gpio(struct intel_pinctrl *pctrl, int pin)\n{\n\tconst struct intel_community *community;\n\tconst struct intel_padgroup *padgrp;\n\n\tcommunity = intel_get_community(pctrl, pin);\n\tif (!community)\n\t\treturn -EINVAL;\n\n\tpadgrp = intel_community_get_padgroup(community, pin);\n\tif (!padgrp)\n\t\treturn -EINVAL;\n\n\treturn pin - padgrp->base + padgrp->gpio_base;\n}\n\nstatic int intel_gpio_get(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct intel_pinctrl *pctrl = gpiochip_get_data(chip);\n\tvoid __iomem *reg;\n\tu32 padcfg0;\n\tint pin;\n\n\tpin = intel_gpio_to_pin(pctrl, offset, NULL, NULL);\n\tif (pin < 0)\n\t\treturn -EINVAL;\n\n\treg = intel_get_padcfg(pctrl, pin, PADCFG0);\n\tif (!reg)\n\t\treturn -EINVAL;\n\n\tpadcfg0 = readl(reg);\n\tif (!(padcfg0 & PADCFG0_GPIOTXDIS))\n\t\treturn !!(padcfg0 & PADCFG0_GPIOTXSTATE);\n\n\treturn !!(padcfg0 & PADCFG0_GPIORXSTATE);\n}\n\nstatic void intel_gpio_set(struct gpio_chip *chip, unsigned int offset,\n\t\t\t   int value)\n{\n\tstruct intel_pinctrl *pctrl = gpiochip_get_data(chip);\n\tunsigned long flags;\n\tvoid __iomem *reg;\n\tu32 padcfg0;\n\tint pin;\n\n\tpin = intel_gpio_to_pin(pctrl, offset, NULL, NULL);\n\tif (pin < 0)\n\t\treturn;\n\n\treg = intel_get_padcfg(pctrl, pin, PADCFG0);\n\tif (!reg)\n\t\treturn;\n\n\traw_spin_lock_irqsave(&pctrl->lock, flags);\n\tpadcfg0 = readl(reg);\n\tif (value)\n\t\tpadcfg0 |= PADCFG0_GPIOTXSTATE;\n\telse\n\t\tpadcfg0 &= ~PADCFG0_GPIOTXSTATE;\n\twritel(padcfg0, reg);\n\traw_spin_unlock_irqrestore(&pctrl->lock, flags);\n}\n\nstatic int intel_gpio_get_direction(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct intel_pinctrl *pctrl = gpiochip_get_data(chip);\n\tunsigned long flags;\n\tvoid __iomem *reg;\n\tu32 padcfg0;\n\tint pin;\n\n\tpin = intel_gpio_to_pin(pctrl, offset, NULL, NULL);\n\tif (pin < 0)\n\t\treturn -EINVAL;\n\n\treg = intel_get_padcfg(pctrl, pin, PADCFG0);\n\tif (!reg)\n\t\treturn -EINVAL;\n\n\traw_spin_lock_irqsave(&pctrl->lock, flags);\n\tpadcfg0 = readl(reg);\n\traw_spin_unlock_irqrestore(&pctrl->lock, flags);\n\tif (padcfg0 & PADCFG0_PMODE_MASK)\n\t\treturn -EINVAL;\n\n\tif (padcfg0 & PADCFG0_GPIOTXDIS)\n\t\treturn GPIO_LINE_DIRECTION_IN;\n\n\treturn GPIO_LINE_DIRECTION_OUT;\n}\n\nstatic int intel_gpio_direction_input(struct gpio_chip *chip, unsigned int offset)\n{\n\treturn pinctrl_gpio_direction_input(chip->base + offset);\n}\n\nstatic int intel_gpio_direction_output(struct gpio_chip *chip, unsigned int offset,\n\t\t\t\t       int value)\n{\n\tintel_gpio_set(chip, offset, value);\n\treturn pinctrl_gpio_direction_output(chip->base + offset);\n}\n\nstatic const struct gpio_chip intel_gpio_chip = {\n\t.owner = THIS_MODULE,\n\t.request = gpiochip_generic_request,\n\t.free = gpiochip_generic_free,\n\t.get_direction = intel_gpio_get_direction,\n\t.direction_input = intel_gpio_direction_input,\n\t.direction_output = intel_gpio_direction_output,\n\t.get = intel_gpio_get,\n\t.set = intel_gpio_set,\n\t.set_config = gpiochip_generic_config,\n};\n\nstatic void intel_gpio_irq_ack(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct intel_pinctrl *pctrl = gpiochip_get_data(gc);\n\tconst struct intel_community *community;\n\tconst struct intel_padgroup *padgrp;\n\tint pin;\n\n\tpin = intel_gpio_to_pin(pctrl, irqd_to_hwirq(d), &community, &padgrp);\n\tif (pin >= 0) {\n\t\tunsigned int gpp, gpp_offset, is_offset;\n\n\t\tgpp = padgrp->reg_num;\n\t\tgpp_offset = padgroup_offset(padgrp, pin);\n\t\tis_offset = community->is_offset + gpp * 4;\n\n\t\traw_spin_lock(&pctrl->lock);\n\t\twritel(BIT(gpp_offset), community->regs + is_offset);\n\t\traw_spin_unlock(&pctrl->lock);\n\t}\n}\n\nstatic void intel_gpio_irq_mask_unmask(struct gpio_chip *gc, irq_hw_number_t hwirq, bool mask)\n{\n\tstruct intel_pinctrl *pctrl = gpiochip_get_data(gc);\n\tconst struct intel_community *community;\n\tconst struct intel_padgroup *padgrp;\n\tint pin;\n\n\tpin = intel_gpio_to_pin(pctrl, hwirq, &community, &padgrp);\n\tif (pin >= 0) {\n\t\tunsigned int gpp, gpp_offset;\n\t\tunsigned long flags;\n\t\tvoid __iomem *reg, *is;\n\t\tu32 value;\n\n\t\tgpp = padgrp->reg_num;\n\t\tgpp_offset = padgroup_offset(padgrp, pin);\n\n\t\treg = community->regs + community->ie_offset + gpp * 4;\n\t\tis = community->regs + community->is_offset + gpp * 4;\n\n\t\traw_spin_lock_irqsave(&pctrl->lock, flags);\n\n\t\t \n\t\twritel(BIT(gpp_offset), is);\n\n\t\tvalue = readl(reg);\n\t\tif (mask)\n\t\t\tvalue &= ~BIT(gpp_offset);\n\t\telse\n\t\t\tvalue |= BIT(gpp_offset);\n\t\twritel(value, reg);\n\t\traw_spin_unlock_irqrestore(&pctrl->lock, flags);\n\t}\n}\n\nstatic void intel_gpio_irq_mask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tirq_hw_number_t hwirq = irqd_to_hwirq(d);\n\n\tintel_gpio_irq_mask_unmask(gc, hwirq, true);\n\tgpiochip_disable_irq(gc, hwirq);\n}\n\nstatic void intel_gpio_irq_unmask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tirq_hw_number_t hwirq = irqd_to_hwirq(d);\n\n\tgpiochip_enable_irq(gc, hwirq);\n\tintel_gpio_irq_mask_unmask(gc, hwirq, false);\n}\n\nstatic int intel_gpio_irq_type(struct irq_data *d, unsigned int type)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct intel_pinctrl *pctrl = gpiochip_get_data(gc);\n\tunsigned int pin = intel_gpio_to_pin(pctrl, irqd_to_hwirq(d), NULL, NULL);\n\tu32 rxevcfg, rxinv, value;\n\tunsigned long flags;\n\tvoid __iomem *reg;\n\n\treg = intel_get_padcfg(pctrl, pin, PADCFG0);\n\tif (!reg)\n\t\treturn -EINVAL;\n\n\t \n\tif (intel_pad_acpi_mode(pctrl, pin)) {\n\t\tdev_warn(pctrl->dev, \"pin %u cannot be used as IRQ\\n\", pin);\n\t\treturn -EPERM;\n\t}\n\n\tif ((type & IRQ_TYPE_EDGE_BOTH) == IRQ_TYPE_EDGE_BOTH) {\n\t\trxevcfg = PADCFG0_RXEVCFG_EDGE_BOTH;\n\t} else if (type & IRQ_TYPE_EDGE_FALLING) {\n\t\trxevcfg = PADCFG0_RXEVCFG_EDGE;\n\t} else if (type & IRQ_TYPE_EDGE_RISING) {\n\t\trxevcfg = PADCFG0_RXEVCFG_EDGE;\n\t} else if (type & IRQ_TYPE_LEVEL_MASK) {\n\t\trxevcfg = PADCFG0_RXEVCFG_LEVEL;\n\t} else {\n\t\trxevcfg = PADCFG0_RXEVCFG_DISABLED;\n\t}\n\n\tif (type == IRQ_TYPE_EDGE_FALLING || type == IRQ_TYPE_LEVEL_LOW)\n\t\trxinv = PADCFG0_RXINV;\n\telse\n\t\trxinv = 0;\n\n\traw_spin_lock_irqsave(&pctrl->lock, flags);\n\n\tintel_gpio_set_gpio_mode(reg);\n\n\tvalue = readl(reg);\n\n\tvalue = (value & ~PADCFG0_RXEVCFG_MASK) | rxevcfg;\n\tvalue = (value & ~PADCFG0_RXINV) | rxinv;\n\n\twritel(value, reg);\n\n\tif (type & IRQ_TYPE_EDGE_BOTH)\n\t\tirq_set_handler_locked(d, handle_edge_irq);\n\telse if (type & IRQ_TYPE_LEVEL_MASK)\n\t\tirq_set_handler_locked(d, handle_level_irq);\n\n\traw_spin_unlock_irqrestore(&pctrl->lock, flags);\n\n\treturn 0;\n}\n\nstatic int intel_gpio_irq_wake(struct irq_data *d, unsigned int on)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct intel_pinctrl *pctrl = gpiochip_get_data(gc);\n\tunsigned int pin = intel_gpio_to_pin(pctrl, irqd_to_hwirq(d), NULL, NULL);\n\n\tif (on)\n\t\tenable_irq_wake(pctrl->irq);\n\telse\n\t\tdisable_irq_wake(pctrl->irq);\n\n\tdev_dbg(pctrl->dev, \"%s wake for pin %u\\n\", str_enable_disable(on), pin);\n\treturn 0;\n}\n\nstatic const struct irq_chip intel_gpio_irq_chip = {\n\t.name = \"intel-gpio\",\n\t.irq_ack = intel_gpio_irq_ack,\n\t.irq_mask = intel_gpio_irq_mask,\n\t.irq_unmask = intel_gpio_irq_unmask,\n\t.irq_set_type = intel_gpio_irq_type,\n\t.irq_set_wake = intel_gpio_irq_wake,\n\t.flags = IRQCHIP_MASK_ON_SUSPEND | IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic int intel_gpio_community_irq_handler(struct intel_pinctrl *pctrl,\n\t\t\t\t\t    const struct intel_community *community)\n{\n\tstruct gpio_chip *gc = &pctrl->chip;\n\tunsigned int gpp;\n\tint ret = 0;\n\n\tfor (gpp = 0; gpp < community->ngpps; gpp++) {\n\t\tconst struct intel_padgroup *padgrp = &community->gpps[gpp];\n\t\tunsigned long pending, enabled, gpp_offset;\n\n\t\traw_spin_lock(&pctrl->lock);\n\n\t\tpending = readl(community->regs + community->is_offset +\n\t\t\t\tpadgrp->reg_num * 4);\n\t\tenabled = readl(community->regs + community->ie_offset +\n\t\t\t\tpadgrp->reg_num * 4);\n\n\t\traw_spin_unlock(&pctrl->lock);\n\n\t\t \n\t\tpending &= enabled;\n\n\t\tfor_each_set_bit(gpp_offset, &pending, padgrp->size)\n\t\t\tgeneric_handle_domain_irq(gc->irq.domain, padgrp->gpio_base + gpp_offset);\n\n\t\tret += pending ? 1 : 0;\n\t}\n\n\treturn ret;\n}\n\nstatic irqreturn_t intel_gpio_irq(int irq, void *data)\n{\n\tconst struct intel_community *community;\n\tstruct intel_pinctrl *pctrl = data;\n\tunsigned int i;\n\tint ret = 0;\n\n\t \n\tfor (i = 0; i < pctrl->ncommunities; i++) {\n\t\tcommunity = &pctrl->communities[i];\n\t\tret += intel_gpio_community_irq_handler(pctrl, community);\n\t}\n\n\treturn IRQ_RETVAL(ret);\n}\n\nstatic void intel_gpio_irq_init(struct intel_pinctrl *pctrl)\n{\n\tint i;\n\n\tfor (i = 0; i < pctrl->ncommunities; i++) {\n\t\tconst struct intel_community *community;\n\t\tvoid __iomem *base;\n\t\tunsigned int gpp;\n\n\t\tcommunity = &pctrl->communities[i];\n\t\tbase = community->regs;\n\n\t\tfor (gpp = 0; gpp < community->ngpps; gpp++) {\n\t\t\t \n\t\t\twritel(0, base + community->ie_offset + gpp * 4);\n\t\t\twritel(0xffff, base + community->is_offset + gpp * 4);\n\t\t}\n\t}\n}\n\nstatic int intel_gpio_irq_init_hw(struct gpio_chip *gc)\n{\n\tstruct intel_pinctrl *pctrl = gpiochip_get_data(gc);\n\n\t \n\tintel_gpio_irq_init(pctrl);\n\n\treturn 0;\n}\n\nstatic int intel_gpio_add_community_ranges(struct intel_pinctrl *pctrl,\n\t\t\t\tconst struct intel_community *community)\n{\n\tint ret = 0, i;\n\n\tfor (i = 0; i < community->ngpps; i++) {\n\t\tconst struct intel_padgroup *gpp = &community->gpps[i];\n\n\t\tif (gpp->gpio_base == INTEL_GPIO_BASE_NOMAP)\n\t\t\tcontinue;\n\n\t\tret = gpiochip_add_pin_range(&pctrl->chip, dev_name(pctrl->dev),\n\t\t\t\t\t     gpp->gpio_base, gpp->base,\n\t\t\t\t\t     gpp->size);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int intel_gpio_add_pin_ranges(struct gpio_chip *gc)\n{\n\tstruct intel_pinctrl *pctrl = gpiochip_get_data(gc);\n\tint ret, i;\n\n\tfor (i = 0; i < pctrl->ncommunities; i++) {\n\t\tstruct intel_community *community = &pctrl->communities[i];\n\n\t\tret = intel_gpio_add_community_ranges(pctrl, community);\n\t\tif (ret) {\n\t\t\tdev_err(pctrl->dev, \"failed to add GPIO pin range\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic unsigned int intel_gpio_ngpio(const struct intel_pinctrl *pctrl)\n{\n\tconst struct intel_community *community;\n\tunsigned int ngpio = 0;\n\tint i, j;\n\n\tfor (i = 0; i < pctrl->ncommunities; i++) {\n\t\tcommunity = &pctrl->communities[i];\n\t\tfor (j = 0; j < community->ngpps; j++) {\n\t\t\tconst struct intel_padgroup *gpp = &community->gpps[j];\n\n\t\t\tif (gpp->gpio_base == INTEL_GPIO_BASE_NOMAP)\n\t\t\t\tcontinue;\n\n\t\t\tif (gpp->gpio_base + gpp->size > ngpio)\n\t\t\t\tngpio = gpp->gpio_base + gpp->size;\n\t\t}\n\t}\n\n\treturn ngpio;\n}\n\nstatic int intel_gpio_probe(struct intel_pinctrl *pctrl, int irq)\n{\n\tint ret;\n\tstruct gpio_irq_chip *girq;\n\n\tpctrl->chip = intel_gpio_chip;\n\n\t \n\tpctrl->chip.ngpio = intel_gpio_ngpio(pctrl);\n\tpctrl->chip.label = dev_name(pctrl->dev);\n\tpctrl->chip.parent = pctrl->dev;\n\tpctrl->chip.base = -1;\n\tpctrl->chip.add_pin_ranges = intel_gpio_add_pin_ranges;\n\tpctrl->irq = irq;\n\n\t \n\tret = devm_request_irq(pctrl->dev, irq, intel_gpio_irq,\n\t\t\t       IRQF_SHARED | IRQF_NO_THREAD,\n\t\t\t       dev_name(pctrl->dev), pctrl);\n\tif (ret) {\n\t\tdev_err(pctrl->dev, \"failed to request interrupt\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tgirq = &pctrl->chip.irq;\n\tgpio_irq_chip_set_chip(girq, &intel_gpio_irq_chip);\n\t \n\tgirq->parent_handler = NULL;\n\tgirq->num_parents = 0;\n\tgirq->default_type = IRQ_TYPE_NONE;\n\tgirq->handler = handle_bad_irq;\n\tgirq->init_hw = intel_gpio_irq_init_hw;\n\n\tret = devm_gpiochip_add_data(pctrl->dev, &pctrl->chip, pctrl);\n\tif (ret) {\n\t\tdev_err(pctrl->dev, \"failed to register gpiochip\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int intel_pinctrl_add_padgroups_by_gpps(struct intel_pinctrl *pctrl,\n\t\t\t\t\t       struct intel_community *community)\n{\n\tstruct intel_padgroup *gpps;\n\tunsigned int padown_num = 0;\n\tsize_t i, ngpps = community->ngpps;\n\n\tgpps = devm_kcalloc(pctrl->dev, ngpps, sizeof(*gpps), GFP_KERNEL);\n\tif (!gpps)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ngpps; i++) {\n\t\tgpps[i] = community->gpps[i];\n\n\t\tif (gpps[i].size > INTEL_PINCTRL_MAX_GPP_SIZE)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tswitch (gpps[i].gpio_base) {\n\t\t\tcase INTEL_GPIO_BASE_MATCH:\n\t\t\t\tgpps[i].gpio_base = gpps[i].base;\n\t\t\t\tbreak;\n\t\t\tcase INTEL_GPIO_BASE_ZERO:\n\t\t\t\tgpps[i].gpio_base = 0;\n\t\t\t\tbreak;\n\t\t\tcase INTEL_GPIO_BASE_NOMAP:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\n\t\tgpps[i].padown_num = padown_num;\n\t\tpadown_num += DIV_ROUND_UP(gpps[i].size * 4, INTEL_PINCTRL_MAX_GPP_SIZE);\n\t}\n\n\tcommunity->gpps = gpps;\n\n\treturn 0;\n}\n\nstatic int intel_pinctrl_add_padgroups_by_size(struct intel_pinctrl *pctrl,\n\t\t\t\t\t       struct intel_community *community)\n{\n\tstruct intel_padgroup *gpps;\n\tunsigned int npins = community->npins;\n\tunsigned int padown_num = 0;\n\tsize_t i, ngpps = DIV_ROUND_UP(npins, community->gpp_size);\n\n\tif (community->gpp_size > INTEL_PINCTRL_MAX_GPP_SIZE)\n\t\treturn -EINVAL;\n\n\tgpps = devm_kcalloc(pctrl->dev, ngpps, sizeof(*gpps), GFP_KERNEL);\n\tif (!gpps)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ngpps; i++) {\n\t\tunsigned int gpp_size = community->gpp_size;\n\n\t\tgpps[i].reg_num = i;\n\t\tgpps[i].base = community->pin_base + i * gpp_size;\n\t\tgpps[i].size = min(gpp_size, npins);\n\t\tnpins -= gpps[i].size;\n\n\t\tgpps[i].gpio_base = gpps[i].base;\n\t\tgpps[i].padown_num = padown_num;\n\n\t\tpadown_num += community->gpp_num_padown_regs;\n\t}\n\n\tcommunity->ngpps = ngpps;\n\tcommunity->gpps = gpps;\n\n\treturn 0;\n}\n\nstatic int intel_pinctrl_pm_init(struct intel_pinctrl *pctrl)\n{\n#ifdef CONFIG_PM_SLEEP\n\tconst struct intel_pinctrl_soc_data *soc = pctrl->soc;\n\tstruct intel_community_context *communities;\n\tstruct intel_pad_context *pads;\n\tint i;\n\n\tpads = devm_kcalloc(pctrl->dev, soc->npins, sizeof(*pads), GFP_KERNEL);\n\tif (!pads)\n\t\treturn -ENOMEM;\n\n\tcommunities = devm_kcalloc(pctrl->dev, pctrl->ncommunities,\n\t\t\t\t   sizeof(*communities), GFP_KERNEL);\n\tif (!communities)\n\t\treturn -ENOMEM;\n\n\n\tfor (i = 0; i < pctrl->ncommunities; i++) {\n\t\tstruct intel_community *community = &pctrl->communities[i];\n\t\tu32 *intmask, *hostown;\n\n\t\tintmask = devm_kcalloc(pctrl->dev, community->ngpps,\n\t\t\t\t       sizeof(*intmask), GFP_KERNEL);\n\t\tif (!intmask)\n\t\t\treturn -ENOMEM;\n\n\t\tcommunities[i].intmask = intmask;\n\n\t\thostown = devm_kcalloc(pctrl->dev, community->ngpps,\n\t\t\t\t       sizeof(*hostown), GFP_KERNEL);\n\t\tif (!hostown)\n\t\t\treturn -ENOMEM;\n\n\t\tcommunities[i].hostown = hostown;\n\t}\n\n\tpctrl->context.pads = pads;\n\tpctrl->context.communities = communities;\n#endif\n\n\treturn 0;\n}\n\nstatic int intel_pinctrl_probe_pwm(struct intel_pinctrl *pctrl,\n\t\t\t\t   struct intel_community *community)\n{\n\tstatic const struct pwm_lpss_boardinfo info = {\n\t\t.clk_rate = 19200000,\n\t\t.npwm = 1,\n\t\t.base_unit_bits = 22,\n\t\t.bypass = true,\n\t};\n\tstruct pwm_lpss_chip *pwm;\n\n\tif (!(community->features & PINCTRL_FEATURE_PWM))\n\t\treturn 0;\n\n\tif (!IS_REACHABLE(CONFIG_PWM_LPSS))\n\t\treturn 0;\n\n\tpwm = devm_pwm_lpss_probe(pctrl->dev, community->regs + PWMC, &info);\n\treturn PTR_ERR_OR_ZERO(pwm);\n}\n\nstatic int intel_pinctrl_probe(struct platform_device *pdev,\n\t\t\t       const struct intel_pinctrl_soc_data *soc_data)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct intel_pinctrl *pctrl;\n\tint i, ret, irq;\n\n\tpctrl = devm_kzalloc(dev, sizeof(*pctrl), GFP_KERNEL);\n\tif (!pctrl)\n\t\treturn -ENOMEM;\n\n\tpctrl->dev = dev;\n\tpctrl->soc = soc_data;\n\traw_spin_lock_init(&pctrl->lock);\n\n\t \n\tpctrl->ncommunities = pctrl->soc->ncommunities;\n\tpctrl->communities = devm_kcalloc(dev, pctrl->ncommunities,\n\t\t\t\t\t  sizeof(*pctrl->communities), GFP_KERNEL);\n\tif (!pctrl->communities)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < pctrl->ncommunities; i++) {\n\t\tstruct intel_community *community = &pctrl->communities[i];\n\t\tvoid __iomem *regs;\n\t\tu32 offset;\n\t\tu32 value;\n\n\t\t*community = pctrl->soc->communities[i];\n\n\t\tregs = devm_platform_ioremap_resource(pdev, community->barno);\n\t\tif (IS_ERR(regs))\n\t\t\treturn PTR_ERR(regs);\n\n\t\t \n\t\tvalue = readl(regs + REVID);\n\t\tif (value == ~0u)\n\t\t\treturn -ENODEV;\n\t\tif (((value & REVID_MASK) >> REVID_SHIFT) >= 0x94) {\n\t\t\tcommunity->features |= PINCTRL_FEATURE_DEBOUNCE;\n\t\t\tcommunity->features |= PINCTRL_FEATURE_1K_PD;\n\t\t}\n\n\t\t \n\t\toffset = CAPLIST;\n\t\tdo {\n\t\t\tvalue = readl(regs + offset);\n\t\t\tswitch ((value & CAPLIST_ID_MASK) >> CAPLIST_ID_SHIFT) {\n\t\t\tcase CAPLIST_ID_GPIO_HW_INFO:\n\t\t\t\tcommunity->features |= PINCTRL_FEATURE_GPIO_HW_INFO;\n\t\t\t\tbreak;\n\t\t\tcase CAPLIST_ID_PWM:\n\t\t\t\tcommunity->features |= PINCTRL_FEATURE_PWM;\n\t\t\t\tbreak;\n\t\t\tcase CAPLIST_ID_BLINK:\n\t\t\t\tcommunity->features |= PINCTRL_FEATURE_BLINK;\n\t\t\t\tbreak;\n\t\t\tcase CAPLIST_ID_EXP:\n\t\t\t\tcommunity->features |= PINCTRL_FEATURE_EXP;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\toffset = (value & CAPLIST_NEXT_MASK) >> CAPLIST_NEXT_SHIFT;\n\t\t} while (offset);\n\n\t\tdev_dbg(dev, \"Community%d features: %#08x\\n\", i, community->features);\n\n\t\t \n\t\toffset = readl(regs + PADBAR);\n\n\t\tcommunity->regs = regs;\n\t\tcommunity->pad_regs = regs + offset;\n\n\t\tif (community->gpps)\n\t\t\tret = intel_pinctrl_add_padgroups_by_gpps(pctrl, community);\n\t\telse\n\t\t\tret = intel_pinctrl_add_padgroups_by_size(pctrl, community);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = intel_pinctrl_probe_pwm(pctrl, community);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = intel_pinctrl_pm_init(pctrl);\n\tif (ret)\n\t\treturn ret;\n\n\tpctrl->pctldesc = intel_pinctrl_desc;\n\tpctrl->pctldesc.name = dev_name(dev);\n\tpctrl->pctldesc.pins = pctrl->soc->pins;\n\tpctrl->pctldesc.npins = pctrl->soc->npins;\n\n\tpctrl->pctldev = devm_pinctrl_register(dev, &pctrl->pctldesc, pctrl);\n\tif (IS_ERR(pctrl->pctldev)) {\n\t\tdev_err(dev, \"failed to register pinctrl driver\\n\");\n\t\treturn PTR_ERR(pctrl->pctldev);\n\t}\n\n\tret = intel_gpio_probe(pctrl, irq);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, pctrl);\n\n\treturn 0;\n}\n\nint intel_pinctrl_probe_by_hid(struct platform_device *pdev)\n{\n\tconst struct intel_pinctrl_soc_data *data;\n\n\tdata = device_get_match_data(&pdev->dev);\n\tif (!data)\n\t\treturn -ENODATA;\n\n\treturn intel_pinctrl_probe(pdev, data);\n}\nEXPORT_SYMBOL_NS_GPL(intel_pinctrl_probe_by_hid, PINCTRL_INTEL);\n\nint intel_pinctrl_probe_by_uid(struct platform_device *pdev)\n{\n\tconst struct intel_pinctrl_soc_data *data;\n\n\tdata = intel_pinctrl_get_soc_data(pdev);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\treturn intel_pinctrl_probe(pdev, data);\n}\nEXPORT_SYMBOL_NS_GPL(intel_pinctrl_probe_by_uid, PINCTRL_INTEL);\n\nconst struct intel_pinctrl_soc_data *intel_pinctrl_get_soc_data(struct platform_device *pdev)\n{\n\tconst struct intel_pinctrl_soc_data * const *table;\n\tconst struct intel_pinctrl_soc_data *data = NULL;\n\tstruct device *dev = &pdev->dev;\n\n\ttable = device_get_match_data(dev);\n\tif (table) {\n\t\tstruct acpi_device *adev = ACPI_COMPANION(dev);\n\t\tunsigned int i;\n\n\t\tfor (i = 0; table[i]; i++) {\n\t\t\tif (!strcmp(adev->pnp.unique_id, table[i]->uid)) {\n\t\t\t\tdata = table[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tconst struct platform_device_id *id;\n\n\t\tid = platform_get_device_id(pdev);\n\t\tif (!id)\n\t\t\treturn ERR_PTR(-ENODEV);\n\n\t\ttable = (const struct intel_pinctrl_soc_data * const *)id->driver_data;\n\t\tdata = table[pdev->id];\n\t}\n\n\treturn data ?: ERR_PTR(-ENODATA);\n}\nEXPORT_SYMBOL_NS_GPL(intel_pinctrl_get_soc_data, PINCTRL_INTEL);\n\n#ifdef CONFIG_PM_SLEEP\nstatic bool __intel_gpio_is_direct_irq(u32 value)\n{\n\treturn (value & PADCFG0_GPIROUTIOXAPIC) && (value & PADCFG0_GPIOTXDIS) &&\n\t       (__intel_gpio_get_gpio_mode(value) == PADCFG0_PMODE_GPIO);\n}\n\nstatic bool intel_pinctrl_should_save(struct intel_pinctrl *pctrl, unsigned int pin)\n{\n\tconst struct pin_desc *pd = pin_desc_get(pctrl->pctldev, pin);\n\tu32 value;\n\n\tif (!pd || !intel_pad_usable(pctrl, pin))\n\t\treturn false;\n\n\t \n\tif (pd->mux_owner || pd->gpio_owner ||\n\t    gpiochip_line_is_irq(&pctrl->chip, intel_pin_to_gpio(pctrl, pin)))\n\t\treturn true;\n\n\t \n\tvalue = readl(intel_get_padcfg(pctrl, pin, PADCFG0));\n\tif (__intel_gpio_is_direct_irq(value))\n\t\treturn true;\n\n\treturn false;\n}\n\nint intel_pinctrl_suspend_noirq(struct device *dev)\n{\n\tstruct intel_pinctrl *pctrl = dev_get_drvdata(dev);\n\tstruct intel_community_context *communities;\n\tstruct intel_pad_context *pads;\n\tint i;\n\n\tpads = pctrl->context.pads;\n\tfor (i = 0; i < pctrl->soc->npins; i++) {\n\t\tconst struct pinctrl_pin_desc *desc = &pctrl->soc->pins[i];\n\t\tvoid __iomem *padcfg;\n\t\tu32 val;\n\n\t\tif (!intel_pinctrl_should_save(pctrl, desc->number))\n\t\t\tcontinue;\n\n\t\tval = readl(intel_get_padcfg(pctrl, desc->number, PADCFG0));\n\t\tpads[i].padcfg0 = val & ~PADCFG0_GPIORXSTATE;\n\t\tval = readl(intel_get_padcfg(pctrl, desc->number, PADCFG1));\n\t\tpads[i].padcfg1 = val;\n\n\t\tpadcfg = intel_get_padcfg(pctrl, desc->number, PADCFG2);\n\t\tif (padcfg)\n\t\t\tpads[i].padcfg2 = readl(padcfg);\n\t}\n\n\tcommunities = pctrl->context.communities;\n\tfor (i = 0; i < pctrl->ncommunities; i++) {\n\t\tstruct intel_community *community = &pctrl->communities[i];\n\t\tvoid __iomem *base;\n\t\tunsigned int gpp;\n\n\t\tbase = community->regs + community->ie_offset;\n\t\tfor (gpp = 0; gpp < community->ngpps; gpp++)\n\t\t\tcommunities[i].intmask[gpp] = readl(base + gpp * 4);\n\n\t\tbase = community->regs + community->hostown_offset;\n\t\tfor (gpp = 0; gpp < community->ngpps; gpp++)\n\t\t\tcommunities[i].hostown[gpp] = readl(base + gpp * 4);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(intel_pinctrl_suspend_noirq);\n\nstatic bool intel_gpio_update_reg(void __iomem *reg, u32 mask, u32 value)\n{\n\tu32 curr, updated;\n\n\tcurr = readl(reg);\n\n\tupdated = (curr & ~mask) | (value & mask);\n\tif (curr == updated)\n\t\treturn false;\n\n\twritel(updated, reg);\n\treturn true;\n}\n\nstatic void intel_restore_hostown(struct intel_pinctrl *pctrl, unsigned int c,\n\t\t\t\t  void __iomem *base, unsigned int gpp, u32 saved)\n{\n\tconst struct intel_community *community = &pctrl->communities[c];\n\tconst struct intel_padgroup *padgrp = &community->gpps[gpp];\n\tstruct device *dev = pctrl->dev;\n\tconst char *dummy;\n\tu32 requested = 0;\n\tunsigned int i;\n\n\tif (padgrp->gpio_base == INTEL_GPIO_BASE_NOMAP)\n\t\treturn;\n\n\tfor_each_requested_gpio_in_range(&pctrl->chip, i, padgrp->gpio_base, padgrp->size, dummy)\n\t\trequested |= BIT(i);\n\n\tif (!intel_gpio_update_reg(base + gpp * 4, requested, saved))\n\t\treturn;\n\n\tdev_dbg(dev, \"restored hostown %u/%u %#08x\\n\", c, gpp, readl(base + gpp * 4));\n}\n\nstatic void intel_restore_intmask(struct intel_pinctrl *pctrl, unsigned int c,\n\t\t\t\t  void __iomem *base, unsigned int gpp, u32 saved)\n{\n\tstruct device *dev = pctrl->dev;\n\n\tif (!intel_gpio_update_reg(base + gpp * 4, ~0U, saved))\n\t\treturn;\n\n\tdev_dbg(dev, \"restored mask %u/%u %#08x\\n\", c, gpp, readl(base + gpp * 4));\n}\n\nstatic void intel_restore_padcfg(struct intel_pinctrl *pctrl, unsigned int pin,\n\t\t\t\t unsigned int reg, u32 saved)\n{\n\tu32 mask = (reg == PADCFG0) ? PADCFG0_GPIORXSTATE : 0;\n\tunsigned int n = reg / sizeof(u32);\n\tstruct device *dev = pctrl->dev;\n\tvoid __iomem *padcfg;\n\n\tpadcfg = intel_get_padcfg(pctrl, pin, reg);\n\tif (!padcfg)\n\t\treturn;\n\n\tif (!intel_gpio_update_reg(padcfg, ~mask, saved))\n\t\treturn;\n\n\tdev_dbg(dev, \"restored pin %u padcfg%u %#08x\\n\", pin, n, readl(padcfg));\n}\n\nint intel_pinctrl_resume_noirq(struct device *dev)\n{\n\tstruct intel_pinctrl *pctrl = dev_get_drvdata(dev);\n\tconst struct intel_community_context *communities;\n\tconst struct intel_pad_context *pads;\n\tint i;\n\n\t \n\tintel_gpio_irq_init(pctrl);\n\n\tpads = pctrl->context.pads;\n\tfor (i = 0; i < pctrl->soc->npins; i++) {\n\t\tconst struct pinctrl_pin_desc *desc = &pctrl->soc->pins[i];\n\n\t\tif (!(intel_pinctrl_should_save(pctrl, desc->number) ||\n\t\t       \n\t\t      __intel_gpio_is_direct_irq(pads[i].padcfg0)))\n\t\t\tcontinue;\n\n\t\tintel_restore_padcfg(pctrl, desc->number, PADCFG0, pads[i].padcfg0);\n\t\tintel_restore_padcfg(pctrl, desc->number, PADCFG1, pads[i].padcfg1);\n\t\tintel_restore_padcfg(pctrl, desc->number, PADCFG2, pads[i].padcfg2);\n\t}\n\n\tcommunities = pctrl->context.communities;\n\tfor (i = 0; i < pctrl->ncommunities; i++) {\n\t\tstruct intel_community *community = &pctrl->communities[i];\n\t\tvoid __iomem *base;\n\t\tunsigned int gpp;\n\n\t\tbase = community->regs + community->ie_offset;\n\t\tfor (gpp = 0; gpp < community->ngpps; gpp++)\n\t\t\tintel_restore_intmask(pctrl, i, base, gpp, communities[i].intmask[gpp]);\n\n\t\tbase = community->regs + community->hostown_offset;\n\t\tfor (gpp = 0; gpp < community->ngpps; gpp++)\n\t\t\tintel_restore_hostown(pctrl, i, base, gpp, communities[i].hostown[gpp]);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(intel_pinctrl_resume_noirq);\n#endif\n\nMODULE_AUTHOR(\"Mathias Nyman <mathias.nyman@linux.intel.com>\");\nMODULE_AUTHOR(\"Mika Westerberg <mika.westerberg@linux.intel.com>\");\nMODULE_DESCRIPTION(\"Intel pinctrl/GPIO core driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}