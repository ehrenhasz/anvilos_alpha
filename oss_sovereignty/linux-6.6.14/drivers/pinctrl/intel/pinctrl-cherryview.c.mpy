{
  "module_name": "pinctrl-cherryview.c",
  "hash_id": "1618cf9afe8c9071005cedd3a99457cc2fa07855151da83e47420385c71bd1c2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/intel/pinctrl-cherryview.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/dmi.h>\n#include <linux/gpio/driver.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/seq_file.h>\n#include <linux/types.h>\n\n#include <linux/pinctrl/consumer.h>\n#include <linux/pinctrl/pinconf-generic.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinmux.h>\n\n#include \"pinctrl-intel.h\"\n\n#define CHV_INTSTAT\t\t\t0x300\n#define CHV_INTMASK\t\t\t0x380\n\n#define FAMILY_PAD_REGS_OFF\t\t0x4400\n#define FAMILY_PAD_REGS_SIZE\t\t0x400\n#define MAX_FAMILY_PAD_GPIO_NO\t\t15\n#define GPIO_REGS_SIZE\t\t\t8\n\n#define CHV_PADCTRL0\t\t\t0x000\n#define CHV_PADCTRL0_INTSEL_SHIFT\t28\n#define CHV_PADCTRL0_INTSEL_MASK\tGENMASK(31, 28)\n#define CHV_PADCTRL0_TERM_UP\t\tBIT(23)\n#define CHV_PADCTRL0_TERM_SHIFT\t\t20\n#define CHV_PADCTRL0_TERM_MASK\t\tGENMASK(22, 20)\n#define CHV_PADCTRL0_TERM_20K\t\t1\n#define CHV_PADCTRL0_TERM_5K\t\t2\n#define CHV_PADCTRL0_TERM_1K\t\t4\n#define CHV_PADCTRL0_PMODE_SHIFT\t16\n#define CHV_PADCTRL0_PMODE_MASK\t\tGENMASK(19, 16)\n#define CHV_PADCTRL0_GPIOEN\t\tBIT(15)\n#define CHV_PADCTRL0_GPIOCFG_SHIFT\t8\n#define CHV_PADCTRL0_GPIOCFG_MASK\tGENMASK(10, 8)\n#define CHV_PADCTRL0_GPIOCFG_GPIO\t0\n#define CHV_PADCTRL0_GPIOCFG_GPO\t1\n#define CHV_PADCTRL0_GPIOCFG_GPI\t2\n#define CHV_PADCTRL0_GPIOCFG_HIZ\t3\n#define CHV_PADCTRL0_GPIOTXSTATE\tBIT(1)\n#define CHV_PADCTRL0_GPIORXSTATE\tBIT(0)\n\n#define CHV_PADCTRL1\t\t\t0x004\n#define CHV_PADCTRL1_CFGLOCK\t\tBIT(31)\n#define CHV_PADCTRL1_INVRXTX_SHIFT\t4\n#define CHV_PADCTRL1_INVRXTX_MASK\tGENMASK(7, 4)\n#define CHV_PADCTRL1_INVRXTX_TXDATA\tBIT(7)\n#define CHV_PADCTRL1_INVRXTX_RXDATA\tBIT(6)\n#define CHV_PADCTRL1_INVRXTX_TXENABLE\tBIT(5)\n#define CHV_PADCTRL1_ODEN\t\tBIT(3)\n#define CHV_PADCTRL1_INTWAKECFG_MASK\tGENMASK(2, 0)\n#define CHV_PADCTRL1_INTWAKECFG_FALLING\t1\n#define CHV_PADCTRL1_INTWAKECFG_RISING\t2\n#define CHV_PADCTRL1_INTWAKECFG_BOTH\t3\n#define CHV_PADCTRL1_INTWAKECFG_LEVEL\t4\n\nstruct intel_pad_context {\n\tu32 padctrl0;\n\tu32 padctrl1;\n};\n\n#define CHV_INVALID_HWIRQ\t(~0U)\n\n \nstruct intel_community_context {\n\tunsigned int intr_lines[16];\n\tu32 saved_intmask;\n};\n\n#define\tPINMODE_INVERT_OE\tBIT(15)\n\n#define PINMODE(m, i)\t\t((m) | ((i) * PINMODE_INVERT_OE))\n\n#define CHV_GPP(start, end)\t\t\t\\\n\t{\t\t\t\t\t\\\n\t\t.base = (start),\t\t\\\n\t\t.size = (end) - (start) + 1,\t\\\n\t}\n\n#define CHV_COMMUNITY(g, i, a)\t\t\t\\\n\t{\t\t\t\t\t\\\n\t\t.gpps = (g),\t\t\t\\\n\t\t.ngpps = ARRAY_SIZE(g),\t\t\\\n\t\t.nirqs = (i),\t\t\t\\\n\t\t.acpi_space_id = (a),\t\t\\\n\t}\n\nstatic const struct pinctrl_pin_desc southwest_pins[] = {\n\tPINCTRL_PIN(0, \"FST_SPI_D2\"),\n\tPINCTRL_PIN(1, \"FST_SPI_D0\"),\n\tPINCTRL_PIN(2, \"FST_SPI_CLK\"),\n\tPINCTRL_PIN(3, \"FST_SPI_D3\"),\n\tPINCTRL_PIN(4, \"FST_SPI_CS1_B\"),\n\tPINCTRL_PIN(5, \"FST_SPI_D1\"),\n\tPINCTRL_PIN(6, \"FST_SPI_CS0_B\"),\n\tPINCTRL_PIN(7, \"FST_SPI_CS2_B\"),\n\n\tPINCTRL_PIN(15, \"UART1_RTS_B\"),\n\tPINCTRL_PIN(16, \"UART1_RXD\"),\n\tPINCTRL_PIN(17, \"UART2_RXD\"),\n\tPINCTRL_PIN(18, \"UART1_CTS_B\"),\n\tPINCTRL_PIN(19, \"UART2_RTS_B\"),\n\tPINCTRL_PIN(20, \"UART1_TXD\"),\n\tPINCTRL_PIN(21, \"UART2_TXD\"),\n\tPINCTRL_PIN(22, \"UART2_CTS_B\"),\n\n\tPINCTRL_PIN(30, \"MF_HDA_CLK\"),\n\tPINCTRL_PIN(31, \"MF_HDA_RSTB\"),\n\tPINCTRL_PIN(32, \"MF_HDA_SDIO\"),\n\tPINCTRL_PIN(33, \"MF_HDA_SDO\"),\n\tPINCTRL_PIN(34, \"MF_HDA_DOCKRSTB\"),\n\tPINCTRL_PIN(35, \"MF_HDA_SYNC\"),\n\tPINCTRL_PIN(36, \"MF_HDA_SDI1\"),\n\tPINCTRL_PIN(37, \"MF_HDA_DOCKENB\"),\n\n\tPINCTRL_PIN(45, \"I2C5_SDA\"),\n\tPINCTRL_PIN(46, \"I2C4_SDA\"),\n\tPINCTRL_PIN(47, \"I2C6_SDA\"),\n\tPINCTRL_PIN(48, \"I2C5_SCL\"),\n\tPINCTRL_PIN(49, \"I2C_NFC_SDA\"),\n\tPINCTRL_PIN(50, \"I2C4_SCL\"),\n\tPINCTRL_PIN(51, \"I2C6_SCL\"),\n\tPINCTRL_PIN(52, \"I2C_NFC_SCL\"),\n\n\tPINCTRL_PIN(60, \"I2C1_SDA\"),\n\tPINCTRL_PIN(61, \"I2C0_SDA\"),\n\tPINCTRL_PIN(62, \"I2C2_SDA\"),\n\tPINCTRL_PIN(63, \"I2C1_SCL\"),\n\tPINCTRL_PIN(64, \"I2C3_SDA\"),\n\tPINCTRL_PIN(65, \"I2C0_SCL\"),\n\tPINCTRL_PIN(66, \"I2C2_SCL\"),\n\tPINCTRL_PIN(67, \"I2C3_SCL\"),\n\n\tPINCTRL_PIN(75, \"SATA_GP0\"),\n\tPINCTRL_PIN(76, \"SATA_GP1\"),\n\tPINCTRL_PIN(77, \"SATA_LEDN\"),\n\tPINCTRL_PIN(78, \"SATA_GP2\"),\n\tPINCTRL_PIN(79, \"MF_SMB_ALERTB\"),\n\tPINCTRL_PIN(80, \"SATA_GP3\"),\n\tPINCTRL_PIN(81, \"MF_SMB_CLK\"),\n\tPINCTRL_PIN(82, \"MF_SMB_DATA\"),\n\n\tPINCTRL_PIN(90, \"PCIE_CLKREQ0B\"),\n\tPINCTRL_PIN(91, \"PCIE_CLKREQ1B\"),\n\tPINCTRL_PIN(92, \"GP_SSP_2_CLK\"),\n\tPINCTRL_PIN(93, \"PCIE_CLKREQ2B\"),\n\tPINCTRL_PIN(94, \"GP_SSP_2_RXD\"),\n\tPINCTRL_PIN(95, \"PCIE_CLKREQ3B\"),\n\tPINCTRL_PIN(96, \"GP_SSP_2_FS\"),\n\tPINCTRL_PIN(97, \"GP_SSP_2_TXD\"),\n};\n\nstatic const unsigned southwest_uart0_pins[] = { 16, 20 };\nstatic const unsigned southwest_uart1_pins[] = { 15, 16, 18, 20 };\nstatic const unsigned southwest_uart2_pins[] = { 17, 19, 21, 22 };\nstatic const unsigned southwest_i2c0_pins[] = { 61, 65 };\nstatic const unsigned southwest_hda_pins[] = { 30, 31, 32, 33, 34, 35, 36, 37 };\nstatic const unsigned southwest_lpe_pins[] = {\n\t30, 31, 32, 33, 34, 35, 36, 37, 92, 94, 96, 97,\n};\nstatic const unsigned southwest_i2c1_pins[] = { 60, 63 };\nstatic const unsigned southwest_i2c2_pins[] = { 62, 66 };\nstatic const unsigned southwest_i2c3_pins[] = { 64, 67 };\nstatic const unsigned southwest_i2c4_pins[] = { 46, 50 };\nstatic const unsigned southwest_i2c5_pins[] = { 45, 48 };\nstatic const unsigned southwest_i2c6_pins[] = { 47, 51 };\nstatic const unsigned southwest_i2c_nfc_pins[] = { 49, 52 };\nstatic const unsigned southwest_spi3_pins[] = { 76, 79, 80, 81, 82 };\n\n \nstatic const unsigned int southwest_lpe_altfuncs[] = {\n\tPINMODE(1, 1), PINMODE(1, 0), PINMODE(1, 0), PINMODE(1, 0),  \n\tPINMODE(1, 1), PINMODE(1, 0), PINMODE(1, 0), PINMODE(1, 0),  \n\tPINMODE(1, 0), PINMODE(1, 0), PINMODE(1, 0), PINMODE(1, 1),  \n};\n\n \nstatic const unsigned int southwest_spi3_altfuncs[] = {\n\tPINMODE(3, 0), PINMODE(2, 0), PINMODE(3, 0), PINMODE(2, 0),  \n\tPINMODE(2, 0),\t\t\t\t\t\t     \n};\n\nstatic const struct intel_pingroup southwest_groups[] = {\n\tPIN_GROUP(\"uart0_grp\", southwest_uart0_pins, PINMODE(2, 0)),\n\tPIN_GROUP(\"uart1_grp\", southwest_uart1_pins, PINMODE(1, 0)),\n\tPIN_GROUP(\"uart2_grp\", southwest_uart2_pins, PINMODE(1, 0)),\n\tPIN_GROUP(\"hda_grp\", southwest_hda_pins, PINMODE(2, 0)),\n\tPIN_GROUP(\"i2c0_grp\", southwest_i2c0_pins, PINMODE(1, 1)),\n\tPIN_GROUP(\"i2c1_grp\", southwest_i2c1_pins, PINMODE(1, 1)),\n\tPIN_GROUP(\"i2c2_grp\", southwest_i2c2_pins, PINMODE(1, 1)),\n\tPIN_GROUP(\"i2c3_grp\", southwest_i2c3_pins, PINMODE(1, 1)),\n\tPIN_GROUP(\"i2c4_grp\", southwest_i2c4_pins, PINMODE(1, 1)),\n\tPIN_GROUP(\"i2c5_grp\", southwest_i2c5_pins, PINMODE(1, 1)),\n\tPIN_GROUP(\"i2c6_grp\", southwest_i2c6_pins, PINMODE(1, 1)),\n\tPIN_GROUP(\"i2c_nfc_grp\", southwest_i2c_nfc_pins, PINMODE(2, 1)),\n\tPIN_GROUP(\"lpe_grp\", southwest_lpe_pins, southwest_lpe_altfuncs),\n\tPIN_GROUP(\"spi3_grp\", southwest_spi3_pins, southwest_spi3_altfuncs),\n};\n\nstatic const char * const southwest_uart0_groups[] = { \"uart0_grp\" };\nstatic const char * const southwest_uart1_groups[] = { \"uart1_grp\" };\nstatic const char * const southwest_uart2_groups[] = { \"uart2_grp\" };\nstatic const char * const southwest_hda_groups[] = { \"hda_grp\" };\nstatic const char * const southwest_lpe_groups[] = { \"lpe_grp\" };\nstatic const char * const southwest_i2c0_groups[] = { \"i2c0_grp\" };\nstatic const char * const southwest_i2c1_groups[] = { \"i2c1_grp\" };\nstatic const char * const southwest_i2c2_groups[] = { \"i2c2_grp\" };\nstatic const char * const southwest_i2c3_groups[] = { \"i2c3_grp\" };\nstatic const char * const southwest_i2c4_groups[] = { \"i2c4_grp\" };\nstatic const char * const southwest_i2c5_groups[] = { \"i2c5_grp\" };\nstatic const char * const southwest_i2c6_groups[] = { \"i2c6_grp\" };\nstatic const char * const southwest_i2c_nfc_groups[] = { \"i2c_nfc_grp\" };\nstatic const char * const southwest_spi3_groups[] = { \"spi3_grp\" };\n\n \nstatic const struct intel_function southwest_functions[] = {\n\tFUNCTION(\"uart0\", southwest_uart0_groups),\n\tFUNCTION(\"uart1\", southwest_uart1_groups),\n\tFUNCTION(\"uart2\", southwest_uart2_groups),\n\tFUNCTION(\"hda\", southwest_hda_groups),\n\tFUNCTION(\"lpe\", southwest_lpe_groups),\n\tFUNCTION(\"i2c0\", southwest_i2c0_groups),\n\tFUNCTION(\"i2c1\", southwest_i2c1_groups),\n\tFUNCTION(\"i2c2\", southwest_i2c2_groups),\n\tFUNCTION(\"i2c3\", southwest_i2c3_groups),\n\tFUNCTION(\"i2c4\", southwest_i2c4_groups),\n\tFUNCTION(\"i2c5\", southwest_i2c5_groups),\n\tFUNCTION(\"i2c6\", southwest_i2c6_groups),\n\tFUNCTION(\"i2c_nfc\", southwest_i2c_nfc_groups),\n\tFUNCTION(\"spi3\", southwest_spi3_groups),\n};\n\nstatic const struct intel_padgroup southwest_gpps[] = {\n\tCHV_GPP(0, 7),\n\tCHV_GPP(15, 22),\n\tCHV_GPP(30, 37),\n\tCHV_GPP(45, 52),\n\tCHV_GPP(60, 67),\n\tCHV_GPP(75, 82),\n\tCHV_GPP(90, 97),\n};\n\n \nstatic const struct intel_community southwest_communities[] = {\n\tCHV_COMMUNITY(southwest_gpps, 8, 0x91),\n};\n\nstatic const struct intel_pinctrl_soc_data southwest_soc_data = {\n\t.uid = \"1\",\n\t.pins = southwest_pins,\n\t.npins = ARRAY_SIZE(southwest_pins),\n\t.groups = southwest_groups,\n\t.ngroups = ARRAY_SIZE(southwest_groups),\n\t.functions = southwest_functions,\n\t.nfunctions = ARRAY_SIZE(southwest_functions),\n\t.communities = southwest_communities,\n\t.ncommunities = ARRAY_SIZE(southwest_communities),\n};\n\nstatic const struct pinctrl_pin_desc north_pins[] = {\n\tPINCTRL_PIN(0, \"GPIO_DFX_0\"),\n\tPINCTRL_PIN(1, \"GPIO_DFX_3\"),\n\tPINCTRL_PIN(2, \"GPIO_DFX_7\"),\n\tPINCTRL_PIN(3, \"GPIO_DFX_1\"),\n\tPINCTRL_PIN(4, \"GPIO_DFX_5\"),\n\tPINCTRL_PIN(5, \"GPIO_DFX_4\"),\n\tPINCTRL_PIN(6, \"GPIO_DFX_8\"),\n\tPINCTRL_PIN(7, \"GPIO_DFX_2\"),\n\tPINCTRL_PIN(8, \"GPIO_DFX_6\"),\n\n\tPINCTRL_PIN(15, \"GPIO_SUS0\"),\n\tPINCTRL_PIN(16, \"SEC_GPIO_SUS10\"),\n\tPINCTRL_PIN(17, \"GPIO_SUS3\"),\n\tPINCTRL_PIN(18, \"GPIO_SUS7\"),\n\tPINCTRL_PIN(19, \"GPIO_SUS1\"),\n\tPINCTRL_PIN(20, \"GPIO_SUS5\"),\n\tPINCTRL_PIN(21, \"SEC_GPIO_SUS11\"),\n\tPINCTRL_PIN(22, \"GPIO_SUS4\"),\n\tPINCTRL_PIN(23, \"SEC_GPIO_SUS8\"),\n\tPINCTRL_PIN(24, \"GPIO_SUS2\"),\n\tPINCTRL_PIN(25, \"GPIO_SUS6\"),\n\tPINCTRL_PIN(26, \"CX_PREQ_B\"),\n\tPINCTRL_PIN(27, \"SEC_GPIO_SUS9\"),\n\n\tPINCTRL_PIN(30, \"TRST_B\"),\n\tPINCTRL_PIN(31, \"TCK\"),\n\tPINCTRL_PIN(32, \"PROCHOT_B\"),\n\tPINCTRL_PIN(33, \"SVIDO_DATA\"),\n\tPINCTRL_PIN(34, \"TMS\"),\n\tPINCTRL_PIN(35, \"CX_PRDY_B_2\"),\n\tPINCTRL_PIN(36, \"TDO_2\"),\n\tPINCTRL_PIN(37, \"CX_PRDY_B\"),\n\tPINCTRL_PIN(38, \"SVIDO_ALERT_B\"),\n\tPINCTRL_PIN(39, \"TDO\"),\n\tPINCTRL_PIN(40, \"SVIDO_CLK\"),\n\tPINCTRL_PIN(41, \"TDI\"),\n\n\tPINCTRL_PIN(45, \"GP_CAMERASB_05\"),\n\tPINCTRL_PIN(46, \"GP_CAMERASB_02\"),\n\tPINCTRL_PIN(47, \"GP_CAMERASB_08\"),\n\tPINCTRL_PIN(48, \"GP_CAMERASB_00\"),\n\tPINCTRL_PIN(49, \"GP_CAMERASB_06\"),\n\tPINCTRL_PIN(50, \"GP_CAMERASB_10\"),\n\tPINCTRL_PIN(51, \"GP_CAMERASB_03\"),\n\tPINCTRL_PIN(52, \"GP_CAMERASB_09\"),\n\tPINCTRL_PIN(53, \"GP_CAMERASB_01\"),\n\tPINCTRL_PIN(54, \"GP_CAMERASB_07\"),\n\tPINCTRL_PIN(55, \"GP_CAMERASB_11\"),\n\tPINCTRL_PIN(56, \"GP_CAMERASB_04\"),\n\n\tPINCTRL_PIN(60, \"PANEL0_BKLTEN\"),\n\tPINCTRL_PIN(61, \"HV_DDI0_HPD\"),\n\tPINCTRL_PIN(62, \"HV_DDI2_DDC_SDA\"),\n\tPINCTRL_PIN(63, \"PANEL1_BKLTCTL\"),\n\tPINCTRL_PIN(64, \"HV_DDI1_HPD\"),\n\tPINCTRL_PIN(65, \"PANEL0_BKLTCTL\"),\n\tPINCTRL_PIN(66, \"HV_DDI0_DDC_SDA\"),\n\tPINCTRL_PIN(67, \"HV_DDI2_DDC_SCL\"),\n\tPINCTRL_PIN(68, \"HV_DDI2_HPD\"),\n\tPINCTRL_PIN(69, \"PANEL1_VDDEN\"),\n\tPINCTRL_PIN(70, \"PANEL1_BKLTEN\"),\n\tPINCTRL_PIN(71, \"HV_DDI0_DDC_SCL\"),\n\tPINCTRL_PIN(72, \"PANEL0_VDDEN\"),\n};\n\nstatic const struct intel_padgroup north_gpps[] = {\n\tCHV_GPP(0, 8),\n\tCHV_GPP(15, 27),\n\tCHV_GPP(30, 41),\n\tCHV_GPP(45, 56),\n\tCHV_GPP(60, 72),\n};\n\n \nstatic const struct intel_community north_communities[] = {\n\tCHV_COMMUNITY(north_gpps, 8, 0x92),\n};\n\nstatic const struct intel_pinctrl_soc_data north_soc_data = {\n\t.uid = \"2\",\n\t.pins = north_pins,\n\t.npins = ARRAY_SIZE(north_pins),\n\t.communities = north_communities,\n\t.ncommunities = ARRAY_SIZE(north_communities),\n};\n\nstatic const struct pinctrl_pin_desc east_pins[] = {\n\tPINCTRL_PIN(0, \"PMU_SLP_S3_B\"),\n\tPINCTRL_PIN(1, \"PMU_BATLOW_B\"),\n\tPINCTRL_PIN(2, \"SUS_STAT_B\"),\n\tPINCTRL_PIN(3, \"PMU_SLP_S0IX_B\"),\n\tPINCTRL_PIN(4, \"PMU_AC_PRESENT\"),\n\tPINCTRL_PIN(5, \"PMU_PLTRST_B\"),\n\tPINCTRL_PIN(6, \"PMU_SUSCLK\"),\n\tPINCTRL_PIN(7, \"PMU_SLP_LAN_B\"),\n\tPINCTRL_PIN(8, \"PMU_PWRBTN_B\"),\n\tPINCTRL_PIN(9, \"PMU_SLP_S4_B\"),\n\tPINCTRL_PIN(10, \"PMU_WAKE_B\"),\n\tPINCTRL_PIN(11, \"PMU_WAKE_LAN_B\"),\n\n\tPINCTRL_PIN(15, \"MF_ISH_GPIO_3\"),\n\tPINCTRL_PIN(16, \"MF_ISH_GPIO_7\"),\n\tPINCTRL_PIN(17, \"MF_ISH_I2C1_SCL\"),\n\tPINCTRL_PIN(18, \"MF_ISH_GPIO_1\"),\n\tPINCTRL_PIN(19, \"MF_ISH_GPIO_5\"),\n\tPINCTRL_PIN(20, \"MF_ISH_GPIO_9\"),\n\tPINCTRL_PIN(21, \"MF_ISH_GPIO_0\"),\n\tPINCTRL_PIN(22, \"MF_ISH_GPIO_4\"),\n\tPINCTRL_PIN(23, \"MF_ISH_GPIO_8\"),\n\tPINCTRL_PIN(24, \"MF_ISH_GPIO_2\"),\n\tPINCTRL_PIN(25, \"MF_ISH_GPIO_6\"),\n\tPINCTRL_PIN(26, \"MF_ISH_I2C1_SDA\"),\n};\n\nstatic const struct intel_padgroup east_gpps[] = {\n\tCHV_GPP(0, 11),\n\tCHV_GPP(15, 26),\n};\n\nstatic const struct intel_community east_communities[] = {\n\tCHV_COMMUNITY(east_gpps, 16, 0x93),\n};\n\nstatic const struct intel_pinctrl_soc_data east_soc_data = {\n\t.uid = \"3\",\n\t.pins = east_pins,\n\t.npins = ARRAY_SIZE(east_pins),\n\t.communities = east_communities,\n\t.ncommunities = ARRAY_SIZE(east_communities),\n};\n\nstatic const struct pinctrl_pin_desc southeast_pins[] = {\n\tPINCTRL_PIN(0, \"MF_PLT_CLK0\"),\n\tPINCTRL_PIN(1, \"PWM1\"),\n\tPINCTRL_PIN(2, \"MF_PLT_CLK1\"),\n\tPINCTRL_PIN(3, \"MF_PLT_CLK4\"),\n\tPINCTRL_PIN(4, \"MF_PLT_CLK3\"),\n\tPINCTRL_PIN(5, \"PWM0\"),\n\tPINCTRL_PIN(6, \"MF_PLT_CLK5\"),\n\tPINCTRL_PIN(7, \"MF_PLT_CLK2\"),\n\n\tPINCTRL_PIN(15, \"SDMMC2_D3_CD_B\"),\n\tPINCTRL_PIN(16, \"SDMMC1_CLK\"),\n\tPINCTRL_PIN(17, \"SDMMC1_D0\"),\n\tPINCTRL_PIN(18, \"SDMMC2_D1\"),\n\tPINCTRL_PIN(19, \"SDMMC2_CLK\"),\n\tPINCTRL_PIN(20, \"SDMMC1_D2\"),\n\tPINCTRL_PIN(21, \"SDMMC2_D2\"),\n\tPINCTRL_PIN(22, \"SDMMC2_CMD\"),\n\tPINCTRL_PIN(23, \"SDMMC1_CMD\"),\n\tPINCTRL_PIN(24, \"SDMMC1_D1\"),\n\tPINCTRL_PIN(25, \"SDMMC2_D0\"),\n\tPINCTRL_PIN(26, \"SDMMC1_D3_CD_B\"),\n\n\tPINCTRL_PIN(30, \"SDMMC3_D1\"),\n\tPINCTRL_PIN(31, \"SDMMC3_CLK\"),\n\tPINCTRL_PIN(32, \"SDMMC3_D3\"),\n\tPINCTRL_PIN(33, \"SDMMC3_D2\"),\n\tPINCTRL_PIN(34, \"SDMMC3_CMD\"),\n\tPINCTRL_PIN(35, \"SDMMC3_D0\"),\n\n\tPINCTRL_PIN(45, \"MF_LPC_AD2\"),\n\tPINCTRL_PIN(46, \"LPC_CLKRUNB\"),\n\tPINCTRL_PIN(47, \"MF_LPC_AD0\"),\n\tPINCTRL_PIN(48, \"LPC_FRAMEB\"),\n\tPINCTRL_PIN(49, \"MF_LPC_CLKOUT1\"),\n\tPINCTRL_PIN(50, \"MF_LPC_AD3\"),\n\tPINCTRL_PIN(51, \"MF_LPC_CLKOUT0\"),\n\tPINCTRL_PIN(52, \"MF_LPC_AD1\"),\n\n\tPINCTRL_PIN(60, \"SPI1_MISO\"),\n\tPINCTRL_PIN(61, \"SPI1_CSO_B\"),\n\tPINCTRL_PIN(62, \"SPI1_CLK\"),\n\tPINCTRL_PIN(63, \"MMC1_D6\"),\n\tPINCTRL_PIN(64, \"SPI1_MOSI\"),\n\tPINCTRL_PIN(65, \"MMC1_D5\"),\n\tPINCTRL_PIN(66, \"SPI1_CS1_B\"),\n\tPINCTRL_PIN(67, \"MMC1_D4_SD_WE\"),\n\tPINCTRL_PIN(68, \"MMC1_D7\"),\n\tPINCTRL_PIN(69, \"MMC1_RCLK\"),\n\n\tPINCTRL_PIN(75, \"USB_OC1_B\"),\n\tPINCTRL_PIN(76, \"PMU_RESETBUTTON_B\"),\n\tPINCTRL_PIN(77, \"GPIO_ALERT\"),\n\tPINCTRL_PIN(78, \"SDMMC3_PWR_EN_B\"),\n\tPINCTRL_PIN(79, \"ILB_SERIRQ\"),\n\tPINCTRL_PIN(80, \"USB_OC0_B\"),\n\tPINCTRL_PIN(81, \"SDMMC3_CD_B\"),\n\tPINCTRL_PIN(82, \"SPKR\"),\n\tPINCTRL_PIN(83, \"SUSPWRDNACK\"),\n\tPINCTRL_PIN(84, \"SPARE_PIN\"),\n\tPINCTRL_PIN(85, \"SDMMC3_1P8_EN\"),\n};\n\nstatic const unsigned southeast_pwm0_pins[] = { 5 };\nstatic const unsigned southeast_pwm1_pins[] = { 1 };\nstatic const unsigned southeast_sdmmc1_pins[] = {\n\t16, 17, 20, 23, 24, 26, 63, 65, 67, 68, 69,\n};\nstatic const unsigned southeast_sdmmc2_pins[] = { 15, 18, 19, 21, 22, 25 };\nstatic const unsigned southeast_sdmmc3_pins[] = {\n\t30, 31, 32, 33, 34, 35, 78, 81, 85,\n};\nstatic const unsigned southeast_spi1_pins[] = { 60, 61, 62, 64, 66 };\nstatic const unsigned southeast_spi2_pins[] = { 2, 3, 4, 6, 7 };\n\nstatic const struct intel_pingroup southeast_groups[] = {\n\tPIN_GROUP(\"pwm0_grp\", southeast_pwm0_pins, PINMODE(1, 0)),\n\tPIN_GROUP(\"pwm1_grp\", southeast_pwm1_pins, PINMODE(1, 0)),\n\tPIN_GROUP(\"sdmmc1_grp\", southeast_sdmmc1_pins, PINMODE(1, 0)),\n\tPIN_GROUP(\"sdmmc2_grp\", southeast_sdmmc2_pins, PINMODE(1, 0)),\n\tPIN_GROUP(\"sdmmc3_grp\", southeast_sdmmc3_pins, PINMODE(1, 0)),\n\tPIN_GROUP(\"spi1_grp\", southeast_spi1_pins, PINMODE(1, 0)),\n\tPIN_GROUP(\"spi2_grp\", southeast_spi2_pins, PINMODE(4, 0)),\n};\n\nstatic const char * const southeast_pwm0_groups[] = { \"pwm0_grp\" };\nstatic const char * const southeast_pwm1_groups[] = { \"pwm1_grp\" };\nstatic const char * const southeast_sdmmc1_groups[] = { \"sdmmc1_grp\" };\nstatic const char * const southeast_sdmmc2_groups[] = { \"sdmmc2_grp\" };\nstatic const char * const southeast_sdmmc3_groups[] = { \"sdmmc3_grp\" };\nstatic const char * const southeast_spi1_groups[] = { \"spi1_grp\" };\nstatic const char * const southeast_spi2_groups[] = { \"spi2_grp\" };\n\nstatic const struct intel_function southeast_functions[] = {\n\tFUNCTION(\"pwm0\", southeast_pwm0_groups),\n\tFUNCTION(\"pwm1\", southeast_pwm1_groups),\n\tFUNCTION(\"sdmmc1\", southeast_sdmmc1_groups),\n\tFUNCTION(\"sdmmc2\", southeast_sdmmc2_groups),\n\tFUNCTION(\"sdmmc3\", southeast_sdmmc3_groups),\n\tFUNCTION(\"spi1\", southeast_spi1_groups),\n\tFUNCTION(\"spi2\", southeast_spi2_groups),\n};\n\nstatic const struct intel_padgroup southeast_gpps[] = {\n\tCHV_GPP(0, 7),\n\tCHV_GPP(15, 26),\n\tCHV_GPP(30, 35),\n\tCHV_GPP(45, 52),\n\tCHV_GPP(60, 69),\n\tCHV_GPP(75, 85),\n};\n\nstatic const struct intel_community southeast_communities[] = {\n\tCHV_COMMUNITY(southeast_gpps, 16, 0x94),\n};\n\nstatic const struct intel_pinctrl_soc_data southeast_soc_data = {\n\t.uid = \"4\",\n\t.pins = southeast_pins,\n\t.npins = ARRAY_SIZE(southeast_pins),\n\t.groups = southeast_groups,\n\t.ngroups = ARRAY_SIZE(southeast_groups),\n\t.functions = southeast_functions,\n\t.nfunctions = ARRAY_SIZE(southeast_functions),\n\t.communities = southeast_communities,\n\t.ncommunities = ARRAY_SIZE(southeast_communities),\n};\n\nstatic const struct intel_pinctrl_soc_data *chv_soc_data[] = {\n\t&southwest_soc_data,\n\t&north_soc_data,\n\t&east_soc_data,\n\t&southeast_soc_data,\n\tNULL\n};\n\n \nstatic DEFINE_RAW_SPINLOCK(chv_lock);\n\nstatic u32 chv_pctrl_readl(struct intel_pinctrl *pctrl, unsigned int offset)\n{\n\tconst struct intel_community *community = &pctrl->communities[0];\n\n\treturn readl(community->regs + offset);\n}\n\nstatic void chv_pctrl_writel(struct intel_pinctrl *pctrl, unsigned int offset, u32 value)\n{\n\tconst struct intel_community *community = &pctrl->communities[0];\n\tvoid __iomem *reg = community->regs + offset;\n\n\t \n\twritel(value, reg);\n\treadl(reg);\n}\n\nstatic void __iomem *chv_padreg(struct intel_pinctrl *pctrl, unsigned int offset,\n\t\t\t\tunsigned int reg)\n{\n\tconst struct intel_community *community = &pctrl->communities[0];\n\tunsigned int family_no = offset / MAX_FAMILY_PAD_GPIO_NO;\n\tunsigned int pad_no = offset % MAX_FAMILY_PAD_GPIO_NO;\n\n\toffset = FAMILY_PAD_REGS_SIZE * family_no + GPIO_REGS_SIZE * pad_no;\n\n\treturn community->pad_regs + offset + reg;\n}\n\nstatic u32 chv_readl(struct intel_pinctrl *pctrl, unsigned int pin, unsigned int offset)\n{\n\treturn readl(chv_padreg(pctrl, pin, offset));\n}\n\nstatic void chv_writel(struct intel_pinctrl *pctrl, unsigned int pin, unsigned int offset, u32 value)\n{\n\tvoid __iomem *reg = chv_padreg(pctrl, pin, offset);\n\n\t \n\twritel(value, reg);\n\treadl(reg);\n}\n\n \nstatic bool chv_pad_locked(struct intel_pinctrl *pctrl, unsigned int offset)\n{\n\treturn chv_readl(pctrl, offset, CHV_PADCTRL1) & CHV_PADCTRL1_CFGLOCK;\n}\n\nstatic void chv_pin_dbg_show(struct pinctrl_dev *pctldev, struct seq_file *s,\n\t\t\t     unsigned int offset)\n{\n\tstruct intel_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\tunsigned long flags;\n\tu32 ctrl0, ctrl1;\n\tbool locked;\n\n\traw_spin_lock_irqsave(&chv_lock, flags);\n\n\tctrl0 = chv_readl(pctrl, offset, CHV_PADCTRL0);\n\tctrl1 = chv_readl(pctrl, offset, CHV_PADCTRL1);\n\tlocked = chv_pad_locked(pctrl, offset);\n\n\traw_spin_unlock_irqrestore(&chv_lock, flags);\n\n\tif (ctrl0 & CHV_PADCTRL0_GPIOEN) {\n\t\tseq_puts(s, \"GPIO \");\n\t} else {\n\t\tu32 mode;\n\n\t\tmode = ctrl0 & CHV_PADCTRL0_PMODE_MASK;\n\t\tmode >>= CHV_PADCTRL0_PMODE_SHIFT;\n\n\t\tseq_printf(s, \"mode %d \", mode);\n\t}\n\n\tseq_printf(s, \"0x%08x 0x%08x\", ctrl0, ctrl1);\n\n\tif (locked)\n\t\tseq_puts(s, \" [LOCKED]\");\n}\n\nstatic const struct pinctrl_ops chv_pinctrl_ops = {\n\t.get_groups_count = intel_get_groups_count,\n\t.get_group_name = intel_get_group_name,\n\t.get_group_pins = intel_get_group_pins,\n\t.pin_dbg_show = chv_pin_dbg_show,\n};\n\nstatic int chv_pinmux_set_mux(struct pinctrl_dev *pctldev,\n\t\t\t      unsigned int function, unsigned int group)\n{\n\tstruct intel_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct device *dev = pctrl->dev;\n\tconst struct intel_pingroup *grp;\n\tunsigned long flags;\n\tint i;\n\n\tgrp = &pctrl->soc->groups[group];\n\n\traw_spin_lock_irqsave(&chv_lock, flags);\n\n\t \n\tfor (i = 0; i < grp->grp.npins; i++) {\n\t\tif (chv_pad_locked(pctrl, grp->grp.pins[i])) {\n\t\t\traw_spin_unlock_irqrestore(&chv_lock, flags);\n\t\t\tdev_warn(dev, \"unable to set mode for locked pin %u\\n\", grp->grp.pins[i]);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\tfor (i = 0; i < grp->grp.npins; i++) {\n\t\tint pin = grp->grp.pins[i];\n\t\tunsigned int mode;\n\t\tbool invert_oe;\n\t\tu32 value;\n\n\t\t \n\t\tif (grp->modes)\n\t\t\tmode = grp->modes[i];\n\t\telse\n\t\t\tmode = grp->mode;\n\n\t\t \n\t\tinvert_oe = mode & PINMODE_INVERT_OE;\n\t\tmode &= ~PINMODE_INVERT_OE;\n\n\t\tvalue = chv_readl(pctrl, pin, CHV_PADCTRL0);\n\t\t \n\t\tvalue &= ~CHV_PADCTRL0_GPIOEN;\n\t\t \n\t\tvalue &= ~CHV_PADCTRL0_PMODE_MASK;\n\t\tvalue |= mode << CHV_PADCTRL0_PMODE_SHIFT;\n\t\tchv_writel(pctrl, pin, CHV_PADCTRL0, value);\n\n\t\t \n\t\tvalue = chv_readl(pctrl, pin, CHV_PADCTRL1) & ~CHV_PADCTRL1_INVRXTX_MASK;\n\t\tif (invert_oe)\n\t\t\tvalue |= CHV_PADCTRL1_INVRXTX_TXENABLE;\n\t\tchv_writel(pctrl, pin, CHV_PADCTRL1, value);\n\n\t\tdev_dbg(dev, \"configured pin %u mode %u OE %sinverted\\n\", pin, mode,\n\t\t\tinvert_oe ? \"\" : \"not \");\n\t}\n\n\traw_spin_unlock_irqrestore(&chv_lock, flags);\n\n\treturn 0;\n}\n\nstatic void chv_gpio_clear_triggering(struct intel_pinctrl *pctrl,\n\t\t\t\t      unsigned int offset)\n{\n\tu32 invrxtx_mask = CHV_PADCTRL1_INVRXTX_MASK;\n\tu32 value;\n\n\t \n\tvalue = chv_readl(pctrl, offset, CHV_PADCTRL0);\n\tif (value & CHV_PADCTRL0_GPIOEN)\n\t\tinvrxtx_mask &= ~CHV_PADCTRL1_INVRXTX_TXDATA;\n\n\tvalue = chv_readl(pctrl, offset, CHV_PADCTRL1);\n\tvalue &= ~CHV_PADCTRL1_INTWAKECFG_MASK;\n\tvalue &= ~invrxtx_mask;\n\tchv_writel(pctrl, offset, CHV_PADCTRL1, value);\n}\n\nstatic int chv_gpio_request_enable(struct pinctrl_dev *pctldev,\n\t\t\t\t   struct pinctrl_gpio_range *range,\n\t\t\t\t   unsigned int offset)\n{\n\tstruct intel_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\tunsigned long flags;\n\tu32 value;\n\n\traw_spin_lock_irqsave(&chv_lock, flags);\n\n\tif (chv_pad_locked(pctrl, offset)) {\n\t\tvalue = chv_readl(pctrl, offset, CHV_PADCTRL0);\n\t\tif (!(value & CHV_PADCTRL0_GPIOEN)) {\n\t\t\t \n\t\t\traw_spin_unlock_irqrestore(&chv_lock, flags);\n\t\t\treturn -EBUSY;\n\t\t}\n\t} else {\n\t\tstruct intel_community_context *cctx = &pctrl->context.communities[0];\n\t\tint i;\n\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(cctx->intr_lines); i++) {\n\t\t\tif (cctx->intr_lines[i] == offset) {\n\t\t\t\tcctx->intr_lines[i] = CHV_INVALID_HWIRQ;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tchv_gpio_clear_triggering(pctrl, offset);\n\n\t\tvalue = chv_readl(pctrl, offset, CHV_PADCTRL0);\n\n\t\t \n\t\tif ((value & CHV_PADCTRL0_GPIOCFG_MASK) ==\n\t\t     (CHV_PADCTRL0_GPIOCFG_HIZ << CHV_PADCTRL0_GPIOCFG_SHIFT)) {\n\t\t\tvalue &= ~CHV_PADCTRL0_GPIOCFG_MASK;\n\t\t\tvalue |= CHV_PADCTRL0_GPIOCFG_GPI << CHV_PADCTRL0_GPIOCFG_SHIFT;\n\t\t}\n\n\t\t \n\t\tvalue |= CHV_PADCTRL0_GPIOEN;\n\t\tchv_writel(pctrl, offset, CHV_PADCTRL0, value);\n\t}\n\n\traw_spin_unlock_irqrestore(&chv_lock, flags);\n\n\treturn 0;\n}\n\nstatic void chv_gpio_disable_free(struct pinctrl_dev *pctldev,\n\t\t\t\t  struct pinctrl_gpio_range *range,\n\t\t\t\t  unsigned int offset)\n{\n\tstruct intel_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&chv_lock, flags);\n\n\tif (!chv_pad_locked(pctrl, offset))\n\t\tchv_gpio_clear_triggering(pctrl, offset);\n\n\traw_spin_unlock_irqrestore(&chv_lock, flags);\n}\n\nstatic int chv_gpio_set_direction(struct pinctrl_dev *pctldev,\n\t\t\t\t  struct pinctrl_gpio_range *range,\n\t\t\t\t  unsigned int offset, bool input)\n{\n\tstruct intel_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\tunsigned long flags;\n\tu32 ctrl0;\n\n\traw_spin_lock_irqsave(&chv_lock, flags);\n\n\tctrl0 = chv_readl(pctrl, offset, CHV_PADCTRL0) & ~CHV_PADCTRL0_GPIOCFG_MASK;\n\tif (input)\n\t\tctrl0 |= CHV_PADCTRL0_GPIOCFG_GPI << CHV_PADCTRL0_GPIOCFG_SHIFT;\n\telse\n\t\tctrl0 |= CHV_PADCTRL0_GPIOCFG_GPO << CHV_PADCTRL0_GPIOCFG_SHIFT;\n\tchv_writel(pctrl, offset, CHV_PADCTRL0, ctrl0);\n\n\traw_spin_unlock_irqrestore(&chv_lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct pinmux_ops chv_pinmux_ops = {\n\t.get_functions_count = intel_get_functions_count,\n\t.get_function_name = intel_get_function_name,\n\t.get_function_groups = intel_get_function_groups,\n\t.set_mux = chv_pinmux_set_mux,\n\t.gpio_request_enable = chv_gpio_request_enable,\n\t.gpio_disable_free = chv_gpio_disable_free,\n\t.gpio_set_direction = chv_gpio_set_direction,\n};\n\nstatic int chv_config_get(struct pinctrl_dev *pctldev, unsigned int pin,\n\t\t\t  unsigned long *config)\n{\n\tstruct intel_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\tenum pin_config_param param = pinconf_to_config_param(*config);\n\tunsigned long flags;\n\tu32 ctrl0, ctrl1;\n\tu16 arg = 0;\n\tu32 term;\n\n\traw_spin_lock_irqsave(&chv_lock, flags);\n\tctrl0 = chv_readl(pctrl, pin, CHV_PADCTRL0);\n\tctrl1 = chv_readl(pctrl, pin, CHV_PADCTRL1);\n\traw_spin_unlock_irqrestore(&chv_lock, flags);\n\n\tterm = (ctrl0 & CHV_PADCTRL0_TERM_MASK) >> CHV_PADCTRL0_TERM_SHIFT;\n\n\tswitch (param) {\n\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\tif (term)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\tif (!(ctrl0 & CHV_PADCTRL0_TERM_UP))\n\t\t\treturn -EINVAL;\n\n\t\tswitch (term) {\n\t\tcase CHV_PADCTRL0_TERM_20K:\n\t\t\targ = 20000;\n\t\t\tbreak;\n\t\tcase CHV_PADCTRL0_TERM_5K:\n\t\t\targ = 5000;\n\t\t\tbreak;\n\t\tcase CHV_PADCTRL0_TERM_1K:\n\t\t\targ = 1000;\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\tif (!term || (ctrl0 & CHV_PADCTRL0_TERM_UP))\n\t\t\treturn -EINVAL;\n\n\t\tswitch (term) {\n\t\tcase CHV_PADCTRL0_TERM_20K:\n\t\t\targ = 20000;\n\t\t\tbreak;\n\t\tcase CHV_PADCTRL0_TERM_5K:\n\t\t\targ = 5000;\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tcase PIN_CONFIG_BIAS_HIGH_IMPEDANCE: {\n\t\tu32 cfg;\n\n\t\tcfg = ctrl0 & CHV_PADCTRL0_GPIOCFG_MASK;\n\t\tcfg >>= CHV_PADCTRL0_GPIOCFG_SHIFT;\n\t\tif (cfg != CHV_PADCTRL0_GPIOCFG_HIZ)\n\t\t\treturn -EINVAL;\n\n\t\tbreak;\n\n\tcase PIN_CONFIG_DRIVE_PUSH_PULL:\n\t\tif (ctrl1 & CHV_PADCTRL1_ODEN)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\tcase PIN_CONFIG_DRIVE_OPEN_DRAIN:\n\t\tif (!(ctrl1 & CHV_PADCTRL1_ODEN))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\t*config = pinconf_to_config_packed(param, arg);\n\treturn 0;\n}\n\nstatic int chv_config_set_pull(struct intel_pinctrl *pctrl, unsigned int pin,\n\t\t\t       enum pin_config_param param, u32 arg)\n{\n\tunsigned long flags;\n\tu32 ctrl0, pull;\n\n\traw_spin_lock_irqsave(&chv_lock, flags);\n\tctrl0 = chv_readl(pctrl, pin, CHV_PADCTRL0);\n\n\tswitch (param) {\n\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\tctrl0 &= ~(CHV_PADCTRL0_TERM_MASK | CHV_PADCTRL0_TERM_UP);\n\t\tbreak;\n\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\tctrl0 &= ~(CHV_PADCTRL0_TERM_MASK | CHV_PADCTRL0_TERM_UP);\n\n\t\tswitch (arg) {\n\t\tcase 1000:\n\t\t\t \n\t\t\tpull = CHV_PADCTRL0_TERM_1K << CHV_PADCTRL0_TERM_SHIFT;\n\t\t\tbreak;\n\t\tcase 5000:\n\t\t\tpull = CHV_PADCTRL0_TERM_5K << CHV_PADCTRL0_TERM_SHIFT;\n\t\t\tbreak;\n\t\tcase 20000:\n\t\t\tpull = CHV_PADCTRL0_TERM_20K << CHV_PADCTRL0_TERM_SHIFT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\traw_spin_unlock_irqrestore(&chv_lock, flags);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tctrl0 |= CHV_PADCTRL0_TERM_UP | pull;\n\t\tbreak;\n\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\tctrl0 &= ~(CHV_PADCTRL0_TERM_MASK | CHV_PADCTRL0_TERM_UP);\n\n\t\tswitch (arg) {\n\t\tcase 5000:\n\t\t\tpull = CHV_PADCTRL0_TERM_5K << CHV_PADCTRL0_TERM_SHIFT;\n\t\t\tbreak;\n\t\tcase 20000:\n\t\t\tpull = CHV_PADCTRL0_TERM_20K << CHV_PADCTRL0_TERM_SHIFT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\traw_spin_unlock_irqrestore(&chv_lock, flags);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tctrl0 |= pull;\n\t\tbreak;\n\n\tdefault:\n\t\traw_spin_unlock_irqrestore(&chv_lock, flags);\n\t\treturn -EINVAL;\n\t}\n\n\tchv_writel(pctrl, pin, CHV_PADCTRL0, ctrl0);\n\traw_spin_unlock_irqrestore(&chv_lock, flags);\n\n\treturn 0;\n}\n\nstatic int chv_config_set_oden(struct intel_pinctrl *pctrl, unsigned int pin,\n\t\t\t       bool enable)\n{\n\tunsigned long flags;\n\tu32 ctrl1;\n\n\traw_spin_lock_irqsave(&chv_lock, flags);\n\tctrl1 = chv_readl(pctrl, pin, CHV_PADCTRL1);\n\n\tif (enable)\n\t\tctrl1 |= CHV_PADCTRL1_ODEN;\n\telse\n\t\tctrl1 &= ~CHV_PADCTRL1_ODEN;\n\n\tchv_writel(pctrl, pin, CHV_PADCTRL1, ctrl1);\n\traw_spin_unlock_irqrestore(&chv_lock, flags);\n\n\treturn 0;\n}\n\nstatic int chv_config_set(struct pinctrl_dev *pctldev, unsigned int pin,\n\t\t\t  unsigned long *configs, unsigned int nconfigs)\n{\n\tstruct intel_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct device *dev = pctrl->dev;\n\tenum pin_config_param param;\n\tint i, ret;\n\tu32 arg;\n\n\tif (chv_pad_locked(pctrl, pin))\n\t\treturn -EBUSY;\n\n\tfor (i = 0; i < nconfigs; i++) {\n\t\tparam = pinconf_to_config_param(configs[i]);\n\t\targ = pinconf_to_config_argument(configs[i]);\n\n\t\tswitch (param) {\n\t\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\t\tret = chv_config_set_pull(pctrl, pin, param, arg);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\n\t\tcase PIN_CONFIG_DRIVE_PUSH_PULL:\n\t\t\tret = chv_config_set_oden(pctrl, pin, false);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\n\t\tcase PIN_CONFIG_DRIVE_OPEN_DRAIN:\n\t\t\tret = chv_config_set_oden(pctrl, pin, true);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\n\t\tdev_dbg(dev, \"pin %d set config %d arg %u\\n\", pin, param, arg);\n\t}\n\n\treturn 0;\n}\n\nstatic int chv_config_group_get(struct pinctrl_dev *pctldev,\n\t\t\t\tunsigned int group,\n\t\t\t\tunsigned long *config)\n{\n\tconst unsigned int *pins;\n\tunsigned int npins;\n\tint ret;\n\n\tret = intel_get_group_pins(pctldev, group, &pins, &npins);\n\tif (ret)\n\t\treturn ret;\n\n\tret = chv_config_get(pctldev, pins[0], config);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int chv_config_group_set(struct pinctrl_dev *pctldev,\n\t\t\t\tunsigned int group, unsigned long *configs,\n\t\t\t\tunsigned int num_configs)\n{\n\tconst unsigned int *pins;\n\tunsigned int npins;\n\tint i, ret;\n\n\tret = intel_get_group_pins(pctldev, group, &pins, &npins);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < npins; i++) {\n\t\tret = chv_config_set(pctldev, pins[i], configs, num_configs);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct pinconf_ops chv_pinconf_ops = {\n\t.is_generic = true,\n\t.pin_config_set = chv_config_set,\n\t.pin_config_get = chv_config_get,\n\t.pin_config_group_get = chv_config_group_get,\n\t.pin_config_group_set = chv_config_group_set,\n};\n\nstatic struct pinctrl_desc chv_pinctrl_desc = {\n\t.pctlops = &chv_pinctrl_ops,\n\t.pmxops = &chv_pinmux_ops,\n\t.confops = &chv_pinconf_ops,\n\t.owner = THIS_MODULE,\n};\n\nstatic int chv_gpio_get(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct intel_pinctrl *pctrl = gpiochip_get_data(chip);\n\tunsigned long flags;\n\tu32 ctrl0, cfg;\n\n\traw_spin_lock_irqsave(&chv_lock, flags);\n\tctrl0 = chv_readl(pctrl, offset, CHV_PADCTRL0);\n\traw_spin_unlock_irqrestore(&chv_lock, flags);\n\n\tcfg = ctrl0 & CHV_PADCTRL0_GPIOCFG_MASK;\n\tcfg >>= CHV_PADCTRL0_GPIOCFG_SHIFT;\n\n\tif (cfg == CHV_PADCTRL0_GPIOCFG_GPO)\n\t\treturn !!(ctrl0 & CHV_PADCTRL0_GPIOTXSTATE);\n\treturn !!(ctrl0 & CHV_PADCTRL0_GPIORXSTATE);\n}\n\nstatic void chv_gpio_set(struct gpio_chip *chip, unsigned int offset, int value)\n{\n\tstruct intel_pinctrl *pctrl = gpiochip_get_data(chip);\n\tunsigned long flags;\n\tu32 ctrl0;\n\n\traw_spin_lock_irqsave(&chv_lock, flags);\n\n\tctrl0 = chv_readl(pctrl, offset, CHV_PADCTRL0);\n\n\tif (value)\n\t\tctrl0 |= CHV_PADCTRL0_GPIOTXSTATE;\n\telse\n\t\tctrl0 &= ~CHV_PADCTRL0_GPIOTXSTATE;\n\n\tchv_writel(pctrl, offset, CHV_PADCTRL0, ctrl0);\n\n\traw_spin_unlock_irqrestore(&chv_lock, flags);\n}\n\nstatic int chv_gpio_get_direction(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct intel_pinctrl *pctrl = gpiochip_get_data(chip);\n\tu32 ctrl0, direction;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&chv_lock, flags);\n\tctrl0 = chv_readl(pctrl, offset, CHV_PADCTRL0);\n\traw_spin_unlock_irqrestore(&chv_lock, flags);\n\n\tdirection = ctrl0 & CHV_PADCTRL0_GPIOCFG_MASK;\n\tdirection >>= CHV_PADCTRL0_GPIOCFG_SHIFT;\n\n\tif (direction == CHV_PADCTRL0_GPIOCFG_GPO)\n\t\treturn GPIO_LINE_DIRECTION_OUT;\n\n\treturn GPIO_LINE_DIRECTION_IN;\n}\n\nstatic int chv_gpio_direction_input(struct gpio_chip *chip, unsigned int offset)\n{\n\treturn pinctrl_gpio_direction_input(chip->base + offset);\n}\n\nstatic int chv_gpio_direction_output(struct gpio_chip *chip, unsigned int offset,\n\t\t\t\t     int value)\n{\n\tchv_gpio_set(chip, offset, value);\n\treturn pinctrl_gpio_direction_output(chip->base + offset);\n}\n\nstatic const struct gpio_chip chv_gpio_chip = {\n\t.owner = THIS_MODULE,\n\t.request = gpiochip_generic_request,\n\t.free = gpiochip_generic_free,\n\t.get_direction = chv_gpio_get_direction,\n\t.direction_input = chv_gpio_direction_input,\n\t.direction_output = chv_gpio_direction_output,\n\t.get = chv_gpio_get,\n\t.set = chv_gpio_set,\n};\n\nstatic void chv_gpio_irq_ack(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct intel_pinctrl *pctrl = gpiochip_get_data(gc);\n\tirq_hw_number_t hwirq = irqd_to_hwirq(d);\n\tu32 intr_line;\n\n\traw_spin_lock(&chv_lock);\n\n\tintr_line = chv_readl(pctrl, hwirq, CHV_PADCTRL0);\n\tintr_line &= CHV_PADCTRL0_INTSEL_MASK;\n\tintr_line >>= CHV_PADCTRL0_INTSEL_SHIFT;\n\tchv_pctrl_writel(pctrl, CHV_INTSTAT, BIT(intr_line));\n\n\traw_spin_unlock(&chv_lock);\n}\n\nstatic void chv_gpio_irq_mask_unmask(struct gpio_chip *gc, irq_hw_number_t hwirq, bool mask)\n{\n\tstruct intel_pinctrl *pctrl = gpiochip_get_data(gc);\n\tu32 value, intr_line;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&chv_lock, flags);\n\n\tintr_line = chv_readl(pctrl, hwirq, CHV_PADCTRL0);\n\tintr_line &= CHV_PADCTRL0_INTSEL_MASK;\n\tintr_line >>= CHV_PADCTRL0_INTSEL_SHIFT;\n\n\tvalue = chv_pctrl_readl(pctrl, CHV_INTMASK);\n\tif (mask)\n\t\tvalue &= ~BIT(intr_line);\n\telse\n\t\tvalue |= BIT(intr_line);\n\tchv_pctrl_writel(pctrl, CHV_INTMASK, value);\n\n\traw_spin_unlock_irqrestore(&chv_lock, flags);\n}\n\nstatic void chv_gpio_irq_mask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tirq_hw_number_t hwirq = irqd_to_hwirq(d);\n\n\tchv_gpio_irq_mask_unmask(gc, hwirq, true);\n\tgpiochip_disable_irq(gc, hwirq);\n}\n\nstatic void chv_gpio_irq_unmask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tirq_hw_number_t hwirq = irqd_to_hwirq(d);\n\n\tgpiochip_enable_irq(gc, hwirq);\n\tchv_gpio_irq_mask_unmask(gc, hwirq, false);\n}\n\nstatic unsigned chv_gpio_irq_startup(struct irq_data *d)\n{\n\t \n\tif (irqd_get_trigger_type(d) == IRQ_TYPE_NONE) {\n\t\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\t\tstruct intel_pinctrl *pctrl = gpiochip_get_data(gc);\n\t\tstruct device *dev = pctrl->dev;\n\t\tstruct intel_community_context *cctx = &pctrl->context.communities[0];\n\t\tirq_hw_number_t hwirq = irqd_to_hwirq(d);\n\t\tirq_flow_handler_t handler;\n\t\tunsigned long flags;\n\t\tu32 intsel, value;\n\n\t\traw_spin_lock_irqsave(&chv_lock, flags);\n\t\tintsel = chv_readl(pctrl, hwirq, CHV_PADCTRL0);\n\t\tintsel &= CHV_PADCTRL0_INTSEL_MASK;\n\t\tintsel >>= CHV_PADCTRL0_INTSEL_SHIFT;\n\n\t\tvalue = chv_readl(pctrl, hwirq, CHV_PADCTRL1);\n\t\tif (value & CHV_PADCTRL1_INTWAKECFG_LEVEL)\n\t\t\thandler = handle_level_irq;\n\t\telse\n\t\t\thandler = handle_edge_irq;\n\n\t\tif (cctx->intr_lines[intsel] == CHV_INVALID_HWIRQ) {\n\t\t\tirq_set_handler_locked(d, handler);\n\t\t\tdev_dbg(dev, \"using interrupt line %u for IRQ_TYPE_NONE on pin %lu\\n\",\n\t\t\t\tintsel, hwirq);\n\t\t\tcctx->intr_lines[intsel] = hwirq;\n\t\t}\n\t\traw_spin_unlock_irqrestore(&chv_lock, flags);\n\t}\n\n\tchv_gpio_irq_unmask(d);\n\treturn 0;\n}\n\nstatic int chv_gpio_set_intr_line(struct intel_pinctrl *pctrl, unsigned int pin)\n{\n\tstruct device *dev = pctrl->dev;\n\tstruct intel_community_context *cctx = &pctrl->context.communities[0];\n\tconst struct intel_community *community = &pctrl->communities[0];\n\tu32 value, intsel;\n\tint i;\n\n\tvalue = chv_readl(pctrl, pin, CHV_PADCTRL0);\n\tintsel = (value & CHV_PADCTRL0_INTSEL_MASK) >> CHV_PADCTRL0_INTSEL_SHIFT;\n\n\tif (cctx->intr_lines[intsel] == pin)\n\t\treturn 0;\n\n\tif (cctx->intr_lines[intsel] == CHV_INVALID_HWIRQ) {\n\t\tdev_dbg(dev, \"using interrupt line %u for pin %u\\n\", intsel, pin);\n\t\tcctx->intr_lines[intsel] = pin;\n\t\treturn 0;\n\t}\n\n\t \n\tdev_info(dev, \"interrupt line %u is used by both pin %u and pin %u\\n\", intsel,\n\t\t cctx->intr_lines[intsel], pin);\n\n\tif (chv_pad_locked(pctrl, pin))\n\t\treturn -EBUSY;\n\n\t \n\tfor (i = community->nirqs - 1; i >= 0; i--) {\n\t\tif (cctx->intr_lines[i] == CHV_INVALID_HWIRQ)\n\t\t\tbreak;\n\t}\n\tif (i < 0)\n\t\treturn -EBUSY;\n\n\tdev_info(dev, \"changing the interrupt line for pin %u to %d\\n\", pin, i);\n\n\tvalue = (value & ~CHV_PADCTRL0_INTSEL_MASK) | (i << CHV_PADCTRL0_INTSEL_SHIFT);\n\tchv_writel(pctrl, pin, CHV_PADCTRL0, value);\n\tcctx->intr_lines[i] = pin;\n\n\treturn 0;\n}\n\nstatic int chv_gpio_irq_type(struct irq_data *d, unsigned int type)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct intel_pinctrl *pctrl = gpiochip_get_data(gc);\n\tirq_hw_number_t hwirq = irqd_to_hwirq(d);\n\tunsigned long flags;\n\tu32 value;\n\tint ret;\n\n\traw_spin_lock_irqsave(&chv_lock, flags);\n\n\tret = chv_gpio_set_intr_line(pctrl, hwirq);\n\tif (ret) {\n\t\traw_spin_unlock_irqrestore(&chv_lock, flags);\n\t\treturn ret;\n\t}\n\n\t \n\tif (!chv_pad_locked(pctrl, hwirq)) {\n\t\tvalue = chv_readl(pctrl, hwirq, CHV_PADCTRL1);\n\t\tvalue &= ~CHV_PADCTRL1_INTWAKECFG_MASK;\n\t\tvalue &= ~CHV_PADCTRL1_INVRXTX_MASK;\n\n\t\tif (type & IRQ_TYPE_EDGE_BOTH) {\n\t\t\tif ((type & IRQ_TYPE_EDGE_BOTH) == IRQ_TYPE_EDGE_BOTH)\n\t\t\t\tvalue |= CHV_PADCTRL1_INTWAKECFG_BOTH;\n\t\t\telse if (type & IRQ_TYPE_EDGE_RISING)\n\t\t\t\tvalue |= CHV_PADCTRL1_INTWAKECFG_RISING;\n\t\t\telse if (type & IRQ_TYPE_EDGE_FALLING)\n\t\t\t\tvalue |= CHV_PADCTRL1_INTWAKECFG_FALLING;\n\t\t} else if (type & IRQ_TYPE_LEVEL_MASK) {\n\t\t\tvalue |= CHV_PADCTRL1_INTWAKECFG_LEVEL;\n\t\t\tif (type & IRQ_TYPE_LEVEL_LOW)\n\t\t\t\tvalue |= CHV_PADCTRL1_INVRXTX_RXDATA;\n\t\t}\n\n\t\tchv_writel(pctrl, hwirq, CHV_PADCTRL1, value);\n\t}\n\n\tif (type & IRQ_TYPE_EDGE_BOTH)\n\t\tirq_set_handler_locked(d, handle_edge_irq);\n\telse if (type & IRQ_TYPE_LEVEL_MASK)\n\t\tirq_set_handler_locked(d, handle_level_irq);\n\n\traw_spin_unlock_irqrestore(&chv_lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct irq_chip chv_gpio_irq_chip = {\n\t.name\t\t= \"chv-gpio\",\n\t.irq_startup\t= chv_gpio_irq_startup,\n\t.irq_ack\t= chv_gpio_irq_ack,\n\t.irq_mask\t= chv_gpio_irq_mask,\n\t.irq_unmask\t= chv_gpio_irq_unmask,\n\t.irq_set_type\t= chv_gpio_irq_type,\n\t.flags\t\t= IRQCHIP_SKIP_SET_WAKE | IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic void chv_gpio_irq_handler(struct irq_desc *desc)\n{\n\tstruct gpio_chip *gc = irq_desc_get_handler_data(desc);\n\tstruct intel_pinctrl *pctrl = gpiochip_get_data(gc);\n\tstruct device *dev = pctrl->dev;\n\tconst struct intel_community *community = &pctrl->communities[0];\n\tstruct intel_community_context *cctx = &pctrl->context.communities[0];\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tunsigned long pending;\n\tunsigned long flags;\n\tu32 intr_line;\n\n\tchained_irq_enter(chip, desc);\n\n\traw_spin_lock_irqsave(&chv_lock, flags);\n\tpending = chv_pctrl_readl(pctrl, CHV_INTSTAT);\n\traw_spin_unlock_irqrestore(&chv_lock, flags);\n\n\tfor_each_set_bit(intr_line, &pending, community->nirqs) {\n\t\tunsigned int offset;\n\n\t\toffset = cctx->intr_lines[intr_line];\n\t\tif (offset == CHV_INVALID_HWIRQ) {\n\t\t\tdev_warn_once(dev, \"interrupt on unmapped interrupt line %u\\n\", intr_line);\n\t\t\t \n\t\t\toffset = 0;\n\t\t}\n\n\t\tgeneric_handle_domain_irq(gc->irq.domain, offset);\n\t}\n\n\tchained_irq_exit(chip, desc);\n}\n\n \nstatic const struct dmi_system_id chv_no_valid_mask[] = {\n\t \n\tfor (i = 0; i < pctrl->soc->npins; i++) {\n\t\tconst struct pinctrl_pin_desc *desc;\n\t\tu32 intsel;\n\n\t\tdesc = &pctrl->soc->pins[i];\n\n\t\tintsel = chv_readl(pctrl, desc->number, CHV_PADCTRL0);\n\t\tintsel &= CHV_PADCTRL0_INTSEL_MASK;\n\t\tintsel >>= CHV_PADCTRL0_INTSEL_SHIFT;\n\n\t\tif (intsel >= community->nirqs)\n\t\t\tclear_bit(desc->number, valid_mask);\n\t}\n}\n\nstatic int chv_gpio_irq_init_hw(struct gpio_chip *chip)\n{\n\tstruct intel_pinctrl *pctrl = gpiochip_get_data(chip);\n\tconst struct intel_community *community = &pctrl->communities[0];\n\n\t \n\tif (!pctrl->chip.irq.init_valid_mask) {\n\t\t \n\t\tchv_pctrl_writel(pctrl, CHV_INTMASK, GENMASK(31, community->nirqs));\n\t}\n\n\t \n\tchv_pctrl_writel(pctrl, CHV_INTSTAT, 0xffff);\n\n\treturn 0;\n}\n\nstatic int chv_gpio_add_pin_ranges(struct gpio_chip *chip)\n{\n\tstruct intel_pinctrl *pctrl = gpiochip_get_data(chip);\n\tstruct device *dev = pctrl->dev;\n\tconst struct intel_community *community = &pctrl->communities[0];\n\tconst struct intel_padgroup *gpp;\n\tint ret, i;\n\n\tfor (i = 0; i < community->ngpps; i++) {\n\t\tgpp = &community->gpps[i];\n\t\tret = gpiochip_add_pin_range(chip, dev_name(dev), gpp->base, gpp->base, gpp->size);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to add GPIO pin range\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int chv_gpio_probe(struct intel_pinctrl *pctrl, int irq)\n{\n\tconst struct intel_community *community = &pctrl->communities[0];\n\tconst struct intel_padgroup *gpp;\n\tstruct gpio_chip *chip = &pctrl->chip;\n\tstruct device *dev = pctrl->dev;\n\tbool need_valid_mask = !dmi_check_system(chv_no_valid_mask);\n\tint ret, i, irq_base;\n\n\t*chip = chv_gpio_chip;\n\n\tchip->ngpio = pctrl->soc->pins[pctrl->soc->npins - 1].number + 1;\n\tchip->label = dev_name(dev);\n\tchip->add_pin_ranges = chv_gpio_add_pin_ranges;\n\tchip->parent = dev;\n\tchip->base = -1;\n\n\tpctrl->irq = irq;\n\n\tgpio_irq_chip_set_chip(&chip->irq, &chv_gpio_irq_chip);\n\tchip->irq.init_hw = chv_gpio_irq_init_hw;\n\tchip->irq.parent_handler = chv_gpio_irq_handler;\n\tchip->irq.num_parents = 1;\n\tchip->irq.parents = &pctrl->irq;\n\tchip->irq.default_type = IRQ_TYPE_NONE;\n\tchip->irq.handler = handle_bad_irq;\n\tif (need_valid_mask) {\n\t\tchip->irq.init_valid_mask = chv_init_irq_valid_mask;\n\t} else {\n\t\tirq_base = devm_irq_alloc_descs(dev, -1, 0, pctrl->soc->npins, NUMA_NO_NODE);\n\t\tif (irq_base < 0) {\n\t\t\tdev_err(dev, \"Failed to allocate IRQ numbers\\n\");\n\t\t\treturn irq_base;\n\t\t}\n\t}\n\n\tret = devm_gpiochip_add_data(dev, chip, pctrl);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to register gpiochip\\n\");\n\t\treturn ret;\n\t}\n\n\tif (!need_valid_mask) {\n\t\tfor (i = 0; i < community->ngpps; i++) {\n\t\t\tgpp = &community->gpps[i];\n\n\t\t\tirq_domain_associate_many(chip->irq.domain, irq_base,\n\t\t\t\t\t\t  gpp->base, gpp->size);\n\t\t\tirq_base += gpp->size;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic acpi_status chv_pinctrl_mmio_access_handler(u32 function,\n\tacpi_physical_address address, u32 bits, u64 *value,\n\tvoid *handler_context, void *region_context)\n{\n\tstruct intel_pinctrl *pctrl = region_context;\n\tunsigned long flags;\n\tacpi_status ret = AE_OK;\n\n\traw_spin_lock_irqsave(&chv_lock, flags);\n\n\tif (function == ACPI_WRITE)\n\t\tchv_pctrl_writel(pctrl, address, *value);\n\telse if (function == ACPI_READ)\n\t\t*value = chv_pctrl_readl(pctrl, address);\n\telse\n\t\tret = AE_BAD_PARAMETER;\n\n\traw_spin_unlock_irqrestore(&chv_lock, flags);\n\n\treturn ret;\n}\n\nstatic int chv_pinctrl_probe(struct platform_device *pdev)\n{\n\tconst struct intel_pinctrl_soc_data *soc_data;\n\tstruct intel_community_context *cctx;\n\tstruct intel_community *community;\n\tstruct device *dev = &pdev->dev;\n\tstruct intel_pinctrl *pctrl;\n\tacpi_status status;\n\tunsigned int i;\n\tint ret, irq;\n\n\tsoc_data = intel_pinctrl_get_soc_data(pdev);\n\tif (IS_ERR(soc_data))\n\t\treturn PTR_ERR(soc_data);\n\n\tpctrl = devm_kzalloc(dev, sizeof(*pctrl), GFP_KERNEL);\n\tif (!pctrl)\n\t\treturn -ENOMEM;\n\n\tpctrl->dev = dev;\n\tpctrl->soc = soc_data;\n\n\tpctrl->ncommunities = pctrl->soc->ncommunities;\n\tpctrl->communities = devm_kmemdup(dev, pctrl->soc->communities,\n\t\t\t\t\t  pctrl->ncommunities * sizeof(*pctrl->communities),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!pctrl->communities)\n\t\treturn -ENOMEM;\n\n\tcommunity = &pctrl->communities[0];\n\tcommunity->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(community->regs))\n\t\treturn PTR_ERR(community->regs);\n\n\tcommunity->pad_regs = community->regs + FAMILY_PAD_REGS_OFF;\n\n#ifdef CONFIG_PM_SLEEP\n\tpctrl->context.pads = devm_kcalloc(dev, pctrl->soc->npins,\n\t\t\t\t\t   sizeof(*pctrl->context.pads),\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!pctrl->context.pads)\n\t\treturn -ENOMEM;\n#endif\n\n\tpctrl->context.communities = devm_kcalloc(dev, pctrl->soc->ncommunities,\n\t\t\t\t\t\t  sizeof(*pctrl->context.communities),\n\t\t\t\t\t\t  GFP_KERNEL);\n\tif (!pctrl->context.communities)\n\t\treturn -ENOMEM;\n\n\tcctx = &pctrl->context.communities[0];\n\tfor (i = 0; i < ARRAY_SIZE(cctx->intr_lines); i++)\n\t\tcctx->intr_lines[i] = CHV_INVALID_HWIRQ;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tpctrl->pctldesc = chv_pinctrl_desc;\n\tpctrl->pctldesc.name = dev_name(dev);\n\tpctrl->pctldesc.pins = pctrl->soc->pins;\n\tpctrl->pctldesc.npins = pctrl->soc->npins;\n\n\tpctrl->pctldev = devm_pinctrl_register(dev, &pctrl->pctldesc, pctrl);\n\tif (IS_ERR(pctrl->pctldev)) {\n\t\tdev_err(dev, \"failed to register pinctrl driver\\n\");\n\t\treturn PTR_ERR(pctrl->pctldev);\n\t}\n\n\tret = chv_gpio_probe(pctrl, irq);\n\tif (ret)\n\t\treturn ret;\n\n\tstatus = acpi_install_address_space_handler(ACPI_HANDLE(dev),\n\t\t\t\t\tcommunity->acpi_space_id,\n\t\t\t\t\tchv_pinctrl_mmio_access_handler,\n\t\t\t\t\tNULL, pctrl);\n\tif (ACPI_FAILURE(status))\n\t\tdev_err(dev, \"failed to install ACPI addr space handler\\n\");\n\n\tplatform_set_drvdata(pdev, pctrl);\n\n\treturn 0;\n}\n\nstatic int chv_pinctrl_remove(struct platform_device *pdev)\n{\n\tstruct intel_pinctrl *pctrl = platform_get_drvdata(pdev);\n\tconst struct intel_community *community = &pctrl->communities[0];\n\n\tacpi_remove_address_space_handler(ACPI_HANDLE(&pdev->dev),\n\t\t\t\t\t  community->acpi_space_id,\n\t\t\t\t\t  chv_pinctrl_mmio_access_handler);\n\n\treturn 0;\n}\n\nstatic int chv_pinctrl_suspend_noirq(struct device *dev)\n{\n\tstruct intel_pinctrl *pctrl = dev_get_drvdata(dev);\n\tstruct intel_community_context *cctx = &pctrl->context.communities[0];\n\tunsigned long flags;\n\tint i;\n\n\traw_spin_lock_irqsave(&chv_lock, flags);\n\n\tcctx->saved_intmask = chv_pctrl_readl(pctrl, CHV_INTMASK);\n\n\tfor (i = 0; i < pctrl->soc->npins; i++) {\n\t\tconst struct pinctrl_pin_desc *desc;\n\t\tstruct intel_pad_context *ctx = &pctrl->context.pads[i];\n\n\t\tdesc = &pctrl->soc->pins[i];\n\t\tif (chv_pad_locked(pctrl, desc->number))\n\t\t\tcontinue;\n\n\t\tctx->padctrl0 = chv_readl(pctrl, desc->number, CHV_PADCTRL0);\n\t\tctx->padctrl0 &= ~CHV_PADCTRL0_GPIORXSTATE;\n\n\t\tctx->padctrl1 = chv_readl(pctrl, desc->number, CHV_PADCTRL1);\n\t}\n\n\traw_spin_unlock_irqrestore(&chv_lock, flags);\n\n\treturn 0;\n}\n\nstatic int chv_pinctrl_resume_noirq(struct device *dev)\n{\n\tstruct intel_pinctrl *pctrl = dev_get_drvdata(dev);\n\tstruct intel_community_context *cctx = &pctrl->context.communities[0];\n\tunsigned long flags;\n\tint i;\n\n\traw_spin_lock_irqsave(&chv_lock, flags);\n\n\t \n\tchv_pctrl_writel(pctrl, CHV_INTMASK, 0x0000);\n\n\tfor (i = 0; i < pctrl->soc->npins; i++) {\n\t\tconst struct pinctrl_pin_desc *desc;\n\t\tstruct intel_pad_context *ctx = &pctrl->context.pads[i];\n\t\tu32 val;\n\n\t\tdesc = &pctrl->soc->pins[i];\n\t\tif (chv_pad_locked(pctrl, desc->number))\n\t\t\tcontinue;\n\n\t\t \n\t\tval = chv_readl(pctrl, desc->number, CHV_PADCTRL0);\n\t\tval &= ~CHV_PADCTRL0_GPIORXSTATE;\n\t\tif (ctx->padctrl0 != val) {\n\t\t\tchv_writel(pctrl, desc->number, CHV_PADCTRL0, ctx->padctrl0);\n\t\t\tdev_dbg(dev, \"restored pin %2u ctrl0 0x%08x\\n\", desc->number,\n\t\t\t\tchv_readl(pctrl, desc->number, CHV_PADCTRL0));\n\t\t}\n\n\t\tval = chv_readl(pctrl, desc->number, CHV_PADCTRL1);\n\t\tif (ctx->padctrl1 != val) {\n\t\t\tchv_writel(pctrl, desc->number, CHV_PADCTRL1, ctx->padctrl1);\n\t\t\tdev_dbg(dev, \"restored pin %2u ctrl1 0x%08x\\n\", desc->number,\n\t\t\t\tchv_readl(pctrl, desc->number, CHV_PADCTRL1));\n\t\t}\n\t}\n\n\t \n\tchv_pctrl_writel(pctrl, CHV_INTSTAT, 0xffff);\n\tchv_pctrl_writel(pctrl, CHV_INTMASK, cctx->saved_intmask);\n\n\traw_spin_unlock_irqrestore(&chv_lock, flags);\n\n\treturn 0;\n}\n\nstatic DEFINE_NOIRQ_DEV_PM_OPS(chv_pinctrl_pm_ops,\n\t\t\t       chv_pinctrl_suspend_noirq, chv_pinctrl_resume_noirq);\n\nstatic const struct acpi_device_id chv_pinctrl_acpi_match[] = {\n\t{ \"INT33FF\", (kernel_ulong_t)chv_soc_data },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, chv_pinctrl_acpi_match);\n\nstatic struct platform_driver chv_pinctrl_driver = {\n\t.probe = chv_pinctrl_probe,\n\t.remove = chv_pinctrl_remove,\n\t.driver = {\n\t\t.name = \"cherryview-pinctrl\",\n\t\t.pm = pm_sleep_ptr(&chv_pinctrl_pm_ops),\n\t\t.acpi_match_table = chv_pinctrl_acpi_match,\n\t},\n};\n\nstatic int __init chv_pinctrl_init(void)\n{\n\treturn platform_driver_register(&chv_pinctrl_driver);\n}\nsubsys_initcall(chv_pinctrl_init);\n\nstatic void __exit chv_pinctrl_exit(void)\n{\n\tplatform_driver_unregister(&chv_pinctrl_driver);\n}\nmodule_exit(chv_pinctrl_exit);\n\nMODULE_AUTHOR(\"Mika Westerberg <mika.westerberg@linux.intel.com>\");\nMODULE_DESCRIPTION(\"Intel Cherryview/Braswell pinctrl driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_IMPORT_NS(PINCTRL_INTEL);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}