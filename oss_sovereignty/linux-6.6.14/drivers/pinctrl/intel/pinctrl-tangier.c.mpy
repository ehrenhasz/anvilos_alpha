{
  "module_name": "pinctrl-tangier.c",
  "hash_id": "d925d3b9208db5a7629b859b76306a2617f68fd01bfa7241cb1c249dd47691e1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/intel/pinctrl-tangier.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/overflow.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/seq_file.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n\n#include <linux/pinctrl/pinconf-generic.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinmux.h>\n\n#include \"../core.h\"\n#include \"pinctrl-intel.h\"\n#include \"pinctrl-tangier.h\"\n\n#define SLEW_OFFSET\t\t\t0x000\n#define BUFCFG_OFFSET\t\t\t0x100\n#define MISC_OFFSET\t\t\t0x300\n\n#define BUFCFG_PINMODE_SHIFT\t\t0\n#define BUFCFG_PINMODE_MASK\t\tGENMASK(2, 0)\n#define BUFCFG_PINMODE_GPIO\t\t0\n#define BUFCFG_PUPD_VAL_SHIFT\t\t4\n#define BUFCFG_PUPD_VAL_MASK\t\tGENMASK(5, 4)\n#define BUFCFG_PUPD_VAL_2K\t\t0\n#define BUFCFG_PUPD_VAL_20K\t\t1\n#define BUFCFG_PUPD_VAL_50K\t\t2\n#define BUFCFG_PUPD_VAL_910\t\t3\n#define BUFCFG_PU_EN\t\t\tBIT(8)\n#define BUFCFG_PD_EN\t\t\tBIT(9)\n#define BUFCFG_Px_EN_MASK\t\tGENMASK(9, 8)\n#define BUFCFG_SLEWSEL\t\t\tBIT(10)\n#define BUFCFG_OVINEN\t\t\tBIT(12)\n#define BUFCFG_OVINEN_EN\t\tBIT(13)\n#define BUFCFG_OVINEN_MASK\t\tGENMASK(13, 12)\n#define BUFCFG_OVOUTEN\t\t\tBIT(14)\n#define BUFCFG_OVOUTEN_EN\t\tBIT(15)\n#define BUFCFG_OVOUTEN_MASK\t\tGENMASK(15, 14)\n#define BUFCFG_INDATAOV_VAL\t\tBIT(16)\n#define BUFCFG_INDATAOV_EN\t\tBIT(17)\n#define BUFCFG_INDATAOV_MASK\t\tGENMASK(17, 16)\n#define BUFCFG_OUTDATAOV_VAL\t\tBIT(18)\n#define BUFCFG_OUTDATAOV_EN\t\tBIT(19)\n#define BUFCFG_OUTDATAOV_MASK\t\tGENMASK(19, 18)\n#define BUFCFG_OD_EN\t\t\tBIT(21)\n\n#define pin_to_bufno(f, p)\t\t((p) - (f)->pin_base)\n\nstatic const struct tng_family *tng_get_family(struct tng_pinctrl *tp,\n\t\t\t\t\t       unsigned int pin)\n{\n\tconst struct tng_family *family;\n\tunsigned int i;\n\n\tfor (i = 0; i < tp->nfamilies; i++) {\n\t\tfamily = &tp->families[i];\n\t\tif (pin >= family->pin_base &&\n\t\t    pin < family->pin_base + family->npins)\n\t\t\treturn family;\n\t}\n\n\tdev_warn(tp->dev, \"failed to find family for pin %u\\n\", pin);\n\treturn NULL;\n}\n\nstatic bool tng_buf_available(struct tng_pinctrl *tp, unsigned int pin)\n{\n\tconst struct tng_family *family;\n\n\tfamily = tng_get_family(tp, pin);\n\tif (!family)\n\t\treturn false;\n\n\treturn !family->protected;\n}\n\nstatic void __iomem *tng_get_bufcfg(struct tng_pinctrl *tp, unsigned int pin)\n{\n\tconst struct tng_family *family;\n\tunsigned int bufno;\n\n\tfamily = tng_get_family(tp, pin);\n\tif (!family)\n\t\treturn NULL;\n\n\tbufno = pin_to_bufno(family, pin);\n\treturn family->regs + BUFCFG_OFFSET + bufno * 4;\n}\n\nstatic int tng_read_bufcfg(struct tng_pinctrl *tp, unsigned int pin, u32 *value)\n{\n\tvoid __iomem *bufcfg;\n\n\tif (!tng_buf_available(tp, pin))\n\t\treturn -EBUSY;\n\n\tbufcfg = tng_get_bufcfg(tp, pin);\n\t*value = readl(bufcfg);\n\n\treturn 0;\n}\n\nstatic void tng_update_bufcfg(struct tng_pinctrl *tp, unsigned int pin,\n\t\t\t      u32 bits, u32 mask)\n{\n\tvoid __iomem *bufcfg;\n\tu32 value;\n\n\tbufcfg = tng_get_bufcfg(tp, pin);\n\n\tvalue = readl(bufcfg);\n\tvalue = (value & ~mask) | (bits & mask);\n\twritel(value, bufcfg);\n}\n\nstatic int tng_get_groups_count(struct pinctrl_dev *pctldev)\n{\n\tstruct tng_pinctrl *tp = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn tp->ngroups;\n}\n\nstatic const char *tng_get_group_name(struct pinctrl_dev *pctldev,\n\t\t\t\t      unsigned int group)\n{\n\tstruct tng_pinctrl *tp = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn tp->groups[group].grp.name;\n}\n\nstatic int tng_get_group_pins(struct pinctrl_dev *pctldev, unsigned int group,\n\t\t\t      const unsigned int **pins, unsigned int *npins)\n{\n\tstruct tng_pinctrl *tp = pinctrl_dev_get_drvdata(pctldev);\n\n\t*pins = tp->groups[group].grp.pins;\n\t*npins = tp->groups[group].grp.npins;\n\treturn 0;\n}\n\nstatic void tng_pin_dbg_show(struct pinctrl_dev *pctldev, struct seq_file *s,\n\t\t\t     unsigned int pin)\n{\n\tstruct tng_pinctrl *tp = pinctrl_dev_get_drvdata(pctldev);\n\tu32 value, mode;\n\tint ret;\n\n\tret = tng_read_bufcfg(tp, pin, &value);\n\tif (ret) {\n\t\tseq_puts(s, \"not available\");\n\t\treturn;\n\t}\n\n\tmode = (value & BUFCFG_PINMODE_MASK) >> BUFCFG_PINMODE_SHIFT;\n\tif (mode == BUFCFG_PINMODE_GPIO)\n\t\tseq_puts(s, \"GPIO \");\n\telse\n\t\tseq_printf(s, \"mode %d \", mode);\n\n\tseq_printf(s, \"0x%08x\", value);\n}\n\nstatic const struct pinctrl_ops tng_pinctrl_ops = {\n\t.get_groups_count = tng_get_groups_count,\n\t.get_group_name = tng_get_group_name,\n\t.get_group_pins = tng_get_group_pins,\n\t.pin_dbg_show = tng_pin_dbg_show,\n};\n\nstatic int tng_get_functions_count(struct pinctrl_dev *pctldev)\n{\n\tstruct tng_pinctrl *tp = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn tp->nfunctions;\n}\n\nstatic const char *tng_get_function_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t unsigned int function)\n{\n\tstruct tng_pinctrl *tp = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn tp->functions[function].func.name;\n}\n\nstatic int tng_get_function_groups(struct pinctrl_dev *pctldev,\n\t\t\t\t   unsigned int function,\n\t\t\t\t   const char * const **groups,\n\t\t\t\t   unsigned int * const ngroups)\n{\n\tstruct tng_pinctrl *tp = pinctrl_dev_get_drvdata(pctldev);\n\n\t*groups = tp->functions[function].func.groups;\n\t*ngroups = tp->functions[function].func.ngroups;\n\treturn 0;\n}\n\nstatic int tng_pinmux_set_mux(struct pinctrl_dev *pctldev,\n\t\t\t      unsigned int function,\n\t\t\t      unsigned int group)\n{\n\tstruct tng_pinctrl *tp = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct intel_pingroup *grp = &tp->groups[group];\n\tu32 bits = grp->mode << BUFCFG_PINMODE_SHIFT;\n\tu32 mask = BUFCFG_PINMODE_MASK;\n\tunsigned long flags;\n\tunsigned int i;\n\n\t \n\tfor (i = 0; i < grp->grp.npins; i++) {\n\t\tif (!tng_buf_available(tp, grp->grp.pins[i]))\n\t\t\treturn -EBUSY;\n\t}\n\n\t \n\traw_spin_lock_irqsave(&tp->lock, flags);\n\tfor (i = 0; i < grp->grp.npins; i++)\n\t\ttng_update_bufcfg(tp, grp->grp.pins[i], bits, mask);\n\traw_spin_unlock_irqrestore(&tp->lock, flags);\n\n\treturn 0;\n}\n\nstatic int tng_gpio_request_enable(struct pinctrl_dev *pctldev,\n\t\t\t\t   struct pinctrl_gpio_range *range,\n\t\t\t\t   unsigned int pin)\n{\n\tstruct tng_pinctrl *tp = pinctrl_dev_get_drvdata(pctldev);\n\tu32 bits = BUFCFG_PINMODE_GPIO << BUFCFG_PINMODE_SHIFT;\n\tu32 mask = BUFCFG_PINMODE_MASK;\n\tunsigned long flags;\n\n\tif (!tng_buf_available(tp, pin))\n\t\treturn -EBUSY;\n\n\traw_spin_lock_irqsave(&tp->lock, flags);\n\ttng_update_bufcfg(tp, pin, bits, mask);\n\traw_spin_unlock_irqrestore(&tp->lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct pinmux_ops tng_pinmux_ops = {\n\t.get_functions_count = tng_get_functions_count,\n\t.get_function_name = tng_get_function_name,\n\t.get_function_groups = tng_get_function_groups,\n\t.set_mux = tng_pinmux_set_mux,\n\t.gpio_request_enable = tng_gpio_request_enable,\n};\n\nstatic int tng_config_get(struct pinctrl_dev *pctldev, unsigned int pin,\n\t\t\t  unsigned long *config)\n{\n\tstruct tng_pinctrl *tp = pinctrl_dev_get_drvdata(pctldev);\n\tenum pin_config_param param = pinconf_to_config_param(*config);\n\tu32 value, term;\n\tu16 arg = 0;\n\tint ret;\n\n\tret = tng_read_bufcfg(tp, pin, &value);\n\tif (ret)\n\t\treturn -ENOTSUPP;\n\n\tterm = (value & BUFCFG_PUPD_VAL_MASK) >> BUFCFG_PUPD_VAL_SHIFT;\n\n\tswitch (param) {\n\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\tif (value & BUFCFG_Px_EN_MASK)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\tif ((value & BUFCFG_Px_EN_MASK) != BUFCFG_PU_EN)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (term) {\n\t\tcase BUFCFG_PUPD_VAL_910:\n\t\t\targ = 910;\n\t\t\tbreak;\n\t\tcase BUFCFG_PUPD_VAL_2K:\n\t\t\targ = 2000;\n\t\t\tbreak;\n\t\tcase BUFCFG_PUPD_VAL_20K:\n\t\t\targ = 20000;\n\t\t\tbreak;\n\t\tcase BUFCFG_PUPD_VAL_50K:\n\t\t\targ = 50000;\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\tif ((value & BUFCFG_Px_EN_MASK) != BUFCFG_PD_EN)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (term) {\n\t\tcase BUFCFG_PUPD_VAL_910:\n\t\t\targ = 910;\n\t\t\tbreak;\n\t\tcase BUFCFG_PUPD_VAL_2K:\n\t\t\targ = 2000;\n\t\t\tbreak;\n\t\tcase BUFCFG_PUPD_VAL_20K:\n\t\t\targ = 20000;\n\t\t\tbreak;\n\t\tcase BUFCFG_PUPD_VAL_50K:\n\t\t\targ = 50000;\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tcase PIN_CONFIG_DRIVE_PUSH_PULL:\n\t\tif (value & BUFCFG_OD_EN)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\tcase PIN_CONFIG_DRIVE_OPEN_DRAIN:\n\t\tif (!(value & BUFCFG_OD_EN))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\tcase PIN_CONFIG_SLEW_RATE:\n\t\tif (value & BUFCFG_SLEWSEL)\n\t\t\targ = 1;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\t*config = pinconf_to_config_packed(param, arg);\n\treturn 0;\n}\n\nstatic int tng_config_set_pin(struct tng_pinctrl *tp, unsigned int pin,\n\t\t\t      unsigned long config)\n{\n\tunsigned int param = pinconf_to_config_param(config);\n\tunsigned int arg = pinconf_to_config_argument(config);\n\tu32 mask, term, value = 0;\n\tunsigned long flags;\n\n\tswitch (param) {\n\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\tmask = BUFCFG_Px_EN_MASK | BUFCFG_PUPD_VAL_MASK;\n\t\tbreak;\n\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\t \n\t\tif (arg == 1)\n\t\t\targ = 20000;\n\n\t\tswitch (arg) {\n\t\tcase 50000:\n\t\t\tterm = BUFCFG_PUPD_VAL_50K;\n\t\t\tbreak;\n\t\tcase 20000:\n\t\t\tterm = BUFCFG_PUPD_VAL_20K;\n\t\t\tbreak;\n\t\tcase 2000:\n\t\t\tterm = BUFCFG_PUPD_VAL_2K;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmask = BUFCFG_Px_EN_MASK | BUFCFG_PUPD_VAL_MASK;\n\t\tvalue = BUFCFG_PU_EN | (term << BUFCFG_PUPD_VAL_SHIFT);\n\t\tbreak;\n\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\t \n\t\tif (arg == 1)\n\t\t\targ = 20000;\n\n\t\tswitch (arg) {\n\t\tcase 50000:\n\t\t\tterm = BUFCFG_PUPD_VAL_50K;\n\t\t\tbreak;\n\t\tcase 20000:\n\t\t\tterm = BUFCFG_PUPD_VAL_20K;\n\t\t\tbreak;\n\t\tcase 2000:\n\t\t\tterm = BUFCFG_PUPD_VAL_2K;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmask = BUFCFG_Px_EN_MASK | BUFCFG_PUPD_VAL_MASK;\n\t\tvalue = BUFCFG_PD_EN | (term << BUFCFG_PUPD_VAL_SHIFT);\n\t\tbreak;\n\n\tcase PIN_CONFIG_DRIVE_PUSH_PULL:\n\t\tmask = BUFCFG_OD_EN;\n\t\tbreak;\n\n\tcase PIN_CONFIG_DRIVE_OPEN_DRAIN:\n\t\tmask = BUFCFG_OD_EN;\n\t\tvalue = BUFCFG_OD_EN;\n\t\tbreak;\n\n\tcase PIN_CONFIG_SLEW_RATE:\n\t\tmask = BUFCFG_SLEWSEL;\n\t\tif (arg)\n\t\t\tvalue = BUFCFG_SLEWSEL;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\traw_spin_lock_irqsave(&tp->lock, flags);\n\ttng_update_bufcfg(tp, pin, value, mask);\n\traw_spin_unlock_irqrestore(&tp->lock, flags);\n\n\treturn 0;\n}\n\nstatic int tng_config_set(struct pinctrl_dev *pctldev, unsigned int pin,\n\t\t\t  unsigned long *configs, unsigned int nconfigs)\n{\n\tstruct tng_pinctrl *tp = pinctrl_dev_get_drvdata(pctldev);\n\tunsigned int i;\n\tint ret;\n\n\tif (!tng_buf_available(tp, pin))\n\t\treturn -ENOTSUPP;\n\n\tfor (i = 0; i < nconfigs; i++) {\n\t\tswitch (pinconf_to_config_param(configs[i])) {\n\t\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\tcase PIN_CONFIG_DRIVE_PUSH_PULL:\n\t\tcase PIN_CONFIG_DRIVE_OPEN_DRAIN:\n\t\tcase PIN_CONFIG_SLEW_RATE:\n\t\t\tret = tng_config_set_pin(tp, pin, configs[i]);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int tng_config_group_get(struct pinctrl_dev *pctldev,\n\t\t\t\tunsigned int group, unsigned long *config)\n{\n\tconst unsigned int *pins;\n\tunsigned int npins;\n\tint ret;\n\n\tret = tng_get_group_pins(pctldev, group, &pins, &npins);\n\tif (ret)\n\t\treturn ret;\n\n\treturn tng_config_get(pctldev, pins[0], config);\n}\n\nstatic int tng_config_group_set(struct pinctrl_dev *pctldev,\n\t\t\t\tunsigned int group, unsigned long *configs,\n\t\t\t\tunsigned int num_configs)\n{\n\tconst unsigned int *pins;\n\tunsigned int npins;\n\tint i, ret;\n\n\tret = tng_get_group_pins(pctldev, group, &pins, &npins);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < npins; i++) {\n\t\tret = tng_config_set(pctldev, pins[i], configs, num_configs);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct pinconf_ops tng_pinconf_ops = {\n\t.is_generic = true,\n\t.pin_config_get = tng_config_get,\n\t.pin_config_set = tng_config_set,\n\t.pin_config_group_get = tng_config_group_get,\n\t.pin_config_group_set = tng_config_group_set,\n};\n\nstatic const struct pinctrl_desc tng_pinctrl_desc = {\n\t.pctlops = &tng_pinctrl_ops,\n\t.pmxops = &tng_pinmux_ops,\n\t.confops = &tng_pinconf_ops,\n\t.owner = THIS_MODULE,\n};\n\nstatic int tng_pinctrl_probe(struct platform_device *pdev,\n\t\t\t     const struct tng_pinctrl *data)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct tng_family *families;\n\tstruct tng_pinctrl *tp;\n\tsize_t families_len;\n\tvoid __iomem *regs;\n\tunsigned int i;\n\n\ttp = devm_kmemdup(dev, data, sizeof(*data), GFP_KERNEL);\n\tif (!tp)\n\t\treturn -ENOMEM;\n\n\ttp->dev = dev;\n\traw_spin_lock_init(&tp->lock);\n\n\tregs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(regs))\n\t\treturn PTR_ERR(regs);\n\n\t \n\tfamilies_len = size_mul(sizeof(*families), tp->nfamilies);\n\tfamilies = devm_kmemdup(dev, tp->families, families_len, GFP_KERNEL);\n\tif (!families)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = 0; i < tp->nfamilies; i++) {\n\t\tstruct tng_family *family = &families[i];\n\n\t\tfamily->regs = regs + family->barno * TNG_FAMILY_LEN;\n\t}\n\n\ttp->families = families;\n\ttp->pctldesc = tng_pinctrl_desc;\n\ttp->pctldesc.name = dev_name(dev);\n\ttp->pctldesc.pins = tp->pins;\n\ttp->pctldesc.npins = tp->npins;\n\n\ttp->pctldev = devm_pinctrl_register(dev, &tp->pctldesc, tp);\n\tif (IS_ERR(tp->pctldev))\n\t\treturn dev_err_probe(dev, PTR_ERR(tp->pctldev),\n\t\t\t\t     \"failed to register pinctrl driver\\n\");\n\n\treturn 0;\n}\n\nint devm_tng_pinctrl_probe(struct platform_device *pdev)\n{\n\tconst struct tng_pinctrl *data;\n\n\tdata = device_get_match_data(&pdev->dev);\n\tif (!data)\n\t\treturn -ENODATA;\n\n\treturn tng_pinctrl_probe(pdev, data);\n}\nEXPORT_SYMBOL_NS_GPL(devm_tng_pinctrl_probe, PINCTRL_TANGIER);\n\nMODULE_AUTHOR(\"Andy Shevchenko <andriy.shevchenko@linux.intel.com>\");\nMODULE_AUTHOR(\"Raag Jadav <raag.jadav@intel.com>\");\nMODULE_DESCRIPTION(\"Intel Tangier pinctrl driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}