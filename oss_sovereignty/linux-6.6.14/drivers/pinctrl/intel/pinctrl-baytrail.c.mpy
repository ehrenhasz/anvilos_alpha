{
  "module_name": "pinctrl-baytrail.c",
  "hash_id": "a89ed6813972cc80816f192c2689ec14bfce37b5864a9f569340b0371c937e9f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/intel/pinctrl-baytrail.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/bitops.h>\n#include <linux/gpio/driver.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/property.h>\n#include <linux/seq_file.h>\n#include <linux/string_helpers.h>\n\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinmux.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinconf-generic.h>\n\n#include \"pinctrl-intel.h\"\n\n \n#define BYT_CONF0_REG\t\t0x000\n#define BYT_CONF1_REG\t\t0x004\n#define BYT_VAL_REG\t\t0x008\n#define BYT_DFT_REG\t\t0x00c\n#define BYT_INT_STAT_REG\t0x800\n#define BYT_DIRECT_IRQ_REG\t0x980\n#define BYT_DEBOUNCE_REG\t0x9d0\n\n \n#define BYT_IODEN\t\tBIT(31)\n#define BYT_DIRECT_IRQ_EN\tBIT(27)\n#define BYT_TRIG_MASK\t\tGENMASK(26, 24)\n#define BYT_TRIG_NEG\t\tBIT(26)\n#define BYT_TRIG_POS\t\tBIT(25)\n#define BYT_TRIG_LVL\t\tBIT(24)\n#define BYT_DEBOUNCE_EN\t\tBIT(20)\n#define BYT_GLITCH_FILTER_EN\tBIT(19)\n#define BYT_GLITCH_F_SLOW_CLK\tBIT(17)\n#define BYT_GLITCH_F_FAST_CLK\tBIT(16)\n#define BYT_PULL_STR_SHIFT\t9\n#define BYT_PULL_STR_MASK\tGENMASK(10, 9)\n#define BYT_PULL_STR_2K\t\t(0 << BYT_PULL_STR_SHIFT)\n#define BYT_PULL_STR_10K\t(1 << BYT_PULL_STR_SHIFT)\n#define BYT_PULL_STR_20K\t(2 << BYT_PULL_STR_SHIFT)\n#define BYT_PULL_STR_40K\t(3 << BYT_PULL_STR_SHIFT)\n#define BYT_PULL_ASSIGN_MASK\tGENMASK(8, 7)\n#define BYT_PULL_ASSIGN_DOWN\tBIT(8)\n#define BYT_PULL_ASSIGN_UP\tBIT(7)\n#define BYT_PIN_MUX\t\tGENMASK(2, 0)\n\n \n#define BYT_DIR_MASK\t\tGENMASK(2, 1)\n#define BYT_INPUT_EN\t\tBIT(2)   \n#define BYT_OUTPUT_EN\t\tBIT(1)   \n#define BYT_LEVEL\t\tBIT(0)\n\n#define BYT_CONF0_RESTORE_MASK\t(BYT_DIRECT_IRQ_EN | BYT_TRIG_MASK | BYT_PIN_MUX)\n#define BYT_VAL_RESTORE_MASK\t(BYT_DIR_MASK | BYT_LEVEL)\n\n \n#define BYT_DEBOUNCE_PULSE_MASK\t\tGENMASK(2, 0)\n#define BYT_DEBOUNCE_PULSE_375US\t1\n#define BYT_DEBOUNCE_PULSE_750US\t2\n#define BYT_DEBOUNCE_PULSE_1500US\t3\n#define BYT_DEBOUNCE_PULSE_3MS\t\t4\n#define BYT_DEBOUNCE_PULSE_6MS\t\t5\n#define BYT_DEBOUNCE_PULSE_12MS\t\t6\n#define BYT_DEBOUNCE_PULSE_24MS\t\t7\n\n#define BYT_NGPIO_SCORE\t\t102\n#define BYT_NGPIO_NCORE\t\t28\n#define BYT_NGPIO_SUS\t\t44\n\n#define BYT_SCORE_ACPI_UID\t\"1\"\n#define BYT_NCORE_ACPI_UID\t\"2\"\n#define BYT_SUS_ACPI_UID\t\"3\"\n\n \n#define BYT_DEFAULT_GPIO_MUX\t0\n#define BYT_ALTER_GPIO_MUX\t1\n\nstruct intel_pad_context {\n\tu32 conf0;\n\tu32 val;\n};\n\n#define COMMUNITY(p, n, map)\t\t\\\n\t{\t\t\t\t\\\n\t\t.pin_base\t= (p),\t\\\n\t\t.npins\t\t= (n),\t\\\n\t\t.pad_map\t= (map),\\\n\t}\n\n \nstatic const struct pinctrl_pin_desc byt_score_pins[] = {\n\tPINCTRL_PIN(0, \"SATA_GP0\"),\n\tPINCTRL_PIN(1, \"SATA_GP1\"),\n\tPINCTRL_PIN(2, \"SATA_LED#\"),\n\tPINCTRL_PIN(3, \"PCIE_CLKREQ0\"),\n\tPINCTRL_PIN(4, \"PCIE_CLKREQ1\"),\n\tPINCTRL_PIN(5, \"PCIE_CLKREQ2\"),\n\tPINCTRL_PIN(6, \"PCIE_CLKREQ3\"),\n\tPINCTRL_PIN(7, \"SD3_WP\"),\n\tPINCTRL_PIN(8, \"HDA_RST\"),\n\tPINCTRL_PIN(9, \"HDA_SYNC\"),\n\tPINCTRL_PIN(10, \"HDA_CLK\"),\n\tPINCTRL_PIN(11, \"HDA_SDO\"),\n\tPINCTRL_PIN(12, \"HDA_SDI0\"),\n\tPINCTRL_PIN(13, \"HDA_SDI1\"),\n\tPINCTRL_PIN(14, \"GPIO_S0_SC14\"),\n\tPINCTRL_PIN(15, \"GPIO_S0_SC15\"),\n\tPINCTRL_PIN(16, \"MMC1_CLK\"),\n\tPINCTRL_PIN(17, \"MMC1_D0\"),\n\tPINCTRL_PIN(18, \"MMC1_D1\"),\n\tPINCTRL_PIN(19, \"MMC1_D2\"),\n\tPINCTRL_PIN(20, \"MMC1_D3\"),\n\tPINCTRL_PIN(21, \"MMC1_D4\"),\n\tPINCTRL_PIN(22, \"MMC1_D5\"),\n\tPINCTRL_PIN(23, \"MMC1_D6\"),\n\tPINCTRL_PIN(24, \"MMC1_D7\"),\n\tPINCTRL_PIN(25, \"MMC1_CMD\"),\n\tPINCTRL_PIN(26, \"MMC1_RST\"),\n\tPINCTRL_PIN(27, \"SD2_CLK\"),\n\tPINCTRL_PIN(28, \"SD2_D0\"),\n\tPINCTRL_PIN(29, \"SD2_D1\"),\n\tPINCTRL_PIN(30, \"SD2_D2\"),\n\tPINCTRL_PIN(31, \"SD2_D3_CD\"),\n\tPINCTRL_PIN(32, \"SD2_CMD\"),\n\tPINCTRL_PIN(33, \"SD3_CLK\"),\n\tPINCTRL_PIN(34, \"SD3_D0\"),\n\tPINCTRL_PIN(35, \"SD3_D1\"),\n\tPINCTRL_PIN(36, \"SD3_D2\"),\n\tPINCTRL_PIN(37, \"SD3_D3\"),\n\tPINCTRL_PIN(38, \"SD3_CD\"),\n\tPINCTRL_PIN(39, \"SD3_CMD\"),\n\tPINCTRL_PIN(40, \"SD3_1P8EN\"),\n\tPINCTRL_PIN(41, \"SD3_PWREN#\"),\n\tPINCTRL_PIN(42, \"ILB_LPC_AD0\"),\n\tPINCTRL_PIN(43, \"ILB_LPC_AD1\"),\n\tPINCTRL_PIN(44, \"ILB_LPC_AD2\"),\n\tPINCTRL_PIN(45, \"ILB_LPC_AD3\"),\n\tPINCTRL_PIN(46, \"ILB_LPC_FRAME\"),\n\tPINCTRL_PIN(47, \"ILB_LPC_CLK0\"),\n\tPINCTRL_PIN(48, \"ILB_LPC_CLK1\"),\n\tPINCTRL_PIN(49, \"ILB_LPC_CLKRUN\"),\n\tPINCTRL_PIN(50, \"ILB_LPC_SERIRQ\"),\n\tPINCTRL_PIN(51, \"PCU_SMB_DATA\"),\n\tPINCTRL_PIN(52, \"PCU_SMB_CLK\"),\n\tPINCTRL_PIN(53, \"PCU_SMB_ALERT\"),\n\tPINCTRL_PIN(54, \"ILB_8254_SPKR\"),\n\tPINCTRL_PIN(55, \"GPIO_S0_SC55\"),\n\tPINCTRL_PIN(56, \"GPIO_S0_SC56\"),\n\tPINCTRL_PIN(57, \"GPIO_S0_SC57\"),\n\tPINCTRL_PIN(58, \"GPIO_S0_SC58\"),\n\tPINCTRL_PIN(59, \"GPIO_S0_SC59\"),\n\tPINCTRL_PIN(60, \"GPIO_S0_SC60\"),\n\tPINCTRL_PIN(61, \"GPIO_S0_SC61\"),\n\tPINCTRL_PIN(62, \"LPE_I2S2_CLK\"),\n\tPINCTRL_PIN(63, \"LPE_I2S2_FRM\"),\n\tPINCTRL_PIN(64, \"LPE_I2S2_DATAIN\"),\n\tPINCTRL_PIN(65, \"LPE_I2S2_DATAOUT\"),\n\tPINCTRL_PIN(66, \"SIO_SPI_CS\"),\n\tPINCTRL_PIN(67, \"SIO_SPI_MISO\"),\n\tPINCTRL_PIN(68, \"SIO_SPI_MOSI\"),\n\tPINCTRL_PIN(69, \"SIO_SPI_CLK\"),\n\tPINCTRL_PIN(70, \"SIO_UART1_RXD\"),\n\tPINCTRL_PIN(71, \"SIO_UART1_TXD\"),\n\tPINCTRL_PIN(72, \"SIO_UART1_RTS\"),\n\tPINCTRL_PIN(73, \"SIO_UART1_CTS\"),\n\tPINCTRL_PIN(74, \"SIO_UART2_RXD\"),\n\tPINCTRL_PIN(75, \"SIO_UART2_TXD\"),\n\tPINCTRL_PIN(76, \"SIO_UART2_RTS\"),\n\tPINCTRL_PIN(77, \"SIO_UART2_CTS\"),\n\tPINCTRL_PIN(78, \"SIO_I2C0_DATA\"),\n\tPINCTRL_PIN(79, \"SIO_I2C0_CLK\"),\n\tPINCTRL_PIN(80, \"SIO_I2C1_DATA\"),\n\tPINCTRL_PIN(81, \"SIO_I2C1_CLK\"),\n\tPINCTRL_PIN(82, \"SIO_I2C2_DATA\"),\n\tPINCTRL_PIN(83, \"SIO_I2C2_CLK\"),\n\tPINCTRL_PIN(84, \"SIO_I2C3_DATA\"),\n\tPINCTRL_PIN(85, \"SIO_I2C3_CLK\"),\n\tPINCTRL_PIN(86, \"SIO_I2C4_DATA\"),\n\tPINCTRL_PIN(87, \"SIO_I2C4_CLK\"),\n\tPINCTRL_PIN(88, \"SIO_I2C5_DATA\"),\n\tPINCTRL_PIN(89, \"SIO_I2C5_CLK\"),\n\tPINCTRL_PIN(90, \"SIO_I2C6_DATA\"),\n\tPINCTRL_PIN(91, \"SIO_I2C6_CLK\"),\n\tPINCTRL_PIN(92, \"GPIO_S0_SC92\"),\n\tPINCTRL_PIN(93, \"GPIO_S0_SC93\"),\n\tPINCTRL_PIN(94, \"SIO_PWM0\"),\n\tPINCTRL_PIN(95, \"SIO_PWM1\"),\n\tPINCTRL_PIN(96, \"PMC_PLT_CLK0\"),\n\tPINCTRL_PIN(97, \"PMC_PLT_CLK1\"),\n\tPINCTRL_PIN(98, \"PMC_PLT_CLK2\"),\n\tPINCTRL_PIN(99, \"PMC_PLT_CLK3\"),\n\tPINCTRL_PIN(100, \"PMC_PLT_CLK4\"),\n\tPINCTRL_PIN(101, \"PMC_PLT_CLK5\"),\n};\n\nstatic const unsigned int byt_score_pins_map[BYT_NGPIO_SCORE] = {\n\t85, 89, 93, 96, 99, 102, 98, 101, 34, 37,\n\t36, 38, 39, 35, 40, 84, 62, 61, 64, 59,\n\t54, 56, 60, 55, 63, 57, 51, 50, 53, 47,\n\t52, 49, 48, 43, 46, 41, 45, 42, 58, 44,\n\t95, 105, 70, 68, 67, 66, 69, 71, 65, 72,\n\t86, 90, 88, 92, 103, 77, 79, 83, 78, 81,\n\t80, 82, 13, 12, 15, 14, 17, 18, 19, 16,\n\t2, 1, 0, 4, 6, 7, 9, 8, 33, 32,\n\t31, 30, 29, 27, 25, 28, 26, 23, 21, 20,\n\t24, 22, 5, 3, 10, 11, 106, 87, 91, 104,\n\t97, 100,\n};\n\n \nstatic const unsigned int byt_score_uart1_pins[] = { 70, 71, 72, 73 };\nstatic const unsigned int byt_score_uart2_pins[] = { 74, 75, 76, 77 };\n\nstatic const unsigned int byt_score_pwm0_pins[] = { 94 };\nstatic const unsigned int byt_score_pwm1_pins[] = { 95 };\n\nstatic const unsigned int byt_score_sio_spi_pins[] = { 66, 67, 68, 69 };\n\nstatic const unsigned int byt_score_i2c5_pins[] = { 88, 89 };\nstatic const unsigned int byt_score_i2c6_pins[] = { 90, 91 };\nstatic const unsigned int byt_score_i2c4_pins[] = { 86, 87 };\nstatic const unsigned int byt_score_i2c3_pins[] = { 84, 85 };\nstatic const unsigned int byt_score_i2c2_pins[] = { 82, 83 };\nstatic const unsigned int byt_score_i2c1_pins[] = { 80, 81 };\nstatic const unsigned int byt_score_i2c0_pins[] = { 78, 79 };\n\nstatic const unsigned int byt_score_ssp0_pins[] = { 8, 9, 10, 11 };\nstatic const unsigned int byt_score_ssp1_pins[] = { 12, 13, 14, 15 };\nstatic const unsigned int byt_score_ssp2_pins[] = { 62, 63, 64, 65 };\n\nstatic const unsigned int byt_score_sdcard_pins[] = {\n\t7, 33, 34, 35, 36, 37, 38, 39, 40, 41,\n};\nstatic const unsigned int byt_score_sdcard_mux_values[] = {\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n};\n\nstatic const unsigned int byt_score_sdio_pins[] = { 27, 28, 29, 30, 31, 32 };\n\nstatic const unsigned int byt_score_emmc_pins[] = {\n\t16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26,\n};\n\nstatic const unsigned int byt_score_ilb_lpc_pins[] = {\n\t42, 43, 44, 45, 46, 47, 48, 49, 50,\n};\n\nstatic const unsigned int byt_score_sata_pins[] = { 0, 1, 2 };\n\nstatic const unsigned int byt_score_plt_clk0_pins[] = { 96 };\nstatic const unsigned int byt_score_plt_clk1_pins[] = { 97 };\nstatic const unsigned int byt_score_plt_clk2_pins[] = { 98 };\nstatic const unsigned int byt_score_plt_clk3_pins[] = { 99 };\nstatic const unsigned int byt_score_plt_clk4_pins[] = { 100 };\nstatic const unsigned int byt_score_plt_clk5_pins[] = { 101 };\n\nstatic const unsigned int byt_score_smbus_pins[] = { 51, 52, 53 };\n\nstatic const struct intel_pingroup byt_score_groups[] = {\n\tPIN_GROUP(\"uart1_grp\", byt_score_uart1_pins, 1),\n\tPIN_GROUP(\"uart2_grp\", byt_score_uart2_pins, 1),\n\tPIN_GROUP(\"pwm0_grp\", byt_score_pwm0_pins, 1),\n\tPIN_GROUP(\"pwm1_grp\", byt_score_pwm1_pins, 1),\n\tPIN_GROUP(\"ssp2_grp\", byt_score_ssp2_pins, 1),\n\tPIN_GROUP(\"sio_spi_grp\", byt_score_sio_spi_pins, 1),\n\tPIN_GROUP(\"i2c5_grp\", byt_score_i2c5_pins, 1),\n\tPIN_GROUP(\"i2c6_grp\", byt_score_i2c6_pins, 1),\n\tPIN_GROUP(\"i2c4_grp\", byt_score_i2c4_pins, 1),\n\tPIN_GROUP(\"i2c3_grp\", byt_score_i2c3_pins, 1),\n\tPIN_GROUP(\"i2c2_grp\", byt_score_i2c2_pins, 1),\n\tPIN_GROUP(\"i2c1_grp\", byt_score_i2c1_pins, 1),\n\tPIN_GROUP(\"i2c0_grp\", byt_score_i2c0_pins, 1),\n\tPIN_GROUP(\"ssp0_grp\", byt_score_ssp0_pins, 1),\n\tPIN_GROUP(\"ssp1_grp\", byt_score_ssp1_pins, 1),\n\tPIN_GROUP(\"sdcard_grp\", byt_score_sdcard_pins, byt_score_sdcard_mux_values),\n\tPIN_GROUP(\"sdio_grp\", byt_score_sdio_pins, 1),\n\tPIN_GROUP(\"emmc_grp\", byt_score_emmc_pins, 1),\n\tPIN_GROUP(\"lpc_grp\", byt_score_ilb_lpc_pins, 1),\n\tPIN_GROUP(\"sata_grp\", byt_score_sata_pins, 1),\n\tPIN_GROUP(\"plt_clk0_grp\", byt_score_plt_clk0_pins, 1),\n\tPIN_GROUP(\"plt_clk1_grp\", byt_score_plt_clk1_pins, 1),\n\tPIN_GROUP(\"plt_clk2_grp\", byt_score_plt_clk2_pins, 1),\n\tPIN_GROUP(\"plt_clk3_grp\", byt_score_plt_clk3_pins, 1),\n\tPIN_GROUP(\"plt_clk4_grp\", byt_score_plt_clk4_pins, 1),\n\tPIN_GROUP(\"plt_clk5_grp\", byt_score_plt_clk5_pins, 1),\n\tPIN_GROUP(\"smbus_grp\", byt_score_smbus_pins, 1),\n};\n\nstatic const char * const byt_score_uart_groups[] = {\n\t\"uart1_grp\", \"uart2_grp\",\n};\nstatic const char * const byt_score_pwm_groups[] = {\n\t\"pwm0_grp\", \"pwm1_grp\",\n};\nstatic const char * const byt_score_ssp_groups[] = {\n\t\"ssp0_grp\", \"ssp1_grp\", \"ssp2_grp\",\n};\nstatic const char * const byt_score_spi_groups[] = { \"sio_spi_grp\" };\nstatic const char * const byt_score_i2c_groups[] = {\n\t\"i2c0_grp\", \"i2c1_grp\", \"i2c2_grp\", \"i2c3_grp\", \"i2c4_grp\", \"i2c5_grp\",\n\t\"i2c6_grp\",\n};\nstatic const char * const byt_score_sdcard_groups[] = { \"sdcard_grp\" };\nstatic const char * const byt_score_sdio_groups[] = { \"sdio_grp\" };\nstatic const char * const byt_score_emmc_groups[] = { \"emmc_grp\" };\nstatic const char * const byt_score_lpc_groups[] = { \"lpc_grp\" };\nstatic const char * const byt_score_sata_groups[] = { \"sata_grp\" };\nstatic const char * const byt_score_plt_clk_groups[] = {\n\t\"plt_clk0_grp\", \"plt_clk1_grp\", \"plt_clk2_grp\", \"plt_clk3_grp\",\n\t\"plt_clk4_grp\", \"plt_clk5_grp\",\n};\nstatic const char * const byt_score_smbus_groups[] = { \"smbus_grp\" };\nstatic const char * const byt_score_gpio_groups[] = {\n\t\"uart1_grp\", \"uart2_grp\", \"pwm0_grp\", \"pwm1_grp\", \"ssp0_grp\",\n\t\"ssp1_grp\", \"ssp2_grp\", \"sio_spi_grp\", \"i2c0_grp\", \"i2c1_grp\",\n\t\"i2c2_grp\", \"i2c3_grp\", \"i2c4_grp\", \"i2c5_grp\", \"i2c6_grp\",\n\t\"sdcard_grp\", \"sdio_grp\", \"emmc_grp\", \"lpc_grp\", \"sata_grp\",\n\t\"plt_clk0_grp\", \"plt_clk1_grp\", \"plt_clk2_grp\", \"plt_clk3_grp\",\n\t\"plt_clk4_grp\", \"plt_clk5_grp\", \"smbus_grp\",\n};\n\nstatic const struct intel_function byt_score_functions[] = {\n\tFUNCTION(\"uart\", byt_score_uart_groups),\n\tFUNCTION(\"pwm\", byt_score_pwm_groups),\n\tFUNCTION(\"ssp\", byt_score_ssp_groups),\n\tFUNCTION(\"spi\", byt_score_spi_groups),\n\tFUNCTION(\"i2c\", byt_score_i2c_groups),\n\tFUNCTION(\"sdcard\", byt_score_sdcard_groups),\n\tFUNCTION(\"sdio\", byt_score_sdio_groups),\n\tFUNCTION(\"emmc\", byt_score_emmc_groups),\n\tFUNCTION(\"lpc\", byt_score_lpc_groups),\n\tFUNCTION(\"sata\", byt_score_sata_groups),\n\tFUNCTION(\"plt_clk\", byt_score_plt_clk_groups),\n\tFUNCTION(\"smbus\", byt_score_smbus_groups),\n\tFUNCTION(\"gpio\", byt_score_gpio_groups),\n};\n\nstatic const struct intel_community byt_score_communities[] = {\n\tCOMMUNITY(0, BYT_NGPIO_SCORE, byt_score_pins_map),\n};\n\nstatic const struct intel_pinctrl_soc_data byt_score_soc_data = {\n\t.uid\t\t= BYT_SCORE_ACPI_UID,\n\t.pins\t\t= byt_score_pins,\n\t.npins\t\t= ARRAY_SIZE(byt_score_pins),\n\t.groups\t\t= byt_score_groups,\n\t.ngroups\t= ARRAY_SIZE(byt_score_groups),\n\t.functions\t= byt_score_functions,\n\t.nfunctions\t= ARRAY_SIZE(byt_score_functions),\n\t.communities\t= byt_score_communities,\n\t.ncommunities\t= ARRAY_SIZE(byt_score_communities),\n};\n\n \nstatic const struct pinctrl_pin_desc byt_sus_pins[] = {\n\tPINCTRL_PIN(0, \"GPIO_S50\"),\n\tPINCTRL_PIN(1, \"GPIO_S51\"),\n\tPINCTRL_PIN(2, \"GPIO_S52\"),\n\tPINCTRL_PIN(3, \"GPIO_S53\"),\n\tPINCTRL_PIN(4, \"GPIO_S54\"),\n\tPINCTRL_PIN(5, \"GPIO_S55\"),\n\tPINCTRL_PIN(6, \"GPIO_S56\"),\n\tPINCTRL_PIN(7, \"GPIO_S57\"),\n\tPINCTRL_PIN(8, \"GPIO_S58\"),\n\tPINCTRL_PIN(9, \"GPIO_S59\"),\n\tPINCTRL_PIN(10, \"GPIO_S510\"),\n\tPINCTRL_PIN(11, \"PMC_SUSPWRDNACK\"),\n\tPINCTRL_PIN(12, \"PMC_SUSCLK0\"),\n\tPINCTRL_PIN(13, \"GPIO_S513\"),\n\tPINCTRL_PIN(14, \"USB_ULPI_RST\"),\n\tPINCTRL_PIN(15, \"PMC_WAKE_PCIE0#\"),\n\tPINCTRL_PIN(16, \"PMC_PWRBTN\"),\n\tPINCTRL_PIN(17, \"GPIO_S517\"),\n\tPINCTRL_PIN(18, \"PMC_SUS_STAT\"),\n\tPINCTRL_PIN(19, \"USB_OC0\"),\n\tPINCTRL_PIN(20, \"USB_OC1\"),\n\tPINCTRL_PIN(21, \"PCU_SPI_CS1\"),\n\tPINCTRL_PIN(22, \"GPIO_S522\"),\n\tPINCTRL_PIN(23, \"GPIO_S523\"),\n\tPINCTRL_PIN(24, \"GPIO_S524\"),\n\tPINCTRL_PIN(25, \"GPIO_S525\"),\n\tPINCTRL_PIN(26, \"GPIO_S526\"),\n\tPINCTRL_PIN(27, \"GPIO_S527\"),\n\tPINCTRL_PIN(28, \"GPIO_S528\"),\n\tPINCTRL_PIN(29, \"GPIO_S529\"),\n\tPINCTRL_PIN(30, \"GPIO_S530\"),\n\tPINCTRL_PIN(31, \"USB_ULPI_CLK\"),\n\tPINCTRL_PIN(32, \"USB_ULPI_DATA0\"),\n\tPINCTRL_PIN(33, \"USB_ULPI_DATA1\"),\n\tPINCTRL_PIN(34, \"USB_ULPI_DATA2\"),\n\tPINCTRL_PIN(35, \"USB_ULPI_DATA3\"),\n\tPINCTRL_PIN(36, \"USB_ULPI_DATA4\"),\n\tPINCTRL_PIN(37, \"USB_ULPI_DATA5\"),\n\tPINCTRL_PIN(38, \"USB_ULPI_DATA6\"),\n\tPINCTRL_PIN(39, \"USB_ULPI_DATA7\"),\n\tPINCTRL_PIN(40, \"USB_ULPI_DIR\"),\n\tPINCTRL_PIN(41, \"USB_ULPI_NXT\"),\n\tPINCTRL_PIN(42, \"USB_ULPI_STP\"),\n\tPINCTRL_PIN(43, \"USB_ULPI_REFCLK\"),\n};\n\nstatic const unsigned int byt_sus_pins_map[BYT_NGPIO_SUS] = {\n\t29, 33, 30, 31, 32, 34, 36, 35, 38, 37,\n\t18, 7, 11, 20, 17, 1, 8, 10, 19, 12,\n\t0, 2, 23, 39, 28, 27, 22, 21, 24, 25,\n\t26, 51, 56, 54, 49, 55, 48, 57, 50, 58,\n\t52, 53, 59, 40,\n};\n\nstatic const unsigned int byt_sus_usb_over_current_pins[] = { 19, 20 };\nstatic const unsigned int byt_sus_usb_over_current_mode_values[] = { 0, 0 };\nstatic const unsigned int byt_sus_usb_over_current_gpio_mode_values[] = { 1, 1 };\n\nstatic const unsigned int byt_sus_usb_ulpi_pins[] = {\n\t14, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,\n};\nstatic const unsigned int byt_sus_usb_ulpi_mode_values[] = {\n\t2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n};\nstatic const unsigned int byt_sus_usb_ulpi_gpio_mode_values[] = {\n\t1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n};\n\nstatic const unsigned int byt_sus_pcu_spi_pins[] = { 21 };\nstatic const unsigned int byt_sus_pcu_spi_mode_values[] = { 0 };\nstatic const unsigned int byt_sus_pcu_spi_gpio_mode_values[] = { 1 };\n\nstatic const unsigned int byt_sus_pmu_clk1_pins[] = { 5 };\nstatic const unsigned int byt_sus_pmu_clk2_pins[] = { 6 };\n\nstatic const struct intel_pingroup byt_sus_groups[] = {\n\tPIN_GROUP(\"usb_oc_grp\", byt_sus_usb_over_current_pins, byt_sus_usb_over_current_mode_values),\n\tPIN_GROUP(\"usb_ulpi_grp\", byt_sus_usb_ulpi_pins, byt_sus_usb_ulpi_mode_values),\n\tPIN_GROUP(\"pcu_spi_grp\", byt_sus_pcu_spi_pins, byt_sus_pcu_spi_mode_values),\n\tPIN_GROUP(\"usb_oc_grp_gpio\", byt_sus_usb_over_current_pins, byt_sus_usb_over_current_gpio_mode_values),\n\tPIN_GROUP(\"usb_ulpi_grp_gpio\", byt_sus_usb_ulpi_pins, byt_sus_usb_ulpi_gpio_mode_values),\n\tPIN_GROUP(\"pcu_spi_grp_gpio\", byt_sus_pcu_spi_pins, byt_sus_pcu_spi_gpio_mode_values),\n\tPIN_GROUP(\"pmu_clk1_grp\", byt_sus_pmu_clk1_pins, 1),\n\tPIN_GROUP(\"pmu_clk2_grp\", byt_sus_pmu_clk2_pins, 1),\n};\n\nstatic const char * const byt_sus_usb_groups[] = {\n\t\"usb_oc_grp\", \"usb_ulpi_grp\",\n};\nstatic const char * const byt_sus_spi_groups[] = { \"pcu_spi_grp\" };\nstatic const char * const byt_sus_pmu_clk_groups[] = {\n\t\"pmu_clk1_grp\", \"pmu_clk2_grp\",\n};\nstatic const char * const byt_sus_gpio_groups[] = {\n\t\"usb_oc_grp_gpio\", \"usb_ulpi_grp_gpio\", \"pcu_spi_grp_gpio\",\n\t\"pmu_clk1_grp\", \"pmu_clk2_grp\",\n};\n\nstatic const struct intel_function byt_sus_functions[] = {\n\tFUNCTION(\"usb\", byt_sus_usb_groups),\n\tFUNCTION(\"spi\", byt_sus_spi_groups),\n\tFUNCTION(\"gpio\", byt_sus_gpio_groups),\n\tFUNCTION(\"pmu_clk\", byt_sus_pmu_clk_groups),\n};\n\nstatic const struct intel_community byt_sus_communities[] = {\n\tCOMMUNITY(0, BYT_NGPIO_SUS, byt_sus_pins_map),\n};\n\nstatic const struct intel_pinctrl_soc_data byt_sus_soc_data = {\n\t.uid\t\t= BYT_SUS_ACPI_UID,\n\t.pins\t\t= byt_sus_pins,\n\t.npins\t\t= ARRAY_SIZE(byt_sus_pins),\n\t.groups\t\t= byt_sus_groups,\n\t.ngroups\t= ARRAY_SIZE(byt_sus_groups),\n\t.functions\t= byt_sus_functions,\n\t.nfunctions\t= ARRAY_SIZE(byt_sus_functions),\n\t.communities\t= byt_sus_communities,\n\t.ncommunities\t= ARRAY_SIZE(byt_sus_communities),\n};\n\nstatic const struct pinctrl_pin_desc byt_ncore_pins[] = {\n\tPINCTRL_PIN(0, \"HV_DDI0_HPD\"),\n\tPINCTRL_PIN(1, \"HV_DDI0_DDC_SDA\"),\n\tPINCTRL_PIN(2, \"HV_DDI0_DDC_SCL\"),\n\tPINCTRL_PIN(3, \"PANEL0_VDDEN\"),\n\tPINCTRL_PIN(4, \"PANEL0_BKLTEN\"),\n\tPINCTRL_PIN(5, \"PANEL0_BKLTCTL\"),\n\tPINCTRL_PIN(6, \"HV_DDI1_HPD\"),\n\tPINCTRL_PIN(7, \"HV_DDI1_DDC_SDA\"),\n\tPINCTRL_PIN(8, \"HV_DDI1_DDC_SCL\"),\n\tPINCTRL_PIN(9, \"PANEL1_VDDEN\"),\n\tPINCTRL_PIN(10, \"PANEL1_BKLTEN\"),\n\tPINCTRL_PIN(11, \"PANEL1_BKLTCTL\"),\n\tPINCTRL_PIN(12, \"GP_INTD_DSI_TE1\"),\n\tPINCTRL_PIN(13, \"HV_DDI2_DDC_SDA\"),\n\tPINCTRL_PIN(14, \"HV_DDI2_DDC_SCL\"),\n\tPINCTRL_PIN(15, \"GP_CAMERASB00\"),\n\tPINCTRL_PIN(16, \"GP_CAMERASB01\"),\n\tPINCTRL_PIN(17, \"GP_CAMERASB02\"),\n\tPINCTRL_PIN(18, \"GP_CAMERASB03\"),\n\tPINCTRL_PIN(19, \"GP_CAMERASB04\"),\n\tPINCTRL_PIN(20, \"GP_CAMERASB05\"),\n\tPINCTRL_PIN(21, \"GP_CAMERASB06\"),\n\tPINCTRL_PIN(22, \"GP_CAMERASB07\"),\n\tPINCTRL_PIN(23, \"GP_CAMERASB08\"),\n\tPINCTRL_PIN(24, \"GP_CAMERASB09\"),\n\tPINCTRL_PIN(25, \"GP_CAMERASB10\"),\n\tPINCTRL_PIN(26, \"GP_CAMERASB11\"),\n\tPINCTRL_PIN(27, \"GP_INTD_DSI_TE2\"),\n};\n\nstatic const unsigned int byt_ncore_pins_map[BYT_NGPIO_NCORE] = {\n\t19, 18, 17, 20, 21, 22, 24, 25, 23, 16,\n\t14, 15, 12, 26, 27, 1, 4, 8, 11, 0,\n\t3, 6, 10, 13, 2, 5, 9, 7,\n};\n\nstatic const struct intel_community byt_ncore_communities[] = {\n\tCOMMUNITY(0, BYT_NGPIO_NCORE, byt_ncore_pins_map),\n};\n\nstatic const struct intel_pinctrl_soc_data byt_ncore_soc_data = {\n\t.uid\t\t= BYT_NCORE_ACPI_UID,\n\t.pins\t\t= byt_ncore_pins,\n\t.npins\t\t= ARRAY_SIZE(byt_ncore_pins),\n\t.communities\t= byt_ncore_communities,\n\t.ncommunities\t= ARRAY_SIZE(byt_ncore_communities),\n};\n\nstatic const struct intel_pinctrl_soc_data *byt_soc_data[] = {\n\t&byt_score_soc_data,\n\t&byt_sus_soc_data,\n\t&byt_ncore_soc_data,\n\tNULL\n};\n\nstatic DEFINE_RAW_SPINLOCK(byt_lock);\n\nstatic void __iomem *byt_gpio_reg(struct intel_pinctrl *vg, unsigned int offset,\n\t\t\t\t  int reg)\n{\n\tstruct intel_community *comm = intel_get_community(vg, offset);\n\tu32 reg_offset;\n\n\tif (!comm)\n\t\treturn NULL;\n\n\toffset -= comm->pin_base;\n\tswitch (reg) {\n\tcase BYT_INT_STAT_REG:\n\t\treg_offset = (offset / 32) * 4;\n\t\tbreak;\n\tcase BYT_DEBOUNCE_REG:\n\t\treg_offset = 0;\n\t\tbreak;\n\tdefault:\n\t\treg_offset = comm->pad_map[offset] * 16;\n\t\tbreak;\n\t}\n\n\treturn comm->pad_regs + reg_offset + reg;\n}\n\nstatic const struct pinctrl_ops byt_pinctrl_ops = {\n\t.get_groups_count\t= intel_get_groups_count,\n\t.get_group_name\t\t= intel_get_group_name,\n\t.get_group_pins\t\t= intel_get_group_pins,\n};\n\nstatic void byt_set_group_simple_mux(struct intel_pinctrl *vg,\n\t\t\t\t     const struct intel_pingroup group,\n\t\t\t\t     unsigned int func)\n{\n\tunsigned long flags;\n\tint i;\n\n\traw_spin_lock_irqsave(&byt_lock, flags);\n\n\tfor (i = 0; i < group.grp.npins; i++) {\n\t\tvoid __iomem *padcfg0;\n\t\tu32 value;\n\n\t\tpadcfg0 = byt_gpio_reg(vg, group.grp.pins[i], BYT_CONF0_REG);\n\t\tif (!padcfg0) {\n\t\t\tdev_warn(vg->dev, \"Group %s, pin %i not muxed (can't retrieve CONF0)\\n\",\n\t\t\t\t group.grp.name, i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tvalue = readl(padcfg0);\n\t\tvalue &= ~BYT_PIN_MUX;\n\t\tvalue |= func;\n\t\twritel(value, padcfg0);\n\t}\n\n\traw_spin_unlock_irqrestore(&byt_lock, flags);\n}\n\nstatic void byt_set_group_mixed_mux(struct intel_pinctrl *vg,\n\t\t\t\t    const struct intel_pingroup group,\n\t\t\t\t    const unsigned int *func)\n{\n\tunsigned long flags;\n\tint i;\n\n\traw_spin_lock_irqsave(&byt_lock, flags);\n\n\tfor (i = 0; i < group.grp.npins; i++) {\n\t\tvoid __iomem *padcfg0;\n\t\tu32 value;\n\n\t\tpadcfg0 = byt_gpio_reg(vg, group.grp.pins[i], BYT_CONF0_REG);\n\t\tif (!padcfg0) {\n\t\t\tdev_warn(vg->dev, \"Group %s, pin %i not muxed (can't retrieve CONF0)\\n\",\n\t\t\t\t group.grp.name, i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tvalue = readl(padcfg0);\n\t\tvalue &= ~BYT_PIN_MUX;\n\t\tvalue |= func[i];\n\t\twritel(value, padcfg0);\n\t}\n\n\traw_spin_unlock_irqrestore(&byt_lock, flags);\n}\n\nstatic int byt_set_mux(struct pinctrl_dev *pctldev, unsigned int func_selector,\n\t\t       unsigned int group_selector)\n{\n\tstruct intel_pinctrl *vg = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct intel_function func = vg->soc->functions[func_selector];\n\tconst struct intel_pingroup group = vg->soc->groups[group_selector];\n\n\tif (group.modes)\n\t\tbyt_set_group_mixed_mux(vg, group, group.modes);\n\telse if (!strcmp(func.func.name, \"gpio\"))\n\t\tbyt_set_group_simple_mux(vg, group, BYT_DEFAULT_GPIO_MUX);\n\telse\n\t\tbyt_set_group_simple_mux(vg, group, group.mode);\n\n\treturn 0;\n}\n\nstatic u32 byt_get_gpio_mux(struct intel_pinctrl *vg, unsigned int offset)\n{\n\t \n\tif (!strcmp(vg->soc->uid, BYT_SCORE_ACPI_UID) &&\n\t    offset >= 92 && offset <= 93)\n\t\treturn BYT_ALTER_GPIO_MUX;\n\n\t \n\tif (!strcmp(vg->soc->uid, BYT_SUS_ACPI_UID) &&\n\t    offset >= 11 && offset <= 21)\n\t\treturn BYT_ALTER_GPIO_MUX;\n\n\treturn BYT_DEFAULT_GPIO_MUX;\n}\n\nstatic void byt_gpio_clear_triggering(struct intel_pinctrl *vg, unsigned int offset)\n{\n\tvoid __iomem *reg = byt_gpio_reg(vg, offset, BYT_CONF0_REG);\n\tunsigned long flags;\n\tu32 value;\n\n\traw_spin_lock_irqsave(&byt_lock, flags);\n\tvalue = readl(reg);\n\n\t \n\tif (!(value & BYT_DIRECT_IRQ_EN))\n\t\tvalue &= ~(BYT_TRIG_POS | BYT_TRIG_NEG | BYT_TRIG_LVL);\n\n\twritel(value, reg);\n\traw_spin_unlock_irqrestore(&byt_lock, flags);\n}\n\nstatic int byt_gpio_request_enable(struct pinctrl_dev *pctl_dev,\n\t\t\t\t   struct pinctrl_gpio_range *range,\n\t\t\t\t   unsigned int offset)\n{\n\tstruct intel_pinctrl *vg = pinctrl_dev_get_drvdata(pctl_dev);\n\tvoid __iomem *reg = byt_gpio_reg(vg, offset, BYT_CONF0_REG);\n\tu32 value, gpio_mux;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&byt_lock, flags);\n\n\t \n\tvalue = readl(reg) & BYT_PIN_MUX;\n\tgpio_mux = byt_get_gpio_mux(vg, offset);\n\tif (gpio_mux != value) {\n\t\tvalue = readl(reg) & ~BYT_PIN_MUX;\n\t\tvalue |= gpio_mux;\n\t\twritel(value, reg);\n\n\t\tdev_warn(vg->dev, FW_BUG \"Pin %i: forcibly re-configured as GPIO\\n\", offset);\n\t}\n\n\traw_spin_unlock_irqrestore(&byt_lock, flags);\n\n\tpm_runtime_get(vg->dev);\n\n\treturn 0;\n}\n\nstatic void byt_gpio_disable_free(struct pinctrl_dev *pctl_dev,\n\t\t\t\t  struct pinctrl_gpio_range *range,\n\t\t\t\t  unsigned int offset)\n{\n\tstruct intel_pinctrl *vg = pinctrl_dev_get_drvdata(pctl_dev);\n\n\tbyt_gpio_clear_triggering(vg, offset);\n\tpm_runtime_put(vg->dev);\n}\n\nstatic void byt_gpio_direct_irq_check(struct intel_pinctrl *vg,\n\t\t\t\t      unsigned int offset)\n{\n\tvoid __iomem *conf_reg = byt_gpio_reg(vg, offset, BYT_CONF0_REG);\n\n\t \n\tif (readl(conf_reg) & BYT_DIRECT_IRQ_EN)\n\t\tdev_info_once(vg->dev,\n\t\t\t      \"Potential Error: Pin %i: forcibly set GPIO with DIRECT_IRQ_EN to output\\n\",\n\t\t\t      offset);\n}\n\nstatic int byt_gpio_set_direction(struct pinctrl_dev *pctl_dev,\n\t\t\t\t  struct pinctrl_gpio_range *range,\n\t\t\t\t  unsigned int offset,\n\t\t\t\t  bool input)\n{\n\tstruct intel_pinctrl *vg = pinctrl_dev_get_drvdata(pctl_dev);\n\tvoid __iomem *val_reg = byt_gpio_reg(vg, offset, BYT_VAL_REG);\n\tunsigned long flags;\n\tu32 value;\n\n\traw_spin_lock_irqsave(&byt_lock, flags);\n\n\tvalue = readl(val_reg);\n\tvalue &= ~BYT_DIR_MASK;\n\tif (input)\n\t\tvalue |= BYT_OUTPUT_EN;\n\telse\n\t\tbyt_gpio_direct_irq_check(vg, offset);\n\n\twritel(value, val_reg);\n\n\traw_spin_unlock_irqrestore(&byt_lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct pinmux_ops byt_pinmux_ops = {\n\t.get_functions_count\t= intel_get_functions_count,\n\t.get_function_name\t= intel_get_function_name,\n\t.get_function_groups\t= intel_get_function_groups,\n\t.set_mux\t\t= byt_set_mux,\n\t.gpio_request_enable\t= byt_gpio_request_enable,\n\t.gpio_disable_free\t= byt_gpio_disable_free,\n\t.gpio_set_direction\t= byt_gpio_set_direction,\n};\n\nstatic void byt_get_pull_strength(u32 reg, u16 *strength)\n{\n\tswitch (reg & BYT_PULL_STR_MASK) {\n\tcase BYT_PULL_STR_2K:\n\t\t*strength = 2000;\n\t\tbreak;\n\tcase BYT_PULL_STR_10K:\n\t\t*strength = 10000;\n\t\tbreak;\n\tcase BYT_PULL_STR_20K:\n\t\t*strength = 20000;\n\t\tbreak;\n\tcase BYT_PULL_STR_40K:\n\t\t*strength = 40000;\n\t\tbreak;\n\t}\n}\n\nstatic int byt_set_pull_strength(u32 *reg, u16 strength)\n{\n\t*reg &= ~BYT_PULL_STR_MASK;\n\n\tswitch (strength) {\n\tcase 2000:\n\t\t*reg |= BYT_PULL_STR_2K;\n\t\tbreak;\n\tcase 10000:\n\t\t*reg |= BYT_PULL_STR_10K;\n\t\tbreak;\n\tcase 20000:\n\t\t*reg |= BYT_PULL_STR_20K;\n\t\tbreak;\n\tcase 40000:\n\t\t*reg |= BYT_PULL_STR_40K;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int byt_pin_config_get(struct pinctrl_dev *pctl_dev, unsigned int offset,\n\t\t\t      unsigned long *config)\n{\n\tstruct intel_pinctrl *vg = pinctrl_dev_get_drvdata(pctl_dev);\n\tenum pin_config_param param = pinconf_to_config_param(*config);\n\tvoid __iomem *conf_reg = byt_gpio_reg(vg, offset, BYT_CONF0_REG);\n\tvoid __iomem *val_reg = byt_gpio_reg(vg, offset, BYT_VAL_REG);\n\tvoid __iomem *db_reg = byt_gpio_reg(vg, offset, BYT_DEBOUNCE_REG);\n\tunsigned long flags;\n\tu32 conf, pull, val, debounce;\n\tu16 arg = 0;\n\n\traw_spin_lock_irqsave(&byt_lock, flags);\n\tconf = readl(conf_reg);\n\tpull = conf & BYT_PULL_ASSIGN_MASK;\n\tval = readl(val_reg);\n\traw_spin_unlock_irqrestore(&byt_lock, flags);\n\n\tswitch (param) {\n\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\tif (pull)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\t \n\t\tif ((val & BYT_INPUT_EN) || pull != BYT_PULL_ASSIGN_DOWN)\n\t\t\treturn -EINVAL;\n\n\t\tbyt_get_pull_strength(conf, &arg);\n\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\t \n\t\tif ((val & BYT_INPUT_EN) || pull != BYT_PULL_ASSIGN_UP)\n\t\t\treturn -EINVAL;\n\n\t\tbyt_get_pull_strength(conf, &arg);\n\n\t\tbreak;\n\tcase PIN_CONFIG_INPUT_DEBOUNCE:\n\t\tif (!(conf & BYT_DEBOUNCE_EN))\n\t\t\treturn -EINVAL;\n\n\t\traw_spin_lock_irqsave(&byt_lock, flags);\n\t\tdebounce = readl(db_reg);\n\t\traw_spin_unlock_irqrestore(&byt_lock, flags);\n\n\t\tswitch (debounce & BYT_DEBOUNCE_PULSE_MASK) {\n\t\tcase BYT_DEBOUNCE_PULSE_375US:\n\t\t\targ = 375;\n\t\t\tbreak;\n\t\tcase BYT_DEBOUNCE_PULSE_750US:\n\t\t\targ = 750;\n\t\t\tbreak;\n\t\tcase BYT_DEBOUNCE_PULSE_1500US:\n\t\t\targ = 1500;\n\t\t\tbreak;\n\t\tcase BYT_DEBOUNCE_PULSE_3MS:\n\t\t\targ = 3000;\n\t\t\tbreak;\n\t\tcase BYT_DEBOUNCE_PULSE_6MS:\n\t\t\targ = 6000;\n\t\t\tbreak;\n\t\tcase BYT_DEBOUNCE_PULSE_12MS:\n\t\t\targ = 12000;\n\t\t\tbreak;\n\t\tcase BYT_DEBOUNCE_PULSE_24MS:\n\t\t\targ = 24000;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\t*config = pinconf_to_config_packed(param, arg);\n\n\treturn 0;\n}\n\nstatic int byt_pin_config_set(struct pinctrl_dev *pctl_dev,\n\t\t\t      unsigned int offset,\n\t\t\t      unsigned long *configs,\n\t\t\t      unsigned int num_configs)\n{\n\tstruct intel_pinctrl *vg = pinctrl_dev_get_drvdata(pctl_dev);\n\tunsigned int param, arg;\n\tvoid __iomem *conf_reg = byt_gpio_reg(vg, offset, BYT_CONF0_REG);\n\tvoid __iomem *val_reg = byt_gpio_reg(vg, offset, BYT_VAL_REG);\n\tvoid __iomem *db_reg = byt_gpio_reg(vg, offset, BYT_DEBOUNCE_REG);\n\tu32 conf, val, db_pulse, debounce;\n\tunsigned long flags;\n\tint i, ret = 0;\n\n\traw_spin_lock_irqsave(&byt_lock, flags);\n\n\tconf = readl(conf_reg);\n\tval = readl(val_reg);\n\n\tfor (i = 0; i < num_configs; i++) {\n\t\tparam = pinconf_to_config_param(configs[i]);\n\t\targ = pinconf_to_config_argument(configs[i]);\n\n\t\tswitch (param) {\n\t\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\t\tconf &= ~BYT_PULL_ASSIGN_MASK;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\t\t \n\t\t\tif (arg == 1)\n\t\t\t\targ = 2000;\n\n\t\t\t \n\t\t\tif (val & BYT_INPUT_EN) {\n\t\t\t\tval &= ~BYT_INPUT_EN;\n\t\t\t\twritel(val, val_reg);\n\t\t\t\tdev_warn(vg->dev, \"Pin %i: forcibly set to input mode\\n\", offset);\n\t\t\t}\n\n\t\t\tconf &= ~BYT_PULL_ASSIGN_MASK;\n\t\t\tconf |= BYT_PULL_ASSIGN_DOWN;\n\t\t\tret = byt_set_pull_strength(&conf, arg);\n\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\t\t \n\t\t\tif (arg == 1)\n\t\t\t\targ = 2000;\n\n\t\t\t \n\t\t\tif (val & BYT_INPUT_EN) {\n\t\t\t\tval &= ~BYT_INPUT_EN;\n\t\t\t\twritel(val, val_reg);\n\t\t\t\tdev_warn(vg->dev, \"Pin %i: forcibly set to input mode\\n\", offset);\n\t\t\t}\n\n\t\t\tconf &= ~BYT_PULL_ASSIGN_MASK;\n\t\t\tconf |= BYT_PULL_ASSIGN_UP;\n\t\t\tret = byt_set_pull_strength(&conf, arg);\n\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_INPUT_DEBOUNCE:\n\t\t\tif (arg) {\n\t\t\t\tconf |= BYT_DEBOUNCE_EN;\n\t\t\t} else {\n\t\t\t\tconf &= ~BYT_DEBOUNCE_EN;\n\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch (arg) {\n\t\t\tcase 375:\n\t\t\t\tdb_pulse = BYT_DEBOUNCE_PULSE_375US;\n\t\t\t\tbreak;\n\t\t\tcase 750:\n\t\t\t\tdb_pulse = BYT_DEBOUNCE_PULSE_750US;\n\t\t\t\tbreak;\n\t\t\tcase 1500:\n\t\t\t\tdb_pulse = BYT_DEBOUNCE_PULSE_1500US;\n\t\t\t\tbreak;\n\t\t\tcase 3000:\n\t\t\t\tdb_pulse = BYT_DEBOUNCE_PULSE_3MS;\n\t\t\t\tbreak;\n\t\t\tcase 6000:\n\t\t\t\tdb_pulse = BYT_DEBOUNCE_PULSE_6MS;\n\t\t\t\tbreak;\n\t\t\tcase 12000:\n\t\t\t\tdb_pulse = BYT_DEBOUNCE_PULSE_12MS;\n\t\t\t\tbreak;\n\t\t\tcase 24000:\n\t\t\t\tdb_pulse = BYT_DEBOUNCE_PULSE_24MS;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (arg)\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\tdebounce = readl(db_reg);\n\t\t\tdebounce = (debounce & ~BYT_DEBOUNCE_PULSE_MASK) | db_pulse;\n\t\t\twritel(debounce, db_reg);\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -ENOTSUPP;\n\t\t}\n\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tif (!ret)\n\t\twritel(conf, conf_reg);\n\n\traw_spin_unlock_irqrestore(&byt_lock, flags);\n\n\treturn ret;\n}\n\nstatic const struct pinconf_ops byt_pinconf_ops = {\n\t.is_generic\t= true,\n\t.pin_config_get\t= byt_pin_config_get,\n\t.pin_config_set\t= byt_pin_config_set,\n};\n\nstatic const struct pinctrl_desc byt_pinctrl_desc = {\n\t.pctlops\t= &byt_pinctrl_ops,\n\t.pmxops\t\t= &byt_pinmux_ops,\n\t.confops\t= &byt_pinconf_ops,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int byt_gpio_get(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct intel_pinctrl *vg = gpiochip_get_data(chip);\n\tvoid __iomem *reg = byt_gpio_reg(vg, offset, BYT_VAL_REG);\n\tunsigned long flags;\n\tu32 val;\n\n\traw_spin_lock_irqsave(&byt_lock, flags);\n\tval = readl(reg);\n\traw_spin_unlock_irqrestore(&byt_lock, flags);\n\n\treturn !!(val & BYT_LEVEL);\n}\n\nstatic void byt_gpio_set(struct gpio_chip *chip, unsigned int offset, int value)\n{\n\tstruct intel_pinctrl *vg = gpiochip_get_data(chip);\n\tvoid __iomem *reg = byt_gpio_reg(vg, offset, BYT_VAL_REG);\n\tunsigned long flags;\n\tu32 old_val;\n\n\tif (!reg)\n\t\treturn;\n\n\traw_spin_lock_irqsave(&byt_lock, flags);\n\told_val = readl(reg);\n\tif (value)\n\t\twritel(old_val | BYT_LEVEL, reg);\n\telse\n\t\twritel(old_val & ~BYT_LEVEL, reg);\n\traw_spin_unlock_irqrestore(&byt_lock, flags);\n}\n\nstatic int byt_gpio_get_direction(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct intel_pinctrl *vg = gpiochip_get_data(chip);\n\tvoid __iomem *reg = byt_gpio_reg(vg, offset, BYT_VAL_REG);\n\tunsigned long flags;\n\tu32 value;\n\n\tif (!reg)\n\t\treturn -EINVAL;\n\n\traw_spin_lock_irqsave(&byt_lock, flags);\n\tvalue = readl(reg);\n\traw_spin_unlock_irqrestore(&byt_lock, flags);\n\n\tif (!(value & BYT_OUTPUT_EN))\n\t\treturn GPIO_LINE_DIRECTION_OUT;\n\tif (!(value & BYT_INPUT_EN))\n\t\treturn GPIO_LINE_DIRECTION_IN;\n\n\treturn -EINVAL;\n}\n\nstatic int byt_gpio_direction_input(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct intel_pinctrl *vg = gpiochip_get_data(chip);\n\tvoid __iomem *val_reg = byt_gpio_reg(vg, offset, BYT_VAL_REG);\n\tunsigned long flags;\n\tu32 reg;\n\n\traw_spin_lock_irqsave(&byt_lock, flags);\n\n\treg = readl(val_reg);\n\treg &= ~BYT_DIR_MASK;\n\treg |= BYT_OUTPUT_EN;\n\twritel(reg, val_reg);\n\n\traw_spin_unlock_irqrestore(&byt_lock, flags);\n\treturn 0;\n}\n\n \nstatic int byt_gpio_direction_output(struct gpio_chip *chip,\n\t\t\t\t     unsigned int offset, int value)\n{\n\tstruct intel_pinctrl *vg = gpiochip_get_data(chip);\n\tvoid __iomem *val_reg = byt_gpio_reg(vg, offset, BYT_VAL_REG);\n\tunsigned long flags;\n\tu32 reg;\n\n\traw_spin_lock_irqsave(&byt_lock, flags);\n\n\tbyt_gpio_direct_irq_check(vg, offset);\n\n\treg = readl(val_reg);\n\treg &= ~BYT_DIR_MASK;\n\tif (value)\n\t\treg |= BYT_LEVEL;\n\telse\n\t\treg &= ~BYT_LEVEL;\n\n\twritel(reg, val_reg);\n\n\traw_spin_unlock_irqrestore(&byt_lock, flags);\n\treturn 0;\n}\n\nstatic void byt_gpio_dbg_show(struct seq_file *s, struct gpio_chip *chip)\n{\n\tstruct intel_pinctrl *vg = gpiochip_get_data(chip);\n\tint i;\n\tu32 conf0, val;\n\n\tfor (i = 0; i < vg->soc->npins; i++) {\n\t\tconst struct intel_community *comm;\n\t\tvoid __iomem *conf_reg, *val_reg;\n\t\tconst char *pull_str = NULL;\n\t\tconst char *pull = NULL;\n\t\tunsigned long flags;\n\t\tconst char *label;\n\t\tunsigned int pin;\n\n\t\tpin = vg->soc->pins[i].number;\n\n\t\tconf_reg = byt_gpio_reg(vg, pin, BYT_CONF0_REG);\n\t\tif (!conf_reg) {\n\t\t\tseq_printf(s, \"Pin %i: can't retrieve CONF0\\n\", pin);\n\t\t\tcontinue;\n\t\t}\n\n\t\tval_reg = byt_gpio_reg(vg, pin, BYT_VAL_REG);\n\t\tif (!val_reg) {\n\t\t\tseq_printf(s, \"Pin %i: can't retrieve VAL\\n\", pin);\n\t\t\tcontinue;\n\t\t}\n\n\t\traw_spin_lock_irqsave(&byt_lock, flags);\n\t\tconf0 = readl(conf_reg);\n\t\tval = readl(val_reg);\n\t\traw_spin_unlock_irqrestore(&byt_lock, flags);\n\n\t\tcomm = intel_get_community(vg, pin);\n\t\tif (!comm) {\n\t\t\tseq_printf(s, \"Pin %i: can't retrieve community\\n\", pin);\n\t\t\tcontinue;\n\t\t}\n\t\tlabel = gpiochip_is_requested(chip, i);\n\t\tif (!label)\n\t\t\tlabel = \"Unrequested\";\n\n\t\tswitch (conf0 & BYT_PULL_ASSIGN_MASK) {\n\t\tcase BYT_PULL_ASSIGN_UP:\n\t\t\tpull = \"up\";\n\t\t\tbreak;\n\t\tcase BYT_PULL_ASSIGN_DOWN:\n\t\t\tpull = \"down\";\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (conf0 & BYT_PULL_STR_MASK) {\n\t\tcase BYT_PULL_STR_2K:\n\t\t\tpull_str = \"2k\";\n\t\t\tbreak;\n\t\tcase BYT_PULL_STR_10K:\n\t\t\tpull_str = \"10k\";\n\t\t\tbreak;\n\t\tcase BYT_PULL_STR_20K:\n\t\t\tpull_str = \"20k\";\n\t\t\tbreak;\n\t\tcase BYT_PULL_STR_40K:\n\t\t\tpull_str = \"40k\";\n\t\t\tbreak;\n\t\t}\n\n\t\tseq_printf(s,\n\t\t\t   \" gpio-%-3d (%-20.20s) %s %s %s pad-%-3d offset:0x%03x mux:%d %s%s%s\",\n\t\t\t   pin,\n\t\t\t   label,\n\t\t\t   val & BYT_INPUT_EN ? \"  \" : \"in\",\n\t\t\t   val & BYT_OUTPUT_EN ? \"   \" : \"out\",\n\t\t\t   str_hi_lo(val & BYT_LEVEL),\n\t\t\t   comm->pad_map[i], comm->pad_map[i] * 16,\n\t\t\t   conf0 & 0x7,\n\t\t\t   conf0 & BYT_TRIG_NEG ? \" fall\" : \"     \",\n\t\t\t   conf0 & BYT_TRIG_POS ? \" rise\" : \"     \",\n\t\t\t   conf0 & BYT_TRIG_LVL ? \" level\" : \"      \");\n\n\t\tif (pull && pull_str)\n\t\t\tseq_printf(s, \" %-4s %-3s\", pull, pull_str);\n\t\telse\n\t\t\tseq_puts(s, \"          \");\n\n\t\tif (conf0 & BYT_IODEN)\n\t\t\tseq_puts(s, \" open-drain\");\n\n\t\tseq_puts(s, \"\\n\");\n\t}\n}\n\nstatic const struct gpio_chip byt_gpio_chip = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.request\t\t= gpiochip_generic_request,\n\t.free\t\t\t= gpiochip_generic_free,\n\t.get_direction\t\t= byt_gpio_get_direction,\n\t.direction_input\t= byt_gpio_direction_input,\n\t.direction_output\t= byt_gpio_direction_output,\n\t.get\t\t\t= byt_gpio_get,\n\t.set\t\t\t= byt_gpio_set,\n\t.set_config\t\t= gpiochip_generic_config,\n\t.dbg_show\t\t= byt_gpio_dbg_show,\n};\n\nstatic void byt_irq_ack(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct intel_pinctrl *vg = gpiochip_get_data(gc);\n\tirq_hw_number_t hwirq = irqd_to_hwirq(d);\n\tvoid __iomem *reg;\n\n\treg = byt_gpio_reg(vg, hwirq, BYT_INT_STAT_REG);\n\tif (!reg)\n\t\treturn;\n\n\traw_spin_lock(&byt_lock);\n\twritel(BIT(hwirq % 32), reg);\n\traw_spin_unlock(&byt_lock);\n}\n\nstatic void byt_irq_mask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct intel_pinctrl *vg = gpiochip_get_data(gc);\n\tirq_hw_number_t hwirq = irqd_to_hwirq(d);\n\n\tbyt_gpio_clear_triggering(vg, hwirq);\n\tgpiochip_disable_irq(gc, hwirq);\n}\n\nstatic void byt_irq_unmask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct intel_pinctrl *vg = gpiochip_get_data(gc);\n\tirq_hw_number_t hwirq = irqd_to_hwirq(d);\n\tunsigned long flags;\n\tvoid __iomem *reg;\n\tu32 value;\n\n\tgpiochip_enable_irq(gc, hwirq);\n\n\treg = byt_gpio_reg(vg, hwirq, BYT_CONF0_REG);\n\tif (!reg)\n\t\treturn;\n\n\traw_spin_lock_irqsave(&byt_lock, flags);\n\tvalue = readl(reg);\n\n\tswitch (irqd_get_trigger_type(d)) {\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tvalue |= BYT_TRIG_LVL;\n\t\tfallthrough;\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tvalue |= BYT_TRIG_POS;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tvalue |= BYT_TRIG_LVL;\n\t\tfallthrough;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tvalue |= BYT_TRIG_NEG;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\tvalue |= (BYT_TRIG_NEG | BYT_TRIG_POS);\n\t\tbreak;\n\t}\n\n\twritel(value, reg);\n\n\traw_spin_unlock_irqrestore(&byt_lock, flags);\n}\n\nstatic int byt_irq_type(struct irq_data *d, unsigned int type)\n{\n\tstruct intel_pinctrl *vg = gpiochip_get_data(irq_data_get_irq_chip_data(d));\n\tirq_hw_number_t hwirq = irqd_to_hwirq(d);\n\tu32 value;\n\tunsigned long flags;\n\tvoid __iomem *reg;\n\n\treg = byt_gpio_reg(vg, hwirq, BYT_CONF0_REG);\n\tif (!reg)\n\t\treturn -EINVAL;\n\n\traw_spin_lock_irqsave(&byt_lock, flags);\n\tvalue = readl(reg);\n\n\tWARN(value & BYT_DIRECT_IRQ_EN,\n\t     \"Bad pad config for IO mode, force DIRECT_IRQ_EN bit clearing\");\n\n\t \n\tvalue &= ~(BYT_DIRECT_IRQ_EN | BYT_TRIG_POS | BYT_TRIG_NEG |\n\t\t   BYT_TRIG_LVL);\n\t \n\tvalue |= BYT_GLITCH_FILTER_EN | BYT_GLITCH_F_SLOW_CLK |\n\t\t BYT_GLITCH_F_FAST_CLK;\n\n\twritel(value, reg);\n\n\tif (type & IRQ_TYPE_EDGE_BOTH)\n\t\tirq_set_handler_locked(d, handle_edge_irq);\n\telse if (type & IRQ_TYPE_LEVEL_MASK)\n\t\tirq_set_handler_locked(d, handle_level_irq);\n\n\traw_spin_unlock_irqrestore(&byt_lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct irq_chip byt_gpio_irq_chip = {\n\t.name\t\t= \"BYT-GPIO\",\n\t.irq_ack\t= byt_irq_ack,\n\t.irq_mask\t= byt_irq_mask,\n\t.irq_unmask\t= byt_irq_unmask,\n\t.irq_set_type\t= byt_irq_type,\n\t.flags\t\t= IRQCHIP_SKIP_SET_WAKE | IRQCHIP_SET_TYPE_MASKED | IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic void byt_gpio_irq_handler(struct irq_desc *desc)\n{\n\tstruct irq_data *data = irq_desc_get_irq_data(desc);\n\tstruct intel_pinctrl *vg = gpiochip_get_data(irq_desc_get_handler_data(desc));\n\tstruct irq_chip *chip = irq_data_get_irq_chip(data);\n\tu32 base, pin;\n\tvoid __iomem *reg;\n\tunsigned long pending;\n\n\t \n\tfor (base = 0; base < vg->chip.ngpio; base += 32) {\n\t\treg = byt_gpio_reg(vg, base, BYT_INT_STAT_REG);\n\n\t\tif (!reg) {\n\t\t\tdev_warn(vg->dev, \"Pin %i: can't retrieve INT_STAT%u\\n\", base / 32, base);\n\t\t\tcontinue;\n\t\t}\n\n\t\traw_spin_lock(&byt_lock);\n\t\tpending = readl(reg);\n\t\traw_spin_unlock(&byt_lock);\n\t\tfor_each_set_bit(pin, &pending, 32)\n\t\t\tgeneric_handle_domain_irq(vg->chip.irq.domain, base + pin);\n\t}\n\tchip->irq_eoi(data);\n}\n\nstatic bool byt_direct_irq_sanity_check(struct intel_pinctrl *vg, int pin, u32 conf0)\n{\n\tint direct_irq, ioapic_direct_irq_base;\n\tu8 *match, direct_irq_mux[16];\n\tu32 trig;\n\n\tmemcpy_fromio(direct_irq_mux, vg->communities->pad_regs + BYT_DIRECT_IRQ_REG,\n\t\t      sizeof(direct_irq_mux));\n\tmatch = memchr(direct_irq_mux, pin, sizeof(direct_irq_mux));\n\tif (!match) {\n\t\tdev_warn(vg->dev, FW_BUG \"Pin %i: DIRECT_IRQ_EN set but no IRQ assigned, clearing\\n\", pin);\n\t\treturn false;\n\t}\n\n\tdirect_irq = match - direct_irq_mux;\n\t \n\tioapic_direct_irq_base = (vg->communities->npins == BYT_NGPIO_SCORE) ? 51 : 67;\n\tdev_dbg(vg->dev, \"Pin %i: uses direct IRQ %d (IO-APIC %d)\\n\", pin,\n\t\tdirect_irq, direct_irq + ioapic_direct_irq_base);\n\n\t \n\ttrig = conf0 & BYT_TRIG_MASK;\n\tif (trig != (BYT_TRIG_POS | BYT_TRIG_LVL) &&\n\t    trig != (BYT_TRIG_NEG | BYT_TRIG_LVL)) {\n\t\tdev_warn(vg->dev,\n\t\t\t FW_BUG \"Pin %i: DIRECT_IRQ_EN set without trigger (CONF0: %#08x), clearing\\n\",\n\t\t\t pin, conf0);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void byt_init_irq_valid_mask(struct gpio_chip *chip,\n\t\t\t\t    unsigned long *valid_mask,\n\t\t\t\t    unsigned int ngpios)\n{\n\tstruct intel_pinctrl *vg = gpiochip_get_data(chip);\n\tvoid __iomem *reg;\n\tu32 value;\n\tint i;\n\n\t \n\tfor (i = 0; i < vg->soc->npins; i++) {\n\t\tunsigned int pin = vg->soc->pins[i].number;\n\n\t\treg = byt_gpio_reg(vg, pin, BYT_CONF0_REG);\n\t\tif (!reg) {\n\t\t\tdev_warn(vg->dev, \"Pin %i: could not retrieve CONF0\\n\", i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tvalue = readl(reg);\n\t\tif (value & BYT_DIRECT_IRQ_EN) {\n\t\t\tif (byt_direct_irq_sanity_check(vg, i, value)) {\n\t\t\t\tclear_bit(i, valid_mask);\n\t\t\t} else {\n\t\t\t\tvalue &= ~(BYT_DIRECT_IRQ_EN | BYT_TRIG_POS |\n\t\t\t\t\t   BYT_TRIG_NEG | BYT_TRIG_LVL);\n\t\t\t\twritel(value, reg);\n\t\t\t}\n\t\t} else if ((value & BYT_PIN_MUX) == byt_get_gpio_mux(vg, i)) {\n\t\t\tbyt_gpio_clear_triggering(vg, i);\n\t\t\tdev_dbg(vg->dev, \"disabling GPIO %d\\n\", i);\n\t\t}\n\t}\n}\n\nstatic int byt_gpio_irq_init_hw(struct gpio_chip *chip)\n{\n\tstruct intel_pinctrl *vg = gpiochip_get_data(chip);\n\tvoid __iomem *reg;\n\tu32 base, value;\n\n\t \n\tfor (base = 0; base < vg->soc->npins; base += 32) {\n\t\treg = byt_gpio_reg(vg, base, BYT_INT_STAT_REG);\n\n\t\tif (!reg) {\n\t\t\tdev_warn(vg->dev, \"Pin %i: can't retrieve INT_STAT%u\\n\", base / 32, base);\n\t\t\tcontinue;\n\t\t}\n\n\t\twritel(0xffffffff, reg);\n\t\t \n\t\tvalue = readl(reg);\n\t\tif (value)\n\t\t\tdev_err(vg->dev,\n\t\t\t\t\"GPIO interrupt error, pins misconfigured. INT_STAT%u: %#08x\\n\",\n\t\t\t\tbase / 32, value);\n\t}\n\n\treturn 0;\n}\n\nstatic int byt_gpio_add_pin_ranges(struct gpio_chip *chip)\n{\n\tstruct intel_pinctrl *vg = gpiochip_get_data(chip);\n\tstruct device *dev = vg->dev;\n\tint ret;\n\n\tret = gpiochip_add_pin_range(chip, dev_name(dev), 0, 0, vg->soc->npins);\n\tif (ret)\n\t\tdev_err(dev, \"failed to add GPIO pin range\\n\");\n\n\treturn ret;\n}\n\nstatic int byt_gpio_probe(struct intel_pinctrl *vg)\n{\n\tstruct platform_device *pdev = to_platform_device(vg->dev);\n\tstruct gpio_chip *gc;\n\tint irq, ret;\n\n\t \n\tvg->chip\t= byt_gpio_chip;\n\tgc\t\t= &vg->chip;\n\tgc->label\t= dev_name(vg->dev);\n\tgc->base\t= -1;\n\tgc->can_sleep\t= false;\n\tgc->add_pin_ranges = byt_gpio_add_pin_ranges;\n\tgc->parent\t= vg->dev;\n\tgc->ngpio\t= vg->soc->npins;\n\n#ifdef CONFIG_PM_SLEEP\n\tvg->context.pads = devm_kcalloc(vg->dev, gc->ngpio, sizeof(*vg->context.pads),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!vg->context.pads)\n\t\treturn -ENOMEM;\n#endif\n\n\t \n\tirq = platform_get_irq_optional(pdev, 0);\n\tif (irq > 0) {\n\t\tstruct gpio_irq_chip *girq;\n\n\t\tgirq = &gc->irq;\n\t\tgpio_irq_chip_set_chip(girq, &byt_gpio_irq_chip);\n\t\tgirq->init_hw = byt_gpio_irq_init_hw;\n\t\tgirq->init_valid_mask = byt_init_irq_valid_mask;\n\t\tgirq->parent_handler = byt_gpio_irq_handler;\n\t\tgirq->num_parents = 1;\n\t\tgirq->parents = devm_kcalloc(vg->dev, girq->num_parents,\n\t\t\t\t\t     sizeof(*girq->parents), GFP_KERNEL);\n\t\tif (!girq->parents)\n\t\t\treturn -ENOMEM;\n\t\tgirq->parents[0] = irq;\n\t\tgirq->default_type = IRQ_TYPE_NONE;\n\t\tgirq->handler = handle_bad_irq;\n\t}\n\n\tret = devm_gpiochip_add_data(vg->dev, gc, vg);\n\tif (ret) {\n\t\tdev_err(vg->dev, \"failed adding byt-gpio chip\\n\");\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int byt_set_soc_data(struct intel_pinctrl *vg,\n\t\t\t    const struct intel_pinctrl_soc_data *soc)\n{\n\tstruct platform_device *pdev = to_platform_device(vg->dev);\n\tint i;\n\n\tvg->soc = soc;\n\n\tvg->ncommunities = vg->soc->ncommunities;\n\tvg->communities = devm_kcalloc(vg->dev, vg->ncommunities,\n\t\t\t\t       sizeof(*vg->communities), GFP_KERNEL);\n\tif (!vg->communities)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < vg->soc->ncommunities; i++) {\n\t\tstruct intel_community *comm = vg->communities + i;\n\n\t\t*comm = vg->soc->communities[i];\n\n\t\tcomm->pad_regs = devm_platform_ioremap_resource(pdev, 0);\n\t\tif (IS_ERR(comm->pad_regs))\n\t\t\treturn PTR_ERR(comm->pad_regs);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct acpi_device_id byt_gpio_acpi_match[] = {\n\t{ \"INT33B2\", (kernel_ulong_t)byt_soc_data },\n\t{ \"INT33FC\", (kernel_ulong_t)byt_soc_data },\n\t{ }\n};\n\nstatic int byt_pinctrl_probe(struct platform_device *pdev)\n{\n\tconst struct intel_pinctrl_soc_data *soc_data;\n\tstruct device *dev = &pdev->dev;\n\tstruct intel_pinctrl *vg;\n\tint ret;\n\n\tsoc_data = intel_pinctrl_get_soc_data(pdev);\n\tif (IS_ERR(soc_data))\n\t\treturn PTR_ERR(soc_data);\n\n\tvg = devm_kzalloc(dev, sizeof(*vg), GFP_KERNEL);\n\tif (!vg)\n\t\treturn -ENOMEM;\n\n\tvg->dev = dev;\n\tret = byt_set_soc_data(vg, soc_data);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to set soc data\\n\");\n\t\treturn ret;\n\t}\n\n\tvg->pctldesc\t\t= byt_pinctrl_desc;\n\tvg->pctldesc.name\t= dev_name(dev);\n\tvg->pctldesc.pins\t= vg->soc->pins;\n\tvg->pctldesc.npins\t= vg->soc->npins;\n\n\tvg->pctldev = devm_pinctrl_register(dev, &vg->pctldesc, vg);\n\tif (IS_ERR(vg->pctldev)) {\n\t\tdev_err(dev, \"failed to register pinctrl driver\\n\");\n\t\treturn PTR_ERR(vg->pctldev);\n\t}\n\n\tret = byt_gpio_probe(vg);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, vg);\n\tpm_runtime_enable(dev);\n\n\treturn 0;\n}\n\nstatic int byt_gpio_suspend(struct device *dev)\n{\n\tstruct intel_pinctrl *vg = dev_get_drvdata(dev);\n\tunsigned long flags;\n\tint i;\n\n\traw_spin_lock_irqsave(&byt_lock, flags);\n\n\tfor (i = 0; i < vg->soc->npins; i++) {\n\t\tvoid __iomem *reg;\n\t\tu32 value;\n\t\tunsigned int pin = vg->soc->pins[i].number;\n\n\t\treg = byt_gpio_reg(vg, pin, BYT_CONF0_REG);\n\t\tif (!reg) {\n\t\t\tdev_warn(vg->dev, \"Pin %i: can't retrieve CONF0\\n\", i);\n\t\t\tcontinue;\n\t\t}\n\t\tvalue = readl(reg) & BYT_CONF0_RESTORE_MASK;\n\t\tvg->context.pads[i].conf0 = value;\n\n\t\treg = byt_gpio_reg(vg, pin, BYT_VAL_REG);\n\t\tif (!reg) {\n\t\t\tdev_warn(vg->dev, \"Pin %i: can't retrieve VAL\\n\", i);\n\t\t\tcontinue;\n\t\t}\n\t\tvalue = readl(reg) & BYT_VAL_RESTORE_MASK;\n\t\tvg->context.pads[i].val = value;\n\t}\n\n\traw_spin_unlock_irqrestore(&byt_lock, flags);\n\treturn 0;\n}\n\nstatic int byt_gpio_resume(struct device *dev)\n{\n\tstruct intel_pinctrl *vg = dev_get_drvdata(dev);\n\tunsigned long flags;\n\tint i;\n\n\traw_spin_lock_irqsave(&byt_lock, flags);\n\n\tfor (i = 0; i < vg->soc->npins; i++) {\n\t\tvoid __iomem *reg;\n\t\tu32 value;\n\t\tunsigned int pin = vg->soc->pins[i].number;\n\n\t\treg = byt_gpio_reg(vg, pin, BYT_CONF0_REG);\n\t\tif (!reg) {\n\t\t\tdev_warn(vg->dev, \"Pin %i: can't retrieve CONF0\\n\", i);\n\t\t\tcontinue;\n\t\t}\n\t\tvalue = readl(reg);\n\t\tif ((value & BYT_CONF0_RESTORE_MASK) !=\n\t\t     vg->context.pads[i].conf0) {\n\t\t\tvalue &= ~BYT_CONF0_RESTORE_MASK;\n\t\t\tvalue |= vg->context.pads[i].conf0;\n\t\t\twritel(value, reg);\n\t\t\tdev_info(dev, \"restored pin %d CONF0 %#08x\", i, value);\n\t\t}\n\n\t\treg = byt_gpio_reg(vg, pin, BYT_VAL_REG);\n\t\tif (!reg) {\n\t\t\tdev_warn(vg->dev, \"Pin %i: can't retrieve VAL\\n\", i);\n\t\t\tcontinue;\n\t\t}\n\t\tvalue = readl(reg);\n\t\tif ((value & BYT_VAL_RESTORE_MASK) !=\n\t\t     vg->context.pads[i].val) {\n\t\t\tu32 v;\n\n\t\t\tv = value & ~BYT_VAL_RESTORE_MASK;\n\t\t\tv |= vg->context.pads[i].val;\n\t\t\tif (v != value) {\n\t\t\t\twritel(v, reg);\n\t\t\t\tdev_dbg(dev, \"restored pin %d VAL %#08x\\n\", i, v);\n\t\t\t}\n\t\t}\n\t}\n\n\traw_spin_unlock_irqrestore(&byt_lock, flags);\n\treturn 0;\n}\n\nstatic int byt_gpio_runtime_suspend(struct device *dev)\n{\n\treturn 0;\n}\n\nstatic int byt_gpio_runtime_resume(struct device *dev)\n{\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops byt_gpio_pm_ops = {\n\tLATE_SYSTEM_SLEEP_PM_OPS(byt_gpio_suspend, byt_gpio_resume)\n\tRUNTIME_PM_OPS(byt_gpio_runtime_suspend, byt_gpio_runtime_resume, NULL)\n};\n\nstatic struct platform_driver byt_gpio_driver = {\n\t.probe          = byt_pinctrl_probe,\n\t.driver         = {\n\t\t.name\t\t\t= \"byt_gpio\",\n\t\t.pm\t\t\t= pm_ptr(&byt_gpio_pm_ops),\n\t\t.acpi_match_table\t= byt_gpio_acpi_match,\n\t\t.suppress_bind_attrs\t= true,\n\t},\n};\n\nstatic int __init byt_gpio_init(void)\n{\n\treturn platform_driver_register(&byt_gpio_driver);\n}\nsubsys_initcall(byt_gpio_init);\n\nMODULE_IMPORT_NS(PINCTRL_INTEL);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}