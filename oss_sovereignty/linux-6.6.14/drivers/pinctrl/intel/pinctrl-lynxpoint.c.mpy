{
  "module_name": "pinctrl-lynxpoint.c",
  "hash_id": "c4b4e761359bbb908ba2f3ec857b2c520a21d29618d95946645309b61c693ff4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/intel/pinctrl-lynxpoint.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/bitops.h>\n#include <linux/gpio/driver.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#include <linux/pinctrl/consumer.h>\n#include <linux/pinctrl/pinconf-generic.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinmux.h>\n\n#include \"pinctrl-intel.h\"\n\n#define COMMUNITY(p, n)\t\t\t\\\n\t{\t\t\t\t\\\n\t\t.pin_base\t= (p),\t\\\n\t\t.npins\t\t= (n),\t\\\n\t}\n\nstatic const struct pinctrl_pin_desc lptlp_pins[] = {\n\tPINCTRL_PIN(0, \"GP0_UART1_RXD\"),\n\tPINCTRL_PIN(1, \"GP1_UART1_TXD\"),\n\tPINCTRL_PIN(2, \"GP2_UART1_RTSB\"),\n\tPINCTRL_PIN(3, \"GP3_UART1_CTSB\"),\n\tPINCTRL_PIN(4, \"GP4_I2C0_SDA\"),\n\tPINCTRL_PIN(5, \"GP5_I2C0_SCL\"),\n\tPINCTRL_PIN(6, \"GP6_I2C1_SDA\"),\n\tPINCTRL_PIN(7, \"GP7_I2C1_SCL\"),\n\tPINCTRL_PIN(8, \"GP8\"),\n\tPINCTRL_PIN(9, \"GP9\"),\n\tPINCTRL_PIN(10, \"GP10\"),\n\tPINCTRL_PIN(11, \"GP11_SMBALERTB\"),\n\tPINCTRL_PIN(12, \"GP12_LANPHYPC\"),\n\tPINCTRL_PIN(13, \"GP13\"),\n\tPINCTRL_PIN(14, \"GP14\"),\n\tPINCTRL_PIN(15, \"GP15\"),\n\tPINCTRL_PIN(16, \"GP16_MGPIO9\"),\n\tPINCTRL_PIN(17, \"GP17_MGPIO10\"),\n\tPINCTRL_PIN(18, \"GP18_SRC0CLKRQB\"),\n\tPINCTRL_PIN(19, \"GP19_SRC1CLKRQB\"),\n\tPINCTRL_PIN(20, \"GP20_SRC2CLKRQB\"),\n\tPINCTRL_PIN(21, \"GP21_SRC3CLKRQB\"),\n\tPINCTRL_PIN(22, \"GP22_SRC4CLKRQB_TRST2\"),\n\tPINCTRL_PIN(23, \"GP23_SRC5CLKRQB_TDI2\"),\n\tPINCTRL_PIN(24, \"GP24_MGPIO0\"),\n\tPINCTRL_PIN(25, \"GP25_USBWAKEOUTB\"),\n\tPINCTRL_PIN(26, \"GP26_MGPIO5\"),\n\tPINCTRL_PIN(27, \"GP27_MGPIO6\"),\n\tPINCTRL_PIN(28, \"GP28_MGPIO7\"),\n\tPINCTRL_PIN(29, \"GP29_SLP_WLANB_MGPIO3\"),\n\tPINCTRL_PIN(30, \"GP30_SUSWARNB_SUSPWRDNACK_MGPIO1\"),\n\tPINCTRL_PIN(31, \"GP31_ACPRESENT_MGPIO2\"),\n\tPINCTRL_PIN(32, \"GP32_CLKRUNB\"),\n\tPINCTRL_PIN(33, \"GP33_DEVSLP0\"),\n\tPINCTRL_PIN(34, \"GP34_SATA0XPCIE6L3B_SATA0GP\"),\n\tPINCTRL_PIN(35, \"GP35_SATA1XPCIE6L2B_SATA1GP\"),\n\tPINCTRL_PIN(36, \"GP36_SATA2XPCIE6L1B_SATA2GP\"),\n\tPINCTRL_PIN(37, \"GP37_SATA3XPCIE6L0B_SATA3GP\"),\n\tPINCTRL_PIN(38, \"GP38_DEVSLP1\"),\n\tPINCTRL_PIN(39, \"GP39_DEVSLP2\"),\n\tPINCTRL_PIN(40, \"GP40_OC0B\"),\n\tPINCTRL_PIN(41, \"GP41_OC1B\"),\n\tPINCTRL_PIN(42, \"GP42_OC2B\"),\n\tPINCTRL_PIN(43, \"GP43_OC3B\"),\n\tPINCTRL_PIN(44, \"GP44\"),\n\tPINCTRL_PIN(45, \"GP45_TMS2\"),\n\tPINCTRL_PIN(46, \"GP46_TDO2\"),\n\tPINCTRL_PIN(47, \"GP47\"),\n\tPINCTRL_PIN(48, \"GP48\"),\n\tPINCTRL_PIN(49, \"GP49\"),\n\tPINCTRL_PIN(50, \"GP50\"),\n\tPINCTRL_PIN(51, \"GP51_GSXDOUT\"),\n\tPINCTRL_PIN(52, \"GP52_GSXSLOAD\"),\n\tPINCTRL_PIN(53, \"GP53_GSXDIN\"),\n\tPINCTRL_PIN(54, \"GP54_GSXSRESETB\"),\n\tPINCTRL_PIN(55, \"GP55_GSXCLK\"),\n\tPINCTRL_PIN(56, \"GP56\"),\n\tPINCTRL_PIN(57, \"GP57\"),\n\tPINCTRL_PIN(58, \"GP58\"),\n\tPINCTRL_PIN(59, \"GP59\"),\n\tPINCTRL_PIN(60, \"GP60_SML0ALERTB_MGPIO4\"),\n\tPINCTRL_PIN(61, \"GP61_SUS_STATB\"),\n\tPINCTRL_PIN(62, \"GP62_SUSCLK\"),\n\tPINCTRL_PIN(63, \"GP63_SLP_S5B\"),\n\tPINCTRL_PIN(64, \"GP64_SDIO_CLK\"),\n\tPINCTRL_PIN(65, \"GP65_SDIO_CMD\"),\n\tPINCTRL_PIN(66, \"GP66_SDIO_D0\"),\n\tPINCTRL_PIN(67, \"GP67_SDIO_D1\"),\n\tPINCTRL_PIN(68, \"GP68_SDIO_D2\"),\n\tPINCTRL_PIN(69, \"GP69_SDIO_D3\"),\n\tPINCTRL_PIN(70, \"GP70_SDIO_POWER_EN\"),\n\tPINCTRL_PIN(71, \"GP71_MPHYPC\"),\n\tPINCTRL_PIN(72, \"GP72_BATLOWB\"),\n\tPINCTRL_PIN(73, \"GP73_SML1ALERTB_PCHHOTB_MGPIO8\"),\n\tPINCTRL_PIN(74, \"GP74_SML1DATA_MGPIO12\"),\n\tPINCTRL_PIN(75, \"GP75_SML1CLK_MGPIO11\"),\n\tPINCTRL_PIN(76, \"GP76_BMBUSYB\"),\n\tPINCTRL_PIN(77, \"GP77_PIRQAB\"),\n\tPINCTRL_PIN(78, \"GP78_PIRQBB\"),\n\tPINCTRL_PIN(79, \"GP79_PIRQCB\"),\n\tPINCTRL_PIN(80, \"GP80_PIRQDB\"),\n\tPINCTRL_PIN(81, \"GP81_SPKR\"),\n\tPINCTRL_PIN(82, \"GP82_RCINB\"),\n\tPINCTRL_PIN(83, \"GP83_GSPI0_CSB\"),\n\tPINCTRL_PIN(84, \"GP84_GSPI0_CLK\"),\n\tPINCTRL_PIN(85, \"GP85_GSPI0_MISO\"),\n\tPINCTRL_PIN(86, \"GP86_GSPI0_MOSI\"),\n\tPINCTRL_PIN(87, \"GP87_GSPI1_CSB\"),\n\tPINCTRL_PIN(88, \"GP88_GSPI1_CLK\"),\n\tPINCTRL_PIN(89, \"GP89_GSPI1_MISO\"),\n\tPINCTRL_PIN(90, \"GP90_GSPI1_MOSI\"),\n\tPINCTRL_PIN(91, \"GP91_UART0_RXD\"),\n\tPINCTRL_PIN(92, \"GP92_UART0_TXD\"),\n\tPINCTRL_PIN(93, \"GP93_UART0_RTSB\"),\n\tPINCTRL_PIN(94, \"GP94_UART0_CTSB\"),\n};\n\nstatic const struct intel_community lptlp_communities[] = {\n\tCOMMUNITY(0, 95),\n};\n\nstatic const struct intel_pinctrl_soc_data lptlp_soc_data = {\n\t.pins\t\t= lptlp_pins,\n\t.npins\t\t= ARRAY_SIZE(lptlp_pins),\n\t.communities\t= lptlp_communities,\n\t.ncommunities\t= ARRAY_SIZE(lptlp_communities),\n};\n\n \n\n#define LP_NUM_GPIO\t95\n\n \n#define LP_ACPI_OWNED\t0x00  \n#define LP_IRQ2IOXAPIC\t0x10  \n#define LP_GC\t\t0x7C  \n#define LP_INT_STAT\t0x80\n#define LP_INT_ENABLE\t0x90\n\n \n#define LP_CONFIG1\t0x100\n#define LP_CONFIG2\t0x104\n\n \n#define OUT_LVL_BIT\tBIT(31)\n#define IN_LVL_BIT\tBIT(30)\n#define TRIG_SEL_BIT\tBIT(4)  \n#define INT_INV_BIT\tBIT(3)  \n#define DIR_BIT\t\tBIT(2)  \n#define USE_SEL_MASK\tGENMASK(1, 0)\t \n#define USE_SEL_NATIVE\t(0 << 0)\n#define USE_SEL_GPIO\t(1 << 0)\n\n \n#define GPINDIS_BIT\tBIT(2)  \n#define GPIWP_MASK\tGENMASK(1, 0)\t \n#define GPIWP_NONE\t0\t\t \n#define GPIWP_DOWN\t1\t\t \n#define GPIWP_UP\t2\t\t \n\n \n\nstatic void __iomem *lp_gpio_reg(struct gpio_chip *chip, unsigned int offset,\n\t\t\t\t int reg)\n{\n\tstruct intel_pinctrl *lg = gpiochip_get_data(chip);\n\tstruct intel_community *comm;\n\tint reg_offset;\n\n\tcomm = intel_get_community(lg, offset);\n\tif (!comm)\n\t\treturn NULL;\n\n\toffset -= comm->pin_base;\n\n\tif (reg == LP_CONFIG1 || reg == LP_CONFIG2)\n\t\t \n\t\treg_offset = offset * 8;\n\telse\n\t\t \n\t\treg_offset = (offset / 32) * 4;\n\n\treturn comm->regs + reg_offset + reg;\n}\n\nstatic bool lp_gpio_acpi_use(struct intel_pinctrl *lg, unsigned int pin)\n{\n\tvoid __iomem *acpi_use;\n\n\tacpi_use = lp_gpio_reg(&lg->chip, pin, LP_ACPI_OWNED);\n\tif (!acpi_use)\n\t\treturn true;\n\n\treturn !(ioread32(acpi_use) & BIT(pin % 32));\n}\n\nstatic bool lp_gpio_ioxapic_use(struct gpio_chip *chip, unsigned int offset)\n{\n\tvoid __iomem *ioxapic_use = lp_gpio_reg(chip, offset, LP_IRQ2IOXAPIC);\n\tu32 value;\n\n\tvalue = ioread32(ioxapic_use);\n\n\tif (offset >= 8 && offset <= 10)\n\t\treturn !!(value & BIT(offset -  8 + 0));\n\tif (offset >= 13 && offset <= 14)\n\t\treturn !!(value & BIT(offset - 13 + 3));\n\tif (offset >= 45 && offset <= 55)\n\t\treturn !!(value & BIT(offset - 45 + 5));\n\n\treturn false;\n}\n\nstatic void lp_pin_dbg_show(struct pinctrl_dev *pctldev, struct seq_file *s,\n\t\t\t    unsigned int pin)\n{\n\tstruct intel_pinctrl *lg = pinctrl_dev_get_drvdata(pctldev);\n\tvoid __iomem *reg = lp_gpio_reg(&lg->chip, pin, LP_CONFIG1);\n\tvoid __iomem *conf2 = lp_gpio_reg(&lg->chip, pin, LP_CONFIG2);\n\tu32 value, mode;\n\n\tvalue = ioread32(reg);\n\n\tmode = value & USE_SEL_MASK;\n\tif (mode == USE_SEL_GPIO)\n\t\tseq_puts(s, \"GPIO \");\n\telse\n\t\tseq_printf(s, \"mode %d \", mode);\n\n\tseq_printf(s, \"0x%08x 0x%08x\", value, ioread32(conf2));\n\n\tif (lp_gpio_acpi_use(lg, pin))\n\t\tseq_puts(s, \" [ACPI]\");\n}\n\nstatic const struct pinctrl_ops lptlp_pinctrl_ops = {\n\t.get_groups_count\t= intel_get_groups_count,\n\t.get_group_name\t\t= intel_get_group_name,\n\t.get_group_pins\t\t= intel_get_group_pins,\n\t.pin_dbg_show\t\t= lp_pin_dbg_show,\n};\n\nstatic int lp_pinmux_set_mux(struct pinctrl_dev *pctldev,\n\t\t\t     unsigned int function, unsigned int group)\n{\n\tstruct intel_pinctrl *lg = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct intel_pingroup *grp = &lg->soc->groups[group];\n\tunsigned long flags;\n\tint i;\n\n\traw_spin_lock_irqsave(&lg->lock, flags);\n\n\t \n\tfor (i = 0; i < grp->grp.npins; i++) {\n\t\tvoid __iomem *reg = lp_gpio_reg(&lg->chip, grp->grp.pins[i], LP_CONFIG1);\n\t\tu32 value;\n\n\t\tvalue = ioread32(reg);\n\n\t\tvalue &= ~USE_SEL_MASK;\n\t\tif (grp->modes)\n\t\t\tvalue |= grp->modes[i];\n\t\telse\n\t\t\tvalue |= grp->mode;\n\n\t\tiowrite32(value, reg);\n\t}\n\n\traw_spin_unlock_irqrestore(&lg->lock, flags);\n\n\treturn 0;\n}\n\nstatic void lp_gpio_enable_input(void __iomem *reg)\n{\n\tiowrite32(ioread32(reg) & ~GPINDIS_BIT, reg);\n}\n\nstatic void lp_gpio_disable_input(void __iomem *reg)\n{\n\tiowrite32(ioread32(reg) | GPINDIS_BIT, reg);\n}\n\nstatic int lp_gpio_request_enable(struct pinctrl_dev *pctldev,\n\t\t\t\t  struct pinctrl_gpio_range *range,\n\t\t\t\t  unsigned int pin)\n{\n\tstruct intel_pinctrl *lg = pinctrl_dev_get_drvdata(pctldev);\n\tvoid __iomem *reg = lp_gpio_reg(&lg->chip, pin, LP_CONFIG1);\n\tvoid __iomem *conf2 = lp_gpio_reg(&lg->chip, pin, LP_CONFIG2);\n\tunsigned long flags;\n\tu32 value;\n\n\tpm_runtime_get(lg->dev);\n\n\traw_spin_lock_irqsave(&lg->lock, flags);\n\n\t \n\tvalue = ioread32(reg);\n\tif ((value & USE_SEL_MASK) != USE_SEL_GPIO) {\n\t\tiowrite32((value & USE_SEL_MASK) | USE_SEL_GPIO, reg);\n\t\tdev_warn(lg->dev, FW_BUG \"pin %u forcibly reconfigured as GPIO\\n\", pin);\n\t}\n\n\t \n\tlp_gpio_enable_input(conf2);\n\n\traw_spin_unlock_irqrestore(&lg->lock, flags);\n\n\treturn 0;\n}\n\nstatic void lp_gpio_disable_free(struct pinctrl_dev *pctldev,\n\t\t\t\t struct pinctrl_gpio_range *range,\n\t\t\t\t unsigned int pin)\n{\n\tstruct intel_pinctrl *lg = pinctrl_dev_get_drvdata(pctldev);\n\tvoid __iomem *conf2 = lp_gpio_reg(&lg->chip, pin, LP_CONFIG2);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&lg->lock, flags);\n\n\t \n\tlp_gpio_disable_input(conf2);\n\n\traw_spin_unlock_irqrestore(&lg->lock, flags);\n\n\tpm_runtime_put(lg->dev);\n}\n\nstatic int lp_gpio_set_direction(struct pinctrl_dev *pctldev,\n\t\t\t\t struct pinctrl_gpio_range *range,\n\t\t\t\t unsigned int pin, bool input)\n{\n\tstruct intel_pinctrl *lg = pinctrl_dev_get_drvdata(pctldev);\n\tvoid __iomem *reg = lp_gpio_reg(&lg->chip, pin, LP_CONFIG1);\n\tunsigned long flags;\n\tu32 value;\n\n\traw_spin_lock_irqsave(&lg->lock, flags);\n\n\tvalue = ioread32(reg);\n\tvalue &= ~DIR_BIT;\n\tif (input) {\n\t\tvalue |= DIR_BIT;\n\t} else {\n\t\t \n\t\tWARN(lp_gpio_ioxapic_use(&lg->chip, pin),\n\t\t     \"Potential Error: Setting GPIO to output with IOxAPIC redirection\");\n\t}\n\tiowrite32(value, reg);\n\n\traw_spin_unlock_irqrestore(&lg->lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct pinmux_ops lptlp_pinmux_ops = {\n\t.get_functions_count\t= intel_get_functions_count,\n\t.get_function_name\t= intel_get_function_name,\n\t.get_function_groups\t= intel_get_function_groups,\n\t.set_mux\t\t= lp_pinmux_set_mux,\n\t.gpio_request_enable\t= lp_gpio_request_enable,\n\t.gpio_disable_free\t= lp_gpio_disable_free,\n\t.gpio_set_direction\t= lp_gpio_set_direction,\n};\n\nstatic int lp_pin_config_get(struct pinctrl_dev *pctldev, unsigned int pin,\n\t\t\t     unsigned long *config)\n{\n\tstruct intel_pinctrl *lg = pinctrl_dev_get_drvdata(pctldev);\n\tvoid __iomem *conf2 = lp_gpio_reg(&lg->chip, pin, LP_CONFIG2);\n\tenum pin_config_param param = pinconf_to_config_param(*config);\n\tunsigned long flags;\n\tu32 value, pull;\n\tu16 arg;\n\n\traw_spin_lock_irqsave(&lg->lock, flags);\n\tvalue = ioread32(conf2);\n\traw_spin_unlock_irqrestore(&lg->lock, flags);\n\n\tpull = value & GPIWP_MASK;\n\n\tswitch (param) {\n\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\tif (pull != GPIWP_NONE)\n\t\t\treturn -EINVAL;\n\t\targ = 0;\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\tif (pull != GPIWP_DOWN)\n\t\t\treturn -EINVAL;\n\n\t\targ = 1;\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\tif (pull != GPIWP_UP)\n\t\t\treturn -EINVAL;\n\n\t\targ = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\t*config = pinconf_to_config_packed(param, arg);\n\n\treturn 0;\n}\n\nstatic int lp_pin_config_set(struct pinctrl_dev *pctldev, unsigned int pin,\n\t\t\t     unsigned long *configs, unsigned int num_configs)\n{\n\tstruct intel_pinctrl *lg = pinctrl_dev_get_drvdata(pctldev);\n\tvoid __iomem *conf2 = lp_gpio_reg(&lg->chip, pin, LP_CONFIG2);\n\tenum pin_config_param param;\n\tunsigned long flags;\n\tint i, ret = 0;\n\tu32 value;\n\n\traw_spin_lock_irqsave(&lg->lock, flags);\n\n\tvalue = ioread32(conf2);\n\n\tfor (i = 0; i < num_configs; i++) {\n\t\tparam = pinconf_to_config_param(configs[i]);\n\n\t\tswitch (param) {\n\t\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\t\tvalue &= ~GPIWP_MASK;\n\t\t\tvalue |= GPIWP_NONE;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\t\tvalue &= ~GPIWP_MASK;\n\t\t\tvalue |= GPIWP_DOWN;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\t\tvalue &= ~GPIWP_MASK;\n\t\t\tvalue |= GPIWP_UP;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -ENOTSUPP;\n\t\t}\n\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tif (!ret)\n\t\tiowrite32(value, conf2);\n\n\traw_spin_unlock_irqrestore(&lg->lock, flags);\n\n\treturn ret;\n}\n\nstatic const struct pinconf_ops lptlp_pinconf_ops = {\n\t.is_generic\t= true,\n\t.pin_config_get\t= lp_pin_config_get,\n\t.pin_config_set\t= lp_pin_config_set,\n};\n\nstatic const struct pinctrl_desc lptlp_pinctrl_desc = {\n\t.pctlops\t= &lptlp_pinctrl_ops,\n\t.pmxops\t\t= &lptlp_pinmux_ops,\n\t.confops\t= &lptlp_pinconf_ops,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int lp_gpio_get(struct gpio_chip *chip, unsigned int offset)\n{\n\tvoid __iomem *reg = lp_gpio_reg(chip, offset, LP_CONFIG1);\n\treturn !!(ioread32(reg) & IN_LVL_BIT);\n}\n\nstatic void lp_gpio_set(struct gpio_chip *chip, unsigned int offset, int value)\n{\n\tstruct intel_pinctrl *lg = gpiochip_get_data(chip);\n\tvoid __iomem *reg = lp_gpio_reg(chip, offset, LP_CONFIG1);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&lg->lock, flags);\n\n\tif (value)\n\t\tiowrite32(ioread32(reg) | OUT_LVL_BIT, reg);\n\telse\n\t\tiowrite32(ioread32(reg) & ~OUT_LVL_BIT, reg);\n\n\traw_spin_unlock_irqrestore(&lg->lock, flags);\n}\n\nstatic int lp_gpio_direction_input(struct gpio_chip *chip, unsigned int offset)\n{\n\treturn pinctrl_gpio_direction_input(chip->base + offset);\n}\n\nstatic int lp_gpio_direction_output(struct gpio_chip *chip, unsigned int offset,\n\t\t\t\t    int value)\n{\n\tlp_gpio_set(chip, offset, value);\n\n\treturn pinctrl_gpio_direction_output(chip->base + offset);\n}\n\nstatic int lp_gpio_get_direction(struct gpio_chip *chip, unsigned int offset)\n{\n\tvoid __iomem *reg = lp_gpio_reg(chip, offset, LP_CONFIG1);\n\n\tif (ioread32(reg) & DIR_BIT)\n\t\treturn GPIO_LINE_DIRECTION_IN;\n\n\treturn GPIO_LINE_DIRECTION_OUT;\n}\n\nstatic void lp_gpio_irq_handler(struct irq_desc *desc)\n{\n\tstruct irq_data *data = irq_desc_get_irq_data(desc);\n\tstruct gpio_chip *gc = irq_desc_get_handler_data(desc);\n\tstruct intel_pinctrl *lg = gpiochip_get_data(gc);\n\tstruct irq_chip *chip = irq_data_get_irq_chip(data);\n\tvoid __iomem *reg, *ena;\n\tunsigned long pending;\n\tu32 base, pin;\n\n\t \n\tfor (base = 0; base < lg->chip.ngpio; base += 32) {\n\t\treg = lp_gpio_reg(&lg->chip, base, LP_INT_STAT);\n\t\tena = lp_gpio_reg(&lg->chip, base, LP_INT_ENABLE);\n\n\t\t \n\t\tpending = ioread32(reg) & ioread32(ena);\n\n\t\tfor_each_set_bit(pin, &pending, 32)\n\t\t\tgeneric_handle_domain_irq(lg->chip.irq.domain, base + pin);\n\t}\n\tchip->irq_eoi(data);\n}\n\nstatic void lp_irq_ack(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct intel_pinctrl *lg = gpiochip_get_data(gc);\n\tirq_hw_number_t hwirq = irqd_to_hwirq(d);\n\tvoid __iomem *reg = lp_gpio_reg(&lg->chip, hwirq, LP_INT_STAT);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&lg->lock, flags);\n\tiowrite32(BIT(hwirq % 32), reg);\n\traw_spin_unlock_irqrestore(&lg->lock, flags);\n}\n\nstatic void lp_irq_unmask(struct irq_data *d)\n{\n}\n\nstatic void lp_irq_mask(struct irq_data *d)\n{\n}\n\nstatic void lp_irq_enable(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct intel_pinctrl *lg = gpiochip_get_data(gc);\n\tirq_hw_number_t hwirq = irqd_to_hwirq(d);\n\tvoid __iomem *reg = lp_gpio_reg(&lg->chip, hwirq, LP_INT_ENABLE);\n\tunsigned long flags;\n\n\tgpiochip_enable_irq(gc, hwirq);\n\n\traw_spin_lock_irqsave(&lg->lock, flags);\n\tiowrite32(ioread32(reg) | BIT(hwirq % 32), reg);\n\traw_spin_unlock_irqrestore(&lg->lock, flags);\n}\n\nstatic void lp_irq_disable(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct intel_pinctrl *lg = gpiochip_get_data(gc);\n\tirq_hw_number_t hwirq = irqd_to_hwirq(d);\n\tvoid __iomem *reg = lp_gpio_reg(&lg->chip, hwirq, LP_INT_ENABLE);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&lg->lock, flags);\n\tiowrite32(ioread32(reg) & ~BIT(hwirq % 32), reg);\n\traw_spin_unlock_irqrestore(&lg->lock, flags);\n\n\tgpiochip_disable_irq(gc, hwirq);\n}\n\nstatic int lp_irq_set_type(struct irq_data *d, unsigned int type)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct intel_pinctrl *lg = gpiochip_get_data(gc);\n\tirq_hw_number_t hwirq = irqd_to_hwirq(d);\n\tunsigned long flags;\n\tvoid __iomem *reg;\n\tu32 value;\n\n\treg = lp_gpio_reg(&lg->chip, hwirq, LP_CONFIG1);\n\tif (!reg)\n\t\treturn -EINVAL;\n\n\t \n\tif (lp_gpio_acpi_use(lg, hwirq)) {\n\t\tdev_err(lg->dev, \"pin %lu can't be used as IRQ\\n\", hwirq);\n\t\treturn -EBUSY;\n\t}\n\n\traw_spin_lock_irqsave(&lg->lock, flags);\n\tvalue = ioread32(reg);\n\n\t \n\tif (type & IRQ_TYPE_EDGE_RISING)\n\t\tvalue &= ~(TRIG_SEL_BIT | INT_INV_BIT);\n\n\t \n\tif (type & IRQ_TYPE_EDGE_FALLING)\n\t\tvalue = (value | INT_INV_BIT) & ~TRIG_SEL_BIT;\n\n\t \n\tif (type & IRQ_TYPE_LEVEL_LOW)\n\t\tvalue = (value | TRIG_SEL_BIT) & ~INT_INV_BIT;\n\n\t \n\tif (type & IRQ_TYPE_LEVEL_HIGH)\n\t\tvalue |= TRIG_SEL_BIT | INT_INV_BIT;\n\n\tiowrite32(value, reg);\n\n\tif (type & IRQ_TYPE_EDGE_BOTH)\n\t\tirq_set_handler_locked(d, handle_edge_irq);\n\telse if (type & IRQ_TYPE_LEVEL_MASK)\n\t\tirq_set_handler_locked(d, handle_level_irq);\n\n\traw_spin_unlock_irqrestore(&lg->lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct irq_chip lp_irqchip = {\n\t.name = \"LP-GPIO\",\n\t.irq_ack = lp_irq_ack,\n\t.irq_mask = lp_irq_mask,\n\t.irq_unmask = lp_irq_unmask,\n\t.irq_enable = lp_irq_enable,\n\t.irq_disable = lp_irq_disable,\n\t.irq_set_type = lp_irq_set_type,\n\t.flags = IRQCHIP_SKIP_SET_WAKE | IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic int lp_gpio_irq_init_hw(struct gpio_chip *chip)\n{\n\tstruct intel_pinctrl *lg = gpiochip_get_data(chip);\n\tvoid __iomem *reg;\n\tunsigned int base;\n\n\tfor (base = 0; base < lg->chip.ngpio; base += 32) {\n\t\t \n\t\treg = lp_gpio_reg(&lg->chip, base, LP_INT_ENABLE);\n\t\tiowrite32(0, reg);\n\t\t \n\t\treg = lp_gpio_reg(&lg->chip, base, LP_INT_STAT);\n\t\tiowrite32(0xffffffff, reg);\n\t}\n\n\treturn 0;\n}\n\nstatic int lp_gpio_add_pin_ranges(struct gpio_chip *chip)\n{\n\tstruct intel_pinctrl *lg = gpiochip_get_data(chip);\n\tstruct device *dev = lg->dev;\n\tint ret;\n\n\tret = gpiochip_add_pin_range(chip, dev_name(dev), 0, 0, lg->soc->npins);\n\tif (ret)\n\t\tdev_err(dev, \"failed to add GPIO pin range\\n\");\n\n\treturn ret;\n}\n\nstatic int lp_gpio_probe(struct platform_device *pdev)\n{\n\tconst struct intel_pinctrl_soc_data *soc;\n\tstruct intel_pinctrl *lg;\n\tstruct gpio_chip *gc;\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *io_rc;\n\tvoid __iomem *regs;\n\tunsigned int i;\n\tint irq, ret;\n\n\tsoc = (const struct intel_pinctrl_soc_data *)device_get_match_data(dev);\n\tif (!soc)\n\t\treturn -ENODEV;\n\n\tlg = devm_kzalloc(dev, sizeof(*lg), GFP_KERNEL);\n\tif (!lg)\n\t\treturn -ENOMEM;\n\n\tlg->dev = dev;\n\tlg->soc = soc;\n\n\tlg->ncommunities = lg->soc->ncommunities;\n\tlg->communities = devm_kcalloc(dev, lg->ncommunities,\n\t\t\t\t       sizeof(*lg->communities), GFP_KERNEL);\n\tif (!lg->communities)\n\t\treturn -ENOMEM;\n\n\tlg->pctldesc           = lptlp_pinctrl_desc;\n\tlg->pctldesc.name      = dev_name(dev);\n\tlg->pctldesc.pins      = lg->soc->pins;\n\tlg->pctldesc.npins     = lg->soc->npins;\n\n\tlg->pctldev = devm_pinctrl_register(dev, &lg->pctldesc, lg);\n\tif (IS_ERR(lg->pctldev)) {\n\t\tdev_err(dev, \"failed to register pinctrl driver\\n\");\n\t\treturn PTR_ERR(lg->pctldev);\n\t}\n\n\tplatform_set_drvdata(pdev, lg);\n\n\tio_rc = platform_get_resource(pdev, IORESOURCE_IO, 0);\n\tif (!io_rc) {\n\t\tdev_err(dev, \"missing IO resources\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tregs = devm_ioport_map(dev, io_rc->start, resource_size(io_rc));\n\tif (!regs) {\n\t\tdev_err(dev, \"failed mapping IO region %pR\\n\", &io_rc);\n\t\treturn -EBUSY;\n\t}\n\n\tfor (i = 0; i < lg->soc->ncommunities; i++) {\n\t\tstruct intel_community *comm = &lg->communities[i];\n\n\t\t*comm = lg->soc->communities[i];\n\n\t\tcomm->regs = regs;\n\t\tcomm->pad_regs = regs + 0x100;\n\t}\n\n\traw_spin_lock_init(&lg->lock);\n\n\tgc = &lg->chip;\n\tgc->label = dev_name(dev);\n\tgc->owner = THIS_MODULE;\n\tgc->request = gpiochip_generic_request;\n\tgc->free = gpiochip_generic_free;\n\tgc->direction_input = lp_gpio_direction_input;\n\tgc->direction_output = lp_gpio_direction_output;\n\tgc->get = lp_gpio_get;\n\tgc->set = lp_gpio_set;\n\tgc->set_config = gpiochip_generic_config;\n\tgc->get_direction = lp_gpio_get_direction;\n\tgc->base = -1;\n\tgc->ngpio = LP_NUM_GPIO;\n\tgc->can_sleep = false;\n\tgc->add_pin_ranges = lp_gpio_add_pin_ranges;\n\tgc->parent = dev;\n\n\t \n\tirq = platform_get_irq_optional(pdev, 0);\n\tif (irq > 0) {\n\t\tstruct gpio_irq_chip *girq;\n\n\t\tgirq = &gc->irq;\n\t\tgpio_irq_chip_set_chip(girq, &lp_irqchip);\n\t\tgirq->init_hw = lp_gpio_irq_init_hw;\n\t\tgirq->parent_handler = lp_gpio_irq_handler;\n\t\tgirq->num_parents = 1;\n\t\tgirq->parents = devm_kcalloc(dev, girq->num_parents,\n\t\t\t\t\t     sizeof(*girq->parents),\n\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!girq->parents)\n\t\t\treturn -ENOMEM;\n\t\tgirq->parents[0] = irq;\n\t\tgirq->default_type = IRQ_TYPE_NONE;\n\t\tgirq->handler = handle_bad_irq;\n\t}\n\n\tret = devm_gpiochip_add_data(dev, gc, lg);\n\tif (ret) {\n\t\tdev_err(dev, \"failed adding lp-gpio chip\\n\");\n\t\treturn ret;\n\t}\n\n\tpm_runtime_enable(dev);\n\n\treturn 0;\n}\n\nstatic int lp_gpio_remove(struct platform_device *pdev)\n{\n\tpm_runtime_disable(&pdev->dev);\n\treturn 0;\n}\n\nstatic int lp_gpio_runtime_suspend(struct device *dev)\n{\n\treturn 0;\n}\n\nstatic int lp_gpio_runtime_resume(struct device *dev)\n{\n\treturn 0;\n}\n\nstatic int lp_gpio_resume(struct device *dev)\n{\n\tstruct intel_pinctrl *lg = dev_get_drvdata(dev);\n\tstruct gpio_chip *chip = &lg->chip;\n\tconst char *dummy;\n\tint i;\n\n\t \n\tfor_each_requested_gpio(chip, i, dummy)\n\t\tlp_gpio_enable_input(lp_gpio_reg(chip, i, LP_CONFIG2));\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops lp_gpio_pm_ops = {\n\tSYSTEM_SLEEP_PM_OPS(NULL, lp_gpio_resume)\n\tRUNTIME_PM_OPS(lp_gpio_runtime_suspend, lp_gpio_runtime_resume, NULL)\n};\n\nstatic const struct acpi_device_id lynxpoint_gpio_acpi_match[] = {\n\t{ \"INT33C7\", (kernel_ulong_t)&lptlp_soc_data },\n\t{ \"INT3437\", (kernel_ulong_t)&lptlp_soc_data },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, lynxpoint_gpio_acpi_match);\n\nstatic struct platform_driver lp_gpio_driver = {\n\t.probe          = lp_gpio_probe,\n\t.remove         = lp_gpio_remove,\n\t.driver         = {\n\t\t.name   = \"lp_gpio\",\n\t\t.pm\t= pm_ptr(&lp_gpio_pm_ops),\n\t\t.acpi_match_table = lynxpoint_gpio_acpi_match,\n\t},\n};\n\nstatic int __init lp_gpio_init(void)\n{\n\treturn platform_driver_register(&lp_gpio_driver);\n}\nsubsys_initcall(lp_gpio_init);\n\nstatic void __exit lp_gpio_exit(void)\n{\n\tplatform_driver_unregister(&lp_gpio_driver);\n}\nmodule_exit(lp_gpio_exit);\n\nMODULE_AUTHOR(\"Mathias Nyman (Intel)\");\nMODULE_AUTHOR(\"Andy Shevchenko (Intel)\");\nMODULE_DESCRIPTION(\"Intel Lynxpoint pinctrl driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:lp_gpio\");\nMODULE_IMPORT_NS(PINCTRL_INTEL);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}