{
  "module_name": "pinctrl-rockchip.c",
  "hash_id": "6992ab0a7b0b7e53da4698370194df955b5061ac6c4c700a2e3a2d9fe24e5f68",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/pinctrl-rockchip.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/io.h>\n#include <linux/bitops.h>\n#include <linux/gpio/driver.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/pinctrl/machine.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinmux.h>\n#include <linux/pinctrl/pinconf-generic.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/clk.h>\n#include <linux/regmap.h>\n#include <linux/mfd/syscon.h>\n#include <linux/string_helpers.h>\n\n#include <dt-bindings/pinctrl/rockchip.h>\n\n#include \"core.h\"\n#include \"pinconf.h\"\n#include \"pinctrl-rockchip.h\"\n\n \n#define WRITE_MASK_VAL(h, l, v) \\\n\t(GENMASK(((h) + 16), ((l) + 16)) | (((v) << (l)) & GENMASK((h), (l))))\n\n \n#define IOMUX_GPIO_ONLY\t\tBIT(0)\n#define IOMUX_WIDTH_4BIT\tBIT(1)\n#define IOMUX_SOURCE_PMU\tBIT(2)\n#define IOMUX_UNROUTED\t\tBIT(3)\n#define IOMUX_WIDTH_3BIT\tBIT(4)\n#define IOMUX_WIDTH_2BIT\tBIT(5)\n#define IOMUX_L_SOURCE_PMU\tBIT(6)\n\n#define PIN_BANK(id, pins, label)\t\t\t\\\n\t{\t\t\t\t\t\t\\\n\t\t.bank_num\t= id,\t\t\t\\\n\t\t.nr_pins\t= pins,\t\t\t\\\n\t\t.name\t\t= label,\t\t\\\n\t\t.iomux\t\t= {\t\t\t\\\n\t\t\t{ .offset = -1 },\t\t\\\n\t\t\t{ .offset = -1 },\t\t\\\n\t\t\t{ .offset = -1 },\t\t\\\n\t\t\t{ .offset = -1 },\t\t\\\n\t\t},\t\t\t\t\t\\\n\t}\n\n#define PIN_BANK_IOMUX_FLAGS(id, pins, label, iom0, iom1, iom2, iom3)\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.bank_num\t= id,\t\t\t\t\t\\\n\t\t.nr_pins\t= pins,\t\t\t\t\t\\\n\t\t.name\t\t= label,\t\t\t\t\\\n\t\t.iomux\t\t= {\t\t\t\t\t\\\n\t\t\t{ .type = iom0, .offset = -1 },\t\t\t\\\n\t\t\t{ .type = iom1, .offset = -1 },\t\t\t\\\n\t\t\t{ .type = iom2, .offset = -1 },\t\t\t\\\n\t\t\t{ .type = iom3, .offset = -1 },\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t}\n\n#define PIN_BANK_DRV_FLAGS(id, pins, label, type0, type1, type2, type3) \\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.bank_num\t= id,\t\t\t\t\t\\\n\t\t.nr_pins\t= pins,\t\t\t\t\t\\\n\t\t.name\t\t= label,\t\t\t\t\\\n\t\t.iomux\t\t= {\t\t\t\t\t\\\n\t\t\t{ .offset = -1 },\t\t\t\t\\\n\t\t\t{ .offset = -1 },\t\t\t\t\\\n\t\t\t{ .offset = -1 },\t\t\t\t\\\n\t\t\t{ .offset = -1 },\t\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t\t.drv\t\t= {\t\t\t\t\t\\\n\t\t\t{ .drv_type = type0, .offset = -1 },\t\t\\\n\t\t\t{ .drv_type = type1, .offset = -1 },\t\t\\\n\t\t\t{ .drv_type = type2, .offset = -1 },\t\t\\\n\t\t\t{ .drv_type = type3, .offset = -1 },\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t}\n\n#define PIN_BANK_IOMUX_FLAGS_PULL_FLAGS(id, pins, label, iom0, iom1,\t\\\n\t\t\t\t\tiom2, iom3, pull0, pull1,\t\\\n\t\t\t\t\tpull2, pull3)\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.bank_num\t= id,\t\t\t\t\t\\\n\t\t.nr_pins\t= pins,\t\t\t\t\t\\\n\t\t.name\t\t= label,\t\t\t\t\\\n\t\t.iomux\t\t= {\t\t\t\t\t\\\n\t\t\t{ .type = iom0, .offset = -1 },\t\t\t\\\n\t\t\t{ .type = iom1, .offset = -1 },\t\t\t\\\n\t\t\t{ .type = iom2, .offset = -1 },\t\t\t\\\n\t\t\t{ .type = iom3, .offset = -1 },\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t\t.pull_type[0] = pull0,\t\t\t\t\t\\\n\t\t.pull_type[1] = pull1,\t\t\t\t\t\\\n\t\t.pull_type[2] = pull2,\t\t\t\t\t\\\n\t\t.pull_type[3] = pull3,\t\t\t\t\t\\\n\t}\n\n#define PIN_BANK_DRV_FLAGS_PULL_FLAGS(id, pins, label, drv0, drv1,\t\\\n\t\t\t\t      drv2, drv3, pull0, pull1,\t\t\\\n\t\t\t\t      pull2, pull3)\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.bank_num\t= id,\t\t\t\t\t\\\n\t\t.nr_pins\t= pins,\t\t\t\t\t\\\n\t\t.name\t\t= label,\t\t\t\t\\\n\t\t.iomux\t\t= {\t\t\t\t\t\\\n\t\t\t{ .offset = -1 },\t\t\t\t\\\n\t\t\t{ .offset = -1 },\t\t\t\t\\\n\t\t\t{ .offset = -1 },\t\t\t\t\\\n\t\t\t{ .offset = -1 },\t\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t\t.drv\t\t= {\t\t\t\t\t\\\n\t\t\t{ .drv_type = drv0, .offset = -1 },\t\t\\\n\t\t\t{ .drv_type = drv1, .offset = -1 },\t\t\\\n\t\t\t{ .drv_type = drv2, .offset = -1 },\t\t\\\n\t\t\t{ .drv_type = drv3, .offset = -1 },\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t\t.pull_type[0] = pull0,\t\t\t\t\t\\\n\t\t.pull_type[1] = pull1,\t\t\t\t\t\\\n\t\t.pull_type[2] = pull2,\t\t\t\t\t\\\n\t\t.pull_type[3] = pull3,\t\t\t\t\t\\\n\t}\n\n#define PIN_BANK_IOMUX_FLAGS_OFFSET(id, pins, label, iom0, iom1, iom2,\t\\\n\t\t\t\t    iom3, offset0, offset1, offset2,\t\\\n\t\t\t\t    offset3)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.bank_num\t= id,\t\t\t\t\t\\\n\t\t.nr_pins\t= pins,\t\t\t\t\t\\\n\t\t.name\t\t= label,\t\t\t\t\\\n\t\t.iomux\t\t= {\t\t\t\t\t\\\n\t\t\t{ .type = iom0, .offset = offset0 },\t\t\\\n\t\t\t{ .type = iom1, .offset = offset1 },\t\t\\\n\t\t\t{ .type = iom2, .offset = offset2 },\t\t\\\n\t\t\t{ .type = iom3, .offset = offset3 },\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t}\n\n#define PIN_BANK_IOMUX_DRV_FLAGS_OFFSET(id, pins, label, iom0, iom1,\t\\\n\t\t\t\t\tiom2, iom3, drv0, drv1, drv2,\t\\\n\t\t\t\t\tdrv3, offset0, offset1,\t\t\\\n\t\t\t\t\toffset2, offset3)\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.bank_num\t= id,\t\t\t\t\t\\\n\t\t.nr_pins\t= pins,\t\t\t\t\t\\\n\t\t.name\t\t= label,\t\t\t\t\\\n\t\t.iomux\t\t= {\t\t\t\t\t\\\n\t\t\t{ .type = iom0, .offset = -1 },\t\t\t\\\n\t\t\t{ .type = iom1, .offset = -1 },\t\t\t\\\n\t\t\t{ .type = iom2, .offset = -1 },\t\t\t\\\n\t\t\t{ .type = iom3, .offset = -1 },\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t\t.drv\t\t= {\t\t\t\t\t\\\n\t\t\t{ .drv_type = drv0, .offset = offset0 },\t\\\n\t\t\t{ .drv_type = drv1, .offset = offset1 },\t\\\n\t\t\t{ .drv_type = drv2, .offset = offset2 },\t\\\n\t\t\t{ .drv_type = drv3, .offset = offset3 },\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t}\n\n#define PIN_BANK_IOMUX_FLAGS_DRV_FLAGS_OFFSET_PULL_FLAGS(id, pins,\t\\\n\t\t\t\t\t      label, iom0, iom1, iom2,  \\\n\t\t\t\t\t      iom3, drv0, drv1, drv2,   \\\n\t\t\t\t\t      drv3, offset0, offset1,   \\\n\t\t\t\t\t      offset2, offset3, pull0,  \\\n\t\t\t\t\t      pull1, pull2, pull3)\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.bank_num\t= id,\t\t\t\t\t\\\n\t\t.nr_pins\t= pins,\t\t\t\t\t\\\n\t\t.name\t\t= label,\t\t\t\t\\\n\t\t.iomux\t\t= {\t\t\t\t\t\\\n\t\t\t{ .type = iom0, .offset = -1 },\t\t\t\\\n\t\t\t{ .type = iom1, .offset = -1 },\t\t\t\\\n\t\t\t{ .type = iom2, .offset = -1 },\t\t\t\\\n\t\t\t{ .type = iom3, .offset = -1 },\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t\t.drv\t\t= {\t\t\t\t\t\\\n\t\t\t{ .drv_type = drv0, .offset = offset0 },\t\\\n\t\t\t{ .drv_type = drv1, .offset = offset1 },\t\\\n\t\t\t{ .drv_type = drv2, .offset = offset2 },\t\\\n\t\t\t{ .drv_type = drv3, .offset = offset3 },\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t\t.pull_type[0] = pull0,\t\t\t\t\t\\\n\t\t.pull_type[1] = pull1,\t\t\t\t\t\\\n\t\t.pull_type[2] = pull2,\t\t\t\t\t\\\n\t\t.pull_type[3] = pull3,\t\t\t\t\t\\\n\t}\n\n#define PIN_BANK_MUX_ROUTE_FLAGS(ID, PIN, FUNC, REG, VAL, FLAG)\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.bank_num\t= ID,\t\t\t\t\t\\\n\t\t.pin\t\t= PIN,\t\t\t\t\t\\\n\t\t.func\t\t= FUNC,\t\t\t\t\t\\\n\t\t.route_offset\t= REG,\t\t\t\t\t\\\n\t\t.route_val\t= VAL,\t\t\t\t\t\\\n\t\t.route_location\t= FLAG,\t\t\t\t\t\\\n\t}\n\n#define RK_MUXROUTE_SAME(ID, PIN, FUNC, REG, VAL)\t\\\n\tPIN_BANK_MUX_ROUTE_FLAGS(ID, PIN, FUNC, REG, VAL, ROCKCHIP_ROUTE_SAME)\n\n#define RK_MUXROUTE_GRF(ID, PIN, FUNC, REG, VAL)\t\\\n\tPIN_BANK_MUX_ROUTE_FLAGS(ID, PIN, FUNC, REG, VAL, ROCKCHIP_ROUTE_GRF)\n\n#define RK_MUXROUTE_PMU(ID, PIN, FUNC, REG, VAL)\t\\\n\tPIN_BANK_MUX_ROUTE_FLAGS(ID, PIN, FUNC, REG, VAL, ROCKCHIP_ROUTE_PMU)\n\n#define RK3588_PIN_BANK_FLAGS(ID, PIN, LABEL, M, P)\t\t\t\\\n\tPIN_BANK_IOMUX_FLAGS_PULL_FLAGS(ID, PIN, LABEL, M, M, M, M, P, P, P, P)\n\nstatic struct regmap_config rockchip_regmap_config = {\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n};\n\nstatic inline const struct rockchip_pin_group *pinctrl_name_to_group(\n\t\t\t\t\tconst struct rockchip_pinctrl *info,\n\t\t\t\t\tconst char *name)\n{\n\tint i;\n\n\tfor (i = 0; i < info->ngroups; i++) {\n\t\tif (!strcmp(info->groups[i].name, name))\n\t\t\treturn &info->groups[i];\n\t}\n\n\treturn NULL;\n}\n\n \nstatic struct rockchip_pin_bank *pin_to_bank(struct rockchip_pinctrl *info,\n\t\t\t\t\t\t\t\tunsigned pin)\n{\n\tstruct rockchip_pin_bank *b = info->ctrl->pin_banks;\n\n\twhile (pin >= (b->pin_base + b->nr_pins))\n\t\tb++;\n\n\treturn b;\n}\n\nstatic struct rockchip_pin_bank *bank_num_to_bank(\n\t\t\t\t\tstruct rockchip_pinctrl *info,\n\t\t\t\t\tunsigned num)\n{\n\tstruct rockchip_pin_bank *b = info->ctrl->pin_banks;\n\tint i;\n\n\tfor (i = 0; i < info->ctrl->nr_banks; i++, b++) {\n\t\tif (b->bank_num == num)\n\t\t\treturn b;\n\t}\n\n\treturn ERR_PTR(-EINVAL);\n}\n\n \n\nstatic int rockchip_get_groups_count(struct pinctrl_dev *pctldev)\n{\n\tstruct rockchip_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn info->ngroups;\n}\n\nstatic const char *rockchip_get_group_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t\t\tunsigned selector)\n{\n\tstruct rockchip_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn info->groups[selector].name;\n}\n\nstatic int rockchip_get_group_pins(struct pinctrl_dev *pctldev,\n\t\t\t\t      unsigned selector, const unsigned **pins,\n\t\t\t\t      unsigned *npins)\n{\n\tstruct rockchip_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\n\n\tif (selector >= info->ngroups)\n\t\treturn -EINVAL;\n\n\t*pins = info->groups[selector].pins;\n\t*npins = info->groups[selector].npins;\n\n\treturn 0;\n}\n\nstatic int rockchip_dt_node_to_map(struct pinctrl_dev *pctldev,\n\t\t\t\t struct device_node *np,\n\t\t\t\t struct pinctrl_map **map, unsigned *num_maps)\n{\n\tstruct rockchip_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct rockchip_pin_group *grp;\n\tstruct device *dev = info->dev;\n\tstruct pinctrl_map *new_map;\n\tstruct device_node *parent;\n\tint map_num = 1;\n\tint i;\n\n\t \n\tgrp = pinctrl_name_to_group(info, np->name);\n\tif (!grp) {\n\t\tdev_err(dev, \"unable to find group for node %pOFn\\n\", np);\n\t\treturn -EINVAL;\n\t}\n\n\tmap_num += grp->npins;\n\n\tnew_map = kcalloc(map_num, sizeof(*new_map), GFP_KERNEL);\n\tif (!new_map)\n\t\treturn -ENOMEM;\n\n\t*map = new_map;\n\t*num_maps = map_num;\n\n\t \n\tparent = of_get_parent(np);\n\tif (!parent) {\n\t\tkfree(new_map);\n\t\treturn -EINVAL;\n\t}\n\tnew_map[0].type = PIN_MAP_TYPE_MUX_GROUP;\n\tnew_map[0].data.mux.function = parent->name;\n\tnew_map[0].data.mux.group = np->name;\n\tof_node_put(parent);\n\n\t \n\tnew_map++;\n\tfor (i = 0; i < grp->npins; i++) {\n\t\tnew_map[i].type = PIN_MAP_TYPE_CONFIGS_PIN;\n\t\tnew_map[i].data.configs.group_or_pin =\n\t\t\t\tpin_get_name(pctldev, grp->pins[i]);\n\t\tnew_map[i].data.configs.configs = grp->data[i].configs;\n\t\tnew_map[i].data.configs.num_configs = grp->data[i].nconfigs;\n\t}\n\n\tdev_dbg(dev, \"maps: function %s group %s num %d\\n\",\n\t\t(*map)->data.mux.function, (*map)->data.mux.group, map_num);\n\n\treturn 0;\n}\n\nstatic void rockchip_dt_free_map(struct pinctrl_dev *pctldev,\n\t\t\t\t    struct pinctrl_map *map, unsigned num_maps)\n{\n\tkfree(map);\n}\n\nstatic const struct pinctrl_ops rockchip_pctrl_ops = {\n\t.get_groups_count\t= rockchip_get_groups_count,\n\t.get_group_name\t\t= rockchip_get_group_name,\n\t.get_group_pins\t\t= rockchip_get_group_pins,\n\t.dt_node_to_map\t\t= rockchip_dt_node_to_map,\n\t.dt_free_map\t\t= rockchip_dt_free_map,\n};\n\n \n\nstatic struct rockchip_mux_recalced_data rv1108_mux_recalced_data[] = {\n\t{\n\t\t.num = 1,\n\t\t.pin = 0,\n\t\t.reg = 0x418,\n\t\t.bit = 0,\n\t\t.mask = 0x3\n\t}, {\n\t\t.num = 1,\n\t\t.pin = 1,\n\t\t.reg = 0x418,\n\t\t.bit = 2,\n\t\t.mask = 0x3\n\t}, {\n\t\t.num = 1,\n\t\t.pin = 2,\n\t\t.reg = 0x418,\n\t\t.bit = 4,\n\t\t.mask = 0x3\n\t}, {\n\t\t.num = 1,\n\t\t.pin = 3,\n\t\t.reg = 0x418,\n\t\t.bit = 6,\n\t\t.mask = 0x3\n\t}, {\n\t\t.num = 1,\n\t\t.pin = 4,\n\t\t.reg = 0x418,\n\t\t.bit = 8,\n\t\t.mask = 0x3\n\t}, {\n\t\t.num = 1,\n\t\t.pin = 5,\n\t\t.reg = 0x418,\n\t\t.bit = 10,\n\t\t.mask = 0x3\n\t}, {\n\t\t.num = 1,\n\t\t.pin = 6,\n\t\t.reg = 0x418,\n\t\t.bit = 12,\n\t\t.mask = 0x3\n\t}, {\n\t\t.num = 1,\n\t\t.pin = 7,\n\t\t.reg = 0x418,\n\t\t.bit = 14,\n\t\t.mask = 0x3\n\t}, {\n\t\t.num = 1,\n\t\t.pin = 8,\n\t\t.reg = 0x41c,\n\t\t.bit = 0,\n\t\t.mask = 0x3\n\t}, {\n\t\t.num = 1,\n\t\t.pin = 9,\n\t\t.reg = 0x41c,\n\t\t.bit = 2,\n\t\t.mask = 0x3\n\t},\n};\n\nstatic struct rockchip_mux_recalced_data rv1126_mux_recalced_data[] = {\n\t{\n\t\t.num = 0,\n\t\t.pin = 20,\n\t\t.reg = 0x10000,\n\t\t.bit = 0,\n\t\t.mask = 0xf\n\t},\n\t{\n\t\t.num = 0,\n\t\t.pin = 21,\n\t\t.reg = 0x10000,\n\t\t.bit = 4,\n\t\t.mask = 0xf\n\t},\n\t{\n\t\t.num = 0,\n\t\t.pin = 22,\n\t\t.reg = 0x10000,\n\t\t.bit = 8,\n\t\t.mask = 0xf\n\t},\n\t{\n\t\t.num = 0,\n\t\t.pin = 23,\n\t\t.reg = 0x10000,\n\t\t.bit = 12,\n\t\t.mask = 0xf\n\t},\n};\n\nstatic  struct rockchip_mux_recalced_data rk3128_mux_recalced_data[] = {\n\t{\n\t\t.num = 2,\n\t\t.pin = 20,\n\t\t.reg = 0xe8,\n\t\t.bit = 0,\n\t\t.mask = 0x7\n\t}, {\n\t\t.num = 2,\n\t\t.pin = 21,\n\t\t.reg = 0xe8,\n\t\t.bit = 4,\n\t\t.mask = 0x7\n\t}, {\n\t\t.num = 2,\n\t\t.pin = 22,\n\t\t.reg = 0xe8,\n\t\t.bit = 8,\n\t\t.mask = 0x7\n\t}, {\n\t\t.num = 2,\n\t\t.pin = 23,\n\t\t.reg = 0xe8,\n\t\t.bit = 12,\n\t\t.mask = 0x7\n\t}, {\n\t\t.num = 2,\n\t\t.pin = 24,\n\t\t.reg = 0xd4,\n\t\t.bit = 12,\n\t\t.mask = 0x7\n\t},\n};\n\nstatic struct rockchip_mux_recalced_data rk3308_mux_recalced_data[] = {\n\t{\n\t\t \n\t\t.num = 1,\n\t\t.pin = 14,\n\t\t.reg = 0x28,\n\t\t.bit = 12,\n\t\t.mask = 0xf\n\t}, {\n\t\t \n\t\t.num = 1,\n\t\t.pin = 15,\n\t\t.reg = 0x2c,\n\t\t.bit = 0,\n\t\t.mask = 0x3\n\t}, {\n\t\t \n\t\t.num = 1,\n\t\t.pin = 18,\n\t\t.reg = 0x30,\n\t\t.bit = 4,\n\t\t.mask = 0xf\n\t}, {\n\t\t \n\t\t.num = 1,\n\t\t.pin = 19,\n\t\t.reg = 0x30,\n\t\t.bit = 8,\n\t\t.mask = 0xf\n\t}, {\n\t\t \n\t\t.num = 1,\n\t\t.pin = 20,\n\t\t.reg = 0x30,\n\t\t.bit = 12,\n\t\t.mask = 0xf\n\t}, {\n\t\t \n\t\t.num = 1,\n\t\t.pin = 21,\n\t\t.reg = 0x34,\n\t\t.bit = 0,\n\t\t.mask = 0xf\n\t}, {\n\t\t \n\t\t.num = 1,\n\t\t.pin = 22,\n\t\t.reg = 0x34,\n\t\t.bit = 4,\n\t\t.mask = 0xf\n\t}, {\n\t\t \n\t\t.num = 1,\n\t\t.pin = 23,\n\t\t.reg = 0x34,\n\t\t.bit = 8,\n\t\t.mask = 0xf\n\t}, {\n\t\t \n\t\t.num = 2,\n\t\t.pin = 2,\n\t\t.reg = 0x40,\n\t\t.bit = 4,\n\t\t.mask = 0x3\n\t}, {\n\t\t \n\t\t.num = 2,\n\t\t.pin = 3,\n\t\t.reg = 0x40,\n\t\t.bit = 6,\n\t\t.mask = 0x3\n\t}, {\n\t\t \n\t\t.num = 2,\n\t\t.pin = 16,\n\t\t.reg = 0x50,\n\t\t.bit = 0,\n\t\t.mask = 0x3\n\t}, {\n\t\t \n\t\t.num = 3,\n\t\t.pin = 10,\n\t\t.reg = 0x68,\n\t\t.bit = 4,\n\t\t.mask = 0x3\n\t}, {\n\t\t \n\t\t.num = 3,\n\t\t.pin = 11,\n\t\t.reg = 0x68,\n\t\t.bit = 6,\n\t\t.mask = 0x3\n\t}, {\n\t\t \n\t\t.num = 3,\n\t\t.pin = 12,\n\t\t.reg = 0x68,\n\t\t.bit = 8,\n\t\t.mask = 0xf\n\t}, {\n\t\t \n\t\t.num = 3,\n\t\t.pin = 13,\n\t\t.reg = 0x68,\n\t\t.bit = 12,\n\t\t.mask = 0xf\n\t},\n};\n\nstatic struct rockchip_mux_recalced_data rk3328_mux_recalced_data[] = {\n\t{\n\t\t.num = 2,\n\t\t.pin = 12,\n\t\t.reg = 0x24,\n\t\t.bit = 8,\n\t\t.mask = 0x3\n\t}, {\n\t\t.num = 2,\n\t\t.pin = 15,\n\t\t.reg = 0x28,\n\t\t.bit = 0,\n\t\t.mask = 0x7\n\t}, {\n\t\t.num = 2,\n\t\t.pin = 23,\n\t\t.reg = 0x30,\n\t\t.bit = 14,\n\t\t.mask = 0x3\n\t},\n};\n\nstatic void rockchip_get_recalced_mux(struct rockchip_pin_bank *bank, int pin,\n\t\t\t\t      int *reg, u8 *bit, int *mask)\n{\n\tstruct rockchip_pinctrl *info = bank->drvdata;\n\tstruct rockchip_pin_ctrl *ctrl = info->ctrl;\n\tstruct rockchip_mux_recalced_data *data;\n\tint i;\n\n\tfor (i = 0; i < ctrl->niomux_recalced; i++) {\n\t\tdata = &ctrl->iomux_recalced[i];\n\t\tif (data->num == bank->bank_num &&\n\t\t    data->pin == pin)\n\t\t\tbreak;\n\t}\n\n\tif (i >= ctrl->niomux_recalced)\n\t\treturn;\n\n\t*reg = data->reg;\n\t*mask = data->mask;\n\t*bit = data->bit;\n}\n\nstatic struct rockchip_mux_route_data px30_mux_route_data[] = {\n\tRK_MUXROUTE_SAME(2, RK_PB4, 1, 0x184, BIT(16 + 7)),  \n\tRK_MUXROUTE_SAME(3, RK_PA1, 3, 0x184, BIT(16 + 7) | BIT(7)),  \n\tRK_MUXROUTE_SAME(2, RK_PB6, 1, 0x184, BIT(16 + 7)),  \n\tRK_MUXROUTE_SAME(3, RK_PA2, 3, 0x184, BIT(16 + 7) | BIT(7)),  \n\tRK_MUXROUTE_SAME(2, RK_PA0, 1, 0x184, BIT(16 + 7)),  \n\tRK_MUXROUTE_SAME(3, RK_PA3, 3, 0x184, BIT(16 + 7) | BIT(7)),  \n\tRK_MUXROUTE_SAME(2, RK_PA1, 1, 0x184, BIT(16 + 7)),  \n\tRK_MUXROUTE_SAME(3, RK_PA5, 3, 0x184, BIT(16 + 7) | BIT(7)),  \n\tRK_MUXROUTE_SAME(2, RK_PA2, 1, 0x184, BIT(16 + 7)),  \n\tRK_MUXROUTE_SAME(3, RK_PA7, 3, 0x184, BIT(16 + 7) | BIT(7)),  \n\tRK_MUXROUTE_SAME(2, RK_PA3, 1, 0x184, BIT(16 + 7)),  \n\tRK_MUXROUTE_SAME(3, RK_PB0, 3, 0x184, BIT(16 + 7) | BIT(7)),  \n\tRK_MUXROUTE_SAME(2, RK_PA4, 1, 0x184, BIT(16 + 7)),  \n\tRK_MUXROUTE_SAME(3, RK_PB1, 3, 0x184, BIT(16 + 7) | BIT(7)),  \n\tRK_MUXROUTE_SAME(2, RK_PA5, 1, 0x184, BIT(16 + 7)),  \n\tRK_MUXROUTE_SAME(3, RK_PB4, 3, 0x184, BIT(16 + 7) | BIT(7)),  \n\tRK_MUXROUTE_SAME(2, RK_PA6, 1, 0x184, BIT(16 + 7)),  \n\tRK_MUXROUTE_SAME(3, RK_PB6, 3, 0x184, BIT(16 + 7) | BIT(7)),  \n\tRK_MUXROUTE_SAME(2, RK_PA7, 1, 0x184, BIT(16 + 7)),  \n\tRK_MUXROUTE_SAME(3, RK_PB7, 3, 0x184, BIT(16 + 7) | BIT(7)),  \n\tRK_MUXROUTE_SAME(2, RK_PB7, 1, 0x184, BIT(16 + 7)),  \n\tRK_MUXROUTE_SAME(3, RK_PC6, 3, 0x184, BIT(16 + 7) | BIT(7)),  \n\tRK_MUXROUTE_SAME(2, RK_PC0, 1, 0x184, BIT(16 + 7)),  \n\tRK_MUXROUTE_SAME(3, RK_PC7, 3, 0x184, BIT(16 + 7) | BIT(7)),  \n\tRK_MUXROUTE_SAME(2, RK_PB0, 1, 0x184, BIT(16 + 7)),  \n\tRK_MUXROUTE_SAME(3, RK_PD1, 3, 0x184, BIT(16 + 7) | BIT(7)),  \n\tRK_MUXROUTE_SAME(2, RK_PB1, 1, 0x184, BIT(16 + 7)),  \n\tRK_MUXROUTE_SAME(3, RK_PD2, 3, 0x184, BIT(16 + 7) | BIT(7)),  \n\tRK_MUXROUTE_SAME(2, RK_PB2, 1, 0x184, BIT(16 + 7)),  \n\tRK_MUXROUTE_SAME(3, RK_PD3, 3, 0x184, BIT(16 + 7) | BIT(7)),  \n\tRK_MUXROUTE_SAME(2, RK_PB3, 1, 0x184, BIT(16 + 7)),  \n\tRK_MUXROUTE_SAME(3, RK_PD0, 3, 0x184, BIT(16 + 7) | BIT(7)),  \n\tRK_MUXROUTE_SAME(3, RK_PC6, 2, 0x184, BIT(16 + 8)),  \n\tRK_MUXROUTE_SAME(2, RK_PC6, 1, 0x184, BIT(16 + 8) | BIT(8)),  \n\tRK_MUXROUTE_SAME(3, RK_PD3, 2, 0x184, BIT(16 + 8)),  \n\tRK_MUXROUTE_SAME(2, RK_PC5, 2, 0x184, BIT(16 + 8) | BIT(8)),  \n\tRK_MUXROUTE_SAME(1, RK_PD3, 2, 0x184, BIT(16 + 10)),  \n\tRK_MUXROUTE_SAME(2, RK_PB6, 2, 0x184, BIT(16 + 10) | BIT(10)),  \n\tRK_MUXROUTE_SAME(1, RK_PD2, 2, 0x184, BIT(16 + 10)),  \n\tRK_MUXROUTE_SAME(2, RK_PB4, 2, 0x184, BIT(16 + 10) | BIT(10)),  \n\tRK_MUXROUTE_SAME(0, RK_PC1, 2, 0x184, BIT(16 + 9)),  \n\tRK_MUXROUTE_SAME(1, RK_PB7, 2, 0x184, BIT(16 + 9) | BIT(9)),  \n\tRK_MUXROUTE_SAME(0, RK_PC0, 2, 0x184, BIT(16 + 9)),  \n\tRK_MUXROUTE_SAME(1, RK_PB6, 2, 0x184, BIT(16 + 9) | BIT(9)),  \n\tRK_MUXROUTE_SAME(0, RK_PC2, 2, 0x184, BIT(16 + 9)),  \n\tRK_MUXROUTE_SAME(1, RK_PB4, 2, 0x184, BIT(16 + 9) | BIT(9)),  \n\tRK_MUXROUTE_SAME(0, RK_PC3, 2, 0x184, BIT(16 + 9)),  \n\tRK_MUXROUTE_SAME(1, RK_PB5, 2, 0x184, BIT(16 + 9) | BIT(9)),  \n};\n\nstatic struct rockchip_mux_route_data rv1126_mux_route_data[] = {\n\tRK_MUXROUTE_GRF(3, RK_PD2, 1, 0x10260, WRITE_MASK_VAL(0, 0, 0)),  \n\tRK_MUXROUTE_GRF(3, RK_PB0, 3, 0x10260, WRITE_MASK_VAL(0, 0, 1)),  \n\n\tRK_MUXROUTE_GRF(0, RK_PD4, 4, 0x10260, WRITE_MASK_VAL(3, 2, 0)),  \n\tRK_MUXROUTE_GRF(1, RK_PD5, 2, 0x10260, WRITE_MASK_VAL(3, 2, 1)),  \n\tRK_MUXROUTE_GRF(2, RK_PC7, 6, 0x10260, WRITE_MASK_VAL(3, 2, 2)),  \n\n\tRK_MUXROUTE_GRF(1, RK_PD0, 1, 0x10260, WRITE_MASK_VAL(4, 4, 0)),  \n\tRK_MUXROUTE_GRF(2, RK_PB3, 2, 0x10260, WRITE_MASK_VAL(4, 4, 1)),  \n\n\tRK_MUXROUTE_GRF(3, RK_PD4, 2, 0x10260, WRITE_MASK_VAL(12, 12, 0)),  \n\tRK_MUXROUTE_GRF(3, RK_PC0, 3, 0x10260, WRITE_MASK_VAL(12, 12, 1)),  \n\n\tRK_MUXROUTE_GRF(3, RK_PC6, 1, 0x10264, WRITE_MASK_VAL(0, 0, 0)),  \n\tRK_MUXROUTE_GRF(2, RK_PD1, 3, 0x10264, WRITE_MASK_VAL(0, 0, 1)),  \n\n\tRK_MUXROUTE_GRF(3, RK_PA4, 5, 0x10264, WRITE_MASK_VAL(5, 4, 0)),  \n\tRK_MUXROUTE_GRF(2, RK_PD4, 7, 0x10264, WRITE_MASK_VAL(5, 4, 1)),  \n\tRK_MUXROUTE_GRF(1, RK_PD6, 3, 0x10264, WRITE_MASK_VAL(5, 4, 2)),  \n\n\tRK_MUXROUTE_GRF(3, RK_PA0, 7, 0x10264, WRITE_MASK_VAL(6, 6, 0)),  \n\tRK_MUXROUTE_GRF(4, RK_PA0, 4, 0x10264, WRITE_MASK_VAL(6, 6, 1)),  \n\n\tRK_MUXROUTE_GRF(2, RK_PA5, 7, 0x10264, WRITE_MASK_VAL(9, 8, 0)),  \n\tRK_MUXROUTE_GRF(3, RK_PB0, 5, 0x10264, WRITE_MASK_VAL(9, 8, 1)),  \n\tRK_MUXROUTE_GRF(1, RK_PD0, 4, 0x10264, WRITE_MASK_VAL(9, 8, 2)),  \n\n\tRK_MUXROUTE_GRF(3, RK_PC0, 5, 0x10264, WRITE_MASK_VAL(11, 10, 0)),  \n\tRK_MUXROUTE_GRF(1, RK_PC6, 3, 0x10264, WRITE_MASK_VAL(11, 10, 1)),  \n\tRK_MUXROUTE_GRF(2, RK_PD5, 6, 0x10264, WRITE_MASK_VAL(11, 10, 2)),  \n\n\tRK_MUXROUTE_GRF(3, RK_PC0, 2, 0x10264, WRITE_MASK_VAL(12, 12, 0)),  \n\tRK_MUXROUTE_GRF(2, RK_PB7, 2, 0x10264, WRITE_MASK_VAL(12, 12, 1)),  \n\n\tRK_MUXROUTE_GRF(3, RK_PA1, 3, 0x10264, WRITE_MASK_VAL(13, 13, 0)),  \n\tRK_MUXROUTE_GRF(3, RK_PA7, 5, 0x10264, WRITE_MASK_VAL(13, 13, 1)),  \n\n\tRK_MUXROUTE_GRF(3, RK_PA4, 6, 0x10268, WRITE_MASK_VAL(0, 0, 0)),  \n\tRK_MUXROUTE_GRF(2, RK_PD7, 5, 0x10268, WRITE_MASK_VAL(0, 0, 1)),  \n\n\tRK_MUXROUTE_GRF(3, RK_PA5, 6, 0x10268, WRITE_MASK_VAL(2, 2, 0)),  \n\tRK_MUXROUTE_GRF(2, RK_PD6, 5, 0x10268, WRITE_MASK_VAL(2, 2, 1)),  \n\n\tRK_MUXROUTE_GRF(3, RK_PA6, 6, 0x10268, WRITE_MASK_VAL(4, 4, 0)),  \n\tRK_MUXROUTE_GRF(2, RK_PD5, 5, 0x10268, WRITE_MASK_VAL(4, 4, 1)),  \n\n\tRK_MUXROUTE_GRF(3, RK_PA7, 6, 0x10268, WRITE_MASK_VAL(6, 6, 0)),  \n\tRK_MUXROUTE_GRF(3, RK_PA1, 5, 0x10268, WRITE_MASK_VAL(6, 6, 1)),  \n\n\tRK_MUXROUTE_GRF(1, RK_PA5, 3, 0x10268, WRITE_MASK_VAL(8, 8, 0)),  \n\tRK_MUXROUTE_GRF(3, RK_PA2, 1, 0x10268, WRITE_MASK_VAL(8, 8, 1)),  \n\n\tRK_MUXROUTE_GRF(3, RK_PC6, 3, 0x10268, WRITE_MASK_VAL(11, 10, 0)),  \n\tRK_MUXROUTE_GRF(1, RK_PA7, 2, 0x10268, WRITE_MASK_VAL(11, 10, 1)),  \n\tRK_MUXROUTE_GRF(3, RK_PA0, 4, 0x10268, WRITE_MASK_VAL(11, 10, 2)),  \n\n\tRK_MUXROUTE_GRF(3, RK_PA4, 4, 0x10268, WRITE_MASK_VAL(13, 12, 0)),  \n\tRK_MUXROUTE_GRF(2, RK_PA6, 4, 0x10268, WRITE_MASK_VAL(13, 12, 1)),  \n\tRK_MUXROUTE_GRF(1, RK_PD5, 3, 0x10268, WRITE_MASK_VAL(13, 12, 2)),  \n\n\tRK_MUXROUTE_GRF(3, RK_PA6, 4, 0x10268, WRITE_MASK_VAL(15, 14, 0)),  \n\tRK_MUXROUTE_GRF(2, RK_PB0, 4, 0x10268, WRITE_MASK_VAL(15, 14, 1)),  \n\tRK_MUXROUTE_GRF(2, RK_PA0, 3, 0x10268, WRITE_MASK_VAL(15, 14, 2)),  \n\n\tRK_MUXROUTE_PMU(0, RK_PB6, 3, 0x0114, WRITE_MASK_VAL(0, 0, 0)),  \n\tRK_MUXROUTE_PMU(2, RK_PB3, 5, 0x0114, WRITE_MASK_VAL(0, 0, 1)),  \n\n\tRK_MUXROUTE_PMU(0, RK_PB7, 3, 0x0114, WRITE_MASK_VAL(2, 2, 0)),  \n\tRK_MUXROUTE_PMU(2, RK_PB2, 5, 0x0114, WRITE_MASK_VAL(2, 2, 1)),  \n\n\tRK_MUXROUTE_PMU(0, RK_PC0, 3, 0x0114, WRITE_MASK_VAL(4, 4, 0)),  \n\tRK_MUXROUTE_PMU(2, RK_PB1, 5, 0x0114, WRITE_MASK_VAL(4, 4, 1)),  \n\n\tRK_MUXROUTE_PMU(0, RK_PC1, 3, 0x0114, WRITE_MASK_VAL(6, 6, 0)),  \n\tRK_MUXROUTE_PMU(2, RK_PB0, 5, 0x0114, WRITE_MASK_VAL(6, 6, 1)),  \n\n\tRK_MUXROUTE_PMU(0, RK_PC2, 3, 0x0114, WRITE_MASK_VAL(8, 8, 0)),  \n\tRK_MUXROUTE_PMU(2, RK_PA7, 5, 0x0114, WRITE_MASK_VAL(8, 8, 1)),  \n\n\tRK_MUXROUTE_PMU(0, RK_PC3, 3, 0x0114, WRITE_MASK_VAL(10, 10, 0)),  \n\tRK_MUXROUTE_PMU(2, RK_PA6, 5, 0x0114, WRITE_MASK_VAL(10, 10, 1)),  \n\n\tRK_MUXROUTE_PMU(0, RK_PB2, 3, 0x0114, WRITE_MASK_VAL(12, 12, 0)),  \n\tRK_MUXROUTE_PMU(2, RK_PD4, 5, 0x0114, WRITE_MASK_VAL(12, 12, 1)),  \n\n\tRK_MUXROUTE_PMU(0, RK_PB1, 3, 0x0114, WRITE_MASK_VAL(14, 14, 0)),  \n\tRK_MUXROUTE_PMU(3, RK_PA0, 5, 0x0114, WRITE_MASK_VAL(14, 14, 1)),  \n\n\tRK_MUXROUTE_PMU(0, RK_PB0, 1, 0x0118, WRITE_MASK_VAL(1, 0, 0)),  \n\tRK_MUXROUTE_PMU(2, RK_PA1, 1, 0x0118, WRITE_MASK_VAL(1, 0, 1)),  \n\tRK_MUXROUTE_PMU(2, RK_PB2, 6, 0x0118, WRITE_MASK_VAL(1, 0, 2)),  \n\n\tRK_MUXROUTE_PMU(0, RK_PB6, 2, 0x0118, WRITE_MASK_VAL(2, 2, 0)),  \n\tRK_MUXROUTE_PMU(1, RK_PD0, 5, 0x0118, WRITE_MASK_VAL(2, 2, 1)),  \n};\n\nstatic struct rockchip_mux_route_data rk3128_mux_route_data[] = {\n\tRK_MUXROUTE_SAME(1, RK_PB2, 1, 0x144, BIT(16 + 3) | BIT(16 + 4)),  \n\tRK_MUXROUTE_SAME(1, RK_PD3, 3, 0x144, BIT(16 + 3) | BIT(16 + 4) | BIT(3)),  \n\tRK_MUXROUTE_SAME(0, RK_PB5, 2, 0x144, BIT(16 + 3) | BIT(16 + 4) | BIT(4)),  \n\tRK_MUXROUTE_SAME(1, RK_PA5, 1, 0x144, BIT(16 + 5)),  \n\tRK_MUXROUTE_SAME(0, RK_PB6, 1, 0x144, BIT(16 + 5) | BIT(5)),  \n\tRK_MUXROUTE_SAME(1, RK_PC6, 2, 0x144, BIT(16 + 6)),  \n\tRK_MUXROUTE_SAME(2, RK_PA4, 2, 0x144, BIT(16 + 6) | BIT(6)),  \n};\n\nstatic struct rockchip_mux_route_data rk3188_mux_route_data[] = {\n\tRK_MUXROUTE_SAME(0, RK_PD0, 1, 0xa0, BIT(16 + 11)),  \n\tRK_MUXROUTE_SAME(0, RK_PD0, 2, 0xa0, BIT(16 + 11) | BIT(11)),  \n};\n\nstatic struct rockchip_mux_route_data rk3228_mux_route_data[] = {\n\tRK_MUXROUTE_SAME(0, RK_PD2, 1, 0x50, BIT(16)),  \n\tRK_MUXROUTE_SAME(3, RK_PC5, 1, 0x50, BIT(16) | BIT(0)),  \n\tRK_MUXROUTE_SAME(0, RK_PD3, 1, 0x50, BIT(16 + 1)),  \n\tRK_MUXROUTE_SAME(0, RK_PD6, 2, 0x50, BIT(16 + 1) | BIT(1)),  \n\tRK_MUXROUTE_SAME(0, RK_PD4, 1, 0x50, BIT(16 + 2)),  \n\tRK_MUXROUTE_SAME(1, RK_PB4, 2, 0x50, BIT(16 + 2) | BIT(2)),  \n\tRK_MUXROUTE_SAME(3, RK_PD2, 1, 0x50, BIT(16 + 3)),  \n\tRK_MUXROUTE_SAME(1, RK_PB3, 2, 0x50, BIT(16 + 3) | BIT(3)),  \n\tRK_MUXROUTE_SAME(1, RK_PA1, 1, 0x50, BIT(16 + 4)),  \n\tRK_MUXROUTE_SAME(3, RK_PA2, 1, 0x50, BIT(16 + 4) | BIT(4)),  \n\tRK_MUXROUTE_SAME(0, RK_PB5, 2, 0x50, BIT(16 + 5)),  \n\tRK_MUXROUTE_SAME(2, RK_PA0, 2, 0x50, BIT(16 + 5) | BIT(5)),  \n\tRK_MUXROUTE_SAME(1, RK_PC6, 2, 0x50, BIT(16 + 7)),  \n\tRK_MUXROUTE_SAME(2, RK_PA4, 2, 0x50, BIT(16 + 7) | BIT(7)),  \n\tRK_MUXROUTE_SAME(1, RK_PC3, 2, 0x50, BIT(16 + 8)),  \n\tRK_MUXROUTE_SAME(1, RK_PB2, 2, 0x50, BIT(16 + 8) | BIT(8)),  \n\tRK_MUXROUTE_SAME(1, RK_PB2, 1, 0x50, BIT(16 + 11)),  \n\tRK_MUXROUTE_SAME(3, RK_PB5, 1, 0x50, BIT(16 + 11) | BIT(11)),  \n};\n\nstatic struct rockchip_mux_route_data rk3288_mux_route_data[] = {\n\tRK_MUXROUTE_SAME(7, RK_PC0, 2, 0x264, BIT(16 + 12) | BIT(12)),  \n\tRK_MUXROUTE_SAME(7, RK_PC7, 4, 0x264, BIT(16 + 12)),  \n};\n\nstatic struct rockchip_mux_route_data rk3308_mux_route_data[] = {\n\tRK_MUXROUTE_SAME(0, RK_PC3, 1, 0x314, BIT(16 + 0) | BIT(0)),  \n\tRK_MUXROUTE_SAME(1, RK_PC6, 2, 0x314, BIT(16 + 2) | BIT(16 + 3)),  \n\tRK_MUXROUTE_SAME(4, RK_PD2, 2, 0x314, BIT(16 + 2) | BIT(16 + 3) | BIT(2)),  \n\tRK_MUXROUTE_SAME(0, RK_PB7, 2, 0x608, BIT(16 + 8) | BIT(16 + 9)),  \n\tRK_MUXROUTE_SAME(3, RK_PB4, 2, 0x608, BIT(16 + 8) | BIT(16 + 9) | BIT(8)),  \n\tRK_MUXROUTE_SAME(2, RK_PA0, 3, 0x608, BIT(16 + 8) | BIT(16 + 9) | BIT(9)),  \n\tRK_MUXROUTE_SAME(1, RK_PA3, 2, 0x308, BIT(16 + 3)),  \n\tRK_MUXROUTE_SAME(1, RK_PA4, 2, 0x308, BIT(16 + 3)),  \n\tRK_MUXROUTE_SAME(1, RK_PB5, 2, 0x308, BIT(16 + 3) | BIT(3)),  \n\tRK_MUXROUTE_SAME(1, RK_PB6, 2, 0x308, BIT(16 + 3) | BIT(3)),  \n\tRK_MUXROUTE_SAME(1, RK_PA4, 3, 0x308, BIT(16 + 12) | BIT(16 + 13)),  \n\tRK_MUXROUTE_SAME(1, RK_PB6, 4, 0x308, BIT(16 + 12) | BIT(16 + 13) | BIT(12)),  \n\tRK_MUXROUTE_SAME(2, RK_PA6, 2, 0x308, BIT(16 + 12) | BIT(16 + 13) | BIT(13)),  \n\tRK_MUXROUTE_SAME(2, RK_PA4, 3, 0x600, BIT(16 + 2) | BIT(2)),  \n\tRK_MUXROUTE_SAME(3, RK_PB2, 3, 0x314, BIT(16 + 9)),  \n\tRK_MUXROUTE_SAME(2, RK_PA4, 2, 0x314, BIT(16 + 9) | BIT(9)),  \n\tRK_MUXROUTE_SAME(0, RK_PB3, 3, 0x314, BIT(16 + 10) | BIT(16 + 11)),  \n\tRK_MUXROUTE_SAME(1, RK_PC6, 7, 0x314, BIT(16 + 10) | BIT(16 + 11) | BIT(10)),  \n\tRK_MUXROUTE_SAME(2, RK_PA2, 5, 0x314, BIT(16 + 10) | BIT(16 + 11) | BIT(11)),  \n\tRK_MUXROUTE_SAME(0, RK_PB3, 2, 0x314, BIT(16 + 12) | BIT(16 + 13)),  \n\tRK_MUXROUTE_SAME(1, RK_PC6, 5, 0x314, BIT(16 + 12) | BIT(16 + 13) | BIT(12)),  \n\tRK_MUXROUTE_SAME(2, RK_PA2, 4, 0x314, BIT(16 + 12) | BIT(16 + 13) | BIT(13)),  \n\tRK_MUXROUTE_SAME(1, RK_PC4, 3, 0x314, BIT(16 + 14)),  \n\tRK_MUXROUTE_SAME(4, RK_PA2, 2, 0x314, BIT(16 + 14) | BIT(14)),  \n\tRK_MUXROUTE_SAME(3, RK_PB4, 4, 0x314, BIT(16 + 15)),  \n\tRK_MUXROUTE_SAME(0, RK_PC1, 3, 0x314, BIT(16 + 15) | BIT(15)),  \n};\n\nstatic struct rockchip_mux_route_data rk3328_mux_route_data[] = {\n\tRK_MUXROUTE_SAME(1, RK_PA1, 2, 0x50, BIT(16) | BIT(16 + 1)),  \n\tRK_MUXROUTE_SAME(2, RK_PA1, 1, 0x50, BIT(16) | BIT(16 + 1) | BIT(0)),  \n\tRK_MUXROUTE_SAME(1, RK_PB3, 2, 0x50, BIT(16 + 2) | BIT(2)),  \n\tRK_MUXROUTE_SAME(1, RK_PB6, 2, 0x50, BIT(16 + 10) | BIT(10)),  \n\tRK_MUXROUTE_SAME(2, RK_PC3, 2, 0x50, BIT(16 + 3)),  \n\tRK_MUXROUTE_SAME(1, RK_PC7, 3, 0x50, BIT(16 + 3) | BIT(3)),  \n\tRK_MUXROUTE_SAME(3, RK_PA2, 4, 0x50, BIT(16 + 4) | BIT(16 + 5) | BIT(5)),  \n\tRK_MUXROUTE_SAME(1, RK_PD0, 1, 0x50, BIT(16 + 6)),  \n\tRK_MUXROUTE_SAME(3, RK_PA2, 6, 0x50, BIT(16 + 6) | BIT(6)),  \n\tRK_MUXROUTE_SAME(2, RK_PC6, 3, 0x50, BIT(16 + 7) | BIT(7)),  \n\tRK_MUXROUTE_SAME(2, RK_PC0, 3, 0x50, BIT(16 + 8) | BIT(8)),  \n\tRK_MUXROUTE_SAME(2, RK_PC0, 4, 0x50, BIT(16 + 9) | BIT(9)),  \n};\n\nstatic struct rockchip_mux_route_data rk3399_mux_route_data[] = {\n\tRK_MUXROUTE_SAME(4, RK_PB0, 2, 0xe21c, BIT(16 + 10) | BIT(16 + 11)),  \n\tRK_MUXROUTE_SAME(4, RK_PC0, 2, 0xe21c, BIT(16 + 10) | BIT(16 + 11) | BIT(10)),  \n\tRK_MUXROUTE_SAME(4, RK_PC3, 1, 0xe21c, BIT(16 + 10) | BIT(16 + 11) | BIT(11)),  \n\tRK_MUXROUTE_SAME(2, RK_PD2, 2, 0xe21c, BIT(16 + 14)),  \n\tRK_MUXROUTE_SAME(4, RK_PD0, 1, 0xe21c, BIT(16 + 14) | BIT(14)),  \n};\n\nstatic struct rockchip_mux_route_data rk3568_mux_route_data[] = {\n\tRK_MUXROUTE_PMU(0, RK_PB7, 1, 0x0110, WRITE_MASK_VAL(1, 0, 0)),  \n\tRK_MUXROUTE_PMU(0, RK_PC7, 2, 0x0110, WRITE_MASK_VAL(1, 0, 1)),  \n\tRK_MUXROUTE_PMU(0, RK_PC0, 1, 0x0110, WRITE_MASK_VAL(3, 2, 0)),  \n\tRK_MUXROUTE_PMU(0, RK_PB5, 4, 0x0110, WRITE_MASK_VAL(3, 2, 1)),  \n\tRK_MUXROUTE_PMU(0, RK_PC1, 1, 0x0110, WRITE_MASK_VAL(5, 4, 0)),  \n\tRK_MUXROUTE_PMU(0, RK_PB6, 4, 0x0110, WRITE_MASK_VAL(5, 4, 1)),  \n\tRK_MUXROUTE_GRF(0, RK_PB3, 2, 0x0300, WRITE_MASK_VAL(0, 0, 0)),  \n\tRK_MUXROUTE_GRF(2, RK_PA1, 4, 0x0300, WRITE_MASK_VAL(0, 0, 1)),  \n\tRK_MUXROUTE_GRF(1, RK_PA1, 3, 0x0300, WRITE_MASK_VAL(2, 2, 0)),  \n\tRK_MUXROUTE_GRF(4, RK_PC3, 3, 0x0300, WRITE_MASK_VAL(2, 2, 1)),  \n\tRK_MUXROUTE_GRF(4, RK_PB5, 3, 0x0300, WRITE_MASK_VAL(4, 4, 0)),  \n\tRK_MUXROUTE_GRF(2, RK_PB2, 4, 0x0300, WRITE_MASK_VAL(4, 4, 1)),  \n\tRK_MUXROUTE_GRF(4, RK_PC4, 1, 0x0300, WRITE_MASK_VAL(6, 6, 0)),  \n\tRK_MUXROUTE_GRF(0, RK_PC2, 2, 0x0300, WRITE_MASK_VAL(6, 6, 1)),  \n\tRK_MUXROUTE_GRF(3, RK_PB1, 3, 0x0300, WRITE_MASK_VAL(8, 8, 0)),  \n\tRK_MUXROUTE_GRF(4, RK_PA7, 3, 0x0300, WRITE_MASK_VAL(8, 8, 1)),  \n\tRK_MUXROUTE_GRF(4, RK_PD1, 1, 0x0300, WRITE_MASK_VAL(10, 10, 0)),  \n\tRK_MUXROUTE_GRF(0, RK_PC7, 1, 0x0300, WRITE_MASK_VAL(10, 10, 1)),  \n\tRK_MUXROUTE_GRF(0, RK_PB6, 1, 0x0300, WRITE_MASK_VAL(14, 14, 0)),  \n\tRK_MUXROUTE_GRF(4, RK_PB4, 1, 0x0300, WRITE_MASK_VAL(14, 14, 1)),  \n\tRK_MUXROUTE_GRF(1, RK_PA0, 1, 0x0304, WRITE_MASK_VAL(0, 0, 0)),  \n\tRK_MUXROUTE_GRF(3, RK_PB6, 4, 0x0304, WRITE_MASK_VAL(0, 0, 1)),  \n\tRK_MUXROUTE_GRF(4, RK_PB2, 1, 0x0304, WRITE_MASK_VAL(2, 2, 0)),  \n\tRK_MUXROUTE_GRF(2, RK_PB1, 2, 0x0304, WRITE_MASK_VAL(2, 2, 1)),  \n\tRK_MUXROUTE_GRF(3, RK_PB4, 4, 0x0304, WRITE_MASK_VAL(4, 4, 0)),  \n\tRK_MUXROUTE_GRF(4, RK_PD0, 2, 0x0304, WRITE_MASK_VAL(4, 4, 1)),  \n\tRK_MUXROUTE_GRF(3, RK_PB1, 5, 0x0304, WRITE_MASK_VAL(14, 14, 0)),  \n\tRK_MUXROUTE_GRF(1, RK_PD5, 4, 0x0304, WRITE_MASK_VAL(14, 14, 1)),  \n\tRK_MUXROUTE_GRF(3, RK_PB2, 5, 0x0308, WRITE_MASK_VAL(0, 0, 0)),  \n\tRK_MUXROUTE_GRF(1, RK_PD6, 4, 0x0308, WRITE_MASK_VAL(0, 0, 1)),  \n\tRK_MUXROUTE_GRF(3, RK_PB5, 5, 0x0308, WRITE_MASK_VAL(2, 2, 0)),  \n\tRK_MUXROUTE_GRF(2, RK_PA1, 2, 0x0308, WRITE_MASK_VAL(2, 2, 1)),  \n\tRK_MUXROUTE_GRF(3, RK_PB6, 5, 0x0308, WRITE_MASK_VAL(4, 4, 0)),  \n\tRK_MUXROUTE_GRF(4, RK_PC0, 3, 0x0308, WRITE_MASK_VAL(4, 4, 1)),  \n\tRK_MUXROUTE_GRF(3, RK_PB7, 2, 0x0308, WRITE_MASK_VAL(6, 6, 0)),  \n\tRK_MUXROUTE_GRF(4, RK_PC5, 1, 0x0308, WRITE_MASK_VAL(6, 6, 1)),  \n\tRK_MUXROUTE_GRF(3, RK_PC0, 2, 0x0308, WRITE_MASK_VAL(8, 8, 0)),  \n\tRK_MUXROUTE_GRF(4, RK_PC6, 1, 0x0308, WRITE_MASK_VAL(8, 8, 1)),  \n\tRK_MUXROUTE_GRF(3, RK_PC4, 1, 0x0308, WRITE_MASK_VAL(10, 10, 0)),  \n\tRK_MUXROUTE_GRF(4, RK_PC2, 1, 0x0308, WRITE_MASK_VAL(10, 10, 1)),  \n\tRK_MUXROUTE_GRF(3, RK_PC5, 1, 0x0308, WRITE_MASK_VAL(12, 12, 0)),  \n\tRK_MUXROUTE_GRF(4, RK_PC3, 1, 0x0308, WRITE_MASK_VAL(12, 12, 1)),  \n\tRK_MUXROUTE_GRF(3, RK_PD2, 3, 0x0308, WRITE_MASK_VAL(14, 14, 0)),  \n\tRK_MUXROUTE_GRF(3, RK_PA5, 5, 0x0308, WRITE_MASK_VAL(14, 14, 1)),  \n\tRK_MUXROUTE_GRF(0, RK_PB5, 2, 0x030c, WRITE_MASK_VAL(0, 0, 0)),  \n\tRK_MUXROUTE_GRF(2, RK_PD3, 3, 0x030c, WRITE_MASK_VAL(0, 0, 1)),  \n\tRK_MUXROUTE_GRF(2, RK_PB5, 3, 0x030c, WRITE_MASK_VAL(2, 2, 0)),  \n\tRK_MUXROUTE_GRF(3, RK_PC3, 3, 0x030c, WRITE_MASK_VAL(2, 2, 1)),  \n\tRK_MUXROUTE_GRF(2, RK_PC1, 4, 0x030c, WRITE_MASK_VAL(4, 4, 0)),  \n\tRK_MUXROUTE_GRF(3, RK_PA0, 3, 0x030c, WRITE_MASK_VAL(4, 4, 1)),  \n\tRK_MUXROUTE_GRF(4, RK_PB3, 4, 0x030c, WRITE_MASK_VAL(6, 6, 0)),  \n\tRK_MUXROUTE_GRF(4, RK_PC2, 2, 0x030c, WRITE_MASK_VAL(6, 6, 1)),  \n\tRK_MUXROUTE_GRF(2, RK_PB4, 2, 0x030c, WRITE_MASK_VAL(8, 8, 0)),  \n\tRK_MUXROUTE_GRF(3, RK_PD6, 4, 0x030c, WRITE_MASK_VAL(8, 8, 1)),  \n\tRK_MUXROUTE_GRF(0, RK_PD1, 1, 0x030c, WRITE_MASK_VAL(10, 10, 0)),  \n\tRK_MUXROUTE_GRF(1, RK_PD5, 2, 0x030c, WRITE_MASK_VAL(10, 10, 1)),  \n\tRK_MUXROUTE_GRF(1, RK_PA1, 2, 0x030c, WRITE_MASK_VAL(12, 12, 0)),  \n\tRK_MUXROUTE_GRF(3, RK_PB7, 4, 0x030c, WRITE_MASK_VAL(12, 12, 1)),  \n\tRK_MUXROUTE_GRF(1, RK_PA6, 2, 0x030c, WRITE_MASK_VAL(14, 14, 0)),  \n\tRK_MUXROUTE_GRF(3, RK_PB2, 4, 0x030c, WRITE_MASK_VAL(14, 14, 1)),  \n\tRK_MUXROUTE_GRF(2, RK_PA2, 3, 0x0310, WRITE_MASK_VAL(0, 0, 0)),  \n\tRK_MUXROUTE_GRF(3, RK_PC2, 4, 0x0310, WRITE_MASK_VAL(0, 0, 1)),  \n\tRK_MUXROUTE_GRF(2, RK_PA4, 3, 0x0310, WRITE_MASK_VAL(2, 2, 0)),  \n\tRK_MUXROUTE_GRF(1, RK_PD5, 3, 0x0310, WRITE_MASK_VAL(2, 2, 1)),  \n\tRK_MUXROUTE_GRF(2, RK_PA6, 3, 0x0310, WRITE_MASK_VAL(5, 4, 0)),  \n\tRK_MUXROUTE_GRF(3, RK_PC4, 4, 0x0310, WRITE_MASK_VAL(5, 4, 1)),  \n\tRK_MUXROUTE_GRF(4, RK_PA2, 4, 0x0310, WRITE_MASK_VAL(5, 4, 2)),  \n\tRK_MUXROUTE_GRF(2, RK_PC5, 3, 0x0310, WRITE_MASK_VAL(6, 6, 0)),  \n\tRK_MUXROUTE_GRF(2, RK_PD7, 4, 0x0310, WRITE_MASK_VAL(6, 6, 1)),  \n\tRK_MUXROUTE_GRF(2, RK_PB0, 3, 0x0310, WRITE_MASK_VAL(9, 8, 0)),  \n\tRK_MUXROUTE_GRF(4, RK_PC5, 4, 0x0310, WRITE_MASK_VAL(9, 8, 1)),  \n\tRK_MUXROUTE_GRF(4, RK_PA4, 4, 0x0310, WRITE_MASK_VAL(9, 8, 2)),  \n\tRK_MUXROUTE_GRF(1, RK_PA2, 1, 0x0310, WRITE_MASK_VAL(11, 10, 0)),  \n\tRK_MUXROUTE_GRF(3, RK_PC6, 4, 0x0310, WRITE_MASK_VAL(11, 10, 1)),  \n\tRK_MUXROUTE_GRF(2, RK_PD0, 5, 0x0310, WRITE_MASK_VAL(11, 10, 2)),  \n\tRK_MUXROUTE_GRF(2, RK_PC1, 1, 0x0310, WRITE_MASK_VAL(12, 12, 0)),  \n\tRK_MUXROUTE_GRF(4, RK_PB6, 5, 0x0310, WRITE_MASK_VAL(12, 12, 1)),  \n\tRK_MUXROUTE_GRF(3, RK_PA2, 4, 0x0310, WRITE_MASK_VAL(14, 14, 0)),  \n\tRK_MUXROUTE_GRF(4, RK_PC2, 5, 0x0310, WRITE_MASK_VAL(14, 14, 1)),  \n\tRK_MUXROUTE_GRF(1, RK_PA4, 3, 0x0314, WRITE_MASK_VAL(1, 0, 0)),  \n\tRK_MUXROUTE_GRF(1, RK_PA6, 3, 0x0314, WRITE_MASK_VAL(1, 0, 0)),  \n\tRK_MUXROUTE_GRF(3, RK_PD6, 5, 0x0314, WRITE_MASK_VAL(1, 0, 1)),  \n\tRK_MUXROUTE_GRF(4, RK_PA0, 4, 0x0314, WRITE_MASK_VAL(1, 0, 1)),  \n\tRK_MUXROUTE_GRF(3, RK_PC4, 5, 0x0314, WRITE_MASK_VAL(1, 0, 2)),  \n\tRK_MUXROUTE_GRF(0, RK_PA5, 3, 0x0314, WRITE_MASK_VAL(3, 2, 0)),  \n\tRK_MUXROUTE_GRF(2, RK_PD0, 4, 0x0314, WRITE_MASK_VAL(3, 2, 1)),  \n\tRK_MUXROUTE_GRF(1, RK_PB0, 4, 0x0314, WRITE_MASK_VAL(3, 2, 2)),  \n\tRK_MUXROUTE_GRF(0, RK_PA4, 3, 0x0314, WRITE_MASK_VAL(5, 4, 0)),  \n\tRK_MUXROUTE_GRF(2, RK_PD2, 4, 0x0314, WRITE_MASK_VAL(5, 4, 1)),  \n\tRK_MUXROUTE_GRF(1, RK_PA5, 4, 0x0314, WRITE_MASK_VAL(5, 4, 2)),  \n\tRK_MUXROUTE_GRF(0, RK_PA6, 2, 0x0314, WRITE_MASK_VAL(7, 6, 0)),  \n\tRK_MUXROUTE_GRF(2, RK_PD4, 4, 0x0314, WRITE_MASK_VAL(7, 6, 1)),  \n\tRK_MUXROUTE_GRF(4, RK_PC2, 4, 0x0314, WRITE_MASK_VAL(7, 6, 2)),  \n};\n\nstatic bool rockchip_get_mux_route(struct rockchip_pin_bank *bank, int pin,\n\t\t\t\t   int mux, u32 *loc, u32 *reg, u32 *value)\n{\n\tstruct rockchip_pinctrl *info = bank->drvdata;\n\tstruct rockchip_pin_ctrl *ctrl = info->ctrl;\n\tstruct rockchip_mux_route_data *data;\n\tint i;\n\n\tfor (i = 0; i < ctrl->niomux_routes; i++) {\n\t\tdata = &ctrl->iomux_routes[i];\n\t\tif ((data->bank_num == bank->bank_num) &&\n\t\t    (data->pin == pin) && (data->func == mux))\n\t\t\tbreak;\n\t}\n\n\tif (i >= ctrl->niomux_routes)\n\t\treturn false;\n\n\t*loc = data->route_location;\n\t*reg = data->route_offset;\n\t*value = data->route_val;\n\n\treturn true;\n}\n\nstatic int rockchip_get_mux(struct rockchip_pin_bank *bank, int pin)\n{\n\tstruct rockchip_pinctrl *info = bank->drvdata;\n\tstruct rockchip_pin_ctrl *ctrl = info->ctrl;\n\tint iomux_num = (pin / 8);\n\tstruct regmap *regmap;\n\tunsigned int val;\n\tint reg, ret, mask, mux_type;\n\tu8 bit;\n\n\tif (iomux_num > 3)\n\t\treturn -EINVAL;\n\n\tif (bank->iomux[iomux_num].type & IOMUX_UNROUTED) {\n\t\tdev_err(info->dev, \"pin %d is unrouted\\n\", pin);\n\t\treturn -EINVAL;\n\t}\n\n\tif (bank->iomux[iomux_num].type & IOMUX_GPIO_ONLY)\n\t\treturn RK_FUNC_GPIO;\n\n\tif (bank->iomux[iomux_num].type & IOMUX_SOURCE_PMU)\n\t\tregmap = info->regmap_pmu;\n\telse if (bank->iomux[iomux_num].type & IOMUX_L_SOURCE_PMU)\n\t\tregmap = (pin % 8 < 4) ? info->regmap_pmu : info->regmap_base;\n\telse\n\t\tregmap = info->regmap_base;\n\n\t \n\tmux_type = bank->iomux[iomux_num].type;\n\treg = bank->iomux[iomux_num].offset;\n\tif (mux_type & IOMUX_WIDTH_4BIT) {\n\t\tif ((pin % 8) >= 4)\n\t\t\treg += 0x4;\n\t\tbit = (pin % 4) * 4;\n\t\tmask = 0xf;\n\t} else if (mux_type & IOMUX_WIDTH_3BIT) {\n\t\tif ((pin % 8) >= 5)\n\t\t\treg += 0x4;\n\t\tbit = (pin % 8 % 5) * 3;\n\t\tmask = 0x7;\n\t} else {\n\t\tbit = (pin % 8) * 2;\n\t\tmask = 0x3;\n\t}\n\n\tif (bank->recalced_mask & BIT(pin))\n\t\trockchip_get_recalced_mux(bank, pin, &reg, &bit, &mask);\n\n\tif (ctrl->type == RK3588) {\n\t\tif (bank->bank_num == 0) {\n\t\t\tif ((pin >= RK_PB4) && (pin <= RK_PD7)) {\n\t\t\t\tu32 reg0 = 0;\n\n\t\t\t\treg0 = reg + 0x4000 - 0xC;  \n\t\t\t\tret = regmap_read(regmap, reg0, &val);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\n\t\t\t\tif (!(val & BIT(8)))\n\t\t\t\t\treturn ((val >> bit) & mask);\n\n\t\t\t\treg = reg + 0x8000;  \n\t\t\t\tregmap = info->regmap_base;\n\t\t\t}\n\t\t} else if (bank->bank_num > 0) {\n\t\t\treg += 0x8000;  \n\t\t}\n\t}\n\n\tret = regmap_read(regmap, reg, &val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ((val >> bit) & mask);\n}\n\nstatic int rockchip_verify_mux(struct rockchip_pin_bank *bank,\n\t\t\t       int pin, int mux)\n{\n\tstruct rockchip_pinctrl *info = bank->drvdata;\n\tstruct device *dev = info->dev;\n\tint iomux_num = (pin / 8);\n\n\tif (iomux_num > 3)\n\t\treturn -EINVAL;\n\n\tif (bank->iomux[iomux_num].type & IOMUX_UNROUTED) {\n\t\tdev_err(dev, \"pin %d is unrouted\\n\", pin);\n\t\treturn -EINVAL;\n\t}\n\n\tif (bank->iomux[iomux_num].type & IOMUX_GPIO_ONLY) {\n\t\tif (mux != RK_FUNC_GPIO) {\n\t\t\tdev_err(dev, \"pin %d only supports a gpio mux\\n\", pin);\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int rockchip_set_mux(struct rockchip_pin_bank *bank, int pin, int mux)\n{\n\tstruct rockchip_pinctrl *info = bank->drvdata;\n\tstruct rockchip_pin_ctrl *ctrl = info->ctrl;\n\tstruct device *dev = info->dev;\n\tint iomux_num = (pin / 8);\n\tstruct regmap *regmap;\n\tint reg, ret, mask, mux_type;\n\tu8 bit;\n\tu32 data, rmask, route_location, route_reg, route_val;\n\n\tret = rockchip_verify_mux(bank, pin, mux);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (bank->iomux[iomux_num].type & IOMUX_GPIO_ONLY)\n\t\treturn 0;\n\n\tdev_dbg(dev, \"setting mux of GPIO%d-%d to %d\\n\", bank->bank_num, pin, mux);\n\n\tif (bank->iomux[iomux_num].type & IOMUX_SOURCE_PMU)\n\t\tregmap = info->regmap_pmu;\n\telse if (bank->iomux[iomux_num].type & IOMUX_L_SOURCE_PMU)\n\t\tregmap = (pin % 8 < 4) ? info->regmap_pmu : info->regmap_base;\n\telse\n\t\tregmap = info->regmap_base;\n\n\t \n\tmux_type = bank->iomux[iomux_num].type;\n\treg = bank->iomux[iomux_num].offset;\n\tif (mux_type & IOMUX_WIDTH_4BIT) {\n\t\tif ((pin % 8) >= 4)\n\t\t\treg += 0x4;\n\t\tbit = (pin % 4) * 4;\n\t\tmask = 0xf;\n\t} else if (mux_type & IOMUX_WIDTH_3BIT) {\n\t\tif ((pin % 8) >= 5)\n\t\t\treg += 0x4;\n\t\tbit = (pin % 8 % 5) * 3;\n\t\tmask = 0x7;\n\t} else {\n\t\tbit = (pin % 8) * 2;\n\t\tmask = 0x3;\n\t}\n\n\tif (bank->recalced_mask & BIT(pin))\n\t\trockchip_get_recalced_mux(bank, pin, &reg, &bit, &mask);\n\n\tif (ctrl->type == RK3588) {\n\t\tif (bank->bank_num == 0) {\n\t\t\tif ((pin >= RK_PB4) && (pin <= RK_PD7)) {\n\t\t\t\tif (mux < 8) {\n\t\t\t\t\treg += 0x4000 - 0xC;  \n\t\t\t\t\tdata = (mask << (bit + 16));\n\t\t\t\t\trmask = data | (data >> 16);\n\t\t\t\t\tdata |= (mux & mask) << bit;\n\t\t\t\t\tret = regmap_update_bits(regmap, reg, rmask, data);\n\t\t\t\t} else {\n\t\t\t\t\tu32 reg0 = 0;\n\n\t\t\t\t\treg0 = reg + 0x4000 - 0xC;  \n\t\t\t\t\tdata = (mask << (bit + 16));\n\t\t\t\t\trmask = data | (data >> 16);\n\t\t\t\t\tdata |= 8 << bit;\n\t\t\t\t\tret = regmap_update_bits(regmap, reg0, rmask, data);\n\n\t\t\t\t\treg0 = reg + 0x8000;  \n\t\t\t\t\tdata = (mask << (bit + 16));\n\t\t\t\t\trmask = data | (data >> 16);\n\t\t\t\t\tdata |= mux << bit;\n\t\t\t\t\tregmap = info->regmap_base;\n\t\t\t\t\tret |= regmap_update_bits(regmap, reg0, rmask, data);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdata = (mask << (bit + 16));\n\t\t\t\trmask = data | (data >> 16);\n\t\t\t\tdata |= (mux & mask) << bit;\n\t\t\t\tret = regmap_update_bits(regmap, reg, rmask, data);\n\t\t\t}\n\t\t\treturn ret;\n\t\t} else if (bank->bank_num > 0) {\n\t\t\treg += 0x8000;  \n\t\t}\n\t}\n\n\tif (mux > mask)\n\t\treturn -EINVAL;\n\n\tif (bank->route_mask & BIT(pin)) {\n\t\tif (rockchip_get_mux_route(bank, pin, mux, &route_location,\n\t\t\t\t\t   &route_reg, &route_val)) {\n\t\t\tstruct regmap *route_regmap = regmap;\n\n\t\t\t \n\t\t\tswitch (route_location) {\n\t\t\tcase ROCKCHIP_ROUTE_PMU:\n\t\t\t\troute_regmap = info->regmap_pmu;\n\t\t\t\tbreak;\n\t\t\tcase ROCKCHIP_ROUTE_GRF:\n\t\t\t\troute_regmap = info->regmap_base;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tret = regmap_write(route_regmap, route_reg, route_val);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tdata = (mask << (bit + 16));\n\trmask = data | (data >> 16);\n\tdata |= (mux & mask) << bit;\n\tret = regmap_update_bits(regmap, reg, rmask, data);\n\n\treturn ret;\n}\n\n#define PX30_PULL_PMU_OFFSET\t\t0x10\n#define PX30_PULL_GRF_OFFSET\t\t0x60\n#define PX30_PULL_BITS_PER_PIN\t\t2\n#define PX30_PULL_PINS_PER_REG\t\t8\n#define PX30_PULL_BANK_STRIDE\t\t16\n\nstatic int px30_calc_pull_reg_and_bit(struct rockchip_pin_bank *bank,\n\t\t\t\t      int pin_num, struct regmap **regmap,\n\t\t\t\t      int *reg, u8 *bit)\n{\n\tstruct rockchip_pinctrl *info = bank->drvdata;\n\n\t \n\tif (bank->bank_num == 0) {\n\t\t*regmap = info->regmap_pmu;\n\t\t*reg = PX30_PULL_PMU_OFFSET;\n\t} else {\n\t\t*regmap = info->regmap_base;\n\t\t*reg = PX30_PULL_GRF_OFFSET;\n\n\t\t \n\t\t*reg -= 0x10;\n\t\t*reg += bank->bank_num * PX30_PULL_BANK_STRIDE;\n\t}\n\n\t*reg += ((pin_num / PX30_PULL_PINS_PER_REG) * 4);\n\t*bit = (pin_num % PX30_PULL_PINS_PER_REG);\n\t*bit *= PX30_PULL_BITS_PER_PIN;\n\n\treturn 0;\n}\n\n#define PX30_DRV_PMU_OFFSET\t\t0x20\n#define PX30_DRV_GRF_OFFSET\t\t0xf0\n#define PX30_DRV_BITS_PER_PIN\t\t2\n#define PX30_DRV_PINS_PER_REG\t\t8\n#define PX30_DRV_BANK_STRIDE\t\t16\n\nstatic int px30_calc_drv_reg_and_bit(struct rockchip_pin_bank *bank,\n\t\t\t\t     int pin_num, struct regmap **regmap,\n\t\t\t\t     int *reg, u8 *bit)\n{\n\tstruct rockchip_pinctrl *info = bank->drvdata;\n\n\t \n\tif (bank->bank_num == 0) {\n\t\t*regmap = info->regmap_pmu;\n\t\t*reg = PX30_DRV_PMU_OFFSET;\n\t} else {\n\t\t*regmap = info->regmap_base;\n\t\t*reg = PX30_DRV_GRF_OFFSET;\n\n\t\t \n\t\t*reg -= 0x10;\n\t\t*reg += bank->bank_num * PX30_DRV_BANK_STRIDE;\n\t}\n\n\t*reg += ((pin_num / PX30_DRV_PINS_PER_REG) * 4);\n\t*bit = (pin_num % PX30_DRV_PINS_PER_REG);\n\t*bit *= PX30_DRV_BITS_PER_PIN;\n\n\treturn 0;\n}\n\n#define PX30_SCHMITT_PMU_OFFSET\t\t\t0x38\n#define PX30_SCHMITT_GRF_OFFSET\t\t\t0xc0\n#define PX30_SCHMITT_PINS_PER_PMU_REG\t\t16\n#define PX30_SCHMITT_BANK_STRIDE\t\t16\n#define PX30_SCHMITT_PINS_PER_GRF_REG\t\t8\n\nstatic int px30_calc_schmitt_reg_and_bit(struct rockchip_pin_bank *bank,\n\t\t\t\t\t int pin_num,\n\t\t\t\t\t struct regmap **regmap,\n\t\t\t\t\t int *reg, u8 *bit)\n{\n\tstruct rockchip_pinctrl *info = bank->drvdata;\n\tint pins_per_reg;\n\n\tif (bank->bank_num == 0) {\n\t\t*regmap = info->regmap_pmu;\n\t\t*reg = PX30_SCHMITT_PMU_OFFSET;\n\t\tpins_per_reg = PX30_SCHMITT_PINS_PER_PMU_REG;\n\t} else {\n\t\t*regmap = info->regmap_base;\n\t\t*reg = PX30_SCHMITT_GRF_OFFSET;\n\t\tpins_per_reg = PX30_SCHMITT_PINS_PER_GRF_REG;\n\t\t*reg += (bank->bank_num  - 1) * PX30_SCHMITT_BANK_STRIDE;\n\t}\n\n\t*reg += ((pin_num / pins_per_reg) * 4);\n\t*bit = pin_num % pins_per_reg;\n\n\treturn 0;\n}\n\n#define RV1108_PULL_PMU_OFFSET\t\t0x10\n#define RV1108_PULL_OFFSET\t\t0x110\n#define RV1108_PULL_PINS_PER_REG\t8\n#define RV1108_PULL_BITS_PER_PIN\t2\n#define RV1108_PULL_BANK_STRIDE\t\t16\n\nstatic int rv1108_calc_pull_reg_and_bit(struct rockchip_pin_bank *bank,\n\t\t\t\t\tint pin_num, struct regmap **regmap,\n\t\t\t\t\tint *reg, u8 *bit)\n{\n\tstruct rockchip_pinctrl *info = bank->drvdata;\n\n\t \n\tif (bank->bank_num == 0) {\n\t\t*regmap = info->regmap_pmu;\n\t\t*reg = RV1108_PULL_PMU_OFFSET;\n\t} else {\n\t\t*reg = RV1108_PULL_OFFSET;\n\t\t*regmap = info->regmap_base;\n\t\t \n\t\t*reg -= 0x10;\n\t\t*reg += bank->bank_num * RV1108_PULL_BANK_STRIDE;\n\t}\n\n\t*reg += ((pin_num / RV1108_PULL_PINS_PER_REG) * 4);\n\t*bit = (pin_num % RV1108_PULL_PINS_PER_REG);\n\t*bit *= RV1108_PULL_BITS_PER_PIN;\n\n\treturn 0;\n}\n\n#define RV1108_DRV_PMU_OFFSET\t\t0x20\n#define RV1108_DRV_GRF_OFFSET\t\t0x210\n#define RV1108_DRV_BITS_PER_PIN\t\t2\n#define RV1108_DRV_PINS_PER_REG\t\t8\n#define RV1108_DRV_BANK_STRIDE\t\t16\n\nstatic int rv1108_calc_drv_reg_and_bit(struct rockchip_pin_bank *bank,\n\t\t\t\t       int pin_num, struct regmap **regmap,\n\t\t\t\t       int *reg, u8 *bit)\n{\n\tstruct rockchip_pinctrl *info = bank->drvdata;\n\n\t \n\tif (bank->bank_num == 0) {\n\t\t*regmap = info->regmap_pmu;\n\t\t*reg = RV1108_DRV_PMU_OFFSET;\n\t} else {\n\t\t*regmap = info->regmap_base;\n\t\t*reg = RV1108_DRV_GRF_OFFSET;\n\n\t\t \n\t\t*reg -= 0x10;\n\t\t*reg += bank->bank_num * RV1108_DRV_BANK_STRIDE;\n\t}\n\n\t*reg += ((pin_num / RV1108_DRV_PINS_PER_REG) * 4);\n\t*bit = pin_num % RV1108_DRV_PINS_PER_REG;\n\t*bit *= RV1108_DRV_BITS_PER_PIN;\n\n\treturn 0;\n}\n\n#define RV1108_SCHMITT_PMU_OFFSET\t\t0x30\n#define RV1108_SCHMITT_GRF_OFFSET\t\t0x388\n#define RV1108_SCHMITT_BANK_STRIDE\t\t8\n#define RV1108_SCHMITT_PINS_PER_GRF_REG\t\t16\n#define RV1108_SCHMITT_PINS_PER_PMU_REG\t\t8\n\nstatic int rv1108_calc_schmitt_reg_and_bit(struct rockchip_pin_bank *bank,\n\t\t\t\t\t   int pin_num,\n\t\t\t\t\t   struct regmap **regmap,\n\t\t\t\t\t   int *reg, u8 *bit)\n{\n\tstruct rockchip_pinctrl *info = bank->drvdata;\n\tint pins_per_reg;\n\n\tif (bank->bank_num == 0) {\n\t\t*regmap = info->regmap_pmu;\n\t\t*reg = RV1108_SCHMITT_PMU_OFFSET;\n\t\tpins_per_reg = RV1108_SCHMITT_PINS_PER_PMU_REG;\n\t} else {\n\t\t*regmap = info->regmap_base;\n\t\t*reg = RV1108_SCHMITT_GRF_OFFSET;\n\t\tpins_per_reg = RV1108_SCHMITT_PINS_PER_GRF_REG;\n\t\t*reg += (bank->bank_num  - 1) * RV1108_SCHMITT_BANK_STRIDE;\n\t}\n\t*reg += ((pin_num / pins_per_reg) * 4);\n\t*bit = pin_num % pins_per_reg;\n\n\treturn 0;\n}\n\n#define RV1126_PULL_PMU_OFFSET\t\t0x40\n#define RV1126_PULL_GRF_GPIO1A0_OFFSET\t0x10108\n#define RV1126_PULL_PINS_PER_REG\t8\n#define RV1126_PULL_BITS_PER_PIN\t2\n#define RV1126_PULL_BANK_STRIDE\t\t16\n#define RV1126_GPIO_C4_D7(p)\t\t(p >= 20 && p <= 31)  \n\nstatic int rv1126_calc_pull_reg_and_bit(struct rockchip_pin_bank *bank,\n\t\t\t\t\tint pin_num, struct regmap **regmap,\n\t\t\t\t\tint *reg, u8 *bit)\n{\n\tstruct rockchip_pinctrl *info = bank->drvdata;\n\n\t \n\tif (bank->bank_num == 0) {\n\t\tif (RV1126_GPIO_C4_D7(pin_num)) {\n\t\t\t*regmap = info->regmap_base;\n\t\t\t*reg = RV1126_PULL_GRF_GPIO1A0_OFFSET;\n\t\t\t*reg -= (((31 - pin_num) / RV1126_PULL_PINS_PER_REG + 1) * 4);\n\t\t\t*bit = pin_num % RV1126_PULL_PINS_PER_REG;\n\t\t\t*bit *= RV1126_PULL_BITS_PER_PIN;\n\t\t\treturn 0;\n\t\t}\n\t\t*regmap = info->regmap_pmu;\n\t\t*reg = RV1126_PULL_PMU_OFFSET;\n\t} else {\n\t\t*reg = RV1126_PULL_GRF_GPIO1A0_OFFSET;\n\t\t*regmap = info->regmap_base;\n\t\t*reg += (bank->bank_num - 1) * RV1126_PULL_BANK_STRIDE;\n\t}\n\n\t*reg += ((pin_num / RV1126_PULL_PINS_PER_REG) * 4);\n\t*bit = (pin_num % RV1126_PULL_PINS_PER_REG);\n\t*bit *= RV1126_PULL_BITS_PER_PIN;\n\n\treturn 0;\n}\n\n#define RV1126_DRV_PMU_OFFSET\t\t0x20\n#define RV1126_DRV_GRF_GPIO1A0_OFFSET\t0x10090\n#define RV1126_DRV_BITS_PER_PIN\t\t4\n#define RV1126_DRV_PINS_PER_REG\t\t4\n#define RV1126_DRV_BANK_STRIDE\t\t32\n\nstatic int rv1126_calc_drv_reg_and_bit(struct rockchip_pin_bank *bank,\n\t\t\t\t       int pin_num, struct regmap **regmap,\n\t\t\t\t       int *reg, u8 *bit)\n{\n\tstruct rockchip_pinctrl *info = bank->drvdata;\n\n\t \n\tif (bank->bank_num == 0) {\n\t\tif (RV1126_GPIO_C4_D7(pin_num)) {\n\t\t\t*regmap = info->regmap_base;\n\t\t\t*reg = RV1126_DRV_GRF_GPIO1A0_OFFSET;\n\t\t\t*reg -= (((31 - pin_num) / RV1126_DRV_PINS_PER_REG + 1) * 4);\n\t\t\t*reg -= 0x4;\n\t\t\t*bit = pin_num % RV1126_DRV_PINS_PER_REG;\n\t\t\t*bit *= RV1126_DRV_BITS_PER_PIN;\n\t\t\treturn 0;\n\t\t}\n\t\t*regmap = info->regmap_pmu;\n\t\t*reg = RV1126_DRV_PMU_OFFSET;\n\t} else {\n\t\t*regmap = info->regmap_base;\n\t\t*reg = RV1126_DRV_GRF_GPIO1A0_OFFSET;\n\t\t*reg += (bank->bank_num - 1) * RV1126_DRV_BANK_STRIDE;\n\t}\n\n\t*reg += ((pin_num / RV1126_DRV_PINS_PER_REG) * 4);\n\t*bit = pin_num % RV1126_DRV_PINS_PER_REG;\n\t*bit *= RV1126_DRV_BITS_PER_PIN;\n\n\treturn 0;\n}\n\n#define RV1126_SCHMITT_PMU_OFFSET\t\t0x60\n#define RV1126_SCHMITT_GRF_GPIO1A0_OFFSET\t0x10188\n#define RV1126_SCHMITT_BANK_STRIDE\t\t16\n#define RV1126_SCHMITT_PINS_PER_GRF_REG\t\t8\n#define RV1126_SCHMITT_PINS_PER_PMU_REG\t\t8\n\nstatic int rv1126_calc_schmitt_reg_and_bit(struct rockchip_pin_bank *bank,\n\t\t\t\t\t   int pin_num,\n\t\t\t\t\t   struct regmap **regmap,\n\t\t\t\t\t   int *reg, u8 *bit)\n{\n\tstruct rockchip_pinctrl *info = bank->drvdata;\n\tint pins_per_reg;\n\n\tif (bank->bank_num == 0) {\n\t\tif (RV1126_GPIO_C4_D7(pin_num)) {\n\t\t\t*regmap = info->regmap_base;\n\t\t\t*reg = RV1126_SCHMITT_GRF_GPIO1A0_OFFSET;\n\t\t\t*reg -= (((31 - pin_num) / RV1126_SCHMITT_PINS_PER_GRF_REG + 1) * 4);\n\t\t\t*bit = pin_num % RV1126_SCHMITT_PINS_PER_GRF_REG;\n\t\t\treturn 0;\n\t\t}\n\t\t*regmap = info->regmap_pmu;\n\t\t*reg = RV1126_SCHMITT_PMU_OFFSET;\n\t\tpins_per_reg = RV1126_SCHMITT_PINS_PER_PMU_REG;\n\t} else {\n\t\t*regmap = info->regmap_base;\n\t\t*reg = RV1126_SCHMITT_GRF_GPIO1A0_OFFSET;\n\t\tpins_per_reg = RV1126_SCHMITT_PINS_PER_GRF_REG;\n\t\t*reg += (bank->bank_num - 1) * RV1126_SCHMITT_BANK_STRIDE;\n\t}\n\t*reg += ((pin_num / pins_per_reg) * 4);\n\t*bit = pin_num % pins_per_reg;\n\n\treturn 0;\n}\n\n#define RK3308_SCHMITT_PINS_PER_REG\t\t8\n#define RK3308_SCHMITT_BANK_STRIDE\t\t16\n#define RK3308_SCHMITT_GRF_OFFSET\t\t0x1a0\n\nstatic int rk3308_calc_schmitt_reg_and_bit(struct rockchip_pin_bank *bank,\n\t\t\t\t    int pin_num, struct regmap **regmap,\n\t\t\t\t    int *reg, u8 *bit)\n{\n\tstruct rockchip_pinctrl *info = bank->drvdata;\n\n\t*regmap = info->regmap_base;\n\t*reg = RK3308_SCHMITT_GRF_OFFSET;\n\n\t*reg += bank->bank_num * RK3308_SCHMITT_BANK_STRIDE;\n\t*reg += ((pin_num / RK3308_SCHMITT_PINS_PER_REG) * 4);\n\t*bit = pin_num % RK3308_SCHMITT_PINS_PER_REG;\n\n\treturn 0;\n}\n\n#define RK2928_PULL_OFFSET\t\t0x118\n#define RK2928_PULL_PINS_PER_REG\t16\n#define RK2928_PULL_BANK_STRIDE\t\t8\n\nstatic int rk2928_calc_pull_reg_and_bit(struct rockchip_pin_bank *bank,\n\t\t\t\t\tint pin_num, struct regmap **regmap,\n\t\t\t\t\tint *reg, u8 *bit)\n{\n\tstruct rockchip_pinctrl *info = bank->drvdata;\n\n\t*regmap = info->regmap_base;\n\t*reg = RK2928_PULL_OFFSET;\n\t*reg += bank->bank_num * RK2928_PULL_BANK_STRIDE;\n\t*reg += (pin_num / RK2928_PULL_PINS_PER_REG) * 4;\n\n\t*bit = pin_num % RK2928_PULL_PINS_PER_REG;\n\n\treturn 0;\n};\n\n#define RK3128_PULL_OFFSET\t0x118\n\nstatic int rk3128_calc_pull_reg_and_bit(struct rockchip_pin_bank *bank,\n\t\t\t\t\tint pin_num, struct regmap **regmap,\n\t\t\t\t\tint *reg, u8 *bit)\n{\n\tstruct rockchip_pinctrl *info = bank->drvdata;\n\n\t*regmap = info->regmap_base;\n\t*reg = RK3128_PULL_OFFSET;\n\t*reg += bank->bank_num * RK2928_PULL_BANK_STRIDE;\n\t*reg += ((pin_num / RK2928_PULL_PINS_PER_REG) * 4);\n\n\t*bit = pin_num % RK2928_PULL_PINS_PER_REG;\n\n\treturn 0;\n}\n\n#define RK3188_PULL_OFFSET\t\t0x164\n#define RK3188_PULL_BITS_PER_PIN\t2\n#define RK3188_PULL_PINS_PER_REG\t8\n#define RK3188_PULL_BANK_STRIDE\t\t16\n#define RK3188_PULL_PMU_OFFSET\t\t0x64\n\nstatic int rk3188_calc_pull_reg_and_bit(struct rockchip_pin_bank *bank,\n\t\t\t\t\tint pin_num, struct regmap **regmap,\n\t\t\t\t\tint *reg, u8 *bit)\n{\n\tstruct rockchip_pinctrl *info = bank->drvdata;\n\n\t \n\tif (bank->bank_num == 0 && pin_num < 12) {\n\t\t*regmap = info->regmap_pmu ? info->regmap_pmu\n\t\t\t\t\t   : bank->regmap_pull;\n\t\t*reg = info->regmap_pmu ? RK3188_PULL_PMU_OFFSET : 0;\n\t\t*reg += ((pin_num / RK3188_PULL_PINS_PER_REG) * 4);\n\t\t*bit = pin_num % RK3188_PULL_PINS_PER_REG;\n\t\t*bit *= RK3188_PULL_BITS_PER_PIN;\n\t} else {\n\t\t*regmap = info->regmap_pull ? info->regmap_pull\n\t\t\t\t\t    : info->regmap_base;\n\t\t*reg = info->regmap_pull ? 0 : RK3188_PULL_OFFSET;\n\n\t\t \n\t\t*reg -= 4;\n\t\t*reg += bank->bank_num * RK3188_PULL_BANK_STRIDE;\n\t\t*reg += ((pin_num / RK3188_PULL_PINS_PER_REG) * 4);\n\n\t\t \n\t\t*bit = 7 - (pin_num % RK3188_PULL_PINS_PER_REG);\n\t\t*bit *= RK3188_PULL_BITS_PER_PIN;\n\t}\n\n\treturn 0;\n}\n\n#define RK3288_PULL_OFFSET\t\t0x140\nstatic int rk3288_calc_pull_reg_and_bit(struct rockchip_pin_bank *bank,\n\t\t\t\t\tint pin_num, struct regmap **regmap,\n\t\t\t\t\tint *reg, u8 *bit)\n{\n\tstruct rockchip_pinctrl *info = bank->drvdata;\n\n\t \n\tif (bank->bank_num == 0) {\n\t\t*regmap = info->regmap_pmu;\n\t\t*reg = RK3188_PULL_PMU_OFFSET;\n\n\t\t*reg += ((pin_num / RK3188_PULL_PINS_PER_REG) * 4);\n\t\t*bit = pin_num % RK3188_PULL_PINS_PER_REG;\n\t\t*bit *= RK3188_PULL_BITS_PER_PIN;\n\t} else {\n\t\t*regmap = info->regmap_base;\n\t\t*reg = RK3288_PULL_OFFSET;\n\n\t\t \n\t\t*reg -= 0x10;\n\t\t*reg += bank->bank_num * RK3188_PULL_BANK_STRIDE;\n\t\t*reg += ((pin_num / RK3188_PULL_PINS_PER_REG) * 4);\n\n\t\t*bit = (pin_num % RK3188_PULL_PINS_PER_REG);\n\t\t*bit *= RK3188_PULL_BITS_PER_PIN;\n\t}\n\n\treturn 0;\n}\n\n#define RK3288_DRV_PMU_OFFSET\t\t0x70\n#define RK3288_DRV_GRF_OFFSET\t\t0x1c0\n#define RK3288_DRV_BITS_PER_PIN\t\t2\n#define RK3288_DRV_PINS_PER_REG\t\t8\n#define RK3288_DRV_BANK_STRIDE\t\t16\n\nstatic int rk3288_calc_drv_reg_and_bit(struct rockchip_pin_bank *bank,\n\t\t\t\t       int pin_num, struct regmap **regmap,\n\t\t\t\t       int *reg, u8 *bit)\n{\n\tstruct rockchip_pinctrl *info = bank->drvdata;\n\n\t \n\tif (bank->bank_num == 0) {\n\t\t*regmap = info->regmap_pmu;\n\t\t*reg = RK3288_DRV_PMU_OFFSET;\n\n\t\t*reg += ((pin_num / RK3288_DRV_PINS_PER_REG) * 4);\n\t\t*bit = pin_num % RK3288_DRV_PINS_PER_REG;\n\t\t*bit *= RK3288_DRV_BITS_PER_PIN;\n\t} else {\n\t\t*regmap = info->regmap_base;\n\t\t*reg = RK3288_DRV_GRF_OFFSET;\n\n\t\t \n\t\t*reg -= 0x10;\n\t\t*reg += bank->bank_num * RK3288_DRV_BANK_STRIDE;\n\t\t*reg += ((pin_num / RK3288_DRV_PINS_PER_REG) * 4);\n\n\t\t*bit = (pin_num % RK3288_DRV_PINS_PER_REG);\n\t\t*bit *= RK3288_DRV_BITS_PER_PIN;\n\t}\n\n\treturn 0;\n}\n\n#define RK3228_PULL_OFFSET\t\t0x100\n\nstatic int rk3228_calc_pull_reg_and_bit(struct rockchip_pin_bank *bank,\n\t\t\t\t\tint pin_num, struct regmap **regmap,\n\t\t\t\t\tint *reg, u8 *bit)\n{\n\tstruct rockchip_pinctrl *info = bank->drvdata;\n\n\t*regmap = info->regmap_base;\n\t*reg = RK3228_PULL_OFFSET;\n\t*reg += bank->bank_num * RK3188_PULL_BANK_STRIDE;\n\t*reg += ((pin_num / RK3188_PULL_PINS_PER_REG) * 4);\n\n\t*bit = (pin_num % RK3188_PULL_PINS_PER_REG);\n\t*bit *= RK3188_PULL_BITS_PER_PIN;\n\n\treturn 0;\n}\n\n#define RK3228_DRV_GRF_OFFSET\t\t0x200\n\nstatic int rk3228_calc_drv_reg_and_bit(struct rockchip_pin_bank *bank,\n\t\t\t\t       int pin_num, struct regmap **regmap,\n\t\t\t\t       int *reg, u8 *bit)\n{\n\tstruct rockchip_pinctrl *info = bank->drvdata;\n\n\t*regmap = info->regmap_base;\n\t*reg = RK3228_DRV_GRF_OFFSET;\n\t*reg += bank->bank_num * RK3288_DRV_BANK_STRIDE;\n\t*reg += ((pin_num / RK3288_DRV_PINS_PER_REG) * 4);\n\n\t*bit = (pin_num % RK3288_DRV_PINS_PER_REG);\n\t*bit *= RK3288_DRV_BITS_PER_PIN;\n\n\treturn 0;\n}\n\n#define RK3308_PULL_OFFSET\t\t0xa0\n\nstatic int rk3308_calc_pull_reg_and_bit(struct rockchip_pin_bank *bank,\n\t\t\t\t\tint pin_num, struct regmap **regmap,\n\t\t\t\t\tint *reg, u8 *bit)\n{\n\tstruct rockchip_pinctrl *info = bank->drvdata;\n\n\t*regmap = info->regmap_base;\n\t*reg = RK3308_PULL_OFFSET;\n\t*reg += bank->bank_num * RK3188_PULL_BANK_STRIDE;\n\t*reg += ((pin_num / RK3188_PULL_PINS_PER_REG) * 4);\n\n\t*bit = (pin_num % RK3188_PULL_PINS_PER_REG);\n\t*bit *= RK3188_PULL_BITS_PER_PIN;\n\n\treturn 0;\n}\n\n#define RK3308_DRV_GRF_OFFSET\t\t0x100\n\nstatic int rk3308_calc_drv_reg_and_bit(struct rockchip_pin_bank *bank,\n\t\t\t\t       int pin_num, struct regmap **regmap,\n\t\t\t\t       int *reg, u8 *bit)\n{\n\tstruct rockchip_pinctrl *info = bank->drvdata;\n\n\t*regmap = info->regmap_base;\n\t*reg = RK3308_DRV_GRF_OFFSET;\n\t*reg += bank->bank_num * RK3288_DRV_BANK_STRIDE;\n\t*reg += ((pin_num / RK3288_DRV_PINS_PER_REG) * 4);\n\n\t*bit = (pin_num % RK3288_DRV_PINS_PER_REG);\n\t*bit *= RK3288_DRV_BITS_PER_PIN;\n\n\treturn 0;\n}\n\n#define RK3368_PULL_GRF_OFFSET\t\t0x100\n#define RK3368_PULL_PMU_OFFSET\t\t0x10\n\nstatic int rk3368_calc_pull_reg_and_bit(struct rockchip_pin_bank *bank,\n\t\t\t\t\tint pin_num, struct regmap **regmap,\n\t\t\t\t\tint *reg, u8 *bit)\n{\n\tstruct rockchip_pinctrl *info = bank->drvdata;\n\n\t \n\tif (bank->bank_num == 0) {\n\t\t*regmap = info->regmap_pmu;\n\t\t*reg = RK3368_PULL_PMU_OFFSET;\n\n\t\t*reg += ((pin_num / RK3188_PULL_PINS_PER_REG) * 4);\n\t\t*bit = pin_num % RK3188_PULL_PINS_PER_REG;\n\t\t*bit *= RK3188_PULL_BITS_PER_PIN;\n\t} else {\n\t\t*regmap = info->regmap_base;\n\t\t*reg = RK3368_PULL_GRF_OFFSET;\n\n\t\t \n\t\t*reg -= 0x10;\n\t\t*reg += bank->bank_num * RK3188_PULL_BANK_STRIDE;\n\t\t*reg += ((pin_num / RK3188_PULL_PINS_PER_REG) * 4);\n\n\t\t*bit = (pin_num % RK3188_PULL_PINS_PER_REG);\n\t\t*bit *= RK3188_PULL_BITS_PER_PIN;\n\t}\n\n\treturn 0;\n}\n\n#define RK3368_DRV_PMU_OFFSET\t\t0x20\n#define RK3368_DRV_GRF_OFFSET\t\t0x200\n\nstatic int rk3368_calc_drv_reg_and_bit(struct rockchip_pin_bank *bank,\n\t\t\t\t       int pin_num, struct regmap **regmap,\n\t\t\t\t       int *reg, u8 *bit)\n{\n\tstruct rockchip_pinctrl *info = bank->drvdata;\n\n\t \n\tif (bank->bank_num == 0) {\n\t\t*regmap = info->regmap_pmu;\n\t\t*reg = RK3368_DRV_PMU_OFFSET;\n\n\t\t*reg += ((pin_num / RK3288_DRV_PINS_PER_REG) * 4);\n\t\t*bit = pin_num % RK3288_DRV_PINS_PER_REG;\n\t\t*bit *= RK3288_DRV_BITS_PER_PIN;\n\t} else {\n\t\t*regmap = info->regmap_base;\n\t\t*reg = RK3368_DRV_GRF_OFFSET;\n\n\t\t \n\t\t*reg -= 0x10;\n\t\t*reg += bank->bank_num * RK3288_DRV_BANK_STRIDE;\n\t\t*reg += ((pin_num / RK3288_DRV_PINS_PER_REG) * 4);\n\n\t\t*bit = (pin_num % RK3288_DRV_PINS_PER_REG);\n\t\t*bit *= RK3288_DRV_BITS_PER_PIN;\n\t}\n\n\treturn 0;\n}\n\n#define RK3399_PULL_GRF_OFFSET\t\t0xe040\n#define RK3399_PULL_PMU_OFFSET\t\t0x40\n#define RK3399_DRV_3BITS_PER_PIN\t3\n\nstatic int rk3399_calc_pull_reg_and_bit(struct rockchip_pin_bank *bank,\n\t\t\t\t\tint pin_num, struct regmap **regmap,\n\t\t\t\t\tint *reg, u8 *bit)\n{\n\tstruct rockchip_pinctrl *info = bank->drvdata;\n\n\t \n\tif ((bank->bank_num == 0) || (bank->bank_num == 1)) {\n\t\t*regmap = info->regmap_pmu;\n\t\t*reg = RK3399_PULL_PMU_OFFSET;\n\n\t\t*reg += bank->bank_num * RK3188_PULL_BANK_STRIDE;\n\n\t\t*reg += ((pin_num / RK3188_PULL_PINS_PER_REG) * 4);\n\t\t*bit = pin_num % RK3188_PULL_PINS_PER_REG;\n\t\t*bit *= RK3188_PULL_BITS_PER_PIN;\n\t} else {\n\t\t*regmap = info->regmap_base;\n\t\t*reg = RK3399_PULL_GRF_OFFSET;\n\n\t\t \n\t\t*reg -= 0x20;\n\t\t*reg += bank->bank_num * RK3188_PULL_BANK_STRIDE;\n\t\t*reg += ((pin_num / RK3188_PULL_PINS_PER_REG) * 4);\n\n\t\t*bit = (pin_num % RK3188_PULL_PINS_PER_REG);\n\t\t*bit *= RK3188_PULL_BITS_PER_PIN;\n\t}\n\n\treturn 0;\n}\n\nstatic int rk3399_calc_drv_reg_and_bit(struct rockchip_pin_bank *bank,\n\t\t\t\t       int pin_num, struct regmap **regmap,\n\t\t\t\t       int *reg, u8 *bit)\n{\n\tstruct rockchip_pinctrl *info = bank->drvdata;\n\tint drv_num = (pin_num / 8);\n\n\t \n\tif ((bank->bank_num == 0) || (bank->bank_num == 1))\n\t\t*regmap = info->regmap_pmu;\n\telse\n\t\t*regmap = info->regmap_base;\n\n\t*reg = bank->drv[drv_num].offset;\n\tif ((bank->drv[drv_num].drv_type == DRV_TYPE_IO_1V8_3V0_AUTO) ||\n\t    (bank->drv[drv_num].drv_type == DRV_TYPE_IO_3V3_ONLY))\n\t\t*bit = (pin_num % 8) * 3;\n\telse\n\t\t*bit = (pin_num % 8) * 2;\n\n\treturn 0;\n}\n\n#define RK3568_PULL_PMU_OFFSET\t\t0x20\n#define RK3568_PULL_GRF_OFFSET\t\t0x80\n#define RK3568_PULL_BITS_PER_PIN\t2\n#define RK3568_PULL_PINS_PER_REG\t8\n#define RK3568_PULL_BANK_STRIDE\t\t0x10\n\nstatic int rk3568_calc_pull_reg_and_bit(struct rockchip_pin_bank *bank,\n\t\t\t\t\tint pin_num, struct regmap **regmap,\n\t\t\t\t\tint *reg, u8 *bit)\n{\n\tstruct rockchip_pinctrl *info = bank->drvdata;\n\n\tif (bank->bank_num == 0) {\n\t\t*regmap = info->regmap_pmu;\n\t\t*reg = RK3568_PULL_PMU_OFFSET;\n\t\t*reg += bank->bank_num * RK3568_PULL_BANK_STRIDE;\n\t\t*reg += ((pin_num / RK3568_PULL_PINS_PER_REG) * 4);\n\n\t\t*bit = pin_num % RK3568_PULL_PINS_PER_REG;\n\t\t*bit *= RK3568_PULL_BITS_PER_PIN;\n\t} else {\n\t\t*regmap = info->regmap_base;\n\t\t*reg = RK3568_PULL_GRF_OFFSET;\n\t\t*reg += (bank->bank_num - 1) * RK3568_PULL_BANK_STRIDE;\n\t\t*reg += ((pin_num / RK3568_PULL_PINS_PER_REG) * 4);\n\n\t\t*bit = (pin_num % RK3568_PULL_PINS_PER_REG);\n\t\t*bit *= RK3568_PULL_BITS_PER_PIN;\n\t}\n\n\treturn 0;\n}\n\n#define RK3568_DRV_PMU_OFFSET\t\t0x70\n#define RK3568_DRV_GRF_OFFSET\t\t0x200\n#define RK3568_DRV_BITS_PER_PIN\t\t8\n#define RK3568_DRV_PINS_PER_REG\t\t2\n#define RK3568_DRV_BANK_STRIDE\t\t0x40\n\nstatic int rk3568_calc_drv_reg_and_bit(struct rockchip_pin_bank *bank,\n\t\t\t\t       int pin_num, struct regmap **regmap,\n\t\t\t\t       int *reg, u8 *bit)\n{\n\tstruct rockchip_pinctrl *info = bank->drvdata;\n\n\t \n\tif (bank->bank_num == 0) {\n\t\t*regmap = info->regmap_pmu;\n\t\t*reg = RK3568_DRV_PMU_OFFSET;\n\t\t*reg += ((pin_num / RK3568_DRV_PINS_PER_REG) * 4);\n\n\t\t*bit = pin_num % RK3568_DRV_PINS_PER_REG;\n\t\t*bit *= RK3568_DRV_BITS_PER_PIN;\n\t} else {\n\t\t*regmap = info->regmap_base;\n\t\t*reg = RK3568_DRV_GRF_OFFSET;\n\t\t*reg += (bank->bank_num - 1) * RK3568_DRV_BANK_STRIDE;\n\t\t*reg += ((pin_num / RK3568_DRV_PINS_PER_REG) * 4);\n\n\t\t*bit = (pin_num % RK3568_DRV_PINS_PER_REG);\n\t\t*bit *= RK3568_DRV_BITS_PER_PIN;\n\t}\n\n\treturn 0;\n}\n\n#define RK3588_PMU1_IOC_REG\t\t(0x0000)\n#define RK3588_PMU2_IOC_REG\t\t(0x4000)\n#define RK3588_BUS_IOC_REG\t\t(0x8000)\n#define RK3588_VCCIO1_4_IOC_REG\t\t(0x9000)\n#define RK3588_VCCIO3_5_IOC_REG\t\t(0xA000)\n#define RK3588_VCCIO2_IOC_REG\t\t(0xB000)\n#define RK3588_VCCIO6_IOC_REG\t\t(0xC000)\n#define RK3588_EMMC_IOC_REG\t\t(0xD000)\n\nstatic const u32 rk3588_ds_regs[][2] = {\n\t{RK_GPIO0_A0, RK3588_PMU1_IOC_REG + 0x0010},\n\t{RK_GPIO0_A4, RK3588_PMU1_IOC_REG + 0x0014},\n\t{RK_GPIO0_B0, RK3588_PMU1_IOC_REG + 0x0018},\n\t{RK_GPIO0_B4, RK3588_PMU2_IOC_REG + 0x0014},\n\t{RK_GPIO0_C0, RK3588_PMU2_IOC_REG + 0x0018},\n\t{RK_GPIO0_C4, RK3588_PMU2_IOC_REG + 0x001C},\n\t{RK_GPIO0_D0, RK3588_PMU2_IOC_REG + 0x0020},\n\t{RK_GPIO0_D4, RK3588_PMU2_IOC_REG + 0x0024},\n\t{RK_GPIO1_A0, RK3588_VCCIO1_4_IOC_REG + 0x0020},\n\t{RK_GPIO1_A4, RK3588_VCCIO1_4_IOC_REG + 0x0024},\n\t{RK_GPIO1_B0, RK3588_VCCIO1_4_IOC_REG + 0x0028},\n\t{RK_GPIO1_B4, RK3588_VCCIO1_4_IOC_REG + 0x002C},\n\t{RK_GPIO1_C0, RK3588_VCCIO1_4_IOC_REG + 0x0030},\n\t{RK_GPIO1_C4, RK3588_VCCIO1_4_IOC_REG + 0x0034},\n\t{RK_GPIO1_D0, RK3588_VCCIO1_4_IOC_REG + 0x0038},\n\t{RK_GPIO1_D4, RK3588_VCCIO1_4_IOC_REG + 0x003C},\n\t{RK_GPIO2_A0, RK3588_EMMC_IOC_REG + 0x0040},\n\t{RK_GPIO2_A4, RK3588_VCCIO3_5_IOC_REG + 0x0044},\n\t{RK_GPIO2_B0, RK3588_VCCIO3_5_IOC_REG + 0x0048},\n\t{RK_GPIO2_B4, RK3588_VCCIO3_5_IOC_REG + 0x004C},\n\t{RK_GPIO2_C0, RK3588_VCCIO3_5_IOC_REG + 0x0050},\n\t{RK_GPIO2_C4, RK3588_VCCIO3_5_IOC_REG + 0x0054},\n\t{RK_GPIO2_D0, RK3588_EMMC_IOC_REG + 0x0058},\n\t{RK_GPIO2_D4, RK3588_EMMC_IOC_REG + 0x005C},\n\t{RK_GPIO3_A0, RK3588_VCCIO3_5_IOC_REG + 0x0060},\n\t{RK_GPIO3_A4, RK3588_VCCIO3_5_IOC_REG + 0x0064},\n\t{RK_GPIO3_B0, RK3588_VCCIO3_5_IOC_REG + 0x0068},\n\t{RK_GPIO3_B4, RK3588_VCCIO3_5_IOC_REG + 0x006C},\n\t{RK_GPIO3_C0, RK3588_VCCIO3_5_IOC_REG + 0x0070},\n\t{RK_GPIO3_C4, RK3588_VCCIO3_5_IOC_REG + 0x0074},\n\t{RK_GPIO3_D0, RK3588_VCCIO3_5_IOC_REG + 0x0078},\n\t{RK_GPIO3_D4, RK3588_VCCIO3_5_IOC_REG + 0x007C},\n\t{RK_GPIO4_A0, RK3588_VCCIO6_IOC_REG + 0x0080},\n\t{RK_GPIO4_A4, RK3588_VCCIO6_IOC_REG + 0x0084},\n\t{RK_GPIO4_B0, RK3588_VCCIO6_IOC_REG + 0x0088},\n\t{RK_GPIO4_B4, RK3588_VCCIO6_IOC_REG + 0x008C},\n\t{RK_GPIO4_C0, RK3588_VCCIO6_IOC_REG + 0x0090},\n\t{RK_GPIO4_C2, RK3588_VCCIO3_5_IOC_REG + 0x0090},\n\t{RK_GPIO4_C4, RK3588_VCCIO3_5_IOC_REG + 0x0094},\n\t{RK_GPIO4_D0, RK3588_VCCIO2_IOC_REG + 0x0098},\n\t{RK_GPIO4_D4, RK3588_VCCIO2_IOC_REG + 0x009C},\n};\n\nstatic const u32 rk3588_p_regs[][2] = {\n\t{RK_GPIO0_A0, RK3588_PMU1_IOC_REG + 0x0020},\n\t{RK_GPIO0_B0, RK3588_PMU1_IOC_REG + 0x0024},\n\t{RK_GPIO0_B5, RK3588_PMU2_IOC_REG + 0x0028},\n\t{RK_GPIO0_C0, RK3588_PMU2_IOC_REG + 0x002C},\n\t{RK_GPIO0_D0, RK3588_PMU2_IOC_REG + 0x0030},\n\t{RK_GPIO1_A0, RK3588_VCCIO1_4_IOC_REG + 0x0110},\n\t{RK_GPIO1_B0, RK3588_VCCIO1_4_IOC_REG + 0x0114},\n\t{RK_GPIO1_C0, RK3588_VCCIO1_4_IOC_REG + 0x0118},\n\t{RK_GPIO1_D0, RK3588_VCCIO1_4_IOC_REG + 0x011C},\n\t{RK_GPIO2_A0, RK3588_EMMC_IOC_REG + 0x0120},\n\t{RK_GPIO2_A6, RK3588_VCCIO3_5_IOC_REG + 0x0120},\n\t{RK_GPIO2_B0, RK3588_VCCIO3_5_IOC_REG + 0x0124},\n\t{RK_GPIO2_C0, RK3588_VCCIO3_5_IOC_REG + 0x0128},\n\t{RK_GPIO2_D0, RK3588_EMMC_IOC_REG + 0x012C},\n\t{RK_GPIO3_A0, RK3588_VCCIO3_5_IOC_REG + 0x0130},\n\t{RK_GPIO3_B0, RK3588_VCCIO3_5_IOC_REG + 0x0134},\n\t{RK_GPIO3_C0, RK3588_VCCIO3_5_IOC_REG + 0x0138},\n\t{RK_GPIO3_D0, RK3588_VCCIO3_5_IOC_REG + 0x013C},\n\t{RK_GPIO4_A0, RK3588_VCCIO6_IOC_REG + 0x0140},\n\t{RK_GPIO4_B0, RK3588_VCCIO6_IOC_REG + 0x0144},\n\t{RK_GPIO4_C0, RK3588_VCCIO6_IOC_REG + 0x0148},\n\t{RK_GPIO4_C2, RK3588_VCCIO3_5_IOC_REG + 0x0148},\n\t{RK_GPIO4_D0, RK3588_VCCIO2_IOC_REG + 0x014C},\n};\n\nstatic const u32 rk3588_smt_regs[][2] = {\n\t{RK_GPIO0_A0, RK3588_PMU1_IOC_REG + 0x0030},\n\t{RK_GPIO0_B0, RK3588_PMU1_IOC_REG + 0x0034},\n\t{RK_GPIO0_B5, RK3588_PMU2_IOC_REG + 0x0040},\n\t{RK_GPIO0_C0, RK3588_PMU2_IOC_REG + 0x0044},\n\t{RK_GPIO0_D0, RK3588_PMU2_IOC_REG + 0x0048},\n\t{RK_GPIO1_A0, RK3588_VCCIO1_4_IOC_REG + 0x0210},\n\t{RK_GPIO1_B0, RK3588_VCCIO1_4_IOC_REG + 0x0214},\n\t{RK_GPIO1_C0, RK3588_VCCIO1_4_IOC_REG + 0x0218},\n\t{RK_GPIO1_D0, RK3588_VCCIO1_4_IOC_REG + 0x021C},\n\t{RK_GPIO2_A0, RK3588_EMMC_IOC_REG + 0x0220},\n\t{RK_GPIO2_A6, RK3588_VCCIO3_5_IOC_REG + 0x0220},\n\t{RK_GPIO2_B0, RK3588_VCCIO3_5_IOC_REG + 0x0224},\n\t{RK_GPIO2_C0, RK3588_VCCIO3_5_IOC_REG + 0x0228},\n\t{RK_GPIO2_D0, RK3588_EMMC_IOC_REG + 0x022C},\n\t{RK_GPIO3_A0, RK3588_VCCIO3_5_IOC_REG + 0x0230},\n\t{RK_GPIO3_B0, RK3588_VCCIO3_5_IOC_REG + 0x0234},\n\t{RK_GPIO3_C0, RK3588_VCCIO3_5_IOC_REG + 0x0238},\n\t{RK_GPIO3_D0, RK3588_VCCIO3_5_IOC_REG + 0x023C},\n\t{RK_GPIO4_A0, RK3588_VCCIO6_IOC_REG + 0x0240},\n\t{RK_GPIO4_B0, RK3588_VCCIO6_IOC_REG + 0x0244},\n\t{RK_GPIO4_C0, RK3588_VCCIO6_IOC_REG + 0x0248},\n\t{RK_GPIO4_C2, RK3588_VCCIO3_5_IOC_REG + 0x0248},\n\t{RK_GPIO4_D0, RK3588_VCCIO2_IOC_REG + 0x024C},\n};\n\n#define RK3588_PULL_BITS_PER_PIN\t\t2\n#define RK3588_PULL_PINS_PER_REG\t\t8\n\nstatic int rk3588_calc_pull_reg_and_bit(struct rockchip_pin_bank *bank,\n\t\t\t\t\tint pin_num, struct regmap **regmap,\n\t\t\t\t\tint *reg, u8 *bit)\n{\n\tstruct rockchip_pinctrl *info = bank->drvdata;\n\tu8 bank_num = bank->bank_num;\n\tu32 pin = bank_num * 32 + pin_num;\n\tint i;\n\n\tfor (i = ARRAY_SIZE(rk3588_p_regs) - 1; i >= 0; i--) {\n\t\tif (pin >= rk3588_p_regs[i][0]) {\n\t\t\t*reg = rk3588_p_regs[i][1];\n\t\t\t*regmap = info->regmap_base;\n\t\t\t*bit = pin_num % RK3588_PULL_PINS_PER_REG;\n\t\t\t*bit *= RK3588_PULL_BITS_PER_PIN;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\n#define RK3588_DRV_BITS_PER_PIN\t\t4\n#define RK3588_DRV_PINS_PER_REG\t\t4\n\nstatic int rk3588_calc_drv_reg_and_bit(struct rockchip_pin_bank *bank,\n\t\t\t\t       int pin_num, struct regmap **regmap,\n\t\t\t\t       int *reg, u8 *bit)\n{\n\tstruct rockchip_pinctrl *info = bank->drvdata;\n\tu8 bank_num = bank->bank_num;\n\tu32 pin = bank_num * 32 + pin_num;\n\tint i;\n\n\tfor (i = ARRAY_SIZE(rk3588_ds_regs) - 1; i >= 0; i--) {\n\t\tif (pin >= rk3588_ds_regs[i][0]) {\n\t\t\t*reg = rk3588_ds_regs[i][1];\n\t\t\t*regmap = info->regmap_base;\n\t\t\t*bit = pin_num % RK3588_DRV_PINS_PER_REG;\n\t\t\t*bit *= RK3588_DRV_BITS_PER_PIN;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\n#define RK3588_SMT_BITS_PER_PIN\t\t1\n#define RK3588_SMT_PINS_PER_REG\t\t8\n\nstatic int rk3588_calc_schmitt_reg_and_bit(struct rockchip_pin_bank *bank,\n\t\t\t\t\t   int pin_num,\n\t\t\t\t\t   struct regmap **regmap,\n\t\t\t\t\t   int *reg, u8 *bit)\n{\n\tstruct rockchip_pinctrl *info = bank->drvdata;\n\tu8 bank_num = bank->bank_num;\n\tu32 pin = bank_num * 32 + pin_num;\n\tint i;\n\n\tfor (i = ARRAY_SIZE(rk3588_smt_regs) - 1; i >= 0; i--) {\n\t\tif (pin >= rk3588_smt_regs[i][0]) {\n\t\t\t*reg = rk3588_smt_regs[i][1];\n\t\t\t*regmap = info->regmap_base;\n\t\t\t*bit = pin_num % RK3588_SMT_PINS_PER_REG;\n\t\t\t*bit *= RK3588_SMT_BITS_PER_PIN;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int rockchip_perpin_drv_list[DRV_TYPE_MAX][8] = {\n\t{ 2, 4, 8, 12, -1, -1, -1, -1 },\n\t{ 3, 6, 9, 12, -1, -1, -1, -1 },\n\t{ 5, 10, 15, 20, -1, -1, -1, -1 },\n\t{ 4, 6, 8, 10, 12, 14, 16, 18 },\n\t{ 4, 7, 10, 13, 16, 19, 22, 26 }\n};\n\nstatic int rockchip_get_drive_perpin(struct rockchip_pin_bank *bank,\n\t\t\t\t     int pin_num)\n{\n\tstruct rockchip_pinctrl *info = bank->drvdata;\n\tstruct rockchip_pin_ctrl *ctrl = info->ctrl;\n\tstruct device *dev = info->dev;\n\tstruct regmap *regmap;\n\tint reg, ret;\n\tu32 data, temp, rmask_bits;\n\tu8 bit;\n\tint drv_type = bank->drv[pin_num / 8].drv_type;\n\n\tret = ctrl->drv_calc_reg(bank, pin_num, &regmap, &reg, &bit);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (drv_type) {\n\tcase DRV_TYPE_IO_1V8_3V0_AUTO:\n\tcase DRV_TYPE_IO_3V3_ONLY:\n\t\trmask_bits = RK3399_DRV_3BITS_PER_PIN;\n\t\tswitch (bit) {\n\t\tcase 0 ... 12:\n\t\t\t \n\t\t\tbreak;\n\t\tcase 15:\n\t\t\t \n\t\t\tret = regmap_read(regmap, reg, &data);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tret = regmap_read(regmap, reg + 0x4, &temp);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\t \n\t\t\tdata >>= 15;\n\t\t\ttemp &= 0x3;\n\t\t\ttemp <<= 1;\n\t\t\tdata |= temp;\n\n\t\t\treturn rockchip_perpin_drv_list[drv_type][data];\n\t\tcase 18 ... 21:\n\t\t\t \n\t\t\treg += 4;\n\t\t\tbit -= 16;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(dev, \"unsupported bit: %d for pinctrl drive type: %d\\n\",\n\t\t\t\tbit, drv_type);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tbreak;\n\tcase DRV_TYPE_IO_DEFAULT:\n\tcase DRV_TYPE_IO_1V8_OR_3V0:\n\tcase DRV_TYPE_IO_1V8_ONLY:\n\t\trmask_bits = RK3288_DRV_BITS_PER_PIN;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"unsupported pinctrl drive type: %d\\n\", drv_type);\n\t\treturn -EINVAL;\n\t}\n\n\tret = regmap_read(regmap, reg, &data);\n\tif (ret)\n\t\treturn ret;\n\n\tdata >>= bit;\n\tdata &= (1 << rmask_bits) - 1;\n\n\treturn rockchip_perpin_drv_list[drv_type][data];\n}\n\nstatic int rockchip_set_drive_perpin(struct rockchip_pin_bank *bank,\n\t\t\t\t     int pin_num, int strength)\n{\n\tstruct rockchip_pinctrl *info = bank->drvdata;\n\tstruct rockchip_pin_ctrl *ctrl = info->ctrl;\n\tstruct device *dev = info->dev;\n\tstruct regmap *regmap;\n\tint reg, ret, i;\n\tu32 data, rmask, rmask_bits, temp;\n\tu8 bit;\n\tint drv_type = bank->drv[pin_num / 8].drv_type;\n\n\tdev_dbg(dev, \"setting drive of GPIO%d-%d to %d\\n\",\n\t\tbank->bank_num, pin_num, strength);\n\n\tret = ctrl->drv_calc_reg(bank, pin_num, &regmap, &reg, &bit);\n\tif (ret)\n\t\treturn ret;\n\tif (ctrl->type == RK3588) {\n\t\trmask_bits = RK3588_DRV_BITS_PER_PIN;\n\t\tret = strength;\n\t\tgoto config;\n\t} else if (ctrl->type == RK3568) {\n\t\trmask_bits = RK3568_DRV_BITS_PER_PIN;\n\t\tret = (1 << (strength + 1)) - 1;\n\t\tgoto config;\n\t}\n\n\tif (ctrl->type == RV1126) {\n\t\trmask_bits = RV1126_DRV_BITS_PER_PIN;\n\t\tret = strength;\n\t\tgoto config;\n\t}\n\n\tret = -EINVAL;\n\tfor (i = 0; i < ARRAY_SIZE(rockchip_perpin_drv_list[drv_type]); i++) {\n\t\tif (rockchip_perpin_drv_list[drv_type][i] == strength) {\n\t\t\tret = i;\n\t\t\tbreak;\n\t\t} else if (rockchip_perpin_drv_list[drv_type][i] < 0) {\n\t\t\tret = rockchip_perpin_drv_list[drv_type][i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret < 0) {\n\t\tdev_err(dev, \"unsupported driver strength %d\\n\", strength);\n\t\treturn ret;\n\t}\n\n\tswitch (drv_type) {\n\tcase DRV_TYPE_IO_1V8_3V0_AUTO:\n\tcase DRV_TYPE_IO_3V3_ONLY:\n\t\trmask_bits = RK3399_DRV_3BITS_PER_PIN;\n\t\tswitch (bit) {\n\t\tcase 0 ... 12:\n\t\t\t \n\t\t\tbreak;\n\t\tcase 15:\n\t\t\t \n\t\t\tdata = (ret & 0x1) << 15;\n\t\t\ttemp = (ret >> 0x1) & 0x3;\n\n\t\t\trmask = BIT(15) | BIT(31);\n\t\t\tdata |= BIT(31);\n\t\t\tret = regmap_update_bits(regmap, reg, rmask, data);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\trmask = 0x3 | (0x3 << 16);\n\t\t\ttemp |= (0x3 << 16);\n\t\t\treg += 0x4;\n\t\t\tret = regmap_update_bits(regmap, reg, rmask, temp);\n\n\t\t\treturn ret;\n\t\tcase 18 ... 21:\n\t\t\t \n\t\t\treg += 4;\n\t\t\tbit -= 16;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(dev, \"unsupported bit: %d for pinctrl drive type: %d\\n\",\n\t\t\t\tbit, drv_type);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase DRV_TYPE_IO_DEFAULT:\n\tcase DRV_TYPE_IO_1V8_OR_3V0:\n\tcase DRV_TYPE_IO_1V8_ONLY:\n\t\trmask_bits = RK3288_DRV_BITS_PER_PIN;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"unsupported pinctrl drive type: %d\\n\", drv_type);\n\t\treturn -EINVAL;\n\t}\n\nconfig:\n\t \n\tdata = ((1 << rmask_bits) - 1) << (bit + 16);\n\trmask = data | (data >> 16);\n\tdata |= (ret << bit);\n\n\tret = regmap_update_bits(regmap, reg, rmask, data);\n\n\treturn ret;\n}\n\nstatic int rockchip_pull_list[PULL_TYPE_MAX][4] = {\n\t{\n\t\tPIN_CONFIG_BIAS_DISABLE,\n\t\tPIN_CONFIG_BIAS_PULL_UP,\n\t\tPIN_CONFIG_BIAS_PULL_DOWN,\n\t\tPIN_CONFIG_BIAS_BUS_HOLD\n\t},\n\t{\n\t\tPIN_CONFIG_BIAS_DISABLE,\n\t\tPIN_CONFIG_BIAS_PULL_DOWN,\n\t\tPIN_CONFIG_BIAS_DISABLE,\n\t\tPIN_CONFIG_BIAS_PULL_UP\n\t},\n};\n\nstatic int rockchip_get_pull(struct rockchip_pin_bank *bank, int pin_num)\n{\n\tstruct rockchip_pinctrl *info = bank->drvdata;\n\tstruct rockchip_pin_ctrl *ctrl = info->ctrl;\n\tstruct device *dev = info->dev;\n\tstruct regmap *regmap;\n\tint reg, ret, pull_type;\n\tu8 bit;\n\tu32 data;\n\n\t \n\tif (ctrl->type == RK3066B)\n\t\treturn PIN_CONFIG_BIAS_DISABLE;\n\n\tret = ctrl->pull_calc_reg(bank, pin_num, &regmap, &reg, &bit);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_read(regmap, reg, &data);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (ctrl->type) {\n\tcase RK2928:\n\tcase RK3128:\n\t\treturn !(data & BIT(bit))\n\t\t\t\t? PIN_CONFIG_BIAS_PULL_PIN_DEFAULT\n\t\t\t\t: PIN_CONFIG_BIAS_DISABLE;\n\tcase PX30:\n\tcase RV1108:\n\tcase RK3188:\n\tcase RK3288:\n\tcase RK3308:\n\tcase RK3368:\n\tcase RK3399:\n\tcase RK3568:\n\tcase RK3588:\n\t\tpull_type = bank->pull_type[pin_num / 8];\n\t\tdata >>= bit;\n\t\tdata &= (1 << RK3188_PULL_BITS_PER_PIN) - 1;\n\t\t \n\t\tif (ctrl->type == RK3568 && bank->bank_num == 0 && pin_num >= 27 && pin_num <= 30) {\n\t\t\tif (data == 3)\n\t\t\t\tdata = 1;\n\t\t}\n\n\t\treturn rockchip_pull_list[pull_type][data];\n\tdefault:\n\t\tdev_err(dev, \"unsupported pinctrl type\\n\");\n\t\treturn -EINVAL;\n\t};\n}\n\nstatic int rockchip_set_pull(struct rockchip_pin_bank *bank,\n\t\t\t\t\tint pin_num, int pull)\n{\n\tstruct rockchip_pinctrl *info = bank->drvdata;\n\tstruct rockchip_pin_ctrl *ctrl = info->ctrl;\n\tstruct device *dev = info->dev;\n\tstruct regmap *regmap;\n\tint reg, ret, i, pull_type;\n\tu8 bit;\n\tu32 data, rmask;\n\n\tdev_dbg(dev, \"setting pull of GPIO%d-%d to %d\\n\", bank->bank_num, pin_num, pull);\n\n\t \n\tif (ctrl->type == RK3066B)\n\t\treturn pull ? -EINVAL : 0;\n\n\tret = ctrl->pull_calc_reg(bank, pin_num, &regmap, &reg, &bit);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (ctrl->type) {\n\tcase RK2928:\n\tcase RK3128:\n\t\tdata = BIT(bit + 16);\n\t\tif (pull == PIN_CONFIG_BIAS_DISABLE)\n\t\t\tdata |= BIT(bit);\n\t\tret = regmap_write(regmap, reg, data);\n\t\tbreak;\n\tcase PX30:\n\tcase RV1108:\n\tcase RV1126:\n\tcase RK3188:\n\tcase RK3288:\n\tcase RK3308:\n\tcase RK3368:\n\tcase RK3399:\n\tcase RK3568:\n\tcase RK3588:\n\t\tpull_type = bank->pull_type[pin_num / 8];\n\t\tret = -EINVAL;\n\t\tfor (i = 0; i < ARRAY_SIZE(rockchip_pull_list[pull_type]);\n\t\t\ti++) {\n\t\t\tif (rockchip_pull_list[pull_type][i] == pull) {\n\t\t\t\tret = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (ctrl->type == RK3568 && bank->bank_num == 0 && pin_num >= 27 && pin_num <= 30) {\n\t\t\tif (ret == 1)\n\t\t\t\tret = 3;\n\t\t}\n\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"unsupported pull setting %d\\n\", pull);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tdata = ((1 << RK3188_PULL_BITS_PER_PIN) - 1) << (bit + 16);\n\t\trmask = data | (data >> 16);\n\t\tdata |= (ret << bit);\n\n\t\tret = regmap_update_bits(regmap, reg, rmask, data);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"unsupported pinctrl type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n\n#define RK3328_SCHMITT_BITS_PER_PIN\t\t1\n#define RK3328_SCHMITT_PINS_PER_REG\t\t16\n#define RK3328_SCHMITT_BANK_STRIDE\t\t8\n#define RK3328_SCHMITT_GRF_OFFSET\t\t0x380\n\nstatic int rk3328_calc_schmitt_reg_and_bit(struct rockchip_pin_bank *bank,\n\t\t\t\t\t   int pin_num,\n\t\t\t\t\t   struct regmap **regmap,\n\t\t\t\t\t   int *reg, u8 *bit)\n{\n\tstruct rockchip_pinctrl *info = bank->drvdata;\n\n\t*regmap = info->regmap_base;\n\t*reg = RK3328_SCHMITT_GRF_OFFSET;\n\n\t*reg += bank->bank_num * RK3328_SCHMITT_BANK_STRIDE;\n\t*reg += ((pin_num / RK3328_SCHMITT_PINS_PER_REG) * 4);\n\t*bit = pin_num % RK3328_SCHMITT_PINS_PER_REG;\n\n\treturn 0;\n}\n\n#define RK3568_SCHMITT_BITS_PER_PIN\t\t2\n#define RK3568_SCHMITT_PINS_PER_REG\t\t8\n#define RK3568_SCHMITT_BANK_STRIDE\t\t0x10\n#define RK3568_SCHMITT_GRF_OFFSET\t\t0xc0\n#define RK3568_SCHMITT_PMUGRF_OFFSET\t\t0x30\n\nstatic int rk3568_calc_schmitt_reg_and_bit(struct rockchip_pin_bank *bank,\n\t\t\t\t\t   int pin_num,\n\t\t\t\t\t   struct regmap **regmap,\n\t\t\t\t\t   int *reg, u8 *bit)\n{\n\tstruct rockchip_pinctrl *info = bank->drvdata;\n\n\tif (bank->bank_num == 0) {\n\t\t*regmap = info->regmap_pmu;\n\t\t*reg = RK3568_SCHMITT_PMUGRF_OFFSET;\n\t} else {\n\t\t*regmap = info->regmap_base;\n\t\t*reg = RK3568_SCHMITT_GRF_OFFSET;\n\t\t*reg += (bank->bank_num - 1) * RK3568_SCHMITT_BANK_STRIDE;\n\t}\n\n\t*reg += ((pin_num / RK3568_SCHMITT_PINS_PER_REG) * 4);\n\t*bit = pin_num % RK3568_SCHMITT_PINS_PER_REG;\n\t*bit *= RK3568_SCHMITT_BITS_PER_PIN;\n\n\treturn 0;\n}\n\nstatic int rockchip_get_schmitt(struct rockchip_pin_bank *bank, int pin_num)\n{\n\tstruct rockchip_pinctrl *info = bank->drvdata;\n\tstruct rockchip_pin_ctrl *ctrl = info->ctrl;\n\tstruct regmap *regmap;\n\tint reg, ret;\n\tu8 bit;\n\tu32 data;\n\n\tret = ctrl->schmitt_calc_reg(bank, pin_num, &regmap, &reg, &bit);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_read(regmap, reg, &data);\n\tif (ret)\n\t\treturn ret;\n\n\tdata >>= bit;\n\tswitch (ctrl->type) {\n\tcase RK3568:\n\t\treturn data & ((1 << RK3568_SCHMITT_BITS_PER_PIN) - 1);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn data & 0x1;\n}\n\nstatic int rockchip_set_schmitt(struct rockchip_pin_bank *bank,\n\t\t\t\tint pin_num, int enable)\n{\n\tstruct rockchip_pinctrl *info = bank->drvdata;\n\tstruct rockchip_pin_ctrl *ctrl = info->ctrl;\n\tstruct device *dev = info->dev;\n\tstruct regmap *regmap;\n\tint reg, ret;\n\tu8 bit;\n\tu32 data, rmask;\n\n\tdev_dbg(dev, \"setting input schmitt of GPIO%d-%d to %d\\n\",\n\t\tbank->bank_num, pin_num, enable);\n\n\tret = ctrl->schmitt_calc_reg(bank, pin_num, &regmap, &reg, &bit);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tswitch (ctrl->type) {\n\tcase RK3568:\n\t\tdata = ((1 << RK3568_SCHMITT_BITS_PER_PIN) - 1) << (bit + 16);\n\t\trmask = data | (data >> 16);\n\t\tdata |= ((enable ? 0x2 : 0x1) << bit);\n\t\tbreak;\n\tdefault:\n\t\tdata = BIT(bit + 16) | (enable << bit);\n\t\trmask = BIT(bit + 16) | BIT(bit);\n\t\tbreak;\n\t}\n\n\treturn regmap_update_bits(regmap, reg, rmask, data);\n}\n\n \n\nstatic int rockchip_pmx_get_funcs_count(struct pinctrl_dev *pctldev)\n{\n\tstruct rockchip_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn info->nfunctions;\n}\n\nstatic const char *rockchip_pmx_get_func_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t  unsigned selector)\n{\n\tstruct rockchip_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn info->functions[selector].name;\n}\n\nstatic int rockchip_pmx_get_groups(struct pinctrl_dev *pctldev,\n\t\t\t\tunsigned selector, const char * const **groups,\n\t\t\t\tunsigned * const num_groups)\n{\n\tstruct rockchip_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\n\n\t*groups = info->functions[selector].groups;\n\t*num_groups = info->functions[selector].ngroups;\n\n\treturn 0;\n}\n\nstatic int rockchip_pmx_set(struct pinctrl_dev *pctldev, unsigned selector,\n\t\t\t    unsigned group)\n{\n\tstruct rockchip_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\n\tconst unsigned int *pins = info->groups[group].pins;\n\tconst struct rockchip_pin_config *data = info->groups[group].data;\n\tstruct device *dev = info->dev;\n\tstruct rockchip_pin_bank *bank;\n\tint cnt, ret = 0;\n\n\tdev_dbg(dev, \"enable function %s group %s\\n\",\n\t\tinfo->functions[selector].name, info->groups[group].name);\n\n\t \n\tfor (cnt = 0; cnt < info->groups[group].npins; cnt++) {\n\t\tbank = pin_to_bank(info, pins[cnt]);\n\t\tret = rockchip_set_mux(bank, pins[cnt] - bank->pin_base,\n\t\t\t\t       data[cnt].func);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tif (ret) {\n\t\t \n\t\tfor (cnt--; cnt >= 0; cnt--)\n\t\t\trockchip_set_mux(bank, pins[cnt] - bank->pin_base, 0);\n\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int rockchip_pmx_gpio_set_direction(struct pinctrl_dev *pctldev,\n\t\t\t\t\t   struct pinctrl_gpio_range *range,\n\t\t\t\t\t   unsigned offset,\n\t\t\t\t\t   bool input)\n{\n\tstruct rockchip_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\n\tstruct rockchip_pin_bank *bank;\n\n\tbank = pin_to_bank(info, offset);\n\treturn rockchip_set_mux(bank, offset - bank->pin_base, RK_FUNC_GPIO);\n}\n\nstatic const struct pinmux_ops rockchip_pmx_ops = {\n\t.get_functions_count\t= rockchip_pmx_get_funcs_count,\n\t.get_function_name\t= rockchip_pmx_get_func_name,\n\t.get_function_groups\t= rockchip_pmx_get_groups,\n\t.set_mux\t\t= rockchip_pmx_set,\n\t.gpio_set_direction\t= rockchip_pmx_gpio_set_direction,\n};\n\n \n\nstatic bool rockchip_pinconf_pull_valid(struct rockchip_pin_ctrl *ctrl,\n\t\t\t\t\tenum pin_config_param pull)\n{\n\tswitch (ctrl->type) {\n\tcase RK2928:\n\tcase RK3128:\n\t\treturn (pull == PIN_CONFIG_BIAS_PULL_PIN_DEFAULT ||\n\t\t\t\t\tpull == PIN_CONFIG_BIAS_DISABLE);\n\tcase RK3066B:\n\t\treturn pull ? false : true;\n\tcase PX30:\n\tcase RV1108:\n\tcase RV1126:\n\tcase RK3188:\n\tcase RK3288:\n\tcase RK3308:\n\tcase RK3368:\n\tcase RK3399:\n\tcase RK3568:\n\tcase RK3588:\n\t\treturn (pull != PIN_CONFIG_BIAS_PULL_PIN_DEFAULT);\n\t}\n\n\treturn false;\n}\n\nstatic int rockchip_pinconf_defer_pin(struct rockchip_pin_bank *bank,\n\t\t\t\t\t unsigned int pin, u32 param, u32 arg)\n{\n\tstruct rockchip_pin_deferred *cfg;\n\n\tcfg = kzalloc(sizeof(*cfg), GFP_KERNEL);\n\tif (!cfg)\n\t\treturn -ENOMEM;\n\n\tcfg->pin = pin;\n\tcfg->param = param;\n\tcfg->arg = arg;\n\n\tlist_add_tail(&cfg->head, &bank->deferred_pins);\n\n\treturn 0;\n}\n\n \nstatic int rockchip_pinconf_set(struct pinctrl_dev *pctldev, unsigned int pin,\n\t\t\t\tunsigned long *configs, unsigned num_configs)\n{\n\tstruct rockchip_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\n\tstruct rockchip_pin_bank *bank = pin_to_bank(info, pin);\n\tstruct gpio_chip *gpio = &bank->gpio_chip;\n\tenum pin_config_param param;\n\tu32 arg;\n\tint i;\n\tint rc;\n\n\tfor (i = 0; i < num_configs; i++) {\n\t\tparam = pinconf_to_config_param(configs[i]);\n\t\targ = pinconf_to_config_argument(configs[i]);\n\n\t\tif (param == PIN_CONFIG_OUTPUT || param == PIN_CONFIG_INPUT_ENABLE) {\n\t\t\t \n\t\t\tmutex_lock(&bank->deferred_lock);\n\t\t\tif (!gpio || !gpio->direction_output) {\n\t\t\t\trc = rockchip_pinconf_defer_pin(bank, pin - bank->pin_base, param,\n\t\t\t\t\t\t\t\targ);\n\t\t\t\tmutex_unlock(&bank->deferred_lock);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmutex_unlock(&bank->deferred_lock);\n\t\t}\n\n\t\tswitch (param) {\n\t\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\t\trc =  rockchip_set_pull(bank, pin - bank->pin_base,\n\t\t\t\tparam);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\tcase PIN_CONFIG_BIAS_PULL_PIN_DEFAULT:\n\t\tcase PIN_CONFIG_BIAS_BUS_HOLD:\n\t\t\tif (!rockchip_pinconf_pull_valid(info->ctrl, param))\n\t\t\t\treturn -ENOTSUPP;\n\n\t\t\tif (!arg)\n\t\t\t\treturn -EINVAL;\n\n\t\t\trc = rockchip_set_pull(bank, pin - bank->pin_base,\n\t\t\t\tparam);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_OUTPUT:\n\t\t\trc = rockchip_set_mux(bank, pin - bank->pin_base,\n\t\t\t\t\t      RK_FUNC_GPIO);\n\t\t\tif (rc != RK_FUNC_GPIO)\n\t\t\t\treturn -EINVAL;\n\n\t\t\trc = gpio->direction_output(gpio, pin - bank->pin_base,\n\t\t\t\t\t\t    arg);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_INPUT_ENABLE:\n\t\t\trc = rockchip_set_mux(bank, pin - bank->pin_base,\n\t\t\t\t\t      RK_FUNC_GPIO);\n\t\t\tif (rc != RK_FUNC_GPIO)\n\t\t\t\treturn -EINVAL;\n\n\t\t\trc = gpio->direction_input(gpio, pin - bank->pin_base);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_DRIVE_STRENGTH:\n\t\t\t \n\t\t\tif (!info->ctrl->drv_calc_reg)\n\t\t\t\treturn -ENOTSUPP;\n\n\t\t\trc = rockchip_set_drive_perpin(bank,\n\t\t\t\t\t\tpin - bank->pin_base, arg);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_INPUT_SCHMITT_ENABLE:\n\t\t\tif (!info->ctrl->schmitt_calc_reg)\n\t\t\t\treturn -ENOTSUPP;\n\n\t\t\trc = rockchip_set_schmitt(bank,\n\t\t\t\t\t\t  pin - bank->pin_base, arg);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -ENOTSUPP;\n\t\t\tbreak;\n\t\t}\n\t}  \n\n\treturn 0;\n}\n\n \nstatic int rockchip_pinconf_get(struct pinctrl_dev *pctldev, unsigned int pin,\n\t\t\t\t\t\t\tunsigned long *config)\n{\n\tstruct rockchip_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\n\tstruct rockchip_pin_bank *bank = pin_to_bank(info, pin);\n\tstruct gpio_chip *gpio = &bank->gpio_chip;\n\tenum pin_config_param param = pinconf_to_config_param(*config);\n\tu16 arg;\n\tint rc;\n\n\tswitch (param) {\n\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\tif (rockchip_get_pull(bank, pin - bank->pin_base) != param)\n\t\t\treturn -EINVAL;\n\n\t\targ = 0;\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\tcase PIN_CONFIG_BIAS_PULL_PIN_DEFAULT:\n\tcase PIN_CONFIG_BIAS_BUS_HOLD:\n\t\tif (!rockchip_pinconf_pull_valid(info->ctrl, param))\n\t\t\treturn -ENOTSUPP;\n\n\t\tif (rockchip_get_pull(bank, pin - bank->pin_base) != param)\n\t\t\treturn -EINVAL;\n\n\t\targ = 1;\n\t\tbreak;\n\tcase PIN_CONFIG_OUTPUT:\n\t\trc = rockchip_get_mux(bank, pin - bank->pin_base);\n\t\tif (rc != RK_FUNC_GPIO)\n\t\t\treturn -EINVAL;\n\n\t\tif (!gpio || !gpio->get) {\n\t\t\targ = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\trc = gpio->get(gpio, pin - bank->pin_base);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\targ = rc ? 1 : 0;\n\t\tbreak;\n\tcase PIN_CONFIG_DRIVE_STRENGTH:\n\t\t \n\t\tif (!info->ctrl->drv_calc_reg)\n\t\t\treturn -ENOTSUPP;\n\n\t\trc = rockchip_get_drive_perpin(bank, pin - bank->pin_base);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\targ = rc;\n\t\tbreak;\n\tcase PIN_CONFIG_INPUT_SCHMITT_ENABLE:\n\t\tif (!info->ctrl->schmitt_calc_reg)\n\t\t\treturn -ENOTSUPP;\n\n\t\trc = rockchip_get_schmitt(bank, pin - bank->pin_base);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\targ = rc;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t\tbreak;\n\t}\n\n\t*config = pinconf_to_config_packed(param, arg);\n\n\treturn 0;\n}\n\nstatic const struct pinconf_ops rockchip_pinconf_ops = {\n\t.pin_config_get\t\t\t= rockchip_pinconf_get,\n\t.pin_config_set\t\t\t= rockchip_pinconf_set,\n\t.is_generic\t\t\t= true,\n};\n\nstatic const struct of_device_id rockchip_bank_match[] = {\n\t{ .compatible = \"rockchip,gpio-bank\" },\n\t{ .compatible = \"rockchip,rk3188-gpio-bank0\" },\n\t{},\n};\n\nstatic void rockchip_pinctrl_child_count(struct rockchip_pinctrl *info,\n\t\t\t\t\t\tstruct device_node *np)\n{\n\tstruct device_node *child;\n\n\tfor_each_child_of_node(np, child) {\n\t\tif (of_match_node(rockchip_bank_match, child))\n\t\t\tcontinue;\n\n\t\tinfo->nfunctions++;\n\t\tinfo->ngroups += of_get_child_count(child);\n\t}\n}\n\nstatic int rockchip_pinctrl_parse_groups(struct device_node *np,\n\t\t\t\t\t      struct rockchip_pin_group *grp,\n\t\t\t\t\t      struct rockchip_pinctrl *info,\n\t\t\t\t\t      u32 index)\n{\n\tstruct device *dev = info->dev;\n\tstruct rockchip_pin_bank *bank;\n\tint size;\n\tconst __be32 *list;\n\tint num;\n\tint i, j;\n\tint ret;\n\n\tdev_dbg(dev, \"group(%d): %pOFn\\n\", index, np);\n\n\t \n\tgrp->name = np->name;\n\n\t \n\tlist = of_get_property(np, \"rockchip,pins\", &size);\n\t \n\tsize /= sizeof(*list);\n\tif (!size || size % 4)\n\t\treturn dev_err_probe(dev, -EINVAL, \"wrong pins number or pins and configs should be by 4\\n\");\n\n\tgrp->npins = size / 4;\n\n\tgrp->pins = devm_kcalloc(dev, grp->npins, sizeof(*grp->pins), GFP_KERNEL);\n\tgrp->data = devm_kcalloc(dev, grp->npins, sizeof(*grp->data), GFP_KERNEL);\n\tif (!grp->pins || !grp->data)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0, j = 0; i < size; i += 4, j++) {\n\t\tconst __be32 *phandle;\n\t\tstruct device_node *np_config;\n\n\t\tnum = be32_to_cpu(*list++);\n\t\tbank = bank_num_to_bank(info, num);\n\t\tif (IS_ERR(bank))\n\t\t\treturn PTR_ERR(bank);\n\n\t\tgrp->pins[j] = bank->pin_base + be32_to_cpu(*list++);\n\t\tgrp->data[j].func = be32_to_cpu(*list++);\n\n\t\tphandle = list++;\n\t\tif (!phandle)\n\t\t\treturn -EINVAL;\n\n\t\tnp_config = of_find_node_by_phandle(be32_to_cpup(phandle));\n\t\tret = pinconf_generic_parse_dt_config(np_config, NULL,\n\t\t\t\t&grp->data[j].configs, &grp->data[j].nconfigs);\n\t\tof_node_put(np_config);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int rockchip_pinctrl_parse_functions(struct device_node *np,\n\t\t\t\t\t\tstruct rockchip_pinctrl *info,\n\t\t\t\t\t\tu32 index)\n{\n\tstruct device *dev = info->dev;\n\tstruct device_node *child;\n\tstruct rockchip_pmx_func *func;\n\tstruct rockchip_pin_group *grp;\n\tint ret;\n\tstatic u32 grp_index;\n\tu32 i = 0;\n\n\tdev_dbg(dev, \"parse function(%d): %pOFn\\n\", index, np);\n\n\tfunc = &info->functions[index];\n\n\t \n\tfunc->name = np->name;\n\tfunc->ngroups = of_get_child_count(np);\n\tif (func->ngroups <= 0)\n\t\treturn 0;\n\n\tfunc->groups = devm_kcalloc(dev, func->ngroups, sizeof(*func->groups), GFP_KERNEL);\n\tif (!func->groups)\n\t\treturn -ENOMEM;\n\n\tfor_each_child_of_node(np, child) {\n\t\tfunc->groups[i] = child->name;\n\t\tgrp = &info->groups[grp_index++];\n\t\tret = rockchip_pinctrl_parse_groups(child, grp, info, i++);\n\t\tif (ret) {\n\t\t\tof_node_put(child);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int rockchip_pinctrl_parse_dt(struct platform_device *pdev,\n\t\t\t\t\t      struct rockchip_pinctrl *info)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct device_node *child;\n\tint ret;\n\tint i;\n\n\trockchip_pinctrl_child_count(info, np);\n\n\tdev_dbg(dev, \"nfunctions = %d\\n\", info->nfunctions);\n\tdev_dbg(dev, \"ngroups = %d\\n\", info->ngroups);\n\n\tinfo->functions = devm_kcalloc(dev, info->nfunctions, sizeof(*info->functions), GFP_KERNEL);\n\tif (!info->functions)\n\t\treturn -ENOMEM;\n\n\tinfo->groups = devm_kcalloc(dev, info->ngroups, sizeof(*info->groups), GFP_KERNEL);\n\tif (!info->groups)\n\t\treturn -ENOMEM;\n\n\ti = 0;\n\n\tfor_each_child_of_node(np, child) {\n\t\tif (of_match_node(rockchip_bank_match, child))\n\t\t\tcontinue;\n\n\t\tret = rockchip_pinctrl_parse_functions(child, info, i++);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to parse function\\n\");\n\t\t\tof_node_put(child);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int rockchip_pinctrl_register(struct platform_device *pdev,\n\t\t\t\t\tstruct rockchip_pinctrl *info)\n{\n\tstruct pinctrl_desc *ctrldesc = &info->pctl;\n\tstruct pinctrl_pin_desc *pindesc, *pdesc;\n\tstruct rockchip_pin_bank *pin_bank;\n\tstruct device *dev = &pdev->dev;\n\tchar **pin_names;\n\tint pin, bank, ret;\n\tint k;\n\n\tctrldesc->name = \"rockchip-pinctrl\";\n\tctrldesc->owner = THIS_MODULE;\n\tctrldesc->pctlops = &rockchip_pctrl_ops;\n\tctrldesc->pmxops = &rockchip_pmx_ops;\n\tctrldesc->confops = &rockchip_pinconf_ops;\n\n\tpindesc = devm_kcalloc(dev, info->ctrl->nr_pins, sizeof(*pindesc), GFP_KERNEL);\n\tif (!pindesc)\n\t\treturn -ENOMEM;\n\n\tctrldesc->pins = pindesc;\n\tctrldesc->npins = info->ctrl->nr_pins;\n\n\tpdesc = pindesc;\n\tfor (bank = 0, k = 0; bank < info->ctrl->nr_banks; bank++) {\n\t\tpin_bank = &info->ctrl->pin_banks[bank];\n\n\t\tpin_names = devm_kasprintf_strarray(dev, pin_bank->name, pin_bank->nr_pins);\n\t\tif (IS_ERR(pin_names))\n\t\t\treturn PTR_ERR(pin_names);\n\n\t\tfor (pin = 0; pin < pin_bank->nr_pins; pin++, k++) {\n\t\t\tpdesc->number = k;\n\t\t\tpdesc->name = pin_names[pin];\n\t\t\tpdesc++;\n\t\t}\n\n\t\tINIT_LIST_HEAD(&pin_bank->deferred_pins);\n\t\tmutex_init(&pin_bank->deferred_lock);\n\t}\n\n\tret = rockchip_pinctrl_parse_dt(pdev, info);\n\tif (ret)\n\t\treturn ret;\n\n\tinfo->pctl_dev = devm_pinctrl_register(dev, ctrldesc, info);\n\tif (IS_ERR(info->pctl_dev))\n\t\treturn dev_err_probe(dev, PTR_ERR(info->pctl_dev), \"could not register pinctrl driver\\n\");\n\n\treturn 0;\n}\n\nstatic const struct of_device_id rockchip_pinctrl_dt_match[];\n\n \nstatic struct rockchip_pin_ctrl *rockchip_pinctrl_get_soc_data(\n\t\t\t\t\t\tstruct rockchip_pinctrl *d,\n\t\t\t\t\t\tstruct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *node = dev->of_node;\n\tconst struct of_device_id *match;\n\tstruct rockchip_pin_ctrl *ctrl;\n\tstruct rockchip_pin_bank *bank;\n\tint grf_offs, pmu_offs, drv_grf_offs, drv_pmu_offs, i, j;\n\n\tmatch = of_match_node(rockchip_pinctrl_dt_match, node);\n\tctrl = (struct rockchip_pin_ctrl *)match->data;\n\n\tgrf_offs = ctrl->grf_mux_offset;\n\tpmu_offs = ctrl->pmu_mux_offset;\n\tdrv_pmu_offs = ctrl->pmu_drv_offset;\n\tdrv_grf_offs = ctrl->grf_drv_offset;\n\tbank = ctrl->pin_banks;\n\tfor (i = 0; i < ctrl->nr_banks; ++i, ++bank) {\n\t\tint bank_pins = 0;\n\n\t\traw_spin_lock_init(&bank->slock);\n\t\tbank->drvdata = d;\n\t\tbank->pin_base = ctrl->nr_pins;\n\t\tctrl->nr_pins += bank->nr_pins;\n\n\t\t \n\t\tfor (j = 0; j < 4; j++) {\n\t\t\tstruct rockchip_iomux *iom = &bank->iomux[j];\n\t\t\tstruct rockchip_drv *drv = &bank->drv[j];\n\t\t\tint inc;\n\n\t\t\tif (bank_pins >= bank->nr_pins)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tif (iom->offset >= 0) {\n\t\t\t\tif ((iom->type & IOMUX_SOURCE_PMU) ||\n\t\t\t\t    (iom->type & IOMUX_L_SOURCE_PMU))\n\t\t\t\t\tpmu_offs = iom->offset;\n\t\t\t\telse\n\t\t\t\t\tgrf_offs = iom->offset;\n\t\t\t} else {  \n\t\t\t\tiom->offset = ((iom->type & IOMUX_SOURCE_PMU) ||\n\t\t\t\t\t       (iom->type & IOMUX_L_SOURCE_PMU)) ?\n\t\t\t\t\t\t\tpmu_offs : grf_offs;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (drv->offset >= 0) {\n\t\t\t\tif (iom->type & IOMUX_SOURCE_PMU)\n\t\t\t\t\tdrv_pmu_offs = drv->offset;\n\t\t\t\telse\n\t\t\t\t\tdrv_grf_offs = drv->offset;\n\t\t\t} else {  \n\t\t\t\tdrv->offset = (iom->type & IOMUX_SOURCE_PMU) ?\n\t\t\t\t\t\tdrv_pmu_offs : drv_grf_offs;\n\t\t\t}\n\n\t\t\tdev_dbg(dev, \"bank %d, iomux %d has iom_offset 0x%x drv_offset 0x%x\\n\",\n\t\t\t\ti, j, iom->offset, drv->offset);\n\n\t\t\t \n\t\t\tinc = (iom->type & (IOMUX_WIDTH_4BIT |\n\t\t\t\t\t    IOMUX_WIDTH_3BIT |\n\t\t\t\t\t    IOMUX_WIDTH_2BIT)) ? 8 : 4;\n\t\t\tif ((iom->type & IOMUX_SOURCE_PMU) || (iom->type & IOMUX_L_SOURCE_PMU))\n\t\t\t\tpmu_offs += inc;\n\t\t\telse\n\t\t\t\tgrf_offs += inc;\n\n\t\t\t \n\t\t\tif ((drv->drv_type == DRV_TYPE_IO_1V8_3V0_AUTO) ||\n\t\t\t    (drv->drv_type == DRV_TYPE_IO_3V3_ONLY))\n\t\t\t\tinc = 8;\n\t\t\telse\n\t\t\t\tinc = 4;\n\n\t\t\tif (iom->type & IOMUX_SOURCE_PMU)\n\t\t\t\tdrv_pmu_offs += inc;\n\t\t\telse\n\t\t\t\tdrv_grf_offs += inc;\n\n\t\t\tbank_pins += 8;\n\t\t}\n\n\t\t \n\t\tfor (j = 0; j < ctrl->niomux_recalced; j++) {\n\t\t\tint pin = 0;\n\n\t\t\tif (ctrl->iomux_recalced[j].num == bank->bank_num) {\n\t\t\t\tpin = ctrl->iomux_recalced[j].pin;\n\t\t\t\tbank->recalced_mask |= BIT(pin);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tfor (j = 0; j < ctrl->niomux_routes; j++) {\n\t\t\tint pin = 0;\n\n\t\t\tif (ctrl->iomux_routes[j].bank_num == bank->bank_num) {\n\t\t\t\tpin = ctrl->iomux_routes[j].pin;\n\t\t\t\tbank->route_mask |= BIT(pin);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ctrl;\n}\n\n#define RK3288_GRF_GPIO6C_IOMUX\t\t0x64\n#define GPIO6C6_SEL_WRITE_ENABLE\tBIT(28)\n\nstatic u32 rk3288_grf_gpio6c_iomux;\n\nstatic int __maybe_unused rockchip_pinctrl_suspend(struct device *dev)\n{\n\tstruct rockchip_pinctrl *info = dev_get_drvdata(dev);\n\tint ret = pinctrl_force_sleep(info->pctl_dev);\n\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (info->ctrl->type == RK3288) {\n\t\tret = regmap_read(info->regmap_base, RK3288_GRF_GPIO6C_IOMUX,\n\t\t\t\t  &rk3288_grf_gpio6c_iomux);\n\t\tif (ret) {\n\t\t\tpinctrl_force_default(info->pctl_dev);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused rockchip_pinctrl_resume(struct device *dev)\n{\n\tstruct rockchip_pinctrl *info = dev_get_drvdata(dev);\n\tint ret;\n\n\tif (info->ctrl->type == RK3288) {\n\t\tret = regmap_write(info->regmap_base, RK3288_GRF_GPIO6C_IOMUX,\n\t\t\t\t   rk3288_grf_gpio6c_iomux |\n\t\t\t\t   GPIO6C6_SEL_WRITE_ENABLE);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn pinctrl_force_default(info->pctl_dev);\n}\n\nstatic SIMPLE_DEV_PM_OPS(rockchip_pinctrl_dev_pm_ops, rockchip_pinctrl_suspend,\n\t\t\t rockchip_pinctrl_resume);\n\nstatic int rockchip_pinctrl_probe(struct platform_device *pdev)\n{\n\tstruct rockchip_pinctrl *info;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node, *node;\n\tstruct rockchip_pin_ctrl *ctrl;\n\tstruct resource *res;\n\tvoid __iomem *base;\n\tint ret;\n\n\tif (!dev->of_node)\n\t\treturn dev_err_probe(dev, -ENODEV, \"device tree node not found\\n\");\n\n\tinfo = devm_kzalloc(dev, sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinfo->dev = dev;\n\n\tctrl = rockchip_pinctrl_get_soc_data(info, pdev);\n\tif (!ctrl)\n\t\treturn dev_err_probe(dev, -EINVAL, \"driver data not available\\n\");\n\tinfo->ctrl = ctrl;\n\n\tnode = of_parse_phandle(np, \"rockchip,grf\", 0);\n\tif (node) {\n\t\tinfo->regmap_base = syscon_node_to_regmap(node);\n\t\tof_node_put(node);\n\t\tif (IS_ERR(info->regmap_base))\n\t\t\treturn PTR_ERR(info->regmap_base);\n\t} else {\n\t\tbase = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\t\tif (IS_ERR(base))\n\t\t\treturn PTR_ERR(base);\n\n\t\trockchip_regmap_config.max_register = resource_size(res) - 4;\n\t\trockchip_regmap_config.name = \"rockchip,pinctrl\";\n\t\tinfo->regmap_base =\n\t\t\tdevm_regmap_init_mmio(dev, base, &rockchip_regmap_config);\n\n\t\t \n\t\tinfo->reg_size = resource_size(res);\n\n\t\t \n\t\tif (ctrl->type == RK3188 && info->reg_size < 0x200) {\n\t\t\tbase = devm_platform_get_and_ioremap_resource(pdev, 1, &res);\n\t\t\tif (IS_ERR(base))\n\t\t\t\treturn PTR_ERR(base);\n\n\t\t\trockchip_regmap_config.max_register = resource_size(res) - 4;\n\t\t\trockchip_regmap_config.name = \"rockchip,pinctrl-pull\";\n\t\t\tinfo->regmap_pull =\n\t\t\t\tdevm_regmap_init_mmio(dev, base, &rockchip_regmap_config);\n\t\t}\n\t}\n\n\t \n\tnode = of_parse_phandle(np, \"rockchip,pmu\", 0);\n\tif (node) {\n\t\tinfo->regmap_pmu = syscon_node_to_regmap(node);\n\t\tof_node_put(node);\n\t\tif (IS_ERR(info->regmap_pmu))\n\t\t\treturn PTR_ERR(info->regmap_pmu);\n\t}\n\n\tret = rockchip_pinctrl_register(pdev, info);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, info);\n\n\tret = of_platform_populate(np, NULL, NULL, &pdev->dev);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"failed to register gpio device\\n\");\n\n\treturn 0;\n}\n\nstatic int rockchip_pinctrl_remove(struct platform_device *pdev)\n{\n\tstruct rockchip_pinctrl *info = platform_get_drvdata(pdev);\n\tstruct rockchip_pin_bank *bank;\n\tstruct rockchip_pin_deferred *cfg;\n\tint i;\n\n\tof_platform_depopulate(&pdev->dev);\n\n\tfor (i = 0; i < info->ctrl->nr_banks; i++) {\n\t\tbank = &info->ctrl->pin_banks[i];\n\n\t\tmutex_lock(&bank->deferred_lock);\n\t\twhile (!list_empty(&bank->deferred_pins)) {\n\t\t\tcfg = list_first_entry(&bank->deferred_pins,\n\t\t\t\t\t       struct rockchip_pin_deferred, head);\n\t\t\tlist_del(&cfg->head);\n\t\t\tkfree(cfg);\n\t\t}\n\t\tmutex_unlock(&bank->deferred_lock);\n\t}\n\n\treturn 0;\n}\n\nstatic struct rockchip_pin_bank px30_pin_banks[] = {\n\tPIN_BANK_IOMUX_FLAGS(0, 32, \"gpio0\", IOMUX_SOURCE_PMU,\n\t\t\t\t\t     IOMUX_SOURCE_PMU,\n\t\t\t\t\t     IOMUX_SOURCE_PMU,\n\t\t\t\t\t     IOMUX_SOURCE_PMU\n\t\t\t    ),\n\tPIN_BANK_IOMUX_FLAGS(1, 32, \"gpio1\", IOMUX_WIDTH_4BIT,\n\t\t\t\t\t     IOMUX_WIDTH_4BIT,\n\t\t\t\t\t     IOMUX_WIDTH_4BIT,\n\t\t\t\t\t     IOMUX_WIDTH_4BIT\n\t\t\t    ),\n\tPIN_BANK_IOMUX_FLAGS(2, 32, \"gpio2\", IOMUX_WIDTH_4BIT,\n\t\t\t\t\t     IOMUX_WIDTH_4BIT,\n\t\t\t\t\t     IOMUX_WIDTH_4BIT,\n\t\t\t\t\t     IOMUX_WIDTH_4BIT\n\t\t\t    ),\n\tPIN_BANK_IOMUX_FLAGS(3, 32, \"gpio3\", IOMUX_WIDTH_4BIT,\n\t\t\t\t\t     IOMUX_WIDTH_4BIT,\n\t\t\t\t\t     IOMUX_WIDTH_4BIT,\n\t\t\t\t\t     IOMUX_WIDTH_4BIT\n\t\t\t    ),\n};\n\nstatic struct rockchip_pin_ctrl px30_pin_ctrl = {\n\t\t.pin_banks\t\t= px30_pin_banks,\n\t\t.nr_banks\t\t= ARRAY_SIZE(px30_pin_banks),\n\t\t.label\t\t\t= \"PX30-GPIO\",\n\t\t.type\t\t\t= PX30,\n\t\t.grf_mux_offset\t\t= 0x0,\n\t\t.pmu_mux_offset\t\t= 0x0,\n\t\t.iomux_routes\t\t= px30_mux_route_data,\n\t\t.niomux_routes\t\t= ARRAY_SIZE(px30_mux_route_data),\n\t\t.pull_calc_reg\t\t= px30_calc_pull_reg_and_bit,\n\t\t.drv_calc_reg\t\t= px30_calc_drv_reg_and_bit,\n\t\t.schmitt_calc_reg\t= px30_calc_schmitt_reg_and_bit,\n};\n\nstatic struct rockchip_pin_bank rv1108_pin_banks[] = {\n\tPIN_BANK_IOMUX_FLAGS(0, 32, \"gpio0\", IOMUX_SOURCE_PMU,\n\t\t\t\t\t     IOMUX_SOURCE_PMU,\n\t\t\t\t\t     IOMUX_SOURCE_PMU,\n\t\t\t\t\t     IOMUX_SOURCE_PMU),\n\tPIN_BANK_IOMUX_FLAGS(1, 32, \"gpio1\", 0, 0, 0, 0),\n\tPIN_BANK_IOMUX_FLAGS(2, 32, \"gpio2\", 0, 0, 0, 0),\n\tPIN_BANK_IOMUX_FLAGS(3, 32, \"gpio3\", 0, 0, 0, 0),\n};\n\nstatic struct rockchip_pin_ctrl rv1108_pin_ctrl = {\n\t.pin_banks\t\t= rv1108_pin_banks,\n\t.nr_banks\t\t= ARRAY_SIZE(rv1108_pin_banks),\n\t.label\t\t\t= \"RV1108-GPIO\",\n\t.type\t\t\t= RV1108,\n\t.grf_mux_offset\t\t= 0x10,\n\t.pmu_mux_offset\t\t= 0x0,\n\t.iomux_recalced\t\t= rv1108_mux_recalced_data,\n\t.niomux_recalced\t= ARRAY_SIZE(rv1108_mux_recalced_data),\n\t.pull_calc_reg\t\t= rv1108_calc_pull_reg_and_bit,\n\t.drv_calc_reg\t\t= rv1108_calc_drv_reg_and_bit,\n\t.schmitt_calc_reg\t= rv1108_calc_schmitt_reg_and_bit,\n};\n\nstatic struct rockchip_pin_bank rv1126_pin_banks[] = {\n\tPIN_BANK_IOMUX_FLAGS(0, 32, \"gpio0\",\n\t\t\t     IOMUX_WIDTH_4BIT | IOMUX_SOURCE_PMU,\n\t\t\t     IOMUX_WIDTH_4BIT | IOMUX_SOURCE_PMU,\n\t\t\t     IOMUX_WIDTH_4BIT | IOMUX_L_SOURCE_PMU,\n\t\t\t     IOMUX_WIDTH_4BIT),\n\tPIN_BANK_IOMUX_FLAGS_OFFSET(1, 32, \"gpio1\",\n\t\t\t\t    IOMUX_WIDTH_4BIT,\n\t\t\t\t    IOMUX_WIDTH_4BIT,\n\t\t\t\t    IOMUX_WIDTH_4BIT,\n\t\t\t\t    IOMUX_WIDTH_4BIT,\n\t\t\t\t    0x10010, 0x10018, 0x10020, 0x10028),\n\tPIN_BANK_IOMUX_FLAGS(2, 32, \"gpio2\",\n\t\t\t     IOMUX_WIDTH_4BIT,\n\t\t\t     IOMUX_WIDTH_4BIT,\n\t\t\t     IOMUX_WIDTH_4BIT,\n\t\t\t     IOMUX_WIDTH_4BIT),\n\tPIN_BANK_IOMUX_FLAGS(3, 32, \"gpio3\",\n\t\t\t     IOMUX_WIDTH_4BIT,\n\t\t\t     IOMUX_WIDTH_4BIT,\n\t\t\t     IOMUX_WIDTH_4BIT,\n\t\t\t     IOMUX_WIDTH_4BIT),\n\tPIN_BANK_IOMUX_FLAGS(4, 2, \"gpio4\",\n\t\t\t     IOMUX_WIDTH_4BIT, 0, 0, 0),\n};\n\nstatic struct rockchip_pin_ctrl rv1126_pin_ctrl = {\n\t.pin_banks\t\t= rv1126_pin_banks,\n\t.nr_banks\t\t= ARRAY_SIZE(rv1126_pin_banks),\n\t.label\t\t\t= \"RV1126-GPIO\",\n\t.type\t\t\t= RV1126,\n\t.grf_mux_offset\t\t= 0x10004,  \n\t.pmu_mux_offset\t\t= 0x0,\n\t.iomux_routes\t\t= rv1126_mux_route_data,\n\t.niomux_routes\t\t= ARRAY_SIZE(rv1126_mux_route_data),\n\t.iomux_recalced\t\t= rv1126_mux_recalced_data,\n\t.niomux_recalced\t= ARRAY_SIZE(rv1126_mux_recalced_data),\n\t.pull_calc_reg\t\t= rv1126_calc_pull_reg_and_bit,\n\t.drv_calc_reg\t\t= rv1126_calc_drv_reg_and_bit,\n\t.schmitt_calc_reg\t= rv1126_calc_schmitt_reg_and_bit,\n};\n\nstatic struct rockchip_pin_bank rk2928_pin_banks[] = {\n\tPIN_BANK(0, 32, \"gpio0\"),\n\tPIN_BANK(1, 32, \"gpio1\"),\n\tPIN_BANK(2, 32, \"gpio2\"),\n\tPIN_BANK(3, 32, \"gpio3\"),\n};\n\nstatic struct rockchip_pin_ctrl rk2928_pin_ctrl = {\n\t\t.pin_banks\t\t= rk2928_pin_banks,\n\t\t.nr_banks\t\t= ARRAY_SIZE(rk2928_pin_banks),\n\t\t.label\t\t\t= \"RK2928-GPIO\",\n\t\t.type\t\t\t= RK2928,\n\t\t.grf_mux_offset\t\t= 0xa8,\n\t\t.pull_calc_reg\t\t= rk2928_calc_pull_reg_and_bit,\n};\n\nstatic struct rockchip_pin_bank rk3036_pin_banks[] = {\n\tPIN_BANK(0, 32, \"gpio0\"),\n\tPIN_BANK(1, 32, \"gpio1\"),\n\tPIN_BANK(2, 32, \"gpio2\"),\n};\n\nstatic struct rockchip_pin_ctrl rk3036_pin_ctrl = {\n\t\t.pin_banks\t\t= rk3036_pin_banks,\n\t\t.nr_banks\t\t= ARRAY_SIZE(rk3036_pin_banks),\n\t\t.label\t\t\t= \"RK3036-GPIO\",\n\t\t.type\t\t\t= RK2928,\n\t\t.grf_mux_offset\t\t= 0xa8,\n\t\t.pull_calc_reg\t\t= rk2928_calc_pull_reg_and_bit,\n};\n\nstatic struct rockchip_pin_bank rk3066a_pin_banks[] = {\n\tPIN_BANK(0, 32, \"gpio0\"),\n\tPIN_BANK(1, 32, \"gpio1\"),\n\tPIN_BANK(2, 32, \"gpio2\"),\n\tPIN_BANK(3, 32, \"gpio3\"),\n\tPIN_BANK(4, 32, \"gpio4\"),\n\tPIN_BANK(6, 16, \"gpio6\"),\n};\n\nstatic struct rockchip_pin_ctrl rk3066a_pin_ctrl = {\n\t\t.pin_banks\t\t= rk3066a_pin_banks,\n\t\t.nr_banks\t\t= ARRAY_SIZE(rk3066a_pin_banks),\n\t\t.label\t\t\t= \"RK3066a-GPIO\",\n\t\t.type\t\t\t= RK2928,\n\t\t.grf_mux_offset\t\t= 0xa8,\n\t\t.pull_calc_reg\t\t= rk2928_calc_pull_reg_and_bit,\n};\n\nstatic struct rockchip_pin_bank rk3066b_pin_banks[] = {\n\tPIN_BANK(0, 32, \"gpio0\"),\n\tPIN_BANK(1, 32, \"gpio1\"),\n\tPIN_BANK(2, 32, \"gpio2\"),\n\tPIN_BANK(3, 32, \"gpio3\"),\n};\n\nstatic struct rockchip_pin_ctrl rk3066b_pin_ctrl = {\n\t\t.pin_banks\t= rk3066b_pin_banks,\n\t\t.nr_banks\t= ARRAY_SIZE(rk3066b_pin_banks),\n\t\t.label\t\t= \"RK3066b-GPIO\",\n\t\t.type\t\t= RK3066B,\n\t\t.grf_mux_offset\t= 0x60,\n};\n\nstatic struct rockchip_pin_bank rk3128_pin_banks[] = {\n\tPIN_BANK(0, 32, \"gpio0\"),\n\tPIN_BANK(1, 32, \"gpio1\"),\n\tPIN_BANK(2, 32, \"gpio2\"),\n\tPIN_BANK(3, 32, \"gpio3\"),\n};\n\nstatic struct rockchip_pin_ctrl rk3128_pin_ctrl = {\n\t\t.pin_banks\t\t= rk3128_pin_banks,\n\t\t.nr_banks\t\t= ARRAY_SIZE(rk3128_pin_banks),\n\t\t.label\t\t\t= \"RK3128-GPIO\",\n\t\t.type\t\t\t= RK3128,\n\t\t.grf_mux_offset\t\t= 0xa8,\n\t\t.iomux_recalced\t\t= rk3128_mux_recalced_data,\n\t\t.niomux_recalced\t= ARRAY_SIZE(rk3128_mux_recalced_data),\n\t\t.iomux_routes\t\t= rk3128_mux_route_data,\n\t\t.niomux_routes\t\t= ARRAY_SIZE(rk3128_mux_route_data),\n\t\t.pull_calc_reg\t\t= rk3128_calc_pull_reg_and_bit,\n};\n\nstatic struct rockchip_pin_bank rk3188_pin_banks[] = {\n\tPIN_BANK_IOMUX_FLAGS(0, 32, \"gpio0\", IOMUX_GPIO_ONLY, 0, 0, 0),\n\tPIN_BANK(1, 32, \"gpio1\"),\n\tPIN_BANK(2, 32, \"gpio2\"),\n\tPIN_BANK(3, 32, \"gpio3\"),\n};\n\nstatic struct rockchip_pin_ctrl rk3188_pin_ctrl = {\n\t\t.pin_banks\t\t= rk3188_pin_banks,\n\t\t.nr_banks\t\t= ARRAY_SIZE(rk3188_pin_banks),\n\t\t.label\t\t\t= \"RK3188-GPIO\",\n\t\t.type\t\t\t= RK3188,\n\t\t.grf_mux_offset\t\t= 0x60,\n\t\t.iomux_routes\t\t= rk3188_mux_route_data,\n\t\t.niomux_routes\t\t= ARRAY_SIZE(rk3188_mux_route_data),\n\t\t.pull_calc_reg\t\t= rk3188_calc_pull_reg_and_bit,\n};\n\nstatic struct rockchip_pin_bank rk3228_pin_banks[] = {\n\tPIN_BANK(0, 32, \"gpio0\"),\n\tPIN_BANK(1, 32, \"gpio1\"),\n\tPIN_BANK(2, 32, \"gpio2\"),\n\tPIN_BANK(3, 32, \"gpio3\"),\n};\n\nstatic struct rockchip_pin_ctrl rk3228_pin_ctrl = {\n\t\t.pin_banks\t\t= rk3228_pin_banks,\n\t\t.nr_banks\t\t= ARRAY_SIZE(rk3228_pin_banks),\n\t\t.label\t\t\t= \"RK3228-GPIO\",\n\t\t.type\t\t\t= RK3288,\n\t\t.grf_mux_offset\t\t= 0x0,\n\t\t.iomux_routes\t\t= rk3228_mux_route_data,\n\t\t.niomux_routes\t\t= ARRAY_SIZE(rk3228_mux_route_data),\n\t\t.pull_calc_reg\t\t= rk3228_calc_pull_reg_and_bit,\n\t\t.drv_calc_reg\t\t= rk3228_calc_drv_reg_and_bit,\n};\n\nstatic struct rockchip_pin_bank rk3288_pin_banks[] = {\n\tPIN_BANK_IOMUX_FLAGS(0, 24, \"gpio0\", IOMUX_SOURCE_PMU,\n\t\t\t\t\t     IOMUX_SOURCE_PMU,\n\t\t\t\t\t     IOMUX_SOURCE_PMU,\n\t\t\t\t\t     IOMUX_UNROUTED\n\t\t\t    ),\n\tPIN_BANK_IOMUX_FLAGS(1, 32, \"gpio1\", IOMUX_UNROUTED,\n\t\t\t\t\t     IOMUX_UNROUTED,\n\t\t\t\t\t     IOMUX_UNROUTED,\n\t\t\t\t\t     0\n\t\t\t    ),\n\tPIN_BANK_IOMUX_FLAGS(2, 32, \"gpio2\", 0, 0, 0, IOMUX_UNROUTED),\n\tPIN_BANK_IOMUX_FLAGS(3, 32, \"gpio3\", 0, 0, 0, IOMUX_WIDTH_4BIT),\n\tPIN_BANK_IOMUX_FLAGS(4, 32, \"gpio4\", IOMUX_WIDTH_4BIT,\n\t\t\t\t\t     IOMUX_WIDTH_4BIT,\n\t\t\t\t\t     0,\n\t\t\t\t\t     0\n\t\t\t    ),\n\tPIN_BANK_IOMUX_FLAGS(5, 32, \"gpio5\", IOMUX_UNROUTED,\n\t\t\t\t\t     0,\n\t\t\t\t\t     0,\n\t\t\t\t\t     IOMUX_UNROUTED\n\t\t\t    ),\n\tPIN_BANK_IOMUX_FLAGS(6, 32, \"gpio6\", 0, 0, 0, IOMUX_UNROUTED),\n\tPIN_BANK_IOMUX_FLAGS(7, 32, \"gpio7\", 0,\n\t\t\t\t\t     0,\n\t\t\t\t\t     IOMUX_WIDTH_4BIT,\n\t\t\t\t\t     IOMUX_UNROUTED\n\t\t\t    ),\n\tPIN_BANK(8, 16, \"gpio8\"),\n};\n\nstatic struct rockchip_pin_ctrl rk3288_pin_ctrl = {\n\t\t.pin_banks\t\t= rk3288_pin_banks,\n\t\t.nr_banks\t\t= ARRAY_SIZE(rk3288_pin_banks),\n\t\t.label\t\t\t= \"RK3288-GPIO\",\n\t\t.type\t\t\t= RK3288,\n\t\t.grf_mux_offset\t\t= 0x0,\n\t\t.pmu_mux_offset\t\t= 0x84,\n\t\t.iomux_routes\t\t= rk3288_mux_route_data,\n\t\t.niomux_routes\t\t= ARRAY_SIZE(rk3288_mux_route_data),\n\t\t.pull_calc_reg\t\t= rk3288_calc_pull_reg_and_bit,\n\t\t.drv_calc_reg\t\t= rk3288_calc_drv_reg_and_bit,\n};\n\nstatic struct rockchip_pin_bank rk3308_pin_banks[] = {\n\tPIN_BANK_IOMUX_FLAGS(0, 32, \"gpio0\", IOMUX_WIDTH_2BIT,\n\t\t\t\t\t     IOMUX_WIDTH_2BIT,\n\t\t\t\t\t     IOMUX_WIDTH_2BIT,\n\t\t\t\t\t     IOMUX_WIDTH_2BIT),\n\tPIN_BANK_IOMUX_FLAGS(1, 32, \"gpio1\", IOMUX_WIDTH_2BIT,\n\t\t\t\t\t     IOMUX_WIDTH_2BIT,\n\t\t\t\t\t     IOMUX_WIDTH_2BIT,\n\t\t\t\t\t     IOMUX_WIDTH_2BIT),\n\tPIN_BANK_IOMUX_FLAGS(2, 32, \"gpio2\", IOMUX_WIDTH_2BIT,\n\t\t\t\t\t     IOMUX_WIDTH_2BIT,\n\t\t\t\t\t     IOMUX_WIDTH_2BIT,\n\t\t\t\t\t     IOMUX_WIDTH_2BIT),\n\tPIN_BANK_IOMUX_FLAGS(3, 32, \"gpio3\", IOMUX_WIDTH_2BIT,\n\t\t\t\t\t     IOMUX_WIDTH_2BIT,\n\t\t\t\t\t     IOMUX_WIDTH_2BIT,\n\t\t\t\t\t     IOMUX_WIDTH_2BIT),\n\tPIN_BANK_IOMUX_FLAGS(4, 32, \"gpio4\", IOMUX_WIDTH_2BIT,\n\t\t\t\t\t     IOMUX_WIDTH_2BIT,\n\t\t\t\t\t     IOMUX_WIDTH_2BIT,\n\t\t\t\t\t     IOMUX_WIDTH_2BIT),\n};\n\nstatic struct rockchip_pin_ctrl rk3308_pin_ctrl = {\n\t\t.pin_banks\t\t= rk3308_pin_banks,\n\t\t.nr_banks\t\t= ARRAY_SIZE(rk3308_pin_banks),\n\t\t.label\t\t\t= \"RK3308-GPIO\",\n\t\t.type\t\t\t= RK3308,\n\t\t.grf_mux_offset\t\t= 0x0,\n\t\t.iomux_recalced\t\t= rk3308_mux_recalced_data,\n\t\t.niomux_recalced\t= ARRAY_SIZE(rk3308_mux_recalced_data),\n\t\t.iomux_routes\t\t= rk3308_mux_route_data,\n\t\t.niomux_routes\t\t= ARRAY_SIZE(rk3308_mux_route_data),\n\t\t.pull_calc_reg\t\t= rk3308_calc_pull_reg_and_bit,\n\t\t.drv_calc_reg\t\t= rk3308_calc_drv_reg_and_bit,\n\t\t.schmitt_calc_reg\t= rk3308_calc_schmitt_reg_and_bit,\n};\n\nstatic struct rockchip_pin_bank rk3328_pin_banks[] = {\n\tPIN_BANK_IOMUX_FLAGS(0, 32, \"gpio0\", 0, 0, 0, 0),\n\tPIN_BANK_IOMUX_FLAGS(1, 32, \"gpio1\", 0, 0, 0, 0),\n\tPIN_BANK_IOMUX_FLAGS(2, 32, \"gpio2\", 0,\n\t\t\t     IOMUX_WIDTH_3BIT,\n\t\t\t     IOMUX_WIDTH_3BIT,\n\t\t\t     0),\n\tPIN_BANK_IOMUX_FLAGS(3, 32, \"gpio3\",\n\t\t\t     IOMUX_WIDTH_3BIT,\n\t\t\t     IOMUX_WIDTH_3BIT,\n\t\t\t     0,\n\t\t\t     0),\n};\n\nstatic struct rockchip_pin_ctrl rk3328_pin_ctrl = {\n\t\t.pin_banks\t\t= rk3328_pin_banks,\n\t\t.nr_banks\t\t= ARRAY_SIZE(rk3328_pin_banks),\n\t\t.label\t\t\t= \"RK3328-GPIO\",\n\t\t.type\t\t\t= RK3288,\n\t\t.grf_mux_offset\t\t= 0x0,\n\t\t.iomux_recalced\t\t= rk3328_mux_recalced_data,\n\t\t.niomux_recalced\t= ARRAY_SIZE(rk3328_mux_recalced_data),\n\t\t.iomux_routes\t\t= rk3328_mux_route_data,\n\t\t.niomux_routes\t\t= ARRAY_SIZE(rk3328_mux_route_data),\n\t\t.pull_calc_reg\t\t= rk3228_calc_pull_reg_and_bit,\n\t\t.drv_calc_reg\t\t= rk3228_calc_drv_reg_and_bit,\n\t\t.schmitt_calc_reg\t= rk3328_calc_schmitt_reg_and_bit,\n};\n\nstatic struct rockchip_pin_bank rk3368_pin_banks[] = {\n\tPIN_BANK_IOMUX_FLAGS(0, 32, \"gpio0\", IOMUX_SOURCE_PMU,\n\t\t\t\t\t     IOMUX_SOURCE_PMU,\n\t\t\t\t\t     IOMUX_SOURCE_PMU,\n\t\t\t\t\t     IOMUX_SOURCE_PMU\n\t\t\t    ),\n\tPIN_BANK(1, 32, \"gpio1\"),\n\tPIN_BANK(2, 32, \"gpio2\"),\n\tPIN_BANK(3, 32, \"gpio3\"),\n};\n\nstatic struct rockchip_pin_ctrl rk3368_pin_ctrl = {\n\t\t.pin_banks\t\t= rk3368_pin_banks,\n\t\t.nr_banks\t\t= ARRAY_SIZE(rk3368_pin_banks),\n\t\t.label\t\t\t= \"RK3368-GPIO\",\n\t\t.type\t\t\t= RK3368,\n\t\t.grf_mux_offset\t\t= 0x0,\n\t\t.pmu_mux_offset\t\t= 0x0,\n\t\t.pull_calc_reg\t\t= rk3368_calc_pull_reg_and_bit,\n\t\t.drv_calc_reg\t\t= rk3368_calc_drv_reg_and_bit,\n};\n\nstatic struct rockchip_pin_bank rk3399_pin_banks[] = {\n\tPIN_BANK_IOMUX_FLAGS_DRV_FLAGS_OFFSET_PULL_FLAGS(0, 32, \"gpio0\",\n\t\t\t\t\t\t\t IOMUX_SOURCE_PMU,\n\t\t\t\t\t\t\t IOMUX_SOURCE_PMU,\n\t\t\t\t\t\t\t IOMUX_SOURCE_PMU,\n\t\t\t\t\t\t\t IOMUX_SOURCE_PMU,\n\t\t\t\t\t\t\t DRV_TYPE_IO_1V8_ONLY,\n\t\t\t\t\t\t\t DRV_TYPE_IO_1V8_ONLY,\n\t\t\t\t\t\t\t DRV_TYPE_IO_DEFAULT,\n\t\t\t\t\t\t\t DRV_TYPE_IO_DEFAULT,\n\t\t\t\t\t\t\t 0x80,\n\t\t\t\t\t\t\t 0x88,\n\t\t\t\t\t\t\t -1,\n\t\t\t\t\t\t\t -1,\n\t\t\t\t\t\t\t PULL_TYPE_IO_1V8_ONLY,\n\t\t\t\t\t\t\t PULL_TYPE_IO_1V8_ONLY,\n\t\t\t\t\t\t\t PULL_TYPE_IO_DEFAULT,\n\t\t\t\t\t\t\t PULL_TYPE_IO_DEFAULT\n\t\t\t\t\t\t\t),\n\tPIN_BANK_IOMUX_DRV_FLAGS_OFFSET(1, 32, \"gpio1\", IOMUX_SOURCE_PMU,\n\t\t\t\t\tIOMUX_SOURCE_PMU,\n\t\t\t\t\tIOMUX_SOURCE_PMU,\n\t\t\t\t\tIOMUX_SOURCE_PMU,\n\t\t\t\t\tDRV_TYPE_IO_1V8_OR_3V0,\n\t\t\t\t\tDRV_TYPE_IO_1V8_OR_3V0,\n\t\t\t\t\tDRV_TYPE_IO_1V8_OR_3V0,\n\t\t\t\t\tDRV_TYPE_IO_1V8_OR_3V0,\n\t\t\t\t\t0xa0,\n\t\t\t\t\t0xa8,\n\t\t\t\t\t0xb0,\n\t\t\t\t\t0xb8\n\t\t\t\t\t),\n\tPIN_BANK_DRV_FLAGS_PULL_FLAGS(2, 32, \"gpio2\", DRV_TYPE_IO_1V8_OR_3V0,\n\t\t\t\t      DRV_TYPE_IO_1V8_OR_3V0,\n\t\t\t\t      DRV_TYPE_IO_1V8_ONLY,\n\t\t\t\t      DRV_TYPE_IO_1V8_ONLY,\n\t\t\t\t      PULL_TYPE_IO_DEFAULT,\n\t\t\t\t      PULL_TYPE_IO_DEFAULT,\n\t\t\t\t      PULL_TYPE_IO_1V8_ONLY,\n\t\t\t\t      PULL_TYPE_IO_1V8_ONLY\n\t\t\t\t      ),\n\tPIN_BANK_DRV_FLAGS(3, 32, \"gpio3\", DRV_TYPE_IO_3V3_ONLY,\n\t\t\t   DRV_TYPE_IO_3V3_ONLY,\n\t\t\t   DRV_TYPE_IO_3V3_ONLY,\n\t\t\t   DRV_TYPE_IO_1V8_OR_3V0\n\t\t\t   ),\n\tPIN_BANK_DRV_FLAGS(4, 32, \"gpio4\", DRV_TYPE_IO_1V8_OR_3V0,\n\t\t\t   DRV_TYPE_IO_1V8_3V0_AUTO,\n\t\t\t   DRV_TYPE_IO_1V8_OR_3V0,\n\t\t\t   DRV_TYPE_IO_1V8_OR_3V0\n\t\t\t   ),\n};\n\nstatic struct rockchip_pin_ctrl rk3399_pin_ctrl = {\n\t\t.pin_banks\t\t= rk3399_pin_banks,\n\t\t.nr_banks\t\t= ARRAY_SIZE(rk3399_pin_banks),\n\t\t.label\t\t\t= \"RK3399-GPIO\",\n\t\t.type\t\t\t= RK3399,\n\t\t.grf_mux_offset\t\t= 0xe000,\n\t\t.pmu_mux_offset\t\t= 0x0,\n\t\t.grf_drv_offset\t\t= 0xe100,\n\t\t.pmu_drv_offset\t\t= 0x80,\n\t\t.iomux_routes\t\t= rk3399_mux_route_data,\n\t\t.niomux_routes\t\t= ARRAY_SIZE(rk3399_mux_route_data),\n\t\t.pull_calc_reg\t\t= rk3399_calc_pull_reg_and_bit,\n\t\t.drv_calc_reg\t\t= rk3399_calc_drv_reg_and_bit,\n};\n\nstatic struct rockchip_pin_bank rk3568_pin_banks[] = {\n\tPIN_BANK_IOMUX_FLAGS(0, 32, \"gpio0\", IOMUX_SOURCE_PMU | IOMUX_WIDTH_4BIT,\n\t\t\t\t\t     IOMUX_SOURCE_PMU | IOMUX_WIDTH_4BIT,\n\t\t\t\t\t     IOMUX_SOURCE_PMU | IOMUX_WIDTH_4BIT,\n\t\t\t\t\t     IOMUX_SOURCE_PMU | IOMUX_WIDTH_4BIT),\n\tPIN_BANK_IOMUX_FLAGS(1, 32, \"gpio1\", IOMUX_WIDTH_4BIT,\n\t\t\t\t\t     IOMUX_WIDTH_4BIT,\n\t\t\t\t\t     IOMUX_WIDTH_4BIT,\n\t\t\t\t\t     IOMUX_WIDTH_4BIT),\n\tPIN_BANK_IOMUX_FLAGS(2, 32, \"gpio2\", IOMUX_WIDTH_4BIT,\n\t\t\t\t\t     IOMUX_WIDTH_4BIT,\n\t\t\t\t\t     IOMUX_WIDTH_4BIT,\n\t\t\t\t\t     IOMUX_WIDTH_4BIT),\n\tPIN_BANK_IOMUX_FLAGS(3, 32, \"gpio3\", IOMUX_WIDTH_4BIT,\n\t\t\t\t\t     IOMUX_WIDTH_4BIT,\n\t\t\t\t\t     IOMUX_WIDTH_4BIT,\n\t\t\t\t\t     IOMUX_WIDTH_4BIT),\n\tPIN_BANK_IOMUX_FLAGS(4, 32, \"gpio4\", IOMUX_WIDTH_4BIT,\n\t\t\t\t\t     IOMUX_WIDTH_4BIT,\n\t\t\t\t\t     IOMUX_WIDTH_4BIT,\n\t\t\t\t\t     IOMUX_WIDTH_4BIT),\n};\n\nstatic struct rockchip_pin_ctrl rk3568_pin_ctrl = {\n\t.pin_banks\t\t= rk3568_pin_banks,\n\t.nr_banks\t\t= ARRAY_SIZE(rk3568_pin_banks),\n\t.label\t\t\t= \"RK3568-GPIO\",\n\t.type\t\t\t= RK3568,\n\t.grf_mux_offset\t\t= 0x0,\n\t.pmu_mux_offset\t\t= 0x0,\n\t.grf_drv_offset\t\t= 0x0200,\n\t.pmu_drv_offset\t\t= 0x0070,\n\t.iomux_routes\t\t= rk3568_mux_route_data,\n\t.niomux_routes\t\t= ARRAY_SIZE(rk3568_mux_route_data),\n\t.pull_calc_reg\t\t= rk3568_calc_pull_reg_and_bit,\n\t.drv_calc_reg\t\t= rk3568_calc_drv_reg_and_bit,\n\t.schmitt_calc_reg\t= rk3568_calc_schmitt_reg_and_bit,\n};\n\nstatic struct rockchip_pin_bank rk3588_pin_banks[] = {\n\tRK3588_PIN_BANK_FLAGS(0, 32, \"gpio0\",\n\t\t\t      IOMUX_WIDTH_4BIT, PULL_TYPE_IO_1V8_ONLY),\n\tRK3588_PIN_BANK_FLAGS(1, 32, \"gpio1\",\n\t\t\t      IOMUX_WIDTH_4BIT, PULL_TYPE_IO_1V8_ONLY),\n\tRK3588_PIN_BANK_FLAGS(2, 32, \"gpio2\",\n\t\t\t      IOMUX_WIDTH_4BIT, PULL_TYPE_IO_1V8_ONLY),\n\tRK3588_PIN_BANK_FLAGS(3, 32, \"gpio3\",\n\t\t\t      IOMUX_WIDTH_4BIT, PULL_TYPE_IO_1V8_ONLY),\n\tRK3588_PIN_BANK_FLAGS(4, 32, \"gpio4\",\n\t\t\t      IOMUX_WIDTH_4BIT, PULL_TYPE_IO_1V8_ONLY),\n};\n\nstatic struct rockchip_pin_ctrl rk3588_pin_ctrl = {\n\t.pin_banks\t\t= rk3588_pin_banks,\n\t.nr_banks\t\t= ARRAY_SIZE(rk3588_pin_banks),\n\t.label\t\t\t= \"RK3588-GPIO\",\n\t.type\t\t\t= RK3588,\n\t.pull_calc_reg\t\t= rk3588_calc_pull_reg_and_bit,\n\t.drv_calc_reg\t\t= rk3588_calc_drv_reg_and_bit,\n\t.schmitt_calc_reg\t= rk3588_calc_schmitt_reg_and_bit,\n};\n\nstatic const struct of_device_id rockchip_pinctrl_dt_match[] = {\n\t{ .compatible = \"rockchip,px30-pinctrl\",\n\t\t.data = &px30_pin_ctrl },\n\t{ .compatible = \"rockchip,rv1108-pinctrl\",\n\t\t.data = &rv1108_pin_ctrl },\n\t{ .compatible = \"rockchip,rv1126-pinctrl\",\n\t\t.data = &rv1126_pin_ctrl },\n\t{ .compatible = \"rockchip,rk2928-pinctrl\",\n\t\t.data = &rk2928_pin_ctrl },\n\t{ .compatible = \"rockchip,rk3036-pinctrl\",\n\t\t.data = &rk3036_pin_ctrl },\n\t{ .compatible = \"rockchip,rk3066a-pinctrl\",\n\t\t.data = &rk3066a_pin_ctrl },\n\t{ .compatible = \"rockchip,rk3066b-pinctrl\",\n\t\t.data = &rk3066b_pin_ctrl },\n\t{ .compatible = \"rockchip,rk3128-pinctrl\",\n\t\t.data = (void *)&rk3128_pin_ctrl },\n\t{ .compatible = \"rockchip,rk3188-pinctrl\",\n\t\t.data = &rk3188_pin_ctrl },\n\t{ .compatible = \"rockchip,rk3228-pinctrl\",\n\t\t.data = &rk3228_pin_ctrl },\n\t{ .compatible = \"rockchip,rk3288-pinctrl\",\n\t\t.data = &rk3288_pin_ctrl },\n\t{ .compatible = \"rockchip,rk3308-pinctrl\",\n\t\t.data = &rk3308_pin_ctrl },\n\t{ .compatible = \"rockchip,rk3328-pinctrl\",\n\t\t.data = &rk3328_pin_ctrl },\n\t{ .compatible = \"rockchip,rk3368-pinctrl\",\n\t\t.data = &rk3368_pin_ctrl },\n\t{ .compatible = \"rockchip,rk3399-pinctrl\",\n\t\t.data = &rk3399_pin_ctrl },\n\t{ .compatible = \"rockchip,rk3568-pinctrl\",\n\t\t.data = &rk3568_pin_ctrl },\n\t{ .compatible = \"rockchip,rk3588-pinctrl\",\n\t\t.data = &rk3588_pin_ctrl },\n\t{},\n};\n\nstatic struct platform_driver rockchip_pinctrl_driver = {\n\t.probe\t\t= rockchip_pinctrl_probe,\n\t.remove\t\t= rockchip_pinctrl_remove,\n\t.driver = {\n\t\t.name\t= \"rockchip-pinctrl\",\n\t\t.pm = &rockchip_pinctrl_dev_pm_ops,\n\t\t.of_match_table = rockchip_pinctrl_dt_match,\n\t},\n};\n\nstatic int __init rockchip_pinctrl_drv_register(void)\n{\n\treturn platform_driver_register(&rockchip_pinctrl_driver);\n}\npostcore_initcall(rockchip_pinctrl_drv_register);\n\nstatic void __exit rockchip_pinctrl_drv_unregister(void)\n{\n\tplatform_driver_unregister(&rockchip_pinctrl_driver);\n}\nmodule_exit(rockchip_pinctrl_drv_unregister);\n\nMODULE_DESCRIPTION(\"ROCKCHIP Pin Controller Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:pinctrl-rockchip\");\nMODULE_DEVICE_TABLE(of, rockchip_pinctrl_dt_match);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}