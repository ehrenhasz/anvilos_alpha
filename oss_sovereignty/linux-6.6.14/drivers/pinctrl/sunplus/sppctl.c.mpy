{
  "module_name": "sppctl.c",
  "hash_id": "c3e1f60e5c0f7dba697f5b98ddac8217fa05bd3155352ed43b749a3408ec7030",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/sunplus/sppctl.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/gpio/driver.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/overflow.h>\n#include <linux/platform_device.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinconf-generic.h>\n#include <linux/pinctrl/pinmux.h>\n\n#include <dt-bindings/pinctrl/sppctl-sp7021.h>\n\n#include \"../core.h\"\n#include \"../pinctrl-utils.h\"\n\n#include \"sppctl.h\"\n\nstruct sppctl_gpio_chip {\n\tvoid __iomem *gpioxt_base;\t \n\tvoid __iomem *first_base;\t \n\n\tstruct gpio_chip chip;\n\tspinlock_t lock;\t\t \n};\n\nstatic inline u32 sppctl_first_readl(struct sppctl_gpio_chip *spp_gchip, u32 off)\n{\n\treturn readl(spp_gchip->first_base + SPPCTL_GPIO_OFF_FIRST + off);\n}\n\nstatic inline void sppctl_first_writel(struct sppctl_gpio_chip *spp_gchip, u32 val, u32 off)\n{\n\twritel(val, spp_gchip->first_base + SPPCTL_GPIO_OFF_FIRST + off);\n}\n\nstatic inline u32 sppctl_gpio_master_readl(struct sppctl_gpio_chip *spp_gchip, u32 off)\n{\n\treturn readl(spp_gchip->gpioxt_base + SPPCTL_GPIO_OFF_MASTER + off);\n}\n\nstatic inline void sppctl_gpio_master_writel(struct sppctl_gpio_chip *spp_gchip, u32 val,\n\t\t\t\t\t     u32 off)\n{\n\twritel(val, spp_gchip->gpioxt_base + SPPCTL_GPIO_OFF_MASTER + off);\n}\n\nstatic inline u32 sppctl_gpio_oe_readl(struct sppctl_gpio_chip *spp_gchip, u32 off)\n{\n\treturn readl(spp_gchip->gpioxt_base + SPPCTL_GPIO_OFF_OE + off);\n}\n\nstatic inline void sppctl_gpio_oe_writel(struct sppctl_gpio_chip *spp_gchip, u32 val, u32 off)\n{\n\twritel(val, spp_gchip->gpioxt_base + SPPCTL_GPIO_OFF_OE + off);\n}\n\nstatic inline void sppctl_gpio_out_writel(struct sppctl_gpio_chip *spp_gchip, u32 val, u32 off)\n{\n\twritel(val, spp_gchip->gpioxt_base + SPPCTL_GPIO_OFF_OUT + off);\n}\n\nstatic inline u32 sppctl_gpio_in_readl(struct sppctl_gpio_chip *spp_gchip, u32 off)\n{\n\treturn readl(spp_gchip->gpioxt_base + SPPCTL_GPIO_OFF_IN + off);\n}\n\nstatic inline u32 sppctl_gpio_iinv_readl(struct sppctl_gpio_chip *spp_gchip, u32 off)\n{\n\treturn readl(spp_gchip->gpioxt_base + SPPCTL_GPIO_OFF_IINV + off);\n}\n\nstatic inline void sppctl_gpio_iinv_writel(struct sppctl_gpio_chip *spp_gchip, u32 val,\n\t\t\t\t\t   u32 off)\n{\n\twritel(val, spp_gchip->gpioxt_base + SPPCTL_GPIO_OFF_IINV + off);\n}\n\nstatic inline u32 sppctl_gpio_oinv_readl(struct sppctl_gpio_chip *spp_gchip, u32 off)\n{\n\treturn readl(spp_gchip->gpioxt_base + SPPCTL_GPIO_OFF_OINV + off);\n}\n\nstatic inline void sppctl_gpio_oinv_writel(struct sppctl_gpio_chip *spp_gchip, u32 val,\n\t\t\t\t\t   u32 off)\n{\n\twritel(val, spp_gchip->gpioxt_base + SPPCTL_GPIO_OFF_OINV + off);\n}\n\nstatic inline u32 sppctl_gpio_od_readl(struct sppctl_gpio_chip *spp_gchip, u32 off)\n{\n\treturn readl(spp_gchip->gpioxt_base + SPPCTL_GPIO_OFF_OD + off);\n}\n\nstatic inline void sppctl_gpio_od_writel(struct sppctl_gpio_chip *spp_gchip, u32 val, u32 off)\n{\n\twritel(val, spp_gchip->gpioxt_base + SPPCTL_GPIO_OFF_OD + off);\n}\n\nstatic inline u32 sppctl_get_reg_and_bit_offset(unsigned int offset, u32 *reg_off)\n{\n\tu32 bit_off;\n\n\t \n\t*reg_off = (offset / 32) * 4;\n\tbit_off = offset % 32;\n\n\treturn bit_off;\n}\n\nstatic inline u32 sppctl_get_moon_reg_and_bit_offset(unsigned int offset, u32 *reg_off)\n{\n\tu32 bit_off;\n\n\t \n\t*reg_off = (offset / 16) * 4;\n\tbit_off = offset % 16;\n\n\treturn bit_off;\n}\n\nstatic inline u32 sppctl_prep_moon_reg_and_offset(unsigned int offset, u32 *reg_off, int val)\n{\n\tu32 bit_off;\n\n\tbit_off = sppctl_get_moon_reg_and_bit_offset(offset, reg_off);\n\tif (val)\n\t\treturn SPPCTL_SET_MOON_REG_BIT(bit_off);\n\telse\n\t\treturn SPPCTL_CLR_MOON_REG_BIT(bit_off);\n}\n\n \nstatic void sppctl_func_set(struct sppctl_pdata *pctl, u8 func, u8 val)\n{\n\tu32 reg, offset;\n\n\t \n\treg = SPPCTL_FULLY_PINMUX_MASK_MASK | val;\n\n\t \n\tfunc -= MUXF_L2SW_CLK_OUT;\n\n\t \n\tif (func & BIT(0))\n\t\treg <<= SPPCTL_FULLY_PINMUX_UPPER_SHIFT;\n\n\t \n\toffset = func * 2;\n\toffset &= GENMASK(31, 2);\n\n\twritel(reg, pctl->moon2_base + offset);\n}\n\n \nstatic void sppctl_gmx_set(struct sppctl_pdata *pctl, u8 reg_off, u8 bit_off, u8 bit_sz,\n\t\t\t   u8 val)\n{\n\tu32 mask, reg;\n\n\t \n\tmask = GENMASK(bit_sz - 1, 0) << SPPCTL_MOON_REG_MASK_SHIFT;\n\treg = (mask | val) << bit_off;\n\n\twritel(reg, pctl->moon1_base + reg_off * 4);\n}\n\n \nstatic int sppctl_first_get(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct sppctl_gpio_chip *spp_gchip = gpiochip_get_data(chip);\n\tu32 reg_off, bit_off, reg;\n\n\tbit_off = sppctl_get_reg_and_bit_offset(offset, &reg_off);\n\treg = sppctl_first_readl(spp_gchip, reg_off);\n\n\treturn (reg & BIT(bit_off)) ? 1 : 0;\n}\n\n \nstatic int sppctl_master_get(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct sppctl_gpio_chip *spp_gchip = gpiochip_get_data(chip);\n\tu32 reg_off, bit_off, reg;\n\n\tbit_off = sppctl_get_moon_reg_and_bit_offset(offset, &reg_off);\n\treg = sppctl_gpio_master_readl(spp_gchip, reg_off);\n\treturn (reg & BIT(bit_off)) ? 1 : 0;\n}\n\nstatic void sppctl_first_master_set(struct gpio_chip *chip, unsigned int offset,\n\t\t\t\t    enum mux_first_reg first, enum mux_master_reg master)\n{\n\tstruct sppctl_gpio_chip *spp_gchip = gpiochip_get_data(chip);\n\tu32 reg_off, bit_off, reg;\n\tenum mux_first_reg val;\n\n\t \n\tif (first != mux_f_keep) {\n\t\tbit_off = sppctl_get_reg_and_bit_offset(offset, &reg_off);\n\t\treg = sppctl_first_readl(spp_gchip, reg_off);\n\t\tval = (reg & BIT(bit_off)) ? mux_f_gpio : mux_f_mux;\n\n\t\tif (first != val)\n\t\t\tswitch (first) {\n\t\t\tcase mux_f_gpio:\n\t\t\t\treg |= BIT(bit_off);\n\t\t\t\tsppctl_first_writel(spp_gchip, reg, reg_off);\n\t\t\t\tbreak;\n\n\t\t\tcase mux_f_mux:\n\t\t\t\treg &= ~BIT(bit_off);\n\t\t\t\tsppctl_first_writel(spp_gchip, reg, reg_off);\n\t\t\t\tbreak;\n\n\t\t\tcase mux_f_keep:\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\t \n\tif (master != mux_m_keep) {\n\t\treg = sppctl_prep_moon_reg_and_offset(offset, &reg_off, (master == mux_m_gpio));\n\t\tsppctl_gpio_master_writel(spp_gchip, reg, reg_off);\n\t}\n}\n\nstatic void sppctl_gpio_input_inv_set(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct sppctl_gpio_chip *spp_gchip = gpiochip_get_data(chip);\n\tu32 reg_off, reg;\n\n\treg = sppctl_prep_moon_reg_and_offset(offset, &reg_off, 1);\n\tsppctl_gpio_iinv_writel(spp_gchip, reg, reg_off);\n}\n\nstatic void sppctl_gpio_output_inv_set(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct sppctl_gpio_chip *spp_gchip = gpiochip_get_data(chip);\n\tu32 reg_off, reg;\n\n\treg = sppctl_prep_moon_reg_and_offset(offset, &reg_off, 1);\n\tsppctl_gpio_oinv_writel(spp_gchip, reg, reg_off);\n}\n\nstatic int sppctl_gpio_output_od_get(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct sppctl_gpio_chip *spp_gchip = gpiochip_get_data(chip);\n\tu32 reg_off, bit_off, reg;\n\n\tbit_off = sppctl_get_moon_reg_and_bit_offset(offset, &reg_off);\n\treg = sppctl_gpio_od_readl(spp_gchip, reg_off);\n\n\treturn (reg & BIT(bit_off)) ? 1 : 0;\n}\n\nstatic void sppctl_gpio_output_od_set(struct gpio_chip *chip, unsigned int offset,\n\t\t\t\t      unsigned int val)\n{\n\tstruct sppctl_gpio_chip *spp_gchip = gpiochip_get_data(chip);\n\tu32 reg_off, reg;\n\n\treg = sppctl_prep_moon_reg_and_offset(offset, &reg_off, val);\n\tsppctl_gpio_od_writel(spp_gchip, reg, reg_off);\n}\n\nstatic int sppctl_gpio_get_direction(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct sppctl_gpio_chip *spp_gchip = gpiochip_get_data(chip);\n\tu32 reg_off, bit_off, reg;\n\n\tbit_off = sppctl_get_moon_reg_and_bit_offset(offset, &reg_off);\n\treg = sppctl_gpio_oe_readl(spp_gchip, reg_off);\n\n\treturn (reg & BIT(bit_off)) ? 0 : 1;\n}\n\nstatic int sppctl_gpio_inv_get(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct sppctl_gpio_chip *spp_gchip = gpiochip_get_data(chip);\n\tu32 reg_off, bit_off, reg;\n\tunsigned long flags;\n\n\tbit_off = sppctl_get_moon_reg_and_bit_offset(offset, &reg_off);\n\n\tspin_lock_irqsave(&spp_gchip->lock, flags);\n\n\tif (sppctl_gpio_get_direction(chip, offset))\n\t\treg = sppctl_gpio_iinv_readl(spp_gchip, reg_off);\n\telse\n\t\treg = sppctl_gpio_oinv_readl(spp_gchip, reg_off);\n\n\tspin_unlock_irqrestore(&spp_gchip->lock, flags);\n\n\treturn (reg & BIT(bit_off)) ? 1 : 0;\n}\n\nstatic int sppctl_gpio_direction_input(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct sppctl_gpio_chip *spp_gchip = gpiochip_get_data(chip);\n\tunsigned long flags;\n\tu32 reg_off, reg;\n\n\treg = sppctl_prep_moon_reg_and_offset(offset, &reg_off, 0);\n\n\tspin_lock_irqsave(&spp_gchip->lock, flags);\n\n\tsppctl_gpio_oe_writel(spp_gchip, reg, reg_off);\n\n\tspin_unlock_irqrestore(&spp_gchip->lock, flags);\n\treturn 0;\n}\n\nstatic int sppctl_gpio_direction_output(struct gpio_chip *chip, unsigned int offset, int val)\n{\n\tstruct sppctl_gpio_chip *spp_gchip = gpiochip_get_data(chip);\n\tunsigned long flags;\n\tu32 reg_off, reg;\n\n\treg = sppctl_prep_moon_reg_and_offset(offset, &reg_off, 1);\n\n\tspin_lock_irqsave(&spp_gchip->lock, flags);\n\n\tsppctl_gpio_oe_writel(spp_gchip, reg, reg_off);\n\n\tif (val < 0) {\n\t\tspin_unlock_irqrestore(&spp_gchip->lock, flags);\n\t\treturn 0;\n\t}\n\n\treg = sppctl_prep_moon_reg_and_offset(offset, &reg_off, val);\n\tsppctl_gpio_out_writel(spp_gchip, reg, reg_off);\n\n\tspin_unlock_irqrestore(&spp_gchip->lock, flags);\n\treturn 0;\n}\n\nstatic int sppctl_gpio_get(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct sppctl_gpio_chip *spp_gchip = gpiochip_get_data(chip);\n\tu32 reg_off, bit_off, reg;\n\n\tbit_off = sppctl_get_reg_and_bit_offset(offset, &reg_off);\n\treg = sppctl_gpio_in_readl(spp_gchip, reg_off);\n\n\treturn (reg & BIT(bit_off)) ? 1 : 0;\n}\n\nstatic void sppctl_gpio_set(struct gpio_chip *chip, unsigned int offset, int val)\n{\n\tstruct sppctl_gpio_chip *spp_gchip = gpiochip_get_data(chip);\n\tu32 reg_off, reg;\n\n\treg = sppctl_prep_moon_reg_and_offset(offset, &reg_off, val);\n\tsppctl_gpio_out_writel(spp_gchip, reg, reg_off);\n}\n\nstatic int sppctl_gpio_set_config(struct gpio_chip *chip, unsigned int offset,\n\t\t\t\t  unsigned long config)\n{\n\tenum pin_config_param param = pinconf_to_config_param(config);\n\tstruct sppctl_gpio_chip *spp_gchip = gpiochip_get_data(chip);\n\tu32 reg_off, reg;\n\n\tswitch (param) {\n\tcase PIN_CONFIG_DRIVE_OPEN_DRAIN:\n\t\treg = sppctl_prep_moon_reg_and_offset(offset, &reg_off, 1);\n\t\tsppctl_gpio_od_writel(spp_gchip, reg, reg_off);\n\t\tbreak;\n\n\tcase PIN_CONFIG_INPUT_ENABLE:\n\t\tbreak;\n\n\tcase PIN_CONFIG_OUTPUT:\n\t\treturn sppctl_gpio_direction_output(chip, offset, 0);\n\n\tcase PIN_CONFIG_PERSIST_STATE:\n\t\treturn -ENOTSUPP;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void sppctl_gpio_dbg_show(struct seq_file *s, struct gpio_chip *chip)\n{\n\tconst char *label;\n\tint i;\n\n\tfor (i = 0; i < chip->ngpio; i++) {\n\t\tlabel = gpiochip_is_requested(chip, i);\n\t\tif (!label)\n\t\t\tlabel = \"\";\n\n\t\tseq_printf(s, \" gpio-%03d (%-16.16s | %-16.16s)\", i + chip->base,\n\t\t\t   chip->names[i], label);\n\t\tseq_printf(s, \" %c\", sppctl_gpio_get_direction(chip, i) ? 'I' : 'O');\n\t\tseq_printf(s, \":%d\", sppctl_gpio_get(chip, i));\n\t\tseq_printf(s, \" %s\", sppctl_first_get(chip, i) ? \"gpi\" : \"mux\");\n\t\tseq_printf(s, \" %s\", sppctl_master_get(chip, i) ? \"gpi\" : \"iop\");\n\t\tseq_printf(s, \" %s\", sppctl_gpio_inv_get(chip, i) ? \"inv\" : \"   \");\n\t\tseq_printf(s, \" %s\", sppctl_gpio_output_od_get(chip, i) ? \"oDr\" : \"\");\n\t\tseq_puts(s, \"\\n\");\n\t}\n}\n\nstatic int sppctl_gpio_new(struct platform_device *pdev, struct sppctl_pdata *pctl)\n{\n\tstruct sppctl_gpio_chip *spp_gchip;\n\tstruct gpio_chip *gchip;\n\tint err;\n\n\tspp_gchip = devm_kzalloc(&pdev->dev, sizeof(*spp_gchip), GFP_KERNEL);\n\tif (!spp_gchip)\n\t\treturn -ENOMEM;\n\tpctl->spp_gchip = spp_gchip;\n\n\tspp_gchip->gpioxt_base  = pctl->gpioxt_base;\n\tspp_gchip->first_base   = pctl->first_base;\n\tspin_lock_init(&spp_gchip->lock);\n\n\tgchip                   = &spp_gchip->chip;\n\tgchip->label            = SPPCTL_MODULE_NAME;\n\tgchip->parent           = &pdev->dev;\n\tgchip->owner            = THIS_MODULE;\n\tgchip->request          = gpiochip_generic_request;\n\tgchip->free             = gpiochip_generic_free;\n\tgchip->get_direction    = sppctl_gpio_get_direction;\n\tgchip->direction_input  = sppctl_gpio_direction_input;\n\tgchip->direction_output = sppctl_gpio_direction_output;\n\tgchip->get              = sppctl_gpio_get;\n\tgchip->set              = sppctl_gpio_set;\n\tgchip->set_config       = sppctl_gpio_set_config;\n\tgchip->dbg_show         = IS_ENABLED(CONFIG_DEBUG_FS) ?\n\t\t\t\t  sppctl_gpio_dbg_show : NULL;\n\tgchip->base             = -1;\n\tgchip->ngpio            = sppctl_gpio_list_sz;\n\tgchip->names            = sppctl_gpio_list_s;\n\n\tpctl->pctl_grange.npins = gchip->ngpio;\n\tpctl->pctl_grange.name  = gchip->label;\n\tpctl->pctl_grange.gc    = gchip;\n\n\terr = devm_gpiochip_add_data(&pdev->dev, gchip, spp_gchip);\n\tif (err)\n\t\treturn dev_err_probe(&pdev->dev, err, \"Failed to add gpiochip!\\n\");\n\n\treturn 0;\n}\n\nstatic int sppctl_pin_config_get(struct pinctrl_dev *pctldev, unsigned int pin,\n\t\t\t\t unsigned long *config)\n{\n\tstruct sppctl_pdata *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tunsigned int param = pinconf_to_config_param(*config);\n\tunsigned int arg;\n\n\tswitch (param) {\n\tcase PIN_CONFIG_DRIVE_OPEN_DRAIN:\n\t\tif (!sppctl_gpio_output_od_get(&pctl->spp_gchip->chip, pin))\n\t\t\treturn -EINVAL;\n\t\targ = 0;\n\t\tbreak;\n\n\tcase PIN_CONFIG_OUTPUT:\n\t\tif (!sppctl_first_get(&pctl->spp_gchip->chip, pin))\n\t\t\treturn -EINVAL;\n\t\tif (!sppctl_master_get(&pctl->spp_gchip->chip, pin))\n\t\t\treturn -EINVAL;\n\t\tif (sppctl_gpio_get_direction(&pctl->spp_gchip->chip, pin))\n\t\t\treturn -EINVAL;\n\t\targ = sppctl_gpio_get(&pctl->spp_gchip->chip, pin);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\t*config = pinconf_to_config_packed(param, arg);\n\n\treturn 0;\n}\n\nstatic int sppctl_pin_config_set(struct pinctrl_dev *pctldev, unsigned int pin,\n\t\t\t\t unsigned long *configs, unsigned int num_configs)\n{\n\tstruct sppctl_pdata *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tint i;\n\n\t \n\tif (configs[0] == SPPCTL_IOP_CONFIGS) {\n\t\tsppctl_first_master_set(&pctl->spp_gchip->chip, pin, mux_f_gpio, mux_m_iop);\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < num_configs; i++) {\n\t\tif (configs[i] & SPPCTL_PCTL_L_OUT)\n\t\t\tsppctl_gpio_direction_output(&pctl->spp_gchip->chip, pin, 0);\n\t\tif (configs[i] & SPPCTL_PCTL_L_OU1)\n\t\t\tsppctl_gpio_direction_output(&pctl->spp_gchip->chip, pin, 1);\n\t\tif (configs[i] & SPPCTL_PCTL_L_INV)\n\t\t\tsppctl_gpio_input_inv_set(&pctl->spp_gchip->chip, pin);\n\t\tif (configs[i] & SPPCTL_PCTL_L_ONV)\n\t\t\tsppctl_gpio_output_inv_set(&pctl->spp_gchip->chip, pin);\n\t\tif (configs[i] & SPPCTL_PCTL_L_ODR)\n\t\t\tsppctl_gpio_output_od_set(&pctl->spp_gchip->chip, pin, 1);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct pinconf_ops sppctl_pconf_ops = {\n\t.is_generic     = true,\n\t.pin_config_get = sppctl_pin_config_get,\n\t.pin_config_set = sppctl_pin_config_set,\n};\n\nstatic int sppctl_get_functions_count(struct pinctrl_dev *pctldev)\n{\n\treturn sppctl_list_funcs_sz;\n}\n\nstatic const char *sppctl_get_function_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t    unsigned int selector)\n{\n\treturn sppctl_list_funcs[selector].name;\n}\n\nstatic int sppctl_get_function_groups(struct pinctrl_dev *pctldev, unsigned int selector,\n\t\t\t\t      const char * const **groups, unsigned int *num_groups)\n{\n\tstruct sppctl_pdata *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct sppctl_func *f = &sppctl_list_funcs[selector];\n\tint i;\n\n\t*num_groups = 0;\n\tswitch (f->type) {\n\tcase pinmux_type_fpmx:\n\t\t*num_groups = sppctl_pmux_list_sz;\n\t\t*groups = sppctl_pmux_list_s;\n\t\tbreak;\n\n\tcase pinmux_type_grp:\n\t\tif (!f->grps)\n\t\t\tbreak;\n\n\t\t*num_groups = f->gnum;\n\t\tfor (i = 0; i < pctl->unq_grps_sz; i++)\n\t\t\tif (pctl->g2fp_maps[i].f_idx == selector)\n\t\t\t\tbreak;\n\t\t*groups = &pctl->unq_grps[i];\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(pctldev->dev, \"Unknown pinmux (selector: %d, type: %d)\\n\",\n\t\t\tselector, f->type);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstatic inline int sppctl_fully_pinmux_conv(unsigned int offset)\n{\n\treturn (offset < 8) ? 0 : offset - 7;\n}\n\nstatic int sppctl_set_mux(struct pinctrl_dev *pctldev, unsigned int func_selector,\n\t\t\t  unsigned int group_selector)\n{\n\tconst struct sppctl_func *f = &sppctl_list_funcs[func_selector];\n\tstruct sppctl_pdata *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct grp2fp_map g2fpm = pctl->g2fp_maps[group_selector];\n\tint i;\n\n\tswitch (f->type) {\n\tcase pinmux_type_fpmx:\n\t\tsppctl_first_master_set(&pctl->spp_gchip->chip, group_selector,\n\t\t\t\t\tmux_f_mux, mux_m_keep);\n\t\tsppctl_func_set(pctl, func_selector, sppctl_fully_pinmux_conv(group_selector));\n\t\tbreak;\n\n\tcase pinmux_type_grp:\n\t\tfor (i = 0; i < f->grps[g2fpm.g_idx].pnum; i++)\n\t\t\tsppctl_first_master_set(&pctl->spp_gchip->chip,\n\t\t\t\t\t\tf->grps[g2fpm.g_idx].pins[i],\n\t\t\t\t\t\tmux_f_mux, mux_m_keep);\n\t\tsppctl_gmx_set(pctl, f->roff, f->boff, f->blen, f->grps[g2fpm.g_idx].gval);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(pctldev->dev, \"Unknown pinmux type (func_selector: %d, type: %d)\\n\",\n\t\t\tfunc_selector, f->type);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int sppctl_gpio_request_enable(struct pinctrl_dev *pctldev,\n\t\t\t\t      struct pinctrl_gpio_range *range, unsigned int offset)\n{\n\tstruct sppctl_pdata *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tint g_f, g_m;\n\n\tg_f = sppctl_first_get(&pctl->spp_gchip->chip, offset);\n\tg_m = sppctl_master_get(&pctl->spp_gchip->chip, offset);\n\tif (g_f == mux_f_gpio && g_m == mux_m_gpio)\n\t\treturn 0;\n\n\tsppctl_first_master_set(&pctl->spp_gchip->chip, offset, mux_f_gpio, mux_m_gpio);\n\treturn 0;\n}\n\nstatic const struct pinmux_ops sppctl_pinmux_ops = {\n\t.get_functions_count = sppctl_get_functions_count,\n\t.get_function_name   = sppctl_get_function_name,\n\t.get_function_groups = sppctl_get_function_groups,\n\t.set_mux             = sppctl_set_mux,\n\t.gpio_request_enable = sppctl_gpio_request_enable,\n\t.strict              = true,\n};\n\nstatic int sppctl_get_groups_count(struct pinctrl_dev *pctldev)\n{\n\tstruct sppctl_pdata *pctl = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pctl->unq_grps_sz;\n}\n\nstatic const char *sppctl_get_group_name(struct pinctrl_dev *pctldev, unsigned int selector)\n{\n\tstruct sppctl_pdata *pctl = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pctl->unq_grps[selector];\n}\n\nstatic int sppctl_get_group_pins(struct pinctrl_dev *pctldev, unsigned int selector,\n\t\t\t\t const unsigned int **pins, unsigned int *num_pins)\n{\n\tstruct sppctl_pdata *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct grp2fp_map g2fpm = pctl->g2fp_maps[selector];\n\tconst struct sppctl_func *f;\n\n\tf = &sppctl_list_funcs[g2fpm.f_idx];\n\t*num_pins = 0;\n\n\t \n\tif (f->type != pinmux_type_grp) {\n\t\t*num_pins = 1;\n\t\t*pins = &sppctl_pins_gpio[selector];\n\t\treturn 0;\n\t}\n\n\t \n\tif (!f->grps)\n\t\treturn 0;\n\n\tif (f->gnum < 1)\n\t\treturn 0;\n\n\t*num_pins = f->grps[g2fpm.g_idx].pnum;\n\t*pins = f->grps[g2fpm.g_idx].pins;\n\n\treturn 0;\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic void sppctl_pin_dbg_show(struct pinctrl_dev *pctldev, struct seq_file *s,\n\t\t\t\tunsigned int offset)\n{\n\tstruct sppctl_pdata *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tconst char *pin_type;\n\tu8 first, master;\n\n\tfirst = sppctl_first_get(&pctl->spp_gchip->chip, offset);\n\tmaster = sppctl_master_get(&pctl->spp_gchip->chip, offset);\n\tif (first)\n\t\tif (master)\n\t\t\tpin_type = \"GPIO\";\n\t\telse\n\t\t\tpin_type = \" IOP\";\n\telse\n\t\tpin_type = \" MUX\";\n\tseq_printf(s, \" %s\", pin_type);\n}\n#endif\n\nstatic int sppctl_dt_node_to_map(struct pinctrl_dev *pctldev, struct device_node *np_config,\n\t\t\t\t struct pinctrl_map **map, unsigned int *num_maps)\n{\n\tstruct sppctl_pdata *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tint nmG = of_property_count_strings(np_config, \"groups\");\n\tconst struct sppctl_func *f = NULL;\n\tu8 pin_num, pin_type, pin_func;\n\tstruct device_node *parent;\n\tunsigned long *configs;\n\tstruct property *prop;\n\tconst char *s_f, *s_g;\n\n\tconst __be32 *list;\n\tu32 dt_pin, dt_fun;\n\tint i, size = 0;\n\n\tlist = of_get_property(np_config, \"sunplus,pins\", &size);\n\t*num_maps = size / sizeof(*list);\n\n\t \n\tfor (i = 0; i < (*num_maps); i++) {\n\t\tdt_pin = be32_to_cpu(list[i]);\n\t\tpin_num = FIELD_GET(GENMASK(31, 24), dt_pin);\n\n\t\tif (pin_num >= sppctl_pins_all_sz) {\n\t\t\tdev_err(pctldev->dev, \"Invalid pin property at index %d (0x%08x)\\n\",\n\t\t\t\ti, dt_pin);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (nmG <= 0)\n\t\tnmG = 0;\n\n\t*map = kcalloc(*num_maps + nmG, sizeof(**map), GFP_KERNEL);\n\tif (!(*map))\n\t\treturn -ENOMEM;\n\n\tparent = of_get_parent(np_config);\n\tfor (i = 0; i < (*num_maps); i++) {\n\t\tdt_pin = be32_to_cpu(list[i]);\n\t\tpin_num = FIELD_GET(GENMASK(31, 24), dt_pin);\n\t\tpin_type = FIELD_GET(GENMASK(23, 16), dt_pin);\n\t\tpin_func = FIELD_GET(GENMASK(15, 8), dt_pin);\n\t\t(*map)[i].name = parent->name;\n\n\t\tif (pin_type == SPPCTL_PCTL_G_GPIO) {\n\t\t\t \n\t\t\t(*map)[i].type = PIN_MAP_TYPE_CONFIGS_PIN;\n\t\t\t(*map)[i].data.configs.num_configs = 1;\n\t\t\t(*map)[i].data.configs.group_or_pin = pin_get_name(pctldev, pin_num);\n\t\t\tconfigs = kmalloc(sizeof(*configs), GFP_KERNEL);\n\t\t\tif (!configs)\n\t\t\t\tgoto sppctl_map_err;\n\t\t\t*configs = FIELD_GET(GENMASK(7, 0), dt_pin);\n\t\t\t(*map)[i].data.configs.configs = configs;\n\n\t\t\tdev_dbg(pctldev->dev, \"%s: GPIO (%s)\\n\",\n\t\t\t\t(*map)[i].data.configs.group_or_pin,\n\t\t\t\t(*configs & (SPPCTL_PCTL_L_OUT | SPPCTL_PCTL_L_OU1)) ?\n\t\t\t\t\"OUT\" : \"IN\");\n\t\t} else if (pin_type == SPPCTL_PCTL_G_IOPP) {\n\t\t\t \n\t\t\t(*map)[i].type = PIN_MAP_TYPE_CONFIGS_PIN;\n\t\t\t(*map)[i].data.configs.num_configs = 1;\n\t\t\t(*map)[i].data.configs.group_or_pin = pin_get_name(pctldev, pin_num);\n\t\t\tconfigs = kmalloc(sizeof(*configs), GFP_KERNEL);\n\t\t\tif (!configs)\n\t\t\t\tgoto sppctl_map_err;\n\t\t\t*configs = SPPCTL_IOP_CONFIGS;\n\t\t\t(*map)[i].data.configs.configs = configs;\n\n\t\t\tdev_dbg(pctldev->dev, \"%s: IOP\\n\",\n\t\t\t\t(*map)[i].data.configs.group_or_pin);\n\t\t} else {\n\t\t\t \n\t\t\t(*map)[i].type = PIN_MAP_TYPE_MUX_GROUP;\n\t\t\t(*map)[i].data.mux.function = sppctl_list_funcs[pin_func].name;\n\t\t\t(*map)[i].data.mux.group = pin_get_name(pctldev, pin_num);\n\n\t\t\tdev_dbg(pctldev->dev, \"%s: %s\\n\", (*map)[i].data.mux.group,\n\t\t\t\t(*map)[i].data.mux.function);\n\t\t}\n\t}\n\n\t \n\tif (nmG > 0 && of_property_read_string(np_config, \"function\", &s_f) == 0) {\n\t\tof_property_for_each_string(np_config, \"groups\", prop, s_g) {\n\t\t\t(*map)[*num_maps].type = PIN_MAP_TYPE_MUX_GROUP;\n\t\t\t(*map)[*num_maps].data.mux.function = s_f;\n\t\t\t(*map)[*num_maps].data.mux.group = s_g;\n\t\t\t(*num_maps)++;\n\n\t\t\tdev_dbg(pctldev->dev, \"%s: %s\\n\", s_f, s_g);\n\t\t}\n\t}\n\n\t \n\tlist = of_get_property(np_config, \"sunplus,zerofunc\", &size);\n\tif (list) {\n\t\tfor (i = 0; i < (size / sizeof(*list)); i++) {\n\t\t\tdt_fun = be32_to_cpu(list[i]);\n\t\t\tif (dt_fun >= sppctl_list_funcs_sz) {\n\t\t\t\tdev_err(pctldev->dev, \"Zero-func %d out of range!\\n\",\n\t\t\t\t\tdt_fun);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tf = &sppctl_list_funcs[dt_fun];\n\t\t\tswitch (f->type) {\n\t\t\tcase pinmux_type_fpmx:\n\t\t\t\tsppctl_func_set(pctl, dt_fun, 0);\n\t\t\t\tdev_dbg(pctldev->dev, \"%s: No map\\n\", f->name);\n\t\t\t\tbreak;\n\n\t\t\tcase pinmux_type_grp:\n\t\t\t\tsppctl_gmx_set(pctl, f->roff, f->boff, f->blen, 0);\n\t\t\t\tdev_dbg(pctldev->dev, \"%s: No map\\n\", f->name);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tdev_err(pctldev->dev, \"Wrong zero-group: %d (%s)\\n\",\n\t\t\t\t\tdt_fun, f->name);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tof_node_put(parent);\n\tdev_dbg(pctldev->dev, \"%d pins mapped\\n\", *num_maps);\n\treturn 0;\n\nsppctl_map_err:\n\tfor (i = 0; i < (*num_maps); i++)\n\t\tif ((*map)[i].type == PIN_MAP_TYPE_CONFIGS_PIN)\n\t\t\tkfree((*map)[i].data.configs.configs);\n\tkfree(*map);\n\tof_node_put(parent);\n\treturn -ENOMEM;\n}\n\nstatic const struct pinctrl_ops sppctl_pctl_ops = {\n\t.get_groups_count = sppctl_get_groups_count,\n\t.get_group_name   = sppctl_get_group_name,\n\t.get_group_pins   = sppctl_get_group_pins,\n#ifdef CONFIG_DEBUG_FS\n\t.pin_dbg_show     = sppctl_pin_dbg_show,\n#endif\n\t.dt_node_to_map   = sppctl_dt_node_to_map,\n\t.dt_free_map      = pinctrl_utils_free_map,\n};\n\nstatic int sppctl_group_groups(struct platform_device *pdev)\n{\n\tstruct sppctl_pdata *sppctl = platform_get_drvdata(pdev);\n\tint i, k, j;\n\n\t \n\tsppctl->unq_grps_sz = sppctl_gpio_list_sz;\n\tfor (i = 0; i < sppctl_list_funcs_sz; i++)\n\t\tif (sppctl_list_funcs[i].type == pinmux_type_grp)\n\t\t\tsppctl->unq_grps_sz += sppctl_list_funcs[i].gnum;\n\n\tsppctl->unq_grps = devm_kcalloc(&pdev->dev, sppctl->unq_grps_sz + 1,\n\t\t\t\t\tsizeof(*sppctl->unq_grps), GFP_KERNEL);\n\tif (!sppctl->unq_grps)\n\t\treturn -ENOMEM;\n\n\tsppctl->g2fp_maps = devm_kcalloc(&pdev->dev, sppctl->unq_grps_sz + 1,\n\t\t\t\t\t sizeof(*sppctl->g2fp_maps), GFP_KERNEL);\n\tif (!sppctl->g2fp_maps)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = 0; i < sppctl_gpio_list_sz; i++) {\n\t\tsppctl->unq_grps[i] = sppctl_gpio_list_s[i];\n\t\tsppctl->g2fp_maps[i].f_idx = 0;\n\t\tsppctl->g2fp_maps[i].g_idx = i;\n\t}\n\n\t \n\tj = sppctl_gpio_list_sz;\n\tfor (i = 0; i < sppctl_list_funcs_sz; i++) {\n\t\tif (sppctl_list_funcs[i].type != pinmux_type_grp)\n\t\t\tcontinue;\n\n\t\tfor (k = 0; k < sppctl_list_funcs[i].gnum; k++) {\n\t\t\tsppctl->unq_grps[j] = sppctl_list_funcs[i].grps[k].name;\n\t\t\tsppctl->g2fp_maps[j].f_idx = i;\n\t\t\tsppctl->g2fp_maps[j].g_idx = k;\n\t\t\tj++;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int sppctl_pinctrl_init(struct platform_device *pdev)\n{\n\tstruct sppctl_pdata *sppctl = platform_get_drvdata(pdev);\n\tint err;\n\n\tsppctl->pctl_desc.owner   = THIS_MODULE;\n\tsppctl->pctl_desc.name    = dev_name(&pdev->dev);\n\tsppctl->pctl_desc.pins    = sppctl_pins_all;\n\tsppctl->pctl_desc.npins   = sppctl_pins_all_sz;\n\tsppctl->pctl_desc.pctlops = &sppctl_pctl_ops;\n\tsppctl->pctl_desc.confops = &sppctl_pconf_ops;\n\tsppctl->pctl_desc.pmxops  = &sppctl_pinmux_ops;\n\n\terr = sppctl_group_groups(pdev);\n\tif (err)\n\t\treturn err;\n\n\terr = devm_pinctrl_register_and_init(&pdev->dev, &sppctl->pctl_desc,\n\t\t\t\t\t     sppctl, &sppctl->pctl_dev);\n\tif (err)\n\t\treturn dev_err_probe(&pdev->dev, err, \"Failed to register pinctrl!\\n\");\n\n\tpinctrl_enable(sppctl->pctl_dev);\n\treturn 0;\n}\n\nstatic int sppctl_resource_map(struct platform_device *pdev, struct sppctl_pdata *sppctl)\n{\n\tsppctl->moon2_base = devm_platform_ioremap_resource_byname(pdev, \"moon2\");\n\tif (IS_ERR(sppctl->moon2_base))\n\t\treturn PTR_ERR(sppctl->moon2_base);\n\n\tsppctl->gpioxt_base = devm_platform_ioremap_resource_byname(pdev, \"gpioxt\");\n\tif (IS_ERR(sppctl->gpioxt_base))\n\t\treturn PTR_ERR(sppctl->gpioxt_base);\n\n\tsppctl->first_base = devm_platform_ioremap_resource_byname(pdev, \"first\");\n\tif (IS_ERR(sppctl->first_base))\n\t\treturn PTR_ERR(sppctl->first_base);\n\n\tsppctl->moon1_base = devm_platform_ioremap_resource_byname(pdev, \"moon1\");\n\tif (IS_ERR(sppctl->moon1_base))\n\t\treturn PTR_ERR(sppctl->moon1_base);\n\n\treturn 0;\n}\n\nstatic int sppctl_probe(struct platform_device *pdev)\n{\n\tstruct sppctl_pdata *sppctl;\n\tint ret;\n\n\tsppctl = devm_kzalloc(&pdev->dev, sizeof(*sppctl), GFP_KERNEL);\n\tif (!sppctl)\n\t\treturn -ENOMEM;\n\tplatform_set_drvdata(pdev, sppctl);\n\n\tret = sppctl_resource_map(pdev, sppctl);\n\tif (ret)\n\t\treturn ret;\n\n\tret = sppctl_gpio_new(pdev, sppctl);\n\tif (ret)\n\t\treturn ret;\n\n\tret = sppctl_pinctrl_init(pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tpinctrl_add_gpio_range(sppctl->pctl_dev, &sppctl->pctl_grange);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id sppctl_match_table[] = {\n\t{ .compatible = \"sunplus,sp7021-pctl\" },\n\t{   }\n};\n\nstatic struct platform_driver sppctl_pinctrl_driver = {\n\t.driver = {\n\t\t.name           = SPPCTL_MODULE_NAME,\n\t\t.of_match_table = sppctl_match_table,\n\t},\n\t.probe  = sppctl_probe,\n};\nbuiltin_platform_driver(sppctl_pinctrl_driver)\n\nMODULE_AUTHOR(\"Dvorkin Dmitry <dvorkin@tibbo.com>\");\nMODULE_AUTHOR(\"Wells Lu <wellslutw@gmail.com>\");\nMODULE_DESCRIPTION(\"Sunplus SP7021 Pin Control and GPIO driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}