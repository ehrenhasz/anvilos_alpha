{
  "module_name": "pinctrl-lantiq.c",
  "hash_id": "5ea29bc938f08e4d0331886bc25a0a0bba1d33b582c7af88dccf1eb5d8560561",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/pinctrl-lantiq.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n\n#include \"pinctrl-lantiq.h\"\n\nstatic int ltq_get_group_count(struct pinctrl_dev *pctrldev)\n{\n\tstruct ltq_pinmux_info *info = pinctrl_dev_get_drvdata(pctrldev);\n\treturn info->num_grps;\n}\n\nstatic const char *ltq_get_group_name(struct pinctrl_dev *pctrldev,\n\t\t\t\t\t unsigned selector)\n{\n\tstruct ltq_pinmux_info *info = pinctrl_dev_get_drvdata(pctrldev);\n\tif (selector >= info->num_grps)\n\t\treturn NULL;\n\treturn info->grps[selector].name;\n}\n\nstatic int ltq_get_group_pins(struct pinctrl_dev *pctrldev,\n\t\t\t\t unsigned selector,\n\t\t\t\t const unsigned **pins,\n\t\t\t\t unsigned *num_pins)\n{\n\tstruct ltq_pinmux_info *info = pinctrl_dev_get_drvdata(pctrldev);\n\tif (selector >= info->num_grps)\n\t\treturn -EINVAL;\n\t*pins = info->grps[selector].pins;\n\t*num_pins = info->grps[selector].npins;\n\treturn 0;\n}\n\nstatic void ltq_pinctrl_dt_free_map(struct pinctrl_dev *pctldev,\n\t\t\t\t    struct pinctrl_map *map, unsigned num_maps)\n{\n\tint i;\n\n\tfor (i = 0; i < num_maps; i++)\n\t\tif (map[i].type == PIN_MAP_TYPE_CONFIGS_PIN ||\n\t\t    map[i].type == PIN_MAP_TYPE_CONFIGS_GROUP)\n\t\t\tkfree(map[i].data.configs.configs);\n\tkfree(map);\n}\n\nstatic void ltq_pinctrl_pin_dbg_show(struct pinctrl_dev *pctldev,\n\t\t\t\t\tstruct seq_file *s,\n\t\t\t\t\tunsigned offset)\n{\n\tseq_printf(s, \" %s\", dev_name(pctldev->dev));\n}\n\nstatic void ltq_pinctrl_dt_subnode_to_map(struct pinctrl_dev *pctldev,\n\t\t\t\tstruct device_node *np,\n\t\t\t\tstruct pinctrl_map **map)\n{\n\tstruct ltq_pinmux_info *info = pinctrl_dev_get_drvdata(pctldev);\n\tstruct property *pins = of_find_property(np, \"lantiq,pins\", NULL);\n\tstruct property *groups = of_find_property(np, \"lantiq,groups\", NULL);\n\tunsigned long configs[3];\n\tunsigned num_configs = 0;\n\tstruct property *prop;\n\tconst char *group, *pin;\n\tconst char *function;\n\tint ret, i;\n\n\tif (!pins && !groups) {\n\t\tdev_err(pctldev->dev, \"%pOFn defines neither pins nor groups\\n\",\n\t\t\tnp);\n\t\treturn;\n\t}\n\n\tif (pins && groups) {\n\t\tdev_err(pctldev->dev, \"%pOFn defines both pins and groups\\n\",\n\t\t\tnp);\n\t\treturn;\n\t}\n\n\tret = of_property_read_string(np, \"lantiq,function\", &function);\n\tif (groups && !ret) {\n\t\tof_property_for_each_string(np, \"lantiq,groups\", prop, group) {\n\t\t\t(*map)->type = PIN_MAP_TYPE_MUX_GROUP;\n\t\t\t(*map)->name = function;\n\t\t\t(*map)->data.mux.group = group;\n\t\t\t(*map)->data.mux.function = function;\n\t\t\t(*map)++;\n\t\t}\n\t}\n\n\tfor (i = 0; i < info->num_params; i++) {\n\t\tu32 val;\n\t\tint ret = of_property_read_u32(np,\n\t\t\t\tinfo->params[i].property, &val);\n\t\tif (!ret)\n\t\t\tconfigs[num_configs++] =\n\t\t\t\tLTQ_PINCONF_PACK(info->params[i].param,\n\t\t\t\tval);\n\t}\n\n\tif (!num_configs)\n\t\treturn;\n\n\tof_property_for_each_string(np, \"lantiq,pins\", prop, pin) {\n\t\t(*map)->data.configs.configs = kmemdup(configs,\n\t\t\t\t\tnum_configs * sizeof(unsigned long),\n\t\t\t\t\tGFP_KERNEL);\n\t\t(*map)->type = PIN_MAP_TYPE_CONFIGS_PIN;\n\t\t(*map)->name = pin;\n\t\t(*map)->data.configs.group_or_pin = pin;\n\t\t(*map)->data.configs.num_configs = num_configs;\n\t\t(*map)++;\n\t}\n\tof_property_for_each_string(np, \"lantiq,groups\", prop, group) {\n\t\t(*map)->data.configs.configs = kmemdup(configs,\n\t\t\t\t\tnum_configs * sizeof(unsigned long),\n\t\t\t\t\tGFP_KERNEL);\n\t\t(*map)->type = PIN_MAP_TYPE_CONFIGS_GROUP;\n\t\t(*map)->name = group;\n\t\t(*map)->data.configs.group_or_pin = group;\n\t\t(*map)->data.configs.num_configs = num_configs;\n\t\t(*map)++;\n\t}\n}\n\nstatic int ltq_pinctrl_dt_subnode_size(struct device_node *np)\n{\n\tint ret;\n\n\tret = of_property_count_strings(np, \"lantiq,groups\");\n\tif (ret < 0)\n\t\tret = of_property_count_strings(np, \"lantiq,pins\");\n\treturn ret;\n}\n\nstatic int ltq_pinctrl_dt_node_to_map(struct pinctrl_dev *pctldev,\n\t\t\t\t      struct device_node *np_config,\n\t\t\t\t      struct pinctrl_map **map,\n\t\t\t\t      unsigned *num_maps)\n{\n\tstruct pinctrl_map *tmp;\n\tstruct device_node *np;\n\tint max_maps = 0;\n\n\tfor_each_child_of_node(np_config, np)\n\t\tmax_maps += ltq_pinctrl_dt_subnode_size(np);\n\t*map = kzalloc(array3_size(max_maps, sizeof(struct pinctrl_map), 2),\n\t\t       GFP_KERNEL);\n\tif (!*map)\n\t\treturn -ENOMEM;\n\ttmp = *map;\n\n\tfor_each_child_of_node(np_config, np)\n\t\tltq_pinctrl_dt_subnode_to_map(pctldev, np, &tmp);\n\t*num_maps = ((int)(tmp - *map));\n\n\treturn 0;\n}\n\nstatic const struct pinctrl_ops ltq_pctrl_ops = {\n\t.get_groups_count\t= ltq_get_group_count,\n\t.get_group_name\t\t= ltq_get_group_name,\n\t.get_group_pins\t\t= ltq_get_group_pins,\n\t.pin_dbg_show\t\t= ltq_pinctrl_pin_dbg_show,\n\t.dt_node_to_map\t\t= ltq_pinctrl_dt_node_to_map,\n\t.dt_free_map\t\t= ltq_pinctrl_dt_free_map,\n};\n\nstatic int ltq_pmx_func_count(struct pinctrl_dev *pctrldev)\n{\n\tstruct ltq_pinmux_info *info = pinctrl_dev_get_drvdata(pctrldev);\n\n\treturn info->num_funcs;\n}\n\nstatic const char *ltq_pmx_func_name(struct pinctrl_dev *pctrldev,\n\t\t\t\t\t unsigned selector)\n{\n\tstruct ltq_pinmux_info *info = pinctrl_dev_get_drvdata(pctrldev);\n\n\tif (selector >= info->num_funcs)\n\t\treturn NULL;\n\n\treturn info->funcs[selector].name;\n}\n\nstatic int ltq_pmx_get_groups(struct pinctrl_dev *pctrldev,\n\t\t\t\tunsigned func,\n\t\t\t\tconst char * const **groups,\n\t\t\t\tunsigned * const num_groups)\n{\n\tstruct ltq_pinmux_info *info = pinctrl_dev_get_drvdata(pctrldev);\n\n\t*groups = info->funcs[func].groups;\n\t*num_groups = info->funcs[func].num_groups;\n\n\treturn 0;\n}\n\n \nstatic int match_mux(const struct ltq_mfp_pin *mfp, unsigned mux)\n{\n\tint i;\n\tfor (i = 0; i < LTQ_MAX_MUX; i++) {\n\t\tif (mfp->func[i] == mux)\n\t\t\tbreak;\n\t}\n\tif (i >= LTQ_MAX_MUX)\n\t\treturn -EINVAL;\n\treturn i;\n}\n\n \nstatic int match_mfp(const struct ltq_pinmux_info *info, int pin)\n{\n\tint i;\n\tfor (i = 0; i < info->num_mfp; i++) {\n\t\tif (info->mfp[i].pin == pin)\n\t\t\treturn i;\n\t}\n\treturn -1;\n}\n\n \nstatic int match_group_mux(const struct ltq_pin_group *grp,\n\t\t\t   const struct ltq_pinmux_info *info,\n\t\t\t   unsigned mux)\n{\n\tint i, pin, ret = 0;\n\tfor (i = 0; i < grp->npins; i++) {\n\t\tpin = match_mfp(info, grp->pins[i]);\n\t\tif (pin < 0) {\n\t\t\tdev_err(info->dev, \"could not find mfp for pin %d\\n\",\n\t\t\t\tgrp->pins[i]);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tret = match_mux(&info->mfp[pin], mux);\n\t\tif (ret < 0) {\n\t\t\tdev_err(info->dev, \"Can't find mux %d on pin%d\\n\",\n\t\t\t\tmux, pin);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int ltq_pmx_set(struct pinctrl_dev *pctrldev,\n\t\t       unsigned func,\n\t\t       unsigned group)\n{\n\tstruct ltq_pinmux_info *info = pinctrl_dev_get_drvdata(pctrldev);\n\tconst struct ltq_pin_group *pin_grp = &info->grps[group];\n\tint i, pin, pin_func, ret;\n\n\tif (!pin_grp->npins ||\n\t\t(match_group_mux(pin_grp, info, pin_grp->mux) < 0)) {\n\t\tdev_err(info->dev, \"Failed to set the pin group: %s\\n\",\n\t\t\tinfo->grps[group].name);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < pin_grp->npins; i++) {\n\t\tpin = match_mfp(info, pin_grp->pins[i]);\n\t\tif (pin < 0) {\n\t\t\tdev_err(info->dev, \"could not find mfp for pin %d\\n\",\n\t\t\t\tpin_grp->pins[i]);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpin_func = match_mux(&info->mfp[pin], pin_grp->mux);\n\t\tret = info->apply_mux(pctrldev, pin, pin_func);\n\t\tif (ret) {\n\t\t\tdev_err(info->dev,\n\t\t\t\t\"failed to apply mux %d for pin %d\\n\",\n\t\t\t\tpin_func, pin);\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int ltq_pmx_gpio_request_enable(struct pinctrl_dev *pctrldev,\n\t\t\t\tstruct pinctrl_gpio_range *range,\n\t\t\t\tunsigned pin)\n{\n\tstruct ltq_pinmux_info *info = pinctrl_dev_get_drvdata(pctrldev);\n\tint mfp = match_mfp(info, pin);\n\tint pin_func;\n\n\tif (mfp < 0) {\n\t\tdev_err(info->dev, \"could not find mfp for pin %d\\n\", pin);\n\t\treturn -EINVAL;\n\t}\n\n\tpin_func = match_mux(&info->mfp[mfp], 0);\n\tif (pin_func < 0) {\n\t\tdev_err(info->dev, \"No GPIO function on pin%d\\n\", mfp);\n\t\treturn -EINVAL;\n\t}\n\n\treturn info->apply_mux(pctrldev, mfp, pin_func);\n}\n\nstatic const struct pinmux_ops ltq_pmx_ops = {\n\t.get_functions_count\t= ltq_pmx_func_count,\n\t.get_function_name\t= ltq_pmx_func_name,\n\t.get_function_groups\t= ltq_pmx_get_groups,\n\t.set_mux\t\t= ltq_pmx_set,\n\t.gpio_request_enable\t= ltq_pmx_gpio_request_enable,\n};\n\n \nint ltq_pinctrl_register(struct platform_device *pdev,\n\t\t\t\tstruct ltq_pinmux_info *info)\n{\n\tstruct pinctrl_desc *desc;\n\n\tif (!info)\n\t\treturn -EINVAL;\n\tdesc = info->desc;\n\tdesc->pctlops = &ltq_pctrl_ops;\n\tdesc->pmxops = &ltq_pmx_ops;\n\tinfo->dev = &pdev->dev;\n\n\tinfo->pctrl = devm_pinctrl_register(&pdev->dev, desc, info);\n\tif (IS_ERR(info->pctrl)) {\n\t\tdev_err(&pdev->dev, \"failed to register LTQ pinmux driver\\n\");\n\t\treturn PTR_ERR(info->pctrl);\n\t}\n\tplatform_set_drvdata(pdev, info);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}