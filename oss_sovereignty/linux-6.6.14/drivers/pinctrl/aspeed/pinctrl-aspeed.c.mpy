{
  "module_name": "pinctrl-aspeed.c",
  "hash_id": "b4836fb5dccbfd8e0418df5dfdd74c6539a6123040f43220725f38a3c57e4b29",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/aspeed/pinctrl-aspeed.c",
  "human_readable_source": "\n \n\n#include <linux/mfd/syscon.h>\n#include <linux/platform_device.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include \"../core.h\"\n#include \"pinctrl-aspeed.h\"\n\nint aspeed_pinctrl_get_groups_count(struct pinctrl_dev *pctldev)\n{\n\tstruct aspeed_pinctrl_data *pdata = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pdata->pinmux.ngroups;\n}\n\nconst char *aspeed_pinctrl_get_group_name(struct pinctrl_dev *pctldev,\n\t\tunsigned int group)\n{\n\tstruct aspeed_pinctrl_data *pdata = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pdata->pinmux.groups[group].name;\n}\n\nint aspeed_pinctrl_get_group_pins(struct pinctrl_dev *pctldev,\n\t\t\t\t  unsigned int group, const unsigned int **pins,\n\t\t\t\t  unsigned int *npins)\n{\n\tstruct aspeed_pinctrl_data *pdata = pinctrl_dev_get_drvdata(pctldev);\n\n\t*pins = &pdata->pinmux.groups[group].pins[0];\n\t*npins = pdata->pinmux.groups[group].npins;\n\n\treturn 0;\n}\n\nvoid aspeed_pinctrl_pin_dbg_show(struct pinctrl_dev *pctldev,\n\t\t\t\t struct seq_file *s, unsigned int offset)\n{\n\tseq_printf(s, \" %s\", dev_name(pctldev->dev));\n}\n\nint aspeed_pinmux_get_fn_count(struct pinctrl_dev *pctldev)\n{\n\tstruct aspeed_pinctrl_data *pdata = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pdata->pinmux.nfunctions;\n}\n\nconst char *aspeed_pinmux_get_fn_name(struct pinctrl_dev *pctldev,\n\t\t\t\t      unsigned int function)\n{\n\tstruct aspeed_pinctrl_data *pdata = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pdata->pinmux.functions[function].name;\n}\n\nint aspeed_pinmux_get_fn_groups(struct pinctrl_dev *pctldev,\n\t\t\t\tunsigned int function,\n\t\t\t\tconst char * const **groups,\n\t\t\t\tunsigned int * const num_groups)\n{\n\tstruct aspeed_pinctrl_data *pdata = pinctrl_dev_get_drvdata(pctldev);\n\n\t*groups = pdata->pinmux.functions[function].groups;\n\t*num_groups = pdata->pinmux.functions[function].ngroups;\n\n\treturn 0;\n}\n\nstatic int aspeed_sig_expr_enable(struct aspeed_pinmux_data *ctx,\n\t\t\t\t  const struct aspeed_sig_expr *expr)\n{\n\tint ret;\n\n\tpr_debug(\"Enabling signal %s for %s\\n\", expr->signal,\n\t\t expr->function);\n\n\tret = aspeed_sig_expr_eval(ctx, expr, true);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!ret)\n\t\treturn aspeed_sig_expr_set(ctx, expr, true);\n\n\treturn 0;\n}\n\nstatic int aspeed_sig_expr_disable(struct aspeed_pinmux_data *ctx,\n\t\t\t\t   const struct aspeed_sig_expr *expr)\n{\n\tint ret;\n\n\tpr_debug(\"Disabling signal %s for %s\\n\", expr->signal,\n\t\t expr->function);\n\n\tret = aspeed_sig_expr_eval(ctx, expr, true);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret)\n\t\treturn aspeed_sig_expr_set(ctx, expr, false);\n\n\treturn 0;\n}\n\n \nstatic int aspeed_disable_sig(struct aspeed_pinmux_data *ctx,\n\t\t\t      const struct aspeed_sig_expr **exprs)\n{\n\tint ret = 0;\n\n\tif (!exprs)\n\t\treturn -EINVAL;\n\n\twhile (*exprs && !ret) {\n\t\tret = aspeed_sig_expr_disable(ctx, *exprs);\n\t\texprs++;\n\t}\n\n\treturn ret;\n}\n\n \nstatic const struct aspeed_sig_expr *aspeed_find_expr_by_name(\n\t\tconst struct aspeed_sig_expr **exprs, const char *name)\n{\n\twhile (*exprs) {\n\t\tif (strcmp((*exprs)->function, name) == 0)\n\t\t\treturn *exprs;\n\t\texprs++;\n\t}\n\n\treturn NULL;\n}\n\nstatic char *get_defined_attribute(const struct aspeed_pin_desc *pdesc,\n\t\t\t\t   const char *(*get)(\n\t\t\t\t\t   const struct aspeed_sig_expr *))\n{\n\tchar *found = NULL;\n\tsize_t len = 0;\n\tconst struct aspeed_sig_expr ***prios, **funcs, *expr;\n\n\tprios = pdesc->prios;\n\n\twhile ((funcs = *prios)) {\n\t\twhile ((expr = *funcs)) {\n\t\t\tconst char *str = get(expr);\n\t\t\tsize_t delta = strlen(str) + 2;\n\t\t\tchar *expanded;\n\n\t\t\texpanded = krealloc(found, len + delta + 1, GFP_KERNEL);\n\t\t\tif (!expanded) {\n\t\t\t\tkfree(found);\n\t\t\t\treturn expanded;\n\t\t\t}\n\n\t\t\tfound = expanded;\n\t\t\tfound[len] = '\\0';\n\t\t\tlen += delta;\n\n\t\t\tstrcat(found, str);\n\t\t\tstrcat(found, \", \");\n\n\t\t\tfuncs++;\n\t\t}\n\t\tprios++;\n\t}\n\n\tif (len < 2) {\n\t\tkfree(found);\n\t\treturn NULL;\n\t}\n\n\tfound[len - 2] = '\\0';\n\n\treturn found;\n}\n\nstatic const char *aspeed_sig_expr_function(const struct aspeed_sig_expr *expr)\n{\n\treturn expr->function;\n}\n\nstatic char *get_defined_functions(const struct aspeed_pin_desc *pdesc)\n{\n\treturn get_defined_attribute(pdesc, aspeed_sig_expr_function);\n}\n\nstatic const char *aspeed_sig_expr_signal(const struct aspeed_sig_expr *expr)\n{\n\treturn expr->signal;\n}\n\nstatic char *get_defined_signals(const struct aspeed_pin_desc *pdesc)\n{\n\treturn get_defined_attribute(pdesc, aspeed_sig_expr_signal);\n}\n\nint aspeed_pinmux_set_mux(struct pinctrl_dev *pctldev, unsigned int function,\n\t\t\t  unsigned int group)\n{\n\tint i;\n\tint ret;\n\tstruct aspeed_pinctrl_data *pdata = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct aspeed_pin_group *pgroup = &pdata->pinmux.groups[group];\n\tconst struct aspeed_pin_function *pfunc =\n\t\t&pdata->pinmux.functions[function];\n\n\tfor (i = 0; i < pgroup->npins; i++) {\n\t\tint pin = pgroup->pins[i];\n\t\tconst struct aspeed_pin_desc *pdesc = pdata->pins[pin].drv_data;\n\t\tconst struct aspeed_sig_expr *expr = NULL;\n\t\tconst struct aspeed_sig_expr **funcs;\n\t\tconst struct aspeed_sig_expr ***prios;\n\n\t\tif (!pdesc)\n\t\t\treturn -EINVAL;\n\n\t\tpr_debug(\"Muxing pin %s for %s\\n\", pdesc->name, pfunc->name);\n\n\t\tprios = pdesc->prios;\n\n\t\tif (!prios)\n\t\t\tcontinue;\n\n\t\t \n\t\twhile ((funcs = *prios)) {\n\t\t\texpr = aspeed_find_expr_by_name(funcs, pfunc->name);\n\n\t\t\tif (expr)\n\t\t\t\tbreak;\n\n\t\t\tret = aspeed_disable_sig(&pdata->pinmux, funcs);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tprios++;\n\t\t}\n\n\t\tif (!expr) {\n\t\t\tchar *functions = get_defined_functions(pdesc);\n\t\t\tchar *signals = get_defined_signals(pdesc);\n\n\t\t\tpr_warn(\"No function %s found on pin %s (%d). Found signal(s) %s for function(s) %s\\n\",\n\t\t\t\tpfunc->name, pdesc->name, pin, signals,\n\t\t\t\tfunctions);\n\t\t\tkfree(signals);\n\t\t\tkfree(functions);\n\n\t\t\treturn -ENXIO;\n\t\t}\n\n\t\tret = aspeed_sig_expr_enable(&pdata->pinmux, expr);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tpr_debug(\"Muxed pin %s as %s for %s\\n\", pdesc->name, expr->signal,\n\t\t\t expr->function);\n\t}\n\n\treturn 0;\n}\n\nstatic bool aspeed_expr_is_gpio(const struct aspeed_sig_expr *expr)\n{\n\t \n\treturn !strncmp(expr->signal, \"GPI\", 3) &&\n\t\t\t!strcmp(expr->signal, expr->function);\n}\n\nstatic bool aspeed_gpio_in_exprs(const struct aspeed_sig_expr **exprs)\n{\n\tif (!exprs)\n\t\treturn false;\n\n\twhile (*exprs) {\n\t\tif (aspeed_expr_is_gpio(*exprs))\n\t\t\treturn true;\n\t\texprs++;\n\t}\n\n\treturn false;\n}\n\nint aspeed_gpio_request_enable(struct pinctrl_dev *pctldev,\n\t\t\t       struct pinctrl_gpio_range *range,\n\t\t\t       unsigned int offset)\n{\n\tint ret;\n\tstruct aspeed_pinctrl_data *pdata = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct aspeed_pin_desc *pdesc = pdata->pins[offset].drv_data;\n\tconst struct aspeed_sig_expr ***prios, **funcs, *expr;\n\n\tif (!pdesc)\n\t\treturn -EINVAL;\n\n\tprios = pdesc->prios;\n\n\tif (!prios)\n\t\treturn -ENXIO;\n\n\tpr_debug(\"Muxing pin %s for GPIO\\n\", pdesc->name);\n\n\t \n\twhile ((funcs = *prios)) {\n\t\tif (aspeed_gpio_in_exprs(funcs))\n\t\t\tbreak;\n\n\t\tret = aspeed_disable_sig(&pdata->pinmux, funcs);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tprios++;\n\t}\n\n\tif (!funcs) {\n\t\tchar *signals = get_defined_signals(pdesc);\n\n\t\tpr_warn(\"No GPIO signal type found on pin %s (%d). Found: %s\\n\",\n\t\t\tpdesc->name, offset, signals);\n\t\tkfree(signals);\n\n\t\treturn -ENXIO;\n\t}\n\n\texpr = *funcs;\n\n\t \n\tif (!expr) {\n\t\tpr_debug(\"Muxed pin %s as GPIO\\n\", pdesc->name);\n\t\treturn 0;\n\t}\n\n\t \n\tret = aspeed_sig_expr_enable(&pdata->pinmux, expr);\n\tif (ret)\n\t\treturn ret;\n\n\tpr_debug(\"Muxed pin %s as %s\\n\", pdesc->name, expr->signal);\n\n\treturn 0;\n}\n\nint aspeed_pinctrl_probe(struct platform_device *pdev,\n\t\t\t struct pinctrl_desc *pdesc,\n\t\t\t struct aspeed_pinctrl_data *pdata)\n{\n\tstruct device *parent;\n\tstruct pinctrl_dev *pctl;\n\n\tparent = pdev->dev.parent;\n\tif (!parent) {\n\t\tdev_err(&pdev->dev, \"No parent for syscon pincontroller\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpdata->scu = syscon_node_to_regmap(parent->of_node);\n\tif (IS_ERR(pdata->scu)) {\n\t\tdev_err(&pdev->dev, \"No regmap for syscon pincontroller parent\\n\");\n\t\treturn PTR_ERR(pdata->scu);\n\t}\n\n\tpdata->pinmux.maps[ASPEED_IP_SCU] = pdata->scu;\n\n\tpctl = pinctrl_register(pdesc, &pdev->dev, pdata);\n\n\tif (IS_ERR(pctl)) {\n\t\tdev_err(&pdev->dev, \"Failed to register pinctrl\\n\");\n\t\treturn PTR_ERR(pctl);\n\t}\n\n\tplatform_set_drvdata(pdev, pdata);\n\n\treturn 0;\n}\n\nstatic inline bool pin_in_config_range(unsigned int offset,\n\t\tconst struct aspeed_pin_config *config)\n{\n\treturn offset >= config->pins[0] && offset <= config->pins[1];\n}\n\nstatic inline const struct aspeed_pin_config *find_pinconf_config(\n\t\tconst struct aspeed_pinctrl_data *pdata,\n\t\tunsigned int offset,\n\t\tenum pin_config_param param)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < pdata->nconfigs; i++) {\n\t\tif (param == pdata->configs[i].param &&\n\t\t\t\tpin_in_config_range(offset, &pdata->configs[i]))\n\t\t\treturn &pdata->configs[i];\n\t}\n\n\treturn NULL;\n}\n\nenum aspeed_pin_config_map_type { MAP_TYPE_ARG, MAP_TYPE_VAL };\n\nstatic const struct aspeed_pin_config_map *find_pinconf_map(\n\t\tconst struct aspeed_pinctrl_data *pdata,\n\t\tenum pin_config_param param,\n\t\tenum aspeed_pin_config_map_type type,\n\t\ts64 value)\n{\n\tint i;\n\n\tfor (i = 0; i < pdata->nconfmaps; i++) {\n\t\tconst struct aspeed_pin_config_map *elem;\n\t\tbool match;\n\n\t\telem = &pdata->confmaps[i];\n\n\t\tswitch (type) {\n\t\tcase MAP_TYPE_ARG:\n\t\t\tmatch = (elem->arg == -1 || elem->arg == value);\n\t\t\tbreak;\n\t\tcase MAP_TYPE_VAL:\n\t\t\tmatch = (elem->val == value);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (param == elem->param && match)\n\t\t\treturn elem;\n\t}\n\n\treturn NULL;\n}\n\nint aspeed_pin_config_get(struct pinctrl_dev *pctldev, unsigned int offset,\n\t\tunsigned long *config)\n{\n\tconst enum pin_config_param param = pinconf_to_config_param(*config);\n\tconst struct aspeed_pin_config_map *pmap;\n\tconst struct aspeed_pinctrl_data *pdata;\n\tconst struct aspeed_pin_config *pconf;\n\tunsigned int val;\n\tint rc = 0;\n\tu32 arg;\n\n\tpdata = pinctrl_dev_get_drvdata(pctldev);\n\tpconf = find_pinconf_config(pdata, offset, param);\n\tif (!pconf)\n\t\treturn -ENOTSUPP;\n\n\trc = regmap_read(pdata->scu, pconf->reg, &val);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tpmap = find_pinconf_map(pdata, param, MAP_TYPE_VAL,\n\t\t\t(val & pconf->mask) >> __ffs(pconf->mask));\n\n\tif (!pmap)\n\t\treturn -EINVAL;\n\n\tif (param == PIN_CONFIG_DRIVE_STRENGTH)\n\t\targ = (u32) pmap->arg;\n\telse if (param == PIN_CONFIG_BIAS_PULL_DOWN)\n\t\targ = !!pmap->arg;\n\telse\n\t\targ = 1;\n\n\tif (!arg)\n\t\treturn -EINVAL;\n\n\t*config = pinconf_to_config_packed(param, arg);\n\n\treturn 0;\n}\n\nint aspeed_pin_config_set(struct pinctrl_dev *pctldev, unsigned int offset,\n\t\tunsigned long *configs, unsigned int num_configs)\n{\n\tconst struct aspeed_pinctrl_data *pdata;\n\tunsigned int i;\n\tint rc = 0;\n\n\tpdata = pinctrl_dev_get_drvdata(pctldev);\n\n\tfor (i = 0; i < num_configs; i++) {\n\t\tconst struct aspeed_pin_config_map *pmap;\n\t\tconst struct aspeed_pin_config *pconf;\n\t\tenum pin_config_param param;\n\t\tunsigned int val;\n\t\tu32 arg;\n\n\t\tparam = pinconf_to_config_param(configs[i]);\n\t\targ = pinconf_to_config_argument(configs[i]);\n\n\t\tpconf = find_pinconf_config(pdata, offset, param);\n\t\tif (!pconf)\n\t\t\treturn -ENOTSUPP;\n\n\t\tpmap = find_pinconf_map(pdata, param, MAP_TYPE_ARG, arg);\n\n\t\tif (WARN_ON(!pmap))\n\t\t\treturn -EINVAL;\n\n\t\tval = pmap->val << __ffs(pconf->mask);\n\n\t\trc = regmap_update_bits(pdata->scu, pconf->reg,\n\t\t\t\t\tpconf->mask, val);\n\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\tpr_debug(\"%s: Set SCU%02X[0x%08X]=0x%X for param %d(=%d) on pin %d\\n\",\n\t\t\t\t__func__, pconf->reg, pconf->mask,\n\t\t\t\tval, param, arg, offset);\n\t}\n\n\treturn 0;\n}\n\nint aspeed_pin_config_group_get(struct pinctrl_dev *pctldev,\n\t\tunsigned int selector,\n\t\tunsigned long *config)\n{\n\tconst unsigned int *pins;\n\tunsigned int npins;\n\tint rc;\n\n\trc = aspeed_pinctrl_get_group_pins(pctldev, selector, &pins, &npins);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tif (!npins)\n\t\treturn -ENODEV;\n\n\trc = aspeed_pin_config_get(pctldev, pins[0], config);\n\n\treturn rc;\n}\n\nint aspeed_pin_config_group_set(struct pinctrl_dev *pctldev,\n\t\tunsigned int selector,\n\t\tunsigned long *configs,\n\t\tunsigned int num_configs)\n{\n\tconst unsigned int *pins;\n\tunsigned int npins;\n\tint rc;\n\tint i;\n\n\tpr_debug(\"%s: Fetching pins for group selector %d\\n\",\n\t\t\t__func__, selector);\n\trc = aspeed_pinctrl_get_group_pins(pctldev, selector, &pins, &npins);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tfor (i = 0; i < npins; i++) {\n\t\trc = aspeed_pin_config_set(pctldev, pins[i], configs,\n\t\t\t\tnum_configs);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}