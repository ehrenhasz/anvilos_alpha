{
  "module_name": "pinctrl-tegra-xusb.c",
  "hash_id": "50e5bddf95ba5ac7e5345f41a785a1555e5654b4a541b02179e17f948def9e7e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/tegra/pinctrl-tegra-xusb.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinmux.h>\n\n#include <dt-bindings/pinctrl/pinctrl-tegra-xusb.h>\n\n#include \"../core.h\"\n#include \"../pinctrl-utils.h\"\n\n#define XUSB_PADCTL_ELPG_PROGRAM 0x01c\n#define XUSB_PADCTL_ELPG_PROGRAM_AUX_MUX_LP0_VCORE_DOWN (1 << 26)\n#define XUSB_PADCTL_ELPG_PROGRAM_AUX_MUX_LP0_CLAMP_EN_EARLY (1 << 25)\n#define XUSB_PADCTL_ELPG_PROGRAM_AUX_MUX_LP0_CLAMP_EN (1 << 24)\n\n#define XUSB_PADCTL_IOPHY_PLL_P0_CTL1 0x040\n#define XUSB_PADCTL_IOPHY_PLL_P0_CTL1_PLL0_LOCKDET (1 << 19)\n#define XUSB_PADCTL_IOPHY_PLL_P0_CTL1_REFCLK_SEL_MASK (0xf << 12)\n#define XUSB_PADCTL_IOPHY_PLL_P0_CTL1_PLL_RST (1 << 1)\n\n#define XUSB_PADCTL_IOPHY_PLL_P0_CTL2 0x044\n#define XUSB_PADCTL_IOPHY_PLL_P0_CTL2_REFCLKBUF_EN (1 << 6)\n#define XUSB_PADCTL_IOPHY_PLL_P0_CTL2_TXCLKREF_EN (1 << 5)\n#define XUSB_PADCTL_IOPHY_PLL_P0_CTL2_TXCLKREF_SEL (1 << 4)\n\n#define XUSB_PADCTL_IOPHY_PLL_S0_CTL1 0x138\n#define XUSB_PADCTL_IOPHY_PLL_S0_CTL1_PLL1_LOCKDET (1 << 27)\n#define XUSB_PADCTL_IOPHY_PLL_S0_CTL1_PLL1_MODE (1 << 24)\n#define XUSB_PADCTL_IOPHY_PLL_S0_CTL1_PLL_PWR_OVRD (1 << 3)\n#define XUSB_PADCTL_IOPHY_PLL_S0_CTL1_PLL_RST (1 << 1)\n#define XUSB_PADCTL_IOPHY_PLL_S0_CTL1_PLL_IDDQ (1 << 0)\n\n#define XUSB_PADCTL_IOPHY_MISC_PAD_S0_CTL1 0x148\n#define XUSB_PADCTL_IOPHY_MISC_PAD_S0_CTL1_IDDQ_OVRD (1 << 1)\n#define XUSB_PADCTL_IOPHY_MISC_PAD_S0_CTL1_IDDQ (1 << 0)\n\nstruct tegra_xusb_padctl_function {\n\tconst char *name;\n\tconst char * const *groups;\n\tunsigned int num_groups;\n};\n\nstruct tegra_xusb_padctl_soc {\n\tconst struct pinctrl_pin_desc *pins;\n\tunsigned int num_pins;\n\n\tconst struct tegra_xusb_padctl_function *functions;\n\tunsigned int num_functions;\n\n\tconst struct tegra_xusb_padctl_lane *lanes;\n\tunsigned int num_lanes;\n};\n\nstruct tegra_xusb_padctl_lane {\n\tconst char *name;\n\n\tunsigned int offset;\n\tunsigned int shift;\n\tunsigned int mask;\n\tunsigned int iddq;\n\n\tconst unsigned int *funcs;\n\tunsigned int num_funcs;\n};\n\nstruct tegra_xusb_padctl {\n\tstruct device *dev;\n\tvoid __iomem *regs;\n\tstruct mutex lock;\n\tstruct reset_control *rst;\n\n\tconst struct tegra_xusb_padctl_soc *soc;\n\tstruct pinctrl_dev *pinctrl;\n\tstruct pinctrl_desc desc;\n\n\tstruct phy_provider *provider;\n\tstruct phy *phys[2];\n\n\tunsigned int enable;\n};\n\nstatic inline void padctl_writel(struct tegra_xusb_padctl *padctl, u32 value,\n\t\t\t\t unsigned long offset)\n{\n\twritel(value, padctl->regs + offset);\n}\n\nstatic inline u32 padctl_readl(struct tegra_xusb_padctl *padctl,\n\t\t\t       unsigned long offset)\n{\n\treturn readl(padctl->regs + offset);\n}\n\nstatic int tegra_xusb_padctl_get_groups_count(struct pinctrl_dev *pinctrl)\n{\n\tstruct tegra_xusb_padctl *padctl = pinctrl_dev_get_drvdata(pinctrl);\n\n\treturn padctl->soc->num_pins;\n}\n\nstatic const char *tegra_xusb_padctl_get_group_name(struct pinctrl_dev *pinctrl,\n\t\t\t\t\t\t    unsigned int group)\n{\n\tstruct tegra_xusb_padctl *padctl = pinctrl_dev_get_drvdata(pinctrl);\n\n\treturn padctl->soc->pins[group].name;\n}\n\nstatic int tegra_xusb_padctl_get_group_pins(struct pinctrl_dev *pinctrl,\n\t\t\t\t\t    unsigned group,\n\t\t\t\t\t    const unsigned **pins,\n\t\t\t\t\t    unsigned *num_pins)\n{\n\t \n\t*pins = &pinctrl->desc->pins[group].number;\n\t*num_pins = 1;\n\n\treturn 0;\n}\n\nenum tegra_xusb_padctl_param {\n\tTEGRA_XUSB_PADCTL_IDDQ,\n};\n\nstatic const struct tegra_xusb_padctl_property {\n\tconst char *name;\n\tenum tegra_xusb_padctl_param param;\n} properties[] = {\n\t{ \"nvidia,iddq\", TEGRA_XUSB_PADCTL_IDDQ },\n};\n\n#define TEGRA_XUSB_PADCTL_PACK(param, value) ((param) << 16 | (value))\n#define TEGRA_XUSB_PADCTL_UNPACK_PARAM(config) ((config) >> 16)\n#define TEGRA_XUSB_PADCTL_UNPACK_VALUE(config) ((config) & 0xffff)\n\nstatic int tegra_xusb_padctl_parse_subnode(struct tegra_xusb_padctl *padctl,\n\t\t\t\t\t   struct device_node *np,\n\t\t\t\t\t   struct pinctrl_map **maps,\n\t\t\t\t\t   unsigned int *reserved_maps,\n\t\t\t\t\t   unsigned int *num_maps)\n{\n\tunsigned int i, reserve = 0, num_configs = 0;\n\tunsigned long config, *configs = NULL;\n\tconst char *function, *group;\n\tstruct property *prop;\n\tint err = 0;\n\tu32 value;\n\n\terr = of_property_read_string(np, \"nvidia,function\", &function);\n\tif (err < 0) {\n\t\tif (err != -EINVAL)\n\t\t\treturn err;\n\n\t\tfunction = NULL;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(properties); i++) {\n\t\terr = of_property_read_u32(np, properties[i].name, &value);\n\t\tif (err < 0) {\n\t\t\tif (err == -EINVAL)\n\t\t\t\tcontinue;\n\n\t\t\tgoto out;\n\t\t}\n\n\t\tconfig = TEGRA_XUSB_PADCTL_PACK(properties[i].param, value);\n\n\t\terr = pinctrl_utils_add_config(padctl->pinctrl, &configs,\n\t\t\t\t\t       &num_configs, config);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\n\tif (function)\n\t\treserve++;\n\n\tif (num_configs)\n\t\treserve++;\n\n\terr = of_property_count_strings(np, \"nvidia,lanes\");\n\tif (err < 0)\n\t\tgoto out;\n\n\treserve *= err;\n\n\terr = pinctrl_utils_reserve_map(padctl->pinctrl, maps, reserved_maps,\n\t\t\t\t\tnum_maps, reserve);\n\tif (err < 0)\n\t\tgoto out;\n\n\tof_property_for_each_string(np, \"nvidia,lanes\", prop, group) {\n\t\tif (function) {\n\t\t\terr = pinctrl_utils_add_map_mux(padctl->pinctrl, maps,\n\t\t\t\t\treserved_maps, num_maps, group,\n\t\t\t\t\tfunction);\n\t\t\tif (err < 0)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tif (num_configs) {\n\t\t\terr = pinctrl_utils_add_map_configs(padctl->pinctrl,\n\t\t\t\t\tmaps, reserved_maps, num_maps, group,\n\t\t\t\t\tconfigs, num_configs,\n\t\t\t\t\tPIN_MAP_TYPE_CONFIGS_GROUP);\n\t\t\tif (err < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\terr = 0;\n\nout:\n\tkfree(configs);\n\treturn err;\n}\n\nstatic int tegra_xusb_padctl_dt_node_to_map(struct pinctrl_dev *pinctrl,\n\t\t\t\t\t    struct device_node *parent,\n\t\t\t\t\t    struct pinctrl_map **maps,\n\t\t\t\t\t    unsigned int *num_maps)\n{\n\tstruct tegra_xusb_padctl *padctl = pinctrl_dev_get_drvdata(pinctrl);\n\tunsigned int reserved_maps = 0;\n\tstruct device_node *np;\n\tint err;\n\n\t*num_maps = 0;\n\t*maps = NULL;\n\n\tfor_each_child_of_node(parent, np) {\n\t\terr = tegra_xusb_padctl_parse_subnode(padctl, np, maps,\n\t\t\t\t\t\t      &reserved_maps,\n\t\t\t\t\t\t      num_maps);\n\t\tif (err < 0) {\n\t\t\tof_node_put(np);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct pinctrl_ops tegra_xusb_padctl_pinctrl_ops = {\n\t.get_groups_count = tegra_xusb_padctl_get_groups_count,\n\t.get_group_name = tegra_xusb_padctl_get_group_name,\n\t.get_group_pins = tegra_xusb_padctl_get_group_pins,\n\t.dt_node_to_map = tegra_xusb_padctl_dt_node_to_map,\n\t.dt_free_map = pinctrl_utils_free_map,\n};\n\nstatic int tegra_xusb_padctl_get_functions_count(struct pinctrl_dev *pinctrl)\n{\n\tstruct tegra_xusb_padctl *padctl = pinctrl_dev_get_drvdata(pinctrl);\n\n\treturn padctl->soc->num_functions;\n}\n\nstatic const char *\ntegra_xusb_padctl_get_function_name(struct pinctrl_dev *pinctrl,\n\t\t\t\t    unsigned int function)\n{\n\tstruct tegra_xusb_padctl *padctl = pinctrl_dev_get_drvdata(pinctrl);\n\n\treturn padctl->soc->functions[function].name;\n}\n\nstatic int tegra_xusb_padctl_get_function_groups(struct pinctrl_dev *pinctrl,\n\t\t\t\t\t\t unsigned int function,\n\t\t\t\t\t\t const char * const **groups,\n\t\t\t\t\t\t unsigned * const num_groups)\n{\n\tstruct tegra_xusb_padctl *padctl = pinctrl_dev_get_drvdata(pinctrl);\n\n\t*num_groups = padctl->soc->functions[function].num_groups;\n\t*groups = padctl->soc->functions[function].groups;\n\n\treturn 0;\n}\n\nstatic int tegra_xusb_padctl_pinmux_set(struct pinctrl_dev *pinctrl,\n\t\t\t\t\tunsigned int function,\n\t\t\t\t\tunsigned int group)\n{\n\tstruct tegra_xusb_padctl *padctl = pinctrl_dev_get_drvdata(pinctrl);\n\tconst struct tegra_xusb_padctl_lane *lane;\n\tunsigned int i;\n\tu32 value;\n\n\tlane = &padctl->soc->lanes[group];\n\n\tfor (i = 0; i < lane->num_funcs; i++)\n\t\tif (lane->funcs[i] == function)\n\t\t\tbreak;\n\n\tif (i >= lane->num_funcs)\n\t\treturn -EINVAL;\n\n\tvalue = padctl_readl(padctl, lane->offset);\n\tvalue &= ~(lane->mask << lane->shift);\n\tvalue |= i << lane->shift;\n\tpadctl_writel(padctl, value, lane->offset);\n\n\treturn 0;\n}\n\nstatic const struct pinmux_ops tegra_xusb_padctl_pinmux_ops = {\n\t.get_functions_count = tegra_xusb_padctl_get_functions_count,\n\t.get_function_name = tegra_xusb_padctl_get_function_name,\n\t.get_function_groups = tegra_xusb_padctl_get_function_groups,\n\t.set_mux = tegra_xusb_padctl_pinmux_set,\n};\n\nstatic int tegra_xusb_padctl_pinconf_group_get(struct pinctrl_dev *pinctrl,\n\t\t\t\t\t       unsigned int group,\n\t\t\t\t\t       unsigned long *config)\n{\n\tstruct tegra_xusb_padctl *padctl = pinctrl_dev_get_drvdata(pinctrl);\n\tconst struct tegra_xusb_padctl_lane *lane;\n\tenum tegra_xusb_padctl_param param;\n\tu32 value;\n\n\tparam = TEGRA_XUSB_PADCTL_UNPACK_PARAM(*config);\n\tlane = &padctl->soc->lanes[group];\n\n\tswitch (param) {\n\tcase TEGRA_XUSB_PADCTL_IDDQ:\n\t\t \n\t\tif (lane->iddq == 0)\n\t\t\treturn -EINVAL;\n\n\t\tvalue = padctl_readl(padctl, lane->offset);\n\n\t\tif (value & BIT(lane->iddq))\n\t\t\tvalue = 0;\n\t\telse\n\t\t\tvalue = 1;\n\n\t\t*config = TEGRA_XUSB_PADCTL_PACK(param, value);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(padctl->dev, \"invalid configuration parameter: %04x\\n\",\n\t\t\tparam);\n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra_xusb_padctl_pinconf_group_set(struct pinctrl_dev *pinctrl,\n\t\t\t\t\t       unsigned int group,\n\t\t\t\t\t       unsigned long *configs,\n\t\t\t\t\t       unsigned int num_configs)\n{\n\tstruct tegra_xusb_padctl *padctl = pinctrl_dev_get_drvdata(pinctrl);\n\tconst struct tegra_xusb_padctl_lane *lane;\n\tenum tegra_xusb_padctl_param param;\n\tunsigned long value;\n\tunsigned int i;\n\tu32 regval;\n\n\tlane = &padctl->soc->lanes[group];\n\n\tfor (i = 0; i < num_configs; i++) {\n\t\tparam = TEGRA_XUSB_PADCTL_UNPACK_PARAM(configs[i]);\n\t\tvalue = TEGRA_XUSB_PADCTL_UNPACK_VALUE(configs[i]);\n\n\t\tswitch (param) {\n\t\tcase TEGRA_XUSB_PADCTL_IDDQ:\n\t\t\t \n\t\t\tif (lane->iddq == 0)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tregval = padctl_readl(padctl, lane->offset);\n\n\t\t\tif (value)\n\t\t\t\tregval &= ~BIT(lane->iddq);\n\t\t\telse\n\t\t\t\tregval |= BIT(lane->iddq);\n\n\t\t\tpadctl_writel(padctl, regval, lane->offset);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_err(padctl->dev,\n\t\t\t\t\"invalid configuration parameter: %04x\\n\",\n\t\t\t\tparam);\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic const char *strip_prefix(const char *s)\n{\n\tconst char *comma = strchr(s, ',');\n\tif (!comma)\n\t\treturn s;\n\n\treturn comma + 1;\n}\n\nstatic void\ntegra_xusb_padctl_pinconf_group_dbg_show(struct pinctrl_dev *pinctrl,\n\t\t\t\t\t struct seq_file *s,\n\t\t\t\t\t unsigned int group)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(properties); i++) {\n\t\tunsigned long config, value;\n\t\tint err;\n\n\t\tconfig = TEGRA_XUSB_PADCTL_PACK(properties[i].param, 0);\n\n\t\terr = tegra_xusb_padctl_pinconf_group_get(pinctrl, group,\n\t\t\t\t\t\t\t  &config);\n\t\tif (err < 0)\n\t\t\tcontinue;\n\n\t\tvalue = TEGRA_XUSB_PADCTL_UNPACK_VALUE(config);\n\n\t\tseq_printf(s, \"\\n\\t%s=%lu\\n\", strip_prefix(properties[i].name),\n\t\t\t   value);\n\t}\n}\n\nstatic void\ntegra_xusb_padctl_pinconf_config_dbg_show(struct pinctrl_dev *pinctrl,\n\t\t\t\t\t  struct seq_file *s,\n\t\t\t\t\t  unsigned long config)\n{\n\tenum tegra_xusb_padctl_param param;\n\tconst char *name = \"unknown\";\n\tunsigned long value;\n\tunsigned int i;\n\n\tparam = TEGRA_XUSB_PADCTL_UNPACK_PARAM(config);\n\tvalue = TEGRA_XUSB_PADCTL_UNPACK_VALUE(config);\n\n\tfor (i = 0; i < ARRAY_SIZE(properties); i++) {\n\t\tif (properties[i].param == param) {\n\t\t\tname = properties[i].name;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tseq_printf(s, \"%s=%lu\", strip_prefix(name), value);\n}\n#endif\n\nstatic const struct pinconf_ops tegra_xusb_padctl_pinconf_ops = {\n\t.pin_config_group_get = tegra_xusb_padctl_pinconf_group_get,\n\t.pin_config_group_set = tegra_xusb_padctl_pinconf_group_set,\n#ifdef CONFIG_DEBUG_FS\n\t.pin_config_group_dbg_show = tegra_xusb_padctl_pinconf_group_dbg_show,\n\t.pin_config_config_dbg_show = tegra_xusb_padctl_pinconf_config_dbg_show,\n#endif\n};\n\nstatic int tegra_xusb_padctl_enable(struct tegra_xusb_padctl *padctl)\n{\n\tu32 value;\n\n\tmutex_lock(&padctl->lock);\n\n\tif (padctl->enable++ > 0)\n\t\tgoto out;\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM);\n\tvalue &= ~XUSB_PADCTL_ELPG_PROGRAM_AUX_MUX_LP0_CLAMP_EN;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM);\n\n\tusleep_range(100, 200);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM);\n\tvalue &= ~XUSB_PADCTL_ELPG_PROGRAM_AUX_MUX_LP0_CLAMP_EN_EARLY;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM);\n\n\tusleep_range(100, 200);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM);\n\tvalue &= ~XUSB_PADCTL_ELPG_PROGRAM_AUX_MUX_LP0_VCORE_DOWN;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM);\n\nout:\n\tmutex_unlock(&padctl->lock);\n\treturn 0;\n}\n\nstatic int tegra_xusb_padctl_disable(struct tegra_xusb_padctl *padctl)\n{\n\tu32 value;\n\n\tmutex_lock(&padctl->lock);\n\n\tif (WARN_ON(padctl->enable == 0))\n\t\tgoto out;\n\n\tif (--padctl->enable > 0)\n\t\tgoto out;\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM);\n\tvalue |= XUSB_PADCTL_ELPG_PROGRAM_AUX_MUX_LP0_VCORE_DOWN;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM);\n\n\tusleep_range(100, 200);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM);\n\tvalue |= XUSB_PADCTL_ELPG_PROGRAM_AUX_MUX_LP0_CLAMP_EN_EARLY;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM);\n\n\tusleep_range(100, 200);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_ELPG_PROGRAM);\n\tvalue |= XUSB_PADCTL_ELPG_PROGRAM_AUX_MUX_LP0_CLAMP_EN;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_ELPG_PROGRAM);\n\nout:\n\tmutex_unlock(&padctl->lock);\n\treturn 0;\n}\n\nstatic int tegra_xusb_phy_init(struct phy *phy)\n{\n\tstruct tegra_xusb_padctl *padctl = phy_get_drvdata(phy);\n\n\treturn tegra_xusb_padctl_enable(padctl);\n}\n\nstatic int tegra_xusb_phy_exit(struct phy *phy)\n{\n\tstruct tegra_xusb_padctl *padctl = phy_get_drvdata(phy);\n\n\treturn tegra_xusb_padctl_disable(padctl);\n}\n\nstatic int pcie_phy_power_on(struct phy *phy)\n{\n\tstruct tegra_xusb_padctl *padctl = phy_get_drvdata(phy);\n\tunsigned long timeout;\n\tint err = -ETIMEDOUT;\n\tu32 value;\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_PLL_P0_CTL1);\n\tvalue &= ~XUSB_PADCTL_IOPHY_PLL_P0_CTL1_REFCLK_SEL_MASK;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_PLL_P0_CTL1);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_PLL_P0_CTL2);\n\tvalue |= XUSB_PADCTL_IOPHY_PLL_P0_CTL2_REFCLKBUF_EN |\n\t\t XUSB_PADCTL_IOPHY_PLL_P0_CTL2_TXCLKREF_EN |\n\t\t XUSB_PADCTL_IOPHY_PLL_P0_CTL2_TXCLKREF_SEL;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_PLL_P0_CTL2);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_PLL_P0_CTL1);\n\tvalue |= XUSB_PADCTL_IOPHY_PLL_P0_CTL1_PLL_RST;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_PLL_P0_CTL1);\n\n\ttimeout = jiffies + msecs_to_jiffies(50);\n\n\twhile (time_before(jiffies, timeout)) {\n\t\tvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_PLL_P0_CTL1);\n\t\tif (value & XUSB_PADCTL_IOPHY_PLL_P0_CTL1_PLL0_LOCKDET) {\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tusleep_range(100, 200);\n\t}\n\n\treturn err;\n}\n\nstatic int pcie_phy_power_off(struct phy *phy)\n{\n\tstruct tegra_xusb_padctl *padctl = phy_get_drvdata(phy);\n\tu32 value;\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_PLL_P0_CTL1);\n\tvalue &= ~XUSB_PADCTL_IOPHY_PLL_P0_CTL1_PLL_RST;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_PLL_P0_CTL1);\n\n\treturn 0;\n}\n\nstatic const struct phy_ops pcie_phy_ops = {\n\t.init = tegra_xusb_phy_init,\n\t.exit = tegra_xusb_phy_exit,\n\t.power_on = pcie_phy_power_on,\n\t.power_off = pcie_phy_power_off,\n\t.owner = THIS_MODULE,\n};\n\nstatic int sata_phy_power_on(struct phy *phy)\n{\n\tstruct tegra_xusb_padctl *padctl = phy_get_drvdata(phy);\n\tunsigned long timeout;\n\tint err = -ETIMEDOUT;\n\tu32 value;\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_MISC_PAD_S0_CTL1);\n\tvalue &= ~XUSB_PADCTL_IOPHY_MISC_PAD_S0_CTL1_IDDQ_OVRD;\n\tvalue &= ~XUSB_PADCTL_IOPHY_MISC_PAD_S0_CTL1_IDDQ;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_MISC_PAD_S0_CTL1);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_PLL_S0_CTL1);\n\tvalue &= ~XUSB_PADCTL_IOPHY_PLL_S0_CTL1_PLL_PWR_OVRD;\n\tvalue &= ~XUSB_PADCTL_IOPHY_PLL_S0_CTL1_PLL_IDDQ;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_PLL_S0_CTL1);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_PLL_S0_CTL1);\n\tvalue |= XUSB_PADCTL_IOPHY_PLL_S0_CTL1_PLL1_MODE;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_PLL_S0_CTL1);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_PLL_S0_CTL1);\n\tvalue |= XUSB_PADCTL_IOPHY_PLL_S0_CTL1_PLL_RST;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_PLL_S0_CTL1);\n\n\ttimeout = jiffies + msecs_to_jiffies(50);\n\n\twhile (time_before(jiffies, timeout)) {\n\t\tvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_PLL_S0_CTL1);\n\t\tif (value & XUSB_PADCTL_IOPHY_PLL_S0_CTL1_PLL1_LOCKDET) {\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tusleep_range(100, 200);\n\t}\n\n\treturn err;\n}\n\nstatic int sata_phy_power_off(struct phy *phy)\n{\n\tstruct tegra_xusb_padctl *padctl = phy_get_drvdata(phy);\n\tu32 value;\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_PLL_S0_CTL1);\n\tvalue &= ~XUSB_PADCTL_IOPHY_PLL_S0_CTL1_PLL_RST;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_PLL_S0_CTL1);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_PLL_S0_CTL1);\n\tvalue &= ~XUSB_PADCTL_IOPHY_PLL_S0_CTL1_PLL1_MODE;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_PLL_S0_CTL1);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_PLL_S0_CTL1);\n\tvalue |= XUSB_PADCTL_IOPHY_PLL_S0_CTL1_PLL_PWR_OVRD;\n\tvalue |= XUSB_PADCTL_IOPHY_PLL_S0_CTL1_PLL_IDDQ;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_PLL_S0_CTL1);\n\n\tvalue = padctl_readl(padctl, XUSB_PADCTL_IOPHY_MISC_PAD_S0_CTL1);\n\tvalue |= ~XUSB_PADCTL_IOPHY_MISC_PAD_S0_CTL1_IDDQ_OVRD;\n\tvalue |= ~XUSB_PADCTL_IOPHY_MISC_PAD_S0_CTL1_IDDQ;\n\tpadctl_writel(padctl, value, XUSB_PADCTL_IOPHY_MISC_PAD_S0_CTL1);\n\n\treturn 0;\n}\n\nstatic const struct phy_ops sata_phy_ops = {\n\t.init = tegra_xusb_phy_init,\n\t.exit = tegra_xusb_phy_exit,\n\t.power_on = sata_phy_power_on,\n\t.power_off = sata_phy_power_off,\n\t.owner = THIS_MODULE,\n};\n\nstatic struct phy *tegra_xusb_padctl_xlate(struct device *dev,\n\t\t\t\t\t   struct of_phandle_args *args)\n{\n\tstruct tegra_xusb_padctl *padctl = dev_get_drvdata(dev);\n\tunsigned int index = args->args[0];\n\n\tif (args->args_count <= 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (index >= ARRAY_SIZE(padctl->phys))\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn padctl->phys[index];\n}\n\n#define PIN_OTG_0   0\n#define PIN_OTG_1   1\n#define PIN_OTG_2   2\n#define PIN_ULPI_0  3\n#define PIN_HSIC_0  4\n#define PIN_HSIC_1  5\n#define PIN_PCIE_0  6\n#define PIN_PCIE_1  7\n#define PIN_PCIE_2  8\n#define PIN_PCIE_3  9\n#define PIN_PCIE_4 10\n#define PIN_SATA_0 11\n\nstatic const struct pinctrl_pin_desc tegra124_pins[] = {\n\tPINCTRL_PIN(PIN_OTG_0,  \"otg-0\"),\n\tPINCTRL_PIN(PIN_OTG_1,  \"otg-1\"),\n\tPINCTRL_PIN(PIN_OTG_2,  \"otg-2\"),\n\tPINCTRL_PIN(PIN_ULPI_0, \"ulpi-0\"),\n\tPINCTRL_PIN(PIN_HSIC_0, \"hsic-0\"),\n\tPINCTRL_PIN(PIN_HSIC_1, \"hsic-1\"),\n\tPINCTRL_PIN(PIN_PCIE_0, \"pcie-0\"),\n\tPINCTRL_PIN(PIN_PCIE_1, \"pcie-1\"),\n\tPINCTRL_PIN(PIN_PCIE_2, \"pcie-2\"),\n\tPINCTRL_PIN(PIN_PCIE_3, \"pcie-3\"),\n\tPINCTRL_PIN(PIN_PCIE_4, \"pcie-4\"),\n\tPINCTRL_PIN(PIN_SATA_0, \"sata-0\"),\n};\n\nstatic const char * const tegra124_snps_groups[] = {\n\t\"otg-0\",\n\t\"otg-1\",\n\t\"otg-2\",\n\t\"ulpi-0\",\n\t\"hsic-0\",\n\t\"hsic-1\",\n};\n\nstatic const char * const tegra124_xusb_groups[] = {\n\t\"otg-0\",\n\t\"otg-1\",\n\t\"otg-2\",\n\t\"ulpi-0\",\n\t\"hsic-0\",\n\t\"hsic-1\",\n};\n\nstatic const char * const tegra124_uart_groups[] = {\n\t\"otg-0\",\n\t\"otg-1\",\n\t\"otg-2\",\n};\n\nstatic const char * const tegra124_pcie_groups[] = {\n\t\"pcie-0\",\n\t\"pcie-1\",\n\t\"pcie-2\",\n\t\"pcie-3\",\n\t\"pcie-4\",\n};\n\nstatic const char * const tegra124_usb3_groups[] = {\n\t\"pcie-0\",\n\t\"pcie-1\",\n\t\"sata-0\",\n};\n\nstatic const char * const tegra124_sata_groups[] = {\n\t\"sata-0\",\n};\n\nstatic const char * const tegra124_rsvd_groups[] = {\n\t\"otg-0\",\n\t\"otg-1\",\n\t\"otg-2\",\n\t\"pcie-0\",\n\t\"pcie-1\",\n\t\"pcie-2\",\n\t\"pcie-3\",\n\t\"pcie-4\",\n\t\"sata-0\",\n};\n\n#define TEGRA124_FUNCTION(_name)\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.name = #_name,\t\t\t\t\t\t\\\n\t\t.num_groups = ARRAY_SIZE(tegra124_##_name##_groups),\t\\\n\t\t.groups = tegra124_##_name##_groups,\t\t\t\\\n\t}\n\nstatic struct tegra_xusb_padctl_function tegra124_functions[] = {\n\tTEGRA124_FUNCTION(snps),\n\tTEGRA124_FUNCTION(xusb),\n\tTEGRA124_FUNCTION(uart),\n\tTEGRA124_FUNCTION(pcie),\n\tTEGRA124_FUNCTION(usb3),\n\tTEGRA124_FUNCTION(sata),\n\tTEGRA124_FUNCTION(rsvd),\n};\n\nenum tegra124_function {\n\tTEGRA124_FUNC_SNPS,\n\tTEGRA124_FUNC_XUSB,\n\tTEGRA124_FUNC_UART,\n\tTEGRA124_FUNC_PCIE,\n\tTEGRA124_FUNC_USB3,\n\tTEGRA124_FUNC_SATA,\n\tTEGRA124_FUNC_RSVD,\n};\n\nstatic const unsigned int tegra124_otg_functions[] = {\n\tTEGRA124_FUNC_SNPS,\n\tTEGRA124_FUNC_XUSB,\n\tTEGRA124_FUNC_UART,\n\tTEGRA124_FUNC_RSVD,\n};\n\nstatic const unsigned int tegra124_usb_functions[] = {\n\tTEGRA124_FUNC_SNPS,\n\tTEGRA124_FUNC_XUSB,\n};\n\nstatic const unsigned int tegra124_pci_functions[] = {\n\tTEGRA124_FUNC_PCIE,\n\tTEGRA124_FUNC_USB3,\n\tTEGRA124_FUNC_SATA,\n\tTEGRA124_FUNC_RSVD,\n};\n\n#define TEGRA124_LANE(_name, _offset, _shift, _mask, _iddq, _funcs)\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.name = _name,\t\t\t\t\t\t\\\n\t\t.offset = _offset,\t\t\t\t\t\\\n\t\t.shift = _shift,\t\t\t\t\t\\\n\t\t.mask = _mask,\t\t\t\t\t\t\\\n\t\t.iddq = _iddq,\t\t\t\t\t\t\\\n\t\t.num_funcs = ARRAY_SIZE(tegra124_##_funcs##_functions),\t\\\n\t\t.funcs = tegra124_##_funcs##_functions,\t\t\t\\\n\t}\n\nstatic const struct tegra_xusb_padctl_lane tegra124_lanes[] = {\n\tTEGRA124_LANE(\"otg-0\",  0x004,  0, 0x3, 0, otg),\n\tTEGRA124_LANE(\"otg-1\",  0x004,  2, 0x3, 0, otg),\n\tTEGRA124_LANE(\"otg-2\",  0x004,  4, 0x3, 0, otg),\n\tTEGRA124_LANE(\"ulpi-0\", 0x004, 12, 0x1, 0, usb),\n\tTEGRA124_LANE(\"hsic-0\", 0x004, 14, 0x1, 0, usb),\n\tTEGRA124_LANE(\"hsic-1\", 0x004, 15, 0x1, 0, usb),\n\tTEGRA124_LANE(\"pcie-0\", 0x134, 16, 0x3, 1, pci),\n\tTEGRA124_LANE(\"pcie-1\", 0x134, 18, 0x3, 2, pci),\n\tTEGRA124_LANE(\"pcie-2\", 0x134, 20, 0x3, 3, pci),\n\tTEGRA124_LANE(\"pcie-3\", 0x134, 22, 0x3, 4, pci),\n\tTEGRA124_LANE(\"pcie-4\", 0x134, 24, 0x3, 5, pci),\n\tTEGRA124_LANE(\"sata-0\", 0x134, 26, 0x3, 6, pci),\n};\n\nstatic const struct tegra_xusb_padctl_soc tegra124_soc = {\n\t.num_pins = ARRAY_SIZE(tegra124_pins),\n\t.pins = tegra124_pins,\n\t.num_functions = ARRAY_SIZE(tegra124_functions),\n\t.functions = tegra124_functions,\n\t.num_lanes = ARRAY_SIZE(tegra124_lanes),\n\t.lanes = tegra124_lanes,\n};\n\nstatic const struct of_device_id tegra_xusb_padctl_of_match[] = {\n\t{ .compatible = \"nvidia,tegra124-xusb-padctl\", .data = &tegra124_soc },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, tegra_xusb_padctl_of_match);\n\n \nint tegra_xusb_padctl_legacy_probe(struct platform_device *pdev);\nint tegra_xusb_padctl_legacy_remove(struct platform_device *pdev);\n\nint tegra_xusb_padctl_legacy_probe(struct platform_device *pdev)\n{\n\tstruct tegra_xusb_padctl *padctl;\n\tconst struct of_device_id *match;\n\tstruct phy *phy;\n\tint err;\n\n\tpadctl = devm_kzalloc(&pdev->dev, sizeof(*padctl), GFP_KERNEL);\n\tif (!padctl)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, padctl);\n\tmutex_init(&padctl->lock);\n\tpadctl->dev = &pdev->dev;\n\n\t \n\tmatch = of_match_node(tegra_xusb_padctl_of_match, pdev->dev.of_node);\n\tpadctl->soc = match->data;\n\n\tpadctl->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(padctl->regs))\n\t\treturn PTR_ERR(padctl->regs);\n\n\tpadctl->rst = devm_reset_control_get_exclusive(&pdev->dev, NULL);\n\tif (IS_ERR(padctl->rst))\n\t\treturn PTR_ERR(padctl->rst);\n\n\terr = reset_control_deassert(padctl->rst);\n\tif (err < 0)\n\t\treturn err;\n\n\tmemset(&padctl->desc, 0, sizeof(padctl->desc));\n\tpadctl->desc.name = dev_name(padctl->dev);\n\tpadctl->desc.pins = tegra124_pins;\n\tpadctl->desc.npins = ARRAY_SIZE(tegra124_pins);\n\tpadctl->desc.pctlops = &tegra_xusb_padctl_pinctrl_ops;\n\tpadctl->desc.pmxops = &tegra_xusb_padctl_pinmux_ops;\n\tpadctl->desc.confops = &tegra_xusb_padctl_pinconf_ops;\n\tpadctl->desc.owner = THIS_MODULE;\n\n\tpadctl->pinctrl = devm_pinctrl_register(&pdev->dev, &padctl->desc,\n\t\t\t\t\t\tpadctl);\n\tif (IS_ERR(padctl->pinctrl)) {\n\t\tdev_err(&pdev->dev, \"failed to register pincontrol\\n\");\n\t\terr = PTR_ERR(padctl->pinctrl);\n\t\tgoto reset;\n\t}\n\n\tphy = devm_phy_create(&pdev->dev, NULL, &pcie_phy_ops);\n\tif (IS_ERR(phy)) {\n\t\terr = PTR_ERR(phy);\n\t\tgoto reset;\n\t}\n\n\tpadctl->phys[TEGRA_XUSB_PADCTL_PCIE] = phy;\n\tphy_set_drvdata(phy, padctl);\n\n\tphy = devm_phy_create(&pdev->dev, NULL, &sata_phy_ops);\n\tif (IS_ERR(phy)) {\n\t\terr = PTR_ERR(phy);\n\t\tgoto reset;\n\t}\n\n\tpadctl->phys[TEGRA_XUSB_PADCTL_SATA] = phy;\n\tphy_set_drvdata(phy, padctl);\n\n\tpadctl->provider = devm_of_phy_provider_register(&pdev->dev,\n\t\t\t\t\t\t\t tegra_xusb_padctl_xlate);\n\tif (IS_ERR(padctl->provider)) {\n\t\terr = PTR_ERR(padctl->provider);\n\t\tdev_err(&pdev->dev, \"failed to register PHYs: %d\\n\", err);\n\t\tgoto reset;\n\t}\n\n\treturn 0;\n\nreset:\n\treset_control_assert(padctl->rst);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(tegra_xusb_padctl_legacy_probe);\n\nint tegra_xusb_padctl_legacy_remove(struct platform_device *pdev)\n{\n\tstruct tegra_xusb_padctl *padctl = platform_get_drvdata(pdev);\n\tint err;\n\n\terr = reset_control_assert(padctl->rst);\n\tif (err < 0)\n\t\tdev_err(&pdev->dev, \"failed to assert reset: %d\\n\", err);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(tegra_xusb_padctl_legacy_remove);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}