{
  "module_name": "pinctrl-tegra.c",
  "hash_id": "39cfd8c0e1a7850332ff2ddac8764f0c719897242117bd74c9bb4ef2e289c626",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/tegra/pinctrl-tegra.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n\n#include <linux/pinctrl/machine.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinmux.h>\n\n#include \"../core.h\"\n#include \"../pinctrl-utils.h\"\n#include \"pinctrl-tegra.h\"\n\nstatic inline u32 pmx_readl(struct tegra_pmx *pmx, u32 bank, u32 reg)\n{\n\treturn readl(pmx->regs[bank] + reg);\n}\n\nstatic inline void pmx_writel(struct tegra_pmx *pmx, u32 val, u32 bank, u32 reg)\n{\n\twritel_relaxed(val, pmx->regs[bank] + reg);\n\t \n\tpmx_readl(pmx, bank, reg);\n}\n\nstatic int tegra_pinctrl_get_groups_count(struct pinctrl_dev *pctldev)\n{\n\tstruct tegra_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pmx->soc->ngroups;\n}\n\nstatic const char *tegra_pinctrl_get_group_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t\tunsigned group)\n{\n\tstruct tegra_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pmx->soc->groups[group].name;\n}\n\nstatic int tegra_pinctrl_get_group_pins(struct pinctrl_dev *pctldev,\n\t\t\t\t\tunsigned group,\n\t\t\t\t\tconst unsigned **pins,\n\t\t\t\t\tunsigned *num_pins)\n{\n\tstruct tegra_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\n\n\t*pins = pmx->soc->groups[group].pins;\n\t*num_pins = pmx->soc->groups[group].npins;\n\n\treturn 0;\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic void tegra_pinctrl_pin_dbg_show(struct pinctrl_dev *pctldev,\n\t\t\t\t       struct seq_file *s,\n\t\t\t\t       unsigned offset)\n{\n\tseq_printf(s, \" %s\", dev_name(pctldev->dev));\n}\n#endif\n\nstatic const struct cfg_param {\n\tconst char *property;\n\tenum tegra_pinconf_param param;\n} cfg_params[] = {\n\t{\"nvidia,pull\",\t\t\tTEGRA_PINCONF_PARAM_PULL},\n\t{\"nvidia,tristate\",\t\tTEGRA_PINCONF_PARAM_TRISTATE},\n\t{\"nvidia,enable-input\",\t\tTEGRA_PINCONF_PARAM_ENABLE_INPUT},\n\t{\"nvidia,open-drain\",\t\tTEGRA_PINCONF_PARAM_OPEN_DRAIN},\n\t{\"nvidia,lock\",\t\t\tTEGRA_PINCONF_PARAM_LOCK},\n\t{\"nvidia,io-reset\",\t\tTEGRA_PINCONF_PARAM_IORESET},\n\t{\"nvidia,rcv-sel\",\t\tTEGRA_PINCONF_PARAM_RCV_SEL},\n\t{\"nvidia,io-hv\",\t\tTEGRA_PINCONF_PARAM_RCV_SEL},\n\t{\"nvidia,high-speed-mode\",\tTEGRA_PINCONF_PARAM_HIGH_SPEED_MODE},\n\t{\"nvidia,schmitt\",\t\tTEGRA_PINCONF_PARAM_SCHMITT},\n\t{\"nvidia,low-power-mode\",\tTEGRA_PINCONF_PARAM_LOW_POWER_MODE},\n\t{\"nvidia,pull-down-strength\",\tTEGRA_PINCONF_PARAM_DRIVE_DOWN_STRENGTH},\n\t{\"nvidia,pull-up-strength\",\tTEGRA_PINCONF_PARAM_DRIVE_UP_STRENGTH},\n\t{\"nvidia,slew-rate-falling\",\tTEGRA_PINCONF_PARAM_SLEW_RATE_FALLING},\n\t{\"nvidia,slew-rate-rising\",\tTEGRA_PINCONF_PARAM_SLEW_RATE_RISING},\n\t{\"nvidia,drive-type\",\t\tTEGRA_PINCONF_PARAM_DRIVE_TYPE},\n};\n\nstatic int tegra_pinctrl_dt_subnode_to_map(struct pinctrl_dev *pctldev,\n\t\t\t\t\t   struct device_node *np,\n\t\t\t\t\t   struct pinctrl_map **map,\n\t\t\t\t\t   unsigned *reserved_maps,\n\t\t\t\t\t   unsigned *num_maps)\n{\n\tstruct device *dev = pctldev->dev;\n\tint ret, i;\n\tconst char *function;\n\tu32 val;\n\tunsigned long config;\n\tunsigned long *configs = NULL;\n\tunsigned num_configs = 0;\n\tunsigned reserve;\n\tstruct property *prop;\n\tconst char *group;\n\n\tret = of_property_read_string(np, \"nvidia,function\", &function);\n\tif (ret < 0) {\n\t\t \n\t\tif (ret != -EINVAL)\n\t\t\tdev_err(dev,\n\t\t\t\t\"could not parse property nvidia,function\\n\");\n\t\tfunction = NULL;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(cfg_params); i++) {\n\t\tret = of_property_read_u32(np, cfg_params[i].property, &val);\n\t\tif (!ret) {\n\t\t\tconfig = TEGRA_PINCONF_PACK(cfg_params[i].param, val);\n\t\t\tret = pinctrl_utils_add_config(pctldev, &configs,\n\t\t\t\t\t&num_configs, config);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto exit;\n\t\t \n\t\t} else if (ret != -EINVAL) {\n\t\t\tdev_err(dev, \"could not parse property %s\\n\",\n\t\t\t\tcfg_params[i].property);\n\t\t}\n\t}\n\n\treserve = 0;\n\tif (function != NULL)\n\t\treserve++;\n\tif (num_configs)\n\t\treserve++;\n\tret = of_property_count_strings(np, \"nvidia,pins\");\n\tif (ret < 0) {\n\t\tdev_err(dev, \"could not parse property nvidia,pins\\n\");\n\t\tgoto exit;\n\t}\n\treserve *= ret;\n\n\tret = pinctrl_utils_reserve_map(pctldev, map, reserved_maps,\n\t\t\t\t\tnum_maps, reserve);\n\tif (ret < 0)\n\t\tgoto exit;\n\n\tof_property_for_each_string(np, \"nvidia,pins\", prop, group) {\n\t\tif (function) {\n\t\t\tret = pinctrl_utils_add_map_mux(pctldev, map,\n\t\t\t\t\treserved_maps, num_maps, group,\n\t\t\t\t\tfunction);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto exit;\n\t\t}\n\n\t\tif (num_configs) {\n\t\t\tret = pinctrl_utils_add_map_configs(pctldev, map,\n\t\t\t\t\treserved_maps, num_maps, group,\n\t\t\t\t\tconfigs, num_configs,\n\t\t\t\t\tPIN_MAP_TYPE_CONFIGS_GROUP);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tret = 0;\n\nexit:\n\tkfree(configs);\n\treturn ret;\n}\n\nstatic int tegra_pinctrl_dt_node_to_map(struct pinctrl_dev *pctldev,\n\t\t\t\t\tstruct device_node *np_config,\n\t\t\t\t\tstruct pinctrl_map **map,\n\t\t\t\t\tunsigned *num_maps)\n{\n\tunsigned reserved_maps;\n\tstruct device_node *np;\n\tint ret;\n\n\treserved_maps = 0;\n\t*map = NULL;\n\t*num_maps = 0;\n\n\tfor_each_child_of_node(np_config, np) {\n\t\tret = tegra_pinctrl_dt_subnode_to_map(pctldev, np, map,\n\t\t\t\t\t\t      &reserved_maps, num_maps);\n\t\tif (ret < 0) {\n\t\t\tpinctrl_utils_free_map(pctldev, *map,\n\t\t\t\t*num_maps);\n\t\t\tof_node_put(np);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct pinctrl_ops tegra_pinctrl_ops = {\n\t.get_groups_count = tegra_pinctrl_get_groups_count,\n\t.get_group_name = tegra_pinctrl_get_group_name,\n\t.get_group_pins = tegra_pinctrl_get_group_pins,\n#ifdef CONFIG_DEBUG_FS\n\t.pin_dbg_show = tegra_pinctrl_pin_dbg_show,\n#endif\n\t.dt_node_to_map = tegra_pinctrl_dt_node_to_map,\n\t.dt_free_map = pinctrl_utils_free_map,\n};\n\nstatic int tegra_pinctrl_get_funcs_count(struct pinctrl_dev *pctldev)\n{\n\tstruct tegra_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pmx->soc->nfunctions;\n}\n\nstatic const char *tegra_pinctrl_get_func_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t       unsigned function)\n{\n\tstruct tegra_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pmx->functions[function].name;\n}\n\nstatic int tegra_pinctrl_get_func_groups(struct pinctrl_dev *pctldev,\n\t\t\t\t\t unsigned function,\n\t\t\t\t\t const char * const **groups,\n\t\t\t\t\t unsigned * const num_groups)\n{\n\tstruct tegra_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\n\n\t*groups = pmx->functions[function].groups;\n\t*num_groups = pmx->functions[function].ngroups;\n\n\treturn 0;\n}\n\nstatic int tegra_pinctrl_set_mux(struct pinctrl_dev *pctldev,\n\t\t\t\t unsigned function,\n\t\t\t\t unsigned group)\n{\n\tstruct tegra_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct tegra_pingroup *g;\n\tint i;\n\tu32 val;\n\n\tg = &pmx->soc->groups[group];\n\n\tif (WARN_ON(g->mux_reg < 0))\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < ARRAY_SIZE(g->funcs); i++) {\n\t\tif (g->funcs[i] == function)\n\t\t\tbreak;\n\t}\n\tif (WARN_ON(i == ARRAY_SIZE(g->funcs)))\n\t\treturn -EINVAL;\n\n\tval = pmx_readl(pmx, g->mux_bank, g->mux_reg);\n\tval &= ~(0x3 << g->mux_bit);\n\tval |= i << g->mux_bit;\n\tpmx_writel(pmx, val, g->mux_bank, g->mux_reg);\n\n\treturn 0;\n}\n\nstatic const struct tegra_pingroup *tegra_pinctrl_get_group(struct pinctrl_dev *pctldev,\n\t\t\t\t\tunsigned int offset)\n{\n\tstruct tegra_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\n\tunsigned int group, num_pins, j;\n\tconst unsigned int *pins;\n\tint ret;\n\n\tfor (group = 0; group < pmx->soc->ngroups; ++group) {\n\t\tret = tegra_pinctrl_get_group_pins(pctldev, group, &pins, &num_pins);\n\t\tif (ret < 0)\n\t\t\tcontinue;\n\t\tfor (j = 0; j < num_pins; j++) {\n\t\t\tif (offset == pins[j])\n\t\t\t\treturn &pmx->soc->groups[group];\n\t\t}\n\t}\n\n\tdev_err(pctldev->dev, \"Pingroup not found for pin %u\\n\", offset);\n\treturn NULL;\n}\n\nstatic int tegra_pinctrl_gpio_request_enable(struct pinctrl_dev *pctldev,\n\t\t\t\t\t     struct pinctrl_gpio_range *range,\n\t\t\t\t\t     unsigned int offset)\n{\n\tstruct tegra_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct tegra_pingroup *group;\n\tu32 value;\n\n\tif (!pmx->soc->sfsel_in_mux)\n\t\treturn 0;\n\n\tgroup = tegra_pinctrl_get_group(pctldev, offset);\n\n\tif (!group)\n\t\treturn -EINVAL;\n\n\tif (group->mux_reg < 0 || group->sfsel_bit < 0)\n\t\treturn -EINVAL;\n\n\tvalue = pmx_readl(pmx, group->mux_bank, group->mux_reg);\n\tvalue &= ~BIT(group->sfsel_bit);\n\tpmx_writel(pmx, value, group->mux_bank, group->mux_reg);\n\n\treturn 0;\n}\n\nstatic void tegra_pinctrl_gpio_disable_free(struct pinctrl_dev *pctldev,\n\t\t\t\t\t    struct pinctrl_gpio_range *range,\n\t\t\t\t\t    unsigned int offset)\n{\n\tstruct tegra_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct tegra_pingroup *group;\n\tu32 value;\n\n\tif (!pmx->soc->sfsel_in_mux)\n\t\treturn;\n\n\tgroup = tegra_pinctrl_get_group(pctldev, offset);\n\n\tif (!group)\n\t\treturn;\n\n\tif (group->mux_reg < 0 || group->sfsel_bit < 0)\n\t\treturn;\n\n\tvalue = pmx_readl(pmx, group->mux_bank, group->mux_reg);\n\tvalue |= BIT(group->sfsel_bit);\n\tpmx_writel(pmx, value, group->mux_bank, group->mux_reg);\n}\n\nstatic const struct pinmux_ops tegra_pinmux_ops = {\n\t.get_functions_count = tegra_pinctrl_get_funcs_count,\n\t.get_function_name = tegra_pinctrl_get_func_name,\n\t.get_function_groups = tegra_pinctrl_get_func_groups,\n\t.set_mux = tegra_pinctrl_set_mux,\n\t.gpio_request_enable = tegra_pinctrl_gpio_request_enable,\n\t.gpio_disable_free = tegra_pinctrl_gpio_disable_free,\n};\n\nstatic int tegra_pinconf_reg(struct tegra_pmx *pmx,\n\t\t\t     const struct tegra_pingroup *g,\n\t\t\t     enum tegra_pinconf_param param,\n\t\t\t     bool report_err,\n\t\t\t     s8 *bank, s32 *reg, s8 *bit, s8 *width)\n{\n\tswitch (param) {\n\tcase TEGRA_PINCONF_PARAM_PULL:\n\t\t*bank = g->pupd_bank;\n\t\t*reg = g->pupd_reg;\n\t\t*bit = g->pupd_bit;\n\t\t*width = 2;\n\t\tbreak;\n\tcase TEGRA_PINCONF_PARAM_TRISTATE:\n\t\t*bank = g->tri_bank;\n\t\t*reg = g->tri_reg;\n\t\t*bit = g->tri_bit;\n\t\t*width = 1;\n\t\tbreak;\n\tcase TEGRA_PINCONF_PARAM_ENABLE_INPUT:\n\t\t*bank = g->mux_bank;\n\t\t*reg = g->mux_reg;\n\t\t*bit = g->einput_bit;\n\t\t*width = 1;\n\t\tbreak;\n\tcase TEGRA_PINCONF_PARAM_OPEN_DRAIN:\n\t\t*bank = g->mux_bank;\n\t\t*reg = g->mux_reg;\n\t\t*bit = g->odrain_bit;\n\t\t*width = 1;\n\t\tbreak;\n\tcase TEGRA_PINCONF_PARAM_LOCK:\n\t\t*bank = g->mux_bank;\n\t\t*reg = g->mux_reg;\n\t\t*bit = g->lock_bit;\n\t\t*width = 1;\n\t\tbreak;\n\tcase TEGRA_PINCONF_PARAM_IORESET:\n\t\t*bank = g->mux_bank;\n\t\t*reg = g->mux_reg;\n\t\t*bit = g->ioreset_bit;\n\t\t*width = 1;\n\t\tbreak;\n\tcase TEGRA_PINCONF_PARAM_RCV_SEL:\n\t\t*bank = g->mux_bank;\n\t\t*reg = g->mux_reg;\n\t\t*bit = g->rcv_sel_bit;\n\t\t*width = 1;\n\t\tbreak;\n\tcase TEGRA_PINCONF_PARAM_HIGH_SPEED_MODE:\n\t\tif (pmx->soc->hsm_in_mux) {\n\t\t\t*bank = g->mux_bank;\n\t\t\t*reg = g->mux_reg;\n\t\t} else {\n\t\t\t*bank = g->drv_bank;\n\t\t\t*reg = g->drv_reg;\n\t\t}\n\t\t*bit = g->hsm_bit;\n\t\t*width = 1;\n\t\tbreak;\n\tcase TEGRA_PINCONF_PARAM_SCHMITT:\n\t\tif (pmx->soc->schmitt_in_mux) {\n\t\t\t*bank = g->mux_bank;\n\t\t\t*reg = g->mux_reg;\n\t\t} else {\n\t\t\t*bank = g->drv_bank;\n\t\t\t*reg = g->drv_reg;\n\t\t}\n\t\t*bit = g->schmitt_bit;\n\t\t*width = 1;\n\t\tbreak;\n\tcase TEGRA_PINCONF_PARAM_LOW_POWER_MODE:\n\t\t*bank = g->drv_bank;\n\t\t*reg = g->drv_reg;\n\t\t*bit = g->lpmd_bit;\n\t\t*width = 2;\n\t\tbreak;\n\tcase TEGRA_PINCONF_PARAM_DRIVE_DOWN_STRENGTH:\n\t\t*bank = g->drv_bank;\n\t\t*reg = g->drv_reg;\n\t\t*bit = g->drvdn_bit;\n\t\t*width = g->drvdn_width;\n\t\tbreak;\n\tcase TEGRA_PINCONF_PARAM_DRIVE_UP_STRENGTH:\n\t\t*bank = g->drv_bank;\n\t\t*reg = g->drv_reg;\n\t\t*bit = g->drvup_bit;\n\t\t*width = g->drvup_width;\n\t\tbreak;\n\tcase TEGRA_PINCONF_PARAM_SLEW_RATE_FALLING:\n\t\t*bank = g->drv_bank;\n\t\t*reg = g->drv_reg;\n\t\t*bit = g->slwf_bit;\n\t\t*width = g->slwf_width;\n\t\tbreak;\n\tcase TEGRA_PINCONF_PARAM_SLEW_RATE_RISING:\n\t\t*bank = g->drv_bank;\n\t\t*reg = g->drv_reg;\n\t\t*bit = g->slwr_bit;\n\t\t*width = g->slwr_width;\n\t\tbreak;\n\tcase TEGRA_PINCONF_PARAM_DRIVE_TYPE:\n\t\tif (pmx->soc->drvtype_in_mux) {\n\t\t\t*bank = g->mux_bank;\n\t\t\t*reg = g->mux_reg;\n\t\t} else {\n\t\t\t*bank = g->drv_bank;\n\t\t\t*reg = g->drv_reg;\n\t\t}\n\t\t*bit = g->drvtype_bit;\n\t\t*width = 2;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(pmx->dev, \"Invalid config param %04x\\n\", param);\n\t\treturn -ENOTSUPP;\n\t}\n\n\tif (*reg < 0 || *bit < 0)  {\n\t\tif (report_err) {\n\t\t\tconst char *prop = \"unknown\";\n\t\t\tint i;\n\n\t\t\tfor (i = 0; i < ARRAY_SIZE(cfg_params); i++) {\n\t\t\t\tif (cfg_params[i].param == param) {\n\t\t\t\t\tprop = cfg_params[i].property;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdev_err(pmx->dev,\n\t\t\t\t\"Config param %04x (%s) not supported on group %s\\n\",\n\t\t\t\tparam, prop, g->name);\n\t\t}\n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra_pinconf_get(struct pinctrl_dev *pctldev,\n\t\t\t     unsigned pin, unsigned long *config)\n{\n\tdev_err(pctldev->dev, \"pin_config_get op not supported\\n\");\n\treturn -ENOTSUPP;\n}\n\nstatic int tegra_pinconf_set(struct pinctrl_dev *pctldev,\n\t\t\t     unsigned pin, unsigned long *configs,\n\t\t\t     unsigned num_configs)\n{\n\tdev_err(pctldev->dev, \"pin_config_set op not supported\\n\");\n\treturn -ENOTSUPP;\n}\n\nstatic int tegra_pinconf_group_get(struct pinctrl_dev *pctldev,\n\t\t\t\t   unsigned group, unsigned long *config)\n{\n\tstruct tegra_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\n\tenum tegra_pinconf_param param = TEGRA_PINCONF_UNPACK_PARAM(*config);\n\tu16 arg;\n\tconst struct tegra_pingroup *g;\n\tint ret;\n\ts8 bank, bit, width;\n\ts32 reg;\n\tu32 val, mask;\n\n\tg = &pmx->soc->groups[group];\n\n\tret = tegra_pinconf_reg(pmx, g, param, true, &bank, &reg, &bit,\n\t\t\t\t&width);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tval = pmx_readl(pmx, bank, reg);\n\tmask = (1 << width) - 1;\n\targ = (val >> bit) & mask;\n\n\t*config = TEGRA_PINCONF_PACK(param, arg);\n\n\treturn 0;\n}\n\nstatic int tegra_pinconf_group_set(struct pinctrl_dev *pctldev,\n\t\t\t\t   unsigned group, unsigned long *configs,\n\t\t\t\t   unsigned num_configs)\n{\n\tstruct tegra_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\n\tenum tegra_pinconf_param param;\n\tu16 arg;\n\tconst struct tegra_pingroup *g;\n\tint ret, i;\n\ts8 bank, bit, width;\n\ts32 reg;\n\tu32 val, mask;\n\n\tg = &pmx->soc->groups[group];\n\n\tfor (i = 0; i < num_configs; i++) {\n\t\tparam = TEGRA_PINCONF_UNPACK_PARAM(configs[i]);\n\t\targ = TEGRA_PINCONF_UNPACK_ARG(configs[i]);\n\n\t\tret = tegra_pinconf_reg(pmx, g, param, true, &bank, &reg, &bit,\n\t\t\t\t\t&width);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tval = pmx_readl(pmx, bank, reg);\n\n\t\t \n\t\tif (param == TEGRA_PINCONF_PARAM_LOCK) {\n\t\t\tif ((val & BIT(bit)) && !arg) {\n\t\t\t\tdev_err(pctldev->dev, \"LOCK bit cannot be cleared\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (width == 1)\n\t\t\targ = !!arg;\n\n\t\t \n\t\tmask = (1 << width) - 1;\n\t\tif (arg & ~mask) {\n\t\t\tdev_err(pctldev->dev,\n\t\t\t\t\"config %lx: %x too big for %d bit register\\n\",\n\t\t\t\tconfigs[i], arg, width);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tval &= ~(mask << bit);\n\t\tval |= arg << bit;\n\t\tpmx_writel(pmx, val, bank, reg);\n\t}  \n\n\treturn 0;\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic void tegra_pinconf_dbg_show(struct pinctrl_dev *pctldev,\n\t\t\t\t   struct seq_file *s, unsigned offset)\n{\n}\n\nstatic const char *strip_prefix(const char *s)\n{\n\tconst char *comma = strchr(s, ',');\n\tif (!comma)\n\t\treturn s;\n\n\treturn comma + 1;\n}\n\nstatic void tegra_pinconf_group_dbg_show(struct pinctrl_dev *pctldev,\n\t\t\t\t\t struct seq_file *s, unsigned group)\n{\n\tstruct tegra_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct tegra_pingroup *g;\n\tint i, ret;\n\ts8 bank, bit, width;\n\ts32 reg;\n\tu32 val;\n\n\tg = &pmx->soc->groups[group];\n\n\tfor (i = 0; i < ARRAY_SIZE(cfg_params); i++) {\n\t\tret = tegra_pinconf_reg(pmx, g, cfg_params[i].param, false,\n\t\t\t\t\t&bank, &reg, &bit, &width);\n\t\tif (ret < 0)\n\t\t\tcontinue;\n\n\t\tval = pmx_readl(pmx, bank, reg);\n\t\tval >>= bit;\n\t\tval &= (1 << width) - 1;\n\n\t\tseq_printf(s, \"\\n\\t%s=%u\",\n\t\t\t   strip_prefix(cfg_params[i].property), val);\n\t}\n}\n\nstatic void tegra_pinconf_config_dbg_show(struct pinctrl_dev *pctldev,\n\t\t\t\t\t  struct seq_file *s,\n\t\t\t\t\t  unsigned long config)\n{\n\tenum tegra_pinconf_param param = TEGRA_PINCONF_UNPACK_PARAM(config);\n\tu16 arg = TEGRA_PINCONF_UNPACK_ARG(config);\n\tconst char *pname = \"unknown\";\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(cfg_params); i++) {\n\t\tif (cfg_params[i].param == param) {\n\t\t\tpname = cfg_params[i].property;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tseq_printf(s, \"%s=%d\", strip_prefix(pname), arg);\n}\n#endif\n\nstatic const struct pinconf_ops tegra_pinconf_ops = {\n\t.pin_config_get = tegra_pinconf_get,\n\t.pin_config_set = tegra_pinconf_set,\n\t.pin_config_group_get = tegra_pinconf_group_get,\n\t.pin_config_group_set = tegra_pinconf_group_set,\n#ifdef CONFIG_DEBUG_FS\n\t.pin_config_dbg_show = tegra_pinconf_dbg_show,\n\t.pin_config_group_dbg_show = tegra_pinconf_group_dbg_show,\n\t.pin_config_config_dbg_show = tegra_pinconf_config_dbg_show,\n#endif\n};\n\nstatic void tegra_pinctrl_clear_parked_bits(struct tegra_pmx *pmx)\n{\n\tint i = 0;\n\tconst struct tegra_pingroup *g;\n\tu32 val;\n\n\tfor (i = 0; i < pmx->soc->ngroups; ++i) {\n\t\tg = &pmx->soc->groups[i];\n\t\tif (g->parked_bitmask > 0) {\n\t\t\tunsigned int bank, reg;\n\n\t\t\tif (g->mux_reg != -1) {\n\t\t\t\tbank = g->mux_bank;\n\t\t\t\treg = g->mux_reg;\n\t\t\t} else {\n\t\t\t\tbank = g->drv_bank;\n\t\t\t\treg = g->drv_reg;\n\t\t\t}\n\n\t\t\tval = pmx_readl(pmx, bank, reg);\n\t\t\tval &= ~g->parked_bitmask;\n\t\t\tpmx_writel(pmx, val, bank, reg);\n\t\t}\n\t}\n}\n\nstatic size_t tegra_pinctrl_get_bank_size(struct device *dev,\n\t\t\t\t\t  unsigned int bank_id)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct resource *res;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, bank_id);\n\n\treturn resource_size(res) / 4;\n}\n\nstatic int tegra_pinctrl_suspend(struct device *dev)\n{\n\tstruct tegra_pmx *pmx = dev_get_drvdata(dev);\n\tu32 *backup_regs = pmx->backup_regs;\n\tu32 __iomem *regs;\n\tsize_t bank_size;\n\tunsigned int i, k;\n\n\tfor (i = 0; i < pmx->nbanks; i++) {\n\t\tbank_size = tegra_pinctrl_get_bank_size(dev, i);\n\t\tregs = pmx->regs[i];\n\t\tfor (k = 0; k < bank_size; k++)\n\t\t\t*backup_regs++ = readl_relaxed(regs++);\n\t}\n\n\treturn pinctrl_force_sleep(pmx->pctl);\n}\n\nstatic int tegra_pinctrl_resume(struct device *dev)\n{\n\tstruct tegra_pmx *pmx = dev_get_drvdata(dev);\n\tu32 *backup_regs = pmx->backup_regs;\n\tu32 __iomem *regs;\n\tsize_t bank_size;\n\tunsigned int i, k;\n\n\tfor (i = 0; i < pmx->nbanks; i++) {\n\t\tbank_size = tegra_pinctrl_get_bank_size(dev, i);\n\t\tregs = pmx->regs[i];\n\t\tfor (k = 0; k < bank_size; k++)\n\t\t\twritel_relaxed(*backup_regs++, regs++);\n\t}\n\n\t \n\treadl_relaxed(pmx->regs[0]);\n\t \n\trmb();\n\treturn 0;\n}\n\nDEFINE_NOIRQ_DEV_PM_OPS(tegra_pinctrl_pm, tegra_pinctrl_suspend, tegra_pinctrl_resume);\n\nstatic bool tegra_pinctrl_gpio_node_has_range(struct tegra_pmx *pmx)\n{\n\tstruct device_node *np;\n\tbool has_prop = false;\n\n\tnp = of_find_compatible_node(NULL, NULL, pmx->soc->gpio_compatible);\n\tif (!np)\n\t\treturn has_prop;\n\n\thas_prop = of_find_property(np, \"gpio-ranges\", NULL);\n\n\tof_node_put(np);\n\n\treturn has_prop;\n}\n\nint tegra_pinctrl_probe(struct platform_device *pdev,\n\t\t\tconst struct tegra_pinctrl_soc_data *soc_data)\n{\n\tstruct tegra_pmx *pmx;\n\tstruct resource *res;\n\tint i;\n\tconst char **group_pins;\n\tint fn, gn, gfn;\n\tunsigned long backup_regs_size = 0;\n\n\tpmx = devm_kzalloc(&pdev->dev, sizeof(*pmx), GFP_KERNEL);\n\tif (!pmx)\n\t\treturn -ENOMEM;\n\n\tpmx->dev = &pdev->dev;\n\tpmx->soc = soc_data;\n\n\t \n\tpmx->group_pins = devm_kcalloc(&pdev->dev, pmx->soc->ngroups * 4,\n\t\t\t\t       sizeof(*pmx->group_pins), GFP_KERNEL);\n\tif (!pmx->group_pins)\n\t\treturn -ENOMEM;\n\n\tpmx->functions = devm_kcalloc(&pdev->dev, pmx->soc->nfunctions,\n\t\t\t\t      sizeof(*pmx->functions), GFP_KERNEL);\n\tif (!pmx->functions)\n\t\treturn -ENOMEM;\n\n\tgroup_pins = pmx->group_pins;\n\n\tfor (fn = 0; fn < pmx->soc->nfunctions; fn++) {\n\t\tstruct tegra_function *func = &pmx->functions[fn];\n\n\t\tfunc->name = pmx->soc->functions[fn];\n\t\tfunc->groups = group_pins;\n\n\t\tfor (gn = 0; gn < pmx->soc->ngroups; gn++) {\n\t\t\tconst struct tegra_pingroup *g = &pmx->soc->groups[gn];\n\n\t\t\tif (g->mux_reg == -1)\n\t\t\t\tcontinue;\n\n\t\t\tfor (gfn = 0; gfn < 4; gfn++)\n\t\t\t\tif (g->funcs[gfn] == fn)\n\t\t\t\t\tbreak;\n\t\t\tif (gfn == 4)\n\t\t\t\tcontinue;\n\n\t\t\tBUG_ON(group_pins - pmx->group_pins >=\n\t\t\t\tpmx->soc->ngroups * 4);\n\t\t\t*group_pins++ = g->name;\n\t\t\tfunc->ngroups++;\n\t\t}\n\t}\n\n\tpmx->gpio_range.name = \"Tegra GPIOs\";\n\tpmx->gpio_range.id = 0;\n\tpmx->gpio_range.base = 0;\n\tpmx->gpio_range.npins = pmx->soc->ngpios;\n\n\tpmx->desc.pctlops = &tegra_pinctrl_ops;\n\tpmx->desc.pmxops = &tegra_pinmux_ops;\n\tpmx->desc.confops = &tegra_pinconf_ops;\n\tpmx->desc.owner = THIS_MODULE;\n\tpmx->desc.name = dev_name(&pdev->dev);\n\tpmx->desc.pins = pmx->soc->pins;\n\tpmx->desc.npins = pmx->soc->npins;\n\n\tfor (i = 0; ; i++) {\n\t\tres = platform_get_resource(pdev, IORESOURCE_MEM, i);\n\t\tif (!res)\n\t\t\tbreak;\n\t\tbackup_regs_size += resource_size(res);\n\t}\n\tpmx->nbanks = i;\n\n\tpmx->regs = devm_kcalloc(&pdev->dev, pmx->nbanks, sizeof(*pmx->regs),\n\t\t\t\t GFP_KERNEL);\n\tif (!pmx->regs)\n\t\treturn -ENOMEM;\n\n\tpmx->backup_regs = devm_kzalloc(&pdev->dev, backup_regs_size,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!pmx->backup_regs)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < pmx->nbanks; i++) {\n\t\tpmx->regs[i] = devm_platform_ioremap_resource(pdev, i);\n\t\tif (IS_ERR(pmx->regs[i]))\n\t\t\treturn PTR_ERR(pmx->regs[i]);\n\t}\n\n\tpmx->pctl = devm_pinctrl_register(&pdev->dev, &pmx->desc, pmx);\n\tif (IS_ERR(pmx->pctl)) {\n\t\tdev_err(&pdev->dev, \"Couldn't register pinctrl driver\\n\");\n\t\treturn PTR_ERR(pmx->pctl);\n\t}\n\n\ttegra_pinctrl_clear_parked_bits(pmx);\n\n\tif (pmx->soc->ngpios > 0 && !tegra_pinctrl_gpio_node_has_range(pmx))\n\t\tpinctrl_add_gpio_range(pmx->pctl, &pmx->gpio_range);\n\n\tplatform_set_drvdata(pdev, pmx);\n\n\tdev_dbg(&pdev->dev, \"Probed Tegra pinctrl driver\\n\");\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}