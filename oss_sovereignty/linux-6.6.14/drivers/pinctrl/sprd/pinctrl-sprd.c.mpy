{
  "module_name": "pinctrl-sprd.c",
  "hash_id": "34c963120dbfd93607832a490b0e17c2c8aa31355c87f58c446260f0273f2b7a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/sprd/pinctrl-sprd.c",
  "human_readable_source": "\n \n\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n\n#include <linux/pinctrl/consumer.h>\n#include <linux/pinctrl/machine.h>\n#include <linux/pinctrl/pinconf-generic.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinmux.h>\n\n#include \"../core.h\"\n#include \"../pinmux.h\"\n#include \"../pinconf.h\"\n#include \"../pinctrl-utils.h\"\n#include \"pinctrl-sprd.h\"\n\n#define PINCTRL_BIT_MASK(width)\t\t(~(~0UL << (width)))\n#define PINCTRL_REG_OFFSET\t\t0x20\n#define PINCTRL_REG_MISC_OFFSET\t\t0x4020\n#define PINCTRL_REG_LEN\t\t\t0x4\n\n#define PIN_FUNC_MASK\t\t\t(BIT(4) | BIT(5))\n#define PIN_FUNC_SEL_1\t\t\t~PIN_FUNC_MASK\n#define PIN_FUNC_SEL_2\t\t\tBIT(4)\n#define PIN_FUNC_SEL_3\t\t\tBIT(5)\n#define PIN_FUNC_SEL_4\t\t\tPIN_FUNC_MASK\n\n#define AP_SLEEP_MODE\t\t\tBIT(13)\n#define PUBCP_SLEEP_MODE\t\tBIT(14)\n#define TGLDSP_SLEEP_MODE\t\tBIT(15)\n#define AGDSP_SLEEP_MODE\t\tBIT(16)\n#define CM4_SLEEP_MODE\t\t\tBIT(17)\n#define SLEEP_MODE_MASK\t\t\tGENMASK(5, 0)\n#define SLEEP_MODE_SHIFT\t\t13\n\n#define SLEEP_INPUT\t\t\tBIT(1)\n#define SLEEP_INPUT_MASK\t\t0x1\n#define SLEEP_INPUT_SHIFT\t\t1\n\n#define SLEEP_OUTPUT\t\t\tBIT(0)\n#define SLEEP_OUTPUT_MASK\t\t0x1\n#define SLEEP_OUTPUT_SHIFT\t\t0\n\n#define DRIVE_STRENGTH_MASK\t\tGENMASK(3, 0)\n#define DRIVE_STRENGTH_SHIFT\t\t19\n\n#define SLEEP_PULL_DOWN\t\t\tBIT(2)\n#define SLEEP_PULL_DOWN_MASK\t\t0x1\n#define SLEEP_PULL_DOWN_SHIFT\t\t2\n\n#define PULL_DOWN\t\t\tBIT(6)\n#define PULL_DOWN_MASK\t\t\t0x1\n#define PULL_DOWN_SHIFT\t\t\t6\n\n#define SLEEP_PULL_UP\t\t\tBIT(3)\n#define SLEEP_PULL_UP_MASK\t\t0x1\n#define SLEEP_PULL_UP_SHIFT\t\t3\n\n#define PULL_UP_4_7K\t\t\t(BIT(12) | BIT(7))\n#define PULL_UP_20K\t\t\tBIT(7)\n#define PULL_UP_MASK\t\t\t0x21\n#define PULL_UP_SHIFT\t\t\t7\n\n#define INPUT_SCHMITT\t\t\tBIT(11)\n#define INPUT_SCHMITT_MASK\t\t0x1\n#define INPUT_SCHMITT_SHIFT\t\t11\n\nenum pin_sleep_mode {\n\tAP_SLEEP = BIT(0),\n\tPUBCP_SLEEP = BIT(1),\n\tTGLDSP_SLEEP = BIT(2),\n\tAGDSP_SLEEP = BIT(3),\n\tCM4_SLEEP = BIT(4),\n};\n\nenum pin_func_sel {\n\tPIN_FUNC_1,\n\tPIN_FUNC_2,\n\tPIN_FUNC_3,\n\tPIN_FUNC_4,\n\tPIN_FUNC_MAX,\n};\n\n \nstruct sprd_pin {\n\tconst char *name;\n\tunsigned int number;\n\tenum pin_type type;\n\tunsigned long reg;\n\tunsigned long bit_offset;\n\tunsigned long bit_width;\n};\n\n \nstruct sprd_pin_group {\n\tconst char *name;\n\tunsigned int npins;\n\tunsigned int *pins;\n};\n\n \nstruct sprd_pinctrl_soc_info {\n\tstruct sprd_pin_group *groups;\n\tunsigned int ngroups;\n\tstruct sprd_pin *pins;\n\tunsigned int npins;\n\tconst char **grp_names;\n};\n\n \nstruct sprd_pinctrl {\n\tstruct device *dev;\n\tstruct pinctrl_dev *pctl;\n\tvoid __iomem *base;\n\tstruct sprd_pinctrl_soc_info *info;\n};\n\n#define SPRD_PIN_CONFIG_CONTROL\t\t(PIN_CONFIG_END + 1)\n#define SPRD_PIN_CONFIG_SLEEP_MODE\t(PIN_CONFIG_END + 2)\n\nstatic int sprd_pinctrl_get_id_by_name(struct sprd_pinctrl *sprd_pctl,\n\t\t\t\t       const char *name)\n{\n\tstruct sprd_pinctrl_soc_info *info = sprd_pctl->info;\n\tint i;\n\n\tfor (i = 0; i < info->npins; i++) {\n\t\tif (!strcmp(info->pins[i].name, name))\n\t\t\treturn info->pins[i].number;\n\t}\n\n\treturn -ENODEV;\n}\n\nstatic struct sprd_pin *\nsprd_pinctrl_get_pin_by_id(struct sprd_pinctrl *sprd_pctl, unsigned int id)\n{\n\tstruct sprd_pinctrl_soc_info *info = sprd_pctl->info;\n\tstruct sprd_pin *pin = NULL;\n\tint i;\n\n\tfor (i = 0; i < info->npins; i++) {\n\t\tif (info->pins[i].number == id) {\n\t\t\tpin = &info->pins[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn pin;\n}\n\nstatic const struct sprd_pin_group *\nsprd_pinctrl_find_group_by_name(struct sprd_pinctrl *sprd_pctl,\n\t\t\t\tconst char *name)\n{\n\tstruct sprd_pinctrl_soc_info *info = sprd_pctl->info;\n\tconst struct sprd_pin_group *grp = NULL;\n\tint i;\n\n\tfor (i = 0; i < info->ngroups; i++) {\n\t\tif (!strcmp(info->groups[i].name, name)) {\n\t\t\tgrp = &info->groups[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn grp;\n}\n\nstatic int sprd_pctrl_group_count(struct pinctrl_dev *pctldev)\n{\n\tstruct sprd_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct sprd_pinctrl_soc_info *info = pctl->info;\n\n\treturn info->ngroups;\n}\n\nstatic const char *sprd_pctrl_group_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t unsigned int selector)\n{\n\tstruct sprd_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct sprd_pinctrl_soc_info *info = pctl->info;\n\n\treturn info->groups[selector].name;\n}\n\nstatic int sprd_pctrl_group_pins(struct pinctrl_dev *pctldev,\n\t\t\t\t unsigned int selector,\n\t\t\t\t const unsigned int **pins,\n\t\t\t\t unsigned int *npins)\n{\n\tstruct sprd_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct sprd_pinctrl_soc_info *info = pctl->info;\n\n\tif (selector >= info->ngroups)\n\t\treturn -EINVAL;\n\n\t*pins = info->groups[selector].pins;\n\t*npins = info->groups[selector].npins;\n\n\treturn 0;\n}\n\nstatic int sprd_dt_node_to_map(struct pinctrl_dev *pctldev,\n\t\t\t       struct device_node *np,\n\t\t\t       struct pinctrl_map **map,\n\t\t\t       unsigned int *num_maps)\n{\n\tstruct sprd_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct sprd_pin_group *grp;\n\tunsigned long *configs = NULL;\n\tunsigned int num_configs = 0;\n\tunsigned int reserved_maps = 0;\n\tunsigned int reserve = 0;\n\tconst char *function;\n\tenum pinctrl_map_type type;\n\tint ret;\n\n\tgrp = sprd_pinctrl_find_group_by_name(pctl, np->name);\n\tif (!grp) {\n\t\tdev_err(pctl->dev, \"unable to find group for node %s\\n\",\n\t\t\tof_node_full_name(np));\n\t\treturn -EINVAL;\n\t}\n\n\tret = of_property_count_strings(np, \"pins\");\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret == 1)\n\t\ttype = PIN_MAP_TYPE_CONFIGS_PIN;\n\telse\n\t\ttype = PIN_MAP_TYPE_CONFIGS_GROUP;\n\n\tret = of_property_read_string(np, \"function\", &function);\n\tif (ret < 0) {\n\t\tif (ret != -EINVAL)\n\t\t\tdev_err(pctl->dev,\n\t\t\t\t\"%s: could not parse property function\\n\",\n\t\t\t\tof_node_full_name(np));\n\t\tfunction = NULL;\n\t}\n\n\tret = pinconf_generic_parse_dt_config(np, pctldev, &configs,\n\t\t\t\t\t      &num_configs);\n\tif (ret < 0) {\n\t\tdev_err(pctl->dev, \"%s: could not parse node property\\n\",\n\t\t\tof_node_full_name(np));\n\t\treturn ret;\n\t}\n\n\t*map = NULL;\n\t*num_maps = 0;\n\n\tif (function != NULL)\n\t\treserve++;\n\tif (num_configs)\n\t\treserve++;\n\n\tret = pinctrl_utils_reserve_map(pctldev, map, &reserved_maps,\n\t\t\t\t\tnum_maps, reserve);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (function) {\n\t\tret = pinctrl_utils_add_map_mux(pctldev, map,\n\t\t\t\t\t\t&reserved_maps, num_maps,\n\t\t\t\t\t\tgrp->name, function);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tif (num_configs) {\n\t\tconst char *group_or_pin;\n\t\tunsigned int pin_id;\n\n\t\tif (type == PIN_MAP_TYPE_CONFIGS_PIN) {\n\t\t\tpin_id = grp->pins[0];\n\t\t\tgroup_or_pin = pin_get_name(pctldev, pin_id);\n\t\t} else {\n\t\t\tgroup_or_pin = grp->name;\n\t\t}\n\n\t\tret = pinctrl_utils_add_map_configs(pctldev, map,\n\t\t\t\t\t\t    &reserved_maps, num_maps,\n\t\t\t\t\t\t    group_or_pin, configs,\n\t\t\t\t\t\t    num_configs, type);\n\t}\n\nout:\n\tkfree(configs);\n\treturn ret;\n}\n\nstatic void sprd_pctrl_dbg_show(struct pinctrl_dev *pctldev, struct seq_file *s,\n\t\t\t\tunsigned int offset)\n{\n\tseq_printf(s, \"%s\", dev_name(pctldev->dev));\n}\n\nstatic const struct pinctrl_ops sprd_pctrl_ops = {\n\t.get_groups_count = sprd_pctrl_group_count,\n\t.get_group_name = sprd_pctrl_group_name,\n\t.get_group_pins = sprd_pctrl_group_pins,\n\t.pin_dbg_show = sprd_pctrl_dbg_show,\n\t.dt_node_to_map = sprd_dt_node_to_map,\n\t.dt_free_map = pinctrl_utils_free_map,\n};\n\nstatic int sprd_pmx_get_function_count(struct pinctrl_dev *pctldev)\n{\n\treturn PIN_FUNC_MAX;\n}\n\nstatic const char *sprd_pmx_get_function_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t      unsigned int selector)\n{\n\tswitch (selector) {\n\tcase PIN_FUNC_1:\n\t\treturn \"func1\";\n\tcase PIN_FUNC_2:\n\t\treturn \"func2\";\n\tcase PIN_FUNC_3:\n\t\treturn \"func3\";\n\tcase PIN_FUNC_4:\n\t\treturn \"func4\";\n\tdefault:\n\t\treturn \"null\";\n\t}\n}\n\nstatic int sprd_pmx_get_function_groups(struct pinctrl_dev *pctldev,\n\t\t\t\t\tunsigned int selector,\n\t\t\t\t\tconst char * const **groups,\n\t\t\t\t\tunsigned int * const num_groups)\n{\n\tstruct sprd_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct sprd_pinctrl_soc_info *info = pctl->info;\n\n\t*groups = info->grp_names;\n\t*num_groups = info->ngroups;\n\n\treturn 0;\n}\n\nstatic int sprd_pmx_set_mux(struct pinctrl_dev *pctldev,\n\t\t\t    unsigned int func_selector,\n\t\t\t    unsigned int group_selector)\n{\n\tstruct sprd_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct sprd_pinctrl_soc_info *info = pctl->info;\n\tstruct sprd_pin_group *grp = &info->groups[group_selector];\n\tunsigned int i, grp_pins = grp->npins;\n\tunsigned long reg;\n\tunsigned int val = 0;\n\n\tif (group_selector >= info->ngroups)\n\t\treturn -EINVAL;\n\n\tswitch (func_selector) {\n\tcase PIN_FUNC_1:\n\t\tval &= PIN_FUNC_SEL_1;\n\t\tbreak;\n\tcase PIN_FUNC_2:\n\t\tval |= PIN_FUNC_SEL_2;\n\t\tbreak;\n\tcase PIN_FUNC_3:\n\t\tval |= PIN_FUNC_SEL_3;\n\t\tbreak;\n\tcase PIN_FUNC_4:\n\t\tval |= PIN_FUNC_SEL_4;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < grp_pins; i++) {\n\t\tunsigned int pin_id = grp->pins[i];\n\t\tstruct sprd_pin *pin = sprd_pinctrl_get_pin_by_id(pctl, pin_id);\n\n\t\tif (!pin || pin->type != COMMON_PIN)\n\t\t\tcontinue;\n\n\t\treg = readl((void __iomem *)pin->reg);\n\t\treg &= ~PIN_FUNC_MASK;\n\t\treg |= val;\n\t\twritel(reg, (void __iomem *)pin->reg);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct pinmux_ops sprd_pmx_ops = {\n\t.get_functions_count = sprd_pmx_get_function_count,\n\t.get_function_name = sprd_pmx_get_function_name,\n\t.get_function_groups = sprd_pmx_get_function_groups,\n\t.set_mux = sprd_pmx_set_mux,\n};\n\nstatic int sprd_pinconf_get(struct pinctrl_dev *pctldev, unsigned int pin_id,\n\t\t\t    unsigned long *config)\n{\n\tstruct sprd_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct sprd_pin *pin = sprd_pinctrl_get_pin_by_id(pctl, pin_id);\n\tunsigned int param = pinconf_to_config_param(*config);\n\tunsigned int reg, arg;\n\n\tif (!pin)\n\t\treturn -EINVAL;\n\n\tif (pin->type == GLOBAL_CTRL_PIN) {\n\t\treg = (readl((void __iomem *)pin->reg) >>\n\t\t\t   pin->bit_offset) & PINCTRL_BIT_MASK(pin->bit_width);\n\t} else {\n\t\treg = readl((void __iomem *)pin->reg);\n\t}\n\n\tif (pin->type == GLOBAL_CTRL_PIN &&\n\t    param == SPRD_PIN_CONFIG_CONTROL) {\n\t\targ = reg;\n\t} else if (pin->type == COMMON_PIN || pin->type == MISC_PIN) {\n\t\tswitch (param) {\n\t\tcase SPRD_PIN_CONFIG_SLEEP_MODE:\n\t\t\targ = (reg >> SLEEP_MODE_SHIFT) & SLEEP_MODE_MASK;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_INPUT_ENABLE:\n\t\t\targ = (reg >> SLEEP_INPUT_SHIFT) & SLEEP_INPUT_MASK;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_OUTPUT_ENABLE:\n\t\t\targ = reg & SLEEP_OUTPUT_MASK;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_BIAS_HIGH_IMPEDANCE:\n\t\t\tif ((reg & SLEEP_OUTPUT) || (reg & SLEEP_INPUT))\n\t\t\t\treturn -EINVAL;\n\n\t\t\targ = 1;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_DRIVE_STRENGTH:\n\t\t\targ = (reg >> DRIVE_STRENGTH_SHIFT) &\n\t\t\t\tDRIVE_STRENGTH_MASK;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\t\t \n\t\t\targ = ((reg >> SLEEP_PULL_DOWN_SHIFT) &\n\t\t\t       SLEEP_PULL_DOWN_MASK) << 16;\n\t\t\targ |= (reg >> PULL_DOWN_SHIFT) & PULL_DOWN_MASK;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_INPUT_SCHMITT_ENABLE:\n\t\t\targ = (reg >> INPUT_SCHMITT_SHIFT) & INPUT_SCHMITT_MASK;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\t\t \n\t\t\targ = ((reg >> SLEEP_PULL_UP_SHIFT) &\n\t\t\t       SLEEP_PULL_UP_MASK) << 16;\n\t\t\targ |= (reg >> PULL_UP_SHIFT) & PULL_UP_MASK;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\t\tif ((reg & (SLEEP_PULL_DOWN | SLEEP_PULL_UP)) ||\n\t\t\t    (reg & (PULL_DOWN | PULL_UP_4_7K | PULL_UP_20K)))\n\t\t\t\treturn -EINVAL;\n\n\t\t\targ = 1;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_SLEEP_HARDWARE_STATE:\n\t\t\targ = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t} else {\n\t\treturn -ENOTSUPP;\n\t}\n\n\t*config = pinconf_to_config_packed(param, arg);\n\treturn 0;\n}\n\nstatic unsigned int sprd_pinconf_drive(unsigned int mA)\n{\n\tunsigned int val = 0;\n\n\tswitch (mA) {\n\tcase 2:\n\t\tbreak;\n\tcase 4:\n\t\tval |= BIT(19);\n\t\tbreak;\n\tcase 6:\n\t\tval |= BIT(20);\n\t\tbreak;\n\tcase 8:\n\t\tval |= BIT(19) | BIT(20);\n\t\tbreak;\n\tcase 10:\n\t\tval |= BIT(21);\n\t\tbreak;\n\tcase 12:\n\t\tval |= BIT(21) | BIT(19);\n\t\tbreak;\n\tcase 14:\n\t\tval |= BIT(21) | BIT(20);\n\t\tbreak;\n\tcase 16:\n\t\tval |= BIT(19) | BIT(20) | BIT(21);\n\t\tbreak;\n\tcase 20:\n\t\tval |= BIT(22);\n\t\tbreak;\n\tcase 21:\n\t\tval |= BIT(22) | BIT(19);\n\t\tbreak;\n\tcase 24:\n\t\tval |= BIT(22) | BIT(20);\n\t\tbreak;\n\tcase 25:\n\t\tval |= BIT(22) | BIT(20) | BIT(19);\n\t\tbreak;\n\tcase 27:\n\t\tval |= BIT(22) | BIT(21);\n\t\tbreak;\n\tcase 29:\n\t\tval |= BIT(22) | BIT(21) | BIT(19);\n\t\tbreak;\n\tcase 31:\n\t\tval |= BIT(22) | BIT(21) | BIT(20);\n\t\tbreak;\n\tcase 33:\n\t\tval |= BIT(22) | BIT(21) | BIT(20) | BIT(19);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn val;\n}\n\nstatic bool sprd_pinctrl_check_sleep_config(unsigned long *configs,\n\t\t\t\t\t    unsigned int num_configs)\n{\n\tunsigned int param;\n\tint i;\n\n\tfor (i = 0; i < num_configs; i++) {\n\t\tparam = pinconf_to_config_param(configs[i]);\n\t\tif (param == PIN_CONFIG_SLEEP_HARDWARE_STATE)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int sprd_pinconf_set(struct pinctrl_dev *pctldev, unsigned int pin_id,\n\t\t\t    unsigned long *configs, unsigned int num_configs)\n{\n\tstruct sprd_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct sprd_pin *pin = sprd_pinctrl_get_pin_by_id(pctl, pin_id);\n\tbool is_sleep_config;\n\tunsigned long reg;\n\tint i;\n\n\tif (!pin)\n\t\treturn -EINVAL;\n\n\tis_sleep_config = sprd_pinctrl_check_sleep_config(configs, num_configs);\n\n\tfor (i = 0; i < num_configs; i++) {\n\t\tunsigned int param, arg, shift, mask, val;\n\n\t\tparam = pinconf_to_config_param(configs[i]);\n\t\targ = pinconf_to_config_argument(configs[i]);\n\n\t\tval = 0;\n\t\tshift = 0;\n\t\tmask = 0;\n\t\tif (pin->type == GLOBAL_CTRL_PIN &&\n\t\t    param == SPRD_PIN_CONFIG_CONTROL) {\n\t\t\tval = arg;\n\t\t} else if (pin->type == COMMON_PIN || pin->type == MISC_PIN) {\n\t\t\tswitch (param) {\n\t\t\tcase SPRD_PIN_CONFIG_SLEEP_MODE:\n\t\t\t\tif (arg & AP_SLEEP)\n\t\t\t\t\tval |= AP_SLEEP_MODE;\n\t\t\t\tif (arg & PUBCP_SLEEP)\n\t\t\t\t\tval |= PUBCP_SLEEP_MODE;\n\t\t\t\tif (arg & TGLDSP_SLEEP)\n\t\t\t\t\tval |= TGLDSP_SLEEP_MODE;\n\t\t\t\tif (arg & AGDSP_SLEEP)\n\t\t\t\t\tval |= AGDSP_SLEEP_MODE;\n\t\t\t\tif (arg & CM4_SLEEP)\n\t\t\t\t\tval |= CM4_SLEEP_MODE;\n\n\t\t\t\tmask = SLEEP_MODE_MASK;\n\t\t\t\tshift = SLEEP_MODE_SHIFT;\n\t\t\t\tbreak;\n\t\t\tcase PIN_CONFIG_INPUT_ENABLE:\n\t\t\t\tif (is_sleep_config == true) {\n\t\t\t\t\tif (arg > 0)\n\t\t\t\t\t\tval |= SLEEP_INPUT;\n\t\t\t\t\telse\n\t\t\t\t\t\tval &= ~SLEEP_INPUT;\n\n\t\t\t\t\tmask = SLEEP_INPUT_MASK;\n\t\t\t\t\tshift = SLEEP_INPUT_SHIFT;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PIN_CONFIG_OUTPUT_ENABLE:\n\t\t\t\tif (is_sleep_config == true) {\n\t\t\t\t\tif (arg > 0)\n\t\t\t\t\t\tval |= SLEEP_OUTPUT;\n\t\t\t\t\telse\n\t\t\t\t\t\tval &= ~SLEEP_OUTPUT;\n\n\t\t\t\t\tmask = SLEEP_OUTPUT_MASK;\n\t\t\t\t\tshift = SLEEP_OUTPUT_SHIFT;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PIN_CONFIG_BIAS_HIGH_IMPEDANCE:\n\t\t\t\tif (is_sleep_config == true) {\n\t\t\t\t\tval = shift = 0;\n\t\t\t\t\tmask = SLEEP_OUTPUT | SLEEP_INPUT;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PIN_CONFIG_DRIVE_STRENGTH:\n\t\t\t\tif (arg < 2 || arg > 60)\n\t\t\t\t\treturn -EINVAL;\n\n\t\t\t\tval = sprd_pinconf_drive(arg);\n\t\t\t\tmask = DRIVE_STRENGTH_MASK;\n\t\t\t\tshift = DRIVE_STRENGTH_SHIFT;\n\t\t\t\tbreak;\n\t\t\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\t\t\tif (is_sleep_config == true) {\n\t\t\t\t\tval |= SLEEP_PULL_DOWN;\n\t\t\t\t\tmask = SLEEP_PULL_DOWN_MASK;\n\t\t\t\t\tshift = SLEEP_PULL_DOWN_SHIFT;\n\t\t\t\t} else {\n\t\t\t\t\tval |= PULL_DOWN;\n\t\t\t\t\tmask = PULL_DOWN_MASK;\n\t\t\t\t\tshift = PULL_DOWN_SHIFT;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PIN_CONFIG_INPUT_SCHMITT_ENABLE:\n\t\t\t\tif (arg > 0)\n\t\t\t\t\tval |= INPUT_SCHMITT;\n\t\t\t\telse\n\t\t\t\t\tval &= ~INPUT_SCHMITT;\n\n\t\t\t\tmask = INPUT_SCHMITT_MASK;\n\t\t\t\tshift = INPUT_SCHMITT_SHIFT;\n\t\t\t\tbreak;\n\t\t\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\t\t\tif (is_sleep_config) {\n\t\t\t\t\tval |= SLEEP_PULL_UP;\n\t\t\t\t\tmask = SLEEP_PULL_UP_MASK;\n\t\t\t\t\tshift = SLEEP_PULL_UP_SHIFT;\n\t\t\t\t} else {\n\t\t\t\t\tif (arg == 20000)\n\t\t\t\t\t\tval |= PULL_UP_20K;\n\t\t\t\t\telse if (arg == 4700)\n\t\t\t\t\t\tval |= PULL_UP_4_7K;\n\n\t\t\t\t\tmask = PULL_UP_MASK;\n\t\t\t\t\tshift = PULL_UP_SHIFT;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\t\t\tif (is_sleep_config == true) {\n\t\t\t\t\tval = shift = 0;\n\t\t\t\t\tmask = SLEEP_PULL_DOWN | SLEEP_PULL_UP;\n\t\t\t\t} else {\n\t\t\t\t\tval = shift = 0;\n\t\t\t\t\tmask = PULL_DOWN | PULL_UP_20K |\n\t\t\t\t\t\tPULL_UP_4_7K;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PIN_CONFIG_SLEEP_HARDWARE_STATE:\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\treturn -ENOTSUPP;\n\t\t\t}\n\t\t} else {\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\n\t\tif (pin->type == GLOBAL_CTRL_PIN) {\n\t\t\treg = readl((void __iomem *)pin->reg);\n\t\t\treg &= ~(PINCTRL_BIT_MASK(pin->bit_width)\n\t\t\t\t<< pin->bit_offset);\n\t\t\treg |= (val & PINCTRL_BIT_MASK(pin->bit_width))\n\t\t\t\t<< pin->bit_offset;\n\t\t\twritel(reg, (void __iomem *)pin->reg);\n\t\t} else {\n\t\t\treg = readl((void __iomem *)pin->reg);\n\t\t\treg &= ~(mask << shift);\n\t\t\treg |= val;\n\t\t\twritel(reg, (void __iomem *)pin->reg);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int sprd_pinconf_group_get(struct pinctrl_dev *pctldev,\n\t\t\t\t  unsigned int selector, unsigned long *config)\n{\n\tstruct sprd_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct sprd_pinctrl_soc_info *info = pctl->info;\n\tstruct sprd_pin_group *grp;\n\tunsigned int pin_id;\n\n\tif (selector >= info->ngroups)\n\t\treturn -EINVAL;\n\n\tgrp = &info->groups[selector];\n\tpin_id = grp->pins[0];\n\n\treturn sprd_pinconf_get(pctldev, pin_id, config);\n}\n\nstatic int sprd_pinconf_group_set(struct pinctrl_dev *pctldev,\n\t\t\t\t  unsigned int selector,\n\t\t\t\t  unsigned long *configs,\n\t\t\t\t  unsigned int num_configs)\n{\n\tstruct sprd_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct sprd_pinctrl_soc_info *info = pctl->info;\n\tstruct sprd_pin_group *grp;\n\tint ret, i;\n\n\tif (selector >= info->ngroups)\n\t\treturn -EINVAL;\n\n\tgrp = &info->groups[selector];\n\n\tfor (i = 0; i < grp->npins; i++) {\n\t\tunsigned int pin_id = grp->pins[i];\n\n\t\tret = sprd_pinconf_set(pctldev, pin_id, configs, num_configs);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int sprd_pinconf_get_config(struct pinctrl_dev *pctldev,\n\t\t\t\t   unsigned int pin_id,\n\t\t\t\t   unsigned long *config)\n{\n\tstruct sprd_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct sprd_pin *pin = sprd_pinctrl_get_pin_by_id(pctl, pin_id);\n\n\tif (!pin)\n\t\treturn -EINVAL;\n\n\tif (pin->type == GLOBAL_CTRL_PIN) {\n\t\t*config = (readl((void __iomem *)pin->reg) >>\n\t\t\t   pin->bit_offset) & PINCTRL_BIT_MASK(pin->bit_width);\n\t} else {\n\t\t*config = readl((void __iomem *)pin->reg);\n\t}\n\n\treturn 0;\n}\n\nstatic void sprd_pinconf_dbg_show(struct pinctrl_dev *pctldev,\n\t\t\t\t  struct seq_file *s, unsigned int pin_id)\n{\n\tunsigned long config;\n\tint ret;\n\n\tret = sprd_pinconf_get_config(pctldev, pin_id, &config);\n\tif (ret)\n\t\treturn;\n\n\tseq_printf(s, \"0x%lx\", config);\n}\n\nstatic void sprd_pinconf_group_dbg_show(struct pinctrl_dev *pctldev,\n\t\t\t\t\tstruct seq_file *s,\n\t\t\t\t\tunsigned int selector)\n{\n\tstruct sprd_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct sprd_pinctrl_soc_info *info = pctl->info;\n\tstruct sprd_pin_group *grp;\n\tunsigned long config;\n\tconst char *name;\n\tint i, ret;\n\n\tif (selector >= info->ngroups)\n\t\treturn;\n\n\tgrp = &info->groups[selector];\n\n\tseq_putc(s, '\\n');\n\tfor (i = 0; i < grp->npins; i++, config++) {\n\t\tunsigned int pin_id = grp->pins[i];\n\n\t\tname = pin_get_name(pctldev, pin_id);\n\t\tret = sprd_pinconf_get_config(pctldev, pin_id, &config);\n\t\tif (ret)\n\t\t\treturn;\n\n\t\tseq_printf(s, \"%s: 0x%lx \", name, config);\n\t}\n}\n\nstatic const struct pinconf_ops sprd_pinconf_ops = {\n\t.is_generic = true,\n\t.pin_config_get = sprd_pinconf_get,\n\t.pin_config_set = sprd_pinconf_set,\n\t.pin_config_group_get = sprd_pinconf_group_get,\n\t.pin_config_group_set = sprd_pinconf_group_set,\n\t.pin_config_dbg_show = sprd_pinconf_dbg_show,\n\t.pin_config_group_dbg_show = sprd_pinconf_group_dbg_show,\n};\n\nstatic const struct pinconf_generic_params sprd_dt_params[] = {\n\t{\"sprd,control\", SPRD_PIN_CONFIG_CONTROL, 0},\n\t{\"sprd,sleep-mode\", SPRD_PIN_CONFIG_SLEEP_MODE, 0},\n};\n\n#ifdef CONFIG_DEBUG_FS\nstatic const struct pin_config_item sprd_conf_items[] = {\n\tPCONFDUMP(SPRD_PIN_CONFIG_CONTROL, \"global control\", NULL, true),\n\tPCONFDUMP(SPRD_PIN_CONFIG_SLEEP_MODE, \"sleep mode\", NULL, true),\n};\n#endif\n\nstatic struct pinctrl_desc sprd_pinctrl_desc = {\n\t.pctlops = &sprd_pctrl_ops,\n\t.pmxops = &sprd_pmx_ops,\n\t.confops = &sprd_pinconf_ops,\n\t.num_custom_params = ARRAY_SIZE(sprd_dt_params),\n\t.custom_params = sprd_dt_params,\n#ifdef CONFIG_DEBUG_FS\n\t.custom_conf_items = sprd_conf_items,\n#endif\n\t.owner = THIS_MODULE,\n};\n\nstatic int sprd_pinctrl_parse_groups(struct device_node *np,\n\t\t\t\t     struct sprd_pinctrl *sprd_pctl,\n\t\t\t\t     struct sprd_pin_group *grp)\n{\n\tstruct property *prop;\n\tconst char *pin_name;\n\tint ret, i = 0;\n\n\tret = of_property_count_strings(np, \"pins\");\n\tif (ret < 0)\n\t\treturn ret;\n\n\tgrp->name = np->name;\n\tgrp->npins = ret;\n\tgrp->pins = devm_kcalloc(sprd_pctl->dev,\n\t\t\t\t grp->npins, sizeof(unsigned int),\n\t\t\t\t GFP_KERNEL);\n\tif (!grp->pins)\n\t\treturn -ENOMEM;\n\n\tof_property_for_each_string(np, \"pins\", prop, pin_name) {\n\t\tret = sprd_pinctrl_get_id_by_name(sprd_pctl, pin_name);\n\t\tif (ret >= 0)\n\t\t\tgrp->pins[i++] = ret;\n\t}\n\n\tfor (i = 0; i < grp->npins; i++) {\n\t\tdev_dbg(sprd_pctl->dev,\n\t\t\t\"Group[%s] contains [%d] pins: id = %d\\n\",\n\t\t\tgrp->name, grp->npins, grp->pins[i]);\n\t}\n\n\treturn 0;\n}\n\nstatic unsigned int sprd_pinctrl_get_groups(struct device_node *np)\n{\n\tstruct device_node *child;\n\tunsigned int group_cnt, cnt;\n\n\tgroup_cnt = of_get_child_count(np);\n\n\tfor_each_child_of_node(np, child) {\n\t\tcnt = of_get_child_count(child);\n\t\tif (cnt > 0)\n\t\t\tgroup_cnt += cnt;\n\t}\n\n\treturn group_cnt;\n}\n\nstatic int sprd_pinctrl_parse_dt(struct sprd_pinctrl *sprd_pctl)\n{\n\tstruct sprd_pinctrl_soc_info *info = sprd_pctl->info;\n\tstruct device_node *np = sprd_pctl->dev->of_node;\n\tstruct device_node *child, *sub_child;\n\tstruct sprd_pin_group *grp;\n\tconst char **temp;\n\tint ret;\n\n\tif (!np)\n\t\treturn -ENODEV;\n\n\tinfo->ngroups = sprd_pinctrl_get_groups(np);\n\tif (!info->ngroups)\n\t\treturn 0;\n\n\tinfo->groups = devm_kcalloc(sprd_pctl->dev,\n\t\t\t\t    info->ngroups,\n\t\t\t\t    sizeof(struct sprd_pin_group),\n\t\t\t\t    GFP_KERNEL);\n\tif (!info->groups)\n\t\treturn -ENOMEM;\n\n\tinfo->grp_names = devm_kcalloc(sprd_pctl->dev,\n\t\t\t\t       info->ngroups, sizeof(char *),\n\t\t\t\t       GFP_KERNEL);\n\tif (!info->grp_names)\n\t\treturn -ENOMEM;\n\n\ttemp = info->grp_names;\n\tgrp = info->groups;\n\n\tfor_each_child_of_node(np, child) {\n\t\tret = sprd_pinctrl_parse_groups(child, sprd_pctl, grp);\n\t\tif (ret) {\n\t\t\tof_node_put(child);\n\t\t\treturn ret;\n\t\t}\n\n\t\t*temp++ = grp->name;\n\t\tgrp++;\n\n\t\tif (of_get_child_count(child) > 0) {\n\t\t\tfor_each_child_of_node(child, sub_child) {\n\t\t\t\tret = sprd_pinctrl_parse_groups(sub_child,\n\t\t\t\t\t\t\t\tsprd_pctl, grp);\n\t\t\t\tif (ret) {\n\t\t\t\t\tof_node_put(sub_child);\n\t\t\t\t\tof_node_put(child);\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\t*temp++ = grp->name;\n\t\t\t\tgrp++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int sprd_pinctrl_add_pins(struct sprd_pinctrl *sprd_pctl,\n\t\t\t\t struct sprd_pins_info *sprd_soc_pin_info,\n\t\t\t\t int pins_cnt)\n{\n\tstruct sprd_pinctrl_soc_info *info = sprd_pctl->info;\n\tunsigned int ctrl_pin = 0, com_pin = 0;\n\tstruct sprd_pin *pin;\n\tint i;\n\n\tinfo->npins = pins_cnt;\n\tinfo->pins = devm_kcalloc(sprd_pctl->dev,\n\t\t\t\t  info->npins, sizeof(struct sprd_pin),\n\t\t\t\t  GFP_KERNEL);\n\tif (!info->pins)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0, pin = info->pins; i < info->npins; i++, pin++) {\n\t\tunsigned int reg;\n\n\t\tpin->name = sprd_soc_pin_info[i].name;\n\t\tpin->type = sprd_soc_pin_info[i].type;\n\t\tpin->number = sprd_soc_pin_info[i].num;\n\t\treg = sprd_soc_pin_info[i].reg;\n\t\tif (pin->type == GLOBAL_CTRL_PIN) {\n\t\t\tpin->reg = (unsigned long)sprd_pctl->base +\n\t\t\t\tPINCTRL_REG_LEN * reg;\n\t\t\tpin->bit_offset = sprd_soc_pin_info[i].bit_offset;\n\t\t\tpin->bit_width = sprd_soc_pin_info[i].bit_width;\n\t\t\tctrl_pin++;\n\t\t} else if (pin->type == COMMON_PIN) {\n\t\t\tpin->reg = (unsigned long)sprd_pctl->base +\n\t\t\t\tPINCTRL_REG_OFFSET + PINCTRL_REG_LEN *\n\t\t\t\t(i - ctrl_pin);\n\t\t\tcom_pin++;\n\t\t} else if (pin->type == MISC_PIN) {\n\t\t\tpin->reg = (unsigned long)sprd_pctl->base +\n\t\t\t\tPINCTRL_REG_MISC_OFFSET + PINCTRL_REG_LEN *\n\t\t\t\t(i - ctrl_pin - com_pin);\n\t\t}\n\t}\n\n\tfor (i = 0, pin = info->pins; i < info->npins; pin++, i++) {\n\t\tdev_dbg(sprd_pctl->dev, \"pin name[%s-%d], type = %d, \"\n\t\t\t\"bit offset = %ld, bit width = %ld, reg = 0x%lx\\n\",\n\t\t\tpin->name, pin->number, pin->type,\n\t\t\tpin->bit_offset, pin->bit_width, pin->reg);\n\t}\n\n\treturn 0;\n}\n\nint sprd_pinctrl_core_probe(struct platform_device *pdev,\n\t\t\t    struct sprd_pins_info *sprd_soc_pin_info,\n\t\t\t    int pins_cnt)\n{\n\tstruct sprd_pinctrl *sprd_pctl;\n\tstruct sprd_pinctrl_soc_info *pinctrl_info;\n\tstruct pinctrl_pin_desc *pin_desc;\n\tint ret, i;\n\n\tsprd_pctl = devm_kzalloc(&pdev->dev, sizeof(struct sprd_pinctrl),\n\t\t\t\t GFP_KERNEL);\n\tif (!sprd_pctl)\n\t\treturn -ENOMEM;\n\n\tsprd_pctl->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(sprd_pctl->base))\n\t\treturn PTR_ERR(sprd_pctl->base);\n\n\tpinctrl_info = devm_kzalloc(&pdev->dev,\n\t\t\t\t    sizeof(struct sprd_pinctrl_soc_info),\n\t\t\t\t    GFP_KERNEL);\n\tif (!pinctrl_info)\n\t\treturn -ENOMEM;\n\n\tsprd_pctl->info = pinctrl_info;\n\tsprd_pctl->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, sprd_pctl);\n\n\tret = sprd_pinctrl_add_pins(sprd_pctl, sprd_soc_pin_info, pins_cnt);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"fail to add pins information\\n\");\n\t\treturn ret;\n\t}\n\n\tret = sprd_pinctrl_parse_dt(sprd_pctl);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"fail to parse dt properties\\n\");\n\t\treturn ret;\n\t}\n\n\tpin_desc = devm_kcalloc(&pdev->dev,\n\t\t\t\tpinctrl_info->npins,\n\t\t\t\tsizeof(struct pinctrl_pin_desc),\n\t\t\t\tGFP_KERNEL);\n\tif (!pin_desc)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < pinctrl_info->npins; i++) {\n\t\tpin_desc[i].number = pinctrl_info->pins[i].number;\n\t\tpin_desc[i].name = pinctrl_info->pins[i].name;\n\t\tpin_desc[i].drv_data = pinctrl_info;\n\t}\n\n\tsprd_pinctrl_desc.pins = pin_desc;\n\tsprd_pinctrl_desc.name = dev_name(&pdev->dev);\n\tsprd_pinctrl_desc.npins = pinctrl_info->npins;\n\n\tsprd_pctl->pctl = pinctrl_register(&sprd_pinctrl_desc,\n\t\t\t\t\t   &pdev->dev, (void *)sprd_pctl);\n\tif (IS_ERR(sprd_pctl->pctl)) {\n\t\tdev_err(&pdev->dev, \"could not register pinctrl driver\\n\");\n\t\treturn PTR_ERR(sprd_pctl->pctl);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(sprd_pinctrl_core_probe);\n\nint sprd_pinctrl_remove(struct platform_device *pdev)\n{\n\tstruct sprd_pinctrl *sprd_pctl = platform_get_drvdata(pdev);\n\n\tpinctrl_unregister(sprd_pctl->pctl);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(sprd_pinctrl_remove);\n\nvoid sprd_pinctrl_shutdown(struct platform_device *pdev)\n{\n\tstruct pinctrl *pinctl;\n\tstruct pinctrl_state *state;\n\n\tpinctl = devm_pinctrl_get(&pdev->dev);\n\tif (IS_ERR(pinctl))\n\t\treturn;\n\tstate = pinctrl_lookup_state(pinctl, \"shutdown\");\n\tif (IS_ERR(state))\n\t\treturn;\n\tpinctrl_select_state(pinctl, state);\n}\nEXPORT_SYMBOL_GPL(sprd_pinctrl_shutdown);\n\nMODULE_DESCRIPTION(\"SPREADTRUM Pin Controller Driver\");\nMODULE_AUTHOR(\"Baolin Wang <baolin.wang@spreadtrum.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}