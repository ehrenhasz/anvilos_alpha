{
  "module_name": "pinconf-generic.c",
  "hash_id": "3acc746a34d210a117fa3e9cf8260e7b4b1f93851d88d21e02a2e2e22692947d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/pinconf-generic.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"generic pinconfig core: \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/slab.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinconf-generic.h>\n#include <linux/of.h>\n#include \"core.h\"\n#include \"pinconf.h\"\n#include \"pinctrl-utils.h\"\n\n#ifdef CONFIG_DEBUG_FS\nstatic const struct pin_config_item conf_items[] = {\n\tPCONFDUMP(PIN_CONFIG_BIAS_BUS_HOLD, \"input bias bus hold\", NULL, false),\n\tPCONFDUMP(PIN_CONFIG_BIAS_DISABLE, \"input bias disabled\", NULL, false),\n\tPCONFDUMP(PIN_CONFIG_BIAS_HIGH_IMPEDANCE, \"input bias high impedance\", NULL, false),\n\tPCONFDUMP(PIN_CONFIG_BIAS_PULL_DOWN, \"input bias pull down\", \"ohms\", true),\n\tPCONFDUMP(PIN_CONFIG_BIAS_PULL_PIN_DEFAULT,\n\t\t\t\t\"input bias pull to pin specific state\", \"ohms\", true),\n\tPCONFDUMP(PIN_CONFIG_BIAS_PULL_UP, \"input bias pull up\", \"ohms\", true),\n\tPCONFDUMP(PIN_CONFIG_DRIVE_OPEN_DRAIN, \"output drive open drain\", NULL, false),\n\tPCONFDUMP(PIN_CONFIG_DRIVE_OPEN_SOURCE, \"output drive open source\", NULL, false),\n\tPCONFDUMP(PIN_CONFIG_DRIVE_PUSH_PULL, \"output drive push pull\", NULL, false),\n\tPCONFDUMP(PIN_CONFIG_DRIVE_STRENGTH, \"output drive strength\", \"mA\", true),\n\tPCONFDUMP(PIN_CONFIG_DRIVE_STRENGTH_UA, \"output drive strength\", \"uA\", true),\n\tPCONFDUMP(PIN_CONFIG_INPUT_DEBOUNCE, \"input debounce\", \"usec\", true),\n\tPCONFDUMP(PIN_CONFIG_INPUT_ENABLE, \"input enabled\", NULL, false),\n\tPCONFDUMP(PIN_CONFIG_INPUT_SCHMITT, \"input schmitt trigger\", NULL, false),\n\tPCONFDUMP(PIN_CONFIG_INPUT_SCHMITT_ENABLE, \"input schmitt enabled\", NULL, false),\n\tPCONFDUMP(PIN_CONFIG_MODE_LOW_POWER, \"pin low power\", \"mode\", true),\n\tPCONFDUMP(PIN_CONFIG_OUTPUT_ENABLE, \"output enabled\", NULL, false),\n\tPCONFDUMP(PIN_CONFIG_OUTPUT, \"pin output\", \"level\", true),\n\tPCONFDUMP(PIN_CONFIG_OUTPUT_IMPEDANCE_OHMS, \"output impedance\", \"ohms\", true),\n\tPCONFDUMP(PIN_CONFIG_POWER_SOURCE, \"pin power source\", \"selector\", true),\n\tPCONFDUMP(PIN_CONFIG_SLEEP_HARDWARE_STATE, \"sleep hardware state\", NULL, false),\n\tPCONFDUMP(PIN_CONFIG_SLEW_RATE, \"slew rate\", NULL, true),\n\tPCONFDUMP(PIN_CONFIG_SKEW_DELAY, \"skew delay\", NULL, true),\n};\n\nstatic void pinconf_generic_dump_one(struct pinctrl_dev *pctldev,\n\t\t\t\t     struct seq_file *s, const char *gname,\n\t\t\t\t     unsigned pin,\n\t\t\t\t     const struct pin_config_item *items,\n\t\t\t\t     int nitems, int *print_sep)\n{\n\tint i;\n\n\tfor (i = 0; i < nitems; i++) {\n\t\tunsigned long config;\n\t\tint ret;\n\n\t\t \n\t\tconfig = pinconf_to_config_packed(items[i].param, 0);\n\t\tif (gname)\n\t\t\tret = pin_config_group_get(dev_name(pctldev->dev),\n\t\t\t\t\t\t   gname, &config);\n\t\telse\n\t\t\tret = pin_config_get_for_pin(pctldev, pin, &config);\n\t\t \n\t\tif (ret == -EINVAL || ret == -ENOTSUPP)\n\t\t\tcontinue;\n\t\tif (ret) {\n\t\t\tseq_printf(s, \"ERROR READING CONFIG SETTING %d \", i);\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (*print_sep)\n\t\t\tseq_puts(s, \", \");\n\t\t*print_sep = 1;\n\t\tseq_puts(s, items[i].display);\n\t\t \n\t\tif (items[i].has_arg) {\n\t\t\tseq_printf(s, \" (%u\",\n\t\t\t\t   pinconf_to_config_argument(config));\n\t\t\tif (items[i].format)\n\t\t\t\tseq_printf(s, \" %s)\", items[i].format);\n\t\t\telse\n\t\t\t\tseq_puts(s, \")\");\n\t\t}\n\t}\n}\n\n \nvoid pinconf_generic_dump_pins(struct pinctrl_dev *pctldev, struct seq_file *s,\n\t\t\t       const char *gname, unsigned pin)\n{\n\tconst struct pinconf_ops *ops = pctldev->desc->confops;\n\tint print_sep = 0;\n\n\tif (!ops->is_generic)\n\t\treturn;\n\n\t \n\tpinconf_generic_dump_one(pctldev, s, gname, pin, conf_items,\n\t\t\t\t ARRAY_SIZE(conf_items), &print_sep);\n\t \n\tif (pctldev->desc->num_custom_params &&\n\t    pctldev->desc->custom_conf_items)\n\t\tpinconf_generic_dump_one(pctldev, s, gname, pin,\n\t\t\t\t\t pctldev->desc->custom_conf_items,\n\t\t\t\t\t pctldev->desc->num_custom_params,\n\t\t\t\t\t &print_sep);\n}\n\nvoid pinconf_generic_dump_config(struct pinctrl_dev *pctldev,\n\t\t\t\t struct seq_file *s, unsigned long config)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(conf_items); i++) {\n\t\tif (pinconf_to_config_param(config) != conf_items[i].param)\n\t\t\tcontinue;\n\t\tseq_printf(s, \"%s: 0x%x\", conf_items[i].display,\n\t\t\t   pinconf_to_config_argument(config));\n\t}\n\n\tif (!pctldev->desc->num_custom_params ||\n\t    !pctldev->desc->custom_conf_items)\n\t\treturn;\n\n\tfor (i = 0; i < pctldev->desc->num_custom_params; i++) {\n\t\tif (pinconf_to_config_param(config) !=\n\t\t    pctldev->desc->custom_conf_items[i].param)\n\t\t\tcontinue;\n\t\tseq_printf(s, \"%s: 0x%x\",\n\t\t\t\tpctldev->desc->custom_conf_items[i].display,\n\t\t\t\tpinconf_to_config_argument(config));\n\t}\n}\nEXPORT_SYMBOL_GPL(pinconf_generic_dump_config);\n#endif\n\n#ifdef CONFIG_OF\nstatic const struct pinconf_generic_params dt_params[] = {\n\t{ \"bias-bus-hold\", PIN_CONFIG_BIAS_BUS_HOLD, 0 },\n\t{ \"bias-disable\", PIN_CONFIG_BIAS_DISABLE, 0 },\n\t{ \"bias-high-impedance\", PIN_CONFIG_BIAS_HIGH_IMPEDANCE, 0 },\n\t{ \"bias-pull-up\", PIN_CONFIG_BIAS_PULL_UP, 1 },\n\t{ \"bias-pull-pin-default\", PIN_CONFIG_BIAS_PULL_PIN_DEFAULT, 1 },\n\t{ \"bias-pull-down\", PIN_CONFIG_BIAS_PULL_DOWN, 1 },\n\t{ \"drive-open-drain\", PIN_CONFIG_DRIVE_OPEN_DRAIN, 0 },\n\t{ \"drive-open-source\", PIN_CONFIG_DRIVE_OPEN_SOURCE, 0 },\n\t{ \"drive-push-pull\", PIN_CONFIG_DRIVE_PUSH_PULL, 0 },\n\t{ \"drive-strength\", PIN_CONFIG_DRIVE_STRENGTH, 0 },\n\t{ \"drive-strength-microamp\", PIN_CONFIG_DRIVE_STRENGTH_UA, 0 },\n\t{ \"input-debounce\", PIN_CONFIG_INPUT_DEBOUNCE, 0 },\n\t{ \"input-disable\", PIN_CONFIG_INPUT_ENABLE, 0 },\n\t{ \"input-enable\", PIN_CONFIG_INPUT_ENABLE, 1 },\n\t{ \"input-schmitt\", PIN_CONFIG_INPUT_SCHMITT, 0 },\n\t{ \"input-schmitt-disable\", PIN_CONFIG_INPUT_SCHMITT_ENABLE, 0 },\n\t{ \"input-schmitt-enable\", PIN_CONFIG_INPUT_SCHMITT_ENABLE, 1 },\n\t{ \"low-power-disable\", PIN_CONFIG_MODE_LOW_POWER, 0 },\n\t{ \"low-power-enable\", PIN_CONFIG_MODE_LOW_POWER, 1 },\n\t{ \"output-disable\", PIN_CONFIG_OUTPUT_ENABLE, 0 },\n\t{ \"output-enable\", PIN_CONFIG_OUTPUT_ENABLE, 1 },\n\t{ \"output-high\", PIN_CONFIG_OUTPUT, 1, },\n\t{ \"output-impedance-ohms\", PIN_CONFIG_OUTPUT_IMPEDANCE_OHMS, 0 },\n\t{ \"output-low\", PIN_CONFIG_OUTPUT, 0, },\n\t{ \"power-source\", PIN_CONFIG_POWER_SOURCE, 0 },\n\t{ \"sleep-hardware-state\", PIN_CONFIG_SLEEP_HARDWARE_STATE, 0 },\n\t{ \"slew-rate\", PIN_CONFIG_SLEW_RATE, 0 },\n\t{ \"skew-delay\", PIN_CONFIG_SKEW_DELAY, 0 },\n};\n\n \nstatic void parse_dt_cfg(struct device_node *np,\n\t\t\t const struct pinconf_generic_params *params,\n\t\t\t unsigned int count, unsigned long *cfg,\n\t\t\t unsigned int *ncfg)\n{\n\tint i;\n\n\tfor (i = 0; i < count; i++) {\n\t\tu32 val;\n\t\tint ret;\n\t\tconst struct pinconf_generic_params *par = &params[i];\n\n\t\tret = of_property_read_u32(np, par->property, &val);\n\n\t\t \n\t\tif (ret == -EINVAL)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (ret)\n\t\t\tval = par->default_value;\n\n\t\tpr_debug(\"found %s with value %u\\n\", par->property, val);\n\t\tcfg[*ncfg] = pinconf_to_config_packed(par->param, val);\n\t\t(*ncfg)++;\n\t}\n}\n\n \nint pinconf_generic_parse_dt_config(struct device_node *np,\n\t\t\t\t    struct pinctrl_dev *pctldev,\n\t\t\t\t    unsigned long **configs,\n\t\t\t\t    unsigned int *nconfigs)\n{\n\tunsigned long *cfg;\n\tunsigned int max_cfg, ncfg = 0;\n\tint ret;\n\n\tif (!np)\n\t\treturn -EINVAL;\n\n\t \n\tmax_cfg = ARRAY_SIZE(dt_params);\n\tif (pctldev)\n\t\tmax_cfg += pctldev->desc->num_custom_params;\n\tcfg = kcalloc(max_cfg, sizeof(*cfg), GFP_KERNEL);\n\tif (!cfg)\n\t\treturn -ENOMEM;\n\n\tparse_dt_cfg(np, dt_params, ARRAY_SIZE(dt_params), cfg, &ncfg);\n\tif (pctldev && pctldev->desc->num_custom_params &&\n\t\tpctldev->desc->custom_params)\n\t\tparse_dt_cfg(np, pctldev->desc->custom_params,\n\t\t\t     pctldev->desc->num_custom_params, cfg, &ncfg);\n\n\tret = 0;\n\n\t \n\tif (ncfg == 0) {\n\t\t*configs = NULL;\n\t\t*nconfigs = 0;\n\t\tgoto out;\n\t}\n\n\t \n\t*configs = kmemdup(cfg, ncfg * sizeof(unsigned long), GFP_KERNEL);\n\tif (!*configs) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t*nconfigs = ncfg;\n\nout:\n\tkfree(cfg);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(pinconf_generic_parse_dt_config);\n\nint pinconf_generic_dt_subnode_to_map(struct pinctrl_dev *pctldev,\n\t\tstruct device_node *np, struct pinctrl_map **map,\n\t\tunsigned *reserved_maps, unsigned *num_maps,\n\t\tenum pinctrl_map_type type)\n{\n\tint ret;\n\tconst char *function;\n\tstruct device *dev = pctldev->dev;\n\tunsigned long *configs = NULL;\n\tunsigned num_configs = 0;\n\tunsigned reserve, strings_count;\n\tstruct property *prop;\n\tconst char *group;\n\tconst char *subnode_target_type = \"pins\";\n\n\tret = of_property_count_strings(np, \"pins\");\n\tif (ret < 0) {\n\t\tret = of_property_count_strings(np, \"groups\");\n\t\tif (ret < 0)\n\t\t\t \n\t\t\treturn 0;\n\t\tif (type == PIN_MAP_TYPE_INVALID)\n\t\t\ttype = PIN_MAP_TYPE_CONFIGS_GROUP;\n\t\tsubnode_target_type = \"groups\";\n\t} else {\n\t\tif (type == PIN_MAP_TYPE_INVALID)\n\t\t\ttype = PIN_MAP_TYPE_CONFIGS_PIN;\n\t}\n\tstrings_count = ret;\n\n\tret = of_property_read_string(np, \"function\", &function);\n\tif (ret < 0) {\n\t\t \n\t\tif (ret != -EINVAL)\n\t\t\tdev_err(dev, \"%pOF: could not parse property function\\n\",\n\t\t\t\tnp);\n\t\tfunction = NULL;\n\t}\n\n\tret = pinconf_generic_parse_dt_config(np, pctldev, &configs,\n\t\t\t\t\t      &num_configs);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%pOF: could not parse node property\\n\", np);\n\t\treturn ret;\n\t}\n\n\treserve = 0;\n\tif (function != NULL)\n\t\treserve++;\n\tif (num_configs)\n\t\treserve++;\n\n\treserve *= strings_count;\n\n\tret = pinctrl_utils_reserve_map(pctldev, map, reserved_maps,\n\t\t\tnum_maps, reserve);\n\tif (ret < 0)\n\t\tgoto exit;\n\n\tof_property_for_each_string(np, subnode_target_type, prop, group) {\n\t\tif (function) {\n\t\t\tret = pinctrl_utils_add_map_mux(pctldev, map,\n\t\t\t\t\treserved_maps, num_maps, group,\n\t\t\t\t\tfunction);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto exit;\n\t\t}\n\n\t\tif (num_configs) {\n\t\t\tret = pinctrl_utils_add_map_configs(pctldev, map,\n\t\t\t\t\treserved_maps, num_maps, group, configs,\n\t\t\t\t\tnum_configs, type);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto exit;\n\t\t}\n\t}\n\tret = 0;\n\nexit:\n\tkfree(configs);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(pinconf_generic_dt_subnode_to_map);\n\nint pinconf_generic_dt_node_to_map(struct pinctrl_dev *pctldev,\n\t\tstruct device_node *np_config, struct pinctrl_map **map,\n\t\tunsigned *num_maps, enum pinctrl_map_type type)\n{\n\tunsigned reserved_maps;\n\tstruct device_node *np;\n\tint ret;\n\n\treserved_maps = 0;\n\t*map = NULL;\n\t*num_maps = 0;\n\n\tret = pinconf_generic_dt_subnode_to_map(pctldev, np_config, map,\n\t\t\t\t\t\t&reserved_maps, num_maps, type);\n\tif (ret < 0)\n\t\tgoto exit;\n\n\tfor_each_available_child_of_node(np_config, np) {\n\t\tret = pinconf_generic_dt_subnode_to_map(pctldev, np, map,\n\t\t\t\t\t&reserved_maps, num_maps, type);\n\t\tif (ret < 0) {\n\t\t\tof_node_put(np);\n\t\t\tgoto exit;\n\t\t}\n\t}\n\treturn 0;\n\nexit:\n\tpinctrl_utils_free_map(pctldev, *map, *num_maps);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(pinconf_generic_dt_node_to_map);\n\nvoid pinconf_generic_dt_free_map(struct pinctrl_dev *pctldev,\n\t\t\t\t struct pinctrl_map *map,\n\t\t\t\t unsigned num_maps)\n{\n\tpinctrl_utils_free_map(pctldev, map, num_maps);\n}\nEXPORT_SYMBOL_GPL(pinconf_generic_dt_free_map);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}