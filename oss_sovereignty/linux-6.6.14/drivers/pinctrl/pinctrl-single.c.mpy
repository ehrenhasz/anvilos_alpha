{
  "module_name": "pinctrl-single.c",
  "hash_id": "069952a0fc6e75f4a784a14a787d5cf37e8d5e11dde800191ef93fc7ac8bd4c6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/pinctrl-single.c",
  "human_readable_source": " \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/list.h>\n#include <linux/interrupt.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/seq_file.h>\n\n#include <linux/pinctrl/pinconf-generic.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinmux.h>\n\n#include <linux/platform_data/pinctrl-single.h>\n\n#include \"core.h\"\n#include \"devicetree.h\"\n#include \"pinconf.h\"\n#include \"pinmux.h\"\n\n#define DRIVER_NAME\t\t\t\"pinctrl-single\"\n#define PCS_OFF_DISABLED\t\t~0U\n\n \nstruct pcs_func_vals {\n\tvoid __iomem *reg;\n\tunsigned val;\n\tunsigned mask;\n};\n\n \nstruct pcs_conf_vals {\n\tenum pin_config_param param;\n\tunsigned val;\n\tunsigned enable;\n\tunsigned disable;\n\tunsigned mask;\n};\n\n \nstruct pcs_conf_type {\n\tconst char *name;\n\tenum pin_config_param param;\n};\n\n \nstruct pcs_function {\n\tconst char *name;\n\tstruct pcs_func_vals *vals;\n\tunsigned nvals;\n\tconst char **pgnames;\n\tint npgnames;\n\tstruct pcs_conf_vals *conf;\n\tint nconfs;\n\tstruct list_head node;\n};\n\n \nstruct pcs_gpiofunc_range {\n\tunsigned offset;\n\tunsigned npins;\n\tunsigned gpiofunc;\n\tstruct list_head node;\n};\n\n \nstruct pcs_data {\n\tstruct pinctrl_pin_desc *pa;\n\tint cur;\n};\n\n \nstruct pcs_soc_data {\n\tunsigned flags;\n\tint irq;\n\tunsigned irq_enable_mask;\n\tunsigned irq_status_mask;\n\tvoid (*rearm)(void);\n};\n\n \nstruct pcs_device {\n\tstruct resource *res;\n\tvoid __iomem *base;\n\tvoid *saved_vals;\n\tunsigned size;\n\tstruct device *dev;\n\tstruct device_node *np;\n\tstruct pinctrl_dev *pctl;\n\tunsigned flags;\n#define PCS_CONTEXT_LOSS_OFF\t(1 << 3)\n#define PCS_QUIRK_SHARED_IRQ\t(1 << 2)\n#define PCS_FEAT_IRQ\t\t(1 << 1)\n#define PCS_FEAT_PINCONF\t(1 << 0)\n\tstruct property *missing_nr_pinctrl_cells;\n\tstruct pcs_soc_data socdata;\n\traw_spinlock_t lock;\n\tstruct mutex mutex;\n\tunsigned width;\n\tunsigned fmask;\n\tunsigned fshift;\n\tunsigned foff;\n\tunsigned fmax;\n\tbool bits_per_mux;\n\tunsigned bits_per_pin;\n\tstruct pcs_data pins;\n\tstruct list_head gpiofuncs;\n\tstruct list_head irqs;\n\tstruct irq_chip chip;\n\tstruct irq_domain *domain;\n\tstruct pinctrl_desc desc;\n\tunsigned (*read)(void __iomem *reg);\n\tvoid (*write)(unsigned val, void __iomem *reg);\n};\n\n#define PCS_QUIRK_HAS_SHARED_IRQ\t(pcs->flags & PCS_QUIRK_SHARED_IRQ)\n#define PCS_HAS_IRQ\t\t(pcs->flags & PCS_FEAT_IRQ)\n#define PCS_HAS_PINCONF\t\t(pcs->flags & PCS_FEAT_PINCONF)\n\nstatic int pcs_pinconf_get(struct pinctrl_dev *pctldev, unsigned pin,\n\t\t\t   unsigned long *config);\nstatic int pcs_pinconf_set(struct pinctrl_dev *pctldev, unsigned pin,\n\t\t\t   unsigned long *configs, unsigned num_configs);\n\nstatic enum pin_config_param pcs_bias[] = {\n\tPIN_CONFIG_BIAS_PULL_DOWN,\n\tPIN_CONFIG_BIAS_PULL_UP,\n};\n\n \nstatic struct lock_class_key pcs_lock_class;\n\n \nstatic struct lock_class_key pcs_request_class;\n\n \n\nstatic unsigned __maybe_unused pcs_readb(void __iomem *reg)\n{\n\treturn readb(reg);\n}\n\nstatic unsigned __maybe_unused pcs_readw(void __iomem *reg)\n{\n\treturn readw(reg);\n}\n\nstatic unsigned __maybe_unused pcs_readl(void __iomem *reg)\n{\n\treturn readl(reg);\n}\n\nstatic void __maybe_unused pcs_writeb(unsigned val, void __iomem *reg)\n{\n\twriteb(val, reg);\n}\n\nstatic void __maybe_unused pcs_writew(unsigned val, void __iomem *reg)\n{\n\twritew(val, reg);\n}\n\nstatic void __maybe_unused pcs_writel(unsigned val, void __iomem *reg)\n{\n\twritel(val, reg);\n}\n\nstatic unsigned int pcs_pin_reg_offset_get(struct pcs_device *pcs,\n\t\t\t\t\t   unsigned int pin)\n{\n\tunsigned int mux_bytes = pcs->width / BITS_PER_BYTE;\n\n\tif (pcs->bits_per_mux) {\n\t\tunsigned int pin_offset_bytes;\n\n\t\tpin_offset_bytes = (pcs->bits_per_pin * pin) / BITS_PER_BYTE;\n\t\treturn (pin_offset_bytes / mux_bytes) * mux_bytes;\n\t}\n\n\treturn pin * mux_bytes;\n}\n\nstatic unsigned int pcs_pin_shift_reg_get(struct pcs_device *pcs,\n\t\t\t\t\t  unsigned int pin)\n{\n\treturn (pin % (pcs->width / pcs->bits_per_pin)) * pcs->bits_per_pin;\n}\n\nstatic void pcs_pin_dbg_show(struct pinctrl_dev *pctldev,\n\t\t\t\t\tstruct seq_file *s,\n\t\t\t\t\tunsigned pin)\n{\n\tstruct pcs_device *pcs;\n\tunsigned int val;\n\tunsigned long offset;\n\tsize_t pa;\n\n\tpcs = pinctrl_dev_get_drvdata(pctldev);\n\n\toffset = pcs_pin_reg_offset_get(pcs, pin);\n\tval = pcs->read(pcs->base + offset);\n\n\tif (pcs->bits_per_mux)\n\t\tval &= pcs->fmask << pcs_pin_shift_reg_get(pcs, pin);\n\n\tpa = pcs->res->start + offset;\n\n\tseq_printf(s, \"%zx %08x %s \", pa, val, DRIVER_NAME);\n}\n\nstatic void pcs_dt_free_map(struct pinctrl_dev *pctldev,\n\t\t\t\tstruct pinctrl_map *map, unsigned num_maps)\n{\n\tstruct pcs_device *pcs;\n\n\tpcs = pinctrl_dev_get_drvdata(pctldev);\n\tdevm_kfree(pcs->dev, map);\n}\n\nstatic int pcs_dt_node_to_map(struct pinctrl_dev *pctldev,\n\t\t\t\tstruct device_node *np_config,\n\t\t\t\tstruct pinctrl_map **map, unsigned *num_maps);\n\nstatic const struct pinctrl_ops pcs_pinctrl_ops = {\n\t.get_groups_count = pinctrl_generic_get_group_count,\n\t.get_group_name = pinctrl_generic_get_group_name,\n\t.get_group_pins = pinctrl_generic_get_group_pins,\n\t.pin_dbg_show = pcs_pin_dbg_show,\n\t.dt_node_to_map = pcs_dt_node_to_map,\n\t.dt_free_map = pcs_dt_free_map,\n};\n\nstatic int pcs_get_function(struct pinctrl_dev *pctldev, unsigned pin,\n\t\t\t    struct pcs_function **func)\n{\n\tstruct pcs_device *pcs = pinctrl_dev_get_drvdata(pctldev);\n\tstruct pin_desc *pdesc = pin_desc_get(pctldev, pin);\n\tconst struct pinctrl_setting_mux *setting;\n\tstruct function_desc *function;\n\tunsigned fselector;\n\n\t \n\tsetting = pdesc->mux_setting;\n\tif (!setting)\n\t\treturn -ENOTSUPP;\n\tfselector = setting->func;\n\tfunction = pinmux_generic_get_function(pctldev, fselector);\n\t*func = function->data;\n\tif (!(*func)) {\n\t\tdev_err(pcs->dev, \"%s could not find function%i\\n\",\n\t\t\t__func__, fselector);\n\t\treturn -ENOTSUPP;\n\t}\n\treturn 0;\n}\n\nstatic int pcs_set_mux(struct pinctrl_dev *pctldev, unsigned fselector,\n\tunsigned group)\n{\n\tstruct pcs_device *pcs;\n\tstruct function_desc *function;\n\tstruct pcs_function *func;\n\tint i;\n\n\tpcs = pinctrl_dev_get_drvdata(pctldev);\n\t \n\tif (!pcs->fmask)\n\t\treturn 0;\n\tfunction = pinmux_generic_get_function(pctldev, fselector);\n\tif (!function)\n\t\treturn -EINVAL;\n\tfunc = function->data;\n\tif (!func)\n\t\treturn -EINVAL;\n\n\tdev_dbg(pcs->dev, \"enabling %s function%i\\n\",\n\t\tfunc->name, fselector);\n\n\tfor (i = 0; i < func->nvals; i++) {\n\t\tstruct pcs_func_vals *vals;\n\t\tunsigned long flags;\n\t\tunsigned val, mask;\n\n\t\tvals = &func->vals[i];\n\t\traw_spin_lock_irqsave(&pcs->lock, flags);\n\t\tval = pcs->read(vals->reg);\n\n\t\tif (pcs->bits_per_mux)\n\t\t\tmask = vals->mask;\n\t\telse\n\t\t\tmask = pcs->fmask;\n\n\t\tval &= ~mask;\n\t\tval |= (vals->val & mask);\n\t\tpcs->write(val, vals->reg);\n\t\traw_spin_unlock_irqrestore(&pcs->lock, flags);\n\t}\n\n\treturn 0;\n}\n\nstatic int pcs_request_gpio(struct pinctrl_dev *pctldev,\n\t\t\t    struct pinctrl_gpio_range *range, unsigned pin)\n{\n\tstruct pcs_device *pcs = pinctrl_dev_get_drvdata(pctldev);\n\tstruct pcs_gpiofunc_range *frange = NULL;\n\tstruct list_head *pos, *tmp;\n\tunsigned data;\n\n\t \n\tif (!pcs->fmask)\n\t\treturn -ENOTSUPP;\n\n\tlist_for_each_safe(pos, tmp, &pcs->gpiofuncs) {\n\t\tu32 offset;\n\n\t\tfrange = list_entry(pos, struct pcs_gpiofunc_range, node);\n\t\tif (pin >= frange->offset + frange->npins\n\t\t\t|| pin < frange->offset)\n\t\t\tcontinue;\n\n\t\toffset = pcs_pin_reg_offset_get(pcs, pin);\n\n\t\tif (pcs->bits_per_mux) {\n\t\t\tint pin_shift = pcs_pin_shift_reg_get(pcs, pin);\n\n\t\t\tdata = pcs->read(pcs->base + offset);\n\t\t\tdata &= ~(pcs->fmask << pin_shift);\n\t\t\tdata |= frange->gpiofunc << pin_shift;\n\t\t\tpcs->write(data, pcs->base + offset);\n\t\t} else {\n\t\t\tdata = pcs->read(pcs->base + offset);\n\t\t\tdata &= ~pcs->fmask;\n\t\t\tdata |= frange->gpiofunc;\n\t\t\tpcs->write(data, pcs->base + offset);\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic const struct pinmux_ops pcs_pinmux_ops = {\n\t.get_functions_count = pinmux_generic_get_function_count,\n\t.get_function_name = pinmux_generic_get_function_name,\n\t.get_function_groups = pinmux_generic_get_function_groups,\n\t.set_mux = pcs_set_mux,\n\t.gpio_request_enable = pcs_request_gpio,\n};\n\n \nstatic void pcs_pinconf_clear_bias(struct pinctrl_dev *pctldev, unsigned pin)\n{\n\tunsigned long config;\n\tint i;\n\tfor (i = 0; i < ARRAY_SIZE(pcs_bias); i++) {\n\t\tconfig = pinconf_to_config_packed(pcs_bias[i], 0);\n\t\tpcs_pinconf_set(pctldev, pin, &config, 1);\n\t}\n}\n\n \nstatic bool pcs_pinconf_bias_disable(struct pinctrl_dev *pctldev, unsigned pin)\n{\n\tunsigned long config;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(pcs_bias); i++) {\n\t\tconfig = pinconf_to_config_packed(pcs_bias[i], 0);\n\t\tif (!pcs_pinconf_get(pctldev, pin, &config))\n\t\t\tgoto out;\n\t}\n\treturn true;\nout:\n\treturn false;\n}\n\nstatic int pcs_pinconf_get(struct pinctrl_dev *pctldev,\n\t\t\t\tunsigned pin, unsigned long *config)\n{\n\tstruct pcs_device *pcs = pinctrl_dev_get_drvdata(pctldev);\n\tstruct pcs_function *func;\n\tenum pin_config_param param;\n\tunsigned offset = 0, data = 0, i, j, ret;\n\n\tret = pcs_get_function(pctldev, pin, &func);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < func->nconfs; i++) {\n\t\tparam = pinconf_to_config_param(*config);\n\t\tif (param == PIN_CONFIG_BIAS_DISABLE) {\n\t\t\tif (pcs_pinconf_bias_disable(pctldev, pin)) {\n\t\t\t\t*config = 0;\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn -ENOTSUPP;\n\t\t\t}\n\t\t} else if (param != func->conf[i].param) {\n\t\t\tcontinue;\n\t\t}\n\n\t\toffset = pin * (pcs->width / BITS_PER_BYTE);\n\t\tdata = pcs->read(pcs->base + offset) & func->conf[i].mask;\n\t\tswitch (func->conf[i].param) {\n\t\t \n\t\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\tcase PIN_CONFIG_INPUT_SCHMITT_ENABLE:\n\t\t\tif ((data != func->conf[i].enable) ||\n\t\t\t    (data == func->conf[i].disable))\n\t\t\t\treturn -ENOTSUPP;\n\t\t\t*config = 0;\n\t\t\tbreak;\n\t\t \n\t\tcase PIN_CONFIG_INPUT_SCHMITT:\n\t\t\tfor (j = 0; j < func->nconfs; j++) {\n\t\t\t\tswitch (func->conf[j].param) {\n\t\t\t\tcase PIN_CONFIG_INPUT_SCHMITT_ENABLE:\n\t\t\t\t\tif (data != func->conf[j].enable)\n\t\t\t\t\t\treturn -ENOTSUPP;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t*config = data;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_DRIVE_STRENGTH:\n\t\tcase PIN_CONFIG_SLEW_RATE:\n\t\tcase PIN_CONFIG_MODE_LOW_POWER:\n\t\tcase PIN_CONFIG_INPUT_ENABLE:\n\t\tdefault:\n\t\t\t*config = data;\n\t\t\tbreak;\n\t\t}\n\t\treturn 0;\n\t}\n\treturn -ENOTSUPP;\n}\n\nstatic int pcs_pinconf_set(struct pinctrl_dev *pctldev,\n\t\t\t\tunsigned pin, unsigned long *configs,\n\t\t\t\tunsigned num_configs)\n{\n\tstruct pcs_device *pcs = pinctrl_dev_get_drvdata(pctldev);\n\tstruct pcs_function *func;\n\tunsigned offset = 0, shift = 0, i, data, ret;\n\tu32 arg;\n\tint j;\n\n\tret = pcs_get_function(pctldev, pin, &func);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (j = 0; j < num_configs; j++) {\n\t\tfor (i = 0; i < func->nconfs; i++) {\n\t\t\tif (pinconf_to_config_param(configs[j])\n\t\t\t\t!= func->conf[i].param)\n\t\t\t\tcontinue;\n\n\t\t\toffset = pin * (pcs->width / BITS_PER_BYTE);\n\t\t\tdata = pcs->read(pcs->base + offset);\n\t\t\targ = pinconf_to_config_argument(configs[j]);\n\t\t\tswitch (func->conf[i].param) {\n\t\t\t \n\t\t\tcase PIN_CONFIG_INPUT_SCHMITT:\n\t\t\tcase PIN_CONFIG_DRIVE_STRENGTH:\n\t\t\tcase PIN_CONFIG_SLEW_RATE:\n\t\t\tcase PIN_CONFIG_MODE_LOW_POWER:\n\t\t\tcase PIN_CONFIG_INPUT_ENABLE:\n\t\t\t\tshift = ffs(func->conf[i].mask) - 1;\n\t\t\t\tdata &= ~func->conf[i].mask;\n\t\t\t\tdata |= (arg << shift) & func->conf[i].mask;\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\t\t\tpcs_pinconf_clear_bias(pctldev, pin);\n\t\t\t\tbreak;\n\t\t\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\t\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\t\t\tif (arg)\n\t\t\t\t\tpcs_pinconf_clear_bias(pctldev, pin);\n\t\t\t\tfallthrough;\n\t\t\tcase PIN_CONFIG_INPUT_SCHMITT_ENABLE:\n\t\t\t\tdata &= ~func->conf[i].mask;\n\t\t\t\tif (arg)\n\t\t\t\t\tdata |= func->conf[i].enable;\n\t\t\t\telse\n\t\t\t\t\tdata |= func->conf[i].disable;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -ENOTSUPP;\n\t\t\t}\n\t\t\tpcs->write(data, pcs->base + offset);\n\n\t\t\tbreak;\n\t\t}\n\t\tif (i >= func->nconfs)\n\t\t\treturn -ENOTSUPP;\n\t}  \n\n\treturn 0;\n}\n\nstatic int pcs_pinconf_group_get(struct pinctrl_dev *pctldev,\n\t\t\t\tunsigned group, unsigned long *config)\n{\n\tconst unsigned *pins;\n\tunsigned npins, old = 0;\n\tint i, ret;\n\n\tret = pinctrl_generic_get_group_pins(pctldev, group, &pins, &npins);\n\tif (ret)\n\t\treturn ret;\n\tfor (i = 0; i < npins; i++) {\n\t\tif (pcs_pinconf_get(pctldev, pins[i], config))\n\t\t\treturn -ENOTSUPP;\n\t\t \n\t\tif (i && (old != *config))\n\t\t\treturn -ENOTSUPP;\n\t\told = *config;\n\t}\n\treturn 0;\n}\n\nstatic int pcs_pinconf_group_set(struct pinctrl_dev *pctldev,\n\t\t\t\tunsigned group, unsigned long *configs,\n\t\t\t\tunsigned num_configs)\n{\n\tconst unsigned *pins;\n\tunsigned npins;\n\tint i, ret;\n\n\tret = pinctrl_generic_get_group_pins(pctldev, group, &pins, &npins);\n\tif (ret)\n\t\treturn ret;\n\tfor (i = 0; i < npins; i++) {\n\t\tif (pcs_pinconf_set(pctldev, pins[i], configs, num_configs))\n\t\t\treturn -ENOTSUPP;\n\t}\n\treturn 0;\n}\n\nstatic void pcs_pinconf_dbg_show(struct pinctrl_dev *pctldev,\n\t\t\t\tstruct seq_file *s, unsigned pin)\n{\n}\n\nstatic void pcs_pinconf_group_dbg_show(struct pinctrl_dev *pctldev,\n\t\t\t\tstruct seq_file *s, unsigned selector)\n{\n}\n\nstatic void pcs_pinconf_config_dbg_show(struct pinctrl_dev *pctldev,\n\t\t\t\t\tstruct seq_file *s,\n\t\t\t\t\tunsigned long config)\n{\n\tpinconf_generic_dump_config(pctldev, s, config);\n}\n\nstatic const struct pinconf_ops pcs_pinconf_ops = {\n\t.pin_config_get = pcs_pinconf_get,\n\t.pin_config_set = pcs_pinconf_set,\n\t.pin_config_group_get = pcs_pinconf_group_get,\n\t.pin_config_group_set = pcs_pinconf_group_set,\n\t.pin_config_dbg_show = pcs_pinconf_dbg_show,\n\t.pin_config_group_dbg_show = pcs_pinconf_group_dbg_show,\n\t.pin_config_config_dbg_show = pcs_pinconf_config_dbg_show,\n\t.is_generic = true,\n};\n\n \nstatic int pcs_add_pin(struct pcs_device *pcs, unsigned int offset)\n{\n\tstruct pcs_soc_data *pcs_soc = &pcs->socdata;\n\tstruct pinctrl_pin_desc *pin;\n\tint i;\n\n\ti = pcs->pins.cur;\n\tif (i >= pcs->desc.npins) {\n\t\tdev_err(pcs->dev, \"too many pins, max %i\\n\",\n\t\t\tpcs->desc.npins);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (pcs_soc->irq_enable_mask) {\n\t\tunsigned val;\n\n\t\tval = pcs->read(pcs->base + offset);\n\t\tif (val & pcs_soc->irq_enable_mask) {\n\t\t\tdev_dbg(pcs->dev, \"irq enabled at boot for pin at %lx (%x), clearing\\n\",\n\t\t\t\t(unsigned long)pcs->res->start + offset, val);\n\t\t\tval &= ~pcs_soc->irq_enable_mask;\n\t\t\tpcs->write(val, pcs->base + offset);\n\t\t}\n\t}\n\n\tpin = &pcs->pins.pa[i];\n\tpin->number = i;\n\tpcs->pins.cur++;\n\n\treturn i;\n}\n\n \nstatic int pcs_allocate_pin_table(struct pcs_device *pcs)\n{\n\tint mux_bytes, nr_pins, i;\n\n\tmux_bytes = pcs->width / BITS_PER_BYTE;\n\n\tif (pcs->bits_per_mux && pcs->fmask) {\n\t\tpcs->bits_per_pin = fls(pcs->fmask);\n\t\tnr_pins = (pcs->size * BITS_PER_BYTE) / pcs->bits_per_pin;\n\t} else {\n\t\tnr_pins = pcs->size / mux_bytes;\n\t}\n\n\tdev_dbg(pcs->dev, \"allocating %i pins\\n\", nr_pins);\n\tpcs->pins.pa = devm_kcalloc(pcs->dev,\n\t\t\t\tnr_pins, sizeof(*pcs->pins.pa),\n\t\t\t\tGFP_KERNEL);\n\tif (!pcs->pins.pa)\n\t\treturn -ENOMEM;\n\n\tpcs->desc.pins = pcs->pins.pa;\n\tpcs->desc.npins = nr_pins;\n\n\tfor (i = 0; i < pcs->desc.npins; i++) {\n\t\tunsigned offset;\n\t\tint res;\n\n\t\toffset = pcs_pin_reg_offset_get(pcs, i);\n\t\tres = pcs_add_pin(pcs, offset);\n\t\tif (res < 0) {\n\t\t\tdev_err(pcs->dev, \"error adding pins: %i\\n\", res);\n\t\t\treturn res;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int pcs_add_function(struct pcs_device *pcs,\n\t\t\t    struct pcs_function **fcn,\n\t\t\t    const char *name,\n\t\t\t    struct pcs_func_vals *vals,\n\t\t\t    unsigned int nvals,\n\t\t\t    const char **pgnames,\n\t\t\t    unsigned int npgnames)\n{\n\tstruct pcs_function *function;\n\tint selector;\n\n\tfunction = devm_kzalloc(pcs->dev, sizeof(*function), GFP_KERNEL);\n\tif (!function)\n\t\treturn -ENOMEM;\n\n\tfunction->vals = vals;\n\tfunction->nvals = nvals;\n\tfunction->name = name;\n\n\tselector = pinmux_generic_add_function(pcs->pctl, name,\n\t\t\t\t\t       pgnames, npgnames,\n\t\t\t\t\t       function);\n\tif (selector < 0) {\n\t\tdevm_kfree(pcs->dev, function);\n\t\t*fcn = NULL;\n\t} else {\n\t\t*fcn = function;\n\t}\n\n\treturn selector;\n}\n\n \nstatic int pcs_get_pin_by_offset(struct pcs_device *pcs, unsigned offset)\n{\n\tunsigned index;\n\n\tif (offset >= pcs->size) {\n\t\tdev_err(pcs->dev, \"mux offset out of range: 0x%x (0x%x)\\n\",\n\t\t\toffset, pcs->size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (pcs->bits_per_mux)\n\t\tindex = (offset * BITS_PER_BYTE) / pcs->bits_per_pin;\n\telse\n\t\tindex = offset / (pcs->width / BITS_PER_BYTE);\n\n\treturn index;\n}\n\n \nstatic int pcs_config_match(unsigned data, unsigned enable, unsigned disable)\n{\n\tint ret = -EINVAL;\n\n\tif (data == enable)\n\t\tret = 1;\n\telse if (data == disable)\n\t\tret = 0;\n\treturn ret;\n}\n\nstatic void add_config(struct pcs_conf_vals **conf, enum pin_config_param param,\n\t\t       unsigned value, unsigned enable, unsigned disable,\n\t\t       unsigned mask)\n{\n\t(*conf)->param = param;\n\t(*conf)->val = value;\n\t(*conf)->enable = enable;\n\t(*conf)->disable = disable;\n\t(*conf)->mask = mask;\n\t(*conf)++;\n}\n\nstatic void add_setting(unsigned long **setting, enum pin_config_param param,\n\t\t\tunsigned arg)\n{\n\t**setting = pinconf_to_config_packed(param, arg);\n\t(*setting)++;\n}\n\n \nstatic void pcs_add_conf2(struct pcs_device *pcs, struct device_node *np,\n\t\t\t  const char *name, enum pin_config_param param,\n\t\t\t  struct pcs_conf_vals **conf, unsigned long **settings)\n{\n\tunsigned value[2], shift;\n\tint ret;\n\n\tret = of_property_read_u32_array(np, name, value, 2);\n\tif (ret)\n\t\treturn;\n\t \n\tvalue[0] &= value[1];\n\tshift = ffs(value[1]) - 1;\n\t \n\tadd_config(conf, param, value[0], 0, 0, value[1]);\n\tadd_setting(settings, param, value[0] >> shift);\n}\n\n \nstatic void pcs_add_conf4(struct pcs_device *pcs, struct device_node *np,\n\t\t\t  const char *name, enum pin_config_param param,\n\t\t\t  struct pcs_conf_vals **conf, unsigned long **settings)\n{\n\tunsigned value[4];\n\tint ret;\n\n\t \n\tret = of_property_read_u32_array(np, name, value, 4);\n\tif (ret)\n\t\treturn;\n\tif (!value[3]) {\n\t\tdev_err(pcs->dev, \"mask field of the property can't be 0\\n\");\n\t\treturn;\n\t}\n\tvalue[0] &= value[3];\n\tvalue[1] &= value[3];\n\tvalue[2] &= value[3];\n\tret = pcs_config_match(value[0], value[1], value[2]);\n\tif (ret < 0)\n\t\tdev_dbg(pcs->dev, \"failed to match enable or disable bits\\n\");\n\tadd_config(conf, param, value[0], value[1], value[2], value[3]);\n\tadd_setting(settings, param, ret);\n}\n\nstatic int pcs_parse_pinconf(struct pcs_device *pcs, struct device_node *np,\n\t\t\t     struct pcs_function *func,\n\t\t\t     struct pinctrl_map **map)\n\n{\n\tstruct pinctrl_map *m = *map;\n\tint i = 0, nconfs = 0;\n\tunsigned long *settings = NULL, *s = NULL;\n\tstruct pcs_conf_vals *conf = NULL;\n\tstatic const struct pcs_conf_type prop2[] = {\n\t\t{ \"pinctrl-single,drive-strength\", PIN_CONFIG_DRIVE_STRENGTH, },\n\t\t{ \"pinctrl-single,slew-rate\", PIN_CONFIG_SLEW_RATE, },\n\t\t{ \"pinctrl-single,input-enable\", PIN_CONFIG_INPUT_ENABLE, },\n\t\t{ \"pinctrl-single,input-schmitt\", PIN_CONFIG_INPUT_SCHMITT, },\n\t\t{ \"pinctrl-single,low-power-mode\", PIN_CONFIG_MODE_LOW_POWER, },\n\t};\n\tstatic const struct pcs_conf_type prop4[] = {\n\t\t{ \"pinctrl-single,bias-pullup\", PIN_CONFIG_BIAS_PULL_UP, },\n\t\t{ \"pinctrl-single,bias-pulldown\", PIN_CONFIG_BIAS_PULL_DOWN, },\n\t\t{ \"pinctrl-single,input-schmitt-enable\",\n\t\t\tPIN_CONFIG_INPUT_SCHMITT_ENABLE, },\n\t};\n\n\t \n\tif (!PCS_HAS_PINCONF)\n\t\treturn -ENOTSUPP;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(prop2); i++) {\n\t\tif (of_property_present(np, prop2[i].name))\n\t\t\tnconfs++;\n\t}\n\tfor (i = 0; i < ARRAY_SIZE(prop4); i++) {\n\t\tif (of_property_present(np, prop4[i].name))\n\t\t\tnconfs++;\n\t}\n\tif (!nconfs)\n\t\treturn -ENOTSUPP;\n\n\tfunc->conf = devm_kcalloc(pcs->dev,\n\t\t\t\t  nconfs, sizeof(struct pcs_conf_vals),\n\t\t\t\t  GFP_KERNEL);\n\tif (!func->conf)\n\t\treturn -ENOMEM;\n\tfunc->nconfs = nconfs;\n\tconf = &(func->conf[0]);\n\tm++;\n\tsettings = devm_kcalloc(pcs->dev, nconfs, sizeof(unsigned long),\n\t\t\t\tGFP_KERNEL);\n\tif (!settings)\n\t\treturn -ENOMEM;\n\ts = &settings[0];\n\n\tfor (i = 0; i < ARRAY_SIZE(prop2); i++)\n\t\tpcs_add_conf2(pcs, np, prop2[i].name, prop2[i].param,\n\t\t\t      &conf, &s);\n\tfor (i = 0; i < ARRAY_SIZE(prop4); i++)\n\t\tpcs_add_conf4(pcs, np, prop4[i].name, prop4[i].param,\n\t\t\t      &conf, &s);\n\tm->type = PIN_MAP_TYPE_CONFIGS_GROUP;\n\tm->data.configs.group_or_pin = np->name;\n\tm->data.configs.configs = settings;\n\tm->data.configs.num_configs = nconfs;\n\treturn 0;\n}\n\n \nstatic int pcs_parse_one_pinctrl_entry(struct pcs_device *pcs,\n\t\t\t\t\t\tstruct device_node *np,\n\t\t\t\t\t\tstruct pinctrl_map **map,\n\t\t\t\t\t\tunsigned *num_maps,\n\t\t\t\t\t\tconst char **pgnames)\n{\n\tconst char *name = \"pinctrl-single,pins\";\n\tstruct pcs_func_vals *vals;\n\tint rows, *pins, found = 0, res = -ENOMEM, i, fsel, gsel;\n\tstruct pcs_function *function = NULL;\n\n\trows = pinctrl_count_index_with_args(np, name);\n\tif (rows <= 0) {\n\t\tdev_err(pcs->dev, \"Invalid number of rows: %d\\n\", rows);\n\t\treturn -EINVAL;\n\t}\n\n\tvals = devm_kcalloc(pcs->dev, rows, sizeof(*vals), GFP_KERNEL);\n\tif (!vals)\n\t\treturn -ENOMEM;\n\n\tpins = devm_kcalloc(pcs->dev, rows, sizeof(*pins), GFP_KERNEL);\n\tif (!pins)\n\t\tgoto free_vals;\n\n\tfor (i = 0; i < rows; i++) {\n\t\tstruct of_phandle_args pinctrl_spec;\n\t\tunsigned int offset;\n\t\tint pin;\n\n\t\tres = pinctrl_parse_index_with_args(np, name, i, &pinctrl_spec);\n\t\tif (res)\n\t\t\treturn res;\n\n\t\tif (pinctrl_spec.args_count < 2 || pinctrl_spec.args_count > 3) {\n\t\t\tdev_err(pcs->dev, \"invalid args_count for spec: %i\\n\",\n\t\t\t\tpinctrl_spec.args_count);\n\t\t\tbreak;\n\t\t}\n\n\t\toffset = pinctrl_spec.args[0];\n\t\tvals[found].reg = pcs->base + offset;\n\n\t\tswitch (pinctrl_spec.args_count) {\n\t\tcase 2:\n\t\t\tvals[found].val = pinctrl_spec.args[1];\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tvals[found].val = (pinctrl_spec.args[1] | pinctrl_spec.args[2]);\n\t\t\tbreak;\n\t\t}\n\n\t\tdev_dbg(pcs->dev, \"%pOFn index: 0x%x value: 0x%x\\n\",\n\t\t\tpinctrl_spec.np, offset, vals[found].val);\n\n\t\tpin = pcs_get_pin_by_offset(pcs, offset);\n\t\tif (pin < 0) {\n\t\t\tdev_err(pcs->dev,\n\t\t\t\t\"could not add functions for %pOFn %ux\\n\",\n\t\t\t\tnp, offset);\n\t\t\tbreak;\n\t\t}\n\t\tpins[found++] = pin;\n\t}\n\n\tpgnames[0] = np->name;\n\tmutex_lock(&pcs->mutex);\n\tfsel = pcs_add_function(pcs, &function, np->name, vals, found,\n\t\t\t\tpgnames, 1);\n\tif (fsel < 0) {\n\t\tres = fsel;\n\t\tgoto free_pins;\n\t}\n\n\tgsel = pinctrl_generic_add_group(pcs->pctl, np->name, pins, found, pcs);\n\tif (gsel < 0) {\n\t\tres = gsel;\n\t\tgoto free_function;\n\t}\n\n\t(*map)->type = PIN_MAP_TYPE_MUX_GROUP;\n\t(*map)->data.mux.group = np->name;\n\t(*map)->data.mux.function = np->name;\n\n\tif (PCS_HAS_PINCONF && function) {\n\t\tres = pcs_parse_pinconf(pcs, np, function, map);\n\t\tif (res == 0)\n\t\t\t*num_maps = 2;\n\t\telse if (res == -ENOTSUPP)\n\t\t\t*num_maps = 1;\n\t\telse\n\t\t\tgoto free_pingroups;\n\t} else {\n\t\t*num_maps = 1;\n\t}\n\tmutex_unlock(&pcs->mutex);\n\n\treturn 0;\n\nfree_pingroups:\n\tpinctrl_generic_remove_group(pcs->pctl, gsel);\n\t*num_maps = 1;\nfree_function:\n\tpinmux_generic_remove_function(pcs->pctl, fsel);\nfree_pins:\n\tmutex_unlock(&pcs->mutex);\n\tdevm_kfree(pcs->dev, pins);\n\nfree_vals:\n\tdevm_kfree(pcs->dev, vals);\n\n\treturn res;\n}\n\nstatic int pcs_parse_bits_in_pinctrl_entry(struct pcs_device *pcs,\n\t\t\t\t\t\tstruct device_node *np,\n\t\t\t\t\t\tstruct pinctrl_map **map,\n\t\t\t\t\t\tunsigned *num_maps,\n\t\t\t\t\t\tconst char **pgnames)\n{\n\tconst char *name = \"pinctrl-single,bits\";\n\tstruct pcs_func_vals *vals;\n\tint rows, *pins, found = 0, res = -ENOMEM, i, fsel;\n\tint npins_in_row;\n\tstruct pcs_function *function = NULL;\n\n\trows = pinctrl_count_index_with_args(np, name);\n\tif (rows <= 0) {\n\t\tdev_err(pcs->dev, \"Invalid number of rows: %d\\n\", rows);\n\t\treturn -EINVAL;\n\t}\n\n\tif (PCS_HAS_PINCONF) {\n\t\tdev_err(pcs->dev, \"pinconf not supported\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tnpins_in_row = pcs->width / pcs->bits_per_pin;\n\n\tvals = devm_kzalloc(pcs->dev,\n\t\t\t    array3_size(rows, npins_in_row, sizeof(*vals)),\n\t\t\t    GFP_KERNEL);\n\tif (!vals)\n\t\treturn -ENOMEM;\n\n\tpins = devm_kzalloc(pcs->dev,\n\t\t\t    array3_size(rows, npins_in_row, sizeof(*pins)),\n\t\t\t    GFP_KERNEL);\n\tif (!pins)\n\t\tgoto free_vals;\n\n\tfor (i = 0; i < rows; i++) {\n\t\tstruct of_phandle_args pinctrl_spec;\n\t\tunsigned offset, val;\n\t\tunsigned mask, bit_pos, val_pos, mask_pos, submask;\n\t\tunsigned pin_num_from_lsb;\n\t\tint pin;\n\n\t\tres = pinctrl_parse_index_with_args(np, name, i, &pinctrl_spec);\n\t\tif (res)\n\t\t\treturn res;\n\n\t\tif (pinctrl_spec.args_count < 3) {\n\t\t\tdev_err(pcs->dev, \"invalid args_count for spec: %i\\n\",\n\t\t\t\tpinctrl_spec.args_count);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\toffset = pinctrl_spec.args[0];\n\t\tval = pinctrl_spec.args[1];\n\t\tmask = pinctrl_spec.args[2];\n\n\t\tdev_dbg(pcs->dev, \"%pOFn index: 0x%x value: 0x%x mask: 0x%x\\n\",\n\t\t\tpinctrl_spec.np, offset, val, mask);\n\n\t\t \n\t\twhile (mask) {\n\t\t\tbit_pos = __ffs(mask);\n\t\t\tpin_num_from_lsb = bit_pos / pcs->bits_per_pin;\n\t\t\tmask_pos = ((pcs->fmask) << bit_pos);\n\t\t\tval_pos = val & mask_pos;\n\t\t\tsubmask = mask & mask_pos;\n\n\t\t\tif ((mask & mask_pos) == 0) {\n\t\t\t\tdev_err(pcs->dev,\n\t\t\t\t\t\"Invalid mask for %pOFn at 0x%x\\n\",\n\t\t\t\t\tnp, offset);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmask &= ~mask_pos;\n\n\t\t\tif (submask != mask_pos) {\n\t\t\t\tdev_warn(pcs->dev,\n\t\t\t\t\t\t\"Invalid submask 0x%x for %pOFn at 0x%x\\n\",\n\t\t\t\t\t\tsubmask, np, offset);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvals[found].mask = submask;\n\t\t\tvals[found].reg = pcs->base + offset;\n\t\t\tvals[found].val = val_pos;\n\n\t\t\tpin = pcs_get_pin_by_offset(pcs, offset);\n\t\t\tif (pin < 0) {\n\t\t\t\tdev_err(pcs->dev,\n\t\t\t\t\t\"could not add functions for %pOFn %ux\\n\",\n\t\t\t\t\tnp, offset);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpins[found++] = pin + pin_num_from_lsb;\n\t\t}\n\t}\n\n\tpgnames[0] = np->name;\n\tmutex_lock(&pcs->mutex);\n\tfsel = pcs_add_function(pcs, &function, np->name, vals, found,\n\t\t\t\tpgnames, 1);\n\tif (fsel < 0) {\n\t\tres = fsel;\n\t\tgoto free_pins;\n\t}\n\n\tres = pinctrl_generic_add_group(pcs->pctl, np->name, pins, found, pcs);\n\tif (res < 0)\n\t\tgoto free_function;\n\n\t(*map)->type = PIN_MAP_TYPE_MUX_GROUP;\n\t(*map)->data.mux.group = np->name;\n\t(*map)->data.mux.function = np->name;\n\n\t*num_maps = 1;\n\tmutex_unlock(&pcs->mutex);\n\n\treturn 0;\n\nfree_function:\n\tpinmux_generic_remove_function(pcs->pctl, fsel);\nfree_pins:\n\tmutex_unlock(&pcs->mutex);\n\tdevm_kfree(pcs->dev, pins);\n\nfree_vals:\n\tdevm_kfree(pcs->dev, vals);\n\n\treturn res;\n}\n \nstatic int pcs_dt_node_to_map(struct pinctrl_dev *pctldev,\n\t\t\t\tstruct device_node *np_config,\n\t\t\t\tstruct pinctrl_map **map, unsigned *num_maps)\n{\n\tstruct pcs_device *pcs;\n\tconst char **pgnames;\n\tint ret;\n\n\tpcs = pinctrl_dev_get_drvdata(pctldev);\n\n\t \n\t*map = devm_kcalloc(pcs->dev, 2, sizeof(**map), GFP_KERNEL);\n\tif (!*map)\n\t\treturn -ENOMEM;\n\n\t*num_maps = 0;\n\n\tpgnames = devm_kzalloc(pcs->dev, sizeof(*pgnames), GFP_KERNEL);\n\tif (!pgnames) {\n\t\tret = -ENOMEM;\n\t\tgoto free_map;\n\t}\n\n\tif (pcs->bits_per_mux) {\n\t\tret = pcs_parse_bits_in_pinctrl_entry(pcs, np_config, map,\n\t\t\t\tnum_maps, pgnames);\n\t\tif (ret < 0) {\n\t\t\tdev_err(pcs->dev, \"no pins entries for %pOFn\\n\",\n\t\t\t\tnp_config);\n\t\t\tgoto free_pgnames;\n\t\t}\n\t} else {\n\t\tret = pcs_parse_one_pinctrl_entry(pcs, np_config, map,\n\t\t\t\tnum_maps, pgnames);\n\t\tif (ret < 0) {\n\t\t\tdev_err(pcs->dev, \"no pins entries for %pOFn\\n\",\n\t\t\t\tnp_config);\n\t\t\tgoto free_pgnames;\n\t\t}\n\t}\n\n\treturn 0;\n\nfree_pgnames:\n\tdevm_kfree(pcs->dev, pgnames);\nfree_map:\n\tdevm_kfree(pcs->dev, *map);\n\n\treturn ret;\n}\n\n \nstatic void pcs_irq_free(struct pcs_device *pcs)\n{\n\tstruct pcs_soc_data *pcs_soc = &pcs->socdata;\n\n\tif (pcs_soc->irq < 0)\n\t\treturn;\n\n\tif (pcs->domain)\n\t\tirq_domain_remove(pcs->domain);\n\n\tif (PCS_QUIRK_HAS_SHARED_IRQ)\n\t\tfree_irq(pcs_soc->irq, pcs_soc);\n\telse\n\t\tirq_set_chained_handler(pcs_soc->irq, NULL);\n}\n\n \nstatic void pcs_free_resources(struct pcs_device *pcs)\n{\n\tpcs_irq_free(pcs);\n\tpinctrl_unregister(pcs->pctl);\n\n#if IS_BUILTIN(CONFIG_PINCTRL_SINGLE)\n\tif (pcs->missing_nr_pinctrl_cells)\n\t\tof_remove_property(pcs->np, pcs->missing_nr_pinctrl_cells);\n#endif\n}\n\nstatic int pcs_add_gpio_func(struct device_node *node, struct pcs_device *pcs)\n{\n\tconst char *propname = \"pinctrl-single,gpio-range\";\n\tconst char *cellname = \"#pinctrl-single,gpio-range-cells\";\n\tstruct of_phandle_args gpiospec;\n\tstruct pcs_gpiofunc_range *range;\n\tint ret, i;\n\n\tfor (i = 0; ; i++) {\n\t\tret = of_parse_phandle_with_args(node, propname, cellname,\n\t\t\t\t\t\t i, &gpiospec);\n\t\t \n\t\tif (ret) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\trange = devm_kzalloc(pcs->dev, sizeof(*range), GFP_KERNEL);\n\t\tif (!range) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\trange->offset = gpiospec.args[0];\n\t\trange->npins = gpiospec.args[1];\n\t\trange->gpiofunc = gpiospec.args[2];\n\t\tmutex_lock(&pcs->mutex);\n\t\tlist_add_tail(&range->node, &pcs->gpiofuncs);\n\t\tmutex_unlock(&pcs->mutex);\n\t}\n\treturn ret;\n}\n\n \nstruct pcs_interrupt {\n\tvoid __iomem *reg;\n\tirq_hw_number_t hwirq;\n\tunsigned int irq;\n\tstruct list_head node;\n};\n\n \nstatic inline void pcs_irq_set(struct pcs_soc_data *pcs_soc,\n\t\t\t       int irq, const bool enable)\n{\n\tstruct pcs_device *pcs;\n\tstruct list_head *pos;\n\tunsigned mask;\n\n\tpcs = container_of(pcs_soc, struct pcs_device, socdata);\n\tlist_for_each(pos, &pcs->irqs) {\n\t\tstruct pcs_interrupt *pcswi;\n\t\tunsigned soc_mask;\n\n\t\tpcswi = list_entry(pos, struct pcs_interrupt, node);\n\t\tif (irq != pcswi->irq)\n\t\t\tcontinue;\n\n\t\tsoc_mask = pcs_soc->irq_enable_mask;\n\t\traw_spin_lock(&pcs->lock);\n\t\tmask = pcs->read(pcswi->reg);\n\t\tif (enable)\n\t\t\tmask |= soc_mask;\n\t\telse\n\t\t\tmask &= ~soc_mask;\n\t\tpcs->write(mask, pcswi->reg);\n\n\t\t \n\t\tmask = pcs->read(pcswi->reg);\n\t\traw_spin_unlock(&pcs->lock);\n\t}\n\n\tif (pcs_soc->rearm)\n\t\tpcs_soc->rearm();\n}\n\n \nstatic void pcs_irq_mask(struct irq_data *d)\n{\n\tstruct pcs_soc_data *pcs_soc = irq_data_get_irq_chip_data(d);\n\n\tpcs_irq_set(pcs_soc, d->irq, false);\n}\n\n \nstatic void pcs_irq_unmask(struct irq_data *d)\n{\n\tstruct pcs_soc_data *pcs_soc = irq_data_get_irq_chip_data(d);\n\n\tpcs_irq_set(pcs_soc, d->irq, true);\n}\n\n \nstatic int pcs_irq_set_wake(struct irq_data *d, unsigned int state)\n{\n\tif (state)\n\t\tpcs_irq_unmask(d);\n\telse\n\t\tpcs_irq_mask(d);\n\n\treturn 0;\n}\n\n \nstatic int pcs_irq_handle(struct pcs_soc_data *pcs_soc)\n{\n\tstruct pcs_device *pcs;\n\tstruct list_head *pos;\n\tint count = 0;\n\n\tpcs = container_of(pcs_soc, struct pcs_device, socdata);\n\tlist_for_each(pos, &pcs->irqs) {\n\t\tstruct pcs_interrupt *pcswi;\n\t\tunsigned mask;\n\n\t\tpcswi = list_entry(pos, struct pcs_interrupt, node);\n\t\traw_spin_lock(&pcs->lock);\n\t\tmask = pcs->read(pcswi->reg);\n\t\traw_spin_unlock(&pcs->lock);\n\t\tif (mask & pcs_soc->irq_status_mask) {\n\t\t\tgeneric_handle_domain_irq(pcs->domain,\n\t\t\t\t\t\t  pcswi->hwirq);\n\t\t\tcount++;\n\t\t}\n\t}\n\n\treturn count;\n}\n\n \nstatic irqreturn_t pcs_irq_handler(int irq, void *d)\n{\n\tstruct pcs_soc_data *pcs_soc = d;\n\n\treturn pcs_irq_handle(pcs_soc) ? IRQ_HANDLED : IRQ_NONE;\n}\n\n \nstatic void pcs_irq_chain_handler(struct irq_desc *desc)\n{\n\tstruct pcs_soc_data *pcs_soc = irq_desc_get_handler_data(desc);\n\tstruct irq_chip *chip;\n\n\tchip = irq_desc_get_chip(desc);\n\tchained_irq_enter(chip, desc);\n\tpcs_irq_handle(pcs_soc);\n\t \n\tchained_irq_exit(chip, desc);\n}\n\nstatic int pcs_irqdomain_map(struct irq_domain *d, unsigned int irq,\n\t\t\t     irq_hw_number_t hwirq)\n{\n\tstruct pcs_soc_data *pcs_soc = d->host_data;\n\tstruct pcs_device *pcs;\n\tstruct pcs_interrupt *pcswi;\n\n\tpcs = container_of(pcs_soc, struct pcs_device, socdata);\n\tpcswi = devm_kzalloc(pcs->dev, sizeof(*pcswi), GFP_KERNEL);\n\tif (!pcswi)\n\t\treturn -ENOMEM;\n\n\tpcswi->reg = pcs->base + hwirq;\n\tpcswi->hwirq = hwirq;\n\tpcswi->irq = irq;\n\n\tmutex_lock(&pcs->mutex);\n\tlist_add_tail(&pcswi->node, &pcs->irqs);\n\tmutex_unlock(&pcs->mutex);\n\n\tirq_set_chip_data(irq, pcs_soc);\n\tirq_set_chip_and_handler(irq, &pcs->chip,\n\t\t\t\t handle_level_irq);\n\tirq_set_lockdep_class(irq, &pcs_lock_class, &pcs_request_class);\n\tirq_set_noprobe(irq);\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops pcs_irqdomain_ops = {\n\t.map = pcs_irqdomain_map,\n\t.xlate = irq_domain_xlate_onecell,\n};\n\n \nstatic int pcs_irq_init_chained_handler(struct pcs_device *pcs,\n\t\t\t\t\tstruct device_node *np)\n{\n\tstruct pcs_soc_data *pcs_soc = &pcs->socdata;\n\tconst char *name = \"pinctrl\";\n\tint num_irqs;\n\n\tif (!pcs_soc->irq_enable_mask ||\n\t    !pcs_soc->irq_status_mask) {\n\t\tpcs_soc->irq = -1;\n\t\treturn -EINVAL;\n\t}\n\n\tINIT_LIST_HEAD(&pcs->irqs);\n\tpcs->chip.name = name;\n\tpcs->chip.irq_ack = pcs_irq_mask;\n\tpcs->chip.irq_mask = pcs_irq_mask;\n\tpcs->chip.irq_unmask = pcs_irq_unmask;\n\tpcs->chip.irq_set_wake = pcs_irq_set_wake;\n\n\tif (PCS_QUIRK_HAS_SHARED_IRQ) {\n\t\tint res;\n\n\t\tres = request_irq(pcs_soc->irq, pcs_irq_handler,\n\t\t\t\t  IRQF_SHARED | IRQF_NO_SUSPEND |\n\t\t\t\t  IRQF_NO_THREAD,\n\t\t\t\t  name, pcs_soc);\n\t\tif (res) {\n\t\t\tpcs_soc->irq = -1;\n\t\t\treturn res;\n\t\t}\n\t} else {\n\t\tirq_set_chained_handler_and_data(pcs_soc->irq,\n\t\t\t\t\t\t pcs_irq_chain_handler,\n\t\t\t\t\t\t pcs_soc);\n\t}\n\n\t \n\tnum_irqs = pcs->size;\n\n\tpcs->domain = irq_domain_add_simple(np, num_irqs, 0,\n\t\t\t\t\t    &pcs_irqdomain_ops,\n\t\t\t\t\t    pcs_soc);\n\tif (!pcs->domain) {\n\t\tirq_set_chained_handler(pcs_soc->irq, NULL);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic int pcs_save_context(struct pcs_device *pcs)\n{\n\tint i, mux_bytes;\n\tu64 *regsl;\n\tu32 *regsw;\n\tu16 *regshw;\n\n\tmux_bytes = pcs->width / BITS_PER_BYTE;\n\n\tif (!pcs->saved_vals) {\n\t\tpcs->saved_vals = devm_kzalloc(pcs->dev, pcs->size, GFP_ATOMIC);\n\t\tif (!pcs->saved_vals)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tswitch (pcs->width) {\n\tcase 64:\n\t\tregsl = pcs->saved_vals;\n\t\tfor (i = 0; i < pcs->size; i += mux_bytes)\n\t\t\t*regsl++ = pcs->read(pcs->base + i);\n\t\tbreak;\n\tcase 32:\n\t\tregsw = pcs->saved_vals;\n\t\tfor (i = 0; i < pcs->size; i += mux_bytes)\n\t\t\t*regsw++ = pcs->read(pcs->base + i);\n\t\tbreak;\n\tcase 16:\n\t\tregshw = pcs->saved_vals;\n\t\tfor (i = 0; i < pcs->size; i += mux_bytes)\n\t\t\t*regshw++ = pcs->read(pcs->base + i);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void pcs_restore_context(struct pcs_device *pcs)\n{\n\tint i, mux_bytes;\n\tu64 *regsl;\n\tu32 *regsw;\n\tu16 *regshw;\n\n\tmux_bytes = pcs->width / BITS_PER_BYTE;\n\n\tswitch (pcs->width) {\n\tcase 64:\n\t\tregsl = pcs->saved_vals;\n\t\tfor (i = 0; i < pcs->size; i += mux_bytes)\n\t\t\tpcs->write(*regsl++, pcs->base + i);\n\t\tbreak;\n\tcase 32:\n\t\tregsw = pcs->saved_vals;\n\t\tfor (i = 0; i < pcs->size; i += mux_bytes)\n\t\t\tpcs->write(*regsw++, pcs->base + i);\n\t\tbreak;\n\tcase 16:\n\t\tregshw = pcs->saved_vals;\n\t\tfor (i = 0; i < pcs->size; i += mux_bytes)\n\t\t\tpcs->write(*regshw++, pcs->base + i);\n\t\tbreak;\n\t}\n}\n\nstatic int pinctrl_single_suspend(struct platform_device *pdev,\n\t\t\t\t\tpm_message_t state)\n{\n\tstruct pcs_device *pcs;\n\n\tpcs = platform_get_drvdata(pdev);\n\tif (!pcs)\n\t\treturn -EINVAL;\n\n\tif (pcs->flags & PCS_CONTEXT_LOSS_OFF) {\n\t\tint ret;\n\n\t\tret = pcs_save_context(pcs);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn pinctrl_force_sleep(pcs->pctl);\n}\n\nstatic int pinctrl_single_resume(struct platform_device *pdev)\n{\n\tstruct pcs_device *pcs;\n\n\tpcs = platform_get_drvdata(pdev);\n\tif (!pcs)\n\t\treturn -EINVAL;\n\n\tif (pcs->flags & PCS_CONTEXT_LOSS_OFF)\n\t\tpcs_restore_context(pcs);\n\n\treturn pinctrl_force_default(pcs->pctl);\n}\n#endif\n\n \nstatic int pcs_quirk_missing_pinctrl_cells(struct pcs_device *pcs,\n\t\t\t\t\t   struct device_node *np,\n\t\t\t\t\t   int cells)\n{\n\tstruct property *p;\n\tconst char *name = \"#pinctrl-cells\";\n\tint error;\n\tu32 val;\n\n\terror = of_property_read_u32(np, name, &val);\n\tif (!error)\n\t\treturn 0;\n\n\tdev_warn(pcs->dev, \"please update dts to use %s = <%i>\\n\",\n\t\t name, cells);\n\n\tp = devm_kzalloc(pcs->dev, sizeof(*p), GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tp->length = sizeof(__be32);\n\tp->value = devm_kzalloc(pcs->dev, sizeof(__be32), GFP_KERNEL);\n\tif (!p->value)\n\t\treturn -ENOMEM;\n\t*(__be32 *)p->value = cpu_to_be32(cells);\n\n\tp->name = devm_kstrdup(pcs->dev, name, GFP_KERNEL);\n\tif (!p->name)\n\t\treturn -ENOMEM;\n\n\tpcs->missing_nr_pinctrl_cells = p;\n\n#if IS_BUILTIN(CONFIG_PINCTRL_SINGLE)\n\terror = of_add_property(np, pcs->missing_nr_pinctrl_cells);\n#endif\n\n\treturn error;\n}\n\nstatic int pcs_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct pcs_pdata *pdata;\n\tstruct resource *res;\n\tstruct pcs_device *pcs;\n\tconst struct pcs_soc_data *soc;\n\tint ret;\n\n\tsoc = of_device_get_match_data(&pdev->dev);\n\tif (WARN_ON(!soc))\n\t\treturn -EINVAL;\n\n\tpcs = devm_kzalloc(&pdev->dev, sizeof(*pcs), GFP_KERNEL);\n\tif (!pcs)\n\t\treturn -ENOMEM;\n\n\tpcs->dev = &pdev->dev;\n\tpcs->np = np;\n\traw_spin_lock_init(&pcs->lock);\n\tmutex_init(&pcs->mutex);\n\tINIT_LIST_HEAD(&pcs->gpiofuncs);\n\tpcs->flags = soc->flags;\n\tmemcpy(&pcs->socdata, soc, sizeof(*soc));\n\n\tret = of_property_read_u32(np, \"pinctrl-single,register-width\",\n\t\t\t\t   &pcs->width);\n\tif (ret) {\n\t\tdev_err(pcs->dev, \"register width not specified\\n\");\n\n\t\treturn ret;\n\t}\n\n\tret = of_property_read_u32(np, \"pinctrl-single,function-mask\",\n\t\t\t\t   &pcs->fmask);\n\tif (!ret) {\n\t\tpcs->fshift = __ffs(pcs->fmask);\n\t\tpcs->fmax = pcs->fmask >> pcs->fshift;\n\t} else {\n\t\t \n\t\tpcs->fmask = 0;\n\t\tpcs->fshift = 0;\n\t\tpcs->fmax = 0;\n\t}\n\n\tret = of_property_read_u32(np, \"pinctrl-single,function-off\",\n\t\t\t\t\t&pcs->foff);\n\tif (ret)\n\t\tpcs->foff = PCS_OFF_DISABLED;\n\n\tpcs->bits_per_mux = of_property_read_bool(np,\n\t\t\t\t\t\t  \"pinctrl-single,bit-per-mux\");\n\tret = pcs_quirk_missing_pinctrl_cells(pcs, np,\n\t\t\t\t\t      pcs->bits_per_mux ? 2 : 1);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"unable to patch #pinctrl-cells\\n\");\n\n\t\treturn ret;\n\t}\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tdev_err(pcs->dev, \"could not get resource\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpcs->res = devm_request_mem_region(pcs->dev, res->start,\n\t\t\tresource_size(res), DRIVER_NAME);\n\tif (!pcs->res) {\n\t\tdev_err(pcs->dev, \"could not get mem_region\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tpcs->size = resource_size(pcs->res);\n\tpcs->base = devm_ioremap(pcs->dev, pcs->res->start, pcs->size);\n\tif (!pcs->base) {\n\t\tdev_err(pcs->dev, \"could not ioremap\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tplatform_set_drvdata(pdev, pcs);\n\n\tswitch (pcs->width) {\n\tcase 8:\n\t\tpcs->read = pcs_readb;\n\t\tpcs->write = pcs_writeb;\n\t\tbreak;\n\tcase 16:\n\t\tpcs->read = pcs_readw;\n\t\tpcs->write = pcs_writew;\n\t\tbreak;\n\tcase 32:\n\t\tpcs->read = pcs_readl;\n\t\tpcs->write = pcs_writel;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tpcs->desc.name = DRIVER_NAME;\n\tpcs->desc.pctlops = &pcs_pinctrl_ops;\n\tpcs->desc.pmxops = &pcs_pinmux_ops;\n\tif (PCS_HAS_PINCONF)\n\t\tpcs->desc.confops = &pcs_pinconf_ops;\n\tpcs->desc.owner = THIS_MODULE;\n\n\tret = pcs_allocate_pin_table(pcs);\n\tif (ret < 0)\n\t\tgoto free;\n\n\tret = pinctrl_register_and_init(&pcs->desc, pcs->dev, pcs, &pcs->pctl);\n\tif (ret) {\n\t\tdev_err(pcs->dev, \"could not register single pinctrl driver\\n\");\n\t\tgoto free;\n\t}\n\n\tret = pcs_add_gpio_func(np, pcs);\n\tif (ret < 0)\n\t\tgoto free;\n\n\tpcs->socdata.irq = irq_of_parse_and_map(np, 0);\n\tif (pcs->socdata.irq)\n\t\tpcs->flags |= PCS_FEAT_IRQ;\n\n\t \n\tpdata = dev_get_platdata(&pdev->dev);\n\tif (pdata) {\n\t\tif (pdata->rearm)\n\t\t\tpcs->socdata.rearm = pdata->rearm;\n\t\tif (pdata->irq) {\n\t\t\tpcs->socdata.irq = pdata->irq;\n\t\t\tpcs->flags |= PCS_FEAT_IRQ;\n\t\t}\n\t}\n\n\tif (PCS_HAS_IRQ) {\n\t\tret = pcs_irq_init_chained_handler(pcs, np);\n\t\tif (ret < 0)\n\t\t\tdev_warn(pcs->dev, \"initialized with no interrupts\\n\");\n\t}\n\n\tdev_info(pcs->dev, \"%i pins, size %u\\n\", pcs->desc.npins, pcs->size);\n\n\treturn pinctrl_enable(pcs->pctl);\n\nfree:\n\tpcs_free_resources(pcs);\n\n\treturn ret;\n}\n\nstatic int pcs_remove(struct platform_device *pdev)\n{\n\tstruct pcs_device *pcs = platform_get_drvdata(pdev);\n\n\tif (!pcs)\n\t\treturn 0;\n\n\tpcs_free_resources(pcs);\n\n\treturn 0;\n}\n\nstatic const struct pcs_soc_data pinctrl_single_omap_wkup = {\n\t.flags = PCS_QUIRK_SHARED_IRQ,\n\t.irq_enable_mask = (1 << 14),\t \n\t.irq_status_mask = (1 << 15),\t \n};\n\nstatic const struct pcs_soc_data pinctrl_single_dra7 = {\n\t.irq_enable_mask = (1 << 24),\t \n\t.irq_status_mask = (1 << 25),\t \n};\n\nstatic const struct pcs_soc_data pinctrl_single_am437x = {\n\t.flags = PCS_QUIRK_SHARED_IRQ | PCS_CONTEXT_LOSS_OFF,\n\t.irq_enable_mask = (1 << 29),    \n\t.irq_status_mask = (1 << 30),    \n};\n\nstatic const struct pcs_soc_data pinctrl_single_am654 = {\n\t.flags = PCS_QUIRK_SHARED_IRQ | PCS_CONTEXT_LOSS_OFF,\n\t.irq_enable_mask = (1 << 29),    \n\t.irq_status_mask = (1 << 30),    \n};\n\nstatic const struct pcs_soc_data pinctrl_single = {\n};\n\nstatic const struct pcs_soc_data pinconf_single = {\n\t.flags = PCS_FEAT_PINCONF,\n};\n\nstatic const struct of_device_id pcs_of_match[] = {\n\t{ .compatible = \"ti,am437-padconf\", .data = &pinctrl_single_am437x },\n\t{ .compatible = \"ti,am654-padconf\", .data = &pinctrl_single_am654 },\n\t{ .compatible = \"ti,dra7-padconf\", .data = &pinctrl_single_dra7 },\n\t{ .compatible = \"ti,omap3-padconf\", .data = &pinctrl_single_omap_wkup },\n\t{ .compatible = \"ti,omap4-padconf\", .data = &pinctrl_single_omap_wkup },\n\t{ .compatible = \"ti,omap5-padconf\", .data = &pinctrl_single_omap_wkup },\n\t{ .compatible = \"pinctrl-single\", .data = &pinctrl_single },\n\t{ .compatible = \"pinconf-single\", .data = &pinconf_single },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, pcs_of_match);\n\nstatic struct platform_driver pcs_driver = {\n\t.probe\t\t= pcs_probe,\n\t.remove\t\t= pcs_remove,\n\t.driver = {\n\t\t.name\t\t= DRIVER_NAME,\n\t\t.of_match_table\t= pcs_of_match,\n\t},\n#ifdef CONFIG_PM\n\t.suspend = pinctrl_single_suspend,\n\t.resume = pinctrl_single_resume,\n#endif\n};\n\nmodule_platform_driver(pcs_driver);\n\nMODULE_AUTHOR(\"Tony Lindgren <tony@atomide.com>\");\nMODULE_DESCRIPTION(\"One-register-per-pin type device tree based pinctrl driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}