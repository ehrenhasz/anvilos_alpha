{
  "module_name": "pinctrl-cy8c95x0.c",
  "hash_id": "c66d89ff2fc5e2c8c4762108c6556da740e4719437b22a367117f48912edf847",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/pinctrl-cy8c95x0.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/bitmap.h>\n#include <linux/dmi.h>\n#include <linux/gpio/driver.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/seq_file.h>\n\n#include <linux/pinctrl/consumer.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinconf-generic.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinmux.h>\n\n \n#define CY8C95X0_INPUT\t\t0x00\n#define CY8C95X0_OUTPUT\t\t0x08\n#define CY8C95X0_INTSTATUS\t0x10\n\n#define CY8C95X0_INPUT_(x)\t(CY8C95X0_INPUT + (x))\n#define CY8C95X0_OUTPUT_(x)\t(CY8C95X0_OUTPUT + (x))\n#define CY8C95X0_INTSTATUS_(x)\t(CY8C95X0_INTSTATUS + (x))\n\n \n#define CY8C95X0_PORTSEL\t0x18\n \n#define CY8C95X0_INTMASK\t0x19\n#define CY8C95X0_PWMSEL\t\t0x1A\n#define CY8C95X0_INVERT\t\t0x1B\n#define CY8C95X0_DIRECTION\t0x1C\n \n#define CY8C95X0_DRV_PU\t\t0x1D\n#define CY8C95X0_DRV_PD\t\t0x1E\n#define CY8C95X0_DRV_ODH\t0x1F\n#define CY8C95X0_DRV_ODL\t0x20\n#define CY8C95X0_DRV_PP_FAST\t0x21\n#define CY8C95X0_DRV_PP_SLOW\t0x22\n#define CY8C95X0_DRV_HIZ\t0x23\n#define CY8C95X0_DEVID\t\t0x2E\n#define CY8C95X0_WATCHDOG\t0x2F\n#define CY8C95X0_COMMAND\t0x30\n\n#define CY8C95X0_PIN_TO_OFFSET(x) (((x) >= 20) ? ((x) + 4) : (x))\n\nstatic const struct i2c_device_id cy8c95x0_id[] = {\n\t{ \"cy8c9520\", 20, },\n\t{ \"cy8c9540\", 40, },\n\t{ \"cy8c9560\", 60, },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, cy8c95x0_id);\n\n#define OF_CY8C95X(__nrgpio) ((void *)(__nrgpio))\n\nstatic const struct of_device_id cy8c95x0_dt_ids[] = {\n\t{ .compatible = \"cypress,cy8c9520\", .data = OF_CY8C95X(20), },\n\t{ .compatible = \"cypress,cy8c9540\", .data = OF_CY8C95X(40), },\n\t{ .compatible = \"cypress,cy8c9560\", .data = OF_CY8C95X(60), },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, cy8c95x0_dt_ids);\n\nstatic const struct acpi_gpio_params cy8c95x0_irq_gpios = { 0, 0, true };\n\nstatic const struct acpi_gpio_mapping cy8c95x0_acpi_irq_gpios[] = {\n\t{ \"irq-gpios\", &cy8c95x0_irq_gpios, 1, ACPI_GPIO_QUIRK_ABSOLUTE_NUMBER },\n\t{ }\n};\n\nstatic int cy8c95x0_acpi_get_irq(struct device *dev)\n{\n\tint ret;\n\n\tret = devm_acpi_dev_add_driver_gpios(dev, cy8c95x0_acpi_irq_gpios);\n\tif (ret)\n\t\tdev_warn(dev, \"can't add GPIO ACPI mapping\\n\");\n\n\tret = acpi_dev_gpio_irq_get_by(ACPI_COMPANION(dev), \"irq-gpios\", 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_info(dev, \"ACPI interrupt quirk (IRQ %d)\\n\", ret);\n\treturn ret;\n}\n\nstatic const struct dmi_system_id cy8c95x0_dmi_acpi_irq_info[] = {\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_EXACT_MATCH(DMI_BOARD_NAME, \"Galileo\"),\n\t\t},\n\t},\n\t{}\n};\n\n#define MAX_BANK 8\n#define BANK_SZ 8\n#define MAX_LINE\t(MAX_BANK * BANK_SZ)\n\n#define CY8C95X0_GPIO_MASK\t\tGENMASK(7, 0)\n\n \nstruct cy8c95x0_pinctrl {\n\tstruct regmap *regmap;\n\tstruct mutex irq_lock;\n\tstruct mutex i2c_lock;\n\tDECLARE_BITMAP(irq_mask, MAX_LINE);\n\tDECLARE_BITMAP(irq_trig_raise, MAX_LINE);\n\tDECLARE_BITMAP(irq_trig_fall, MAX_LINE);\n\tDECLARE_BITMAP(irq_trig_low, MAX_LINE);\n\tDECLARE_BITMAP(irq_trig_high, MAX_LINE);\n\tDECLARE_BITMAP(push_pull, MAX_LINE);\n\tDECLARE_BITMAP(shiftmask, MAX_LINE);\n\tint nport;\n\tstruct gpio_chip gpio_chip;\n\tunsigned long driver_data;\n\tstruct regulator *regulator;\n\tstruct device *dev;\n\tstruct pinctrl_dev *pctldev;\n\tstruct pinctrl_desc pinctrl_desc;\n\tchar name[32];\n\tunsigned int tpin;\n\tstruct gpio_desc *gpio_reset;\n};\n\nstatic const struct pinctrl_pin_desc cy8c9560_pins[] = {\n\tPINCTRL_PIN(0, \"gp00\"),\n\tPINCTRL_PIN(1, \"gp01\"),\n\tPINCTRL_PIN(2, \"gp02\"),\n\tPINCTRL_PIN(3, \"gp03\"),\n\tPINCTRL_PIN(4, \"gp04\"),\n\tPINCTRL_PIN(5, \"gp05\"),\n\tPINCTRL_PIN(6, \"gp06\"),\n\tPINCTRL_PIN(7, \"gp07\"),\n\n\tPINCTRL_PIN(8, \"gp10\"),\n\tPINCTRL_PIN(9, \"gp11\"),\n\tPINCTRL_PIN(10, \"gp12\"),\n\tPINCTRL_PIN(11, \"gp13\"),\n\tPINCTRL_PIN(12, \"gp14\"),\n\tPINCTRL_PIN(13, \"gp15\"),\n\tPINCTRL_PIN(14, \"gp16\"),\n\tPINCTRL_PIN(15, \"gp17\"),\n\n\tPINCTRL_PIN(16, \"gp20\"),\n\tPINCTRL_PIN(17, \"gp21\"),\n\tPINCTRL_PIN(18, \"gp22\"),\n\tPINCTRL_PIN(19, \"gp23\"),\n\n\tPINCTRL_PIN(20, \"gp30\"),\n\tPINCTRL_PIN(21, \"gp31\"),\n\tPINCTRL_PIN(22, \"gp32\"),\n\tPINCTRL_PIN(23, \"gp33\"),\n\tPINCTRL_PIN(24, \"gp34\"),\n\tPINCTRL_PIN(25, \"gp35\"),\n\tPINCTRL_PIN(26, \"gp36\"),\n\tPINCTRL_PIN(27, \"gp37\"),\n\n\tPINCTRL_PIN(28, \"gp40\"),\n\tPINCTRL_PIN(29, \"gp41\"),\n\tPINCTRL_PIN(30, \"gp42\"),\n\tPINCTRL_PIN(31, \"gp43\"),\n\tPINCTRL_PIN(32, \"gp44\"),\n\tPINCTRL_PIN(33, \"gp45\"),\n\tPINCTRL_PIN(34, \"gp46\"),\n\tPINCTRL_PIN(35, \"gp47\"),\n\n\tPINCTRL_PIN(36, \"gp50\"),\n\tPINCTRL_PIN(37, \"gp51\"),\n\tPINCTRL_PIN(38, \"gp52\"),\n\tPINCTRL_PIN(39, \"gp53\"),\n\tPINCTRL_PIN(40, \"gp54\"),\n\tPINCTRL_PIN(41, \"gp55\"),\n\tPINCTRL_PIN(42, \"gp56\"),\n\tPINCTRL_PIN(43, \"gp57\"),\n\n\tPINCTRL_PIN(44, \"gp60\"),\n\tPINCTRL_PIN(45, \"gp61\"),\n\tPINCTRL_PIN(46, \"gp62\"),\n\tPINCTRL_PIN(47, \"gp63\"),\n\tPINCTRL_PIN(48, \"gp64\"),\n\tPINCTRL_PIN(49, \"gp65\"),\n\tPINCTRL_PIN(50, \"gp66\"),\n\tPINCTRL_PIN(51, \"gp67\"),\n\n\tPINCTRL_PIN(52, \"gp70\"),\n\tPINCTRL_PIN(53, \"gp71\"),\n\tPINCTRL_PIN(54, \"gp72\"),\n\tPINCTRL_PIN(55, \"gp73\"),\n\tPINCTRL_PIN(56, \"gp74\"),\n\tPINCTRL_PIN(57, \"gp75\"),\n\tPINCTRL_PIN(58, \"gp76\"),\n\tPINCTRL_PIN(59, \"gp77\"),\n};\n\nstatic const char * const cy8c95x0_groups[] = {\n\t\"gp00\",\n\t\"gp01\",\n\t\"gp02\",\n\t\"gp03\",\n\t\"gp04\",\n\t\"gp05\",\n\t\"gp06\",\n\t\"gp07\",\n\n\t\"gp10\",\n\t\"gp11\",\n\t\"gp12\",\n\t\"gp13\",\n\t\"gp14\",\n\t\"gp15\",\n\t\"gp16\",\n\t\"gp17\",\n\n\t\"gp20\",\n\t\"gp21\",\n\t\"gp22\",\n\t\"gp23\",\n\n\t\"gp30\",\n\t\"gp31\",\n\t\"gp32\",\n\t\"gp33\",\n\t\"gp34\",\n\t\"gp35\",\n\t\"gp36\",\n\t\"gp37\",\n\n\t\"gp40\",\n\t\"gp41\",\n\t\"gp42\",\n\t\"gp43\",\n\t\"gp44\",\n\t\"gp45\",\n\t\"gp46\",\n\t\"gp47\",\n\n\t\"gp50\",\n\t\"gp51\",\n\t\"gp52\",\n\t\"gp53\",\n\t\"gp54\",\n\t\"gp55\",\n\t\"gp56\",\n\t\"gp57\",\n\n\t\"gp60\",\n\t\"gp61\",\n\t\"gp62\",\n\t\"gp63\",\n\t\"gp64\",\n\t\"gp65\",\n\t\"gp66\",\n\t\"gp67\",\n\n\t\"gp70\",\n\t\"gp71\",\n\t\"gp72\",\n\t\"gp73\",\n\t\"gp74\",\n\t\"gp75\",\n\t\"gp76\",\n\t\"gp77\",\n};\n\nstatic int cy8c95x0_pinmux_direction(struct cy8c95x0_pinctrl *chip,\n\t\t\t\t     unsigned int pin, bool input);\n\nstatic inline u8 cypress_get_port(struct cy8c95x0_pinctrl *chip, unsigned int pin)\n{\n\t \n\treturn CY8C95X0_PIN_TO_OFFSET(pin) / BANK_SZ;\n}\n\nstatic int cypress_get_pin_mask(struct cy8c95x0_pinctrl *chip, unsigned int pin)\n{\n\t \n\treturn BIT(CY8C95X0_PIN_TO_OFFSET(pin) % BANK_SZ);\n}\n\nstatic bool cy8c95x0_readable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase 0x24 ... 0x27:\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nstatic bool cy8c95x0_writeable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase CY8C95X0_INPUT_(0) ... CY8C95X0_INPUT_(7):\n\t\treturn false;\n\tcase CY8C95X0_DEVID:\n\t\treturn false;\n\tcase 0x24 ... 0x27:\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nstatic bool cy8c95x0_volatile_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase CY8C95X0_INPUT_(0) ... CY8C95X0_INPUT_(7):\n\tcase CY8C95X0_INTSTATUS_(0) ... CY8C95X0_INTSTATUS_(7):\n\tcase CY8C95X0_INTMASK:\n\tcase CY8C95X0_INVERT:\n\tcase CY8C95X0_PWMSEL:\n\tcase CY8C95X0_DIRECTION:\n\tcase CY8C95X0_DRV_PU:\n\tcase CY8C95X0_DRV_PD:\n\tcase CY8C95X0_DRV_ODH:\n\tcase CY8C95X0_DRV_ODL:\n\tcase CY8C95X0_DRV_PP_FAST:\n\tcase CY8C95X0_DRV_PP_SLOW:\n\tcase CY8C95X0_DRV_HIZ:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool cy8c95x0_precious_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase CY8C95X0_INTSTATUS_(0) ... CY8C95X0_INTSTATUS_(7):\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct reg_default cy8c95x0_reg_defaults[] = {\n\t{ CY8C95X0_OUTPUT_(0), GENMASK(7, 0) },\n\t{ CY8C95X0_OUTPUT_(1), GENMASK(7, 0) },\n\t{ CY8C95X0_OUTPUT_(2), GENMASK(7, 0) },\n\t{ CY8C95X0_OUTPUT_(3), GENMASK(7, 0) },\n\t{ CY8C95X0_OUTPUT_(4), GENMASK(7, 0) },\n\t{ CY8C95X0_OUTPUT_(5), GENMASK(7, 0) },\n\t{ CY8C95X0_OUTPUT_(6), GENMASK(7, 0) },\n\t{ CY8C95X0_OUTPUT_(7), GENMASK(7, 0) },\n\t{ CY8C95X0_PORTSEL, 0 },\n\t{ CY8C95X0_PWMSEL, 0 },\n};\n\nstatic const struct regmap_config cy8c95x0_i2c_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.reg_defaults = cy8c95x0_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(cy8c95x0_reg_defaults),\n\n\t.readable_reg = cy8c95x0_readable_register,\n\t.writeable_reg = cy8c95x0_writeable_register,\n\t.volatile_reg = cy8c95x0_volatile_register,\n\t.precious_reg = cy8c95x0_precious_register,\n\n\t.cache_type = REGCACHE_FLAT,\n\t.max_register = CY8C95X0_COMMAND,\n};\n\nstatic int cy8c95x0_write_regs_mask(struct cy8c95x0_pinctrl *chip, int reg,\n\t\t\t\t    unsigned long *val, unsigned long *mask)\n{\n\tDECLARE_BITMAP(tmask, MAX_LINE);\n\tDECLARE_BITMAP(tval, MAX_LINE);\n\tint write_val;\n\tint ret = 0;\n\tint i, off = 0;\n\tu8 bits;\n\n\t \n\tbitmap_andnot(tmask, mask, chip->shiftmask, MAX_LINE);\n\tbitmap_shift_left(tmask, tmask, 4, MAX_LINE);\n\tbitmap_replace(tmask, tmask, mask, chip->shiftmask, BANK_SZ * 3);\n\n\tbitmap_andnot(tval, val, chip->shiftmask, MAX_LINE);\n\tbitmap_shift_left(tval, tval, 4, MAX_LINE);\n\tbitmap_replace(tval, tval, val, chip->shiftmask, BANK_SZ * 3);\n\n\tmutex_lock(&chip->i2c_lock);\n\tfor (i = 0; i < chip->nport; i++) {\n\t\t \n\t\tbits = bitmap_get_value8(tmask, i * BANK_SZ);\n\t\tif (!bits)\n\t\t\tcontinue;\n\n\t\tswitch (reg) {\n\t\t \n\t\tcase CY8C95X0_INTMASK:\n\t\tcase CY8C95X0_PWMSEL:\n\t\tcase CY8C95X0_INVERT:\n\t\tcase CY8C95X0_DIRECTION:\n\t\tcase CY8C95X0_DRV_PU:\n\t\tcase CY8C95X0_DRV_PD:\n\t\tcase CY8C95X0_DRV_ODH:\n\t\tcase CY8C95X0_DRV_ODL:\n\t\tcase CY8C95X0_DRV_PP_FAST:\n\t\tcase CY8C95X0_DRV_PP_SLOW:\n\t\tcase CY8C95X0_DRV_HIZ:\n\t\t\tret = regmap_write(chip->regmap, CY8C95X0_PORTSEL, i);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\toff = reg;\n\t\t\tbreak;\n\t\t \n\t\tcase CY8C95X0_INPUT:\n\t\tcase CY8C95X0_OUTPUT:\n\t\tcase CY8C95X0_INTSTATUS:\n\t\t\toff = reg + i;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\twrite_val = bitmap_get_value8(tval, i * BANK_SZ);\n\n\t\tret = regmap_update_bits(chip->regmap, off, bits, write_val);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&chip->i2c_lock);\n\n\tif (ret < 0)\n\t\tdev_err(chip->dev, \"failed writing register %d: err %d\\n\", off, ret);\n\n\treturn ret;\n}\n\nstatic int cy8c95x0_read_regs_mask(struct cy8c95x0_pinctrl *chip, int reg,\n\t\t\t\t   unsigned long *val, unsigned long *mask)\n{\n\tDECLARE_BITMAP(tmask, MAX_LINE);\n\tDECLARE_BITMAP(tval, MAX_LINE);\n\tDECLARE_BITMAP(tmp, MAX_LINE);\n\tint read_val;\n\tint ret = 0;\n\tint i, off = 0;\n\tu8 bits;\n\n\t \n\tbitmap_andnot(tmask, mask, chip->shiftmask, MAX_LINE);\n\tbitmap_shift_left(tmask, tmask, 4, MAX_LINE);\n\tbitmap_replace(tmask, tmask, mask, chip->shiftmask, BANK_SZ * 3);\n\n\tbitmap_andnot(tval, val, chip->shiftmask, MAX_LINE);\n\tbitmap_shift_left(tval, tval, 4, MAX_LINE);\n\tbitmap_replace(tval, tval, val, chip->shiftmask, BANK_SZ * 3);\n\n\tmutex_lock(&chip->i2c_lock);\n\tfor (i = 0; i < chip->nport; i++) {\n\t\t \n\t\tbits = bitmap_get_value8(tmask, i * BANK_SZ);\n\t\tif (!bits)\n\t\t\tcontinue;\n\n\t\tswitch (reg) {\n\t\t \n\t\tcase CY8C95X0_INTMASK:\n\t\tcase CY8C95X0_PWMSEL:\n\t\tcase CY8C95X0_INVERT:\n\t\tcase CY8C95X0_DIRECTION:\n\t\tcase CY8C95X0_DRV_PU:\n\t\tcase CY8C95X0_DRV_PD:\n\t\tcase CY8C95X0_DRV_ODH:\n\t\tcase CY8C95X0_DRV_ODL:\n\t\tcase CY8C95X0_DRV_PP_FAST:\n\t\tcase CY8C95X0_DRV_PP_SLOW:\n\t\tcase CY8C95X0_DRV_HIZ:\n\t\t\tret = regmap_write(chip->regmap, CY8C95X0_PORTSEL, i);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\toff = reg;\n\t\t\tbreak;\n\t\t \n\t\tcase CY8C95X0_INPUT:\n\t\tcase CY8C95X0_OUTPUT:\n\t\tcase CY8C95X0_INTSTATUS:\n\t\t\toff = reg + i;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = regmap_read(chip->regmap, off, &read_val);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tread_val &= bits;\n\t\tread_val |= bitmap_get_value8(tval, i * BANK_SZ) & ~bits;\n\t\tbitmap_set_value8(tval, read_val, i * BANK_SZ);\n\t}\n\n\t \n\tbitmap_shift_right(tmp, tval, 4, MAX_LINE);\n\tbitmap_replace(val, tmp, tval, chip->shiftmask, MAX_LINE);\n\nout:\n\tmutex_unlock(&chip->i2c_lock);\n\n\tif (ret < 0)\n\t\tdev_err(chip->dev, \"failed reading register %d: err %d\\n\", off, ret);\n\n\treturn ret;\n}\n\nstatic int cy8c95x0_gpio_direction_input(struct gpio_chip *gc, unsigned int off)\n{\n\treturn pinctrl_gpio_direction_input(gc->base + off);\n}\n\nstatic int cy8c95x0_gpio_direction_output(struct gpio_chip *gc,\n\t\t\t\t\t  unsigned int off, int val)\n{\n\tstruct cy8c95x0_pinctrl *chip = gpiochip_get_data(gc);\n\tu8 port = cypress_get_port(chip, off);\n\tu8 outreg = CY8C95X0_OUTPUT_(port);\n\tu8 bit = cypress_get_pin_mask(chip, off);\n\tint ret;\n\n\t \n\tret = regmap_write_bits(chip->regmap, outreg, bit, val ? bit : 0);\n\tif (ret)\n\t\treturn ret;\n\n\treturn pinctrl_gpio_direction_output(gc->base + off);\n}\n\nstatic int cy8c95x0_gpio_get_value(struct gpio_chip *gc, unsigned int off)\n{\n\tstruct cy8c95x0_pinctrl *chip = gpiochip_get_data(gc);\n\tu8 inreg = CY8C95X0_INPUT_(cypress_get_port(chip, off));\n\tu8 bit = cypress_get_pin_mask(chip, off);\n\tu32 reg_val;\n\tint ret;\n\n\tret = regmap_read(chip->regmap, inreg, &reg_val);\n\tif (ret < 0) {\n\t\t \n\t\treturn 0;\n\t}\n\n\treturn !!(reg_val & bit);\n}\n\nstatic void cy8c95x0_gpio_set_value(struct gpio_chip *gc, unsigned int off,\n\t\t\t\t    int val)\n{\n\tstruct cy8c95x0_pinctrl *chip = gpiochip_get_data(gc);\n\tu8 outreg = CY8C95X0_OUTPUT_(cypress_get_port(chip, off));\n\tu8 bit = cypress_get_pin_mask(chip, off);\n\n\tregmap_write_bits(chip->regmap, outreg, bit, val ? bit : 0);\n}\n\nstatic int cy8c95x0_gpio_get_direction(struct gpio_chip *gc, unsigned int off)\n{\n\tstruct cy8c95x0_pinctrl *chip = gpiochip_get_data(gc);\n\tu8 port = cypress_get_port(chip, off);\n\tu8 bit = cypress_get_pin_mask(chip, off);\n\tu32 reg_val;\n\tint ret;\n\n\tmutex_lock(&chip->i2c_lock);\n\n\tret = regmap_write(chip->regmap, CY8C95X0_PORTSEL, port);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = regmap_read(chip->regmap, CY8C95X0_DIRECTION, &reg_val);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tmutex_unlock(&chip->i2c_lock);\n\n\tif (reg_val & bit)\n\t\treturn GPIO_LINE_DIRECTION_IN;\n\n\treturn GPIO_LINE_DIRECTION_OUT;\nout:\n\tmutex_unlock(&chip->i2c_lock);\n\treturn ret;\n}\n\nstatic int cy8c95x0_gpio_get_pincfg(struct cy8c95x0_pinctrl *chip,\n\t\t\t\t    unsigned int off,\n\t\t\t\t    unsigned long *config)\n{\n\tenum pin_config_param param = pinconf_to_config_param(*config);\n\tu8 port = cypress_get_port(chip, off);\n\tu8 bit = cypress_get_pin_mask(chip, off);\n\tunsigned int reg;\n\tu32 reg_val;\n\tu16 arg = 0;\n\tint ret;\n\n\tmutex_lock(&chip->i2c_lock);\n\n\t \n\tret = regmap_write(chip->regmap, CY8C95X0_PORTSEL, port);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tswitch (param) {\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\treg = CY8C95X0_DRV_PU;\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\treg = CY8C95X0_DRV_PD;\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\treg = CY8C95X0_DRV_HIZ;\n\t\tbreak;\n\tcase PIN_CONFIG_DRIVE_OPEN_DRAIN:\n\t\treg = CY8C95X0_DRV_ODL;\n\t\tbreak;\n\tcase PIN_CONFIG_DRIVE_OPEN_SOURCE:\n\t\treg = CY8C95X0_DRV_ODH;\n\t\tbreak;\n\tcase PIN_CONFIG_DRIVE_PUSH_PULL:\n\t\treg = CY8C95X0_DRV_PP_FAST;\n\t\tbreak;\n\tcase PIN_CONFIG_INPUT_ENABLE:\n\t\treg = CY8C95X0_DIRECTION;\n\t\tbreak;\n\tcase PIN_CONFIG_MODE_PWM:\n\t\treg = CY8C95X0_PWMSEL;\n\t\tbreak;\n\tcase PIN_CONFIG_OUTPUT:\n\t\treg = CY8C95X0_OUTPUT_(port);\n\t\tbreak;\n\tcase PIN_CONFIG_OUTPUT_ENABLE:\n\t\treg = CY8C95X0_DIRECTION;\n\t\tbreak;\n\n\tcase PIN_CONFIG_BIAS_HIGH_IMPEDANCE:\n\tcase PIN_CONFIG_BIAS_BUS_HOLD:\n\tcase PIN_CONFIG_BIAS_PULL_PIN_DEFAULT:\n\tcase PIN_CONFIG_DRIVE_STRENGTH:\n\tcase PIN_CONFIG_DRIVE_STRENGTH_UA:\n\tcase PIN_CONFIG_INPUT_DEBOUNCE:\n\tcase PIN_CONFIG_INPUT_SCHMITT:\n\tcase PIN_CONFIG_INPUT_SCHMITT_ENABLE:\n\tcase PIN_CONFIG_MODE_LOW_POWER:\n\tcase PIN_CONFIG_PERSIST_STATE:\n\tcase PIN_CONFIG_POWER_SOURCE:\n\tcase PIN_CONFIG_SKEW_DELAY:\n\tcase PIN_CONFIG_SLEEP_HARDWARE_STATE:\n\tcase PIN_CONFIG_SLEW_RATE:\n\tdefault:\n\t\tret = -ENOTSUPP;\n\t\tgoto out;\n\t}\n\t \n\tret = regmap_read(chip->regmap, reg, &reg_val);\n\tif (reg_val & bit)\n\t\targ = 1;\n\tif (param == PIN_CONFIG_OUTPUT_ENABLE)\n\t\targ = !arg;\n\n\t*config = pinconf_to_config_packed(param, (u16)arg);\nout:\n\tmutex_unlock(&chip->i2c_lock);\n\n\treturn ret;\n}\n\nstatic int cy8c95x0_gpio_set_pincfg(struct cy8c95x0_pinctrl *chip,\n\t\t\t\t    unsigned int off,\n\t\t\t\t    unsigned long config)\n{\n\tu8 port = cypress_get_port(chip, off);\n\tu8 bit = cypress_get_pin_mask(chip, off);\n\tunsigned long param = pinconf_to_config_param(config);\n\tunsigned long arg = pinconf_to_config_argument(config);\n\tunsigned int reg;\n\tint ret;\n\n\tmutex_lock(&chip->i2c_lock);\n\n\t \n\tret = regmap_write(chip->regmap, CY8C95X0_PORTSEL, port);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tswitch (param) {\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\t__clear_bit(off, chip->push_pull);\n\t\treg = CY8C95X0_DRV_PU;\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\t__clear_bit(off, chip->push_pull);\n\t\treg = CY8C95X0_DRV_PD;\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\t__clear_bit(off, chip->push_pull);\n\t\treg = CY8C95X0_DRV_HIZ;\n\t\tbreak;\n\tcase PIN_CONFIG_DRIVE_OPEN_DRAIN:\n\t\t__clear_bit(off, chip->push_pull);\n\t\treg = CY8C95X0_DRV_ODL;\n\t\tbreak;\n\tcase PIN_CONFIG_DRIVE_OPEN_SOURCE:\n\t\t__clear_bit(off, chip->push_pull);\n\t\treg = CY8C95X0_DRV_ODH;\n\t\tbreak;\n\tcase PIN_CONFIG_DRIVE_PUSH_PULL:\n\t\t__set_bit(off, chip->push_pull);\n\t\treg = CY8C95X0_DRV_PP_FAST;\n\t\tbreak;\n\tcase PIN_CONFIG_MODE_PWM:\n\t\treg = CY8C95X0_PWMSEL;\n\t\tbreak;\n\tcase PIN_CONFIG_OUTPUT_ENABLE:\n\t\tret = cy8c95x0_pinmux_direction(chip, off, !arg);\n\t\tgoto out;\n\tcase PIN_CONFIG_INPUT_ENABLE:\n\t\tret = cy8c95x0_pinmux_direction(chip, off, arg);\n\t\tgoto out;\n\tdefault:\n\t\tret = -ENOTSUPP;\n\t\tgoto out;\n\t}\n\t \n\tret = regmap_write_bits(chip->regmap, reg, bit, bit);\n\nout:\n\tmutex_unlock(&chip->i2c_lock);\n\treturn ret;\n}\n\nstatic int cy8c95x0_gpio_get_multiple(struct gpio_chip *gc,\n\t\t\t\t      unsigned long *mask, unsigned long *bits)\n{\n\tstruct cy8c95x0_pinctrl *chip = gpiochip_get_data(gc);\n\n\treturn cy8c95x0_read_regs_mask(chip, CY8C95X0_INPUT, bits, mask);\n}\n\nstatic void cy8c95x0_gpio_set_multiple(struct gpio_chip *gc,\n\t\t\t\t       unsigned long *mask, unsigned long *bits)\n{\n\tstruct cy8c95x0_pinctrl *chip = gpiochip_get_data(gc);\n\n\tcy8c95x0_write_regs_mask(chip, CY8C95X0_OUTPUT, bits, mask);\n}\n\nstatic int cy8c95x0_add_pin_ranges(struct gpio_chip *gc)\n{\n\tstruct cy8c95x0_pinctrl *chip = gpiochip_get_data(gc);\n\tstruct device *dev = chip->dev;\n\tint ret;\n\n\tret = gpiochip_add_pin_range(gc, dev_name(dev), 0, 0, chip->tpin);\n\tif (ret)\n\t\tdev_err(dev, \"failed to add GPIO pin range\\n\");\n\n\treturn ret;\n}\n\nstatic int cy8c95x0_setup_gpiochip(struct cy8c95x0_pinctrl *chip)\n{\n\tstruct gpio_chip *gc = &chip->gpio_chip;\n\n\tgc->request = gpiochip_generic_request;\n\tgc->free = gpiochip_generic_free;\n\tgc->direction_input  = cy8c95x0_gpio_direction_input;\n\tgc->direction_output = cy8c95x0_gpio_direction_output;\n\tgc->get = cy8c95x0_gpio_get_value;\n\tgc->set = cy8c95x0_gpio_set_value;\n\tgc->get_direction = cy8c95x0_gpio_get_direction;\n\tgc->get_multiple = cy8c95x0_gpio_get_multiple;\n\tgc->set_multiple = cy8c95x0_gpio_set_multiple;\n\tgc->set_config = gpiochip_generic_config;\n\tgc->can_sleep = true;\n\tgc->add_pin_ranges = cy8c95x0_add_pin_ranges;\n\n\tgc->base = -1;\n\tgc->ngpio = chip->tpin;\n\n\tgc->parent = chip->dev;\n\tgc->owner = THIS_MODULE;\n\tgc->names = NULL;\n\n\tgc->label = dev_name(chip->dev);\n\n\treturn devm_gpiochip_add_data(chip->dev, gc, chip);\n}\n\nstatic void cy8c95x0_irq_mask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct cy8c95x0_pinctrl *chip = gpiochip_get_data(gc);\n\tirq_hw_number_t hwirq = irqd_to_hwirq(d);\n\n\tset_bit(hwirq, chip->irq_mask);\n\tgpiochip_disable_irq(gc, hwirq);\n}\n\nstatic void cy8c95x0_irq_unmask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct cy8c95x0_pinctrl *chip = gpiochip_get_data(gc);\n\tirq_hw_number_t hwirq = irqd_to_hwirq(d);\n\n\tgpiochip_enable_irq(gc, hwirq);\n\tclear_bit(hwirq, chip->irq_mask);\n}\n\nstatic void cy8c95x0_irq_bus_lock(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct cy8c95x0_pinctrl *chip = gpiochip_get_data(gc);\n\n\tmutex_lock(&chip->irq_lock);\n}\n\nstatic void cy8c95x0_irq_bus_sync_unlock(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct cy8c95x0_pinctrl *chip = gpiochip_get_data(gc);\n\tDECLARE_BITMAP(ones, MAX_LINE);\n\tDECLARE_BITMAP(irq_mask, MAX_LINE);\n\tDECLARE_BITMAP(reg_direction, MAX_LINE);\n\n\tbitmap_fill(ones, MAX_LINE);\n\n\tcy8c95x0_write_regs_mask(chip, CY8C95X0_INTMASK, chip->irq_mask, ones);\n\n\t \n\tcy8c95x0_read_regs_mask(chip, CY8C95X0_DIRECTION, reg_direction, chip->irq_mask);\n\tbitmap_or(irq_mask, chip->irq_mask, reg_direction, MAX_LINE);\n\tbitmap_complement(irq_mask, irq_mask, MAX_LINE);\n\n\t \n\tcy8c95x0_write_regs_mask(chip, CY8C95X0_DIRECTION, ones, irq_mask);\n\n\tmutex_unlock(&chip->irq_lock);\n}\n\nstatic int cy8c95x0_irq_set_type(struct irq_data *d, unsigned int type)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct cy8c95x0_pinctrl *chip = gpiochip_get_data(gc);\n\tirq_hw_number_t hwirq = irqd_to_hwirq(d);\n\tunsigned int trig_type;\n\n\tswitch (type) {\n\tcase IRQ_TYPE_EDGE_RISING:\n\tcase IRQ_TYPE_EDGE_FALLING:\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\ttrig_type = type;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\ttrig_type = IRQ_TYPE_EDGE_RISING;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\ttrig_type = IRQ_TYPE_EDGE_FALLING;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(chip->dev, \"irq %d: unsupported type %d\\n\", d->irq, type);\n\t\treturn -EINVAL;\n\t}\n\n\tassign_bit(hwirq, chip->irq_trig_fall, trig_type & IRQ_TYPE_EDGE_FALLING);\n\tassign_bit(hwirq, chip->irq_trig_raise, trig_type & IRQ_TYPE_EDGE_RISING);\n\tassign_bit(hwirq, chip->irq_trig_low, type == IRQ_TYPE_LEVEL_LOW);\n\tassign_bit(hwirq, chip->irq_trig_high, type == IRQ_TYPE_LEVEL_HIGH);\n\n\treturn 0;\n}\n\nstatic void cy8c95x0_irq_shutdown(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct cy8c95x0_pinctrl *chip = gpiochip_get_data(gc);\n\tirq_hw_number_t hwirq = irqd_to_hwirq(d);\n\n\tclear_bit(hwirq, chip->irq_trig_raise);\n\tclear_bit(hwirq, chip->irq_trig_fall);\n\tclear_bit(hwirq, chip->irq_trig_low);\n\tclear_bit(hwirq, chip->irq_trig_high);\n}\n\nstatic const struct irq_chip cy8c95x0_irqchip = {\n\t.name = \"cy8c95x0-irq\",\n\t.irq_mask = cy8c95x0_irq_mask,\n\t.irq_unmask = cy8c95x0_irq_unmask,\n\t.irq_bus_lock = cy8c95x0_irq_bus_lock,\n\t.irq_bus_sync_unlock = cy8c95x0_irq_bus_sync_unlock,\n\t.irq_set_type = cy8c95x0_irq_set_type,\n\t.irq_shutdown = cy8c95x0_irq_shutdown,\n\t.flags = IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic bool cy8c95x0_irq_pending(struct cy8c95x0_pinctrl *chip, unsigned long *pending)\n{\n\tDECLARE_BITMAP(ones, MAX_LINE);\n\tDECLARE_BITMAP(cur_stat, MAX_LINE);\n\tDECLARE_BITMAP(new_stat, MAX_LINE);\n\tDECLARE_BITMAP(trigger, MAX_LINE);\n\n\tbitmap_fill(ones, MAX_LINE);\n\n\t \n\tif (cy8c95x0_read_regs_mask(chip, CY8C95X0_INTSTATUS, trigger, ones))\n\t\treturn false;\n\n\t \n\tif (cy8c95x0_read_regs_mask(chip, CY8C95X0_INPUT, cur_stat, trigger))\n\t\treturn false;\n\n\t \n\tbitmap_replace(new_stat, chip->irq_trig_fall, chip->irq_trig_raise,\n\t\t       cur_stat, MAX_LINE);\n\n\tbitmap_and(pending, new_stat, trigger, MAX_LINE);\n\n\treturn !bitmap_empty(pending, MAX_LINE);\n}\n\nstatic irqreturn_t cy8c95x0_irq_handler(int irq, void *devid)\n{\n\tstruct cy8c95x0_pinctrl *chip = devid;\n\tstruct gpio_chip *gc = &chip->gpio_chip;\n\tDECLARE_BITMAP(pending, MAX_LINE);\n\tint nested_irq, level;\n\tbool ret;\n\n\tret = cy8c95x0_irq_pending(chip, pending);\n\tif (!ret)\n\t\treturn IRQ_RETVAL(0);\n\n\tret = 0;\n\tfor_each_set_bit(level, pending, MAX_LINE) {\n\t\t \n\t\tnested_irq = irq_find_mapping(gc->irq.domain, level);\n\n\t\tif (unlikely(nested_irq <= 0)) {\n\t\t\tdev_warn_ratelimited(gc->parent, \"unmapped interrupt %d\\n\", level);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (test_bit(level, chip->irq_trig_low))\n\t\t\twhile (!cy8c95x0_gpio_get_value(gc, level))\n\t\t\t\thandle_nested_irq(nested_irq);\n\t\telse if (test_bit(level, chip->irq_trig_high))\n\t\t\twhile (cy8c95x0_gpio_get_value(gc, level))\n\t\t\t\thandle_nested_irq(nested_irq);\n\t\telse\n\t\t\thandle_nested_irq(nested_irq);\n\n\t\tret = 1;\n\t}\n\n\treturn IRQ_RETVAL(ret);\n}\n\nstatic int cy8c95x0_pinctrl_get_groups_count(struct pinctrl_dev *pctldev)\n{\n\tstruct cy8c95x0_pinctrl *chip = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn chip->tpin;\n}\n\nstatic const char *cy8c95x0_pinctrl_get_group_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t\t   unsigned int group)\n{\n\treturn cy8c95x0_groups[group];\n}\n\nstatic int cy8c95x0_pinctrl_get_group_pins(struct pinctrl_dev *pctldev,\n\t\t\t\t\t   unsigned int group,\n\t\t\t\t\t   const unsigned int **pins,\n\t\t\t\t\t   unsigned int *num_pins)\n{\n\t*pins = &cy8c9560_pins[group].number;\n\t*num_pins = 1;\n\treturn 0;\n}\n\nstatic const char *cy8c95x0_get_fname(unsigned int selector)\n{\n\tif (selector == 0)\n\t\treturn \"gpio\";\n\telse\n\t\treturn \"pwm\";\n}\n\nstatic void cy8c95x0_pin_dbg_show(struct pinctrl_dev *pctldev, struct seq_file *s,\n\t\t\t\t  unsigned int pin)\n{\n\tstruct cy8c95x0_pinctrl *chip = pinctrl_dev_get_drvdata(pctldev);\n\tDECLARE_BITMAP(mask, MAX_LINE);\n\tDECLARE_BITMAP(pwm, MAX_LINE);\n\n\tbitmap_zero(mask, MAX_LINE);\n\t__set_bit(pin, mask);\n\n\tif (cy8c95x0_read_regs_mask(chip, CY8C95X0_PWMSEL, pwm, mask)) {\n\t\tseq_puts(s, \"not available\");\n\t\treturn;\n\t}\n\n\tseq_printf(s, \"MODE:%s\", cy8c95x0_get_fname(test_bit(pin, pwm)));\n}\n\nstatic const struct pinctrl_ops cy8c95x0_pinctrl_ops = {\n\t.get_groups_count = cy8c95x0_pinctrl_get_groups_count,\n\t.get_group_name = cy8c95x0_pinctrl_get_group_name,\n\t.get_group_pins = cy8c95x0_pinctrl_get_group_pins,\n#ifdef CONFIG_OF\n\t.dt_node_to_map = pinconf_generic_dt_node_to_map_pin,\n\t.dt_free_map = pinconf_generic_dt_free_map,\n#endif\n\t.pin_dbg_show = cy8c95x0_pin_dbg_show,\n};\n\nstatic const char *cy8c95x0_get_function_name(struct pinctrl_dev *pctldev, unsigned int selector)\n{\n\treturn cy8c95x0_get_fname(selector);\n}\n\nstatic int cy8c95x0_get_functions_count(struct pinctrl_dev *pctldev)\n{\n\treturn 2;\n}\n\nstatic int cy8c95x0_get_function_groups(struct pinctrl_dev *pctldev, unsigned int selector,\n\t\t\t\t\tconst char * const **groups,\n\t\t\t\t\tunsigned int * const num_groups)\n{\n\tstruct cy8c95x0_pinctrl *chip = pinctrl_dev_get_drvdata(pctldev);\n\n\t*groups = cy8c95x0_groups;\n\t*num_groups = chip->tpin;\n\treturn 0;\n}\n\nstatic int cy8c95x0_set_mode(struct cy8c95x0_pinctrl *chip, unsigned int off, bool mode)\n{\n\tu8 port = cypress_get_port(chip, off);\n\tu8 bit = cypress_get_pin_mask(chip, off);\n\tint ret;\n\n\t \n\tret = regmap_write(chip->regmap, CY8C95X0_PORTSEL, port);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn regmap_write_bits(chip->regmap, CY8C95X0_PWMSEL, bit, mode ? bit : 0);\n}\n\nstatic int cy8c95x0_pinmux_mode(struct cy8c95x0_pinctrl *chip,\n\t\t\t\tunsigned int selector, unsigned int group)\n{\n\tu8 port = cypress_get_port(chip, group);\n\tu8 bit = cypress_get_pin_mask(chip, group);\n\tint ret;\n\n\tret = cy8c95x0_set_mode(chip, group, selector);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (selector == 0)\n\t\treturn 0;\n\n\t \n\tret = regmap_write_bits(chip->regmap, CY8C95X0_DIRECTION, bit, bit);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn regmap_write_bits(chip->regmap, CY8C95X0_OUTPUT_(port), bit, bit);\n}\n\nstatic int cy8c95x0_set_mux(struct pinctrl_dev *pctldev, unsigned int selector,\n\t\t\t    unsigned int group)\n{\n\tstruct cy8c95x0_pinctrl *chip = pinctrl_dev_get_drvdata(pctldev);\n\tint ret;\n\n\tmutex_lock(&chip->i2c_lock);\n\tret = cy8c95x0_pinmux_mode(chip, selector, group);\n\tmutex_unlock(&chip->i2c_lock);\n\n\treturn ret;\n}\n\nstatic int cy8c95x0_gpio_request_enable(struct pinctrl_dev *pctldev,\n\t\t\t\t\tstruct pinctrl_gpio_range *range,\n\t\t\t\t\tunsigned int pin)\n{\n\tstruct cy8c95x0_pinctrl *chip = pinctrl_dev_get_drvdata(pctldev);\n\tint ret;\n\n\tmutex_lock(&chip->i2c_lock);\n\tret = cy8c95x0_set_mode(chip, pin, false);\n\tmutex_unlock(&chip->i2c_lock);\n\n\treturn ret;\n}\n\nstatic int cy8c95x0_pinmux_direction(struct cy8c95x0_pinctrl *chip,\n\t\t\t\t     unsigned int pin, bool input)\n{\n\tu8 port = cypress_get_port(chip, pin);\n\tu8 bit = cypress_get_pin_mask(chip, pin);\n\tint ret;\n\n\t \n\tret = regmap_write(chip->regmap, CY8C95X0_PORTSEL, port);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_write_bits(chip->regmap, CY8C95X0_DIRECTION, bit, input ? bit : 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (input && test_bit(pin, chip->push_pull)) {\n\t\tret = regmap_write_bits(chip->regmap, CY8C95X0_DRV_HIZ, bit, bit);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t__clear_bit(pin, chip->push_pull);\n\t}\n\n\treturn 0;\n}\n\nstatic int cy8c95x0_gpio_set_direction(struct pinctrl_dev *pctldev,\n\t\t\t\t       struct pinctrl_gpio_range *range,\n\t\t\t\t       unsigned int pin, bool input)\n{\n\tstruct cy8c95x0_pinctrl *chip = pinctrl_dev_get_drvdata(pctldev);\n\tint ret;\n\n\tmutex_lock(&chip->i2c_lock);\n\tret = cy8c95x0_pinmux_direction(chip, pin, input);\n\tmutex_unlock(&chip->i2c_lock);\n\n\treturn ret;\n}\n\nstatic const struct pinmux_ops cy8c95x0_pmxops = {\n\t.get_functions_count = cy8c95x0_get_functions_count,\n\t.get_function_name = cy8c95x0_get_function_name,\n\t.get_function_groups = cy8c95x0_get_function_groups,\n\t.set_mux = cy8c95x0_set_mux,\n\t.gpio_request_enable = cy8c95x0_gpio_request_enable,\n\t.gpio_set_direction = cy8c95x0_gpio_set_direction,\n\t.strict = true,\n};\n\nstatic int cy8c95x0_pinconf_get(struct pinctrl_dev *pctldev, unsigned int pin,\n\t\t\t\tunsigned long *config)\n{\n\tstruct cy8c95x0_pinctrl *chip = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn cy8c95x0_gpio_get_pincfg(chip, pin, config);\n}\n\nstatic int cy8c95x0_pinconf_set(struct pinctrl_dev *pctldev, unsigned int pin,\n\t\t\t\tunsigned long *configs, unsigned int num_configs)\n{\n\tstruct cy8c95x0_pinctrl *chip = pinctrl_dev_get_drvdata(pctldev);\n\tint ret = 0;\n\tint i;\n\n\tfor (i = 0; i < num_configs; i++) {\n\t\tret = cy8c95x0_gpio_set_pincfg(chip, pin, configs[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct pinconf_ops cy8c95x0_pinconf_ops = {\n\t.pin_config_get = cy8c95x0_pinconf_get,\n\t.pin_config_set = cy8c95x0_pinconf_set,\n\t.is_generic = true,\n};\n\nstatic int cy8c95x0_irq_setup(struct cy8c95x0_pinctrl *chip, int irq)\n{\n\tstruct gpio_irq_chip *girq = &chip->gpio_chip.irq;\n\tDECLARE_BITMAP(pending_irqs, MAX_LINE);\n\tint ret;\n\n\tmutex_init(&chip->irq_lock);\n\n\tbitmap_zero(pending_irqs, MAX_LINE);\n\n\t \n\tret = cy8c95x0_irq_pending(chip, pending_irqs);\n\tif (ret) {\n\t\tdev_err(chip->dev, \"failed to clear irq status register\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tbitmap_fill(chip->irq_mask, MAX_LINE);\n\n\tgpio_irq_chip_set_chip(girq, &cy8c95x0_irqchip);\n\n\t \n\tgirq->parent_handler = NULL;\n\tgirq->num_parents = 0;\n\tgirq->parents = NULL;\n\tgirq->default_type = IRQ_TYPE_NONE;\n\tgirq->handler = handle_simple_irq;\n\tgirq->threaded = true;\n\n\tret = devm_request_threaded_irq(chip->dev, irq,\n\t\t\t\t\tNULL, cy8c95x0_irq_handler,\n\t\t\t\t\tIRQF_ONESHOT | IRQF_SHARED | IRQF_TRIGGER_HIGH,\n\t\t\t\t\tdev_name(chip->dev), chip);\n\tif (ret) {\n\t\tdev_err(chip->dev, \"failed to request irq %d\\n\", irq);\n\t\treturn ret;\n\t}\n\tdev_info(chip->dev, \"Registered threaded IRQ\\n\");\n\n\treturn 0;\n}\n\nstatic int cy8c95x0_setup_pinctrl(struct cy8c95x0_pinctrl *chip)\n{\n\tstruct pinctrl_desc *pd = &chip->pinctrl_desc;\n\n\tpd->pctlops = &cy8c95x0_pinctrl_ops;\n\tpd->confops = &cy8c95x0_pinconf_ops;\n\tpd->pmxops = &cy8c95x0_pmxops;\n\tpd->name = dev_name(chip->dev);\n\tpd->pins = cy8c9560_pins;\n\tpd->npins = chip->tpin;\n\tpd->owner = THIS_MODULE;\n\n\tchip->pctldev = devm_pinctrl_register(chip->dev, pd, chip);\n\tif (IS_ERR(chip->pctldev))\n\t\treturn dev_err_probe(chip->dev, PTR_ERR(chip->pctldev),\n\t\t\t\"can't register controller\\n\");\n\n\treturn 0;\n}\n\nstatic int cy8c95x0_detect(struct i2c_client *client,\n\t\t\t   struct i2c_board_info *info)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tint ret;\n\tconst char *name;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -ENODEV;\n\n\tret = i2c_smbus_read_byte_data(client, CY8C95X0_DEVID);\n\tif (ret < 0)\n\t\treturn ret;\n\tswitch (ret & GENMASK(7, 4)) {\n\tcase 0x20:\n\t\tname = cy8c95x0_id[0].name;\n\t\tbreak;\n\tcase 0x40:\n\t\tname = cy8c95x0_id[1].name;\n\t\tbreak;\n\tcase 0x60:\n\t\tname = cy8c95x0_id[2].name;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\tdev_info(&client->dev, \"Found a %s chip at 0x%02x.\\n\", name, client->addr);\n\tstrscpy(info->type, name, I2C_NAME_SIZE);\n\n\treturn 0;\n}\n\nstatic int cy8c95x0_probe(struct i2c_client *client)\n{\n\tstruct cy8c95x0_pinctrl *chip;\n\tstruct regulator *reg;\n\tint ret;\n\n\tchip = devm_kzalloc(&client->dev, sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tchip->dev = &client->dev;\n\n\t \n\tchip->driver_data = (unsigned long)device_get_match_data(&client->dev);\n\tif (!chip->driver_data)\n\t\tchip->driver_data = i2c_match_id(cy8c95x0_id, client)->driver_data;\n\tif (!chip->driver_data)\n\t\treturn -ENODEV;\n\n\ti2c_set_clientdata(client, chip);\n\n\tchip->tpin = chip->driver_data & CY8C95X0_GPIO_MASK;\n\tchip->nport = DIV_ROUND_UP(CY8C95X0_PIN_TO_OFFSET(chip->tpin), BANK_SZ);\n\n\tswitch (chip->tpin) {\n\tcase 20:\n\t\tstrscpy(chip->name, cy8c95x0_id[0].name, I2C_NAME_SIZE);\n\t\tbreak;\n\tcase 40:\n\t\tstrscpy(chip->name, cy8c95x0_id[1].name, I2C_NAME_SIZE);\n\t\tbreak;\n\tcase 60:\n\t\tstrscpy(chip->name, cy8c95x0_id[2].name, I2C_NAME_SIZE);\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\treg = devm_regulator_get(&client->dev, \"vdd\");\n\tif (IS_ERR(reg)) {\n\t\tif (PTR_ERR(reg) == -EPROBE_DEFER)\n\t\t\treturn -EPROBE_DEFER;\n\t} else {\n\t\tret = regulator_enable(reg);\n\t\tif (ret) {\n\t\t\tdev_err(&client->dev, \"failed to enable regulator vdd: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tchip->regulator = reg;\n\t}\n\n\t \n\tchip->gpio_reset = devm_gpiod_get_optional(&client->dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(chip->gpio_reset)) {\n\t\tret = dev_err_probe(chip->dev, PTR_ERR(chip->gpio_reset),\n\t\t\t\t    \"Failed to get GPIO 'reset'\\n\");\n\t\tgoto err_exit;\n\t} else if (chip->gpio_reset) {\n\t\tusleep_range(1000, 2000);\n\t\tgpiod_set_value_cansleep(chip->gpio_reset, 0);\n\t\tusleep_range(250000, 300000);\n\n\t\tgpiod_set_consumer_name(chip->gpio_reset, \"CY8C95X0 RESET\");\n\t}\n\n\tchip->regmap = devm_regmap_init_i2c(client, &cy8c95x0_i2c_regmap);\n\tif (IS_ERR(chip->regmap)) {\n\t\tret = PTR_ERR(chip->regmap);\n\t\tgoto err_exit;\n\t}\n\n\tbitmap_zero(chip->push_pull, MAX_LINE);\n\tbitmap_zero(chip->shiftmask, MAX_LINE);\n\tbitmap_set(chip->shiftmask, 0, 20);\n\tmutex_init(&chip->i2c_lock);\n\n\tif (dmi_first_match(cy8c95x0_dmi_acpi_irq_info)) {\n\t\tret = cy8c95x0_acpi_get_irq(&client->dev);\n\t\tif (ret > 0)\n\t\t\tclient->irq = ret;\n\t}\n\n\tif (client->irq) {\n\t\tret = cy8c95x0_irq_setup(chip, client->irq);\n\t\tif (ret)\n\t\t\tgoto err_exit;\n\t}\n\n\tret = cy8c95x0_setup_pinctrl(chip);\n\tif (ret)\n\t\tgoto err_exit;\n\n\tret = cy8c95x0_setup_gpiochip(chip);\n\tif (ret)\n\t\tgoto err_exit;\n\n\treturn 0;\n\nerr_exit:\n\tif (!IS_ERR_OR_NULL(chip->regulator))\n\t\tregulator_disable(chip->regulator);\n\treturn ret;\n}\n\nstatic void cy8c95x0_remove(struct i2c_client *client)\n{\n\tstruct cy8c95x0_pinctrl *chip = i2c_get_clientdata(client);\n\n\tif (!IS_ERR_OR_NULL(chip->regulator))\n\t\tregulator_disable(chip->regulator);\n}\n\nstatic const struct acpi_device_id cy8c95x0_acpi_ids[] = {\n\t{ \"INT3490\", 40, },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, cy8c95x0_acpi_ids);\n\nstatic struct i2c_driver cy8c95x0_driver = {\n\t.driver = {\n\t\t.name\t= \"cy8c95x0-pinctrl\",\n\t\t.of_match_table = cy8c95x0_dt_ids,\n\t\t.acpi_match_table = cy8c95x0_acpi_ids,\n\t},\n\t.probe\t\t= cy8c95x0_probe,\n\t.remove\t\t= cy8c95x0_remove,\n\t.id_table\t= cy8c95x0_id,\n\t.detect\t\t= cy8c95x0_detect,\n};\nmodule_i2c_driver(cy8c95x0_driver);\n\nMODULE_AUTHOR(\"Patrick Rudolph <patrick.rudolph@9elements.com>\");\nMODULE_AUTHOR(\"Naresh Solanki <naresh.solanki@9elements.com>\");\nMODULE_DESCRIPTION(\"Pinctrl driver for CY8C95X0\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}