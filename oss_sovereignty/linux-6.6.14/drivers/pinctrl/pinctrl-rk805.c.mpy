{
  "module_name": "pinctrl-rk805.c",
  "hash_id": "546095356868aaa631490930c4a9567b899136b3f585bf118a6b312ec5f5154a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/pinctrl-rk805.c",
  "human_readable_source": "\n \n\n#include <linux/gpio/driver.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mfd/rk808.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/property.h>\n#include <linux/slab.h>\n\n#include <linux/pinctrl/consumer.h>\n#include <linux/pinctrl/machine.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinconf-generic.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinmux.h>\n\n#include \"core.h\"\n#include \"pinconf.h\"\n#include \"pinctrl-utils.h\"\n\nstruct rk805_pin_function {\n\tconst char *name;\n\tconst char *const *groups;\n\tunsigned int ngroups;\n\tint mux_option;\n};\n\nstruct rk805_pin_group {\n\tconst char *name;\n\tconst unsigned int pins[1];\n\tunsigned int npins;\n};\n\n \nstruct rk805_pin_config {\n\tu8 reg;\n\tu8 fun_reg;\n\tu8 fun_msk;\n\tu8 dir_msk;\n\tu8 val_msk;\n};\n\nstruct rk805_pctrl_info {\n\tstruct rk808 *rk808;\n\tstruct device *dev;\n\tstruct pinctrl_dev *pctl;\n\tstruct gpio_chip gpio_chip;\n\tstruct pinctrl_desc pinctrl_desc;\n\tconst struct rk805_pin_function *functions;\n\tunsigned int num_functions;\n\tconst struct rk805_pin_group *groups;\n\tint num_pin_groups;\n\tconst struct pinctrl_pin_desc *pins;\n\tunsigned int num_pins;\n\tconst struct rk805_pin_config *pin_cfg;\n};\n\nenum rk805_pinmux_option {\n\tRK805_PINMUX_GPIO,\n};\n\nenum rk806_pinmux_option {\n\tRK806_PINMUX_FUN0 = 0,\n\tRK806_PINMUX_FUN1,\n\tRK806_PINMUX_FUN2,\n\tRK806_PINMUX_FUN3,\n\tRK806_PINMUX_FUN4,\n\tRK806_PINMUX_FUN5,\n};\n\nenum {\n\tRK805_GPIO0,\n\tRK805_GPIO1,\n};\n\nenum {\n\tRK806_GPIO_DVS1,\n\tRK806_GPIO_DVS2,\n\tRK806_GPIO_DVS3\n};\n\nstatic const char *const rk805_gpio_groups[] = {\n\t\"gpio0\",\n\t\"gpio1\",\n};\n\nstatic const char *const rk806_gpio_groups[] = {\n\t\"gpio_pwrctrl1\",\n\t\"gpio_pwrctrl2\",\n\t\"gpio_pwrctrl3\",\n};\n\n \nstatic const struct pinctrl_pin_desc rk805_pins_desc[] = {\n\tPINCTRL_PIN(RK805_GPIO0, \"gpio0\"),\n\tPINCTRL_PIN(RK805_GPIO1, \"gpio1\"),\n};\n\n \nstatic const struct pinctrl_pin_desc rk806_pins_desc[] = {\n\tPINCTRL_PIN(RK806_GPIO_DVS1, \"gpio_pwrctrl1\"),\n\tPINCTRL_PIN(RK806_GPIO_DVS2, \"gpio_pwrctrl2\"),\n\tPINCTRL_PIN(RK806_GPIO_DVS3, \"gpio_pwrctrl3\"),\n};\n\nstatic const struct rk805_pin_function rk805_pin_functions[] = {\n\t{\n\t\t.name = \"gpio\",\n\t\t.groups = rk805_gpio_groups,\n\t\t.ngroups = ARRAY_SIZE(rk805_gpio_groups),\n\t\t.mux_option = RK805_PINMUX_GPIO,\n\t},\n};\n\nstatic const struct rk805_pin_function rk806_pin_functions[] = {\n\t{\n\t\t.name = \"pin_fun0\",\n\t\t.groups = rk806_gpio_groups,\n\t\t.ngroups = ARRAY_SIZE(rk806_gpio_groups),\n\t\t.mux_option = RK806_PINMUX_FUN0,\n\t},\n\t{\n\t\t.name = \"pin_fun1\",\n\t\t.groups = rk806_gpio_groups,\n\t\t.ngroups = ARRAY_SIZE(rk806_gpio_groups),\n\t\t.mux_option = RK806_PINMUX_FUN1,\n\t},\n\t{\n\t\t.name = \"pin_fun2\",\n\t\t.groups = rk806_gpio_groups,\n\t\t.ngroups = ARRAY_SIZE(rk806_gpio_groups),\n\t\t.mux_option = RK806_PINMUX_FUN2,\n\t},\n\t{\n\t\t.name = \"pin_fun3\",\n\t\t.groups = rk806_gpio_groups,\n\t\t.ngroups = ARRAY_SIZE(rk806_gpio_groups),\n\t\t.mux_option = RK806_PINMUX_FUN3,\n\t},\n\t{\n\t\t.name = \"pin_fun4\",\n\t\t.groups = rk806_gpio_groups,\n\t\t.ngroups = ARRAY_SIZE(rk806_gpio_groups),\n\t\t.mux_option = RK806_PINMUX_FUN4,\n\t},\n\t{\n\t\t.name = \"pin_fun5\",\n\t\t.groups = rk806_gpio_groups,\n\t\t.ngroups = ARRAY_SIZE(rk806_gpio_groups),\n\t\t.mux_option = RK806_PINMUX_FUN5,\n\t},\n};\n\nstatic const struct rk805_pin_group rk805_pin_groups[] = {\n\t{\n\t\t.name = \"gpio0\",\n\t\t.pins = { RK805_GPIO0 },\n\t\t.npins = 1,\n\t},\n\t{\n\t\t.name = \"gpio1\",\n\t\t.pins = { RK805_GPIO1 },\n\t\t.npins = 1,\n\t},\n};\n\nstatic const struct rk805_pin_group rk806_pin_groups[] = {\n\t{\n\t\t.name = \"gpio_pwrctrl1\",\n\t\t.pins = { RK806_GPIO_DVS1 },\n\t\t.npins = 1,\n\t},\n\t{\n\t\t.name = \"gpio_pwrctrl2\",\n\t\t.pins = { RK806_GPIO_DVS2 },\n\t\t.npins = 1,\n\t},\n\t{\n\t\t.name = \"gpio_pwrctrl3\",\n\t\t.pins = { RK806_GPIO_DVS3 },\n\t\t.npins = 1,\n\t}\n};\n\n#define RK805_GPIO0_VAL_MSK\tBIT(0)\n#define RK805_GPIO1_VAL_MSK\tBIT(1)\n\nstatic const struct rk805_pin_config rk805_gpio_cfgs[] = {\n\t{\n\t\t.reg = RK805_OUT_REG,\n\t\t.val_msk = RK805_GPIO0_VAL_MSK,\n\t},\n\t{\n\t\t.reg = RK805_OUT_REG,\n\t\t.val_msk = RK805_GPIO1_VAL_MSK,\n\t},\n};\n\n#define RK806_PWRCTRL1_DR\tBIT(0)\n#define RK806_PWRCTRL2_DR\tBIT(1)\n#define RK806_PWRCTRL3_DR\tBIT(2)\n#define RK806_PWRCTRL1_DATA\tBIT(4)\n#define RK806_PWRCTRL2_DATA\tBIT(5)\n#define RK806_PWRCTRL3_DATA\tBIT(6)\n#define RK806_PWRCTRL1_FUN\tGENMASK(2, 0)\n#define RK806_PWRCTRL2_FUN\tGENMASK(6, 4)\n#define RK806_PWRCTRL3_FUN\tGENMASK(2, 0)\n\nstatic struct rk805_pin_config rk806_gpio_cfgs[] = {\n\t{\n\t\t.fun_reg = RK806_SLEEP_CONFIG0,\n\t\t.fun_msk = RK806_PWRCTRL1_FUN,\n\t\t.reg = RK806_SLEEP_GPIO,\n\t\t.val_msk = RK806_PWRCTRL1_DATA,\n\t\t.dir_msk = RK806_PWRCTRL1_DR,\n\t},\n\t{\n\t\t.fun_reg = RK806_SLEEP_CONFIG0,\n\t\t.fun_msk = RK806_PWRCTRL2_FUN,\n\t\t.reg = RK806_SLEEP_GPIO,\n\t\t.val_msk = RK806_PWRCTRL2_DATA,\n\t\t.dir_msk = RK806_PWRCTRL2_DR,\n\t},\n\t{\n\t\t.fun_reg = RK806_SLEEP_CONFIG1,\n\t\t.fun_msk = RK806_PWRCTRL3_FUN,\n\t\t.reg = RK806_SLEEP_GPIO,\n\t\t.val_msk = RK806_PWRCTRL3_DATA,\n\t\t.dir_msk = RK806_PWRCTRL3_DR,\n\t}\n};\n\n \nstatic int rk805_gpio_get(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct rk805_pctrl_info *pci = gpiochip_get_data(chip);\n\tint ret, val;\n\n\tret = regmap_read(pci->rk808->regmap, pci->pin_cfg[offset].reg, &val);\n\tif (ret) {\n\t\tdev_err(pci->dev, \"get gpio%d value failed\\n\", offset);\n\t\treturn ret;\n\t}\n\n\treturn !!(val & pci->pin_cfg[offset].val_msk);\n}\n\nstatic void rk805_gpio_set(struct gpio_chip *chip,\n\t\t\t   unsigned int offset,\n\t\t\t   int value)\n{\n\tstruct rk805_pctrl_info *pci = gpiochip_get_data(chip);\n\tint ret;\n\n\tret = regmap_update_bits(pci->rk808->regmap,\n\t\t\t\t pci->pin_cfg[offset].reg,\n\t\t\t\t pci->pin_cfg[offset].val_msk,\n\t\t\t\t value ? pci->pin_cfg[offset].val_msk : 0);\n\tif (ret)\n\t\tdev_err(pci->dev, \"set gpio%d value %d failed\\n\",\n\t\t\toffset, value);\n}\n\nstatic int rk805_gpio_direction_input(struct gpio_chip *chip,\n\t\t\t\t      unsigned int offset)\n{\n\treturn pinctrl_gpio_direction_input(chip->base + offset);\n}\n\nstatic int rk805_gpio_direction_output(struct gpio_chip *chip,\n\t\t\t\t       unsigned int offset, int value)\n{\n\trk805_gpio_set(chip, offset, value);\n\treturn pinctrl_gpio_direction_output(chip->base + offset);\n}\n\nstatic int rk805_gpio_get_direction(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct rk805_pctrl_info *pci = gpiochip_get_data(chip);\n\tunsigned int val;\n\tint ret;\n\n\t \n\tif (!pci->pin_cfg[offset].dir_msk)\n\t\treturn GPIO_LINE_DIRECTION_OUT;\n\n\tret = regmap_read(pci->rk808->regmap,\n\t\t\t  pci->pin_cfg[offset].reg,\n\t\t\t  &val);\n\tif (ret) {\n\t\tdev_err(pci->dev, \"get gpio%d direction failed\\n\", offset);\n\t\treturn ret;\n\t}\n\n\tif (val & pci->pin_cfg[offset].dir_msk)\n\t\treturn GPIO_LINE_DIRECTION_OUT;\n\n\treturn GPIO_LINE_DIRECTION_IN;\n}\n\nstatic const struct gpio_chip rk805_gpio_chip = {\n\t.label\t\t\t= \"rk805-gpio\",\n\t.request\t\t= gpiochip_generic_request,\n\t.free\t\t\t= gpiochip_generic_free,\n\t.get_direction\t\t= rk805_gpio_get_direction,\n\t.get\t\t\t= rk805_gpio_get,\n\t.set\t\t\t= rk805_gpio_set,\n\t.direction_input\t= rk805_gpio_direction_input,\n\t.direction_output\t= rk805_gpio_direction_output,\n\t.can_sleep\t\t= true,\n\t.base\t\t\t= -1,\n\t.owner\t\t\t= THIS_MODULE,\n};\n\n \nstatic int rk805_pinctrl_get_groups_count(struct pinctrl_dev *pctldev)\n{\n\tstruct rk805_pctrl_info *pci = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pci->num_pin_groups;\n}\n\nstatic const char *rk805_pinctrl_get_group_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t\tunsigned int group)\n{\n\tstruct rk805_pctrl_info *pci = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pci->groups[group].name;\n}\n\nstatic int rk805_pinctrl_get_group_pins(struct pinctrl_dev *pctldev,\n\t\t\t\t\tunsigned int group,\n\t\t\t\t\tconst unsigned int **pins,\n\t\t\t\t\tunsigned int *num_pins)\n{\n\tstruct rk805_pctrl_info *pci = pinctrl_dev_get_drvdata(pctldev);\n\n\t*pins = pci->groups[group].pins;\n\t*num_pins = pci->groups[group].npins;\n\n\treturn 0;\n}\n\nstatic const struct pinctrl_ops rk805_pinctrl_ops = {\n\t.get_groups_count = rk805_pinctrl_get_groups_count,\n\t.get_group_name = rk805_pinctrl_get_group_name,\n\t.get_group_pins = rk805_pinctrl_get_group_pins,\n\t.dt_node_to_map = pinconf_generic_dt_node_to_map_pin,\n\t.dt_free_map = pinctrl_utils_free_map,\n};\n\nstatic int rk805_pinctrl_get_funcs_count(struct pinctrl_dev *pctldev)\n{\n\tstruct rk805_pctrl_info *pci = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pci->num_functions;\n}\n\nstatic const char *rk805_pinctrl_get_func_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t       unsigned int function)\n{\n\tstruct rk805_pctrl_info *pci = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pci->functions[function].name;\n}\n\nstatic int rk805_pinctrl_get_func_groups(struct pinctrl_dev *pctldev,\n\t\t\t\t\t unsigned int function,\n\t\t\t\t\t const char *const **groups,\n\t\t\t\t\t unsigned int *const num_groups)\n{\n\tstruct rk805_pctrl_info *pci = pinctrl_dev_get_drvdata(pctldev);\n\n\t*groups = pci->functions[function].groups;\n\t*num_groups = pci->functions[function].ngroups;\n\n\treturn 0;\n}\n\nstatic int _rk805_pinctrl_set_mux(struct pinctrl_dev *pctldev,\n\t\t\t\t  unsigned int offset,\n\t\t\t\t  int mux)\n{\n\tstruct rk805_pctrl_info *pci = pinctrl_dev_get_drvdata(pctldev);\n\tint ret;\n\n\tif (!pci->pin_cfg[offset].fun_msk)\n\t\treturn 0;\n\n\tmux <<= ffs(pci->pin_cfg[offset].fun_msk) - 1;\n\tret = regmap_update_bits(pci->rk808->regmap,\n\t\t\t\t pci->pin_cfg[offset].fun_reg,\n\t\t\t\t pci->pin_cfg[offset].fun_msk, mux);\n\n\tif (ret)\n\t\tdev_err(pci->dev, \"set gpio%d func%d failed\\n\", offset, mux);\n\n\treturn 0;\n}\n\nstatic int rk805_pinctrl_set_mux(struct pinctrl_dev *pctldev,\n\t\t\t\t unsigned int function,\n\t\t\t\t unsigned int group)\n{\n\tstruct rk805_pctrl_info *pci = pinctrl_dev_get_drvdata(pctldev);\n\tint mux = pci->functions[function].mux_option;\n\tint offset = group;\n\n\treturn _rk805_pinctrl_set_mux(pctldev, offset, mux);\n}\n\nstatic int rk805_pinctrl_gpio_request_enable(struct pinctrl_dev *pctldev,\n\t\t\t\t\t     struct pinctrl_gpio_range *range,\n\t\t\t\t\t     unsigned int offset)\n{\n\tstruct rk805_pctrl_info *pci = pinctrl_dev_get_drvdata(pctldev);\n\n\tswitch (pci->rk808->variant) {\n\tcase RK805_ID:\n\t\treturn _rk805_pinctrl_set_mux(pctldev, offset, RK805_PINMUX_GPIO);\n\tcase RK806_ID:\n\t\treturn _rk805_pinctrl_set_mux(pctldev, offset, RK806_PINMUX_FUN5);\n\t}\n\n\treturn -ENOTSUPP;\n}\n\nstatic int rk805_pmx_gpio_set_direction(struct pinctrl_dev *pctldev,\n\t\t\t\t\tstruct pinctrl_gpio_range *range,\n\t\t\t\t\tunsigned int offset, bool input)\n{\n\tstruct rk805_pctrl_info *pci = pinctrl_dev_get_drvdata(pctldev);\n\tint ret;\n\n\t \n\tif (!pci->pin_cfg[offset].dir_msk)\n\t\treturn 0;\n\n\tret = regmap_update_bits(pci->rk808->regmap,\n\t\t\t\t pci->pin_cfg[offset].reg,\n\t\t\t\t pci->pin_cfg[offset].dir_msk,\n\t\t\t\t input ? 0 : pci->pin_cfg[offset].dir_msk);\n\tif (ret) {\n\t\tdev_err(pci->dev, \"set gpio%d direction failed\\n\", offset);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct pinmux_ops rk805_pinmux_ops = {\n\t.get_functions_count\t= rk805_pinctrl_get_funcs_count,\n\t.get_function_name\t= rk805_pinctrl_get_func_name,\n\t.get_function_groups\t= rk805_pinctrl_get_func_groups,\n\t.set_mux\t\t= rk805_pinctrl_set_mux,\n\t.gpio_request_enable\t= rk805_pinctrl_gpio_request_enable,\n\t.gpio_set_direction\t= rk805_pmx_gpio_set_direction,\n};\n\nstatic int rk805_pinconf_get(struct pinctrl_dev *pctldev,\n\t\t\t     unsigned int pin, unsigned long *config)\n{\n\tstruct rk805_pctrl_info *pci = pinctrl_dev_get_drvdata(pctldev);\n\tenum pin_config_param param = pinconf_to_config_param(*config);\n\tu32 arg = 0;\n\n\tswitch (param) {\n\tcase PIN_CONFIG_OUTPUT:\n\tcase PIN_CONFIG_INPUT_ENABLE:\n\t\targ = rk805_gpio_get(&pci->gpio_chip, pin);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(pci->dev, \"Properties not supported\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\t*config = pinconf_to_config_packed(param, (u16)arg);\n\n\treturn 0;\n}\n\nstatic int rk805_pinconf_set(struct pinctrl_dev *pctldev,\n\t\t\t     unsigned int pin, unsigned long *configs,\n\t\t\t     unsigned int num_configs)\n{\n\tstruct rk805_pctrl_info *pci = pinctrl_dev_get_drvdata(pctldev);\n\tenum pin_config_param param;\n\tu32 i, arg = 0;\n\n\tfor (i = 0; i < num_configs; i++) {\n\t\tparam = pinconf_to_config_param(configs[i]);\n\t\targ = pinconf_to_config_argument(configs[i]);\n\n\t\tswitch (param) {\n\t\tcase PIN_CONFIG_OUTPUT:\n\t\t\trk805_gpio_set(&pci->gpio_chip, pin, arg);\n\t\t\trk805_pmx_gpio_set_direction(pctldev, NULL, pin, false);\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_INPUT_ENABLE:\n\t\t\tif (pci->rk808->variant != RK805_ID && arg) {\n\t\t\t\trk805_pmx_gpio_set_direction(pctldev, NULL, pin, true);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\tdev_err(pci->dev, \"Properties not supported\\n\");\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct pinconf_ops rk805_pinconf_ops = {\n\t.pin_config_get = rk805_pinconf_get,\n\t.pin_config_set = rk805_pinconf_set,\n};\n\nstatic const struct pinctrl_desc rk805_pinctrl_desc = {\n\t.name = \"rk805-pinctrl\",\n\t.pctlops = &rk805_pinctrl_ops,\n\t.pmxops = &rk805_pinmux_ops,\n\t.confops = &rk805_pinconf_ops,\n\t.owner = THIS_MODULE,\n};\n\nstatic int rk805_pinctrl_probe(struct platform_device *pdev)\n{\n\tstruct rk805_pctrl_info *pci;\n\tint ret;\n\n\tdevice_set_node(&pdev->dev, dev_fwnode(pdev->dev.parent));\n\n\tpci = devm_kzalloc(&pdev->dev, sizeof(*pci), GFP_KERNEL);\n\tif (!pci)\n\t\treturn -ENOMEM;\n\n\tpci->dev = &pdev->dev;\n\tpci->rk808 = dev_get_drvdata(pdev->dev.parent);\n\n\tpci->pinctrl_desc = rk805_pinctrl_desc;\n\tpci->gpio_chip = rk805_gpio_chip;\n\tpci->gpio_chip.parent = &pdev->dev;\n\n\tplatform_set_drvdata(pdev, pci);\n\n\tswitch (pci->rk808->variant) {\n\tcase RK805_ID:\n\t\tpci->pins = rk805_pins_desc;\n\t\tpci->num_pins = ARRAY_SIZE(rk805_pins_desc);\n\t\tpci->functions = rk805_pin_functions;\n\t\tpci->num_functions = ARRAY_SIZE(rk805_pin_functions);\n\t\tpci->groups = rk805_pin_groups;\n\t\tpci->num_pin_groups = ARRAY_SIZE(rk805_pin_groups);\n\t\tpci->pinctrl_desc.pins = rk805_pins_desc;\n\t\tpci->pinctrl_desc.npins = ARRAY_SIZE(rk805_pins_desc);\n\t\tpci->pin_cfg = rk805_gpio_cfgs;\n\t\tpci->gpio_chip.ngpio = ARRAY_SIZE(rk805_gpio_cfgs);\n\t\tbreak;\n\tcase RK806_ID:\n\t\tpci->pins = rk806_pins_desc;\n\t\tpci->num_pins = ARRAY_SIZE(rk806_pins_desc);\n\t\tpci->functions = rk806_pin_functions;\n\t\tpci->num_functions = ARRAY_SIZE(rk806_pin_functions);\n\t\tpci->groups = rk806_pin_groups;\n\t\tpci->num_pin_groups = ARRAY_SIZE(rk806_pin_groups);\n\t\tpci->pinctrl_desc.pins = rk806_pins_desc;\n\t\tpci->pinctrl_desc.npins = ARRAY_SIZE(rk806_pins_desc);\n\t\tpci->pin_cfg = rk806_gpio_cfgs;\n\t\tpci->gpio_chip.ngpio = ARRAY_SIZE(rk806_gpio_cfgs);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&pdev->dev, \"unsupported RK805 ID %lu\\n\",\n\t\t\tpci->rk808->variant);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = devm_gpiochip_add_data(&pdev->dev, &pci->gpio_chip, pci);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Couldn't add gpiochip\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tpci->pctl = devm_pinctrl_register(&pdev->dev, &pci->pinctrl_desc, pci);\n\tif (IS_ERR(pci->pctl)) {\n\t\tdev_err(&pdev->dev, \"Couldn't add pinctrl\\n\");\n\t\treturn PTR_ERR(pci->pctl);\n\t}\n\n\t \n\tret = gpiochip_add_pin_range(&pci->gpio_chip, dev_name(&pdev->dev),\n\t\t\t\t     0, 0, pci->gpio_chip.ngpio);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Couldn't add gpiochip pin range\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver rk805_pinctrl_driver = {\n\t.probe = rk805_pinctrl_probe,\n\t.driver = {\n\t\t.name = \"rk805-pinctrl\",\n\t},\n};\nmodule_platform_driver(rk805_pinctrl_driver);\n\nMODULE_DESCRIPTION(\"RK805 pin control and GPIO driver\");\nMODULE_AUTHOR(\"Xu Shengfei <xsf@rock-chips.com>\");\nMODULE_AUTHOR(\"Joseph Chen <chenjh@rock-chips.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}