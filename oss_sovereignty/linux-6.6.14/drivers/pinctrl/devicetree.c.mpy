{
  "module_name": "devicetree.c",
  "hash_id": "f9ec3a372bd3489a6a63521b344ea2a33a88324b264f2ed884a064f18b5dc8da",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/devicetree.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/of.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/slab.h>\n\n#include \"core.h\"\n#include \"devicetree.h\"\n\n \nstruct pinctrl_dt_map {\n\tstruct list_head node;\n\tstruct pinctrl_dev *pctldev;\n\tstruct pinctrl_map *map;\n\tunsigned num_maps;\n};\n\nstatic void dt_free_map(struct pinctrl_dev *pctldev,\n\t\t     struct pinctrl_map *map, unsigned num_maps)\n{\n\tint i;\n\n\tfor (i = 0; i < num_maps; ++i) {\n\t\tkfree_const(map[i].dev_name);\n\t\tmap[i].dev_name = NULL;\n\t}\n\n\tif (pctldev) {\n\t\tconst struct pinctrl_ops *ops = pctldev->desc->pctlops;\n\t\tif (ops->dt_free_map)\n\t\t\tops->dt_free_map(pctldev, map, num_maps);\n\t} else {\n\t\t \n\t\tkfree(map);\n\t}\n}\n\nvoid pinctrl_dt_free_maps(struct pinctrl *p)\n{\n\tstruct pinctrl_dt_map *dt_map, *n1;\n\n\tlist_for_each_entry_safe(dt_map, n1, &p->dt_maps, node) {\n\t\tpinctrl_unregister_mappings(dt_map->map);\n\t\tlist_del(&dt_map->node);\n\t\tdt_free_map(dt_map->pctldev, dt_map->map,\n\t\t\t    dt_map->num_maps);\n\t\tkfree(dt_map);\n\t}\n\n\tof_node_put(p->dev->of_node);\n}\n\nstatic int dt_remember_or_free_map(struct pinctrl *p, const char *statename,\n\t\t\t\t   struct pinctrl_dev *pctldev,\n\t\t\t\t   struct pinctrl_map *map, unsigned num_maps)\n{\n\tint i;\n\tstruct pinctrl_dt_map *dt_map;\n\n\t \n\tfor (i = 0; i < num_maps; i++) {\n\t\tconst char *devname;\n\n\t\tdevname = kstrdup_const(dev_name(p->dev), GFP_KERNEL);\n\t\tif (!devname)\n\t\t\tgoto err_free_map;\n\n\t\tmap[i].dev_name = devname;\n\t\tmap[i].name = statename;\n\t\tif (pctldev)\n\t\t\tmap[i].ctrl_dev_name = dev_name(pctldev->dev);\n\t}\n\n\t \n\tdt_map = kzalloc(sizeof(*dt_map), GFP_KERNEL);\n\tif (!dt_map)\n\t\tgoto err_free_map;\n\n\tdt_map->pctldev = pctldev;\n\tdt_map->map = map;\n\tdt_map->num_maps = num_maps;\n\tlist_add_tail(&dt_map->node, &p->dt_maps);\n\n\treturn pinctrl_register_mappings(map, num_maps);\n\nerr_free_map:\n\tdt_free_map(pctldev, map, num_maps);\n\treturn -ENOMEM;\n}\n\nstruct pinctrl_dev *of_pinctrl_get(struct device_node *np)\n{\n\treturn get_pinctrl_dev_from_of_node(np);\n}\nEXPORT_SYMBOL_GPL(of_pinctrl_get);\n\nstatic int dt_to_map_one_config(struct pinctrl *p,\n\t\t\t\tstruct pinctrl_dev *hog_pctldev,\n\t\t\t\tconst char *statename,\n\t\t\t\tstruct device_node *np_config)\n{\n\tstruct pinctrl_dev *pctldev = NULL;\n\tstruct device_node *np_pctldev;\n\tconst struct pinctrl_ops *ops;\n\tint ret;\n\tstruct pinctrl_map *map;\n\tunsigned num_maps;\n\tbool allow_default = false;\n\n\t \n\tnp_pctldev = of_node_get(np_config);\n\tfor (;;) {\n\t\tif (!allow_default)\n\t\t\tallow_default = of_property_read_bool(np_pctldev,\n\t\t\t\t\t\t\t      \"pinctrl-use-default\");\n\n\t\tnp_pctldev = of_get_next_parent(np_pctldev);\n\t\tif (!np_pctldev || of_node_is_root(np_pctldev)) {\n\t\t\tof_node_put(np_pctldev);\n\t\t\tret = -ENODEV;\n\t\t\t \n\t\t\tif (IS_ENABLED(CONFIG_MODULES) && !allow_default && ret < 0)\n\t\t\t\tret = -EPROBE_DEFER;\n\t\t\treturn ret;\n\t\t}\n\t\t \n\t\tif (hog_pctldev && (np_pctldev == p->dev->of_node)) {\n\t\t\tpctldev = hog_pctldev;\n\t\t\tbreak;\n\t\t}\n\t\tpctldev = get_pinctrl_dev_from_of_node(np_pctldev);\n\t\tif (pctldev)\n\t\t\tbreak;\n\t\t \n\t\tif (np_pctldev == p->dev->of_node) {\n\t\t\tof_node_put(np_pctldev);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\tof_node_put(np_pctldev);\n\n\t \n\tops = pctldev->desc->pctlops;\n\tif (!ops->dt_node_to_map) {\n\t\tdev_err(p->dev, \"pctldev %s doesn't support DT\\n\",\n\t\t\tdev_name(pctldev->dev));\n\t\treturn -ENODEV;\n\t}\n\tret = ops->dt_node_to_map(pctldev, np_config, &map, &num_maps);\n\tif (ret < 0)\n\t\treturn ret;\n\telse if (num_maps == 0) {\n\t\t \n\t\tdev_info(p->dev,\n\t\t\t \"there is not valid maps for state %s\\n\", statename);\n\t\treturn 0;\n\t}\n\n\t \n\treturn dt_remember_or_free_map(p, statename, pctldev, map, num_maps);\n}\n\nstatic int dt_remember_dummy_state(struct pinctrl *p, const char *statename)\n{\n\tstruct pinctrl_map *map;\n\n\tmap = kzalloc(sizeof(*map), GFP_KERNEL);\n\tif (!map)\n\t\treturn -ENOMEM;\n\n\t \n\tmap->type = PIN_MAP_TYPE_DUMMY_STATE;\n\n\treturn dt_remember_or_free_map(p, statename, NULL, map, 1);\n}\n\nint pinctrl_dt_to_map(struct pinctrl *p, struct pinctrl_dev *pctldev)\n{\n\tstruct device_node *np = p->dev->of_node;\n\tint state, ret;\n\tchar *propname;\n\tstruct property *prop;\n\tconst char *statename;\n\tconst __be32 *list;\n\tint size, config;\n\tphandle phandle;\n\tstruct device_node *np_config;\n\n\t \n\tif (!np) {\n\t\tif (of_have_populated_dt())\n\t\t\tdev_dbg(p->dev,\n\t\t\t\t\"no of_node; not parsing pinctrl DT\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tof_node_get(np);\n\n\t \n\tfor (state = 0; ; state++) {\n\t\t \n\t\tpropname = kasprintf(GFP_KERNEL, \"pinctrl-%d\", state);\n\t\tif (!propname)\n\t\t\treturn -ENOMEM;\n\t\tprop = of_find_property(np, propname, &size);\n\t\tkfree(propname);\n\t\tif (!prop) {\n\t\t\tif (state == 0) {\n\t\t\t\tof_node_put(np);\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tlist = prop->value;\n\t\tsize /= sizeof(*list);\n\n\t\t \n\t\tret = of_property_read_string_index(np, \"pinctrl-names\",\n\t\t\t\t\t\t    state, &statename);\n\t\t \n\t\tif (ret < 0)\n\t\t\tstatename = prop->name + strlen(\"pinctrl-\");\n\n\t\t \n\t\tfor (config = 0; config < size; config++) {\n\t\t\tphandle = be32_to_cpup(list++);\n\n\t\t\t \n\t\t\tnp_config = of_find_node_by_phandle(phandle);\n\t\t\tif (!np_config) {\n\t\t\t\tdev_err(p->dev,\n\t\t\t\t\t\"prop %s index %i invalid phandle\\n\",\n\t\t\t\t\tprop->name, config);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\t \n\t\t\tret = dt_to_map_one_config(p, pctldev, statename,\n\t\t\t\t\t\t   np_config);\n\t\t\tof_node_put(np_config);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err;\n\t\t}\n\n\t\t \n\t\tif (!size) {\n\t\t\tret = dt_remember_dummy_state(p, statename);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr:\n\tpinctrl_dt_free_maps(p);\n\treturn ret;\n}\n\n \nstatic int pinctrl_find_cells_size(const struct device_node *np)\n{\n\tconst char *cells_name = \"#pinctrl-cells\";\n\tint cells_size, error;\n\n\terror = of_property_read_u32(np->parent, cells_name, &cells_size);\n\tif (error) {\n\t\terror = of_property_read_u32(np->parent->parent,\n\t\t\t\t\t     cells_name, &cells_size);\n\t\tif (error)\n\t\t\treturn -ENOENT;\n\t}\n\n\treturn cells_size;\n}\n\n \nstatic int pinctrl_get_list_and_count(const struct device_node *np,\n\t\t\t\t      const char *list_name,\n\t\t\t\t      const __be32 **list,\n\t\t\t\t      int *cells_size,\n\t\t\t\t      int *nr_elements)\n{\n\tint size;\n\n\t*cells_size = 0;\n\t*nr_elements = 0;\n\n\t*list = of_get_property(np, list_name, &size);\n\tif (!*list)\n\t\treturn -ENOENT;\n\n\t*cells_size = pinctrl_find_cells_size(np);\n\tif (*cells_size < 0)\n\t\treturn -ENOENT;\n\n\t \n\t*nr_elements = (size / sizeof(**list)) / (*cells_size + 1);\n\n\treturn 0;\n}\n\n \nint pinctrl_count_index_with_args(const struct device_node *np,\n\t\t\t\t  const char *list_name)\n{\n\tconst __be32 *list;\n\tint size, nr_cells, error;\n\n\terror = pinctrl_get_list_and_count(np, list_name, &list,\n\t\t\t\t\t   &nr_cells, &size);\n\tif (error)\n\t\treturn error;\n\n\treturn size;\n}\nEXPORT_SYMBOL_GPL(pinctrl_count_index_with_args);\n\n \nstatic int pinctrl_copy_args(const struct device_node *np,\n\t\t\t     const __be32 *list,\n\t\t\t     int index, int nr_cells, int nr_elem,\n\t\t\t     struct of_phandle_args *out_args)\n{\n\tint i;\n\n\tmemset(out_args, 0, sizeof(*out_args));\n\tout_args->np = (struct device_node *)np;\n\tout_args->args_count = nr_cells + 1;\n\n\tif (index >= nr_elem)\n\t\treturn -EINVAL;\n\n\tlist += index * (nr_cells + 1);\n\n\tfor (i = 0; i < nr_cells + 1; i++)\n\t\tout_args->args[i] = be32_to_cpup(list++);\n\n\treturn 0;\n}\n\n \nint pinctrl_parse_index_with_args(const struct device_node *np,\n\t\t\t\t  const char *list_name, int index,\n\t\t\t\t  struct of_phandle_args *out_args)\n{\n\tconst __be32 *list;\n\tint nr_elem, nr_cells, error;\n\n\terror = pinctrl_get_list_and_count(np, list_name, &list,\n\t\t\t\t\t   &nr_cells, &nr_elem);\n\tif (error || !nr_cells)\n\t\treturn error;\n\n\terror = pinctrl_copy_args(np, list, index, nr_cells, nr_elem,\n\t\t\t\t  out_args);\n\tif (error)\n\t\treturn error;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(pinctrl_parse_index_with_args);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}