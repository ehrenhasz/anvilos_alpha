{
  "module_name": "pinctrl-ns.c",
  "hash_id": "90318757d8b7f5d60782b0ef6977b713939277f859de0e18d290705d0bf88ee6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/bcm/pinctrl-ns.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/pinctrl/pinconf-generic.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinmux.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include \"../core.h\"\n#include \"../pinmux.h\"\n\n#define FLAG_BCM4708\t\tBIT(1)\n#define FLAG_BCM4709\t\tBIT(2)\n#define FLAG_BCM53012\t\tBIT(3)\n\nstruct ns_pinctrl {\n\tstruct device *dev;\n\tunsigned int chipset_flag;\n\tstruct pinctrl_dev *pctldev;\n\tvoid __iomem *base;\n\n\tstruct pinctrl_desc pctldesc;\n};\n\n \n\nstatic const struct pinctrl_pin_desc ns_pinctrl_pins[] = {\n\t{ 0, \"spi_clk\", (void *)(FLAG_BCM4708 | FLAG_BCM4709 | FLAG_BCM53012) },\n\t{ 1, \"spi_ss\", (void *)(FLAG_BCM4708 | FLAG_BCM4709 | FLAG_BCM53012) },\n\t{ 2, \"spi_mosi\", (void *)(FLAG_BCM4708 | FLAG_BCM4709 | FLAG_BCM53012) },\n\t{ 3, \"spi_miso\", (void *)(FLAG_BCM4708 | FLAG_BCM4709 | FLAG_BCM53012) },\n\t{ 4, \"i2c_scl\", (void *)(FLAG_BCM4708 | FLAG_BCM4709 | FLAG_BCM53012) },\n\t{ 5, \"i2c_sda\", (void *)(FLAG_BCM4708 | FLAG_BCM4709 | FLAG_BCM53012) },\n\t{ 6, \"mdc\", (void *)(FLAG_BCM4709 | FLAG_BCM53012) },\n\t{ 7, \"mdio\", (void *)(FLAG_BCM4709 | FLAG_BCM53012) },\n\t{ 8, \"pwm0\", (void *)(FLAG_BCM4708 | FLAG_BCM4709 | FLAG_BCM53012) },\n\t{ 9, \"pwm1\", (void *)(FLAG_BCM4708 | FLAG_BCM4709 | FLAG_BCM53012) },\n\t{ 10, \"pwm2\", (void *)(FLAG_BCM4708 | FLAG_BCM4709 | FLAG_BCM53012) },\n\t{ 11, \"pwm3\", (void *)(FLAG_BCM4708 | FLAG_BCM4709 | FLAG_BCM53012) },\n\t{ 12, \"uart1_rx\", (void *)(FLAG_BCM4708 | FLAG_BCM4709 | FLAG_BCM53012) },\n\t{ 13, \"uart1_tx\", (void *)(FLAG_BCM4708 | FLAG_BCM4709 | FLAG_BCM53012) },\n\t{ 14, \"uart1_cts\", (void *)(FLAG_BCM4708 | FLAG_BCM4709 | FLAG_BCM53012) },\n\t{ 15, \"uart1_rts\", (void *)(FLAG_BCM4708 | FLAG_BCM4709 | FLAG_BCM53012) },\n\t{ 16, \"uart2_rx\", (void *)(FLAG_BCM4709 | FLAG_BCM53012) },\n\t{ 17, \"uart2_tx\", (void *)(FLAG_BCM4709 | FLAG_BCM53012) },\n \n\t{ 22, \"sdio_pwr\", (void *)(FLAG_BCM4709 | FLAG_BCM53012) },\n\t{ 23, \"sdio_en_1p8v\", (void *)(FLAG_BCM4709 | FLAG_BCM53012) },\n};\n\n \n\nstruct ns_pinctrl_group {\n\tconst char *name;\n\tunsigned int *pins;\n\tconst unsigned int num_pins;\n\tunsigned int chipsets;\n};\n\nstatic unsigned int spi_pins[] = { 0, 1, 2, 3 };\nstatic unsigned int i2c_pins[] = { 4, 5 };\nstatic unsigned int mdio_pins[] = { 6, 7 };\nstatic unsigned int pwm0_pins[] = { 8 };\nstatic unsigned int pwm1_pins[] = { 9 };\nstatic unsigned int pwm2_pins[] = { 10 };\nstatic unsigned int pwm3_pins[] = { 11 };\nstatic unsigned int uart1_pins[] = { 12, 13, 14, 15 };\nstatic unsigned int uart2_pins[] = { 16, 17 };\nstatic unsigned int sdio_pwr_pins[] = { 22 };\nstatic unsigned int sdio_1p8v_pins[] = { 23 };\n\n#define NS_GROUP(_name, _pins, _chipsets)\t\t\\\n{\t\t\t\t\t\t\t\\\n\t.name = _name,\t\t\t\t\t\\\n\t.pins = _pins,\t\t\t\t\t\\\n\t.num_pins = ARRAY_SIZE(_pins),\t\t\t\\\n\t.chipsets = _chipsets,\t\t\t\t\\\n}\n\nstatic const struct ns_pinctrl_group ns_pinctrl_groups[] = {\n\tNS_GROUP(\"spi_grp\", spi_pins, FLAG_BCM4708 | FLAG_BCM4709 | FLAG_BCM53012),\n\tNS_GROUP(\"i2c_grp\", i2c_pins, FLAG_BCM4708 | FLAG_BCM4709 | FLAG_BCM53012),\n\tNS_GROUP(\"mdio_grp\", mdio_pins, FLAG_BCM4709 | FLAG_BCM53012),\n\tNS_GROUP(\"pwm0_grp\", pwm0_pins, FLAG_BCM4708 | FLAG_BCM4709 | FLAG_BCM53012),\n\tNS_GROUP(\"pwm1_grp\", pwm1_pins, FLAG_BCM4708 | FLAG_BCM4709 | FLAG_BCM53012),\n\tNS_GROUP(\"pwm2_grp\", pwm2_pins, FLAG_BCM4708 | FLAG_BCM4709 | FLAG_BCM53012),\n\tNS_GROUP(\"pwm3_grp\", pwm3_pins, FLAG_BCM4708 | FLAG_BCM4709 | FLAG_BCM53012),\n\tNS_GROUP(\"uart1_grp\", uart1_pins, FLAG_BCM4708 | FLAG_BCM4709 | FLAG_BCM53012),\n\tNS_GROUP(\"uart2_grp\", uart2_pins, FLAG_BCM4709 | FLAG_BCM53012),\n\tNS_GROUP(\"sdio_pwr_grp\", sdio_pwr_pins, FLAG_BCM4709 | FLAG_BCM53012),\n\tNS_GROUP(\"sdio_1p8v_grp\", sdio_1p8v_pins, FLAG_BCM4709 | FLAG_BCM53012),\n};\n\n \n\nstruct ns_pinctrl_function {\n\tconst char *name;\n\tconst char * const *groups;\n\tconst unsigned int num_groups;\n\tunsigned int chipsets;\n};\n\nstatic const char * const spi_groups[] = { \"spi_grp\" };\nstatic const char * const i2c_groups[] = { \"i2c_grp\" };\nstatic const char * const mdio_groups[] = { \"mdio_grp\" };\nstatic const char * const pwm_groups[] = { \"pwm0_grp\", \"pwm1_grp\", \"pwm2_grp\",\n\t\t\t\t\t   \"pwm3_grp\" };\nstatic const char * const uart1_groups[] = { \"uart1_grp\" };\nstatic const char * const uart2_groups[] = { \"uart2_grp\" };\nstatic const char * const sdio_groups[] = { \"sdio_pwr_grp\", \"sdio_1p8v_grp\" };\n\n#define NS_FUNCTION(_name, _groups, _chipsets)\t\t\\\n{\t\t\t\t\t\t\t\\\n\t.name = _name,\t\t\t\t\t\\\n\t.groups = _groups,\t\t\t\t\\\n\t.num_groups = ARRAY_SIZE(_groups),\t\t\\\n\t.chipsets = _chipsets,\t\t\t\t\\\n}\n\nstatic const struct ns_pinctrl_function ns_pinctrl_functions[] = {\n\tNS_FUNCTION(\"spi\", spi_groups, FLAG_BCM4708 | FLAG_BCM4709 | FLAG_BCM53012),\n\tNS_FUNCTION(\"i2c\", i2c_groups, FLAG_BCM4708 | FLAG_BCM4709 | FLAG_BCM53012),\n\tNS_FUNCTION(\"mdio\", mdio_groups, FLAG_BCM4709 | FLAG_BCM53012),\n\tNS_FUNCTION(\"pwm\", pwm_groups, FLAG_BCM4708 | FLAG_BCM4709 | FLAG_BCM53012),\n\tNS_FUNCTION(\"uart1\", uart1_groups, FLAG_BCM4708 | FLAG_BCM4709 | FLAG_BCM53012),\n\tNS_FUNCTION(\"uart2\", uart2_groups, FLAG_BCM4709 | FLAG_BCM53012),\n\tNS_FUNCTION(\"sdio\", sdio_groups, FLAG_BCM4709 | FLAG_BCM53012),\n};\n\n \n\nstatic const struct pinctrl_ops ns_pinctrl_ops = {\n\t.get_groups_count = pinctrl_generic_get_group_count,\n\t.get_group_name = pinctrl_generic_get_group_name,\n\t.get_group_pins = pinctrl_generic_get_group_pins,\n\t.dt_node_to_map = pinconf_generic_dt_node_to_map_group,\n\t.dt_free_map = pinconf_generic_dt_free_map,\n};\n\n \n\nstatic int ns_pinctrl_set_mux(struct pinctrl_dev *pctrl_dev,\n\t\t\t      unsigned int func_select,\n\t\t\t      unsigned int group_selector)\n{\n\tstruct ns_pinctrl *ns_pinctrl = pinctrl_dev_get_drvdata(pctrl_dev);\n\tstruct group_desc *group;\n\tu32 unset = 0;\n\tu32 tmp;\n\tint i;\n\n\tgroup = pinctrl_generic_get_group(pctrl_dev, group_selector);\n\tif (!group)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < group->num_pins; i++)\n\t\tunset |= BIT(group->pins[i]);\n\n\ttmp = readl(ns_pinctrl->base);\n\ttmp &= ~unset;\n\twritel(tmp, ns_pinctrl->base);\n\n\treturn 0;\n}\n\nstatic const struct pinmux_ops ns_pinctrl_pmxops = {\n\t.get_functions_count = pinmux_generic_get_function_count,\n\t.get_function_name = pinmux_generic_get_function_name,\n\t.get_function_groups = pinmux_generic_get_function_groups,\n\t.set_mux = ns_pinctrl_set_mux,\n};\n\n \n\nstatic struct pinctrl_desc ns_pinctrl_desc = {\n\t.name = \"pinctrl-ns\",\n\t.pctlops = &ns_pinctrl_ops,\n\t.pmxops = &ns_pinctrl_pmxops,\n};\n\nstatic const struct of_device_id ns_pinctrl_of_match_table[] = {\n\t{ .compatible = \"brcm,bcm4708-pinmux\", .data = (void *)FLAG_BCM4708, },\n\t{ .compatible = \"brcm,bcm4709-pinmux\", .data = (void *)FLAG_BCM4709, },\n\t{ .compatible = \"brcm,bcm53012-pinmux\", .data = (void *)FLAG_BCM53012, },\n\t{ }\n};\n\nstatic int ns_pinctrl_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tconst struct of_device_id *of_id;\n\tstruct ns_pinctrl *ns_pinctrl;\n\tstruct pinctrl_desc *pctldesc;\n\tstruct pinctrl_pin_desc *pin;\n\tstruct resource *res;\n\tint i;\n\n\tns_pinctrl = devm_kzalloc(dev, sizeof(*ns_pinctrl), GFP_KERNEL);\n\tif (!ns_pinctrl)\n\t\treturn -ENOMEM;\n\tpctldesc = &ns_pinctrl->pctldesc;\n\tplatform_set_drvdata(pdev, ns_pinctrl);\n\n\t \n\n\tns_pinctrl->dev = dev;\n\n\tof_id = of_match_device(ns_pinctrl_of_match_table, dev);\n\tif (!of_id)\n\t\treturn -EINVAL;\n\tns_pinctrl->chipset_flag = (uintptr_t)of_id->data;\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\n\t\t\t\t\t   \"cru_gpio_control\");\n\tns_pinctrl->base = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(ns_pinctrl->base))\n\t\treturn PTR_ERR(ns_pinctrl->base);\n\n\tmemcpy(pctldesc, &ns_pinctrl_desc, sizeof(*pctldesc));\n\n\t \n\n\tpctldesc->pins = devm_kcalloc(dev, ARRAY_SIZE(ns_pinctrl_pins),\n\t\t\t\t      sizeof(struct pinctrl_pin_desc),\n\t\t\t\t      GFP_KERNEL);\n\tif (!pctldesc->pins)\n\t\treturn -ENOMEM;\n\tfor (i = 0, pin = (struct pinctrl_pin_desc *)&pctldesc->pins[0];\n\t     i < ARRAY_SIZE(ns_pinctrl_pins); i++) {\n\t\tconst struct pinctrl_pin_desc *src = &ns_pinctrl_pins[i];\n\t\tunsigned int chipsets = (uintptr_t)src->drv_data;\n\n\t\tif (chipsets & ns_pinctrl->chipset_flag) {\n\t\t\tmemcpy(pin++, src, sizeof(*src));\n\t\t\tpctldesc->npins++;\n\t\t}\n\t}\n\n\t \n\n\tns_pinctrl->pctldev = devm_pinctrl_register(dev, pctldesc, ns_pinctrl);\n\tif (IS_ERR(ns_pinctrl->pctldev)) {\n\t\tdev_err(dev, \"Failed to register pinctrl\\n\");\n\t\treturn PTR_ERR(ns_pinctrl->pctldev);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(ns_pinctrl_groups); i++) {\n\t\tconst struct ns_pinctrl_group *group = &ns_pinctrl_groups[i];\n\n\t\tif (!(group->chipsets & ns_pinctrl->chipset_flag))\n\t\t\tcontinue;\n\n\t\tpinctrl_generic_add_group(ns_pinctrl->pctldev, group->name,\n\t\t\t\t\t  group->pins, group->num_pins, NULL);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(ns_pinctrl_functions); i++) {\n\t\tconst struct ns_pinctrl_function *function = &ns_pinctrl_functions[i];\n\n\t\tif (!(function->chipsets & ns_pinctrl->chipset_flag))\n\t\t\tcontinue;\n\n\t\tpinmux_generic_add_function(ns_pinctrl->pctldev, function->name,\n\t\t\t\t\t    function->groups,\n\t\t\t\t\t    function->num_groups, NULL);\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver ns_pinctrl_driver = {\n\t.probe = ns_pinctrl_probe,\n\t.driver = {\n\t\t.name = \"ns-pinmux\",\n\t\t.of_match_table = ns_pinctrl_of_match_table,\n\t},\n};\n\nmodule_platform_driver(ns_pinctrl_driver);\n\nMODULE_AUTHOR(\"Rafa\u0142 Mi\u0142ecki\");\nMODULE_DEVICE_TABLE(of, ns_pinctrl_of_match_table);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}