{
  "module_name": "pinctrl-nsp-mux.c",
  "hash_id": "7045cb36d4f3cef9f8a4b878aac002f477f8754dc51013a7926715652beacb58",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/bcm/pinctrl-nsp-mux.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n\n#include <linux/pinctrl/pinconf-generic.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinmux.h>\n\n#include \"../core.h\"\n#include \"../pinctrl-utils.h\"\n\n#define NSP_MUX_BASE0\t0x00\n#define NSP_MUX_BASE1\t0x01\n#define NSP_MUX_BASE2\t0x02\n \nstruct nsp_mux {\n\tunsigned int base;\n\tunsigned int shift;\n\tunsigned int mask;\n\tunsigned int alt;\n};\n\n \nstruct nsp_mux_log {\n\tstruct nsp_mux mux;\n\tbool is_configured;\n};\n\n \nstruct nsp_pin_group {\n\tconst char *name;\n\tconst unsigned int *pins;\n\tconst unsigned int num_pins;\n\tconst struct nsp_mux mux;\n};\n\n \nstruct nsp_pin_function {\n\tconst char *name;\n\tconst char * const *groups;\n\tconst unsigned int num_groups;\n};\n\n \nstruct nsp_pinctrl {\n\tstruct pinctrl_dev *pctl;\n\tstruct device *dev;\n\tvoid __iomem *base0;\n\tvoid __iomem *base1;\n\tvoid __iomem *base2;\n\tconst struct nsp_pin_group *groups;\n\tunsigned int num_groups;\n\tconst struct nsp_pin_function *functions;\n\tunsigned int num_functions;\n\tstruct nsp_mux_log *mux_log;\n\tspinlock_t lock;\n};\n\n \nstruct nsp_pin {\n\tunsigned int pin;\n\tchar *name;\n\tunsigned int gpio_select;\n};\n\n#define NSP_PIN_DESC(p, n, g)\t\t\\\n{\t\t\t\t\t\\\n\t.pin = p,\t\t\t\\\n\t.name = n,\t\t\t\\\n\t.gpio_select = g,\t\t\\\n}\n\n \nstatic struct nsp_pin nsp_pins[] = {\n\tNSP_PIN_DESC(0, \"spi_clk\", 1),\n\tNSP_PIN_DESC(1, \"spi_ss\", 1),\n\tNSP_PIN_DESC(2, \"spi_mosi\", 1),\n\tNSP_PIN_DESC(3, \"spi_miso\", 1),\n\tNSP_PIN_DESC(4, \"scl\", 1),\n\tNSP_PIN_DESC(5, \"sda\", 1),\n\tNSP_PIN_DESC(6, \"mdc\", 1),\n\tNSP_PIN_DESC(7, \"mdio\", 1),\n\tNSP_PIN_DESC(8, \"pwm0\", 1),\n\tNSP_PIN_DESC(9, \"pwm1\", 1),\n\tNSP_PIN_DESC(10, \"pwm2\", 1),\n\tNSP_PIN_DESC(11, \"pwm3\", 1),\n\tNSP_PIN_DESC(12, \"uart1_rx\", 1),\n\tNSP_PIN_DESC(13, \"uart1_tx\", 1),\n\tNSP_PIN_DESC(14, \"uart1_cts\", 1),\n\tNSP_PIN_DESC(15, \"uart1_rts\", 1),\n\tNSP_PIN_DESC(16, \"uart2_rx\", 1),\n\tNSP_PIN_DESC(17, \"uart2_tx\", 1),\n\tNSP_PIN_DESC(18, \"synce\", 0),\n\tNSP_PIN_DESC(19, \"sata0_led\", 0),\n\tNSP_PIN_DESC(20, \"sata1_led\", 0),\n\tNSP_PIN_DESC(21, \"xtal_out\", 1),\n\tNSP_PIN_DESC(22, \"sdio_pwr\", 1),\n\tNSP_PIN_DESC(23, \"sdio_en_1p8v\", 1),\n\tNSP_PIN_DESC(24, \"gpio_24\", 1),\n\tNSP_PIN_DESC(25, \"gpio_25\", 1),\n\tNSP_PIN_DESC(26, \"p5_led0\", 0),\n\tNSP_PIN_DESC(27, \"p5_led1\", 0),\n\tNSP_PIN_DESC(28, \"gpio_28\", 1),\n\tNSP_PIN_DESC(29, \"gpio_29\", 1),\n\tNSP_PIN_DESC(30, \"gpio_30\", 1),\n\tNSP_PIN_DESC(31, \"gpio_31\", 1),\n\tNSP_PIN_DESC(32, \"nand_ale\", 0),\n\tNSP_PIN_DESC(33, \"nand_ce0\", 0),\n\tNSP_PIN_DESC(34, \"nand_r/b\", 0),\n\tNSP_PIN_DESC(35, \"nand_dq0\", 0),\n\tNSP_PIN_DESC(36, \"nand_dq1\", 0),\n\tNSP_PIN_DESC(37, \"nand_dq2\", 0),\n\tNSP_PIN_DESC(38, \"nand_dq3\", 0),\n\tNSP_PIN_DESC(39, \"nand_dq4\", 0),\n\tNSP_PIN_DESC(40, \"nand_dq5\", 0),\n\tNSP_PIN_DESC(41, \"nand_dq6\", 0),\n\tNSP_PIN_DESC(42, \"nand_dq7\", 0),\n};\n\n \n\nstatic const unsigned int spi_pins[] = {0, 1, 2, 3};\nstatic const unsigned int i2c_pins[] = {4, 5};\nstatic const unsigned int mdio_pins[] = {6, 7};\nstatic const unsigned int pwm0_pins[] = {8};\nstatic const unsigned int gpio_b_0_pins[] = {8};\nstatic const unsigned int pwm1_pins[] = {9};\nstatic const unsigned int gpio_b_1_pins[] = {9};\nstatic const unsigned int pwm2_pins[] = {10};\nstatic const unsigned int gpio_b_2_pins[] = {10};\nstatic const unsigned int pwm3_pins[] = {11};\nstatic const unsigned int gpio_b_3_pins[] = {11};\nstatic const unsigned int uart1_pins[] = {12, 13, 14, 15};\nstatic const unsigned int uart2_pins[] = {16, 17};\nstatic const unsigned int synce_pins[] = {18};\nstatic const unsigned int sata0_led_pins[] = {19};\nstatic const unsigned int sata1_led_pins[] = {20};\nstatic const unsigned int xtal_out_pins[] = {21};\nstatic const unsigned int sdio_pwr_pins[] = {22};\nstatic const unsigned int sdio_1p8v_pins[] = {23};\nstatic const unsigned int switch_p05_led0_pins[] = {26};\nstatic const unsigned int switch_p05_led1_pins[] = {27};\nstatic const unsigned int nand_pins[] = {32, 33, 34, 35, 36, 37, 38, 39,\n\t\t\t\t\t\t\t40, 41, 42};\nstatic const unsigned int emmc_pins[] = {32, 33, 34, 35, 36, 37, 38, 39,\n\t\t\t\t\t\t\t40, 41, 42};\n\n#define NSP_PIN_GROUP(group_name, ba, sh, ma, al)\t\\\n{\t\t\t\t\t\t\t\\\n\t.name = __stringify(group_name) \"_grp\",\t\t\\\n\t.pins = group_name ## _pins,\t\t\t\\\n\t.num_pins = ARRAY_SIZE(group_name ## _pins),\t\\\n\t.mux = {\t\t\t\t\t\\\n\t\t.base = ba,\t\t\t\t\\\n\t\t.shift = sh,\t\t\t\t\\\n\t\t.mask = ma,\t\t\t\t\\\n\t\t.alt = al,\t\t\t\t\\\n\t}\t\t\t\t\t\t\\\n}\n\n \nstatic const struct nsp_pin_group nsp_pin_groups[] = {\n\tNSP_PIN_GROUP(spi, NSP_MUX_BASE0, 0, 0x0f, 0x00),\n\tNSP_PIN_GROUP(i2c, NSP_MUX_BASE0, 3, 0x03, 0x00),\n\tNSP_PIN_GROUP(mdio, NSP_MUX_BASE0, 5, 0x03, 0x00),\n\tNSP_PIN_GROUP(gpio_b_0, NSP_MUX_BASE0, 7, 0x01, 0x00),\n\tNSP_PIN_GROUP(pwm0, NSP_MUX_BASE1, 0, 0x01, 0x01),\n\tNSP_PIN_GROUP(gpio_b_1, NSP_MUX_BASE0, 8, 0x01, 0x00),\n\tNSP_PIN_GROUP(pwm1, NSP_MUX_BASE1, 1, 0x01, 0x01),\n\tNSP_PIN_GROUP(gpio_b_2, NSP_MUX_BASE0, 9, 0x01, 0x00),\n\tNSP_PIN_GROUP(pwm2, NSP_MUX_BASE1, 2, 0x01, 0x01),\n\tNSP_PIN_GROUP(gpio_b_3, NSP_MUX_BASE0, 10, 0x01, 0x00),\n\tNSP_PIN_GROUP(pwm3, NSP_MUX_BASE1, 3, 0x01, 0x01),\n\tNSP_PIN_GROUP(uart1, NSP_MUX_BASE0, 11, 0x0f, 0x00),\n\tNSP_PIN_GROUP(uart2, NSP_MUX_BASE0, 15, 0x03, 0x00),\n\tNSP_PIN_GROUP(synce, NSP_MUX_BASE0, 17, 0x01, 0x01),\n\tNSP_PIN_GROUP(sata0_led, NSP_MUX_BASE0, 18, 0x01, 0x01),\n\tNSP_PIN_GROUP(sata1_led, NSP_MUX_BASE0, 19, 0x01, 0x01),\n\tNSP_PIN_GROUP(xtal_out, NSP_MUX_BASE0, 20, 0x01, 0x00),\n\tNSP_PIN_GROUP(sdio_pwr, NSP_MUX_BASE0, 21, 0x01, 0x00),\n\tNSP_PIN_GROUP(sdio_1p8v, NSP_MUX_BASE0, 22, 0x01, 0x00),\n\tNSP_PIN_GROUP(switch_p05_led0, NSP_MUX_BASE0, 26, 0x01, 0x01),\n\tNSP_PIN_GROUP(switch_p05_led1, NSP_MUX_BASE0, 27, 0x01, 0x01),\n\tNSP_PIN_GROUP(nand, NSP_MUX_BASE2, 0, 0x01, 0x00),\n\tNSP_PIN_GROUP(emmc, NSP_MUX_BASE2, 0, 0x01, 0x01)\n};\n\n \n\nstatic const char * const spi_grps[] = {\"spi_grp\"};\nstatic const char * const i2c_grps[] = {\"i2c_grp\"};\nstatic const char * const mdio_grps[] = {\"mdio_grp\"};\nstatic const char * const pwm_grps[] = {\"pwm0_grp\", \"pwm1_grp\", \"pwm2_grp\"\n\t\t\t\t\t\t, \"pwm3_grp\"};\nstatic const char * const gpio_b_grps[] = {\"gpio_b_0_grp\", \"gpio_b_1_grp\",\n\t\t\t\t\t\"gpio_b_2_grp\", \"gpio_b_3_grp\"};\nstatic const char * const uart1_grps[] = {\"uart1_grp\"};\nstatic const char * const uart2_grps[] = {\"uart2_grp\"};\nstatic const char * const synce_grps[] = {\"synce_grp\"};\nstatic const char * const sata_led_grps[] = {\"sata0_led_grp\", \"sata1_led_grp\"};\nstatic const char * const xtal_out_grps[] = {\"xtal_out_grp\"};\nstatic const char * const sdio_grps[] = {\"sdio_pwr_grp\", \"sdio_1p8v_grp\"};\nstatic const char * const switch_led_grps[] = {\"switch_p05_led0_grp\",\n\t\t\t\t\t\t\"switch_p05_led1_grp\"};\nstatic const char * const nand_grps[] = {\"nand_grp\"};\nstatic const char * const emmc_grps[] = {\"emmc_grp\"};\n\n#define NSP_PIN_FUNCTION(func)\t\t\t\t\\\n{\t\t\t\t\t\t\t\\\n\t.name = #func,\t\t\t\t\t\\\n\t.groups = func ## _grps,\t\t\t\\\n\t.num_groups = ARRAY_SIZE(func ## _grps),\t\\\n}\n\n \nstatic const struct nsp_pin_function nsp_pin_functions[] = {\n\tNSP_PIN_FUNCTION(spi),\n\tNSP_PIN_FUNCTION(i2c),\n\tNSP_PIN_FUNCTION(mdio),\n\tNSP_PIN_FUNCTION(pwm),\n\tNSP_PIN_FUNCTION(gpio_b),\n\tNSP_PIN_FUNCTION(uart1),\n\tNSP_PIN_FUNCTION(uart2),\n\tNSP_PIN_FUNCTION(synce),\n\tNSP_PIN_FUNCTION(sata_led),\n\tNSP_PIN_FUNCTION(xtal_out),\n\tNSP_PIN_FUNCTION(sdio),\n\tNSP_PIN_FUNCTION(switch_led),\n\tNSP_PIN_FUNCTION(nand),\n\tNSP_PIN_FUNCTION(emmc)\n};\n\nstatic int nsp_get_groups_count(struct pinctrl_dev *pctrl_dev)\n{\n\tstruct nsp_pinctrl *pinctrl = pinctrl_dev_get_drvdata(pctrl_dev);\n\n\treturn pinctrl->num_groups;\n}\n\nstatic const char *nsp_get_group_name(struct pinctrl_dev *pctrl_dev,\n\t\t\t\t      unsigned int selector)\n{\n\tstruct nsp_pinctrl *pinctrl = pinctrl_dev_get_drvdata(pctrl_dev);\n\n\treturn pinctrl->groups[selector].name;\n}\n\nstatic int nsp_get_group_pins(struct pinctrl_dev *pctrl_dev,\n\t\t\t      unsigned int selector, const unsigned int **pins,\n\t\t\t      unsigned int *num_pins)\n{\n\tstruct nsp_pinctrl *pinctrl = pinctrl_dev_get_drvdata(pctrl_dev);\n\n\t*pins = pinctrl->groups[selector].pins;\n\t*num_pins = pinctrl->groups[selector].num_pins;\n\n\treturn 0;\n}\n\nstatic void nsp_pin_dbg_show(struct pinctrl_dev *pctrl_dev,\n\t\t\t     struct seq_file *s, unsigned int offset)\n{\n\tseq_printf(s, \" %s\", dev_name(pctrl_dev->dev));\n}\n\nstatic const struct pinctrl_ops nsp_pinctrl_ops = {\n\t.get_groups_count = nsp_get_groups_count,\n\t.get_group_name = nsp_get_group_name,\n\t.get_group_pins = nsp_get_group_pins,\n\t.pin_dbg_show = nsp_pin_dbg_show,\n\t.dt_node_to_map = pinconf_generic_dt_node_to_map_group,\n\t.dt_free_map = pinctrl_utils_free_map,\n};\n\nstatic int nsp_get_functions_count(struct pinctrl_dev *pctrl_dev)\n{\n\tstruct nsp_pinctrl *pinctrl = pinctrl_dev_get_drvdata(pctrl_dev);\n\n\treturn pinctrl->num_functions;\n}\n\nstatic const char *nsp_get_function_name(struct pinctrl_dev *pctrl_dev,\n\t\t\t\t\t unsigned int selector)\n{\n\tstruct nsp_pinctrl *pinctrl = pinctrl_dev_get_drvdata(pctrl_dev);\n\n\treturn pinctrl->functions[selector].name;\n}\n\nstatic int nsp_get_function_groups(struct pinctrl_dev *pctrl_dev,\n\t\t\t\t   unsigned int selector,\n\t\t\t\t   const char * const **groups,\n\t\t\t\t   unsigned * const num_groups)\n{\n\tstruct nsp_pinctrl *pinctrl = pinctrl_dev_get_drvdata(pctrl_dev);\n\n\t*groups = pinctrl->functions[selector].groups;\n\t*num_groups = pinctrl->functions[selector].num_groups;\n\n\treturn 0;\n}\n\nstatic int nsp_pinmux_set(struct nsp_pinctrl *pinctrl,\n\t\t\t  const struct nsp_pin_function *func,\n\t\t\t  const struct nsp_pin_group *grp,\n\t\t\t  struct nsp_mux_log *mux_log)\n{\n\tconst struct nsp_mux *mux = &grp->mux;\n\tint i;\n\tu32 val, mask;\n\tunsigned long flags;\n\tvoid __iomem *base_address;\n\n\tfor (i = 0; i < pinctrl->num_groups; i++) {\n\t\tif ((mux->shift != mux_log[i].mux.shift) ||\n\t\t\t(mux->base != mux_log[i].mux.base))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!mux_log[i].is_configured)\n\t\t\tbreak;\n\n\t\t \n\t\tif (mux_log[i].mux.alt != mux->alt) {\n\t\t\tdev_err(pinctrl->dev,\n\t\t\t\t\"double configuration error detected!\\n\");\n\t\t\tdev_err(pinctrl->dev, \"func:%s grp:%s\\n\",\n\t\t\t\tfunc->name, grp->name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\treturn 0;\n\t}\n\tif (i == pinctrl->num_groups)\n\t\treturn -EINVAL;\n\n\tmask = mux->mask;\n\tmux_log[i].mux.alt = mux->alt;\n\tmux_log[i].is_configured = true;\n\n\tswitch (mux->base) {\n\tcase NSP_MUX_BASE0:\n\t\tbase_address = pinctrl->base0;\n\t\tbreak;\n\n\tcase NSP_MUX_BASE1:\n\t\tbase_address = pinctrl->base1;\n\t\tbreak;\n\n\tcase NSP_MUX_BASE2:\n\t\tbase_address = pinctrl->base2;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(&pinctrl->lock, flags);\n\tval = readl(base_address);\n\tval &= ~(mask << grp->mux.shift);\n\tval |= grp->mux.alt << grp->mux.shift;\n\twritel(val, base_address);\n\tspin_unlock_irqrestore(&pinctrl->lock, flags);\n\n\treturn 0;\n}\n\nstatic int nsp_pinmux_enable(struct pinctrl_dev *pctrl_dev,\n\t\t\t     unsigned int func_select, unsigned int grp_select)\n{\n\tstruct nsp_pinctrl *pinctrl = pinctrl_dev_get_drvdata(pctrl_dev);\n\tconst struct nsp_pin_function *func;\n\tconst struct nsp_pin_group *grp;\n\n\tif (grp_select >= pinctrl->num_groups ||\n\t    func_select >= pinctrl->num_functions)\n\t\treturn -EINVAL;\n\n\tfunc = &pinctrl->functions[func_select];\n\tgrp = &pinctrl->groups[grp_select];\n\n\tdev_dbg(pctrl_dev->dev, \"func:%u name:%s grp:%u name:%s\\n\",\n\t\tfunc_select, func->name, grp_select, grp->name);\n\n\tdev_dbg(pctrl_dev->dev, \"shift:%u alt:%u\\n\", grp->mux.shift,\n\t\tgrp->mux.alt);\n\n\treturn nsp_pinmux_set(pinctrl, func, grp, pinctrl->mux_log);\n}\n\n\nstatic int nsp_gpio_request_enable(struct pinctrl_dev *pctrl_dev,\n\t\t\t\t   struct pinctrl_gpio_range *range,\n\t\t\t\t   unsigned int pin)\n{\n\tstruct nsp_pinctrl *pinctrl = pinctrl_dev_get_drvdata(pctrl_dev);\n\tu32 *gpio_select = pctrl_dev->desc->pins[pin].drv_data;\n\tu32 val;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pinctrl->lock, flags);\n\tval = readl(pinctrl->base0);\n\tif ((val & BIT(pin)) != (*gpio_select << pin)) {\n\t\tval &= ~BIT(pin);\n\t\tval |= *gpio_select << pin;\n\t\twritel(val, pinctrl->base0);\n\t}\n\tspin_unlock_irqrestore(&pinctrl->lock, flags);\n\n\treturn 0;\n}\n\nstatic void nsp_gpio_disable_free(struct pinctrl_dev *pctrl_dev,\n\t\t\t\t  struct pinctrl_gpio_range *range,\n\t\t\t\t  unsigned int pin)\n{\n\tstruct nsp_pinctrl *pinctrl = pinctrl_dev_get_drvdata(pctrl_dev);\n\tu32 *gpio_select = pctrl_dev->desc->pins[pin].drv_data;\n\tu32 val;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pinctrl->lock, flags);\n\tval = readl(pinctrl->base0);\n\tif ((val & (1 << pin)) == (*gpio_select << pin)) {\n\t\tval &= ~(1 << pin);\n\t\tif (!(*gpio_select))\n\t\t\tval |= (1 << pin);\n\t\twritel(val, pinctrl->base0);\n\t}\n\tspin_unlock_irqrestore(&pinctrl->lock, flags);\n}\n\nstatic const struct pinmux_ops nsp_pinmux_ops = {\n\t.get_functions_count = nsp_get_functions_count,\n\t.get_function_name = nsp_get_function_name,\n\t.get_function_groups = nsp_get_function_groups,\n\t.set_mux = nsp_pinmux_enable,\n\t.gpio_request_enable = nsp_gpio_request_enable,\n\t.gpio_disable_free = nsp_gpio_disable_free,\n};\n\nstatic struct pinctrl_desc nsp_pinctrl_desc = {\n\t.name = \"nsp-pinmux\",\n\t.pctlops = &nsp_pinctrl_ops,\n\t.pmxops = &nsp_pinmux_ops,\n};\n\nstatic int nsp_mux_log_init(struct nsp_pinctrl *pinctrl)\n{\n\tstruct nsp_mux_log *log;\n\tunsigned int i;\n\tu32 no_of_groups = ARRAY_SIZE(nsp_pin_groups);\n\n\tpinctrl->mux_log = devm_kcalloc(pinctrl->dev, no_of_groups,\n\t\t\t\t\tsizeof(struct nsp_mux_log),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!pinctrl->mux_log)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < no_of_groups; i++) {\n\t\tlog = &pinctrl->mux_log[i];\n\t\tlog->mux.base = nsp_pin_groups[i].mux.base;\n\t\tlog->mux.shift = nsp_pin_groups[i].mux.shift;\n\t\tlog->mux.alt = 0;\n\t\tlog->is_configured = false;\n\t}\n\n\treturn 0;\n}\n\nstatic int nsp_pinmux_probe(struct platform_device *pdev)\n{\n\tstruct nsp_pinctrl *pinctrl;\n\tstruct resource *res;\n\tint i, ret;\n\tstruct pinctrl_pin_desc *pins;\n\tunsigned int num_pins = ARRAY_SIZE(nsp_pins);\n\n\tpinctrl = devm_kzalloc(&pdev->dev, sizeof(*pinctrl), GFP_KERNEL);\n\tif (!pinctrl)\n\t\treturn -ENOMEM;\n\tpinctrl->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, pinctrl);\n\tspin_lock_init(&pinctrl->lock);\n\n\tpinctrl->base0 = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(pinctrl->base0))\n\t\treturn PTR_ERR(pinctrl->base0);\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\tif (!res)\n\t\treturn -EINVAL;\n\tpinctrl->base1 = devm_ioremap(&pdev->dev, res->start,\n\t\t\t\t\t      resource_size(res));\n\tif (!pinctrl->base1) {\n\t\tdev_err(&pdev->dev, \"unable to map I/O space\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpinctrl->base2 = devm_platform_ioremap_resource(pdev, 2);\n\tif (IS_ERR(pinctrl->base2))\n\t\treturn PTR_ERR(pinctrl->base2);\n\n\tret = nsp_mux_log_init(pinctrl);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"unable to initialize IOMUX log\\n\");\n\t\treturn ret;\n\t}\n\n\tpins = devm_kcalloc(&pdev->dev, num_pins, sizeof(*pins), GFP_KERNEL);\n\tif (!pins)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < num_pins; i++) {\n\t\tpins[i].number = nsp_pins[i].pin;\n\t\tpins[i].name = nsp_pins[i].name;\n\t\tpins[i].drv_data = &nsp_pins[i].gpio_select;\n\t}\n\n\tpinctrl->groups = nsp_pin_groups;\n\tpinctrl->num_groups = ARRAY_SIZE(nsp_pin_groups);\n\tpinctrl->functions = nsp_pin_functions;\n\tpinctrl->num_functions = ARRAY_SIZE(nsp_pin_functions);\n\tnsp_pinctrl_desc.pins = pins;\n\tnsp_pinctrl_desc.npins = num_pins;\n\n\tpinctrl->pctl = devm_pinctrl_register(&pdev->dev, &nsp_pinctrl_desc,\n\t\t\t\t\t pinctrl);\n\tif (IS_ERR(pinctrl->pctl)) {\n\t\tdev_err(&pdev->dev, \"unable to register nsp IOMUX pinctrl\\n\");\n\t\treturn PTR_ERR(pinctrl->pctl);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id nsp_pinmux_of_match[] = {\n\t{ .compatible = \"brcm,nsp-pinmux\" },\n\t{ }\n};\n\nstatic struct platform_driver nsp_pinmux_driver = {\n\t.driver = {\n\t\t.name = \"nsp-pinmux\",\n\t\t.of_match_table = nsp_pinmux_of_match,\n\t},\n\t.probe = nsp_pinmux_probe,\n};\n\nstatic int __init nsp_pinmux_init(void)\n{\n\treturn platform_driver_register(&nsp_pinmux_driver);\n}\narch_initcall(nsp_pinmux_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}