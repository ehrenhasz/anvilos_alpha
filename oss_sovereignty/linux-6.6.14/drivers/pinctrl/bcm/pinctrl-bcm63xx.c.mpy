{
  "module_name": "pinctrl-bcm63xx.c",
  "hash_id": "89e0cd2e5f1b59ea4cee2ad22a6e2920c5b41f7cd5778ef8e445242d18831d1f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/bcm/pinctrl-bcm63xx.c",
  "human_readable_source": "\n \n\n#include <linux/gpio/regmap.h>\n#include <linux/mfd/syscon.h>\n#include <linux/mod_devicetable.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n#include \"pinctrl-bcm63xx.h\"\n\n#define BCM63XX_BANK_SIZE\t4\n\n#define BCM63XX_DIROUT_REG\t0x04\n#define BCM63XX_DATA_REG\t0x0c\n\nstatic int bcm63xx_reg_mask_xlate(struct gpio_regmap *gpio,\n\t\t\t\t  unsigned int base, unsigned int offset,\n\t\t\t\t  unsigned int *reg, unsigned int *mask)\n{\n\tunsigned int line = offset % BCM63XX_BANK_GPIOS;\n\tunsigned int stride = offset / BCM63XX_BANK_GPIOS;\n\n\t*reg = base - stride * BCM63XX_BANK_SIZE;\n\t*mask = BIT(line);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id bcm63xx_gpio_of_match[] = {\n\t{ .compatible = \"brcm,bcm6318-gpio\", },\n\t{ .compatible = \"brcm,bcm6328-gpio\", },\n\t{ .compatible = \"brcm,bcm6358-gpio\", },\n\t{ .compatible = \"brcm,bcm6362-gpio\", },\n\t{ .compatible = \"brcm,bcm6368-gpio\", },\n\t{ .compatible = \"brcm,bcm63268-gpio\", },\n\t{   }\n};\n\nstatic int bcm63xx_gpio_probe(struct device *dev, struct device_node *node,\n\t\t\t      const struct bcm63xx_pinctrl_soc *soc,\n\t\t\t      struct bcm63xx_pinctrl *pc)\n{\n\tstruct gpio_regmap_config grc = {0};\n\n\tgrc.parent = dev;\n\tgrc.fwnode = &node->fwnode;\n\tgrc.ngpio = soc->ngpios;\n\tgrc.ngpio_per_reg = BCM63XX_BANK_GPIOS;\n\tgrc.regmap = pc->regs;\n\tgrc.reg_dat_base = BCM63XX_DATA_REG;\n\tgrc.reg_dir_out_base = BCM63XX_DIROUT_REG;\n\tgrc.reg_set_base = BCM63XX_DATA_REG;\n\tgrc.reg_mask_xlate = bcm63xx_reg_mask_xlate;\n\n\treturn PTR_ERR_OR_ZERO(devm_gpio_regmap_register(dev, &grc));\n}\n\nint bcm63xx_pinctrl_probe(struct platform_device *pdev,\n\t\t\t  const struct bcm63xx_pinctrl_soc *soc,\n\t\t\t  void *driver_data)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct bcm63xx_pinctrl *pc;\n\tstruct device_node *node;\n\tint err;\n\n\tpc = devm_kzalloc(dev, sizeof(*pc), GFP_KERNEL);\n\tif (!pc)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, pc);\n\n\tpc->dev = dev;\n\tpc->driver_data = driver_data;\n\n\tpc->regs = syscon_node_to_regmap(dev->parent->of_node);\n\tif (IS_ERR(pc->regs))\n\t\treturn PTR_ERR(pc->regs);\n\n\tpc->pctl_desc.name = dev_name(dev);\n\tpc->pctl_desc.pins = soc->pins;\n\tpc->pctl_desc.npins = soc->npins;\n\tpc->pctl_desc.pctlops = soc->pctl_ops;\n\tpc->pctl_desc.pmxops = soc->pmx_ops;\n\tpc->pctl_desc.owner = THIS_MODULE;\n\n\tpc->pctl_dev = devm_pinctrl_register(dev, &pc->pctl_desc, pc);\n\tif (IS_ERR(pc->pctl_dev))\n\t\treturn PTR_ERR(pc->pctl_dev);\n\n\tfor_each_child_of_node(dev->parent->of_node, node) {\n\t\tif (of_match_node(bcm63xx_gpio_of_match, node)) {\n\t\t\terr = bcm63xx_gpio_probe(dev, node, soc, pc);\n\t\t\tif (err) {\n\t\t\t\tdev_err(dev, \"could not add GPIO chip\\n\");\n\t\t\t\tof_node_put(node);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}