{
  "module_name": "pinctrl-nsp-gpio.c",
  "hash_id": "186a6870e3ca41b642b8fbd4558e092bccc9305d33c42e5eb2dd4aa7b9b1aa11",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/bcm/pinctrl-nsp-gpio.c",
  "human_readable_source": "\n\n\n \n\n#include <linux/gpio/driver.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinconf-generic.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include \"../pinctrl-utils.h\"\n\n#define NSP_CHIP_A_INT_STATUS\t\t0x00\n#define NSP_CHIP_A_INT_MASK\t\t0x04\n#define NSP_GPIO_DATA_IN\t\t0x40\n#define NSP_GPIO_DATA_OUT\t\t0x44\n#define NSP_GPIO_OUT_EN\t\t\t0x48\n#define NSP_GPIO_INT_POLARITY\t\t0x50\n#define NSP_GPIO_INT_MASK\t\t0x54\n#define NSP_GPIO_EVENT\t\t\t0x58\n#define NSP_GPIO_EVENT_INT_MASK\t\t0x5c\n#define NSP_GPIO_EVENT_INT_POLARITY\t0x64\n#define NSP_CHIP_A_GPIO_INT_BIT\t\t0x01\n\n \n#define NSP_GPIO_DRV_CTRL\t\t0x00\n#define NSP_GPIO_HYSTERESIS_EN\t\t0x10\n#define NSP_GPIO_SLEW_RATE_EN\t\t0x14\n#define NSP_PULL_UP_EN\t\t\t0x18\n#define NSP_PULL_DOWN_EN\t\t0x1c\n#define GPIO_DRV_STRENGTH_BITS\t\t0x03\n\n \nstruct nsp_gpio {\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tvoid __iomem *io_ctrl;\n\tstruct gpio_chip gc;\n\tstruct pinctrl_dev *pctl;\n\tstruct pinctrl_desc pctldesc;\n\traw_spinlock_t lock;\n};\n\nenum base_type {\n\tREG,\n\tIO_CTRL\n};\n\n \nstatic inline unsigned nsp_pin_to_gpio(unsigned pin)\n{\n\treturn pin;\n}\n\n \nstatic inline void nsp_set_bit(struct nsp_gpio *chip, enum base_type address,\n\t\t\t       unsigned int reg, unsigned gpio, bool set)\n{\n\tu32 val;\n\tvoid __iomem *base_address;\n\n\tif (address == IO_CTRL)\n\t\tbase_address = chip->io_ctrl;\n\telse\n\t\tbase_address = chip->base;\n\n\tval = readl(base_address + reg);\n\tif (set)\n\t\tval |= BIT(gpio);\n\telse\n\t\tval &= ~BIT(gpio);\n\n\twritel(val, base_address + reg);\n}\n\n \nstatic inline bool nsp_get_bit(struct nsp_gpio *chip, enum base_type address,\n\t\t\t       unsigned int reg, unsigned gpio)\n{\n\tif (address == IO_CTRL)\n\t\treturn !!(readl(chip->io_ctrl + reg) & BIT(gpio));\n\telse\n\t\treturn !!(readl(chip->base + reg) & BIT(gpio));\n}\n\nstatic irqreturn_t nsp_gpio_irq_handler(int irq, void *data)\n{\n\tstruct gpio_chip *gc = (struct gpio_chip *)data;\n\tstruct nsp_gpio *chip = gpiochip_get_data(gc);\n\tint bit;\n\tunsigned long int_bits = 0;\n\tu32 int_status;\n\n\t \n\tint_status = readl(chip->base + NSP_CHIP_A_INT_STATUS);\n\tif (int_status & NSP_CHIP_A_GPIO_INT_BIT) {\n\t\tunsigned int event, level;\n\n\t\t \n\t\tevent = readl(chip->base + NSP_GPIO_EVENT_INT_MASK) &\n\t\t\t      readl(chip->base + NSP_GPIO_EVENT);\n\t\tlevel = readl(chip->base + NSP_GPIO_DATA_IN) ^\n\t\t\t      readl(chip->base + NSP_GPIO_INT_POLARITY);\n\t\tlevel &= readl(chip->base + NSP_GPIO_INT_MASK);\n\t\tint_bits = level | event;\n\n\t\tfor_each_set_bit(bit, &int_bits, gc->ngpio)\n\t\t\tgeneric_handle_domain_irq(gc->irq.domain, bit);\n\t}\n\n\treturn  int_bits ? IRQ_HANDLED : IRQ_NONE;\n}\n\nstatic void nsp_gpio_irq_ack(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct nsp_gpio *chip = gpiochip_get_data(gc);\n\tunsigned gpio = d->hwirq;\n\tu32 val = BIT(gpio);\n\tu32 trigger_type;\n\n\ttrigger_type = irq_get_trigger_type(d->irq);\n\tif (trigger_type & (IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING))\n\t\twritel(val, chip->base + NSP_GPIO_EVENT);\n}\n\n \nstatic void nsp_gpio_irq_set_mask(struct irq_data *d, bool unmask)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct nsp_gpio *chip = gpiochip_get_data(gc);\n\tunsigned gpio = d->hwirq;\n\tu32 trigger_type;\n\n\ttrigger_type = irq_get_trigger_type(d->irq);\n\tif (trigger_type & (IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING))\n\t\tnsp_set_bit(chip, REG, NSP_GPIO_EVENT_INT_MASK, gpio, unmask);\n\telse\n\t\tnsp_set_bit(chip, REG, NSP_GPIO_INT_MASK, gpio, unmask);\n}\n\nstatic void nsp_gpio_irq_mask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct nsp_gpio *chip = gpiochip_get_data(gc);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&chip->lock, flags);\n\tnsp_gpio_irq_set_mask(d, false);\n\traw_spin_unlock_irqrestore(&chip->lock, flags);\n\tgpiochip_disable_irq(gc, irqd_to_hwirq(d));\n}\n\nstatic void nsp_gpio_irq_unmask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct nsp_gpio *chip = gpiochip_get_data(gc);\n\tunsigned long flags;\n\n\tgpiochip_enable_irq(gc, irqd_to_hwirq(d));\n\traw_spin_lock_irqsave(&chip->lock, flags);\n\tnsp_gpio_irq_set_mask(d, true);\n\traw_spin_unlock_irqrestore(&chip->lock, flags);\n}\n\nstatic int nsp_gpio_irq_set_type(struct irq_data *d, unsigned int type)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct nsp_gpio *chip = gpiochip_get_data(gc);\n\tunsigned gpio = d->hwirq;\n\tbool level_low;\n\tbool falling;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&chip->lock, flags);\n\tfalling = nsp_get_bit(chip, REG, NSP_GPIO_EVENT_INT_POLARITY, gpio);\n\tlevel_low = nsp_get_bit(chip, REG, NSP_GPIO_INT_POLARITY, gpio);\n\n\tswitch (type & IRQ_TYPE_SENSE_MASK) {\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tfalling = false;\n\t\tbreak;\n\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tfalling = true;\n\t\tbreak;\n\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tlevel_low = false;\n\t\tbreak;\n\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tlevel_low = true;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(chip->dev, \"invalid GPIO IRQ type 0x%x\\n\",\n\t\t\ttype);\n\t\traw_spin_unlock_irqrestore(&chip->lock, flags);\n\t\treturn -EINVAL;\n\t}\n\n\tnsp_set_bit(chip, REG, NSP_GPIO_EVENT_INT_POLARITY, gpio, falling);\n\tnsp_set_bit(chip, REG, NSP_GPIO_INT_POLARITY, gpio, level_low);\n\n\tif (type & IRQ_TYPE_EDGE_BOTH)\n\t\tirq_set_handler_locked(d, handle_edge_irq);\n\telse\n\t\tirq_set_handler_locked(d, handle_level_irq);\n\n\traw_spin_unlock_irqrestore(&chip->lock, flags);\n\n\tdev_dbg(chip->dev, \"gpio:%u level_low:%s falling:%s\\n\", gpio,\n\t\tlevel_low ? \"true\" : \"false\", falling ? \"true\" : \"false\");\n\treturn 0;\n}\n\nstatic const struct irq_chip nsp_gpio_irq_chip = {\n\t.name = \"gpio-a\",\n\t.irq_ack = nsp_gpio_irq_ack,\n\t.irq_mask = nsp_gpio_irq_mask,\n\t.irq_unmask = nsp_gpio_irq_unmask,\n\t.irq_set_type = nsp_gpio_irq_set_type,\n\t.flags = IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic int nsp_gpio_direction_input(struct gpio_chip *gc, unsigned gpio)\n{\n\tstruct nsp_gpio *chip = gpiochip_get_data(gc);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&chip->lock, flags);\n\tnsp_set_bit(chip, REG, NSP_GPIO_OUT_EN, gpio, false);\n\traw_spin_unlock_irqrestore(&chip->lock, flags);\n\n\tdev_dbg(chip->dev, \"gpio:%u set input\\n\", gpio);\n\treturn 0;\n}\n\nstatic int nsp_gpio_direction_output(struct gpio_chip *gc, unsigned gpio,\n\t\t\t\t     int val)\n{\n\tstruct nsp_gpio *chip = gpiochip_get_data(gc);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&chip->lock, flags);\n\tnsp_set_bit(chip, REG, NSP_GPIO_OUT_EN, gpio, true);\n\tnsp_set_bit(chip, REG, NSP_GPIO_DATA_OUT, gpio, !!(val));\n\traw_spin_unlock_irqrestore(&chip->lock, flags);\n\n\tdev_dbg(chip->dev, \"gpio:%u set output, value:%d\\n\", gpio, val);\n\treturn 0;\n}\n\nstatic int nsp_gpio_get_direction(struct gpio_chip *gc, unsigned gpio)\n{\n\tstruct nsp_gpio *chip = gpiochip_get_data(gc);\n\tunsigned long flags;\n\tint val;\n\n\traw_spin_lock_irqsave(&chip->lock, flags);\n\tval = nsp_get_bit(chip, REG, NSP_GPIO_OUT_EN, gpio);\n\traw_spin_unlock_irqrestore(&chip->lock, flags);\n\n\treturn !val;\n}\n\nstatic void nsp_gpio_set(struct gpio_chip *gc, unsigned gpio, int val)\n{\n\tstruct nsp_gpio *chip = gpiochip_get_data(gc);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&chip->lock, flags);\n\tnsp_set_bit(chip, REG, NSP_GPIO_DATA_OUT, gpio, !!(val));\n\traw_spin_unlock_irqrestore(&chip->lock, flags);\n\n\tdev_dbg(chip->dev, \"gpio:%u set, value:%d\\n\", gpio, val);\n}\n\nstatic int nsp_gpio_get(struct gpio_chip *gc, unsigned gpio)\n{\n\tstruct nsp_gpio *chip = gpiochip_get_data(gc);\n\n\treturn !!(readl(chip->base + NSP_GPIO_DATA_IN) & BIT(gpio));\n}\n\nstatic int nsp_get_groups_count(struct pinctrl_dev *pctldev)\n{\n\treturn 1;\n}\n\n \nstatic const char *nsp_get_group_name(struct pinctrl_dev *pctldev,\n\t\t\t\t      unsigned selector)\n{\n\treturn \"gpio_grp\";\n}\n\nstatic const struct pinctrl_ops nsp_pctrl_ops = {\n\t.get_groups_count = nsp_get_groups_count,\n\t.get_group_name = nsp_get_group_name,\n\t.dt_node_to_map = pinconf_generic_dt_node_to_map_pin,\n\t.dt_free_map = pinctrl_utils_free_map,\n};\n\nstatic int nsp_gpio_set_slew(struct nsp_gpio *chip, unsigned gpio, u32 slew)\n{\n\tif (slew)\n\t\tnsp_set_bit(chip, IO_CTRL, NSP_GPIO_SLEW_RATE_EN, gpio, true);\n\telse\n\t\tnsp_set_bit(chip, IO_CTRL, NSP_GPIO_SLEW_RATE_EN, gpio, false);\n\n\treturn 0;\n}\n\nstatic int nsp_gpio_set_pull(struct nsp_gpio *chip, unsigned gpio,\n\t\t\t     bool pull_up, bool pull_down)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&chip->lock, flags);\n\tnsp_set_bit(chip, IO_CTRL, NSP_PULL_DOWN_EN, gpio, pull_down);\n\tnsp_set_bit(chip, IO_CTRL, NSP_PULL_UP_EN, gpio, pull_up);\n\traw_spin_unlock_irqrestore(&chip->lock, flags);\n\n\tdev_dbg(chip->dev, \"gpio:%u set pullup:%d pulldown: %d\\n\",\n\t\tgpio, pull_up, pull_down);\n\treturn 0;\n}\n\nstatic void nsp_gpio_get_pull(struct nsp_gpio *chip, unsigned gpio,\n\t\t\t      bool *pull_up, bool *pull_down)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&chip->lock, flags);\n\t*pull_up = nsp_get_bit(chip, IO_CTRL, NSP_PULL_UP_EN, gpio);\n\t*pull_down = nsp_get_bit(chip, IO_CTRL, NSP_PULL_DOWN_EN, gpio);\n\traw_spin_unlock_irqrestore(&chip->lock, flags);\n}\n\nstatic int nsp_gpio_set_strength(struct nsp_gpio *chip, unsigned gpio,\n\t\t\t\t u32 strength)\n{\n\tu32 offset, shift, i;\n\tu32 val;\n\tunsigned long flags;\n\n\t \n\tif (strength < 2 || strength > 16 || (strength % 2))\n\t\treturn -ENOTSUPP;\n\n\tshift = gpio;\n\toffset = NSP_GPIO_DRV_CTRL;\n\tdev_dbg(chip->dev, \"gpio:%u set drive strength:%d mA\\n\", gpio,\n\t\tstrength);\n\traw_spin_lock_irqsave(&chip->lock, flags);\n\tstrength = (strength / 2) - 1;\n\tfor (i = GPIO_DRV_STRENGTH_BITS; i > 0; i--) {\n\t\tval = readl(chip->io_ctrl + offset);\n\t\tval &= ~BIT(shift);\n\t\tval |= ((strength >> (i-1)) & 0x1) << shift;\n\t\twritel(val, chip->io_ctrl + offset);\n\t\toffset += 4;\n\t}\n\traw_spin_unlock_irqrestore(&chip->lock, flags);\n\n\treturn 0;\n}\n\nstatic int nsp_gpio_get_strength(struct nsp_gpio *chip, unsigned gpio,\n\t\t\t\t u16 *strength)\n{\n\tunsigned int offset, shift;\n\tu32 val;\n\tunsigned long flags;\n\tint i;\n\n\toffset = NSP_GPIO_DRV_CTRL;\n\tshift = gpio;\n\n\traw_spin_lock_irqsave(&chip->lock, flags);\n\t*strength = 0;\n\tfor (i = (GPIO_DRV_STRENGTH_BITS - 1); i >= 0; i--) {\n\t\tval = readl(chip->io_ctrl + offset) & BIT(shift);\n\t\tval >>= shift;\n\t\t*strength += (val << i);\n\t\toffset += 4;\n\t}\n\n\t \n\t*strength = (*strength + 1) * 2;\n\traw_spin_unlock_irqrestore(&chip->lock, flags);\n\n\treturn 0;\n}\n\nstatic int nsp_pin_config_group_get(struct pinctrl_dev *pctldev,\n\t\t\t\t    unsigned selector,\n\t\t\t     unsigned long *config)\n{\n\treturn 0;\n}\n\nstatic int nsp_pin_config_group_set(struct pinctrl_dev *pctldev,\n\t\t\t\t    unsigned selector,\n\t\t\t     unsigned long *configs, unsigned num_configs)\n{\n\treturn 0;\n}\n\nstatic int nsp_pin_config_get(struct pinctrl_dev *pctldev, unsigned pin,\n\t\t\t      unsigned long *config)\n{\n\tstruct nsp_gpio *chip = pinctrl_dev_get_drvdata(pctldev);\n\tenum pin_config_param param = pinconf_to_config_param(*config);\n\tunsigned int gpio;\n\tu16 arg = 0;\n\tbool pull_up, pull_down;\n\tint ret;\n\n\tgpio = nsp_pin_to_gpio(pin);\n\tswitch (param) {\n\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\tnsp_gpio_get_pull(chip, gpio, &pull_up, &pull_down);\n\t\tif ((pull_up == false) && (pull_down == false))\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn -EINVAL;\n\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\tnsp_gpio_get_pull(chip, gpio, &pull_up, &pull_down);\n\t\tif (pull_up)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn -EINVAL;\n\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\tnsp_gpio_get_pull(chip, gpio, &pull_up, &pull_down);\n\t\tif (pull_down)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn -EINVAL;\n\n\tcase PIN_CONFIG_DRIVE_STRENGTH:\n\t\tret = nsp_gpio_get_strength(chip, gpio, &arg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t*config = pinconf_to_config_packed(param, arg);\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n}\n\nstatic int nsp_pin_config_set(struct pinctrl_dev *pctldev, unsigned pin,\n\t\t\t      unsigned long *configs, unsigned num_configs)\n{\n\tstruct nsp_gpio *chip = pinctrl_dev_get_drvdata(pctldev);\n\tenum pin_config_param param;\n\tu32 arg;\n\tunsigned int i, gpio;\n\tint ret = -ENOTSUPP;\n\n\tgpio = nsp_pin_to_gpio(pin);\n\tfor (i = 0; i < num_configs; i++) {\n\t\tparam = pinconf_to_config_param(configs[i]);\n\t\targ = pinconf_to_config_argument(configs[i]);\n\n\t\tswitch (param) {\n\t\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\t\tret = nsp_gpio_set_pull(chip, gpio, false, false);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\n\t\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\t\tret = nsp_gpio_set_pull(chip, gpio, true, false);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\n\t\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\t\tret = nsp_gpio_set_pull(chip, gpio, false, true);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\n\t\tcase PIN_CONFIG_DRIVE_STRENGTH:\n\t\t\tret = nsp_gpio_set_strength(chip, gpio, arg);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\n\t\tcase PIN_CONFIG_SLEW_RATE:\n\t\t\tret = nsp_gpio_set_slew(chip, gpio, arg);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_err(chip->dev, \"invalid configuration\\n\");\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}\n\nstatic const struct pinconf_ops nsp_pconf_ops = {\n\t.is_generic = true,\n\t.pin_config_get = nsp_pin_config_get,\n\t.pin_config_set = nsp_pin_config_set,\n\t.pin_config_group_get = nsp_pin_config_group_get,\n\t.pin_config_group_set = nsp_pin_config_group_set,\n};\n\n \nstatic int nsp_gpio_register_pinconf(struct nsp_gpio *chip)\n{\n\tstruct pinctrl_desc *pctldesc = &chip->pctldesc;\n\tstruct pinctrl_pin_desc *pins;\n\tstruct gpio_chip *gc = &chip->gc;\n\tint i;\n\n\tpins = devm_kcalloc(chip->dev, gc->ngpio, sizeof(*pins), GFP_KERNEL);\n\tif (!pins)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < gc->ngpio; i++) {\n\t\tpins[i].number = i;\n\t\tpins[i].name = devm_kasprintf(chip->dev, GFP_KERNEL,\n\t\t\t\t\t      \"gpio-%d\", i);\n\t\tif (!pins[i].name)\n\t\t\treturn -ENOMEM;\n\t}\n\tpctldesc->name = dev_name(chip->dev);\n\tpctldesc->pctlops = &nsp_pctrl_ops;\n\tpctldesc->pins = pins;\n\tpctldesc->npins = gc->ngpio;\n\tpctldesc->confops = &nsp_pconf_ops;\n\n\tchip->pctl = devm_pinctrl_register(chip->dev, pctldesc, chip);\n\tif (IS_ERR(chip->pctl)) {\n\t\tdev_err(chip->dev, \"unable to register pinctrl device\\n\");\n\t\treturn PTR_ERR(chip->pctl);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id nsp_gpio_of_match[] = {\n\t{.compatible = \"brcm,nsp-gpio-a\",},\n\t{}\n};\n\nstatic int nsp_gpio_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct nsp_gpio *chip;\n\tstruct gpio_chip *gc;\n\tu32 val;\n\tint irq, ret;\n\n\tif (of_property_read_u32(pdev->dev.of_node, \"ngpios\", &val)) {\n\t\tdev_err(&pdev->dev, \"Missing ngpios OF property\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tchip = devm_kzalloc(dev, sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tchip->dev = dev;\n\tplatform_set_drvdata(pdev, chip);\n\n\tchip->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(chip->base)) {\n\t\tdev_err(dev, \"unable to map I/O memory\\n\");\n\t\treturn PTR_ERR(chip->base);\n\t}\n\n\tchip->io_ctrl = devm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(chip->io_ctrl)) {\n\t\tdev_err(dev, \"unable to map I/O memory\\n\");\n\t\treturn PTR_ERR(chip->io_ctrl);\n\t}\n\n\traw_spin_lock_init(&chip->lock);\n\tgc = &chip->gc;\n\tgc->base = -1;\n\tgc->can_sleep = false;\n\tgc->ngpio = val;\n\tgc->label = dev_name(dev);\n\tgc->parent = dev;\n\tgc->request = gpiochip_generic_request;\n\tgc->free = gpiochip_generic_free;\n\tgc->direction_input = nsp_gpio_direction_input;\n\tgc->direction_output = nsp_gpio_direction_output;\n\tgc->get_direction = nsp_gpio_get_direction;\n\tgc->set = nsp_gpio_set;\n\tgc->get = nsp_gpio_get;\n\n\t \n\tirq = platform_get_irq(pdev, 0);\n\tif (irq > 0) {\n\t\tstruct gpio_irq_chip *girq;\n\n\t\tval = readl(chip->base + NSP_CHIP_A_INT_MASK);\n\t\tval = val | NSP_CHIP_A_GPIO_INT_BIT;\n\t\twritel(val, (chip->base + NSP_CHIP_A_INT_MASK));\n\n\t\t \n\t\tret = devm_request_irq(dev, irq, nsp_gpio_irq_handler,\n\t\t\t\t       IRQF_SHARED, \"gpio-a\", &chip->gc);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"Unable to request IRQ%d: %d\\n\",\n\t\t\t\tirq, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tgirq = &chip->gc.irq;\n\t\tgpio_irq_chip_set_chip(girq, &nsp_gpio_irq_chip);\n\t\t \n\t\tgirq->parent_handler = NULL;\n\t\tgirq->num_parents = 0;\n\t\tgirq->parents = NULL;\n\t\tgirq->default_type = IRQ_TYPE_NONE;\n\t\tgirq->handler = handle_bad_irq;\n\t}\n\n\tret = devm_gpiochip_add_data(dev, gc, chip);\n\tif (ret < 0)\n\t\treturn dev_err_probe(dev, ret, \"unable to add GPIO chip\\n\");\n\n\tret = nsp_gpio_register_pinconf(chip);\n\tif (ret) {\n\t\tdev_err(dev, \"unable to register pinconf\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver nsp_gpio_driver = {\n\t.driver = {\n\t\t.name = \"nsp-gpio-a\",\n\t\t.of_match_table = nsp_gpio_of_match,\n\t},\n\t.probe = nsp_gpio_probe,\n};\n\nstatic int __init nsp_gpio_init(void)\n{\n\treturn platform_driver_register(&nsp_gpio_driver);\n}\narch_initcall_sync(nsp_gpio_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}