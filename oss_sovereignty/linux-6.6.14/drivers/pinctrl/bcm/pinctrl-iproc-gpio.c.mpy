{
  "module_name": "pinctrl-iproc-gpio.c",
  "hash_id": "e9bfa130209a5165622b0fb85128ea473a700a3046e147f020bea39447b2fedc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/bcm/pinctrl-iproc-gpio.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/gpio/driver.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n\n#include <linux/pinctrl/consumer.h>\n#include <linux/pinctrl/pinconf-generic.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinctrl.h>\n\n#include \"../pinctrl-utils.h\"\n\n#define IPROC_GPIO_DATA_IN_OFFSET   0x00\n#define IPROC_GPIO_DATA_OUT_OFFSET  0x04\n#define IPROC_GPIO_OUT_EN_OFFSET    0x08\n#define IPROC_GPIO_INT_TYPE_OFFSET  0x0c\n#define IPROC_GPIO_INT_DE_OFFSET    0x10\n#define IPROC_GPIO_INT_EDGE_OFFSET  0x14\n#define IPROC_GPIO_INT_MSK_OFFSET   0x18\n#define IPROC_GPIO_INT_STAT_OFFSET  0x1c\n#define IPROC_GPIO_INT_MSTAT_OFFSET 0x20\n#define IPROC_GPIO_INT_CLR_OFFSET   0x24\n#define IPROC_GPIO_PAD_RES_OFFSET   0x34\n#define IPROC_GPIO_RES_EN_OFFSET    0x38\n\n \n#define IPROC_GPIO_ASIU_DRV0_CTRL_OFFSET 0x58\n\n \n#define IPROC_GPIO_PULL_DN_OFFSET   0x10\n#define IPROC_GPIO_PULL_UP_OFFSET   0x14\n\n \n#define IPROC_GPIO_DRV_CTRL_OFFSET  0x00\n\n#define GPIO_BANK_SIZE 0x200\n#define NGPIOS_PER_BANK 32\n#define GPIO_BANK(pin) ((pin) / NGPIOS_PER_BANK)\n\n#define IPROC_GPIO_REG(pin, reg) (GPIO_BANK(pin) * GPIO_BANK_SIZE + (reg))\n#define IPROC_GPIO_SHIFT(pin) ((pin) % NGPIOS_PER_BANK)\n\n#define GPIO_DRV_STRENGTH_BIT_SHIFT  20\n#define GPIO_DRV_STRENGTH_BITS       3\n#define GPIO_DRV_STRENGTH_BIT_MASK   ((1 << GPIO_DRV_STRENGTH_BITS) - 1)\n\nenum iproc_pinconf_param {\n\tIPROC_PINCONF_DRIVE_STRENGTH = 0,\n\tIPROC_PINCONF_BIAS_DISABLE,\n\tIPROC_PINCONF_BIAS_PULL_UP,\n\tIPROC_PINCONF_BIAS_PULL_DOWN,\n\tIPROC_PINCON_MAX,\n};\n\nenum iproc_pinconf_ctrl_type {\n\tIOCTRL_TYPE_AON = 1,\n\tIOCTRL_TYPE_CDRU,\n\tIOCTRL_TYPE_INVALID,\n};\n\n \nstruct iproc_gpio {\n\tstruct device *dev;\n\n\tvoid __iomem *base;\n\tvoid __iomem *io_ctrl;\n\tenum iproc_pinconf_ctrl_type io_ctrl_type;\n\n\traw_spinlock_t lock;\n\n\tstruct gpio_chip gc;\n\tunsigned num_banks;\n\n\tbool pinmux_is_supported;\n\n\tenum pin_config_param *pinconf_disable;\n\tunsigned int nr_pinconf_disable;\n\n\tstruct pinctrl_dev *pctl;\n\tstruct pinctrl_desc pctldesc;\n};\n\n \nstatic inline unsigned iproc_pin_to_gpio(unsigned pin)\n{\n\treturn pin;\n}\n\n \nstatic inline void iproc_set_bit(struct iproc_gpio *chip, unsigned int reg,\n\t\t\t\t  unsigned gpio, bool set)\n{\n\tunsigned int offset = IPROC_GPIO_REG(gpio, reg);\n\tunsigned int shift = IPROC_GPIO_SHIFT(gpio);\n\tu32 val;\n\n\tval = readl(chip->base + offset);\n\tif (set)\n\t\tval |= BIT(shift);\n\telse\n\t\tval &= ~BIT(shift);\n\twritel(val, chip->base + offset);\n}\n\nstatic inline bool iproc_get_bit(struct iproc_gpio *chip, unsigned int reg,\n\t\t\t\t  unsigned gpio)\n{\n\tunsigned int offset = IPROC_GPIO_REG(gpio, reg);\n\tunsigned int shift = IPROC_GPIO_SHIFT(gpio);\n\n\treturn !!(readl(chip->base + offset) & BIT(shift));\n}\n\nstatic void iproc_gpio_irq_handler(struct irq_desc *desc)\n{\n\tstruct gpio_chip *gc = irq_desc_get_handler_data(desc);\n\tstruct iproc_gpio *chip = gpiochip_get_data(gc);\n\tstruct irq_chip *irq_chip = irq_desc_get_chip(desc);\n\tint i, bit;\n\n\tchained_irq_enter(irq_chip, desc);\n\n\t \n\tfor (i = 0; i < chip->num_banks; i++) {\n\t\tunsigned long val = readl(chip->base + (i * GPIO_BANK_SIZE) +\n\t\t\t\t\t  IPROC_GPIO_INT_MSTAT_OFFSET);\n\n\t\tfor_each_set_bit(bit, &val, NGPIOS_PER_BANK) {\n\t\t\tunsigned pin = NGPIOS_PER_BANK * i + bit;\n\n\t\t\t \n\t\t\twritel(BIT(bit), chip->base + (i * GPIO_BANK_SIZE) +\n\t\t\t       IPROC_GPIO_INT_CLR_OFFSET);\n\n\t\t\tgeneric_handle_domain_irq(gc->irq.domain, pin);\n\t\t}\n\t}\n\n\tchained_irq_exit(irq_chip, desc);\n}\n\n\nstatic void iproc_gpio_irq_ack(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct iproc_gpio *chip = gpiochip_get_data(gc);\n\tunsigned gpio = d->hwirq;\n\tunsigned int offset = IPROC_GPIO_REG(gpio,\n\t\t\tIPROC_GPIO_INT_CLR_OFFSET);\n\tunsigned int shift = IPROC_GPIO_SHIFT(gpio);\n\tu32 val = BIT(shift);\n\n\twritel(val, chip->base + offset);\n}\n\n \nstatic void iproc_gpio_irq_set_mask(struct irq_data *d, bool unmask)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct iproc_gpio *chip = gpiochip_get_data(gc);\n\tunsigned gpio = irqd_to_hwirq(d);\n\n\tiproc_set_bit(chip, IPROC_GPIO_INT_MSK_OFFSET, gpio, unmask);\n}\n\nstatic void iproc_gpio_irq_mask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct iproc_gpio *chip = gpiochip_get_data(gc);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&chip->lock, flags);\n\tiproc_gpio_irq_set_mask(d, false);\n\traw_spin_unlock_irqrestore(&chip->lock, flags);\n\tgpiochip_disable_irq(gc, irqd_to_hwirq(d));\n}\n\nstatic void iproc_gpio_irq_unmask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct iproc_gpio *chip = gpiochip_get_data(gc);\n\tunsigned long flags;\n\n\tgpiochip_enable_irq(gc, irqd_to_hwirq(d));\n\traw_spin_lock_irqsave(&chip->lock, flags);\n\tiproc_gpio_irq_set_mask(d, true);\n\traw_spin_unlock_irqrestore(&chip->lock, flags);\n}\n\nstatic int iproc_gpio_irq_set_type(struct irq_data *d, unsigned int type)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct iproc_gpio *chip = gpiochip_get_data(gc);\n\tunsigned gpio = d->hwirq;\n\tbool level_triggered = false;\n\tbool dual_edge = false;\n\tbool rising_or_high = false;\n\tunsigned long flags;\n\n\tswitch (type & IRQ_TYPE_SENSE_MASK) {\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\trising_or_high = true;\n\t\tbreak;\n\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tbreak;\n\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\tdual_edge = true;\n\t\tbreak;\n\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tlevel_triggered = true;\n\t\trising_or_high = true;\n\t\tbreak;\n\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tlevel_triggered = true;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(chip->dev, \"invalid GPIO IRQ type 0x%x\\n\",\n\t\t\ttype);\n\t\treturn -EINVAL;\n\t}\n\n\traw_spin_lock_irqsave(&chip->lock, flags);\n\tiproc_set_bit(chip, IPROC_GPIO_INT_TYPE_OFFSET, gpio,\n\t\t       level_triggered);\n\tiproc_set_bit(chip, IPROC_GPIO_INT_DE_OFFSET, gpio, dual_edge);\n\tiproc_set_bit(chip, IPROC_GPIO_INT_EDGE_OFFSET, gpio,\n\t\t       rising_or_high);\n\n\tif (type & IRQ_TYPE_EDGE_BOTH)\n\t\tirq_set_handler_locked(d, handle_edge_irq);\n\telse\n\t\tirq_set_handler_locked(d, handle_level_irq);\n\n\traw_spin_unlock_irqrestore(&chip->lock, flags);\n\n\tdev_dbg(chip->dev,\n\t\t\"gpio:%u level_triggered:%d dual_edge:%d rising_or_high:%d\\n\",\n\t\tgpio, level_triggered, dual_edge, rising_or_high);\n\n\treturn 0;\n}\n\nstatic void iproc_gpio_irq_print_chip(struct irq_data *d, struct seq_file *p)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct iproc_gpio *chip = gpiochip_get_data(gc);\n\n\tseq_printf(p, dev_name(chip->dev));\n}\n\nstatic const struct irq_chip iproc_gpio_irq_chip = {\n\t.irq_ack = iproc_gpio_irq_ack,\n\t.irq_mask = iproc_gpio_irq_mask,\n\t.irq_unmask = iproc_gpio_irq_unmask,\n\t.irq_set_type = iproc_gpio_irq_set_type,\n\t.irq_enable = iproc_gpio_irq_unmask,\n\t.irq_disable = iproc_gpio_irq_mask,\n\t.irq_print_chip = iproc_gpio_irq_print_chip,\n\t.flags = IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\n \nstatic int iproc_gpio_request(struct gpio_chip *gc, unsigned offset)\n{\n\tstruct iproc_gpio *chip = gpiochip_get_data(gc);\n\tunsigned gpio = gc->base + offset;\n\n\t \n\tif (!chip->pinmux_is_supported)\n\t\treturn 0;\n\n\treturn pinctrl_gpio_request(gpio);\n}\n\nstatic void iproc_gpio_free(struct gpio_chip *gc, unsigned offset)\n{\n\tstruct iproc_gpio *chip = gpiochip_get_data(gc);\n\tunsigned gpio = gc->base + offset;\n\n\tif (!chip->pinmux_is_supported)\n\t\treturn;\n\n\tpinctrl_gpio_free(gpio);\n}\n\nstatic int iproc_gpio_direction_input(struct gpio_chip *gc, unsigned gpio)\n{\n\tstruct iproc_gpio *chip = gpiochip_get_data(gc);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&chip->lock, flags);\n\tiproc_set_bit(chip, IPROC_GPIO_OUT_EN_OFFSET, gpio, false);\n\traw_spin_unlock_irqrestore(&chip->lock, flags);\n\n\tdev_dbg(chip->dev, \"gpio:%u set input\\n\", gpio);\n\n\treturn 0;\n}\n\nstatic int iproc_gpio_direction_output(struct gpio_chip *gc, unsigned gpio,\n\t\t\t\t\tint val)\n{\n\tstruct iproc_gpio *chip = gpiochip_get_data(gc);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&chip->lock, flags);\n\tiproc_set_bit(chip, IPROC_GPIO_OUT_EN_OFFSET, gpio, true);\n\tiproc_set_bit(chip, IPROC_GPIO_DATA_OUT_OFFSET, gpio, !!(val));\n\traw_spin_unlock_irqrestore(&chip->lock, flags);\n\n\tdev_dbg(chip->dev, \"gpio:%u set output, value:%d\\n\", gpio, val);\n\n\treturn 0;\n}\n\nstatic int iproc_gpio_get_direction(struct gpio_chip *gc, unsigned int gpio)\n{\n\tstruct iproc_gpio *chip = gpiochip_get_data(gc);\n\tunsigned int offset = IPROC_GPIO_REG(gpio, IPROC_GPIO_OUT_EN_OFFSET);\n\tunsigned int shift = IPROC_GPIO_SHIFT(gpio);\n\n\tif (readl(chip->base + offset) & BIT(shift))\n\t\treturn GPIO_LINE_DIRECTION_OUT;\n\n\treturn GPIO_LINE_DIRECTION_IN;\n}\n\nstatic void iproc_gpio_set(struct gpio_chip *gc, unsigned gpio, int val)\n{\n\tstruct iproc_gpio *chip = gpiochip_get_data(gc);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&chip->lock, flags);\n\tiproc_set_bit(chip, IPROC_GPIO_DATA_OUT_OFFSET, gpio, !!(val));\n\traw_spin_unlock_irqrestore(&chip->lock, flags);\n\n\tdev_dbg(chip->dev, \"gpio:%u set, value:%d\\n\", gpio, val);\n}\n\nstatic int iproc_gpio_get(struct gpio_chip *gc, unsigned gpio)\n{\n\tstruct iproc_gpio *chip = gpiochip_get_data(gc);\n\tunsigned int offset = IPROC_GPIO_REG(gpio,\n\t\t\t\t\t      IPROC_GPIO_DATA_IN_OFFSET);\n\tunsigned int shift = IPROC_GPIO_SHIFT(gpio);\n\n\treturn !!(readl(chip->base + offset) & BIT(shift));\n}\n\n \nstatic const enum pin_config_param iproc_pinconf_disable_map[] = {\n\t[IPROC_PINCONF_DRIVE_STRENGTH] = PIN_CONFIG_DRIVE_STRENGTH,\n\t[IPROC_PINCONF_BIAS_DISABLE] = PIN_CONFIG_BIAS_DISABLE,\n\t[IPROC_PINCONF_BIAS_PULL_UP] = PIN_CONFIG_BIAS_PULL_UP,\n\t[IPROC_PINCONF_BIAS_PULL_DOWN] = PIN_CONFIG_BIAS_PULL_DOWN,\n};\n\nstatic bool iproc_pinconf_param_is_disabled(struct iproc_gpio *chip,\n\t\t\t\t\t    enum pin_config_param param)\n{\n\tunsigned int i;\n\n\tif (!chip->nr_pinconf_disable)\n\t\treturn false;\n\n\tfor (i = 0; i < chip->nr_pinconf_disable; i++)\n\t\tif (chip->pinconf_disable[i] == param)\n\t\t\treturn true;\n\n\treturn false;\n}\n\nstatic int iproc_pinconf_disable_map_create(struct iproc_gpio *chip,\n\t\t\t\t\t    unsigned long disable_mask)\n{\n\tunsigned int map_size = ARRAY_SIZE(iproc_pinconf_disable_map);\n\tunsigned int bit, nbits = 0;\n\n\t \n\tfor_each_set_bit(bit, &disable_mask, map_size)\n\t\tnbits++;\n\n\tif (!nbits)\n\t\treturn 0;\n\n\t \n\tchip->pinconf_disable = devm_kcalloc(chip->dev, nbits,\n\t\t\t\t\t     sizeof(*chip->pinconf_disable),\n\t\t\t\t\t     GFP_KERNEL);\n\tif (!chip->pinconf_disable)\n\t\treturn -ENOMEM;\n\n\tchip->nr_pinconf_disable = nbits;\n\n\t \n\tnbits = 0;\n\tfor_each_set_bit(bit, &disable_mask, map_size)\n\t\tchip->pinconf_disable[nbits++] = iproc_pinconf_disable_map[bit];\n\n\treturn 0;\n}\n\nstatic int iproc_get_groups_count(struct pinctrl_dev *pctldev)\n{\n\treturn 1;\n}\n\n \nstatic const char *iproc_get_group_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t unsigned selector)\n{\n\treturn \"gpio_grp\";\n}\n\nstatic const struct pinctrl_ops iproc_pctrl_ops = {\n\t.get_groups_count = iproc_get_groups_count,\n\t.get_group_name = iproc_get_group_name,\n\t.dt_node_to_map = pinconf_generic_dt_node_to_map_pin,\n\t.dt_free_map = pinctrl_utils_free_map,\n};\n\nstatic int iproc_gpio_set_pull(struct iproc_gpio *chip, unsigned gpio,\n\t\t\t\tbool disable, bool pull_up)\n{\n\tvoid __iomem *base;\n\tunsigned long flags;\n\tunsigned int shift;\n\tu32 val_1, val_2;\n\n\traw_spin_lock_irqsave(&chip->lock, flags);\n\tif (chip->io_ctrl_type == IOCTRL_TYPE_CDRU) {\n\t\tbase = chip->io_ctrl;\n\t\tshift = IPROC_GPIO_SHIFT(gpio);\n\n\t\tval_1 = readl(base + IPROC_GPIO_PULL_UP_OFFSET);\n\t\tval_2 = readl(base + IPROC_GPIO_PULL_DN_OFFSET);\n\t\tif (disable) {\n\t\t\t \n\t\t\tval_1 &= ~BIT(shift);\n\t\t\tval_2 &= ~BIT(shift);\n\t\t} else if (pull_up) {\n\t\t\tval_1 |= BIT(shift);\n\t\t\tval_2 &= ~BIT(shift);\n\t\t} else {\n\t\t\tval_1 &= ~BIT(shift);\n\t\t\tval_2 |= BIT(shift);\n\t\t}\n\t\twritel(val_1, base + IPROC_GPIO_PULL_UP_OFFSET);\n\t\twritel(val_2, base + IPROC_GPIO_PULL_DN_OFFSET);\n\t} else {\n\t\tif (disable) {\n\t\t\tiproc_set_bit(chip, IPROC_GPIO_RES_EN_OFFSET, gpio,\n\t\t\t\t      false);\n\t\t} else {\n\t\t\tiproc_set_bit(chip, IPROC_GPIO_PAD_RES_OFFSET, gpio,\n\t\t\t\t      pull_up);\n\t\t\tiproc_set_bit(chip, IPROC_GPIO_RES_EN_OFFSET, gpio,\n\t\t\t\t      true);\n\t\t}\n\t}\n\n\traw_spin_unlock_irqrestore(&chip->lock, flags);\n\tdev_dbg(chip->dev, \"gpio:%u set pullup:%d\\n\", gpio, pull_up);\n\n\treturn 0;\n}\n\nstatic void iproc_gpio_get_pull(struct iproc_gpio *chip, unsigned gpio,\n\t\t\t\t bool *disable, bool *pull_up)\n{\n\tvoid __iomem *base;\n\tunsigned long flags;\n\tunsigned int shift;\n\tu32 val_1, val_2;\n\n\traw_spin_lock_irqsave(&chip->lock, flags);\n\tif (chip->io_ctrl_type == IOCTRL_TYPE_CDRU) {\n\t\tbase = chip->io_ctrl;\n\t\tshift = IPROC_GPIO_SHIFT(gpio);\n\n\t\tval_1 = readl(base + IPROC_GPIO_PULL_UP_OFFSET) & BIT(shift);\n\t\tval_2 = readl(base + IPROC_GPIO_PULL_DN_OFFSET) & BIT(shift);\n\n\t\t*pull_up = val_1 ? true : false;\n\t\t*disable = (val_1 | val_2) ? false : true;\n\n\t} else {\n\t\t*disable = !iproc_get_bit(chip, IPROC_GPIO_RES_EN_OFFSET, gpio);\n\t\t*pull_up = iproc_get_bit(chip, IPROC_GPIO_PAD_RES_OFFSET, gpio);\n\t}\n\traw_spin_unlock_irqrestore(&chip->lock, flags);\n}\n\n#define DRV_STRENGTH_OFFSET(gpio, bit, type)  ((type) == IOCTRL_TYPE_AON ? \\\n\t((2 - (bit)) * 4 + IPROC_GPIO_DRV_CTRL_OFFSET) : \\\n\t((type) == IOCTRL_TYPE_CDRU) ? \\\n\t((bit) * 4 + IPROC_GPIO_DRV_CTRL_OFFSET) : \\\n\t((bit) * 4 + IPROC_GPIO_REG(gpio, IPROC_GPIO_ASIU_DRV0_CTRL_OFFSET)))\n\nstatic int iproc_gpio_set_strength(struct iproc_gpio *chip, unsigned gpio,\n\t\t\t\t    unsigned strength)\n{\n\tvoid __iomem *base;\n\tunsigned int i, offset, shift;\n\tu32 val;\n\tunsigned long flags;\n\n\t \n\tif (strength < 2 ||  strength > 16 || (strength % 2))\n\t\treturn -ENOTSUPP;\n\n\tif (chip->io_ctrl) {\n\t\tbase = chip->io_ctrl;\n\t} else {\n\t\tbase = chip->base;\n\t}\n\n\tshift = IPROC_GPIO_SHIFT(gpio);\n\n\tdev_dbg(chip->dev, \"gpio:%u set drive strength:%d mA\\n\", gpio,\n\t\tstrength);\n\n\traw_spin_lock_irqsave(&chip->lock, flags);\n\tstrength = (strength / 2) - 1;\n\tfor (i = 0; i < GPIO_DRV_STRENGTH_BITS; i++) {\n\t\toffset = DRV_STRENGTH_OFFSET(gpio, i, chip->io_ctrl_type);\n\t\tval = readl(base + offset);\n\t\tval &= ~BIT(shift);\n\t\tval |= ((strength >> i) & 0x1) << shift;\n\t\twritel(val, base + offset);\n\t}\n\traw_spin_unlock_irqrestore(&chip->lock, flags);\n\n\treturn 0;\n}\n\nstatic int iproc_gpio_get_strength(struct iproc_gpio *chip, unsigned gpio,\n\t\t\t\t    u16 *strength)\n{\n\tvoid __iomem *base;\n\tunsigned int i, offset, shift;\n\tu32 val;\n\tunsigned long flags;\n\n\tif (chip->io_ctrl) {\n\t\tbase = chip->io_ctrl;\n\t} else {\n\t\tbase = chip->base;\n\t}\n\n\tshift = IPROC_GPIO_SHIFT(gpio);\n\n\traw_spin_lock_irqsave(&chip->lock, flags);\n\t*strength = 0;\n\tfor (i = 0; i < GPIO_DRV_STRENGTH_BITS; i++) {\n\t\toffset = DRV_STRENGTH_OFFSET(gpio, i, chip->io_ctrl_type);\n\t\tval = readl(base + offset) & BIT(shift);\n\t\tval >>= shift;\n\t\t*strength += (val << i);\n\t}\n\n\t \n\t*strength = (*strength + 1) * 2;\n\traw_spin_unlock_irqrestore(&chip->lock, flags);\n\n\treturn 0;\n}\n\nstatic int iproc_pin_config_get(struct pinctrl_dev *pctldev, unsigned pin,\n\t\t\t\t unsigned long *config)\n{\n\tstruct iproc_gpio *chip = pinctrl_dev_get_drvdata(pctldev);\n\tenum pin_config_param param = pinconf_to_config_param(*config);\n\tunsigned gpio = iproc_pin_to_gpio(pin);\n\tu16 arg;\n\tbool disable, pull_up;\n\tint ret;\n\n\tif (iproc_pinconf_param_is_disabled(chip, param))\n\t\treturn -ENOTSUPP;\n\n\tswitch (param) {\n\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\tiproc_gpio_get_pull(chip, gpio, &disable, &pull_up);\n\t\tif (disable)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn -EINVAL;\n\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\tiproc_gpio_get_pull(chip, gpio, &disable, &pull_up);\n\t\tif (!disable && pull_up)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn -EINVAL;\n\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\tiproc_gpio_get_pull(chip, gpio, &disable, &pull_up);\n\t\tif (!disable && !pull_up)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn -EINVAL;\n\n\tcase PIN_CONFIG_DRIVE_STRENGTH:\n\t\tret = iproc_gpio_get_strength(chip, gpio, &arg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t*config = pinconf_to_config_packed(param, arg);\n\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn -ENOTSUPP;\n}\n\nstatic int iproc_pin_config_set(struct pinctrl_dev *pctldev, unsigned pin,\n\t\t\t\t unsigned long *configs, unsigned num_configs)\n{\n\tstruct iproc_gpio *chip = pinctrl_dev_get_drvdata(pctldev);\n\tenum pin_config_param param;\n\tu32 arg;\n\tunsigned i, gpio = iproc_pin_to_gpio(pin);\n\tint ret = -ENOTSUPP;\n\n\tfor (i = 0; i < num_configs; i++) {\n\t\tparam = pinconf_to_config_param(configs[i]);\n\n\t\tif (iproc_pinconf_param_is_disabled(chip, param))\n\t\t\treturn -ENOTSUPP;\n\n\t\targ = pinconf_to_config_argument(configs[i]);\n\n\t\tswitch (param) {\n\t\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\t\tret = iproc_gpio_set_pull(chip, gpio, true, false);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\n\t\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\t\tret = iproc_gpio_set_pull(chip, gpio, false, true);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\n\t\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\t\tret = iproc_gpio_set_pull(chip, gpio, false, false);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\n\t\tcase PIN_CONFIG_DRIVE_STRENGTH:\n\t\t\tret = iproc_gpio_set_strength(chip, gpio, arg);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_err(chip->dev, \"invalid configuration\\n\");\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t}  \n\nout:\n\treturn ret;\n}\n\nstatic const struct pinconf_ops iproc_pconf_ops = {\n\t.is_generic = true,\n\t.pin_config_get = iproc_pin_config_get,\n\t.pin_config_set = iproc_pin_config_set,\n};\n\n \nstatic int iproc_gpio_register_pinconf(struct iproc_gpio *chip)\n{\n\tstruct pinctrl_desc *pctldesc = &chip->pctldesc;\n\tstruct pinctrl_pin_desc *pins;\n\tstruct gpio_chip *gc = &chip->gc;\n\tint i;\n\n\tpins = devm_kcalloc(chip->dev, gc->ngpio, sizeof(*pins), GFP_KERNEL);\n\tif (!pins)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < gc->ngpio; i++) {\n\t\tpins[i].number = i;\n\t\tpins[i].name = devm_kasprintf(chip->dev, GFP_KERNEL,\n\t\t\t\t\t      \"gpio-%d\", i);\n\t\tif (!pins[i].name)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tpctldesc->name = dev_name(chip->dev);\n\tpctldesc->pctlops = &iproc_pctrl_ops;\n\tpctldesc->pins = pins;\n\tpctldesc->npins = gc->ngpio;\n\tpctldesc->confops = &iproc_pconf_ops;\n\n\tchip->pctl = devm_pinctrl_register(chip->dev, pctldesc, chip);\n\tif (IS_ERR(chip->pctl)) {\n\t\tdev_err(chip->dev, \"unable to register pinctrl device\\n\");\n\t\treturn PTR_ERR(chip->pctl);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id iproc_gpio_of_match[] = {\n\t{ .compatible = \"brcm,iproc-gpio\" },\n\t{ .compatible = \"brcm,cygnus-ccm-gpio\" },\n\t{ .compatible = \"brcm,cygnus-asiu-gpio\" },\n\t{ .compatible = \"brcm,cygnus-crmu-gpio\" },\n\t{ .compatible = \"brcm,iproc-nsp-gpio\" },\n\t{ .compatible = \"brcm,iproc-stingray-gpio\" },\n\t{   }\n};\n\nstatic int iproc_gpio_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *res;\n\tstruct iproc_gpio *chip;\n\tstruct gpio_chip *gc;\n\tu32 ngpios, pinconf_disable_mask = 0;\n\tint irq, ret;\n\tbool no_pinconf = false;\n\tenum iproc_pinconf_ctrl_type io_ctrl_type = IOCTRL_TYPE_INVALID;\n\n\t \n\tif (of_device_is_compatible(dev->of_node, \"brcm,iproc-nsp-gpio\"))\n\t\tpinconf_disable_mask = BIT(IPROC_PINCONF_DRIVE_STRENGTH);\n\t \n\telse if (of_device_is_compatible(dev->of_node,\n\t\t\t\t\t \"brcm,iproc-stingray-gpio\"))\n\t\tno_pinconf = true;\n\n\tchip = devm_kzalloc(dev, sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tchip->dev = dev;\n\tplatform_set_drvdata(pdev, chip);\n\n\tchip->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(chip->base)) {\n\t\tdev_err(dev, \"unable to map I/O memory\\n\");\n\t\treturn PTR_ERR(chip->base);\n\t}\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\tif (res) {\n\t\tchip->io_ctrl = devm_ioremap_resource(dev, res);\n\t\tif (IS_ERR(chip->io_ctrl))\n\t\t\treturn PTR_ERR(chip->io_ctrl);\n\t\tif (of_device_is_compatible(dev->of_node,\n\t\t\t\t\t    \"brcm,cygnus-ccm-gpio\"))\n\t\t\tio_ctrl_type = IOCTRL_TYPE_CDRU;\n\t\telse\n\t\t\tio_ctrl_type = IOCTRL_TYPE_AON;\n\t}\n\n\tchip->io_ctrl_type = io_ctrl_type;\n\n\tif (of_property_read_u32(dev->of_node, \"ngpios\", &ngpios)) {\n\t\tdev_err(&pdev->dev, \"missing ngpios DT property\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\traw_spin_lock_init(&chip->lock);\n\n\tgc = &chip->gc;\n\tgc->base = -1;\n\tgc->ngpio = ngpios;\n\tchip->num_banks = (ngpios + NGPIOS_PER_BANK - 1) / NGPIOS_PER_BANK;\n\tgc->label = dev_name(dev);\n\tgc->parent = dev;\n\tgc->request = iproc_gpio_request;\n\tgc->free = iproc_gpio_free;\n\tgc->direction_input = iproc_gpio_direction_input;\n\tgc->direction_output = iproc_gpio_direction_output;\n\tgc->get_direction = iproc_gpio_get_direction;\n\tgc->set = iproc_gpio_set;\n\tgc->get = iproc_gpio_get;\n\n\tchip->pinmux_is_supported = of_property_read_bool(dev->of_node,\n\t\t\t\t\t\t\t\"gpio-ranges\");\n\n\t \n\tirq = platform_get_irq_optional(pdev, 0);\n\tif (irq > 0) {\n\t\tstruct gpio_irq_chip *girq;\n\n\t\tgirq = &gc->irq;\n\t\tgpio_irq_chip_set_chip(girq, &iproc_gpio_irq_chip);\n\t\tgirq->parent_handler = iproc_gpio_irq_handler;\n\t\tgirq->num_parents = 1;\n\t\tgirq->parents = devm_kcalloc(dev, 1,\n\t\t\t\t\t     sizeof(*girq->parents),\n\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!girq->parents)\n\t\t\treturn -ENOMEM;\n\t\tgirq->parents[0] = irq;\n\t\tgirq->default_type = IRQ_TYPE_NONE;\n\t\tgirq->handler = handle_bad_irq;\n\t}\n\n\tret = gpiochip_add_data(gc, chip);\n\tif (ret < 0)\n\t\treturn dev_err_probe(dev, ret, \"unable to add GPIO chip\\n\");\n\n\tif (!no_pinconf) {\n\t\tret = iproc_gpio_register_pinconf(chip);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"unable to register pinconf\\n\");\n\t\t\tgoto err_rm_gpiochip;\n\t\t}\n\n\t\tif (pinconf_disable_mask) {\n\t\t\tret = iproc_pinconf_disable_map_create(chip,\n\t\t\t\t\t\t\t pinconf_disable_mask);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(dev,\n\t\t\t\t\t\"unable to create pinconf disable map\\n\");\n\t\t\t\tgoto err_rm_gpiochip;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_rm_gpiochip:\n\tgpiochip_remove(gc);\n\n\treturn ret;\n}\n\nstatic struct platform_driver iproc_gpio_driver = {\n\t.driver = {\n\t\t.name = \"iproc-gpio\",\n\t\t.of_match_table = iproc_gpio_of_match,\n\t},\n\t.probe = iproc_gpio_probe,\n};\n\nstatic int __init iproc_gpio_init(void)\n{\n\treturn platform_driver_register(&iproc_gpio_driver);\n}\narch_initcall_sync(iproc_gpio_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}