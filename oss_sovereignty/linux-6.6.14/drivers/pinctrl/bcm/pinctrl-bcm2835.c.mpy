{
  "module_name": "pinctrl-bcm2835.c",
  "hash_id": "46d4d833be36e35fd9aea9425531bdbf64bbeabfe9fa487198328516fec08bc0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/bcm/pinctrl-bcm2835.c",
  "human_readable_source": "\n \n\n#include <linux/bitmap.h>\n#include <linux/bug.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/gpio/driver.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/irqdesc.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/pinctrl/machine.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinmux.h>\n#include <linux/pinctrl/pinconf-generic.h>\n#include <linux/platform_device.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <dt-bindings/pinctrl/bcm2835.h>\n\n#define MODULE_NAME \"pinctrl-bcm2835\"\n#define BCM2835_NUM_GPIOS 54\n#define BCM2711_NUM_GPIOS 58\n#define BCM2835_NUM_BANKS 2\n#define BCM2835_NUM_IRQS  3\n\n \n#define GPFSEL0\t\t0x0\t \n#define GPSET0\t\t0x1c\t \n#define GPCLR0\t\t0x28\t \n#define GPLEV0\t\t0x34\t \n#define GPEDS0\t\t0x40\t \n#define GPREN0\t\t0x4c\t \n#define GPFEN0\t\t0x58\t \n#define GPHEN0\t\t0x64\t \n#define GPLEN0\t\t0x70\t \n#define GPAREN0\t\t0x7c\t \n#define GPAFEN0\t\t0x88\t \n#define GPPUD\t\t0x94\t \n#define GPPUDCLK0\t0x98\t \n#define GP_GPIO_PUP_PDN_CNTRL_REG0 0xe4  \n\n#define FSEL_REG(p)\t\t(GPFSEL0 + (((p) / 10) * 4))\n#define FSEL_SHIFT(p)\t\t(((p) % 10) * 3)\n#define GPIO_REG_OFFSET(p)\t((p) / 32)\n#define GPIO_REG_SHIFT(p)\t((p) % 32)\n\n#define PUD_2711_MASK\t\t0x3\n#define PUD_2711_REG_OFFSET(p)\t((p) / 16)\n#define PUD_2711_REG_SHIFT(p)\t(((p) % 16) * 2)\n\n \n#define BCM2835_PINCONF_PARAM_PULL\t(PIN_CONFIG_END + 1)\n\n#define BCM2711_PULL_NONE\t0x0\n#define BCM2711_PULL_UP\t\t0x1\n#define BCM2711_PULL_DOWN\t0x2\n\nstruct bcm2835_pinctrl {\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tint *wake_irq;\n\n\t \n\tunsigned long enabled_irq_map[BCM2835_NUM_BANKS];\n\tunsigned int irq_type[BCM2711_NUM_GPIOS];\n\n\tstruct pinctrl_dev *pctl_dev;\n\tstruct gpio_chip gpio_chip;\n\tstruct pinctrl_desc pctl_desc;\n\tstruct pinctrl_gpio_range gpio_range;\n\n\traw_spinlock_t irq_lock[BCM2835_NUM_BANKS];\n\t \n\tspinlock_t fsel_lock;\n};\n\n \n#define BCM2835_GPIO_PIN(a) PINCTRL_PIN(a, \"gpio\" #a)\nstatic struct pinctrl_pin_desc bcm2835_gpio_pins[] = {\n\tBCM2835_GPIO_PIN(0),\n\tBCM2835_GPIO_PIN(1),\n\tBCM2835_GPIO_PIN(2),\n\tBCM2835_GPIO_PIN(3),\n\tBCM2835_GPIO_PIN(4),\n\tBCM2835_GPIO_PIN(5),\n\tBCM2835_GPIO_PIN(6),\n\tBCM2835_GPIO_PIN(7),\n\tBCM2835_GPIO_PIN(8),\n\tBCM2835_GPIO_PIN(9),\n\tBCM2835_GPIO_PIN(10),\n\tBCM2835_GPIO_PIN(11),\n\tBCM2835_GPIO_PIN(12),\n\tBCM2835_GPIO_PIN(13),\n\tBCM2835_GPIO_PIN(14),\n\tBCM2835_GPIO_PIN(15),\n\tBCM2835_GPIO_PIN(16),\n\tBCM2835_GPIO_PIN(17),\n\tBCM2835_GPIO_PIN(18),\n\tBCM2835_GPIO_PIN(19),\n\tBCM2835_GPIO_PIN(20),\n\tBCM2835_GPIO_PIN(21),\n\tBCM2835_GPIO_PIN(22),\n\tBCM2835_GPIO_PIN(23),\n\tBCM2835_GPIO_PIN(24),\n\tBCM2835_GPIO_PIN(25),\n\tBCM2835_GPIO_PIN(26),\n\tBCM2835_GPIO_PIN(27),\n\tBCM2835_GPIO_PIN(28),\n\tBCM2835_GPIO_PIN(29),\n\tBCM2835_GPIO_PIN(30),\n\tBCM2835_GPIO_PIN(31),\n\tBCM2835_GPIO_PIN(32),\n\tBCM2835_GPIO_PIN(33),\n\tBCM2835_GPIO_PIN(34),\n\tBCM2835_GPIO_PIN(35),\n\tBCM2835_GPIO_PIN(36),\n\tBCM2835_GPIO_PIN(37),\n\tBCM2835_GPIO_PIN(38),\n\tBCM2835_GPIO_PIN(39),\n\tBCM2835_GPIO_PIN(40),\n\tBCM2835_GPIO_PIN(41),\n\tBCM2835_GPIO_PIN(42),\n\tBCM2835_GPIO_PIN(43),\n\tBCM2835_GPIO_PIN(44),\n\tBCM2835_GPIO_PIN(45),\n\tBCM2835_GPIO_PIN(46),\n\tBCM2835_GPIO_PIN(47),\n\tBCM2835_GPIO_PIN(48),\n\tBCM2835_GPIO_PIN(49),\n\tBCM2835_GPIO_PIN(50),\n\tBCM2835_GPIO_PIN(51),\n\tBCM2835_GPIO_PIN(52),\n\tBCM2835_GPIO_PIN(53),\n\tBCM2835_GPIO_PIN(54),\n\tBCM2835_GPIO_PIN(55),\n\tBCM2835_GPIO_PIN(56),\n\tBCM2835_GPIO_PIN(57),\n};\n\n \nstatic const char * const bcm2835_gpio_groups[] = {\n\t\"gpio0\",\n\t\"gpio1\",\n\t\"gpio2\",\n\t\"gpio3\",\n\t\"gpio4\",\n\t\"gpio5\",\n\t\"gpio6\",\n\t\"gpio7\",\n\t\"gpio8\",\n\t\"gpio9\",\n\t\"gpio10\",\n\t\"gpio11\",\n\t\"gpio12\",\n\t\"gpio13\",\n\t\"gpio14\",\n\t\"gpio15\",\n\t\"gpio16\",\n\t\"gpio17\",\n\t\"gpio18\",\n\t\"gpio19\",\n\t\"gpio20\",\n\t\"gpio21\",\n\t\"gpio22\",\n\t\"gpio23\",\n\t\"gpio24\",\n\t\"gpio25\",\n\t\"gpio26\",\n\t\"gpio27\",\n\t\"gpio28\",\n\t\"gpio29\",\n\t\"gpio30\",\n\t\"gpio31\",\n\t\"gpio32\",\n\t\"gpio33\",\n\t\"gpio34\",\n\t\"gpio35\",\n\t\"gpio36\",\n\t\"gpio37\",\n\t\"gpio38\",\n\t\"gpio39\",\n\t\"gpio40\",\n\t\"gpio41\",\n\t\"gpio42\",\n\t\"gpio43\",\n\t\"gpio44\",\n\t\"gpio45\",\n\t\"gpio46\",\n\t\"gpio47\",\n\t\"gpio48\",\n\t\"gpio49\",\n\t\"gpio50\",\n\t\"gpio51\",\n\t\"gpio52\",\n\t\"gpio53\",\n\t\"gpio54\",\n\t\"gpio55\",\n\t\"gpio56\",\n\t\"gpio57\",\n};\n\nenum bcm2835_fsel {\n\tBCM2835_FSEL_COUNT = 8,\n\tBCM2835_FSEL_MASK = 0x7,\n};\n\nstatic const char * const bcm2835_functions[BCM2835_FSEL_COUNT] = {\n\t[BCM2835_FSEL_GPIO_IN] = \"gpio_in\",\n\t[BCM2835_FSEL_GPIO_OUT] = \"gpio_out\",\n\t[BCM2835_FSEL_ALT0] = \"alt0\",\n\t[BCM2835_FSEL_ALT1] = \"alt1\",\n\t[BCM2835_FSEL_ALT2] = \"alt2\",\n\t[BCM2835_FSEL_ALT3] = \"alt3\",\n\t[BCM2835_FSEL_ALT4] = \"alt4\",\n\t[BCM2835_FSEL_ALT5] = \"alt5\",\n};\n\nstatic const char * const irq_type_names[] = {\n\t[IRQ_TYPE_NONE] = \"none\",\n\t[IRQ_TYPE_EDGE_RISING] = \"edge-rising\",\n\t[IRQ_TYPE_EDGE_FALLING] = \"edge-falling\",\n\t[IRQ_TYPE_EDGE_BOTH] = \"edge-both\",\n\t[IRQ_TYPE_LEVEL_HIGH] = \"level-high\",\n\t[IRQ_TYPE_LEVEL_LOW] = \"level-low\",\n};\n\nstatic inline u32 bcm2835_gpio_rd(struct bcm2835_pinctrl *pc, unsigned reg)\n{\n\treturn readl(pc->base + reg);\n}\n\nstatic inline void bcm2835_gpio_wr(struct bcm2835_pinctrl *pc, unsigned reg,\n\t\tu32 val)\n{\n\twritel(val, pc->base + reg);\n}\n\nstatic inline int bcm2835_gpio_get_bit(struct bcm2835_pinctrl *pc, unsigned reg,\n\t\tunsigned bit)\n{\n\treg += GPIO_REG_OFFSET(bit) * 4;\n\treturn (bcm2835_gpio_rd(pc, reg) >> GPIO_REG_SHIFT(bit)) & 1;\n}\n\n \nstatic inline void bcm2835_gpio_set_bit(struct bcm2835_pinctrl *pc,\n\t\tunsigned reg, unsigned bit)\n{\n\treg += GPIO_REG_OFFSET(bit) * 4;\n\tbcm2835_gpio_wr(pc, reg, BIT(GPIO_REG_SHIFT(bit)));\n}\n\nstatic inline enum bcm2835_fsel bcm2835_pinctrl_fsel_get(\n\t\tstruct bcm2835_pinctrl *pc, unsigned pin)\n{\n\tu32 val = bcm2835_gpio_rd(pc, FSEL_REG(pin));\n\tenum bcm2835_fsel status = (val >> FSEL_SHIFT(pin)) & BCM2835_FSEL_MASK;\n\n\tdev_dbg(pc->dev, \"get %08x (%u => %s)\\n\", val, pin,\n\t\t\tbcm2835_functions[status]);\n\n\treturn status;\n}\n\nstatic inline void bcm2835_pinctrl_fsel_set(\n\t\tstruct bcm2835_pinctrl *pc, unsigned pin,\n\t\tenum bcm2835_fsel fsel)\n{\n\tu32 val;\n\tenum bcm2835_fsel cur;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pc->fsel_lock, flags);\n\tval = bcm2835_gpio_rd(pc, FSEL_REG(pin));\n\tcur = (val >> FSEL_SHIFT(pin)) & BCM2835_FSEL_MASK;\n\n\tdev_dbg(pc->dev, \"read %08x (%u => %s)\\n\", val, pin,\n\t\tbcm2835_functions[cur]);\n\n\tif (cur == fsel)\n\t\tgoto unlock;\n\n\tif (cur != BCM2835_FSEL_GPIO_IN && fsel != BCM2835_FSEL_GPIO_IN) {\n\t\t \n\t\tval &= ~(BCM2835_FSEL_MASK << FSEL_SHIFT(pin));\n\t\tval |= BCM2835_FSEL_GPIO_IN << FSEL_SHIFT(pin);\n\n\t\tdev_dbg(pc->dev, \"trans %08x (%u <= %s)\\n\", val, pin,\n\t\t\t\tbcm2835_functions[BCM2835_FSEL_GPIO_IN]);\n\t\tbcm2835_gpio_wr(pc, FSEL_REG(pin), val);\n\t}\n\n\tval &= ~(BCM2835_FSEL_MASK << FSEL_SHIFT(pin));\n\tval |= fsel << FSEL_SHIFT(pin);\n\n\tdev_dbg(pc->dev, \"write %08x (%u <= %s)\\n\", val, pin,\n\t\t\tbcm2835_functions[fsel]);\n\tbcm2835_gpio_wr(pc, FSEL_REG(pin), val);\n\nunlock:\n\tspin_unlock_irqrestore(&pc->fsel_lock, flags);\n}\n\nstatic int bcm2835_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct bcm2835_pinctrl *pc = gpiochip_get_data(chip);\n\n\tbcm2835_pinctrl_fsel_set(pc, offset, BCM2835_FSEL_GPIO_IN);\n\treturn 0;\n}\n\nstatic int bcm2835_gpio_get(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct bcm2835_pinctrl *pc = gpiochip_get_data(chip);\n\n\treturn bcm2835_gpio_get_bit(pc, GPLEV0, offset);\n}\n\nstatic int bcm2835_gpio_get_direction(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct bcm2835_pinctrl *pc = gpiochip_get_data(chip);\n\tenum bcm2835_fsel fsel = bcm2835_pinctrl_fsel_get(pc, offset);\n\n\t \n\tif (fsel > BCM2835_FSEL_GPIO_OUT)\n\t\treturn -EINVAL;\n\n\tif (fsel == BCM2835_FSEL_GPIO_IN)\n\t\treturn GPIO_LINE_DIRECTION_IN;\n\n\treturn GPIO_LINE_DIRECTION_OUT;\n}\n\nstatic void bcm2835_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\n{\n\tstruct bcm2835_pinctrl *pc = gpiochip_get_data(chip);\n\n\tbcm2835_gpio_set_bit(pc, value ? GPSET0 : GPCLR0, offset);\n}\n\nstatic int bcm2835_gpio_direction_output(struct gpio_chip *chip,\n\t\tunsigned offset, int value)\n{\n\tstruct bcm2835_pinctrl *pc = gpiochip_get_data(chip);\n\n\tbcm2835_gpio_set_bit(pc, value ? GPSET0 : GPCLR0, offset);\n\tbcm2835_pinctrl_fsel_set(pc, offset, BCM2835_FSEL_GPIO_OUT);\n\treturn 0;\n}\n\nstatic int bcm2835_add_pin_ranges_fallback(struct gpio_chip *gc)\n{\n\tstruct device_node *np = dev_of_node(gc->parent);\n\tstruct pinctrl_dev *pctldev = of_pinctrl_get(np);\n\n\tif (!pctldev)\n\t\treturn 0;\n\n\treturn gpiochip_add_pin_range(gc, pinctrl_dev_get_devname(pctldev), 0, 0,\n\t\t\t\t      gc->ngpio);\n}\n\nstatic const struct gpio_chip bcm2835_gpio_chip = {\n\t.label = MODULE_NAME,\n\t.owner = THIS_MODULE,\n\t.request = gpiochip_generic_request,\n\t.free = gpiochip_generic_free,\n\t.direction_input = bcm2835_gpio_direction_input,\n\t.direction_output = bcm2835_gpio_direction_output,\n\t.get_direction = bcm2835_gpio_get_direction,\n\t.get = bcm2835_gpio_get,\n\t.set = bcm2835_gpio_set,\n\t.set_config = gpiochip_generic_config,\n\t.base = -1,\n\t.ngpio = BCM2835_NUM_GPIOS,\n\t.can_sleep = false,\n\t.add_pin_ranges = bcm2835_add_pin_ranges_fallback,\n};\n\nstatic const struct gpio_chip bcm2711_gpio_chip = {\n\t.label = \"pinctrl-bcm2711\",\n\t.owner = THIS_MODULE,\n\t.request = gpiochip_generic_request,\n\t.free = gpiochip_generic_free,\n\t.direction_input = bcm2835_gpio_direction_input,\n\t.direction_output = bcm2835_gpio_direction_output,\n\t.get_direction = bcm2835_gpio_get_direction,\n\t.get = bcm2835_gpio_get,\n\t.set = bcm2835_gpio_set,\n\t.set_config = gpiochip_generic_config,\n\t.base = -1,\n\t.ngpio = BCM2711_NUM_GPIOS,\n\t.can_sleep = false,\n\t.add_pin_ranges = bcm2835_add_pin_ranges_fallback,\n};\n\nstatic void bcm2835_gpio_irq_handle_bank(struct bcm2835_pinctrl *pc,\n\t\t\t\t\t unsigned int bank, u32 mask)\n{\n\tunsigned long events;\n\tunsigned offset;\n\tunsigned gpio;\n\n\tevents = bcm2835_gpio_rd(pc, GPEDS0 + bank * 4);\n\tevents &= mask;\n\tevents &= pc->enabled_irq_map[bank];\n\tfor_each_set_bit(offset, &events, 32) {\n\t\tgpio = (32 * bank) + offset;\n\t\tgeneric_handle_domain_irq(pc->gpio_chip.irq.domain,\n\t\t\t\t\t  gpio);\n\t}\n}\n\nstatic void bcm2835_gpio_irq_handler(struct irq_desc *desc)\n{\n\tstruct gpio_chip *chip = irq_desc_get_handler_data(desc);\n\tstruct bcm2835_pinctrl *pc = gpiochip_get_data(chip);\n\tstruct irq_chip *host_chip = irq_desc_get_chip(desc);\n\tint irq = irq_desc_get_irq(desc);\n\tint group = 0;\n\tint i;\n\n\tfor (i = 0; i < BCM2835_NUM_IRQS; i++) {\n\t\tif (chip->irq.parents[i] == irq) {\n\t\t\tgroup = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t \n\tBUG_ON(i == BCM2835_NUM_IRQS);\n\n\tchained_irq_enter(host_chip, desc);\n\n\tswitch (group) {\n\tcase 0:  \n\t\tbcm2835_gpio_irq_handle_bank(pc, 0, 0x0fffffff);\n\t\tbreak;\n\tcase 1:  \n\t\tbcm2835_gpio_irq_handle_bank(pc, 0, 0xf0000000);\n\t\tbcm2835_gpio_irq_handle_bank(pc, 1, 0x00003fff);\n\t\tbreak;\n\tcase 2:  \n\t\tbcm2835_gpio_irq_handle_bank(pc, 1, 0x003fc000);\n\t\tbreak;\n\t}\n\n\tchained_irq_exit(host_chip, desc);\n}\n\nstatic irqreturn_t bcm2835_gpio_wake_irq_handler(int irq, void *dev_id)\n{\n\treturn IRQ_HANDLED;\n}\n\nstatic inline void __bcm2835_gpio_irq_config(struct bcm2835_pinctrl *pc,\n\tunsigned reg, unsigned offset, bool enable)\n{\n\tu32 value;\n\treg += GPIO_REG_OFFSET(offset) * 4;\n\tvalue = bcm2835_gpio_rd(pc, reg);\n\tif (enable)\n\t\tvalue |= BIT(GPIO_REG_SHIFT(offset));\n\telse\n\t\tvalue &= ~(BIT(GPIO_REG_SHIFT(offset)));\n\tbcm2835_gpio_wr(pc, reg, value);\n}\n\n \nstatic void bcm2835_gpio_irq_config(struct bcm2835_pinctrl *pc,\n\tunsigned offset, bool enable)\n{\n\tswitch (pc->irq_type[offset]) {\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\t__bcm2835_gpio_irq_config(pc, GPREN0, offset, enable);\n\t\tbreak;\n\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\t__bcm2835_gpio_irq_config(pc, GPFEN0, offset, enable);\n\t\tbreak;\n\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\t__bcm2835_gpio_irq_config(pc, GPREN0, offset, enable);\n\t\t__bcm2835_gpio_irq_config(pc, GPFEN0, offset, enable);\n\t\tbreak;\n\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\t__bcm2835_gpio_irq_config(pc, GPHEN0, offset, enable);\n\t\tbreak;\n\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\t__bcm2835_gpio_irq_config(pc, GPLEN0, offset, enable);\n\t\tbreak;\n\t}\n}\n\nstatic void bcm2835_gpio_irq_unmask(struct irq_data *data)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\n\tstruct bcm2835_pinctrl *pc = gpiochip_get_data(chip);\n\tunsigned gpio = irqd_to_hwirq(data);\n\tunsigned offset = GPIO_REG_SHIFT(gpio);\n\tunsigned bank = GPIO_REG_OFFSET(gpio);\n\tunsigned long flags;\n\n\tgpiochip_enable_irq(chip, gpio);\n\n\traw_spin_lock_irqsave(&pc->irq_lock[bank], flags);\n\tset_bit(offset, &pc->enabled_irq_map[bank]);\n\tbcm2835_gpio_irq_config(pc, gpio, true);\n\traw_spin_unlock_irqrestore(&pc->irq_lock[bank], flags);\n}\n\nstatic void bcm2835_gpio_irq_mask(struct irq_data *data)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\n\tstruct bcm2835_pinctrl *pc = gpiochip_get_data(chip);\n\tunsigned gpio = irqd_to_hwirq(data);\n\tunsigned offset = GPIO_REG_SHIFT(gpio);\n\tunsigned bank = GPIO_REG_OFFSET(gpio);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&pc->irq_lock[bank], flags);\n\tbcm2835_gpio_irq_config(pc, gpio, false);\n\t \n\tbcm2835_gpio_set_bit(pc, GPEDS0, gpio);\n\tclear_bit(offset, &pc->enabled_irq_map[bank]);\n\traw_spin_unlock_irqrestore(&pc->irq_lock[bank], flags);\n\n\tgpiochip_disable_irq(chip, gpio);\n}\n\nstatic int __bcm2835_gpio_irq_set_type_disabled(struct bcm2835_pinctrl *pc,\n\tunsigned offset, unsigned int type)\n{\n\tswitch (type) {\n\tcase IRQ_TYPE_NONE:\n\tcase IRQ_TYPE_EDGE_RISING:\n\tcase IRQ_TYPE_EDGE_FALLING:\n\tcase IRQ_TYPE_EDGE_BOTH:\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tpc->irq_type[offset] = type;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nstatic int __bcm2835_gpio_irq_set_type_enabled(struct bcm2835_pinctrl *pc,\n\tunsigned offset, unsigned int type)\n{\n\tswitch (type) {\n\tcase IRQ_TYPE_NONE:\n\t\tif (pc->irq_type[offset] != type) {\n\t\t\tbcm2835_gpio_irq_config(pc, offset, false);\n\t\t\tpc->irq_type[offset] = type;\n\t\t}\n\t\tbreak;\n\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tif (pc->irq_type[offset] == IRQ_TYPE_EDGE_BOTH) {\n\t\t\t \n\t\t\tpc->irq_type[offset] = IRQ_TYPE_EDGE_FALLING;\n\t\t\tbcm2835_gpio_irq_config(pc, offset, false);\n\t\t\tpc->irq_type[offset] = type;\n\t\t} else if (pc->irq_type[offset] != type) {\n\t\t\tbcm2835_gpio_irq_config(pc, offset, false);\n\t\t\tpc->irq_type[offset] = type;\n\t\t\tbcm2835_gpio_irq_config(pc, offset, true);\n\t\t}\n\t\tbreak;\n\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tif (pc->irq_type[offset] == IRQ_TYPE_EDGE_BOTH) {\n\t\t\t \n\t\t\tpc->irq_type[offset] = IRQ_TYPE_EDGE_RISING;\n\t\t\tbcm2835_gpio_irq_config(pc, offset, false);\n\t\t\tpc->irq_type[offset] = type;\n\t\t} else if (pc->irq_type[offset] != type) {\n\t\t\tbcm2835_gpio_irq_config(pc, offset, false);\n\t\t\tpc->irq_type[offset] = type;\n\t\t\tbcm2835_gpio_irq_config(pc, offset, true);\n\t\t}\n\t\tbreak;\n\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\tif (pc->irq_type[offset] == IRQ_TYPE_EDGE_RISING) {\n\t\t\t \n\t\t\tpc->irq_type[offset] = IRQ_TYPE_EDGE_FALLING;\n\t\t\tbcm2835_gpio_irq_config(pc, offset, true);\n\t\t\tpc->irq_type[offset] = type;\n\t\t} else if (pc->irq_type[offset] == IRQ_TYPE_EDGE_FALLING) {\n\t\t\t \n\t\t\tpc->irq_type[offset] = IRQ_TYPE_EDGE_RISING;\n\t\t\tbcm2835_gpio_irq_config(pc, offset, true);\n\t\t\tpc->irq_type[offset] = type;\n\t\t} else if (pc->irq_type[offset] != type) {\n\t\t\tbcm2835_gpio_irq_config(pc, offset, false);\n\t\t\tpc->irq_type[offset] = type;\n\t\t\tbcm2835_gpio_irq_config(pc, offset, true);\n\t\t}\n\t\tbreak;\n\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tif (pc->irq_type[offset] != type) {\n\t\t\tbcm2835_gpio_irq_config(pc, offset, false);\n\t\t\tpc->irq_type[offset] = type;\n\t\t\tbcm2835_gpio_irq_config(pc, offset, true);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int bcm2835_gpio_irq_set_type(struct irq_data *data, unsigned int type)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\n\tstruct bcm2835_pinctrl *pc = gpiochip_get_data(chip);\n\tunsigned gpio = irqd_to_hwirq(data);\n\tunsigned offset = GPIO_REG_SHIFT(gpio);\n\tunsigned bank = GPIO_REG_OFFSET(gpio);\n\tunsigned long flags;\n\tint ret;\n\n\traw_spin_lock_irqsave(&pc->irq_lock[bank], flags);\n\n\tif (test_bit(offset, &pc->enabled_irq_map[bank]))\n\t\tret = __bcm2835_gpio_irq_set_type_enabled(pc, gpio, type);\n\telse\n\t\tret = __bcm2835_gpio_irq_set_type_disabled(pc, gpio, type);\n\n\tif (type & IRQ_TYPE_EDGE_BOTH)\n\t\tirq_set_handler_locked(data, handle_edge_irq);\n\telse\n\t\tirq_set_handler_locked(data, handle_level_irq);\n\n\traw_spin_unlock_irqrestore(&pc->irq_lock[bank], flags);\n\n\treturn ret;\n}\n\nstatic void bcm2835_gpio_irq_ack(struct irq_data *data)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\n\tstruct bcm2835_pinctrl *pc = gpiochip_get_data(chip);\n\tunsigned gpio = irqd_to_hwirq(data);\n\n\tbcm2835_gpio_set_bit(pc, GPEDS0, gpio);\n}\n\nstatic int bcm2835_gpio_irq_set_wake(struct irq_data *data, unsigned int on)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\n\tstruct bcm2835_pinctrl *pc = gpiochip_get_data(chip);\n\tunsigned gpio = irqd_to_hwirq(data);\n\tunsigned int irqgroup;\n\tint ret = -EINVAL;\n\n\tif (!pc->wake_irq)\n\t\treturn ret;\n\n\tif (gpio <= 27)\n\t\tirqgroup = 0;\n\telse if (gpio >= 28 && gpio <= 45)\n\t\tirqgroup = 1;\n\telse if (gpio >= 46 && gpio <= 57)\n\t\tirqgroup = 2;\n\telse\n\t\treturn ret;\n\n\tif (on)\n\t\tret = enable_irq_wake(pc->wake_irq[irqgroup]);\n\telse\n\t\tret = disable_irq_wake(pc->wake_irq[irqgroup]);\n\n\treturn ret;\n}\n\nstatic const struct irq_chip bcm2835_gpio_irq_chip = {\n\t.name = MODULE_NAME,\n\t.irq_set_type = bcm2835_gpio_irq_set_type,\n\t.irq_ack = bcm2835_gpio_irq_ack,\n\t.irq_mask = bcm2835_gpio_irq_mask,\n\t.irq_unmask = bcm2835_gpio_irq_unmask,\n\t.irq_set_wake = bcm2835_gpio_irq_set_wake,\n\t.flags = (IRQCHIP_MASK_ON_SUSPEND | IRQCHIP_IMMUTABLE),\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic int bcm2835_pctl_get_groups_count(struct pinctrl_dev *pctldev)\n{\n\treturn BCM2835_NUM_GPIOS;\n}\n\nstatic const char *bcm2835_pctl_get_group_name(struct pinctrl_dev *pctldev,\n\t\tunsigned selector)\n{\n\treturn bcm2835_gpio_groups[selector];\n}\n\nstatic int bcm2835_pctl_get_group_pins(struct pinctrl_dev *pctldev,\n\t\tunsigned selector,\n\t\tconst unsigned **pins,\n\t\tunsigned *num_pins)\n{\n\t*pins = &bcm2835_gpio_pins[selector].number;\n\t*num_pins = 1;\n\n\treturn 0;\n}\n\nstatic void bcm2835_pctl_pin_dbg_show(struct pinctrl_dev *pctldev,\n\t\tstruct seq_file *s,\n\t\tunsigned offset)\n{\n\tstruct bcm2835_pinctrl *pc = pinctrl_dev_get_drvdata(pctldev);\n\tstruct gpio_chip *chip = &pc->gpio_chip;\n\tenum bcm2835_fsel fsel = bcm2835_pinctrl_fsel_get(pc, offset);\n\tconst char *fname = bcm2835_functions[fsel];\n\tint value = bcm2835_gpio_get_bit(pc, GPLEV0, offset);\n\tint irq = irq_find_mapping(chip->irq.domain, offset);\n\n\tseq_printf(s, \"function %s in %s; irq %d (%s)\",\n\t\tfname, value ? \"hi\" : \"lo\",\n\t\tirq, irq_type_names[pc->irq_type[offset]]);\n}\n\nstatic void bcm2835_pctl_dt_free_map(struct pinctrl_dev *pctldev,\n\t\tstruct pinctrl_map *maps, unsigned num_maps)\n{\n\tint i;\n\n\tfor (i = 0; i < num_maps; i++)\n\t\tif (maps[i].type == PIN_MAP_TYPE_CONFIGS_PIN)\n\t\t\tkfree(maps[i].data.configs.configs);\n\n\tkfree(maps);\n}\n\nstatic int bcm2835_pctl_dt_node_to_map_func(struct bcm2835_pinctrl *pc,\n\t\tstruct device_node *np, u32 pin, u32 fnum,\n\t\tstruct pinctrl_map **maps)\n{\n\tstruct pinctrl_map *map = *maps;\n\n\tif (fnum >= ARRAY_SIZE(bcm2835_functions)) {\n\t\tdev_err(pc->dev, \"%pOF: invalid brcm,function %d\\n\", np, fnum);\n\t\treturn -EINVAL;\n\t}\n\n\tmap->type = PIN_MAP_TYPE_MUX_GROUP;\n\tmap->data.mux.group = bcm2835_gpio_groups[pin];\n\tmap->data.mux.function = bcm2835_functions[fnum];\n\t(*maps)++;\n\n\treturn 0;\n}\n\nstatic int bcm2835_pctl_dt_node_to_map_pull(struct bcm2835_pinctrl *pc,\n\t\tstruct device_node *np, u32 pin, u32 pull,\n\t\tstruct pinctrl_map **maps)\n{\n\tstruct pinctrl_map *map = *maps;\n\tunsigned long *configs;\n\n\tif (pull > 2) {\n\t\tdev_err(pc->dev, \"%pOF: invalid brcm,pull %d\\n\", np, pull);\n\t\treturn -EINVAL;\n\t}\n\n\tconfigs = kzalloc(sizeof(*configs), GFP_KERNEL);\n\tif (!configs)\n\t\treturn -ENOMEM;\n\tconfigs[0] = pinconf_to_config_packed(BCM2835_PINCONF_PARAM_PULL, pull);\n\n\tmap->type = PIN_MAP_TYPE_CONFIGS_PIN;\n\tmap->data.configs.group_or_pin = bcm2835_gpio_pins[pin].name;\n\tmap->data.configs.configs = configs;\n\tmap->data.configs.num_configs = 1;\n\t(*maps)++;\n\n\treturn 0;\n}\n\nstatic int bcm2835_pctl_dt_node_to_map(struct pinctrl_dev *pctldev,\n\t\tstruct device_node *np,\n\t\tstruct pinctrl_map **map, unsigned int *num_maps)\n{\n\tstruct bcm2835_pinctrl *pc = pinctrl_dev_get_drvdata(pctldev);\n\tstruct property *pins, *funcs, *pulls;\n\tint num_pins, num_funcs, num_pulls, maps_per_pin;\n\tstruct pinctrl_map *maps, *cur_map;\n\tint i, err;\n\tu32 pin, func, pull;\n\n\t \n\terr = pinconf_generic_dt_node_to_map_all(pctldev, np, map, num_maps);\n\tif (err || *num_maps)\n\t\treturn err;\n\n\t \n\tpins = of_find_property(np, \"brcm,pins\", NULL);\n\tif (!pins) {\n\t\tdev_err(pc->dev, \"%pOF: missing brcm,pins property\\n\", np);\n\t\treturn -EINVAL;\n\t}\n\n\tfuncs = of_find_property(np, \"brcm,function\", NULL);\n\tpulls = of_find_property(np, \"brcm,pull\", NULL);\n\n\tif (!funcs && !pulls) {\n\t\tdev_err(pc->dev,\n\t\t\t\"%pOF: neither brcm,function nor brcm,pull specified\\n\",\n\t\t\tnp);\n\t\treturn -EINVAL;\n\t}\n\n\tnum_pins = pins->length / 4;\n\tnum_funcs = funcs ? (funcs->length / 4) : 0;\n\tnum_pulls = pulls ? (pulls->length / 4) : 0;\n\n\tif (num_funcs > 1 && num_funcs != num_pins) {\n\t\tdev_err(pc->dev,\n\t\t\t\"%pOF: brcm,function must have 1 or %d entries\\n\",\n\t\t\tnp, num_pins);\n\t\treturn -EINVAL;\n\t}\n\n\tif (num_pulls > 1 && num_pulls != num_pins) {\n\t\tdev_err(pc->dev,\n\t\t\t\"%pOF: brcm,pull must have 1 or %d entries\\n\",\n\t\t\tnp, num_pins);\n\t\treturn -EINVAL;\n\t}\n\n\tmaps_per_pin = 0;\n\tif (num_funcs)\n\t\tmaps_per_pin++;\n\tif (num_pulls)\n\t\tmaps_per_pin++;\n\tcur_map = maps = kcalloc(num_pins * maps_per_pin, sizeof(*maps),\n\t\t\t\t GFP_KERNEL);\n\tif (!maps)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < num_pins; i++) {\n\t\terr = of_property_read_u32_index(np, \"brcm,pins\", i, &pin);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (pin >= pc->pctl_desc.npins) {\n\t\t\tdev_err(pc->dev, \"%pOF: invalid brcm,pins value %d\\n\",\n\t\t\t\tnp, pin);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (num_funcs) {\n\t\t\terr = of_property_read_u32_index(np, \"brcm,function\",\n\t\t\t\t\t(num_funcs > 1) ? i : 0, &func);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\terr = bcm2835_pctl_dt_node_to_map_func(pc, np, pin,\n\t\t\t\t\t\t\tfunc, &cur_map);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t\tif (num_pulls) {\n\t\t\terr = of_property_read_u32_index(np, \"brcm,pull\",\n\t\t\t\t\t(num_pulls > 1) ? i : 0, &pull);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\terr = bcm2835_pctl_dt_node_to_map_pull(pc, np, pin,\n\t\t\t\t\t\t\tpull, &cur_map);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\t*map = maps;\n\t*num_maps = num_pins * maps_per_pin;\n\n\treturn 0;\n\nout:\n\tbcm2835_pctl_dt_free_map(pctldev, maps, num_pins * maps_per_pin);\n\treturn err;\n}\n\nstatic const struct pinctrl_ops bcm2835_pctl_ops = {\n\t.get_groups_count = bcm2835_pctl_get_groups_count,\n\t.get_group_name = bcm2835_pctl_get_group_name,\n\t.get_group_pins = bcm2835_pctl_get_group_pins,\n\t.pin_dbg_show = bcm2835_pctl_pin_dbg_show,\n\t.dt_node_to_map = bcm2835_pctl_dt_node_to_map,\n\t.dt_free_map = bcm2835_pctl_dt_free_map,\n};\n\nstatic int bcm2835_pmx_free(struct pinctrl_dev *pctldev,\n\t\tunsigned offset)\n{\n\tstruct bcm2835_pinctrl *pc = pinctrl_dev_get_drvdata(pctldev);\n\n\t \n\tbcm2835_pinctrl_fsel_set(pc, offset, BCM2835_FSEL_GPIO_IN);\n\treturn 0;\n}\n\nstatic int bcm2835_pmx_get_functions_count(struct pinctrl_dev *pctldev)\n{\n\treturn BCM2835_FSEL_COUNT;\n}\n\nstatic const char *bcm2835_pmx_get_function_name(struct pinctrl_dev *pctldev,\n\t\tunsigned selector)\n{\n\treturn bcm2835_functions[selector];\n}\n\nstatic int bcm2835_pmx_get_function_groups(struct pinctrl_dev *pctldev,\n\t\tunsigned selector,\n\t\tconst char * const **groups,\n\t\tunsigned * const num_groups)\n{\n\t \n\t*groups = bcm2835_gpio_groups;\n\t*num_groups = BCM2835_NUM_GPIOS;\n\n\treturn 0;\n}\n\nstatic int bcm2835_pmx_set(struct pinctrl_dev *pctldev,\n\t\tunsigned func_selector,\n\t\tunsigned group_selector)\n{\n\tstruct bcm2835_pinctrl *pc = pinctrl_dev_get_drvdata(pctldev);\n\n\tbcm2835_pinctrl_fsel_set(pc, group_selector, func_selector);\n\n\treturn 0;\n}\n\nstatic void bcm2835_pmx_gpio_disable_free(struct pinctrl_dev *pctldev,\n\t\tstruct pinctrl_gpio_range *range,\n\t\tunsigned offset)\n{\n\tstruct bcm2835_pinctrl *pc = pinctrl_dev_get_drvdata(pctldev);\n\n\t \n\tbcm2835_pinctrl_fsel_set(pc, offset, BCM2835_FSEL_GPIO_IN);\n}\n\nstatic int bcm2835_pmx_gpio_set_direction(struct pinctrl_dev *pctldev,\n\t\tstruct pinctrl_gpio_range *range,\n\t\tunsigned offset,\n\t\tbool input)\n{\n\tstruct bcm2835_pinctrl *pc = pinctrl_dev_get_drvdata(pctldev);\n\tenum bcm2835_fsel fsel = input ?\n\t\tBCM2835_FSEL_GPIO_IN : BCM2835_FSEL_GPIO_OUT;\n\n\tbcm2835_pinctrl_fsel_set(pc, offset, fsel);\n\n\treturn 0;\n}\n\nstatic const struct pinmux_ops bcm2835_pmx_ops = {\n\t.free = bcm2835_pmx_free,\n\t.get_functions_count = bcm2835_pmx_get_functions_count,\n\t.get_function_name = bcm2835_pmx_get_function_name,\n\t.get_function_groups = bcm2835_pmx_get_function_groups,\n\t.set_mux = bcm2835_pmx_set,\n\t.gpio_disable_free = bcm2835_pmx_gpio_disable_free,\n\t.gpio_set_direction = bcm2835_pmx_gpio_set_direction,\n};\n\nstatic int bcm2835_pinconf_get(struct pinctrl_dev *pctldev,\n\t\t\tunsigned pin, unsigned long *config)\n{\n\t \n\treturn -ENOTSUPP;\n}\n\nstatic void bcm2835_pull_config_set(struct bcm2835_pinctrl *pc,\n\t\tunsigned int pin, unsigned int arg)\n{\n\tu32 off, bit;\n\n\toff = GPIO_REG_OFFSET(pin);\n\tbit = GPIO_REG_SHIFT(pin);\n\n\tbcm2835_gpio_wr(pc, GPPUD, arg & 3);\n\t \n\tudelay(1);\n\tbcm2835_gpio_wr(pc, GPPUDCLK0 + (off * 4), BIT(bit));\n\tudelay(1);\n\tbcm2835_gpio_wr(pc, GPPUDCLK0 + (off * 4), 0);\n}\n\nstatic int bcm2835_pinconf_set(struct pinctrl_dev *pctldev,\n\t\t\tunsigned int pin, unsigned long *configs,\n\t\t\tunsigned int num_configs)\n{\n\tstruct bcm2835_pinctrl *pc = pinctrl_dev_get_drvdata(pctldev);\n\tu32 param, arg;\n\tint i;\n\n\tfor (i = 0; i < num_configs; i++) {\n\t\tparam = pinconf_to_config_param(configs[i]);\n\t\targ = pinconf_to_config_argument(configs[i]);\n\n\t\tswitch (param) {\n\t\t \n\t\tcase BCM2835_PINCONF_PARAM_PULL:\n\t\t\tbcm2835_pull_config_set(pc, pin, arg);\n\t\t\tbreak;\n\n\t\t \n\t\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\t\tbcm2835_pull_config_set(pc, pin, BCM2835_PUD_OFF);\n\t\t\tbreak;\n\n\t\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\t\tbcm2835_pull_config_set(pc, pin, BCM2835_PUD_DOWN);\n\t\t\tbreak;\n\n\t\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\t\tbcm2835_pull_config_set(pc, pin, BCM2835_PUD_UP);\n\t\t\tbreak;\n\n\t\t \n\t\tcase PIN_CONFIG_OUTPUT:\n\t\t\tbcm2835_gpio_set_bit(pc, arg ? GPSET0 : GPCLR0, pin);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -ENOTSUPP;\n\n\t\t}  \n\t}  \n\n\treturn 0;\n}\n\nstatic const struct pinconf_ops bcm2835_pinconf_ops = {\n\t.is_generic = true,\n\t.pin_config_get = bcm2835_pinconf_get,\n\t.pin_config_set = bcm2835_pinconf_set,\n};\n\nstatic void bcm2711_pull_config_set(struct bcm2835_pinctrl *pc,\n\t\t\t\t    unsigned int pin, unsigned int arg)\n{\n\tu32 shifter;\n\tu32 value;\n\tu32 off;\n\n\toff = PUD_2711_REG_OFFSET(pin);\n\tshifter = PUD_2711_REG_SHIFT(pin);\n\n\tvalue = bcm2835_gpio_rd(pc, GP_GPIO_PUP_PDN_CNTRL_REG0 + (off * 4));\n\tvalue &= ~(PUD_2711_MASK << shifter);\n\tvalue |= (arg << shifter);\n\tbcm2835_gpio_wr(pc, GP_GPIO_PUP_PDN_CNTRL_REG0 + (off * 4), value);\n}\n\nstatic int bcm2711_pinconf_set(struct pinctrl_dev *pctldev,\n\t\t\t       unsigned int pin, unsigned long *configs,\n\t\t\t       unsigned int num_configs)\n{\n\tstruct bcm2835_pinctrl *pc = pinctrl_dev_get_drvdata(pctldev);\n\tu32 param, arg;\n\tint i;\n\n\tfor (i = 0; i < num_configs; i++) {\n\t\tparam = pinconf_to_config_param(configs[i]);\n\t\targ = pinconf_to_config_argument(configs[i]);\n\n\t\tswitch (param) {\n\t\t \n\t\tcase BCM2835_PINCONF_PARAM_PULL:\n\t\t\tif (arg == BCM2835_PUD_UP)\n\t\t\t\targ = BCM2711_PULL_UP;\n\t\t\telse if (arg == BCM2835_PUD_DOWN)\n\t\t\t\targ = BCM2711_PULL_DOWN;\n\t\t\telse\n\t\t\t\targ = BCM2711_PULL_NONE;\n\n\t\t\tbcm2711_pull_config_set(pc, pin, arg);\n\t\t\tbreak;\n\n\t\t \n\t\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\t\tbcm2711_pull_config_set(pc, pin, BCM2711_PULL_NONE);\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\t\tbcm2711_pull_config_set(pc, pin, BCM2711_PULL_DOWN);\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\t\tbcm2711_pull_config_set(pc, pin, BCM2711_PULL_UP);\n\t\t\tbreak;\n\n\t\t \n\t\tcase PIN_CONFIG_OUTPUT:\n\t\t\tbcm2835_gpio_set_bit(pc, arg ? GPSET0 : GPCLR0, pin);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t}  \n\n\treturn 0;\n}\n\nstatic const struct pinconf_ops bcm2711_pinconf_ops = {\n\t.is_generic = true,\n\t.pin_config_get = bcm2835_pinconf_get,\n\t.pin_config_set = bcm2711_pinconf_set,\n};\n\nstatic const struct pinctrl_desc bcm2835_pinctrl_desc = {\n\t.name = MODULE_NAME,\n\t.pins = bcm2835_gpio_pins,\n\t.npins = BCM2835_NUM_GPIOS,\n\t.pctlops = &bcm2835_pctl_ops,\n\t.pmxops = &bcm2835_pmx_ops,\n\t.confops = &bcm2835_pinconf_ops,\n\t.owner = THIS_MODULE,\n};\n\nstatic const struct pinctrl_desc bcm2711_pinctrl_desc = {\n\t.name = \"pinctrl-bcm2711\",\n\t.pins = bcm2835_gpio_pins,\n\t.npins = BCM2711_NUM_GPIOS,\n\t.pctlops = &bcm2835_pctl_ops,\n\t.pmxops = &bcm2835_pmx_ops,\n\t.confops = &bcm2711_pinconf_ops,\n\t.owner = THIS_MODULE,\n};\n\nstatic const struct pinctrl_gpio_range bcm2835_pinctrl_gpio_range = {\n\t.name = MODULE_NAME,\n\t.npins = BCM2835_NUM_GPIOS,\n};\n\nstatic const struct pinctrl_gpio_range bcm2711_pinctrl_gpio_range = {\n\t.name = \"pinctrl-bcm2711\",\n\t.npins = BCM2711_NUM_GPIOS,\n};\n\nstruct bcm_plat_data {\n\tconst struct gpio_chip *gpio_chip;\n\tconst struct pinctrl_desc *pctl_desc;\n\tconst struct pinctrl_gpio_range *gpio_range;\n};\n\nstatic const struct bcm_plat_data bcm2835_plat_data = {\n\t.gpio_chip = &bcm2835_gpio_chip,\n\t.pctl_desc = &bcm2835_pinctrl_desc,\n\t.gpio_range = &bcm2835_pinctrl_gpio_range,\n};\n\nstatic const struct bcm_plat_data bcm2711_plat_data = {\n\t.gpio_chip = &bcm2711_gpio_chip,\n\t.pctl_desc = &bcm2711_pinctrl_desc,\n\t.gpio_range = &bcm2711_pinctrl_gpio_range,\n};\n\nstatic const struct of_device_id bcm2835_pinctrl_match[] = {\n\t{\n\t\t.compatible = \"brcm,bcm2835-gpio\",\n\t\t.data = &bcm2835_plat_data,\n\t},\n\t{\n\t\t.compatible = \"brcm,bcm2711-gpio\",\n\t\t.data = &bcm2711_plat_data,\n\t},\n\t{\n\t\t.compatible = \"brcm,bcm7211-gpio\",\n\t\t.data = &bcm2711_plat_data,\n\t},\n\t{}\n};\n\nstatic int bcm2835_pinctrl_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tconst struct bcm_plat_data *pdata;\n\tstruct bcm2835_pinctrl *pc;\n\tstruct gpio_irq_chip *girq;\n\tstruct resource iomem;\n\tint err, i;\n\tconst struct of_device_id *match;\n\tint is_7211 = 0;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(bcm2835_gpio_pins) != BCM2711_NUM_GPIOS);\n\tBUILD_BUG_ON(ARRAY_SIZE(bcm2835_gpio_groups) != BCM2711_NUM_GPIOS);\n\n\tpc = devm_kzalloc(dev, sizeof(*pc), GFP_KERNEL);\n\tif (!pc)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, pc);\n\tpc->dev = dev;\n\n\terr = of_address_to_resource(np, 0, &iomem);\n\tif (err) {\n\t\tdev_err(dev, \"could not get IO memory\\n\");\n\t\treturn err;\n\t}\n\n\tpc->base = devm_ioremap_resource(dev, &iomem);\n\tif (IS_ERR(pc->base))\n\t\treturn PTR_ERR(pc->base);\n\n\tmatch = of_match_node(bcm2835_pinctrl_match, pdev->dev.of_node);\n\tif (!match)\n\t\treturn -EINVAL;\n\n\tpdata = match->data;\n\tis_7211 = of_device_is_compatible(np, \"brcm,bcm7211-gpio\");\n\n\tpc->gpio_chip = *pdata->gpio_chip;\n\tpc->gpio_chip.parent = dev;\n\n\tspin_lock_init(&pc->fsel_lock);\n\tfor (i = 0; i < BCM2835_NUM_BANKS; i++) {\n\t\tunsigned long events;\n\t\tunsigned offset;\n\n\t\t \n\t\tbcm2835_gpio_wr(pc, GPREN0 + i * 4, 0);\n\t\tbcm2835_gpio_wr(pc, GPFEN0 + i * 4, 0);\n\t\tbcm2835_gpio_wr(pc, GPHEN0 + i * 4, 0);\n\t\tbcm2835_gpio_wr(pc, GPLEN0 + i * 4, 0);\n\t\tbcm2835_gpio_wr(pc, GPAREN0 + i * 4, 0);\n\t\tbcm2835_gpio_wr(pc, GPAFEN0 + i * 4, 0);\n\n\t\t \n\t\tevents = bcm2835_gpio_rd(pc, GPEDS0 + i * 4);\n\t\tfor_each_set_bit(offset, &events, 32)\n\t\t\tbcm2835_gpio_wr(pc, GPEDS0 + i * 4, BIT(offset));\n\n\t\traw_spin_lock_init(&pc->irq_lock[i]);\n\t}\n\n\tpc->pctl_desc = *pdata->pctl_desc;\n\tpc->pctl_dev = devm_pinctrl_register(dev, &pc->pctl_desc, pc);\n\tif (IS_ERR(pc->pctl_dev)) {\n\t\tgpiochip_remove(&pc->gpio_chip);\n\t\treturn PTR_ERR(pc->pctl_dev);\n\t}\n\n\tpc->gpio_range = *pdata->gpio_range;\n\tpc->gpio_range.base = pc->gpio_chip.base;\n\tpc->gpio_range.gc = &pc->gpio_chip;\n\tpinctrl_add_gpio_range(pc->pctl_dev, &pc->gpio_range);\n\n\tgirq = &pc->gpio_chip.irq;\n\tgpio_irq_chip_set_chip(girq, &bcm2835_gpio_irq_chip);\n\tgirq->parent_handler = bcm2835_gpio_irq_handler;\n\tgirq->num_parents = BCM2835_NUM_IRQS;\n\tgirq->parents = devm_kcalloc(dev, BCM2835_NUM_IRQS,\n\t\t\t\t     sizeof(*girq->parents),\n\t\t\t\t     GFP_KERNEL);\n\tif (!girq->parents) {\n\t\terr = -ENOMEM;\n\t\tgoto out_remove;\n\t}\n\n\tif (is_7211) {\n\t\tpc->wake_irq = devm_kcalloc(dev, BCM2835_NUM_IRQS,\n\t\t\t\t\t    sizeof(*pc->wake_irq),\n\t\t\t\t\t    GFP_KERNEL);\n\t\tif (!pc->wake_irq) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_remove;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < BCM2835_NUM_IRQS; i++) {\n\t\tint len;\n\t\tchar *name;\n\n\t\tgirq->parents[i] = irq_of_parse_and_map(np, i);\n\t\tif (!is_7211) {\n\t\t\tif (!girq->parents[i]) {\n\t\t\t\tgirq->num_parents = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tpc->wake_irq[i] = irq_of_parse_and_map(np, i +\n\t\t\t\t\t\t       BCM2835_NUM_IRQS + 1);\n\n\t\tlen = strlen(dev_name(pc->dev)) + 16;\n\t\tname = devm_kzalloc(pc->dev, len, GFP_KERNEL);\n\t\tif (!name) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_remove;\n\t\t}\n\n\t\tsnprintf(name, len, \"%s:bank%d\", dev_name(pc->dev), i);\n\n\t\t \n\t\terr = devm_request_irq(dev, pc->wake_irq[i],\n\t\t\t\t       bcm2835_gpio_wake_irq_handler,\n\t\t\t\t       IRQF_SHARED, name, pc);\n\t\tif (err)\n\t\t\tdev_warn(dev, \"unable to request wake IRQ %d\\n\",\n\t\t\t\t pc->wake_irq[i]);\n\t}\n\n\tgirq->default_type = IRQ_TYPE_NONE;\n\tgirq->handler = handle_level_irq;\n\n\terr = gpiochip_add_data(&pc->gpio_chip, pc);\n\tif (err) {\n\t\tdev_err(dev, \"could not add GPIO chip\\n\");\n\t\tgoto out_remove;\n\t}\n\n\treturn 0;\n\nout_remove:\n\tpinctrl_remove_gpio_range(pc->pctl_dev, &pc->gpio_range);\n\treturn err;\n}\n\nstatic struct platform_driver bcm2835_pinctrl_driver = {\n\t.probe = bcm2835_pinctrl_probe,\n\t.driver = {\n\t\t.name = MODULE_NAME,\n\t\t.of_match_table = bcm2835_pinctrl_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n};\nmodule_platform_driver(bcm2835_pinctrl_driver);\n\nMODULE_AUTHOR(\"Chris Boot\");\nMODULE_AUTHOR(\"Simon Arlott\");\nMODULE_AUTHOR(\"Stephen Warren\");\nMODULE_DESCRIPTION(\"Broadcom BCM2835/2711 pinctrl and GPIO driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}