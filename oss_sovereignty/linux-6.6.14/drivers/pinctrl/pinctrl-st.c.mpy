{
  "module_name": "pinctrl-st.c",
  "hash_id": "7352e994f5be9929d62d0cd711d1db86f884c9daba32511b6e1ac97e261c2bb0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/pinctrl-st.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/gpio/driver.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/string_helpers.h>\n\n#include <linux/pinctrl/consumer.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinmux.h>\n\n#include \"core.h\"\n\n \n \n#define REG_PIO_POUT\t\t\t0x00\n \n#define REG_PIO_SET_POUT\t\t0x04\n \n#define REG_PIO_CLR_POUT\t\t0x08\n \n#define REG_PIO_PIN\t\t\t0x10\n \n#define REG_PIO_PC(n)\t\t\t(0x20 + (n) * 0x10)\n \n#define REG_PIO_SET_PC(n)\t\t(0x24 + (n) * 0x10)\n \n#define REG_PIO_CLR_PC(n)\t\t(0x28 + (n) * 0x10)\n \n#define REG_PIO_PCOMP\t\t\t0x50\n \n#define REG_PIO_SET_PCOMP\t\t0x54\n \n#define REG_PIO_CLR_PCOMP\t\t0x58\n \n#define REG_PIO_PMASK\t\t\t0x60\n \n#define REG_PIO_SET_PMASK\t\t0x64\n \n#define REG_PIO_CLR_PMASK\t\t0x68\n\n#define ST_GPIO_DIRECTION_BIDIR\t0x1\n#define ST_GPIO_DIRECTION_OUT\t0x2\n#define ST_GPIO_DIRECTION_IN\t0x4\n\n \n#define RT_P_CFGS_PER_BANK\t\t\t2\n#define RT_P_CFG0_CLK1NOTCLK0_FIELD(reg)\tREG_FIELD(reg, 0, 7)\n#define RT_P_CFG0_DELAY_0_FIELD(reg)\t\tREG_FIELD(reg, 16, 23)\n#define RT_P_CFG0_DELAY_1_FIELD(reg)\t\tREG_FIELD(reg, 24, 31)\n#define RT_P_CFG1_INVERTCLK_FIELD(reg)\t\tREG_FIELD(reg, 0, 7)\n#define RT_P_CFG1_RETIME_FIELD(reg)\t\tREG_FIELD(reg, 8, 15)\n#define RT_P_CFG1_CLKNOTDATA_FIELD(reg)\t\tREG_FIELD(reg, 16, 23)\n#define RT_P_CFG1_DOUBLE_EDGE_FIELD(reg)\tREG_FIELD(reg, 24, 31)\n\n \n#define RT_D_CFGS_PER_BANK\t\t8\n#define RT_D_CFG_CLK_SHIFT\t\t0\n#define RT_D_CFG_CLK_MASK\t\t(0x3 << 0)\n#define RT_D_CFG_CLKNOTDATA_SHIFT\t2\n#define RT_D_CFG_CLKNOTDATA_MASK\tBIT(2)\n#define RT_D_CFG_DELAY_SHIFT\t\t3\n#define RT_D_CFG_DELAY_MASK\t\t(0xf << 3)\n#define RT_D_CFG_DELAY_INNOTOUT_SHIFT\t7\n#define RT_D_CFG_DELAY_INNOTOUT_MASK\tBIT(7)\n#define RT_D_CFG_DOUBLE_EDGE_SHIFT\t8\n#define RT_D_CFG_DOUBLE_EDGE_MASK\tBIT(8)\n#define RT_D_CFG_INVERTCLK_SHIFT\t9\n#define RT_D_CFG_INVERTCLK_MASK\t\tBIT(9)\n#define RT_D_CFG_RETIME_SHIFT\t\t10\n#define RT_D_CFG_RETIME_MASK\t\tBIT(10)\n\n \n\n#define ST_PINCONF_UNPACK(conf, param)\\\n\t\t\t\t((conf >> ST_PINCONF_ ##param ##_SHIFT) \\\n\t\t\t\t& ST_PINCONF_ ##param ##_MASK)\n\n#define ST_PINCONF_PACK(conf, val, param)\t(conf |=\\\n\t\t\t\t((val & ST_PINCONF_ ##param ##_MASK) << \\\n\t\t\t\t\tST_PINCONF_ ##param ##_SHIFT))\n\n \n#define ST_PINCONF_OE_MASK\t\t0x1\n#define ST_PINCONF_OE_SHIFT\t\t27\n#define ST_PINCONF_OE\t\t\tBIT(27)\n#define ST_PINCONF_UNPACK_OE(conf)\tST_PINCONF_UNPACK(conf, OE)\n#define ST_PINCONF_PACK_OE(conf)\tST_PINCONF_PACK(conf, 1, OE)\n\n \n#define ST_PINCONF_PU_MASK\t\t0x1\n#define ST_PINCONF_PU_SHIFT\t\t26\n#define ST_PINCONF_PU\t\t\tBIT(26)\n#define ST_PINCONF_UNPACK_PU(conf)\tST_PINCONF_UNPACK(conf, PU)\n#define ST_PINCONF_PACK_PU(conf)\tST_PINCONF_PACK(conf, 1, PU)\n\n \n#define ST_PINCONF_OD_MASK\t\t0x1\n#define ST_PINCONF_OD_SHIFT\t\t25\n#define ST_PINCONF_OD\t\t\tBIT(25)\n#define ST_PINCONF_UNPACK_OD(conf)\tST_PINCONF_UNPACK(conf, OD)\n#define ST_PINCONF_PACK_OD(conf)\tST_PINCONF_PACK(conf, 1, OD)\n\n#define ST_PINCONF_RT_MASK\t\t0x1\n#define ST_PINCONF_RT_SHIFT\t\t23\n#define ST_PINCONF_RT\t\t\tBIT(23)\n#define ST_PINCONF_UNPACK_RT(conf)\tST_PINCONF_UNPACK(conf, RT)\n#define ST_PINCONF_PACK_RT(conf)\tST_PINCONF_PACK(conf, 1, RT)\n\n#define ST_PINCONF_RT_INVERTCLK_MASK\t0x1\n#define ST_PINCONF_RT_INVERTCLK_SHIFT\t22\n#define ST_PINCONF_RT_INVERTCLK\t\tBIT(22)\n#define ST_PINCONF_UNPACK_RT_INVERTCLK(conf) \\\n\t\t\tST_PINCONF_UNPACK(conf, RT_INVERTCLK)\n#define ST_PINCONF_PACK_RT_INVERTCLK(conf) \\\n\t\t\tST_PINCONF_PACK(conf, 1, RT_INVERTCLK)\n\n#define ST_PINCONF_RT_CLKNOTDATA_MASK\t0x1\n#define ST_PINCONF_RT_CLKNOTDATA_SHIFT\t21\n#define ST_PINCONF_RT_CLKNOTDATA\tBIT(21)\n#define ST_PINCONF_UNPACK_RT_CLKNOTDATA(conf)\t\\\n\t\t\t\tST_PINCONF_UNPACK(conf, RT_CLKNOTDATA)\n#define ST_PINCONF_PACK_RT_CLKNOTDATA(conf) \\\n\t\t\t\tST_PINCONF_PACK(conf, 1, RT_CLKNOTDATA)\n\n#define ST_PINCONF_RT_DOUBLE_EDGE_MASK\t0x1\n#define ST_PINCONF_RT_DOUBLE_EDGE_SHIFT\t20\n#define ST_PINCONF_RT_DOUBLE_EDGE\tBIT(20)\n#define ST_PINCONF_UNPACK_RT_DOUBLE_EDGE(conf) \\\n\t\t\t\tST_PINCONF_UNPACK(conf, RT_DOUBLE_EDGE)\n#define ST_PINCONF_PACK_RT_DOUBLE_EDGE(conf) \\\n\t\t\t\tST_PINCONF_PACK(conf, 1, RT_DOUBLE_EDGE)\n\n#define ST_PINCONF_RT_CLK_MASK\t\t0x3\n#define ST_PINCONF_RT_CLK_SHIFT\t\t18\n#define ST_PINCONF_RT_CLK\t\tBIT(18)\n#define ST_PINCONF_UNPACK_RT_CLK(conf)\tST_PINCONF_UNPACK(conf, RT_CLK)\n#define ST_PINCONF_PACK_RT_CLK(conf, val) ST_PINCONF_PACK(conf, val, RT_CLK)\n\n \n#define ST_PINCONF_RT_DELAY_MASK\t0xffff\n#define ST_PINCONF_RT_DELAY_SHIFT\t0\n#define ST_PINCONF_UNPACK_RT_DELAY(conf) ST_PINCONF_UNPACK(conf, RT_DELAY)\n#define ST_PINCONF_PACK_RT_DELAY(conf, val) \\\n\t\t\t\tST_PINCONF_PACK(conf, val, RT_DELAY)\n\n#define ST_GPIO_PINS_PER_BANK\t(8)\n#define OF_GPIO_ARGS_MIN\t(4)\n#define OF_RT_ARGS_MIN\t\t(2)\n\n#define gpio_range_to_bank(chip) \\\n\t\tcontainer_of(chip, struct st_gpio_bank, range)\n\n#define pc_to_bank(pc) \\\n\t\tcontainer_of(pc, struct st_gpio_bank, pc)\n\nenum st_retime_style {\n\tst_retime_style_none,\n\tst_retime_style_packed,\n\tst_retime_style_dedicated,\n};\n\nstruct st_retime_dedicated {\n\tstruct regmap_field *rt[ST_GPIO_PINS_PER_BANK];\n};\n\nstruct st_retime_packed {\n\tstruct regmap_field *clk1notclk0;\n\tstruct regmap_field *delay_0;\n\tstruct regmap_field *delay_1;\n\tstruct regmap_field *invertclk;\n\tstruct regmap_field *retime;\n\tstruct regmap_field *clknotdata;\n\tstruct regmap_field *double_edge;\n};\n\nstruct st_pio_control {\n\tu32 rt_pin_mask;\n\tstruct regmap_field *alt, *oe, *pu, *od;\n\t \n\tunion {\n\t\tstruct st_retime_packed\t\trt_p;\n\t\tstruct st_retime_dedicated\trt_d;\n\t} rt;\n};\n\nstruct st_pctl_data {\n\tconst enum st_retime_style\trt_style;\n\tconst unsigned int\t\t*input_delays;\n\tconst int\t\t\tninput_delays;\n\tconst unsigned int\t\t*output_delays;\n\tconst int\t\t\tnoutput_delays;\n\t \n\tconst int alt, oe, pu, od, rt;\n};\n\nstruct st_pinconf {\n\tint\t\tpin;\n\tconst char\t*name;\n\tunsigned long\tconfig;\n\tint\t\taltfunc;\n};\n\nstruct st_pmx_func {\n\tconst char\t*name;\n\tconst char\t**groups;\n\tunsigned\tngroups;\n};\n\nstruct st_pctl_group {\n\tconst char\t\t*name;\n\tunsigned int\t\t*pins;\n\tunsigned\t\tnpins;\n\tstruct st_pinconf\t*pin_conf;\n};\n\n \n\n#define ST_IRQ_EDGE_CONF_BITS_PER_PIN\t4\n#define ST_IRQ_EDGE_MASK\t\t0xf\n#define ST_IRQ_EDGE_FALLING\t\tBIT(0)\n#define ST_IRQ_EDGE_RISING\t\tBIT(1)\n#define ST_IRQ_EDGE_BOTH\t\t(BIT(0) | BIT(1))\n\n#define ST_IRQ_RISING_EDGE_CONF(pin) \\\n\t(ST_IRQ_EDGE_RISING << (pin * ST_IRQ_EDGE_CONF_BITS_PER_PIN))\n\n#define ST_IRQ_FALLING_EDGE_CONF(pin) \\\n\t(ST_IRQ_EDGE_FALLING << (pin * ST_IRQ_EDGE_CONF_BITS_PER_PIN))\n\n#define ST_IRQ_BOTH_EDGE_CONF(pin) \\\n\t(ST_IRQ_EDGE_BOTH << (pin * ST_IRQ_EDGE_CONF_BITS_PER_PIN))\n\n#define ST_IRQ_EDGE_CONF(conf, pin) \\\n\t(conf >> (pin * ST_IRQ_EDGE_CONF_BITS_PER_PIN) & ST_IRQ_EDGE_MASK)\n\nstruct st_gpio_bank {\n\tstruct gpio_chip\t\tgpio_chip;\n\tstruct pinctrl_gpio_range\trange;\n\tvoid __iomem\t\t\t*base;\n\tstruct st_pio_control\t\tpc;\n\tunsigned long\t\t\tirq_edge_conf;\n\tspinlock_t                      lock;\n};\n\nstruct st_pinctrl {\n\tstruct device\t\t\t*dev;\n\tstruct pinctrl_dev\t\t*pctl;\n\tstruct st_gpio_bank\t\t*banks;\n\tint\t\t\t\tnbanks;\n\tstruct st_pmx_func\t\t*functions;\n\tint\t\t\t\tnfunctions;\n\tstruct st_pctl_group\t\t*groups;\n\tint\t\t\t\tngroups;\n\tstruct regmap\t\t\t*regmap;\n\tconst struct st_pctl_data\t*data;\n\tvoid __iomem\t\t\t*irqmux_base;\n};\n\n \n\nstatic const unsigned int stih407_delays[] = {0, 300, 500, 750, 1000, 1250,\n\t\t\t1500, 1750, 2000, 2250, 2500, 2750, 3000, 3250 };\n\nstatic const struct st_pctl_data  stih407_data = {\n\t.rt_style       = st_retime_style_dedicated,\n\t.input_delays   = stih407_delays,\n\t.ninput_delays  = ARRAY_SIZE(stih407_delays),\n\t.output_delays  = stih407_delays,\n\t.noutput_delays = ARRAY_SIZE(stih407_delays),\n\t.alt = 0, .oe = 40, .pu = 50, .od = 60, .rt = 100,\n};\n\nstatic const struct st_pctl_data stih407_flashdata = {\n\t.rt_style\t= st_retime_style_none,\n\t.input_delays\t= stih407_delays,\n\t.ninput_delays\t= ARRAY_SIZE(stih407_delays),\n\t.output_delays\t= stih407_delays,\n\t.noutput_delays = ARRAY_SIZE(stih407_delays),\n\t.alt = 0,\n\t.oe = -1,  \n\t.pu = -1,  \n\t.od = 60,\n\t.rt = 100,\n};\n\nstatic struct st_pio_control *st_get_pio_control(\n\t\t\tstruct pinctrl_dev *pctldev, int pin)\n{\n\tstruct pinctrl_gpio_range *range =\n\t\t\t pinctrl_find_gpio_range_from_pin(pctldev, pin);\n\tstruct st_gpio_bank *bank = gpio_range_to_bank(range);\n\n\treturn &bank->pc;\n}\n\n \nstatic inline int st_gpio_bank(int gpio)\n{\n\treturn gpio/ST_GPIO_PINS_PER_BANK;\n}\n\nstatic inline int st_gpio_pin(int gpio)\n{\n\treturn gpio%ST_GPIO_PINS_PER_BANK;\n}\n\nstatic void st_pinconf_set_config(struct st_pio_control *pc,\n\t\t\t\tint pin, unsigned long config)\n{\n\tstruct regmap_field *output_enable = pc->oe;\n\tstruct regmap_field *pull_up = pc->pu;\n\tstruct regmap_field *open_drain = pc->od;\n\tunsigned int oe_value, pu_value, od_value;\n\tunsigned long mask = BIT(pin);\n\n\tif (output_enable) {\n\t\tregmap_field_read(output_enable, &oe_value);\n\t\toe_value &= ~mask;\n\t\tif (config & ST_PINCONF_OE)\n\t\t\toe_value |= mask;\n\t\tregmap_field_write(output_enable, oe_value);\n\t}\n\n\tif (pull_up) {\n\t\tregmap_field_read(pull_up, &pu_value);\n\t\tpu_value &= ~mask;\n\t\tif (config & ST_PINCONF_PU)\n\t\t\tpu_value |= mask;\n\t\tregmap_field_write(pull_up, pu_value);\n\t}\n\n\tif (open_drain) {\n\t\tregmap_field_read(open_drain, &od_value);\n\t\tod_value &= ~mask;\n\t\tif (config & ST_PINCONF_OD)\n\t\t\tod_value |= mask;\n\t\tregmap_field_write(open_drain, od_value);\n\t}\n}\n\nstatic void st_pctl_set_function(struct st_pio_control *pc,\n\t\t\t\tint pin_id, int function)\n{\n\tstruct regmap_field *alt = pc->alt;\n\tunsigned int val;\n\tint pin = st_gpio_pin(pin_id);\n\tint offset = pin * 4;\n\n\tif (!alt)\n\t\treturn;\n\n\tregmap_field_read(alt, &val);\n\tval &= ~(0xf << offset);\n\tval |= function << offset;\n\tregmap_field_write(alt, val);\n}\n\nstatic unsigned int st_pctl_get_pin_function(struct st_pio_control *pc, int pin)\n{\n\tstruct regmap_field *alt = pc->alt;\n\tunsigned int val;\n\tint offset = pin * 4;\n\n\tif (!alt)\n\t\treturn 0;\n\n\tregmap_field_read(alt, &val);\n\n\treturn (val >> offset) & 0xf;\n}\n\nstatic unsigned long st_pinconf_delay_to_bit(unsigned int delay,\n\tconst struct st_pctl_data *data, unsigned long config)\n{\n\tconst unsigned int *delay_times;\n\tint num_delay_times, i, closest_index = -1;\n\tunsigned int closest_divergence = UINT_MAX;\n\n\tif (ST_PINCONF_UNPACK_OE(config)) {\n\t\tdelay_times = data->output_delays;\n\t\tnum_delay_times = data->noutput_delays;\n\t} else {\n\t\tdelay_times = data->input_delays;\n\t\tnum_delay_times = data->ninput_delays;\n\t}\n\n\tfor (i = 0; i < num_delay_times; i++) {\n\t\tunsigned int divergence = abs(delay - delay_times[i]);\n\n\t\tif (divergence == 0)\n\t\t\treturn i;\n\n\t\tif (divergence < closest_divergence) {\n\t\t\tclosest_divergence = divergence;\n\t\t\tclosest_index = i;\n\t\t}\n\t}\n\n\tpr_warn(\"Attempt to set delay %d, closest available %d\\n\",\n\t     delay, delay_times[closest_index]);\n\n\treturn closest_index;\n}\n\nstatic unsigned long st_pinconf_bit_to_delay(unsigned int index,\n\tconst struct st_pctl_data *data, unsigned long output)\n{\n\tconst unsigned int *delay_times;\n\tint num_delay_times;\n\n\tif (output) {\n\t\tdelay_times = data->output_delays;\n\t\tnum_delay_times = data->noutput_delays;\n\t} else {\n\t\tdelay_times = data->input_delays;\n\t\tnum_delay_times = data->ninput_delays;\n\t}\n\n\tif (index < num_delay_times) {\n\t\treturn delay_times[index];\n\t} else {\n\t\tpr_warn(\"Delay not found in/out delay list\\n\");\n\t\treturn 0;\n\t}\n}\n\nstatic void st_regmap_field_bit_set_clear_pin(struct regmap_field *field,\n\tint enable, int pin)\n{\n\tunsigned int val = 0;\n\n\tregmap_field_read(field, &val);\n\tif (enable)\n\t\tval |= BIT(pin);\n\telse\n\t\tval &= ~BIT(pin);\n\tregmap_field_write(field, val);\n}\n\nstatic void st_pinconf_set_retime_packed(struct st_pinctrl *info,\n\tstruct st_pio_control *pc,\tunsigned long config, int pin)\n{\n\tconst struct st_pctl_data *data = info->data;\n\tstruct st_retime_packed *rt_p = &pc->rt.rt_p;\n\tunsigned int delay;\n\n\tst_regmap_field_bit_set_clear_pin(rt_p->clk1notclk0,\n\t\t\t\tST_PINCONF_UNPACK_RT_CLK(config), pin);\n\n\tst_regmap_field_bit_set_clear_pin(rt_p->clknotdata,\n\t\t\t\tST_PINCONF_UNPACK_RT_CLKNOTDATA(config), pin);\n\n\tst_regmap_field_bit_set_clear_pin(rt_p->double_edge,\n\t\t\t\tST_PINCONF_UNPACK_RT_DOUBLE_EDGE(config), pin);\n\n\tst_regmap_field_bit_set_clear_pin(rt_p->invertclk,\n\t\t\t\tST_PINCONF_UNPACK_RT_INVERTCLK(config), pin);\n\n\tst_regmap_field_bit_set_clear_pin(rt_p->retime,\n\t\t\t\tST_PINCONF_UNPACK_RT(config), pin);\n\n\tdelay = st_pinconf_delay_to_bit(ST_PINCONF_UNPACK_RT_DELAY(config),\n\t\t\t\t\tdata, config);\n\t \n\tst_regmap_field_bit_set_clear_pin(rt_p->delay_0, delay & 0x1, pin);\n\t \n\tst_regmap_field_bit_set_clear_pin(rt_p->delay_1, delay & 0x2, pin);\n}\n\nstatic void st_pinconf_set_retime_dedicated(struct st_pinctrl *info,\n\tstruct st_pio_control *pc, unsigned long config, int pin)\n{\n\tint input\t= ST_PINCONF_UNPACK_OE(config) ? 0 : 1;\n\tint clk\t\t= ST_PINCONF_UNPACK_RT_CLK(config);\n\tint clknotdata\t= ST_PINCONF_UNPACK_RT_CLKNOTDATA(config);\n\tint double_edge\t= ST_PINCONF_UNPACK_RT_DOUBLE_EDGE(config);\n\tint invertclk\t= ST_PINCONF_UNPACK_RT_INVERTCLK(config);\n\tint retime\t= ST_PINCONF_UNPACK_RT(config);\n\n\tunsigned long delay = st_pinconf_delay_to_bit(\n\t\t\tST_PINCONF_UNPACK_RT_DELAY(config),\n\t\t\tinfo->data, config);\n\tstruct st_retime_dedicated *rt_d = &pc->rt.rt_d;\n\n\tunsigned long retime_config =\n\t\t((clk) << RT_D_CFG_CLK_SHIFT) |\n\t\t((delay) << RT_D_CFG_DELAY_SHIFT) |\n\t\t((input) << RT_D_CFG_DELAY_INNOTOUT_SHIFT) |\n\t\t((retime) << RT_D_CFG_RETIME_SHIFT) |\n\t\t((clknotdata) << RT_D_CFG_CLKNOTDATA_SHIFT) |\n\t\t((invertclk) << RT_D_CFG_INVERTCLK_SHIFT) |\n\t\t((double_edge) << RT_D_CFG_DOUBLE_EDGE_SHIFT);\n\n\tregmap_field_write(rt_d->rt[pin], retime_config);\n}\n\nstatic void st_pinconf_get_direction(struct st_pio_control *pc,\n\tint pin, unsigned long *config)\n{\n\tunsigned int oe_value, pu_value, od_value;\n\n\tif (pc->oe) {\n\t\tregmap_field_read(pc->oe, &oe_value);\n\t\tif (oe_value & BIT(pin))\n\t\t\tST_PINCONF_PACK_OE(*config);\n\t}\n\n\tif (pc->pu) {\n\t\tregmap_field_read(pc->pu, &pu_value);\n\t\tif (pu_value & BIT(pin))\n\t\t\tST_PINCONF_PACK_PU(*config);\n\t}\n\n\tif (pc->od) {\n\t\tregmap_field_read(pc->od, &od_value);\n\t\tif (od_value & BIT(pin))\n\t\t\tST_PINCONF_PACK_OD(*config);\n\t}\n}\n\nstatic int st_pinconf_get_retime_packed(struct st_pinctrl *info,\n\tstruct st_pio_control *pc,\tint pin, unsigned long *config)\n{\n\tconst struct st_pctl_data *data = info->data;\n\tstruct st_retime_packed *rt_p = &pc->rt.rt_p;\n\tunsigned int delay_bits, delay, delay0, delay1, val;\n\tint output = ST_PINCONF_UNPACK_OE(*config);\n\n\tif (!regmap_field_read(rt_p->retime, &val) && (val & BIT(pin)))\n\t\tST_PINCONF_PACK_RT(*config);\n\n\tif (!regmap_field_read(rt_p->clk1notclk0, &val) && (val & BIT(pin)))\n\t\tST_PINCONF_PACK_RT_CLK(*config, 1);\n\n\tif (!regmap_field_read(rt_p->clknotdata, &val) && (val & BIT(pin)))\n\t\tST_PINCONF_PACK_RT_CLKNOTDATA(*config);\n\n\tif (!regmap_field_read(rt_p->double_edge, &val) && (val & BIT(pin)))\n\t\tST_PINCONF_PACK_RT_DOUBLE_EDGE(*config);\n\n\tif (!regmap_field_read(rt_p->invertclk, &val) && (val & BIT(pin)))\n\t\tST_PINCONF_PACK_RT_INVERTCLK(*config);\n\n\tregmap_field_read(rt_p->delay_0, &delay0);\n\tregmap_field_read(rt_p->delay_1, &delay1);\n\tdelay_bits = (((delay1 & BIT(pin)) ? 1 : 0) << 1) |\n\t\t\t(((delay0 & BIT(pin)) ? 1 : 0));\n\tdelay =  st_pinconf_bit_to_delay(delay_bits, data, output);\n\tST_PINCONF_PACK_RT_DELAY(*config, delay);\n\n\treturn 0;\n}\n\nstatic int st_pinconf_get_retime_dedicated(struct st_pinctrl *info,\n\tstruct st_pio_control *pc,\tint pin, unsigned long *config)\n{\n\tunsigned int value;\n\tunsigned long delay_bits, delay, rt_clk;\n\tint output = ST_PINCONF_UNPACK_OE(*config);\n\tstruct st_retime_dedicated *rt_d = &pc->rt.rt_d;\n\n\tregmap_field_read(rt_d->rt[pin], &value);\n\n\trt_clk = (value & RT_D_CFG_CLK_MASK) >> RT_D_CFG_CLK_SHIFT;\n\tST_PINCONF_PACK_RT_CLK(*config, rt_clk);\n\n\tdelay_bits = (value & RT_D_CFG_DELAY_MASK) >> RT_D_CFG_DELAY_SHIFT;\n\tdelay =  st_pinconf_bit_to_delay(delay_bits, info->data, output);\n\tST_PINCONF_PACK_RT_DELAY(*config, delay);\n\n\tif (value & RT_D_CFG_CLKNOTDATA_MASK)\n\t\tST_PINCONF_PACK_RT_CLKNOTDATA(*config);\n\n\tif (value & RT_D_CFG_DOUBLE_EDGE_MASK)\n\t\tST_PINCONF_PACK_RT_DOUBLE_EDGE(*config);\n\n\tif (value & RT_D_CFG_INVERTCLK_MASK)\n\t\tST_PINCONF_PACK_RT_INVERTCLK(*config);\n\n\tif (value & RT_D_CFG_RETIME_MASK)\n\t\tST_PINCONF_PACK_RT(*config);\n\n\treturn 0;\n}\n\n \n\nstatic inline void __st_gpio_set(struct st_gpio_bank *bank,\n\tunsigned offset, int value)\n{\n\tif (value)\n\t\twritel(BIT(offset), bank->base + REG_PIO_SET_POUT);\n\telse\n\t\twritel(BIT(offset), bank->base + REG_PIO_CLR_POUT);\n}\n\nstatic void st_gpio_direction(struct st_gpio_bank *bank,\n\t\tunsigned int gpio, unsigned int direction)\n{\n\tint offset = st_gpio_pin(gpio);\n\tint i = 0;\n\t \n\tfor (i = 0; i <= 2; i++) {\n\t\tif (direction & BIT(i))\n\t\t\twritel(BIT(offset), bank->base + REG_PIO_SET_PC(i));\n\t\telse\n\t\t\twritel(BIT(offset), bank->base + REG_PIO_CLR_PC(i));\n\t}\n}\n\nstatic int st_gpio_get(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct st_gpio_bank *bank = gpiochip_get_data(chip);\n\n\treturn !!(readl(bank->base + REG_PIO_PIN) & BIT(offset));\n}\n\nstatic void st_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\n{\n\tstruct st_gpio_bank *bank = gpiochip_get_data(chip);\n\t__st_gpio_set(bank, offset, value);\n}\n\nstatic int st_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\n{\n\tpinctrl_gpio_direction_input(chip->base + offset);\n\n\treturn 0;\n}\n\nstatic int st_gpio_direction_output(struct gpio_chip *chip,\n\tunsigned offset, int value)\n{\n\tstruct st_gpio_bank *bank = gpiochip_get_data(chip);\n\n\t__st_gpio_set(bank, offset, value);\n\tpinctrl_gpio_direction_output(chip->base + offset);\n\n\treturn 0;\n}\n\nstatic int st_gpio_get_direction(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct st_gpio_bank *bank = gpiochip_get_data(chip);\n\tstruct st_pio_control pc = bank->pc;\n\tunsigned long config;\n\tunsigned int direction = 0;\n\tunsigned int function;\n\tunsigned int value;\n\tint i = 0;\n\n\t \n\tfunction = st_pctl_get_pin_function(&pc, offset);\n\tif (function) {\n\t\tst_pinconf_get_direction(&pc, offset, &config);\n\t\tif (ST_PINCONF_UNPACK_OE(config))\n\t\t\treturn GPIO_LINE_DIRECTION_OUT;\n\n\t\treturn GPIO_LINE_DIRECTION_IN;\n\t}\n\n\t \n\tfor (i = 0; i <= 2; i++) {\n\t\tvalue = readl(bank->base + REG_PIO_PC(i));\n\t\tdirection |= ((value >> offset) & 0x1) << i;\n\t}\n\n\tif (direction == ST_GPIO_DIRECTION_IN)\n\t\treturn GPIO_LINE_DIRECTION_IN;\n\n\treturn GPIO_LINE_DIRECTION_OUT;\n}\n\n \nstatic int st_pctl_get_groups_count(struct pinctrl_dev *pctldev)\n{\n\tstruct st_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn info->ngroups;\n}\n\nstatic const char *st_pctl_get_group_name(struct pinctrl_dev *pctldev,\n\t\t\t\t       unsigned selector)\n{\n\tstruct st_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn info->groups[selector].name;\n}\n\nstatic int st_pctl_get_group_pins(struct pinctrl_dev *pctldev,\n\tunsigned selector, const unsigned **pins, unsigned *npins)\n{\n\tstruct st_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\n\n\tif (selector >= info->ngroups)\n\t\treturn -EINVAL;\n\n\t*pins = info->groups[selector].pins;\n\t*npins = info->groups[selector].npins;\n\n\treturn 0;\n}\n\nstatic inline const struct st_pctl_group *st_pctl_find_group_by_name(\n\tconst struct st_pinctrl *info, const char *name)\n{\n\tint i;\n\n\tfor (i = 0; i < info->ngroups; i++) {\n\t\tif (!strcmp(info->groups[i].name, name))\n\t\t\treturn &info->groups[i];\n\t}\n\n\treturn NULL;\n}\n\nstatic int st_pctl_dt_node_to_map(struct pinctrl_dev *pctldev,\n\tstruct device_node *np, struct pinctrl_map **map, unsigned *num_maps)\n{\n\tstruct st_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct st_pctl_group *grp;\n\tstruct device *dev = info->dev;\n\tstruct pinctrl_map *new_map;\n\tstruct device_node *parent;\n\tint map_num, i;\n\n\tgrp = st_pctl_find_group_by_name(info, np->name);\n\tif (!grp) {\n\t\tdev_err(dev, \"unable to find group for node %pOFn\\n\", np);\n\t\treturn -EINVAL;\n\t}\n\n\tmap_num = grp->npins + 1;\n\tnew_map = devm_kcalloc(dev, map_num, sizeof(*new_map), GFP_KERNEL);\n\tif (!new_map)\n\t\treturn -ENOMEM;\n\n\tparent = of_get_parent(np);\n\tif (!parent) {\n\t\tdevm_kfree(dev, new_map);\n\t\treturn -EINVAL;\n\t}\n\n\t*map = new_map;\n\t*num_maps = map_num;\n\tnew_map[0].type = PIN_MAP_TYPE_MUX_GROUP;\n\tnew_map[0].data.mux.function = parent->name;\n\tnew_map[0].data.mux.group = np->name;\n\tof_node_put(parent);\n\n\t \n\tnew_map++;\n\tfor (i = 0; i < grp->npins; i++) {\n\t\tnew_map[i].type = PIN_MAP_TYPE_CONFIGS_PIN;\n\t\tnew_map[i].data.configs.group_or_pin =\n\t\t\t\tpin_get_name(pctldev, grp->pins[i]);\n\t\tnew_map[i].data.configs.configs = &grp->pin_conf[i].config;\n\t\tnew_map[i].data.configs.num_configs = 1;\n\t}\n\tdev_info(dev, \"maps: function %s group %s num %d\\n\",\n\t\t(*map)->data.mux.function, grp->name, map_num);\n\n\treturn 0;\n}\n\nstatic void st_pctl_dt_free_map(struct pinctrl_dev *pctldev,\n\t\t\tstruct pinctrl_map *map, unsigned num_maps)\n{\n}\n\nstatic const struct pinctrl_ops st_pctlops = {\n\t.get_groups_count\t= st_pctl_get_groups_count,\n\t.get_group_pins\t\t= st_pctl_get_group_pins,\n\t.get_group_name\t\t= st_pctl_get_group_name,\n\t.dt_node_to_map\t\t= st_pctl_dt_node_to_map,\n\t.dt_free_map\t\t= st_pctl_dt_free_map,\n};\n\n \nstatic int st_pmx_get_funcs_count(struct pinctrl_dev *pctldev)\n{\n\tstruct st_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn info->nfunctions;\n}\n\nstatic const char *st_pmx_get_fname(struct pinctrl_dev *pctldev,\n\tunsigned selector)\n{\n\tstruct st_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn info->functions[selector].name;\n}\n\nstatic int st_pmx_get_groups(struct pinctrl_dev *pctldev,\n\tunsigned selector, const char * const **grps, unsigned * const ngrps)\n{\n\tstruct st_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\n\t*grps = info->functions[selector].groups;\n\t*ngrps = info->functions[selector].ngroups;\n\n\treturn 0;\n}\n\nstatic int st_pmx_set_mux(struct pinctrl_dev *pctldev, unsigned fselector,\n\t\t\tunsigned group)\n{\n\tstruct st_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\n\tstruct st_pinconf *conf = info->groups[group].pin_conf;\n\tstruct st_pio_control *pc;\n\tint i;\n\n\tfor (i = 0; i < info->groups[group].npins; i++) {\n\t\tpc = st_get_pio_control(pctldev, conf[i].pin);\n\t\tst_pctl_set_function(pc, conf[i].pin, conf[i].altfunc);\n\t}\n\n\treturn 0;\n}\n\nstatic int st_pmx_set_gpio_direction(struct pinctrl_dev *pctldev,\n\t\t\tstruct pinctrl_gpio_range *range, unsigned gpio,\n\t\t\tbool input)\n{\n\tstruct st_gpio_bank *bank = gpio_range_to_bank(range);\n\t \n\tst_pctl_set_function(&bank->pc, gpio, 0);\n\tst_gpio_direction(bank, gpio, input ?\n\t\tST_GPIO_DIRECTION_IN : ST_GPIO_DIRECTION_OUT);\n\n\treturn 0;\n}\n\nstatic const struct pinmux_ops st_pmxops = {\n\t.get_functions_count\t= st_pmx_get_funcs_count,\n\t.get_function_name\t= st_pmx_get_fname,\n\t.get_function_groups\t= st_pmx_get_groups,\n\t.set_mux\t\t= st_pmx_set_mux,\n\t.gpio_set_direction\t= st_pmx_set_gpio_direction,\n\t.strict\t\t\t= true,\n};\n\n \nstatic void st_pinconf_get_retime(struct st_pinctrl *info,\n\tstruct st_pio_control *pc, int pin, unsigned long *config)\n{\n\tif (info->data->rt_style == st_retime_style_packed)\n\t\tst_pinconf_get_retime_packed(info, pc, pin, config);\n\telse if (info->data->rt_style == st_retime_style_dedicated)\n\t\tif ((BIT(pin) & pc->rt_pin_mask))\n\t\t\tst_pinconf_get_retime_dedicated(info, pc,\n\t\t\t\t\tpin, config);\n}\n\nstatic void st_pinconf_set_retime(struct st_pinctrl *info,\n\tstruct st_pio_control *pc, int pin, unsigned long config)\n{\n\tif (info->data->rt_style == st_retime_style_packed)\n\t\tst_pinconf_set_retime_packed(info, pc, config, pin);\n\telse if (info->data->rt_style == st_retime_style_dedicated)\n\t\tif ((BIT(pin) & pc->rt_pin_mask))\n\t\t\tst_pinconf_set_retime_dedicated(info, pc,\n\t\t\t\t\t\t\tconfig, pin);\n}\n\nstatic int st_pinconf_set(struct pinctrl_dev *pctldev, unsigned pin_id,\n\t\t\tunsigned long *configs, unsigned num_configs)\n{\n\tint pin = st_gpio_pin(pin_id);\n\tstruct st_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\n\tstruct st_pio_control *pc = st_get_pio_control(pctldev, pin_id);\n\tint i;\n\n\tfor (i = 0; i < num_configs; i++) {\n\t\tst_pinconf_set_config(pc, pin, configs[i]);\n\t\tst_pinconf_set_retime(info, pc, pin, configs[i]);\n\t}  \n\n\treturn 0;\n}\n\nstatic int st_pinconf_get(struct pinctrl_dev *pctldev,\n\t\t\t     unsigned pin_id, unsigned long *config)\n{\n\tint pin = st_gpio_pin(pin_id);\n\tstruct st_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\n\tstruct st_pio_control *pc = st_get_pio_control(pctldev, pin_id);\n\n\t*config = 0;\n\tst_pinconf_get_direction(pc, pin, config);\n\tst_pinconf_get_retime(info, pc, pin, config);\n\n\treturn 0;\n}\n\nstatic void st_pinconf_dbg_show(struct pinctrl_dev *pctldev,\n\t\t\t\t   struct seq_file *s, unsigned pin_id)\n{\n\tstruct st_pio_control *pc;\n\tunsigned long config;\n\tunsigned int function;\n\tint offset = st_gpio_pin(pin_id);\n\tchar f[16];\n\tint oe;\n\n\tmutex_unlock(&pctldev->mutex);\n\tpc = st_get_pio_control(pctldev, pin_id);\n\tst_pinconf_get(pctldev, pin_id, &config);\n\tmutex_lock(&pctldev->mutex);\n\n\tfunction = st_pctl_get_pin_function(pc, offset);\n\tif (function)\n\t\tsnprintf(f, 10, \"Alt Fn %u\", function);\n\telse\n\t\tsnprintf(f, 5, \"GPIO\");\n\n\toe = st_gpio_get_direction(&pc_to_bank(pc)->gpio_chip, offset);\n\tseq_printf(s, \"[OE:%d,PU:%ld,OD:%ld]\\t%s\\n\"\n\t\t\"\\t\\t[retime:%ld,invclk:%ld,clknotdat:%ld,\"\n\t\t\"de:%ld,rt-clk:%ld,rt-delay:%ld]\",\n\t\t(oe == GPIO_LINE_DIRECTION_OUT),\n\t\tST_PINCONF_UNPACK_PU(config),\n\t\tST_PINCONF_UNPACK_OD(config),\n\t\tf,\n\t\tST_PINCONF_UNPACK_RT(config),\n\t\tST_PINCONF_UNPACK_RT_INVERTCLK(config),\n\t\tST_PINCONF_UNPACK_RT_CLKNOTDATA(config),\n\t\tST_PINCONF_UNPACK_RT_DOUBLE_EDGE(config),\n\t\tST_PINCONF_UNPACK_RT_CLK(config),\n\t\tST_PINCONF_UNPACK_RT_DELAY(config));\n}\n\nstatic const struct pinconf_ops st_confops = {\n\t.pin_config_get\t\t= st_pinconf_get,\n\t.pin_config_set\t\t= st_pinconf_set,\n\t.pin_config_dbg_show\t= st_pinconf_dbg_show,\n};\n\nstatic void st_pctl_dt_child_count(struct st_pinctrl *info,\n\t\t\t\t     struct device_node *np)\n{\n\tstruct device_node *child;\n\tfor_each_child_of_node(np, child) {\n\t\tif (of_property_read_bool(child, \"gpio-controller\")) {\n\t\t\tinfo->nbanks++;\n\t\t} else {\n\t\t\tinfo->nfunctions++;\n\t\t\tinfo->ngroups += of_get_child_count(child);\n\t\t}\n\t}\n}\n\nstatic int st_pctl_dt_setup_retime_packed(struct st_pinctrl *info,\n\tint bank, struct st_pio_control *pc)\n{\n\tstruct device *dev = info->dev;\n\tstruct regmap *rm = info->regmap;\n\tconst struct st_pctl_data *data = info->data;\n\t \n\tint reg = (data->rt + bank * RT_P_CFGS_PER_BANK) * 4;\n\tstruct st_retime_packed *rt_p = &pc->rt.rt_p;\n\t \n\tstruct reg_field clk1notclk0 = RT_P_CFG0_CLK1NOTCLK0_FIELD(reg);\n\tstruct reg_field delay_0 = RT_P_CFG0_DELAY_0_FIELD(reg);\n\tstruct reg_field delay_1 = RT_P_CFG0_DELAY_1_FIELD(reg);\n\t \n\tstruct reg_field invertclk = RT_P_CFG1_INVERTCLK_FIELD(reg + 4);\n\tstruct reg_field retime = RT_P_CFG1_RETIME_FIELD(reg + 4);\n\tstruct reg_field clknotdata = RT_P_CFG1_CLKNOTDATA_FIELD(reg + 4);\n\tstruct reg_field double_edge = RT_P_CFG1_DOUBLE_EDGE_FIELD(reg + 4);\n\n\trt_p->clk1notclk0 = devm_regmap_field_alloc(dev, rm, clk1notclk0);\n\trt_p->delay_0\t= devm_regmap_field_alloc(dev, rm, delay_0);\n\trt_p->delay_1 = devm_regmap_field_alloc(dev, rm, delay_1);\n\trt_p->invertclk = devm_regmap_field_alloc(dev, rm, invertclk);\n\trt_p->retime = devm_regmap_field_alloc(dev, rm, retime);\n\trt_p->clknotdata = devm_regmap_field_alloc(dev, rm, clknotdata);\n\trt_p->double_edge = devm_regmap_field_alloc(dev, rm, double_edge);\n\n\tif (IS_ERR(rt_p->clk1notclk0) || IS_ERR(rt_p->delay_0) ||\n\t\t IS_ERR(rt_p->delay_1) || IS_ERR(rt_p->invertclk) ||\n\t\t IS_ERR(rt_p->retime) || IS_ERR(rt_p->clknotdata) ||\n\t\t IS_ERR(rt_p->double_edge))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int st_pctl_dt_setup_retime_dedicated(struct st_pinctrl *info,\n\tint bank, struct st_pio_control *pc)\n{\n\tstruct device *dev = info->dev;\n\tstruct regmap *rm = info->regmap;\n\tconst struct st_pctl_data *data = info->data;\n\t \n\tint reg_offset = (data->rt + bank * RT_D_CFGS_PER_BANK) * 4;\n\tstruct st_retime_dedicated *rt_d = &pc->rt.rt_d;\n\tunsigned int j;\n\tu32 pin_mask = pc->rt_pin_mask;\n\n\tfor (j = 0; j < RT_D_CFGS_PER_BANK; j++) {\n\t\tif (BIT(j) & pin_mask) {\n\t\t\tstruct reg_field reg = REG_FIELD(reg_offset, 0, 31);\n\t\t\trt_d->rt[j] = devm_regmap_field_alloc(dev, rm, reg);\n\t\t\tif (IS_ERR(rt_d->rt[j]))\n\t\t\t\treturn -EINVAL;\n\t\t\treg_offset += 4;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int st_pctl_dt_setup_retime(struct st_pinctrl *info,\n\tint bank, struct st_pio_control *pc)\n{\n\tconst struct st_pctl_data *data = info->data;\n\tif (data->rt_style  == st_retime_style_packed)\n\t\treturn st_pctl_dt_setup_retime_packed(info, bank, pc);\n\telse if (data->rt_style == st_retime_style_dedicated)\n\t\treturn st_pctl_dt_setup_retime_dedicated(info, bank, pc);\n\n\treturn -EINVAL;\n}\n\n\nstatic struct regmap_field *st_pc_get_value(struct device *dev,\n\t\t\t\t\t    struct regmap *regmap, int bank,\n\t\t\t\t\t    int data, int lsb, int msb)\n{\n\tstruct reg_field reg = REG_FIELD((data + bank) * 4, lsb, msb);\n\n\tif (data < 0)\n\t\treturn NULL;\n\n\treturn devm_regmap_field_alloc(dev, regmap, reg);\n}\n\nstatic void st_parse_syscfgs(struct st_pinctrl *info, int bank,\n\t\t\t     struct device_node *np)\n{\n\tconst struct st_pctl_data *data = info->data;\n\t \n\tint lsb = (bank%4) * ST_GPIO_PINS_PER_BANK;\n\tint msb = lsb + ST_GPIO_PINS_PER_BANK - 1;\n\tstruct st_pio_control *pc = &info->banks[bank].pc;\n\tstruct device *dev = info->dev;\n\tstruct regmap *regmap  = info->regmap;\n\n\tpc->alt = st_pc_get_value(dev, regmap, bank, data->alt, 0, 31);\n\tpc->oe = st_pc_get_value(dev, regmap, bank/4, data->oe, lsb, msb);\n\tpc->pu = st_pc_get_value(dev, regmap, bank/4, data->pu, lsb, msb);\n\tpc->od = st_pc_get_value(dev, regmap, bank/4, data->od, lsb, msb);\n\n\t \n\tpc->rt_pin_mask = 0xff;\n\tof_property_read_u32(np, \"st,retime-pin-mask\", &pc->rt_pin_mask);\n\tst_pctl_dt_setup_retime(info, bank, pc);\n\n\treturn;\n}\n\nstatic int st_pctl_dt_calculate_pin(struct st_pinctrl *info,\n\t\t\t\t    phandle bank, unsigned int offset)\n{\n\tstruct device_node *np;\n\tstruct gpio_chip *chip;\n\tint retval = -EINVAL;\n\tint i;\n\n\tnp = of_find_node_by_phandle(bank);\n\tif (!np)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < info->nbanks; i++) {\n\t\tchip = &info->banks[i].gpio_chip;\n\t\tif (chip->fwnode == of_fwnode_handle(np)) {\n\t\t\tif (offset < chip->ngpio)\n\t\t\t\tretval = chip->base + offset;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tof_node_put(np);\n\treturn retval;\n}\n\n \nstatic int st_pctl_dt_parse_groups(struct device_node *np,\n\tstruct st_pctl_group *grp, struct st_pinctrl *info, int idx)\n{\n\t \n\tconst __be32 *list;\n\tstruct property *pp;\n\tstruct device *dev = info->dev;\n\tstruct st_pinconf *conf;\n\tstruct device_node *pins;\n\tphandle bank;\n\tunsigned int offset;\n\tint i = 0, npins = 0, nr_props, ret = 0;\n\n\tpins = of_get_child_by_name(np, \"st,pins\");\n\tif (!pins)\n\t\treturn -ENODATA;\n\n\tfor_each_property_of_node(pins, pp) {\n\t\t \n\t\tif (!strcmp(pp->name, \"name\"))\n\t\t\tcontinue;\n\n\t\tif (pp->length / sizeof(__be32) >= OF_GPIO_ARGS_MIN) {\n\t\t\tnpins++;\n\t\t} else {\n\t\t\tpr_warn(\"Invalid st,pins in %pOFn node\\n\", np);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_put_node;\n\t\t}\n\t}\n\n\tgrp->npins = npins;\n\tgrp->name = np->name;\n\tgrp->pins = devm_kcalloc(dev, npins, sizeof(*grp->pins), GFP_KERNEL);\n\tgrp->pin_conf = devm_kcalloc(dev, npins, sizeof(*grp->pin_conf), GFP_KERNEL);\n\n\tif (!grp->pins || !grp->pin_conf) {\n\t\tret = -ENOMEM;\n\t\tgoto out_put_node;\n\t}\n\n\t \n\tfor_each_property_of_node(pins, pp) {\n\t\tif (!strcmp(pp->name, \"name\"))\n\t\t\tcontinue;\n\t\tnr_props = pp->length/sizeof(u32);\n\t\tlist = pp->value;\n\t\tconf = &grp->pin_conf[i];\n\n\t\t \n\t\tbank = be32_to_cpup(list++);\n\t\toffset = be32_to_cpup(list++);\n\t\tconf->pin = st_pctl_dt_calculate_pin(info, bank, offset);\n\t\tconf->name = pp->name;\n\t\tgrp->pins[i] = conf->pin;\n\t\t \n\t\tconf->altfunc = be32_to_cpup(list++);\n\t\tconf->config = 0;\n\t\t \n\t\tconf->config |= be32_to_cpup(list++);\n\t\t \n\t\tif (nr_props >= OF_GPIO_ARGS_MIN + OF_RT_ARGS_MIN) {\n\t\t\t \n\t\t\tconf->config |= be32_to_cpup(list++);\n\t\t\t \n\t\t\tconf->config |= be32_to_cpup(list++);\n\t\t\t \n\t\t\tif (nr_props > OF_GPIO_ARGS_MIN + OF_RT_ARGS_MIN)\n\t\t\t\tconf->config |= be32_to_cpup(list++);\n\t\t}\n\t\ti++;\n\t}\n\nout_put_node:\n\tof_node_put(pins);\n\n\treturn ret;\n}\n\nstatic int st_pctl_parse_functions(struct device_node *np,\n\t\t\tstruct st_pinctrl *info, u32 index, int *grp_index)\n{\n\tstruct device *dev = info->dev;\n\tstruct device_node *child;\n\tstruct st_pmx_func *func;\n\tstruct st_pctl_group *grp;\n\tint ret, i;\n\n\tfunc = &info->functions[index];\n\tfunc->name = np->name;\n\tfunc->ngroups = of_get_child_count(np);\n\tif (func->ngroups == 0)\n\t\treturn dev_err_probe(dev, -EINVAL, \"No groups defined\\n\");\n\tfunc->groups = devm_kcalloc(dev, func->ngroups, sizeof(*func->groups), GFP_KERNEL);\n\tif (!func->groups)\n\t\treturn -ENOMEM;\n\n\ti = 0;\n\tfor_each_child_of_node(np, child) {\n\t\tfunc->groups[i] = child->name;\n\t\tgrp = &info->groups[*grp_index];\n\t\t*grp_index += 1;\n\t\tret = st_pctl_dt_parse_groups(child, grp, info, i++);\n\t\tif (ret) {\n\t\t\tof_node_put(child);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tdev_info(dev, \"Function[%d\\t name:%s,\\tgroups:%d]\\n\", index, func->name, func->ngroups);\n\n\treturn 0;\n}\n\nstatic void st_gpio_irq_mask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct st_gpio_bank *bank = gpiochip_get_data(gc);\n\n\twritel(BIT(irqd_to_hwirq(d)), bank->base + REG_PIO_CLR_PMASK);\n\tgpiochip_disable_irq(gc, irqd_to_hwirq(d));\n}\n\nstatic void st_gpio_irq_unmask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct st_gpio_bank *bank = gpiochip_get_data(gc);\n\n\tgpiochip_enable_irq(gc, irqd_to_hwirq(d));\n\twritel(BIT(irqd_to_hwirq(d)), bank->base + REG_PIO_SET_PMASK);\n}\n\nstatic int st_gpio_irq_request_resources(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\n\tst_gpio_direction_input(gc, d->hwirq);\n\n\treturn gpiochip_reqres_irq(gc, d->hwirq);\n}\n\nstatic void st_gpio_irq_release_resources(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\n\tgpiochip_relres_irq(gc, d->hwirq);\n}\n\nstatic int st_gpio_irq_set_type(struct irq_data *d, unsigned type)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct st_gpio_bank *bank = gpiochip_get_data(gc);\n\tunsigned long flags;\n\tint comp, pin = d->hwirq;\n\tu32 val;\n\tu32 pin_edge_conf = 0;\n\n\tswitch (type) {\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tcomp = 0;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tcomp = 0;\n\t\tpin_edge_conf = ST_IRQ_FALLING_EDGE_CONF(pin);\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tcomp = 1;\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tcomp = 1;\n\t\tpin_edge_conf = ST_IRQ_RISING_EDGE_CONF(pin);\n\t\tbreak;\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\tcomp = st_gpio_get(&bank->gpio_chip, pin);\n\t\tpin_edge_conf = ST_IRQ_BOTH_EDGE_CONF(pin);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(&bank->lock, flags);\n\tbank->irq_edge_conf &=  ~(ST_IRQ_EDGE_MASK << (\n\t\t\t\tpin * ST_IRQ_EDGE_CONF_BITS_PER_PIN));\n\tbank->irq_edge_conf |= pin_edge_conf;\n\tspin_unlock_irqrestore(&bank->lock, flags);\n\n\tval = readl(bank->base + REG_PIO_PCOMP);\n\tval &= ~BIT(pin);\n\tval |= (comp << pin);\n\twritel(val, bank->base + REG_PIO_PCOMP);\n\n\treturn 0;\n}\n\n \nstatic void __gpio_irq_handler(struct st_gpio_bank *bank)\n{\n\tunsigned long port_in, port_mask, port_comp, active_irqs;\n\tunsigned long bank_edge_mask, flags;\n\tint n, val, ecfg;\n\n\tspin_lock_irqsave(&bank->lock, flags);\n\tbank_edge_mask = bank->irq_edge_conf;\n\tspin_unlock_irqrestore(&bank->lock, flags);\n\n\tfor (;;) {\n\t\tport_in = readl(bank->base + REG_PIO_PIN);\n\t\tport_comp = readl(bank->base + REG_PIO_PCOMP);\n\t\tport_mask = readl(bank->base + REG_PIO_PMASK);\n\n\t\tactive_irqs = (port_in ^ port_comp) & port_mask;\n\n\t\tif (active_irqs == 0)\n\t\t\tbreak;\n\n\t\tfor_each_set_bit(n, &active_irqs, BITS_PER_LONG) {\n\t\t\t \n\t\t\tecfg = ST_IRQ_EDGE_CONF(bank_edge_mask, n);\n\n\t\t\tif (ecfg) {\n\t\t\t\t \n\t\t\t\tval = st_gpio_get(&bank->gpio_chip, n);\n\n\t\t\t\twritel(BIT(n),\n\t\t\t\t\tval ? bank->base + REG_PIO_SET_PCOMP :\n\t\t\t\t\tbank->base + REG_PIO_CLR_PCOMP);\n\n\t\t\t\tif (ecfg != ST_IRQ_EDGE_BOTH &&\n\t\t\t\t\t!((ecfg & ST_IRQ_EDGE_FALLING) ^ val))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tgeneric_handle_domain_irq(bank->gpio_chip.irq.domain, n);\n\t\t}\n\t}\n}\n\nstatic void st_gpio_irq_handler(struct irq_desc *desc)\n{\n\t \n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tstruct gpio_chip *gc = irq_desc_get_handler_data(desc);\n\tstruct st_gpio_bank *bank = gpiochip_get_data(gc);\n\n\tchained_irq_enter(chip, desc);\n\t__gpio_irq_handler(bank);\n\tchained_irq_exit(chip, desc);\n}\n\nstatic void st_gpio_irqmux_handler(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tstruct st_pinctrl *info = irq_desc_get_handler_data(desc);\n\tunsigned long status;\n\tint n;\n\n\tchained_irq_enter(chip, desc);\n\n\tstatus = readl(info->irqmux_base);\n\n\tfor_each_set_bit(n, &status, info->nbanks)\n\t\t__gpio_irq_handler(&info->banks[n]);\n\n\tchained_irq_exit(chip, desc);\n}\n\nstatic const struct gpio_chip st_gpio_template = {\n\t.request\t\t= gpiochip_generic_request,\n\t.free\t\t\t= gpiochip_generic_free,\n\t.get\t\t\t= st_gpio_get,\n\t.set\t\t\t= st_gpio_set,\n\t.direction_input\t= st_gpio_direction_input,\n\t.direction_output\t= st_gpio_direction_output,\n\t.get_direction\t\t= st_gpio_get_direction,\n\t.ngpio\t\t\t= ST_GPIO_PINS_PER_BANK,\n};\n\nstatic const struct irq_chip st_gpio_irqchip = {\n\t.name\t\t\t= \"GPIO\",\n\t.irq_request_resources\t= st_gpio_irq_request_resources,\n\t.irq_release_resources\t= st_gpio_irq_release_resources,\n\t.irq_disable\t\t= st_gpio_irq_mask,\n\t.irq_mask\t\t= st_gpio_irq_mask,\n\t.irq_unmask\t\t= st_gpio_irq_unmask,\n\t.irq_set_type\t\t= st_gpio_irq_set_type,\n\t.flags\t\t\t= IRQCHIP_SKIP_SET_WAKE | IRQCHIP_IMMUTABLE,\n};\n\nstatic int st_gpiolib_register_bank(struct st_pinctrl *info,\n\tint bank_nr, struct device_node *np)\n{\n\tstruct st_gpio_bank *bank = &info->banks[bank_nr];\n\tstruct pinctrl_gpio_range *range = &bank->range;\n\tstruct device *dev = info->dev;\n\tint bank_num = of_alias_get_id(np, \"gpio\");\n\tstruct resource res, irq_res;\n\tint err;\n\n\tif (of_address_to_resource(np, 0, &res))\n\t\treturn -ENODEV;\n\n\tbank->base = devm_ioremap_resource(dev, &res);\n\tif (IS_ERR(bank->base))\n\t\treturn PTR_ERR(bank->base);\n\n\tbank->gpio_chip = st_gpio_template;\n\tbank->gpio_chip.base = bank_num * ST_GPIO_PINS_PER_BANK;\n\tbank->gpio_chip.ngpio = ST_GPIO_PINS_PER_BANK;\n\tbank->gpio_chip.fwnode = of_fwnode_handle(np);\n\tbank->gpio_chip.parent = dev;\n\tspin_lock_init(&bank->lock);\n\n\tof_property_read_string(np, \"st,bank-name\", &range->name);\n\tbank->gpio_chip.label = range->name;\n\n\trange->id = bank_num;\n\trange->pin_base = range->base = range->id * ST_GPIO_PINS_PER_BANK;\n\trange->npins = bank->gpio_chip.ngpio;\n\trange->gc = &bank->gpio_chip;\n\n\t \n\n\tif (of_irq_to_resource(np, 0, &irq_res) > 0) {\n\t\tstruct gpio_irq_chip *girq;\n\t\tint gpio_irq = irq_res.start;\n\n\t\t \n\t\tif (gpio_irq <= 0) {\n\t\t\tdev_err(dev, \"invalid IRQ for %pOF bank\\n\", np);\n\t\t\tgoto skip_irq;\n\t\t}\n\t\t \n\t\tif (!info->irqmux_base) {\n\t\t\tdev_err(dev, \"no irqmux for %pOF bank\\n\", np);\n\t\t\tgoto skip_irq;\n\t\t}\n\n\t\tgirq = &bank->gpio_chip.irq;\n\t\tgpio_irq_chip_set_chip(girq, &st_gpio_irqchip);\n\t\tgirq->parent_handler = st_gpio_irq_handler;\n\t\tgirq->num_parents = 1;\n\t\tgirq->parents = devm_kcalloc(dev, 1, sizeof(*girq->parents),\n\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!girq->parents)\n\t\t\treturn -ENOMEM;\n\t\tgirq->parents[0] = gpio_irq;\n\t\tgirq->default_type = IRQ_TYPE_NONE;\n\t\tgirq->handler = handle_simple_irq;\n\t}\n\nskip_irq:\n\terr  = gpiochip_add_data(&bank->gpio_chip, bank);\n\tif (err)\n\t\treturn dev_err_probe(dev, err, \"Failed to add gpiochip(%d)!\\n\", bank_num);\n\tdev_info(dev, \"%s bank added.\\n\", range->name);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id st_pctl_of_match[] = {\n\t{ .compatible = \"st,stih407-sbc-pinctrl\", .data = &stih407_data},\n\t{ .compatible = \"st,stih407-front-pinctrl\", .data = &stih407_data},\n\t{ .compatible = \"st,stih407-rear-pinctrl\", .data = &stih407_data},\n\t{ .compatible = \"st,stih407-flash-pinctrl\", .data = &stih407_flashdata},\n\t{   }\n};\n\nstatic int st_pctl_probe_dt(struct platform_device *pdev,\n\tstruct pinctrl_desc *pctl_desc, struct st_pinctrl *info)\n{\n\tstruct device *dev = &pdev->dev;\n\tint ret = 0;\n\tint i = 0, j = 0, k = 0, bank;\n\tstruct pinctrl_pin_desc *pdesc;\n\tstruct device_node *np = dev->of_node;\n\tstruct device_node *child;\n\tint grp_index = 0;\n\tint irq = 0;\n\n\tst_pctl_dt_child_count(info, np);\n\tif (!info->nbanks)\n\t\treturn dev_err_probe(dev, -EINVAL, \"you need at least one gpio bank\\n\");\n\n\tdev_info(dev, \"nbanks = %d\\n\", info->nbanks);\n\tdev_info(dev, \"nfunctions = %d\\n\", info->nfunctions);\n\tdev_info(dev, \"ngroups = %d\\n\", info->ngroups);\n\n\tinfo->functions = devm_kcalloc(dev, info->nfunctions, sizeof(*info->functions), GFP_KERNEL);\n\n\tinfo->groups = devm_kcalloc(dev, info->ngroups, sizeof(*info->groups), GFP_KERNEL);\n\n\tinfo->banks = devm_kcalloc(dev, info->nbanks, sizeof(*info->banks), GFP_KERNEL);\n\n\tif (!info->functions || !info->groups || !info->banks)\n\t\treturn -ENOMEM;\n\n\tinfo->regmap = syscon_regmap_lookup_by_phandle(np, \"st,syscfg\");\n\tif (IS_ERR(info->regmap))\n\t\treturn dev_err_probe(dev, PTR_ERR(info->regmap), \"No syscfg phandle specified\\n\");\n\tinfo->data = of_match_node(st_pctl_of_match, np)->data;\n\n\tirq = platform_get_irq(pdev, 0);\n\n\tif (irq > 0) {\n\t\tinfo->irqmux_base = devm_platform_ioremap_resource_byname(pdev, \"irqmux\");\n\t\tif (IS_ERR(info->irqmux_base))\n\t\t\treturn PTR_ERR(info->irqmux_base);\n\n\t\tirq_set_chained_handler_and_data(irq, st_gpio_irqmux_handler,\n\t\t\t\t\t\t info);\n\t}\n\n\tpctl_desc->npins = info->nbanks * ST_GPIO_PINS_PER_BANK;\n\tpdesc =\tdevm_kcalloc(dev, pctl_desc->npins, sizeof(*pdesc), GFP_KERNEL);\n\tif (!pdesc)\n\t\treturn -ENOMEM;\n\n\tpctl_desc->pins = pdesc;\n\n\tbank = 0;\n\tfor_each_child_of_node(np, child) {\n\t\tif (of_property_read_bool(child, \"gpio-controller\")) {\n\t\t\tconst char *bank_name = NULL;\n\t\t\tchar **pin_names;\n\n\t\t\tret = st_gpiolib_register_bank(info, bank, child);\n\t\t\tif (ret) {\n\t\t\t\tof_node_put(child);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tk = info->banks[bank].range.pin_base;\n\t\t\tbank_name = info->banks[bank].range.name;\n\n\t\t\tpin_names = devm_kasprintf_strarray(dev, bank_name, ST_GPIO_PINS_PER_BANK);\n\t\t\tif (IS_ERR(pin_names)) {\n\t\t\t\tof_node_put(child);\n\t\t\t\treturn PTR_ERR(pin_names);\n\t\t\t}\n\n\t\t\tfor (j = 0; j < ST_GPIO_PINS_PER_BANK; j++, k++) {\n\t\t\t\tpdesc->number = k;\n\t\t\t\tpdesc->name = pin_names[j];\n\t\t\t\tpdesc++;\n\t\t\t}\n\t\t\tst_parse_syscfgs(info, bank, child);\n\t\t\tbank++;\n\t\t} else {\n\t\t\tret = st_pctl_parse_functions(child, info,\n\t\t\t\t\t\t\ti++, &grp_index);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(dev, \"No functions found.\\n\");\n\t\t\t\tof_node_put(child);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int st_pctl_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct st_pinctrl *info;\n\tstruct pinctrl_desc *pctl_desc;\n\tint ret, i;\n\n\tif (!dev->of_node) {\n\t\tdev_err(dev, \"device node not found.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpctl_desc = devm_kzalloc(dev, sizeof(*pctl_desc), GFP_KERNEL);\n\tif (!pctl_desc)\n\t\treturn -ENOMEM;\n\n\tinfo = devm_kzalloc(dev, sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinfo->dev = dev;\n\tplatform_set_drvdata(pdev, info);\n\tret = st_pctl_probe_dt(pdev, pctl_desc, info);\n\tif (ret)\n\t\treturn ret;\n\n\tpctl_desc->owner\t= THIS_MODULE;\n\tpctl_desc->pctlops\t= &st_pctlops;\n\tpctl_desc->pmxops\t= &st_pmxops;\n\tpctl_desc->confops\t= &st_confops;\n\tpctl_desc->name\t\t= dev_name(dev);\n\n\tinfo->pctl = devm_pinctrl_register(dev, pctl_desc, info);\n\tif (IS_ERR(info->pctl))\n\t\treturn dev_err_probe(dev, PTR_ERR(info->pctl), \"Failed pinctrl registration\\n\");\n\n\tfor (i = 0; i < info->nbanks; i++)\n\t\tpinctrl_add_gpio_range(info->pctl, &info->banks[i].range);\n\n\treturn 0;\n}\n\nstatic struct platform_driver st_pctl_driver = {\n\t.driver = {\n\t\t.name = \"st-pinctrl\",\n\t\t.of_match_table = st_pctl_of_match,\n\t},\n\t.probe = st_pctl_probe,\n};\n\nstatic int __init st_pctl_init(void)\n{\n\treturn platform_driver_register(&st_pctl_driver);\n}\narch_initcall(st_pctl_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}