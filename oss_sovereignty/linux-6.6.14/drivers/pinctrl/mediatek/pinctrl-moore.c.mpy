{
  "module_name": "pinctrl-moore.c",
  "hash_id": "52294f71a459fd0c0b07dc2cc603ab67f46506a26c75eba73899f10b42a1bc62",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/mediatek/pinctrl-moore.c",
  "human_readable_source": "\n \n\n#include <dt-bindings/pinctrl/mt65xx.h>\n#include <linux/gpio/driver.h>\n\n#include <linux/pinctrl/consumer.h>\n\n#include \"pinctrl-moore.h\"\n\n#define PINCTRL_PINCTRL_DEV\t\tKBUILD_MODNAME\n\n \n#define MTK_PIN_CONFIG_TDSEL\t(PIN_CONFIG_END + 1)\n#define MTK_PIN_CONFIG_RDSEL\t(PIN_CONFIG_END + 2)\n#define MTK_PIN_CONFIG_PU_ADV\t(PIN_CONFIG_END + 3)\n#define MTK_PIN_CONFIG_PD_ADV\t(PIN_CONFIG_END + 4)\n\nstatic const struct pinconf_generic_params mtk_custom_bindings[] = {\n\t{\"mediatek,tdsel\",\tMTK_PIN_CONFIG_TDSEL,\t\t0},\n\t{\"mediatek,rdsel\",\tMTK_PIN_CONFIG_RDSEL,\t\t0},\n\t{\"mediatek,pull-up-adv\", MTK_PIN_CONFIG_PU_ADV,\t\t1},\n\t{\"mediatek,pull-down-adv\", MTK_PIN_CONFIG_PD_ADV,\t1},\n};\n\n#ifdef CONFIG_DEBUG_FS\nstatic const struct pin_config_item mtk_conf_items[] = {\n\tPCONFDUMP(MTK_PIN_CONFIG_TDSEL, \"tdsel\", NULL, true),\n\tPCONFDUMP(MTK_PIN_CONFIG_RDSEL, \"rdsel\", NULL, true),\n\tPCONFDUMP(MTK_PIN_CONFIG_PU_ADV, \"pu-adv\", NULL, true),\n\tPCONFDUMP(MTK_PIN_CONFIG_PD_ADV, \"pd-adv\", NULL, true),\n};\n#endif\n\nstatic int mtk_pinmux_set_mux(struct pinctrl_dev *pctldev,\n\t\t\t      unsigned int selector, unsigned int group)\n{\n\tstruct mtk_pinctrl *hw = pinctrl_dev_get_drvdata(pctldev);\n\tstruct function_desc *func;\n\tstruct group_desc *grp;\n\tint i;\n\n\tfunc = pinmux_generic_get_function(pctldev, selector);\n\tif (!func)\n\t\treturn -EINVAL;\n\n\tgrp = pinctrl_generic_get_group(pctldev, group);\n\tif (!grp)\n\t\treturn -EINVAL;\n\n\tdev_dbg(pctldev->dev, \"enable function %s group %s\\n\",\n\t\tfunc->name, grp->name);\n\n\tfor (i = 0; i < grp->num_pins; i++) {\n\t\tconst struct mtk_pin_desc *desc;\n\t\tint *pin_modes = grp->data;\n\t\tint pin = grp->pins[i];\n\n\t\tdesc = (const struct mtk_pin_desc *)&hw->soc->pins[pin];\n\t\tif (!desc->name)\n\t\t\treturn -ENOTSUPP;\n\n\t\tmtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_MODE,\n\t\t\t\t pin_modes[i]);\n\t}\n\n\treturn 0;\n}\n\nstatic int mtk_pinmux_gpio_request_enable(struct pinctrl_dev *pctldev,\n\t\t\t\t\t  struct pinctrl_gpio_range *range,\n\t\t\t\t\t  unsigned int pin)\n{\n\tstruct mtk_pinctrl *hw = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct mtk_pin_desc *desc;\n\n\tdesc = (const struct mtk_pin_desc *)&hw->soc->pins[pin];\n\tif (!desc->name)\n\t\treturn -ENOTSUPP;\n\n\treturn mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_MODE,\n\t\t\t\thw->soc->gpio_m);\n}\n\nstatic int mtk_pinmux_gpio_set_direction(struct pinctrl_dev *pctldev,\n\t\t\t\t\t struct pinctrl_gpio_range *range,\n\t\t\t\t\t unsigned int pin, bool input)\n{\n\tstruct mtk_pinctrl *hw = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct mtk_pin_desc *desc;\n\n\tdesc = (const struct mtk_pin_desc *)&hw->soc->pins[pin];\n\tif (!desc->name)\n\t\treturn -ENOTSUPP;\n\n\t \n\treturn mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_DIR, !input);\n}\n\nstatic int mtk_pinconf_get(struct pinctrl_dev *pctldev,\n\t\t\t   unsigned int pin, unsigned long *config)\n{\n\tstruct mtk_pinctrl *hw = pinctrl_dev_get_drvdata(pctldev);\n\tu32 param = pinconf_to_config_param(*config);\n\tint val, val2, err, pullup, reg, ret = 1;\n\tconst struct mtk_pin_desc *desc;\n\n\tdesc = (const struct mtk_pin_desc *)&hw->soc->pins[pin];\n\tif (!desc->name)\n\t\treturn -ENOTSUPP;\n\n\tswitch (param) {\n\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\tif (hw->soc->bias_get_combo) {\n\t\t\terr = hw->soc->bias_get_combo(hw, desc, &pullup, &ret);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tif (ret != MTK_PUPD_SET_R1R0_00 && ret != MTK_DISABLE)\n\t\t\t\treturn -EINVAL;\n\t\t} else if (hw->soc->bias_disable_get) {\n\t\t\terr = hw->soc->bias_disable_get(hw, desc, &ret);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\tif (hw->soc->bias_get_combo) {\n\t\t\terr = hw->soc->bias_get_combo(hw, desc, &pullup, &ret);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tif (ret == MTK_PUPD_SET_R1R0_00 || ret == MTK_DISABLE)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (!pullup)\n\t\t\t\treturn -EINVAL;\n\t\t} else if (hw->soc->bias_get) {\n\t\t\terr = hw->soc->bias_get(hw, desc, 1, &ret);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\tif (hw->soc->bias_get_combo) {\n\t\t\terr = hw->soc->bias_get_combo(hw, desc, &pullup, &ret);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tif (ret == MTK_PUPD_SET_R1R0_00 || ret == MTK_DISABLE)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (pullup)\n\t\t\t\treturn -EINVAL;\n\t\t} else if (hw->soc->bias_get) {\n\t\t\terr = hw->soc->bias_get(hw, desc, 0, &ret);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t\tbreak;\n\tcase PIN_CONFIG_SLEW_RATE:\n\t\terr = mtk_hw_get_value(hw, desc, PINCTRL_PIN_REG_SR, &val);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (!val)\n\t\t\treturn -EINVAL;\n\n\t\tbreak;\n\tcase PIN_CONFIG_INPUT_ENABLE:\n\tcase PIN_CONFIG_OUTPUT_ENABLE:\n\t\terr = mtk_hw_get_value(hw, desc, PINCTRL_PIN_REG_DIR, &val);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t \n\t\tif ((val && param == PIN_CONFIG_INPUT_ENABLE) ||\n\t\t    (!val && param == PIN_CONFIG_OUTPUT_ENABLE))\n\t\t\treturn -EINVAL;\n\n\t\tbreak;\n\tcase PIN_CONFIG_INPUT_SCHMITT_ENABLE:\n\t\terr = mtk_hw_get_value(hw, desc, PINCTRL_PIN_REG_DIR, &val);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = mtk_hw_get_value(hw, desc, PINCTRL_PIN_REG_SMT, &val2);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (val || !val2)\n\t\t\treturn -EINVAL;\n\n\t\tbreak;\n\tcase PIN_CONFIG_DRIVE_STRENGTH:\n\t\tif (hw->soc->drive_get) {\n\t\t\terr = hw->soc->drive_get(hw, desc, &ret);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\terr = -ENOTSUPP;\n\t\t}\n\t\tbreak;\n\tcase MTK_PIN_CONFIG_TDSEL:\n\tcase MTK_PIN_CONFIG_RDSEL:\n\t\treg = (param == MTK_PIN_CONFIG_TDSEL) ?\n\t\t       PINCTRL_PIN_REG_TDSEL : PINCTRL_PIN_REG_RDSEL;\n\n\t\terr = mtk_hw_get_value(hw, desc, reg, &val);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tret = val;\n\n\t\tbreak;\n\tcase MTK_PIN_CONFIG_PU_ADV:\n\tcase MTK_PIN_CONFIG_PD_ADV:\n\t\tif (hw->soc->adv_pull_get) {\n\t\t\tbool pullup;\n\n\t\t\tpullup = param == MTK_PIN_CONFIG_PU_ADV;\n\t\t\terr = hw->soc->adv_pull_get(hw, desc, pullup, &ret);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\t*config = pinconf_to_config_packed(param, ret);\n\n\treturn 0;\n}\n\nstatic int mtk_pinconf_set(struct pinctrl_dev *pctldev, unsigned int pin,\n\t\t\t   unsigned long *configs, unsigned int num_configs)\n{\n\tstruct mtk_pinctrl *hw = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct mtk_pin_desc *desc;\n\tu32 reg, param, arg;\n\tint cfg, err = 0;\n\n\tdesc = (const struct mtk_pin_desc *)&hw->soc->pins[pin];\n\tif (!desc->name)\n\t\treturn -ENOTSUPP;\n\n\tfor (cfg = 0; cfg < num_configs; cfg++) {\n\t\tparam = pinconf_to_config_param(configs[cfg]);\n\t\targ = pinconf_to_config_argument(configs[cfg]);\n\n\t\tswitch (param) {\n\t\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\t\tif (hw->soc->bias_set_combo) {\n\t\t\t\terr = hw->soc->bias_set_combo(hw, desc, 0, MTK_DISABLE);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t} else if (hw->soc->bias_disable_set) {\n\t\t\t\terr = hw->soc->bias_disable_set(hw, desc);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t} else {\n\t\t\t\treturn -ENOTSUPP;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\t\tif (hw->soc->bias_set_combo) {\n\t\t\t\terr = hw->soc->bias_set_combo(hw, desc, 1, arg);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t} else if (hw->soc->bias_set) {\n\t\t\t\terr = hw->soc->bias_set(hw, desc, 1);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t} else {\n\t\t\t\treturn -ENOTSUPP;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\t\tif (hw->soc->bias_set_combo) {\n\t\t\t\terr = hw->soc->bias_set_combo(hw, desc, 0, arg);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t} else if (hw->soc->bias_set) {\n\t\t\t\terr = hw->soc->bias_set(hw, desc, 0);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t} else {\n\t\t\t\treturn -ENOTSUPP;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_OUTPUT_ENABLE:\n\t\t\terr = mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_SMT,\n\t\t\t\t\t       MTK_DISABLE);\n\t\t\tif (err)\n\t\t\t\tgoto err;\n\n\t\t\terr = mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_DIR,\n\t\t\t\t\t       MTK_OUTPUT);\n\t\t\tif (err)\n\t\t\t\tgoto err;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_INPUT_ENABLE:\n\n\t\t\tif (hw->soc->ies_present) {\n\t\t\t\tmtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_IES,\n\t\t\t\t\t\t MTK_ENABLE);\n\t\t\t}\n\n\t\t\terr = mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_DIR,\n\t\t\t\t\t       MTK_INPUT);\n\t\t\tif (err)\n\t\t\t\tgoto err;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_SLEW_RATE:\n\t\t\terr = mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_SR,\n\t\t\t\t\t       arg);\n\t\t\tif (err)\n\t\t\t\tgoto err;\n\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_OUTPUT:\n\t\t\terr = mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_DIR,\n\t\t\t\t\t       MTK_OUTPUT);\n\t\t\tif (err)\n\t\t\t\tgoto err;\n\n\t\t\terr = mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_DO,\n\t\t\t\t\t       arg);\n\t\t\tif (err)\n\t\t\t\tgoto err;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_INPUT_SCHMITT_ENABLE:\n\t\t\t \n\t\t\targ = arg ? 2 : 1;\n\t\t\terr = mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_DIR,\n\t\t\t\t\t       arg & 1);\n\t\t\tif (err)\n\t\t\t\tgoto err;\n\n\t\t\terr = mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_SMT,\n\t\t\t\t\t       !!(arg & 2));\n\t\t\tif (err)\n\t\t\t\tgoto err;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_DRIVE_STRENGTH:\n\t\t\tif (hw->soc->drive_set) {\n\t\t\t\terr = hw->soc->drive_set(hw, desc, arg);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t} else {\n\t\t\t\terr = -ENOTSUPP;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MTK_PIN_CONFIG_TDSEL:\n\t\tcase MTK_PIN_CONFIG_RDSEL:\n\t\t\treg = (param == MTK_PIN_CONFIG_TDSEL) ?\n\t\t\t       PINCTRL_PIN_REG_TDSEL : PINCTRL_PIN_REG_RDSEL;\n\n\t\t\terr = mtk_hw_set_value(hw, desc, reg, arg);\n\t\t\tif (err)\n\t\t\t\tgoto err;\n\t\t\tbreak;\n\t\tcase MTK_PIN_CONFIG_PU_ADV:\n\t\tcase MTK_PIN_CONFIG_PD_ADV:\n\t\t\tif (hw->soc->adv_pull_set) {\n\t\t\t\tbool pullup;\n\n\t\t\t\tpullup = param == MTK_PIN_CONFIG_PU_ADV;\n\t\t\t\terr = hw->soc->adv_pull_set(hw, desc, pullup,\n\t\t\t\t\t\t\t    arg);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t} else {\n\t\t\t\treturn -ENOTSUPP;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -ENOTSUPP;\n\t\t}\n\t}\nerr:\n\treturn err;\n}\n\nstatic int mtk_pinconf_group_get(struct pinctrl_dev *pctldev,\n\t\t\t\t unsigned int group, unsigned long *config)\n{\n\tconst unsigned int *pins;\n\tunsigned int i, npins, old = 0;\n\tint ret;\n\n\tret = pinctrl_generic_get_group_pins(pctldev, group, &pins, &npins);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < npins; i++) {\n\t\tif (mtk_pinconf_get(pctldev, pins[i], config))\n\t\t\treturn -ENOTSUPP;\n\n\t\t \n\t\tif (i && old != *config)\n\t\t\treturn -ENOTSUPP;\n\n\t\told = *config;\n\t}\n\n\treturn 0;\n}\n\nstatic int mtk_pinconf_group_set(struct pinctrl_dev *pctldev,\n\t\t\t\t unsigned int group, unsigned long *configs,\n\t\t\t\t unsigned int num_configs)\n{\n\tconst unsigned int *pins;\n\tunsigned int i, npins;\n\tint ret;\n\n\tret = pinctrl_generic_get_group_pins(pctldev, group, &pins, &npins);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < npins; i++) {\n\t\tret = mtk_pinconf_set(pctldev, pins[i], configs, num_configs);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct pinctrl_ops mtk_pctlops = {\n\t.get_groups_count = pinctrl_generic_get_group_count,\n\t.get_group_name = pinctrl_generic_get_group_name,\n\t.get_group_pins = pinctrl_generic_get_group_pins,\n\t.dt_node_to_map = pinconf_generic_dt_node_to_map_all,\n\t.dt_free_map = pinconf_generic_dt_free_map,\n};\n\nstatic const struct pinmux_ops mtk_pmxops = {\n\t.get_functions_count = pinmux_generic_get_function_count,\n\t.get_function_name = pinmux_generic_get_function_name,\n\t.get_function_groups = pinmux_generic_get_function_groups,\n\t.set_mux = mtk_pinmux_set_mux,\n\t.gpio_request_enable = mtk_pinmux_gpio_request_enable,\n\t.gpio_set_direction = mtk_pinmux_gpio_set_direction,\n\t.strict = true,\n};\n\nstatic const struct pinconf_ops mtk_confops = {\n\t.is_generic = true,\n\t.pin_config_get = mtk_pinconf_get,\n\t.pin_config_set = mtk_pinconf_set,\n\t.pin_config_group_get = mtk_pinconf_group_get,\n\t.pin_config_group_set = mtk_pinconf_group_set,\n\t.pin_config_config_dbg_show = pinconf_generic_dump_config,\n};\n\nstatic struct pinctrl_desc mtk_desc = {\n\t.name = PINCTRL_PINCTRL_DEV,\n\t.pctlops = &mtk_pctlops,\n\t.pmxops = &mtk_pmxops,\n\t.confops = &mtk_confops,\n\t.owner = THIS_MODULE,\n};\n\nstatic int mtk_gpio_get(struct gpio_chip *chip, unsigned int gpio)\n{\n\tstruct mtk_pinctrl *hw = gpiochip_get_data(chip);\n\tconst struct mtk_pin_desc *desc;\n\tint value, err;\n\n\tdesc = (const struct mtk_pin_desc *)&hw->soc->pins[gpio];\n\tif (!desc->name)\n\t\treturn -ENOTSUPP;\n\n\terr = mtk_hw_get_value(hw, desc, PINCTRL_PIN_REG_DI, &value);\n\tif (err)\n\t\treturn err;\n\n\treturn !!value;\n}\n\nstatic void mtk_gpio_set(struct gpio_chip *chip, unsigned int gpio, int value)\n{\n\tstruct mtk_pinctrl *hw = gpiochip_get_data(chip);\n\tconst struct mtk_pin_desc *desc;\n\n\tdesc = (const struct mtk_pin_desc *)&hw->soc->pins[gpio];\n\tif (!desc->name) {\n\t\tdev_err(hw->dev, \"Failed to set gpio %d\\n\", gpio);\n\t\treturn;\n\t}\n\n\tmtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_DO, !!value);\n}\n\nstatic int mtk_gpio_direction_input(struct gpio_chip *chip, unsigned int gpio)\n{\n\treturn pinctrl_gpio_direction_input(chip->base + gpio);\n}\n\nstatic int mtk_gpio_direction_output(struct gpio_chip *chip, unsigned int gpio,\n\t\t\t\t     int value)\n{\n\tmtk_gpio_set(chip, gpio, value);\n\n\treturn pinctrl_gpio_direction_output(chip->base + gpio);\n}\n\nstatic int mtk_gpio_to_irq(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct mtk_pinctrl *hw = gpiochip_get_data(chip);\n\tconst struct mtk_pin_desc *desc;\n\n\tif (!hw->eint)\n\t\treturn -ENOTSUPP;\n\n\tdesc = (const struct mtk_pin_desc *)&hw->soc->pins[offset];\n\n\tif (desc->eint.eint_n == (u16)EINT_NA)\n\t\treturn -ENOTSUPP;\n\n\treturn mtk_eint_find_irq(hw->eint, desc->eint.eint_n);\n}\n\nstatic int mtk_gpio_set_config(struct gpio_chip *chip, unsigned int offset,\n\t\t\t       unsigned long config)\n{\n\tstruct mtk_pinctrl *hw = gpiochip_get_data(chip);\n\tconst struct mtk_pin_desc *desc;\n\tu32 debounce;\n\n\tdesc = (const struct mtk_pin_desc *)&hw->soc->pins[offset];\n\tif (!desc->name)\n\t\treturn -ENOTSUPP;\n\n\tif (!hw->eint ||\n\t    pinconf_to_config_param(config) != PIN_CONFIG_INPUT_DEBOUNCE ||\n\t    desc->eint.eint_n == (u16)EINT_NA)\n\t\treturn -ENOTSUPP;\n\n\tdebounce = pinconf_to_config_argument(config);\n\n\treturn mtk_eint_set_debounce(hw->eint, desc->eint.eint_n, debounce);\n}\n\nstatic int mtk_build_gpiochip(struct mtk_pinctrl *hw)\n{\n\tstruct gpio_chip *chip = &hw->chip;\n\tint ret;\n\n\tchip->label\t\t= PINCTRL_PINCTRL_DEV;\n\tchip->parent\t\t= hw->dev;\n\tchip->request\t\t= gpiochip_generic_request;\n\tchip->free\t\t= gpiochip_generic_free;\n\tchip->direction_input\t= mtk_gpio_direction_input;\n\tchip->direction_output\t= mtk_gpio_direction_output;\n\tchip->get\t\t= mtk_gpio_get;\n\tchip->set\t\t= mtk_gpio_set;\n\tchip->to_irq\t\t= mtk_gpio_to_irq;\n\tchip->set_config\t= mtk_gpio_set_config;\n\tchip->base\t\t= -1;\n\tchip->ngpio\t\t= hw->soc->npins;\n\n\tret = gpiochip_add_data(chip, hw);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (!of_property_present(hw->dev->of_node, \"gpio-ranges\")) {\n\t\tret = gpiochip_add_pin_range(chip, dev_name(hw->dev), 0, 0,\n\t\t\t\t\t     chip->ngpio);\n\t\tif (ret < 0) {\n\t\t\tgpiochip_remove(chip);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int mtk_build_groups(struct mtk_pinctrl *hw)\n{\n\tint err, i;\n\n\tfor (i = 0; i < hw->soc->ngrps; i++) {\n\t\tconst struct group_desc *group = hw->soc->grps + i;\n\n\t\terr = pinctrl_generic_add_group(hw->pctrl, group->name,\n\t\t\t\t\t\tgroup->pins, group->num_pins,\n\t\t\t\t\t\tgroup->data);\n\t\tif (err < 0) {\n\t\t\tdev_err(hw->dev, \"Failed to register group %s\\n\",\n\t\t\t\tgroup->name);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int mtk_build_functions(struct mtk_pinctrl *hw)\n{\n\tint i, err;\n\n\tfor (i = 0; i < hw->soc->nfuncs ; i++) {\n\t\tconst struct function_desc *func = hw->soc->funcs + i;\n\n\t\terr = pinmux_generic_add_function(hw->pctrl, func->name,\n\t\t\t\t\t\t  func->group_names,\n\t\t\t\t\t\t  func->num_group_names,\n\t\t\t\t\t\t  func->data);\n\t\tif (err < 0) {\n\t\t\tdev_err(hw->dev, \"Failed to register function %s\\n\",\n\t\t\t\tfunc->name);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint mtk_moore_pinctrl_probe(struct platform_device *pdev,\n\t\t\t    const struct mtk_pin_soc *soc)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct pinctrl_pin_desc *pins;\n\tstruct mtk_pinctrl *hw;\n\tint err, i;\n\n\thw = devm_kzalloc(&pdev->dev, sizeof(*hw), GFP_KERNEL);\n\tif (!hw)\n\t\treturn -ENOMEM;\n\n\thw->soc = soc;\n\thw->dev = &pdev->dev;\n\n\tif (!hw->soc->nbase_names)\n\t\treturn dev_err_probe(dev, -EINVAL,\n\t\t\t\"SoC should be assigned at least one register base\\n\");\n\n\thw->base = devm_kmalloc_array(&pdev->dev, hw->soc->nbase_names,\n\t\t\t\t      sizeof(*hw->base), GFP_KERNEL);\n\tif (!hw->base)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < hw->soc->nbase_names; i++) {\n\t\thw->base[i] = devm_platform_ioremap_resource_byname(pdev,\n\t\t\t\t\t\thw->soc->base_names[i]);\n\t\tif (IS_ERR(hw->base[i]))\n\t\t\treturn PTR_ERR(hw->base[i]);\n\t}\n\n\thw->nbase = hw->soc->nbase_names;\n\n\tspin_lock_init(&hw->lock);\n\n\t \n\tpins = devm_kmalloc_array(&pdev->dev, hw->soc->npins, sizeof(*pins),\n\t\t\t\t  GFP_KERNEL);\n\tif (!pins)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < hw->soc->npins; i++) {\n\t\tpins[i].number = hw->soc->pins[i].number;\n\t\tpins[i].name = hw->soc->pins[i].name;\n\t}\n\n\t \n\tmtk_desc.pins = (const struct pinctrl_pin_desc *)pins;\n\tmtk_desc.npins = hw->soc->npins;\n\tmtk_desc.num_custom_params = ARRAY_SIZE(mtk_custom_bindings);\n\tmtk_desc.custom_params = mtk_custom_bindings;\n#ifdef CONFIG_DEBUG_FS\n\tmtk_desc.custom_conf_items = mtk_conf_items;\n#endif\n\n\terr = devm_pinctrl_register_and_init(&pdev->dev, &mtk_desc, hw,\n\t\t\t\t\t     &hw->pctrl);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = mtk_build_groups(hw);\n\tif (err)\n\t\treturn dev_err_probe(dev, err, \"Failed to build groups\\n\");\n\n\t \n\terr = mtk_build_functions(hw);\n\tif (err)\n\t\treturn dev_err_probe(dev, err, \"Failed to build functions\\n\");\n\n\t \n\terr = pinctrl_enable(hw->pctrl);\n\tif (err)\n\t\treturn err;\n\n\terr = mtk_build_eint(hw, pdev);\n\tif (err)\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"Failed to add EINT, but pinctrl still can work\\n\");\n\n\t \n\terr = mtk_build_gpiochip(hw);\n\tif (err)\n\t\treturn dev_err_probe(dev, err, \"Failed to add gpio_chip\\n\");\n\n\tplatform_set_drvdata(pdev, hw);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}