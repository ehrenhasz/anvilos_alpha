{
  "module_name": "pinctrl-mtk-common.c",
  "hash_id": "5289eee43683614aa4ef0a12f92be01bd7e2a8417a3d310520f337d6ee317d13",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/mediatek/pinctrl-mtk-common.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/gpio/driver.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/pinctrl/machine.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinconf-generic.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinmux.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/regmap.h>\n#include <linux/mfd/syscon.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/pm.h>\n#include <dt-bindings/pinctrl/mt65xx.h>\n\n#include \"../core.h\"\n#include \"../pinconf.h\"\n#include \"../pinctrl-utils.h\"\n#include \"mtk-eint.h\"\n#include \"pinctrl-mtk-common.h\"\n\n#define GPIO_MODE_BITS        3\n#define GPIO_MODE_PREFIX \"GPIO\"\n\nstatic const char * const mtk_gpio_functions[] = {\n\t\"func0\", \"func1\", \"func2\", \"func3\",\n\t\"func4\", \"func5\", \"func6\", \"func7\",\n\t\"func8\", \"func9\", \"func10\", \"func11\",\n\t\"func12\", \"func13\", \"func14\", \"func15\",\n};\n\n \nstatic struct regmap *mtk_get_regmap(struct mtk_pinctrl *pctl,\n\t\tunsigned long pin)\n{\n\tif (pin >= pctl->devdata->type1_start && pin < pctl->devdata->type1_end)\n\t\treturn pctl->regmap2;\n\treturn pctl->regmap1;\n}\n\nstatic unsigned int mtk_get_port(struct mtk_pinctrl *pctl, unsigned long pin)\n{\n\t \n\treturn ((pin >> pctl->devdata->mode_shf) & pctl->devdata->port_mask)\n\t\t\t<< pctl->devdata->port_shf;\n}\n\nstatic int mtk_pmx_gpio_set_direction(struct pinctrl_dev *pctldev,\n\t\t\tstruct pinctrl_gpio_range *range, unsigned offset,\n\t\t\tbool input)\n{\n\tunsigned int reg_addr;\n\tunsigned int bit;\n\tstruct mtk_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\n\treg_addr = mtk_get_port(pctl, offset) + pctl->devdata->dir_offset;\n\tbit = BIT(offset & pctl->devdata->mode_mask);\n\n\tif (pctl->devdata->spec_dir_set)\n\t\tpctl->devdata->spec_dir_set(&reg_addr, offset);\n\n\tif (input)\n\t\t \n\t\treg_addr = CLR_ADDR(reg_addr, pctl);\n\telse\n\t\treg_addr = SET_ADDR(reg_addr, pctl);\n\n\tregmap_write(mtk_get_regmap(pctl, offset), reg_addr, bit);\n\treturn 0;\n}\n\nstatic void mtk_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\n{\n\tunsigned int reg_addr;\n\tunsigned int bit;\n\tstruct mtk_pinctrl *pctl = gpiochip_get_data(chip);\n\n\treg_addr = mtk_get_port(pctl, offset) + pctl->devdata->dout_offset;\n\tbit = BIT(offset & pctl->devdata->mode_mask);\n\n\tif (value)\n\t\treg_addr = SET_ADDR(reg_addr, pctl);\n\telse\n\t\treg_addr = CLR_ADDR(reg_addr, pctl);\n\n\tregmap_write(mtk_get_regmap(pctl, offset), reg_addr, bit);\n}\n\nstatic int mtk_pconf_set_ies_smt(struct mtk_pinctrl *pctl, unsigned pin,\n\t\tint value, enum pin_config_param arg)\n{\n\tunsigned int reg_addr, offset;\n\tunsigned int bit;\n\n\t \n\tif (!pctl->devdata->spec_ies_smt_set &&\n\t\tpctl->devdata->ies_offset == MTK_PINCTRL_NOT_SUPPORT &&\n\t\t\targ == PIN_CONFIG_INPUT_ENABLE)\n\t\treturn -EINVAL;\n\n\tif (!pctl->devdata->spec_ies_smt_set &&\n\t\tpctl->devdata->smt_offset == MTK_PINCTRL_NOT_SUPPORT &&\n\t\t\targ == PIN_CONFIG_INPUT_SCHMITT_ENABLE)\n\t\treturn -EINVAL;\n\n\t \n\tif (pctl->devdata->spec_ies_smt_set) {\n\t\treturn pctl->devdata->spec_ies_smt_set(mtk_get_regmap(pctl, pin),\n\t\t\tpctl->devdata, pin, value, arg);\n\t}\n\n\tif (arg == PIN_CONFIG_INPUT_ENABLE)\n\t\toffset = pctl->devdata->ies_offset;\n\telse\n\t\toffset = pctl->devdata->smt_offset;\n\n\tbit = BIT(offset & pctl->devdata->mode_mask);\n\n\tif (value)\n\t\treg_addr = SET_ADDR(mtk_get_port(pctl, pin) + offset, pctl);\n\telse\n\t\treg_addr = CLR_ADDR(mtk_get_port(pctl, pin) + offset, pctl);\n\n\tregmap_write(mtk_get_regmap(pctl, pin), reg_addr, bit);\n\treturn 0;\n}\n\nint mtk_pconf_spec_set_ies_smt_range(struct regmap *regmap,\n\t\tconst struct mtk_pinctrl_devdata *devdata,\n\t\tunsigned int pin, int value, enum pin_config_param arg)\n{\n\tconst struct mtk_pin_ies_smt_set *ies_smt_infos = NULL;\n\tunsigned int i, info_num, reg_addr, bit;\n\n\tswitch (arg) {\n\tcase PIN_CONFIG_INPUT_ENABLE:\n\t\ties_smt_infos = devdata->spec_ies;\n\t\tinfo_num = devdata->n_spec_ies;\n\t\tbreak;\n\tcase PIN_CONFIG_INPUT_SCHMITT_ENABLE:\n\t\ties_smt_infos = devdata->spec_smt;\n\t\tinfo_num = devdata->n_spec_smt;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!ies_smt_infos)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < info_num; i++) {\n\t\tif (pin >= ies_smt_infos[i].start &&\n\t\t\t\tpin <= ies_smt_infos[i].end) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == info_num)\n\t\treturn -EINVAL;\n\n\tif (value)\n\t\treg_addr = ies_smt_infos[i].offset + devdata->port_align;\n\telse\n\t\treg_addr = ies_smt_infos[i].offset + (devdata->port_align << 1);\n\n\tbit = BIT(ies_smt_infos[i].bit);\n\tregmap_write(regmap, reg_addr, bit);\n\treturn 0;\n}\n\nstatic const struct mtk_pin_drv_grp *mtk_find_pin_drv_grp_by_pin(\n\t\tstruct mtk_pinctrl *pctl,  unsigned long pin) {\n\tint i;\n\n\tfor (i = 0; i < pctl->devdata->n_pin_drv_grps; i++) {\n\t\tconst struct mtk_pin_drv_grp *pin_drv =\n\t\t\t\tpctl->devdata->pin_drv_grp + i;\n\t\tif (pin == pin_drv->pin)\n\t\t\treturn pin_drv;\n\t}\n\n\treturn NULL;\n}\n\nstatic int mtk_pconf_set_driving(struct mtk_pinctrl *pctl,\n\t\tunsigned int pin, unsigned char driving)\n{\n\tconst struct mtk_pin_drv_grp *pin_drv;\n\tunsigned int val;\n\tunsigned int bits, mask, shift;\n\tconst struct mtk_drv_group_desc *drv_grp;\n\n\tif (pin >= pctl->devdata->npins)\n\t\treturn -EINVAL;\n\n\tpin_drv = mtk_find_pin_drv_grp_by_pin(pctl, pin);\n\tif (!pin_drv || pin_drv->grp > pctl->devdata->n_grp_cls)\n\t\treturn -EINVAL;\n\n\tdrv_grp = pctl->devdata->grp_desc + pin_drv->grp;\n\tif (driving >= drv_grp->min_drv && driving <= drv_grp->max_drv\n\t\t&& !(driving % drv_grp->step)) {\n\t\tval = driving / drv_grp->step - 1;\n\t\tbits = drv_grp->high_bit - drv_grp->low_bit + 1;\n\t\tmask = BIT(bits) - 1;\n\t\tshift = pin_drv->bit + drv_grp->low_bit;\n\t\tmask <<= shift;\n\t\tval <<= shift;\n\t\treturn regmap_update_bits(mtk_get_regmap(pctl, pin),\n\t\t\t\tpin_drv->offset, mask, val);\n\t}\n\n\treturn -EINVAL;\n}\n\nint mtk_pctrl_spec_pull_set_samereg(struct regmap *regmap,\n\t\tconst struct mtk_pinctrl_devdata *devdata,\n\t\tunsigned int pin, bool isup, unsigned int r1r0)\n{\n\tunsigned int i;\n\tunsigned int reg_pupd, reg_set, reg_rst;\n\tunsigned int bit_pupd, bit_r0, bit_r1;\n\tconst struct mtk_pin_spec_pupd_set_samereg *spec_pupd_pin;\n\tbool find = false;\n\n\tif (!devdata->spec_pupd)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < devdata->n_spec_pupd; i++) {\n\t\tif (pin == devdata->spec_pupd[i].pin) {\n\t\t\tfind = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!find)\n\t\treturn -EINVAL;\n\n\tspec_pupd_pin = devdata->spec_pupd + i;\n\treg_set = spec_pupd_pin->offset + devdata->port_align;\n\treg_rst = spec_pupd_pin->offset + (devdata->port_align << 1);\n\n\tif (isup)\n\t\treg_pupd = reg_rst;\n\telse\n\t\treg_pupd = reg_set;\n\n\tbit_pupd = BIT(spec_pupd_pin->pupd_bit);\n\tregmap_write(regmap, reg_pupd, bit_pupd);\n\n\tbit_r0 = BIT(spec_pupd_pin->r0_bit);\n\tbit_r1 = BIT(spec_pupd_pin->r1_bit);\n\n\tswitch (r1r0) {\n\tcase MTK_PUPD_SET_R1R0_00:\n\t\tregmap_write(regmap, reg_rst, bit_r0);\n\t\tregmap_write(regmap, reg_rst, bit_r1);\n\t\tbreak;\n\tcase MTK_PUPD_SET_R1R0_01:\n\t\tregmap_write(regmap, reg_set, bit_r0);\n\t\tregmap_write(regmap, reg_rst, bit_r1);\n\t\tbreak;\n\tcase MTK_PUPD_SET_R1R0_10:\n\t\tregmap_write(regmap, reg_rst, bit_r0);\n\t\tregmap_write(regmap, reg_set, bit_r1);\n\t\tbreak;\n\tcase MTK_PUPD_SET_R1R0_11:\n\t\tregmap_write(regmap, reg_set, bit_r0);\n\t\tregmap_write(regmap, reg_set, bit_r1);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int mtk_pconf_set_pull_select(struct mtk_pinctrl *pctl,\n\t\tunsigned int pin, bool enable, bool isup, unsigned int arg)\n{\n\tunsigned int bit;\n\tunsigned int reg_pullen, reg_pullsel, r1r0;\n\tint ret;\n\n\t \n\tif (pctl->devdata->spec_pull_set) {\n\t\t \n\t\tr1r0 = enable ? arg : MTK_PUPD_SET_R1R0_00;\n\t\tret = pctl->devdata->spec_pull_set(mtk_get_regmap(pctl, pin),\n\t\t\t\t\t\t   pctl->devdata, pin, isup,\n\t\t\t\t\t\t   r1r0);\n\t\tif (!ret)\n\t\t\treturn 0;\n\t}\n\n\t \n\tif (arg != 0 && arg != 1) {\n\t\tdev_err(pctl->dev, \"invalid pull-up argument %d on pin %d .\\n\",\n\t\t\targ, pin);\n\t\treturn -EINVAL;\n\t}\n\n\tif (pctl->devdata->mt8365_set_clr_mode) {\n\t\tbit = pin & pctl->devdata->mode_mask;\n\t\treg_pullen = mtk_get_port(pctl, pin) +\n\t\t\tpctl->devdata->pullen_offset;\n\t\treg_pullsel = mtk_get_port(pctl, pin) +\n\t\t\tpctl->devdata->pullsel_offset;\n\t\tret = pctl->devdata->mt8365_set_clr_mode(mtk_get_regmap(pctl, pin),\n\t\t\tbit, reg_pullen, reg_pullsel,\n\t\t\tenable, isup);\n\t\tif (ret)\n\t\t\treturn -EINVAL;\n\n\t\treturn 0;\n\t}\n\n\tbit = BIT(pin & pctl->devdata->mode_mask);\n\tif (enable)\n\t\treg_pullen = SET_ADDR(mtk_get_port(pctl, pin) +\n\t\t\tpctl->devdata->pullen_offset, pctl);\n\telse\n\t\treg_pullen = CLR_ADDR(mtk_get_port(pctl, pin) +\n\t\t\tpctl->devdata->pullen_offset, pctl);\n\n\tif (isup)\n\t\treg_pullsel = SET_ADDR(mtk_get_port(pctl, pin) +\n\t\t\tpctl->devdata->pullsel_offset, pctl);\n\telse\n\t\treg_pullsel = CLR_ADDR(mtk_get_port(pctl, pin) +\n\t\t\tpctl->devdata->pullsel_offset, pctl);\n\n\tregmap_write(mtk_get_regmap(pctl, pin), reg_pullen, bit);\n\tregmap_write(mtk_get_regmap(pctl, pin), reg_pullsel, bit);\n\treturn 0;\n}\n\nstatic int mtk_pconf_parse_conf(struct pinctrl_dev *pctldev,\n\t\tunsigned int pin, enum pin_config_param param,\n\t\tenum pin_config_param arg)\n{\n\tint ret = 0;\n\tstruct mtk_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\n\tswitch (param) {\n\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\tret = mtk_pconf_set_pull_select(pctl, pin, false, false, arg);\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\tret = mtk_pconf_set_pull_select(pctl, pin, true, true, arg);\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\tret = mtk_pconf_set_pull_select(pctl, pin, true, false, arg);\n\t\tbreak;\n\tcase PIN_CONFIG_INPUT_ENABLE:\n\t\tmtk_pmx_gpio_set_direction(pctldev, NULL, pin, true);\n\t\tret = mtk_pconf_set_ies_smt(pctl, pin, arg, param);\n\t\tbreak;\n\tcase PIN_CONFIG_OUTPUT:\n\t\tmtk_gpio_set(pctl->chip, pin, arg);\n\t\tret = mtk_pmx_gpio_set_direction(pctldev, NULL, pin, false);\n\t\tbreak;\n\tcase PIN_CONFIG_INPUT_SCHMITT_ENABLE:\n\t\tmtk_pmx_gpio_set_direction(pctldev, NULL, pin, true);\n\t\tret = mtk_pconf_set_ies_smt(pctl, pin, arg, param);\n\t\tbreak;\n\tcase PIN_CONFIG_DRIVE_STRENGTH:\n\t\tret = mtk_pconf_set_driving(pctl, pin, arg);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int mtk_pconf_group_get(struct pinctrl_dev *pctldev,\n\t\t\t\t unsigned group,\n\t\t\t\t unsigned long *config)\n{\n\tstruct mtk_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\n\t*config = pctl->groups[group].config;\n\n\treturn 0;\n}\n\nstatic int mtk_pconf_group_set(struct pinctrl_dev *pctldev, unsigned group,\n\t\t\t\t unsigned long *configs, unsigned num_configs)\n{\n\tstruct mtk_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct mtk_pinctrl_group *g = &pctl->groups[group];\n\tint i, ret;\n\n\tfor (i = 0; i < num_configs; i++) {\n\t\tret = mtk_pconf_parse_conf(pctldev, g->pin,\n\t\t\tpinconf_to_config_param(configs[i]),\n\t\t\tpinconf_to_config_argument(configs[i]));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tg->config = configs[i];\n\t}\n\n\treturn 0;\n}\n\nstatic const struct pinconf_ops mtk_pconf_ops = {\n\t.pin_config_group_get\t= mtk_pconf_group_get,\n\t.pin_config_group_set\t= mtk_pconf_group_set,\n};\n\nstatic struct mtk_pinctrl_group *\nmtk_pctrl_find_group_by_pin(struct mtk_pinctrl *pctl, u32 pin)\n{\n\tint i;\n\n\tfor (i = 0; i < pctl->ngroups; i++) {\n\t\tstruct mtk_pinctrl_group *grp = pctl->groups + i;\n\n\t\tif (grp->pin == pin)\n\t\t\treturn grp;\n\t}\n\n\treturn NULL;\n}\n\nstatic const struct mtk_desc_function *mtk_pctrl_find_function_by_pin(\n\t\tstruct mtk_pinctrl *pctl, u32 pin_num, u32 fnum)\n{\n\tconst struct mtk_desc_pin *pin = pctl->devdata->pins + pin_num;\n\tconst struct mtk_desc_function *func = pin->functions;\n\n\twhile (func && func->name) {\n\t\tif (func->muxval == fnum)\n\t\t\treturn func;\n\t\tfunc++;\n\t}\n\n\treturn NULL;\n}\n\nstatic bool mtk_pctrl_is_function_valid(struct mtk_pinctrl *pctl,\n\t\tu32 pin_num, u32 fnum)\n{\n\tint i;\n\n\tfor (i = 0; i < pctl->devdata->npins; i++) {\n\t\tconst struct mtk_desc_pin *pin = pctl->devdata->pins + i;\n\n\t\tif (pin->pin.number == pin_num) {\n\t\t\tconst struct mtk_desc_function *func =\n\t\t\t\t\tpin->functions;\n\n\t\t\twhile (func && func->name) {\n\t\t\t\tif (func->muxval == fnum)\n\t\t\t\t\treturn true;\n\t\t\t\tfunc++;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic int mtk_pctrl_dt_node_to_map_func(struct mtk_pinctrl *pctl,\n\t\tu32 pin, u32 fnum, struct mtk_pinctrl_group *grp,\n\t\tstruct pinctrl_map **map, unsigned *reserved_maps,\n\t\tunsigned *num_maps)\n{\n\tbool ret;\n\n\tif (*num_maps == *reserved_maps)\n\t\treturn -ENOSPC;\n\n\t(*map)[*num_maps].type = PIN_MAP_TYPE_MUX_GROUP;\n\t(*map)[*num_maps].data.mux.group = grp->name;\n\n\tret = mtk_pctrl_is_function_valid(pctl, pin, fnum);\n\tif (!ret) {\n\t\tdev_err(pctl->dev, \"invalid function %d on pin %d .\\n\",\n\t\t\t\tfnum, pin);\n\t\treturn -EINVAL;\n\t}\n\n\t(*map)[*num_maps].data.mux.function = mtk_gpio_functions[fnum];\n\t(*num_maps)++;\n\n\treturn 0;\n}\n\nstatic int mtk_pctrl_dt_subnode_to_map(struct pinctrl_dev *pctldev,\n\t\t\t\t      struct device_node *node,\n\t\t\t\t      struct pinctrl_map **map,\n\t\t\t\t      unsigned *reserved_maps,\n\t\t\t\t      unsigned *num_maps)\n{\n\tstruct property *pins;\n\tu32 pinfunc, pin, func;\n\tint num_pins, num_funcs, maps_per_pin;\n\tunsigned long *configs;\n\tunsigned int num_configs;\n\tbool has_config = false;\n\tint i, err;\n\tunsigned reserve = 0;\n\tstruct mtk_pinctrl_group *grp;\n\tstruct mtk_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\n\tpins = of_find_property(node, \"pinmux\", NULL);\n\tif (!pins) {\n\t\tdev_err(pctl->dev, \"missing pins property in node %pOFn .\\n\",\n\t\t\t\tnode);\n\t\treturn -EINVAL;\n\t}\n\n\terr = pinconf_generic_parse_dt_config(node, pctldev, &configs,\n\t\t&num_configs);\n\tif (err)\n\t\treturn err;\n\n\tif (num_configs)\n\t\thas_config = true;\n\n\tnum_pins = pins->length / sizeof(u32);\n\tnum_funcs = num_pins;\n\tmaps_per_pin = 0;\n\tif (num_funcs)\n\t\tmaps_per_pin++;\n\tif (has_config && num_pins >= 1)\n\t\tmaps_per_pin++;\n\n\tif (!num_pins || !maps_per_pin) {\n\t\terr = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\treserve = num_pins * maps_per_pin;\n\n\terr = pinctrl_utils_reserve_map(pctldev, map,\n\t\t\treserved_maps, num_maps, reserve);\n\tif (err < 0)\n\t\tgoto exit;\n\n\tfor (i = 0; i < num_pins; i++) {\n\t\terr = of_property_read_u32_index(node, \"pinmux\",\n\t\t\t\ti, &pinfunc);\n\t\tif (err)\n\t\t\tgoto exit;\n\n\t\tpin = MTK_GET_PIN_NO(pinfunc);\n\t\tfunc = MTK_GET_PIN_FUNC(pinfunc);\n\n\t\tif (pin >= pctl->devdata->npins ||\n\t\t\t\tfunc >= ARRAY_SIZE(mtk_gpio_functions)) {\n\t\t\tdev_err(pctl->dev, \"invalid pins value.\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tgrp = mtk_pctrl_find_group_by_pin(pctl, pin);\n\t\tif (!grp) {\n\t\t\tdev_err(pctl->dev, \"unable to match pin %d to group\\n\",\n\t\t\t\t\tpin);\n\t\t\terr = -EINVAL;\n\t\t\tgoto exit;\n\t\t}\n\n\t\terr = mtk_pctrl_dt_node_to_map_func(pctl, pin, func, grp, map,\n\t\t\t\treserved_maps, num_maps);\n\t\tif (err < 0)\n\t\t\tgoto exit;\n\n\t\tif (has_config) {\n\t\t\terr = pinctrl_utils_add_map_configs(pctldev, map,\n\t\t\t\t\treserved_maps, num_maps, grp->name,\n\t\t\t\t\tconfigs, num_configs,\n\t\t\t\t\tPIN_MAP_TYPE_CONFIGS_GROUP);\n\t\t\tif (err < 0)\n\t\t\t\tgoto exit;\n\t\t}\n\t}\n\n\terr = 0;\n\nexit:\n\tkfree(configs);\n\treturn err;\n}\n\nstatic int mtk_pctrl_dt_node_to_map(struct pinctrl_dev *pctldev,\n\t\t\t\t struct device_node *np_config,\n\t\t\t\t struct pinctrl_map **map, unsigned *num_maps)\n{\n\tstruct device_node *np;\n\tunsigned reserved_maps;\n\tint ret;\n\n\t*map = NULL;\n\t*num_maps = 0;\n\treserved_maps = 0;\n\n\tfor_each_child_of_node(np_config, np) {\n\t\tret = mtk_pctrl_dt_subnode_to_map(pctldev, np, map,\n\t\t\t\t&reserved_maps, num_maps);\n\t\tif (ret < 0) {\n\t\t\tpinctrl_utils_free_map(pctldev, *map, *num_maps);\n\t\t\tof_node_put(np);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int mtk_pctrl_get_groups_count(struct pinctrl_dev *pctldev)\n{\n\tstruct mtk_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pctl->ngroups;\n}\n\nstatic const char *mtk_pctrl_get_group_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t      unsigned group)\n{\n\tstruct mtk_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pctl->groups[group].name;\n}\n\nstatic int mtk_pctrl_get_group_pins(struct pinctrl_dev *pctldev,\n\t\t\t\t      unsigned group,\n\t\t\t\t      const unsigned **pins,\n\t\t\t\t      unsigned *num_pins)\n{\n\tstruct mtk_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\n\t*pins = (unsigned *)&pctl->groups[group].pin;\n\t*num_pins = 1;\n\n\treturn 0;\n}\n\nstatic const struct pinctrl_ops mtk_pctrl_ops = {\n\t.dt_node_to_map\t\t= mtk_pctrl_dt_node_to_map,\n\t.dt_free_map\t\t= pinctrl_utils_free_map,\n\t.get_groups_count\t= mtk_pctrl_get_groups_count,\n\t.get_group_name\t\t= mtk_pctrl_get_group_name,\n\t.get_group_pins\t\t= mtk_pctrl_get_group_pins,\n};\n\nstatic int mtk_pmx_get_funcs_cnt(struct pinctrl_dev *pctldev)\n{\n\treturn ARRAY_SIZE(mtk_gpio_functions);\n}\n\nstatic const char *mtk_pmx_get_func_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t   unsigned selector)\n{\n\treturn mtk_gpio_functions[selector];\n}\n\nstatic int mtk_pmx_get_func_groups(struct pinctrl_dev *pctldev,\n\t\t\t\t     unsigned function,\n\t\t\t\t     const char * const **groups,\n\t\t\t\t     unsigned * const num_groups)\n{\n\tstruct mtk_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\n\t*groups = pctl->grp_names;\n\t*num_groups = pctl->ngroups;\n\n\treturn 0;\n}\n\nstatic int mtk_pmx_set_mode(struct pinctrl_dev *pctldev,\n\t\tunsigned long pin, unsigned long mode)\n{\n\tunsigned int reg_addr;\n\tunsigned char bit;\n\tunsigned int val;\n\tunsigned int mask = (1L << GPIO_MODE_BITS) - 1;\n\tstruct mtk_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\n\tif (pctl->devdata->spec_pinmux_set)\n\t\tpctl->devdata->spec_pinmux_set(mtk_get_regmap(pctl, pin),\n\t\t\t\t\tpin, mode);\n\n\treg_addr = ((pin / pctl->devdata->mode_per_reg) << pctl->devdata->port_shf)\n\t\t\t+ pctl->devdata->pinmux_offset;\n\n\tmode &= mask;\n\tbit = pin % pctl->devdata->mode_per_reg;\n\tmask <<= (GPIO_MODE_BITS * bit);\n\tval = (mode << (GPIO_MODE_BITS * bit));\n\treturn regmap_update_bits(mtk_get_regmap(pctl, pin),\n\t\t\treg_addr, mask, val);\n}\n\nstatic const struct mtk_desc_pin *\nmtk_find_pin_by_eint_num(struct mtk_pinctrl *pctl, unsigned int eint_num)\n{\n\tint i;\n\tconst struct mtk_desc_pin *pin;\n\n\tfor (i = 0; i < pctl->devdata->npins; i++) {\n\t\tpin = pctl->devdata->pins + i;\n\t\tif (pin->eint.eintnum == eint_num)\n\t\t\treturn pin;\n\t}\n\n\treturn NULL;\n}\n\nstatic int mtk_pmx_set_mux(struct pinctrl_dev *pctldev,\n\t\t\t    unsigned function,\n\t\t\t    unsigned group)\n{\n\tbool ret;\n\tconst struct mtk_desc_function *desc;\n\tstruct mtk_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct mtk_pinctrl_group *g = pctl->groups + group;\n\n\tret = mtk_pctrl_is_function_valid(pctl, g->pin, function);\n\tif (!ret) {\n\t\tdev_err(pctl->dev, \"invalid function %d on group %d .\\n\",\n\t\t\t\tfunction, group);\n\t\treturn -EINVAL;\n\t}\n\n\tdesc = mtk_pctrl_find_function_by_pin(pctl, g->pin, function);\n\tif (!desc)\n\t\treturn -EINVAL;\n\tmtk_pmx_set_mode(pctldev, g->pin, desc->muxval);\n\treturn 0;\n}\n\nstatic int mtk_pmx_find_gpio_mode(struct mtk_pinctrl *pctl,\n\t\t\t\tunsigned offset)\n{\n\tconst struct mtk_desc_pin *pin = pctl->devdata->pins + offset;\n\tconst struct mtk_desc_function *func = pin->functions;\n\n\twhile (func && func->name) {\n\t\tif (!strncmp(func->name, GPIO_MODE_PREFIX,\n\t\t\tsizeof(GPIO_MODE_PREFIX)-1))\n\t\t\treturn func->muxval;\n\t\tfunc++;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int mtk_pmx_gpio_request_enable(struct pinctrl_dev *pctldev,\n\t\t\t\t    struct pinctrl_gpio_range *range,\n\t\t\t\t    unsigned offset)\n{\n\tint muxval;\n\tstruct mtk_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\n\tmuxval = mtk_pmx_find_gpio_mode(pctl, offset);\n\n\tif (muxval < 0) {\n\t\tdev_err(pctl->dev, \"invalid gpio pin %d.\\n\", offset);\n\t\treturn -EINVAL;\n\t}\n\n\tmtk_pmx_set_mode(pctldev, offset, muxval);\n\tmtk_pconf_set_ies_smt(pctl, offset, 1, PIN_CONFIG_INPUT_ENABLE);\n\n\treturn 0;\n}\n\nstatic const struct pinmux_ops mtk_pmx_ops = {\n\t.get_functions_count\t= mtk_pmx_get_funcs_cnt,\n\t.get_function_name\t= mtk_pmx_get_func_name,\n\t.get_function_groups\t= mtk_pmx_get_func_groups,\n\t.set_mux\t\t= mtk_pmx_set_mux,\n\t.gpio_set_direction\t= mtk_pmx_gpio_set_direction,\n\t.gpio_request_enable\t= mtk_pmx_gpio_request_enable,\n};\n\nstatic int mtk_gpio_direction_input(struct gpio_chip *chip,\n\t\t\t\t\tunsigned offset)\n{\n\treturn pinctrl_gpio_direction_input(chip->base + offset);\n}\n\nstatic int mtk_gpio_direction_output(struct gpio_chip *chip,\n\t\t\t\t\tunsigned offset, int value)\n{\n\tmtk_gpio_set(chip, offset, value);\n\treturn pinctrl_gpio_direction_output(chip->base + offset);\n}\n\nstatic int mtk_gpio_get_direction(struct gpio_chip *chip, unsigned offset)\n{\n\tunsigned int reg_addr;\n\tunsigned int bit;\n\tunsigned int read_val = 0;\n\n\tstruct mtk_pinctrl *pctl = gpiochip_get_data(chip);\n\n\treg_addr =  mtk_get_port(pctl, offset) + pctl->devdata->dir_offset;\n\tbit = BIT(offset & pctl->devdata->mode_mask);\n\n\tif (pctl->devdata->spec_dir_set)\n\t\tpctl->devdata->spec_dir_set(&reg_addr, offset);\n\n\tregmap_read(pctl->regmap1, reg_addr, &read_val);\n\tif (read_val & bit)\n\t\treturn GPIO_LINE_DIRECTION_OUT;\n\n\treturn GPIO_LINE_DIRECTION_IN;\n}\n\nstatic int mtk_gpio_get(struct gpio_chip *chip, unsigned offset)\n{\n\tunsigned int reg_addr;\n\tunsigned int bit;\n\tunsigned int read_val = 0;\n\tstruct mtk_pinctrl *pctl = gpiochip_get_data(chip);\n\n\treg_addr = mtk_get_port(pctl, offset) +\n\t\tpctl->devdata->din_offset;\n\n\tbit = BIT(offset & pctl->devdata->mode_mask);\n\tregmap_read(pctl->regmap1, reg_addr, &read_val);\n\treturn !!(read_val & bit);\n}\n\nstatic int mtk_gpio_to_irq(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct mtk_pinctrl *pctl = gpiochip_get_data(chip);\n\tconst struct mtk_desc_pin *pin;\n\tunsigned long eint_n;\n\n\tpin = pctl->devdata->pins + offset;\n\tif (pin->eint.eintnum == NO_EINT_SUPPORT)\n\t\treturn -EINVAL;\n\n\teint_n = pin->eint.eintnum;\n\n\treturn mtk_eint_find_irq(pctl->eint, eint_n);\n}\n\nstatic int mtk_gpio_set_config(struct gpio_chip *chip, unsigned offset,\n\t\t\t       unsigned long config)\n{\n\tstruct mtk_pinctrl *pctl = gpiochip_get_data(chip);\n\tconst struct mtk_desc_pin *pin;\n\tunsigned long eint_n;\n\tu32 debounce;\n\n\tif (pinconf_to_config_param(config) != PIN_CONFIG_INPUT_DEBOUNCE)\n\t\treturn -ENOTSUPP;\n\n\tpin = pctl->devdata->pins + offset;\n\tif (pin->eint.eintnum == NO_EINT_SUPPORT)\n\t\treturn -EINVAL;\n\n\tdebounce = pinconf_to_config_argument(config);\n\teint_n = pin->eint.eintnum;\n\n\treturn mtk_eint_set_debounce(pctl->eint, eint_n, debounce);\n}\n\nstatic const struct gpio_chip mtk_gpio_chip = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.request\t\t= gpiochip_generic_request,\n\t.free\t\t\t= gpiochip_generic_free,\n\t.get_direction\t\t= mtk_gpio_get_direction,\n\t.direction_input\t= mtk_gpio_direction_input,\n\t.direction_output\t= mtk_gpio_direction_output,\n\t.get\t\t\t= mtk_gpio_get,\n\t.set\t\t\t= mtk_gpio_set,\n\t.to_irq\t\t\t= mtk_gpio_to_irq,\n\t.set_config\t\t= mtk_gpio_set_config,\n};\n\nstatic int mtk_eint_suspend(struct device *device)\n{\n\tstruct mtk_pinctrl *pctl = dev_get_drvdata(device);\n\n\treturn mtk_eint_do_suspend(pctl->eint);\n}\n\nstatic int mtk_eint_resume(struct device *device)\n{\n\tstruct mtk_pinctrl *pctl = dev_get_drvdata(device);\n\n\treturn mtk_eint_do_resume(pctl->eint);\n}\n\nconst struct dev_pm_ops mtk_eint_pm_ops = {\n\t.suspend_noirq = mtk_eint_suspend,\n\t.resume_noirq = mtk_eint_resume,\n};\n\nstatic int mtk_pctrl_build_state(struct platform_device *pdev)\n{\n\tstruct mtk_pinctrl *pctl = platform_get_drvdata(pdev);\n\tint i;\n\n\tpctl->ngroups = pctl->devdata->npins;\n\n\t \n\tpctl->groups = devm_kcalloc(&pdev->dev, pctl->ngroups,\n\t\t\t\t    sizeof(*pctl->groups), GFP_KERNEL);\n\tif (!pctl->groups)\n\t\treturn -ENOMEM;\n\n\t \n\tpctl->grp_names = devm_kcalloc(&pdev->dev, pctl->ngroups,\n\t\t\t\t       sizeof(*pctl->grp_names), GFP_KERNEL);\n\tif (!pctl->grp_names)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < pctl->devdata->npins; i++) {\n\t\tconst struct mtk_desc_pin *pin = pctl->devdata->pins + i;\n\t\tstruct mtk_pinctrl_group *group = pctl->groups + i;\n\n\t\tgroup->name = pin->pin.name;\n\t\tgroup->pin = pin->pin.number;\n\n\t\tpctl->grp_names[i] = pin->pin.name;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nmtk_xt_get_gpio_n(void *data, unsigned long eint_n, unsigned int *gpio_n,\n\t\t  struct gpio_chip **gpio_chip)\n{\n\tstruct mtk_pinctrl *pctl = (struct mtk_pinctrl *)data;\n\tconst struct mtk_desc_pin *pin;\n\n\tpin = mtk_find_pin_by_eint_num(pctl, eint_n);\n\tif (!pin)\n\t\treturn -EINVAL;\n\n\t*gpio_chip = pctl->chip;\n\t*gpio_n = pin->pin.number;\n\n\treturn 0;\n}\n\nstatic int mtk_xt_get_gpio_state(void *data, unsigned long eint_n)\n{\n\tstruct mtk_pinctrl *pctl = (struct mtk_pinctrl *)data;\n\tconst struct mtk_desc_pin *pin;\n\n\tpin = mtk_find_pin_by_eint_num(pctl, eint_n);\n\tif (!pin)\n\t\treturn -EINVAL;\n\n\treturn mtk_gpio_get(pctl->chip, pin->pin.number);\n}\n\nstatic int mtk_xt_set_gpio_as_eint(void *data, unsigned long eint_n)\n{\n\tstruct mtk_pinctrl *pctl = (struct mtk_pinctrl *)data;\n\tconst struct mtk_desc_pin *pin;\n\n\tpin = mtk_find_pin_by_eint_num(pctl, eint_n);\n\tif (!pin)\n\t\treturn -EINVAL;\n\n\t \n\tmtk_pmx_set_mode(pctl->pctl_dev, pin->pin.number, pin->eint.eintmux);\n\t \n\tmtk_pmx_gpio_set_direction(pctl->pctl_dev, NULL, pin->pin.number,\n\t\t\t\t   true);\n\t \n\tmtk_pconf_set_ies_smt(pctl, pin->pin.number, 1,\n\t\t\t      PIN_CONFIG_INPUT_ENABLE);\n\n\treturn 0;\n}\n\nstatic const struct mtk_eint_xt mtk_eint_xt = {\n\t.get_gpio_n = mtk_xt_get_gpio_n,\n\t.get_gpio_state = mtk_xt_get_gpio_state,\n\t.set_gpio_as_eint = mtk_xt_set_gpio_as_eint,\n};\n\nstatic int mtk_eint_init(struct mtk_pinctrl *pctl, struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\n\tif (!of_property_read_bool(np, \"interrupt-controller\"))\n\t\treturn -ENODEV;\n\n\tpctl->eint = devm_kzalloc(pctl->dev, sizeof(*pctl->eint), GFP_KERNEL);\n\tif (!pctl->eint)\n\t\treturn -ENOMEM;\n\n\tpctl->eint->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(pctl->eint->base))\n\t\treturn PTR_ERR(pctl->eint->base);\n\n\tpctl->eint->irq = irq_of_parse_and_map(np, 0);\n\tif (!pctl->eint->irq)\n\t\treturn -EINVAL;\n\n\tpctl->eint->dev = &pdev->dev;\n\t \n\tpctl->eint->regs = pctl->devdata->eint_regs;\n\tpctl->eint->hw = &pctl->devdata->eint_hw;\n\tpctl->eint->pctl = pctl;\n\tpctl->eint->gpio_xlate = &mtk_eint_xt;\n\n\treturn mtk_eint_do_init(pctl->eint);\n}\n\n \nint mtk_pctrl_init(struct platform_device *pdev,\n\t\tconst struct mtk_pinctrl_devdata *data,\n\t\tstruct regmap *regmap)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct pinctrl_pin_desc *pins;\n\tstruct mtk_pinctrl *pctl;\n\tstruct device_node *np = pdev->dev.of_node, *node;\n\tint ret, i;\n\n\tpctl = devm_kzalloc(&pdev->dev, sizeof(*pctl), GFP_KERNEL);\n\tif (!pctl)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, pctl);\n\n\tnode = of_parse_phandle(np, \"mediatek,pctl-regmap\", 0);\n\tif (node) {\n\t\tpctl->regmap1 = syscon_node_to_regmap(node);\n\t\tof_node_put(node);\n\t\tif (IS_ERR(pctl->regmap1))\n\t\t\treturn PTR_ERR(pctl->regmap1);\n\t} else if (regmap) {\n\t\tpctl->regmap1  = regmap;\n\t} else {\n\t\treturn dev_err_probe(dev, -EINVAL, \"Cannot find pinctrl regmap.\\n\");\n\t}\n\n\t \n\tnode = of_parse_phandle(np, \"mediatek,pctl-regmap\", 1);\n\tif (node) {\n\t\tpctl->regmap2 = syscon_node_to_regmap(node);\n\t\tof_node_put(node);\n\t\tif (IS_ERR(pctl->regmap2))\n\t\t\treturn PTR_ERR(pctl->regmap2);\n\t}\n\n\tpctl->devdata = data;\n\tret = mtk_pctrl_build_state(pdev);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"build state failed\\n\");\n\n\tpins = devm_kcalloc(&pdev->dev, pctl->devdata->npins, sizeof(*pins),\n\t\t\t    GFP_KERNEL);\n\tif (!pins)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < pctl->devdata->npins; i++)\n\t\tpins[i] = pctl->devdata->pins[i].pin;\n\n\tpctl->pctl_desc.name = dev_name(&pdev->dev);\n\tpctl->pctl_desc.owner = THIS_MODULE;\n\tpctl->pctl_desc.pins = pins;\n\tpctl->pctl_desc.npins = pctl->devdata->npins;\n\tpctl->pctl_desc.confops = &mtk_pconf_ops;\n\tpctl->pctl_desc.pctlops = &mtk_pctrl_ops;\n\tpctl->pctl_desc.pmxops = &mtk_pmx_ops;\n\tpctl->dev = &pdev->dev;\n\n\tpctl->pctl_dev = devm_pinctrl_register(&pdev->dev, &pctl->pctl_desc,\n\t\t\t\t\t       pctl);\n\tif (IS_ERR(pctl->pctl_dev))\n\t\treturn dev_err_probe(dev, PTR_ERR(pctl->pctl_dev),\n\t\t\t\t     \"Couldn't register pinctrl driver\\n\");\n\n\tpctl->chip = devm_kzalloc(&pdev->dev, sizeof(*pctl->chip), GFP_KERNEL);\n\tif (!pctl->chip)\n\t\treturn -ENOMEM;\n\n\t*pctl->chip = mtk_gpio_chip;\n\tpctl->chip->ngpio = pctl->devdata->npins;\n\tpctl->chip->label = dev_name(&pdev->dev);\n\tpctl->chip->parent = &pdev->dev;\n\tpctl->chip->base = -1;\n\n\tret = gpiochip_add_data(pctl->chip, pctl);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\t \n\tret = gpiochip_add_pin_range(pctl->chip, dev_name(&pdev->dev),\n\t\t\t0, 0, pctl->devdata->npins);\n\tif (ret) {\n\t\tret = -EINVAL;\n\t\tgoto chip_error;\n\t}\n\n\tret = mtk_eint_init(pctl, pdev);\n\tif (ret)\n\t\tgoto chip_error;\n\n\treturn 0;\n\nchip_error:\n\tgpiochip_remove(pctl->chip);\n\treturn ret;\n}\n\nint mtk_pctrl_common_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tconst struct mtk_pinctrl_devdata *data = device_get_match_data(dev);\n\n\tif (!data)\n\t\treturn -ENODEV;\n\n\treturn mtk_pctrl_init(pdev, data, NULL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}