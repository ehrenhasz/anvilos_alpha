{
  "module_name": "pinctrl-mtmips.c",
  "hash_id": "8c60f02b13ee565fdfae966abab76c156619378a7e6c47941fbdcd0eb276c8a8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/mediatek/pinctrl-mtmips.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinconf-generic.h>\n#include <linux/pinctrl/pinmux.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/pinctrl/machine.h>\n\n#include <asm/mach-ralink/ralink_regs.h>\n#include <asm/mach-ralink/mt7620.h>\n\n#include \"pinctrl-mtmips.h\"\n#include \"../core.h\"\n#include \"../pinctrl-utils.h\"\n\n#define SYSC_REG_GPIO_MODE\t0x60\n#define SYSC_REG_GPIO_MODE2\t0x64\n\nstruct mtmips_priv {\n\tstruct device *dev;\n\n\tstruct pinctrl_pin_desc *pads;\n\tstruct pinctrl_desc *desc;\n\n\tstruct mtmips_pmx_func **func;\n\tint func_count;\n\n\tstruct mtmips_pmx_group *groups;\n\tconst char **group_names;\n\tint group_count;\n\n\tu8 *gpio;\n\tint max_pins;\n};\n\nstatic int mtmips_get_group_count(struct pinctrl_dev *pctrldev)\n{\n\tstruct mtmips_priv *p = pinctrl_dev_get_drvdata(pctrldev);\n\n\treturn p->group_count;\n}\n\nstatic const char *mtmips_get_group_name(struct pinctrl_dev *pctrldev,\n\t\t\t\t\t unsigned int group)\n{\n\tstruct mtmips_priv *p = pinctrl_dev_get_drvdata(pctrldev);\n\n\treturn (group >= p->group_count) ? NULL : p->group_names[group];\n}\n\nstatic int mtmips_get_group_pins(struct pinctrl_dev *pctrldev,\n\t\t\t\t unsigned int group,\n\t\t\t\t const unsigned int **pins,\n\t\t\t\t unsigned int *num_pins)\n{\n\tstruct mtmips_priv *p = pinctrl_dev_get_drvdata(pctrldev);\n\n\tif (group >= p->group_count)\n\t\treturn -EINVAL;\n\n\t*pins = p->groups[group].func[0].pins;\n\t*num_pins = p->groups[group].func[0].pin_count;\n\n\treturn 0;\n}\n\nstatic const struct pinctrl_ops mtmips_pctrl_ops = {\n\t.get_groups_count\t= mtmips_get_group_count,\n\t.get_group_name\t\t= mtmips_get_group_name,\n\t.get_group_pins\t\t= mtmips_get_group_pins,\n\t.dt_node_to_map\t\t= pinconf_generic_dt_node_to_map_all,\n\t.dt_free_map\t\t= pinconf_generic_dt_free_map,\n};\n\nstatic int mtmips_pmx_func_count(struct pinctrl_dev *pctrldev)\n{\n\tstruct mtmips_priv *p = pinctrl_dev_get_drvdata(pctrldev);\n\n\treturn p->func_count;\n}\n\nstatic const char *mtmips_pmx_func_name(struct pinctrl_dev *pctrldev,\n\t\t\t\t\tunsigned int func)\n{\n\tstruct mtmips_priv *p = pinctrl_dev_get_drvdata(pctrldev);\n\n\treturn p->func[func]->name;\n}\n\nstatic int mtmips_pmx_group_get_groups(struct pinctrl_dev *pctrldev,\n\t\t\t\t       unsigned int func,\n\t\t\t\t       const char * const **groups,\n\t\t\t\t       unsigned int * const num_groups)\n{\n\tstruct mtmips_priv *p = pinctrl_dev_get_drvdata(pctrldev);\n\n\tif (p->func[func]->group_count == 1)\n\t\t*groups = &p->group_names[p->func[func]->groups[0]];\n\telse\n\t\t*groups = p->group_names;\n\n\t*num_groups = p->func[func]->group_count;\n\n\treturn 0;\n}\n\nstatic int mtmips_pmx_group_enable(struct pinctrl_dev *pctrldev,\n\t\t\t\t   unsigned int func, unsigned int group)\n{\n\tstruct mtmips_priv *p = pinctrl_dev_get_drvdata(pctrldev);\n\tu32 mode = 0;\n\tu32 reg = SYSC_REG_GPIO_MODE;\n\tint i;\n\tint shift;\n\n\t \n\tif (p->groups[group].enabled) {\n\t\tdev_err(p->dev, \"%s is already enabled\\n\",\n\t\t\tp->groups[group].name);\n\t\treturn 0;\n\t}\n\n\tp->groups[group].enabled = 1;\n\tp->func[func]->enabled = 1;\n\n\tshift = p->groups[group].shift;\n\tif (shift >= 32) {\n\t\tshift -= 32;\n\t\treg = SYSC_REG_GPIO_MODE2;\n\t}\n\tmode = rt_sysc_r32(reg);\n\tmode &= ~(p->groups[group].mask << shift);\n\n\t \n\tfor (i = 0; i < p->groups[group].func[0].pin_count; i++)\n\t\tp->gpio[p->groups[group].func[0].pins[i]] = 1;\n\n\t \n\tif (func == 0) {\n\t\tmode |= p->groups[group].gpio << shift;\n\t} else {\n\t\tfor (i = 0; i < p->func[func]->pin_count; i++)\n\t\t\tp->gpio[p->func[func]->pins[i]] = 0;\n\t\tmode |= p->func[func]->value << shift;\n\t}\n\trt_sysc_w32(mode, reg);\n\n\treturn 0;\n}\n\nstatic int mtmips_pmx_group_gpio_request_enable(struct pinctrl_dev *pctrldev,\n\t\t\t\t\t\tstruct pinctrl_gpio_range *range,\n\t\t\t\t\t\tunsigned int pin)\n{\n\tstruct mtmips_priv *p = pinctrl_dev_get_drvdata(pctrldev);\n\n\tif (!p->gpio[pin]) {\n\t\tdev_err(p->dev, \"pin %d is not set to gpio mux\\n\", pin);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct pinmux_ops mtmips_pmx_group_ops = {\n\t.get_functions_count\t= mtmips_pmx_func_count,\n\t.get_function_name\t= mtmips_pmx_func_name,\n\t.get_function_groups\t= mtmips_pmx_group_get_groups,\n\t.set_mux\t\t= mtmips_pmx_group_enable,\n\t.gpio_request_enable\t= mtmips_pmx_group_gpio_request_enable,\n};\n\nstatic struct pinctrl_desc mtmips_pctrl_desc = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"mtmips-pinctrl\",\n\t.pctlops\t= &mtmips_pctrl_ops,\n\t.pmxops\t\t= &mtmips_pmx_group_ops,\n};\n\nstatic struct mtmips_pmx_func gpio_func = {\n\t.name = \"gpio\",\n};\n\nstatic int mtmips_pinctrl_index(struct mtmips_priv *p)\n{\n\tstruct mtmips_pmx_group *mux = p->groups;\n\tint i, j, c = 0;\n\n\t \n\twhile (mux->name) {\n\t\tp->group_count++;\n\t\tmux++;\n\t}\n\n\t \n\tp->group_names = devm_kcalloc(p->dev, p->group_count,\n\t\t\t\t      sizeof(char *), GFP_KERNEL);\n\tif (!p->group_names)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < p->group_count; i++) {\n\t\tp->group_names[i] = p->groups[i].name;\n\t\tp->func_count += p->groups[i].func_count;\n\t}\n\n\t \n\tp->func_count++;\n\n\t \n\tp->func = devm_kcalloc(p->dev, p->func_count,\n\t\t\t       sizeof(*p->func), GFP_KERNEL);\n\tgpio_func.groups = devm_kcalloc(p->dev, p->group_count, sizeof(int),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!p->func || !gpio_func.groups)\n\t\treturn -ENOMEM;\n\n\t \n\tgpio_func.group_count = p->group_count;\n\tfor (i = 0; i < gpio_func.group_count; i++)\n\t\tgpio_func.groups[i] = i;\n\n\tp->func[c] = &gpio_func;\n\tc++;\n\n\t \n\tfor (i = 0; i < p->group_count; i++) {\n\t\tfor (j = 0; j < p->groups[i].func_count; j++) {\n\t\t\tp->func[c] = &p->groups[i].func[j];\n\t\t\tp->func[c]->groups = devm_kzalloc(p->dev, sizeof(int),\n\t\t\t\t\t\t    GFP_KERNEL);\n\t\t\tif (!p->func[c]->groups)\n\t\t\t\treturn -ENOMEM;\n\t\t\tp->func[c]->groups[0] = i;\n\t\t\tp->func[c]->group_count = 1;\n\t\t\tc++;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int mtmips_pinctrl_pins(struct mtmips_priv *p)\n{\n\tint i, j;\n\n\t \n\tfor (i = 0; i < p->func_count; i++) {\n\t\tint pin;\n\n\t\tif (!p->func[i]->pin_count)\n\t\t\tcontinue;\n\n\t\tp->func[i]->pins = devm_kcalloc(p->dev,\n\t\t\t\t\t\tp->func[i]->pin_count,\n\t\t\t\t\t\tsizeof(int),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!p->func[i]->pins)\n\t\t\treturn -ENOMEM;\n\t\tfor (j = 0; j < p->func[i]->pin_count; j++)\n\t\t\tp->func[i]->pins[j] = p->func[i]->pin_first + j;\n\n\t\tpin = p->func[i]->pin_first + p->func[i]->pin_count;\n\t\tif (pin > p->max_pins)\n\t\t\tp->max_pins = pin;\n\t}\n\n\t \n\tp->gpio = devm_kcalloc(p->dev, p->max_pins, sizeof(u8), GFP_KERNEL);\n\t \n\tp->pads = devm_kcalloc(p->dev, p->max_pins,\n\t\t\t       sizeof(struct pinctrl_pin_desc), GFP_KERNEL);\n\tif (!p->pads || !p->gpio)\n\t\treturn -ENOMEM;\n\n\tmemset(p->gpio, 1, sizeof(u8) * p->max_pins);\n\tfor (i = 0; i < p->func_count; i++) {\n\t\tif (!p->func[i]->pin_count)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < p->func[i]->pin_count; j++)\n\t\t\tp->gpio[p->func[i]->pins[j]] = 0;\n\t}\n\n\t \n\tp->gpio[0] = 1;\n\n\t \n\tfor (i = 0; i < p->max_pins; i++) {\n\t\t \n\t\tchar *name = devm_kzalloc(p->dev, 5, GFP_KERNEL);\n\n\t\tif (!name)\n\t\t\treturn -ENOMEM;\n\t\tsnprintf(name, 5, \"io%d\", i);\n\t\tp->pads[i].number = i;\n\t\tp->pads[i].name = name;\n\t}\n\tp->desc->pins = p->pads;\n\tp->desc->npins = p->max_pins;\n\n\treturn 0;\n}\n\nint mtmips_pinctrl_init(struct platform_device *pdev,\n\t\t\tstruct mtmips_pmx_group *data)\n{\n\tstruct mtmips_priv *p;\n\tstruct pinctrl_dev *dev;\n\tint err;\n\n\tif (!data)\n\t\treturn -ENOTSUPP;\n\n\t \n\tp = devm_kzalloc(&pdev->dev, sizeof(struct mtmips_priv), GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tp->dev = &pdev->dev;\n\tp->desc = &mtmips_pctrl_desc;\n\tp->groups = data;\n\tplatform_set_drvdata(pdev, p);\n\n\t \n\terr = mtmips_pinctrl_index(p);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to load index\\n\");\n\t\treturn err;\n\t}\n\n\terr = mtmips_pinctrl_pins(p);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to load pins\\n\");\n\t\treturn err;\n\t}\n\tdev = pinctrl_register(p->desc, &pdev->dev, p);\n\n\treturn PTR_ERR_OR_ZERO(dev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}