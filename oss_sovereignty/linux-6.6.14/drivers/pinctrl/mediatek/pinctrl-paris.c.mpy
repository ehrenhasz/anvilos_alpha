{
  "module_name": "pinctrl-paris.c",
  "hash_id": "cabe67fdea6bb3cd55a2d32fbbad2a2eb0b9f8b926c80a834c2962b6a0ffd476",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/mediatek/pinctrl-paris.c",
  "human_readable_source": "\n \n\n#include <linux/gpio/driver.h>\n#include <linux/module.h>\n#include <linux/seq_file.h>\n\n#include <linux/pinctrl/consumer.h>\n\n#include <dt-bindings/pinctrl/mt65xx.h>\n\n#include \"pinctrl-paris.h\"\n\n#define PINCTRL_PINCTRL_DEV\tKBUILD_MODNAME\n\n \n#define MTK_PIN_CONFIG_TDSEL\t(PIN_CONFIG_END + 1)\n#define MTK_PIN_CONFIG_RDSEL\t(PIN_CONFIG_END + 2)\n#define MTK_PIN_CONFIG_PU_ADV\t(PIN_CONFIG_END + 3)\n#define MTK_PIN_CONFIG_PD_ADV\t(PIN_CONFIG_END + 4)\n#define MTK_PIN_CONFIG_DRV_ADV\t(PIN_CONFIG_END + 5)\n\nstatic const struct pinconf_generic_params mtk_custom_bindings[] = {\n\t{\"mediatek,tdsel\",\tMTK_PIN_CONFIG_TDSEL,\t\t0},\n\t{\"mediatek,rdsel\",\tMTK_PIN_CONFIG_RDSEL,\t\t0},\n\t{\"mediatek,pull-up-adv\", MTK_PIN_CONFIG_PU_ADV,\t\t1},\n\t{\"mediatek,pull-down-adv\", MTK_PIN_CONFIG_PD_ADV,\t1},\n\t{\"mediatek,drive-strength-adv\", MTK_PIN_CONFIG_DRV_ADV,\t2},\n};\n\n#ifdef CONFIG_DEBUG_FS\nstatic const struct pin_config_item mtk_conf_items[] = {\n\tPCONFDUMP(MTK_PIN_CONFIG_TDSEL, \"tdsel\", NULL, true),\n\tPCONFDUMP(MTK_PIN_CONFIG_RDSEL, \"rdsel\", NULL, true),\n\tPCONFDUMP(MTK_PIN_CONFIG_PU_ADV, \"pu-adv\", NULL, true),\n\tPCONFDUMP(MTK_PIN_CONFIG_PD_ADV, \"pd-adv\", NULL, true),\n\tPCONFDUMP(MTK_PIN_CONFIG_DRV_ADV, \"drive-strength-adv\", NULL, true),\n};\n#endif\n\nstatic const char * const mtk_gpio_functions[] = {\n\t\"func0\", \"func1\", \"func2\", \"func3\",\n\t\"func4\", \"func5\", \"func6\", \"func7\",\n\t\"func8\", \"func9\", \"func10\", \"func11\",\n\t\"func12\", \"func13\", \"func14\", \"func15\",\n};\n\n \nstatic const int mtk_drv_adv_uA[] = { 125, 250, 500, 1000 };\n\nstatic int mtk_drv_adv_to_uA(int val)\n{\n\t \n\tif (WARN_ON_ONCE(val < 0 || val > 7))\n\t\treturn -EINVAL;\n\n\t \n\tif (!(val & BIT(0)))\n\t\treturn -EINVAL;\n\n\treturn mtk_drv_adv_uA[(val >> 1)];\n}\n\nstatic int mtk_drv_uA_to_adv(int val)\n{\n\tswitch (val) {\n\tcase 125:\n\t\treturn 0x1;\n\tcase 250:\n\t\treturn 0x3;\n\tcase 500:\n\t\treturn 0x5;\n\tcase 1000:\n\t\treturn 0x7;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int mtk_pinmux_gpio_request_enable(struct pinctrl_dev *pctldev,\n\t\t\t\t\t  struct pinctrl_gpio_range *range,\n\t\t\t\t\t  unsigned int pin)\n{\n\tstruct mtk_pinctrl *hw = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct mtk_pin_desc *desc;\n\n\tdesc = (const struct mtk_pin_desc *)&hw->soc->pins[pin];\n\n\treturn mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_MODE,\n\t\t\t\thw->soc->gpio_m);\n}\n\nstatic int mtk_pinmux_gpio_set_direction(struct pinctrl_dev *pctldev,\n\t\t\t\t\t struct pinctrl_gpio_range *range,\n\t\t\t\t\t unsigned int pin, bool input)\n{\n\tstruct mtk_pinctrl *hw = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct mtk_pin_desc *desc;\n\n\tdesc = (const struct mtk_pin_desc *)&hw->soc->pins[pin];\n\n\t \n\treturn mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_DIR, !input);\n}\n\nstatic int mtk_pinconf_get(struct pinctrl_dev *pctldev,\n\t\t\t   unsigned int pin, unsigned long *config)\n{\n\tstruct mtk_pinctrl *hw = pinctrl_dev_get_drvdata(pctldev);\n\tu32 param = pinconf_to_config_param(*config);\n\tint pullup, reg, err = -ENOTSUPP, ret = 1;\n\tconst struct mtk_pin_desc *desc;\n\n\tif (pin >= hw->soc->npins)\n\t\treturn -EINVAL;\n\n\tdesc = (const struct mtk_pin_desc *)&hw->soc->pins[pin];\n\n\tswitch (param) {\n\tcase PIN_CONFIG_BIAS_DISABLE:\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\tif (!hw->soc->bias_get_combo)\n\t\t\tbreak;\n\t\terr = hw->soc->bias_get_combo(hw, desc, &pullup, &ret);\n\t\tif (err)\n\t\t\tbreak;\n\t\tif (ret == MTK_PUPD_SET_R1R0_00)\n\t\t\tret = MTK_DISABLE;\n\t\tif (param == PIN_CONFIG_BIAS_DISABLE) {\n\t\t\tif (ret != MTK_DISABLE)\n\t\t\t\terr = -EINVAL;\n\t\t} else if (param == PIN_CONFIG_BIAS_PULL_UP) {\n\t\t\tif (!pullup || ret == MTK_DISABLE)\n\t\t\t\terr = -EINVAL;\n\t\t} else if (param == PIN_CONFIG_BIAS_PULL_DOWN) {\n\t\t\tif (pullup || ret == MTK_DISABLE)\n\t\t\t\terr = -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase PIN_CONFIG_SLEW_RATE:\n\t\terr = mtk_hw_get_value(hw, desc, PINCTRL_PIN_REG_SR, &ret);\n\t\tbreak;\n\tcase PIN_CONFIG_INPUT_ENABLE:\n\tcase PIN_CONFIG_OUTPUT_ENABLE:\n\t\terr = mtk_hw_get_value(hw, desc, PINCTRL_PIN_REG_DIR, &ret);\n\t\tif (err)\n\t\t\tbreak;\n\t\t \n\t\tif (param == PIN_CONFIG_INPUT_ENABLE)\n\t\t\tret = !ret;\n\n\t\tbreak;\n\tcase PIN_CONFIG_INPUT_SCHMITT_ENABLE:\n\t\terr = mtk_hw_get_value(hw, desc, PINCTRL_PIN_REG_DIR, &ret);\n\t\tif (err)\n\t\t\tbreak;\n\t\t \n\t\tif (ret) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\terr = mtk_hw_get_value(hw, desc, PINCTRL_PIN_REG_SMT, &ret);\n\t\tbreak;\n\tcase PIN_CONFIG_DRIVE_STRENGTH:\n\t\tif (!hw->soc->drive_get)\n\t\t\tbreak;\n\n\t\tif (hw->soc->adv_drive_get) {\n\t\t\terr = hw->soc->adv_drive_get(hw, desc, &ret);\n\t\t\tif (!err) {\n\t\t\t\terr = mtk_drv_adv_to_uA(ret);\n\t\t\t\tif (err > 0) {\n\t\t\t\t\t \n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\terr = hw->soc->drive_get(hw, desc, &ret);\n\t\tbreak;\n\tcase PIN_CONFIG_DRIVE_STRENGTH_UA:\n\t\tif (!hw->soc->adv_drive_get)\n\t\t\tbreak;\n\n\t\terr = hw->soc->adv_drive_get(hw, desc, &ret);\n\t\tif (err)\n\t\t\tbreak;\n\t\terr = mtk_drv_adv_to_uA(ret);\n\t\tif (err < 0)\n\t\t\tbreak;\n\n\t\tret = err;\n\t\terr = 0;\n\t\tbreak;\n\tcase MTK_PIN_CONFIG_TDSEL:\n\tcase MTK_PIN_CONFIG_RDSEL:\n\t\treg = (param == MTK_PIN_CONFIG_TDSEL) ?\n\t\t       PINCTRL_PIN_REG_TDSEL : PINCTRL_PIN_REG_RDSEL;\n\t\terr = mtk_hw_get_value(hw, desc, reg, &ret);\n\t\tbreak;\n\tcase MTK_PIN_CONFIG_PU_ADV:\n\tcase MTK_PIN_CONFIG_PD_ADV:\n\t\tif (!hw->soc->adv_pull_get)\n\t\t\tbreak;\n\t\tpullup = param == MTK_PIN_CONFIG_PU_ADV;\n\t\terr = hw->soc->adv_pull_get(hw, desc, pullup, &ret);\n\t\tbreak;\n\tcase MTK_PIN_CONFIG_DRV_ADV:\n\t\tif (!hw->soc->adv_drive_get)\n\t\t\tbreak;\n\t\terr = hw->soc->adv_drive_get(hw, desc, &ret);\n\t\tbreak;\n\t}\n\n\tif (!err)\n\t\t*config = pinconf_to_config_packed(param, ret);\n\n\treturn err;\n}\n\nstatic int mtk_pinconf_set(struct pinctrl_dev *pctldev, unsigned int pin,\n\t\t\t   enum pin_config_param param, u32 arg)\n{\n\tstruct mtk_pinctrl *hw = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct mtk_pin_desc *desc;\n\tint err = -ENOTSUPP;\n\tu32 reg;\n\n\tif (pin >= hw->soc->npins)\n\t\treturn -EINVAL;\n\n\tdesc = (const struct mtk_pin_desc *)&hw->soc->pins[pin];\n\n\tswitch ((u32)param) {\n\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\tif (!hw->soc->bias_set_combo)\n\t\t\tbreak;\n\t\terr = hw->soc->bias_set_combo(hw, desc, 0, MTK_DISABLE);\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\tif (!hw->soc->bias_set_combo)\n\t\t\tbreak;\n\t\terr = hw->soc->bias_set_combo(hw, desc, 1, arg);\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\tif (!hw->soc->bias_set_combo)\n\t\t\tbreak;\n\t\terr = hw->soc->bias_set_combo(hw, desc, 0, arg);\n\t\tbreak;\n\tcase PIN_CONFIG_OUTPUT_ENABLE:\n\t\terr = mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_SMT,\n\t\t\t\t       MTK_DISABLE);\n\t\t \n\t\tif (err != -ENOTSUPP)\n\t\t\tbreak;\n\n\t\terr = mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_DIR,\n\t\t\t\t       MTK_OUTPUT);\n\t\tbreak;\n\tcase PIN_CONFIG_INPUT_ENABLE:\n\t\t \n\t\terr = mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_IES, !!arg);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\terr = mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_DIR,\n\t\t\t\t       MTK_INPUT);\n\t\tbreak;\n\tcase PIN_CONFIG_SLEW_RATE:\n\t\t \n\t\terr = mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_SR, !!arg);\n\t\tbreak;\n\tcase PIN_CONFIG_OUTPUT:\n\t\terr = mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_DO,\n\t\t\t\t       arg);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\terr = mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_DIR,\n\t\t\t\t       MTK_OUTPUT);\n\t\tbreak;\n\tcase PIN_CONFIG_INPUT_SCHMITT:\n\tcase PIN_CONFIG_INPUT_SCHMITT_ENABLE:\n\t\t \n\t\terr = mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_DIR, !arg);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\terr = mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_SMT, !!arg);\n\t\tbreak;\n\tcase PIN_CONFIG_DRIVE_STRENGTH:\n\t\tif (!hw->soc->drive_set)\n\t\t\tbreak;\n\t\terr = hw->soc->drive_set(hw, desc, arg);\n\t\tbreak;\n\tcase PIN_CONFIG_DRIVE_STRENGTH_UA:\n\t\tif (!hw->soc->adv_drive_set)\n\t\t\tbreak;\n\n\t\terr = mtk_drv_uA_to_adv(arg);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t\terr = hw->soc->adv_drive_set(hw, desc, err);\n\t\tbreak;\n\tcase MTK_PIN_CONFIG_TDSEL:\n\tcase MTK_PIN_CONFIG_RDSEL:\n\t\treg = (param == MTK_PIN_CONFIG_TDSEL) ?\n\t\t       PINCTRL_PIN_REG_TDSEL : PINCTRL_PIN_REG_RDSEL;\n\t\terr = mtk_hw_set_value(hw, desc, reg, arg);\n\t\tbreak;\n\tcase MTK_PIN_CONFIG_PU_ADV:\n\tcase MTK_PIN_CONFIG_PD_ADV:\n\t\tif (!hw->soc->adv_pull_set)\n\t\t\tbreak;\n\t\terr = hw->soc->adv_pull_set(hw, desc,\n\t\t\t\t\t    (param == MTK_PIN_CONFIG_PU_ADV),\n\t\t\t\t\t    arg);\n\t\tbreak;\n\tcase MTK_PIN_CONFIG_DRV_ADV:\n\t\tif (!hw->soc->adv_drive_set)\n\t\t\tbreak;\n\t\terr = hw->soc->adv_drive_set(hw, desc, arg);\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic struct mtk_pinctrl_group *\nmtk_pctrl_find_group_by_pin(struct mtk_pinctrl *hw, u32 pin)\n{\n\tint i;\n\n\tfor (i = 0; i < hw->soc->ngrps; i++) {\n\t\tstruct mtk_pinctrl_group *grp = hw->groups + i;\n\n\t\tif (grp->pin == pin)\n\t\t\treturn grp;\n\t}\n\n\treturn NULL;\n}\n\nstatic const struct mtk_func_desc *\nmtk_pctrl_find_function_by_pin(struct mtk_pinctrl *hw, u32 pin_num, u32 fnum)\n{\n\tconst struct mtk_pin_desc *pin = hw->soc->pins + pin_num;\n\tconst struct mtk_func_desc *func = pin->funcs;\n\n\twhile (func && func->name) {\n\t\tif (func->muxval == fnum)\n\t\t\treturn func;\n\t\tfunc++;\n\t}\n\n\treturn NULL;\n}\n\nstatic bool mtk_pctrl_is_function_valid(struct mtk_pinctrl *hw, u32 pin_num,\n\t\t\t\t\tu32 fnum)\n{\n\tint i;\n\n\tfor (i = 0; i < hw->soc->npins; i++) {\n\t\tconst struct mtk_pin_desc *pin = hw->soc->pins + i;\n\n\t\tif (pin->number == pin_num) {\n\t\t\tconst struct mtk_func_desc *func = pin->funcs;\n\n\t\t\twhile (func && func->name) {\n\t\t\t\tif (func->muxval == fnum)\n\t\t\t\t\treturn true;\n\t\t\t\tfunc++;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic int mtk_pctrl_dt_node_to_map_func(struct mtk_pinctrl *pctl,\n\t\t\t\t\t u32 pin, u32 fnum,\n\t\t\t\t\t struct mtk_pinctrl_group *grp,\n\t\t\t\t\t struct pinctrl_map **map,\n\t\t\t\t\t unsigned *reserved_maps,\n\t\t\t\t\t unsigned *num_maps)\n{\n\tbool ret;\n\n\tif (*num_maps == *reserved_maps)\n\t\treturn -ENOSPC;\n\n\t(*map)[*num_maps].type = PIN_MAP_TYPE_MUX_GROUP;\n\t(*map)[*num_maps].data.mux.group = grp->name;\n\n\tret = mtk_pctrl_is_function_valid(pctl, pin, fnum);\n\tif (!ret) {\n\t\tdev_err(pctl->dev, \"invalid function %d on pin %d .\\n\",\n\t\t\tfnum, pin);\n\t\treturn -EINVAL;\n\t}\n\n\t(*map)[*num_maps].data.mux.function = mtk_gpio_functions[fnum];\n\t(*num_maps)++;\n\n\treturn 0;\n}\n\nstatic int mtk_pctrl_dt_subnode_to_map(struct pinctrl_dev *pctldev,\n\t\t\t\t       struct device_node *node,\n\t\t\t\t       struct pinctrl_map **map,\n\t\t\t\t       unsigned *reserved_maps,\n\t\t\t\t       unsigned *num_maps)\n{\n\tstruct mtk_pinctrl *hw = pinctrl_dev_get_drvdata(pctldev);\n\tint num_pins, num_funcs, maps_per_pin, i, err;\n\tstruct mtk_pinctrl_group *grp;\n\tunsigned int num_configs;\n\tbool has_config = false;\n\tunsigned long *configs;\n\tu32 pinfunc, pin, func;\n\tstruct property *pins;\n\tunsigned reserve = 0;\n\n\tpins = of_find_property(node, \"pinmux\", NULL);\n\tif (!pins) {\n\t\tdev_err(hw->dev, \"missing pins property in node %pOFn .\\n\",\n\t\t\tnode);\n\t\treturn -EINVAL;\n\t}\n\n\terr = pinconf_generic_parse_dt_config(node, pctldev, &configs,\n\t\t\t\t\t      &num_configs);\n\tif (err)\n\t\treturn err;\n\n\tif (num_configs)\n\t\thas_config = true;\n\n\tnum_pins = pins->length / sizeof(u32);\n\tnum_funcs = num_pins;\n\tmaps_per_pin = 0;\n\tif (num_funcs)\n\t\tmaps_per_pin++;\n\tif (has_config && num_pins >= 1)\n\t\tmaps_per_pin++;\n\n\tif (!num_pins || !maps_per_pin) {\n\t\terr = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\treserve = num_pins * maps_per_pin;\n\n\terr = pinctrl_utils_reserve_map(pctldev, map, reserved_maps, num_maps,\n\t\t\t\t\treserve);\n\tif (err < 0)\n\t\tgoto exit;\n\n\tfor (i = 0; i < num_pins; i++) {\n\t\terr = of_property_read_u32_index(node, \"pinmux\", i, &pinfunc);\n\t\tif (err)\n\t\t\tgoto exit;\n\n\t\tpin = MTK_GET_PIN_NO(pinfunc);\n\t\tfunc = MTK_GET_PIN_FUNC(pinfunc);\n\n\t\tif (pin >= hw->soc->npins ||\n\t\t    func >= ARRAY_SIZE(mtk_gpio_functions)) {\n\t\t\tdev_err(hw->dev, \"invalid pins value.\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tgrp = mtk_pctrl_find_group_by_pin(hw, pin);\n\t\tif (!grp) {\n\t\t\tdev_err(hw->dev, \"unable to match pin %d to group\\n\",\n\t\t\t\tpin);\n\t\t\terr = -EINVAL;\n\t\t\tgoto exit;\n\t\t}\n\n\t\terr = mtk_pctrl_dt_node_to_map_func(hw, pin, func, grp, map,\n\t\t\t\t\t\t    reserved_maps, num_maps);\n\t\tif (err < 0)\n\t\t\tgoto exit;\n\n\t\tif (has_config) {\n\t\t\terr = pinctrl_utils_add_map_configs(pctldev, map,\n\t\t\t\t\t\t\t    reserved_maps,\n\t\t\t\t\t\t\t    num_maps,\n\t\t\t\t\t\t\t    grp->name,\n\t\t\t\t\t\t\t    configs,\n\t\t\t\t\t\t\t    num_configs,\n\t\t\t\t\t\t\t    PIN_MAP_TYPE_CONFIGS_GROUP);\n\t\t\tif (err < 0)\n\t\t\t\tgoto exit;\n\t\t}\n\t}\n\n\terr = 0;\n\nexit:\n\tkfree(configs);\n\treturn err;\n}\n\nstatic int mtk_pctrl_dt_node_to_map(struct pinctrl_dev *pctldev,\n\t\t\t\t    struct device_node *np_config,\n\t\t\t\t    struct pinctrl_map **map,\n\t\t\t\t    unsigned *num_maps)\n{\n\tstruct device_node *np;\n\tunsigned reserved_maps;\n\tint ret;\n\n\t*map = NULL;\n\t*num_maps = 0;\n\treserved_maps = 0;\n\n\tfor_each_child_of_node(np_config, np) {\n\t\tret = mtk_pctrl_dt_subnode_to_map(pctldev, np, map,\n\t\t\t\t\t\t  &reserved_maps,\n\t\t\t\t\t\t  num_maps);\n\t\tif (ret < 0) {\n\t\t\tpinctrl_utils_free_map(pctldev, *map, *num_maps);\n\t\t\tof_node_put(np);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int mtk_pctrl_get_groups_count(struct pinctrl_dev *pctldev)\n{\n\tstruct mtk_pinctrl *hw = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn hw->soc->ngrps;\n}\n\nstatic const char *mtk_pctrl_get_group_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t    unsigned group)\n{\n\tstruct mtk_pinctrl *hw = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn hw->groups[group].name;\n}\n\nstatic int mtk_pctrl_get_group_pins(struct pinctrl_dev *pctldev,\n\t\t\t\t    unsigned group, const unsigned **pins,\n\t\t\t\t    unsigned *num_pins)\n{\n\tstruct mtk_pinctrl *hw = pinctrl_dev_get_drvdata(pctldev);\n\n\t*pins = (unsigned *)&hw->groups[group].pin;\n\t*num_pins = 1;\n\n\treturn 0;\n}\n\nstatic int mtk_hw_get_value_wrap(struct mtk_pinctrl *hw, unsigned int gpio, int field)\n{\n\tconst struct mtk_pin_desc *desc;\n\tint value, err;\n\n\tif (gpio >= hw->soc->npins)\n\t\treturn -EINVAL;\n\n\tdesc = (const struct mtk_pin_desc *)&hw->soc->pins[gpio];\n\n\terr = mtk_hw_get_value(hw, desc, field, &value);\n\tif (err)\n\t\treturn err;\n\n\treturn value;\n}\n\n#define mtk_pctrl_get_pinmux(hw, gpio)\t\t\t\\\n\tmtk_hw_get_value_wrap(hw, gpio, PINCTRL_PIN_REG_MODE)\n\n#define mtk_pctrl_get_direction(hw, gpio)\t\t\\\n\tmtk_hw_get_value_wrap(hw, gpio, PINCTRL_PIN_REG_DIR)\n\n#define mtk_pctrl_get_out(hw, gpio)\t\t\t\\\n\tmtk_hw_get_value_wrap(hw, gpio, PINCTRL_PIN_REG_DO)\n\n#define mtk_pctrl_get_in(hw, gpio)\t\t\t\\\n\tmtk_hw_get_value_wrap(hw, gpio, PINCTRL_PIN_REG_DI)\n\n#define mtk_pctrl_get_smt(hw, gpio)\t\t\t\\\n\tmtk_hw_get_value_wrap(hw, gpio, PINCTRL_PIN_REG_SMT)\n\n#define mtk_pctrl_get_ies(hw, gpio)\t\t\t\\\n\tmtk_hw_get_value_wrap(hw, gpio, PINCTRL_PIN_REG_IES)\n\n#define mtk_pctrl_get_driving(hw, gpio)\t\t\t\\\n\tmtk_hw_get_value_wrap(hw, gpio, PINCTRL_PIN_REG_DRV)\n\nssize_t mtk_pctrl_show_one_pin(struct mtk_pinctrl *hw,\n\tunsigned int gpio, char *buf, unsigned int buf_len)\n{\n\tint pinmux, pullup = 0, pullen = 0, len = 0, r1 = -1, r0 = -1, rsel = -1;\n\tconst struct mtk_pin_desc *desc;\n\tu32 try_all_type = 0;\n\n\tif (gpio >= hw->soc->npins)\n\t\treturn -EINVAL;\n\n\tif (mtk_is_virt_gpio(hw, gpio))\n\t\treturn -EINVAL;\n\n\tdesc = (const struct mtk_pin_desc *)&hw->soc->pins[gpio];\n\tpinmux = mtk_pctrl_get_pinmux(hw, gpio);\n\tif (pinmux >= hw->soc->nfuncs)\n\t\tpinmux -= hw->soc->nfuncs;\n\n\tmtk_pinconf_bias_get_combo(hw, desc, &pullup, &pullen);\n\n\tif (hw->soc->pull_type)\n\t\ttry_all_type = hw->soc->pull_type[desc->number];\n\n\tif (hw->rsel_si_unit && (try_all_type & MTK_PULL_RSEL_TYPE)) {\n\t\trsel = pullen;\n\t\tpullen = 1;\n\t} else {\n\t\t \n\t\tif (pullen == MTK_PUPD_SET_R1R0_00) {\n\t\t\tpullen = 0;\n\t\t\tr1 = 0;\n\t\t\tr0 = 0;\n\t\t} else if (pullen == MTK_PUPD_SET_R1R0_01) {\n\t\t\tpullen = 1;\n\t\t\tr1 = 0;\n\t\t\tr0 = 1;\n\t\t} else if (pullen == MTK_PUPD_SET_R1R0_10) {\n\t\t\tpullen = 1;\n\t\t\tr1 = 1;\n\t\t\tr0 = 0;\n\t\t} else if (pullen == MTK_PUPD_SET_R1R0_11) {\n\t\t\tpullen = 1;\n\t\t\tr1 = 1;\n\t\t\tr0 = 1;\n\t\t}\n\n\t\t \n\t\tif (pullen >= MTK_PULL_SET_RSEL_000 &&\n\t\t    pullen <= MTK_PULL_SET_RSEL_111) {\n\t\t\trsel = pullen - MTK_PULL_SET_RSEL_000;\n\t\t\tpullen = 1;\n\t\t}\n\t}\n\tlen += scnprintf(buf + len, buf_len - len,\n\t\t\t\"%03d: %1d%1d%1d%1d%02d%1d%1d%1d%1d\",\n\t\t\tgpio,\n\t\t\tpinmux,\n\t\t\tmtk_pctrl_get_direction(hw, gpio),\n\t\t\tmtk_pctrl_get_out(hw, gpio),\n\t\t\tmtk_pctrl_get_in(hw, gpio),\n\t\t\tmtk_pctrl_get_driving(hw, gpio),\n\t\t\tmtk_pctrl_get_smt(hw, gpio),\n\t\t\tmtk_pctrl_get_ies(hw, gpio),\n\t\t\tpullen,\n\t\t\tpullup);\n\n\tif (r1 != -1)\n\t\tlen += scnprintf(buf + len, buf_len - len, \" (%1d %1d)\", r1, r0);\n\telse if (rsel != -1)\n\t\tlen += scnprintf(buf + len, buf_len - len, \" (%1d)\", rsel);\n\n\treturn len;\n}\nEXPORT_SYMBOL_GPL(mtk_pctrl_show_one_pin);\n\n#define PIN_DBG_BUF_SZ 96\nstatic void mtk_pctrl_dbg_show(struct pinctrl_dev *pctldev, struct seq_file *s,\n\t\t\t  unsigned int gpio)\n{\n\tstruct mtk_pinctrl *hw = pinctrl_dev_get_drvdata(pctldev);\n\tchar buf[PIN_DBG_BUF_SZ] = { 0 };\n\n\t(void)mtk_pctrl_show_one_pin(hw, gpio, buf, PIN_DBG_BUF_SZ);\n\n\tseq_printf(s, \"%s\", buf);\n}\n\nstatic const struct pinctrl_ops mtk_pctlops = {\n\t.dt_node_to_map\t\t= mtk_pctrl_dt_node_to_map,\n\t.dt_free_map\t\t= pinctrl_utils_free_map,\n\t.get_groups_count\t= mtk_pctrl_get_groups_count,\n\t.get_group_name\t\t= mtk_pctrl_get_group_name,\n\t.get_group_pins\t\t= mtk_pctrl_get_group_pins,\n\t.pin_dbg_show           = mtk_pctrl_dbg_show,\n};\n\nstatic int mtk_pmx_get_funcs_cnt(struct pinctrl_dev *pctldev)\n{\n\treturn ARRAY_SIZE(mtk_gpio_functions);\n}\n\nstatic const char *mtk_pmx_get_func_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t unsigned selector)\n{\n\treturn mtk_gpio_functions[selector];\n}\n\nstatic int mtk_pmx_get_func_groups(struct pinctrl_dev *pctldev,\n\t\t\t\t   unsigned function,\n\t\t\t\t   const char * const **groups,\n\t\t\t\t   unsigned * const num_groups)\n{\n\tstruct mtk_pinctrl *hw = pinctrl_dev_get_drvdata(pctldev);\n\n\t*groups = hw->grp_names;\n\t*num_groups = hw->soc->ngrps;\n\n\treturn 0;\n}\n\nstatic int mtk_pmx_set_mux(struct pinctrl_dev *pctldev,\n\t\t\t   unsigned function,\n\t\t\t   unsigned group)\n{\n\tstruct mtk_pinctrl *hw = pinctrl_dev_get_drvdata(pctldev);\n\tstruct mtk_pinctrl_group *grp = hw->groups + group;\n\tconst struct mtk_func_desc *desc_func;\n\tconst struct mtk_pin_desc *desc;\n\tbool ret;\n\n\tret = mtk_pctrl_is_function_valid(hw, grp->pin, function);\n\tif (!ret) {\n\t\tdev_err(hw->dev, \"invalid function %d on group %d .\\n\",\n\t\t\tfunction, group);\n\t\treturn -EINVAL;\n\t}\n\n\tdesc_func = mtk_pctrl_find_function_by_pin(hw, grp->pin, function);\n\tif (!desc_func)\n\t\treturn -EINVAL;\n\n\tdesc = (const struct mtk_pin_desc *)&hw->soc->pins[grp->pin];\n\tmtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_MODE, desc_func->muxval);\n\n\treturn 0;\n}\n\nstatic const struct pinmux_ops mtk_pmxops = {\n\t.get_functions_count\t= mtk_pmx_get_funcs_cnt,\n\t.get_function_name\t= mtk_pmx_get_func_name,\n\t.get_function_groups\t= mtk_pmx_get_func_groups,\n\t.set_mux\t\t= mtk_pmx_set_mux,\n\t.gpio_set_direction\t= mtk_pinmux_gpio_set_direction,\n\t.gpio_request_enable\t= mtk_pinmux_gpio_request_enable,\n};\n\nstatic int mtk_pconf_group_get(struct pinctrl_dev *pctldev, unsigned group,\n\t\t\t       unsigned long *config)\n{\n\tstruct mtk_pinctrl *hw = pinctrl_dev_get_drvdata(pctldev);\n\tstruct mtk_pinctrl_group *grp = &hw->groups[group];\n\n\t  \n\treturn mtk_pinconf_get(pctldev, grp->pin, config);\n}\n\nstatic int mtk_pconf_group_set(struct pinctrl_dev *pctldev, unsigned group,\n\t\t\t       unsigned long *configs, unsigned num_configs)\n{\n\tstruct mtk_pinctrl *hw = pinctrl_dev_get_drvdata(pctldev);\n\tstruct mtk_pinctrl_group *grp = &hw->groups[group];\n\tbool drive_strength_uA_found = false;\n\tbool adv_drve_strength_found = false;\n\tint i, ret;\n\n\tfor (i = 0; i < num_configs; i++) {\n\t\tret = mtk_pinconf_set(pctldev, grp->pin,\n\t\t\t\t      pinconf_to_config_param(configs[i]),\n\t\t\t\t      pinconf_to_config_argument(configs[i]));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (pinconf_to_config_param(configs[i]) == PIN_CONFIG_DRIVE_STRENGTH_UA)\n\t\t\tdrive_strength_uA_found = true;\n\t\tif (pinconf_to_config_param(configs[i]) == MTK_PIN_CONFIG_DRV_ADV)\n\t\t\tadv_drve_strength_found = true;\n\t}\n\n\t \n\tif (hw->soc->adv_drive_set && !drive_strength_uA_found &&\n\t    !adv_drve_strength_found)\n\t\thw->soc->adv_drive_set(hw, &hw->soc->pins[grp->pin], 0);\n\n\treturn 0;\n}\n\nstatic const struct pinconf_ops mtk_confops = {\n\t.pin_config_get = mtk_pinconf_get,\n\t.pin_config_group_get\t= mtk_pconf_group_get,\n\t.pin_config_group_set\t= mtk_pconf_group_set,\n\t.is_generic = true,\n};\n\nstatic struct pinctrl_desc mtk_desc = {\n\t.name = PINCTRL_PINCTRL_DEV,\n\t.pctlops = &mtk_pctlops,\n\t.pmxops = &mtk_pmxops,\n\t.confops = &mtk_confops,\n\t.owner = THIS_MODULE,\n};\n\nstatic int mtk_gpio_get_direction(struct gpio_chip *chip, unsigned int gpio)\n{\n\tstruct mtk_pinctrl *hw = gpiochip_get_data(chip);\n\tconst struct mtk_pin_desc *desc;\n\tint value, err;\n\n\tif (gpio >= hw->soc->npins)\n\t\treturn -EINVAL;\n\n\t \n\tif (mtk_is_virt_gpio(hw, gpio))\n\t\treturn 1;\n\n\tdesc = (const struct mtk_pin_desc *)&hw->soc->pins[gpio];\n\n\terr = mtk_hw_get_value(hw, desc, PINCTRL_PIN_REG_DIR, &value);\n\tif (err)\n\t\treturn err;\n\n\tif (value)\n\t\treturn GPIO_LINE_DIRECTION_OUT;\n\n\treturn GPIO_LINE_DIRECTION_IN;\n}\n\nstatic int mtk_gpio_get(struct gpio_chip *chip, unsigned int gpio)\n{\n\tstruct mtk_pinctrl *hw = gpiochip_get_data(chip);\n\tconst struct mtk_pin_desc *desc;\n\tint value, err;\n\n\tif (gpio >= hw->soc->npins)\n\t\treturn -EINVAL;\n\n\tdesc = (const struct mtk_pin_desc *)&hw->soc->pins[gpio];\n\n\terr = mtk_hw_get_value(hw, desc, PINCTRL_PIN_REG_DI, &value);\n\tif (err)\n\t\treturn err;\n\n\treturn !!value;\n}\n\nstatic void mtk_gpio_set(struct gpio_chip *chip, unsigned int gpio, int value)\n{\n\tstruct mtk_pinctrl *hw = gpiochip_get_data(chip);\n\tconst struct mtk_pin_desc *desc;\n\n\tif (gpio >= hw->soc->npins)\n\t\treturn;\n\n\tdesc = (const struct mtk_pin_desc *)&hw->soc->pins[gpio];\n\n\tmtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_DO, !!value);\n}\n\nstatic int mtk_gpio_direction_input(struct gpio_chip *chip, unsigned int gpio)\n{\n\tstruct mtk_pinctrl *hw = gpiochip_get_data(chip);\n\n\tif (gpio >= hw->soc->npins)\n\t\treturn -EINVAL;\n\n\treturn pinctrl_gpio_direction_input(chip->base + gpio);\n}\n\nstatic int mtk_gpio_direction_output(struct gpio_chip *chip, unsigned int gpio,\n\t\t\t\t     int value)\n{\n\tstruct mtk_pinctrl *hw = gpiochip_get_data(chip);\n\n\tif (gpio >= hw->soc->npins)\n\t\treturn -EINVAL;\n\n\tmtk_gpio_set(chip, gpio, value);\n\n\treturn pinctrl_gpio_direction_output(chip->base + gpio);\n}\n\nstatic int mtk_gpio_to_irq(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct mtk_pinctrl *hw = gpiochip_get_data(chip);\n\tconst struct mtk_pin_desc *desc;\n\n\tif (!hw->eint)\n\t\treturn -ENOTSUPP;\n\n\tdesc = (const struct mtk_pin_desc *)&hw->soc->pins[offset];\n\n\tif (desc->eint.eint_n == EINT_NA)\n\t\treturn -ENOTSUPP;\n\n\treturn mtk_eint_find_irq(hw->eint, desc->eint.eint_n);\n}\n\nstatic int mtk_gpio_set_config(struct gpio_chip *chip, unsigned int offset,\n\t\t\t       unsigned long config)\n{\n\tstruct mtk_pinctrl *hw = gpiochip_get_data(chip);\n\tconst struct mtk_pin_desc *desc;\n\tu32 debounce;\n\n\tdesc = (const struct mtk_pin_desc *)&hw->soc->pins[offset];\n\n\tif (!hw->eint ||\n\t    pinconf_to_config_param(config) != PIN_CONFIG_INPUT_DEBOUNCE ||\n\t    desc->eint.eint_n == EINT_NA)\n\t\treturn -ENOTSUPP;\n\n\tdebounce = pinconf_to_config_argument(config);\n\n\treturn mtk_eint_set_debounce(hw->eint, desc->eint.eint_n, debounce);\n}\n\nstatic int mtk_build_gpiochip(struct mtk_pinctrl *hw)\n{\n\tstruct gpio_chip *chip = &hw->chip;\n\tint ret;\n\n\tchip->label\t\t= PINCTRL_PINCTRL_DEV;\n\tchip->parent\t\t= hw->dev;\n\tchip->request\t\t= gpiochip_generic_request;\n\tchip->free\t\t= gpiochip_generic_free;\n\tchip->get_direction\t= mtk_gpio_get_direction;\n\tchip->direction_input\t= mtk_gpio_direction_input;\n\tchip->direction_output\t= mtk_gpio_direction_output;\n\tchip->get\t\t= mtk_gpio_get;\n\tchip->set\t\t= mtk_gpio_set;\n\tchip->to_irq\t\t= mtk_gpio_to_irq;\n\tchip->set_config\t= mtk_gpio_set_config;\n\tchip->base\t\t= -1;\n\tchip->ngpio\t\t= hw->soc->npins;\n\n\tret = gpiochip_add_data(chip, hw);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int mtk_pctrl_build_state(struct platform_device *pdev)\n{\n\tstruct mtk_pinctrl *hw = platform_get_drvdata(pdev);\n\tint i;\n\n\t \n\thw->groups = devm_kmalloc_array(&pdev->dev, hw->soc->ngrps,\n\t\t\t\t\tsizeof(*hw->groups), GFP_KERNEL);\n\tif (!hw->groups)\n\t\treturn -ENOMEM;\n\n\t \n\thw->grp_names = devm_kmalloc_array(&pdev->dev, hw->soc->ngrps,\n\t\t\t\t\t   sizeof(*hw->grp_names), GFP_KERNEL);\n\tif (!hw->grp_names)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < hw->soc->npins; i++) {\n\t\tconst struct mtk_pin_desc *pin = hw->soc->pins + i;\n\t\tstruct mtk_pinctrl_group *group = hw->groups + i;\n\n\t\tgroup->name = pin->name;\n\t\tgroup->pin = pin->number;\n\n\t\thw->grp_names[i] = pin->name;\n\t}\n\n\treturn 0;\n}\n\nint mtk_paris_pinctrl_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct pinctrl_pin_desc *pins;\n\tstruct mtk_pinctrl *hw;\n\tint err, i;\n\n\thw = devm_kzalloc(&pdev->dev, sizeof(*hw), GFP_KERNEL);\n\tif (!hw)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, hw);\n\n\thw->soc = device_get_match_data(dev);\n\tif (!hw->soc)\n\t\treturn -ENOENT;\n\n\thw->dev = &pdev->dev;\n\n\tif (!hw->soc->nbase_names)\n\t\treturn dev_err_probe(dev, -EINVAL,\n\t\t\t\"SoC should be assigned at least one register base\\n\");\n\n\thw->base = devm_kmalloc_array(&pdev->dev, hw->soc->nbase_names,\n\t\t\t\t      sizeof(*hw->base), GFP_KERNEL);\n\tif (!hw->base)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < hw->soc->nbase_names; i++) {\n\t\thw->base[i] = devm_platform_ioremap_resource_byname(pdev,\n\t\t\t\t\thw->soc->base_names[i]);\n\t\tif (IS_ERR(hw->base[i]))\n\t\t\treturn PTR_ERR(hw->base[i]);\n\t}\n\n\thw->nbase = hw->soc->nbase_names;\n\n\tif (of_find_property(hw->dev->of_node,\n\t\t\t     \"mediatek,rsel-resistance-in-si-unit\", NULL))\n\t\thw->rsel_si_unit = true;\n\telse\n\t\thw->rsel_si_unit = false;\n\n\tspin_lock_init(&hw->lock);\n\n\terr = mtk_pctrl_build_state(pdev);\n\tif (err)\n\t\treturn dev_err_probe(dev, err, \"build state failed\\n\");\n\n\t \n\tpins = devm_kmalloc_array(&pdev->dev, hw->soc->npins, sizeof(*pins),\n\t\t\t\t  GFP_KERNEL);\n\tif (!pins)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < hw->soc->npins; i++) {\n\t\tpins[i].number = hw->soc->pins[i].number;\n\t\tpins[i].name = hw->soc->pins[i].name;\n\t}\n\n\t \n\tmtk_desc.pins = (const struct pinctrl_pin_desc *)pins;\n\tmtk_desc.npins = hw->soc->npins;\n\tmtk_desc.num_custom_params = ARRAY_SIZE(mtk_custom_bindings);\n\tmtk_desc.custom_params = mtk_custom_bindings;\n#ifdef CONFIG_DEBUG_FS\n\tmtk_desc.custom_conf_items = mtk_conf_items;\n#endif\n\n\terr = devm_pinctrl_register_and_init(&pdev->dev, &mtk_desc, hw,\n\t\t\t\t\t     &hw->pctrl);\n\tif (err)\n\t\treturn err;\n\n\terr = pinctrl_enable(hw->pctrl);\n\tif (err)\n\t\treturn err;\n\n\terr = mtk_build_eint(hw, pdev);\n\tif (err)\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"Failed to add EINT, but pinctrl still can work\\n\");\n\n\t \n\terr = mtk_build_gpiochip(hw);\n\tif (err)\n\t\treturn dev_err_probe(dev, err, \"Failed to add gpio_chip\\n\");\n\n\tplatform_set_drvdata(pdev, hw);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mtk_paris_pinctrl_probe);\n\nstatic int mtk_paris_pinctrl_suspend(struct device *device)\n{\n\tstruct mtk_pinctrl *pctl = dev_get_drvdata(device);\n\n\treturn mtk_eint_do_suspend(pctl->eint);\n}\n\nstatic int mtk_paris_pinctrl_resume(struct device *device)\n{\n\tstruct mtk_pinctrl *pctl = dev_get_drvdata(device);\n\n\treturn mtk_eint_do_resume(pctl->eint);\n}\n\nconst struct dev_pm_ops mtk_paris_pinctrl_pm_ops = {\n\t.suspend_noirq = mtk_paris_pinctrl_suspend,\n\t.resume_noirq = mtk_paris_pinctrl_resume,\n};\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"MediaTek Pinctrl Common Driver V2 Paris\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}