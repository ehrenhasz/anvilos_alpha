{
  "module_name": "mtk-eint.c",
  "hash_id": "4657f431e06c79df753237273633f6cb5bd45d536ef89f3e017712d2ac9bac02",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/mediatek/mtk-eint.c",
  "human_readable_source": "\n\n\n \n\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/gpio/driver.h>\n#include <linux/io.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/irqdomain.h>\n#include <linux/module.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n\n#include \"mtk-eint.h\"\n\n#define MTK_EINT_EDGE_SENSITIVE           0\n#define MTK_EINT_LEVEL_SENSITIVE          1\n#define MTK_EINT_DBNC_SET_DBNC_BITS\t  4\n#define MTK_EINT_DBNC_MAX\t\t  16\n#define MTK_EINT_DBNC_RST_BIT\t\t  (0x1 << 1)\n#define MTK_EINT_DBNC_SET_EN\t\t  (0x1 << 0)\n\nstatic const struct mtk_eint_regs mtk_generic_eint_regs = {\n\t.stat      = 0x000,\n\t.ack       = 0x040,\n\t.mask      = 0x080,\n\t.mask_set  = 0x0c0,\n\t.mask_clr  = 0x100,\n\t.sens      = 0x140,\n\t.sens_set  = 0x180,\n\t.sens_clr  = 0x1c0,\n\t.soft      = 0x200,\n\t.soft_set  = 0x240,\n\t.soft_clr  = 0x280,\n\t.pol       = 0x300,\n\t.pol_set   = 0x340,\n\t.pol_clr   = 0x380,\n\t.dom_en    = 0x400,\n\t.dbnc_ctrl = 0x500,\n\t.dbnc_set  = 0x600,\n\t.dbnc_clr  = 0x700,\n};\n\nconst unsigned int debounce_time_mt2701[] = {\n\t500, 1000, 16000, 32000, 64000, 128000, 256000, 0\n};\nEXPORT_SYMBOL_GPL(debounce_time_mt2701);\n\nconst unsigned int debounce_time_mt6765[] = {\n\t125, 250, 500, 1000, 16000, 32000, 64000, 128000, 256000, 512000, 0\n};\nEXPORT_SYMBOL_GPL(debounce_time_mt6765);\n\nconst unsigned int debounce_time_mt6795[] = {\n\t500, 1000, 16000, 32000, 64000, 128000, 256000, 512000, 0\n};\nEXPORT_SYMBOL_GPL(debounce_time_mt6795);\n\nstatic void __iomem *mtk_eint_get_offset(struct mtk_eint *eint,\n\t\t\t\t\t unsigned int eint_num,\n\t\t\t\t\t unsigned int offset)\n{\n\tunsigned int eint_base = 0;\n\tvoid __iomem *reg;\n\n\tif (eint_num >= eint->hw->ap_num)\n\t\teint_base = eint->hw->ap_num;\n\n\treg = eint->base + offset + ((eint_num - eint_base) / 32) * 4;\n\n\treturn reg;\n}\n\nstatic unsigned int mtk_eint_can_en_debounce(struct mtk_eint *eint,\n\t\t\t\t\t     unsigned int eint_num)\n{\n\tunsigned int sens;\n\tunsigned int bit = BIT(eint_num % 32);\n\tvoid __iomem *reg = mtk_eint_get_offset(eint, eint_num,\n\t\t\t\t\t\teint->regs->sens);\n\n\tif (readl(reg) & bit)\n\t\tsens = MTK_EINT_LEVEL_SENSITIVE;\n\telse\n\t\tsens = MTK_EINT_EDGE_SENSITIVE;\n\n\tif (eint_num < eint->hw->db_cnt && sens != MTK_EINT_EDGE_SENSITIVE)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nstatic int mtk_eint_flip_edge(struct mtk_eint *eint, int hwirq)\n{\n\tint start_level, curr_level;\n\tunsigned int reg_offset;\n\tu32 mask = BIT(hwirq & 0x1f);\n\tu32 port = (hwirq >> 5) & eint->hw->port_mask;\n\tvoid __iomem *reg = eint->base + (port << 2);\n\n\tcurr_level = eint->gpio_xlate->get_gpio_state(eint->pctl, hwirq);\n\n\tdo {\n\t\tstart_level = curr_level;\n\t\tif (start_level)\n\t\t\treg_offset = eint->regs->pol_clr;\n\t\telse\n\t\t\treg_offset = eint->regs->pol_set;\n\t\twritel(mask, reg + reg_offset);\n\n\t\tcurr_level = eint->gpio_xlate->get_gpio_state(eint->pctl,\n\t\t\t\t\t\t\t      hwirq);\n\t} while (start_level != curr_level);\n\n\treturn start_level;\n}\n\nstatic void mtk_eint_mask(struct irq_data *d)\n{\n\tstruct mtk_eint *eint = irq_data_get_irq_chip_data(d);\n\tu32 mask = BIT(d->hwirq & 0x1f);\n\tvoid __iomem *reg = mtk_eint_get_offset(eint, d->hwirq,\n\t\t\t\t\t\teint->regs->mask_set);\n\n\teint->cur_mask[d->hwirq >> 5] &= ~mask;\n\n\twritel(mask, reg);\n}\n\nstatic void mtk_eint_unmask(struct irq_data *d)\n{\n\tstruct mtk_eint *eint = irq_data_get_irq_chip_data(d);\n\tu32 mask = BIT(d->hwirq & 0x1f);\n\tvoid __iomem *reg = mtk_eint_get_offset(eint, d->hwirq,\n\t\t\t\t\t\teint->regs->mask_clr);\n\n\teint->cur_mask[d->hwirq >> 5] |= mask;\n\n\twritel(mask, reg);\n\n\tif (eint->dual_edge[d->hwirq])\n\t\tmtk_eint_flip_edge(eint, d->hwirq);\n}\n\nstatic unsigned int mtk_eint_get_mask(struct mtk_eint *eint,\n\t\t\t\t      unsigned int eint_num)\n{\n\tunsigned int bit = BIT(eint_num % 32);\n\tvoid __iomem *reg = mtk_eint_get_offset(eint, eint_num,\n\t\t\t\t\t\teint->regs->mask);\n\n\treturn !!(readl(reg) & bit);\n}\n\nstatic void mtk_eint_ack(struct irq_data *d)\n{\n\tstruct mtk_eint *eint = irq_data_get_irq_chip_data(d);\n\tu32 mask = BIT(d->hwirq & 0x1f);\n\tvoid __iomem *reg = mtk_eint_get_offset(eint, d->hwirq,\n\t\t\t\t\t\teint->regs->ack);\n\n\twritel(mask, reg);\n}\n\nstatic int mtk_eint_set_type(struct irq_data *d, unsigned int type)\n{\n\tstruct mtk_eint *eint = irq_data_get_irq_chip_data(d);\n\tbool masked;\n\tu32 mask = BIT(d->hwirq & 0x1f);\n\tvoid __iomem *reg;\n\n\tif (((type & IRQ_TYPE_EDGE_BOTH) && (type & IRQ_TYPE_LEVEL_MASK)) ||\n\t    ((type & IRQ_TYPE_LEVEL_MASK) == IRQ_TYPE_LEVEL_MASK)) {\n\t\tdev_err(eint->dev,\n\t\t\t\"Can't configure IRQ%d (EINT%lu) for type 0x%X\\n\",\n\t\t\td->irq, d->hwirq, type);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((type & IRQ_TYPE_EDGE_BOTH) == IRQ_TYPE_EDGE_BOTH)\n\t\teint->dual_edge[d->hwirq] = 1;\n\telse\n\t\teint->dual_edge[d->hwirq] = 0;\n\n\tif (!mtk_eint_get_mask(eint, d->hwirq)) {\n\t\tmtk_eint_mask(d);\n\t\tmasked = false;\n\t} else {\n\t\tmasked = true;\n\t}\n\n\tif (type & (IRQ_TYPE_LEVEL_LOW | IRQ_TYPE_EDGE_FALLING)) {\n\t\treg = mtk_eint_get_offset(eint, d->hwirq, eint->regs->pol_clr);\n\t\twritel(mask, reg);\n\t} else {\n\t\treg = mtk_eint_get_offset(eint, d->hwirq, eint->regs->pol_set);\n\t\twritel(mask, reg);\n\t}\n\n\tif (type & (IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING)) {\n\t\treg = mtk_eint_get_offset(eint, d->hwirq, eint->regs->sens_clr);\n\t\twritel(mask, reg);\n\t} else {\n\t\treg = mtk_eint_get_offset(eint, d->hwirq, eint->regs->sens_set);\n\t\twritel(mask, reg);\n\t}\n\n\tmtk_eint_ack(d);\n\tif (!masked)\n\t\tmtk_eint_unmask(d);\n\n\treturn 0;\n}\n\nstatic int mtk_eint_irq_set_wake(struct irq_data *d, unsigned int on)\n{\n\tstruct mtk_eint *eint = irq_data_get_irq_chip_data(d);\n\tint shift = d->hwirq & 0x1f;\n\tint reg = d->hwirq >> 5;\n\n\tif (on)\n\t\teint->wake_mask[reg] |= BIT(shift);\n\telse\n\t\teint->wake_mask[reg] &= ~BIT(shift);\n\n\treturn 0;\n}\n\nstatic void mtk_eint_chip_write_mask(const struct mtk_eint *eint,\n\t\t\t\t     void __iomem *base, u32 *buf)\n{\n\tint port;\n\tvoid __iomem *reg;\n\n\tfor (port = 0; port < eint->hw->ports; port++) {\n\t\treg = base + (port << 2);\n\t\twritel_relaxed(~buf[port], reg + eint->regs->mask_set);\n\t\twritel_relaxed(buf[port], reg + eint->regs->mask_clr);\n\t}\n}\n\nstatic int mtk_eint_irq_request_resources(struct irq_data *d)\n{\n\tstruct mtk_eint *eint = irq_data_get_irq_chip_data(d);\n\tstruct gpio_chip *gpio_c;\n\tunsigned int gpio_n;\n\tint err;\n\n\terr = eint->gpio_xlate->get_gpio_n(eint->pctl, d->hwirq,\n\t\t\t\t\t   &gpio_n, &gpio_c);\n\tif (err < 0) {\n\t\tdev_err(eint->dev, \"Can not find pin\\n\");\n\t\treturn err;\n\t}\n\n\terr = gpiochip_lock_as_irq(gpio_c, gpio_n);\n\tif (err < 0) {\n\t\tdev_err(eint->dev, \"unable to lock HW IRQ %lu for IRQ\\n\",\n\t\t\tirqd_to_hwirq(d));\n\t\treturn err;\n\t}\n\n\terr = eint->gpio_xlate->set_gpio_as_eint(eint->pctl, d->hwirq);\n\tif (err < 0) {\n\t\tdev_err(eint->dev, \"Can not eint mode\\n\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void mtk_eint_irq_release_resources(struct irq_data *d)\n{\n\tstruct mtk_eint *eint = irq_data_get_irq_chip_data(d);\n\tstruct gpio_chip *gpio_c;\n\tunsigned int gpio_n;\n\n\teint->gpio_xlate->get_gpio_n(eint->pctl, d->hwirq, &gpio_n,\n\t\t\t\t     &gpio_c);\n\n\tgpiochip_unlock_as_irq(gpio_c, gpio_n);\n}\n\nstatic struct irq_chip mtk_eint_irq_chip = {\n\t.name = \"mt-eint\",\n\t.irq_disable = mtk_eint_mask,\n\t.irq_mask = mtk_eint_mask,\n\t.irq_unmask = mtk_eint_unmask,\n\t.irq_ack = mtk_eint_ack,\n\t.irq_set_type = mtk_eint_set_type,\n\t.irq_set_wake = mtk_eint_irq_set_wake,\n\t.irq_request_resources = mtk_eint_irq_request_resources,\n\t.irq_release_resources = mtk_eint_irq_release_resources,\n};\n\nstatic unsigned int mtk_eint_hw_init(struct mtk_eint *eint)\n{\n\tvoid __iomem *dom_en = eint->base + eint->regs->dom_en;\n\tvoid __iomem *mask_set = eint->base + eint->regs->mask_set;\n\tunsigned int i;\n\n\tfor (i = 0; i < eint->hw->ap_num; i += 32) {\n\t\twritel(0xffffffff, dom_en);\n\t\twritel(0xffffffff, mask_set);\n\t\tdom_en += 4;\n\t\tmask_set += 4;\n\t}\n\n\treturn 0;\n}\n\nstatic inline void\nmtk_eint_debounce_process(struct mtk_eint *eint, int index)\n{\n\tunsigned int rst, ctrl_offset;\n\tunsigned int bit, dbnc;\n\n\tctrl_offset = (index / 4) * 4 + eint->regs->dbnc_ctrl;\n\tdbnc = readl(eint->base + ctrl_offset);\n\tbit = MTK_EINT_DBNC_SET_EN << ((index % 4) * 8);\n\tif ((bit & dbnc) > 0) {\n\t\tctrl_offset = (index / 4) * 4 + eint->regs->dbnc_set;\n\t\trst = MTK_EINT_DBNC_RST_BIT << ((index % 4) * 8);\n\t\twritel(rst, eint->base + ctrl_offset);\n\t}\n}\n\nstatic void mtk_eint_irq_handler(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tstruct mtk_eint *eint = irq_desc_get_handler_data(desc);\n\tunsigned int status, eint_num;\n\tint offset, mask_offset, index;\n\tvoid __iomem *reg =  mtk_eint_get_offset(eint, 0, eint->regs->stat);\n\tint dual_edge, start_level, curr_level;\n\n\tchained_irq_enter(chip, desc);\n\tfor (eint_num = 0; eint_num < eint->hw->ap_num; eint_num += 32,\n\t     reg += 4) {\n\t\tstatus = readl(reg);\n\t\twhile (status) {\n\t\t\toffset = __ffs(status);\n\t\t\tmask_offset = eint_num >> 5;\n\t\t\tindex = eint_num + offset;\n\t\t\tstatus &= ~BIT(offset);\n\n\t\t\t \n\t\t\tif (eint->wake_mask[mask_offset] & BIT(offset) &&\n\t\t\t    !(eint->cur_mask[mask_offset] & BIT(offset))) {\n\t\t\t\twritel_relaxed(BIT(offset), reg -\n\t\t\t\t\teint->regs->stat +\n\t\t\t\t\teint->regs->mask_set);\n\t\t\t}\n\n\t\t\tdual_edge = eint->dual_edge[index];\n\t\t\tif (dual_edge) {\n\t\t\t\t \n\t\t\t\twritel(BIT(offset), reg - eint->regs->stat +\n\t\t\t\t       eint->regs->soft_clr);\n\n\t\t\t\tstart_level =\n\t\t\t\teint->gpio_xlate->get_gpio_state(eint->pctl,\n\t\t\t\t\t\t\t\t index);\n\t\t\t}\n\n\t\t\tgeneric_handle_domain_irq(eint->domain, index);\n\n\t\t\tif (dual_edge) {\n\t\t\t\tcurr_level = mtk_eint_flip_edge(eint, index);\n\n\t\t\t\t \n\t\t\t\tif (start_level != curr_level)\n\t\t\t\t\twritel(BIT(offset), reg -\n\t\t\t\t\t       eint->regs->stat +\n\t\t\t\t\t       eint->regs->soft_set);\n\t\t\t}\n\n\t\t\tif (index < eint->hw->db_cnt)\n\t\t\t\tmtk_eint_debounce_process(eint, index);\n\t\t}\n\t}\n\tchained_irq_exit(chip, desc);\n}\n\nint mtk_eint_do_suspend(struct mtk_eint *eint)\n{\n\tmtk_eint_chip_write_mask(eint, eint->base, eint->wake_mask);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mtk_eint_do_suspend);\n\nint mtk_eint_do_resume(struct mtk_eint *eint)\n{\n\tmtk_eint_chip_write_mask(eint, eint->base, eint->cur_mask);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mtk_eint_do_resume);\n\nint mtk_eint_set_debounce(struct mtk_eint *eint, unsigned long eint_num,\n\t\t\t  unsigned int debounce)\n{\n\tint virq, eint_offset;\n\tunsigned int set_offset, bit, clr_bit, clr_offset, rst, i, unmask,\n\t\t     dbnc;\n\tstruct irq_data *d;\n\n\tif (!eint->hw->db_time)\n\t\treturn -EOPNOTSUPP;\n\n\tvirq = irq_find_mapping(eint->domain, eint_num);\n\teint_offset = (eint_num % 4) * 8;\n\td = irq_get_irq_data(virq);\n\n\tset_offset = (eint_num / 4) * 4 + eint->regs->dbnc_set;\n\tclr_offset = (eint_num / 4) * 4 + eint->regs->dbnc_clr;\n\n\tif (!mtk_eint_can_en_debounce(eint, eint_num))\n\t\treturn -EINVAL;\n\n\tdbnc = eint->num_db_time;\n\tfor (i = 0; i < eint->num_db_time; i++) {\n\t\tif (debounce <= eint->hw->db_time[i]) {\n\t\t\tdbnc = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!mtk_eint_get_mask(eint, eint_num)) {\n\t\tmtk_eint_mask(d);\n\t\tunmask = 1;\n\t} else {\n\t\tunmask = 0;\n\t}\n\n\tclr_bit = 0xff << eint_offset;\n\twritel(clr_bit, eint->base + clr_offset);\n\n\tbit = ((dbnc << MTK_EINT_DBNC_SET_DBNC_BITS) | MTK_EINT_DBNC_SET_EN) <<\n\t\teint_offset;\n\trst = MTK_EINT_DBNC_RST_BIT << eint_offset;\n\twritel(rst | bit, eint->base + set_offset);\n\n\t \n\tudelay(1);\n\tif (unmask == 1)\n\t\tmtk_eint_unmask(d);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mtk_eint_set_debounce);\n\nint mtk_eint_find_irq(struct mtk_eint *eint, unsigned long eint_n)\n{\n\tint irq;\n\n\tirq = irq_find_mapping(eint->domain, eint_n);\n\tif (!irq)\n\t\treturn -EINVAL;\n\n\treturn irq;\n}\nEXPORT_SYMBOL_GPL(mtk_eint_find_irq);\n\nint mtk_eint_do_init(struct mtk_eint *eint)\n{\n\tint i;\n\n\t \n\tif (!eint->regs)\n\t\teint->regs = &mtk_generic_eint_regs;\n\n\teint->wake_mask = devm_kcalloc(eint->dev, eint->hw->ports,\n\t\t\t\t       sizeof(*eint->wake_mask), GFP_KERNEL);\n\tif (!eint->wake_mask)\n\t\treturn -ENOMEM;\n\n\teint->cur_mask = devm_kcalloc(eint->dev, eint->hw->ports,\n\t\t\t\t      sizeof(*eint->cur_mask), GFP_KERNEL);\n\tif (!eint->cur_mask)\n\t\treturn -ENOMEM;\n\n\teint->dual_edge = devm_kcalloc(eint->dev, eint->hw->ap_num,\n\t\t\t\t       sizeof(int), GFP_KERNEL);\n\tif (!eint->dual_edge)\n\t\treturn -ENOMEM;\n\n\teint->domain = irq_domain_add_linear(eint->dev->of_node,\n\t\t\t\t\t     eint->hw->ap_num,\n\t\t\t\t\t     &irq_domain_simple_ops, NULL);\n\tif (!eint->domain)\n\t\treturn -ENOMEM;\n\n\tif (eint->hw->db_time) {\n\t\tfor (i = 0; i < MTK_EINT_DBNC_MAX; i++)\n\t\t\tif (eint->hw->db_time[i] == 0)\n\t\t\t\tbreak;\n\t\teint->num_db_time = i;\n\t}\n\n\tmtk_eint_hw_init(eint);\n\tfor (i = 0; i < eint->hw->ap_num; i++) {\n\t\tint virq = irq_create_mapping(eint->domain, i);\n\n\t\tirq_set_chip_and_handler(virq, &mtk_eint_irq_chip,\n\t\t\t\t\t handle_level_irq);\n\t\tirq_set_chip_data(virq, eint);\n\t}\n\n\tirq_set_chained_handler_and_data(eint->irq, mtk_eint_irq_handler,\n\t\t\t\t\t eint);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mtk_eint_do_init);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"MediaTek EINT Driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}