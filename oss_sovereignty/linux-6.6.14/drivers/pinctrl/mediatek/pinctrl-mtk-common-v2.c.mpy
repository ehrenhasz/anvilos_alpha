{
  "module_name": "pinctrl-mtk-common-v2.c",
  "hash_id": "f7b5e7d8ca5c4b8c11f72d7d3ac56f5075e45638763afb1a16721347c9f08957",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/mediatek/pinctrl-mtk-common-v2.c",
  "human_readable_source": "\n \n\n#include <dt-bindings/pinctrl/mt65xx.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/gpio/driver.h>\n#include <linux/platform_device.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of_irq.h>\n\n#include \"mtk-eint.h\"\n#include \"pinctrl-mtk-common-v2.h\"\n\n \nstruct mtk_drive_desc {\n\tu8 min;\n\tu8 max;\n\tu8 step;\n\tu8 scal;\n};\n\n \nstatic const struct mtk_drive_desc mtk_drive[] = {\n\t[DRV_GRP0] = { 4, 16, 4, 1 },\n\t[DRV_GRP1] = { 4, 16, 4, 2 },\n\t[DRV_GRP2] = { 2, 8, 2, 1 },\n\t[DRV_GRP3] = { 2, 8, 2, 2 },\n\t[DRV_GRP4] = { 2, 16, 2, 1 },\n};\n\nstatic void mtk_w32(struct mtk_pinctrl *pctl, u8 i, u32 reg, u32 val)\n{\n\twritel_relaxed(val, pctl->base[i] + reg);\n}\n\nstatic u32 mtk_r32(struct mtk_pinctrl *pctl, u8 i, u32 reg)\n{\n\treturn readl_relaxed(pctl->base[i] + reg);\n}\n\nvoid mtk_rmw(struct mtk_pinctrl *pctl, u8 i, u32 reg, u32 mask, u32 set)\n{\n\tu32 val;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pctl->lock, flags);\n\n\tval = mtk_r32(pctl, i, reg);\n\tval &= ~mask;\n\tval |= set;\n\tmtk_w32(pctl, i, reg, val);\n\n\tspin_unlock_irqrestore(&pctl->lock, flags);\n}\n\nstatic int mtk_hw_pin_field_lookup(struct mtk_pinctrl *hw,\n\t\t\t\t   const struct mtk_pin_desc *desc,\n\t\t\t\t   int field, struct mtk_pin_field *pfd)\n{\n\tconst struct mtk_pin_field_calc *c;\n\tconst struct mtk_pin_reg_calc *rc;\n\tint start = 0, end, check;\n\tbool found = false;\n\tu32 bits;\n\n\tif (hw->soc->reg_cal && hw->soc->reg_cal[field].range) {\n\t\trc = &hw->soc->reg_cal[field];\n\t} else {\n\t\tdev_dbg(hw->dev,\n\t\t\t\"Not support field %d for this soc\\n\", field);\n\t\treturn -ENOTSUPP;\n\t}\n\n\tend = rc->nranges - 1;\n\n\twhile (start <= end) {\n\t\tcheck = (start + end) >> 1;\n\t\tif (desc->number >= rc->range[check].s_pin\n\t\t && desc->number <= rc->range[check].e_pin) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t} else if (start == end)\n\t\t\tbreak;\n\t\telse if (desc->number < rc->range[check].s_pin)\n\t\t\tend = check - 1;\n\t\telse\n\t\t\tstart = check + 1;\n\t}\n\n\tif (!found) {\n\t\tdev_dbg(hw->dev, \"Not support field %d for pin = %d (%s)\\n\",\n\t\t\tfield, desc->number, desc->name);\n\t\treturn -ENOTSUPP;\n\t}\n\n\tc = rc->range + check;\n\n\tif (c->i_base > hw->nbase - 1) {\n\t\tdev_err(hw->dev,\n\t\t\t\"Invalid base for field %d for pin = %d (%s)\\n\",\n\t\t\tfield, desc->number, desc->name);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tbits = c->fixed ? c->s_bit : c->s_bit +\n\t       (desc->number - c->s_pin) * (c->x_bits);\n\n\t \n\tpfd->index = c->i_base;\n\tpfd->offset = c->s_addr + c->x_addrs * (bits / c->sz_reg);\n\tpfd->bitpos = bits % c->sz_reg;\n\tpfd->mask = (1 << c->x_bits) - 1;\n\n\t \n\tpfd->next = pfd->bitpos + c->x_bits > c->sz_reg ? c->x_addrs : 0;\n\n\treturn 0;\n}\n\nstatic int mtk_hw_pin_field_get(struct mtk_pinctrl *hw,\n\t\t\t\tconst struct mtk_pin_desc *desc,\n\t\t\t\tint field, struct mtk_pin_field *pfd)\n{\n\tif (field < 0 || field >= PINCTRL_PIN_REG_MAX) {\n\t\tdev_err(hw->dev, \"Invalid Field %d\\n\", field);\n\t\treturn -EINVAL;\n\t}\n\n\treturn mtk_hw_pin_field_lookup(hw, desc, field, pfd);\n}\n\nstatic void mtk_hw_bits_part(struct mtk_pin_field *pf, int *h, int *l)\n{\n\t*l = 32 - pf->bitpos;\n\t*h = get_count_order(pf->mask) - *l;\n}\n\nstatic void mtk_hw_write_cross_field(struct mtk_pinctrl *hw,\n\t\t\t\t     struct mtk_pin_field *pf, int value)\n{\n\tint nbits_l, nbits_h;\n\n\tmtk_hw_bits_part(pf, &nbits_h, &nbits_l);\n\n\tmtk_rmw(hw, pf->index, pf->offset, pf->mask << pf->bitpos,\n\t\t(value & pf->mask) << pf->bitpos);\n\n\tmtk_rmw(hw, pf->index, pf->offset + pf->next, BIT(nbits_h) - 1,\n\t\t(value & pf->mask) >> nbits_l);\n}\n\nstatic void mtk_hw_read_cross_field(struct mtk_pinctrl *hw,\n\t\t\t\t    struct mtk_pin_field *pf, int *value)\n{\n\tint nbits_l, nbits_h, h, l;\n\n\tmtk_hw_bits_part(pf, &nbits_h, &nbits_l);\n\n\tl  = (mtk_r32(hw, pf->index, pf->offset)\n\t      >> pf->bitpos) & (BIT(nbits_l) - 1);\n\th  = (mtk_r32(hw, pf->index, pf->offset + pf->next))\n\t      & (BIT(nbits_h) - 1);\n\n\t*value = (h << nbits_l) | l;\n}\n\nint mtk_hw_set_value(struct mtk_pinctrl *hw, const struct mtk_pin_desc *desc,\n\t\t     int field, int value)\n{\n\tstruct mtk_pin_field pf;\n\tint err;\n\n\terr = mtk_hw_pin_field_get(hw, desc, field, &pf);\n\tif (err)\n\t\treturn err;\n\n\tif (value < 0 || value > pf.mask)\n\t\treturn -EINVAL;\n\n\tif (!pf.next)\n\t\tmtk_rmw(hw, pf.index, pf.offset, pf.mask << pf.bitpos,\n\t\t\t(value & pf.mask) << pf.bitpos);\n\telse\n\t\tmtk_hw_write_cross_field(hw, &pf, value);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mtk_hw_set_value);\n\nint mtk_hw_get_value(struct mtk_pinctrl *hw, const struct mtk_pin_desc *desc,\n\t\t     int field, int *value)\n{\n\tstruct mtk_pin_field pf;\n\tint err;\n\n\terr = mtk_hw_pin_field_get(hw, desc, field, &pf);\n\tif (err)\n\t\treturn err;\n\n\tif (!pf.next)\n\t\t*value = (mtk_r32(hw, pf.index, pf.offset)\n\t\t\t  >> pf.bitpos) & pf.mask;\n\telse\n\t\tmtk_hw_read_cross_field(hw, &pf, value);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mtk_hw_get_value);\n\nstatic int mtk_xt_find_eint_num(struct mtk_pinctrl *hw, unsigned long eint_n)\n{\n\tconst struct mtk_pin_desc *desc;\n\tint i = 0;\n\n\tdesc = (const struct mtk_pin_desc *)hw->soc->pins;\n\n\twhile (i < hw->soc->npins) {\n\t\tif (desc[i].eint.eint_n == eint_n)\n\t\t\treturn desc[i].number;\n\t\ti++;\n\t}\n\n\treturn EINT_NA;\n}\n\n \n\nbool mtk_is_virt_gpio(struct mtk_pinctrl *hw, unsigned int gpio_n)\n{\n\tconst struct mtk_pin_desc *desc;\n\tbool virt_gpio = false;\n\n\tdesc = (const struct mtk_pin_desc *)&hw->soc->pins[gpio_n];\n\n\t \n\tif (desc->eint.eint_m == NO_EINT_SUPPORT)\n\t\treturn virt_gpio;\n\n\tif (desc->funcs && !desc->funcs[desc->eint.eint_m].name)\n\t\tvirt_gpio = true;\n\n\treturn virt_gpio;\n}\nEXPORT_SYMBOL_GPL(mtk_is_virt_gpio);\n\nstatic int mtk_xt_get_gpio_n(void *data, unsigned long eint_n,\n\t\t\t     unsigned int *gpio_n,\n\t\t\t     struct gpio_chip **gpio_chip)\n{\n\tstruct mtk_pinctrl *hw = (struct mtk_pinctrl *)data;\n\tconst struct mtk_pin_desc *desc;\n\n\tdesc = (const struct mtk_pin_desc *)hw->soc->pins;\n\t*gpio_chip = &hw->chip;\n\n\t \n\tif (hw->soc->npins > eint_n &&\n\t    desc[eint_n].eint.eint_n == eint_n)\n\t\t*gpio_n = eint_n;\n\telse\n\t\t*gpio_n = mtk_xt_find_eint_num(hw, eint_n);\n\n\treturn *gpio_n == EINT_NA ? -EINVAL : 0;\n}\n\nstatic int mtk_xt_get_gpio_state(void *data, unsigned long eint_n)\n{\n\tstruct mtk_pinctrl *hw = (struct mtk_pinctrl *)data;\n\tconst struct mtk_pin_desc *desc;\n\tstruct gpio_chip *gpio_chip;\n\tunsigned int gpio_n;\n\tint value, err;\n\n\terr = mtk_xt_get_gpio_n(hw, eint_n, &gpio_n, &gpio_chip);\n\tif (err)\n\t\treturn err;\n\n\tdesc = (const struct mtk_pin_desc *)&hw->soc->pins[gpio_n];\n\n\terr = mtk_hw_get_value(hw, desc, PINCTRL_PIN_REG_DI, &value);\n\tif (err)\n\t\treturn err;\n\n\treturn !!value;\n}\n\nstatic int mtk_xt_set_gpio_as_eint(void *data, unsigned long eint_n)\n{\n\tstruct mtk_pinctrl *hw = (struct mtk_pinctrl *)data;\n\tconst struct mtk_pin_desc *desc;\n\tstruct gpio_chip *gpio_chip;\n\tunsigned int gpio_n;\n\tint err;\n\n\terr = mtk_xt_get_gpio_n(hw, eint_n, &gpio_n, &gpio_chip);\n\tif (err)\n\t\treturn err;\n\n\tif (mtk_is_virt_gpio(hw, gpio_n))\n\t\treturn 0;\n\n\tdesc = (const struct mtk_pin_desc *)&hw->soc->pins[gpio_n];\n\n\terr = mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_MODE,\n\t\t\t       desc->eint.eint_m);\n\tif (err)\n\t\treturn err;\n\n\terr = mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_DIR, MTK_INPUT);\n\tif (err)\n\t\treturn err;\n\n\terr = mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_SMT, MTK_ENABLE);\n\t \n\tif (err && err != -ENOTSUPP)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic const struct mtk_eint_xt mtk_eint_xt = {\n\t.get_gpio_n = mtk_xt_get_gpio_n,\n\t.get_gpio_state = mtk_xt_get_gpio_state,\n\t.set_gpio_as_eint = mtk_xt_set_gpio_as_eint,\n};\n\nint mtk_build_eint(struct mtk_pinctrl *hw, struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tint ret;\n\n\tif (!IS_ENABLED(CONFIG_EINT_MTK))\n\t\treturn 0;\n\n\tif (!of_property_read_bool(np, \"interrupt-controller\"))\n\t\treturn -ENODEV;\n\n\thw->eint = devm_kzalloc(hw->dev, sizeof(*hw->eint), GFP_KERNEL);\n\tif (!hw->eint)\n\t\treturn -ENOMEM;\n\n\thw->eint->base = devm_platform_ioremap_resource_byname(pdev, \"eint\");\n\tif (IS_ERR(hw->eint->base)) {\n\t\tret = PTR_ERR(hw->eint->base);\n\t\tgoto err_free_eint;\n\t}\n\n\thw->eint->irq = irq_of_parse_and_map(np, 0);\n\tif (!hw->eint->irq) {\n\t\tret = -EINVAL;\n\t\tgoto err_free_eint;\n\t}\n\n\tif (!hw->soc->eint_hw) {\n\t\tret = -ENODEV;\n\t\tgoto err_free_eint;\n\t}\n\n\thw->eint->dev = &pdev->dev;\n\thw->eint->hw = hw->soc->eint_hw;\n\thw->eint->pctl = hw;\n\thw->eint->gpio_xlate = &mtk_eint_xt;\n\n\treturn mtk_eint_do_init(hw->eint);\n\nerr_free_eint:\n\tdevm_kfree(hw->dev, hw->eint);\n\thw->eint = NULL;\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(mtk_build_eint);\n\n \nint mtk_pinconf_bias_disable_set(struct mtk_pinctrl *hw,\n\t\t\t\t const struct mtk_pin_desc *desc)\n{\n\tint err;\n\n\terr = mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_PU,\n\t\t\t       MTK_DISABLE);\n\tif (err)\n\t\treturn err;\n\n\terr = mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_PD,\n\t\t\t       MTK_DISABLE);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mtk_pinconf_bias_disable_set);\n\nint mtk_pinconf_bias_disable_get(struct mtk_pinctrl *hw,\n\t\t\t\t const struct mtk_pin_desc *desc, int *res)\n{\n\tint v, v2;\n\tint err;\n\n\terr = mtk_hw_get_value(hw, desc, PINCTRL_PIN_REG_PU, &v);\n\tif (err)\n\t\treturn err;\n\n\terr = mtk_hw_get_value(hw, desc, PINCTRL_PIN_REG_PD, &v2);\n\tif (err)\n\t\treturn err;\n\n\tif (v == MTK_ENABLE || v2 == MTK_ENABLE)\n\t\treturn -EINVAL;\n\n\t*res = 1;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mtk_pinconf_bias_disable_get);\n\nint mtk_pinconf_bias_set(struct mtk_pinctrl *hw,\n\t\t\t const struct mtk_pin_desc *desc, bool pullup)\n{\n\tint err, arg;\n\n\targ = pullup ? 1 : 2;\n\n\terr = mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_PU, arg & 1);\n\tif (err)\n\t\treturn err;\n\n\terr = mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_PD,\n\t\t\t       !!(arg & 2));\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mtk_pinconf_bias_set);\n\nint mtk_pinconf_bias_get(struct mtk_pinctrl *hw,\n\t\t\t const struct mtk_pin_desc *desc, bool pullup, int *res)\n{\n\tint reg, err, v;\n\n\treg = pullup ? PINCTRL_PIN_REG_PU : PINCTRL_PIN_REG_PD;\n\n\terr = mtk_hw_get_value(hw, desc, reg, &v);\n\tif (err)\n\t\treturn err;\n\n\tif (!v)\n\t\treturn -EINVAL;\n\n\t*res = 1;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mtk_pinconf_bias_get);\n\n \nint mtk_pinconf_bias_disable_set_rev1(struct mtk_pinctrl *hw,\n\t\t\t\t      const struct mtk_pin_desc *desc)\n{\n\treturn mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_PULLEN,\n\t\t\t\tMTK_DISABLE);\n}\nEXPORT_SYMBOL_GPL(mtk_pinconf_bias_disable_set_rev1);\n\nint mtk_pinconf_bias_disable_get_rev1(struct mtk_pinctrl *hw,\n\t\t\t\t      const struct mtk_pin_desc *desc, int *res)\n{\n\tint v, err;\n\n\terr = mtk_hw_get_value(hw, desc, PINCTRL_PIN_REG_PULLEN, &v);\n\tif (err)\n\t\treturn err;\n\n\tif (v == MTK_ENABLE)\n\t\treturn -EINVAL;\n\n\t*res = 1;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mtk_pinconf_bias_disable_get_rev1);\n\nint mtk_pinconf_bias_set_rev1(struct mtk_pinctrl *hw,\n\t\t\t      const struct mtk_pin_desc *desc, bool pullup)\n{\n\tint err, arg;\n\n\targ = pullup ? MTK_PULLUP : MTK_PULLDOWN;\n\n\terr = mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_PULLEN,\n\t\t\t       MTK_ENABLE);\n\tif (err)\n\t\treturn err;\n\n\terr = mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_PULLSEL, arg);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mtk_pinconf_bias_set_rev1);\n\nint mtk_pinconf_bias_get_rev1(struct mtk_pinctrl *hw,\n\t\t\t      const struct mtk_pin_desc *desc, bool pullup,\n\t\t\t      int *res)\n{\n\tint err, v;\n\n\terr = mtk_hw_get_value(hw, desc, PINCTRL_PIN_REG_PULLEN, &v);\n\tif (err)\n\t\treturn err;\n\n\tif (v == MTK_DISABLE)\n\t\treturn -EINVAL;\n\n\terr = mtk_hw_get_value(hw, desc, PINCTRL_PIN_REG_PULLSEL, &v);\n\tif (err)\n\t\treturn err;\n\n\tif (pullup ^ (v == MTK_PULLUP))\n\t\treturn -EINVAL;\n\n\t*res = 1;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mtk_pinconf_bias_get_rev1);\n\n \nstatic int mtk_pinconf_bias_set_pu_pd(struct mtk_pinctrl *hw,\n\t\t\t\tconst struct mtk_pin_desc *desc,\n\t\t\t\tu32 pullup, u32 arg)\n{\n\tint err, pu, pd;\n\n\tif (arg == MTK_DISABLE) {\n\t\tpu = 0;\n\t\tpd = 0;\n\t} else if ((arg == MTK_ENABLE) && pullup) {\n\t\tpu = 1;\n\t\tpd = 0;\n\t} else if ((arg == MTK_ENABLE) && !pullup) {\n\t\tpu = 0;\n\t\tpd = 1;\n\t} else {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\terr = mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_PU, pu);\n\tif (err)\n\t\tgoto out;\n\n\terr = mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_PD, pd);\n\nout:\n\treturn err;\n}\n\nstatic int mtk_pinconf_bias_set_pullsel_pullen(struct mtk_pinctrl *hw,\n\t\t\t\tconst struct mtk_pin_desc *desc,\n\t\t\t\tu32 pullup, u32 arg)\n{\n\tint err, enable;\n\n\tif (arg == MTK_DISABLE)\n\t\tenable = 0;\n\telse if (arg == MTK_ENABLE)\n\t\tenable = 1;\n\telse {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\terr = mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_PULLEN, enable);\n\tif (err)\n\t\tgoto out;\n\n\terr = mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_PULLSEL, pullup);\n\nout:\n\treturn err;\n}\n\nstatic int mtk_pinconf_bias_set_pupd_r1_r0(struct mtk_pinctrl *hw,\n\t\t\t\tconst struct mtk_pin_desc *desc,\n\t\t\t\tu32 pullup, u32 arg)\n{\n\tint err, r0, r1;\n\n\tif ((arg == MTK_DISABLE) || (arg == MTK_PUPD_SET_R1R0_00)) {\n\t\tpullup = 0;\n\t\tr0 = 0;\n\t\tr1 = 0;\n\t} else if (arg == MTK_PUPD_SET_R1R0_01) {\n\t\tr0 = 1;\n\t\tr1 = 0;\n\t} else if (arg == MTK_PUPD_SET_R1R0_10) {\n\t\tr0 = 0;\n\t\tr1 = 1;\n\t} else if (arg == MTK_PUPD_SET_R1R0_11) {\n\t\tr0 = 1;\n\t\tr1 = 1;\n\t} else {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\terr = mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_PUPD, !pullup);\n\tif (err)\n\t\tgoto out;\n\n\terr = mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_R0, r0);\n\tif (err)\n\t\tgoto out;\n\n\terr = mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_R1, r1);\n\nout:\n\treturn err;\n}\n\nstatic int mtk_hw_pin_rsel_lookup(struct mtk_pinctrl *hw,\n\t\t\t\t  const struct mtk_pin_desc *desc,\n\t\t\t\t  u32 pullup, u32 arg, u32 *rsel_val)\n{\n\tconst struct mtk_pin_rsel *rsel;\n\tint check;\n\tbool found = false;\n\n\trsel = hw->soc->pin_rsel;\n\n\tfor (check = 0; check <= hw->soc->npin_rsel - 1; check++) {\n\t\tif (desc->number >= rsel[check].s_pin &&\n\t\t    desc->number <= rsel[check].e_pin) {\n\t\t\tif (pullup) {\n\t\t\t\tif (rsel[check].up_rsel == arg) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\t*rsel_val = rsel[check].rsel_index;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (rsel[check].down_rsel == arg) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\t*rsel_val = rsel[check].rsel_index;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tdev_err(hw->dev, \"Not support rsel value %d Ohm for pin = %d (%s)\\n\",\n\t\t\targ, desc->number, desc->name);\n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int mtk_pinconf_bias_set_rsel(struct mtk_pinctrl *hw,\n\t\t\t\t     const struct mtk_pin_desc *desc,\n\t\t\t\t     u32 pullup, u32 arg)\n{\n\tint err, rsel_val;\n\n\tif (!pullup && arg == MTK_DISABLE)\n\t\treturn 0;\n\n\tif (hw->rsel_si_unit) {\n\t\t \n\t\terr = mtk_hw_pin_rsel_lookup(hw, desc, pullup, arg, &rsel_val);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\tif (arg < MTK_PULL_SET_RSEL_000 ||\n\t\t    arg > MTK_PULL_SET_RSEL_111) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\trsel_val = arg - MTK_PULL_SET_RSEL_000;\n\t}\n\n\terr = mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_RSEL, rsel_val);\n\tif (err)\n\t\tgoto out;\n\n\terr = mtk_pinconf_bias_set_pu_pd(hw, desc, pullup, MTK_ENABLE);\n\nout:\n\treturn err;\n}\n\nint mtk_pinconf_bias_set_combo(struct mtk_pinctrl *hw,\n\t\t\t       const struct mtk_pin_desc *desc,\n\t\t\t       u32 pullup, u32 arg)\n{\n\tint err = -ENOTSUPP;\n\tu32 try_all_type;\n\n\tif (hw->soc->pull_type)\n\t\ttry_all_type = hw->soc->pull_type[desc->number];\n\telse\n\t\ttry_all_type = MTK_PULL_TYPE_MASK;\n\n\tif (try_all_type & MTK_PULL_RSEL_TYPE) {\n\t\terr = mtk_pinconf_bias_set_rsel(hw, desc, pullup, arg);\n\t\tif (!err)\n\t\t\treturn err;\n\t}\n\n\tif (try_all_type & MTK_PULL_PU_PD_TYPE) {\n\t\terr = mtk_pinconf_bias_set_pu_pd(hw, desc, pullup, arg);\n\t\tif (!err)\n\t\t\treturn err;\n\t}\n\n\tif (try_all_type & MTK_PULL_PULLSEL_TYPE) {\n\t\terr = mtk_pinconf_bias_set_pullsel_pullen(hw, desc,\n\t\t\t\t\t\t\t  pullup, arg);\n\t\tif (!err)\n\t\t\treturn err;\n\t}\n\n\tif (try_all_type & MTK_PULL_PUPD_R1R0_TYPE)\n\t\terr = mtk_pinconf_bias_set_pupd_r1_r0(hw, desc, pullup, arg);\n\n\tif (err)\n\t\tdev_err(hw->dev, \"Invalid pull argument\\n\");\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mtk_pinconf_bias_set_combo);\n\nstatic int mtk_rsel_get_si_unit(struct mtk_pinctrl *hw,\n\t\t\t\tconst struct mtk_pin_desc *desc,\n\t\t\t\tu32 pullup, u32 rsel_val, u32 *si_unit)\n{\n\tconst struct mtk_pin_rsel *rsel;\n\tint check;\n\n\trsel = hw->soc->pin_rsel;\n\n\tfor (check = 0; check <= hw->soc->npin_rsel - 1; check++) {\n\t\tif (desc->number >= rsel[check].s_pin &&\n\t\t    desc->number <= rsel[check].e_pin) {\n\t\t\tif (rsel_val == rsel[check].rsel_index) {\n\t\t\t\tif (pullup)\n\t\t\t\t\t*si_unit = rsel[check].up_rsel;\n\t\t\t\telse\n\t\t\t\t\t*si_unit = rsel[check].down_rsel;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int mtk_pinconf_bias_get_rsel(struct mtk_pinctrl *hw,\n\t\t\t\t     const struct mtk_pin_desc *desc,\n\t\t\t\t     u32 *pullup, u32 *enable)\n{\n\tint pu, pd, rsel, err;\n\n\terr = mtk_hw_get_value(hw, desc, PINCTRL_PIN_REG_RSEL, &rsel);\n\tif (err)\n\t\tgoto out;\n\n\terr = mtk_hw_get_value(hw, desc, PINCTRL_PIN_REG_PU, &pu);\n\tif (err)\n\t\tgoto out;\n\n\terr = mtk_hw_get_value(hw, desc, PINCTRL_PIN_REG_PD, &pd);\n\tif (err)\n\t\tgoto out;\n\n\tif (pu == 0 && pd == 0) {\n\t\t*pullup = 0;\n\t\t*enable = MTK_DISABLE;\n\t} else if (pu == 1 && pd == 0) {\n\t\t*pullup = 1;\n\t\tif (hw->rsel_si_unit)\n\t\t\tmtk_rsel_get_si_unit(hw, desc, *pullup, rsel, enable);\n\t\telse\n\t\t\t*enable = rsel + MTK_PULL_SET_RSEL_000;\n\t} else if (pu == 0 && pd == 1) {\n\t\t*pullup = 0;\n\t\tif (hw->rsel_si_unit)\n\t\t\tmtk_rsel_get_si_unit(hw, desc, *pullup, rsel, enable);\n\t\telse\n\t\t\t*enable = rsel + MTK_PULL_SET_RSEL_000;\n\t} else {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\nout:\n\treturn err;\n}\n\nstatic int mtk_pinconf_bias_get_pu_pd(struct mtk_pinctrl *hw,\n\t\t\t\tconst struct mtk_pin_desc *desc,\n\t\t\t\tu32 *pullup, u32 *enable)\n{\n\tint err, pu, pd;\n\n\terr = mtk_hw_get_value(hw, desc, PINCTRL_PIN_REG_PU, &pu);\n\tif (err)\n\t\tgoto out;\n\n\terr = mtk_hw_get_value(hw, desc, PINCTRL_PIN_REG_PD, &pd);\n\tif (err)\n\t\tgoto out;\n\n\tif (pu == 0 && pd == 0) {\n\t\t*pullup = 0;\n\t\t*enable = MTK_DISABLE;\n\t} else if (pu == 1 && pd == 0) {\n\t\t*pullup = 1;\n\t\t*enable = MTK_ENABLE;\n\t} else if (pu == 0 && pd == 1) {\n\t\t*pullup = 0;\n\t\t*enable = MTK_ENABLE;\n\t} else\n\t\terr = -EINVAL;\n\nout:\n\treturn err;\n}\n\nstatic int mtk_pinconf_bias_get_pullsel_pullen(struct mtk_pinctrl *hw,\n\t\t\t\tconst struct mtk_pin_desc *desc,\n\t\t\t\tu32 *pullup, u32 *enable)\n{\n\tint err;\n\n\terr = mtk_hw_get_value(hw, desc, PINCTRL_PIN_REG_PULLSEL, pullup);\n\tif (err)\n\t\tgoto out;\n\n\terr = mtk_hw_get_value(hw, desc, PINCTRL_PIN_REG_PULLEN, enable);\n\nout:\n\treturn err;\n}\n\nstatic int mtk_pinconf_bias_get_pupd_r1_r0(struct mtk_pinctrl *hw,\n\t\t\t\tconst struct mtk_pin_desc *desc,\n\t\t\t\tu32 *pullup, u32 *enable)\n{\n\tint err, r0, r1;\n\n\terr = mtk_hw_get_value(hw, desc, PINCTRL_PIN_REG_PUPD, pullup);\n\tif (err)\n\t\tgoto out;\n\t \n\t*pullup = !(*pullup);\n\n\terr = mtk_hw_get_value(hw, desc, PINCTRL_PIN_REG_R0, &r0);\n\tif (err)\n\t\tgoto out;\n\n\terr = mtk_hw_get_value(hw, desc, PINCTRL_PIN_REG_R1, &r1);\n\tif (err)\n\t\tgoto out;\n\n\tif ((r1 == 0) && (r0 == 0))\n\t\t*enable = MTK_PUPD_SET_R1R0_00;\n\telse if ((r1 == 0) && (r0 == 1))\n\t\t*enable = MTK_PUPD_SET_R1R0_01;\n\telse if ((r1 == 1) && (r0 == 0))\n\t\t*enable = MTK_PUPD_SET_R1R0_10;\n\telse if ((r1 == 1) && (r0 == 1))\n\t\t*enable = MTK_PUPD_SET_R1R0_11;\n\telse\n\t\terr = -EINVAL;\n\nout:\n\treturn err;\n}\n\nint mtk_pinconf_bias_get_combo(struct mtk_pinctrl *hw,\n\t\t\t      const struct mtk_pin_desc *desc,\n\t\t\t      u32 *pullup, u32 *enable)\n{\n\tint err = -ENOTSUPP;\n\tu32 try_all_type;\n\n\tif (hw->soc->pull_type)\n\t\ttry_all_type = hw->soc->pull_type[desc->number];\n\telse\n\t\ttry_all_type = MTK_PULL_TYPE_MASK;\n\n\tif (try_all_type & MTK_PULL_RSEL_TYPE) {\n\t\terr = mtk_pinconf_bias_get_rsel(hw, desc, pullup, enable);\n\t\tif (!err)\n\t\t\treturn err;\n\t}\n\n\tif (try_all_type & MTK_PULL_PU_PD_TYPE) {\n\t\terr = mtk_pinconf_bias_get_pu_pd(hw, desc, pullup, enable);\n\t\tif (!err)\n\t\t\treturn err;\n\t}\n\n\tif (try_all_type & MTK_PULL_PULLSEL_TYPE) {\n\t\terr = mtk_pinconf_bias_get_pullsel_pullen(hw, desc,\n\t\t\t\t\t\t\t  pullup, enable);\n\t\tif (!err)\n\t\t\treturn err;\n\t}\n\n\tif (try_all_type & MTK_PULL_PUPD_R1R0_TYPE)\n\t\terr = mtk_pinconf_bias_get_pupd_r1_r0(hw, desc, pullup, enable);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mtk_pinconf_bias_get_combo);\n\n \nint mtk_pinconf_drive_set(struct mtk_pinctrl *hw,\n\t\t\t  const struct mtk_pin_desc *desc, u32 arg)\n{\n\tconst struct mtk_drive_desc *tb;\n\tint err = -ENOTSUPP;\n\n\ttb = &mtk_drive[desc->drv_n];\n\t \n\tif ((arg >= tb->min && arg <= tb->max) && !(arg % tb->step)) {\n\t\targ = (arg / tb->step - 1) * tb->scal;\n\t\terr = mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_E4,\n\t\t\t\t       arg & 0x1);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_E8,\n\t\t\t\t       (arg & 0x2) >> 1);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mtk_pinconf_drive_set);\n\nint mtk_pinconf_drive_get(struct mtk_pinctrl *hw,\n\t\t\t  const struct mtk_pin_desc *desc, int *val)\n{\n\tconst struct mtk_drive_desc *tb;\n\tint err, val1, val2;\n\n\ttb = &mtk_drive[desc->drv_n];\n\n\terr = mtk_hw_get_value(hw, desc, PINCTRL_PIN_REG_E4, &val1);\n\tif (err)\n\t\treturn err;\n\n\terr = mtk_hw_get_value(hw, desc, PINCTRL_PIN_REG_E8, &val2);\n\tif (err)\n\t\treturn err;\n\n\t \n\t*val = (((val2 << 1) + val1) / tb->scal + 1) * tb->step;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mtk_pinconf_drive_get);\n\n \nint mtk_pinconf_drive_set_rev1(struct mtk_pinctrl *hw,\n\t\t\t       const struct mtk_pin_desc *desc, u32 arg)\n{\n\tconst struct mtk_drive_desc *tb;\n\tint err = -ENOTSUPP;\n\n\ttb = &mtk_drive[desc->drv_n];\n\n\tif ((arg >= tb->min && arg <= tb->max) && !(arg % tb->step)) {\n\t\targ = (arg / tb->step - 1) * tb->scal;\n\n\t\terr = mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_DRV,\n\t\t\t\t       arg);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mtk_pinconf_drive_set_rev1);\n\nint mtk_pinconf_drive_get_rev1(struct mtk_pinctrl *hw,\n\t\t\t       const struct mtk_pin_desc *desc, int *val)\n{\n\tconst struct mtk_drive_desc *tb;\n\tint err, val1;\n\n\ttb = &mtk_drive[desc->drv_n];\n\n\terr = mtk_hw_get_value(hw, desc, PINCTRL_PIN_REG_DRV, &val1);\n\tif (err)\n\t\treturn err;\n\n\t*val = ((val1 & 0x7) / tb->scal + 1) * tb->step;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mtk_pinconf_drive_get_rev1);\n\nint mtk_pinconf_drive_set_raw(struct mtk_pinctrl *hw,\n\t\t\t       const struct mtk_pin_desc *desc, u32 arg)\n{\n\treturn mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_DRV, arg);\n}\nEXPORT_SYMBOL_GPL(mtk_pinconf_drive_set_raw);\n\nint mtk_pinconf_drive_get_raw(struct mtk_pinctrl *hw,\n\t\t\t       const struct mtk_pin_desc *desc, int *val)\n{\n\treturn mtk_hw_get_value(hw, desc, PINCTRL_PIN_REG_DRV, val);\n}\nEXPORT_SYMBOL_GPL(mtk_pinconf_drive_get_raw);\n\nint mtk_pinconf_adv_pull_set(struct mtk_pinctrl *hw,\n\t\t\t     const struct mtk_pin_desc *desc, bool pullup,\n\t\t\t     u32 arg)\n{\n\tint err;\n\n\t \n\terr = mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_R0, arg & 1);\n\tif (err)\n\t\treturn 0;\n\n\terr = mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_R1,\n\t\t\t       !!(arg & 2));\n\tif (err)\n\t\treturn 0;\n\n\targ = pullup ? 0 : 1;\n\n\terr = mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_PUPD, arg);\n\n\t \n\tif (err == -ENOTSUPP) {\n\t\tif (hw->soc->bias_set) {\n\t\t\terr = hw->soc->bias_set(hw, desc, pullup);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\terr = mtk_pinconf_bias_set_rev1(hw, desc, pullup);\n\t\t\tif (err)\n\t\t\t\terr = mtk_pinconf_bias_set(hw, desc, pullup);\n\t\t}\n\t}\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mtk_pinconf_adv_pull_set);\n\nint mtk_pinconf_adv_pull_get(struct mtk_pinctrl *hw,\n\t\t\t     const struct mtk_pin_desc *desc, bool pullup,\n\t\t\t     u32 *val)\n{\n\tu32 t, t2;\n\tint err;\n\n\terr = mtk_hw_get_value(hw, desc, PINCTRL_PIN_REG_PUPD, &t);\n\n\t \n\tif (err == -ENOTSUPP) {\n\t\tif (hw->soc->bias_get) {\n\t\t\terr = hw->soc->bias_get(hw, desc, pullup, val);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t} else {\n\t\t \n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (pullup ^ !t)\n\t\t\treturn -EINVAL;\n\t}\n\n\terr = mtk_hw_get_value(hw, desc, PINCTRL_PIN_REG_R0, &t);\n\tif (err)\n\t\treturn err;\n\n\terr = mtk_hw_get_value(hw, desc, PINCTRL_PIN_REG_R1, &t2);\n\tif (err)\n\t\treturn err;\n\n\t*val = (t | t2 << 1) & 0x7;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mtk_pinconf_adv_pull_get);\n\nint mtk_pinconf_adv_drive_set(struct mtk_pinctrl *hw,\n\t\t\t      const struct mtk_pin_desc *desc, u32 arg)\n{\n\tint err;\n\tint en = arg & 1;\n\tint e0 = !!(arg & 2);\n\tint e1 = !!(arg & 4);\n\n\terr = mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_DRV_EN, en);\n\tif (err)\n\t\treturn err;\n\n\tif (!en)\n\t\treturn err;\n\n\terr = mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_DRV_E0, e0);\n\tif (err)\n\t\treturn err;\n\n\terr = mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_DRV_E1, e1);\n\tif (err)\n\t\treturn err;\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mtk_pinconf_adv_drive_set);\n\nint mtk_pinconf_adv_drive_get(struct mtk_pinctrl *hw,\n\t\t\t      const struct mtk_pin_desc *desc, u32 *val)\n{\n\tu32 en, e0, e1;\n\tint err;\n\n\terr = mtk_hw_get_value(hw, desc, PINCTRL_PIN_REG_DRV_EN, &en);\n\tif (err)\n\t\treturn err;\n\n\terr = mtk_hw_get_value(hw, desc, PINCTRL_PIN_REG_DRV_E0, &e0);\n\tif (err)\n\t\treturn err;\n\n\terr = mtk_hw_get_value(hw, desc, PINCTRL_PIN_REG_DRV_E1, &e1);\n\tif (err)\n\t\treturn err;\n\n\t*val = (en | e0 << 1 | e1 << 2) & 0x7;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mtk_pinconf_adv_drive_get);\n\nint mtk_pinconf_adv_drive_set_raw(struct mtk_pinctrl *hw,\n\t\t\t\t  const struct mtk_pin_desc *desc, u32 arg)\n{\n\treturn mtk_hw_set_value(hw, desc, PINCTRL_PIN_REG_DRV_ADV, arg);\n}\nEXPORT_SYMBOL_GPL(mtk_pinconf_adv_drive_set_raw);\n\nint mtk_pinconf_adv_drive_get_raw(struct mtk_pinctrl *hw,\n\t\t\t\t  const struct mtk_pin_desc *desc, u32 *val)\n{\n\treturn mtk_hw_get_value(hw, desc, PINCTRL_PIN_REG_DRV_ADV, val);\n}\nEXPORT_SYMBOL_GPL(mtk_pinconf_adv_drive_get_raw);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Sean Wang <sean.wang@mediatek.com>\");\nMODULE_DESCRIPTION(\"Pin configuration library module for mediatek SoCs\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}