{
  "module_name": "pinctrl-plgpio.c",
  "hash_id": "5659aead6ef1a60650a636756f7082d3b56544c2cb95ee1512272e13259a7467",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/spear/pinctrl-plgpio.c",
  "human_readable_source": " \n\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/gpio/driver.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/mfd/syscon.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/regmap.h>\n#include <linux/spinlock.h>\n\n#define MAX_GPIO_PER_REG\t\t32\n#define PIN_OFFSET(pin)\t\t\t(pin % MAX_GPIO_PER_REG)\n#define REG_OFFSET(base, reg, pin)\t(base + reg + (pin / MAX_GPIO_PER_REG) \\\n\t\t\t\t\t\t\t* sizeof(int *))\n\n \n#define PTO_ENB_REG\t\t0x001\n#define PTO_WDATA_REG\t\t0x002\n#define PTO_DIR_REG\t\t0x004\n#define PTO_IE_REG\t\t0x008\n#define PTO_RDATA_REG\t\t0x010\n#define PTO_MIS_REG\t\t0x020\n\nstruct plgpio_regs {\n\tu32 enb;\t\t \n\tu32 wdata;\t\t \n\tu32 dir;\t\t \n\tu32 rdata;\t\t \n\tu32 ie;\t\t\t \n\tu32 mis;\t\t \n\tu32 eit;\t\t \n};\n\n \nstruct plgpio {\n\tspinlock_t\t\tlock;\n\tstruct regmap\t\t*regmap;\n\tstruct clk\t\t*clk;\n\tstruct gpio_chip\tchip;\n\tint\t\t\t(*p2o)(int pin);\t \n\tint\t\t\t(*o2p)(int offset);\t \n\tu32\t\t\tp2o_regs;\n\tstruct plgpio_regs\tregs;\n#ifdef CONFIG_PM_SLEEP\n\tstruct plgpio_regs\t*csave_regs;\n#endif\n};\n\n \nstatic inline u32 is_plgpio_set(struct regmap *regmap, u32 pin, u32 reg)\n{\n\tu32 offset = PIN_OFFSET(pin);\n\tu32 reg_off = REG_OFFSET(0, reg, pin);\n\tu32 val;\n\n\tregmap_read(regmap, reg_off, &val);\n\n\treturn !!(val & (1 << offset));\n}\n\nstatic inline void plgpio_reg_set(struct regmap *regmap, u32 pin, u32 reg)\n{\n\tu32 offset = PIN_OFFSET(pin);\n\tu32 reg_off = REG_OFFSET(0, reg, pin);\n\tu32 mask;\n\n\tmask = 1 << offset;\n\tregmap_update_bits(regmap, reg_off, mask, mask);\n}\n\nstatic inline void plgpio_reg_reset(struct regmap *regmap, u32 pin, u32 reg)\n{\n\tu32 offset = PIN_OFFSET(pin);\n\tu32 reg_off = REG_OFFSET(0, reg, pin);\n\tu32 mask;\n\n\tmask = 1 << offset;\n\tregmap_update_bits(regmap, reg_off, mask, 0);\n}\n\n\n \nstatic int plgpio_direction_input(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct plgpio *plgpio = gpiochip_get_data(chip);\n\tunsigned long flags;\n\n\t \n\tif (plgpio->p2o && (plgpio->p2o_regs & PTO_DIR_REG)) {\n\t\toffset = plgpio->p2o(offset);\n\t\tif (offset == -1)\n\t\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(&plgpio->lock, flags);\n\tplgpio_reg_set(plgpio->regmap, offset, plgpio->regs.dir);\n\tspin_unlock_irqrestore(&plgpio->lock, flags);\n\n\treturn 0;\n}\n\nstatic int plgpio_direction_output(struct gpio_chip *chip, unsigned offset,\n\t\tint value)\n{\n\tstruct plgpio *plgpio = gpiochip_get_data(chip);\n\tunsigned long flags;\n\tunsigned dir_offset = offset, wdata_offset = offset, tmp;\n\n\t \n\tif (plgpio->p2o && (plgpio->p2o_regs & (PTO_DIR_REG | PTO_WDATA_REG))) {\n\t\ttmp = plgpio->p2o(offset);\n\t\tif (tmp == -1)\n\t\t\treturn -EINVAL;\n\n\t\tif (plgpio->p2o_regs & PTO_DIR_REG)\n\t\t\tdir_offset = tmp;\n\t\tif (plgpio->p2o_regs & PTO_WDATA_REG)\n\t\t\twdata_offset = tmp;\n\t}\n\n\tspin_lock_irqsave(&plgpio->lock, flags);\n\tif (value)\n\t\tplgpio_reg_set(plgpio->regmap, wdata_offset,\n\t\t\t\tplgpio->regs.wdata);\n\telse\n\t\tplgpio_reg_reset(plgpio->regmap, wdata_offset,\n\t\t\t\tplgpio->regs.wdata);\n\n\tplgpio_reg_reset(plgpio->regmap, dir_offset, plgpio->regs.dir);\n\tspin_unlock_irqrestore(&plgpio->lock, flags);\n\n\treturn 0;\n}\n\nstatic int plgpio_get_value(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct plgpio *plgpio = gpiochip_get_data(chip);\n\n\tif (offset >= chip->ngpio)\n\t\treturn -EINVAL;\n\n\t \n\tif (plgpio->p2o && (plgpio->p2o_regs & PTO_RDATA_REG)) {\n\t\toffset = plgpio->p2o(offset);\n\t\tif (offset == -1)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn is_plgpio_set(plgpio->regmap, offset, plgpio->regs.rdata);\n}\n\nstatic void plgpio_set_value(struct gpio_chip *chip, unsigned offset, int value)\n{\n\tstruct plgpio *plgpio = gpiochip_get_data(chip);\n\n\tif (offset >= chip->ngpio)\n\t\treturn;\n\n\t \n\tif (plgpio->p2o && (plgpio->p2o_regs & PTO_WDATA_REG)) {\n\t\toffset = plgpio->p2o(offset);\n\t\tif (offset == -1)\n\t\t\treturn;\n\t}\n\n\tif (value)\n\t\tplgpio_reg_set(plgpio->regmap, offset, plgpio->regs.wdata);\n\telse\n\t\tplgpio_reg_reset(plgpio->regmap, offset, plgpio->regs.wdata);\n}\n\nstatic int plgpio_request(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct plgpio *plgpio = gpiochip_get_data(chip);\n\tint gpio = chip->base + offset;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tif (offset >= chip->ngpio)\n\t\treturn -EINVAL;\n\n\tret = pinctrl_gpio_request(gpio);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!IS_ERR(plgpio->clk)) {\n\t\tret = clk_enable(plgpio->clk);\n\t\tif (ret)\n\t\t\tgoto err0;\n\t}\n\n\tif (plgpio->regs.enb == -1)\n\t\treturn 0;\n\n\t \n\tret = plgpio_direction_input(chip, offset);\n\tif (ret)\n\t\tgoto err1;\n\n\t \n\tif (plgpio->p2o && (plgpio->p2o_regs & PTO_ENB_REG)) {\n\t\toffset = plgpio->p2o(offset);\n\t\tif (offset == -1) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err1;\n\t\t}\n\t}\n\n\tspin_lock_irqsave(&plgpio->lock, flags);\n\tplgpio_reg_set(plgpio->regmap, offset, plgpio->regs.enb);\n\tspin_unlock_irqrestore(&plgpio->lock, flags);\n\treturn 0;\n\nerr1:\n\tif (!IS_ERR(plgpio->clk))\n\t\tclk_disable(plgpio->clk);\nerr0:\n\tpinctrl_gpio_free(gpio);\n\treturn ret;\n}\n\nstatic void plgpio_free(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct plgpio *plgpio = gpiochip_get_data(chip);\n\tint gpio = chip->base + offset;\n\tunsigned long flags;\n\n\tif (offset >= chip->ngpio)\n\t\treturn;\n\n\tif (plgpio->regs.enb == -1)\n\t\tgoto disable_clk;\n\n\t \n\tif (plgpio->p2o && (plgpio->p2o_regs & PTO_ENB_REG)) {\n\t\toffset = plgpio->p2o(offset);\n\t\tif (offset == -1)\n\t\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&plgpio->lock, flags);\n\tplgpio_reg_reset(plgpio->regmap, offset, plgpio->regs.enb);\n\tspin_unlock_irqrestore(&plgpio->lock, flags);\n\ndisable_clk:\n\tif (!IS_ERR(plgpio->clk))\n\t\tclk_disable(plgpio->clk);\n\n\tpinctrl_gpio_free(gpio);\n}\n\n \nstatic void plgpio_irq_disable(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct plgpio *plgpio = gpiochip_get_data(gc);\n\tint offset = d->hwirq;\n\tunsigned long flags;\n\n\t \n\tif (plgpio->p2o && (plgpio->p2o_regs & PTO_IE_REG)) {\n\t\toffset = plgpio->p2o(offset);\n\t\tif (offset == -1)\n\t\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&plgpio->lock, flags);\n\tplgpio_reg_set(plgpio->regmap, offset, plgpio->regs.ie);\n\tspin_unlock_irqrestore(&plgpio->lock, flags);\n\tgpiochip_disable_irq(gc, irqd_to_hwirq(d));\n}\n\nstatic void plgpio_irq_enable(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct plgpio *plgpio = gpiochip_get_data(gc);\n\tint offset = d->hwirq;\n\tunsigned long flags;\n\n\t \n\tif (plgpio->p2o && (plgpio->p2o_regs & PTO_IE_REG)) {\n\t\toffset = plgpio->p2o(offset);\n\t\tif (offset == -1)\n\t\t\treturn;\n\t}\n\n\tgpiochip_enable_irq(gc, irqd_to_hwirq(d));\n\tspin_lock_irqsave(&plgpio->lock, flags);\n\tplgpio_reg_reset(plgpio->regmap, offset, plgpio->regs.ie);\n\tspin_unlock_irqrestore(&plgpio->lock, flags);\n}\n\nstatic int plgpio_irq_set_type(struct irq_data *d, unsigned trigger)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct plgpio *plgpio = gpiochip_get_data(gc);\n\tint offset = d->hwirq;\n\tu32 reg_off;\n\tunsigned int supported_type = 0, val;\n\n\tif (offset >= plgpio->chip.ngpio)\n\t\treturn -EINVAL;\n\n\tif (plgpio->regs.eit == -1)\n\t\tsupported_type = IRQ_TYPE_LEVEL_HIGH;\n\telse\n\t\tsupported_type = IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING;\n\n\tif (!(trigger & supported_type))\n\t\treturn -EINVAL;\n\n\tif (plgpio->regs.eit == -1)\n\t\treturn 0;\n\n\treg_off = REG_OFFSET(0, plgpio->regs.eit, offset);\n\tregmap_read(plgpio->regmap, reg_off, &val);\n\n\toffset = PIN_OFFSET(offset);\n\tif (trigger & IRQ_TYPE_EDGE_RISING)\n\t\tregmap_write(plgpio->regmap, reg_off, val | (1 << offset));\n\telse\n\t\tregmap_write(plgpio->regmap, reg_off, val & ~(1 << offset));\n\n\treturn 0;\n}\n\nstatic const struct irq_chip plgpio_irqchip = {\n\t.name\t\t= \"PLGPIO\",\n\t.irq_enable\t= plgpio_irq_enable,\n\t.irq_disable\t= plgpio_irq_disable,\n\t.irq_set_type\t= plgpio_irq_set_type,\n\t.flags\t\t= IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic void plgpio_irq_handler(struct irq_desc *desc)\n{\n\tstruct gpio_chip *gc = irq_desc_get_handler_data(desc);\n\tstruct plgpio *plgpio = gpiochip_get_data(gc);\n\tstruct irq_chip *irqchip = irq_desc_get_chip(desc);\n\tint regs_count, count, pin, offset, i = 0;\n\tu32 pending;\n\tunsigned long pendingl;\n\n\tcount = plgpio->chip.ngpio;\n\tregs_count = DIV_ROUND_UP(count, MAX_GPIO_PER_REG);\n\n\tchained_irq_enter(irqchip, desc);\n\t \n\tfor (; i < regs_count; i++) {\n\t\tregmap_read(plgpio->regmap, plgpio->regs.mis +\n\t\t\ti * sizeof(int *), &pending);\n\t\tif (!pending)\n\t\t\tcontinue;\n\n\t\t \n\t\tregmap_write(plgpio->regmap, plgpio->regs.mis +\n\t\t\ti * sizeof(int *), ~pending);\n\t\t \n\t\tcount = count - i * MAX_GPIO_PER_REG;\n\t\tif (count < MAX_GPIO_PER_REG)\n\t\t\tpending &= (1 << count) - 1;\n\n\t\tpendingl = pending;\n\t\tfor_each_set_bit(offset, &pendingl, MAX_GPIO_PER_REG) {\n\t\t\t \n\t\t\tif (plgpio->o2p && (plgpio->p2o_regs & PTO_MIS_REG)) {\n\t\t\t\tpin = plgpio->o2p(offset);\n\t\t\t\tif (pin == -1)\n\t\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\tpin = offset;\n\n\t\t\t \n\t\t\tpin = i * MAX_GPIO_PER_REG + pin;\n\t\t\tgeneric_handle_domain_irq(gc->irq.domain, pin);\n\t\t}\n\t}\n\tchained_irq_exit(irqchip, desc);\n}\n\n \nstatic int spear310_p2o(int pin)\n{\n\tint offset = pin;\n\n\tif (pin <= 27)\n\t\toffset += 4;\n\telse if (pin <= 33)\n\t\toffset = -1;\n\telse if (pin <= 97)\n\t\toffset -= 2;\n\telse if (pin <= 101)\n\t\toffset = 101 - pin;\n\telse\n\t\toffset = -1;\n\n\treturn offset;\n}\n\nstatic int spear310_o2p(int offset)\n{\n\tif (offset <= 3)\n\t\treturn 101 - offset;\n\telse if (offset <= 31)\n\t\treturn offset - 4;\n\telse\n\t\treturn offset + 2;\n}\n\nstatic int plgpio_probe_dt(struct platform_device *pdev, struct plgpio *plgpio)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tint ret = -EINVAL;\n\tu32 val;\n\n\tif (of_machine_is_compatible(\"st,spear310\")) {\n\t\tplgpio->p2o = spear310_p2o;\n\t\tplgpio->o2p = spear310_o2p;\n\t\tplgpio->p2o_regs = PTO_WDATA_REG | PTO_DIR_REG | PTO_IE_REG |\n\t\t\tPTO_RDATA_REG | PTO_MIS_REG;\n\t}\n\n\tif (!of_property_read_u32(np, \"st-plgpio,ngpio\", &val)) {\n\t\tplgpio->chip.ngpio = val;\n\t} else {\n\t\tdev_err(&pdev->dev, \"DT: Invalid ngpio field\\n\");\n\t\tgoto end;\n\t}\n\n\tif (!of_property_read_u32(np, \"st-plgpio,enb-reg\", &val))\n\t\tplgpio->regs.enb = val;\n\telse\n\t\tplgpio->regs.enb = -1;\n\n\tif (!of_property_read_u32(np, \"st-plgpio,wdata-reg\", &val)) {\n\t\tplgpio->regs.wdata = val;\n\t} else {\n\t\tdev_err(&pdev->dev, \"DT: Invalid wdata reg\\n\");\n\t\tgoto end;\n\t}\n\n\tif (!of_property_read_u32(np, \"st-plgpio,dir-reg\", &val)) {\n\t\tplgpio->regs.dir = val;\n\t} else {\n\t\tdev_err(&pdev->dev, \"DT: Invalid dir reg\\n\");\n\t\tgoto end;\n\t}\n\n\tif (!of_property_read_u32(np, \"st-plgpio,ie-reg\", &val)) {\n\t\tplgpio->regs.ie = val;\n\t} else {\n\t\tdev_err(&pdev->dev, \"DT: Invalid ie reg\\n\");\n\t\tgoto end;\n\t}\n\n\tif (!of_property_read_u32(np, \"st-plgpio,rdata-reg\", &val)) {\n\t\tplgpio->regs.rdata = val;\n\t} else {\n\t\tdev_err(&pdev->dev, \"DT: Invalid rdata reg\\n\");\n\t\tgoto end;\n\t}\n\n\tif (!of_property_read_u32(np, \"st-plgpio,mis-reg\", &val)) {\n\t\tplgpio->regs.mis = val;\n\t} else {\n\t\tdev_err(&pdev->dev, \"DT: Invalid mis reg\\n\");\n\t\tgoto end;\n\t}\n\n\tif (!of_property_read_u32(np, \"st-plgpio,eit-reg\", &val))\n\t\tplgpio->regs.eit = val;\n\telse\n\t\tplgpio->regs.eit = -1;\n\n\treturn 0;\n\nend:\n\treturn ret;\n}\n\nstatic int plgpio_probe(struct platform_device *pdev)\n{\n\tstruct device_node *regmap_np;\n\tstruct plgpio *plgpio;\n\tint ret, irq;\n\n\tplgpio = devm_kzalloc(&pdev->dev, sizeof(*plgpio), GFP_KERNEL);\n\tif (!plgpio)\n\t\treturn -ENOMEM;\n\n\tregmap_np = of_parse_phandle(pdev->dev.of_node, \"regmap\", 0);\n\tif (regmap_np) {\n\t\tplgpio->regmap = device_node_to_regmap(regmap_np);\n\t\tof_node_put(regmap_np);\n\t\tif (IS_ERR(plgpio->regmap)) {\n\t\t\tdev_err(&pdev->dev, \"Retrieve regmap failed (%pe)\\n\",\n\t\t\t\tplgpio->regmap);\n\t\t\treturn PTR_ERR(plgpio->regmap);\n\t\t}\n\t} else {\n\t\tplgpio->regmap = device_node_to_regmap(pdev->dev.of_node);\n\t\tif (IS_ERR(plgpio->regmap)) {\n\t\t\tdev_err(&pdev->dev, \"Init regmap failed (%pe)\\n\",\n\t\t\t\tplgpio->regmap);\n\t\t\treturn PTR_ERR(plgpio->regmap);\n\t\t}\n\t}\n\n\tret = plgpio_probe_dt(pdev, plgpio);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"DT probe failed\\n\");\n\t\treturn ret;\n\t}\n\n\tplgpio->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(plgpio->clk))\n\t\tdev_warn(&pdev->dev, \"clk_get() failed, work without it\\n\");\n\n#ifdef CONFIG_PM_SLEEP\n\tplgpio->csave_regs = devm_kcalloc(&pdev->dev,\n\t\t\tDIV_ROUND_UP(plgpio->chip.ngpio, MAX_GPIO_PER_REG),\n\t\t\tsizeof(*plgpio->csave_regs),\n\t\t\tGFP_KERNEL);\n\tif (!plgpio->csave_regs)\n\t\treturn -ENOMEM;\n#endif\n\n\tplatform_set_drvdata(pdev, plgpio);\n\tspin_lock_init(&plgpio->lock);\n\n\tplgpio->chip.base = -1;\n\tplgpio->chip.request = plgpio_request;\n\tplgpio->chip.free = plgpio_free;\n\tplgpio->chip.direction_input = plgpio_direction_input;\n\tplgpio->chip.direction_output = plgpio_direction_output;\n\tplgpio->chip.get = plgpio_get_value;\n\tplgpio->chip.set = plgpio_set_value;\n\tplgpio->chip.label = dev_name(&pdev->dev);\n\tplgpio->chip.parent = &pdev->dev;\n\tplgpio->chip.owner = THIS_MODULE;\n\n\tif (!IS_ERR(plgpio->clk)) {\n\t\tret = clk_prepare(plgpio->clk);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"clk prepare failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq > 0) {\n\t\tstruct gpio_irq_chip *girq;\n\n\t\tgirq = &plgpio->chip.irq;\n\t\tgpio_irq_chip_set_chip(girq, &plgpio_irqchip);\n\t\tgirq->parent_handler = plgpio_irq_handler;\n\t\tgirq->num_parents = 1;\n\t\tgirq->parents = devm_kcalloc(&pdev->dev, 1,\n\t\t\t\t\t     sizeof(*girq->parents),\n\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!girq->parents)\n\t\t\treturn -ENOMEM;\n\t\tgirq->parents[0] = irq;\n\t\tgirq->default_type = IRQ_TYPE_NONE;\n\t\tgirq->handler = handle_simple_irq;\n\t\tdev_info(&pdev->dev, \"PLGPIO registering with IRQs\\n\");\n\t} else {\n\t\tdev_info(&pdev->dev, \"PLGPIO registering without IRQs\\n\");\n\t}\n\n\tret = gpiochip_add_data(&plgpio->chip, plgpio);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"unable to add gpio chip\\n\");\n\t\tgoto unprepare_clk;\n\t}\n\n\treturn 0;\n\nunprepare_clk:\n\tif (!IS_ERR(plgpio->clk))\n\t\tclk_unprepare(plgpio->clk);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int plgpio_suspend(struct device *dev)\n{\n\tstruct plgpio *plgpio = dev_get_drvdata(dev);\n\tint i, reg_count = DIV_ROUND_UP(plgpio->chip.ngpio, MAX_GPIO_PER_REG);\n\tu32 off;\n\n\tfor (i = 0; i < reg_count; i++) {\n\t\toff = i * sizeof(int *);\n\n\t\tif (plgpio->regs.enb != -1)\n\t\t\tregmap_read(plgpio->regmap, plgpio->regs.enb + off,\n\t\t\t\t&plgpio->csave_regs[i].enb);\n\t\tif (plgpio->regs.eit != -1)\n\t\t\tregmap_read(plgpio->regmap, plgpio->regs.eit + off,\n\t\t\t\t&plgpio->csave_regs[i].eit);\n\t\tregmap_read(plgpio->regmap, plgpio->regs.wdata + off,\n\t\t\t\t&plgpio->csave_regs[i].wdata);\n\t\tregmap_read(plgpio->regmap, plgpio->regs.dir + off,\n\t\t\t\t&plgpio->csave_regs[i].dir);\n\t\tregmap_read(plgpio->regmap, plgpio->regs.ie + off,\n\t\t\t\t&plgpio->csave_regs[i].ie);\n\t}\n\n\treturn 0;\n}\n\n \n#define plgpio_prepare_reg(__reg, _off, _mask, _tmp)\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\tregmap_read(plgpio->regmap, plgpio->regs.__reg + _off, &_tmp); \\\n\t_tmp &= ~_mask;\t\t\t\t\t\t\\\n\tplgpio->csave_regs[i].__reg =\t\t\t\t\\\n\t\t_tmp | (plgpio->csave_regs[i].__reg & _mask);\t\\\n}\n\nstatic int plgpio_resume(struct device *dev)\n{\n\tstruct plgpio *plgpio = dev_get_drvdata(dev);\n\tint i, reg_count = DIV_ROUND_UP(plgpio->chip.ngpio, MAX_GPIO_PER_REG);\n\tu32 off;\n\tu32 mask, tmp;\n\n\tfor (i = 0; i < reg_count; i++) {\n\t\toff = i * sizeof(int *);\n\n\t\tif (i == reg_count - 1) {\n\t\t\tmask = (1 << (plgpio->chip.ngpio - i *\n\t\t\t\t\t\tMAX_GPIO_PER_REG)) - 1;\n\n\t\t\tif (plgpio->regs.enb != -1)\n\t\t\t\tplgpio_prepare_reg(enb, off, mask, tmp);\n\n\t\t\tif (plgpio->regs.eit != -1)\n\t\t\t\tplgpio_prepare_reg(eit, off, mask, tmp);\n\n\t\t\tplgpio_prepare_reg(wdata, off, mask, tmp);\n\t\t\tplgpio_prepare_reg(dir, off, mask, tmp);\n\t\t\tplgpio_prepare_reg(ie, off, mask, tmp);\n\t\t}\n\n\t\tregmap_write(plgpio->regmap, plgpio->regs.wdata + off,\n\t\t\tplgpio->csave_regs[i].wdata);\n\n\t\tregmap_write(plgpio->regmap, plgpio->regs.dir + off,\n\t\t\tplgpio->csave_regs[i].dir);\n\n\t\tif (plgpio->regs.eit != -1)\n\t\t\tregmap_write(plgpio->regmap, plgpio->regs.eit + off,\n\t\t\t\tplgpio->csave_regs[i].eit);\n\n\t\tregmap_write(plgpio->regmap, plgpio->regs.ie + off,\n\t\t\tplgpio->csave_regs[i].ie);\n\n\t\tif (plgpio->regs.enb != -1)\n\t\t\tregmap_write(plgpio->regmap, plgpio->regs.enb + off,\n\t\t\t\tplgpio->csave_regs[i].enb);\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(plgpio_dev_pm_ops, plgpio_suspend, plgpio_resume);\n\nstatic const struct of_device_id plgpio_of_match[] = {\n\t{ .compatible = \"st,spear-plgpio\" },\n\t{}\n};\n\nstatic struct platform_driver plgpio_driver = {\n\t.probe = plgpio_probe,\n\t.driver = {\n\t\t.name = \"spear-plgpio\",\n\t\t.pm = &plgpio_dev_pm_ops,\n\t\t.of_match_table = plgpio_of_match,\n\t},\n};\n\nstatic int __init plgpio_init(void)\n{\n\treturn platform_driver_register(&plgpio_driver);\n}\nsubsys_initcall(plgpio_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}