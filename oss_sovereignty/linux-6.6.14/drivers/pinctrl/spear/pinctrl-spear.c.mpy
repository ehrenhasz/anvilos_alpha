{
  "module_name": "pinctrl-spear.c",
  "hash_id": "e7903690866cff5cd61502f1862fe255893607c7a7df05c11a452884669b433d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/spear/pinctrl-spear.c",
  "human_readable_source": " \n\n#include <linux/err.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n\n#include <linux/pinctrl/machine.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinmux.h>\n\n#include \"pinctrl-spear.h\"\n\n#define DRIVER_NAME \"spear-pinmux\"\n\nstatic void muxregs_endisable(struct spear_pmx *pmx,\n\t\tstruct spear_muxreg *muxregs, u8 count, bool enable)\n{\n\tstruct spear_muxreg *muxreg;\n\tu32 val, temp, j;\n\n\tfor (j = 0; j < count; j++) {\n\t\tmuxreg = &muxregs[j];\n\n\t\tval = pmx_readl(pmx, muxreg->reg);\n\t\tval &= ~muxreg->mask;\n\n\t\tif (enable)\n\t\t\ttemp = muxreg->val;\n\t\telse\n\t\t\ttemp = ~muxreg->val;\n\n\t\tval |= muxreg->mask & temp;\n\t\tpmx_writel(pmx, val, muxreg->reg);\n\t}\n}\n\nstatic int set_mode(struct spear_pmx *pmx, int mode)\n{\n\tstruct spear_pmx_mode *pmx_mode = NULL;\n\tint i;\n\tu32 val;\n\n\tif (!pmx->machdata->pmx_modes || !pmx->machdata->npmx_modes)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < pmx->machdata->npmx_modes; i++) {\n\t\tif (pmx->machdata->pmx_modes[i]->mode == (1 << mode)) {\n\t\t\tpmx_mode = pmx->machdata->pmx_modes[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!pmx_mode)\n\t\treturn -EINVAL;\n\n\tval = pmx_readl(pmx, pmx_mode->reg);\n\tval &= ~pmx_mode->mask;\n\tval |= pmx_mode->val;\n\tpmx_writel(pmx, val, pmx_mode->reg);\n\n\tpmx->machdata->mode = pmx_mode->mode;\n\tdev_info(pmx->dev, \"Configured Mode: %s with id: %x\\n\\n\",\n\t\t\tpmx_mode->name ? pmx_mode->name : \"no_name\",\n\t\t\tpmx_mode->reg);\n\n\treturn 0;\n}\n\nvoid pmx_init_gpio_pingroup_addr(struct spear_gpio_pingroup *gpio_pingroup,\n\t\t\t\t unsigned count, u16 reg)\n{\n\tint i, j;\n\n\tfor (i = 0; i < count; i++)\n\t\tfor (j = 0; j < gpio_pingroup[i].nmuxregs; j++)\n\t\t\tgpio_pingroup[i].muxregs[j].reg = reg;\n}\n\nvoid pmx_init_addr(struct spear_pinctrl_machdata *machdata, u16 reg)\n{\n\tstruct spear_pingroup *pgroup;\n\tstruct spear_modemux *modemux;\n\tint i, j, group;\n\n\tfor (group = 0; group < machdata->ngroups; group++) {\n\t\tpgroup = machdata->groups[group];\n\n\t\tfor (i = 0; i < pgroup->nmodemuxs; i++) {\n\t\t\tmodemux = &pgroup->modemuxs[i];\n\n\t\t\tfor (j = 0; j < modemux->nmuxregs; j++)\n\t\t\t\tif (modemux->muxregs[j].reg == 0xFFFF)\n\t\t\t\t\tmodemux->muxregs[j].reg = reg;\n\t\t}\n\t}\n}\n\nstatic int spear_pinctrl_get_groups_cnt(struct pinctrl_dev *pctldev)\n{\n\tstruct spear_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pmx->machdata->ngroups;\n}\n\nstatic const char *spear_pinctrl_get_group_name(struct pinctrl_dev *pctldev,\n\t\tunsigned group)\n{\n\tstruct spear_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pmx->machdata->groups[group]->name;\n}\n\nstatic int spear_pinctrl_get_group_pins(struct pinctrl_dev *pctldev,\n\t\tunsigned group, const unsigned **pins, unsigned *num_pins)\n{\n\tstruct spear_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\n\n\t*pins = pmx->machdata->groups[group]->pins;\n\t*num_pins = pmx->machdata->groups[group]->npins;\n\n\treturn 0;\n}\n\nstatic void spear_pinctrl_pin_dbg_show(struct pinctrl_dev *pctldev,\n\t\tstruct seq_file *s, unsigned offset)\n{\n\tseq_printf(s, \" \" DRIVER_NAME);\n}\n\nstatic int spear_pinctrl_dt_node_to_map(struct pinctrl_dev *pctldev,\n\t\t\t\t\tstruct device_node *np_config,\n\t\t\t\t\tstruct pinctrl_map **map,\n\t\t\t\t\tunsigned *num_maps)\n{\n\tstruct spear_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\n\tstruct device_node *np;\n\tstruct property *prop;\n\tconst char *function, *group;\n\tint ret, index = 0, count = 0;\n\n\t \n\tfor_each_child_of_node(np_config, np) {\n\t\tret = of_property_read_string(np, \"st,function\", &function);\n\t\tif (ret < 0) {\n\t\t\tof_node_put(np);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = of_property_count_strings(np, \"st,pins\");\n\t\tif (ret < 0) {\n\t\t\tof_node_put(np);\n\t\t\treturn ret;\n\t\t}\n\n\t\tcount += ret;\n\t}\n\n\tif (!count) {\n\t\tdev_err(pmx->dev, \"No child nodes passed via DT\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t*map = kcalloc(count, sizeof(**map), GFP_KERNEL);\n\tif (!*map)\n\t\treturn -ENOMEM;\n\n\tfor_each_child_of_node(np_config, np) {\n\t\tof_property_read_string(np, \"st,function\", &function);\n\t\tof_property_for_each_string(np, \"st,pins\", prop, group) {\n\t\t\t(*map)[index].type = PIN_MAP_TYPE_MUX_GROUP;\n\t\t\t(*map)[index].data.mux.group = group;\n\t\t\t(*map)[index].data.mux.function = function;\n\t\t\tindex++;\n\t\t}\n\t}\n\n\t*num_maps = count;\n\n\treturn 0;\n}\n\nstatic void spear_pinctrl_dt_free_map(struct pinctrl_dev *pctldev,\n\t\t\t\t      struct pinctrl_map *map,\n\t\t\t\t      unsigned num_maps)\n{\n\tkfree(map);\n}\n\nstatic const struct pinctrl_ops spear_pinctrl_ops = {\n\t.get_groups_count = spear_pinctrl_get_groups_cnt,\n\t.get_group_name = spear_pinctrl_get_group_name,\n\t.get_group_pins = spear_pinctrl_get_group_pins,\n\t.pin_dbg_show = spear_pinctrl_pin_dbg_show,\n\t.dt_node_to_map = spear_pinctrl_dt_node_to_map,\n\t.dt_free_map = spear_pinctrl_dt_free_map,\n};\n\nstatic int spear_pinctrl_get_funcs_count(struct pinctrl_dev *pctldev)\n{\n\tstruct spear_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pmx->machdata->nfunctions;\n}\n\nstatic const char *spear_pinctrl_get_func_name(struct pinctrl_dev *pctldev,\n\t\tunsigned function)\n{\n\tstruct spear_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pmx->machdata->functions[function]->name;\n}\n\nstatic int spear_pinctrl_get_func_groups(struct pinctrl_dev *pctldev,\n\t\tunsigned function, const char *const **groups,\n\t\tunsigned * const ngroups)\n{\n\tstruct spear_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\n\n\t*groups = pmx->machdata->functions[function]->groups;\n\t*ngroups = pmx->machdata->functions[function]->ngroups;\n\n\treturn 0;\n}\n\nstatic int spear_pinctrl_endisable(struct pinctrl_dev *pctldev,\n\t\tunsigned function, unsigned group, bool enable)\n{\n\tstruct spear_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct spear_pingroup *pgroup;\n\tconst struct spear_modemux *modemux;\n\tint i;\n\tbool found = false;\n\n\tpgroup = pmx->machdata->groups[group];\n\n\tfor (i = 0; i < pgroup->nmodemuxs; i++) {\n\t\tmodemux = &pgroup->modemuxs[i];\n\n\t\t \n\t\tif (pmx->machdata->modes_supported) {\n\t\t\tif (!(pmx->machdata->mode & modemux->modes))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tfound = true;\n\t\tmuxregs_endisable(pmx, modemux->muxregs, modemux->nmuxregs,\n\t\t\t\tenable);\n\t}\n\n\tif (!found) {\n\t\tdev_err(pmx->dev, \"pinmux group: %s not supported\\n\",\n\t\t\t\tpgroup->name);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int spear_pinctrl_set_mux(struct pinctrl_dev *pctldev, unsigned function,\n\t\tunsigned group)\n{\n\treturn spear_pinctrl_endisable(pctldev, function, group, true);\n}\n\n \nstatic struct spear_gpio_pingroup *get_gpio_pingroup(struct spear_pmx *pmx,\n\t\tunsigned pin)\n{\n\tstruct spear_gpio_pingroup *gpio_pingroup;\n\tint i, j;\n\n\tif (!pmx->machdata->gpio_pingroups)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pmx->machdata->ngpio_pingroups; i++) {\n\t\tgpio_pingroup = &pmx->machdata->gpio_pingroups[i];\n\n\t\tfor (j = 0; j < gpio_pingroup->npins; j++) {\n\t\t\tif (gpio_pingroup->pins[j] == pin)\n\t\t\t\treturn gpio_pingroup;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic int gpio_request_endisable(struct pinctrl_dev *pctldev,\n\t\tstruct pinctrl_gpio_range *range, unsigned offset, bool enable)\n{\n\tstruct spear_pmx *pmx = pinctrl_dev_get_drvdata(pctldev);\n\tstruct spear_pinctrl_machdata *machdata = pmx->machdata;\n\tstruct spear_gpio_pingroup *gpio_pingroup;\n\n\t \n\tgpio_pingroup = get_gpio_pingroup(pmx, offset);\n\tif (gpio_pingroup)\n\t\tmuxregs_endisable(pmx, gpio_pingroup->muxregs,\n\t\t\t\tgpio_pingroup->nmuxregs, enable);\n\n\t \n\tif (machdata->gpio_request_endisable)\n\t\tmachdata->gpio_request_endisable(pmx, offset, enable);\n\n\treturn 0;\n}\n\nstatic int gpio_request_enable(struct pinctrl_dev *pctldev,\n\t\tstruct pinctrl_gpio_range *range, unsigned offset)\n{\n\treturn gpio_request_endisable(pctldev, range, offset, true);\n}\n\nstatic void gpio_disable_free(struct pinctrl_dev *pctldev,\n\t\tstruct pinctrl_gpio_range *range, unsigned offset)\n{\n\tgpio_request_endisable(pctldev, range, offset, false);\n}\n\nstatic const struct pinmux_ops spear_pinmux_ops = {\n\t.get_functions_count = spear_pinctrl_get_funcs_count,\n\t.get_function_name = spear_pinctrl_get_func_name,\n\t.get_function_groups = spear_pinctrl_get_func_groups,\n\t.set_mux = spear_pinctrl_set_mux,\n\t.gpio_request_enable = gpio_request_enable,\n\t.gpio_disable_free = gpio_disable_free,\n};\n\nstatic struct pinctrl_desc spear_pinctrl_desc = {\n\t.name = DRIVER_NAME,\n\t.pctlops = &spear_pinctrl_ops,\n\t.pmxops = &spear_pinmux_ops,\n\t.owner = THIS_MODULE,\n};\n\nint spear_pinctrl_probe(struct platform_device *pdev,\n\t\t\tstruct spear_pinctrl_machdata *machdata)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct spear_pmx *pmx;\n\n\tif (!machdata)\n\t\treturn -ENODEV;\n\n\tpmx = devm_kzalloc(&pdev->dev, sizeof(*pmx), GFP_KERNEL);\n\tif (!pmx)\n\t\treturn -ENOMEM;\n\n\tpmx->regmap = device_node_to_regmap(np);\n\tif (IS_ERR(pmx->regmap)) {\n\t\tdev_err(&pdev->dev, \"Init regmap failed (%pe).\\n\",\n\t\t\tpmx->regmap);\n\t\treturn PTR_ERR(pmx->regmap);\n\t}\n\n\tpmx->dev = &pdev->dev;\n\tpmx->machdata = machdata;\n\n\t \n\tif (machdata->modes_supported) {\n\t\tint mode = 0;\n\n\t\tif (of_property_read_u32(np, \"st,pinmux-mode\", &mode)) {\n\t\t\tdev_err(&pdev->dev, \"OF: pinmux mode not passed\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (set_mode(pmx, mode)) {\n\t\t\tdev_err(&pdev->dev, \"OF: Couldn't configure mode: %x\\n\",\n\t\t\t\t\tmode);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tplatform_set_drvdata(pdev, pmx);\n\n\tspear_pinctrl_desc.pins = machdata->pins;\n\tspear_pinctrl_desc.npins = machdata->npins;\n\n\tpmx->pctl = devm_pinctrl_register(&pdev->dev, &spear_pinctrl_desc, pmx);\n\tif (IS_ERR(pmx->pctl)) {\n\t\tdev_err(&pdev->dev, \"Couldn't register pinctrl driver\\n\");\n\t\treturn PTR_ERR(pmx->pctl);\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}