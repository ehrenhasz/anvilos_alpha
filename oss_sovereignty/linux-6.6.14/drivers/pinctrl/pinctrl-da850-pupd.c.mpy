{
  "module_name": "pinctrl-da850-pupd.c",
  "hash_id": "d3c2762bbb4e79ff5b55e2eed75007551ed232f22b8ecbeccbc7548817aacf1a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/pinctrl-da850-pupd.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinconf-generic.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/platform_device.h>\n\n#define DA850_PUPD_ENA\t\t0x00\n#define DA850_PUPD_SEL\t\t0x04\n\nstruct da850_pupd_data {\n\tvoid __iomem *base;\n\tstruct pinctrl_desc desc;\n\tstruct pinctrl_dev *pinctrl;\n};\n\nstatic const char * const da850_pupd_group_names[] = {\n\t\"cp0\", \"cp1\", \"cp2\", \"cp3\", \"cp4\", \"cp5\", \"cp6\", \"cp7\",\n\t\"cp8\", \"cp9\", \"cp10\", \"cp11\", \"cp12\", \"cp13\", \"cp14\", \"cp15\",\n\t\"cp16\", \"cp17\", \"cp18\", \"cp19\", \"cp20\", \"cp21\", \"cp22\", \"cp23\",\n\t\"cp24\", \"cp25\", \"cp26\", \"cp27\", \"cp28\", \"cp29\", \"cp30\", \"cp31\",\n};\n\nstatic int da850_pupd_get_groups_count(struct pinctrl_dev *pctldev)\n{\n\treturn ARRAY_SIZE(da850_pupd_group_names);\n}\n\nstatic const char *da850_pupd_get_group_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t     unsigned int selector)\n{\n\treturn da850_pupd_group_names[selector];\n}\n\nstatic int da850_pupd_get_group_pins(struct pinctrl_dev *pctldev,\n\t\t\t\t     unsigned int selector,\n\t\t\t\t     const unsigned int **pins,\n\t\t\t\t     unsigned int *num_pins)\n{\n\t*num_pins = 0;\n\n\treturn 0;\n}\n\nstatic const struct pinctrl_ops da850_pupd_pctlops = {\n\t.get_groups_count\t= da850_pupd_get_groups_count,\n\t.get_group_name\t\t= da850_pupd_get_group_name,\n\t.get_group_pins\t\t= da850_pupd_get_group_pins,\n\t.dt_node_to_map\t\t= pinconf_generic_dt_node_to_map_group,\n\t.dt_free_map\t\t= pinconf_generic_dt_free_map,\n};\n\nstatic int da850_pupd_pin_config_group_get(struct pinctrl_dev *pctldev,\n\t\t\t\t\t   unsigned int selector,\n\t\t\t\t\t   unsigned long *config)\n{\n\tstruct da850_pupd_data *data = pinctrl_dev_get_drvdata(pctldev);\n\tenum pin_config_param param = pinconf_to_config_param(*config);\n\tu32 val;\n\tu16 arg;\n\n\tval = readl(data->base + DA850_PUPD_ENA);\n\targ = !!(~val & BIT(selector));\n\n\tswitch (param) {\n\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\tif (arg) {\n\t\t\t \n\t\t\targ = 0;\n\t\t\tbreak;\n\t\t}\n\t\tval = readl(data->base + DA850_PUPD_SEL);\n\t\tif (param == PIN_CONFIG_BIAS_PULL_DOWN)\n\t\t\tval = ~val;\n\t\targ = !!(val & BIT(selector));\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t*config = pinconf_to_config_packed(param, arg);\n\n\treturn 0;\n}\n\nstatic int da850_pupd_pin_config_group_set(struct pinctrl_dev *pctldev,\n\t\t\t\t\t   unsigned int selector,\n\t\t\t\t\t   unsigned long *configs,\n\t\t\t\t\t   unsigned int num_configs)\n{\n\tstruct da850_pupd_data *data = pinctrl_dev_get_drvdata(pctldev);\n\tu32 ena, sel;\n\tenum pin_config_param param;\n\tint i;\n\n\tena = readl(data->base + DA850_PUPD_ENA);\n\tsel = readl(data->base + DA850_PUPD_SEL);\n\n\tfor (i = 0; i < num_configs; i++) {\n\t\tparam = pinconf_to_config_param(configs[i]);\n\n\t\tswitch (param) {\n\t\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\t\tena &= ~BIT(selector);\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\t\tena |= BIT(selector);\n\t\t\tsel |= BIT(selector);\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\t\tena |= BIT(selector);\n\t\t\tsel &= ~BIT(selector);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\twritel(sel, data->base + DA850_PUPD_SEL);\n\twritel(ena, data->base + DA850_PUPD_ENA);\n\n\treturn 0;\n}\n\nstatic const struct pinconf_ops da850_pupd_confops = {\n\t.is_generic\t\t= true,\n\t.pin_config_group_get\t= da850_pupd_pin_config_group_get,\n\t.pin_config_group_set\t= da850_pupd_pin_config_group_set,\n};\n\nstatic int da850_pupd_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct da850_pupd_data *data;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(data->base)) {\n\t\tdev_err(dev, \"Could not map resource\\n\");\n\t\treturn PTR_ERR(data->base);\n\t}\n\n\tdata->desc.name = dev_name(dev);\n\tdata->desc.pctlops = &da850_pupd_pctlops;\n\tdata->desc.confops = &da850_pupd_confops;\n\tdata->desc.owner = THIS_MODULE;\n\n\tdata->pinctrl = devm_pinctrl_register(dev, &data->desc, data);\n\tif (IS_ERR(data->pinctrl)) {\n\t\tdev_err(dev, \"Failed to register pinctrl\\n\");\n\t\treturn PTR_ERR(data->pinctrl);\n\t}\n\n\tplatform_set_drvdata(pdev, data);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id da850_pupd_of_match[] = {\n\t{ .compatible = \"ti,da850-pupd\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, da850_pupd_of_match);\n\nstatic struct platform_driver da850_pupd_driver = {\n\t.driver\t= {\n\t\t.name\t\t= \"ti-da850-pupd\",\n\t\t.of_match_table\t= da850_pupd_of_match,\n\t},\n\t.probe\t= da850_pupd_probe,\n};\nmodule_platform_driver(da850_pupd_driver);\n\nMODULE_AUTHOR(\"David Lechner <david@lechnology.com>\");\nMODULE_DESCRIPTION(\"TI DA850/OMAP-L138/AM18XX pullup/pulldown configuration\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}