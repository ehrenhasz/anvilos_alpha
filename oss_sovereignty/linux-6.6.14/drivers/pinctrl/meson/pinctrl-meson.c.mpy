{
  "module_name": "pinctrl-meson.c",
  "hash_id": "6e7b72292bd14c1cbbd88f2e7b138d61fc399cbb836c47304309ab9bc17f0875",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/meson/pinctrl-meson.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/device.h>\n#include <linux/gpio/driver.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/pinctrl/pinconf-generic.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinmux.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/seq_file.h>\n\n#include \"../core.h\"\n#include \"../pinctrl-utils.h\"\n#include \"pinctrl-meson.h\"\n\nstatic const unsigned int meson_bit_strides[] = {\n\t1, 1, 1, 1, 1, 2, 1\n};\n\n \nstatic int meson_get_bank(struct meson_pinctrl *pc, unsigned int pin,\n\t\t\t  struct meson_bank **bank)\n{\n\tint i;\n\n\tfor (i = 0; i < pc->data->num_banks; i++) {\n\t\tif (pin >= pc->data->banks[i].first &&\n\t\t    pin <= pc->data->banks[i].last) {\n\t\t\t*bank = &pc->data->banks[i];\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\n \nstatic void meson_calc_reg_and_bit(struct meson_bank *bank, unsigned int pin,\n\t\t\t\t   enum meson_reg_type reg_type,\n\t\t\t\t   unsigned int *reg, unsigned int *bit)\n{\n\tstruct meson_reg_desc *desc = &bank->regs[reg_type];\n\n\t*bit = (desc->bit + pin - bank->first) * meson_bit_strides[reg_type];\n\t*reg = (desc->reg + (*bit / 32)) * 4;\n\t*bit &= 0x1f;\n}\n\nstatic int meson_get_groups_count(struct pinctrl_dev *pcdev)\n{\n\tstruct meson_pinctrl *pc = pinctrl_dev_get_drvdata(pcdev);\n\n\treturn pc->data->num_groups;\n}\n\nstatic const char *meson_get_group_name(struct pinctrl_dev *pcdev,\n\t\t\t\t\tunsigned selector)\n{\n\tstruct meson_pinctrl *pc = pinctrl_dev_get_drvdata(pcdev);\n\n\treturn pc->data->groups[selector].name;\n}\n\nstatic int meson_get_group_pins(struct pinctrl_dev *pcdev, unsigned selector,\n\t\t\t\tconst unsigned **pins, unsigned *num_pins)\n{\n\tstruct meson_pinctrl *pc = pinctrl_dev_get_drvdata(pcdev);\n\n\t*pins = pc->data->groups[selector].pins;\n\t*num_pins = pc->data->groups[selector].num_pins;\n\n\treturn 0;\n}\n\nstatic void meson_pin_dbg_show(struct pinctrl_dev *pcdev, struct seq_file *s,\n\t\t\t       unsigned offset)\n{\n\tseq_printf(s, \" %s\", dev_name(pcdev->dev));\n}\n\nstatic const struct pinctrl_ops meson_pctrl_ops = {\n\t.get_groups_count\t= meson_get_groups_count,\n\t.get_group_name\t\t= meson_get_group_name,\n\t.get_group_pins\t\t= meson_get_group_pins,\n\t.dt_node_to_map\t\t= pinconf_generic_dt_node_to_map_all,\n\t.dt_free_map\t\t= pinctrl_utils_free_map,\n\t.pin_dbg_show\t\t= meson_pin_dbg_show,\n};\n\nint meson_pmx_get_funcs_count(struct pinctrl_dev *pcdev)\n{\n\tstruct meson_pinctrl *pc = pinctrl_dev_get_drvdata(pcdev);\n\n\treturn pc->data->num_funcs;\n}\nEXPORT_SYMBOL_GPL(meson_pmx_get_funcs_count);\n\nconst char *meson_pmx_get_func_name(struct pinctrl_dev *pcdev,\n\t\t\t\t    unsigned selector)\n{\n\tstruct meson_pinctrl *pc = pinctrl_dev_get_drvdata(pcdev);\n\n\treturn pc->data->funcs[selector].name;\n}\nEXPORT_SYMBOL_GPL(meson_pmx_get_func_name);\n\nint meson_pmx_get_groups(struct pinctrl_dev *pcdev, unsigned selector,\n\t\t\t const char * const **groups,\n\t\t\t unsigned * const num_groups)\n{\n\tstruct meson_pinctrl *pc = pinctrl_dev_get_drvdata(pcdev);\n\n\t*groups = pc->data->funcs[selector].groups;\n\t*num_groups = pc->data->funcs[selector].num_groups;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(meson_pmx_get_groups);\n\nstatic int meson_pinconf_set_gpio_bit(struct meson_pinctrl *pc,\n\t\t\t\t      unsigned int pin,\n\t\t\t\t      unsigned int reg_type,\n\t\t\t\t      bool arg)\n{\n\tstruct meson_bank *bank;\n\tunsigned int reg, bit;\n\tint ret;\n\n\tret = meson_get_bank(pc, pin, &bank);\n\tif (ret)\n\t\treturn ret;\n\n\tmeson_calc_reg_and_bit(bank, pin, reg_type, &reg, &bit);\n\treturn regmap_update_bits(pc->reg_gpio, reg, BIT(bit),\n\t\t\t\t  arg ? BIT(bit) : 0);\n}\n\nstatic int meson_pinconf_get_gpio_bit(struct meson_pinctrl *pc,\n\t\t\t\t      unsigned int pin,\n\t\t\t\t      unsigned int reg_type)\n{\n\tstruct meson_bank *bank;\n\tunsigned int reg, bit, val;\n\tint ret;\n\n\tret = meson_get_bank(pc, pin, &bank);\n\tif (ret)\n\t\treturn ret;\n\n\tmeson_calc_reg_and_bit(bank, pin, reg_type, &reg, &bit);\n\tret = regmap_read(pc->reg_gpio, reg, &val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn BIT(bit) & val ? 1 : 0;\n}\n\nstatic int meson_pinconf_set_output(struct meson_pinctrl *pc,\n\t\t\t\t    unsigned int pin,\n\t\t\t\t    bool out)\n{\n\treturn meson_pinconf_set_gpio_bit(pc, pin, MESON_REG_DIR, !out);\n}\n\nstatic int meson_pinconf_get_output(struct meson_pinctrl *pc,\n\t\t\t\t    unsigned int pin)\n{\n\tint ret = meson_pinconf_get_gpio_bit(pc, pin, MESON_REG_DIR);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn !ret;\n}\n\nstatic int meson_pinconf_set_drive(struct meson_pinctrl *pc,\n\t\t\t\t   unsigned int pin,\n\t\t\t\t   bool high)\n{\n\treturn meson_pinconf_set_gpio_bit(pc, pin, MESON_REG_OUT, high);\n}\n\nstatic int meson_pinconf_get_drive(struct meson_pinctrl *pc,\n\t\t\t\t   unsigned int pin)\n{\n\treturn meson_pinconf_get_gpio_bit(pc, pin, MESON_REG_OUT);\n}\n\nstatic int meson_pinconf_set_output_drive(struct meson_pinctrl *pc,\n\t\t\t\t\t  unsigned int pin,\n\t\t\t\t\t  bool high)\n{\n\tint ret;\n\n\tret = meson_pinconf_set_output(pc, pin, true);\n\tif (ret)\n\t\treturn ret;\n\n\treturn meson_pinconf_set_drive(pc, pin, high);\n}\n\nstatic int meson_pinconf_disable_bias(struct meson_pinctrl *pc,\n\t\t\t\t      unsigned int pin)\n{\n\tstruct meson_bank *bank;\n\tunsigned int reg, bit = 0;\n\tint ret;\n\n\tret = meson_get_bank(pc, pin, &bank);\n\tif (ret)\n\t\treturn ret;\n\n\tmeson_calc_reg_and_bit(bank, pin, MESON_REG_PULLEN, &reg, &bit);\n\tret = regmap_update_bits(pc->reg_pullen, reg, BIT(bit), 0);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int meson_pinconf_enable_bias(struct meson_pinctrl *pc, unsigned int pin,\n\t\t\t\t     bool pull_up)\n{\n\tstruct meson_bank *bank;\n\tunsigned int reg, bit, val = 0;\n\tint ret;\n\n\tret = meson_get_bank(pc, pin, &bank);\n\tif (ret)\n\t\treturn ret;\n\n\tmeson_calc_reg_and_bit(bank, pin, MESON_REG_PULL, &reg, &bit);\n\tif (pull_up)\n\t\tval = BIT(bit);\n\n\tret = regmap_update_bits(pc->reg_pull, reg, BIT(bit), val);\n\tif (ret)\n\t\treturn ret;\n\n\tmeson_calc_reg_and_bit(bank, pin, MESON_REG_PULLEN, &reg, &bit);\n\tret = regmap_update_bits(pc->reg_pullen, reg, BIT(bit),\tBIT(bit));\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int meson_pinconf_set_drive_strength(struct meson_pinctrl *pc,\n\t\t\t\t\t    unsigned int pin,\n\t\t\t\t\t    u16 drive_strength_ua)\n{\n\tstruct meson_bank *bank;\n\tunsigned int reg, bit, ds_val;\n\tint ret;\n\n\tif (!pc->reg_ds) {\n\t\tdev_err(pc->dev, \"drive-strength not supported\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tret = meson_get_bank(pc, pin, &bank);\n\tif (ret)\n\t\treturn ret;\n\n\tmeson_calc_reg_and_bit(bank, pin, MESON_REG_DS, &reg, &bit);\n\n\tif (drive_strength_ua <= 500) {\n\t\tds_val = MESON_PINCONF_DRV_500UA;\n\t} else if (drive_strength_ua <= 2500) {\n\t\tds_val = MESON_PINCONF_DRV_2500UA;\n\t} else if (drive_strength_ua <= 3000) {\n\t\tds_val = MESON_PINCONF_DRV_3000UA;\n\t} else if (drive_strength_ua <= 4000) {\n\t\tds_val = MESON_PINCONF_DRV_4000UA;\n\t} else {\n\t\tdev_warn_once(pc->dev,\n\t\t\t      \"pin %u: invalid drive-strength : %d , default to 4mA\\n\",\n\t\t\t      pin, drive_strength_ua);\n\t\tds_val = MESON_PINCONF_DRV_4000UA;\n\t}\n\n\tret = regmap_update_bits(pc->reg_ds, reg, 0x3 << bit, ds_val << bit);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int meson_pinconf_set(struct pinctrl_dev *pcdev, unsigned int pin,\n\t\t\t     unsigned long *configs, unsigned num_configs)\n{\n\tstruct meson_pinctrl *pc = pinctrl_dev_get_drvdata(pcdev);\n\tenum pin_config_param param;\n\tunsigned int arg = 0;\n\tint i, ret;\n\n\tfor (i = 0; i < num_configs; i++) {\n\t\tparam = pinconf_to_config_param(configs[i]);\n\n\t\tswitch (param) {\n\t\tcase PIN_CONFIG_DRIVE_STRENGTH_UA:\n\t\tcase PIN_CONFIG_OUTPUT_ENABLE:\n\t\tcase PIN_CONFIG_OUTPUT:\n\t\t\targ = pinconf_to_config_argument(configs[i]);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (param) {\n\t\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\t\tret = meson_pinconf_disable_bias(pc, pin);\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\t\tret = meson_pinconf_enable_bias(pc, pin, true);\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\t\tret = meson_pinconf_enable_bias(pc, pin, false);\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_DRIVE_STRENGTH_UA:\n\t\t\tret = meson_pinconf_set_drive_strength(pc, pin, arg);\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_OUTPUT_ENABLE:\n\t\t\tret = meson_pinconf_set_output(pc, pin, arg);\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_OUTPUT:\n\t\t\tret = meson_pinconf_set_output_drive(pc, pin, arg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -ENOTSUPP;\n\t\t}\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int meson_pinconf_get_pull(struct meson_pinctrl *pc, unsigned int pin)\n{\n\tstruct meson_bank *bank;\n\tunsigned int reg, bit, val;\n\tint ret, conf;\n\n\tret = meson_get_bank(pc, pin, &bank);\n\tif (ret)\n\t\treturn ret;\n\n\tmeson_calc_reg_and_bit(bank, pin, MESON_REG_PULLEN, &reg, &bit);\n\n\tret = regmap_read(pc->reg_pullen, reg, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!(val & BIT(bit))) {\n\t\tconf = PIN_CONFIG_BIAS_DISABLE;\n\t} else {\n\t\tmeson_calc_reg_and_bit(bank, pin, MESON_REG_PULL, &reg, &bit);\n\n\t\tret = regmap_read(pc->reg_pull, reg, &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (val & BIT(bit))\n\t\t\tconf = PIN_CONFIG_BIAS_PULL_UP;\n\t\telse\n\t\t\tconf = PIN_CONFIG_BIAS_PULL_DOWN;\n\t}\n\n\treturn conf;\n}\n\nstatic int meson_pinconf_get_drive_strength(struct meson_pinctrl *pc,\n\t\t\t\t\t    unsigned int pin,\n\t\t\t\t\t    u16 *drive_strength_ua)\n{\n\tstruct meson_bank *bank;\n\tunsigned int reg, bit;\n\tunsigned int val;\n\tint ret;\n\n\tif (!pc->reg_ds)\n\t\treturn -ENOTSUPP;\n\n\tret = meson_get_bank(pc, pin, &bank);\n\tif (ret)\n\t\treturn ret;\n\n\tmeson_calc_reg_and_bit(bank, pin, MESON_REG_DS, &reg, &bit);\n\n\tret = regmap_read(pc->reg_ds, reg, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch ((val >> bit) & 0x3) {\n\tcase MESON_PINCONF_DRV_500UA:\n\t\t*drive_strength_ua = 500;\n\t\tbreak;\n\tcase MESON_PINCONF_DRV_2500UA:\n\t\t*drive_strength_ua = 2500;\n\t\tbreak;\n\tcase MESON_PINCONF_DRV_3000UA:\n\t\t*drive_strength_ua = 3000;\n\t\tbreak;\n\tcase MESON_PINCONF_DRV_4000UA:\n\t\t*drive_strength_ua = 4000;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int meson_pinconf_get(struct pinctrl_dev *pcdev, unsigned int pin,\n\t\t\t     unsigned long *config)\n{\n\tstruct meson_pinctrl *pc = pinctrl_dev_get_drvdata(pcdev);\n\tenum pin_config_param param = pinconf_to_config_param(*config);\n\tu16 arg;\n\tint ret;\n\n\tswitch (param) {\n\tcase PIN_CONFIG_BIAS_DISABLE:\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\tif (meson_pinconf_get_pull(pc, pin) == param)\n\t\t\targ = 1;\n\t\telse\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase PIN_CONFIG_DRIVE_STRENGTH_UA:\n\t\tret = meson_pinconf_get_drive_strength(pc, pin, &arg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase PIN_CONFIG_OUTPUT_ENABLE:\n\t\tret = meson_pinconf_get_output(pc, pin);\n\t\tif (ret <= 0)\n\t\t\treturn -EINVAL;\n\t\targ = 1;\n\t\tbreak;\n\tcase PIN_CONFIG_OUTPUT:\n\t\tret = meson_pinconf_get_output(pc, pin);\n\t\tif (ret <= 0)\n\t\t\treturn -EINVAL;\n\n\t\tret = meson_pinconf_get_drive(pc, pin);\n\t\tif (ret < 0)\n\t\t\treturn -EINVAL;\n\n\t\targ = ret;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\t*config = pinconf_to_config_packed(param, arg);\n\tdev_dbg(pc->dev, \"pinconf for pin %u is %lu\\n\", pin, *config);\n\n\treturn 0;\n}\n\nstatic int meson_pinconf_group_set(struct pinctrl_dev *pcdev,\n\t\t\t\t   unsigned int num_group,\n\t\t\t\t   unsigned long *configs, unsigned num_configs)\n{\n\tstruct meson_pinctrl *pc = pinctrl_dev_get_drvdata(pcdev);\n\tstruct meson_pmx_group *group = &pc->data->groups[num_group];\n\tint i;\n\n\tdev_dbg(pc->dev, \"set pinconf for group %s\\n\", group->name);\n\n\tfor (i = 0; i < group->num_pins; i++) {\n\t\tmeson_pinconf_set(pcdev, group->pins[i], configs,\n\t\t\t\t  num_configs);\n\t}\n\n\treturn 0;\n}\n\nstatic int meson_pinconf_group_get(struct pinctrl_dev *pcdev,\n\t\t\t\t   unsigned int group, unsigned long *config)\n{\n\treturn -ENOTSUPP;\n}\n\nstatic const struct pinconf_ops meson_pinconf_ops = {\n\t.pin_config_get\t\t= meson_pinconf_get,\n\t.pin_config_set\t\t= meson_pinconf_set,\n\t.pin_config_group_get\t= meson_pinconf_group_get,\n\t.pin_config_group_set\t= meson_pinconf_group_set,\n\t.is_generic\t\t= true,\n};\n\nstatic int meson_gpio_get_direction(struct gpio_chip *chip, unsigned gpio)\n{\n\tstruct meson_pinctrl *pc = gpiochip_get_data(chip);\n\tint ret;\n\n\tret = meson_pinconf_get_output(pc, gpio);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ret ? GPIO_LINE_DIRECTION_OUT : GPIO_LINE_DIRECTION_IN;\n}\n\nstatic int meson_gpio_direction_input(struct gpio_chip *chip, unsigned gpio)\n{\n\treturn meson_pinconf_set_output(gpiochip_get_data(chip), gpio, false);\n}\n\nstatic int meson_gpio_direction_output(struct gpio_chip *chip, unsigned gpio,\n\t\t\t\t       int value)\n{\n\treturn meson_pinconf_set_output_drive(gpiochip_get_data(chip),\n\t\t\t\t\t      gpio, value);\n}\n\nstatic void meson_gpio_set(struct gpio_chip *chip, unsigned gpio, int value)\n{\n\tmeson_pinconf_set_drive(gpiochip_get_data(chip), gpio, value);\n}\n\nstatic int meson_gpio_get(struct gpio_chip *chip, unsigned gpio)\n{\n\tstruct meson_pinctrl *pc = gpiochip_get_data(chip);\n\tunsigned int reg, bit, val;\n\tstruct meson_bank *bank;\n\tint ret;\n\n\tret = meson_get_bank(pc, gpio, &bank);\n\tif (ret)\n\t\treturn ret;\n\n\tmeson_calc_reg_and_bit(bank, gpio, MESON_REG_IN, &reg, &bit);\n\tregmap_read(pc->reg_gpio, reg, &val);\n\n\treturn !!(val & BIT(bit));\n}\n\nstatic int meson_gpiolib_register(struct meson_pinctrl *pc)\n{\n\tint ret;\n\n\tpc->chip.label = pc->data->name;\n\tpc->chip.parent = pc->dev;\n\tpc->chip.fwnode = pc->fwnode;\n\tpc->chip.request = gpiochip_generic_request;\n\tpc->chip.free = gpiochip_generic_free;\n\tpc->chip.set_config = gpiochip_generic_config;\n\tpc->chip.get_direction = meson_gpio_get_direction;\n\tpc->chip.direction_input = meson_gpio_direction_input;\n\tpc->chip.direction_output = meson_gpio_direction_output;\n\tpc->chip.get = meson_gpio_get;\n\tpc->chip.set = meson_gpio_set;\n\tpc->chip.base = -1;\n\tpc->chip.ngpio = pc->data->num_pins;\n\tpc->chip.can_sleep = false;\n\n\tret = gpiochip_add_data(&pc->chip, pc);\n\tif (ret) {\n\t\tdev_err(pc->dev, \"can't add gpio chip %s\\n\",\n\t\t\tpc->data->name);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic struct regmap_config meson_regmap_config = {\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n};\n\nstatic struct regmap *meson_map_resource(struct meson_pinctrl *pc,\n\t\t\t\t\t struct device_node *node, char *name)\n{\n\tstruct resource res;\n\tvoid __iomem *base;\n\tint i;\n\n\ti = of_property_match_string(node, \"reg-names\", name);\n\tif (of_address_to_resource(node, i, &res))\n\t\treturn NULL;\n\n\tbase = devm_ioremap_resource(pc->dev, &res);\n\tif (IS_ERR(base))\n\t\treturn ERR_CAST(base);\n\n\tmeson_regmap_config.max_register = resource_size(&res) - 4;\n\tmeson_regmap_config.name = devm_kasprintf(pc->dev, GFP_KERNEL,\n\t\t\t\t\t\t  \"%pOFn-%s\", node,\n\t\t\t\t\t\t  name);\n\tif (!meson_regmap_config.name)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\treturn devm_regmap_init_mmio(pc->dev, base, &meson_regmap_config);\n}\n\nstatic int meson_pinctrl_parse_dt(struct meson_pinctrl *pc)\n{\n\tstruct device_node *gpio_np;\n\tunsigned int chips;\n\n\tchips = gpiochip_node_count(pc->dev);\n\tif (!chips) {\n\t\tdev_err(pc->dev, \"no gpio node found\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (chips > 1) {\n\t\tdev_err(pc->dev, \"multiple gpio nodes\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpc->fwnode = gpiochip_node_get_first(pc->dev);\n\tgpio_np = to_of_node(pc->fwnode);\n\n\tpc->reg_mux = meson_map_resource(pc, gpio_np, \"mux\");\n\tif (IS_ERR_OR_NULL(pc->reg_mux)) {\n\t\tdev_err(pc->dev, \"mux registers not found\\n\");\n\t\treturn pc->reg_mux ? PTR_ERR(pc->reg_mux) : -ENOENT;\n\t}\n\n\tpc->reg_gpio = meson_map_resource(pc, gpio_np, \"gpio\");\n\tif (IS_ERR_OR_NULL(pc->reg_gpio)) {\n\t\tdev_err(pc->dev, \"gpio registers not found\\n\");\n\t\treturn pc->reg_gpio ? PTR_ERR(pc->reg_gpio) : -ENOENT;\n\t}\n\n\tpc->reg_pull = meson_map_resource(pc, gpio_np, \"pull\");\n\tif (IS_ERR(pc->reg_pull))\n\t\tpc->reg_pull = NULL;\n\n\tpc->reg_pullen = meson_map_resource(pc, gpio_np, \"pull-enable\");\n\tif (IS_ERR(pc->reg_pullen))\n\t\tpc->reg_pullen = NULL;\n\n\tpc->reg_ds = meson_map_resource(pc, gpio_np, \"ds\");\n\tif (IS_ERR(pc->reg_ds)) {\n\t\tdev_dbg(pc->dev, \"ds registers not found - skipping\\n\");\n\t\tpc->reg_ds = NULL;\n\t}\n\n\tif (pc->data->parse_dt)\n\t\treturn pc->data->parse_dt(pc);\n\n\treturn 0;\n}\n\nint meson8_aobus_parse_dt_extra(struct meson_pinctrl *pc)\n{\n\tif (!pc->reg_pull)\n\t\treturn -EINVAL;\n\n\tpc->reg_pullen = pc->reg_pull;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(meson8_aobus_parse_dt_extra);\n\nint meson_a1_parse_dt_extra(struct meson_pinctrl *pc)\n{\n\tpc->reg_pull = pc->reg_gpio;\n\tpc->reg_pullen = pc->reg_gpio;\n\tpc->reg_ds = pc->reg_gpio;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(meson_a1_parse_dt_extra);\n\nint meson_pinctrl_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct meson_pinctrl *pc;\n\tint ret;\n\n\tpc = devm_kzalloc(dev, sizeof(struct meson_pinctrl), GFP_KERNEL);\n\tif (!pc)\n\t\treturn -ENOMEM;\n\n\tpc->dev = dev;\n\tpc->data = (struct meson_pinctrl_data *) of_device_get_match_data(dev);\n\n\tret = meson_pinctrl_parse_dt(pc);\n\tif (ret)\n\t\treturn ret;\n\n\tpc->desc.name\t\t= \"pinctrl-meson\";\n\tpc->desc.owner\t\t= THIS_MODULE;\n\tpc->desc.pctlops\t= &meson_pctrl_ops;\n\tpc->desc.pmxops\t\t= pc->data->pmx_ops;\n\tpc->desc.confops\t= &meson_pinconf_ops;\n\tpc->desc.pins\t\t= pc->data->pins;\n\tpc->desc.npins\t\t= pc->data->num_pins;\n\n\tpc->pcdev = devm_pinctrl_register(pc->dev, &pc->desc, pc);\n\tif (IS_ERR(pc->pcdev)) {\n\t\tdev_err(pc->dev, \"can't register pinctrl device\");\n\t\treturn PTR_ERR(pc->pcdev);\n\t}\n\n\treturn meson_gpiolib_register(pc);\n}\nEXPORT_SYMBOL_GPL(meson_pinctrl_probe);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}