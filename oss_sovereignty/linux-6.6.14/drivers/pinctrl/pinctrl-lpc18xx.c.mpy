{
  "module_name": "pinctrl-lpc18xx.c",
  "hash_id": "43d9d4ec97362bb716626caa5d519eeda2d9c38ff994aefba09a0e1bbecd891d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/pinctrl-lpc18xx.c",
  "human_readable_source": " \n\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n\n#include <linux/pinctrl/pinconf-generic.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinmux.h>\n\n#include \"core.h\"\n#include \"pinctrl-utils.h\"\n\n \n#define LPC18XX_SCU_REG_ENAIO0\t\t0xc88\n#define LPC18XX_SCU_REG_ENAIO1\t\t0xc8c\n#define LPC18XX_SCU_REG_ENAIO2\t\t0xc90\n#define LPC18XX_SCU_REG_ENAIO2_DAC\tBIT(0)\n\n \n#define LPC18XX_SCU_PIN_MODE_MASK\t0x7\n#define LPC18XX_SCU_PIN_EPD\t\tBIT(3)\n#define LPC18XX_SCU_PIN_EPUN\t\tBIT(4)\n#define LPC18XX_SCU_PIN_EHS\t\tBIT(5)\n#define LPC18XX_SCU_PIN_EZI\t\tBIT(6)\n#define LPC18XX_SCU_PIN_ZIF\t\tBIT(7)\n#define LPC18XX_SCU_PIN_EHD_MASK\t0x300\n#define LPC18XX_SCU_PIN_EHD_POS\t\t8\n\n#define LPC18XX_SCU_USB1_EPD\t\tBIT(2)\n#define LPC18XX_SCU_USB1_EPWR\t\tBIT(4)\n\n#define LPC18XX_SCU_I2C0_EFP\t\tBIT(0)\n#define LPC18XX_SCU_I2C0_EHD\t\tBIT(2)\n#define LPC18XX_SCU_I2C0_EZI\t\tBIT(3)\n#define LPC18XX_SCU_I2C0_ZIF\t\tBIT(7)\n#define LPC18XX_SCU_I2C0_SCL_SHIFT\t0\n#define LPC18XX_SCU_I2C0_SDA_SHIFT\t8\n\n#define LPC18XX_SCU_FUNC_PER_PIN\t8\n\n \n#define LPC18XX_SCU_PINTSEL0\t\t0xe00\n#define LPC18XX_SCU_PINTSEL1\t\t0xe04\n#define LPC18XX_SCU_PINTSEL_VAL_MASK\t0xff\n#define LPC18XX_SCU_PINTSEL_PORT_SHIFT\t5\n#define LPC18XX_SCU_IRQ_PER_PINTSEL\t4\n#define LPC18XX_GPIO_PINS_PER_PORT\t32\n#define LPC18XX_GPIO_PIN_INT_MAX\t8\n\n#define LPC18XX_SCU_PINTSEL_VAL(val, n) \\\n\t((val) << (((n) % LPC18XX_SCU_IRQ_PER_PINTSEL) * 8))\n\n \nenum {\n\tTYPE_ND,\t \n\tTYPE_HD,\t \n\tTYPE_HS,\t \n\tTYPE_I2C0,\n\tTYPE_USB1,\n};\n\n \nenum {\n\tFUNC_R,\t\t \n\tFUNC_ADC,\n\tFUNC_ADCTRIG,\n\tFUNC_CAN0,\n\tFUNC_CAN1,\n\tFUNC_CGU_OUT,\n\tFUNC_CLKIN,\n\tFUNC_CLKOUT,\n\tFUNC_CTIN,\n\tFUNC_CTOUT,\n\tFUNC_DAC,\n\tFUNC_EMC,\n\tFUNC_EMC_ALT,\n\tFUNC_ENET,\n\tFUNC_ENET_ALT,\n\tFUNC_GPIO,\n\tFUNC_I2C0,\n\tFUNC_I2C1,\n\tFUNC_I2S0_RX_MCLK,\n\tFUNC_I2S0_RX_SCK,\n\tFUNC_I2S0_RX_SDA,\n\tFUNC_I2S0_RX_WS,\n\tFUNC_I2S0_TX_MCLK,\n\tFUNC_I2S0_TX_SCK,\n\tFUNC_I2S0_TX_SDA,\n\tFUNC_I2S0_TX_WS,\n\tFUNC_I2S1,\n\tFUNC_LCD,\n\tFUNC_LCD_ALT,\n\tFUNC_MCTRL,\n\tFUNC_NMI,\n\tFUNC_QEI,\n\tFUNC_SDMMC,\n\tFUNC_SGPIO,\n\tFUNC_SPI,\n\tFUNC_SPIFI,\n\tFUNC_SSP0,\n\tFUNC_SSP0_ALT,\n\tFUNC_SSP1,\n\tFUNC_TIMER0,\n\tFUNC_TIMER1,\n\tFUNC_TIMER2,\n\tFUNC_TIMER3,\n\tFUNC_TRACE,\n\tFUNC_UART0,\n\tFUNC_UART1,\n\tFUNC_UART2,\n\tFUNC_UART3,\n\tFUNC_USB0,\n\tFUNC_USB1,\n\tFUNC_MAX\n};\n\nstatic const char *const lpc18xx_function_names[] = {\n\t[FUNC_R]\t\t= \"reserved\",\n\t[FUNC_ADC]\t\t= \"adc\",\n\t[FUNC_ADCTRIG]\t\t= \"adctrig\",\n\t[FUNC_CAN0]\t\t= \"can0\",\n\t[FUNC_CAN1]\t\t= \"can1\",\n\t[FUNC_CGU_OUT]\t\t= \"cgu_out\",\n\t[FUNC_CLKIN]\t\t= \"clkin\",\n\t[FUNC_CLKOUT]\t\t= \"clkout\",\n\t[FUNC_CTIN]\t\t= \"ctin\",\n\t[FUNC_CTOUT]\t\t= \"ctout\",\n\t[FUNC_DAC]\t\t= \"dac\",\n\t[FUNC_EMC]\t\t= \"emc\",\n\t[FUNC_EMC_ALT]\t\t= \"emc_alt\",\n\t[FUNC_ENET]\t\t= \"enet\",\n\t[FUNC_ENET_ALT]\t\t= \"enet_alt\",\n\t[FUNC_GPIO]\t\t= \"gpio\",\n\t[FUNC_I2C0]\t\t= \"i2c0\",\n\t[FUNC_I2C1]\t\t= \"i2c1\",\n\t[FUNC_I2S0_RX_MCLK]\t= \"i2s0_rx_mclk\",\n\t[FUNC_I2S0_RX_SCK]\t= \"i2s0_rx_sck\",\n\t[FUNC_I2S0_RX_SDA]\t= \"i2s0_rx_sda\",\n\t[FUNC_I2S0_RX_WS]\t= \"i2s0_rx_ws\",\n\t[FUNC_I2S0_TX_MCLK]\t= \"i2s0_tx_mclk\",\n\t[FUNC_I2S0_TX_SCK]\t= \"i2s0_tx_sck\",\n\t[FUNC_I2S0_TX_SDA]\t= \"i2s0_tx_sda\",\n\t[FUNC_I2S0_TX_WS]\t= \"i2s0_tx_ws\",\n\t[FUNC_I2S1]\t\t= \"i2s1\",\n\t[FUNC_LCD]\t\t= \"lcd\",\n\t[FUNC_LCD_ALT]\t\t= \"lcd_alt\",\n\t[FUNC_MCTRL]\t\t= \"mctrl\",\n\t[FUNC_NMI]\t\t= \"nmi\",\n\t[FUNC_QEI]\t\t= \"qei\",\n\t[FUNC_SDMMC]\t\t= \"sdmmc\",\n\t[FUNC_SGPIO]\t\t= \"sgpio\",\n\t[FUNC_SPI]\t\t= \"spi\",\n\t[FUNC_SPIFI]\t\t= \"spifi\",\n\t[FUNC_SSP0]\t\t= \"ssp0\",\n\t[FUNC_SSP0_ALT]\t\t= \"ssp0_alt\",\n\t[FUNC_SSP1]\t\t= \"ssp1\",\n\t[FUNC_TIMER0]\t\t= \"timer0\",\n\t[FUNC_TIMER1]\t\t= \"timer1\",\n\t[FUNC_TIMER2]\t\t= \"timer2\",\n\t[FUNC_TIMER3]\t\t= \"timer3\",\n\t[FUNC_TRACE]\t\t= \"trace\",\n\t[FUNC_UART0]\t\t= \"uart0\",\n\t[FUNC_UART1]\t\t= \"uart1\",\n\t[FUNC_UART2]\t\t= \"uart2\",\n\t[FUNC_UART3]\t\t= \"uart3\",\n\t[FUNC_USB0]\t\t= \"usb0\",\n\t[FUNC_USB1]\t\t= \"usb1\",\n};\n\nstruct lpc18xx_pmx_func {\n\tconst char **groups;\n\tunsigned ngroups;\n};\n\nstruct lpc18xx_scu_data {\n\tstruct pinctrl_dev *pctl;\n\tvoid __iomem *base;\n\tstruct clk *clk;\n\tstruct lpc18xx_pmx_func func[FUNC_MAX];\n};\n\nstruct lpc18xx_pin_caps {\n\tunsigned int offset;\n\tunsigned char functions[LPC18XX_SCU_FUNC_PER_PIN];\n\tunsigned char analog;\n\tunsigned char type;\n};\n\n \n#define LPC18XX_SCU_ANALOG_PIN_CFG\t0x10\n\n \n#define LPC18XX_ANALOG_PIN\t\tBIT(7)\n#define LPC18XX_ANALOG_ADC(a)\t\t((a >> 5) & 0x3)\n#define LPC18XX_ANALOG_BIT_MASK\t\t0x1f\n#define ADC0\t\t\t\t(LPC18XX_ANALOG_PIN | (0x00 << 5))\n#define ADC1\t\t\t\t(LPC18XX_ANALOG_PIN | (0x01 << 5))\n#define DAC\t\t\t\tLPC18XX_ANALOG_PIN\n\n#define LPC_P(port, pin, f0, f1, f2, f3, f4, f5, f6, f7, a, t)\t\\\nstatic struct lpc18xx_pin_caps lpc18xx_pin_p##port##_##pin = {\t\\\n\t.offset = 0x##port * 32 * 4 + pin * 4,\t\t\t\\\n\t.functions = {\t\t\t\t\t\t\\\n\t\t\tFUNC_##f0, FUNC_##f1, FUNC_##f2,\t\\\n\t\t\tFUNC_##f3, FUNC_##f4, FUNC_##f5,\t\\\n\t\t\tFUNC_##f6, FUNC_##f7,\t\t\t\\\n\t},\t\t\t\t\t\t\t\\\n\t.analog = a,\t\t\t\t\t\t\\\n\t.type = TYPE_##t,\t\t\t\t\t\\\n}\n\n#define LPC_N(pname, off, f0, f1, f2, f3, f4, f5, f6, f7, a, t)\t\\\nstatic struct lpc18xx_pin_caps lpc18xx_pin_##pname = {\t\t\\\n\t.offset = off,\t\t\t\t\t\t\\\n\t.functions = {\t\t\t\t\t\t\\\n\t\t\tFUNC_##f0, FUNC_##f1, FUNC_##f2,\t\\\n\t\t\tFUNC_##f3, FUNC_##f4, FUNC_##f5,\t\\\n\t\t\tFUNC_##f6, FUNC_##f7,\t\t\t\\\n\t},\t\t\t\t\t\t\t\\\n\t.analog = a,\t\t\t\t\t\t\\\n\t.type = TYPE_##t,\t\t\t\t\t\\\n}\n\n\n \n \nLPC_P(0,0,   GPIO,  SSP1,  ENET,  SGPIO,      R,      R, I2S0_TX_WS,I2S1,     0, ND);\nLPC_P(0,1,   GPIO,  SSP1,ENET_ALT,SGPIO,      R,      R,   ENET,    I2S1,     0, ND);\nLPC_P(1,0,   GPIO,  CTIN,   EMC,      R,      R,   SSP0,  SGPIO,       R,     0, ND);\nLPC_P(1,1,   GPIO, CTOUT,   EMC,  SGPIO,      R,   SSP0,      R,       R,     0, ND);\nLPC_P(1,2,   GPIO, CTOUT,   EMC,  SGPIO,      R,   SSP0,      R,       R,     0, ND);\nLPC_P(1,3,   GPIO, CTOUT, SGPIO,    EMC,   USB0,   SSP1,      R,   SDMMC,     0, ND);\nLPC_P(1,4,   GPIO, CTOUT, SGPIO,    EMC,   USB0,   SSP1,      R,   SDMMC,     0, ND);\nLPC_P(1,5,   GPIO, CTOUT,     R,    EMC,   USB0,   SSP1,  SGPIO,   SDMMC,     0, ND);\nLPC_P(1,6,   GPIO,  CTIN,     R,    EMC,      R,      R,  SGPIO,   SDMMC,     0, ND);\nLPC_P(1,7,   GPIO, UART1, CTOUT,    EMC,   USB0,      R,      R,       R,     0, ND);\nLPC_P(1,8,   GPIO, UART1, CTOUT,    EMC,      R,      R,      R,   SDMMC,     0, ND);\nLPC_P(1,9,   GPIO, UART1, CTOUT,    EMC,      R,      R,      R,   SDMMC,     0, ND);\nLPC_P(1,10,  GPIO, UART1, CTOUT,    EMC,      R,      R,      R,   SDMMC,     0, ND);\nLPC_P(1,11,  GPIO, UART1, CTOUT,    EMC,      R,      R,      R,   SDMMC,     0, ND);\nLPC_P(1,12,  GPIO, UART1,     R,    EMC, TIMER0,      R,  SGPIO,   SDMMC,     0, ND);\nLPC_P(1,13,  GPIO, UART1,     R,    EMC, TIMER0,      R,  SGPIO,   SDMMC,     0, ND);\nLPC_P(1,14,  GPIO, UART1,     R,    EMC, TIMER0,      R,  SGPIO,       R,     0, ND);\nLPC_P(1,15,  GPIO, UART2, SGPIO,   ENET, TIMER0,      R,      R,       R,     0, ND);\nLPC_P(1,16,  GPIO, UART2, SGPIO,ENET_ALT,TIMER0,      R,      R,    ENET,     0, ND);\nLPC_P(1,17,  GPIO, UART2,     R,   ENET, TIMER0,   CAN1,  SGPIO,       R,     0, HD);\nLPC_P(1,18,  GPIO, UART2,     R,   ENET, TIMER0,   CAN1,  SGPIO,       R,     0, ND);\nLPC_P(1,19,  ENET,  SSP1,     R,      R, CLKOUT,      R, I2S0_RX_MCLK,I2S1,   0, ND);\nLPC_P(1,20,  GPIO,  SSP1,     R,   ENET, TIMER0,      R,  SGPIO,       R,     0, ND);\nLPC_P(2,0,  SGPIO, UART0,   EMC,   USB0,   GPIO,      R, TIMER3,    ENET,     0, ND);\nLPC_P(2,1,  SGPIO, UART0,   EMC,   USB0,   GPIO,      R, TIMER3,       R,     0, ND);\nLPC_P(2,2,  SGPIO, UART0,   EMC,   USB0,   GPIO,   CTIN, TIMER3,       R,     0, ND);\nLPC_P(2,3,  SGPIO,  I2C1, UART3,   CTIN,   GPIO,      R, TIMER3,    USB0,     0, HD);\nLPC_P(2,4,  SGPIO,  I2C1, UART3,   CTIN,   GPIO,      R, TIMER3,    USB0,     0, HD);\nLPC_P(2,5,  SGPIO,  CTIN,  USB1, ADCTRIG,  GPIO,      R, TIMER3,    USB0,     0, HD);\nLPC_P(2,6,  SGPIO, UART0,   EMC,   USB0,   GPIO,   CTIN, TIMER3,       R,     0, ND);\nLPC_P(2,7,   GPIO, CTOUT, UART3,    EMC,      R,      R, TIMER3,       R,     0, ND);\nLPC_P(2,8,  SGPIO, CTOUT, UART3,    EMC,   GPIO,      R,      R,       R,     0, ND);\nLPC_P(2,9,   GPIO, CTOUT, UART3,    EMC,      R,      R,      R,       R,     0, ND);\nLPC_P(2,10,  GPIO, CTOUT, UART2,    EMC,      R,      R,      R,       R,     0, ND);\nLPC_P(2,11,  GPIO, CTOUT, UART2,    EMC,      R,      R,      R,       R,     0, ND);\nLPC_P(2,12,  GPIO, CTOUT,     R,    EMC,      R,      R,      R,   UART2,     0, ND);\nLPC_P(2,13,  GPIO,  CTIN,     R,    EMC,      R,      R,      R,   UART2,     0, ND);\nLPC_P(3,0,  I2S0_RX_SCK, I2S0_RX_MCLK, I2S0_TX_SCK, I2S0_TX_MCLK,SSP0,R,R,R,  0, ND);\nLPC_P(3,1,  I2S0_TX_WS, I2S0_RX_WS,CAN0,USB1,GPIO,    R,    LCD,       R,     0, ND);\nLPC_P(3,2,  I2S0_TX_SDA, I2S0_RX_SDA,CAN0,USB1,GPIO,  R,    LCD,      R,      0, ND);\nLPC_P(3,3,      R,   SPI,  SSP0,  SPIFI, CGU_OUT,R, I2S0_TX_MCLK,  I2S1,      0, HS);\nLPC_P(3,4,   GPIO,     R,     R,  SPIFI,  UART1, I2S0_TX_WS, I2S1,  LCD,      0, ND);\nLPC_P(3,5,   GPIO,     R,     R,  SPIFI,  UART1, I2S0_TX_SDA,I2S1,  LCD,      0, ND);\nLPC_P(3,6,   GPIO,   SPI,  SSP0,  SPIFI,      R,  SSP0_ALT,   R,      R,      0, ND);\nLPC_P(3,7,      R,   SPI,  SSP0,  SPIFI,   GPIO,  SSP0_ALT,   R,      R,      0, ND);\nLPC_P(3,8,      R,   SPI,  SSP0,  SPIFI,   GPIO,  SSP0_ALT,   R,      R,      0, ND);\nLPC_P(4,0,   GPIO, MCTRL,   NMI,      R,      R,    LCD,  UART3,      R,      0, ND);\nLPC_P(4,1,   GPIO, CTOUT,   LCD,      R,      R, LCD_ALT, UART3,   ENET, ADC0|1, ND);\nLPC_P(4,2,   GPIO, CTOUT,   LCD,      R,      R, LCD_ALT, UART3,  SGPIO,      0, ND);\nLPC_P(4,3,   GPIO, CTOUT,   LCD,      R,      R, LCD_ALT, UART3,  SGPIO, ADC0|0, ND);\nLPC_P(4,4,   GPIO, CTOUT,   LCD,      R,      R, LCD_ALT, UART3,  SGPIO,    DAC, ND);\nLPC_P(4,5,   GPIO, CTOUT,   LCD,      R,      R,      R,      R,  SGPIO,      0, ND);\nLPC_P(4,6,   GPIO, CTOUT,   LCD,      R,      R,      R,      R,  SGPIO,      0, ND);\nLPC_P(4,7,    LCD, CLKIN,     R,      R,      R,      R,   I2S1,I2S0_TX_SCK,  0, ND);\nLPC_P(4,8,      R,  CTIN,   LCD,      R,   GPIO, LCD_ALT,  CAN1,  SGPIO,      0, ND);\nLPC_P(4,9,      R,  CTIN,   LCD,      R,   GPIO, LCD_ALT,  CAN1,  SGPIO,      0, ND);\nLPC_P(4,10,     R,  CTIN,   LCD,      R,   GPIO, LCD_ALT,     R,  SGPIO,      0, ND);\nLPC_P(5,0,   GPIO, MCTRL,   EMC,      R,  UART1, TIMER1,      R,      R,      0, ND);\nLPC_P(5,1,   GPIO, MCTRL,   EMC,      R,  UART1, TIMER1,      R,      R,      0, ND);\nLPC_P(5,2,   GPIO, MCTRL,   EMC,      R,  UART1, TIMER1,      R,      R,      0, ND);\nLPC_P(5,3,   GPIO, MCTRL,   EMC,      R,  UART1, TIMER1,      R,      R,      0, ND);\nLPC_P(5,4,   GPIO, MCTRL,   EMC,      R,  UART1, TIMER1,      R,      R,      0, ND);\nLPC_P(5,5,   GPIO, MCTRL,   EMC,      R,  UART1, TIMER1,      R,      R,      0, ND);\nLPC_P(5,6,   GPIO, MCTRL,   EMC,      R,  UART1, TIMER1,      R,      R,      0, ND);\nLPC_P(5,7,   GPIO, MCTRL,   EMC,      R,  UART1, TIMER1,      R,      R,      0, ND);\nLPC_P(6,0,      R, I2S0_RX_MCLK,R,    R, I2S0_RX_SCK, R,      R,      R,      0, ND);\nLPC_P(6,1,   GPIO,   EMC, UART0, I2S0_RX_WS,  R, TIMER2,      R,      R,      0, ND);\nLPC_P(6,2,   GPIO,   EMC, UART0, I2S0_RX_SDA, R, TIMER2,      R,      R,      0, ND);\nLPC_P(6,3,   GPIO,  USB0, SGPIO,    EMC,      R, TIMER2,      R,      R,      0, ND);\nLPC_P(6,4,   GPIO,  CTIN, UART0,    EMC,      R,      R,      R,      R,      0, ND);\nLPC_P(6,5,   GPIO, CTOUT, UART0,    EMC,      R,      R,      R,      R,      0, ND);\nLPC_P(6,6,   GPIO,   EMC, SGPIO,   USB0,      R, TIMER2,      R,      R,      0, ND);\nLPC_P(6,7,      R,   EMC, SGPIO,   USB0,   GPIO, TIMER2,      R,      R,      0, ND);\nLPC_P(6,8,      R,   EMC, SGPIO,   USB0,   GPIO, TIMER2,      R,      R,      0, ND);\nLPC_P(6,9,   GPIO,     R,     R,    EMC,      R, TIMER2,      R,      R,      0, ND);\nLPC_P(6,10,  GPIO, MCTRL,     R,    EMC,      R,      R,      R,      R,      0, ND);\nLPC_P(6,11,  GPIO,     R,     R,    EMC,      R, TIMER2,      R,      R,      0, ND);\nLPC_P(6,12,  GPIO, CTOUT,     R,    EMC,      R,      R,      R,      R,      0, ND);\nLPC_P(7,0,   GPIO, CTOUT,     R,    LCD,      R,      R,      R,  SGPIO,      0, ND);\nLPC_P(7,1,   GPIO, CTOUT,I2S0_TX_WS,LCD,LCD_ALT,      R,  UART2,  SGPIO,      0, ND);\nLPC_P(7,2,   GPIO, CTIN,I2S0_TX_SDA,LCD,LCD_ALT,      R,  UART2,  SGPIO,      0, ND);\nLPC_P(7,3,   GPIO, CTIN,      R,    LCD,LCD_ALT,      R,      R,      R,      0, ND);\nLPC_P(7,4,   GPIO, CTOUT,     R,    LCD,LCD_ALT,  TRACE,      R,      R, ADC0|4, ND);\nLPC_P(7,5,   GPIO, CTOUT,     R,    LCD,LCD_ALT,  TRACE,      R,      R, ADC0|3, ND);\nLPC_P(7,6,   GPIO, CTOUT,     R,    LCD,      R,  TRACE,      R,      R,      0, ND);\nLPC_P(7,7,   GPIO, CTOUT,     R,    LCD,      R,  TRACE,   ENET,  SGPIO, ADC1|6, ND);\nLPC_P(8,0,   GPIO,  USB0,     R,  MCTRL,  SGPIO,      R,      R, TIMER0,      0, HD);\nLPC_P(8,1,   GPIO,  USB0,     R,  MCTRL,  SGPIO,      R,      R, TIMER0,      0, HD);\nLPC_P(8,2,   GPIO,  USB0,     R,  MCTRL,  SGPIO,      R,      R, TIMER0,      0, HD);\nLPC_P(8,3,   GPIO,  USB1,     R,    LCD, LCD_ALT,     R,      R, TIMER0,      0, ND);\nLPC_P(8,4,   GPIO,  USB1,     R,    LCD, LCD_ALT,     R,      R, TIMER0,      0, ND);\nLPC_P(8,5,   GPIO,  USB1,     R,    LCD, LCD_ALT,     R,      R, TIMER0,      0, ND);\nLPC_P(8,6,   GPIO,  USB1,     R,    LCD, LCD_ALT,     R,      R, TIMER0,      0, ND);\nLPC_P(8,7,   GPIO,  USB1,     R,    LCD, LCD_ALT,     R,      R, TIMER0,      0, ND);\nLPC_P(8,8,      R,  USB1,     R,      R,      R,      R,CGU_OUT,   I2S1,      0, ND);\nLPC_P(9,0,   GPIO, MCTRL,     R,      R,      R,   ENET,  SGPIO,   SSP0,      0, ND);\nLPC_P(9,1,   GPIO, MCTRL,     R,      R, I2S0_TX_WS,ENET, SGPIO,   SSP0,      0, ND);\nLPC_P(9,2,   GPIO, MCTRL,     R,      R, I2S0_TX_SDA,ENET,SGPIO,   SSP0,      0, ND);\nLPC_P(9,3,   GPIO, MCTRL,  USB1,      R,      R,   ENET,  SGPIO,  UART3,      0, ND);\nLPC_P(9,4,      R, MCTRL,  USB1,      R,   GPIO,   ENET,  SGPIO,  UART3,      0, ND);\nLPC_P(9,5,      R, MCTRL,  USB1,      R,   GPIO,   ENET,  SGPIO,  UART0,      0, ND);\nLPC_P(9,6,   GPIO, MCTRL,  USB1,      R,      R,   ENET,  SGPIO,  UART0,      0, ND);\nLPC_P(a,0,      R,     R,     R,      R,      R,   I2S1, CGU_OUT,     R,      0, ND);\nLPC_P(a,1,   GPIO,   QEI,     R,  UART2,      R,      R,      R,      R,      0, HD);\nLPC_P(a,2,   GPIO,   QEI,     R,  UART2,      R,      R,      R,      R,      0, HD);\nLPC_P(a,3,   GPIO,   QEI,     R,      R,      R,      R,      R,      R,      0, HD);\nLPC_P(a,4,      R, CTOUT,     R,    EMC,   GPIO,      R,      R,      R,      0, ND);\nLPC_P(b,0,      R, CTOUT,   LCD,      R,   GPIO,      R,      R,      R,      0, ND);\nLPC_P(b,1,      R,  USB1,   LCD,      R,   GPIO,  CTOUT,      R,      R,      0, ND);\nLPC_P(b,2,      R,  USB1,   LCD,      R,   GPIO,  CTOUT,      R,      R,      0, ND);\nLPC_P(b,3,      R,  USB1,   LCD,      R,   GPIO,  CTOUT,      R,      R,      0, ND);\nLPC_P(b,4,      R,  USB1,   LCD,      R,   GPIO,   CTIN,      R,      R,      0, ND);\nLPC_P(b,5,      R,  USB1,   LCD,      R,   GPIO,   CTIN, LCD_ALT,     R,      0, ND);\nLPC_P(b,6,      R,  USB1,   LCD,      R,   GPIO,   CTIN, LCD_ALT,     R, ADC0|6, ND);\nLPC_P(c,0,      R,  USB1,     R,   ENET,    LCD,      R,      R,  SDMMC, ADC1|1, ND);\nLPC_P(c,1,   USB1,     R, UART1,   ENET,   GPIO,      R, TIMER3,  SDMMC,      0, ND);\nLPC_P(c,2,   USB1,     R, UART1,   ENET,   GPIO,      R,      R,  SDMMC,      0, ND);\nLPC_P(c,3,   USB1,     R, UART1,   ENET,   GPIO,      R,      R,  SDMMC, ADC1|0, ND);\nLPC_P(c,4,      R,  USB1,     R,   ENET,   GPIO,      R, TIMER3,  SDMMC,      0, ND);\nLPC_P(c,5,      R,  USB1,     R,   ENET,   GPIO,      R, TIMER3,  SDMMC,      0, ND);\nLPC_P(c,6,      R,  USB1,     R,   ENET,   GPIO,      R, TIMER3,  SDMMC,      0, ND);\nLPC_P(c,7,      R,  USB1,     R,   ENET,   GPIO,      R, TIMER3,  SDMMC,      0, ND);\nLPC_P(c,8,      R,  USB1,     R,   ENET,   GPIO,      R, TIMER3,  SDMMC,      0, ND);\nLPC_P(c,9,      R,  USB1,     R,   ENET,   GPIO,      R, TIMER3,  SDMMC,      0, ND);\nLPC_P(c,10,     R,  USB1, UART1,      R,   GPIO,      R, TIMER3,  SDMMC,      0, ND);\nLPC_P(c,11,     R,  USB1, UART1,      R,   GPIO,      R,      R,  SDMMC,      0, ND);\nLPC_P(c,12,     R,     R, UART1,      R,   GPIO,  SGPIO, I2S0_TX_SDA,SDMMC,   0, ND);\nLPC_P(c,13,     R,     R, UART1,      R,   GPIO,  SGPIO, I2S0_TX_WS, SDMMC,   0, ND);\nLPC_P(c,14,     R,     R, UART1,      R,   GPIO,  SGPIO,   ENET,  SDMMC,      0, ND);\nLPC_P(d,0,      R, CTOUT,   EMC,      R,   GPIO,      R,      R,  SGPIO,      0, ND);\nLPC_P(d,1,      R,     R,   EMC,      R,   GPIO,  SDMMC,      R,  SGPIO,      0, ND);\nLPC_P(d,2,      R, CTOUT,   EMC,      R,   GPIO,      R,      R,  SGPIO,      0, ND);\nLPC_P(d,3,      R, CTOUT,   EMC,      R,   GPIO,      R,      R,  SGPIO,      0, ND);\nLPC_P(d,4,      R, CTOUT,   EMC,      R,   GPIO,      R,      R,  SGPIO,      0, ND);\nLPC_P(d,5,      R, CTOUT,   EMC,      R,   GPIO,      R,      R,  SGPIO,      0, ND);\nLPC_P(d,6,      R, CTOUT,   EMC,      R,   GPIO,      R,      R,  SGPIO,      0, ND);\nLPC_P(d,7,      R,  CTIN,   EMC,      R,   GPIO,      R,      R,  SGPIO,      0, ND);\nLPC_P(d,8,      R,  CTIN,   EMC,      R,   GPIO,      R,      R,  SGPIO,      0, ND);\nLPC_P(d,9,      R, CTOUT,   EMC,      R,   GPIO,      R,      R,  SGPIO,      0, ND);\nLPC_P(d,10,     R,  CTIN,   EMC,      R,   GPIO,      R,      R,      R,      0, ND);\nLPC_P(d,11,     R,     R,   EMC,      R,   GPIO,   USB1,  CTOUT,      R,      0, ND);\nLPC_P(d,12,     R,     R,   EMC,      R,   GPIO,      R,  CTOUT,      R,      0, ND);\nLPC_P(d,13,     R,  CTIN,   EMC,      R,   GPIO,      R,  CTOUT,      R,      0, ND);\nLPC_P(d,14,     R,     R,   EMC,      R,   GPIO,      R,  CTOUT,      R,      0, ND);\nLPC_P(d,15,     R,     R,   EMC,      R,   GPIO,  SDMMC,  CTOUT,      R,      0, ND);\nLPC_P(d,16,     R,     R,   EMC,      R,   GPIO,  SDMMC,  CTOUT,      R,      0, ND);\nLPC_P(e,0,      R,     R,     R,    EMC,   GPIO,   CAN1,      R,      R,      0, ND);\nLPC_P(e,1,      R,     R,     R,    EMC,   GPIO,   CAN1,      R,      R,      0, ND);\nLPC_P(e,2,ADCTRIG,  CAN0,     R,    EMC,   GPIO,      R,      R,      R,      0, ND);\nLPC_P(e,3,      R,  CAN0,ADCTRIG,   EMC,   GPIO,      R,      R,      R,      0, ND);\nLPC_P(e,4,      R,   NMI,     R,    EMC,   GPIO,      R,      R,      R,      0, ND);\nLPC_P(e,5,      R, CTOUT, UART1,    EMC,   GPIO,      R,      R,      R,      0, ND);\nLPC_P(e,6,      R, CTOUT, UART1,    EMC,   GPIO,      R,      R,      R,      0, ND);\nLPC_P(e,7,      R, CTOUT, UART1,    EMC,   GPIO,      R,      R,      R,      0, ND);\nLPC_P(e,8,      R, CTOUT, UART1,    EMC,   GPIO,      R,      R,      R,      0, ND);\nLPC_P(e,9,      R,  CTIN, UART1,    EMC,   GPIO,      R,      R,      R,      0, ND);\nLPC_P(e,10,     R,  CTIN, UART1,    EMC,   GPIO,      R,      R,      R,      0, ND);\nLPC_P(e,11,     R, CTOUT, UART1,    EMC,   GPIO,      R,      R,      R,      0, ND);\nLPC_P(e,12,     R, CTOUT, UART1,    EMC,   GPIO,      R,      R,      R,      0, ND);\nLPC_P(e,13,     R, CTOUT,  I2C1,    EMC,   GPIO,      R,      R,      R,      0, ND);\nLPC_P(e,14,     R,     R,     R,    EMC,   GPIO,      R,      R,      R,      0, ND);\nLPC_P(e,15,     R, CTOUT,  I2C1,    EMC,   GPIO,      R,      R,      R,      0, ND);\nLPC_P(f,0,   SSP0, CLKIN,     R,      R,      R,      R,      R,   I2S1,      0, ND);\nLPC_P(f,1,      R,     R,  SSP0,      R,   GPIO,      R,  SGPIO,      R,      0, ND);\nLPC_P(f,2,      R, UART3,  SSP0,      R,   GPIO,      R,  SGPIO,      R,      0, ND);\nLPC_P(f,3,      R, UART3,  SSP0,      R,   GPIO,      R,  SGPIO,      R,      0, ND);\nLPC_P(f,4,   SSP1, CLKIN, TRACE,      R,      R, R, I2S0_TX_MCLK,I2S0_RX_SCK, 0, ND);\nLPC_P(f,5,      R, UART3,  SSP1,  TRACE,   GPIO,      R,  SGPIO,      R, ADC1|4, ND);\nLPC_P(f,6,      R, UART3,  SSP1,  TRACE,   GPIO,      R,  SGPIO,   I2S1, ADC1|3, ND);\nLPC_P(f,7,      R, UART3,  SSP1,  TRACE,   GPIO,      R,  SGPIO,   I2S1, ADC1|7, ND);\nLPC_P(f,8,      R, UART0,  CTIN,  TRACE,   GPIO,      R,  SGPIO,      R, ADC0|2, ND);\nLPC_P(f,9,      R, UART0, CTOUT,      R,   GPIO,      R,  SGPIO,      R, ADC1|2, ND);\nLPC_P(f,10,     R, UART0,     R,      R,   GPIO,      R,  SDMMC,      R, ADC0|5, ND);\nLPC_P(f,11,     R, UART0,     R,      R,   GPIO,      R,  SDMMC,      R, ADC1|5, ND);\n\n \nLPC_N(clk0,     0xc00, EMC, CLKOUT,   R,     R,  SDMMC,   EMC_ALT,  SSP1,      ENET,  0, HS);\nLPC_N(clk1,     0xc04, EMC, CLKOUT,   R,     R,      R,   CGU_OUT,   R,        I2S1,  0, HS);\nLPC_N(clk2,     0xc08, EMC, CLKOUT,   R,     R,  SDMMC,   EMC_ALT,I2S0_TX_MCLK,I2S1,  0, HS);\nLPC_N(clk3,     0xc0c, EMC, CLKOUT,   R,     R,      R,   CGU_OUT,   R,        I2S1,  0, HS);\nLPC_N(usb1_dm,  0xc80, R,      R,     R,     R,      R,      R,      R,          R,   0, USB1);\nLPC_N(usb1_dp,  0xc80, R,      R,     R,     R,      R,      R,      R,          R,   0, USB1);\nLPC_N(i2c0_scl, 0xc84, R,      R,     R,     R,      R,      R,      R,          R,   0, I2C0);\nLPC_N(i2c0_sda, 0xc84, R,      R,     R,     R,      R,      R,      R,          R,   0, I2C0);\n\n#define LPC18XX_PIN_P(port, pin) {\t\t\t\\\n\t.number = 0x##port * 32 + pin,\t\t\t\\\n\t.name = \"p\"#port\"_\"#pin,\t\t\t\\\n\t.drv_data = &lpc18xx_pin_p##port##_##pin \t\\\n}\n\n \nenum {\n\tPIN_CLK0 = 600,\n\tPIN_CLK1,\n\tPIN_CLK2,\n\tPIN_CLK3,\n\tPIN_USB1_DM,\n\tPIN_USB1_DP,\n\tPIN_I2C0_SCL,\n\tPIN_I2C0_SDA,\n};\n\n#define LPC18XX_PIN(pname, n) {\t\t\t\t\\\n\t.number = n,\t\t\t\t\t\\\n\t.name = #pname,\t\t\t\t\t\\\n\t.drv_data = &lpc18xx_pin_##pname \t\t\\\n}\n\nstatic const struct pinctrl_pin_desc lpc18xx_pins[] = {\n\tLPC18XX_PIN_P(0,0),\n\tLPC18XX_PIN_P(0,1),\n\tLPC18XX_PIN_P(1,0),\n\tLPC18XX_PIN_P(1,1),\n\tLPC18XX_PIN_P(1,2),\n\tLPC18XX_PIN_P(1,3),\n\tLPC18XX_PIN_P(1,4),\n\tLPC18XX_PIN_P(1,5),\n\tLPC18XX_PIN_P(1,6),\n\tLPC18XX_PIN_P(1,7),\n\tLPC18XX_PIN_P(1,8),\n\tLPC18XX_PIN_P(1,9),\n\tLPC18XX_PIN_P(1,10),\n\tLPC18XX_PIN_P(1,11),\n\tLPC18XX_PIN_P(1,12),\n\tLPC18XX_PIN_P(1,13),\n\tLPC18XX_PIN_P(1,14),\n\tLPC18XX_PIN_P(1,15),\n\tLPC18XX_PIN_P(1,16),\n\tLPC18XX_PIN_P(1,17),\n\tLPC18XX_PIN_P(1,18),\n\tLPC18XX_PIN_P(1,19),\n\tLPC18XX_PIN_P(1,20),\n\tLPC18XX_PIN_P(2,0),\n\tLPC18XX_PIN_P(2,1),\n\tLPC18XX_PIN_P(2,2),\n\tLPC18XX_PIN_P(2,3),\n\tLPC18XX_PIN_P(2,4),\n\tLPC18XX_PIN_P(2,5),\n\tLPC18XX_PIN_P(2,6),\n\tLPC18XX_PIN_P(2,7),\n\tLPC18XX_PIN_P(2,8),\n\tLPC18XX_PIN_P(2,9),\n\tLPC18XX_PIN_P(2,10),\n\tLPC18XX_PIN_P(2,11),\n\tLPC18XX_PIN_P(2,12),\n\tLPC18XX_PIN_P(2,13),\n\tLPC18XX_PIN_P(3,0),\n\tLPC18XX_PIN_P(3,1),\n\tLPC18XX_PIN_P(3,2),\n\tLPC18XX_PIN_P(3,3),\n\tLPC18XX_PIN_P(3,4),\n\tLPC18XX_PIN_P(3,5),\n\tLPC18XX_PIN_P(3,6),\n\tLPC18XX_PIN_P(3,7),\n\tLPC18XX_PIN_P(3,8),\n\tLPC18XX_PIN_P(4,0),\n\tLPC18XX_PIN_P(4,1),\n\tLPC18XX_PIN_P(4,2),\n\tLPC18XX_PIN_P(4,3),\n\tLPC18XX_PIN_P(4,4),\n\tLPC18XX_PIN_P(4,5),\n\tLPC18XX_PIN_P(4,6),\n\tLPC18XX_PIN_P(4,7),\n\tLPC18XX_PIN_P(4,8),\n\tLPC18XX_PIN_P(4,9),\n\tLPC18XX_PIN_P(4,10),\n\tLPC18XX_PIN_P(5,0),\n\tLPC18XX_PIN_P(5,1),\n\tLPC18XX_PIN_P(5,2),\n\tLPC18XX_PIN_P(5,3),\n\tLPC18XX_PIN_P(5,4),\n\tLPC18XX_PIN_P(5,5),\n\tLPC18XX_PIN_P(5,6),\n\tLPC18XX_PIN_P(5,7),\n\tLPC18XX_PIN_P(6,0),\n\tLPC18XX_PIN_P(6,1),\n\tLPC18XX_PIN_P(6,2),\n\tLPC18XX_PIN_P(6,3),\n\tLPC18XX_PIN_P(6,4),\n\tLPC18XX_PIN_P(6,5),\n\tLPC18XX_PIN_P(6,6),\n\tLPC18XX_PIN_P(6,7),\n\tLPC18XX_PIN_P(6,8),\n\tLPC18XX_PIN_P(6,9),\n\tLPC18XX_PIN_P(6,10),\n\tLPC18XX_PIN_P(6,11),\n\tLPC18XX_PIN_P(6,12),\n\tLPC18XX_PIN_P(7,0),\n\tLPC18XX_PIN_P(7,1),\n\tLPC18XX_PIN_P(7,2),\n\tLPC18XX_PIN_P(7,3),\n\tLPC18XX_PIN_P(7,4),\n\tLPC18XX_PIN_P(7,5),\n\tLPC18XX_PIN_P(7,6),\n\tLPC18XX_PIN_P(7,7),\n\tLPC18XX_PIN_P(8,0),\n\tLPC18XX_PIN_P(8,1),\n\tLPC18XX_PIN_P(8,2),\n\tLPC18XX_PIN_P(8,3),\n\tLPC18XX_PIN_P(8,4),\n\tLPC18XX_PIN_P(8,5),\n\tLPC18XX_PIN_P(8,6),\n\tLPC18XX_PIN_P(8,7),\n\tLPC18XX_PIN_P(8,8),\n\tLPC18XX_PIN_P(9,0),\n\tLPC18XX_PIN_P(9,1),\n\tLPC18XX_PIN_P(9,2),\n\tLPC18XX_PIN_P(9,3),\n\tLPC18XX_PIN_P(9,4),\n\tLPC18XX_PIN_P(9,5),\n\tLPC18XX_PIN_P(9,6),\n\tLPC18XX_PIN_P(a,0),\n\tLPC18XX_PIN_P(a,1),\n\tLPC18XX_PIN_P(a,2),\n\tLPC18XX_PIN_P(a,3),\n\tLPC18XX_PIN_P(a,4),\n\tLPC18XX_PIN_P(b,0),\n\tLPC18XX_PIN_P(b,1),\n\tLPC18XX_PIN_P(b,2),\n\tLPC18XX_PIN_P(b,3),\n\tLPC18XX_PIN_P(b,4),\n\tLPC18XX_PIN_P(b,5),\n\tLPC18XX_PIN_P(b,6),\n\tLPC18XX_PIN_P(c,0),\n\tLPC18XX_PIN_P(c,1),\n\tLPC18XX_PIN_P(c,2),\n\tLPC18XX_PIN_P(c,3),\n\tLPC18XX_PIN_P(c,4),\n\tLPC18XX_PIN_P(c,5),\n\tLPC18XX_PIN_P(c,6),\n\tLPC18XX_PIN_P(c,7),\n\tLPC18XX_PIN_P(c,8),\n\tLPC18XX_PIN_P(c,9),\n\tLPC18XX_PIN_P(c,10),\n\tLPC18XX_PIN_P(c,11),\n\tLPC18XX_PIN_P(c,12),\n\tLPC18XX_PIN_P(c,13),\n\tLPC18XX_PIN_P(c,14),\n\tLPC18XX_PIN_P(d,0),\n\tLPC18XX_PIN_P(d,1),\n\tLPC18XX_PIN_P(d,2),\n\tLPC18XX_PIN_P(d,3),\n\tLPC18XX_PIN_P(d,4),\n\tLPC18XX_PIN_P(d,5),\n\tLPC18XX_PIN_P(d,6),\n\tLPC18XX_PIN_P(d,7),\n\tLPC18XX_PIN_P(d,8),\n\tLPC18XX_PIN_P(d,9),\n\tLPC18XX_PIN_P(d,10),\n\tLPC18XX_PIN_P(d,11),\n\tLPC18XX_PIN_P(d,12),\n\tLPC18XX_PIN_P(d,13),\n\tLPC18XX_PIN_P(d,14),\n\tLPC18XX_PIN_P(d,15),\n\tLPC18XX_PIN_P(d,16),\n\tLPC18XX_PIN_P(e,0),\n\tLPC18XX_PIN_P(e,1),\n\tLPC18XX_PIN_P(e,2),\n\tLPC18XX_PIN_P(e,3),\n\tLPC18XX_PIN_P(e,4),\n\tLPC18XX_PIN_P(e,5),\n\tLPC18XX_PIN_P(e,6),\n\tLPC18XX_PIN_P(e,7),\n\tLPC18XX_PIN_P(e,8),\n\tLPC18XX_PIN_P(e,9),\n\tLPC18XX_PIN_P(e,10),\n\tLPC18XX_PIN_P(e,11),\n\tLPC18XX_PIN_P(e,12),\n\tLPC18XX_PIN_P(e,13),\n\tLPC18XX_PIN_P(e,14),\n\tLPC18XX_PIN_P(e,15),\n\tLPC18XX_PIN_P(f,0),\n\tLPC18XX_PIN_P(f,1),\n\tLPC18XX_PIN_P(f,2),\n\tLPC18XX_PIN_P(f,3),\n\tLPC18XX_PIN_P(f,4),\n\tLPC18XX_PIN_P(f,5),\n\tLPC18XX_PIN_P(f,6),\n\tLPC18XX_PIN_P(f,7),\n\tLPC18XX_PIN_P(f,8),\n\tLPC18XX_PIN_P(f,9),\n\tLPC18XX_PIN_P(f,10),\n\tLPC18XX_PIN_P(f,11),\n\n\tLPC18XX_PIN(clk0, PIN_CLK0),\n\tLPC18XX_PIN(clk1, PIN_CLK1),\n\tLPC18XX_PIN(clk2, PIN_CLK2),\n\tLPC18XX_PIN(clk3, PIN_CLK3),\n\tLPC18XX_PIN(usb1_dm,  PIN_USB1_DM),\n\tLPC18XX_PIN(usb1_dp,  PIN_USB1_DP),\n\tLPC18XX_PIN(i2c0_scl, PIN_I2C0_SCL),\n\tLPC18XX_PIN(i2c0_sda, PIN_I2C0_SDA),\n};\n\n \n#define PIN_CONFIG_GPIO_PIN_INT\t\t(PIN_CONFIG_END + 1)\n\nstatic const struct pinconf_generic_params lpc18xx_params[] = {\n\t{\"nxp,gpio-pin-interrupt\", PIN_CONFIG_GPIO_PIN_INT, 0},\n};\n\n#ifdef CONFIG_DEBUG_FS\nstatic const struct pin_config_item lpc18xx_conf_items[ARRAY_SIZE(lpc18xx_params)] = {\n\tPCONFDUMP(PIN_CONFIG_GPIO_PIN_INT, \"gpio pin int\", NULL, true),\n};\n#endif\n\nstatic int lpc18xx_pconf_get_usb1(enum pin_config_param param, int *arg, u32 reg)\n{\n\tswitch (param) {\n\tcase PIN_CONFIG_MODE_LOW_POWER:\n\t\tif (reg & LPC18XX_SCU_USB1_EPWR)\n\t\t\t*arg = 0;\n\t\telse\n\t\t\t*arg = 1;\n\t\tbreak;\n\n\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\tif (reg & LPC18XX_SCU_USB1_EPD)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\tif (reg & LPC18XX_SCU_USB1_EPD)\n\t\t\t*arg = 1;\n\t\telse\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int lpc18xx_pconf_get_i2c0(enum pin_config_param param, int *arg, u32 reg,\n\t\t\t\t  unsigned pin)\n{\n\tu8 shift;\n\n\tif (pin == PIN_I2C0_SCL)\n\t\tshift = LPC18XX_SCU_I2C0_SCL_SHIFT;\n\telse\n\t\tshift = LPC18XX_SCU_I2C0_SDA_SHIFT;\n\n\tswitch (param) {\n\tcase PIN_CONFIG_INPUT_ENABLE:\n\t\tif (reg & (LPC18XX_SCU_I2C0_EZI << shift))\n\t\t\t*arg = 1;\n\t\telse\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\tcase PIN_CONFIG_SLEW_RATE:\n\t\tif (reg & (LPC18XX_SCU_I2C0_EHD << shift))\n\t\t\t*arg = 1;\n\t\telse\n\t\t\t*arg = 0;\n\t\tbreak;\n\n\tcase PIN_CONFIG_INPUT_SCHMITT:\n\t\tif (reg & (LPC18XX_SCU_I2C0_EFP << shift))\n\t\t\t*arg = 3;\n\t\telse\n\t\t\t*arg = 50;\n\t\tbreak;\n\n\tcase PIN_CONFIG_INPUT_SCHMITT_ENABLE:\n\t\tif (reg & (LPC18XX_SCU_I2C0_ZIF << shift))\n\t\t\treturn -EINVAL;\n\t\telse\n\t\t\t*arg = 1;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int lpc18xx_pin_to_gpio(struct pinctrl_dev *pctldev, unsigned pin)\n{\n\tstruct pinctrl_gpio_range *range;\n\n\trange = pinctrl_find_gpio_range_from_pin_nolock(pctldev, pin);\n\tif (!range)\n\t\treturn -EINVAL;\n\n\treturn pin - range->pin_base + range->base;\n}\n\nstatic int lpc18xx_get_pintsel(void __iomem *addr, u32 val, int *arg)\n{\n\tu32 reg_val;\n\tint i;\n\n\treg_val = readl(addr);\n\tfor (i = 0; i < LPC18XX_SCU_IRQ_PER_PINTSEL; i++) {\n\t\tif ((reg_val & LPC18XX_SCU_PINTSEL_VAL_MASK) == val)\n\t\t\treturn 0;\n\n\t\treg_val >>= BITS_PER_BYTE;\n\t\t*arg += 1;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic u32 lpc18xx_gpio_to_pintsel_val(int gpio)\n{\n\tunsigned int gpio_port, gpio_pin;\n\n\tgpio_port = gpio / LPC18XX_GPIO_PINS_PER_PORT;\n\tgpio_pin  = gpio % LPC18XX_GPIO_PINS_PER_PORT;\n\n\treturn gpio_pin | (gpio_port << LPC18XX_SCU_PINTSEL_PORT_SHIFT);\n}\n\nstatic int lpc18xx_pconf_get_gpio_pin_int(struct pinctrl_dev *pctldev,\n\t\t\t\t\t  int *arg, unsigned pin)\n{\n\tstruct lpc18xx_scu_data *scu = pinctrl_dev_get_drvdata(pctldev);\n\tint gpio, ret;\n\tu32 val;\n\n\tgpio = lpc18xx_pin_to_gpio(pctldev, pin);\n\tif (gpio < 0)\n\t\treturn -ENOTSUPP;\n\n\tval = lpc18xx_gpio_to_pintsel_val(gpio);\n\n\t \n\t*arg = 0;\n\tret = lpc18xx_get_pintsel(scu->base + LPC18XX_SCU_PINTSEL0, val, arg);\n\tif (ret == 0)\n\t\treturn ret;\n\n\treturn lpc18xx_get_pintsel(scu->base + LPC18XX_SCU_PINTSEL1, val, arg);\n}\n\nstatic int lpc18xx_pconf_get_pin(struct pinctrl_dev *pctldev, unsigned param,\n\t\t\t\t int *arg, u32 reg, unsigned pin,\n\t\t\t\t struct lpc18xx_pin_caps *pin_cap)\n{\n\tswitch (param) {\n\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\tif ((!(reg & LPC18XX_SCU_PIN_EPD)) && (reg & LPC18XX_SCU_PIN_EPUN))\n\t\t\t;\n\t\telse\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\tif (reg & LPC18XX_SCU_PIN_EPUN)\n\t\t\treturn -EINVAL;\n\t\telse\n\t\t\t*arg = 1;\n\t\tbreak;\n\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\tif (reg & LPC18XX_SCU_PIN_EPD)\n\t\t\t*arg = 1;\n\t\telse\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\tcase PIN_CONFIG_INPUT_ENABLE:\n\t\tif (reg & LPC18XX_SCU_PIN_EZI)\n\t\t\t*arg = 1;\n\t\telse\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\tcase PIN_CONFIG_SLEW_RATE:\n\t\tif (pin_cap->type == TYPE_HD)\n\t\t\treturn -ENOTSUPP;\n\n\t\tif (reg & LPC18XX_SCU_PIN_EHS)\n\t\t\t*arg = 1;\n\t\telse\n\t\t\t*arg = 0;\n\t\tbreak;\n\n\tcase PIN_CONFIG_INPUT_SCHMITT_ENABLE:\n\t\tif (reg & LPC18XX_SCU_PIN_ZIF)\n\t\t\treturn -EINVAL;\n\t\telse\n\t\t\t*arg = 1;\n\t\tbreak;\n\n\tcase PIN_CONFIG_DRIVE_STRENGTH:\n\t\tif (pin_cap->type != TYPE_HD)\n\t\t\treturn -ENOTSUPP;\n\n\t\t*arg = (reg & LPC18XX_SCU_PIN_EHD_MASK) >> LPC18XX_SCU_PIN_EHD_POS;\n\t\tswitch (*arg) {\n\t\tcase 3: *arg += 5;\n\t\t\tfallthrough;\n\t\tcase 2: *arg += 5;\n\t\t\tfallthrough;\n\t\tcase 1: *arg += 3;\n\t\t\tfallthrough;\n\t\tcase 0: *arg += 4;\n\t\t}\n\t\tbreak;\n\n\tcase PIN_CONFIG_GPIO_PIN_INT:\n\t\treturn lpc18xx_pconf_get_gpio_pin_int(pctldev, arg, pin);\n\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic struct lpc18xx_pin_caps *lpc18xx_get_pin_caps(unsigned pin)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(lpc18xx_pins); i++) {\n\t\tif (lpc18xx_pins[i].number == pin)\n\t\t\treturn lpc18xx_pins[i].drv_data;\n\t}\n\n\treturn NULL;\n}\n\nstatic int lpc18xx_pconf_get(struct pinctrl_dev *pctldev, unsigned pin,\n\t\t\t     unsigned long *config)\n{\n\tstruct lpc18xx_scu_data *scu = pinctrl_dev_get_drvdata(pctldev);\n\tenum pin_config_param param = pinconf_to_config_param(*config);\n\tstruct lpc18xx_pin_caps *pin_cap;\n\tint ret, arg = 0;\n\tu32 reg;\n\n\tpin_cap = lpc18xx_get_pin_caps(pin);\n\tif (!pin_cap)\n\t\treturn -EINVAL;\n\n\treg = readl(scu->base + pin_cap->offset);\n\n\tif (pin_cap->type == TYPE_I2C0)\n\t\tret = lpc18xx_pconf_get_i2c0(param, &arg, reg, pin);\n\telse if (pin_cap->type == TYPE_USB1)\n\t\tret = lpc18xx_pconf_get_usb1(param, &arg, reg);\n\telse\n\t\tret = lpc18xx_pconf_get_pin(pctldev, param, &arg, reg, pin, pin_cap);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*config = pinconf_to_config_packed(param, (u16)arg);\n\n\treturn 0;\n}\n\nstatic int lpc18xx_pconf_set_usb1(struct pinctrl_dev *pctldev,\n\t\t\t\t  enum pin_config_param param,\n\t\t\t\t  u32 param_val, u32 *reg)\n{\n\tswitch (param) {\n\tcase PIN_CONFIG_MODE_LOW_POWER:\n\t\tif (param_val)\n\t\t\t*reg &= ~LPC18XX_SCU_USB1_EPWR;\n\t\telse\n\t\t\t*reg |= LPC18XX_SCU_USB1_EPWR;\n\t\tbreak;\n\n\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\t*reg &= ~LPC18XX_SCU_USB1_EPD;\n\t\tbreak;\n\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\t*reg |= LPC18XX_SCU_USB1_EPD;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(pctldev->dev, \"Property not supported\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int lpc18xx_pconf_set_i2c0(struct pinctrl_dev *pctldev,\n\t\t\t\t  enum pin_config_param param,\n\t\t\t\t  u32 param_val, u32 *reg,\n\t\t\t\t  unsigned pin)\n{\n\tu8 shift;\n\n\tif (pin == PIN_I2C0_SCL)\n\t\tshift = LPC18XX_SCU_I2C0_SCL_SHIFT;\n\telse\n\t\tshift = LPC18XX_SCU_I2C0_SDA_SHIFT;\n\n\tswitch (param) {\n\tcase PIN_CONFIG_INPUT_ENABLE:\n\t\tif (param_val)\n\t\t\t*reg |= (LPC18XX_SCU_I2C0_EZI << shift);\n\t\telse\n\t\t\t*reg &= ~(LPC18XX_SCU_I2C0_EZI << shift);\n\t\tbreak;\n\n\tcase PIN_CONFIG_SLEW_RATE:\n\t\tif (param_val)\n\t\t\t*reg |= (LPC18XX_SCU_I2C0_EHD << shift);\n\t\telse\n\t\t\t*reg &= ~(LPC18XX_SCU_I2C0_EHD << shift);\n\t\tbreak;\n\n\tcase PIN_CONFIG_INPUT_SCHMITT:\n\t\tif (param_val == 3)\n\t\t\t*reg |= (LPC18XX_SCU_I2C0_EFP << shift);\n\t\telse if (param_val == 50)\n\t\t\t*reg &= ~(LPC18XX_SCU_I2C0_EFP << shift);\n\t\telse\n\t\t\treturn -ENOTSUPP;\n\t\tbreak;\n\n\tcase PIN_CONFIG_INPUT_SCHMITT_ENABLE:\n\t\tif (param_val)\n\t\t\t*reg &= ~(LPC18XX_SCU_I2C0_ZIF << shift);\n\t\telse\n\t\t\t*reg |= (LPC18XX_SCU_I2C0_ZIF << shift);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(pctldev->dev, \"Property not supported\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int lpc18xx_pconf_set_gpio_pin_int(struct pinctrl_dev *pctldev,\n\t\t\t\t\t  u32 param_val, unsigned pin)\n{\n\tstruct lpc18xx_scu_data *scu = pinctrl_dev_get_drvdata(pctldev);\n\tu32 val, reg_val, reg_offset = LPC18XX_SCU_PINTSEL0;\n\tint gpio;\n\n\tif (param_val >= LPC18XX_GPIO_PIN_INT_MAX)\n\t\treturn -EINVAL;\n\n\tgpio = lpc18xx_pin_to_gpio(pctldev, pin);\n\tif (gpio < 0)\n\t\treturn -ENOTSUPP;\n\n\tval = lpc18xx_gpio_to_pintsel_val(gpio);\n\n\treg_offset += (param_val / LPC18XX_SCU_IRQ_PER_PINTSEL) * sizeof(u32);\n\n\treg_val = readl(scu->base + reg_offset);\n\treg_val &= ~LPC18XX_SCU_PINTSEL_VAL(LPC18XX_SCU_PINTSEL_VAL_MASK, param_val);\n\treg_val |= LPC18XX_SCU_PINTSEL_VAL(val, param_val);\n\twritel(reg_val, scu->base + reg_offset);\n\n\treturn 0;\n}\n\nstatic int lpc18xx_pconf_set_pin(struct pinctrl_dev *pctldev, unsigned param,\n\t\t\t\t u32 param_val, u32 *reg, unsigned pin,\n\t\t\t\t struct lpc18xx_pin_caps *pin_cap)\n{\n\tswitch (param) {\n\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\t*reg &= ~LPC18XX_SCU_PIN_EPD;\n\t\t*reg |= LPC18XX_SCU_PIN_EPUN;\n\t\tbreak;\n\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\t*reg &= ~LPC18XX_SCU_PIN_EPUN;\n\t\tbreak;\n\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\t*reg |= LPC18XX_SCU_PIN_EPD;\n\t\tbreak;\n\n\tcase PIN_CONFIG_INPUT_ENABLE:\n\t\tif (param_val)\n\t\t\t*reg |= LPC18XX_SCU_PIN_EZI;\n\t\telse\n\t\t\t*reg &= ~LPC18XX_SCU_PIN_EZI;\n\t\tbreak;\n\n\tcase PIN_CONFIG_SLEW_RATE:\n\t\tif (pin_cap->type == TYPE_HD) {\n\t\t\tdev_err(pctldev->dev, \"Slew rate unsupported on high-drive pins\\n\");\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\n\t\tif (param_val == 0)\n\t\t\t*reg &= ~LPC18XX_SCU_PIN_EHS;\n\t\telse\n\t\t\t*reg |= LPC18XX_SCU_PIN_EHS;\n\t\tbreak;\n\n\tcase PIN_CONFIG_INPUT_SCHMITT_ENABLE:\n\t\tif (param_val)\n\t\t\t*reg &= ~LPC18XX_SCU_PIN_ZIF;\n\t\telse\n\t\t\t*reg |= LPC18XX_SCU_PIN_ZIF;\n\t\tbreak;\n\n\tcase PIN_CONFIG_DRIVE_STRENGTH:\n\t\tif (pin_cap->type != TYPE_HD) {\n\t\t\tdev_err(pctldev->dev, \"Drive strength available only on high-drive pins\\n\");\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t\t*reg &= ~LPC18XX_SCU_PIN_EHD_MASK;\n\n\t\tswitch (param_val) {\n\t\tcase 20: param_val -= 5;\n\t\t\tfallthrough;\n\t\tcase 14: param_val -= 5;\n\t\t\tfallthrough;\n\t\tcase  8: param_val -= 3;\n\t\t\tfallthrough;\n\t\tcase  4: param_val -= 4;\n\t\t\t break;\n\t\tdefault:\n\t\t\tdev_err(pctldev->dev, \"Drive strength %u unsupported\\n\", param_val);\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t\t*reg |= param_val << LPC18XX_SCU_PIN_EHD_POS;\n\t\tbreak;\n\n\tcase PIN_CONFIG_GPIO_PIN_INT:\n\t\treturn lpc18xx_pconf_set_gpio_pin_int(pctldev, param_val, pin);\n\n\tdefault:\n\t\tdev_err(pctldev->dev, \"Property not supported\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int lpc18xx_pconf_set(struct pinctrl_dev *pctldev, unsigned pin,\n\t\t\t     unsigned long *configs, unsigned num_configs)\n{\n\tstruct lpc18xx_scu_data *scu = pinctrl_dev_get_drvdata(pctldev);\n\tstruct lpc18xx_pin_caps *pin_cap;\n\tenum pin_config_param param;\n\tu32 param_val;\n\tu32 reg;\n\tint ret;\n\tint i;\n\n\tpin_cap = lpc18xx_get_pin_caps(pin);\n\tif (!pin_cap)\n\t\treturn -EINVAL;\n\n\treg = readl(scu->base + pin_cap->offset);\n\n\tfor (i = 0; i < num_configs; i++) {\n\t\tparam = pinconf_to_config_param(configs[i]);\n\t\tparam_val = pinconf_to_config_argument(configs[i]);\n\n\t\tif (pin_cap->type == TYPE_I2C0)\n\t\t\tret = lpc18xx_pconf_set_i2c0(pctldev, param, param_val, &reg, pin);\n\t\telse if (pin_cap->type == TYPE_USB1)\n\t\t\tret = lpc18xx_pconf_set_usb1(pctldev, param, param_val, &reg);\n\t\telse\n\t\t\tret = lpc18xx_pconf_set_pin(pctldev, param, param_val, &reg, pin, pin_cap);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\twritel(reg, scu->base + pin_cap->offset);\n\n\treturn 0;\n}\n\nstatic const struct pinconf_ops lpc18xx_pconf_ops = {\n\t.is_generic\t= true,\n\t.pin_config_get\t= lpc18xx_pconf_get,\n\t.pin_config_set\t= lpc18xx_pconf_set,\n};\n\nstatic int lpc18xx_pmx_get_funcs_count(struct pinctrl_dev *pctldev)\n{\n\treturn ARRAY_SIZE(lpc18xx_function_names);\n}\n\nstatic const char *lpc18xx_pmx_get_func_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t     unsigned function)\n{\n\treturn lpc18xx_function_names[function];\n}\n\nstatic int lpc18xx_pmx_get_func_groups(struct pinctrl_dev *pctldev,\n\t\t\t\t       unsigned function,\n\t\t\t\t       const char *const **groups,\n\t\t\t\t       unsigned *const num_groups)\n{\n\tstruct lpc18xx_scu_data *scu = pinctrl_dev_get_drvdata(pctldev);\n\n\t*groups  = scu->func[function].groups;\n\t*num_groups = scu->func[function].ngroups;\n\n\treturn 0;\n}\n\nstatic int lpc18xx_pmx_set(struct pinctrl_dev *pctldev, unsigned function,\n\t\t\t   unsigned group)\n{\n\tstruct lpc18xx_scu_data *scu = pinctrl_dev_get_drvdata(pctldev);\n\tstruct lpc18xx_pin_caps *pin = lpc18xx_pins[group].drv_data;\n\tint func;\n\tu32 reg;\n\n\t \n\tif (pin->type == TYPE_USB1) {\n\t\tif (function == FUNC_USB1)\n\t\t\treturn 0;\n\n\t\tgoto fail;\n\t}\n\n\tif (pin->type == TYPE_I2C0) {\n\t\tif (function == FUNC_I2C0)\n\t\t\treturn 0;\n\n\t\tgoto fail;\n\t}\n\n\tif (function == FUNC_ADC && (pin->analog & LPC18XX_ANALOG_PIN)) {\n\t\tu32 offset;\n\n\t\twritel(LPC18XX_SCU_ANALOG_PIN_CFG, scu->base + pin->offset);\n\n\t\tif (LPC18XX_ANALOG_ADC(pin->analog) == 0)\n\t\t\toffset = LPC18XX_SCU_REG_ENAIO0;\n\t\telse\n\t\t\toffset = LPC18XX_SCU_REG_ENAIO1;\n\n\t\treg = readl(scu->base + offset);\n\t\treg |= pin->analog & LPC18XX_ANALOG_BIT_MASK;\n\t\twritel(reg, scu->base + offset);\n\n\t\treturn 0;\n\t}\n\n\tif (function == FUNC_DAC && (pin->analog & LPC18XX_ANALOG_PIN)) {\n\t\twritel(LPC18XX_SCU_ANALOG_PIN_CFG, scu->base + pin->offset);\n\n\t\treg = readl(scu->base + LPC18XX_SCU_REG_ENAIO2);\n\t\treg |= LPC18XX_SCU_REG_ENAIO2_DAC;\n\t\twritel(reg, scu->base + LPC18XX_SCU_REG_ENAIO2);\n\n\t\treturn 0;\n\t}\n\n\tfor (func = 0; func < LPC18XX_SCU_FUNC_PER_PIN; func++) {\n\t\tif (function == pin->functions[func])\n\t\t\tbreak;\n\t}\n\n\tif (func >= LPC18XX_SCU_FUNC_PER_PIN)\n\t\tgoto fail;\n\n\treg = readl(scu->base + pin->offset);\n\treg &= ~LPC18XX_SCU_PIN_MODE_MASK;\n\twritel(reg | func, scu->base + pin->offset);\n\n\treturn 0;\nfail:\n\tdev_err(pctldev->dev, \"Pin %s can't be %s\\n\", lpc18xx_pins[group].name,\n\t\t\t\t\t\t      lpc18xx_function_names[function]);\n\treturn -EINVAL;\n}\n\nstatic const struct pinmux_ops lpc18xx_pmx_ops = {\n\t.get_functions_count\t= lpc18xx_pmx_get_funcs_count,\n\t.get_function_name\t= lpc18xx_pmx_get_func_name,\n\t.get_function_groups\t= lpc18xx_pmx_get_func_groups,\n\t.set_mux\t\t= lpc18xx_pmx_set,\n};\n\nstatic int lpc18xx_pctl_get_groups_count(struct pinctrl_dev *pctldev)\n{\n\treturn ARRAY_SIZE(lpc18xx_pins);\n}\n\nstatic const char *lpc18xx_pctl_get_group_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t       unsigned group)\n{\n\treturn lpc18xx_pins[group].name;\n}\n\nstatic int lpc18xx_pctl_get_group_pins(struct pinctrl_dev *pctldev,\n\t\t\t\t       unsigned group,\n\t\t\t\t       const unsigned **pins,\n\t\t\t\t       unsigned *num_pins)\n{\n\t*pins = &lpc18xx_pins[group].number;\n\t*num_pins = 1;\n\n\treturn 0;\n}\n\nstatic const struct pinctrl_ops lpc18xx_pctl_ops = {\n\t.get_groups_count\t= lpc18xx_pctl_get_groups_count,\n\t.get_group_name\t\t= lpc18xx_pctl_get_group_name,\n\t.get_group_pins\t\t= lpc18xx_pctl_get_group_pins,\n\t.dt_node_to_map\t\t= pinconf_generic_dt_node_to_map_pin,\n\t.dt_free_map\t\t= pinctrl_utils_free_map,\n};\n\nstatic struct pinctrl_desc lpc18xx_scu_desc = {\n\t.name = \"lpc18xx/43xx-scu\",\n\t.pins = lpc18xx_pins,\n\t.npins = ARRAY_SIZE(lpc18xx_pins),\n\t.pctlops = &lpc18xx_pctl_ops,\n\t.pmxops = &lpc18xx_pmx_ops,\n\t.confops = &lpc18xx_pconf_ops,\n\t.num_custom_params = ARRAY_SIZE(lpc18xx_params),\n\t.custom_params = lpc18xx_params,\n#ifdef CONFIG_DEBUG_FS\n\t.custom_conf_items = lpc18xx_conf_items,\n#endif\n\t.owner = THIS_MODULE,\n};\n\nstatic bool lpc18xx_valid_pin_function(unsigned pin, unsigned function)\n{\n\tstruct lpc18xx_pin_caps *p = lpc18xx_pins[pin].drv_data;\n\tint i;\n\n\tif (function == FUNC_DAC && p->analog == DAC)\n\t\treturn true;\n\n\tif (function == FUNC_ADC && p->analog)\n\t\treturn true;\n\n\tif (function == FUNC_I2C0 && p->type == TYPE_I2C0)\n\t\treturn true;\n\n\tif (function == FUNC_USB1 && p->type == TYPE_USB1)\n\t\treturn true;\n\n\tfor (i = 0; i < LPC18XX_SCU_FUNC_PER_PIN; i++) {\n\t\tif (function == p->functions[i])\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int lpc18xx_create_group_func_map(struct device *dev,\n\t\t\t\t\t struct lpc18xx_scu_data *scu)\n{\n\tu16 pins[ARRAY_SIZE(lpc18xx_pins)];\n\tint func, ngroups, i;\n\n\tfor (func = 0; func < FUNC_MAX; func++) {\n\t\tfor (ngroups = 0, i = 0; i < ARRAY_SIZE(lpc18xx_pins); i++) {\n\t\t\tif (lpc18xx_valid_pin_function(i, func))\n\t\t\t\tpins[ngroups++] = i;\n\t\t}\n\n\t\tscu->func[func].ngroups = ngroups;\n\t\tscu->func[func].groups = devm_kcalloc(dev,\n\t\t\t\t\t\t      ngroups, sizeof(char *),\n\t\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!scu->func[func].groups)\n\t\t\treturn -ENOMEM;\n\n\t\tfor (i = 0; i < ngroups; i++)\n\t\t\tscu->func[func].groups[i] = lpc18xx_pins[pins[i]].name;\n\t}\n\n\treturn 0;\n}\n\nstatic int lpc18xx_scu_probe(struct platform_device *pdev)\n{\n\tstruct lpc18xx_scu_data *scu;\n\tint ret;\n\n\tscu = devm_kzalloc(&pdev->dev, sizeof(*scu), GFP_KERNEL);\n\tif (!scu)\n\t\treturn -ENOMEM;\n\n\tscu->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(scu->base))\n\t\treturn PTR_ERR(scu->base);\n\n\tscu->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(scu->clk)) {\n\t\tdev_err(&pdev->dev, \"Input clock not found.\\n\");\n\t\treturn PTR_ERR(scu->clk);\n\t}\n\n\tret = lpc18xx_create_group_func_map(&pdev->dev, scu);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Unable to create group func map.\\n\");\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(scu->clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Unable to enable clock.\\n\");\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, scu);\n\n\tscu->pctl = devm_pinctrl_register(&pdev->dev, &lpc18xx_scu_desc, scu);\n\tif (IS_ERR(scu->pctl)) {\n\t\tdev_err(&pdev->dev, \"Could not register pinctrl driver\\n\");\n\t\tclk_disable_unprepare(scu->clk);\n\t\treturn PTR_ERR(scu->pctl);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id lpc18xx_scu_match[] = {\n\t{ .compatible = \"nxp,lpc1850-scu\" },\n\t{},\n};\n\nstatic struct platform_driver lpc18xx_scu_driver = {\n\t.probe\t\t= lpc18xx_scu_probe,\n\t.driver = {\n\t\t.name\t\t= \"lpc18xx-scu\",\n\t\t.of_match_table\t= lpc18xx_scu_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n};\nbuiltin_platform_driver(lpc18xx_scu_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}