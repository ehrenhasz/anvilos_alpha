{
  "module_name": "pinconf.c",
  "hash_id": "732156a4ea9053e2b640853fd1fa88f6a6422080fe0f843dacacb6d093e6813b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/pinconf.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) \"pinconfig core: \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/slab.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/pinctrl/machine.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinconf.h>\n#include \"core.h\"\n#include \"pinconf.h\"\n\nint pinconf_check_ops(struct pinctrl_dev *pctldev)\n{\n\tconst struct pinconf_ops *ops = pctldev->desc->confops;\n\n\t \n\tif (!ops->pin_config_set && !ops->pin_config_group_set) {\n\t\tdev_err(pctldev->dev,\n\t\t\t\"pinconf has to be able to set a pins config\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nint pinconf_validate_map(const struct pinctrl_map *map, int i)\n{\n\tif (!map->data.configs.group_or_pin) {\n\t\tpr_err(\"failed to register map %s (%d): no group/pin given\\n\",\n\t\t       map->name, i);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!map->data.configs.num_configs ||\n\t\t\t!map->data.configs.configs) {\n\t\tpr_err(\"failed to register map %s (%d): no configs given\\n\",\n\t\t       map->name, i);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint pin_config_get_for_pin(struct pinctrl_dev *pctldev, unsigned pin,\n\t\t\t   unsigned long *config)\n{\n\tconst struct pinconf_ops *ops = pctldev->desc->confops;\n\n\tif (!ops || !ops->pin_config_get) {\n\t\tdev_dbg(pctldev->dev,\n\t\t\t\"cannot get pin configuration, .pin_config_get missing in driver\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn ops->pin_config_get(pctldev, pin, config);\n}\n\nint pin_config_group_get(const char *dev_name, const char *pin_group,\n\t\t\t unsigned long *config)\n{\n\tstruct pinctrl_dev *pctldev;\n\tconst struct pinconf_ops *ops;\n\tint selector, ret;\n\n\tpctldev = get_pinctrl_dev_from_devname(dev_name);\n\tif (!pctldev) {\n\t\tret = -EINVAL;\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&pctldev->mutex);\n\n\tops = pctldev->desc->confops;\n\n\tif (!ops || !ops->pin_config_group_get) {\n\t\tdev_dbg(pctldev->dev,\n\t\t\t\"cannot get configuration for pin group, missing group config get function in driver\\n\");\n\t\tret = -ENOTSUPP;\n\t\tgoto unlock;\n\t}\n\n\tselector = pinctrl_get_group_selector(pctldev, pin_group);\n\tif (selector < 0) {\n\t\tret = selector;\n\t\tgoto unlock;\n\t}\n\n\tret = ops->pin_config_group_get(pctldev, selector, config);\n\nunlock:\n\tmutex_unlock(&pctldev->mutex);\n\treturn ret;\n}\n\nint pinconf_map_to_setting(const struct pinctrl_map *map,\n\t\t\t  struct pinctrl_setting *setting)\n{\n\tstruct pinctrl_dev *pctldev = setting->pctldev;\n\tint pin;\n\n\tswitch (setting->type) {\n\tcase PIN_MAP_TYPE_CONFIGS_PIN:\n\t\tpin = pin_get_from_name(pctldev,\n\t\t\t\t\tmap->data.configs.group_or_pin);\n\t\tif (pin < 0) {\n\t\t\tdev_err(pctldev->dev, \"could not map pin config for \\\"%s\\\"\",\n\t\t\t\tmap->data.configs.group_or_pin);\n\t\t\treturn pin;\n\t\t}\n\t\tsetting->data.configs.group_or_pin = pin;\n\t\tbreak;\n\tcase PIN_MAP_TYPE_CONFIGS_GROUP:\n\t\tpin = pinctrl_get_group_selector(pctldev,\n\t\t\t\t\t map->data.configs.group_or_pin);\n\t\tif (pin < 0) {\n\t\t\tdev_err(pctldev->dev, \"could not map group config for \\\"%s\\\"\",\n\t\t\t\tmap->data.configs.group_or_pin);\n\t\t\treturn pin;\n\t\t}\n\t\tsetting->data.configs.group_or_pin = pin;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsetting->data.configs.num_configs = map->data.configs.num_configs;\n\tsetting->data.configs.configs = map->data.configs.configs;\n\n\treturn 0;\n}\n\nvoid pinconf_free_setting(const struct pinctrl_setting *setting)\n{\n}\n\nint pinconf_apply_setting(const struct pinctrl_setting *setting)\n{\n\tstruct pinctrl_dev *pctldev = setting->pctldev;\n\tconst struct pinconf_ops *ops = pctldev->desc->confops;\n\tint ret;\n\n\tif (!ops) {\n\t\tdev_err(pctldev->dev, \"missing confops\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (setting->type) {\n\tcase PIN_MAP_TYPE_CONFIGS_PIN:\n\t\tif (!ops->pin_config_set) {\n\t\t\tdev_err(pctldev->dev, \"missing pin_config_set op\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tret = ops->pin_config_set(pctldev,\n\t\t\t\tsetting->data.configs.group_or_pin,\n\t\t\t\tsetting->data.configs.configs,\n\t\t\t\tsetting->data.configs.num_configs);\n\t\tif (ret < 0) {\n\t\t\tdev_err(pctldev->dev,\n\t\t\t\t\"pin_config_set op failed for pin %d\\n\",\n\t\t\t\tsetting->data.configs.group_or_pin);\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tcase PIN_MAP_TYPE_CONFIGS_GROUP:\n\t\tif (!ops->pin_config_group_set) {\n\t\t\tdev_err(pctldev->dev,\n\t\t\t\t\"missing pin_config_group_set op\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tret = ops->pin_config_group_set(pctldev,\n\t\t\t\tsetting->data.configs.group_or_pin,\n\t\t\t\tsetting->data.configs.configs,\n\t\t\t\tsetting->data.configs.num_configs);\n\t\tif (ret < 0) {\n\t\t\tdev_err(pctldev->dev,\n\t\t\t\t\"pin_config_group_set op failed for group %d\\n\",\n\t\t\t\tsetting->data.configs.group_or_pin);\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint pinconf_set_config(struct pinctrl_dev *pctldev, unsigned pin,\n\t\t       unsigned long *configs, size_t nconfigs)\n{\n\tconst struct pinconf_ops *ops;\n\n\tops = pctldev->desc->confops;\n\tif (!ops || !ops->pin_config_set)\n\t\treturn -ENOTSUPP;\n\n\treturn ops->pin_config_set(pctldev, pin, configs, nconfigs);\n}\n\n#ifdef CONFIG_DEBUG_FS\n\nstatic void pinconf_show_config(struct seq_file *s, struct pinctrl_dev *pctldev,\n\t\t      unsigned long *configs, unsigned num_configs)\n{\n\tconst struct pinconf_ops *confops;\n\tint i;\n\n\tif (pctldev)\n\t\tconfops = pctldev->desc->confops;\n\telse\n\t\tconfops = NULL;\n\n\tfor (i = 0; i < num_configs; i++) {\n\t\tseq_puts(s, \"config \");\n\t\tif (confops && confops->pin_config_config_dbg_show)\n\t\t\tconfops->pin_config_config_dbg_show(pctldev, s,\n\t\t\t\t\t\t\t    configs[i]);\n\t\telse\n\t\t\tseq_printf(s, \"%08lx\", configs[i]);\n\t\tseq_putc(s, '\\n');\n\t}\n}\n\nvoid pinconf_show_map(struct seq_file *s, const struct pinctrl_map *map)\n{\n\tstruct pinctrl_dev *pctldev;\n\n\tpctldev = get_pinctrl_dev_from_devname(map->ctrl_dev_name);\n\n\tswitch (map->type) {\n\tcase PIN_MAP_TYPE_CONFIGS_PIN:\n\t\tseq_puts(s, \"pin \");\n\t\tbreak;\n\tcase PIN_MAP_TYPE_CONFIGS_GROUP:\n\t\tseq_puts(s, \"group \");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tseq_printf(s, \"%s\\n\", map->data.configs.group_or_pin);\n\n\tpinconf_show_config(s, pctldev, map->data.configs.configs,\n\t\t\t    map->data.configs.num_configs);\n}\n\nvoid pinconf_show_setting(struct seq_file *s,\n\t\t\t  const struct pinctrl_setting *setting)\n{\n\tstruct pinctrl_dev *pctldev = setting->pctldev;\n\tconst struct pinctrl_ops *pctlops = pctldev->desc->pctlops;\n\tstruct pin_desc *desc;\n\n\tswitch (setting->type) {\n\tcase PIN_MAP_TYPE_CONFIGS_PIN:\n\t\tdesc = pin_desc_get(setting->pctldev,\n\t\t\t\t    setting->data.configs.group_or_pin);\n\t\tseq_printf(s, \"pin %s (%d)\", desc->name,\n\t\t\t   setting->data.configs.group_or_pin);\n\t\tbreak;\n\tcase PIN_MAP_TYPE_CONFIGS_GROUP:\n\t\tseq_printf(s, \"group %s (%d)\",\n\t\t\t   pctlops->get_group_name(pctldev,\n\t\t\t\t\tsetting->data.configs.group_or_pin),\n\t\t\t   setting->data.configs.group_or_pin);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tpinconf_show_config(s, pctldev, setting->data.configs.configs,\n\t\t\t    setting->data.configs.num_configs);\n}\n\nstatic void pinconf_dump_pin(struct pinctrl_dev *pctldev,\n\t\t\t     struct seq_file *s, int pin)\n{\n\tconst struct pinconf_ops *ops = pctldev->desc->confops;\n\n\t \n\tpinconf_generic_dump_pins(pctldev, s, NULL, pin);\n\tif (ops && ops->pin_config_dbg_show)\n\t\tops->pin_config_dbg_show(pctldev, s, pin);\n}\n\nstatic int pinconf_pins_show(struct seq_file *s, void *what)\n{\n\tstruct pinctrl_dev *pctldev = s->private;\n\tunsigned i, pin;\n\n\tseq_puts(s, \"Pin config settings per pin\\n\");\n\tseq_puts(s, \"Format: pin (name): configs\\n\");\n\n\tmutex_lock(&pctldev->mutex);\n\n\t \n\tfor (i = 0; i < pctldev->desc->npins; i++) {\n\t\tstruct pin_desc *desc;\n\n\t\tpin = pctldev->desc->pins[i].number;\n\t\tdesc = pin_desc_get(pctldev, pin);\n\t\t \n\t\tif (!desc)\n\t\t\tcontinue;\n\n\t\tseq_printf(s, \"pin %d (%s): \", pin, desc->name);\n\n\t\tpinconf_dump_pin(pctldev, s, pin);\n\t\tseq_putc(s, '\\n');\n\t}\n\n\tmutex_unlock(&pctldev->mutex);\n\n\treturn 0;\n}\n\nstatic void pinconf_dump_group(struct pinctrl_dev *pctldev,\n\t\t\t       struct seq_file *s, unsigned selector,\n\t\t\t       const char *gname)\n{\n\tconst struct pinconf_ops *ops = pctldev->desc->confops;\n\n\t \n\tpinconf_generic_dump_pins(pctldev, s, gname, 0);\n\tif (ops && ops->pin_config_group_dbg_show)\n\t\tops->pin_config_group_dbg_show(pctldev, s, selector);\n}\n\nstatic int pinconf_groups_show(struct seq_file *s, void *what)\n{\n\tstruct pinctrl_dev *pctldev = s->private;\n\tconst struct pinctrl_ops *pctlops = pctldev->desc->pctlops;\n\tunsigned ngroups = pctlops->get_groups_count(pctldev);\n\tunsigned selector = 0;\n\n\tseq_puts(s, \"Pin config settings per pin group\\n\");\n\tseq_puts(s, \"Format: group (name): configs\\n\");\n\n\twhile (selector < ngroups) {\n\t\tconst char *gname = pctlops->get_group_name(pctldev, selector);\n\n\t\tseq_printf(s, \"%u (%s): \", selector, gname);\n\t\tpinconf_dump_group(pctldev, s, selector, gname);\n\t\tseq_putc(s, '\\n');\n\t\tselector++;\n\t}\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(pinconf_pins);\nDEFINE_SHOW_ATTRIBUTE(pinconf_groups);\n\nvoid pinconf_init_device_debugfs(struct dentry *devroot,\n\t\t\t struct pinctrl_dev *pctldev)\n{\n\tdebugfs_create_file(\"pinconf-pins\", 0444,\n\t\t\t    devroot, pctldev, &pinconf_pins_fops);\n\tdebugfs_create_file(\"pinconf-groups\", 0444,\n\t\t\t    devroot, pctldev, &pinconf_groups_fops);\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}