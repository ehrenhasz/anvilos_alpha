{
  "module_name": "pinctrl-apple-gpio.c",
  "hash_id": "e693eb3d29bb98e72c662b12723b6c40b906417fb207a4b068eb9394da0f28f2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/pinctrl-apple-gpio.c",
  "human_readable_source": "\n \n\n#include <dt-bindings/pinctrl/apple.h>\n\n#include <linux/bitfield.h>\n#include <linux/bits.h>\n#include <linux/gpio/driver.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinmux.h>\n\n#include \"pinctrl-utils.h\"\n#include \"core.h\"\n#include \"pinmux.h\"\n\nstruct apple_gpio_pinctrl {\n\tstruct device *dev;\n\tstruct pinctrl_dev *pctldev;\n\n\tvoid __iomem *base;\n\tstruct regmap *map;\n\n\tstruct pinctrl_desc pinctrl_desc;\n\tstruct gpio_chip gpio_chip;\n\tu8 irqgrps[];\n};\n\n#define REG_GPIO(x)          (4 * (x))\n#define REG_GPIOx_DATA       BIT(0)\n#define REG_GPIOx_MODE       GENMASK(3, 1)\n#define REG_GPIOx_OUT        1\n#define REG_GPIOx_IN_IRQ_HI  2\n#define REG_GPIOx_IN_IRQ_LO  3\n#define REG_GPIOx_IN_IRQ_UP  4\n#define REG_GPIOx_IN_IRQ_DN  5\n#define REG_GPIOx_IN_IRQ_ANY 6\n#define REG_GPIOx_IN_IRQ_OFF 7\n#define REG_GPIOx_PERIPH     GENMASK(6, 5)\n#define REG_GPIOx_PULL       GENMASK(8, 7)\n#define REG_GPIOx_PULL_OFF   0\n#define REG_GPIOx_PULL_DOWN  1\n#define REG_GPIOx_PULL_UP_STRONG 2\n#define REG_GPIOx_PULL_UP    3\n#define REG_GPIOx_INPUT_ENABLE BIT(9)\n#define REG_GPIOx_DRIVE_STRENGTH0 GENMASK(11, 10)\n#define REG_GPIOx_SCHMITT    BIT(15)\n#define REG_GPIOx_GRP        GENMASK(18, 16)\n#define REG_GPIOx_LOCK       BIT(21)\n#define REG_GPIOx_DRIVE_STRENGTH1 GENMASK(23, 22)\n#define REG_IRQ(g, x)        (0x800 + 0x40 * (g) + 4 * ((x) >> 5))\n\nstruct regmap_config regmap_config = {\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n\t.cache_type = REGCACHE_FLAT,\n\t.max_register = 512 * sizeof(u32),\n\t.num_reg_defaults_raw = 512,\n\t.use_relaxed_mmio = true,\n\t.use_raw_spinlock = true,\n};\n\n \nstatic void apple_gpio_set_reg(struct apple_gpio_pinctrl *pctl,\n                               unsigned int pin, u32 mask, u32 value)\n{\n\tregmap_update_bits(pctl->map, REG_GPIO(pin), mask, value);\n}\n\nstatic u32 apple_gpio_get_reg(struct apple_gpio_pinctrl *pctl,\n                              unsigned int pin)\n{\n\tint ret;\n\tu32 val;\n\n\tret = regmap_read(pctl->map, REG_GPIO(pin), &val);\n\tif (ret)\n\t\treturn 0;\n\n\treturn val;\n}\n\n \n\nstatic int apple_gpio_dt_node_to_map(struct pinctrl_dev *pctldev,\n                                     struct device_node *node,\n                                     struct pinctrl_map **map,\n                                     unsigned *num_maps)\n{\n\tunsigned reserved_maps;\n\tstruct apple_gpio_pinctrl *pctl;\n\tu32 pinfunc, pin, func;\n\tint num_pins, i, ret;\n\tconst char *group_name;\n\tconst char *function_name;\n\n\t*map = NULL;\n\t*num_maps = 0;\n\treserved_maps = 0;\n\n\tpctl = pinctrl_dev_get_drvdata(pctldev);\n\n\tret = of_property_count_u32_elems(node, \"pinmux\");\n\tif (ret <= 0) {\n\t\tdev_err(pctl->dev,\n\t\t\t\"missing or empty pinmux property in node %pOFn.\\n\",\n\t\t\tnode);\n\t\treturn ret ? ret : -EINVAL;\n\t}\n\n\tnum_pins = ret;\n\n\tret = pinctrl_utils_reserve_map(pctldev, map, &reserved_maps, num_maps, num_pins);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < num_pins; i++) {\n\t\tret = of_property_read_u32_index(node, \"pinmux\", i, &pinfunc);\n\t\tif (ret)\n\t\t\tgoto free_map;\n\n\t\tpin = APPLE_PIN(pinfunc);\n\t\tfunc = APPLE_FUNC(pinfunc);\n\n\t\tif (func >= pinmux_generic_get_function_count(pctldev)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto free_map;\n\t\t}\n\n\t\tgroup_name = pinctrl_generic_get_group_name(pctldev, pin);\n\t\tfunction_name = pinmux_generic_get_function_name(pctl->pctldev, func);\n\t\tret = pinctrl_utils_add_map_mux(pctl->pctldev, map,\n\t\t                                &reserved_maps, num_maps,\n\t\t                                group_name, function_name);\n\t\tif (ret)\n\t\t\tgoto free_map;\n\t}\n\nfree_map:\n\tif (ret < 0)\n\t\tpinctrl_utils_free_map(pctldev, *map, *num_maps);\n\n\treturn ret;\n}\n\nstatic const struct pinctrl_ops apple_gpio_pinctrl_ops = {\n\t.get_groups_count = pinctrl_generic_get_group_count,\n\t.get_group_name = pinctrl_generic_get_group_name,\n\t.get_group_pins = pinctrl_generic_get_group_pins,\n\t.dt_node_to_map = apple_gpio_dt_node_to_map,\n\t.dt_free_map = pinctrl_utils_free_map,\n};\n\n \n\nstatic int apple_gpio_pinmux_set(struct pinctrl_dev *pctldev, unsigned func,\n                                 unsigned group)\n{\n\tstruct apple_gpio_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\n\tapple_gpio_set_reg(\n\t\tpctl, group, REG_GPIOx_PERIPH | REG_GPIOx_INPUT_ENABLE,\n\t\tFIELD_PREP(REG_GPIOx_PERIPH, func) | REG_GPIOx_INPUT_ENABLE);\n\n\treturn 0;\n}\n\nstatic const struct pinmux_ops apple_gpio_pinmux_ops = {\n\t.get_functions_count = pinmux_generic_get_function_count,\n\t.get_function_name = pinmux_generic_get_function_name,\n\t.get_function_groups = pinmux_generic_get_function_groups,\n\t.set_mux = apple_gpio_pinmux_set,\n\t.strict = true,\n};\n\n \n\nstatic int apple_gpio_get_direction(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct apple_gpio_pinctrl *pctl = gpiochip_get_data(chip);\n\tunsigned int reg = apple_gpio_get_reg(pctl, offset);\n\n\tif (FIELD_GET(REG_GPIOx_MODE, reg) == REG_GPIOx_OUT)\n\t\treturn GPIO_LINE_DIRECTION_OUT;\n\treturn GPIO_LINE_DIRECTION_IN;\n}\n\nstatic int apple_gpio_get(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct apple_gpio_pinctrl *pctl = gpiochip_get_data(chip);\n\tunsigned int reg = apple_gpio_get_reg(pctl, offset);\n\n\t \n\tif (FIELD_GET(REG_GPIOx_MODE, reg) != REG_GPIOx_OUT)\n\t\treg = readl_relaxed(pctl->base + REG_GPIO(offset));\n\n\treturn !!(reg & REG_GPIOx_DATA);\n}\n\nstatic void apple_gpio_set(struct gpio_chip *chip, unsigned int offset, int value)\n{\n\tstruct apple_gpio_pinctrl *pctl = gpiochip_get_data(chip);\n\n\tapple_gpio_set_reg(pctl, offset, REG_GPIOx_DATA, value ? REG_GPIOx_DATA : 0);\n}\n\nstatic int apple_gpio_direction_input(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct apple_gpio_pinctrl *pctl = gpiochip_get_data(chip);\n\n\tapple_gpio_set_reg(pctl, offset,\n\t\t\t   REG_GPIOx_PERIPH | REG_GPIOx_MODE | REG_GPIOx_DATA |\n\t\t\t\t   REG_GPIOx_INPUT_ENABLE,\n\t\t\t   FIELD_PREP(REG_GPIOx_MODE, REG_GPIOx_IN_IRQ_OFF) |\n\t\t\t\t   REG_GPIOx_INPUT_ENABLE);\n\treturn 0;\n}\n\nstatic int apple_gpio_direction_output(struct gpio_chip *chip,\n                                       unsigned int offset, int value)\n{\n\tstruct apple_gpio_pinctrl *pctl = gpiochip_get_data(chip);\n\n\tapple_gpio_set_reg(pctl, offset,\n\t\t\t   REG_GPIOx_PERIPH | REG_GPIOx_MODE | REG_GPIOx_DATA,\n\t\t\t   FIELD_PREP(REG_GPIOx_MODE, REG_GPIOx_OUT) |\n\t\t\t\t   (value ? REG_GPIOx_DATA : 0));\n\treturn 0;\n}\n\n \n\nstatic void apple_gpio_irq_ack(struct irq_data *data)\n{\n\tstruct apple_gpio_pinctrl *pctl = gpiochip_get_data(irq_data_get_irq_chip_data(data));\n\tunsigned int irqgrp = FIELD_GET(REG_GPIOx_GRP, apple_gpio_get_reg(pctl, data->hwirq));\n\n\twritel(BIT(data->hwirq % 32), pctl->base + REG_IRQ(irqgrp, data->hwirq));\n}\n\nstatic unsigned int apple_gpio_irq_type(unsigned int type)\n{\n\tswitch (type & IRQ_TYPE_SENSE_MASK) {\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\treturn REG_GPIOx_IN_IRQ_UP;\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\treturn REG_GPIOx_IN_IRQ_DN;\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\treturn REG_GPIOx_IN_IRQ_ANY;\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\treturn REG_GPIOx_IN_IRQ_HI;\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\treturn REG_GPIOx_IN_IRQ_LO;\n\tdefault:\n\t\treturn REG_GPIOx_IN_IRQ_OFF;\n\t}\n}\n\nstatic void apple_gpio_irq_mask(struct irq_data *data)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(data);\n\tstruct apple_gpio_pinctrl *pctl = gpiochip_get_data(gc);\n\n\tapple_gpio_set_reg(pctl, data->hwirq, REG_GPIOx_MODE,\n\t                   FIELD_PREP(REG_GPIOx_MODE, REG_GPIOx_IN_IRQ_OFF));\n\tgpiochip_disable_irq(gc, data->hwirq);\n}\n\nstatic void apple_gpio_irq_unmask(struct irq_data *data)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(data);\n\tstruct apple_gpio_pinctrl *pctl = gpiochip_get_data(gc);\n\tunsigned int irqtype = apple_gpio_irq_type(irqd_get_trigger_type(data));\n\n\tgpiochip_enable_irq(gc, data->hwirq);\n\tapple_gpio_set_reg(pctl, data->hwirq, REG_GPIOx_MODE,\n\t                   FIELD_PREP(REG_GPIOx_MODE, irqtype));\n}\n\nstatic unsigned int apple_gpio_irq_startup(struct irq_data *data)\n{\n\tstruct gpio_chip *chip = irq_data_get_irq_chip_data(data);\n\tstruct apple_gpio_pinctrl *pctl = gpiochip_get_data(chip);\n\n\tapple_gpio_set_reg(pctl, data->hwirq, REG_GPIOx_GRP,\n\t                   FIELD_PREP(REG_GPIOx_GRP, 0));\n\n\tapple_gpio_direction_input(chip, data->hwirq);\n\tapple_gpio_irq_unmask(data);\n\n\treturn 0;\n}\n\nstatic int apple_gpio_irq_set_type(struct irq_data *data, unsigned int type)\n{\n\tstruct apple_gpio_pinctrl *pctl = gpiochip_get_data(irq_data_get_irq_chip_data(data));\n\tunsigned int irqtype = apple_gpio_irq_type(type);\n\n\tif (irqtype == REG_GPIOx_IN_IRQ_OFF)\n\t\treturn -EINVAL;\n\n\tapple_gpio_set_reg(pctl, data->hwirq, REG_GPIOx_MODE,\n\t                   FIELD_PREP(REG_GPIOx_MODE, irqtype));\n\n\tif (type & IRQ_TYPE_LEVEL_MASK)\n\t\tirq_set_handler_locked(data, handle_level_irq);\n\telse\n\t\tirq_set_handler_locked(data, handle_edge_irq);\n\treturn 0;\n}\n\nstatic void apple_gpio_irq_handler(struct irq_desc *desc)\n{\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tu8 *grpp = irq_desc_get_handler_data(desc);\n\tstruct apple_gpio_pinctrl *pctl;\n\tunsigned int pinh, pinl;\n\tunsigned long pending;\n\tstruct gpio_chip *gc;\n\n\tpctl = container_of(grpp - *grpp, typeof(*pctl), irqgrps[0]);\n\tgc = &pctl->gpio_chip;\n\n\tchained_irq_enter(chip, desc);\n\tfor (pinh = 0; pinh < gc->ngpio; pinh += 32) {\n\t\tpending = readl_relaxed(pctl->base + REG_IRQ(*grpp, pinh));\n\t\tfor_each_set_bit(pinl, &pending, 32)\n\t\t\tgeneric_handle_domain_irq(gc->irq.domain, pinh + pinl);\n\t}\n\tchained_irq_exit(chip, desc);\n}\n\nstatic const struct irq_chip apple_gpio_irqchip = {\n\t.name\t\t\t= \"Apple-GPIO\",\n\t.irq_startup\t\t= apple_gpio_irq_startup,\n\t.irq_ack\t\t= apple_gpio_irq_ack,\n\t.irq_mask\t\t= apple_gpio_irq_mask,\n\t.irq_unmask\t\t= apple_gpio_irq_unmask,\n\t.irq_set_type\t\t= apple_gpio_irq_set_type,\n\t.flags\t\t\t= IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\n \n\nstatic int apple_gpio_register(struct apple_gpio_pinctrl *pctl)\n{\n\tstruct gpio_irq_chip *girq = &pctl->gpio_chip.irq;\n\tvoid **irq_data = NULL;\n\tint ret;\n\n\tpctl->gpio_chip.label = dev_name(pctl->dev);\n\tpctl->gpio_chip.request = gpiochip_generic_request;\n\tpctl->gpio_chip.free = gpiochip_generic_free;\n\tpctl->gpio_chip.get_direction = apple_gpio_get_direction;\n\tpctl->gpio_chip.direction_input = apple_gpio_direction_input;\n\tpctl->gpio_chip.direction_output = apple_gpio_direction_output;\n\tpctl->gpio_chip.get = apple_gpio_get;\n\tpctl->gpio_chip.set = apple_gpio_set;\n\tpctl->gpio_chip.base = -1;\n\tpctl->gpio_chip.ngpio = pctl->pinctrl_desc.npins;\n\tpctl->gpio_chip.parent = pctl->dev;\n\n\tif (girq->num_parents) {\n\t\tint i;\n\n\t\tgpio_irq_chip_set_chip(girq, &apple_gpio_irqchip);\n\t\tgirq->parent_handler = apple_gpio_irq_handler;\n\n\t\tgirq->parents = kmalloc_array(girq->num_parents,\n\t\t\t\t\t      sizeof(*girq->parents),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tirq_data = kmalloc_array(girq->num_parents, sizeof(*irq_data),\n\t\t\t\t\t GFP_KERNEL);\n\t\tif (!girq->parents || !irq_data) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_free_irq_data;\n\t\t}\n\n\t\tfor (i = 0; i < girq->num_parents; i++) {\n\t\t\tret = platform_get_irq(to_platform_device(pctl->dev), i);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out_free_irq_data;\n\n\t\t\tgirq->parents[i] = ret;\n\t\t\tpctl->irqgrps[i] = i;\n\t\t\tirq_data[i] = &pctl->irqgrps[i];\n\t\t}\n\n\t\tgirq->parent_handler_data_array = irq_data;\n\t\tgirq->per_parent_data = true;\n\t\tgirq->default_type = IRQ_TYPE_NONE;\n\t\tgirq->handler = handle_level_irq;\n\t}\n\n\tret = devm_gpiochip_add_data(pctl->dev, &pctl->gpio_chip, pctl);\n\nout_free_irq_data:\n\tkfree(girq->parents);\n\tkfree(irq_data);\n\n\treturn ret;\n}\n\nstatic int apple_gpio_pinctrl_probe(struct platform_device *pdev)\n{\n\tstruct apple_gpio_pinctrl *pctl;\n\tstruct pinctrl_pin_desc *pins;\n\tunsigned int npins;\n\tconst char **pin_names;\n\tunsigned int *pin_nums;\n\tstatic const char* pinmux_functions[] = {\n\t\t\"gpio\", \"periph1\", \"periph2\", \"periph3\"\n\t};\n\tunsigned int i, nirqs = 0;\n\tint res;\n\n\tif (of_property_read_bool(pdev->dev.of_node, \"interrupt-controller\")) {\n\t\tres = platform_irq_count(pdev);\n\t\tif (res > 0)\n\t\t\tnirqs = res;\n\t}\n\n\tpctl = devm_kzalloc(&pdev->dev, struct_size(pctl, irqgrps, nirqs),\n\t\t\t    GFP_KERNEL);\n\tif (!pctl)\n\t\treturn -ENOMEM;\n\tpctl->dev = &pdev->dev;\n\tpctl->gpio_chip.irq.num_parents = nirqs;\n\tdev_set_drvdata(&pdev->dev, pctl);\n\n\tif (of_property_read_u32(pdev->dev.of_node, \"apple,npins\", &npins))\n\t\treturn dev_err_probe(&pdev->dev, -EINVAL,\n\t\t\t\t     \"apple,npins property not found\\n\");\n\n\tpins = devm_kmalloc_array(&pdev->dev, npins, sizeof(pins[0]),\n\t\t\t\t  GFP_KERNEL);\n\tpin_names = devm_kmalloc_array(&pdev->dev, npins, sizeof(pin_names[0]),\n\t\t\t\t       GFP_KERNEL);\n\tpin_nums = devm_kmalloc_array(&pdev->dev, npins, sizeof(pin_nums[0]),\n\t\t\t\t      GFP_KERNEL);\n\tif (!pins || !pin_names || !pin_nums)\n\t\treturn -ENOMEM;\n\n\tpctl->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(pctl->base))\n\t\treturn PTR_ERR(pctl->base);\n\n\tpctl->map = devm_regmap_init_mmio(&pdev->dev, pctl->base, &regmap_config);\n\tif (IS_ERR(pctl->map))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(pctl->map),\n\t\t\t\t     \"Failed to create regmap\\n\");\n\n\tfor (i = 0; i < npins; i++) {\n\t\tpins[i].number = i;\n\t\tpins[i].name = devm_kasprintf(&pdev->dev, GFP_KERNEL, \"PIN%u\", i);\n\t\tpins[i].drv_data = pctl;\n\t\tpin_names[i] = pins[i].name;\n\t\tpin_nums[i] = i;\n\t}\n\n\tpctl->pinctrl_desc.name = dev_name(pctl->dev);\n\tpctl->pinctrl_desc.pins = pins;\n\tpctl->pinctrl_desc.npins = npins;\n\tpctl->pinctrl_desc.pctlops = &apple_gpio_pinctrl_ops;\n\tpctl->pinctrl_desc.pmxops = &apple_gpio_pinmux_ops;\n\n\tpctl->pctldev =\tdevm_pinctrl_register(&pdev->dev, &pctl->pinctrl_desc, pctl);\n\tif (IS_ERR(pctl->pctldev))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(pctl->pctldev),\n\t\t\t\t     \"Failed to register pinctrl device.\\n\");\n\n\tfor (i = 0; i < npins; i++) {\n\t\tres = pinctrl_generic_add_group(pctl->pctldev, pins[i].name,\n\t\t\t\t\t\tpin_nums + i, 1, pctl);\n\t\tif (res < 0)\n\t\t\treturn dev_err_probe(pctl->dev, res,\n\t\t\t\t\t     \"Failed to register group\");\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(pinmux_functions); ++i) {\n\t\tres = pinmux_generic_add_function(pctl->pctldev, pinmux_functions[i],\n\t\t\t\t\t\t  pin_names, npins, pctl);\n\t\tif (res < 0)\n\t\t\treturn dev_err_probe(pctl->dev, res,\n\t\t\t\t\t     \"Failed to register function.\");\n\t}\n\n\treturn apple_gpio_register(pctl);\n}\n\nstatic const struct of_device_id apple_gpio_pinctrl_of_match[] = {\n\t{ .compatible = \"apple,pinctrl\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, apple_gpio_pinctrl_of_match);\n\nstatic struct platform_driver apple_gpio_pinctrl_driver = {\n\t.driver = {\n\t\t.name = \"apple-gpio-pinctrl\",\n\t\t.of_match_table = apple_gpio_pinctrl_of_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe = apple_gpio_pinctrl_probe,\n};\nmodule_platform_driver(apple_gpio_pinctrl_driver);\n\nMODULE_DESCRIPTION(\"Apple pinctrl/GPIO driver\");\nMODULE_AUTHOR(\"Stan Skowronek <stan@corellium.com>\");\nMODULE_AUTHOR(\"Joey Gouly <joey.gouly@arm.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}