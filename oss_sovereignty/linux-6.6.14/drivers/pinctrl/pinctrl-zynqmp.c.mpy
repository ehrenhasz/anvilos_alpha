{
  "module_name": "pinctrl-zynqmp.c",
  "hash_id": "f6a81851ba5f707288f78ec93da00b9bfd5b003c349814adaeb6e3ca0c5c1fa9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/pinctrl-zynqmp.c",
  "human_readable_source": "\n \n\n#include <dt-bindings/pinctrl/pinctrl-zynqmp.h>\n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n\n#include <linux/firmware/xlnx-zynqmp.h>\n\n#include <linux/pinctrl/pinconf-generic.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinmux.h>\n\n#include \"core.h\"\n#include \"pinctrl-utils.h\"\n\n#define ZYNQMP_PIN_PREFIX\t\t\t\"MIO\"\n#define PINCTRL_GET_FUNC_NAME_RESP_LEN\t\t16\n#define MAX_FUNC_NAME_LEN\t\t\t16\n#define MAX_GROUP_PIN\t\t\t\t50\n#define MAX_PIN_GROUPS\t\t\t\t50\n#define END_OF_FUNCTIONS\t\t\t\"END_OF_FUNCTIONS\"\n#define NUM_GROUPS_PER_RESP\t\t\t6\n\n#define PINCTRL_GET_FUNC_GROUPS_RESP_LEN\t12\n#define PINCTRL_GET_PIN_GROUPS_RESP_LEN\t\t12\n#define NA_GROUP\t\t\t\t0xFFFF\n#define RESERVED_GROUP\t\t\t\t0xFFFE\n\n#define DRIVE_STRENGTH_2MA\t2\n#define DRIVE_STRENGTH_4MA\t4\n#define DRIVE_STRENGTH_8MA\t8\n#define DRIVE_STRENGTH_12MA\t12\n\n \nstruct zynqmp_pmux_function {\n\tchar name[MAX_FUNC_NAME_LEN];\n\tconst char * const *groups;\n\tunsigned int ngroups;\n};\n\n \nstruct zynqmp_pinctrl {\n\tstruct pinctrl_dev *pctrl;\n\tconst struct zynqmp_pctrl_group *groups;\n\tunsigned int ngroups;\n\tconst struct zynqmp_pmux_function *funcs;\n\tunsigned int nfuncs;\n};\n\n \nstruct zynqmp_pctrl_group {\n\tconst char *name;\n\tunsigned int pins[MAX_GROUP_PIN];\n\tunsigned int npins;\n};\n\nstatic struct pinctrl_desc zynqmp_desc;\n\nstatic int zynqmp_pctrl_get_groups_count(struct pinctrl_dev *pctldev)\n{\n\tstruct zynqmp_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pctrl->ngroups;\n}\n\nstatic const char *zynqmp_pctrl_get_group_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t       unsigned int selector)\n{\n\tstruct zynqmp_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pctrl->groups[selector].name;\n}\n\nstatic int zynqmp_pctrl_get_group_pins(struct pinctrl_dev *pctldev,\n\t\t\t\t       unsigned int selector,\n\t\t\t\t       const unsigned int **pins,\n\t\t\t\t       unsigned int *npins)\n{\n\tstruct zynqmp_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\n\t*pins = pctrl->groups[selector].pins;\n\t*npins = pctrl->groups[selector].npins;\n\n\treturn 0;\n}\n\nstatic const struct pinctrl_ops zynqmp_pctrl_ops = {\n\t.get_groups_count = zynqmp_pctrl_get_groups_count,\n\t.get_group_name = zynqmp_pctrl_get_group_name,\n\t.get_group_pins = zynqmp_pctrl_get_group_pins,\n\t.dt_node_to_map = pinconf_generic_dt_node_to_map_all,\n\t.dt_free_map = pinctrl_utils_free_map,\n};\n\nstatic int zynqmp_pinmux_request_pin(struct pinctrl_dev *pctldev,\n\t\t\t\t     unsigned int pin)\n{\n\tint ret;\n\n\tret = zynqmp_pm_pinctrl_request(pin);\n\tif (ret) {\n\t\tdev_err(pctldev->dev, \"request failed for pin %u\\n\", pin);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int zynqmp_pmux_get_functions_count(struct pinctrl_dev *pctldev)\n{\n\tstruct zynqmp_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pctrl->nfuncs;\n}\n\nstatic const char *zynqmp_pmux_get_function_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t\t unsigned int selector)\n{\n\tstruct zynqmp_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pctrl->funcs[selector].name;\n}\n\n \nstatic int zynqmp_pmux_get_function_groups(struct pinctrl_dev *pctldev,\n\t\t\t\t\t   unsigned int selector,\n\t\t\t\t\t   const char * const **groups,\n\t\t\t\t\t   unsigned * const num_groups)\n{\n\tstruct zynqmp_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\n\t*groups = pctrl->funcs[selector].groups;\n\t*num_groups = pctrl->funcs[selector].ngroups;\n\n\treturn 0;\n}\n\n \nstatic int zynqmp_pinmux_set_mux(struct pinctrl_dev *pctldev,\n\t\t\t\t unsigned int function,\n\t\t\t\t unsigned int group)\n{\n\tstruct zynqmp_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct zynqmp_pctrl_group *pgrp = &pctrl->groups[group];\n\tint ret, i;\n\n\tfor (i = 0; i < pgrp->npins; i++) {\n\t\tunsigned int pin = pgrp->pins[i];\n\n\t\tret = zynqmp_pm_pinctrl_set_function(pin, function);\n\t\tif (ret) {\n\t\t\tdev_err(pctldev->dev, \"set mux failed for pin %u\\n\",\n\t\t\t\tpin);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int zynqmp_pinmux_release_pin(struct pinctrl_dev *pctldev,\n\t\t\t\t     unsigned int pin)\n{\n\tint ret;\n\n\tret = zynqmp_pm_pinctrl_release(pin);\n\tif (ret) {\n\t\tdev_err(pctldev->dev, \"free pin failed for pin %u\\n\",\n\t\t\tpin);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct pinmux_ops zynqmp_pinmux_ops = {\n\t.request = zynqmp_pinmux_request_pin,\n\t.get_functions_count = zynqmp_pmux_get_functions_count,\n\t.get_function_name = zynqmp_pmux_get_function_name,\n\t.get_function_groups = zynqmp_pmux_get_function_groups,\n\t.set_mux = zynqmp_pinmux_set_mux,\n\t.free = zynqmp_pinmux_release_pin,\n};\n\n \nstatic int zynqmp_pinconf_cfg_get(struct pinctrl_dev *pctldev,\n\t\t\t\t  unsigned int pin,\n\t\t\t\t  unsigned long *config)\n{\n\tunsigned int arg, param = pinconf_to_config_param(*config);\n\tint ret;\n\n\tswitch (param) {\n\tcase PIN_CONFIG_SLEW_RATE:\n\t\tparam = PM_PINCTRL_CONFIG_SLEW_RATE;\n\t\tret = zynqmp_pm_pinctrl_get_config(pin, param, &arg);\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\tparam = PM_PINCTRL_CONFIG_PULL_CTRL;\n\t\tret = zynqmp_pm_pinctrl_get_config(pin, param, &arg);\n\t\tif (arg != PM_PINCTRL_BIAS_PULL_UP)\n\t\t\treturn -EINVAL;\n\n\t\targ = 1;\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\tparam = PM_PINCTRL_CONFIG_PULL_CTRL;\n\t\tret = zynqmp_pm_pinctrl_get_config(pin, param, &arg);\n\t\tif (arg != PM_PINCTRL_BIAS_PULL_DOWN)\n\t\t\treturn -EINVAL;\n\n\t\targ = 1;\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\tparam = PM_PINCTRL_CONFIG_BIAS_STATUS;\n\t\tret = zynqmp_pm_pinctrl_get_config(pin, param, &arg);\n\t\tif (arg != PM_PINCTRL_BIAS_DISABLE)\n\t\t\treturn -EINVAL;\n\n\t\targ = 1;\n\t\tbreak;\n\tcase PIN_CONFIG_POWER_SOURCE:\n\t\tparam = PM_PINCTRL_CONFIG_VOLTAGE_STATUS;\n\t\tret = zynqmp_pm_pinctrl_get_config(pin, param, &arg);\n\t\tbreak;\n\tcase PIN_CONFIG_INPUT_SCHMITT_ENABLE:\n\t\tparam = PM_PINCTRL_CONFIG_SCHMITT_CMOS;\n\t\tret = zynqmp_pm_pinctrl_get_config(pin, param, &arg);\n\t\tbreak;\n\tcase PIN_CONFIG_DRIVE_STRENGTH:\n\t\tparam = PM_PINCTRL_CONFIG_DRIVE_STRENGTH;\n\t\tret = zynqmp_pm_pinctrl_get_config(pin, param, &arg);\n\t\tswitch (arg) {\n\t\tcase PM_PINCTRL_DRIVE_STRENGTH_2MA:\n\t\t\targ = DRIVE_STRENGTH_2MA;\n\t\t\tbreak;\n\t\tcase PM_PINCTRL_DRIVE_STRENGTH_4MA:\n\t\t\targ = DRIVE_STRENGTH_4MA;\n\t\t\tbreak;\n\t\tcase PM_PINCTRL_DRIVE_STRENGTH_8MA:\n\t\t\targ = DRIVE_STRENGTH_8MA;\n\t\t\tbreak;\n\t\tcase PM_PINCTRL_DRIVE_STRENGTH_12MA:\n\t\t\targ = DRIVE_STRENGTH_12MA;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tdev_warn(pctldev->dev,\n\t\t\t\t \"Invalid drive strength for pin %d\\n\",\n\t\t\t\t pin);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOTSUPP;\n\t\tbreak;\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\tparam = pinconf_to_config_param(*config);\n\t*config = pinconf_to_config_packed(param, arg);\n\n\treturn 0;\n}\n\n \nstatic int zynqmp_pinconf_cfg_set(struct pinctrl_dev *pctldev,\n\t\t\t\t  unsigned int pin, unsigned long *configs,\n\t\t\t\t  unsigned int num_configs)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < num_configs; i++) {\n\t\tunsigned int param = pinconf_to_config_param(configs[i]);\n\t\tunsigned int arg = pinconf_to_config_argument(configs[i]);\n\t\tunsigned int value;\n\n\t\tswitch (param) {\n\t\tcase PIN_CONFIG_SLEW_RATE:\n\t\t\tparam = PM_PINCTRL_CONFIG_SLEW_RATE;\n\t\t\tret = zynqmp_pm_pinctrl_set_config(pin, param, arg);\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\t\tparam = PM_PINCTRL_CONFIG_PULL_CTRL;\n\t\t\targ = PM_PINCTRL_BIAS_PULL_UP;\n\t\t\tret = zynqmp_pm_pinctrl_set_config(pin, param, arg);\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\t\tparam = PM_PINCTRL_CONFIG_PULL_CTRL;\n\t\t\targ = PM_PINCTRL_BIAS_PULL_DOWN;\n\t\t\tret = zynqmp_pm_pinctrl_set_config(pin, param, arg);\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\t\tparam = PM_PINCTRL_CONFIG_BIAS_STATUS;\n\t\t\targ = PM_PINCTRL_BIAS_DISABLE;\n\t\t\tret = zynqmp_pm_pinctrl_set_config(pin, param, arg);\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_INPUT_SCHMITT_ENABLE:\n\t\t\tparam = PM_PINCTRL_CONFIG_SCHMITT_CMOS;\n\t\t\tret = zynqmp_pm_pinctrl_set_config(pin, param, arg);\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_DRIVE_STRENGTH:\n\t\t\tswitch (arg) {\n\t\t\tcase DRIVE_STRENGTH_2MA:\n\t\t\t\tvalue = PM_PINCTRL_DRIVE_STRENGTH_2MA;\n\t\t\t\tbreak;\n\t\t\tcase DRIVE_STRENGTH_4MA:\n\t\t\t\tvalue = PM_PINCTRL_DRIVE_STRENGTH_4MA;\n\t\t\t\tbreak;\n\t\t\tcase DRIVE_STRENGTH_8MA:\n\t\t\t\tvalue = PM_PINCTRL_DRIVE_STRENGTH_8MA;\n\t\t\t\tbreak;\n\t\t\tcase DRIVE_STRENGTH_12MA:\n\t\t\t\tvalue = PM_PINCTRL_DRIVE_STRENGTH_12MA;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t \n\t\t\t\tdev_warn(pctldev->dev,\n\t\t\t\t\t \"Invalid drive strength for pin %d\\n\",\n\t\t\t\t\t pin);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tparam = PM_PINCTRL_CONFIG_DRIVE_STRENGTH;\n\t\t\tret = zynqmp_pm_pinctrl_set_config(pin, param, value);\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_POWER_SOURCE:\n\t\t\tparam = PM_PINCTRL_CONFIG_VOLTAGE_STATUS;\n\t\t\tret = zynqmp_pm_pinctrl_get_config(pin, param, &value);\n\n\t\t\tif (arg != value)\n\t\t\t\tdev_warn(pctldev->dev,\n\t\t\t\t\t \"Invalid IO Standard requested for pin %d\\n\",\n\t\t\t\t\t pin);\n\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_BIAS_HIGH_IMPEDANCE:\n\t\t\tparam = PM_PINCTRL_CONFIG_TRI_STATE;\n\t\t\targ = PM_PINCTRL_TRI_STATE_ENABLE;\n\t\t\tret = zynqmp_pm_pinctrl_set_config(pin, param, arg);\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_MODE_LOW_POWER:\n\t\t\t \n\t\t\tret = 0;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_OUTPUT_ENABLE:\n\t\t\tparam = PM_PINCTRL_CONFIG_TRI_STATE;\n\t\t\targ = PM_PINCTRL_TRI_STATE_DISABLE;\n\t\t\tret = zynqmp_pm_pinctrl_set_config(pin, param, arg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(pctldev->dev,\n\t\t\t\t \"unsupported configuration parameter '%u'\\n\",\n\t\t\t\t param);\n\t\t\tret = -ENOTSUPP;\n\t\t\tbreak;\n\t\t}\n\n\t\tparam = pinconf_to_config_param(configs[i]);\n\t\targ = pinconf_to_config_argument(configs[i]);\n\t\tif (ret)\n\t\t\tdev_warn(pctldev->dev,\n\t\t\t\t \"failed to set: pin %u param %u value %u\\n\",\n\t\t\t\t pin, param, arg);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int zynqmp_pinconf_group_set(struct pinctrl_dev *pctldev,\n\t\t\t\t    unsigned int selector,\n\t\t\t\t    unsigned long *configs,\n\t\t\t\t    unsigned int num_configs)\n{\n\tint i, ret;\n\tstruct zynqmp_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct zynqmp_pctrl_group *pgrp = &pctrl->groups[selector];\n\n\tfor (i = 0; i < pgrp->npins; i++) {\n\t\tret = zynqmp_pinconf_cfg_set(pctldev, pgrp->pins[i], configs,\n\t\t\t\t\t     num_configs);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct pinconf_ops zynqmp_pinconf_ops = {\n\t.is_generic = true,\n\t.pin_config_get = zynqmp_pinconf_cfg_get,\n\t.pin_config_set = zynqmp_pinconf_cfg_set,\n\t.pin_config_group_set = zynqmp_pinconf_group_set,\n};\n\nstatic struct pinctrl_desc zynqmp_desc = {\n\t.name = \"zynqmp_pinctrl\",\n\t.owner = THIS_MODULE,\n\t.pctlops = &zynqmp_pctrl_ops,\n\t.pmxops = &zynqmp_pinmux_ops,\n\t.confops = &zynqmp_pinconf_ops,\n};\n\nstatic int zynqmp_pinctrl_get_function_groups(u32 fid, u32 index, u16 *groups)\n{\n\tstruct zynqmp_pm_query_data qdata = {0};\n\tu32 payload[PAYLOAD_ARG_CNT];\n\tint ret;\n\n\tqdata.qid = PM_QID_PINCTRL_GET_FUNCTION_GROUPS;\n\tqdata.arg1 = fid;\n\tqdata.arg2 = index;\n\n\tret = zynqmp_pm_query_data(qdata, payload);\n\tif (ret)\n\t\treturn ret;\n\n\tmemcpy(groups, &payload[1], PINCTRL_GET_FUNC_GROUPS_RESP_LEN);\n\n\treturn 0;\n}\n\nstatic int zynqmp_pinctrl_get_func_num_groups(u32 fid, unsigned int *ngroups)\n{\n\tstruct zynqmp_pm_query_data qdata = {0};\n\tu32 payload[PAYLOAD_ARG_CNT];\n\tint ret;\n\n\tqdata.qid = PM_QID_PINCTRL_GET_NUM_FUNCTION_GROUPS;\n\tqdata.arg1 = fid;\n\n\tret = zynqmp_pm_query_data(qdata, payload);\n\tif (ret)\n\t\treturn ret;\n\n\t*ngroups = payload[1];\n\n\treturn 0;\n}\n\n \nstatic int zynqmp_pinctrl_prepare_func_groups(struct device *dev, u32 fid,\n\t\t\t\t\t      struct zynqmp_pmux_function *func,\n\t\t\t\t\t      struct zynqmp_pctrl_group *groups)\n{\n\tu16 resp[NUM_GROUPS_PER_RESP] = {0};\n\tconst char **fgroups;\n\tint ret, index, i;\n\n\tfgroups = devm_kzalloc(dev, sizeof(*fgroups) * func->ngroups, GFP_KERNEL);\n\tif (!fgroups)\n\t\treturn -ENOMEM;\n\n\tfor (index = 0; index < func->ngroups; index += NUM_GROUPS_PER_RESP) {\n\t\tret = zynqmp_pinctrl_get_function_groups(fid, index, resp);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tfor (i = 0; i < NUM_GROUPS_PER_RESP; i++) {\n\t\t\tif (resp[i] == NA_GROUP)\n\t\t\t\tgoto done;\n\n\t\t\tif (resp[i] == RESERVED_GROUP)\n\t\t\t\tcontinue;\n\n\t\t\tfgroups[index + i] = devm_kasprintf(dev, GFP_KERNEL,\n\t\t\t\t\t\t\t    \"%s_%d_grp\",\n\t\t\t\t\t\t\t    func->name,\n\t\t\t\t\t\t\t    index + i);\n\t\t\tif (!fgroups[index + i])\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tgroups[resp[i]].name = devm_kasprintf(dev, GFP_KERNEL,\n\t\t\t\t\t\t\t      \"%s_%d_grp\",\n\t\t\t\t\t\t\t      func->name,\n\t\t\t\t\t\t\t      index + i);\n\t\t\tif (!groups[resp[i]].name)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t}\ndone:\n\tfunc->groups = fgroups;\n\n\treturn 0;\n}\n\nstatic void zynqmp_pinctrl_get_function_name(u32 fid, char *name)\n{\n\tstruct zynqmp_pm_query_data qdata = {0};\n\tu32 payload[PAYLOAD_ARG_CNT];\n\n\tqdata.qid = PM_QID_PINCTRL_GET_FUNCTION_NAME;\n\tqdata.arg1 = fid;\n\n\t \n\tzynqmp_pm_query_data(qdata, payload);\n\tmemcpy(name, payload, PINCTRL_GET_FUNC_NAME_RESP_LEN);\n}\n\nstatic int zynqmp_pinctrl_get_num_functions(unsigned int *nfuncs)\n{\n\tstruct zynqmp_pm_query_data qdata = {0};\n\tu32 payload[PAYLOAD_ARG_CNT];\n\tint ret;\n\n\tqdata.qid = PM_QID_PINCTRL_GET_NUM_FUNCTIONS;\n\n\tret = zynqmp_pm_query_data(qdata, payload);\n\tif (ret)\n\t\treturn ret;\n\n\t*nfuncs = payload[1];\n\n\treturn 0;\n}\n\nstatic int zynqmp_pinctrl_get_pin_groups(u32 pin, u32 index, u16 *groups)\n{\n\tstruct zynqmp_pm_query_data qdata = {0};\n\tu32 payload[PAYLOAD_ARG_CNT];\n\tint ret;\n\n\tqdata.qid = PM_QID_PINCTRL_GET_PIN_GROUPS;\n\tqdata.arg1 = pin;\n\tqdata.arg2 = index;\n\n\tret = zynqmp_pm_query_data(qdata, payload);\n\tif (ret)\n\t\treturn ret;\n\n\tmemcpy(groups, &payload[1], PINCTRL_GET_PIN_GROUPS_RESP_LEN);\n\n\treturn 0;\n}\n\nstatic void zynqmp_pinctrl_group_add_pin(struct zynqmp_pctrl_group *group,\n\t\t\t\t\t unsigned int pin)\n{\n\tgroup->pins[group->npins++] = pin;\n}\n\n \nstatic int zynqmp_pinctrl_create_pin_groups(struct device *dev,\n\t\t\t\t\t    struct zynqmp_pctrl_group *groups,\n\t\t\t\t\t    unsigned int pin)\n{\n\tu16 resp[NUM_GROUPS_PER_RESP] = {0};\n\tint ret, i, index = 0;\n\n\tdo {\n\t\tret = zynqmp_pinctrl_get_pin_groups(pin, index, resp);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tfor (i = 0; i < NUM_GROUPS_PER_RESP; i++) {\n\t\t\tif (resp[i] == NA_GROUP)\n\t\t\t\treturn ret;\n\n\t\t\tif (resp[i] == RESERVED_GROUP)\n\t\t\t\tcontinue;\n\n\t\t\tzynqmp_pinctrl_group_add_pin(&groups[resp[i]], pin);\n\t\t}\n\t\tindex += NUM_GROUPS_PER_RESP;\n\t} while (index <= MAX_PIN_GROUPS);\n\n\treturn 0;\n}\n\n \nstatic int zynqmp_pinctrl_prepare_group_pins(struct device *dev,\n\t\t\t\t\t     struct zynqmp_pctrl_group *groups,\n\t\t\t\t\t     unsigned int ngroups)\n{\n\tunsigned int pin;\n\tint ret;\n\n\tfor (pin = 0; pin < zynqmp_desc.npins; pin++) {\n\t\tret = zynqmp_pinctrl_create_pin_groups(dev, groups, pin);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int zynqmp_pinctrl_prepare_function_info(struct device *dev,\n\t\t\t\t\t\tstruct zynqmp_pinctrl *pctrl)\n{\n\tstruct zynqmp_pmux_function *funcs;\n\tstruct zynqmp_pctrl_group *groups;\n\tint ret, i;\n\n\tret = zynqmp_pinctrl_get_num_functions(&pctrl->nfuncs);\n\tif (ret)\n\t\treturn ret;\n\n\tfuncs = devm_kzalloc(dev, sizeof(*funcs) * pctrl->nfuncs, GFP_KERNEL);\n\tif (!funcs)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < pctrl->nfuncs; i++) {\n\t\tzynqmp_pinctrl_get_function_name(i, funcs[i].name);\n\n\t\tret = zynqmp_pinctrl_get_func_num_groups(i, &funcs[i].ngroups);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tpctrl->ngroups += funcs[i].ngroups;\n\t}\n\n\tgroups = devm_kzalloc(dev, sizeof(*groups) * pctrl->ngroups, GFP_KERNEL);\n\tif (!groups)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < pctrl->nfuncs; i++) {\n\t\tret = zynqmp_pinctrl_prepare_func_groups(dev, i, &funcs[i],\n\t\t\t\t\t\t\t groups);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = zynqmp_pinctrl_prepare_group_pins(dev, groups, pctrl->ngroups);\n\tif (ret)\n\t\treturn ret;\n\n\tpctrl->funcs = funcs;\n\tpctrl->groups = groups;\n\n\treturn 0;\n}\n\nstatic int zynqmp_pinctrl_get_num_pins(unsigned int *npins)\n{\n\tstruct zynqmp_pm_query_data qdata = {0};\n\tu32 payload[PAYLOAD_ARG_CNT];\n\tint ret;\n\n\tqdata.qid = PM_QID_PINCTRL_GET_NUM_PINS;\n\n\tret = zynqmp_pm_query_data(qdata, payload);\n\tif (ret)\n\t\treturn ret;\n\n\t*npins = payload[1];\n\n\treturn 0;\n}\n\n \nstatic int zynqmp_pinctrl_prepare_pin_desc(struct device *dev,\n\t\t\t\t\t   const struct pinctrl_pin_desc\n\t\t\t\t\t   **zynqmp_pins,\n\t\t\t\t\t   unsigned int *npins)\n{\n\tstruct pinctrl_pin_desc *pins, *pin;\n\tint ret;\n\tint i;\n\n\tret = zynqmp_pinctrl_get_num_pins(npins);\n\tif (ret)\n\t\treturn ret;\n\n\tpins = devm_kzalloc(dev, sizeof(*pins) * *npins, GFP_KERNEL);\n\tif (!pins)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < *npins; i++) {\n\t\tpin = &pins[i];\n\t\tpin->number = i;\n\t\tpin->name = devm_kasprintf(dev, GFP_KERNEL, \"%s%d\",\n\t\t\t\t\t   ZYNQMP_PIN_PREFIX, i);\n\t\tif (!pin->name)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t*zynqmp_pins = pins;\n\n\treturn 0;\n}\n\nstatic int zynqmp_pinctrl_probe(struct platform_device *pdev)\n{\n\tstruct zynqmp_pinctrl *pctrl;\n\tint ret;\n\n\tpctrl = devm_kzalloc(&pdev->dev, sizeof(*pctrl), GFP_KERNEL);\n\tif (!pctrl)\n\t\treturn -ENOMEM;\n\n\tret = zynqmp_pinctrl_prepare_pin_desc(&pdev->dev,\n\t\t\t\t\t      &zynqmp_desc.pins,\n\t\t\t\t\t      &zynqmp_desc.npins);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"pin desc prepare fail with %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = zynqmp_pinctrl_prepare_function_info(&pdev->dev, pctrl);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"function info prepare fail with %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpctrl->pctrl = devm_pinctrl_register(&pdev->dev, &zynqmp_desc, pctrl);\n\tif (IS_ERR(pctrl->pctrl))\n\t\treturn PTR_ERR(pctrl->pctrl);\n\n\tplatform_set_drvdata(pdev, pctrl);\n\n\treturn ret;\n}\n\nstatic const struct of_device_id zynqmp_pinctrl_of_match[] = {\n\t{ .compatible = \"xlnx,zynqmp-pinctrl\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, zynqmp_pinctrl_of_match);\n\nstatic struct platform_driver zynqmp_pinctrl_driver = {\n\t.driver = {\n\t\t.name = \"zynqmp-pinctrl\",\n\t\t.of_match_table = zynqmp_pinctrl_of_match,\n\t},\n\t.probe = zynqmp_pinctrl_probe,\n};\nmodule_platform_driver(zynqmp_pinctrl_driver);\n\nMODULE_AUTHOR(\"Sai Krishna Potthuri <lakshmi.sai.krishna.potthuri@xilinx.com>\");\nMODULE_DESCRIPTION(\"ZynqMP Pin Controller Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}