{
  "module_name": "pinctrl-owl.c",
  "hash_id": "e5fa21cc7e2e92c01f39dea47c7417a453691bf8de1f516dad84877868081d07",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/actions/pinctrl-owl.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/gpio/driver.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\n#include <linux/pinctrl/machine.h>\n#include <linux/pinctrl/pinconf-generic.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinmux.h>\n\n#include \"../core.h\"\n#include \"../pinctrl-utils.h\"\n#include \"pinctrl-owl.h\"\n\n \nstruct owl_pinctrl {\n\tstruct device *dev;\n\tstruct pinctrl_dev *pctrldev;\n\tstruct gpio_chip chip;\n\traw_spinlock_t lock;\n\tstruct clk *clk;\n\tconst struct owl_pinctrl_soc_data *soc;\n\tvoid __iomem *base;\n\tunsigned int num_irq;\n\tunsigned int *irq;\n};\n\nstatic void owl_update_bits(void __iomem *base, u32 mask, u32 val)\n{\n\tu32 reg_val;\n\n\treg_val = readl_relaxed(base);\n\n\treg_val = (reg_val & ~mask) | (val & mask);\n\n\twritel_relaxed(reg_val, base);\n}\n\nstatic u32 owl_read_field(struct owl_pinctrl *pctrl, u32 reg,\n\t\t\t\tu32 bit, u32 width)\n{\n\tu32 tmp, mask;\n\n\ttmp = readl_relaxed(pctrl->base + reg);\n\tmask = (1 << width) - 1;\n\n\treturn (tmp >> bit) & mask;\n}\n\nstatic void owl_write_field(struct owl_pinctrl *pctrl, u32 reg, u32 arg,\n\t\t\t\tu32 bit, u32 width)\n{\n\tu32 mask;\n\n\tmask = (1 << width) - 1;\n\tmask = mask << bit;\n\n\towl_update_bits(pctrl->base + reg, mask, (arg << bit));\n}\n\nstatic int owl_get_groups_count(struct pinctrl_dev *pctrldev)\n{\n\tstruct owl_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctrldev);\n\n\treturn pctrl->soc->ngroups;\n}\n\nstatic const char *owl_get_group_name(struct pinctrl_dev *pctrldev,\n\t\t\t\tunsigned int group)\n{\n\tstruct owl_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctrldev);\n\n\treturn pctrl->soc->groups[group].name;\n}\n\nstatic int owl_get_group_pins(struct pinctrl_dev *pctrldev,\n\t\t\t\tunsigned int group,\n\t\t\t\tconst unsigned int **pins,\n\t\t\t\tunsigned int *num_pins)\n{\n\tstruct owl_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctrldev);\n\n\t*pins = pctrl->soc->groups[group].pads;\n\t*num_pins = pctrl->soc->groups[group].npads;\n\n\treturn 0;\n}\n\nstatic void owl_pin_dbg_show(struct pinctrl_dev *pctrldev,\n\t\t\t\tstruct seq_file *s,\n\t\t\t\tunsigned int offset)\n{\n\tstruct owl_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctrldev);\n\n\tseq_printf(s, \"%s\", dev_name(pctrl->dev));\n}\n\nstatic const struct pinctrl_ops owl_pinctrl_ops = {\n\t.get_groups_count = owl_get_groups_count,\n\t.get_group_name = owl_get_group_name,\n\t.get_group_pins = owl_get_group_pins,\n\t.pin_dbg_show = owl_pin_dbg_show,\n\t.dt_node_to_map = pinconf_generic_dt_node_to_map_all,\n\t.dt_free_map = pinctrl_utils_free_map,\n};\n\nstatic int owl_get_funcs_count(struct pinctrl_dev *pctrldev)\n{\n\tstruct owl_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctrldev);\n\n\treturn pctrl->soc->nfunctions;\n}\n\nstatic const char *owl_get_func_name(struct pinctrl_dev *pctrldev,\n\t\t\t\tunsigned int function)\n{\n\tstruct owl_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctrldev);\n\n\treturn pctrl->soc->functions[function].name;\n}\n\nstatic int owl_get_func_groups(struct pinctrl_dev *pctrldev,\n\t\t\t\tunsigned int function,\n\t\t\t\tconst char * const **groups,\n\t\t\t\tunsigned int * const num_groups)\n{\n\tstruct owl_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctrldev);\n\n\t*groups = pctrl->soc->functions[function].groups;\n\t*num_groups = pctrl->soc->functions[function].ngroups;\n\n\treturn 0;\n}\n\nstatic inline int get_group_mfp_mask_val(const struct owl_pingroup *g,\n\t\t\t\tint function,\n\t\t\t\tu32 *mask,\n\t\t\t\tu32 *val)\n{\n\tint id;\n\tu32 option_num;\n\tu32 option_mask;\n\n\tfor (id = 0; id < g->nfuncs; id++) {\n\t\tif (g->funcs[id] == function)\n\t\t\tbreak;\n\t}\n\tif (WARN_ON(id == g->nfuncs))\n\t\treturn -EINVAL;\n\n\toption_num = (1 << g->mfpctl_width);\n\tif (id > option_num)\n\t\tid -= option_num;\n\n\toption_mask = option_num - 1;\n\t*mask = (option_mask  << g->mfpctl_shift);\n\t*val = (id << g->mfpctl_shift);\n\n\treturn 0;\n}\n\nstatic int owl_set_mux(struct pinctrl_dev *pctrldev,\n\t\t\t\tunsigned int function,\n\t\t\t\tunsigned int group)\n{\n\tstruct owl_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctrldev);\n\tconst struct owl_pingroup *g;\n\tunsigned long flags;\n\tu32 val, mask;\n\n\tg = &pctrl->soc->groups[group];\n\n\tif (get_group_mfp_mask_val(g, function, &mask, &val))\n\t\treturn -EINVAL;\n\n\traw_spin_lock_irqsave(&pctrl->lock, flags);\n\n\towl_update_bits(pctrl->base + g->mfpctl_reg, mask, val);\n\n\traw_spin_unlock_irqrestore(&pctrl->lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct pinmux_ops owl_pinmux_ops = {\n\t.get_functions_count = owl_get_funcs_count,\n\t.get_function_name = owl_get_func_name,\n\t.get_function_groups = owl_get_func_groups,\n\t.set_mux = owl_set_mux,\n};\n\nstatic int owl_pad_pinconf_reg(const struct owl_padinfo *info,\n\t\t\t\tunsigned int param,\n\t\t\t\tu32 *reg,\n\t\t\t\tu32 *bit,\n\t\t\t\tu32 *width)\n{\n\tswitch (param) {\n\tcase PIN_CONFIG_BIAS_BUS_HOLD:\n\tcase PIN_CONFIG_BIAS_HIGH_IMPEDANCE:\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\tif (!info->pullctl)\n\t\t\treturn -EINVAL;\n\t\t*reg = info->pullctl->reg;\n\t\t*bit = info->pullctl->shift;\n\t\t*width = info->pullctl->width;\n\t\tbreak;\n\tcase PIN_CONFIG_INPUT_SCHMITT_ENABLE:\n\t\tif (!info->st)\n\t\t\treturn -EINVAL;\n\t\t*reg = info->st->reg;\n\t\t*bit = info->st->shift;\n\t\t*width = info->st->width;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int owl_pin_config_get(struct pinctrl_dev *pctrldev,\n\t\t\t\tunsigned int pin,\n\t\t\t\tunsigned long *config)\n{\n\tint ret = 0;\n\tstruct owl_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctrldev);\n\tconst struct owl_padinfo *info;\n\tunsigned int param = pinconf_to_config_param(*config);\n\tu32 reg, bit, width, arg;\n\n\tinfo = &pctrl->soc->padinfo[pin];\n\n\tret = owl_pad_pinconf_reg(info, param, &reg, &bit, &width);\n\tif (ret)\n\t\treturn ret;\n\n\targ = owl_read_field(pctrl, reg, bit, width);\n\n\tif (!pctrl->soc->padctl_val2arg)\n\t\treturn -ENOTSUPP;\n\n\tret = pctrl->soc->padctl_val2arg(info, param, &arg);\n\tif (ret)\n\t\treturn ret;\n\n\t*config = pinconf_to_config_packed(param, arg);\n\n\treturn ret;\n}\n\nstatic int owl_pin_config_set(struct pinctrl_dev *pctrldev,\n\t\t\t\tunsigned int pin,\n\t\t\t\tunsigned long *configs,\n\t\t\t\tunsigned int num_configs)\n{\n\tstruct owl_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctrldev);\n\tconst struct owl_padinfo *info;\n\tunsigned long flags;\n\tunsigned int param;\n\tu32 reg, bit, width, arg;\n\tint ret = 0, i;\n\n\tinfo = &pctrl->soc->padinfo[pin];\n\n\tfor (i = 0; i < num_configs; i++) {\n\t\tparam = pinconf_to_config_param(configs[i]);\n\t\targ = pinconf_to_config_argument(configs[i]);\n\n\t\tret = owl_pad_pinconf_reg(info, param, &reg, &bit, &width);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (!pctrl->soc->padctl_arg2val)\n\t\t\treturn -ENOTSUPP;\n\n\t\tret = pctrl->soc->padctl_arg2val(info, param, &arg);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\traw_spin_lock_irqsave(&pctrl->lock, flags);\n\n\t\towl_write_field(pctrl, reg, arg, bit, width);\n\n\t\traw_spin_unlock_irqrestore(&pctrl->lock, flags);\n\t}\n\n\treturn ret;\n}\n\nstatic int owl_group_pinconf_reg(const struct owl_pingroup *g,\n\t\t\t\tunsigned int param,\n\t\t\t\tu32 *reg,\n\t\t\t\tu32 *bit,\n\t\t\t\tu32 *width)\n{\n\tswitch (param) {\n\tcase PIN_CONFIG_DRIVE_STRENGTH:\n\t\tif (g->drv_reg < 0)\n\t\t\treturn -EINVAL;\n\t\t*reg = g->drv_reg;\n\t\t*bit = g->drv_shift;\n\t\t*width = g->drv_width;\n\t\tbreak;\n\tcase PIN_CONFIG_SLEW_RATE:\n\t\tif (g->sr_reg < 0)\n\t\t\treturn -EINVAL;\n\t\t*reg = g->sr_reg;\n\t\t*bit = g->sr_shift;\n\t\t*width = g->sr_width;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int owl_group_pinconf_arg2val(const struct owl_pingroup *g,\n\t\t\t\tunsigned int param,\n\t\t\t\tu32 *arg)\n{\n\tswitch (param) {\n\tcase PIN_CONFIG_DRIVE_STRENGTH:\n\t\tswitch (*arg) {\n\t\tcase 2:\n\t\t\t*arg = OWL_PINCONF_DRV_2MA;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\t*arg = OWL_PINCONF_DRV_4MA;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\t*arg = OWL_PINCONF_DRV_8MA;\n\t\t\tbreak;\n\t\tcase 12:\n\t\t\t*arg = OWL_PINCONF_DRV_12MA;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase PIN_CONFIG_SLEW_RATE:\n\t\tif (*arg)\n\t\t\t*arg = OWL_PINCONF_SLEW_FAST;\n\t\telse\n\t\t\t*arg = OWL_PINCONF_SLEW_SLOW;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int owl_group_pinconf_val2arg(const struct owl_pingroup *g,\n\t\t\t\tunsigned int param,\n\t\t\t\tu32 *arg)\n{\n\tswitch (param) {\n\tcase PIN_CONFIG_DRIVE_STRENGTH:\n\t\tswitch (*arg) {\n\t\tcase OWL_PINCONF_DRV_2MA:\n\t\t\t*arg = 2;\n\t\t\tbreak;\n\t\tcase OWL_PINCONF_DRV_4MA:\n\t\t\t*arg = 4;\n\t\t\tbreak;\n\t\tcase OWL_PINCONF_DRV_8MA:\n\t\t\t*arg = 8;\n\t\t\tbreak;\n\t\tcase OWL_PINCONF_DRV_12MA:\n\t\t\t*arg = 12;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase PIN_CONFIG_SLEW_RATE:\n\t\tif (*arg)\n\t\t\t*arg = 1;\n\t\telse\n\t\t\t*arg = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int owl_group_config_get(struct pinctrl_dev *pctrldev,\n\t\t\t\tunsigned int group,\n\t\t\t\tunsigned long *config)\n{\n\tconst struct owl_pingroup *g;\n\tstruct owl_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctrldev);\n\tunsigned int param = pinconf_to_config_param(*config);\n\tu32 reg, bit, width, arg;\n\tint ret;\n\n\tg = &pctrl->soc->groups[group];\n\n\tret = owl_group_pinconf_reg(g, param, &reg, &bit, &width);\n\tif (ret)\n\t\treturn ret;\n\n\targ = owl_read_field(pctrl, reg, bit, width);\n\n\tret = owl_group_pinconf_val2arg(g, param, &arg);\n\tif (ret)\n\t\treturn ret;\n\n\t*config = pinconf_to_config_packed(param, arg);\n\n\treturn ret;\n}\n\nstatic int owl_group_config_set(struct pinctrl_dev *pctrldev,\n\t\t\t\tunsigned int group,\n\t\t\t\tunsigned long *configs,\n\t\t\t\tunsigned int num_configs)\n{\n\tconst struct owl_pingroup *g;\n\tstruct owl_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctrldev);\n\tunsigned long flags;\n\tunsigned int param;\n\tu32 reg, bit, width, arg;\n\tint ret, i;\n\n\tg = &pctrl->soc->groups[group];\n\n\tfor (i = 0; i < num_configs; i++) {\n\t\tparam = pinconf_to_config_param(configs[i]);\n\t\targ = pinconf_to_config_argument(configs[i]);\n\n\t\tret = owl_group_pinconf_reg(g, param, &reg, &bit, &width);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = owl_group_pinconf_arg2val(g, param, &arg);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\traw_spin_lock_irqsave(&pctrl->lock, flags);\n\n\t\towl_write_field(pctrl, reg, arg, bit, width);\n\n\t\traw_spin_unlock_irqrestore(&pctrl->lock, flags);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct pinconf_ops owl_pinconf_ops = {\n\t.is_generic = true,\n\t.pin_config_get = owl_pin_config_get,\n\t.pin_config_set = owl_pin_config_set,\n\t.pin_config_group_get = owl_group_config_get,\n\t.pin_config_group_set = owl_group_config_set,\n};\n\nstatic struct pinctrl_desc owl_pinctrl_desc = {\n\t.pctlops = &owl_pinctrl_ops,\n\t.pmxops = &owl_pinmux_ops,\n\t.confops = &owl_pinconf_ops,\n\t.owner = THIS_MODULE,\n};\n\nstatic const struct owl_gpio_port *\nowl_gpio_get_port(struct owl_pinctrl *pctrl, unsigned int *pin)\n{\n\tunsigned int start = 0, i;\n\n\tfor (i = 0; i < pctrl->soc->nports; i++) {\n\t\tconst struct owl_gpio_port *port = &pctrl->soc->ports[i];\n\n\t\tif (*pin >= start && *pin < start + port->pins) {\n\t\t\t*pin -= start;\n\t\t\treturn port;\n\t\t}\n\n\t\tstart += port->pins;\n\t}\n\n\treturn NULL;\n}\n\nstatic void owl_gpio_update_reg(void __iomem *base, unsigned int pin, int flag)\n{\n\tu32 val;\n\n\tval = readl_relaxed(base);\n\n\tif (flag)\n\t\tval |= BIT(pin);\n\telse\n\t\tval &= ~BIT(pin);\n\n\twritel_relaxed(val, base);\n}\n\nstatic int owl_gpio_request(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct owl_pinctrl *pctrl = gpiochip_get_data(chip);\n\tconst struct owl_gpio_port *port;\n\tvoid __iomem *gpio_base;\n\tunsigned long flags;\n\n\tport = owl_gpio_get_port(pctrl, &offset);\n\tif (WARN_ON(port == NULL))\n\t\treturn -ENODEV;\n\n\tgpio_base = pctrl->base + port->offset;\n\n\t \n\traw_spin_lock_irqsave(&pctrl->lock, flags);\n\towl_gpio_update_reg(gpio_base + port->outen, offset, true);\n\traw_spin_unlock_irqrestore(&pctrl->lock, flags);\n\n\treturn 0;\n}\n\nstatic void owl_gpio_free(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct owl_pinctrl *pctrl = gpiochip_get_data(chip);\n\tconst struct owl_gpio_port *port;\n\tvoid __iomem *gpio_base;\n\tunsigned long flags;\n\n\tport = owl_gpio_get_port(pctrl, &offset);\n\tif (WARN_ON(port == NULL))\n\t\treturn;\n\n\tgpio_base = pctrl->base + port->offset;\n\n\traw_spin_lock_irqsave(&pctrl->lock, flags);\n\t \n\towl_gpio_update_reg(gpio_base + port->outen, offset, false);\n\n\t \n\towl_gpio_update_reg(gpio_base + port->inen, offset, false);\n\traw_spin_unlock_irqrestore(&pctrl->lock, flags);\n}\n\nstatic int owl_gpio_get(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct owl_pinctrl *pctrl = gpiochip_get_data(chip);\n\tconst struct owl_gpio_port *port;\n\tvoid __iomem *gpio_base;\n\tunsigned long flags;\n\tu32 val;\n\n\tport = owl_gpio_get_port(pctrl, &offset);\n\tif (WARN_ON(port == NULL))\n\t\treturn -ENODEV;\n\n\tgpio_base = pctrl->base + port->offset;\n\n\traw_spin_lock_irqsave(&pctrl->lock, flags);\n\tval = readl_relaxed(gpio_base + port->dat);\n\traw_spin_unlock_irqrestore(&pctrl->lock, flags);\n\n\treturn !!(val & BIT(offset));\n}\n\nstatic void owl_gpio_set(struct gpio_chip *chip, unsigned int offset, int value)\n{\n\tstruct owl_pinctrl *pctrl = gpiochip_get_data(chip);\n\tconst struct owl_gpio_port *port;\n\tvoid __iomem *gpio_base;\n\tunsigned long flags;\n\n\tport = owl_gpio_get_port(pctrl, &offset);\n\tif (WARN_ON(port == NULL))\n\t\treturn;\n\n\tgpio_base = pctrl->base + port->offset;\n\n\traw_spin_lock_irqsave(&pctrl->lock, flags);\n\towl_gpio_update_reg(gpio_base + port->dat, offset, value);\n\traw_spin_unlock_irqrestore(&pctrl->lock, flags);\n}\n\nstatic int owl_gpio_direction_input(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct owl_pinctrl *pctrl = gpiochip_get_data(chip);\n\tconst struct owl_gpio_port *port;\n\tvoid __iomem *gpio_base;\n\tunsigned long flags;\n\n\tport = owl_gpio_get_port(pctrl, &offset);\n\tif (WARN_ON(port == NULL))\n\t\treturn -ENODEV;\n\n\tgpio_base = pctrl->base + port->offset;\n\n\traw_spin_lock_irqsave(&pctrl->lock, flags);\n\towl_gpio_update_reg(gpio_base + port->outen, offset, false);\n\towl_gpio_update_reg(gpio_base + port->inen, offset, true);\n\traw_spin_unlock_irqrestore(&pctrl->lock, flags);\n\n\treturn 0;\n}\n\nstatic int owl_gpio_direction_output(struct gpio_chip *chip,\n\t\t\t\tunsigned int offset, int value)\n{\n\tstruct owl_pinctrl *pctrl = gpiochip_get_data(chip);\n\tconst struct owl_gpio_port *port;\n\tvoid __iomem *gpio_base;\n\tunsigned long flags;\n\n\tport = owl_gpio_get_port(pctrl, &offset);\n\tif (WARN_ON(port == NULL))\n\t\treturn -ENODEV;\n\n\tgpio_base = pctrl->base + port->offset;\n\n\traw_spin_lock_irqsave(&pctrl->lock, flags);\n\towl_gpio_update_reg(gpio_base + port->inen, offset, false);\n\towl_gpio_update_reg(gpio_base + port->outen, offset, true);\n\towl_gpio_update_reg(gpio_base + port->dat, offset, value);\n\traw_spin_unlock_irqrestore(&pctrl->lock, flags);\n\n\treturn 0;\n}\n\nstatic void irq_set_type(struct owl_pinctrl *pctrl, int gpio, unsigned int type)\n{\n\tconst struct owl_gpio_port *port;\n\tvoid __iomem *gpio_base;\n\tunsigned long flags;\n\tunsigned int offset, value, irq_type = 0;\n\n\tswitch (type) {\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\t \n\t\tif (owl_gpio_get(&pctrl->chip, gpio))\n\t\t\tirq_type = OWL_GPIO_INT_EDGE_FALLING;\n\t\telse\n\t\t\tirq_type = OWL_GPIO_INT_EDGE_RISING;\n\t\tbreak;\n\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tirq_type = OWL_GPIO_INT_EDGE_RISING;\n\t\tbreak;\n\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tirq_type = OWL_GPIO_INT_EDGE_FALLING;\n\t\tbreak;\n\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tirq_type = OWL_GPIO_INT_LEVEL_HIGH;\n\t\tbreak;\n\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tirq_type = OWL_GPIO_INT_LEVEL_LOW;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tport = owl_gpio_get_port(pctrl, &gpio);\n\tif (WARN_ON(port == NULL))\n\t\treturn;\n\n\tgpio_base = pctrl->base + port->offset;\n\n\traw_spin_lock_irqsave(&pctrl->lock, flags);\n\n\toffset = (gpio < 16) ? 4 : 0;\n\tvalue = readl_relaxed(gpio_base + port->intc_type + offset);\n\tvalue &= ~(OWL_GPIO_INT_MASK << ((gpio % 16) * 2));\n\tvalue |= irq_type << ((gpio % 16) * 2);\n\twritel_relaxed(value, gpio_base + port->intc_type + offset);\n\n\traw_spin_unlock_irqrestore(&pctrl->lock, flags);\n}\n\nstatic void owl_gpio_irq_mask(struct irq_data *data)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(data);\n\tstruct owl_pinctrl *pctrl = gpiochip_get_data(gc);\n\tirq_hw_number_t hwirq = irqd_to_hwirq(data);\n\tconst struct owl_gpio_port *port;\n\tunsigned int gpio = hwirq;\n\tvoid __iomem *gpio_base;\n\tunsigned long flags;\n\tu32 val;\n\n\tport = owl_gpio_get_port(pctrl, &gpio);\n\tif (WARN_ON(port == NULL))\n\t\treturn;\n\n\tgpio_base = pctrl->base + port->offset;\n\n\traw_spin_lock_irqsave(&pctrl->lock, flags);\n\n\towl_gpio_update_reg(gpio_base + port->intc_msk, gpio, false);\n\n\t \n\tval = readl_relaxed(gpio_base + port->intc_msk);\n\tif (val == 0)\n\t\towl_gpio_update_reg(gpio_base + port->intc_ctl,\n\t\t\t\t\tOWL_GPIO_CTLR_ENABLE + port->shared_ctl_offset * 5, false);\n\n\traw_spin_unlock_irqrestore(&pctrl->lock, flags);\n\n\tgpiochip_disable_irq(gc, hwirq);\n}\n\nstatic void owl_gpio_irq_unmask(struct irq_data *data)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(data);\n\tstruct owl_pinctrl *pctrl = gpiochip_get_data(gc);\n\tirq_hw_number_t hwirq = irqd_to_hwirq(data);\n\tconst struct owl_gpio_port *port;\n\tunsigned int gpio = hwirq;\n\tvoid __iomem *gpio_base;\n\tunsigned long flags;\n\tu32 value;\n\n\tport = owl_gpio_get_port(pctrl, &gpio);\n\tif (WARN_ON(port == NULL))\n\t\treturn;\n\n\tgpiochip_enable_irq(gc, hwirq);\n\n\tgpio_base = pctrl->base + port->offset;\n\traw_spin_lock_irqsave(&pctrl->lock, flags);\n\n\t \n\tvalue = readl_relaxed(gpio_base + port->intc_ctl);\n\tvalue |= ((BIT(OWL_GPIO_CTLR_ENABLE) | BIT(OWL_GPIO_CTLR_SAMPLE_CLK_24M))\n\t\t\t<< port->shared_ctl_offset * 5);\n\twritel_relaxed(value, gpio_base + port->intc_ctl);\n\n\t \n\towl_gpio_update_reg(gpio_base + port->intc_msk, gpio, true);\n\n\traw_spin_unlock_irqrestore(&pctrl->lock, flags);\n}\n\nstatic void owl_gpio_irq_ack(struct irq_data *data)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(data);\n\tstruct owl_pinctrl *pctrl = gpiochip_get_data(gc);\n\tirq_hw_number_t hwirq = irqd_to_hwirq(data);\n\tconst struct owl_gpio_port *port;\n\tunsigned int gpio = hwirq;\n\tvoid __iomem *gpio_base;\n\tunsigned long flags;\n\n\t \n\tif (irqd_get_trigger_type(data) == IRQ_TYPE_EDGE_BOTH) {\n\t\tif (owl_gpio_get(gc, hwirq))\n\t\t\tirq_set_type(pctrl, hwirq, IRQ_TYPE_EDGE_FALLING);\n\t\telse\n\t\t\tirq_set_type(pctrl, hwirq, IRQ_TYPE_EDGE_RISING);\n\t}\n\n\tport = owl_gpio_get_port(pctrl, &gpio);\n\tif (WARN_ON(port == NULL))\n\t\treturn;\n\n\tgpio_base = pctrl->base + port->offset;\n\n\traw_spin_lock_irqsave(&pctrl->lock, flags);\n\n\towl_gpio_update_reg(gpio_base + port->intc_ctl,\n\t\t\t\tOWL_GPIO_CTLR_PENDING + port->shared_ctl_offset * 5, true);\n\n\traw_spin_unlock_irqrestore(&pctrl->lock, flags);\n}\n\nstatic int owl_gpio_irq_set_type(struct irq_data *data, unsigned int type)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(data);\n\tstruct owl_pinctrl *pctrl = gpiochip_get_data(gc);\n\n\tif (type & (IRQ_TYPE_LEVEL_LOW | IRQ_TYPE_LEVEL_HIGH))\n\t\tirq_set_handler_locked(data, handle_level_irq);\n\telse\n\t\tirq_set_handler_locked(data, handle_edge_irq);\n\n\tirq_set_type(pctrl, data->hwirq, type);\n\n\treturn 0;\n}\n\nstatic const struct irq_chip owl_gpio_irqchip = {\n\t.name = \"owl-irq\",\n\t.irq_ack = owl_gpio_irq_ack,\n\t.irq_mask = owl_gpio_irq_mask,\n\t.irq_unmask = owl_gpio_irq_unmask,\n\t.irq_set_type = owl_gpio_irq_set_type,\n\t.flags = IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic void owl_gpio_irq_handler(struct irq_desc *desc)\n{\n\tstruct owl_pinctrl *pctrl = irq_desc_get_handler_data(desc);\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tstruct irq_domain *domain = pctrl->chip.irq.domain;\n\tunsigned int parent = irq_desc_get_irq(desc);\n\tconst struct owl_gpio_port *port;\n\tvoid __iomem *base;\n\tunsigned int pin, offset = 0, i;\n\tunsigned long pending_irq;\n\n\tchained_irq_enter(chip, desc);\n\n\tfor (i = 0; i < pctrl->soc->nports; i++) {\n\t\tport = &pctrl->soc->ports[i];\n\t\tbase = pctrl->base + port->offset;\n\n\t\t \n\t\tif (parent != pctrl->irq[i])\n\t\t\tgoto skip;\n\n\t\tpending_irq = readl_relaxed(base + port->intc_pd);\n\n\t\tfor_each_set_bit(pin, &pending_irq, port->pins) {\n\t\t\tgeneric_handle_domain_irq(domain, offset + pin);\n\n\t\t\t \n\t\t\towl_gpio_update_reg(base + port->intc_pd, pin, true);\n\t\t}\n\nskip:\n\t\toffset += port->pins;\n\t}\n\n\tchained_irq_exit(chip, desc);\n}\n\nstatic int owl_gpio_init(struct owl_pinctrl *pctrl)\n{\n\tstruct gpio_chip *chip;\n\tstruct gpio_irq_chip *gpio_irq;\n\tint ret, i, j, offset;\n\n\tchip = &pctrl->chip;\n\tchip->base = -1;\n\tchip->ngpio = pctrl->soc->ngpios;\n\tchip->label = dev_name(pctrl->dev);\n\tchip->parent = pctrl->dev;\n\tchip->owner = THIS_MODULE;\n\n\tgpio_irq = &chip->irq;\n\tgpio_irq_chip_set_chip(gpio_irq, &owl_gpio_irqchip);\n\tgpio_irq->handler = handle_simple_irq;\n\tgpio_irq->default_type = IRQ_TYPE_NONE;\n\tgpio_irq->parent_handler = owl_gpio_irq_handler;\n\tgpio_irq->parent_handler_data = pctrl;\n\tgpio_irq->num_parents = pctrl->num_irq;\n\tgpio_irq->parents = pctrl->irq;\n\n\tgpio_irq->map = devm_kcalloc(pctrl->dev, chip->ngpio,\n\t\t\t\tsizeof(*gpio_irq->map), GFP_KERNEL);\n\tif (!gpio_irq->map)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0, offset = 0; i < pctrl->soc->nports; i++) {\n\t\tconst struct owl_gpio_port *port = &pctrl->soc->ports[i];\n\n\t\tfor (j = 0; j < port->pins; j++)\n\t\t\tgpio_irq->map[offset + j] = gpio_irq->parents[i];\n\n\t\toffset += port->pins;\n\t}\n\n\tret = gpiochip_add_data(&pctrl->chip, pctrl);\n\tif (ret) {\n\t\tdev_err(pctrl->dev, \"failed to register gpiochip\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint owl_pinctrl_probe(struct platform_device *pdev,\n\t\t\t\tstruct owl_pinctrl_soc_data *soc_data)\n{\n\tstruct owl_pinctrl *pctrl;\n\tint ret, i;\n\n\tpctrl = devm_kzalloc(&pdev->dev, sizeof(*pctrl), GFP_KERNEL);\n\tif (!pctrl)\n\t\treturn -ENOMEM;\n\n\tpctrl->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(pctrl->base))\n\t\treturn PTR_ERR(pctrl->base);\n\n\t \n\tpctrl->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(pctrl->clk)) {\n\t\tdev_err(&pdev->dev, \"no clock defined\\n\");\n\t\treturn PTR_ERR(pctrl->clk);\n\t}\n\n\tret = clk_prepare_enable(pctrl->clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"clk enable failed\\n\");\n\t\treturn ret;\n\t}\n\n\traw_spin_lock_init(&pctrl->lock);\n\n\towl_pinctrl_desc.name = dev_name(&pdev->dev);\n\towl_pinctrl_desc.pins = soc_data->pins;\n\towl_pinctrl_desc.npins = soc_data->npins;\n\n\tpctrl->chip.direction_input  = owl_gpio_direction_input;\n\tpctrl->chip.direction_output = owl_gpio_direction_output;\n\tpctrl->chip.get = owl_gpio_get;\n\tpctrl->chip.set = owl_gpio_set;\n\tpctrl->chip.request = owl_gpio_request;\n\tpctrl->chip.free = owl_gpio_free;\n\n\tpctrl->soc = soc_data;\n\tpctrl->dev = &pdev->dev;\n\n\tpctrl->pctrldev = devm_pinctrl_register(&pdev->dev,\n\t\t\t\t\t&owl_pinctrl_desc, pctrl);\n\tif (IS_ERR(pctrl->pctrldev)) {\n\t\tdev_err(&pdev->dev, \"could not register Actions OWL pinmux driver\\n\");\n\t\tret = PTR_ERR(pctrl->pctrldev);\n\t\tgoto err_exit;\n\t}\n\n\tret = platform_irq_count(pdev);\n\tif (ret < 0)\n\t\tgoto err_exit;\n\n\tpctrl->num_irq = ret;\n\n\tpctrl->irq = devm_kcalloc(&pdev->dev, pctrl->num_irq,\n\t\t\t\t\tsizeof(*pctrl->irq), GFP_KERNEL);\n\tif (!pctrl->irq) {\n\t\tret = -ENOMEM;\n\t\tgoto err_exit;\n\t}\n\n\tfor (i = 0; i < pctrl->num_irq ; i++) {\n\t\tret = platform_get_irq(pdev, i);\n\t\tif (ret < 0)\n\t\t\tgoto err_exit;\n\t\tpctrl->irq[i] = ret;\n\t}\n\n\tret = owl_gpio_init(pctrl);\n\tif (ret)\n\t\tgoto err_exit;\n\n\tplatform_set_drvdata(pdev, pctrl);\n\n\treturn 0;\n\nerr_exit:\n\tclk_disable_unprepare(pctrl->clk);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}