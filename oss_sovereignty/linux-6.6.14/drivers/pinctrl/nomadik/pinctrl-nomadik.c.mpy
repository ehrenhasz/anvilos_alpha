{
  "module_name": "pinctrl-nomadik.c",
  "hash_id": "f0313049059378f53e392b194d3923665272f6bf212cdb19850c0adf11366917",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/nomadik/pinctrl-nomadik.c",
  "human_readable_source": "\n \n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/gpio/driver.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/of_address.h>\n#include <linux/of_device.h>\n#include <linux/platform_device.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\n \n#include <linux/pinctrl/consumer.h>\n#include <linux/pinctrl/machine.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinmux.h>\n\n#include \"../core.h\"\n#include \"../pinctrl-utils.h\"\n\n#include \"pinctrl-nomadik.h\"\n\n \n\n \n\ntypedef unsigned long pin_cfg_t;\n\n#define PIN_NUM_MASK\t\t0x1ff\n#define PIN_NUM(x)\t\t((x) & PIN_NUM_MASK)\n\n#define PIN_ALT_SHIFT\t\t9\n#define PIN_ALT_MASK\t\t(0x3 << PIN_ALT_SHIFT)\n#define PIN_ALT(x)\t\t(((x) & PIN_ALT_MASK) >> PIN_ALT_SHIFT)\n#define PIN_GPIO\t\t(NMK_GPIO_ALT_GPIO << PIN_ALT_SHIFT)\n#define PIN_ALT_A\t\t(NMK_GPIO_ALT_A << PIN_ALT_SHIFT)\n#define PIN_ALT_B\t\t(NMK_GPIO_ALT_B << PIN_ALT_SHIFT)\n#define PIN_ALT_C\t\t(NMK_GPIO_ALT_C << PIN_ALT_SHIFT)\n\n#define PIN_PULL_SHIFT\t\t11\n#define PIN_PULL_MASK\t\t(0x3 << PIN_PULL_SHIFT)\n#define PIN_PULL(x)\t\t(((x) & PIN_PULL_MASK) >> PIN_PULL_SHIFT)\n#define PIN_PULL_NONE\t\t(NMK_GPIO_PULL_NONE << PIN_PULL_SHIFT)\n#define PIN_PULL_UP\t\t(NMK_GPIO_PULL_UP << PIN_PULL_SHIFT)\n#define PIN_PULL_DOWN\t\t(NMK_GPIO_PULL_DOWN << PIN_PULL_SHIFT)\n\n#define PIN_SLPM_SHIFT\t\t13\n#define PIN_SLPM_MASK\t\t(0x1 << PIN_SLPM_SHIFT)\n#define PIN_SLPM(x)\t\t(((x) & PIN_SLPM_MASK) >> PIN_SLPM_SHIFT)\n#define PIN_SLPM_MAKE_INPUT\t(NMK_GPIO_SLPM_INPUT << PIN_SLPM_SHIFT)\n#define PIN_SLPM_NOCHANGE\t(NMK_GPIO_SLPM_NOCHANGE << PIN_SLPM_SHIFT)\n \n#define PIN_SLPM_WAKEUP_ENABLE\t(NMK_GPIO_SLPM_WAKEUP_ENABLE << PIN_SLPM_SHIFT)\n#define PIN_SLPM_WAKEUP_DISABLE\t(NMK_GPIO_SLPM_WAKEUP_DISABLE << PIN_SLPM_SHIFT)\n#define PIN_SLPM_USE_MUX_SETTINGS_IN_SLEEP PIN_SLPM_WAKEUP_DISABLE\n\n#define PIN_SLPM_GPIO  PIN_SLPM_WAKEUP_ENABLE  \n#define PIN_SLPM_ALTFUNC PIN_SLPM_WAKEUP_DISABLE  \n\n#define PIN_DIR_SHIFT\t\t14\n#define PIN_DIR_MASK\t\t(0x1 << PIN_DIR_SHIFT)\n#define PIN_DIR(x)\t\t(((x) & PIN_DIR_MASK) >> PIN_DIR_SHIFT)\n#define PIN_DIR_INPUT\t\t(0 << PIN_DIR_SHIFT)\n#define PIN_DIR_OUTPUT\t\t(1 << PIN_DIR_SHIFT)\n\n#define PIN_VAL_SHIFT\t\t15\n#define PIN_VAL_MASK\t\t(0x1 << PIN_VAL_SHIFT)\n#define PIN_VAL(x)\t\t(((x) & PIN_VAL_MASK) >> PIN_VAL_SHIFT)\n#define PIN_VAL_LOW\t\t(0 << PIN_VAL_SHIFT)\n#define PIN_VAL_HIGH\t\t(1 << PIN_VAL_SHIFT)\n\n#define PIN_SLPM_PULL_SHIFT\t16\n#define PIN_SLPM_PULL_MASK\t(0x7 << PIN_SLPM_PULL_SHIFT)\n#define PIN_SLPM_PULL(x)\t\\\n\t(((x) & PIN_SLPM_PULL_MASK) >> PIN_SLPM_PULL_SHIFT)\n#define PIN_SLPM_PULL_NONE\t\\\n\t((1 + NMK_GPIO_PULL_NONE) << PIN_SLPM_PULL_SHIFT)\n#define PIN_SLPM_PULL_UP\t\\\n\t((1 + NMK_GPIO_PULL_UP) << PIN_SLPM_PULL_SHIFT)\n#define PIN_SLPM_PULL_DOWN\t\\\n\t((1 + NMK_GPIO_PULL_DOWN) << PIN_SLPM_PULL_SHIFT)\n\n#define PIN_SLPM_DIR_SHIFT\t19\n#define PIN_SLPM_DIR_MASK\t(0x3 << PIN_SLPM_DIR_SHIFT)\n#define PIN_SLPM_DIR(x)\t\t\\\n\t(((x) & PIN_SLPM_DIR_MASK) >> PIN_SLPM_DIR_SHIFT)\n#define PIN_SLPM_DIR_INPUT\t((1 + 0) << PIN_SLPM_DIR_SHIFT)\n#define PIN_SLPM_DIR_OUTPUT\t((1 + 1) << PIN_SLPM_DIR_SHIFT)\n\n#define PIN_SLPM_VAL_SHIFT\t21\n#define PIN_SLPM_VAL_MASK\t(0x3 << PIN_SLPM_VAL_SHIFT)\n#define PIN_SLPM_VAL(x)\t\t\\\n\t(((x) & PIN_SLPM_VAL_MASK) >> PIN_SLPM_VAL_SHIFT)\n#define PIN_SLPM_VAL_LOW\t((1 + 0) << PIN_SLPM_VAL_SHIFT)\n#define PIN_SLPM_VAL_HIGH\t((1 + 1) << PIN_SLPM_VAL_SHIFT)\n\n#define PIN_SLPM_PDIS_SHIFT\t\t23\n#define PIN_SLPM_PDIS_MASK\t\t(0x3 << PIN_SLPM_PDIS_SHIFT)\n#define PIN_SLPM_PDIS(x)\t\\\n\t(((x) & PIN_SLPM_PDIS_MASK) >> PIN_SLPM_PDIS_SHIFT)\n#define PIN_SLPM_PDIS_NO_CHANGE\t\t(0 << PIN_SLPM_PDIS_SHIFT)\n#define PIN_SLPM_PDIS_DISABLED\t\t(1 << PIN_SLPM_PDIS_SHIFT)\n#define PIN_SLPM_PDIS_ENABLED\t\t(2 << PIN_SLPM_PDIS_SHIFT)\n\n#define PIN_LOWEMI_SHIFT\t25\n#define PIN_LOWEMI_MASK\t\t(0x1 << PIN_LOWEMI_SHIFT)\n#define PIN_LOWEMI(x)\t\t(((x) & PIN_LOWEMI_MASK) >> PIN_LOWEMI_SHIFT)\n#define PIN_LOWEMI_DISABLED\t(0 << PIN_LOWEMI_SHIFT)\n#define PIN_LOWEMI_ENABLED\t(1 << PIN_LOWEMI_SHIFT)\n\n#define PIN_GPIOMODE_SHIFT\t26\n#define PIN_GPIOMODE_MASK\t(0x1 << PIN_GPIOMODE_SHIFT)\n#define PIN_GPIOMODE(x)\t\t(((x) & PIN_GPIOMODE_MASK) >> PIN_GPIOMODE_SHIFT)\n#define PIN_GPIOMODE_DISABLED\t(0 << PIN_GPIOMODE_SHIFT)\n#define PIN_GPIOMODE_ENABLED\t(1 << PIN_GPIOMODE_SHIFT)\n\n#define PIN_SLEEPMODE_SHIFT\t27\n#define PIN_SLEEPMODE_MASK\t(0x1 << PIN_SLEEPMODE_SHIFT)\n#define PIN_SLEEPMODE(x)\t(((x) & PIN_SLEEPMODE_MASK) >> PIN_SLEEPMODE_SHIFT)\n#define PIN_SLEEPMODE_DISABLED\t(0 << PIN_SLEEPMODE_SHIFT)\n#define PIN_SLEEPMODE_ENABLED\t(1 << PIN_SLEEPMODE_SHIFT)\n\n\n \n#define PIN_INPUT_PULLDOWN\t(PIN_DIR_INPUT | PIN_PULL_DOWN)\n#define PIN_INPUT_PULLUP\t(PIN_DIR_INPUT | PIN_PULL_UP)\n#define PIN_INPUT_NOPULL\t(PIN_DIR_INPUT | PIN_PULL_NONE)\n#define PIN_OUTPUT_LOW\t\t(PIN_DIR_OUTPUT | PIN_VAL_LOW)\n#define PIN_OUTPUT_HIGH\t\t(PIN_DIR_OUTPUT | PIN_VAL_HIGH)\n\n#define PIN_SLPM_INPUT_PULLDOWN\t(PIN_SLPM_DIR_INPUT | PIN_SLPM_PULL_DOWN)\n#define PIN_SLPM_INPUT_PULLUP\t(PIN_SLPM_DIR_INPUT | PIN_SLPM_PULL_UP)\n#define PIN_SLPM_INPUT_NOPULL\t(PIN_SLPM_DIR_INPUT | PIN_SLPM_PULL_NONE)\n#define PIN_SLPM_OUTPUT_LOW\t(PIN_SLPM_DIR_OUTPUT | PIN_SLPM_VAL_LOW)\n#define PIN_SLPM_OUTPUT_HIGH\t(PIN_SLPM_DIR_OUTPUT | PIN_SLPM_VAL_HIGH)\n\n#define PIN_CFG_DEFAULT\t\t(0)\n\n#define PIN_CFG(num, alt)\t\t\\\n\t(PIN_CFG_DEFAULT |\\\n\t (PIN_NUM(num) | PIN_##alt))\n\n#define PIN_CFG_INPUT(num, alt, pull)\t\t\\\n\t(PIN_CFG_DEFAULT |\\\n\t (PIN_NUM(num) | PIN_##alt | PIN_INPUT_##pull))\n\n#define PIN_CFG_OUTPUT(num, alt, val)\t\t\\\n\t(PIN_CFG_DEFAULT |\\\n\t (PIN_NUM(num) | PIN_##alt | PIN_OUTPUT_##val))\n\n \n\n#define GPIO_BLOCK_SHIFT 5\n#define NMK_GPIO_PER_CHIP (1 << GPIO_BLOCK_SHIFT)\n#define NMK_MAX_BANKS DIV_ROUND_UP(512, NMK_GPIO_PER_CHIP)\n\n \n#define NMK_GPIO_DAT\t0x00\n#define NMK_GPIO_DATS\t0x04\n#define NMK_GPIO_DATC\t0x08\n#define NMK_GPIO_PDIS\t0x0c\n#define NMK_GPIO_DIR\t0x10\n#define NMK_GPIO_DIRS\t0x14\n#define NMK_GPIO_DIRC\t0x18\n#define NMK_GPIO_SLPC\t0x1c\n#define NMK_GPIO_AFSLA\t0x20\n#define NMK_GPIO_AFSLB\t0x24\n#define NMK_GPIO_LOWEMI\t0x28\n\n#define NMK_GPIO_RIMSC\t0x40\n#define NMK_GPIO_FIMSC\t0x44\n#define NMK_GPIO_IS\t0x48\n#define NMK_GPIO_IC\t0x4c\n#define NMK_GPIO_RWIMSC\t0x50\n#define NMK_GPIO_FWIMSC\t0x54\n#define NMK_GPIO_WKS\t0x58\n \n#define NMK_GPIO_EDGELEVEL 0x5C\n#define NMK_GPIO_LEVEL\t0x60\n\n\n \nenum nmk_gpio_pull {\n\tNMK_GPIO_PULL_NONE,\n\tNMK_GPIO_PULL_UP,\n\tNMK_GPIO_PULL_DOWN,\n};\n\n \nenum nmk_gpio_slpm {\n\tNMK_GPIO_SLPM_INPUT,\n\tNMK_GPIO_SLPM_WAKEUP_ENABLE = NMK_GPIO_SLPM_INPUT,\n\tNMK_GPIO_SLPM_NOCHANGE,\n\tNMK_GPIO_SLPM_WAKEUP_DISABLE = NMK_GPIO_SLPM_NOCHANGE,\n};\n\nstruct nmk_gpio_chip {\n\tstruct gpio_chip chip;\n\tvoid __iomem *addr;\n\tstruct clk *clk;\n\tunsigned int bank;\n\tvoid (*set_ioforce)(bool enable);\n\tspinlock_t lock;\n\tbool sleepmode;\n\t \n\tu32 edge_rising;\n\tu32 edge_falling;\n\tu32 real_wake;\n\tu32 rwimsc;\n\tu32 fwimsc;\n\tu32 rimsc;\n\tu32 fimsc;\n\tu32 pull_up;\n\tu32 lowemi;\n};\n\n \nstruct nmk_pinctrl {\n\tstruct device *dev;\n\tstruct pinctrl_dev *pctl;\n\tconst struct nmk_pinctrl_soc_data *soc;\n\tvoid __iomem *prcm_base;\n};\n\nstatic struct nmk_gpio_chip *nmk_gpio_chips[NMK_MAX_BANKS];\n\nstatic DEFINE_SPINLOCK(nmk_gpio_slpm_lock);\n\n#define NUM_BANKS ARRAY_SIZE(nmk_gpio_chips)\n\nstatic void __nmk_gpio_set_mode(struct nmk_gpio_chip *nmk_chip,\n\t\t\t\tunsigned offset, int gpio_mode)\n{\n\tu32 afunc, bfunc;\n\n\tafunc = readl(nmk_chip->addr + NMK_GPIO_AFSLA) & ~BIT(offset);\n\tbfunc = readl(nmk_chip->addr + NMK_GPIO_AFSLB) & ~BIT(offset);\n\tif (gpio_mode & NMK_GPIO_ALT_A)\n\t\tafunc |= BIT(offset);\n\tif (gpio_mode & NMK_GPIO_ALT_B)\n\t\tbfunc |= BIT(offset);\n\twritel(afunc, nmk_chip->addr + NMK_GPIO_AFSLA);\n\twritel(bfunc, nmk_chip->addr + NMK_GPIO_AFSLB);\n}\n\nstatic void __nmk_gpio_set_slpm(struct nmk_gpio_chip *nmk_chip,\n\t\t\t\tunsigned offset, enum nmk_gpio_slpm mode)\n{\n\tu32 slpm;\n\n\tslpm = readl(nmk_chip->addr + NMK_GPIO_SLPC);\n\tif (mode == NMK_GPIO_SLPM_NOCHANGE)\n\t\tslpm |= BIT(offset);\n\telse\n\t\tslpm &= ~BIT(offset);\n\twritel(slpm, nmk_chip->addr + NMK_GPIO_SLPC);\n}\n\nstatic void __nmk_gpio_set_pull(struct nmk_gpio_chip *nmk_chip,\n\t\t\t\tunsigned offset, enum nmk_gpio_pull pull)\n{\n\tu32 pdis;\n\n\tpdis = readl(nmk_chip->addr + NMK_GPIO_PDIS);\n\tif (pull == NMK_GPIO_PULL_NONE) {\n\t\tpdis |= BIT(offset);\n\t\tnmk_chip->pull_up &= ~BIT(offset);\n\t} else {\n\t\tpdis &= ~BIT(offset);\n\t}\n\n\twritel(pdis, nmk_chip->addr + NMK_GPIO_PDIS);\n\n\tif (pull == NMK_GPIO_PULL_UP) {\n\t\tnmk_chip->pull_up |= BIT(offset);\n\t\twritel(BIT(offset), nmk_chip->addr + NMK_GPIO_DATS);\n\t} else if (pull == NMK_GPIO_PULL_DOWN) {\n\t\tnmk_chip->pull_up &= ~BIT(offset);\n\t\twritel(BIT(offset), nmk_chip->addr + NMK_GPIO_DATC);\n\t}\n}\n\nstatic void __nmk_gpio_set_lowemi(struct nmk_gpio_chip *nmk_chip,\n\t\t\t\t  unsigned offset, bool lowemi)\n{\n\tbool enabled = nmk_chip->lowemi & BIT(offset);\n\n\tif (lowemi == enabled)\n\t\treturn;\n\n\tif (lowemi)\n\t\tnmk_chip->lowemi |= BIT(offset);\n\telse\n\t\tnmk_chip->lowemi &= ~BIT(offset);\n\n\twritel_relaxed(nmk_chip->lowemi,\n\t\t       nmk_chip->addr + NMK_GPIO_LOWEMI);\n}\n\nstatic void __nmk_gpio_make_input(struct nmk_gpio_chip *nmk_chip,\n\t\t\t\t  unsigned offset)\n{\n\twritel(BIT(offset), nmk_chip->addr + NMK_GPIO_DIRC);\n}\n\nstatic void __nmk_gpio_set_output(struct nmk_gpio_chip *nmk_chip,\n\t\t\t\t  unsigned offset, int val)\n{\n\tif (val)\n\t\twritel(BIT(offset), nmk_chip->addr + NMK_GPIO_DATS);\n\telse\n\t\twritel(BIT(offset), nmk_chip->addr + NMK_GPIO_DATC);\n}\n\nstatic void __nmk_gpio_make_output(struct nmk_gpio_chip *nmk_chip,\n\t\t\t\t  unsigned offset, int val)\n{\n\twritel(BIT(offset), nmk_chip->addr + NMK_GPIO_DIRS);\n\t__nmk_gpio_set_output(nmk_chip, offset, val);\n}\n\nstatic void __nmk_gpio_set_mode_safe(struct nmk_gpio_chip *nmk_chip,\n\t\t\t\t     unsigned offset, int gpio_mode,\n\t\t\t\t     bool glitch)\n{\n\tu32 rwimsc = nmk_chip->rwimsc;\n\tu32 fwimsc = nmk_chip->fwimsc;\n\n\tif (glitch && nmk_chip->set_ioforce) {\n\t\tu32 bit = BIT(offset);\n\n\t\t \n\t\twritel(rwimsc & ~bit, nmk_chip->addr + NMK_GPIO_RWIMSC);\n\t\twritel(fwimsc & ~bit, nmk_chip->addr + NMK_GPIO_FWIMSC);\n\n\t\tnmk_chip->set_ioforce(true);\n\t}\n\n\t__nmk_gpio_set_mode(nmk_chip, offset, gpio_mode);\n\n\tif (glitch && nmk_chip->set_ioforce) {\n\t\tnmk_chip->set_ioforce(false);\n\n\t\twritel(rwimsc, nmk_chip->addr + NMK_GPIO_RWIMSC);\n\t\twritel(fwimsc, nmk_chip->addr + NMK_GPIO_FWIMSC);\n\t}\n}\n\nstatic void\nnmk_gpio_disable_lazy_irq(struct nmk_gpio_chip *nmk_chip, unsigned offset)\n{\n\tu32 falling = nmk_chip->fimsc & BIT(offset);\n\tu32 rising = nmk_chip->rimsc & BIT(offset);\n\tint gpio = nmk_chip->chip.base + offset;\n\tint irq = irq_find_mapping(nmk_chip->chip.irq.domain, offset);\n\tstruct irq_data *d = irq_get_irq_data(irq);\n\n\tif (!rising && !falling)\n\t\treturn;\n\n\tif (!d || !irqd_irq_disabled(d))\n\t\treturn;\n\n\tif (rising) {\n\t\tnmk_chip->rimsc &= ~BIT(offset);\n\t\twritel_relaxed(nmk_chip->rimsc,\n\t\t\t       nmk_chip->addr + NMK_GPIO_RIMSC);\n\t}\n\n\tif (falling) {\n\t\tnmk_chip->fimsc &= ~BIT(offset);\n\t\twritel_relaxed(nmk_chip->fimsc,\n\t\t\t       nmk_chip->addr + NMK_GPIO_FIMSC);\n\t}\n\n\tdev_dbg(nmk_chip->chip.parent, \"%d: clearing interrupt mask\\n\", gpio);\n}\n\nstatic void nmk_write_masked(void __iomem *reg, u32 mask, u32 value)\n{\n\tu32 val;\n\n\tval = readl(reg);\n\tval = ((val & ~mask) | (value & mask));\n\twritel(val, reg);\n}\n\nstatic void nmk_prcm_altcx_set_mode(struct nmk_pinctrl *npct,\n\tunsigned offset, unsigned alt_num)\n{\n\tint i;\n\tu16 reg;\n\tu8 bit;\n\tu8 alt_index;\n\tconst struct prcm_gpiocr_altcx_pin_desc *pin_desc;\n\tconst u16 *gpiocr_regs;\n\n\tif (!npct->prcm_base)\n\t\treturn;\n\n\tif (alt_num > PRCM_IDX_GPIOCR_ALTC_MAX) {\n\t\tdev_err(npct->dev, \"PRCM GPIOCR: alternate-C%i is invalid\\n\",\n\t\t\talt_num);\n\t\treturn;\n\t}\n\n\tfor (i = 0 ; i < npct->soc->npins_altcx ; i++) {\n\t\tif (npct->soc->altcx_pins[i].pin == offset)\n\t\t\tbreak;\n\t}\n\tif (i == npct->soc->npins_altcx) {\n\t\tdev_dbg(npct->dev, \"PRCM GPIOCR: pin %i is not found\\n\",\n\t\t\toffset);\n\t\treturn;\n\t}\n\n\tpin_desc = npct->soc->altcx_pins + i;\n\tgpiocr_regs = npct->soc->prcm_gpiocr_registers;\n\n\t \n\tif (!alt_num) {\n\t\tfor (i = 0 ; i < PRCM_IDX_GPIOCR_ALTC_MAX ; i++) {\n\t\t\tif (pin_desc->altcx[i].used == true) {\n\t\t\t\treg = gpiocr_regs[pin_desc->altcx[i].reg_index];\n\t\t\t\tbit = pin_desc->altcx[i].control_bit;\n\t\t\t\tif (readl(npct->prcm_base + reg) & BIT(bit)) {\n\t\t\t\t\tnmk_write_masked(npct->prcm_base + reg, BIT(bit), 0);\n\t\t\t\t\tdev_dbg(npct->dev,\n\t\t\t\t\t\t\"PRCM GPIOCR: pin %i: alternate-C%i has been disabled\\n\",\n\t\t\t\t\t\toffset, i+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\talt_index = alt_num - 1;\n\tif (pin_desc->altcx[alt_index].used == false) {\n\t\tdev_warn(npct->dev,\n\t\t\t\"PRCM GPIOCR: pin %i: alternate-C%i does not exist\\n\",\n\t\t\toffset, alt_num);\n\t\treturn;\n\t}\n\n\t \n\tfor (i = 0 ; i < PRCM_IDX_GPIOCR_ALTC_MAX ; i++) {\n\t\tif (i == alt_index)\n\t\t\tcontinue;\n\t\tif (pin_desc->altcx[i].used == true) {\n\t\t\treg = gpiocr_regs[pin_desc->altcx[i].reg_index];\n\t\t\tbit = pin_desc->altcx[i].control_bit;\n\t\t\tif (readl(npct->prcm_base + reg) & BIT(bit)) {\n\t\t\t\tnmk_write_masked(npct->prcm_base + reg, BIT(bit), 0);\n\t\t\t\tdev_dbg(npct->dev,\n\t\t\t\t\t\"PRCM GPIOCR: pin %i: alternate-C%i has been disabled\\n\",\n\t\t\t\t\toffset, i+1);\n\t\t\t}\n\t\t}\n\t}\n\n\treg = gpiocr_regs[pin_desc->altcx[alt_index].reg_index];\n\tbit = pin_desc->altcx[alt_index].control_bit;\n\tdev_dbg(npct->dev, \"PRCM GPIOCR: pin %i: alternate-C%i has been selected\\n\",\n\t\toffset, alt_index+1);\n\tnmk_write_masked(npct->prcm_base + reg, BIT(bit), BIT(bit));\n}\n\n \nstatic void nmk_gpio_glitch_slpm_init(unsigned int *slpm)\n{\n\tint i;\n\n\tfor (i = 0; i < NUM_BANKS; i++) {\n\t\tstruct nmk_gpio_chip *chip = nmk_gpio_chips[i];\n\t\tunsigned int temp = slpm[i];\n\n\t\tif (!chip)\n\t\t\tbreak;\n\n\t\tclk_enable(chip->clk);\n\n\t\tslpm[i] = readl(chip->addr + NMK_GPIO_SLPC);\n\t\twritel(temp, chip->addr + NMK_GPIO_SLPC);\n\t}\n}\n\nstatic void nmk_gpio_glitch_slpm_restore(unsigned int *slpm)\n{\n\tint i;\n\n\tfor (i = 0; i < NUM_BANKS; i++) {\n\t\tstruct nmk_gpio_chip *chip = nmk_gpio_chips[i];\n\n\t\tif (!chip)\n\t\t\tbreak;\n\n\t\twritel(slpm[i], chip->addr + NMK_GPIO_SLPC);\n\n\t\tclk_disable(chip->clk);\n\t}\n}\n\nstatic int __maybe_unused nmk_prcm_gpiocr_get_mode(struct pinctrl_dev *pctldev, int gpio)\n{\n\tint i;\n\tu16 reg;\n\tu8 bit;\n\tstruct nmk_pinctrl *npct = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct prcm_gpiocr_altcx_pin_desc *pin_desc;\n\tconst u16 *gpiocr_regs;\n\n\tif (!npct->prcm_base)\n\t\treturn NMK_GPIO_ALT_C;\n\n\tfor (i = 0; i < npct->soc->npins_altcx; i++) {\n\t\tif (npct->soc->altcx_pins[i].pin == gpio)\n\t\t\tbreak;\n\t}\n\tif (i == npct->soc->npins_altcx)\n\t\treturn NMK_GPIO_ALT_C;\n\n\tpin_desc = npct->soc->altcx_pins + i;\n\tgpiocr_regs = npct->soc->prcm_gpiocr_registers;\n\tfor (i = 0; i < PRCM_IDX_GPIOCR_ALTC_MAX; i++) {\n\t\tif (pin_desc->altcx[i].used == true) {\n\t\t\treg = gpiocr_regs[pin_desc->altcx[i].reg_index];\n\t\t\tbit = pin_desc->altcx[i].control_bit;\n\t\t\tif (readl(npct->prcm_base + reg) & BIT(bit))\n\t\t\t\treturn NMK_GPIO_ALT_C+i+1;\n\t\t}\n\t}\n\treturn NMK_GPIO_ALT_C;\n}\n\n \n\nstatic void nmk_gpio_irq_ack(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct nmk_gpio_chip *nmk_chip = gpiochip_get_data(gc);\n\n\tclk_enable(nmk_chip->clk);\n\twritel(BIT(d->hwirq), nmk_chip->addr + NMK_GPIO_IC);\n\tclk_disable(nmk_chip->clk);\n}\n\nenum nmk_gpio_irq_type {\n\tNORMAL,\n\tWAKE,\n};\n\nstatic void __nmk_gpio_irq_modify(struct nmk_gpio_chip *nmk_chip,\n\t\t\t\t  int offset, enum nmk_gpio_irq_type which,\n\t\t\t\t  bool enable)\n{\n\tu32 *rimscval;\n\tu32 *fimscval;\n\tu32 rimscreg;\n\tu32 fimscreg;\n\n\tif (which == NORMAL) {\n\t\trimscreg = NMK_GPIO_RIMSC;\n\t\tfimscreg = NMK_GPIO_FIMSC;\n\t\trimscval = &nmk_chip->rimsc;\n\t\tfimscval = &nmk_chip->fimsc;\n\t} else  {\n\t\trimscreg = NMK_GPIO_RWIMSC;\n\t\tfimscreg = NMK_GPIO_FWIMSC;\n\t\trimscval = &nmk_chip->rwimsc;\n\t\tfimscval = &nmk_chip->fwimsc;\n\t}\n\n\t \n\tif (nmk_chip->edge_rising & BIT(offset)) {\n\t\tif (enable)\n\t\t\t*rimscval |= BIT(offset);\n\t\telse\n\t\t\t*rimscval &= ~BIT(offset);\n\t\twritel(*rimscval, nmk_chip->addr + rimscreg);\n\t}\n\tif (nmk_chip->edge_falling & BIT(offset)) {\n\t\tif (enable)\n\t\t\t*fimscval |= BIT(offset);\n\t\telse\n\t\t\t*fimscval &= ~BIT(offset);\n\t\twritel(*fimscval, nmk_chip->addr + fimscreg);\n\t}\n}\n\nstatic void __nmk_gpio_set_wake(struct nmk_gpio_chip *nmk_chip,\n\t\t\t\tint offset, bool on)\n{\n\t \n\tif (nmk_chip->sleepmode && on) {\n\t\t__nmk_gpio_set_slpm(nmk_chip, offset,\n\t\t\t\t    NMK_GPIO_SLPM_WAKEUP_ENABLE);\n\t}\n\n\t__nmk_gpio_irq_modify(nmk_chip, offset, WAKE, on);\n}\n\nstatic void nmk_gpio_irq_maskunmask(struct nmk_gpio_chip *nmk_chip,\n\t\t\t\t    struct irq_data *d, bool enable)\n{\n\tunsigned long flags;\n\n\tclk_enable(nmk_chip->clk);\n\tspin_lock_irqsave(&nmk_gpio_slpm_lock, flags);\n\tspin_lock(&nmk_chip->lock);\n\n\t__nmk_gpio_irq_modify(nmk_chip, d->hwirq, NORMAL, enable);\n\n\tif (!(nmk_chip->real_wake & BIT(d->hwirq)))\n\t\t__nmk_gpio_set_wake(nmk_chip, d->hwirq, enable);\n\n\tspin_unlock(&nmk_chip->lock);\n\tspin_unlock_irqrestore(&nmk_gpio_slpm_lock, flags);\n\tclk_disable(nmk_chip->clk);\n}\n\nstatic void nmk_gpio_irq_mask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct nmk_gpio_chip *nmk_chip = gpiochip_get_data(gc);\n\n\tnmk_gpio_irq_maskunmask(nmk_chip, d, false);\n\tgpiochip_disable_irq(gc, irqd_to_hwirq(d));\n}\n\nstatic void nmk_gpio_irq_unmask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct nmk_gpio_chip *nmk_chip = gpiochip_get_data(gc);\n\n\tgpiochip_enable_irq(gc, irqd_to_hwirq(d));\n\tnmk_gpio_irq_maskunmask(nmk_chip, d, true);\n}\n\nstatic int nmk_gpio_irq_set_wake(struct irq_data *d, unsigned int on)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct nmk_gpio_chip *nmk_chip = gpiochip_get_data(gc);\n\tunsigned long flags;\n\n\tclk_enable(nmk_chip->clk);\n\tspin_lock_irqsave(&nmk_gpio_slpm_lock, flags);\n\tspin_lock(&nmk_chip->lock);\n\n\tif (irqd_irq_disabled(d))\n\t\t__nmk_gpio_set_wake(nmk_chip, d->hwirq, on);\n\n\tif (on)\n\t\tnmk_chip->real_wake |= BIT(d->hwirq);\n\telse\n\t\tnmk_chip->real_wake &= ~BIT(d->hwirq);\n\n\tspin_unlock(&nmk_chip->lock);\n\tspin_unlock_irqrestore(&nmk_gpio_slpm_lock, flags);\n\tclk_disable(nmk_chip->clk);\n\n\treturn 0;\n}\n\nstatic int nmk_gpio_irq_set_type(struct irq_data *d, unsigned int type)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct nmk_gpio_chip *nmk_chip = gpiochip_get_data(gc);\n\tbool enabled = !irqd_irq_disabled(d);\n\tbool wake = irqd_is_wakeup_set(d);\n\tunsigned long flags;\n\n\tif (type & IRQ_TYPE_LEVEL_HIGH)\n\t\treturn -EINVAL;\n\tif (type & IRQ_TYPE_LEVEL_LOW)\n\t\treturn -EINVAL;\n\n\tclk_enable(nmk_chip->clk);\n\tspin_lock_irqsave(&nmk_chip->lock, flags);\n\n\tif (enabled)\n\t\t__nmk_gpio_irq_modify(nmk_chip, d->hwirq, NORMAL, false);\n\n\tif (enabled || wake)\n\t\t__nmk_gpio_irq_modify(nmk_chip, d->hwirq, WAKE, false);\n\n\tnmk_chip->edge_rising &= ~BIT(d->hwirq);\n\tif (type & IRQ_TYPE_EDGE_RISING)\n\t\tnmk_chip->edge_rising |= BIT(d->hwirq);\n\n\tnmk_chip->edge_falling &= ~BIT(d->hwirq);\n\tif (type & IRQ_TYPE_EDGE_FALLING)\n\t\tnmk_chip->edge_falling |= BIT(d->hwirq);\n\n\tif (enabled)\n\t\t__nmk_gpio_irq_modify(nmk_chip, d->hwirq, NORMAL, true);\n\n\tif (enabled || wake)\n\t\t__nmk_gpio_irq_modify(nmk_chip, d->hwirq, WAKE, true);\n\n\tspin_unlock_irqrestore(&nmk_chip->lock, flags);\n\tclk_disable(nmk_chip->clk);\n\n\treturn 0;\n}\n\nstatic unsigned int nmk_gpio_irq_startup(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct nmk_gpio_chip *nmk_chip = gpiochip_get_data(gc);\n\n\tclk_enable(nmk_chip->clk);\n\tnmk_gpio_irq_unmask(d);\n\treturn 0;\n}\n\nstatic void nmk_gpio_irq_shutdown(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct nmk_gpio_chip *nmk_chip = gpiochip_get_data(gc);\n\n\tnmk_gpio_irq_mask(d);\n\tclk_disable(nmk_chip->clk);\n}\n\nstatic void nmk_gpio_irq_handler(struct irq_desc *desc)\n{\n\tstruct irq_chip *host_chip = irq_desc_get_chip(desc);\n\tstruct gpio_chip *chip = irq_desc_get_handler_data(desc);\n\tstruct nmk_gpio_chip *nmk_chip = gpiochip_get_data(chip);\n\tu32 status;\n\n\tchained_irq_enter(host_chip, desc);\n\n\tclk_enable(nmk_chip->clk);\n\tstatus = readl(nmk_chip->addr + NMK_GPIO_IS);\n\tclk_disable(nmk_chip->clk);\n\n\twhile (status) {\n\t\tint bit = __ffs(status);\n\n\t\tgeneric_handle_domain_irq(chip->irq.domain, bit);\n\t\tstatus &= ~BIT(bit);\n\t}\n\n\tchained_irq_exit(host_chip, desc);\n}\n\n \n\nstatic int nmk_gpio_get_dir(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct nmk_gpio_chip *nmk_chip = gpiochip_get_data(chip);\n\tint dir;\n\n\tclk_enable(nmk_chip->clk);\n\n\tdir = readl(nmk_chip->addr + NMK_GPIO_DIR) & BIT(offset);\n\n\tclk_disable(nmk_chip->clk);\n\n\tif (dir)\n\t\treturn GPIO_LINE_DIRECTION_OUT;\n\n\treturn GPIO_LINE_DIRECTION_IN;\n}\n\nstatic int nmk_gpio_make_input(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct nmk_gpio_chip *nmk_chip = gpiochip_get_data(chip);\n\n\tclk_enable(nmk_chip->clk);\n\n\twritel(BIT(offset), nmk_chip->addr + NMK_GPIO_DIRC);\n\n\tclk_disable(nmk_chip->clk);\n\n\treturn 0;\n}\n\nstatic int nmk_gpio_get_input(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct nmk_gpio_chip *nmk_chip = gpiochip_get_data(chip);\n\tint value;\n\n\tclk_enable(nmk_chip->clk);\n\n\tvalue = !!(readl(nmk_chip->addr + NMK_GPIO_DAT) & BIT(offset));\n\n\tclk_disable(nmk_chip->clk);\n\n\treturn value;\n}\n\nstatic void nmk_gpio_set_output(struct gpio_chip *chip, unsigned offset,\n\t\t\t\tint val)\n{\n\tstruct nmk_gpio_chip *nmk_chip = gpiochip_get_data(chip);\n\n\tclk_enable(nmk_chip->clk);\n\n\t__nmk_gpio_set_output(nmk_chip, offset, val);\n\n\tclk_disable(nmk_chip->clk);\n}\n\nstatic int nmk_gpio_make_output(struct gpio_chip *chip, unsigned offset,\n\t\t\t\tint val)\n{\n\tstruct nmk_gpio_chip *nmk_chip = gpiochip_get_data(chip);\n\n\tclk_enable(nmk_chip->clk);\n\n\t__nmk_gpio_make_output(nmk_chip, offset, val);\n\n\tclk_disable(nmk_chip->clk);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic int nmk_gpio_get_mode(struct nmk_gpio_chip *nmk_chip, int offset)\n{\n\tu32 afunc, bfunc;\n\n\tclk_enable(nmk_chip->clk);\n\n\tafunc = readl(nmk_chip->addr + NMK_GPIO_AFSLA) & BIT(offset);\n\tbfunc = readl(nmk_chip->addr + NMK_GPIO_AFSLB) & BIT(offset);\n\n\tclk_disable(nmk_chip->clk);\n\n\treturn (afunc ? NMK_GPIO_ALT_A : 0) | (bfunc ? NMK_GPIO_ALT_B : 0);\n}\n\nstatic void nmk_gpio_dbg_show_one(struct seq_file *s,\n\tstruct pinctrl_dev *pctldev, struct gpio_chip *chip,\n\tunsigned offset, unsigned gpio)\n{\n\tconst char *label = gpiochip_is_requested(chip, offset);\n\tstruct nmk_gpio_chip *nmk_chip = gpiochip_get_data(chip);\n\tint mode;\n\tbool is_out;\n\tbool data_out;\n\tbool pull;\n\tconst char *modes[] = {\n\t\t[NMK_GPIO_ALT_GPIO]\t= \"gpio\",\n\t\t[NMK_GPIO_ALT_A]\t= \"altA\",\n\t\t[NMK_GPIO_ALT_B]\t= \"altB\",\n\t\t[NMK_GPIO_ALT_C]\t= \"altC\",\n\t\t[NMK_GPIO_ALT_C+1]\t= \"altC1\",\n\t\t[NMK_GPIO_ALT_C+2]\t= \"altC2\",\n\t\t[NMK_GPIO_ALT_C+3]\t= \"altC3\",\n\t\t[NMK_GPIO_ALT_C+4]\t= \"altC4\",\n\t};\n\n\tclk_enable(nmk_chip->clk);\n\tis_out = !!(readl(nmk_chip->addr + NMK_GPIO_DIR) & BIT(offset));\n\tpull = !(readl(nmk_chip->addr + NMK_GPIO_PDIS) & BIT(offset));\n\tdata_out = !!(readl(nmk_chip->addr + NMK_GPIO_DAT) & BIT(offset));\n\tmode = nmk_gpio_get_mode(nmk_chip, offset);\n\tif ((mode == NMK_GPIO_ALT_C) && pctldev)\n\t\tmode = nmk_prcm_gpiocr_get_mode(pctldev, gpio);\n\n\tif (is_out) {\n\t\tseq_printf(s, \" gpio-%-3d (%-20.20s) out %s           %s\",\n\t\t\t   gpio,\n\t\t\t   label ?: \"(none)\",\n\t\t\t   data_out ? \"hi\" : \"lo\",\n\t\t\t   (mode < 0) ? \"unknown\" : modes[mode]);\n\t} else {\n\t\tint irq = chip->to_irq(chip, offset);\n\t\tconst int pullidx = pull ? 1 : 0;\n\t\tint val;\n\t\tstatic const char * const pulls[] = {\n\t\t\t\"none        \",\n\t\t\t\"pull enabled\",\n\t\t};\n\n\t\tseq_printf(s, \" gpio-%-3d (%-20.20s) in  %s %s\",\n\t\t\t   gpio,\n\t\t\t   label ?: \"(none)\",\n\t\t\t   pulls[pullidx],\n\t\t\t   (mode < 0) ? \"unknown\" : modes[mode]);\n\n\t\tval = nmk_gpio_get_input(chip, offset);\n\t\tseq_printf(s, \" VAL %d\", val);\n\n\t\t \n\t\tif (irq > 0 && irq_has_action(irq)) {\n\t\t\tchar *trigger;\n\t\t\tbool wake;\n\n\t\t\tif (nmk_chip->edge_rising & BIT(offset))\n\t\t\t\ttrigger = \"edge-rising\";\n\t\t\telse if (nmk_chip->edge_falling & BIT(offset))\n\t\t\t\ttrigger = \"edge-falling\";\n\t\t\telse\n\t\t\t\ttrigger = \"edge-undefined\";\n\n\t\t\twake = !!(nmk_chip->real_wake & BIT(offset));\n\n\t\t\tseq_printf(s, \" irq-%d %s%s\",\n\t\t\t\t   irq, trigger, wake ? \" wakeup\" : \"\");\n\t\t}\n\t}\n\tclk_disable(nmk_chip->clk);\n}\n\nstatic void nmk_gpio_dbg_show(struct seq_file *s, struct gpio_chip *chip)\n{\n\tunsigned\t\ti;\n\tunsigned\t\tgpio = chip->base;\n\n\tfor (i = 0; i < chip->ngpio; i++, gpio++) {\n\t\tnmk_gpio_dbg_show_one(s, NULL, chip, i, gpio);\n\t\tseq_printf(s, \"\\n\");\n\t}\n}\n\n#else\nstatic inline void nmk_gpio_dbg_show_one(struct seq_file *s,\n\t\t\t\t\t struct pinctrl_dev *pctldev,\n\t\t\t\t\t struct gpio_chip *chip,\n\t\t\t\t\t unsigned offset, unsigned gpio)\n{\n}\n#define nmk_gpio_dbg_show\tNULL\n#endif\n\n \nstatic struct nmk_gpio_chip *nmk_gpio_populate_chip(struct device_node *np,\n\t\t\t\t\t\tstruct platform_device *pdev)\n{\n\tstruct nmk_gpio_chip *nmk_chip;\n\tstruct platform_device *gpio_pdev;\n\tstruct gpio_chip *chip;\n\tstruct resource *res;\n\tstruct clk *clk;\n\tvoid __iomem *base;\n\tu32 id;\n\n\tgpio_pdev = of_find_device_by_node(np);\n\tif (!gpio_pdev) {\n\t\tpr_err(\"populate \\\"%pOFn\\\": device not found\\n\", np);\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\tif (of_property_read_u32(np, \"gpio-bank\", &id)) {\n\t\tdev_err(&pdev->dev, \"populate: gpio-bank property not found\\n\");\n\t\tplatform_device_put(gpio_pdev);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t \n\tnmk_chip = nmk_gpio_chips[id];\n\tif (nmk_chip) {\n\t\tplatform_device_put(gpio_pdev);\n\t\treturn nmk_chip;\n\t}\n\n\tnmk_chip = devm_kzalloc(&pdev->dev, sizeof(*nmk_chip), GFP_KERNEL);\n\tif (!nmk_chip) {\n\t\tplatform_device_put(gpio_pdev);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tnmk_chip->bank = id;\n\tchip = &nmk_chip->chip;\n\tchip->base = id * NMK_GPIO_PER_CHIP;\n\tchip->ngpio = NMK_GPIO_PER_CHIP;\n\tchip->label = dev_name(&gpio_pdev->dev);\n\tchip->parent = &gpio_pdev->dev;\n\n\tres = platform_get_resource(gpio_pdev, IORESOURCE_MEM, 0);\n\tbase = devm_ioremap_resource(&pdev->dev, res);\n\tif (IS_ERR(base)) {\n\t\tplatform_device_put(gpio_pdev);\n\t\treturn ERR_CAST(base);\n\t}\n\tnmk_chip->addr = base;\n\n\tclk = clk_get(&gpio_pdev->dev, NULL);\n\tif (IS_ERR(clk)) {\n\t\tplatform_device_put(gpio_pdev);\n\t\treturn (void *) clk;\n\t}\n\tclk_prepare(clk);\n\tnmk_chip->clk = clk;\n\n\tBUG_ON(nmk_chip->bank >= ARRAY_SIZE(nmk_gpio_chips));\n\tnmk_gpio_chips[id] = nmk_chip;\n\treturn nmk_chip;\n}\n\nstatic void nmk_gpio_irq_print_chip(struct irq_data *d, struct seq_file *p)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct nmk_gpio_chip *nmk_chip = gpiochip_get_data(gc);\n\n\tseq_printf(p, \"nmk%u-%u-%u\", nmk_chip->bank,\n\t\t   gc->base, gc->base + gc->ngpio - 1);\n}\n\nstatic const struct irq_chip nmk_irq_chip = {\n\t.irq_ack = nmk_gpio_irq_ack,\n\t.irq_mask = nmk_gpio_irq_mask,\n\t.irq_unmask = nmk_gpio_irq_unmask,\n\t.irq_set_type = nmk_gpio_irq_set_type,\n\t.irq_set_wake = nmk_gpio_irq_set_wake,\n\t.irq_startup = nmk_gpio_irq_startup,\n\t.irq_shutdown = nmk_gpio_irq_shutdown,\n\t.irq_print_chip = nmk_gpio_irq_print_chip,\n\t.flags = IRQCHIP_MASK_ON_SUSPEND | IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic int nmk_gpio_probe(struct platform_device *dev)\n{\n\tstruct device_node *np = dev->dev.of_node;\n\tstruct nmk_gpio_chip *nmk_chip;\n\tstruct gpio_chip *chip;\n\tstruct gpio_irq_chip *girq;\n\tbool supports_sleepmode;\n\tint irq;\n\tint ret;\n\n\tnmk_chip = nmk_gpio_populate_chip(np, dev);\n\tif (IS_ERR(nmk_chip)) {\n\t\tdev_err(&dev->dev, \"could not populate nmk chip struct\\n\");\n\t\treturn PTR_ERR(nmk_chip);\n\t}\n\n\tsupports_sleepmode =\n\t\tof_property_read_bool(np, \"st,supports-sleepmode\");\n\n\t \n\tdev->id = nmk_chip->bank;\n\n\tirq = platform_get_irq(dev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\t \n\tnmk_chip->sleepmode = supports_sleepmode;\n\tspin_lock_init(&nmk_chip->lock);\n\n\tchip = &nmk_chip->chip;\n\tchip->parent = &dev->dev;\n\tchip->request = gpiochip_generic_request;\n\tchip->free = gpiochip_generic_free;\n\tchip->get_direction = nmk_gpio_get_dir;\n\tchip->direction_input = nmk_gpio_make_input;\n\tchip->get = nmk_gpio_get_input;\n\tchip->direction_output = nmk_gpio_make_output;\n\tchip->set = nmk_gpio_set_output;\n\tchip->dbg_show = nmk_gpio_dbg_show;\n\tchip->can_sleep = false;\n\tchip->owner = THIS_MODULE;\n\n\tgirq = &chip->irq;\n\tgpio_irq_chip_set_chip(girq, &nmk_irq_chip);\n\tgirq->parent_handler = nmk_gpio_irq_handler;\n\tgirq->num_parents = 1;\n\tgirq->parents = devm_kcalloc(&dev->dev, 1,\n\t\t\t\t     sizeof(*girq->parents),\n\t\t\t\t     GFP_KERNEL);\n\tif (!girq->parents)\n\t\treturn -ENOMEM;\n\tgirq->parents[0] = irq;\n\tgirq->default_type = IRQ_TYPE_NONE;\n\tgirq->handler = handle_edge_irq;\n\n\tclk_enable(nmk_chip->clk);\n\tnmk_chip->lowemi = readl_relaxed(nmk_chip->addr + NMK_GPIO_LOWEMI);\n\tclk_disable(nmk_chip->clk);\n\n\tret = gpiochip_add_data(chip, nmk_chip);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(dev, nmk_chip);\n\n\tdev_info(&dev->dev, \"chip registered\\n\");\n\n\treturn 0;\n}\n\nstatic int nmk_get_groups_cnt(struct pinctrl_dev *pctldev)\n{\n\tstruct nmk_pinctrl *npct = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn npct->soc->ngroups;\n}\n\nstatic const char *nmk_get_group_name(struct pinctrl_dev *pctldev,\n\t\t\t\t       unsigned selector)\n{\n\tstruct nmk_pinctrl *npct = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn npct->soc->groups[selector].grp.name;\n}\n\nstatic int nmk_get_group_pins(struct pinctrl_dev *pctldev, unsigned selector,\n\t\t\t      const unsigned **pins,\n\t\t\t      unsigned *npins)\n{\n\tstruct nmk_pinctrl *npct = pinctrl_dev_get_drvdata(pctldev);\n\n\t*pins = npct->soc->groups[selector].grp.pins;\n\t*npins = npct->soc->groups[selector].grp.npins;\n\treturn 0;\n}\n\nstatic struct nmk_gpio_chip *find_nmk_gpio_from_pin(unsigned pin)\n{\n\tint i;\n\tstruct nmk_gpio_chip *nmk_gpio;\n\n\tfor(i = 0; i < NMK_MAX_BANKS; i++) {\n\t\tnmk_gpio = nmk_gpio_chips[i];\n\t\tif (!nmk_gpio)\n\t\t\tcontinue;\n\t\tif (pin >= nmk_gpio->chip.base &&\n\t\t\tpin < nmk_gpio->chip.base + nmk_gpio->chip.ngpio)\n\t\t\treturn nmk_gpio;\n\t}\n\treturn NULL;\n}\n\nstatic struct gpio_chip *find_gc_from_pin(unsigned pin)\n{\n\tstruct nmk_gpio_chip *nmk_gpio = find_nmk_gpio_from_pin(pin);\n\n\tif (nmk_gpio)\n\t\treturn &nmk_gpio->chip;\n\treturn NULL;\n}\n\nstatic void nmk_pin_dbg_show(struct pinctrl_dev *pctldev, struct seq_file *s,\n\t\t   unsigned offset)\n{\n\tstruct gpio_chip *chip = find_gc_from_pin(offset);\n\n\tif (!chip) {\n\t\tseq_printf(s, \"invalid pin offset\");\n\t\treturn;\n\t}\n\tnmk_gpio_dbg_show_one(s, pctldev, chip, offset - chip->base, offset);\n}\n\nstatic int nmk_dt_add_map_mux(struct pinctrl_map **map, unsigned *reserved_maps,\n\t\tunsigned *num_maps, const char *group,\n\t\tconst char *function)\n{\n\tif (*num_maps == *reserved_maps)\n\t\treturn -ENOSPC;\n\n\t(*map)[*num_maps].type = PIN_MAP_TYPE_MUX_GROUP;\n\t(*map)[*num_maps].data.mux.group = group;\n\t(*map)[*num_maps].data.mux.function = function;\n\t(*num_maps)++;\n\n\treturn 0;\n}\n\nstatic int nmk_dt_add_map_configs(struct pinctrl_map **map,\n\t\tunsigned *reserved_maps,\n\t\tunsigned *num_maps, const char *group,\n\t\tunsigned long *configs, unsigned num_configs)\n{\n\tunsigned long *dup_configs;\n\n\tif (*num_maps == *reserved_maps)\n\t\treturn -ENOSPC;\n\n\tdup_configs = kmemdup(configs, num_configs * sizeof(*dup_configs),\n\t\t\t      GFP_KERNEL);\n\tif (!dup_configs)\n\t\treturn -ENOMEM;\n\n\t(*map)[*num_maps].type = PIN_MAP_TYPE_CONFIGS_PIN;\n\n\t(*map)[*num_maps].data.configs.group_or_pin = group;\n\t(*map)[*num_maps].data.configs.configs = dup_configs;\n\t(*map)[*num_maps].data.configs.num_configs = num_configs;\n\t(*num_maps)++;\n\n\treturn 0;\n}\n\n#define NMK_CONFIG_PIN(x, y) { .property = x, .config = y, }\n#define NMK_CONFIG_PIN_ARRAY(x, y) { .property = x, .choice = y, \\\n\t.size = ARRAY_SIZE(y), }\n\nstatic const unsigned long nmk_pin_input_modes[] = {\n\tPIN_INPUT_NOPULL,\n\tPIN_INPUT_PULLUP,\n\tPIN_INPUT_PULLDOWN,\n};\n\nstatic const unsigned long nmk_pin_output_modes[] = {\n\tPIN_OUTPUT_LOW,\n\tPIN_OUTPUT_HIGH,\n\tPIN_DIR_OUTPUT,\n};\n\nstatic const unsigned long nmk_pin_sleep_modes[] = {\n\tPIN_SLEEPMODE_DISABLED,\n\tPIN_SLEEPMODE_ENABLED,\n};\n\nstatic const unsigned long nmk_pin_sleep_input_modes[] = {\n\tPIN_SLPM_INPUT_NOPULL,\n\tPIN_SLPM_INPUT_PULLUP,\n\tPIN_SLPM_INPUT_PULLDOWN,\n\tPIN_SLPM_DIR_INPUT,\n};\n\nstatic const unsigned long nmk_pin_sleep_output_modes[] = {\n\tPIN_SLPM_OUTPUT_LOW,\n\tPIN_SLPM_OUTPUT_HIGH,\n\tPIN_SLPM_DIR_OUTPUT,\n};\n\nstatic const unsigned long nmk_pin_sleep_wakeup_modes[] = {\n\tPIN_SLPM_WAKEUP_DISABLE,\n\tPIN_SLPM_WAKEUP_ENABLE,\n};\n\nstatic const unsigned long nmk_pin_gpio_modes[] = {\n\tPIN_GPIOMODE_DISABLED,\n\tPIN_GPIOMODE_ENABLED,\n};\n\nstatic const unsigned long nmk_pin_sleep_pdis_modes[] = {\n\tPIN_SLPM_PDIS_DISABLED,\n\tPIN_SLPM_PDIS_ENABLED,\n};\n\nstruct nmk_cfg_param {\n\tconst char *property;\n\tunsigned long config;\n\tconst unsigned long *choice;\n\tint size;\n};\n\nstatic const struct nmk_cfg_param nmk_cfg_params[] = {\n\tNMK_CONFIG_PIN_ARRAY(\"ste,input\",\t\tnmk_pin_input_modes),\n\tNMK_CONFIG_PIN_ARRAY(\"ste,output\",\t\tnmk_pin_output_modes),\n\tNMK_CONFIG_PIN_ARRAY(\"ste,sleep\",\t\tnmk_pin_sleep_modes),\n\tNMK_CONFIG_PIN_ARRAY(\"ste,sleep-input\",\t\tnmk_pin_sleep_input_modes),\n\tNMK_CONFIG_PIN_ARRAY(\"ste,sleep-output\",\tnmk_pin_sleep_output_modes),\n\tNMK_CONFIG_PIN_ARRAY(\"ste,sleep-wakeup\",\tnmk_pin_sleep_wakeup_modes),\n\tNMK_CONFIG_PIN_ARRAY(\"ste,gpio\",\t\tnmk_pin_gpio_modes),\n\tNMK_CONFIG_PIN_ARRAY(\"ste,sleep-pull-disable\",\tnmk_pin_sleep_pdis_modes),\n};\n\nstatic int nmk_dt_pin_config(int index, int val, unsigned long *config)\n{\n\tif (nmk_cfg_params[index].choice == NULL)\n\t\t*config = nmk_cfg_params[index].config;\n\telse {\n\t\t \n\t\tif  (val < nmk_cfg_params[index].size) {\n\t\t\t*config = nmk_cfg_params[index].config |\n\t\t\t\tnmk_cfg_params[index].choice[val];\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic const char *nmk_find_pin_name(struct pinctrl_dev *pctldev, const char *pin_name)\n{\n\tint i, pin_number;\n\tstruct nmk_pinctrl *npct = pinctrl_dev_get_drvdata(pctldev);\n\n\tif (sscanf((char *)pin_name, \"GPIO%d\", &pin_number) == 1)\n\t\tfor (i = 0; i < npct->soc->npins; i++)\n\t\t\tif (npct->soc->pins[i].number == pin_number)\n\t\t\t\treturn npct->soc->pins[i].name;\n\treturn NULL;\n}\n\nstatic bool nmk_pinctrl_dt_get_config(struct device_node *np,\n\t\tunsigned long *configs)\n{\n\tbool has_config = 0;\n\tunsigned long cfg = 0;\n\tint i, val, ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(nmk_cfg_params); i++) {\n\t\tret = of_property_read_u32(np,\n\t\t\t\tnmk_cfg_params[i].property, &val);\n\t\tif (ret != -EINVAL) {\n\t\t\tif (nmk_dt_pin_config(i, val, &cfg) == 0) {\n\t\t\t\t*configs |= cfg;\n\t\t\t\thas_config = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn has_config;\n}\n\nstatic int nmk_pinctrl_dt_subnode_to_map(struct pinctrl_dev *pctldev,\n\t\tstruct device_node *np,\n\t\tstruct pinctrl_map **map,\n\t\tunsigned *reserved_maps,\n\t\tunsigned *num_maps)\n{\n\tint ret;\n\tconst char *function = NULL;\n\tunsigned long configs = 0;\n\tbool has_config = 0;\n\tstruct property *prop;\n\tstruct device_node *np_config;\n\n\tret = of_property_read_string(np, \"function\", &function);\n\tif (ret >= 0) {\n\t\tconst char *group;\n\n\t\tret = of_property_count_strings(np, \"groups\");\n\t\tif (ret < 0)\n\t\t\tgoto exit;\n\n\t\tret = pinctrl_utils_reserve_map(pctldev, map,\n\t\t\t\t\t\treserved_maps,\n\t\t\t\t\t\tnum_maps, ret);\n\t\tif (ret < 0)\n\t\t\tgoto exit;\n\n\t\tof_property_for_each_string(np, \"groups\", prop, group) {\n\t\t\tret = nmk_dt_add_map_mux(map, reserved_maps, num_maps,\n\t\t\t\t\t  group, function);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto exit;\n\t\t}\n\t}\n\n\thas_config = nmk_pinctrl_dt_get_config(np, &configs);\n\tnp_config = of_parse_phandle(np, \"ste,config\", 0);\n\tif (np_config) {\n\t\thas_config |= nmk_pinctrl_dt_get_config(np_config, &configs);\n\t\tof_node_put(np_config);\n\t}\n\tif (has_config) {\n\t\tconst char *gpio_name;\n\t\tconst char *pin;\n\n\t\tret = of_property_count_strings(np, \"pins\");\n\t\tif (ret < 0)\n\t\t\tgoto exit;\n\t\tret = pinctrl_utils_reserve_map(pctldev, map,\n\t\t\t\t\t\treserved_maps,\n\t\t\t\t\t\tnum_maps, ret);\n\t\tif (ret < 0)\n\t\t\tgoto exit;\n\n\t\tof_property_for_each_string(np, \"pins\", prop, pin) {\n\t\t\tgpio_name = nmk_find_pin_name(pctldev, pin);\n\n\t\t\tret = nmk_dt_add_map_configs(map, reserved_maps,\n\t\t\t\t\t\t     num_maps,\n\t\t\t\t\t\t     gpio_name, &configs, 1);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto exit;\n\t\t}\n\t}\n\nexit:\n\treturn ret;\n}\n\nstatic int nmk_pinctrl_dt_node_to_map(struct pinctrl_dev *pctldev,\n\t\t\t\t struct device_node *np_config,\n\t\t\t\t struct pinctrl_map **map, unsigned *num_maps)\n{\n\tunsigned reserved_maps;\n\tstruct device_node *np;\n\tint ret;\n\n\treserved_maps = 0;\n\t*map = NULL;\n\t*num_maps = 0;\n\n\tfor_each_child_of_node(np_config, np) {\n\t\tret = nmk_pinctrl_dt_subnode_to_map(pctldev, np, map,\n\t\t\t\t&reserved_maps, num_maps);\n\t\tif (ret < 0) {\n\t\t\tpinctrl_utils_free_map(pctldev, *map, *num_maps);\n\t\t\tof_node_put(np);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct pinctrl_ops nmk_pinctrl_ops = {\n\t.get_groups_count = nmk_get_groups_cnt,\n\t.get_group_name = nmk_get_group_name,\n\t.get_group_pins = nmk_get_group_pins,\n\t.pin_dbg_show = nmk_pin_dbg_show,\n\t.dt_node_to_map = nmk_pinctrl_dt_node_to_map,\n\t.dt_free_map = pinctrl_utils_free_map,\n};\n\nstatic int nmk_pmx_get_funcs_cnt(struct pinctrl_dev *pctldev)\n{\n\tstruct nmk_pinctrl *npct = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn npct->soc->nfunctions;\n}\n\nstatic const char *nmk_pmx_get_func_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t unsigned function)\n{\n\tstruct nmk_pinctrl *npct = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn npct->soc->functions[function].name;\n}\n\nstatic int nmk_pmx_get_func_groups(struct pinctrl_dev *pctldev,\n\t\t\t\t   unsigned function,\n\t\t\t\t   const char * const **groups,\n\t\t\t\t   unsigned * const num_groups)\n{\n\tstruct nmk_pinctrl *npct = pinctrl_dev_get_drvdata(pctldev);\n\n\t*groups = npct->soc->functions[function].groups;\n\t*num_groups = npct->soc->functions[function].ngroups;\n\n\treturn 0;\n}\n\nstatic int nmk_pmx_set(struct pinctrl_dev *pctldev, unsigned function,\n\t\t       unsigned group)\n{\n\tstruct nmk_pinctrl *npct = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct nmk_pingroup *g;\n\tstatic unsigned int slpm[NUM_BANKS];\n\tunsigned long flags = 0;\n\tbool glitch;\n\tint ret = -EINVAL;\n\tint i;\n\n\tg = &npct->soc->groups[group];\n\n\tif (g->altsetting < 0)\n\t\treturn -EINVAL;\n\n\tdev_dbg(npct->dev, \"enable group %s, %u pins\\n\", g->grp.name, g->grp.npins);\n\n\t \n\tglitch = ((g->altsetting & NMK_GPIO_ALT_C) == NMK_GPIO_ALT_C);\n\n\tif (glitch) {\n\t\tspin_lock_irqsave(&nmk_gpio_slpm_lock, flags);\n\n\t\t \n\t\tmemset(slpm, 0xff, sizeof(slpm));\n\n\t\t \n\t\tfor (i = 0; i < g->grp.npins; i++)\n\t\t\tslpm[g->grp.pins[i] / NMK_GPIO_PER_CHIP] &= ~BIT(g->grp.pins[i]);\n\t\tnmk_gpio_glitch_slpm_init(slpm);\n\t}\n\n\tfor (i = 0; i < g->grp.npins; i++) {\n\t\tstruct nmk_gpio_chip *nmk_chip;\n\t\tunsigned bit;\n\n\t\tnmk_chip = find_nmk_gpio_from_pin(g->grp.pins[i]);\n\t\tif (!nmk_chip) {\n\t\t\tdev_err(npct->dev,\n\t\t\t\t\"invalid pin offset %d in group %s at index %d\\n\",\n\t\t\t\tg->grp.pins[i], g->grp.name, i);\n\t\t\tgoto out_glitch;\n\t\t}\n\t\tdev_dbg(npct->dev, \"setting pin %d to altsetting %d\\n\", g->grp.pins[i], g->altsetting);\n\n\t\tclk_enable(nmk_chip->clk);\n\t\tbit = g->grp.pins[i] % NMK_GPIO_PER_CHIP;\n\t\t \n\t\tnmk_gpio_disable_lazy_irq(nmk_chip, bit);\n\n\t\t__nmk_gpio_set_mode_safe(nmk_chip, bit,\n\t\t\t(g->altsetting & NMK_GPIO_ALT_C), glitch);\n\t\tclk_disable(nmk_chip->clk);\n\n\t\t \n\t\tif ((g->altsetting & NMK_GPIO_ALT_C) == NMK_GPIO_ALT_C)\n\t\t\tnmk_prcm_altcx_set_mode(npct, g->grp.pins[i],\n\t\t\t\tg->altsetting >> NMK_GPIO_ALT_CX_SHIFT);\n\t}\n\n\t \n\tret = 0;\n\nout_glitch:\n\tif (glitch) {\n\t\tnmk_gpio_glitch_slpm_restore(slpm);\n\t\tspin_unlock_irqrestore(&nmk_gpio_slpm_lock, flags);\n\t}\n\n\treturn ret;\n}\n\nstatic int nmk_gpio_request_enable(struct pinctrl_dev *pctldev,\n\t\t\t\t   struct pinctrl_gpio_range *range,\n\t\t\t\t   unsigned offset)\n{\n\tstruct nmk_pinctrl *npct = pinctrl_dev_get_drvdata(pctldev);\n\tstruct nmk_gpio_chip *nmk_chip;\n\tstruct gpio_chip *chip;\n\tunsigned bit;\n\n\tif (!range) {\n\t\tdev_err(npct->dev, \"invalid range\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (!range->gc) {\n\t\tdev_err(npct->dev, \"missing GPIO chip in range\\n\");\n\t\treturn -EINVAL;\n\t}\n\tchip = range->gc;\n\tnmk_chip = gpiochip_get_data(chip);\n\n\tdev_dbg(npct->dev, \"enable pin %u as GPIO\\n\", offset);\n\n\tclk_enable(nmk_chip->clk);\n\tbit = offset % NMK_GPIO_PER_CHIP;\n\t \n\t__nmk_gpio_set_mode(nmk_chip, bit, NMK_GPIO_ALT_GPIO);\n\tclk_disable(nmk_chip->clk);\n\n\treturn 0;\n}\n\nstatic void nmk_gpio_disable_free(struct pinctrl_dev *pctldev,\n\t\t\t\t  struct pinctrl_gpio_range *range,\n\t\t\t\t  unsigned offset)\n{\n\tstruct nmk_pinctrl *npct = pinctrl_dev_get_drvdata(pctldev);\n\n\tdev_dbg(npct->dev, \"disable pin %u as GPIO\\n\", offset);\n\t \n}\n\nstatic const struct pinmux_ops nmk_pinmux_ops = {\n\t.get_functions_count = nmk_pmx_get_funcs_cnt,\n\t.get_function_name = nmk_pmx_get_func_name,\n\t.get_function_groups = nmk_pmx_get_func_groups,\n\t.set_mux = nmk_pmx_set,\n\t.gpio_request_enable = nmk_gpio_request_enable,\n\t.gpio_disable_free = nmk_gpio_disable_free,\n\t.strict = true,\n};\n\nstatic int nmk_pin_config_get(struct pinctrl_dev *pctldev, unsigned pin,\n\t\t\t      unsigned long *config)\n{\n\t \n\treturn -EINVAL;\n}\n\nstatic int nmk_pin_config_set(struct pinctrl_dev *pctldev, unsigned pin,\n\t\t\t      unsigned long *configs, unsigned num_configs)\n{\n\tstatic const char *pullnames[] = {\n\t\t[NMK_GPIO_PULL_NONE]\t= \"none\",\n\t\t[NMK_GPIO_PULL_UP]\t= \"up\",\n\t\t[NMK_GPIO_PULL_DOWN]\t= \"down\",\n\t\t[3]  \t= \"??\"\n\t};\n\tstatic const char *slpmnames[] = {\n\t\t[NMK_GPIO_SLPM_INPUT]\t\t= \"input/wakeup\",\n\t\t[NMK_GPIO_SLPM_NOCHANGE]\t= \"no-change/no-wakeup\",\n\t};\n\tstruct nmk_pinctrl *npct = pinctrl_dev_get_drvdata(pctldev);\n\tstruct nmk_gpio_chip *nmk_chip;\n\tunsigned bit;\n\tpin_cfg_t cfg;\n\tint pull, slpm, output, val, i;\n\tbool lowemi, gpiomode, sleep;\n\n\tnmk_chip = find_nmk_gpio_from_pin(pin);\n\tif (!nmk_chip) {\n\t\tdev_err(npct->dev,\n\t\t\t\"invalid pin offset %d\\n\", pin);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < num_configs; i++) {\n\t\t \n\t\tcfg = (pin_cfg_t) configs[i];\n\t\tpull = PIN_PULL(cfg);\n\t\tslpm = PIN_SLPM(cfg);\n\t\toutput = PIN_DIR(cfg);\n\t\tval = PIN_VAL(cfg);\n\t\tlowemi = PIN_LOWEMI(cfg);\n\t\tgpiomode = PIN_GPIOMODE(cfg);\n\t\tsleep = PIN_SLEEPMODE(cfg);\n\n\t\tif (sleep) {\n\t\t\tint slpm_pull = PIN_SLPM_PULL(cfg);\n\t\t\tint slpm_output = PIN_SLPM_DIR(cfg);\n\t\t\tint slpm_val = PIN_SLPM_VAL(cfg);\n\n\t\t\t \n\t\t\tgpiomode = true;\n\n\t\t\t \n\t\t\tif (slpm_pull)\n\t\t\t\tpull = slpm_pull - 1;\n\t\t\tif (slpm_output)\n\t\t\t\toutput = slpm_output - 1;\n\t\t\tif (slpm_val)\n\t\t\t\tval = slpm_val - 1;\n\n\t\t\tdev_dbg(nmk_chip->chip.parent,\n\t\t\t\t\"pin %d: sleep pull %s, dir %s, val %s\\n\",\n\t\t\t\tpin,\n\t\t\t\tslpm_pull ? pullnames[pull] : \"same\",\n\t\t\t\tslpm_output ? (output ? \"output\" : \"input\")\n\t\t\t\t: \"same\",\n\t\t\t\tslpm_val ? (val ? \"high\" : \"low\") : \"same\");\n\t\t}\n\n\t\tdev_dbg(nmk_chip->chip.parent,\n\t\t\t\"pin %d [%#lx]: pull %s, slpm %s (%s%s), lowemi %s\\n\",\n\t\t\tpin, cfg, pullnames[pull], slpmnames[slpm],\n\t\t\toutput ? \"output \" : \"input\",\n\t\t\toutput ? (val ? \"high\" : \"low\") : \"\",\n\t\t\tlowemi ? \"on\" : \"off\");\n\n\t\tclk_enable(nmk_chip->clk);\n\t\tbit = pin % NMK_GPIO_PER_CHIP;\n\t\tif (gpiomode)\n\t\t\t \n\t\t\t__nmk_gpio_set_mode(nmk_chip, bit, NMK_GPIO_ALT_GPIO);\n\t\tif (output)\n\t\t\t__nmk_gpio_make_output(nmk_chip, bit, val);\n\t\telse {\n\t\t\t__nmk_gpio_make_input(nmk_chip, bit);\n\t\t\t__nmk_gpio_set_pull(nmk_chip, bit, pull);\n\t\t}\n\t\t \n\t\t__nmk_gpio_set_lowemi(nmk_chip, bit, lowemi);\n\n\t\t__nmk_gpio_set_slpm(nmk_chip, bit, slpm);\n\t\tclk_disable(nmk_chip->clk);\n\t}  \n\n\treturn 0;\n}\n\nstatic const struct pinconf_ops nmk_pinconf_ops = {\n\t.pin_config_get = nmk_pin_config_get,\n\t.pin_config_set = nmk_pin_config_set,\n};\n\nstatic struct pinctrl_desc nmk_pinctrl_desc = {\n\t.name = \"pinctrl-nomadik\",\n\t.pctlops = &nmk_pinctrl_ops,\n\t.pmxops = &nmk_pinmux_ops,\n\t.confops = &nmk_pinconf_ops,\n\t.owner = THIS_MODULE,\n};\n\nstatic const struct of_device_id nmk_pinctrl_match[] = {\n\t{\n\t\t.compatible = \"stericsson,stn8815-pinctrl\",\n\t\t.data = (void *)PINCTRL_NMK_STN8815,\n\t},\n\t{\n\t\t.compatible = \"stericsson,db8500-pinctrl\",\n\t\t.data = (void *)PINCTRL_NMK_DB8500,\n\t},\n\t{},\n};\n\n#ifdef CONFIG_PM_SLEEP\nstatic int nmk_pinctrl_suspend(struct device *dev)\n{\n\tstruct nmk_pinctrl *npct;\n\n\tnpct = dev_get_drvdata(dev);\n\tif (!npct)\n\t\treturn -EINVAL;\n\n\treturn pinctrl_force_sleep(npct->pctl);\n}\n\nstatic int nmk_pinctrl_resume(struct device *dev)\n{\n\tstruct nmk_pinctrl *npct;\n\n\tnpct = dev_get_drvdata(dev);\n\tif (!npct)\n\t\treturn -EINVAL;\n\n\treturn pinctrl_force_default(npct->pctl);\n}\n#endif\n\nstatic int nmk_pinctrl_probe(struct platform_device *pdev)\n{\n\tconst struct of_device_id *match;\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct device_node *prcm_np;\n\tstruct nmk_pinctrl *npct;\n\tunsigned int version = 0;\n\tint i;\n\n\tnpct = devm_kzalloc(&pdev->dev, sizeof(*npct), GFP_KERNEL);\n\tif (!npct)\n\t\treturn -ENOMEM;\n\n\tmatch = of_match_device(nmk_pinctrl_match, &pdev->dev);\n\tif (!match)\n\t\treturn -ENODEV;\n\tversion = (unsigned int) match->data;\n\n\t \n\tif (version == PINCTRL_NMK_STN8815)\n\t\tnmk_pinctrl_stn8815_init(&npct->soc);\n\tif (version == PINCTRL_NMK_DB8500)\n\t\tnmk_pinctrl_db8500_init(&npct->soc);\n\n\t \n\tfor (i = 0; i < NMK_MAX_BANKS; i++) {\n\t\tstruct device_node *gpio_np;\n\t\tstruct nmk_gpio_chip *nmk_chip;\n\n\t\tgpio_np = of_parse_phandle(np, \"nomadik-gpio-chips\", i);\n\t\tif (gpio_np) {\n\t\t\tdev_info(&pdev->dev,\n\t\t\t\t \"populate NMK GPIO %d \\\"%pOFn\\\"\\n\",\n\t\t\t\t i, gpio_np);\n\t\t\tnmk_chip = nmk_gpio_populate_chip(gpio_np, pdev);\n\t\t\tif (IS_ERR(nmk_chip))\n\t\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\t\"could not populate nmk chip struct \"\n\t\t\t\t\t\"- continue anyway\\n\");\n\t\t\tof_node_put(gpio_np);\n\t\t}\n\t}\n\n\tprcm_np = of_parse_phandle(np, \"prcm\", 0);\n\tif (prcm_np) {\n\t\tnpct->prcm_base = of_iomap(prcm_np, 0);\n\t\tof_node_put(prcm_np);\n\t}\n\tif (!npct->prcm_base) {\n\t\tif (version == PINCTRL_NMK_STN8815) {\n\t\t\tdev_info(&pdev->dev,\n\t\t\t\t \"No PRCM base, \"\n\t\t\t\t \"assuming no ALT-Cx control is available\\n\");\n\t\t} else {\n\t\t\tdev_err(&pdev->dev, \"missing PRCM base address\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tnmk_pinctrl_desc.pins = npct->soc->pins;\n\tnmk_pinctrl_desc.npins = npct->soc->npins;\n\tnpct->dev = &pdev->dev;\n\n\tnpct->pctl = devm_pinctrl_register(&pdev->dev, &nmk_pinctrl_desc, npct);\n\tif (IS_ERR(npct->pctl)) {\n\t\tdev_err(&pdev->dev, \"could not register Nomadik pinctrl driver\\n\");\n\t\treturn PTR_ERR(npct->pctl);\n\t}\n\n\tplatform_set_drvdata(pdev, npct);\n\tdev_info(&pdev->dev, \"initialized Nomadik pin control driver\\n\");\n\n\treturn 0;\n}\n\nstatic const struct of_device_id nmk_gpio_match[] = {\n\t{ .compatible = \"st,nomadik-gpio\", },\n\t{}\n};\n\nstatic struct platform_driver nmk_gpio_driver = {\n\t.driver = {\n\t\t.name = \"gpio\",\n\t\t.of_match_table = nmk_gpio_match,\n\t},\n\t.probe = nmk_gpio_probe,\n};\n\nstatic SIMPLE_DEV_PM_OPS(nmk_pinctrl_pm_ops,\n\t\t\tnmk_pinctrl_suspend,\n\t\t\tnmk_pinctrl_resume);\n\nstatic struct platform_driver nmk_pinctrl_driver = {\n\t.driver = {\n\t\t.name = \"pinctrl-nomadik\",\n\t\t.of_match_table = nmk_pinctrl_match,\n\t\t.pm = &nmk_pinctrl_pm_ops,\n\t},\n\t.probe = nmk_pinctrl_probe,\n};\n\nstatic int __init nmk_gpio_init(void)\n{\n\treturn platform_driver_register(&nmk_gpio_driver);\n}\nsubsys_initcall(nmk_gpio_init);\n\nstatic int __init nmk_pinctrl_init(void)\n{\n\treturn platform_driver_register(&nmk_pinctrl_driver);\n}\ncore_initcall(nmk_pinctrl_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}