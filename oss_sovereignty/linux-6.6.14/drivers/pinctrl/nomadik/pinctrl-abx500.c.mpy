{
  "module_name": "pinctrl-abx500.c",
  "hash_id": "46876b3a60ec442963e026081ca78756a79270063ca19b48389b91ae476224a4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/nomadik/pinctrl-abx500.c",
  "human_readable_source": "\n \n#include <linux/bitops.h>\n#include <linux/err.h>\n#include <linux/gpio/driver.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/platform_device.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#include <linux/mfd/abx500.h>\n#include <linux/mfd/abx500/ab8500.h>\n\n#include <linux/pinctrl/consumer.h>\n#include <linux/pinctrl/machine.h>\n#include <linux/pinctrl/pinconf-generic.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinmux.h>\n\n#include \"../core.h\"\n#include \"../pinconf.h\"\n#include \"../pinctrl-utils.h\"\n\n#include \"pinctrl-abx500.h\"\n\n \n#define AB8500_GPIO_SEL1_REG\t0x00\n#define AB8500_GPIO_SEL2_REG\t0x01\n#define AB8500_GPIO_SEL3_REG\t0x02\n#define AB8500_GPIO_SEL4_REG\t0x03\n#define AB8500_GPIO_SEL5_REG\t0x04\n#define AB8500_GPIO_SEL6_REG\t0x05\n\n#define AB8500_GPIO_DIR1_REG\t0x10\n#define AB8500_GPIO_DIR2_REG\t0x11\n#define AB8500_GPIO_DIR3_REG\t0x12\n#define AB8500_GPIO_DIR4_REG\t0x13\n#define AB8500_GPIO_DIR5_REG\t0x14\n#define AB8500_GPIO_DIR6_REG\t0x15\n\n#define AB8500_GPIO_OUT1_REG\t0x20\n#define AB8500_GPIO_OUT2_REG\t0x21\n#define AB8500_GPIO_OUT3_REG\t0x22\n#define AB8500_GPIO_OUT4_REG\t0x23\n#define AB8500_GPIO_OUT5_REG\t0x24\n#define AB8500_GPIO_OUT6_REG\t0x25\n\n#define AB8500_GPIO_PUD1_REG\t0x30\n#define AB8500_GPIO_PUD2_REG\t0x31\n#define AB8500_GPIO_PUD3_REG\t0x32\n#define AB8500_GPIO_PUD4_REG\t0x33\n#define AB8500_GPIO_PUD5_REG\t0x34\n#define AB8500_GPIO_PUD6_REG\t0x35\n\n#define AB8500_GPIO_IN1_REG\t0x40\n#define AB8500_GPIO_IN2_REG\t0x41\n#define AB8500_GPIO_IN3_REG\t0x42\n#define AB8500_GPIO_IN4_REG\t0x43\n#define AB8500_GPIO_IN5_REG\t0x44\n#define AB8500_GPIO_IN6_REG\t0x45\n#define AB8500_GPIO_ALTFUN_REG\t0x50\n\n#define ABX500_GPIO_INPUT\t0\n#define ABX500_GPIO_OUTPUT\t1\n\nstruct abx500_pinctrl {\n\tstruct device *dev;\n\tstruct pinctrl_dev *pctldev;\n\tstruct abx500_pinctrl_soc_data *soc;\n\tstruct gpio_chip chip;\n\tstruct ab8500 *parent;\n\tstruct abx500_gpio_irq_cluster *irq_cluster;\n\tint irq_cluster_size;\n};\n\nstatic int abx500_gpio_get_bit(struct gpio_chip *chip, u8 reg,\n\t\t\t       unsigned offset, bool *bit)\n{\n\tstruct abx500_pinctrl *pct = gpiochip_get_data(chip);\n\tu8 pos = offset % 8;\n\tu8 val;\n\tint ret;\n\n\treg += offset / 8;\n\tret = abx500_get_register_interruptible(pct->dev,\n\t\t\t\t\t\tAB8500_MISC, reg, &val);\n\tif (ret < 0) {\n\t\tdev_err(pct->dev,\n\t\t\t\"%s read reg =%x, offset=%x failed (%d)\\n\",\n\t\t\t__func__, reg, offset, ret);\n\t\treturn ret;\n\t}\n\n\t*bit = !!(val & BIT(pos));\n\n\treturn 0;\n}\n\nstatic int abx500_gpio_set_bits(struct gpio_chip *chip, u8 reg,\n\t\t\t\tunsigned offset, int val)\n{\n\tstruct abx500_pinctrl *pct = gpiochip_get_data(chip);\n\tu8 pos = offset % 8;\n\tint ret;\n\n\treg += offset / 8;\n\tret = abx500_mask_and_set_register_interruptible(pct->dev,\n\t\t\t\tAB8500_MISC, reg, BIT(pos), val << pos);\n\tif (ret < 0)\n\t\tdev_err(pct->dev, \"%s write reg, %x offset %x failed (%d)\\n\",\n\t\t\t\t__func__, reg, offset, ret);\n\n\treturn ret;\n}\n\n \nstatic int abx500_gpio_get(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct abx500_pinctrl *pct = gpiochip_get_data(chip);\n\tbool bit;\n\tbool is_out;\n\tu8 gpio_offset = offset - 1;\n\tint ret;\n\n\tret = abx500_gpio_get_bit(chip, AB8500_GPIO_DIR1_REG,\n\t\t\tgpio_offset, &is_out);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (is_out)\n\t\tret = abx500_gpio_get_bit(chip, AB8500_GPIO_OUT1_REG,\n\t\t\t\tgpio_offset, &bit);\n\telse\n\t\tret = abx500_gpio_get_bit(chip, AB8500_GPIO_IN1_REG,\n\t\t\t\tgpio_offset, &bit);\nout:\n\tif (ret < 0) {\n\t\tdev_err(pct->dev, \"%s failed (%d)\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\treturn bit;\n}\n\nstatic void abx500_gpio_set(struct gpio_chip *chip, unsigned offset, int val)\n{\n\tstruct abx500_pinctrl *pct = gpiochip_get_data(chip);\n\tint ret;\n\n\tret = abx500_gpio_set_bits(chip, AB8500_GPIO_OUT1_REG, offset, val);\n\tif (ret < 0)\n\t\tdev_err(pct->dev, \"%s write failed (%d)\\n\", __func__, ret);\n}\n\nstatic int abx500_gpio_direction_output(struct gpio_chip *chip,\n\t\t\t\t\tunsigned offset,\n\t\t\t\t\tint val)\n{\n\tstruct abx500_pinctrl *pct = gpiochip_get_data(chip);\n\tint ret;\n\n\t \n\tret = abx500_gpio_set_bits(chip,\n\t\t\t\tAB8500_GPIO_DIR1_REG,\n\t\t\t\toffset,\n\t\t\t\tABX500_GPIO_OUTPUT);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tret = abx500_gpio_set_bits(chip,\n\t\t\t\tAB8500_GPIO_PUD1_REG,\n\t\t\t\toffset,\n\t\t\t\tABX500_GPIO_PULL_NONE);\n\nout:\n\tif (ret < 0) {\n\t\tdev_err(pct->dev, \"%s failed (%d)\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\t \n\treturn abx500_gpio_set_bits(chip, AB8500_GPIO_OUT1_REG, offset, val);\n}\n\nstatic int abx500_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\n{\n\t \n\treturn abx500_gpio_set_bits(chip,\n\t\t\t\tAB8500_GPIO_DIR1_REG,\n\t\t\t\toffset,\n\t\t\t\tABX500_GPIO_INPUT);\n}\n\nstatic int abx500_gpio_to_irq(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct abx500_pinctrl *pct = gpiochip_get_data(chip);\n\t \n\tint gpio = offset + 1;\n\tint hwirq;\n\tint i;\n\n\tfor (i = 0; i < pct->irq_cluster_size; i++) {\n\t\tstruct abx500_gpio_irq_cluster *cluster =\n\t\t\t&pct->irq_cluster[i];\n\n\t\tif (gpio >= cluster->start && gpio <= cluster->end) {\n\t\t\t \n\t\t\thwirq = gpio - cluster->start + cluster->to_irq;\n\t\t\treturn irq_create_mapping(pct->parent->domain, hwirq);\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int abx500_set_mode(struct pinctrl_dev *pctldev, struct gpio_chip *chip,\n\t\t\t   unsigned gpio, int alt_setting)\n{\n\tstruct abx500_pinctrl *pct = pinctrl_dev_get_drvdata(pctldev);\n\tstruct alternate_functions af = pct->soc->alternate_functions[gpio];\n\tint ret;\n\tint val;\n\tunsigned offset;\n\n\tconst char *modes[] = {\n\t\t[ABX500_DEFAULT]\t= \"default\",\n\t\t[ABX500_ALT_A]\t\t= \"altA\",\n\t\t[ABX500_ALT_B]\t\t= \"altB\",\n\t\t[ABX500_ALT_C]\t\t= \"altC\",\n\t};\n\n\t \n\tif (((alt_setting == ABX500_ALT_A) && (af.gpiosel_bit == UNUSED)) ||\n\t    ((alt_setting == ABX500_ALT_B) && (af.alt_bit1 == UNUSED)) ||\n\t    ((alt_setting == ABX500_ALT_C) && (af.alt_bit2 == UNUSED))) {\n\t\tdev_dbg(pct->dev, \"pin %d doesn't support %s mode\\n\", gpio,\n\t\t\t\tmodes[alt_setting]);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\toffset = gpio - 1;\n\n\tswitch (alt_setting) {\n\tcase ABX500_DEFAULT:\n\t\t \n\t\tval = 0;\n\t\tif (af.alt_bit1 != UNUSED)\n\t\t\tval++;\n\n\t\tret = abx500_gpio_set_bits(chip, AB8500_GPIO_SEL1_REG,\n\t\t\t\t\t   offset, val);\n\t\tbreak;\n\n\tcase ABX500_ALT_A:\n\t\t \n\t\tif (af.alt_bit1 != UNUSED) {\n\t\t\tret = abx500_gpio_set_bits(chip, AB8500_GPIO_SEL1_REG,\n\t\t\t\t\toffset, 0);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\n\t\t\tret = abx500_gpio_set_bits(chip,\n\t\t\t\t\tAB8500_GPIO_ALTFUN_REG,\n\t\t\t\t\taf.alt_bit1,\n\t\t\t\t\t!!(af.alta_val & BIT(0)));\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\n\t\t\tif (af.alt_bit2 != UNUSED)\n\t\t\t\tret = abx500_gpio_set_bits(chip,\n\t\t\t\t\tAB8500_GPIO_ALTFUN_REG,\n\t\t\t\t\taf.alt_bit2,\n\t\t\t\t\t!!(af.alta_val & BIT(1)));\n\t\t} else\n\t\t\tret = abx500_gpio_set_bits(chip, AB8500_GPIO_SEL1_REG,\n\t\t\t\t\toffset, 1);\n\t\tbreak;\n\n\tcase ABX500_ALT_B:\n\t\tret = abx500_gpio_set_bits(chip, AB8500_GPIO_SEL1_REG,\n\t\t\t\toffset, 0);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tret = abx500_gpio_set_bits(chip, AB8500_GPIO_ALTFUN_REG,\n\t\t\t\taf.alt_bit1, !!(af.altb_val & BIT(0)));\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tif (af.alt_bit2 != UNUSED)\n\t\t\tret = abx500_gpio_set_bits(chip,\n\t\t\t\t\tAB8500_GPIO_ALTFUN_REG,\n\t\t\t\t\taf.alt_bit2,\n\t\t\t\t\t!!(af.altb_val & BIT(1)));\n\t\tbreak;\n\n\tcase ABX500_ALT_C:\n\t\tret = abx500_gpio_set_bits(chip, AB8500_GPIO_SEL1_REG,\n\t\t\t\toffset, 0);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tret = abx500_gpio_set_bits(chip, AB8500_GPIO_ALTFUN_REG,\n\t\t\t\taf.alt_bit2, !!(af.altc_val & BIT(0)));\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tret = abx500_gpio_set_bits(chip, AB8500_GPIO_ALTFUN_REG,\n\t\t\t\taf.alt_bit2, !!(af.altc_val & BIT(1)));\n\t\tbreak;\n\n\tdefault:\n\t\tdev_dbg(pct->dev, \"unknown alt_setting %d\\n\", alt_setting);\n\n\t\treturn -EINVAL;\n\t}\nout:\n\tif (ret < 0)\n\t\tdev_err(pct->dev, \"%s failed (%d)\\n\", __func__, ret);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic int abx500_get_mode(struct pinctrl_dev *pctldev, struct gpio_chip *chip,\n\t\t\t  unsigned gpio)\n{\n\tu8 mode;\n\tbool bit_mode;\n\tbool alt_bit1;\n\tbool alt_bit2;\n\tstruct abx500_pinctrl *pct = pinctrl_dev_get_drvdata(pctldev);\n\tstruct alternate_functions af = pct->soc->alternate_functions[gpio];\n\t \n\tunsigned offset = gpio - 1;\n\tint ret;\n\n\t \n\tif (af.gpiosel_bit == UNUSED)\n\t\treturn ABX500_DEFAULT;\n\n\t \n\tret = abx500_gpio_get_bit(chip, AB8500_GPIO_SEL1_REG + (offset / 8),\n\t\t\taf.gpiosel_bit, &bit_mode);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tmode = bit_mode;\n\n\t \n\tif ((af.alt_bit1 < UNUSED) || (af.alt_bit1 > 7) ||\n\t    (af.alt_bit2 < UNUSED) || (af.alt_bit2 > 7)) {\n\t\tdev_err(pct->dev,\n\t\t\t\"alt_bitX value not in correct range (-1 to 7)\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif ((af.alt_bit2 != UNUSED) && (af.alt_bit1 == UNUSED)) {\n\t\tdev_err(pct->dev,\n\t\t\t\"if alt_bit2 is used, alt_bit1 can't be unused\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif ((af.alt_bit1 == UNUSED) && (af.alt_bit2 == UNUSED))\n\t\treturn mode;\n\t \n\tif (mode)\n\t\treturn ABX500_DEFAULT;\n\n\t \n\tret = abx500_gpio_get_bit(chip, AB8500_GPIO_ALTFUN_REG,\n\t\t\t    af.alt_bit1, &alt_bit1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (af.alt_bit2 != UNUSED) {\n\t\t \n\t\tret = abx500_gpio_get_bit(chip, AB8500_GPIO_ALTFUN_REG,\n\t\t\t\taf.alt_bit2,\n\t\t\t\t&alt_bit2);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t} else\n\t\talt_bit2 = 0;\n\n\tmode = (alt_bit2 << 1) + alt_bit1;\n\tif (mode == af.alta_val)\n\t\treturn ABX500_ALT_A;\n\telse if (mode == af.altb_val)\n\t\treturn ABX500_ALT_B;\n\telse\n\t\treturn ABX500_ALT_C;\n\nout:\n\tdev_err(pct->dev, \"%s failed (%d)\\n\", __func__, ret);\n\treturn ret;\n}\n\nstatic void abx500_gpio_dbg_show_one(struct seq_file *s,\n\t\t\t\t     struct pinctrl_dev *pctldev,\n\t\t\t\t     struct gpio_chip *chip,\n\t\t\t\t     unsigned offset, unsigned gpio)\n{\n\tstruct abx500_pinctrl *pct = pinctrl_dev_get_drvdata(pctldev);\n\tconst char *label = gpiochip_is_requested(chip, offset - 1);\n\tu8 gpio_offset = offset - 1;\n\tint mode = -1;\n\tbool is_out;\n\tbool pd;\n\tint ret;\n\n\tconst char *modes[] = {\n\t\t[ABX500_DEFAULT]\t= \"default\",\n\t\t[ABX500_ALT_A]\t\t= \"altA\",\n\t\t[ABX500_ALT_B]\t\t= \"altB\",\n\t\t[ABX500_ALT_C]\t\t= \"altC\",\n\t};\n\n\tconst char *pull_up_down[] = {\n\t\t[ABX500_GPIO_PULL_DOWN]\t\t= \"pull down\",\n\t\t[ABX500_GPIO_PULL_NONE]\t\t= \"pull none\",\n\t\t[ABX500_GPIO_PULL_NONE + 1]\t= \"pull none\",\n\t\t[ABX500_GPIO_PULL_UP]\t\t= \"pull up\",\n\t};\n\n\tret = abx500_gpio_get_bit(chip, AB8500_GPIO_DIR1_REG,\n\t\t\tgpio_offset, &is_out);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tseq_printf(s, \" gpio-%-3d (%-20.20s) %-3s\",\n\t\t   gpio, label ?: \"(none)\",\n\t\t   is_out ? \"out\" : \"in \");\n\n\tif (!is_out) {\n\t\tret = abx500_gpio_get_bit(chip, AB8500_GPIO_PUD1_REG,\n\t\t\t\tgpio_offset, &pd);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tseq_printf(s, \" %-9s\", pull_up_down[pd]);\n\t} else\n\t\tseq_printf(s, \" %-9s\", chip->get(chip, offset) ? \"hi\" : \"lo\");\n\n\tmode = abx500_get_mode(pctldev, chip, offset);\n\n\tseq_printf(s, \" %s\", (mode < 0) ? \"unknown\" : modes[mode]);\n\nout:\n\tif (ret < 0)\n\t\tdev_err(pct->dev, \"%s failed (%d)\\n\", __func__, ret);\n}\n\nstatic void abx500_gpio_dbg_show(struct seq_file *s, struct gpio_chip *chip)\n{\n\tunsigned i;\n\tunsigned gpio = chip->base;\n\tstruct abx500_pinctrl *pct = gpiochip_get_data(chip);\n\tstruct pinctrl_dev *pctldev = pct->pctldev;\n\n\tfor (i = 0; i < chip->ngpio; i++, gpio++) {\n\t\t \n\t\tabx500_gpio_dbg_show_one(s, pctldev, chip, i + 1, gpio);\n\t\tseq_putc(s, '\\n');\n\t}\n}\n\n#else\nstatic inline void abx500_gpio_dbg_show_one(struct seq_file *s,\n\t\t\t\t\t    struct pinctrl_dev *pctldev,\n\t\t\t\t\t    struct gpio_chip *chip,\n\t\t\t\t\t    unsigned offset, unsigned gpio)\n{\n}\n#define abx500_gpio_dbg_show\tNULL\n#endif\n\nstatic const struct gpio_chip abx500gpio_chip = {\n\t.label\t\t\t= \"abx500-gpio\",\n\t.owner\t\t\t= THIS_MODULE,\n\t.request\t\t= gpiochip_generic_request,\n\t.free\t\t\t= gpiochip_generic_free,\n\t.direction_input\t= abx500_gpio_direction_input,\n\t.get\t\t\t= abx500_gpio_get,\n\t.direction_output\t= abx500_gpio_direction_output,\n\t.set\t\t\t= abx500_gpio_set,\n\t.to_irq\t\t\t= abx500_gpio_to_irq,\n\t.dbg_show\t\t= abx500_gpio_dbg_show,\n};\n\nstatic int abx500_pmx_get_funcs_cnt(struct pinctrl_dev *pctldev)\n{\n\tstruct abx500_pinctrl *pct = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pct->soc->nfunctions;\n}\n\nstatic const char *abx500_pmx_get_func_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t unsigned function)\n{\n\tstruct abx500_pinctrl *pct = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pct->soc->functions[function].name;\n}\n\nstatic int abx500_pmx_get_func_groups(struct pinctrl_dev *pctldev,\n\t\t\t\t      unsigned function,\n\t\t\t\t      const char * const **groups,\n\t\t\t\t      unsigned * const num_groups)\n{\n\tstruct abx500_pinctrl *pct = pinctrl_dev_get_drvdata(pctldev);\n\n\t*groups = pct->soc->functions[function].groups;\n\t*num_groups = pct->soc->functions[function].ngroups;\n\n\treturn 0;\n}\n\nstatic int abx500_pmx_set(struct pinctrl_dev *pctldev, unsigned function,\n\t\t\t  unsigned group)\n{\n\tstruct abx500_pinctrl *pct = pinctrl_dev_get_drvdata(pctldev);\n\tstruct gpio_chip *chip = &pct->chip;\n\tconst struct abx500_pingroup *g;\n\tint i;\n\tint ret = 0;\n\n\tg = &pct->soc->groups[group];\n\tif (g->altsetting < 0)\n\t\treturn -EINVAL;\n\n\tdev_dbg(pct->dev, \"enable group %s, %u pins\\n\", g->name, g->npins);\n\n\tfor (i = 0; i < g->npins; i++) {\n\t\tdev_dbg(pct->dev, \"setting pin %d to altsetting %d\\n\",\n\t\t\tg->pins[i], g->altsetting);\n\n\t\tret = abx500_set_mode(pctldev, chip, g->pins[i], g->altsetting);\n\t}\n\n\tif (ret < 0)\n\t\tdev_err(pct->dev, \"%s failed (%d)\\n\", __func__, ret);\n\n\treturn ret;\n}\n\nstatic int abx500_gpio_request_enable(struct pinctrl_dev *pctldev,\n\t\t\t       struct pinctrl_gpio_range *range,\n\t\t\t       unsigned offset)\n{\n\tstruct abx500_pinctrl *pct = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct abx500_pinrange *p;\n\tint ret;\n\tint i;\n\n\t \n\tfor (i = 0; i < pct->soc->gpio_num_ranges; i++) {\n\t\tp = &pct->soc->gpio_ranges[i];\n\t\tif ((offset >= p->offset) &&\n\t\t    (offset < (p->offset + p->npins)))\n\t\t  break;\n\t}\n\n\tif (i == pct->soc->gpio_num_ranges) {\n\t\tdev_err(pct->dev, \"%s failed to locate range\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\n\tdev_dbg(pct->dev, \"enable GPIO by altfunc %d at gpio %d\\n\",\n\t\tp->altfunc, offset);\n\n\tret = abx500_set_mode(pct->pctldev, &pct->chip,\n\t\t\t      offset, p->altfunc);\n\tif (ret < 0)\n\t\tdev_err(pct->dev, \"%s setting altfunc failed\\n\", __func__);\n\n\treturn ret;\n}\n\nstatic void abx500_gpio_disable_free(struct pinctrl_dev *pctldev,\n\t\t\t\t     struct pinctrl_gpio_range *range,\n\t\t\t\t     unsigned offset)\n{\n}\n\nstatic const struct pinmux_ops abx500_pinmux_ops = {\n\t.get_functions_count = abx500_pmx_get_funcs_cnt,\n\t.get_function_name = abx500_pmx_get_func_name,\n\t.get_function_groups = abx500_pmx_get_func_groups,\n\t.set_mux = abx500_pmx_set,\n\t.gpio_request_enable = abx500_gpio_request_enable,\n\t.gpio_disable_free = abx500_gpio_disable_free,\n};\n\nstatic int abx500_get_groups_cnt(struct pinctrl_dev *pctldev)\n{\n\tstruct abx500_pinctrl *pct = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pct->soc->ngroups;\n}\n\nstatic const char *abx500_get_group_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t unsigned selector)\n{\n\tstruct abx500_pinctrl *pct = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pct->soc->groups[selector].name;\n}\n\nstatic int abx500_get_group_pins(struct pinctrl_dev *pctldev,\n\t\t\t\t unsigned selector,\n\t\t\t\t const unsigned **pins,\n\t\t\t\t unsigned *num_pins)\n{\n\tstruct abx500_pinctrl *pct = pinctrl_dev_get_drvdata(pctldev);\n\n\t*pins = pct->soc->groups[selector].pins;\n\t*num_pins = pct->soc->groups[selector].npins;\n\n\treturn 0;\n}\n\nstatic void abx500_pin_dbg_show(struct pinctrl_dev *pctldev,\n\t\t\t\tstruct seq_file *s, unsigned offset)\n{\n\tstruct abx500_pinctrl *pct = pinctrl_dev_get_drvdata(pctldev);\n\tstruct gpio_chip *chip = &pct->chip;\n\n\tabx500_gpio_dbg_show_one(s, pctldev, chip, offset,\n\t\t\t\t chip->base + offset - 1);\n}\n\nstatic int abx500_dt_add_map_mux(struct pinctrl_map **map,\n\t\tunsigned *reserved_maps,\n\t\tunsigned *num_maps, const char *group,\n\t\tconst char *function)\n{\n\tif (*num_maps == *reserved_maps)\n\t\treturn -ENOSPC;\n\n\t(*map)[*num_maps].type = PIN_MAP_TYPE_MUX_GROUP;\n\t(*map)[*num_maps].data.mux.group = group;\n\t(*map)[*num_maps].data.mux.function = function;\n\t(*num_maps)++;\n\n\treturn 0;\n}\n\nstatic int abx500_dt_add_map_configs(struct pinctrl_map **map,\n\t\tunsigned *reserved_maps,\n\t\tunsigned *num_maps, const char *group,\n\t\tunsigned long *configs, unsigned num_configs)\n{\n\tunsigned long *dup_configs;\n\n\tif (*num_maps == *reserved_maps)\n\t\treturn -ENOSPC;\n\n\tdup_configs = kmemdup(configs, num_configs * sizeof(*dup_configs),\n\t\t\t      GFP_KERNEL);\n\tif (!dup_configs)\n\t\treturn -ENOMEM;\n\n\t(*map)[*num_maps].type = PIN_MAP_TYPE_CONFIGS_PIN;\n\n\t(*map)[*num_maps].data.configs.group_or_pin = group;\n\t(*map)[*num_maps].data.configs.configs = dup_configs;\n\t(*map)[*num_maps].data.configs.num_configs = num_configs;\n\t(*num_maps)++;\n\n\treturn 0;\n}\n\nstatic const char *abx500_find_pin_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\tconst char *pin_name)\n{\n\tint i, pin_number;\n\tstruct abx500_pinctrl *npct = pinctrl_dev_get_drvdata(pctldev);\n\n\tif (sscanf((char *)pin_name, \"GPIO%d\", &pin_number) == 1)\n\t\tfor (i = 0; i < npct->soc->npins; i++)\n\t\t\tif (npct->soc->pins[i].number == pin_number)\n\t\t\t\treturn npct->soc->pins[i].name;\n\treturn NULL;\n}\n\nstatic int abx500_dt_subnode_to_map(struct pinctrl_dev *pctldev,\n\t\tstruct device_node *np,\n\t\tstruct pinctrl_map **map,\n\t\tunsigned *reserved_maps,\n\t\tunsigned *num_maps)\n{\n\tint ret;\n\tconst char *function = NULL;\n\tunsigned long *configs;\n\tunsigned int nconfigs = 0;\n\tstruct property *prop;\n\n\tret = of_property_read_string(np, \"function\", &function);\n\tif (ret >= 0) {\n\t\tconst char *group;\n\n\t\tret = of_property_count_strings(np, \"groups\");\n\t\tif (ret < 0)\n\t\t\tgoto exit;\n\n\t\tret = pinctrl_utils_reserve_map(pctldev, map, reserved_maps,\n\t\t\t\t\t\tnum_maps, ret);\n\t\tif (ret < 0)\n\t\t\tgoto exit;\n\n\t\tof_property_for_each_string(np, \"groups\", prop, group) {\n\t\t\tret = abx500_dt_add_map_mux(map, reserved_maps,\n\t\t\t\t\tnum_maps, group, function);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tret = pinconf_generic_parse_dt_config(np, pctldev, &configs, &nconfigs);\n\tif (nconfigs) {\n\t\tconst char *gpio_name;\n\t\tconst char *pin;\n\n\t\tret = of_property_count_strings(np, \"pins\");\n\t\tif (ret < 0)\n\t\t\tgoto exit;\n\n\t\tret = pinctrl_utils_reserve_map(pctldev, map,\n\t\t\t\t\t\treserved_maps,\n\t\t\t\t\t\tnum_maps, ret);\n\t\tif (ret < 0)\n\t\t\tgoto exit;\n\n\t\tof_property_for_each_string(np, \"pins\", prop, pin) {\n\t\t\tgpio_name = abx500_find_pin_name(pctldev, pin);\n\n\t\t\tret = abx500_dt_add_map_configs(map, reserved_maps,\n\t\t\t\t\tnum_maps, gpio_name, configs, 1);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto exit;\n\t\t}\n\t}\n\nexit:\n\treturn ret;\n}\n\nstatic int abx500_dt_node_to_map(struct pinctrl_dev *pctldev,\n\t\t\t\t struct device_node *np_config,\n\t\t\t\t struct pinctrl_map **map, unsigned *num_maps)\n{\n\tunsigned reserved_maps;\n\tstruct device_node *np;\n\tint ret;\n\n\treserved_maps = 0;\n\t*map = NULL;\n\t*num_maps = 0;\n\n\tfor_each_child_of_node(np_config, np) {\n\t\tret = abx500_dt_subnode_to_map(pctldev, np, map,\n\t\t\t\t&reserved_maps, num_maps);\n\t\tif (ret < 0) {\n\t\t\tpinctrl_utils_free_map(pctldev, *map, *num_maps);\n\t\t\tof_node_put(np);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct pinctrl_ops abx500_pinctrl_ops = {\n\t.get_groups_count = abx500_get_groups_cnt,\n\t.get_group_name = abx500_get_group_name,\n\t.get_group_pins = abx500_get_group_pins,\n\t.pin_dbg_show = abx500_pin_dbg_show,\n\t.dt_node_to_map = abx500_dt_node_to_map,\n\t.dt_free_map = pinctrl_utils_free_map,\n};\n\nstatic int abx500_pin_config_get(struct pinctrl_dev *pctldev,\n\t\t\t  unsigned pin,\n\t\t\t  unsigned long *config)\n{\n\treturn -ENOSYS;\n}\n\nstatic int abx500_pin_config_set(struct pinctrl_dev *pctldev,\n\t\t\t  unsigned pin,\n\t\t\t  unsigned long *configs,\n\t\t\t  unsigned num_configs)\n{\n\tstruct abx500_pinctrl *pct = pinctrl_dev_get_drvdata(pctldev);\n\tstruct gpio_chip *chip = &pct->chip;\n\tunsigned offset;\n\tint ret = -EINVAL;\n\tint i;\n\tenum pin_config_param param;\n\tenum pin_config_param argument;\n\n\tfor (i = 0; i < num_configs; i++) {\n\t\tparam = pinconf_to_config_param(configs[i]);\n\t\targument = pinconf_to_config_argument(configs[i]);\n\n\t\tdev_dbg(chip->parent, \"pin %d [%#lx]: %s %s\\n\",\n\t\t\tpin, configs[i],\n\t\t\t(param == PIN_CONFIG_OUTPUT) ? \"output \" : \"input\",\n\t\t\t(param == PIN_CONFIG_OUTPUT) ?\n\t\t\t(argument ? \"high\" : \"low\") :\n\t\t\t(argument ? \"pull up\" : \"pull down\"));\n\n\t\t \n\t\toffset = pin - 1;\n\n\t\tswitch (param) {\n\t\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\t\tret = abx500_gpio_direction_input(chip, offset);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\n\t\t\t \n\t\t\tret = abx500_gpio_set_bits(chip,\n\t\t\t\tAB8500_GPIO_PUD1_REG, offset,\n\t\t\t\tABX500_GPIO_PULL_NONE);\n\t\t\tbreak;\n\n\t\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\t\tret = abx500_gpio_direction_input(chip, offset);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\t \n\t\t\tret = abx500_gpio_set_bits(chip,\n\t\t\tAB8500_GPIO_PUD1_REG,\n\t\t\t\toffset,\n\t\t\t\targument ? ABX500_GPIO_PULL_DOWN :\n\t\t\t\tABX500_GPIO_PULL_NONE);\n\t\t\tbreak;\n\n\t\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\t\tret = abx500_gpio_direction_input(chip, offset);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\t \n\t\t\tret = abx500_gpio_direction_input(chip, offset);\n\t\t\tbreak;\n\n\t\tcase PIN_CONFIG_OUTPUT:\n\t\t\tret = abx500_gpio_direction_output(chip, offset,\n\t\t\t\targument);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_err(chip->parent,\n\t\t\t\t\"illegal configuration requested\\n\");\n\t\t}\n\t}  \nout:\n\tif (ret < 0)\n\t\tdev_err(pct->dev, \"%s failed (%d)\\n\", __func__, ret);\n\n\treturn ret;\n}\n\nstatic const struct pinconf_ops abx500_pinconf_ops = {\n\t.pin_config_get = abx500_pin_config_get,\n\t.pin_config_set = abx500_pin_config_set,\n\t.is_generic = true,\n};\n\nstatic struct pinctrl_desc abx500_pinctrl_desc = {\n\t.name = \"pinctrl-abx500\",\n\t.pctlops = &abx500_pinctrl_ops,\n\t.pmxops = &abx500_pinmux_ops,\n\t.confops = &abx500_pinconf_ops,\n\t.owner = THIS_MODULE,\n};\n\nstatic int abx500_get_gpio_num(struct abx500_pinctrl_soc_data *soc)\n{\n\tunsigned int lowest = 0;\n\tunsigned int highest = 0;\n\tunsigned int npins = 0;\n\tint i;\n\n\t \n\tfor (i = 0; i < soc->gpio_num_ranges; i++) {\n\t\tunsigned gstart;\n\t\tunsigned gend;\n\t\tconst struct abx500_pinrange *p;\n\n\t\tp = &soc->gpio_ranges[i];\n\t\tgstart = p->offset;\n\t\tgend = p->offset + p->npins - 1;\n\n\t\tif (i == 0) {\n\t\t\t \n\t\t\tlowest = gstart;\n\t\t\thighest = gend;\n\t\t} else {\n\t\t\tif (gstart < lowest)\n\t\t\t\tlowest = gstart;\n\t\t\tif (gend > highest)\n\t\t\t\thighest = gend;\n\t\t}\n\t}\n\t \n\tnpins = highest - lowest + 1;\n\treturn npins;\n}\n\nstatic const struct of_device_id abx500_gpio_match[] = {\n\t{ .compatible = \"stericsson,ab8500-gpio\", .data = (void *)PINCTRL_AB8500, },\n\t{ .compatible = \"stericsson,ab8505-gpio\", .data = (void *)PINCTRL_AB8505, },\n\t{ }\n};\n\nstatic int abx500_gpio_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tconst struct of_device_id *match;\n\tstruct abx500_pinctrl *pct;\n\tunsigned int id = -1;\n\tint ret;\n\tint i;\n\n\tif (!np) {\n\t\tdev_err(&pdev->dev, \"gpio dt node missing\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpct = devm_kzalloc(&pdev->dev, sizeof(*pct), GFP_KERNEL);\n\tif (!pct)\n\t\treturn -ENOMEM;\n\n\tpct->dev = &pdev->dev;\n\tpct->parent = dev_get_drvdata(pdev->dev.parent);\n\tpct->chip = abx500gpio_chip;\n\tpct->chip.parent = &pdev->dev;\n\tpct->chip.base = -1;  \n\n\tmatch = of_match_device(abx500_gpio_match, &pdev->dev);\n\tif (!match) {\n\t\tdev_err(&pdev->dev, \"gpio dt not matching\\n\");\n\t\treturn -ENODEV;\n\t}\n\tid = (unsigned long)match->data;\n\n\t \n\tswitch (id) {\n\tcase PINCTRL_AB8500:\n\t\tabx500_pinctrl_ab8500_init(&pct->soc);\n\t\tbreak;\n\tcase PINCTRL_AB8505:\n\t\tabx500_pinctrl_ab8505_init(&pct->soc);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&pdev->dev, \"Unsupported pinctrl sub driver (%d)\\n\", id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!pct->soc) {\n\t\tdev_err(&pdev->dev, \"Invalid SOC data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpct->chip.ngpio = abx500_get_gpio_num(pct->soc);\n\tpct->irq_cluster = pct->soc->gpio_irq_cluster;\n\tpct->irq_cluster_size = pct->soc->ngpio_irq_cluster;\n\n\tret = gpiochip_add_data(&pct->chip, pct);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"unable to add gpiochip: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tdev_info(&pdev->dev, \"added gpiochip\\n\");\n\n\tabx500_pinctrl_desc.pins = pct->soc->pins;\n\tabx500_pinctrl_desc.npins = pct->soc->npins;\n\tpct->pctldev = devm_pinctrl_register(&pdev->dev, &abx500_pinctrl_desc,\n\t\t\t\t\t     pct);\n\tif (IS_ERR(pct->pctldev)) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"could not register abx500 pinctrl driver\\n\");\n\t\tret = PTR_ERR(pct->pctldev);\n\t\tgoto out_rem_chip;\n\t}\n\tdev_info(&pdev->dev, \"registered pin controller\\n\");\n\n\t \n\tfor (i = 0; i < pct->soc->gpio_num_ranges; i++) {\n\t\tconst struct abx500_pinrange *p = &pct->soc->gpio_ranges[i];\n\n\t\tret = gpiochip_add_pin_range(&pct->chip,\n\t\t\t\t\tdev_name(&pdev->dev),\n\t\t\t\t\tp->offset - 1, p->offset, p->npins);\n\t\tif (ret < 0)\n\t\t\tgoto out_rem_chip;\n\t}\n\n\tplatform_set_drvdata(pdev, pct);\n\tdev_info(&pdev->dev, \"initialized abx500 pinctrl driver\\n\");\n\n\treturn 0;\n\nout_rem_chip:\n\tgpiochip_remove(&pct->chip);\n\treturn ret;\n}\n\n \nstatic int abx500_gpio_remove(struct platform_device *pdev)\n{\n\tstruct abx500_pinctrl *pct = platform_get_drvdata(pdev);\n\n\tgpiochip_remove(&pct->chip);\n\treturn 0;\n}\n\nstatic struct platform_driver abx500_gpio_driver = {\n\t.driver = {\n\t\t.name = \"abx500-gpio\",\n\t\t.of_match_table = abx500_gpio_match,\n\t},\n\t.probe = abx500_gpio_probe,\n\t.remove = abx500_gpio_remove,\n};\n\nstatic int __init abx500_gpio_init(void)\n{\n\treturn platform_driver_register(&abx500_gpio_driver);\n}\ncore_initcall(abx500_gpio_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}