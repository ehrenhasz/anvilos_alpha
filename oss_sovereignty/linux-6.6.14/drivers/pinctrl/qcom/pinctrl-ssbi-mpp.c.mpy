{
  "module_name": "pinctrl-ssbi-mpp.c",
  "hash_id": "90574f26502ad60fdddd702ad0e710f70ef3cfce1a366cef3df713eec4664b8a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/qcom/pinctrl-ssbi-mpp.c",
  "human_readable_source": "\n \n\n#include <linux/gpio/driver.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n\n#include <linux/pinctrl/pinconf-generic.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinmux.h>\n\n#include <dt-bindings/pinctrl/qcom,pmic-mpp.h>\n\n#include \"../core.h\"\n#include \"../pinctrl-utils.h\"\n\n \n#define SSBI_REG_ADDR_MPP_BASE\t\t0x50\n#define SSBI_REG_ADDR_MPP(n)\t\t(SSBI_REG_ADDR_MPP_BASE + n)\n\n \n#define PM8XXX_MPP_TYPE_D_INPUT         0\n#define PM8XXX_MPP_TYPE_D_OUTPUT        1\n#define PM8XXX_MPP_TYPE_D_BI_DIR        2\n#define PM8XXX_MPP_TYPE_A_INPUT         3\n#define PM8XXX_MPP_TYPE_A_OUTPUT        4\n#define PM8XXX_MPP_TYPE_SINK            5\n#define PM8XXX_MPP_TYPE_DTEST_SINK      6\n#define PM8XXX_MPP_TYPE_DTEST_OUTPUT    7\n\n \n#define PM8XXX_MPP_DIN_TO_INT           0\n#define PM8XXX_MPP_DIN_TO_DBUS1         1\n#define PM8XXX_MPP_DIN_TO_DBUS2         2\n#define PM8XXX_MPP_DIN_TO_DBUS3         3\n\n \n#define PM8XXX_MPP_DOUT_CTRL_LOW        0\n#define PM8XXX_MPP_DOUT_CTRL_HIGH       1\n#define PM8XXX_MPP_DOUT_CTRL_MPP        2\n#define PM8XXX_MPP_DOUT_CTRL_INV_MPP    3\n\n \n#define PM8XXX_MPP_BI_PULLUP_1KOHM      0\n#define PM8XXX_MPP_BI_PULLUP_OPEN       1\n#define PM8XXX_MPP_BI_PULLUP_10KOHM     2\n#define PM8XXX_MPP_BI_PULLUP_30KOHM     3\n\n \n#define PM8XXX_MPP_AOUT_CTRL_DISABLE            0\n#define PM8XXX_MPP_AOUT_CTRL_ENABLE             1\n#define PM8XXX_MPP_AOUT_CTRL_MPP_HIGH_EN        2\n#define PM8XXX_MPP_AOUT_CTRL_MPP_LOW_EN         3\n\n \n#define PM8XXX_MPP_CS_CTRL_DISABLE      0\n#define PM8XXX_MPP_CS_CTRL_ENABLE       1\n#define PM8XXX_MPP_CS_CTRL_MPP_HIGH_EN  2\n#define PM8XXX_MPP_CS_CTRL_MPP_LOW_EN   3\n\n \n#define PM8XXX_MPP_DTEST_CS_CTRL_EN1    0\n#define PM8XXX_MPP_DTEST_CS_CTRL_EN2    1\n#define PM8XXX_MPP_DTEST_CS_CTRL_EN3    2\n#define PM8XXX_MPP_DTEST_CS_CTRL_EN4    3\n\n \n#define PM8XXX_MPP_DTEST_DBUS1          0\n#define PM8XXX_MPP_DTEST_DBUS2          1\n#define PM8XXX_MPP_DTEST_DBUS3          2\n#define PM8XXX_MPP_DTEST_DBUS4          3\n\n \n#define PM8XXX_CONFIG_AMUX\t\t(PIN_CONFIG_END + 1)\n#define PM8XXX_CONFIG_DTEST_SELECTOR\t(PIN_CONFIG_END + 2)\n#define PM8XXX_CONFIG_ALEVEL\t\t(PIN_CONFIG_END + 3)\n#define PM8XXX_CONFIG_PAIRED\t\t(PIN_CONFIG_END + 4)\n\n \nstruct pm8xxx_pin_data {\n\tunsigned reg;\n\n\tu8 mode;\n\n\tbool input;\n\tbool output;\n\tbool high_z;\n\tbool paired;\n\tbool output_value;\n\n\tu8 power_source;\n\tu8 dtest;\n\tu8 amux;\n\tu8 aout_level;\n\tu8 drive_strength;\n\tunsigned pullup;\n};\n\nstruct pm8xxx_mpp {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tstruct pinctrl_dev *pctrl;\n\tstruct gpio_chip chip;\n\n\tstruct pinctrl_desc desc;\n\tunsigned npins;\n};\n\nstatic const struct pinconf_generic_params pm8xxx_mpp_bindings[] = {\n\t{\"qcom,amux-route\",\tPM8XXX_CONFIG_AMUX,\t\t0},\n\t{\"qcom,analog-level\",\tPM8XXX_CONFIG_ALEVEL,\t\t0},\n\t{\"qcom,dtest\",\t\tPM8XXX_CONFIG_DTEST_SELECTOR,\t0},\n\t{\"qcom,paired\",\t\tPM8XXX_CONFIG_PAIRED,\t\t0},\n};\n\n#ifdef CONFIG_DEBUG_FS\nstatic const struct pin_config_item pm8xxx_conf_items[] = {\n\tPCONFDUMP(PM8XXX_CONFIG_AMUX, \"analog mux\", NULL, true),\n\tPCONFDUMP(PM8XXX_CONFIG_ALEVEL, \"analog level\", NULL, true),\n\tPCONFDUMP(PM8XXX_CONFIG_DTEST_SELECTOR, \"dtest\", NULL, true),\n\tPCONFDUMP(PM8XXX_CONFIG_PAIRED, \"paired\", NULL, false),\n};\n#endif\n\n#define PM8XXX_MAX_MPPS\t12\n#define PM8XXX_MPP_PHYSICAL_OFFSET    1\n\nstatic const char * const pm8xxx_groups[PM8XXX_MAX_MPPS] = {\n\t\"mpp1\", \"mpp2\", \"mpp3\", \"mpp4\", \"mpp5\", \"mpp6\", \"mpp7\", \"mpp8\",\n\t\"mpp9\", \"mpp10\", \"mpp11\", \"mpp12\",\n};\n\n#define PM8XXX_MPP_DIGITAL\t0\n#define PM8XXX_MPP_ANALOG\t1\n#define PM8XXX_MPP_SINK\t\t2\n\nstatic const char * const pm8xxx_mpp_functions[] = {\n\t\"digital\", \"analog\", \"sink\",\n};\n\nstatic int pm8xxx_mpp_update(struct pm8xxx_mpp *pctrl,\n\t\t\t     struct pm8xxx_pin_data *pin)\n{\n\tunsigned level;\n\tunsigned ctrl;\n\tunsigned type;\n\tint ret;\n\tu8 val;\n\n\tswitch (pin->mode) {\n\tcase PM8XXX_MPP_DIGITAL:\n\t\tif (pin->dtest) {\n\t\t\ttype = PM8XXX_MPP_TYPE_DTEST_OUTPUT;\n\t\t\tctrl = pin->dtest - 1;\n\t\t} else if (pin->input && pin->output) {\n\t\t\ttype = PM8XXX_MPP_TYPE_D_BI_DIR;\n\t\t\tif (pin->high_z)\n\t\t\t\tctrl = PM8XXX_MPP_BI_PULLUP_OPEN;\n\t\t\telse if (pin->pullup == 600)\n\t\t\t\tctrl = PM8XXX_MPP_BI_PULLUP_1KOHM;\n\t\t\telse if (pin->pullup == 10000)\n\t\t\t\tctrl = PM8XXX_MPP_BI_PULLUP_10KOHM;\n\t\t\telse\n\t\t\t\tctrl = PM8XXX_MPP_BI_PULLUP_30KOHM;\n\t\t} else if (pin->input) {\n\t\t\ttype = PM8XXX_MPP_TYPE_D_INPUT;\n\t\t\tif (pin->dtest)\n\t\t\t\tctrl = pin->dtest;\n\t\t\telse\n\t\t\t\tctrl = PM8XXX_MPP_DIN_TO_INT;\n\t\t} else {\n\t\t\ttype = PM8XXX_MPP_TYPE_D_OUTPUT;\n\t\t\tctrl = !!pin->output_value;\n\t\t\tif (pin->paired)\n\t\t\t\tctrl |= BIT(1);\n\t\t}\n\n\t\tlevel = pin->power_source;\n\t\tbreak;\n\tcase PM8XXX_MPP_ANALOG:\n\t\tif (pin->output) {\n\t\t\ttype = PM8XXX_MPP_TYPE_A_OUTPUT;\n\t\t\tlevel = pin->aout_level;\n\t\t\tctrl = pin->output_value;\n\t\t\tif (pin->paired)\n\t\t\t\tctrl |= BIT(1);\n\t\t} else {\n\t\t\ttype = PM8XXX_MPP_TYPE_A_INPUT;\n\t\t\tlevel = pin->amux;\n\t\t\tctrl = 0;\n\t\t}\n\t\tbreak;\n\tcase PM8XXX_MPP_SINK:\n\t\tlevel = (pin->drive_strength / 5) - 1;\n\t\tif (pin->dtest) {\n\t\t\ttype = PM8XXX_MPP_TYPE_DTEST_SINK;\n\t\t\tctrl = pin->dtest - 1;\n\t\t} else {\n\t\t\ttype = PM8XXX_MPP_TYPE_SINK;\n\t\t\tctrl = pin->output_value;\n\t\t\tif (pin->paired)\n\t\t\t\tctrl |= BIT(1);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tval = type << 5 | level << 2 | ctrl;\n\tret = regmap_write(pctrl->regmap, pin->reg, val);\n\tif (ret)\n\t\tdev_err(pctrl->dev, \"failed to write register\\n\");\n\n\treturn ret;\n}\n\nstatic int pm8xxx_get_groups_count(struct pinctrl_dev *pctldev)\n{\n\tstruct pm8xxx_mpp *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pctrl->npins;\n}\n\nstatic const char *pm8xxx_get_group_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t unsigned group)\n{\n\treturn pm8xxx_groups[group];\n}\n\n\nstatic int pm8xxx_get_group_pins(struct pinctrl_dev *pctldev,\n\t\t\t\t unsigned group,\n\t\t\t\t const unsigned **pins,\n\t\t\t\t unsigned *num_pins)\n{\n\tstruct pm8xxx_mpp *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\n\t*pins = &pctrl->desc.pins[group].number;\n\t*num_pins = 1;\n\n\treturn 0;\n}\n\nstatic const struct pinctrl_ops pm8xxx_pinctrl_ops = {\n\t.get_groups_count\t= pm8xxx_get_groups_count,\n\t.get_group_name\t\t= pm8xxx_get_group_name,\n\t.get_group_pins         = pm8xxx_get_group_pins,\n\t.dt_node_to_map\t\t= pinconf_generic_dt_node_to_map_group,\n\t.dt_free_map\t\t= pinctrl_utils_free_map,\n};\n\nstatic int pm8xxx_get_functions_count(struct pinctrl_dev *pctldev)\n{\n\treturn ARRAY_SIZE(pm8xxx_mpp_functions);\n}\n\nstatic const char *pm8xxx_get_function_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t    unsigned function)\n{\n\treturn pm8xxx_mpp_functions[function];\n}\n\nstatic int pm8xxx_get_function_groups(struct pinctrl_dev *pctldev,\n\t\t\t\t      unsigned function,\n\t\t\t\t      const char * const **groups,\n\t\t\t\t      unsigned * const num_groups)\n{\n\tstruct pm8xxx_mpp *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\n\t*groups = pm8xxx_groups;\n\t*num_groups = pctrl->npins;\n\treturn 0;\n}\n\nstatic int pm8xxx_pinmux_set_mux(struct pinctrl_dev *pctldev,\n\t\t\t\t unsigned function,\n\t\t\t\t unsigned group)\n{\n\tstruct pm8xxx_mpp *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct pm8xxx_pin_data *pin = pctrl->desc.pins[group].drv_data;\n\n\tpin->mode = function;\n\tpm8xxx_mpp_update(pctrl, pin);\n\n\treturn 0;\n}\n\nstatic const struct pinmux_ops pm8xxx_pinmux_ops = {\n\t.get_functions_count\t= pm8xxx_get_functions_count,\n\t.get_function_name\t= pm8xxx_get_function_name,\n\t.get_function_groups\t= pm8xxx_get_function_groups,\n\t.set_mux\t\t= pm8xxx_pinmux_set_mux,\n};\n\nstatic int pm8xxx_pin_config_get(struct pinctrl_dev *pctldev,\n\t\t\t\t unsigned int offset,\n\t\t\t\t unsigned long *config)\n{\n\tstruct pm8xxx_mpp *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct pm8xxx_pin_data *pin = pctrl->desc.pins[offset].drv_data;\n\tunsigned param = pinconf_to_config_param(*config);\n\tunsigned arg;\n\n\tswitch (param) {\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\targ = pin->pullup;\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_HIGH_IMPEDANCE:\n\t\targ = pin->high_z;\n\t\tbreak;\n\tcase PIN_CONFIG_INPUT_ENABLE:\n\t\targ = pin->input;\n\t\tbreak;\n\tcase PIN_CONFIG_OUTPUT:\n\t\targ = pin->output_value;\n\t\tbreak;\n\tcase PIN_CONFIG_POWER_SOURCE:\n\t\targ = pin->power_source;\n\t\tbreak;\n\tcase PIN_CONFIG_DRIVE_STRENGTH:\n\t\targ = pin->drive_strength;\n\t\tbreak;\n\tcase PM8XXX_CONFIG_DTEST_SELECTOR:\n\t\targ = pin->dtest;\n\t\tbreak;\n\tcase PM8XXX_CONFIG_AMUX:\n\t\targ = pin->amux;\n\t\tbreak;\n\tcase PM8XXX_CONFIG_ALEVEL:\n\t\targ = pin->aout_level;\n\t\tbreak;\n\tcase PM8XXX_CONFIG_PAIRED:\n\t\targ = pin->paired;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t*config = pinconf_to_config_packed(param, arg);\n\n\treturn 0;\n}\n\nstatic int pm8xxx_pin_config_set(struct pinctrl_dev *pctldev,\n\t\t\t\t unsigned int offset,\n\t\t\t\t unsigned long *configs,\n\t\t\t\t unsigned num_configs)\n{\n\tstruct pm8xxx_mpp *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct pm8xxx_pin_data *pin = pctrl->desc.pins[offset].drv_data;\n\tunsigned param;\n\tunsigned arg;\n\tunsigned i;\n\n\tfor (i = 0; i < num_configs; i++) {\n\t\tparam = pinconf_to_config_param(configs[i]);\n\t\targ = pinconf_to_config_argument(configs[i]);\n\n\t\tswitch (param) {\n\t\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\t\tpin->pullup = arg;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_BIAS_HIGH_IMPEDANCE:\n\t\t\tpin->high_z = true;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_INPUT_ENABLE:\n\t\t\tpin->input = true;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_OUTPUT:\n\t\t\tpin->output = true;\n\t\t\tpin->output_value = !!arg;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_POWER_SOURCE:\n\t\t\tpin->power_source = arg;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_DRIVE_STRENGTH:\n\t\t\tpin->drive_strength = arg;\n\t\t\tbreak;\n\t\tcase PM8XXX_CONFIG_DTEST_SELECTOR:\n\t\t\tpin->dtest = arg;\n\t\t\tbreak;\n\t\tcase PM8XXX_CONFIG_AMUX:\n\t\t\tpin->amux = arg;\n\t\t\tbreak;\n\t\tcase PM8XXX_CONFIG_ALEVEL:\n\t\t\tpin->aout_level = arg;\n\t\t\tbreak;\n\t\tcase PM8XXX_CONFIG_PAIRED:\n\t\t\tpin->paired = !!arg;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(pctrl->dev,\n\t\t\t\t\"unsupported config parameter: %x\\n\",\n\t\t\t\tparam);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tpm8xxx_mpp_update(pctrl, pin);\n\n\treturn 0;\n}\n\nstatic const struct pinconf_ops pm8xxx_pinconf_ops = {\n\t.is_generic = true,\n\t.pin_config_group_get = pm8xxx_pin_config_get,\n\t.pin_config_group_set = pm8xxx_pin_config_set,\n};\n\nstatic const struct pinctrl_desc pm8xxx_pinctrl_desc = {\n\t.name = \"pm8xxx_mpp\",\n\t.pctlops = &pm8xxx_pinctrl_ops,\n\t.pmxops = &pm8xxx_pinmux_ops,\n\t.confops = &pm8xxx_pinconf_ops,\n\t.owner = THIS_MODULE,\n};\n\nstatic int pm8xxx_mpp_direction_input(struct gpio_chip *chip,\n\t\t\t\t       unsigned offset)\n{\n\tstruct pm8xxx_mpp *pctrl = gpiochip_get_data(chip);\n\tstruct pm8xxx_pin_data *pin = pctrl->desc.pins[offset].drv_data;\n\n\tswitch (pin->mode) {\n\tcase PM8XXX_MPP_DIGITAL:\n\t\tpin->input = true;\n\t\tbreak;\n\tcase PM8XXX_MPP_ANALOG:\n\t\tpin->input = true;\n\t\tpin->output = true;\n\t\tbreak;\n\tcase PM8XXX_MPP_SINK:\n\t\treturn -EINVAL;\n\t}\n\n\tpm8xxx_mpp_update(pctrl, pin);\n\n\treturn 0;\n}\n\nstatic int pm8xxx_mpp_direction_output(struct gpio_chip *chip,\n\t\t\t\t\tunsigned offset,\n\t\t\t\t\tint value)\n{\n\tstruct pm8xxx_mpp *pctrl = gpiochip_get_data(chip);\n\tstruct pm8xxx_pin_data *pin = pctrl->desc.pins[offset].drv_data;\n\n\tswitch (pin->mode) {\n\tcase PM8XXX_MPP_DIGITAL:\n\t\tpin->output = true;\n\t\tbreak;\n\tcase PM8XXX_MPP_ANALOG:\n\t\tpin->input = false;\n\t\tpin->output = true;\n\t\tbreak;\n\tcase PM8XXX_MPP_SINK:\n\t\tpin->input = false;\n\t\tpin->output = true;\n\t\tbreak;\n\t}\n\n\tpm8xxx_mpp_update(pctrl, pin);\n\n\treturn 0;\n}\n\nstatic int pm8xxx_mpp_get(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct pm8xxx_mpp *pctrl = gpiochip_get_data(chip);\n\tstruct pm8xxx_pin_data *pin = pctrl->desc.pins[offset].drv_data;\n\tbool state;\n\tint ret, irq;\n\n\tif (!pin->input)\n\t\treturn !!pin->output_value;\n\n\tirq = chip->to_irq(chip, offset);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = irq_get_irqchip_state(irq, IRQCHIP_STATE_LINE_LEVEL, &state);\n\tif (!ret)\n\t\tret = !!state;\n\n\treturn ret;\n}\n\nstatic void pm8xxx_mpp_set(struct gpio_chip *chip, unsigned offset, int value)\n{\n\tstruct pm8xxx_mpp *pctrl = gpiochip_get_data(chip);\n\tstruct pm8xxx_pin_data *pin = pctrl->desc.pins[offset].drv_data;\n\n\tpin->output_value = !!value;\n\n\tpm8xxx_mpp_update(pctrl, pin);\n}\n\nstatic int pm8xxx_mpp_of_xlate(struct gpio_chip *chip,\n\t\t\t\tconst struct of_phandle_args *gpio_desc,\n\t\t\t\tu32 *flags)\n{\n\tif (chip->of_gpio_n_cells < 2)\n\t\treturn -EINVAL;\n\n\tif (flags)\n\t\t*flags = gpio_desc->args[1];\n\n\treturn gpio_desc->args[0] - PM8XXX_MPP_PHYSICAL_OFFSET;\n}\n\n\n#ifdef CONFIG_DEBUG_FS\n\nstatic void pm8xxx_mpp_dbg_show_one(struct seq_file *s,\n\t\t\t\t  struct pinctrl_dev *pctldev,\n\t\t\t\t  struct gpio_chip *chip,\n\t\t\t\t  unsigned offset,\n\t\t\t\t  unsigned gpio)\n{\n\tstruct pm8xxx_mpp *pctrl = gpiochip_get_data(chip);\n\tstruct pm8xxx_pin_data *pin = pctrl->desc.pins[offset].drv_data;\n\n\tstatic const char * const aout_lvls[] = {\n\t\t\"1v25\", \"1v25_2\", \"0v625\", \"0v3125\", \"mpp\", \"abus1\", \"abus2\",\n\t\t\"abus3\"\n\t};\n\n\tstatic const char * const amuxs[] = {\n\t\t\"amux5\", \"amux6\", \"amux7\", \"amux8\", \"amux9\", \"abus1\", \"abus2\",\n\t\t\"abus3\",\n\t};\n\n\tseq_printf(s, \" mpp%-2d:\", offset + PM8XXX_MPP_PHYSICAL_OFFSET);\n\n\tswitch (pin->mode) {\n\tcase PM8XXX_MPP_DIGITAL:\n\t\tseq_puts(s, \" digital \");\n\t\tif (pin->dtest) {\n\t\t\tseq_printf(s, \"dtest%d\\n\", pin->dtest);\n\t\t} else if (pin->input && pin->output) {\n\t\t\tif (pin->high_z)\n\t\t\t\tseq_puts(s, \"bi-dir high-z\");\n\t\t\telse\n\t\t\t\tseq_printf(s, \"bi-dir %dOhm\", pin->pullup);\n\t\t} else if (pin->input) {\n\t\t\tif (pin->dtest)\n\t\t\t\tseq_printf(s, \"in dtest%d\", pin->dtest);\n\t\t\telse\n\t\t\t\tseq_puts(s, \"in gpio\");\n\t\t} else if (pin->output) {\n\t\t\tseq_puts(s, \"out \");\n\n\t\t\tif (!pin->paired) {\n\t\t\t\tseq_puts(s, pin->output_value ?\n\t\t\t\t\t \"high\" : \"low\");\n\t\t\t} else {\n\t\t\t\tseq_puts(s, pin->output_value ?\n\t\t\t\t\t \"inverted\" : \"follow\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase PM8XXX_MPP_ANALOG:\n\t\tseq_puts(s, \" analog \");\n\t\tif (pin->output) {\n\t\t\tseq_printf(s, \"out %s \", aout_lvls[pin->aout_level]);\n\t\t\tif (!pin->paired) {\n\t\t\t\tseq_puts(s, pin->output_value ?\n\t\t\t\t\t \"high\" : \"low\");\n\t\t\t} else {\n\t\t\t\tseq_puts(s, pin->output_value ?\n\t\t\t\t\t \"inverted\" : \"follow\");\n\t\t\t}\n\t\t} else {\n\t\t\tseq_printf(s, \"input mux %s\", amuxs[pin->amux]);\n\t\t}\n\t\tbreak;\n\tcase PM8XXX_MPP_SINK:\n\t\tseq_printf(s, \" sink %dmA \", pin->drive_strength);\n\t\tif (pin->dtest) {\n\t\t\tseq_printf(s, \"dtest%d\", pin->dtest);\n\t\t} else {\n\t\t\tif (!pin->paired) {\n\t\t\t\tseq_puts(s, pin->output_value ?\n\t\t\t\t\t \"high\" : \"low\");\n\t\t\t} else {\n\t\t\t\tseq_puts(s, pin->output_value ?\n\t\t\t\t\t \"inverted\" : \"follow\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic void pm8xxx_mpp_dbg_show(struct seq_file *s, struct gpio_chip *chip)\n{\n\tunsigned gpio = chip->base;\n\tunsigned i;\n\n\tfor (i = 0; i < chip->ngpio; i++, gpio++) {\n\t\tpm8xxx_mpp_dbg_show_one(s, NULL, chip, i, gpio);\n\t\tseq_puts(s, \"\\n\");\n\t}\n}\n\n#else\n#define pm8xxx_mpp_dbg_show NULL\n#endif\n\nstatic const struct gpio_chip pm8xxx_mpp_template = {\n\t.direction_input = pm8xxx_mpp_direction_input,\n\t.direction_output = pm8xxx_mpp_direction_output,\n\t.get = pm8xxx_mpp_get,\n\t.set = pm8xxx_mpp_set,\n\t.of_xlate = pm8xxx_mpp_of_xlate,\n\t.dbg_show = pm8xxx_mpp_dbg_show,\n\t.owner = THIS_MODULE,\n};\n\nstatic int pm8xxx_pin_populate(struct pm8xxx_mpp *pctrl,\n\t\t\t       struct pm8xxx_pin_data *pin)\n{\n\tunsigned int val;\n\tunsigned level;\n\tunsigned ctrl;\n\tunsigned type;\n\tint ret;\n\n\tret = regmap_read(pctrl->regmap, pin->reg, &val);\n\tif (ret) {\n\t\tdev_err(pctrl->dev, \"failed to read register\\n\");\n\t\treturn ret;\n\t}\n\n\ttype = (val >> 5) & 7;\n\tlevel = (val >> 2) & 7;\n\tctrl = (val) & 3;\n\n\tswitch (type) {\n\tcase PM8XXX_MPP_TYPE_D_INPUT:\n\t\tpin->mode = PM8XXX_MPP_DIGITAL;\n\t\tpin->input = true;\n\t\tpin->power_source = level;\n\t\tpin->dtest = ctrl;\n\t\tbreak;\n\tcase PM8XXX_MPP_TYPE_D_OUTPUT:\n\t\tpin->mode = PM8XXX_MPP_DIGITAL;\n\t\tpin->output = true;\n\t\tpin->power_source = level;\n\t\tpin->output_value = !!(ctrl & BIT(0));\n\t\tpin->paired = !!(ctrl & BIT(1));\n\t\tbreak;\n\tcase PM8XXX_MPP_TYPE_D_BI_DIR:\n\t\tpin->mode = PM8XXX_MPP_DIGITAL;\n\t\tpin->input = true;\n\t\tpin->output = true;\n\t\tpin->power_source = level;\n\t\tswitch (ctrl) {\n\t\tcase PM8XXX_MPP_BI_PULLUP_1KOHM:\n\t\t\tpin->pullup = 600;\n\t\t\tbreak;\n\t\tcase PM8XXX_MPP_BI_PULLUP_OPEN:\n\t\t\tpin->high_z = true;\n\t\t\tbreak;\n\t\tcase PM8XXX_MPP_BI_PULLUP_10KOHM:\n\t\t\tpin->pullup = 10000;\n\t\t\tbreak;\n\t\tcase PM8XXX_MPP_BI_PULLUP_30KOHM:\n\t\t\tpin->pullup = 30000;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase PM8XXX_MPP_TYPE_A_INPUT:\n\t\tpin->mode = PM8XXX_MPP_ANALOG;\n\t\tpin->input = true;\n\t\tpin->amux = level;\n\t\tbreak;\n\tcase PM8XXX_MPP_TYPE_A_OUTPUT:\n\t\tpin->mode = PM8XXX_MPP_ANALOG;\n\t\tpin->output = true;\n\t\tpin->aout_level = level;\n\t\tpin->output_value = !!(ctrl & BIT(0));\n\t\tpin->paired = !!(ctrl & BIT(1));\n\t\tbreak;\n\tcase PM8XXX_MPP_TYPE_SINK:\n\t\tpin->mode = PM8XXX_MPP_SINK;\n\t\tpin->drive_strength = 5 * (level + 1);\n\t\tpin->output_value = !!(ctrl & BIT(0));\n\t\tpin->paired = !!(ctrl & BIT(1));\n\t\tbreak;\n\tcase PM8XXX_MPP_TYPE_DTEST_SINK:\n\t\tpin->mode = PM8XXX_MPP_SINK;\n\t\tpin->dtest = ctrl + 1;\n\t\tpin->drive_strength = 5 * (level + 1);\n\t\tbreak;\n\tcase PM8XXX_MPP_TYPE_DTEST_OUTPUT:\n\t\tpin->mode = PM8XXX_MPP_DIGITAL;\n\t\tpin->power_source = level;\n\t\tif (ctrl >= 1)\n\t\t\tpin->dtest = ctrl;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int pm8xxx_mpp_domain_translate(struct irq_domain *domain,\n\t\t\t\t   struct irq_fwspec *fwspec,\n\t\t\t\t   unsigned long *hwirq,\n\t\t\t\t   unsigned int *type)\n{\n\tstruct pm8xxx_mpp *pctrl = container_of(domain->host_data,\n\t\t\t\t\t\t struct pm8xxx_mpp, chip);\n\n\tif (fwspec->param_count != 2 ||\n\t    fwspec->param[0] < PM8XXX_MPP_PHYSICAL_OFFSET ||\n\t    fwspec->param[0] > pctrl->chip.ngpio)\n\t\treturn -EINVAL;\n\n\t*hwirq = fwspec->param[0] - PM8XXX_MPP_PHYSICAL_OFFSET;\n\t*type = fwspec->param[1];\n\n\treturn 0;\n}\n\nstatic unsigned int pm8xxx_mpp_child_offset_to_irq(struct gpio_chip *chip,\n\t\t\t\t\t\t   unsigned int offset)\n{\n\treturn offset + PM8XXX_MPP_PHYSICAL_OFFSET;\n}\n\nstatic int pm8821_mpp_child_to_parent_hwirq(struct gpio_chip *chip,\n\t\t\t\t\t    unsigned int child_hwirq,\n\t\t\t\t\t    unsigned int child_type,\n\t\t\t\t\t    unsigned int *parent_hwirq,\n\t\t\t\t\t    unsigned int *parent_type)\n{\n\t*parent_hwirq = child_hwirq + 24;\n\t*parent_type = child_type;\n\n\treturn 0;\n}\n\nstatic int pm8xxx_mpp_child_to_parent_hwirq(struct gpio_chip *chip,\n\t\t\t\t\t    unsigned int child_hwirq,\n\t\t\t\t\t    unsigned int child_type,\n\t\t\t\t\t    unsigned int *parent_hwirq,\n\t\t\t\t\t    unsigned int *parent_type)\n{\n\t*parent_hwirq = child_hwirq + 0x80;\n\t*parent_type = child_type;\n\n\treturn 0;\n}\n\nstatic void pm8xxx_mpp_irq_disable(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\n\tgpiochip_disable_irq(gc, irqd_to_hwirq(d));\n}\n\nstatic void pm8xxx_mpp_irq_enable(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\n\tgpiochip_enable_irq(gc, irqd_to_hwirq(d));\n}\n\nstatic const struct irq_chip pm8xxx_mpp_irq_chip = {\n\t.name = \"ssbi-mpp\",\n\t.irq_mask_ack = irq_chip_mask_ack_parent,\n\t.irq_unmask = irq_chip_unmask_parent,\n\t.irq_disable = pm8xxx_mpp_irq_disable,\n\t.irq_enable = pm8xxx_mpp_irq_enable,\n\t.irq_set_type = irq_chip_set_type_parent,\n\t.flags = IRQCHIP_MASK_ON_SUSPEND | IRQCHIP_SKIP_SET_WAKE |\n\t\tIRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic const struct of_device_id pm8xxx_mpp_of_match[] = {\n\t{ .compatible = \"qcom,pm8018-mpp\", .data = (void *) 6 },\n\t{ .compatible = \"qcom,pm8038-mpp\", .data = (void *) 6 },\n\t{ .compatible = \"qcom,pm8058-mpp\", .data = (void *) 12 },\n\t{ .compatible = \"qcom,pm8821-mpp\", .data = (void *) 4 },\n\t{ .compatible = \"qcom,pm8917-mpp\", .data = (void *) 10 },\n\t{ .compatible = \"qcom,pm8921-mpp\", .data = (void *) 12 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, pm8xxx_mpp_of_match);\n\nstatic int pm8xxx_mpp_probe(struct platform_device *pdev)\n{\n\tstruct pm8xxx_pin_data *pin_data;\n\tstruct irq_domain *parent_domain;\n\tstruct device_node *parent_node;\n\tstruct pinctrl_pin_desc *pins;\n\tstruct gpio_irq_chip *girq;\n\tstruct pm8xxx_mpp *pctrl;\n\tint ret;\n\tint i;\n\n\tpctrl = devm_kzalloc(&pdev->dev, sizeof(*pctrl), GFP_KERNEL);\n\tif (!pctrl)\n\t\treturn -ENOMEM;\n\n\tpctrl->dev = &pdev->dev;\n\tpctrl->npins = (uintptr_t) device_get_match_data(&pdev->dev);\n\n\tpctrl->regmap = dev_get_regmap(pdev->dev.parent, NULL);\n\tif (!pctrl->regmap) {\n\t\tdev_err(&pdev->dev, \"parent regmap unavailable\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tpctrl->desc = pm8xxx_pinctrl_desc;\n\tpctrl->desc.npins = pctrl->npins;\n\n\tpins = devm_kcalloc(&pdev->dev,\n\t\t\t    pctrl->desc.npins,\n\t\t\t    sizeof(struct pinctrl_pin_desc),\n\t\t\t    GFP_KERNEL);\n\tif (!pins)\n\t\treturn -ENOMEM;\n\n\tpin_data = devm_kcalloc(&pdev->dev,\n\t\t\t\tpctrl->desc.npins,\n\t\t\t\tsizeof(struct pm8xxx_pin_data),\n\t\t\t\tGFP_KERNEL);\n\tif (!pin_data)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < pctrl->desc.npins; i++) {\n\t\tpin_data[i].reg = SSBI_REG_ADDR_MPP(i);\n\n\t\tret = pm8xxx_pin_populate(pctrl, &pin_data[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tpins[i].number = i;\n\t\tpins[i].name = pm8xxx_groups[i];\n\t\tpins[i].drv_data = &pin_data[i];\n\t}\n\tpctrl->desc.pins = pins;\n\n\tpctrl->desc.num_custom_params = ARRAY_SIZE(pm8xxx_mpp_bindings);\n\tpctrl->desc.custom_params = pm8xxx_mpp_bindings;\n#ifdef CONFIG_DEBUG_FS\n\tpctrl->desc.custom_conf_items = pm8xxx_conf_items;\n#endif\n\n\tpctrl->pctrl = devm_pinctrl_register(&pdev->dev, &pctrl->desc, pctrl);\n\tif (IS_ERR(pctrl->pctrl)) {\n\t\tdev_err(&pdev->dev, \"couldn't register pm8xxx mpp driver\\n\");\n\t\treturn PTR_ERR(pctrl->pctrl);\n\t}\n\n\tpctrl->chip = pm8xxx_mpp_template;\n\tpctrl->chip.base = -1;\n\tpctrl->chip.parent = &pdev->dev;\n\tpctrl->chip.of_gpio_n_cells = 2;\n\tpctrl->chip.label = dev_name(pctrl->dev);\n\tpctrl->chip.ngpio = pctrl->npins;\n\n\tparent_node = of_irq_find_parent(pctrl->dev->of_node);\n\tif (!parent_node)\n\t\treturn -ENXIO;\n\n\tparent_domain = irq_find_host(parent_node);\n\tof_node_put(parent_node);\n\tif (!parent_domain)\n\t\treturn -ENXIO;\n\n\tgirq = &pctrl->chip.irq;\n\tgpio_irq_chip_set_chip(girq, &pm8xxx_mpp_irq_chip);\n\tgirq->default_type = IRQ_TYPE_NONE;\n\tgirq->handler = handle_level_irq;\n\tgirq->fwnode = dev_fwnode(pctrl->dev);\n\tgirq->parent_domain = parent_domain;\n\tif (of_device_is_compatible(pdev->dev.of_node, \"qcom,pm8821-mpp\"))\n\t\tgirq->child_to_parent_hwirq = pm8821_mpp_child_to_parent_hwirq;\n\telse\n\t\tgirq->child_to_parent_hwirq = pm8xxx_mpp_child_to_parent_hwirq;\n\tgirq->populate_parent_alloc_arg = gpiochip_populate_parent_fwspec_twocell;\n\tgirq->child_offset_to_irq = pm8xxx_mpp_child_offset_to_irq;\n\tgirq->child_irq_domain_ops.translate = pm8xxx_mpp_domain_translate;\n\n\tret = gpiochip_add_data(&pctrl->chip, pctrl);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed register gpiochip\\n\");\n\t\treturn ret;\n\t}\n\n\tret = gpiochip_add_pin_range(&pctrl->chip,\n\t\t\t\t     dev_name(pctrl->dev),\n\t\t\t\t     0, 0, pctrl->chip.ngpio);\n\tif (ret) {\n\t\tdev_err(pctrl->dev, \"failed to add pin range\\n\");\n\t\tgoto unregister_gpiochip;\n\t}\n\n\tplatform_set_drvdata(pdev, pctrl);\n\n\tdev_dbg(&pdev->dev, \"Qualcomm pm8xxx mpp driver probed\\n\");\n\n\treturn 0;\n\nunregister_gpiochip:\n\tgpiochip_remove(&pctrl->chip);\n\n\treturn ret;\n}\n\nstatic int pm8xxx_mpp_remove(struct platform_device *pdev)\n{\n\tstruct pm8xxx_mpp *pctrl = platform_get_drvdata(pdev);\n\n\tgpiochip_remove(&pctrl->chip);\n\n\treturn 0;\n}\n\nstatic struct platform_driver pm8xxx_mpp_driver = {\n\t.driver = {\n\t\t.name = \"qcom-ssbi-mpp\",\n\t\t.of_match_table = pm8xxx_mpp_of_match,\n\t},\n\t.probe = pm8xxx_mpp_probe,\n\t.remove = pm8xxx_mpp_remove,\n};\n\nmodule_platform_driver(pm8xxx_mpp_driver);\n\nMODULE_AUTHOR(\"Bjorn Andersson <bjorn.andersson@sonymobile.com>\");\nMODULE_DESCRIPTION(\"Qualcomm PM8xxx MPP driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}