{
  "module_name": "pinctrl-lpass-lpi.c",
  "hash_id": "c12b9b7867ce6d4f73b42e0d71291ec0bef12f005c1d6832fc64232fa9a4865a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/qcom/pinctrl-lpass-lpi.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/gpio/driver.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/seq_file.h>\n\n#include <linux/pinctrl/pinconf-generic.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinmux.h>\n\n#include \"../pinctrl-utils.h\"\n\n#include \"pinctrl-lpass-lpi.h\"\n\n#define MAX_NR_GPIO\t\t23\n#define GPIO_FUNC\t\t0\n#define MAX_LPI_NUM_CLKS\t2\n\nstruct lpi_pinctrl {\n\tstruct device *dev;\n\tstruct pinctrl_dev *ctrl;\n\tstruct gpio_chip chip;\n\tstruct pinctrl_desc desc;\n\tchar __iomem *tlmm_base;\n\tchar __iomem *slew_base;\n\tstruct clk_bulk_data clks[MAX_LPI_NUM_CLKS];\n\t \n\tstruct mutex lock;\n\tDECLARE_BITMAP(ever_gpio, MAX_NR_GPIO);\n\tconst struct lpi_pinctrl_variant_data *data;\n};\n\nstatic int lpi_gpio_read(struct lpi_pinctrl *state, unsigned int pin,\n\t\t\t unsigned int addr)\n{\n\treturn ioread32(state->tlmm_base + LPI_TLMM_REG_OFFSET * pin + addr);\n}\n\nstatic int lpi_gpio_write(struct lpi_pinctrl *state, unsigned int pin,\n\t\t\t  unsigned int addr, unsigned int val)\n{\n\tiowrite32(val, state->tlmm_base + LPI_TLMM_REG_OFFSET * pin + addr);\n\n\treturn 0;\n}\n\nstatic const struct pinctrl_ops lpi_gpio_pinctrl_ops = {\n\t.get_groups_count\t= pinctrl_generic_get_group_count,\n\t.get_group_name\t\t= pinctrl_generic_get_group_name,\n\t.get_group_pins\t\t= pinctrl_generic_get_group_pins,\n\t.dt_node_to_map\t\t= pinconf_generic_dt_node_to_map_group,\n\t.dt_free_map\t\t= pinctrl_utils_free_map,\n};\n\nstatic int lpi_gpio_get_functions_count(struct pinctrl_dev *pctldev)\n{\n\tstruct lpi_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pctrl->data->nfunctions;\n}\n\nstatic const char *lpi_gpio_get_function_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t      unsigned int function)\n{\n\tstruct lpi_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pctrl->data->functions[function].name;\n}\n\nstatic int lpi_gpio_get_function_groups(struct pinctrl_dev *pctldev,\n\t\t\t\t\tunsigned int function,\n\t\t\t\t\tconst char *const **groups,\n\t\t\t\t\tunsigned *const num_qgroups)\n{\n\tstruct lpi_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\n\t*groups = pctrl->data->functions[function].groups;\n\t*num_qgroups = pctrl->data->functions[function].ngroups;\n\n\treturn 0;\n}\n\nstatic int lpi_gpio_set_mux(struct pinctrl_dev *pctldev, unsigned int function,\n\t\t\t    unsigned int group)\n{\n\tstruct lpi_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct lpi_pingroup *g = &pctrl->data->groups[group];\n\tu32 val;\n\tint i, pin = g->pin;\n\n\tfor (i = 0; i < g->nfuncs; i++) {\n\t\tif (g->funcs[i] == function)\n\t\t\tbreak;\n\t}\n\n\tif (WARN_ON(i == g->nfuncs))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&pctrl->lock);\n\tval = lpi_gpio_read(pctrl, pin, LPI_GPIO_CFG_REG);\n\n\t \n\tif (i == GPIO_FUNC && (val & LPI_GPIO_OE_MASK) &&\n\t    !test_and_set_bit(group, pctrl->ever_gpio)) {\n\t\tu32 io_val = lpi_gpio_read(pctrl, group, LPI_GPIO_VALUE_REG);\n\n\t\tif (io_val & LPI_GPIO_VALUE_IN_MASK) {\n\t\t\tif (!(io_val & LPI_GPIO_VALUE_OUT_MASK))\n\t\t\t\tlpi_gpio_write(pctrl, group, LPI_GPIO_VALUE_REG,\n\t\t\t\t\t       io_val | LPI_GPIO_VALUE_OUT_MASK);\n\t\t} else {\n\t\t\tif (io_val & LPI_GPIO_VALUE_OUT_MASK)\n\t\t\t\tlpi_gpio_write(pctrl, group, LPI_GPIO_VALUE_REG,\n\t\t\t\t\t       io_val & ~LPI_GPIO_VALUE_OUT_MASK);\n\t\t}\n\t}\n\n\tu32p_replace_bits(&val, i, LPI_GPIO_FUNCTION_MASK);\n\tlpi_gpio_write(pctrl, pin, LPI_GPIO_CFG_REG, val);\n\tmutex_unlock(&pctrl->lock);\n\n\treturn 0;\n}\n\nstatic const struct pinmux_ops lpi_gpio_pinmux_ops = {\n\t.get_functions_count\t= lpi_gpio_get_functions_count,\n\t.get_function_name\t= lpi_gpio_get_function_name,\n\t.get_function_groups\t= lpi_gpio_get_function_groups,\n\t.set_mux\t\t= lpi_gpio_set_mux,\n};\n\nstatic int lpi_config_get(struct pinctrl_dev *pctldev,\n\t\t\t  unsigned int pin, unsigned long *config)\n{\n\tunsigned int param = pinconf_to_config_param(*config);\n\tstruct lpi_pinctrl *state = dev_get_drvdata(pctldev->dev);\n\tunsigned int arg = 0;\n\tint is_out;\n\tint pull;\n\tu32 ctl_reg;\n\n\tctl_reg = lpi_gpio_read(state, pin, LPI_GPIO_CFG_REG);\n\tis_out = ctl_reg & LPI_GPIO_OE_MASK;\n\tpull = FIELD_GET(LPI_GPIO_PULL_MASK, ctl_reg);\n\n\tswitch (param) {\n\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\tif (pull == LPI_GPIO_BIAS_DISABLE)\n\t\t\targ = 1;\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\tif (pull == LPI_GPIO_PULL_DOWN)\n\t\t\targ = 1;\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_BUS_HOLD:\n\t\tif (pull == LPI_GPIO_KEEPER)\n\t\t\targ = 1;\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\tif (pull == LPI_GPIO_PULL_UP)\n\t\t\targ = 1;\n\t\tbreak;\n\tcase PIN_CONFIG_INPUT_ENABLE:\n\tcase PIN_CONFIG_OUTPUT:\n\t\tif (is_out)\n\t\t\targ = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t*config = pinconf_to_config_packed(param, arg);\n\treturn 0;\n}\n\nstatic int lpi_config_set(struct pinctrl_dev *pctldev, unsigned int group,\n\t\t\t  unsigned long *configs, unsigned int nconfs)\n{\n\tstruct lpi_pinctrl *pctrl = dev_get_drvdata(pctldev->dev);\n\tunsigned int param, arg, pullup = LPI_GPIO_BIAS_DISABLE, strength = 2;\n\tbool value, output_enabled = false;\n\tconst struct lpi_pingroup *g;\n\tunsigned long sval;\n\tint i, slew_offset;\n\tu32 val;\n\n\tg = &pctrl->data->groups[group];\n\tfor (i = 0; i < nconfs; i++) {\n\t\tparam = pinconf_to_config_param(configs[i]);\n\t\targ = pinconf_to_config_argument(configs[i]);\n\n\t\tswitch (param) {\n\t\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\t\tpullup = LPI_GPIO_BIAS_DISABLE;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\t\tpullup = LPI_GPIO_PULL_DOWN;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_BIAS_BUS_HOLD:\n\t\t\tpullup = LPI_GPIO_KEEPER;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\t\tpullup = LPI_GPIO_PULL_UP;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_INPUT_ENABLE:\n\t\t\toutput_enabled = false;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_OUTPUT:\n\t\t\toutput_enabled = true;\n\t\t\tvalue = arg;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_DRIVE_STRENGTH:\n\t\t\tstrength = arg;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_SLEW_RATE:\n\t\t\tif (arg > LPI_SLEW_RATE_MAX) {\n\t\t\t\tdev_err(pctldev->dev, \"invalid slew rate %u for pin: %d\\n\",\n\t\t\t\t\targ, group);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tslew_offset = g->slew_offset;\n\t\t\tif (slew_offset == LPI_NO_SLEW)\n\t\t\t\tbreak;\n\n\t\t\tmutex_lock(&pctrl->lock);\n\n\t\t\tsval = ioread32(pctrl->slew_base + LPI_SLEW_RATE_CTL_REG);\n\t\t\tsval &= ~(LPI_SLEW_RATE_MASK << slew_offset);\n\t\t\tsval |= arg << slew_offset;\n\t\t\tiowrite32(sval, pctrl->slew_base + LPI_SLEW_RATE_CTL_REG);\n\n\t\t\tmutex_unlock(&pctrl->lock);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tif (output_enabled) {\n\t\tval = u32_encode_bits(value ? 1 : 0, LPI_GPIO_VALUE_OUT_MASK);\n\t\tlpi_gpio_write(pctrl, group, LPI_GPIO_VALUE_REG, val);\n\t}\n\n\tmutex_lock(&pctrl->lock);\n\tval = lpi_gpio_read(pctrl, group, LPI_GPIO_CFG_REG);\n\n\tu32p_replace_bits(&val, pullup, LPI_GPIO_PULL_MASK);\n\tu32p_replace_bits(&val, LPI_GPIO_DS_TO_VAL(strength),\n\t\t\t  LPI_GPIO_OUT_STRENGTH_MASK);\n\tu32p_replace_bits(&val, output_enabled, LPI_GPIO_OE_MASK);\n\n\tlpi_gpio_write(pctrl, group, LPI_GPIO_CFG_REG, val);\n\tmutex_unlock(&pctrl->lock);\n\n\treturn 0;\n}\n\nstatic const struct pinconf_ops lpi_gpio_pinconf_ops = {\n\t.is_generic\t\t\t= true,\n\t.pin_config_group_get\t\t= lpi_config_get,\n\t.pin_config_group_set\t\t= lpi_config_set,\n};\n\nstatic int lpi_gpio_direction_input(struct gpio_chip *chip, unsigned int pin)\n{\n\tstruct lpi_pinctrl *state = gpiochip_get_data(chip);\n\tunsigned long config;\n\n\tconfig = pinconf_to_config_packed(PIN_CONFIG_INPUT_ENABLE, 1);\n\n\treturn lpi_config_set(state->ctrl, pin, &config, 1);\n}\n\nstatic int lpi_gpio_direction_output(struct gpio_chip *chip,\n\t\t\t\t     unsigned int pin, int val)\n{\n\tstruct lpi_pinctrl *state = gpiochip_get_data(chip);\n\tunsigned long config;\n\n\tconfig = pinconf_to_config_packed(PIN_CONFIG_OUTPUT, val);\n\n\treturn lpi_config_set(state->ctrl, pin, &config, 1);\n}\n\nstatic int lpi_gpio_get(struct gpio_chip *chip, unsigned int pin)\n{\n\tstruct lpi_pinctrl *state = gpiochip_get_data(chip);\n\n\treturn lpi_gpio_read(state, pin, LPI_GPIO_VALUE_REG) &\n\t\tLPI_GPIO_VALUE_IN_MASK;\n}\n\nstatic void lpi_gpio_set(struct gpio_chip *chip, unsigned int pin, int value)\n{\n\tstruct lpi_pinctrl *state = gpiochip_get_data(chip);\n\tunsigned long config;\n\n\tconfig = pinconf_to_config_packed(PIN_CONFIG_OUTPUT, value);\n\n\tlpi_config_set(state->ctrl, pin, &config, 1);\n}\n\n#ifdef CONFIG_DEBUG_FS\n#include <linux/seq_file.h>\n\nstatic unsigned int lpi_regval_to_drive(u32 val)\n{\n\treturn (val + 1) * 2;\n}\n\nstatic void lpi_gpio_dbg_show_one(struct seq_file *s,\n\t\t\t\t  struct pinctrl_dev *pctldev,\n\t\t\t\t  struct gpio_chip *chip,\n\t\t\t\t  unsigned int offset,\n\t\t\t\t  unsigned int gpio)\n{\n\tstruct lpi_pinctrl *state = gpiochip_get_data(chip);\n\tstruct pinctrl_pin_desc pindesc;\n\tunsigned int func;\n\tint is_out;\n\tint drive;\n\tint pull;\n\tu32 ctl_reg;\n\n\tstatic const char * const pulls[] = {\n\t\t\"no pull\",\n\t\t\"pull down\",\n\t\t\"keeper\",\n\t\t\"pull up\"\n\t};\n\n\tpctldev = pctldev ? : state->ctrl;\n\tpindesc = pctldev->desc->pins[offset];\n\tctl_reg = lpi_gpio_read(state, offset, LPI_GPIO_CFG_REG);\n\tis_out = ctl_reg & LPI_GPIO_OE_MASK;\n\n\tfunc = FIELD_GET(LPI_GPIO_FUNCTION_MASK, ctl_reg);\n\tdrive = FIELD_GET(LPI_GPIO_OUT_STRENGTH_MASK, ctl_reg);\n\tpull = FIELD_GET(LPI_GPIO_PULL_MASK, ctl_reg);\n\n\tseq_printf(s, \" %-8s: %-3s %d\", pindesc.name, is_out ? \"out\" : \"in\", func);\n\tseq_printf(s, \" %dmA\", lpi_regval_to_drive(drive));\n\tseq_printf(s, \" %s\", pulls[pull]);\n}\n\nstatic void lpi_gpio_dbg_show(struct seq_file *s, struct gpio_chip *chip)\n{\n\tunsigned int gpio = chip->base;\n\tunsigned int i;\n\n\tfor (i = 0; i < chip->ngpio; i++, gpio++) {\n\t\tlpi_gpio_dbg_show_one(s, NULL, chip, i, gpio);\n\t\tseq_puts(s, \"\\n\");\n\t}\n}\n\n#else\n#define lpi_gpio_dbg_show NULL\n#endif\n\nstatic const struct gpio_chip lpi_gpio_template = {\n\t.direction_input\t= lpi_gpio_direction_input,\n\t.direction_output\t= lpi_gpio_direction_output,\n\t.get\t\t\t= lpi_gpio_get,\n\t.set\t\t\t= lpi_gpio_set,\n\t.request\t\t= gpiochip_generic_request,\n\t.free\t\t\t= gpiochip_generic_free,\n\t.dbg_show\t\t= lpi_gpio_dbg_show,\n};\n\nstatic int lpi_build_pin_desc_groups(struct lpi_pinctrl *pctrl)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < pctrl->data->npins; i++) {\n\t\tconst struct pinctrl_pin_desc *pin_info = pctrl->desc.pins + i;\n\n\t\tret = pinctrl_generic_add_group(pctrl->ctrl, pin_info->name,\n\t\t\t\t\t\t  (int *)&pin_info->number, 1, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto err_pinctrl;\n\t}\n\n\treturn 0;\n\nerr_pinctrl:\n\tfor (; i > 0; i--)\n\t\tpinctrl_generic_remove_group(pctrl->ctrl, i - 1);\n\n\treturn ret;\n}\n\nint lpi_pinctrl_probe(struct platform_device *pdev)\n{\n\tconst struct lpi_pinctrl_variant_data *data;\n\tstruct device *dev = &pdev->dev;\n\tstruct lpi_pinctrl *pctrl;\n\tint ret;\n\n\tpctrl = devm_kzalloc(dev, sizeof(*pctrl), GFP_KERNEL);\n\tif (!pctrl)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, pctrl);\n\n\tdata = of_device_get_match_data(dev);\n\tif (!data)\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(data->npins > MAX_NR_GPIO))\n\t\treturn -EINVAL;\n\n\tpctrl->data = data;\n\tpctrl->dev = &pdev->dev;\n\n\tpctrl->clks[0].id = \"core\";\n\tpctrl->clks[1].id = \"audio\";\n\n\tpctrl->tlmm_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(pctrl->tlmm_base))\n\t\treturn dev_err_probe(dev, PTR_ERR(pctrl->tlmm_base),\n\t\t\t\t     \"TLMM resource not provided\\n\");\n\n\tpctrl->slew_base = devm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(pctrl->slew_base))\n\t\treturn dev_err_probe(dev, PTR_ERR(pctrl->slew_base),\n\t\t\t\t     \"Slew resource not provided\\n\");\n\n\tret = devm_clk_bulk_get_optional(dev, MAX_LPI_NUM_CLKS, pctrl->clks);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_bulk_prepare_enable(MAX_LPI_NUM_CLKS, pctrl->clks);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Can't enable clocks\\n\");\n\n\tpctrl->desc.pctlops = &lpi_gpio_pinctrl_ops;\n\tpctrl->desc.pmxops = &lpi_gpio_pinmux_ops;\n\tpctrl->desc.confops = &lpi_gpio_pinconf_ops;\n\tpctrl->desc.owner = THIS_MODULE;\n\tpctrl->desc.name = dev_name(dev);\n\tpctrl->desc.pins = data->pins;\n\tpctrl->desc.npins = data->npins;\n\tpctrl->chip = lpi_gpio_template;\n\tpctrl->chip.parent = dev;\n\tpctrl->chip.base = -1;\n\tpctrl->chip.ngpio = data->npins;\n\tpctrl->chip.label = dev_name(dev);\n\tpctrl->chip.can_sleep = false;\n\n\tmutex_init(&pctrl->lock);\n\n\tpctrl->ctrl = devm_pinctrl_register(dev, &pctrl->desc, pctrl);\n\tif (IS_ERR(pctrl->ctrl)) {\n\t\tret = PTR_ERR(pctrl->ctrl);\n\t\tdev_err(dev, \"failed to add pin controller\\n\");\n\t\tgoto err_pinctrl;\n\t}\n\n\tret = lpi_build_pin_desc_groups(pctrl);\n\tif (ret)\n\t\tgoto err_pinctrl;\n\n\tret = devm_gpiochip_add_data(dev, &pctrl->chip, pctrl);\n\tif (ret) {\n\t\tdev_err(pctrl->dev, \"can't add gpio chip\\n\");\n\t\tgoto err_pinctrl;\n\t}\n\n\treturn 0;\n\nerr_pinctrl:\n\tmutex_destroy(&pctrl->lock);\n\tclk_bulk_disable_unprepare(MAX_LPI_NUM_CLKS, pctrl->clks);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(lpi_pinctrl_probe);\n\nint lpi_pinctrl_remove(struct platform_device *pdev)\n{\n\tstruct lpi_pinctrl *pctrl = platform_get_drvdata(pdev);\n\tint i;\n\n\tmutex_destroy(&pctrl->lock);\n\tclk_bulk_disable_unprepare(MAX_LPI_NUM_CLKS, pctrl->clks);\n\n\tfor (i = 0; i < pctrl->data->npins; i++)\n\t\tpinctrl_generic_remove_group(pctrl->ctrl, i);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(lpi_pinctrl_remove);\n\nMODULE_DESCRIPTION(\"QTI LPI GPIO pin control driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}