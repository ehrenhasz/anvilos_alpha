{
  "module_name": "pinctrl-msm.c",
  "hash_id": "aef293f689a55005c3811b0f820449ac7167caae9fab2a10d643a340371adf3d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/qcom/pinctrl-msm.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/gpio/driver.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/log2.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/firmware/qcom/qcom_scm.h>\n#include <linux/reboot.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\n#include <linux/pinctrl/machine.h>\n#include <linux/pinctrl/pinconf-generic.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinmux.h>\n\n#include <linux/soc/qcom/irq.h>\n\n#include \"../core.h\"\n#include \"../pinconf.h\"\n#include \"../pinctrl-utils.h\"\n\n#include \"pinctrl-msm.h\"\n\n#define MAX_NR_GPIO 300\n#define MAX_NR_TILES 4\n#define PS_HOLD_OFFSET 0x820\n\n \nstruct msm_pinctrl {\n\tstruct device *dev;\n\tstruct pinctrl_dev *pctrl;\n\tstruct gpio_chip chip;\n\tstruct pinctrl_desc desc;\n\tstruct notifier_block restart_nb;\n\n\tint irq;\n\n\tbool intr_target_use_scm;\n\n\traw_spinlock_t lock;\n\n\tDECLARE_BITMAP(dual_edge_irqs, MAX_NR_GPIO);\n\tDECLARE_BITMAP(enabled_irqs, MAX_NR_GPIO);\n\tDECLARE_BITMAP(skip_wake_irqs, MAX_NR_GPIO);\n\tDECLARE_BITMAP(disabled_for_mux, MAX_NR_GPIO);\n\tDECLARE_BITMAP(ever_gpio, MAX_NR_GPIO);\n\n\tconst struct msm_pinctrl_soc_data *soc;\n\tvoid __iomem *regs[MAX_NR_TILES];\n\tu32 phys_base[MAX_NR_TILES];\n};\n\n#define MSM_ACCESSOR(name) \\\nstatic u32 msm_readl_##name(struct msm_pinctrl *pctrl, \\\n\t\t\t    const struct msm_pingroup *g) \\\n{ \\\n\treturn readl(pctrl->regs[g->tile] + g->name##_reg); \\\n} \\\nstatic void msm_writel_##name(u32 val, struct msm_pinctrl *pctrl, \\\n\t\t\t      const struct msm_pingroup *g) \\\n{ \\\n\twritel(val, pctrl->regs[g->tile] + g->name##_reg); \\\n}\n\nMSM_ACCESSOR(ctl)\nMSM_ACCESSOR(io)\nMSM_ACCESSOR(intr_cfg)\nMSM_ACCESSOR(intr_status)\nMSM_ACCESSOR(intr_target)\n\nstatic void msm_ack_intr_status(struct msm_pinctrl *pctrl,\n\t\t\t\tconst struct msm_pingroup *g)\n{\n\tu32 val = g->intr_ack_high ? BIT(g->intr_status_bit) : 0;\n\n\tmsm_writel_intr_status(val, pctrl, g);\n}\n\nstatic int msm_get_groups_count(struct pinctrl_dev *pctldev)\n{\n\tstruct msm_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pctrl->soc->ngroups;\n}\n\nstatic const char *msm_get_group_name(struct pinctrl_dev *pctldev,\n\t\t\t\t      unsigned group)\n{\n\tstruct msm_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pctrl->soc->groups[group].grp.name;\n}\n\nstatic int msm_get_group_pins(struct pinctrl_dev *pctldev,\n\t\t\t      unsigned group,\n\t\t\t      const unsigned **pins,\n\t\t\t      unsigned *num_pins)\n{\n\tstruct msm_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\n\t*pins = pctrl->soc->groups[group].grp.pins;\n\t*num_pins = pctrl->soc->groups[group].grp.npins;\n\treturn 0;\n}\n\nstatic const struct pinctrl_ops msm_pinctrl_ops = {\n\t.get_groups_count\t= msm_get_groups_count,\n\t.get_group_name\t\t= msm_get_group_name,\n\t.get_group_pins\t\t= msm_get_group_pins,\n\t.dt_node_to_map\t\t= pinconf_generic_dt_node_to_map_group,\n\t.dt_free_map\t\t= pinctrl_utils_free_map,\n};\n\nstatic int msm_pinmux_request(struct pinctrl_dev *pctldev, unsigned offset)\n{\n\tstruct msm_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct gpio_chip *chip = &pctrl->chip;\n\n\treturn gpiochip_line_is_valid(chip, offset) ? 0 : -EINVAL;\n}\n\nstatic int msm_get_functions_count(struct pinctrl_dev *pctldev)\n{\n\tstruct msm_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pctrl->soc->nfunctions;\n}\n\nstatic const char *msm_get_function_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t unsigned function)\n{\n\tstruct msm_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pctrl->soc->functions[function].name;\n}\n\nstatic int msm_get_function_groups(struct pinctrl_dev *pctldev,\n\t\t\t\t   unsigned function,\n\t\t\t\t   const char * const **groups,\n\t\t\t\t   unsigned * const num_groups)\n{\n\tstruct msm_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\n\t*groups = pctrl->soc->functions[function].groups;\n\t*num_groups = pctrl->soc->functions[function].ngroups;\n\treturn 0;\n}\n\nstatic int msm_pinmux_set_mux(struct pinctrl_dev *pctldev,\n\t\t\t      unsigned function,\n\t\t\t      unsigned group)\n{\n\tstruct msm_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct gpio_chip *gc = &pctrl->chip;\n\tunsigned int irq = irq_find_mapping(gc->irq.domain, group);\n\tstruct irq_data *d = irq_get_irq_data(irq);\n\tunsigned int gpio_func = pctrl->soc->gpio_func;\n\tunsigned int egpio_func = pctrl->soc->egpio_func;\n\tconst struct msm_pingroup *g;\n\tunsigned long flags;\n\tu32 val, mask;\n\tint i;\n\n\tg = &pctrl->soc->groups[group];\n\tmask = GENMASK(g->mux_bit + order_base_2(g->nfuncs) - 1, g->mux_bit);\n\n\tfor (i = 0; i < g->nfuncs; i++) {\n\t\tif (g->funcs[i] == function)\n\t\t\tbreak;\n\t}\n\n\tif (WARN_ON(i == g->nfuncs))\n\t\treturn -EINVAL;\n\n\t \n\tif (d && i != gpio_func &&\n\t    !test_and_set_bit(d->hwirq, pctrl->disabled_for_mux))\n\t\tdisable_irq(irq);\n\n\traw_spin_lock_irqsave(&pctrl->lock, flags);\n\n\tval = msm_readl_ctl(pctrl, g);\n\n\t \n\tif (i == gpio_func && (val & BIT(g->oe_bit)) &&\n\t    !test_and_set_bit(group, pctrl->ever_gpio)) {\n\t\tu32 io_val = msm_readl_io(pctrl, g);\n\n\t\tif (io_val & BIT(g->in_bit)) {\n\t\t\tif (!(io_val & BIT(g->out_bit)))\n\t\t\t\tmsm_writel_io(io_val | BIT(g->out_bit), pctrl, g);\n\t\t} else {\n\t\t\tif (io_val & BIT(g->out_bit))\n\t\t\t\tmsm_writel_io(io_val & ~BIT(g->out_bit), pctrl, g);\n\t\t}\n\t}\n\n\tif (egpio_func && i == egpio_func) {\n\t\tif (val & BIT(g->egpio_present))\n\t\t\tval &= ~BIT(g->egpio_enable);\n\t} else {\n\t\tval &= ~mask;\n\t\tval |= i << g->mux_bit;\n\t\t \n\t\tif (egpio_func && val & BIT(g->egpio_present))\n\t\t\tval |= BIT(g->egpio_enable);\n\t}\n\n\tmsm_writel_ctl(val, pctrl, g);\n\n\traw_spin_unlock_irqrestore(&pctrl->lock, flags);\n\n\tif (d && i == gpio_func &&\n\t    test_and_clear_bit(d->hwirq, pctrl->disabled_for_mux)) {\n\t\t \n\t\tif (d->parent_data && test_bit(d->hwirq, pctrl->skip_wake_irqs))\n\t\t\tirq_chip_set_parent_state(d, IRQCHIP_STATE_PENDING, false);\n\t\telse\n\t\t\tmsm_ack_intr_status(pctrl, g);\n\n\t\tenable_irq(irq);\n\t}\n\n\treturn 0;\n}\n\nstatic int msm_pinmux_request_gpio(struct pinctrl_dev *pctldev,\n\t\t\t\t   struct pinctrl_gpio_range *range,\n\t\t\t\t   unsigned offset)\n{\n\tstruct msm_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct msm_pingroup *g = &pctrl->soc->groups[offset];\n\n\t \n\tif (!g->nfuncs)\n\t\treturn 0;\n\n\treturn msm_pinmux_set_mux(pctldev, g->funcs[pctrl->soc->gpio_func], offset);\n}\n\nstatic const struct pinmux_ops msm_pinmux_ops = {\n\t.request\t\t= msm_pinmux_request,\n\t.get_functions_count\t= msm_get_functions_count,\n\t.get_function_name\t= msm_get_function_name,\n\t.get_function_groups\t= msm_get_function_groups,\n\t.gpio_request_enable\t= msm_pinmux_request_gpio,\n\t.set_mux\t\t= msm_pinmux_set_mux,\n};\n\nstatic int msm_config_reg(struct msm_pinctrl *pctrl,\n\t\t\t  const struct msm_pingroup *g,\n\t\t\t  unsigned param,\n\t\t\t  unsigned *mask,\n\t\t\t  unsigned *bit)\n{\n\tswitch (param) {\n\tcase PIN_CONFIG_BIAS_DISABLE:\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\tcase PIN_CONFIG_BIAS_BUS_HOLD:\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\t*bit = g->pull_bit;\n\t\t*mask = 3;\n\t\tif (g->i2c_pull_bit)\n\t\t\t*mask |= BIT(g->i2c_pull_bit) >> *bit;\n\t\tbreak;\n\tcase PIN_CONFIG_DRIVE_OPEN_DRAIN:\n\t\t*bit = g->od_bit;\n\t\t*mask = 1;\n\t\tbreak;\n\tcase PIN_CONFIG_DRIVE_STRENGTH:\n\t\t*bit = g->drv_bit;\n\t\t*mask = 7;\n\t\tbreak;\n\tcase PIN_CONFIG_OUTPUT:\n\tcase PIN_CONFIG_INPUT_ENABLE:\n\tcase PIN_CONFIG_OUTPUT_ENABLE:\n\t\t*bit = g->oe_bit;\n\t\t*mask = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn 0;\n}\n\n#define MSM_NO_PULL\t\t0\n#define MSM_PULL_DOWN\t\t1\n#define MSM_KEEPER\t\t2\n#define MSM_PULL_UP_NO_KEEPER\t2\n#define MSM_PULL_UP\t\t3\n#define MSM_I2C_STRONG_PULL_UP\t2200\n\nstatic unsigned msm_regval_to_drive(u32 val)\n{\n\treturn (val + 1) * 2;\n}\n\nstatic int msm_config_group_get(struct pinctrl_dev *pctldev,\n\t\t\t\tunsigned int group,\n\t\t\t\tunsigned long *config)\n{\n\tconst struct msm_pingroup *g;\n\tstruct msm_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\tunsigned param = pinconf_to_config_param(*config);\n\tunsigned mask;\n\tunsigned arg;\n\tunsigned bit;\n\tint ret;\n\tu32 val;\n\n\tg = &pctrl->soc->groups[group];\n\n\tret = msm_config_reg(pctrl, g, param, &mask, &bit);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tval = msm_readl_ctl(pctrl, g);\n\targ = (val >> bit) & mask;\n\n\t \n\tswitch (param) {\n\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\tif (arg != MSM_NO_PULL)\n\t\t\treturn -EINVAL;\n\t\targ = 1;\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\tif (arg != MSM_PULL_DOWN)\n\t\t\treturn -EINVAL;\n\t\targ = 1;\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_BUS_HOLD:\n\t\tif (pctrl->soc->pull_no_keeper)\n\t\t\treturn -ENOTSUPP;\n\n\t\tif (arg != MSM_KEEPER)\n\t\t\treturn -EINVAL;\n\t\targ = 1;\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\tif (pctrl->soc->pull_no_keeper)\n\t\t\targ = arg == MSM_PULL_UP_NO_KEEPER;\n\t\telse if (arg & BIT(g->i2c_pull_bit))\n\t\t\targ = MSM_I2C_STRONG_PULL_UP;\n\t\telse\n\t\t\targ = arg == MSM_PULL_UP;\n\t\tif (!arg)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase PIN_CONFIG_DRIVE_OPEN_DRAIN:\n\t\t \n\t\tif (!arg)\n\t\t\treturn -EINVAL;\n\t\targ = 1;\n\t\tbreak;\n\tcase PIN_CONFIG_DRIVE_STRENGTH:\n\t\targ = msm_regval_to_drive(arg);\n\t\tbreak;\n\tcase PIN_CONFIG_OUTPUT:\n\t\t \n\t\tif (!arg)\n\t\t\treturn -EINVAL;\n\n\t\tval = msm_readl_io(pctrl, g);\n\t\targ = !!(val & BIT(g->in_bit));\n\t\tbreak;\n\tcase PIN_CONFIG_OUTPUT_ENABLE:\n\t\tif (!arg)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\t*config = pinconf_to_config_packed(param, arg);\n\n\treturn 0;\n}\n\nstatic int msm_config_group_set(struct pinctrl_dev *pctldev,\n\t\t\t\tunsigned group,\n\t\t\t\tunsigned long *configs,\n\t\t\t\tunsigned num_configs)\n{\n\tconst struct msm_pingroup *g;\n\tstruct msm_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\tunsigned long flags;\n\tunsigned param;\n\tunsigned mask;\n\tunsigned arg;\n\tunsigned bit;\n\tint ret;\n\tu32 val;\n\tint i;\n\n\tg = &pctrl->soc->groups[group];\n\n\tfor (i = 0; i < num_configs; i++) {\n\t\tparam = pinconf_to_config_param(configs[i]);\n\t\targ = pinconf_to_config_argument(configs[i]);\n\n\t\tret = msm_config_reg(pctrl, g, param, &mask, &bit);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tswitch (param) {\n\t\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\t\targ = MSM_NO_PULL;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\t\targ = MSM_PULL_DOWN;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_BIAS_BUS_HOLD:\n\t\t\tif (pctrl->soc->pull_no_keeper)\n\t\t\t\treturn -ENOTSUPP;\n\n\t\t\targ = MSM_KEEPER;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\t\tif (pctrl->soc->pull_no_keeper)\n\t\t\t\targ = MSM_PULL_UP_NO_KEEPER;\n\t\t\telse if (g->i2c_pull_bit && arg == MSM_I2C_STRONG_PULL_UP)\n\t\t\t\targ = BIT(g->i2c_pull_bit) | MSM_PULL_UP;\n\t\t\telse\n\t\t\t\targ = MSM_PULL_UP;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_DRIVE_OPEN_DRAIN:\n\t\t\targ = 1;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_DRIVE_STRENGTH:\n\t\t\t \n\t\t\tif (arg > 16 || arg < 2 || (arg % 2) != 0)\n\t\t\t\targ = -1;\n\t\t\telse\n\t\t\t\targ = (arg / 2) - 1;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_OUTPUT:\n\t\t\t \n\t\t\traw_spin_lock_irqsave(&pctrl->lock, flags);\n\t\t\tval = msm_readl_io(pctrl, g);\n\t\t\tif (arg)\n\t\t\t\tval |= BIT(g->out_bit);\n\t\t\telse\n\t\t\t\tval &= ~BIT(g->out_bit);\n\t\t\tmsm_writel_io(val, pctrl, g);\n\t\t\traw_spin_unlock_irqrestore(&pctrl->lock, flags);\n\n\t\t\t \n\t\t\targ = 1;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_INPUT_ENABLE:\n\t\t\t \n\t\t\targ = 0;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_OUTPUT_ENABLE:\n\t\t\targ = !!arg;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(pctrl->dev, \"Unsupported config parameter: %x\\n\",\n\t\t\t\tparam);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (arg & ~mask) {\n\t\t\tdev_err(pctrl->dev, \"config %x: %x is invalid\\n\", param, arg);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\traw_spin_lock_irqsave(&pctrl->lock, flags);\n\t\tval = msm_readl_ctl(pctrl, g);\n\t\tval &= ~(mask << bit);\n\t\tval |= arg << bit;\n\t\tmsm_writel_ctl(val, pctrl, g);\n\t\traw_spin_unlock_irqrestore(&pctrl->lock, flags);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct pinconf_ops msm_pinconf_ops = {\n\t.is_generic\t\t= true,\n\t.pin_config_group_get\t= msm_config_group_get,\n\t.pin_config_group_set\t= msm_config_group_set,\n};\n\nstatic int msm_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\n{\n\tconst struct msm_pingroup *g;\n\tstruct msm_pinctrl *pctrl = gpiochip_get_data(chip);\n\tunsigned long flags;\n\tu32 val;\n\n\tg = &pctrl->soc->groups[offset];\n\n\traw_spin_lock_irqsave(&pctrl->lock, flags);\n\n\tval = msm_readl_ctl(pctrl, g);\n\tval &= ~BIT(g->oe_bit);\n\tmsm_writel_ctl(val, pctrl, g);\n\n\traw_spin_unlock_irqrestore(&pctrl->lock, flags);\n\n\treturn 0;\n}\n\nstatic int msm_gpio_direction_output(struct gpio_chip *chip, unsigned offset, int value)\n{\n\tconst struct msm_pingroup *g;\n\tstruct msm_pinctrl *pctrl = gpiochip_get_data(chip);\n\tunsigned long flags;\n\tu32 val;\n\n\tg = &pctrl->soc->groups[offset];\n\n\traw_spin_lock_irqsave(&pctrl->lock, flags);\n\n\tval = msm_readl_io(pctrl, g);\n\tif (value)\n\t\tval |= BIT(g->out_bit);\n\telse\n\t\tval &= ~BIT(g->out_bit);\n\tmsm_writel_io(val, pctrl, g);\n\n\tval = msm_readl_ctl(pctrl, g);\n\tval |= BIT(g->oe_bit);\n\tmsm_writel_ctl(val, pctrl, g);\n\n\traw_spin_unlock_irqrestore(&pctrl->lock, flags);\n\n\treturn 0;\n}\n\nstatic int msm_gpio_get_direction(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct msm_pinctrl *pctrl = gpiochip_get_data(chip);\n\tconst struct msm_pingroup *g;\n\tu32 val;\n\n\tg = &pctrl->soc->groups[offset];\n\n\tval = msm_readl_ctl(pctrl, g);\n\n\treturn val & BIT(g->oe_bit) ? GPIO_LINE_DIRECTION_OUT :\n\t\t\t\t      GPIO_LINE_DIRECTION_IN;\n}\n\nstatic int msm_gpio_get(struct gpio_chip *chip, unsigned offset)\n{\n\tconst struct msm_pingroup *g;\n\tstruct msm_pinctrl *pctrl = gpiochip_get_data(chip);\n\tu32 val;\n\n\tg = &pctrl->soc->groups[offset];\n\n\tval = msm_readl_io(pctrl, g);\n\treturn !!(val & BIT(g->in_bit));\n}\n\nstatic void msm_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\n{\n\tconst struct msm_pingroup *g;\n\tstruct msm_pinctrl *pctrl = gpiochip_get_data(chip);\n\tunsigned long flags;\n\tu32 val;\n\n\tg = &pctrl->soc->groups[offset];\n\n\traw_spin_lock_irqsave(&pctrl->lock, flags);\n\n\tval = msm_readl_io(pctrl, g);\n\tif (value)\n\t\tval |= BIT(g->out_bit);\n\telse\n\t\tval &= ~BIT(g->out_bit);\n\tmsm_writel_io(val, pctrl, g);\n\n\traw_spin_unlock_irqrestore(&pctrl->lock, flags);\n}\n\n#ifdef CONFIG_DEBUG_FS\n\nstatic void msm_gpio_dbg_show_one(struct seq_file *s,\n\t\t\t\t  struct pinctrl_dev *pctldev,\n\t\t\t\t  struct gpio_chip *chip,\n\t\t\t\t  unsigned offset,\n\t\t\t\t  unsigned gpio)\n{\n\tconst struct msm_pingroup *g;\n\tstruct msm_pinctrl *pctrl = gpiochip_get_data(chip);\n\tunsigned func;\n\tint is_out;\n\tint drive;\n\tint pull;\n\tint val;\n\tint egpio_enable;\n\tu32 ctl_reg, io_reg;\n\n\tstatic const char * const pulls_keeper[] = {\n\t\t\"no pull\",\n\t\t\"pull down\",\n\t\t\"keeper\",\n\t\t\"pull up\"\n\t};\n\n\tstatic const char * const pulls_no_keeper[] = {\n\t\t\"no pull\",\n\t\t\"pull down\",\n\t\t\"pull up\",\n\t};\n\n\tif (!gpiochip_line_is_valid(chip, offset))\n\t\treturn;\n\n\tg = &pctrl->soc->groups[offset];\n\tctl_reg = msm_readl_ctl(pctrl, g);\n\tio_reg = msm_readl_io(pctrl, g);\n\n\tis_out = !!(ctl_reg & BIT(g->oe_bit));\n\tfunc = (ctl_reg >> g->mux_bit) & 7;\n\tdrive = (ctl_reg >> g->drv_bit) & 7;\n\tpull = (ctl_reg >> g->pull_bit) & 3;\n\tegpio_enable = 0;\n\tif (pctrl->soc->egpio_func && ctl_reg & BIT(g->egpio_present))\n\t\tegpio_enable = !(ctl_reg & BIT(g->egpio_enable));\n\n\tif (is_out)\n\t\tval = !!(io_reg & BIT(g->out_bit));\n\telse\n\t\tval = !!(io_reg & BIT(g->in_bit));\n\n\tif (egpio_enable) {\n\t\tseq_printf(s, \" %-8s: egpio\\n\", g->grp.name);\n\t\treturn;\n\t}\n\n\tseq_printf(s, \" %-8s: %-3s\", g->grp.name, is_out ? \"out\" : \"in\");\n\tseq_printf(s, \" %-4s func%d\", val ? \"high\" : \"low\", func);\n\tseq_printf(s, \" %dmA\", msm_regval_to_drive(drive));\n\tif (pctrl->soc->pull_no_keeper)\n\t\tseq_printf(s, \" %s\", pulls_no_keeper[pull]);\n\telse\n\t\tseq_printf(s, \" %s\", pulls_keeper[pull]);\n\tseq_puts(s, \"\\n\");\n}\n\nstatic void msm_gpio_dbg_show(struct seq_file *s, struct gpio_chip *chip)\n{\n\tunsigned gpio = chip->base;\n\tunsigned i;\n\n\tfor (i = 0; i < chip->ngpio; i++, gpio++)\n\t\tmsm_gpio_dbg_show_one(s, NULL, chip, i, gpio);\n}\n\n#else\n#define msm_gpio_dbg_show NULL\n#endif\n\nstatic int msm_gpio_init_valid_mask(struct gpio_chip *gc,\n\t\t\t\t    unsigned long *valid_mask,\n\t\t\t\t    unsigned int ngpios)\n{\n\tstruct msm_pinctrl *pctrl = gpiochip_get_data(gc);\n\tint ret;\n\tunsigned int len, i;\n\tconst int *reserved = pctrl->soc->reserved_gpios;\n\tu16 *tmp;\n\n\t \n\tif (reserved) {\n\t\tfor (i = 0; reserved[i] >= 0; i++) {\n\t\t\tif (i >= ngpios || reserved[i] >= ngpios) {\n\t\t\t\tdev_err(pctrl->dev, \"invalid list of reserved GPIOs\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tclear_bit(reserved[i], valid_mask);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t \n\tlen = ret = device_property_count_u16(pctrl->dev, \"gpios\");\n\tif (ret < 0)\n\t\treturn 0;\n\n\tif (ret > ngpios)\n\t\treturn -EINVAL;\n\n\ttmp = kmalloc_array(len, sizeof(*tmp), GFP_KERNEL);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\tret = device_property_read_u16_array(pctrl->dev, \"gpios\", tmp, len);\n\tif (ret < 0) {\n\t\tdev_err(pctrl->dev, \"could not read list of GPIOs\\n\");\n\t\tgoto out;\n\t}\n\n\tbitmap_zero(valid_mask, ngpios);\n\tfor (i = 0; i < len; i++)\n\t\tset_bit(tmp[i], valid_mask);\n\nout:\n\tkfree(tmp);\n\treturn ret;\n}\n\nstatic const struct gpio_chip msm_gpio_template = {\n\t.direction_input  = msm_gpio_direction_input,\n\t.direction_output = msm_gpio_direction_output,\n\t.get_direction    = msm_gpio_get_direction,\n\t.get              = msm_gpio_get,\n\t.set              = msm_gpio_set,\n\t.request          = gpiochip_generic_request,\n\t.free             = gpiochip_generic_free,\n\t.dbg_show         = msm_gpio_dbg_show,\n};\n\n \nstatic void msm_gpio_update_dual_edge_pos(struct msm_pinctrl *pctrl,\n\t\t\t\t\t  const struct msm_pingroup *g,\n\t\t\t\t\t  struct irq_data *d)\n{\n\tint loop_limit = 100;\n\tunsigned val, val2, intstat;\n\tunsigned pol;\n\n\tdo {\n\t\tval = msm_readl_io(pctrl, g) & BIT(g->in_bit);\n\n\t\tpol = msm_readl_intr_cfg(pctrl, g);\n\t\tpol ^= BIT(g->intr_polarity_bit);\n\t\tmsm_writel_intr_cfg(pol, pctrl, g);\n\n\t\tval2 = msm_readl_io(pctrl, g) & BIT(g->in_bit);\n\t\tintstat = msm_readl_intr_status(pctrl, g);\n\t\tif (intstat || (val == val2))\n\t\t\treturn;\n\t} while (loop_limit-- > 0);\n\tdev_err(pctrl->dev, \"dual-edge irq failed to stabilize, %#08x != %#08x\\n\",\n\t\tval, val2);\n}\n\nstatic void msm_gpio_irq_mask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct msm_pinctrl *pctrl = gpiochip_get_data(gc);\n\tconst struct msm_pingroup *g;\n\tunsigned long flags;\n\tu32 val;\n\n\tif (d->parent_data)\n\t\tirq_chip_mask_parent(d);\n\n\tif (test_bit(d->hwirq, pctrl->skip_wake_irqs))\n\t\treturn;\n\n\tg = &pctrl->soc->groups[d->hwirq];\n\n\traw_spin_lock_irqsave(&pctrl->lock, flags);\n\n\tval = msm_readl_intr_cfg(pctrl, g);\n\t \n\tif (irqd_get_trigger_type(d) & IRQ_TYPE_LEVEL_MASK)\n\t\tval &= ~BIT(g->intr_raw_status_bit);\n\n\tval &= ~BIT(g->intr_enable_bit);\n\tmsm_writel_intr_cfg(val, pctrl, g);\n\n\tclear_bit(d->hwirq, pctrl->enabled_irqs);\n\n\traw_spin_unlock_irqrestore(&pctrl->lock, flags);\n}\n\nstatic void msm_gpio_irq_unmask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct msm_pinctrl *pctrl = gpiochip_get_data(gc);\n\tconst struct msm_pingroup *g;\n\tunsigned long flags;\n\tu32 val;\n\n\tif (d->parent_data)\n\t\tirq_chip_unmask_parent(d);\n\n\tif (test_bit(d->hwirq, pctrl->skip_wake_irqs))\n\t\treturn;\n\n\tg = &pctrl->soc->groups[d->hwirq];\n\n\traw_spin_lock_irqsave(&pctrl->lock, flags);\n\n\tval = msm_readl_intr_cfg(pctrl, g);\n\tval |= BIT(g->intr_raw_status_bit);\n\tval |= BIT(g->intr_enable_bit);\n\tmsm_writel_intr_cfg(val, pctrl, g);\n\n\tset_bit(d->hwirq, pctrl->enabled_irqs);\n\n\traw_spin_unlock_irqrestore(&pctrl->lock, flags);\n}\n\nstatic void msm_gpio_irq_enable(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct msm_pinctrl *pctrl = gpiochip_get_data(gc);\n\n\tgpiochip_enable_irq(gc, d->hwirq);\n\n\tif (d->parent_data)\n\t\tirq_chip_enable_parent(d);\n\n\tif (!test_bit(d->hwirq, pctrl->skip_wake_irqs))\n\t\tmsm_gpio_irq_unmask(d);\n}\n\nstatic void msm_gpio_irq_disable(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct msm_pinctrl *pctrl = gpiochip_get_data(gc);\n\n\tif (d->parent_data)\n\t\tirq_chip_disable_parent(d);\n\n\tif (!test_bit(d->hwirq, pctrl->skip_wake_irqs))\n\t\tmsm_gpio_irq_mask(d);\n\n\tgpiochip_disable_irq(gc, d->hwirq);\n}\n\n \nstatic void msm_gpio_update_dual_edge_parent(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct msm_pinctrl *pctrl = gpiochip_get_data(gc);\n\tconst struct msm_pingroup *g = &pctrl->soc->groups[d->hwirq];\n\tint loop_limit = 100;\n\tunsigned int val;\n\tunsigned int type;\n\n\t \n\tval = msm_readl_io(pctrl, g) & BIT(g->in_bit);\n\ttype = val ? IRQ_TYPE_EDGE_FALLING : IRQ_TYPE_EDGE_RISING;\n\n\tdo {\n\t\t \n\t\tirq_chip_set_type_parent(d, type);\n\n\t\t \n\t\tval = msm_readl_io(pctrl, g) & BIT(g->in_bit);\n\t\tif (type == IRQ_TYPE_EDGE_RISING) {\n\t\t\tif (!val)\n\t\t\t\treturn;\n\t\t\ttype = IRQ_TYPE_EDGE_FALLING;\n\t\t} else if (type == IRQ_TYPE_EDGE_FALLING) {\n\t\t\tif (val)\n\t\t\t\treturn;\n\t\t\ttype = IRQ_TYPE_EDGE_RISING;\n\t\t}\n\t} while (loop_limit-- > 0);\n\tdev_warn_once(pctrl->dev, \"dual-edge irq failed to stabilize\\n\");\n}\n\nstatic void msm_gpio_irq_ack(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct msm_pinctrl *pctrl = gpiochip_get_data(gc);\n\tconst struct msm_pingroup *g;\n\tunsigned long flags;\n\n\tif (test_bit(d->hwirq, pctrl->skip_wake_irqs)) {\n\t\tif (test_bit(d->hwirq, pctrl->dual_edge_irqs))\n\t\t\tmsm_gpio_update_dual_edge_parent(d);\n\t\treturn;\n\t}\n\n\tg = &pctrl->soc->groups[d->hwirq];\n\n\traw_spin_lock_irqsave(&pctrl->lock, flags);\n\n\tmsm_ack_intr_status(pctrl, g);\n\n\tif (test_bit(d->hwirq, pctrl->dual_edge_irqs))\n\t\tmsm_gpio_update_dual_edge_pos(pctrl, g, d);\n\n\traw_spin_unlock_irqrestore(&pctrl->lock, flags);\n}\n\nstatic void msm_gpio_irq_eoi(struct irq_data *d)\n{\n\td = d->parent_data;\n\n\tif (d)\n\t\td->chip->irq_eoi(d);\n}\n\nstatic bool msm_gpio_needs_dual_edge_parent_workaround(struct irq_data *d,\n\t\t\t\t\t\t       unsigned int type)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct msm_pinctrl *pctrl = gpiochip_get_data(gc);\n\n\treturn type == IRQ_TYPE_EDGE_BOTH &&\n\t       pctrl->soc->wakeirq_dual_edge_errata && d->parent_data &&\n\t       test_bit(d->hwirq, pctrl->skip_wake_irqs);\n}\n\nstatic int msm_gpio_irq_set_type(struct irq_data *d, unsigned int type)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct msm_pinctrl *pctrl = gpiochip_get_data(gc);\n\tconst struct msm_pingroup *g;\n\tu32 intr_target_mask = GENMASK(2, 0);\n\tunsigned long flags;\n\tbool was_enabled;\n\tu32 val;\n\n\tif (msm_gpio_needs_dual_edge_parent_workaround(d, type)) {\n\t\tset_bit(d->hwirq, pctrl->dual_edge_irqs);\n\t\tirq_set_handler_locked(d, handle_fasteoi_ack_irq);\n\t\tmsm_gpio_update_dual_edge_parent(d);\n\t\treturn 0;\n\t}\n\n\tif (d->parent_data)\n\t\tirq_chip_set_type_parent(d, type);\n\n\tif (test_bit(d->hwirq, pctrl->skip_wake_irqs)) {\n\t\tclear_bit(d->hwirq, pctrl->dual_edge_irqs);\n\t\tirq_set_handler_locked(d, handle_fasteoi_irq);\n\t\treturn 0;\n\t}\n\n\tg = &pctrl->soc->groups[d->hwirq];\n\n\traw_spin_lock_irqsave(&pctrl->lock, flags);\n\n\t \n\tif (g->intr_detection_width == 1 && type == IRQ_TYPE_EDGE_BOTH)\n\t\tset_bit(d->hwirq, pctrl->dual_edge_irqs);\n\telse\n\t\tclear_bit(d->hwirq, pctrl->dual_edge_irqs);\n\n\t \n\tif (g->intr_target_width)\n\t\tintr_target_mask = GENMASK(g->intr_target_width - 1, 0);\n\n\tif (pctrl->intr_target_use_scm) {\n\t\tu32 addr = pctrl->phys_base[0] + g->intr_target_reg;\n\t\tint ret;\n\n\t\tqcom_scm_io_readl(addr, &val);\n\t\tval &= ~(intr_target_mask << g->intr_target_bit);\n\t\tval |= g->intr_target_kpss_val << g->intr_target_bit;\n\n\t\tret = qcom_scm_io_writel(addr, val);\n\t\tif (ret)\n\t\t\tdev_err(pctrl->dev,\n\t\t\t\t\"Failed routing %lu interrupt to Apps proc\",\n\t\t\t\td->hwirq);\n\t} else {\n\t\tval = msm_readl_intr_target(pctrl, g);\n\t\tval &= ~(intr_target_mask << g->intr_target_bit);\n\t\tval |= g->intr_target_kpss_val << g->intr_target_bit;\n\t\tmsm_writel_intr_target(val, pctrl, g);\n\t}\n\n\t \n\tval = msm_readl_intr_cfg(pctrl, g);\n\twas_enabled = val & BIT(g->intr_raw_status_bit);\n\tval |= BIT(g->intr_raw_status_bit);\n\tif (g->intr_detection_width == 2) {\n\t\tval &= ~(3 << g->intr_detection_bit);\n\t\tval &= ~(1 << g->intr_polarity_bit);\n\t\tswitch (type) {\n\t\tcase IRQ_TYPE_EDGE_RISING:\n\t\t\tval |= 1 << g->intr_detection_bit;\n\t\t\tval |= BIT(g->intr_polarity_bit);\n\t\t\tbreak;\n\t\tcase IRQ_TYPE_EDGE_FALLING:\n\t\t\tval |= 2 << g->intr_detection_bit;\n\t\t\tval |= BIT(g->intr_polarity_bit);\n\t\t\tbreak;\n\t\tcase IRQ_TYPE_EDGE_BOTH:\n\t\t\tval |= 3 << g->intr_detection_bit;\n\t\t\tval |= BIT(g->intr_polarity_bit);\n\t\t\tbreak;\n\t\tcase IRQ_TYPE_LEVEL_LOW:\n\t\t\tbreak;\n\t\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\t\tval |= BIT(g->intr_polarity_bit);\n\t\t\tbreak;\n\t\t}\n\t} else if (g->intr_detection_width == 1) {\n\t\tval &= ~(1 << g->intr_detection_bit);\n\t\tval &= ~(1 << g->intr_polarity_bit);\n\t\tswitch (type) {\n\t\tcase IRQ_TYPE_EDGE_RISING:\n\t\t\tval |= BIT(g->intr_detection_bit);\n\t\t\tval |= BIT(g->intr_polarity_bit);\n\t\t\tbreak;\n\t\tcase IRQ_TYPE_EDGE_FALLING:\n\t\t\tval |= BIT(g->intr_detection_bit);\n\t\t\tbreak;\n\t\tcase IRQ_TYPE_EDGE_BOTH:\n\t\t\tval |= BIT(g->intr_detection_bit);\n\t\t\tval |= BIT(g->intr_polarity_bit);\n\t\t\tbreak;\n\t\tcase IRQ_TYPE_LEVEL_LOW:\n\t\t\tbreak;\n\t\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\t\tval |= BIT(g->intr_polarity_bit);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tBUG();\n\t}\n\tmsm_writel_intr_cfg(val, pctrl, g);\n\n\t \n\tif (!was_enabled)\n\t\tmsm_ack_intr_status(pctrl, g);\n\n\tif (test_bit(d->hwirq, pctrl->dual_edge_irqs))\n\t\tmsm_gpio_update_dual_edge_pos(pctrl, g, d);\n\n\traw_spin_unlock_irqrestore(&pctrl->lock, flags);\n\n\tif (type & (IRQ_TYPE_LEVEL_LOW | IRQ_TYPE_LEVEL_HIGH))\n\t\tirq_set_handler_locked(d, handle_level_irq);\n\telse if (type & (IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING))\n\t\tirq_set_handler_locked(d, handle_edge_irq);\n\n\treturn 0;\n}\n\nstatic int msm_gpio_irq_set_wake(struct irq_data *d, unsigned int on)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct msm_pinctrl *pctrl = gpiochip_get_data(gc);\n\n\t \n\tif (d->parent_data && test_bit(d->hwirq, pctrl->skip_wake_irqs))\n\t\treturn irq_chip_set_wake_parent(d, on);\n\n\treturn irq_set_irq_wake(pctrl->irq, on);\n}\n\nstatic int msm_gpio_irq_reqres(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct msm_pinctrl *pctrl = gpiochip_get_data(gc);\n\tint ret;\n\n\tif (!try_module_get(gc->owner))\n\t\treturn -ENODEV;\n\n\tret = msm_pinmux_request_gpio(pctrl->pctrl, NULL, d->hwirq);\n\tif (ret)\n\t\tgoto out;\n\tmsm_gpio_direction_input(gc, d->hwirq);\n\n\tif (gpiochip_lock_as_irq(gc, d->hwirq)) {\n\t\tdev_err(gc->parent,\n\t\t\t\"unable to lock HW IRQ %lu for IRQ\\n\",\n\t\t\td->hwirq);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tirq_set_status_flags(d->irq, IRQ_DISABLE_UNLAZY);\n\n\treturn 0;\nout:\n\tmodule_put(gc->owner);\n\treturn ret;\n}\n\nstatic void msm_gpio_irq_relres(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\n\tgpiochip_unlock_as_irq(gc, d->hwirq);\n\tmodule_put(gc->owner);\n}\n\nstatic int msm_gpio_irq_set_affinity(struct irq_data *d,\n\t\t\t\tconst struct cpumask *dest, bool force)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct msm_pinctrl *pctrl = gpiochip_get_data(gc);\n\n\tif (d->parent_data && test_bit(d->hwirq, pctrl->skip_wake_irqs))\n\t\treturn irq_chip_set_affinity_parent(d, dest, force);\n\n\treturn -EINVAL;\n}\n\nstatic int msm_gpio_irq_set_vcpu_affinity(struct irq_data *d, void *vcpu_info)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct msm_pinctrl *pctrl = gpiochip_get_data(gc);\n\n\tif (d->parent_data && test_bit(d->hwirq, pctrl->skip_wake_irqs))\n\t\treturn irq_chip_set_vcpu_affinity_parent(d, vcpu_info);\n\n\treturn -EINVAL;\n}\n\nstatic void msm_gpio_irq_handler(struct irq_desc *desc)\n{\n\tstruct gpio_chip *gc = irq_desc_get_handler_data(desc);\n\tconst struct msm_pingroup *g;\n\tstruct msm_pinctrl *pctrl = gpiochip_get_data(gc);\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tint handled = 0;\n\tu32 val;\n\tint i;\n\n\tchained_irq_enter(chip, desc);\n\n\t \n\tfor_each_set_bit(i, pctrl->enabled_irqs, pctrl->chip.ngpio) {\n\t\tg = &pctrl->soc->groups[i];\n\t\tval = msm_readl_intr_status(pctrl, g);\n\t\tif (val & BIT(g->intr_status_bit)) {\n\t\t\tgeneric_handle_domain_irq(gc->irq.domain, i);\n\t\t\thandled++;\n\t\t}\n\t}\n\n\t \n\tif (handled == 0)\n\t\thandle_bad_irq(desc);\n\n\tchained_irq_exit(chip, desc);\n}\n\nstatic int msm_gpio_wakeirq(struct gpio_chip *gc,\n\t\t\t    unsigned int child,\n\t\t\t    unsigned int child_type,\n\t\t\t    unsigned int *parent,\n\t\t\t    unsigned int *parent_type)\n{\n\tstruct msm_pinctrl *pctrl = gpiochip_get_data(gc);\n\tconst struct msm_gpio_wakeirq_map *map;\n\tint i;\n\n\t*parent = GPIO_NO_WAKE_IRQ;\n\t*parent_type = IRQ_TYPE_EDGE_RISING;\n\n\tfor (i = 0; i < pctrl->soc->nwakeirq_map; i++) {\n\t\tmap = &pctrl->soc->wakeirq_map[i];\n\t\tif (map->gpio == child) {\n\t\t\t*parent = map->wakeirq;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic bool msm_gpio_needs_valid_mask(struct msm_pinctrl *pctrl)\n{\n\tif (pctrl->soc->reserved_gpios)\n\t\treturn true;\n\n\treturn device_property_count_u16(pctrl->dev, \"gpios\") > 0;\n}\n\nstatic const struct irq_chip msm_gpio_irq_chip = {\n\t.name\t\t\t= \"msmgpio\",\n\t.irq_enable\t\t= msm_gpio_irq_enable,\n\t.irq_disable\t\t= msm_gpio_irq_disable,\n\t.irq_mask\t\t= msm_gpio_irq_mask,\n\t.irq_unmask\t\t= msm_gpio_irq_unmask,\n\t.irq_ack\t\t= msm_gpio_irq_ack,\n\t.irq_eoi\t\t= msm_gpio_irq_eoi,\n\t.irq_set_type\t\t= msm_gpio_irq_set_type,\n\t.irq_set_wake\t\t= msm_gpio_irq_set_wake,\n\t.irq_request_resources\t= msm_gpio_irq_reqres,\n\t.irq_release_resources\t= msm_gpio_irq_relres,\n\t.irq_set_affinity\t= msm_gpio_irq_set_affinity,\n\t.irq_set_vcpu_affinity\t= msm_gpio_irq_set_vcpu_affinity,\n\t.flags\t\t\t= (IRQCHIP_MASK_ON_SUSPEND |\n\t\t\t\t   IRQCHIP_SET_TYPE_MASKED |\n\t\t\t\t   IRQCHIP_ENABLE_WAKEUP_ON_SUSPEND |\n\t\t\t\t   IRQCHIP_IMMUTABLE),\n};\n\nstatic int msm_gpio_init(struct msm_pinctrl *pctrl)\n{\n\tstruct gpio_chip *chip;\n\tstruct gpio_irq_chip *girq;\n\tint i, ret;\n\tunsigned gpio, ngpio = pctrl->soc->ngpios;\n\tstruct device_node *np;\n\tbool skip;\n\n\tif (WARN_ON(ngpio > MAX_NR_GPIO))\n\t\treturn -EINVAL;\n\n\tchip = &pctrl->chip;\n\tchip->base = -1;\n\tchip->ngpio = ngpio;\n\tchip->label = dev_name(pctrl->dev);\n\tchip->parent = pctrl->dev;\n\tchip->owner = THIS_MODULE;\n\tif (msm_gpio_needs_valid_mask(pctrl))\n\t\tchip->init_valid_mask = msm_gpio_init_valid_mask;\n\n\tnp = of_parse_phandle(pctrl->dev->of_node, \"wakeup-parent\", 0);\n\tif (np) {\n\t\tchip->irq.parent_domain = irq_find_matching_host(np,\n\t\t\t\t\t\t DOMAIN_BUS_WAKEUP);\n\t\tof_node_put(np);\n\t\tif (!chip->irq.parent_domain)\n\t\t\treturn -EPROBE_DEFER;\n\t\tchip->irq.child_to_parent_hwirq = msm_gpio_wakeirq;\n\t\t \n\t\tskip = irq_domain_qcom_handle_wakeup(chip->irq.parent_domain);\n\t\tfor (i = 0; skip && i < pctrl->soc->nwakeirq_map; i++) {\n\t\t\tgpio = pctrl->soc->wakeirq_map[i].gpio;\n\t\t\tset_bit(gpio, pctrl->skip_wake_irqs);\n\t\t}\n\t}\n\n\tgirq = &chip->irq;\n\tgpio_irq_chip_set_chip(girq, &msm_gpio_irq_chip);\n\tgirq->parent_handler = msm_gpio_irq_handler;\n\tgirq->fwnode = dev_fwnode(pctrl->dev);\n\tgirq->num_parents = 1;\n\tgirq->parents = devm_kcalloc(pctrl->dev, 1, sizeof(*girq->parents),\n\t\t\t\t     GFP_KERNEL);\n\tif (!girq->parents)\n\t\treturn -ENOMEM;\n\tgirq->default_type = IRQ_TYPE_NONE;\n\tgirq->handler = handle_bad_irq;\n\tgirq->parents[0] = pctrl->irq;\n\n\tret = gpiochip_add_data(&pctrl->chip, pctrl);\n\tif (ret) {\n\t\tdev_err(pctrl->dev, \"Failed register gpiochip\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tif (!of_property_read_bool(pctrl->dev->of_node, \"gpio-ranges\")) {\n\t\tret = gpiochip_add_pin_range(&pctrl->chip,\n\t\t\tdev_name(pctrl->dev), 0, 0, chip->ngpio);\n\t\tif (ret) {\n\t\t\tdev_err(pctrl->dev, \"Failed to add pin range\\n\");\n\t\t\tgpiochip_remove(&pctrl->chip);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int msm_ps_hold_restart(struct notifier_block *nb, unsigned long action,\n\t\t\t       void *data)\n{\n\tstruct msm_pinctrl *pctrl = container_of(nb, struct msm_pinctrl, restart_nb);\n\n\twritel(0, pctrl->regs[0] + PS_HOLD_OFFSET);\n\tmdelay(1000);\n\treturn NOTIFY_DONE;\n}\n\nstatic struct msm_pinctrl *poweroff_pctrl;\n\nstatic void msm_ps_hold_poweroff(void)\n{\n\tmsm_ps_hold_restart(&poweroff_pctrl->restart_nb, 0, NULL);\n}\n\nstatic void msm_pinctrl_setup_pm_reset(struct msm_pinctrl *pctrl)\n{\n\tint i;\n\tconst struct pinfunction *func = pctrl->soc->functions;\n\n\tfor (i = 0; i < pctrl->soc->nfunctions; i++)\n\t\tif (!strcmp(func[i].name, \"ps_hold\")) {\n\t\t\tpctrl->restart_nb.notifier_call = msm_ps_hold_restart;\n\t\t\tpctrl->restart_nb.priority = 128;\n\t\t\tif (register_restart_handler(&pctrl->restart_nb))\n\t\t\t\tdev_err(pctrl->dev,\n\t\t\t\t\t\"failed to setup restart handler.\\n\");\n\t\t\tpoweroff_pctrl = pctrl;\n\t\t\tpm_power_off = msm_ps_hold_poweroff;\n\t\t\tbreak;\n\t\t}\n}\n\nstatic __maybe_unused int msm_pinctrl_suspend(struct device *dev)\n{\n\tstruct msm_pinctrl *pctrl = dev_get_drvdata(dev);\n\n\treturn pinctrl_force_sleep(pctrl->pctrl);\n}\n\nstatic __maybe_unused int msm_pinctrl_resume(struct device *dev)\n{\n\tstruct msm_pinctrl *pctrl = dev_get_drvdata(dev);\n\n\treturn pinctrl_force_default(pctrl->pctrl);\n}\n\nSIMPLE_DEV_PM_OPS(msm_pinctrl_dev_pm_ops, msm_pinctrl_suspend,\n\t\t  msm_pinctrl_resume);\n\nEXPORT_SYMBOL(msm_pinctrl_dev_pm_ops);\n\nint msm_pinctrl_probe(struct platform_device *pdev,\n\t\t      const struct msm_pinctrl_soc_data *soc_data)\n{\n\tstruct msm_pinctrl *pctrl;\n\tstruct resource *res;\n\tint ret;\n\tint i;\n\n\tpctrl = devm_kzalloc(&pdev->dev, sizeof(*pctrl), GFP_KERNEL);\n\tif (!pctrl)\n\t\treturn -ENOMEM;\n\n\tpctrl->dev = &pdev->dev;\n\tpctrl->soc = soc_data;\n\tpctrl->chip = msm_gpio_template;\n\tpctrl->intr_target_use_scm = of_device_is_compatible(\n\t\t\t\t\tpctrl->dev->of_node,\n\t\t\t\t\t\"qcom,ipq8064-pinctrl\");\n\n\traw_spin_lock_init(&pctrl->lock);\n\n\tif (soc_data->tiles) {\n\t\tfor (i = 0; i < soc_data->ntiles; i++) {\n\t\t\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\n\t\t\t\t\t\t\t   soc_data->tiles[i]);\n\t\t\tpctrl->regs[i] = devm_ioremap_resource(&pdev->dev, res);\n\t\t\tif (IS_ERR(pctrl->regs[i]))\n\t\t\t\treturn PTR_ERR(pctrl->regs[i]);\n\t\t}\n\t} else {\n\t\tpctrl->regs[0] = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\t\tif (IS_ERR(pctrl->regs[0]))\n\t\t\treturn PTR_ERR(pctrl->regs[0]);\n\n\t\tpctrl->phys_base[0] = res->start;\n\t}\n\n\tmsm_pinctrl_setup_pm_reset(pctrl);\n\n\tpctrl->irq = platform_get_irq(pdev, 0);\n\tif (pctrl->irq < 0)\n\t\treturn pctrl->irq;\n\n\tpctrl->desc.owner = THIS_MODULE;\n\tpctrl->desc.pctlops = &msm_pinctrl_ops;\n\tpctrl->desc.pmxops = &msm_pinmux_ops;\n\tpctrl->desc.confops = &msm_pinconf_ops;\n\tpctrl->desc.name = dev_name(&pdev->dev);\n\tpctrl->desc.pins = pctrl->soc->pins;\n\tpctrl->desc.npins = pctrl->soc->npins;\n\n\tpctrl->pctrl = devm_pinctrl_register(&pdev->dev, &pctrl->desc, pctrl);\n\tif (IS_ERR(pctrl->pctrl)) {\n\t\tdev_err(&pdev->dev, \"Couldn't register pinctrl driver\\n\");\n\t\treturn PTR_ERR(pctrl->pctrl);\n\t}\n\n\tret = msm_gpio_init(pctrl);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, pctrl);\n\n\tdev_dbg(&pdev->dev, \"Probed Qualcomm pinctrl driver\\n\");\n\n\treturn 0;\n}\nEXPORT_SYMBOL(msm_pinctrl_probe);\n\nint msm_pinctrl_remove(struct platform_device *pdev)\n{\n\tstruct msm_pinctrl *pctrl = platform_get_drvdata(pdev);\n\n\tgpiochip_remove(&pctrl->chip);\n\n\tunregister_restart_handler(&pctrl->restart_nb);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(msm_pinctrl_remove);\n\nMODULE_DESCRIPTION(\"Qualcomm Technologies, Inc. TLMM driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}