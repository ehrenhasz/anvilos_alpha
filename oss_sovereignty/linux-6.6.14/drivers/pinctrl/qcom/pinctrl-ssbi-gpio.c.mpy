{
  "module_name": "pinctrl-ssbi-gpio.c",
  "hash_id": "78d53be78aa0179f6ee8b8700ef5a0e62da603e7aa311f20b37ed5aef7ecfd67",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/qcom/pinctrl-ssbi-gpio.c",
  "human_readable_source": "\n \n\n#include <linux/gpio/driver.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n\n#include <linux/pinctrl/pinconf-generic.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinmux.h>\n\n#include <dt-bindings/pinctrl/qcom,pmic-gpio.h>\n\n#include \"../core.h\"\n#include \"../pinctrl-utils.h\"\n\n \n#define PM8XXX_GPIO_MODE_ENABLED\tBIT(0)\n#define PM8XXX_GPIO_MODE_INPUT\t\t0\n#define PM8XXX_GPIO_MODE_OUTPUT\t\t2\n\n \n#define PM8XXX_GPIO_PUSH_PULL\t\t0\n#define PM8XXX_GPIO_OPEN_DRAIN\t\t1\n\n \n#define PM8XXX_GPIO_BIAS_PU_30\t\t0\n#define PM8XXX_GPIO_BIAS_PU_1P5\t\t1\n#define PM8XXX_GPIO_BIAS_PU_31P5\t2\n#define PM8XXX_GPIO_BIAS_PU_1P5_30\t3\n#define PM8XXX_GPIO_BIAS_PD\t\t4\n#define PM8XXX_GPIO_BIAS_NP\t\t5\n\n \n#define SSBI_REG_ADDR_GPIO_BASE\t\t0x150\n#define SSBI_REG_ADDR_GPIO(n)\t\t(SSBI_REG_ADDR_GPIO_BASE + n)\n\n#define PM8XXX_BANK_WRITE\t\tBIT(7)\n\n#define PM8XXX_MAX_GPIOS               44\n\n#define PM8XXX_GPIO_PHYSICAL_OFFSET\t1\n\n \n#define PM8XXX_QCOM_DRIVE_STRENGH      (PIN_CONFIG_END + 1)\n#define PM8XXX_QCOM_PULL_UP_STRENGTH   (PIN_CONFIG_END + 2)\n\n \nstruct pm8xxx_pin_data {\n\tunsigned reg;\n\tu8 power_source;\n\tu8 mode;\n\tbool open_drain;\n\tbool output_value;\n\tu8 bias;\n\tu8 pull_up_strength;\n\tu8 output_strength;\n\tbool disable;\n\tu8 function;\n\tbool inverted;\n};\n\nstruct pm8xxx_gpio {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tstruct pinctrl_dev *pctrl;\n\tstruct gpio_chip chip;\n\n\tstruct pinctrl_desc desc;\n\tunsigned npins;\n};\n\nstatic const struct pinconf_generic_params pm8xxx_gpio_bindings[] = {\n\t{\"qcom,drive-strength\",\t\tPM8XXX_QCOM_DRIVE_STRENGH,\t0},\n\t{\"qcom,pull-up-strength\",\tPM8XXX_QCOM_PULL_UP_STRENGTH,\t0},\n};\n\n#ifdef CONFIG_DEBUG_FS\nstatic const struct pin_config_item pm8xxx_conf_items[ARRAY_SIZE(pm8xxx_gpio_bindings)] = {\n\tPCONFDUMP(PM8XXX_QCOM_DRIVE_STRENGH, \"drive-strength\", NULL, true),\n\tPCONFDUMP(PM8XXX_QCOM_PULL_UP_STRENGTH,  \"pull up strength\", NULL, true),\n};\n#endif\n\nstatic const char * const pm8xxx_groups[PM8XXX_MAX_GPIOS] = {\n\t\"gpio1\", \"gpio2\", \"gpio3\", \"gpio4\", \"gpio5\", \"gpio6\", \"gpio7\", \"gpio8\",\n\t\"gpio9\", \"gpio10\", \"gpio11\", \"gpio12\", \"gpio13\", \"gpio14\", \"gpio15\",\n\t\"gpio16\", \"gpio17\", \"gpio18\", \"gpio19\", \"gpio20\", \"gpio21\", \"gpio22\",\n\t\"gpio23\", \"gpio24\", \"gpio25\", \"gpio26\", \"gpio27\", \"gpio28\", \"gpio29\",\n\t\"gpio30\", \"gpio31\", \"gpio32\", \"gpio33\", \"gpio34\", \"gpio35\", \"gpio36\",\n\t\"gpio37\", \"gpio38\", \"gpio39\", \"gpio40\", \"gpio41\", \"gpio42\", \"gpio43\",\n\t\"gpio44\",\n};\n\nstatic const char * const pm8xxx_gpio_functions[] = {\n\tPMIC_GPIO_FUNC_NORMAL, PMIC_GPIO_FUNC_PAIRED,\n\tPMIC_GPIO_FUNC_FUNC1, PMIC_GPIO_FUNC_FUNC2,\n\tPMIC_GPIO_FUNC_DTEST1, PMIC_GPIO_FUNC_DTEST2,\n\tPMIC_GPIO_FUNC_DTEST3, PMIC_GPIO_FUNC_DTEST4,\n};\n\nstatic int pm8xxx_read_bank(struct pm8xxx_gpio *pctrl,\n\t\t\t    struct pm8xxx_pin_data *pin, int bank)\n{\n\tunsigned int val = bank << 4;\n\tint ret;\n\n\tret = regmap_write(pctrl->regmap, pin->reg, val);\n\tif (ret) {\n\t\tdev_err(pctrl->dev, \"failed to select bank %d\\n\", bank);\n\t\treturn ret;\n\t}\n\n\tret = regmap_read(pctrl->regmap, pin->reg, &val);\n\tif (ret) {\n\t\tdev_err(pctrl->dev, \"failed to read register %d\\n\", bank);\n\t\treturn ret;\n\t}\n\n\treturn val;\n}\n\nstatic int pm8xxx_write_bank(struct pm8xxx_gpio *pctrl,\n\t\t\t     struct pm8xxx_pin_data *pin,\n\t\t\t     int bank,\n\t\t\t     u8 val)\n{\n\tint ret;\n\n\tval |= PM8XXX_BANK_WRITE;\n\tval |= bank << 4;\n\n\tret = regmap_write(pctrl->regmap, pin->reg, val);\n\tif (ret)\n\t\tdev_err(pctrl->dev, \"failed to write register\\n\");\n\n\treturn ret;\n}\n\nstatic int pm8xxx_get_groups_count(struct pinctrl_dev *pctldev)\n{\n\tstruct pm8xxx_gpio *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pctrl->npins;\n}\n\nstatic const char *pm8xxx_get_group_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t unsigned group)\n{\n\treturn pm8xxx_groups[group];\n}\n\n\nstatic int pm8xxx_get_group_pins(struct pinctrl_dev *pctldev,\n\t\t\t\t unsigned group,\n\t\t\t\t const unsigned **pins,\n\t\t\t\t unsigned *num_pins)\n{\n\tstruct pm8xxx_gpio *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\n\t*pins = &pctrl->desc.pins[group].number;\n\t*num_pins = 1;\n\n\treturn 0;\n}\n\nstatic const struct pinctrl_ops pm8xxx_pinctrl_ops = {\n\t.get_groups_count\t= pm8xxx_get_groups_count,\n\t.get_group_name\t\t= pm8xxx_get_group_name,\n\t.get_group_pins         = pm8xxx_get_group_pins,\n\t.dt_node_to_map\t\t= pinconf_generic_dt_node_to_map_group,\n\t.dt_free_map\t\t= pinctrl_utils_free_map,\n};\n\nstatic int pm8xxx_get_functions_count(struct pinctrl_dev *pctldev)\n{\n\treturn ARRAY_SIZE(pm8xxx_gpio_functions);\n}\n\nstatic const char *pm8xxx_get_function_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t    unsigned function)\n{\n\treturn pm8xxx_gpio_functions[function];\n}\n\nstatic int pm8xxx_get_function_groups(struct pinctrl_dev *pctldev,\n\t\t\t\t      unsigned function,\n\t\t\t\t      const char * const **groups,\n\t\t\t\t      unsigned * const num_groups)\n{\n\tstruct pm8xxx_gpio *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\n\t*groups = pm8xxx_groups;\n\t*num_groups = pctrl->npins;\n\treturn 0;\n}\n\nstatic int pm8xxx_pinmux_set_mux(struct pinctrl_dev *pctldev,\n\t\t\t\t unsigned function,\n\t\t\t\t unsigned group)\n{\n\tstruct pm8xxx_gpio *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct pm8xxx_pin_data *pin = pctrl->desc.pins[group].drv_data;\n\tu8 val;\n\n\tpin->function = function;\n\tval = pin->function << 1;\n\n\tpm8xxx_write_bank(pctrl, pin, 4, val);\n\n\treturn 0;\n}\n\nstatic const struct pinmux_ops pm8xxx_pinmux_ops = {\n\t.get_functions_count\t= pm8xxx_get_functions_count,\n\t.get_function_name\t= pm8xxx_get_function_name,\n\t.get_function_groups\t= pm8xxx_get_function_groups,\n\t.set_mux\t\t= pm8xxx_pinmux_set_mux,\n};\n\nstatic int pm8xxx_pin_config_get(struct pinctrl_dev *pctldev,\n\t\t\t\t unsigned int offset,\n\t\t\t\t unsigned long *config)\n{\n\tstruct pm8xxx_gpio *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct pm8xxx_pin_data *pin = pctrl->desc.pins[offset].drv_data;\n\tunsigned param = pinconf_to_config_param(*config);\n\tunsigned arg;\n\n\tswitch (param) {\n\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\tif (pin->bias != PM8XXX_GPIO_BIAS_NP)\n\t\t\treturn -EINVAL;\n\t\targ = 1;\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\tif (pin->bias != PM8XXX_GPIO_BIAS_PD)\n\t\t\treturn -EINVAL;\n\t\targ = 1;\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\tif (pin->bias > PM8XXX_GPIO_BIAS_PU_1P5_30)\n\t\t\treturn -EINVAL;\n\t\targ = 1;\n\t\tbreak;\n\tcase PM8XXX_QCOM_PULL_UP_STRENGTH:\n\t\targ = pin->pull_up_strength;\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_HIGH_IMPEDANCE:\n\t\tif (!pin->disable)\n\t\t\treturn -EINVAL;\n\t\targ = 1;\n\t\tbreak;\n\tcase PIN_CONFIG_INPUT_ENABLE:\n\t\tif (pin->mode != PM8XXX_GPIO_MODE_INPUT)\n\t\t\treturn -EINVAL;\n\t\targ = 1;\n\t\tbreak;\n\tcase PIN_CONFIG_OUTPUT:\n\t\tif (pin->mode & PM8XXX_GPIO_MODE_OUTPUT)\n\t\t\targ = pin->output_value;\n\t\telse\n\t\t\targ = 0;\n\t\tbreak;\n\tcase PIN_CONFIG_POWER_SOURCE:\n\t\targ = pin->power_source;\n\t\tbreak;\n\tcase PM8XXX_QCOM_DRIVE_STRENGH:\n\t\targ = pin->output_strength;\n\t\tbreak;\n\tcase PIN_CONFIG_DRIVE_PUSH_PULL:\n\t\tif (pin->open_drain)\n\t\t\treturn -EINVAL;\n\t\targ = 1;\n\t\tbreak;\n\tcase PIN_CONFIG_DRIVE_OPEN_DRAIN:\n\t\tif (!pin->open_drain)\n\t\t\treturn -EINVAL;\n\t\targ = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t*config = pinconf_to_config_packed(param, arg);\n\n\treturn 0;\n}\n\nstatic int pm8xxx_pin_config_set(struct pinctrl_dev *pctldev,\n\t\t\t\t unsigned int offset,\n\t\t\t\t unsigned long *configs,\n\t\t\t\t unsigned num_configs)\n{\n\tstruct pm8xxx_gpio *pctrl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct pm8xxx_pin_data *pin = pctrl->desc.pins[offset].drv_data;\n\tunsigned param;\n\tunsigned arg;\n\tunsigned i;\n\tu8 banks = 0;\n\tu8 val;\n\n\tfor (i = 0; i < num_configs; i++) {\n\t\tparam = pinconf_to_config_param(configs[i]);\n\t\targ = pinconf_to_config_argument(configs[i]);\n\n\t\tswitch (param) {\n\t\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\t\tpin->bias = PM8XXX_GPIO_BIAS_NP;\n\t\t\tbanks |= BIT(2);\n\t\t\tpin->disable = 0;\n\t\t\tbanks |= BIT(3);\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\t\tpin->bias = PM8XXX_GPIO_BIAS_PD;\n\t\t\tbanks |= BIT(2);\n\t\t\tpin->disable = 0;\n\t\t\tbanks |= BIT(3);\n\t\t\tbreak;\n\t\tcase PM8XXX_QCOM_PULL_UP_STRENGTH:\n\t\t\tif (arg > PM8XXX_GPIO_BIAS_PU_1P5_30) {\n\t\t\t\tdev_err(pctrl->dev, \"invalid pull-up strength\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tpin->pull_up_strength = arg;\n\t\t\tfallthrough;\n\t\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\t\tpin->bias = pin->pull_up_strength;\n\t\t\tbanks |= BIT(2);\n\t\t\tpin->disable = 0;\n\t\t\tbanks |= BIT(3);\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_BIAS_HIGH_IMPEDANCE:\n\t\t\tpin->disable = 1;\n\t\t\tbanks |= BIT(3);\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_INPUT_ENABLE:\n\t\t\tpin->mode = PM8XXX_GPIO_MODE_INPUT;\n\t\t\tbanks |= BIT(0) | BIT(1);\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_OUTPUT:\n\t\t\tpin->mode = PM8XXX_GPIO_MODE_OUTPUT;\n\t\t\tpin->output_value = !!arg;\n\t\t\tbanks |= BIT(0) | BIT(1);\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_POWER_SOURCE:\n\t\t\tpin->power_source = arg;\n\t\t\tbanks |= BIT(0);\n\t\t\tbreak;\n\t\tcase PM8XXX_QCOM_DRIVE_STRENGH:\n\t\t\tif (arg > PMIC_GPIO_STRENGTH_LOW) {\n\t\t\t\tdev_err(pctrl->dev, \"invalid drive strength\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tpin->output_strength = arg;\n\t\t\tbanks |= BIT(3);\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_DRIVE_PUSH_PULL:\n\t\t\tpin->open_drain = 0;\n\t\t\tbanks |= BIT(1);\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_DRIVE_OPEN_DRAIN:\n\t\t\tpin->open_drain = 1;\n\t\t\tbanks |= BIT(1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(pctrl->dev,\n\t\t\t\t\"unsupported config parameter: %x\\n\",\n\t\t\t\tparam);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (banks & BIT(0)) {\n\t\tval = pin->power_source << 1;\n\t\tval |= PM8XXX_GPIO_MODE_ENABLED;\n\t\tpm8xxx_write_bank(pctrl, pin, 0, val);\n\t}\n\n\tif (banks & BIT(1)) {\n\t\tval = pin->mode << 2;\n\t\tval |= pin->open_drain << 1;\n\t\tval |= pin->output_value;\n\t\tpm8xxx_write_bank(pctrl, pin, 1, val);\n\t}\n\n\tif (banks & BIT(2)) {\n\t\tval = pin->bias << 1;\n\t\tpm8xxx_write_bank(pctrl, pin, 2, val);\n\t}\n\n\tif (banks & BIT(3)) {\n\t\tval = pin->output_strength << 2;\n\t\tval |= pin->disable;\n\t\tpm8xxx_write_bank(pctrl, pin, 3, val);\n\t}\n\n\tif (banks & BIT(4)) {\n\t\tval = pin->function << 1;\n\t\tpm8xxx_write_bank(pctrl, pin, 4, val);\n\t}\n\n\tif (banks & BIT(5)) {\n\t\tval = 0;\n\t\tif (!pin->inverted)\n\t\t\tval |= BIT(3);\n\t\tpm8xxx_write_bank(pctrl, pin, 5, val);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct pinconf_ops pm8xxx_pinconf_ops = {\n\t.is_generic = true,\n\t.pin_config_group_get = pm8xxx_pin_config_get,\n\t.pin_config_group_set = pm8xxx_pin_config_set,\n};\n\nstatic const struct pinctrl_desc pm8xxx_pinctrl_desc = {\n\t.name = \"pm8xxx_gpio\",\n\t.pctlops = &pm8xxx_pinctrl_ops,\n\t.pmxops = &pm8xxx_pinmux_ops,\n\t.confops = &pm8xxx_pinconf_ops,\n\t.owner = THIS_MODULE,\n};\n\nstatic int pm8xxx_gpio_direction_input(struct gpio_chip *chip,\n\t\t\t\t       unsigned offset)\n{\n\tstruct pm8xxx_gpio *pctrl = gpiochip_get_data(chip);\n\tstruct pm8xxx_pin_data *pin = pctrl->desc.pins[offset].drv_data;\n\tu8 val;\n\n\tpin->mode = PM8XXX_GPIO_MODE_INPUT;\n\tval = pin->mode << 2;\n\n\tpm8xxx_write_bank(pctrl, pin, 1, val);\n\n\treturn 0;\n}\n\nstatic int pm8xxx_gpio_direction_output(struct gpio_chip *chip,\n\t\t\t\t\tunsigned offset,\n\t\t\t\t\tint value)\n{\n\tstruct pm8xxx_gpio *pctrl = gpiochip_get_data(chip);\n\tstruct pm8xxx_pin_data *pin = pctrl->desc.pins[offset].drv_data;\n\tu8 val;\n\n\tpin->mode = PM8XXX_GPIO_MODE_OUTPUT;\n\tpin->output_value = !!value;\n\n\tval = pin->mode << 2;\n\tval |= pin->open_drain << 1;\n\tval |= pin->output_value;\n\n\tpm8xxx_write_bank(pctrl, pin, 1, val);\n\n\treturn 0;\n}\n\nstatic int pm8xxx_gpio_get(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct pm8xxx_gpio *pctrl = gpiochip_get_data(chip);\n\tstruct pm8xxx_pin_data *pin = pctrl->desc.pins[offset].drv_data;\n\tint ret, irq;\n\tbool state;\n\n\tif (pin->mode == PM8XXX_GPIO_MODE_OUTPUT)\n\t\treturn pin->output_value;\n\n\tirq = chip->to_irq(chip, offset);\n\tif (irq >= 0) {\n\t\tret = irq_get_irqchip_state(irq, IRQCHIP_STATE_LINE_LEVEL,\n\t\t\t\t\t    &state);\n\t\tif (!ret)\n\t\t\tret = !!state;\n\t} else\n\t\tret = -EINVAL;\n\n\treturn ret;\n}\n\nstatic void pm8xxx_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\n{\n\tstruct pm8xxx_gpio *pctrl = gpiochip_get_data(chip);\n\tstruct pm8xxx_pin_data *pin = pctrl->desc.pins[offset].drv_data;\n\tu8 val;\n\n\tpin->output_value = !!value;\n\n\tval = pin->mode << 2;\n\tval |= pin->open_drain << 1;\n\tval |= pin->output_value;\n\n\tpm8xxx_write_bank(pctrl, pin, 1, val);\n}\n\nstatic int pm8xxx_gpio_of_xlate(struct gpio_chip *chip,\n\t\t\t\tconst struct of_phandle_args *gpio_desc,\n\t\t\t\tu32 *flags)\n{\n\tif (chip->of_gpio_n_cells < 2)\n\t\treturn -EINVAL;\n\n\tif (flags)\n\t\t*flags = gpio_desc->args[1];\n\n\treturn gpio_desc->args[0] - PM8XXX_GPIO_PHYSICAL_OFFSET;\n}\n\n\n#ifdef CONFIG_DEBUG_FS\n\nstatic void pm8xxx_gpio_dbg_show_one(struct seq_file *s,\n\t\t\t\t  struct pinctrl_dev *pctldev,\n\t\t\t\t  struct gpio_chip *chip,\n\t\t\t\t  unsigned offset,\n\t\t\t\t  unsigned gpio)\n{\n\tstruct pm8xxx_gpio *pctrl = gpiochip_get_data(chip);\n\tstruct pm8xxx_pin_data *pin = pctrl->desc.pins[offset].drv_data;\n\n\tstatic const char * const modes[] = {\n\t\t\"in\", \"both\", \"out\", \"off\"\n\t};\n\tstatic const char * const biases[] = {\n\t\t\"pull-up 30uA\", \"pull-up 1.5uA\", \"pull-up 31.5uA\",\n\t\t\"pull-up 1.5uA + 30uA boost\", \"pull-down 10uA\", \"no pull\"\n\t};\n\tstatic const char * const buffer_types[] = {\n\t\t\"push-pull\", \"open-drain\"\n\t};\n\tstatic const char * const strengths[] = {\n\t\t\"no\", \"high\", \"medium\", \"low\"\n\t};\n\n\tseq_printf(s, \" gpio%-2d:\", offset + PM8XXX_GPIO_PHYSICAL_OFFSET);\n\tif (pin->disable) {\n\t\tseq_puts(s, \" ---\");\n\t} else {\n\t\tseq_printf(s, \" %-4s\", modes[pin->mode]);\n\t\tseq_printf(s, \" %-7s\", pm8xxx_gpio_functions[pin->function]);\n\t\tseq_printf(s, \" VIN%d\", pin->power_source);\n\t\tseq_printf(s, \" %-27s\", biases[pin->bias]);\n\t\tseq_printf(s, \" %-10s\", buffer_types[pin->open_drain]);\n\t\tseq_printf(s, \" %-4s\", pin->output_value ? \"high\" : \"low\");\n\t\tseq_printf(s, \" %-7s\", strengths[pin->output_strength]);\n\t\tif (pin->inverted)\n\t\t\tseq_puts(s, \" inverted\");\n\t}\n}\n\nstatic void pm8xxx_gpio_dbg_show(struct seq_file *s, struct gpio_chip *chip)\n{\n\tunsigned gpio = chip->base;\n\tunsigned i;\n\n\tfor (i = 0; i < chip->ngpio; i++, gpio++) {\n\t\tpm8xxx_gpio_dbg_show_one(s, NULL, chip, i, gpio);\n\t\tseq_puts(s, \"\\n\");\n\t}\n}\n\n#else\n#define pm8xxx_gpio_dbg_show NULL\n#endif\n\nstatic const struct gpio_chip pm8xxx_gpio_template = {\n\t.direction_input = pm8xxx_gpio_direction_input,\n\t.direction_output = pm8xxx_gpio_direction_output,\n\t.get = pm8xxx_gpio_get,\n\t.set = pm8xxx_gpio_set,\n\t.of_xlate = pm8xxx_gpio_of_xlate,\n\t.dbg_show = pm8xxx_gpio_dbg_show,\n\t.owner = THIS_MODULE,\n};\n\nstatic int pm8xxx_pin_populate(struct pm8xxx_gpio *pctrl,\n\t\t\t       struct pm8xxx_pin_data *pin)\n{\n\tint val;\n\n\tval = pm8xxx_read_bank(pctrl, pin, 0);\n\tif (val < 0)\n\t\treturn val;\n\n\tpin->power_source = (val >> 1) & 0x7;\n\n\tval = pm8xxx_read_bank(pctrl, pin, 1);\n\tif (val < 0)\n\t\treturn val;\n\n\tpin->mode = (val >> 2) & 0x3;\n\tpin->open_drain = !!(val & BIT(1));\n\tpin->output_value = val & BIT(0);\n\n\tval = pm8xxx_read_bank(pctrl, pin, 2);\n\tif (val < 0)\n\t\treturn val;\n\n\tpin->bias = (val >> 1) & 0x7;\n\tif (pin->bias <= PM8XXX_GPIO_BIAS_PU_1P5_30)\n\t\tpin->pull_up_strength = pin->bias;\n\telse\n\t\tpin->pull_up_strength = PM8XXX_GPIO_BIAS_PU_30;\n\n\tval = pm8xxx_read_bank(pctrl, pin, 3);\n\tif (val < 0)\n\t\treturn val;\n\n\tpin->output_strength = (val >> 2) & 0x3;\n\tpin->disable = val & BIT(0);\n\n\tval = pm8xxx_read_bank(pctrl, pin, 4);\n\tif (val < 0)\n\t\treturn val;\n\n\tpin->function = (val >> 1) & 0x7;\n\n\tval = pm8xxx_read_bank(pctrl, pin, 5);\n\tif (val < 0)\n\t\treturn val;\n\n\tpin->inverted = !(val & BIT(3));\n\n\treturn 0;\n}\n\nstatic void pm8xxx_irq_disable(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\n\tgpiochip_disable_irq(gc, irqd_to_hwirq(d));\n}\n\nstatic void pm8xxx_irq_enable(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\n\tgpiochip_enable_irq(gc, irqd_to_hwirq(d));\n}\n\nstatic const struct irq_chip pm8xxx_irq_chip = {\n\t.name = \"ssbi-gpio\",\n\t.irq_mask_ack = irq_chip_mask_ack_parent,\n\t.irq_unmask = irq_chip_unmask_parent,\n\t.irq_disable = pm8xxx_irq_disable,\n\t.irq_enable = pm8xxx_irq_enable,\n\t.irq_set_type = irq_chip_set_type_parent,\n\t.flags = IRQCHIP_MASK_ON_SUSPEND | IRQCHIP_SKIP_SET_WAKE |\n\t\tIRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic int pm8xxx_domain_translate(struct irq_domain *domain,\n\t\t\t\t   struct irq_fwspec *fwspec,\n\t\t\t\t   unsigned long *hwirq,\n\t\t\t\t   unsigned int *type)\n{\n\tstruct pm8xxx_gpio *pctrl = container_of(domain->host_data,\n\t\t\t\t\t\t struct pm8xxx_gpio, chip);\n\n\tif (fwspec->param_count != 2 || fwspec->param[0] < 1 ||\n\t    fwspec->param[0] > pctrl->chip.ngpio)\n\t\treturn -EINVAL;\n\n\t*hwirq = fwspec->param[0] - PM8XXX_GPIO_PHYSICAL_OFFSET;\n\t*type = fwspec->param[1];\n\n\treturn 0;\n}\n\nstatic unsigned int pm8xxx_child_offset_to_irq(struct gpio_chip *chip,\n\t\t\t\t\t       unsigned int offset)\n{\n\treturn offset + PM8XXX_GPIO_PHYSICAL_OFFSET;\n}\n\nstatic int pm8xxx_child_to_parent_hwirq(struct gpio_chip *chip,\n\t\t\t\t\tunsigned int child_hwirq,\n\t\t\t\t\tunsigned int child_type,\n\t\t\t\t\tunsigned int *parent_hwirq,\n\t\t\t\t\tunsigned int *parent_type)\n{\n\t*parent_hwirq = child_hwirq + 0xc0;\n\t*parent_type = child_type;\n\n\treturn 0;\n}\n\nstatic const struct of_device_id pm8xxx_gpio_of_match[] = {\n\t{ .compatible = \"qcom,pm8018-gpio\", .data = (void *) 6 },\n\t{ .compatible = \"qcom,pm8038-gpio\", .data = (void *) 12 },\n\t{ .compatible = \"qcom,pm8058-gpio\", .data = (void *) 44 },\n\t{ .compatible = \"qcom,pm8917-gpio\", .data = (void *) 38 },\n\t{ .compatible = \"qcom,pm8921-gpio\", .data = (void *) 44 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, pm8xxx_gpio_of_match);\n\nstatic int pm8xxx_gpio_probe(struct platform_device *pdev)\n{\n\tstruct pm8xxx_pin_data *pin_data;\n\tstruct irq_domain *parent_domain;\n\tstruct device_node *parent_node;\n\tstruct pinctrl_pin_desc *pins;\n\tstruct gpio_irq_chip *girq;\n\tstruct pm8xxx_gpio *pctrl;\n\tint ret, i;\n\n\tpctrl = devm_kzalloc(&pdev->dev, sizeof(*pctrl), GFP_KERNEL);\n\tif (!pctrl)\n\t\treturn -ENOMEM;\n\n\tpctrl->dev = &pdev->dev;\n\tpctrl->npins = (uintptr_t) device_get_match_data(&pdev->dev);\n\n\tpctrl->regmap = dev_get_regmap(pdev->dev.parent, NULL);\n\tif (!pctrl->regmap) {\n\t\tdev_err(&pdev->dev, \"parent regmap unavailable\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tpctrl->desc = pm8xxx_pinctrl_desc;\n\tpctrl->desc.npins = pctrl->npins;\n\n\tpins = devm_kcalloc(&pdev->dev,\n\t\t\t    pctrl->desc.npins,\n\t\t\t    sizeof(struct pinctrl_pin_desc),\n\t\t\t    GFP_KERNEL);\n\tif (!pins)\n\t\treturn -ENOMEM;\n\n\tpin_data = devm_kcalloc(&pdev->dev,\n\t\t\t\tpctrl->desc.npins,\n\t\t\t\tsizeof(struct pm8xxx_pin_data),\n\t\t\t\tGFP_KERNEL);\n\tif (!pin_data)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < pctrl->desc.npins; i++) {\n\t\tpin_data[i].reg = SSBI_REG_ADDR_GPIO(i);\n\n\t\tret = pm8xxx_pin_populate(pctrl, &pin_data[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tpins[i].number = i;\n\t\tpins[i].name = pm8xxx_groups[i];\n\t\tpins[i].drv_data = &pin_data[i];\n\t}\n\tpctrl->desc.pins = pins;\n\n\tpctrl->desc.num_custom_params = ARRAY_SIZE(pm8xxx_gpio_bindings);\n\tpctrl->desc.custom_params = pm8xxx_gpio_bindings;\n#ifdef CONFIG_DEBUG_FS\n\tpctrl->desc.custom_conf_items = pm8xxx_conf_items;\n#endif\n\n\tpctrl->pctrl = devm_pinctrl_register(&pdev->dev, &pctrl->desc, pctrl);\n\tif (IS_ERR(pctrl->pctrl)) {\n\t\tdev_err(&pdev->dev, \"couldn't register pm8xxx gpio driver\\n\");\n\t\treturn PTR_ERR(pctrl->pctrl);\n\t}\n\n\tpctrl->chip = pm8xxx_gpio_template;\n\tpctrl->chip.base = -1;\n\tpctrl->chip.parent = &pdev->dev;\n\tpctrl->chip.of_gpio_n_cells = 2;\n\tpctrl->chip.label = dev_name(pctrl->dev);\n\tpctrl->chip.ngpio = pctrl->npins;\n\n\tparent_node = of_irq_find_parent(pctrl->dev->of_node);\n\tif (!parent_node)\n\t\treturn -ENXIO;\n\n\tparent_domain = irq_find_host(parent_node);\n\tof_node_put(parent_node);\n\tif (!parent_domain)\n\t\treturn -ENXIO;\n\n\tgirq = &pctrl->chip.irq;\n\tgpio_irq_chip_set_chip(girq, &pm8xxx_irq_chip);\n\tgirq->default_type = IRQ_TYPE_NONE;\n\tgirq->handler = handle_level_irq;\n\tgirq->fwnode = dev_fwnode(pctrl->dev);\n\tgirq->parent_domain = parent_domain;\n\tgirq->child_to_parent_hwirq = pm8xxx_child_to_parent_hwirq;\n\tgirq->populate_parent_alloc_arg = gpiochip_populate_parent_fwspec_twocell;\n\tgirq->child_offset_to_irq = pm8xxx_child_offset_to_irq;\n\tgirq->child_irq_domain_ops.translate = pm8xxx_domain_translate;\n\n\tret = gpiochip_add_data(&pctrl->chip, pctrl);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed register gpiochip\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tif (!of_property_read_bool(pctrl->dev->of_node, \"gpio-ranges\")) {\n\t\tret = gpiochip_add_pin_range(&pctrl->chip, dev_name(pctrl->dev),\n\t\t\t\t\t     0, 0, pctrl->chip.ngpio);\n\t\tif (ret) {\n\t\t\tdev_err(pctrl->dev, \"failed to add pin range\\n\");\n\t\t\tgoto unregister_gpiochip;\n\t\t}\n\t}\n\n\tplatform_set_drvdata(pdev, pctrl);\n\n\tdev_dbg(&pdev->dev, \"Qualcomm pm8xxx gpio driver probed\\n\");\n\n\treturn 0;\n\nunregister_gpiochip:\n\tgpiochip_remove(&pctrl->chip);\n\n\treturn ret;\n}\n\nstatic int pm8xxx_gpio_remove(struct platform_device *pdev)\n{\n\tstruct pm8xxx_gpio *pctrl = platform_get_drvdata(pdev);\n\n\tgpiochip_remove(&pctrl->chip);\n\n\treturn 0;\n}\n\nstatic struct platform_driver pm8xxx_gpio_driver = {\n\t.driver = {\n\t\t.name = \"qcom-ssbi-gpio\",\n\t\t.of_match_table = pm8xxx_gpio_of_match,\n\t},\n\t.probe = pm8xxx_gpio_probe,\n\t.remove = pm8xxx_gpio_remove,\n};\n\nmodule_platform_driver(pm8xxx_gpio_driver);\n\nMODULE_AUTHOR(\"Bjorn Andersson <bjorn.andersson@sonymobile.com>\");\nMODULE_DESCRIPTION(\"Qualcomm PM8xxx GPIO driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}