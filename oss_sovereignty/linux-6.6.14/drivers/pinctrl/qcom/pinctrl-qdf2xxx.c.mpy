{
  "module_name": "pinctrl-qdf2xxx.c",
  "hash_id": "3720ad9f5c65150de2310890d0b1d5442cc4433c058551ac0637e31b79305909",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/qcom/pinctrl-qdf2xxx.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/acpi.h>\n\n#include \"pinctrl-msm.h\"\n\n \n#define MAX_GPIOS\t256\n\n \n#define NAME_SIZE\t8\n\nstatic int qdf2xxx_pinctrl_probe(struct platform_device *pdev)\n{\n\tstruct msm_pinctrl_soc_data *pinctrl;\n\tstruct pinctrl_pin_desc *pins;\n\tstruct msm_pingroup *groups;\n\tchar (*names)[NAME_SIZE];\n\tunsigned int i;\n\tu32 num_gpios;\n\tunsigned int avail_gpios;  \n\tu8 gpios[MAX_GPIOS];       \n\tint ret;\n\n\t \n\tret = device_property_read_u32(&pdev->dev, \"num-gpios\", &num_gpios);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"missing 'num-gpios' property\\n\");\n\t\treturn ret;\n\t}\n\tif (!num_gpios || num_gpios > MAX_GPIOS) {\n\t\tdev_err(&pdev->dev, \"invalid 'num-gpios' property\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tret = device_property_count_u8(&pdev->dev, \"gpios\");\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"missing 'gpios' property\\n\");\n\t\treturn ret;\n\t}\n\t \n\tif (!ret || ret > num_gpios) {\n\t\tdev_err(&pdev->dev, \"invalid 'gpios' property\\n\");\n\t\treturn -ENODEV;\n\t}\n\tavail_gpios = ret;\n\n\tret = device_property_read_u8_array(&pdev->dev, \"gpios\", gpios,\n\t\t\t\t\t    avail_gpios);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"could not read list of GPIOs\\n\");\n\t\treturn ret;\n\t}\n\n\tpinctrl = devm_kzalloc(&pdev->dev, sizeof(*pinctrl), GFP_KERNEL);\n\tpins = devm_kcalloc(&pdev->dev, num_gpios,\n\t\tsizeof(struct pinctrl_pin_desc), GFP_KERNEL);\n\tgroups = devm_kcalloc(&pdev->dev, num_gpios,\n\t\tsizeof(struct msm_pingroup), GFP_KERNEL);\n\tnames = devm_kcalloc(&pdev->dev, avail_gpios, NAME_SIZE, GFP_KERNEL);\n\n\tif (!pinctrl || !pins || !groups || !names)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = 0; i < num_gpios; i++) {\n\t\tpins[i].number = i;\n\t\tgroups[i].grp.pins = &pins[i].number;\n\t}\n\n\t \n\tfor (i = 0; i < avail_gpios; i++) {\n\t\tunsigned int gpio = gpios[i];\n\n\t\tgroups[gpio].grp.npins = 1;\n\t\tsnprintf(names[i], NAME_SIZE, \"gpio%u\", gpio);\n\t\tpins[gpio].name = names[i];\n\t\tgroups[gpio].grp.name = names[i];\n\n\t\tgroups[gpio].ctl_reg = 0x10000 * gpio;\n\t\tgroups[gpio].io_reg = 0x04 + 0x10000 * gpio;\n\t\tgroups[gpio].intr_cfg_reg = 0x08 + 0x10000 * gpio;\n\t\tgroups[gpio].intr_status_reg = 0x0c + 0x10000 * gpio;\n\t\tgroups[gpio].intr_target_reg = 0x08 + 0x10000 * gpio;\n\n\t\tgroups[gpio].mux_bit = 2;\n\t\tgroups[gpio].pull_bit = 0;\n\t\tgroups[gpio].drv_bit = 6;\n\t\tgroups[gpio].oe_bit = 9;\n\t\tgroups[gpio].in_bit = 0;\n\t\tgroups[gpio].out_bit = 1;\n\t\tgroups[gpio].intr_enable_bit = 0;\n\t\tgroups[gpio].intr_status_bit = 0;\n\t\tgroups[gpio].intr_target_bit = 5;\n\t\tgroups[gpio].intr_target_kpss_val = 1;\n\t\tgroups[gpio].intr_raw_status_bit = 4;\n\t\tgroups[gpio].intr_polarity_bit = 1;\n\t\tgroups[gpio].intr_detection_bit = 2;\n\t\tgroups[gpio].intr_detection_width = 2;\n\t}\n\n\tpinctrl->pins = pins;\n\tpinctrl->groups = groups;\n\tpinctrl->npins = num_gpios;\n\tpinctrl->ngroups = num_gpios;\n\tpinctrl->ngpios = num_gpios;\n\n\treturn msm_pinctrl_probe(pdev, pinctrl);\n}\n\nstatic const struct acpi_device_id qdf2xxx_acpi_ids[] = {\n\t{\"QCOM8002\"},\n\t{},\n};\nMODULE_DEVICE_TABLE(acpi, qdf2xxx_acpi_ids);\n\nstatic struct platform_driver qdf2xxx_pinctrl_driver = {\n\t.driver = {\n\t\t.name = \"qdf2xxx-pinctrl\",\n\t\t.acpi_match_table = qdf2xxx_acpi_ids,\n\t},\n\t.probe = qdf2xxx_pinctrl_probe,\n\t.remove = msm_pinctrl_remove,\n};\n\nstatic int __init qdf2xxx_pinctrl_init(void)\n{\n\treturn platform_driver_register(&qdf2xxx_pinctrl_driver);\n}\narch_initcall(qdf2xxx_pinctrl_init);\n\nstatic void __exit qdf2xxx_pinctrl_exit(void)\n{\n\tplatform_driver_unregister(&qdf2xxx_pinctrl_driver);\n}\nmodule_exit(qdf2xxx_pinctrl_exit);\n\nMODULE_DESCRIPTION(\"Qualcomm Technologies QDF2xxx pin control driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}