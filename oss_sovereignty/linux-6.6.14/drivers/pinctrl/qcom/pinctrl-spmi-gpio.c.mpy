{
  "module_name": "pinctrl-spmi-gpio.c",
  "hash_id": "2c297c3086ca4fe6e020920106f2c50ffe3ac17fb7a2ed07830e6ba5f9f7dc84",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/qcom/pinctrl-spmi-gpio.c",
  "human_readable_source": "\n \n\n#include <linux/gpio/driver.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/spmi.h>\n#include <linux/types.h>\n\n#include <linux/pinctrl/pinconf-generic.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinmux.h>\n\n#include <dt-bindings/pinctrl/qcom,pmic-gpio.h>\n\n#include \"../core.h\"\n#include \"../pinctrl-utils.h\"\n\n#define PMIC_GPIO_ADDRESS_RANGE\t\t\t0x100\n\n \n#define PMIC_GPIO_REG_TYPE\t\t\t0x4\n#define PMIC_GPIO_REG_SUBTYPE\t\t\t0x5\n\n \n#define PMIC_GPIO_TYPE\t\t\t\t0x10\n#define PMIC_GPIO_SUBTYPE_GPIO_4CH\t\t0x1\n#define PMIC_GPIO_SUBTYPE_GPIOC_4CH\t\t0x5\n#define PMIC_GPIO_SUBTYPE_GPIO_8CH\t\t0x9\n#define PMIC_GPIO_SUBTYPE_GPIOC_8CH\t\t0xd\n#define PMIC_GPIO_SUBTYPE_GPIO_LV\t\t0x10\n#define PMIC_GPIO_SUBTYPE_GPIO_MV\t\t0x11\n#define PMIC_GPIO_SUBTYPE_GPIO_LV_VIN2\t\t0x12\n#define PMIC_GPIO_SUBTYPE_GPIO_MV_VIN3\t\t0x13\n\n#define PMIC_MPP_REG_RT_STS\t\t\t0x10\n#define PMIC_MPP_REG_RT_STS_VAL_MASK\t\t0x1\n\n \n#define PMIC_GPIO_REG_MODE_CTL\t\t\t0x40\n#define PMIC_GPIO_REG_DIG_VIN_CTL\t\t0x41\n#define PMIC_GPIO_REG_DIG_PULL_CTL\t\t0x42\n#define PMIC_GPIO_REG_LV_MV_DIG_OUT_SOURCE_CTL\t0x44\n#define PMIC_GPIO_REG_DIG_IN_CTL\t\t0x43\n#define PMIC_GPIO_REG_DIG_OUT_CTL\t\t0x45\n#define PMIC_GPIO_REG_EN_CTL\t\t\t0x46\n#define PMIC_GPIO_REG_LV_MV_ANA_PASS_THRU_SEL\t0x4A\n\n \n#define PMIC_GPIO_REG_MODE_VALUE_SHIFT\t\t0x1\n#define PMIC_GPIO_REG_MODE_FUNCTION_SHIFT\t1\n#define PMIC_GPIO_REG_MODE_FUNCTION_MASK\t0x7\n#define PMIC_GPIO_REG_MODE_DIR_SHIFT\t\t4\n#define PMIC_GPIO_REG_MODE_DIR_MASK\t\t0x7\n\n#define PMIC_GPIO_MODE_DIGITAL_INPUT\t\t0\n#define PMIC_GPIO_MODE_DIGITAL_OUTPUT\t\t1\n#define PMIC_GPIO_MODE_DIGITAL_INPUT_OUTPUT\t2\n#define PMIC_GPIO_MODE_ANALOG_PASS_THRU\t\t3\n#define PMIC_GPIO_REG_LV_MV_MODE_DIR_MASK\t0x3\n\n \n#define PMIC_GPIO_REG_VIN_SHIFT\t\t\t0\n#define PMIC_GPIO_REG_VIN_MASK\t\t\t0x7\n\n \n#define PMIC_GPIO_REG_PULL_SHIFT\t\t0\n#define PMIC_GPIO_REG_PULL_MASK\t\t\t0x7\n\n#define PMIC_GPIO_PULL_DOWN\t\t\t4\n#define PMIC_GPIO_PULL_DISABLE\t\t\t5\n\n \n#define PMIC_GPIO_LV_MV_OUTPUT_INVERT\t\t0x80\n#define PMIC_GPIO_LV_MV_OUTPUT_INVERT_SHIFT\t7\n#define PMIC_GPIO_LV_MV_OUTPUT_SOURCE_SEL_MASK\t0xF\n\n \n#define PMIC_GPIO_LV_MV_DIG_IN_DTEST_EN\t\t0x80\n#define PMIC_GPIO_LV_MV_DIG_IN_DTEST_SEL_MASK\t0x7\n#define PMIC_GPIO_DIG_IN_DTEST_SEL_MASK\t\t0xf\n\n \n#define PMIC_GPIO_REG_OUT_STRENGTH_SHIFT\t0\n#define PMIC_GPIO_REG_OUT_STRENGTH_MASK\t\t0x3\n#define PMIC_GPIO_REG_OUT_TYPE_SHIFT\t\t4\n#define PMIC_GPIO_REG_OUT_TYPE_MASK\t\t0x3\n\n \n#define PMIC_GPIO_OUT_BUF_CMOS\t\t\t0\n#define PMIC_GPIO_OUT_BUF_OPEN_DRAIN_NMOS\t1\n#define PMIC_GPIO_OUT_BUF_OPEN_DRAIN_PMOS\t2\n\n#define PMIC_GPIO_OUT_STRENGTH_LOW\t\t1\n#define PMIC_GPIO_OUT_STRENGTH_HIGH\t\t3\n\n \n#define PMIC_GPIO_REG_MASTER_EN_SHIFT\t\t7\n\n#define PMIC_GPIO_PHYSICAL_OFFSET\t\t1\n\n \n#define PMIC_GPIO_LV_MV_ANA_MUX_SEL_MASK\t\t0x3\n\n \n#define PMIC_GPIO_CONF_PULL_UP\t\t\t(PIN_CONFIG_END + 1)\n#define PMIC_GPIO_CONF_STRENGTH\t\t\t(PIN_CONFIG_END + 2)\n#define PMIC_GPIO_CONF_ATEST\t\t\t(PIN_CONFIG_END + 3)\n#define PMIC_GPIO_CONF_ANALOG_PASS\t\t(PIN_CONFIG_END + 4)\n#define PMIC_GPIO_CONF_DTEST_BUFFER\t\t(PIN_CONFIG_END + 5)\n\n \nenum pmic_gpio_func_index {\n\tPMIC_GPIO_FUNC_INDEX_NORMAL,\n\tPMIC_GPIO_FUNC_INDEX_PAIRED,\n\tPMIC_GPIO_FUNC_INDEX_FUNC1,\n\tPMIC_GPIO_FUNC_INDEX_FUNC2,\n\tPMIC_GPIO_FUNC_INDEX_FUNC3,\n\tPMIC_GPIO_FUNC_INDEX_FUNC4,\n\tPMIC_GPIO_FUNC_INDEX_DTEST1,\n\tPMIC_GPIO_FUNC_INDEX_DTEST2,\n\tPMIC_GPIO_FUNC_INDEX_DTEST3,\n\tPMIC_GPIO_FUNC_INDEX_DTEST4,\n};\n\n \nstruct pmic_gpio_pad {\n\tu16\t\tbase;\n\tbool\t\tis_enabled;\n\tbool\t\tout_value;\n\tbool\t\thave_buffer;\n\tbool\t\toutput_enabled;\n\tbool\t\tinput_enabled;\n\tbool\t\tanalog_pass;\n\tbool\t\tlv_mv_type;\n\tunsigned int\tnum_sources;\n\tunsigned int\tpower_source;\n\tunsigned int\tbuffer_type;\n\tunsigned int\tpullup;\n\tunsigned int\tstrength;\n\tunsigned int\tfunction;\n\tunsigned int\tatest;\n\tunsigned int\tdtest_buffer;\n};\n\nstruct pmic_gpio_state {\n\tstruct device\t*dev;\n\tstruct regmap\t*map;\n\tstruct pinctrl_dev *ctrl;\n\tstruct gpio_chip chip;\n\tu8 usid;\n\tu8 pid_base;\n};\n\nstatic const struct pinconf_generic_params pmic_gpio_bindings[] = {\n\t{\"qcom,pull-up-strength\",\tPMIC_GPIO_CONF_PULL_UP,\t\t0},\n\t{\"qcom,drive-strength\",\t\tPMIC_GPIO_CONF_STRENGTH,\t0},\n\t{\"qcom,atest\",\t\t\tPMIC_GPIO_CONF_ATEST,\t\t0},\n\t{\"qcom,analog-pass\",\t\tPMIC_GPIO_CONF_ANALOG_PASS,\t0},\n\t{\"qcom,dtest-buffer\",           PMIC_GPIO_CONF_DTEST_BUFFER,    0},\n};\n\n#ifdef CONFIG_DEBUG_FS\nstatic const struct pin_config_item pmic_conf_items[ARRAY_SIZE(pmic_gpio_bindings)] = {\n\tPCONFDUMP(PMIC_GPIO_CONF_PULL_UP,  \"pull up strength\", NULL, true),\n\tPCONFDUMP(PMIC_GPIO_CONF_STRENGTH, \"drive-strength\", NULL, true),\n\tPCONFDUMP(PMIC_GPIO_CONF_ATEST, \"atest\", NULL, true),\n\tPCONFDUMP(PMIC_GPIO_CONF_ANALOG_PASS, \"analog-pass\", NULL, true),\n\tPCONFDUMP(PMIC_GPIO_CONF_DTEST_BUFFER, \"dtest-buffer\", NULL, true),\n};\n#endif\n\nstatic const char *const pmic_gpio_groups[] = {\n\t\"gpio1\", \"gpio2\", \"gpio3\", \"gpio4\", \"gpio5\", \"gpio6\", \"gpio7\", \"gpio8\",\n\t\"gpio9\", \"gpio10\", \"gpio11\", \"gpio12\", \"gpio13\", \"gpio14\", \"gpio15\",\n\t\"gpio16\", \"gpio17\", \"gpio18\", \"gpio19\", \"gpio20\", \"gpio21\", \"gpio22\",\n\t\"gpio23\", \"gpio24\", \"gpio25\", \"gpio26\", \"gpio27\", \"gpio28\", \"gpio29\",\n\t\"gpio30\", \"gpio31\", \"gpio32\", \"gpio33\", \"gpio34\", \"gpio35\", \"gpio36\",\n};\n\nstatic const char *const pmic_gpio_functions[] = {\n\t[PMIC_GPIO_FUNC_INDEX_NORMAL]\t= PMIC_GPIO_FUNC_NORMAL,\n\t[PMIC_GPIO_FUNC_INDEX_PAIRED]\t= PMIC_GPIO_FUNC_PAIRED,\n\t[PMIC_GPIO_FUNC_INDEX_FUNC1]\t= PMIC_GPIO_FUNC_FUNC1,\n\t[PMIC_GPIO_FUNC_INDEX_FUNC2]\t= PMIC_GPIO_FUNC_FUNC2,\n\t[PMIC_GPIO_FUNC_INDEX_FUNC3]\t= PMIC_GPIO_FUNC_FUNC3,\n\t[PMIC_GPIO_FUNC_INDEX_FUNC4]\t= PMIC_GPIO_FUNC_FUNC4,\n\t[PMIC_GPIO_FUNC_INDEX_DTEST1]\t= PMIC_GPIO_FUNC_DTEST1,\n\t[PMIC_GPIO_FUNC_INDEX_DTEST2]\t= PMIC_GPIO_FUNC_DTEST2,\n\t[PMIC_GPIO_FUNC_INDEX_DTEST3]\t= PMIC_GPIO_FUNC_DTEST3,\n\t[PMIC_GPIO_FUNC_INDEX_DTEST4]\t= PMIC_GPIO_FUNC_DTEST4,\n};\n\nstatic int pmic_gpio_read(struct pmic_gpio_state *state,\n\t\t\t  struct pmic_gpio_pad *pad, unsigned int addr)\n{\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read(state->map, pad->base + addr, &val);\n\tif (ret < 0)\n\t\tdev_err(state->dev, \"read 0x%x failed\\n\", addr);\n\telse\n\t\tret = val;\n\n\treturn ret;\n}\n\nstatic int pmic_gpio_write(struct pmic_gpio_state *state,\n\t\t\t   struct pmic_gpio_pad *pad, unsigned int addr,\n\t\t\t   unsigned int val)\n{\n\tint ret;\n\n\tret = regmap_write(state->map, pad->base + addr, val);\n\tif (ret < 0)\n\t\tdev_err(state->dev, \"write 0x%x failed\\n\", addr);\n\n\treturn ret;\n}\n\nstatic int pmic_gpio_get_groups_count(struct pinctrl_dev *pctldev)\n{\n\t \n\treturn pctldev->desc->npins;\n}\n\nstatic const char *pmic_gpio_get_group_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t    unsigned pin)\n{\n\treturn pctldev->desc->pins[pin].name;\n}\n\nstatic int pmic_gpio_get_group_pins(struct pinctrl_dev *pctldev, unsigned pin,\n\t\t\t\t    const unsigned **pins, unsigned *num_pins)\n{\n\t*pins = &pctldev->desc->pins[pin].number;\n\t*num_pins = 1;\n\treturn 0;\n}\n\nstatic const struct pinctrl_ops pmic_gpio_pinctrl_ops = {\n\t.get_groups_count\t= pmic_gpio_get_groups_count,\n\t.get_group_name\t\t= pmic_gpio_get_group_name,\n\t.get_group_pins\t\t= pmic_gpio_get_group_pins,\n\t.dt_node_to_map\t\t= pinconf_generic_dt_node_to_map_group,\n\t.dt_free_map\t\t= pinctrl_utils_free_map,\n};\n\nstatic int pmic_gpio_get_functions_count(struct pinctrl_dev *pctldev)\n{\n\treturn ARRAY_SIZE(pmic_gpio_functions);\n}\n\nstatic const char *pmic_gpio_get_function_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t       unsigned function)\n{\n\treturn pmic_gpio_functions[function];\n}\n\nstatic int pmic_gpio_get_function_groups(struct pinctrl_dev *pctldev,\n\t\t\t\t\t unsigned function,\n\t\t\t\t\t const char *const **groups,\n\t\t\t\t\t unsigned *const num_qgroups)\n{\n\t*groups = pmic_gpio_groups;\n\t*num_qgroups = pctldev->desc->npins;\n\treturn 0;\n}\n\nstatic int pmic_gpio_set_mux(struct pinctrl_dev *pctldev, unsigned function,\n\t\t\t\tunsigned pin)\n{\n\tstruct pmic_gpio_state *state = pinctrl_dev_get_drvdata(pctldev);\n\tstruct pmic_gpio_pad *pad;\n\tunsigned int val;\n\tint ret;\n\n\tif (function > PMIC_GPIO_FUNC_INDEX_DTEST4) {\n\t\tpr_err(\"function: %d is not defined\\n\", function);\n\t\treturn -EINVAL;\n\t}\n\n\tpad = pctldev->desc->pins[pin].drv_data;\n\t \n\tif (!pad->lv_mv_type) {\n\t\tif (function == PMIC_GPIO_FUNC_INDEX_FUNC3 ||\n\t\t\t\tfunction == PMIC_GPIO_FUNC_INDEX_FUNC4) {\n\t\t\tpr_err(\"LV/MV subtype doesn't have func3/func4\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (function >= PMIC_GPIO_FUNC_INDEX_DTEST1)\n\t\t\tfunction -= (PMIC_GPIO_FUNC_INDEX_DTEST1 -\n\t\t\t\t\tPMIC_GPIO_FUNC_INDEX_FUNC3);\n\t}\n\n\tpad->function = function;\n\n\tif (pad->analog_pass)\n\t\tval = PMIC_GPIO_MODE_ANALOG_PASS_THRU;\n\telse if (pad->output_enabled && pad->input_enabled)\n\t\tval = PMIC_GPIO_MODE_DIGITAL_INPUT_OUTPUT;\n\telse if (pad->output_enabled)\n\t\tval = PMIC_GPIO_MODE_DIGITAL_OUTPUT;\n\telse\n\t\tval = PMIC_GPIO_MODE_DIGITAL_INPUT;\n\n\tif (pad->lv_mv_type) {\n\t\tret = pmic_gpio_write(state, pad,\n\t\t\t\tPMIC_GPIO_REG_MODE_CTL, val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tval = pad->atest - 1;\n\t\tret = pmic_gpio_write(state, pad,\n\t\t\t\tPMIC_GPIO_REG_LV_MV_ANA_PASS_THRU_SEL, val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tval = pad->out_value\n\t\t\t<< PMIC_GPIO_LV_MV_OUTPUT_INVERT_SHIFT;\n\t\tval |= pad->function\n\t\t\t& PMIC_GPIO_LV_MV_OUTPUT_SOURCE_SEL_MASK;\n\t\tret = pmic_gpio_write(state, pad,\n\t\t\tPMIC_GPIO_REG_LV_MV_DIG_OUT_SOURCE_CTL, val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tval = val << PMIC_GPIO_REG_MODE_DIR_SHIFT;\n\t\tval |= pad->function << PMIC_GPIO_REG_MODE_FUNCTION_SHIFT;\n\t\tval |= pad->out_value & PMIC_GPIO_REG_MODE_VALUE_SHIFT;\n\n\t\tret = pmic_gpio_write(state, pad, PMIC_GPIO_REG_MODE_CTL, val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tval = pad->is_enabled << PMIC_GPIO_REG_MASTER_EN_SHIFT;\n\n\treturn pmic_gpio_write(state, pad, PMIC_GPIO_REG_EN_CTL, val);\n}\n\nstatic const struct pinmux_ops pmic_gpio_pinmux_ops = {\n\t.get_functions_count\t= pmic_gpio_get_functions_count,\n\t.get_function_name\t= pmic_gpio_get_function_name,\n\t.get_function_groups\t= pmic_gpio_get_function_groups,\n\t.set_mux\t\t= pmic_gpio_set_mux,\n};\n\nstatic int pmic_gpio_config_get(struct pinctrl_dev *pctldev,\n\t\t\t\tunsigned int pin, unsigned long *config)\n{\n\tunsigned param = pinconf_to_config_param(*config);\n\tstruct pmic_gpio_pad *pad;\n\tunsigned arg;\n\n\tpad = pctldev->desc->pins[pin].drv_data;\n\n\tswitch (param) {\n\tcase PIN_CONFIG_DRIVE_PUSH_PULL:\n\t\tif (pad->buffer_type != PMIC_GPIO_OUT_BUF_CMOS)\n\t\t\treturn -EINVAL;\n\t\targ = 1;\n\t\tbreak;\n\tcase PIN_CONFIG_DRIVE_OPEN_DRAIN:\n\t\tif (pad->buffer_type != PMIC_GPIO_OUT_BUF_OPEN_DRAIN_NMOS)\n\t\t\treturn -EINVAL;\n\t\targ = 1;\n\t\tbreak;\n\tcase PIN_CONFIG_DRIVE_OPEN_SOURCE:\n\t\tif (pad->buffer_type != PMIC_GPIO_OUT_BUF_OPEN_DRAIN_PMOS)\n\t\t\treturn -EINVAL;\n\t\targ = 1;\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\tif (pad->pullup != PMIC_GPIO_PULL_DOWN)\n\t\t\treturn -EINVAL;\n\t\targ = 1;\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\tif (pad->pullup != PMIC_GPIO_PULL_DISABLE)\n\t\t\treturn -EINVAL;\n\t\targ = 1;\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\tif (pad->pullup != PMIC_GPIO_PULL_UP_30)\n\t\t\treturn -EINVAL;\n\t\targ = 1;\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_HIGH_IMPEDANCE:\n\t\tif (pad->is_enabled)\n\t\t\treturn -EINVAL;\n\t\targ = 1;\n\t\tbreak;\n\tcase PIN_CONFIG_POWER_SOURCE:\n\t\targ = pad->power_source;\n\t\tbreak;\n\tcase PIN_CONFIG_INPUT_ENABLE:\n\t\tif (!pad->input_enabled)\n\t\t\treturn -EINVAL;\n\t\targ = 1;\n\t\tbreak;\n\tcase PIN_CONFIG_OUTPUT_ENABLE:\n\t\targ = pad->output_enabled;\n\t\tbreak;\n\tcase PIN_CONFIG_OUTPUT:\n\t\targ = pad->out_value;\n\t\tbreak;\n\tcase PMIC_GPIO_CONF_PULL_UP:\n\t\targ = pad->pullup;\n\t\tbreak;\n\tcase PMIC_GPIO_CONF_STRENGTH:\n\t\tswitch (pad->strength) {\n\t\tcase PMIC_GPIO_OUT_STRENGTH_HIGH:\n\t\t\targ = PMIC_GPIO_STRENGTH_HIGH;\n\t\t\tbreak;\n\t\tcase PMIC_GPIO_OUT_STRENGTH_LOW:\n\t\t\targ = PMIC_GPIO_STRENGTH_LOW;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\targ = pad->strength;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase PMIC_GPIO_CONF_ATEST:\n\t\targ = pad->atest;\n\t\tbreak;\n\tcase PMIC_GPIO_CONF_ANALOG_PASS:\n\t\targ = pad->analog_pass;\n\t\tbreak;\n\tcase PMIC_GPIO_CONF_DTEST_BUFFER:\n\t\targ = pad->dtest_buffer;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t*config = pinconf_to_config_packed(param, arg);\n\treturn 0;\n}\n\nstatic int pmic_gpio_config_set(struct pinctrl_dev *pctldev, unsigned int pin,\n\t\t\t\tunsigned long *configs, unsigned nconfs)\n{\n\tstruct pmic_gpio_state *state = pinctrl_dev_get_drvdata(pctldev);\n\tstruct pmic_gpio_pad *pad;\n\tunsigned param, arg;\n\tunsigned int val;\n\tint i, ret;\n\n\tpad = pctldev->desc->pins[pin].drv_data;\n\n\tpad->is_enabled = true;\n\tfor (i = 0; i < nconfs; i++) {\n\t\tparam = pinconf_to_config_param(configs[i]);\n\t\targ = pinconf_to_config_argument(configs[i]);\n\n\t\tswitch (param) {\n\t\tcase PIN_CONFIG_DRIVE_PUSH_PULL:\n\t\t\tpad->buffer_type = PMIC_GPIO_OUT_BUF_CMOS;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_DRIVE_OPEN_DRAIN:\n\t\t\tif (!pad->have_buffer)\n\t\t\t\treturn -EINVAL;\n\t\t\tpad->buffer_type = PMIC_GPIO_OUT_BUF_OPEN_DRAIN_NMOS;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_DRIVE_OPEN_SOURCE:\n\t\t\tif (!pad->have_buffer)\n\t\t\t\treturn -EINVAL;\n\t\t\tpad->buffer_type = PMIC_GPIO_OUT_BUF_OPEN_DRAIN_PMOS;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\t\tpad->pullup = PMIC_GPIO_PULL_DISABLE;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\t\tpad->pullup = PMIC_GPIO_PULL_UP_30;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\t\tif (arg)\n\t\t\t\tpad->pullup = PMIC_GPIO_PULL_DOWN;\n\t\t\telse\n\t\t\t\tpad->pullup = PMIC_GPIO_PULL_DISABLE;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_BIAS_HIGH_IMPEDANCE:\n\t\t\tpad->is_enabled = false;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_POWER_SOURCE:\n\t\t\tif (arg >= pad->num_sources)\n\t\t\t\treturn -EINVAL;\n\t\t\tpad->power_source = arg;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_INPUT_ENABLE:\n\t\t\tpad->input_enabled = arg ? true : false;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_OUTPUT_ENABLE:\n\t\t\tpad->output_enabled = arg ? true : false;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_OUTPUT:\n\t\t\tpad->output_enabled = true;\n\t\t\tpad->out_value = arg;\n\t\t\tbreak;\n\t\tcase PMIC_GPIO_CONF_PULL_UP:\n\t\t\tif (arg > PMIC_GPIO_PULL_UP_1P5_30)\n\t\t\t\treturn -EINVAL;\n\t\t\tpad->pullup = arg;\n\t\t\tbreak;\n\t\tcase PMIC_GPIO_CONF_STRENGTH:\n\t\t\tif (arg > PMIC_GPIO_STRENGTH_LOW)\n\t\t\t\treturn -EINVAL;\n\t\t\tswitch (arg) {\n\t\t\tcase PMIC_GPIO_STRENGTH_HIGH:\n\t\t\t\tpad->strength = PMIC_GPIO_OUT_STRENGTH_HIGH;\n\t\t\t\tbreak;\n\t\t\tcase PMIC_GPIO_STRENGTH_LOW:\n\t\t\t\tpad->strength = PMIC_GPIO_OUT_STRENGTH_LOW;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpad->strength = arg;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PMIC_GPIO_CONF_ATEST:\n\t\t\tif (!pad->lv_mv_type || arg > 4)\n\t\t\t\treturn -EINVAL;\n\t\t\tpad->atest = arg;\n\t\t\tbreak;\n\t\tcase PMIC_GPIO_CONF_ANALOG_PASS:\n\t\t\tif (!pad->lv_mv_type)\n\t\t\t\treturn -EINVAL;\n\t\t\tpad->analog_pass = true;\n\t\t\tbreak;\n\t\tcase PMIC_GPIO_CONF_DTEST_BUFFER:\n\t\t\tif (arg > 4)\n\t\t\t\treturn -EINVAL;\n\t\t\tpad->dtest_buffer = arg;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tval = pad->power_source << PMIC_GPIO_REG_VIN_SHIFT;\n\n\tret = pmic_gpio_write(state, pad, PMIC_GPIO_REG_DIG_VIN_CTL, val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tval = pad->pullup << PMIC_GPIO_REG_PULL_SHIFT;\n\n\tret = pmic_gpio_write(state, pad, PMIC_GPIO_REG_DIG_PULL_CTL, val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tval = pad->buffer_type << PMIC_GPIO_REG_OUT_TYPE_SHIFT;\n\tval |= pad->strength << PMIC_GPIO_REG_OUT_STRENGTH_SHIFT;\n\n\tret = pmic_gpio_write(state, pad, PMIC_GPIO_REG_DIG_OUT_CTL, val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (pad->dtest_buffer == 0) {\n\t\tval = 0;\n\t} else {\n\t\tif (pad->lv_mv_type) {\n\t\t\tval = pad->dtest_buffer - 1;\n\t\t\tval |= PMIC_GPIO_LV_MV_DIG_IN_DTEST_EN;\n\t\t} else {\n\t\t\tval = BIT(pad->dtest_buffer - 1);\n\t\t}\n\t}\n\tret = pmic_gpio_write(state, pad, PMIC_GPIO_REG_DIG_IN_CTL, val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (pad->analog_pass)\n\t\tval = PMIC_GPIO_MODE_ANALOG_PASS_THRU;\n\telse if (pad->output_enabled && pad->input_enabled)\n\t\tval = PMIC_GPIO_MODE_DIGITAL_INPUT_OUTPUT;\n\telse if (pad->output_enabled)\n\t\tval = PMIC_GPIO_MODE_DIGITAL_OUTPUT;\n\telse\n\t\tval = PMIC_GPIO_MODE_DIGITAL_INPUT;\n\n\tif (pad->lv_mv_type) {\n\t\tret = pmic_gpio_write(state, pad,\n\t\t\t\tPMIC_GPIO_REG_MODE_CTL, val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tval = pad->atest - 1;\n\t\tret = pmic_gpio_write(state, pad,\n\t\t\t\tPMIC_GPIO_REG_LV_MV_ANA_PASS_THRU_SEL, val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tval = pad->out_value\n\t\t\t<< PMIC_GPIO_LV_MV_OUTPUT_INVERT_SHIFT;\n\t\tval |= pad->function\n\t\t\t& PMIC_GPIO_LV_MV_OUTPUT_SOURCE_SEL_MASK;\n\t\tret = pmic_gpio_write(state, pad,\n\t\t\tPMIC_GPIO_REG_LV_MV_DIG_OUT_SOURCE_CTL, val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tval = val << PMIC_GPIO_REG_MODE_DIR_SHIFT;\n\t\tval |= pad->function << PMIC_GPIO_REG_MODE_FUNCTION_SHIFT;\n\t\tval |= pad->out_value & PMIC_GPIO_REG_MODE_VALUE_SHIFT;\n\n\t\tret = pmic_gpio_write(state, pad, PMIC_GPIO_REG_MODE_CTL, val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tval = pad->is_enabled << PMIC_GPIO_REG_MASTER_EN_SHIFT;\n\n\tret = pmic_gpio_write(state, pad, PMIC_GPIO_REG_EN_CTL, val);\n\n\treturn ret;\n}\n\nstatic void pmic_gpio_config_dbg_show(struct pinctrl_dev *pctldev,\n\t\t\t\t      struct seq_file *s, unsigned pin)\n{\n\tstruct pmic_gpio_state *state = pinctrl_dev_get_drvdata(pctldev);\n\tstruct pmic_gpio_pad *pad;\n\tint ret, val, function;\n\n\tstatic const char *const biases[] = {\n\t\t\"pull-up 30uA\", \"pull-up 1.5uA\", \"pull-up 31.5uA\",\n\t\t\"pull-up 1.5uA + 30uA boost\", \"pull-down 10uA\", \"no pull\"\n\t};\n\tstatic const char *const buffer_types[] = {\n\t\t\"push-pull\", \"open-drain\", \"open-source\"\n\t};\n\tstatic const char *const strengths[] = {\n\t\t\"no\", \"high\", \"medium\", \"low\"\n\t};\n\n\tpad = pctldev->desc->pins[pin].drv_data;\n\n\tseq_printf(s, \" gpio%-2d:\", pin + PMIC_GPIO_PHYSICAL_OFFSET);\n\n\tval = pmic_gpio_read(state, pad, PMIC_GPIO_REG_EN_CTL);\n\n\tif (val < 0 || !(val >> PMIC_GPIO_REG_MASTER_EN_SHIFT)) {\n\t\tseq_puts(s, \" ---\");\n\t} else {\n\t\tif (pad->input_enabled) {\n\t\t\tret = pmic_gpio_read(state, pad, PMIC_MPP_REG_RT_STS);\n\t\t\tif (ret < 0)\n\t\t\t\treturn;\n\n\t\t\tret &= PMIC_MPP_REG_RT_STS_VAL_MASK;\n\t\t\tpad->out_value = ret;\n\t\t}\n\t\t \n\t\tfunction = pad->function;\n\t\tif (!pad->lv_mv_type &&\n\t\t\t\tpad->function >= PMIC_GPIO_FUNC_INDEX_FUNC3)\n\t\t\tfunction += PMIC_GPIO_FUNC_INDEX_DTEST1 -\n\t\t\t\tPMIC_GPIO_FUNC_INDEX_FUNC3;\n\n\t\tif (pad->analog_pass)\n\t\t\tseq_puts(s, \" analog-pass\");\n\t\telse\n\t\t\tseq_printf(s, \" %-4s\",\n\t\t\t\t\tpad->output_enabled ? \"out\" : \"in\");\n\t\tseq_printf(s, \" %-4s\", pad->out_value ? \"high\" : \"low\");\n\t\tseq_printf(s, \" %-7s\", pmic_gpio_functions[function]);\n\t\tseq_printf(s, \" vin-%d\", pad->power_source);\n\t\tseq_printf(s, \" %-27s\", biases[pad->pullup]);\n\t\tseq_printf(s, \" %-10s\", buffer_types[pad->buffer_type]);\n\t\tseq_printf(s, \" %-7s\", strengths[pad->strength]);\n\t\tseq_printf(s, \" atest-%d\", pad->atest);\n\t\tseq_printf(s, \" dtest-%d\", pad->dtest_buffer);\n\t}\n}\n\nstatic const struct pinconf_ops pmic_gpio_pinconf_ops = {\n\t.is_generic\t\t\t= true,\n\t.pin_config_group_get\t\t= pmic_gpio_config_get,\n\t.pin_config_group_set\t\t= pmic_gpio_config_set,\n\t.pin_config_group_dbg_show\t= pmic_gpio_config_dbg_show,\n};\n\nstatic int pmic_gpio_direction_input(struct gpio_chip *chip, unsigned pin)\n{\n\tstruct pmic_gpio_state *state = gpiochip_get_data(chip);\n\tunsigned long config;\n\n\tconfig = pinconf_to_config_packed(PIN_CONFIG_INPUT_ENABLE, 1);\n\n\treturn pmic_gpio_config_set(state->ctrl, pin, &config, 1);\n}\n\nstatic int pmic_gpio_direction_output(struct gpio_chip *chip,\n\t\t\t\t      unsigned pin, int val)\n{\n\tstruct pmic_gpio_state *state = gpiochip_get_data(chip);\n\tunsigned long config;\n\n\tconfig = pinconf_to_config_packed(PIN_CONFIG_OUTPUT, val);\n\n\treturn pmic_gpio_config_set(state->ctrl, pin, &config, 1);\n}\n\nstatic int pmic_gpio_get(struct gpio_chip *chip, unsigned pin)\n{\n\tstruct pmic_gpio_state *state = gpiochip_get_data(chip);\n\tstruct pmic_gpio_pad *pad;\n\tint ret;\n\n\tpad = state->ctrl->desc->pins[pin].drv_data;\n\n\tif (!pad->is_enabled)\n\t\treturn -EINVAL;\n\n\tif (pad->input_enabled) {\n\t\tret = pmic_gpio_read(state, pad, PMIC_MPP_REG_RT_STS);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tpad->out_value = ret & PMIC_MPP_REG_RT_STS_VAL_MASK;\n\t}\n\n\treturn !!pad->out_value;\n}\n\nstatic void pmic_gpio_set(struct gpio_chip *chip, unsigned pin, int value)\n{\n\tstruct pmic_gpio_state *state = gpiochip_get_data(chip);\n\tunsigned long config;\n\n\tconfig = pinconf_to_config_packed(PIN_CONFIG_OUTPUT, value);\n\n\tpmic_gpio_config_set(state->ctrl, pin, &config, 1);\n}\n\nstatic int pmic_gpio_of_xlate(struct gpio_chip *chip,\n\t\t\t      const struct of_phandle_args *gpio_desc,\n\t\t\t      u32 *flags)\n{\n\tif (chip->of_gpio_n_cells < 2)\n\t\treturn -EINVAL;\n\n\tif (flags)\n\t\t*flags = gpio_desc->args[1];\n\n\treturn gpio_desc->args[0] - PMIC_GPIO_PHYSICAL_OFFSET;\n}\n\nstatic void pmic_gpio_dbg_show(struct seq_file *s, struct gpio_chip *chip)\n{\n\tstruct pmic_gpio_state *state = gpiochip_get_data(chip);\n\tunsigned i;\n\n\tfor (i = 0; i < chip->ngpio; i++) {\n\t\tpmic_gpio_config_dbg_show(state->ctrl, s, i);\n\t\tseq_puts(s, \"\\n\");\n\t}\n}\n\nstatic const struct gpio_chip pmic_gpio_gpio_template = {\n\t.direction_input\t= pmic_gpio_direction_input,\n\t.direction_output\t= pmic_gpio_direction_output,\n\t.get\t\t\t= pmic_gpio_get,\n\t.set\t\t\t= pmic_gpio_set,\n\t.request\t\t= gpiochip_generic_request,\n\t.free\t\t\t= gpiochip_generic_free,\n\t.of_xlate\t\t= pmic_gpio_of_xlate,\n\t.dbg_show\t\t= pmic_gpio_dbg_show,\n};\n\nstatic int pmic_gpio_populate(struct pmic_gpio_state *state,\n\t\t\t      struct pmic_gpio_pad *pad)\n{\n\tint type, subtype, val, dir;\n\n\ttype = pmic_gpio_read(state, pad, PMIC_GPIO_REG_TYPE);\n\tif (type < 0)\n\t\treturn type;\n\n\tif (type != PMIC_GPIO_TYPE) {\n\t\tdev_err(state->dev, \"incorrect block type 0x%x at 0x%x\\n\",\n\t\t\ttype, pad->base);\n\t\treturn -ENODEV;\n\t}\n\n\tsubtype = pmic_gpio_read(state, pad, PMIC_GPIO_REG_SUBTYPE);\n\tif (subtype < 0)\n\t\treturn subtype;\n\n\tswitch (subtype) {\n\tcase PMIC_GPIO_SUBTYPE_GPIO_4CH:\n\t\tpad->have_buffer = true;\n\t\tfallthrough;\n\tcase PMIC_GPIO_SUBTYPE_GPIOC_4CH:\n\t\tpad->num_sources = 4;\n\t\tbreak;\n\tcase PMIC_GPIO_SUBTYPE_GPIO_8CH:\n\t\tpad->have_buffer = true;\n\t\tfallthrough;\n\tcase PMIC_GPIO_SUBTYPE_GPIOC_8CH:\n\t\tpad->num_sources = 8;\n\t\tbreak;\n\tcase PMIC_GPIO_SUBTYPE_GPIO_LV:\n\t\tpad->num_sources = 1;\n\t\tpad->have_buffer = true;\n\t\tpad->lv_mv_type = true;\n\t\tbreak;\n\tcase PMIC_GPIO_SUBTYPE_GPIO_MV:\n\t\tpad->num_sources = 2;\n\t\tpad->have_buffer = true;\n\t\tpad->lv_mv_type = true;\n\t\tbreak;\n\tcase PMIC_GPIO_SUBTYPE_GPIO_LV_VIN2:\n\t\tpad->num_sources = 2;\n\t\tpad->have_buffer = true;\n\t\tpad->lv_mv_type = true;\n\t\tbreak;\n\tcase PMIC_GPIO_SUBTYPE_GPIO_MV_VIN3:\n\t\tpad->num_sources = 3;\n\t\tpad->have_buffer = true;\n\t\tpad->lv_mv_type = true;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(state->dev, \"unknown GPIO type 0x%x\\n\", subtype);\n\t\treturn -ENODEV;\n\t}\n\n\tif (pad->lv_mv_type) {\n\t\tval = pmic_gpio_read(state, pad,\n\t\t\t\tPMIC_GPIO_REG_LV_MV_DIG_OUT_SOURCE_CTL);\n\t\tif (val < 0)\n\t\t\treturn val;\n\n\t\tpad->out_value = !!(val & PMIC_GPIO_LV_MV_OUTPUT_INVERT);\n\t\tpad->function = val & PMIC_GPIO_LV_MV_OUTPUT_SOURCE_SEL_MASK;\n\n\t\tval = pmic_gpio_read(state, pad, PMIC_GPIO_REG_MODE_CTL);\n\t\tif (val < 0)\n\t\t\treturn val;\n\n\t\tdir = val & PMIC_GPIO_REG_LV_MV_MODE_DIR_MASK;\n\t} else {\n\t\tval = pmic_gpio_read(state, pad, PMIC_GPIO_REG_MODE_CTL);\n\t\tif (val < 0)\n\t\t\treturn val;\n\n\t\tpad->out_value = val & PMIC_GPIO_REG_MODE_VALUE_SHIFT;\n\n\t\tdir = val >> PMIC_GPIO_REG_MODE_DIR_SHIFT;\n\t\tdir &= PMIC_GPIO_REG_MODE_DIR_MASK;\n\t\tpad->function = val >> PMIC_GPIO_REG_MODE_FUNCTION_SHIFT;\n\t\tpad->function &= PMIC_GPIO_REG_MODE_FUNCTION_MASK;\n\t}\n\n\tswitch (dir) {\n\tcase PMIC_GPIO_MODE_DIGITAL_INPUT:\n\t\tpad->input_enabled = true;\n\t\tpad->output_enabled = false;\n\t\tbreak;\n\tcase PMIC_GPIO_MODE_DIGITAL_OUTPUT:\n\t\tpad->input_enabled = false;\n\t\tpad->output_enabled = true;\n\t\tbreak;\n\tcase PMIC_GPIO_MODE_DIGITAL_INPUT_OUTPUT:\n\t\tpad->input_enabled = true;\n\t\tpad->output_enabled = true;\n\t\tbreak;\n\tcase PMIC_GPIO_MODE_ANALOG_PASS_THRU:\n\t\tif (!pad->lv_mv_type)\n\t\t\treturn -ENODEV;\n\t\tpad->analog_pass = true;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(state->dev, \"unknown GPIO direction\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tval = pmic_gpio_read(state, pad, PMIC_GPIO_REG_DIG_VIN_CTL);\n\tif (val < 0)\n\t\treturn val;\n\n\tpad->power_source = val >> PMIC_GPIO_REG_VIN_SHIFT;\n\tpad->power_source &= PMIC_GPIO_REG_VIN_MASK;\n\n\tval = pmic_gpio_read(state, pad, PMIC_GPIO_REG_DIG_PULL_CTL);\n\tif (val < 0)\n\t\treturn val;\n\n\tpad->pullup = val >> PMIC_GPIO_REG_PULL_SHIFT;\n\tpad->pullup &= PMIC_GPIO_REG_PULL_MASK;\n\n\tval = pmic_gpio_read(state, pad, PMIC_GPIO_REG_DIG_IN_CTL);\n\tif (val < 0)\n\t\treturn val;\n\n\tif (pad->lv_mv_type && (val & PMIC_GPIO_LV_MV_DIG_IN_DTEST_EN))\n\t\tpad->dtest_buffer =\n\t\t\t(val & PMIC_GPIO_LV_MV_DIG_IN_DTEST_SEL_MASK) + 1;\n\telse if (!pad->lv_mv_type)\n\t\tpad->dtest_buffer = ffs(val);\n\telse\n\t\tpad->dtest_buffer = 0;\n\n\tval = pmic_gpio_read(state, pad, PMIC_GPIO_REG_DIG_OUT_CTL);\n\tif (val < 0)\n\t\treturn val;\n\n\tpad->strength = val >> PMIC_GPIO_REG_OUT_STRENGTH_SHIFT;\n\tpad->strength &= PMIC_GPIO_REG_OUT_STRENGTH_MASK;\n\n\tpad->buffer_type = val >> PMIC_GPIO_REG_OUT_TYPE_SHIFT;\n\tpad->buffer_type &= PMIC_GPIO_REG_OUT_TYPE_MASK;\n\n\tif (pad->lv_mv_type) {\n\t\tval = pmic_gpio_read(state, pad,\n\t\t\t\tPMIC_GPIO_REG_LV_MV_ANA_PASS_THRU_SEL);\n\t\tif (val < 0)\n\t\t\treturn val;\n\t\tpad->atest = (val & PMIC_GPIO_LV_MV_ANA_MUX_SEL_MASK) + 1;\n\t}\n\n\t \n\tpad->is_enabled = true;\n\treturn 0;\n}\n\nstatic int pmic_gpio_domain_translate(struct irq_domain *domain,\n\t\t\t\t      struct irq_fwspec *fwspec,\n\t\t\t\t      unsigned long *hwirq,\n\t\t\t\t      unsigned int *type)\n{\n\tstruct pmic_gpio_state *state = container_of(domain->host_data,\n\t\t\t\t\t\t     struct pmic_gpio_state,\n\t\t\t\t\t\t     chip);\n\n\tif (fwspec->param_count != 2 ||\n\t    fwspec->param[0] < 1 || fwspec->param[0] > state->chip.ngpio)\n\t\treturn -EINVAL;\n\n\t*hwirq = fwspec->param[0] - PMIC_GPIO_PHYSICAL_OFFSET;\n\t*type = fwspec->param[1];\n\n\treturn 0;\n}\n\nstatic unsigned int pmic_gpio_child_offset_to_irq(struct gpio_chip *chip,\n\t\t\t\t\t\t  unsigned int offset)\n{\n\treturn offset + PMIC_GPIO_PHYSICAL_OFFSET;\n}\n\nstatic int pmic_gpio_child_to_parent_hwirq(struct gpio_chip *chip,\n\t\t\t\t\t   unsigned int child_hwirq,\n\t\t\t\t\t   unsigned int child_type,\n\t\t\t\t\t   unsigned int *parent_hwirq,\n\t\t\t\t\t   unsigned int *parent_type)\n{\n\tstruct pmic_gpio_state *state = gpiochip_get_data(chip);\n\n\t*parent_hwirq = child_hwirq + state->pid_base;\n\t*parent_type = child_type;\n\n\treturn 0;\n}\n\nstatic int pmic_gpio_populate_parent_fwspec(struct gpio_chip *chip,\n\t\t\t\t\t    union gpio_irq_fwspec *gfwspec,\n\t\t\t\t\t    unsigned int parent_hwirq,\n\t\t\t\t\t    unsigned int parent_type)\n{\n\tstruct pmic_gpio_state *state = gpiochip_get_data(chip);\n\tstruct irq_fwspec *fwspec = &gfwspec->fwspec;\n\n\tfwspec->fwnode = chip->irq.parent_domain->fwnode;\n\n\tfwspec->param_count = 4;\n\tfwspec->param[0] = state->usid;\n\tfwspec->param[1] = parent_hwirq;\n\t \n\tfwspec->param[3] = parent_type;\n\n\treturn 0;\n}\n\nstatic void pmic_gpio_irq_mask(struct irq_data *data)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(data);\n\n\tirq_chip_mask_parent(data);\n\tgpiochip_disable_irq(gc, data->hwirq);\n}\n\nstatic void pmic_gpio_irq_unmask(struct irq_data *data)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(data);\n\n\tgpiochip_enable_irq(gc, data->hwirq);\n\tirq_chip_unmask_parent(data);\n}\n\nstatic const struct irq_chip spmi_gpio_irq_chip = {\n\t.name\t\t= \"spmi-gpio\",\n\t.irq_ack\t= irq_chip_ack_parent,\n\t.irq_mask\t= pmic_gpio_irq_mask,\n\t.irq_unmask\t= pmic_gpio_irq_unmask,\n\t.irq_set_type\t= irq_chip_set_type_parent,\n\t.irq_set_wake\t= irq_chip_set_wake_parent,\n\t.flags\t\t= IRQCHIP_IMMUTABLE | IRQCHIP_MASK_ON_SUSPEND,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic int pmic_gpio_probe(struct platform_device *pdev)\n{\n\tstruct irq_domain *parent_domain;\n\tstruct device_node *parent_node;\n\tstruct device *dev = &pdev->dev;\n\tstruct pinctrl_pin_desc *pindesc;\n\tstruct pinctrl_desc *pctrldesc;\n\tstruct pmic_gpio_pad *pad, *pads;\n\tstruct pmic_gpio_state *state;\n\tstruct gpio_irq_chip *girq;\n\tconst struct spmi_device *parent_spmi_dev;\n\tint ret, npins, i;\n\tu32 reg;\n\n\tret = of_property_read_u32(dev->of_node, \"reg\", &reg);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"missing base address\");\n\t\treturn ret;\n\t}\n\n\tnpins = (uintptr_t) device_get_match_data(&pdev->dev);\n\n\tstate = devm_kzalloc(dev, sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, state);\n\n\tstate->dev = &pdev->dev;\n\tstate->map = dev_get_regmap(dev->parent, NULL);\n\tparent_spmi_dev = to_spmi_device(dev->parent);\n\tstate->usid = parent_spmi_dev->usid;\n\tstate->pid_base = reg >> 8;\n\n\tpindesc = devm_kcalloc(dev, npins, sizeof(*pindesc), GFP_KERNEL);\n\tif (!pindesc)\n\t\treturn -ENOMEM;\n\n\tpads = devm_kcalloc(dev, npins, sizeof(*pads), GFP_KERNEL);\n\tif (!pads)\n\t\treturn -ENOMEM;\n\n\tpctrldesc = devm_kzalloc(dev, sizeof(*pctrldesc), GFP_KERNEL);\n\tif (!pctrldesc)\n\t\treturn -ENOMEM;\n\n\tpctrldesc->pctlops = &pmic_gpio_pinctrl_ops;\n\tpctrldesc->pmxops = &pmic_gpio_pinmux_ops;\n\tpctrldesc->confops = &pmic_gpio_pinconf_ops;\n\tpctrldesc->owner = THIS_MODULE;\n\tpctrldesc->name = dev_name(dev);\n\tpctrldesc->pins = pindesc;\n\tpctrldesc->npins = npins;\n\tpctrldesc->num_custom_params = ARRAY_SIZE(pmic_gpio_bindings);\n\tpctrldesc->custom_params = pmic_gpio_bindings;\n#ifdef CONFIG_DEBUG_FS\n\tpctrldesc->custom_conf_items = pmic_conf_items;\n#endif\n\n\tfor (i = 0; i < npins; i++, pindesc++) {\n\t\tpad = &pads[i];\n\t\tpindesc->drv_data = pad;\n\t\tpindesc->number = i;\n\t\tpindesc->name = pmic_gpio_groups[i];\n\n\t\tpad->base = reg + i * PMIC_GPIO_ADDRESS_RANGE;\n\n\t\tret = pmic_gpio_populate(state, pad);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tstate->chip = pmic_gpio_gpio_template;\n\tstate->chip.parent = dev;\n\tstate->chip.base = -1;\n\tstate->chip.ngpio = npins;\n\tstate->chip.label = dev_name(dev);\n\tstate->chip.of_gpio_n_cells = 2;\n\tstate->chip.can_sleep = false;\n\n\tstate->ctrl = devm_pinctrl_register(dev, pctrldesc, state);\n\tif (IS_ERR(state->ctrl))\n\t\treturn PTR_ERR(state->ctrl);\n\n\tparent_node = of_irq_find_parent(state->dev->of_node);\n\tif (!parent_node)\n\t\treturn -ENXIO;\n\n\tparent_domain = irq_find_host(parent_node);\n\tof_node_put(parent_node);\n\tif (!parent_domain)\n\t\treturn -ENXIO;\n\n\tgirq = &state->chip.irq;\n\tgpio_irq_chip_set_chip(girq, &spmi_gpio_irq_chip);\n\tgirq->default_type = IRQ_TYPE_NONE;\n\tgirq->handler = handle_level_irq;\n\tgirq->fwnode = dev_fwnode(state->dev);\n\tgirq->parent_domain = parent_domain;\n\tgirq->child_to_parent_hwirq = pmic_gpio_child_to_parent_hwirq;\n\tgirq->populate_parent_alloc_arg = pmic_gpio_populate_parent_fwspec;\n\tgirq->child_offset_to_irq = pmic_gpio_child_offset_to_irq;\n\tgirq->child_irq_domain_ops.translate = pmic_gpio_domain_translate;\n\n\tret = gpiochip_add_data(&state->chip, state);\n\tif (ret) {\n\t\tdev_err(state->dev, \"can't add gpio chip\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tif (!of_property_read_bool(dev->of_node, \"gpio-ranges\")) {\n\t\tret = gpiochip_add_pin_range(&state->chip, dev_name(dev), 0, 0,\n\t\t\t\t\t     npins);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to add pin range\\n\");\n\t\t\tgoto err_range;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_range:\n\tgpiochip_remove(&state->chip);\n\treturn ret;\n}\n\nstatic int pmic_gpio_remove(struct platform_device *pdev)\n{\n\tstruct pmic_gpio_state *state = platform_get_drvdata(pdev);\n\n\tgpiochip_remove(&state->chip);\n\treturn 0;\n}\n\nstatic const struct of_device_id pmic_gpio_of_match[] = {\n\t{ .compatible = \"qcom,pm2250-gpio\", .data = (void *) 10 },\n\t \n\t{ .compatible = \"qcom,pm660-gpio\", .data = (void *) 13 },\n\t \n\t{ .compatible = \"qcom,pm660l-gpio\", .data = (void *) 12 },\n\t{ .compatible = \"qcom,pm6125-gpio\", .data = (void *) 9 },\n\t{ .compatible = \"qcom,pm6150-gpio\", .data = (void *) 10 },\n\t{ .compatible = \"qcom,pm6150l-gpio\", .data = (void *) 12 },\n\t{ .compatible = \"qcom,pm6350-gpio\", .data = (void *) 9 },\n\t{ .compatible = \"qcom,pm7250b-gpio\", .data = (void *) 12 },\n\t{ .compatible = \"qcom,pm7325-gpio\", .data = (void *) 10 },\n\t{ .compatible = \"qcom,pm7550ba-gpio\", .data = (void *) 8},\n\t{ .compatible = \"qcom,pm8005-gpio\", .data = (void *) 4 },\n\t{ .compatible = \"qcom,pm8008-gpio\", .data = (void *) 2 },\n\t{ .compatible = \"qcom,pm8019-gpio\", .data = (void *) 6 },\n\t \n\t{ .compatible = \"qcom,pm8150-gpio\", .data = (void *) 10 },\n\t{ .compatible = \"qcom,pmc8180-gpio\", .data = (void *) 10 },\n\t \n\t{ .compatible = \"qcom,pm8150b-gpio\", .data = (void *) 12 },\n\t \n\t{ .compatible = \"qcom,pm8150l-gpio\", .data = (void *) 12 },\n\t{ .compatible = \"qcom,pmc8180c-gpio\", .data = (void *) 12 },\n\t{ .compatible = \"qcom,pm8226-gpio\", .data = (void *) 8 },\n\t{ .compatible = \"qcom,pm8350-gpio\", .data = (void *) 10 },\n\t{ .compatible = \"qcom,pm8350b-gpio\", .data = (void *) 8 },\n\t{ .compatible = \"qcom,pm8350c-gpio\", .data = (void *) 9 },\n\t{ .compatible = \"qcom,pm8450-gpio\", .data = (void *) 4 },\n\t{ .compatible = \"qcom,pm8550-gpio\", .data = (void *) 12 },\n\t{ .compatible = \"qcom,pm8550b-gpio\", .data = (void *) 12 },\n\t{ .compatible = \"qcom,pm8550ve-gpio\", .data = (void *) 8 },\n\t{ .compatible = \"qcom,pm8550vs-gpio\", .data = (void *) 6 },\n\t{ .compatible = \"qcom,pm8916-gpio\", .data = (void *) 4 },\n\t{ .compatible = \"qcom,pm8941-gpio\", .data = (void *) 36 },\n\t \n\t{ .compatible = \"qcom,pm8950-gpio\", .data = (void *) 8 },\n\t \n\t{ .compatible = \"qcom,pm8953-gpio\", .data = (void *) 8 },\n\t{ .compatible = \"qcom,pm8994-gpio\", .data = (void *) 22 },\n\t{ .compatible = \"qcom,pm8998-gpio\", .data = (void *) 26 },\n\t{ .compatible = \"qcom,pma8084-gpio\", .data = (void *) 22 },\n\t{ .compatible = \"qcom,pmi632-gpio\", .data = (void *) 8 },\n\t{ .compatible = \"qcom,pmi8950-gpio\", .data = (void *) 2 },\n\t{ .compatible = \"qcom,pmi8994-gpio\", .data = (void *) 10 },\n\t{ .compatible = \"qcom,pmi8998-gpio\", .data = (void *) 14 },\n\t{ .compatible = \"qcom,pmk8350-gpio\", .data = (void *) 4 },\n\t{ .compatible = \"qcom,pmk8550-gpio\", .data = (void *) 6 },\n\t{ .compatible = \"qcom,pmm8155au-gpio\", .data = (void *) 10 },\n\t{ .compatible = \"qcom,pmm8654au-gpio\", .data = (void *) 12 },\n\t \n\t{ .compatible = \"qcom,pmp8074-gpio\", .data = (void *) 12 },\n\t{ .compatible = \"qcom,pmr735a-gpio\", .data = (void *) 4 },\n\t{ .compatible = \"qcom,pmr735b-gpio\", .data = (void *) 4 },\n\t{ .compatible = \"qcom,pmr735d-gpio\", .data = (void *) 2 },\n\t \n\t{ .compatible = \"qcom,pms405-gpio\", .data = (void *) 12 },\n\t \n\t{ .compatible = \"qcom,pmx55-gpio\", .data = (void *) 11 },\n\t{ .compatible = \"qcom,pmx65-gpio\", .data = (void *) 16 },\n\t{ .compatible = \"qcom,pmx75-gpio\", .data = (void *) 16 },\n\t{ },\n};\n\nMODULE_DEVICE_TABLE(of, pmic_gpio_of_match);\n\nstatic struct platform_driver pmic_gpio_driver = {\n\t.driver = {\n\t\t   .name = \"qcom-spmi-gpio\",\n\t\t   .of_match_table = pmic_gpio_of_match,\n\t},\n\t.probe\t= pmic_gpio_probe,\n\t.remove = pmic_gpio_remove,\n};\n\nmodule_platform_driver(pmic_gpio_driver);\n\nMODULE_AUTHOR(\"Ivan T. Ivanov <iivanov@mm-sol.com>\");\nMODULE_DESCRIPTION(\"Qualcomm SPMI PMIC GPIO pin control driver\");\nMODULE_ALIAS(\"platform:qcom-spmi-gpio\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}