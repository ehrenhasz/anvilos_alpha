{
  "module_name": "pinctrl-spmi-mpp.c",
  "hash_id": "1fe57ad4477aa051ccf90276a0f03fceace6c2dc3da27eb97adeb6d02d756ec8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/qcom/pinctrl-spmi-mpp.c",
  "human_readable_source": "\n \n\n#include <linux/gpio/driver.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#include <linux/pinctrl/pinconf-generic.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinmux.h>\n\n#include <dt-bindings/pinctrl/qcom,pmic-mpp.h>\n\n#include \"../core.h\"\n#include \"../pinctrl-utils.h\"\n\n#define PMIC_MPP_ADDRESS_RANGE\t\t\t0x100\n\n \n#define PMIC_MPP_PULL_UP_0P6KOHM\t\t0\n#define PMIC_MPP_PULL_UP_10KOHM\t\t\t1\n#define PMIC_MPP_PULL_UP_30KOHM\t\t\t2\n#define PMIC_MPP_PULL_UP_OPEN\t\t\t3\n\n \n#define PMIC_MPP_REG_TYPE\t\t\t0x4\n#define PMIC_MPP_REG_SUBTYPE\t\t\t0x5\n\n \n#define PMIC_MPP_TYPE\t\t\t\t0x11\n#define PMIC_MPP_SUBTYPE_4CH_NO_ANA_OUT\t\t0x3\n#define PMIC_MPP_SUBTYPE_ULT_4CH_NO_ANA_OUT\t0x4\n#define PMIC_MPP_SUBTYPE_4CH_NO_SINK\t\t0x5\n#define PMIC_MPP_SUBTYPE_ULT_4CH_NO_SINK\t0x6\n#define PMIC_MPP_SUBTYPE_4CH_FULL_FUNC\t\t0x7\n#define PMIC_MPP_SUBTYPE_8CH_FULL_FUNC\t\t0xf\n\n#define PMIC_MPP_REG_RT_STS\t\t\t0x10\n#define PMIC_MPP_REG_RT_STS_VAL_MASK\t\t0x1\n\n \n#define PMIC_MPP_REG_MODE_CTL\t\t\t0x40\n#define PMIC_MPP_REG_DIG_VIN_CTL\t\t0x41\n#define PMIC_MPP_REG_DIG_PULL_CTL\t\t0x42\n#define PMIC_MPP_REG_DIG_IN_CTL\t\t\t0x43\n#define PMIC_MPP_REG_EN_CTL\t\t\t0x46\n#define PMIC_MPP_REG_AOUT_CTL\t\t\t0x48\n#define PMIC_MPP_REG_AIN_CTL\t\t\t0x4a\n#define PMIC_MPP_REG_SINK_CTL\t\t\t0x4c\n\n \n#define PMIC_MPP_REG_MODE_VALUE_MASK\t\t0x1\n#define PMIC_MPP_REG_MODE_FUNCTION_SHIFT\t1\n#define PMIC_MPP_REG_MODE_FUNCTION_MASK\t\t0x7\n#define PMIC_MPP_REG_MODE_DIR_SHIFT\t\t4\n#define PMIC_MPP_REG_MODE_DIR_MASK\t\t0x7\n\n \n#define PMIC_MPP_REG_VIN_SHIFT\t\t\t0\n#define PMIC_MPP_REG_VIN_MASK\t\t\t0x7\n\n \n#define PMIC_MPP_REG_PULL_SHIFT\t\t\t0\n#define PMIC_MPP_REG_PULL_MASK\t\t\t0x7\n\n \n#define PMIC_MPP_REG_MASTER_EN_SHIFT\t\t7\n\n \n#define PMIC_MPP_REG_AIN_ROUTE_SHIFT\t\t0\n#define PMIC_MPP_REG_AIN_ROUTE_MASK\t\t0x7\n\n#define PMIC_MPP_MODE_DIGITAL_INPUT\t\t0\n#define PMIC_MPP_MODE_DIGITAL_OUTPUT\t\t1\n#define PMIC_MPP_MODE_DIGITAL_BIDIR\t\t2\n#define PMIC_MPP_MODE_ANALOG_BIDIR\t\t3\n#define PMIC_MPP_MODE_ANALOG_INPUT\t\t4\n#define PMIC_MPP_MODE_ANALOG_OUTPUT\t\t5\n#define PMIC_MPP_MODE_CURRENT_SINK\t\t6\n\n#define PMIC_MPP_SELECTOR_NORMAL\t\t0\n#define PMIC_MPP_SELECTOR_PAIRED\t\t1\n#define PMIC_MPP_SELECTOR_DTEST_FIRST\t\t4\n\n#define PMIC_MPP_PHYSICAL_OFFSET\t\t1\n\n \n#define PMIC_MPP_CONF_AMUX_ROUTE\t\t(PIN_CONFIG_END + 1)\n#define PMIC_MPP_CONF_ANALOG_LEVEL\t\t(PIN_CONFIG_END + 2)\n#define PMIC_MPP_CONF_DTEST_SELECTOR\t\t(PIN_CONFIG_END + 3)\n#define PMIC_MPP_CONF_PAIRED\t\t\t(PIN_CONFIG_END + 4)\n\n \nstruct pmic_mpp_pad {\n\tu16\t\tbase;\n\tbool\t\tis_enabled;\n\tbool\t\tout_value;\n\tbool\t\toutput_enabled;\n\tbool\t\tinput_enabled;\n\tbool\t\tpaired;\n\tbool\t\thas_pullup;\n\tunsigned int\tnum_sources;\n\tunsigned int\tpower_source;\n\tunsigned int\tamux_input;\n\tunsigned int\taout_level;\n\tunsigned int\tpullup;\n\tunsigned int\tfunction;\n\tunsigned int\tdrive_strength;\n\tunsigned int\tdtest;\n};\n\nstruct pmic_mpp_state {\n\tstruct device\t*dev;\n\tstruct regmap\t*map;\n\tstruct pinctrl_dev *ctrl;\n\tstruct gpio_chip chip;\n};\n\nstatic const struct pinconf_generic_params pmic_mpp_bindings[] = {\n\t{\"qcom,amux-route\",\tPMIC_MPP_CONF_AMUX_ROUTE,\t0},\n\t{\"qcom,analog-level\",\tPMIC_MPP_CONF_ANALOG_LEVEL,\t0},\n\t{\"qcom,dtest\",\t\tPMIC_MPP_CONF_DTEST_SELECTOR,\t0},\n\t{\"qcom,paired\",\t\tPMIC_MPP_CONF_PAIRED,\t\t0},\n};\n\n#ifdef CONFIG_DEBUG_FS\nstatic const struct pin_config_item pmic_conf_items[] = {\n\tPCONFDUMP(PMIC_MPP_CONF_AMUX_ROUTE, \"analog mux\", NULL, true),\n\tPCONFDUMP(PMIC_MPP_CONF_ANALOG_LEVEL, \"analog level\", NULL, true),\n\tPCONFDUMP(PMIC_MPP_CONF_DTEST_SELECTOR, \"dtest\", NULL, true),\n\tPCONFDUMP(PMIC_MPP_CONF_PAIRED, \"paired\", NULL, false),\n};\n#endif\n\nstatic const char *const pmic_mpp_groups[] = {\n\t\"mpp1\", \"mpp2\", \"mpp3\", \"mpp4\", \"mpp5\", \"mpp6\", \"mpp7\", \"mpp8\",\n};\n\n#define PMIC_MPP_DIGITAL\t0\n#define PMIC_MPP_ANALOG\t\t1\n#define PMIC_MPP_SINK\t\t2\n\nstatic const char *const pmic_mpp_functions[] = {\n\t\"digital\", \"analog\", \"sink\"\n};\n\nstatic int pmic_mpp_read(struct pmic_mpp_state *state,\n\t\t\t struct pmic_mpp_pad *pad, unsigned int addr)\n{\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read(state->map, pad->base + addr, &val);\n\tif (ret < 0)\n\t\tdev_err(state->dev, \"read 0x%x failed\\n\", addr);\n\telse\n\t\tret = val;\n\n\treturn ret;\n}\n\nstatic int pmic_mpp_write(struct pmic_mpp_state *state,\n\t\t\t  struct pmic_mpp_pad *pad, unsigned int addr,\n\t\t\t  unsigned int val)\n{\n\tint ret;\n\n\tret = regmap_write(state->map, pad->base + addr, val);\n\tif (ret < 0)\n\t\tdev_err(state->dev, \"write 0x%x failed\\n\", addr);\n\n\treturn ret;\n}\n\nstatic int pmic_mpp_get_groups_count(struct pinctrl_dev *pctldev)\n{\n\t \n\treturn pctldev->desc->npins;\n}\n\nstatic const char *pmic_mpp_get_group_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t   unsigned pin)\n{\n\treturn pctldev->desc->pins[pin].name;\n}\n\nstatic int pmic_mpp_get_group_pins(struct pinctrl_dev *pctldev,\n\t\t\t\t   unsigned pin,\n\t\t\t\t   const unsigned **pins, unsigned *num_pins)\n{\n\t*pins = &pctldev->desc->pins[pin].number;\n\t*num_pins = 1;\n\treturn 0;\n}\n\nstatic const struct pinctrl_ops pmic_mpp_pinctrl_ops = {\n\t.get_groups_count\t= pmic_mpp_get_groups_count,\n\t.get_group_name\t\t= pmic_mpp_get_group_name,\n\t.get_group_pins\t\t= pmic_mpp_get_group_pins,\n\t.dt_node_to_map\t\t= pinconf_generic_dt_node_to_map_group,\n\t.dt_free_map\t\t= pinctrl_utils_free_map,\n};\n\nstatic int pmic_mpp_get_functions_count(struct pinctrl_dev *pctldev)\n{\n\treturn ARRAY_SIZE(pmic_mpp_functions);\n}\n\nstatic const char *pmic_mpp_get_function_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t      unsigned function)\n{\n\treturn pmic_mpp_functions[function];\n}\n\nstatic int pmic_mpp_get_function_groups(struct pinctrl_dev *pctldev,\n\t\t\t\t\tunsigned function,\n\t\t\t\t\tconst char *const **groups,\n\t\t\t\t\tunsigned *const num_qgroups)\n{\n\t*groups = pmic_mpp_groups;\n\t*num_qgroups = pctldev->desc->npins;\n\treturn 0;\n}\n\nstatic int pmic_mpp_write_mode_ctl(struct pmic_mpp_state *state,\n\t\t\t\t   struct pmic_mpp_pad *pad)\n{\n\tunsigned int mode;\n\tunsigned int sel;\n\tunsigned int val;\n\tunsigned int en;\n\n\tswitch (pad->function) {\n\tcase PMIC_MPP_ANALOG:\n\t\tif (pad->input_enabled && pad->output_enabled)\n\t\t\tmode = PMIC_MPP_MODE_ANALOG_BIDIR;\n\t\telse if (pad->input_enabled)\n\t\t\tmode = PMIC_MPP_MODE_ANALOG_INPUT;\n\t\telse\n\t\t\tmode = PMIC_MPP_MODE_ANALOG_OUTPUT;\n\t\tbreak;\n\tcase PMIC_MPP_DIGITAL:\n\t\tif (pad->input_enabled && pad->output_enabled)\n\t\t\tmode = PMIC_MPP_MODE_DIGITAL_BIDIR;\n\t\telse if (pad->input_enabled)\n\t\t\tmode = PMIC_MPP_MODE_DIGITAL_INPUT;\n\t\telse\n\t\t\tmode = PMIC_MPP_MODE_DIGITAL_OUTPUT;\n\t\tbreak;\n\tcase PMIC_MPP_SINK:\n\tdefault:\n\t\tmode = PMIC_MPP_MODE_CURRENT_SINK;\n\t\tbreak;\n\t}\n\n\tif (pad->dtest)\n\t\tsel = PMIC_MPP_SELECTOR_DTEST_FIRST + pad->dtest - 1;\n\telse if (pad->paired)\n\t\tsel = PMIC_MPP_SELECTOR_PAIRED;\n\telse\n\t\tsel = PMIC_MPP_SELECTOR_NORMAL;\n\n\ten = !!pad->out_value;\n\n\tval = mode << PMIC_MPP_REG_MODE_DIR_SHIFT |\n\t      sel << PMIC_MPP_REG_MODE_FUNCTION_SHIFT |\n\t      en;\n\n\treturn pmic_mpp_write(state, pad, PMIC_MPP_REG_MODE_CTL, val);\n}\n\nstatic int pmic_mpp_set_mux(struct pinctrl_dev *pctldev, unsigned function,\n\t\t\t\tunsigned pin)\n{\n\tstruct pmic_mpp_state *state = pinctrl_dev_get_drvdata(pctldev);\n\tstruct pmic_mpp_pad *pad;\n\tunsigned int val;\n\tint ret;\n\n\tpad = pctldev->desc->pins[pin].drv_data;\n\n\tpad->function = function;\n\n\tret = pmic_mpp_write_mode_ctl(state, pad);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tval = pad->is_enabled << PMIC_MPP_REG_MASTER_EN_SHIFT;\n\n\treturn pmic_mpp_write(state, pad, PMIC_MPP_REG_EN_CTL, val);\n}\n\nstatic const struct pinmux_ops pmic_mpp_pinmux_ops = {\n\t.get_functions_count\t= pmic_mpp_get_functions_count,\n\t.get_function_name\t= pmic_mpp_get_function_name,\n\t.get_function_groups\t= pmic_mpp_get_function_groups,\n\t.set_mux\t\t= pmic_mpp_set_mux,\n};\n\nstatic int pmic_mpp_config_get(struct pinctrl_dev *pctldev,\n\t\t\t       unsigned int pin, unsigned long *config)\n{\n\tunsigned param = pinconf_to_config_param(*config);\n\tstruct pmic_mpp_pad *pad;\n\tunsigned arg = 0;\n\n\tpad = pctldev->desc->pins[pin].drv_data;\n\n\tswitch (param) {\n\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\tif (pad->pullup != PMIC_MPP_PULL_UP_OPEN)\n\t\t\treturn -EINVAL;\n\t\targ = 1;\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\tswitch (pad->pullup) {\n\t\tcase PMIC_MPP_PULL_UP_0P6KOHM:\n\t\t\targ = 600;\n\t\t\tbreak;\n\t\tcase PMIC_MPP_PULL_UP_10KOHM:\n\t\t\targ = 10000;\n\t\t\tbreak;\n\t\tcase PMIC_MPP_PULL_UP_30KOHM:\n\t\t\targ = 30000;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_HIGH_IMPEDANCE:\n\t\tif (pad->is_enabled)\n\t\t\treturn -EINVAL;\n\t\targ = 1;\n\t\tbreak;\n\tcase PIN_CONFIG_POWER_SOURCE:\n\t\targ = pad->power_source;\n\t\tbreak;\n\tcase PIN_CONFIG_INPUT_ENABLE:\n\t\tif (!pad->input_enabled)\n\t\t\treturn -EINVAL;\n\t\targ = 1;\n\t\tbreak;\n\tcase PIN_CONFIG_OUTPUT:\n\t\targ = pad->out_value;\n\t\tbreak;\n\tcase PMIC_MPP_CONF_DTEST_SELECTOR:\n\t\targ = pad->dtest;\n\t\tbreak;\n\tcase PMIC_MPP_CONF_AMUX_ROUTE:\n\t\targ = pad->amux_input;\n\t\tbreak;\n\tcase PMIC_MPP_CONF_PAIRED:\n\t\tif (!pad->paired)\n\t\t\treturn -EINVAL;\n\t\targ = 1;\n\t\tbreak;\n\tcase PIN_CONFIG_DRIVE_STRENGTH:\n\t\targ = pad->drive_strength;\n\t\tbreak;\n\tcase PMIC_MPP_CONF_ANALOG_LEVEL:\n\t\targ = pad->aout_level;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\t*config = pinconf_to_config_packed(param, arg);\n\treturn 0;\n}\n\nstatic int pmic_mpp_config_set(struct pinctrl_dev *pctldev, unsigned int pin,\n\t\t\t       unsigned long *configs, unsigned nconfs)\n{\n\tstruct pmic_mpp_state *state = pinctrl_dev_get_drvdata(pctldev);\n\tstruct pmic_mpp_pad *pad;\n\tunsigned param, arg;\n\tunsigned int val;\n\tint i, ret;\n\n\tpad = pctldev->desc->pins[pin].drv_data;\n\n\t \n\tpad->is_enabled = true;\n\n\tfor (i = 0; i < nconfs; i++) {\n\t\tparam = pinconf_to_config_param(configs[i]);\n\t\targ = pinconf_to_config_argument(configs[i]);\n\n\t\tswitch (param) {\n\t\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\t\tpad->pullup = PMIC_MPP_PULL_UP_OPEN;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\t\tswitch (arg) {\n\t\t\tcase 600:\n\t\t\t\tpad->pullup = PMIC_MPP_PULL_UP_0P6KOHM;\n\t\t\t\tbreak;\n\t\t\tcase 10000:\n\t\t\t\tpad->pullup = PMIC_MPP_PULL_UP_10KOHM;\n\t\t\t\tbreak;\n\t\t\tcase 30000:\n\t\t\t\tpad->pullup = PMIC_MPP_PULL_UP_30KOHM;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_BIAS_HIGH_IMPEDANCE:\n\t\t\tpad->is_enabled = false;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_POWER_SOURCE:\n\t\t\tif (arg >= pad->num_sources)\n\t\t\t\treturn -EINVAL;\n\t\t\tpad->power_source = arg;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_INPUT_ENABLE:\n\t\t\tpad->input_enabled = arg ? true : false;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_OUTPUT:\n\t\t\tpad->output_enabled = true;\n\t\t\tpad->out_value = arg;\n\t\t\tbreak;\n\t\tcase PMIC_MPP_CONF_DTEST_SELECTOR:\n\t\t\tpad->dtest = arg;\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_DRIVE_STRENGTH:\n\t\t\tpad->drive_strength = arg;\n\t\t\tbreak;\n\t\tcase PMIC_MPP_CONF_AMUX_ROUTE:\n\t\t\tif (arg >= PMIC_MPP_AMUX_ROUTE_ABUS4)\n\t\t\t\treturn -EINVAL;\n\t\t\tpad->amux_input = arg;\n\t\t\tbreak;\n\t\tcase PMIC_MPP_CONF_ANALOG_LEVEL:\n\t\t\tpad->aout_level = arg;\n\t\t\tbreak;\n\t\tcase PMIC_MPP_CONF_PAIRED:\n\t\t\tpad->paired = !!arg;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tval = pad->power_source << PMIC_MPP_REG_VIN_SHIFT;\n\n\tret = pmic_mpp_write(state, pad, PMIC_MPP_REG_DIG_VIN_CTL, val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (pad->has_pullup) {\n\t\tval = pad->pullup << PMIC_MPP_REG_PULL_SHIFT;\n\n\t\tret = pmic_mpp_write(state, pad, PMIC_MPP_REG_DIG_PULL_CTL,\n\t\t\t\t     val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tval = pad->amux_input & PMIC_MPP_REG_AIN_ROUTE_MASK;\n\n\tret = pmic_mpp_write(state, pad, PMIC_MPP_REG_AIN_CTL, val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = pmic_mpp_write(state, pad, PMIC_MPP_REG_AOUT_CTL, pad->aout_level);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = pmic_mpp_write_mode_ctl(state, pad);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = pmic_mpp_write(state, pad, PMIC_MPP_REG_SINK_CTL, pad->drive_strength);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tval = pad->is_enabled << PMIC_MPP_REG_MASTER_EN_SHIFT;\n\n\treturn pmic_mpp_write(state, pad, PMIC_MPP_REG_EN_CTL, val);\n}\n\nstatic void pmic_mpp_config_dbg_show(struct pinctrl_dev *pctldev,\n\t\t\t\t     struct seq_file *s, unsigned pin)\n{\n\tstruct pmic_mpp_state *state = pinctrl_dev_get_drvdata(pctldev);\n\tstruct pmic_mpp_pad *pad;\n\tint ret;\n\n\tstatic const char *const biases[] = {\n\t\t\"0.6kOhm\", \"10kOhm\", \"30kOhm\", \"Disabled\"\n\t};\n\n\tpad = pctldev->desc->pins[pin].drv_data;\n\n\tseq_printf(s, \" mpp%-2d:\", pin + PMIC_MPP_PHYSICAL_OFFSET);\n\n\tif (!pad->is_enabled) {\n\t\tseq_puts(s, \" ---\");\n\t} else {\n\n\t\tif (pad->input_enabled) {\n\t\t\tret = pmic_mpp_read(state, pad, PMIC_MPP_REG_RT_STS);\n\t\t\tif (ret < 0)\n\t\t\t\treturn;\n\n\t\t\tret &= PMIC_MPP_REG_RT_STS_VAL_MASK;\n\t\t\tpad->out_value = ret;\n\t\t}\n\n\t\tseq_printf(s, \" %-4s\", pad->output_enabled ? \"out\" : \"in\");\n\t\tseq_printf(s, \" %-7s\", pmic_mpp_functions[pad->function]);\n\t\tseq_printf(s, \" vin-%d\", pad->power_source);\n\t\tseq_printf(s, \" %d\", pad->aout_level);\n\t\tif (pad->has_pullup)\n\t\t\tseq_printf(s, \" %-8s\", biases[pad->pullup]);\n\t\tseq_printf(s, \" %-4s\", pad->out_value ? \"high\" : \"low\");\n\t\tif (pad->dtest)\n\t\t\tseq_printf(s, \" dtest%d\", pad->dtest);\n\t\tif (pad->paired)\n\t\t\tseq_puts(s, \" paired\");\n\t}\n}\n\nstatic const struct pinconf_ops pmic_mpp_pinconf_ops = {\n\t.is_generic = true,\n\t.pin_config_group_get\t\t= pmic_mpp_config_get,\n\t.pin_config_group_set\t\t= pmic_mpp_config_set,\n\t.pin_config_group_dbg_show\t= pmic_mpp_config_dbg_show,\n};\n\nstatic int pmic_mpp_direction_input(struct gpio_chip *chip, unsigned pin)\n{\n\tstruct pmic_mpp_state *state = gpiochip_get_data(chip);\n\tunsigned long config;\n\n\tconfig = pinconf_to_config_packed(PIN_CONFIG_INPUT_ENABLE, 1);\n\n\treturn pmic_mpp_config_set(state->ctrl, pin, &config, 1);\n}\n\nstatic int pmic_mpp_direction_output(struct gpio_chip *chip,\n\t\t\t\t     unsigned pin, int val)\n{\n\tstruct pmic_mpp_state *state = gpiochip_get_data(chip);\n\tunsigned long config;\n\n\tconfig = pinconf_to_config_packed(PIN_CONFIG_OUTPUT, val);\n\n\treturn pmic_mpp_config_set(state->ctrl, pin, &config, 1);\n}\n\nstatic int pmic_mpp_get(struct gpio_chip *chip, unsigned pin)\n{\n\tstruct pmic_mpp_state *state = gpiochip_get_data(chip);\n\tstruct pmic_mpp_pad *pad;\n\tint ret;\n\n\tpad = state->ctrl->desc->pins[pin].drv_data;\n\n\tif (pad->input_enabled) {\n\t\tret = pmic_mpp_read(state, pad, PMIC_MPP_REG_RT_STS);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tpad->out_value = ret & PMIC_MPP_REG_RT_STS_VAL_MASK;\n\t}\n\n\treturn !!pad->out_value;\n}\n\nstatic void pmic_mpp_set(struct gpio_chip *chip, unsigned pin, int value)\n{\n\tstruct pmic_mpp_state *state = gpiochip_get_data(chip);\n\tunsigned long config;\n\n\tconfig = pinconf_to_config_packed(PIN_CONFIG_OUTPUT, value);\n\n\tpmic_mpp_config_set(state->ctrl, pin, &config, 1);\n}\n\nstatic int pmic_mpp_of_xlate(struct gpio_chip *chip,\n\t\t\t     const struct of_phandle_args *gpio_desc,\n\t\t\t     u32 *flags)\n{\n\tif (chip->of_gpio_n_cells < 2)\n\t\treturn -EINVAL;\n\n\tif (flags)\n\t\t*flags = gpio_desc->args[1];\n\n\treturn gpio_desc->args[0] - PMIC_MPP_PHYSICAL_OFFSET;\n}\n\nstatic void pmic_mpp_dbg_show(struct seq_file *s, struct gpio_chip *chip)\n{\n\tstruct pmic_mpp_state *state = gpiochip_get_data(chip);\n\tunsigned i;\n\n\tfor (i = 0; i < chip->ngpio; i++) {\n\t\tpmic_mpp_config_dbg_show(state->ctrl, s, i);\n\t\tseq_puts(s, \"\\n\");\n\t}\n}\n\nstatic const struct gpio_chip pmic_mpp_gpio_template = {\n\t.direction_input\t= pmic_mpp_direction_input,\n\t.direction_output\t= pmic_mpp_direction_output,\n\t.get\t\t\t= pmic_mpp_get,\n\t.set\t\t\t= pmic_mpp_set,\n\t.request\t\t= gpiochip_generic_request,\n\t.free\t\t\t= gpiochip_generic_free,\n\t.of_xlate\t\t= pmic_mpp_of_xlate,\n\t.dbg_show\t\t= pmic_mpp_dbg_show,\n};\n\nstatic int pmic_mpp_populate(struct pmic_mpp_state *state,\n\t\t\t     struct pmic_mpp_pad *pad)\n{\n\tint type, subtype, val, dir;\n\tunsigned int sel;\n\n\ttype = pmic_mpp_read(state, pad, PMIC_MPP_REG_TYPE);\n\tif (type < 0)\n\t\treturn type;\n\n\tif (type != PMIC_MPP_TYPE) {\n\t\tdev_err(state->dev, \"incorrect block type 0x%x at 0x%x\\n\",\n\t\t\ttype, pad->base);\n\t\treturn -ENODEV;\n\t}\n\n\tsubtype = pmic_mpp_read(state, pad, PMIC_MPP_REG_SUBTYPE);\n\tif (subtype < 0)\n\t\treturn subtype;\n\n\tswitch (subtype) {\n\tcase PMIC_MPP_SUBTYPE_4CH_NO_ANA_OUT:\n\tcase PMIC_MPP_SUBTYPE_ULT_4CH_NO_ANA_OUT:\n\tcase PMIC_MPP_SUBTYPE_4CH_NO_SINK:\n\tcase PMIC_MPP_SUBTYPE_ULT_4CH_NO_SINK:\n\tcase PMIC_MPP_SUBTYPE_4CH_FULL_FUNC:\n\t\tpad->num_sources = 4;\n\t\tbreak;\n\tcase PMIC_MPP_SUBTYPE_8CH_FULL_FUNC:\n\t\tpad->num_sources = 8;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(state->dev, \"unknown MPP type 0x%x at 0x%x\\n\",\n\t\t\tsubtype, pad->base);\n\t\treturn -ENODEV;\n\t}\n\n\tval = pmic_mpp_read(state, pad, PMIC_MPP_REG_MODE_CTL);\n\tif (val < 0)\n\t\treturn val;\n\n\tpad->out_value = val & PMIC_MPP_REG_MODE_VALUE_MASK;\n\n\tdir = val >> PMIC_MPP_REG_MODE_DIR_SHIFT;\n\tdir &= PMIC_MPP_REG_MODE_DIR_MASK;\n\n\tswitch (dir) {\n\tcase PMIC_MPP_MODE_DIGITAL_INPUT:\n\t\tpad->input_enabled = true;\n\t\tpad->output_enabled = false;\n\t\tpad->function = PMIC_MPP_DIGITAL;\n\t\tbreak;\n\tcase PMIC_MPP_MODE_DIGITAL_OUTPUT:\n\t\tpad->input_enabled = false;\n\t\tpad->output_enabled = true;\n\t\tpad->function = PMIC_MPP_DIGITAL;\n\t\tbreak;\n\tcase PMIC_MPP_MODE_DIGITAL_BIDIR:\n\t\tpad->input_enabled = true;\n\t\tpad->output_enabled = true;\n\t\tpad->function = PMIC_MPP_DIGITAL;\n\t\tbreak;\n\tcase PMIC_MPP_MODE_ANALOG_BIDIR:\n\t\tpad->input_enabled = true;\n\t\tpad->output_enabled = true;\n\t\tpad->function = PMIC_MPP_ANALOG;\n\t\tbreak;\n\tcase PMIC_MPP_MODE_ANALOG_INPUT:\n\t\tpad->input_enabled = true;\n\t\tpad->output_enabled = false;\n\t\tpad->function = PMIC_MPP_ANALOG;\n\t\tbreak;\n\tcase PMIC_MPP_MODE_ANALOG_OUTPUT:\n\t\tpad->input_enabled = false;\n\t\tpad->output_enabled = true;\n\t\tpad->function = PMIC_MPP_ANALOG;\n\t\tbreak;\n\tcase PMIC_MPP_MODE_CURRENT_SINK:\n\t\tpad->input_enabled = false;\n\t\tpad->output_enabled = true;\n\t\tpad->function = PMIC_MPP_SINK;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(state->dev, \"unknown MPP direction\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tsel = val >> PMIC_MPP_REG_MODE_FUNCTION_SHIFT;\n\tsel &= PMIC_MPP_REG_MODE_FUNCTION_MASK;\n\n\tif (sel >= PMIC_MPP_SELECTOR_DTEST_FIRST)\n\t\tpad->dtest = sel + 1;\n\telse if (sel == PMIC_MPP_SELECTOR_PAIRED)\n\t\tpad->paired = true;\n\n\tval = pmic_mpp_read(state, pad, PMIC_MPP_REG_DIG_VIN_CTL);\n\tif (val < 0)\n\t\treturn val;\n\n\tpad->power_source = val >> PMIC_MPP_REG_VIN_SHIFT;\n\tpad->power_source &= PMIC_MPP_REG_VIN_MASK;\n\n\tif (subtype != PMIC_MPP_SUBTYPE_ULT_4CH_NO_ANA_OUT &&\n\t    subtype != PMIC_MPP_SUBTYPE_ULT_4CH_NO_SINK) {\n\t\tval = pmic_mpp_read(state, pad, PMIC_MPP_REG_DIG_PULL_CTL);\n\t\tif (val < 0)\n\t\t\treturn val;\n\n\t\tpad->pullup = val >> PMIC_MPP_REG_PULL_SHIFT;\n\t\tpad->pullup &= PMIC_MPP_REG_PULL_MASK;\n\t\tpad->has_pullup = true;\n\t}\n\n\tval = pmic_mpp_read(state, pad, PMIC_MPP_REG_AIN_CTL);\n\tif (val < 0)\n\t\treturn val;\n\n\tpad->amux_input = val >> PMIC_MPP_REG_AIN_ROUTE_SHIFT;\n\tpad->amux_input &= PMIC_MPP_REG_AIN_ROUTE_MASK;\n\n\tval = pmic_mpp_read(state, pad, PMIC_MPP_REG_SINK_CTL);\n\tif (val < 0)\n\t\treturn val;\n\n\tpad->drive_strength = val;\n\n\tval = pmic_mpp_read(state, pad, PMIC_MPP_REG_AOUT_CTL);\n\tif (val < 0)\n\t\treturn val;\n\n\tpad->aout_level = val;\n\n\tval = pmic_mpp_read(state, pad, PMIC_MPP_REG_EN_CTL);\n\tif (val < 0)\n\t\treturn val;\n\n\tpad->is_enabled = !!val;\n\n\treturn 0;\n}\n\nstatic int pmic_mpp_domain_translate(struct irq_domain *domain,\n\t\t\t\t      struct irq_fwspec *fwspec,\n\t\t\t\t      unsigned long *hwirq,\n\t\t\t\t      unsigned int *type)\n{\n\tstruct pmic_mpp_state *state = container_of(domain->host_data,\n\t\t\t\t\t\t     struct pmic_mpp_state,\n\t\t\t\t\t\t     chip);\n\n\tif (fwspec->param_count != 2 ||\n\t    fwspec->param[0] < 1 || fwspec->param[0] > state->chip.ngpio)\n\t\treturn -EINVAL;\n\n\t*hwirq = fwspec->param[0] - PMIC_MPP_PHYSICAL_OFFSET;\n\t*type = fwspec->param[1];\n\n\treturn 0;\n}\n\nstatic unsigned int pmic_mpp_child_offset_to_irq(struct gpio_chip *chip,\n\t\t\t\t\t\t  unsigned int offset)\n{\n\treturn offset + PMIC_MPP_PHYSICAL_OFFSET;\n}\n\nstatic int pmic_mpp_child_to_parent_hwirq(struct gpio_chip *chip,\n\t\t\t\t\t   unsigned int child_hwirq,\n\t\t\t\t\t   unsigned int child_type,\n\t\t\t\t\t   unsigned int *parent_hwirq,\n\t\t\t\t\t   unsigned int *parent_type)\n{\n\t*parent_hwirq = child_hwirq + 0xc0;\n\t*parent_type = child_type;\n\n\treturn 0;\n}\n\nstatic void pmic_mpp_irq_mask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\n\tirq_chip_mask_parent(d);\n\tgpiochip_disable_irq(gc, irqd_to_hwirq(d));\n}\n\nstatic void pmic_mpp_irq_unmask(struct irq_data *d)\n{\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\n\tgpiochip_enable_irq(gc, irqd_to_hwirq(d));\n\tirq_chip_unmask_parent(d);\n}\n\nstatic const struct irq_chip pmic_mpp_irq_chip = {\n\t.name = \"spmi-mpp\",\n\t.irq_ack = irq_chip_ack_parent,\n\t.irq_mask = pmic_mpp_irq_mask,\n\t.irq_unmask = pmic_mpp_irq_unmask,\n\t.irq_set_type = irq_chip_set_type_parent,\n\t.irq_set_wake = irq_chip_set_wake_parent,\n\t.flags = IRQCHIP_MASK_ON_SUSPEND | IRQCHIP_IMMUTABLE,\n\tGPIOCHIP_IRQ_RESOURCE_HELPERS,\n};\n\nstatic int pmic_mpp_probe(struct platform_device *pdev)\n{\n\tstruct irq_domain *parent_domain;\n\tstruct device_node *parent_node;\n\tstruct device *dev = &pdev->dev;\n\tstruct pinctrl_pin_desc *pindesc;\n\tstruct pinctrl_desc *pctrldesc;\n\tstruct pmic_mpp_pad *pad, *pads;\n\tstruct pmic_mpp_state *state;\n\tstruct gpio_irq_chip *girq;\n\tint ret, npins, i;\n\tu32 reg;\n\n\tret = of_property_read_u32(dev->of_node, \"reg\", &reg);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"missing base address\");\n\t\treturn ret;\n\t}\n\n\tnpins = (uintptr_t) device_get_match_data(&pdev->dev);\n\n\tBUG_ON(npins > ARRAY_SIZE(pmic_mpp_groups));\n\n\tstate = devm_kzalloc(dev, sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, state);\n\n\tstate->dev = &pdev->dev;\n\tstate->map = dev_get_regmap(dev->parent, NULL);\n\n\tpindesc = devm_kcalloc(dev, npins, sizeof(*pindesc), GFP_KERNEL);\n\tif (!pindesc)\n\t\treturn -ENOMEM;\n\n\tpads = devm_kcalloc(dev, npins, sizeof(*pads), GFP_KERNEL);\n\tif (!pads)\n\t\treturn -ENOMEM;\n\n\tpctrldesc = devm_kzalloc(dev, sizeof(*pctrldesc), GFP_KERNEL);\n\tif (!pctrldesc)\n\t\treturn -ENOMEM;\n\n\tpctrldesc->pctlops = &pmic_mpp_pinctrl_ops;\n\tpctrldesc->pmxops = &pmic_mpp_pinmux_ops;\n\tpctrldesc->confops = &pmic_mpp_pinconf_ops;\n\tpctrldesc->owner = THIS_MODULE;\n\tpctrldesc->name = dev_name(dev);\n\tpctrldesc->pins = pindesc;\n\tpctrldesc->npins = npins;\n\n\tpctrldesc->num_custom_params = ARRAY_SIZE(pmic_mpp_bindings);\n\tpctrldesc->custom_params = pmic_mpp_bindings;\n#ifdef CONFIG_DEBUG_FS\n\tpctrldesc->custom_conf_items = pmic_conf_items;\n#endif\n\n\tfor (i = 0; i < npins; i++, pindesc++) {\n\t\tpad = &pads[i];\n\t\tpindesc->drv_data = pad;\n\t\tpindesc->number = i;\n\t\tpindesc->name = pmic_mpp_groups[i];\n\n\t\tpad->base = reg + i * PMIC_MPP_ADDRESS_RANGE;\n\n\t\tret = pmic_mpp_populate(state, pad);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tstate->chip = pmic_mpp_gpio_template;\n\tstate->chip.parent = dev;\n\tstate->chip.base = -1;\n\tstate->chip.ngpio = npins;\n\tstate->chip.label = dev_name(dev);\n\tstate->chip.of_gpio_n_cells = 2;\n\tstate->chip.can_sleep = false;\n\n\tstate->ctrl = devm_pinctrl_register(dev, pctrldesc, state);\n\tif (IS_ERR(state->ctrl))\n\t\treturn PTR_ERR(state->ctrl);\n\n\tparent_node = of_irq_find_parent(state->dev->of_node);\n\tif (!parent_node)\n\t\treturn -ENXIO;\n\n\tparent_domain = irq_find_host(parent_node);\n\tof_node_put(parent_node);\n\tif (!parent_domain)\n\t\treturn -ENXIO;\n\n\tgirq = &state->chip.irq;\n\tgpio_irq_chip_set_chip(girq, &pmic_mpp_irq_chip);\n\tgirq->default_type = IRQ_TYPE_NONE;\n\tgirq->handler = handle_level_irq;\n\tgirq->fwnode = dev_fwnode(state->dev);\n\tgirq->parent_domain = parent_domain;\n\tgirq->child_to_parent_hwirq = pmic_mpp_child_to_parent_hwirq;\n\tgirq->populate_parent_alloc_arg = gpiochip_populate_parent_fwspec_fourcell;\n\tgirq->child_offset_to_irq = pmic_mpp_child_offset_to_irq;\n\tgirq->child_irq_domain_ops.translate = pmic_mpp_domain_translate;\n\n\tret = gpiochip_add_data(&state->chip, state);\n\tif (ret) {\n\t\tdev_err(state->dev, \"can't add gpio chip\\n\");\n\t\treturn ret;\n\t}\n\n\tret = gpiochip_add_pin_range(&state->chip, dev_name(dev), 0, 0, npins);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to add pin range\\n\");\n\t\tgoto err_range;\n\t}\n\n\treturn 0;\n\nerr_range:\n\tgpiochip_remove(&state->chip);\n\treturn ret;\n}\n\nstatic int pmic_mpp_remove(struct platform_device *pdev)\n{\n\tstruct pmic_mpp_state *state = platform_get_drvdata(pdev);\n\n\tgpiochip_remove(&state->chip);\n\treturn 0;\n}\n\nstatic const struct of_device_id pmic_mpp_of_match[] = {\n\t{ .compatible = \"qcom,pm8019-mpp\", .data = (void *) 6 },\n\t{ .compatible = \"qcom,pm8226-mpp\", .data = (void *) 8 },\n\t{ .compatible = \"qcom,pm8841-mpp\", .data = (void *) 4 },\n\t{ .compatible = \"qcom,pm8916-mpp\", .data = (void *) 4 },\n\t{ .compatible = \"qcom,pm8941-mpp\", .data = (void *) 8 },\n\t{ .compatible = \"qcom,pm8950-mpp\", .data = (void *) 4 },\n\t{ .compatible = \"qcom,pmi8950-mpp\", .data = (void *) 4 },\n\t{ .compatible = \"qcom,pm8994-mpp\", .data = (void *) 8 },\n\t{ .compatible = \"qcom,pma8084-mpp\", .data = (void *) 8 },\n\t{ .compatible = \"qcom,pmi8994-mpp\", .data = (void *) 4 },\n\t{ },\n};\n\nMODULE_DEVICE_TABLE(of, pmic_mpp_of_match);\n\nstatic struct platform_driver pmic_mpp_driver = {\n\t.driver = {\n\t\t   .name = \"qcom-spmi-mpp\",\n\t\t   .of_match_table = pmic_mpp_of_match,\n\t},\n\t.probe\t= pmic_mpp_probe,\n\t.remove = pmic_mpp_remove,\n};\n\nmodule_platform_driver(pmic_mpp_driver);\n\nMODULE_AUTHOR(\"Ivan T. Ivanov <iivanov@mm-sol.com>\");\nMODULE_DESCRIPTION(\"Qualcomm SPMI PMIC MPP pin control driver\");\nMODULE_ALIAS(\"platform:qcom-spmi-mpp\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}