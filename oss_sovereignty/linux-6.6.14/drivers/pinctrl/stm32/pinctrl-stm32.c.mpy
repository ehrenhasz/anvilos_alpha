{
  "module_name": "pinctrl-stm32.c",
  "hash_id": "e76c4eda949b906263d1568d201a8472bdd98cb30529a9ef4d1cf4cc9a1eabe3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/stm32/pinctrl-stm32.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/gpio/driver.h>\n#include <linux/hwspinlock.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n\n#include <linux/pinctrl/consumer.h>\n#include <linux/pinctrl/machine.h>\n#include <linux/pinctrl/pinconf-generic.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinmux.h>\n\n#include \"../core.h\"\n#include \"../pinconf.h\"\n#include \"../pinctrl-utils.h\"\n#include \"pinctrl-stm32.h\"\n\n#define STM32_GPIO_MODER\t0x00\n#define STM32_GPIO_TYPER\t0x04\n#define STM32_GPIO_SPEEDR\t0x08\n#define STM32_GPIO_PUPDR\t0x0c\n#define STM32_GPIO_IDR\t\t0x10\n#define STM32_GPIO_ODR\t\t0x14\n#define STM32_GPIO_BSRR\t\t0x18\n#define STM32_GPIO_LCKR\t\t0x1c\n#define STM32_GPIO_AFRL\t\t0x20\n#define STM32_GPIO_AFRH\t\t0x24\n#define STM32_GPIO_SECCFGR\t0x30\n\n \n#define STM32_GPIO_BKP_MODE_SHIFT\t0\n#define STM32_GPIO_BKP_MODE_MASK\tGENMASK(1, 0)\n#define STM32_GPIO_BKP_ALT_SHIFT\t2\n#define STM32_GPIO_BKP_ALT_MASK\t\tGENMASK(5, 2)\n#define STM32_GPIO_BKP_SPEED_SHIFT\t6\n#define STM32_GPIO_BKP_SPEED_MASK\tGENMASK(7, 6)\n#define STM32_GPIO_BKP_PUPD_SHIFT\t8\n#define STM32_GPIO_BKP_PUPD_MASK\tGENMASK(9, 8)\n#define STM32_GPIO_BKP_TYPE\t\t10\n#define STM32_GPIO_BKP_VAL\t\t11\n\n#define STM32_GPIO_PINS_PER_BANK 16\n#define STM32_GPIO_IRQ_LINE\t 16\n\n#define SYSCFG_IRQMUX_MASK GENMASK(3, 0)\n\n#define gpio_range_to_bank(chip) \\\n\t\tcontainer_of(chip, struct stm32_gpio_bank, range)\n\n#define HWSPNLCK_TIMEOUT\t1000  \n\nstatic const char * const stm32_gpio_functions[] = {\n\t\"gpio\", \"af0\", \"af1\",\n\t\"af2\", \"af3\", \"af4\",\n\t\"af5\", \"af6\", \"af7\",\n\t\"af8\", \"af9\", \"af10\",\n\t\"af11\", \"af12\", \"af13\",\n\t\"af14\", \"af15\", \"analog\",\n};\n\nstruct stm32_pinctrl_group {\n\tconst char *name;\n\tunsigned long config;\n\tunsigned pin;\n};\n\nstruct stm32_gpio_bank {\n\tvoid __iomem *base;\n\tstruct clk *clk;\n\tstruct reset_control *rstc;\n\tspinlock_t lock;\n\tstruct gpio_chip gpio_chip;\n\tstruct pinctrl_gpio_range range;\n\tstruct fwnode_handle *fwnode;\n\tstruct irq_domain *domain;\n\tu32 bank_nr;\n\tu32 bank_ioport_nr;\n\tu32 pin_backup[STM32_GPIO_PINS_PER_BANK];\n\tu8 irq_type[STM32_GPIO_PINS_PER_BANK];\n\tbool secure_control;\n};\n\nstruct stm32_pinctrl {\n\tstruct device *dev;\n\tstruct pinctrl_dev *pctl_dev;\n\tstruct pinctrl_desc pctl_desc;\n\tstruct stm32_pinctrl_group *groups;\n\tunsigned ngroups;\n\tconst char **grp_names;\n\tstruct stm32_gpio_bank *banks;\n\tunsigned nbanks;\n\tconst struct stm32_pinctrl_match_data *match_data;\n\tstruct irq_domain\t*domain;\n\tstruct regmap\t\t*regmap;\n\tstruct regmap_field\t*irqmux[STM32_GPIO_PINS_PER_BANK];\n\tstruct hwspinlock *hwlock;\n\tstruct stm32_desc_pin *pins;\n\tu32 npins;\n\tu32 pkg;\n\tu16 irqmux_map;\n\tspinlock_t irqmux_lock;\n};\n\nstatic inline int stm32_gpio_pin(int gpio)\n{\n\treturn gpio % STM32_GPIO_PINS_PER_BANK;\n}\n\nstatic inline u32 stm32_gpio_get_mode(u32 function)\n{\n\tswitch (function) {\n\tcase STM32_PIN_GPIO:\n\t\treturn 0;\n\tcase STM32_PIN_AF(0) ... STM32_PIN_AF(15):\n\t\treturn 2;\n\tcase STM32_PIN_ANALOG:\n\t\treturn 3;\n\t}\n\n\treturn 0;\n}\n\nstatic inline u32 stm32_gpio_get_alt(u32 function)\n{\n\tswitch (function) {\n\tcase STM32_PIN_GPIO:\n\t\treturn 0;\n\tcase STM32_PIN_AF(0) ... STM32_PIN_AF(15):\n\t\treturn function - 1;\n\tcase STM32_PIN_ANALOG:\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n\nstatic void stm32_gpio_backup_value(struct stm32_gpio_bank *bank,\n\t\t\t\t    u32 offset, u32 value)\n{\n\tbank->pin_backup[offset] &= ~BIT(STM32_GPIO_BKP_VAL);\n\tbank->pin_backup[offset] |= value << STM32_GPIO_BKP_VAL;\n}\n\nstatic void stm32_gpio_backup_mode(struct stm32_gpio_bank *bank, u32 offset,\n\t\t\t\t   u32 mode, u32 alt)\n{\n\tbank->pin_backup[offset] &= ~(STM32_GPIO_BKP_MODE_MASK |\n\t\t\t\t      STM32_GPIO_BKP_ALT_MASK);\n\tbank->pin_backup[offset] |= mode << STM32_GPIO_BKP_MODE_SHIFT;\n\tbank->pin_backup[offset] |= alt << STM32_GPIO_BKP_ALT_SHIFT;\n}\n\nstatic void stm32_gpio_backup_driving(struct stm32_gpio_bank *bank, u32 offset,\n\t\t\t\t      u32 drive)\n{\n\tbank->pin_backup[offset] &= ~BIT(STM32_GPIO_BKP_TYPE);\n\tbank->pin_backup[offset] |= drive << STM32_GPIO_BKP_TYPE;\n}\n\nstatic void stm32_gpio_backup_speed(struct stm32_gpio_bank *bank, u32 offset,\n\t\t\t\t    u32 speed)\n{\n\tbank->pin_backup[offset] &= ~STM32_GPIO_BKP_SPEED_MASK;\n\tbank->pin_backup[offset] |= speed << STM32_GPIO_BKP_SPEED_SHIFT;\n}\n\nstatic void stm32_gpio_backup_bias(struct stm32_gpio_bank *bank, u32 offset,\n\t\t\t\t   u32 bias)\n{\n\tbank->pin_backup[offset] &= ~STM32_GPIO_BKP_PUPD_MASK;\n\tbank->pin_backup[offset] |= bias << STM32_GPIO_BKP_PUPD_SHIFT;\n}\n\n \n\nstatic inline void __stm32_gpio_set(struct stm32_gpio_bank *bank,\n\tunsigned offset, int value)\n{\n\tstm32_gpio_backup_value(bank, offset, value);\n\n\tif (!value)\n\t\toffset += STM32_GPIO_PINS_PER_BANK;\n\n\twritel_relaxed(BIT(offset), bank->base + STM32_GPIO_BSRR);\n}\n\nstatic int stm32_gpio_request(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct stm32_gpio_bank *bank = gpiochip_get_data(chip);\n\tstruct stm32_pinctrl *pctl = dev_get_drvdata(bank->gpio_chip.parent);\n\tstruct pinctrl_gpio_range *range;\n\tint pin = offset + (bank->bank_nr * STM32_GPIO_PINS_PER_BANK);\n\n\trange = pinctrl_find_gpio_range_from_pin_nolock(pctl->pctl_dev, pin);\n\tif (!range) {\n\t\tdev_err(pctl->dev, \"pin %d not in range.\\n\", pin);\n\t\treturn -EINVAL;\n\t}\n\n\treturn pinctrl_gpio_request(chip->base + offset);\n}\n\nstatic void stm32_gpio_free(struct gpio_chip *chip, unsigned offset)\n{\n\tpinctrl_gpio_free(chip->base + offset);\n}\n\nstatic int stm32_gpio_get(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct stm32_gpio_bank *bank = gpiochip_get_data(chip);\n\n\treturn !!(readl_relaxed(bank->base + STM32_GPIO_IDR) & BIT(offset));\n}\n\nstatic void stm32_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\n{\n\tstruct stm32_gpio_bank *bank = gpiochip_get_data(chip);\n\n\t__stm32_gpio_set(bank, offset, value);\n}\n\nstatic int stm32_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\n{\n\treturn pinctrl_gpio_direction_input(chip->base + offset);\n}\n\nstatic int stm32_gpio_direction_output(struct gpio_chip *chip,\n\tunsigned offset, int value)\n{\n\tstruct stm32_gpio_bank *bank = gpiochip_get_data(chip);\n\n\t__stm32_gpio_set(bank, offset, value);\n\tpinctrl_gpio_direction_output(chip->base + offset);\n\n\treturn 0;\n}\n\n\nstatic int stm32_gpio_to_irq(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct stm32_gpio_bank *bank = gpiochip_get_data(chip);\n\tstruct irq_fwspec fwspec;\n\n\tfwspec.fwnode = bank->fwnode;\n\tfwspec.param_count = 2;\n\tfwspec.param[0] = offset;\n\tfwspec.param[1] = IRQ_TYPE_NONE;\n\n\treturn irq_create_fwspec_mapping(&fwspec);\n}\n\nstatic int stm32_gpio_get_direction(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct stm32_gpio_bank *bank = gpiochip_get_data(chip);\n\tint pin = stm32_gpio_pin(offset);\n\tint ret;\n\tu32 mode, alt;\n\n\tstm32_pmx_get_mode(bank, pin, &mode, &alt);\n\tif ((alt == 0) && (mode == 0))\n\t\tret = GPIO_LINE_DIRECTION_IN;\n\telse if ((alt == 0) && (mode == 1))\n\t\tret = GPIO_LINE_DIRECTION_OUT;\n\telse\n\t\tret = -EINVAL;\n\n\treturn ret;\n}\n\nstatic int stm32_gpio_init_valid_mask(struct gpio_chip *chip,\n\t\t\t\t      unsigned long *valid_mask,\n\t\t\t\t      unsigned int ngpios)\n{\n\tstruct stm32_gpio_bank *bank = gpiochip_get_data(chip);\n\tstruct stm32_pinctrl *pctl = dev_get_drvdata(bank->gpio_chip.parent);\n\tunsigned int i;\n\tu32 sec;\n\n\t \n\tbitmap_fill(valid_mask, ngpios);\n\n\tif (bank->secure_control) {\n\t\t \n\t\tsec = readl_relaxed(bank->base + STM32_GPIO_SECCFGR);\n\n\t\tfor (i = 0; i < ngpios; i++) {\n\t\t\tif (sec & BIT(i)) {\n\t\t\t\tclear_bit(i, valid_mask);\n\t\t\t\tdev_dbg(pctl->dev, \"No access to gpio %d - %d\\n\", bank->bank_nr, i);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct gpio_chip stm32_gpio_template = {\n\t.request\t\t= stm32_gpio_request,\n\t.free\t\t\t= stm32_gpio_free,\n\t.get\t\t\t= stm32_gpio_get,\n\t.set\t\t\t= stm32_gpio_set,\n\t.direction_input\t= stm32_gpio_direction_input,\n\t.direction_output\t= stm32_gpio_direction_output,\n\t.to_irq\t\t\t= stm32_gpio_to_irq,\n\t.get_direction\t\t= stm32_gpio_get_direction,\n\t.set_config\t\t= gpiochip_generic_config,\n\t.init_valid_mask\t= stm32_gpio_init_valid_mask,\n};\n\nstatic void stm32_gpio_irq_trigger(struct irq_data *d)\n{\n\tstruct stm32_gpio_bank *bank = d->domain->host_data;\n\tint level;\n\n\t \n\tif (!(bank->irq_type[d->hwirq] & IRQ_TYPE_LEVEL_MASK))\n\t\treturn;\n\n\t \n\tlevel = stm32_gpio_get(&bank->gpio_chip, d->hwirq);\n\tif ((level == 0 && bank->irq_type[d->hwirq] == IRQ_TYPE_LEVEL_LOW) ||\n\t    (level == 1 && bank->irq_type[d->hwirq] == IRQ_TYPE_LEVEL_HIGH))\n\t\tirq_chip_retrigger_hierarchy(d);\n}\n\nstatic void stm32_gpio_irq_eoi(struct irq_data *d)\n{\n\tirq_chip_eoi_parent(d);\n\tstm32_gpio_irq_trigger(d);\n};\n\nstatic int stm32_gpio_set_type(struct irq_data *d, unsigned int type)\n{\n\tstruct stm32_gpio_bank *bank = d->domain->host_data;\n\tu32 parent_type;\n\n\tswitch (type) {\n\tcase IRQ_TYPE_EDGE_RISING:\n\tcase IRQ_TYPE_EDGE_FALLING:\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\tparent_type = type;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tparent_type = IRQ_TYPE_EDGE_RISING;\n\t\tbreak;\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tparent_type = IRQ_TYPE_EDGE_FALLING;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tbank->irq_type[d->hwirq] = type;\n\n\treturn irq_chip_set_type_parent(d, parent_type);\n};\n\nstatic int stm32_gpio_irq_request_resources(struct irq_data *irq_data)\n{\n\tstruct stm32_gpio_bank *bank = irq_data->domain->host_data;\n\tstruct stm32_pinctrl *pctl = dev_get_drvdata(bank->gpio_chip.parent);\n\tint ret;\n\n\tret = stm32_gpio_direction_input(&bank->gpio_chip, irq_data->hwirq);\n\tif (ret)\n\t\treturn ret;\n\n\tret = gpiochip_lock_as_irq(&bank->gpio_chip, irq_data->hwirq);\n\tif (ret) {\n\t\tdev_err(pctl->dev, \"unable to lock HW IRQ %lu for IRQ\\n\",\n\t\t\tirq_data->hwirq);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void stm32_gpio_irq_release_resources(struct irq_data *irq_data)\n{\n\tstruct stm32_gpio_bank *bank = irq_data->domain->host_data;\n\n\tgpiochip_unlock_as_irq(&bank->gpio_chip, irq_data->hwirq);\n}\n\nstatic void stm32_gpio_irq_unmask(struct irq_data *d)\n{\n\tirq_chip_unmask_parent(d);\n\tstm32_gpio_irq_trigger(d);\n}\n\nstatic struct irq_chip stm32_gpio_irq_chip = {\n\t.name\t\t= \"stm32gpio\",\n\t.irq_eoi\t= stm32_gpio_irq_eoi,\n\t.irq_ack\t= irq_chip_ack_parent,\n\t.irq_mask\t= irq_chip_mask_parent,\n\t.irq_unmask\t= stm32_gpio_irq_unmask,\n\t.irq_set_type\t= stm32_gpio_set_type,\n\t.irq_set_wake\t= irq_chip_set_wake_parent,\n\t.irq_request_resources = stm32_gpio_irq_request_resources,\n\t.irq_release_resources = stm32_gpio_irq_release_resources,\n};\n\nstatic int stm32_gpio_domain_translate(struct irq_domain *d,\n\t\t\t\t       struct irq_fwspec *fwspec,\n\t\t\t\t       unsigned long *hwirq,\n\t\t\t\t       unsigned int *type)\n{\n\tif ((fwspec->param_count != 2) ||\n\t    (fwspec->param[0] >= STM32_GPIO_IRQ_LINE))\n\t\treturn -EINVAL;\n\n\t*hwirq = fwspec->param[0];\n\t*type = fwspec->param[1];\n\treturn 0;\n}\n\nstatic int stm32_gpio_domain_activate(struct irq_domain *d,\n\t\t\t\t      struct irq_data *irq_data, bool reserve)\n{\n\tstruct stm32_gpio_bank *bank = d->host_data;\n\tstruct stm32_pinctrl *pctl = dev_get_drvdata(bank->gpio_chip.parent);\n\tint ret = 0;\n\n\tif (pctl->hwlock) {\n\t\tret = hwspin_lock_timeout_in_atomic(pctl->hwlock,\n\t\t\t\t\t\t    HWSPNLCK_TIMEOUT);\n\t\tif (ret) {\n\t\t\tdev_err(pctl->dev, \"Can't get hwspinlock\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tregmap_field_write(pctl->irqmux[irq_data->hwirq], bank->bank_ioport_nr);\n\n\tif (pctl->hwlock)\n\t\thwspin_unlock_in_atomic(pctl->hwlock);\n\n\treturn ret;\n}\n\nstatic int stm32_gpio_domain_alloc(struct irq_domain *d,\n\t\t\t\t   unsigned int virq,\n\t\t\t\t   unsigned int nr_irqs, void *data)\n{\n\tstruct stm32_gpio_bank *bank = d->host_data;\n\tstruct irq_fwspec *fwspec = data;\n\tstruct irq_fwspec parent_fwspec;\n\tstruct stm32_pinctrl *pctl = dev_get_drvdata(bank->gpio_chip.parent);\n\tirq_hw_number_t hwirq = fwspec->param[0];\n\tunsigned long flags;\n\tint ret = 0;\n\n\t \n\tspin_lock_irqsave(&pctl->irqmux_lock, flags);\n\n\tif (pctl->irqmux_map & BIT(hwirq)) {\n\t\tdev_err(pctl->dev, \"irq line %ld already requested.\\n\", hwirq);\n\t\tret = -EBUSY;\n\t} else {\n\t\tpctl->irqmux_map |= BIT(hwirq);\n\t}\n\n\tspin_unlock_irqrestore(&pctl->irqmux_lock, flags);\n\tif (ret)\n\t\treturn ret;\n\n\tparent_fwspec.fwnode = d->parent->fwnode;\n\tparent_fwspec.param_count = 2;\n\tparent_fwspec.param[0] = fwspec->param[0];\n\tparent_fwspec.param[1] = fwspec->param[1];\n\n\tirq_domain_set_hwirq_and_chip(d, virq, hwirq, &stm32_gpio_irq_chip,\n\t\t\t\t      bank);\n\n\treturn irq_domain_alloc_irqs_parent(d, virq, nr_irqs, &parent_fwspec);\n}\n\nstatic void stm32_gpio_domain_free(struct irq_domain *d, unsigned int virq,\n\t\t\t\t   unsigned int nr_irqs)\n{\n\tstruct stm32_gpio_bank *bank = d->host_data;\n\tstruct stm32_pinctrl *pctl = dev_get_drvdata(bank->gpio_chip.parent);\n\tstruct irq_data *irq_data = irq_domain_get_irq_data(d, virq);\n\tunsigned long flags, hwirq = irq_data->hwirq;\n\n\tirq_domain_free_irqs_common(d, virq, nr_irqs);\n\n\tspin_lock_irqsave(&pctl->irqmux_lock, flags);\n\tpctl->irqmux_map &= ~BIT(hwirq);\n\tspin_unlock_irqrestore(&pctl->irqmux_lock, flags);\n}\n\nstatic const struct irq_domain_ops stm32_gpio_domain_ops = {\n\t.translate\t= stm32_gpio_domain_translate,\n\t.alloc\t\t= stm32_gpio_domain_alloc,\n\t.free\t\t= stm32_gpio_domain_free,\n\t.activate\t= stm32_gpio_domain_activate,\n};\n\n \nstatic struct stm32_pinctrl_group *\nstm32_pctrl_find_group_by_pin(struct stm32_pinctrl *pctl, u32 pin)\n{\n\tint i;\n\n\tfor (i = 0; i < pctl->ngroups; i++) {\n\t\tstruct stm32_pinctrl_group *grp = pctl->groups + i;\n\n\t\tif (grp->pin == pin)\n\t\t\treturn grp;\n\t}\n\n\treturn NULL;\n}\n\nstatic bool stm32_pctrl_is_function_valid(struct stm32_pinctrl *pctl,\n\t\tu32 pin_num, u32 fnum)\n{\n\tint i, k;\n\n\tfor (i = 0; i < pctl->npins; i++) {\n\t\tconst struct stm32_desc_pin *pin = pctl->pins + i;\n\t\tconst struct stm32_desc_function *func = pin->functions;\n\n\t\tif (pin->pin.number != pin_num)\n\t\t\tcontinue;\n\n\t\tfor (k = 0; k < STM32_CONFIG_NUM; k++) {\n\t\t\tif (func->num == fnum)\n\t\t\t\treturn true;\n\t\t\tfunc++;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tdev_err(pctl->dev, \"invalid function %d on pin %d .\\n\", fnum, pin_num);\n\n\treturn false;\n}\n\nstatic int stm32_pctrl_dt_node_to_map_func(struct stm32_pinctrl *pctl,\n\t\tu32 pin, u32 fnum, struct stm32_pinctrl_group *grp,\n\t\tstruct pinctrl_map **map, unsigned *reserved_maps,\n\t\tunsigned *num_maps)\n{\n\tif (*num_maps == *reserved_maps)\n\t\treturn -ENOSPC;\n\n\t(*map)[*num_maps].type = PIN_MAP_TYPE_MUX_GROUP;\n\t(*map)[*num_maps].data.mux.group = grp->name;\n\n\tif (!stm32_pctrl_is_function_valid(pctl, pin, fnum))\n\t\treturn -EINVAL;\n\n\t(*map)[*num_maps].data.mux.function = stm32_gpio_functions[fnum];\n\t(*num_maps)++;\n\n\treturn 0;\n}\n\nstatic int stm32_pctrl_dt_subnode_to_map(struct pinctrl_dev *pctldev,\n\t\t\t\t      struct device_node *node,\n\t\t\t\t      struct pinctrl_map **map,\n\t\t\t\t      unsigned *reserved_maps,\n\t\t\t\t      unsigned *num_maps)\n{\n\tstruct stm32_pinctrl *pctl;\n\tstruct stm32_pinctrl_group *grp;\n\tstruct property *pins;\n\tu32 pinfunc, pin, func;\n\tunsigned long *configs;\n\tunsigned int num_configs;\n\tbool has_config = 0;\n\tunsigned reserve = 0;\n\tint num_pins, num_funcs, maps_per_pin, i, err = 0;\n\n\tpctl = pinctrl_dev_get_drvdata(pctldev);\n\n\tpins = of_find_property(node, \"pinmux\", NULL);\n\tif (!pins) {\n\t\tdev_err(pctl->dev, \"missing pins property in node %pOFn .\\n\",\n\t\t\t\tnode);\n\t\treturn -EINVAL;\n\t}\n\n\terr = pinconf_generic_parse_dt_config(node, pctldev, &configs,\n\t\t&num_configs);\n\tif (err)\n\t\treturn err;\n\n\tif (num_configs)\n\t\thas_config = 1;\n\n\tnum_pins = pins->length / sizeof(u32);\n\tnum_funcs = num_pins;\n\tmaps_per_pin = 0;\n\tif (num_funcs)\n\t\tmaps_per_pin++;\n\tif (has_config && num_pins >= 1)\n\t\tmaps_per_pin++;\n\n\tif (!num_pins || !maps_per_pin) {\n\t\terr = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\treserve = num_pins * maps_per_pin;\n\n\terr = pinctrl_utils_reserve_map(pctldev, map,\n\t\t\treserved_maps, num_maps, reserve);\n\tif (err)\n\t\tgoto exit;\n\n\tfor (i = 0; i < num_pins; i++) {\n\t\terr = of_property_read_u32_index(node, \"pinmux\",\n\t\t\t\ti, &pinfunc);\n\t\tif (err)\n\t\t\tgoto exit;\n\n\t\tpin = STM32_GET_PIN_NO(pinfunc);\n\t\tfunc = STM32_GET_PIN_FUNC(pinfunc);\n\n\t\tif (!stm32_pctrl_is_function_valid(pctl, pin, func)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tgrp = stm32_pctrl_find_group_by_pin(pctl, pin);\n\t\tif (!grp) {\n\t\t\tdev_err(pctl->dev, \"unable to match pin %d to group\\n\",\n\t\t\t\t\tpin);\n\t\t\terr = -EINVAL;\n\t\t\tgoto exit;\n\t\t}\n\n\t\terr = stm32_pctrl_dt_node_to_map_func(pctl, pin, func, grp, map,\n\t\t\t\treserved_maps, num_maps);\n\t\tif (err)\n\t\t\tgoto exit;\n\n\t\tif (has_config) {\n\t\t\terr = pinctrl_utils_add_map_configs(pctldev, map,\n\t\t\t\t\treserved_maps, num_maps, grp->name,\n\t\t\t\t\tconfigs, num_configs,\n\t\t\t\t\tPIN_MAP_TYPE_CONFIGS_GROUP);\n\t\t\tif (err)\n\t\t\t\tgoto exit;\n\t\t}\n\t}\n\nexit:\n\tkfree(configs);\n\treturn err;\n}\n\nstatic int stm32_pctrl_dt_node_to_map(struct pinctrl_dev *pctldev,\n\t\t\t\t struct device_node *np_config,\n\t\t\t\t struct pinctrl_map **map, unsigned *num_maps)\n{\n\tstruct device_node *np;\n\tunsigned reserved_maps;\n\tint ret;\n\n\t*map = NULL;\n\t*num_maps = 0;\n\treserved_maps = 0;\n\n\tfor_each_child_of_node(np_config, np) {\n\t\tret = stm32_pctrl_dt_subnode_to_map(pctldev, np, map,\n\t\t\t\t&reserved_maps, num_maps);\n\t\tif (ret < 0) {\n\t\t\tpinctrl_utils_free_map(pctldev, *map, *num_maps);\n\t\t\tof_node_put(np);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int stm32_pctrl_get_groups_count(struct pinctrl_dev *pctldev)\n{\n\tstruct stm32_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pctl->ngroups;\n}\n\nstatic const char *stm32_pctrl_get_group_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t      unsigned group)\n{\n\tstruct stm32_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn pctl->groups[group].name;\n}\n\nstatic int stm32_pctrl_get_group_pins(struct pinctrl_dev *pctldev,\n\t\t\t\t      unsigned group,\n\t\t\t\t      const unsigned **pins,\n\t\t\t\t      unsigned *num_pins)\n{\n\tstruct stm32_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\n\t*pins = (unsigned *)&pctl->groups[group].pin;\n\t*num_pins = 1;\n\n\treturn 0;\n}\n\nstatic const struct pinctrl_ops stm32_pctrl_ops = {\n\t.dt_node_to_map\t\t= stm32_pctrl_dt_node_to_map,\n\t.dt_free_map\t\t= pinctrl_utils_free_map,\n\t.get_groups_count\t= stm32_pctrl_get_groups_count,\n\t.get_group_name\t\t= stm32_pctrl_get_group_name,\n\t.get_group_pins\t\t= stm32_pctrl_get_group_pins,\n};\n\n\n \n\nstatic int stm32_pmx_get_funcs_cnt(struct pinctrl_dev *pctldev)\n{\n\treturn ARRAY_SIZE(stm32_gpio_functions);\n}\n\nstatic const char *stm32_pmx_get_func_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t   unsigned selector)\n{\n\treturn stm32_gpio_functions[selector];\n}\n\nstatic int stm32_pmx_get_func_groups(struct pinctrl_dev *pctldev,\n\t\t\t\t     unsigned function,\n\t\t\t\t     const char * const **groups,\n\t\t\t\t     unsigned * const num_groups)\n{\n\tstruct stm32_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\n\t*groups = pctl->grp_names;\n\t*num_groups = pctl->ngroups;\n\n\treturn 0;\n}\n\nstatic int stm32_pmx_set_mode(struct stm32_gpio_bank *bank,\n\t\t\t      int pin, u32 mode, u32 alt)\n{\n\tstruct stm32_pinctrl *pctl = dev_get_drvdata(bank->gpio_chip.parent);\n\tu32 val;\n\tint alt_shift = (pin % 8) * 4;\n\tint alt_offset = STM32_GPIO_AFRL + (pin / 8) * 4;\n\tunsigned long flags;\n\tint err = 0;\n\n\tspin_lock_irqsave(&bank->lock, flags);\n\n\tif (pctl->hwlock) {\n\t\terr = hwspin_lock_timeout_in_atomic(pctl->hwlock,\n\t\t\t\t\t\t    HWSPNLCK_TIMEOUT);\n\t\tif (err) {\n\t\t\tdev_err(pctl->dev, \"Can't get hwspinlock\\n\");\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tval = readl_relaxed(bank->base + alt_offset);\n\tval &= ~GENMASK(alt_shift + 3, alt_shift);\n\tval |= (alt << alt_shift);\n\twritel_relaxed(val, bank->base + alt_offset);\n\n\tval = readl_relaxed(bank->base + STM32_GPIO_MODER);\n\tval &= ~GENMASK(pin * 2 + 1, pin * 2);\n\tval |= mode << (pin * 2);\n\twritel_relaxed(val, bank->base + STM32_GPIO_MODER);\n\n\tif (pctl->hwlock)\n\t\thwspin_unlock_in_atomic(pctl->hwlock);\n\n\tstm32_gpio_backup_mode(bank, pin, mode, alt);\n\nunlock:\n\tspin_unlock_irqrestore(&bank->lock, flags);\n\n\treturn err;\n}\n\nvoid stm32_pmx_get_mode(struct stm32_gpio_bank *bank, int pin, u32 *mode,\n\t\t\tu32 *alt)\n{\n\tu32 val;\n\tint alt_shift = (pin % 8) * 4;\n\tint alt_offset = STM32_GPIO_AFRL + (pin / 8) * 4;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&bank->lock, flags);\n\n\tval = readl_relaxed(bank->base + alt_offset);\n\tval &= GENMASK(alt_shift + 3, alt_shift);\n\t*alt = val >> alt_shift;\n\n\tval = readl_relaxed(bank->base + STM32_GPIO_MODER);\n\tval &= GENMASK(pin * 2 + 1, pin * 2);\n\t*mode = val >> (pin * 2);\n\n\tspin_unlock_irqrestore(&bank->lock, flags);\n}\n\nstatic int stm32_pmx_set_mux(struct pinctrl_dev *pctldev,\n\t\t\t    unsigned function,\n\t\t\t    unsigned group)\n{\n\tbool ret;\n\tstruct stm32_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct stm32_pinctrl_group *g = pctl->groups + group;\n\tstruct pinctrl_gpio_range *range;\n\tstruct stm32_gpio_bank *bank;\n\tu32 mode, alt;\n\tint pin;\n\n\tret = stm32_pctrl_is_function_valid(pctl, g->pin, function);\n\tif (!ret)\n\t\treturn -EINVAL;\n\n\trange = pinctrl_find_gpio_range_from_pin(pctldev, g->pin);\n\tif (!range) {\n\t\tdev_err(pctl->dev, \"No gpio range defined.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbank = gpiochip_get_data(range->gc);\n\tpin = stm32_gpio_pin(g->pin);\n\n\tmode = stm32_gpio_get_mode(function);\n\talt = stm32_gpio_get_alt(function);\n\n\treturn stm32_pmx_set_mode(bank, pin, mode, alt);\n}\n\nstatic int stm32_pmx_gpio_set_direction(struct pinctrl_dev *pctldev,\n\t\t\tstruct pinctrl_gpio_range *range, unsigned gpio,\n\t\t\tbool input)\n{\n\tstruct stm32_gpio_bank *bank = gpiochip_get_data(range->gc);\n\tint pin = stm32_gpio_pin(gpio);\n\n\treturn stm32_pmx_set_mode(bank, pin, !input, 0);\n}\n\nstatic int stm32_pmx_request(struct pinctrl_dev *pctldev, unsigned int gpio)\n{\n\tstruct stm32_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct pinctrl_gpio_range *range;\n\n\trange = pinctrl_find_gpio_range_from_pin_nolock(pctldev, gpio);\n\tif (!range) {\n\t\tdev_err(pctl->dev, \"No gpio range defined.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!gpiochip_line_is_valid(range->gc, stm32_gpio_pin(gpio))) {\n\t\tdev_warn(pctl->dev, \"Can't access gpio %d\\n\", gpio);\n\t\treturn -EACCES;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct pinmux_ops stm32_pmx_ops = {\n\t.get_functions_count\t= stm32_pmx_get_funcs_cnt,\n\t.get_function_name\t= stm32_pmx_get_func_name,\n\t.get_function_groups\t= stm32_pmx_get_func_groups,\n\t.set_mux\t\t= stm32_pmx_set_mux,\n\t.gpio_set_direction\t= stm32_pmx_gpio_set_direction,\n\t.request\t\t= stm32_pmx_request,\n\t.strict\t\t\t= true,\n};\n\n \n\nstatic int stm32_pconf_set_driving(struct stm32_gpio_bank *bank,\n\t\t\t\t   unsigned offset, u32 drive)\n{\n\tstruct stm32_pinctrl *pctl = dev_get_drvdata(bank->gpio_chip.parent);\n\tunsigned long flags;\n\tu32 val;\n\tint err = 0;\n\n\tspin_lock_irqsave(&bank->lock, flags);\n\n\tif (pctl->hwlock) {\n\t\terr = hwspin_lock_timeout_in_atomic(pctl->hwlock,\n\t\t\t\t\t\t    HWSPNLCK_TIMEOUT);\n\t\tif (err) {\n\t\t\tdev_err(pctl->dev, \"Can't get hwspinlock\\n\");\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tval = readl_relaxed(bank->base + STM32_GPIO_TYPER);\n\tval &= ~BIT(offset);\n\tval |= drive << offset;\n\twritel_relaxed(val, bank->base + STM32_GPIO_TYPER);\n\n\tif (pctl->hwlock)\n\t\thwspin_unlock_in_atomic(pctl->hwlock);\n\n\tstm32_gpio_backup_driving(bank, offset, drive);\n\nunlock:\n\tspin_unlock_irqrestore(&bank->lock, flags);\n\n\treturn err;\n}\n\nstatic u32 stm32_pconf_get_driving(struct stm32_gpio_bank *bank,\n\tunsigned int offset)\n{\n\tunsigned long flags;\n\tu32 val;\n\n\tspin_lock_irqsave(&bank->lock, flags);\n\n\tval = readl_relaxed(bank->base + STM32_GPIO_TYPER);\n\tval &= BIT(offset);\n\n\tspin_unlock_irqrestore(&bank->lock, flags);\n\n\treturn (val >> offset);\n}\n\nstatic int stm32_pconf_set_speed(struct stm32_gpio_bank *bank,\n\t\t\t\t unsigned offset, u32 speed)\n{\n\tstruct stm32_pinctrl *pctl = dev_get_drvdata(bank->gpio_chip.parent);\n\tunsigned long flags;\n\tu32 val;\n\tint err = 0;\n\n\tspin_lock_irqsave(&bank->lock, flags);\n\n\tif (pctl->hwlock) {\n\t\terr = hwspin_lock_timeout_in_atomic(pctl->hwlock,\n\t\t\t\t\t\t    HWSPNLCK_TIMEOUT);\n\t\tif (err) {\n\t\t\tdev_err(pctl->dev, \"Can't get hwspinlock\\n\");\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tval = readl_relaxed(bank->base + STM32_GPIO_SPEEDR);\n\tval &= ~GENMASK(offset * 2 + 1, offset * 2);\n\tval |= speed << (offset * 2);\n\twritel_relaxed(val, bank->base + STM32_GPIO_SPEEDR);\n\n\tif (pctl->hwlock)\n\t\thwspin_unlock_in_atomic(pctl->hwlock);\n\n\tstm32_gpio_backup_speed(bank, offset, speed);\n\nunlock:\n\tspin_unlock_irqrestore(&bank->lock, flags);\n\n\treturn err;\n}\n\nstatic u32 stm32_pconf_get_speed(struct stm32_gpio_bank *bank,\n\tunsigned int offset)\n{\n\tunsigned long flags;\n\tu32 val;\n\n\tspin_lock_irqsave(&bank->lock, flags);\n\n\tval = readl_relaxed(bank->base + STM32_GPIO_SPEEDR);\n\tval &= GENMASK(offset * 2 + 1, offset * 2);\n\n\tspin_unlock_irqrestore(&bank->lock, flags);\n\n\treturn (val >> (offset * 2));\n}\n\nstatic int stm32_pconf_set_bias(struct stm32_gpio_bank *bank,\n\t\t\t\tunsigned offset, u32 bias)\n{\n\tstruct stm32_pinctrl *pctl = dev_get_drvdata(bank->gpio_chip.parent);\n\tunsigned long flags;\n\tu32 val;\n\tint err = 0;\n\n\tspin_lock_irqsave(&bank->lock, flags);\n\n\tif (pctl->hwlock) {\n\t\terr = hwspin_lock_timeout_in_atomic(pctl->hwlock,\n\t\t\t\t\t\t    HWSPNLCK_TIMEOUT);\n\t\tif (err) {\n\t\t\tdev_err(pctl->dev, \"Can't get hwspinlock\\n\");\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tval = readl_relaxed(bank->base + STM32_GPIO_PUPDR);\n\tval &= ~GENMASK(offset * 2 + 1, offset * 2);\n\tval |= bias << (offset * 2);\n\twritel_relaxed(val, bank->base + STM32_GPIO_PUPDR);\n\n\tif (pctl->hwlock)\n\t\thwspin_unlock_in_atomic(pctl->hwlock);\n\n\tstm32_gpio_backup_bias(bank, offset, bias);\n\nunlock:\n\tspin_unlock_irqrestore(&bank->lock, flags);\n\n\treturn err;\n}\n\nstatic u32 stm32_pconf_get_bias(struct stm32_gpio_bank *bank,\n\tunsigned int offset)\n{\n\tunsigned long flags;\n\tu32 val;\n\n\tspin_lock_irqsave(&bank->lock, flags);\n\n\tval = readl_relaxed(bank->base + STM32_GPIO_PUPDR);\n\tval &= GENMASK(offset * 2 + 1, offset * 2);\n\n\tspin_unlock_irqrestore(&bank->lock, flags);\n\n\treturn (val >> (offset * 2));\n}\n\nstatic bool stm32_pconf_get(struct stm32_gpio_bank *bank,\n\tunsigned int offset, bool dir)\n{\n\tunsigned long flags;\n\tu32 val;\n\n\tspin_lock_irqsave(&bank->lock, flags);\n\n\tif (dir)\n\t\tval = !!(readl_relaxed(bank->base + STM32_GPIO_IDR) &\n\t\t\t BIT(offset));\n\telse\n\t\tval = !!(readl_relaxed(bank->base + STM32_GPIO_ODR) &\n\t\t\t BIT(offset));\n\n\tspin_unlock_irqrestore(&bank->lock, flags);\n\n\treturn val;\n}\n\nstatic int stm32_pconf_parse_conf(struct pinctrl_dev *pctldev,\n\t\tunsigned int pin, enum pin_config_param param,\n\t\tenum pin_config_param arg)\n{\n\tstruct stm32_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct pinctrl_gpio_range *range;\n\tstruct stm32_gpio_bank *bank;\n\tint offset, ret = 0;\n\n\trange = pinctrl_find_gpio_range_from_pin_nolock(pctldev, pin);\n\tif (!range) {\n\t\tdev_err(pctl->dev, \"No gpio range defined.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbank = gpiochip_get_data(range->gc);\n\toffset = stm32_gpio_pin(pin);\n\n\tif (!gpiochip_line_is_valid(range->gc, offset)) {\n\t\tdev_warn(pctl->dev, \"Can't access gpio %d\\n\", pin);\n\t\treturn -EACCES;\n\t}\n\n\tswitch (param) {\n\tcase PIN_CONFIG_DRIVE_PUSH_PULL:\n\t\tret = stm32_pconf_set_driving(bank, offset, 0);\n\t\tbreak;\n\tcase PIN_CONFIG_DRIVE_OPEN_DRAIN:\n\t\tret = stm32_pconf_set_driving(bank, offset, 1);\n\t\tbreak;\n\tcase PIN_CONFIG_SLEW_RATE:\n\t\tret = stm32_pconf_set_speed(bank, offset, arg);\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\tret = stm32_pconf_set_bias(bank, offset, 0);\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\tret = stm32_pconf_set_bias(bank, offset, 1);\n\t\tbreak;\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\tret = stm32_pconf_set_bias(bank, offset, 2);\n\t\tbreak;\n\tcase PIN_CONFIG_OUTPUT:\n\t\t__stm32_gpio_set(bank, offset, arg);\n\t\tret = stm32_pmx_gpio_set_direction(pctldev, range, pin, false);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOTSUPP;\n\t}\n\n\treturn ret;\n}\n\nstatic int stm32_pconf_group_get(struct pinctrl_dev *pctldev,\n\t\t\t\t unsigned group,\n\t\t\t\t unsigned long *config)\n{\n\tstruct stm32_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\n\t*config = pctl->groups[group].config;\n\n\treturn 0;\n}\n\nstatic int stm32_pconf_group_set(struct pinctrl_dev *pctldev, unsigned group,\n\t\t\t\t unsigned long *configs, unsigned num_configs)\n{\n\tstruct stm32_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tstruct stm32_pinctrl_group *g = &pctl->groups[group];\n\tint i, ret;\n\n\tfor (i = 0; i < num_configs; i++) {\n\t\tmutex_lock(&pctldev->mutex);\n\t\tret = stm32_pconf_parse_conf(pctldev, g->pin,\n\t\t\tpinconf_to_config_param(configs[i]),\n\t\t\tpinconf_to_config_argument(configs[i]));\n\t\tmutex_unlock(&pctldev->mutex);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tg->config = configs[i];\n\t}\n\n\treturn 0;\n}\n\nstatic int stm32_pconf_set(struct pinctrl_dev *pctldev, unsigned int pin,\n\t\t\t   unsigned long *configs, unsigned int num_configs)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < num_configs; i++) {\n\t\tret = stm32_pconf_parse_conf(pctldev, pin,\n\t\t\t\tpinconf_to_config_param(configs[i]),\n\t\t\t\tpinconf_to_config_argument(configs[i]));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic struct stm32_desc_pin *\nstm32_pconf_get_pin_desc_by_pin_number(struct stm32_pinctrl *pctl,\n\t\t\t\t       unsigned int pin_number)\n{\n\tstruct stm32_desc_pin *pins = pctl->pins;\n\tint i;\n\n\tfor (i = 0; i < pctl->npins; i++) {\n\t\tif (pins->pin.number == pin_number)\n\t\t\treturn pins;\n\t\tpins++;\n\t}\n\treturn NULL;\n}\n\nstatic void stm32_pconf_dbg_show(struct pinctrl_dev *pctldev,\n\t\t\t\t struct seq_file *s,\n\t\t\t\t unsigned int pin)\n{\n\tstruct stm32_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct stm32_desc_pin *pin_desc;\n\tstruct pinctrl_gpio_range *range;\n\tstruct stm32_gpio_bank *bank;\n\tint offset;\n\tu32 mode, alt, drive, speed, bias;\n\tstatic const char * const modes[] = {\n\t\t\t\"input\", \"output\", \"alternate\", \"analog\" };\n\tstatic const char * const speeds[] = {\n\t\t\t\"low\", \"medium\", \"high\", \"very high\" };\n\tstatic const char * const biasing[] = {\n\t\t\t\"floating\", \"pull up\", \"pull down\", \"\" };\n\tbool val;\n\n\trange = pinctrl_find_gpio_range_from_pin_nolock(pctldev, pin);\n\tif (!range)\n\t\treturn;\n\n\tbank = gpiochip_get_data(range->gc);\n\toffset = stm32_gpio_pin(pin);\n\n\tif (!gpiochip_line_is_valid(range->gc, offset)) {\n\t\tseq_puts(s, \"NO ACCESS\");\n\t\treturn;\n\t}\n\n\tstm32_pmx_get_mode(bank, offset, &mode, &alt);\n\tbias = stm32_pconf_get_bias(bank, offset);\n\n\tseq_printf(s, \"%s \", modes[mode]);\n\n\tswitch (mode) {\n\t \n\tcase 0:\n\t\tval = stm32_pconf_get(bank, offset, true);\n\t\tseq_printf(s, \"- %s - %s\",\n\t\t\t   val ? \"high\" : \"low\",\n\t\t\t   biasing[bias]);\n\t\tbreak;\n\n\t \n\tcase 1:\n\t\tdrive = stm32_pconf_get_driving(bank, offset);\n\t\tspeed = stm32_pconf_get_speed(bank, offset);\n\t\tval = stm32_pconf_get(bank, offset, false);\n\t\tseq_printf(s, \"- %s - %s - %s - %s %s\",\n\t\t\t   val ? \"high\" : \"low\",\n\t\t\t   drive ? \"open drain\" : \"push pull\",\n\t\t\t   biasing[bias],\n\t\t\t   speeds[speed], \"speed\");\n\t\tbreak;\n\n\t \n\tcase 2:\n\t\tdrive = stm32_pconf_get_driving(bank, offset);\n\t\tspeed = stm32_pconf_get_speed(bank, offset);\n\t\tpin_desc = stm32_pconf_get_pin_desc_by_pin_number(pctl, pin);\n\t\tif (!pin_desc)\n\t\t\treturn;\n\n\t\tseq_printf(s, \"%d (%s) - %s - %s - %s %s\", alt,\n\t\t\t   pin_desc->functions[alt + 1].name,\n\t\t\t   drive ? \"open drain\" : \"push pull\",\n\t\t\t   biasing[bias],\n\t\t\t   speeds[speed], \"speed\");\n\t\tbreak;\n\n\t \n\tcase 3:\n\t\tbreak;\n\t}\n}\n\nstatic const struct pinconf_ops stm32_pconf_ops = {\n\t.pin_config_group_get\t= stm32_pconf_group_get,\n\t.pin_config_group_set\t= stm32_pconf_group_set,\n\t.pin_config_set\t\t= stm32_pconf_set,\n\t.pin_config_dbg_show\t= stm32_pconf_dbg_show,\n};\n\nstatic struct stm32_desc_pin *stm32_pctrl_get_desc_pin_from_gpio(struct stm32_pinctrl *pctl,\n\t\t\t\t\t\t\t\t struct stm32_gpio_bank *bank,\n\t\t\t\t\t\t\t\t unsigned int offset)\n{\n\tunsigned int stm32_pin_nb = bank->bank_nr * STM32_GPIO_PINS_PER_BANK + offset;\n\tstruct stm32_desc_pin *pin_desc;\n\tint i;\n\n\t \n\tif (stm32_pin_nb < pctl->npins) {\n\t\tpin_desc = pctl->pins + stm32_pin_nb;\n\t\tif (pin_desc->pin.number == stm32_pin_nb)\n\t\t\treturn pin_desc;\n\t}\n\n\t \n\tfor (i = 0; i < pctl->npins; i++) {\n\t\tpin_desc = pctl->pins + i;\n\t\tif (pin_desc->pin.number == stm32_pin_nb)\n\t\t\treturn pin_desc;\n\t}\n\treturn NULL;\n}\n\nstatic int stm32_gpiolib_register_bank(struct stm32_pinctrl *pctl, struct fwnode_handle *fwnode)\n{\n\tstruct stm32_gpio_bank *bank = &pctl->banks[pctl->nbanks];\n\tint bank_ioport_nr;\n\tstruct pinctrl_gpio_range *range = &bank->range;\n\tstruct fwnode_reference_args args;\n\tstruct device *dev = pctl->dev;\n\tstruct resource res;\n\tint npins = STM32_GPIO_PINS_PER_BANK;\n\tint bank_nr, err, i = 0;\n\tstruct stm32_desc_pin *stm32_pin;\n\tchar **names;\n\n\tif (!IS_ERR(bank->rstc))\n\t\treset_control_deassert(bank->rstc);\n\n\tif (of_address_to_resource(to_of_node(fwnode), 0, &res))\n\t\treturn -ENODEV;\n\n\tbank->base = devm_ioremap_resource(dev, &res);\n\tif (IS_ERR(bank->base))\n\t\treturn PTR_ERR(bank->base);\n\n\terr = clk_prepare_enable(bank->clk);\n\tif (err) {\n\t\tdev_err(dev, \"failed to prepare_enable clk (%d)\\n\", err);\n\t\treturn err;\n\t}\n\n\tbank->gpio_chip = stm32_gpio_template;\n\n\tfwnode_property_read_string(fwnode, \"st,bank-name\", &bank->gpio_chip.label);\n\n\tif (!fwnode_property_get_reference_args(fwnode, \"gpio-ranges\", NULL, 3, i, &args)) {\n\t\tbank_nr = args.args[1] / STM32_GPIO_PINS_PER_BANK;\n\t\tbank->gpio_chip.base = args.args[1];\n\n\t\t \n\t\tnpins = args.args[0] + args.args[2];\n\t\twhile (!fwnode_property_get_reference_args(fwnode, \"gpio-ranges\", NULL, 3, ++i, &args))\n\t\t\tnpins = max(npins, (int)(args.args[0] + args.args[2]));\n\t} else {\n\t\tbank_nr = pctl->nbanks;\n\t\tbank->gpio_chip.base = bank_nr * STM32_GPIO_PINS_PER_BANK;\n\t\trange->name = bank->gpio_chip.label;\n\t\trange->id = bank_nr;\n\t\trange->pin_base = range->id * STM32_GPIO_PINS_PER_BANK;\n\t\trange->base = range->id * STM32_GPIO_PINS_PER_BANK;\n\t\trange->npins = npins;\n\t\trange->gc = &bank->gpio_chip;\n\t\tpinctrl_add_gpio_range(pctl->pctl_dev,\n\t\t\t\t       &pctl->banks[bank_nr].range);\n\t}\n\n\tif (fwnode_property_read_u32(fwnode, \"st,bank-ioport\", &bank_ioport_nr))\n\t\tbank_ioport_nr = bank_nr;\n\n\tbank->gpio_chip.base = -1;\n\n\tbank->gpio_chip.ngpio = npins;\n\tbank->gpio_chip.fwnode = fwnode;\n\tbank->gpio_chip.parent = dev;\n\tbank->bank_nr = bank_nr;\n\tbank->bank_ioport_nr = bank_ioport_nr;\n\tbank->secure_control = pctl->match_data->secure_control;\n\tspin_lock_init(&bank->lock);\n\n\tif (pctl->domain) {\n\t\t \n\t\tbank->fwnode = fwnode;\n\n\t\tbank->domain = irq_domain_create_hierarchy(pctl->domain, 0, STM32_GPIO_IRQ_LINE,\n\t\t\t\t\t\t\t   bank->fwnode, &stm32_gpio_domain_ops,\n\t\t\t\t\t\t\t   bank);\n\n\t\tif (!bank->domain) {\n\t\t\terr = -ENODEV;\n\t\t\tgoto err_clk;\n\t\t}\n\t}\n\n\tnames = devm_kcalloc(dev, npins, sizeof(char *), GFP_KERNEL);\n\tif (!names) {\n\t\terr = -ENOMEM;\n\t\tgoto err_clk;\n\t}\n\n\tfor (i = 0; i < npins; i++) {\n\t\tstm32_pin = stm32_pctrl_get_desc_pin_from_gpio(pctl, bank, i);\n\t\tif (stm32_pin && stm32_pin->pin.name)\n\t\t\tnames[i] = devm_kasprintf(dev, GFP_KERNEL, \"%s\", stm32_pin->pin.name);\n\t\telse\n\t\t\tnames[i] = NULL;\n\t}\n\n\tbank->gpio_chip.names = (const char * const *)names;\n\n\terr = gpiochip_add_data(&bank->gpio_chip, bank);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to add gpiochip(%d)!\\n\", bank_nr);\n\t\tgoto err_clk;\n\t}\n\n\tdev_info(dev, \"%s bank added\\n\", bank->gpio_chip.label);\n\treturn 0;\n\nerr_clk:\n\tclk_disable_unprepare(bank->clk);\n\treturn err;\n}\n\nstatic struct irq_domain *stm32_pctrl_get_irq_domain(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct device_node *parent;\n\tstruct irq_domain *domain;\n\n\tif (!of_property_present(np, \"interrupt-parent\"))\n\t\treturn NULL;\n\n\tparent = of_irq_find_parent(np);\n\tif (!parent)\n\t\treturn ERR_PTR(-ENXIO);\n\n\tdomain = irq_find_host(parent);\n\tof_node_put(parent);\n\tif (!domain)\n\t\t \n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\n\treturn domain;\n}\n\nstatic int stm32_pctrl_dt_setup_irq(struct platform_device *pdev,\n\t\t\t   struct stm32_pinctrl *pctl)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct device *dev = &pdev->dev;\n\tstruct regmap *rm;\n\tint offset, ret, i;\n\tint mask, mask_width;\n\n\tpctl->regmap = syscon_regmap_lookup_by_phandle(np, \"st,syscfg\");\n\tif (IS_ERR(pctl->regmap))\n\t\treturn PTR_ERR(pctl->regmap);\n\n\trm = pctl->regmap;\n\n\tret = of_property_read_u32_index(np, \"st,syscfg\", 1, &offset);\n\tif (ret)\n\t\treturn ret;\n\n\tret = of_property_read_u32_index(np, \"st,syscfg\", 2, &mask);\n\tif (ret)\n\t\tmask = SYSCFG_IRQMUX_MASK;\n\n\tmask_width = fls(mask);\n\n\tfor (i = 0; i < STM32_GPIO_PINS_PER_BANK; i++) {\n\t\tstruct reg_field mux;\n\n\t\tmux.reg = offset + (i / 4) * 4;\n\t\tmux.lsb = (i % 4) * mask_width;\n\t\tmux.msb = mux.lsb + mask_width - 1;\n\n\t\tdev_dbg(dev, \"irqmux%d: reg:%#x, lsb:%d, msb:%d\\n\",\n\t\t\ti, mux.reg, mux.lsb, mux.msb);\n\n\t\tpctl->irqmux[i] = devm_regmap_field_alloc(dev, rm, mux);\n\t\tif (IS_ERR(pctl->irqmux[i]))\n\t\t\treturn PTR_ERR(pctl->irqmux[i]);\n\t}\n\n\treturn 0;\n}\n\nstatic int stm32_pctrl_build_state(struct platform_device *pdev)\n{\n\tstruct stm32_pinctrl *pctl = platform_get_drvdata(pdev);\n\tint i;\n\n\tpctl->ngroups = pctl->npins;\n\n\t \n\tpctl->groups = devm_kcalloc(&pdev->dev, pctl->ngroups,\n\t\t\t\t    sizeof(*pctl->groups), GFP_KERNEL);\n\tif (!pctl->groups)\n\t\treturn -ENOMEM;\n\n\t \n\tpctl->grp_names = devm_kcalloc(&pdev->dev, pctl->ngroups,\n\t\t\t\t       sizeof(*pctl->grp_names), GFP_KERNEL);\n\tif (!pctl->grp_names)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < pctl->npins; i++) {\n\t\tconst struct stm32_desc_pin *pin = pctl->pins + i;\n\t\tstruct stm32_pinctrl_group *group = pctl->groups + i;\n\n\t\tgroup->name = pin->pin.name;\n\t\tgroup->pin = pin->pin.number;\n\t\tpctl->grp_names[i] = pin->pin.name;\n\t}\n\n\treturn 0;\n}\n\nstatic int stm32_pctrl_create_pins_tab(struct stm32_pinctrl *pctl,\n\t\t\t\t       struct stm32_desc_pin *pins)\n{\n\tconst struct stm32_desc_pin *p;\n\tint i, nb_pins_available = 0;\n\n\tfor (i = 0; i < pctl->match_data->npins; i++) {\n\t\tp = pctl->match_data->pins + i;\n\t\tif (pctl->pkg && !(pctl->pkg & p->pkg))\n\t\t\tcontinue;\n\t\tpins->pin = p->pin;\n\t\tmemcpy((struct stm32_desc_pin *)pins->functions, p->functions,\n\t\t       STM32_CONFIG_NUM * sizeof(struct stm32_desc_function));\n\t\tpins++;\n\t\tnb_pins_available++;\n\t}\n\n\tpctl->npins = nb_pins_available;\n\n\treturn 0;\n}\n\nint stm32_pctl_probe(struct platform_device *pdev)\n{\n\tconst struct stm32_pinctrl_match_data *match_data;\n\tstruct fwnode_handle *child;\n\tstruct device *dev = &pdev->dev;\n\tstruct stm32_pinctrl *pctl;\n\tstruct pinctrl_pin_desc *pins;\n\tint i, ret, hwlock_id;\n\tunsigned int banks;\n\n\tmatch_data = device_get_match_data(dev);\n\tif (!match_data)\n\t\treturn -EINVAL;\n\n\tpctl = devm_kzalloc(dev, sizeof(*pctl), GFP_KERNEL);\n\tif (!pctl)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, pctl);\n\n\t \n\tpctl->domain = stm32_pctrl_get_irq_domain(pdev);\n\tif (IS_ERR(pctl->domain))\n\t\treturn PTR_ERR(pctl->domain);\n\tif (!pctl->domain)\n\t\tdev_warn(dev, \"pinctrl without interrupt support\\n\");\n\n\t \n\thwlock_id = of_hwspin_lock_get_id(pdev->dev.of_node, 0);\n\tif (hwlock_id < 0) {\n\t\tif (hwlock_id == -EPROBE_DEFER)\n\t\t\treturn hwlock_id;\n\t} else {\n\t\tpctl->hwlock = hwspin_lock_request_specific(hwlock_id);\n\t}\n\n\tspin_lock_init(&pctl->irqmux_lock);\n\n\tpctl->dev = dev;\n\tpctl->match_data = match_data;\n\n\t \n\tif (!device_property_read_u32(dev, \"st,package\", &pctl->pkg))\n\t\tdev_dbg(pctl->dev, \"package detected: %x\\n\", pctl->pkg);\n\n\tpctl->pins = devm_kcalloc(pctl->dev, pctl->match_data->npins,\n\t\t\t\t  sizeof(*pctl->pins), GFP_KERNEL);\n\tif (!pctl->pins)\n\t\treturn -ENOMEM;\n\n\tret = stm32_pctrl_create_pins_tab(pctl, pctl->pins);\n\tif (ret)\n\t\treturn ret;\n\n\tret = stm32_pctrl_build_state(pdev);\n\tif (ret) {\n\t\tdev_err(dev, \"build state failed: %d\\n\", ret);\n\t\treturn -EINVAL;\n\t}\n\n\tif (pctl->domain) {\n\t\tret = stm32_pctrl_dt_setup_irq(pdev, pctl);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tpins = devm_kcalloc(&pdev->dev, pctl->npins, sizeof(*pins),\n\t\t\t    GFP_KERNEL);\n\tif (!pins)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < pctl->npins; i++)\n\t\tpins[i] = pctl->pins[i].pin;\n\n\tpctl->pctl_desc.name = dev_name(&pdev->dev);\n\tpctl->pctl_desc.owner = THIS_MODULE;\n\tpctl->pctl_desc.pins = pins;\n\tpctl->pctl_desc.npins = pctl->npins;\n\tpctl->pctl_desc.link_consumers = true;\n\tpctl->pctl_desc.confops = &stm32_pconf_ops;\n\tpctl->pctl_desc.pctlops = &stm32_pctrl_ops;\n\tpctl->pctl_desc.pmxops = &stm32_pmx_ops;\n\tpctl->dev = &pdev->dev;\n\n\tpctl->pctl_dev = devm_pinctrl_register(&pdev->dev, &pctl->pctl_desc,\n\t\t\t\t\t       pctl);\n\n\tif (IS_ERR(pctl->pctl_dev)) {\n\t\tdev_err(&pdev->dev, \"Failed pinctrl registration\\n\");\n\t\treturn PTR_ERR(pctl->pctl_dev);\n\t}\n\n\tbanks = gpiochip_node_count(dev);\n\tif (!banks) {\n\t\tdev_err(dev, \"at least one GPIO bank is required\\n\");\n\t\treturn -EINVAL;\n\t}\n\tpctl->banks = devm_kcalloc(dev, banks, sizeof(*pctl->banks),\n\t\t\tGFP_KERNEL);\n\tif (!pctl->banks)\n\t\treturn -ENOMEM;\n\n\ti = 0;\n\tfor_each_gpiochip_node(dev, child) {\n\t\tstruct stm32_gpio_bank *bank = &pctl->banks[i];\n\t\tstruct device_node *np = to_of_node(child);\n\n\t\tbank->rstc = of_reset_control_get_exclusive(np, NULL);\n\t\tif (PTR_ERR(bank->rstc) == -EPROBE_DEFER) {\n\t\t\tfwnode_handle_put(child);\n\t\t\treturn -EPROBE_DEFER;\n\t\t}\n\n\t\tbank->clk = of_clk_get_by_name(np, NULL);\n\t\tif (IS_ERR(bank->clk)) {\n\t\t\tfwnode_handle_put(child);\n\t\t\treturn dev_err_probe(dev, PTR_ERR(bank->clk),\n\t\t\t\t\t     \"failed to get clk\\n\");\n\t\t}\n\t\ti++;\n\t}\n\n\tfor_each_gpiochip_node(dev, child) {\n\t\tret = stm32_gpiolib_register_bank(pctl, child);\n\t\tif (ret) {\n\t\t\tfwnode_handle_put(child);\n\n\t\t\tfor (i = 0; i < pctl->nbanks; i++)\n\t\t\t\tclk_disable_unprepare(pctl->banks[i].clk);\n\n\t\t\treturn ret;\n\t\t}\n\n\t\tpctl->nbanks++;\n\t}\n\n\tdev_info(dev, \"Pinctrl STM32 initialized\\n\");\n\n\treturn 0;\n}\n\nstatic int __maybe_unused stm32_pinctrl_restore_gpio_regs(\n\t\t\t\t\tstruct stm32_pinctrl *pctl, u32 pin)\n{\n\tconst struct pin_desc *desc = pin_desc_get(pctl->pctl_dev, pin);\n\tu32 val, alt, mode, offset = stm32_gpio_pin(pin);\n\tstruct pinctrl_gpio_range *range;\n\tstruct stm32_gpio_bank *bank;\n\tbool pin_is_irq;\n\tint ret;\n\n\trange = pinctrl_find_gpio_range_from_pin(pctl->pctl_dev, pin);\n\tif (!range)\n\t\treturn 0;\n\n\tif (!gpiochip_line_is_valid(range->gc, offset))\n\t\treturn 0;\n\n\tpin_is_irq = gpiochip_line_is_irq(range->gc, offset);\n\n\tif (!desc || (!pin_is_irq && !desc->gpio_owner))\n\t\treturn 0;\n\n\tbank = gpiochip_get_data(range->gc);\n\n\talt = bank->pin_backup[offset] & STM32_GPIO_BKP_ALT_MASK;\n\talt >>= STM32_GPIO_BKP_ALT_SHIFT;\n\tmode = bank->pin_backup[offset] & STM32_GPIO_BKP_MODE_MASK;\n\tmode >>= STM32_GPIO_BKP_MODE_SHIFT;\n\n\tret = stm32_pmx_set_mode(bank, offset, mode, alt);\n\tif (ret)\n\t\treturn ret;\n\n\tif (mode == 1) {\n\t\tval = bank->pin_backup[offset] & BIT(STM32_GPIO_BKP_VAL);\n\t\tval = val >> STM32_GPIO_BKP_VAL;\n\t\t__stm32_gpio_set(bank, offset, val);\n\t}\n\n\tval = bank->pin_backup[offset] & BIT(STM32_GPIO_BKP_TYPE);\n\tval >>= STM32_GPIO_BKP_TYPE;\n\tret = stm32_pconf_set_driving(bank, offset, val);\n\tif (ret)\n\t\treturn ret;\n\n\tval = bank->pin_backup[offset] & STM32_GPIO_BKP_SPEED_MASK;\n\tval >>= STM32_GPIO_BKP_SPEED_SHIFT;\n\tret = stm32_pconf_set_speed(bank, offset, val);\n\tif (ret)\n\t\treturn ret;\n\n\tval = bank->pin_backup[offset] & STM32_GPIO_BKP_PUPD_MASK;\n\tval >>= STM32_GPIO_BKP_PUPD_SHIFT;\n\tret = stm32_pconf_set_bias(bank, offset, val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (pin_is_irq)\n\t\tregmap_field_write(pctl->irqmux[offset], bank->bank_ioport_nr);\n\n\treturn 0;\n}\n\nint __maybe_unused stm32_pinctrl_suspend(struct device *dev)\n{\n\tstruct stm32_pinctrl *pctl = dev_get_drvdata(dev);\n\tint i;\n\n\tfor (i = 0; i < pctl->nbanks; i++)\n\t\tclk_disable(pctl->banks[i].clk);\n\n\treturn 0;\n}\n\nint __maybe_unused stm32_pinctrl_resume(struct device *dev)\n{\n\tstruct stm32_pinctrl *pctl = dev_get_drvdata(dev);\n\tstruct stm32_pinctrl_group *g = pctl->groups;\n\tint i;\n\n\tfor (i = 0; i < pctl->nbanks; i++)\n\t\tclk_enable(pctl->banks[i].clk);\n\n\tfor (i = 0; i < pctl->ngroups; i++, g++)\n\t\tstm32_pinctrl_restore_gpio_regs(pctl, g->pin);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}