{
  "module_name": "pinctrl-utils.c",
  "hash_id": "6bbac3eb71b58377d55d5d51760fbf32a0beeb82cd9a6b5d64776ef2d10352cd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/pinctrl-utils.c",
  "human_readable_source": "\n \n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include \"core.h\"\n#include \"pinctrl-utils.h\"\n\nint pinctrl_utils_reserve_map(struct pinctrl_dev *pctldev,\n\t\tstruct pinctrl_map **map, unsigned *reserved_maps,\n\t\tunsigned *num_maps, unsigned reserve)\n{\n\tunsigned old_num = *reserved_maps;\n\tunsigned new_num = *num_maps + reserve;\n\tstruct pinctrl_map *new_map;\n\n\tif (old_num >= new_num)\n\t\treturn 0;\n\n\tnew_map = krealloc_array(*map, new_num, sizeof(*new_map), GFP_KERNEL);\n\tif (!new_map) {\n\t\tdev_err(pctldev->dev, \"krealloc(map) failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(new_map + old_num, 0, (new_num - old_num) * sizeof(*new_map));\n\n\t*map = new_map;\n\t*reserved_maps = new_num;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(pinctrl_utils_reserve_map);\n\nint pinctrl_utils_add_map_mux(struct pinctrl_dev *pctldev,\n\t\tstruct pinctrl_map **map, unsigned *reserved_maps,\n\t\tunsigned *num_maps, const char *group,\n\t\tconst char *function)\n{\n\tif (WARN_ON(*num_maps == *reserved_maps))\n\t\treturn -ENOSPC;\n\n\t(*map)[*num_maps].type = PIN_MAP_TYPE_MUX_GROUP;\n\t(*map)[*num_maps].data.mux.group = group;\n\t(*map)[*num_maps].data.mux.function = function;\n\t(*num_maps)++;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(pinctrl_utils_add_map_mux);\n\nint pinctrl_utils_add_map_configs(struct pinctrl_dev *pctldev,\n\t\tstruct pinctrl_map **map, unsigned *reserved_maps,\n\t\tunsigned *num_maps, const char *group,\n\t\tunsigned long *configs, unsigned num_configs,\n\t\tenum pinctrl_map_type type)\n{\n\tunsigned long *dup_configs;\n\n\tif (WARN_ON(*num_maps == *reserved_maps))\n\t\treturn -ENOSPC;\n\n\tdup_configs = kmemdup(configs, num_configs * sizeof(*dup_configs),\n\t\t\t      GFP_KERNEL);\n\tif (!dup_configs)\n\t\treturn -ENOMEM;\n\n\t(*map)[*num_maps].type = type;\n\t(*map)[*num_maps].data.configs.group_or_pin = group;\n\t(*map)[*num_maps].data.configs.configs = dup_configs;\n\t(*map)[*num_maps].data.configs.num_configs = num_configs;\n\t(*num_maps)++;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(pinctrl_utils_add_map_configs);\n\nint pinctrl_utils_add_config(struct pinctrl_dev *pctldev,\n\t\tunsigned long **configs, unsigned *num_configs,\n\t\tunsigned long config)\n{\n\tunsigned old_num = *num_configs;\n\tunsigned new_num = old_num + 1;\n\tunsigned long *new_configs;\n\n\tnew_configs = krealloc(*configs, sizeof(*new_configs) * new_num,\n\t\t\t       GFP_KERNEL);\n\tif (!new_configs) {\n\t\tdev_err(pctldev->dev, \"krealloc(configs) failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tnew_configs[old_num] = config;\n\n\t*configs = new_configs;\n\t*num_configs = new_num;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(pinctrl_utils_add_config);\n\nvoid pinctrl_utils_free_map(struct pinctrl_dev *pctldev,\n\t      struct pinctrl_map *map, unsigned num_maps)\n{\n\tint i;\n\n\tfor (i = 0; i < num_maps; i++) {\n\t\tswitch (map[i].type) {\n\t\tcase PIN_MAP_TYPE_CONFIGS_GROUP:\n\t\tcase PIN_MAP_TYPE_CONFIGS_PIN:\n\t\t\tkfree(map[i].data.configs.configs);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tkfree(map);\n}\nEXPORT_SYMBOL_GPL(pinctrl_utils_free_map);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}