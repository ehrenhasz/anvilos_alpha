{
  "module_name": "pinctrl-imx.c",
  "hash_id": "e11ba5b710064a1eb7873c1925565a3c9aaf20e4db0c9e1da747537672ee63c1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/freescale/pinctrl-imx.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n\n#include <linux/pinctrl/machine.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinmux.h>\n\n#include \"../core.h\"\n#include \"../pinconf.h\"\n#include \"../pinmux.h\"\n#include \"pinctrl-imx.h\"\n\n \n#define IMX_NO_PAD_CTL\t0x80000000\t \n#define IMX_PAD_SION 0x40000000\t\t \n\nstatic inline const struct group_desc *imx_pinctrl_find_group_by_name(\n\t\t\t\tstruct pinctrl_dev *pctldev,\n\t\t\t\tconst char *name)\n{\n\tconst struct group_desc *grp = NULL;\n\tint i;\n\n\tfor (i = 0; i < pctldev->num_groups; i++) {\n\t\tgrp = pinctrl_generic_get_group(pctldev, i);\n\t\tif (grp && !strcmp(grp->name, name))\n\t\t\tbreak;\n\t}\n\n\treturn grp;\n}\n\nstatic void imx_pin_dbg_show(struct pinctrl_dev *pctldev, struct seq_file *s,\n\t\t   unsigned offset)\n{\n\tseq_printf(s, \"%s\", dev_name(pctldev->dev));\n}\n\nstatic int imx_dt_node_to_map(struct pinctrl_dev *pctldev,\n\t\t\tstruct device_node *np,\n\t\t\tstruct pinctrl_map **map, unsigned *num_maps)\n{\n\tstruct imx_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct imx_pinctrl_soc_info *info = ipctl->info;\n\tconst struct group_desc *grp;\n\tstruct pinctrl_map *new_map;\n\tstruct device_node *parent;\n\tstruct imx_pin *pin;\n\tint map_num = 1;\n\tint i, j;\n\n\t \n\tgrp = imx_pinctrl_find_group_by_name(pctldev, np->name);\n\tif (!grp) {\n\t\tdev_err(ipctl->dev, \"unable to find group for node %pOFn\\n\", np);\n\t\treturn -EINVAL;\n\t}\n\n\tif (info->flags & IMX_USE_SCU) {\n\t\tmap_num += grp->num_pins;\n\t} else {\n\t\tfor (i = 0; i < grp->num_pins; i++) {\n\t\t\tpin = &((struct imx_pin *)(grp->data))[i];\n\t\t\tif (!(pin->conf.mmio.config & IMX_NO_PAD_CTL))\n\t\t\t\tmap_num++;\n\t\t}\n\t}\n\n\tnew_map = kmalloc_array(map_num, sizeof(struct pinctrl_map),\n\t\t\t\tGFP_KERNEL);\n\tif (!new_map)\n\t\treturn -ENOMEM;\n\n\t*map = new_map;\n\t*num_maps = map_num;\n\n\t \n\tparent = of_get_parent(np);\n\tif (!parent) {\n\t\tkfree(new_map);\n\t\treturn -EINVAL;\n\t}\n\tnew_map[0].type = PIN_MAP_TYPE_MUX_GROUP;\n\tnew_map[0].data.mux.function = parent->name;\n\tnew_map[0].data.mux.group = np->name;\n\tof_node_put(parent);\n\n\t \n\tnew_map++;\n\tfor (i = j = 0; i < grp->num_pins; i++) {\n\t\tpin = &((struct imx_pin *)(grp->data))[i];\n\n\t\t \n\t\tif (!(info->flags & IMX_USE_SCU) &&\n\t\t    (pin->conf.mmio.config & IMX_NO_PAD_CTL))\n\t\t\tcontinue;\n\n\t\tnew_map[j].type = PIN_MAP_TYPE_CONFIGS_PIN;\n\t\tnew_map[j].data.configs.group_or_pin =\n\t\t\t\t\tpin_get_name(pctldev, pin->pin);\n\n\t\tif (info->flags & IMX_USE_SCU) {\n\t\t\t \n\t\t\tnew_map[j].data.configs.configs =\n\t\t\t\t\t(unsigned long *)&pin->conf.scu;\n\t\t\tnew_map[j].data.configs.num_configs = 2;\n\t\t} else {\n\t\t\tnew_map[j].data.configs.configs =\n\t\t\t\t\t&pin->conf.mmio.config;\n\t\t\tnew_map[j].data.configs.num_configs = 1;\n\t\t}\n\n\t\tj++;\n\t}\n\n\tdev_dbg(pctldev->dev, \"maps: function %s group %s num %d\\n\",\n\t\t(*map)->data.mux.function, (*map)->data.mux.group, map_num);\n\n\treturn 0;\n}\n\nstatic void imx_dt_free_map(struct pinctrl_dev *pctldev,\n\t\t\t\tstruct pinctrl_map *map, unsigned num_maps)\n{\n\tkfree(map);\n}\n\nstatic const struct pinctrl_ops imx_pctrl_ops = {\n\t.get_groups_count = pinctrl_generic_get_group_count,\n\t.get_group_name = pinctrl_generic_get_group_name,\n\t.get_group_pins = pinctrl_generic_get_group_pins,\n\t.pin_dbg_show = imx_pin_dbg_show,\n\t.dt_node_to_map = imx_dt_node_to_map,\n\t.dt_free_map = imx_dt_free_map,\n};\n\nstatic int imx_pmx_set_one_pin_mmio(struct imx_pinctrl *ipctl,\n\t\t\t\t    struct imx_pin *pin)\n{\n\tconst struct imx_pinctrl_soc_info *info = ipctl->info;\n\tstruct imx_pin_mmio *pin_mmio = &pin->conf.mmio;\n\tconst struct imx_pin_reg *pin_reg;\n\tunsigned int pin_id;\n\n\tpin_id = pin->pin;\n\tpin_reg = &ipctl->pin_regs[pin_id];\n\n\tif (pin_reg->mux_reg == -1) {\n\t\tdev_dbg(ipctl->dev, \"Pin(%s) does not support mux function\\n\",\n\t\t\tinfo->pins[pin_id].name);\n\t\treturn 0;\n\t}\n\n\tif (info->flags & SHARE_MUX_CONF_REG) {\n\t\tu32 reg;\n\n\t\treg = readl(ipctl->base + pin_reg->mux_reg);\n\t\treg &= ~info->mux_mask;\n\t\treg |= (pin_mmio->mux_mode << info->mux_shift);\n\t\twritel(reg, ipctl->base + pin_reg->mux_reg);\n\t\tdev_dbg(ipctl->dev, \"write: offset 0x%x val 0x%x\\n\",\n\t\t\tpin_reg->mux_reg, reg);\n\t} else {\n\t\twritel(pin_mmio->mux_mode, ipctl->base + pin_reg->mux_reg);\n\t\tdev_dbg(ipctl->dev, \"write: offset 0x%x val 0x%x\\n\",\n\t\t\tpin_reg->mux_reg, pin_mmio->mux_mode);\n\t}\n\n\t \n\tif (pin_mmio->input_val >> 24 == 0xff) {\n\t\tu32 val = pin_mmio->input_val;\n\t\tu8 select = val & 0xff;\n\t\tu8 width = (val >> 8) & 0xff;\n\t\tu8 shift = (val >> 16) & 0xff;\n\t\tu32 mask = ((1 << width) - 1) << shift;\n\t\t \n\t\tval = readl(ipctl->base + pin_mmio->input_reg);\n\t\tval &= ~mask;\n\t\tval |= select << shift;\n\t\twritel(val, ipctl->base + pin_mmio->input_reg);\n\t} else if (pin_mmio->input_reg) {\n\t\t \n\t\tif (ipctl->input_sel_base)\n\t\t\twritel(pin_mmio->input_val, ipctl->input_sel_base +\n\t\t\t\t\tpin_mmio->input_reg);\n\t\telse\n\t\t\twritel(pin_mmio->input_val, ipctl->base +\n\t\t\t\t\tpin_mmio->input_reg);\n\t\tdev_dbg(ipctl->dev,\n\t\t\t\"==>select_input: offset 0x%x val 0x%x\\n\",\n\t\t\tpin_mmio->input_reg, pin_mmio->input_val);\n\t}\n\n\treturn 0;\n}\n\nstatic int imx_pmx_set(struct pinctrl_dev *pctldev, unsigned selector,\n\t\t       unsigned group)\n{\n\tstruct imx_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct imx_pinctrl_soc_info *info = ipctl->info;\n\tstruct function_desc *func;\n\tstruct group_desc *grp;\n\tstruct imx_pin *pin;\n\tunsigned int npins;\n\tint i, err;\n\n\t \n\tgrp = pinctrl_generic_get_group(pctldev, group);\n\tif (!grp)\n\t\treturn -EINVAL;\n\n\tfunc = pinmux_generic_get_function(pctldev, selector);\n\tif (!func)\n\t\treturn -EINVAL;\n\n\tnpins = grp->num_pins;\n\n\tdev_dbg(ipctl->dev, \"enable function %s group %s\\n\",\n\t\tfunc->name, grp->name);\n\n\tfor (i = 0; i < npins; i++) {\n\t\t \n\t\tpin = &((struct imx_pin *)(grp->data))[i];\n\t\tif (!(info->flags & IMX_USE_SCU)) {\n\t\t\terr = imx_pmx_set_one_pin_mmio(ipctl, pin);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstruct pinmux_ops imx_pmx_ops = {\n\t.get_functions_count = pinmux_generic_get_function_count,\n\t.get_function_name = pinmux_generic_get_function_name,\n\t.get_function_groups = pinmux_generic_get_function_groups,\n\t.set_mux = imx_pmx_set,\n};\n\nstatic int imx_pinconf_get_mmio(struct pinctrl_dev *pctldev, unsigned pin_id,\n\t\t\t\tunsigned long *config)\n{\n\tstruct imx_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct imx_pinctrl_soc_info *info = ipctl->info;\n\tconst struct imx_pin_reg *pin_reg = &ipctl->pin_regs[pin_id];\n\n\tif (pin_reg->conf_reg == -1) {\n\t\tdev_err(ipctl->dev, \"Pin(%s) does not support config function\\n\",\n\t\t\tinfo->pins[pin_id].name);\n\t\treturn -EINVAL;\n\t}\n\n\t*config = readl(ipctl->base + pin_reg->conf_reg);\n\n\tif (info->flags & SHARE_MUX_CONF_REG)\n\t\t*config &= ~info->mux_mask;\n\n\treturn 0;\n}\n\nstatic int imx_pinconf_get(struct pinctrl_dev *pctldev,\n\t\t\t   unsigned pin_id, unsigned long *config)\n{\n\tstruct imx_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct imx_pinctrl_soc_info *info = ipctl->info;\n\n\tif (info->flags & IMX_USE_SCU)\n\t\treturn info->imx_pinconf_get(pctldev, pin_id, config);\n\telse\n\t\treturn imx_pinconf_get_mmio(pctldev, pin_id, config);\n}\n\nstatic int imx_pinconf_set_mmio(struct pinctrl_dev *pctldev,\n\t\t\t\tunsigned pin_id, unsigned long *configs,\n\t\t\t\tunsigned num_configs)\n{\n\tstruct imx_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct imx_pinctrl_soc_info *info = ipctl->info;\n\tconst struct imx_pin_reg *pin_reg = &ipctl->pin_regs[pin_id];\n\tint i;\n\n\tif (pin_reg->conf_reg == -1) {\n\t\tdev_err(ipctl->dev, \"Pin(%s) does not support config function\\n\",\n\t\t\tinfo->pins[pin_id].name);\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(ipctl->dev, \"pinconf set pin %s\\n\",\n\t\tinfo->pins[pin_id].name);\n\n\tfor (i = 0; i < num_configs; i++) {\n\t\tif (info->flags & SHARE_MUX_CONF_REG) {\n\t\t\tu32 reg;\n\t\t\treg = readl(ipctl->base + pin_reg->conf_reg);\n\t\t\treg &= info->mux_mask;\n\t\t\treg |= configs[i];\n\t\t\twritel(reg, ipctl->base + pin_reg->conf_reg);\n\t\t\tdev_dbg(ipctl->dev, \"write: offset 0x%x val 0x%x\\n\",\n\t\t\t\tpin_reg->conf_reg, reg);\n\t\t} else {\n\t\t\twritel(configs[i], ipctl->base + pin_reg->conf_reg);\n\t\t\tdev_dbg(ipctl->dev, \"write: offset 0x%x val 0x%lx\\n\",\n\t\t\t\tpin_reg->conf_reg, configs[i]);\n\t\t}\n\t}  \n\n\treturn 0;\n}\n\nstatic int imx_pinconf_set(struct pinctrl_dev *pctldev,\n\t\t\t   unsigned pin_id, unsigned long *configs,\n\t\t\t   unsigned num_configs)\n{\n\tstruct imx_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct imx_pinctrl_soc_info *info = ipctl->info;\n\n\tif (info->flags & IMX_USE_SCU)\n\t\treturn info->imx_pinconf_set(pctldev, pin_id,\n\t\t\t\t\t   configs, num_configs);\n\telse\n\t\treturn imx_pinconf_set_mmio(pctldev, pin_id,\n\t\t\t\t\t    configs, num_configs);\n}\n\nstatic void imx_pinconf_dbg_show(struct pinctrl_dev *pctldev,\n\t\t\t\t   struct seq_file *s, unsigned pin_id)\n{\n\tstruct imx_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct imx_pinctrl_soc_info *info = ipctl->info;\n\tconst struct imx_pin_reg *pin_reg;\n\tunsigned long config;\n\tint ret;\n\n\tif (info->flags & IMX_USE_SCU) {\n\t\tret = info->imx_pinconf_get(pctldev, pin_id, &config);\n\t\tif (ret) {\n\t\t\tdev_err(ipctl->dev, \"failed to get %s pinconf\\n\",\n\t\t\t\tpin_get_name(pctldev, pin_id));\n\t\t\tseq_puts(s, \"N/A\");\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tpin_reg = &ipctl->pin_regs[pin_id];\n\t\tif (pin_reg->conf_reg == -1) {\n\t\t\tseq_puts(s, \"N/A\");\n\t\t\treturn;\n\t\t}\n\n\t\tconfig = readl(ipctl->base + pin_reg->conf_reg);\n\t}\n\n\tseq_printf(s, \"0x%lx\", config);\n}\n\nstatic void imx_pinconf_group_dbg_show(struct pinctrl_dev *pctldev,\n\t\t\t\t\t struct seq_file *s, unsigned group)\n{\n\tstruct group_desc *grp;\n\tunsigned long config;\n\tconst char *name;\n\tint i, ret;\n\n\tif (group >= pctldev->num_groups)\n\t\treturn;\n\n\tseq_puts(s, \"\\n\");\n\tgrp = pinctrl_generic_get_group(pctldev, group);\n\tif (!grp)\n\t\treturn;\n\n\tfor (i = 0; i < grp->num_pins; i++) {\n\t\tstruct imx_pin *pin = &((struct imx_pin *)(grp->data))[i];\n\n\t\tname = pin_get_name(pctldev, pin->pin);\n\t\tret = imx_pinconf_get(pctldev, pin->pin, &config);\n\t\tif (ret)\n\t\t\treturn;\n\t\tseq_printf(s, \"  %s: 0x%lx\\n\", name, config);\n\t}\n}\n\nstatic const struct pinconf_ops imx_pinconf_ops = {\n\t.pin_config_get = imx_pinconf_get,\n\t.pin_config_set = imx_pinconf_set,\n\t.pin_config_dbg_show = imx_pinconf_dbg_show,\n\t.pin_config_group_dbg_show = imx_pinconf_group_dbg_show,\n};\n\n \n#define FSL_PIN_SIZE 24\n#define FSL_PIN_SHARE_SIZE 20\n#define FSL_SCU_PIN_SIZE 12\n\nstatic void imx_pinctrl_parse_pin_mmio(struct imx_pinctrl *ipctl,\n\t\t\t\t       unsigned int *pin_id, struct imx_pin *pin,\n\t\t\t\t       const __be32 **list_p,\n\t\t\t\t       struct device_node *np)\n{\n\tconst struct imx_pinctrl_soc_info *info = ipctl->info;\n\tstruct imx_pin_mmio *pin_mmio = &pin->conf.mmio;\n\tstruct imx_pin_reg *pin_reg;\n\tconst __be32 *list = *list_p;\n\tu32 mux_reg, conf_reg;\n\tu32 config;\n\n\tmux_reg = be32_to_cpu(*list++);\n\n\tif (!(info->flags & ZERO_OFFSET_VALID) && !mux_reg)\n\t\tmux_reg = -1;\n\n\tif (info->flags & SHARE_MUX_CONF_REG) {\n\t\tconf_reg = mux_reg;\n\t} else {\n\t\tconf_reg = be32_to_cpu(*list++);\n\t\tif (!conf_reg)\n\t\t\tconf_reg = -1;\n\t}\n\n\t*pin_id = (mux_reg != -1) ? mux_reg / 4 : conf_reg / 4;\n\tpin_reg = &ipctl->pin_regs[*pin_id];\n\tpin->pin = *pin_id;\n\tpin_reg->mux_reg = mux_reg;\n\tpin_reg->conf_reg = conf_reg;\n\tpin_mmio->input_reg = be32_to_cpu(*list++);\n\tpin_mmio->mux_mode = be32_to_cpu(*list++);\n\tpin_mmio->input_val = be32_to_cpu(*list++);\n\n\tconfig = be32_to_cpu(*list++);\n\n\t \n\tif (config & IMX_PAD_SION)\n\t\tpin_mmio->mux_mode |= IOMUXC_CONFIG_SION;\n\tpin_mmio->config = config & ~IMX_PAD_SION;\n\n\t*list_p = list;\n\n\tdev_dbg(ipctl->dev, \"%s: 0x%x 0x%08lx\", info->pins[*pin_id].name,\n\t\t\t     pin_mmio->mux_mode, pin_mmio->config);\n}\n\nstatic int imx_pinctrl_parse_groups(struct device_node *np,\n\t\t\t\t    struct group_desc *grp,\n\t\t\t\t    struct imx_pinctrl *ipctl,\n\t\t\t\t    u32 index)\n{\n\tconst struct imx_pinctrl_soc_info *info = ipctl->info;\n\tstruct imx_pin *pin;\n\tint size, pin_size;\n\tconst __be32 *list;\n\tint i;\n\n\tdev_dbg(ipctl->dev, \"group(%d): %pOFn\\n\", index, np);\n\n\tif (info->flags & IMX_USE_SCU)\n\t\tpin_size = FSL_SCU_PIN_SIZE;\n\telse if (info->flags & SHARE_MUX_CONF_REG)\n\t\tpin_size = FSL_PIN_SHARE_SIZE;\n\telse\n\t\tpin_size = FSL_PIN_SIZE;\n\n\t \n\tgrp->name = np->name;\n\n\t \n\tlist = of_get_property(np, \"fsl,pins\", &size);\n\tif (!list) {\n\t\tlist = of_get_property(np, \"pinmux\", &size);\n\t\tif (!list) {\n\t\t\tdev_err(ipctl->dev,\n\t\t\t\t\"no fsl,pins and pins property in node %pOF\\n\", np);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tif (!size || size % pin_size) {\n\t\tdev_err(ipctl->dev, \"Invalid fsl,pins or pins property in node %pOF\\n\", np);\n\t\treturn -EINVAL;\n\t}\n\n\tgrp->num_pins = size / pin_size;\n\tgrp->data = devm_kcalloc(ipctl->dev,\n\t\t\t\t grp->num_pins, sizeof(struct imx_pin),\n\t\t\t\t GFP_KERNEL);\n\tgrp->pins = devm_kcalloc(ipctl->dev,\n\t\t\t\t grp->num_pins, sizeof(unsigned int),\n\t\t\t\t GFP_KERNEL);\n\tif (!grp->pins || !grp->data)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < grp->num_pins; i++) {\n\t\tpin = &((struct imx_pin *)(grp->data))[i];\n\t\tif (info->flags & IMX_USE_SCU)\n\t\t\tinfo->imx_pinctrl_parse_pin(ipctl, &grp->pins[i],\n\t\t\t\t\t\t  pin, &list);\n\t\telse\n\t\t\timx_pinctrl_parse_pin_mmio(ipctl, &grp->pins[i],\n\t\t\t\t\t\t   pin, &list, np);\n\t}\n\n\treturn 0;\n}\n\nstatic int imx_pinctrl_parse_functions(struct device_node *np,\n\t\t\t\t       struct imx_pinctrl *ipctl,\n\t\t\t\t       u32 index)\n{\n\tstruct pinctrl_dev *pctl = ipctl->pctl;\n\tstruct device_node *child;\n\tstruct function_desc *func;\n\tstruct group_desc *grp;\n\tconst char **group_names;\n\tu32 i;\n\n\tdev_dbg(pctl->dev, \"parse function(%d): %pOFn\\n\", index, np);\n\n\tfunc = pinmux_generic_get_function(pctl, index);\n\tif (!func)\n\t\treturn -EINVAL;\n\n\t \n\tfunc->name = np->name;\n\tfunc->num_group_names = of_get_child_count(np);\n\tif (func->num_group_names == 0) {\n\t\tdev_info(ipctl->dev, \"no groups defined in %pOF\\n\", np);\n\t\treturn -EINVAL;\n\t}\n\n\tgroup_names = devm_kcalloc(ipctl->dev, func->num_group_names,\n\t\t\t\t   sizeof(char *), GFP_KERNEL);\n\tif (!group_names)\n\t\treturn -ENOMEM;\n\ti = 0;\n\tfor_each_child_of_node(np, child)\n\t\tgroup_names[i++] = child->name;\n\tfunc->group_names = group_names;\n\n\ti = 0;\n\tfor_each_child_of_node(np, child) {\n\t\tgrp = devm_kzalloc(ipctl->dev, sizeof(struct group_desc),\n\t\t\t\t   GFP_KERNEL);\n\t\tif (!grp) {\n\t\t\tof_node_put(child);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tmutex_lock(&ipctl->mutex);\n\t\tradix_tree_insert(&pctl->pin_group_tree,\n\t\t\t\t  ipctl->group_index++, grp);\n\t\tmutex_unlock(&ipctl->mutex);\n\n\t\timx_pinctrl_parse_groups(child, grp, ipctl, i++);\n\t}\n\n\treturn 0;\n}\n\n \nstatic bool imx_pinctrl_dt_is_flat_functions(struct device_node *np)\n{\n\tstruct device_node *function_np;\n\tstruct device_node *pinctrl_np;\n\n\tfor_each_child_of_node(np, function_np) {\n\t\tif (of_property_read_bool(function_np, \"fsl,pins\")) {\n\t\t\tof_node_put(function_np);\n\t\t\treturn true;\n\t\t}\n\n\t\tfor_each_child_of_node(function_np, pinctrl_np) {\n\t\t\tif (of_property_read_bool(pinctrl_np, \"fsl,pins\")) {\n\t\t\t\tof_node_put(pinctrl_np);\n\t\t\t\tof_node_put(function_np);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstatic int imx_pinctrl_probe_dt(struct platform_device *pdev,\n\t\t\t\tstruct imx_pinctrl *ipctl)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct device_node *child;\n\tstruct pinctrl_dev *pctl = ipctl->pctl;\n\tu32 nfuncs = 0;\n\tu32 i = 0;\n\tbool flat_funcs;\n\n\tif (!np)\n\t\treturn -ENODEV;\n\n\tflat_funcs = imx_pinctrl_dt_is_flat_functions(np);\n\tif (flat_funcs) {\n\t\tnfuncs = 1;\n\t} else {\n\t\tnfuncs = of_get_child_count(np);\n\t\tif (nfuncs == 0) {\n\t\t\tdev_err(&pdev->dev, \"no functions defined\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tfor (i = 0; i < nfuncs; i++) {\n\t\tstruct function_desc *function;\n\n\t\tfunction = devm_kzalloc(&pdev->dev, sizeof(*function),\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (!function)\n\t\t\treturn -ENOMEM;\n\n\t\tmutex_lock(&ipctl->mutex);\n\t\tradix_tree_insert(&pctl->pin_function_tree, i, function);\n\t\tmutex_unlock(&ipctl->mutex);\n\t}\n\tpctl->num_functions = nfuncs;\n\n\tipctl->group_index = 0;\n\tif (flat_funcs) {\n\t\tpctl->num_groups = of_get_child_count(np);\n\t} else {\n\t\tpctl->num_groups = 0;\n\t\tfor_each_child_of_node(np, child)\n\t\t\tpctl->num_groups += of_get_child_count(child);\n\t}\n\n\tif (flat_funcs) {\n\t\timx_pinctrl_parse_functions(np, ipctl, 0);\n\t} else {\n\t\ti = 0;\n\t\tfor_each_child_of_node(np, child)\n\t\t\timx_pinctrl_parse_functions(child, ipctl, i++);\n\t}\n\n\treturn 0;\n}\n\nint imx_pinctrl_probe(struct platform_device *pdev,\n\t\t      const struct imx_pinctrl_soc_info *info)\n{\n\tstruct regmap_config config = { .name = \"gpr\" };\n\tstruct device_node *dev_np = pdev->dev.of_node;\n\tstruct pinctrl_desc *imx_pinctrl_desc;\n\tstruct device_node *np;\n\tstruct imx_pinctrl *ipctl;\n\tstruct regmap *gpr;\n\tint ret, i;\n\n\tif (!info || !info->pins || !info->npins) {\n\t\tdev_err(&pdev->dev, \"wrong pinctrl info\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (info->gpr_compatible) {\n\t\tgpr = syscon_regmap_lookup_by_compatible(info->gpr_compatible);\n\t\tif (!IS_ERR(gpr))\n\t\t\tregmap_attach_dev(&pdev->dev, gpr, &config);\n\t}\n\n\t \n\tipctl = devm_kzalloc(&pdev->dev, sizeof(*ipctl), GFP_KERNEL);\n\tif (!ipctl)\n\t\treturn -ENOMEM;\n\n\tif (!(info->flags & IMX_USE_SCU)) {\n\t\tipctl->pin_regs = devm_kmalloc_array(&pdev->dev, info->npins,\n\t\t\t\t\t\t     sizeof(*ipctl->pin_regs),\n\t\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!ipctl->pin_regs)\n\t\t\treturn -ENOMEM;\n\n\t\tfor (i = 0; i < info->npins; i++) {\n\t\t\tipctl->pin_regs[i].mux_reg = -1;\n\t\t\tipctl->pin_regs[i].conf_reg = -1;\n\t\t}\n\n\t\tipctl->base = devm_platform_ioremap_resource(pdev, 0);\n\t\tif (IS_ERR(ipctl->base))\n\t\t\treturn PTR_ERR(ipctl->base);\n\n\t\tif (of_property_read_bool(dev_np, \"fsl,input-sel\")) {\n\t\t\tnp = of_parse_phandle(dev_np, \"fsl,input-sel\", 0);\n\t\t\tif (!np) {\n\t\t\t\tdev_err(&pdev->dev, \"iomuxc fsl,input-sel property not found\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tipctl->input_sel_base = of_iomap(np, 0);\n\t\t\tof_node_put(np);\n\t\t\tif (!ipctl->input_sel_base) {\n\t\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\t\"iomuxc input select base address not found\\n\");\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\t}\n\n\timx_pinctrl_desc = devm_kzalloc(&pdev->dev, sizeof(*imx_pinctrl_desc),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!imx_pinctrl_desc)\n\t\treturn -ENOMEM;\n\n\timx_pinctrl_desc->name = dev_name(&pdev->dev);\n\timx_pinctrl_desc->pins = info->pins;\n\timx_pinctrl_desc->npins = info->npins;\n\timx_pinctrl_desc->pctlops = &imx_pctrl_ops;\n\timx_pinctrl_desc->pmxops = &imx_pmx_ops;\n\timx_pinctrl_desc->confops = &imx_pinconf_ops;\n\timx_pinctrl_desc->owner = THIS_MODULE;\n\n\t \n\timx_pmx_ops.gpio_set_direction = info->gpio_set_direction;\n\n\tmutex_init(&ipctl->mutex);\n\n\tipctl->info = info;\n\tipctl->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, ipctl);\n\tret = devm_pinctrl_register_and_init(&pdev->dev,\n\t\t\t\t\t     imx_pinctrl_desc, ipctl,\n\t\t\t\t\t     &ipctl->pctl);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"could not register IMX pinctrl driver\\n\");\n\t\treturn ret;\n\t}\n\n\tret = imx_pinctrl_probe_dt(pdev, ipctl);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"fail to probe dt properties\\n\");\n\t\treturn ret;\n\t}\n\n\tdev_info(&pdev->dev, \"initialized IMX pinctrl driver\\n\");\n\n\treturn pinctrl_enable(ipctl->pctl);\n}\nEXPORT_SYMBOL_GPL(imx_pinctrl_probe);\n\nstatic int __maybe_unused imx_pinctrl_suspend(struct device *dev)\n{\n\tstruct imx_pinctrl *ipctl = dev_get_drvdata(dev);\n\n\treturn pinctrl_force_sleep(ipctl->pctl);\n}\n\nstatic int __maybe_unused imx_pinctrl_resume(struct device *dev)\n{\n\tstruct imx_pinctrl *ipctl = dev_get_drvdata(dev);\n\n\treturn pinctrl_force_default(ipctl->pctl);\n}\n\nconst struct dev_pm_ops imx_pinctrl_pm_ops = {\n\tSET_LATE_SYSTEM_SLEEP_PM_OPS(imx_pinctrl_suspend,\n\t\t\t\t\timx_pinctrl_resume)\n};\nEXPORT_SYMBOL_GPL(imx_pinctrl_pm_ops);\n\nMODULE_AUTHOR(\"Dong Aisheng <aisheng.dong@nxp.com>\");\nMODULE_DESCRIPTION(\"NXP i.MX common pinctrl driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}