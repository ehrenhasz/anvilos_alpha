{
  "module_name": "pinctrl-imx1-core.c",
  "hash_id": "13c3d90090da5a88e4ad146d4220fb37f983719228bb34825821d57d14bda81b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/freescale/pinctrl-imx1-core.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n#include <linux/bitops.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n\n#include <linux/pinctrl/machine.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinmux.h>\n\n#include \"../core.h\"\n#include \"pinctrl-imx1.h\"\n\nstruct imx1_pinctrl {\n\tstruct device *dev;\n\tstruct pinctrl_dev *pctl;\n\tvoid __iomem *base;\n\tconst struct imx1_pinctrl_soc_info *info;\n};\n\n \n\n#define MX1_DDIR 0x00\n#define MX1_OCR 0x04\n#define MX1_ICONFA 0x0c\n#define MX1_ICONFB 0x14\n#define MX1_GIUS 0x20\n#define MX1_GPR 0x38\n#define MX1_PUEN 0x40\n\n#define MX1_PORT_STRIDE 0x100\n\n\n \n#define MX1_MUX_FUNCTION(val) (BIT(0) & val)\n#define MX1_MUX_GPIO(val) ((BIT(1) & val) >> 1)\n#define MX1_MUX_DIR(val) ((BIT(2) & val) >> 2)\n#define MX1_MUX_OCONF(val) (((BIT(4) | BIT(5)) & val) >> 4)\n#define MX1_MUX_ICONFA(val) (((BIT(8) | BIT(9)) & val) >> 8)\n#define MX1_MUX_ICONFB(val) (((BIT(10) | BIT(11)) & val) >> 10)\n\n\n \n\n \nstatic void __iomem *imx1_mem(struct imx1_pinctrl *ipctl, unsigned int pin_id)\n{\n\tunsigned int port = pin_id / 32;\n\treturn ipctl->base + port * MX1_PORT_STRIDE;\n}\n\n \nstatic void imx1_write_2bit(struct imx1_pinctrl *ipctl, unsigned int pin_id,\n\t\tu32 value, u32 reg_offset)\n{\n\tvoid __iomem *reg = imx1_mem(ipctl, pin_id) + reg_offset;\n\tint offset = (pin_id % 16) * 2;  \n\tint mask = ~(0x3 << offset);  \n\tu32 old_val;\n\tu32 new_val;\n\n\t \n\tif (pin_id % 32 >= 16)\n\t\treg += 0x04;\n\n\tdev_dbg(ipctl->dev, \"write: register 0x%p offset %d value 0x%x\\n\",\n\t\t\treg, offset, value);\n\n\t \n\told_val = readl(reg);\n\told_val &= mask;\n\n\tnew_val = value & 0x3;  \n\tnew_val <<= offset;\n\tnew_val |= old_val; \n\n\twritel(new_val, reg);\n}\n\nstatic void imx1_write_bit(struct imx1_pinctrl *ipctl, unsigned int pin_id,\n\t\tu32 value, u32 reg_offset)\n{\n\tvoid __iomem *reg = imx1_mem(ipctl, pin_id) + reg_offset;\n\tint offset = pin_id % 32;\n\tint mask = ~BIT_MASK(offset);\n\tu32 old_val;\n\tu32 new_val;\n\n\t \n\told_val = readl(reg);\n\told_val &= mask;\n\n\tnew_val = value & 0x1;  \n\tnew_val <<= offset;\n\tnew_val |= old_val; \n\n\twritel(new_val, reg);\n}\n\nstatic int imx1_read_2bit(struct imx1_pinctrl *ipctl, unsigned int pin_id,\n\t\tu32 reg_offset)\n{\n\tvoid __iomem *reg = imx1_mem(ipctl, pin_id) + reg_offset;\n\tint offset = (pin_id % 16) * 2;\n\n\t \n\tif (pin_id % 32 >= 16)\n\t\treg += 0x04;\n\n\treturn (readl(reg) & (BIT(offset) | BIT(offset+1))) >> offset;\n}\n\nstatic int imx1_read_bit(struct imx1_pinctrl *ipctl, unsigned int pin_id,\n\t\tu32 reg_offset)\n{\n\tvoid __iomem *reg = imx1_mem(ipctl, pin_id) + reg_offset;\n\tint offset = pin_id % 32;\n\n\treturn !!(readl(reg) & BIT(offset));\n}\n\nstatic inline const struct imx1_pin_group *imx1_pinctrl_find_group_by_name(\n\t\t\t\tconst struct imx1_pinctrl_soc_info *info,\n\t\t\t\tconst char *name)\n{\n\tconst struct imx1_pin_group *grp = NULL;\n\tint i;\n\n\tfor (i = 0; i < info->ngroups; i++) {\n\t\tif (!strcmp(info->groups[i].name, name)) {\n\t\t\tgrp = &info->groups[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn grp;\n}\n\nstatic int imx1_get_groups_count(struct pinctrl_dev *pctldev)\n{\n\tstruct imx1_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct imx1_pinctrl_soc_info *info = ipctl->info;\n\n\treturn info->ngroups;\n}\n\nstatic const char *imx1_get_group_name(struct pinctrl_dev *pctldev,\n\t\t\t\t       unsigned selector)\n{\n\tstruct imx1_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct imx1_pinctrl_soc_info *info = ipctl->info;\n\n\treturn info->groups[selector].name;\n}\n\nstatic int imx1_get_group_pins(struct pinctrl_dev *pctldev, unsigned selector,\n\t\t\t       const unsigned int **pins,\n\t\t\t       unsigned *npins)\n{\n\tstruct imx1_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct imx1_pinctrl_soc_info *info = ipctl->info;\n\n\tif (selector >= info->ngroups)\n\t\treturn -EINVAL;\n\n\t*pins = info->groups[selector].pin_ids;\n\t*npins = info->groups[selector].npins;\n\n\treturn 0;\n}\n\nstatic void imx1_pin_dbg_show(struct pinctrl_dev *pctldev, struct seq_file *s,\n\t\t   unsigned offset)\n{\n\tstruct imx1_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\n\n\tseq_printf(s, \"GPIO %d, function %d, direction %d, oconf %d, iconfa %d, iconfb %d\",\n\t\t\timx1_read_bit(ipctl, offset, MX1_GIUS),\n\t\t\timx1_read_bit(ipctl, offset, MX1_GPR),\n\t\t\timx1_read_bit(ipctl, offset, MX1_DDIR),\n\t\t\timx1_read_2bit(ipctl, offset, MX1_OCR),\n\t\t\timx1_read_2bit(ipctl, offset, MX1_ICONFA),\n\t\t\timx1_read_2bit(ipctl, offset, MX1_ICONFB));\n}\n\nstatic int imx1_dt_node_to_map(struct pinctrl_dev *pctldev,\n\t\t\tstruct device_node *np,\n\t\t\tstruct pinctrl_map **map, unsigned *num_maps)\n{\n\tstruct imx1_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct imx1_pinctrl_soc_info *info = ipctl->info;\n\tconst struct imx1_pin_group *grp;\n\tstruct pinctrl_map *new_map;\n\tstruct device_node *parent;\n\tint map_num = 1;\n\tint i, j;\n\n\t \n\tgrp = imx1_pinctrl_find_group_by_name(info, np->name);\n\tif (!grp) {\n\t\tdev_err(info->dev, \"unable to find group for node %pOFn\\n\",\n\t\t\tnp);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < grp->npins; i++)\n\t\tmap_num++;\n\n\tnew_map = kmalloc_array(map_num, sizeof(struct pinctrl_map),\n\t\t\t\tGFP_KERNEL);\n\tif (!new_map)\n\t\treturn -ENOMEM;\n\n\t*map = new_map;\n\t*num_maps = map_num;\n\n\t \n\tparent = of_get_parent(np);\n\tif (!parent) {\n\t\tkfree(new_map);\n\t\treturn -EINVAL;\n\t}\n\tnew_map[0].type = PIN_MAP_TYPE_MUX_GROUP;\n\tnew_map[0].data.mux.function = parent->name;\n\tnew_map[0].data.mux.group = np->name;\n\tof_node_put(parent);\n\n\t \n\tnew_map++;\n\tfor (i = j = 0; i < grp->npins; i++) {\n\t\tnew_map[j].type = PIN_MAP_TYPE_CONFIGS_PIN;\n\t\tnew_map[j].data.configs.group_or_pin =\n\t\t\t\tpin_get_name(pctldev, grp->pins[i].pin_id);\n\t\tnew_map[j].data.configs.configs = &grp->pins[i].config;\n\t\tnew_map[j].data.configs.num_configs = 1;\n\t\tj++;\n\t}\n\n\tdev_dbg(pctldev->dev, \"maps: function %s group %s num %d\\n\",\n\t\t(*map)->data.mux.function, (*map)->data.mux.group, map_num);\n\n\treturn 0;\n}\n\nstatic void imx1_dt_free_map(struct pinctrl_dev *pctldev,\n\t\t\t\tstruct pinctrl_map *map, unsigned num_maps)\n{\n\tkfree(map);\n}\n\nstatic const struct pinctrl_ops imx1_pctrl_ops = {\n\t.get_groups_count = imx1_get_groups_count,\n\t.get_group_name = imx1_get_group_name,\n\t.get_group_pins = imx1_get_group_pins,\n\t.pin_dbg_show = imx1_pin_dbg_show,\n\t.dt_node_to_map = imx1_dt_node_to_map,\n\t.dt_free_map = imx1_dt_free_map,\n};\n\nstatic int imx1_pmx_set(struct pinctrl_dev *pctldev, unsigned selector,\n\t\t\tunsigned group)\n{\n\tstruct imx1_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct imx1_pinctrl_soc_info *info = ipctl->info;\n\tconst struct imx1_pin *pins;\n\tunsigned int npins;\n\tint i;\n\n\t \n\tpins = info->groups[group].pins;\n\tnpins = info->groups[group].npins;\n\n\tWARN_ON(!pins || !npins);\n\n\tdev_dbg(ipctl->dev, \"enable function %s group %s\\n\",\n\t\tinfo->functions[selector].name, info->groups[group].name);\n\n\tfor (i = 0; i < npins; i++) {\n\t\tunsigned int mux = pins[i].mux_id;\n\t\tunsigned int pin_id = pins[i].pin_id;\n\t\tunsigned int afunction = MX1_MUX_FUNCTION(mux);\n\t\tunsigned int gpio_in_use = MX1_MUX_GPIO(mux);\n\t\tunsigned int direction = MX1_MUX_DIR(mux);\n\t\tunsigned int gpio_oconf = MX1_MUX_OCONF(mux);\n\t\tunsigned int gpio_iconfa = MX1_MUX_ICONFA(mux);\n\t\tunsigned int gpio_iconfb = MX1_MUX_ICONFB(mux);\n\n\t\tdev_dbg(pctldev->dev, \"%s, pin 0x%x, function %d, gpio %d, direction %d, oconf %d, iconfa %d, iconfb %d\\n\",\n\t\t\t\t__func__, pin_id, afunction, gpio_in_use,\n\t\t\t\tdirection, gpio_oconf, gpio_iconfa,\n\t\t\t\tgpio_iconfb);\n\n\t\timx1_write_bit(ipctl, pin_id, gpio_in_use, MX1_GIUS);\n\t\timx1_write_bit(ipctl, pin_id, direction, MX1_DDIR);\n\n\t\tif (gpio_in_use) {\n\t\t\timx1_write_2bit(ipctl, pin_id, gpio_oconf, MX1_OCR);\n\t\t\timx1_write_2bit(ipctl, pin_id, gpio_iconfa,\n\t\t\t\t\tMX1_ICONFA);\n\t\t\timx1_write_2bit(ipctl, pin_id, gpio_iconfb,\n\t\t\t\t\tMX1_ICONFB);\n\t\t} else {\n\t\t\timx1_write_bit(ipctl, pin_id, afunction, MX1_GPR);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int imx1_pmx_get_funcs_count(struct pinctrl_dev *pctldev)\n{\n\tstruct imx1_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct imx1_pinctrl_soc_info *info = ipctl->info;\n\n\treturn info->nfunctions;\n}\n\nstatic const char *imx1_pmx_get_func_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t  unsigned selector)\n{\n\tstruct imx1_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct imx1_pinctrl_soc_info *info = ipctl->info;\n\n\treturn info->functions[selector].name;\n}\n\nstatic int imx1_pmx_get_groups(struct pinctrl_dev *pctldev, unsigned selector,\n\t\t\t       const char * const **groups,\n\t\t\t       unsigned * const num_groups)\n{\n\tstruct imx1_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct imx1_pinctrl_soc_info *info = ipctl->info;\n\n\t*groups = info->functions[selector].groups;\n\t*num_groups = info->functions[selector].num_groups;\n\n\treturn 0;\n}\n\nstatic const struct pinmux_ops imx1_pmx_ops = {\n\t.get_functions_count = imx1_pmx_get_funcs_count,\n\t.get_function_name = imx1_pmx_get_func_name,\n\t.get_function_groups = imx1_pmx_get_groups,\n\t.set_mux = imx1_pmx_set,\n};\n\nstatic int imx1_pinconf_get(struct pinctrl_dev *pctldev,\n\t\t\t     unsigned pin_id, unsigned long *config)\n{\n\tstruct imx1_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\n\n\t*config = imx1_read_bit(ipctl, pin_id, MX1_PUEN);\n\n\treturn 0;\n}\n\nstatic int imx1_pinconf_set(struct pinctrl_dev *pctldev,\n\t\t\t     unsigned pin_id, unsigned long *configs,\n\t\t\t     unsigned num_configs)\n{\n\tstruct imx1_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\n\tint i;\n\n\tfor (i = 0; i != num_configs; ++i) {\n\t\timx1_write_bit(ipctl, pin_id, configs[i] & 0x01, MX1_PUEN);\n\n\t\tdev_dbg(ipctl->dev, \"pinconf set pullup pin %s\\n\",\n\t\t\tpin_desc_get(pctldev, pin_id)->name);\n\t}\n\n\treturn 0;\n}\n\nstatic void imx1_pinconf_dbg_show(struct pinctrl_dev *pctldev,\n\t\t\t\t   struct seq_file *s, unsigned pin_id)\n{\n\tunsigned long config;\n\n\timx1_pinconf_get(pctldev, pin_id, &config);\n\tseq_printf(s, \"0x%lx\", config);\n}\n\nstatic void imx1_pinconf_group_dbg_show(struct pinctrl_dev *pctldev,\n\t\t\t\t\t struct seq_file *s, unsigned group)\n{\n\tstruct imx1_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\n\tconst struct imx1_pinctrl_soc_info *info = ipctl->info;\n\tstruct imx1_pin_group *grp;\n\tunsigned long config;\n\tconst char *name;\n\tint i, ret;\n\n\tif (group >= info->ngroups)\n\t\treturn;\n\n\tseq_puts(s, \"\\n\");\n\tgrp = &info->groups[group];\n\tfor (i = 0; i < grp->npins; i++) {\n\t\tname = pin_get_name(pctldev, grp->pins[i].pin_id);\n\t\tret = imx1_pinconf_get(pctldev, grp->pins[i].pin_id, &config);\n\t\tif (ret)\n\t\t\treturn;\n\t\tseq_printf(s, \"%s: 0x%lx\", name, config);\n\t}\n}\n\nstatic const struct pinconf_ops imx1_pinconf_ops = {\n\t.pin_config_get = imx1_pinconf_get,\n\t.pin_config_set = imx1_pinconf_set,\n\t.pin_config_dbg_show = imx1_pinconf_dbg_show,\n\t.pin_config_group_dbg_show = imx1_pinconf_group_dbg_show,\n};\n\nstatic struct pinctrl_desc imx1_pinctrl_desc = {\n\t.pctlops = &imx1_pctrl_ops,\n\t.pmxops = &imx1_pmx_ops,\n\t.confops = &imx1_pinconf_ops,\n\t.owner = THIS_MODULE,\n};\n\nstatic int imx1_pinctrl_parse_groups(struct device_node *np,\n\t\t\t\t    struct imx1_pin_group *grp,\n\t\t\t\t    struct imx1_pinctrl_soc_info *info,\n\t\t\t\t    u32 index)\n{\n\tint size;\n\tconst __be32 *list;\n\tint i;\n\n\tdev_dbg(info->dev, \"group(%d): %pOFn\\n\", index, np);\n\n\t \n\tgrp->name = np->name;\n\n\t \n\tlist = of_get_property(np, \"fsl,pins\", &size);\n\t \n\tif (!size || size % 12) {\n\t\tdev_notice(info->dev, \"Not a valid fsl,pins property (%pOFn)\\n\",\n\t\t\t\tnp);\n\t\treturn -EINVAL;\n\t}\n\n\tgrp->npins = size / 12;\n\tgrp->pins = devm_kcalloc(info->dev,\n\t\t\tgrp->npins, sizeof(struct imx1_pin), GFP_KERNEL);\n\tgrp->pin_ids = devm_kcalloc(info->dev,\n\t\t\tgrp->npins, sizeof(unsigned int), GFP_KERNEL);\n\n\tif (!grp->pins || !grp->pin_ids)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < grp->npins; i++) {\n\t\tgrp->pins[i].pin_id = be32_to_cpu(*list++);\n\t\tgrp->pins[i].mux_id = be32_to_cpu(*list++);\n\t\tgrp->pins[i].config = be32_to_cpu(*list++);\n\n\t\tgrp->pin_ids[i] = grp->pins[i].pin_id;\n\t}\n\n\treturn 0;\n}\n\nstatic int imx1_pinctrl_parse_functions(struct device_node *np,\n\t\t\t\t       struct imx1_pinctrl_soc_info *info,\n\t\t\t\t       u32 index)\n{\n\tstruct device_node *child;\n\tstruct imx1_pmx_func *func;\n\tstruct imx1_pin_group *grp;\n\tint ret;\n\tstatic u32 grp_index;\n\tu32 i = 0;\n\n\tdev_dbg(info->dev, \"parse function(%d): %pOFn\\n\", index, np);\n\n\tfunc = &info->functions[index];\n\n\t \n\tfunc->name = np->name;\n\tfunc->num_groups = of_get_child_count(np);\n\tif (func->num_groups == 0)\n\t\treturn -EINVAL;\n\n\tfunc->groups = devm_kcalloc(info->dev,\n\t\t\tfunc->num_groups, sizeof(char *), GFP_KERNEL);\n\n\tif (!func->groups)\n\t\treturn -ENOMEM;\n\n\tfor_each_child_of_node(np, child) {\n\t\tfunc->groups[i] = child->name;\n\t\tgrp = &info->groups[grp_index++];\n\t\tret = imx1_pinctrl_parse_groups(child, grp, info, i++);\n\t\tif (ret == -ENOMEM) {\n\t\t\tof_node_put(child);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int imx1_pinctrl_parse_dt(struct platform_device *pdev,\n\t\tstruct imx1_pinctrl *pctl, struct imx1_pinctrl_soc_info *info)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct device_node *child;\n\tint ret;\n\tu32 nfuncs = 0;\n\tu32 ngroups = 0;\n\tu32 ifunc = 0;\n\n\tif (!np)\n\t\treturn -ENODEV;\n\n\tfor_each_child_of_node(np, child) {\n\t\t++nfuncs;\n\t\tngroups += of_get_child_count(child);\n\t}\n\n\tif (!nfuncs) {\n\t\tdev_err(&pdev->dev, \"No pin functions defined\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tinfo->nfunctions = nfuncs;\n\tinfo->functions = devm_kcalloc(&pdev->dev,\n\t\t\tnfuncs, sizeof(struct imx1_pmx_func), GFP_KERNEL);\n\n\tinfo->ngroups = ngroups;\n\tinfo->groups = devm_kcalloc(&pdev->dev,\n\t\t\tngroups, sizeof(struct imx1_pin_group), GFP_KERNEL);\n\n\n\tif (!info->functions || !info->groups)\n\t\treturn -ENOMEM;\n\n\tfor_each_child_of_node(np, child) {\n\t\tret = imx1_pinctrl_parse_functions(child, info, ifunc++);\n\t\tif (ret == -ENOMEM) {\n\t\t\tof_node_put(child);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint imx1_pinctrl_core_probe(struct platform_device *pdev,\n\t\t      struct imx1_pinctrl_soc_info *info)\n{\n\tstruct imx1_pinctrl *ipctl;\n\tstruct resource *res;\n\tstruct pinctrl_desc *pctl_desc;\n\tint ret;\n\n\tif (!info || !info->pins || !info->npins) {\n\t\tdev_err(&pdev->dev, \"wrong pinctrl info\\n\");\n\t\treturn -EINVAL;\n\t}\n\tinfo->dev = &pdev->dev;\n\n\t \n\tipctl = devm_kzalloc(&pdev->dev, sizeof(*ipctl), GFP_KERNEL);\n\tif (!ipctl)\n\t\treturn -ENOMEM;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -ENOENT;\n\n\tipctl->base = devm_ioremap(&pdev->dev, res->start,\n\t\t\tresource_size(res));\n\tif (!ipctl->base)\n\t\treturn -ENOMEM;\n\n\tpctl_desc = &imx1_pinctrl_desc;\n\tpctl_desc->name = dev_name(&pdev->dev);\n\tpctl_desc->pins = info->pins;\n\tpctl_desc->npins = info->npins;\n\n\tret = imx1_pinctrl_parse_dt(pdev, ipctl, info);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"fail to probe dt properties\\n\");\n\t\treturn ret;\n\t}\n\n\tipctl->info = info;\n\tipctl->dev = info->dev;\n\tplatform_set_drvdata(pdev, ipctl);\n\tipctl->pctl = devm_pinctrl_register(&pdev->dev, pctl_desc, ipctl);\n\tif (IS_ERR(ipctl->pctl)) {\n\t\tdev_err(&pdev->dev, \"could not register IMX pinctrl driver\\n\");\n\t\treturn PTR_ERR(ipctl->pctl);\n\t}\n\n\tret = of_platform_populate(pdev->dev.of_node, NULL, NULL, &pdev->dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to populate subdevices\\n\");\n\t\treturn ret;\n\t}\n\n\tdev_info(&pdev->dev, \"initialized IMX pinctrl driver\\n\");\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}