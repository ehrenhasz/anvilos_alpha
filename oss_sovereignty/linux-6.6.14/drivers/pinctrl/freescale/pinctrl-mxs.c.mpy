{
  "module_name": "pinctrl-mxs.c",
  "hash_id": "bd41ff586cb53154bb3686bedcb773b842a02003d2e96c912453c946079d8bf8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/freescale/pinctrl-mxs.c",
  "human_readable_source": "\n\n\n\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n\n#include <linux/pinctrl/machine.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinmux.h>\n\n#include \"../core.h\"\n#include \"pinctrl-mxs.h\"\n\n#define SUFFIX_LEN\t4\n\nstruct mxs_pinctrl_data {\n\tstruct device *dev;\n\tstruct pinctrl_dev *pctl;\n\tvoid __iomem *base;\n\tstruct mxs_pinctrl_soc_data *soc;\n};\n\nstatic int mxs_get_groups_count(struct pinctrl_dev *pctldev)\n{\n\tstruct mxs_pinctrl_data *d = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn d->soc->ngroups;\n}\n\nstatic const char *mxs_get_group_name(struct pinctrl_dev *pctldev,\n\t\t\t\t      unsigned group)\n{\n\tstruct mxs_pinctrl_data *d = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn d->soc->groups[group].name;\n}\n\nstatic int mxs_get_group_pins(struct pinctrl_dev *pctldev, unsigned group,\n\t\t\t      const unsigned **pins, unsigned *num_pins)\n{\n\tstruct mxs_pinctrl_data *d = pinctrl_dev_get_drvdata(pctldev);\n\n\t*pins = d->soc->groups[group].pins;\n\t*num_pins = d->soc->groups[group].npins;\n\n\treturn 0;\n}\n\nstatic void mxs_pin_dbg_show(struct pinctrl_dev *pctldev, struct seq_file *s,\n\t\t\t     unsigned offset)\n{\n\tseq_printf(s, \" %s\", dev_name(pctldev->dev));\n}\n\nstatic int mxs_dt_node_to_map(struct pinctrl_dev *pctldev,\n\t\t\t      struct device_node *np,\n\t\t\t      struct pinctrl_map **map, unsigned *num_maps)\n{\n\tstruct pinctrl_map *new_map;\n\tchar *group = NULL;\n\tunsigned new_num = 1;\n\tunsigned long config = 0;\n\tunsigned long *pconfig;\n\tint length = strlen(np->name) + SUFFIX_LEN;\n\tbool purecfg = false;\n\tu32 val, reg;\n\tint ret, i = 0;\n\n\t \n\tif (of_property_read_u32(np, \"reg\", &reg))\n\t\tpurecfg = true;\n\n\tret = of_property_read_u32(np, \"fsl,drive-strength\", &val);\n\tif (!ret)\n\t\tconfig = val | MA_PRESENT;\n\tret = of_property_read_u32(np, \"fsl,voltage\", &val);\n\tif (!ret)\n\t\tconfig |= val << VOL_SHIFT | VOL_PRESENT;\n\tret = of_property_read_u32(np, \"fsl,pull-up\", &val);\n\tif (!ret)\n\t\tconfig |= val << PULL_SHIFT | PULL_PRESENT;\n\n\t \n\tif (!purecfg && config)\n\t\tnew_num = 2;\n\n\tnew_map = kcalloc(new_num, sizeof(*new_map), GFP_KERNEL);\n\tif (!new_map)\n\t\treturn -ENOMEM;\n\n\tif (!purecfg) {\n\t\tnew_map[i].type = PIN_MAP_TYPE_MUX_GROUP;\n\t\tnew_map[i].data.mux.function = np->name;\n\n\t\t \n\t\tgroup = kzalloc(length, GFP_KERNEL);\n\t\tif (!group) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t\tsnprintf(group, length, \"%s.%d\", np->name, reg);\n\t\tnew_map[i].data.mux.group = group;\n\t\ti++;\n\t}\n\n\tif (config) {\n\t\tpconfig = kmemdup(&config, sizeof(config), GFP_KERNEL);\n\t\tif (!pconfig) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_group;\n\t\t}\n\n\t\tnew_map[i].type = PIN_MAP_TYPE_CONFIGS_GROUP;\n\t\tnew_map[i].data.configs.group_or_pin = purecfg ? np->name :\n\t\t\t\t\t\t\t\t group;\n\t\tnew_map[i].data.configs.configs = pconfig;\n\t\tnew_map[i].data.configs.num_configs = 1;\n\t}\n\n\t*map = new_map;\n\t*num_maps = new_num;\n\n\treturn 0;\n\nfree_group:\n\tif (!purecfg)\n\t\tkfree(group);\nfree:\n\tkfree(new_map);\n\treturn ret;\n}\n\nstatic void mxs_dt_free_map(struct pinctrl_dev *pctldev,\n\t\t\t    struct pinctrl_map *map, unsigned num_maps)\n{\n\tu32 i;\n\n\tfor (i = 0; i < num_maps; i++) {\n\t\tif (map[i].type == PIN_MAP_TYPE_MUX_GROUP)\n\t\t\tkfree(map[i].data.mux.group);\n\t\tif (map[i].type == PIN_MAP_TYPE_CONFIGS_GROUP)\n\t\t\tkfree(map[i].data.configs.configs);\n\t}\n\n\tkfree(map);\n}\n\nstatic const struct pinctrl_ops mxs_pinctrl_ops = {\n\t.get_groups_count = mxs_get_groups_count,\n\t.get_group_name = mxs_get_group_name,\n\t.get_group_pins = mxs_get_group_pins,\n\t.pin_dbg_show = mxs_pin_dbg_show,\n\t.dt_node_to_map = mxs_dt_node_to_map,\n\t.dt_free_map = mxs_dt_free_map,\n};\n\nstatic int mxs_pinctrl_get_funcs_count(struct pinctrl_dev *pctldev)\n{\n\tstruct mxs_pinctrl_data *d = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn d->soc->nfunctions;\n}\n\nstatic const char *mxs_pinctrl_get_func_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t     unsigned function)\n{\n\tstruct mxs_pinctrl_data *d = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn d->soc->functions[function].name;\n}\n\nstatic int mxs_pinctrl_get_func_groups(struct pinctrl_dev *pctldev,\n\t\t\t\t       unsigned group,\n\t\t\t\t       const char * const **groups,\n\t\t\t\t       unsigned * const num_groups)\n{\n\tstruct mxs_pinctrl_data *d = pinctrl_dev_get_drvdata(pctldev);\n\n\t*groups = d->soc->functions[group].groups;\n\t*num_groups = d->soc->functions[group].ngroups;\n\n\treturn 0;\n}\n\nstatic void mxs_pinctrl_rmwl(u32 value, u32 mask, u8 shift, void __iomem *reg)\n{\n\tu32 tmp;\n\n\ttmp = readl(reg);\n\ttmp &= ~(mask << shift);\n\ttmp |= value << shift;\n\twritel(tmp, reg);\n}\n\nstatic int mxs_pinctrl_set_mux(struct pinctrl_dev *pctldev, unsigned selector,\n\t\t\t       unsigned group)\n{\n\tstruct mxs_pinctrl_data *d = pinctrl_dev_get_drvdata(pctldev);\n\tstruct mxs_group *g = &d->soc->groups[group];\n\tvoid __iomem *reg;\n\tu8 bank, shift;\n\tu16 pin;\n\tu32 i;\n\n\tfor (i = 0; i < g->npins; i++) {\n\t\tbank = PINID_TO_BANK(g->pins[i]);\n\t\tpin = PINID_TO_PIN(g->pins[i]);\n\t\treg = d->base + d->soc->regs->muxsel;\n\t\treg += bank * 0x20 + pin / 16 * 0x10;\n\t\tshift = pin % 16 * 2;\n\n\t\tmxs_pinctrl_rmwl(g->muxsel[i], 0x3, shift, reg);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct pinmux_ops mxs_pinmux_ops = {\n\t.get_functions_count = mxs_pinctrl_get_funcs_count,\n\t.get_function_name = mxs_pinctrl_get_func_name,\n\t.get_function_groups = mxs_pinctrl_get_func_groups,\n\t.set_mux = mxs_pinctrl_set_mux,\n};\n\nstatic int mxs_pinconf_get(struct pinctrl_dev *pctldev,\n\t\t\t   unsigned pin, unsigned long *config)\n{\n\treturn -ENOTSUPP;\n}\n\nstatic int mxs_pinconf_set(struct pinctrl_dev *pctldev,\n\t\t\t   unsigned pin, unsigned long *configs,\n\t\t\t   unsigned num_configs)\n{\n\treturn -ENOTSUPP;\n}\n\nstatic int mxs_pinconf_group_get(struct pinctrl_dev *pctldev,\n\t\t\t\t unsigned group, unsigned long *config)\n{\n\tstruct mxs_pinctrl_data *d = pinctrl_dev_get_drvdata(pctldev);\n\n\t*config = d->soc->groups[group].config;\n\n\treturn 0;\n}\n\nstatic int mxs_pinconf_group_set(struct pinctrl_dev *pctldev,\n\t\t\t\t unsigned group, unsigned long *configs,\n\t\t\t\t unsigned num_configs)\n{\n\tstruct mxs_pinctrl_data *d = pinctrl_dev_get_drvdata(pctldev);\n\tstruct mxs_group *g = &d->soc->groups[group];\n\tvoid __iomem *reg;\n\tu8 ma, vol, pull, bank, shift;\n\tu16 pin;\n\tu32 i;\n\tint n;\n\tunsigned long config;\n\n\tfor (n = 0; n < num_configs; n++) {\n\t\tconfig = configs[n];\n\n\t\tma = PIN_CONFIG_TO_MA(config);\n\t\tvol = PIN_CONFIG_TO_VOL(config);\n\t\tpull = PIN_CONFIG_TO_PULL(config);\n\n\t\tfor (i = 0; i < g->npins; i++) {\n\t\t\tbank = PINID_TO_BANK(g->pins[i]);\n\t\t\tpin = PINID_TO_PIN(g->pins[i]);\n\n\t\t\t \n\t\t\treg = d->base + d->soc->regs->drive;\n\t\t\treg += bank * 0x40 + pin / 8 * 0x10;\n\n\t\t\t \n\t\t\tif (config & MA_PRESENT) {\n\t\t\t\tshift = pin % 8 * 4;\n\t\t\t\tmxs_pinctrl_rmwl(ma, 0x3, shift, reg);\n\t\t\t}\n\n\t\t\t \n\t\t\tif (config & VOL_PRESENT) {\n\t\t\t\tshift = pin % 8 * 4 + 2;\n\t\t\t\tif (vol)\n\t\t\t\t\twritel(1 << shift, reg + SET);\n\t\t\t\telse\n\t\t\t\t\twritel(1 << shift, reg + CLR);\n\t\t\t}\n\n\t\t\t \n\t\t\tif (config & PULL_PRESENT) {\n\t\t\t\treg = d->base + d->soc->regs->pull;\n\t\t\t\treg += bank * 0x10;\n\t\t\t\tshift = pin;\n\t\t\t\tif (pull)\n\t\t\t\t\twritel(1 << shift, reg + SET);\n\t\t\t\telse\n\t\t\t\t\twritel(1 << shift, reg + CLR);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tg->config = config;\n\n\t}  \n\n\treturn 0;\n}\n\nstatic void mxs_pinconf_dbg_show(struct pinctrl_dev *pctldev,\n\t\t\t\t struct seq_file *s, unsigned pin)\n{\n\t \n}\n\nstatic void mxs_pinconf_group_dbg_show(struct pinctrl_dev *pctldev,\n\t\t\t\t       struct seq_file *s, unsigned group)\n{\n\tunsigned long config;\n\n\tif (!mxs_pinconf_group_get(pctldev, group, &config))\n\t\tseq_printf(s, \"0x%lx\", config);\n}\n\nstatic const struct pinconf_ops mxs_pinconf_ops = {\n\t.pin_config_get = mxs_pinconf_get,\n\t.pin_config_set = mxs_pinconf_set,\n\t.pin_config_group_get = mxs_pinconf_group_get,\n\t.pin_config_group_set = mxs_pinconf_group_set,\n\t.pin_config_dbg_show = mxs_pinconf_dbg_show,\n\t.pin_config_group_dbg_show = mxs_pinconf_group_dbg_show,\n};\n\nstatic struct pinctrl_desc mxs_pinctrl_desc = {\n\t.pctlops = &mxs_pinctrl_ops,\n\t.pmxops = &mxs_pinmux_ops,\n\t.confops = &mxs_pinconf_ops,\n\t.owner = THIS_MODULE,\n};\n\nstatic int mxs_pinctrl_parse_group(struct platform_device *pdev,\n\t\t\t\t   struct device_node *np, int idx,\n\t\t\t\t   const char **out_name)\n{\n\tstruct mxs_pinctrl_data *d = platform_get_drvdata(pdev);\n\tstruct mxs_group *g = &d->soc->groups[idx];\n\tstruct property *prop;\n\tconst char *propname = \"fsl,pinmux-ids\";\n\tchar *group;\n\tint length = strlen(np->name) + SUFFIX_LEN;\n\tu32 val, i;\n\n\tgroup = devm_kzalloc(&pdev->dev, length, GFP_KERNEL);\n\tif (!group)\n\t\treturn -ENOMEM;\n\tif (of_property_read_u32(np, \"reg\", &val))\n\t\tsnprintf(group, length, \"%s\", np->name);\n\telse\n\t\tsnprintf(group, length, \"%s.%d\", np->name, val);\n\tg->name = group;\n\n\tprop = of_find_property(np, propname, &length);\n\tif (!prop)\n\t\treturn -EINVAL;\n\tg->npins = length / sizeof(u32);\n\n\tg->pins = devm_kcalloc(&pdev->dev, g->npins, sizeof(*g->pins),\n\t\t\t       GFP_KERNEL);\n\tif (!g->pins)\n\t\treturn -ENOMEM;\n\n\tg->muxsel = devm_kcalloc(&pdev->dev, g->npins, sizeof(*g->muxsel),\n\t\t\t\t GFP_KERNEL);\n\tif (!g->muxsel)\n\t\treturn -ENOMEM;\n\n\tof_property_read_u32_array(np, propname, g->pins, g->npins);\n\tfor (i = 0; i < g->npins; i++) {\n\t\tg->muxsel[i] = MUXID_TO_MUXSEL(g->pins[i]);\n\t\tg->pins[i] = MUXID_TO_PINID(g->pins[i]);\n\t}\n\n\tif (out_name)\n\t\t*out_name = g->name;\n\n\treturn 0;\n}\n\nstatic int mxs_pinctrl_probe_dt(struct platform_device *pdev,\n\t\t\t\tstruct mxs_pinctrl_data *d)\n{\n\tstruct mxs_pinctrl_soc_data *soc = d->soc;\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct device_node *child;\n\tstruct mxs_function *f;\n\tconst char *gpio_compat = \"fsl,mxs-gpio\";\n\tconst char *fn, *fnull = \"\";\n\tint i = 0, idxf = 0, idxg = 0;\n\tint ret;\n\tu32 val;\n\n\tchild = of_get_next_child(np, NULL);\n\tif (!child) {\n\t\tdev_err(&pdev->dev, \"no group is defined\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\t \n\tfn = fnull;\n\tfor_each_child_of_node(np, child) {\n\t\tif (of_device_is_compatible(child, gpio_compat))\n\t\t\tcontinue;\n\t\tsoc->ngroups++;\n\t\t \n\t\tif (of_property_read_u32(child, \"reg\", &val))\n\t\t\tcontinue;\n\t\tif (strcmp(fn, child->name)) {\n\t\t\tfn = child->name;\n\t\t\tsoc->nfunctions++;\n\t\t}\n\t}\n\n\tsoc->functions = devm_kcalloc(&pdev->dev,\n\t\t\t\t      soc->nfunctions,\n\t\t\t\t      sizeof(*soc->functions),\n\t\t\t\t      GFP_KERNEL);\n\tif (!soc->functions)\n\t\treturn -ENOMEM;\n\n\tsoc->groups = devm_kcalloc(&pdev->dev,\n\t\t\t\t   soc->ngroups, sizeof(*soc->groups),\n\t\t\t\t   GFP_KERNEL);\n\tif (!soc->groups)\n\t\treturn -ENOMEM;\n\n\t \n\tfn = fnull;\n\tf = &soc->functions[idxf];\n\tfor_each_child_of_node(np, child) {\n\t\tif (of_device_is_compatible(child, gpio_compat))\n\t\t\tcontinue;\n\t\tif (of_property_read_u32(child, \"reg\", &val))\n\t\t\tcontinue;\n\t\tif (strcmp(fn, child->name)) {\n\t\t\tstruct device_node *child2;\n\n\t\t\t \n\t\t\tof_node_get(child);\n\n\t\t\t \n\t\t\tfor (child2 = of_get_next_child(np, child);\n\t\t\t     child2 != NULL;\n\t\t\t     child2 = of_get_next_child(np, child2)) {\n\t\t\t\tif (!strcmp(child2->name, fn))\n\t\t\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t\t\t \"function nodes must be grouped by name (failed for: %s)\",\n\t\t\t\t\t\t fn);\n\t\t\t}\n\n\t\t\tf = &soc->functions[idxf++];\n\t\t\tf->name = fn = child->name;\n\t\t}\n\t\tf->ngroups++;\n\t}\n\n\t \n\tidxf = 0;\n\tfn = fnull;\n\tfor_each_child_of_node(np, child) {\n\t\tif (of_device_is_compatible(child, gpio_compat))\n\t\t\tcontinue;\n\t\tif (of_property_read_u32(child, \"reg\", &val)) {\n\t\t\tret = mxs_pinctrl_parse_group(pdev, child,\n\t\t\t\t\t\t      idxg++, NULL);\n\t\t\tif (ret) {\n\t\t\t\tof_node_put(child);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strcmp(fn, child->name)) {\n\t\t\tf = &soc->functions[idxf++];\n\t\t\tf->groups = devm_kcalloc(&pdev->dev,\n\t\t\t\t\t\t f->ngroups,\n\t\t\t\t\t\t sizeof(*f->groups),\n\t\t\t\t\t\t GFP_KERNEL);\n\t\t\tif (!f->groups) {\n\t\t\t\tof_node_put(child);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tfn = child->name;\n\t\t\ti = 0;\n\t\t}\n\t\tret = mxs_pinctrl_parse_group(pdev, child, idxg++,\n\t\t\t\t\t      &f->groups[i++]);\n\t\tif (ret) {\n\t\t\tof_node_put(child);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint mxs_pinctrl_probe(struct platform_device *pdev,\n\t\t      struct mxs_pinctrl_soc_data *soc)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct mxs_pinctrl_data *d;\n\tint ret;\n\n\td = devm_kzalloc(&pdev->dev, sizeof(*d), GFP_KERNEL);\n\tif (!d)\n\t\treturn -ENOMEM;\n\n\td->dev = &pdev->dev;\n\td->soc = soc;\n\n\td->base = of_iomap(np, 0);\n\tif (!d->base)\n\t\treturn -EADDRNOTAVAIL;\n\n\tmxs_pinctrl_desc.pins = d->soc->pins;\n\tmxs_pinctrl_desc.npins = d->soc->npins;\n\tmxs_pinctrl_desc.name = dev_name(&pdev->dev);\n\n\tplatform_set_drvdata(pdev, d);\n\n\tret = mxs_pinctrl_probe_dt(pdev, d);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"dt probe failed: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\td->pctl = pinctrl_register(&mxs_pinctrl_desc, &pdev->dev, d);\n\tif (IS_ERR(d->pctl)) {\n\t\tdev_err(&pdev->dev, \"Couldn't register MXS pinctrl driver\\n\");\n\t\tret = PTR_ERR(d->pctl);\n\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tiounmap(d->base);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}