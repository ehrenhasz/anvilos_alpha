{
  "module_name": "pinctrl-wmt.c",
  "hash_id": "3952e457b4a21b448676717d58c55f44d1cfc3d71dc52fa5fe53ed458ff7d2fc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/pinctrl/vt8500/pinctrl-wmt.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/gpio/driver.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/pinctrl/machine.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinconf-generic.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinmux.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include \"pinctrl-wmt.h\"\n\nstatic inline void wmt_setbits(struct wmt_pinctrl_data *data, u32 reg,\n\t\t\t\t u32 mask)\n{\n\tu32 val;\n\n\tval = readl_relaxed(data->base + reg);\n\tval |= mask;\n\twritel_relaxed(val, data->base + reg);\n}\n\nstatic inline void wmt_clearbits(struct wmt_pinctrl_data *data, u32 reg,\n\t\t\t\t   u32 mask)\n{\n\tu32 val;\n\n\tval = readl_relaxed(data->base + reg);\n\tval &= ~mask;\n\twritel_relaxed(val, data->base + reg);\n}\n\nenum wmt_func_sel {\n\tWMT_FSEL_GPIO_IN = 0,\n\tWMT_FSEL_GPIO_OUT = 1,\n\tWMT_FSEL_ALT = 2,\n\tWMT_FSEL_COUNT = 3,\n};\n\nstatic const char * const wmt_functions[WMT_FSEL_COUNT] = {\n\t[WMT_FSEL_GPIO_IN] = \"gpio_in\",\n\t[WMT_FSEL_GPIO_OUT] = \"gpio_out\",\n\t[WMT_FSEL_ALT] = \"alt\",\n};\n\nstatic int wmt_pmx_get_functions_count(struct pinctrl_dev *pctldev)\n{\n\treturn WMT_FSEL_COUNT;\n}\n\nstatic const char *wmt_pmx_get_function_name(struct pinctrl_dev *pctldev,\n\t\t\t\t\t     unsigned selector)\n{\n\treturn wmt_functions[selector];\n}\n\nstatic int wmt_pmx_get_function_groups(struct pinctrl_dev *pctldev,\n\t\t\t\t       unsigned selector,\n\t\t\t\t       const char * const **groups,\n\t\t\t\t       unsigned * const num_groups)\n{\n\tstruct wmt_pinctrl_data *data = pinctrl_dev_get_drvdata(pctldev);\n\n\t \n\t*groups = data->groups;\n\t*num_groups = data->ngroups;\n\n\treturn 0;\n}\n\nstatic int wmt_set_pinmux(struct wmt_pinctrl_data *data, unsigned func,\n\t\t\t  unsigned pin)\n{\n\tu32 bank = WMT_BANK_FROM_PIN(pin);\n\tu32 bit = WMT_BIT_FROM_PIN(pin);\n\tu32 reg_en = data->banks[bank].reg_en;\n\tu32 reg_dir = data->banks[bank].reg_dir;\n\n\tif (reg_dir == NO_REG) {\n\t\tdev_err(data->dev, \"pin:%d no direction register defined\\n\",\n\t\t\tpin);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (func) {\n\tcase WMT_FSEL_GPIO_IN:\n\t\tif (reg_en != NO_REG)\n\t\t\twmt_setbits(data, reg_en, BIT(bit));\n\t\twmt_clearbits(data, reg_dir, BIT(bit));\n\t\tbreak;\n\tcase WMT_FSEL_GPIO_OUT:\n\t\tif (reg_en != NO_REG)\n\t\t\twmt_setbits(data, reg_en, BIT(bit));\n\t\twmt_setbits(data, reg_dir, BIT(bit));\n\t\tbreak;\n\tcase WMT_FSEL_ALT:\n\t\tif (reg_en == NO_REG) {\n\t\t\tdev_err(data->dev, \"pin:%d no alt function available\\n\",\n\t\t\t\tpin);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\twmt_clearbits(data, reg_en, BIT(bit));\n\t}\n\n\treturn 0;\n}\n\nstatic int wmt_pmx_set_mux(struct pinctrl_dev *pctldev,\n\t\t\t   unsigned func_selector,\n\t\t\t   unsigned group_selector)\n{\n\tstruct wmt_pinctrl_data *data = pinctrl_dev_get_drvdata(pctldev);\n\tu32 pinnum = data->pins[group_selector].number;\n\n\treturn wmt_set_pinmux(data, func_selector, pinnum);\n}\n\nstatic void wmt_pmx_gpio_disable_free(struct pinctrl_dev *pctldev,\n\t\t\t\t      struct pinctrl_gpio_range *range,\n\t\t\t\t      unsigned offset)\n{\n\tstruct wmt_pinctrl_data *data = pinctrl_dev_get_drvdata(pctldev);\n\n\t \n\twmt_set_pinmux(data, WMT_FSEL_GPIO_IN, offset);\n}\n\nstatic int wmt_pmx_gpio_set_direction(struct pinctrl_dev *pctldev,\n\t\t\t\t      struct pinctrl_gpio_range *range,\n\t\t\t\t      unsigned offset,\n\t\t\t\t      bool input)\n{\n\tstruct wmt_pinctrl_data *data = pinctrl_dev_get_drvdata(pctldev);\n\n\twmt_set_pinmux(data, (input ? WMT_FSEL_GPIO_IN : WMT_FSEL_GPIO_OUT),\n\t\t       offset);\n\n\treturn 0;\n}\n\nstatic const struct pinmux_ops wmt_pinmux_ops = {\n\t.get_functions_count = wmt_pmx_get_functions_count,\n\t.get_function_name = wmt_pmx_get_function_name,\n\t.get_function_groups = wmt_pmx_get_function_groups,\n\t.set_mux = wmt_pmx_set_mux,\n\t.gpio_disable_free = wmt_pmx_gpio_disable_free,\n\t.gpio_set_direction = wmt_pmx_gpio_set_direction,\n};\n\nstatic int wmt_get_groups_count(struct pinctrl_dev *pctldev)\n{\n\tstruct wmt_pinctrl_data *data = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn data->ngroups;\n}\n\nstatic const char *wmt_get_group_name(struct pinctrl_dev *pctldev,\n\t\t\t\t      unsigned selector)\n{\n\tstruct wmt_pinctrl_data *data = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn data->groups[selector];\n}\n\nstatic int wmt_get_group_pins(struct pinctrl_dev *pctldev,\n\t\t\t      unsigned selector,\n\t\t\t      const unsigned **pins,\n\t\t\t      unsigned *num_pins)\n{\n\tstruct wmt_pinctrl_data *data = pinctrl_dev_get_drvdata(pctldev);\n\n\t*pins = &data->pins[selector].number;\n\t*num_pins = 1;\n\n\treturn 0;\n}\n\nstatic int wmt_pctl_find_group_by_pin(struct wmt_pinctrl_data *data, u32 pin)\n{\n\tint i;\n\n\tfor (i = 0; i < data->npins; i++) {\n\t\tif (data->pins[i].number == pin)\n\t\t\treturn i;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int wmt_pctl_dt_node_to_map_func(struct wmt_pinctrl_data *data,\n\t\t\t\t\tstruct device_node *np,\n\t\t\t\t\tu32 pin, u32 fnum,\n\t\t\t\t\tstruct pinctrl_map **maps)\n{\n\tint group;\n\tstruct pinctrl_map *map = *maps;\n\n\tif (fnum >= ARRAY_SIZE(wmt_functions)) {\n\t\tdev_err(data->dev, \"invalid wm,function %d\\n\", fnum);\n\t\treturn -EINVAL;\n\t}\n\n\tgroup = wmt_pctl_find_group_by_pin(data, pin);\n\tif (group < 0) {\n\t\tdev_err(data->dev, \"unable to match pin %d to group\\n\", pin);\n\t\treturn group;\n\t}\n\n\tmap->type = PIN_MAP_TYPE_MUX_GROUP;\n\tmap->data.mux.group = data->groups[group];\n\tmap->data.mux.function = wmt_functions[fnum];\n\t(*maps)++;\n\n\treturn 0;\n}\n\nstatic int wmt_pctl_dt_node_to_map_pull(struct wmt_pinctrl_data *data,\n\t\t\t\t\tstruct device_node *np,\n\t\t\t\t\tu32 pin, u32 pull,\n\t\t\t\t\tstruct pinctrl_map **maps)\n{\n\tint group;\n\tunsigned long *configs;\n\tstruct pinctrl_map *map = *maps;\n\n\tif (pull > 2) {\n\t\tdev_err(data->dev, \"invalid wm,pull %d\\n\", pull);\n\t\treturn -EINVAL;\n\t}\n\n\tgroup = wmt_pctl_find_group_by_pin(data, pin);\n\tif (group < 0) {\n\t\tdev_err(data->dev, \"unable to match pin %d to group\\n\", pin);\n\t\treturn group;\n\t}\n\n\tconfigs = kzalloc(sizeof(*configs), GFP_KERNEL);\n\tif (!configs)\n\t\treturn -ENOMEM;\n\n\tswitch (pull) {\n\tcase 0:\n\t\tconfigs[0] = PIN_CONFIG_BIAS_DISABLE;\n\t\tbreak;\n\tcase 1:\n\t\tconfigs[0] = PIN_CONFIG_BIAS_PULL_DOWN;\n\t\tbreak;\n\tcase 2:\n\t\tconfigs[0] = PIN_CONFIG_BIAS_PULL_UP;\n\t\tbreak;\n\tdefault:\n\t\tconfigs[0] = PIN_CONFIG_BIAS_DISABLE;\n\t\tdev_err(data->dev, \"invalid pull state %d - disabling\\n\", pull);\n\t}\n\n\tmap->type = PIN_MAP_TYPE_CONFIGS_PIN;\n\tmap->data.configs.group_or_pin = data->groups[group];\n\tmap->data.configs.configs = configs;\n\tmap->data.configs.num_configs = 1;\n\t(*maps)++;\n\n\treturn 0;\n}\n\nstatic void wmt_pctl_dt_free_map(struct pinctrl_dev *pctldev,\n\t\t\t\t struct pinctrl_map *maps,\n\t\t\t\t unsigned num_maps)\n{\n\tint i;\n\n\tfor (i = 0; i < num_maps; i++)\n\t\tif (maps[i].type == PIN_MAP_TYPE_CONFIGS_PIN)\n\t\t\tkfree(maps[i].data.configs.configs);\n\n\tkfree(maps);\n}\n\nstatic int wmt_pctl_dt_node_to_map(struct pinctrl_dev *pctldev,\n\t\t\t\t   struct device_node *np,\n\t\t\t\t   struct pinctrl_map **map,\n\t\t\t\t   unsigned *num_maps)\n{\n\tstruct pinctrl_map *maps, *cur_map;\n\tstruct property *pins, *funcs, *pulls;\n\tu32 pin, func, pull;\n\tint num_pins, num_funcs, num_pulls, maps_per_pin;\n\tint i, err;\n\tstruct wmt_pinctrl_data *data = pinctrl_dev_get_drvdata(pctldev);\n\n\tpins = of_find_property(np, \"wm,pins\", NULL);\n\tif (!pins) {\n\t\tdev_err(data->dev, \"missing wmt,pins property\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfuncs = of_find_property(np, \"wm,function\", NULL);\n\tpulls = of_find_property(np, \"wm,pull\", NULL);\n\n\tif (!funcs && !pulls) {\n\t\tdev_err(data->dev, \"neither wm,function nor wm,pull specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tnum_pins = pins->length / sizeof(u32);\n\tnum_funcs = funcs ? (funcs->length / sizeof(u32)) : 0;\n\tnum_pulls = pulls ? (pulls->length / sizeof(u32)) : 0;\n\n\tif (num_funcs > 1 && num_funcs != num_pins) {\n\t\tdev_err(data->dev, \"wm,function must have 1 or %d entries\\n\",\n\t\t\tnum_pins);\n\t\treturn -EINVAL;\n\t}\n\n\tif (num_pulls > 1 && num_pulls != num_pins) {\n\t\tdev_err(data->dev, \"wm,pull must have 1 or %d entries\\n\",\n\t\t\tnum_pins);\n\t\treturn -EINVAL;\n\t}\n\n\tmaps_per_pin = 0;\n\tif (num_funcs)\n\t\tmaps_per_pin++;\n\tif (num_pulls)\n\t\tmaps_per_pin++;\n\n\tcur_map = maps = kcalloc(num_pins * maps_per_pin, sizeof(*maps),\n\t\t\t\t GFP_KERNEL);\n\tif (!maps)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < num_pins; i++) {\n\t\terr = of_property_read_u32_index(np, \"wm,pins\", i, &pin);\n\t\tif (err)\n\t\t\tgoto fail;\n\n\t\tif (pin >= (data->nbanks * 32)) {\n\t\t\tdev_err(data->dev, \"invalid wm,pins value\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (num_funcs) {\n\t\t\terr = of_property_read_u32_index(np, \"wm,function\",\n\t\t\t\t\t\t(num_funcs > 1 ? i : 0), &func);\n\t\t\tif (err)\n\t\t\t\tgoto fail;\n\n\t\t\terr = wmt_pctl_dt_node_to_map_func(data, np, pin, func,\n\t\t\t\t\t\t\t   &cur_map);\n\t\t\tif (err)\n\t\t\t\tgoto fail;\n\t\t}\n\n\t\tif (num_pulls) {\n\t\t\terr = of_property_read_u32_index(np, \"wm,pull\",\n\t\t\t\t\t\t(num_pulls > 1 ? i : 0), &pull);\n\t\t\tif (err)\n\t\t\t\tgoto fail;\n\n\t\t\terr = wmt_pctl_dt_node_to_map_pull(data, np, pin, pull,\n\t\t\t\t\t\t\t   &cur_map);\n\t\t\tif (err)\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\t*map = maps;\n\t*num_maps = num_pins * maps_per_pin;\n\treturn 0;\n\n \nfail:\n\twmt_pctl_dt_free_map(pctldev, maps, num_pins * maps_per_pin);\n\treturn err;\n}\n\nstatic const struct pinctrl_ops wmt_pctl_ops = {\n\t.get_groups_count = wmt_get_groups_count,\n\t.get_group_name\t= wmt_get_group_name,\n\t.get_group_pins\t= wmt_get_group_pins,\n\t.dt_node_to_map = wmt_pctl_dt_node_to_map,\n\t.dt_free_map = wmt_pctl_dt_free_map,\n};\n\nstatic int wmt_pinconf_get(struct pinctrl_dev *pctldev, unsigned pin,\n\t\t\t   unsigned long *config)\n{\n\treturn -ENOTSUPP;\n}\n\nstatic int wmt_pinconf_set(struct pinctrl_dev *pctldev, unsigned pin,\n\t\t\t   unsigned long *configs, unsigned num_configs)\n{\n\tstruct wmt_pinctrl_data *data = pinctrl_dev_get_drvdata(pctldev);\n\tenum pin_config_param param;\n\tu32 arg;\n\tu32 bank = WMT_BANK_FROM_PIN(pin);\n\tu32 bit = WMT_BIT_FROM_PIN(pin);\n\tu32 reg_pull_en = data->banks[bank].reg_pull_en;\n\tu32 reg_pull_cfg = data->banks[bank].reg_pull_cfg;\n\tint i;\n\n\tif ((reg_pull_en == NO_REG) || (reg_pull_cfg == NO_REG)) {\n\t\tdev_err(data->dev, \"bias functions not supported on pin %d\\n\",\n\t\t\tpin);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < num_configs; i++) {\n\t\tparam = pinconf_to_config_param(configs[i]);\n\t\targ = pinconf_to_config_argument(configs[i]);\n\n\t\tif ((param == PIN_CONFIG_BIAS_PULL_DOWN) ||\n\t\t    (param == PIN_CONFIG_BIAS_PULL_UP)) {\n\t\t\tif (arg == 0)\n\t\t\t\tparam = PIN_CONFIG_BIAS_DISABLE;\n\t\t}\n\n\t\tswitch (param) {\n\t\tcase PIN_CONFIG_BIAS_DISABLE:\n\t\t\twmt_clearbits(data, reg_pull_en, BIT(bit));\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\t\twmt_clearbits(data, reg_pull_cfg, BIT(bit));\n\t\t\twmt_setbits(data, reg_pull_en, BIT(bit));\n\t\t\tbreak;\n\t\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\t\twmt_setbits(data, reg_pull_cfg, BIT(bit));\n\t\t\twmt_setbits(data, reg_pull_en, BIT(bit));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(data->dev, \"unknown pinconf param\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}  \n\n\treturn 0;\n}\n\nstatic const struct pinconf_ops wmt_pinconf_ops = {\n\t.pin_config_get = wmt_pinconf_get,\n\t.pin_config_set = wmt_pinconf_set,\n};\n\nstatic struct pinctrl_desc wmt_desc = {\n\t.owner = THIS_MODULE,\n\t.name = \"pinctrl-wmt\",\n\t.pctlops = &wmt_pctl_ops,\n\t.pmxops = &wmt_pinmux_ops,\n\t.confops = &wmt_pinconf_ops,\n};\n\nstatic int wmt_gpio_get_direction(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct wmt_pinctrl_data *data = gpiochip_get_data(chip);\n\tu32 bank = WMT_BANK_FROM_PIN(offset);\n\tu32 bit = WMT_BIT_FROM_PIN(offset);\n\tu32 reg_dir = data->banks[bank].reg_dir;\n\tu32 val;\n\n\tval = readl_relaxed(data->base + reg_dir);\n\tif (val & BIT(bit))\n\t\treturn GPIO_LINE_DIRECTION_OUT;\n\n\treturn GPIO_LINE_DIRECTION_IN;\n}\n\nstatic int wmt_gpio_get_value(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct wmt_pinctrl_data *data = gpiochip_get_data(chip);\n\tu32 bank = WMT_BANK_FROM_PIN(offset);\n\tu32 bit = WMT_BIT_FROM_PIN(offset);\n\tu32 reg_data_in = data->banks[bank].reg_data_in;\n\n\tif (reg_data_in == NO_REG) {\n\t\tdev_err(data->dev, \"no data in register defined\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn !!(readl_relaxed(data->base + reg_data_in) & BIT(bit));\n}\n\nstatic void wmt_gpio_set_value(struct gpio_chip *chip, unsigned offset,\n\t\t\t       int val)\n{\n\tstruct wmt_pinctrl_data *data = gpiochip_get_data(chip);\n\tu32 bank = WMT_BANK_FROM_PIN(offset);\n\tu32 bit = WMT_BIT_FROM_PIN(offset);\n\tu32 reg_data_out = data->banks[bank].reg_data_out;\n\n\tif (reg_data_out == NO_REG) {\n\t\tdev_err(data->dev, \"no data out register defined\\n\");\n\t\treturn;\n\t}\n\n\tif (val)\n\t\twmt_setbits(data, reg_data_out, BIT(bit));\n\telse\n\t\twmt_clearbits(data, reg_data_out, BIT(bit));\n}\n\nstatic int wmt_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\n{\n\treturn pinctrl_gpio_direction_input(chip->base + offset);\n}\n\nstatic int wmt_gpio_direction_output(struct gpio_chip *chip, unsigned offset,\n\t\t\t\t     int value)\n{\n\twmt_gpio_set_value(chip, offset, value);\n\treturn pinctrl_gpio_direction_output(chip->base + offset);\n}\n\nstatic const struct gpio_chip wmt_gpio_chip = {\n\t.label = \"gpio-wmt\",\n\t.owner = THIS_MODULE,\n\t.request = gpiochip_generic_request,\n\t.free = gpiochip_generic_free,\n\t.get_direction = wmt_gpio_get_direction,\n\t.direction_input = wmt_gpio_direction_input,\n\t.direction_output = wmt_gpio_direction_output,\n\t.get = wmt_gpio_get_value,\n\t.set = wmt_gpio_set_value,\n\t.can_sleep = false,\n};\n\nint wmt_pinctrl_probe(struct platform_device *pdev,\n\t\t      struct wmt_pinctrl_data *data)\n{\n\tint err;\n\n\tdata->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(data->base))\n\t\treturn PTR_ERR(data->base);\n\n\twmt_desc.pins = data->pins;\n\twmt_desc.npins = data->npins;\n\n\tdata->gpio_chip = wmt_gpio_chip;\n\tdata->gpio_chip.parent = &pdev->dev;\n\tdata->gpio_chip.ngpio = data->nbanks * 32;\n\n\tplatform_set_drvdata(pdev, data);\n\n\tdata->dev = &pdev->dev;\n\n\tdata->pctl_dev = devm_pinctrl_register(&pdev->dev, &wmt_desc, data);\n\tif (IS_ERR(data->pctl_dev)) {\n\t\tdev_err(&pdev->dev, \"Failed to register pinctrl\\n\");\n\t\treturn PTR_ERR(data->pctl_dev);\n\t}\n\n\terr = gpiochip_add_data(&data->gpio_chip, data);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"could not add GPIO chip\\n\");\n\t\treturn err;\n\t}\n\n\terr = gpiochip_add_pin_range(&data->gpio_chip, dev_name(data->dev),\n\t\t\t\t     0, 0, data->nbanks * 32);\n\tif (err)\n\t\tgoto fail_range;\n\n\tdev_info(&pdev->dev, \"Pin controller initialized\\n\");\n\n\treturn 0;\n\nfail_range:\n\tgpiochip_remove(&data->gpio_chip);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}