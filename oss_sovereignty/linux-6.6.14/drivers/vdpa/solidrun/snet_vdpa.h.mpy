{
  "module_name": "snet_vdpa.h",
  "hash_id": "931ae8173c4fd4c58195d2cf955f48bf45391df747bc595aebfe490c2f8c364b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/vdpa/solidrun/snet_vdpa.h",
  "human_readable_source": " \n \n#ifndef _SNET_VDPA_H_\n#define _SNET_VDPA_H_\n\n#include <linux/vdpa.h>\n#include <linux/pci.h>\n\n#define SNET_NAME_SIZE 256\n\n#define SNET_ERR(pdev, fmt, ...) dev_err(&(pdev)->dev, \"%s\"fmt, \"snet_vdpa: \", ##__VA_ARGS__)\n#define SNET_WARN(pdev, fmt, ...) dev_warn(&(pdev)->dev, \"%s\"fmt, \"snet_vdpa: \", ##__VA_ARGS__)\n#define SNET_INFO(pdev, fmt, ...) dev_info(&(pdev)->dev, \"%s\"fmt, \"snet_vdpa: \", ##__VA_ARGS__)\n#define SNET_DBG(pdev, fmt, ...) dev_dbg(&(pdev)->dev, \"%s\"fmt, \"snet_vdpa: \", ##__VA_ARGS__)\n#define SNET_HAS_FEATURE(s, f) ((s)->negotiated_features & BIT_ULL(f))\n \n#define SNET_CFG_VER(snet, ver) ((snet)->psnet->negotiated_cfg_ver >= (ver))\n\n \nstruct snet_vq {\n\t \n\tstruct vdpa_callback cb;\n\t \n\tstruct vdpa_vq_state vq_state;\n\t \n\tu64 desc_area;\n\t \n\tu64 device_area;\n\t \n\tu64 driver_area;\n\t \n\tu32 num;\n\t \n\tu32 sid;\n\t \n\tbool ready;\n\t \n\tu32 irq;\n\t \n\tu32 irq_idx;\n\t \n\tchar irq_name[SNET_NAME_SIZE];\n\t \n\tvoid __iomem *kick_ptr;\n};\n\nstruct snet {\n\t \n\tstruct vdpa_device vdpa;\n\t \n\tstruct vdpa_callback cb;\n\t \n\tstruct mutex ctrl_lock;\n\t \n\tspinlock_t ctrl_spinlock;\n\t \n\tstruct snet_vq **vqs;\n\t \n\tu64 negotiated_features;\n\t \n\tu32 sid;\n\t \n\tu8 status;\n\t \n\tbool dpu_ready;\n\t \n\tu32 cfg_irq;\n\t \n\tu32 cfg_irq_idx;\n\t \n\tchar cfg_irq_name[SNET_NAME_SIZE];\n\t \n\tvoid __iomem *bar;\n\t \n\tstruct pci_dev *pdev;\n\t \n\tstruct psnet *psnet;\n\t \n\tstruct snet_dev_cfg *cfg;\n};\n\nstruct snet_dev_cfg {\n\t \n\tu32 virtio_id;\n\t \n\tu32 vq_num;\n\t \n\tu32 vq_size;\n\t \n\tu32 vfid;\n\t \n\tu64 features;\n\t \n\tu32 rsvd[6];\n\t \n\tu32 cfg_size;\n\t \n\tvoid __iomem *virtio_cfg;\n} __packed;\n\nstruct snet_cfg {\n\t \n\tu32 key;\n\t \n\tu32 cfg_size;\n\t \n\tu32 cfg_ver;\n\t \n\tu32 vf_num;\n\t \n\tu32 vf_bar;\n\t \n\tu32 host_cfg_off;\n\t \n\tu32 max_size_host_cfg;\n\t \n\tu32 virtio_cfg_off;\n\t \n\tu32 kick_off;\n\t \n\tu32 hwmon_off;\n\t \n\tu32 ctrl_off;\n\t \n\tu32 flags;\n\t \n\tu32 rsvd[6];\n\t \n\tu32 devices_num;\n\t \n\tstruct snet_dev_cfg **devs;\n} __packed;\n\n \nstruct psnet {\n\t \n\tvoid __iomem *bars[PCI_STD_NUM_BARS];\n\t \n\tu32 negotiated_cfg_ver;\n\t \n\tu32 next_irq;\n\t \n\tu8 barno;\n\t \n\tspinlock_t lock;\n\t \n\tstruct snet_cfg cfg;\n\t \n\tchar hwmon_name[SNET_NAME_SIZE];\n};\n\nenum snet_cfg_flags {\n\t \n\tSNET_CFG_FLAG_HWMON = BIT(0),\n\t \n\tSNET_CFG_FLAG_IRQ_PF = BIT(1),\n};\n\n#define PSNET_FLAG_ON(p, f)\t((p)->cfg.flags & (f))\n\nstatic inline u32 psnet_read32(struct psnet *psnet, u32 off)\n{\n\treturn ioread32(psnet->bars[psnet->barno] + off);\n}\n\nstatic inline u32 snet_read32(struct snet *snet, u32 off)\n{\n\treturn ioread32(snet->bar + off);\n}\n\nstatic inline void snet_write32(struct snet *snet, u32 off, u32 val)\n{\n\tiowrite32(val, snet->bar + off);\n}\n\nstatic inline u64 psnet_read64(struct psnet *psnet, u32 off)\n{\n\tu64 val;\n\t \n\tval = (u64)psnet_read32(psnet, off);\n\tval |= ((u64)psnet_read32(psnet, off + 4) << 32);\n\treturn val;\n}\n\nstatic inline void snet_write64(struct snet *snet, u32 off, u64 val)\n{\n\t \n\tsnet_write32(snet, off, (u32)val);\n\tsnet_write32(snet, off + 4, (u32)(val >> 32));\n}\n\n#if IS_ENABLED(CONFIG_HWMON)\nvoid psnet_create_hwmon(struct pci_dev *pdev);\n#endif\n\nvoid snet_ctrl_clear(struct snet *snet);\nint snet_destroy_dev(struct snet *snet);\nint snet_read_vq_state(struct snet *snet, u16 idx, struct vdpa_vq_state *state);\nint snet_suspend_dev(struct snet *snet);\nint snet_resume_dev(struct snet *snet);\n\n#endif \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}