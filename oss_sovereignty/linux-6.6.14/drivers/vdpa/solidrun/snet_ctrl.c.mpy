{
  "module_name": "snet_ctrl.c",
  "hash_id": "5961f7f888edb7aafbb0b932f954a5b989d426d6a2810383f1ce717640208d14",
  "original_prompt": "Ingested from linux-6.6.14/drivers/vdpa/solidrun/snet_ctrl.c",
  "human_readable_source": "\n \n\n#include <linux/iopoll.h>\n\n#include \"snet_vdpa.h\"\n\nenum snet_ctrl_opcodes {\n\tSNET_CTRL_OP_DESTROY = 1,\n\tSNET_CTRL_OP_READ_VQ_STATE,\n\tSNET_CTRL_OP_SUSPEND,\n\tSNET_CTRL_OP_RESUME,\n};\n\n#define SNET_CTRL_TIMEOUT\t        2000000\n\n#define SNET_CTRL_DATA_SIZE_MASK\t0x0000FFFF\n#define SNET_CTRL_IN_PROCESS_MASK\t0x00010000\n#define SNET_CTRL_CHUNK_RDY_MASK\t0x00020000\n#define SNET_CTRL_ERROR_MASK\t\t0x0FFC0000\n\n#define SNET_VAL_TO_ERR(val)\t\t(-(((val) & SNET_CTRL_ERROR_MASK) >> 18))\n#define SNET_EMPTY_CTRL(val)\t\t(((val) & SNET_CTRL_ERROR_MASK) || \\\n\t\t\t\t\t\t!((val) & SNET_CTRL_IN_PROCESS_MASK))\n#define SNET_DATA_READY(val)\t\t((val) & (SNET_CTRL_ERROR_MASK | SNET_CTRL_CHUNK_RDY_MASK))\n\n \nstruct snet_ctrl_reg_ctrl {\n\t \n\tu16 data_size;\n\t \n\tu16 in_process:1;\n\t \n\tu16 chunk_ready:1;\n\t \n\tu16 error:10;\n\t \n\tu16 rsvd:4;\n};\n\n \nstruct snet_ctrl_reg_op {\n\tu16 opcode;\n\t \n\tu16 vq_idx;\n};\n\nstruct snet_ctrl_regs {\n\tstruct snet_ctrl_reg_op op;\n\tstruct snet_ctrl_reg_ctrl ctrl;\n\tu32 rsvd;\n\tu32 data[];\n};\n\nstatic struct snet_ctrl_regs __iomem *snet_get_ctrl(struct snet *snet)\n{\n\treturn snet->bar + snet->psnet->cfg.ctrl_off;\n}\n\nstatic int snet_wait_for_empty_ctrl(struct snet_ctrl_regs __iomem *regs)\n{\n\tu32 val;\n\n\treturn readx_poll_timeout(ioread32, &regs->ctrl, val, SNET_EMPTY_CTRL(val), 10,\n\t\t\t\t  SNET_CTRL_TIMEOUT);\n}\n\nstatic int snet_wait_for_empty_op(struct snet_ctrl_regs __iomem *regs)\n{\n\tu32 val;\n\n\treturn readx_poll_timeout(ioread32, &regs->op, val, !val, 10, SNET_CTRL_TIMEOUT);\n}\n\nstatic int snet_wait_for_data(struct snet_ctrl_regs __iomem *regs)\n{\n\tu32 val;\n\n\treturn readx_poll_timeout(ioread32, &regs->ctrl, val, SNET_DATA_READY(val), 10,\n\t\t\t\t  SNET_CTRL_TIMEOUT);\n}\n\nstatic u32 snet_read32_word(struct snet_ctrl_regs __iomem *ctrl_regs, u16 word_idx)\n{\n\treturn ioread32(&ctrl_regs->data[word_idx]);\n}\n\nstatic u32 snet_read_ctrl(struct snet_ctrl_regs __iomem *ctrl_regs)\n{\n\treturn ioread32(&ctrl_regs->ctrl);\n}\n\nstatic void snet_write_ctrl(struct snet_ctrl_regs __iomem *ctrl_regs, u32 val)\n{\n\tiowrite32(val, &ctrl_regs->ctrl);\n}\n\nstatic void snet_write_op(struct snet_ctrl_regs __iomem *ctrl_regs, u32 val)\n{\n\tiowrite32(val, &ctrl_regs->op);\n}\n\nstatic int snet_wait_for_dpu_completion(struct snet_ctrl_regs __iomem *ctrl_regs)\n{\n\t \n\treturn snet_wait_for_empty_op(ctrl_regs);\n}\n\n \nstatic int snet_ctrl_read_from_dpu(struct snet *snet, u16 opcode, u16 vq_idx, void *buffer,\n\t\t\t\t   u32 buf_size)\n{\n\tstruct pci_dev *pdev = snet->pdev;\n\tstruct snet_ctrl_regs __iomem *regs = snet_get_ctrl(snet);\n\tu32 *bfr_ptr = (u32 *)buffer;\n\tu32 val;\n\tu16 buf_words;\n\tint ret;\n\tu16 words, i, tot_words = 0;\n\n\t \n\tif (!SNET_CFG_VER(snet, 2))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!IS_ALIGNED(buf_size, 4))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&snet->ctrl_lock);\n\n\tbuf_words = buf_size / 4;\n\n\t \n\tret = snet_wait_for_empty_ctrl(regs);\n\tif (ret) {\n\t\tSNET_WARN(pdev, \"Timeout waiting for previous control data to be consumed\\n\");\n\t\tgoto exit;\n\t}\n\n\t \n\tspin_lock(&snet->ctrl_spinlock);\n\n\tsnet_write_ctrl(regs, buf_words);\n\tsnet_write_op(regs, opcode | (vq_idx << 16));\n\n\tspin_unlock(&snet->ctrl_spinlock);\n\n\twhile (buf_words != tot_words) {\n\t\tret = snet_wait_for_data(regs);\n\t\tif (ret) {\n\t\t\tSNET_WARN(pdev, \"Timeout waiting for control data\\n\");\n\t\t\tgoto exit;\n\t\t}\n\n\t\tval = snet_read_ctrl(regs);\n\n\t\t \n\t\tif (val & SNET_CTRL_ERROR_MASK) {\n\t\t\tret = SNET_VAL_TO_ERR(val);\n\t\t\tSNET_WARN(pdev, \"Error while reading control data from DPU, err %d\\n\", ret);\n\t\t\tgoto exit;\n\t\t}\n\n\t\twords = min_t(u16, val & SNET_CTRL_DATA_SIZE_MASK, buf_words - tot_words);\n\n\t\tfor (i = 0; i < words; i++) {\n\t\t\t*bfr_ptr = snet_read32_word(regs, i);\n\t\t\tbfr_ptr++;\n\t\t}\n\n\t\ttot_words += words;\n\n\t\t \n\t\tif (!(val & SNET_CTRL_IN_PROCESS_MASK))\n\t\t\tbreak;\n\n\t\t \n\t\tval &= ~SNET_CTRL_CHUNK_RDY_MASK;\n\t\tsnet_write_ctrl(regs, val);\n\t}\n\n\tret = snet_wait_for_dpu_completion(regs);\n\tif (ret)\n\t\tSNET_WARN(pdev, \"Timeout waiting for the DPU to complete a control command\\n\");\n\nexit:\n\tmutex_unlock(&snet->ctrl_lock);\n\treturn ret;\n}\n\n \nstatic int snet_send_ctrl_msg_old(struct snet *snet, u32 opcode)\n{\n\tstruct pci_dev *pdev = snet->pdev;\n\tstruct snet_ctrl_regs __iomem *regs = snet_get_ctrl(snet);\n\tint ret;\n\n\tmutex_lock(&snet->ctrl_lock);\n\n\t \n\tret = snet_wait_for_empty_op(regs);\n\tif (ret) {\n\t\tSNET_WARN(pdev, \"Timeout waiting for previous control message to be ACKed\\n\");\n\t\tgoto exit;\n\t}\n\n\t \n\tsnet_write_op(regs, opcode);\n\n\t \n\tret = snet_wait_for_empty_op(regs);\n\tif (ret)\n\t\tSNET_WARN(pdev, \"Timeout waiting for a control message to be ACKed\\n\");\n\nexit:\n\tmutex_unlock(&snet->ctrl_lock);\n\treturn ret;\n}\n\n \nstatic int snet_send_ctrl_msg(struct snet *snet, u16 opcode, u16 vq_idx)\n{\n\tstruct pci_dev *pdev = snet->pdev;\n\tstruct snet_ctrl_regs __iomem *regs = snet_get_ctrl(snet);\n\tu32 val;\n\tint ret;\n\n\t \n\tif (!SNET_CFG_VER(snet, 2))\n\t\treturn snet_send_ctrl_msg_old(snet, opcode);\n\n\tmutex_lock(&snet->ctrl_lock);\n\n\t \n\tret = snet_wait_for_empty_ctrl(regs);\n\tif (ret) {\n\t\tSNET_WARN(pdev, \"Timeout waiting for previous control data to be consumed\\n\");\n\t\tgoto exit;\n\t}\n\n\t \n\tspin_lock(&snet->ctrl_spinlock);\n\n\tsnet_write_ctrl(regs, 0);\n\tsnet_write_op(regs, opcode | (vq_idx << 16));\n\n\tspin_unlock(&snet->ctrl_spinlock);\n\n\t \n\tret = snet_wait_for_data(regs);\n\tif (ret) {\n\t\tSNET_WARN(pdev, \"Timeout waiting for control message to be ACKed\\n\");\n\t\tgoto exit;\n\t}\n\n\t \n\tval = snet_read_ctrl(regs);\n\tret = SNET_VAL_TO_ERR(val);\n\n\t \n\tval &= ~SNET_CTRL_CHUNK_RDY_MASK;\n\tsnet_write_ctrl(regs, val);\n\n\tret = snet_wait_for_dpu_completion(regs);\n\tif (ret)\n\t\tSNET_WARN(pdev, \"Timeout waiting for DPU to complete a control command, err %d\\n\",\n\t\t\t  ret);\n\nexit:\n\tmutex_unlock(&snet->ctrl_lock);\n\treturn ret;\n}\n\nvoid snet_ctrl_clear(struct snet *snet)\n{\n\tstruct snet_ctrl_regs __iomem *regs = snet_get_ctrl(snet);\n\n\tsnet_write_op(regs, 0);\n}\n\nint snet_destroy_dev(struct snet *snet)\n{\n\treturn snet_send_ctrl_msg(snet, SNET_CTRL_OP_DESTROY, 0);\n}\n\nint snet_read_vq_state(struct snet *snet, u16 idx, struct vdpa_vq_state *state)\n{\n\treturn snet_ctrl_read_from_dpu(snet, SNET_CTRL_OP_READ_VQ_STATE, idx, state,\n\t\t\t\t       sizeof(*state));\n}\n\nint snet_suspend_dev(struct snet *snet)\n{\n\treturn snet_send_ctrl_msg(snet, SNET_CTRL_OP_SUSPEND, 0);\n}\n\nint snet_resume_dev(struct snet *snet)\n{\n\treturn snet_send_ctrl_msg(snet, SNET_CTRL_OP_RESUME, 0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}