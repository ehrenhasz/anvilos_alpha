{
  "module_name": "snet_main.c",
  "hash_id": "ee9625973fe8b5ed17a392476e5cee0526b263814c7200766a06a46ffae01163",
  "original_prompt": "Ingested from linux-6.6.14/drivers/vdpa/solidrun/snet_main.c",
  "human_readable_source": "\n \n#include <linux/iopoll.h>\n\n#include \"snet_vdpa.h\"\n\n \n#define SNET_DEVICE_ID          0x1000\n \n#define SNET_SIGNATURE          0xD0D06363\n \n#define SNET_CFG_VERSION        0x2\n \n#define SNET_QUEUE_ALIGNMENT    PAGE_SIZE\n \n#define SNET_KICK_VAL           0x1\n#define SNET_CONFIG_OFF         0x0\n \n#define SNET_DETECT_TIMEOUT\t5000000\n \n#define SNET_READ_CFG_TIMEOUT\t3000000\n \n#define SNET_GENERAL_CFG_LEN\t36\n#define SNET_GENERAL_CFG_VQ_LEN\t40\n\nstatic struct snet *vdpa_to_snet(struct vdpa_device *vdpa)\n{\n\treturn container_of(vdpa, struct snet, vdpa);\n}\n\nstatic irqreturn_t snet_cfg_irq_hndlr(int irq, void *data)\n{\n\tstruct snet *snet = data;\n\t \n\tif (likely(snet->cb.callback))\n\t\treturn snet->cb.callback(snet->cb.private);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t snet_vq_irq_hndlr(int irq, void *data)\n{\n\tstruct snet_vq *vq = data;\n\t \n\tif (likely(vq->cb.callback))\n\t\treturn vq->cb.callback(vq->cb.private);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void snet_free_irqs(struct snet *snet)\n{\n\tstruct psnet *psnet = snet->psnet;\n\tstruct pci_dev *pdev;\n\tu32 i;\n\n\t \n\tif (PSNET_FLAG_ON(psnet, SNET_CFG_FLAG_IRQ_PF))\n\t\tpdev = snet->pdev->physfn;\n\telse\n\t\tpdev = snet->pdev;\n\n\t \n\tif (snet->cfg_irq != -1) {\n\t\tdevm_free_irq(&pdev->dev, snet->cfg_irq, snet);\n\t\tsnet->cfg_irq = -1;\n\t}\n\t \n\tfor (i = 0; i < snet->cfg->vq_num; i++) {\n\t\tif (snet->vqs[i] && snet->vqs[i]->irq != -1) {\n\t\t\tdevm_free_irq(&pdev->dev, snet->vqs[i]->irq, snet->vqs[i]);\n\t\t\tsnet->vqs[i]->irq = -1;\n\t\t}\n\t}\n\n\t \n}\n\nstatic int snet_set_vq_address(struct vdpa_device *vdev, u16 idx, u64 desc_area,\n\t\t\t       u64 driver_area, u64 device_area)\n{\n\tstruct snet *snet = vdpa_to_snet(vdev);\n\t \n\tsnet->vqs[idx]->desc_area = desc_area;\n\tsnet->vqs[idx]->driver_area = driver_area;\n\tsnet->vqs[idx]->device_area = device_area;\n\n\treturn 0;\n}\n\nstatic void snet_set_vq_num(struct vdpa_device *vdev, u16 idx, u32 num)\n{\n\tstruct snet *snet = vdpa_to_snet(vdev);\n\t \n\tsnet->vqs[idx]->num = num;\n}\n\nstatic void snet_kick_vq(struct vdpa_device *vdev, u16 idx)\n{\n\tstruct snet *snet = vdpa_to_snet(vdev);\n\t \n\tif (unlikely(!snet->vqs[idx]->ready))\n\t\treturn;\n\n\tiowrite32(SNET_KICK_VAL, snet->vqs[idx]->kick_ptr);\n}\n\nstatic void snet_kick_vq_with_data(struct vdpa_device *vdev, u32 data)\n{\n\tstruct snet *snet = vdpa_to_snet(vdev);\n\tu16 idx = data & 0xFFFF;\n\n\t \n\tif (unlikely(!snet->vqs[idx]->ready))\n\t\treturn;\n\n\tiowrite32((data & 0xFFFF0000) | SNET_KICK_VAL, snet->vqs[idx]->kick_ptr);\n}\n\nstatic void snet_set_vq_cb(struct vdpa_device *vdev, u16 idx, struct vdpa_callback *cb)\n{\n\tstruct snet *snet = vdpa_to_snet(vdev);\n\n\tsnet->vqs[idx]->cb.callback = cb->callback;\n\tsnet->vqs[idx]->cb.private = cb->private;\n}\n\nstatic void snet_set_vq_ready(struct vdpa_device *vdev, u16 idx, bool ready)\n{\n\tstruct snet *snet = vdpa_to_snet(vdev);\n\n\tsnet->vqs[idx]->ready = ready;\n}\n\nstatic bool snet_get_vq_ready(struct vdpa_device *vdev, u16 idx)\n{\n\tstruct snet *snet = vdpa_to_snet(vdev);\n\n\treturn snet->vqs[idx]->ready;\n}\n\nstatic bool snet_vq_state_is_initial(struct snet *snet, const struct vdpa_vq_state *state)\n{\n\tif (SNET_HAS_FEATURE(snet, VIRTIO_F_RING_PACKED)) {\n\t\tconst struct vdpa_vq_state_packed *p = &state->packed;\n\n\t\tif (p->last_avail_counter == 1 && p->last_used_counter == 1 &&\n\t\t    p->last_avail_idx == 0 && p->last_used_idx == 0)\n\t\t\treturn true;\n\t} else {\n\t\tconst struct vdpa_vq_state_split *s = &state->split;\n\n\t\tif (s->avail_index == 0)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int snet_set_vq_state(struct vdpa_device *vdev, u16 idx, const struct vdpa_vq_state *state)\n{\n\tstruct snet *snet = vdpa_to_snet(vdev);\n\n\t \n\tif (SNET_CFG_VER(snet, 2)) {\n\t\tmemcpy(&snet->vqs[idx]->vq_state, state, sizeof(*state));\n\t\treturn 0;\n\t}\n\n\t \n\tif (snet_vq_state_is_initial(snet, state))\n\t\treturn 0;\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int snet_get_vq_state(struct vdpa_device *vdev, u16 idx, struct vdpa_vq_state *state)\n{\n\tstruct snet *snet = vdpa_to_snet(vdev);\n\n\treturn snet_read_vq_state(snet, idx, state);\n}\n\nstatic int snet_get_vq_irq(struct vdpa_device *vdev, u16 idx)\n{\n\tstruct snet *snet = vdpa_to_snet(vdev);\n\n\treturn snet->vqs[idx]->irq;\n}\n\nstatic u32 snet_get_vq_align(struct vdpa_device *vdev)\n{\n\treturn (u32)SNET_QUEUE_ALIGNMENT;\n}\n\nstatic int snet_reset_dev(struct snet *snet)\n{\n\tstruct pci_dev *pdev = snet->pdev;\n\tint ret = 0;\n\tu32 i;\n\n\t \n\tif (!snet->status)\n\t\treturn 0;\n\n\t \n\tif (snet->status & VIRTIO_CONFIG_S_DRIVER_OK)\n\t\tret = snet_destroy_dev(snet);\n\n\t \n\tfor (i = 0; i < snet->cfg->vq_num; i++) {\n\t\tif (!snet->vqs[i])\n\t\t\tcontinue;\n\t\tsnet->vqs[i]->cb.callback = NULL;\n\t\tsnet->vqs[i]->cb.private = NULL;\n\t\tsnet->vqs[i]->desc_area = 0;\n\t\tsnet->vqs[i]->device_area = 0;\n\t\tsnet->vqs[i]->driver_area = 0;\n\t\tsnet->vqs[i]->ready = false;\n\t}\n\n\t \n\tsnet->cb.callback = NULL;\n\tsnet->cb.private = NULL;\n\t \n\tsnet_free_irqs(snet);\n\t \n\tsnet->status = 0;\n\tsnet->dpu_ready = false;\n\n\tif (ret)\n\t\tSNET_WARN(pdev, \"Incomplete reset to SNET[%u] device, err: %d\\n\", snet->sid, ret);\n\telse\n\t\tSNET_DBG(pdev, \"Reset SNET[%u] device\\n\", snet->sid);\n\n\treturn 0;\n}\n\nstatic int snet_reset(struct vdpa_device *vdev)\n{\n\tstruct snet *snet = vdpa_to_snet(vdev);\n\n\treturn snet_reset_dev(snet);\n}\n\nstatic size_t snet_get_config_size(struct vdpa_device *vdev)\n{\n\tstruct snet *snet = vdpa_to_snet(vdev);\n\n\treturn (size_t)snet->cfg->cfg_size;\n}\n\nstatic u64 snet_get_features(struct vdpa_device *vdev)\n{\n\tstruct snet *snet = vdpa_to_snet(vdev);\n\n\treturn snet->cfg->features;\n}\n\nstatic int snet_set_drv_features(struct vdpa_device *vdev, u64 features)\n{\n\tstruct snet *snet = vdpa_to_snet(vdev);\n\n\tsnet->negotiated_features = snet->cfg->features & features;\n\treturn 0;\n}\n\nstatic u64 snet_get_drv_features(struct vdpa_device *vdev)\n{\n\tstruct snet *snet = vdpa_to_snet(vdev);\n\n\treturn snet->negotiated_features;\n}\n\nstatic u16 snet_get_vq_num_max(struct vdpa_device *vdev)\n{\n\tstruct snet *snet = vdpa_to_snet(vdev);\n\n\treturn (u16)snet->cfg->vq_size;\n}\n\nstatic void snet_set_config_cb(struct vdpa_device *vdev, struct vdpa_callback *cb)\n{\n\tstruct snet *snet = vdpa_to_snet(vdev);\n\n\tsnet->cb.callback = cb->callback;\n\tsnet->cb.private = cb->private;\n}\n\nstatic u32 snet_get_device_id(struct vdpa_device *vdev)\n{\n\tstruct snet *snet = vdpa_to_snet(vdev);\n\n\treturn snet->cfg->virtio_id;\n}\n\nstatic u32 snet_get_vendor_id(struct vdpa_device *vdev)\n{\n\treturn (u32)PCI_VENDOR_ID_SOLIDRUN;\n}\n\nstatic u8 snet_get_status(struct vdpa_device *vdev)\n{\n\tstruct snet *snet = vdpa_to_snet(vdev);\n\n\treturn snet->status;\n}\n\nstatic int snet_write_conf(struct snet *snet)\n{\n\tu32 off, i, tmp;\n\tint ret;\n\n\t \n\tif (snet->dpu_ready)\n\t\treturn true;\n\n\t \n\n\t \n\toff = snet->psnet->cfg.host_cfg_off;\n\n\t \n\toff += 4;\n\tsnet_write32(snet, off, snet->psnet->negotiated_cfg_ver);\n\toff += 4;\n\tsnet_write32(snet, off, snet->sid);\n\toff += 4;\n\tsnet_write32(snet, off, snet->cfg->vq_num);\n\toff += 4;\n\tsnet_write32(snet, off, snet->cfg_irq_idx);\n\toff += 4;\n\tsnet_write64(snet, off, snet->negotiated_features);\n\toff += 8;\n\t \n\toff += 8;\n\t \n\tfor (i = 0 ; i < snet->cfg->vq_num ; i++) {\n\t\ttmp = (i << 16) | (snet->vqs[i]->num & 0xFFFF);\n\t\tsnet_write32(snet, off, tmp);\n\t\toff += 4;\n\t\tsnet_write32(snet, off, snet->vqs[i]->irq_idx);\n\t\toff += 4;\n\t\tsnet_write64(snet, off, snet->vqs[i]->desc_area);\n\t\toff += 8;\n\t\tsnet_write64(snet, off, snet->vqs[i]->device_area);\n\t\toff += 8;\n\t\tsnet_write64(snet, off, snet->vqs[i]->driver_area);\n\t\toff += 8;\n\t\t \n\t\tif (SNET_CFG_VER(snet, 2))\n\t\t\tsnet_write32(snet, off, *(u32 *)&snet->vqs[i]->vq_state);\n\t\toff += 4;\n\n\t\t \n\t\toff += 4;\n\t}\n\n\t \n\tsnet_write32(snet, snet->psnet->cfg.host_cfg_off, SNET_SIGNATURE);\n\n\t \n\tret = readx_poll_timeout(ioread32, snet->bar + snet->psnet->cfg.host_cfg_off,\n\t\t\t\t tmp, !tmp, 10, SNET_READ_CFG_TIMEOUT);\n\tif (ret) {\n\t\tSNET_ERR(snet->pdev, \"Timeout waiting for the DPU to read the config\\n\");\n\t\treturn false;\n\t}\n\n\t \n\tsnet->dpu_ready = true;\n\n\treturn true;\n}\n\nstatic int snet_request_irqs(struct pci_dev *pdev, struct snet *snet)\n{\n\tint ret, i, irq;\n\n\t \n\tirq = pci_irq_vector(pdev, snet->cfg_irq_idx);\n\tret = devm_request_irq(&pdev->dev, irq, snet_cfg_irq_hndlr, 0,\n\t\t\t       snet->cfg_irq_name, snet);\n\tif (ret) {\n\t\tSNET_ERR(pdev, \"Failed to request IRQ\\n\");\n\t\treturn ret;\n\t}\n\tsnet->cfg_irq = irq;\n\n\t \n\tfor (i = 0; i < snet->cfg->vq_num; i++) {\n\t\tirq = pci_irq_vector(pdev, snet->vqs[i]->irq_idx);\n\t\tret = devm_request_irq(&pdev->dev, irq, snet_vq_irq_hndlr, 0,\n\t\t\t\t       snet->vqs[i]->irq_name, snet->vqs[i]);\n\t\tif (ret) {\n\t\t\tSNET_ERR(pdev, \"Failed to request IRQ\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tsnet->vqs[i]->irq = irq;\n\t}\n\treturn 0;\n}\n\nstatic void snet_set_status(struct vdpa_device *vdev, u8 status)\n{\n\tstruct snet *snet = vdpa_to_snet(vdev);\n\tstruct psnet *psnet = snet->psnet;\n\tstruct pci_dev *pdev = snet->pdev;\n\tint ret;\n\tbool pf_irqs;\n\n\tif (status == snet->status)\n\t\treturn;\n\n\tif ((status & VIRTIO_CONFIG_S_DRIVER_OK) &&\n\t    !(snet->status & VIRTIO_CONFIG_S_DRIVER_OK)) {\n\t\t \n\t\tpf_irqs = PSNET_FLAG_ON(psnet, SNET_CFG_FLAG_IRQ_PF);\n\t\tret = snet_request_irqs(pf_irqs ? pdev->physfn : pdev, snet);\n\t\tif (ret)\n\t\t\tgoto set_err;\n\n\t\t \n\t\tif (snet_write_conf(snet)) {\n\t\t\tSNET_INFO(pdev, \"Create SNET[%u] device\\n\", snet->sid);\n\t\t} else {\n\t\t\tsnet_free_irqs(snet);\n\t\t\tgoto set_err;\n\t\t}\n\t}\n\n\t \n\tsnet->status = status;\n\treturn;\n\nset_err:\n\tsnet->status |= VIRTIO_CONFIG_S_FAILED;\n}\n\nstatic void snet_get_config(struct vdpa_device *vdev, unsigned int offset,\n\t\t\t    void *buf, unsigned int len)\n{\n\tstruct snet *snet = vdpa_to_snet(vdev);\n\tvoid __iomem *cfg_ptr = snet->cfg->virtio_cfg + offset;\n\tu8 *buf_ptr = buf;\n\tu32 i;\n\n\t \n\tif (offset + len > snet->cfg->cfg_size)\n\t\treturn;\n\n\t \n\tfor (i = 0; i < len; i++)\n\t\t*buf_ptr++ = ioread8(cfg_ptr + i);\n}\n\nstatic void snet_set_config(struct vdpa_device *vdev, unsigned int offset,\n\t\t\t    const void *buf, unsigned int len)\n{\n\tstruct snet *snet = vdpa_to_snet(vdev);\n\tvoid __iomem *cfg_ptr = snet->cfg->virtio_cfg + offset;\n\tconst u8 *buf_ptr = buf;\n\tu32 i;\n\n\t \n\tif (offset + len > snet->cfg->cfg_size)\n\t\treturn;\n\n\t \n\tfor (i = 0; i < len; i++)\n\t\tiowrite8(*buf_ptr++, cfg_ptr + i);\n}\n\nstatic int snet_suspend(struct vdpa_device *vdev)\n{\n\tstruct snet *snet = vdpa_to_snet(vdev);\n\tint ret;\n\n\tret = snet_suspend_dev(snet);\n\tif (ret)\n\t\tSNET_ERR(snet->pdev, \"SNET[%u] suspend failed, err: %d\\n\", snet->sid, ret);\n\telse\n\t\tSNET_DBG(snet->pdev, \"Suspend SNET[%u] device\\n\", snet->sid);\n\n\treturn ret;\n}\n\nstatic int snet_resume(struct vdpa_device *vdev)\n{\n\tstruct snet *snet = vdpa_to_snet(vdev);\n\tint ret;\n\n\tret = snet_resume_dev(snet);\n\tif (ret)\n\t\tSNET_ERR(snet->pdev, \"SNET[%u] resume failed, err: %d\\n\", snet->sid, ret);\n\telse\n\t\tSNET_DBG(snet->pdev, \"Resume SNET[%u] device\\n\", snet->sid);\n\n\treturn ret;\n}\n\nstatic const struct vdpa_config_ops snet_config_ops = {\n\t.set_vq_address         = snet_set_vq_address,\n\t.set_vq_num             = snet_set_vq_num,\n\t.kick_vq                = snet_kick_vq,\n\t.kick_vq_with_data\t= snet_kick_vq_with_data,\n\t.set_vq_cb              = snet_set_vq_cb,\n\t.set_vq_ready           = snet_set_vq_ready,\n\t.get_vq_ready           = snet_get_vq_ready,\n\t.set_vq_state           = snet_set_vq_state,\n\t.get_vq_state           = snet_get_vq_state,\n\t.get_vq_irq\t\t= snet_get_vq_irq,\n\t.get_vq_align           = snet_get_vq_align,\n\t.reset                  = snet_reset,\n\t.get_config_size        = snet_get_config_size,\n\t.get_device_features    = snet_get_features,\n\t.set_driver_features    = snet_set_drv_features,\n\t.get_driver_features    = snet_get_drv_features,\n\t.get_vq_num_min         = snet_get_vq_num_max,\n\t.get_vq_num_max         = snet_get_vq_num_max,\n\t.set_config_cb          = snet_set_config_cb,\n\t.get_device_id          = snet_get_device_id,\n\t.get_vendor_id          = snet_get_vendor_id,\n\t.get_status             = snet_get_status,\n\t.set_status             = snet_set_status,\n\t.get_config             = snet_get_config,\n\t.set_config             = snet_set_config,\n\t.suspend\t\t= snet_suspend,\n\t.resume\t\t\t= snet_resume,\n};\n\nstatic int psnet_open_pf_bar(struct pci_dev *pdev, struct psnet *psnet)\n{\n\tchar name[50];\n\tint ret, i, mask = 0;\n\t \n\tfor (i = 0; i < PCI_STD_NUM_BARS; i++) {\n\t\tif (pci_resource_len(pdev, i))\n\t\t\tmask |= (1 << i);\n\t}\n\n\t \n\tif (!mask) {\n\t\tSNET_ERR(pdev, \"Failed to find a PCI BAR\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tsnprintf(name, sizeof(name), \"psnet[%s]-bars\", pci_name(pdev));\n\tret = pcim_iomap_regions(pdev, mask, name);\n\tif (ret) {\n\t\tSNET_ERR(pdev, \"Failed to request and map PCI BARs\\n\");\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < PCI_STD_NUM_BARS; i++) {\n\t\tif (mask & (1 << i))\n\t\t\tpsnet->bars[i] = pcim_iomap_table(pdev)[i];\n\t}\n\n\treturn 0;\n}\n\nstatic int snet_open_vf_bar(struct pci_dev *pdev, struct snet *snet)\n{\n\tchar name[50];\n\tint ret;\n\n\tsnprintf(name, sizeof(name), \"snet[%s]-bar\", pci_name(pdev));\n\t \n\tret = pcim_iomap_regions(pdev, BIT(snet->psnet->cfg.vf_bar), name);\n\tif (ret) {\n\t\tSNET_ERR(pdev, \"Failed to request and map PCI BAR for a VF\\n\");\n\t\treturn ret;\n\t}\n\n\tsnet->bar = pcim_iomap_table(pdev)[snet->psnet->cfg.vf_bar];\n\n\treturn 0;\n}\n\nstatic void snet_free_cfg(struct snet_cfg *cfg)\n{\n\tu32 i;\n\n\tif (!cfg->devs)\n\t\treturn;\n\n\t \n\tfor (i = 0; i < cfg->devices_num; i++) {\n\t\tif (!cfg->devs[i])\n\t\t\tbreak;\n\n\t\tkfree(cfg->devs[i]);\n\t}\n\t \n\tkfree(cfg->devs);\n}\n\n \nstatic int psnet_detect_bar(struct psnet *psnet, u32 off)\n{\n\tunsigned long exit_time;\n\tint i;\n\n\texit_time = jiffies + usecs_to_jiffies(SNET_DETECT_TIMEOUT);\n\n\t \n\twhile (time_before(jiffies, exit_time)) {\n\t\tfor (i = 0; i < PCI_STD_NUM_BARS; i++) {\n\t\t\t \n\t\t\tif (!psnet->bars[i])\n\t\t\t\tcontinue;\n\n\t\t\tif (ioread32(psnet->bars[i] + off) == SNET_SIGNATURE)\n\t\t\t\treturn i;\n\t\t}\n\t\tusleep_range(1000, 10000);\n\t}\n\n\treturn -ENODEV;\n}\n\nstatic void psnet_unmap_unused_bars(struct pci_dev *pdev, struct psnet *psnet)\n{\n\tint i, mask = 0;\n\n\tfor (i = 0; i < PCI_STD_NUM_BARS; i++) {\n\t\tif (psnet->bars[i] && i != psnet->barno)\n\t\t\tmask |= (1 << i);\n\t}\n\n\tif (mask)\n\t\tpcim_iounmap_regions(pdev, mask);\n}\n\n \nstatic int psnet_read_cfg(struct pci_dev *pdev, struct psnet *psnet)\n{\n\tstruct snet_cfg *cfg = &psnet->cfg;\n\tu32 i, off;\n\tint barno;\n\n\t \n\toff = SNET_CONFIG_OFF;\n\n\t \n\tbarno = psnet_detect_bar(psnet, off);\n\tif (barno < 0) {\n\t\tSNET_ERR(pdev, \"SNET config is not ready.\\n\");\n\t\treturn barno;\n\t}\n\n\t \n\tpsnet->barno = barno;\n\tSNET_DBG(pdev, \"Using BAR number %d\\n\", barno);\n\n\tpsnet_unmap_unused_bars(pdev, psnet);\n\n\t \n\tcfg->key = psnet_read32(psnet, off);\n\toff += 4;\n\tcfg->cfg_size = psnet_read32(psnet, off);\n\toff += 4;\n\tcfg->cfg_ver = psnet_read32(psnet, off);\n\toff += 4;\n\t \n\tpsnet->negotiated_cfg_ver = min_t(u32, cfg->cfg_ver, SNET_CFG_VERSION);\n\tSNET_DBG(pdev, \"SNET config version %u\\n\", psnet->negotiated_cfg_ver);\n\n\tcfg->vf_num = psnet_read32(psnet, off);\n\toff += 4;\n\tcfg->vf_bar = psnet_read32(psnet, off);\n\toff += 4;\n\tcfg->host_cfg_off = psnet_read32(psnet, off);\n\toff += 4;\n\tcfg->max_size_host_cfg = psnet_read32(psnet, off);\n\toff += 4;\n\tcfg->virtio_cfg_off = psnet_read32(psnet, off);\n\toff += 4;\n\tcfg->kick_off = psnet_read32(psnet, off);\n\toff += 4;\n\tcfg->hwmon_off = psnet_read32(psnet, off);\n\toff += 4;\n\tcfg->ctrl_off = psnet_read32(psnet, off);\n\toff += 4;\n\tcfg->flags = psnet_read32(psnet, off);\n\toff += 4;\n\t \n\toff += sizeof(cfg->rsvd);\n\n\tcfg->devices_num = psnet_read32(psnet, off);\n\toff += 4;\n\t \n\tcfg->devs = kcalloc(cfg->devices_num, sizeof(void *), GFP_KERNEL);\n\tif (!cfg->devs)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = 0; i < cfg->devices_num; i++) {\n\t\tcfg->devs[i] = kzalloc(sizeof(*cfg->devs[i]), GFP_KERNEL);\n\t\tif (!cfg->devs[i]) {\n\t\t\tsnet_free_cfg(cfg);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\t \n\t\tcfg->devs[i]->virtio_id = psnet_read32(psnet, off);\n\t\toff += 4;\n\t\tcfg->devs[i]->vq_num = psnet_read32(psnet, off);\n\t\toff += 4;\n\t\tcfg->devs[i]->vq_size = psnet_read32(psnet, off);\n\t\toff += 4;\n\t\tcfg->devs[i]->vfid = psnet_read32(psnet, off);\n\t\toff += 4;\n\t\tcfg->devs[i]->features = psnet_read64(psnet, off);\n\t\toff += 8;\n\t\t \n\t\toff += sizeof(cfg->devs[i]->rsvd);\n\n\t\tcfg->devs[i]->cfg_size = psnet_read32(psnet, off);\n\t\toff += 4;\n\n\t\t \n\t\tif (SNET_GENERAL_CFG_LEN + SNET_GENERAL_CFG_VQ_LEN * cfg->devs[i]->vq_num >\n\t\t    cfg->max_size_host_cfg) {\n\t\t\tSNET_ERR(pdev, \"Failed to read SNET config, the config is too big..\\n\");\n\t\t\tsnet_free_cfg(cfg);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int psnet_alloc_irq_vector(struct pci_dev *pdev, struct psnet *psnet)\n{\n\tint ret = 0;\n\tu32 i, irq_num = 0;\n\n\t \n\tfor (i = 0; i < psnet->cfg.devices_num; i++)\n\t\tirq_num += psnet->cfg.devs[i]->vq_num + 1;\n\n\tret = pci_alloc_irq_vectors(pdev, irq_num, irq_num, PCI_IRQ_MSIX);\n\tif (ret != irq_num) {\n\t\tSNET_ERR(pdev, \"Failed to allocate IRQ vectors\\n\");\n\t\treturn ret;\n\t}\n\tSNET_DBG(pdev, \"Allocated %u IRQ vectors from physical function\\n\", irq_num);\n\n\treturn 0;\n}\n\nstatic int snet_alloc_irq_vector(struct pci_dev *pdev, struct snet_dev_cfg *snet_cfg)\n{\n\tint ret = 0;\n\tu32 irq_num;\n\n\t \n\tirq_num = snet_cfg->vq_num + 1;\n\n\tret = pci_alloc_irq_vectors(pdev, irq_num, irq_num, PCI_IRQ_MSIX);\n\tif (ret <= 0) {\n\t\tSNET_ERR(pdev, \"Failed to allocate IRQ vectors\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void snet_free_vqs(struct snet *snet)\n{\n\tu32 i;\n\n\tif (!snet->vqs)\n\t\treturn;\n\n\tfor (i = 0 ; i < snet->cfg->vq_num ; i++) {\n\t\tif (!snet->vqs[i])\n\t\t\tbreak;\n\n\t\tkfree(snet->vqs[i]);\n\t}\n\tkfree(snet->vqs);\n}\n\nstatic int snet_build_vqs(struct snet *snet)\n{\n\tu32 i;\n\t \n\tsnet->vqs = kcalloc(snet->cfg->vq_num, sizeof(void *), GFP_KERNEL);\n\tif (!snet->vqs)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = 0; i < snet->cfg->vq_num; i++) {\n\t\tsnet->vqs[i] = kzalloc(sizeof(*snet->vqs[i]), GFP_KERNEL);\n\t\tif (!snet->vqs[i]) {\n\t\t\tsnet_free_vqs(snet);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\t \n\t\tsnet->vqs[i]->irq = -1;\n\t\t \n\t\tsnet->vqs[i]->sid = i;\n\t\t \n\t\tsnet->vqs[i]->kick_ptr = snet->bar + snet->psnet->cfg.kick_off +\n\t\t\t\t\t snet->vqs[i]->sid * 4;\n\t\t \n\t\tiowrite32(0, snet->vqs[i]->kick_ptr);\n\t}\n\treturn 0;\n}\n\nstatic int psnet_get_next_irq_num(struct psnet *psnet)\n{\n\tint irq;\n\n\tspin_lock(&psnet->lock);\n\tirq = psnet->next_irq++;\n\tspin_unlock(&psnet->lock);\n\n\treturn irq;\n}\n\nstatic void snet_reserve_irq_idx(struct pci_dev *pdev, struct snet *snet)\n{\n\tstruct psnet *psnet = snet->psnet;\n\tint  i;\n\n\t \n\tsnet->cfg_irq_idx = psnet_get_next_irq_num(psnet);\n\tsnprintf(snet->cfg_irq_name, SNET_NAME_SIZE, \"snet[%s]-cfg[%d]\",\n\t\t pci_name(pdev), snet->cfg_irq_idx);\n\n\tfor (i = 0; i < snet->cfg->vq_num; i++) {\n\t\t \n\t\tsnet->vqs[i]->irq_idx = psnet_get_next_irq_num(psnet);\n\t\t \n\t\tsnprintf(snet->vqs[i]->irq_name, SNET_NAME_SIZE, \"snet[%s]-vq[%d]\",\n\t\t\t pci_name(pdev), snet->vqs[i]->irq_idx);\n\t}\n}\n\n \nstatic struct snet_dev_cfg *snet_find_dev_cfg(struct snet_cfg *cfg, u32 vfid)\n{\n\tu32 i;\n\n\tfor (i = 0; i < cfg->devices_num; i++) {\n\t\tif (cfg->devs[i]->vfid == vfid)\n\t\t\treturn cfg->devs[i];\n\t}\n\t \n\treturn NULL;\n}\n\n \nstatic int snet_vdpa_probe_pf(struct pci_dev *pdev)\n{\n\tstruct psnet *psnet;\n\tint ret = 0;\n\tbool pf_irqs = false;\n\n\tret = pcim_enable_device(pdev);\n\tif (ret) {\n\t\tSNET_ERR(pdev, \"Failed to enable PCI device\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tpsnet = kzalloc(sizeof(*psnet), GFP_KERNEL);\n\tif (!psnet)\n\t\treturn -ENOMEM;\n\n\t \n\tspin_lock_init(&psnet->lock);\n\n\tpci_set_master(pdev);\n\tpci_set_drvdata(pdev, psnet);\n\n\t \n\tret = psnet_open_pf_bar(pdev, psnet);\n\tif (ret)\n\t\tgoto free_psnet;\n\n\t \n\tret = psnet_read_cfg(pdev, psnet);\n\tif (ret)\n\t\tgoto free_psnet;\n\n\t \n\tpf_irqs = PSNET_FLAG_ON(psnet, SNET_CFG_FLAG_IRQ_PF);\n\n\tif (pf_irqs) {\n\t\tret = psnet_alloc_irq_vector(pdev, psnet);\n\t\tif (ret)\n\t\t\tgoto free_cfg;\n\t}\n\n\tSNET_DBG(pdev, \"Enable %u virtual functions\\n\", psnet->cfg.vf_num);\n\tret = pci_enable_sriov(pdev, psnet->cfg.vf_num);\n\tif (ret) {\n\t\tSNET_ERR(pdev, \"Failed to enable SR-IOV\\n\");\n\t\tgoto free_irq;\n\t}\n\n\t \n\tif (PSNET_FLAG_ON(psnet, SNET_CFG_FLAG_HWMON)) {\n#if IS_ENABLED(CONFIG_HWMON)\n\t\tpsnet_create_hwmon(pdev);\n#else\n\t\tSNET_WARN(pdev, \"Can't start HWMON, CONFIG_HWMON is not enabled\\n\");\n#endif\n\t}\n\n\treturn 0;\n\nfree_irq:\n\tif (pf_irqs)\n\t\tpci_free_irq_vectors(pdev);\nfree_cfg:\n\tsnet_free_cfg(&psnet->cfg);\nfree_psnet:\n\tkfree(psnet);\n\treturn ret;\n}\n\n \nstatic int snet_vdpa_probe_vf(struct pci_dev *pdev)\n{\n\tstruct pci_dev *pdev_pf = pdev->physfn;\n\tstruct psnet *psnet = pci_get_drvdata(pdev_pf);\n\tstruct snet_dev_cfg *dev_cfg;\n\tstruct snet *snet;\n\tu32 vfid;\n\tint ret;\n\tbool pf_irqs = false;\n\n\t \n\tret = pci_iov_vf_id(pdev);\n\tif (ret < 0) {\n\t\tSNET_ERR(pdev, \"Failed to find a VF id\\n\");\n\t\treturn ret;\n\t}\n\tvfid = ret + 1;\n\n\t \n\tdev_cfg = snet_find_dev_cfg(&psnet->cfg, vfid);\n\tif (!dev_cfg) {\n\t\tSNET_WARN(pdev, \"Failed to find a VF config..\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tpf_irqs = PSNET_FLAG_ON(psnet, SNET_CFG_FLAG_IRQ_PF);\n\n\tret = pcim_enable_device(pdev);\n\tif (ret) {\n\t\tSNET_ERR(pdev, \"Failed to enable PCI VF device\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tif (!pf_irqs) {\n\t\tret = snet_alloc_irq_vector(pdev, dev_cfg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tsnet = vdpa_alloc_device(struct snet, vdpa, &pdev->dev, &snet_config_ops, 1, 1, NULL,\n\t\t\t\t false);\n\tif (!snet) {\n\t\tSNET_ERR(pdev, \"Failed to allocate a vdpa device\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto free_irqs;\n\t}\n\n\t \n\tmutex_init(&snet->ctrl_lock);\n\tspin_lock_init(&snet->ctrl_spinlock);\n\n\t \n\tsnet->pdev = pdev;\n\tsnet->psnet = psnet;\n\tsnet->cfg = dev_cfg;\n\tsnet->dpu_ready = false;\n\tsnet->sid = vfid;\n\t \n\tsnet->cfg_irq = -1;\n\n\tret = snet_open_vf_bar(pdev, snet);\n\tif (ret)\n\t\tgoto put_device;\n\n\t \n\tsnet->cfg->virtio_cfg = snet->bar + snet->psnet->cfg.virtio_cfg_off;\n\n\t \n\tsnet_ctrl_clear(snet);\n\n\tpci_set_master(pdev);\n\tpci_set_drvdata(pdev, snet);\n\n\tret = snet_build_vqs(snet);\n\tif (ret)\n\t\tgoto put_device;\n\n\t \n\tsnet_reserve_irq_idx(pf_irqs ? pdev_pf : pdev, snet);\n\n\t \n\tsnet->vdpa.dma_dev = &pdev->dev;\n\n\t \n\tret = vdpa_register_device(&snet->vdpa, snet->cfg->vq_num);\n\tif (ret) {\n\t\tSNET_ERR(pdev, \"Failed to register vdpa device\\n\");\n\t\tgoto free_vqs;\n\t}\n\n\treturn 0;\n\nfree_vqs:\n\tsnet_free_vqs(snet);\nput_device:\n\tput_device(&snet->vdpa.dev);\nfree_irqs:\n\tif (!pf_irqs)\n\t\tpci_free_irq_vectors(pdev);\n\treturn ret;\n}\n\nstatic int snet_vdpa_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tif (pdev->is_virtfn)\n\t\treturn snet_vdpa_probe_vf(pdev);\n\telse\n\t\treturn snet_vdpa_probe_pf(pdev);\n}\n\nstatic void snet_vdpa_remove_pf(struct pci_dev *pdev)\n{\n\tstruct psnet *psnet = pci_get_drvdata(pdev);\n\n\tpci_disable_sriov(pdev);\n\t \n\tif (PSNET_FLAG_ON(psnet, SNET_CFG_FLAG_IRQ_PF))\n\t\tpci_free_irq_vectors(pdev);\n\n\tsnet_free_cfg(&psnet->cfg);\n\tkfree(psnet);\n}\n\nstatic void snet_vdpa_remove_vf(struct pci_dev *pdev)\n{\n\tstruct snet *snet = pci_get_drvdata(pdev);\n\tstruct psnet *psnet = snet->psnet;\n\n\tvdpa_unregister_device(&snet->vdpa);\n\tsnet_free_vqs(snet);\n\t \n\tif (!PSNET_FLAG_ON(psnet, SNET_CFG_FLAG_IRQ_PF))\n\t\tpci_free_irq_vectors(pdev);\n}\n\nstatic void snet_vdpa_remove(struct pci_dev *pdev)\n{\n\tif (pdev->is_virtfn)\n\t\tsnet_vdpa_remove_vf(pdev);\n\telse\n\t\tsnet_vdpa_remove_pf(pdev);\n}\n\nstatic struct pci_device_id snet_driver_pci_ids[] = {\n\t{ PCI_DEVICE_SUB(PCI_VENDOR_ID_SOLIDRUN, SNET_DEVICE_ID,\n\t\t\t PCI_VENDOR_ID_SOLIDRUN, SNET_DEVICE_ID) },\n\t{ 0 },\n};\n\nMODULE_DEVICE_TABLE(pci, snet_driver_pci_ids);\n\nstatic struct pci_driver snet_vdpa_driver = {\n\t.name\t\t= \"snet-vdpa-driver\",\n\t.id_table\t= snet_driver_pci_ids,\n\t.probe\t\t= snet_vdpa_probe,\n\t.remove\t\t= snet_vdpa_remove,\n};\n\nmodule_pci_driver(snet_vdpa_driver);\n\nMODULE_AUTHOR(\"Alvaro Karsz <alvaro.karsz@solid-run.com>\");\nMODULE_DESCRIPTION(\"SolidRun vDPA driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}