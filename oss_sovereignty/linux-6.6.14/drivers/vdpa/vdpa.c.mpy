{
  "module_name": "vdpa.c",
  "hash_id": "2fcc8d4618370387036be2aba5e6b3200eb7ff498fd6ef270792bf44a24aa582",
  "original_prompt": "Ingested from linux-6.6.14/drivers/vdpa/vdpa.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/vdpa.h>\n#include <uapi/linux/vdpa.h>\n#include <net/genetlink.h>\n#include <linux/mod_devicetable.h>\n#include <linux/virtio_ids.h>\n\nstatic LIST_HEAD(mdev_head);\n \nstatic DECLARE_RWSEM(vdpa_dev_lock);\nstatic DEFINE_IDA(vdpa_index_ida);\n\nvoid vdpa_set_status(struct vdpa_device *vdev, u8 status)\n{\n\tdown_write(&vdev->cf_lock);\n\tvdev->config->set_status(vdev, status);\n\tup_write(&vdev->cf_lock);\n}\nEXPORT_SYMBOL(vdpa_set_status);\n\nstatic struct genl_family vdpa_nl_family;\n\nstatic int vdpa_dev_probe(struct device *d)\n{\n\tstruct vdpa_device *vdev = dev_to_vdpa(d);\n\tstruct vdpa_driver *drv = drv_to_vdpa(vdev->dev.driver);\n\tconst struct vdpa_config_ops *ops = vdev->config;\n\tu32 max_num, min_num = 1;\n\tint ret = 0;\n\n\td->dma_mask = &d->coherent_dma_mask;\n\tret = dma_set_mask_and_coherent(d, DMA_BIT_MASK(64));\n\tif (ret)\n\t\treturn ret;\n\n\tmax_num = ops->get_vq_num_max(vdev);\n\tif (ops->get_vq_num_min)\n\t\tmin_num = ops->get_vq_num_min(vdev);\n\tif (max_num < min_num)\n\t\treturn -EINVAL;\n\n\tif (drv && drv->probe)\n\t\tret = drv->probe(vdev);\n\n\treturn ret;\n}\n\nstatic void vdpa_dev_remove(struct device *d)\n{\n\tstruct vdpa_device *vdev = dev_to_vdpa(d);\n\tstruct vdpa_driver *drv = drv_to_vdpa(vdev->dev.driver);\n\n\tif (drv && drv->remove)\n\t\tdrv->remove(vdev);\n}\n\nstatic int vdpa_dev_match(struct device *dev, struct device_driver *drv)\n{\n\tstruct vdpa_device *vdev = dev_to_vdpa(dev);\n\n\t \n\tif (vdev->driver_override)\n\t\treturn strcmp(vdev->driver_override, drv->name) == 0;\n\n\t \n\treturn 1;\n}\n\nstatic ssize_t driver_override_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct vdpa_device *vdev = dev_to_vdpa(dev);\n\tint ret;\n\n\tret = driver_set_override(dev, &vdev->driver_override, buf, count);\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic ssize_t driver_override_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct vdpa_device *vdev = dev_to_vdpa(dev);\n\tssize_t len;\n\n\tdevice_lock(dev);\n\tlen = snprintf(buf, PAGE_SIZE, \"%s\\n\", vdev->driver_override);\n\tdevice_unlock(dev);\n\n\treturn len;\n}\nstatic DEVICE_ATTR_RW(driver_override);\n\nstatic struct attribute *vdpa_dev_attrs[] = {\n\t&dev_attr_driver_override.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group vdpa_dev_group = {\n\t.attrs  = vdpa_dev_attrs,\n};\n__ATTRIBUTE_GROUPS(vdpa_dev);\n\nstatic struct bus_type vdpa_bus = {\n\t.name  = \"vdpa\",\n\t.dev_groups = vdpa_dev_groups,\n\t.match = vdpa_dev_match,\n\t.probe = vdpa_dev_probe,\n\t.remove = vdpa_dev_remove,\n};\n\nstatic void vdpa_release_dev(struct device *d)\n{\n\tstruct vdpa_device *vdev = dev_to_vdpa(d);\n\tconst struct vdpa_config_ops *ops = vdev->config;\n\n\tif (ops->free)\n\t\tops->free(vdev);\n\n\tida_simple_remove(&vdpa_index_ida, vdev->index);\n\tkfree(vdev->driver_override);\n\tkfree(vdev);\n}\n\n \nstruct vdpa_device *__vdpa_alloc_device(struct device *parent,\n\t\t\t\t\tconst struct vdpa_config_ops *config,\n\t\t\t\t\tunsigned int ngroups, unsigned int nas,\n\t\t\t\t\tsize_t size, const char *name,\n\t\t\t\t\tbool use_va)\n{\n\tstruct vdpa_device *vdev;\n\tint err = -EINVAL;\n\n\tif (!config)\n\t\tgoto err;\n\n\tif (!!config->dma_map != !!config->dma_unmap)\n\t\tgoto err;\n\n\t \n\tif (use_va && !(config->dma_map || config->set_map))\n\t\tgoto err;\n\n\terr = -ENOMEM;\n\tvdev = kzalloc(size, GFP_KERNEL);\n\tif (!vdev)\n\t\tgoto err;\n\n\terr = ida_alloc(&vdpa_index_ida, GFP_KERNEL);\n\tif (err < 0)\n\t\tgoto err_ida;\n\n\tvdev->dev.bus = &vdpa_bus;\n\tvdev->dev.parent = parent;\n\tvdev->dev.release = vdpa_release_dev;\n\tvdev->index = err;\n\tvdev->config = config;\n\tvdev->features_valid = false;\n\tvdev->use_va = use_va;\n\tvdev->ngroups = ngroups;\n\tvdev->nas = nas;\n\n\tif (name)\n\t\terr = dev_set_name(&vdev->dev, \"%s\", name);\n\telse\n\t\terr = dev_set_name(&vdev->dev, \"vdpa%u\", vdev->index);\n\tif (err)\n\t\tgoto err_name;\n\n\tinit_rwsem(&vdev->cf_lock);\n\tdevice_initialize(&vdev->dev);\n\n\treturn vdev;\n\nerr_name:\n\tida_simple_remove(&vdpa_index_ida, vdev->index);\nerr_ida:\n\tkfree(vdev);\nerr:\n\treturn ERR_PTR(err);\n}\nEXPORT_SYMBOL_GPL(__vdpa_alloc_device);\n\nstatic int vdpa_name_match(struct device *dev, const void *data)\n{\n\tstruct vdpa_device *vdev = container_of(dev, struct vdpa_device, dev);\n\n\treturn (strcmp(dev_name(&vdev->dev), data) == 0);\n}\n\nstatic int __vdpa_register_device(struct vdpa_device *vdev, u32 nvqs)\n{\n\tstruct device *dev;\n\n\tvdev->nvqs = nvqs;\n\n\tlockdep_assert_held(&vdpa_dev_lock);\n\tdev = bus_find_device(&vdpa_bus, NULL, dev_name(&vdev->dev), vdpa_name_match);\n\tif (dev) {\n\t\tput_device(dev);\n\t\treturn -EEXIST;\n\t}\n\treturn device_add(&vdev->dev);\n}\n\n \nint _vdpa_register_device(struct vdpa_device *vdev, u32 nvqs)\n{\n\tif (!vdev->mdev)\n\t\treturn -EINVAL;\n\n\treturn __vdpa_register_device(vdev, nvqs);\n}\nEXPORT_SYMBOL_GPL(_vdpa_register_device);\n\n \nint vdpa_register_device(struct vdpa_device *vdev, u32 nvqs)\n{\n\tint err;\n\n\tdown_write(&vdpa_dev_lock);\n\terr = __vdpa_register_device(vdev, nvqs);\n\tup_write(&vdpa_dev_lock);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(vdpa_register_device);\n\n \nvoid _vdpa_unregister_device(struct vdpa_device *vdev)\n{\n\tlockdep_assert_held(&vdpa_dev_lock);\n\tWARN_ON(!vdev->mdev);\n\tdevice_unregister(&vdev->dev);\n}\nEXPORT_SYMBOL_GPL(_vdpa_unregister_device);\n\n \nvoid vdpa_unregister_device(struct vdpa_device *vdev)\n{\n\tdown_write(&vdpa_dev_lock);\n\tdevice_unregister(&vdev->dev);\n\tup_write(&vdpa_dev_lock);\n}\nEXPORT_SYMBOL_GPL(vdpa_unregister_device);\n\n \nint __vdpa_register_driver(struct vdpa_driver *drv, struct module *owner)\n{\n\tdrv->driver.bus = &vdpa_bus;\n\tdrv->driver.owner = owner;\n\n\treturn driver_register(&drv->driver);\n}\nEXPORT_SYMBOL_GPL(__vdpa_register_driver);\n\n \nvoid vdpa_unregister_driver(struct vdpa_driver *drv)\n{\n\tdriver_unregister(&drv->driver);\n}\nEXPORT_SYMBOL_GPL(vdpa_unregister_driver);\n\n \nint vdpa_mgmtdev_register(struct vdpa_mgmt_dev *mdev)\n{\n\tif (!mdev->device || !mdev->ops || !mdev->ops->dev_add || !mdev->ops->dev_del)\n\t\treturn -EINVAL;\n\n\tINIT_LIST_HEAD(&mdev->list);\n\tdown_write(&vdpa_dev_lock);\n\tlist_add_tail(&mdev->list, &mdev_head);\n\tup_write(&vdpa_dev_lock);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(vdpa_mgmtdev_register);\n\nstatic int vdpa_match_remove(struct device *dev, void *data)\n{\n\tstruct vdpa_device *vdev = container_of(dev, struct vdpa_device, dev);\n\tstruct vdpa_mgmt_dev *mdev = vdev->mdev;\n\n\tif (mdev == data)\n\t\tmdev->ops->dev_del(mdev, vdev);\n\treturn 0;\n}\n\nvoid vdpa_mgmtdev_unregister(struct vdpa_mgmt_dev *mdev)\n{\n\tdown_write(&vdpa_dev_lock);\n\n\tlist_del(&mdev->list);\n\n\t \n\tbus_for_each_dev(&vdpa_bus, NULL, mdev, vdpa_match_remove);\n\n\tup_write(&vdpa_dev_lock);\n}\nEXPORT_SYMBOL_GPL(vdpa_mgmtdev_unregister);\n\nstatic void vdpa_get_config_unlocked(struct vdpa_device *vdev,\n\t\t\t\t     unsigned int offset,\n\t\t\t\t     void *buf, unsigned int len)\n{\n\tconst struct vdpa_config_ops *ops = vdev->config;\n\n\t \n\tif (!vdev->features_valid)\n\t\tvdpa_set_features_unlocked(vdev, 0);\n\tops->get_config(vdev, offset, buf, len);\n}\n\n \nvoid vdpa_get_config(struct vdpa_device *vdev, unsigned int offset,\n\t\t     void *buf, unsigned int len)\n{\n\tdown_read(&vdev->cf_lock);\n\tvdpa_get_config_unlocked(vdev, offset, buf, len);\n\tup_read(&vdev->cf_lock);\n}\nEXPORT_SYMBOL_GPL(vdpa_get_config);\n\n \nvoid vdpa_set_config(struct vdpa_device *vdev, unsigned int offset,\n\t\t     const void *buf, unsigned int length)\n{\n\tdown_write(&vdev->cf_lock);\n\tvdev->config->set_config(vdev, offset, buf, length);\n\tup_write(&vdev->cf_lock);\n}\nEXPORT_SYMBOL_GPL(vdpa_set_config);\n\nstatic bool mgmtdev_handle_match(const struct vdpa_mgmt_dev *mdev,\n\t\t\t\t const char *busname, const char *devname)\n{\n\t \n\tif ((busname && !mdev->device->bus) || (!busname && mdev->device->bus))\n\t\treturn false;\n\n\tif (!busname && strcmp(dev_name(mdev->device), devname) == 0)\n\t\treturn true;\n\n\tif (busname && (strcmp(mdev->device->bus->name, busname) == 0) &&\n\t    (strcmp(dev_name(mdev->device), devname) == 0))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic struct vdpa_mgmt_dev *vdpa_mgmtdev_get_from_attr(struct nlattr **attrs)\n{\n\tstruct vdpa_mgmt_dev *mdev;\n\tconst char *busname = NULL;\n\tconst char *devname;\n\n\tif (!attrs[VDPA_ATTR_MGMTDEV_DEV_NAME])\n\t\treturn ERR_PTR(-EINVAL);\n\tdevname = nla_data(attrs[VDPA_ATTR_MGMTDEV_DEV_NAME]);\n\tif (attrs[VDPA_ATTR_MGMTDEV_BUS_NAME])\n\t\tbusname = nla_data(attrs[VDPA_ATTR_MGMTDEV_BUS_NAME]);\n\n\tlist_for_each_entry(mdev, &mdev_head, list) {\n\t\tif (mgmtdev_handle_match(mdev, busname, devname))\n\t\t\treturn mdev;\n\t}\n\treturn ERR_PTR(-ENODEV);\n}\n\nstatic int vdpa_nl_mgmtdev_handle_fill(struct sk_buff *msg, const struct vdpa_mgmt_dev *mdev)\n{\n\tif (mdev->device->bus &&\n\t    nla_put_string(msg, VDPA_ATTR_MGMTDEV_BUS_NAME, mdev->device->bus->name))\n\t\treturn -EMSGSIZE;\n\tif (nla_put_string(msg, VDPA_ATTR_MGMTDEV_DEV_NAME, dev_name(mdev->device)))\n\t\treturn -EMSGSIZE;\n\treturn 0;\n}\n\nstatic u64 vdpa_mgmtdev_get_classes(const struct vdpa_mgmt_dev *mdev,\n\t\t\t\t    unsigned int *nclasses)\n{\n\tu64 supported_classes = 0;\n\tunsigned int n = 0;\n\n\tfor (int i = 0; mdev->id_table[i].device; i++) {\n\t\tif (mdev->id_table[i].device > 63)\n\t\t\tcontinue;\n\t\tsupported_classes |= BIT_ULL(mdev->id_table[i].device);\n\t\tn++;\n\t}\n\tif (nclasses)\n\t\t*nclasses = n;\n\n\treturn supported_classes;\n}\n\nstatic int vdpa_mgmtdev_fill(const struct vdpa_mgmt_dev *mdev, struct sk_buff *msg,\n\t\t\t     u32 portid, u32 seq, int flags)\n{\n\tvoid *hdr;\n\tint err;\n\n\thdr = genlmsg_put(msg, portid, seq, &vdpa_nl_family, flags, VDPA_CMD_MGMTDEV_NEW);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\terr = vdpa_nl_mgmtdev_handle_fill(msg, mdev);\n\tif (err)\n\t\tgoto msg_err;\n\n\tif (nla_put_u64_64bit(msg, VDPA_ATTR_MGMTDEV_SUPPORTED_CLASSES,\n\t\t\t      vdpa_mgmtdev_get_classes(mdev, NULL),\n\t\t\t      VDPA_ATTR_UNSPEC)) {\n\t\terr = -EMSGSIZE;\n\t\tgoto msg_err;\n\t}\n\tif (nla_put_u32(msg, VDPA_ATTR_DEV_MGMTDEV_MAX_VQS,\n\t\t\tmdev->max_supported_vqs)) {\n\t\terr = -EMSGSIZE;\n\t\tgoto msg_err;\n\t}\n\tif (nla_put_u64_64bit(msg, VDPA_ATTR_DEV_SUPPORTED_FEATURES,\n\t\t\t      mdev->supported_features, VDPA_ATTR_PAD)) {\n\t\terr = -EMSGSIZE;\n\t\tgoto msg_err;\n\t}\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\nmsg_err:\n\tgenlmsg_cancel(msg, hdr);\n\treturn err;\n}\n\nstatic int vdpa_nl_cmd_mgmtdev_get_doit(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct vdpa_mgmt_dev *mdev;\n\tstruct sk_buff *msg;\n\tint err;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tdown_read(&vdpa_dev_lock);\n\tmdev = vdpa_mgmtdev_get_from_attr(info->attrs);\n\tif (IS_ERR(mdev)) {\n\t\tup_read(&vdpa_dev_lock);\n\t\tNL_SET_ERR_MSG_MOD(info->extack, \"Fail to find the specified mgmt device\");\n\t\terr = PTR_ERR(mdev);\n\t\tgoto out;\n\t}\n\n\terr = vdpa_mgmtdev_fill(mdev, msg, info->snd_portid, info->snd_seq, 0);\n\tup_read(&vdpa_dev_lock);\n\tif (err)\n\t\tgoto out;\n\terr = genlmsg_reply(msg, info);\n\treturn err;\n\nout:\n\tnlmsg_free(msg);\n\treturn err;\n}\n\nstatic int\nvdpa_nl_cmd_mgmtdev_get_dumpit(struct sk_buff *msg, struct netlink_callback *cb)\n{\n\tstruct vdpa_mgmt_dev *mdev;\n\tint start = cb->args[0];\n\tint idx = 0;\n\tint err;\n\n\tdown_read(&vdpa_dev_lock);\n\tlist_for_each_entry(mdev, &mdev_head, list) {\n\t\tif (idx < start) {\n\t\t\tidx++;\n\t\t\tcontinue;\n\t\t}\n\t\terr = vdpa_mgmtdev_fill(mdev, msg, NETLINK_CB(cb->skb).portid,\n\t\t\t\t\tcb->nlh->nlmsg_seq, NLM_F_MULTI);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tidx++;\n\t}\nout:\n\tup_read(&vdpa_dev_lock);\n\tcb->args[0] = idx;\n\treturn msg->len;\n}\n\n#define VDPA_DEV_NET_ATTRS_MASK (BIT_ULL(VDPA_ATTR_DEV_NET_CFG_MACADDR) | \\\n\t\t\t\t BIT_ULL(VDPA_ATTR_DEV_NET_CFG_MTU)     | \\\n\t\t\t\t BIT_ULL(VDPA_ATTR_DEV_NET_CFG_MAX_VQP))\n\n \n#define VIRTIO_DEVICE_F_MASK (~0ULL << (VIRTIO_TRANSPORT_F_END + 1) | \\\n\t\t\t      ((1ULL << VIRTIO_TRANSPORT_F_START) - 1))\n\nstatic int vdpa_nl_cmd_dev_add_set_doit(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct vdpa_dev_set_config config = {};\n\tstruct nlattr **nl_attrs = info->attrs;\n\tstruct vdpa_mgmt_dev *mdev;\n\tunsigned int ncls = 0;\n\tconst u8 *macaddr;\n\tconst char *name;\n\tu64 classes;\n\tint err = 0;\n\n\tif (!info->attrs[VDPA_ATTR_DEV_NAME])\n\t\treturn -EINVAL;\n\n\tname = nla_data(info->attrs[VDPA_ATTR_DEV_NAME]);\n\n\tif (nl_attrs[VDPA_ATTR_DEV_NET_CFG_MACADDR]) {\n\t\tmacaddr = nla_data(nl_attrs[VDPA_ATTR_DEV_NET_CFG_MACADDR]);\n\t\tmemcpy(config.net.mac, macaddr, sizeof(config.net.mac));\n\t\tconfig.mask |= BIT_ULL(VDPA_ATTR_DEV_NET_CFG_MACADDR);\n\t}\n\tif (nl_attrs[VDPA_ATTR_DEV_NET_CFG_MTU]) {\n\t\tconfig.net.mtu =\n\t\t\tnla_get_u16(nl_attrs[VDPA_ATTR_DEV_NET_CFG_MTU]);\n\t\tconfig.mask |= BIT_ULL(VDPA_ATTR_DEV_NET_CFG_MTU);\n\t}\n\tif (nl_attrs[VDPA_ATTR_DEV_NET_CFG_MAX_VQP]) {\n\t\tconfig.net.max_vq_pairs =\n\t\t\tnla_get_u16(nl_attrs[VDPA_ATTR_DEV_NET_CFG_MAX_VQP]);\n\t\tif (!config.net.max_vq_pairs) {\n\t\t\tNL_SET_ERR_MSG_MOD(info->extack,\n\t\t\t\t\t   \"At least one pair of VQs is required\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tconfig.mask |= BIT_ULL(VDPA_ATTR_DEV_NET_CFG_MAX_VQP);\n\t}\n\tif (nl_attrs[VDPA_ATTR_DEV_FEATURES]) {\n\t\tu64 missing = 0x0ULL;\n\n\t\tconfig.device_features =\n\t\t\tnla_get_u64(nl_attrs[VDPA_ATTR_DEV_FEATURES]);\n\t\tif (nl_attrs[VDPA_ATTR_DEV_NET_CFG_MACADDR] &&\n\t\t    !(config.device_features & BIT_ULL(VIRTIO_NET_F_MAC)))\n\t\t\tmissing |= BIT_ULL(VIRTIO_NET_F_MAC);\n\t\tif (nl_attrs[VDPA_ATTR_DEV_NET_CFG_MTU] &&\n\t\t    !(config.device_features & BIT_ULL(VIRTIO_NET_F_MTU)))\n\t\t\tmissing |= BIT_ULL(VIRTIO_NET_F_MTU);\n\t\tif (nl_attrs[VDPA_ATTR_DEV_NET_CFG_MAX_VQP] &&\n\t\t    config.net.max_vq_pairs > 1 &&\n\t\t    !(config.device_features & BIT_ULL(VIRTIO_NET_F_MQ)))\n\t\t\tmissing |= BIT_ULL(VIRTIO_NET_F_MQ);\n\t\tif (missing) {\n\t\t\tNL_SET_ERR_MSG_FMT_MOD(info->extack,\n\t\t\t\t\t       \"Missing features 0x%llx for provided attributes\",\n\t\t\t\t\t       missing);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tconfig.mask |= BIT_ULL(VDPA_ATTR_DEV_FEATURES);\n\t}\n\n\t \n\tif ((config.mask & VDPA_DEV_NET_ATTRS_MASK) &&\n\t    !netlink_capable(skb, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tdown_write(&vdpa_dev_lock);\n\tmdev = vdpa_mgmtdev_get_from_attr(info->attrs);\n\tif (IS_ERR(mdev)) {\n\t\tNL_SET_ERR_MSG_MOD(info->extack, \"Fail to find the specified management device\");\n\t\terr = PTR_ERR(mdev);\n\t\tgoto err;\n\t}\n\n\tif ((config.mask & mdev->config_attr_mask) != config.mask) {\n\t\tNL_SET_ERR_MSG_FMT_MOD(info->extack,\n\t\t\t\t       \"Some provided attributes are not supported: 0x%llx\",\n\t\t\t\t       config.mask & ~mdev->config_attr_mask);\n\t\terr = -EOPNOTSUPP;\n\t\tgoto err;\n\t}\n\n\tclasses = vdpa_mgmtdev_get_classes(mdev, &ncls);\n\tif (config.mask & VDPA_DEV_NET_ATTRS_MASK &&\n\t    !(classes & BIT_ULL(VIRTIO_ID_NET))) {\n\t\tNL_SET_ERR_MSG_MOD(info->extack,\n\t\t\t\t   \"Network class attributes provided on unsupported management device\");\n\t\terr = -EINVAL;\n\t\tgoto err;\n\t}\n\tif (!(config.mask & VDPA_DEV_NET_ATTRS_MASK) &&\n\t    config.mask & BIT_ULL(VDPA_ATTR_DEV_FEATURES) &&\n\t    classes & BIT_ULL(VIRTIO_ID_NET) && ncls > 1 &&\n\t    config.device_features & VIRTIO_DEVICE_F_MASK) {\n\t\tNL_SET_ERR_MSG_MOD(info->extack,\n\t\t\t\t   \"Management device supports multi-class while device features specified are ambiguous\");\n\t\terr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\terr = mdev->ops->dev_add(mdev, name, &config);\nerr:\n\tup_write(&vdpa_dev_lock);\n\treturn err;\n}\n\nstatic int vdpa_nl_cmd_dev_del_set_doit(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct vdpa_mgmt_dev *mdev;\n\tstruct vdpa_device *vdev;\n\tstruct device *dev;\n\tconst char *name;\n\tint err = 0;\n\n\tif (!info->attrs[VDPA_ATTR_DEV_NAME])\n\t\treturn -EINVAL;\n\tname = nla_data(info->attrs[VDPA_ATTR_DEV_NAME]);\n\n\tdown_write(&vdpa_dev_lock);\n\tdev = bus_find_device(&vdpa_bus, NULL, name, vdpa_name_match);\n\tif (!dev) {\n\t\tNL_SET_ERR_MSG_MOD(info->extack, \"device not found\");\n\t\terr = -ENODEV;\n\t\tgoto dev_err;\n\t}\n\tvdev = container_of(dev, struct vdpa_device, dev);\n\tif (!vdev->mdev) {\n\t\tNL_SET_ERR_MSG_MOD(info->extack, \"Only user created device can be deleted by user\");\n\t\terr = -EINVAL;\n\t\tgoto mdev_err;\n\t}\n\tmdev = vdev->mdev;\n\tmdev->ops->dev_del(mdev, vdev);\nmdev_err:\n\tput_device(dev);\ndev_err:\n\tup_write(&vdpa_dev_lock);\n\treturn err;\n}\n\nstatic int\nvdpa_dev_fill(struct vdpa_device *vdev, struct sk_buff *msg, u32 portid, u32 seq,\n\t      int flags, struct netlink_ext_ack *extack)\n{\n\tu16 max_vq_size;\n\tu16 min_vq_size = 1;\n\tu32 device_id;\n\tu32 vendor_id;\n\tvoid *hdr;\n\tint err;\n\n\thdr = genlmsg_put(msg, portid, seq, &vdpa_nl_family, flags, VDPA_CMD_DEV_NEW);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\n\terr = vdpa_nl_mgmtdev_handle_fill(msg, vdev->mdev);\n\tif (err)\n\t\tgoto msg_err;\n\n\tdevice_id = vdev->config->get_device_id(vdev);\n\tvendor_id = vdev->config->get_vendor_id(vdev);\n\tmax_vq_size = vdev->config->get_vq_num_max(vdev);\n\tif (vdev->config->get_vq_num_min)\n\t\tmin_vq_size = vdev->config->get_vq_num_min(vdev);\n\n\terr = -EMSGSIZE;\n\tif (nla_put_string(msg, VDPA_ATTR_DEV_NAME, dev_name(&vdev->dev)))\n\t\tgoto msg_err;\n\tif (nla_put_u32(msg, VDPA_ATTR_DEV_ID, device_id))\n\t\tgoto msg_err;\n\tif (nla_put_u32(msg, VDPA_ATTR_DEV_VENDOR_ID, vendor_id))\n\t\tgoto msg_err;\n\tif (nla_put_u32(msg, VDPA_ATTR_DEV_MAX_VQS, vdev->nvqs))\n\t\tgoto msg_err;\n\tif (nla_put_u16(msg, VDPA_ATTR_DEV_MAX_VQ_SIZE, max_vq_size))\n\t\tgoto msg_err;\n\tif (nla_put_u16(msg, VDPA_ATTR_DEV_MIN_VQ_SIZE, min_vq_size))\n\t\tgoto msg_err;\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\nmsg_err:\n\tgenlmsg_cancel(msg, hdr);\n\treturn err;\n}\n\nstatic int vdpa_nl_cmd_dev_get_doit(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct vdpa_device *vdev;\n\tstruct sk_buff *msg;\n\tconst char *devname;\n\tstruct device *dev;\n\tint err;\n\n\tif (!info->attrs[VDPA_ATTR_DEV_NAME])\n\t\treturn -EINVAL;\n\tdevname = nla_data(info->attrs[VDPA_ATTR_DEV_NAME]);\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tdown_read(&vdpa_dev_lock);\n\tdev = bus_find_device(&vdpa_bus, NULL, devname, vdpa_name_match);\n\tif (!dev) {\n\t\tNL_SET_ERR_MSG_MOD(info->extack, \"device not found\");\n\t\terr = -ENODEV;\n\t\tgoto err;\n\t}\n\tvdev = container_of(dev, struct vdpa_device, dev);\n\tif (!vdev->mdev) {\n\t\terr = -EINVAL;\n\t\tgoto mdev_err;\n\t}\n\terr = vdpa_dev_fill(vdev, msg, info->snd_portid, info->snd_seq, 0, info->extack);\n\tif (err)\n\t\tgoto mdev_err;\n\n\terr = genlmsg_reply(msg, info);\n\tput_device(dev);\n\tup_read(&vdpa_dev_lock);\n\treturn err;\n\nmdev_err:\n\tput_device(dev);\nerr:\n\tup_read(&vdpa_dev_lock);\n\tnlmsg_free(msg);\n\treturn err;\n}\n\nstruct vdpa_dev_dump_info {\n\tstruct sk_buff *msg;\n\tstruct netlink_callback *cb;\n\tint start_idx;\n\tint idx;\n};\n\nstatic int vdpa_dev_dump(struct device *dev, void *data)\n{\n\tstruct vdpa_device *vdev = container_of(dev, struct vdpa_device, dev);\n\tstruct vdpa_dev_dump_info *info = data;\n\tint err;\n\n\tif (!vdev->mdev)\n\t\treturn 0;\n\tif (info->idx < info->start_idx) {\n\t\tinfo->idx++;\n\t\treturn 0;\n\t}\n\terr = vdpa_dev_fill(vdev, info->msg, NETLINK_CB(info->cb->skb).portid,\n\t\t\t    info->cb->nlh->nlmsg_seq, NLM_F_MULTI, info->cb->extack);\n\tif (err)\n\t\treturn err;\n\n\tinfo->idx++;\n\treturn 0;\n}\n\nstatic int vdpa_nl_cmd_dev_get_dumpit(struct sk_buff *msg, struct netlink_callback *cb)\n{\n\tstruct vdpa_dev_dump_info info;\n\n\tinfo.msg = msg;\n\tinfo.cb = cb;\n\tinfo.start_idx = cb->args[0];\n\tinfo.idx = 0;\n\n\tdown_read(&vdpa_dev_lock);\n\tbus_for_each_dev(&vdpa_bus, NULL, &info, vdpa_dev_dump);\n\tup_read(&vdpa_dev_lock);\n\tcb->args[0] = info.idx;\n\treturn msg->len;\n}\n\nstatic int vdpa_dev_net_mq_config_fill(struct sk_buff *msg, u64 features,\n\t\t\t\t       const struct virtio_net_config *config)\n{\n\tu16 val_u16;\n\n\tif ((features & BIT_ULL(VIRTIO_NET_F_MQ)) == 0 &&\n\t    (features & BIT_ULL(VIRTIO_NET_F_RSS)) == 0)\n\t\treturn 0;\n\n\tval_u16 = __virtio16_to_cpu(true, config->max_virtqueue_pairs);\n\n\treturn nla_put_u16(msg, VDPA_ATTR_DEV_NET_CFG_MAX_VQP, val_u16);\n}\n\nstatic int vdpa_dev_net_mtu_config_fill(struct sk_buff *msg, u64 features,\n\t\t\t\t\tconst struct virtio_net_config *config)\n{\n\tu16 val_u16;\n\n\tif ((features & BIT_ULL(VIRTIO_NET_F_MTU)) == 0)\n\t\treturn 0;\n\n\tval_u16 = __virtio16_to_cpu(true, config->mtu);\n\n\treturn nla_put_u16(msg, VDPA_ATTR_DEV_NET_CFG_MTU, val_u16);\n}\n\nstatic int vdpa_dev_net_mac_config_fill(struct sk_buff *msg, u64 features,\n\t\t\t\t\tconst struct virtio_net_config *config)\n{\n\tif ((features & BIT_ULL(VIRTIO_NET_F_MAC)) == 0)\n\t\treturn 0;\n\n\treturn  nla_put(msg, VDPA_ATTR_DEV_NET_CFG_MACADDR,\n\t\t\tsizeof(config->mac), config->mac);\n}\n\nstatic int vdpa_dev_net_status_config_fill(struct sk_buff *msg, u64 features,\n\t\t\t\t\t   const struct virtio_net_config *config)\n{\n\tu16 val_u16;\n\n\tif ((features & BIT_ULL(VIRTIO_NET_F_STATUS)) == 0)\n\t\treturn 0;\n\n\tval_u16 = __virtio16_to_cpu(true, config->status);\n\treturn nla_put_u16(msg, VDPA_ATTR_DEV_NET_STATUS, val_u16);\n}\n\nstatic int vdpa_dev_net_config_fill(struct vdpa_device *vdev, struct sk_buff *msg)\n{\n\tstruct virtio_net_config config = {};\n\tu64 features_device;\n\n\tvdev->config->get_config(vdev, 0, &config, sizeof(config));\n\n\tfeatures_device = vdev->config->get_device_features(vdev);\n\n\tif (nla_put_u64_64bit(msg, VDPA_ATTR_DEV_FEATURES, features_device,\n\t\t\t      VDPA_ATTR_PAD))\n\t\treturn -EMSGSIZE;\n\n\tif (vdpa_dev_net_mtu_config_fill(msg, features_device, &config))\n\t\treturn -EMSGSIZE;\n\n\tif (vdpa_dev_net_mac_config_fill(msg, features_device, &config))\n\t\treturn -EMSGSIZE;\n\n\tif (vdpa_dev_net_status_config_fill(msg, features_device, &config))\n\t\treturn -EMSGSIZE;\n\n\treturn vdpa_dev_net_mq_config_fill(msg, features_device, &config);\n}\n\nstatic int\nvdpa_dev_config_fill(struct vdpa_device *vdev, struct sk_buff *msg, u32 portid, u32 seq,\n\t\t     int flags, struct netlink_ext_ack *extack)\n{\n\tu64 features_driver;\n\tu8 status = 0;\n\tu32 device_id;\n\tvoid *hdr;\n\tint err;\n\n\tdown_read(&vdev->cf_lock);\n\thdr = genlmsg_put(msg, portid, seq, &vdpa_nl_family, flags,\n\t\t\t  VDPA_CMD_DEV_CONFIG_GET);\n\tif (!hdr) {\n\t\terr = -EMSGSIZE;\n\t\tgoto out;\n\t}\n\n\tif (nla_put_string(msg, VDPA_ATTR_DEV_NAME, dev_name(&vdev->dev))) {\n\t\terr = -EMSGSIZE;\n\t\tgoto msg_err;\n\t}\n\n\tdevice_id = vdev->config->get_device_id(vdev);\n\tif (nla_put_u32(msg, VDPA_ATTR_DEV_ID, device_id)) {\n\t\terr = -EMSGSIZE;\n\t\tgoto msg_err;\n\t}\n\n\t \n\tstatus = vdev->config->get_status(vdev);\n\tif (status & VIRTIO_CONFIG_S_FEATURES_OK) {\n\t\tfeatures_driver = vdev->config->get_driver_features(vdev);\n\t\tif (nla_put_u64_64bit(msg, VDPA_ATTR_DEV_NEGOTIATED_FEATURES, features_driver,\n\t\t\t\t      VDPA_ATTR_PAD)) {\n\t\t\terr = -EMSGSIZE;\n\t\t\tgoto msg_err;\n\t\t}\n\t}\n\n\tswitch (device_id) {\n\tcase VIRTIO_ID_NET:\n\t\terr = vdpa_dev_net_config_fill(vdev, msg);\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\tif (err)\n\t\tgoto msg_err;\n\n\tup_read(&vdev->cf_lock);\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\nmsg_err:\n\tgenlmsg_cancel(msg, hdr);\nout:\n\tup_read(&vdev->cf_lock);\n\treturn err;\n}\n\nstatic int vdpa_fill_stats_rec(struct vdpa_device *vdev, struct sk_buff *msg,\n\t\t\t       struct genl_info *info, u32 index)\n{\n\tstruct virtio_net_config config = {};\n\tu64 features;\n\tu8 status;\n\tint err;\n\n\tstatus = vdev->config->get_status(vdev);\n\tif (!(status & VIRTIO_CONFIG_S_FEATURES_OK)) {\n\t\tNL_SET_ERR_MSG_MOD(info->extack, \"feature negotiation not complete\");\n\t\treturn -EAGAIN;\n\t}\n\tvdpa_get_config_unlocked(vdev, 0, &config, sizeof(config));\n\n\tfeatures = vdev->config->get_driver_features(vdev);\n\tif (nla_put_u64_64bit(msg, VDPA_ATTR_DEV_NEGOTIATED_FEATURES,\n\t\t\t      features, VDPA_ATTR_PAD))\n\t\treturn -EMSGSIZE;\n\n\terr = vdpa_dev_net_mq_config_fill(msg, features, &config);\n\tif (err)\n\t\treturn err;\n\n\tif (nla_put_u32(msg, VDPA_ATTR_DEV_QUEUE_INDEX, index))\n\t\treturn -EMSGSIZE;\n\n\terr = vdev->config->get_vendor_vq_stats(vdev, index, msg, info->extack);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int vendor_stats_fill(struct vdpa_device *vdev, struct sk_buff *msg,\n\t\t\t     struct genl_info *info, u32 index)\n{\n\tint err;\n\n\tdown_read(&vdev->cf_lock);\n\tif (!vdev->config->get_vendor_vq_stats) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\terr = vdpa_fill_stats_rec(vdev, msg, info, index);\nout:\n\tup_read(&vdev->cf_lock);\n\treturn err;\n}\n\nstatic int vdpa_dev_vendor_stats_fill(struct vdpa_device *vdev,\n\t\t\t\t      struct sk_buff *msg,\n\t\t\t\t      struct genl_info *info, u32 index)\n{\n\tu32 device_id;\n\tvoid *hdr;\n\tint err;\n\tu32 portid = info->snd_portid;\n\tu32 seq = info->snd_seq;\n\tu32 flags = 0;\n\n\thdr = genlmsg_put(msg, portid, seq, &vdpa_nl_family, flags,\n\t\t\t  VDPA_CMD_DEV_VSTATS_GET);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_string(msg, VDPA_ATTR_DEV_NAME, dev_name(&vdev->dev))) {\n\t\terr = -EMSGSIZE;\n\t\tgoto undo_msg;\n\t}\n\n\tdevice_id = vdev->config->get_device_id(vdev);\n\tif (nla_put_u32(msg, VDPA_ATTR_DEV_ID, device_id)) {\n\t\terr = -EMSGSIZE;\n\t\tgoto undo_msg;\n\t}\n\n\tswitch (device_id) {\n\tcase VIRTIO_ID_NET:\n\t\tif (index > VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MAX) {\n\t\t\tNL_SET_ERR_MSG_MOD(info->extack, \"queue index exceeds max value\");\n\t\t\terr = -ERANGE;\n\t\t\tbreak;\n\t\t}\n\n\t\terr = vendor_stats_fill(vdev, msg, info, index);\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\tgenlmsg_end(msg, hdr);\n\n\treturn err;\n\nundo_msg:\n\tgenlmsg_cancel(msg, hdr);\n\treturn err;\n}\n\nstatic int vdpa_nl_cmd_dev_config_get_doit(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct vdpa_device *vdev;\n\tstruct sk_buff *msg;\n\tconst char *devname;\n\tstruct device *dev;\n\tint err;\n\n\tif (!info->attrs[VDPA_ATTR_DEV_NAME])\n\t\treturn -EINVAL;\n\tdevname = nla_data(info->attrs[VDPA_ATTR_DEV_NAME]);\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tdown_read(&vdpa_dev_lock);\n\tdev = bus_find_device(&vdpa_bus, NULL, devname, vdpa_name_match);\n\tif (!dev) {\n\t\tNL_SET_ERR_MSG_MOD(info->extack, \"device not found\");\n\t\terr = -ENODEV;\n\t\tgoto dev_err;\n\t}\n\tvdev = container_of(dev, struct vdpa_device, dev);\n\tif (!vdev->mdev) {\n\t\tNL_SET_ERR_MSG_MOD(info->extack, \"unmanaged vdpa device\");\n\t\terr = -EINVAL;\n\t\tgoto mdev_err;\n\t}\n\terr = vdpa_dev_config_fill(vdev, msg, info->snd_portid, info->snd_seq,\n\t\t\t\t   0, info->extack);\n\tif (!err)\n\t\terr = genlmsg_reply(msg, info);\n\nmdev_err:\n\tput_device(dev);\ndev_err:\n\tup_read(&vdpa_dev_lock);\n\tif (err)\n\t\tnlmsg_free(msg);\n\treturn err;\n}\n\nstatic int vdpa_dev_config_dump(struct device *dev, void *data)\n{\n\tstruct vdpa_device *vdev = container_of(dev, struct vdpa_device, dev);\n\tstruct vdpa_dev_dump_info *info = data;\n\tint err;\n\n\tif (!vdev->mdev)\n\t\treturn 0;\n\tif (info->idx < info->start_idx) {\n\t\tinfo->idx++;\n\t\treturn 0;\n\t}\n\terr = vdpa_dev_config_fill(vdev, info->msg, NETLINK_CB(info->cb->skb).portid,\n\t\t\t\t   info->cb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\t   info->cb->extack);\n\tif (err)\n\t\treturn err;\n\n\tinfo->idx++;\n\treturn 0;\n}\n\nstatic int\nvdpa_nl_cmd_dev_config_get_dumpit(struct sk_buff *msg, struct netlink_callback *cb)\n{\n\tstruct vdpa_dev_dump_info info;\n\n\tinfo.msg = msg;\n\tinfo.cb = cb;\n\tinfo.start_idx = cb->args[0];\n\tinfo.idx = 0;\n\n\tdown_read(&vdpa_dev_lock);\n\tbus_for_each_dev(&vdpa_bus, NULL, &info, vdpa_dev_config_dump);\n\tup_read(&vdpa_dev_lock);\n\tcb->args[0] = info.idx;\n\treturn msg->len;\n}\n\nstatic int vdpa_nl_cmd_dev_stats_get_doit(struct sk_buff *skb,\n\t\t\t\t\t  struct genl_info *info)\n{\n\tstruct vdpa_device *vdev;\n\tstruct sk_buff *msg;\n\tconst char *devname;\n\tstruct device *dev;\n\tu32 index;\n\tint err;\n\n\tif (!info->attrs[VDPA_ATTR_DEV_NAME])\n\t\treturn -EINVAL;\n\n\tif (!info->attrs[VDPA_ATTR_DEV_QUEUE_INDEX])\n\t\treturn -EINVAL;\n\n\tdevname = nla_data(info->attrs[VDPA_ATTR_DEV_NAME]);\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tindex = nla_get_u32(info->attrs[VDPA_ATTR_DEV_QUEUE_INDEX]);\n\tdown_read(&vdpa_dev_lock);\n\tdev = bus_find_device(&vdpa_bus, NULL, devname, vdpa_name_match);\n\tif (!dev) {\n\t\tNL_SET_ERR_MSG_MOD(info->extack, \"device not found\");\n\t\terr = -ENODEV;\n\t\tgoto dev_err;\n\t}\n\tvdev = container_of(dev, struct vdpa_device, dev);\n\tif (!vdev->mdev) {\n\t\tNL_SET_ERR_MSG_MOD(info->extack, \"unmanaged vdpa device\");\n\t\terr = -EINVAL;\n\t\tgoto mdev_err;\n\t}\n\terr = vdpa_dev_vendor_stats_fill(vdev, msg, info, index);\n\tif (err)\n\t\tgoto mdev_err;\n\n\terr = genlmsg_reply(msg, info);\n\n\tput_device(dev);\n\tup_read(&vdpa_dev_lock);\n\n\treturn err;\n\nmdev_err:\n\tput_device(dev);\ndev_err:\n\tnlmsg_free(msg);\n\tup_read(&vdpa_dev_lock);\n\treturn err;\n}\n\nstatic const struct nla_policy vdpa_nl_policy[VDPA_ATTR_MAX + 1] = {\n\t[VDPA_ATTR_MGMTDEV_BUS_NAME] = { .type = NLA_NUL_STRING },\n\t[VDPA_ATTR_MGMTDEV_DEV_NAME] = { .type = NLA_STRING },\n\t[VDPA_ATTR_DEV_NAME] = { .type = NLA_STRING },\n\t[VDPA_ATTR_DEV_NET_CFG_MACADDR] = NLA_POLICY_ETH_ADDR,\n\t[VDPA_ATTR_DEV_NET_CFG_MAX_VQP] = { .type = NLA_U16 },\n\t \n\t[VDPA_ATTR_DEV_NET_CFG_MTU] = NLA_POLICY_MIN(NLA_U16, 68),\n\t[VDPA_ATTR_DEV_QUEUE_INDEX] = { .type = NLA_U32 },\n\t[VDPA_ATTR_DEV_FEATURES] = { .type = NLA_U64 },\n};\n\nstatic const struct genl_ops vdpa_nl_ops[] = {\n\t{\n\t\t.cmd = VDPA_CMD_MGMTDEV_GET,\n\t\t.doit = vdpa_nl_cmd_mgmtdev_get_doit,\n\t\t.dumpit = vdpa_nl_cmd_mgmtdev_get_dumpit,\n\t},\n\t{\n\t\t.cmd = VDPA_CMD_DEV_NEW,\n\t\t.doit = vdpa_nl_cmd_dev_add_set_doit,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = VDPA_CMD_DEV_DEL,\n\t\t.doit = vdpa_nl_cmd_dev_del_set_doit,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = VDPA_CMD_DEV_GET,\n\t\t.doit = vdpa_nl_cmd_dev_get_doit,\n\t\t.dumpit = vdpa_nl_cmd_dev_get_dumpit,\n\t},\n\t{\n\t\t.cmd = VDPA_CMD_DEV_CONFIG_GET,\n\t\t.doit = vdpa_nl_cmd_dev_config_get_doit,\n\t\t.dumpit = vdpa_nl_cmd_dev_config_get_dumpit,\n\t},\n\t{\n\t\t.cmd = VDPA_CMD_DEV_VSTATS_GET,\n\t\t.doit = vdpa_nl_cmd_dev_stats_get_doit,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n};\n\nstatic struct genl_family vdpa_nl_family __ro_after_init = {\n\t.name = VDPA_GENL_NAME,\n\t.version = VDPA_GENL_VERSION,\n\t.maxattr = VDPA_ATTR_MAX,\n\t.policy = vdpa_nl_policy,\n\t.netnsok = false,\n\t.module = THIS_MODULE,\n\t.ops = vdpa_nl_ops,\n\t.n_ops = ARRAY_SIZE(vdpa_nl_ops),\n\t.resv_start_op = VDPA_CMD_DEV_VSTATS_GET + 1,\n};\n\nstatic int vdpa_init(void)\n{\n\tint err;\n\n\terr = bus_register(&vdpa_bus);\n\tif (err)\n\t\treturn err;\n\terr = genl_register_family(&vdpa_nl_family);\n\tif (err)\n\t\tgoto err;\n\treturn 0;\n\nerr:\n\tbus_unregister(&vdpa_bus);\n\treturn err;\n}\n\nstatic void __exit vdpa_exit(void)\n{\n\tgenl_unregister_family(&vdpa_nl_family);\n\tbus_unregister(&vdpa_bus);\n\tida_destroy(&vdpa_index_ida);\n}\ncore_initcall(vdpa_init);\nmodule_exit(vdpa_exit);\n\nMODULE_AUTHOR(\"Jason Wang <jasowang@redhat.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}