{
  "module_name": "eni_vdpa.c",
  "hash_id": "ebe8f5972598660cd662e1e0c1c07bf27d4de4c50582426aa848210a52a76d4e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/vdpa/alibaba/eni_vdpa.c",
  "human_readable_source": "\n \n\n#include \"linux/bits.h\"\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/vdpa.h>\n#include <linux/virtio.h>\n#include <linux/virtio_config.h>\n#include <linux/virtio_ring.h>\n#include <linux/virtio_pci.h>\n#include <linux/virtio_pci_legacy.h>\n#include <uapi/linux/virtio_net.h>\n\n#define ENI_MSIX_NAME_SIZE 256\n\n#define ENI_ERR(pdev, fmt, ...)\t\\\n\tdev_err(&pdev->dev, \"%s\"fmt, \"eni_vdpa: \", ##__VA_ARGS__)\n#define ENI_DBG(pdev, fmt, ...)\t\\\n\tdev_dbg(&pdev->dev, \"%s\"fmt, \"eni_vdpa: \", ##__VA_ARGS__)\n#define ENI_INFO(pdev, fmt, ...) \\\n\tdev_info(&pdev->dev, \"%s\"fmt, \"eni_vdpa: \", ##__VA_ARGS__)\n\nstruct eni_vring {\n\tvoid __iomem *notify;\n\tchar msix_name[ENI_MSIX_NAME_SIZE];\n\tstruct vdpa_callback cb;\n\tint irq;\n};\n\nstruct eni_vdpa {\n\tstruct vdpa_device vdpa;\n\tstruct virtio_pci_legacy_device ldev;\n\tstruct eni_vring *vring;\n\tstruct vdpa_callback config_cb;\n\tchar msix_name[ENI_MSIX_NAME_SIZE];\n\tint config_irq;\n\tint queues;\n\tint vectors;\n};\n\nstatic struct eni_vdpa *vdpa_to_eni(struct vdpa_device *vdpa)\n{\n\treturn container_of(vdpa, struct eni_vdpa, vdpa);\n}\n\nstatic struct virtio_pci_legacy_device *vdpa_to_ldev(struct vdpa_device *vdpa)\n{\n\tstruct eni_vdpa *eni_vdpa = vdpa_to_eni(vdpa);\n\n\treturn &eni_vdpa->ldev;\n}\n\nstatic u64 eni_vdpa_get_device_features(struct vdpa_device *vdpa)\n{\n\tstruct virtio_pci_legacy_device *ldev = vdpa_to_ldev(vdpa);\n\tu64 features = vp_legacy_get_features(ldev);\n\n\tfeatures |= BIT_ULL(VIRTIO_F_ACCESS_PLATFORM);\n\tfeatures |= BIT_ULL(VIRTIO_F_ORDER_PLATFORM);\n\n\treturn features;\n}\n\nstatic int eni_vdpa_set_driver_features(struct vdpa_device *vdpa, u64 features)\n{\n\tstruct virtio_pci_legacy_device *ldev = vdpa_to_ldev(vdpa);\n\n\tif (!(features & BIT_ULL(VIRTIO_NET_F_MRG_RXBUF)) && features) {\n\t\tENI_ERR(ldev->pci_dev,\n\t\t\t\"VIRTIO_NET_F_MRG_RXBUF is not negotiated\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tvp_legacy_set_features(ldev, (u32)features);\n\n\treturn 0;\n}\n\nstatic u64 eni_vdpa_get_driver_features(struct vdpa_device *vdpa)\n{\n\tstruct virtio_pci_legacy_device *ldev = vdpa_to_ldev(vdpa);\n\n\treturn vp_legacy_get_driver_features(ldev);\n}\n\nstatic u8 eni_vdpa_get_status(struct vdpa_device *vdpa)\n{\n\tstruct virtio_pci_legacy_device *ldev = vdpa_to_ldev(vdpa);\n\n\treturn vp_legacy_get_status(ldev);\n}\n\nstatic int eni_vdpa_get_vq_irq(struct vdpa_device *vdpa, u16 idx)\n{\n\tstruct eni_vdpa *eni_vdpa = vdpa_to_eni(vdpa);\n\tint irq = eni_vdpa->vring[idx].irq;\n\n\tif (irq == VIRTIO_MSI_NO_VECTOR)\n\t\treturn -EINVAL;\n\n\treturn irq;\n}\n\nstatic void eni_vdpa_free_irq(struct eni_vdpa *eni_vdpa)\n{\n\tstruct virtio_pci_legacy_device *ldev = &eni_vdpa->ldev;\n\tstruct pci_dev *pdev = ldev->pci_dev;\n\tint i;\n\n\tfor (i = 0; i < eni_vdpa->queues; i++) {\n\t\tif (eni_vdpa->vring[i].irq != VIRTIO_MSI_NO_VECTOR) {\n\t\t\tvp_legacy_queue_vector(ldev, i, VIRTIO_MSI_NO_VECTOR);\n\t\t\tdevm_free_irq(&pdev->dev, eni_vdpa->vring[i].irq,\n\t\t\t\t      &eni_vdpa->vring[i]);\n\t\t\teni_vdpa->vring[i].irq = VIRTIO_MSI_NO_VECTOR;\n\t\t}\n\t}\n\n\tif (eni_vdpa->config_irq != VIRTIO_MSI_NO_VECTOR) {\n\t\tvp_legacy_config_vector(ldev, VIRTIO_MSI_NO_VECTOR);\n\t\tdevm_free_irq(&pdev->dev, eni_vdpa->config_irq, eni_vdpa);\n\t\teni_vdpa->config_irq = VIRTIO_MSI_NO_VECTOR;\n\t}\n\n\tif (eni_vdpa->vectors) {\n\t\tpci_free_irq_vectors(pdev);\n\t\teni_vdpa->vectors = 0;\n\t}\n}\n\nstatic irqreturn_t eni_vdpa_vq_handler(int irq, void *arg)\n{\n\tstruct eni_vring *vring = arg;\n\n\tif (vring->cb.callback)\n\t\treturn vring->cb.callback(vring->cb.private);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t eni_vdpa_config_handler(int irq, void *arg)\n{\n\tstruct eni_vdpa *eni_vdpa = arg;\n\n\tif (eni_vdpa->config_cb.callback)\n\t\treturn eni_vdpa->config_cb.callback(eni_vdpa->config_cb.private);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int eni_vdpa_request_irq(struct eni_vdpa *eni_vdpa)\n{\n\tstruct virtio_pci_legacy_device *ldev = &eni_vdpa->ldev;\n\tstruct pci_dev *pdev = ldev->pci_dev;\n\tint i, ret, irq;\n\tint queues = eni_vdpa->queues;\n\tint vectors = queues + 1;\n\n\tret = pci_alloc_irq_vectors(pdev, vectors, vectors, PCI_IRQ_MSIX);\n\tif (ret != vectors) {\n\t\tENI_ERR(pdev,\n\t\t\t\"failed to allocate irq vectors want %d but %d\\n\",\n\t\t\tvectors, ret);\n\t\treturn ret;\n\t}\n\n\teni_vdpa->vectors = vectors;\n\n\tfor (i = 0; i < queues; i++) {\n\t\tsnprintf(eni_vdpa->vring[i].msix_name, ENI_MSIX_NAME_SIZE,\n\t\t\t \"eni-vdpa[%s]-%d\\n\", pci_name(pdev), i);\n\t\tirq = pci_irq_vector(pdev, i);\n\t\tret = devm_request_irq(&pdev->dev, irq,\n\t\t\t\t       eni_vdpa_vq_handler,\n\t\t\t\t       0, eni_vdpa->vring[i].msix_name,\n\t\t\t\t       &eni_vdpa->vring[i]);\n\t\tif (ret) {\n\t\t\tENI_ERR(pdev, \"failed to request irq for vq %d\\n\", i);\n\t\t\tgoto err;\n\t\t}\n\t\tvp_legacy_queue_vector(ldev, i, i);\n\t\teni_vdpa->vring[i].irq = irq;\n\t}\n\n\tsnprintf(eni_vdpa->msix_name, ENI_MSIX_NAME_SIZE, \"eni-vdpa[%s]-config\\n\",\n\t\t pci_name(pdev));\n\tirq = pci_irq_vector(pdev, queues);\n\tret = devm_request_irq(&pdev->dev, irq, eni_vdpa_config_handler, 0,\n\t\t\t       eni_vdpa->msix_name, eni_vdpa);\n\tif (ret) {\n\t\tENI_ERR(pdev, \"failed to request irq for config vq %d\\n\", i);\n\t\tgoto err;\n\t}\n\tvp_legacy_config_vector(ldev, queues);\n\teni_vdpa->config_irq = irq;\n\n\treturn 0;\nerr:\n\teni_vdpa_free_irq(eni_vdpa);\n\treturn ret;\n}\n\nstatic void eni_vdpa_set_status(struct vdpa_device *vdpa, u8 status)\n{\n\tstruct eni_vdpa *eni_vdpa = vdpa_to_eni(vdpa);\n\tstruct virtio_pci_legacy_device *ldev = &eni_vdpa->ldev;\n\tu8 s = eni_vdpa_get_status(vdpa);\n\n\tif (status & VIRTIO_CONFIG_S_DRIVER_OK &&\n\t    !(s & VIRTIO_CONFIG_S_DRIVER_OK)) {\n\t\teni_vdpa_request_irq(eni_vdpa);\n\t}\n\n\tvp_legacy_set_status(ldev, status);\n\n\tif (!(status & VIRTIO_CONFIG_S_DRIVER_OK) &&\n\t    (s & VIRTIO_CONFIG_S_DRIVER_OK))\n\t\teni_vdpa_free_irq(eni_vdpa);\n}\n\nstatic int eni_vdpa_reset(struct vdpa_device *vdpa)\n{\n\tstruct eni_vdpa *eni_vdpa = vdpa_to_eni(vdpa);\n\tstruct virtio_pci_legacy_device *ldev = &eni_vdpa->ldev;\n\tu8 s = eni_vdpa_get_status(vdpa);\n\n\tvp_legacy_set_status(ldev, 0);\n\n\tif (s & VIRTIO_CONFIG_S_DRIVER_OK)\n\t\teni_vdpa_free_irq(eni_vdpa);\n\n\treturn 0;\n}\n\nstatic u16 eni_vdpa_get_vq_num_max(struct vdpa_device *vdpa)\n{\n\tstruct virtio_pci_legacy_device *ldev = vdpa_to_ldev(vdpa);\n\n\treturn vp_legacy_get_queue_size(ldev, 0);\n}\n\nstatic u16 eni_vdpa_get_vq_num_min(struct vdpa_device *vdpa)\n{\n\tstruct virtio_pci_legacy_device *ldev = vdpa_to_ldev(vdpa);\n\n\treturn vp_legacy_get_queue_size(ldev, 0);\n}\n\nstatic int eni_vdpa_get_vq_state(struct vdpa_device *vdpa, u16 qid,\n\t\t\t\tstruct vdpa_vq_state *state)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic int eni_vdpa_set_vq_state(struct vdpa_device *vdpa, u16 qid,\n\t\t\t\t const struct vdpa_vq_state *state)\n{\n\tstruct virtio_pci_legacy_device *ldev = vdpa_to_ldev(vdpa);\n\tconst struct vdpa_vq_state_split *split = &state->split;\n\n\t \n\tif (!vp_legacy_get_queue_enable(ldev, qid)\n\t    && split->avail_index == 0)\n\t\treturn 0;\n\n\treturn -EOPNOTSUPP;\n}\n\n\nstatic void eni_vdpa_set_vq_cb(struct vdpa_device *vdpa, u16 qid,\n\t\t\t       struct vdpa_callback *cb)\n{\n\tstruct eni_vdpa *eni_vdpa = vdpa_to_eni(vdpa);\n\n\teni_vdpa->vring[qid].cb = *cb;\n}\n\nstatic void eni_vdpa_set_vq_ready(struct vdpa_device *vdpa, u16 qid,\n\t\t\t\t  bool ready)\n{\n\tstruct virtio_pci_legacy_device *ldev = vdpa_to_ldev(vdpa);\n\n\t \n\tif (!ready)\n\t\tvp_legacy_set_queue_address(ldev, qid, 0);\n}\n\nstatic bool eni_vdpa_get_vq_ready(struct vdpa_device *vdpa, u16 qid)\n{\n\tstruct virtio_pci_legacy_device *ldev = vdpa_to_ldev(vdpa);\n\n\treturn vp_legacy_get_queue_enable(ldev, qid);\n}\n\nstatic void eni_vdpa_set_vq_num(struct vdpa_device *vdpa, u16 qid,\n\t\t\t       u32 num)\n{\n\tstruct virtio_pci_legacy_device *ldev = vdpa_to_ldev(vdpa);\n\tstruct pci_dev *pdev = ldev->pci_dev;\n\tu16 n = vp_legacy_get_queue_size(ldev, qid);\n\n\t \n\tif (num != n)\n\t\tENI_ERR(pdev,\n\t\t\t\"not support to set vq %u fixed num %u to %u\\n\",\n\t\t\tqid, n, num);\n}\n\nstatic int eni_vdpa_set_vq_address(struct vdpa_device *vdpa, u16 qid,\n\t\t\t\t   u64 desc_area, u64 driver_area,\n\t\t\t\t   u64 device_area)\n{\n\tstruct virtio_pci_legacy_device *ldev = vdpa_to_ldev(vdpa);\n\tu32 pfn = desc_area >> VIRTIO_PCI_QUEUE_ADDR_SHIFT;\n\n\tvp_legacy_set_queue_address(ldev, qid, pfn);\n\n\treturn 0;\n}\n\nstatic void eni_vdpa_kick_vq(struct vdpa_device *vdpa, u16 qid)\n{\n\tstruct eni_vdpa *eni_vdpa = vdpa_to_eni(vdpa);\n\n\tiowrite16(qid, eni_vdpa->vring[qid].notify);\n}\n\nstatic u32 eni_vdpa_get_device_id(struct vdpa_device *vdpa)\n{\n\tstruct virtio_pci_legacy_device *ldev = vdpa_to_ldev(vdpa);\n\n\treturn ldev->id.device;\n}\n\nstatic u32 eni_vdpa_get_vendor_id(struct vdpa_device *vdpa)\n{\n\tstruct virtio_pci_legacy_device *ldev = vdpa_to_ldev(vdpa);\n\n\treturn ldev->id.vendor;\n}\n\nstatic u32 eni_vdpa_get_vq_align(struct vdpa_device *vdpa)\n{\n\treturn VIRTIO_PCI_VRING_ALIGN;\n}\n\nstatic size_t eni_vdpa_get_config_size(struct vdpa_device *vdpa)\n{\n\treturn sizeof(struct virtio_net_config);\n}\n\n\nstatic void eni_vdpa_get_config(struct vdpa_device *vdpa,\n\t\t\t\tunsigned int offset,\n\t\t\t\tvoid *buf, unsigned int len)\n{\n\tstruct eni_vdpa *eni_vdpa = vdpa_to_eni(vdpa);\n\tstruct virtio_pci_legacy_device *ldev = &eni_vdpa->ldev;\n\tvoid __iomem *ioaddr = ldev->ioaddr +\n\t\tVIRTIO_PCI_CONFIG_OFF(eni_vdpa->vectors) +\n\t\toffset;\n\tu8 *p = buf;\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\t*p++ = ioread8(ioaddr + i);\n}\n\nstatic void eni_vdpa_set_config(struct vdpa_device *vdpa,\n\t\t\t\tunsigned int offset, const void *buf,\n\t\t\t\tunsigned int len)\n{\n\tstruct eni_vdpa *eni_vdpa = vdpa_to_eni(vdpa);\n\tstruct virtio_pci_legacy_device *ldev = &eni_vdpa->ldev;\n\tvoid __iomem *ioaddr = ldev->ioaddr +\n\t\tVIRTIO_PCI_CONFIG_OFF(eni_vdpa->vectors) +\n\t\toffset;\n\tconst u8 *p = buf;\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\tiowrite8(*p++, ioaddr + i);\n}\n\nstatic void eni_vdpa_set_config_cb(struct vdpa_device *vdpa,\n\t\t\t\t   struct vdpa_callback *cb)\n{\n\tstruct eni_vdpa *eni_vdpa = vdpa_to_eni(vdpa);\n\n\teni_vdpa->config_cb = *cb;\n}\n\nstatic const struct vdpa_config_ops eni_vdpa_ops = {\n\t.get_device_features = eni_vdpa_get_device_features,\n\t.set_driver_features = eni_vdpa_set_driver_features,\n\t.get_driver_features = eni_vdpa_get_driver_features,\n\t.get_status\t= eni_vdpa_get_status,\n\t.set_status\t= eni_vdpa_set_status,\n\t.reset\t\t= eni_vdpa_reset,\n\t.get_vq_num_max\t= eni_vdpa_get_vq_num_max,\n\t.get_vq_num_min\t= eni_vdpa_get_vq_num_min,\n\t.get_vq_state\t= eni_vdpa_get_vq_state,\n\t.set_vq_state\t= eni_vdpa_set_vq_state,\n\t.set_vq_cb\t= eni_vdpa_set_vq_cb,\n\t.set_vq_ready\t= eni_vdpa_set_vq_ready,\n\t.get_vq_ready\t= eni_vdpa_get_vq_ready,\n\t.set_vq_num\t= eni_vdpa_set_vq_num,\n\t.set_vq_address\t= eni_vdpa_set_vq_address,\n\t.kick_vq\t= eni_vdpa_kick_vq,\n\t.get_device_id\t= eni_vdpa_get_device_id,\n\t.get_vendor_id\t= eni_vdpa_get_vendor_id,\n\t.get_vq_align\t= eni_vdpa_get_vq_align,\n\t.get_config_size = eni_vdpa_get_config_size,\n\t.get_config\t= eni_vdpa_get_config,\n\t.set_config\t= eni_vdpa_set_config,\n\t.set_config_cb  = eni_vdpa_set_config_cb,\n\t.get_vq_irq\t= eni_vdpa_get_vq_irq,\n};\n\n\nstatic u16 eni_vdpa_get_num_queues(struct eni_vdpa *eni_vdpa)\n{\n\tstruct virtio_pci_legacy_device *ldev = &eni_vdpa->ldev;\n\tu32 features = vp_legacy_get_features(ldev);\n\tu16 num = 2;\n\n\tif (features & BIT_ULL(VIRTIO_NET_F_MQ)) {\n\t\t__virtio16 max_virtqueue_pairs;\n\n\t\teni_vdpa_get_config(&eni_vdpa->vdpa,\n\t\t\toffsetof(struct virtio_net_config, max_virtqueue_pairs),\n\t\t\t&max_virtqueue_pairs,\n\t\t\tsizeof(max_virtqueue_pairs));\n\t\tnum = 2 * __virtio16_to_cpu(virtio_legacy_is_little_endian(),\n\t\t\t\tmax_virtqueue_pairs);\n\t}\n\n\tif (features & BIT_ULL(VIRTIO_NET_F_CTRL_VQ))\n\t\tnum += 1;\n\n\treturn num;\n}\n\nstatic int eni_vdpa_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct eni_vdpa *eni_vdpa;\n\tstruct virtio_pci_legacy_device *ldev;\n\tint ret, i;\n\n\tret = pcim_enable_device(pdev);\n\tif (ret)\n\t\treturn ret;\n\n\teni_vdpa = vdpa_alloc_device(struct eni_vdpa, vdpa,\n\t\t\t\t     dev, &eni_vdpa_ops, 1, 1, NULL, false);\n\tif (IS_ERR(eni_vdpa)) {\n\t\tENI_ERR(pdev, \"failed to allocate vDPA structure\\n\");\n\t\treturn PTR_ERR(eni_vdpa);\n\t}\n\n\tldev = &eni_vdpa->ldev;\n\tldev->pci_dev = pdev;\n\n\tret = vp_legacy_probe(ldev);\n\tif (ret) {\n\t\tENI_ERR(pdev, \"failed to probe legacy PCI device\\n\");\n\t\tgoto err;\n\t}\n\n\tpci_set_master(pdev);\n\tpci_set_drvdata(pdev, eni_vdpa);\n\n\teni_vdpa->vdpa.dma_dev = &pdev->dev;\n\teni_vdpa->queues = eni_vdpa_get_num_queues(eni_vdpa);\n\n\teni_vdpa->vring = devm_kcalloc(&pdev->dev, eni_vdpa->queues,\n\t\t\t\t      sizeof(*eni_vdpa->vring),\n\t\t\t\t      GFP_KERNEL);\n\tif (!eni_vdpa->vring) {\n\t\tret = -ENOMEM;\n\t\tENI_ERR(pdev, \"failed to allocate virtqueues\\n\");\n\t\tgoto err_remove_vp_legacy;\n\t}\n\n\tfor (i = 0; i < eni_vdpa->queues; i++) {\n\t\teni_vdpa->vring[i].irq = VIRTIO_MSI_NO_VECTOR;\n\t\teni_vdpa->vring[i].notify = ldev->ioaddr + VIRTIO_PCI_QUEUE_NOTIFY;\n\t}\n\teni_vdpa->config_irq = VIRTIO_MSI_NO_VECTOR;\n\n\tret = vdpa_register_device(&eni_vdpa->vdpa, eni_vdpa->queues);\n\tif (ret) {\n\t\tENI_ERR(pdev, \"failed to register to vdpa bus\\n\");\n\t\tgoto err_remove_vp_legacy;\n\t}\n\n\treturn 0;\n\nerr_remove_vp_legacy:\n\tvp_legacy_remove(&eni_vdpa->ldev);\nerr:\n\tput_device(&eni_vdpa->vdpa.dev);\n\treturn ret;\n}\n\nstatic void eni_vdpa_remove(struct pci_dev *pdev)\n{\n\tstruct eni_vdpa *eni_vdpa = pci_get_drvdata(pdev);\n\n\tvdpa_unregister_device(&eni_vdpa->vdpa);\n\tvp_legacy_remove(&eni_vdpa->ldev);\n}\n\nstatic struct pci_device_id eni_pci_ids[] = {\n\t{ PCI_DEVICE_SUB(PCI_VENDOR_ID_REDHAT_QUMRANET,\n\t\t\t VIRTIO_TRANS_ID_NET,\n\t\t\t PCI_SUBVENDOR_ID_REDHAT_QUMRANET,\n\t\t\t VIRTIO_ID_NET) },\n\t{ 0 },\n};\n\nstatic struct pci_driver eni_vdpa_driver = {\n\t.name\t\t= \"alibaba-eni-vdpa\",\n\t.id_table\t= eni_pci_ids,\n\t.probe\t\t= eni_vdpa_probe,\n\t.remove\t\t= eni_vdpa_remove,\n};\n\nmodule_pci_driver(eni_vdpa_driver);\n\nMODULE_AUTHOR(\"Wu Zongyong <wuzongyong@linux.alibaba.com>\");\nMODULE_DESCRIPTION(\"Alibaba ENI vDPA driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}