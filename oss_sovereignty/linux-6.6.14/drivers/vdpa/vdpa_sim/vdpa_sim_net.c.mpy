{
  "module_name": "vdpa_sim_net.c",
  "hash_id": "f2698e9a507ed136cdf81f505e9ba396325a2647bba725da6d5b2291c4edfa1b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/vdpa/vdpa_sim/vdpa_sim_net.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/etherdevice.h>\n#include <linux/vringh.h>\n#include <linux/vdpa.h>\n#include <net/netlink.h>\n#include <uapi/linux/virtio_net.h>\n#include <uapi/linux/vdpa.h>\n\n#include \"vdpa_sim.h\"\n\n#define DRV_VERSION  \"0.1\"\n#define DRV_AUTHOR   \"Jason Wang <jasowang@redhat.com>\"\n#define DRV_DESC     \"vDPA Device Simulator for networking device\"\n#define DRV_LICENSE  \"GPL v2\"\n\n#define VDPASIM_NET_FEATURES\t(VDPASIM_FEATURES | \\\n\t\t\t\t (1ULL << VIRTIO_NET_F_MAC) | \\\n\t\t\t\t (1ULL << VIRTIO_NET_F_STATUS) | \\\n\t\t\t\t (1ULL << VIRTIO_NET_F_MTU) | \\\n\t\t\t\t (1ULL << VIRTIO_NET_F_CTRL_VQ) | \\\n\t\t\t\t (1ULL << VIRTIO_NET_F_CTRL_MAC_ADDR))\n\n \n#define VDPASIM_NET_VQ_NUM\t3\n#define VDPASIM_NET_AS_NUM\t2\n#define VDPASIM_NET_GROUP_NUM\t2\n\nstruct vdpasim_dataq_stats {\n\tstruct u64_stats_sync syncp;\n\tu64 pkts;\n\tu64 bytes;\n\tu64 drops;\n\tu64 errors;\n\tu64 overruns;\n};\n\nstruct vdpasim_cq_stats {\n\tstruct u64_stats_sync syncp;\n\tu64 requests;\n\tu64 successes;\n\tu64 errors;\n};\n\nstruct vdpasim_net{\n\tstruct vdpasim vdpasim;\n\tstruct vdpasim_dataq_stats tx_stats;\n\tstruct vdpasim_dataq_stats rx_stats;\n\tstruct vdpasim_cq_stats cq_stats;\n\tvoid *buffer;\n};\n\nstatic struct vdpasim_net *sim_to_net(struct vdpasim *vdpasim)\n{\n\treturn container_of(vdpasim, struct vdpasim_net, vdpasim);\n}\n\nstatic void vdpasim_net_complete(struct vdpasim_virtqueue *vq, size_t len)\n{\n\t \n\tsmp_wmb();\n\n\tvringh_complete_iotlb(&vq->vring, vq->head, len);\n\n\t \n\tsmp_wmb();\n\n\tlocal_bh_disable();\n\tif (vringh_need_notify_iotlb(&vq->vring) > 0)\n\t\tvringh_notify(&vq->vring);\n\tlocal_bh_enable();\n}\n\nstatic bool receive_filter(struct vdpasim *vdpasim, size_t len)\n{\n\tbool modern = vdpasim->features & (1ULL << VIRTIO_F_VERSION_1);\n\tsize_t hdr_len = modern ? sizeof(struct virtio_net_hdr_v1) :\n\t\t\t\t  sizeof(struct virtio_net_hdr);\n\tstruct virtio_net_config *vio_config = vdpasim->config;\n\tstruct vdpasim_net *net = sim_to_net(vdpasim);\n\n\tif (len < ETH_ALEN + hdr_len)\n\t\treturn false;\n\n\tif (is_broadcast_ether_addr(net->buffer + hdr_len) ||\n\t    is_multicast_ether_addr(net->buffer + hdr_len))\n\t\treturn true;\n\tif (!strncmp(net->buffer + hdr_len, vio_config->mac, ETH_ALEN))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic virtio_net_ctrl_ack vdpasim_handle_ctrl_mac(struct vdpasim *vdpasim,\n\t\t\t\t\t\t   u8 cmd)\n{\n\tstruct virtio_net_config *vio_config = vdpasim->config;\n\tstruct vdpasim_virtqueue *cvq = &vdpasim->vqs[2];\n\tvirtio_net_ctrl_ack status = VIRTIO_NET_ERR;\n\tsize_t read;\n\n\tswitch (cmd) {\n\tcase VIRTIO_NET_CTRL_MAC_ADDR_SET:\n\t\tread = vringh_iov_pull_iotlb(&cvq->vring, &cvq->in_iov,\n\t\t\t\t\t     vio_config->mac, ETH_ALEN);\n\t\tif (read == ETH_ALEN)\n\t\t\tstatus = VIRTIO_NET_OK;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn status;\n}\n\nstatic void vdpasim_handle_cvq(struct vdpasim *vdpasim)\n{\n\tstruct vdpasim_virtqueue *cvq = &vdpasim->vqs[2];\n\tstruct vdpasim_net *net = sim_to_net(vdpasim);\n\tvirtio_net_ctrl_ack status = VIRTIO_NET_ERR;\n\tstruct virtio_net_ctrl_hdr ctrl;\n\tsize_t read, write;\n\tu64 requests = 0, errors = 0, successes = 0;\n\tint err;\n\n\tif (!(vdpasim->features & (1ULL << VIRTIO_NET_F_CTRL_VQ)))\n\t\treturn;\n\n\tif (!cvq->ready)\n\t\treturn;\n\n\twhile (true) {\n\t\terr = vringh_getdesc_iotlb(&cvq->vring, &cvq->in_iov,\n\t\t\t\t\t   &cvq->out_iov,\n\t\t\t\t\t   &cvq->head, GFP_ATOMIC);\n\t\tif (err <= 0)\n\t\t\tbreak;\n\n\t\t++requests;\n\t\tread = vringh_iov_pull_iotlb(&cvq->vring, &cvq->in_iov, &ctrl,\n\t\t\t\t\t     sizeof(ctrl));\n\t\tif (read != sizeof(ctrl)) {\n\t\t\t++errors;\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (ctrl.class) {\n\t\tcase VIRTIO_NET_CTRL_MAC:\n\t\t\tstatus = vdpasim_handle_ctrl_mac(vdpasim, ctrl.cmd);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (status == VIRTIO_NET_OK)\n\t\t\t++successes;\n\t\telse\n\t\t\t++errors;\n\n\t\t \n\t\tsmp_wmb();\n\n\t\twrite = vringh_iov_push_iotlb(&cvq->vring, &cvq->out_iov,\n\t\t\t\t\t      &status, sizeof(status));\n\t\tvringh_complete_iotlb(&cvq->vring, cvq->head, write);\n\t\tvringh_kiov_cleanup(&cvq->in_iov);\n\t\tvringh_kiov_cleanup(&cvq->out_iov);\n\n\t\t \n\t\tsmp_wmb();\n\n\t\tlocal_bh_disable();\n\t\tif (cvq->cb)\n\t\t\tcvq->cb(cvq->private);\n\t\tlocal_bh_enable();\n\t}\n\n\tu64_stats_update_begin(&net->cq_stats.syncp);\n\tnet->cq_stats.requests += requests;\n\tnet->cq_stats.errors += errors;\n\tnet->cq_stats.successes += successes;\n\tu64_stats_update_end(&net->cq_stats.syncp);\n}\n\nstatic void vdpasim_net_work(struct vdpasim *vdpasim)\n{\n\tstruct vdpasim_virtqueue *txq = &vdpasim->vqs[1];\n\tstruct vdpasim_virtqueue *rxq = &vdpasim->vqs[0];\n\tstruct vdpasim_net *net = sim_to_net(vdpasim);\n\tssize_t read, write;\n\tu64 tx_pkts = 0, rx_pkts = 0, tx_bytes = 0, rx_bytes = 0;\n\tu64 rx_drops = 0, rx_overruns = 0, rx_errors = 0, tx_errors = 0;\n\tint err;\n\n\tmutex_lock(&vdpasim->mutex);\n\n\tif (!vdpasim->running)\n\t\tgoto out;\n\n\tif (!(vdpasim->status & VIRTIO_CONFIG_S_DRIVER_OK))\n\t\tgoto out;\n\n\tvdpasim_handle_cvq(vdpasim);\n\n\tif (!txq->ready || !rxq->ready)\n\t\tgoto out;\n\n\twhile (true) {\n\t\terr = vringh_getdesc_iotlb(&txq->vring, &txq->out_iov, NULL,\n\t\t\t\t\t   &txq->head, GFP_ATOMIC);\n\t\tif (err <= 0) {\n\t\t\tif (err)\n\t\t\t\t++tx_errors;\n\t\t\tbreak;\n\t\t}\n\n\t\t++tx_pkts;\n\t\tread = vringh_iov_pull_iotlb(&txq->vring, &txq->out_iov,\n\t\t\t\t\t     net->buffer, PAGE_SIZE);\n\n\t\ttx_bytes += read;\n\n\t\tif (!receive_filter(vdpasim, read)) {\n\t\t\t++rx_drops;\n\t\t\tvdpasim_net_complete(txq, 0);\n\t\t\tcontinue;\n\t\t}\n\n\t\terr = vringh_getdesc_iotlb(&rxq->vring, NULL, &rxq->in_iov,\n\t\t\t\t\t   &rxq->head, GFP_ATOMIC);\n\t\tif (err <= 0) {\n\t\t\t++rx_overruns;\n\t\t\tvdpasim_net_complete(txq, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\twrite = vringh_iov_push_iotlb(&rxq->vring, &rxq->in_iov,\n\t\t\t\t\t      net->buffer, read);\n\t\tif (write <= 0) {\n\t\t\t++rx_errors;\n\t\t\tbreak;\n\t\t}\n\n\t\t++rx_pkts;\n\t\trx_bytes += write;\n\n\t\tvdpasim_net_complete(txq, 0);\n\t\tvdpasim_net_complete(rxq, write);\n\n\t\tif (tx_pkts > 4) {\n\t\t\tvdpasim_schedule_work(vdpasim);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tmutex_unlock(&vdpasim->mutex);\n\n\tu64_stats_update_begin(&net->tx_stats.syncp);\n\tnet->tx_stats.pkts += tx_pkts;\n\tnet->tx_stats.bytes += tx_bytes;\n\tnet->tx_stats.errors += tx_errors;\n\tu64_stats_update_end(&net->tx_stats.syncp);\n\n\tu64_stats_update_begin(&net->rx_stats.syncp);\n\tnet->rx_stats.pkts += rx_pkts;\n\tnet->rx_stats.bytes += rx_bytes;\n\tnet->rx_stats.drops += rx_drops;\n\tnet->rx_stats.errors += rx_errors;\n\tnet->rx_stats.overruns += rx_overruns;\n\tu64_stats_update_end(&net->rx_stats.syncp);\n}\n\nstatic int vdpasim_net_get_stats(struct vdpasim *vdpasim, u16 idx,\n\t\t\t\t struct sk_buff *msg,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct vdpasim_net *net = sim_to_net(vdpasim);\n\tu64 rx_pkts, rx_bytes, rx_errors, rx_overruns, rx_drops;\n\tu64 tx_pkts, tx_bytes, tx_errors, tx_drops;\n\tu64 cq_requests, cq_successes, cq_errors;\n\tunsigned int start;\n\tint err = -EMSGSIZE;\n\n\tswitch(idx) {\n\tcase 0:\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin(&net->rx_stats.syncp);\n\t\t\trx_pkts = net->rx_stats.pkts;\n\t\t\trx_bytes = net->rx_stats.bytes;\n\t\t\trx_errors = net->rx_stats.errors;\n\t\t\trx_overruns = net->rx_stats.overruns;\n\t\t\trx_drops = net->rx_stats.drops;\n\t\t} while (u64_stats_fetch_retry(&net->rx_stats.syncp, start));\n\n\t\tif (nla_put_string(msg, VDPA_ATTR_DEV_VENDOR_ATTR_NAME,\n\t\t\t\t\t\"rx packets\"))\n\t\t\tbreak;\n\t\tif (nla_put_u64_64bit(msg, VDPA_ATTR_DEV_VENDOR_ATTR_VALUE,\n\t\t\t\t      rx_pkts, VDPA_ATTR_PAD))\n\t\t\tbreak;\n\t\tif (nla_put_string(msg, VDPA_ATTR_DEV_VENDOR_ATTR_NAME,\n\t\t\t\t  \"rx bytes\"))\n\t\t\tbreak;\n\t\tif (nla_put_u64_64bit(msg, VDPA_ATTR_DEV_VENDOR_ATTR_VALUE,\n\t\t\t\t      rx_bytes, VDPA_ATTR_PAD))\n\t\t\tbreak;\n\t\tif (nla_put_string(msg, VDPA_ATTR_DEV_VENDOR_ATTR_NAME,\n\t\t\t\t  \"rx errors\"))\n\t\t\tbreak;\n\t\tif (nla_put_u64_64bit(msg, VDPA_ATTR_DEV_VENDOR_ATTR_VALUE,\n\t\t\t\t      rx_errors, VDPA_ATTR_PAD))\n\t\t\tbreak;\n\t\tif (nla_put_string(msg, VDPA_ATTR_DEV_VENDOR_ATTR_NAME,\n\t\t\t\t  \"rx overruns\"))\n\t\t\tbreak;\n\t\tif (nla_put_u64_64bit(msg, VDPA_ATTR_DEV_VENDOR_ATTR_VALUE,\n\t\t\t\t      rx_overruns, VDPA_ATTR_PAD))\n\t\t\tbreak;\n\t\tif (nla_put_string(msg, VDPA_ATTR_DEV_VENDOR_ATTR_NAME,\n\t\t\t\t  \"rx drops\"))\n\t\t\tbreak;\n\t\tif (nla_put_u64_64bit(msg, VDPA_ATTR_DEV_VENDOR_ATTR_VALUE,\n\t\t\t\t      rx_drops, VDPA_ATTR_PAD))\n\t\t\tbreak;\n\t\terr = 0;\n\t\tbreak;\n\tcase 1:\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin(&net->tx_stats.syncp);\n\t\t\ttx_pkts = net->tx_stats.pkts;\n\t\t\ttx_bytes = net->tx_stats.bytes;\n\t\t\ttx_errors = net->tx_stats.errors;\n\t\t\ttx_drops = net->tx_stats.drops;\n\t\t} while (u64_stats_fetch_retry(&net->tx_stats.syncp, start));\n\n\t\tif (nla_put_string(msg, VDPA_ATTR_DEV_VENDOR_ATTR_NAME,\n\t\t\t\t  \"tx packets\"))\n\t\t\tbreak;\n\t\tif (nla_put_u64_64bit(msg, VDPA_ATTR_DEV_VENDOR_ATTR_VALUE,\n\t\t\t\t      tx_pkts, VDPA_ATTR_PAD))\n\t\t\tbreak;\n\t\tif (nla_put_string(msg, VDPA_ATTR_DEV_VENDOR_ATTR_NAME,\n\t\t\t\t  \"tx bytes\"))\n\t\t\tbreak;\n\t\tif (nla_put_u64_64bit(msg, VDPA_ATTR_DEV_VENDOR_ATTR_VALUE,\n\t\t\t\t      tx_bytes, VDPA_ATTR_PAD))\n\t\t\tbreak;\n\t\tif (nla_put_string(msg, VDPA_ATTR_DEV_VENDOR_ATTR_NAME,\n\t\t\t\t  \"tx errors\"))\n\t\t\tbreak;\n\t\tif (nla_put_u64_64bit(msg, VDPA_ATTR_DEV_VENDOR_ATTR_VALUE,\n\t\t\t\t      tx_errors, VDPA_ATTR_PAD))\n\t\t\tbreak;\n\t\tif (nla_put_string(msg, VDPA_ATTR_DEV_VENDOR_ATTR_NAME,\n\t\t\t\t  \"tx drops\"))\n\t\t\tbreak;\n\t\tif (nla_put_u64_64bit(msg, VDPA_ATTR_DEV_VENDOR_ATTR_VALUE,\n\t\t\t\t      tx_drops, VDPA_ATTR_PAD))\n\t\t\tbreak;\n\t\terr = 0;\n\t\tbreak;\n\tcase 2:\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin(&net->cq_stats.syncp);\n\t\t\tcq_requests = net->cq_stats.requests;\n\t\t\tcq_successes = net->cq_stats.successes;\n\t\t\tcq_errors = net->cq_stats.errors;\n\t\t} while (u64_stats_fetch_retry(&net->cq_stats.syncp, start));\n\n\t\tif (nla_put_string(msg, VDPA_ATTR_DEV_VENDOR_ATTR_NAME,\n\t\t\t\t  \"cvq requests\"))\n\t\t\tbreak;\n\t\tif (nla_put_u64_64bit(msg, VDPA_ATTR_DEV_VENDOR_ATTR_VALUE,\n\t\t\t\t      cq_requests, VDPA_ATTR_PAD))\n\t\t\tbreak;\n\t\tif (nla_put_string(msg, VDPA_ATTR_DEV_VENDOR_ATTR_NAME,\n\t\t\t\t  \"cvq successes\"))\n\t\t\tbreak;\n\t\tif (nla_put_u64_64bit(msg, VDPA_ATTR_DEV_VENDOR_ATTR_VALUE,\n\t\t\t\t      cq_successes, VDPA_ATTR_PAD))\n\t\t\tbreak;\n\t\tif (nla_put_string(msg, VDPA_ATTR_DEV_VENDOR_ATTR_NAME,\n\t\t\t\t  \"cvq errors\"))\n\t\t\tbreak;\n\t\tif (nla_put_u64_64bit(msg, VDPA_ATTR_DEV_VENDOR_ATTR_VALUE,\n\t\t\t\t      cq_errors, VDPA_ATTR_PAD))\n\t\t\tbreak;\n\t\terr = 0;\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic void vdpasim_net_get_config(struct vdpasim *vdpasim, void *config)\n{\n\tstruct virtio_net_config *net_config = config;\n\n\tnet_config->status = cpu_to_vdpasim16(vdpasim, VIRTIO_NET_S_LINK_UP);\n}\n\nstatic void vdpasim_net_setup_config(struct vdpasim *vdpasim,\n\t\t\t\t     const struct vdpa_dev_set_config *config)\n{\n\tstruct virtio_net_config *vio_config = vdpasim->config;\n\n\tif (config->mask & (1 << VDPA_ATTR_DEV_NET_CFG_MACADDR))\n\t\tmemcpy(vio_config->mac, config->net.mac, ETH_ALEN);\n\tif (config->mask & (1 << VDPA_ATTR_DEV_NET_CFG_MTU))\n\t\tvio_config->mtu = cpu_to_vdpasim16(vdpasim, config->net.mtu);\n\telse\n\t\t \n\t\tvio_config->mtu = cpu_to_vdpasim16(vdpasim, 1500);\n}\n\nstatic void vdpasim_net_free(struct vdpasim *vdpasim)\n{\n\tstruct vdpasim_net *net = sim_to_net(vdpasim);\n\n\tkvfree(net->buffer);\n}\n\nstatic void vdpasim_net_mgmtdev_release(struct device *dev)\n{\n}\n\nstatic struct device vdpasim_net_mgmtdev = {\n\t.init_name = \"vdpasim_net\",\n\t.release = vdpasim_net_mgmtdev_release,\n};\n\nstatic int vdpasim_net_dev_add(struct vdpa_mgmt_dev *mdev, const char *name,\n\t\t\t       const struct vdpa_dev_set_config *config)\n{\n\tstruct vdpasim_dev_attr dev_attr = {};\n\tstruct vdpasim_net *net;\n\tstruct vdpasim *simdev;\n\tint ret;\n\n\tdev_attr.mgmt_dev = mdev;\n\tdev_attr.name = name;\n\tdev_attr.id = VIRTIO_ID_NET;\n\tdev_attr.supported_features = VDPASIM_NET_FEATURES;\n\tdev_attr.nvqs = VDPASIM_NET_VQ_NUM;\n\tdev_attr.ngroups = VDPASIM_NET_GROUP_NUM;\n\tdev_attr.nas = VDPASIM_NET_AS_NUM;\n\tdev_attr.alloc_size = sizeof(struct vdpasim_net);\n\tdev_attr.config_size = sizeof(struct virtio_net_config);\n\tdev_attr.get_config = vdpasim_net_get_config;\n\tdev_attr.work_fn = vdpasim_net_work;\n\tdev_attr.get_stats = vdpasim_net_get_stats;\n\tdev_attr.free = vdpasim_net_free;\n\n\tsimdev = vdpasim_create(&dev_attr, config);\n\tif (IS_ERR(simdev))\n\t\treturn PTR_ERR(simdev);\n\n\tvdpasim_net_setup_config(simdev, config);\n\n\tnet = sim_to_net(simdev);\n\n\tu64_stats_init(&net->tx_stats.syncp);\n\tu64_stats_init(&net->rx_stats.syncp);\n\tu64_stats_init(&net->cq_stats.syncp);\n\n\tnet->buffer = kvmalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!net->buffer) {\n\t\tret = -ENOMEM;\n\t\tgoto reg_err;\n\t}\n\n\t \n\tret = _vdpa_register_device(&simdev->vdpa, VDPASIM_NET_VQ_NUM);\n\tif (ret)\n\t\tgoto reg_err;\n\n\treturn 0;\n\nreg_err:\n\tput_device(&simdev->vdpa.dev);\n\treturn ret;\n}\n\nstatic void vdpasim_net_dev_del(struct vdpa_mgmt_dev *mdev,\n\t\t\t\tstruct vdpa_device *dev)\n{\n\tstruct vdpasim *simdev = container_of(dev, struct vdpasim, vdpa);\n\n\t_vdpa_unregister_device(&simdev->vdpa);\n}\n\nstatic const struct vdpa_mgmtdev_ops vdpasim_net_mgmtdev_ops = {\n\t.dev_add = vdpasim_net_dev_add,\n\t.dev_del = vdpasim_net_dev_del\n};\n\nstatic struct virtio_device_id id_table[] = {\n\t{ VIRTIO_ID_NET, VIRTIO_DEV_ANY_ID },\n\t{ 0 },\n};\n\nstatic struct vdpa_mgmt_dev mgmt_dev = {\n\t.device = &vdpasim_net_mgmtdev,\n\t.id_table = id_table,\n\t.ops = &vdpasim_net_mgmtdev_ops,\n\t.config_attr_mask = (1 << VDPA_ATTR_DEV_NET_CFG_MACADDR |\n\t\t\t     1 << VDPA_ATTR_DEV_NET_CFG_MTU |\n\t\t             1 << VDPA_ATTR_DEV_FEATURES),\n\t.max_supported_vqs = VDPASIM_NET_VQ_NUM,\n\t.supported_features = VDPASIM_NET_FEATURES,\n};\n\nstatic int __init vdpasim_net_init(void)\n{\n\tint ret;\n\n\tret = device_register(&vdpasim_net_mgmtdev);\n\tif (ret) {\n\t\tput_device(&vdpasim_net_mgmtdev);\n\t\treturn ret;\n\t}\n\n\tret = vdpa_mgmtdev_register(&mgmt_dev);\n\tif (ret)\n\t\tgoto parent_err;\n\treturn 0;\n\nparent_err:\n\tdevice_unregister(&vdpasim_net_mgmtdev);\n\treturn ret;\n}\n\nstatic void __exit vdpasim_net_exit(void)\n{\n\tvdpa_mgmtdev_unregister(&mgmt_dev);\n\tdevice_unregister(&vdpasim_net_mgmtdev);\n}\n\nmodule_init(vdpasim_net_init);\nmodule_exit(vdpasim_net_exit);\n\nMODULE_VERSION(DRV_VERSION);\nMODULE_LICENSE(DRV_LICENSE);\nMODULE_AUTHOR(DRV_AUTHOR);\nMODULE_DESCRIPTION(DRV_DESC);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}