{
  "module_name": "vp_vdpa.c",
  "hash_id": "05fcc120d4b2ef25f4aebb1706888dfec5e2aa04d0c764bd4eabb33031870126",
  "original_prompt": "Ingested from linux-6.6.14/drivers/vdpa/virtio_pci/vp_vdpa.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/vdpa.h>\n#include <linux/virtio.h>\n#include <linux/virtio_config.h>\n#include <linux/virtio_ring.h>\n#include <linux/virtio_pci.h>\n#include <linux/virtio_pci_modern.h>\n#include <uapi/linux/vdpa.h>\n\n#define VP_VDPA_QUEUE_MAX 256\n#define VP_VDPA_DRIVER_NAME \"vp_vdpa\"\n#define VP_VDPA_NAME_SIZE 256\n\nstruct vp_vring {\n\tvoid __iomem *notify;\n\tchar msix_name[VP_VDPA_NAME_SIZE];\n\tstruct vdpa_callback cb;\n\tresource_size_t notify_pa;\n\tint irq;\n};\n\nstruct vp_vdpa {\n\tstruct vdpa_device vdpa;\n\tstruct virtio_pci_modern_device *mdev;\n\tstruct vp_vring *vring;\n\tstruct vdpa_callback config_cb;\n\tu64 device_features;\n\tchar msix_name[VP_VDPA_NAME_SIZE];\n\tint config_irq;\n\tint queues;\n\tint vectors;\n};\n\nstruct vp_vdpa_mgmtdev {\n\tstruct vdpa_mgmt_dev mgtdev;\n\tstruct virtio_pci_modern_device *mdev;\n\tstruct vp_vdpa *vp_vdpa;\n};\n\nstatic struct vp_vdpa *vdpa_to_vp(struct vdpa_device *vdpa)\n{\n\treturn container_of(vdpa, struct vp_vdpa, vdpa);\n}\n\nstatic struct virtio_pci_modern_device *vdpa_to_mdev(struct vdpa_device *vdpa)\n{\n\tstruct vp_vdpa *vp_vdpa = vdpa_to_vp(vdpa);\n\n\treturn vp_vdpa->mdev;\n}\n\nstatic struct virtio_pci_modern_device *vp_vdpa_to_mdev(struct vp_vdpa *vp_vdpa)\n{\n\treturn vp_vdpa->mdev;\n}\n\nstatic u64 vp_vdpa_get_device_features(struct vdpa_device *vdpa)\n{\n\tstruct vp_vdpa *vp_vdpa = vdpa_to_vp(vdpa);\n\n\treturn vp_vdpa->device_features;\n}\n\nstatic int vp_vdpa_set_driver_features(struct vdpa_device *vdpa, u64 features)\n{\n\tstruct virtio_pci_modern_device *mdev = vdpa_to_mdev(vdpa);\n\n\tvp_modern_set_features(mdev, features);\n\n\treturn 0;\n}\n\nstatic u64 vp_vdpa_get_driver_features(struct vdpa_device *vdpa)\n{\n\tstruct virtio_pci_modern_device *mdev = vdpa_to_mdev(vdpa);\n\n\treturn vp_modern_get_driver_features(mdev);\n}\n\nstatic u8 vp_vdpa_get_status(struct vdpa_device *vdpa)\n{\n\tstruct virtio_pci_modern_device *mdev = vdpa_to_mdev(vdpa);\n\n\treturn vp_modern_get_status(mdev);\n}\n\nstatic int vp_vdpa_get_vq_irq(struct vdpa_device *vdpa, u16 idx)\n{\n\tstruct vp_vdpa *vp_vdpa = vdpa_to_vp(vdpa);\n\tint irq = vp_vdpa->vring[idx].irq;\n\n\tif (irq == VIRTIO_MSI_NO_VECTOR)\n\t\treturn -EINVAL;\n\n\treturn irq;\n}\n\nstatic void vp_vdpa_free_irq(struct vp_vdpa *vp_vdpa)\n{\n\tstruct virtio_pci_modern_device *mdev = vp_vdpa_to_mdev(vp_vdpa);\n\tstruct pci_dev *pdev = mdev->pci_dev;\n\tint i;\n\n\tfor (i = 0; i < vp_vdpa->queues; i++) {\n\t\tif (vp_vdpa->vring[i].irq != VIRTIO_MSI_NO_VECTOR) {\n\t\t\tvp_modern_queue_vector(mdev, i, VIRTIO_MSI_NO_VECTOR);\n\t\t\tdevm_free_irq(&pdev->dev, vp_vdpa->vring[i].irq,\n\t\t\t\t      &vp_vdpa->vring[i]);\n\t\t\tvp_vdpa->vring[i].irq = VIRTIO_MSI_NO_VECTOR;\n\t\t}\n\t}\n\n\tif (vp_vdpa->config_irq != VIRTIO_MSI_NO_VECTOR) {\n\t\tvp_modern_config_vector(mdev, VIRTIO_MSI_NO_VECTOR);\n\t\tdevm_free_irq(&pdev->dev, vp_vdpa->config_irq, vp_vdpa);\n\t\tvp_vdpa->config_irq = VIRTIO_MSI_NO_VECTOR;\n\t}\n\n\tif (vp_vdpa->vectors) {\n\t\tpci_free_irq_vectors(pdev);\n\t\tvp_vdpa->vectors = 0;\n\t}\n}\n\nstatic irqreturn_t vp_vdpa_vq_handler(int irq, void *arg)\n{\n\tstruct vp_vring *vring = arg;\n\n\tif (vring->cb.callback)\n\t\treturn vring->cb.callback(vring->cb.private);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t vp_vdpa_config_handler(int irq, void *arg)\n{\n\tstruct vp_vdpa *vp_vdpa = arg;\n\n\tif (vp_vdpa->config_cb.callback)\n\t\treturn vp_vdpa->config_cb.callback(vp_vdpa->config_cb.private);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int vp_vdpa_request_irq(struct vp_vdpa *vp_vdpa)\n{\n\tstruct virtio_pci_modern_device *mdev = vp_vdpa_to_mdev(vp_vdpa);\n\tstruct pci_dev *pdev = mdev->pci_dev;\n\tint i, ret, irq;\n\tint queues = vp_vdpa->queues;\n\tint vectors = queues + 1;\n\n\tret = pci_alloc_irq_vectors(pdev, vectors, vectors, PCI_IRQ_MSIX);\n\tif (ret != vectors) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"vp_vdpa: fail to allocate irq vectors want %d but %d\\n\",\n\t\t\tvectors, ret);\n\t\treturn ret;\n\t}\n\n\tvp_vdpa->vectors = vectors;\n\n\tfor (i = 0; i < queues; i++) {\n\t\tsnprintf(vp_vdpa->vring[i].msix_name, VP_VDPA_NAME_SIZE,\n\t\t\t\"vp-vdpa[%s]-%d\\n\", pci_name(pdev), i);\n\t\tirq = pci_irq_vector(pdev, i);\n\t\tret = devm_request_irq(&pdev->dev, irq,\n\t\t\t\t       vp_vdpa_vq_handler,\n\t\t\t\t       0, vp_vdpa->vring[i].msix_name,\n\t\t\t\t       &vp_vdpa->vring[i]);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"vp_vdpa: fail to request irq for vq %d\\n\", i);\n\t\t\tgoto err;\n\t\t}\n\t\tvp_modern_queue_vector(mdev, i, i);\n\t\tvp_vdpa->vring[i].irq = irq;\n\t}\n\n\tsnprintf(vp_vdpa->msix_name, VP_VDPA_NAME_SIZE, \"vp-vdpa[%s]-config\\n\",\n\t\t pci_name(pdev));\n\tirq = pci_irq_vector(pdev, queues);\n\tret = devm_request_irq(&pdev->dev, irq,\tvp_vdpa_config_handler, 0,\n\t\t\t       vp_vdpa->msix_name, vp_vdpa);\n\tif (ret) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"vp_vdpa: fail to request irq for vq %d\\n\", i);\n\t\t\tgoto err;\n\t}\n\tvp_modern_config_vector(mdev, queues);\n\tvp_vdpa->config_irq = irq;\n\n\treturn 0;\nerr:\n\tvp_vdpa_free_irq(vp_vdpa);\n\treturn ret;\n}\n\nstatic void vp_vdpa_set_status(struct vdpa_device *vdpa, u8 status)\n{\n\tstruct vp_vdpa *vp_vdpa = vdpa_to_vp(vdpa);\n\tstruct virtio_pci_modern_device *mdev = vp_vdpa_to_mdev(vp_vdpa);\n\tu8 s = vp_vdpa_get_status(vdpa);\n\n\tif (status & VIRTIO_CONFIG_S_DRIVER_OK &&\n\t    !(s & VIRTIO_CONFIG_S_DRIVER_OK)) {\n\t\tvp_vdpa_request_irq(vp_vdpa);\n\t}\n\n\tvp_modern_set_status(mdev, status);\n}\n\nstatic int vp_vdpa_reset(struct vdpa_device *vdpa)\n{\n\tstruct vp_vdpa *vp_vdpa = vdpa_to_vp(vdpa);\n\tstruct virtio_pci_modern_device *mdev = vp_vdpa_to_mdev(vp_vdpa);\n\tu8 s = vp_vdpa_get_status(vdpa);\n\n\tvp_modern_set_status(mdev, 0);\n\n\tif (s & VIRTIO_CONFIG_S_DRIVER_OK)\n\t\tvp_vdpa_free_irq(vp_vdpa);\n\n\treturn 0;\n}\n\nstatic u16 vp_vdpa_get_vq_num_max(struct vdpa_device *vdpa)\n{\n\treturn VP_VDPA_QUEUE_MAX;\n}\n\nstatic int vp_vdpa_get_vq_state(struct vdpa_device *vdpa, u16 qid,\n\t\t\t\tstruct vdpa_vq_state *state)\n{\n\t \n\treturn -EOPNOTSUPP;\n}\n\nstatic int vp_vdpa_set_vq_state_split(struct vdpa_device *vdpa,\n\t\t\t\t      const struct vdpa_vq_state *state)\n{\n\tconst struct vdpa_vq_state_split *split = &state->split;\n\n\tif (split->avail_index == 0)\n\t\treturn 0;\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int vp_vdpa_set_vq_state_packed(struct vdpa_device *vdpa,\n\t\t\t\t       const struct vdpa_vq_state *state)\n{\n\tconst struct vdpa_vq_state_packed *packed = &state->packed;\n\n\tif (packed->last_avail_counter == 1 &&\n\t    packed->last_avail_idx == 0 &&\n\t    packed->last_used_counter == 1 &&\n\t    packed->last_used_idx == 0)\n\t\treturn 0;\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int vp_vdpa_set_vq_state(struct vdpa_device *vdpa, u16 qid,\n\t\t\t\tconst struct vdpa_vq_state *state)\n{\n\tstruct virtio_pci_modern_device *mdev = vdpa_to_mdev(vdpa);\n\n\t \n\tif ((vp_modern_get_status(mdev) & VIRTIO_CONFIG_S_FEATURES_OK) &&\n\t    !vp_modern_get_queue_enable(mdev, qid)) {\n\t\tif (vp_modern_get_driver_features(mdev) &\n\t\t    BIT_ULL(VIRTIO_F_RING_PACKED))\n\t\t\treturn vp_vdpa_set_vq_state_packed(vdpa, state);\n\t\telse\n\t\t\treturn vp_vdpa_set_vq_state_split(vdpa,\tstate);\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic void vp_vdpa_set_vq_cb(struct vdpa_device *vdpa, u16 qid,\n\t\t\t      struct vdpa_callback *cb)\n{\n\tstruct vp_vdpa *vp_vdpa = vdpa_to_vp(vdpa);\n\n\tvp_vdpa->vring[qid].cb = *cb;\n}\n\nstatic void vp_vdpa_set_vq_ready(struct vdpa_device *vdpa,\n\t\t\t\t u16 qid, bool ready)\n{\n\tstruct virtio_pci_modern_device *mdev = vdpa_to_mdev(vdpa);\n\n\tvp_modern_set_queue_enable(mdev, qid, ready);\n}\n\nstatic bool vp_vdpa_get_vq_ready(struct vdpa_device *vdpa, u16 qid)\n{\n\tstruct virtio_pci_modern_device *mdev = vdpa_to_mdev(vdpa);\n\n\treturn vp_modern_get_queue_enable(mdev, qid);\n}\n\nstatic void vp_vdpa_set_vq_num(struct vdpa_device *vdpa, u16 qid,\n\t\t\t       u32 num)\n{\n\tstruct virtio_pci_modern_device *mdev = vdpa_to_mdev(vdpa);\n\n\tvp_modern_set_queue_size(mdev, qid, num);\n}\n\nstatic int vp_vdpa_set_vq_address(struct vdpa_device *vdpa, u16 qid,\n\t\t\t\t  u64 desc_area, u64 driver_area,\n\t\t\t\t  u64 device_area)\n{\n\tstruct virtio_pci_modern_device *mdev = vdpa_to_mdev(vdpa);\n\n\tvp_modern_queue_address(mdev, qid, desc_area,\n\t\t\t\tdriver_area, device_area);\n\n\treturn 0;\n}\n\nstatic void vp_vdpa_kick_vq(struct vdpa_device *vdpa, u16 qid)\n{\n\tstruct vp_vdpa *vp_vdpa = vdpa_to_vp(vdpa);\n\n\tvp_iowrite16(qid, vp_vdpa->vring[qid].notify);\n}\n\nstatic u32 vp_vdpa_get_generation(struct vdpa_device *vdpa)\n{\n\tstruct virtio_pci_modern_device *mdev = vdpa_to_mdev(vdpa);\n\n\treturn vp_modern_generation(mdev);\n}\n\nstatic u32 vp_vdpa_get_device_id(struct vdpa_device *vdpa)\n{\n\tstruct virtio_pci_modern_device *mdev = vdpa_to_mdev(vdpa);\n\n\treturn mdev->id.device;\n}\n\nstatic u32 vp_vdpa_get_vendor_id(struct vdpa_device *vdpa)\n{\n\tstruct virtio_pci_modern_device *mdev = vdpa_to_mdev(vdpa);\n\n\treturn mdev->id.vendor;\n}\n\nstatic u32 vp_vdpa_get_vq_align(struct vdpa_device *vdpa)\n{\n\treturn PAGE_SIZE;\n}\n\nstatic size_t vp_vdpa_get_config_size(struct vdpa_device *vdpa)\n{\n\tstruct virtio_pci_modern_device *mdev = vdpa_to_mdev(vdpa);\n\n\treturn mdev->device_len;\n}\n\nstatic void vp_vdpa_get_config(struct vdpa_device *vdpa,\n\t\t\t       unsigned int offset,\n\t\t\t       void *buf, unsigned int len)\n{\n\tstruct vp_vdpa *vp_vdpa = vdpa_to_vp(vdpa);\n\tstruct virtio_pci_modern_device *mdev = vp_vdpa_to_mdev(vp_vdpa);\n\tu8 old, new;\n\tu8 *p;\n\tint i;\n\n\tdo {\n\t\told = vp_ioread8(&mdev->common->config_generation);\n\t\tp = buf;\n\t\tfor (i = 0; i < len; i++)\n\t\t\t*p++ = vp_ioread8(mdev->device + offset + i);\n\n\t\tnew = vp_ioread8(&mdev->common->config_generation);\n\t} while (old != new);\n}\n\nstatic void vp_vdpa_set_config(struct vdpa_device *vdpa,\n\t\t\t       unsigned int offset, const void *buf,\n\t\t\t       unsigned int len)\n{\n\tstruct vp_vdpa *vp_vdpa = vdpa_to_vp(vdpa);\n\tstruct virtio_pci_modern_device *mdev = vp_vdpa_to_mdev(vp_vdpa);\n\tconst u8 *p = buf;\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\tvp_iowrite8(*p++, mdev->device + offset + i);\n}\n\nstatic void vp_vdpa_set_config_cb(struct vdpa_device *vdpa,\n\t\t\t\t  struct vdpa_callback *cb)\n{\n\tstruct vp_vdpa *vp_vdpa = vdpa_to_vp(vdpa);\n\n\tvp_vdpa->config_cb = *cb;\n}\n\nstatic struct vdpa_notification_area\nvp_vdpa_get_vq_notification(struct vdpa_device *vdpa, u16 qid)\n{\n\tstruct vp_vdpa *vp_vdpa = vdpa_to_vp(vdpa);\n\tstruct virtio_pci_modern_device *mdev = vp_vdpa_to_mdev(vp_vdpa);\n\tstruct vdpa_notification_area notify;\n\n\tnotify.addr = vp_vdpa->vring[qid].notify_pa;\n\tnotify.size = mdev->notify_offset_multiplier;\n\n\treturn notify;\n}\n\nstatic const struct vdpa_config_ops vp_vdpa_ops = {\n\t.get_device_features = vp_vdpa_get_device_features,\n\t.set_driver_features = vp_vdpa_set_driver_features,\n\t.get_driver_features = vp_vdpa_get_driver_features,\n\t.get_status\t= vp_vdpa_get_status,\n\t.set_status\t= vp_vdpa_set_status,\n\t.reset\t\t= vp_vdpa_reset,\n\t.get_vq_num_max\t= vp_vdpa_get_vq_num_max,\n\t.get_vq_state\t= vp_vdpa_get_vq_state,\n\t.get_vq_notification = vp_vdpa_get_vq_notification,\n\t.set_vq_state\t= vp_vdpa_set_vq_state,\n\t.set_vq_cb\t= vp_vdpa_set_vq_cb,\n\t.set_vq_ready\t= vp_vdpa_set_vq_ready,\n\t.get_vq_ready\t= vp_vdpa_get_vq_ready,\n\t.set_vq_num\t= vp_vdpa_set_vq_num,\n\t.set_vq_address\t= vp_vdpa_set_vq_address,\n\t.kick_vq\t= vp_vdpa_kick_vq,\n\t.get_generation\t= vp_vdpa_get_generation,\n\t.get_device_id\t= vp_vdpa_get_device_id,\n\t.get_vendor_id\t= vp_vdpa_get_vendor_id,\n\t.get_vq_align\t= vp_vdpa_get_vq_align,\n\t.get_config_size = vp_vdpa_get_config_size,\n\t.get_config\t= vp_vdpa_get_config,\n\t.set_config\t= vp_vdpa_set_config,\n\t.set_config_cb  = vp_vdpa_set_config_cb,\n\t.get_vq_irq\t= vp_vdpa_get_vq_irq,\n};\n\nstatic void vp_vdpa_free_irq_vectors(void *data)\n{\n\tpci_free_irq_vectors(data);\n}\n\nstatic int vp_vdpa_dev_add(struct vdpa_mgmt_dev *v_mdev, const char *name,\n\t\t\t   const struct vdpa_dev_set_config *add_config)\n{\n\tstruct vp_vdpa_mgmtdev *vp_vdpa_mgtdev =\n\t\tcontainer_of(v_mdev, struct vp_vdpa_mgmtdev, mgtdev);\n\n\tstruct virtio_pci_modern_device *mdev = vp_vdpa_mgtdev->mdev;\n\tstruct pci_dev *pdev = mdev->pci_dev;\n\tstruct device *dev = &pdev->dev;\n\tstruct vp_vdpa *vp_vdpa = NULL;\n\tu64 device_features;\n\tint ret, i;\n\n\tvp_vdpa = vdpa_alloc_device(struct vp_vdpa, vdpa,\n\t\t\t\t    dev, &vp_vdpa_ops, 1, 1, name, false);\n\n\tif (IS_ERR(vp_vdpa)) {\n\t\tdev_err(dev, \"vp_vdpa: Failed to allocate vDPA structure\\n\");\n\t\treturn PTR_ERR(vp_vdpa);\n\t}\n\n\tvp_vdpa_mgtdev->vp_vdpa = vp_vdpa;\n\n\tvp_vdpa->vdpa.dma_dev = &pdev->dev;\n\tvp_vdpa->queues = vp_modern_get_num_queues(mdev);\n\tvp_vdpa->mdev = mdev;\n\n\tdevice_features = vp_modern_get_features(mdev);\n\tif (add_config->mask & BIT_ULL(VDPA_ATTR_DEV_FEATURES)) {\n\t\tif (add_config->device_features & ~device_features) {\n\t\t\tret = -EINVAL;\n\t\t\tdev_err(&pdev->dev, \"Try to provision features \"\n\t\t\t\t\"that are not supported by the device: \"\n\t\t\t\t\"device_features 0x%llx provisioned 0x%llx\\n\",\n\t\t\t\tdevice_features, add_config->device_features);\n\t\t\tgoto err;\n\t\t}\n\t\tdevice_features = add_config->device_features;\n\t}\n\tvp_vdpa->device_features = device_features;\n\n\tret = devm_add_action_or_reset(dev, vp_vdpa_free_irq_vectors, pdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed for adding devres for freeing irq vectors\\n\");\n\t\tgoto err;\n\t}\n\n\tvp_vdpa->vring = devm_kcalloc(&pdev->dev, vp_vdpa->queues,\n\t\t\t\t      sizeof(*vp_vdpa->vring),\n\t\t\t\t      GFP_KERNEL);\n\tif (!vp_vdpa->vring) {\n\t\tret = -ENOMEM;\n\t\tdev_err(&pdev->dev, \"Fail to allocate virtqueues\\n\");\n\t\tgoto err;\n\t}\n\n\tfor (i = 0; i < vp_vdpa->queues; i++) {\n\t\tvp_vdpa->vring[i].irq = VIRTIO_MSI_NO_VECTOR;\n\t\tvp_vdpa->vring[i].notify =\n\t\t\tvp_modern_map_vq_notify(mdev, i,\n\t\t\t\t\t\t&vp_vdpa->vring[i].notify_pa);\n\t\tif (!vp_vdpa->vring[i].notify) {\n\t\t\tret = -EINVAL;\n\t\t\tdev_warn(&pdev->dev, \"Fail to map vq notify %d\\n\", i);\n\t\t\tgoto err;\n\t\t}\n\t}\n\tvp_vdpa->config_irq = VIRTIO_MSI_NO_VECTOR;\n\n\tvp_vdpa->vdpa.mdev = &vp_vdpa_mgtdev->mgtdev;\n\tret = _vdpa_register_device(&vp_vdpa->vdpa, vp_vdpa->queues);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to register to vdpa bus\\n\");\n\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tput_device(&vp_vdpa->vdpa.dev);\n\treturn ret;\n}\n\nstatic void vp_vdpa_dev_del(struct vdpa_mgmt_dev *v_mdev,\n\t\t\t    struct vdpa_device *dev)\n{\n\tstruct vp_vdpa_mgmtdev *vp_vdpa_mgtdev =\n\t\tcontainer_of(v_mdev, struct vp_vdpa_mgmtdev, mgtdev);\n\n\tstruct vp_vdpa *vp_vdpa = vp_vdpa_mgtdev->vp_vdpa;\n\n\t_vdpa_unregister_device(&vp_vdpa->vdpa);\n\tvp_vdpa_mgtdev->vp_vdpa = NULL;\n}\n\nstatic const struct vdpa_mgmtdev_ops vp_vdpa_mdev_ops = {\n\t.dev_add = vp_vdpa_dev_add,\n\t.dev_del = vp_vdpa_dev_del,\n};\n\nstatic int vp_vdpa_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstruct vp_vdpa_mgmtdev *vp_vdpa_mgtdev = NULL;\n\tstruct vdpa_mgmt_dev *mgtdev;\n\tstruct device *dev = &pdev->dev;\n\tstruct virtio_pci_modern_device *mdev = NULL;\n\tstruct virtio_device_id *mdev_id = NULL;\n\tint err;\n\n\tvp_vdpa_mgtdev = kzalloc(sizeof(*vp_vdpa_mgtdev), GFP_KERNEL);\n\tif (!vp_vdpa_mgtdev)\n\t\treturn -ENOMEM;\n\n\tmgtdev = &vp_vdpa_mgtdev->mgtdev;\n\tmgtdev->ops = &vp_vdpa_mdev_ops;\n\tmgtdev->device = dev;\n\n\tmdev = kzalloc(sizeof(struct virtio_pci_modern_device), GFP_KERNEL);\n\tif (!mdev) {\n\t\terr = -ENOMEM;\n\t\tgoto mdev_err;\n\t}\n\n\tmdev_id = kzalloc(sizeof(struct virtio_device_id), GFP_KERNEL);\n\tif (!mdev_id) {\n\t\terr = -ENOMEM;\n\t\tgoto mdev_id_err;\n\t}\n\n\tvp_vdpa_mgtdev->mdev = mdev;\n\tmdev->pci_dev = pdev;\n\n\terr = pcim_enable_device(pdev);\n\tif (err) {\n\t\tgoto probe_err;\n\t}\n\n\terr = vp_modern_probe(mdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to probe modern PCI device\\n\");\n\t\tgoto probe_err;\n\t}\n\n\tmdev_id->device = mdev->id.device;\n\tmdev_id->vendor = mdev->id.vendor;\n\tmgtdev->id_table = mdev_id;\n\tmgtdev->max_supported_vqs = vp_modern_get_num_queues(mdev);\n\tmgtdev->supported_features = vp_modern_get_features(mdev);\n\tmgtdev->config_attr_mask = (1 << VDPA_ATTR_DEV_FEATURES);\n\tpci_set_master(pdev);\n\tpci_set_drvdata(pdev, vp_vdpa_mgtdev);\n\n\terr = vdpa_mgmtdev_register(mgtdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to register vdpa mgmtdev device\\n\");\n\t\tgoto register_err;\n\t}\n\n\treturn 0;\n\nregister_err:\n\tvp_modern_remove(vp_vdpa_mgtdev->mdev);\nprobe_err:\n\tkfree(mdev_id);\nmdev_id_err:\n\tkfree(mdev);\nmdev_err:\n\tkfree(vp_vdpa_mgtdev);\n\treturn err;\n}\n\nstatic void vp_vdpa_remove(struct pci_dev *pdev)\n{\n\tstruct vp_vdpa_mgmtdev *vp_vdpa_mgtdev = pci_get_drvdata(pdev);\n\tstruct virtio_pci_modern_device *mdev = NULL;\n\n\tmdev = vp_vdpa_mgtdev->mdev;\n\tvdpa_mgmtdev_unregister(&vp_vdpa_mgtdev->mgtdev);\n\tvp_modern_remove(mdev);\n\tkfree(vp_vdpa_mgtdev->mgtdev.id_table);\n\tkfree(mdev);\n\tkfree(vp_vdpa_mgtdev);\n}\n\nstatic struct pci_driver vp_vdpa_driver = {\n\t.name\t\t= \"vp-vdpa\",\n\t.id_table\t= NULL,  \n\t.probe\t\t= vp_vdpa_probe,\n\t.remove\t\t= vp_vdpa_remove,\n};\n\nmodule_pci_driver(vp_vdpa_driver);\n\nMODULE_AUTHOR(\"Jason Wang <jasowang@redhat.com>\");\nMODULE_DESCRIPTION(\"vp-vdpa\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(\"1\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}