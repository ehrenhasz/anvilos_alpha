{
  "module_name": "ifcvf_base.h",
  "hash_id": "ddc952aceb9a7853beb1037034162fe24fdac4c0e3b4c6328fb3a5b35640109e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/vdpa/ifcvf/ifcvf_base.h",
  "human_readable_source": " \n \n\n#ifndef _IFCVF_H_\n#define _IFCVF_H_\n\n#include <linux/pci.h>\n#include <linux/pci_regs.h>\n#include <linux/vdpa.h>\n#include <linux/virtio_pci_modern.h>\n#include <uapi/linux/virtio_net.h>\n#include <uapi/linux/virtio_blk.h>\n#include <uapi/linux/virtio_config.h>\n#include <uapi/linux/virtio_pci.h>\n#include <uapi/linux/vdpa.h>\n\n#define N3000_DEVICE_ID\t\t0x1041\n#define N3000_SUBSYS_DEVICE_ID\t0x001A\n\n#define IFCVF_QUEUE_ALIGNMENT\tPAGE_SIZE\n#define IFCVF_PCI_MAX_RESOURCE\t6\n\n#define IFCVF_LM_BAR\t\t\t4\n\n#define IFCVF_ERR(pdev, fmt, ...)\tdev_err(&pdev->dev, fmt, ##__VA_ARGS__)\n#define IFCVF_DBG(pdev, fmt, ...)\tdev_dbg(&pdev->dev, fmt, ##__VA_ARGS__)\n#define IFCVF_INFO(pdev, fmt, ...)\tdev_info(&pdev->dev, fmt, ##__VA_ARGS__)\n\n \n#define MSIX_VECTOR_PER_VQ_AND_CONFIG\t\t1\n \n#define MSIX_VECTOR_SHARED_VQ_AND_CONFIG\t2\n \n#define MSIX_VECTOR_DEV_SHARED\t\t\t3\n\nstruct vring_info {\n\tu16 last_avail_idx;\n\tvoid __iomem *notify_addr;\n\tphys_addr_t notify_pa;\n\tu32 irq;\n\tstruct vdpa_callback cb;\n\tchar msix_name[256];\n};\n\nstruct ifcvf_lm_cfg {\n\t__le64 control;\n\t__le64 status;\n\t__le64 lm_mem_log_start_addr;\n\t__le64 lm_mem_log_end_addr;\n\t__le16 vq_state_region;\n};\n\nstruct ifcvf_hw {\n\tu8 __iomem *isr;\n\t \n\tstruct ifcvf_lm_cfg  __iomem *lm_cfg;\n\t \n\tu8 notify_bar;\n\tu8 msix_vector_status;\n\t \n\tu32 config_size;\n\t \n\tvoid __iomem *notify_base;\n\tphys_addr_t notify_base_pa;\n\tu32 notify_off_multiplier;\n\tu32 dev_type;\n\tu64 hw_features;\n\t \n\tu64 dev_features;\n\tstruct virtio_pci_common_cfg __iomem *common_cfg;\n\tvoid __iomem *dev_cfg;\n\tstruct vring_info *vring;\n\tvoid __iomem * const *base;\n\tchar config_msix_name[256];\n\tstruct vdpa_callback config_cb;\n\tint config_irq;\n\tint vqs_reused_irq;\n\tu16 nr_vring;\n\t \n\tu32 num_msix_vectors;\n\tu32 cap_dev_config_size;\n\tstruct pci_dev *pdev;\n};\n\nstruct ifcvf_adapter {\n\tstruct vdpa_device vdpa;\n\tstruct pci_dev *pdev;\n\tstruct ifcvf_hw *vf;\n};\n\nstruct ifcvf_vdpa_mgmt_dev {\n\tstruct vdpa_mgmt_dev mdev;\n\tstruct ifcvf_hw vf;\n\tstruct ifcvf_adapter *adapter;\n\tstruct pci_dev *pdev;\n};\n\nint ifcvf_init_hw(struct ifcvf_hw *hw, struct pci_dev *dev);\nvoid ifcvf_stop(struct ifcvf_hw *hw);\nvoid ifcvf_notify_queue(struct ifcvf_hw *hw, u16 qid);\nvoid ifcvf_read_dev_config(struct ifcvf_hw *hw, u64 offset,\n\t\t\t   void *dst, int length);\nvoid ifcvf_write_dev_config(struct ifcvf_hw *hw, u64 offset,\n\t\t\t    const void *src, int length);\nu8 ifcvf_get_status(struct ifcvf_hw *hw);\nvoid ifcvf_set_status(struct ifcvf_hw *hw, u8 status);\nvoid io_write64_twopart(u64 val, u32 *lo, u32 *hi);\nvoid ifcvf_reset(struct ifcvf_hw *hw);\nu64 ifcvf_get_dev_features(struct ifcvf_hw *hw);\nu64 ifcvf_get_hw_features(struct ifcvf_hw *hw);\nint ifcvf_verify_min_features(struct ifcvf_hw *hw, u64 features);\nu16 ifcvf_get_vq_state(struct ifcvf_hw *hw, u16 qid);\nint ifcvf_set_vq_state(struct ifcvf_hw *hw, u16 qid, u16 num);\nstruct ifcvf_adapter *vf_to_adapter(struct ifcvf_hw *hw);\nint ifcvf_probed_virtio_net(struct ifcvf_hw *hw);\nu32 ifcvf_get_config_size(struct ifcvf_hw *hw);\nu16 ifcvf_set_vq_vector(struct ifcvf_hw *hw, u16 qid, int vector);\nu16 ifcvf_set_config_vector(struct ifcvf_hw *hw, int vector);\nvoid ifcvf_set_vq_num(struct ifcvf_hw *hw, u16 qid, u32 num);\nint ifcvf_set_vq_address(struct ifcvf_hw *hw, u16 qid, u64 desc_area,\n\t\t\t u64 driver_area, u64 device_area);\nbool ifcvf_get_vq_ready(struct ifcvf_hw *hw, u16 qid);\nvoid ifcvf_set_vq_ready(struct ifcvf_hw *hw, u16 qid, bool ready);\nvoid ifcvf_set_driver_features(struct ifcvf_hw *hw, u64 features);\nu64 ifcvf_get_driver_features(struct ifcvf_hw *hw);\nu16 ifcvf_get_max_vq_size(struct ifcvf_hw *hw);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}