{
  "module_name": "arm_smccc_trng.c",
  "hash_id": "62b0555efff29a33a42daaf4a32a21969ebc5bcac657efb7d182b941e8675354",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/hw_random/arm_smccc_trng.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/device.h>\n#include <linux/hw_random.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/arm-smccc.h>\n\n#ifdef CONFIG_ARM64\n#define ARM_SMCCC_TRNG_RND\tARM_SMCCC_TRNG_RND64\n#define MAX_BITS_PER_CALL\t(3 * 64UL)\n#else\n#define ARM_SMCCC_TRNG_RND\tARM_SMCCC_TRNG_RND32\n#define MAX_BITS_PER_CALL\t(3 * 32UL)\n#endif\n\n \n#define SMCCC_TRNG_MAX_TRIES\t20\n\n#define SMCCC_RET_TRNG_INVALID_PARAMETER\t-2\n#define SMCCC_RET_TRNG_NO_ENTROPY\t\t-3\n\nstatic int copy_from_registers(char *buf, struct arm_smccc_res *res,\n\t\t\t       size_t bytes)\n{\n\tunsigned int chunk, copied;\n\n\tif (bytes == 0)\n\t\treturn 0;\n\n\tchunk = min(bytes, sizeof(long));\n\tmemcpy(buf, &res->a3, chunk);\n\tcopied = chunk;\n\tif (copied >= bytes)\n\t\treturn copied;\n\n\tchunk = min((bytes - copied), sizeof(long));\n\tmemcpy(&buf[copied], &res->a2, chunk);\n\tcopied += chunk;\n\tif (copied >= bytes)\n\t\treturn copied;\n\n\tchunk = min((bytes - copied), sizeof(long));\n\tmemcpy(&buf[copied], &res->a1, chunk);\n\n\treturn copied + chunk;\n}\n\nstatic int smccc_trng_read(struct hwrng *rng, void *data, size_t max, bool wait)\n{\n\tstruct arm_smccc_res res;\n\tu8 *buf = data;\n\tunsigned int copied = 0;\n\tint tries = 0;\n\n\twhile (copied < max) {\n\t\tsize_t bits = min_t(size_t, (max - copied) * BITS_PER_BYTE,\n\t\t\t\t  MAX_BITS_PER_CALL);\n\n\t\tarm_smccc_1_1_invoke(ARM_SMCCC_TRNG_RND, bits, &res);\n\n\t\tswitch ((int)res.a0) {\n\t\tcase SMCCC_RET_SUCCESS:\n\t\t\tcopied += copy_from_registers(buf + copied, &res,\n\t\t\t\t\t\t      bits / BITS_PER_BYTE);\n\t\t\ttries = 0;\n\t\t\tbreak;\n\t\tcase SMCCC_RET_TRNG_NO_ENTROPY:\n\t\t\tif (!wait)\n\t\t\t\treturn copied;\n\t\t\ttries++;\n\t\t\tif (tries >= SMCCC_TRNG_MAX_TRIES)\n\t\t\t\treturn copied;\n\t\t\tcond_resched();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\treturn copied;\n}\n\nstatic int smccc_trng_probe(struct platform_device *pdev)\n{\n\tstruct hwrng *trng;\n\n\ttrng = devm_kzalloc(&pdev->dev, sizeof(*trng), GFP_KERNEL);\n\tif (!trng)\n\t\treturn -ENOMEM;\n\n\ttrng->name = \"smccc_trng\";\n\ttrng->read = smccc_trng_read;\n\n\treturn devm_hwrng_register(&pdev->dev, trng);\n}\n\nstatic struct platform_driver smccc_trng_driver = {\n\t.driver = {\n\t\t.name\t\t= \"smccc_trng\",\n\t},\n\t.probe\t\t= smccc_trng_probe,\n};\nmodule_platform_driver(smccc_trng_driver);\n\nMODULE_ALIAS(\"platform:smccc_trng\");\nMODULE_AUTHOR(\"Andre Przywara\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}