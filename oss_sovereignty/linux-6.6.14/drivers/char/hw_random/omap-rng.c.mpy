{
  "module_name": "omap-rng.c",
  "hash_id": "3d51b0a2b4c7f6356a24cb1b221065764284bf2398cb7742e5dfe641d96c279d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/hw_random/omap-rng.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/random.h>\n#include <linux/err.h>\n#include <linux/platform_device.h>\n#include <linux/hw_random.h>\n#include <linux/delay.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pm_runtime.h>\n#include <linux/of.h>\n#include <linux/interrupt.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n\n#define RNG_REG_STATUS_RDY\t\t\t(1 << 0)\n\n#define RNG_REG_INTACK_RDY_MASK\t\t\t(1 << 0)\n#define RNG_REG_INTACK_SHUTDOWN_OFLO_MASK\t(1 << 1)\n#define RNG_SHUTDOWN_OFLO_MASK\t\t\t(1 << 1)\n\n#define RNG_CONTROL_STARTUP_CYCLES_SHIFT\t16\n#define RNG_CONTROL_STARTUP_CYCLES_MASK\t\t(0xffff << 16)\n#define RNG_CONTROL_ENABLE_TRNG_SHIFT\t\t10\n#define RNG_CONTROL_ENABLE_TRNG_MASK\t\t(1 << 10)\n\n#define RNG_CONFIG_MAX_REFIL_CYCLES_SHIFT\t16\n#define RNG_CONFIG_MAX_REFIL_CYCLES_MASK\t(0xffff << 16)\n#define RNG_CONFIG_MIN_REFIL_CYCLES_SHIFT\t0\n#define RNG_CONFIG_MIN_REFIL_CYCLES_MASK\t(0xff << 0)\n\n#define RNG_CONTROL_STARTUP_CYCLES\t\t0xff\n#define RNG_CONFIG_MIN_REFIL_CYCLES\t\t0x21\n#define RNG_CONFIG_MAX_REFIL_CYCLES\t\t0x22\n\n#define RNG_ALARMCNT_ALARM_TH_SHIFT\t\t0x0\n#define RNG_ALARMCNT_ALARM_TH_MASK\t\t(0xff << 0)\n#define RNG_ALARMCNT_SHUTDOWN_TH_SHIFT\t\t16\n#define RNG_ALARMCNT_SHUTDOWN_TH_MASK\t\t(0x1f << 16)\n#define RNG_ALARM_THRESHOLD\t\t\t0xff\n#define RNG_SHUTDOWN_THRESHOLD\t\t\t0x4\n\n#define RNG_REG_FROENABLE_MASK\t\t\t0xffffff\n#define RNG_REG_FRODETUNE_MASK\t\t\t0xffffff\n\n#define OMAP2_RNG_OUTPUT_SIZE\t\t\t0x4\n#define OMAP4_RNG_OUTPUT_SIZE\t\t\t0x8\n#define EIP76_RNG_OUTPUT_SIZE\t\t\t0x10\n\n \n#define RNG_DATA_FILL_TIMEOUT\t\t\t100\n\nenum {\n\tRNG_OUTPUT_0_REG = 0,\n\tRNG_OUTPUT_1_REG,\n\tRNG_OUTPUT_2_REG,\n\tRNG_OUTPUT_3_REG,\n\tRNG_STATUS_REG,\n\tRNG_INTMASK_REG,\n\tRNG_INTACK_REG,\n\tRNG_CONTROL_REG,\n\tRNG_CONFIG_REG,\n\tRNG_ALARMCNT_REG,\n\tRNG_FROENABLE_REG,\n\tRNG_FRODETUNE_REG,\n\tRNG_ALARMMASK_REG,\n\tRNG_ALARMSTOP_REG,\n\tRNG_REV_REG,\n\tRNG_SYSCONFIG_REG,\n};\n\nstatic const u16 reg_map_omap2[] = {\n\t[RNG_OUTPUT_0_REG]\t= 0x0,\n\t[RNG_STATUS_REG]\t= 0x4,\n\t[RNG_CONFIG_REG]\t= 0x28,\n\t[RNG_REV_REG]\t\t= 0x3c,\n\t[RNG_SYSCONFIG_REG]\t= 0x40,\n};\n\nstatic const u16 reg_map_omap4[] = {\n\t[RNG_OUTPUT_0_REG]\t= 0x0,\n\t[RNG_OUTPUT_1_REG]\t= 0x4,\n\t[RNG_STATUS_REG]\t= 0x8,\n\t[RNG_INTMASK_REG]\t= 0xc,\n\t[RNG_INTACK_REG]\t= 0x10,\n\t[RNG_CONTROL_REG]\t= 0x14,\n\t[RNG_CONFIG_REG]\t= 0x18,\n\t[RNG_ALARMCNT_REG]\t= 0x1c,\n\t[RNG_FROENABLE_REG]\t= 0x20,\n\t[RNG_FRODETUNE_REG]\t= 0x24,\n\t[RNG_ALARMMASK_REG]\t= 0x28,\n\t[RNG_ALARMSTOP_REG]\t= 0x2c,\n\t[RNG_REV_REG]\t\t= 0x1FE0,\n\t[RNG_SYSCONFIG_REG]\t= 0x1FE4,\n};\n\nstatic const u16 reg_map_eip76[] = {\n\t[RNG_OUTPUT_0_REG]\t= 0x0,\n\t[RNG_OUTPUT_1_REG]\t= 0x4,\n\t[RNG_OUTPUT_2_REG]\t= 0x8,\n\t[RNG_OUTPUT_3_REG]\t= 0xc,\n\t[RNG_STATUS_REG]\t= 0x10,\n\t[RNG_INTACK_REG]\t= 0x10,\n\t[RNG_CONTROL_REG]\t= 0x14,\n\t[RNG_CONFIG_REG]\t= 0x18,\n\t[RNG_ALARMCNT_REG]\t= 0x1c,\n\t[RNG_FROENABLE_REG]\t= 0x20,\n\t[RNG_FRODETUNE_REG]\t= 0x24,\n\t[RNG_ALARMMASK_REG]\t= 0x28,\n\t[RNG_ALARMSTOP_REG]\t= 0x2c,\n\t[RNG_REV_REG]\t\t= 0x7c,\n};\n\nstruct omap_rng_dev;\n \nstruct omap_rng_pdata {\n\tu16\t*regs;\n\tu32\tdata_size;\n\tu32\t(*data_present)(struct omap_rng_dev *priv);\n\tint\t(*init)(struct omap_rng_dev *priv);\n\tvoid\t(*cleanup)(struct omap_rng_dev *priv);\n};\n\nstruct omap_rng_dev {\n\tvoid __iomem\t\t\t*base;\n\tstruct device\t\t\t*dev;\n\tconst struct omap_rng_pdata\t*pdata;\n\tstruct hwrng rng;\n\tstruct clk \t\t\t*clk;\n\tstruct clk\t\t\t*clk_reg;\n};\n\nstatic inline u32 omap_rng_read(struct omap_rng_dev *priv, u16 reg)\n{\n\treturn __raw_readl(priv->base + priv->pdata->regs[reg]);\n}\n\nstatic inline void omap_rng_write(struct omap_rng_dev *priv, u16 reg,\n\t\t\t\t      u32 val)\n{\n\t__raw_writel(val, priv->base + priv->pdata->regs[reg]);\n}\n\n\nstatic int omap_rng_do_read(struct hwrng *rng, void *data, size_t max,\n\t\t\t    bool wait)\n{\n\tstruct omap_rng_dev *priv;\n\tint i, present;\n\n\tpriv = (struct omap_rng_dev *)rng->priv;\n\n\tif (max < priv->pdata->data_size)\n\t\treturn 0;\n\n\tfor (i = 0; i < RNG_DATA_FILL_TIMEOUT; i++) {\n\t\tpresent = priv->pdata->data_present(priv);\n\t\tif (present || !wait)\n\t\t\tbreak;\n\n\t\tudelay(10);\n\t}\n\tif (!present)\n\t\treturn 0;\n\n\tmemcpy_fromio(data, priv->base + priv->pdata->regs[RNG_OUTPUT_0_REG],\n\t\t      priv->pdata->data_size);\n\n\tif (priv->pdata->regs[RNG_INTACK_REG])\n\t\tomap_rng_write(priv, RNG_INTACK_REG, RNG_REG_INTACK_RDY_MASK);\n\n\treturn priv->pdata->data_size;\n}\n\nstatic int omap_rng_init(struct hwrng *rng)\n{\n\tstruct omap_rng_dev *priv;\n\n\tpriv = (struct omap_rng_dev *)rng->priv;\n\treturn priv->pdata->init(priv);\n}\n\nstatic void omap_rng_cleanup(struct hwrng *rng)\n{\n\tstruct omap_rng_dev *priv;\n\n\tpriv = (struct omap_rng_dev *)rng->priv;\n\tpriv->pdata->cleanup(priv);\n}\n\n\nstatic inline u32 omap2_rng_data_present(struct omap_rng_dev *priv)\n{\n\treturn omap_rng_read(priv, RNG_STATUS_REG) ? 0 : 1;\n}\n\nstatic int omap2_rng_init(struct omap_rng_dev *priv)\n{\n\tomap_rng_write(priv, RNG_SYSCONFIG_REG, 0x1);\n\treturn 0;\n}\n\nstatic void omap2_rng_cleanup(struct omap_rng_dev *priv)\n{\n\tomap_rng_write(priv, RNG_SYSCONFIG_REG, 0x0);\n}\n\nstatic struct omap_rng_pdata omap2_rng_pdata = {\n\t.regs\t\t= (u16 *)reg_map_omap2,\n\t.data_size\t= OMAP2_RNG_OUTPUT_SIZE,\n\t.data_present\t= omap2_rng_data_present,\n\t.init\t\t= omap2_rng_init,\n\t.cleanup\t= omap2_rng_cleanup,\n};\n\nstatic inline u32 omap4_rng_data_present(struct omap_rng_dev *priv)\n{\n\treturn omap_rng_read(priv, RNG_STATUS_REG) & RNG_REG_STATUS_RDY;\n}\n\nstatic int eip76_rng_init(struct omap_rng_dev *priv)\n{\n\tu32 val;\n\n\t \n\tif (omap_rng_read(priv, RNG_CONTROL_REG) & RNG_CONTROL_ENABLE_TRNG_MASK)\n\t\treturn 0;\n\n\t \n\tval = 0x5 << RNG_CONFIG_MIN_REFIL_CYCLES_SHIFT;\n\n\t \n\tval |= RNG_CONFIG_MAX_REFIL_CYCLES << RNG_CONFIG_MAX_REFIL_CYCLES_SHIFT;\n\tomap_rng_write(priv, RNG_CONFIG_REG, val);\n\n\t \n\tomap_rng_write(priv, RNG_FRODETUNE_REG, 0x0);\n\tomap_rng_write(priv, RNG_FROENABLE_REG, RNG_REG_FROENABLE_MASK);\n\n\t \n\tval = RNG_CONTROL_ENABLE_TRNG_MASK;\n\tomap_rng_write(priv, RNG_CONTROL_REG, val);\n\n\treturn 0;\n}\n\nstatic int omap4_rng_init(struct omap_rng_dev *priv)\n{\n\tu32 val;\n\n\t \n\tif (omap_rng_read(priv, RNG_CONTROL_REG) & RNG_CONTROL_ENABLE_TRNG_MASK)\n\t\treturn 0;\n\n\tval = RNG_CONFIG_MIN_REFIL_CYCLES << RNG_CONFIG_MIN_REFIL_CYCLES_SHIFT;\n\tval |= RNG_CONFIG_MAX_REFIL_CYCLES << RNG_CONFIG_MAX_REFIL_CYCLES_SHIFT;\n\tomap_rng_write(priv, RNG_CONFIG_REG, val);\n\n\tomap_rng_write(priv, RNG_FRODETUNE_REG, 0x0);\n\tomap_rng_write(priv, RNG_FROENABLE_REG, RNG_REG_FROENABLE_MASK);\n\tval = RNG_ALARM_THRESHOLD << RNG_ALARMCNT_ALARM_TH_SHIFT;\n\tval |= RNG_SHUTDOWN_THRESHOLD << RNG_ALARMCNT_SHUTDOWN_TH_SHIFT;\n\tomap_rng_write(priv, RNG_ALARMCNT_REG, val);\n\n\tval = RNG_CONTROL_STARTUP_CYCLES << RNG_CONTROL_STARTUP_CYCLES_SHIFT;\n\tval |= RNG_CONTROL_ENABLE_TRNG_MASK;\n\tomap_rng_write(priv, RNG_CONTROL_REG, val);\n\n\treturn 0;\n}\n\nstatic void omap4_rng_cleanup(struct omap_rng_dev *priv)\n{\n\tint val;\n\n\tval = omap_rng_read(priv, RNG_CONTROL_REG);\n\tval &= ~RNG_CONTROL_ENABLE_TRNG_MASK;\n\tomap_rng_write(priv, RNG_CONTROL_REG, val);\n}\n\nstatic irqreturn_t omap4_rng_irq(int irq, void *dev_id)\n{\n\tstruct omap_rng_dev *priv = dev_id;\n\tu32 fro_detune, fro_enable;\n\n\t \n\tomap_rng_write(priv, RNG_ALARMMASK_REG, 0x0);\n\tomap_rng_write(priv, RNG_ALARMSTOP_REG, 0x0);\n\n\tfro_enable = omap_rng_read(priv, RNG_FROENABLE_REG);\n\tfro_detune = ~fro_enable & RNG_REG_FRODETUNE_MASK;\n\tfro_detune = fro_detune | omap_rng_read(priv, RNG_FRODETUNE_REG);\n\tfro_enable = RNG_REG_FROENABLE_MASK;\n\n\tomap_rng_write(priv, RNG_FRODETUNE_REG, fro_detune);\n\tomap_rng_write(priv, RNG_FROENABLE_REG, fro_enable);\n\n\tomap_rng_write(priv, RNG_INTACK_REG, RNG_REG_INTACK_SHUTDOWN_OFLO_MASK);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic struct omap_rng_pdata omap4_rng_pdata = {\n\t.regs\t\t= (u16 *)reg_map_omap4,\n\t.data_size\t= OMAP4_RNG_OUTPUT_SIZE,\n\t.data_present\t= omap4_rng_data_present,\n\t.init\t\t= omap4_rng_init,\n\t.cleanup\t= omap4_rng_cleanup,\n};\n\nstatic struct omap_rng_pdata eip76_rng_pdata = {\n\t.regs\t\t= (u16 *)reg_map_eip76,\n\t.data_size\t= EIP76_RNG_OUTPUT_SIZE,\n\t.data_present\t= omap4_rng_data_present,\n\t.init\t\t= eip76_rng_init,\n\t.cleanup\t= omap4_rng_cleanup,\n};\n\nstatic const struct of_device_id omap_rng_of_match[] __maybe_unused = {\n\t\t{\n\t\t\t.compatible\t= \"ti,omap2-rng\",\n\t\t\t.data\t\t= &omap2_rng_pdata,\n\t\t},\n\t\t{\n\t\t\t.compatible\t= \"ti,omap4-rng\",\n\t\t\t.data\t\t= &omap4_rng_pdata,\n\t\t},\n\t\t{\n\t\t\t.compatible\t= \"inside-secure,safexcel-eip76\",\n\t\t\t.data\t\t= &eip76_rng_pdata,\n\t\t},\n\t\t{},\n};\nMODULE_DEVICE_TABLE(of, omap_rng_of_match);\n\nstatic int of_get_omap_rng_device_details(struct omap_rng_dev *priv,\n\t\t\t\t\t  struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tint irq, err;\n\n\tpriv->pdata = of_device_get_match_data(dev);\n\tif (!priv->pdata)\n\t\treturn -ENODEV;\n\n\n\tif (of_device_is_compatible(dev->of_node, \"ti,omap4-rng\") ||\n\t    of_device_is_compatible(dev->of_node, \"inside-secure,safexcel-eip76\")) {\n\t\tirq = platform_get_irq(pdev, 0);\n\t\tif (irq < 0)\n\t\t\treturn irq;\n\n\t\terr = devm_request_irq(dev, irq, omap4_rng_irq,\n\t\t\t\t       IRQF_TRIGGER_NONE, dev_name(dev), priv);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"unable to request irq %d, err = %d\\n\",\n\t\t\t\tirq, err);\n\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\tif (priv->pdata->regs[RNG_INTMASK_REG])\n\t\t\tomap_rng_write(priv, RNG_INTMASK_REG,\n\t\t\t\t       RNG_SHUTDOWN_OFLO_MASK);\n\t\telse\n\t\t\tomap_rng_write(priv, RNG_CONTROL_REG,\n\t\t\t\t       RNG_SHUTDOWN_OFLO_MASK);\n\t}\n\treturn 0;\n}\n\nstatic int get_omap_rng_device_details(struct omap_rng_dev *omap_rng)\n{\n\t \n\tomap_rng->pdata = &omap2_rng_pdata;\n\treturn 0;\n}\n\nstatic int omap_rng_probe(struct platform_device *pdev)\n{\n\tstruct omap_rng_dev *priv;\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(struct omap_rng_dev), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->rng.read = omap_rng_do_read;\n\tpriv->rng.init = omap_rng_init;\n\tpriv->rng.cleanup = omap_rng_cleanup;\n\tpriv->rng.quality = 900;\n\n\tpriv->rng.priv = (unsigned long)priv;\n\tplatform_set_drvdata(pdev, priv);\n\tpriv->dev = dev;\n\n\tpriv->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->base)) {\n\t\tret = PTR_ERR(priv->base);\n\t\tgoto err_ioremap;\n\t}\n\n\tpriv->rng.name = devm_kstrdup(dev, dev_name(dev), GFP_KERNEL);\n\tif (!priv->rng.name) {\n\t\tret = -ENOMEM;\n\t\tgoto err_ioremap;\n\t}\n\n\tpm_runtime_enable(&pdev->dev);\n\tret = pm_runtime_resume_and_get(&pdev->dev);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to runtime_get device: %d\\n\", ret);\n\t\tgoto err_ioremap;\n\t}\n\n\tpriv->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (PTR_ERR(priv->clk) == -EPROBE_DEFER)\n\t\treturn -EPROBE_DEFER;\n\tif (!IS_ERR(priv->clk)) {\n\t\tret = clk_prepare_enable(priv->clk);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Unable to enable the clk: %d\\n\", ret);\n\t\t\tgoto err_register;\n\t\t}\n\t}\n\n\tpriv->clk_reg = devm_clk_get(&pdev->dev, \"reg\");\n\tif (PTR_ERR(priv->clk_reg) == -EPROBE_DEFER)\n\t\treturn -EPROBE_DEFER;\n\tif (!IS_ERR(priv->clk_reg)) {\n\t\tret = clk_prepare_enable(priv->clk_reg);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Unable to enable the register clk: %d\\n\",\n\t\t\t\tret);\n\t\t\tgoto err_register;\n\t\t}\n\t}\n\n\tret = (dev->of_node) ? of_get_omap_rng_device_details(priv, pdev) :\n\t\t\t\tget_omap_rng_device_details(priv);\n\tif (ret)\n\t\tgoto err_register;\n\n\tret = devm_hwrng_register(&pdev->dev, &priv->rng);\n\tif (ret)\n\t\tgoto err_register;\n\n\tdev_info(&pdev->dev, \"Random Number Generator ver. %02x\\n\",\n\t\t omap_rng_read(priv, RNG_REV_REG));\n\n\treturn 0;\n\nerr_register:\n\tpriv->base = NULL;\n\tpm_runtime_put_sync(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\n\tclk_disable_unprepare(priv->clk_reg);\n\tclk_disable_unprepare(priv->clk);\nerr_ioremap:\n\tdev_err(dev, \"initialization failed.\\n\");\n\treturn ret;\n}\n\nstatic int omap_rng_remove(struct platform_device *pdev)\n{\n\tstruct omap_rng_dev *priv = platform_get_drvdata(pdev);\n\n\n\tpriv->pdata->cleanup(priv);\n\n\tpm_runtime_put_sync(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\n\tclk_disable_unprepare(priv->clk);\n\tclk_disable_unprepare(priv->clk_reg);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused omap_rng_suspend(struct device *dev)\n{\n\tstruct omap_rng_dev *priv = dev_get_drvdata(dev);\n\n\tpriv->pdata->cleanup(priv);\n\tpm_runtime_put_sync(dev);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused omap_rng_resume(struct device *dev)\n{\n\tstruct omap_rng_dev *priv = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to runtime_get device: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpriv->pdata->init(priv);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(omap_rng_pm, omap_rng_suspend, omap_rng_resume);\n\nstatic struct platform_driver omap_rng_driver = {\n\t.driver = {\n\t\t.name\t\t= \"omap_rng\",\n\t\t.pm\t\t= &omap_rng_pm,\n\t\t.of_match_table = of_match_ptr(omap_rng_of_match),\n\t},\n\t.probe\t\t= omap_rng_probe,\n\t.remove\t\t= omap_rng_remove,\n};\n\nmodule_platform_driver(omap_rng_driver);\nMODULE_ALIAS(\"platform:omap_rng\");\nMODULE_AUTHOR(\"Deepak Saxena (and others)\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}