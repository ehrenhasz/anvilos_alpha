{
  "module_name": "optee-rng.c",
  "hash_id": "6de07c5b593d082a9101d4df152b2f23a723d11c6354e8df6754f279d976b495",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/hw_random/optee-rng.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/of.h>\n#include <linux/hw_random.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/tee_drv.h>\n#include <linux/uuid.h>\n\n#define DRIVER_NAME \"optee-rng\"\n\n#define TEE_ERROR_HEALTH_TEST_FAIL\t0x00000001\n\n \n#define TA_CMD_GET_ENTROPY\t\t0x0\n\n \n#define TA_CMD_GET_RNG_INFO\t\t0x1\n\n#define MAX_ENTROPY_REQ_SZ\t\t(4 * 1024)\n\n \nstruct optee_rng_private {\n\tstruct device *dev;\n\tstruct tee_context *ctx;\n\tu32 session_id;\n\tu32 data_rate;\n\tstruct tee_shm *entropy_shm_pool;\n\tstruct hwrng optee_rng;\n};\n\n#define to_optee_rng_private(r) \\\n\t\tcontainer_of(r, struct optee_rng_private, optee_rng)\n\nstatic size_t get_optee_rng_data(struct optee_rng_private *pvt_data,\n\t\t\t\t void *buf, size_t req_size)\n{\n\tint ret = 0;\n\tu8 *rng_data = NULL;\n\tsize_t rng_size = 0;\n\tstruct tee_ioctl_invoke_arg inv_arg;\n\tstruct tee_param param[4];\n\n\tmemset(&inv_arg, 0, sizeof(inv_arg));\n\tmemset(&param, 0, sizeof(param));\n\n\t \n\tinv_arg.func = TA_CMD_GET_ENTROPY;\n\tinv_arg.session = pvt_data->session_id;\n\tinv_arg.num_params = 4;\n\n\t \n\tparam[0].attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INOUT;\n\tparam[0].u.memref.shm = pvt_data->entropy_shm_pool;\n\tparam[0].u.memref.size = req_size;\n\tparam[0].u.memref.shm_offs = 0;\n\n\tret = tee_client_invoke_func(pvt_data->ctx, &inv_arg, param);\n\tif ((ret < 0) || (inv_arg.ret != 0)) {\n\t\tdev_err(pvt_data->dev, \"TA_CMD_GET_ENTROPY invoke err: %x\\n\",\n\t\t\tinv_arg.ret);\n\t\treturn 0;\n\t}\n\n\trng_data = tee_shm_get_va(pvt_data->entropy_shm_pool, 0);\n\tif (IS_ERR(rng_data)) {\n\t\tdev_err(pvt_data->dev, \"tee_shm_get_va failed\\n\");\n\t\treturn 0;\n\t}\n\n\trng_size = param[0].u.memref.size;\n\tmemcpy(buf, rng_data, rng_size);\n\n\treturn rng_size;\n}\n\nstatic int optee_rng_read(struct hwrng *rng, void *buf, size_t max, bool wait)\n{\n\tstruct optee_rng_private *pvt_data = to_optee_rng_private(rng);\n\tsize_t read = 0, rng_size;\n\tint timeout = 1;\n\tu8 *data = buf;\n\n\tif (max > MAX_ENTROPY_REQ_SZ)\n\t\tmax = MAX_ENTROPY_REQ_SZ;\n\n\twhile (read < max) {\n\t\trng_size = get_optee_rng_data(pvt_data, data, (max - read));\n\n\t\tdata += rng_size;\n\t\tread += rng_size;\n\n\t\tif (wait && pvt_data->data_rate) {\n\t\t\tif ((timeout-- == 0) || (read == max))\n\t\t\t\treturn read;\n\t\t\tmsleep((1000 * (max - read)) / pvt_data->data_rate);\n\t\t} else {\n\t\t\treturn read;\n\t\t}\n\t}\n\n\treturn read;\n}\n\nstatic int optee_rng_init(struct hwrng *rng)\n{\n\tstruct optee_rng_private *pvt_data = to_optee_rng_private(rng);\n\tstruct tee_shm *entropy_shm_pool = NULL;\n\n\tentropy_shm_pool = tee_shm_alloc_kernel_buf(pvt_data->ctx,\n\t\t\t\t\t\t    MAX_ENTROPY_REQ_SZ);\n\tif (IS_ERR(entropy_shm_pool)) {\n\t\tdev_err(pvt_data->dev, \"tee_shm_alloc_kernel_buf failed\\n\");\n\t\treturn PTR_ERR(entropy_shm_pool);\n\t}\n\n\tpvt_data->entropy_shm_pool = entropy_shm_pool;\n\n\treturn 0;\n}\n\nstatic void optee_rng_cleanup(struct hwrng *rng)\n{\n\tstruct optee_rng_private *pvt_data = to_optee_rng_private(rng);\n\n\ttee_shm_free(pvt_data->entropy_shm_pool);\n}\n\nstatic struct optee_rng_private pvt_data = {\n\t.optee_rng = {\n\t\t.name\t\t= DRIVER_NAME,\n\t\t.init\t\t= optee_rng_init,\n\t\t.cleanup\t= optee_rng_cleanup,\n\t\t.read\t\t= optee_rng_read,\n\t}\n};\n\nstatic int get_optee_rng_info(struct device *dev)\n{\n\tint ret = 0;\n\tstruct tee_ioctl_invoke_arg inv_arg;\n\tstruct tee_param param[4];\n\n\tmemset(&inv_arg, 0, sizeof(inv_arg));\n\tmemset(&param, 0, sizeof(param));\n\n\t \n\tinv_arg.func = TA_CMD_GET_RNG_INFO;\n\tinv_arg.session = pvt_data.session_id;\n\tinv_arg.num_params = 4;\n\n\t \n\tparam[0].attr = TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_OUTPUT;\n\n\tret = tee_client_invoke_func(pvt_data.ctx, &inv_arg, param);\n\tif ((ret < 0) || (inv_arg.ret != 0)) {\n\t\tdev_err(dev, \"TA_CMD_GET_RNG_INFO invoke err: %x\\n\",\n\t\t\tinv_arg.ret);\n\t\treturn -EINVAL;\n\t}\n\n\tpvt_data.data_rate = param[0].u.value.a;\n\tpvt_data.optee_rng.quality = param[0].u.value.b;\n\n\treturn 0;\n}\n\nstatic int optee_ctx_match(struct tee_ioctl_version_data *ver, const void *data)\n{\n\tif (ver->impl_id == TEE_IMPL_ID_OPTEE)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nstatic int optee_rng_probe(struct device *dev)\n{\n\tstruct tee_client_device *rng_device = to_tee_client_device(dev);\n\tint ret = 0, err = -ENODEV;\n\tstruct tee_ioctl_open_session_arg sess_arg;\n\n\tmemset(&sess_arg, 0, sizeof(sess_arg));\n\n\t \n\tpvt_data.ctx = tee_client_open_context(NULL, optee_ctx_match, NULL,\n\t\t\t\t\t       NULL);\n\tif (IS_ERR(pvt_data.ctx))\n\t\treturn -ENODEV;\n\n\t \n\texport_uuid(sess_arg.uuid, &rng_device->id.uuid);\n\tsess_arg.clnt_login = TEE_IOCTL_LOGIN_PUBLIC;\n\tsess_arg.num_params = 0;\n\n\tret = tee_client_open_session(pvt_data.ctx, &sess_arg, NULL);\n\tif ((ret < 0) || (sess_arg.ret != 0)) {\n\t\tdev_err(dev, \"tee_client_open_session failed, err: %x\\n\",\n\t\t\tsess_arg.ret);\n\t\terr = -EINVAL;\n\t\tgoto out_ctx;\n\t}\n\tpvt_data.session_id = sess_arg.session;\n\n\terr = get_optee_rng_info(dev);\n\tif (err)\n\t\tgoto out_sess;\n\n\terr = devm_hwrng_register(dev, &pvt_data.optee_rng);\n\tif (err) {\n\t\tdev_err(dev, \"hwrng registration failed (%d)\\n\", err);\n\t\tgoto out_sess;\n\t}\n\n\tpvt_data.dev = dev;\n\n\treturn 0;\n\nout_sess:\n\ttee_client_close_session(pvt_data.ctx, pvt_data.session_id);\nout_ctx:\n\ttee_client_close_context(pvt_data.ctx);\n\n\treturn err;\n}\n\nstatic int optee_rng_remove(struct device *dev)\n{\n\ttee_client_close_session(pvt_data.ctx, pvt_data.session_id);\n\ttee_client_close_context(pvt_data.ctx);\n\n\treturn 0;\n}\n\nstatic const struct tee_client_device_id optee_rng_id_table[] = {\n\t{UUID_INIT(0xab7a617c, 0xb8e7, 0x4d8f,\n\t\t   0x83, 0x01, 0xd0, 0x9b, 0x61, 0x03, 0x6b, 0x64)},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(tee, optee_rng_id_table);\n\nstatic struct tee_client_driver optee_rng_driver = {\n\t.id_table\t= optee_rng_id_table,\n\t.driver\t\t= {\n\t\t.name\t\t= DRIVER_NAME,\n\t\t.bus\t\t= &tee_bus_type,\n\t\t.probe\t\t= optee_rng_probe,\n\t\t.remove\t\t= optee_rng_remove,\n\t},\n};\n\nstatic int __init optee_rng_mod_init(void)\n{\n\treturn driver_register(&optee_rng_driver.driver);\n}\n\nstatic void __exit optee_rng_mod_exit(void)\n{\n\tdriver_unregister(&optee_rng_driver.driver);\n}\n\nmodule_init(optee_rng_mod_init);\nmodule_exit(optee_rng_mod_exit);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Sumit Garg <sumit.garg@linaro.org>\");\nMODULE_DESCRIPTION(\"OP-TEE based random number generator driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}