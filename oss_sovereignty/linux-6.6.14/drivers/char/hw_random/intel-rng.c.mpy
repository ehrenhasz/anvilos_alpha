{
  "module_name": "intel-rng.c",
  "hash_id": "c182b870fca454ca76d929ef3ad7db3a9517cef60a137869b93bf6f11f7ab4d5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/hw_random/intel-rng.c",
  "human_readable_source": " \n\n#include <linux/hw_random.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n\n\n#define PFX\tKBUILD_MODNAME \": \"\n\n \n#define INTEL_RNG_HW_STATUS\t\t\t0\n#define         INTEL_RNG_PRESENT\t\t0x40\n#define         INTEL_RNG_ENABLED\t\t0x01\n#define INTEL_RNG_STATUS\t\t\t1\n#define         INTEL_RNG_DATA_PRESENT\t\t0x01\n#define INTEL_RNG_DATA\t\t\t\t2\n\n \n#define INTEL_RNG_ADDR\t\t\t\t0xFFBC015F\n#define INTEL_RNG_ADDR_LEN\t\t\t3\n\n \n#define FWH_DEC_EN1_REG_OLD\t\t\t0xe3\n#define FWH_DEC_EN1_REG_NEW\t\t\t0xd9  \n#define FWH_F8_EN_MASK\t\t\t\t0x80\n\n#define BIOS_CNTL_REG_OLD\t\t\t0x4e\n#define BIOS_CNTL_REG_NEW\t\t\t0xdc\n#define BIOS_CNTL_WRITE_ENABLE_MASK\t\t0x01\n#define BIOS_CNTL_LOCK_ENABLE_MASK\t\t0x02\n\n \n#define INTEL_FWH_ADDR\t\t\t\t0xffff0000\n#define INTEL_FWH_ADDR_LEN\t\t\t2\n\n \n#define INTEL_FWH_RESET_CMD\t\t\t0xff  \n#define INTEL_FWH_READ_ID_CMD\t\t\t0x90\n\n \n#define INTEL_FWH_MANUFACTURER_CODE_ADDRESS\t0x000000\n#define INTEL_FWH_DEVICE_CODE_ADDRESS\t\t0x000001\n\n \n#define INTEL_FWH_MANUFACTURER_CODE\t\t0x89\n#define INTEL_FWH_DEVICE_CODE_8M\t\t0xac\n#define INTEL_FWH_DEVICE_CODE_4M\t\t0xad\n\n \nstatic const struct pci_device_id pci_tbl[] = {\n \n\t{ PCI_DEVICE(0x8086, 0x2410) },  \n \n\t{ PCI_DEVICE(0x8086, 0x2420) },  \n \n \n\t{ PCI_DEVICE(0x8086, 0x244c) },  \n\t{ PCI_DEVICE(0x8086, 0x248c) },  \n\t{ PCI_DEVICE(0x8086, 0x24cc) },  \n\t{ PCI_DEVICE(0x8086, 0x2641) },  \n\t{ PCI_DEVICE(0x8086, 0x27b9) },  \n\t{ PCI_DEVICE(0x8086, 0x27bd) },  \n \n\t{ PCI_DEVICE(0x8086, 0x2440) },  \n\t{ PCI_DEVICE(0x8086, 0x2480) },  \n\t{ PCI_DEVICE(0x8086, 0x24c0) },  \n\t{ PCI_DEVICE(0x8086, 0x24d0) },  \n\t{ PCI_DEVICE(0x8086, 0x25a1) },  \n\t{ PCI_DEVICE(0x8086, 0x2640) },  \n\t{ PCI_DEVICE(0x8086, 0x2670) },  \n\t{ PCI_DEVICE(0x8086, 0x2671) },  \n\t{ PCI_DEVICE(0x8086, 0x2672) },  \n\t{ PCI_DEVICE(0x8086, 0x2673) },  \n\t{ PCI_DEVICE(0x8086, 0x2674) },  \n\t{ PCI_DEVICE(0x8086, 0x2675) },  \n\t{ PCI_DEVICE(0x8086, 0x2676) },  \n\t{ PCI_DEVICE(0x8086, 0x2677) },  \n\t{ PCI_DEVICE(0x8086, 0x2678) },  \n\t{ PCI_DEVICE(0x8086, 0x2679) },  \n\t{ PCI_DEVICE(0x8086, 0x267a) },  \n\t{ PCI_DEVICE(0x8086, 0x267b) },  \n\t{ PCI_DEVICE(0x8086, 0x267c) },  \n\t{ PCI_DEVICE(0x8086, 0x267d) },  \n\t{ PCI_DEVICE(0x8086, 0x267e) },  \n\t{ PCI_DEVICE(0x8086, 0x267f) },  \n\t{ PCI_DEVICE(0x8086, 0x27b8) },  \n \n\t{ PCI_DEVICE(0x8086, 0x2450) },  \n\t{ 0, },\t \n};\nMODULE_DEVICE_TABLE(pci, pci_tbl);\n\nstatic __initdata int no_fwh_detect;\nmodule_param(no_fwh_detect, int, 0);\nMODULE_PARM_DESC(no_fwh_detect, \"Skip FWH detection:\\n\"\n                                \" positive value - skip if FWH space locked read-only\\n\"\n                                \" negative value - skip always\");\n\nstatic inline u8 hwstatus_get(void __iomem *mem)\n{\n\treturn readb(mem + INTEL_RNG_HW_STATUS);\n}\n\nstatic inline u8 hwstatus_set(void __iomem *mem,\n\t\t\t      u8 hw_status)\n{\n\twriteb(hw_status, mem + INTEL_RNG_HW_STATUS);\n\treturn hwstatus_get(mem);\n}\n\nstatic int intel_rng_data_present(struct hwrng *rng, int wait)\n{\n\tvoid __iomem *mem = (void __iomem *)rng->priv;\n\tint data, i;\n\n\tfor (i = 0; i < 20; i++) {\n\t\tdata = !!(readb(mem + INTEL_RNG_STATUS) &\n\t\t\t  INTEL_RNG_DATA_PRESENT);\n\t\tif (data || !wait)\n\t\t\tbreak;\n\t\tudelay(10);\n\t}\n\treturn data;\n}\n\nstatic int intel_rng_data_read(struct hwrng *rng, u32 *data)\n{\n\tvoid __iomem *mem = (void __iomem *)rng->priv;\n\n\t*data = readb(mem + INTEL_RNG_DATA);\n\n\treturn 1;\n}\n\nstatic int intel_rng_init(struct hwrng *rng)\n{\n\tvoid __iomem *mem = (void __iomem *)rng->priv;\n\tu8 hw_status;\n\tint err = -EIO;\n\n\thw_status = hwstatus_get(mem);\n\t \n\tif ((hw_status & INTEL_RNG_ENABLED) == 0)\n\t\thw_status = hwstatus_set(mem, hw_status | INTEL_RNG_ENABLED);\n\tif ((hw_status & INTEL_RNG_ENABLED) == 0) {\n\t\tpr_err(PFX \"cannot enable RNG, aborting\\n\");\n\t\tgoto out;\n\t}\n\terr = 0;\nout:\n\treturn err;\n}\n\nstatic void intel_rng_cleanup(struct hwrng *rng)\n{\n\tvoid __iomem *mem = (void __iomem *)rng->priv;\n\tu8 hw_status;\n\n\thw_status = hwstatus_get(mem);\n\tif (hw_status & INTEL_RNG_ENABLED)\n\t\thwstatus_set(mem, hw_status & ~INTEL_RNG_ENABLED);\n\telse\n\t\tpr_warn(PFX \"unusual: RNG already disabled\\n\");\n}\n\n\nstatic struct hwrng intel_rng = {\n\t.name\t\t= \"intel\",\n\t.init\t\t= intel_rng_init,\n\t.cleanup\t= intel_rng_cleanup,\n\t.data_present\t= intel_rng_data_present,\n\t.data_read\t= intel_rng_data_read,\n};\n\nstruct intel_rng_hw {\n\tstruct pci_dev *dev;\n\tvoid __iomem *mem;\n\tu8 bios_cntl_off;\n\tu8 bios_cntl_val;\n\tu8 fwh_dec_en1_off;\n\tu8 fwh_dec_en1_val;\n};\n\nstatic int __init intel_rng_hw_init(void *_intel_rng_hw)\n{\n\tstruct intel_rng_hw *intel_rng_hw = _intel_rng_hw;\n\tu8 mfc, dvc;\n\n\t \n\n\tif (!(intel_rng_hw->fwh_dec_en1_val & FWH_F8_EN_MASK))\n\t\tpci_write_config_byte(intel_rng_hw->dev,\n\t\t                      intel_rng_hw->fwh_dec_en1_off,\n\t\t                      intel_rng_hw->fwh_dec_en1_val |\n\t\t\t\t      FWH_F8_EN_MASK);\n\tif (!(intel_rng_hw->bios_cntl_val & BIOS_CNTL_WRITE_ENABLE_MASK))\n\t\tpci_write_config_byte(intel_rng_hw->dev,\n\t\t                      intel_rng_hw->bios_cntl_off,\n\t\t                      intel_rng_hw->bios_cntl_val |\n\t\t\t\t      BIOS_CNTL_WRITE_ENABLE_MASK);\n\n\twriteb(INTEL_FWH_RESET_CMD, intel_rng_hw->mem);\n\twriteb(INTEL_FWH_READ_ID_CMD, intel_rng_hw->mem);\n\tmfc = readb(intel_rng_hw->mem + INTEL_FWH_MANUFACTURER_CODE_ADDRESS);\n\tdvc = readb(intel_rng_hw->mem + INTEL_FWH_DEVICE_CODE_ADDRESS);\n\twriteb(INTEL_FWH_RESET_CMD, intel_rng_hw->mem);\n\n\tif (!(intel_rng_hw->bios_cntl_val &\n\t      (BIOS_CNTL_LOCK_ENABLE_MASK|BIOS_CNTL_WRITE_ENABLE_MASK)))\n\t\tpci_write_config_byte(intel_rng_hw->dev,\n\t\t\t\t      intel_rng_hw->bios_cntl_off,\n\t\t\t\t      intel_rng_hw->bios_cntl_val);\n\tif (!(intel_rng_hw->fwh_dec_en1_val & FWH_F8_EN_MASK))\n\t\tpci_write_config_byte(intel_rng_hw->dev,\n\t\t\t\t      intel_rng_hw->fwh_dec_en1_off,\n\t\t\t\t      intel_rng_hw->fwh_dec_en1_val);\n\n\tif (mfc != INTEL_FWH_MANUFACTURER_CODE ||\n\t    (dvc != INTEL_FWH_DEVICE_CODE_8M &&\n\t     dvc != INTEL_FWH_DEVICE_CODE_4M)) {\n\t\tpr_notice(PFX \"FWH not detected\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int __init intel_init_hw_struct(struct intel_rng_hw *intel_rng_hw,\n\t\t\t\t\tstruct pci_dev *dev)\n{\n\tintel_rng_hw->bios_cntl_val = 0xff;\n\tintel_rng_hw->fwh_dec_en1_val = 0xff;\n\tintel_rng_hw->dev = dev;\n\n\t \n\tif (dev->device < 0x2640) {\n\t\tintel_rng_hw->fwh_dec_en1_off = FWH_DEC_EN1_REG_OLD;\n\t\tintel_rng_hw->bios_cntl_off = BIOS_CNTL_REG_OLD;\n\t} else {\n\t\tintel_rng_hw->fwh_dec_en1_off = FWH_DEC_EN1_REG_NEW;\n\t\tintel_rng_hw->bios_cntl_off = BIOS_CNTL_REG_NEW;\n\t}\n\n\tpci_read_config_byte(dev, intel_rng_hw->fwh_dec_en1_off,\n\t\t\t     &intel_rng_hw->fwh_dec_en1_val);\n\tpci_read_config_byte(dev, intel_rng_hw->bios_cntl_off,\n\t\t\t     &intel_rng_hw->bios_cntl_val);\n\n\tif ((intel_rng_hw->bios_cntl_val &\n\t     (BIOS_CNTL_LOCK_ENABLE_MASK|BIOS_CNTL_WRITE_ENABLE_MASK))\n\t    == BIOS_CNTL_LOCK_ENABLE_MASK) {\n\t\tstatic __initdata   char warning[] =\nPFX \"Firmware space is locked read-only. If you can't or\\n\"\nPFX \"don't want to disable this in firmware setup, and if\\n\"\nPFX \"you are certain that your system has a functional\\n\"\nPFX \"RNG, try using the 'no_fwh_detect' option.\\n\";\n\n\t\tif (no_fwh_detect)\n\t\t\treturn -ENODEV;\n\t\tpr_warn(\"%s\", warning);\n\t\treturn -EBUSY;\n\t}\n\n\tintel_rng_hw->mem = ioremap(INTEL_FWH_ADDR, INTEL_FWH_ADDR_LEN);\n\tif (intel_rng_hw->mem == NULL)\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n\n\nstatic int __init intel_rng_mod_init(void)\n{\n\tint err = -ENODEV;\n\tint i;\n\tstruct pci_dev *dev = NULL;\n\tvoid __iomem *mem;\n\tu8 hw_status;\n\tstruct intel_rng_hw *intel_rng_hw;\n\n\tfor (i = 0; !dev && pci_tbl[i].vendor; ++i)\n\t\tdev = pci_get_device(pci_tbl[i].vendor, pci_tbl[i].device,\n\t\t\t\t     NULL);\n\n\tif (!dev)\n\t\tgoto out;  \n\n\tif (no_fwh_detect < 0) {\n\t\tpci_dev_put(dev);\n\t\tgoto fwh_done;\n\t}\n\n\tintel_rng_hw = kmalloc(sizeof(*intel_rng_hw), GFP_KERNEL);\n\tif (!intel_rng_hw) {\n\t\tpci_dev_put(dev);\n\t\tgoto out;\n\t}\n\n\terr = intel_init_hw_struct(intel_rng_hw, dev);\n\tif (err) {\n\t\tpci_dev_put(dev);\n\t\tkfree(intel_rng_hw);\n\t\tif (err == -ENODEV)\n\t\t\tgoto fwh_done;\n\t\tgoto out;\n\t}\n\n\t \n\terr = stop_machine(intel_rng_hw_init, intel_rng_hw, NULL);\n\tpci_dev_put(dev);\n\tiounmap(intel_rng_hw->mem);\n\tkfree(intel_rng_hw);\n\tif (err)\n\t\tgoto out;\n\nfwh_done:\n\terr = -ENOMEM;\n\tmem = ioremap(INTEL_RNG_ADDR, INTEL_RNG_ADDR_LEN);\n\tif (!mem)\n\t\tgoto out;\n\tintel_rng.priv = (unsigned long)mem;\n\n\t \n\terr = -ENODEV;\n\thw_status = hwstatus_get(mem);\n\tif ((hw_status & INTEL_RNG_PRESENT) == 0) {\n\t\tiounmap(mem);\n\t\tgoto out;\n\t}\n\n\tpr_info(\"Intel 82802 RNG detected\\n\");\n\terr = hwrng_register(&intel_rng);\n\tif (err) {\n\t\tpr_err(PFX \"RNG registering failed (%d)\\n\",\n\t\t       err);\n\t\tiounmap(mem);\n\t}\nout:\n\treturn err;\n\n}\n\nstatic void __exit intel_rng_mod_exit(void)\n{\n\tvoid __iomem *mem = (void __iomem *)intel_rng.priv;\n\n\thwrng_unregister(&intel_rng);\n\tiounmap(mem);\n}\n\nmodule_init(intel_rng_mod_init);\nmodule_exit(intel_rng_mod_exit);\n\nMODULE_DESCRIPTION(\"H/W RNG driver for Intel chipsets\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}