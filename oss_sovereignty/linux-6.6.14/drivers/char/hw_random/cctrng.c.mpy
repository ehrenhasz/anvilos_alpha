{
  "module_name": "cctrng.c",
  "hash_id": "1ace64fceb0f9e2e3c9372002f5a97c6307bf3232914ad8fc810fe34386a7dfe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/hw_random/cctrng.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/clk.h>\n#include <linux/hw_random.h>\n#include <linux/io.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/interrupt.h>\n#include <linux/irqreturn.h>\n#include <linux/workqueue.h>\n#include <linux/circ_buf.h>\n#include <linux/completion.h>\n#include <linux/of.h>\n#include <linux/bitfield.h>\n#include <linux/fips.h>\n\n#include \"cctrng.h\"\n\n#define CC_REG_LOW(name)  (name ## _BIT_SHIFT)\n#define CC_REG_HIGH(name) (CC_REG_LOW(name) + name ## _BIT_SIZE - 1)\n#define CC_GENMASK(name)  GENMASK(CC_REG_HIGH(name), CC_REG_LOW(name))\n\n#define CC_REG_FLD_GET(reg_name, fld_name, reg_val)     \\\n\t(FIELD_GET(CC_GENMASK(CC_ ## reg_name ## _ ## fld_name), reg_val))\n\n#define CC_HW_RESET_LOOP_COUNT 10\n#define CC_TRNG_SUSPEND_TIMEOUT 3000\n\n \n#define CCTRNG_DATA_BUF_WORDS 32\n\n \n#define EHR_NUM 1\n#define VN_COEFF 4\n#define EHR_LENGTH CC_TRNG_EHR_IN_BITS\n#define SCALE_VALUE 2\n#define CCTRNG_TIMEOUT(smpl_cnt) \\\n\t(EHR_NUM * VN_COEFF * EHR_LENGTH * smpl_cnt * SCALE_VALUE)\n\nstruct cctrng_drvdata {\n\tstruct platform_device *pdev;\n\tvoid __iomem *cc_base;\n\tstruct clk *clk;\n\tstruct hwrng rng;\n\tu32 active_rosc;\n\t \n\tu32 smpl_ratio[CC_TRNG_NUM_OF_ROSCS];\n\n\tu32 data_buf[CCTRNG_DATA_BUF_WORDS];\n\tstruct circ_buf circ;\n\tstruct work_struct compwork;\n\tstruct work_struct startwork;\n\n\t \n\tatomic_t pending_hw;\n\n\t \n\tspinlock_t read_lock;\n};\n\n\n \nstatic inline void cc_iowrite(struct cctrng_drvdata *drvdata, u32 reg, u32 val)\n{\n\tiowrite32(val, (drvdata->cc_base + reg));\n}\nstatic inline u32 cc_ioread(struct cctrng_drvdata *drvdata, u32 reg)\n{\n\treturn ioread32(drvdata->cc_base + reg);\n}\n\n\nstatic int cc_trng_pm_get(struct device *dev)\n{\n\tint rc = 0;\n\n\trc = pm_runtime_get_sync(dev);\n\n\t \n\treturn (rc == 1 ? 0 : rc);\n}\n\nstatic void cc_trng_pm_put_suspend(struct device *dev)\n{\n\tint rc = 0;\n\n\tpm_runtime_mark_last_busy(dev);\n\trc = pm_runtime_put_autosuspend(dev);\n\tif (rc)\n\t\tdev_err(dev, \"pm_runtime_put_autosuspend returned %x\\n\", rc);\n}\n\nstatic int cc_trng_pm_init(struct cctrng_drvdata *drvdata)\n{\n\tstruct device *dev = &(drvdata->pdev->dev);\n\n\t \n\tpm_runtime_set_autosuspend_delay(dev, CC_TRNG_SUSPEND_TIMEOUT);\n\tpm_runtime_use_autosuspend(dev);\n\t \n\treturn pm_runtime_set_active(dev);\n}\n\nstatic void cc_trng_pm_go(struct cctrng_drvdata *drvdata)\n{\n\tstruct device *dev = &(drvdata->pdev->dev);\n\n\t \n\tpm_runtime_enable(dev);\n}\n\nstatic void cc_trng_pm_fini(struct cctrng_drvdata *drvdata)\n{\n\tstruct device *dev = &(drvdata->pdev->dev);\n\n\tpm_runtime_disable(dev);\n}\n\n\nstatic inline int cc_trng_parse_sampling_ratio(struct cctrng_drvdata *drvdata)\n{\n\tstruct device *dev = &(drvdata->pdev->dev);\n\tstruct device_node *np = drvdata->pdev->dev.of_node;\n\tint rc;\n\tint i;\n\t \n\tint ret = -EINVAL;\n\n\trc = of_property_read_u32_array(np, \"arm,rosc-ratio\",\n\t\t\t\t\tdrvdata->smpl_ratio,\n\t\t\t\t\tCC_TRNG_NUM_OF_ROSCS);\n\tif (rc) {\n\t\t \n\t\treturn rc;\n\t}\n\n\t \n\tfor (i = 0; i < CC_TRNG_NUM_OF_ROSCS; ++i) {\n\t\tdev_dbg(dev, \"rosc %d sampling ratio %u\",\n\t\t\ti, drvdata->smpl_ratio[i]);\n\n\t\tif (drvdata->smpl_ratio[i] > 0)\n\t\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\nstatic int cc_trng_change_rosc(struct cctrng_drvdata *drvdata)\n{\n\tstruct device *dev = &(drvdata->pdev->dev);\n\n\tdev_dbg(dev, \"cctrng change rosc (was %d)\\n\", drvdata->active_rosc);\n\tdrvdata->active_rosc += 1;\n\n\twhile (drvdata->active_rosc < CC_TRNG_NUM_OF_ROSCS) {\n\t\tif (drvdata->smpl_ratio[drvdata->active_rosc] > 0)\n\t\t\treturn 0;\n\n\t\tdrvdata->active_rosc += 1;\n\t}\n\treturn -EINVAL;\n}\n\n\nstatic void cc_trng_enable_rnd_source(struct cctrng_drvdata *drvdata)\n{\n\tu32 max_cycles;\n\n\t \n\tmax_cycles = CCTRNG_TIMEOUT(drvdata->smpl_ratio[drvdata->active_rosc]);\n\tcc_iowrite(drvdata, CC_RNG_WATCHDOG_VAL_REG_OFFSET, max_cycles);\n\n\t \n\tcc_iowrite(drvdata, CC_RND_SOURCE_ENABLE_REG_OFFSET, 0x1);\n\n\t \n\tcc_iowrite(drvdata, CC_RNG_IMR_REG_OFFSET, (u32)~CC_RNG_INT_MASK);\n}\n\n\n \nstatic inline void circ_idx_inc(int *idx, int bytes)\n{\n\t*idx += (bytes + 3) >> 2;\n\t*idx &= (CCTRNG_DATA_BUF_WORDS - 1);\n}\n\nstatic inline size_t circ_buf_space(struct cctrng_drvdata *drvdata)\n{\n\treturn CIRC_SPACE(drvdata->circ.head,\n\t\t\t  drvdata->circ.tail, CCTRNG_DATA_BUF_WORDS);\n\n}\n\nstatic int cctrng_read(struct hwrng *rng, void *data, size_t max, bool wait)\n{\n\t \n\n\tstruct cctrng_drvdata *drvdata = (struct cctrng_drvdata *)rng->priv;\n\tstruct device *dev = &(drvdata->pdev->dev);\n\tu32 *buf = (u32 *)drvdata->circ.buf;\n\tsize_t copied = 0;\n\tsize_t cnt_w;\n\tsize_t size;\n\tsize_t left;\n\n\tif (!spin_trylock(&drvdata->read_lock)) {\n\t\t \n\t\tdev_dbg_ratelimited(dev, \"unable to hold lock\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tcnt_w = CIRC_CNT_TO_END(drvdata->circ.head,\n\t\t\t\tdrvdata->circ.tail, CCTRNG_DATA_BUF_WORDS);\n\tsize = min((cnt_w<<2), max);\n\tmemcpy(data, &(buf[drvdata->circ.tail]), size);\n\tcopied = size;\n\tcirc_idx_inc(&drvdata->circ.tail, size);\n\t \n\tleft = max - copied;\n\tif (left > 0) {\n\t\tcnt_w = CIRC_CNT(drvdata->circ.head,\n\t\t\t\t drvdata->circ.tail, CCTRNG_DATA_BUF_WORDS);\n\t\tsize = min((cnt_w<<2), left);\n\t\tmemcpy(data, &(buf[drvdata->circ.tail]), size);\n\t\tcopied += size;\n\t\tcirc_idx_inc(&drvdata->circ.tail, size);\n\t}\n\n\tspin_unlock(&drvdata->read_lock);\n\n\tif (circ_buf_space(drvdata) >= CC_TRNG_EHR_IN_WORDS) {\n\t\tif (atomic_cmpxchg(&drvdata->pending_hw, 0, 1) == 0) {\n\t\t\t \n\t\t\tif (circ_buf_space(drvdata) >= CC_TRNG_EHR_IN_WORDS) {\n\t\t\t\t \n\t\t\t\tint rc = cc_trng_pm_get(dev);\n\n\t\t\t\tif (rc) {\n\t\t\t\t\tdev_err(dev,\n\t\t\t\t\t\t\"cc_trng_pm_get returned %x\\n\",\n\t\t\t\t\t\trc);\n\t\t\t\t\treturn rc;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tschedule_work(&drvdata->startwork);\n\t\t\t} else {\n\t\t\t\tatomic_set(&drvdata->pending_hw, 0);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn copied;\n}\n\nstatic void cc_trng_hw_trigger(struct cctrng_drvdata *drvdata)\n{\n\tu32 tmp_smpl_cnt = 0;\n\tstruct device *dev = &(drvdata->pdev->dev);\n\n\tdev_dbg(dev, \"cctrng hw trigger.\\n\");\n\n\t \n\tcc_iowrite(drvdata, CC_RNG_CLK_ENABLE_REG_OFFSET, 0x1);\n\n\t \n\tcc_iowrite(drvdata, CC_RNG_SW_RESET_REG_OFFSET, 0x1);\n\t \n\tdo {\n\t\t \n\t\tcc_iowrite(drvdata, CC_RNG_CLK_ENABLE_REG_OFFSET, 0x1);\n\n\t\t \n\t\tcc_iowrite(drvdata, CC_SAMPLE_CNT1_REG_OFFSET,\n\t\t\t   drvdata->smpl_ratio[drvdata->active_rosc]);\n\n\t\t \n\t\ttmp_smpl_cnt = cc_ioread(drvdata, CC_SAMPLE_CNT1_REG_OFFSET);\n\n\t} while (tmp_smpl_cnt != drvdata->smpl_ratio[drvdata->active_rosc]);\n\n\t \n\tcc_iowrite(drvdata, CC_RND_SOURCE_ENABLE_REG_OFFSET, 0);\n\n\tcc_iowrite(drvdata, CC_RNG_ICR_REG_OFFSET, 0xFFFFFFFF);\n\n\tcc_iowrite(drvdata, CC_TRNG_CONFIG_REG_OFFSET, drvdata->active_rosc);\n\n\t \n\tcc_iowrite(drvdata, CC_TRNG_DEBUG_CONTROL_REG_OFFSET, 0);\n\n\tcc_trng_enable_rnd_source(drvdata);\n}\n\nstatic void cc_trng_compwork_handler(struct work_struct *w)\n{\n\tu32 isr = 0;\n\tu32 ehr_valid = 0;\n\tstruct cctrng_drvdata *drvdata =\n\t\t\tcontainer_of(w, struct cctrng_drvdata, compwork);\n\tstruct device *dev = &(drvdata->pdev->dev);\n\tint i;\n\n\t \n\tcc_iowrite(drvdata, CC_RNG_DMA_ENABLE_REG_OFFSET, 0);\n\tcc_iowrite(drvdata, CC_RND_SOURCE_ENABLE_REG_OFFSET, 0);\n\n\t \n\tisr = cc_ioread(drvdata, CC_RNG_ISR_REG_OFFSET);\n\tehr_valid = CC_REG_FLD_GET(RNG_ISR, EHR_VALID, isr);\n\tdev_dbg(dev, \"Got RNG_ISR=0x%08X (EHR_VALID=%u)\\n\", isr, ehr_valid);\n\n\tif (fips_enabled && CC_REG_FLD_GET(RNG_ISR, CRNGT_ERR, isr)) {\n\t\tfips_fail_notify();\n\t\t \n\t\tpanic(\"Got HW CRNGT error while fips is enabled!\\n\");\n\t}\n\n\t \n\tcc_iowrite(drvdata, CC_RNG_ICR_REG_OFFSET, isr);\n\n\n\tif (!ehr_valid) {\n\t\t \n\t\tif (CC_REG_FLD_GET(RNG_ISR, AUTOCORR_ERR, isr) ||\n\t\t\t\tCC_REG_FLD_GET(RNG_ISR, WATCHDOG, isr)) {\n\t\t\tdev_dbg(dev, \"cctrng autocorr/timeout error.\\n\");\n\t\t\tgoto next_rosc;\n\t\t}\n\n\t\t \n\t}\n\n\t \n\tfor (i = 0; i < CC_TRNG_EHR_IN_WORDS; i++) {\n\t\t \n\t\tu32 *buf = (u32 *)drvdata->circ.buf;\n\n\t\tbuf[drvdata->circ.head] = cc_ioread(drvdata,\n\t\t\t\tCC_EHR_DATA_0_REG_OFFSET + (i*sizeof(u32)));\n\n\t\t \n\t\tif (buf[drvdata->circ.head] == 0) {\n\t\t\tdev_dbg(dev, \"Got 0 value in EHR. active_rosc %u\\n\",\n\t\t\t\tdrvdata->active_rosc);\n\t\t\tgoto next_rosc;\n\t\t}\n\n\t\tcirc_idx_inc(&drvdata->circ.head, 1<<2);\n\t}\n\n\tatomic_set(&drvdata->pending_hw, 0);\n\n\t \n\tif (circ_buf_space(drvdata) >= CC_TRNG_EHR_IN_WORDS) {\n\t\tif (atomic_cmpxchg(&drvdata->pending_hw, 0, 1) == 0) {\n\t\t\t \n\t\t\tcc_trng_enable_rnd_source(drvdata);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tcc_trng_pm_put_suspend(dev);\n\n\tdev_dbg(dev, \"compwork handler done\\n\");\n\treturn;\n\nnext_rosc:\n\tif ((circ_buf_space(drvdata) >= CC_TRNG_EHR_IN_WORDS) &&\n\t\t\t(cc_trng_change_rosc(drvdata) == 0)) {\n\t\t \n\t\tcc_trng_hw_trigger(drvdata);\n\t} else {\n\t\tatomic_set(&drvdata->pending_hw, 0);\n\t\tcc_trng_pm_put_suspend(dev);\n\t}\n}\n\nstatic irqreturn_t cc_isr(int irq, void *dev_id)\n{\n\tstruct cctrng_drvdata *drvdata = (struct cctrng_drvdata *)dev_id;\n\tstruct device *dev = &(drvdata->pdev->dev);\n\tu32 irr;\n\n\t \n\tif (pm_runtime_suspended(dev))\n\t\treturn IRQ_NONE;\n\n\t \n\tirr = cc_ioread(drvdata, CC_HOST_RGF_IRR_REG_OFFSET);\n\tdev_dbg(dev, \"Got IRR=0x%08X\\n\", irr);\n\n\tif (irr == 0)  \n\t\treturn IRQ_NONE;\n\n\t \n\tcc_iowrite(drvdata, CC_HOST_RGF_ICR_REG_OFFSET, irr);\n\n\t \n\tif (irr & CC_HOST_RNG_IRQ_MASK) {\n\t\t \n\t\tcc_iowrite(drvdata, CC_RNG_IMR_REG_OFFSET, 0xFFFFFFFF);\n\n\t\t \n\t\tcc_iowrite(drvdata, CC_HOST_RGF_ICR_REG_OFFSET,\n\t\t\t   CC_HOST_RNG_IRQ_MASK);\n\n\t\tirr &= ~CC_HOST_RNG_IRQ_MASK;\n\n\t\t \n\t\tschedule_work(&drvdata->compwork);\n\t}\n\n\tif (irr) {\n\t\tdev_dbg_ratelimited(dev,\n\t\t\t\t\"IRR includes unknown cause bits (0x%08X)\\n\",\n\t\t\t\tirr);\n\t\t \n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void cc_trng_startwork_handler(struct work_struct *w)\n{\n\tstruct cctrng_drvdata *drvdata =\n\t\t\tcontainer_of(w, struct cctrng_drvdata, startwork);\n\n\tdrvdata->active_rosc = 0;\n\tcc_trng_hw_trigger(drvdata);\n}\n\nstatic int cctrng_probe(struct platform_device *pdev)\n{\n\tstruct cctrng_drvdata *drvdata;\n\tstruct device *dev = &pdev->dev;\n\tint rc = 0;\n\tu32 val;\n\tint irq;\n\n\t \n\tBUILD_BUG_ON(CCTRNG_DATA_BUF_WORDS < 6);\n\tBUILD_BUG_ON((CCTRNG_DATA_BUF_WORDS & (CCTRNG_DATA_BUF_WORDS-1)) != 0);\n\n\tdrvdata = devm_kzalloc(dev, sizeof(*drvdata), GFP_KERNEL);\n\tif (!drvdata)\n\t\treturn -ENOMEM;\n\n\tdrvdata->rng.name = devm_kstrdup(dev, dev_name(dev), GFP_KERNEL);\n\tif (!drvdata->rng.name)\n\t\treturn -ENOMEM;\n\n\tdrvdata->rng.read = cctrng_read;\n\tdrvdata->rng.priv = (unsigned long)drvdata;\n\tdrvdata->rng.quality = CC_TRNG_QUALITY;\n\n\tplatform_set_drvdata(pdev, drvdata);\n\tdrvdata->pdev = pdev;\n\n\tdrvdata->circ.buf = (char *)drvdata->data_buf;\n\n\tdrvdata->cc_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(drvdata->cc_base))\n\t\treturn dev_err_probe(dev, PTR_ERR(drvdata->cc_base), \"Failed to ioremap registers\");\n\n\t \n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\t \n\trc = cc_trng_parse_sampling_ratio(drvdata);\n\tif (rc)\n\t\treturn dev_err_probe(dev, rc, \"Failed to get legal sampling ratio for rosc\\n\");\n\n\tdrvdata->clk = devm_clk_get_optional_enabled(dev, NULL);\n\tif (IS_ERR(drvdata->clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(drvdata->clk),\n\t\t\t\t     \"Failed to get or enable the clock\\n\");\n\n\tINIT_WORK(&drvdata->compwork, cc_trng_compwork_handler);\n\tINIT_WORK(&drvdata->startwork, cc_trng_startwork_handler);\n\tspin_lock_init(&drvdata->read_lock);\n\n\t \n\trc = devm_request_irq(dev, irq, cc_isr, IRQF_SHARED, \"cctrng\", drvdata);\n\tif (rc)\n\t\treturn dev_err_probe(dev, rc, \"Could not register to interrupt %d\\n\", irq);\n\tdev_dbg(dev, \"Registered to IRQ: %d\\n\", irq);\n\n\t \n\tval = cc_ioread(drvdata, CC_HOST_RGF_IRR_REG_OFFSET);\n\tdev_dbg(dev, \"IRR=0x%08X\\n\", val);\n\tcc_iowrite(drvdata, CC_HOST_RGF_ICR_REG_OFFSET, val);\n\n\t \n\tcc_iowrite(drvdata, CC_HOST_RGF_IMR_REG_OFFSET,\n\t\t   cc_ioread(drvdata, CC_HOST_RGF_IMR_REG_OFFSET) &\n\t\t   ~CC_HOST_RNG_IRQ_MASK);\n\n\t \n\trc = cc_trng_pm_init(drvdata);\n\tif (rc)\n\t\treturn dev_err_probe(dev, rc, \"cc_trng_pm_init failed\\n\");\n\n\t \n\trc = cc_trng_pm_get(dev);\n\tif (rc)\n\t\treturn dev_err_probe(dev, rc, \"cc_trng_pm_get returned %x\\n\", rc);\n\n\t \n\tatomic_set(&drvdata->pending_hw, 1);\n\n\t \n\trc = devm_hwrng_register(dev, &drvdata->rng);\n\tif (rc) {\n\t\tdev_err(dev, \"Could not register hwrng device.\\n\");\n\t\tgoto post_pm_err;\n\t}\n\n\t \n\tdrvdata->active_rosc = 0;\n\tcc_trng_hw_trigger(drvdata);\n\n\t \n\tcc_trng_pm_go(drvdata);\n\n\tdev_info(dev, \"ARM cctrng device initialized\\n\");\n\n\treturn 0;\n\npost_pm_err:\n\tcc_trng_pm_fini(drvdata);\n\n\treturn rc;\n}\n\nstatic int cctrng_remove(struct platform_device *pdev)\n{\n\tstruct cctrng_drvdata *drvdata = platform_get_drvdata(pdev);\n\tstruct device *dev = &pdev->dev;\n\n\tdev_dbg(dev, \"Releasing cctrng resources...\\n\");\n\n\tcc_trng_pm_fini(drvdata);\n\n\tdev_info(dev, \"ARM cctrng device terminated\\n\");\n\n\treturn 0;\n}\n\nstatic int __maybe_unused cctrng_suspend(struct device *dev)\n{\n\tstruct cctrng_drvdata *drvdata = dev_get_drvdata(dev);\n\n\tdev_dbg(dev, \"set HOST_POWER_DOWN_EN\\n\");\n\tcc_iowrite(drvdata, CC_HOST_POWER_DOWN_EN_REG_OFFSET,\n\t\t\tPOWER_DOWN_ENABLE);\n\n\tclk_disable_unprepare(drvdata->clk);\n\n\treturn 0;\n}\n\nstatic bool cctrng_wait_for_reset_completion(struct cctrng_drvdata *drvdata)\n{\n\tunsigned int val;\n\tunsigned int i;\n\n\tfor (i = 0; i < CC_HW_RESET_LOOP_COUNT; i++) {\n\t\t \n\t\tval = cc_ioread(drvdata, CC_NVM_IS_IDLE_REG_OFFSET);\n\t\tif (val & BIT(CC_NVM_IS_IDLE_VALUE_BIT_SHIFT)) {\n\t\t\t \n\t\t\treturn true;\n\t\t}\n\t\t \n\t\tschedule();\n\t}\n\t \n\treturn false;\n}\n\nstatic int __maybe_unused cctrng_resume(struct device *dev)\n{\n\tstruct cctrng_drvdata *drvdata = dev_get_drvdata(dev);\n\tint rc;\n\n\tdev_dbg(dev, \"unset HOST_POWER_DOWN_EN\\n\");\n\t \n\trc = clk_prepare_enable(drvdata->clk);\n\tif (rc) {\n\t\tdev_err(dev, \"failed getting clock back on. We're toast.\\n\");\n\t\treturn rc;\n\t}\n\n\t \n\tif (!cctrng_wait_for_reset_completion(drvdata)) {\n\t\tdev_err(dev, \"Cryptocell reset not completed\");\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tcc_iowrite(drvdata, CC_HOST_RGF_IMR_REG_OFFSET,\n\t\t   cc_ioread(drvdata, CC_HOST_RGF_IMR_REG_OFFSET) &\n\t\t   ~CC_HOST_RNG_IRQ_MASK);\n\n\tcc_iowrite(drvdata, CC_HOST_POWER_DOWN_EN_REG_OFFSET,\n\t\t   POWER_DOWN_DISABLE);\n\n\treturn 0;\n}\n\nstatic UNIVERSAL_DEV_PM_OPS(cctrng_pm, cctrng_suspend, cctrng_resume, NULL);\n\nstatic const struct of_device_id arm_cctrng_dt_match[] = {\n\t{ .compatible = \"arm,cryptocell-713-trng\", },\n\t{ .compatible = \"arm,cryptocell-703-trng\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, arm_cctrng_dt_match);\n\nstatic struct platform_driver cctrng_driver = {\n\t.driver = {\n\t\t.name = \"cctrng\",\n\t\t.of_match_table = arm_cctrng_dt_match,\n\t\t.pm = &cctrng_pm,\n\t},\n\t.probe = cctrng_probe,\n\t.remove = cctrng_remove,\n};\n\nmodule_platform_driver(cctrng_driver);\n\n \nMODULE_DESCRIPTION(\"ARM CryptoCell TRNG Driver\");\nMODULE_AUTHOR(\"ARM\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}