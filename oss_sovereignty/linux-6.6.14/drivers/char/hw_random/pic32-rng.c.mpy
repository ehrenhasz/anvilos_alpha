{
  "module_name": "pic32-rng.c",
  "hash_id": "4d0df368d3e351f372ba26d1241a9f93c7b3e4d3b0e17c4e458b7ba135a4cca1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/hw_random/pic32-rng.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clkdev.h>\n#include <linux/err.h>\n#include <linux/hw_random.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#define RNGCON\t\t0x04\n#define TRNGEN\t\tBIT(8)\n#define TRNGMOD\t\tBIT(11)\n#define RNGSEED1\t0x18\n#define RNGSEED2\t0x1C\n#define RNGRCNT\t\t0x20\n#define RCNT_MASK\t0x7F\n\nstruct pic32_rng {\n\tvoid __iomem\t*base;\n\tstruct hwrng\trng;\n};\n\n \n#define RNG_TIMEOUT 500\n\nstatic int pic32_rng_init(struct hwrng *rng)\n{\n\tstruct pic32_rng *priv = container_of(rng, struct pic32_rng, rng);\n\n\t \n\twritel(TRNGEN | TRNGMOD, priv->base + RNGCON);\n\treturn 0;\n}\n\nstatic int pic32_rng_read(struct hwrng *rng, void *buf, size_t max,\n\t\t\t  bool wait)\n{\n\tstruct pic32_rng *priv = container_of(rng, struct pic32_rng, rng);\n\tu64 *data = buf;\n\tu32 t;\n\tunsigned int timeout = RNG_TIMEOUT;\n\n\tdo {\n\t\tt = readl(priv->base + RNGRCNT) & RCNT_MASK;\n\t\tif (t == 64) {\n\t\t\t \n\t\t\t*data = ((u64)readl(priv->base + RNGSEED2) << 32) +\n\t\t\t\treadl(priv->base + RNGSEED1);\n\t\t\treturn 8;\n\t\t}\n\t} while (wait && --timeout);\n\n\treturn -EIO;\n}\n\nstatic void pic32_rng_cleanup(struct hwrng *rng)\n{\n\tstruct pic32_rng *priv = container_of(rng, struct pic32_rng, rng);\n\n\twritel(0, priv->base + RNGCON);\n}\n\nstatic int pic32_rng_probe(struct platform_device *pdev)\n{\n\tstruct pic32_rng *priv;\n\tstruct clk *clk;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->base))\n\t\treturn PTR_ERR(priv->base);\n\n\tclk = devm_clk_get_enabled(&pdev->dev, NULL);\n\tif (IS_ERR(clk))\n\t\treturn PTR_ERR(clk);\n\n\tpriv->rng.name = pdev->name;\n\tpriv->rng.init = pic32_rng_init;\n\tpriv->rng.read = pic32_rng_read;\n\tpriv->rng.cleanup = pic32_rng_cleanup;\n\n\treturn devm_hwrng_register(&pdev->dev, &priv->rng);\n}\n\nstatic const struct of_device_id pic32_rng_of_match[] __maybe_unused = {\n\t{ .compatible\t= \"microchip,pic32mzda-rng\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, pic32_rng_of_match);\n\nstatic struct platform_driver pic32_rng_driver = {\n\t.probe\t\t= pic32_rng_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"pic32-rng\",\n\t\t.of_match_table = pic32_rng_of_match,\n\t},\n};\n\nmodule_platform_driver(pic32_rng_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Joshua Henderson <joshua.henderson@microchip.com>\");\nMODULE_DESCRIPTION(\"Microchip PIC32 RNG Driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}