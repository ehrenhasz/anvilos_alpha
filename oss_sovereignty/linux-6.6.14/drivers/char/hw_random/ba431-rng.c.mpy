{
  "module_name": "ba431-rng.c",
  "hash_id": "67dfc873693c23dfdae355f13f3538ec236f7a64bf201dd0a95de759299323de",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/hw_random/ba431-rng.c",
  "human_readable_source": "\n\n\n#include <linux/delay.h>\n#include <linux/hw_random.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/workqueue.h>\n\n#define BA431_RESET_DELAY\t\t\t1  \n#define BA431_RESET_READ_STATUS_TIMEOUT\t\t1000  \n#define BA431_RESET_READ_STATUS_INTERVAL\t10  \n#define BA431_READ_RETRY_INTERVAL\t\t1  \n\n#define BA431_REG_CTRL\t\t\t\t0x00\n#define BA431_REG_FIFO_LEVEL\t\t\t0x04\n#define BA431_REG_STATUS\t\t\t0x30\n#define BA431_REG_FIFODATA\t\t\t0x80\n\n#define BA431_CTRL_ENABLE\t\t\tBIT(0)\n#define BA431_CTRL_SOFTRESET\t\t\tBIT(8)\n\n#define BA431_STATUS_STATE_MASK\t\t\t(BIT(1) | BIT(2) | BIT(3))\n#define BA431_STATUS_STATE_OFFSET\t\t1\n\nenum ba431_state {\n\tBA431_STATE_RESET,\n\tBA431_STATE_STARTUP,\n\tBA431_STATE_FIFOFULLON,\n\tBA431_STATE_FIFOFULLOFF,\n\tBA431_STATE_RUNNING,\n\tBA431_STATE_ERROR\n};\n\nstruct ba431_trng {\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tstruct hwrng rng;\n\tatomic_t reset_pending;\n\tstruct work_struct reset_work;\n};\n\nstatic inline u32 ba431_trng_read_reg(struct ba431_trng *ba431, u32 reg)\n{\n\treturn ioread32(ba431->base + reg);\n}\n\nstatic inline void ba431_trng_write_reg(struct ba431_trng *ba431, u32 reg,\n\t\t\t\t\tu32 val)\n{\n\tiowrite32(val, ba431->base + reg);\n}\n\nstatic inline enum ba431_state ba431_trng_get_state(struct ba431_trng *ba431)\n{\n\tu32 status = ba431_trng_read_reg(ba431, BA431_REG_STATUS);\n\n\treturn (status & BA431_STATUS_STATE_MASK) >> BA431_STATUS_STATE_OFFSET;\n}\n\nstatic int ba431_trng_is_in_error(struct ba431_trng *ba431)\n{\n\tenum ba431_state state = ba431_trng_get_state(ba431);\n\n\tif ((state < BA431_STATE_STARTUP) ||\n\t    (state >= BA431_STATE_ERROR))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int ba431_trng_reset(struct ba431_trng *ba431)\n{\n\tint ret;\n\n\t \n\tba431_trng_write_reg(ba431, BA431_REG_CTRL, BA431_CTRL_SOFTRESET);\n\tudelay(BA431_RESET_DELAY);\n\tba431_trng_write_reg(ba431, BA431_REG_CTRL, BA431_CTRL_ENABLE);\n\n\t \n\tif (readx_poll_timeout(ba431_trng_is_in_error, ba431, ret, !ret,\n\t\t\t       BA431_RESET_READ_STATUS_INTERVAL,\n\t\t\t       BA431_RESET_READ_STATUS_TIMEOUT)) {\n\t\tdev_err(ba431->dev, \"reset failed (state: %d)\\n\",\n\t\t\tba431_trng_get_state(ba431));\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tdev_info(ba431->dev, \"reset done\\n\");\n\n\treturn 0;\n}\n\nstatic void ba431_trng_reset_work(struct work_struct *work)\n{\n\tstruct ba431_trng *ba431 = container_of(work, struct ba431_trng,\n\t\t\t\t\t\treset_work);\n\tba431_trng_reset(ba431);\n\tatomic_set(&ba431->reset_pending, 0);\n}\n\nstatic void ba431_trng_schedule_reset(struct ba431_trng *ba431)\n{\n\tif (atomic_cmpxchg(&ba431->reset_pending, 0, 1))\n\t\treturn;\n\n\tschedule_work(&ba431->reset_work);\n}\n\nstatic int ba431_trng_read(struct hwrng *rng, void *buf, size_t max, bool wait)\n{\n\tstruct ba431_trng *ba431 = container_of(rng, struct ba431_trng, rng);\n\tu32 *data = buf;\n\tunsigned int level, i;\n\tint n = 0;\n\n\twhile (max > 0) {\n\t\tlevel = ba431_trng_read_reg(ba431, BA431_REG_FIFO_LEVEL);\n\t\tif (!level) {\n\t\t\tif (ba431_trng_is_in_error(ba431)) {\n\t\t\t\tba431_trng_schedule_reset(ba431);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!wait)\n\t\t\t\tbreak;\n\n\t\t\tudelay(BA431_READ_RETRY_INTERVAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\ti = level;\n\t\tdo {\n\t\t\tdata[n++] = ba431_trng_read_reg(ba431,\n\t\t\t\t\t\t\tBA431_REG_FIFODATA);\n\t\t\tmax -= sizeof(*data);\n\t\t} while (--i && (max > 0));\n\n\t\tif (ba431_trng_is_in_error(ba431)) {\n\t\t\tn -= (level - i);\n\t\t\tba431_trng_schedule_reset(ba431);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tn *= sizeof(data);\n\treturn (n || !wait) ? n : -EIO;\n}\n\nstatic void ba431_trng_cleanup(struct hwrng *rng)\n{\n\tstruct ba431_trng *ba431 = container_of(rng, struct ba431_trng, rng);\n\n\tba431_trng_write_reg(ba431, BA431_REG_CTRL, 0);\n\tcancel_work_sync(&ba431->reset_work);\n}\n\nstatic int ba431_trng_init(struct hwrng *rng)\n{\n\tstruct ba431_trng *ba431 = container_of(rng, struct ba431_trng, rng);\n\n\treturn ba431_trng_reset(ba431);\n}\n\nstatic int ba431_trng_probe(struct platform_device *pdev)\n{\n\tstruct ba431_trng *ba431;\n\tint ret;\n\n\tba431 = devm_kzalloc(&pdev->dev, sizeof(*ba431), GFP_KERNEL);\n\tif (!ba431)\n\t\treturn -ENOMEM;\n\n\tba431->dev = &pdev->dev;\n\n\tba431->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(ba431->base))\n\t\treturn PTR_ERR(ba431->base);\n\n\tatomic_set(&ba431->reset_pending, 0);\n\tINIT_WORK(&ba431->reset_work, ba431_trng_reset_work);\n\tba431->rng.name = pdev->name;\n\tba431->rng.init = ba431_trng_init;\n\tba431->rng.cleanup = ba431_trng_cleanup;\n\tba431->rng.read = ba431_trng_read;\n\n\tret = devm_hwrng_register(&pdev->dev, &ba431->rng);\n\tif (ret)\n\t\treturn dev_err_probe(&pdev->dev, ret, \"BA431 registration failed\\n\");\n\n\tdev_info(&pdev->dev, \"BA431 TRNG registered\\n\");\n\n\treturn 0;\n}\n\nstatic const struct of_device_id ba431_trng_dt_ids[] = {\n\t{ .compatible = \"silex-insight,ba431-rng\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, ba431_trng_dt_ids);\n\nstatic struct platform_driver ba431_trng_driver = {\n\t.driver = {\n\t\t.name = \"ba431-rng\",\n\t\t.of_match_table = ba431_trng_dt_ids,\n\t},\n\t.probe = ba431_trng_probe,\n};\n\nmodule_platform_driver(ba431_trng_driver);\n\nMODULE_AUTHOR(\"Olivier Sobrie <olivier@sobrie.be>\");\nMODULE_DESCRIPTION(\"TRNG driver for Silex Insight BA431\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}