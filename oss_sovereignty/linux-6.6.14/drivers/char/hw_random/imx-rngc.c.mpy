{
  "module_name": "imx-rngc.c",
  "hash_id": "ccade8ec711268d1520ce76ecd7662259131be4ad4bc116a577741b279347cd6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/hw_random/imx-rngc.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/platform_device.h>\n#include <linux/interrupt.h>\n#include <linux/hw_random.h>\n#include <linux/completion.h>\n#include <linux/io.h>\n#include <linux/bitfield.h>\n\n#define RNGC_VER_ID\t\t\t0x0000\n#define RNGC_COMMAND\t\t\t0x0004\n#define RNGC_CONTROL\t\t\t0x0008\n#define RNGC_STATUS\t\t\t0x000C\n#define RNGC_ERROR\t\t\t0x0010\n#define RNGC_FIFO\t\t\t0x0014\n\n \n#define RNG_TYPE\t\t\tGENMASK(31, 28)\n#define RNGC_VER_MAJ_SHIFT\t\t8\n\n \n#define RNGC_TYPE_RNGB\t\t\t0x1\n#define RNGC_TYPE_RNGC\t\t\t0x2\n\n\n#define RNGC_CMD_CLR_ERR\t\tBIT(5)\n#define RNGC_CMD_CLR_INT\t\tBIT(4)\n#define RNGC_CMD_SEED\t\t\tBIT(1)\n#define RNGC_CMD_SELF_TEST\t\tBIT(0)\n\n#define RNGC_CTRL_MASK_ERROR\t\tBIT(6)\n#define RNGC_CTRL_MASK_DONE\t\tBIT(5)\n#define RNGC_CTRL_AUTO_SEED\t\tBIT(4)\n\n#define RNGC_STATUS_ERROR\t\tBIT(16)\n#define RNGC_STATUS_FIFO_LEVEL_MASK\tGENMASK(11, 8)\n#define RNGC_STATUS_SEED_DONE\t\tBIT(5)\n#define RNGC_STATUS_ST_DONE\t\tBIT(4)\n\n#define RNGC_ERROR_STATUS_STAT_ERR\t0x00000008\n\n#define RNGC_TIMEOUT  3000  \n\n\nstatic bool self_test = true;\nmodule_param(self_test, bool, 0);\n\nstruct imx_rngc {\n\tstruct device\t\t*dev;\n\tstruct clk\t\t*clk;\n\tvoid __iomem\t\t*base;\n\tstruct hwrng\t\trng;\n\tstruct completion\trng_op_done;\n\t \n\tu32\t\t\terr_reg;\n};\n\n\nstatic inline void imx_rngc_irq_mask_clear(struct imx_rngc *rngc)\n{\n\tu32 ctrl, cmd;\n\n\t \n\tctrl = readl(rngc->base + RNGC_CONTROL);\n\tctrl |= RNGC_CTRL_MASK_DONE | RNGC_CTRL_MASK_ERROR;\n\twritel(ctrl, rngc->base + RNGC_CONTROL);\n\n\t \n\tcmd = readl(rngc->base + RNGC_COMMAND);\n\tcmd |= RNGC_CMD_CLR_INT | RNGC_CMD_CLR_ERR;\n\twritel(cmd, rngc->base + RNGC_COMMAND);\n}\n\nstatic inline void imx_rngc_irq_unmask(struct imx_rngc *rngc)\n{\n\tu32 ctrl;\n\n\tctrl = readl(rngc->base + RNGC_CONTROL);\n\tctrl &= ~(RNGC_CTRL_MASK_DONE | RNGC_CTRL_MASK_ERROR);\n\twritel(ctrl, rngc->base + RNGC_CONTROL);\n}\n\nstatic int imx_rngc_self_test(struct imx_rngc *rngc)\n{\n\tu32 cmd;\n\tint ret;\n\n\timx_rngc_irq_unmask(rngc);\n\n\t \n\tcmd = readl(rngc->base + RNGC_COMMAND);\n\twritel(cmd | RNGC_CMD_SELF_TEST, rngc->base + RNGC_COMMAND);\n\n\tret = wait_for_completion_timeout(&rngc->rng_op_done, msecs_to_jiffies(RNGC_TIMEOUT));\n\timx_rngc_irq_mask_clear(rngc);\n\tif (!ret)\n\t\treturn -ETIMEDOUT;\n\n\treturn rngc->err_reg ? -EIO : 0;\n}\n\nstatic int imx_rngc_read(struct hwrng *rng, void *data, size_t max, bool wait)\n{\n\tstruct imx_rngc *rngc = container_of(rng, struct imx_rngc, rng);\n\tunsigned int status;\n\tint retval = 0;\n\n\twhile (max >= sizeof(u32)) {\n\t\tstatus = readl(rngc->base + RNGC_STATUS);\n\n\t\t \n\t\tif (status & RNGC_STATUS_ERROR)\n\t\t\tbreak;\n\n\t\tif (status & RNGC_STATUS_FIFO_LEVEL_MASK) {\n\t\t\t \n\t\t\t*(u32 *)data = readl(rngc->base + RNGC_FIFO);\n\n\t\t\tretval += sizeof(u32);\n\t\t\tdata += sizeof(u32);\n\t\t\tmax -= sizeof(u32);\n\t\t}\n\t}\n\n\treturn retval ? retval : -EIO;\n}\n\nstatic irqreturn_t imx_rngc_irq(int irq, void *priv)\n{\n\tstruct imx_rngc *rngc = (struct imx_rngc *)priv;\n\tu32 status;\n\n\t \n\tstatus = readl(rngc->base + RNGC_STATUS);\n\trngc->err_reg = readl(rngc->base + RNGC_ERROR);\n\n\timx_rngc_irq_mask_clear(rngc);\n\n\tif (status & (RNGC_STATUS_SEED_DONE | RNGC_STATUS_ST_DONE))\n\t\tcomplete(&rngc->rng_op_done);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int imx_rngc_init(struct hwrng *rng)\n{\n\tstruct imx_rngc *rngc = container_of(rng, struct imx_rngc, rng);\n\tu32 cmd, ctrl;\n\tint ret;\n\n\t \n\tcmd = readl(rngc->base + RNGC_COMMAND);\n\twritel(cmd | RNGC_CMD_CLR_ERR, rngc->base + RNGC_COMMAND);\n\n\timx_rngc_irq_unmask(rngc);\n\n\t \n\tdo {\n\t\t \n\t\tcmd = readl(rngc->base + RNGC_COMMAND);\n\t\twritel(cmd | RNGC_CMD_SEED, rngc->base + RNGC_COMMAND);\n\n\t\tret = wait_for_completion_timeout(&rngc->rng_op_done, msecs_to_jiffies(RNGC_TIMEOUT));\n\t\tif (!ret) {\n\t\t\tret = -ETIMEDOUT;\n\t\t\tgoto err;\n\t\t}\n\n\t} while (rngc->err_reg == RNGC_ERROR_STATUS_STAT_ERR);\n\n\tif (rngc->err_reg) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t \n\tctrl = readl(rngc->base + RNGC_CONTROL);\n\tctrl |= RNGC_CTRL_AUTO_SEED;\n\twritel(ctrl, rngc->base + RNGC_CONTROL);\n\n\t \n\treturn 0;\n\nerr:\n\timx_rngc_irq_mask_clear(rngc);\n\treturn ret;\n}\n\nstatic void imx_rngc_cleanup(struct hwrng *rng)\n{\n\tstruct imx_rngc *rngc = container_of(rng, struct imx_rngc, rng);\n\n\timx_rngc_irq_mask_clear(rngc);\n}\n\nstatic int __init imx_rngc_probe(struct platform_device *pdev)\n{\n\tstruct imx_rngc *rngc;\n\tint ret;\n\tint irq;\n\tu32 ver_id;\n\tu8  rng_type;\n\n\trngc = devm_kzalloc(&pdev->dev, sizeof(*rngc), GFP_KERNEL);\n\tif (!rngc)\n\t\treturn -ENOMEM;\n\n\trngc->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(rngc->base))\n\t\treturn PTR_ERR(rngc->base);\n\n\trngc->clk = devm_clk_get_enabled(&pdev->dev, NULL);\n\tif (IS_ERR(rngc->clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(rngc->clk), \"Cannot get rng_clk\\n\");\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tver_id = readl(rngc->base + RNGC_VER_ID);\n\trng_type = FIELD_GET(RNG_TYPE, ver_id);\n\t \n\tif (rng_type != RNGC_TYPE_RNGC && rng_type != RNGC_TYPE_RNGB)\n\t\treturn -ENODEV;\n\n\tinit_completion(&rngc->rng_op_done);\n\n\trngc->rng.name = pdev->name;\n\trngc->rng.init = imx_rngc_init;\n\trngc->rng.read = imx_rngc_read;\n\trngc->rng.cleanup = imx_rngc_cleanup;\n\trngc->rng.quality = 19;\n\n\trngc->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, rngc);\n\n\timx_rngc_irq_mask_clear(rngc);\n\n\tret = devm_request_irq(&pdev->dev,\n\t\t\tirq, imx_rngc_irq, 0, pdev->name, (void *)rngc);\n\tif (ret)\n\t\treturn dev_err_probe(&pdev->dev, ret, \"Can't get interrupt working.\\n\");\n\n\tif (self_test) {\n\t\tret = imx_rngc_self_test(rngc);\n\t\tif (ret)\n\t\t\treturn dev_err_probe(&pdev->dev, ret, \"self test failed\\n\");\n\t}\n\n\tret = devm_hwrng_register(&pdev->dev, &rngc->rng);\n\tif (ret)\n\t\treturn dev_err_probe(&pdev->dev, ret, \"hwrng registration failed\\n\");\n\n\tdev_info(&pdev->dev,\n\t\t\"Freescale RNG%c registered (HW revision %d.%02d)\\n\",\n\t\trng_type == RNGC_TYPE_RNGB ? 'B' : 'C',\n\t\t(ver_id >> RNGC_VER_MAJ_SHIFT) & 0xff, ver_id & 0xff);\n\treturn 0;\n}\n\nstatic int imx_rngc_suspend(struct device *dev)\n{\n\tstruct imx_rngc *rngc = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(rngc->clk);\n\n\treturn 0;\n}\n\nstatic int imx_rngc_resume(struct device *dev)\n{\n\tstruct imx_rngc *rngc = dev_get_drvdata(dev);\n\n\tclk_prepare_enable(rngc->clk);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(imx_rngc_pm_ops, imx_rngc_suspend, imx_rngc_resume);\n\nstatic const struct of_device_id imx_rngc_dt_ids[] = {\n\t{ .compatible = \"fsl,imx25-rngb\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, imx_rngc_dt_ids);\n\nstatic struct platform_driver imx_rngc_driver = {\n\t.driver = {\n\t\t.name = KBUILD_MODNAME,\n\t\t.pm = pm_sleep_ptr(&imx_rngc_pm_ops),\n\t\t.of_match_table = imx_rngc_dt_ids,\n\t},\n};\n\nmodule_platform_driver_probe(imx_rngc_driver, imx_rngc_probe);\n\nMODULE_AUTHOR(\"Freescale Semiconductor, Inc.\");\nMODULE_DESCRIPTION(\"H/W RNGC driver for i.MX\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}