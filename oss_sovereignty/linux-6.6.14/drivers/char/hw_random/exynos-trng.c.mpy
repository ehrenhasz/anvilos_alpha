{
  "module_name": "exynos-trng.c",
  "hash_id": "dcde908057fdee87a32381bd08cb2d340d69934bcad709bd7aa02f33cd8a8ee4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/hw_random/exynos-trng.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/crypto.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/hw_random.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n\n#define EXYNOS_TRNG_CLKDIV         (0x0)\n\n#define EXYNOS_TRNG_CTRL           (0x20)\n#define EXYNOS_TRNG_CTRL_RNGEN     BIT(31)\n\n#define EXYNOS_TRNG_POST_CTRL      (0x30)\n#define EXYNOS_TRNG_ONLINE_CTRL    (0x40)\n#define EXYNOS_TRNG_ONLINE_STAT    (0x44)\n#define EXYNOS_TRNG_ONLINE_MAXCHI2 (0x48)\n#define EXYNOS_TRNG_FIFO_CTRL      (0x50)\n#define EXYNOS_TRNG_FIFO_0         (0x80)\n#define EXYNOS_TRNG_FIFO_1         (0x84)\n#define EXYNOS_TRNG_FIFO_2         (0x88)\n#define EXYNOS_TRNG_FIFO_3         (0x8c)\n#define EXYNOS_TRNG_FIFO_4         (0x90)\n#define EXYNOS_TRNG_FIFO_5         (0x94)\n#define EXYNOS_TRNG_FIFO_6         (0x98)\n#define EXYNOS_TRNG_FIFO_7         (0x9c)\n#define EXYNOS_TRNG_FIFO_LEN       (8)\n#define EXYNOS_TRNG_CLOCK_RATE     (500000)\n\n\nstruct exynos_trng_dev {\n\tstruct device    *dev;\n\tvoid __iomem     *mem;\n\tstruct clk       *clk;\n\tstruct hwrng rng;\n};\n\nstatic int exynos_trng_do_read(struct hwrng *rng, void *data, size_t max,\n\t\t\t       bool wait)\n{\n\tstruct exynos_trng_dev *trng;\n\tint val;\n\n\tmax = min_t(size_t, max, (EXYNOS_TRNG_FIFO_LEN * 4));\n\n\ttrng = (struct exynos_trng_dev *)rng->priv;\n\n\twritel_relaxed(max * 8, trng->mem + EXYNOS_TRNG_FIFO_CTRL);\n\tval = readl_poll_timeout(trng->mem + EXYNOS_TRNG_FIFO_CTRL, val,\n\t\t\t\t val == 0, 200, 1000000);\n\tif (val < 0)\n\t\treturn val;\n\n\tmemcpy_fromio(data, trng->mem + EXYNOS_TRNG_FIFO_0, max);\n\n\treturn max;\n}\n\nstatic int exynos_trng_init(struct hwrng *rng)\n{\n\tstruct exynos_trng_dev *trng = (struct exynos_trng_dev *)rng->priv;\n\tunsigned long sss_rate;\n\tu32 val;\n\n\tsss_rate = clk_get_rate(trng->clk);\n\n\t \n\tval = sss_rate / (EXYNOS_TRNG_CLOCK_RATE * 2);\n\tif (val > 0x7fff) {\n\t\tdev_err(trng->dev, \"clock divider too large: %d\", val);\n\t\treturn -ERANGE;\n\t}\n\tval = val << 1;\n\twritel_relaxed(val, trng->mem + EXYNOS_TRNG_CLKDIV);\n\n\t \n\tval = EXYNOS_TRNG_CTRL_RNGEN;\n\twritel_relaxed(val, trng->mem + EXYNOS_TRNG_CTRL);\n\n\t \n\twritel_relaxed(0, trng->mem + EXYNOS_TRNG_POST_CTRL);\n\n\treturn 0;\n}\n\nstatic int exynos_trng_probe(struct platform_device *pdev)\n{\n\tstruct exynos_trng_dev *trng;\n\tint ret = -ENOMEM;\n\n\ttrng = devm_kzalloc(&pdev->dev, sizeof(*trng), GFP_KERNEL);\n\tif (!trng)\n\t\treturn ret;\n\n\ttrng->rng.name = devm_kstrdup(&pdev->dev, dev_name(&pdev->dev),\n\t\t\t\t      GFP_KERNEL);\n\tif (!trng->rng.name)\n\t\treturn ret;\n\n\ttrng->rng.init = exynos_trng_init;\n\ttrng->rng.read = exynos_trng_do_read;\n\ttrng->rng.priv = (unsigned long) trng;\n\n\tplatform_set_drvdata(pdev, trng);\n\ttrng->dev = &pdev->dev;\n\n\ttrng->mem = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(trng->mem))\n\t\treturn PTR_ERR(trng->mem);\n\n\tpm_runtime_enable(&pdev->dev);\n\tret = pm_runtime_resume_and_get(&pdev->dev);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Could not get runtime PM.\\n\");\n\t\tgoto err_pm_get;\n\t}\n\n\ttrng->clk = devm_clk_get(&pdev->dev, \"secss\");\n\tif (IS_ERR(trng->clk)) {\n\t\tret = PTR_ERR(trng->clk);\n\t\tdev_err(&pdev->dev, \"Could not get clock.\\n\");\n\t\tgoto err_clock;\n\t}\n\n\tret = clk_prepare_enable(trng->clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Could not enable the clk.\\n\");\n\t\tgoto err_clock;\n\t}\n\n\tret = devm_hwrng_register(&pdev->dev, &trng->rng);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Could not register hwrng device.\\n\");\n\t\tgoto err_register;\n\t}\n\n\tdev_info(&pdev->dev, \"Exynos True Random Number Generator.\\n\");\n\n\treturn 0;\n\nerr_register:\n\tclk_disable_unprepare(trng->clk);\n\nerr_clock:\n\tpm_runtime_put_noidle(&pdev->dev);\n\nerr_pm_get:\n\tpm_runtime_disable(&pdev->dev);\n\n\treturn ret;\n}\n\nstatic int exynos_trng_remove(struct platform_device *pdev)\n{\n\tstruct exynos_trng_dev *trng =  platform_get_drvdata(pdev);\n\n\tclk_disable_unprepare(trng->clk);\n\n\tpm_runtime_put_sync(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\n\treturn 0;\n}\n\nstatic int exynos_trng_suspend(struct device *dev)\n{\n\tpm_runtime_put_sync(dev);\n\n\treturn 0;\n}\n\nstatic int exynos_trng_resume(struct device *dev)\n{\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Could not get runtime PM.\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(exynos_trng_pm_ops, exynos_trng_suspend,\n\t\t\t exynos_trng_resume);\n\nstatic const struct of_device_id exynos_trng_dt_match[] = {\n\t{\n\t\t.compatible = \"samsung,exynos5250-trng\",\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, exynos_trng_dt_match);\n\nstatic struct platform_driver exynos_trng_driver = {\n\t.driver = {\n\t\t.name = \"exynos-trng\",\n\t\t.pm = pm_sleep_ptr(&exynos_trng_pm_ops),\n\t\t.of_match_table = exynos_trng_dt_match,\n\t},\n\t.probe = exynos_trng_probe,\n\t.remove = exynos_trng_remove,\n};\n\nmodule_platform_driver(exynos_trng_driver);\nMODULE_AUTHOR(\"\u0141ukasz Stelmach\");\nMODULE_DESCRIPTION(\"H/W TRNG driver for Exynos chips\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}