{
  "module_name": "npcm-rng.c",
  "hash_id": "384efc16841e79baf9adc6fef8b31fa1054f5555cb9bdcbca14b4c06d0fa2011",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/hw_random/npcm-rng.c",
  "human_readable_source": "\n\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/init.h>\n#include <linux/random.h>\n#include <linux/err.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/hw_random.h>\n#include <linux/delay.h>\n#include <linux/pm_runtime.h>\n\n#define NPCM_RNGCS_REG\t\t0x00\t \n#define NPCM_RNGD_REG\t\t0x04\t \n#define NPCM_RNGMODE_REG\t0x08\t \n\n#define NPCM_RNG_CLK_SET_62_5MHZ\tBIT(2)  \n#define NPCM_RNG_CLK_SET_25MHZ\tGENMASK(4, 3)  \n#define NPCM_RNG_DATA_VALID\tBIT(1)\n#define NPCM_RNG_ENABLE\t\tBIT(0)\n#define NPCM_RNG_M1ROSEL\tBIT(1)\n\n#define NPCM_RNG_TIMEOUT_USEC\t20000\n#define NPCM_RNG_POLL_USEC\t1000\n\n#define to_npcm_rng(p)\tcontainer_of(p, struct npcm_rng, rng)\n\nstruct npcm_rng {\n\tvoid __iomem *base;\n\tstruct hwrng rng;\n\tu32 clkp;\n};\n\nstatic int npcm_rng_init(struct hwrng *rng)\n{\n\tstruct npcm_rng *priv = to_npcm_rng(rng);\n\n\twritel(priv->clkp | NPCM_RNG_ENABLE, priv->base + NPCM_RNGCS_REG);\n\n\treturn 0;\n}\n\nstatic void npcm_rng_cleanup(struct hwrng *rng)\n{\n\tstruct npcm_rng *priv = to_npcm_rng(rng);\n\n\twritel(priv->clkp, priv->base + NPCM_RNGCS_REG);\n}\n\nstatic int npcm_rng_read(struct hwrng *rng, void *buf, size_t max, bool wait)\n{\n\tstruct npcm_rng *priv = to_npcm_rng(rng);\n\tint retval = 0;\n\tint ready;\n\n\tpm_runtime_get_sync((struct device *)priv->rng.priv);\n\n\twhile (max) {\n\t\tif (wait) {\n\t\t\tif (readb_poll_timeout(priv->base + NPCM_RNGCS_REG,\n\t\t\t\t\t       ready,\n\t\t\t\t\t       ready & NPCM_RNG_DATA_VALID,\n\t\t\t\t\t       NPCM_RNG_POLL_USEC,\n\t\t\t\t\t       NPCM_RNG_TIMEOUT_USEC))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif ((readb(priv->base + NPCM_RNGCS_REG) &\n\t\t\t    NPCM_RNG_DATA_VALID) == 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t*(u8 *)buf = readb(priv->base + NPCM_RNGD_REG);\n\t\tretval++;\n\t\tbuf++;\n\t\tmax--;\n\t}\n\n\tpm_runtime_mark_last_busy((struct device *)priv->rng.priv);\n\tpm_runtime_put_sync_autosuspend((struct device *)priv->rng.priv);\n\n\treturn retval || !wait ? retval : -EIO;\n}\n\nstatic int npcm_rng_probe(struct platform_device *pdev)\n{\n\tstruct npcm_rng *priv;\n\tint ret;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->base))\n\t\treturn PTR_ERR(priv->base);\n\n\tdev_set_drvdata(&pdev->dev, priv);\n\tpm_runtime_set_autosuspend_delay(&pdev->dev, 100);\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\n#ifndef CONFIG_PM\n\tpriv->rng.init = npcm_rng_init;\n\tpriv->rng.cleanup = npcm_rng_cleanup;\n#endif\n\tpriv->rng.name = pdev->name;\n\tpriv->rng.read = npcm_rng_read;\n\tpriv->rng.priv = (unsigned long)&pdev->dev;\n\tpriv->clkp = (u32)(uintptr_t)of_device_get_match_data(&pdev->dev);\n\n\twritel(NPCM_RNG_M1ROSEL, priv->base + NPCM_RNGMODE_REG);\n\n\tret = devm_hwrng_register(&pdev->dev, &priv->rng);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to register rng device: %d\\n\",\n\t\t\tret);\n\t\tpm_runtime_disable(&pdev->dev);\n\t\tpm_runtime_set_suspended(&pdev->dev);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int npcm_rng_remove(struct platform_device *pdev)\n{\n\tstruct npcm_rng *priv = platform_get_drvdata(pdev);\n\n\tdevm_hwrng_unregister(&pdev->dev, &priv->rng);\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_set_suspended(&pdev->dev);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic int npcm_rng_runtime_suspend(struct device *dev)\n{\n\tstruct npcm_rng *priv = dev_get_drvdata(dev);\n\n\tnpcm_rng_cleanup(&priv->rng);\n\n\treturn 0;\n}\n\nstatic int npcm_rng_runtime_resume(struct device *dev)\n{\n\tstruct npcm_rng *priv = dev_get_drvdata(dev);\n\n\treturn npcm_rng_init(&priv->rng);\n}\n#endif\n\nstatic const struct dev_pm_ops npcm_rng_pm_ops = {\n\tSET_RUNTIME_PM_OPS(npcm_rng_runtime_suspend,\n\t\t\t   npcm_rng_runtime_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n};\n\nstatic const struct of_device_id rng_dt_id[] __maybe_unused = {\n\t{ .compatible = \"nuvoton,npcm750-rng\",\n\t\t.data = (void *)NPCM_RNG_CLK_SET_25MHZ },\n\t{ .compatible = \"nuvoton,npcm845-rng\",\n\t\t.data = (void *)NPCM_RNG_CLK_SET_62_5MHZ },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, rng_dt_id);\n\nstatic struct platform_driver npcm_rng_driver = {\n\t.driver = {\n\t\t.name\t\t= \"npcm-rng\",\n\t\t.pm\t\t= &npcm_rng_pm_ops,\n\t\t.of_match_table = of_match_ptr(rng_dt_id),\n\t},\n\t.probe\t\t= npcm_rng_probe,\n\t.remove\t\t= npcm_rng_remove,\n};\n\nmodule_platform_driver(npcm_rng_driver);\n\nMODULE_DESCRIPTION(\"Nuvoton NPCM Random Number Generator Driver\");\nMODULE_AUTHOR(\"Tomer Maimon <tomer.maimon@nuvoton.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}