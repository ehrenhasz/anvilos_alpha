{
  "module_name": "s390-trng.c",
  "hash_id": "400d30fda288990add0b0457b6ea52706634bffd747d20a25b93cc353b8c5c30",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/hw_random/s390-trng.c",
  "human_readable_source": "\n \n\n#define KMSG_COMPONENT \"trng\"\n#define pr_fmt(fmt) KMSG_COMPONENT \": \" fmt\n\n#include <linux/hw_random.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/cpufeature.h>\n#include <linux/miscdevice.h>\n#include <linux/debugfs.h>\n#include <linux/atomic.h>\n#include <linux/random.h>\n#include <linux/sched/signal.h>\n#include <asm/debug.h>\n#include <asm/cpacf.h>\n#include <asm/archrandom.h>\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"IBM Corporation\");\nMODULE_DESCRIPTION(\"s390 CPACF TRNG device driver\");\n\n\n \n\nstatic debug_info_t *debug_info;\n\n#define DEBUG_DBG(...)\tdebug_sprintf_event(debug_info, 6, ##__VA_ARGS__)\n#define DEBUG_INFO(...) debug_sprintf_event(debug_info, 5, ##__VA_ARGS__)\n#define DEBUG_WARN(...) debug_sprintf_event(debug_info, 4, ##__VA_ARGS__)\n#define DEBUG_ERR(...)\tdebug_sprintf_event(debug_info, 3, ##__VA_ARGS__)\n\n\n \n\nstatic atomic64_t trng_dev_counter = ATOMIC64_INIT(0);\nstatic atomic64_t trng_hwrng_counter = ATOMIC64_INIT(0);\n\n\n \n\nstatic int trng_open(struct inode *inode, struct file *file)\n{\n\treturn nonseekable_open(inode, file);\n}\n\nstatic ssize_t trng_read(struct file *file, char __user *ubuf,\n\t\t\t size_t nbytes, loff_t *ppos)\n{\n\tu8 buf[32];\n\tu8 *p = buf;\n\tunsigned int n;\n\tssize_t ret = 0;\n\n\t \n\n\tif (nbytes > sizeof(buf)) {\n\t\tp = (u8 *) __get_free_page(GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t}\n\n\twhile (nbytes) {\n\t\tif (need_resched()) {\n\t\t\tif (signal_pending(current)) {\n\t\t\t\tif (ret == 0)\n\t\t\t\t\tret = -ERESTARTSYS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tschedule();\n\t\t}\n\t\tn = nbytes > PAGE_SIZE ? PAGE_SIZE : nbytes;\n\t\tcpacf_trng(NULL, 0, p, n);\n\t\tatomic64_add(n, &trng_dev_counter);\n\t\tif (copy_to_user(ubuf, p, n)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tnbytes -= n;\n\t\tubuf += n;\n\t\tret += n;\n\t}\n\n\tif (p != buf)\n\t\tfree_page((unsigned long) p);\n\n\tDEBUG_DBG(\"trng_read()=%zd\\n\", ret);\n\treturn ret;\n}\n\n\n \n\nstatic ssize_t trng_counter_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tu64 dev_counter = atomic64_read(&trng_dev_counter);\n\tu64 hwrng_counter = atomic64_read(&trng_hwrng_counter);\n\tu64 arch_counter = atomic64_read(&s390_arch_random_counter);\n\n\treturn sysfs_emit(buf,\n\t\t\t\"trng:  %llu\\n\"\n\t\t\t\"hwrng: %llu\\n\"\n\t\t\t\"arch:  %llu\\n\"\n\t\t\t\"total: %llu\\n\",\n\t\t\tdev_counter, hwrng_counter, arch_counter,\n\t\t\tdev_counter + hwrng_counter + arch_counter);\n}\nstatic DEVICE_ATTR(byte_counter, 0444, trng_counter_show, NULL);\n\nstatic struct attribute *trng_dev_attrs[] = {\n\t&dev_attr_byte_counter.attr,\n\tNULL\n};\n\nstatic const struct attribute_group trng_dev_attr_group = {\n\t.attrs = trng_dev_attrs\n};\n\nstatic const struct attribute_group *trng_dev_attr_groups[] = {\n\t&trng_dev_attr_group,\n\tNULL\n};\n\nstatic const struct file_operations trng_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= &trng_open,\n\t.release\t= NULL,\n\t.read\t\t= &trng_read,\n\t.llseek\t\t= noop_llseek,\n};\n\nstatic struct miscdevice trng_dev = {\n\t.name\t= \"trng\",\n\t.minor\t= MISC_DYNAMIC_MINOR,\n\t.mode\t= 0444,\n\t.fops\t= &trng_fops,\n\t.groups = trng_dev_attr_groups,\n};\n\n\n \n\nstatic inline void _trng_hwrng_read(u8 *buf, size_t len)\n{\n\tcpacf_trng(NULL, 0, buf, len);\n\tatomic64_add(len, &trng_hwrng_counter);\n}\n\nstatic int trng_hwrng_data_read(struct hwrng *rng, u32 *data)\n{\n\tsize_t len = sizeof(*data);\n\n\t_trng_hwrng_read((u8 *) data, len);\n\n\tDEBUG_DBG(\"trng_hwrng_data_read()=%zu\\n\", len);\n\n\treturn len;\n}\n\nstatic int trng_hwrng_read(struct hwrng *rng, void *data, size_t max, bool wait)\n{\n\tsize_t len = max <= PAGE_SIZE ? max : PAGE_SIZE;\n\n\t_trng_hwrng_read((u8 *) data, len);\n\n\tDEBUG_DBG(\"trng_hwrng_read()=%zu\\n\", len);\n\n\treturn len;\n}\n\n \nstatic struct hwrng trng_hwrng_dev = {\n\t.name\t\t= \"s390-trng\",\n\t.data_read\t= trng_hwrng_data_read,\n\t.read\t\t= trng_hwrng_read,\n};\n\n\n \n\nstatic void __init trng_debug_init(void)\n{\n\tdebug_info = debug_register(\"trng\", 1, 1, 4 * sizeof(long));\n\tdebug_register_view(debug_info, &debug_sprintf_view);\n\tdebug_set_level(debug_info, 3);\n}\n\nstatic void trng_debug_exit(void)\n{\n\tdebug_unregister(debug_info);\n}\n\nstatic int __init trng_init(void)\n{\n\tint ret;\n\n\ttrng_debug_init();\n\n\t \n\tif (!cpacf_query_func(CPACF_PRNO, CPACF_PRNO_TRNG)) {\n\t\tDEBUG_INFO(\"trng_init CPACF_PRNO_TRNG not available\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out_dbg;\n\t}\n\n\tret = misc_register(&trng_dev);\n\tif (ret) {\n\t\tDEBUG_WARN(\"trng_init misc_register() failed rc=%d\\n\", ret);\n\t\tgoto out_dbg;\n\t}\n\n\tret = hwrng_register(&trng_hwrng_dev);\n\tif (ret) {\n\t\tDEBUG_WARN(\"trng_init hwrng_register() failed rc=%d\\n\", ret);\n\t\tgoto out_misc;\n\t}\n\n\tDEBUG_DBG(\"trng_init successful\\n\");\n\n\treturn 0;\n\nout_misc:\n\tmisc_deregister(&trng_dev);\nout_dbg:\n\ttrng_debug_exit();\n\treturn ret;\n}\n\nstatic void __exit trng_exit(void)\n{\n\thwrng_unregister(&trng_hwrng_dev);\n\tmisc_deregister(&trng_dev);\n\ttrng_debug_exit();\n}\n\nmodule_cpu_feature_match(S390_CPU_FEATURE_MSA, trng_init);\nmodule_exit(trng_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}