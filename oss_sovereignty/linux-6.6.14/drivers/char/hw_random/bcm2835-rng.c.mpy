{
  "module_name": "bcm2835-rng.c",
  "hash_id": "e37e735c02f7b33d562ad7708fb76aa923b70fe0e3d14f0f60f17c54aaed3d6a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/hw_random/bcm2835-rng.c",
  "human_readable_source": "\n \n\n#include <linux/hw_random.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/printk.h>\n#include <linux/clk.h>\n#include <linux/reset.h>\n\n#define RNG_CTRL\t0x0\n#define RNG_STATUS\t0x4\n#define RNG_DATA\t0x8\n#define RNG_INT_MASK\t0x10\n\n \n#define RNG_RBGEN\t0x1\n\n \n#define RNG_WARMUP_COUNT 0x40000\n\n#define RNG_INT_OFF\t0x1\n\nstruct bcm2835_rng_priv {\n\tstruct hwrng rng;\n\tvoid __iomem *base;\n\tbool mask_interrupts;\n\tstruct clk *clk;\n\tstruct reset_control *reset;\n};\n\nstatic inline struct bcm2835_rng_priv *to_rng_priv(struct hwrng *rng)\n{\n\treturn container_of(rng, struct bcm2835_rng_priv, rng);\n}\n\nstatic inline u32 rng_readl(struct bcm2835_rng_priv *priv, u32 offset)\n{\n\t \n\tif (IS_ENABLED(CONFIG_MIPS) && IS_ENABLED(CONFIG_CPU_BIG_ENDIAN))\n\t\treturn __raw_readl(priv->base + offset);\n\telse\n\t\treturn readl(priv->base + offset);\n}\n\nstatic inline void rng_writel(struct bcm2835_rng_priv *priv, u32 val,\n\t\t\t      u32 offset)\n{\n\tif (IS_ENABLED(CONFIG_MIPS) && IS_ENABLED(CONFIG_CPU_BIG_ENDIAN))\n\t\t__raw_writel(val, priv->base + offset);\n\telse\n\t\twritel(val, priv->base + offset);\n}\n\nstatic int bcm2835_rng_read(struct hwrng *rng, void *buf, size_t max,\n\t\t\t       bool wait)\n{\n\tstruct bcm2835_rng_priv *priv = to_rng_priv(rng);\n\tu32 max_words = max / sizeof(u32);\n\tu32 num_words, count;\n\n\twhile ((rng_readl(priv, RNG_STATUS) >> 24) == 0) {\n\t\tif (!wait)\n\t\t\treturn 0;\n\t\thwrng_yield(rng);\n\t}\n\n\tnum_words = rng_readl(priv, RNG_STATUS) >> 24;\n\tif (num_words > max_words)\n\t\tnum_words = max_words;\n\n\tfor (count = 0; count < num_words; count++)\n\t\t((u32 *)buf)[count] = rng_readl(priv, RNG_DATA);\n\n\treturn num_words * sizeof(u32);\n}\n\nstatic int bcm2835_rng_init(struct hwrng *rng)\n{\n\tstruct bcm2835_rng_priv *priv = to_rng_priv(rng);\n\tint ret = 0;\n\tu32 val;\n\n\tret = clk_prepare_enable(priv->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = reset_control_reset(priv->reset);\n\tif (ret)\n\t\treturn ret;\n\n\tif (priv->mask_interrupts) {\n\t\t \n\t\tval = rng_readl(priv, RNG_INT_MASK);\n\t\tval |= RNG_INT_OFF;\n\t\trng_writel(priv, val, RNG_INT_MASK);\n\t}\n\n\t \n\trng_writel(priv, RNG_WARMUP_COUNT, RNG_STATUS);\n\trng_writel(priv, RNG_RBGEN, RNG_CTRL);\n\n\treturn ret;\n}\n\nstatic void bcm2835_rng_cleanup(struct hwrng *rng)\n{\n\tstruct bcm2835_rng_priv *priv = to_rng_priv(rng);\n\n\t \n\trng_writel(priv, 0, RNG_CTRL);\n\n\tclk_disable_unprepare(priv->clk);\n}\n\nstruct bcm2835_rng_of_data {\n\tbool mask_interrupts;\n};\n\nstatic const struct bcm2835_rng_of_data nsp_rng_of_data = {\n\t.mask_interrupts = true,\n};\n\nstatic const struct of_device_id bcm2835_rng_of_match[] = {\n\t{ .compatible = \"brcm,bcm2835-rng\"},\n\t{ .compatible = \"brcm,bcm-nsp-rng\", .data = &nsp_rng_of_data },\n\t{ .compatible = \"brcm,bcm5301x-rng\", .data = &nsp_rng_of_data },\n\t{ .compatible = \"brcm,bcm6368-rng\"},\n\t{},\n};\n\nstatic int bcm2835_rng_probe(struct platform_device *pdev)\n{\n\tconst struct bcm2835_rng_of_data *of_data;\n\tstruct device *dev = &pdev->dev;\n\tconst struct of_device_id *rng_id;\n\tstruct bcm2835_rng_priv *priv;\n\tint err;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, priv);\n\n\t \n\tpriv->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->base))\n\t\treturn PTR_ERR(priv->base);\n\n\t \n\tpriv->clk = devm_clk_get_optional(dev, NULL);\n\tif (IS_ERR(priv->clk))\n\t\treturn PTR_ERR(priv->clk);\n\n\tpriv->reset = devm_reset_control_get_optional_exclusive(dev, NULL);\n\tif (IS_ERR(priv->reset))\n\t\treturn PTR_ERR(priv->reset);\n\n\tpriv->rng.name = pdev->name;\n\tpriv->rng.init = bcm2835_rng_init;\n\tpriv->rng.read = bcm2835_rng_read;\n\tpriv->rng.cleanup = bcm2835_rng_cleanup;\n\n\tif (dev_of_node(dev)) {\n\t\trng_id = of_match_node(bcm2835_rng_of_match, dev->of_node);\n\t\tif (!rng_id)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tof_data = rng_id->data;\n\t\tif (of_data)\n\t\t\tpriv->mask_interrupts = of_data->mask_interrupts;\n\t}\n\n\t \n\terr = devm_hwrng_register(dev, &priv->rng);\n\tif (err)\n\t\tdev_err(dev, \"hwrng registration failed\\n\");\n\telse\n\t\tdev_info(dev, \"hwrng registered\\n\");\n\n\treturn err;\n}\n\nMODULE_DEVICE_TABLE(of, bcm2835_rng_of_match);\n\nstatic const struct platform_device_id bcm2835_rng_devtype[] = {\n\t{ .name = \"bcm2835-rng\" },\n\t{ .name = \"bcm63xx-rng\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(platform, bcm2835_rng_devtype);\n\nstatic struct platform_driver bcm2835_rng_driver = {\n\t.driver = {\n\t\t.name = \"bcm2835-rng\",\n\t\t.of_match_table = bcm2835_rng_of_match,\n\t},\n\t.probe\t\t= bcm2835_rng_probe,\n\t.id_table\t= bcm2835_rng_devtype,\n};\nmodule_platform_driver(bcm2835_rng_driver);\n\nMODULE_AUTHOR(\"Lubomir Rintel <lkundrak@v3.sk>\");\nMODULE_DESCRIPTION(\"BCM2835 Random Number Generator (RNG) driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}