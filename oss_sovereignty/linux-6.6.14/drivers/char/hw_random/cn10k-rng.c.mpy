{
  "module_name": "cn10k-rng.c",
  "hash_id": "ef82dcde6e5458ead3c1ce48034d541c7682fff7bafba30bc1b4dd10447e8e1d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/hw_random/cn10k-rng.c",
  "human_readable_source": "\n \n\n#include <linux/hw_random.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/pci_ids.h>\n#include <linux/delay.h>\n\n#include <linux/arm-smccc.h>\n\n \n#define RNM_CTL_STATUS\t\t0x000\n#define RNM_ENTROPY_STATUS\t0x008\n#define RNM_CONST\t\t0x030\n#define RNM_EBG_ENT\t\t0x048\n#define RNM_PF_EBG_HEALTH\t0x050\n#define RNM_PF_RANDOM\t\t0x400\n#define RNM_TRNG_RESULT\t\t0x408\n\n \n#define RNM_PF_TRNG_DAT\t\t0x1000\n#define RNM_PF_TRNG_RES\t\t0x1008\n\nstruct cn10k_rng {\n\tvoid __iomem *reg_base;\n\tstruct hwrng ops;\n\tstruct pci_dev *pdev;\n\t \n\tbool extended_trng_regs;\n};\n\n#define PLAT_OCTEONTX_RESET_RNG_EBG_HEALTH_STATE     0xc2000b0f\n\n#define PCI_SUBSYS_DEVID_CN10K_A_RNG\t0xB900\n#define PCI_SUBSYS_DEVID_CNF10K_A_RNG\t0xBA00\n#define PCI_SUBSYS_DEVID_CNF10K_B_RNG\t0xBC00\n\nstatic bool cn10k_is_extended_trng_regs_supported(struct pci_dev *pdev)\n{\n\t \n\tif ((pdev->subsystem_device == PCI_SUBSYS_DEVID_CN10K_A_RNG) &&\n\t    (!pdev->revision || (pdev->revision & 0xff) == 0x50 ||\n\t     (pdev->revision & 0xff) == 0x51))\n\t\treturn false;\n\n\t \n\tif ((pdev->subsystem_device == PCI_SUBSYS_DEVID_CNF10K_A_RNG) &&\n\t    (!pdev->revision || (pdev->revision & 0xff) == 0x60 ||\n\t     (pdev->revision & 0xff) == 0x61))\n\t\treturn false;\n\n\t \n\tif ((pdev->subsystem_device == PCI_SUBSYS_DEVID_CNF10K_B_RNG) &&\n\t    (!pdev->revision || (pdev->revision & 0xff) == 0x70 ||\n\t     (pdev->revision & 0xff) == 0x74))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic unsigned long reset_rng_health_state(struct cn10k_rng *rng)\n{\n\tstruct arm_smccc_res res;\n\n\t \n\tarm_smccc_smc(PLAT_OCTEONTX_RESET_RNG_EBG_HEALTH_STATE, 0, 0, 0, 0, 0, 0, 0, &res);\n\treturn res.a0;\n}\n\nstatic int check_rng_health(struct cn10k_rng *rng)\n{\n\tu64 status;\n\tunsigned long err;\n\n\t \n\tif (!rng->reg_base)\n\t\treturn -ENODEV;\n\n\tstatus = readq(rng->reg_base + RNM_PF_EBG_HEALTH);\n\tif (status & BIT_ULL(20)) {\n\t\terr = reset_rng_health_state(rng);\n\t\tif (err) {\n\t\t\tdev_err(&rng->pdev->dev, \"HWRNG: Health test failed (status=%llx)\\n\",\n\t\t\t\t\tstatus);\n\t\t\tdev_err(&rng->pdev->dev, \"HWRNG: error during reset (error=%lx)\\n\",\n\t\t\t\t\terr);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic bool cn10k_read_trng(struct cn10k_rng *rng, u64 *value)\n{\n\tu16 retry_count = 0;\n\tu64 upper, lower;\n\tu64 status;\n\n\tif (rng->extended_trng_regs) {\n\t\tdo {\n\t\t\t*value = readq(rng->reg_base + RNM_PF_TRNG_DAT);\n\t\t\tif (*value)\n\t\t\t\treturn true;\n\t\t\tstatus = readq(rng->reg_base + RNM_PF_TRNG_RES);\n\t\t\tif (!status && (retry_count++ > 0x1000))\n\t\t\t\treturn false;\n\t\t} while (!status);\n\t}\n\n\t*value = readq(rng->reg_base + RNM_PF_RANDOM);\n\n\t \n\tif (!*value) {\n\t\tupper = readq(rng->reg_base + RNM_PF_RANDOM);\n\t\tlower = readq(rng->reg_base + RNM_PF_RANDOM);\n\t\twhile (!(upper & 0x00000000FFFFFFFFULL))\n\t\t\tupper = readq(rng->reg_base + RNM_PF_RANDOM);\n\t\twhile (!(lower & 0xFFFFFFFF00000000ULL))\n\t\t\tlower = readq(rng->reg_base + RNM_PF_RANDOM);\n\n\t\t*value = (upper & 0xFFFFFFFF00000000) | (lower & 0xFFFFFFFF);\n\t}\n\treturn true;\n}\n\nstatic int cn10k_rng_read(struct hwrng *hwrng, void *data,\n\t\t\t  size_t max, bool wait)\n{\n\tstruct cn10k_rng *rng = (struct cn10k_rng *)hwrng->priv;\n\tunsigned int size;\n\tu8 *pos = data;\n\tint err = 0;\n\tu64 value;\n\n\terr = check_rng_health(rng);\n\tif (err)\n\t\treturn err;\n\n\tsize = max;\n\n\twhile (size >= 8) {\n\t\tif (!cn10k_read_trng(rng, &value))\n\t\t\tgoto out;\n\n\t\t*((u64 *)pos) = value;\n\t\tsize -= 8;\n\t\tpos += 8;\n\t}\n\n\tif (size > 0) {\n\t\tif (!cn10k_read_trng(rng, &value))\n\t\t\tgoto out;\n\n\t\twhile (size > 0) {\n\t\t\t*pos = (u8)value;\n\t\t\tvalue >>= 8;\n\t\t\tsize--;\n\t\t\tpos++;\n\t\t}\n\t}\n\nout:\n\treturn max - size;\n}\n\nstatic int cn10k_rng_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstruct\tcn10k_rng *rng;\n\tint\terr;\n\n\trng = devm_kzalloc(&pdev->dev, sizeof(*rng), GFP_KERNEL);\n\tif (!rng)\n\t\treturn -ENOMEM;\n\n\trng->pdev = pdev;\n\tpci_set_drvdata(pdev, rng);\n\n\trng->reg_base = pcim_iomap(pdev, 0, 0);\n\tif (!rng->reg_base)\n\t\treturn dev_err_probe(&pdev->dev, -ENOMEM, \"Error while mapping CSRs, exiting\\n\");\n\n\trng->ops.name = devm_kasprintf(&pdev->dev, GFP_KERNEL,\n\t\t\t\t       \"cn10k-rng-%s\", dev_name(&pdev->dev));\n\tif (!rng->ops.name)\n\t\treturn -ENOMEM;\n\n\trng->ops.read = cn10k_rng_read;\n\trng->ops.priv = (unsigned long)rng;\n\n\trng->extended_trng_regs = cn10k_is_extended_trng_regs_supported(pdev);\n\n\treset_rng_health_state(rng);\n\n\terr = devm_hwrng_register(&pdev->dev, &rng->ops);\n\tif (err)\n\t\treturn dev_err_probe(&pdev->dev, err, \"Could not register hwrng device.\\n\");\n\n\treturn 0;\n}\n\nstatic const struct pci_device_id cn10k_rng_id_table[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_CAVIUM, 0xA098) },  \n\t{0,},\n};\n\nMODULE_DEVICE_TABLE(pci, cn10k_rng_id_table);\n\nstatic struct pci_driver cn10k_rng_driver = {\n\t.name\t\t= \"cn10k_rng\",\n\t.id_table\t= cn10k_rng_id_table,\n\t.probe\t\t= cn10k_rng_probe,\n};\n\nmodule_pci_driver(cn10k_rng_driver);\nMODULE_AUTHOR(\"Sunil Goutham <sgoutham@marvell.com>\");\nMODULE_DESCRIPTION(\"Marvell CN10K HW RNG Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}