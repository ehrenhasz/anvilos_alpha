{
  "module_name": "st-rng.c",
  "hash_id": "cbf891dfd92c2d33cef4e76bb8563075c781e2c25e001caabc346df235887acd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/hw_random/st-rng.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/hw_random.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n \n#define ST_RNG_STATUS_REG\t\t0x20\n#define ST_RNG_DATA_REG\t\t\t0x24\n\n \n#define ST_RNG_STATUS_BAD_SEQUENCE\tBIT(0)\n#define ST_RNG_STATUS_BAD_ALTERNANCE\tBIT(1)\n#define ST_RNG_STATUS_FIFO_FULL\t\tBIT(5)\n\n#define ST_RNG_SAMPLE_SIZE\t\t2  \n#define ST_RNG_FIFO_DEPTH\t\t4\n#define ST_RNG_FIFO_SIZE\t\t(ST_RNG_FIFO_DEPTH * ST_RNG_SAMPLE_SIZE)\n\n \n#define ST_RNG_FILL_FIFO_TIMEOUT\t(12 * 2)\n\nstruct st_rng_data {\n\tvoid __iomem\t*base;\n\tstruct hwrng\tops;\n};\n\nstatic int st_rng_read(struct hwrng *rng, void *data, size_t max, bool wait)\n{\n\tstruct st_rng_data *ddata = (struct st_rng_data *)rng->priv;\n\tu32 status;\n\tint i;\n\n\t \n\tfor (i = 0; i < ST_RNG_FILL_FIFO_TIMEOUT; i++) {\n\t\tstatus = readl_relaxed(ddata->base + ST_RNG_STATUS_REG);\n\t\tif (status & ST_RNG_STATUS_FIFO_FULL)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tif (i == ST_RNG_FILL_FIFO_TIMEOUT)\n\t\treturn 0;\n\n\tfor (i = 0; i < ST_RNG_FIFO_SIZE && i < max; i += 2)\n\t\t*(u16 *)(data + i) =\n\t\t\treadl_relaxed(ddata->base + ST_RNG_DATA_REG);\n\n\treturn i;\t \n}\n\nstatic int st_rng_probe(struct platform_device *pdev)\n{\n\tstruct st_rng_data *ddata;\n\tstruct clk *clk;\n\tvoid __iomem *base;\n\tint ret;\n\n\tddata = devm_kzalloc(&pdev->dev, sizeof(*ddata), GFP_KERNEL);\n\tif (!ddata)\n\t\treturn -ENOMEM;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tclk = devm_clk_get_enabled(&pdev->dev, NULL);\n\tif (IS_ERR(clk))\n\t\treturn PTR_ERR(clk);\n\n\tddata->ops.priv\t= (unsigned long)ddata;\n\tddata->ops.read\t= st_rng_read;\n\tddata->ops.name\t= pdev->name;\n\tddata->base\t= base;\n\n\tret = devm_hwrng_register(&pdev->dev, &ddata->ops);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to register HW RNG\\n\");\n\t\treturn ret;\n\t}\n\n\tdev_info(&pdev->dev, \"Successfully registered HW RNG\\n\");\n\n\treturn 0;\n}\n\nstatic const struct of_device_id st_rng_match[] __maybe_unused = {\n\t{ .compatible = \"st,rng\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, st_rng_match);\n\nstatic struct platform_driver st_rng_driver = {\n\t.driver = {\n\t\t.name = \"st-hwrandom\",\n\t\t.of_match_table = of_match_ptr(st_rng_match),\n\t},\n\t.probe = st_rng_probe,\n};\n\nmodule_platform_driver(st_rng_driver);\n\nMODULE_AUTHOR(\"Pankaj Dev <pankaj.dev@st.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}