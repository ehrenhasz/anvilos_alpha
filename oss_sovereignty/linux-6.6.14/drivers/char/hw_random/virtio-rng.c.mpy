{
  "module_name": "virtio-rng.c",
  "hash_id": "da181fd5b3928047aa3c3d0ce6b0b713f1b771def90c9b7157db84a4194b99e2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/hw_random/virtio-rng.c",
  "human_readable_source": "\n \n\n#include <asm/barrier.h>\n#include <linux/err.h>\n#include <linux/hw_random.h>\n#include <linux/scatterlist.h>\n#include <linux/spinlock.h>\n#include <linux/virtio.h>\n#include <linux/virtio_rng.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nstatic DEFINE_IDA(rng_index_ida);\n\nstruct virtrng_info {\n\tstruct hwrng hwrng;\n\tstruct virtqueue *vq;\n\tchar name[25];\n\tint index;\n\tbool hwrng_register_done;\n\tbool hwrng_removed;\n\t \n\tstruct completion have_data;\n\tunsigned int data_avail;\n\tunsigned int data_idx;\n\t \n#if SMP_CACHE_BYTES < 32\n\tu8 data[32];\n#else\n\tu8 data[SMP_CACHE_BYTES];\n#endif\n};\n\nstatic void random_recv_done(struct virtqueue *vq)\n{\n\tstruct virtrng_info *vi = vq->vdev->priv;\n\tunsigned int len;\n\n\t \n\tif (!virtqueue_get_buf(vi->vq, &len))\n\t\treturn;\n\n\tsmp_store_release(&vi->data_avail, len);\n\tcomplete(&vi->have_data);\n}\n\nstatic void request_entropy(struct virtrng_info *vi)\n{\n\tstruct scatterlist sg;\n\n\treinit_completion(&vi->have_data);\n\tvi->data_idx = 0;\n\n\tsg_init_one(&sg, vi->data, sizeof(vi->data));\n\n\t \n\tvirtqueue_add_inbuf(vi->vq, &sg, 1, vi->data, GFP_KERNEL);\n\n\tvirtqueue_kick(vi->vq);\n}\n\nstatic unsigned int copy_data(struct virtrng_info *vi, void *buf,\n\t\t\t      unsigned int size)\n{\n\tsize = min_t(unsigned int, size, vi->data_avail);\n\tmemcpy(buf, vi->data + vi->data_idx, size);\n\tvi->data_idx += size;\n\tvi->data_avail -= size;\n\tif (vi->data_avail == 0)\n\t\trequest_entropy(vi);\n\treturn size;\n}\n\nstatic int virtio_read(struct hwrng *rng, void *buf, size_t size, bool wait)\n{\n\tint ret;\n\tstruct virtrng_info *vi = (struct virtrng_info *)rng->priv;\n\tunsigned int chunk;\n\tsize_t read;\n\n\tif (vi->hwrng_removed)\n\t\treturn -ENODEV;\n\n\tread = 0;\n\n\t \n\tif (smp_load_acquire(&vi->data_avail)) {\n\t\tchunk = copy_data(vi, buf, size);\n\t\tsize -= chunk;\n\t\tread += chunk;\n\t}\n\n\tif (!wait)\n\t\treturn read;\n\n\t \n\twhile (size != 0) {\n\t\t \n\t\tret = wait_for_completion_killable(&vi->have_data);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t \n\t\tif (vi->data_avail == 0)\n\t\t\treturn read;\n\n\t\tchunk = copy_data(vi, buf + read, size);\n\t\tsize -= chunk;\n\t\tread += chunk;\n\t}\n\n\treturn read;\n}\n\nstatic void virtio_cleanup(struct hwrng *rng)\n{\n\tstruct virtrng_info *vi = (struct virtrng_info *)rng->priv;\n\n\tcomplete(&vi->have_data);\n}\n\nstatic int probe_common(struct virtio_device *vdev)\n{\n\tint err, index;\n\tstruct virtrng_info *vi = NULL;\n\n\tvi = kzalloc(sizeof(struct virtrng_info), GFP_KERNEL);\n\tif (!vi)\n\t\treturn -ENOMEM;\n\n\tvi->index = index = ida_simple_get(&rng_index_ida, 0, 0, GFP_KERNEL);\n\tif (index < 0) {\n\t\terr = index;\n\t\tgoto err_ida;\n\t}\n\tsprintf(vi->name, \"virtio_rng.%d\", index);\n\tinit_completion(&vi->have_data);\n\n\tvi->hwrng = (struct hwrng) {\n\t\t.read = virtio_read,\n\t\t.cleanup = virtio_cleanup,\n\t\t.priv = (unsigned long)vi,\n\t\t.name = vi->name,\n\t};\n\tvdev->priv = vi;\n\n\t \n\tvi->vq = virtio_find_single_vq(vdev, random_recv_done, \"input\");\n\tif (IS_ERR(vi->vq)) {\n\t\terr = PTR_ERR(vi->vq);\n\t\tgoto err_find;\n\t}\n\n\tvirtio_device_ready(vdev);\n\n\t \n\trequest_entropy(vi);\n\n\treturn 0;\n\nerr_find:\n\tida_simple_remove(&rng_index_ida, index);\nerr_ida:\n\tkfree(vi);\n\treturn err;\n}\n\nstatic void remove_common(struct virtio_device *vdev)\n{\n\tstruct virtrng_info *vi = vdev->priv;\n\n\tvi->hwrng_removed = true;\n\tvi->data_avail = 0;\n\tvi->data_idx = 0;\n\tcomplete(&vi->have_data);\n\tif (vi->hwrng_register_done)\n\t\thwrng_unregister(&vi->hwrng);\n\tvirtio_reset_device(vdev);\n\tvdev->config->del_vqs(vdev);\n\tida_simple_remove(&rng_index_ida, vi->index);\n\tkfree(vi);\n}\n\nstatic int virtrng_probe(struct virtio_device *vdev)\n{\n\treturn probe_common(vdev);\n}\n\nstatic void virtrng_remove(struct virtio_device *vdev)\n{\n\tremove_common(vdev);\n}\n\nstatic void virtrng_scan(struct virtio_device *vdev)\n{\n\tstruct virtrng_info *vi = vdev->priv;\n\tint err;\n\n\terr = hwrng_register(&vi->hwrng);\n\tif (!err)\n\t\tvi->hwrng_register_done = true;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int virtrng_freeze(struct virtio_device *vdev)\n{\n\tremove_common(vdev);\n\treturn 0;\n}\n\nstatic int virtrng_restore(struct virtio_device *vdev)\n{\n\tint err;\n\n\terr = probe_common(vdev);\n\tif (!err) {\n\t\tstruct virtrng_info *vi = vdev->priv;\n\n\t\t \n\t\tvi->hwrng_removed = true;\n\t\terr = hwrng_register(&vi->hwrng);\n\t\tif (!err) {\n\t\t\tvi->hwrng_register_done = true;\n\t\t\tvi->hwrng_removed = false;\n\t\t}\n\t}\n\n\treturn err;\n}\n#endif\n\nstatic const struct virtio_device_id id_table[] = {\n\t{ VIRTIO_ID_RNG, VIRTIO_DEV_ANY_ID },\n\t{ 0 },\n};\n\nstatic struct virtio_driver virtio_rng_driver = {\n\t.driver.name =\tKBUILD_MODNAME,\n\t.driver.owner =\tTHIS_MODULE,\n\t.id_table =\tid_table,\n\t.probe =\tvirtrng_probe,\n\t.remove =\tvirtrng_remove,\n\t.scan =\t\tvirtrng_scan,\n#ifdef CONFIG_PM_SLEEP\n\t.freeze =\tvirtrng_freeze,\n\t.restore =\tvirtrng_restore,\n#endif\n};\n\nmodule_virtio_driver(virtio_rng_driver);\nMODULE_DEVICE_TABLE(virtio, id_table);\nMODULE_DESCRIPTION(\"Virtio random number driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}