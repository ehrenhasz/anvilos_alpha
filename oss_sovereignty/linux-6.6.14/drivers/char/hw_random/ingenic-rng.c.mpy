{
  "module_name": "ingenic-rng.c",
  "hash_id": "d3a11959555afed46cc51eb898607a0f92ec30f71a32d5ebcf831e7f6c73ef16",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/hw_random/ingenic-rng.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/kernel.h>\n#include <linux/hw_random.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/of_device.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n \n#define RNG_REG_ERNG_OFFSET\t\t0x0\n#define RNG_REG_RNG_OFFSET\t\t0x4\n\n \n#define ERNG_READY\t\t\t\tBIT(31)\n#define ERNG_ENABLE\t\t\t\tBIT(0)\n\nenum ingenic_rng_version {\n\tID_JZ4780,\n\tID_X1000,\n};\n\n \nstruct ingenic_rng {\n\tenum ingenic_rng_version version;\n\n\tvoid __iomem *base;\n\tstruct hwrng rng;\n};\n\nstatic int ingenic_rng_init(struct hwrng *rng)\n{\n\tstruct ingenic_rng *priv = container_of(rng, struct ingenic_rng, rng);\n\n\twritel(ERNG_ENABLE, priv->base + RNG_REG_ERNG_OFFSET);\n\n\treturn 0;\n}\n\nstatic void ingenic_rng_cleanup(struct hwrng *rng)\n{\n\tstruct ingenic_rng *priv = container_of(rng, struct ingenic_rng, rng);\n\n\twritel(0, priv->base + RNG_REG_ERNG_OFFSET);\n}\n\nstatic int ingenic_rng_read(struct hwrng *rng, void *buf, size_t max, bool wait)\n{\n\tstruct ingenic_rng *priv = container_of(rng, struct ingenic_rng, rng);\n\tu32 *data = buf;\n\tu32 status;\n\tint ret;\n\n\tif (priv->version >= ID_X1000) {\n\t\tret = readl_poll_timeout(priv->base + RNG_REG_ERNG_OFFSET, status,\n\t\t\t\t\t status & ERNG_READY, 10, 1000);\n\t\tif (ret == -ETIMEDOUT) {\n\t\t\tpr_err(\"%s: Wait for RNG data ready timeout\\n\", __func__);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\t \n\t\tudelay(20);\n\t}\n\n\t*data = readl(priv->base + RNG_REG_RNG_OFFSET);\n\n\treturn 4;\n}\n\nstatic int ingenic_rng_probe(struct platform_device *pdev)\n{\n\tstruct ingenic_rng *priv;\n\tint ret;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->base)) {\n\t\tpr_err(\"%s: Failed to map RNG registers\\n\", __func__);\n\t\treturn PTR_ERR(priv->base);\n\t}\n\n\tpriv->version = (enum ingenic_rng_version)(uintptr_t)of_device_get_match_data(&pdev->dev);\n\n\tpriv->rng.name = pdev->name;\n\tpriv->rng.init = ingenic_rng_init;\n\tpriv->rng.cleanup = ingenic_rng_cleanup;\n\tpriv->rng.read = ingenic_rng_read;\n\n\tret = hwrng_register(&priv->rng);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to register hwrng\\n\");\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tdev_info(&pdev->dev, \"Ingenic RNG driver registered\\n\");\n\treturn 0;\n}\n\nstatic int ingenic_rng_remove(struct platform_device *pdev)\n{\n\tstruct ingenic_rng *priv = platform_get_drvdata(pdev);\n\n\thwrng_unregister(&priv->rng);\n\n\twritel(0, priv->base + RNG_REG_ERNG_OFFSET);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id ingenic_rng_of_match[] = {\n\t{ .compatible = \"ingenic,jz4780-rng\", .data = (void *) ID_JZ4780 },\n\t{ .compatible = \"ingenic,x1000-rng\", .data = (void *) ID_X1000 },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, ingenic_rng_of_match);\n\nstatic struct platform_driver ingenic_rng_driver = {\n\t.probe\t\t= ingenic_rng_probe,\n\t.remove\t\t= ingenic_rng_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"ingenic-rng\",\n\t\t.of_match_table = ingenic_rng_of_match,\n\t},\n};\n\nmodule_platform_driver(ingenic_rng_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"PrasannaKumar Muralidharan <prasannatsmkumar@gmail.com>\");\nMODULE_AUTHOR(\"\u5468\u7430\u6770 (Zhou Yanjie) <zhouyanjie@wanyeetech.com>\");\nMODULE_DESCRIPTION(\"Ingenic Random Number Generator driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}