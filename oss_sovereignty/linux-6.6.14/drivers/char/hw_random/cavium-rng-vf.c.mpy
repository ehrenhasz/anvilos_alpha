{
  "module_name": "cavium-rng-vf.c",
  "hash_id": "8dd1d4466def65d8ee8e07c18612b88819f00861676e9c3753919348db874c18",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/hw_random/cavium-rng-vf.c",
  "human_readable_source": "\n \n\n#include <linux/hw_random.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/pci_ids.h>\n\n#include <asm/arch_timer.h>\n\n \n#define\tPCI_DEVID_CAVIUM_RNG_PF\t\t0xA018\n#define\tPCI_DEVID_CAVIUM_RNG_VF\t\t0xA033\n\n#define HEALTH_STATUS_REG\t\t0x38\n\n \n#define PCI_DEVICE_ID_RST_OTX2\t\t0xA085\n#define RST_BOOT_REG\t\t\t0x1600ULL\n#define CLOCK_BASE_RATE\t\t\t50000000ULL\n#define MSEC_TO_NSEC(x)\t\t\t(x * 1000000)\n\nstruct cavium_rng {\n\tstruct hwrng ops;\n\tvoid __iomem *result;\n\tvoid __iomem *pf_regbase;\n\tstruct pci_dev *pdev;\n\tu64  clock_rate;\n\tu64  prev_error;\n\tu64  prev_time;\n};\n\nstatic inline bool is_octeontx(struct pci_dev *pdev)\n{\n\tif (midr_is_cpu_model_range(read_cpuid_id(), MIDR_THUNDERX_83XX,\n\t\t\t\t    MIDR_CPU_VAR_REV(0, 0),\n\t\t\t\t    MIDR_CPU_VAR_REV(3, 0)) ||\n\t    midr_is_cpu_model_range(read_cpuid_id(), MIDR_THUNDERX_81XX,\n\t\t\t\t    MIDR_CPU_VAR_REV(0, 0),\n\t\t\t\t    MIDR_CPU_VAR_REV(3, 0)) ||\n\t    midr_is_cpu_model_range(read_cpuid_id(), MIDR_THUNDERX,\n\t\t\t\t    MIDR_CPU_VAR_REV(0, 0),\n\t\t\t\t    MIDR_CPU_VAR_REV(3, 0)))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic u64 rng_get_coprocessor_clkrate(void)\n{\n\tu64 ret = CLOCK_BASE_RATE * 16;  \n\tstruct pci_dev *pdev;\n\tvoid __iomem *base;\n\n\tpdev = pci_get_device(PCI_VENDOR_ID_CAVIUM,\n\t\t\t      PCI_DEVICE_ID_RST_OTX2, NULL);\n\tif (!pdev)\n\t\tgoto error;\n\n\tbase = pci_ioremap_bar(pdev, 0);\n\tif (!base)\n\t\tgoto error_put_pdev;\n\n\t \n\tret = CLOCK_BASE_RATE * ((readq(base + RST_BOOT_REG) >> 33) & 0x3F);\n\n\tiounmap(base);\n\nerror_put_pdev:\n\tpci_dev_put(pdev);\n\nerror:\n\treturn ret;\n}\n\nstatic int check_rng_health(struct cavium_rng *rng)\n{\n\tu64 cur_err, cur_time;\n\tu64 status, cycles;\n\tu64 time_elapsed;\n\n\n\t \n\tif (!rng->pf_regbase)\n\t\treturn 0;\n\n\tstatus = readq(rng->pf_regbase + HEALTH_STATUS_REG);\n\tif (status & BIT_ULL(0)) {\n\t\tdev_err(&rng->pdev->dev, \"HWRNG: Startup health test failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\tcycles = status >> 1;\n\tif (!cycles)\n\t\treturn 0;\n\n\tcur_time = arch_timer_read_counter();\n\n\t \n\tcycles = cycles / 2;\n\tcur_err = (cycles * 1000000000) / rng->clock_rate;  \n\n\t \n\tif (cur_err > MSEC_TO_NSEC(10)) {\n\t\trng->prev_error = 0;\n\t\trng->prev_time = 0;\n\t\treturn 0;\n\t}\n\n\tif (rng->prev_error) {\n\t\t \n\t\ttime_elapsed = (cur_time - rng->prev_time) * 10;\n\t\ttime_elapsed += rng->prev_error;\n\n\t\t \n\t\tif (cur_err < time_elapsed) {\n\t\t\tdev_err(&rng->pdev->dev, \"HWRNG failure detected\\n\");\n\t\t\trng->prev_error = cur_err;\n\t\t\trng->prev_time = cur_time;\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\trng->prev_error = cur_err;\n\trng->prev_time = cur_time;\n\treturn 0;\n}\n\n \nstatic int cavium_rng_read(struct hwrng *rng, void *dat, size_t max, bool wait)\n{\n\tstruct cavium_rng *p = container_of(rng, struct cavium_rng, ops);\n\tunsigned int size = max;\n\tint err = 0;\n\n\terr = check_rng_health(p);\n\tif (err)\n\t\treturn err;\n\n\twhile (size >= 8) {\n\t\t*((u64 *)dat) = readq(p->result);\n\t\tsize -= 8;\n\t\tdat += 8;\n\t}\n\twhile (size > 0) {\n\t\t*((u8 *)dat) = readb(p->result);\n\t\tsize--;\n\t\tdat++;\n\t}\n\treturn max;\n}\n\nstatic int cavium_map_pf_regs(struct cavium_rng *rng)\n{\n\tstruct pci_dev *pdev;\n\n\t \n\tif (is_octeontx(rng->pdev)) {\n\t\trng->pf_regbase = NULL;\n\t\treturn 0;\n\t}\n\n\tpdev = pci_get_device(PCI_VENDOR_ID_CAVIUM,\n\t\t\t      PCI_DEVID_CAVIUM_RNG_PF, NULL);\n\tif (!pdev) {\n\t\tpr_err(\"Cannot find RNG PF device\\n\");\n\t\treturn -EIO;\n\t}\n\n\trng->pf_regbase = ioremap(pci_resource_start(pdev, 0),\n\t\t\t\t  pci_resource_len(pdev, 0));\n\tif (!rng->pf_regbase) {\n\t\tdev_err(&pdev->dev, \"Failed to map PF CSR region\\n\");\n\t\tpci_dev_put(pdev);\n\t\treturn -ENOMEM;\n\t}\n\n\tpci_dev_put(pdev);\n\n\t \n\trng->clock_rate = rng_get_coprocessor_clkrate();\n\n\treturn 0;\n}\n\n \nstatic int cavium_rng_probe_vf(struct\tpci_dev\t\t*pdev,\n\t\t\t const struct\tpci_device_id\t*id)\n{\n\tstruct\tcavium_rng *rng;\n\tint\tret;\n\n\trng = devm_kzalloc(&pdev->dev, sizeof(*rng), GFP_KERNEL);\n\tif (!rng)\n\t\treturn -ENOMEM;\n\n\trng->pdev = pdev;\n\n\t \n\trng->result = pcim_iomap(pdev, 0, 0);\n\tif (!rng->result) {\n\t\tdev_err(&pdev->dev, \"Error iomap failed retrieving result.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\trng->ops.name = devm_kasprintf(&pdev->dev, GFP_KERNEL,\n\t\t\t\t       \"cavium-rng-%s\", dev_name(&pdev->dev));\n\tif (!rng->ops.name)\n\t\treturn -ENOMEM;\n\n\trng->ops.read    = cavium_rng_read;\n\n\tpci_set_drvdata(pdev, rng);\n\n\t \n\tret = cavium_map_pf_regs(rng);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_hwrng_register(&pdev->dev, &rng->ops);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Error registering device as HWRNG.\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void cavium_rng_remove_vf(struct pci_dev *pdev)\n{\n\tstruct cavium_rng *rng;\n\n\trng = pci_get_drvdata(pdev);\n\tiounmap(rng->pf_regbase);\n}\n\nstatic const struct pci_device_id cavium_rng_vf_id_table[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_CAVIUM, PCI_DEVID_CAVIUM_RNG_VF) },\n\t{ 0, }\n};\nMODULE_DEVICE_TABLE(pci, cavium_rng_vf_id_table);\n\nstatic struct pci_driver cavium_rng_vf_driver = {\n\t.name\t\t= \"cavium_rng_vf\",\n\t.id_table\t= cavium_rng_vf_id_table,\n\t.probe\t\t= cavium_rng_probe_vf,\n\t.remove\t\t= cavium_rng_remove_vf,\n};\nmodule_pci_driver(cavium_rng_vf_driver);\n\nMODULE_AUTHOR(\"Omer Khaliq <okhaliq@caviumnetworks.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}