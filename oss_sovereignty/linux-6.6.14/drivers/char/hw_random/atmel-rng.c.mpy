{
  "module_name": "atmel-rng.c",
  "hash_id": "0c2a6f27eaa056a4f055c61dd65203cb070adbad62262cf48e784b7354636d15",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/hw_random/atmel-rng.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/hw_random.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n\n#define TRNG_CR\t\t0x00\n#define TRNG_MR\t\t0x04\n#define TRNG_ISR\t0x1c\n#define TRNG_ISR_DATRDY\tBIT(0)\n#define TRNG_ODATA\t0x50\n\n#define TRNG_KEY\t0x524e4700  \n\n#define TRNG_HALFR\tBIT(0)  \n\nstruct atmel_trng_data {\n\tbool has_half_rate;\n};\n\nstruct atmel_trng {\n\tstruct clk *clk;\n\tvoid __iomem *base;\n\tstruct hwrng rng;\n\tbool has_half_rate;\n};\n\nstatic bool atmel_trng_wait_ready(struct atmel_trng *trng, bool wait)\n{\n\tint ready;\n\n\tready = readl(trng->base + TRNG_ISR) & TRNG_ISR_DATRDY;\n\tif (!ready && wait)\n\t\treadl_poll_timeout(trng->base + TRNG_ISR, ready,\n\t\t\t\t   ready & TRNG_ISR_DATRDY, 1000, 20000);\n\n\treturn !!ready;\n}\n\nstatic int atmel_trng_read(struct hwrng *rng, void *buf, size_t max,\n\t\t\t   bool wait)\n{\n\tstruct atmel_trng *trng = container_of(rng, struct atmel_trng, rng);\n\tu32 *data = buf;\n\tint ret;\n\n\tret = pm_runtime_get_sync((struct device *)trng->rng.priv);\n\tif (ret < 0) {\n\t\tpm_runtime_put_sync((struct device *)trng->rng.priv);\n\t\treturn ret;\n\t}\n\n\tret = atmel_trng_wait_ready(trng, wait);\n\tif (!ret)\n\t\tgoto out;\n\n\t*data = readl(trng->base + TRNG_ODATA);\n\t \n\treadl(trng->base + TRNG_ISR);\n\tret = 4;\n\nout:\n\tpm_runtime_mark_last_busy((struct device *)trng->rng.priv);\n\tpm_runtime_put_sync_autosuspend((struct device *)trng->rng.priv);\n\treturn ret;\n}\n\nstatic int atmel_trng_init(struct atmel_trng *trng)\n{\n\tunsigned long rate;\n\tint ret;\n\n\tret = clk_prepare_enable(trng->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tif (trng->has_half_rate) {\n\t\trate = clk_get_rate(trng->clk);\n\n\t\t \n\t\tif (rate > 100000000)\n\t\t\twritel(TRNG_HALFR, trng->base + TRNG_MR);\n\t}\n\n\twritel(TRNG_KEY | 1, trng->base + TRNG_CR);\n\n\treturn 0;\n}\n\nstatic void atmel_trng_cleanup(struct atmel_trng *trng)\n{\n\twritel(TRNG_KEY, trng->base + TRNG_CR);\n\tclk_disable_unprepare(trng->clk);\n}\n\nstatic int atmel_trng_probe(struct platform_device *pdev)\n{\n\tstruct atmel_trng *trng;\n\tconst struct atmel_trng_data *data;\n\tint ret;\n\n\ttrng = devm_kzalloc(&pdev->dev, sizeof(*trng), GFP_KERNEL);\n\tif (!trng)\n\t\treturn -ENOMEM;\n\n\ttrng->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(trng->base))\n\t\treturn PTR_ERR(trng->base);\n\n\ttrng->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(trng->clk))\n\t\treturn PTR_ERR(trng->clk);\n\tdata = of_device_get_match_data(&pdev->dev);\n\tif (!data)\n\t\treturn -ENODEV;\n\n\ttrng->has_half_rate = data->has_half_rate;\n\ttrng->rng.name = pdev->name;\n\ttrng->rng.read = atmel_trng_read;\n\ttrng->rng.priv = (unsigned long)&pdev->dev;\n\tplatform_set_drvdata(pdev, trng);\n\n#ifndef CONFIG_PM\n\tret = atmel_trng_init(trng);\n\tif (ret)\n\t\treturn ret;\n#endif\n\n\tpm_runtime_set_autosuspend_delay(&pdev->dev, 100);\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\n\tret = devm_hwrng_register(&pdev->dev, &trng->rng);\n\tif (ret) {\n\t\tpm_runtime_disable(&pdev->dev);\n\t\tpm_runtime_set_suspended(&pdev->dev);\n#ifndef CONFIG_PM\n\t\tatmel_trng_cleanup(trng);\n#endif\n\t}\n\n\treturn ret;\n}\n\nstatic int atmel_trng_remove(struct platform_device *pdev)\n{\n\tstruct atmel_trng *trng = platform_get_drvdata(pdev);\n\n\tatmel_trng_cleanup(trng);\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_set_suspended(&pdev->dev);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused atmel_trng_runtime_suspend(struct device *dev)\n{\n\tstruct atmel_trng *trng = dev_get_drvdata(dev);\n\n\tatmel_trng_cleanup(trng);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused atmel_trng_runtime_resume(struct device *dev)\n{\n\tstruct atmel_trng *trng = dev_get_drvdata(dev);\n\n\treturn atmel_trng_init(trng);\n}\n\nstatic const struct dev_pm_ops __maybe_unused atmel_trng_pm_ops = {\n\tSET_RUNTIME_PM_OPS(atmel_trng_runtime_suspend,\n\t\t\t   atmel_trng_runtime_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n};\n\nstatic const struct atmel_trng_data at91sam9g45_config = {\n\t.has_half_rate = false,\n};\n\nstatic const struct atmel_trng_data sam9x60_config = {\n\t.has_half_rate = true,\n};\n\nstatic const struct of_device_id atmel_trng_dt_ids[] = {\n\t{\n\t\t.compatible = \"atmel,at91sam9g45-trng\",\n\t\t.data = &at91sam9g45_config,\n\t}, {\n\t\t.compatible = \"microchip,sam9x60-trng\",\n\t\t.data = &sam9x60_config,\n\t}, {\n\t\t \n\t}\n};\nMODULE_DEVICE_TABLE(of, atmel_trng_dt_ids);\n\nstatic struct platform_driver atmel_trng_driver = {\n\t.probe\t\t= atmel_trng_probe,\n\t.remove\t\t= atmel_trng_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"atmel-trng\",\n\t\t.pm\t= pm_ptr(&atmel_trng_pm_ops),\n\t\t.of_match_table = atmel_trng_dt_ids,\n\t},\n};\n\nmodule_platform_driver(atmel_trng_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Peter Korsgaard <jacmet@sunsite.dk>\");\nMODULE_DESCRIPTION(\"Atmel true random number generator driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}