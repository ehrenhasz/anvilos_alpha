{
  "module_name": "n2-drv.c",
  "hash_id": "6f84cc54cd5a0becf71c7c7c32112b9f332ce647fd46d8b60b9b894226a74fcb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/hw_random/n2-drv.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/preempt.h>\n#include <linux/hw_random.h>\n\n#include <linux/of.h>\n#include <linux/of_device.h>\n\n#include <asm/hypervisor.h>\n\n#include \"n2rng.h\"\n\n#define DRV_MODULE_NAME\t\t\"n2rng\"\n#define PFX DRV_MODULE_NAME\t\": \"\n#define DRV_MODULE_VERSION\t\"0.3\"\n#define DRV_MODULE_RELDATE\t\"Jan 7, 2017\"\n\nstatic char version[] =\n\tDRV_MODULE_NAME \" v\" DRV_MODULE_VERSION \" (\" DRV_MODULE_RELDATE \")\\n\";\n\nMODULE_AUTHOR(\"David S. Miller (davem@davemloft.net)\");\nMODULE_DESCRIPTION(\"Niagara2 RNG driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(DRV_MODULE_VERSION);\n\n \n\nstatic int n2rng_hv_err_trans(unsigned long hv_err)\n{\n\tswitch (hv_err) {\n\tcase HV_EOK:\n\t\treturn 0;\n\tcase HV_EWOULDBLOCK:\n\t\treturn -EAGAIN;\n\tcase HV_ENOACCESS:\n\t\treturn -EPERM;\n\tcase HV_EIO:\n\t\treturn -EIO;\n\tcase HV_EBUSY:\n\t\treturn -EBUSY;\n\tcase HV_EBADALIGN:\n\tcase HV_ENORADDR:\n\t\treturn -EFAULT;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic unsigned long n2rng_generic_read_control_v2(unsigned long ra,\n\t\t\t\t\t\t   unsigned long unit)\n{\n\tunsigned long hv_err, state, ticks, watchdog_delta, watchdog_status;\n\tint block = 0, busy = 0;\n\n\twhile (1) {\n\t\thv_err = sun4v_rng_ctl_read_v2(ra, unit, &state,\n\t\t\t\t\t       &ticks,\n\t\t\t\t\t       &watchdog_delta,\n\t\t\t\t\t       &watchdog_status);\n\t\tif (hv_err == HV_EOK)\n\t\t\tbreak;\n\n\t\tif (hv_err == HV_EBUSY) {\n\t\t\tif (++busy >= N2RNG_BUSY_LIMIT)\n\t\t\t\tbreak;\n\n\t\t\tudelay(1);\n\t\t} else if (hv_err == HV_EWOULDBLOCK) {\n\t\t\tif (++block >= N2RNG_BLOCK_LIMIT)\n\t\t\t\tbreak;\n\n\t\t\t__delay(ticks);\n\t\t} else\n\t\t\tbreak;\n\t}\n\n\treturn hv_err;\n}\n\n \nstatic unsigned long n2rng_control_settle_v2(struct n2rng *np, int unit)\n{\n\tunsigned long ra = __pa(&np->scratch_control[0]);\n\n\treturn n2rng_generic_read_control_v2(ra, unit);\n}\n\nstatic unsigned long n2rng_write_ctl_one(struct n2rng *np, int unit,\n\t\t\t\t\t unsigned long state,\n\t\t\t\t\t unsigned long control_ra,\n\t\t\t\t\t unsigned long watchdog_timeout,\n\t\t\t\t\t unsigned long *ticks)\n{\n\tunsigned long hv_err;\n\n\tif (np->hvapi_major == 1) {\n\t\thv_err = sun4v_rng_ctl_write_v1(control_ra, state,\n\t\t\t\t\t\twatchdog_timeout, ticks);\n\t} else {\n\t\thv_err = sun4v_rng_ctl_write_v2(control_ra, state,\n\t\t\t\t\t\twatchdog_timeout, unit);\n\t\tif (hv_err == HV_EOK)\n\t\t\thv_err = n2rng_control_settle_v2(np, unit);\n\t\t*ticks = N2RNG_ACCUM_CYCLES_DEFAULT;\n\t}\n\n\treturn hv_err;\n}\n\nstatic int n2rng_generic_read_data(unsigned long data_ra)\n{\n\tunsigned long ticks, hv_err;\n\tint block = 0, hcheck = 0;\n\n\twhile (1) {\n\t\thv_err = sun4v_rng_data_read(data_ra, &ticks);\n\t\tif (hv_err == HV_EOK)\n\t\t\treturn 0;\n\n\t\tif (hv_err == HV_EWOULDBLOCK) {\n\t\t\tif (++block >= N2RNG_BLOCK_LIMIT)\n\t\t\t\treturn -EWOULDBLOCK;\n\t\t\t__delay(ticks);\n\t\t} else if (hv_err == HV_ENOACCESS) {\n\t\t\treturn -EPERM;\n\t\t} else if (hv_err == HV_EIO) {\n\t\t\tif (++hcheck >= N2RNG_HCHECK_LIMIT)\n\t\t\t\treturn -EIO;\n\t\t\tudelay(10000);\n\t\t} else\n\t\t\treturn -ENODEV;\n\t}\n}\n\nstatic unsigned long n2rng_read_diag_data_one(struct n2rng *np,\n\t\t\t\t\t      unsigned long unit,\n\t\t\t\t\t      unsigned long data_ra,\n\t\t\t\t\t      unsigned long data_len,\n\t\t\t\t\t      unsigned long *ticks)\n{\n\tunsigned long hv_err;\n\n\tif (np->hvapi_major == 1) {\n\t\thv_err = sun4v_rng_data_read_diag_v1(data_ra, data_len, ticks);\n\t} else {\n\t\thv_err = sun4v_rng_data_read_diag_v2(data_ra, data_len,\n\t\t\t\t\t\t     unit, ticks);\n\t\tif (!*ticks)\n\t\t\t*ticks = N2RNG_ACCUM_CYCLES_DEFAULT;\n\t}\n\treturn hv_err;\n}\n\nstatic int n2rng_generic_read_diag_data(struct n2rng *np,\n\t\t\t\t\tunsigned long unit,\n\t\t\t\t\tunsigned long data_ra,\n\t\t\t\t\tunsigned long data_len)\n{\n\tunsigned long ticks, hv_err;\n\tint block = 0;\n\n\twhile (1) {\n\t\thv_err = n2rng_read_diag_data_one(np, unit,\n\t\t\t\t\t\t  data_ra, data_len,\n\t\t\t\t\t\t  &ticks);\n\t\tif (hv_err == HV_EOK)\n\t\t\treturn 0;\n\n\t\tif (hv_err == HV_EWOULDBLOCK) {\n\t\t\tif (++block >= N2RNG_BLOCK_LIMIT)\n\t\t\t\treturn -EWOULDBLOCK;\n\t\t\t__delay(ticks);\n\t\t} else if (hv_err == HV_ENOACCESS) {\n\t\t\treturn -EPERM;\n\t\t} else if (hv_err == HV_EIO) {\n\t\t\treturn -EIO;\n\t\t} else\n\t\t\treturn -ENODEV;\n\t}\n}\n\n\nstatic int n2rng_generic_write_control(struct n2rng *np,\n\t\t\t\t       unsigned long control_ra,\n\t\t\t\t       unsigned long unit,\n\t\t\t\t       unsigned long state)\n{\n\tunsigned long hv_err, ticks;\n\tint block = 0, busy = 0;\n\n\twhile (1) {\n\t\thv_err = n2rng_write_ctl_one(np, unit, state, control_ra,\n\t\t\t\t\t     np->wd_timeo, &ticks);\n\t\tif (hv_err == HV_EOK)\n\t\t\treturn 0;\n\n\t\tif (hv_err == HV_EWOULDBLOCK) {\n\t\t\tif (++block >= N2RNG_BLOCK_LIMIT)\n\t\t\t\treturn -EWOULDBLOCK;\n\t\t\t__delay(ticks);\n\t\t} else if (hv_err == HV_EBUSY) {\n\t\t\tif (++busy >= N2RNG_BUSY_LIMIT)\n\t\t\t\treturn -EBUSY;\n\t\t\tudelay(1);\n\t\t} else\n\t\t\treturn -ENODEV;\n\t}\n}\n\n \nstatic int n2rng_try_read_ctl(struct n2rng *np)\n{\n\tunsigned long hv_err;\n\tunsigned long x;\n\n\tif (np->hvapi_major == 1) {\n\t\thv_err = sun4v_rng_get_diag_ctl();\n\t} else {\n\t\t \n\t\thv_err = sun4v_rng_ctl_read_v2(0UL, ~0UL, &x, &x, &x, &x);\n\t\tswitch (hv_err) {\n\t\tcase HV_EWOULDBLOCK:\n\t\tcase HV_ENOACCESS:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\thv_err = HV_EOK;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn n2rng_hv_err_trans(hv_err);\n}\n\nstatic u64 n2rng_control_default(struct n2rng *np, int ctl)\n{\n\tu64 val = 0;\n\n\tif (np->data->chip_version == 1) {\n\t\tval = ((2 << RNG_v1_CTL_ASEL_SHIFT) |\n\t\t\t(N2RNG_ACCUM_CYCLES_DEFAULT << RNG_v1_CTL_WAIT_SHIFT) |\n\t\t\t RNG_CTL_LFSR);\n\n\t\tswitch (ctl) {\n\t\tcase 0:\n\t\t\tval |= (1 << RNG_v1_CTL_VCO_SHIFT) | RNG_CTL_ES1;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tval |= (2 << RNG_v1_CTL_VCO_SHIFT) | RNG_CTL_ES2;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tval |= (3 << RNG_v1_CTL_VCO_SHIFT) | RNG_CTL_ES3;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tval |= RNG_CTL_ES1 | RNG_CTL_ES2 | RNG_CTL_ES3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t} else {\n\t\tval = ((2 << RNG_v2_CTL_ASEL_SHIFT) |\n\t\t\t(N2RNG_ACCUM_CYCLES_DEFAULT << RNG_v2_CTL_WAIT_SHIFT) |\n\t\t\t RNG_CTL_LFSR);\n\n\t\tswitch (ctl) {\n\t\tcase 0:\n\t\t\tval |= (1 << RNG_v2_CTL_VCO_SHIFT) | RNG_CTL_ES1;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tval |= (2 << RNG_v2_CTL_VCO_SHIFT) | RNG_CTL_ES2;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tval |= (3 << RNG_v2_CTL_VCO_SHIFT) | RNG_CTL_ES3;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tval |= RNG_CTL_ES1 | RNG_CTL_ES2 | RNG_CTL_ES3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn val;\n}\n\nstatic void n2rng_control_swstate_init(struct n2rng *np)\n{\n\tint i;\n\n\tnp->flags |= N2RNG_FLAG_CONTROL;\n\n\tnp->health_check_sec = N2RNG_HEALTH_CHECK_SEC_DEFAULT;\n\tnp->accum_cycles = N2RNG_ACCUM_CYCLES_DEFAULT;\n\tnp->wd_timeo = N2RNG_WD_TIMEO_DEFAULT;\n\n\tfor (i = 0; i < np->num_units; i++) {\n\t\tstruct n2rng_unit *up = &np->units[i];\n\n\t\tup->control[0] = n2rng_control_default(np, 0);\n\t\tup->control[1] = n2rng_control_default(np, 1);\n\t\tup->control[2] = n2rng_control_default(np, 2);\n\t\tup->control[3] = n2rng_control_default(np, 3);\n\t}\n\n\tnp->hv_state = HV_RNG_STATE_UNCONFIGURED;\n}\n\nstatic int n2rng_grab_diag_control(struct n2rng *np)\n{\n\tint i, busy_count, err = -ENODEV;\n\n\tbusy_count = 0;\n\tfor (i = 0; i < 100; i++) {\n\t\terr = n2rng_try_read_ctl(np);\n\t\tif (err != -EAGAIN)\n\t\t\tbreak;\n\n\t\tif (++busy_count > 100) {\n\t\t\tdev_err(&np->op->dev,\n\t\t\t\t\"Grab diag control timeout.\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tudelay(1);\n\t}\n\n\treturn err;\n}\n\nstatic int n2rng_init_control(struct n2rng *np)\n{\n\tint err = n2rng_grab_diag_control(np);\n\n\t \n\tif (err == -EPERM)\n\t\treturn 0;\n\tif (err)\n\t\treturn err;\n\n\tn2rng_control_swstate_init(np);\n\n\treturn 0;\n}\n\nstatic int n2rng_data_read(struct hwrng *rng, u32 *data)\n{\n\tstruct n2rng *np = (struct n2rng *) rng->priv;\n\tunsigned long ra = __pa(&np->test_data);\n\tint len;\n\n\tif (!(np->flags & N2RNG_FLAG_READY)) {\n\t\tlen = 0;\n\t} else if (np->flags & N2RNG_FLAG_BUFFER_VALID) {\n\t\tnp->flags &= ~N2RNG_FLAG_BUFFER_VALID;\n\t\t*data = np->buffer;\n\t\tlen = 4;\n\t} else {\n\t\tint err = n2rng_generic_read_data(ra);\n\t\tif (!err) {\n\t\t\tnp->flags |= N2RNG_FLAG_BUFFER_VALID;\n\t\t\tnp->buffer = np->test_data >> 32;\n\t\t\t*data = np->test_data & 0xffffffff;\n\t\t\tlen = 4;\n\t\t} else {\n\t\t\tdev_err(&np->op->dev, \"RNG error, retesting\\n\");\n\t\t\tnp->flags &= ~N2RNG_FLAG_READY;\n\t\t\tif (!(np->flags & N2RNG_FLAG_SHUTDOWN))\n\t\t\t\tschedule_delayed_work(&np->work, 0);\n\t\t\tlen = 0;\n\t\t}\n\t}\n\n\treturn len;\n}\n\n \nstatic int n2rng_guest_check(struct n2rng *np)\n{\n\tunsigned long ra = __pa(&np->test_data);\n\n\treturn n2rng_generic_read_data(ra);\n}\n\nstatic int n2rng_entropy_diag_read(struct n2rng *np, unsigned long unit,\n\t\t\t\t   u64 *pre_control, u64 pre_state,\n\t\t\t\t   u64 *buffer, unsigned long buf_len,\n\t\t\t\t   u64 *post_control, u64 post_state)\n{\n\tunsigned long post_ctl_ra = __pa(post_control);\n\tunsigned long pre_ctl_ra = __pa(pre_control);\n\tunsigned long buffer_ra = __pa(buffer);\n\tint err;\n\n\terr = n2rng_generic_write_control(np, pre_ctl_ra, unit, pre_state);\n\tif (err)\n\t\treturn err;\n\n\terr = n2rng_generic_read_diag_data(np, unit,\n\t\t\t\t\t   buffer_ra, buf_len);\n\n\t(void) n2rng_generic_write_control(np, post_ctl_ra, unit,\n\t\t\t\t\t   post_state);\n\n\treturn err;\n}\n\nstatic u64 advance_polynomial(u64 poly, u64 val, int count)\n{\n\tint i;\n\n\tfor (i = 0; i < count; i++) {\n\t\tint highbit_set = ((s64)val < 0);\n\n\t\tval <<= 1;\n\t\tif (highbit_set)\n\t\t\tval ^= poly;\n\t}\n\n\treturn val;\n}\n\nstatic int n2rng_test_buffer_find(struct n2rng *np, u64 val)\n{\n\tint i, count = 0;\n\n\t \n\tfor (i = 1; i < SELFTEST_BUFFER_WORDS; i++) {\n\t\tif (np->test_buffer[i] == val)\n\t\t\tcount++;\n\t}\n\treturn count;\n}\n\nstatic void n2rng_dump_test_buffer(struct n2rng *np)\n{\n\tint i;\n\n\tfor (i = 0; i < SELFTEST_BUFFER_WORDS; i++)\n\t\tdev_err(&np->op->dev, \"Test buffer slot %d [0x%016llx]\\n\",\n\t\t\ti, np->test_buffer[i]);\n}\n\nstatic int n2rng_check_selftest_buffer(struct n2rng *np, unsigned long unit)\n{\n\tu64 val;\n\tint err, matches, limit;\n\n\tswitch (np->data->id) {\n\tcase N2_n2_rng:\n\tcase N2_vf_rng:\n\tcase N2_kt_rng:\n\tcase N2_m4_rng:   \n\t\tval = RNG_v1_SELFTEST_VAL;\n\t\tbreak;\n\tdefault:\n\t\tval = RNG_v2_SELFTEST_VAL;\n\t\tbreak;\n\t}\n\n\tmatches = 0;\n\tfor (limit = 0; limit < SELFTEST_LOOPS_MAX; limit++) {\n\t\tmatches += n2rng_test_buffer_find(np, val);\n\t\tif (matches >= SELFTEST_MATCH_GOAL)\n\t\t\tbreak;\n\t\tval = advance_polynomial(SELFTEST_POLY, val, 1);\n\t}\n\n\terr = 0;\n\tif (limit >= SELFTEST_LOOPS_MAX) {\n\t\terr = -ENODEV;\n\t\tdev_err(&np->op->dev, \"Selftest failed on unit %lu\\n\", unit);\n\t\tn2rng_dump_test_buffer(np);\n\t} else\n\t\tdev_info(&np->op->dev, \"Selftest passed on unit %lu\\n\", unit);\n\n\treturn err;\n}\n\nstatic int n2rng_control_selftest(struct n2rng *np, unsigned long unit)\n{\n\tint err;\n\tu64 base, base3;\n\n\tswitch (np->data->id) {\n\tcase N2_n2_rng:\n\tcase N2_vf_rng:\n\tcase N2_kt_rng:\n\t\tbase = RNG_v1_CTL_ASEL_NOOUT << RNG_v1_CTL_ASEL_SHIFT;\n\t\tbase3 = base | RNG_CTL_LFSR |\n\t\t\t((RNG_v1_SELFTEST_TICKS - 2) << RNG_v1_CTL_WAIT_SHIFT);\n\t\tbreak;\n\tcase N2_m4_rng:\n\t\tbase = RNG_v2_CTL_ASEL_NOOUT << RNG_v2_CTL_ASEL_SHIFT;\n\t\tbase3 = base | RNG_CTL_LFSR |\n\t\t\t((RNG_v1_SELFTEST_TICKS - 2) << RNG_v2_CTL_WAIT_SHIFT);\n\t\tbreak;\n\tdefault:\n\t\tbase = RNG_v2_CTL_ASEL_NOOUT << RNG_v2_CTL_ASEL_SHIFT;\n\t\tbase3 = base | RNG_CTL_LFSR |\n\t\t\t(RNG_v2_SELFTEST_TICKS << RNG_v2_CTL_WAIT_SHIFT);\n\t\tbreak;\n\t}\n\n\tnp->test_control[0] = base;\n\tnp->test_control[1] = base;\n\tnp->test_control[2] = base;\n\tnp->test_control[3] = base3;\n\n\terr = n2rng_entropy_diag_read(np, unit, np->test_control,\n\t\t\t\t      HV_RNG_STATE_HEALTHCHECK,\n\t\t\t\t      np->test_buffer,\n\t\t\t\t      sizeof(np->test_buffer),\n\t\t\t\t      &np->units[unit].control[0],\n\t\t\t\t      np->hv_state);\n\tif (err)\n\t\treturn err;\n\n\treturn n2rng_check_selftest_buffer(np, unit);\n}\n\nstatic int n2rng_control_check(struct n2rng *np)\n{\n\tint i;\n\n\tfor (i = 0; i < np->num_units; i++) {\n\t\tint err = n2rng_control_selftest(np, i);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\n \nstatic int n2rng_control_configure_units(struct n2rng *np)\n{\n\tint unit, err;\n\n\terr = 0;\n\tfor (unit = 0; unit < np->num_units; unit++) {\n\t\tstruct n2rng_unit *up = &np->units[unit];\n\t\tunsigned long ctl_ra = __pa(&up->control[0]);\n\t\tint esrc;\n\t\tu64 base, shift;\n\n\t\tif (np->data->chip_version == 1) {\n\t\t\tbase = ((np->accum_cycles << RNG_v1_CTL_WAIT_SHIFT) |\n\t\t\t      (RNG_v1_CTL_ASEL_NOOUT << RNG_v1_CTL_ASEL_SHIFT) |\n\t\t\t      RNG_CTL_LFSR);\n\t\t\tshift = RNG_v1_CTL_VCO_SHIFT;\n\t\t} else {\n\t\t\tbase = ((np->accum_cycles << RNG_v2_CTL_WAIT_SHIFT) |\n\t\t\t      (RNG_v2_CTL_ASEL_NOOUT << RNG_v2_CTL_ASEL_SHIFT) |\n\t\t\t      RNG_CTL_LFSR);\n\t\t\tshift = RNG_v2_CTL_VCO_SHIFT;\n\t\t}\n\n\t\t \n\t\tfor (esrc = 0; esrc < 3; esrc++)\n\t\t\tup->control[esrc] = base |\n\t\t\t\t(esrc << shift) |\n\t\t\t\t(RNG_CTL_ES1 << esrc);\n\n\t\tup->control[3] = base |\n\t\t\t(RNG_CTL_ES1 | RNG_CTL_ES2 | RNG_CTL_ES3);\n\n\t\terr = n2rng_generic_write_control(np, ctl_ra, unit,\n\t\t\t\t\t\t  HV_RNG_STATE_CONFIGURED);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic void n2rng_work(struct work_struct *work)\n{\n\tstruct n2rng *np = container_of(work, struct n2rng, work.work);\n\tint err = 0;\n\tstatic int retries = 4;\n\n\tif (!(np->flags & N2RNG_FLAG_CONTROL)) {\n\t\terr = n2rng_guest_check(np);\n\t} else {\n\t\tpreempt_disable();\n\t\terr = n2rng_control_check(np);\n\t\tpreempt_enable();\n\n\t\tif (!err)\n\t\t\terr = n2rng_control_configure_units(np);\n\t}\n\n\tif (!err) {\n\t\tnp->flags |= N2RNG_FLAG_READY;\n\t\tdev_info(&np->op->dev, \"RNG ready\\n\");\n\t}\n\n\tif (--retries == 0)\n\t\tdev_err(&np->op->dev, \"Self-test retries failed, RNG not ready\\n\");\n\telse if (err && !(np->flags & N2RNG_FLAG_SHUTDOWN))\n\t\tschedule_delayed_work(&np->work, HZ * 2);\n}\n\nstatic void n2rng_driver_version(void)\n{\n\tstatic int n2rng_version_printed;\n\n\tif (n2rng_version_printed++ == 0)\n\t\tpr_info(\"%s\", version);\n}\n\nstatic const struct of_device_id n2rng_match[];\nstatic int n2rng_probe(struct platform_device *op)\n{\n\tconst struct of_device_id *match;\n\tint err = -ENOMEM;\n\tstruct n2rng *np;\n\n\tmatch = of_match_device(n2rng_match, &op->dev);\n\tif (!match)\n\t\treturn -EINVAL;\n\n\tn2rng_driver_version();\n\tnp = devm_kzalloc(&op->dev, sizeof(*np), GFP_KERNEL);\n\tif (!np)\n\t\tgoto out;\n\tnp->op = op;\n\tnp->data = (struct n2rng_template *)match->data;\n\n\tINIT_DELAYED_WORK(&np->work, n2rng_work);\n\n\tif (np->data->multi_capable)\n\t\tnp->flags |= N2RNG_FLAG_MULTI;\n\n\terr = -ENODEV;\n\tnp->hvapi_major = 2;\n\tif (sun4v_hvapi_register(HV_GRP_RNG,\n\t\t\t\t np->hvapi_major,\n\t\t\t\t &np->hvapi_minor)) {\n\t\tnp->hvapi_major = 1;\n\t\tif (sun4v_hvapi_register(HV_GRP_RNG,\n\t\t\t\t\t np->hvapi_major,\n\t\t\t\t\t &np->hvapi_minor)) {\n\t\t\tdev_err(&op->dev, \"Cannot register suitable \"\n\t\t\t\t\"HVAPI version.\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (np->flags & N2RNG_FLAG_MULTI) {\n\t\tif (np->hvapi_major < 2) {\n\t\t\tdev_err(&op->dev, \"multi-unit-capable RNG requires \"\n\t\t\t\t\"HVAPI major version 2 or later, got %lu\\n\",\n\t\t\t\tnp->hvapi_major);\n\t\t\tgoto out_hvapi_unregister;\n\t\t}\n\t\tnp->num_units = of_getintprop_default(op->dev.of_node,\n\t\t\t\t\t\t      \"rng-#units\", 0);\n\t\tif (!np->num_units) {\n\t\t\tdev_err(&op->dev, \"VF RNG lacks rng-#units property\\n\");\n\t\t\tgoto out_hvapi_unregister;\n\t\t}\n\t} else {\n\t\tnp->num_units = 1;\n\t}\n\n\tdev_info(&op->dev, \"Registered RNG HVAPI major %lu minor %lu\\n\",\n\t\t np->hvapi_major, np->hvapi_minor);\n\tnp->units = devm_kcalloc(&op->dev, np->num_units, sizeof(*np->units),\n\t\t\t\t GFP_KERNEL);\n\terr = -ENOMEM;\n\tif (!np->units)\n\t\tgoto out_hvapi_unregister;\n\n\terr = n2rng_init_control(np);\n\tif (err)\n\t\tgoto out_hvapi_unregister;\n\n\tdev_info(&op->dev, \"Found %s RNG, units: %d\\n\",\n\t\t ((np->flags & N2RNG_FLAG_MULTI) ?\n\t\t  \"multi-unit-capable\" : \"single-unit\"),\n\t\t np->num_units);\n\n\tnp->hwrng.name = DRV_MODULE_NAME;\n\tnp->hwrng.data_read = n2rng_data_read;\n\tnp->hwrng.priv = (unsigned long) np;\n\n\terr = devm_hwrng_register(&op->dev, &np->hwrng);\n\tif (err)\n\t\tgoto out_hvapi_unregister;\n\n\tplatform_set_drvdata(op, np);\n\n\tschedule_delayed_work(&np->work, 0);\n\n\treturn 0;\n\nout_hvapi_unregister:\n\tsun4v_hvapi_unregister(HV_GRP_RNG);\n\nout:\n\treturn err;\n}\n\nstatic int n2rng_remove(struct platform_device *op)\n{\n\tstruct n2rng *np = platform_get_drvdata(op);\n\n\tnp->flags |= N2RNG_FLAG_SHUTDOWN;\n\n\tcancel_delayed_work_sync(&np->work);\n\n\tsun4v_hvapi_unregister(HV_GRP_RNG);\n\n\treturn 0;\n}\n\nstatic struct n2rng_template n2_template = {\n\t.id = N2_n2_rng,\n\t.multi_capable = 0,\n\t.chip_version = 1,\n};\n\nstatic struct n2rng_template vf_template = {\n\t.id = N2_vf_rng,\n\t.multi_capable = 1,\n\t.chip_version = 1,\n};\n\nstatic struct n2rng_template kt_template = {\n\t.id = N2_kt_rng,\n\t.multi_capable = 1,\n\t.chip_version = 1,\n};\n\nstatic struct n2rng_template m4_template = {\n\t.id = N2_m4_rng,\n\t.multi_capable = 1,\n\t.chip_version = 2,\n};\n\nstatic struct n2rng_template m7_template = {\n\t.id = N2_m7_rng,\n\t.multi_capable = 1,\n\t.chip_version = 2,\n};\n\nstatic const struct of_device_id n2rng_match[] = {\n\t{\n\t\t.name\t\t= \"random-number-generator\",\n\t\t.compatible\t= \"SUNW,n2-rng\",\n\t\t.data\t\t= &n2_template,\n\t},\n\t{\n\t\t.name\t\t= \"random-number-generator\",\n\t\t.compatible\t= \"SUNW,vf-rng\",\n\t\t.data\t\t= &vf_template,\n\t},\n\t{\n\t\t.name\t\t= \"random-number-generator\",\n\t\t.compatible\t= \"SUNW,kt-rng\",\n\t\t.data\t\t= &kt_template,\n\t},\n\t{\n\t\t.name\t\t= \"random-number-generator\",\n\t\t.compatible\t= \"ORCL,m4-rng\",\n\t\t.data\t\t= &m4_template,\n\t},\n\t{\n\t\t.name\t\t= \"random-number-generator\",\n\t\t.compatible\t= \"ORCL,m7-rng\",\n\t\t.data\t\t= &m7_template,\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, n2rng_match);\n\nstatic struct platform_driver n2rng_driver = {\n\t.driver = {\n\t\t.name = \"n2rng\",\n\t\t.of_match_table = n2rng_match,\n\t},\n\t.probe\t\t= n2rng_probe,\n\t.remove\t\t= n2rng_remove,\n};\n\nmodule_platform_driver(n2rng_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}