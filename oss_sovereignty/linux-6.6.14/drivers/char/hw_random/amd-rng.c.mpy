{
  "module_name": "amd-rng.c",
  "hash_id": "83f923bed51aaf7a567e42cfab92f6fe073d872acf396930cbdc3ec71e55f2a6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/hw_random/amd-rng.c",
  "human_readable_source": " \n\n#include <linux/delay.h>\n#include <linux/hw_random.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n\n#define DRV_NAME \"AMD768-HWRNG\"\n\n#define RNGDATA\t\t0x00\n#define RNGDONE\t\t0x04\n#define PMBASE_OFFSET\t0xF0\n#define PMBASE_SIZE\t8\n\n \nstatic const struct pci_device_id pci_tbl[] = {\n\t{ PCI_VDEVICE(AMD, 0x7443), 0, },\n\t{ PCI_VDEVICE(AMD, 0x746b), 0, },\n\t{ 0, },\t \n};\nMODULE_DEVICE_TABLE(pci, pci_tbl);\n\nstruct amd768_priv {\n\tvoid __iomem *iobase;\n\tstruct pci_dev *pcidev;\n\tu32 pmbase;\n};\n\nstatic int amd_rng_read(struct hwrng *rng, void *buf, size_t max, bool wait)\n{\n\tu32 *data = buf;\n\tstruct amd768_priv *priv = (struct amd768_priv *)rng->priv;\n\tsize_t read = 0;\n\t \n\tint timeout = max / 4 + 1;\n\n\t \n\twhile (read < max) {\n\t\tif (ioread32(priv->iobase + RNGDONE) == 0) {\n\t\t\tif (wait) {\n\t\t\t\t \n\t\t\t\tusleep_range(128, 196);\n\t\t\t\tif (timeout-- == 0)\n\t\t\t\t\treturn read;\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else {\n\t\t\t*data = ioread32(priv->iobase + RNGDATA);\n\t\t\tdata++;\n\t\t\tread += 4;\n\t\t}\n\t}\n\n\treturn read;\n}\n\nstatic int amd_rng_init(struct hwrng *rng)\n{\n\tstruct amd768_priv *priv = (struct amd768_priv *)rng->priv;\n\tu8 rnen;\n\n\tpci_read_config_byte(priv->pcidev, 0x40, &rnen);\n\trnen |= BIT(7);\t \n\tpci_write_config_byte(priv->pcidev, 0x40, rnen);\n\n\tpci_read_config_byte(priv->pcidev, 0x41, &rnen);\n\trnen |= BIT(7);\t \n\tpci_write_config_byte(priv->pcidev, 0x41, rnen);\n\n\treturn 0;\n}\n\nstatic void amd_rng_cleanup(struct hwrng *rng)\n{\n\tstruct amd768_priv *priv = (struct amd768_priv *)rng->priv;\n\tu8 rnen;\n\n\tpci_read_config_byte(priv->pcidev, 0x40, &rnen);\n\trnen &= ~BIT(7);\t \n\tpci_write_config_byte(priv->pcidev, 0x40, rnen);\n}\n\nstatic struct hwrng amd_rng = {\n\t.name\t\t= \"amd\",\n\t.init\t\t= amd_rng_init,\n\t.cleanup\t= amd_rng_cleanup,\n\t.read\t\t= amd_rng_read,\n};\n\nstatic int __init amd_rng_mod_init(void)\n{\n\tint err;\n\tstruct pci_dev *pdev = NULL;\n\tconst struct pci_device_id *ent;\n\tu32 pmbase;\n\tstruct amd768_priv *priv;\n\n\tfor_each_pci_dev(pdev) {\n\t\tent = pci_match_id(pci_tbl, pdev);\n\t\tif (ent)\n\t\t\tgoto found;\n\t}\n\t \n\treturn -ENODEV;\n\nfound:\n\terr = pci_read_config_dword(pdev, 0x58, &pmbase);\n\tif (err)\n\t\tgoto put_dev;\n\n\tpmbase &= 0x0000FF00;\n\tif (pmbase == 0) {\n\t\terr = -EIO;\n\t\tgoto put_dev;\n\t}\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv) {\n\t\terr = -ENOMEM;\n\t\tgoto put_dev;\n\t}\n\n\tif (!request_region(pmbase + PMBASE_OFFSET, PMBASE_SIZE, DRV_NAME)) {\n\t\tdev_err(&pdev->dev, DRV_NAME \" region 0x%x already in use!\\n\",\n\t\t\tpmbase + 0xF0);\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tpriv->iobase = ioport_map(pmbase + PMBASE_OFFSET, PMBASE_SIZE);\n\tif (!priv->iobase) {\n\t\tpr_err(DRV_NAME \"Cannot map ioport\\n\");\n\t\terr = -EINVAL;\n\t\tgoto err_iomap;\n\t}\n\n\tamd_rng.priv = (unsigned long)priv;\n\tpriv->pmbase = pmbase;\n\tpriv->pcidev = pdev;\n\n\tpr_info(DRV_NAME \" detected\\n\");\n\terr = hwrng_register(&amd_rng);\n\tif (err) {\n\t\tpr_err(DRV_NAME \" registering failed (%d)\\n\", err);\n\t\tgoto err_hwrng;\n\t}\n\treturn 0;\n\nerr_hwrng:\n\tioport_unmap(priv->iobase);\nerr_iomap:\n\trelease_region(pmbase + PMBASE_OFFSET, PMBASE_SIZE);\nout:\n\tkfree(priv);\nput_dev:\n\tpci_dev_put(pdev);\n\treturn err;\n}\n\nstatic void __exit amd_rng_mod_exit(void)\n{\n\tstruct amd768_priv *priv;\n\n\tpriv = (struct amd768_priv *)amd_rng.priv;\n\n\thwrng_unregister(&amd_rng);\n\n\tioport_unmap(priv->iobase);\n\n\trelease_region(priv->pmbase + PMBASE_OFFSET, PMBASE_SIZE);\n\n\tpci_dev_put(priv->pcidev);\n\n\tkfree(priv);\n}\n\nmodule_init(amd_rng_mod_init);\nmodule_exit(amd_rng_mod_exit);\n\nMODULE_AUTHOR(\"The Linux Kernel team\");\nMODULE_DESCRIPTION(\"H/W RNG driver for AMD chipsets\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}