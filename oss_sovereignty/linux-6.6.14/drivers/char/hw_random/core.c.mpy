{
  "module_name": "core.c",
  "hash_id": "55d2eabb45379673cc0545625d557bf7d2c39dfab95d627fe3776d7e1df0a8f3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/hw_random/core.c",
  "human_readable_source": " \n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/fs.h>\n#include <linux/hw_random.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/miscdevice.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/sched.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\n#define RNG_MODULE_NAME\t\t\"hw_random\"\n\nstatic struct hwrng *current_rng;\n \nstatic int cur_rng_set_by_user;\nstatic struct task_struct *hwrng_fill;\n \nstatic LIST_HEAD(rng_list);\n \nstatic DEFINE_MUTEX(rng_mutex);\n \nstatic DEFINE_MUTEX(reading_mutex);\nstatic int data_avail;\nstatic u8 *rng_buffer, *rng_fillbuf;\nstatic unsigned short current_quality;\nstatic unsigned short default_quality = 1024;  \n\nmodule_param(current_quality, ushort, 0644);\nMODULE_PARM_DESC(current_quality,\n\t\t \"current hwrng entropy estimation per 1024 bits of input -- obsolete, use rng_quality instead\");\nmodule_param(default_quality, ushort, 0644);\nMODULE_PARM_DESC(default_quality,\n\t\t \"default maximum entropy content of hwrng per 1024 bits of input\");\n\nstatic void drop_current_rng(void);\nstatic int hwrng_init(struct hwrng *rng);\nstatic int hwrng_fillfn(void *unused);\n\nstatic inline int rng_get_data(struct hwrng *rng, u8 *buffer, size_t size,\n\t\t\t       int wait);\n\nstatic size_t rng_buffer_size(void)\n{\n\treturn SMP_CACHE_BYTES < 32 ? 32 : SMP_CACHE_BYTES;\n}\n\nstatic void add_early_randomness(struct hwrng *rng)\n{\n\tint bytes_read;\n\n\tmutex_lock(&reading_mutex);\n\tbytes_read = rng_get_data(rng, rng_fillbuf, 32, 0);\n\tmutex_unlock(&reading_mutex);\n\tif (bytes_read > 0) {\n\t\tsize_t entropy = bytes_read * 8 * rng->quality / 1024;\n\t\tadd_hwgenerator_randomness(rng_fillbuf, bytes_read, entropy, false);\n\t}\n}\n\nstatic inline void cleanup_rng(struct kref *kref)\n{\n\tstruct hwrng *rng = container_of(kref, struct hwrng, ref);\n\n\tif (rng->cleanup)\n\t\trng->cleanup(rng);\n\n\tcomplete(&rng->cleanup_done);\n}\n\nstatic int set_current_rng(struct hwrng *rng)\n{\n\tint err;\n\n\tBUG_ON(!mutex_is_locked(&rng_mutex));\n\n\terr = hwrng_init(rng);\n\tif (err)\n\t\treturn err;\n\n\tdrop_current_rng();\n\tcurrent_rng = rng;\n\n\t \n\tif (!hwrng_fill) {\n\t\thwrng_fill = kthread_run(hwrng_fillfn, NULL, \"hwrng\");\n\t\tif (IS_ERR(hwrng_fill)) {\n\t\t\tpr_err(\"hwrng_fill thread creation failed\\n\");\n\t\t\thwrng_fill = NULL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void drop_current_rng(void)\n{\n\tBUG_ON(!mutex_is_locked(&rng_mutex));\n\tif (!current_rng)\n\t\treturn;\n\n\t \n\tkref_put(&current_rng->ref, cleanup_rng);\n\tcurrent_rng = NULL;\n}\n\n \nstatic struct hwrng *get_current_rng_nolock(void)\n{\n\tif (current_rng)\n\t\tkref_get(&current_rng->ref);\n\n\treturn current_rng;\n}\n\nstatic struct hwrng *get_current_rng(void)\n{\n\tstruct hwrng *rng;\n\n\tif (mutex_lock_interruptible(&rng_mutex))\n\t\treturn ERR_PTR(-ERESTARTSYS);\n\n\trng = get_current_rng_nolock();\n\n\tmutex_unlock(&rng_mutex);\n\treturn rng;\n}\n\nstatic void put_rng(struct hwrng *rng)\n{\n\t \n\tmutex_lock(&rng_mutex);\n\tif (rng)\n\t\tkref_put(&rng->ref, cleanup_rng);\n\tmutex_unlock(&rng_mutex);\n}\n\nstatic int hwrng_init(struct hwrng *rng)\n{\n\tif (kref_get_unless_zero(&rng->ref))\n\t\tgoto skip_init;\n\n\tif (rng->init) {\n\t\tint ret;\n\n\t\tret =  rng->init(rng);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tkref_init(&rng->ref);\n\treinit_completion(&rng->cleanup_done);\n\nskip_init:\n\trng->quality = min_t(u16, min_t(u16, default_quality, 1024), rng->quality ?: 1024);\n\tcurrent_quality = rng->quality;  \n\n\treturn 0;\n}\n\nstatic int rng_dev_open(struct inode *inode, struct file *filp)\n{\n\t \n\tif ((filp->f_mode & FMODE_READ) == 0)\n\t\treturn -EINVAL;\n\tif (filp->f_mode & FMODE_WRITE)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic inline int rng_get_data(struct hwrng *rng, u8 *buffer, size_t size,\n\t\t\tint wait) {\n\tint present;\n\n\tBUG_ON(!mutex_is_locked(&reading_mutex));\n\tif (rng->read)\n\t\treturn rng->read(rng, (void *)buffer, size, wait);\n\n\tif (rng->data_present)\n\t\tpresent = rng->data_present(rng, wait);\n\telse\n\t\tpresent = 1;\n\n\tif (present)\n\t\treturn rng->data_read(rng, (u32 *)buffer);\n\n\treturn 0;\n}\n\nstatic ssize_t rng_dev_read(struct file *filp, char __user *buf,\n\t\t\t    size_t size, loff_t *offp)\n{\n\tssize_t ret = 0;\n\tint err = 0;\n\tint bytes_read, len;\n\tstruct hwrng *rng;\n\n\twhile (size) {\n\t\trng = get_current_rng();\n\t\tif (IS_ERR(rng)) {\n\t\t\terr = PTR_ERR(rng);\n\t\t\tgoto out;\n\t\t}\n\t\tif (!rng) {\n\t\t\terr = -ENODEV;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (mutex_lock_interruptible(&reading_mutex)) {\n\t\t\terr = -ERESTARTSYS;\n\t\t\tgoto out_put;\n\t\t}\n\t\tif (!data_avail) {\n\t\t\tbytes_read = rng_get_data(rng, rng_buffer,\n\t\t\t\trng_buffer_size(),\n\t\t\t\t!(filp->f_flags & O_NONBLOCK));\n\t\t\tif (bytes_read < 0) {\n\t\t\t\terr = bytes_read;\n\t\t\t\tgoto out_unlock_reading;\n\t\t\t}\n\t\t\tdata_avail = bytes_read;\n\t\t}\n\n\t\tif (!data_avail) {\n\t\t\tif (filp->f_flags & O_NONBLOCK) {\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tgoto out_unlock_reading;\n\t\t\t}\n\t\t} else {\n\t\t\tlen = data_avail;\n\t\t\tif (len > size)\n\t\t\t\tlen = size;\n\n\t\t\tdata_avail -= len;\n\n\t\t\tif (copy_to_user(buf + ret, rng_buffer + data_avail,\n\t\t\t\t\t\t\t\tlen)) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tgoto out_unlock_reading;\n\t\t\t}\n\n\t\t\tsize -= len;\n\t\t\tret += len;\n\t\t}\n\n\t\tmutex_unlock(&reading_mutex);\n\t\tput_rng(rng);\n\n\t\tif (need_resched())\n\t\t\tschedule_timeout_interruptible(1);\n\n\t\tif (signal_pending(current)) {\n\t\t\terr = -ERESTARTSYS;\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\treturn ret ? : err;\n\nout_unlock_reading:\n\tmutex_unlock(&reading_mutex);\nout_put:\n\tput_rng(rng);\n\tgoto out;\n}\n\nstatic const struct file_operations rng_chrdev_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= rng_dev_open,\n\t.read\t\t= rng_dev_read,\n\t.llseek\t\t= noop_llseek,\n};\n\nstatic const struct attribute_group *rng_dev_groups[];\n\nstatic struct miscdevice rng_miscdev = {\n\t.minor\t\t= HWRNG_MINOR,\n\t.name\t\t= RNG_MODULE_NAME,\n\t.nodename\t= \"hwrng\",\n\t.fops\t\t= &rng_chrdev_ops,\n\t.groups\t\t= rng_dev_groups,\n};\n\nstatic int enable_best_rng(void)\n{\n\tstruct hwrng *rng, *new_rng = NULL;\n\tint ret = -ENODEV;\n\n\tBUG_ON(!mutex_is_locked(&rng_mutex));\n\n\t \n\tif (list_empty(&rng_list)) {\n\t\tdrop_current_rng();\n\t\tcur_rng_set_by_user = 0;\n\t\treturn 0;\n\t}\n\n\t \n\tlist_for_each_entry(rng, &rng_list, list) {\n\t\tif (!new_rng || rng->quality > new_rng->quality)\n\t\t\tnew_rng = rng;\n\t}\n\n\tret = ((new_rng == current_rng) ? 0 : set_current_rng(new_rng));\n\tif (!ret)\n\t\tcur_rng_set_by_user = 0;\n\n\treturn ret;\n}\n\nstatic ssize_t rng_current_store(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t len)\n{\n\tint err;\n\tstruct hwrng *rng, *old_rng, *new_rng;\n\n\terr = mutex_lock_interruptible(&rng_mutex);\n\tif (err)\n\t\treturn -ERESTARTSYS;\n\n\told_rng = current_rng;\n\tif (sysfs_streq(buf, \"\")) {\n\t\terr = enable_best_rng();\n\t} else {\n\t\tlist_for_each_entry(rng, &rng_list, list) {\n\t\t\tif (sysfs_streq(rng->name, buf)) {\n\t\t\t\terr = set_current_rng(rng);\n\t\t\t\tif (!err)\n\t\t\t\t\tcur_rng_set_by_user = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tnew_rng = get_current_rng_nolock();\n\tmutex_unlock(&rng_mutex);\n\n\tif (new_rng) {\n\t\tif (new_rng != old_rng)\n\t\t\tadd_early_randomness(new_rng);\n\t\tput_rng(new_rng);\n\t}\n\n\treturn err ? : len;\n}\n\nstatic ssize_t rng_current_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tssize_t ret;\n\tstruct hwrng *rng;\n\n\trng = get_current_rng();\n\tif (IS_ERR(rng))\n\t\treturn PTR_ERR(rng);\n\n\tret = snprintf(buf, PAGE_SIZE, \"%s\\n\", rng ? rng->name : \"none\");\n\tput_rng(rng);\n\n\treturn ret;\n}\n\nstatic ssize_t rng_available_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  char *buf)\n{\n\tint err;\n\tstruct hwrng *rng;\n\n\terr = mutex_lock_interruptible(&rng_mutex);\n\tif (err)\n\t\treturn -ERESTARTSYS;\n\tbuf[0] = '\\0';\n\tlist_for_each_entry(rng, &rng_list, list) {\n\t\tstrlcat(buf, rng->name, PAGE_SIZE);\n\t\tstrlcat(buf, \" \", PAGE_SIZE);\n\t}\n\tstrlcat(buf, \"\\n\", PAGE_SIZE);\n\tmutex_unlock(&rng_mutex);\n\n\treturn strlen(buf);\n}\n\nstatic ssize_t rng_selected_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", cur_rng_set_by_user);\n}\n\nstatic ssize_t rng_quality_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tssize_t ret;\n\tstruct hwrng *rng;\n\n\trng = get_current_rng();\n\tif (IS_ERR(rng))\n\t\treturn PTR_ERR(rng);\n\n\tif (!rng)  \n\t\treturn -ENODEV;\n\n\tret = sysfs_emit(buf, \"%hu\\n\", rng->quality);\n\tput_rng(rng);\n\n\treturn ret;\n}\n\nstatic ssize_t rng_quality_store(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t len)\n{\n\tu16 quality;\n\tint ret = -EINVAL;\n\n\tif (len < 2)\n\t\treturn -EINVAL;\n\n\tret = mutex_lock_interruptible(&rng_mutex);\n\tif (ret)\n\t\treturn -ERESTARTSYS;\n\n\tret = kstrtou16(buf, 0, &quality);\n\tif (ret || quality > 1024) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!current_rng) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tcurrent_rng->quality = quality;\n\tcurrent_quality = quality;  \n\n\t \n\tret = enable_best_rng();\n\nout:\n\tmutex_unlock(&rng_mutex);\n\treturn ret ? ret : len;\n}\n\nstatic DEVICE_ATTR_RW(rng_current);\nstatic DEVICE_ATTR_RO(rng_available);\nstatic DEVICE_ATTR_RO(rng_selected);\nstatic DEVICE_ATTR_RW(rng_quality);\n\nstatic struct attribute *rng_dev_attrs[] = {\n\t&dev_attr_rng_current.attr,\n\t&dev_attr_rng_available.attr,\n\t&dev_attr_rng_selected.attr,\n\t&dev_attr_rng_quality.attr,\n\tNULL\n};\n\nATTRIBUTE_GROUPS(rng_dev);\n\nstatic void __exit unregister_miscdev(void)\n{\n\tmisc_deregister(&rng_miscdev);\n}\n\nstatic int __init register_miscdev(void)\n{\n\treturn misc_register(&rng_miscdev);\n}\n\nstatic int hwrng_fillfn(void *unused)\n{\n\tsize_t entropy, entropy_credit = 0;  \n\tlong rc;\n\n\twhile (!kthread_should_stop()) {\n\t\tunsigned short quality;\n\t\tstruct hwrng *rng;\n\n\t\trng = get_current_rng();\n\t\tif (IS_ERR(rng) || !rng)\n\t\t\tbreak;\n\t\tmutex_lock(&reading_mutex);\n\t\trc = rng_get_data(rng, rng_fillbuf,\n\t\t\t\t  rng_buffer_size(), 1);\n\t\tif (current_quality != rng->quality)\n\t\t\trng->quality = current_quality;  \n\t\tquality = rng->quality;\n\t\tmutex_unlock(&reading_mutex);\n\n\t\tif (rc <= 0)\n\t\t\thwrng_msleep(rng, 10000);\n\n\t\tput_rng(rng);\n\n\t\tif (rc <= 0)\n\t\t\tcontinue;\n\n\t\t \n\t\tentropy = rc * quality * 8 + entropy_credit;\n\t\tif ((entropy >> 10) == 0)\n\t\t\tentropy_credit = entropy;\n\n\t\t \n\t\tadd_hwgenerator_randomness((void *)rng_fillbuf, rc,\n\t\t\t\t\t   entropy >> 10, true);\n\t}\n\thwrng_fill = NULL;\n\treturn 0;\n}\n\nint hwrng_register(struct hwrng *rng)\n{\n\tint err = -EINVAL;\n\tstruct hwrng *tmp;\n\tbool is_new_current = false;\n\n\tif (!rng->name || (!rng->data_read && !rng->read))\n\t\tgoto out;\n\n\tmutex_lock(&rng_mutex);\n\n\t \n\terr = -EEXIST;\n\tlist_for_each_entry(tmp, &rng_list, list) {\n\t\tif (strcmp(tmp->name, rng->name) == 0)\n\t\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&rng->list, &rng_list);\n\n\tinit_completion(&rng->cleanup_done);\n\tcomplete(&rng->cleanup_done);\n\tinit_completion(&rng->dying);\n\n\tif (!current_rng ||\n\t    (!cur_rng_set_by_user && rng->quality > current_rng->quality)) {\n\t\t \n\t\terr = set_current_rng(rng);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\t\t \n\t\tis_new_current = true;\n\t\tkref_get(&rng->ref);\n\t}\n\tmutex_unlock(&rng_mutex);\n\tif (is_new_current || !rng->init) {\n\t\t \n\t\tadd_early_randomness(rng);\n\t}\n\tif (is_new_current)\n\t\tput_rng(rng);\n\treturn 0;\nout_unlock:\n\tmutex_unlock(&rng_mutex);\nout:\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(hwrng_register);\n\nvoid hwrng_unregister(struct hwrng *rng)\n{\n\tstruct hwrng *old_rng, *new_rng;\n\tint err;\n\n\tmutex_lock(&rng_mutex);\n\n\told_rng = current_rng;\n\tlist_del(&rng->list);\n\tcomplete_all(&rng->dying);\n\tif (current_rng == rng) {\n\t\terr = enable_best_rng();\n\t\tif (err) {\n\t\t\tdrop_current_rng();\n\t\t\tcur_rng_set_by_user = 0;\n\t\t}\n\t}\n\n\tnew_rng = get_current_rng_nolock();\n\tif (list_empty(&rng_list)) {\n\t\tmutex_unlock(&rng_mutex);\n\t\tif (hwrng_fill)\n\t\t\tkthread_stop(hwrng_fill);\n\t} else\n\t\tmutex_unlock(&rng_mutex);\n\n\tif (new_rng) {\n\t\tif (old_rng != new_rng)\n\t\t\tadd_early_randomness(new_rng);\n\t\tput_rng(new_rng);\n\t}\n\n\twait_for_completion(&rng->cleanup_done);\n}\nEXPORT_SYMBOL_GPL(hwrng_unregister);\n\nstatic void devm_hwrng_release(struct device *dev, void *res)\n{\n\thwrng_unregister(*(struct hwrng **)res);\n}\n\nstatic int devm_hwrng_match(struct device *dev, void *res, void *data)\n{\n\tstruct hwrng **r = res;\n\n\tif (WARN_ON(!r || !*r))\n\t\treturn 0;\n\n\treturn *r == data;\n}\n\nint devm_hwrng_register(struct device *dev, struct hwrng *rng)\n{\n\tstruct hwrng **ptr;\n\tint error;\n\n\tptr = devres_alloc(devm_hwrng_release, sizeof(*ptr), GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\n\terror = hwrng_register(rng);\n\tif (error) {\n\t\tdevres_free(ptr);\n\t\treturn error;\n\t}\n\n\t*ptr = rng;\n\tdevres_add(dev, ptr);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(devm_hwrng_register);\n\nvoid devm_hwrng_unregister(struct device *dev, struct hwrng *rng)\n{\n\tdevres_release(dev, devm_hwrng_release, devm_hwrng_match, rng);\n}\nEXPORT_SYMBOL_GPL(devm_hwrng_unregister);\n\nlong hwrng_msleep(struct hwrng *rng, unsigned int msecs)\n{\n\tunsigned long timeout = msecs_to_jiffies(msecs) + 1;\n\n\treturn wait_for_completion_interruptible_timeout(&rng->dying, timeout);\n}\nEXPORT_SYMBOL_GPL(hwrng_msleep);\n\nlong hwrng_yield(struct hwrng *rng)\n{\n\treturn wait_for_completion_interruptible_timeout(&rng->dying, 1);\n}\nEXPORT_SYMBOL_GPL(hwrng_yield);\n\nstatic int __init hwrng_modinit(void)\n{\n\tint ret;\n\n\t \n\trng_buffer = kmalloc(rng_buffer_size(), GFP_KERNEL);\n\tif (!rng_buffer)\n\t\treturn -ENOMEM;\n\n\trng_fillbuf = kmalloc(rng_buffer_size(), GFP_KERNEL);\n\tif (!rng_fillbuf) {\n\t\tkfree(rng_buffer);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = register_miscdev();\n\tif (ret) {\n\t\tkfree(rng_fillbuf);\n\t\tkfree(rng_buffer);\n\t}\n\n\treturn ret;\n}\n\nstatic void __exit hwrng_modexit(void)\n{\n\tmutex_lock(&rng_mutex);\n\tBUG_ON(current_rng);\n\tkfree(rng_buffer);\n\tkfree(rng_fillbuf);\n\tmutex_unlock(&rng_mutex);\n\n\tunregister_miscdev();\n}\n\nfs_initcall(hwrng_modinit);  \nmodule_exit(hwrng_modexit);\n\nMODULE_DESCRIPTION(\"H/W Random Number Generator (RNG) driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}