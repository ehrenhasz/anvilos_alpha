{
  "module_name": "mpfs-rng.c",
  "hash_id": "9ad826b3b4f6d01877cbb0380be4c13cffdc29b85adf2f3c8415198b8fefb920",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/hw_random/mpfs-rng.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/hw_random.h>\n#include <linux/platform_device.h>\n#include <soc/microchip/mpfs.h>\n\n#define CMD_OPCODE\t0x21\n#define CMD_DATA_SIZE\t0U\n#define CMD_DATA\tNULL\n#define MBOX_OFFSET\t0U\n#define RESP_OFFSET\t0U\n#define RNG_RESP_BYTES\t32U\n\nstruct mpfs_rng {\n\tstruct mpfs_sys_controller *sys_controller;\n\tstruct hwrng rng;\n};\n\nstatic int mpfs_rng_read(struct hwrng *rng, void *buf, size_t max, bool wait)\n{\n\tstruct mpfs_rng *rng_priv = container_of(rng, struct mpfs_rng, rng);\n\tu32 response_msg[RNG_RESP_BYTES / sizeof(u32)];\n\tunsigned int count = 0, copy_size_bytes;\n\tint ret;\n\n\tstruct mpfs_mss_response response = {\n\t\t.resp_status = 0U,\n\t\t.resp_msg = (u32 *)response_msg,\n\t\t.resp_size = RNG_RESP_BYTES\n\t};\n\tstruct mpfs_mss_msg msg = {\n\t\t.cmd_opcode = CMD_OPCODE,\n\t\t.cmd_data_size = CMD_DATA_SIZE,\n\t\t.response = &response,\n\t\t.cmd_data = CMD_DATA,\n\t\t.mbox_offset = MBOX_OFFSET,\n\t\t.resp_offset = RESP_OFFSET\n\t};\n\n\twhile (count < max) {\n\t\tret = mpfs_blocking_transaction(rng_priv->sys_controller, &msg);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tcopy_size_bytes = max - count > RNG_RESP_BYTES ? RNG_RESP_BYTES : max - count;\n\t\tmemcpy(buf + count, response_msg, copy_size_bytes);\n\n\t\tcount += copy_size_bytes;\n\t\tif (!wait)\n\t\t\tbreak;\n\t}\n\n\treturn count;\n}\n\nstatic int mpfs_rng_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct mpfs_rng *rng_priv;\n\tint ret;\n\n\trng_priv = devm_kzalloc(dev, sizeof(*rng_priv), GFP_KERNEL);\n\tif (!rng_priv)\n\t\treturn -ENOMEM;\n\n\trng_priv->sys_controller =  mpfs_sys_controller_get(&pdev->dev);\n\tif (IS_ERR(rng_priv->sys_controller))\n\t\treturn dev_err_probe(dev, PTR_ERR(rng_priv->sys_controller),\n\t\t\t\t     \"Failed to register system controller hwrng sub device\\n\");\n\n\trng_priv->rng.read = mpfs_rng_read;\n\trng_priv->rng.name = pdev->name;\n\n\tplatform_set_drvdata(pdev, rng_priv);\n\n\tret = devm_hwrng_register(&pdev->dev, &rng_priv->rng);\n\tif (ret)\n\t\treturn dev_err_probe(&pdev->dev, ret, \"Failed to register MPFS hwrng\\n\");\n\n\tdev_info(&pdev->dev, \"Registered MPFS hwrng\\n\");\n\n\treturn 0;\n}\n\nstatic struct platform_driver mpfs_rng_driver = {\n\t.driver = {\n\t\t.name = \"mpfs-rng\",\n\t},\n\t.probe = mpfs_rng_probe,\n};\nmodule_platform_driver(mpfs_rng_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Conor Dooley <conor.dooley@microchip.com>\");\nMODULE_DESCRIPTION(\"PolarFire SoC (MPFS) hardware random driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}