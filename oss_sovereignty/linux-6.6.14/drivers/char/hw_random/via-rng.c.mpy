{
  "module_name": "via-rng.c",
  "hash_id": "69bcba205240acaa617ec9c36ddc71a4b2b4fcb0d66755edb3285db9eade4f5f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/hw_random/via-rng.c",
  "human_readable_source": " \n\n#include <crypto/padlock.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/hw_random.h>\n#include <linux/delay.h>\n#include <asm/cpu_device_id.h>\n#include <asm/io.h>\n#include <asm/msr.h>\n#include <asm/cpufeature.h>\n#include <asm/fpu/api.h>\n\n\n\n\nenum {\n\tVIA_STRFILT_CNT_SHIFT\t= 16,\n\tVIA_STRFILT_FAIL\t= (1 << 15),\n\tVIA_STRFILT_ENABLE\t= (1 << 14),\n\tVIA_RAWBITS_ENABLE\t= (1 << 13),\n\tVIA_RNG_ENABLE\t\t= (1 << 6),\n\tVIA_NOISESRC1\t\t= (1 << 8),\n\tVIA_NOISESRC2\t\t= (1 << 9),\n\tVIA_XSTORE_CNT_MASK\t= 0x0F,\n\n\tVIA_RNG_CHUNK_8\t\t= 0x00,\t \n\tVIA_RNG_CHUNK_4\t\t= 0x01,\t \n\tVIA_RNG_CHUNK_4_MASK\t= 0xFFFFFFFF,\n\tVIA_RNG_CHUNK_2\t\t= 0x02,\t \n\tVIA_RNG_CHUNK_2_MASK\t= 0xFFFF,\n\tVIA_RNG_CHUNK_1\t\t= 0x03,\t \n\tVIA_RNG_CHUNK_1_MASK\t= 0xFF,\n};\n\n \n\nstatic inline u32 xstore(u32 *addr, u32 edx_in)\n{\n\tu32 eax_out;\n\n\tasm(\".byte 0x0F,0xA7,0xC0 /* xstore %%edi (addr=%0) */\"\n\t\t: \"=m\" (*addr), \"=a\" (eax_out), \"+d\" (edx_in), \"+D\" (addr));\n\n\treturn eax_out;\n}\n\nstatic int via_rng_data_present(struct hwrng *rng, int wait)\n{\n\tchar buf[16 + PADLOCK_ALIGNMENT - STACK_ALIGN] __attribute__\n\t\t((aligned(STACK_ALIGN)));\n\tu32 *via_rng_datum = (u32 *)PTR_ALIGN(&buf[0], PADLOCK_ALIGNMENT);\n\tu32 bytes_out;\n\tint i;\n\n\t \n\n\tfor (i = 0; i < 20; i++) {\n\t\t*via_rng_datum = 0;  \n\t\tbytes_out = xstore(via_rng_datum, VIA_RNG_CHUNK_1);\n\t\tbytes_out &= VIA_XSTORE_CNT_MASK;\n\t\tif (bytes_out || !wait)\n\t\t\tbreak;\n\t\tudelay(10);\n\t}\n\trng->priv = *via_rng_datum;\n\treturn bytes_out ? 1 : 0;\n}\n\nstatic int via_rng_data_read(struct hwrng *rng, u32 *data)\n{\n\tu32 via_rng_datum = (u32)rng->priv;\n\n\t*data = via_rng_datum;\n\n\treturn 1;\n}\n\nstatic int via_rng_init(struct hwrng *rng)\n{\n\tstruct cpuinfo_x86 *c = &cpu_data(0);\n\tu32 lo, hi, old_lo;\n\n\t \n\tif (((c->x86 == 6) && (c->x86_model >= 0x0f))  || (c->x86 > 6)){\n\t\tif (!boot_cpu_has(X86_FEATURE_XSTORE_EN)) {\n\t\t\tpr_err(PFX \"can't enable hardware RNG \"\n\t\t\t\t\"if XSTORE is not enabled\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t \n\trdmsr(MSR_VIA_RNG, lo, hi);\n\n\told_lo = lo;\n\tlo &= ~(0x7f << VIA_STRFILT_CNT_SHIFT);\n\tlo &= ~VIA_XSTORE_CNT_MASK;\n\tlo &= ~(VIA_STRFILT_ENABLE | VIA_STRFILT_FAIL | VIA_RAWBITS_ENABLE);\n\tlo |= VIA_RNG_ENABLE;\n\tlo |= VIA_NOISESRC1;\n\n\t \n\n\t \n\tif ((c->x86_model == 9) && (c->x86_stepping > 7))\n\t\tlo |= VIA_NOISESRC2;\n\n\t \n\tif (c->x86_model >= 10)\n\t\tlo |= VIA_NOISESRC2;\n\n\tif (lo != old_lo)\n\t\twrmsr(MSR_VIA_RNG, lo, hi);\n\n\t \n\trdmsr(MSR_VIA_RNG, lo, hi);\n\tif ((lo & VIA_RNG_ENABLE) == 0) {\n\t\tpr_err(PFX \"cannot enable VIA C3 RNG, aborting\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\n\nstatic struct hwrng via_rng = {\n\t.name\t\t= \"via\",\n\t.init\t\t= via_rng_init,\n\t.data_present\t= via_rng_data_present,\n\t.data_read\t= via_rng_data_read,\n};\n\n\nstatic int __init via_rng_mod_init(void)\n{\n\tint err;\n\n\tif (!boot_cpu_has(X86_FEATURE_XSTORE))\n\t\treturn -ENODEV;\n\n\tpr_info(\"VIA RNG detected\\n\");\n\terr = hwrng_register(&via_rng);\n\tif (err) {\n\t\tpr_err(PFX \"RNG registering failed (%d)\\n\",\n\t\t       err);\n\t\tgoto out;\n\t}\nout:\n\treturn err;\n}\nmodule_init(via_rng_mod_init);\n\nstatic void __exit via_rng_mod_exit(void)\n{\n\thwrng_unregister(&via_rng);\n}\nmodule_exit(via_rng_mod_exit);\n\nstatic struct x86_cpu_id __maybe_unused via_rng_cpu_id[] = {\n\tX86_MATCH_FEATURE(X86_FEATURE_XSTORE, NULL),\n\t{}\n};\nMODULE_DEVICE_TABLE(x86cpu, via_rng_cpu_id);\n\nMODULE_DESCRIPTION(\"H/W RNG driver for VIA CPU with PadLock\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}