{
  "module_name": "xiphera-trng.c",
  "hash_id": "b2e58dfb22ded00a1d272712a58464242cc7972cdfbbbdbdae6a88e3c716a2a9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/hw_random/xiphera-trng.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/hw_random.h>\n#include <linux/platform_device.h>\n#include <linux/delay.h>\n\n#define CONTROL_REG\t\t\t0x00000000\n#define STATUS_REG\t\t\t0x00000004\n#define RAND_REG\t\t\t0x00000000\n\n#define HOST_TO_TRNG_RESET\t\t0x00000001\n#define HOST_TO_TRNG_RELEASE_RESET\t0x00000002\n#define HOST_TO_TRNG_ENABLE\t\t0x80000000\n#define HOST_TO_TRNG_ZEROIZE\t\t0x80000004\n#define HOST_TO_TRNG_ACK_ZEROIZE\t0x80000008\n#define HOST_TO_TRNG_READ\t\t0x8000000F\n\n \n#define TRNG_ACK_RESET\t\t\t0x000000AC\n#define TRNG_SUCCESSFUL_STARTUP\t\t0x00000057\n#define TRNG_FAILED_STARTUP\t\t0x000000FA\n#define TRNG_NEW_RAND_AVAILABLE\t\t0x000000ED\n\nstruct xiphera_trng {\n\tvoid __iomem *mem;\n\tstruct hwrng rng;\n};\n\nstatic int xiphera_trng_read(struct hwrng *rng, void *buf, size_t max, bool wait)\n{\n\tstruct xiphera_trng *trng = container_of(rng, struct xiphera_trng, rng);\n\tint ret = 0;\n\n\twhile (max >= sizeof(u32)) {\n\t\t \n\t\tif (readl(trng->mem + STATUS_REG) == TRNG_NEW_RAND_AVAILABLE) {\n\t\t\t*(u32 *)buf = readl(trng->mem + RAND_REG);\n\t\t\t \n\t\t\twritel(HOST_TO_TRNG_READ, trng->mem + CONTROL_REG);\n\t\t\twritel(HOST_TO_TRNG_ENABLE, trng->mem + CONTROL_REG);\n\t\t\tret += sizeof(u32);\n\t\t\tbuf += sizeof(u32);\n\t\t\tmax -= sizeof(u32);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int xiphera_trng_probe(struct platform_device *pdev)\n{\n\tint ret;\n\tstruct xiphera_trng *trng;\n\tstruct device *dev = &pdev->dev;\n\n\ttrng = devm_kzalloc(dev, sizeof(*trng), GFP_KERNEL);\n\tif (!trng)\n\t\treturn -ENOMEM;\n\n\ttrng->mem = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(trng->mem))\n\t\treturn PTR_ERR(trng->mem);\n\n\t \n\twritel(HOST_TO_TRNG_RESET, trng->mem + CONTROL_REG);\n\tusleep_range(100, 200);\n\n\tif (readl(trng->mem + STATUS_REG) != TRNG_ACK_RESET) {\n\t\t \n\t\tusleep_range(100, 200);\n\t\tif (readl(trng->mem + STATUS_REG) != TRNG_ACK_RESET) {\n\t\t\tdev_err(dev, \"failed to reset the trng ip\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\t \n\twritel(HOST_TO_TRNG_RELEASE_RESET, trng->mem + CONTROL_REG);\n\twritel(HOST_TO_TRNG_ENABLE, trng->mem + CONTROL_REG);\n\twritel(HOST_TO_TRNG_ZEROIZE, trng->mem + CONTROL_REG);\n\tmsleep(20);\n\n\tif (readl(trng->mem + STATUS_REG) != TRNG_SUCCESSFUL_STARTUP) {\n\t\t \n\t\tif (readl(trng->mem + STATUS_REG) == TRNG_FAILED_STARTUP) {\n\t\t\tdev_err(dev, \"trng ip startup-tests failed\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tdev_err(dev, \"startup-tests yielded no response\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\twritel(HOST_TO_TRNG_ACK_ZEROIZE, trng->mem + CONTROL_REG);\n\n\ttrng->rng.name = pdev->name;\n\ttrng->rng.read = xiphera_trng_read;\n\ttrng->rng.quality = 900;\n\n\tret = devm_hwrng_register(dev, &trng->rng);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register rng device: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, trng);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id xiphera_trng_of_match[] = {\n\t{ .compatible = \"xiphera,xip8001b-trng\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, xiphera_trng_of_match);\n\nstatic struct platform_driver xiphera_trng_driver = {\n\t.driver = {\n\t\t.name = \"xiphera-trng\",\n\t\t.of_match_table\t= xiphera_trng_of_match,\n\t},\n\t.probe = xiphera_trng_probe,\n};\n\nmodule_platform_driver(xiphera_trng_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Atte Tommiska\");\nMODULE_DESCRIPTION(\"Xiphera FPGA-based true random number generator driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}