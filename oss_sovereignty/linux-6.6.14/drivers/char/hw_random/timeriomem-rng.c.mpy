{
  "module_name": "timeriomem-rng.c",
  "hash_id": "b2a0272175dbc750b1dcadaff2b6165f811317bab1087cc842a38d86aa6b1451",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/hw_random/timeriomem-rng.c",
  "human_readable_source": "\n \n\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/hrtimer.h>\n#include <linux/hw_random.h>\n#include <linux/io.h>\n#include <linux/ktime.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/timeriomem-rng.h>\n\nstruct timeriomem_rng_private {\n\tvoid __iomem\t\t*io_base;\n\tktime_t\t\t\tperiod;\n\tunsigned int\t\tpresent:1;\n\n\tstruct hrtimer\t\ttimer;\n\tstruct completion\tcompletion;\n\n\tstruct hwrng\t\trng_ops;\n};\n\nstatic int timeriomem_rng_read(struct hwrng *hwrng, void *data,\n\t\t\t\tsize_t max, bool wait)\n{\n\tstruct timeriomem_rng_private *priv =\n\t\tcontainer_of(hwrng, struct timeriomem_rng_private, rng_ops);\n\tint retval = 0;\n\tint period_us = ktime_to_us(priv->period);\n\n\t \n\tif (!wait && !priv->present)\n\t\treturn 0;\n\n\twait_for_completion(&priv->completion);\n\n\tdo {\n\t\t \n\t\tif (retval > 0)\n\t\t\tusleep_range(period_us,\n\t\t\t\t\tperiod_us + max(1, period_us / 100));\n\n\t\t*(u32 *)data = readl(priv->io_base);\n\t\tretval += sizeof(u32);\n\t\tdata += sizeof(u32);\n\t\tmax -= sizeof(u32);\n\t} while (wait && max > sizeof(u32));\n\n\t \n\tpriv->present = 0;\n\treinit_completion(&priv->completion);\n\thrtimer_forward_now(&priv->timer, priv->period);\n\thrtimer_restart(&priv->timer);\n\n\treturn retval;\n}\n\nstatic enum hrtimer_restart timeriomem_rng_trigger(struct hrtimer *timer)\n{\n\tstruct timeriomem_rng_private *priv\n\t\t= container_of(timer, struct timeriomem_rng_private, timer);\n\n\tpriv->present = 1;\n\tcomplete(&priv->completion);\n\n\treturn HRTIMER_NORESTART;\n}\n\nstatic int timeriomem_rng_probe(struct platform_device *pdev)\n{\n\tstruct timeriomem_rng_data *pdata = pdev->dev.platform_data;\n\tstruct timeriomem_rng_private *priv;\n\tstruct resource *res;\n\tint err = 0;\n\tint period;\n\n\tif (!pdev->dev.of_node && !pdata) {\n\t\tdev_err(&pdev->dev, \"timeriomem_rng_data is missing\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tpriv = devm_kzalloc(&pdev->dev,\n\t\t\tsizeof(struct timeriomem_rng_private), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tpriv->io_base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(priv->io_base))\n\t\treturn PTR_ERR(priv->io_base);\n\n\tif (res->start % 4 != 0 || resource_size(res) < 4) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"address must be at least four bytes wide and 32-bit aligned\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (pdev->dev.of_node) {\n\t\tint i;\n\n\t\tif (!of_property_read_u32(pdev->dev.of_node,\n\t\t\t\t\t\t\"period\", &i))\n\t\t\tperiod = i;\n\t\telse {\n\t\t\tdev_err(&pdev->dev, \"missing period\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!of_property_read_u32(pdev->dev.of_node,\n\t\t\t\t\t\t\"quality\", &i))\n\t\t\tpriv->rng_ops.quality = i;\n\t} else {\n\t\tperiod = pdata->period;\n\t\tpriv->rng_ops.quality = pdata->quality;\n\t}\n\n\tpriv->period = ns_to_ktime(period * NSEC_PER_USEC);\n\tinit_completion(&priv->completion);\n\thrtimer_init(&priv->timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\n\tpriv->timer.function = timeriomem_rng_trigger;\n\n\tpriv->rng_ops.name = dev_name(&pdev->dev);\n\tpriv->rng_ops.read = timeriomem_rng_read;\n\n\t \n\tpriv->present = 1;\n\tcomplete(&priv->completion);\n\n\terr = devm_hwrng_register(&pdev->dev, &priv->rng_ops);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"problem registering\\n\");\n\t\treturn err;\n\t}\n\n\tdev_info(&pdev->dev, \"32bits from 0x%p @ %dus\\n\",\n\t\t\tpriv->io_base, period);\n\n\treturn 0;\n}\n\nstatic int timeriomem_rng_remove(struct platform_device *pdev)\n{\n\tstruct timeriomem_rng_private *priv = platform_get_drvdata(pdev);\n\n\thrtimer_cancel(&priv->timer);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id timeriomem_rng_match[] = {\n\t{ .compatible = \"timeriomem_rng\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, timeriomem_rng_match);\n\nstatic struct platform_driver timeriomem_rng_driver = {\n\t.driver = {\n\t\t.name\t\t= \"timeriomem_rng\",\n\t\t.of_match_table\t= timeriomem_rng_match,\n\t},\n\t.probe\t\t= timeriomem_rng_probe,\n\t.remove\t\t= timeriomem_rng_remove,\n};\n\nmodule_platform_driver(timeriomem_rng_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Alexander Clouter <alex@digriz.org.uk>\");\nMODULE_DESCRIPTION(\"Timer IOMEM H/W RNG driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}