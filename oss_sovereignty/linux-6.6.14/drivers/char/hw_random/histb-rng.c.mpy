{
  "module_name": "histb-rng.c",
  "hash_id": "d7bfa7bee9084ea4f4b68497b6a6f1a00dddeb1101b596be7d5e15ff52df8624",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/hw_random/histb-rng.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/hw_random.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n\n#define RNG_CTRL\t\t0x0\n#define  RNG_SOURCE\t\t\tGENMASK(1, 0)\n#define  DROP_ENABLE\t\t\tBIT(5)\n#define  POST_PROCESS_ENABLE\t\tBIT(7)\n#define  POST_PROCESS_DEPTH\t\tGENMASK(15, 8)\n#define RNG_NUMBER\t\t0x4\n#define RNG_STAT\t\t0x8\n#define  DATA_COUNT\t\t\tGENMASK(2, 0)\t \n\nstruct histb_rng_priv {\n\tstruct hwrng rng;\n\tvoid __iomem *base;\n};\n\n \nstatic int histb_rng_wait(void __iomem *base)\n{\n\tu32 val;\n\n\treturn readl_relaxed_poll_timeout(base + RNG_STAT, val,\n\t\t\t\t\t  val & DATA_COUNT, 1000, 30 * 1000);\n}\n\nstatic void histb_rng_init(void __iomem *base, unsigned int depth)\n{\n\tu32 val;\n\n\tval = readl_relaxed(base + RNG_CTRL);\n\n\tval &= ~RNG_SOURCE;\n\tval |= 2;\n\n\tval &= ~POST_PROCESS_DEPTH;\n\tval |= min(depth, 0xffu) << 8;\n\n\tval |= POST_PROCESS_ENABLE;\n\tval |= DROP_ENABLE;\n\n\twritel_relaxed(val, base + RNG_CTRL);\n}\n\nstatic int histb_rng_read(struct hwrng *rng, void *data, size_t max, bool wait)\n{\n\tstruct histb_rng_priv *priv = container_of(rng, typeof(*priv), rng);\n\tvoid __iomem *base = priv->base;\n\n\tfor (int i = 0; i < max; i += sizeof(u32)) {\n\t\tif (!(readl_relaxed(base + RNG_STAT) & DATA_COUNT)) {\n\t\t\tif (!wait)\n\t\t\t\treturn i;\n\t\t\tif (histb_rng_wait(base)) {\n\t\t\t\tpr_err(\"failed to generate random number, generated %d\\n\",\n\t\t\t\t       i);\n\t\t\t\treturn i ? i : -ETIMEDOUT;\n\t\t\t}\n\t\t}\n\t\t*(u32 *) (data + i) = readl_relaxed(base + RNG_NUMBER);\n\t}\n\n\treturn max;\n}\n\nstatic unsigned int histb_rng_get_depth(void __iomem *base)\n{\n\treturn (readl_relaxed(base + RNG_CTRL) & POST_PROCESS_DEPTH) >> 8;\n}\n\nstatic ssize_t\ndepth_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct histb_rng_priv *priv = dev_get_drvdata(dev);\n\tvoid __iomem *base = priv->base;\n\n\treturn sprintf(buf, \"%d\\n\", histb_rng_get_depth(base));\n}\n\nstatic ssize_t\ndepth_store(struct device *dev, struct device_attribute *attr,\n\t    const char *buf, size_t count)\n{\n\tstruct histb_rng_priv *priv = dev_get_drvdata(dev);\n\tvoid __iomem *base = priv->base;\n\tunsigned int depth;\n\n\tif (kstrtouint(buf, 0, &depth))\n\t\treturn -ERANGE;\n\n\thistb_rng_init(base, depth);\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(depth);\n\nstatic struct attribute *histb_rng_attrs[] = {\n\t&dev_attr_depth.attr,\n\tNULL,\n};\n\nATTRIBUTE_GROUPS(histb_rng);\n\nstatic int histb_rng_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct histb_rng_priv *priv;\n\tvoid __iomem *base;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\thistb_rng_init(base, 144);\n\tif (histb_rng_wait(base)) {\n\t\tdev_err(dev, \"cannot bring up device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpriv->base = base;\n\tpriv->rng.name = pdev->name;\n\tpriv->rng.read = histb_rng_read;\n\tret = devm_hwrng_register(dev, &priv->rng);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register hwrng: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, priv);\n\tdev_set_drvdata(dev, priv);\n\treturn 0;\n}\n\nstatic const struct of_device_id histb_rng_of_match[] = {\n\t{ .compatible = \"hisilicon,histb-rng\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, histb_rng_of_match);\n\nstatic struct platform_driver histb_rng_driver = {\n\t.probe = histb_rng_probe,\n\t.driver = {\n\t\t.name = \"histb-rng\",\n\t\t.of_match_table = histb_rng_of_match,\n\t\t.dev_groups = histb_rng_groups,\n\t},\n};\n\nmodule_platform_driver(histb_rng_driver);\n\nMODULE_DESCRIPTION(\"Hisilicon STB random number generator driver\");\nMODULE_LICENSE(\"Dual MIT/GPL\");\nMODULE_AUTHOR(\"David Yang <mmyangfl@gmail.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}