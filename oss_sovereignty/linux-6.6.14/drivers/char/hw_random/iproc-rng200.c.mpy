{
  "module_name": "iproc-rng200.c",
  "hash_id": "7de71fb8f666cec5b67ab52157cd5b2c1d0793d2694205c6d30aa307d7d95053",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/hw_random/iproc-rng200.c",
  "human_readable_source": "\n \n \n\n#include <linux/hw_random.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/delay.h>\n\n \n#define RNG_CTRL_OFFSET\t\t\t\t\t0x00\n#define RNG_CTRL_RNG_RBGEN_MASK\t\t\t\t0x00001FFF\n#define RNG_CTRL_RNG_RBGEN_ENABLE\t\t\t0x00000001\n\n#define RNG_SOFT_RESET_OFFSET\t\t\t\t0x04\n#define RNG_SOFT_RESET\t\t\t\t\t0x00000001\n\n#define RBG_SOFT_RESET_OFFSET\t\t\t\t0x08\n#define RBG_SOFT_RESET\t\t\t\t\t0x00000001\n\n#define RNG_INT_STATUS_OFFSET\t\t\t\t0x18\n#define RNG_INT_STATUS_MASTER_FAIL_LOCKOUT_IRQ_MASK\t0x80000000\n#define RNG_INT_STATUS_STARTUP_TRANSITIONS_MET_IRQ_MASK\t0x00020000\n#define RNG_INT_STATUS_NIST_FAIL_IRQ_MASK\t\t0x00000020\n#define RNG_INT_STATUS_TOTAL_BITS_COUNT_IRQ_MASK\t0x00000001\n\n#define RNG_FIFO_DATA_OFFSET\t\t\t\t0x20\n\n#define RNG_FIFO_COUNT_OFFSET\t\t\t\t0x24\n#define RNG_FIFO_COUNT_RNG_FIFO_COUNT_MASK\t\t0x000000FF\n\nstruct iproc_rng200_dev {\n\tstruct hwrng rng;\n\tvoid __iomem *base;\n};\n\n#define to_rng_priv(rng)\tcontainer_of(rng, struct iproc_rng200_dev, rng)\n\nstatic void iproc_rng200_enable_set(void __iomem *rng_base, bool enable)\n{\n\tu32 val;\n\n\tval = ioread32(rng_base + RNG_CTRL_OFFSET);\n\tval &= ~RNG_CTRL_RNG_RBGEN_MASK;\n\n\tif (enable)\n\t\tval |= RNG_CTRL_RNG_RBGEN_ENABLE;\n\n\tiowrite32(val, rng_base + RNG_CTRL_OFFSET);\n}\n\nstatic void iproc_rng200_restart(void __iomem *rng_base)\n{\n\tuint32_t val;\n\n\tiproc_rng200_enable_set(rng_base, false);\n\n\t \n\tiowrite32(0xFFFFFFFFUL, rng_base + RNG_INT_STATUS_OFFSET);\n\n\t \n\tval = ioread32(rng_base + RBG_SOFT_RESET_OFFSET);\n\tval |= RBG_SOFT_RESET;\n\tiowrite32(val, rng_base + RBG_SOFT_RESET_OFFSET);\n\n\tval = ioread32(rng_base + RNG_SOFT_RESET_OFFSET);\n\tval |= RNG_SOFT_RESET;\n\tiowrite32(val, rng_base + RNG_SOFT_RESET_OFFSET);\n\n\tval = ioread32(rng_base + RNG_SOFT_RESET_OFFSET);\n\tval &= ~RNG_SOFT_RESET;\n\tiowrite32(val, rng_base + RNG_SOFT_RESET_OFFSET);\n\n\tval = ioread32(rng_base + RBG_SOFT_RESET_OFFSET);\n\tval &= ~RBG_SOFT_RESET;\n\tiowrite32(val, rng_base + RBG_SOFT_RESET_OFFSET);\n\n\tiproc_rng200_enable_set(rng_base, true);\n}\n\nstatic int iproc_rng200_read(struct hwrng *rng, void *buf, size_t max,\n\t\t\t     bool wait)\n{\n\tstruct iproc_rng200_dev *priv = to_rng_priv(rng);\n\tuint32_t num_remaining = max;\n\tuint32_t status;\n\n\t#define MAX_RESETS_PER_READ\t1\n\tuint32_t num_resets = 0;\n\n\t#define MAX_IDLE_TIME\t(1 * HZ)\n\tunsigned long idle_endtime = jiffies + MAX_IDLE_TIME;\n\n\twhile ((num_remaining > 0) && time_before(jiffies, idle_endtime)) {\n\n\t\t \n\t\tstatus = ioread32(priv->base + RNG_INT_STATUS_OFFSET);\n\t\tif ((status & (RNG_INT_STATUS_MASTER_FAIL_LOCKOUT_IRQ_MASK |\n\t\t\tRNG_INT_STATUS_NIST_FAIL_IRQ_MASK)) != 0) {\n\n\t\t\tif (num_resets >= MAX_RESETS_PER_READ)\n\t\t\t\treturn max - num_remaining;\n\n\t\t\tiproc_rng200_restart(priv->base);\n\t\t\tnum_resets++;\n\t\t}\n\n\t\t \n\t\tif ((ioread32(priv->base + RNG_FIFO_COUNT_OFFSET) &\n\t\t\t\tRNG_FIFO_COUNT_RNG_FIFO_COUNT_MASK) > 0) {\n\n\t\t\tif (num_remaining >= sizeof(uint32_t)) {\n\t\t\t\t \n\t\t\t\t*(uint32_t *)buf = ioread32(priv->base +\n\t\t\t\t\t\t\tRNG_FIFO_DATA_OFFSET);\n\t\t\t\tbuf += sizeof(uint32_t);\n\t\t\t\tnum_remaining -= sizeof(uint32_t);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tuint32_t rnd_number = ioread32(priv->base +\n\t\t\t\t\t\t\tRNG_FIFO_DATA_OFFSET);\n\t\t\t\tmemcpy(buf, &rnd_number, num_remaining);\n\t\t\t\tbuf += num_remaining;\n\t\t\t\tnum_remaining = 0;\n\t\t\t}\n\n\t\t\t \n\t\t\tidle_endtime = jiffies + MAX_IDLE_TIME;\n\t\t} else {\n\t\t\tif (!wait)\n\t\t\t\t \n\t\t\t\treturn max - num_remaining;\n\n\t\t\t \n\t\t\tusleep_range(min(num_remaining * 10, 500U), 500);\n\t\t}\n\t}\n\n\treturn max - num_remaining;\n}\n\nstatic int iproc_rng200_init(struct hwrng *rng)\n{\n\tstruct iproc_rng200_dev *priv = to_rng_priv(rng);\n\n\tiproc_rng200_enable_set(priv->base, true);\n\n\treturn 0;\n}\n\nstatic void iproc_rng200_cleanup(struct hwrng *rng)\n{\n\tstruct iproc_rng200_dev *priv = to_rng_priv(rng);\n\n\tiproc_rng200_enable_set(priv->base, false);\n}\n\nstatic int iproc_rng200_probe(struct platform_device *pdev)\n{\n\tstruct iproc_rng200_dev *priv;\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\t \n\tpriv->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->base)) {\n\t\tdev_err(dev, \"failed to remap rng regs\\n\");\n\t\treturn PTR_ERR(priv->base);\n\t}\n\n\tdev_set_drvdata(dev, priv);\n\n\tpriv->rng.name = \"iproc-rng200\";\n\tpriv->rng.read = iproc_rng200_read;\n\tpriv->rng.init = iproc_rng200_init;\n\tpriv->rng.cleanup = iproc_rng200_cleanup;\n\n\t \n\tret = devm_hwrng_register(dev, &priv->rng);\n\tif (ret) {\n\t\tdev_err(dev, \"hwrng registration failed\\n\");\n\t\treturn ret;\n\t}\n\n\tdev_info(dev, \"hwrng registered\\n\");\n\n\treturn 0;\n}\n\nstatic int __maybe_unused iproc_rng200_suspend(struct device *dev)\n{\n\tstruct iproc_rng200_dev *priv = dev_get_drvdata(dev);\n\n\tiproc_rng200_cleanup(&priv->rng);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused iproc_rng200_resume(struct device *dev)\n{\n\tstruct iproc_rng200_dev *priv =  dev_get_drvdata(dev);\n\n\tiproc_rng200_init(&priv->rng);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops iproc_rng200_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(iproc_rng200_suspend, iproc_rng200_resume)\n};\n\nstatic const struct of_device_id iproc_rng200_of_match[] = {\n\t{ .compatible = \"brcm,bcm2711-rng200\", },\n\t{ .compatible = \"brcm,bcm7211-rng200\", },\n\t{ .compatible = \"brcm,bcm7278-rng200\", },\n\t{ .compatible = \"brcm,iproc-rng200\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, iproc_rng200_of_match);\n\nstatic struct platform_driver iproc_rng200_driver = {\n\t.driver = {\n\t\t.name\t\t= \"iproc-rng200\",\n\t\t.of_match_table = iproc_rng200_of_match,\n\t\t.pm\t\t= &iproc_rng200_pm_ops,\n\t},\n\t.probe\t\t= iproc_rng200_probe,\n};\nmodule_platform_driver(iproc_rng200_driver);\n\nMODULE_AUTHOR(\"Broadcom\");\nMODULE_DESCRIPTION(\"iProc RNG200 Random Number Generator driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}