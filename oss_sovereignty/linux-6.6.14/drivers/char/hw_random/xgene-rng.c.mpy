{
  "module_name": "xgene-rng.c",
  "hash_id": "b8053f1dc5f87e1b50f249a870c307360dc90340515f398c8d419d3a4565547a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/hw_random/xgene-rng.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/hw_random.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/timer.h>\n\n#define RNG_MAX_DATUM\t\t\t4\n#define MAX_TRY\t\t\t\t100\n#define XGENE_RNG_RETRY_COUNT\t\t20\n#define XGENE_RNG_RETRY_INTERVAL\t10\n\n \n#define RNG_INOUT_0\t\t\t0x00\n#define RNG_INTR_STS_ACK\t\t0x10\n#define RNG_CONTROL\t\t\t0x14\n#define RNG_CONFIG\t\t\t0x18\n#define RNG_ALARMCNT\t\t\t0x1c\n#define RNG_FROENABLE\t\t\t0x20\n#define RNG_FRODETUNE\t\t\t0x24\n#define RNG_ALARMMASK\t\t\t0x28\n#define RNG_ALARMSTOP\t\t\t0x2c\n#define RNG_OPTIONS\t\t\t0x78\n#define RNG_EIP_REV\t\t\t0x7c\n\n#define MONOBIT_FAIL_MASK\t\tBIT(7)\n#define POKER_FAIL_MASK\t\t\tBIT(6)\n#define LONG_RUN_FAIL_MASK\t\tBIT(5)\n#define RUN_FAIL_MASK\t\t\tBIT(4)\n#define NOISE_FAIL_MASK\t\t\tBIT(3)\n#define STUCK_OUT_MASK\t\t\tBIT(2)\n#define SHUTDOWN_OFLO_MASK\t\tBIT(1)\n#define READY_MASK\t\t\tBIT(0)\n\n#define MAJOR_HW_REV_RD(src)\t\t(((src) & 0x0f000000) >> 24)\n#define MINOR_HW_REV_RD(src)\t\t(((src) & 0x00f00000) >> 20)\n#define HW_PATCH_LEVEL_RD(src)\t\t(((src) & 0x000f0000) >> 16)\n#define MAX_REFILL_CYCLES_SET(dst, src) \\\n\t\t\t((dst & ~0xffff0000) | (((u32)src << 16) & 0xffff0000))\n#define MIN_REFILL_CYCLES_SET(dst, src) \\\n\t\t\t((dst & ~0x000000ff) | (((u32)src) & 0x000000ff))\n#define ALARM_THRESHOLD_SET(dst, src) \\\n\t\t\t((dst & ~0x000000ff) | (((u32)src) & 0x000000ff))\n#define ENABLE_RNG_SET(dst, src) \\\n\t\t\t((dst & ~BIT(10)) | (((u32)src << 10) & BIT(10)))\n#define REGSPEC_TEST_MODE_SET(dst, src) \\\n\t\t\t((dst & ~BIT(8)) | (((u32)src << 8) & BIT(8)))\n#define MONOBIT_FAIL_MASK_SET(dst, src) \\\n\t\t\t((dst & ~BIT(7)) | (((u32)src << 7) & BIT(7)))\n#define POKER_FAIL_MASK_SET(dst, src) \\\n\t\t\t((dst & ~BIT(6)) | (((u32)src << 6) & BIT(6)))\n#define LONG_RUN_FAIL_MASK_SET(dst, src) \\\n\t\t\t((dst & ~BIT(5)) | (((u32)src << 5) & BIT(5)))\n#define RUN_FAIL_MASK_SET(dst, src) \\\n\t\t\t((dst & ~BIT(4)) | (((u32)src << 4) & BIT(4)))\n#define NOISE_FAIL_MASK_SET(dst, src) \\\n\t\t\t((dst & ~BIT(3)) | (((u32)src << 3) & BIT(3)))\n#define STUCK_OUT_MASK_SET(dst, src) \\\n\t\t\t((dst & ~BIT(2)) | (((u32)src << 2) & BIT(2)))\n#define SHUTDOWN_OFLO_MASK_SET(dst, src) \\\n\t\t\t((dst & ~BIT(1)) | (((u32)src << 1) & BIT(1)))\n\nstruct xgene_rng_dev {\n\tu32 irq;\n\tvoid  __iomem *csr_base;\n\tu32 revision;\n\tu32 datum_size;\n\tu32 failure_cnt;\t \n\tunsigned long failure_ts; \n\tstruct timer_list failure_timer;\n\tstruct device *dev;\n};\n\nstatic void xgene_rng_expired_timer(struct timer_list *t)\n{\n\tstruct xgene_rng_dev *ctx = from_timer(ctx, t, failure_timer);\n\n\t \n\tdisable_irq(ctx->irq);\n\tctx->failure_cnt = 0;\n\tdel_timer(&ctx->failure_timer);\n\tenable_irq(ctx->irq);\n}\n\nstatic void xgene_rng_start_timer(struct xgene_rng_dev *ctx)\n{\n\tctx->failure_timer.expires = jiffies + 120 * HZ;\n\tadd_timer(&ctx->failure_timer);\n}\n\n \nstatic void xgene_rng_init_fro(struct xgene_rng_dev *ctx, u32 fro_val)\n{\n\twritel(fro_val, ctx->csr_base + RNG_FRODETUNE);\n\twritel(0x00000000, ctx->csr_base + RNG_ALARMMASK);\n\twritel(0x00000000, ctx->csr_base + RNG_ALARMSTOP);\n\twritel(0xFFFFFFFF, ctx->csr_base + RNG_FROENABLE);\n}\n\nstatic void xgene_rng_chk_overflow(struct xgene_rng_dev *ctx)\n{\n\tu32 val;\n\n\tval = readl(ctx->csr_base + RNG_INTR_STS_ACK);\n\tif (val & MONOBIT_FAIL_MASK)\n\t\t \n\t\tdev_err(ctx->dev, \"test monobit failure error 0x%08X\\n\", val);\n\tif (val & POKER_FAIL_MASK)\n\t\t \n\t\tdev_err(ctx->dev, \"test poker failure error 0x%08X\\n\", val);\n\tif (val & LONG_RUN_FAIL_MASK)\n\t\t \n\t\tdev_err(ctx->dev, \"test long run failure error 0x%08X\\n\", val);\n\tif (val & RUN_FAIL_MASK)\n\t\t \n\t\tdev_err(ctx->dev, \"test run failure error 0x%08X\\n\", val);\n\tif (val & NOISE_FAIL_MASK)\n\t\t \n\t\tdev_err(ctx->dev, \"noise failure error 0x%08X\\n\", val);\n\tif (val & STUCK_OUT_MASK)\n\t\t \n\t\tdev_err(ctx->dev, \"stuck out failure error 0x%08X\\n\", val);\n\n\tif (val & SHUTDOWN_OFLO_MASK) {\n\t\tu32 frostopped;\n\n\t\t \n\t\tif (++ctx->failure_cnt == 1) {\n\t\t\t \n\t\t\tctx->failure_ts = jiffies;\n\t\t\tfrostopped = readl(ctx->csr_base + RNG_ALARMSTOP);\n\t\t\txgene_rng_init_fro(ctx, frostopped);\n\n\t\t\t \n\t\t\txgene_rng_start_timer(ctx);\n\t\t} else {\n\t\t\t \n\t\t\tif (time_after(ctx->failure_ts + 60 * HZ, jiffies)) {\n\t\t\t\tdev_err(ctx->dev,\n\t\t\t\t\t\"FRO shutdown failure error 0x%08X\\n\",\n\t\t\t\t\tval);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tctx->failure_ts = jiffies;\n\t\t\t\tctx->failure_cnt = 1;\n\t\t\t\t \n\t\t\t\txgene_rng_start_timer(ctx);\n\t\t\t}\n\t\t\tfrostopped = readl(ctx->csr_base + RNG_ALARMSTOP);\n\t\t\txgene_rng_init_fro(ctx, frostopped);\n\t\t}\n\t}\n\t \n\twritel(val, ctx->csr_base + RNG_INTR_STS_ACK);\n}\n\nstatic irqreturn_t xgene_rng_irq_handler(int irq, void *id)\n{\n\tstruct xgene_rng_dev *ctx = id;\n\n\t \n\txgene_rng_chk_overflow(ctx);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int xgene_rng_data_present(struct hwrng *rng, int wait)\n{\n\tstruct xgene_rng_dev *ctx = (struct xgene_rng_dev *) rng->priv;\n\tu32 i, val = 0;\n\n\tfor (i = 0; i < XGENE_RNG_RETRY_COUNT; i++) {\n\t\tval = readl(ctx->csr_base + RNG_INTR_STS_ACK);\n\t\tif ((val & READY_MASK) || !wait)\n\t\t\tbreak;\n\t\tudelay(XGENE_RNG_RETRY_INTERVAL);\n\t}\n\n\treturn (val & READY_MASK);\n}\n\nstatic int xgene_rng_data_read(struct hwrng *rng, u32 *data)\n{\n\tstruct xgene_rng_dev *ctx = (struct xgene_rng_dev *) rng->priv;\n\tint i;\n\n\tfor (i = 0; i < ctx->datum_size; i++)\n\t\tdata[i] = readl(ctx->csr_base + RNG_INOUT_0 + i * 4);\n\n\t \n\twritel(READY_MASK, ctx->csr_base + RNG_INTR_STS_ACK);\n\n\treturn ctx->datum_size << 2;\n}\n\nstatic void xgene_rng_init_internal(struct xgene_rng_dev *ctx)\n{\n\tu32 val;\n\n\twritel(0x00000000, ctx->csr_base + RNG_CONTROL);\n\n\tval = MAX_REFILL_CYCLES_SET(0, 10);\n\tval = MIN_REFILL_CYCLES_SET(val, 10);\n\twritel(val, ctx->csr_base + RNG_CONFIG);\n\n\tval = ALARM_THRESHOLD_SET(0, 0xFF);\n\twritel(val, ctx->csr_base + RNG_ALARMCNT);\n\n\txgene_rng_init_fro(ctx, 0);\n\n\twritel(MONOBIT_FAIL_MASK |\n\t\tPOKER_FAIL_MASK\t|\n\t\tLONG_RUN_FAIL_MASK |\n\t\tRUN_FAIL_MASK |\n\t\tNOISE_FAIL_MASK |\n\t\tSTUCK_OUT_MASK |\n\t\tSHUTDOWN_OFLO_MASK |\n\t\tREADY_MASK, ctx->csr_base + RNG_INTR_STS_ACK);\n\n\tval = ENABLE_RNG_SET(0, 1);\n\tval = MONOBIT_FAIL_MASK_SET(val, 1);\n\tval = POKER_FAIL_MASK_SET(val, 1);\n\tval = LONG_RUN_FAIL_MASK_SET(val, 1);\n\tval = RUN_FAIL_MASK_SET(val, 1);\n\tval = NOISE_FAIL_MASK_SET(val, 1);\n\tval = STUCK_OUT_MASK_SET(val, 1);\n\tval = SHUTDOWN_OFLO_MASK_SET(val, 1);\n\twritel(val, ctx->csr_base + RNG_CONTROL);\n}\n\nstatic int xgene_rng_init(struct hwrng *rng)\n{\n\tstruct xgene_rng_dev *ctx = (struct xgene_rng_dev *) rng->priv;\n\n\tctx->failure_cnt = 0;\n\ttimer_setup(&ctx->failure_timer, xgene_rng_expired_timer, 0);\n\n\tctx->revision = readl(ctx->csr_base + RNG_EIP_REV);\n\n\tdev_dbg(ctx->dev, \"Rev %d.%d.%d\\n\",\n\t\tMAJOR_HW_REV_RD(ctx->revision),\n\t\tMINOR_HW_REV_RD(ctx->revision),\n\t\tHW_PATCH_LEVEL_RD(ctx->revision));\n\n\tdev_dbg(ctx->dev, \"Options 0x%08X\",\n\t\treadl(ctx->csr_base + RNG_OPTIONS));\n\n\txgene_rng_init_internal(ctx);\n\n\tctx->datum_size = RNG_MAX_DATUM;\n\n\treturn 0;\n}\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id xgene_rng_acpi_match[] = {\n\t{ \"APMC0D18\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, xgene_rng_acpi_match);\n#endif\n\nstatic struct hwrng xgene_rng_func = {\n\t.name\t\t= \"xgene-rng\",\n\t.init\t\t= xgene_rng_init,\n\t.data_present\t= xgene_rng_data_present,\n\t.data_read\t= xgene_rng_data_read,\n};\n\nstatic int xgene_rng_probe(struct platform_device *pdev)\n{\n\tstruct xgene_rng_dev *ctx;\n\tstruct clk *clk;\n\tint rc = 0;\n\n\tctx = devm_kzalloc(&pdev->dev, sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, ctx);\n\n\tctx->csr_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(ctx->csr_base))\n\t\treturn PTR_ERR(ctx->csr_base);\n\n\trc = platform_get_irq(pdev, 0);\n\tif (rc < 0)\n\t\treturn rc;\n\tctx->irq = rc;\n\n\tdev_dbg(&pdev->dev, \"APM X-Gene RNG BASE %p ALARM IRQ %d\",\n\t\tctx->csr_base, ctx->irq);\n\n\trc = devm_request_irq(&pdev->dev, ctx->irq, xgene_rng_irq_handler, 0,\n\t\t\t\tdev_name(&pdev->dev), ctx);\n\tif (rc)\n\t\treturn dev_err_probe(&pdev->dev, rc, \"Could not request RNG alarm IRQ\\n\");\n\n\t \n\tclk = devm_clk_get_optional_enabled(&pdev->dev, NULL);\n\tif (IS_ERR(clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(clk), \"Couldn't get the clock for RNG\\n\");\n\n\txgene_rng_func.priv = (unsigned long) ctx;\n\n\trc = devm_hwrng_register(&pdev->dev, &xgene_rng_func);\n\tif (rc)\n\t\treturn dev_err_probe(&pdev->dev, rc, \"RNG registering failed\\n\");\n\n\trc = device_init_wakeup(&pdev->dev, 1);\n\tif (rc)\n\t\treturn dev_err_probe(&pdev->dev, rc, \"RNG device_init_wakeup failed\\n\");\n\n\treturn 0;\n}\n\nstatic int xgene_rng_remove(struct platform_device *pdev)\n{\n\tint rc;\n\n\trc = device_init_wakeup(&pdev->dev, 0);\n\tif (rc)\n\t\tdev_err(&pdev->dev, \"RNG init wakeup failed error %d\\n\", rc);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id xgene_rng_of_match[] = {\n\t{ .compatible = \"apm,xgene-rng\" },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(of, xgene_rng_of_match);\n\nstatic struct platform_driver xgene_rng_driver = {\n\t.probe = xgene_rng_probe,\n\t.remove\t= xgene_rng_remove,\n\t.driver = {\n\t\t.name\t\t= \"xgene-rng\",\n\t\t.of_match_table = xgene_rng_of_match,\n\t\t.acpi_match_table = ACPI_PTR(xgene_rng_acpi_match),\n\t},\n};\n\nmodule_platform_driver(xgene_rng_driver);\nMODULE_DESCRIPTION(\"APM X-Gene RNG driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}