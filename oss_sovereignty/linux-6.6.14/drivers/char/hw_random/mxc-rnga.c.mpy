{
  "module_name": "mxc-rnga.c",
  "hash_id": "f4963b93713dbe494adb6b13336f40767b54c979fe36da5430c3322aa8ae0597",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/hw_random/mxc-rnga.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/hw_random.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n \n#define RNGA_CONTROL\t\t\t0x00\n#define RNGA_STATUS\t\t\t0x04\n#define RNGA_ENTROPY\t\t\t0x08\n#define RNGA_OUTPUT_FIFO\t\t0x0c\n#define RNGA_MODE\t\t\t0x10\n#define RNGA_VERIFICATION_CONTROL\t0x14\n#define RNGA_OSC_CONTROL_COUNTER\t0x18\n#define RNGA_OSC1_COUNTER\t\t0x1c\n#define RNGA_OSC2_COUNTER\t\t0x20\n#define RNGA_OSC_COUNTER_STATUS\t\t0x24\n\n \n#define RNG_ADDR_RANGE\t\t\t0x28\n\n \n#define RNGA_CONTROL_SLEEP\t\t0x00000010\n#define RNGA_CONTROL_CLEAR_INT\t\t0x00000008\n#define RNGA_CONTROL_MASK_INTS\t\t0x00000004\n#define RNGA_CONTROL_HIGH_ASSURANCE\t0x00000002\n#define RNGA_CONTROL_GO\t\t\t0x00000001\n\n#define RNGA_STATUS_LEVEL_MASK\t\t0x0000ff00\n\n \n#define RNGA_STATUS_OSC_DEAD\t\t0x80000000\n#define RNGA_STATUS_SLEEP\t\t0x00000010\n#define RNGA_STATUS_ERROR_INT\t\t0x00000008\n#define RNGA_STATUS_FIFO_UNDERFLOW\t0x00000004\n#define RNGA_STATUS_LAST_READ_STATUS\t0x00000002\n#define RNGA_STATUS_SECURITY_VIOLATION\t0x00000001\n\nstruct mxc_rng {\n\tstruct device *dev;\n\tstruct hwrng rng;\n\tvoid __iomem *mem;\n\tstruct clk *clk;\n};\n\nstatic int mxc_rnga_data_present(struct hwrng *rng, int wait)\n{\n\tint i;\n\tstruct mxc_rng *mxc_rng = container_of(rng, struct mxc_rng, rng);\n\n\tfor (i = 0; i < 20; i++) {\n\t\t \n\t\tint level = (__raw_readl(mxc_rng->mem + RNGA_STATUS) &\n\t\t\t\tRNGA_STATUS_LEVEL_MASK) >> 8;\n\t\tif (level || !wait)\n\t\t\treturn !!level;\n\t\tudelay(10);\n\t}\n\treturn 0;\n}\n\nstatic int mxc_rnga_data_read(struct hwrng *rng, u32 * data)\n{\n\tint err;\n\tu32 ctrl;\n\tstruct mxc_rng *mxc_rng = container_of(rng, struct mxc_rng, rng);\n\n\t \n\t*data = __raw_readl(mxc_rng->mem + RNGA_OUTPUT_FIFO);\n\n\t \n\terr = __raw_readl(mxc_rng->mem + RNGA_STATUS) & RNGA_STATUS_ERROR_INT;\n\n\t \n\tif (err) {\n\t\tdev_dbg(mxc_rng->dev, \"Error while reading random number!\\n\");\n\t\tctrl = __raw_readl(mxc_rng->mem + RNGA_CONTROL);\n\t\t__raw_writel(ctrl | RNGA_CONTROL_CLEAR_INT,\n\t\t\t\t\tmxc_rng->mem + RNGA_CONTROL);\n\t\treturn 0;\n\t} else\n\t\treturn 4;\n}\n\nstatic int mxc_rnga_init(struct hwrng *rng)\n{\n\tu32 ctrl, osc;\n\tstruct mxc_rng *mxc_rng = container_of(rng, struct mxc_rng, rng);\n\n\t \n\tctrl = __raw_readl(mxc_rng->mem + RNGA_CONTROL);\n\t__raw_writel(ctrl & ~RNGA_CONTROL_SLEEP, mxc_rng->mem + RNGA_CONTROL);\n\n\t \n\tosc = __raw_readl(mxc_rng->mem + RNGA_STATUS);\n\tif (osc & RNGA_STATUS_OSC_DEAD) {\n\t\tdev_err(mxc_rng->dev, \"RNGA Oscillator is dead!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tctrl = __raw_readl(mxc_rng->mem + RNGA_CONTROL);\n\t__raw_writel(ctrl | RNGA_CONTROL_GO, mxc_rng->mem + RNGA_CONTROL);\n\n\treturn 0;\n}\n\nstatic void mxc_rnga_cleanup(struct hwrng *rng)\n{\n\tu32 ctrl;\n\tstruct mxc_rng *mxc_rng = container_of(rng, struct mxc_rng, rng);\n\n\tctrl = __raw_readl(mxc_rng->mem + RNGA_CONTROL);\n\n\t \n\t__raw_writel(ctrl & ~RNGA_CONTROL_GO, mxc_rng->mem + RNGA_CONTROL);\n}\n\nstatic int __init mxc_rnga_probe(struct platform_device *pdev)\n{\n\tint err;\n\tstruct mxc_rng *mxc_rng;\n\n\tmxc_rng = devm_kzalloc(&pdev->dev, sizeof(*mxc_rng), GFP_KERNEL);\n\tif (!mxc_rng)\n\t\treturn -ENOMEM;\n\n\tmxc_rng->dev = &pdev->dev;\n\tmxc_rng->rng.name = \"mxc-rnga\";\n\tmxc_rng->rng.init = mxc_rnga_init;\n\tmxc_rng->rng.cleanup = mxc_rnga_cleanup;\n\tmxc_rng->rng.data_present = mxc_rnga_data_present;\n\tmxc_rng->rng.data_read = mxc_rnga_data_read;\n\n\tmxc_rng->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(mxc_rng->clk)) {\n\t\tdev_err(&pdev->dev, \"Could not get rng_clk!\\n\");\n\t\treturn PTR_ERR(mxc_rng->clk);\n\t}\n\n\terr = clk_prepare_enable(mxc_rng->clk);\n\tif (err)\n\t\treturn err;\n\n\tmxc_rng->mem = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(mxc_rng->mem)) {\n\t\terr = PTR_ERR(mxc_rng->mem);\n\t\tgoto err_ioremap;\n\t}\n\n\terr = hwrng_register(&mxc_rng->rng);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"MXC RNGA registering failed (%d)\\n\", err);\n\t\tgoto err_ioremap;\n\t}\n\n\treturn 0;\n\nerr_ioremap:\n\tclk_disable_unprepare(mxc_rng->clk);\n\treturn err;\n}\n\nstatic int __exit mxc_rnga_remove(struct platform_device *pdev)\n{\n\tstruct mxc_rng *mxc_rng = platform_get_drvdata(pdev);\n\n\thwrng_unregister(&mxc_rng->rng);\n\n\tclk_disable_unprepare(mxc_rng->clk);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id mxc_rnga_of_match[] = {\n\t{ .compatible = \"fsl,imx21-rnga\", },\n\t{ .compatible = \"fsl,imx31-rnga\", },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, mxc_rnga_of_match);\n\nstatic struct platform_driver mxc_rnga_driver = {\n\t.driver = {\n\t\t.name = \"mxc_rnga\",\n\t\t.of_match_table = mxc_rnga_of_match,\n\t},\n\t.remove = __exit_p(mxc_rnga_remove),\n};\n\nmodule_platform_driver_probe(mxc_rnga_driver, mxc_rnga_probe);\n\nMODULE_AUTHOR(\"Freescale Semiconductor, Inc.\");\nMODULE_DESCRIPTION(\"H/W RNGA driver for i.MX\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}