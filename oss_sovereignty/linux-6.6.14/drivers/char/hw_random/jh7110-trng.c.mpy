{
  "module_name": "jh7110-trng.c",
  "hash_id": "4d3369ac62c006dccdb1c91729447198eb6689dc520a0acd223c82ef517e8d16",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/hw_random/jh7110-trng.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/hw_random.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/random.h>\n#include <linux/reset.h>\n\n \n#define STARFIVE_CTRL\t\t\t0x00\n#define STARFIVE_STAT\t\t\t0x04\n#define STARFIVE_MODE\t\t\t0x08\n#define STARFIVE_SMODE\t\t\t0x0C\n#define STARFIVE_IE\t\t\t0x10\n#define STARFIVE_ISTAT\t\t\t0x14\n#define STARFIVE_RAND0\t\t\t0x20\n#define STARFIVE_RAND1\t\t\t0x24\n#define STARFIVE_RAND2\t\t\t0x28\n#define STARFIVE_RAND3\t\t\t0x2C\n#define STARFIVE_RAND4\t\t\t0x30\n#define STARFIVE_RAND5\t\t\t0x34\n#define STARFIVE_RAND6\t\t\t0x38\n#define STARFIVE_RAND7\t\t\t0x3C\n#define STARFIVE_AUTO_RQSTS\t\t0x60\n#define STARFIVE_AUTO_AGE\t\t0x64\n\n \n#define STARFIVE_CTRL_EXEC_NOP\t\t0x0\n#define STARFIVE_CTRL_GENE_RANDNUM\t0x1\n#define STARFIVE_CTRL_EXEC_RANDRESEED\t0x2\n\n \n#define STARFIVE_STAT_NONCE_MODE\tBIT(2)\n#define STARFIVE_STAT_R256\t\tBIT(3)\n#define STARFIVE_STAT_MISSION_MODE\tBIT(8)\n#define STARFIVE_STAT_SEEDED\t\tBIT(9)\n#define STARFIVE_STAT_LAST_RESEED(x)\t((x) << 16)\n#define STARFIVE_STAT_SRVC_RQST\t\tBIT(27)\n#define STARFIVE_STAT_RAND_GENERATING\tBIT(30)\n#define STARFIVE_STAT_RAND_SEEDING\tBIT(31)\n\n \n#define STARFIVE_MODE_R256\t\tBIT(3)\n\n \n#define STARFIVE_SMODE_NONCE_MODE\tBIT(2)\n#define STARFIVE_SMODE_MISSION_MODE\tBIT(8)\n#define STARFIVE_SMODE_MAX_REJECTS(x)\t((x) << 16)\n\n \n#define STARFIVE_IE_RAND_RDY_EN\t\tBIT(0)\n#define STARFIVE_IE_SEED_DONE_EN\tBIT(1)\n#define STARFIVE_IE_LFSR_LOCKUP_EN\tBIT(4)\n#define STARFIVE_IE_GLBL_EN\t\tBIT(31)\n\n#define STARFIVE_IE_ALL\t\t\t(STARFIVE_IE_GLBL_EN | \\\n\t\t\t\t\t STARFIVE_IE_RAND_RDY_EN | \\\n\t\t\t\t\t STARFIVE_IE_SEED_DONE_EN | \\\n\t\t\t\t\t STARFIVE_IE_LFSR_LOCKUP_EN)\n\n \n#define STARFIVE_ISTAT_RAND_RDY\t\tBIT(0)\n#define STARFIVE_ISTAT_SEED_DONE\tBIT(1)\n#define STARFIVE_ISTAT_LFSR_LOCKUP\tBIT(4)\n\n#define STARFIVE_RAND_LEN\t\tsizeof(u32)\n\n#define to_trng(p)\t\t\tcontainer_of(p, struct starfive_trng, rng)\n\nenum reseed {\n\tRANDOM_RESEED,\n\tNONCE_RESEED,\n};\n\nenum mode {\n\tPRNG_128BIT,\n\tPRNG_256BIT,\n};\n\nstruct starfive_trng {\n\tstruct device\t\t*dev;\n\tvoid __iomem\t\t*base;\n\tstruct clk\t\t*hclk;\n\tstruct clk\t\t*ahb;\n\tstruct reset_control\t*rst;\n\tstruct hwrng\t\trng;\n\tstruct completion\trandom_done;\n\tstruct completion\treseed_done;\n\tu32\t\t\tmode;\n\tu32\t\t\tmission;\n\tu32\t\t\treseed;\n\t \n\tspinlock_t\t\twrite_lock;\n};\n\nstatic u16 autoreq;\nmodule_param(autoreq, ushort, 0);\nMODULE_PARM_DESC(autoreq, \"Auto-reseeding after random number requests by host reaches specified counter:\\n\"\n\t\t\t\t\" 0 - disable counter\\n\"\n\t\t\t\t\" other - reload value for internal counter\");\n\nstatic u16 autoage;\nmodule_param(autoage, ushort, 0);\nMODULE_PARM_DESC(autoage, \"Auto-reseeding after specified timer countdowns to 0:\\n\"\n\t\t\t\t\" 0 - disable timer\\n\"\n\t\t\t\t\" other - reload value for internal timer\");\n\nstatic inline int starfive_trng_wait_idle(struct starfive_trng *trng)\n{\n\tu32 stat;\n\n\treturn readl_relaxed_poll_timeout(trng->base + STARFIVE_STAT, stat,\n\t\t\t\t\t  !(stat & (STARFIVE_STAT_RAND_GENERATING |\n\t\t\t\t\t\t    STARFIVE_STAT_RAND_SEEDING)),\n\t\t\t\t\t  10, 100000);\n}\n\nstatic inline void starfive_trng_irq_mask_clear(struct starfive_trng *trng)\n{\n\t \n\tu32 data = readl(trng->base + STARFIVE_ISTAT);\n\n\twritel(data, trng->base + STARFIVE_ISTAT);\n}\n\nstatic int starfive_trng_cmd(struct starfive_trng *trng, u32 cmd, bool wait)\n{\n\tint wait_time = 1000;\n\n\t \n\tif (!wait)\n\t\twait_time = 40;\n\n\tswitch (cmd) {\n\tcase STARFIVE_CTRL_GENE_RANDNUM:\n\t\treinit_completion(&trng->random_done);\n\t\tspin_lock_irq(&trng->write_lock);\n\t\twritel(cmd, trng->base + STARFIVE_CTRL);\n\t\tspin_unlock_irq(&trng->write_lock);\n\t\tif (!wait_for_completion_timeout(&trng->random_done, usecs_to_jiffies(wait_time)))\n\t\t\treturn -ETIMEDOUT;\n\t\tbreak;\n\tcase STARFIVE_CTRL_EXEC_RANDRESEED:\n\t\treinit_completion(&trng->reseed_done);\n\t\tspin_lock_irq(&trng->write_lock);\n\t\twritel(cmd, trng->base + STARFIVE_CTRL);\n\t\tspin_unlock_irq(&trng->write_lock);\n\t\tif (!wait_for_completion_timeout(&trng->reseed_done, usecs_to_jiffies(wait_time)))\n\t\t\treturn -ETIMEDOUT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int starfive_trng_init(struct hwrng *rng)\n{\n\tstruct starfive_trng *trng = to_trng(rng);\n\tu32 mode, intr = 0;\n\n\t \n\twritel(autoage, trng->base + STARFIVE_AUTO_AGE);\n\twritel(autoreq, trng->base + STARFIVE_AUTO_RQSTS);\n\n\t \n\tstarfive_trng_irq_mask_clear(trng);\n\n\tintr |= STARFIVE_IE_ALL;\n\twritel(intr, trng->base + STARFIVE_IE);\n\n\tmode  = readl(trng->base + STARFIVE_MODE);\n\n\tswitch (trng->mode) {\n\tcase PRNG_128BIT:\n\t\tmode &= ~STARFIVE_MODE_R256;\n\t\tbreak;\n\tcase PRNG_256BIT:\n\t\tmode |= STARFIVE_MODE_R256;\n\t\tbreak;\n\tdefault:\n\t\tmode |= STARFIVE_MODE_R256;\n\t\tbreak;\n\t}\n\n\twritel(mode, trng->base + STARFIVE_MODE);\n\n\treturn starfive_trng_cmd(trng, STARFIVE_CTRL_EXEC_RANDRESEED, 1);\n}\n\nstatic irqreturn_t starfive_trng_irq(int irq, void *priv)\n{\n\tu32 status;\n\tstruct starfive_trng *trng = (struct starfive_trng *)priv;\n\n\tstatus = readl(trng->base + STARFIVE_ISTAT);\n\tif (status & STARFIVE_ISTAT_RAND_RDY) {\n\t\twritel(STARFIVE_ISTAT_RAND_RDY, trng->base + STARFIVE_ISTAT);\n\t\tcomplete(&trng->random_done);\n\t}\n\n\tif (status & STARFIVE_ISTAT_SEED_DONE) {\n\t\twritel(STARFIVE_ISTAT_SEED_DONE, trng->base + STARFIVE_ISTAT);\n\t\tcomplete(&trng->reseed_done);\n\t}\n\n\tif (status & STARFIVE_ISTAT_LFSR_LOCKUP) {\n\t\twritel(STARFIVE_ISTAT_LFSR_LOCKUP, trng->base + STARFIVE_ISTAT);\n\t\t \n\t\tspin_lock(&trng->write_lock);\n\t\twritel(STARFIVE_CTRL_EXEC_RANDRESEED, trng->base + STARFIVE_CTRL);\n\t\tspin_unlock(&trng->write_lock);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void starfive_trng_cleanup(struct hwrng *rng)\n{\n\tstruct starfive_trng *trng = to_trng(rng);\n\n\twritel(0, trng->base + STARFIVE_CTRL);\n\n\treset_control_assert(trng->rst);\n\tclk_disable_unprepare(trng->hclk);\n\tclk_disable_unprepare(trng->ahb);\n}\n\nstatic int starfive_trng_read(struct hwrng *rng, void *buf, size_t max, bool wait)\n{\n\tstruct starfive_trng *trng = to_trng(rng);\n\tint ret;\n\n\tpm_runtime_get_sync(trng->dev);\n\n\tif (trng->mode == PRNG_256BIT)\n\t\tmax = min_t(size_t, max, (STARFIVE_RAND_LEN * 8));\n\telse\n\t\tmax = min_t(size_t, max, (STARFIVE_RAND_LEN * 4));\n\n\tif (wait) {\n\t\tret = starfive_trng_wait_idle(trng);\n\t\tif (ret)\n\t\t\treturn -ETIMEDOUT;\n\t}\n\n\tret = starfive_trng_cmd(trng, STARFIVE_CTRL_GENE_RANDNUM, wait);\n\tif (ret)\n\t\treturn ret;\n\n\tmemcpy_fromio(buf, trng->base + STARFIVE_RAND0, max);\n\n\tpm_runtime_put_sync_autosuspend(trng->dev);\n\n\treturn max;\n}\n\nstatic int starfive_trng_probe(struct platform_device *pdev)\n{\n\tint ret;\n\tint irq;\n\tstruct starfive_trng *trng;\n\n\ttrng = devm_kzalloc(&pdev->dev, sizeof(*trng), GFP_KERNEL);\n\tif (!trng)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, trng);\n\ttrng->dev = &pdev->dev;\n\n\ttrng->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(trng->base))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(trng->base),\n\t\t\t\t     \"Error remapping memory for platform device.\\n\");\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tinit_completion(&trng->random_done);\n\tinit_completion(&trng->reseed_done);\n\tspin_lock_init(&trng->write_lock);\n\n\tret = devm_request_irq(&pdev->dev, irq, starfive_trng_irq, 0, pdev->name,\n\t\t\t       (void *)trng);\n\tif (ret)\n\t\treturn dev_err_probe(&pdev->dev, irq,\n\t\t\t\t     \"Failed to register interrupt handler\\n\");\n\n\ttrng->hclk = devm_clk_get(&pdev->dev, \"hclk\");\n\tif (IS_ERR(trng->hclk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(trng->hclk),\n\t\t\t\t     \"Error getting hardware reference clock\\n\");\n\n\ttrng->ahb = devm_clk_get(&pdev->dev, \"ahb\");\n\tif (IS_ERR(trng->ahb))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(trng->ahb),\n\t\t\t\t     \"Error getting ahb reference clock\\n\");\n\n\ttrng->rst = devm_reset_control_get_shared(&pdev->dev, NULL);\n\tif (IS_ERR(trng->rst))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(trng->rst),\n\t\t\t\t     \"Error getting hardware reset line\\n\");\n\n\tclk_prepare_enable(trng->hclk);\n\tclk_prepare_enable(trng->ahb);\n\treset_control_deassert(trng->rst);\n\n\ttrng->rng.name = dev_driver_string(&pdev->dev);\n\ttrng->rng.init = starfive_trng_init;\n\ttrng->rng.cleanup = starfive_trng_cleanup;\n\ttrng->rng.read = starfive_trng_read;\n\n\ttrng->mode = PRNG_256BIT;\n\ttrng->mission = 1;\n\ttrng->reseed = RANDOM_RESEED;\n\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\tpm_runtime_set_autosuspend_delay(&pdev->dev, 100);\n\tpm_runtime_enable(&pdev->dev);\n\n\tret = devm_hwrng_register(&pdev->dev, &trng->rng);\n\tif (ret) {\n\t\tpm_runtime_disable(&pdev->dev);\n\n\t\treset_control_assert(trng->rst);\n\t\tclk_disable_unprepare(trng->ahb);\n\t\tclk_disable_unprepare(trng->hclk);\n\n\t\treturn dev_err_probe(&pdev->dev, ret, \"Failed to register hwrng\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused starfive_trng_suspend(struct device *dev)\n{\n\tstruct starfive_trng *trng = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(trng->hclk);\n\tclk_disable_unprepare(trng->ahb);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused starfive_trng_resume(struct device *dev)\n{\n\tstruct starfive_trng *trng = dev_get_drvdata(dev);\n\n\tclk_prepare_enable(trng->hclk);\n\tclk_prepare_enable(trng->ahb);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(starfive_trng_pm_ops, starfive_trng_suspend,\n\t\t\t\tstarfive_trng_resume);\n\nstatic const struct of_device_id trng_dt_ids[] __maybe_unused = {\n\t{ .compatible = \"starfive,jh7110-trng\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, trng_dt_ids);\n\nstatic struct platform_driver starfive_trng_driver = {\n\t.probe\t= starfive_trng_probe,\n\t.driver\t= {\n\t\t.name\t\t= \"jh7110-trng\",\n\t\t.pm\t\t= &starfive_trng_pm_ops,\n\t\t.of_match_table\t= of_match_ptr(trng_dt_ids),\n\t},\n};\n\nmodule_platform_driver(starfive_trng_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"StarFive True Random Number Generator\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}