{
  "module_name": "ps3flash.c",
  "hash_id": "cece68d14e71f07bcf66836a19a08cb05bdcf8dfc784066ecaecb62ce3546ff6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/ps3flash.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/miscdevice.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\n#include <asm/lv1call.h>\n#include <asm/ps3stor.h>\n\n\n#define DEVICE_NAME\t\t\"ps3flash\"\n\n#define FLASH_BLOCK_SIZE\t(256*1024)\n\n\nstruct ps3flash_private {\n\tstruct mutex mutex;\t \n\tu64 chunk_sectors;\n\tint tag;\t\t \n\tbool dirty;\n};\n\nstatic struct ps3_storage_device *ps3flash_dev;\n\nstatic int ps3flash_read_write_sectors(struct ps3_storage_device *dev,\n\t\t\t\t       u64 start_sector, int write)\n{\n\tstruct ps3flash_private *priv = ps3_system_bus_get_drvdata(&dev->sbd);\n\tu64 res = ps3stor_read_write_sectors(dev, dev->bounce_lpar,\n\t\t\t\t\t     start_sector, priv->chunk_sectors,\n\t\t\t\t\t     write);\n\tif (res) {\n\t\tdev_err(&dev->sbd.core, \"%s:%u: %s failed 0x%llx\\n\", __func__,\n\t\t\t__LINE__, write ? \"write\" : \"read\", res);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic int ps3flash_writeback(struct ps3_storage_device *dev)\n{\n\tstruct ps3flash_private *priv = ps3_system_bus_get_drvdata(&dev->sbd);\n\tint res;\n\n\tif (!priv->dirty || priv->tag < 0)\n\t\treturn 0;\n\n\tres = ps3flash_read_write_sectors(dev, priv->tag, 1);\n\tif (res)\n\t\treturn res;\n\n\tpriv->dirty = false;\n\treturn 0;\n}\n\nstatic int ps3flash_fetch(struct ps3_storage_device *dev, u64 start_sector)\n{\n\tstruct ps3flash_private *priv = ps3_system_bus_get_drvdata(&dev->sbd);\n\tint res;\n\n\tif (start_sector == priv->tag)\n\t\treturn 0;\n\n\tres = ps3flash_writeback(dev);\n\tif (res)\n\t\treturn res;\n\n\tpriv->tag = -1;\n\n\tres = ps3flash_read_write_sectors(dev, start_sector, 0);\n\tif (res)\n\t\treturn res;\n\n\tpriv->tag = start_sector;\n\treturn 0;\n}\n\nstatic loff_t ps3flash_llseek(struct file *file, loff_t offset, int origin)\n{\n\tstruct ps3_storage_device *dev = ps3flash_dev;\n\treturn generic_file_llseek_size(file, offset, origin, MAX_LFS_FILESIZE,\n\t\t\tdev->regions[dev->region_idx].size*dev->blk_size);\n}\n\nstatic ssize_t ps3flash_read(char __user *userbuf, void *kernelbuf,\n\t\t\t     size_t count, loff_t *pos)\n{\n\tstruct ps3_storage_device *dev = ps3flash_dev;\n\tstruct ps3flash_private *priv = ps3_system_bus_get_drvdata(&dev->sbd);\n\tu64 size, sector, offset;\n\tint res;\n\tsize_t remaining, n;\n\tconst void *src;\n\n\tdev_dbg(&dev->sbd.core,\n\t\t\"%s:%u: Reading %zu bytes at position %lld to U0x%p/K0x%p\\n\",\n\t\t__func__, __LINE__, count, *pos, userbuf, kernelbuf);\n\n\tsize = dev->regions[dev->region_idx].size*dev->blk_size;\n\tif (*pos >= size || !count)\n\t\treturn 0;\n\n\tif (*pos + count > size) {\n\t\tdev_dbg(&dev->sbd.core,\n\t\t\t\"%s:%u Truncating count from %zu to %llu\\n\", __func__,\n\t\t\t__LINE__, count, size - *pos);\n\t\tcount = size - *pos;\n\t}\n\n\tsector = *pos / dev->bounce_size * priv->chunk_sectors;\n\toffset = *pos % dev->bounce_size;\n\n\tremaining = count;\n\tdo {\n\t\tn = min_t(u64, remaining, dev->bounce_size - offset);\n\t\tsrc = dev->bounce_buf + offset;\n\n\t\tmutex_lock(&priv->mutex);\n\n\t\tres = ps3flash_fetch(dev, sector);\n\t\tif (res)\n\t\t\tgoto fail;\n\n\t\tdev_dbg(&dev->sbd.core,\n\t\t\t\"%s:%u: copy %lu bytes from 0x%p to U0x%p/K0x%p\\n\",\n\t\t\t__func__, __LINE__, n, src, userbuf, kernelbuf);\n\t\tif (userbuf) {\n\t\t\tif (copy_to_user(userbuf, src, n)) {\n\t\t\t\tres = -EFAULT;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tuserbuf += n;\n\t\t}\n\t\tif (kernelbuf) {\n\t\t\tmemcpy(kernelbuf, src, n);\n\t\t\tkernelbuf += n;\n\t\t}\n\n\t\tmutex_unlock(&priv->mutex);\n\n\t\t*pos += n;\n\t\tremaining -= n;\n\t\tsector += priv->chunk_sectors;\n\t\toffset = 0;\n\t} while (remaining > 0);\n\n\treturn count;\n\nfail:\n\tmutex_unlock(&priv->mutex);\n\treturn res;\n}\n\nstatic ssize_t ps3flash_write(const char __user *userbuf,\n\t\t\t      const void *kernelbuf, size_t count, loff_t *pos)\n{\n\tstruct ps3_storage_device *dev = ps3flash_dev;\n\tstruct ps3flash_private *priv = ps3_system_bus_get_drvdata(&dev->sbd);\n\tu64 size, sector, offset;\n\tint res = 0;\n\tsize_t remaining, n;\n\tvoid *dst;\n\n\tdev_dbg(&dev->sbd.core,\n\t\t\"%s:%u: Writing %zu bytes at position %lld from U0x%p/K0x%p\\n\",\n\t\t__func__, __LINE__, count, *pos, userbuf, kernelbuf);\n\n\tsize = dev->regions[dev->region_idx].size*dev->blk_size;\n\tif (*pos >= size || !count)\n\t\treturn 0;\n\n\tif (*pos + count > size) {\n\t\tdev_dbg(&dev->sbd.core,\n\t\t\t\"%s:%u Truncating count from %zu to %llu\\n\", __func__,\n\t\t\t__LINE__, count, size - *pos);\n\t\tcount = size - *pos;\n\t}\n\n\tsector = *pos / dev->bounce_size * priv->chunk_sectors;\n\toffset = *pos % dev->bounce_size;\n\n\tremaining = count;\n\tdo {\n\t\tn = min_t(u64, remaining, dev->bounce_size - offset);\n\t\tdst = dev->bounce_buf + offset;\n\n\t\tmutex_lock(&priv->mutex);\n\n\t\tif (n != dev->bounce_size)\n\t\t\tres = ps3flash_fetch(dev, sector);\n\t\telse if (sector != priv->tag)\n\t\t\tres = ps3flash_writeback(dev);\n\t\tif (res)\n\t\t\tgoto fail;\n\n\t\tdev_dbg(&dev->sbd.core,\n\t\t\t\"%s:%u: copy %lu bytes from U0x%p/K0x%p to 0x%p\\n\",\n\t\t\t__func__, __LINE__, n, userbuf, kernelbuf, dst);\n\t\tif (userbuf) {\n\t\t\tif (copy_from_user(dst, userbuf, n)) {\n\t\t\t\tres = -EFAULT;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tuserbuf += n;\n\t\t}\n\t\tif (kernelbuf) {\n\t\t\tmemcpy(dst, kernelbuf, n);\n\t\t\tkernelbuf += n;\n\t\t}\n\n\t\tpriv->tag = sector;\n\t\tpriv->dirty = true;\n\n\t\tmutex_unlock(&priv->mutex);\n\n\t\t*pos += n;\n\t\tremaining -= n;\n\t\tsector += priv->chunk_sectors;\n\t\toffset = 0;\n\t} while (remaining > 0);\n\n\treturn count;\n\nfail:\n\tmutex_unlock(&priv->mutex);\n\treturn res;\n}\n\nstatic ssize_t ps3flash_user_read(struct file *file, char __user *buf,\n\t\t\t\t  size_t count, loff_t *pos)\n{\n\treturn ps3flash_read(buf, NULL, count, pos);\n}\n\nstatic ssize_t ps3flash_user_write(struct file *file, const char __user *buf,\n\t\t\t\t   size_t count, loff_t *pos)\n{\n\treturn ps3flash_write(buf, NULL, count, pos);\n}\n\nstatic ssize_t ps3flash_kernel_read(void *buf, size_t count, loff_t pos)\n{\n\treturn ps3flash_read(NULL, buf, count, &pos);\n}\n\nstatic ssize_t ps3flash_kernel_write(const void *buf, size_t count,\n\t\t\t\t     loff_t pos)\n{\n\tssize_t res;\n\tint wb;\n\n\tres = ps3flash_write(NULL, buf, count, &pos);\n\tif (res < 0)\n\t\treturn res;\n\n\t \n\twb = ps3flash_writeback(ps3flash_dev);\n\tif (wb)\n\t\treturn wb;\n\n\treturn res;\n}\n\nstatic int ps3flash_flush(struct file *file, fl_owner_t id)\n{\n\treturn ps3flash_writeback(ps3flash_dev);\n}\n\nstatic int ps3flash_fsync(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tstruct inode *inode = file_inode(file);\n\tint err;\n\tinode_lock(inode);\n\terr = ps3flash_writeback(ps3flash_dev);\n\tinode_unlock(inode);\n\treturn err;\n}\n\nstatic irqreturn_t ps3flash_interrupt(int irq, void *data)\n{\n\tstruct ps3_storage_device *dev = data;\n\tint res;\n\tu64 tag, status;\n\n\tres = lv1_storage_get_async_status(dev->sbd.dev_id, &tag, &status);\n\n\tif (tag != dev->tag)\n\t\tdev_err(&dev->sbd.core,\n\t\t\t\"%s:%u: tag mismatch, got %llx, expected %llx\\n\",\n\t\t\t__func__, __LINE__, tag, dev->tag);\n\n\tif (res) {\n\t\tdev_err(&dev->sbd.core, \"%s:%u: res=%d status=0x%llx\\n\",\n\t\t\t__func__, __LINE__, res, status);\n\t} else {\n\t\tdev->lv1_status = status;\n\t\tcomplete(&dev->done);\n\t}\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct file_operations ps3flash_fops = {\n\t.owner\t= THIS_MODULE,\n\t.llseek\t= ps3flash_llseek,\n\t.read\t= ps3flash_user_read,\n\t.write\t= ps3flash_user_write,\n\t.flush\t= ps3flash_flush,\n\t.fsync\t= ps3flash_fsync,\n};\n\nstatic const struct ps3_os_area_flash_ops ps3flash_kernel_ops = {\n\t.read\t= ps3flash_kernel_read,\n\t.write\t= ps3flash_kernel_write,\n};\n\nstatic struct miscdevice ps3flash_misc = {\n\t.minor\t= MISC_DYNAMIC_MINOR,\n\t.name\t= DEVICE_NAME,\n\t.fops\t= &ps3flash_fops,\n};\n\nstatic int ps3flash_probe(struct ps3_system_bus_device *_dev)\n{\n\tstruct ps3_storage_device *dev = to_ps3_storage_device(&_dev->core);\n\tstruct ps3flash_private *priv;\n\tint error;\n\tunsigned long tmp;\n\n\ttmp = dev->regions[dev->region_idx].start*dev->blk_size;\n\tif (tmp % FLASH_BLOCK_SIZE) {\n\t\tdev_err(&dev->sbd.core,\n\t\t\t\"%s:%u region start %lu is not aligned\\n\", __func__,\n\t\t\t__LINE__, tmp);\n\t\treturn -EINVAL;\n\t}\n\ttmp = dev->regions[dev->region_idx].size*dev->blk_size;\n\tif (tmp % FLASH_BLOCK_SIZE) {\n\t\tdev_err(&dev->sbd.core,\n\t\t\t\"%s:%u region size %lu is not aligned\\n\", __func__,\n\t\t\t__LINE__, tmp);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!ps3flash_bounce_buffer.address)\n\t\treturn -ENODEV;\n\n\tif (ps3flash_dev) {\n\t\tdev_err(&dev->sbd.core,\n\t\t\t\"Only one FLASH device is supported\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tps3flash_dev = dev;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv) {\n\t\terror = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tps3_system_bus_set_drvdata(&dev->sbd, priv);\n\tmutex_init(&priv->mutex);\n\tpriv->tag = -1;\n\n\tdev->bounce_size = ps3flash_bounce_buffer.size;\n\tdev->bounce_buf = ps3flash_bounce_buffer.address;\n\tpriv->chunk_sectors = dev->bounce_size / dev->blk_size;\n\n\terror = ps3stor_setup(dev, ps3flash_interrupt);\n\tif (error)\n\t\tgoto fail_free_priv;\n\n\tps3flash_misc.parent = &dev->sbd.core;\n\terror = misc_register(&ps3flash_misc);\n\tif (error) {\n\t\tdev_err(&dev->sbd.core, \"%s:%u: misc_register failed %d\\n\",\n\t\t\t__func__, __LINE__, error);\n\t\tgoto fail_teardown;\n\t}\n\n\tdev_info(&dev->sbd.core, \"%s:%u: registered misc device %d\\n\",\n\t\t __func__, __LINE__, ps3flash_misc.minor);\n\n\tps3_os_area_flash_register(&ps3flash_kernel_ops);\n\treturn 0;\n\nfail_teardown:\n\tps3stor_teardown(dev);\nfail_free_priv:\n\tkfree(priv);\n\tps3_system_bus_set_drvdata(&dev->sbd, NULL);\nfail:\n\tps3flash_dev = NULL;\n\treturn error;\n}\n\nstatic void ps3flash_remove(struct ps3_system_bus_device *_dev)\n{\n\tstruct ps3_storage_device *dev = to_ps3_storage_device(&_dev->core);\n\n\tps3_os_area_flash_register(NULL);\n\tmisc_deregister(&ps3flash_misc);\n\tps3stor_teardown(dev);\n\tkfree(ps3_system_bus_get_drvdata(&dev->sbd));\n\tps3_system_bus_set_drvdata(&dev->sbd, NULL);\n\tps3flash_dev = NULL;\n}\n\n\nstatic struct ps3_system_bus_driver ps3flash = {\n\t.match_id\t= PS3_MATCH_ID_STOR_FLASH,\n\t.core.name\t= DEVICE_NAME,\n\t.core.owner\t= THIS_MODULE,\n\t.probe\t\t= ps3flash_probe,\n\t.remove\t\t= ps3flash_remove,\n\t.shutdown\t= ps3flash_remove,\n};\n\n\nstatic int __init ps3flash_init(void)\n{\n\treturn ps3_system_bus_driver_register(&ps3flash);\n}\n\nstatic void __exit ps3flash_exit(void)\n{\n\tps3_system_bus_driver_unregister(&ps3flash);\n}\n\nmodule_init(ps3flash_init);\nmodule_exit(ps3flash_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"PS3 FLASH ROM Storage Driver\");\nMODULE_AUTHOR(\"Sony Corporation\");\nMODULE_ALIAS(PS3_MODULE_ALIAS_STOR_FLASH);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}