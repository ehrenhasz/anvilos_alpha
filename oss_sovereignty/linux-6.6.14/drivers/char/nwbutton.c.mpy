{
  "module_name": "nwbutton.c",
  "hash_id": "d3c29a1aa2d71e2970540c05600a4b1d9b2b5b8af8c7f31b464ecbe8adef54fa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/nwbutton.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/time.h>\n#include <linux/timer.h>\n#include <linux/fs.h>\n#include <linux/miscdevice.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n\n#include <linux/uaccess.h>\n#include <asm/irq.h>\n#include <asm/mach-types.h>\n\n#define __NWBUTTON_C\t\t \n#include \"nwbutton.h\"\n\nstatic void button_sequence_finished(struct timer_list *unused);\n\nstatic int button_press_count;\t\t \n \nstatic DEFINE_TIMER(button_timer, button_sequence_finished);\nstatic DECLARE_WAIT_QUEUE_HEAD(button_wait_queue);  \nstatic char button_output_buffer[32];\t \nstatic int bcount;\t\t\t \nstatic int bdelay = BUTTON_DELAY;\t \nstatic struct button_callback button_callback_list[32];  \nstatic int callback_count;\t\t \nstatic int reboot_count = NUM_PRESSES_REBOOT;  \n\n \n\nint button_add_callback (void (*callback) (void), int count)\n{\n\tint lp = 0;\n\tif (callback_count == 32) {\n\t\treturn -ENOMEM;\n\t}\n\tif (!callback) {\n\t\treturn -EINVAL;\n\t}\n\tcallback_count++;\n\tfor (; (button_callback_list [lp].callback); lp++);\n\tbutton_callback_list [lp].callback = callback;\n\tbutton_callback_list [lp].count = count;\n\treturn 0;\n}\n\n \n\nint button_del_callback (void (*callback) (void))\n{\n\tint lp = 31;\n\tif (!callback) {\n\t\treturn -EINVAL;\n\t}\n\twhile (lp >= 0) {\n\t\tif ((button_callback_list [lp].callback) == callback) {\n\t\t\tbutton_callback_list [lp].callback = NULL;\n\t\t\tbutton_callback_list [lp].count = 0;\n\t\t\tcallback_count--;\n\t\t\treturn 0;\n\t\t}\n\t\tlp--;\n\t}\n\treturn -EINVAL;\n}\n\n \n\nstatic void button_consume_callbacks (int bpcount)\n{\n\tint lp = 0;\n\tfor (; lp <= 31; lp++) {\n\t\tif ((button_callback_list [lp].count) == bpcount) {\n\t\t\tif (button_callback_list [lp].callback) {\n\t\t\t\tbutton_callback_list[lp].callback();\n\t\t\t}\n\t\t}\n\t}\n}\n\n \n\nstatic void button_sequence_finished(struct timer_list *unused)\n{\n\tif (IS_ENABLED(CONFIG_NWBUTTON_REBOOT) &&\n\t    button_press_count == reboot_count)\n\t\tkill_cad_pid(SIGINT, 1);\t \n\tbutton_consume_callbacks (button_press_count);\n\tbcount = sprintf (button_output_buffer, \"%d\\n\", button_press_count);\n\tbutton_press_count = 0;\t\t \n\twake_up_interruptible (&button_wait_queue);\n}\n\n  \n\nstatic irqreturn_t button_handler (int irq, void *dev_id)\n{\n\tbutton_press_count++;\n\tmod_timer(&button_timer, jiffies + bdelay);\n\n\treturn IRQ_HANDLED;\n}\n\n \n\nstatic int button_read (struct file *filp, char __user *buffer,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tDEFINE_WAIT(wait);\n\tprepare_to_wait(&button_wait_queue, &wait, TASK_INTERRUPTIBLE);\n\tschedule();\n\tfinish_wait(&button_wait_queue, &wait);\n\treturn (copy_to_user (buffer, &button_output_buffer, bcount))\n\t\t ? -EFAULT : bcount;\n}\n\n \n\nstatic const struct file_operations button_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.read\t\t= button_read,\n\t.llseek\t\t= noop_llseek,\n};\n\n \n\nstatic struct miscdevice button_misc_device = {\n\tBUTTON_MINOR,\n\t\"nwbutton\",\n\t&button_fops,\n};\n\n \n\nstatic int __init nwbutton_init(void)\n{\n\tif (!machine_is_netwinder())\n\t\treturn -ENODEV;\n\n\tprintk (KERN_INFO \"NetWinder Button Driver Version %s (C) Alex Holden \"\n\t\t\t\"<alex@linuxhacker.org> 1998.\\n\", VERSION);\n\n\tif (misc_register (&button_misc_device)) {\n\t\tprintk (KERN_WARNING \"nwbutton: Couldn't register device 10, \"\n\t\t\t\t\"%d.\\n\", BUTTON_MINOR);\n\t\treturn -EBUSY;\n\t}\n\n\tif (request_irq (IRQ_NETWINDER_BUTTON, button_handler, 0,\n\t\t\t\"nwbutton\", NULL)) {\n\t\tprintk (KERN_WARNING \"nwbutton: IRQ %d is not free.\\n\",\n\t\t\t\tIRQ_NETWINDER_BUTTON);\n\t\tmisc_deregister (&button_misc_device);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic void __exit nwbutton_exit (void) \n{\n\tfree_irq (IRQ_NETWINDER_BUTTON, NULL);\n\tmisc_deregister (&button_misc_device);\n}\n\n\nMODULE_AUTHOR(\"Alex Holden\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(nwbutton_init);\nmodule_exit(nwbutton_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}