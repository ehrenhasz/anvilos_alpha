{
  "module_name": "ppdev.c",
  "hash_id": "dda3452c1abe718308eda62a0fb4f3bd161109dc4dbbd0defad482ab534d20fb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/ppdev.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sched/signal.h>\n#include <linux/device.h>\n#include <linux/ioctl.h>\n#include <linux/parport.h>\n#include <linux/ctype.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/major.h>\n#include <linux/ppdev.h>\n#include <linux/mutex.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n\n#define PP_VERSION \"ppdev: user-space parallel port driver\"\n#define CHRDEV \"ppdev\"\n\nstruct pp_struct {\n\tstruct pardevice *pdev;\n\twait_queue_head_t irq_wait;\n\tatomic_t irqc;\n\tunsigned int flags;\n\tint irqresponse;\n\tunsigned char irqctl;\n\tstruct ieee1284_info state;\n\tstruct ieee1284_info saved_state;\n\tlong default_inactivity;\n\tint index;\n};\n\n \nstatic struct device *devices[PARPORT_MAX];\n\nstatic DEFINE_IDA(ida_index);\n\n \n#define PP_CLAIMED    (1<<0)\n#define PP_EXCL       (1<<1)\n\n \n#define PP_INTERRUPT_TIMEOUT (10 * HZ)  \n#define PP_BUFFER_SIZE 1024\n#define PARDEVICE_MAX 8\n\nstatic DEFINE_MUTEX(pp_do_mutex);\n\n \n#define PPGETTIME32\t_IOR(PP_IOCTL, 0x95, s32[2])\n#define PPSETTIME32\t_IOW(PP_IOCTL, 0x96, s32[2])\n#define PPGETTIME64\t_IOR(PP_IOCTL, 0x95, s64[2])\n#define PPSETTIME64\t_IOW(PP_IOCTL, 0x96, s64[2])\n\nstatic inline void pp_enable_irq(struct pp_struct *pp)\n{\n\tstruct parport *port = pp->pdev->port;\n\n\tport->ops->enable_irq(port);\n}\n\nstatic ssize_t pp_read(struct file *file, char __user *buf, size_t count,\n\t\t       loff_t *ppos)\n{\n\tunsigned int minor = iminor(file_inode(file));\n\tstruct pp_struct *pp = file->private_data;\n\tchar *kbuffer;\n\tssize_t bytes_read = 0;\n\tstruct parport *pport;\n\tint mode;\n\n\tif (!(pp->flags & PP_CLAIMED)) {\n\t\t \n\t\tpr_debug(CHRDEV \"%x: claim the port first\\n\", minor);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (count == 0)\n\t\treturn 0;\n\n\tkbuffer = kmalloc(min_t(size_t, count, PP_BUFFER_SIZE), GFP_KERNEL);\n\tif (!kbuffer)\n\t\treturn -ENOMEM;\n\tpport = pp->pdev->port;\n\tmode = pport->ieee1284.mode & ~(IEEE1284_DEVICEID | IEEE1284_ADDR);\n\n\tparport_set_timeout(pp->pdev,\n\t\t\t    (file->f_flags & O_NONBLOCK) ?\n\t\t\t    PARPORT_INACTIVITY_O_NONBLOCK :\n\t\t\t    pp->default_inactivity);\n\n\twhile (bytes_read == 0) {\n\t\tssize_t need = min_t(unsigned long, count, PP_BUFFER_SIZE);\n\n\t\tif (mode == IEEE1284_MODE_EPP) {\n\t\t\t \n\t\t\tint flags = 0;\n\t\t\tsize_t (*fn)(struct parport *, void *, size_t, int);\n\n\t\t\tif (pp->flags & PP_W91284PIC)\n\t\t\t\tflags |= PARPORT_W91284PIC;\n\t\t\tif (pp->flags & PP_FASTREAD)\n\t\t\t\tflags |= PARPORT_EPP_FAST;\n\t\t\tif (pport->ieee1284.mode & IEEE1284_ADDR)\n\t\t\t\tfn = pport->ops->epp_read_addr;\n\t\t\telse\n\t\t\t\tfn = pport->ops->epp_read_data;\n\t\t\tbytes_read = (*fn)(pport, kbuffer, need, flags);\n\t\t} else {\n\t\t\tbytes_read = parport_read(pport, kbuffer, need);\n\t\t}\n\n\t\tif (bytes_read != 0)\n\t\t\tbreak;\n\n\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\tbytes_read = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (signal_pending(current)) {\n\t\t\tbytes_read = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\n\t\tcond_resched();\n\t}\n\n\tparport_set_timeout(pp->pdev, pp->default_inactivity);\n\n\tif (bytes_read > 0 && copy_to_user(buf, kbuffer, bytes_read))\n\t\tbytes_read = -EFAULT;\n\n\tkfree(kbuffer);\n\tpp_enable_irq(pp);\n\treturn bytes_read;\n}\n\nstatic ssize_t pp_write(struct file *file, const char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tunsigned int minor = iminor(file_inode(file));\n\tstruct pp_struct *pp = file->private_data;\n\tchar *kbuffer;\n\tssize_t bytes_written = 0;\n\tssize_t wrote;\n\tint mode;\n\tstruct parport *pport;\n\n\tif (!(pp->flags & PP_CLAIMED)) {\n\t\t \n\t\tpr_debug(CHRDEV \"%x: claim the port first\\n\", minor);\n\t\treturn -EINVAL;\n\t}\n\n\tkbuffer = kmalloc(min_t(size_t, count, PP_BUFFER_SIZE), GFP_KERNEL);\n\tif (!kbuffer)\n\t\treturn -ENOMEM;\n\n\tpport = pp->pdev->port;\n\tmode = pport->ieee1284.mode & ~(IEEE1284_DEVICEID | IEEE1284_ADDR);\n\n\tparport_set_timeout(pp->pdev,\n\t\t\t    (file->f_flags & O_NONBLOCK) ?\n\t\t\t    PARPORT_INACTIVITY_O_NONBLOCK :\n\t\t\t    pp->default_inactivity);\n\n\twhile (bytes_written < count) {\n\t\tssize_t n = min_t(unsigned long, count - bytes_written, PP_BUFFER_SIZE);\n\n\t\tif (copy_from_user(kbuffer, buf + bytes_written, n)) {\n\t\t\tbytes_written = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((pp->flags & PP_FASTWRITE) && (mode == IEEE1284_MODE_EPP)) {\n\t\t\t \n\t\t\tif (pport->ieee1284.mode & IEEE1284_ADDR) {\n\t\t\t\twrote = pport->ops->epp_write_addr(pport,\n\t\t\t\t\tkbuffer, n, PARPORT_EPP_FAST);\n\t\t\t} else {\n\t\t\t\twrote = pport->ops->epp_write_data(pport,\n\t\t\t\t\tkbuffer, n, PARPORT_EPP_FAST);\n\t\t\t}\n\t\t} else {\n\t\t\twrote = parport_write(pp->pdev->port, kbuffer, n);\n\t\t}\n\n\t\tif (wrote <= 0) {\n\t\t\tif (!bytes_written)\n\t\t\t\tbytes_written = wrote;\n\t\t\tbreak;\n\t\t}\n\n\t\tbytes_written += wrote;\n\n\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\tif (!bytes_written)\n\t\t\t\tbytes_written = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\n\t\tcond_resched();\n\t}\n\n\tparport_set_timeout(pp->pdev, pp->default_inactivity);\n\n\tkfree(kbuffer);\n\tpp_enable_irq(pp);\n\treturn bytes_written;\n}\n\nstatic void pp_irq(void *private)\n{\n\tstruct pp_struct *pp = private;\n\n\tif (pp->irqresponse) {\n\t\tparport_write_control(pp->pdev->port, pp->irqctl);\n\t\tpp->irqresponse = 0;\n\t}\n\n\tatomic_inc(&pp->irqc);\n\twake_up_interruptible(&pp->irq_wait);\n}\n\nstatic int register_device(int minor, struct pp_struct *pp)\n{\n\tstruct parport *port;\n\tstruct pardevice *pdev = NULL;\n\tchar *name;\n\tstruct pardev_cb ppdev_cb;\n\tint rc = 0, index;\n\n\tname = kasprintf(GFP_KERNEL, CHRDEV \"%x\", minor);\n\tif (name == NULL)\n\t\treturn -ENOMEM;\n\n\tport = parport_find_number(minor);\n\tif (!port) {\n\t\tpr_warn(\"%s: no associated port!\\n\", name);\n\t\trc = -ENXIO;\n\t\tgoto err;\n\t}\n\n\tindex = ida_simple_get(&ida_index, 0, 0, GFP_KERNEL);\n\tmemset(&ppdev_cb, 0, sizeof(ppdev_cb));\n\tppdev_cb.irq_func = pp_irq;\n\tppdev_cb.flags = (pp->flags & PP_EXCL) ? PARPORT_FLAG_EXCL : 0;\n\tppdev_cb.private = pp;\n\tpdev = parport_register_dev_model(port, name, &ppdev_cb, index);\n\tparport_put_port(port);\n\n\tif (!pdev) {\n\t\tpr_warn(\"%s: failed to register device!\\n\", name);\n\t\trc = -ENXIO;\n\t\tida_simple_remove(&ida_index, index);\n\t\tgoto err;\n\t}\n\n\tpp->pdev = pdev;\n\tpp->index = index;\n\tdev_dbg(&pdev->dev, \"registered pardevice\\n\");\nerr:\n\tkfree(name);\n\treturn rc;\n}\n\nstatic enum ieee1284_phase init_phase(int mode)\n{\n\tswitch (mode & ~(IEEE1284_DEVICEID\n\t\t\t | IEEE1284_ADDR)) {\n\tcase IEEE1284_MODE_NIBBLE:\n\tcase IEEE1284_MODE_BYTE:\n\t\treturn IEEE1284_PH_REV_IDLE;\n\t}\n\treturn IEEE1284_PH_FWD_IDLE;\n}\n\nstatic int pp_set_timeout(struct pardevice *pdev, long tv_sec, int tv_usec)\n{\n\tlong to_jiffies;\n\n\tif ((tv_sec < 0) || (tv_usec < 0))\n\t\treturn -EINVAL;\n\n\tto_jiffies = usecs_to_jiffies(tv_usec);\n\tto_jiffies += tv_sec * HZ;\n\tif (to_jiffies <= 0)\n\t\treturn -EINVAL;\n\n\tpdev->timeout = to_jiffies;\n\treturn 0;\n}\n\nstatic int pp_do_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tunsigned int minor = iminor(file_inode(file));\n\tstruct pp_struct *pp = file->private_data;\n\tstruct parport *port;\n\tvoid __user *argp = (void __user *)arg;\n\tstruct ieee1284_info *info;\n\tunsigned char reg;\n\tunsigned char mask;\n\tint mode;\n\ts32 time32[2];\n\ts64 time64[2];\n\tstruct timespec64 ts;\n\tint ret;\n\n\t \n\tswitch (cmd) {\n\tcase PPCLAIM:\n\t    {\n\t\tif (pp->flags & PP_CLAIMED) {\n\t\t\tdev_dbg(&pp->pdev->dev, \"you've already got it!\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (!pp->pdev) {\n\t\t\tint err = register_device(minor, pp);\n\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tret = parport_claim_or_block(pp->pdev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tpp->flags |= PP_CLAIMED;\n\n\t\t \n\t\tpp_enable_irq(pp);\n\n\t\t \n\t\tinfo = &pp->pdev->port->ieee1284;\n\t\tpp->saved_state.mode = info->mode;\n\t\tpp->saved_state.phase = info->phase;\n\t\tinfo->mode = pp->state.mode;\n\t\tinfo->phase = pp->state.phase;\n\t\tpp->default_inactivity = parport_set_timeout(pp->pdev, 0);\n\t\tparport_set_timeout(pp->pdev, pp->default_inactivity);\n\n\t\treturn 0;\n\t    }\n\tcase PPEXCL:\n\t\tif (pp->pdev) {\n\t\t\tdev_dbg(&pp->pdev->dev,\n\t\t\t\t\"too late for PPEXCL; already registered\\n\");\n\t\t\tif (pp->flags & PP_EXCL)\n\t\t\t\t \n\t\t\t\treturn 0;\n\t\t\t \n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tpp->flags |= PP_EXCL;\n\t\treturn 0;\n\tcase PPSETMODE:\n\t    {\n\t\tint mode;\n\n\t\tif (copy_from_user(&mode, argp, sizeof(mode)))\n\t\t\treturn -EFAULT;\n\t\t \n\t\tpp->state.mode = mode;\n\t\tpp->state.phase = init_phase(mode);\n\n\t\tif (pp->flags & PP_CLAIMED) {\n\t\t\tpp->pdev->port->ieee1284.mode = mode;\n\t\t\tpp->pdev->port->ieee1284.phase = pp->state.phase;\n\t\t}\n\n\t\treturn 0;\n\t    }\n\tcase PPGETMODE:\n\t    {\n\t\tint mode;\n\n\t\tif (pp->flags & PP_CLAIMED)\n\t\t\tmode = pp->pdev->port->ieee1284.mode;\n\t\telse\n\t\t\tmode = pp->state.mode;\n\n\t\tif (copy_to_user(argp, &mode, sizeof(mode)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t    }\n\tcase PPSETPHASE:\n\t    {\n\t\tint phase;\n\n\t\tif (copy_from_user(&phase, argp, sizeof(phase)))\n\t\t\treturn -EFAULT;\n\n\t\t \n\t\tpp->state.phase = phase;\n\n\t\tif (pp->flags & PP_CLAIMED)\n\t\t\tpp->pdev->port->ieee1284.phase = phase;\n\n\t\treturn 0;\n\t    }\n\tcase PPGETPHASE:\n\t    {\n\t\tint phase;\n\n\t\tif (pp->flags & PP_CLAIMED)\n\t\t\tphase = pp->pdev->port->ieee1284.phase;\n\t\telse\n\t\t\tphase = pp->state.phase;\n\t\tif (copy_to_user(argp, &phase, sizeof(phase)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t    }\n\tcase PPGETMODES:\n\t    {\n\t\tunsigned int modes;\n\n\t\tport = parport_find_number(minor);\n\t\tif (!port)\n\t\t\treturn -ENODEV;\n\n\t\tmodes = port->modes;\n\t\tparport_put_port(port);\n\t\tif (copy_to_user(argp, &modes, sizeof(modes)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t    }\n\tcase PPSETFLAGS:\n\t    {\n\t\tint uflags;\n\n\t\tif (copy_from_user(&uflags, argp, sizeof(uflags)))\n\t\t\treturn -EFAULT;\n\t\tpp->flags &= ~PP_FLAGMASK;\n\t\tpp->flags |= (uflags & PP_FLAGMASK);\n\t\treturn 0;\n\t    }\n\tcase PPGETFLAGS:\n\t    {\n\t\tint uflags;\n\n\t\tuflags = pp->flags & PP_FLAGMASK;\n\t\tif (copy_to_user(argp, &uflags, sizeof(uflags)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t    }\n\t}\t \n\n\t \n\tif ((pp->flags & PP_CLAIMED) == 0) {\n\t\tpr_debug(CHRDEV \"%x: claim the port first\\n\", minor);\n\t\treturn -EINVAL;\n\t}\n\n\tport = pp->pdev->port;\n\tswitch (cmd) {\n\tcase PPRSTATUS:\n\t\treg = parport_read_status(port);\n\t\tif (copy_to_user(argp, &reg, sizeof(reg)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tcase PPRDATA:\n\t\treg = parport_read_data(port);\n\t\tif (copy_to_user(argp, &reg, sizeof(reg)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tcase PPRCONTROL:\n\t\treg = parport_read_control(port);\n\t\tif (copy_to_user(argp, &reg, sizeof(reg)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tcase PPYIELD:\n\t\tparport_yield_blocking(pp->pdev);\n\t\treturn 0;\n\n\tcase PPRELEASE:\n\t\t \n\t\tinfo = &pp->pdev->port->ieee1284;\n\t\tpp->state.mode = info->mode;\n\t\tpp->state.phase = info->phase;\n\t\tinfo->mode = pp->saved_state.mode;\n\t\tinfo->phase = pp->saved_state.phase;\n\t\tparport_release(pp->pdev);\n\t\tpp->flags &= ~PP_CLAIMED;\n\t\treturn 0;\n\n\tcase PPWCONTROL:\n\t\tif (copy_from_user(&reg, argp, sizeof(reg)))\n\t\t\treturn -EFAULT;\n\t\tparport_write_control(port, reg);\n\t\treturn 0;\n\n\tcase PPWDATA:\n\t\tif (copy_from_user(&reg, argp, sizeof(reg)))\n\t\t\treturn -EFAULT;\n\t\tparport_write_data(port, reg);\n\t\treturn 0;\n\n\tcase PPFCONTROL:\n\t\tif (copy_from_user(&mask, argp,\n\t\t\t\t   sizeof(mask)))\n\t\t\treturn -EFAULT;\n\t\tif (copy_from_user(&reg, 1 + (unsigned char __user *) arg,\n\t\t\t\t   sizeof(reg)))\n\t\t\treturn -EFAULT;\n\t\tparport_frob_control(port, mask, reg);\n\t\treturn 0;\n\n\tcase PPDATADIR:\n\t\tif (copy_from_user(&mode, argp, sizeof(mode)))\n\t\t\treturn -EFAULT;\n\t\tif (mode)\n\t\t\tport->ops->data_reverse(port);\n\t\telse\n\t\t\tport->ops->data_forward(port);\n\t\treturn 0;\n\n\tcase PPNEGOT:\n\t\tif (copy_from_user(&mode, argp, sizeof(mode)))\n\t\t\treturn -EFAULT;\n\t\tswitch ((ret = parport_negotiate(port, mode))) {\n\t\tcase 0: break;\n\t\tcase -1:  \n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\tcase 1:   \n\t\t\tret = -ENXIO;\n\t\t\tbreak;\n\t\t}\n\t\tpp_enable_irq(pp);\n\t\treturn ret;\n\n\tcase PPWCTLONIRQ:\n\t\tif (copy_from_user(&reg, argp, sizeof(reg)))\n\t\t\treturn -EFAULT;\n\n\t\t \n\t\tpp->irqctl = reg;\n\t\tpp->irqresponse = 1;\n\t\treturn 0;\n\n\tcase PPCLRIRQ:\n\t\tret = atomic_read(&pp->irqc);\n\t\tif (copy_to_user(argp, &ret, sizeof(ret)))\n\t\t\treturn -EFAULT;\n\t\tatomic_sub(ret, &pp->irqc);\n\t\treturn 0;\n\n\tcase PPSETTIME32:\n\t\tif (copy_from_user(time32, argp, sizeof(time32)))\n\t\t\treturn -EFAULT;\n\n\t\tif ((time32[0] < 0) || (time32[1] < 0))\n\t\t\treturn -EINVAL;\n\n\t\treturn pp_set_timeout(pp->pdev, time32[0], time32[1]);\n\n\tcase PPSETTIME64:\n\t\tif (copy_from_user(time64, argp, sizeof(time64)))\n\t\t\treturn -EFAULT;\n\n\t\tif ((time64[0] < 0) || (time64[1] < 0))\n\t\t\treturn -EINVAL;\n\n\t\tif (IS_ENABLED(CONFIG_SPARC64) && !in_compat_syscall())\n\t\t\ttime64[1] >>= 32;\n\n\t\treturn pp_set_timeout(pp->pdev, time64[0], time64[1]);\n\n\tcase PPGETTIME32:\n\t\tjiffies_to_timespec64(pp->pdev->timeout, &ts);\n\t\ttime32[0] = ts.tv_sec;\n\t\ttime32[1] = ts.tv_nsec / NSEC_PER_USEC;\n\n\t\tif (copy_to_user(argp, time32, sizeof(time32)))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\n\tcase PPGETTIME64:\n\t\tjiffies_to_timespec64(pp->pdev->timeout, &ts);\n\t\ttime64[0] = ts.tv_sec;\n\t\ttime64[1] = ts.tv_nsec / NSEC_PER_USEC;\n\n\t\tif (IS_ENABLED(CONFIG_SPARC64) && !in_compat_syscall())\n\t\t\ttime64[1] <<= 32;\n\n\t\tif (copy_to_user(argp, time64, sizeof(time64)))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\n\tdefault:\n\t\tdev_dbg(&pp->pdev->dev, \"What? (cmd=0x%x)\\n\", cmd);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\treturn 0;\n}\n\nstatic long pp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tlong ret;\n\n\tmutex_lock(&pp_do_mutex);\n\tret = pp_do_ioctl(file, cmd, arg);\n\tmutex_unlock(&pp_do_mutex);\n\treturn ret;\n}\n\nstatic int pp_open(struct inode *inode, struct file *file)\n{\n\tunsigned int minor = iminor(inode);\n\tstruct pp_struct *pp;\n\n\tif (minor >= PARPORT_MAX)\n\t\treturn -ENXIO;\n\n\tpp = kmalloc(sizeof(struct pp_struct), GFP_KERNEL);\n\tif (!pp)\n\t\treturn -ENOMEM;\n\n\tpp->state.mode = IEEE1284_MODE_COMPAT;\n\tpp->state.phase = init_phase(pp->state.mode);\n\tpp->flags = 0;\n\tpp->irqresponse = 0;\n\tatomic_set(&pp->irqc, 0);\n\tinit_waitqueue_head(&pp->irq_wait);\n\n\t \n\tpp->pdev = NULL;\n\tfile->private_data = pp;\n\n\treturn 0;\n}\n\nstatic int pp_release(struct inode *inode, struct file *file)\n{\n\tunsigned int minor = iminor(inode);\n\tstruct pp_struct *pp = file->private_data;\n\tint compat_negot;\n\n\tcompat_negot = 0;\n\tif (!(pp->flags & PP_CLAIMED) && pp->pdev &&\n\t    (pp->state.mode != IEEE1284_MODE_COMPAT)) {\n\t\tstruct ieee1284_info *info;\n\n\t\t \n\t\tparport_claim_or_block(pp->pdev);\n\t\tpp->flags |= PP_CLAIMED;\n\t\tinfo = &pp->pdev->port->ieee1284;\n\t\tpp->saved_state.mode = info->mode;\n\t\tpp->saved_state.phase = info->phase;\n\t\tinfo->mode = pp->state.mode;\n\t\tinfo->phase = pp->state.phase;\n\t\tcompat_negot = 1;\n\t} else if ((pp->flags & PP_CLAIMED) && pp->pdev &&\n\t    (pp->pdev->port->ieee1284.mode != IEEE1284_MODE_COMPAT)) {\n\t\tcompat_negot = 2;\n\t}\n\tif (compat_negot) {\n\t\tparport_negotiate(pp->pdev->port, IEEE1284_MODE_COMPAT);\n\t\tdev_dbg(&pp->pdev->dev,\n\t\t\t\"negotiated back to compatibility mode because user-space forgot\\n\");\n\t}\n\n\tif ((pp->flags & PP_CLAIMED) && pp->pdev) {\n\t\tstruct ieee1284_info *info;\n\n\t\tinfo = &pp->pdev->port->ieee1284;\n\t\tpp->state.mode = info->mode;\n\t\tpp->state.phase = info->phase;\n\t\tinfo->mode = pp->saved_state.mode;\n\t\tinfo->phase = pp->saved_state.phase;\n\t\tparport_release(pp->pdev);\n\t\tif (compat_negot != 1) {\n\t\t\tpr_debug(CHRDEV \"%x: released pardevice \"\n\t\t\t\t\"because user-space forgot\\n\", minor);\n\t\t}\n\t}\n\n\tif (pp->pdev) {\n\t\tparport_unregister_device(pp->pdev);\n\t\tida_simple_remove(&ida_index, pp->index);\n\t\tpp->pdev = NULL;\n\t\tpr_debug(CHRDEV \"%x: unregistered pardevice\\n\", minor);\n\t}\n\n\tkfree(pp);\n\n\treturn 0;\n}\n\n \nstatic __poll_t pp_poll(struct file *file, poll_table *wait)\n{\n\tstruct pp_struct *pp = file->private_data;\n\t__poll_t mask = 0;\n\n\tpoll_wait(file, &pp->irq_wait, wait);\n\tif (atomic_read(&pp->irqc))\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\n\treturn mask;\n}\n\nstatic const struct class ppdev_class = {\n\t.name = CHRDEV,\n};\n\nstatic const struct file_operations pp_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.llseek\t\t= no_llseek,\n\t.read\t\t= pp_read,\n\t.write\t\t= pp_write,\n\t.poll\t\t= pp_poll,\n\t.unlocked_ioctl\t= pp_ioctl,\n\t.compat_ioctl   = compat_ptr_ioctl,\n\t.open\t\t= pp_open,\n\t.release\t= pp_release,\n};\n\nstatic void pp_attach(struct parport *port)\n{\n\tstruct device *ret;\n\n\tif (devices[port->number])\n\t\treturn;\n\n\tret = device_create(&ppdev_class, port->dev,\n\t\t\t    MKDEV(PP_MAJOR, port->number), NULL,\n\t\t\t    \"parport%d\", port->number);\n\tif (IS_ERR(ret)) {\n\t\tpr_err(\"Failed to create device parport%d\\n\",\n\t\t       port->number);\n\t\treturn;\n\t}\n\tdevices[port->number] = ret;\n}\n\nstatic void pp_detach(struct parport *port)\n{\n\tif (!devices[port->number])\n\t\treturn;\n\n\tdevice_destroy(&ppdev_class, MKDEV(PP_MAJOR, port->number));\n\tdevices[port->number] = NULL;\n}\n\nstatic int pp_probe(struct pardevice *par_dev)\n{\n\tstruct device_driver *drv = par_dev->dev.driver;\n\tint len = strlen(drv->name);\n\n\tif (strncmp(par_dev->name, drv->name, len))\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic struct parport_driver pp_driver = {\n\t.name\t\t= CHRDEV,\n\t.probe\t\t= pp_probe,\n\t.match_port\t= pp_attach,\n\t.detach\t\t= pp_detach,\n\t.devmodel\t= true,\n};\n\nstatic int __init ppdev_init(void)\n{\n\tint err = 0;\n\n\tif (register_chrdev(PP_MAJOR, CHRDEV, &pp_fops)) {\n\t\tpr_warn(CHRDEV \": unable to get major %d\\n\", PP_MAJOR);\n\t\treturn -EIO;\n\t}\n\terr = class_register(&ppdev_class);\n\tif (err)\n\t\tgoto out_chrdev;\n\n\terr = parport_register_driver(&pp_driver);\n\tif (err < 0) {\n\t\tpr_warn(CHRDEV \": unable to register with parport\\n\");\n\t\tgoto out_class;\n\t}\n\n\tpr_info(PP_VERSION \"\\n\");\n\tgoto out;\n\nout_class:\n\tclass_unregister(&ppdev_class);\nout_chrdev:\n\tunregister_chrdev(PP_MAJOR, CHRDEV);\nout:\n\treturn err;\n}\n\nstatic void __exit ppdev_cleanup(void)\n{\n\t \n\tparport_unregister_driver(&pp_driver);\n\tclass_unregister(&ppdev_class);\n\tunregister_chrdev(PP_MAJOR, CHRDEV);\n}\n\nmodule_init(ppdev_init);\nmodule_exit(ppdev_cleanup);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_CHARDEV_MAJOR(PP_MAJOR);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}