{
  "module_name": "scx200_gpio.c",
  "hash_id": "88dc107a5504b157641a0267e6c8e415803126086397b7811e922916b2be409b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/scx200_gpio.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#include <linux/uaccess.h>\n#include <asm/io.h>\n\n#include <linux/types.h>\n#include <linux/cdev.h>\n\n#include <linux/scx200_gpio.h>\n#include <linux/nsc_gpio.h>\n\n#define DRVNAME \"scx200_gpio\"\n\nstatic struct platform_device *pdev;\n\nMODULE_AUTHOR(\"Christer Weinigel <wingel@nano-system.com>\");\nMODULE_DESCRIPTION(\"NatSemi/AMD SCx200 GPIO Pin Driver\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int major = 0;\t\t \nmodule_param(major, int, 0);\nMODULE_PARM_DESC(major, \"Major device number\");\n\n#define MAX_PINS 32\t\t \n\nstruct nsc_gpio_ops scx200_gpio_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.gpio_config\t= scx200_gpio_configure,\n\t.gpio_dump\t= nsc_gpio_dump,\n\t.gpio_get\t= scx200_gpio_get,\n\t.gpio_set\t= scx200_gpio_set,\n\t.gpio_change\t= scx200_gpio_change,\n\t.gpio_current\t= scx200_gpio_current\n};\nEXPORT_SYMBOL_GPL(scx200_gpio_ops);\n\nstatic int scx200_gpio_open(struct inode *inode, struct file *file)\n{\n\tunsigned m = iminor(inode);\n\tfile->private_data = &scx200_gpio_ops;\n\n\tif (m >= MAX_PINS)\n\t\treturn -EINVAL;\n\treturn nonseekable_open(inode, file);\n}\n\nstatic int scx200_gpio_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}\n\nstatic const struct file_operations scx200_gpio_fileops = {\n\t.owner   = THIS_MODULE,\n\t.write   = nsc_gpio_write,\n\t.read    = nsc_gpio_read,\n\t.open    = scx200_gpio_open,\n\t.release = scx200_gpio_release,\n\t.llseek  = no_llseek,\n};\n\nstatic struct cdev scx200_gpio_cdev;   \n\nstatic int __init scx200_gpio_init(void)\n{\n\tint rc;\n\tdev_t devid;\n\n\tif (!scx200_gpio_present()) {\n\t\tprintk(KERN_ERR DRVNAME \": no SCx200 gpio present\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tpdev = platform_device_alloc(DRVNAME, 0);\n\tif (!pdev)\n\t\treturn -ENOMEM;\n\n\trc = platform_device_add(pdev);\n\tif (rc)\n\t\tgoto undo_malloc;\n\n\t \n\tscx200_gpio_ops.dev = &pdev->dev;\n\n\tif (major) {\n\t\tdevid = MKDEV(major, 0);\n\t\trc = register_chrdev_region(devid, MAX_PINS, \"scx200_gpio\");\n\t} else {\n\t\trc = alloc_chrdev_region(&devid, 0, MAX_PINS, \"scx200_gpio\");\n\t\tmajor = MAJOR(devid);\n\t}\n\tif (rc < 0) {\n\t\tdev_err(&pdev->dev, \"SCx200 chrdev_region err: %d\\n\", rc);\n\t\tgoto undo_platform_device_add;\n\t}\n\n\tcdev_init(&scx200_gpio_cdev, &scx200_gpio_fileops);\n\tcdev_add(&scx200_gpio_cdev, devid, MAX_PINS);\n\n\treturn 0;  \n\nundo_platform_device_add:\n\tplatform_device_del(pdev);\nundo_malloc:\n\tplatform_device_put(pdev);\n\n\treturn rc;\n}\n\nstatic void __exit scx200_gpio_cleanup(void)\n{\n\tcdev_del(&scx200_gpio_cdev);\n\t \n\n\tunregister_chrdev_region(MKDEV(major, 0), MAX_PINS);\n\tplatform_device_unregister(pdev);\n}\n\nmodule_init(scx200_gpio_init);\nmodule_exit(scx200_gpio_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}