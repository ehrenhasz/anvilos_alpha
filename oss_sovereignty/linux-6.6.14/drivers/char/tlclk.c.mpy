{
  "module_name": "tlclk.c",
  "hash_id": "f61177f43c515f27a900cb7dff946427627c166abe84aad77586e5b59482ad36",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/tlclk.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\t \n#include <linux/fs.h>\t\t \n#include <linux/errno.h>\t \n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/ioport.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/timer.h>\n#include <linux/sysfs.h>\n#include <linux/device.h>\n#include <linux/miscdevice.h>\n#include <linux/platform_device.h>\n#include <asm/io.h>\t\t \n#include <linux/uaccess.h>\n\nMODULE_AUTHOR(\"Sebastien Bouchard <sebastien.bouchard@ca.kontron.com>\");\nMODULE_LICENSE(\"GPL\");\n\n \n#define RESET_ON\t0x00\n#define RESET_OFF\t0x01\n\n \n#define NORMAL_MODE \t0x00\n#define HOLDOVER_MODE\t0x10\n#define FREERUN_MODE\t0x20\n\n \n#define FILTER_6HZ\t0x04\n#define FILTER_12HZ\t0x00\n\n \n#define REF_CLK1_8kHz\t\t0x00\n#define REF_CLK2_19_44MHz\t0x02\n\n \n#define PRIMARY_CLOCK\t0x00\n#define SECONDARY_CLOCK\t0x01\n\n \n#define CLK_8kHz\t0xff\n#define CLK_16_384MHz\t0xfb\n\n#define CLK_1_544MHz\t0x00\n#define CLK_2_048MHz\t0x01\n#define CLK_4_096MHz\t0x02\n#define CLK_6_312MHz\t0x03\n#define CLK_8_192MHz\t0x04\n#define CLK_19_440MHz\t0x06\n\n#define CLK_8_592MHz\t0x08\n#define CLK_11_184MHz\t0x09\n#define CLK_34_368MHz\t0x0b\n#define CLK_44_736MHz\t0x0a\n\n \n#define AMC_B1 0\n#define AMC_B2 1\n\n \n#define HW_ENABLE\t0x80\n#define HW_DISABLE\t0x00\n\n \n#define PLL_HOLDOVER\t0x40\n#define LOST_CLOCK\t0x00\n\n \n#define UNLOCK_MASK\t0x10\n#define HOLDOVER_MASK\t0x20\n#define SEC_LOST_MASK\t0x40\n#define PRI_LOST_MASK\t0x80\n\n \n\n#define PRI_LOS_01_MASK\t\t0x01\n#define PRI_LOS_10_MASK\t\t0x02\n\n#define SEC_LOS_01_MASK\t\t0x04\n#define SEC_LOS_10_MASK\t\t0x08\n\n#define HOLDOVER_01_MASK\t0x10\n#define HOLDOVER_10_MASK\t0x20\n\n#define UNLOCK_01_MASK\t\t0x40\n#define UNLOCK_10_MASK\t\t0x80\n\nstruct tlclk_alarms {\n\t__u32 lost_clocks;\n\t__u32 lost_primary_clock;\n\t__u32 lost_secondary_clock;\n\t__u32 primary_clock_back;\n\t__u32 secondary_clock_back;\n\t__u32 switchover_primary;\n\t__u32 switchover_secondary;\n\t__u32 pll_holdover;\n\t__u32 pll_end_holdover;\n\t__u32 pll_lost_sync;\n\t__u32 pll_sync;\n};\n \n#define TLCLK_BASE 0xa08\n#define TLCLK_REG0 TLCLK_BASE\n#define TLCLK_REG1 (TLCLK_BASE+1)\n#define TLCLK_REG2 (TLCLK_BASE+2)\n#define TLCLK_REG3 (TLCLK_BASE+3)\n#define TLCLK_REG4 (TLCLK_BASE+4)\n#define TLCLK_REG5 (TLCLK_BASE+5)\n#define TLCLK_REG6 (TLCLK_BASE+6)\n#define TLCLK_REG7 (TLCLK_BASE+7)\n\n#define SET_PORT_BITS(port, mask, val) outb(((inb(port) & mask) | val), port)\n\n \n#define TLCLK_MAJOR 0\n\n \n\nstatic unsigned int telclk_interrupt;\n\nstatic int int_events;\t\t \nstatic int got_event;\t\t \n\nstatic void switchover_timeout(struct timer_list *t);\nstatic struct timer_list switchover_timer;\nstatic unsigned long tlclk_timer_data;\n\nstatic struct tlclk_alarms *alarm_events;\n\nstatic DEFINE_SPINLOCK(event_lock);\n\nstatic int tlclk_major = TLCLK_MAJOR;\n\nstatic irqreturn_t tlclk_interrupt(int irq, void *dev_id);\n\nstatic DECLARE_WAIT_QUEUE_HEAD(wq);\n\nstatic unsigned long useflags;\nstatic DEFINE_MUTEX(tlclk_mutex);\n\nstatic int tlclk_open(struct inode *inode, struct file *filp)\n{\n\tint result;\n\n\tmutex_lock(&tlclk_mutex);\n\tif (test_and_set_bit(0, &useflags)) {\n\t\tresult = -EBUSY;\n\t\t \n\t\tgoto out;\n\t}\n\n\t \n\tinb(TLCLK_REG6);\n\n\t \n\tresult = request_irq(telclk_interrupt, &tlclk_interrupt,\n\t\t\t     0, \"telco_clock\", tlclk_interrupt);\n\tif (result == -EBUSY)\n\t\tprintk(KERN_ERR \"tlclk: Interrupt can't be reserved.\\n\");\n\telse\n\t\tinb(TLCLK_REG6);\t \n\nout:\n\tmutex_unlock(&tlclk_mutex);\n\treturn result;\n}\n\nstatic int tlclk_release(struct inode *inode, struct file *filp)\n{\n\tfree_irq(telclk_interrupt, tlclk_interrupt);\n\tclear_bit(0, &useflags);\n\n\treturn 0;\n}\n\nstatic ssize_t tlclk_read(struct file *filp, char __user *buf, size_t count,\n\t\tloff_t *f_pos)\n{\n\tif (count < sizeof(struct tlclk_alarms))\n\t\treturn -EIO;\n\tif (mutex_lock_interruptible(&tlclk_mutex))\n\t\treturn -EINTR;\n\n\n\twait_event_interruptible(wq, got_event);\n\tif (copy_to_user(buf, alarm_events, sizeof(struct tlclk_alarms))) {\n\t\tmutex_unlock(&tlclk_mutex);\n\t\treturn -EFAULT;\n\t}\n\n\tmemset(alarm_events, 0, sizeof(struct tlclk_alarms));\n\tgot_event = 0;\n\n\tmutex_unlock(&tlclk_mutex);\n\treturn  sizeof(struct tlclk_alarms);\n}\n\nstatic const struct file_operations tlclk_fops = {\n\t.read = tlclk_read,\n\t.open = tlclk_open,\n\t.release = tlclk_release,\n\t.llseek = noop_llseek,\n\n};\n\nstatic struct miscdevice tlclk_miscdev = {\n\t.minor = MISC_DYNAMIC_MINOR,\n\t.name = \"telco_clock\",\n\t.fops = &tlclk_fops,\n};\n\nstatic ssize_t show_current_ref(struct device *d,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tunsigned long ret_val;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&event_lock, flags);\n\tret_val = ((inb(TLCLK_REG1) & 0x08) >> 3);\n\tspin_unlock_irqrestore(&event_lock, flags);\n\n\treturn sprintf(buf, \"0x%lX\\n\", ret_val);\n}\n\nstatic DEVICE_ATTR(current_ref, S_IRUGO, show_current_ref, NULL);\n\n\nstatic ssize_t show_telclock_version(struct device *d,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tunsigned long ret_val;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&event_lock, flags);\n\tret_val = inb(TLCLK_REG5);\n\tspin_unlock_irqrestore(&event_lock, flags);\n\n\treturn sprintf(buf, \"0x%lX\\n\", ret_val);\n}\n\nstatic DEVICE_ATTR(telclock_version, S_IRUGO,\n\t\tshow_telclock_version, NULL);\n\nstatic ssize_t show_alarms(struct device *d,\n\t\tstruct device_attribute *attr,  char *buf)\n{\n\tunsigned long ret_val;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&event_lock, flags);\n\tret_val = (inb(TLCLK_REG2) & 0xf0);\n\tspin_unlock_irqrestore(&event_lock, flags);\n\n\treturn sprintf(buf, \"0x%lX\\n\", ret_val);\n}\n\nstatic DEVICE_ATTR(alarms, S_IRUGO, show_alarms, NULL);\n\nstatic ssize_t store_received_ref_clk3a(struct device *d,\n\t\t struct device_attribute *attr, const char *buf, size_t count)\n{\n\tunsigned long tmp;\n\tunsigned char val;\n\tunsigned long flags;\n\n\tsscanf(buf, \"%lX\", &tmp);\n\tdev_dbg(d, \": tmp = 0x%lX\\n\", tmp);\n\n\tval = (unsigned char)tmp;\n\tspin_lock_irqsave(&event_lock, flags);\n\tSET_PORT_BITS(TLCLK_REG1, 0xef, val);\n\tspin_unlock_irqrestore(&event_lock, flags);\n\n\treturn strnlen(buf, count);\n}\n\nstatic DEVICE_ATTR(received_ref_clk3a, (S_IWUSR|S_IWGRP), NULL,\n\t\tstore_received_ref_clk3a);\n\n\nstatic ssize_t store_received_ref_clk3b(struct device *d,\n\t\t struct device_attribute *attr, const char *buf, size_t count)\n{\n\tunsigned long tmp;\n\tunsigned char val;\n\tunsigned long flags;\n\n\tsscanf(buf, \"%lX\", &tmp);\n\tdev_dbg(d, \": tmp = 0x%lX\\n\", tmp);\n\n\tval = (unsigned char)tmp;\n\tspin_lock_irqsave(&event_lock, flags);\n\tSET_PORT_BITS(TLCLK_REG1, 0xdf, val << 1);\n\tspin_unlock_irqrestore(&event_lock, flags);\n\n\treturn strnlen(buf, count);\n}\n\nstatic DEVICE_ATTR(received_ref_clk3b, (S_IWUSR|S_IWGRP), NULL,\n\t\tstore_received_ref_clk3b);\n\n\nstatic ssize_t store_enable_clk3b_output(struct device *d,\n\t\t struct device_attribute *attr, const char *buf, size_t count)\n{\n\tunsigned long tmp;\n\tunsigned char val;\n\tunsigned long flags;\n\n\tsscanf(buf, \"%lX\", &tmp);\n\tdev_dbg(d, \": tmp = 0x%lX\\n\", tmp);\n\n\tval = (unsigned char)tmp;\n\tspin_lock_irqsave(&event_lock, flags);\n\tSET_PORT_BITS(TLCLK_REG3, 0x7f, val << 7);\n\tspin_unlock_irqrestore(&event_lock, flags);\n\n\treturn strnlen(buf, count);\n}\n\nstatic DEVICE_ATTR(enable_clk3b_output, (S_IWUSR|S_IWGRP), NULL,\n\t\tstore_enable_clk3b_output);\n\nstatic ssize_t store_enable_clk3a_output(struct device *d,\n\t\t struct device_attribute *attr, const char *buf, size_t count)\n{\n\tunsigned long flags;\n\tunsigned long tmp;\n\tunsigned char val;\n\n\tsscanf(buf, \"%lX\", &tmp);\n\tdev_dbg(d, \"tmp = 0x%lX\\n\", tmp);\n\n\tval = (unsigned char)tmp;\n\tspin_lock_irqsave(&event_lock, flags);\n\tSET_PORT_BITS(TLCLK_REG3, 0xbf, val << 6);\n\tspin_unlock_irqrestore(&event_lock, flags);\n\n\treturn strnlen(buf, count);\n}\n\nstatic DEVICE_ATTR(enable_clk3a_output, (S_IWUSR|S_IWGRP), NULL,\n\t\tstore_enable_clk3a_output);\n\nstatic ssize_t store_enable_clkb1_output(struct device *d,\n\t\t struct device_attribute *attr, const char *buf, size_t count)\n{\n\tunsigned long flags;\n\tunsigned long tmp;\n\tunsigned char val;\n\n\tsscanf(buf, \"%lX\", &tmp);\n\tdev_dbg(d, \"tmp = 0x%lX\\n\", tmp);\n\n\tval = (unsigned char)tmp;\n\tspin_lock_irqsave(&event_lock, flags);\n\tSET_PORT_BITS(TLCLK_REG2, 0xf7, val << 3);\n\tspin_unlock_irqrestore(&event_lock, flags);\n\n\treturn strnlen(buf, count);\n}\n\nstatic DEVICE_ATTR(enable_clkb1_output, (S_IWUSR|S_IWGRP), NULL,\n\t\tstore_enable_clkb1_output);\n\n\nstatic ssize_t store_enable_clka1_output(struct device *d,\n\t\t struct device_attribute *attr, const char *buf, size_t count)\n{\n\tunsigned long flags;\n\tunsigned long tmp;\n\tunsigned char val;\n\n\tsscanf(buf, \"%lX\", &tmp);\n\tdev_dbg(d, \"tmp = 0x%lX\\n\", tmp);\n\n\tval = (unsigned char)tmp;\n\tspin_lock_irqsave(&event_lock, flags);\n\tSET_PORT_BITS(TLCLK_REG2, 0xfb, val << 2);\n\tspin_unlock_irqrestore(&event_lock, flags);\n\n\treturn strnlen(buf, count);\n}\n\nstatic DEVICE_ATTR(enable_clka1_output, (S_IWUSR|S_IWGRP), NULL,\n\t\tstore_enable_clka1_output);\n\nstatic ssize_t store_enable_clkb0_output(struct device *d,\n\t\t struct device_attribute *attr, const char *buf, size_t count)\n{\n\tunsigned long flags;\n\tunsigned long tmp;\n\tunsigned char val;\n\n\tsscanf(buf, \"%lX\", &tmp);\n\tdev_dbg(d, \"tmp = 0x%lX\\n\", tmp);\n\n\tval = (unsigned char)tmp;\n\tspin_lock_irqsave(&event_lock, flags);\n\tSET_PORT_BITS(TLCLK_REG2, 0xfd, val << 1);\n\tspin_unlock_irqrestore(&event_lock, flags);\n\n\treturn strnlen(buf, count);\n}\n\nstatic DEVICE_ATTR(enable_clkb0_output, (S_IWUSR|S_IWGRP), NULL,\n\t\tstore_enable_clkb0_output);\n\nstatic ssize_t store_enable_clka0_output(struct device *d,\n\t\t struct device_attribute *attr, const char *buf, size_t count)\n{\n\tunsigned long flags;\n\tunsigned long tmp;\n\tunsigned char val;\n\n\tsscanf(buf, \"%lX\", &tmp);\n\tdev_dbg(d, \"tmp = 0x%lX\\n\", tmp);\n\n\tval = (unsigned char)tmp;\n\tspin_lock_irqsave(&event_lock, flags);\n\tSET_PORT_BITS(TLCLK_REG2, 0xfe, val);\n\tspin_unlock_irqrestore(&event_lock, flags);\n\n\treturn strnlen(buf, count);\n}\n\nstatic DEVICE_ATTR(enable_clka0_output, (S_IWUSR|S_IWGRP), NULL,\n\t\tstore_enable_clka0_output);\n\nstatic ssize_t store_select_amcb2_transmit_clock(struct device *d,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tunsigned long flags;\n\tunsigned long tmp;\n\tunsigned char val;\n\n\tsscanf(buf, \"%lX\", &tmp);\n\tdev_dbg(d, \"tmp = 0x%lX\\n\", tmp);\n\n\tval = (unsigned char)tmp;\n\tspin_lock_irqsave(&event_lock, flags);\n\tif ((val == CLK_8kHz) || (val == CLK_16_384MHz)) {\n\t\tSET_PORT_BITS(TLCLK_REG3, 0xc7, 0x28);\n\t\tSET_PORT_BITS(TLCLK_REG1, 0xfb, ~val);\n\t} else if (val >= CLK_8_592MHz) {\n\t\tSET_PORT_BITS(TLCLK_REG3, 0xc7, 0x38);\n\t\tswitch (val) {\n\t\tcase CLK_8_592MHz:\n\t\t\tSET_PORT_BITS(TLCLK_REG0, 0xfc, 2);\n\t\t\tbreak;\n\t\tcase CLK_11_184MHz:\n\t\t\tSET_PORT_BITS(TLCLK_REG0, 0xfc, 0);\n\t\t\tbreak;\n\t\tcase CLK_34_368MHz:\n\t\t\tSET_PORT_BITS(TLCLK_REG0, 0xfc, 3);\n\t\t\tbreak;\n\t\tcase CLK_44_736MHz:\n\t\t\tSET_PORT_BITS(TLCLK_REG0, 0xfc, 1);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tSET_PORT_BITS(TLCLK_REG3, 0xc7, val << 3);\n\t}\n\tspin_unlock_irqrestore(&event_lock, flags);\n\n\treturn strnlen(buf, count);\n}\n\nstatic DEVICE_ATTR(select_amcb2_transmit_clock, (S_IWUSR|S_IWGRP), NULL,\n\tstore_select_amcb2_transmit_clock);\n\nstatic ssize_t store_select_amcb1_transmit_clock(struct device *d,\n\t\t struct device_attribute *attr, const char *buf, size_t count)\n{\n\tunsigned long tmp;\n\tunsigned char val;\n\tunsigned long flags;\n\n\tsscanf(buf, \"%lX\", &tmp);\n\tdev_dbg(d, \"tmp = 0x%lX\\n\", tmp);\n\n\tval = (unsigned char)tmp;\n\tspin_lock_irqsave(&event_lock, flags);\n\tif ((val == CLK_8kHz) || (val == CLK_16_384MHz)) {\n\t\tSET_PORT_BITS(TLCLK_REG3, 0xf8, 0x5);\n\t\tSET_PORT_BITS(TLCLK_REG1, 0xfb, ~val);\n\t} else if (val >= CLK_8_592MHz) {\n\t\tSET_PORT_BITS(TLCLK_REG3, 0xf8, 0x7);\n\t\tswitch (val) {\n\t\tcase CLK_8_592MHz:\n\t\t\tSET_PORT_BITS(TLCLK_REG0, 0xfc, 2);\n\t\t\tbreak;\n\t\tcase CLK_11_184MHz:\n\t\t\tSET_PORT_BITS(TLCLK_REG0, 0xfc, 0);\n\t\t\tbreak;\n\t\tcase CLK_34_368MHz:\n\t\t\tSET_PORT_BITS(TLCLK_REG0, 0xfc, 3);\n\t\t\tbreak;\n\t\tcase CLK_44_736MHz:\n\t\t\tSET_PORT_BITS(TLCLK_REG0, 0xfc, 1);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tSET_PORT_BITS(TLCLK_REG3, 0xf8, val);\n\t}\n\tspin_unlock_irqrestore(&event_lock, flags);\n\n\treturn strnlen(buf, count);\n}\n\nstatic DEVICE_ATTR(select_amcb1_transmit_clock, (S_IWUSR|S_IWGRP), NULL,\n\t\tstore_select_amcb1_transmit_clock);\n\nstatic ssize_t store_select_redundant_clock(struct device *d,\n\t\t struct device_attribute *attr, const char *buf, size_t count)\n{\n\tunsigned long tmp;\n\tunsigned char val;\n\tunsigned long flags;\n\n\tsscanf(buf, \"%lX\", &tmp);\n\tdev_dbg(d, \"tmp = 0x%lX\\n\", tmp);\n\n\tval = (unsigned char)tmp;\n\tspin_lock_irqsave(&event_lock, flags);\n\tSET_PORT_BITS(TLCLK_REG1, 0xfe, val);\n\tspin_unlock_irqrestore(&event_lock, flags);\n\n\treturn strnlen(buf, count);\n}\n\nstatic DEVICE_ATTR(select_redundant_clock, (S_IWUSR|S_IWGRP), NULL,\n\t\tstore_select_redundant_clock);\n\nstatic ssize_t store_select_ref_frequency(struct device *d,\n\t\t struct device_attribute *attr, const char *buf, size_t count)\n{\n\tunsigned long tmp;\n\tunsigned char val;\n\tunsigned long flags;\n\n\tsscanf(buf, \"%lX\", &tmp);\n\tdev_dbg(d, \"tmp = 0x%lX\\n\", tmp);\n\n\tval = (unsigned char)tmp;\n\tspin_lock_irqsave(&event_lock, flags);\n\tSET_PORT_BITS(TLCLK_REG1, 0xfd, val);\n\tspin_unlock_irqrestore(&event_lock, flags);\n\n\treturn strnlen(buf, count);\n}\n\nstatic DEVICE_ATTR(select_ref_frequency, (S_IWUSR|S_IWGRP), NULL,\n\t\tstore_select_ref_frequency);\n\nstatic ssize_t store_filter_select(struct device *d,\n\t\t struct device_attribute *attr, const char *buf, size_t count)\n{\n\tunsigned long tmp;\n\tunsigned char val;\n\tunsigned long flags;\n\n\tsscanf(buf, \"%lX\", &tmp);\n\tdev_dbg(d, \"tmp = 0x%lX\\n\", tmp);\n\n\tval = (unsigned char)tmp;\n\tspin_lock_irqsave(&event_lock, flags);\n\tSET_PORT_BITS(TLCLK_REG0, 0xfb, val);\n\tspin_unlock_irqrestore(&event_lock, flags);\n\n\treturn strnlen(buf, count);\n}\n\nstatic DEVICE_ATTR(filter_select, (S_IWUSR|S_IWGRP), NULL, store_filter_select);\n\nstatic ssize_t store_hardware_switching_mode(struct device *d,\n\t\t struct device_attribute *attr, const char *buf, size_t count)\n{\n\tunsigned long tmp;\n\tunsigned char val;\n\tunsigned long flags;\n\n\tsscanf(buf, \"%lX\", &tmp);\n\tdev_dbg(d, \"tmp = 0x%lX\\n\", tmp);\n\n\tval = (unsigned char)tmp;\n\tspin_lock_irqsave(&event_lock, flags);\n\tSET_PORT_BITS(TLCLK_REG0, 0xbf, val);\n\tspin_unlock_irqrestore(&event_lock, flags);\n\n\treturn strnlen(buf, count);\n}\n\nstatic DEVICE_ATTR(hardware_switching_mode, (S_IWUSR|S_IWGRP), NULL,\n\t\tstore_hardware_switching_mode);\n\nstatic ssize_t store_hardware_switching(struct device *d,\n\t\t struct device_attribute *attr, const char *buf, size_t count)\n{\n\tunsigned long tmp;\n\tunsigned char val;\n\tunsigned long flags;\n\n\tsscanf(buf, \"%lX\", &tmp);\n\tdev_dbg(d, \"tmp = 0x%lX\\n\", tmp);\n\n\tval = (unsigned char)tmp;\n\tspin_lock_irqsave(&event_lock, flags);\n\tSET_PORT_BITS(TLCLK_REG0, 0x7f, val);\n\tspin_unlock_irqrestore(&event_lock, flags);\n\n\treturn strnlen(buf, count);\n}\n\nstatic DEVICE_ATTR(hardware_switching, (S_IWUSR|S_IWGRP), NULL,\n\t\tstore_hardware_switching);\n\nstatic ssize_t store_refalign (struct device *d,\n\t\t struct device_attribute *attr, const char *buf, size_t count)\n{\n\tunsigned long tmp;\n\tunsigned long flags;\n\n\tsscanf(buf, \"%lX\", &tmp);\n\tdev_dbg(d, \"tmp = 0x%lX\\n\", tmp);\n\tspin_lock_irqsave(&event_lock, flags);\n\tSET_PORT_BITS(TLCLK_REG0, 0xf7, 0);\n\tSET_PORT_BITS(TLCLK_REG0, 0xf7, 0x08);\n\tSET_PORT_BITS(TLCLK_REG0, 0xf7, 0);\n\tspin_unlock_irqrestore(&event_lock, flags);\n\n\treturn strnlen(buf, count);\n}\n\nstatic DEVICE_ATTR(refalign, (S_IWUSR|S_IWGRP), NULL, store_refalign);\n\nstatic ssize_t store_mode_select (struct device *d,\n\t\t struct device_attribute *attr, const char *buf, size_t count)\n{\n\tunsigned long tmp;\n\tunsigned char val;\n\tunsigned long flags;\n\n\tsscanf(buf, \"%lX\", &tmp);\n\tdev_dbg(d, \"tmp = 0x%lX\\n\", tmp);\n\n\tval = (unsigned char)tmp;\n\tspin_lock_irqsave(&event_lock, flags);\n\tSET_PORT_BITS(TLCLK_REG0, 0xcf, val);\n\tspin_unlock_irqrestore(&event_lock, flags);\n\n\treturn strnlen(buf, count);\n}\n\nstatic DEVICE_ATTR(mode_select, (S_IWUSR|S_IWGRP), NULL, store_mode_select);\n\nstatic ssize_t store_reset (struct device *d,\n\t\t struct device_attribute *attr, const char *buf, size_t count)\n{\n\tunsigned long tmp;\n\tunsigned char val;\n\tunsigned long flags;\n\n\tsscanf(buf, \"%lX\", &tmp);\n\tdev_dbg(d, \"tmp = 0x%lX\\n\", tmp);\n\n\tval = (unsigned char)tmp;\n\tspin_lock_irqsave(&event_lock, flags);\n\tSET_PORT_BITS(TLCLK_REG4, 0xfd, val);\n\tspin_unlock_irqrestore(&event_lock, flags);\n\n\treturn strnlen(buf, count);\n}\n\nstatic DEVICE_ATTR(reset, (S_IWUSR|S_IWGRP), NULL, store_reset);\n\nstatic struct attribute *tlclk_sysfs_entries[] = {\n\t&dev_attr_current_ref.attr,\n\t&dev_attr_telclock_version.attr,\n\t&dev_attr_alarms.attr,\n\t&dev_attr_received_ref_clk3a.attr,\n\t&dev_attr_received_ref_clk3b.attr,\n\t&dev_attr_enable_clk3a_output.attr,\n\t&dev_attr_enable_clk3b_output.attr,\n\t&dev_attr_enable_clkb1_output.attr,\n\t&dev_attr_enable_clka1_output.attr,\n\t&dev_attr_enable_clkb0_output.attr,\n\t&dev_attr_enable_clka0_output.attr,\n\t&dev_attr_select_amcb1_transmit_clock.attr,\n\t&dev_attr_select_amcb2_transmit_clock.attr,\n\t&dev_attr_select_redundant_clock.attr,\n\t&dev_attr_select_ref_frequency.attr,\n\t&dev_attr_filter_select.attr,\n\t&dev_attr_hardware_switching_mode.attr,\n\t&dev_attr_hardware_switching.attr,\n\t&dev_attr_refalign.attr,\n\t&dev_attr_mode_select.attr,\n\t&dev_attr_reset.attr,\n\tNULL\n};\n\nstatic const struct attribute_group tlclk_attribute_group = {\n\t.name = NULL,\t\t \n\t.attrs = tlclk_sysfs_entries,\n};\n\nstatic struct platform_device *tlclk_device;\n\nstatic int __init tlclk_init(void)\n{\n\tint ret;\n\n\ttelclk_interrupt = (inb(TLCLK_REG7) & 0x0f);\n\n\talarm_events = kzalloc( sizeof(struct tlclk_alarms), GFP_KERNEL);\n\tif (!alarm_events) {\n\t\tret = -ENOMEM;\n\t\tgoto out1;\n\t}\n\n\tret = register_chrdev(tlclk_major, \"telco_clock\", &tlclk_fops);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR \"tlclk: can't get major %d.\\n\", tlclk_major);\n\t\tkfree(alarm_events);\n\t\treturn ret;\n\t}\n\ttlclk_major = ret;\n\n\t \n\tif (!request_region(TLCLK_BASE, 8, \"telco_clock\")) {\n\t\tprintk(KERN_ERR \"tlclk: request_region 0x%X failed.\\n\",\n\t\t\tTLCLK_BASE);\n\t\tret = -EBUSY;\n\t\tgoto out2;\n\t}\n\n\tif (0x0F == telclk_interrupt ) {  \n\t\tprintk(KERN_ERR \"telclk_interrupt = 0x%x non-mcpbl0010 hw.\\n\",\n\t\t\ttelclk_interrupt);\n\t\tret = -ENXIO;\n\t\tgoto out3;\n\t}\n\n\ttimer_setup(&switchover_timer, switchover_timeout, 0);\n\n\tret = misc_register(&tlclk_miscdev);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR \"tlclk: misc_register returns %d.\\n\", ret);\n\t\tgoto out3;\n\t}\n\n\ttlclk_device = platform_device_register_simple(\"telco_clock\",\n\t\t\t\t-1, NULL, 0);\n\tif (IS_ERR(tlclk_device)) {\n\t\tprintk(KERN_ERR \"tlclk: platform_device_register failed.\\n\");\n\t\tret = PTR_ERR(tlclk_device);\n\t\tgoto out4;\n\t}\n\n\tret = sysfs_create_group(&tlclk_device->dev.kobj,\n\t\t\t&tlclk_attribute_group);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"tlclk: failed to create sysfs device attributes.\\n\");\n\t\tgoto out5;\n\t}\n\n\treturn 0;\nout5:\n\tplatform_device_unregister(tlclk_device);\nout4:\n\tmisc_deregister(&tlclk_miscdev);\nout3:\n\trelease_region(TLCLK_BASE, 8);\nout2:\n\tkfree(alarm_events);\n\tunregister_chrdev(tlclk_major, \"telco_clock\");\nout1:\n\treturn ret;\n}\n\nstatic void __exit tlclk_cleanup(void)\n{\n\tsysfs_remove_group(&tlclk_device->dev.kobj, &tlclk_attribute_group);\n\tplatform_device_unregister(tlclk_device);\n\tmisc_deregister(&tlclk_miscdev);\n\tunregister_chrdev(tlclk_major, \"telco_clock\");\n\n\trelease_region(TLCLK_BASE, 8);\n\tdel_timer_sync(&switchover_timer);\n\tkfree(alarm_events);\n\n}\n\nstatic void switchover_timeout(struct timer_list *unused)\n{\n\tunsigned long flags = tlclk_timer_data;\n\n\tif ((flags & 1)) {\n\t\tif ((inb(TLCLK_REG1) & 0x08) != (flags & 0x08))\n\t\t\talarm_events->switchover_primary++;\n\t} else {\n\t\tif ((inb(TLCLK_REG1) & 0x08) != (flags & 0x08))\n\t\t\talarm_events->switchover_secondary++;\n\t}\n\n\t \n\tdel_timer(&switchover_timer);\n\tgot_event = 1;\n\twake_up(&wq);\n}\n\nstatic irqreturn_t tlclk_interrupt(int irq, void *dev_id)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&event_lock, flags);\n\t \n\tint_events = inb(TLCLK_REG6);\n\n\t \n\tif (int_events & PRI_LOS_01_MASK) {\n\t\tif (inb(TLCLK_REG2) & SEC_LOST_MASK)\n\t\t\talarm_events->lost_clocks++;\n\t\telse\n\t\t\talarm_events->lost_primary_clock++;\n\t}\n\n\t \n\tif (int_events & PRI_LOS_10_MASK) {\n\t\talarm_events->primary_clock_back++;\n\t\tSET_PORT_BITS(TLCLK_REG1, 0xFE, 1);\n\t}\n\t \n\tif (int_events & SEC_LOS_01_MASK) {\n\t\tif (inb(TLCLK_REG2) & PRI_LOST_MASK)\n\t\t\talarm_events->lost_clocks++;\n\t\telse\n\t\t\talarm_events->lost_secondary_clock++;\n\t}\n\t \n\tif (int_events & SEC_LOS_10_MASK) {\n\t\talarm_events->secondary_clock_back++;\n\t\tSET_PORT_BITS(TLCLK_REG1, 0xFE, 0);\n\t}\n\tif (int_events & HOLDOVER_10_MASK)\n\t\talarm_events->pll_end_holdover++;\n\n\tif (int_events & UNLOCK_01_MASK)\n\t\talarm_events->pll_lost_sync++;\n\n\tif (int_events & UNLOCK_10_MASK)\n\t\talarm_events->pll_sync++;\n\n\t \n\tif (int_events & HOLDOVER_01_MASK) {\n\t\talarm_events->pll_holdover++;\n\n\t\t \n\t\tswitchover_timer.expires = jiffies + msecs_to_jiffies(10);\n\t\ttlclk_timer_data = inb(TLCLK_REG1);\n\t\tmod_timer(&switchover_timer, switchover_timer.expires);\n\t} else {\n\t\tgot_event = 1;\n\t\twake_up(&wq);\n\t}\n\tspin_unlock_irqrestore(&event_lock, flags);\n\n\treturn IRQ_HANDLED;\n}\n\nmodule_init(tlclk_init);\nmodule_exit(tlclk_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}