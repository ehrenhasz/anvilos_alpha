{
  "module_name": "mwavedd.c",
  "hash_id": "df4162f38bb32846b4449ba64b5cda5876962d2d5d2de3aa61bcb35758cd4304",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/mwave/mwavedd.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/major.h>\n#include <linux/miscdevice.h>\n#include <linux/device.h>\n#include <linux/serial.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/serial_8250.h>\n#include <linux/nospec.h>\n#include \"smapi.h\"\n#include \"mwavedd.h\"\n#include \"3780i.h\"\n#include \"tp3780i.h\"\n\nMODULE_DESCRIPTION(\"3780i Advanced Communications Processor (Mwave) driver\");\nMODULE_AUTHOR(\"Mike Sullivan and Paul Schroeder\");\nMODULE_LICENSE(\"GPL\");\n\n \nstatic DEFINE_MUTEX(mwave_mutex);\nint mwave_debug = 0;\nint mwave_3780i_irq = 0;\nint mwave_3780i_io = 0;\nint mwave_uart_irq = 0;\nint mwave_uart_io = 0;\nmodule_param(mwave_debug, int, 0);\nmodule_param_hw(mwave_3780i_irq, int, irq, 0);\nmodule_param_hw(mwave_3780i_io, int, ioport, 0);\nmodule_param_hw(mwave_uart_irq, int, irq, 0);\nmodule_param_hw(mwave_uart_io, int, ioport, 0);\n\nstatic int mwave_open(struct inode *inode, struct file *file);\nstatic int mwave_close(struct inode *inode, struct file *file);\nstatic long mwave_ioctl(struct file *filp, unsigned int iocmd,\n\t\t\t\t\t\t\tunsigned long ioarg);\n\nMWAVE_DEVICE_DATA mwave_s_mdd;\n\nstatic int mwave_open(struct inode *inode, struct file *file)\n{\n\tunsigned int retval = 0;\n\n\tPRINTK_3(TRACE_MWAVE,\n\t\t\"mwavedd::mwave_open, entry inode %p file %p\\n\",\n\t\t inode, file);\n\tPRINTK_2(TRACE_MWAVE,\n\t\t\"mwavedd::mwave_open, exit return retval %x\\n\", retval);\n\n\treturn retval;\n}\n\nstatic int mwave_close(struct inode *inode, struct file *file)\n{\n\tunsigned int retval = 0;\n\n\tPRINTK_3(TRACE_MWAVE,\n\t\t\"mwavedd::mwave_close, entry inode %p file %p\\n\",\n\t\t inode,  file);\n\n\tPRINTK_2(TRACE_MWAVE, \"mwavedd::mwave_close, exit retval %x\\n\",\n\t\tretval);\n\n\treturn retval;\n}\n\nstatic long mwave_ioctl(struct file *file, unsigned int iocmd,\n\t\t\t\t\t\t\tunsigned long ioarg)\n{\n\tunsigned int retval = 0;\n\tpMWAVE_DEVICE_DATA pDrvData = &mwave_s_mdd;\n\tvoid __user *arg = (void __user *)ioarg;\n\n\tPRINTK_4(TRACE_MWAVE,\n\t\t\"mwavedd::mwave_ioctl, entry file %p cmd %x arg %x\\n\",\n\t\tfile, iocmd, (int) ioarg);\n\n\tswitch (iocmd) {\n\n\t\tcase IOCTL_MW_RESET:\n\t\t\tPRINTK_1(TRACE_MWAVE,\n\t\t\t\t\"mwavedd::mwave_ioctl, IOCTL_MW_RESET\"\n\t\t\t\t\" calling tp3780I_ResetDSP\\n\");\n\t\t\tmutex_lock(&mwave_mutex);\n\t\t\tretval = tp3780I_ResetDSP(&pDrvData->rBDData);\n\t\t\tmutex_unlock(&mwave_mutex);\n\t\t\tPRINTK_2(TRACE_MWAVE,\n\t\t\t\t\"mwavedd::mwave_ioctl, IOCTL_MW_RESET\"\n\t\t\t\t\" retval %x from tp3780I_ResetDSP\\n\",\n\t\t\t\tretval);\n\t\t\tbreak;\n\t\n\t\tcase IOCTL_MW_RUN:\n\t\t\tPRINTK_1(TRACE_MWAVE,\n\t\t\t\t\"mwavedd::mwave_ioctl, IOCTL_MW_RUN\"\n\t\t\t\t\" calling tp3780I_StartDSP\\n\");\n\t\t\tmutex_lock(&mwave_mutex);\n\t\t\tretval = tp3780I_StartDSP(&pDrvData->rBDData);\n\t\t\tmutex_unlock(&mwave_mutex);\n\t\t\tPRINTK_2(TRACE_MWAVE,\n\t\t\t\t\"mwavedd::mwave_ioctl, IOCTL_MW_RUN\"\n\t\t\t\t\" retval %x from tp3780I_StartDSP\\n\",\n\t\t\t\tretval);\n\t\t\tbreak;\n\t\n\t\tcase IOCTL_MW_DSP_ABILITIES: {\n\t\t\tMW_ABILITIES rAbilities;\n\t\n\t\t\tPRINTK_1(TRACE_MWAVE,\n\t\t\t\t\"mwavedd::mwave_ioctl,\"\n\t\t\t\t\" IOCTL_MW_DSP_ABILITIES calling\"\n\t\t\t\t\" tp3780I_QueryAbilities\\n\");\n\t\t\tmutex_lock(&mwave_mutex);\n\t\t\tretval = tp3780I_QueryAbilities(&pDrvData->rBDData,\n\t\t\t\t\t&rAbilities);\n\t\t\tmutex_unlock(&mwave_mutex);\n\t\t\tPRINTK_2(TRACE_MWAVE,\n\t\t\t\t\"mwavedd::mwave_ioctl, IOCTL_MW_DSP_ABILITIES\"\n\t\t\t\t\" retval %x from tp3780I_QueryAbilities\\n\",\n\t\t\t\tretval);\n\t\t\tif (retval == 0) {\n\t\t\t\tif( copy_to_user(arg, &rAbilities,\n\t\t\t\t\t\t\tsizeof(MW_ABILITIES)) )\n\t\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t\tPRINTK_2(TRACE_MWAVE,\n\t\t\t\t\"mwavedd::mwave_ioctl, IOCTL_MW_DSP_ABILITIES\"\n\t\t\t\t\" exit retval %x\\n\",\n\t\t\t\tretval);\n\t\t}\n\t\t\tbreak;\n\t\n\t\tcase IOCTL_MW_READ_DATA:\n\t\tcase IOCTL_MW_READCLEAR_DATA: {\n\t\t\tMW_READWRITE rReadData;\n\t\t\tunsigned short __user *pusBuffer = NULL;\n\t\n\t\t\tif( copy_from_user(&rReadData, arg,\n\t\t\t\t\t\tsizeof(MW_READWRITE)) )\n\t\t\t\treturn -EFAULT;\n\t\t\tpusBuffer = (unsigned short __user *) (rReadData.pBuf);\n\t\n\t\t\tPRINTK_4(TRACE_MWAVE,\n\t\t\t\t\"mwavedd::mwave_ioctl IOCTL_MW_READ_DATA,\"\n\t\t\t\t\" size %lx, ioarg %lx pusBuffer %p\\n\",\n\t\t\t\trReadData.ulDataLength, ioarg, pusBuffer);\n\t\t\tmutex_lock(&mwave_mutex);\n\t\t\tretval = tp3780I_ReadWriteDspDStore(&pDrvData->rBDData,\n\t\t\t\t\tiocmd,\n\t\t\t\t\tpusBuffer,\n\t\t\t\t\trReadData.ulDataLength,\n\t\t\t\t\trReadData.usDspAddress);\n\t\t\tmutex_unlock(&mwave_mutex);\n\t\t}\n\t\t\tbreak;\n\t\n\t\tcase IOCTL_MW_READ_INST: {\n\t\t\tMW_READWRITE rReadData;\n\t\t\tunsigned short __user *pusBuffer = NULL;\n\t\n\t\t\tif( copy_from_user(&rReadData, arg,\n\t\t\t\t\t\tsizeof(MW_READWRITE)) )\n\t\t\t\treturn -EFAULT;\n\t\t\tpusBuffer = (unsigned short __user *) (rReadData.pBuf);\n\t\n\t\t\tPRINTK_4(TRACE_MWAVE,\n\t\t\t\t\"mwavedd::mwave_ioctl IOCTL_MW_READ_INST,\"\n\t\t\t\t\" size %lx, ioarg %lx pusBuffer %p\\n\",\n\t\t\t\trReadData.ulDataLength / 2, ioarg,\n\t\t\t\tpusBuffer);\n\t\t\tmutex_lock(&mwave_mutex);\n\t\t\tretval = tp3780I_ReadWriteDspDStore(&pDrvData->rBDData,\n\t\t\t\tiocmd, pusBuffer,\n\t\t\t\trReadData.ulDataLength / 2,\n\t\t\t\trReadData.usDspAddress);\n\t\t\tmutex_unlock(&mwave_mutex);\n\t\t}\n\t\t\tbreak;\n\t\n\t\tcase IOCTL_MW_WRITE_DATA: {\n\t\t\tMW_READWRITE rWriteData;\n\t\t\tunsigned short __user *pusBuffer = NULL;\n\t\n\t\t\tif( copy_from_user(&rWriteData, arg,\n\t\t\t\t\t\tsizeof(MW_READWRITE)) )\n\t\t\t\treturn -EFAULT;\n\t\t\tpusBuffer = (unsigned short __user *) (rWriteData.pBuf);\n\t\n\t\t\tPRINTK_4(TRACE_MWAVE,\n\t\t\t\t\"mwavedd::mwave_ioctl IOCTL_MW_WRITE_DATA,\"\n\t\t\t\t\" size %lx, ioarg %lx pusBuffer %p\\n\",\n\t\t\t\trWriteData.ulDataLength, ioarg,\n\t\t\t\tpusBuffer);\n\t\t\tmutex_lock(&mwave_mutex);\n\t\t\tretval = tp3780I_ReadWriteDspDStore(&pDrvData->rBDData,\n\t\t\t\t\tiocmd, pusBuffer,\n\t\t\t\t\trWriteData.ulDataLength,\n\t\t\t\t\trWriteData.usDspAddress);\n\t\t\tmutex_unlock(&mwave_mutex);\n\t\t}\n\t\t\tbreak;\n\t\n\t\tcase IOCTL_MW_WRITE_INST: {\n\t\t\tMW_READWRITE rWriteData;\n\t\t\tunsigned short __user *pusBuffer = NULL;\n\t\n\t\t\tif( copy_from_user(&rWriteData, arg,\n\t\t\t\t\t\tsizeof(MW_READWRITE)) )\n\t\t\t\treturn -EFAULT;\n\t\t\tpusBuffer = (unsigned short __user *)(rWriteData.pBuf);\n\t\n\t\t\tPRINTK_4(TRACE_MWAVE,\n\t\t\t\t\"mwavedd::mwave_ioctl IOCTL_MW_WRITE_INST,\"\n\t\t\t\t\" size %lx, ioarg %lx pusBuffer %p\\n\",\n\t\t\t\trWriteData.ulDataLength, ioarg,\n\t\t\t\tpusBuffer);\n\t\t\tmutex_lock(&mwave_mutex);\n\t\t\tretval = tp3780I_ReadWriteDspIStore(&pDrvData->rBDData,\n\t\t\t\t\tiocmd, pusBuffer,\n\t\t\t\t\trWriteData.ulDataLength,\n\t\t\t\t\trWriteData.usDspAddress);\n\t\t\tmutex_unlock(&mwave_mutex);\n\t\t}\n\t\t\tbreak;\n\t\n\t\tcase IOCTL_MW_REGISTER_IPC: {\n\t\t\tunsigned int ipcnum = (unsigned int) ioarg;\n\t\n\t\t\tif (ipcnum >= ARRAY_SIZE(pDrvData->IPCs)) {\n\t\t\t\tPRINTK_ERROR(KERN_ERR_MWAVE\n\t\t\t\t\t\t\"mwavedd::mwave_ioctl:\"\n\t\t\t\t\t\t\" IOCTL_MW_REGISTER_IPC:\"\n\t\t\t\t\t\t\" Error: Invalid ipcnum %x\\n\",\n\t\t\t\t\t\tipcnum);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tipcnum = array_index_nospec(ipcnum,\n\t\t\t\t\t\t    ARRAY_SIZE(pDrvData->IPCs));\n\t\t\tPRINTK_3(TRACE_MWAVE,\n\t\t\t\t\"mwavedd::mwave_ioctl IOCTL_MW_REGISTER_IPC\"\n\t\t\t\t\" ipcnum %x entry usIntCount %x\\n\",\n\t\t\t\tipcnum,\n\t\t\t\tpDrvData->IPCs[ipcnum].usIntCount);\n\n\t\t\tmutex_lock(&mwave_mutex);\n\t\t\tpDrvData->IPCs[ipcnum].bIsHere = false;\n\t\t\tpDrvData->IPCs[ipcnum].bIsEnabled = true;\n\t\t\tmutex_unlock(&mwave_mutex);\n\t\n\t\t\tPRINTK_2(TRACE_MWAVE,\n\t\t\t\t\"mwavedd::mwave_ioctl IOCTL_MW_REGISTER_IPC\"\n\t\t\t\t\" ipcnum %x exit\\n\",\n\t\t\t\tipcnum);\n\t\t}\n\t\t\tbreak;\n\t\n\t\tcase IOCTL_MW_GET_IPC: {\n\t\t\tunsigned int ipcnum = (unsigned int) ioarg;\n\t\n\t\t\tif (ipcnum >= ARRAY_SIZE(pDrvData->IPCs)) {\n\t\t\t\tPRINTK_ERROR(KERN_ERR_MWAVE\n\t\t\t\t\t\t\"mwavedd::mwave_ioctl:\"\n\t\t\t\t\t\t\" IOCTL_MW_GET_IPC: Error:\"\n\t\t\t\t\t\t\" Invalid ipcnum %x\\n\", ipcnum);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tipcnum = array_index_nospec(ipcnum,\n\t\t\t\t\t\t    ARRAY_SIZE(pDrvData->IPCs));\n\t\t\tPRINTK_3(TRACE_MWAVE,\n\t\t\t\t\"mwavedd::mwave_ioctl IOCTL_MW_GET_IPC\"\n\t\t\t\t\" ipcnum %x, usIntCount %x\\n\",\n\t\t\t\tipcnum,\n\t\t\t\tpDrvData->IPCs[ipcnum].usIntCount);\n\t\n\t\t\tmutex_lock(&mwave_mutex);\n\t\t\tif (pDrvData->IPCs[ipcnum].bIsEnabled == true) {\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tPRINTK_2(TRACE_MWAVE,\n\t\t\t\t\t\"mwavedd::mwave_ioctl, thread for\"\n\t\t\t\t\t\" ipc %x going to sleep\\n\",\n\t\t\t\t\tipcnum);\n\t\t\t\tadd_wait_queue(&pDrvData->IPCs[ipcnum].ipc_wait_queue, &wait);\n\t\t\t\tpDrvData->IPCs[ipcnum].bIsHere = true;\n\t\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tif (pDrvData->IPCs[ipcnum].usIntCount == 1) {\t \n\t\t\t\t\tpDrvData->IPCs[ipcnum].usIntCount = 2;\t \n\t\t\t\t\tPRINTK_2(TRACE_MWAVE,\n\t\t\t\t\t\t\"mwavedd::mwave_ioctl\"\n\t\t\t\t\t\t\" IOCTL_MW_GET_IPC ipcnum %x\"\n\t\t\t\t\t\t\" handling first int\\n\",\n\t\t\t\t\t\tipcnum);\n\t\t\t\t} else {\t \n\t\t\t\t\tschedule();\n\t\t\t\t\tif (pDrvData->IPCs[ipcnum].usIntCount == 1) {\n\t\t\t\t\t\tpDrvData->IPCs[ipcnum].usIntCount = 2;\n\t\t\t\t\t}\n\t\t\t\t\tPRINTK_2(TRACE_MWAVE,\n\t\t\t\t\t\t\"mwavedd::mwave_ioctl\"\n\t\t\t\t\t\t\" IOCTL_MW_GET_IPC ipcnum %x\"\n\t\t\t\t\t\t\" woke up and returning to\"\n\t\t\t\t\t\t\" application\\n\",\n\t\t\t\t\t\tipcnum);\n\t\t\t\t}\n\t\t\t\tpDrvData->IPCs[ipcnum].bIsHere = false;\n\t\t\t\tremove_wait_queue(&pDrvData->IPCs[ipcnum].ipc_wait_queue, &wait);\n\t\t\t\tset_current_state(TASK_RUNNING);\n\t\t\t\tPRINTK_2(TRACE_MWAVE,\n\t\t\t\t\t\"mwavedd::mwave_ioctl IOCTL_MW_GET_IPC,\"\n\t\t\t\t\t\" returning thread for ipc %x\"\n\t\t\t\t\t\" processing\\n\",\n\t\t\t\t\tipcnum);\n\t\t\t}\n\t\t\tmutex_unlock(&mwave_mutex);\n\t\t}\n\t\t\tbreak;\n\t\n\t\tcase IOCTL_MW_UNREGISTER_IPC: {\n\t\t\tunsigned int ipcnum = (unsigned int) ioarg;\n\t\n\t\t\tPRINTK_2(TRACE_MWAVE,\n\t\t\t\t\"mwavedd::mwave_ioctl IOCTL_MW_UNREGISTER_IPC\"\n\t\t\t\t\" ipcnum %x\\n\",\n\t\t\t\tipcnum);\n\t\t\tif (ipcnum >= ARRAY_SIZE(pDrvData->IPCs)) {\n\t\t\t\tPRINTK_ERROR(KERN_ERR_MWAVE\n\t\t\t\t\t\t\"mwavedd::mwave_ioctl:\"\n\t\t\t\t\t\t\" IOCTL_MW_UNREGISTER_IPC:\"\n\t\t\t\t\t\t\" Error: Invalid ipcnum %x\\n\",\n\t\t\t\t\t\tipcnum);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tipcnum = array_index_nospec(ipcnum,\n\t\t\t\t\t\t    ARRAY_SIZE(pDrvData->IPCs));\n\t\t\tmutex_lock(&mwave_mutex);\n\t\t\tif (pDrvData->IPCs[ipcnum].bIsEnabled == true) {\n\t\t\t\tpDrvData->IPCs[ipcnum].bIsEnabled = false;\n\t\t\t\tif (pDrvData->IPCs[ipcnum].bIsHere == true) {\n\t\t\t\t\twake_up_interruptible(&pDrvData->IPCs[ipcnum].ipc_wait_queue);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmutex_unlock(&mwave_mutex);\n\t\t}\n\t\t\tbreak;\n\t\n\t\tdefault:\n\t\t\treturn -ENOTTY;\n\t}  \n\n\tPRINTK_2(TRACE_MWAVE, \"mwavedd::mwave_ioctl, exit retval %x\\n\", retval);\n\n\treturn retval;\n}\n\n\nstatic ssize_t mwave_read(struct file *file, char __user *buf, size_t count,\n                          loff_t * ppos)\n{\n\tPRINTK_5(TRACE_MWAVE,\n\t\t\"mwavedd::mwave_read entry file %p, buf %p, count %zx ppos %p\\n\",\n\t\tfile, buf, count, ppos);\n\n\treturn -EINVAL;\n}\n\n\nstatic ssize_t mwave_write(struct file *file, const char __user *buf,\n                           size_t count, loff_t * ppos)\n{\n\tPRINTK_5(TRACE_MWAVE,\n\t\t\"mwavedd::mwave_write entry file %p, buf %p,\"\n\t\t\" count %zx ppos %p\\n\",\n\t\tfile, buf, count, ppos);\n\n\treturn -EINVAL;\n}\n\n\nstatic int register_serial_portandirq(unsigned int port, int irq)\n{\n\tstruct uart_8250_port uart;\n\t\n\tswitch ( port ) {\n\t\tcase 0x3f8:\n\t\tcase 0x2f8:\n\t\tcase 0x3e8:\n\t\tcase 0x2e8:\n\t\t\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPRINTK_ERROR(KERN_ERR_MWAVE\n\t\t\t\t\t\"mwavedd::register_serial_portandirq:\"\n\t\t\t\t\t\" Error: Illegal port %x\\n\", port );\n\t\t\treturn -1;\n\t}  \n\t \n\n\tswitch ( irq ) {\n\t\tcase 3:\n\t\tcase 4:\n\t\tcase 5:\n\t\tcase 7:\n\t\t\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPRINTK_ERROR(KERN_ERR_MWAVE\n\t\t\t\t\t\"mwavedd::register_serial_portandirq:\"\n\t\t\t\t\t\" Error: Illegal irq %x\\n\", irq );\n\t\t\treturn -1;\n\t}  \n\t \n\n\tmemset(&uart, 0, sizeof(uart));\n\t\n\tuart.port.uartclk =  1843200;\n\tuart.port.iobase = port;\n\tuart.port.irq = irq;\n\tuart.port.iotype = UPIO_PORT;\n\tuart.port.flags =  UPF_SHARE_IRQ;\n\treturn serial8250_register_8250_port(&uart);\n}\n\n\nstatic const struct file_operations mwave_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.read\t\t= mwave_read,\n\t.write\t\t= mwave_write,\n\t.unlocked_ioctl\t= mwave_ioctl,\n\t.open\t\t= mwave_open,\n\t.release\t= mwave_close,\n\t.llseek\t\t= default_llseek,\n};\n\n\nstatic struct miscdevice mwave_misc_dev = { MWAVE_MINOR, \"mwave\", &mwave_fops };\n\n#if 0  \n \n\nstruct device mwave_device;\n\n \n#define mwave_show_function(attr_name, format_string, field)\t\t\\\nstatic ssize_t mwave_show_##attr_name(struct device *dev, struct device_attribute *attr, char *buf)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tDSP_3780I_CONFIG_SETTINGS *pSettings =\t\t\t\t\\\n\t\t&mwave_s_mdd.rBDData.rDspSettings;\t\t\t\\\n        return sprintf(buf, format_string, pSettings->field);\t\t\\\n}\n\n \n#define mwave_dev_rd_attr(attr_name, format_string, field)\t\t\\\n\tmwave_show_function(attr_name, format_string, field)\t\t\\\nstatic DEVICE_ATTR(attr_name, S_IRUGO, mwave_show_##attr_name, NULL)\n\nmwave_dev_rd_attr (3780i_dma, \"%i\\n\", usDspDma);\nmwave_dev_rd_attr (3780i_irq, \"%i\\n\", usDspIrq);\nmwave_dev_rd_attr (3780i_io, \"%#.4x\\n\", usDspBaseIO);\nmwave_dev_rd_attr (uart_irq, \"%i\\n\", usUartIrq);\nmwave_dev_rd_attr (uart_io, \"%#.4x\\n\", usUartBaseIO);\n\nstatic struct device_attribute * const mwave_dev_attrs[] = {\n\t&dev_attr_3780i_dma,\n\t&dev_attr_3780i_irq,\n\t&dev_attr_3780i_io,\n\t&dev_attr_uart_irq,\n\t&dev_attr_uart_io,\n};\n#endif\n\n \nstatic void mwave_exit(void)\n{\n\tpMWAVE_DEVICE_DATA pDrvData = &mwave_s_mdd;\n\n\tPRINTK_1(TRACE_MWAVE, \"mwavedd::mwave_exit entry\\n\");\n\n#if 0\n\tfor (i = 0; i < pDrvData->nr_registered_attrs; i++)\n\t\tdevice_remove_file(&mwave_device, mwave_dev_attrs[i]);\n\tpDrvData->nr_registered_attrs = 0;\n\n\tif (pDrvData->device_registered) {\n\t\tdevice_unregister(&mwave_device);\n\t\tpDrvData->device_registered = false;\n\t}\n#endif\n\n\tif ( pDrvData->sLine >= 0 ) {\n\t\tserial8250_unregister_port(pDrvData->sLine);\n\t}\n\tif (pDrvData->bMwaveDevRegistered) {\n\t\tmisc_deregister(&mwave_misc_dev);\n\t}\n\tif (pDrvData->bDSPEnabled) {\n\t\ttp3780I_DisableDSP(&pDrvData->rBDData);\n\t}\n\tif (pDrvData->bResourcesClaimed) {\n\t\ttp3780I_ReleaseResources(&pDrvData->rBDData);\n\t}\n\tif (pDrvData->bBDInitialized) {\n\t\ttp3780I_Cleanup(&pDrvData->rBDData);\n\t}\n\n\tPRINTK_1(TRACE_MWAVE, \"mwavedd::mwave_exit exit\\n\");\n}\n\nmodule_exit(mwave_exit);\n\nstatic int __init mwave_init(void)\n{\n\tint i;\n\tint retval = 0;\n\tpMWAVE_DEVICE_DATA pDrvData = &mwave_s_mdd;\n\n\tPRINTK_1(TRACE_MWAVE, \"mwavedd::mwave_init entry\\n\");\n\n\tmemset(&mwave_s_mdd, 0, sizeof(MWAVE_DEVICE_DATA));\n\n\tpDrvData->bBDInitialized = false;\n\tpDrvData->bResourcesClaimed = false;\n\tpDrvData->bDSPEnabled = false;\n\tpDrvData->bDSPReset = false;\n\tpDrvData->bMwaveDevRegistered = false;\n\tpDrvData->sLine = -1;\n\n\tfor (i = 0; i < ARRAY_SIZE(pDrvData->IPCs); i++) {\n\t\tpDrvData->IPCs[i].bIsEnabled = false;\n\t\tpDrvData->IPCs[i].bIsHere = false;\n\t\tpDrvData->IPCs[i].usIntCount = 0;\t \n\t\tinit_waitqueue_head(&pDrvData->IPCs[i].ipc_wait_queue);\n\t}\n\n\tretval = tp3780I_InitializeBoardData(&pDrvData->rBDData);\n\tPRINTK_2(TRACE_MWAVE,\n\t\t\"mwavedd::mwave_init, return from tp3780I_InitializeBoardData\"\n\t\t\" retval %x\\n\",\n\t\tretval);\n\tif (retval) {\n\t\tPRINTK_ERROR(KERN_ERR_MWAVE\n\t\t\t\t\"mwavedd::mwave_init: Error:\"\n\t\t\t\t\" Failed to initialize board data\\n\");\n\t\tgoto cleanup_error;\n\t}\n\tpDrvData->bBDInitialized = true;\n\n\tretval = tp3780I_CalcResources(&pDrvData->rBDData);\n\tPRINTK_2(TRACE_MWAVE,\n\t\t\"mwavedd::mwave_init, return from tp3780I_CalcResources\"\n\t\t\" retval %x\\n\",\n\t\tretval);\n\tif (retval) {\n\t\tPRINTK_ERROR(KERN_ERR_MWAVE\n\t\t\t\t\"mwavedd:mwave_init: Error:\"\n\t\t\t\t\" Failed to calculate resources\\n\");\n\t\tgoto cleanup_error;\n\t}\n\n\tretval = tp3780I_ClaimResources(&pDrvData->rBDData);\n\tPRINTK_2(TRACE_MWAVE,\n\t\t\"mwavedd::mwave_init, return from tp3780I_ClaimResources\"\n\t\t\" retval %x\\n\",\n\t\tretval);\n\tif (retval) {\n\t\tPRINTK_ERROR(KERN_ERR_MWAVE\n\t\t\t\t\"mwavedd:mwave_init: Error:\"\n\t\t\t\t\" Failed to claim resources\\n\");\n\t\tgoto cleanup_error;\n\t}\n\tpDrvData->bResourcesClaimed = true;\n\n\tretval = tp3780I_EnableDSP(&pDrvData->rBDData);\n\tPRINTK_2(TRACE_MWAVE,\n\t\t\"mwavedd::mwave_init, return from tp3780I_EnableDSP\"\n\t\t\" retval %x\\n\",\n\t\tretval);\n\tif (retval) {\n\t\tPRINTK_ERROR(KERN_ERR_MWAVE\n\t\t\t\t\"mwavedd:mwave_init: Error:\"\n\t\t\t\t\" Failed to enable DSP\\n\");\n\t\tgoto cleanup_error;\n\t}\n\tpDrvData->bDSPEnabled = true;\n\n\tif (misc_register(&mwave_misc_dev) < 0) {\n\t\tPRINTK_ERROR(KERN_ERR_MWAVE\n\t\t\t\t\"mwavedd:mwave_init: Error:\"\n\t\t\t\t\" Failed to register misc device\\n\");\n\t\tgoto cleanup_error;\n\t}\n\tpDrvData->bMwaveDevRegistered = true;\n\n\tpDrvData->sLine = register_serial_portandirq(\n\t\tpDrvData->rBDData.rDspSettings.usUartBaseIO,\n\t\tpDrvData->rBDData.rDspSettings.usUartIrq\n\t);\n\tif (pDrvData->sLine < 0) {\n\t\tPRINTK_ERROR(KERN_ERR_MWAVE\n\t\t\t\t\"mwavedd:mwave_init: Error:\"\n\t\t\t\t\" Failed to register serial driver\\n\");\n\t\tgoto cleanup_error;\n\t}\n\t \n\n#if 0\n\t \n\tmemset(&mwave_device, 0, sizeof (struct device));\n\tdev_set_name(&mwave_device, \"mwave\");\n\n\tif (device_register(&mwave_device))\n\t\tgoto cleanup_error;\n\tpDrvData->device_registered = true;\n\tfor (i = 0; i < ARRAY_SIZE(mwave_dev_attrs); i++) {\n\t\tif(device_create_file(&mwave_device, mwave_dev_attrs[i])) {\n\t\t\tPRINTK_ERROR(KERN_ERR_MWAVE\n\t\t\t\t\t\"mwavedd:mwave_init: Error:\"\n\t\t\t\t\t\" Failed to create sysfs file %s\\n\",\n\t\t\t\t\tmwave_dev_attrs[i]->attr.name);\n\t\t\tgoto cleanup_error;\n\t\t}\n\t\tpDrvData->nr_registered_attrs++;\n\t}\n#endif\n\n\t \n\treturn 0;\n\ncleanup_error:\n\tPRINTK_ERROR(KERN_ERR_MWAVE\n\t\t\t\"mwavedd::mwave_init: Error:\"\n\t\t\t\" Failed to initialize\\n\");\n\tmwave_exit();  \n\n\treturn -EIO;\n}\n\nmodule_init(mwave_init);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}