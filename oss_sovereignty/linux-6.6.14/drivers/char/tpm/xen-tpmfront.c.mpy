{
  "module_name": "xen-tpmfront.c",
  "hash_id": "9c261c1ccc6d4c05406e1b34646ae1d7b0b5ff4e3e6fea1004a7db997da838bc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/tpm/xen-tpmfront.c",
  "human_readable_source": "\n \n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/freezer.h>\n#include <xen/xen.h>\n#include <xen/events.h>\n#include <xen/interface/io/tpmif.h>\n#include <xen/grant_table.h>\n#include <xen/xenbus.h>\n#include <xen/page.h>\n#include \"tpm.h\"\n#include <xen/platform_pci.h>\n\nstruct tpm_private {\n\tstruct tpm_chip *chip;\n\tstruct xenbus_device *dev;\n\n\tstruct vtpm_shared_page *shr;\n\n\tunsigned int evtchn;\n\tint ring_ref;\n\tdomid_t backend_id;\n\tint irq;\n\twait_queue_head_t read_queue;\n};\n\nenum status_bits {\n\tVTPM_STATUS_RUNNING  = 0x1,\n\tVTPM_STATUS_IDLE     = 0x2,\n\tVTPM_STATUS_RESULT   = 0x4,\n\tVTPM_STATUS_CANCELED = 0x8,\n};\n\nstatic bool wait_for_tpm_stat_cond(struct tpm_chip *chip, u8 mask,\n\t\t\t\t\tbool check_cancel, bool *canceled)\n{\n\tu8 status = chip->ops->status(chip);\n\n\t*canceled = false;\n\tif ((status & mask) == mask)\n\t\treturn true;\n\tif (check_cancel && chip->ops->req_canceled(chip, status)) {\n\t\t*canceled = true;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic int wait_for_tpm_stat(struct tpm_chip *chip, u8 mask,\n\t\tunsigned long timeout, wait_queue_head_t *queue,\n\t\tbool check_cancel)\n{\n\tunsigned long stop;\n\tlong rc;\n\tu8 status;\n\tbool canceled = false;\n\n\t \n\tstatus = chip->ops->status(chip);\n\tif ((status & mask) == mask)\n\t\treturn 0;\n\n\tstop = jiffies + timeout;\n\n\tif (chip->flags & TPM_CHIP_FLAG_IRQ) {\nagain:\n\t\ttimeout = stop - jiffies;\n\t\tif ((long)timeout <= 0)\n\t\t\treturn -ETIME;\n\t\trc = wait_event_interruptible_timeout(*queue,\n\t\t\twait_for_tpm_stat_cond(chip, mask, check_cancel,\n\t\t\t\t\t       &canceled),\n\t\t\ttimeout);\n\t\tif (rc > 0) {\n\t\t\tif (canceled)\n\t\t\t\treturn -ECANCELED;\n\t\t\treturn 0;\n\t\t}\n\t\tif (rc == -ERESTARTSYS && freezing(current)) {\n\t\t\tclear_thread_flag(TIF_SIGPENDING);\n\t\t\tgoto again;\n\t\t}\n\t} else {\n\t\tdo {\n\t\t\ttpm_msleep(TPM_TIMEOUT);\n\t\t\tstatus = chip->ops->status(chip);\n\t\t\tif ((status & mask) == mask)\n\t\t\t\treturn 0;\n\t\t} while (time_before(jiffies, stop));\n\t}\n\treturn -ETIME;\n}\n\nstatic u8 vtpm_status(struct tpm_chip *chip)\n{\n\tstruct tpm_private *priv = dev_get_drvdata(&chip->dev);\n\tswitch (priv->shr->state) {\n\tcase VTPM_STATE_IDLE:\n\t\treturn VTPM_STATUS_IDLE | VTPM_STATUS_CANCELED;\n\tcase VTPM_STATE_FINISH:\n\t\treturn VTPM_STATUS_IDLE | VTPM_STATUS_RESULT;\n\tcase VTPM_STATE_SUBMIT:\n\tcase VTPM_STATE_CANCEL:  \n\t\treturn VTPM_STATUS_RUNNING;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic bool vtpm_req_canceled(struct tpm_chip *chip, u8 status)\n{\n\treturn status & VTPM_STATUS_CANCELED;\n}\n\nstatic void vtpm_cancel(struct tpm_chip *chip)\n{\n\tstruct tpm_private *priv = dev_get_drvdata(&chip->dev);\n\tpriv->shr->state = VTPM_STATE_CANCEL;\n\twmb();\n\tnotify_remote_via_evtchn(priv->evtchn);\n}\n\nstatic size_t shr_data_offset(struct vtpm_shared_page *shr)\n{\n\treturn struct_size(shr, extra_pages, shr->nr_extra_pages);\n}\n\nstatic int vtpm_send(struct tpm_chip *chip, u8 *buf, size_t count)\n{\n\tstruct tpm_private *priv = dev_get_drvdata(&chip->dev);\n\tstruct vtpm_shared_page *shr = priv->shr;\n\tsize_t offset = shr_data_offset(shr);\n\n\tu32 ordinal;\n\tunsigned long duration;\n\n\tif (offset > PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\tif (offset + count > PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\t \n\tif (wait_for_tpm_stat(chip, VTPM_STATUS_IDLE, chip->timeout_c,\n\t\t\t&priv->read_queue, true) < 0) {\n\t\tvtpm_cancel(chip);\n\t\treturn -ETIME;\n\t}\n\n\tmemcpy(offset + (u8 *)shr, buf, count);\n\tshr->length = count;\n\tbarrier();\n\tshr->state = VTPM_STATE_SUBMIT;\n\twmb();\n\tnotify_remote_via_evtchn(priv->evtchn);\n\n\tordinal = be32_to_cpu(((struct tpm_header *)buf)->ordinal);\n\tduration = tpm_calc_ordinal_duration(chip, ordinal);\n\n\tif (wait_for_tpm_stat(chip, VTPM_STATUS_IDLE, duration,\n\t\t\t&priv->read_queue, true) < 0) {\n\t\t \n\t\tvtpm_cancel(chip);\n\t\treturn -ETIME;\n\t}\n\n\treturn 0;\n}\n\nstatic int vtpm_recv(struct tpm_chip *chip, u8 *buf, size_t count)\n{\n\tstruct tpm_private *priv = dev_get_drvdata(&chip->dev);\n\tstruct vtpm_shared_page *shr = priv->shr;\n\tsize_t offset = shr_data_offset(shr);\n\tsize_t length = shr->length;\n\n\tif (shr->state == VTPM_STATE_IDLE)\n\t\treturn -ECANCELED;\n\n\t \n\tif (wait_for_tpm_stat(chip, VTPM_STATUS_RESULT, chip->timeout_c,\n\t\t\t&priv->read_queue, true) < 0) {\n\t\tvtpm_cancel(chip);\n\t\treturn -ETIME;\n\t}\n\n\tif (offset > PAGE_SIZE)\n\t\treturn -EIO;\n\n\tif (offset + length > PAGE_SIZE)\n\t\tlength = PAGE_SIZE - offset;\n\n\tif (length > count)\n\t\tlength = count;\n\n\tmemcpy(buf, offset + (u8 *)shr, length);\n\n\treturn length;\n}\n\nstatic const struct tpm_class_ops tpm_vtpm = {\n\t.status = vtpm_status,\n\t.recv = vtpm_recv,\n\t.send = vtpm_send,\n\t.cancel = vtpm_cancel,\n\t.req_complete_mask = VTPM_STATUS_IDLE | VTPM_STATUS_RESULT,\n\t.req_complete_val  = VTPM_STATUS_IDLE | VTPM_STATUS_RESULT,\n\t.req_canceled      = vtpm_req_canceled,\n};\n\nstatic irqreturn_t tpmif_interrupt(int dummy, void *dev_id)\n{\n\tstruct tpm_private *priv = dev_id;\n\n\tswitch (priv->shr->state) {\n\tcase VTPM_STATE_IDLE:\n\tcase VTPM_STATE_FINISH:\n\t\twake_up_interruptible(&priv->read_queue);\n\t\tbreak;\n\tcase VTPM_STATE_SUBMIT:\n\tcase VTPM_STATE_CANCEL:\n\tdefault:\n\t\tbreak;\n\t}\n\treturn IRQ_HANDLED;\n}\n\nstatic int setup_chip(struct device *dev, struct tpm_private *priv)\n{\n\tstruct tpm_chip *chip;\n\n\tchip = tpmm_chip_alloc(dev, &tpm_vtpm);\n\tif (IS_ERR(chip))\n\t\treturn PTR_ERR(chip);\n\n\tinit_waitqueue_head(&priv->read_queue);\n\n\tpriv->chip = chip;\n\tdev_set_drvdata(&chip->dev, priv);\n\n\treturn 0;\n}\n\n \nstatic int setup_ring(struct xenbus_device *dev, struct tpm_private *priv)\n{\n\tstruct xenbus_transaction xbt;\n\tconst char *message = NULL;\n\tint rv;\n\n\trv = xenbus_setup_ring(dev, GFP_KERNEL, (void **)&priv->shr, 1,\n\t\t\t       &priv->ring_ref);\n\tif (rv < 0)\n\t\treturn rv;\n\n\trv = xenbus_alloc_evtchn(dev, &priv->evtchn);\n\tif (rv)\n\t\treturn rv;\n\n\trv = bind_evtchn_to_irqhandler(priv->evtchn, tpmif_interrupt, 0,\n\t\t\t\t       \"tpmif\", priv);\n\tif (rv <= 0) {\n\t\txenbus_dev_fatal(dev, rv, \"allocating TPM irq\");\n\t\treturn rv;\n\t}\n\tpriv->irq = rv;\n\n again:\n\trv = xenbus_transaction_start(&xbt);\n\tif (rv) {\n\t\txenbus_dev_fatal(dev, rv, \"starting transaction\");\n\t\treturn rv;\n\t}\n\n\trv = xenbus_printf(xbt, dev->nodename,\n\t\t\t\"ring-ref\", \"%u\", priv->ring_ref);\n\tif (rv) {\n\t\tmessage = \"writing ring-ref\";\n\t\tgoto abort_transaction;\n\t}\n\n\trv = xenbus_printf(xbt, dev->nodename, \"event-channel\", \"%u\",\n\t\t\tpriv->evtchn);\n\tif (rv) {\n\t\tmessage = \"writing event-channel\";\n\t\tgoto abort_transaction;\n\t}\n\n\trv = xenbus_printf(xbt, dev->nodename, \"feature-protocol-v2\", \"1\");\n\tif (rv) {\n\t\tmessage = \"writing feature-protocol-v2\";\n\t\tgoto abort_transaction;\n\t}\n\n\trv = xenbus_transaction_end(xbt, 0);\n\tif (rv == -EAGAIN)\n\t\tgoto again;\n\tif (rv) {\n\t\txenbus_dev_fatal(dev, rv, \"completing transaction\");\n\t\treturn rv;\n\t}\n\n\txenbus_switch_state(dev, XenbusStateInitialised);\n\n\treturn 0;\n\n abort_transaction:\n\txenbus_transaction_end(xbt, 1);\n\tif (message)\n\t\txenbus_dev_error(dev, rv, \"%s\", message);\n\n\treturn rv;\n}\n\nstatic void ring_free(struct tpm_private *priv)\n{\n\tif (!priv)\n\t\treturn;\n\n\txenbus_teardown_ring((void **)&priv->shr, 1, &priv->ring_ref);\n\n\tif (priv->irq)\n\t\tunbind_from_irqhandler(priv->irq, priv);\n\n\tkfree(priv);\n}\n\nstatic int tpmfront_probe(struct xenbus_device *dev,\n\t\tconst struct xenbus_device_id *id)\n{\n\tstruct tpm_private *priv;\n\tint rv;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv) {\n\t\txenbus_dev_fatal(dev, -ENOMEM, \"allocating priv structure\");\n\t\treturn -ENOMEM;\n\t}\n\n\trv = setup_chip(&dev->dev, priv);\n\tif (rv) {\n\t\tkfree(priv);\n\t\treturn rv;\n\t}\n\n\trv = setup_ring(dev, priv);\n\tif (rv) {\n\t\tring_free(priv);\n\t\treturn rv;\n\t}\n\n\ttpm_get_timeouts(priv->chip);\n\n\treturn tpm_chip_register(priv->chip);\n}\n\nstatic void tpmfront_remove(struct xenbus_device *dev)\n{\n\tstruct tpm_chip *chip = dev_get_drvdata(&dev->dev);\n\tstruct tpm_private *priv = dev_get_drvdata(&chip->dev);\n\ttpm_chip_unregister(chip);\n\tring_free(priv);\n\tdev_set_drvdata(&chip->dev, NULL);\n}\n\nstatic int tpmfront_resume(struct xenbus_device *dev)\n{\n\t \n\ttpmfront_remove(dev);\n\treturn tpmfront_probe(dev, NULL);\n}\n\nstatic void backend_changed(struct xenbus_device *dev,\n\t\tenum xenbus_state backend_state)\n{\n\tswitch (backend_state) {\n\tcase XenbusStateInitialised:\n\tcase XenbusStateConnected:\n\t\tif (dev->state == XenbusStateConnected)\n\t\t\tbreak;\n\n\t\tif (!xenbus_read_unsigned(dev->otherend, \"feature-protocol-v2\",\n\t\t\t\t\t  0)) {\n\t\t\txenbus_dev_fatal(dev, -EINVAL,\n\t\t\t\t\t\"vTPM protocol 2 required\");\n\t\t\treturn;\n\t\t}\n\t\txenbus_switch_state(dev, XenbusStateConnected);\n\t\tbreak;\n\n\tcase XenbusStateClosing:\n\tcase XenbusStateClosed:\n\t\tdevice_unregister(&dev->dev);\n\t\txenbus_frontend_closed(dev);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic const struct xenbus_device_id tpmfront_ids[] = {\n\t{ \"vtpm\" },\n\t{ \"\" }\n};\nMODULE_ALIAS(\"xen:vtpm\");\n\nstatic struct xenbus_driver tpmfront_driver = {\n\t.ids = tpmfront_ids,\n\t.probe = tpmfront_probe,\n\t.remove = tpmfront_remove,\n\t.resume = tpmfront_resume,\n\t.otherend_changed = backend_changed,\n};\n\nstatic int __init xen_tpmfront_init(void)\n{\n\tif (!xen_domain())\n\t\treturn -ENODEV;\n\n\tif (!xen_has_pv_devices())\n\t\treturn -ENODEV;\n\n\treturn xenbus_register_frontend(&tpmfront_driver);\n}\nmodule_init(xen_tpmfront_init);\n\nstatic void __exit xen_tpmfront_exit(void)\n{\n\txenbus_unregister_driver(&tpmfront_driver);\n}\nmodule_exit(xen_tpmfront_exit);\n\nMODULE_AUTHOR(\"Daniel De Graaf <dgdegra@tycho.nsa.gov>\");\nMODULE_DESCRIPTION(\"Xen vTPM Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}