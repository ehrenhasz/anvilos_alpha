{
  "module_name": "tpm_atmel.h",
  "hash_id": "739abed3c5a35cc91f4d9d3fa99c154b6739ab1d8525c5c3a64343392470c083",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/tpm/tpm_atmel.h",
  "human_readable_source": " \n \n\nstruct tpm_atmel_priv {\n\tint region_size;\n\tint have_region;\n\tunsigned long base;\n\tvoid __iomem *iobase;\n};\n\n#ifdef CONFIG_PPC64\n\n#include <linux/of.h>\n\n#define atmel_getb(priv, offset) readb(priv->iobase + offset)\n#define atmel_putb(val, priv, offset) writeb(val, priv->iobase + offset)\n#define atmel_request_region request_mem_region\n#define atmel_release_region release_mem_region\n\nstatic inline void atmel_put_base_addr(void __iomem *iobase)\n{\n\tiounmap(iobase);\n}\n\nstatic void __iomem * atmel_get_base_addr(unsigned long *base, int *region_size)\n{\n\tstruct device_node *dn;\n\tunsigned long address, size;\n\tconst unsigned int *reg;\n\tint reglen;\n\tint naddrc;\n\tint nsizec;\n\n\tdn = of_find_node_by_name(NULL, \"tpm\");\n\n\tif (!dn)\n\t\treturn NULL;\n\n\tif (!of_device_is_compatible(dn, \"AT97SC3201\")) {\n\t\tof_node_put(dn);\n\t\treturn NULL;\n\t}\n\n\treg = of_get_property(dn, \"reg\", &reglen);\n\tnaddrc = of_n_addr_cells(dn);\n\tnsizec = of_n_size_cells(dn);\n\n\tof_node_put(dn);\n\n\n\tif (naddrc == 2)\n\t\taddress = ((unsigned long) reg[0] << 32) | reg[1];\n\telse\n\t\taddress = reg[0];\n\n\tif (nsizec == 2)\n\t\tsize =\n\t\t    ((unsigned long) reg[naddrc] << 32) | reg[naddrc + 1];\n\telse\n\t\tsize = reg[naddrc];\n\n\t*base = address;\n\t*region_size = size;\n\treturn ioremap(*base, *region_size);\n}\n#else\n#define atmel_getb(chip, offset) inb(atmel_get_priv(chip)->base + offset)\n#define atmel_putb(val, chip, offset) \\\n\toutb(val, atmel_get_priv(chip)->base + offset)\n#define atmel_request_region request_region\n#define atmel_release_region release_region\n \nenum tpm_atmel_addr {\n\tTPM_ATMEL_BASE_ADDR_LO = 0x08,\n\tTPM_ATMEL_BASE_ADDR_HI = 0x09\n};\n\nstatic inline int tpm_read_index(int base, int index)\n{\n\toutb(index, base);\n\treturn inb(base+1) & 0xFF;\n}\n\n \nstatic int atmel_verify_tpm11(void)\n{\n\n\t \n\tif (tpm_read_index(TPM_ADDR, 4) != 'A' ||\n\t    tpm_read_index(TPM_ADDR, 5) != 'T' ||\n\t    tpm_read_index(TPM_ADDR, 6) != 'M' ||\n\t    tpm_read_index(TPM_ADDR, 7) != 'L')\n\t\treturn 1;\n\n\t \n\tif (tpm_read_index(TPM_ADDR, 0x00) != 1 ||\n\t    tpm_read_index(TPM_ADDR, 0x01) != 1)\n\t\treturn 1;\n\n\t \n\treturn 0;\n}\n\nstatic inline void atmel_put_base_addr(void __iomem *iobase)\n{\n}\n\n \nstatic void __iomem * atmel_get_base_addr(unsigned long *base, int *region_size)\n{\n\tint lo, hi;\n\n\tif (atmel_verify_tpm11() != 0)\n\t\treturn NULL;\n\n\tlo = tpm_read_index(TPM_ADDR, TPM_ATMEL_BASE_ADDR_LO);\n\thi = tpm_read_index(TPM_ADDR, TPM_ATMEL_BASE_ADDR_HI);\n\n\t*base = (hi << 8) | lo;\n\t*region_size = 2;\n\n\treturn ioport_map(*base, *region_size);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}