{
  "module_name": "tpm-dev-common.c",
  "hash_id": "662e652877625584402ea07c47ab3276b91927c00f038a6bc33334ed9706f667",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/tpm/tpm-dev-common.c",
  "human_readable_source": "\n \n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/workqueue.h>\n#include \"tpm.h\"\n#include \"tpm-dev.h\"\n\nstatic struct workqueue_struct *tpm_dev_wq;\n\nstatic ssize_t tpm_dev_transmit(struct tpm_chip *chip, struct tpm_space *space,\n\t\t\t\tu8 *buf, size_t bufsiz)\n{\n\tstruct tpm_header *header = (void *)buf;\n\tssize_t ret, len;\n\n\tret = tpm2_prepare_space(chip, space, buf, bufsiz);\n\t \n\tif (ret == -EOPNOTSUPP) {\n\t\theader->length = cpu_to_be32(sizeof(*header));\n\t\theader->tag = cpu_to_be16(TPM2_ST_NO_SESSIONS);\n\t\theader->return_code = cpu_to_be32(TPM2_RC_COMMAND_CODE |\n\t\t\t\t\t\t  TSS2_RESMGR_TPM_RC_LAYER);\n\t\tret = sizeof(*header);\n\t}\n\tif (ret)\n\t\tgoto out_rc;\n\n\tlen = tpm_transmit(chip, buf, bufsiz);\n\tif (len < 0)\n\t\tret = len;\n\n\tif (!ret)\n\t\tret = tpm2_commit_space(chip, space, buf, &len);\n\nout_rc:\n\treturn ret ? ret : len;\n}\n\nstatic void tpm_dev_async_work(struct work_struct *work)\n{\n\tstruct file_priv *priv =\n\t\t\tcontainer_of(work, struct file_priv, async_work);\n\tssize_t ret;\n\n\tmutex_lock(&priv->buffer_mutex);\n\tpriv->command_enqueued = false;\n\tret = tpm_try_get_ops(priv->chip);\n\tif (ret) {\n\t\tpriv->response_length = ret;\n\t\tgoto out;\n\t}\n\n\tret = tpm_dev_transmit(priv->chip, priv->space, priv->data_buffer,\n\t\t\t       sizeof(priv->data_buffer));\n\ttpm_put_ops(priv->chip);\n\n\t \n\tif (ret != 0) {\n\t\tpriv->response_length = ret;\n\t\tmod_timer(&priv->user_read_timer, jiffies + (120 * HZ));\n\t}\nout:\n\tmutex_unlock(&priv->buffer_mutex);\n\twake_up_interruptible(&priv->async_wait);\n}\n\nstatic void user_reader_timeout(struct timer_list *t)\n{\n\tstruct file_priv *priv = from_timer(priv, t, user_read_timer);\n\n\tpr_warn(\"TPM user space timeout is deprecated (pid=%d)\\n\",\n\t\ttask_tgid_nr(current));\n\n\tschedule_work(&priv->timeout_work);\n}\n\nstatic void tpm_timeout_work(struct work_struct *work)\n{\n\tstruct file_priv *priv = container_of(work, struct file_priv,\n\t\t\t\t\t      timeout_work);\n\n\tmutex_lock(&priv->buffer_mutex);\n\tpriv->response_read = true;\n\tpriv->response_length = 0;\n\tmemset(priv->data_buffer, 0, sizeof(priv->data_buffer));\n\tmutex_unlock(&priv->buffer_mutex);\n\twake_up_interruptible(&priv->async_wait);\n}\n\nvoid tpm_common_open(struct file *file, struct tpm_chip *chip,\n\t\t     struct file_priv *priv, struct tpm_space *space)\n{\n\tpriv->chip = chip;\n\tpriv->space = space;\n\tpriv->response_read = true;\n\n\tmutex_init(&priv->buffer_mutex);\n\ttimer_setup(&priv->user_read_timer, user_reader_timeout, 0);\n\tINIT_WORK(&priv->timeout_work, tpm_timeout_work);\n\tINIT_WORK(&priv->async_work, tpm_dev_async_work);\n\tinit_waitqueue_head(&priv->async_wait);\n\tfile->private_data = priv;\n}\n\nssize_t tpm_common_read(struct file *file, char __user *buf,\n\t\t\tsize_t size, loff_t *off)\n{\n\tstruct file_priv *priv = file->private_data;\n\tssize_t ret_size = 0;\n\tint rc;\n\n\tmutex_lock(&priv->buffer_mutex);\n\n\tif (priv->response_length) {\n\t\tpriv->response_read = true;\n\n\t\tret_size = min_t(ssize_t, size, priv->response_length);\n\t\tif (ret_size <= 0) {\n\t\t\tpriv->response_length = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\trc = copy_to_user(buf, priv->data_buffer + *off, ret_size);\n\t\tif (rc) {\n\t\t\tmemset(priv->data_buffer, 0, TPM_BUFSIZE);\n\t\t\tpriv->response_length = 0;\n\t\t\tret_size = -EFAULT;\n\t\t} else {\n\t\t\tmemset(priv->data_buffer + *off, 0, ret_size);\n\t\t\tpriv->response_length -= ret_size;\n\t\t\t*off += ret_size;\n\t\t}\n\t}\n\nout:\n\tif (!priv->response_length) {\n\t\t*off = 0;\n\t\tdel_timer_sync(&priv->user_read_timer);\n\t\tflush_work(&priv->timeout_work);\n\t}\n\tmutex_unlock(&priv->buffer_mutex);\n\treturn ret_size;\n}\n\nssize_t tpm_common_write(struct file *file, const char __user *buf,\n\t\t\t size_t size, loff_t *off)\n{\n\tstruct file_priv *priv = file->private_data;\n\tint ret = 0;\n\n\tif (size > TPM_BUFSIZE)\n\t\treturn -E2BIG;\n\n\tmutex_lock(&priv->buffer_mutex);\n\n\t \n\tif ((!priv->response_read && priv->response_length) ||\n\t    priv->command_enqueued) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tif (copy_from_user(priv->data_buffer, buf, size)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (size < 6 ||\n\t    size < be32_to_cpu(*((__be32 *)(priv->data_buffer + 2)))) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tpriv->response_length = 0;\n\tpriv->response_read = false;\n\t*off = 0;\n\n\t \n\tif (file->f_flags & O_NONBLOCK) {\n\t\tpriv->command_enqueued = true;\n\t\tqueue_work(tpm_dev_wq, &priv->async_work);\n\t\tmutex_unlock(&priv->buffer_mutex);\n\t\treturn size;\n\t}\n\n\t \n\tif (tpm_try_get_ops(priv->chip)) {\n\t\tret = -EPIPE;\n\t\tgoto out;\n\t}\n\n\tret = tpm_dev_transmit(priv->chip, priv->space, priv->data_buffer,\n\t\t\t       sizeof(priv->data_buffer));\n\ttpm_put_ops(priv->chip);\n\n\tif (ret > 0) {\n\t\tpriv->response_length = ret;\n\t\tmod_timer(&priv->user_read_timer, jiffies + (120 * HZ));\n\t\tret = size;\n\t}\nout:\n\tmutex_unlock(&priv->buffer_mutex);\n\treturn ret;\n}\n\n__poll_t tpm_common_poll(struct file *file, poll_table *wait)\n{\n\tstruct file_priv *priv = file->private_data;\n\t__poll_t mask = 0;\n\n\tpoll_wait(file, &priv->async_wait, wait);\n\tmutex_lock(&priv->buffer_mutex);\n\n\t \n\tif (priv->response_length)\n\t\tmask = EPOLLIN | EPOLLRDNORM;\n\telse\n\t\tmask = EPOLLOUT | EPOLLWRNORM;\n\n\tmutex_unlock(&priv->buffer_mutex);\n\treturn mask;\n}\n\n \nvoid tpm_common_release(struct file *file, struct file_priv *priv)\n{\n\tflush_work(&priv->async_work);\n\tdel_timer_sync(&priv->user_read_timer);\n\tflush_work(&priv->timeout_work);\n\tfile->private_data = NULL;\n\tpriv->response_length = 0;\n}\n\nint __init tpm_dev_common_init(void)\n{\n\ttpm_dev_wq = alloc_workqueue(\"tpm_dev_wq\", WQ_MEM_RECLAIM, 0);\n\n\treturn !tpm_dev_wq ? -ENOMEM : 0;\n}\n\nvoid __exit tpm_dev_common_exit(void)\n{\n\tif (tpm_dev_wq) {\n\t\tdestroy_workqueue(tpm_dev_wq);\n\t\ttpm_dev_wq = NULL;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}