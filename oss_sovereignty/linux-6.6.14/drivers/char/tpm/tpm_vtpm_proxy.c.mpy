{
  "module_name": "tpm_vtpm_proxy.c",
  "hash_id": "77525bc36b72f5d4d17480e5a9b5ba069f3d9f9ff810a8c5579ff3e29a831ece",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/tpm/tpm_vtpm_proxy.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/uaccess.h>\n#include <linux/wait.h>\n#include <linux/miscdevice.h>\n#include <linux/vtpm_proxy.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/poll.h>\n#include <linux/compat.h>\n\n#include \"tpm.h\"\n\n#define VTPM_PROXY_REQ_COMPLETE_FLAG  BIT(0)\n\nstruct proxy_dev {\n\tstruct tpm_chip *chip;\n\n\tu32 flags;                    \n\n\twait_queue_head_t wq;\n\n\tstruct mutex buf_lock;        \n\n\tlong state;                   \n#define STATE_OPENED_FLAG        BIT(0)\n#define STATE_WAIT_RESPONSE_FLAG BIT(1)   \n#define STATE_REGISTERED_FLAG\t BIT(2)\n#define STATE_DRIVER_COMMAND     BIT(3)   \n\n\tsize_t req_len;               \n\tsize_t resp_len;              \n\tu8 buffer[TPM_BUFSIZE];       \n\n\tstruct work_struct work;      \n};\n\n \n#define VTPM_PROXY_FLAGS_ALL  (VTPM_PROXY_FLAG_TPM2)\n\nstatic struct workqueue_struct *workqueue;\n\nstatic void vtpm_proxy_delete_device(struct proxy_dev *proxy_dev);\n\n \n\n \nstatic ssize_t vtpm_proxy_fops_read(struct file *filp, char __user *buf,\n\t\t\t\t    size_t count, loff_t *off)\n{\n\tstruct proxy_dev *proxy_dev = filp->private_data;\n\tsize_t len;\n\tint sig, rc;\n\n\tsig = wait_event_interruptible(proxy_dev->wq,\n\t\tproxy_dev->req_len != 0 ||\n\t\t!(proxy_dev->state & STATE_OPENED_FLAG));\n\tif (sig)\n\t\treturn -EINTR;\n\n\tmutex_lock(&proxy_dev->buf_lock);\n\n\tif (!(proxy_dev->state & STATE_OPENED_FLAG)) {\n\t\tmutex_unlock(&proxy_dev->buf_lock);\n\t\treturn -EPIPE;\n\t}\n\n\tlen = proxy_dev->req_len;\n\n\tif (count < len || len > sizeof(proxy_dev->buffer)) {\n\t\tmutex_unlock(&proxy_dev->buf_lock);\n\t\tpr_debug(\"Invalid size in recv: count=%zd, req_len=%zd\\n\",\n\t\t\t count, len);\n\t\treturn -EIO;\n\t}\n\n\trc = copy_to_user(buf, proxy_dev->buffer, len);\n\tmemset(proxy_dev->buffer, 0, len);\n\tproxy_dev->req_len = 0;\n\n\tif (!rc)\n\t\tproxy_dev->state |= STATE_WAIT_RESPONSE_FLAG;\n\n\tmutex_unlock(&proxy_dev->buf_lock);\n\n\tif (rc)\n\t\treturn -EFAULT;\n\n\treturn len;\n}\n\n \nstatic ssize_t vtpm_proxy_fops_write(struct file *filp, const char __user *buf,\n\t\t\t\t     size_t count, loff_t *off)\n{\n\tstruct proxy_dev *proxy_dev = filp->private_data;\n\n\tmutex_lock(&proxy_dev->buf_lock);\n\n\tif (!(proxy_dev->state & STATE_OPENED_FLAG)) {\n\t\tmutex_unlock(&proxy_dev->buf_lock);\n\t\treturn -EPIPE;\n\t}\n\n\tif (count > sizeof(proxy_dev->buffer) ||\n\t    !(proxy_dev->state & STATE_WAIT_RESPONSE_FLAG)) {\n\t\tmutex_unlock(&proxy_dev->buf_lock);\n\t\treturn -EIO;\n\t}\n\n\tproxy_dev->state &= ~STATE_WAIT_RESPONSE_FLAG;\n\n\tproxy_dev->req_len = 0;\n\n\tif (copy_from_user(proxy_dev->buffer, buf, count)) {\n\t\tmutex_unlock(&proxy_dev->buf_lock);\n\t\treturn -EFAULT;\n\t}\n\n\tproxy_dev->resp_len = count;\n\n\tmutex_unlock(&proxy_dev->buf_lock);\n\n\twake_up_interruptible(&proxy_dev->wq);\n\n\treturn count;\n}\n\n \nstatic __poll_t vtpm_proxy_fops_poll(struct file *filp, poll_table *wait)\n{\n\tstruct proxy_dev *proxy_dev = filp->private_data;\n\t__poll_t ret;\n\n\tpoll_wait(filp, &proxy_dev->wq, wait);\n\n\tret = EPOLLOUT;\n\n\tmutex_lock(&proxy_dev->buf_lock);\n\n\tif (proxy_dev->req_len)\n\t\tret |= EPOLLIN | EPOLLRDNORM;\n\n\tif (!(proxy_dev->state & STATE_OPENED_FLAG))\n\t\tret |= EPOLLHUP;\n\n\tmutex_unlock(&proxy_dev->buf_lock);\n\n\treturn ret;\n}\n\n \nstatic void vtpm_proxy_fops_open(struct file *filp)\n{\n\tstruct proxy_dev *proxy_dev = filp->private_data;\n\n\tproxy_dev->state |= STATE_OPENED_FLAG;\n}\n\n \nstatic void vtpm_proxy_fops_undo_open(struct proxy_dev *proxy_dev)\n{\n\tmutex_lock(&proxy_dev->buf_lock);\n\n\tproxy_dev->state &= ~STATE_OPENED_FLAG;\n\n\tmutex_unlock(&proxy_dev->buf_lock);\n\n\t \n\twake_up_interruptible(&proxy_dev->wq);\n}\n\n \nstatic int vtpm_proxy_fops_release(struct inode *inode, struct file *filp)\n{\n\tstruct proxy_dev *proxy_dev = filp->private_data;\n\n\tfilp->private_data = NULL;\n\n\tvtpm_proxy_delete_device(proxy_dev);\n\n\treturn 0;\n}\n\nstatic const struct file_operations vtpm_proxy_fops = {\n\t.owner = THIS_MODULE,\n\t.llseek = no_llseek,\n\t.read = vtpm_proxy_fops_read,\n\t.write = vtpm_proxy_fops_write,\n\t.poll = vtpm_proxy_fops_poll,\n\t.release = vtpm_proxy_fops_release,\n};\n\n \n\n \nstatic int vtpm_proxy_tpm_op_recv(struct tpm_chip *chip, u8 *buf, size_t count)\n{\n\tstruct proxy_dev *proxy_dev = dev_get_drvdata(&chip->dev);\n\tsize_t len;\n\n\t \n\tmutex_lock(&proxy_dev->buf_lock);\n\n\tif (!(proxy_dev->state & STATE_OPENED_FLAG)) {\n\t\tmutex_unlock(&proxy_dev->buf_lock);\n\t\treturn -EPIPE;\n\t}\n\n\tlen = proxy_dev->resp_len;\n\tif (count < len) {\n\t\tdev_err(&chip->dev,\n\t\t\t\"Invalid size in recv: count=%zd, resp_len=%zd\\n\",\n\t\t\tcount, len);\n\t\tlen = -EIO;\n\t\tgoto out;\n\t}\n\n\tmemcpy(buf, proxy_dev->buffer, len);\n\tproxy_dev->resp_len = 0;\n\nout:\n\tmutex_unlock(&proxy_dev->buf_lock);\n\n\treturn len;\n}\n\nstatic int vtpm_proxy_is_driver_command(struct tpm_chip *chip,\n\t\t\t\t\tu8 *buf, size_t count)\n{\n\tstruct tpm_header *hdr = (struct tpm_header *)buf;\n\n\tif (count < sizeof(struct tpm_header))\n\t\treturn 0;\n\n\tif (chip->flags & TPM_CHIP_FLAG_TPM2) {\n\t\tswitch (be32_to_cpu(hdr->ordinal)) {\n\t\tcase TPM2_CC_SET_LOCALITY:\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\tswitch (be32_to_cpu(hdr->ordinal)) {\n\t\tcase TPM_ORD_SET_LOCALITY:\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int vtpm_proxy_tpm_op_send(struct tpm_chip *chip, u8 *buf, size_t count)\n{\n\tstruct proxy_dev *proxy_dev = dev_get_drvdata(&chip->dev);\n\n\tif (count > sizeof(proxy_dev->buffer)) {\n\t\tdev_err(&chip->dev,\n\t\t\t\"Invalid size in send: count=%zd, buffer size=%zd\\n\",\n\t\t\tcount, sizeof(proxy_dev->buffer));\n\t\treturn -EIO;\n\t}\n\n\tif (!(proxy_dev->state & STATE_DRIVER_COMMAND) &&\n\t    vtpm_proxy_is_driver_command(chip, buf, count))\n\t\treturn -EFAULT;\n\n\tmutex_lock(&proxy_dev->buf_lock);\n\n\tif (!(proxy_dev->state & STATE_OPENED_FLAG)) {\n\t\tmutex_unlock(&proxy_dev->buf_lock);\n\t\treturn -EPIPE;\n\t}\n\n\tproxy_dev->resp_len = 0;\n\n\tproxy_dev->req_len = count;\n\tmemcpy(proxy_dev->buffer, buf, count);\n\n\tproxy_dev->state &= ~STATE_WAIT_RESPONSE_FLAG;\n\n\tmutex_unlock(&proxy_dev->buf_lock);\n\n\twake_up_interruptible(&proxy_dev->wq);\n\n\treturn 0;\n}\n\nstatic void vtpm_proxy_tpm_op_cancel(struct tpm_chip *chip)\n{\n\t \n}\n\nstatic u8 vtpm_proxy_tpm_op_status(struct tpm_chip *chip)\n{\n\tstruct proxy_dev *proxy_dev = dev_get_drvdata(&chip->dev);\n\n\tif (proxy_dev->resp_len)\n\t\treturn VTPM_PROXY_REQ_COMPLETE_FLAG;\n\n\treturn 0;\n}\n\nstatic bool vtpm_proxy_tpm_req_canceled(struct tpm_chip  *chip, u8 status)\n{\n\tstruct proxy_dev *proxy_dev = dev_get_drvdata(&chip->dev);\n\tbool ret;\n\n\tmutex_lock(&proxy_dev->buf_lock);\n\n\tret = !(proxy_dev->state & STATE_OPENED_FLAG);\n\n\tmutex_unlock(&proxy_dev->buf_lock);\n\n\treturn ret;\n}\n\nstatic int vtpm_proxy_request_locality(struct tpm_chip *chip, int locality)\n{\n\tstruct tpm_buf buf;\n\tint rc;\n\tconst struct tpm_header *header;\n\tstruct proxy_dev *proxy_dev = dev_get_drvdata(&chip->dev);\n\n\tif (chip->flags & TPM_CHIP_FLAG_TPM2)\n\t\trc = tpm_buf_init(&buf, TPM2_ST_SESSIONS,\n\t\t\t\t  TPM2_CC_SET_LOCALITY);\n\telse\n\t\trc = tpm_buf_init(&buf, TPM_TAG_RQU_COMMAND,\n\t\t\t\t  TPM_ORD_SET_LOCALITY);\n\tif (rc)\n\t\treturn rc;\n\ttpm_buf_append_u8(&buf, locality);\n\n\tproxy_dev->state |= STATE_DRIVER_COMMAND;\n\n\trc = tpm_transmit_cmd(chip, &buf, 0, \"attempting to set locality\");\n\n\tproxy_dev->state &= ~STATE_DRIVER_COMMAND;\n\n\tif (rc < 0) {\n\t\tlocality = rc;\n\t\tgoto out;\n\t}\n\n\theader = (const struct tpm_header *)buf.data;\n\trc = be32_to_cpu(header->return_code);\n\tif (rc)\n\t\tlocality = -1;\n\nout:\n\ttpm_buf_destroy(&buf);\n\n\treturn locality;\n}\n\nstatic const struct tpm_class_ops vtpm_proxy_tpm_ops = {\n\t.flags = TPM_OPS_AUTO_STARTUP,\n\t.recv = vtpm_proxy_tpm_op_recv,\n\t.send = vtpm_proxy_tpm_op_send,\n\t.cancel = vtpm_proxy_tpm_op_cancel,\n\t.status = vtpm_proxy_tpm_op_status,\n\t.req_complete_mask = VTPM_PROXY_REQ_COMPLETE_FLAG,\n\t.req_complete_val = VTPM_PROXY_REQ_COMPLETE_FLAG,\n\t.req_canceled = vtpm_proxy_tpm_req_canceled,\n\t.request_locality = vtpm_proxy_request_locality,\n};\n\n \n\nstatic void vtpm_proxy_work(struct work_struct *work)\n{\n\tstruct proxy_dev *proxy_dev = container_of(work, struct proxy_dev,\n\t\t\t\t\t\t   work);\n\tint rc;\n\n\trc = tpm_chip_register(proxy_dev->chip);\n\tif (rc)\n\t\tvtpm_proxy_fops_undo_open(proxy_dev);\n\telse\n\t\tproxy_dev->state |= STATE_REGISTERED_FLAG;\n}\n\n \nstatic void vtpm_proxy_work_stop(struct proxy_dev *proxy_dev)\n{\n\tvtpm_proxy_fops_undo_open(proxy_dev);\n\tflush_work(&proxy_dev->work);\n}\n\n \nstatic inline void vtpm_proxy_work_start(struct proxy_dev *proxy_dev)\n{\n\tqueue_work(workqueue, &proxy_dev->work);\n}\n\n \nstatic struct proxy_dev *vtpm_proxy_create_proxy_dev(void)\n{\n\tstruct proxy_dev *proxy_dev;\n\tstruct tpm_chip *chip;\n\tint err;\n\n\tproxy_dev = kzalloc(sizeof(*proxy_dev), GFP_KERNEL);\n\tif (proxy_dev == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit_waitqueue_head(&proxy_dev->wq);\n\tmutex_init(&proxy_dev->buf_lock);\n\tINIT_WORK(&proxy_dev->work, vtpm_proxy_work);\n\n\tchip = tpm_chip_alloc(NULL, &vtpm_proxy_tpm_ops);\n\tif (IS_ERR(chip)) {\n\t\terr = PTR_ERR(chip);\n\t\tgoto err_proxy_dev_free;\n\t}\n\tdev_set_drvdata(&chip->dev, proxy_dev);\n\n\tproxy_dev->chip = chip;\n\n\treturn proxy_dev;\n\nerr_proxy_dev_free:\n\tkfree(proxy_dev);\n\n\treturn ERR_PTR(err);\n}\n\n \nstatic inline void vtpm_proxy_delete_proxy_dev(struct proxy_dev *proxy_dev)\n{\n\tput_device(&proxy_dev->chip->dev);  \n\tkfree(proxy_dev);\n}\n\n \nstatic struct file *vtpm_proxy_create_device(\n\t\t\t\t struct vtpm_proxy_new_dev *vtpm_new_dev)\n{\n\tstruct proxy_dev *proxy_dev;\n\tint rc, fd;\n\tstruct file *file;\n\n\tif (vtpm_new_dev->flags & ~VTPM_PROXY_FLAGS_ALL)\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tproxy_dev = vtpm_proxy_create_proxy_dev();\n\tif (IS_ERR(proxy_dev))\n\t\treturn ERR_CAST(proxy_dev);\n\n\tproxy_dev->flags = vtpm_new_dev->flags;\n\n\t \n\tfd = get_unused_fd_flags(O_RDWR);\n\tif (fd < 0) {\n\t\trc = fd;\n\t\tgoto err_delete_proxy_dev;\n\t}\n\n\tfile = anon_inode_getfile(\"[vtpms]\", &vtpm_proxy_fops, proxy_dev,\n\t\t\t\t  O_RDWR);\n\tif (IS_ERR(file)) {\n\t\trc = PTR_ERR(file);\n\t\tgoto err_put_unused_fd;\n\t}\n\n\t \n\t \n\tvtpm_proxy_fops_open(file);\n\n\tif (proxy_dev->flags & VTPM_PROXY_FLAG_TPM2)\n\t\tproxy_dev->chip->flags |= TPM_CHIP_FLAG_TPM2;\n\n\tvtpm_proxy_work_start(proxy_dev);\n\n\tvtpm_new_dev->fd = fd;\n\tvtpm_new_dev->major = MAJOR(proxy_dev->chip->dev.devt);\n\tvtpm_new_dev->minor = MINOR(proxy_dev->chip->dev.devt);\n\tvtpm_new_dev->tpm_num = proxy_dev->chip->dev_num;\n\n\treturn file;\n\nerr_put_unused_fd:\n\tput_unused_fd(fd);\n\nerr_delete_proxy_dev:\n\tvtpm_proxy_delete_proxy_dev(proxy_dev);\n\n\treturn ERR_PTR(rc);\n}\n\n \nstatic void vtpm_proxy_delete_device(struct proxy_dev *proxy_dev)\n{\n\tvtpm_proxy_work_stop(proxy_dev);\n\n\t \n\tvtpm_proxy_fops_undo_open(proxy_dev);\n\n\tif (proxy_dev->state & STATE_REGISTERED_FLAG)\n\t\ttpm_chip_unregister(proxy_dev->chip);\n\n\tvtpm_proxy_delete_proxy_dev(proxy_dev);\n}\n\n \n\n \nstatic long vtpmx_ioc_new_dev(struct file *file, unsigned int ioctl,\n\t\t\t      unsigned long arg)\n{\n\tvoid __user *argp = (void __user *)arg;\n\tstruct vtpm_proxy_new_dev __user *vtpm_new_dev_p;\n\tstruct vtpm_proxy_new_dev vtpm_new_dev;\n\tstruct file *vtpm_file;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tvtpm_new_dev_p = argp;\n\n\tif (copy_from_user(&vtpm_new_dev, vtpm_new_dev_p,\n\t\t\t   sizeof(vtpm_new_dev)))\n\t\treturn -EFAULT;\n\n\tvtpm_file = vtpm_proxy_create_device(&vtpm_new_dev);\n\tif (IS_ERR(vtpm_file))\n\t\treturn PTR_ERR(vtpm_file);\n\n\tif (copy_to_user(vtpm_new_dev_p, &vtpm_new_dev,\n\t\t\t sizeof(vtpm_new_dev))) {\n\t\tput_unused_fd(vtpm_new_dev.fd);\n\t\tfput(vtpm_file);\n\t\treturn -EFAULT;\n\t}\n\n\tfd_install(vtpm_new_dev.fd, vtpm_file);\n\treturn 0;\n}\n\n \nstatic long vtpmx_fops_ioctl(struct file *f, unsigned int ioctl,\n\t\t\t     unsigned long arg)\n{\n\tswitch (ioctl) {\n\tcase VTPM_PROXY_IOC_NEW_DEV:\n\t\treturn vtpmx_ioc_new_dev(f, ioctl, arg);\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n}\n\nstatic const struct file_operations vtpmx_fops = {\n\t.owner = THIS_MODULE,\n\t.unlocked_ioctl = vtpmx_fops_ioctl,\n\t.compat_ioctl = compat_ptr_ioctl,\n\t.llseek = noop_llseek,\n};\n\nstatic struct miscdevice vtpmx_miscdev = {\n\t.minor = MISC_DYNAMIC_MINOR,\n\t.name = \"vtpmx\",\n\t.fops = &vtpmx_fops,\n};\n\nstatic int __init vtpm_module_init(void)\n{\n\tint rc;\n\n\tworkqueue = create_workqueue(\"tpm-vtpm\");\n\tif (!workqueue) {\n\t\tpr_err(\"couldn't create workqueue\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\trc = misc_register(&vtpmx_miscdev);\n\tif (rc) {\n\t\tpr_err(\"couldn't create vtpmx device\\n\");\n\t\tdestroy_workqueue(workqueue);\n\t}\n\n\treturn rc;\n}\n\nstatic void __exit vtpm_module_exit(void)\n{\n\tdestroy_workqueue(workqueue);\n\tmisc_deregister(&vtpmx_miscdev);\n}\n\nmodule_init(vtpm_module_init);\nmodule_exit(vtpm_module_exit);\n\nMODULE_AUTHOR(\"Stefan Berger (stefanb@us.ibm.com)\");\nMODULE_DESCRIPTION(\"vTPM Driver\");\nMODULE_VERSION(\"0.1\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}