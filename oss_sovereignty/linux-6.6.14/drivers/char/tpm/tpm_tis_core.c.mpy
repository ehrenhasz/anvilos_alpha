{
  "module_name": "tpm_tis_core.c",
  "hash_id": "f199fa7557e86de5ba5463f8cc1b0f5fe7c881abfef08e372cd1740a1fd8540f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/tpm/tpm_tis_core.c",
  "human_readable_source": "\n \n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/pnp.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/wait.h>\n#include <linux/acpi.h>\n#include <linux/freezer.h>\n#include <linux/dmi.h>\n#include \"tpm.h\"\n#include \"tpm_tis_core.h\"\n\n#define TPM_TIS_MAX_UNHANDLED_IRQS\t1000\n\nstatic void tpm_tis_clkrun_enable(struct tpm_chip *chip, bool value);\n\nstatic bool wait_for_tpm_stat_cond(struct tpm_chip *chip, u8 mask,\n\t\t\t\t\tbool check_cancel, bool *canceled)\n{\n\tu8 status = chip->ops->status(chip);\n\n\t*canceled = false;\n\tif ((status & mask) == mask)\n\t\treturn true;\n\tif (check_cancel && chip->ops->req_canceled(chip, status)) {\n\t\t*canceled = true;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic u8 tpm_tis_filter_sts_mask(u8 int_mask, u8 sts_mask)\n{\n\tif (!(int_mask & TPM_INTF_STS_VALID_INT))\n\t\tsts_mask &= ~TPM_STS_VALID;\n\n\tif (!(int_mask & TPM_INTF_DATA_AVAIL_INT))\n\t\tsts_mask &= ~TPM_STS_DATA_AVAIL;\n\n\tif (!(int_mask & TPM_INTF_CMD_READY_INT))\n\t\tsts_mask &= ~TPM_STS_COMMAND_READY;\n\n\treturn sts_mask;\n}\n\nstatic int wait_for_tpm_stat(struct tpm_chip *chip, u8 mask,\n\t\tunsigned long timeout, wait_queue_head_t *queue,\n\t\tbool check_cancel)\n{\n\tstruct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);\n\tunsigned long stop;\n\tlong rc;\n\tu8 status;\n\tbool canceled = false;\n\tu8 sts_mask;\n\tint ret = 0;\n\n\t \n\tstatus = chip->ops->status(chip);\n\tif ((status & mask) == mask)\n\t\treturn 0;\n\n\tsts_mask = mask & (TPM_STS_VALID | TPM_STS_DATA_AVAIL |\n\t\t\t   TPM_STS_COMMAND_READY);\n\t \n\tsts_mask = tpm_tis_filter_sts_mask(priv->int_mask, sts_mask);\n\n\tstop = jiffies + timeout;\n\t \n\tif (sts_mask) {\n\t\tret = -ETIME;\nagain:\n\t\ttimeout = stop - jiffies;\n\t\tif ((long)timeout <= 0)\n\t\t\treturn -ETIME;\n\t\trc = wait_event_interruptible_timeout(*queue,\n\t\t\twait_for_tpm_stat_cond(chip, sts_mask, check_cancel,\n\t\t\t\t\t       &canceled),\n\t\t\ttimeout);\n\t\tif (rc > 0) {\n\t\t\tif (canceled)\n\t\t\t\treturn -ECANCELED;\n\t\t\tret = 0;\n\t\t}\n\t\tif (rc == -ERESTARTSYS && freezing(current)) {\n\t\t\tclear_thread_flag(TIF_SIGPENDING);\n\t\t\tgoto again;\n\t\t}\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\tmask &= ~sts_mask;\n\tif (!mask)  \n\t\treturn 0;\n\t \n\tdo {\n\t\tstatus = chip->ops->status(chip);\n\t\tif ((status & mask) == mask)\n\t\t\treturn 0;\n\t\tusleep_range(priv->timeout_min,\n\t\t\t     priv->timeout_max);\n\t} while (time_before(jiffies, stop));\n\treturn -ETIME;\n}\n\n \nstatic int wait_startup(struct tpm_chip *chip, int l)\n{\n\tstruct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);\n\tunsigned long stop = jiffies + chip->timeout_a;\n\n\tdo {\n\t\tint rc;\n\t\tu8 access;\n\n\t\trc = tpm_tis_read8(priv, TPM_ACCESS(l), &access);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\tif (access & TPM_ACCESS_VALID)\n\t\t\treturn 0;\n\t\ttpm_msleep(TPM_TIMEOUT);\n\t} while (time_before(jiffies, stop));\n\treturn -1;\n}\n\nstatic bool check_locality(struct tpm_chip *chip, int l)\n{\n\tstruct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);\n\tint rc;\n\tu8 access;\n\n\trc = tpm_tis_read8(priv, TPM_ACCESS(l), &access);\n\tif (rc < 0)\n\t\treturn false;\n\n\tif ((access & (TPM_ACCESS_ACTIVE_LOCALITY | TPM_ACCESS_VALID\n\t\t       | TPM_ACCESS_REQUEST_USE)) ==\n\t    (TPM_ACCESS_ACTIVE_LOCALITY | TPM_ACCESS_VALID)) {\n\t\tpriv->locality = l;\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int __tpm_tis_relinquish_locality(struct tpm_tis_data *priv, int l)\n{\n\ttpm_tis_write8(priv, TPM_ACCESS(l), TPM_ACCESS_ACTIVE_LOCALITY);\n\n\treturn 0;\n}\n\nstatic int tpm_tis_relinquish_locality(struct tpm_chip *chip, int l)\n{\n\tstruct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);\n\n\tmutex_lock(&priv->locality_count_mutex);\n\tpriv->locality_count--;\n\tif (priv->locality_count == 0)\n\t\t__tpm_tis_relinquish_locality(priv, l);\n\tmutex_unlock(&priv->locality_count_mutex);\n\n\treturn 0;\n}\n\nstatic int __tpm_tis_request_locality(struct tpm_chip *chip, int l)\n{\n\tstruct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);\n\tunsigned long stop, timeout;\n\tlong rc;\n\n\tif (check_locality(chip, l))\n\t\treturn l;\n\n\trc = tpm_tis_write8(priv, TPM_ACCESS(l), TPM_ACCESS_REQUEST_USE);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tstop = jiffies + chip->timeout_a;\n\n\tif (chip->flags & TPM_CHIP_FLAG_IRQ) {\nagain:\n\t\ttimeout = stop - jiffies;\n\t\tif ((long)timeout <= 0)\n\t\t\treturn -1;\n\t\trc = wait_event_interruptible_timeout(priv->int_queue,\n\t\t\t\t\t\t      (check_locality\n\t\t\t\t\t\t       (chip, l)),\n\t\t\t\t\t\t      timeout);\n\t\tif (rc > 0)\n\t\t\treturn l;\n\t\tif (rc == -ERESTARTSYS && freezing(current)) {\n\t\t\tclear_thread_flag(TIF_SIGPENDING);\n\t\t\tgoto again;\n\t\t}\n\t} else {\n\t\t \n\t\tdo {\n\t\t\tif (check_locality(chip, l))\n\t\t\t\treturn l;\n\t\t\ttpm_msleep(TPM_TIMEOUT);\n\t\t} while (time_before(jiffies, stop));\n\t}\n\treturn -1;\n}\n\nstatic int tpm_tis_request_locality(struct tpm_chip *chip, int l)\n{\n\tstruct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);\n\tint ret = 0;\n\n\tmutex_lock(&priv->locality_count_mutex);\n\tif (priv->locality_count == 0)\n\t\tret = __tpm_tis_request_locality(chip, l);\n\tif (!ret)\n\t\tpriv->locality_count++;\n\tmutex_unlock(&priv->locality_count_mutex);\n\treturn ret;\n}\n\nstatic u8 tpm_tis_status(struct tpm_chip *chip)\n{\n\tstruct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);\n\tint rc;\n\tu8 status;\n\n\trc = tpm_tis_read8(priv, TPM_STS(priv->locality), &status);\n\tif (rc < 0)\n\t\treturn 0;\n\n\tif (unlikely((status & TPM_STS_READ_ZERO) != 0)) {\n\t\tif  (!test_and_set_bit(TPM_TIS_INVALID_STATUS, &priv->flags)) {\n\t\t\t \n\t\t\tdev_err(&chip->dev, \"invalid TPM_STS.x 0x%02x, dumping stack for forensics\\n\",\n\t\t\t\tstatus);\n\n\t\t\t \n\t\t\tdump_stack();\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\treturn status;\n}\n\nstatic void tpm_tis_ready(struct tpm_chip *chip)\n{\n\tstruct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);\n\n\t \n\ttpm_tis_write8(priv, TPM_STS(priv->locality), TPM_STS_COMMAND_READY);\n}\n\nstatic int get_burstcount(struct tpm_chip *chip)\n{\n\tstruct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);\n\tunsigned long stop;\n\tint burstcnt, rc;\n\tu32 value;\n\n\t \n\tif (chip->flags & TPM_CHIP_FLAG_TPM2)\n\t\tstop = jiffies + chip->timeout_a;\n\telse\n\t\tstop = jiffies + chip->timeout_d;\n\tdo {\n\t\trc = tpm_tis_read32(priv, TPM_STS(priv->locality), &value);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\tburstcnt = (value >> 8) & 0xFFFF;\n\t\tif (burstcnt)\n\t\t\treturn burstcnt;\n\t\tusleep_range(TPM_TIMEOUT_USECS_MIN, TPM_TIMEOUT_USECS_MAX);\n\t} while (time_before(jiffies, stop));\n\treturn -EBUSY;\n}\n\nstatic int recv_data(struct tpm_chip *chip, u8 *buf, size_t count)\n{\n\tstruct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);\n\tint size = 0, burstcnt, rc;\n\n\twhile (size < count) {\n\t\trc = wait_for_tpm_stat(chip,\n\t\t\t\t TPM_STS_DATA_AVAIL | TPM_STS_VALID,\n\t\t\t\t chip->timeout_c,\n\t\t\t\t &priv->read_queue, true);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\tburstcnt = get_burstcount(chip);\n\t\tif (burstcnt < 0) {\n\t\t\tdev_err(&chip->dev, \"Unable to read burstcount\\n\");\n\t\t\treturn burstcnt;\n\t\t}\n\t\tburstcnt = min_t(int, burstcnt, count - size);\n\n\t\trc = tpm_tis_read_bytes(priv, TPM_DATA_FIFO(priv->locality),\n\t\t\t\t\tburstcnt, buf + size);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\tsize += burstcnt;\n\t}\n\treturn size;\n}\n\nstatic int tpm_tis_try_recv(struct tpm_chip *chip, u8 *buf, size_t count)\n{\n\tstruct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);\n\tint size = 0;\n\tint status;\n\tu32 expected;\n\tint rc;\n\n\tsize = recv_data(chip, buf, TPM_HEADER_SIZE);\n\t \n\tif (size < TPM_HEADER_SIZE) {\n\t\tdev_err(&chip->dev, \"Unable to read header\\n\");\n\t\tgoto out;\n\t}\n\n\texpected = be32_to_cpu(*(__be32 *) (buf + 2));\n\tif (expected > count || expected < TPM_HEADER_SIZE) {\n\t\tsize = -EIO;\n\t\tgoto out;\n\t}\n\n\trc = recv_data(chip, &buf[TPM_HEADER_SIZE],\n\t\t       expected - TPM_HEADER_SIZE);\n\tif (rc < 0) {\n\t\tsize = rc;\n\t\tgoto out;\n\t}\n\tsize += rc;\n\tif (size < expected) {\n\t\tdev_err(&chip->dev, \"Unable to read remainder of result\\n\");\n\t\tsize = -ETIME;\n\t\tgoto out;\n\t}\n\n\tif (wait_for_tpm_stat(chip, TPM_STS_VALID, chip->timeout_c,\n\t\t\t\t&priv->int_queue, false) < 0) {\n\t\tsize = -ETIME;\n\t\tgoto out;\n\t}\n\tstatus = tpm_tis_status(chip);\n\tif (status & TPM_STS_DATA_AVAIL) {\n\t\tdev_err(&chip->dev, \"Error left over data\\n\");\n\t\tsize = -EIO;\n\t\tgoto out;\n\t}\n\n\trc = tpm_tis_verify_crc(priv, (size_t)size, buf);\n\tif (rc < 0) {\n\t\tdev_err(&chip->dev, \"CRC mismatch for response.\\n\");\n\t\tsize = rc;\n\t\tgoto out;\n\t}\n\nout:\n\treturn size;\n}\n\nstatic int tpm_tis_recv(struct tpm_chip *chip, u8 *buf, size_t count)\n{\n\tstruct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);\n\tunsigned int try;\n\tint rc = 0;\n\n\tif (count < TPM_HEADER_SIZE)\n\t\treturn -EIO;\n\n\tfor (try = 0; try < TPM_RETRY; try++) {\n\t\trc = tpm_tis_try_recv(chip, buf, count);\n\n\t\tif (rc == -EIO)\n\t\t\t \n\t\t\ttpm_tis_write8(priv, TPM_STS(priv->locality),\n\t\t\t\t       TPM_STS_RESPONSE_RETRY);\n\t\telse\n\t\t\tbreak;\n\t}\n\n\ttpm_tis_ready(chip);\n\n\treturn rc;\n}\n\n \nstatic int tpm_tis_send_data(struct tpm_chip *chip, const u8 *buf, size_t len)\n{\n\tstruct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);\n\tint rc, status, burstcnt;\n\tsize_t count = 0;\n\tbool itpm = test_bit(TPM_TIS_ITPM_WORKAROUND, &priv->flags);\n\n\tstatus = tpm_tis_status(chip);\n\tif ((status & TPM_STS_COMMAND_READY) == 0) {\n\t\ttpm_tis_ready(chip);\n\t\tif (wait_for_tpm_stat\n\t\t    (chip, TPM_STS_COMMAND_READY, chip->timeout_b,\n\t\t     &priv->int_queue, false) < 0) {\n\t\t\trc = -ETIME;\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\twhile (count < len - 1) {\n\t\tburstcnt = get_burstcount(chip);\n\t\tif (burstcnt < 0) {\n\t\t\tdev_err(&chip->dev, \"Unable to read burstcount\\n\");\n\t\t\trc = burstcnt;\n\t\t\tgoto out_err;\n\t\t}\n\t\tburstcnt = min_t(int, burstcnt, len - count - 1);\n\t\trc = tpm_tis_write_bytes(priv, TPM_DATA_FIFO(priv->locality),\n\t\t\t\t\t burstcnt, buf + count);\n\t\tif (rc < 0)\n\t\t\tgoto out_err;\n\n\t\tcount += burstcnt;\n\n\t\tif (wait_for_tpm_stat(chip, TPM_STS_VALID, chip->timeout_c,\n\t\t\t\t\t&priv->int_queue, false) < 0) {\n\t\t\trc = -ETIME;\n\t\t\tgoto out_err;\n\t\t}\n\t\tstatus = tpm_tis_status(chip);\n\t\tif (!itpm && (status & TPM_STS_DATA_EXPECT) == 0) {\n\t\t\trc = -EIO;\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\t \n\trc = tpm_tis_write8(priv, TPM_DATA_FIFO(priv->locality), buf[count]);\n\tif (rc < 0)\n\t\tgoto out_err;\n\n\tif (wait_for_tpm_stat(chip, TPM_STS_VALID, chip->timeout_c,\n\t\t\t\t&priv->int_queue, false) < 0) {\n\t\trc = -ETIME;\n\t\tgoto out_err;\n\t}\n\tstatus = tpm_tis_status(chip);\n\tif (!itpm && (status & TPM_STS_DATA_EXPECT) != 0) {\n\t\trc = -EIO;\n\t\tgoto out_err;\n\t}\n\n\trc = tpm_tis_verify_crc(priv, len, buf);\n\tif (rc < 0) {\n\t\tdev_err(&chip->dev, \"CRC mismatch for command.\\n\");\n\t\tgoto out_err;\n\t}\n\n\treturn 0;\n\nout_err:\n\ttpm_tis_ready(chip);\n\treturn rc;\n}\n\nstatic void __tpm_tis_disable_interrupts(struct tpm_chip *chip)\n{\n\tstruct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);\n\tu32 int_mask = 0;\n\n\ttpm_tis_read32(priv, TPM_INT_ENABLE(priv->locality), &int_mask);\n\tint_mask &= ~TPM_GLOBAL_INT_ENABLE;\n\ttpm_tis_write32(priv, TPM_INT_ENABLE(priv->locality), int_mask);\n\n\tchip->flags &= ~TPM_CHIP_FLAG_IRQ;\n}\n\nstatic void tpm_tis_disable_interrupts(struct tpm_chip *chip)\n{\n\tstruct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);\n\n\tif (priv->irq == 0)\n\t\treturn;\n\n\t__tpm_tis_disable_interrupts(chip);\n\n\tdevm_free_irq(chip->dev.parent, priv->irq, chip);\n\tpriv->irq = 0;\n}\n\n \nstatic int tpm_tis_send_main(struct tpm_chip *chip, const u8 *buf, size_t len)\n{\n\tstruct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);\n\tint rc;\n\tu32 ordinal;\n\tunsigned long dur;\n\tunsigned int try;\n\n\tfor (try = 0; try < TPM_RETRY; try++) {\n\t\trc = tpm_tis_send_data(chip, buf, len);\n\t\tif (rc >= 0)\n\t\t\t \n\t\t\tbreak;\n\t\telse if (rc != -EIO)\n\t\t\t \n\t\t\treturn rc;\n\t}\n\n\t \n\trc = tpm_tis_write8(priv, TPM_STS(priv->locality), TPM_STS_GO);\n\tif (rc < 0)\n\t\tgoto out_err;\n\n\tif (chip->flags & TPM_CHIP_FLAG_IRQ) {\n\t\tordinal = be32_to_cpu(*((__be32 *) (buf + 6)));\n\n\t\tdur = tpm_calc_ordinal_duration(chip, ordinal);\n\t\tif (wait_for_tpm_stat\n\t\t    (chip, TPM_STS_DATA_AVAIL | TPM_STS_VALID, dur,\n\t\t     &priv->read_queue, false) < 0) {\n\t\t\trc = -ETIME;\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\treturn 0;\nout_err:\n\ttpm_tis_ready(chip);\n\treturn rc;\n}\n\nstatic int tpm_tis_send(struct tpm_chip *chip, u8 *buf, size_t len)\n{\n\tint rc, irq;\n\tstruct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);\n\n\tif (!(chip->flags & TPM_CHIP_FLAG_IRQ) ||\n\t     test_bit(TPM_TIS_IRQ_TESTED, &priv->flags))\n\t\treturn tpm_tis_send_main(chip, buf, len);\n\n\t \n\tirq = priv->irq;\n\tpriv->irq = 0;\n\tchip->flags &= ~TPM_CHIP_FLAG_IRQ;\n\trc = tpm_tis_send_main(chip, buf, len);\n\tpriv->irq = irq;\n\tchip->flags |= TPM_CHIP_FLAG_IRQ;\n\tif (!test_bit(TPM_TIS_IRQ_TESTED, &priv->flags))\n\t\ttpm_msleep(1);\n\tif (!test_bit(TPM_TIS_IRQ_TESTED, &priv->flags))\n\t\ttpm_tis_disable_interrupts(chip);\n\tset_bit(TPM_TIS_IRQ_TESTED, &priv->flags);\n\treturn rc;\n}\n\nstruct tis_vendor_durations_override {\n\tu32 did_vid;\n\tstruct tpm1_version version;\n\tunsigned long durations[3];\n};\n\nstatic const struct  tis_vendor_durations_override vendor_dur_overrides[] = {\n\t \n\t{ 0x0000104a,\n\t  { 1, 2, 8, 28 },\n\t  { (2 * 60 * HZ), (2 * 60 * HZ), (2 * 60 * HZ) } },\n};\n\nstatic void tpm_tis_update_durations(struct tpm_chip *chip,\n\t\t\t\t     unsigned long *duration_cap)\n{\n\tstruct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);\n\tstruct tpm1_version *version;\n\tu32 did_vid;\n\tint i, rc;\n\tcap_t cap;\n\n\tchip->duration_adjusted = false;\n\n\tif (chip->ops->clk_enable != NULL)\n\t\tchip->ops->clk_enable(chip, true);\n\n\trc = tpm_tis_read32(priv, TPM_DID_VID(0), &did_vid);\n\tif (rc < 0) {\n\t\tdev_warn(&chip->dev, \"%s: failed to read did_vid. %d\\n\",\n\t\t\t __func__, rc);\n\t\tgoto out;\n\t}\n\n\t \n\trc = tpm1_getcap(chip, TPM_CAP_VERSION_1_2, &cap,\n\t\t\t \"attempting to determine the 1.2 version\",\n\t\t\t sizeof(cap.version2));\n\tif (!rc) {\n\t\tversion = &cap.version2.version;\n\t} else {\n\t\trc = tpm1_getcap(chip, TPM_CAP_VERSION_1_1, &cap,\n\t\t\t\t \"attempting to determine the 1.1 version\",\n\t\t\t\t sizeof(cap.version1));\n\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\tversion = &cap.version1;\n\t}\n\n\tfor (i = 0; i != ARRAY_SIZE(vendor_dur_overrides); i++) {\n\t\tif (vendor_dur_overrides[i].did_vid != did_vid)\n\t\t\tcontinue;\n\n\t\tif ((version->major ==\n\t\t     vendor_dur_overrides[i].version.major) &&\n\t\t    (version->minor ==\n\t\t     vendor_dur_overrides[i].version.minor) &&\n\t\t    (version->rev_major ==\n\t\t     vendor_dur_overrides[i].version.rev_major) &&\n\t\t    (version->rev_minor ==\n\t\t     vendor_dur_overrides[i].version.rev_minor)) {\n\n\t\t\tmemcpy(duration_cap,\n\t\t\t       vendor_dur_overrides[i].durations,\n\t\t\t       sizeof(vendor_dur_overrides[i].durations));\n\n\t\t\tchip->duration_adjusted = true;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tif (chip->ops->clk_enable != NULL)\n\t\tchip->ops->clk_enable(chip, false);\n}\n\nstruct tis_vendor_timeout_override {\n\tu32 did_vid;\n\tunsigned long timeout_us[4];\n};\n\nstatic const struct tis_vendor_timeout_override vendor_timeout_overrides[] = {\n\t \n\t{ 0x32041114, { (TIS_SHORT_TIMEOUT*1000), (TIS_LONG_TIMEOUT*1000),\n\t\t\t(TIS_SHORT_TIMEOUT*1000), (TIS_SHORT_TIMEOUT*1000) } },\n};\n\nstatic void tpm_tis_update_timeouts(struct tpm_chip *chip,\n\t\t\t\t    unsigned long *timeout_cap)\n{\n\tstruct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);\n\tint i, rc;\n\tu32 did_vid;\n\n\tchip->timeout_adjusted = false;\n\n\tif (chip->ops->clk_enable != NULL)\n\t\tchip->ops->clk_enable(chip, true);\n\n\trc = tpm_tis_read32(priv, TPM_DID_VID(0), &did_vid);\n\tif (rc < 0) {\n\t\tdev_warn(&chip->dev, \"%s: failed to read did_vid: %d\\n\",\n\t\t\t __func__, rc);\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i != ARRAY_SIZE(vendor_timeout_overrides); i++) {\n\t\tif (vendor_timeout_overrides[i].did_vid != did_vid)\n\t\t\tcontinue;\n\t\tmemcpy(timeout_cap, vendor_timeout_overrides[i].timeout_us,\n\t\t       sizeof(vendor_timeout_overrides[i].timeout_us));\n\t\tchip->timeout_adjusted = true;\n\t}\n\nout:\n\tif (chip->ops->clk_enable != NULL)\n\t\tchip->ops->clk_enable(chip, false);\n\n\treturn;\n}\n\n \nstatic int probe_itpm(struct tpm_chip *chip)\n{\n\tstruct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);\n\tint rc = 0;\n\tstatic const u8 cmd_getticks[] = {\n\t\t0x00, 0xc1, 0x00, 0x00, 0x00, 0x0a,\n\t\t0x00, 0x00, 0x00, 0xf1\n\t};\n\tsize_t len = sizeof(cmd_getticks);\n\tu16 vendor;\n\n\tif (test_bit(TPM_TIS_ITPM_WORKAROUND, &priv->flags))\n\t\treturn 0;\n\n\trc = tpm_tis_read16(priv, TPM_DID_VID(0), &vendor);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\tif (vendor != TPM_VID_INTEL)\n\t\treturn 0;\n\n\tif (tpm_tis_request_locality(chip, 0) != 0)\n\t\treturn -EBUSY;\n\n\trc = tpm_tis_send_data(chip, cmd_getticks, len);\n\tif (rc == 0)\n\t\tgoto out;\n\n\ttpm_tis_ready(chip);\n\n\tset_bit(TPM_TIS_ITPM_WORKAROUND, &priv->flags);\n\n\trc = tpm_tis_send_data(chip, cmd_getticks, len);\n\tif (rc == 0)\n\t\tdev_info(&chip->dev, \"Detected an iTPM.\\n\");\n\telse {\n\t\tclear_bit(TPM_TIS_ITPM_WORKAROUND, &priv->flags);\n\t\trc = -EFAULT;\n\t}\n\nout:\n\ttpm_tis_ready(chip);\n\ttpm_tis_relinquish_locality(chip, priv->locality);\n\n\treturn rc;\n}\n\nstatic bool tpm_tis_req_canceled(struct tpm_chip *chip, u8 status)\n{\n\tstruct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);\n\n\tif (!test_bit(TPM_TIS_DEFAULT_CANCELLATION, &priv->flags)) {\n\t\tswitch (priv->manufacturer_id) {\n\t\tcase TPM_VID_WINBOND:\n\t\t\treturn ((status == TPM_STS_VALID) ||\n\t\t\t\t(status == (TPM_STS_VALID | TPM_STS_COMMAND_READY)));\n\t\tcase TPM_VID_STM:\n\t\t\treturn (status == (TPM_STS_VALID | TPM_STS_COMMAND_READY));\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn status == TPM_STS_COMMAND_READY;\n}\n\nstatic irqreturn_t tpm_tis_revert_interrupts(struct tpm_chip *chip)\n{\n\tstruct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);\n\tconst char *product;\n\tconst char *vendor;\n\n\tdev_warn(&chip->dev, FW_BUG\n\t\t \"TPM interrupt storm detected, polling instead\\n\");\n\n\tvendor = dmi_get_system_info(DMI_SYS_VENDOR);\n\tproduct = dmi_get_system_info(DMI_PRODUCT_VERSION);\n\n\tif (vendor && product) {\n\t\tdev_info(&chip->dev,\n\t\t\t\"Consider adding the following entry to tpm_tis_dmi_table:\\n\");\n\t\tdev_info(&chip->dev, \"\\tDMI_SYS_VENDOR: %s\\n\", vendor);\n\t\tdev_info(&chip->dev, \"\\tDMI_PRODUCT_VERSION: %s\\n\", product);\n\t}\n\n\tif (tpm_tis_request_locality(chip, 0) != 0)\n\t\treturn IRQ_NONE;\n\n\t__tpm_tis_disable_interrupts(chip);\n\ttpm_tis_relinquish_locality(chip, 0);\n\n\tschedule_work(&priv->free_irq_work);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t tpm_tis_update_unhandled_irqs(struct tpm_chip *chip)\n{\n\tstruct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);\n\tirqreturn_t irqret = IRQ_HANDLED;\n\n\tif (!(chip->flags & TPM_CHIP_FLAG_IRQ))\n\t\treturn IRQ_HANDLED;\n\n\tif (time_after(jiffies, priv->last_unhandled_irq + HZ/10))\n\t\tpriv->unhandled_irqs = 1;\n\telse\n\t\tpriv->unhandled_irqs++;\n\n\tpriv->last_unhandled_irq = jiffies;\n\n\tif (priv->unhandled_irqs > TPM_TIS_MAX_UNHANDLED_IRQS)\n\t\tirqret = tpm_tis_revert_interrupts(chip);\n\n\treturn irqret;\n}\n\nstatic irqreturn_t tis_int_handler(int dummy, void *dev_id)\n{\n\tstruct tpm_chip *chip = dev_id;\n\tstruct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);\n\tu32 interrupt;\n\tint rc;\n\n\trc = tpm_tis_read32(priv, TPM_INT_STATUS(priv->locality), &interrupt);\n\tif (rc < 0)\n\t\tgoto err;\n\n\tif (interrupt == 0)\n\t\tgoto err;\n\n\tset_bit(TPM_TIS_IRQ_TESTED, &priv->flags);\n\tif (interrupt & TPM_INTF_DATA_AVAIL_INT)\n\t\twake_up_interruptible(&priv->read_queue);\n\n\tif (interrupt &\n\t    (TPM_INTF_LOCALITY_CHANGE_INT | TPM_INTF_STS_VALID_INT |\n\t     TPM_INTF_CMD_READY_INT))\n\t\twake_up_interruptible(&priv->int_queue);\n\n\t \n\ttpm_tis_request_locality(chip, 0);\n\trc = tpm_tis_write32(priv, TPM_INT_STATUS(priv->locality), interrupt);\n\ttpm_tis_relinquish_locality(chip, 0);\n\tif (rc < 0)\n\t\tgoto err;\n\n\ttpm_tis_read32(priv, TPM_INT_STATUS(priv->locality), &interrupt);\n\treturn IRQ_HANDLED;\n\nerr:\n\treturn tpm_tis_update_unhandled_irqs(chip);\n}\n\nstatic void tpm_tis_gen_interrupt(struct tpm_chip *chip)\n{\n\tconst char *desc = \"attempting to generate an interrupt\";\n\tu32 cap2;\n\tcap_t cap;\n\tint ret;\n\n\tchip->flags |= TPM_CHIP_FLAG_IRQ;\n\n\tif (chip->flags & TPM_CHIP_FLAG_TPM2)\n\t\tret = tpm2_get_tpm_pt(chip, 0x100, &cap2, desc);\n\telse\n\t\tret = tpm1_getcap(chip, TPM_CAP_PROP_TIS_TIMEOUT, &cap, desc, 0);\n\n\tif (ret)\n\t\tchip->flags &= ~TPM_CHIP_FLAG_IRQ;\n}\n\nstatic void tpm_tis_free_irq_func(struct work_struct *work)\n{\n\tstruct tpm_tis_data *priv = container_of(work, typeof(*priv), free_irq_work);\n\tstruct tpm_chip *chip = priv->chip;\n\n\tdevm_free_irq(chip->dev.parent, priv->irq, chip);\n\tpriv->irq = 0;\n}\n\n \nstatic int tpm_tis_probe_irq_single(struct tpm_chip *chip, u32 intmask,\n\t\t\t\t    int flags, int irq)\n{\n\tstruct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);\n\tu8 original_int_vec;\n\tint rc;\n\tu32 int_status;\n\n\tINIT_WORK(&priv->free_irq_work, tpm_tis_free_irq_func);\n\n\trc = devm_request_threaded_irq(chip->dev.parent, irq, NULL,\n\t\t\t\t       tis_int_handler, IRQF_ONESHOT | flags,\n\t\t\t\t       dev_name(&chip->dev), chip);\n\tif (rc) {\n\t\tdev_info(&chip->dev, \"Unable to request irq: %d for probe\\n\",\n\t\t\t irq);\n\t\treturn -1;\n\t}\n\tpriv->irq = irq;\n\n\trc = tpm_tis_request_locality(chip, 0);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = tpm_tis_read8(priv, TPM_INT_VECTOR(priv->locality),\n\t\t\t   &original_int_vec);\n\tif (rc < 0) {\n\t\ttpm_tis_relinquish_locality(chip, priv->locality);\n\t\treturn rc;\n\t}\n\n\trc = tpm_tis_write8(priv, TPM_INT_VECTOR(priv->locality), irq);\n\tif (rc < 0)\n\t\tgoto restore_irqs;\n\n\trc = tpm_tis_read32(priv, TPM_INT_STATUS(priv->locality), &int_status);\n\tif (rc < 0)\n\t\tgoto restore_irqs;\n\n\t \n\trc = tpm_tis_write32(priv, TPM_INT_STATUS(priv->locality), int_status);\n\tif (rc < 0)\n\t\tgoto restore_irqs;\n\t \n\trc = tpm_tis_write32(priv, TPM_INT_ENABLE(priv->locality),\n\t\t\t     intmask | TPM_GLOBAL_INT_ENABLE);\n\tif (rc < 0)\n\t\tgoto restore_irqs;\n\n\tclear_bit(TPM_TIS_IRQ_TESTED, &priv->flags);\n\n\t \n\ttpm_tis_gen_interrupt(chip);\n\nrestore_irqs:\n\t \n\tif (!(chip->flags & TPM_CHIP_FLAG_IRQ)) {\n\t\ttpm_tis_write8(priv, original_int_vec,\n\t\t\t       TPM_INT_VECTOR(priv->locality));\n\t\trc = -1;\n\t}\n\n\ttpm_tis_relinquish_locality(chip, priv->locality);\n\n\treturn rc;\n}\n\n \nstatic void tpm_tis_probe_irq(struct tpm_chip *chip, u32 intmask)\n{\n\tstruct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);\n\tu8 original_int_vec;\n\tint i, rc;\n\n\trc = tpm_tis_read8(priv, TPM_INT_VECTOR(priv->locality),\n\t\t\t   &original_int_vec);\n\tif (rc < 0)\n\t\treturn;\n\n\tif (!original_int_vec) {\n\t\tif (IS_ENABLED(CONFIG_X86))\n\t\t\tfor (i = 3; i <= 15; i++)\n\t\t\t\tif (!tpm_tis_probe_irq_single(chip, intmask, 0,\n\t\t\t\t\t\t\t      i))\n\t\t\t\t\treturn;\n\t} else if (!tpm_tis_probe_irq_single(chip, intmask, 0,\n\t\t\t\t\t     original_int_vec))\n\t\treturn;\n}\n\nvoid tpm_tis_remove(struct tpm_chip *chip)\n{\n\tstruct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);\n\tu32 reg = TPM_INT_ENABLE(priv->locality);\n\tu32 interrupt;\n\tint rc;\n\n\ttpm_tis_clkrun_enable(chip, true);\n\n\trc = tpm_tis_read32(priv, reg, &interrupt);\n\tif (rc < 0)\n\t\tinterrupt = 0;\n\n\ttpm_tis_write32(priv, reg, ~TPM_GLOBAL_INT_ENABLE & interrupt);\n\tflush_work(&priv->free_irq_work);\n\n\ttpm_tis_clkrun_enable(chip, false);\n\n\tif (priv->ilb_base_addr)\n\t\tiounmap(priv->ilb_base_addr);\n}\nEXPORT_SYMBOL_GPL(tpm_tis_remove);\n\n \nstatic void tpm_tis_clkrun_enable(struct tpm_chip *chip, bool value)\n{\n\tstruct tpm_tis_data *data = dev_get_drvdata(&chip->dev);\n\tu32 clkrun_val;\n\n\tif (!IS_ENABLED(CONFIG_X86) || !is_bsw() ||\n\t    !data->ilb_base_addr)\n\t\treturn;\n\n\tif (value) {\n\t\tdata->clkrun_enabled++;\n\t\tif (data->clkrun_enabled > 1)\n\t\t\treturn;\n\t\tclkrun_val = ioread32(data->ilb_base_addr + LPC_CNTRL_OFFSET);\n\n\t\t \n\t\tclkrun_val &= ~LPC_CLKRUN_EN;\n\t\tiowrite32(clkrun_val, data->ilb_base_addr + LPC_CNTRL_OFFSET);\n\n\t\t \n\t\toutb(0xCC, 0x80);\n\t} else {\n\t\tdata->clkrun_enabled--;\n\t\tif (data->clkrun_enabled)\n\t\t\treturn;\n\n\t\tclkrun_val = ioread32(data->ilb_base_addr + LPC_CNTRL_OFFSET);\n\n\t\t \n\t\tclkrun_val |= LPC_CLKRUN_EN;\n\t\tiowrite32(clkrun_val, data->ilb_base_addr + LPC_CNTRL_OFFSET);\n\n\t\t \n\t\toutb(0xCC, 0x80);\n\t}\n}\n\nstatic const struct tpm_class_ops tpm_tis = {\n\t.flags = TPM_OPS_AUTO_STARTUP,\n\t.status = tpm_tis_status,\n\t.recv = tpm_tis_recv,\n\t.send = tpm_tis_send,\n\t.cancel = tpm_tis_ready,\n\t.update_timeouts = tpm_tis_update_timeouts,\n\t.update_durations = tpm_tis_update_durations,\n\t.req_complete_mask = TPM_STS_DATA_AVAIL | TPM_STS_VALID,\n\t.req_complete_val = TPM_STS_DATA_AVAIL | TPM_STS_VALID,\n\t.req_canceled = tpm_tis_req_canceled,\n\t.request_locality = tpm_tis_request_locality,\n\t.relinquish_locality = tpm_tis_relinquish_locality,\n\t.clk_enable = tpm_tis_clkrun_enable,\n};\n\nint tpm_tis_core_init(struct device *dev, struct tpm_tis_data *priv, int irq,\n\t\t      const struct tpm_tis_phy_ops *phy_ops,\n\t\t      acpi_handle acpi_dev_handle)\n{\n\tu32 vendor;\n\tu32 intfcaps;\n\tu32 intmask;\n\tu32 clkrun_val;\n\tu8 rid;\n\tint rc, probe;\n\tstruct tpm_chip *chip;\n\n\tchip = tpmm_chip_alloc(dev, &tpm_tis);\n\tif (IS_ERR(chip))\n\t\treturn PTR_ERR(chip);\n\n#ifdef CONFIG_ACPI\n\tchip->acpi_dev_handle = acpi_dev_handle;\n#endif\n\n\tchip->hwrng.quality = priv->rng_quality;\n\n\t \n\tchip->timeout_a = msecs_to_jiffies(TIS_TIMEOUT_A_MAX);\n\tchip->timeout_b = msecs_to_jiffies(TIS_TIMEOUT_B_MAX);\n\tchip->timeout_c = msecs_to_jiffies(TIS_TIMEOUT_C_MAX);\n\tchip->timeout_d = msecs_to_jiffies(TIS_TIMEOUT_D_MAX);\n\tpriv->chip = chip;\n\tpriv->timeout_min = TPM_TIMEOUT_USECS_MIN;\n\tpriv->timeout_max = TPM_TIMEOUT_USECS_MAX;\n\tpriv->phy_ops = phy_ops;\n\tpriv->locality_count = 0;\n\tmutex_init(&priv->locality_count_mutex);\n\n\tdev_set_drvdata(&chip->dev, priv);\n\n\trc = tpm_tis_read32(priv, TPM_DID_VID(0), &vendor);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tpriv->manufacturer_id = vendor;\n\n\tif (priv->manufacturer_id == TPM_VID_ATML &&\n\t\t!(chip->flags & TPM_CHIP_FLAG_TPM2)) {\n\t\tpriv->timeout_min = TIS_TIMEOUT_MIN_ATML;\n\t\tpriv->timeout_max = TIS_TIMEOUT_MAX_ATML;\n\t}\n\n\tif (is_bsw()) {\n\t\tpriv->ilb_base_addr = ioremap(INTEL_LEGACY_BLK_BASE_ADDR,\n\t\t\t\t\tILB_REMAP_SIZE);\n\t\tif (!priv->ilb_base_addr)\n\t\t\treturn -ENOMEM;\n\n\t\tclkrun_val = ioread32(priv->ilb_base_addr + LPC_CNTRL_OFFSET);\n\t\t \n\t\tif (!(clkrun_val & LPC_CLKRUN_EN)) {\n\t\t\tiounmap(priv->ilb_base_addr);\n\t\t\tpriv->ilb_base_addr = NULL;\n\t\t}\n\t}\n\n\tif (chip->ops->clk_enable != NULL)\n\t\tchip->ops->clk_enable(chip, true);\n\n\tif (wait_startup(chip, 0) != 0) {\n\t\trc = -ENODEV;\n\t\tgoto out_err;\n\t}\n\n\t \n\trc = tpm_tis_read32(priv, TPM_INT_ENABLE(priv->locality), &intmask);\n\tif (rc < 0)\n\t\tgoto out_err;\n\n\t \n\trc = tpm_tis_read32(priv, TPM_INTF_CAPS(priv->locality), &intfcaps);\n\tif (rc < 0)\n\t\tgoto out_err;\n\n\tdev_dbg(dev, \"TPM interface capabilities (0x%x):\\n\",\n\t\tintfcaps);\n\tif (intfcaps & TPM_INTF_BURST_COUNT_STATIC)\n\t\tdev_dbg(dev, \"\\tBurst Count Static\\n\");\n\tif (intfcaps & TPM_INTF_CMD_READY_INT) {\n\t\tintmask |= TPM_INTF_CMD_READY_INT;\n\t\tdev_dbg(dev, \"\\tCommand Ready Int Support\\n\");\n\t}\n\tif (intfcaps & TPM_INTF_INT_EDGE_FALLING)\n\t\tdev_dbg(dev, \"\\tInterrupt Edge Falling\\n\");\n\tif (intfcaps & TPM_INTF_INT_EDGE_RISING)\n\t\tdev_dbg(dev, \"\\tInterrupt Edge Rising\\n\");\n\tif (intfcaps & TPM_INTF_INT_LEVEL_LOW)\n\t\tdev_dbg(dev, \"\\tInterrupt Level Low\\n\");\n\tif (intfcaps & TPM_INTF_INT_LEVEL_HIGH)\n\t\tdev_dbg(dev, \"\\tInterrupt Level High\\n\");\n\tif (intfcaps & TPM_INTF_LOCALITY_CHANGE_INT) {\n\t\tintmask |= TPM_INTF_LOCALITY_CHANGE_INT;\n\t\tdev_dbg(dev, \"\\tLocality Change Int Support\\n\");\n\t}\n\tif (intfcaps & TPM_INTF_STS_VALID_INT) {\n\t\tintmask |= TPM_INTF_STS_VALID_INT;\n\t\tdev_dbg(dev, \"\\tSts Valid Int Support\\n\");\n\t}\n\tif (intfcaps & TPM_INTF_DATA_AVAIL_INT) {\n\t\tintmask |= TPM_INTF_DATA_AVAIL_INT;\n\t\tdev_dbg(dev, \"\\tData Avail Int Support\\n\");\n\t}\n\n\tintmask &= ~TPM_GLOBAL_INT_ENABLE;\n\n\trc = tpm_tis_request_locality(chip, 0);\n\tif (rc < 0) {\n\t\trc = -ENODEV;\n\t\tgoto out_err;\n\t}\n\n\ttpm_tis_write32(priv, TPM_INT_ENABLE(priv->locality), intmask);\n\ttpm_tis_relinquish_locality(chip, 0);\n\n\trc = tpm_chip_start(chip);\n\tif (rc)\n\t\tgoto out_err;\n\trc = tpm2_probe(chip);\n\ttpm_chip_stop(chip);\n\tif (rc)\n\t\tgoto out_err;\n\n\trc = tpm_tis_read8(priv, TPM_RID(0), &rid);\n\tif (rc < 0)\n\t\tgoto out_err;\n\n\tdev_info(dev, \"%s TPM (device-id 0x%X, rev-id %d)\\n\",\n\t\t (chip->flags & TPM_CHIP_FLAG_TPM2) ? \"2.0\" : \"1.2\",\n\t\t vendor >> 16, rid);\n\n\tprobe = probe_itpm(chip);\n\tif (probe < 0) {\n\t\trc = -ENODEV;\n\t\tgoto out_err;\n\t}\n\n\t \n\tinit_waitqueue_head(&priv->read_queue);\n\tinit_waitqueue_head(&priv->int_queue);\n\n\trc = tpm_chip_bootstrap(chip);\n\tif (rc)\n\t\tgoto out_err;\n\n\tif (irq != -1) {\n\t\t \n\n\t\trc = tpm_tis_request_locality(chip, 0);\n\t\tif (rc < 0)\n\t\t\tgoto out_err;\n\n\t\trc = tpm_get_timeouts(chip);\n\n\t\ttpm_tis_relinquish_locality(chip, 0);\n\n\t\tif (rc) {\n\t\t\tdev_err(dev, \"Could not get TPM timeouts and durations\\n\");\n\t\t\trc = -ENODEV;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tif (irq)\n\t\t\ttpm_tis_probe_irq_single(chip, intmask, IRQF_SHARED,\n\t\t\t\t\t\t irq);\n\t\telse\n\t\t\ttpm_tis_probe_irq(chip, intmask);\n\n\t\tif (chip->flags & TPM_CHIP_FLAG_IRQ) {\n\t\t\tpriv->int_mask = intmask;\n\t\t} else {\n\t\t\tdev_err(&chip->dev, FW_BUG\n\t\t\t\t\t\"TPM interrupt not working, polling instead\\n\");\n\n\t\t\trc = tpm_tis_request_locality(chip, 0);\n\t\t\tif (rc < 0)\n\t\t\t\tgoto out_err;\n\t\t\ttpm_tis_disable_interrupts(chip);\n\t\t\ttpm_tis_relinquish_locality(chip, 0);\n\t\t}\n\t}\n\n\trc = tpm_chip_register(chip);\n\tif (rc)\n\t\tgoto out_err;\n\n\tif (chip->ops->clk_enable != NULL)\n\t\tchip->ops->clk_enable(chip, false);\n\n\treturn 0;\nout_err:\n\tif (chip->ops->clk_enable != NULL)\n\t\tchip->ops->clk_enable(chip, false);\n\n\ttpm_tis_remove(chip);\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(tpm_tis_core_init);\n\n#ifdef CONFIG_PM_SLEEP\nstatic void tpm_tis_reenable_interrupts(struct tpm_chip *chip)\n{\n\tstruct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);\n\tu32 intmask;\n\tint rc;\n\n\t \n\trc = tpm_tis_write8(priv, TPM_INT_VECTOR(priv->locality), priv->irq);\n\tif (rc < 0) {\n\t\tdev_err(&chip->dev, \"Setting IRQ failed.\\n\");\n\t\treturn;\n\t}\n\n\tintmask = priv->int_mask | TPM_GLOBAL_INT_ENABLE;\n\trc = tpm_tis_write32(priv, TPM_INT_ENABLE(priv->locality), intmask);\n\tif (rc < 0)\n\t\tdev_err(&chip->dev, \"Enabling interrupts failed.\\n\");\n}\n\nint tpm_tis_resume(struct device *dev)\n{\n\tstruct tpm_chip *chip = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = tpm_chip_start(chip);\n\tif (ret)\n\t\treturn ret;\n\n\tif (chip->flags & TPM_CHIP_FLAG_IRQ)\n\t\ttpm_tis_reenable_interrupts(chip);\n\n\t \n\tif (!(chip->flags & TPM_CHIP_FLAG_TPM2))\n\t\ttpm1_do_selftest(chip);\n\n\ttpm_chip_stop(chip);\n\n\tret = tpm_pm_resume(dev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(tpm_tis_resume);\n#endif\n\nMODULE_AUTHOR(\"Leendert van Doorn (leendert@watson.ibm.com)\");\nMODULE_DESCRIPTION(\"TPM Driver\");\nMODULE_VERSION(\"2.0\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}