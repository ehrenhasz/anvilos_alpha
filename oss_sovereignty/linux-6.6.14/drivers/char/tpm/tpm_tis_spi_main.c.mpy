{
  "module_name": "tpm_tis_spi_main.c",
  "hash_id": "0fa21966c13656a76c63d11331194626efa0f461a02e82dffba878acf45db47a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/tpm/tpm_tis_spi_main.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/completion.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include <linux/of.h>\n#include <linux/spi/spi.h>\n#include <linux/tpm.h>\n\n#include \"tpm.h\"\n#include \"tpm_tis_core.h\"\n#include \"tpm_tis_spi.h\"\n\n#define MAX_SPI_FRAMESIZE 64\n\n \nstatic int tpm_tis_spi_flow_control(struct tpm_tis_spi_phy *phy,\n\t\t\t\t    struct spi_transfer *spi_xfer)\n{\n\tstruct spi_message m;\n\tint ret, i;\n\n\tif ((phy->iobuf[3] & 0x01) == 0) {\n\t\t\n\t\tfor (i = 0; i < TPM_RETRY; i++) {\n\t\t\tspi_xfer->len = 1;\n\t\t\tspi_message_init(&m);\n\t\t\tspi_message_add_tail(spi_xfer, &m);\n\t\t\tret = spi_sync_locked(phy->spi_device, &m);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (phy->iobuf[0] & 0x01)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i == TPM_RETRY)\n\t\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int tpm_tis_spi_transfer_half(struct tpm_tis_data *data,\tu32 addr,\n\t\t\t\t     u16 len, u8 *in, const u8 *out)\n{\n\tstruct tpm_tis_spi_phy *phy = to_tpm_tis_spi_phy(data);\n\tstruct spi_transfer spi_xfer[3];\n\tstruct spi_message m;\n\tu8 transfer_len;\n\tint ret;\n\n\twhile (len) {\n\t\ttransfer_len = min_t(u16, len, MAX_SPI_FRAMESIZE);\n\n\t\tspi_message_init(&m);\n\t\tphy->iobuf[0] = (in ? 0x80 : 0) | (transfer_len - 1);\n\t\tphy->iobuf[1] = 0xd4;\n\t\tphy->iobuf[2] = addr >> 8;\n\t\tphy->iobuf[3] = addr;\n\n\t\tmemset(&spi_xfer, 0, sizeof(spi_xfer));\n\n\t\tspi_xfer[0].tx_buf = phy->iobuf;\n\t\tspi_xfer[0].len = 1;\n\t\tspi_message_add_tail(&spi_xfer[0], &m);\n\n\t\tspi_xfer[1].tx_buf = phy->iobuf + 1;\n\t\tspi_xfer[1].len = 3;\n\t\tspi_message_add_tail(&spi_xfer[1], &m);\n\n\t\tif (out) {\n\t\t\tspi_xfer[2].tx_buf = &phy->iobuf[4];\n\t\t\tspi_xfer[2].rx_buf = NULL;\n\t\t\tmemcpy(&phy->iobuf[4], out, transfer_len);\n\t\t\tout += transfer_len;\n\t\t}\n\n\t\tif (in) {\n\t\t\tspi_xfer[2].tx_buf = NULL;\n\t\t\tspi_xfer[2].rx_buf = &phy->iobuf[4];\n\t\t}\n\n\t\tspi_xfer[2].len = transfer_len;\n\t\tspi_message_add_tail(&spi_xfer[2], &m);\n\n\t\treinit_completion(&phy->ready);\n\n\t\tret = spi_sync(phy->spi_device, &m);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (in) {\n\t\t\tmemcpy(in, &phy->iobuf[4], transfer_len);\n\t\t\tin += transfer_len;\n\t\t}\n\n\t\tlen -= transfer_len;\n\t}\n\n\treturn ret;\n}\n\nstatic int tpm_tis_spi_transfer_full(struct tpm_tis_data *data, u32 addr,\n\t\t\t\t     u16 len, u8 *in, const u8 *out)\n{\n\tstruct tpm_tis_spi_phy *phy = to_tpm_tis_spi_phy(data);\n\tint ret = 0;\n\tstruct spi_message m;\n\tstruct spi_transfer spi_xfer;\n\tu8 transfer_len;\n\n\tspi_bus_lock(phy->spi_device->master);\n\n\twhile (len) {\n\t\ttransfer_len = min_t(u16, len, MAX_SPI_FRAMESIZE);\n\n\t\tphy->iobuf[0] = (in ? 0x80 : 0) | (transfer_len - 1);\n\t\tphy->iobuf[1] = 0xd4;\n\t\tphy->iobuf[2] = addr >> 8;\n\t\tphy->iobuf[3] = addr;\n\n\t\tmemset(&spi_xfer, 0, sizeof(spi_xfer));\n\t\tspi_xfer.tx_buf = phy->iobuf;\n\t\tspi_xfer.rx_buf = phy->iobuf;\n\t\tspi_xfer.len = 4;\n\t\tspi_xfer.cs_change = 1;\n\n\t\tspi_message_init(&m);\n\t\tspi_message_add_tail(&spi_xfer, &m);\n\t\tret = spi_sync_locked(phy->spi_device, &m);\n\t\tif (ret < 0)\n\t\t\tgoto exit;\n\n\t\t \n\t\tspi_xfer.tx_buf = NULL;\n\t\tret = phy->flow_control(phy, &spi_xfer);\n\t\tif (ret < 0)\n\t\t\tgoto exit;\n\n\t\tspi_xfer.cs_change = 0;\n\t\tspi_xfer.len = transfer_len;\n\t\tspi_xfer.delay.value = 5;\n\t\tspi_xfer.delay.unit = SPI_DELAY_UNIT_USECS;\n\n\t\tif (out) {\n\t\t\tspi_xfer.tx_buf = phy->iobuf;\n\t\t\tspi_xfer.rx_buf = NULL;\n\t\t\tmemcpy(phy->iobuf, out, transfer_len);\n\t\t\tout += transfer_len;\n\t\t}\n\n\t\tspi_message_init(&m);\n\t\tspi_message_add_tail(&spi_xfer, &m);\n\t\treinit_completion(&phy->ready);\n\t\tret = spi_sync_locked(phy->spi_device, &m);\n\t\tif (ret < 0)\n\t\t\tgoto exit;\n\n\t\tif (in) {\n\t\t\tmemcpy(in, phy->iobuf, transfer_len);\n\t\t\tin += transfer_len;\n\t\t}\n\n\t\tlen -= transfer_len;\n\t}\n\nexit:\n\tif (ret < 0) {\n\t\t \n\t\tmemset(&spi_xfer, 0, sizeof(spi_xfer));\n\t\tspi_message_init(&m);\n\t\tspi_message_add_tail(&spi_xfer, &m);\n\t\tspi_sync_locked(phy->spi_device, &m);\n\t}\n\n\tspi_bus_unlock(phy->spi_device->master);\n\treturn ret;\n}\n\nint tpm_tis_spi_transfer(struct tpm_tis_data *data, u32 addr, u16 len,\n\t\t\t u8 *in, const u8 *out)\n{\n\tstruct tpm_tis_spi_phy *phy = to_tpm_tis_spi_phy(data);\n\tstruct spi_controller *ctlr = phy->spi_device->controller;\n\n\t \n\tif (ctlr->flags & SPI_CONTROLLER_HALF_DUPLEX)\n\t\treturn tpm_tis_spi_transfer_half(data, addr, len, in, out);\n\telse\n\t\treturn tpm_tis_spi_transfer_full(data, addr, len, in, out);\n}\n\nstatic int tpm_tis_spi_read_bytes(struct tpm_tis_data *data, u32 addr,\n\t\t\t\t  u16 len, u8 *result, enum tpm_tis_io_mode io_mode)\n{\n\treturn tpm_tis_spi_transfer(data, addr, len, result, NULL);\n}\n\nstatic int tpm_tis_spi_write_bytes(struct tpm_tis_data *data, u32 addr,\n\t\t\t\t   u16 len, const u8 *value, enum tpm_tis_io_mode io_mode)\n{\n\treturn tpm_tis_spi_transfer(data, addr, len, NULL, value);\n}\n\nint tpm_tis_spi_init(struct spi_device *spi, struct tpm_tis_spi_phy *phy,\n\t\t     int irq, const struct tpm_tis_phy_ops *phy_ops)\n{\n\tphy->iobuf = devm_kmalloc(&spi->dev, MAX_SPI_FRAMESIZE, GFP_KERNEL);\n\tif (!phy->iobuf)\n\t\treturn -ENOMEM;\n\n\tphy->spi_device = spi;\n\n\treturn tpm_tis_core_init(&spi->dev, &phy->priv, irq, phy_ops, NULL);\n}\n\nstatic const struct tpm_tis_phy_ops tpm_spi_phy_ops = {\n\t.read_bytes = tpm_tis_spi_read_bytes,\n\t.write_bytes = tpm_tis_spi_write_bytes,\n};\n\nstatic int tpm_tis_spi_probe(struct spi_device *dev)\n{\n\tstruct tpm_tis_spi_phy *phy;\n\tint irq;\n\n\tphy = devm_kzalloc(&dev->dev, sizeof(struct tpm_tis_spi_phy),\n\t\t\t   GFP_KERNEL);\n\tif (!phy)\n\t\treturn -ENOMEM;\n\n\tphy->flow_control = tpm_tis_spi_flow_control;\n\n\tif (dev->controller->flags & SPI_CONTROLLER_HALF_DUPLEX)\n\t\tdev->mode |= SPI_TPM_HW_FLOW;\n\n\t \n\tif (dev->irq > 0)\n\t\tirq = dev->irq;\n\telse\n\t\tirq = -1;\n\n\tinit_completion(&phy->ready);\n\treturn tpm_tis_spi_init(dev, phy, irq, &tpm_spi_phy_ops);\n}\n\ntypedef int (*tpm_tis_spi_probe_func)(struct spi_device *);\n\nstatic int tpm_tis_spi_driver_probe(struct spi_device *spi)\n{\n\tconst struct spi_device_id *spi_dev_id = spi_get_device_id(spi);\n\ttpm_tis_spi_probe_func probe_func;\n\n\tprobe_func = of_device_get_match_data(&spi->dev);\n\tif (!probe_func) {\n\t\tif (spi_dev_id) {\n\t\t\tprobe_func = (tpm_tis_spi_probe_func)spi_dev_id->driver_data;\n\t\t\tif (!probe_func)\n\t\t\t\treturn -ENODEV;\n\t\t} else\n\t\t\tprobe_func = tpm_tis_spi_probe;\n\t}\n\n\treturn probe_func(spi);\n}\n\nstatic SIMPLE_DEV_PM_OPS(tpm_tis_pm, tpm_pm_suspend, tpm_tis_spi_resume);\n\nstatic void tpm_tis_spi_remove(struct spi_device *dev)\n{\n\tstruct tpm_chip *chip = spi_get_drvdata(dev);\n\n\ttpm_chip_unregister(chip);\n\ttpm_tis_remove(chip);\n}\n\nstatic const struct spi_device_id tpm_tis_spi_id[] = {\n\t{ \"st33htpm-spi\", (unsigned long)tpm_tis_spi_probe },\n\t{ \"slb9670\", (unsigned long)tpm_tis_spi_probe },\n\t{ \"tpm_tis_spi\", (unsigned long)tpm_tis_spi_probe },\n\t{ \"tpm_tis-spi\", (unsigned long)tpm_tis_spi_probe },\n\t{ \"cr50\", (unsigned long)cr50_spi_probe },\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, tpm_tis_spi_id);\n\nstatic const struct of_device_id of_tis_spi_match[] __maybe_unused = {\n\t{ .compatible = \"st,st33htpm-spi\", .data = tpm_tis_spi_probe },\n\t{ .compatible = \"infineon,slb9670\", .data = tpm_tis_spi_probe },\n\t{ .compatible = \"tcg,tpm_tis-spi\", .data = tpm_tis_spi_probe },\n\t{ .compatible = \"google,cr50\", .data = cr50_spi_probe },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, of_tis_spi_match);\n\nstatic const struct acpi_device_id acpi_tis_spi_match[] __maybe_unused = {\n\t{\"SMO0768\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(acpi, acpi_tis_spi_match);\n\nstatic struct spi_driver tpm_tis_spi_driver = {\n\t.driver = {\n\t\t.name = \"tpm_tis_spi\",\n\t\t.pm = &tpm_tis_pm,\n\t\t.of_match_table = of_match_ptr(of_tis_spi_match),\n\t\t.acpi_match_table = ACPI_PTR(acpi_tis_spi_match),\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n\t.probe = tpm_tis_spi_driver_probe,\n\t.remove = tpm_tis_spi_remove,\n\t.id_table = tpm_tis_spi_id,\n};\nmodule_spi_driver(tpm_tis_spi_driver);\n\nMODULE_DESCRIPTION(\"TPM Driver for native SPI access\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}