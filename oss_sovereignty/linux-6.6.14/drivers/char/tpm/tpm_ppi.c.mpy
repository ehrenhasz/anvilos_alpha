{
  "module_name": "tpm_ppi.c",
  "hash_id": "756264fe693c40826a764c315b30666f41313ee7edd4d43199c86940c6e9bb37",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/tpm/tpm_ppi.c",
  "human_readable_source": "\n \n\n\n#include <linux/acpi.h>\n#include \"tpm.h\"\n\n#define TPM_PPI_REVISION_ID_1\t1\n#define TPM_PPI_REVISION_ID_2\t2\n#define TPM_PPI_FN_VERSION\t1\n#define TPM_PPI_FN_SUBREQ\t2\n#define TPM_PPI_FN_GETREQ\t3\n#define TPM_PPI_FN_GETACT\t4\n#define TPM_PPI_FN_GETRSP\t5\n#define TPM_PPI_FN_SUBREQ2\t7\n#define TPM_PPI_FN_GETOPR\t8\n#define PPI_TPM_REQ_MAX\t\t101  \n#define PPI_VS_REQ_START\t128\n#define PPI_VS_REQ_END\t\t255\n\nstatic const guid_t tpm_ppi_guid =\n\tGUID_INIT(0x3DDDFAA6, 0x361B, 0x4EB4,\n\t\t  0xA4, 0x24, 0x8D, 0x10, 0x08, 0x9D, 0x16, 0x53);\n\nstatic bool tpm_ppi_req_has_parameter(u64 req)\n{\n\treturn req == 23;\n}\n\nstatic inline union acpi_object *\ntpm_eval_dsm(acpi_handle ppi_handle, int func, acpi_object_type type,\n\t     union acpi_object *argv4, u64 rev)\n{\n\tBUG_ON(!ppi_handle);\n\treturn acpi_evaluate_dsm_typed(ppi_handle, &tpm_ppi_guid,\n\t\t\t\t       rev, func, argv4, type);\n}\n\nstatic ssize_t tpm_show_ppi_version(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct tpm_chip *chip = to_tpm_chip(dev);\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%s\\n\", chip->ppi_version);\n}\n\nstatic ssize_t tpm_show_ppi_request(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tssize_t size = -EINVAL;\n\tunion acpi_object *obj;\n\tstruct tpm_chip *chip = to_tpm_chip(dev);\n\tu64 rev = TPM_PPI_REVISION_ID_2;\n\tu64 req;\n\n\tif (strcmp(chip->ppi_version, \"1.2\") < 0)\n\t\trev = TPM_PPI_REVISION_ID_1;\n\n\tobj = tpm_eval_dsm(chip->acpi_dev_handle, TPM_PPI_FN_GETREQ,\n\t\t\t   ACPI_TYPE_PACKAGE, NULL, rev);\n\tif (!obj)\n\t\treturn -ENXIO;\n\n\t \n\tif (obj->package.count == 3 &&\n\t    obj->package.elements[0].type == ACPI_TYPE_INTEGER &&\n\t    obj->package.elements[1].type == ACPI_TYPE_INTEGER &&\n\t    obj->package.elements[2].type == ACPI_TYPE_INTEGER) {\n\t\tif (obj->package.elements[0].integer.value)\n\t\t\tsize = -EFAULT;\n\t\telse {\n\t\t\treq = obj->package.elements[1].integer.value;\n\t\t\tif (tpm_ppi_req_has_parameter(req))\n\t\t\t\tsize = scnprintf(buf, PAGE_SIZE,\n\t\t\t\t    \"%llu %llu\\n\", req,\n\t\t\t\t    obj->package.elements[2].integer.value);\n\t\t\telse\n\t\t\t\tsize = scnprintf(buf, PAGE_SIZE,\n\t\t\t\t\t\t\"%llu\\n\", req);\n\t\t}\n\t} else if (obj->package.count == 2 &&\n\t    obj->package.elements[0].type == ACPI_TYPE_INTEGER &&\n\t    obj->package.elements[1].type == ACPI_TYPE_INTEGER) {\n\t\tif (obj->package.elements[0].integer.value)\n\t\t\tsize = -EFAULT;\n\t\telse\n\t\t\tsize = scnprintf(buf, PAGE_SIZE, \"%llu\\n\",\n\t\t\t\t obj->package.elements[1].integer.value);\n\t}\n\n\tACPI_FREE(obj);\n\n\treturn size;\n}\n\nstatic ssize_t tpm_store_ppi_request(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tu32 req;\n\tu64 ret;\n\tint func = TPM_PPI_FN_SUBREQ;\n\tunion acpi_object *obj, tmp[2];\n\tunion acpi_object argv4 = ACPI_INIT_DSM_ARGV4(2, tmp);\n\tstruct tpm_chip *chip = to_tpm_chip(dev);\n\tu64 rev = TPM_PPI_REVISION_ID_1;\n\n\t \n\tif (acpi_check_dsm(chip->acpi_dev_handle, &tpm_ppi_guid,\n\t\t\t   TPM_PPI_REVISION_ID_1, 1 << TPM_PPI_FN_SUBREQ2))\n\t\tfunc = TPM_PPI_FN_SUBREQ2;\n\n\t \n\tif (strcmp(chip->ppi_version, \"1.3\") == 0) {\n\t\tif (sscanf(buf, \"%llu %llu\", &tmp[0].integer.value,\n\t\t\t   &tmp[1].integer.value) != 2)\n\t\t\tgoto ppi12;\n\t\trev = TPM_PPI_REVISION_ID_2;\n\t\ttmp[0].type = ACPI_TYPE_INTEGER;\n\t\ttmp[1].type = ACPI_TYPE_INTEGER;\n\t} else if (strcmp(chip->ppi_version, \"1.2\") < 0) {\n\t\tif (sscanf(buf, \"%d\", &req) != 1)\n\t\t\treturn -EINVAL;\n\t\targv4.type = ACPI_TYPE_BUFFER;\n\t\targv4.buffer.length = sizeof(req);\n\t\targv4.buffer.pointer = (u8 *)&req;\n\t} else {\nppi12:\n\t\targv4.package.count = 1;\n\t\ttmp[0].type = ACPI_TYPE_INTEGER;\n\t\tif (sscanf(buf, \"%llu\", &tmp[0].integer.value) != 1)\n\t\t\treturn -EINVAL;\n\t}\n\n\tobj = tpm_eval_dsm(chip->acpi_dev_handle, func, ACPI_TYPE_INTEGER,\n\t\t\t   &argv4, rev);\n\tif (!obj) {\n\t\treturn -ENXIO;\n\t} else {\n\t\tret = obj->integer.value;\n\t\tACPI_FREE(obj);\n\t}\n\n\tif (ret == 0)\n\t\treturn (acpi_status)count;\n\n\treturn (ret == 1) ? -EPERM : -EFAULT;\n}\n\nstatic ssize_t tpm_show_ppi_transition_action(struct device *dev,\n\t\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t\t      char *buf)\n{\n\tu32 ret;\n\tacpi_status status;\n\tunion acpi_object *obj = NULL;\n\tunion acpi_object tmp = {\n\t\t.buffer.type = ACPI_TYPE_BUFFER,\n\t\t.buffer.length = 0,\n\t\t.buffer.pointer = NULL\n\t};\n\tstruct tpm_chip *chip = to_tpm_chip(dev);\n\n\tstatic char *info[] = {\n\t\t\"None\",\n\t\t\"Shutdown\",\n\t\t\"Reboot\",\n\t\t\"OS Vendor-specific\",\n\t\t\"Error\",\n\t};\n\n\t \n\tif (strcmp(chip->ppi_version, \"1.2\") < 0)\n\t\tobj = &tmp;\n\tobj = tpm_eval_dsm(chip->acpi_dev_handle, TPM_PPI_FN_GETACT,\n\t\t\t   ACPI_TYPE_INTEGER, obj, TPM_PPI_REVISION_ID_1);\n\tif (!obj) {\n\t\treturn -ENXIO;\n\t} else {\n\t\tret = obj->integer.value;\n\t\tACPI_FREE(obj);\n\t}\n\n\tif (ret < ARRAY_SIZE(info) - 1)\n\t\tstatus = scnprintf(buf, PAGE_SIZE, \"%d: %s\\n\", ret, info[ret]);\n\telse\n\t\tstatus = scnprintf(buf, PAGE_SIZE, \"%d: %s\\n\", ret,\n\t\t\t\t   info[ARRAY_SIZE(info)-1]);\n\treturn status;\n}\n\nstatic ssize_t tpm_show_ppi_response(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     char *buf)\n{\n\tacpi_status status = -EINVAL;\n\tunion acpi_object *obj, *ret_obj;\n\tu64 req, res;\n\tstruct tpm_chip *chip = to_tpm_chip(dev);\n\n\tobj = tpm_eval_dsm(chip->acpi_dev_handle, TPM_PPI_FN_GETRSP,\n\t\t\t   ACPI_TYPE_PACKAGE, NULL, TPM_PPI_REVISION_ID_1);\n\tif (!obj)\n\t\treturn -ENXIO;\n\n\t \n\tret_obj = obj->package.elements;\n\tif (obj->package.count < 3 ||\n\t    ret_obj[0].type != ACPI_TYPE_INTEGER ||\n\t    ret_obj[1].type != ACPI_TYPE_INTEGER ||\n\t    ret_obj[2].type != ACPI_TYPE_INTEGER)\n\t\tgoto cleanup;\n\n\tif (ret_obj[0].integer.value) {\n\t\tstatus = -EFAULT;\n\t\tgoto cleanup;\n\t}\n\n\treq = ret_obj[1].integer.value;\n\tres = ret_obj[2].integer.value;\n\tif (req) {\n\t\tif (res == 0)\n\t\t\tstatus = scnprintf(buf, PAGE_SIZE, \"%llu %s\\n\", req,\n\t\t\t\t\t   \"0: Success\");\n\t\telse if (res == 0xFFFFFFF0)\n\t\t\tstatus = scnprintf(buf, PAGE_SIZE, \"%llu %s\\n\", req,\n\t\t\t\t\t   \"0xFFFFFFF0: User Abort\");\n\t\telse if (res == 0xFFFFFFF1)\n\t\t\tstatus = scnprintf(buf, PAGE_SIZE, \"%llu %s\\n\", req,\n\t\t\t\t\t   \"0xFFFFFFF1: BIOS Failure\");\n\t\telse if (res >= 1 && res <= 0x00000FFF)\n\t\t\tstatus = scnprintf(buf, PAGE_SIZE, \"%llu %llu: %s\\n\",\n\t\t\t\t\t   req, res, \"Corresponding TPM error\");\n\t\telse\n\t\t\tstatus = scnprintf(buf, PAGE_SIZE, \"%llu %llu: %s\\n\",\n\t\t\t\t\t   req, res, \"Error\");\n\t} else {\n\t\tstatus = scnprintf(buf, PAGE_SIZE, \"%llu: %s\\n\",\n\t\t\t\t   req, \"No Recent Request\");\n\t}\n\ncleanup:\n\tACPI_FREE(obj);\n\treturn status;\n}\n\nstatic ssize_t show_ppi_operations(acpi_handle dev_handle, char *buf, u32 start,\n\t\t\t\t   u32 end)\n{\n\tint i;\n\tu32 ret;\n\tchar *str = buf;\n\tunion acpi_object *obj, tmp;\n\tunion acpi_object argv = ACPI_INIT_DSM_ARGV4(1, &tmp);\n\n\tstatic char *info[] = {\n\t\t\"Not implemented\",\n\t\t\"BIOS only\",\n\t\t\"Blocked for OS by BIOS\",\n\t\t\"User required\",\n\t\t\"User not required\",\n\t};\n\n\tif (!acpi_check_dsm(dev_handle, &tpm_ppi_guid, TPM_PPI_REVISION_ID_1,\n\t\t\t    1 << TPM_PPI_FN_GETOPR))\n\t\treturn -EPERM;\n\n\ttmp.integer.type = ACPI_TYPE_INTEGER;\n\tfor (i = start; i <= end; i++) {\n\t\ttmp.integer.value = i;\n\t\tobj = tpm_eval_dsm(dev_handle, TPM_PPI_FN_GETOPR,\n\t\t\t\t   ACPI_TYPE_INTEGER, &argv,\n\t\t\t\t   TPM_PPI_REVISION_ID_1);\n\t\tif (!obj) {\n\t\t\treturn -ENOMEM;\n\t\t} else {\n\t\t\tret = obj->integer.value;\n\t\t\tACPI_FREE(obj);\n\t\t}\n\n\t\tif (ret > 0 && ret < ARRAY_SIZE(info))\n\t\t\tstr += scnprintf(str, PAGE_SIZE, \"%d %d: %s\\n\",\n\t\t\t\t\t i, ret, info[ret]);\n\t}\n\n\treturn str - buf;\n}\n\nstatic ssize_t tpm_show_ppi_tcg_operations(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   char *buf)\n{\n\tstruct tpm_chip *chip = to_tpm_chip(dev);\n\n\treturn show_ppi_operations(chip->acpi_dev_handle, buf, 0,\n\t\t\t\t   PPI_TPM_REQ_MAX);\n}\n\nstatic ssize_t tpm_show_ppi_vs_operations(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  char *buf)\n{\n\tstruct tpm_chip *chip = to_tpm_chip(dev);\n\n\treturn show_ppi_operations(chip->acpi_dev_handle, buf, PPI_VS_REQ_START,\n\t\t\t\t   PPI_VS_REQ_END);\n}\n\nstatic DEVICE_ATTR(version, S_IRUGO, tpm_show_ppi_version, NULL);\nstatic DEVICE_ATTR(request, S_IRUGO | S_IWUSR | S_IWGRP,\n\t\t   tpm_show_ppi_request, tpm_store_ppi_request);\nstatic DEVICE_ATTR(transition_action, S_IRUGO,\n\t\t   tpm_show_ppi_transition_action, NULL);\nstatic DEVICE_ATTR(response, S_IRUGO, tpm_show_ppi_response, NULL);\nstatic DEVICE_ATTR(tcg_operations, S_IRUGO, tpm_show_ppi_tcg_operations, NULL);\nstatic DEVICE_ATTR(vs_operations, S_IRUGO, tpm_show_ppi_vs_operations, NULL);\n\nstatic struct attribute *ppi_attrs[] = {\n\t&dev_attr_version.attr,\n\t&dev_attr_request.attr,\n\t&dev_attr_transition_action.attr,\n\t&dev_attr_response.attr,\n\t&dev_attr_tcg_operations.attr,\n\t&dev_attr_vs_operations.attr, NULL,\n};\nstatic const struct attribute_group ppi_attr_grp = {\n\t.name = \"ppi\",\n\t.attrs = ppi_attrs\n};\n\nvoid tpm_add_ppi(struct tpm_chip *chip)\n{\n\tunion acpi_object *obj;\n\n\tif (!chip->acpi_dev_handle)\n\t\treturn;\n\n\tif (!acpi_check_dsm(chip->acpi_dev_handle, &tpm_ppi_guid,\n\t\t\t    TPM_PPI_REVISION_ID_1, 1 << TPM_PPI_FN_VERSION))\n\t\treturn;\n\n\t \n\tobj = acpi_evaluate_dsm_typed(chip->acpi_dev_handle, &tpm_ppi_guid,\n\t\t\t\t      TPM_PPI_REVISION_ID_1,\n\t\t\t\t      TPM_PPI_FN_VERSION,\n\t\t\t\t      NULL, ACPI_TYPE_STRING);\n\tif (obj) {\n\t\tstrscpy(chip->ppi_version, obj->string.pointer,\n\t\t\tsizeof(chip->ppi_version));\n\t\tACPI_FREE(obj);\n\t}\n\n\tchip->groups[chip->groups_cnt++] = &ppi_attr_grp;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}