{
  "module_name": "tpm_tis_core.h",
  "hash_id": "66eae52db6ff519adf8298fb3f70e204e178ed98d5d1150b97f878a376955188",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/tpm/tpm_tis_core.h",
  "human_readable_source": " \n \n\n#ifndef __TPM_TIS_CORE_H__\n#define __TPM_TIS_CORE_H__\n\n#include \"tpm.h\"\n\nenum tis_access {\n\tTPM_ACCESS_VALID = 0x80,\n\tTPM_ACCESS_ACTIVE_LOCALITY = 0x20,\n\tTPM_ACCESS_REQUEST_PENDING = 0x04,\n\tTPM_ACCESS_REQUEST_USE = 0x02,\n};\n\nenum tis_status {\n\tTPM_STS_VALID = 0x80,\n\tTPM_STS_COMMAND_READY = 0x40,\n\tTPM_STS_GO = 0x20,\n\tTPM_STS_DATA_AVAIL = 0x10,\n\tTPM_STS_DATA_EXPECT = 0x08,\n\tTPM_STS_RESPONSE_RETRY = 0x02,\n\tTPM_STS_READ_ZERO = 0x23,  \n};\n\nenum tis_int_flags {\n\tTPM_GLOBAL_INT_ENABLE = 0x80000000,\n\tTPM_INTF_BURST_COUNT_STATIC = 0x100,\n\tTPM_INTF_CMD_READY_INT = 0x080,\n\tTPM_INTF_INT_EDGE_FALLING = 0x040,\n\tTPM_INTF_INT_EDGE_RISING = 0x020,\n\tTPM_INTF_INT_LEVEL_LOW = 0x010,\n\tTPM_INTF_INT_LEVEL_HIGH = 0x008,\n\tTPM_INTF_LOCALITY_CHANGE_INT = 0x004,\n\tTPM_INTF_STS_VALID_INT = 0x002,\n\tTPM_INTF_DATA_AVAIL_INT = 0x001,\n};\n\nenum tis_defaults {\n\tTIS_MEM_LEN = 0x5000,\n\tTIS_SHORT_TIMEOUT = 750,\t \n\tTIS_LONG_TIMEOUT = 2000,\t \n\tTIS_TIMEOUT_MIN_ATML = 14700,\t \n\tTIS_TIMEOUT_MAX_ATML = 15000,\t \n};\n\n \n#define TIS_TIMEOUT_A_MAX\tmax_t(int, TIS_SHORT_TIMEOUT, TPM2_TIMEOUT_A)\n#define TIS_TIMEOUT_B_MAX\tmax_t(int, TIS_LONG_TIMEOUT, TPM2_TIMEOUT_B)\n#define TIS_TIMEOUT_C_MAX\tmax_t(int, TIS_SHORT_TIMEOUT, TPM2_TIMEOUT_C)\n#define TIS_TIMEOUT_D_MAX\tmax_t(int, TIS_SHORT_TIMEOUT, TPM2_TIMEOUT_D)\n\n#define\tTPM_ACCESS(l)\t\t\t(0x0000 | ((l) << 12))\n#define\tTPM_INT_ENABLE(l)\t\t(0x0008 | ((l) << 12))\n#define\tTPM_INT_VECTOR(l)\t\t(0x000C | ((l) << 12))\n#define\tTPM_INT_STATUS(l)\t\t(0x0010 | ((l) << 12))\n#define\tTPM_INTF_CAPS(l)\t\t(0x0014 | ((l) << 12))\n#define\tTPM_STS(l)\t\t\t(0x0018 | ((l) << 12))\n#define\tTPM_STS3(l)\t\t\t(0x001b | ((l) << 12))\n#define\tTPM_DATA_FIFO(l)\t\t(0x0024 | ((l) << 12))\n\n#define\tTPM_DID_VID(l)\t\t\t(0x0F00 | ((l) << 12))\n#define\tTPM_RID(l)\t\t\t(0x0F04 | ((l) << 12))\n\n#define LPC_CNTRL_OFFSET\t\t0x84\n#define LPC_CLKRUN_EN\t\t\t(1 << 2)\n#define INTEL_LEGACY_BLK_BASE_ADDR\t0xFED08000\n#define ILB_REMAP_SIZE\t\t\t0x100\n\nenum tpm_tis_flags {\n\tTPM_TIS_ITPM_WORKAROUND\t\t= 0,\n\tTPM_TIS_INVALID_STATUS\t\t= 1,\n\tTPM_TIS_DEFAULT_CANCELLATION\t= 2,\n\tTPM_TIS_IRQ_TESTED\t\t= 3,\n};\n\nstruct tpm_tis_data {\n\tstruct tpm_chip *chip;\n\tu16 manufacturer_id;\n\tstruct mutex locality_count_mutex;\n\tunsigned int locality_count;\n\tint locality;\n\tint irq;\n\tstruct work_struct free_irq_work;\n\tunsigned long last_unhandled_irq;\n\tunsigned int unhandled_irqs;\n\tunsigned int int_mask;\n\tunsigned long flags;\n\tvoid __iomem *ilb_base_addr;\n\tu16 clkrun_enabled;\n\twait_queue_head_t int_queue;\n\twait_queue_head_t read_queue;\n\tconst struct tpm_tis_phy_ops *phy_ops;\n\tunsigned short rng_quality;\n\tunsigned int timeout_min;  \n\tunsigned int timeout_max;  \n};\n\n \nenum tpm_tis_io_mode {\n\tTPM_TIS_PHYS_8,\n\tTPM_TIS_PHYS_16,\n\tTPM_TIS_PHYS_32,\n};\n\nstruct tpm_tis_phy_ops {\n\t \n\tint (*read_bytes)(struct tpm_tis_data *data, u32 addr, u16 len,\n\t\t\t  u8 *result, enum tpm_tis_io_mode mode);\n\tint (*write_bytes)(struct tpm_tis_data *data, u32 addr, u16 len,\n\t\t\t   const u8 *value, enum tpm_tis_io_mode mode);\n\tint (*verify_crc)(struct tpm_tis_data *data, size_t len,\n\t\t\t  const u8 *value);\n};\n\nstatic inline int tpm_tis_read_bytes(struct tpm_tis_data *data, u32 addr,\n\t\t\t\t     u16 len, u8 *result)\n{\n\treturn data->phy_ops->read_bytes(data, addr, len, result,\n\t\t\t\t\t TPM_TIS_PHYS_8);\n}\n\nstatic inline int tpm_tis_read8(struct tpm_tis_data *data, u32 addr, u8 *result)\n{\n\treturn data->phy_ops->read_bytes(data, addr, 1, result, TPM_TIS_PHYS_8);\n}\n\nstatic inline int tpm_tis_read16(struct tpm_tis_data *data, u32 addr,\n\t\t\t\t u16 *result)\n{\n\t__le16 result_le;\n\tint rc;\n\n\trc = data->phy_ops->read_bytes(data, addr, sizeof(u16),\n\t\t\t\t       (u8 *)&result_le, TPM_TIS_PHYS_16);\n\tif (!rc)\n\t\t*result = le16_to_cpu(result_le);\n\n\treturn rc;\n}\n\nstatic inline int tpm_tis_read32(struct tpm_tis_data *data, u32 addr,\n\t\t\t\t u32 *result)\n{\n\t__le32 result_le;\n\tint rc;\n\n\trc = data->phy_ops->read_bytes(data, addr, sizeof(u32),\n\t\t\t\t       (u8 *)&result_le, TPM_TIS_PHYS_32);\n\tif (!rc)\n\t\t*result = le32_to_cpu(result_le);\n\n\treturn rc;\n}\n\nstatic inline int tpm_tis_write_bytes(struct tpm_tis_data *data, u32 addr,\n\t\t\t\t      u16 len, const u8 *value)\n{\n\treturn data->phy_ops->write_bytes(data, addr, len, value,\n\t\t\t\t\t  TPM_TIS_PHYS_8);\n}\n\nstatic inline int tpm_tis_write8(struct tpm_tis_data *data, u32 addr, u8 value)\n{\n\treturn data->phy_ops->write_bytes(data, addr, 1, &value,\n\t\t\t\t\t  TPM_TIS_PHYS_8);\n}\n\nstatic inline int tpm_tis_write32(struct tpm_tis_data *data, u32 addr,\n\t\t\t\t  u32 value)\n{\n\t__le32 value_le;\n\tint rc;\n\n\tvalue_le = cpu_to_le32(value);\n\trc =  data->phy_ops->write_bytes(data, addr, sizeof(u32),\n\t\t\t\t\t (u8 *)&value_le, TPM_TIS_PHYS_32);\n\treturn rc;\n}\n\nstatic inline int tpm_tis_verify_crc(struct tpm_tis_data *data, size_t len,\n\t\t\t\t     const u8 *value)\n{\n\tif (!data->phy_ops->verify_crc)\n\t\treturn 0;\n\treturn data->phy_ops->verify_crc(data, len, value);\n}\n\nstatic inline bool is_bsw(void)\n{\n#ifdef CONFIG_X86\n\treturn ((boot_cpu_data.x86_model == INTEL_FAM6_ATOM_AIRMONT) ? 1 : 0);\n#else\n\treturn false;\n#endif\n}\n\nvoid tpm_tis_remove(struct tpm_chip *chip);\nint tpm_tis_core_init(struct device *dev, struct tpm_tis_data *priv, int irq,\n\t\t      const struct tpm_tis_phy_ops *phy_ops,\n\t\t      acpi_handle acpi_dev_handle);\n\n#ifdef CONFIG_PM_SLEEP\nint tpm_tis_resume(struct device *dev);\n#endif\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}