{
  "module_name": "tpm1-cmd.c",
  "hash_id": "ff84fac0868c974d0e6b427cfebcf9d0e54550c62290ce8a1e46b59d187b002a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/tpm/tpm1-cmd.c",
  "human_readable_source": "\n \n\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/freezer.h>\n#include <linux/tpm_eventlog.h>\n\n#include \"tpm.h\"\n\n#define TPM_MAX_ORDINAL 243\n\n \nstatic const u8 tpm1_ordinal_duration[TPM_MAX_ORDINAL] = {\n\tTPM_UNDEFINED,\t\t \n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\t\t \n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_SHORT,\t\t \n\tTPM_SHORT,\n\tTPM_MEDIUM,\n\tTPM_LONG,\n\tTPM_LONG,\n\tTPM_MEDIUM,\t\t \n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_MEDIUM,\n\tTPM_LONG,\n\tTPM_SHORT,\t\t \n\tTPM_SHORT,\n\tTPM_MEDIUM,\n\tTPM_MEDIUM,\n\tTPM_MEDIUM,\n\tTPM_SHORT,\t\t \n\tTPM_SHORT,\n\tTPM_MEDIUM,\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_MEDIUM,\t\t \n\tTPM_LONG,\n\tTPM_MEDIUM,\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_SHORT,\t\t \n\tTPM_MEDIUM,\n\tTPM_MEDIUM,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_MEDIUM,\t\t \n\tTPM_LONG,\n\tTPM_MEDIUM,\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_SHORT,\t\t \n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_LONG,\n\tTPM_MEDIUM,\t\t \n\tTPM_MEDIUM,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\t\t \n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_MEDIUM,\t\t \n\tTPM_MEDIUM,\n\tTPM_MEDIUM,\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_MEDIUM,\t\t \n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_SHORT,\t\t \n\tTPM_SHORT,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\t\t \n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_LONG,\t\t \n\tTPM_UNDEFINED,\n\tTPM_MEDIUM,\n\tTPM_LONG,\n\tTPM_SHORT,\n\tTPM_UNDEFINED,\t\t \n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_SHORT,\t\t \n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_UNDEFINED,\t\t \n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_MEDIUM,\t\t \n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\t\t \n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_SHORT,\t\t \n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_SHORT,\t\t \n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_LONG,\t\t \n\tTPM_LONG,\n\tTPM_MEDIUM,\n\tTPM_UNDEFINED,\n\tTPM_SHORT,\n\tTPM_SHORT,\t\t \n\tTPM_SHORT,\n\tTPM_LONG,\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_SHORT,\t\t \n\tTPM_MEDIUM,\n\tTPM_UNDEFINED,\n\tTPM_SHORT,\n\tTPM_MEDIUM,\n\tTPM_UNDEFINED,\t\t \n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_SHORT,\t\t \n\tTPM_SHORT,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\t\t \n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_SHORT,\t\t \n\tTPM_MEDIUM,\n\tTPM_MEDIUM,\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_UNDEFINED,\t\t \n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_SHORT,\t\t \n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\t\t \n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_LONG,\t\t \n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\t\t \n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_MEDIUM,\t\t \n\tTPM_SHORT,\n\tTPM_MEDIUM,\n\tTPM_MEDIUM,\n\tTPM_MEDIUM,\n\tTPM_MEDIUM,\t\t \n\tTPM_SHORT,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\t\t \n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\t\t \n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_SHORT,\t\t \n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_SHORT,\n\tTPM_SHORT,\t\t \n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_MEDIUM,\t\t \n\tTPM_UNDEFINED,\n\tTPM_MEDIUM,\n\tTPM_MEDIUM,\n\tTPM_MEDIUM,\n\tTPM_UNDEFINED,\t\t \n\tTPM_MEDIUM,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_SHORT,\n\tTPM_SHORT,\t\t \n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_SHORT,\n\tTPM_UNDEFINED,\t\t \n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_SHORT,\t\t \n\tTPM_LONG,\n\tTPM_MEDIUM,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\t\t \n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_UNDEFINED,\n\tTPM_SHORT,\t\t \n\tTPM_UNDEFINED,\n\tTPM_MEDIUM,\n};\n\n \nunsigned long tpm1_calc_ordinal_duration(struct tpm_chip *chip, u32 ordinal)\n{\n\tint duration_idx = TPM_UNDEFINED;\n\tint duration = 0;\n\n\t \n\tif (ordinal < TPM_MAX_ORDINAL)\n\t\tduration_idx = tpm1_ordinal_duration[ordinal];\n\n\tif (duration_idx != TPM_UNDEFINED)\n\t\tduration = chip->duration[duration_idx];\n\tif (duration <= 0)\n\t\treturn 2 * 60 * HZ;\n\telse\n\t\treturn duration;\n}\n\n#define TPM_ORD_STARTUP 153\n#define TPM_ST_CLEAR 1\n\n \nstatic int tpm1_startup(struct tpm_chip *chip)\n{\n\tstruct tpm_buf buf;\n\tint rc;\n\n\tdev_info(&chip->dev, \"starting up the TPM manually\\n\");\n\n\trc = tpm_buf_init(&buf, TPM_TAG_RQU_COMMAND, TPM_ORD_STARTUP);\n\tif (rc < 0)\n\t\treturn rc;\n\n\ttpm_buf_append_u16(&buf, TPM_ST_CLEAR);\n\n\trc = tpm_transmit_cmd(chip, &buf, 0, \"attempting to start the TPM\");\n\ttpm_buf_destroy(&buf);\n\treturn rc;\n}\n\nint tpm1_get_timeouts(struct tpm_chip *chip)\n{\n\tcap_t cap;\n\tunsigned long timeout_old[4], timeout_chip[4], timeout_eff[4];\n\tunsigned long durations[3];\n\tssize_t rc;\n\n\trc = tpm1_getcap(chip, TPM_CAP_PROP_TIS_TIMEOUT, &cap, NULL,\n\t\t\t sizeof(cap.timeout));\n\tif (rc == TPM_ERR_INVALID_POSTINIT) {\n\t\tif (tpm1_startup(chip))\n\t\t\treturn rc;\n\n\t\trc = tpm1_getcap(chip, TPM_CAP_PROP_TIS_TIMEOUT, &cap,\n\t\t\t\t \"attempting to determine the timeouts\",\n\t\t\t\t sizeof(cap.timeout));\n\t}\n\n\tif (rc) {\n\t\tdev_err(&chip->dev, \"A TPM error (%zd) occurred attempting to determine the timeouts\\n\",\n\t\t\trc);\n\t\treturn rc;\n\t}\n\n\ttimeout_old[0] = jiffies_to_usecs(chip->timeout_a);\n\ttimeout_old[1] = jiffies_to_usecs(chip->timeout_b);\n\ttimeout_old[2] = jiffies_to_usecs(chip->timeout_c);\n\ttimeout_old[3] = jiffies_to_usecs(chip->timeout_d);\n\ttimeout_chip[0] = be32_to_cpu(cap.timeout.a);\n\ttimeout_chip[1] = be32_to_cpu(cap.timeout.b);\n\ttimeout_chip[2] = be32_to_cpu(cap.timeout.c);\n\ttimeout_chip[3] = be32_to_cpu(cap.timeout.d);\n\tmemcpy(timeout_eff, timeout_chip, sizeof(timeout_eff));\n\n\t \n\tif (chip->ops->update_timeouts)\n\t\tchip->ops->update_timeouts(chip, timeout_eff);\n\n\tif (!chip->timeout_adjusted) {\n\t\t \n\t\tunsigned int i;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(timeout_eff); i++) {\n\t\t\tif (timeout_eff[i])\n\t\t\t\tcontinue;\n\n\t\t\ttimeout_eff[i] = timeout_old[i];\n\t\t\tchip->timeout_adjusted = true;\n\t\t}\n\n\t\tif (timeout_eff[0] != 0 && timeout_eff[0] < 1000) {\n\t\t\t \n\t\t\tfor (i = 0; i != ARRAY_SIZE(timeout_eff); i++)\n\t\t\t\ttimeout_eff[i] *= 1000;\n\t\t\tchip->timeout_adjusted = true;\n\t\t}\n\t}\n\n\t \n\tif (chip->timeout_adjusted) {\n\t\tdev_info(&chip->dev, HW_ERR \"Adjusting reported timeouts: A %lu->%luus B %lu->%luus C %lu->%luus D %lu->%luus\\n\",\n\t\t\t timeout_chip[0], timeout_eff[0],\n\t\t\t timeout_chip[1], timeout_eff[1],\n\t\t\t timeout_chip[2], timeout_eff[2],\n\t\t\t timeout_chip[3], timeout_eff[3]);\n\t}\n\n\tchip->timeout_a = usecs_to_jiffies(timeout_eff[0]);\n\tchip->timeout_b = usecs_to_jiffies(timeout_eff[1]);\n\tchip->timeout_c = usecs_to_jiffies(timeout_eff[2]);\n\tchip->timeout_d = usecs_to_jiffies(timeout_eff[3]);\n\n\trc = tpm1_getcap(chip, TPM_CAP_PROP_TIS_DURATION, &cap,\n\t\t\t \"attempting to determine the durations\",\n\t\t\t  sizeof(cap.duration));\n\tif (rc)\n\t\treturn rc;\n\n\tchip->duration[TPM_SHORT] =\n\t\tusecs_to_jiffies(be32_to_cpu(cap.duration.tpm_short));\n\tchip->duration[TPM_MEDIUM] =\n\t\tusecs_to_jiffies(be32_to_cpu(cap.duration.tpm_medium));\n\tchip->duration[TPM_LONG] =\n\t\tusecs_to_jiffies(be32_to_cpu(cap.duration.tpm_long));\n\tchip->duration[TPM_LONG_LONG] = 0;  \n\n\t \n\tif (chip->ops->update_durations)\n\t\tchip->ops->update_durations(chip, durations);\n\n\tif (chip->duration_adjusted) {\n\t\tdev_info(&chip->dev, HW_ERR \"Adjusting reported durations.\");\n\t\tchip->duration[TPM_SHORT] = durations[0];\n\t\tchip->duration[TPM_MEDIUM] = durations[1];\n\t\tchip->duration[TPM_LONG] = durations[2];\n\t}\n\n\t \n\tif (chip->duration[TPM_SHORT] < (HZ / 100)) {\n\t\tchip->duration[TPM_SHORT] = HZ;\n\t\tchip->duration[TPM_MEDIUM] *= 1000;\n\t\tchip->duration[TPM_LONG] *= 1000;\n\t\tchip->duration_adjusted = true;\n\t\tdev_info(&chip->dev, \"Adjusting TPM timeout parameters.\");\n\t}\n\n\tchip->flags |= TPM_CHIP_FLAG_HAVE_TIMEOUTS;\n\treturn 0;\n}\n\n#define TPM_ORD_PCR_EXTEND 20\nint tpm1_pcr_extend(struct tpm_chip *chip, u32 pcr_idx, const u8 *hash,\n\t\t    const char *log_msg)\n{\n\tstruct tpm_buf buf;\n\tint rc;\n\n\trc = tpm_buf_init(&buf, TPM_TAG_RQU_COMMAND, TPM_ORD_PCR_EXTEND);\n\tif (rc)\n\t\treturn rc;\n\n\ttpm_buf_append_u32(&buf, pcr_idx);\n\ttpm_buf_append(&buf, hash, TPM_DIGEST_SIZE);\n\n\trc = tpm_transmit_cmd(chip, &buf, TPM_DIGEST_SIZE, log_msg);\n\ttpm_buf_destroy(&buf);\n\treturn rc;\n}\n\n#define TPM_ORD_GET_CAP 101\nssize_t tpm1_getcap(struct tpm_chip *chip, u32 subcap_id, cap_t *cap,\n\t\t    const char *desc, size_t min_cap_length)\n{\n\tstruct tpm_buf buf;\n\tint rc;\n\n\trc = tpm_buf_init(&buf, TPM_TAG_RQU_COMMAND, TPM_ORD_GET_CAP);\n\tif (rc)\n\t\treturn rc;\n\n\tif (subcap_id == TPM_CAP_VERSION_1_1 ||\n\t    subcap_id == TPM_CAP_VERSION_1_2) {\n\t\ttpm_buf_append_u32(&buf, subcap_id);\n\t\ttpm_buf_append_u32(&buf, 0);\n\t} else {\n\t\tif (subcap_id == TPM_CAP_FLAG_PERM ||\n\t\t    subcap_id == TPM_CAP_FLAG_VOL)\n\t\t\ttpm_buf_append_u32(&buf, TPM_CAP_FLAG);\n\t\telse\n\t\t\ttpm_buf_append_u32(&buf, TPM_CAP_PROP);\n\n\t\ttpm_buf_append_u32(&buf, 4);\n\t\ttpm_buf_append_u32(&buf, subcap_id);\n\t}\n\trc = tpm_transmit_cmd(chip, &buf, min_cap_length, desc);\n\tif (!rc)\n\t\t*cap = *(cap_t *)&buf.data[TPM_HEADER_SIZE + 4];\n\ttpm_buf_destroy(&buf);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(tpm1_getcap);\n\n#define TPM_ORD_GET_RANDOM 70\nstruct tpm1_get_random_out {\n\t__be32 rng_data_len;\n\tu8 rng_data[TPM_MAX_RNG_DATA];\n} __packed;\n\n \nint tpm1_get_random(struct tpm_chip *chip, u8 *dest, size_t max)\n{\n\tstruct tpm1_get_random_out *out;\n\tu32 num_bytes =  min_t(u32, max, TPM_MAX_RNG_DATA);\n\tstruct tpm_buf buf;\n\tu32 total = 0;\n\tint retries = 5;\n\tu32 recd;\n\tint rc;\n\n\trc = tpm_buf_init(&buf, TPM_TAG_RQU_COMMAND, TPM_ORD_GET_RANDOM);\n\tif (rc)\n\t\treturn rc;\n\n\tdo {\n\t\ttpm_buf_append_u32(&buf, num_bytes);\n\n\t\trc = tpm_transmit_cmd(chip, &buf, sizeof(out->rng_data_len),\n\t\t\t\t      \"attempting get random\");\n\t\tif (rc) {\n\t\t\tif (rc > 0)\n\t\t\t\trc = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\tout = (struct tpm1_get_random_out *)&buf.data[TPM_HEADER_SIZE];\n\n\t\trecd = be32_to_cpu(out->rng_data_len);\n\t\tif (recd > num_bytes) {\n\t\t\trc = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (tpm_buf_length(&buf) < TPM_HEADER_SIZE +\n\t\t\t\t\t   sizeof(out->rng_data_len) + recd) {\n\t\t\trc = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(dest, out->rng_data, recd);\n\n\t\tdest += recd;\n\t\ttotal += recd;\n\t\tnum_bytes -= recd;\n\n\t\ttpm_buf_reset(&buf, TPM_TAG_RQU_COMMAND, TPM_ORD_GET_RANDOM);\n\t} while (retries-- && total < max);\n\n\trc = total ? (int)total : -EIO;\nout:\n\ttpm_buf_destroy(&buf);\n\treturn rc;\n}\n\n#define TPM_ORD_PCRREAD 21\nint tpm1_pcr_read(struct tpm_chip *chip, u32 pcr_idx, u8 *res_buf)\n{\n\tstruct tpm_buf buf;\n\tint rc;\n\n\trc = tpm_buf_init(&buf, TPM_TAG_RQU_COMMAND, TPM_ORD_PCRREAD);\n\tif (rc)\n\t\treturn rc;\n\n\ttpm_buf_append_u32(&buf, pcr_idx);\n\n\trc = tpm_transmit_cmd(chip, &buf, TPM_DIGEST_SIZE,\n\t\t\t      \"attempting to read a pcr value\");\n\tif (rc)\n\t\tgoto out;\n\n\tif (tpm_buf_length(&buf) < TPM_DIGEST_SIZE) {\n\t\trc = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tmemcpy(res_buf, &buf.data[TPM_HEADER_SIZE], TPM_DIGEST_SIZE);\n\nout:\n\ttpm_buf_destroy(&buf);\n\treturn rc;\n}\n\n#define TPM_ORD_CONTINUE_SELFTEST 83\n \nstatic int tpm1_continue_selftest(struct tpm_chip *chip)\n{\n\tstruct tpm_buf buf;\n\tint rc;\n\n\trc = tpm_buf_init(&buf, TPM_TAG_RQU_COMMAND, TPM_ORD_CONTINUE_SELFTEST);\n\tif (rc)\n\t\treturn rc;\n\n\trc = tpm_transmit_cmd(chip, &buf, 0, \"continue selftest\");\n\ttpm_buf_destroy(&buf);\n\treturn rc;\n}\n\n \nint tpm1_do_selftest(struct tpm_chip *chip)\n{\n\tint rc;\n\tunsigned int loops;\n\tunsigned int delay_msec = 100;\n\tunsigned long duration;\n\tu8 dummy[TPM_DIGEST_SIZE];\n\n\tduration = tpm1_calc_ordinal_duration(chip, TPM_ORD_CONTINUE_SELFTEST);\n\n\tloops = jiffies_to_msecs(duration) / delay_msec;\n\n\trc = tpm1_continue_selftest(chip);\n\tif (rc == TPM_ERR_INVALID_POSTINIT) {\n\t\tchip->flags |= TPM_CHIP_FLAG_ALWAYS_POWERED;\n\t\tdev_info(&chip->dev, \"TPM not ready (%d)\\n\", rc);\n\t}\n\t \n\tif (rc)\n\t\treturn rc;\n\n\tdo {\n\t\t \n\t\trc = tpm1_pcr_read(chip, 0, dummy);\n\n\t\t \n\t\tif (rc == -ETIME) {\n\t\t\tdev_info(&chip->dev, HW_ERR \"TPM command timed out during continue self test\");\n\t\t\ttpm_msleep(delay_msec);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (rc == TPM_ERR_DISABLED || rc == TPM_ERR_DEACTIVATED) {\n\t\t\tdev_info(&chip->dev, \"TPM is disabled/deactivated (0x%X)\\n\",\n\t\t\t\t rc);\n\t\t\t \n\t\t\treturn 0;\n\t\t}\n\t\tif (rc != TPM_WARN_DOING_SELFTEST)\n\t\t\treturn rc;\n\t\ttpm_msleep(delay_msec);\n\t} while (--loops > 0);\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(tpm1_do_selftest);\n\n \nint tpm1_auto_startup(struct tpm_chip *chip)\n{\n\tint rc;\n\n\trc = tpm1_get_timeouts(chip);\n\tif (rc)\n\t\tgoto out;\n\trc = tpm1_do_selftest(chip);\n\tif (rc == TPM_ERR_FAILEDSELFTEST) {\n\t\tdev_warn(&chip->dev, \"TPM self test failed, switching to the firmware upgrade mode\\n\");\n\t\t \n\t\tchip->flags |= TPM_CHIP_FLAG_FIRMWARE_UPGRADE;\n\t\treturn 0;\n\t} else if (rc) {\n\t\tdev_err(&chip->dev, \"TPM self test failed\\n\");\n\t\tgoto out;\n\t}\n\n\treturn rc;\nout:\n\tif (rc > 0)\n\t\trc = -ENODEV;\n\treturn rc;\n}\n\n#define TPM_ORD_SAVESTATE 152\n\n \nint tpm1_pm_suspend(struct tpm_chip *chip, u32 tpm_suspend_pcr)\n{\n\tu8 dummy_hash[TPM_DIGEST_SIZE] = { 0 };\n\tstruct tpm_buf buf;\n\tunsigned int try;\n\tint rc;\n\n\n\t \n\tif (tpm_suspend_pcr)\n\t\trc = tpm1_pcr_extend(chip, tpm_suspend_pcr, dummy_hash,\n\t\t\t\t     \"extending dummy pcr before suspend\");\n\n\trc = tpm_buf_init(&buf, TPM_TAG_RQU_COMMAND, TPM_ORD_SAVESTATE);\n\tif (rc)\n\t\treturn rc;\n\t \n\tfor (try = 0; try < TPM_RETRY; try++) {\n\t\trc = tpm_transmit_cmd(chip, &buf, 0, NULL);\n\t\t \n\t\tif (rc != TPM_WARN_RETRY)\n\t\t\tbreak;\n\t\ttpm_msleep(TPM_TIMEOUT_RETRY);\n\n\t\ttpm_buf_reset(&buf, TPM_TAG_RQU_COMMAND, TPM_ORD_SAVESTATE);\n\t}\n\n\tif (rc)\n\t\tdev_err(&chip->dev, \"Error (%d) sending savestate before suspend\\n\",\n\t\t\trc);\n\telse if (try > 0)\n\t\tdev_warn(&chip->dev, \"TPM savestate took %dms\\n\",\n\t\t\t try * TPM_TIMEOUT_RETRY);\n\n\ttpm_buf_destroy(&buf);\n\n\treturn rc;\n}\n\n \nint tpm1_get_pcr_allocation(struct tpm_chip *chip)\n{\n\tchip->allocated_banks = kcalloc(1, sizeof(*chip->allocated_banks),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!chip->allocated_banks)\n\t\treturn -ENOMEM;\n\n\tchip->allocated_banks[0].alg_id = TPM_ALG_SHA1;\n\tchip->allocated_banks[0].digest_size = hash_digest_size[HASH_ALGO_SHA1];\n\tchip->allocated_banks[0].crypto_id = HASH_ALGO_SHA1;\n\tchip->nr_allocated_banks = 1;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}