{
  "module_name": "tpm-sysfs.c",
  "hash_id": "bbd0c56ea9422d313043e7834b639b0b491861144ef07f223fa331e7dbf06d52",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/tpm/tpm-sysfs.c",
  "human_readable_source": "\n \n#include <linux/device.h>\n#include \"tpm.h\"\n\nstruct tpm_readpubek_out {\n\tu8 algorithm[4];\n\tu8 encscheme[2];\n\tu8 sigscheme[2];\n\t__be32 paramsize;\n\tu8 parameters[12];\n\t__be32 keysize;\n\tu8 modulus[256];\n\tu8 checksum[20];\n} __packed;\n\n#define READ_PUBEK_RESULT_MIN_BODY_SIZE (28 + 256)\n#define TPM_ORD_READPUBEK 124\n\nstatic ssize_t pubek_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tstruct tpm_buf tpm_buf;\n\tstruct tpm_readpubek_out *out;\n\tint i;\n\tchar *str = buf;\n\tstruct tpm_chip *chip = to_tpm_chip(dev);\n\tchar anti_replay[20];\n\n\tmemset(&anti_replay, 0, sizeof(anti_replay));\n\n\tif (tpm_try_get_ops(chip))\n\t\treturn 0;\n\n\tif (tpm_buf_init(&tpm_buf, TPM_TAG_RQU_COMMAND, TPM_ORD_READPUBEK))\n\t\tgoto out_ops;\n\n\ttpm_buf_append(&tpm_buf, anti_replay, sizeof(anti_replay));\n\n\tif (tpm_transmit_cmd(chip, &tpm_buf, READ_PUBEK_RESULT_MIN_BODY_SIZE,\n\t\t\t     \"attempting to read the PUBEK\"))\n\t\tgoto out_buf;\n\n\tout = (struct tpm_readpubek_out *)&tpm_buf.data[10];\n\tstr +=\n\t    sprintf(str,\n\t\t    \"Algorithm: %4ph\\n\"\n\t\t    \"Encscheme: %2ph\\n\"\n\t\t    \"Sigscheme: %2ph\\n\"\n\t\t    \"Parameters: %12ph\\n\"\n\t\t    \"Modulus length: %d\\n\"\n\t\t    \"Modulus:\\n\",\n\t\t    out->algorithm,\n\t\t    out->encscheme,\n\t\t    out->sigscheme,\n\t\t    out->parameters,\n\t\t    be32_to_cpu(out->keysize));\n\n\tfor (i = 0; i < 256; i += 16)\n\t\tstr += sprintf(str, \"%16ph\\n\", &out->modulus[i]);\n\nout_buf:\n\ttpm_buf_destroy(&tpm_buf);\nout_ops:\n\ttpm_put_ops(chip);\n\treturn str - buf;\n}\nstatic DEVICE_ATTR_RO(pubek);\n\nstatic ssize_t pcrs_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tcap_t cap;\n\tu8 digest[TPM_DIGEST_SIZE];\n\tu32 i, j, num_pcrs;\n\tchar *str = buf;\n\tstruct tpm_chip *chip = to_tpm_chip(dev);\n\n\tif (tpm_try_get_ops(chip))\n\t\treturn 0;\n\n\tif (tpm1_getcap(chip, TPM_CAP_PROP_PCR, &cap,\n\t\t\t\"attempting to determine the number of PCRS\",\n\t\t\tsizeof(cap.num_pcrs))) {\n\t\ttpm_put_ops(chip);\n\t\treturn 0;\n\t}\n\n\tnum_pcrs = be32_to_cpu(cap.num_pcrs);\n\tfor (i = 0; i < num_pcrs; i++) {\n\t\tif (tpm1_pcr_read(chip, i, digest)) {\n\t\t\tstr = buf;\n\t\t\tbreak;\n\t\t}\n\t\tstr += sprintf(str, \"PCR-%02d: \", i);\n\t\tfor (j = 0; j < TPM_DIGEST_SIZE; j++)\n\t\t\tstr += sprintf(str, \"%02X \", digest[j]);\n\t\tstr += sprintf(str, \"\\n\");\n\t}\n\ttpm_put_ops(chip);\n\treturn str - buf;\n}\nstatic DEVICE_ATTR_RO(pcrs);\n\nstatic ssize_t enabled_show(struct device *dev, struct device_attribute *attr,\n\t\t     char *buf)\n{\n\tstruct tpm_chip *chip = to_tpm_chip(dev);\n\tssize_t rc = 0;\n\tcap_t cap;\n\n\tif (tpm_try_get_ops(chip))\n\t\treturn 0;\n\n\tif (tpm1_getcap(chip, TPM_CAP_FLAG_PERM, &cap,\n\t\t\t\"attempting to determine the permanent enabled state\",\n\t\t\tsizeof(cap.perm_flags)))\n\t\tgoto out_ops;\n\n\trc = sprintf(buf, \"%d\\n\", !cap.perm_flags.disable);\nout_ops:\n\ttpm_put_ops(chip);\n\treturn rc;\n}\nstatic DEVICE_ATTR_RO(enabled);\n\nstatic ssize_t active_show(struct device *dev, struct device_attribute *attr,\n\t\t    char *buf)\n{\n\tstruct tpm_chip *chip = to_tpm_chip(dev);\n\tssize_t rc = 0;\n\tcap_t cap;\n\n\tif (tpm_try_get_ops(chip))\n\t\treturn 0;\n\n\tif (tpm1_getcap(chip, TPM_CAP_FLAG_PERM, &cap,\n\t\t\t\"attempting to determine the permanent active state\",\n\t\t\tsizeof(cap.perm_flags)))\n\t\tgoto out_ops;\n\n\trc = sprintf(buf, \"%d\\n\", !cap.perm_flags.deactivated);\nout_ops:\n\ttpm_put_ops(chip);\n\treturn rc;\n}\nstatic DEVICE_ATTR_RO(active);\n\nstatic ssize_t owned_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tstruct tpm_chip *chip = to_tpm_chip(dev);\n\tssize_t rc = 0;\n\tcap_t cap;\n\n\tif (tpm_try_get_ops(chip))\n\t\treturn 0;\n\n\tif (tpm1_getcap(to_tpm_chip(dev), TPM_CAP_PROP_OWNER, &cap,\n\t\t\t\"attempting to determine the owner state\",\n\t\t\tsizeof(cap.owned)))\n\t\tgoto out_ops;\n\n\trc = sprintf(buf, \"%d\\n\", cap.owned);\nout_ops:\n\ttpm_put_ops(chip);\n\treturn rc;\n}\nstatic DEVICE_ATTR_RO(owned);\n\nstatic ssize_t temp_deactivated_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct tpm_chip *chip = to_tpm_chip(dev);\n\tssize_t rc = 0;\n\tcap_t cap;\n\n\tif (tpm_try_get_ops(chip))\n\t\treturn 0;\n\n\tif (tpm1_getcap(to_tpm_chip(dev), TPM_CAP_FLAG_VOL, &cap,\n\t\t\t\"attempting to determine the temporary state\",\n\t\t\tsizeof(cap.stclear_flags)))\n\t\tgoto out_ops;\n\n\trc = sprintf(buf, \"%d\\n\", cap.stclear_flags.deactivated);\nout_ops:\n\ttpm_put_ops(chip);\n\treturn rc;\n}\nstatic DEVICE_ATTR_RO(temp_deactivated);\n\nstatic ssize_t caps_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct tpm_chip *chip = to_tpm_chip(dev);\n\tstruct tpm1_version *version;\n\tssize_t rc = 0;\n\tchar *str = buf;\n\tcap_t cap;\n\n\tif (tpm_try_get_ops(chip))\n\t\treturn 0;\n\n\tif (tpm1_getcap(chip, TPM_CAP_PROP_MANUFACTURER, &cap,\n\t\t\t\"attempting to determine the manufacturer\",\n\t\t\tsizeof(cap.manufacturer_id)))\n\t\tgoto out_ops;\n\n\tstr += sprintf(str, \"Manufacturer: 0x%x\\n\",\n\t\t       be32_to_cpu(cap.manufacturer_id));\n\n\t \n\tif (!tpm1_getcap(chip, TPM_CAP_VERSION_1_2, &cap,\n\t\t\t \"attempting to determine the 1.2 version\",\n\t\t\t sizeof(cap.version2))) {\n\t\tversion = &cap.version2.version;\n\t\tgoto out_print;\n\t}\n\n\t \n\tif (tpm1_getcap(chip, TPM_CAP_VERSION_1_1, &cap,\n\t\t\t\"attempting to determine the 1.1 version\",\n\t\t\tsizeof(cap.version1))) {\n\t\tgoto out_ops;\n\t}\n\n\tversion = &cap.version1;\n\nout_print:\n\tstr += sprintf(str,\n\t\t       \"TCG version: %d.%d\\nFirmware version: %d.%d\\n\",\n\t\t       version->major, version->minor,\n\t\t       version->rev_major, version->rev_minor);\n\n\trc = str - buf;\n\nout_ops:\n\ttpm_put_ops(chip);\n\treturn rc;\n}\nstatic DEVICE_ATTR_RO(caps);\n\nstatic ssize_t cancel_store(struct device *dev, struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tstruct tpm_chip *chip = to_tpm_chip(dev);\n\n\tif (tpm_try_get_ops(chip))\n\t\treturn 0;\n\n\tchip->ops->cancel(chip);\n\ttpm_put_ops(chip);\n\treturn count;\n}\nstatic DEVICE_ATTR_WO(cancel);\n\nstatic ssize_t durations_show(struct device *dev, struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct tpm_chip *chip = to_tpm_chip(dev);\n\n\tif (chip->duration[TPM_LONG] == 0)\n\t\treturn 0;\n\n\treturn sprintf(buf, \"%d %d %d [%s]\\n\",\n\t\t       jiffies_to_usecs(chip->duration[TPM_SHORT]),\n\t\t       jiffies_to_usecs(chip->duration[TPM_MEDIUM]),\n\t\t       jiffies_to_usecs(chip->duration[TPM_LONG]),\n\t\t       chip->duration_adjusted\n\t\t       ? \"adjusted\" : \"original\");\n}\nstatic DEVICE_ATTR_RO(durations);\n\nstatic ssize_t timeouts_show(struct device *dev, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct tpm_chip *chip = to_tpm_chip(dev);\n\n\treturn sprintf(buf, \"%d %d %d %d [%s]\\n\",\n\t\t       jiffies_to_usecs(chip->timeout_a),\n\t\t       jiffies_to_usecs(chip->timeout_b),\n\t\t       jiffies_to_usecs(chip->timeout_c),\n\t\t       jiffies_to_usecs(chip->timeout_d),\n\t\t       chip->timeout_adjusted\n\t\t       ? \"adjusted\" : \"original\");\n}\nstatic DEVICE_ATTR_RO(timeouts);\n\nstatic ssize_t tpm_version_major_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct tpm_chip *chip = to_tpm_chip(dev);\n\n\treturn sprintf(buf, \"%s\\n\", chip->flags & TPM_CHIP_FLAG_TPM2\n\t\t       ? \"2\" : \"1\");\n}\nstatic DEVICE_ATTR_RO(tpm_version_major);\n\nstatic struct attribute *tpm1_dev_attrs[] = {\n\t&dev_attr_pubek.attr,\n\t&dev_attr_pcrs.attr,\n\t&dev_attr_enabled.attr,\n\t&dev_attr_active.attr,\n\t&dev_attr_owned.attr,\n\t&dev_attr_temp_deactivated.attr,\n\t&dev_attr_caps.attr,\n\t&dev_attr_cancel.attr,\n\t&dev_attr_durations.attr,\n\t&dev_attr_timeouts.attr,\n\t&dev_attr_tpm_version_major.attr,\n\tNULL,\n};\n\nstatic struct attribute *tpm2_dev_attrs[] = {\n\t&dev_attr_tpm_version_major.attr,\n\tNULL\n};\n\nstatic const struct attribute_group tpm1_dev_group = {\n\t.attrs = tpm1_dev_attrs,\n};\n\nstatic const struct attribute_group tpm2_dev_group = {\n\t.attrs = tpm2_dev_attrs,\n};\n\nstruct tpm_pcr_attr {\n\tint alg_id;\n\tint pcr;\n\tstruct device_attribute attr;\n};\n\n#define to_tpm_pcr_attr(a) container_of(a, struct tpm_pcr_attr, attr)\n\nstatic ssize_t pcr_value_show(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct tpm_pcr_attr *ha = to_tpm_pcr_attr(attr);\n\tstruct tpm_chip *chip = to_tpm_chip(dev);\n\tstruct tpm_digest digest;\n\tint i;\n\tint digest_size = 0;\n\tint rc;\n\tchar *str = buf;\n\n\tfor (i = 0; i < chip->nr_allocated_banks; i++)\n\t\tif (ha->alg_id == chip->allocated_banks[i].alg_id)\n\t\t\tdigest_size = chip->allocated_banks[i].digest_size;\n\t \n\tif (!digest_size)\n\t\treturn -EINVAL;\n\n\tdigest.alg_id = ha->alg_id;\n\trc = tpm_pcr_read(chip, ha->pcr, &digest);\n\tif (rc)\n\t\treturn rc;\n\tfor (i = 0; i < digest_size; i++)\n\t\tstr += sprintf(str, \"%02X\", digest.digest[i]);\n\tstr += sprintf(str, \"\\n\");\n\n\treturn str - buf;\n}\n\n \n\n \n#define _TPM_HELPER(_alg, _hash, F) \\\n\tF(_alg, _hash, 0)\t    \\\n\tF(_alg, _hash, 1)\t    \\\n\tF(_alg, _hash, 2)\t    \\\n\tF(_alg, _hash, 3)\t    \\\n\tF(_alg, _hash, 4)\t    \\\n\tF(_alg, _hash, 5)\t    \\\n\tF(_alg, _hash, 6)\t    \\\n\tF(_alg, _hash, 7)\t    \\\n\tF(_alg, _hash, 8)\t    \\\n\tF(_alg, _hash, 9)\t    \\\n\tF(_alg, _hash, 10)\t    \\\n\tF(_alg, _hash, 11)\t    \\\n\tF(_alg, _hash, 12)\t    \\\n\tF(_alg, _hash, 13)\t    \\\n\tF(_alg, _hash, 14)\t    \\\n\tF(_alg, _hash, 15)\t    \\\n\tF(_alg, _hash, 16)\t    \\\n\tF(_alg, _hash, 17)\t    \\\n\tF(_alg, _hash, 18)\t    \\\n\tF(_alg, _hash, 19)\t    \\\n\tF(_alg, _hash, 20)\t    \\\n\tF(_alg, _hash, 21)\t    \\\n\tF(_alg, _hash, 22)\t    \\\n\tF(_alg, _hash, 23)\n\n \n#define PCR_ATTR(_alg, _hash, _pcr)\t\t\t\t   \\\n\tstatic struct tpm_pcr_attr dev_attr_pcr_##_hash##_##_pcr = {\t\\\n\t\t.alg_id = _alg,\t\t\t\t\t   \\\n\t\t.pcr = _pcr,\t\t\t\t\t   \\\n\t\t.attr = {\t\t\t\t\t   \\\n\t\t\t.attr = {\t\t\t\t   \\\n\t\t\t\t.name = __stringify(_pcr),\t   \\\n\t\t\t\t.mode = 0444\t\t\t   \\\n\t\t\t},\t\t\t\t\t   \\\n\t\t\t.show = pcr_value_show\t\t\t   \\\n\t\t}\t\t\t\t\t\t   \\\n\t};\n\n#define PCR_ATTRS(_alg, _hash)\t\t\t\\\n\t_TPM_HELPER(_alg, _hash, PCR_ATTR)\n\n \n#define PCR_ATTR_VAL(_alg, _hash, _pcr)\t\t\\\n\t&dev_attr_pcr_##_hash##_##_pcr.attr.attr,\n\n#define PCR_ATTR_GROUP_ARRAY(_alg, _hash)\t\t       \\\n\tstatic struct attribute *pcr_group_attrs_##_hash[] = { \\\n\t\t_TPM_HELPER(_alg, _hash, PCR_ATTR_VAL)\t       \\\n\t\tNULL\t\t\t\t\t       \\\n\t}\n\n#define PCR_ATTR_GROUP(_alg, _hash)\t\t\t    \\\n\tstatic struct attribute_group pcr_group_##_hash = { \\\n\t\t.name = \"pcr-\" __stringify(_hash),\t    \\\n\t\t.attrs = pcr_group_attrs_##_hash\t    \\\n\t}\n\n#define PCR_ATTR_BUILD(_alg, _hash)\t   \\\n\tPCR_ATTRS(_alg, _hash)\t\t   \\\n\tPCR_ATTR_GROUP_ARRAY(_alg, _hash); \\\n\tPCR_ATTR_GROUP(_alg, _hash)\n \n\n \nPCR_ATTR_BUILD(TPM_ALG_SHA1, sha1);\nPCR_ATTR_BUILD(TPM_ALG_SHA256, sha256);\nPCR_ATTR_BUILD(TPM_ALG_SHA384, sha384);\nPCR_ATTR_BUILD(TPM_ALG_SHA512, sha512);\nPCR_ATTR_BUILD(TPM_ALG_SM3_256, sm3);\n\n\nvoid tpm_sysfs_add_device(struct tpm_chip *chip)\n{\n\tint i;\n\n\tWARN_ON(chip->groups_cnt != 0);\n\n\tif (tpm_is_firmware_upgrade(chip))\n\t\treturn;\n\n\tif (chip->flags & TPM_CHIP_FLAG_TPM2)\n\t\tchip->groups[chip->groups_cnt++] = &tpm2_dev_group;\n\telse\n\t\tchip->groups[chip->groups_cnt++] = &tpm1_dev_group;\n\n\t \n\tfor (i = 0; i < chip->nr_allocated_banks; i++) {\n\t\tswitch (chip->allocated_banks[i].alg_id) {\n\t\tcase TPM_ALG_SHA1:\n\t\t\tchip->groups[chip->groups_cnt++] = &pcr_group_sha1;\n\t\t\tbreak;\n\t\tcase TPM_ALG_SHA256:\n\t\t\tchip->groups[chip->groups_cnt++] = &pcr_group_sha256;\n\t\t\tbreak;\n\t\tcase TPM_ALG_SHA384:\n\t\t\tchip->groups[chip->groups_cnt++] = &pcr_group_sha384;\n\t\t\tbreak;\n\t\tcase TPM_ALG_SHA512:\n\t\t\tchip->groups[chip->groups_cnt++] = &pcr_group_sha512;\n\t\t\tbreak;\n\t\tcase TPM_ALG_SM3_256:\n\t\t\tchip->groups[chip->groups_cnt++] = &pcr_group_sm3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tdev_err(&chip->dev,\n\t\t\t\t\"TPM with unsupported bank algorithm 0x%04x\",\n\t\t\t\tchip->allocated_banks[i].alg_id);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tWARN_ON(chip->groups_cnt > TPM_MAX_HASHES + 1);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}