{
  "module_name": "tpm_atmel.c",
  "hash_id": "b0351fd81af0861c9d7709e74fd3a4fb7705c52f0d697046ae0f11fd8a2d157e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/tpm/tpm_atmel.c",
  "human_readable_source": "\n \n\n#include \"tpm.h\"\n#include \"tpm_atmel.h\"\n\n \nenum tpm_atmel_write_status {\n\tATML_STATUS_ABORT = 0x01,\n\tATML_STATUS_LASTBYTE = 0x04\n};\n \nenum tpm_atmel_read_status {\n\tATML_STATUS_BUSY = 0x01,\n\tATML_STATUS_DATA_AVAIL = 0x02,\n\tATML_STATUS_REWRITE = 0x04,\n\tATML_STATUS_READY = 0x08\n};\n\nstatic int tpm_atml_recv(struct tpm_chip *chip, u8 *buf, size_t count)\n{\n\tstruct tpm_atmel_priv *priv = dev_get_drvdata(&chip->dev);\n\tu8 status, *hdr = buf;\n\tu32 size;\n\tint i;\n\t__be32 *native_size;\n\n\t \n\tif (count < 6)\n\t\treturn -EIO;\n\n\tfor (i = 0; i < 6; i++) {\n\t\tstatus = ioread8(priv->iobase + 1);\n\t\tif ((status & ATML_STATUS_DATA_AVAIL) == 0) {\n\t\t\tdev_err(&chip->dev, \"error reading header\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\t*buf++ = ioread8(priv->iobase);\n\t}\n\n\t \n\tnative_size = (__force __be32 *) (hdr + 2);\n\tsize = be32_to_cpu(*native_size);\n\n\tif (count < size) {\n\t\tdev_err(&chip->dev,\n\t\t\t\"Recv size(%d) less than available space\\n\", size);\n\t\tfor (; i < size; i++) {\t \n\t\t\tstatus = ioread8(priv->iobase + 1);\n\t\t\tif ((status & ATML_STATUS_DATA_AVAIL) == 0) {\n\t\t\t\tdev_err(&chip->dev, \"error reading data\\n\");\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\t\treturn -EIO;\n\t}\n\n\t \n\tfor (; i < size; i++) {\n\t\tstatus = ioread8(priv->iobase + 1);\n\t\tif ((status & ATML_STATUS_DATA_AVAIL) == 0) {\n\t\t\tdev_err(&chip->dev, \"error reading data\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\t*buf++ = ioread8(priv->iobase);\n\t}\n\n\t \n\tstatus = ioread8(priv->iobase + 1);\n\n\tif (status & ATML_STATUS_DATA_AVAIL) {\n\t\tdev_err(&chip->dev, \"data available is stuck\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn size;\n}\n\nstatic int tpm_atml_send(struct tpm_chip *chip, u8 *buf, size_t count)\n{\n\tstruct tpm_atmel_priv *priv = dev_get_drvdata(&chip->dev);\n\tint i;\n\n\tdev_dbg(&chip->dev, \"tpm_atml_send:\\n\");\n\tfor (i = 0; i < count; i++) {\n\t\tdev_dbg(&chip->dev, \"%d 0x%x(%d)\\n\",  i, buf[i], buf[i]);\n\t\tiowrite8(buf[i], priv->iobase);\n\t}\n\n\treturn 0;\n}\n\nstatic void tpm_atml_cancel(struct tpm_chip *chip)\n{\n\tstruct tpm_atmel_priv *priv = dev_get_drvdata(&chip->dev);\n\n\tiowrite8(ATML_STATUS_ABORT, priv->iobase + 1);\n}\n\nstatic u8 tpm_atml_status(struct tpm_chip *chip)\n{\n\tstruct tpm_atmel_priv *priv = dev_get_drvdata(&chip->dev);\n\n\treturn ioread8(priv->iobase + 1);\n}\n\nstatic bool tpm_atml_req_canceled(struct tpm_chip *chip, u8 status)\n{\n\treturn (status == ATML_STATUS_READY);\n}\n\nstatic const struct tpm_class_ops tpm_atmel = {\n\t.recv = tpm_atml_recv,\n\t.send = tpm_atml_send,\n\t.cancel = tpm_atml_cancel,\n\t.status = tpm_atml_status,\n\t.req_complete_mask = ATML_STATUS_BUSY | ATML_STATUS_DATA_AVAIL,\n\t.req_complete_val = ATML_STATUS_DATA_AVAIL,\n\t.req_canceled = tpm_atml_req_canceled,\n};\n\nstatic struct platform_device *pdev;\n\nstatic void atml_plat_remove(void)\n{\n\tstruct tpm_chip *chip = dev_get_drvdata(&pdev->dev);\n\tstruct tpm_atmel_priv *priv = dev_get_drvdata(&chip->dev);\n\n\ttpm_chip_unregister(chip);\n\tif (priv->have_region)\n\t\tatmel_release_region(priv->base, priv->region_size);\n\tatmel_put_base_addr(priv->iobase);\n\tplatform_device_unregister(pdev);\n}\n\nstatic SIMPLE_DEV_PM_OPS(tpm_atml_pm, tpm_pm_suspend, tpm_pm_resume);\n\nstatic struct platform_driver atml_drv = {\n\t.driver = {\n\t\t.name = \"tpm_atmel\",\n\t\t.pm\t\t= &tpm_atml_pm,\n\t},\n};\n\nstatic int __init init_atmel(void)\n{\n\tint rc = 0;\n\tvoid __iomem *iobase = NULL;\n\tint have_region, region_size;\n\tunsigned long base;\n\tstruct  tpm_chip *chip;\n\tstruct tpm_atmel_priv *priv;\n\n\trc = platform_driver_register(&atml_drv);\n\tif (rc)\n\t\treturn rc;\n\n\tif ((iobase = atmel_get_base_addr(&base, &region_size)) == NULL) {\n\t\trc = -ENODEV;\n\t\tgoto err_unreg_drv;\n\t}\n\n\thave_region =\n\t    (atmel_request_region\n\t     (base, region_size, \"tpm_atmel0\") == NULL) ? 0 : 1;\n\n\tpdev = platform_device_register_simple(\"tpm_atmel\", -1, NULL, 0);\n\tif (IS_ERR(pdev)) {\n\t\trc = PTR_ERR(pdev);\n\t\tgoto err_rel_reg;\n\t}\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv) {\n\t\trc = -ENOMEM;\n\t\tgoto err_unreg_dev;\n\t}\n\n\tpriv->iobase = iobase;\n\tpriv->base = base;\n\tpriv->have_region = have_region;\n\tpriv->region_size = region_size;\n\n\tchip = tpmm_chip_alloc(&pdev->dev, &tpm_atmel);\n\tif (IS_ERR(chip)) {\n\t\trc = PTR_ERR(chip);\n\t\tgoto err_unreg_dev;\n\t}\n\n\tdev_set_drvdata(&chip->dev, priv);\n\n\trc = tpm_chip_register(chip);\n\tif (rc)\n\t\tgoto err_unreg_dev;\n\n\treturn 0;\n\nerr_unreg_dev:\n\tplatform_device_unregister(pdev);\nerr_rel_reg:\n\tatmel_put_base_addr(iobase);\n\tif (have_region)\n\t\tatmel_release_region(base,\n\t\t\t\t     region_size);\nerr_unreg_drv:\n\tplatform_driver_unregister(&atml_drv);\n\treturn rc;\n}\n\nstatic void __exit cleanup_atmel(void)\n{\n\tplatform_driver_unregister(&atml_drv);\n\tatml_plat_remove();\n}\n\nmodule_init(init_atmel);\nmodule_exit(cleanup_atmel);\n\nMODULE_AUTHOR(\"Leendert van Doorn (leendert@watson.ibm.com)\");\nMODULE_DESCRIPTION(\"TPM Driver\");\nMODULE_VERSION(\"2.0\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}