{
  "module_name": "tpm_ftpm_tee.c",
  "hash_id": "2804efc0836a0d005bbb482796a5ab7e39bfdc73e05d138864c11d0d396e0430",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/tpm/tpm_ftpm_tee.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/tee_drv.h>\n#include <linux/tpm.h>\n#include <linux/uuid.h>\n\n#include \"tpm.h\"\n#include \"tpm_ftpm_tee.h\"\n\n \nstatic const uuid_t ftpm_ta_uuid =\n\tUUID_INIT(0xBC50D971, 0xD4C9, 0x42C4,\n\t\t  0x82, 0xCB, 0x34, 0x3F, 0xB7, 0xF3, 0x78, 0x96);\n\n \nstatic int ftpm_tee_tpm_op_recv(struct tpm_chip *chip, u8 *buf, size_t count)\n{\n\tstruct ftpm_tee_private *pvt_data = dev_get_drvdata(chip->dev.parent);\n\tsize_t len;\n\n\tlen = pvt_data->resp_len;\n\tif (count < len) {\n\t\tdev_err(&chip->dev,\n\t\t\t\"%s: Invalid size in recv: count=%zd, resp_len=%zd\\n\",\n\t\t\t__func__, count, len);\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(buf, pvt_data->resp_buf, len);\n\tpvt_data->resp_len = 0;\n\n\treturn len;\n}\n\n \nstatic int ftpm_tee_tpm_op_send(struct tpm_chip *chip, u8 *buf, size_t len)\n{\n\tstruct ftpm_tee_private *pvt_data = dev_get_drvdata(chip->dev.parent);\n\tsize_t resp_len;\n\tint rc;\n\tu8 *temp_buf;\n\tstruct tpm_header *resp_header;\n\tstruct tee_ioctl_invoke_arg transceive_args;\n\tstruct tee_param command_params[4];\n\tstruct tee_shm *shm = pvt_data->shm;\n\n\tif (len > MAX_COMMAND_SIZE) {\n\t\tdev_err(&chip->dev,\n\t\t\t\"%s: len=%zd exceeds MAX_COMMAND_SIZE supported by fTPM TA\\n\",\n\t\t\t__func__, len);\n\t\treturn -EIO;\n\t}\n\n\tmemset(&transceive_args, 0, sizeof(transceive_args));\n\tmemset(command_params, 0, sizeof(command_params));\n\tpvt_data->resp_len = 0;\n\n\t \n\ttransceive_args = (struct tee_ioctl_invoke_arg) {\n\t\t.func = FTPM_OPTEE_TA_SUBMIT_COMMAND,\n\t\t.session = pvt_data->session,\n\t\t.num_params = 4,\n\t};\n\n\t \n\tcommand_params[0] = (struct tee_param) {\n\t\t.attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT,\n\t\t.u.memref = {\n\t\t\t.shm = shm,\n\t\t\t.size = len,\n\t\t\t.shm_offs = 0,\n\t\t},\n\t};\n\n\ttemp_buf = tee_shm_get_va(shm, 0);\n\tif (IS_ERR(temp_buf)) {\n\t\tdev_err(&chip->dev, \"%s: tee_shm_get_va failed for transmit\\n\",\n\t\t\t__func__);\n\t\treturn PTR_ERR(temp_buf);\n\t}\n\tmemset(temp_buf, 0, (MAX_COMMAND_SIZE + MAX_RESPONSE_SIZE));\n\tmemcpy(temp_buf, buf, len);\n\n\tcommand_params[1] = (struct tee_param) {\n\t\t.attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INOUT,\n\t\t.u.memref = {\n\t\t\t.shm = shm,\n\t\t\t.size = MAX_RESPONSE_SIZE,\n\t\t\t.shm_offs = MAX_COMMAND_SIZE,\n\t\t},\n\t};\n\n\trc = tee_client_invoke_func(pvt_data->ctx, &transceive_args,\n\t\t\t\t    command_params);\n\tif ((rc < 0) || (transceive_args.ret != 0)) {\n\t\tdev_err(&chip->dev, \"%s: SUBMIT_COMMAND invoke error: 0x%x\\n\",\n\t\t\t__func__, transceive_args.ret);\n\t\treturn (rc < 0) ? rc : transceive_args.ret;\n\t}\n\n\ttemp_buf = tee_shm_get_va(shm, command_params[1].u.memref.shm_offs);\n\tif (IS_ERR(temp_buf)) {\n\t\tdev_err(&chip->dev, \"%s: tee_shm_get_va failed for receive\\n\",\n\t\t\t__func__);\n\t\treturn PTR_ERR(temp_buf);\n\t}\n\n\tresp_header = (struct tpm_header *)temp_buf;\n\tresp_len = be32_to_cpu(resp_header->length);\n\n\t \n\tif (resp_len < TPM_HEADER_SIZE) {\n\t\tdev_err(&chip->dev, \"%s: tpm response header too small\\n\",\n\t\t\t__func__);\n\t\treturn -EIO;\n\t}\n\tif (resp_len > MAX_RESPONSE_SIZE) {\n\t\tdev_err(&chip->dev,\n\t\t\t\"%s: resp_len=%zd exceeds MAX_RESPONSE_SIZE\\n\",\n\t\t\t__func__, resp_len);\n\t\treturn -EIO;\n\t}\n\n\t \n\tmemcpy(pvt_data->resp_buf, temp_buf, resp_len);\n\tpvt_data->resp_len = resp_len;\n\n\treturn 0;\n}\n\nstatic void ftpm_tee_tpm_op_cancel(struct tpm_chip *chip)\n{\n\t \n}\n\nstatic u8 ftpm_tee_tpm_op_status(struct tpm_chip *chip)\n{\n\treturn 0;\n}\n\nstatic bool ftpm_tee_tpm_req_canceled(struct tpm_chip *chip, u8 status)\n{\n\treturn false;\n}\n\nstatic const struct tpm_class_ops ftpm_tee_tpm_ops = {\n\t.flags = TPM_OPS_AUTO_STARTUP,\n\t.recv = ftpm_tee_tpm_op_recv,\n\t.send = ftpm_tee_tpm_op_send,\n\t.cancel = ftpm_tee_tpm_op_cancel,\n\t.status = ftpm_tee_tpm_op_status,\n\t.req_complete_mask = 0,\n\t.req_complete_val = 0,\n\t.req_canceled = ftpm_tee_tpm_req_canceled,\n};\n\n \nstatic int ftpm_tee_match(struct tee_ioctl_version_data *ver, const void *data)\n{\n\t \n\tif ((ver->impl_id == TEE_IMPL_ID_OPTEE) &&\n\t\t(ver->gen_caps & TEE_GEN_CAP_GP))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\n \nstatic int ftpm_tee_probe(struct device *dev)\n{\n\tint rc;\n\tstruct tpm_chip *chip;\n\tstruct ftpm_tee_private *pvt_data = NULL;\n\tstruct tee_ioctl_open_session_arg sess_arg;\n\n\tpvt_data = devm_kzalloc(dev, sizeof(struct ftpm_tee_private),\n\t\t\t\tGFP_KERNEL);\n\tif (!pvt_data)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, pvt_data);\n\n\t \n\tpvt_data->ctx = tee_client_open_context(NULL, ftpm_tee_match, NULL,\n\t\t\t\t\t\tNULL);\n\tif (IS_ERR(pvt_data->ctx)) {\n\t\tif (PTR_ERR(pvt_data->ctx) == -ENOENT)\n\t\t\treturn -EPROBE_DEFER;\n\t\tdev_err(dev, \"%s: tee_client_open_context failed\\n\", __func__);\n\t\treturn PTR_ERR(pvt_data->ctx);\n\t}\n\n\t \n\tmemset(&sess_arg, 0, sizeof(sess_arg));\n\texport_uuid(sess_arg.uuid, &ftpm_ta_uuid);\n\tsess_arg.clnt_login = TEE_IOCTL_LOGIN_PUBLIC;\n\tsess_arg.num_params = 0;\n\n\trc = tee_client_open_session(pvt_data->ctx, &sess_arg, NULL);\n\tif ((rc < 0) || (sess_arg.ret != 0)) {\n\t\tdev_err(dev, \"%s: tee_client_open_session failed, err=%x\\n\",\n\t\t\t__func__, sess_arg.ret);\n\t\trc = -EINVAL;\n\t\tgoto out_tee_session;\n\t}\n\tpvt_data->session = sess_arg.session;\n\n\t \n\tpvt_data->shm = tee_shm_alloc_kernel_buf(pvt_data->ctx,\n\t\t\t\t\t\t MAX_COMMAND_SIZE +\n\t\t\t\t\t\t MAX_RESPONSE_SIZE);\n\tif (IS_ERR(pvt_data->shm)) {\n\t\tdev_err(dev, \"%s: tee_shm_alloc_kernel_buf failed\\n\", __func__);\n\t\trc = -ENOMEM;\n\t\tgoto out_shm_alloc;\n\t}\n\n\t \n\tchip = tpm_chip_alloc(dev, &ftpm_tee_tpm_ops);\n\tif (IS_ERR(chip)) {\n\t\tdev_err(dev, \"%s: tpm_chip_alloc failed\\n\", __func__);\n\t\trc = PTR_ERR(chip);\n\t\tgoto out_chip_alloc;\n\t}\n\n\tpvt_data->chip = chip;\n\tpvt_data->chip->flags |= TPM_CHIP_FLAG_TPM2;\n\n\t \n\trc = tpm_chip_register(pvt_data->chip);\n\tif (rc) {\n\t\tdev_err(dev, \"%s: tpm_chip_register failed with rc=%d\\n\",\n\t\t\t__func__, rc);\n\t\tgoto out_chip;\n\t}\n\n\treturn 0;\n\nout_chip:\n\tput_device(&pvt_data->chip->dev);\nout_chip_alloc:\n\ttee_shm_free(pvt_data->shm);\nout_shm_alloc:\n\ttee_client_close_session(pvt_data->ctx, pvt_data->session);\nout_tee_session:\n\ttee_client_close_context(pvt_data->ctx);\n\n\treturn rc;\n}\n\nstatic int ftpm_plat_tee_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\n\treturn ftpm_tee_probe(dev);\n}\n\n \nstatic int ftpm_tee_remove(struct device *dev)\n{\n\tstruct ftpm_tee_private *pvt_data = dev_get_drvdata(dev);\n\n\t \n\ttpm_chip_unregister(pvt_data->chip);\n\n\t \n\tput_device(&pvt_data->chip->dev);\n\n\t \n\ttee_shm_free(pvt_data->shm);\n\n\t \n\ttee_client_close_session(pvt_data->ctx, pvt_data->session);\n\n\t \n\ttee_client_close_context(pvt_data->ctx);\n\n\t \n\n\treturn 0;\n}\n\nstatic void ftpm_plat_tee_remove(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\n\tftpm_tee_remove(dev);\n}\n\n \nstatic void ftpm_plat_tee_shutdown(struct platform_device *pdev)\n{\n\tstruct ftpm_tee_private *pvt_data = dev_get_drvdata(&pdev->dev);\n\n\ttee_shm_free(pvt_data->shm);\n\ttee_client_close_session(pvt_data->ctx, pvt_data->session);\n\ttee_client_close_context(pvt_data->ctx);\n}\n\nstatic const struct of_device_id of_ftpm_tee_ids[] = {\n\t{ .compatible = \"microsoft,ftpm\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, of_ftpm_tee_ids);\n\nstatic struct platform_driver ftpm_tee_plat_driver = {\n\t.driver = {\n\t\t.name = \"ftpm-tee\",\n\t\t.of_match_table = of_match_ptr(of_ftpm_tee_ids),\n\t},\n\t.shutdown = ftpm_plat_tee_shutdown,\n\t.probe = ftpm_plat_tee_probe,\n\t.remove_new = ftpm_plat_tee_remove,\n};\n\n \nstatic const struct tee_client_device_id optee_ftpm_id_table[] = {\n\t{UUID_INIT(0xbc50d971, 0xd4c9, 0x42c4,\n\t\t   0x82, 0xcb, 0x34, 0x3f, 0xb7, 0xf3, 0x78, 0x96)},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(tee, optee_ftpm_id_table);\n\nstatic struct tee_client_driver ftpm_tee_driver = {\n\t.id_table\t= optee_ftpm_id_table,\n\t.driver\t\t= {\n\t\t.name\t\t= \"optee-ftpm\",\n\t\t.bus\t\t= &tee_bus_type,\n\t\t.probe\t\t= ftpm_tee_probe,\n\t\t.remove\t\t= ftpm_tee_remove,\n\t},\n};\n\nstatic int __init ftpm_mod_init(void)\n{\n\tint rc;\n\n\trc = platform_driver_register(&ftpm_tee_plat_driver);\n\tif (rc)\n\t\treturn rc;\n\n\trc = driver_register(&ftpm_tee_driver.driver);\n\tif (rc) {\n\t\tplatform_driver_unregister(&ftpm_tee_plat_driver);\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit ftpm_mod_exit(void)\n{\n\tplatform_driver_unregister(&ftpm_tee_plat_driver);\n\tdriver_unregister(&ftpm_tee_driver.driver);\n}\n\nmodule_init(ftpm_mod_init);\nmodule_exit(ftpm_mod_exit);\n\nMODULE_AUTHOR(\"Thirupathaiah Annapureddy <thiruan@microsoft.com>\");\nMODULE_DESCRIPTION(\"TPM Driver for fTPM TA in TEE\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}