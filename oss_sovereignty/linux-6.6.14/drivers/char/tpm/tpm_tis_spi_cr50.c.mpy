{
  "module_name": "tpm_tis_spi_cr50.c",
  "hash_id": "54e3768fa8a6ff25e5fa1359a2991ca07870f455dba0410527f66aefaa93b350",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/tpm/tpm_tis_spi_cr50.c",
  "human_readable_source": "\n \n\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/pm.h>\n#include <linux/spi/spi.h>\n#include <linux/wait.h>\n\n#include \"tpm_tis_core.h\"\n#include \"tpm_tis_spi.h\"\n\n \n#define CR50_SLEEP_DELAY_MSEC\t\t\t1000\n#define CR50_WAKE_START_DELAY_USEC\t\t1000\n#define CR50_NOIRQ_ACCESS_DELAY\t\t\tmsecs_to_jiffies(2)\n#define CR50_READY_IRQ_TIMEOUT\t\t\tmsecs_to_jiffies(TPM2_TIMEOUT_A)\n#define CR50_FLOW_CONTROL\t\t\tmsecs_to_jiffies(TPM2_TIMEOUT_A)\n#define MAX_IRQ_CONFIRMATION_ATTEMPTS\t\t3\n\n#define TPM_CR50_FW_VER(l)\t\t\t(0x0f90 | ((l) << 12))\n#define TPM_CR50_MAX_FW_VER_LEN\t\t\t64\n\n \n#define TPM_CR50_DEFAULT_RNG_QUALITY\t\t700\n\nstruct cr50_spi_phy {\n\tstruct tpm_tis_spi_phy spi_phy;\n\n\tstruct mutex time_track_mutex;\n\tunsigned long last_access;\n\n\tunsigned long access_delay;\n\n\tunsigned int irq_confirmation_attempt;\n\tbool irq_needs_confirmation;\n\tbool irq_confirmed;\n};\n\nstatic inline struct cr50_spi_phy *to_cr50_spi_phy(struct tpm_tis_spi_phy *phy)\n{\n\treturn container_of(phy, struct cr50_spi_phy, spi_phy);\n}\n\n \nstatic irqreturn_t cr50_spi_irq_handler(int dummy, void *dev_id)\n{\n\tstruct cr50_spi_phy *cr50_phy = dev_id;\n\n\tcr50_phy->irq_confirmed = true;\n\tcomplete(&cr50_phy->spi_phy.ready);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void cr50_ensure_access_delay(struct cr50_spi_phy *phy)\n{\n\tunsigned long allowed_access = phy->last_access + phy->access_delay;\n\tunsigned long time_now = jiffies;\n\tstruct device *dev = &phy->spi_phy.spi_device->dev;\n\n\t \n\tif (time_in_range_open(time_now, phy->last_access, allowed_access)) {\n\t\tunsigned long remaining, timeout = allowed_access - time_now;\n\n\t\tremaining = wait_for_completion_timeout(&phy->spi_phy.ready,\n\t\t\t\t\t\t\ttimeout);\n\t\tif (!remaining && phy->irq_confirmed)\n\t\t\tdev_warn(dev, \"Timeout waiting for TPM ready IRQ\\n\");\n\t}\n\n\tif (phy->irq_needs_confirmation) {\n\t\tunsigned int attempt = ++phy->irq_confirmation_attempt;\n\n\t\tif (phy->irq_confirmed) {\n\t\t\tphy->irq_needs_confirmation = false;\n\t\t\tphy->access_delay = CR50_READY_IRQ_TIMEOUT;\n\t\t\tdev_info(dev, \"TPM ready IRQ confirmed on attempt %u\\n\",\n\t\t\t\t attempt);\n\t\t} else if (attempt > MAX_IRQ_CONFIRMATION_ATTEMPTS) {\n\t\t\tphy->irq_needs_confirmation = false;\n\t\t\tdev_warn(dev, \"IRQ not confirmed - will use delays\\n\");\n\t\t}\n\t}\n}\n\n \nstatic bool cr50_needs_waking(struct cr50_spi_phy *phy)\n{\n\t \n\treturn !time_in_range_open(jiffies, phy->last_access,\n\t\t\t\t   phy->spi_phy.wake_after);\n}\n\nstatic void cr50_wake_if_needed(struct cr50_spi_phy *cr50_phy)\n{\n\tstruct tpm_tis_spi_phy *phy = &cr50_phy->spi_phy;\n\n\tif (cr50_needs_waking(cr50_phy)) {\n\t\t \n\t\tstruct spi_transfer spi_cs_wake = {\n\t\t\t.delay = {\n\t\t\t\t.value = 1000,\n\t\t\t\t.unit = SPI_DELAY_UNIT_USECS\n\t\t\t}\n\t\t};\n\n\t\tspi_sync_transfer(phy->spi_device, &spi_cs_wake, 1);\n\t\t \n\t\tusleep_range(CR50_WAKE_START_DELAY_USEC,\n\t\t\t     CR50_WAKE_START_DELAY_USEC * 2);\n\t}\n\n\t \n\tphy->wake_after = jiffies + msecs_to_jiffies(CR50_SLEEP_DELAY_MSEC);\n}\n\n \nstatic int cr50_spi_flow_control(struct tpm_tis_spi_phy *phy,\n\t\t\t\t struct spi_transfer *spi_xfer)\n{\n\tstruct device *dev = &phy->spi_device->dev;\n\tunsigned long timeout = jiffies + CR50_FLOW_CONTROL;\n\tstruct spi_message m;\n\tint ret;\n\n\tspi_xfer->len = 1;\n\n\tdo {\n\t\tspi_message_init(&m);\n\t\tspi_message_add_tail(spi_xfer, &m);\n\t\tret = spi_sync_locked(phy->spi_device, &m);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\tdev_warn(dev, \"Timeout during flow control\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t} while (!(phy->iobuf[0] & 0x01));\n\n\treturn 0;\n}\n\nstatic bool tpm_cr50_spi_is_firmware_power_managed(struct device *dev)\n{\n\tu8 val;\n\tint ret;\n\n\t \n\tret = device_property_read_u8(dev, \"firmware-power-managed\", &val);\n\tif (ret)\n\t\treturn true;\n\n\treturn val;\n}\n\nstatic int tpm_tis_spi_cr50_transfer(struct tpm_tis_data *data, u32 addr, u16 len,\n\t\t\t\t     u8 *in, const u8 *out)\n{\n\tstruct tpm_tis_spi_phy *phy = to_tpm_tis_spi_phy(data);\n\tstruct cr50_spi_phy *cr50_phy = to_cr50_spi_phy(phy);\n\tint ret;\n\n\tmutex_lock(&cr50_phy->time_track_mutex);\n\t \n\tcr50_ensure_access_delay(cr50_phy);\n\tcr50_wake_if_needed(cr50_phy);\n\n\tret = tpm_tis_spi_transfer(data, addr, len, in, out);\n\n\tcr50_phy->last_access = jiffies;\n\tmutex_unlock(&cr50_phy->time_track_mutex);\n\n\treturn ret;\n}\n\nstatic int tpm_tis_spi_cr50_read_bytes(struct tpm_tis_data *data, u32 addr,\n\t\t\t\t       u16 len, u8 *result, enum tpm_tis_io_mode io_mode)\n{\n\treturn tpm_tis_spi_cr50_transfer(data, addr, len, result, NULL);\n}\n\nstatic int tpm_tis_spi_cr50_write_bytes(struct tpm_tis_data *data, u32 addr,\n\t\t\t\t\tu16 len, const u8 *value, enum tpm_tis_io_mode io_mode)\n{\n\treturn tpm_tis_spi_cr50_transfer(data, addr, len, NULL, value);\n}\n\nstatic const struct tpm_tis_phy_ops tpm_spi_cr50_phy_ops = {\n\t.read_bytes = tpm_tis_spi_cr50_read_bytes,\n\t.write_bytes = tpm_tis_spi_cr50_write_bytes,\n};\n\nstatic void cr50_print_fw_version(struct tpm_tis_data *data)\n{\n\tstruct tpm_tis_spi_phy *phy = to_tpm_tis_spi_phy(data);\n\tint i, len = 0;\n\tchar fw_ver[TPM_CR50_MAX_FW_VER_LEN + 1];\n\tchar fw_ver_block[4];\n\n\t \n\ttpm_tis_write8(data, TPM_CR50_FW_VER(data->locality), 0);\n\n\t \n\tdo {\n\t\ttpm_tis_read_bytes(data, TPM_CR50_FW_VER(data->locality), 4,\n\t\t\t\t   fw_ver_block);\n\t\tfor (i = 0; i < 4 && fw_ver_block[i]; ++len, ++i)\n\t\t\tfw_ver[len] = fw_ver_block[i];\n\t} while (i == 4 && len < TPM_CR50_MAX_FW_VER_LEN);\n\tfw_ver[len] = '\\0';\n\n\tdev_info(&phy->spi_device->dev, \"Cr50 firmware version: %s\\n\", fw_ver);\n}\n\nint cr50_spi_probe(struct spi_device *spi)\n{\n\tstruct tpm_tis_spi_phy *phy;\n\tstruct cr50_spi_phy *cr50_phy;\n\tint ret;\n\tstruct tpm_chip *chip;\n\n\tcr50_phy = devm_kzalloc(&spi->dev, sizeof(*cr50_phy), GFP_KERNEL);\n\tif (!cr50_phy)\n\t\treturn -ENOMEM;\n\n\tphy = &cr50_phy->spi_phy;\n\tphy->flow_control = cr50_spi_flow_control;\n\tphy->wake_after = jiffies;\n\tphy->priv.rng_quality = TPM_CR50_DEFAULT_RNG_QUALITY;\n\tinit_completion(&phy->ready);\n\n\tcr50_phy->access_delay = CR50_NOIRQ_ACCESS_DELAY;\n\tcr50_phy->last_access = jiffies;\n\tmutex_init(&cr50_phy->time_track_mutex);\n\n\tif (spi->irq > 0) {\n\t\tret = devm_request_irq(&spi->dev, spi->irq,\n\t\t\t\t       cr50_spi_irq_handler,\n\t\t\t\t       IRQF_TRIGGER_RISING | IRQF_ONESHOT,\n\t\t\t\t       \"cr50_spi\", cr50_phy);\n\t\tif (ret < 0) {\n\t\t\tif (ret == -EPROBE_DEFER)\n\t\t\t\treturn ret;\n\t\t\tdev_warn(&spi->dev, \"Requesting IRQ %d failed: %d\\n\",\n\t\t\t\t spi->irq, ret);\n\t\t\t \n\t\t} else {\n\t\t\t \n\t\t\tcr50_phy->irq_needs_confirmation = true;\n\t\t}\n\t} else {\n\t\tdev_warn(&spi->dev,\n\t\t\t \"No IRQ - will use delays between transactions.\\n\");\n\t}\n\n\tret = tpm_tis_spi_init(spi, phy, -1, &tpm_spi_cr50_phy_ops);\n\tif (ret)\n\t\treturn ret;\n\n\tcr50_print_fw_version(&phy->priv);\n\n\tchip = dev_get_drvdata(&spi->dev);\n\tif (tpm_cr50_spi_is_firmware_power_managed(&spi->dev))\n\t\tchip->flags |= TPM_CHIP_FLAG_FIRMWARE_POWER_MANAGED;\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nint tpm_tis_spi_resume(struct device *dev)\n{\n\tstruct tpm_chip *chip = dev_get_drvdata(dev);\n\tstruct tpm_tis_data *data = dev_get_drvdata(&chip->dev);\n\tstruct tpm_tis_spi_phy *phy = to_tpm_tis_spi_phy(data);\n\t \n\tphy->wake_after = jiffies;\n\n\treturn tpm_tis_resume(dev);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}