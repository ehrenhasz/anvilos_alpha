{
  "module_name": "tpm-interface.c",
  "hash_id": "e1805ea4b5828ec4fe81b9f6eaa49ff456f8e12445afde7e8e5138841871eed9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/tpm/tpm-interface.c",
  "human_readable_source": "\n \n\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/suspend.h>\n#include <linux/freezer.h>\n#include <linux/tpm_eventlog.h>\n\n#include \"tpm.h\"\n\n \nstatic u32 tpm_suspend_pcr;\nmodule_param_named(suspend_pcr, tpm_suspend_pcr, uint, 0644);\nMODULE_PARM_DESC(suspend_pcr,\n\t\t \"PCR to use for dummy writes to facilitate flush on suspend.\");\n\n \nunsigned long tpm_calc_ordinal_duration(struct tpm_chip *chip, u32 ordinal)\n{\n\tif (chip->flags & TPM_CHIP_FLAG_TPM2)\n\t\treturn tpm2_calc_ordinal_duration(chip, ordinal);\n\telse\n\t\treturn tpm1_calc_ordinal_duration(chip, ordinal);\n}\nEXPORT_SYMBOL_GPL(tpm_calc_ordinal_duration);\n\nstatic ssize_t tpm_try_transmit(struct tpm_chip *chip, void *buf, size_t bufsiz)\n{\n\tstruct tpm_header *header = buf;\n\tint rc;\n\tssize_t len = 0;\n\tu32 count, ordinal;\n\tunsigned long stop;\n\n\tif (bufsiz < TPM_HEADER_SIZE)\n\t\treturn -EINVAL;\n\n\tif (bufsiz > TPM_BUFSIZE)\n\t\tbufsiz = TPM_BUFSIZE;\n\n\tcount = be32_to_cpu(header->length);\n\tordinal = be32_to_cpu(header->ordinal);\n\tif (count == 0)\n\t\treturn -ENODATA;\n\tif (count > bufsiz) {\n\t\tdev_err(&chip->dev,\n\t\t\t\"invalid count value %x %zx\\n\", count, bufsiz);\n\t\treturn -E2BIG;\n\t}\n\n\trc = chip->ops->send(chip, buf, count);\n\tif (rc < 0) {\n\t\tif (rc != -EPIPE)\n\t\t\tdev_err(&chip->dev,\n\t\t\t\t\"%s: send(): error %d\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\n\t \n\tif (rc > 0) {\n\t\tdev_warn(&chip->dev,\n\t\t\t \"%s: send(): invalid value %d\\n\", __func__, rc);\n\t\trc = 0;\n\t}\n\n\tif (chip->flags & TPM_CHIP_FLAG_IRQ)\n\t\tgoto out_recv;\n\n\tstop = jiffies + tpm_calc_ordinal_duration(chip, ordinal);\n\tdo {\n\t\tu8 status = chip->ops->status(chip);\n\t\tif ((status & chip->ops->req_complete_mask) ==\n\t\t    chip->ops->req_complete_val)\n\t\t\tgoto out_recv;\n\n\t\tif (chip->ops->req_canceled(chip, status)) {\n\t\t\tdev_err(&chip->dev, \"Operation Canceled\\n\");\n\t\t\treturn -ECANCELED;\n\t\t}\n\n\t\ttpm_msleep(TPM_TIMEOUT_POLL);\n\t\trmb();\n\t} while (time_before(jiffies, stop));\n\n\tchip->ops->cancel(chip);\n\tdev_err(&chip->dev, \"Operation Timed out\\n\");\n\treturn -ETIME;\n\nout_recv:\n\tlen = chip->ops->recv(chip, buf, bufsiz);\n\tif (len < 0) {\n\t\trc = len;\n\t\tdev_err(&chip->dev, \"tpm_transmit: tpm_recv: error %d\\n\", rc);\n\t} else if (len < TPM_HEADER_SIZE || len != be32_to_cpu(header->length))\n\t\trc = -EFAULT;\n\n\treturn rc ? rc : len;\n}\n\n \nssize_t tpm_transmit(struct tpm_chip *chip, u8 *buf, size_t bufsiz)\n{\n\tstruct tpm_header *header = (struct tpm_header *)buf;\n\t \n\tu8 save[TPM_HEADER_SIZE + 3*sizeof(u32)];\n\tunsigned int delay_msec = TPM2_DURATION_SHORT;\n\tu32 rc = 0;\n\tssize_t ret;\n\tconst size_t save_size = min(sizeof(save), bufsiz);\n\t \n\tu32 cc = be32_to_cpu(header->return_code);\n\n\t \n\tmemcpy(save, buf, save_size);\n\n\tfor (;;) {\n\t\tret = tpm_try_transmit(chip, buf, bufsiz);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\trc = be32_to_cpu(header->return_code);\n\t\tif (rc != TPM2_RC_RETRY && rc != TPM2_RC_TESTING)\n\t\t\tbreak;\n\t\t \n\t\tif (rc == TPM2_RC_TESTING && cc == TPM2_CC_SELF_TEST)\n\t\t\tbreak;\n\n\t\tif (delay_msec > TPM2_DURATION_LONG) {\n\t\t\tif (rc == TPM2_RC_RETRY)\n\t\t\t\tdev_err(&chip->dev, \"in retry loop\\n\");\n\t\t\telse\n\t\t\t\tdev_err(&chip->dev,\n\t\t\t\t\t\"self test is still running\\n\");\n\t\t\tbreak;\n\t\t}\n\t\ttpm_msleep(delay_msec);\n\t\tdelay_msec *= 2;\n\t\tmemcpy(buf, save, save_size);\n\t}\n\treturn ret;\n}\n\n \nssize_t tpm_transmit_cmd(struct tpm_chip *chip, struct tpm_buf *buf,\n\t\t\t size_t min_rsp_body_length, const char *desc)\n{\n\tconst struct tpm_header *header = (struct tpm_header *)buf->data;\n\tint err;\n\tssize_t len;\n\n\tlen = tpm_transmit(chip, buf->data, PAGE_SIZE);\n\tif (len <  0)\n\t\treturn len;\n\n\terr = be32_to_cpu(header->return_code);\n\tif (err != 0 && err != TPM_ERR_DISABLED && err != TPM_ERR_DEACTIVATED\n\t    && err != TPM2_RC_TESTING && desc)\n\t\tdev_err(&chip->dev, \"A TPM error (%d) occurred %s\\n\", err,\n\t\t\tdesc);\n\tif (err)\n\t\treturn err;\n\n\tif (len < min_rsp_body_length + TPM_HEADER_SIZE)\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(tpm_transmit_cmd);\n\nint tpm_get_timeouts(struct tpm_chip *chip)\n{\n\tif (chip->flags & TPM_CHIP_FLAG_HAVE_TIMEOUTS)\n\t\treturn 0;\n\n\tif (chip->flags & TPM_CHIP_FLAG_TPM2)\n\t\treturn tpm2_get_timeouts(chip);\n\telse\n\t\treturn tpm1_get_timeouts(chip);\n}\nEXPORT_SYMBOL_GPL(tpm_get_timeouts);\n\n \nint tpm_is_tpm2(struct tpm_chip *chip)\n{\n\tint rc;\n\n\tchip = tpm_find_get_ops(chip);\n\tif (!chip)\n\t\treturn -ENODEV;\n\n\trc = (chip->flags & TPM_CHIP_FLAG_TPM2) != 0;\n\n\ttpm_put_ops(chip);\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(tpm_is_tpm2);\n\n \nint tpm_pcr_read(struct tpm_chip *chip, u32 pcr_idx,\n\t\t struct tpm_digest *digest)\n{\n\tint rc;\n\n\tchip = tpm_find_get_ops(chip);\n\tif (!chip)\n\t\treturn -ENODEV;\n\n\tif (chip->flags & TPM_CHIP_FLAG_TPM2)\n\t\trc = tpm2_pcr_read(chip, pcr_idx, digest, NULL);\n\telse\n\t\trc = tpm1_pcr_read(chip, pcr_idx, digest->digest);\n\n\ttpm_put_ops(chip);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(tpm_pcr_read);\n\n \nint tpm_pcr_extend(struct tpm_chip *chip, u32 pcr_idx,\n\t\t   struct tpm_digest *digests)\n{\n\tint rc;\n\tint i;\n\n\tchip = tpm_find_get_ops(chip);\n\tif (!chip)\n\t\treturn -ENODEV;\n\n\tfor (i = 0; i < chip->nr_allocated_banks; i++) {\n\t\tif (digests[i].alg_id != chip->allocated_banks[i].alg_id) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (chip->flags & TPM_CHIP_FLAG_TPM2) {\n\t\trc = tpm2_pcr_extend(chip, pcr_idx, digests);\n\t\tgoto out;\n\t}\n\n\trc = tpm1_pcr_extend(chip, pcr_idx, digests[0].digest,\n\t\t\t     \"attempting extend a PCR value\");\n\nout:\n\ttpm_put_ops(chip);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(tpm_pcr_extend);\n\n \nint tpm_send(struct tpm_chip *chip, void *cmd, size_t buflen)\n{\n\tstruct tpm_buf buf;\n\tint rc;\n\n\tchip = tpm_find_get_ops(chip);\n\tif (!chip)\n\t\treturn -ENODEV;\n\n\tbuf.data = cmd;\n\trc = tpm_transmit_cmd(chip, &buf, 0, \"attempting to a send a command\");\n\n\ttpm_put_ops(chip);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(tpm_send);\n\nint tpm_auto_startup(struct tpm_chip *chip)\n{\n\tint rc;\n\n\tif (!(chip->ops->flags & TPM_OPS_AUTO_STARTUP))\n\t\treturn 0;\n\n\tif (chip->flags & TPM_CHIP_FLAG_TPM2)\n\t\trc = tpm2_auto_startup(chip);\n\telse\n\t\trc = tpm1_auto_startup(chip);\n\n\treturn rc;\n}\n\n \nint tpm_pm_suspend(struct device *dev)\n{\n\tstruct tpm_chip *chip = dev_get_drvdata(dev);\n\tint rc = 0;\n\n\tif (!chip)\n\t\treturn -ENODEV;\n\n\tif (chip->flags & TPM_CHIP_FLAG_ALWAYS_POWERED)\n\t\tgoto suspended;\n\n\tif ((chip->flags & TPM_CHIP_FLAG_FIRMWARE_POWER_MANAGED) &&\n\t    !pm_suspend_via_firmware())\n\t\tgoto suspended;\n\n\trc = tpm_try_get_ops(chip);\n\tif (!rc) {\n\t\tif (chip->flags & TPM_CHIP_FLAG_TPM2)\n\t\t\ttpm2_shutdown(chip, TPM2_SU_STATE);\n\t\telse\n\t\t\trc = tpm1_pm_suspend(chip, tpm_suspend_pcr);\n\n\t\ttpm_put_ops(chip);\n\t}\n\nsuspended:\n\tchip->flags |= TPM_CHIP_FLAG_SUSPENDED;\n\n\tif (rc)\n\t\tdev_err(dev, \"Ignoring error %d while suspending\\n\", rc);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(tpm_pm_suspend);\n\n \nint tpm_pm_resume(struct device *dev)\n{\n\tstruct tpm_chip *chip = dev_get_drvdata(dev);\n\n\tif (chip == NULL)\n\t\treturn -ENODEV;\n\n\tchip->flags &= ~TPM_CHIP_FLAG_SUSPENDED;\n\n\t \n\twmb();\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(tpm_pm_resume);\n\n \nint tpm_get_random(struct tpm_chip *chip, u8 *out, size_t max)\n{\n\tint rc;\n\n\tif (!out || max > TPM_MAX_RNG_DATA)\n\t\treturn -EINVAL;\n\n\tchip = tpm_find_get_ops(chip);\n\tif (!chip)\n\t\treturn -ENODEV;\n\n\tif (chip->flags & TPM_CHIP_FLAG_TPM2)\n\t\trc = tpm2_get_random(chip, out, max);\n\telse\n\t\trc = tpm1_get_random(chip, out, max);\n\n\ttpm_put_ops(chip);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(tpm_get_random);\n\nstatic int __init tpm_init(void)\n{\n\tint rc;\n\n\trc = class_register(&tpm_class);\n\tif (rc) {\n\t\tpr_err(\"couldn't create tpm class\\n\");\n\t\treturn rc;\n\t}\n\n\trc = class_register(&tpmrm_class);\n\tif (rc) {\n\t\tpr_err(\"couldn't create tpmrm class\\n\");\n\t\tgoto out_destroy_tpm_class;\n\t}\n\n\trc = alloc_chrdev_region(&tpm_devt, 0, 2*TPM_NUM_DEVICES, \"tpm\");\n\tif (rc < 0) {\n\t\tpr_err(\"tpm: failed to allocate char dev region\\n\");\n\t\tgoto out_destroy_tpmrm_class;\n\t}\n\n\trc = tpm_dev_common_init();\n\tif (rc) {\n\t\tpr_err(\"tpm: failed to allocate char dev region\\n\");\n\t\tgoto out_unreg_chrdev;\n\t}\n\n\treturn 0;\n\nout_unreg_chrdev:\n\tunregister_chrdev_region(tpm_devt, 2 * TPM_NUM_DEVICES);\nout_destroy_tpmrm_class:\n\tclass_unregister(&tpmrm_class);\nout_destroy_tpm_class:\n\tclass_unregister(&tpm_class);\n\n\treturn rc;\n}\n\nstatic void __exit tpm_exit(void)\n{\n\tidr_destroy(&dev_nums_idr);\n\tclass_unregister(&tpm_class);\n\tclass_unregister(&tpmrm_class);\n\tunregister_chrdev_region(tpm_devt, 2*TPM_NUM_DEVICES);\n\ttpm_dev_common_exit();\n}\n\nsubsys_initcall(tpm_init);\nmodule_exit(tpm_exit);\n\nMODULE_AUTHOR(\"Leendert van Doorn (leendert@watson.ibm.com)\");\nMODULE_DESCRIPTION(\"TPM Driver\");\nMODULE_VERSION(\"2.0\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}