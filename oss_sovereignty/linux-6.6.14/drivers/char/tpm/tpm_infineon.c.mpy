{
  "module_name": "tpm_infineon.c",
  "hash_id": "2518b20c2bcdf3680ae0b357abda574a6a7d26e387dfb47536c5efa1accac6ac",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/tpm/tpm_infineon.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/pnp.h>\n#include \"tpm.h\"\n\n \n \n#define\tTPM_MAX_WTX_PACKAGES \t50\n \n#define\tTPM_WTX_MSLEEP_TIME \t20\n \n#define\tTPM_MSLEEP_TIME \t3\n \n#define\tTPM_MAX_TRIES\t\t5000\n#define\tTPM_INFINEON_DEV_VEN_VALUE\t0x15D1\n\n#define TPM_INF_IO_PORT\t\t0x0\n#define TPM_INF_IO_MEM\t\t0x1\n\n#define TPM_INF_ADDR\t\t0x0\n#define TPM_INF_DATA\t\t0x1\n\nstruct tpm_inf_dev {\n\tint iotype;\n\n\tvoid __iomem *mem_base;\t \n\tunsigned long map_base;\t \n\tunsigned long map_size;\t \n\tunsigned int index_off;\t \n\n\tunsigned int data_regs;\t \n\tunsigned int data_size;\n\n\tunsigned int config_port;\t \n\tunsigned int config_size;\n};\n\nstatic struct tpm_inf_dev tpm_dev;\n\nstatic inline void tpm_data_out(unsigned char data, unsigned char offset)\n{\n\tif (tpm_dev.iotype == TPM_INF_IO_PORT)\n\t\toutb(data, tpm_dev.data_regs + offset);\n\telse\n\t\twriteb(data, tpm_dev.mem_base + tpm_dev.data_regs + offset);\n}\n\nstatic inline unsigned char tpm_data_in(unsigned char offset)\n{\n\tif (tpm_dev.iotype == TPM_INF_IO_PORT)\n\t\treturn inb(tpm_dev.data_regs + offset);\n\telse\n\t\treturn readb(tpm_dev.mem_base + tpm_dev.data_regs + offset);\n}\n\nstatic inline void tpm_config_out(unsigned char data, unsigned char offset)\n{\n\tif (tpm_dev.iotype == TPM_INF_IO_PORT)\n\t\toutb(data, tpm_dev.config_port + offset);\n\telse\n\t\twriteb(data, tpm_dev.mem_base + tpm_dev.index_off + offset);\n}\n\nstatic inline unsigned char tpm_config_in(unsigned char offset)\n{\n\tif (tpm_dev.iotype == TPM_INF_IO_PORT)\n\t\treturn inb(tpm_dev.config_port + offset);\n\telse\n\t\treturn readb(tpm_dev.mem_base + tpm_dev.index_off + offset);\n}\n\n \nenum infineon_tpm_header {\n\tTPM_VL_VER = 0x01,\n\tTPM_VL_CHANNEL_CONTROL = 0x07,\n\tTPM_VL_CHANNEL_PERSONALISATION = 0x0A,\n\tTPM_VL_CHANNEL_TPM = 0x0B,\n\tTPM_VL_CONTROL = 0x00,\n\tTPM_INF_NAK = 0x15,\n\tTPM_CTRL_WTX = 0x10,\n\tTPM_CTRL_WTX_ABORT = 0x18,\n\tTPM_CTRL_WTX_ABORT_ACK = 0x18,\n\tTPM_CTRL_ERROR = 0x20,\n\tTPM_CTRL_CHAININGACK = 0x40,\n\tTPM_CTRL_CHAINING = 0x80,\n\tTPM_CTRL_DATA = 0x04,\n\tTPM_CTRL_DATA_CHA = 0x84,\n\tTPM_CTRL_DATA_CHA_ACK = 0xC4\n};\n\nenum infineon_tpm_register {\n\tWRFIFO = 0x00,\n\tRDFIFO = 0x01,\n\tSTAT = 0x02,\n\tCMD = 0x03\n};\n\nenum infineon_tpm_command_bits {\n\tCMD_DIS = 0x00,\n\tCMD_LP = 0x01,\n\tCMD_RES = 0x02,\n\tCMD_IRQC = 0x06\n};\n\nenum infineon_tpm_status_bits {\n\tSTAT_XFE = 0x00,\n\tSTAT_LPA = 0x01,\n\tSTAT_FOK = 0x02,\n\tSTAT_TOK = 0x03,\n\tSTAT_IRQA = 0x06,\n\tSTAT_RDA = 0x07\n};\n\n \nenum infineon_tpm_values {\n\tCHIP_ID1 = 0x20,\n\tCHIP_ID2 = 0x21,\n\tTPM_DAR = 0x30,\n\tRESET_LP_IRQC_DISABLE = 0x41,\n\tENABLE_REGISTER_PAIR = 0x55,\n\tIOLIMH = 0x60,\n\tIOLIML = 0x61,\n\tDISABLE_REGISTER_PAIR = 0xAA,\n\tIDVENL = 0xF1,\n\tIDVENH = 0xF2,\n\tIDPDL = 0xF3,\n\tIDPDH = 0xF4\n};\n\nstatic int number_of_wtx;\n\nstatic int empty_fifo(struct tpm_chip *chip, int clear_wrfifo)\n{\n\tint status;\n\tint check = 0;\n\tint i;\n\n\tif (clear_wrfifo) {\n\t\tfor (i = 0; i < 4096; i++) {\n\t\t\tstatus = tpm_data_in(WRFIFO);\n\t\t\tif (status == 0xff) {\n\t\t\t\tif (check == 5)\n\t\t\t\t\tbreak;\n\t\t\t\telse\n\t\t\t\t\tcheck++;\n\t\t\t}\n\t\t}\n\t}\n\t \n\ti = 0;\n\tdo {\n\t\tstatus = tpm_data_in(RDFIFO);\n\t\tstatus = tpm_data_in(STAT);\n\t\ti++;\n\t\tif (i == TPM_MAX_TRIES)\n\t\t\treturn -EIO;\n\t} while ((status & (1 << STAT_RDA)) != 0);\n\treturn 0;\n}\n\nstatic int wait(struct tpm_chip *chip, int wait_for_bit)\n{\n\tint status;\n\tint i;\n\tfor (i = 0; i < TPM_MAX_TRIES; i++) {\n\t\tstatus = tpm_data_in(STAT);\n\t\t \n\t\tif (status & 1 << wait_for_bit)\n\t\t\tbreak;\n\t\ttpm_msleep(TPM_MSLEEP_TIME);\n\t}\n\tif (i == TPM_MAX_TRIES) {\t \n\t\tif (wait_for_bit == STAT_XFE)\n\t\t\tdev_err(&chip->dev, \"Timeout in wait(STAT_XFE)\\n\");\n\t\tif (wait_for_bit == STAT_RDA)\n\t\t\tdev_err(&chip->dev, \"Timeout in wait(STAT_RDA)\\n\");\n\t\treturn -EIO;\n\t}\n\treturn 0;\n};\n\nstatic void wait_and_send(struct tpm_chip *chip, u8 sendbyte)\n{\n\twait(chip, STAT_XFE);\n\ttpm_data_out(sendbyte, WRFIFO);\n}\n\n     \n\nstatic void tpm_wtx(struct tpm_chip *chip)\n{\n\tnumber_of_wtx++;\n\tdev_info(&chip->dev, \"Granting WTX (%02d / %02d)\\n\",\n\t\t number_of_wtx, TPM_MAX_WTX_PACKAGES);\n\twait_and_send(chip, TPM_VL_VER);\n\twait_and_send(chip, TPM_CTRL_WTX);\n\twait_and_send(chip, 0x00);\n\twait_and_send(chip, 0x00);\n\ttpm_msleep(TPM_WTX_MSLEEP_TIME);\n}\n\nstatic void tpm_wtx_abort(struct tpm_chip *chip)\n{\n\tdev_info(&chip->dev, \"Aborting WTX\\n\");\n\twait_and_send(chip, TPM_VL_VER);\n\twait_and_send(chip, TPM_CTRL_WTX_ABORT);\n\twait_and_send(chip, 0x00);\n\twait_and_send(chip, 0x00);\n\tnumber_of_wtx = 0;\n\ttpm_msleep(TPM_WTX_MSLEEP_TIME);\n}\n\nstatic int tpm_inf_recv(struct tpm_chip *chip, u8 * buf, size_t count)\n{\n\tint i;\n\tint ret;\n\tu32 size = 0;\n\tnumber_of_wtx = 0;\n\nrecv_begin:\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tret = wait(chip, STAT_RDA);\n\t\tif (ret)\n\t\t\treturn -EIO;\n\t\tbuf[i] = tpm_data_in(RDFIFO);\n\t}\n\n\tif (buf[0] != TPM_VL_VER) {\n\t\tdev_err(&chip->dev,\n\t\t\t\"Wrong transport protocol implementation!\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (buf[1] == TPM_CTRL_DATA) {\n\t\t \n\t\tsize = ((buf[2] << 8) | buf[3]);\n\n\t\tfor (i = 0; i < size; i++) {\n\t\t\twait(chip, STAT_RDA);\n\t\t\tbuf[i] = tpm_data_in(RDFIFO);\n\t\t}\n\n\t\tif ((size == 0x6D00) && (buf[1] == 0x80)) {\n\t\t\tdev_err(&chip->dev, \"Error handling on vendor layer!\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tfor (i = 0; i < size; i++)\n\t\t\tbuf[i] = buf[i + 6];\n\n\t\tsize = size - 6;\n\t\treturn size;\n\t}\n\n\tif (buf[1] == TPM_CTRL_WTX) {\n\t\tdev_info(&chip->dev, \"WTX-package received\\n\");\n\t\tif (number_of_wtx < TPM_MAX_WTX_PACKAGES) {\n\t\t\ttpm_wtx(chip);\n\t\t\tgoto recv_begin;\n\t\t} else {\n\t\t\ttpm_wtx_abort(chip);\n\t\t\tgoto recv_begin;\n\t\t}\n\t}\n\n\tif (buf[1] == TPM_CTRL_WTX_ABORT_ACK) {\n\t\tdev_info(&chip->dev, \"WTX-abort acknowledged\\n\");\n\t\treturn size;\n\t}\n\n\tif (buf[1] == TPM_CTRL_ERROR) {\n\t\tdev_err(&chip->dev, \"ERROR-package received:\\n\");\n\t\tif (buf[4] == TPM_INF_NAK)\n\t\t\tdev_err(&chip->dev,\n\t\t\t\t\"-> Negative acknowledgement\"\n\t\t\t\t\" - retransmit command!\\n\");\n\t\treturn -EIO;\n\t}\n\treturn -EIO;\n}\n\nstatic int tpm_inf_send(struct tpm_chip *chip, u8 * buf, size_t count)\n{\n\tint i;\n\tint ret;\n\tu8 count_high, count_low, count_4, count_3, count_2, count_1;\n\n\t \n\ttpm_data_out(RESET_LP_IRQC_DISABLE, CMD);\n\n\tret = empty_fifo(chip, 1);\n\tif (ret) {\n\t\tdev_err(&chip->dev, \"Timeout while clearing FIFO\\n\");\n\t\treturn -EIO;\n\t}\n\n\tret = wait(chip, STAT_XFE);\n\tif (ret)\n\t\treturn -EIO;\n\n\tcount_4 = (count & 0xff000000) >> 24;\n\tcount_3 = (count & 0x00ff0000) >> 16;\n\tcount_2 = (count & 0x0000ff00) >> 8;\n\tcount_1 = (count & 0x000000ff);\n\tcount_high = ((count + 6) & 0xffffff00) >> 8;\n\tcount_low = ((count + 6) & 0x000000ff);\n\n\t \n\twait_and_send(chip, TPM_VL_VER);\n\twait_and_send(chip, TPM_CTRL_DATA);\n\twait_and_send(chip, count_high);\n\twait_and_send(chip, count_low);\n\n\t \n\twait_and_send(chip, TPM_VL_VER);\n\twait_and_send(chip, TPM_VL_CHANNEL_TPM);\n\twait_and_send(chip, count_4);\n\twait_and_send(chip, count_3);\n\twait_and_send(chip, count_2);\n\twait_and_send(chip, count_1);\n\n\t \n\tfor (i = 0; i < count; i++) {\n\t\twait_and_send(chip, buf[i]);\n\t}\n\treturn 0;\n}\n\nstatic void tpm_inf_cancel(struct tpm_chip *chip)\n{\n\t \n}\n\nstatic u8 tpm_inf_status(struct tpm_chip *chip)\n{\n\treturn tpm_data_in(STAT);\n}\n\nstatic const struct tpm_class_ops tpm_inf = {\n\t.recv = tpm_inf_recv,\n\t.send = tpm_inf_send,\n\t.cancel = tpm_inf_cancel,\n\t.status = tpm_inf_status,\n\t.req_complete_mask = 0,\n\t.req_complete_val = 0,\n};\n\nstatic const struct pnp_device_id tpm_inf_pnp_tbl[] = {\n\t \n\t{\"IFX0101\", 0},\n\t{\"IFX0102\", 0},\n\t{\"\", 0}\n};\n\nMODULE_DEVICE_TABLE(pnp, tpm_inf_pnp_tbl);\n\nstatic int tpm_inf_pnp_probe(struct pnp_dev *dev,\n\t\t\t\t       const struct pnp_device_id *dev_id)\n{\n\tint rc = 0;\n\tu8 iol, ioh;\n\tint vendorid[2];\n\tint version[2];\n\tint productid[2];\n\tconst char *chipname;\n\tstruct tpm_chip *chip;\n\n\t \n\tif (pnp_port_valid(dev, 0) && pnp_port_valid(dev, 1) &&\n\t    !(pnp_port_flags(dev, 0) & IORESOURCE_DISABLED)) {\n\n\t\ttpm_dev.iotype = TPM_INF_IO_PORT;\n\n\t\ttpm_dev.config_port = pnp_port_start(dev, 0);\n\t\ttpm_dev.config_size = pnp_port_len(dev, 0);\n\t\ttpm_dev.data_regs = pnp_port_start(dev, 1);\n\t\ttpm_dev.data_size = pnp_port_len(dev, 1);\n\t\tif ((tpm_dev.data_size < 4) || (tpm_dev.config_size < 2)) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto err_last;\n\t\t}\n\t\tdev_info(&dev->dev, \"Found %s with ID %s\\n\",\n\t\t\t dev->name, dev_id->id);\n\t\tif (!((tpm_dev.data_regs >> 8) & 0xff)) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto err_last;\n\t\t}\n\t\t \n\t\tif (request_region(tpm_dev.data_regs, tpm_dev.data_size,\n\t\t\t\t   \"tpm_infineon0\") == NULL) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto err_last;\n\t\t}\n\t\tif (request_region(tpm_dev.config_port, tpm_dev.config_size,\n\t\t\t\t   \"tpm_infineon0\") == NULL) {\n\t\t\trelease_region(tpm_dev.data_regs, tpm_dev.data_size);\n\t\t\trc = -EINVAL;\n\t\t\tgoto err_last;\n\t\t}\n\t} else if (pnp_mem_valid(dev, 0) &&\n\t\t   !(pnp_mem_flags(dev, 0) & IORESOURCE_DISABLED)) {\n\n\t\ttpm_dev.iotype = TPM_INF_IO_MEM;\n\n\t\ttpm_dev.map_base = pnp_mem_start(dev, 0);\n\t\ttpm_dev.map_size = pnp_mem_len(dev, 0);\n\n\t\tdev_info(&dev->dev, \"Found %s with ID %s\\n\",\n\t\t\t dev->name, dev_id->id);\n\n\t\t \n\t\tif (request_mem_region(tpm_dev.map_base, tpm_dev.map_size,\n\t\t\t\t       \"tpm_infineon0\") == NULL) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto err_last;\n\t\t}\n\n\t\ttpm_dev.mem_base = ioremap(tpm_dev.map_base, tpm_dev.map_size);\n\t\tif (tpm_dev.mem_base == NULL) {\n\t\t\trelease_mem_region(tpm_dev.map_base, tpm_dev.map_size);\n\t\t\trc = -EINVAL;\n\t\t\tgoto err_last;\n\t\t}\n\n\t\t \n\t\ttpm_dev.index_off = TPM_ADDR;\n\t\ttpm_dev.data_regs = 0x0;\n\t} else {\n\t\trc = -EINVAL;\n\t\tgoto err_last;\n\t}\n\n\t \n\ttpm_config_out(ENABLE_REGISTER_PAIR, TPM_INF_ADDR);\n\ttpm_config_out(IDVENL, TPM_INF_ADDR);\n\tvendorid[1] = tpm_config_in(TPM_INF_DATA);\n\ttpm_config_out(IDVENH, TPM_INF_ADDR);\n\tvendorid[0] = tpm_config_in(TPM_INF_DATA);\n\ttpm_config_out(IDPDL, TPM_INF_ADDR);\n\tproductid[1] = tpm_config_in(TPM_INF_DATA);\n\ttpm_config_out(IDPDH, TPM_INF_ADDR);\n\tproductid[0] = tpm_config_in(TPM_INF_DATA);\n\ttpm_config_out(CHIP_ID1, TPM_INF_ADDR);\n\tversion[1] = tpm_config_in(TPM_INF_DATA);\n\ttpm_config_out(CHIP_ID2, TPM_INF_ADDR);\n\tversion[0] = tpm_config_in(TPM_INF_DATA);\n\n\tswitch ((productid[0] << 8) | productid[1]) {\n\tcase 6:\n\t\tchipname = \" (SLD 9630 TT 1.1)\";\n\t\tbreak;\n\tcase 11:\n\t\tchipname = \" (SLB 9635 TT 1.2)\";\n\t\tbreak;\n\tdefault:\n\t\tchipname = \" (unknown chip)\";\n\t\tbreak;\n\t}\n\n\tif ((vendorid[0] << 8 | vendorid[1]) == (TPM_INFINEON_DEV_VEN_VALUE)) {\n\n\t\t \n\t\ttpm_config_out(IOLIMH, TPM_INF_ADDR);\n\t\ttpm_config_out((tpm_dev.data_regs >> 8) & 0xff, TPM_INF_DATA);\n\t\ttpm_config_out(IOLIML, TPM_INF_ADDR);\n\t\ttpm_config_out((tpm_dev.data_regs & 0xff), TPM_INF_DATA);\n\n\t\t \n\t\ttpm_config_out(IOLIMH, TPM_INF_ADDR);\n\t\tioh = tpm_config_in(TPM_INF_DATA);\n\t\ttpm_config_out(IOLIML, TPM_INF_ADDR);\n\t\tiol = tpm_config_in(TPM_INF_DATA);\n\n\t\tif ((ioh << 8 | iol) != tpm_dev.data_regs) {\n\t\t\tdev_err(&dev->dev,\n\t\t\t\t\"Could not set IO-data registers to 0x%x\\n\",\n\t\t\t\ttpm_dev.data_regs);\n\t\t\trc = -EIO;\n\t\t\tgoto err_release_region;\n\t\t}\n\n\t\t \n\t\ttpm_config_out(TPM_DAR, TPM_INF_ADDR);\n\t\ttpm_config_out(0x01, TPM_INF_DATA);\n\t\ttpm_config_out(DISABLE_REGISTER_PAIR, TPM_INF_ADDR);\n\n\t\t \n\t\ttpm_data_out(RESET_LP_IRQC_DISABLE, CMD);\n\n\t\t \n\t\tdev_info(&dev->dev, \"TPM found: \"\n\t\t\t \"config base 0x%lx, \"\n\t\t\t \"data base 0x%lx, \"\n\t\t\t \"chip version 0x%02x%02x, \"\n\t\t\t \"vendor id 0x%x%x (Infineon), \"\n\t\t\t \"product id 0x%02x%02x\"\n\t\t\t \"%s\\n\",\n\t\t\t tpm_dev.iotype == TPM_INF_IO_PORT ?\n\t\t\t tpm_dev.config_port :\n\t\t\t tpm_dev.map_base + tpm_dev.index_off,\n\t\t\t tpm_dev.iotype == TPM_INF_IO_PORT ?\n\t\t\t tpm_dev.data_regs :\n\t\t\t tpm_dev.map_base + tpm_dev.data_regs,\n\t\t\t version[0], version[1],\n\t\t\t vendorid[0], vendorid[1],\n\t\t\t productid[0], productid[1], chipname);\n\n\t\tchip = tpmm_chip_alloc(&dev->dev, &tpm_inf);\n\t\tif (IS_ERR(chip)) {\n\t\t\trc = PTR_ERR(chip);\n\t\t\tgoto err_release_region;\n\t\t}\n\n\t\trc = tpm_chip_register(chip);\n\t\tif (rc)\n\t\t\tgoto err_release_region;\n\n\t\treturn 0;\n\t} else {\n\t\trc = -ENODEV;\n\t\tgoto err_release_region;\n\t}\n\nerr_release_region:\n\tif (tpm_dev.iotype == TPM_INF_IO_PORT) {\n\t\trelease_region(tpm_dev.data_regs, tpm_dev.data_size);\n\t\trelease_region(tpm_dev.config_port, tpm_dev.config_size);\n\t} else {\n\t\tiounmap(tpm_dev.mem_base);\n\t\trelease_mem_region(tpm_dev.map_base, tpm_dev.map_size);\n\t}\n\nerr_last:\n\treturn rc;\n}\n\nstatic void tpm_inf_pnp_remove(struct pnp_dev *dev)\n{\n\tstruct tpm_chip *chip = pnp_get_drvdata(dev);\n\n\ttpm_chip_unregister(chip);\n\n\tif (tpm_dev.iotype == TPM_INF_IO_PORT) {\n\t\trelease_region(tpm_dev.data_regs, tpm_dev.data_size);\n\t\trelease_region(tpm_dev.config_port,\n\t\t\t       tpm_dev.config_size);\n\t} else {\n\t\tiounmap(tpm_dev.mem_base);\n\t\trelease_mem_region(tpm_dev.map_base, tpm_dev.map_size);\n\t}\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int tpm_inf_resume(struct device *dev)\n{\n\t \n\ttpm_config_out(ENABLE_REGISTER_PAIR, TPM_INF_ADDR);\n\ttpm_config_out(IOLIMH, TPM_INF_ADDR);\n\ttpm_config_out((tpm_dev.data_regs >> 8) & 0xff, TPM_INF_DATA);\n\ttpm_config_out(IOLIML, TPM_INF_ADDR);\n\ttpm_config_out((tpm_dev.data_regs & 0xff), TPM_INF_DATA);\n\t \n\ttpm_config_out(TPM_DAR, TPM_INF_ADDR);\n\ttpm_config_out(0x01, TPM_INF_DATA);\n\ttpm_config_out(DISABLE_REGISTER_PAIR, TPM_INF_ADDR);\n\t \n\ttpm_data_out(RESET_LP_IRQC_DISABLE, CMD);\n\treturn tpm_pm_resume(dev);\n}\n#endif\nstatic SIMPLE_DEV_PM_OPS(tpm_inf_pm, tpm_pm_suspend, tpm_inf_resume);\n\nstatic struct pnp_driver tpm_inf_pnp_driver = {\n\t.name = \"tpm_inf_pnp\",\n\t.id_table = tpm_inf_pnp_tbl,\n\t.probe = tpm_inf_pnp_probe,\n\t.remove = tpm_inf_pnp_remove,\n\t.driver = {\n\t\t.pm = &tpm_inf_pm,\n\t}\n};\n\nmodule_pnp_driver(tpm_inf_pnp_driver);\n\nMODULE_AUTHOR(\"Marcel Selhorst <tpmdd@sirrix.com>\");\nMODULE_DESCRIPTION(\"Driver for Infineon TPM SLD 9630 TT 1.1 / SLB 9635 TT 1.2\");\nMODULE_VERSION(\"1.9.2\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}