{
  "module_name": "tpm_ibmvtpm.c",
  "hash_id": "4a6dece1e2111e04621420c27d8e1c57782f400ce01439c3a73ab7e83ce9bdc2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/tpm/tpm_ibmvtpm.c",
  "human_readable_source": "\n \n\n#include <linux/dma-mapping.h>\n#include <linux/dmapool.h>\n#include <linux/slab.h>\n#include <asm/vio.h>\n#include <asm/irq.h>\n#include <linux/types.h>\n#include <linux/list.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/wait.h>\n#include <asm/prom.h>\n\n#include \"tpm.h\"\n#include \"tpm_ibmvtpm.h\"\n\nstatic const char tpm_ibmvtpm_driver_name[] = \"tpm_ibmvtpm\";\n\nstatic const struct vio_device_id tpm_ibmvtpm_device_table[] = {\n\t{ \"IBM,vtpm\", \"IBM,vtpm\"},\n\t{ \"IBM,vtpm\", \"IBM,vtpm20\"},\n\t{ \"\", \"\" }\n};\nMODULE_DEVICE_TABLE(vio, tpm_ibmvtpm_device_table);\n\n \nstatic int ibmvtpm_send_crq_word(struct vio_dev *vdev, u64 w1)\n{\n\treturn plpar_hcall_norets(H_SEND_CRQ, vdev->unit_address, w1, 0);\n}\n\n \nstatic int ibmvtpm_send_crq(struct vio_dev *vdev,\n\t\tu8 valid, u8 msg, u16 len, u32 data)\n{\n\tu64 w1 = ((u64)valid << 56) | ((u64)msg << 48) | ((u64)len << 32) |\n\t\t(u64)data;\n\treturn ibmvtpm_send_crq_word(vdev, w1);\n}\n\n \nstatic int tpm_ibmvtpm_recv(struct tpm_chip *chip, u8 *buf, size_t count)\n{\n\tstruct ibmvtpm_dev *ibmvtpm = dev_get_drvdata(&chip->dev);\n\tu16 len;\n\n\tif (!ibmvtpm->rtce_buf) {\n\t\tdev_err(ibmvtpm->dev, \"ibmvtpm device is not ready\\n\");\n\t\treturn 0;\n\t}\n\n\tlen = ibmvtpm->res_len;\n\n\tif (count < len) {\n\t\tdev_err(ibmvtpm->dev,\n\t\t\t\"Invalid size in recv: count=%zd, crq_size=%d\\n\",\n\t\t\tcount, len);\n\t\treturn -EIO;\n\t}\n\n\tspin_lock(&ibmvtpm->rtce_lock);\n\tmemcpy((void *)buf, (void *)ibmvtpm->rtce_buf, len);\n\tmemset(ibmvtpm->rtce_buf, 0, len);\n\tibmvtpm->res_len = 0;\n\tspin_unlock(&ibmvtpm->rtce_lock);\n\treturn len;\n}\n\n \nstatic int ibmvtpm_crq_send_init(struct ibmvtpm_dev *ibmvtpm)\n{\n\tint rc;\n\n\trc = ibmvtpm_send_crq_word(ibmvtpm->vdev, INIT_CRQ_CMD);\n\tif (rc != H_SUCCESS)\n\t\tdev_err(ibmvtpm->dev,\n\t\t\t\"%s failed rc=%d\\n\", __func__, rc);\n\n\treturn rc;\n}\n\n \nstatic int tpm_ibmvtpm_resume(struct device *dev)\n{\n\tstruct tpm_chip *chip = dev_get_drvdata(dev);\n\tstruct ibmvtpm_dev *ibmvtpm = dev_get_drvdata(&chip->dev);\n\tint rc = 0;\n\n\tdo {\n\t\tif (rc)\n\t\t\tmsleep(100);\n\t\trc = plpar_hcall_norets(H_ENABLE_CRQ,\n\t\t\t\t\tibmvtpm->vdev->unit_address);\n\t} while (rc == H_IN_PROGRESS || rc == H_BUSY || H_IS_LONG_BUSY(rc));\n\n\tif (rc) {\n\t\tdev_err(dev, \"Error enabling ibmvtpm rc=%d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\trc = vio_enable_interrupts(ibmvtpm->vdev);\n\tif (rc) {\n\t\tdev_err(dev, \"Error vio_enable_interrupts rc=%d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\trc = ibmvtpm_crq_send_init(ibmvtpm);\n\tif (rc)\n\t\tdev_err(dev, \"Error send_init rc=%d\\n\", rc);\n\n\treturn rc;\n}\n\n \nstatic int tpm_ibmvtpm_send(struct tpm_chip *chip, u8 *buf, size_t count)\n{\n\tstruct ibmvtpm_dev *ibmvtpm = dev_get_drvdata(&chip->dev);\n\tbool retry = true;\n\tint rc, sig;\n\n\tif (!ibmvtpm->rtce_buf) {\n\t\tdev_err(ibmvtpm->dev, \"ibmvtpm device is not ready\\n\");\n\t\treturn 0;\n\t}\n\n\tif (count > ibmvtpm->rtce_size) {\n\t\tdev_err(ibmvtpm->dev,\n\t\t\t\"Invalid size in send: count=%zd, rtce_size=%d\\n\",\n\t\t\tcount, ibmvtpm->rtce_size);\n\t\treturn -EIO;\n\t}\n\n\tif (ibmvtpm->tpm_processing_cmd) {\n\t\tdev_info(ibmvtpm->dev,\n\t\t         \"Need to wait for TPM to finish\\n\");\n\t\t \n\t\tsig = wait_event_interruptible(ibmvtpm->wq, !ibmvtpm->tpm_processing_cmd);\n\t\tif (sig)\n\t\t\treturn -EINTR;\n\t}\n\n\tspin_lock(&ibmvtpm->rtce_lock);\n\tibmvtpm->res_len = 0;\n\tmemcpy((void *)ibmvtpm->rtce_buf, (void *)buf, count);\n\n\t \n\tibmvtpm->tpm_processing_cmd = 1;\n\nagain:\n\trc = ibmvtpm_send_crq(ibmvtpm->vdev,\n\t\t\tIBMVTPM_VALID_CMD, VTPM_TPM_COMMAND,\n\t\t\tcount, ibmvtpm->rtce_dma_handle);\n\tif (rc != H_SUCCESS) {\n\t\t \n\t\tif (rc == H_CLOSED && retry) {\n\t\t\ttpm_ibmvtpm_resume(ibmvtpm->dev);\n\t\t\tretry = false;\n\t\t\tgoto again;\n\t\t}\n\t\tdev_err(ibmvtpm->dev, \"tpm_ibmvtpm_send failed rc=%d\\n\", rc);\n\t\tibmvtpm->tpm_processing_cmd = 0;\n\t}\n\n\tspin_unlock(&ibmvtpm->rtce_lock);\n\treturn 0;\n}\n\nstatic void tpm_ibmvtpm_cancel(struct tpm_chip *chip)\n{\n\treturn;\n}\n\nstatic u8 tpm_ibmvtpm_status(struct tpm_chip *chip)\n{\n\tstruct ibmvtpm_dev *ibmvtpm = dev_get_drvdata(&chip->dev);\n\n\treturn ibmvtpm->tpm_processing_cmd;\n}\n\n \nstatic int ibmvtpm_crq_get_rtce_size(struct ibmvtpm_dev *ibmvtpm)\n{\n\tint rc;\n\n\trc = ibmvtpm_send_crq(ibmvtpm->vdev,\n\t\t\tIBMVTPM_VALID_CMD, VTPM_GET_RTCE_BUFFER_SIZE, 0, 0);\n\tif (rc != H_SUCCESS)\n\t\tdev_err(ibmvtpm->dev,\n\t\t\t\"ibmvtpm_crq_get_rtce_size failed rc=%d\\n\", rc);\n\n\treturn rc;\n}\n\n \nstatic int ibmvtpm_crq_get_version(struct ibmvtpm_dev *ibmvtpm)\n{\n\tint rc;\n\n\trc = ibmvtpm_send_crq(ibmvtpm->vdev,\n\t\t\tIBMVTPM_VALID_CMD, VTPM_GET_VERSION, 0, 0);\n\tif (rc != H_SUCCESS)\n\t\tdev_err(ibmvtpm->dev,\n\t\t\t\"ibmvtpm_crq_get_version failed rc=%d\\n\", rc);\n\n\treturn rc;\n}\n\n \nstatic int ibmvtpm_crq_send_init_complete(struct ibmvtpm_dev *ibmvtpm)\n{\n\tint rc;\n\n\trc = ibmvtpm_send_crq_word(ibmvtpm->vdev, INIT_CRQ_COMP_CMD);\n\tif (rc != H_SUCCESS)\n\t\tdev_err(ibmvtpm->dev,\n\t\t\t\"ibmvtpm_crq_send_init_complete failed rc=%d\\n\", rc);\n\n\treturn rc;\n}\n\n \nstatic void tpm_ibmvtpm_remove(struct vio_dev *vdev)\n{\n\tstruct tpm_chip *chip = dev_get_drvdata(&vdev->dev);\n\tstruct ibmvtpm_dev *ibmvtpm = dev_get_drvdata(&chip->dev);\n\tint rc = 0;\n\n\ttpm_chip_unregister(chip);\n\n\tfree_irq(vdev->irq, ibmvtpm);\n\n\tdo {\n\t\tif (rc)\n\t\t\tmsleep(100);\n\t\trc = plpar_hcall_norets(H_FREE_CRQ, vdev->unit_address);\n\t} while (rc == H_BUSY || H_IS_LONG_BUSY(rc));\n\n\tdma_unmap_single(ibmvtpm->dev, ibmvtpm->crq_dma_handle,\n\t\t\t CRQ_RES_BUF_SIZE, DMA_BIDIRECTIONAL);\n\tfree_page((unsigned long)ibmvtpm->crq_queue.crq_addr);\n\n\tif (ibmvtpm->rtce_buf) {\n\t\tdma_unmap_single(ibmvtpm->dev, ibmvtpm->rtce_dma_handle,\n\t\t\t\t ibmvtpm->rtce_size, DMA_BIDIRECTIONAL);\n\t\tkfree(ibmvtpm->rtce_buf);\n\t}\n\n\tkfree(ibmvtpm);\n\t \n\tdev_set_drvdata(&vdev->dev, NULL);\n}\n\n \nstatic unsigned long tpm_ibmvtpm_get_desired_dma(struct vio_dev *vdev)\n{\n\tstruct tpm_chip *chip = dev_get_drvdata(&vdev->dev);\n\tstruct ibmvtpm_dev *ibmvtpm;\n\n\t \n\tif (chip)\n\t\tibmvtpm = dev_get_drvdata(&chip->dev);\n\telse\n\t\treturn CRQ_RES_BUF_SIZE + PAGE_SIZE;\n\n\treturn CRQ_RES_BUF_SIZE + ibmvtpm->rtce_size;\n}\n\n \nstatic int tpm_ibmvtpm_suspend(struct device *dev)\n{\n\tstruct tpm_chip *chip = dev_get_drvdata(dev);\n\tstruct ibmvtpm_dev *ibmvtpm = dev_get_drvdata(&chip->dev);\n\tint rc = 0;\n\n\trc = ibmvtpm_send_crq(ibmvtpm->vdev,\n\t\t\tIBMVTPM_VALID_CMD, VTPM_PREPARE_TO_SUSPEND, 0, 0);\n\tif (rc != H_SUCCESS)\n\t\tdev_err(ibmvtpm->dev,\n\t\t\t\"tpm_ibmvtpm_suspend failed rc=%d\\n\", rc);\n\n\treturn rc;\n}\n\n \nstatic int ibmvtpm_reset_crq(struct ibmvtpm_dev *ibmvtpm)\n{\n\tint rc = 0;\n\n\tdo {\n\t\tif (rc)\n\t\t\tmsleep(100);\n\t\trc = plpar_hcall_norets(H_FREE_CRQ,\n\t\t\t\t\tibmvtpm->vdev->unit_address);\n\t} while (rc == H_BUSY || H_IS_LONG_BUSY(rc));\n\n\tmemset(ibmvtpm->crq_queue.crq_addr, 0, CRQ_RES_BUF_SIZE);\n\tibmvtpm->crq_queue.index = 0;\n\n\treturn plpar_hcall_norets(H_REG_CRQ, ibmvtpm->vdev->unit_address,\n\t\t\t\t  ibmvtpm->crq_dma_handle, CRQ_RES_BUF_SIZE);\n}\n\nstatic bool tpm_ibmvtpm_req_canceled(struct tpm_chip *chip, u8 status)\n{\n\treturn (status == 0);\n}\n\nstatic const struct tpm_class_ops tpm_ibmvtpm = {\n\t.recv = tpm_ibmvtpm_recv,\n\t.send = tpm_ibmvtpm_send,\n\t.cancel = tpm_ibmvtpm_cancel,\n\t.status = tpm_ibmvtpm_status,\n\t.req_complete_mask = 1,\n\t.req_complete_val = 0,\n\t.req_canceled = tpm_ibmvtpm_req_canceled,\n};\n\nstatic const struct dev_pm_ops tpm_ibmvtpm_pm_ops = {\n\t.suspend = tpm_ibmvtpm_suspend,\n\t.resume = tpm_ibmvtpm_resume,\n};\n\n \nstatic struct ibmvtpm_crq *ibmvtpm_crq_get_next(struct ibmvtpm_dev *ibmvtpm)\n{\n\tstruct ibmvtpm_crq_queue *crq_q = &ibmvtpm->crq_queue;\n\tstruct ibmvtpm_crq *crq = &crq_q->crq_addr[crq_q->index];\n\n\tif (crq->valid & VTPM_MSG_RES) {\n\t\tif (++crq_q->index == crq_q->num_entry)\n\t\t\tcrq_q->index = 0;\n\t\tsmp_rmb();\n\t} else\n\t\tcrq = NULL;\n\treturn crq;\n}\n\n \nstatic void ibmvtpm_crq_process(struct ibmvtpm_crq *crq,\n\t\t\t\tstruct ibmvtpm_dev *ibmvtpm)\n{\n\tint rc = 0;\n\n\tswitch (crq->valid) {\n\tcase VALID_INIT_CRQ:\n\t\tswitch (crq->msg) {\n\t\tcase INIT_CRQ_RES:\n\t\t\tdev_info(ibmvtpm->dev, \"CRQ initialized\\n\");\n\t\t\trc = ibmvtpm_crq_send_init_complete(ibmvtpm);\n\t\t\tif (rc)\n\t\t\t\tdev_err(ibmvtpm->dev, \"Unable to send CRQ init complete rc=%d\\n\", rc);\n\t\t\treturn;\n\t\tcase INIT_CRQ_COMP_RES:\n\t\t\tdev_info(ibmvtpm->dev,\n\t\t\t\t \"CRQ initialization completed\\n\");\n\t\t\treturn;\n\t\tdefault:\n\t\t\tdev_err(ibmvtpm->dev, \"Unknown crq message type: %d\\n\", crq->msg);\n\t\t\treturn;\n\t\t}\n\tcase IBMVTPM_VALID_CMD:\n\t\tswitch (crq->msg) {\n\t\tcase VTPM_GET_RTCE_BUFFER_SIZE_RES:\n\t\t\tif (be16_to_cpu(crq->len) <= 0) {\n\t\t\t\tdev_err(ibmvtpm->dev, \"Invalid rtce size\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tibmvtpm->rtce_size = be16_to_cpu(crq->len);\n\t\t\tibmvtpm->rtce_buf = kmalloc(ibmvtpm->rtce_size,\n\t\t\t\t\t\t    GFP_ATOMIC);\n\t\t\tif (!ibmvtpm->rtce_buf) {\n\t\t\t\tdev_err(ibmvtpm->dev, \"Failed to allocate memory for rtce buffer\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tibmvtpm->rtce_dma_handle = dma_map_single(ibmvtpm->dev,\n\t\t\t\tibmvtpm->rtce_buf, ibmvtpm->rtce_size,\n\t\t\t\tDMA_BIDIRECTIONAL);\n\n\t\t\tif (dma_mapping_error(ibmvtpm->dev,\n\t\t\t\t\t      ibmvtpm->rtce_dma_handle)) {\n\t\t\t\tkfree(ibmvtpm->rtce_buf);\n\t\t\t\tibmvtpm->rtce_buf = NULL;\n\t\t\t\tdev_err(ibmvtpm->dev, \"Failed to dma map rtce buffer\\n\");\n\t\t\t}\n\n\t\t\treturn;\n\t\tcase VTPM_GET_VERSION_RES:\n\t\t\tibmvtpm->vtpm_version = be32_to_cpu(crq->data);\n\t\t\treturn;\n\t\tcase VTPM_TPM_COMMAND_RES:\n\t\t\t \n\t\t\tibmvtpm->res_len = be16_to_cpu(crq->len);\n\t\t\tibmvtpm->tpm_processing_cmd = 0;\n\t\t\twake_up_interruptible(&ibmvtpm->wq);\n\t\t\treturn;\n\t\tdefault:\n\t\t\treturn;\n\t\t}\n\t}\n\treturn;\n}\n\n \nstatic irqreturn_t ibmvtpm_interrupt(int irq, void *vtpm_instance)\n{\n\tstruct ibmvtpm_dev *ibmvtpm = (struct ibmvtpm_dev *) vtpm_instance;\n\tstruct ibmvtpm_crq *crq;\n\n\t \n\twhile ((crq = ibmvtpm_crq_get_next(ibmvtpm)) != NULL) {\n\t\tibmvtpm_crq_process(crq, ibmvtpm);\n\t\twake_up_interruptible(&ibmvtpm->crq_queue.wq);\n\t\tcrq->valid = 0;\n\t\tsmp_wmb();\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int tpm_ibmvtpm_probe(struct vio_dev *vio_dev,\n\t\t\t\t   const struct vio_device_id *id)\n{\n\tstruct ibmvtpm_dev *ibmvtpm;\n\tstruct device *dev = &vio_dev->dev;\n\tstruct ibmvtpm_crq_queue *crq_q;\n\tstruct tpm_chip *chip;\n\tint rc = -ENOMEM, rc1;\n\n\tchip = tpmm_chip_alloc(dev, &tpm_ibmvtpm);\n\tif (IS_ERR(chip))\n\t\treturn PTR_ERR(chip);\n\n\tibmvtpm = kzalloc(sizeof(struct ibmvtpm_dev), GFP_KERNEL);\n\tif (!ibmvtpm) {\n\t\tdev_err(dev, \"kzalloc for ibmvtpm failed\\n\");\n\t\tgoto cleanup;\n\t}\n\n\tibmvtpm->dev = dev;\n\tibmvtpm->vdev = vio_dev;\n\n\tcrq_q = &ibmvtpm->crq_queue;\n\tcrq_q->crq_addr = (struct ibmvtpm_crq *)get_zeroed_page(GFP_KERNEL);\n\tif (!crq_q->crq_addr) {\n\t\tdev_err(dev, \"Unable to allocate memory for crq_addr\\n\");\n\t\tgoto cleanup;\n\t}\n\n\tcrq_q->num_entry = CRQ_RES_BUF_SIZE / sizeof(*crq_q->crq_addr);\n\tinit_waitqueue_head(&crq_q->wq);\n\tibmvtpm->crq_dma_handle = dma_map_single(dev, crq_q->crq_addr,\n\t\t\t\t\t\t CRQ_RES_BUF_SIZE,\n\t\t\t\t\t\t DMA_BIDIRECTIONAL);\n\n\tif (dma_mapping_error(dev, ibmvtpm->crq_dma_handle)) {\n\t\tdev_err(dev, \"dma mapping failed\\n\");\n\t\tgoto cleanup;\n\t}\n\n\trc = plpar_hcall_norets(H_REG_CRQ, vio_dev->unit_address,\n\t\t\t\tibmvtpm->crq_dma_handle, CRQ_RES_BUF_SIZE);\n\tif (rc == H_RESOURCE)\n\t\trc = ibmvtpm_reset_crq(ibmvtpm);\n\n\tif (rc) {\n\t\tdev_err(dev, \"Unable to register CRQ rc=%d\\n\", rc);\n\t\tgoto reg_crq_cleanup;\n\t}\n\n\trc = request_irq(vio_dev->irq, ibmvtpm_interrupt, 0,\n\t\t\t tpm_ibmvtpm_driver_name, ibmvtpm);\n\tif (rc) {\n\t\tdev_err(dev, \"Error %d register irq 0x%x\\n\", rc, vio_dev->irq);\n\t\tgoto init_irq_cleanup;\n\t}\n\n\trc = vio_enable_interrupts(vio_dev);\n\tif (rc) {\n\t\tdev_err(dev, \"Error %d enabling interrupts\\n\", rc);\n\t\tgoto init_irq_cleanup;\n\t}\n\n\tinit_waitqueue_head(&ibmvtpm->wq);\n\n\tcrq_q->index = 0;\n\n\tdev_set_drvdata(&chip->dev, ibmvtpm);\n\n\tspin_lock_init(&ibmvtpm->rtce_lock);\n\n\trc = ibmvtpm_crq_send_init(ibmvtpm);\n\tif (rc)\n\t\tgoto init_irq_cleanup;\n\n\trc = ibmvtpm_crq_get_version(ibmvtpm);\n\tif (rc)\n\t\tgoto init_irq_cleanup;\n\n\trc = ibmvtpm_crq_get_rtce_size(ibmvtpm);\n\tif (rc)\n\t\tgoto init_irq_cleanup;\n\n\tif (!wait_event_timeout(ibmvtpm->crq_queue.wq,\n\t\t\t\tibmvtpm->rtce_buf != NULL,\n\t\t\t\tHZ)) {\n\t\trc = -ENODEV;\n\t\tdev_err(dev, \"CRQ response timed out\\n\");\n\t\tgoto init_irq_cleanup;\n\t}\n\n\n\tif (!strcmp(id->compat, \"IBM,vtpm20\"))\n\t\tchip->flags |= TPM_CHIP_FLAG_TPM2;\n\n\trc = tpm_get_timeouts(chip);\n\tif (rc)\n\t\tgoto init_irq_cleanup;\n\n\tif (chip->flags & TPM_CHIP_FLAG_TPM2) {\n\t\trc = tpm2_get_cc_attrs_tbl(chip);\n\t\tif (rc)\n\t\t\tgoto init_irq_cleanup;\n\t}\n\n\treturn tpm_chip_register(chip);\ninit_irq_cleanup:\n\tdo {\n\t\trc1 = plpar_hcall_norets(H_FREE_CRQ, vio_dev->unit_address);\n\t} while (rc1 == H_BUSY || H_IS_LONG_BUSY(rc1));\nreg_crq_cleanup:\n\tdma_unmap_single(dev, ibmvtpm->crq_dma_handle, CRQ_RES_BUF_SIZE,\n\t\t\t DMA_BIDIRECTIONAL);\ncleanup:\n\tif (ibmvtpm) {\n\t\tif (crq_q->crq_addr)\n\t\t\tfree_page((unsigned long)crq_q->crq_addr);\n\t\tkfree(ibmvtpm);\n\t}\n\n\treturn rc;\n}\n\nstatic struct vio_driver ibmvtpm_driver = {\n\t.id_table\t = tpm_ibmvtpm_device_table,\n\t.probe\t\t = tpm_ibmvtpm_probe,\n\t.remove\t\t = tpm_ibmvtpm_remove,\n\t.get_desired_dma = tpm_ibmvtpm_get_desired_dma,\n\t.name\t\t = tpm_ibmvtpm_driver_name,\n\t.pm\t\t = &tpm_ibmvtpm_pm_ops,\n};\n\n \nstatic int __init ibmvtpm_module_init(void)\n{\n\treturn vio_register_driver(&ibmvtpm_driver);\n}\n\n \nstatic void __exit ibmvtpm_module_exit(void)\n{\n\tvio_unregister_driver(&ibmvtpm_driver);\n}\n\nmodule_init(ibmvtpm_module_init);\nmodule_exit(ibmvtpm_module_exit);\n\nMODULE_AUTHOR(\"adlai@us.ibm.com\");\nMODULE_DESCRIPTION(\"IBM vTPM Driver\");\nMODULE_VERSION(\"1.0\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}