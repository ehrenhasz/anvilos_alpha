{
  "module_name": "tpm_tis.c",
  "hash_id": "9a67ff02ebfd358ccfa7c1bce7400b93377d1579cc281f103195d8bfd6e4520c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/tpm/tpm_tis.c",
  "human_readable_source": "\n \n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/pnp.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/wait.h>\n#include <linux/acpi.h>\n#include <linux/freezer.h>\n#include <linux/of.h>\n#include <linux/kernel.h>\n#include \"tpm.h\"\n#include \"tpm_tis_core.h\"\n\nstruct tpm_info {\n\tstruct resource res;\n\t \n\tint irq;\n};\n\nstruct tpm_tis_tcg_phy {\n\tstruct tpm_tis_data priv;\n\tvoid __iomem *iobase;\n};\n\nstatic inline struct tpm_tis_tcg_phy *to_tpm_tis_tcg_phy(struct tpm_tis_data *data)\n{\n\treturn container_of(data, struct tpm_tis_tcg_phy, priv);\n}\n\n#ifdef CONFIG_PREEMPT_RT\n \nstatic inline void tpm_tis_flush(void __iomem *iobase)\n{\n\tioread8(iobase + TPM_ACCESS(0));\n}\n#else\n#define tpm_tis_flush(iobase) do { } while (0)\n#endif\n\n \nstatic inline void tpm_tis_iowrite8(u8 b, void __iomem *iobase, u32 addr)\n{\n\tiowrite8(b, iobase + addr);\n\ttpm_tis_flush(iobase);\n}\n\n \nstatic inline void tpm_tis_iowrite32(u32 b, void __iomem *iobase, u32 addr)\n{\n\tiowrite32(b, iobase + addr);\n\ttpm_tis_flush(iobase);\n}\n\nstatic bool interrupts;\nmodule_param(interrupts, bool, 0444);\nMODULE_PARM_DESC(interrupts, \"Enable interrupts\");\n\nstatic bool itpm;\nmodule_param(itpm, bool, 0444);\nMODULE_PARM_DESC(itpm, \"Force iTPM workarounds (found on some Lenovo laptops)\");\n\nstatic bool force;\n#ifdef CONFIG_X86\nmodule_param(force, bool, 0444);\nMODULE_PARM_DESC(force, \"Force device probe rather than using ACPI entry\");\n#endif\n\n#if defined(CONFIG_PNP) && defined(CONFIG_ACPI)\nstatic int has_hid(struct acpi_device *dev, const char *hid)\n{\n\tstruct acpi_hardware_id *id;\n\n\tlist_for_each_entry(id, &dev->pnp.ids, list)\n\t\tif (!strcmp(hid, id->id))\n\t\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic inline int is_itpm(struct acpi_device *dev)\n{\n\tif (!dev)\n\t\treturn 0;\n\treturn has_hid(dev, \"INTC0102\");\n}\n#else\nstatic inline int is_itpm(struct acpi_device *dev)\n{\n\treturn 0;\n}\n#endif\n\n#if defined(CONFIG_ACPI)\n#define DEVICE_IS_TPM2 1\n\nstatic const struct acpi_device_id tpm_acpi_tbl[] = {\n\t{\"MSFT0101\", DEVICE_IS_TPM2},\n\t{},\n};\nMODULE_DEVICE_TABLE(acpi, tpm_acpi_tbl);\n\nstatic int check_acpi_tpm2(struct device *dev)\n{\n\tconst struct acpi_device_id *aid = acpi_match_device(tpm_acpi_tbl, dev);\n\tstruct acpi_table_tpm2 *tbl;\n\tacpi_status st;\n\tint ret = 0;\n\n\tif (!aid || aid->driver_data != DEVICE_IS_TPM2)\n\t\treturn 0;\n\n\t \n\tst = acpi_get_table(ACPI_SIG_TPM2, 1, (struct acpi_table_header **)&tbl);\n\tif (ACPI_FAILURE(st) || tbl->header.length < sizeof(*tbl)) {\n\t\tdev_err(dev, FW_BUG \"failed to get TPM2 ACPI table\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (tbl->start_method != ACPI_TPM2_MEMORY_MAPPED)\n\t\tret = -ENODEV;\n\n\tacpi_put_table((struct acpi_table_header *)tbl);\n\treturn ret;\n}\n#else\nstatic int check_acpi_tpm2(struct device *dev)\n{\n\treturn 0;\n}\n#endif\n\nstatic int tpm_tcg_read_bytes(struct tpm_tis_data *data, u32 addr, u16 len,\n\t\t\t      u8 *result, enum tpm_tis_io_mode io_mode)\n{\n\tstruct tpm_tis_tcg_phy *phy = to_tpm_tis_tcg_phy(data);\n\t__le16 result_le16;\n\t__le32 result_le32;\n\n\tswitch (io_mode) {\n\tcase TPM_TIS_PHYS_8:\n\t\twhile (len--)\n\t\t\t*result++ = ioread8(phy->iobase + addr);\n\t\tbreak;\n\tcase TPM_TIS_PHYS_16:\n\t\tresult_le16 = cpu_to_le16(ioread16(phy->iobase + addr));\n\t\tmemcpy(result, &result_le16, sizeof(u16));\n\t\tbreak;\n\tcase TPM_TIS_PHYS_32:\n\t\tresult_le32 = cpu_to_le32(ioread32(phy->iobase + addr));\n\t\tmemcpy(result, &result_le32, sizeof(u32));\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int tpm_tcg_write_bytes(struct tpm_tis_data *data, u32 addr, u16 len,\n\t\t\t       const u8 *value, enum tpm_tis_io_mode io_mode)\n{\n\tstruct tpm_tis_tcg_phy *phy = to_tpm_tis_tcg_phy(data);\n\n\tswitch (io_mode) {\n\tcase TPM_TIS_PHYS_8:\n\t\twhile (len--)\n\t\t\ttpm_tis_iowrite8(*value++, phy->iobase, addr);\n\t\tbreak;\n\tcase TPM_TIS_PHYS_16:\n\t\treturn -EINVAL;\n\tcase TPM_TIS_PHYS_32:\n\t\ttpm_tis_iowrite32(le32_to_cpu(*((__le32 *)value)), phy->iobase, addr);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct tpm_tis_phy_ops tpm_tcg = {\n\t.read_bytes = tpm_tcg_read_bytes,\n\t.write_bytes = tpm_tcg_write_bytes,\n};\n\nstatic int tpm_tis_init(struct device *dev, struct tpm_info *tpm_info)\n{\n\tstruct tpm_tis_tcg_phy *phy;\n\tint irq = -1;\n\tint rc;\n\n\trc = check_acpi_tpm2(dev);\n\tif (rc)\n\t\treturn rc;\n\n\tphy = devm_kzalloc(dev, sizeof(struct tpm_tis_tcg_phy), GFP_KERNEL);\n\tif (phy == NULL)\n\t\treturn -ENOMEM;\n\n\tphy->iobase = devm_ioremap_resource(dev, &tpm_info->res);\n\tif (IS_ERR(phy->iobase))\n\t\treturn PTR_ERR(phy->iobase);\n\n\tif (interrupts)\n\t\tirq = tpm_info->irq;\n\n\tif (itpm || is_itpm(ACPI_COMPANION(dev)))\n\t\tset_bit(TPM_TIS_ITPM_WORKAROUND, &phy->priv.flags);\n\n\treturn tpm_tis_core_init(dev, &phy->priv, irq, &tpm_tcg,\n\t\t\t\t ACPI_HANDLE(dev));\n}\n\nstatic SIMPLE_DEV_PM_OPS(tpm_tis_pm, tpm_pm_suspend, tpm_tis_resume);\n\nstatic int tpm_tis_pnp_init(struct pnp_dev *pnp_dev,\n\t\t\t    const struct pnp_device_id *pnp_id)\n{\n\tstruct tpm_info tpm_info = {};\n\tstruct resource *res;\n\n\tres = pnp_get_resource(pnp_dev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -ENODEV;\n\ttpm_info.res = *res;\n\n\tif (pnp_irq_valid(pnp_dev, 0))\n\t\ttpm_info.irq = pnp_irq(pnp_dev, 0);\n\telse\n\t\ttpm_info.irq = -1;\n\n\treturn tpm_tis_init(&pnp_dev->dev, &tpm_info);\n}\n\n \n\nstatic struct pnp_device_id tpm_pnp_tbl[] = {\n\t{\"PNP0C31\", 0},\t\t \n\t{\"ATM1200\", 0},\t\t \n\t{\"IFX0102\", 0},\t\t \n\t{\"BCM0101\", 0},\t\t \n\t{\"BCM0102\", 0},\t\t \n\t{\"NSC1200\", 0},\t\t \n\t{\"ICO0102\", 0},\t\t \n\t \n\t{\"\", 0},\t\t \n\t{\"\", 0}\t\t\t \n};\nMODULE_DEVICE_TABLE(pnp, tpm_pnp_tbl);\n\nstatic void tpm_tis_pnp_remove(struct pnp_dev *dev)\n{\n\tstruct tpm_chip *chip = pnp_get_drvdata(dev);\n\n\ttpm_chip_unregister(chip);\n\ttpm_tis_remove(chip);\n}\n\nstatic struct pnp_driver tis_pnp_driver = {\n\t.name = \"tpm_tis\",\n\t.id_table = tpm_pnp_tbl,\n\t.probe = tpm_tis_pnp_init,\n\t.remove = tpm_tis_pnp_remove,\n\t.driver\t= {\n\t\t.pm = &tpm_tis_pm,\n\t},\n};\n\n#define TIS_HID_USR_IDX (ARRAY_SIZE(tpm_pnp_tbl) - 2)\nmodule_param_string(hid, tpm_pnp_tbl[TIS_HID_USR_IDX].id,\n\t\t    sizeof(tpm_pnp_tbl[TIS_HID_USR_IDX].id), 0444);\nMODULE_PARM_DESC(hid, \"Set additional specific HID for this driver to probe\");\n\nstatic struct platform_device *force_pdev;\n\nstatic int tpm_tis_plat_probe(struct platform_device *pdev)\n{\n\tstruct tpm_info tpm_info = {};\n\tstruct resource *res;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (res == NULL) {\n\t\tdev_err(&pdev->dev, \"no memory resource defined\\n\");\n\t\treturn -ENODEV;\n\t}\n\ttpm_info.res = *res;\n\n\ttpm_info.irq = platform_get_irq_optional(pdev, 0);\n\tif (tpm_info.irq <= 0) {\n\t\tif (pdev != force_pdev)\n\t\t\ttpm_info.irq = -1;\n\t\telse\n\t\t\t \n\t\t\ttpm_info.irq = 0;\n\t}\n\n\treturn tpm_tis_init(&pdev->dev, &tpm_info);\n}\n\nstatic void tpm_tis_plat_remove(struct platform_device *pdev)\n{\n\tstruct tpm_chip *chip = dev_get_drvdata(&pdev->dev);\n\n\ttpm_chip_unregister(chip);\n\ttpm_tis_remove(chip);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id tis_of_platform_match[] = {\n\t{.compatible = \"tcg,tpm-tis-mmio\"},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, tis_of_platform_match);\n#endif\n\nstatic struct platform_driver tis_drv = {\n\t.probe = tpm_tis_plat_probe,\n\t.remove_new = tpm_tis_plat_remove,\n\t.driver = {\n\t\t.name\t\t= \"tpm_tis\",\n\t\t.pm\t\t= &tpm_tis_pm,\n\t\t.of_match_table = of_match_ptr(tis_of_platform_match),\n\t\t.acpi_match_table = ACPI_PTR(tpm_acpi_tbl),\n\t},\n};\n\nstatic int tpm_tis_force_device(void)\n{\n\tstruct platform_device *pdev;\n\tstatic const struct resource x86_resources[] = {\n\t\tDEFINE_RES_MEM(0xFED40000, TIS_MEM_LEN)\n\t};\n\n\tif (!force)\n\t\treturn 0;\n\n\t \n\tpdev = platform_device_register_simple(\"tpm_tis\", -1, x86_resources,\n\t\t\t\t\t       ARRAY_SIZE(x86_resources));\n\tif (IS_ERR(pdev))\n\t\treturn PTR_ERR(pdev);\n\tforce_pdev = pdev;\n\n\treturn 0;\n}\n\nstatic int __init init_tis(void)\n{\n\tint rc;\n\n\trc = tpm_tis_force_device();\n\tif (rc)\n\t\tgoto err_force;\n\n\trc = platform_driver_register(&tis_drv);\n\tif (rc)\n\t\tgoto err_platform;\n\n\n\tif (IS_ENABLED(CONFIG_PNP)) {\n\t\trc = pnp_register_driver(&tis_pnp_driver);\n\t\tif (rc)\n\t\t\tgoto err_pnp;\n\t}\n\n\treturn 0;\n\nerr_pnp:\n\tplatform_driver_unregister(&tis_drv);\nerr_platform:\n\tif (force_pdev)\n\t\tplatform_device_unregister(force_pdev);\nerr_force:\n\treturn rc;\n}\n\nstatic void __exit cleanup_tis(void)\n{\n\tpnp_unregister_driver(&tis_pnp_driver);\n\tplatform_driver_unregister(&tis_drv);\n\n\tif (force_pdev)\n\t\tplatform_device_unregister(force_pdev);\n}\n\nmodule_init(init_tis);\nmodule_exit(cleanup_tis);\nMODULE_AUTHOR(\"Leendert van Doorn (leendert@watson.ibm.com)\");\nMODULE_DESCRIPTION(\"TPM Driver\");\nMODULE_VERSION(\"2.0\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}