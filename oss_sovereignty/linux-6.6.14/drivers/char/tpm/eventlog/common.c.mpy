{
  "module_name": "common.c",
  "hash_id": "52cff991d1cb709c3540b9ee2a5200a9547b31993527bb9b38f7506bd7d40c78",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/tpm/eventlog/common.c",
  "human_readable_source": "\n \n\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/tpm_eventlog.h>\n\n#include \"../tpm.h\"\n#include \"common.h\"\n\nstatic int tpm_bios_measurements_open(struct inode *inode,\n\t\t\t\t\t    struct file *file)\n{\n\tint err;\n\tstruct seq_file *seq;\n\tstruct tpm_chip_seqops *chip_seqops;\n\tconst struct seq_operations *seqops;\n\tstruct tpm_chip *chip;\n\n\tinode_lock(inode);\n\tif (!inode->i_private) {\n\t\tinode_unlock(inode);\n\t\treturn -ENODEV;\n\t}\n\tchip_seqops = inode->i_private;\n\tseqops = chip_seqops->seqops;\n\tchip = chip_seqops->chip;\n\tget_device(&chip->dev);\n\tinode_unlock(inode);\n\n\t \n\terr = seq_open(file, seqops);\n\tif (!err) {\n\t\tseq = file->private_data;\n\t\tseq->private = chip;\n\t}\n\n\treturn err;\n}\n\nstatic int tpm_bios_measurements_release(struct inode *inode,\n\t\t\t\t\t struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\tstruct tpm_chip *chip = seq->private;\n\n\tput_device(&chip->dev);\n\n\treturn seq_release(inode, file);\n}\n\nstatic const struct file_operations tpm_bios_measurements_ops = {\n\t.owner = THIS_MODULE,\n\t.open = tpm_bios_measurements_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = tpm_bios_measurements_release,\n};\n\nstatic int tpm_read_log(struct tpm_chip *chip)\n{\n\tint rc;\n\n\tif (chip->log.bios_event_log != NULL) {\n\t\tdev_dbg(&chip->dev,\n\t\t\t\"%s: ERROR - event log already initialized\\n\",\n\t\t\t__func__);\n\t\treturn -EFAULT;\n\t}\n\n\trc = tpm_read_log_acpi(chip);\n\tif (rc != -ENODEV)\n\t\treturn rc;\n\n\trc = tpm_read_log_efi(chip);\n\tif (rc != -ENODEV)\n\t\treturn rc;\n\n\treturn tpm_read_log_of(chip);\n}\n\n \nvoid tpm_bios_log_setup(struct tpm_chip *chip)\n{\n\tconst char *name = dev_name(&chip->dev);\n\tunsigned int cnt;\n\tint log_version;\n\tint rc = 0;\n\n\tif (chip->flags & TPM_CHIP_FLAG_VIRTUAL)\n\t\treturn;\n\n\trc = tpm_read_log(chip);\n\tif (rc < 0)\n\t\treturn;\n\tlog_version = rc;\n\n\tcnt = 0;\n\tchip->bios_dir[cnt] = securityfs_create_dir(name, NULL);\n\t \n\tif (IS_ERR(chip->bios_dir[cnt]))\n\t\tgoto err;\n\tcnt++;\n\n\tchip->bin_log_seqops.chip = chip;\n\tif (log_version == EFI_TCG2_EVENT_LOG_FORMAT_TCG_2)\n\t\tchip->bin_log_seqops.seqops =\n\t\t\t&tpm2_binary_b_measurements_seqops;\n\telse\n\t\tchip->bin_log_seqops.seqops =\n\t\t\t&tpm1_binary_b_measurements_seqops;\n\n\n\tchip->bios_dir[cnt] =\n\t    securityfs_create_file(\"binary_bios_measurements\",\n\t\t\t\t   0440, chip->bios_dir[0],\n\t\t\t\t   (void *)&chip->bin_log_seqops,\n\t\t\t\t   &tpm_bios_measurements_ops);\n\tif (IS_ERR(chip->bios_dir[cnt]))\n\t\tgoto err;\n\tcnt++;\n\n\tif (!(chip->flags & TPM_CHIP_FLAG_TPM2)) {\n\n\t\tchip->ascii_log_seqops.chip = chip;\n\t\tchip->ascii_log_seqops.seqops =\n\t\t\t&tpm1_ascii_b_measurements_seqops;\n\n\t\tchip->bios_dir[cnt] =\n\t\t\tsecurityfs_create_file(\"ascii_bios_measurements\",\n\t\t\t\t\t       0440, chip->bios_dir[0],\n\t\t\t\t\t       (void *)&chip->ascii_log_seqops,\n\t\t\t\t\t       &tpm_bios_measurements_ops);\n\t\tif (IS_ERR(chip->bios_dir[cnt]))\n\t\t\tgoto err;\n\t\tcnt++;\n\t}\n\n\treturn;\n\nerr:\n\tchip->bios_dir[cnt] = NULL;\n\ttpm_bios_log_teardown(chip);\n\treturn;\n}\n\nvoid tpm_bios_log_teardown(struct tpm_chip *chip)\n{\n\tint i;\n\tstruct inode *inode;\n\n\t \n\tfor (i = (TPM_NUM_EVENT_LOG_FILES - 1); i >= 0; i--) {\n\t\tif (chip->bios_dir[i]) {\n\t\t\tinode = d_inode(chip->bios_dir[i]);\n\t\t\tinode_lock(inode);\n\t\t\tinode->i_private = NULL;\n\t\t\tinode_unlock(inode);\n\t\t\tsecurityfs_remove(chip->bios_dir[i]);\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}