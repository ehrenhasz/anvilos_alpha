{
  "module_name": "tpm2.c",
  "hash_id": "9b1000dac7b56f82a91ac896bbb2fb00219d09dff2de33222749dc7865e3fbb9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/tpm/eventlog/tpm2.c",
  "human_readable_source": "\n \n\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/tpm_eventlog.h>\n\n#include \"../tpm.h\"\n#include \"common.h\"\n\n \nstatic size_t calc_tpm2_event_size(struct tcg_pcr_event2_head *event,\n\t\t\t\t   struct tcg_pcr_event *event_header)\n{\n\treturn __calc_tpm2_event_size(event, event_header, false);\n}\n\nstatic void *tpm2_bios_measurements_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct tpm_chip *chip = m->private;\n\tstruct tpm_bios_log *log = &chip->log;\n\tvoid *addr = log->bios_event_log;\n\tvoid *limit = log->bios_event_log_end;\n\tstruct tcg_pcr_event *event_header;\n\tstruct tcg_pcr_event2_head *event;\n\tsize_t size;\n\tint i;\n\n\tevent_header = addr;\n\tsize = struct_size(event_header, event, event_header->event_size);\n\n\tif (*pos == 0) {\n\t\tif (addr + size < limit) {\n\t\t\tif ((event_header->event_type == 0) &&\n\t\t\t    (event_header->event_size == 0))\n\t\t\t\treturn NULL;\n\t\t\treturn SEQ_START_TOKEN;\n\t\t}\n\t}\n\n\tif (*pos > 0) {\n\t\taddr += size;\n\t\tevent = addr;\n\t\tsize = calc_tpm2_event_size(event, event_header);\n\t\tif ((addr + size >=  limit) || (size == 0))\n\t\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < (*pos - 1); i++) {\n\t\tevent = addr;\n\t\tsize = calc_tpm2_event_size(event, event_header);\n\n\t\tif ((addr + size >= limit) || (size == 0))\n\t\t\treturn NULL;\n\t\taddr += size;\n\t}\n\n\treturn addr;\n}\n\nstatic void *tpm2_bios_measurements_next(struct seq_file *m, void *v,\n\t\t\t\t\t loff_t *pos)\n{\n\tstruct tcg_pcr_event *event_header;\n\tstruct tcg_pcr_event2_head *event;\n\tstruct tpm_chip *chip = m->private;\n\tstruct tpm_bios_log *log = &chip->log;\n\tvoid *limit = log->bios_event_log_end;\n\tsize_t event_size;\n\tvoid *marker;\n\n\t(*pos)++;\n\tevent_header = log->bios_event_log;\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tevent_size = struct_size(event_header, event,\n\t\t\t\t\t event_header->event_size);\n\t\tmarker = event_header;\n\t} else {\n\t\tevent = v;\n\t\tevent_size = calc_tpm2_event_size(event, event_header);\n\t\tif (event_size == 0)\n\t\t\treturn NULL;\n\t\tmarker = event;\n\t}\n\n\tmarker = marker + event_size;\n\tif (marker >= limit)\n\t\treturn NULL;\n\tv = marker;\n\tevent = v;\n\n\tevent_size = calc_tpm2_event_size(event, event_header);\n\tif (((v + event_size) >= limit) || (event_size == 0))\n\t\treturn NULL;\n\n\treturn v;\n}\n\nstatic void tpm2_bios_measurements_stop(struct seq_file *m, void *v)\n{\n}\n\nstatic int tpm2_binary_bios_measurements_show(struct seq_file *m, void *v)\n{\n\tstruct tpm_chip *chip = m->private;\n\tstruct tpm_bios_log *log = &chip->log;\n\tstruct tcg_pcr_event *event_header = log->bios_event_log;\n\tstruct tcg_pcr_event2_head *event = v;\n\tvoid *temp_ptr;\n\tsize_t size;\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tsize = struct_size(event_header, event,\n\t\t\t\t   event_header->event_size);\n\t\ttemp_ptr = event_header;\n\n\t\tif (size > 0)\n\t\t\tseq_write(m, temp_ptr, size);\n\t} else {\n\t\tsize = calc_tpm2_event_size(event, event_header);\n\t\ttemp_ptr = event;\n\t\tif (size > 0)\n\t\t\tseq_write(m, temp_ptr, size);\n\t}\n\n\treturn 0;\n}\n\nconst struct seq_operations tpm2_binary_b_measurements_seqops = {\n\t.start = tpm2_bios_measurements_start,\n\t.next = tpm2_bios_measurements_next,\n\t.stop = tpm2_bios_measurements_stop,\n\t.show = tpm2_binary_bios_measurements_show,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}