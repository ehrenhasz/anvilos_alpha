{
  "module_name": "acpi.c",
  "hash_id": "e083a953e379bd73846c54946321926c663400391c011acf275c556542189cec",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/tpm/eventlog/acpi.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/acpi.h>\n#include <linux/tpm_eventlog.h>\n\n#include \"../tpm.h\"\n#include \"common.h\"\n\nstruct acpi_tcpa {\n\tstruct acpi_table_header hdr;\n\tu16 platform_class;\n\tunion {\n\t\tstruct client_hdr {\n\t\t\tu32 log_max_len __packed;\n\t\t\tu64 log_start_addr __packed;\n\t\t} client;\n\t\tstruct server_hdr {\n\t\t\tu16 reserved;\n\t\t\tu64 log_max_len __packed;\n\t\t\tu64 log_start_addr __packed;\n\t\t} server;\n\t};\n};\n\n \nstatic bool tpm_is_tpm2_log(void *bios_event_log, u64 len)\n{\n\tstruct tcg_efi_specid_event_head *efispecid;\n\tstruct tcg_pcr_event *event_header;\n\tint n;\n\n\tif (len < sizeof(*event_header))\n\t\treturn false;\n\tlen -= sizeof(*event_header);\n\tevent_header = bios_event_log;\n\n\tif (len < sizeof(*efispecid))\n\t\treturn false;\n\tefispecid = (struct tcg_efi_specid_event_head *)event_header->event;\n\n\tn = memcmp(efispecid->signature, TCG_SPECID_SIG,\n\t\t   sizeof(TCG_SPECID_SIG));\n\treturn n == 0;\n}\n\n \nint tpm_read_log_acpi(struct tpm_chip *chip)\n{\n\tstruct acpi_tcpa *buff;\n\tacpi_status status;\n\tvoid __iomem *virt;\n\tu64 len, start;\n\tstruct tpm_bios_log *log;\n\tstruct acpi_table_tpm2 *tbl;\n\tstruct acpi_tpm2_phy *tpm2_phy;\n\tint format;\n\tint ret;\n\n\tlog = &chip->log;\n\n\t \n\tif (!chip->acpi_dev_handle)\n\t\treturn -ENODEV;\n\n\tif (chip->flags & TPM_CHIP_FLAG_TPM2) {\n\t\tstatus = acpi_get_table(\"TPM2\", 1,\n\t\t\t\t\t(struct acpi_table_header **)&tbl);\n\t\tif (ACPI_FAILURE(status))\n\t\t\treturn -ENODEV;\n\n\t\tif (tbl->header.length <\n\t\t\t\tsizeof(*tbl) + sizeof(struct acpi_tpm2_phy)) {\n\t\t\tacpi_put_table((struct acpi_table_header *)tbl);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\ttpm2_phy = (void *)tbl + sizeof(*tbl);\n\t\tlen = tpm2_phy->log_area_minimum_length;\n\n\t\tstart = tpm2_phy->log_area_start_address;\n\t\tif (!start || !len) {\n\t\t\tacpi_put_table((struct acpi_table_header *)tbl);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tacpi_put_table((struct acpi_table_header *)tbl);\n\t\tformat = EFI_TCG2_EVENT_LOG_FORMAT_TCG_2;\n\t} else {\n\t\t \n\t\tstatus = acpi_get_table(ACPI_SIG_TCPA, 1,\n\t\t\t\t\t(struct acpi_table_header **)&buff);\n\t\tif (ACPI_FAILURE(status))\n\t\t\treturn -ENODEV;\n\n\t\tswitch (buff->platform_class) {\n\t\tcase BIOS_SERVER:\n\t\t\tlen = buff->server.log_max_len;\n\t\t\tstart = buff->server.log_start_addr;\n\t\t\tbreak;\n\t\tcase BIOS_CLIENT:\n\t\tdefault:\n\t\t\tlen = buff->client.log_max_len;\n\t\t\tstart = buff->client.log_start_addr;\n\t\t\tbreak;\n\t\t}\n\n\t\tacpi_put_table((struct acpi_table_header *)buff);\n\t\tformat = EFI_TCG2_EVENT_LOG_FORMAT_TCG_1_2;\n\t}\n\n\tif (!len) {\n\t\tdev_warn(&chip->dev, \"%s: TCPA log area empty\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\n\t \n\tlog->bios_event_log = devm_kmalloc(&chip->dev, len, GFP_KERNEL);\n\tif (!log->bios_event_log)\n\t\treturn -ENOMEM;\n\n\tlog->bios_event_log_end = log->bios_event_log + len;\n\n\tret = -EIO;\n\tvirt = acpi_os_map_iomem(start, len);\n\tif (!virt) {\n\t\tdev_warn(&chip->dev, \"%s: Failed to map ACPI memory\\n\", __func__);\n\t\t \n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\tmemcpy_fromio(log->bios_event_log, virt, len);\n\n\tacpi_os_unmap_iomem(virt, len);\n\n\tif (chip->flags & TPM_CHIP_FLAG_TPM2 &&\n\t    !tpm_is_tpm2_log(log->bios_event_log, len)) {\n\t\t \n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\treturn format;\n\nerr:\n\tdevm_kfree(&chip->dev, log->bios_event_log);\n\tlog->bios_event_log = NULL;\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}