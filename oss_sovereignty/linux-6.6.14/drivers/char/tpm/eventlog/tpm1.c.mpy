{
  "module_name": "tpm1.c",
  "hash_id": "59ebe85e370ef0cd2c06e5407bdafeb98671e1f07d7a8668c339d368459b5f42",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/tpm/eventlog/tpm1.c",
  "human_readable_source": "\n \n\n#include <linux/seq_file.h>\n#include <linux/efi.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/tpm_eventlog.h>\n\n#include \"../tpm.h\"\n#include \"common.h\"\n\n\nstatic const char* tcpa_event_type_strings[] = {\n\t\"PREBOOT\",\n\t\"POST CODE\",\n\t\"\",\n\t\"NO ACTION\",\n\t\"SEPARATOR\",\n\t\"ACTION\",\n\t\"EVENT TAG\",\n\t\"S-CRTM Contents\",\n\t\"S-CRTM Version\",\n\t\"CPU Microcode\",\n\t\"Platform Config Flags\",\n\t\"Table of Devices\",\n\t\"Compact Hash\",\n\t\"IPL\",\n\t\"IPL Partition Data\",\n\t\"Non-Host Code\",\n\t\"Non-Host Config\",\n\t\"Non-Host Info\"\n};\n\nstatic const char* tcpa_pc_event_id_strings[] = {\n\t\"\",\n\t\"SMBIOS\",\n\t\"BIS Certificate\",\n\t\"POST BIOS \",\n\t\"ESCD \",\n\t\"CMOS\",\n\t\"NVRAM\",\n\t\"Option ROM\",\n\t\"Option ROM config\",\n\t\"\",\n\t\"Option ROM microcode \",\n\t\"S-CRTM Version\",\n\t\"S-CRTM Contents \",\n\t\"POST Contents \",\n\t\"Table of Devices\",\n};\n\n \nstatic void *tpm1_bios_measurements_start(struct seq_file *m, loff_t *pos)\n{\n\tloff_t i = 0;\n\tstruct tpm_chip *chip = m->private;\n\tstruct tpm_bios_log *log = &chip->log;\n\tvoid *addr = log->bios_event_log;\n\tvoid *limit = log->bios_event_log_end;\n\tstruct tcpa_event *event;\n\tu32 converted_event_size;\n\tu32 converted_event_type;\n\n\t \n\tdo {\n\t\tevent = addr;\n\n\t\t \n\t\tif (addr + sizeof(struct tcpa_event) > limit)\n\t\t\treturn NULL;\n\n\t\tconverted_event_size =\n\t\t    do_endian_conversion(event->event_size);\n\t\tconverted_event_type =\n\t\t    do_endian_conversion(event->event_type);\n\n\t\tif (((converted_event_type == 0) && (converted_event_size == 0))\n\t\t    || ((addr + sizeof(struct tcpa_event) + converted_event_size)\n\t\t\t> limit))\n\t\t\treturn NULL;\n\n\t\tif (i++ == *pos)\n\t\t\tbreak;\n\n\t\taddr += (sizeof(struct tcpa_event) + converted_event_size);\n\t} while (1);\n\n\treturn addr;\n}\n\nstatic void *tpm1_bios_measurements_next(struct seq_file *m, void *v,\n\t\t\t\t\tloff_t *pos)\n{\n\tstruct tcpa_event *event = v;\n\tstruct tpm_chip *chip = m->private;\n\tstruct tpm_bios_log *log = &chip->log;\n\tvoid *limit = log->bios_event_log_end;\n\tu32 converted_event_size;\n\tu32 converted_event_type;\n\n\t(*pos)++;\n\tconverted_event_size = do_endian_conversion(event->event_size);\n\n\tv += sizeof(struct tcpa_event) + converted_event_size;\n\n\t \n\tif ((v + sizeof(struct tcpa_event)) > limit)\n\t\treturn NULL;\n\n\tevent = v;\n\n\tconverted_event_size = do_endian_conversion(event->event_size);\n\tconverted_event_type = do_endian_conversion(event->event_type);\n\n\tif (((converted_event_type == 0) && (converted_event_size == 0)) ||\n\t    ((v + sizeof(struct tcpa_event) + converted_event_size) > limit))\n\t\treturn NULL;\n\n\treturn v;\n}\n\nstatic void tpm1_bios_measurements_stop(struct seq_file *m, void *v)\n{\n}\n\nstatic int get_event_name(char *dest, struct tcpa_event *event,\n\t\t\tunsigned char * event_entry)\n{\n\tconst char *name = \"\";\n\t \n\tchar data[41] = \"\";\n\tint i, n_len = 0, d_len = 0;\n\tstruct tcpa_pc_event *pc_event;\n\n\tswitch (do_endian_conversion(event->event_type)) {\n\tcase PREBOOT:\n\tcase POST_CODE:\n\tcase UNUSED:\n\tcase NO_ACTION:\n\tcase SCRTM_CONTENTS:\n\tcase SCRTM_VERSION:\n\tcase CPU_MICROCODE:\n\tcase PLATFORM_CONFIG_FLAGS:\n\tcase TABLE_OF_DEVICES:\n\tcase COMPACT_HASH:\n\tcase IPL:\n\tcase IPL_PARTITION_DATA:\n\tcase NONHOST_CODE:\n\tcase NONHOST_CONFIG:\n\tcase NONHOST_INFO:\n\t\tname = tcpa_event_type_strings[do_endian_conversion\n\t\t\t\t\t\t(event->event_type)];\n\t\tn_len = strlen(name);\n\t\tbreak;\n\tcase SEPARATOR:\n\tcase ACTION:\n\t\tif (MAX_TEXT_EVENT >\n\t\t    do_endian_conversion(event->event_size)) {\n\t\t\tname = event_entry;\n\t\t\tn_len = do_endian_conversion(event->event_size);\n\t\t}\n\t\tbreak;\n\tcase EVENT_TAG:\n\t\tpc_event = (struct tcpa_pc_event *)event_entry;\n\n\t\t \n\n\t\tswitch (do_endian_conversion(pc_event->event_id)) {\n\t\tcase SMBIOS:\n\t\tcase BIS_CERT:\n\t\tcase CMOS:\n\t\tcase NVRAM:\n\t\tcase OPTION_ROM_EXEC:\n\t\tcase OPTION_ROM_CONFIG:\n\t\tcase S_CRTM_VERSION:\n\t\t\tname = tcpa_pc_event_id_strings[do_endian_conversion\n\t\t\t\t\t\t\t(pc_event->event_id)];\n\t\t\tn_len = strlen(name);\n\t\t\tbreak;\n\t\t \n\t\tcase POST_BIOS_ROM:\n\t\tcase ESCD:\n\t\tcase OPTION_ROM_MICROCODE:\n\t\tcase S_CRTM_CONTENTS:\n\t\tcase POST_CONTENTS:\n\t\t\tname = tcpa_pc_event_id_strings[do_endian_conversion\n\t\t\t\t\t\t\t(pc_event->event_id)];\n\t\t\tn_len = strlen(name);\n\t\t\tfor (i = 0; i < 20; i++)\n\t\t\t\td_len += sprintf(&data[2*i], \"%02x\",\n\t\t\t\t\t\tpc_event->event_data[i]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn snprintf(dest, MAX_TEXT_EVENT, \"[%.*s%.*s]\",\n\t\t\tn_len, name, d_len, data);\n\n}\n\nstatic int tpm1_binary_bios_measurements_show(struct seq_file *m, void *v)\n{\n\tstruct tcpa_event *event = v;\n\tstruct tcpa_event temp_event;\n\tchar *temp_ptr;\n\tint i;\n\n\tmemcpy(&temp_event, event, sizeof(struct tcpa_event));\n\n\t \n\ttemp_event.pcr_index = do_endian_conversion(event->pcr_index);\n\ttemp_event.event_type = do_endian_conversion(event->event_type);\n\ttemp_event.event_size = do_endian_conversion(event->event_size);\n\n\ttemp_ptr = (char *) &temp_event;\n\n\tfor (i = 0; i < (sizeof(struct tcpa_event) - 1) ; i++)\n\t\tseq_putc(m, temp_ptr[i]);\n\n\ttemp_ptr = (char *) v;\n\n\tfor (i = (sizeof(struct tcpa_event) - 1);\n\t     i < (sizeof(struct tcpa_event) + temp_event.event_size); i++)\n\t\tseq_putc(m, temp_ptr[i]);\n\n\treturn 0;\n\n}\n\nstatic int tpm1_ascii_bios_measurements_show(struct seq_file *m, void *v)\n{\n\tchar *eventname;\n\tstruct tcpa_event *event = v;\n\tunsigned char *event_entry =\n\t    (unsigned char *)(v + sizeof(struct tcpa_event));\n\n\teventname = kmalloc(MAX_TEXT_EVENT, GFP_KERNEL);\n\tif (!eventname) {\n\t\tprintk(KERN_ERR \"%s: ERROR - No Memory for event name\\n \",\n\t\t       __func__);\n\t\treturn -EFAULT;\n\t}\n\n\t \n\tseq_printf(m, \"%2d \", do_endian_conversion(event->pcr_index));\n\n\t \n\tseq_printf(m, \"%20phN\", event->pcr_value);\n\n\t \n\tseq_printf(m, \" %02x\", do_endian_conversion(event->event_type));\n\n\tget_event_name(eventname, event, event_entry);\n\n\t \n\tseq_printf(m, \" %s\\n\", eventname);\n\n\tkfree(eventname);\n\treturn 0;\n}\n\nconst struct seq_operations tpm1_ascii_b_measurements_seqops = {\n\t.start = tpm1_bios_measurements_start,\n\t.next = tpm1_bios_measurements_next,\n\t.stop = tpm1_bios_measurements_stop,\n\t.show = tpm1_ascii_bios_measurements_show,\n};\n\nconst struct seq_operations tpm1_binary_b_measurements_seqops = {\n\t.start = tpm1_bios_measurements_start,\n\t.next = tpm1_bios_measurements_next,\n\t.stop = tpm1_bios_measurements_stop,\n\t.show = tpm1_binary_bios_measurements_show,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}