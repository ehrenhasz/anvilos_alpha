{
  "module_name": "tpm_tis_synquacer.c",
  "hash_id": "6c0747d647f0b703aff88082f1cda08830a392a8f4a5febda425a35824cad8be",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/tpm/tpm_tis_synquacer.c",
  "human_readable_source": "\n \n#include <linux/acpi.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/kernel.h>\n#include \"tpm.h\"\n#include \"tpm_tis_core.h\"\n\n \nstruct tpm_tis_synquacer_info {\n\tstruct resource res;\n\tint irq;\n};\n\nstruct tpm_tis_synquacer_phy {\n\tstruct tpm_tis_data priv;\n\tvoid __iomem *iobase;\n};\n\nstatic inline struct tpm_tis_synquacer_phy *to_tpm_tis_tcg_phy(struct tpm_tis_data *data)\n{\n\treturn container_of(data, struct tpm_tis_synquacer_phy, priv);\n}\n\nstatic int tpm_tis_synquacer_read_bytes(struct tpm_tis_data *data, u32 addr,\n\t\t\t\t\tu16 len, u8 *result,\n\t\t\t\t\tenum tpm_tis_io_mode io_mode)\n{\n\tstruct tpm_tis_synquacer_phy *phy = to_tpm_tis_tcg_phy(data);\n\tswitch (io_mode) {\n\tcase TPM_TIS_PHYS_8:\n\t\twhile (len--)\n\t\t\t*result++ = ioread8(phy->iobase + addr);\n\t\tbreak;\n\tcase TPM_TIS_PHYS_16:\n\t\tresult[1] = ioread8(phy->iobase + addr + 1);\n\t\tresult[0] = ioread8(phy->iobase + addr);\n\t\tbreak;\n\tcase TPM_TIS_PHYS_32:\n\t\tresult[3] = ioread8(phy->iobase + addr + 3);\n\t\tresult[2] = ioread8(phy->iobase + addr + 2);\n\t\tresult[1] = ioread8(phy->iobase + addr + 1);\n\t\tresult[0] = ioread8(phy->iobase + addr);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int tpm_tis_synquacer_write_bytes(struct tpm_tis_data *data, u32 addr,\n\t\t\t\t\t u16 len, const u8 *value,\n\t\t\t\t\t enum tpm_tis_io_mode io_mode)\n{\n\tstruct tpm_tis_synquacer_phy *phy = to_tpm_tis_tcg_phy(data);\n\tswitch (io_mode) {\n\tcase TPM_TIS_PHYS_8:\n\t\twhile (len--)\n\t\t\tiowrite8(*value++, phy->iobase + addr);\n\t\tbreak;\n\tcase TPM_TIS_PHYS_16:\n\t\treturn -EINVAL;\n\tcase TPM_TIS_PHYS_32:\n\t\t \n\t\tiowrite8(value[3], phy->iobase + addr + 3);\n\t\tiowrite8(value[2], phy->iobase + addr + 2);\n\t\tiowrite8(value[1], phy->iobase + addr + 1);\n\t\tiowrite8(value[0], phy->iobase + addr);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct tpm_tis_phy_ops tpm_tcg_bw = {\n\t.read_bytes\t= tpm_tis_synquacer_read_bytes,\n\t.write_bytes\t= tpm_tis_synquacer_write_bytes,\n};\n\nstatic int tpm_tis_synquacer_init(struct device *dev,\n\t\t\t\t  struct tpm_tis_synquacer_info *tpm_info)\n{\n\tstruct tpm_tis_synquacer_phy *phy;\n\n\tphy = devm_kzalloc(dev, sizeof(struct tpm_tis_synquacer_phy), GFP_KERNEL);\n\tif (phy == NULL)\n\t\treturn -ENOMEM;\n\n\tphy->iobase = devm_ioremap_resource(dev, &tpm_info->res);\n\tif (IS_ERR(phy->iobase))\n\t\treturn PTR_ERR(phy->iobase);\n\n\treturn tpm_tis_core_init(dev, &phy->priv, tpm_info->irq, &tpm_tcg_bw,\n\t\t\t\t ACPI_HANDLE(dev));\n}\n\nstatic SIMPLE_DEV_PM_OPS(tpm_tis_synquacer_pm, tpm_pm_suspend, tpm_tis_resume);\n\nstatic int tpm_tis_synquacer_probe(struct platform_device *pdev)\n{\n\tstruct tpm_tis_synquacer_info tpm_info = {};\n\tstruct resource *res;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (res == NULL) {\n\t\tdev_err(&pdev->dev, \"no memory resource defined\\n\");\n\t\treturn -ENODEV;\n\t}\n\ttpm_info.res = *res;\n\n\ttpm_info.irq = -1;\n\n\treturn tpm_tis_synquacer_init(&pdev->dev, &tpm_info);\n}\n\nstatic void tpm_tis_synquacer_remove(struct platform_device *pdev)\n{\n\tstruct tpm_chip *chip = dev_get_drvdata(&pdev->dev);\n\n\ttpm_chip_unregister(chip);\n\ttpm_tis_remove(chip);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id tis_synquacer_of_platform_match[] = {\n\t{.compatible = \"socionext,synquacer-tpm-mmio\"},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, tis_synquacer_of_platform_match);\n#endif\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id tpm_synquacer_acpi_tbl[] = {\n\t{ \"SCX0009\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(acpi, tpm_synquacer_acpi_tbl);\n#endif\n\nstatic struct platform_driver tis_synquacer_drv = {\n\t.probe = tpm_tis_synquacer_probe,\n\t.remove_new = tpm_tis_synquacer_remove,\n\t.driver = {\n\t\t.name\t\t= \"tpm_tis_synquacer\",\n\t\t.pm\t\t= &tpm_tis_synquacer_pm,\n\t\t.of_match_table = of_match_ptr(tis_synquacer_of_platform_match),\n\t\t.acpi_match_table = ACPI_PTR(tpm_synquacer_acpi_tbl),\n\t},\n};\n\nmodule_platform_driver(tis_synquacer_drv);\n\nMODULE_DESCRIPTION(\"TPM MMIO Driver for Socionext SynQuacer platform\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}