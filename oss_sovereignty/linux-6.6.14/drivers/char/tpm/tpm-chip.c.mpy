{
  "module_name": "tpm-chip.c",
  "hash_id": "99186beb442197e1c24e71d15bcd192e950fdc92794042c05e1f658a7150cf41",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/tpm/tpm-chip.c",
  "human_readable_source": "\n \n\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/freezer.h>\n#include <linux/major.h>\n#include <linux/tpm_eventlog.h>\n#include <linux/hw_random.h>\n#include \"tpm.h\"\n\nDEFINE_IDR(dev_nums_idr);\nstatic DEFINE_MUTEX(idr_lock);\n\nconst struct class tpm_class = {\n\t.name = \"tpm\",\n\t.shutdown_pre = tpm_class_shutdown,\n};\nconst struct class tpmrm_class = {\n\t.name = \"tpmrm\",\n};\ndev_t tpm_devt;\n\nstatic int tpm_request_locality(struct tpm_chip *chip)\n{\n\tint rc;\n\n\tif (!chip->ops->request_locality)\n\t\treturn 0;\n\n\trc = chip->ops->request_locality(chip, 0);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tchip->locality = rc;\n\treturn 0;\n}\n\nstatic void tpm_relinquish_locality(struct tpm_chip *chip)\n{\n\tint rc;\n\n\tif (!chip->ops->relinquish_locality)\n\t\treturn;\n\n\trc = chip->ops->relinquish_locality(chip, chip->locality);\n\tif (rc)\n\t\tdev_err(&chip->dev, \"%s: : error %d\\n\", __func__, rc);\n\n\tchip->locality = -1;\n}\n\nstatic int tpm_cmd_ready(struct tpm_chip *chip)\n{\n\tif (!chip->ops->cmd_ready)\n\t\treturn 0;\n\n\treturn chip->ops->cmd_ready(chip);\n}\n\nstatic int tpm_go_idle(struct tpm_chip *chip)\n{\n\tif (!chip->ops->go_idle)\n\t\treturn 0;\n\n\treturn chip->ops->go_idle(chip);\n}\n\nstatic void tpm_clk_enable(struct tpm_chip *chip)\n{\n\tif (chip->ops->clk_enable)\n\t\tchip->ops->clk_enable(chip, true);\n}\n\nstatic void tpm_clk_disable(struct tpm_chip *chip)\n{\n\tif (chip->ops->clk_enable)\n\t\tchip->ops->clk_enable(chip, false);\n}\n\n \nint tpm_chip_start(struct tpm_chip *chip)\n{\n\tint ret;\n\n\ttpm_clk_enable(chip);\n\n\tif (chip->locality == -1) {\n\t\tret = tpm_request_locality(chip);\n\t\tif (ret) {\n\t\t\ttpm_clk_disable(chip);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = tpm_cmd_ready(chip);\n\tif (ret) {\n\t\ttpm_relinquish_locality(chip);\n\t\ttpm_clk_disable(chip);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(tpm_chip_start);\n\n \nvoid tpm_chip_stop(struct tpm_chip *chip)\n{\n\ttpm_go_idle(chip);\n\ttpm_relinquish_locality(chip);\n\ttpm_clk_disable(chip);\n}\nEXPORT_SYMBOL_GPL(tpm_chip_stop);\n\n \nint tpm_try_get_ops(struct tpm_chip *chip)\n{\n\tint rc = -EIO;\n\n\tget_device(&chip->dev);\n\n\tdown_read(&chip->ops_sem);\n\tif (!chip->ops)\n\t\tgoto out_ops;\n\n\tmutex_lock(&chip->tpm_mutex);\n\trc = tpm_chip_start(chip);\n\tif (rc)\n\t\tgoto out_lock;\n\n\treturn 0;\nout_lock:\n\tmutex_unlock(&chip->tpm_mutex);\nout_ops:\n\tup_read(&chip->ops_sem);\n\tput_device(&chip->dev);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(tpm_try_get_ops);\n\n \nvoid tpm_put_ops(struct tpm_chip *chip)\n{\n\ttpm_chip_stop(chip);\n\tmutex_unlock(&chip->tpm_mutex);\n\tup_read(&chip->ops_sem);\n\tput_device(&chip->dev);\n}\nEXPORT_SYMBOL_GPL(tpm_put_ops);\n\n \nstruct tpm_chip *tpm_default_chip(void)\n{\n\tstruct tpm_chip *chip, *res = NULL;\n\tint chip_num = 0;\n\tint chip_prev;\n\n\tmutex_lock(&idr_lock);\n\n\tdo {\n\t\tchip_prev = chip_num;\n\t\tchip = idr_get_next(&dev_nums_idr, &chip_num);\n\t\tif (chip) {\n\t\t\tget_device(&chip->dev);\n\t\t\tres = chip;\n\t\t\tbreak;\n\t\t}\n\t} while (chip_prev != chip_num);\n\n\tmutex_unlock(&idr_lock);\n\n\treturn res;\n}\nEXPORT_SYMBOL_GPL(tpm_default_chip);\n\n \nstruct tpm_chip *tpm_find_get_ops(struct tpm_chip *chip)\n{\n\tint rc;\n\n\tif (chip) {\n\t\tif (!tpm_try_get_ops(chip))\n\t\t\treturn chip;\n\t\treturn NULL;\n\t}\n\n\tchip = tpm_default_chip();\n\tif (!chip)\n\t\treturn NULL;\n\trc = tpm_try_get_ops(chip);\n\t \n\tput_device(&chip->dev);\n\tif (rc)\n\t\treturn NULL;\n\treturn chip;\n}\n\n \nstatic void tpm_dev_release(struct device *dev)\n{\n\tstruct tpm_chip *chip = container_of(dev, struct tpm_chip, dev);\n\n\tmutex_lock(&idr_lock);\n\tidr_remove(&dev_nums_idr, chip->dev_num);\n\tmutex_unlock(&idr_lock);\n\n\tkfree(chip->work_space.context_buf);\n\tkfree(chip->work_space.session_buf);\n\tkfree(chip->allocated_banks);\n\tkfree(chip);\n}\n\n \nint tpm_class_shutdown(struct device *dev)\n{\n\tstruct tpm_chip *chip = container_of(dev, struct tpm_chip, dev);\n\n\tdown_write(&chip->ops_sem);\n\tif (chip->flags & TPM_CHIP_FLAG_TPM2) {\n\t\tif (!tpm_chip_start(chip)) {\n\t\t\ttpm2_shutdown(chip, TPM2_SU_CLEAR);\n\t\t\ttpm_chip_stop(chip);\n\t\t}\n\t}\n\tchip->ops = NULL;\n\tup_write(&chip->ops_sem);\n\n\treturn 0;\n}\n\n \nstruct tpm_chip *tpm_chip_alloc(struct device *pdev,\n\t\t\t\tconst struct tpm_class_ops *ops)\n{\n\tstruct tpm_chip *chip;\n\tint rc;\n\n\tchip = kzalloc(sizeof(*chip), GFP_KERNEL);\n\tif (chip == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&chip->tpm_mutex);\n\tinit_rwsem(&chip->ops_sem);\n\n\tchip->ops = ops;\n\n\tmutex_lock(&idr_lock);\n\trc = idr_alloc(&dev_nums_idr, NULL, 0, TPM_NUM_DEVICES, GFP_KERNEL);\n\tmutex_unlock(&idr_lock);\n\tif (rc < 0) {\n\t\tdev_err(pdev, \"No available tpm device numbers\\n\");\n\t\tkfree(chip);\n\t\treturn ERR_PTR(rc);\n\t}\n\tchip->dev_num = rc;\n\n\tdevice_initialize(&chip->dev);\n\n\tchip->dev.class = &tpm_class;\n\tchip->dev.release = tpm_dev_release;\n\tchip->dev.parent = pdev;\n\tchip->dev.groups = chip->groups;\n\n\tif (chip->dev_num == 0)\n\t\tchip->dev.devt = MKDEV(MISC_MAJOR, TPM_MINOR);\n\telse\n\t\tchip->dev.devt = MKDEV(MAJOR(tpm_devt), chip->dev_num);\n\n\trc = dev_set_name(&chip->dev, \"tpm%d\", chip->dev_num);\n\tif (rc)\n\t\tgoto out;\n\n\tif (!pdev)\n\t\tchip->flags |= TPM_CHIP_FLAG_VIRTUAL;\n\n\tcdev_init(&chip->cdev, &tpm_fops);\n\tchip->cdev.owner = THIS_MODULE;\n\n\trc = tpm2_init_space(&chip->work_space, TPM2_SPACE_BUFFER_SIZE);\n\tif (rc) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tchip->locality = -1;\n\treturn chip;\n\nout:\n\tput_device(&chip->dev);\n\treturn ERR_PTR(rc);\n}\nEXPORT_SYMBOL_GPL(tpm_chip_alloc);\n\nstatic void tpm_put_device(void *dev)\n{\n\tput_device(dev);\n}\n\n \nstruct tpm_chip *tpmm_chip_alloc(struct device *pdev,\n\t\t\t\t const struct tpm_class_ops *ops)\n{\n\tstruct tpm_chip *chip;\n\tint rc;\n\n\tchip = tpm_chip_alloc(pdev, ops);\n\tif (IS_ERR(chip))\n\t\treturn chip;\n\n\trc = devm_add_action_or_reset(pdev,\n\t\t\t\t      tpm_put_device,\n\t\t\t\t      &chip->dev);\n\tif (rc)\n\t\treturn ERR_PTR(rc);\n\n\tdev_set_drvdata(pdev, chip);\n\n\treturn chip;\n}\nEXPORT_SYMBOL_GPL(tpmm_chip_alloc);\n\nstatic int tpm_add_char_device(struct tpm_chip *chip)\n{\n\tint rc;\n\n\trc = cdev_device_add(&chip->cdev, &chip->dev);\n\tif (rc) {\n\t\tdev_err(&chip->dev,\n\t\t\t\"unable to cdev_device_add() %s, major %d, minor %d, err=%d\\n\",\n\t\t\tdev_name(&chip->dev), MAJOR(chip->dev.devt),\n\t\t\tMINOR(chip->dev.devt), rc);\n\t\treturn rc;\n\t}\n\n\tif (chip->flags & TPM_CHIP_FLAG_TPM2 && !tpm_is_firmware_upgrade(chip)) {\n\t\trc = tpm_devs_add(chip);\n\t\tif (rc)\n\t\t\tgoto err_del_cdev;\n\t}\n\n\t \n\tmutex_lock(&idr_lock);\n\tidr_replace(&dev_nums_idr, chip, chip->dev_num);\n\tmutex_unlock(&idr_lock);\n\n\treturn 0;\n\nerr_del_cdev:\n\tcdev_device_del(&chip->cdev, &chip->dev);\n\treturn rc;\n}\n\nstatic void tpm_del_char_device(struct tpm_chip *chip)\n{\n\tcdev_device_del(&chip->cdev, &chip->dev);\n\n\t \n\tmutex_lock(&idr_lock);\n\tidr_replace(&dev_nums_idr, NULL, chip->dev_num);\n\tmutex_unlock(&idr_lock);\n\n\t \n\tdown_write(&chip->ops_sem);\n\n\t \n\tif (chip->ops) {\n\t\tif (chip->flags & TPM_CHIP_FLAG_TPM2) {\n\t\t\tif (!tpm_chip_start(chip)) {\n\t\t\t\ttpm2_shutdown(chip, TPM2_SU_CLEAR);\n\t\t\t\ttpm_chip_stop(chip);\n\t\t\t}\n\t\t}\n\t\tchip->ops = NULL;\n\t}\n\tup_write(&chip->ops_sem);\n}\n\nstatic void tpm_del_legacy_sysfs(struct tpm_chip *chip)\n{\n\tstruct attribute **i;\n\n\tif (chip->flags & (TPM_CHIP_FLAG_TPM2 | TPM_CHIP_FLAG_VIRTUAL) ||\n\t    tpm_is_firmware_upgrade(chip))\n\t\treturn;\n\n\tsysfs_remove_link(&chip->dev.parent->kobj, \"ppi\");\n\n\tfor (i = chip->groups[0]->attrs; *i != NULL; ++i)\n\t\tsysfs_remove_link(&chip->dev.parent->kobj, (*i)->name);\n}\n\n \nstatic int tpm_add_legacy_sysfs(struct tpm_chip *chip)\n{\n\tstruct attribute **i;\n\tint rc;\n\n\tif (chip->flags & (TPM_CHIP_FLAG_TPM2 | TPM_CHIP_FLAG_VIRTUAL) ||\n\t\ttpm_is_firmware_upgrade(chip))\n\t\treturn 0;\n\n\trc = compat_only_sysfs_link_entry_to_kobj(\n\t\t    &chip->dev.parent->kobj, &chip->dev.kobj, \"ppi\", NULL);\n\tif (rc && rc != -ENOENT)\n\t\treturn rc;\n\n\t \n\tfor (i = chip->groups[0]->attrs; *i != NULL; ++i) {\n\t\trc = compat_only_sysfs_link_entry_to_kobj(\n\t\t    &chip->dev.parent->kobj, &chip->dev.kobj, (*i)->name, NULL);\n\t\tif (rc) {\n\t\t\ttpm_del_legacy_sysfs(chip);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int tpm_hwrng_read(struct hwrng *rng, void *data, size_t max, bool wait)\n{\n\tstruct tpm_chip *chip = container_of(rng, struct tpm_chip, hwrng);\n\n\t \n\tif (chip->flags & TPM_CHIP_FLAG_SUSPENDED)\n\t\treturn 0;\n\n\treturn tpm_get_random(chip, data, max);\n}\n\nstatic bool tpm_is_hwrng_enabled(struct tpm_chip *chip)\n{\n\tif (!IS_ENABLED(CONFIG_HW_RANDOM_TPM))\n\t\treturn false;\n\tif (tpm_is_firmware_upgrade(chip))\n\t\treturn false;\n\tif (chip->flags & TPM_CHIP_FLAG_HWRNG_DISABLED)\n\t\treturn false;\n\treturn true;\n}\n\nstatic int tpm_add_hwrng(struct tpm_chip *chip)\n{\n\tif (!tpm_is_hwrng_enabled(chip))\n\t\treturn 0;\n\n\tsnprintf(chip->hwrng_name, sizeof(chip->hwrng_name),\n\t\t \"tpm-rng-%d\", chip->dev_num);\n\tchip->hwrng.name = chip->hwrng_name;\n\tchip->hwrng.read = tpm_hwrng_read;\n\treturn hwrng_register(&chip->hwrng);\n}\n\nstatic int tpm_get_pcr_allocation(struct tpm_chip *chip)\n{\n\tint rc;\n\n\tif (tpm_is_firmware_upgrade(chip))\n\t\treturn 0;\n\n\trc = (chip->flags & TPM_CHIP_FLAG_TPM2) ?\n\t     tpm2_get_pcr_allocation(chip) :\n\t     tpm1_get_pcr_allocation(chip);\n\n\tif (rc > 0)\n\t\treturn -ENODEV;\n\n\treturn rc;\n}\n\n \nint tpm_chip_bootstrap(struct tpm_chip *chip)\n{\n\tint rc;\n\n\tif (chip->flags & TPM_CHIP_FLAG_BOOTSTRAPPED)\n\t\treturn 0;\n\n\trc = tpm_chip_start(chip);\n\tif (rc)\n\t\treturn rc;\n\n\trc = tpm_auto_startup(chip);\n\tif (rc)\n\t\tgoto stop;\n\n\trc = tpm_get_pcr_allocation(chip);\nstop:\n\ttpm_chip_stop(chip);\n\n\t \n\tchip->flags |= TPM_CHIP_FLAG_BOOTSTRAPPED;\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(tpm_chip_bootstrap);\n\n \nint tpm_chip_register(struct tpm_chip *chip)\n{\n\tint rc;\n\n\trc = tpm_chip_bootstrap(chip);\n\tif (rc)\n\t\treturn rc;\n\n\ttpm_sysfs_add_device(chip);\n\n\ttpm_bios_log_setup(chip);\n\n\ttpm_add_ppi(chip);\n\n\trc = tpm_add_hwrng(chip);\n\tif (rc)\n\t\tgoto out_ppi;\n\n\trc = tpm_add_char_device(chip);\n\tif (rc)\n\t\tgoto out_hwrng;\n\n\trc = tpm_add_legacy_sysfs(chip);\n\tif (rc) {\n\t\ttpm_chip_unregister(chip);\n\t\treturn rc;\n\t}\n\n\treturn 0;\n\nout_hwrng:\n\tif (tpm_is_hwrng_enabled(chip))\n\t\thwrng_unregister(&chip->hwrng);\nout_ppi:\n\ttpm_bios_log_teardown(chip);\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(tpm_chip_register);\n\n \nvoid tpm_chip_unregister(struct tpm_chip *chip)\n{\n\ttpm_del_legacy_sysfs(chip);\n\tif (tpm_is_hwrng_enabled(chip))\n\t\thwrng_unregister(&chip->hwrng);\n\ttpm_bios_log_teardown(chip);\n\tif (chip->flags & TPM_CHIP_FLAG_TPM2 && !tpm_is_firmware_upgrade(chip))\n\t\ttpm_devs_remove(chip);\n\ttpm_del_char_device(chip);\n}\nEXPORT_SYMBOL_GPL(tpm_chip_unregister);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}