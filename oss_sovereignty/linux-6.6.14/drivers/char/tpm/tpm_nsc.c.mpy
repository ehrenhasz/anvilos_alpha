{
  "module_name": "tpm_nsc.c",
  "hash_id": "749e1ddbc0067be63da816e2795ff225290519df6fc781209eeb83993eba5936",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/tpm/tpm_nsc.c",
  "human_readable_source": "\n \n\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include \"tpm.h\"\n\n \nenum tpm_nsc_addr{\n\tTPM_NSC_IRQ = 0x07,\n\tTPM_NSC_BASE0_HI = 0x60,\n\tTPM_NSC_BASE0_LO = 0x61,\n\tTPM_NSC_BASE1_HI = 0x62,\n\tTPM_NSC_BASE1_LO = 0x63\n};\n\nenum tpm_nsc_index {\n\tNSC_LDN_INDEX = 0x07,\n\tNSC_SID_INDEX = 0x20,\n\tNSC_LDC_INDEX = 0x30,\n\tNSC_DIO_INDEX = 0x60,\n\tNSC_CIO_INDEX = 0x62,\n\tNSC_IRQ_INDEX = 0x70,\n\tNSC_ITS_INDEX = 0x71\n};\n\nenum tpm_nsc_status_loc {\n\tNSC_STATUS = 0x01,\n\tNSC_COMMAND = 0x01,\n\tNSC_DATA = 0x00\n};\n\n \nenum tpm_nsc_status {\n\tNSC_STATUS_OBF = 0x01,\t \n\tNSC_STATUS_IBF = 0x02,\t \n\tNSC_STATUS_F0 = 0x04,\t \n\tNSC_STATUS_A2 = 0x08,\t \n\tNSC_STATUS_RDY = 0x10,\t \n\tNSC_STATUS_IBR = 0x20\t \n};\n\n \nenum tpm_nsc_cmd_mode {\n\tNSC_COMMAND_NORMAL = 0x01,\t \n\tNSC_COMMAND_EOC = 0x03,\n\tNSC_COMMAND_CANCEL = 0x22\n};\n\nstruct tpm_nsc_priv {\n\tunsigned long base;\n};\n\n \nstatic int wait_for_stat(struct tpm_chip *chip, u8 mask, u8 val, u8 * data)\n{\n\tstruct tpm_nsc_priv *priv = dev_get_drvdata(&chip->dev);\n\tunsigned long stop;\n\n\t \n\t*data = inb(priv->base + NSC_STATUS);\n\tif ((*data & mask) == val)\n\t\treturn 0;\n\n\t \n\tstop = jiffies + 10 * HZ;\n\tdo {\n\t\tmsleep(TPM_TIMEOUT);\n\t\t*data = inb(priv->base + 1);\n\t\tif ((*data & mask) == val)\n\t\t\treturn 0;\n\t}\n\twhile (time_before(jiffies, stop));\n\n\treturn -EBUSY;\n}\n\nstatic int nsc_wait_for_ready(struct tpm_chip *chip)\n{\n\tstruct tpm_nsc_priv *priv = dev_get_drvdata(&chip->dev);\n\tint status;\n\tunsigned long stop;\n\n\t \n\tstatus = inb(priv->base + NSC_STATUS);\n\tif (status & NSC_STATUS_OBF)\n\t\tstatus = inb(priv->base + NSC_DATA);\n\tif (status & NSC_STATUS_RDY)\n\t\treturn 0;\n\n\t \n\tstop = jiffies + 100;\n\tdo {\n\t\tmsleep(TPM_TIMEOUT);\n\t\tstatus = inb(priv->base + NSC_STATUS);\n\t\tif (status & NSC_STATUS_OBF)\n\t\t\tstatus = inb(priv->base + NSC_DATA);\n\t\tif (status & NSC_STATUS_RDY)\n\t\t\treturn 0;\n\t}\n\twhile (time_before(jiffies, stop));\n\n\tdev_info(&chip->dev, \"wait for ready failed\\n\");\n\treturn -EBUSY;\n}\n\n\nstatic int tpm_nsc_recv(struct tpm_chip *chip, u8 * buf, size_t count)\n{\n\tstruct tpm_nsc_priv *priv = dev_get_drvdata(&chip->dev);\n\tu8 *buffer = buf;\n\tu8 data, *p;\n\tu32 size;\n\t__be32 *native_size;\n\n\tif (count < 6)\n\t\treturn -EIO;\n\n\tif (wait_for_stat(chip, NSC_STATUS_F0, NSC_STATUS_F0, &data) < 0) {\n\t\tdev_err(&chip->dev, \"F0 timeout\\n\");\n\t\treturn -EIO;\n\t}\n\n\tdata = inb(priv->base + NSC_DATA);\n\tif (data != NSC_COMMAND_NORMAL) {\n\t\tdev_err(&chip->dev, \"not in normal mode (0x%x)\\n\",\n\t\t\tdata);\n\t\treturn -EIO;\n\t}\n\n\t \n\tfor (p = buffer; p < &buffer[count]; p++) {\n\t\tif (wait_for_stat\n\t\t    (chip, NSC_STATUS_OBF, NSC_STATUS_OBF, &data) < 0) {\n\t\t\tdev_err(&chip->dev,\n\t\t\t\t\"OBF timeout (while reading data)\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (data & NSC_STATUS_F0)\n\t\t\tbreak;\n\t\t*p = inb(priv->base + NSC_DATA);\n\t}\n\n\tif ((data & NSC_STATUS_F0) == 0 &&\n\t(wait_for_stat(chip, NSC_STATUS_F0, NSC_STATUS_F0, &data) < 0)) {\n\t\tdev_err(&chip->dev, \"F0 not set\\n\");\n\t\treturn -EIO;\n\t}\n\n\tdata = inb(priv->base + NSC_DATA);\n\tif (data != NSC_COMMAND_EOC) {\n\t\tdev_err(&chip->dev,\n\t\t\t\"expected end of command(0x%x)\\n\", data);\n\t\treturn -EIO;\n\t}\n\n\tnative_size = (__force __be32 *) (buf + 2);\n\tsize = be32_to_cpu(*native_size);\n\n\tif (count < size)\n\t\treturn -EIO;\n\n\treturn size;\n}\n\nstatic int tpm_nsc_send(struct tpm_chip *chip, u8 * buf, size_t count)\n{\n\tstruct tpm_nsc_priv *priv = dev_get_drvdata(&chip->dev);\n\tu8 data;\n\tint i;\n\n\t \n\toutb(NSC_COMMAND_CANCEL, priv->base + NSC_COMMAND);\n\n\tif (nsc_wait_for_ready(chip) != 0)\n\t\treturn -EIO;\n\n\tif (wait_for_stat(chip, NSC_STATUS_IBF, 0, &data) < 0) {\n\t\tdev_err(&chip->dev, \"IBF timeout\\n\");\n\t\treturn -EIO;\n\t}\n\n\toutb(NSC_COMMAND_NORMAL, priv->base + NSC_COMMAND);\n\tif (wait_for_stat(chip, NSC_STATUS_IBR, NSC_STATUS_IBR, &data) < 0) {\n\t\tdev_err(&chip->dev, \"IBR timeout\\n\");\n\t\treturn -EIO;\n\t}\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (wait_for_stat(chip, NSC_STATUS_IBF, 0, &data) < 0) {\n\t\t\tdev_err(&chip->dev,\n\t\t\t\t\"IBF timeout (while writing data)\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\toutb(buf[i], priv->base + NSC_DATA);\n\t}\n\n\tif (wait_for_stat(chip, NSC_STATUS_IBF, 0, &data) < 0) {\n\t\tdev_err(&chip->dev, \"IBF timeout\\n\");\n\t\treturn -EIO;\n\t}\n\toutb(NSC_COMMAND_EOC, priv->base + NSC_COMMAND);\n\n\treturn 0;\n}\n\nstatic void tpm_nsc_cancel(struct tpm_chip *chip)\n{\n\tstruct tpm_nsc_priv *priv = dev_get_drvdata(&chip->dev);\n\n\toutb(NSC_COMMAND_CANCEL, priv->base + NSC_COMMAND);\n}\n\nstatic u8 tpm_nsc_status(struct tpm_chip *chip)\n{\n\tstruct tpm_nsc_priv *priv = dev_get_drvdata(&chip->dev);\n\n\treturn inb(priv->base + NSC_STATUS);\n}\n\nstatic bool tpm_nsc_req_canceled(struct tpm_chip *chip, u8 status)\n{\n\treturn (status == NSC_STATUS_RDY);\n}\n\nstatic const struct tpm_class_ops tpm_nsc = {\n\t.recv = tpm_nsc_recv,\n\t.send = tpm_nsc_send,\n\t.cancel = tpm_nsc_cancel,\n\t.status = tpm_nsc_status,\n\t.req_complete_mask = NSC_STATUS_OBF,\n\t.req_complete_val = NSC_STATUS_OBF,\n\t.req_canceled = tpm_nsc_req_canceled,\n};\n\nstatic struct platform_device *pdev = NULL;\n\nstatic void tpm_nsc_remove(struct device *dev)\n{\n\tstruct tpm_chip *chip = dev_get_drvdata(dev);\n\tstruct tpm_nsc_priv *priv = dev_get_drvdata(&chip->dev);\n\n\ttpm_chip_unregister(chip);\n\trelease_region(priv->base, 2);\n}\n\nstatic SIMPLE_DEV_PM_OPS(tpm_nsc_pm, tpm_pm_suspend, tpm_pm_resume);\n\nstatic struct platform_driver nsc_drv = {\n\t.driver          = {\n\t\t.name    = \"tpm_nsc\",\n\t\t.pm      = &tpm_nsc_pm,\n\t},\n};\n\nstatic inline int tpm_read_index(int base, int index)\n{\n\toutb(index, base);\n\treturn inb(base+1) & 0xFF;\n}\n\nstatic inline void tpm_write_index(int base, int index, int value)\n{\n\toutb(index, base);\n\toutb(value & 0xFF, base+1);\n}\n\nstatic int __init init_nsc(void)\n{\n\tint rc = 0;\n\tint lo, hi, err;\n\tint nscAddrBase = TPM_ADDR;\n\tstruct tpm_chip *chip;\n\tunsigned long base;\n\tstruct tpm_nsc_priv *priv;\n\n\t \n\tif (tpm_read_index(TPM_ADDR, NSC_SID_INDEX) != 0xEF) {\n\t\tnscAddrBase = (tpm_read_index(TPM_SUPERIO_ADDR, 0x2C)<<8)|\n\t\t\t(tpm_read_index(TPM_SUPERIO_ADDR, 0x2B)&0xFE);\n\t\tif (tpm_read_index(nscAddrBase, NSC_SID_INDEX) != 0xF6)\n\t\t\treturn -ENODEV;\n\t}\n\n\terr = platform_driver_register(&nsc_drv);\n\tif (err)\n\t\treturn err;\n\n\thi = tpm_read_index(nscAddrBase, TPM_NSC_BASE0_HI);\n\tlo = tpm_read_index(nscAddrBase, TPM_NSC_BASE0_LO);\n\tbase = (hi<<8) | lo;\n\n\t \n\ttpm_write_index(nscAddrBase, NSC_LDC_INDEX, 0x01);\n\n\tpdev = platform_device_alloc(\"tpm_nscl0\", -1);\n\tif (!pdev) {\n\t\trc = -ENOMEM;\n\t\tgoto err_unreg_drv;\n\t}\n\n\tpdev->num_resources = 0;\n\tpdev->dev.driver = &nsc_drv.driver;\n\tpdev->dev.release = tpm_nsc_remove;\n\n\tif ((rc = platform_device_add(pdev)) < 0)\n\t\tgoto err_put_dev;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv) {\n\t\trc = -ENOMEM;\n\t\tgoto err_del_dev;\n\t}\n\n\tpriv->base = base;\n\n\tif (request_region(base, 2, \"tpm_nsc0\") == NULL ) {\n\t\trc = -EBUSY;\n\t\tgoto err_del_dev;\n\t}\n\n\tchip = tpmm_chip_alloc(&pdev->dev, &tpm_nsc);\n\tif (IS_ERR(chip)) {\n\t\trc = -ENODEV;\n\t\tgoto err_rel_reg;\n\t}\n\n\tdev_set_drvdata(&chip->dev, priv);\n\n\trc = tpm_chip_register(chip);\n\tif (rc)\n\t\tgoto err_rel_reg;\n\n\tdev_dbg(&pdev->dev, \"NSC TPM detected\\n\");\n\tdev_dbg(&pdev->dev,\n\t\t\"NSC LDN 0x%x, SID 0x%x, SRID 0x%x\\n\",\n\t\ttpm_read_index(nscAddrBase,0x07), tpm_read_index(nscAddrBase,0x20),\n\t\ttpm_read_index(nscAddrBase,0x27));\n\tdev_dbg(&pdev->dev,\n\t\t\"NSC SIOCF1 0x%x SIOCF5 0x%x SIOCF6 0x%x SIOCF8 0x%x\\n\",\n\t\ttpm_read_index(nscAddrBase,0x21), tpm_read_index(nscAddrBase,0x25),\n\t\ttpm_read_index(nscAddrBase,0x26), tpm_read_index(nscAddrBase,0x28));\n\tdev_dbg(&pdev->dev, \"NSC IO Base0 0x%x\\n\",\n\t\t(tpm_read_index(nscAddrBase,0x60) << 8) | tpm_read_index(nscAddrBase,0x61));\n\tdev_dbg(&pdev->dev, \"NSC IO Base1 0x%x\\n\",\n\t\t(tpm_read_index(nscAddrBase,0x62) << 8) | tpm_read_index(nscAddrBase,0x63));\n\tdev_dbg(&pdev->dev, \"NSC Interrupt number and wakeup 0x%x\\n\",\n\t\ttpm_read_index(nscAddrBase,0x70));\n\tdev_dbg(&pdev->dev, \"NSC IRQ type select 0x%x\\n\",\n\t\ttpm_read_index(nscAddrBase,0x71));\n\tdev_dbg(&pdev->dev,\n\t\t\"NSC DMA channel select0 0x%x, select1 0x%x\\n\",\n\t\ttpm_read_index(nscAddrBase,0x74), tpm_read_index(nscAddrBase,0x75));\n\tdev_dbg(&pdev->dev,\n\t\t\"NSC Config \"\n\t\t\"0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\\n\",\n\t\ttpm_read_index(nscAddrBase,0xF0), tpm_read_index(nscAddrBase,0xF1),\n\t\ttpm_read_index(nscAddrBase,0xF2), tpm_read_index(nscAddrBase,0xF3),\n\t\ttpm_read_index(nscAddrBase,0xF4), tpm_read_index(nscAddrBase,0xF5),\n\t\ttpm_read_index(nscAddrBase,0xF6), tpm_read_index(nscAddrBase,0xF7),\n\t\ttpm_read_index(nscAddrBase,0xF8), tpm_read_index(nscAddrBase,0xF9));\n\n\tdev_info(&pdev->dev,\n\t\t \"NSC TPM revision %d\\n\",\n\t\t tpm_read_index(nscAddrBase, 0x27) & 0x1F);\n\n\treturn 0;\n\nerr_rel_reg:\n\trelease_region(base, 2);\nerr_del_dev:\n\tplatform_device_del(pdev);\nerr_put_dev:\n\tplatform_device_put(pdev);\nerr_unreg_drv:\n\tplatform_driver_unregister(&nsc_drv);\n\treturn rc;\n}\n\nstatic void __exit cleanup_nsc(void)\n{\n\tif (pdev) {\n\t\ttpm_nsc_remove(&pdev->dev);\n\t\tplatform_device_unregister(pdev);\n\t}\n\n\tplatform_driver_unregister(&nsc_drv);\n}\n\nmodule_init(init_nsc);\nmodule_exit(cleanup_nsc);\n\nMODULE_AUTHOR(\"Leendert van Doorn (leendert@watson.ibm.com)\");\nMODULE_DESCRIPTION(\"TPM Driver\");\nMODULE_VERSION(\"2.0\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}