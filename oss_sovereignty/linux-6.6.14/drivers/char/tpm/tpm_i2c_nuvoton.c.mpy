{
  "module_name": "tpm_i2c_nuvoton.c",
  "hash_id": "5fc3a6559dcf1290e4d0b268c0cd63181db5dc5d425799e81846a2eb33ba9f65",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/tpm/tpm_i2c_nuvoton.c",
  "human_readable_source": "\n  \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/wait.h>\n#include <linux/i2c.h>\n#include <linux/of_device.h>\n#include \"tpm.h\"\n\n \n#define TPM_STS\t\t\t0x00\n#define TPM_BURST_COUNT\t\t0x01\n#define TPM_DATA_FIFO_W\t\t0x20\n#define TPM_DATA_FIFO_R\t\t0x40\n#define TPM_VID_DID_RID\t\t0x60\n#define TPM_I2C_RETRIES\t\t5\n \n#define TPM_I2C_MAX_BUF_SIZE           32\n#define TPM_I2C_RETRY_COUNT            32\n#define TPM_I2C_BUS_DELAY              1000      \t \n#define TPM_I2C_RETRY_DELAY_SHORT      (2 * 1000)\t \n#define TPM_I2C_RETRY_DELAY_LONG       (10 * 1000) \t \n#define TPM_I2C_DELAY_RANGE            300\t\t \n\n#define OF_IS_TPM2 ((void *)1)\n#define I2C_IS_TPM2 1\n\nstruct priv_data {\n\tint irq;\n\tunsigned int intrs;\n\twait_queue_head_t read_queue;\n};\n\nstatic s32 i2c_nuvoton_read_buf(struct i2c_client *client, u8 offset, u8 size,\n\t\t\t\tu8 *data)\n{\n\ts32 status;\n\n\tstatus = i2c_smbus_read_i2c_block_data(client, offset, size, data);\n\tdev_dbg(&client->dev,\n\t\t\"%s(offset=%u size=%u data=%*ph) -> sts=%d\\n\", __func__,\n\t\toffset, size, (int)size, data, status);\n\treturn status;\n}\n\nstatic s32 i2c_nuvoton_write_buf(struct i2c_client *client, u8 offset, u8 size,\n\t\t\t\t u8 *data)\n{\n\ts32 status;\n\n\tstatus = i2c_smbus_write_i2c_block_data(client, offset, size, data);\n\tdev_dbg(&client->dev,\n\t\t\"%s(offset=%u size=%u data=%*ph) -> sts=%d\\n\", __func__,\n\t\toffset, size, (int)size, data, status);\n\treturn status;\n}\n\n#define TPM_STS_VALID          0x80\n#define TPM_STS_COMMAND_READY  0x40\n#define TPM_STS_GO             0x20\n#define TPM_STS_DATA_AVAIL     0x10\n#define TPM_STS_EXPECT         0x08\n#define TPM_STS_RESPONSE_RETRY 0x02\n#define TPM_STS_ERR_VAL        0x07     \n\n#define TPM_I2C_SHORT_TIMEOUT  750      \n#define TPM_I2C_LONG_TIMEOUT   2000     \n\n \nstatic u8 i2c_nuvoton_read_status(struct tpm_chip *chip)\n{\n\tstruct i2c_client *client = to_i2c_client(chip->dev.parent);\n\ts32 status;\n\tu8 data;\n\n\tstatus = i2c_nuvoton_read_buf(client, TPM_STS, 1, &data);\n\tif (status <= 0) {\n\t\tdev_err(&chip->dev, \"%s() error return %d\\n\", __func__,\n\t\t\tstatus);\n\t\tdata = TPM_STS_ERR_VAL;\n\t}\n\n\treturn data;\n}\n\n \nstatic s32 i2c_nuvoton_write_status(struct i2c_client *client, u8 data)\n{\n\ts32 status;\n\tint i;\n\n\t \n\tfor (i = 0, status = -1; i < TPM_I2C_RETRY_COUNT && status < 0; i++) {\n\t\tstatus = i2c_nuvoton_write_buf(client, TPM_STS, 1, &data);\n\t\tif (status < 0)\n\t\t\tusleep_range(TPM_I2C_BUS_DELAY, TPM_I2C_BUS_DELAY\n\t\t\t\t     + TPM_I2C_DELAY_RANGE);\n\t}\n\treturn status;\n}\n\n \nstatic void i2c_nuvoton_ready(struct tpm_chip *chip)\n{\n\tstruct i2c_client *client = to_i2c_client(chip->dev.parent);\n\ts32 status;\n\n\t \n\tstatus = i2c_nuvoton_write_status(client, TPM_STS_COMMAND_READY);\n\tif (status < 0)\n\t\tdev_err(&chip->dev,\n\t\t\t\"%s() fail to write TPM_STS.commandReady\\n\", __func__);\n}\n\n \nstatic int i2c_nuvoton_get_burstcount(struct i2c_client *client,\n\t\t\t\t      struct tpm_chip *chip)\n{\n\tunsigned long stop = jiffies + chip->timeout_d;\n\ts32 status;\n\tint burst_count = -1;\n\tu8 data;\n\n\t \n\tdo {\n\t\t \n\t\tstatus = i2c_nuvoton_read_buf(client, TPM_BURST_COUNT, 1,\n\t\t\t\t\t      &data);\n\t\tif (status > 0 && data > 0) {\n\t\t\tburst_count = min_t(u8, TPM_I2C_MAX_BUF_SIZE, data);\n\t\t\tbreak;\n\t\t}\n\t\tusleep_range(TPM_I2C_BUS_DELAY, TPM_I2C_BUS_DELAY\n\t\t\t     + TPM_I2C_DELAY_RANGE);\n\t} while (time_before(jiffies, stop));\n\n\treturn burst_count;\n}\n\n \nstatic bool i2c_nuvoton_check_status(struct tpm_chip *chip, u8 mask, u8 value)\n{\n\tu8 status = i2c_nuvoton_read_status(chip);\n\treturn (status != TPM_STS_ERR_VAL) && ((status & mask) == value);\n}\n\nstatic int i2c_nuvoton_wait_for_stat(struct tpm_chip *chip, u8 mask, u8 value,\n\t\t\t\t     u32 timeout, wait_queue_head_t *queue)\n{\n\tif ((chip->flags & TPM_CHIP_FLAG_IRQ) && queue) {\n\t\ts32 rc;\n\t\tstruct priv_data *priv = dev_get_drvdata(&chip->dev);\n\t\tunsigned int cur_intrs = priv->intrs;\n\n\t\tenable_irq(priv->irq);\n\t\trc = wait_event_interruptible_timeout(*queue,\n\t\t\t\t\t\t      cur_intrs != priv->intrs,\n\t\t\t\t\t\t      timeout);\n\t\tif (rc > 0)\n\t\t\treturn 0;\n\t\t \n\t} else {\n\t\tunsigned long ten_msec, stop;\n\t\tbool status_valid;\n\n\t\t \n\t\tstatus_valid = i2c_nuvoton_check_status(chip, mask, value);\n\t\tif (status_valid)\n\t\t\treturn 0;\n\n\t\t \n\t\tten_msec = jiffies + usecs_to_jiffies(TPM_I2C_RETRY_DELAY_LONG);\n\t\tstop = jiffies + timeout;\n\t\tdo {\n\t\t\tif (time_before(jiffies, ten_msec))\n\t\t\t\tusleep_range(TPM_I2C_RETRY_DELAY_SHORT,\n\t\t\t\t\t     TPM_I2C_RETRY_DELAY_SHORT\n\t\t\t\t\t     + TPM_I2C_DELAY_RANGE);\n\t\t\telse\n\t\t\t\tusleep_range(TPM_I2C_RETRY_DELAY_LONG,\n\t\t\t\t\t     TPM_I2C_RETRY_DELAY_LONG\n\t\t\t\t\t     + TPM_I2C_DELAY_RANGE);\n\t\t\tstatus_valid = i2c_nuvoton_check_status(chip, mask,\n\t\t\t\t\t\t\t\tvalue);\n\t\t\tif (status_valid)\n\t\t\t\treturn 0;\n\t\t} while (time_before(jiffies, stop));\n\t}\n\tdev_err(&chip->dev, \"%s(%02x, %02x) -> timeout\\n\", __func__, mask,\n\t\tvalue);\n\treturn -ETIMEDOUT;\n}\n\n \nstatic int i2c_nuvoton_wait_for_data_avail(struct tpm_chip *chip, u32 timeout,\n\t\t\t\t\t   wait_queue_head_t *queue)\n{\n\treturn i2c_nuvoton_wait_for_stat(chip,\n\t\t\t\t\t TPM_STS_DATA_AVAIL | TPM_STS_VALID,\n\t\t\t\t\t TPM_STS_DATA_AVAIL | TPM_STS_VALID,\n\t\t\t\t\t timeout, queue);\n}\n\n \nstatic int i2c_nuvoton_recv_data(struct i2c_client *client,\n\t\t\t\t struct tpm_chip *chip, u8 *buf, size_t count)\n{\n\tstruct priv_data *priv = dev_get_drvdata(&chip->dev);\n\ts32 rc;\n\tint burst_count, bytes2read, size = 0;\n\n\twhile (size < count &&\n\t       i2c_nuvoton_wait_for_data_avail(chip,\n\t\t\t\t\t       chip->timeout_c,\n\t\t\t\t\t       &priv->read_queue) == 0) {\n\t\tburst_count = i2c_nuvoton_get_burstcount(client, chip);\n\t\tif (burst_count < 0) {\n\t\t\tdev_err(&chip->dev,\n\t\t\t\t\"%s() fail to read burstCount=%d\\n\", __func__,\n\t\t\t\tburst_count);\n\t\t\treturn -EIO;\n\t\t}\n\t\tbytes2read = min_t(size_t, burst_count, count - size);\n\t\trc = i2c_nuvoton_read_buf(client, TPM_DATA_FIFO_R,\n\t\t\t\t\t  bytes2read, &buf[size]);\n\t\tif (rc < 0) {\n\t\t\tdev_err(&chip->dev,\n\t\t\t\t\"%s() fail on i2c_nuvoton_read_buf()=%d\\n\",\n\t\t\t\t__func__, rc);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdev_dbg(&chip->dev, \"%s(%d):\", __func__, bytes2read);\n\t\tsize += bytes2read;\n\t}\n\n\treturn size;\n}\n\n \nstatic int i2c_nuvoton_recv(struct tpm_chip *chip, u8 *buf, size_t count)\n{\n\tstruct priv_data *priv = dev_get_drvdata(&chip->dev);\n\tstruct device *dev = chip->dev.parent;\n\tstruct i2c_client *client = to_i2c_client(dev);\n\ts32 rc;\n\tint status;\n\tint burst_count;\n\tint retries;\n\tint size = 0;\n\tu32 expected;\n\n\tif (count < TPM_HEADER_SIZE) {\n\t\ti2c_nuvoton_ready(chip);     \n\t\tdev_err(dev, \"%s() count < header size\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\tfor (retries = 0; retries < TPM_I2C_RETRIES; retries++) {\n\t\tif (retries > 0) {\n\t\t\t \n\t\t\ti2c_nuvoton_write_status(client,\n\t\t\t\t\t\t TPM_STS_RESPONSE_RETRY);\n\t\t}\n\t\t \n\t\tstatus = i2c_nuvoton_wait_for_data_avail(\n\t\t\tchip, chip->timeout_c, &priv->read_queue);\n\t\tif (status != 0) {\n\t\t\tdev_err(dev, \"%s() timeout on dataAvail\\n\", __func__);\n\t\t\tsize = -ETIMEDOUT;\n\t\t\tcontinue;\n\t\t}\n\t\tburst_count = i2c_nuvoton_get_burstcount(client, chip);\n\t\tif (burst_count < 0) {\n\t\t\tdev_err(dev, \"%s() fail to get burstCount\\n\", __func__);\n\t\t\tsize = -EIO;\n\t\t\tcontinue;\n\t\t}\n\t\tsize = i2c_nuvoton_recv_data(client, chip, buf,\n\t\t\t\t\t     burst_count);\n\t\tif (size < TPM_HEADER_SIZE) {\n\t\t\tdev_err(dev, \"%s() fail to read header\\n\", __func__);\n\t\t\tsize = -EIO;\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\texpected = be32_to_cpu(*(__be32 *) (buf + 2));\n\t\tif (expected > count || expected < size) {\n\t\t\tdev_err(dev, \"%s() expected > count\\n\", __func__);\n\t\t\tsize = -EIO;\n\t\t\tcontinue;\n\t\t}\n\t\trc = i2c_nuvoton_recv_data(client, chip, &buf[size],\n\t\t\t\t\t   expected - size);\n\t\tsize += rc;\n\t\tif (rc < 0 || size < expected) {\n\t\t\tdev_err(dev, \"%s() fail to read remainder of result\\n\",\n\t\t\t\t__func__);\n\t\t\tsize = -EIO;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i2c_nuvoton_wait_for_stat(\n\t\t\t    chip, TPM_STS_VALID | TPM_STS_DATA_AVAIL,\n\t\t\t    TPM_STS_VALID, chip->timeout_c,\n\t\t\t    NULL)) {\n\t\t\tdev_err(dev, \"%s() error left over data\\n\", __func__);\n\t\t\tsize = -ETIMEDOUT;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\ti2c_nuvoton_ready(chip);\n\tdev_dbg(&chip->dev, \"%s() -> %d\\n\", __func__, size);\n\treturn size;\n}\n\n \nstatic int i2c_nuvoton_send(struct tpm_chip *chip, u8 *buf, size_t len)\n{\n\tstruct priv_data *priv = dev_get_drvdata(&chip->dev);\n\tstruct device *dev = chip->dev.parent;\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tu32 ordinal;\n\tunsigned long duration;\n\tsize_t count = 0;\n\tint burst_count, bytes2write, retries, rc = -EIO;\n\n\tfor (retries = 0; retries < TPM_RETRY; retries++) {\n\t\ti2c_nuvoton_ready(chip);\n\t\tif (i2c_nuvoton_wait_for_stat(chip, TPM_STS_COMMAND_READY,\n\t\t\t\t\t      TPM_STS_COMMAND_READY,\n\t\t\t\t\t      chip->timeout_b, NULL)) {\n\t\t\tdev_err(dev, \"%s() timeout on commandReady\\n\",\n\t\t\t\t__func__);\n\t\t\trc = -EIO;\n\t\t\tcontinue;\n\t\t}\n\t\trc = 0;\n\t\twhile (count < len - 1) {\n\t\t\tburst_count = i2c_nuvoton_get_burstcount(client,\n\t\t\t\t\t\t\t\t chip);\n\t\t\tif (burst_count < 0) {\n\t\t\t\tdev_err(dev, \"%s() fail get burstCount\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\trc = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbytes2write = min_t(size_t, burst_count,\n\t\t\t\t\t    len - 1 - count);\n\t\t\trc = i2c_nuvoton_write_buf(client, TPM_DATA_FIFO_W,\n\t\t\t\t\t\t   bytes2write, &buf[count]);\n\t\t\tif (rc < 0) {\n\t\t\t\tdev_err(dev, \"%s() fail i2cWriteBuf\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdev_dbg(dev, \"%s(%d):\", __func__, bytes2write);\n\t\t\tcount += bytes2write;\n\t\t\trc = i2c_nuvoton_wait_for_stat(chip,\n\t\t\t\t\t\t       TPM_STS_VALID |\n\t\t\t\t\t\t       TPM_STS_EXPECT,\n\t\t\t\t\t\t       TPM_STS_VALID |\n\t\t\t\t\t\t       TPM_STS_EXPECT,\n\t\t\t\t\t\t       chip->timeout_c,\n\t\t\t\t\t\t       NULL);\n\t\t\tif (rc < 0) {\n\t\t\t\tdev_err(dev, \"%s() timeout on Expect\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\trc = -ETIMEDOUT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (rc < 0)\n\t\t\tcontinue;\n\n\t\t \n\t\trc = i2c_nuvoton_write_buf(client, TPM_DATA_FIFO_W, 1,\n\t\t\t\t\t   &buf[count]);\n\t\tif (rc < 0) {\n\t\t\tdev_err(dev, \"%s() fail to write last byte\\n\",\n\t\t\t\t__func__);\n\t\t\trc = -EIO;\n\t\t\tcontinue;\n\t\t}\n\t\tdev_dbg(dev, \"%s(last): %02x\", __func__, buf[count]);\n\t\trc = i2c_nuvoton_wait_for_stat(chip,\n\t\t\t\t\t       TPM_STS_VALID | TPM_STS_EXPECT,\n\t\t\t\t\t       TPM_STS_VALID,\n\t\t\t\t\t       chip->timeout_c, NULL);\n\t\tif (rc) {\n\t\t\tdev_err(dev, \"%s() timeout on Expect to clear\\n\",\n\t\t\t\t__func__);\n\t\t\trc = -ETIMEDOUT;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\tif (rc < 0) {\n\t\t \n\t\ti2c_nuvoton_ready(chip);\n\t\treturn rc;\n\t}\n\t \n\trc = i2c_nuvoton_write_status(client, TPM_STS_GO);\n\tif (rc < 0) {\n\t\tdev_err(dev, \"%s() fail to write Go\\n\", __func__);\n\t\ti2c_nuvoton_ready(chip);\n\t\treturn rc;\n\t}\n\tordinal = be32_to_cpu(*((__be32 *) (buf + 6)));\n\tduration = tpm_calc_ordinal_duration(chip, ordinal);\n\n\trc = i2c_nuvoton_wait_for_data_avail(chip, duration, &priv->read_queue);\n\tif (rc) {\n\t\tdev_err(dev, \"%s() timeout command duration %ld\\n\",\n\t\t\t__func__, duration);\n\t\ti2c_nuvoton_ready(chip);\n\t\treturn rc;\n\t}\n\n\tdev_dbg(dev, \"%s() -> %zd\\n\", __func__, len);\n\treturn 0;\n}\n\nstatic bool i2c_nuvoton_req_canceled(struct tpm_chip *chip, u8 status)\n{\n\treturn (status == TPM_STS_COMMAND_READY);\n}\n\nstatic const struct tpm_class_ops tpm_i2c = {\n\t.flags = TPM_OPS_AUTO_STARTUP,\n\t.status = i2c_nuvoton_read_status,\n\t.recv = i2c_nuvoton_recv,\n\t.send = i2c_nuvoton_send,\n\t.cancel = i2c_nuvoton_ready,\n\t.req_complete_mask = TPM_STS_DATA_AVAIL | TPM_STS_VALID,\n\t.req_complete_val = TPM_STS_DATA_AVAIL | TPM_STS_VALID,\n\t.req_canceled = i2c_nuvoton_req_canceled,\n};\n\n \nstatic irqreturn_t i2c_nuvoton_int_handler(int dummy, void *dev_id)\n{\n\tstruct tpm_chip *chip = dev_id;\n\tstruct priv_data *priv = dev_get_drvdata(&chip->dev);\n\n\tpriv->intrs++;\n\twake_up(&priv->read_queue);\n\tdisable_irq_nosync(priv->irq);\n\treturn IRQ_HANDLED;\n}\n\nstatic int get_vid(struct i2c_client *client, u32 *res)\n{\n\tstatic const u8 vid_did_rid_value[] = { 0x50, 0x10, 0xfe };\n\tu32 temp;\n\ts32 rc;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -ENODEV;\n\trc = i2c_nuvoton_read_buf(client, TPM_VID_DID_RID, 4, (u8 *)&temp);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\tif (memcmp(&temp, vid_did_rid_value, sizeof(vid_did_rid_value))) {\n\t\t \n\t\trc = i2c_nuvoton_read_buf(client, TPM_DATA_FIFO_W, 4,\n\t\t\t\t\t  (u8 *) (&temp));\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\t \n\t\tif (memcmp(&temp, vid_did_rid_value,\n\t\t\t   sizeof(vid_did_rid_value)))\n\t\t\treturn -ENODEV;\n\t}\n\n\t*res = temp;\n\treturn 0;\n}\n\nstatic int i2c_nuvoton_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tint rc;\n\tstruct tpm_chip *chip;\n\tstruct device *dev = &client->dev;\n\tstruct priv_data *priv;\n\tu32 vid = 0;\n\n\trc = get_vid(client, &vid);\n\tif (rc)\n\t\treturn rc;\n\n\tdev_info(dev, \"VID: %04X DID: %02X RID: %02X\\n\", (u16) vid,\n\t\t (u8) (vid >> 16), (u8) (vid >> 24));\n\n\tchip = tpmm_chip_alloc(dev, &tpm_i2c);\n\tif (IS_ERR(chip))\n\t\treturn PTR_ERR(chip);\n\n\tpriv = devm_kzalloc(dev, sizeof(struct priv_data), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tif (dev->of_node) {\n\t\tconst struct of_device_id *of_id;\n\n\t\tof_id = of_match_device(dev->driver->of_match_table, dev);\n\t\tif (of_id && of_id->data == OF_IS_TPM2)\n\t\t\tchip->flags |= TPM_CHIP_FLAG_TPM2;\n\t} else\n\t\tif (id->driver_data == I2C_IS_TPM2)\n\t\t\tchip->flags |= TPM_CHIP_FLAG_TPM2;\n\n\tinit_waitqueue_head(&priv->read_queue);\n\n\t \n\tchip->timeout_a = msecs_to_jiffies(TPM_I2C_SHORT_TIMEOUT);\n\tchip->timeout_b = msecs_to_jiffies(TPM_I2C_LONG_TIMEOUT);\n\tchip->timeout_c = msecs_to_jiffies(TPM_I2C_SHORT_TIMEOUT);\n\tchip->timeout_d = msecs_to_jiffies(TPM_I2C_SHORT_TIMEOUT);\n\n\tdev_set_drvdata(&chip->dev, priv);\n\n\t \n\tpriv->irq = client->irq;\n\tif (client->irq) {\n\t\tdev_dbg(dev, \"%s() priv->irq\\n\", __func__);\n\t\trc = devm_request_irq(dev, client->irq,\n\t\t\t\t      i2c_nuvoton_int_handler,\n\t\t\t\t      IRQF_TRIGGER_LOW,\n\t\t\t\t      dev_name(&chip->dev),\n\t\t\t\t      chip);\n\t\tif (rc) {\n\t\t\tdev_err(dev, \"%s() Unable to request irq: %d for use\\n\",\n\t\t\t\t__func__, priv->irq);\n\t\t\tpriv->irq = 0;\n\t\t} else {\n\t\t\tchip->flags |= TPM_CHIP_FLAG_IRQ;\n\t\t\t \n\t\t\ti2c_nuvoton_ready(chip);\n\t\t\t \n\t\t\trc = i2c_nuvoton_wait_for_stat(chip,\n\t\t\t\t\t\t       TPM_STS_COMMAND_READY,\n\t\t\t\t\t\t       TPM_STS_COMMAND_READY,\n\t\t\t\t\t\t       chip->timeout_b,\n\t\t\t\t\t\t       NULL);\n\t\t\tif (rc == 0) {\n\t\t\t\t \n\t\t\t\trc = i2c_nuvoton_write_buf(client,\n\t\t\t\t\t\t\t   TPM_DATA_FIFO_W,\n\t\t\t\t\t\t\t   1, (u8 *) (&rc));\n\t\t\t\tif (rc < 0)\n\t\t\t\t\treturn rc;\n\t\t\t\t \n\t\t\t\ti2c_nuvoton_ready(chip);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (i2c_nuvoton_read_status(chip) !=\n\t\t\t\t    TPM_STS_VALID)\n\t\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn tpm_chip_register(chip);\n}\n\nstatic void i2c_nuvoton_remove(struct i2c_client *client)\n{\n\tstruct tpm_chip *chip = i2c_get_clientdata(client);\n\n\ttpm_chip_unregister(chip);\n}\n\nstatic const struct i2c_device_id i2c_nuvoton_id[] = {\n\t{\"tpm_i2c_nuvoton\"},\n\t{\"tpm2_i2c_nuvoton\", .driver_data = I2C_IS_TPM2},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, i2c_nuvoton_id);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id i2c_nuvoton_of_match[] = {\n\t{.compatible = \"nuvoton,npct501\"},\n\t{.compatible = \"winbond,wpct301\"},\n\t{.compatible = \"nuvoton,npct601\", .data = OF_IS_TPM2},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, i2c_nuvoton_of_match);\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(i2c_nuvoton_pm_ops, tpm_pm_suspend, tpm_pm_resume);\n\nstatic struct i2c_driver i2c_nuvoton_driver = {\n\t.id_table = i2c_nuvoton_id,\n\t.probe = i2c_nuvoton_probe,\n\t.remove = i2c_nuvoton_remove,\n\t.driver = {\n\t\t.name = \"tpm_i2c_nuvoton\",\n\t\t.pm = &i2c_nuvoton_pm_ops,\n\t\t.of_match_table = of_match_ptr(i2c_nuvoton_of_match),\n\t},\n};\n\nmodule_i2c_driver(i2c_nuvoton_driver);\n\nMODULE_AUTHOR(\"Dan Morav (dan.morav@nuvoton.com)\");\nMODULE_DESCRIPTION(\"Nuvoton TPM I2C Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}