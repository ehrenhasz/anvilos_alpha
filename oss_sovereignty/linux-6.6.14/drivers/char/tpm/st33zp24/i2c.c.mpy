{
  "module_name": "i2c.c",
  "hash_id": "42831460405094dc5876ecfd3ab24e181ed428b873b5b92b4b92fb924ae83002",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/tpm/st33zp24/i2c.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/of.h>\n#include <linux/acpi.h>\n#include <linux/tpm.h>\n\n#include \"../tpm.h\"\n#include \"st33zp24.h\"\n\n#define TPM_DUMMY_BYTE\t\t\t0xAA\n\nstruct st33zp24_i2c_phy {\n\tstruct i2c_client *client;\n\tu8 buf[ST33ZP24_BUFSIZE + 1];\n};\n\n \nstatic int write8_reg(void *phy_id, u8 tpm_register, u8 *tpm_data, int tpm_size)\n{\n\tstruct st33zp24_i2c_phy *phy = phy_id;\n\n\tphy->buf[0] = tpm_register;\n\tmemcpy(phy->buf + 1, tpm_data, tpm_size);\n\treturn i2c_master_send(phy->client, phy->buf, tpm_size + 1);\n}  \n\n \nstatic int read8_reg(void *phy_id, u8 tpm_register, u8 *tpm_data, int tpm_size)\n{\n\tstruct st33zp24_i2c_phy *phy = phy_id;\n\tu8 status = 0;\n\tu8 data;\n\n\tdata = TPM_DUMMY_BYTE;\n\tstatus = write8_reg(phy, tpm_register, &data, 1);\n\tif (status == 2)\n\t\tstatus = i2c_master_recv(phy->client, tpm_data, tpm_size);\n\treturn status;\n}  \n\n \nstatic int st33zp24_i2c_send(void *phy_id, u8 tpm_register, u8 *tpm_data,\n\t\t\t     int tpm_size)\n{\n\treturn write8_reg(phy_id, tpm_register | TPM_WRITE_DIRECTION, tpm_data,\n\t\t\t  tpm_size);\n}\n\n \nstatic int st33zp24_i2c_recv(void *phy_id, u8 tpm_register, u8 *tpm_data,\n\t\t\t     int tpm_size)\n{\n\treturn read8_reg(phy_id, tpm_register, tpm_data, tpm_size);\n}\n\nstatic const struct st33zp24_phy_ops i2c_phy_ops = {\n\t.send = st33zp24_i2c_send,\n\t.recv = st33zp24_i2c_recv,\n};\n\n \nstatic int st33zp24_i2c_probe(struct i2c_client *client)\n{\n\tstruct st33zp24_i2c_phy *phy;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\n\t\tdev_info(&client->dev, \"client not i2c capable\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tphy = devm_kzalloc(&client->dev, sizeof(struct st33zp24_i2c_phy),\n\t\t\t   GFP_KERNEL);\n\tif (!phy)\n\t\treturn -ENOMEM;\n\n\tphy->client = client;\n\n\treturn st33zp24_probe(phy, &i2c_phy_ops, &client->dev, client->irq);\n}\n\n \nstatic void st33zp24_i2c_remove(struct i2c_client *client)\n{\n\tstruct tpm_chip *chip = i2c_get_clientdata(client);\n\n\tst33zp24_remove(chip);\n}\n\nstatic const struct i2c_device_id st33zp24_i2c_id[] = {\n\t{TPM_ST33_I2C, 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, st33zp24_i2c_id);\n\nstatic const struct of_device_id of_st33zp24_i2c_match[] __maybe_unused = {\n\t{ .compatible = \"st,st33zp24-i2c\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, of_st33zp24_i2c_match);\n\nstatic const struct acpi_device_id st33zp24_i2c_acpi_match[] __maybe_unused = {\n\t{\"SMO3324\"},\n\t{}\n};\nMODULE_DEVICE_TABLE(acpi, st33zp24_i2c_acpi_match);\n\nstatic SIMPLE_DEV_PM_OPS(st33zp24_i2c_ops, st33zp24_pm_suspend,\n\t\t\t st33zp24_pm_resume);\n\nstatic struct i2c_driver st33zp24_i2c_driver = {\n\t.driver = {\n\t\t.name = TPM_ST33_I2C,\n\t\t.pm = &st33zp24_i2c_ops,\n\t\t.of_match_table = of_match_ptr(of_st33zp24_i2c_match),\n\t\t.acpi_match_table = ACPI_PTR(st33zp24_i2c_acpi_match),\n\t},\n\t.probe = st33zp24_i2c_probe,\n\t.remove = st33zp24_i2c_remove,\n\t.id_table = st33zp24_i2c_id\n};\n\nmodule_i2c_driver(st33zp24_i2c_driver);\n\nMODULE_AUTHOR(\"TPM support (TPMsupport@list.st.com)\");\nMODULE_DESCRIPTION(\"STM TPM 1.2 I2C ST33 Driver\");\nMODULE_VERSION(\"1.3.0\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}