{
  "module_name": "spi.c",
  "hash_id": "13fdda5f7e20902522c48d85a67de62a8d60e10b0b02844be3445be663ef5e55",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/tpm/st33zp24/spi.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/spi/spi.h>\n#include <linux/of.h>\n#include <linux/acpi.h>\n#include <linux/tpm.h>\n\n#include \"../tpm.h\"\n#include \"st33zp24.h\"\n\n#define TPM_DATA_FIFO           0x24\n#define TPM_INTF_CAPABILITY     0x14\n\n#define TPM_DUMMY_BYTE\t\t0x00\n\n#define MAX_SPI_LATENCY\t\t15\n#define LOCALITY0\t\t0\n\n#define ST33ZP24_OK\t\t\t\t\t0x5A\n#define ST33ZP24_UNDEFINED_ERR\t\t\t\t0x80\n#define ST33ZP24_BADLOCALITY\t\t\t\t0x81\n#define ST33ZP24_TISREGISTER_UNKNOWN\t\t\t0x82\n#define ST33ZP24_LOCALITY_NOT_ACTIVATED\t\t\t0x83\n#define ST33ZP24_HASH_END_BEFORE_HASH_START\t\t0x84\n#define ST33ZP24_BAD_COMMAND_ORDER\t\t\t0x85\n#define ST33ZP24_INCORECT_RECEIVED_LENGTH\t\t0x86\n#define ST33ZP24_TPM_FIFO_OVERFLOW\t\t\t0x89\n#define ST33ZP24_UNEXPECTED_READ_FIFO\t\t\t0x8A\n#define ST33ZP24_UNEXPECTED_WRITE_FIFO\t\t\t0x8B\n#define ST33ZP24_CMDRDY_SET_WHEN_PROCESSING_HASH_END\t0x90\n#define ST33ZP24_DUMMY_BYTES\t\t\t\t0x00\n\n \n#define ST33ZP24_SPI_BUFFER_SIZE (ST33ZP24_BUFSIZE + (ST33ZP24_BUFSIZE / 2) +\\\n\t\t\t\t  MAX_SPI_LATENCY)\n\n\nstruct st33zp24_spi_phy {\n\tstruct spi_device *spi_device;\n\n\tu8 tx_buf[ST33ZP24_SPI_BUFFER_SIZE];\n\tu8 rx_buf[ST33ZP24_SPI_BUFFER_SIZE];\n\n\tint latency;\n};\n\nstatic int st33zp24_status_to_errno(u8 code)\n{\n\tswitch (code) {\n\tcase ST33ZP24_OK:\n\t\treturn 0;\n\tcase ST33ZP24_UNDEFINED_ERR:\n\tcase ST33ZP24_BADLOCALITY:\n\tcase ST33ZP24_TISREGISTER_UNKNOWN:\n\tcase ST33ZP24_LOCALITY_NOT_ACTIVATED:\n\tcase ST33ZP24_HASH_END_BEFORE_HASH_START:\n\tcase ST33ZP24_BAD_COMMAND_ORDER:\n\tcase ST33ZP24_UNEXPECTED_READ_FIFO:\n\tcase ST33ZP24_UNEXPECTED_WRITE_FIFO:\n\tcase ST33ZP24_CMDRDY_SET_WHEN_PROCESSING_HASH_END:\n\t\treturn -EPROTO;\n\tcase ST33ZP24_INCORECT_RECEIVED_LENGTH:\n\tcase ST33ZP24_TPM_FIFO_OVERFLOW:\n\t\treturn -EMSGSIZE;\n\tcase ST33ZP24_DUMMY_BYTES:\n\t\treturn -ENOSYS;\n\t}\n\treturn code;\n}\n\n \nstatic int st33zp24_spi_send(void *phy_id, u8 tpm_register, u8 *tpm_data,\n\t\t\t     int tpm_size)\n{\n\tint total_length = 0, ret = 0;\n\tstruct st33zp24_spi_phy *phy = phy_id;\n\tstruct spi_device *dev = phy->spi_device;\n\tstruct spi_transfer spi_xfer = {\n\t\t.tx_buf = phy->tx_buf,\n\t\t.rx_buf = phy->rx_buf,\n\t};\n\n\t \n\tphy->tx_buf[total_length++] = TPM_WRITE_DIRECTION | LOCALITY0;\n\tphy->tx_buf[total_length++] = tpm_register;\n\n\tif (tpm_size > 0 && tpm_register == TPM_DATA_FIFO) {\n\t\tphy->tx_buf[total_length++] = tpm_size >> 8;\n\t\tphy->tx_buf[total_length++] = tpm_size;\n\t}\n\n\tmemcpy(&phy->tx_buf[total_length], tpm_data, tpm_size);\n\ttotal_length += tpm_size;\n\n\tmemset(&phy->tx_buf[total_length], TPM_DUMMY_BYTE, phy->latency);\n\n\tspi_xfer.len = total_length + phy->latency;\n\n\tret = spi_sync_transfer(dev, &spi_xfer, 1);\n\tif (ret == 0)\n\t\tret = phy->rx_buf[total_length + phy->latency - 1];\n\n\treturn st33zp24_status_to_errno(ret);\n}  \n\n \nstatic int st33zp24_spi_read8_reg(void *phy_id, u8 tpm_register, u8 *tpm_data,\n\t\t\t\t  int tpm_size)\n{\n\tint total_length = 0, ret;\n\tstruct st33zp24_spi_phy *phy = phy_id;\n\tstruct spi_device *dev = phy->spi_device;\n\tstruct spi_transfer spi_xfer = {\n\t\t.tx_buf = phy->tx_buf,\n\t\t.rx_buf = phy->rx_buf,\n\t};\n\n\t \n\tphy->tx_buf[total_length++] = LOCALITY0;\n\tphy->tx_buf[total_length++] = tpm_register;\n\n\tmemset(&phy->tx_buf[total_length], TPM_DUMMY_BYTE,\n\t       phy->latency + tpm_size);\n\n\tspi_xfer.len = total_length + phy->latency + tpm_size;\n\n\t \n\tret = spi_sync_transfer(dev, &spi_xfer, 1);\n\tif (tpm_size > 0 && ret == 0) {\n\t\tret = phy->rx_buf[total_length + phy->latency - 1];\n\n\t\tmemcpy(tpm_data, phy->rx_buf + total_length + phy->latency,\n\t\t       tpm_size);\n\t}\n\n\treturn ret;\n}  \n\n \nstatic int st33zp24_spi_recv(void *phy_id, u8 tpm_register, u8 *tpm_data,\n\t\t\t     int tpm_size)\n{\n\tint ret;\n\n\tret = st33zp24_spi_read8_reg(phy_id, tpm_register, tpm_data, tpm_size);\n\tif (!st33zp24_status_to_errno(ret))\n\t\treturn tpm_size;\n\treturn ret;\n}  \n\nstatic int st33zp24_spi_evaluate_latency(void *phy_id)\n{\n\tstruct st33zp24_spi_phy *phy = phy_id;\n\tint latency = 1, status = 0;\n\tu8 data = 0;\n\n\twhile (!status && latency < MAX_SPI_LATENCY) {\n\t\tphy->latency = latency;\n\t\tstatus = st33zp24_spi_read8_reg(phy_id, TPM_INTF_CAPABILITY,\n\t\t\t\t\t\t&data, 1);\n\t\tlatency++;\n\t}\n\tif (status < 0)\n\t\treturn status;\n\tif (latency == MAX_SPI_LATENCY)\n\t\treturn -ENODEV;\n\n\treturn latency - 1;\n}  \n\nstatic const struct st33zp24_phy_ops spi_phy_ops = {\n\t.send = st33zp24_spi_send,\n\t.recv = st33zp24_spi_recv,\n};\n\n \nstatic int st33zp24_spi_probe(struct spi_device *dev)\n{\n\tstruct st33zp24_spi_phy *phy;\n\n\tphy = devm_kzalloc(&dev->dev, sizeof(struct st33zp24_spi_phy),\n\t\t\t   GFP_KERNEL);\n\tif (!phy)\n\t\treturn -ENOMEM;\n\n\tphy->spi_device = dev;\n\n\tphy->latency = st33zp24_spi_evaluate_latency(phy);\n\tif (phy->latency <= 0)\n\t\treturn -ENODEV;\n\n\treturn st33zp24_probe(phy, &spi_phy_ops, &dev->dev, dev->irq);\n}\n\n \nstatic void st33zp24_spi_remove(struct spi_device *dev)\n{\n\tstruct tpm_chip *chip = spi_get_drvdata(dev);\n\n\tst33zp24_remove(chip);\n}\n\nstatic const struct spi_device_id st33zp24_spi_id[] = {\n\t{TPM_ST33_SPI, 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, st33zp24_spi_id);\n\nstatic const struct of_device_id of_st33zp24_spi_match[] __maybe_unused = {\n\t{ .compatible = \"st,st33zp24-spi\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, of_st33zp24_spi_match);\n\nstatic const struct acpi_device_id st33zp24_spi_acpi_match[] __maybe_unused = {\n\t{\"SMO3324\"},\n\t{}\n};\nMODULE_DEVICE_TABLE(acpi, st33zp24_spi_acpi_match);\n\nstatic SIMPLE_DEV_PM_OPS(st33zp24_spi_ops, st33zp24_pm_suspend,\n\t\t\t st33zp24_pm_resume);\n\nstatic struct spi_driver st33zp24_spi_driver = {\n\t.driver = {\n\t\t.name = \"st33zp24-spi\",\n\t\t.pm = &st33zp24_spi_ops,\n\t\t.of_match_table = of_match_ptr(of_st33zp24_spi_match),\n\t\t.acpi_match_table = ACPI_PTR(st33zp24_spi_acpi_match),\n\t},\n\t.probe = st33zp24_spi_probe,\n\t.remove = st33zp24_spi_remove,\n\t.id_table = st33zp24_spi_id,\n};\n\nmodule_spi_driver(st33zp24_spi_driver);\n\nMODULE_AUTHOR(\"TPM support (TPMsupport@list.st.com)\");\nMODULE_DESCRIPTION(\"STM TPM 1.2 SPI ST33 Driver\");\nMODULE_VERSION(\"1.3.0\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}