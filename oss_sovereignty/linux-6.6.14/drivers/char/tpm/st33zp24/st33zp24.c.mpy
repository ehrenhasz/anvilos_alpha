{
  "module_name": "st33zp24.c",
  "hash_id": "8e9bcb47d9b73a1ac6e94d6c341b6e7a74ed192669337db80e39260e75c003d8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/tpm/st33zp24/st33zp24.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/wait.h>\n#include <linux/freezer.h>\n#include <linux/string.h>\n#include <linux/interrupt.h>\n#include <linux/gpio/consumer.h>\n#include <linux/sched.h>\n#include <linux/uaccess.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n\n#include \"../tpm.h\"\n#include \"st33zp24.h\"\n\n#define TPM_ACCESS\t\t\t0x0\n#define TPM_STS\t\t\t\t0x18\n#define TPM_DATA_FIFO\t\t\t0x24\n#define TPM_INTF_CAPABILITY\t\t0x14\n#define TPM_INT_STATUS\t\t\t0x10\n#define TPM_INT_ENABLE\t\t\t0x08\n\n#define LOCALITY0\t\t\t0\n\nenum st33zp24_access {\n\tTPM_ACCESS_VALID = 0x80,\n\tTPM_ACCESS_ACTIVE_LOCALITY = 0x20,\n\tTPM_ACCESS_REQUEST_PENDING = 0x04,\n\tTPM_ACCESS_REQUEST_USE = 0x02,\n};\n\nenum st33zp24_status {\n\tTPM_STS_VALID = 0x80,\n\tTPM_STS_COMMAND_READY = 0x40,\n\tTPM_STS_GO = 0x20,\n\tTPM_STS_DATA_AVAIL = 0x10,\n\tTPM_STS_DATA_EXPECT = 0x08,\n};\n\nenum st33zp24_int_flags {\n\tTPM_GLOBAL_INT_ENABLE = 0x80,\n\tTPM_INTF_CMD_READY_INT = 0x080,\n\tTPM_INTF_FIFO_AVALAIBLE_INT = 0x040,\n\tTPM_INTF_WAKE_UP_READY_INT = 0x020,\n\tTPM_INTF_LOCALITY_CHANGE_INT = 0x004,\n\tTPM_INTF_STS_VALID_INT = 0x002,\n\tTPM_INTF_DATA_AVAIL_INT = 0x001,\n};\n\nenum tis_defaults {\n\tTIS_SHORT_TIMEOUT = 750,\n\tTIS_LONG_TIMEOUT = 2000,\n};\n\n \nstatic u8 clear_interruption(struct st33zp24_dev *tpm_dev)\n{\n\tu8 interrupt;\n\n\ttpm_dev->ops->recv(tpm_dev->phy_id, TPM_INT_STATUS, &interrupt, 1);\n\ttpm_dev->ops->send(tpm_dev->phy_id, TPM_INT_STATUS, &interrupt, 1);\n\treturn interrupt;\n}\n\n \nstatic void st33zp24_cancel(struct tpm_chip *chip)\n{\n\tstruct st33zp24_dev *tpm_dev = dev_get_drvdata(&chip->dev);\n\tu8 data;\n\n\tdata = TPM_STS_COMMAND_READY;\n\ttpm_dev->ops->send(tpm_dev->phy_id, TPM_STS, &data, 1);\n}\n\n \nstatic u8 st33zp24_status(struct tpm_chip *chip)\n{\n\tstruct st33zp24_dev *tpm_dev = dev_get_drvdata(&chip->dev);\n\tu8 data;\n\n\ttpm_dev->ops->recv(tpm_dev->phy_id, TPM_STS, &data, 1);\n\treturn data;\n}\n\n \nstatic bool check_locality(struct tpm_chip *chip)\n{\n\tstruct st33zp24_dev *tpm_dev = dev_get_drvdata(&chip->dev);\n\tu8 data;\n\tu8 status;\n\n\tstatus = tpm_dev->ops->recv(tpm_dev->phy_id, TPM_ACCESS, &data, 1);\n\tif (status && (data &\n\t\t(TPM_ACCESS_ACTIVE_LOCALITY | TPM_ACCESS_VALID)) ==\n\t\t(TPM_ACCESS_ACTIVE_LOCALITY | TPM_ACCESS_VALID))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int request_locality(struct tpm_chip *chip)\n{\n\tstruct st33zp24_dev *tpm_dev = dev_get_drvdata(&chip->dev);\n\tunsigned long stop;\n\tlong ret;\n\tu8 data;\n\n\tif (check_locality(chip))\n\t\treturn tpm_dev->locality;\n\n\tdata = TPM_ACCESS_REQUEST_USE;\n\tret = tpm_dev->ops->send(tpm_dev->phy_id, TPM_ACCESS, &data, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tstop = jiffies + chip->timeout_a;\n\n\t \n\tdo {\n\t\tif (check_locality(chip))\n\t\t\treturn tpm_dev->locality;\n\t\tmsleep(TPM_TIMEOUT);\n\t} while (time_before(jiffies, stop));\n\n\t \n\treturn -EACCES;\n}\n\nstatic void release_locality(struct tpm_chip *chip)\n{\n\tstruct st33zp24_dev *tpm_dev = dev_get_drvdata(&chip->dev);\n\tu8 data;\n\n\tdata = TPM_ACCESS_ACTIVE_LOCALITY;\n\n\ttpm_dev->ops->send(tpm_dev->phy_id, TPM_ACCESS, &data, 1);\n}\n\n \nstatic int get_burstcount(struct tpm_chip *chip)\n{\n\tstruct st33zp24_dev *tpm_dev = dev_get_drvdata(&chip->dev);\n\tunsigned long stop;\n\tint burstcnt, status;\n\tu8 temp;\n\n\tstop = jiffies + chip->timeout_d;\n\tdo {\n\t\tstatus = tpm_dev->ops->recv(tpm_dev->phy_id, TPM_STS + 1,\n\t\t\t\t\t    &temp, 1);\n\t\tif (status < 0)\n\t\t\treturn -EBUSY;\n\n\t\tburstcnt = temp;\n\t\tstatus = tpm_dev->ops->recv(tpm_dev->phy_id, TPM_STS + 2,\n\t\t\t\t\t    &temp, 1);\n\t\tif (status < 0)\n\t\t\treturn -EBUSY;\n\n\t\tburstcnt |= temp << 8;\n\t\tif (burstcnt)\n\t\t\treturn burstcnt;\n\t\tmsleep(TPM_TIMEOUT);\n\t} while (time_before(jiffies, stop));\n\treturn -EBUSY;\n}\n\nstatic bool wait_for_tpm_stat_cond(struct tpm_chip *chip, u8 mask,\n\t\t\t\tbool check_cancel, bool *canceled)\n{\n\tu8 status = chip->ops->status(chip);\n\n\t*canceled = false;\n\tif ((status & mask) == mask)\n\t\treturn true;\n\tif (check_cancel && chip->ops->req_canceled(chip, status)) {\n\t\t*canceled = true;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nstatic int wait_for_stat(struct tpm_chip *chip, u8 mask, unsigned long timeout,\n\t\t\twait_queue_head_t *queue, bool check_cancel)\n{\n\tstruct st33zp24_dev *tpm_dev = dev_get_drvdata(&chip->dev);\n\tunsigned long stop;\n\tint ret = 0;\n\tbool canceled = false;\n\tbool condition;\n\tu32 cur_intrs;\n\tu8 status;\n\n\t \n\tstatus = st33zp24_status(chip);\n\tif ((status & mask) == mask)\n\t\treturn 0;\n\n\tstop = jiffies + timeout;\n\n\tif (chip->flags & TPM_CHIP_FLAG_IRQ) {\n\t\tcur_intrs = tpm_dev->intrs;\n\t\tclear_interruption(tpm_dev);\n\t\tenable_irq(tpm_dev->irq);\n\n\t\tdo {\n\t\t\tif (ret == -ERESTARTSYS && freezing(current))\n\t\t\t\tclear_thread_flag(TIF_SIGPENDING);\n\n\t\t\ttimeout = stop - jiffies;\n\t\t\tif ((long) timeout <= 0)\n\t\t\t\treturn -1;\n\n\t\t\tret = wait_event_interruptible_timeout(*queue,\n\t\t\t\t\t\tcur_intrs != tpm_dev->intrs,\n\t\t\t\t\t\ttimeout);\n\t\t\tclear_interruption(tpm_dev);\n\t\t\tcondition = wait_for_tpm_stat_cond(chip, mask,\n\t\t\t\t\t\tcheck_cancel, &canceled);\n\t\t\tif (ret >= 0 && condition) {\n\t\t\t\tif (canceled)\n\t\t\t\t\treturn -ECANCELED;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} while (ret == -ERESTARTSYS && freezing(current));\n\n\t\tdisable_irq_nosync(tpm_dev->irq);\n\n\t} else {\n\t\tdo {\n\t\t\tmsleep(TPM_TIMEOUT);\n\t\t\tstatus = chip->ops->status(chip);\n\t\t\tif ((status & mask) == mask)\n\t\t\t\treturn 0;\n\t\t} while (time_before(jiffies, stop));\n\t}\n\n\treturn -ETIME;\n}\n\nstatic int recv_data(struct tpm_chip *chip, u8 *buf, size_t count)\n{\n\tstruct st33zp24_dev *tpm_dev = dev_get_drvdata(&chip->dev);\n\tint size = 0, burstcnt, len, ret;\n\n\twhile (size < count &&\n\t       wait_for_stat(chip,\n\t\t\t     TPM_STS_DATA_AVAIL | TPM_STS_VALID,\n\t\t\t     chip->timeout_c,\n\t\t\t     &tpm_dev->read_queue, true) == 0) {\n\t\tburstcnt = get_burstcount(chip);\n\t\tif (burstcnt < 0)\n\t\t\treturn burstcnt;\n\t\tlen = min_t(int, burstcnt, count - size);\n\t\tret = tpm_dev->ops->recv(tpm_dev->phy_id, TPM_DATA_FIFO,\n\t\t\t\t\t buf + size, len);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tsize += len;\n\t}\n\treturn size;\n}\n\nstatic irqreturn_t tpm_ioserirq_handler(int irq, void *dev_id)\n{\n\tstruct tpm_chip *chip = dev_id;\n\tstruct st33zp24_dev *tpm_dev = dev_get_drvdata(&chip->dev);\n\n\ttpm_dev->intrs++;\n\twake_up_interruptible(&tpm_dev->read_queue);\n\tdisable_irq_nosync(tpm_dev->irq);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int st33zp24_send(struct tpm_chip *chip, unsigned char *buf,\n\t\t\t size_t len)\n{\n\tstruct st33zp24_dev *tpm_dev = dev_get_drvdata(&chip->dev);\n\tu32 status, i, size, ordinal;\n\tint burstcnt = 0;\n\tint ret;\n\tu8 data;\n\n\tif (len < TPM_HEADER_SIZE)\n\t\treturn -EBUSY;\n\n\tret = request_locality(chip);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tstatus = st33zp24_status(chip);\n\tif ((status & TPM_STS_COMMAND_READY) == 0) {\n\t\tst33zp24_cancel(chip);\n\t\tif (wait_for_stat\n\t\t    (chip, TPM_STS_COMMAND_READY, chip->timeout_b,\n\t\t     &tpm_dev->read_queue, false) < 0) {\n\t\t\tret = -ETIME;\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\tfor (i = 0; i < len - 1;) {\n\t\tburstcnt = get_burstcount(chip);\n\t\tif (burstcnt < 0)\n\t\t\treturn burstcnt;\n\t\tsize = min_t(int, len - i - 1, burstcnt);\n\t\tret = tpm_dev->ops->send(tpm_dev->phy_id, TPM_DATA_FIFO,\n\t\t\t\t\t buf + i, size);\n\t\tif (ret < 0)\n\t\t\tgoto out_err;\n\n\t\ti += size;\n\t}\n\n\tstatus = st33zp24_status(chip);\n\tif ((status & TPM_STS_DATA_EXPECT) == 0) {\n\t\tret = -EIO;\n\t\tgoto out_err;\n\t}\n\n\tret = tpm_dev->ops->send(tpm_dev->phy_id, TPM_DATA_FIFO,\n\t\t\t\t buf + len - 1, 1);\n\tif (ret < 0)\n\t\tgoto out_err;\n\n\tstatus = st33zp24_status(chip);\n\tif ((status & TPM_STS_DATA_EXPECT) != 0) {\n\t\tret = -EIO;\n\t\tgoto out_err;\n\t}\n\n\tdata = TPM_STS_GO;\n\tret = tpm_dev->ops->send(tpm_dev->phy_id, TPM_STS, &data, 1);\n\tif (ret < 0)\n\t\tgoto out_err;\n\n\tif (chip->flags & TPM_CHIP_FLAG_IRQ) {\n\t\tordinal = be32_to_cpu(*((__be32 *) (buf + 6)));\n\n\t\tret = wait_for_stat(chip, TPM_STS_DATA_AVAIL | TPM_STS_VALID,\n\t\t\t\ttpm_calc_ordinal_duration(chip, ordinal),\n\t\t\t\t&tpm_dev->read_queue, false);\n\t\tif (ret < 0)\n\t\t\tgoto out_err;\n\t}\n\n\treturn 0;\nout_err:\n\tst33zp24_cancel(chip);\n\trelease_locality(chip);\n\treturn ret;\n}\n\nstatic int st33zp24_recv(struct tpm_chip *chip, unsigned char *buf,\n\t\t\t    size_t count)\n{\n\tint size = 0;\n\tu32 expected;\n\n\tif (!chip)\n\t\treturn -EBUSY;\n\n\tif (count < TPM_HEADER_SIZE) {\n\t\tsize = -EIO;\n\t\tgoto out;\n\t}\n\n\tsize = recv_data(chip, buf, TPM_HEADER_SIZE);\n\tif (size < TPM_HEADER_SIZE) {\n\t\tdev_err(&chip->dev, \"Unable to read header\\n\");\n\t\tgoto out;\n\t}\n\n\texpected = be32_to_cpu(*(__be32 *)(buf + 2));\n\tif (expected > count || expected < TPM_HEADER_SIZE) {\n\t\tsize = -EIO;\n\t\tgoto out;\n\t}\n\n\tsize += recv_data(chip, &buf[TPM_HEADER_SIZE],\n\t\t\texpected - TPM_HEADER_SIZE);\n\tif (size < expected) {\n\t\tdev_err(&chip->dev, \"Unable to read remainder of result\\n\");\n\t\tsize = -ETIME;\n\t}\n\nout:\n\tst33zp24_cancel(chip);\n\trelease_locality(chip);\n\treturn size;\n}\n\nstatic bool st33zp24_req_canceled(struct tpm_chip *chip, u8 status)\n{\n\treturn (status == TPM_STS_COMMAND_READY);\n}\n\nstatic const struct tpm_class_ops st33zp24_tpm = {\n\t.flags = TPM_OPS_AUTO_STARTUP,\n\t.send = st33zp24_send,\n\t.recv = st33zp24_recv,\n\t.cancel = st33zp24_cancel,\n\t.status = st33zp24_status,\n\t.req_complete_mask = TPM_STS_DATA_AVAIL | TPM_STS_VALID,\n\t.req_complete_val = TPM_STS_DATA_AVAIL | TPM_STS_VALID,\n\t.req_canceled = st33zp24_req_canceled,\n};\n\nstatic const struct acpi_gpio_params lpcpd_gpios = { 1, 0, false };\n\nstatic const struct acpi_gpio_mapping acpi_st33zp24_gpios[] = {\n\t{ \"lpcpd-gpios\", &lpcpd_gpios, 1 },\n\t{ },\n};\n\n \nint st33zp24_probe(void *phy_id, const struct st33zp24_phy_ops *ops,\n\t\t   struct device *dev, int irq)\n{\n\tint ret;\n\tu8 intmask = 0;\n\tstruct tpm_chip *chip;\n\tstruct st33zp24_dev *tpm_dev;\n\n\tchip = tpmm_chip_alloc(dev, &st33zp24_tpm);\n\tif (IS_ERR(chip))\n\t\treturn PTR_ERR(chip);\n\n\ttpm_dev = devm_kzalloc(dev, sizeof(struct st33zp24_dev),\n\t\t\t       GFP_KERNEL);\n\tif (!tpm_dev)\n\t\treturn -ENOMEM;\n\n\ttpm_dev->phy_id = phy_id;\n\ttpm_dev->ops = ops;\n\tdev_set_drvdata(&chip->dev, tpm_dev);\n\n\tchip->timeout_a = msecs_to_jiffies(TIS_SHORT_TIMEOUT);\n\tchip->timeout_b = msecs_to_jiffies(TIS_LONG_TIMEOUT);\n\tchip->timeout_c = msecs_to_jiffies(TIS_SHORT_TIMEOUT);\n\tchip->timeout_d = msecs_to_jiffies(TIS_SHORT_TIMEOUT);\n\n\ttpm_dev->locality = LOCALITY0;\n\n\tif (ACPI_COMPANION(dev)) {\n\t\tret = devm_acpi_dev_add_driver_gpios(dev, acpi_st33zp24_gpios);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\ttpm_dev->io_lpcpd = devm_gpiod_get_optional(dev, \"lpcpd\",\n\t\t\t\t\t\t    GPIOD_OUT_HIGH);\n\tret = PTR_ERR_OR_ZERO(tpm_dev->io_lpcpd);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to request lpcpd gpio: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (irq) {\n\t\t \n\t\tinit_waitqueue_head(&tpm_dev->read_queue);\n\t\ttpm_dev->intrs = 0;\n\n\t\tif (request_locality(chip) != LOCALITY0) {\n\t\t\tret = -ENODEV;\n\t\t\tgoto _tpm_clean_answer;\n\t\t}\n\n\t\tclear_interruption(tpm_dev);\n\t\tret = devm_request_irq(dev, irq, tpm_ioserirq_handler,\n\t\t\t\tIRQF_TRIGGER_HIGH, \"TPM SERIRQ management\",\n\t\t\t\tchip);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&chip->dev, \"TPM SERIRQ signals %d not available\\n\",\n\t\t\t\tirq);\n\t\t\tgoto _tpm_clean_answer;\n\t\t}\n\n\t\tintmask |= TPM_INTF_CMD_READY_INT\n\t\t\t|  TPM_INTF_STS_VALID_INT\n\t\t\t|  TPM_INTF_DATA_AVAIL_INT;\n\n\t\tret = tpm_dev->ops->send(tpm_dev->phy_id, TPM_INT_ENABLE,\n\t\t\t\t\t &intmask, 1);\n\t\tif (ret < 0)\n\t\t\tgoto _tpm_clean_answer;\n\n\t\tintmask = TPM_GLOBAL_INT_ENABLE;\n\t\tret = tpm_dev->ops->send(tpm_dev->phy_id, (TPM_INT_ENABLE + 3),\n\t\t\t\t\t &intmask, 1);\n\t\tif (ret < 0)\n\t\t\tgoto _tpm_clean_answer;\n\n\t\ttpm_dev->irq = irq;\n\t\tchip->flags |= TPM_CHIP_FLAG_IRQ;\n\n\t\tdisable_irq_nosync(tpm_dev->irq);\n\t}\n\n\treturn tpm_chip_register(chip);\n_tpm_clean_answer:\n\tdev_info(&chip->dev, \"TPM initialization fail\\n\");\n\treturn ret;\n}\nEXPORT_SYMBOL(st33zp24_probe);\n\nvoid st33zp24_remove(struct tpm_chip *chip)\n{\n\ttpm_chip_unregister(chip);\n}\nEXPORT_SYMBOL(st33zp24_remove);\n\n#ifdef CONFIG_PM_SLEEP\nint st33zp24_pm_suspend(struct device *dev)\n{\n\tstruct tpm_chip *chip = dev_get_drvdata(dev);\n\tstruct st33zp24_dev *tpm_dev = dev_get_drvdata(&chip->dev);\n\n\tint ret = 0;\n\n\tif (tpm_dev->io_lpcpd)\n\t\tgpiod_set_value_cansleep(tpm_dev->io_lpcpd, 0);\n\telse\n\t\tret = tpm_pm_suspend(dev);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(st33zp24_pm_suspend);\n\nint st33zp24_pm_resume(struct device *dev)\n{\n\tstruct tpm_chip *chip = dev_get_drvdata(dev);\n\tstruct st33zp24_dev *tpm_dev = dev_get_drvdata(&chip->dev);\n\tint ret = 0;\n\n\tif (tpm_dev->io_lpcpd) {\n\t\tgpiod_set_value_cansleep(tpm_dev->io_lpcpd, 1);\n\t\tret = wait_for_stat(chip,\n\t\t\t\tTPM_STS_VALID, chip->timeout_b,\n\t\t\t\t&tpm_dev->read_queue, false);\n\t} else {\n\t\tret = tpm_pm_resume(dev);\n\t\tif (!ret)\n\t\t\ttpm1_do_selftest(chip);\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL(st33zp24_pm_resume);\n#endif\n\nMODULE_AUTHOR(\"TPM support (TPMsupport@list.st.com)\");\nMODULE_DESCRIPTION(\"ST33ZP24 TPM 1.2 driver\");\nMODULE_VERSION(\"1.3.0\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}