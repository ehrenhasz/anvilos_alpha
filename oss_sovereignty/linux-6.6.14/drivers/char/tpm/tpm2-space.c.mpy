{
  "module_name": "tpm2-space.c",
  "hash_id": "d5d5fc509c4dd16b0e938f4bac7c4940eaadca68ff4433e17ec12773f7d86f9c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/tpm/tpm2-space.c",
  "human_readable_source": "\n \n\n#include <linux/gfp.h>\n#include <asm/unaligned.h>\n#include \"tpm.h\"\n\nenum tpm2_handle_types {\n\tTPM2_HT_HMAC_SESSION\t= 0x02000000,\n\tTPM2_HT_POLICY_SESSION\t= 0x03000000,\n\tTPM2_HT_TRANSIENT\t= 0x80000000,\n};\n\nstruct tpm2_context {\n\t__be64 sequence;\n\t__be32 saved_handle;\n\t__be32 hierarchy;\n\t__be16 blob_size;\n} __packed;\n\nstatic void tpm2_flush_sessions(struct tpm_chip *chip, struct tpm_space *space)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(space->session_tbl); i++) {\n\t\tif (space->session_tbl[i])\n\t\t\ttpm2_flush_context(chip, space->session_tbl[i]);\n\t}\n}\n\nint tpm2_init_space(struct tpm_space *space, unsigned int buf_size)\n{\n\tspace->context_buf = kzalloc(buf_size, GFP_KERNEL);\n\tif (!space->context_buf)\n\t\treturn -ENOMEM;\n\n\tspace->session_buf = kzalloc(buf_size, GFP_KERNEL);\n\tif (space->session_buf == NULL) {\n\t\tkfree(space->context_buf);\n\t\t \n\t\tspace->context_buf = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\tspace->buf_size = buf_size;\n\treturn 0;\n}\n\nvoid tpm2_del_space(struct tpm_chip *chip, struct tpm_space *space)\n{\n\n\tif (tpm_try_get_ops(chip) == 0) {\n\t\ttpm2_flush_sessions(chip, space);\n\t\ttpm_put_ops(chip);\n\t}\n\n\tkfree(space->context_buf);\n\tkfree(space->session_buf);\n}\n\nstatic int tpm2_load_context(struct tpm_chip *chip, u8 *buf,\n\t\t\t     unsigned int *offset, u32 *handle)\n{\n\tstruct tpm_buf tbuf;\n\tstruct tpm2_context *ctx;\n\tunsigned int body_size;\n\tint rc;\n\n\trc = tpm_buf_init(&tbuf, TPM2_ST_NO_SESSIONS, TPM2_CC_CONTEXT_LOAD);\n\tif (rc)\n\t\treturn rc;\n\n\tctx = (struct tpm2_context *)&buf[*offset];\n\tbody_size = sizeof(*ctx) + be16_to_cpu(ctx->blob_size);\n\ttpm_buf_append(&tbuf, &buf[*offset], body_size);\n\n\trc = tpm_transmit_cmd(chip, &tbuf, 4, NULL);\n\tif (rc < 0) {\n\t\tdev_warn(&chip->dev, \"%s: failed with a system error %d\\n\",\n\t\t\t __func__, rc);\n\t\ttpm_buf_destroy(&tbuf);\n\t\treturn -EFAULT;\n\t} else if (tpm2_rc_value(rc) == TPM2_RC_HANDLE ||\n\t\t   rc == TPM2_RC_REFERENCE_H0) {\n\t\t \n\t\t*handle = 0;\n\t\ttpm_buf_destroy(&tbuf);\n\t\treturn -ENOENT;\n\t} else if (rc > 0) {\n\t\tdev_warn(&chip->dev, \"%s: failed with a TPM error 0x%04X\\n\",\n\t\t\t __func__, rc);\n\t\ttpm_buf_destroy(&tbuf);\n\t\treturn -EFAULT;\n\t}\n\n\t*handle = be32_to_cpup((__be32 *)&tbuf.data[TPM_HEADER_SIZE]);\n\t*offset += body_size;\n\n\ttpm_buf_destroy(&tbuf);\n\treturn 0;\n}\n\nstatic int tpm2_save_context(struct tpm_chip *chip, u32 handle, u8 *buf,\n\t\t\t     unsigned int buf_size, unsigned int *offset)\n{\n\tstruct tpm_buf tbuf;\n\tunsigned int body_size;\n\tint rc;\n\n\trc = tpm_buf_init(&tbuf, TPM2_ST_NO_SESSIONS, TPM2_CC_CONTEXT_SAVE);\n\tif (rc)\n\t\treturn rc;\n\n\ttpm_buf_append_u32(&tbuf, handle);\n\n\trc = tpm_transmit_cmd(chip, &tbuf, 0, NULL);\n\tif (rc < 0) {\n\t\tdev_warn(&chip->dev, \"%s: failed with a system error %d\\n\",\n\t\t\t __func__, rc);\n\t\ttpm_buf_destroy(&tbuf);\n\t\treturn -EFAULT;\n\t} else if (tpm2_rc_value(rc) == TPM2_RC_REFERENCE_H0) {\n\t\ttpm_buf_destroy(&tbuf);\n\t\treturn -ENOENT;\n\t} else if (rc) {\n\t\tdev_warn(&chip->dev, \"%s: failed with a TPM error 0x%04X\\n\",\n\t\t\t __func__, rc);\n\t\ttpm_buf_destroy(&tbuf);\n\t\treturn -EFAULT;\n\t}\n\n\tbody_size = tpm_buf_length(&tbuf) - TPM_HEADER_SIZE;\n\tif ((*offset + body_size) > buf_size) {\n\t\tdev_warn(&chip->dev, \"%s: out of backing storage\\n\", __func__);\n\t\ttpm_buf_destroy(&tbuf);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemcpy(&buf[*offset], &tbuf.data[TPM_HEADER_SIZE], body_size);\n\t*offset += body_size;\n\ttpm_buf_destroy(&tbuf);\n\treturn 0;\n}\n\nvoid tpm2_flush_space(struct tpm_chip *chip)\n{\n\tstruct tpm_space *space = &chip->work_space;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(space->context_tbl); i++)\n\t\tif (space->context_tbl[i] && ~space->context_tbl[i])\n\t\t\ttpm2_flush_context(chip, space->context_tbl[i]);\n\n\ttpm2_flush_sessions(chip, space);\n}\n\nstatic int tpm2_load_space(struct tpm_chip *chip)\n{\n\tstruct tpm_space *space = &chip->work_space;\n\tunsigned int offset;\n\tint i;\n\tint rc;\n\n\tfor (i = 0, offset = 0; i < ARRAY_SIZE(space->context_tbl); i++) {\n\t\tif (!space->context_tbl[i])\n\t\t\tcontinue;\n\n\t\t \n\t\tif (~space->context_tbl[i]) {\n\t\t\tdev_err(&chip->dev, \"context table is inconsistent\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\trc = tpm2_load_context(chip, space->context_buf, &offset,\n\t\t\t\t       &space->context_tbl[i]);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tfor (i = 0, offset = 0; i < ARRAY_SIZE(space->session_tbl); i++) {\n\t\tu32 handle;\n\n\t\tif (!space->session_tbl[i])\n\t\t\tcontinue;\n\n\t\trc = tpm2_load_context(chip, space->session_buf,\n\t\t\t\t       &offset, &handle);\n\t\tif (rc == -ENOENT) {\n\t\t\t \n\t\t\tspace->session_tbl[i] = 0;\n\t\t} else if (rc) {\n\t\t\ttpm2_flush_space(chip);\n\t\t\treturn rc;\n\t\t}\n\t\tif (handle != space->session_tbl[i]) {\n\t\t\tdev_warn(&chip->dev, \"session restored to wrong handle\\n\");\n\t\t\ttpm2_flush_space(chip);\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic bool tpm2_map_to_phandle(struct tpm_space *space, void *handle)\n{\n\tu32 vhandle = be32_to_cpup((__be32 *)handle);\n\tu32 phandle;\n\tint i;\n\n\ti = 0xFFFFFF - (vhandle & 0xFFFFFF);\n\tif (i >= ARRAY_SIZE(space->context_tbl) || !space->context_tbl[i])\n\t\treturn false;\n\n\tphandle = space->context_tbl[i];\n\t*((__be32 *)handle) = cpu_to_be32(phandle);\n\treturn true;\n}\n\nstatic int tpm2_map_command(struct tpm_chip *chip, u32 cc, u8 *cmd)\n{\n\tstruct tpm_space *space = &chip->work_space;\n\tunsigned int nr_handles;\n\tu32 attrs;\n\t__be32 *handle;\n\tint i;\n\n\ti = tpm2_find_cc(chip, cc);\n\tif (i < 0)\n\t\treturn -EINVAL;\n\n\tattrs = chip->cc_attrs_tbl[i];\n\tnr_handles = (attrs >> TPM2_CC_ATTR_CHANDLES) & GENMASK(2, 0);\n\n\thandle = (__be32 *)&cmd[TPM_HEADER_SIZE];\n\tfor (i = 0; i < nr_handles; i++, handle++) {\n\t\tif ((be32_to_cpu(*handle) & 0xFF000000) == TPM2_HT_TRANSIENT) {\n\t\t\tif (!tpm2_map_to_phandle(space, handle))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int tpm_find_and_validate_cc(struct tpm_chip *chip,\n\t\t\t\t    struct tpm_space *space,\n\t\t\t\t    const void *cmd, size_t len)\n{\n\tconst struct tpm_header *header = (const void *)cmd;\n\tint i;\n\tu32 cc;\n\tu32 attrs;\n\tunsigned int nr_handles;\n\n\tif (len < TPM_HEADER_SIZE || !chip->nr_commands)\n\t\treturn -EINVAL;\n\n\tcc = be32_to_cpu(header->ordinal);\n\n\ti = tpm2_find_cc(chip, cc);\n\tif (i < 0) {\n\t\tdev_dbg(&chip->dev, \"0x%04X is an invalid command\\n\",\n\t\t\tcc);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tattrs = chip->cc_attrs_tbl[i];\n\tnr_handles =\n\t\t4 * ((attrs >> TPM2_CC_ATTR_CHANDLES) & GENMASK(2, 0));\n\tif (len < TPM_HEADER_SIZE + 4 * nr_handles)\n\t\tgoto err_len;\n\n\treturn cc;\nerr_len:\n\tdev_dbg(&chip->dev, \"%s: insufficient command length %zu\", __func__,\n\t\tlen);\n\treturn -EINVAL;\n}\n\nint tpm2_prepare_space(struct tpm_chip *chip, struct tpm_space *space, u8 *cmd,\n\t\t       size_t cmdsiz)\n{\n\tint rc;\n\tint cc;\n\n\tif (!space)\n\t\treturn 0;\n\n\tcc = tpm_find_and_validate_cc(chip, space, cmd, cmdsiz);\n\tif (cc < 0)\n\t\treturn cc;\n\n\tmemcpy(&chip->work_space.context_tbl, &space->context_tbl,\n\t       sizeof(space->context_tbl));\n\tmemcpy(&chip->work_space.session_tbl, &space->session_tbl,\n\t       sizeof(space->session_tbl));\n\tmemcpy(chip->work_space.context_buf, space->context_buf,\n\t       space->buf_size);\n\tmemcpy(chip->work_space.session_buf, space->session_buf,\n\t       space->buf_size);\n\n\trc = tpm2_load_space(chip);\n\tif (rc) {\n\t\ttpm2_flush_space(chip);\n\t\treturn rc;\n\t}\n\n\trc = tpm2_map_command(chip, cc, cmd);\n\tif (rc) {\n\t\ttpm2_flush_space(chip);\n\t\treturn rc;\n\t}\n\n\tchip->last_cc = cc;\n\treturn 0;\n}\n\nstatic bool tpm2_add_session(struct tpm_chip *chip, u32 handle)\n{\n\tstruct tpm_space *space = &chip->work_space;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(space->session_tbl); i++)\n\t\tif (space->session_tbl[i] == 0)\n\t\t\tbreak;\n\n\tif (i == ARRAY_SIZE(space->session_tbl))\n\t\treturn false;\n\n\tspace->session_tbl[i] = handle;\n\treturn true;\n}\n\nstatic u32 tpm2_map_to_vhandle(struct tpm_space *space, u32 phandle, bool alloc)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(space->context_tbl); i++) {\n\t\tif (alloc) {\n\t\t\tif (!space->context_tbl[i]) {\n\t\t\t\tspace->context_tbl[i] = phandle;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (space->context_tbl[i] == phandle)\n\t\t\tbreak;\n\t}\n\n\tif (i == ARRAY_SIZE(space->context_tbl))\n\t\treturn 0;\n\n\treturn TPM2_HT_TRANSIENT | (0xFFFFFF - i);\n}\n\nstatic int tpm2_map_response_header(struct tpm_chip *chip, u32 cc, u8 *rsp,\n\t\t\t\t    size_t len)\n{\n\tstruct tpm_space *space = &chip->work_space;\n\tstruct tpm_header *header = (struct tpm_header *)rsp;\n\tu32 phandle;\n\tu32 phandle_type;\n\tu32 vhandle;\n\tu32 attrs;\n\tint i;\n\n\tif (be32_to_cpu(header->return_code) != TPM2_RC_SUCCESS)\n\t\treturn 0;\n\n\ti = tpm2_find_cc(chip, cc);\n\t \n\tif (i < 0)\n\t\treturn -EFAULT;\n\n\tattrs = chip->cc_attrs_tbl[i];\n\tif (!((attrs >> TPM2_CC_ATTR_RHANDLE) & 1))\n\t\treturn 0;\n\n\tphandle = be32_to_cpup((__be32 *)&rsp[TPM_HEADER_SIZE]);\n\tphandle_type = phandle & 0xFF000000;\n\n\tswitch (phandle_type) {\n\tcase TPM2_HT_TRANSIENT:\n\t\tvhandle = tpm2_map_to_vhandle(space, phandle, true);\n\t\tif (!vhandle)\n\t\t\tgoto out_no_slots;\n\n\t\t*(__be32 *)&rsp[TPM_HEADER_SIZE] = cpu_to_be32(vhandle);\n\t\tbreak;\n\tcase TPM2_HT_HMAC_SESSION:\n\tcase TPM2_HT_POLICY_SESSION:\n\t\tif (!tpm2_add_session(chip, phandle))\n\t\t\tgoto out_no_slots;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&chip->dev, \"%s: unknown handle 0x%08X\\n\",\n\t\t\t__func__, phandle);\n\t\tbreak;\n\t}\n\n\treturn 0;\nout_no_slots:\n\ttpm2_flush_context(chip, phandle);\n\tdev_warn(&chip->dev, \"%s: out of slots for 0x%08X\\n\", __func__,\n\t\t phandle);\n\treturn -ENOMEM;\n}\n\nstruct tpm2_cap_handles {\n\tu8 more_data;\n\t__be32 capability;\n\t__be32 count;\n\t__be32 handles[];\n} __packed;\n\nstatic int tpm2_map_response_body(struct tpm_chip *chip, u32 cc, u8 *rsp,\n\t\t\t\t  size_t len)\n{\n\tstruct tpm_space *space = &chip->work_space;\n\tstruct tpm_header *header = (struct tpm_header *)rsp;\n\tstruct tpm2_cap_handles *data;\n\tu32 phandle;\n\tu32 phandle_type;\n\tu32 vhandle;\n\tint i;\n\tint j;\n\n\tif (cc != TPM2_CC_GET_CAPABILITY ||\n\t    be32_to_cpu(header->return_code) != TPM2_RC_SUCCESS) {\n\t\treturn 0;\n\t}\n\n\tif (len < TPM_HEADER_SIZE + 9)\n\t\treturn -EFAULT;\n\n\tdata = (void *)&rsp[TPM_HEADER_SIZE];\n\tif (be32_to_cpu(data->capability) != TPM2_CAP_HANDLES)\n\t\treturn 0;\n\n\tif (be32_to_cpu(data->count) > (UINT_MAX - TPM_HEADER_SIZE - 9) / 4)\n\t\treturn -EFAULT;\n\n\tif (len != TPM_HEADER_SIZE + 9 + 4 * be32_to_cpu(data->count))\n\t\treturn -EFAULT;\n\n\tfor (i = 0, j = 0; i < be32_to_cpu(data->count); i++) {\n\t\tphandle = be32_to_cpup((__be32 *)&data->handles[i]);\n\t\tphandle_type = phandle & 0xFF000000;\n\n\t\tswitch (phandle_type) {\n\t\tcase TPM2_HT_TRANSIENT:\n\t\t\tvhandle = tpm2_map_to_vhandle(space, phandle, false);\n\t\t\tif (!vhandle)\n\t\t\t\tbreak;\n\n\t\t\tdata->handles[j] = cpu_to_be32(vhandle);\n\t\t\tj++;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdata->handles[j] = cpu_to_be32(phandle);\n\t\t\tj++;\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\theader->length = cpu_to_be32(TPM_HEADER_SIZE + 9 + 4 * j);\n\tdata->count = cpu_to_be32(j);\n\treturn 0;\n}\n\nstatic int tpm2_save_space(struct tpm_chip *chip)\n{\n\tstruct tpm_space *space = &chip->work_space;\n\tunsigned int offset;\n\tint i;\n\tint rc;\n\n\tfor (i = 0, offset = 0; i < ARRAY_SIZE(space->context_tbl); i++) {\n\t\tif (!(space->context_tbl[i] && ~space->context_tbl[i]))\n\t\t\tcontinue;\n\n\t\trc = tpm2_save_context(chip, space->context_tbl[i],\n\t\t\t\t       space->context_buf, space->buf_size,\n\t\t\t\t       &offset);\n\t\tif (rc == -ENOENT) {\n\t\t\tspace->context_tbl[i] = 0;\n\t\t\tcontinue;\n\t\t} else if (rc)\n\t\t\treturn rc;\n\n\t\ttpm2_flush_context(chip, space->context_tbl[i]);\n\t\tspace->context_tbl[i] = ~0;\n\t}\n\n\tfor (i = 0, offset = 0; i < ARRAY_SIZE(space->session_tbl); i++) {\n\t\tif (!space->session_tbl[i])\n\t\t\tcontinue;\n\n\t\trc = tpm2_save_context(chip, space->session_tbl[i],\n\t\t\t\t       space->session_buf, space->buf_size,\n\t\t\t\t       &offset);\n\t\tif (rc == -ENOENT) {\n\t\t\t \n\t\t\tspace->session_tbl[i] = 0;\n\t\t} else if (rc < 0) {\n\t\t\ttpm2_flush_space(chip);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint tpm2_commit_space(struct tpm_chip *chip, struct tpm_space *space,\n\t\t      void *buf, size_t *bufsiz)\n{\n\tstruct tpm_header *header = buf;\n\tint rc;\n\n\tif (!space)\n\t\treturn 0;\n\n\trc = tpm2_map_response_header(chip, chip->last_cc, buf, *bufsiz);\n\tif (rc) {\n\t\ttpm2_flush_space(chip);\n\t\tgoto out;\n\t}\n\n\trc = tpm2_map_response_body(chip, chip->last_cc, buf, *bufsiz);\n\tif (rc) {\n\t\ttpm2_flush_space(chip);\n\t\tgoto out;\n\t}\n\n\trc = tpm2_save_space(chip);\n\tif (rc) {\n\t\ttpm2_flush_space(chip);\n\t\tgoto out;\n\t}\n\n\t*bufsiz = be32_to_cpu(header->length);\n\n\tmemcpy(&space->context_tbl, &chip->work_space.context_tbl,\n\t       sizeof(space->context_tbl));\n\tmemcpy(&space->session_tbl, &chip->work_space.session_tbl,\n\t       sizeof(space->session_tbl));\n\tmemcpy(space->context_buf, chip->work_space.context_buf,\n\t       space->buf_size);\n\tmemcpy(space->session_buf, chip->work_space.session_buf,\n\t       space->buf_size);\n\n\treturn 0;\nout:\n\tdev_err(&chip->dev, \"%s: error %d\\n\", __func__, rc);\n\treturn rc;\n}\n\n \nstatic void tpm_devs_release(struct device *dev)\n{\n\tstruct tpm_chip *chip = container_of(dev, struct tpm_chip, devs);\n\n\t \n\tput_device(&chip->dev);\n}\n\n \nvoid tpm_devs_remove(struct tpm_chip *chip)\n{\n\tcdev_device_del(&chip->cdevs, &chip->devs);\n\tput_device(&chip->devs);\n}\n\n \nint tpm_devs_add(struct tpm_chip *chip)\n{\n\tint rc;\n\n\tdevice_initialize(&chip->devs);\n\tchip->devs.parent = chip->dev.parent;\n\tchip->devs.class = &tpmrm_class;\n\n\t \n\tget_device(&chip->dev);\n\tchip->devs.release = tpm_devs_release;\n\tchip->devs.devt = MKDEV(MAJOR(tpm_devt), chip->dev_num + TPM_NUM_DEVICES);\n\tcdev_init(&chip->cdevs, &tpmrm_fops);\n\tchip->cdevs.owner = THIS_MODULE;\n\n\trc = dev_set_name(&chip->devs, \"tpmrm%d\", chip->dev_num);\n\tif (rc)\n\t\tgoto err_put_devs;\n\n\trc = cdev_device_add(&chip->cdevs, &chip->devs);\n\tif (rc) {\n\t\tdev_err(&chip->devs,\n\t\t\t\"unable to cdev_device_add() %s, major %d, minor %d, err=%d\\n\",\n\t\t\tdev_name(&chip->devs), MAJOR(chip->devs.devt),\n\t\t\tMINOR(chip->devs.devt), rc);\n\t\tgoto err_put_devs;\n\t}\n\n\treturn 0;\n\nerr_put_devs:\n\tput_device(&chip->devs);\n\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}