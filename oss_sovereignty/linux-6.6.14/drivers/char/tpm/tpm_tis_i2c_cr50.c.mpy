{
  "module_name": "tpm_tis_i2c_cr50.c",
  "hash_id": "275a3a688ff9eb9d045860a0c2f558bdc4c161c615a8f4912c113709ef4d1cbe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/tpm/tpm_tis_i2c_cr50.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/completion.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/pm.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n\n#include \"tpm_tis_core.h\"\n\n#define TPM_CR50_MAX_BUFSIZE\t\t64\n#define TPM_CR50_TIMEOUT_SHORT_MS\t2\t\t \n#define TPM_CR50_TIMEOUT_NOIRQ_MS\t20\t\t \n#define TPM_CR50_I2C_DID_VID\t\t0x00281ae0L\t \n#define TPM_TI50_I2C_DID_VID\t\t0x504a6666L\t \n#define TPM_CR50_I2C_MAX_RETRIES\t3\t\t \n#define TPM_CR50_I2C_RETRY_DELAY_LO\t55\t\t \n#define TPM_CR50_I2C_RETRY_DELAY_HI\t65\t\t \n\n#define TPM_I2C_ACCESS(l)\t(0x0000 | ((l) << 4))\n#define TPM_I2C_STS(l)\t\t(0x0001 | ((l) << 4))\n#define TPM_I2C_DATA_FIFO(l)\t(0x0005 | ((l) << 4))\n#define TPM_I2C_DID_VID(l)\t(0x0006 | ((l) << 4))\n\n \nstruct tpm_i2c_cr50_priv_data {\n\tint irq;\n\tstruct completion tpm_ready;\n\tu8 buf[TPM_CR50_MAX_BUFSIZE];\n};\n\n \nstatic irqreturn_t tpm_cr50_i2c_int_handler(int dummy, void *tpm_info)\n{\n\tstruct tpm_chip *chip = tpm_info;\n\tstruct tpm_i2c_cr50_priv_data *priv = dev_get_drvdata(&chip->dev);\n\n\tcomplete(&priv->tpm_ready);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int tpm_cr50_i2c_wait_tpm_ready(struct tpm_chip *chip)\n{\n\tstruct tpm_i2c_cr50_priv_data *priv = dev_get_drvdata(&chip->dev);\n\n\t \n\tif (priv->irq <= 0) {\n\t\tmsleep(TPM_CR50_TIMEOUT_NOIRQ_MS);\n\t\treturn 0;\n\t}\n\n\t \n\tif (!wait_for_completion_timeout(&priv->tpm_ready, chip->timeout_a)) {\n\t\tdev_warn(&chip->dev, \"Timeout waiting for TPM ready\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void tpm_cr50_i2c_enable_tpm_irq(struct tpm_chip *chip)\n{\n\tstruct tpm_i2c_cr50_priv_data *priv = dev_get_drvdata(&chip->dev);\n\n\tif (priv->irq > 0) {\n\t\treinit_completion(&priv->tpm_ready);\n\t\tenable_irq(priv->irq);\n\t}\n}\n\n \nstatic void tpm_cr50_i2c_disable_tpm_irq(struct tpm_chip *chip)\n{\n\tstruct tpm_i2c_cr50_priv_data *priv = dev_get_drvdata(&chip->dev);\n\n\tif (priv->irq > 0)\n\t\tdisable_irq(priv->irq);\n}\n\n \nstatic int tpm_cr50_i2c_transfer_message(struct device *dev,\n\t\t\t\t\t struct i2c_adapter *adapter,\n\t\t\t\t\t struct i2c_msg *msg)\n{\n\tunsigned int try;\n\tint rc;\n\n\tfor (try = 0; try < TPM_CR50_I2C_MAX_RETRIES; try++) {\n\t\trc = __i2c_transfer(adapter, msg, 1);\n\t\tif (rc == 1)\n\t\t\treturn 0;  \n\t\tif (try)\n\t\t\tdev_warn(dev, \"i2c transfer failed (attempt %d/%d): %d\\n\",\n\t\t\t\t try + 1, TPM_CR50_I2C_MAX_RETRIES, rc);\n\t\tusleep_range(TPM_CR50_I2C_RETRY_DELAY_LO, TPM_CR50_I2C_RETRY_DELAY_HI);\n\t}\n\n\t \n\treturn -EIO;\n}\n\n \nstatic int tpm_cr50_i2c_read(struct tpm_chip *chip, u8 addr, u8 *buffer, size_t len)\n{\n\tstruct i2c_client *client = to_i2c_client(chip->dev.parent);\n\tstruct i2c_msg msg_reg_addr = {\n\t\t.addr = client->addr,\n\t\t.len = 1,\n\t\t.buf = &addr\n\t};\n\tstruct i2c_msg msg_response = {\n\t\t.addr = client->addr,\n\t\t.flags = I2C_M_RD,\n\t\t.len = len,\n\t\t.buf = buffer\n\t};\n\tint rc;\n\n\ti2c_lock_bus(client->adapter, I2C_LOCK_SEGMENT);\n\n\t \n\ttpm_cr50_i2c_enable_tpm_irq(chip);\n\n\t \n\trc = tpm_cr50_i2c_transfer_message(&chip->dev, client->adapter, &msg_reg_addr);\n\tif (rc < 0)\n\t\tgoto out;\n\n\t \n\trc = tpm_cr50_i2c_wait_tpm_ready(chip);\n\tif (rc < 0)\n\t\tgoto out;\n\n\t \n\trc = tpm_cr50_i2c_transfer_message(&chip->dev, client->adapter, &msg_response);\n\nout:\n\ttpm_cr50_i2c_disable_tpm_irq(chip);\n\ti2c_unlock_bus(client->adapter, I2C_LOCK_SEGMENT);\n\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn 0;\n}\n\n \nstatic int tpm_cr50_i2c_write(struct tpm_chip *chip, u8 addr, u8 *buffer,\n\t\t\t      size_t len)\n{\n\tstruct tpm_i2c_cr50_priv_data *priv = dev_get_drvdata(&chip->dev);\n\tstruct i2c_client *client = to_i2c_client(chip->dev.parent);\n\tstruct i2c_msg msg = {\n\t\t.addr = client->addr,\n\t\t.len = len + 1,\n\t\t.buf = priv->buf\n\t};\n\tint rc;\n\n\tif (len > TPM_CR50_MAX_BUFSIZE - 1)\n\t\treturn -EINVAL;\n\n\t \n\tpriv->buf[0] = addr;\n\tmemcpy(priv->buf + 1, buffer, len);\n\n\ti2c_lock_bus(client->adapter, I2C_LOCK_SEGMENT);\n\n\t \n\ttpm_cr50_i2c_enable_tpm_irq(chip);\n\n\t \n\trc = tpm_cr50_i2c_transfer_message(&chip->dev, client->adapter, &msg);\n\tif (rc < 0)\n\t\tgoto out;\n\n\t \n\ttpm_cr50_i2c_wait_tpm_ready(chip);\n\nout:\n\ttpm_cr50_i2c_disable_tpm_irq(chip);\n\ti2c_unlock_bus(client->adapter, I2C_LOCK_SEGMENT);\n\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn 0;\n}\n\n \nstatic int tpm_cr50_check_locality(struct tpm_chip *chip)\n{\n\tu8 mask = TPM_ACCESS_VALID | TPM_ACCESS_ACTIVE_LOCALITY;\n\tu8 buf;\n\tint rc;\n\n\trc = tpm_cr50_i2c_read(chip, TPM_I2C_ACCESS(0), &buf, sizeof(buf));\n\tif (rc < 0)\n\t\treturn rc;\n\n\tif ((buf & mask) == mask)\n\t\treturn 0;\n\n\treturn -EIO;\n}\n\n \nstatic void tpm_cr50_release_locality(struct tpm_chip *chip, bool force)\n{\n\tu8 mask = TPM_ACCESS_VALID | TPM_ACCESS_REQUEST_PENDING;\n\tu8 addr = TPM_I2C_ACCESS(0);\n\tu8 buf;\n\n\tif (tpm_cr50_i2c_read(chip, addr, &buf, sizeof(buf)) < 0)\n\t\treturn;\n\n\tif (force || (buf & mask) == mask) {\n\t\tbuf = TPM_ACCESS_ACTIVE_LOCALITY;\n\t\ttpm_cr50_i2c_write(chip, addr, &buf, sizeof(buf));\n\t}\n}\n\n \nstatic int tpm_cr50_request_locality(struct tpm_chip *chip)\n{\n\tu8 buf = TPM_ACCESS_REQUEST_USE;\n\tunsigned long stop;\n\tint rc;\n\n\tif (!tpm_cr50_check_locality(chip))\n\t\treturn 0;\n\n\trc = tpm_cr50_i2c_write(chip, TPM_I2C_ACCESS(0), &buf, sizeof(buf));\n\tif (rc < 0)\n\t\treturn rc;\n\n\tstop = jiffies + chip->timeout_a;\n\tdo {\n\t\tif (!tpm_cr50_check_locality(chip))\n\t\t\treturn 0;\n\n\t\tmsleep(TPM_CR50_TIMEOUT_SHORT_MS);\n\t} while (time_before(jiffies, stop));\n\n\treturn -ETIMEDOUT;\n}\n\n \nstatic u8 tpm_cr50_i2c_tis_status(struct tpm_chip *chip)\n{\n\tu8 buf[4];\n\n\tif (tpm_cr50_i2c_read(chip, TPM_I2C_STS(0), buf, sizeof(buf)) < 0)\n\t\treturn 0;\n\n\treturn buf[0];\n}\n\n \nstatic void tpm_cr50_i2c_tis_set_ready(struct tpm_chip *chip)\n{\n\tu8 buf[4] = { TPM_STS_COMMAND_READY };\n\n\ttpm_cr50_i2c_write(chip, TPM_I2C_STS(0), buf, sizeof(buf));\n\tmsleep(TPM_CR50_TIMEOUT_SHORT_MS);\n}\n\n \nstatic int tpm_cr50_i2c_get_burst_and_status(struct tpm_chip *chip, u8 mask,\n\t\t\t\t\t     size_t *burst, u32 *status)\n{\n\tunsigned long stop;\n\tu8 buf[4];\n\n\t*status = 0;\n\n\t \n\tstop = jiffies + chip->timeout_b;\n\n\tdo {\n\t\tif (tpm_cr50_i2c_read(chip, TPM_I2C_STS(0), buf, sizeof(buf)) < 0) {\n\t\t\tmsleep(TPM_CR50_TIMEOUT_SHORT_MS);\n\t\t\tcontinue;\n\t\t}\n\n\t\t*status = *buf;\n\t\t*burst = le16_to_cpup((__le16 *)(buf + 1));\n\n\t\tif ((*status & mask) == mask &&\n\t\t    *burst > 0 && *burst <= TPM_CR50_MAX_BUFSIZE - 1)\n\t\t\treturn 0;\n\n\t\tmsleep(TPM_CR50_TIMEOUT_SHORT_MS);\n\t} while (time_before(jiffies, stop));\n\n\tdev_err(&chip->dev, \"Timeout reading burst and status\\n\");\n\treturn -ETIMEDOUT;\n}\n\n \nstatic int tpm_cr50_i2c_tis_recv(struct tpm_chip *chip, u8 *buf, size_t buf_len)\n{\n\n\tu8 mask = TPM_STS_VALID | TPM_STS_DATA_AVAIL;\n\tsize_t burstcnt, cur, len, expected;\n\tu8 addr = TPM_I2C_DATA_FIFO(0);\n\tu32 status;\n\tint rc;\n\n\tif (buf_len < TPM_HEADER_SIZE)\n\t\treturn -EINVAL;\n\n\trc = tpm_cr50_i2c_get_burst_and_status(chip, mask, &burstcnt, &status);\n\tif (rc < 0)\n\t\tgoto out_err;\n\n\tif (burstcnt > buf_len || burstcnt < TPM_HEADER_SIZE) {\n\t\tdev_err(&chip->dev,\n\t\t\t\"Unexpected burstcnt: %zu (max=%zu, min=%d)\\n\",\n\t\t\tburstcnt, buf_len, TPM_HEADER_SIZE);\n\t\trc = -EIO;\n\t\tgoto out_err;\n\t}\n\n\t \n\trc = tpm_cr50_i2c_read(chip, addr, buf, burstcnt);\n\tif (rc < 0) {\n\t\tdev_err(&chip->dev, \"Read of first chunk failed\\n\");\n\t\tgoto out_err;\n\t}\n\n\t \n\texpected = be32_to_cpup((__be32 *)(buf + 2));\n\tif (expected > buf_len) {\n\t\tdev_err(&chip->dev, \"Buffer too small to receive i2c data\\n\");\n\t\trc = -E2BIG;\n\t\tgoto out_err;\n\t}\n\n\t \n\tcur = burstcnt;\n\twhile (cur < expected) {\n\t\t \n\t\trc = tpm_cr50_i2c_get_burst_and_status(chip, mask, &burstcnt, &status);\n\t\tif (rc < 0)\n\t\t\tgoto out_err;\n\n\t\tlen = min_t(size_t, burstcnt, expected - cur);\n\t\trc = tpm_cr50_i2c_read(chip, addr, buf + cur, len);\n\t\tif (rc < 0) {\n\t\t\tdev_err(&chip->dev, \"Read failed\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tcur += len;\n\t}\n\n\t \n\trc = tpm_cr50_i2c_get_burst_and_status(chip, TPM_STS_VALID, &burstcnt, &status);\n\tif (rc < 0)\n\t\tgoto out_err;\n\tif (status & TPM_STS_DATA_AVAIL) {\n\t\tdev_err(&chip->dev, \"Data still available\\n\");\n\t\trc = -EIO;\n\t\tgoto out_err;\n\t}\n\n\ttpm_cr50_release_locality(chip, false);\n\treturn cur;\n\nout_err:\n\t \n\tif (tpm_cr50_i2c_tis_status(chip) & TPM_STS_COMMAND_READY)\n\t\ttpm_cr50_i2c_tis_set_ready(chip);\n\n\ttpm_cr50_release_locality(chip, false);\n\treturn rc;\n}\n\n \nstatic int tpm_cr50_i2c_tis_send(struct tpm_chip *chip, u8 *buf, size_t len)\n{\n\tsize_t burstcnt, limit, sent = 0;\n\tu8 tpm_go[4] = { TPM_STS_GO };\n\tunsigned long stop;\n\tu32 status;\n\tint rc;\n\n\trc = tpm_cr50_request_locality(chip);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\tstop = jiffies + chip->timeout_b;\n\twhile (!(tpm_cr50_i2c_tis_status(chip) & TPM_STS_COMMAND_READY)) {\n\t\tif (time_after(jiffies, stop)) {\n\t\t\trc = -ETIMEDOUT;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\ttpm_cr50_i2c_tis_set_ready(chip);\n\t}\n\n\twhile (len > 0) {\n\t\tu8 mask = TPM_STS_VALID;\n\n\t\t \n\t\tif (sent > 0)\n\t\t\tmask |= TPM_STS_DATA_EXPECT;\n\n\t\t \n\t\trc = tpm_cr50_i2c_get_burst_and_status(chip, mask, &burstcnt, &status);\n\t\tif (rc < 0)\n\t\t\tgoto out_err;\n\n\t\t \n\t\tlimit = min_t(size_t, burstcnt - 1, len);\n\t\trc = tpm_cr50_i2c_write(chip, TPM_I2C_DATA_FIFO(0), &buf[sent], limit);\n\t\tif (rc < 0) {\n\t\t\tdev_err(&chip->dev, \"Write failed\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tsent += limit;\n\t\tlen -= limit;\n\t}\n\n\t \n\trc = tpm_cr50_i2c_get_burst_and_status(chip, TPM_STS_VALID, &burstcnt, &status);\n\tif (rc < 0)\n\t\tgoto out_err;\n\tif (status & TPM_STS_DATA_EXPECT) {\n\t\tdev_err(&chip->dev, \"Data still expected\\n\");\n\t\trc = -EIO;\n\t\tgoto out_err;\n\t}\n\n\t \n\trc = tpm_cr50_i2c_write(chip, TPM_I2C_STS(0), tpm_go,\n\t\t\t\tsizeof(tpm_go));\n\tif (rc < 0) {\n\t\tdev_err(&chip->dev, \"Start command failed\\n\");\n\t\tgoto out_err;\n\t}\n\treturn 0;\n\nout_err:\n\t \n\tif (tpm_cr50_i2c_tis_status(chip) & TPM_STS_COMMAND_READY)\n\t\ttpm_cr50_i2c_tis_set_ready(chip);\n\n\ttpm_cr50_release_locality(chip, false);\n\treturn rc;\n}\n\n \nstatic bool tpm_cr50_i2c_req_canceled(struct tpm_chip *chip, u8 status)\n{\n\treturn status == TPM_STS_COMMAND_READY;\n}\n\nstatic bool tpm_cr50_i2c_is_firmware_power_managed(struct device *dev)\n{\n\tu8 val;\n\tint ret;\n\n\t \n\tret = device_property_read_u8(dev, \"firmware-power-managed\", &val);\n\tif (ret)\n\t\treturn true;\n\n\treturn val;\n}\n\nstatic const struct tpm_class_ops cr50_i2c = {\n\t.flags = TPM_OPS_AUTO_STARTUP,\n\t.status = &tpm_cr50_i2c_tis_status,\n\t.recv = &tpm_cr50_i2c_tis_recv,\n\t.send = &tpm_cr50_i2c_tis_send,\n\t.cancel = &tpm_cr50_i2c_tis_set_ready,\n\t.req_complete_mask = TPM_STS_DATA_AVAIL | TPM_STS_VALID,\n\t.req_complete_val = TPM_STS_DATA_AVAIL | TPM_STS_VALID,\n\t.req_canceled = &tpm_cr50_i2c_req_canceled,\n};\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id cr50_i2c_acpi_id[] = {\n\t{ \"GOOG0005\", 0 },\n\t{}\n};\nMODULE_DEVICE_TABLE(acpi, cr50_i2c_acpi_id);\n#endif\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id of_cr50_i2c_match[] = {\n\t{ .compatible = \"google,cr50\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, of_cr50_i2c_match);\n#endif\n\n \nstatic int tpm_cr50_i2c_probe(struct i2c_client *client)\n{\n\tstruct tpm_i2c_cr50_priv_data *priv;\n\tstruct device *dev = &client->dev;\n\tstruct tpm_chip *chip;\n\tu32 vendor;\n\tu8 buf[4];\n\tint rc;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))\n\t\treturn -ENODEV;\n\n\tchip = tpmm_chip_alloc(dev, &cr50_i2c);\n\tif (IS_ERR(chip))\n\t\treturn PTR_ERR(chip);\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\t \n\tchip->flags |= TPM_CHIP_FLAG_TPM2;\n\tif (tpm_cr50_i2c_is_firmware_power_managed(dev))\n\t\tchip->flags |= TPM_CHIP_FLAG_FIRMWARE_POWER_MANAGED;\n\n\t \n\tchip->timeout_a = msecs_to_jiffies(TIS_SHORT_TIMEOUT);\n\tchip->timeout_b = msecs_to_jiffies(TIS_LONG_TIMEOUT);\n\tchip->timeout_c = msecs_to_jiffies(TIS_SHORT_TIMEOUT);\n\tchip->timeout_d = msecs_to_jiffies(TIS_SHORT_TIMEOUT);\n\n\tdev_set_drvdata(&chip->dev, priv);\n\tinit_completion(&priv->tpm_ready);\n\n\tif (client->irq > 0) {\n\t\trc = devm_request_irq(dev, client->irq, tpm_cr50_i2c_int_handler,\n\t\t\t\t      IRQF_TRIGGER_FALLING | IRQF_ONESHOT |\n\t\t\t\t      IRQF_NO_AUTOEN,\n\t\t\t\t      dev->driver->name, chip);\n\t\tif (rc < 0) {\n\t\t\tdev_err(dev, \"Failed to probe IRQ %d\\n\", client->irq);\n\t\t\treturn rc;\n\t\t}\n\n\t\tpriv->irq = client->irq;\n\t} else {\n\t\tdev_warn(dev, \"No IRQ, will use %ums delay for TPM ready\\n\",\n\t\t\t TPM_CR50_TIMEOUT_NOIRQ_MS);\n\t}\n\n\trc = tpm_cr50_request_locality(chip);\n\tif (rc < 0) {\n\t\tdev_err(dev, \"Could not request locality\\n\");\n\t\treturn rc;\n\t}\n\n\t \n\trc = tpm_cr50_i2c_read(chip, TPM_I2C_DID_VID(0), buf, sizeof(buf));\n\tif (rc < 0) {\n\t\tdev_err(dev, \"Could not read vendor id\\n\");\n\t\ttpm_cr50_release_locality(chip, true);\n\t\treturn rc;\n\t}\n\n\tvendor = le32_to_cpup((__le32 *)buf);\n\tif (vendor != TPM_CR50_I2C_DID_VID && vendor != TPM_TI50_I2C_DID_VID) {\n\t\tdev_err(dev, \"Vendor ID did not match! ID was %08x\\n\", vendor);\n\t\ttpm_cr50_release_locality(chip, true);\n\t\treturn -ENODEV;\n\t}\n\n\tdev_info(dev, \"%s TPM 2.0 (i2c 0x%02x irq %d id 0x%x)\\n\",\n\t\t vendor == TPM_TI50_I2C_DID_VID ? \"ti50\" : \"cr50\",\n\t\t client->addr, client->irq, vendor >> 16);\n\treturn tpm_chip_register(chip);\n}\n\n \nstatic void tpm_cr50_i2c_remove(struct i2c_client *client)\n{\n\tstruct tpm_chip *chip = i2c_get_clientdata(client);\n\tstruct device *dev = &client->dev;\n\n\tif (!chip) {\n\t\tdev_crit(dev, \"Could not get client data at remove, memory corruption ahead\\n\");\n\t\treturn;\n\t}\n\n\ttpm_chip_unregister(chip);\n\ttpm_cr50_release_locality(chip, true);\n}\n\nstatic SIMPLE_DEV_PM_OPS(cr50_i2c_pm, tpm_pm_suspend, tpm_pm_resume);\n\nstatic struct i2c_driver cr50_i2c_driver = {\n\t.probe = tpm_cr50_i2c_probe,\n\t.remove = tpm_cr50_i2c_remove,\n\t.driver = {\n\t\t.name = \"cr50_i2c\",\n\t\t.pm = &cr50_i2c_pm,\n\t\t.acpi_match_table = ACPI_PTR(cr50_i2c_acpi_id),\n\t\t.of_match_table = of_match_ptr(of_cr50_i2c_match),\n\t},\n};\n\nmodule_i2c_driver(cr50_i2c_driver);\n\nMODULE_DESCRIPTION(\"cr50 TPM I2C Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}