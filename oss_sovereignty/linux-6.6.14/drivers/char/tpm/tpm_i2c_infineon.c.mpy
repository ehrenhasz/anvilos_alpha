{
  "module_name": "tpm_i2c_infineon.c",
  "hash_id": "d17c214b6ceba5fed86823dedd8d69db0ed2811e8f57f76cfbba388f139c7e4d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/tpm/tpm_i2c_infineon.c",
  "human_readable_source": "\n \n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include \"tpm.h\"\n\n#define TPM_I2C_INFINEON_BUFSIZE 1260\n\n \n#define MAX_COUNT 3\n\n#define SLEEP_DURATION_LOW 55\n#define SLEEP_DURATION_HI 65\n\n \n#define MAX_COUNT_LONG 50\n\n#define SLEEP_DURATION_LONG_LOW 200\n#define SLEEP_DURATION_LONG_HI 220\n\n \n#define SLEEP_DURATION_RESET_LOW 2400\n#define SLEEP_DURATION_RESET_HI 2600\n\n \n#define TPM_TIMEOUT_US_LOW (TPM_TIMEOUT * 1000)\n#define TPM_TIMEOUT_US_HI  (TPM_TIMEOUT_US_LOW + 2000)\n\n \n#define TPM_TIS_I2C_DID_VID_9635 0xd1150b00L\n#define TPM_TIS_I2C_DID_VID_9645 0x001a15d1L\n\nenum i2c_chip_type {\n\tSLB9635,\n\tSLB9645,\n\tUNKNOWN,\n};\n\nstruct tpm_inf_dev {\n\tstruct i2c_client *client;\n\tint locality;\n\t \n\tu8 buf[TPM_I2C_INFINEON_BUFSIZE + 1];\n\tstruct tpm_chip *chip;\n\tenum i2c_chip_type chip_type;\n\tunsigned int adapterlimit;\n};\n\nstatic struct tpm_inf_dev tpm_dev;\n\n \nstatic int iic_tpm_read(u8 addr, u8 *buffer, size_t len)\n{\n\n\tstruct i2c_msg msg1 = {\n\t\t.addr = tpm_dev.client->addr,\n\t\t.len = 1,\n\t\t.buf = &addr\n\t};\n\tstruct i2c_msg msg2 = {\n\t\t.addr = tpm_dev.client->addr,\n\t\t.flags = I2C_M_RD,\n\t\t.len = len,\n\t\t.buf = buffer\n\t};\n\tstruct i2c_msg msgs[] = {msg1, msg2};\n\n\tint rc = 0;\n\tint count;\n\tunsigned int msglen = len;\n\n\t \n\tif (!tpm_dev.client->adapter->algo->master_xfer)\n\t\treturn -EOPNOTSUPP;\n\ti2c_lock_bus(tpm_dev.client->adapter, I2C_LOCK_SEGMENT);\n\n\tif (tpm_dev.chip_type == SLB9645) {\n\t\t \n\t\tfor (count = 0; count < MAX_COUNT; count++) {\n\t\t\trc = __i2c_transfer(tpm_dev.client->adapter, msgs, 2);\n\t\t\tif (rc > 0)\n\t\t\t\tbreak;\t \n\t\t\tusleep_range(SLEEP_DURATION_LOW, SLEEP_DURATION_HI);\n\t\t}\n\t} else {\n\t\t \n\t\twhile (len > 0) {\n\t\t\t \n\t\t\tfor (count = 0; count < MAX_COUNT; count++) {\n\t\t\t\trc = __i2c_transfer(tpm_dev.client->adapter,\n\t\t\t\t\t\t    &msg1, 1);\n\t\t\t\tif (rc > 0)\n\t\t\t\t\tbreak;\t \n\n\t\t\t\tusleep_range(SLEEP_DURATION_LOW,\n\t\t\t\t\t     SLEEP_DURATION_HI);\n\t\t\t}\n\n\t\t\tif (rc <= 0)\n\t\t\t\tgoto out;\n\n\t\t\t \n\t\t\tfor (count = 0; count < MAX_COUNT; count++) {\n\t\t\t\tif (tpm_dev.adapterlimit) {\n\t\t\t\t\tmsglen = min_t(unsigned int,\n\t\t\t\t\t\t       tpm_dev.adapterlimit,\n\t\t\t\t\t\t       len);\n\t\t\t\t\tmsg2.len = msglen;\n\t\t\t\t}\n\t\t\t\tusleep_range(SLEEP_DURATION_LOW,\n\t\t\t\t\t     SLEEP_DURATION_HI);\n\t\t\t\trc = __i2c_transfer(tpm_dev.client->adapter,\n\t\t\t\t\t\t    &msg2, 1);\n\t\t\t\tif (rc > 0) {\n\t\t\t\t\t \n\t\t\t\t\tif (msglen > len)\n\t\t\t\t\t\tlen = 0;\n\t\t\t\t\telse\n\t\t\t\t\t\tlen -= msglen;\n\t\t\t\t\tmsg2.buf += msglen;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tif (rc == -EOPNOTSUPP)\n\t\t\t\t\ttpm_dev.adapterlimit =\n\t\t\t\t\t\t\tI2C_SMBUS_BLOCK_MAX;\n\t\t\t}\n\n\t\t\tif (rc <= 0)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\ti2c_unlock_bus(tpm_dev.client->adapter, I2C_LOCK_SEGMENT);\n\t \n\tusleep_range(SLEEP_DURATION_LOW, SLEEP_DURATION_HI);\n\n\t \n\tif (rc <= 0)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int iic_tpm_write_generic(u8 addr, u8 *buffer, size_t len,\n\t\t\t\t unsigned int sleep_low,\n\t\t\t\t unsigned int sleep_hi, u8 max_count)\n{\n\tint rc = -EIO;\n\tint count;\n\n\tstruct i2c_msg msg1 = {\n\t\t.addr = tpm_dev.client->addr,\n\t\t.len = len + 1,\n\t\t.buf = tpm_dev.buf\n\t};\n\n\tif (len > TPM_I2C_INFINEON_BUFSIZE)\n\t\treturn -EINVAL;\n\n\tif (!tpm_dev.client->adapter->algo->master_xfer)\n\t\treturn -EOPNOTSUPP;\n\ti2c_lock_bus(tpm_dev.client->adapter, I2C_LOCK_SEGMENT);\n\n\t \n\ttpm_dev.buf[0] = addr;\n\tmemcpy(&(tpm_dev.buf[1]), buffer, len);\n\n\t \n\tfor (count = 0; count < max_count; count++) {\n\t\trc = __i2c_transfer(tpm_dev.client->adapter, &msg1, 1);\n\t\tif (rc > 0)\n\t\t\tbreak;\n\t\tusleep_range(sleep_low, sleep_hi);\n\t}\n\n\ti2c_unlock_bus(tpm_dev.client->adapter, I2C_LOCK_SEGMENT);\n\t \n\tusleep_range(SLEEP_DURATION_LOW, SLEEP_DURATION_HI);\n\n\t \n\tif (rc <= 0)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\n \nstatic int iic_tpm_write(u8 addr, u8 *buffer, size_t len)\n{\n\treturn iic_tpm_write_generic(addr, buffer, len, SLEEP_DURATION_LOW,\n\t\t\t\t     SLEEP_DURATION_HI, MAX_COUNT);\n}\n\n \nstatic int iic_tpm_write_long(u8 addr, u8 *buffer, size_t len)\n{\n\treturn iic_tpm_write_generic(addr, buffer, len, SLEEP_DURATION_LONG_LOW,\n\t\t\t\t     SLEEP_DURATION_LONG_HI, MAX_COUNT_LONG);\n}\n\nenum tis_access {\n\tTPM_ACCESS_VALID = 0x80,\n\tTPM_ACCESS_ACTIVE_LOCALITY = 0x20,\n\tTPM_ACCESS_REQUEST_PENDING = 0x04,\n\tTPM_ACCESS_REQUEST_USE = 0x02,\n};\n\nenum tis_status {\n\tTPM_STS_VALID = 0x80,\n\tTPM_STS_COMMAND_READY = 0x40,\n\tTPM_STS_GO = 0x20,\n\tTPM_STS_DATA_AVAIL = 0x10,\n\tTPM_STS_DATA_EXPECT = 0x08,\n};\n\nenum tis_defaults {\n\tTIS_SHORT_TIMEOUT = 750,\t \n\tTIS_LONG_TIMEOUT = 2000,\t \n};\n\n#define\tTPM_ACCESS(l)\t\t\t(0x0000 | ((l) << 4))\n#define\tTPM_STS(l)\t\t\t(0x0001 | ((l) << 4))\n#define\tTPM_DATA_FIFO(l)\t\t(0x0005 | ((l) << 4))\n#define\tTPM_DID_VID(l)\t\t\t(0x0006 | ((l) << 4))\n\nstatic bool check_locality(struct tpm_chip *chip, int loc)\n{\n\tu8 buf;\n\tint rc;\n\n\trc = iic_tpm_read(TPM_ACCESS(loc), &buf, 1);\n\tif (rc < 0)\n\t\treturn false;\n\n\tif ((buf & (TPM_ACCESS_ACTIVE_LOCALITY | TPM_ACCESS_VALID)) ==\n\t    (TPM_ACCESS_ACTIVE_LOCALITY | TPM_ACCESS_VALID)) {\n\t\ttpm_dev.locality = loc;\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nstatic void release_locality(struct tpm_chip *chip, int loc, int force)\n{\n\tu8 buf;\n\tif (iic_tpm_read(TPM_ACCESS(loc), &buf, 1) < 0)\n\t\treturn;\n\n\tif (force || (buf & (TPM_ACCESS_REQUEST_PENDING | TPM_ACCESS_VALID)) ==\n\t    (TPM_ACCESS_REQUEST_PENDING | TPM_ACCESS_VALID)) {\n\t\tbuf = TPM_ACCESS_ACTIVE_LOCALITY;\n\t\tiic_tpm_write(TPM_ACCESS(loc), &buf, 1);\n\t}\n}\n\nstatic int request_locality(struct tpm_chip *chip, int loc)\n{\n\tunsigned long stop;\n\tu8 buf = TPM_ACCESS_REQUEST_USE;\n\n\tif (check_locality(chip, loc))\n\t\treturn loc;\n\n\tiic_tpm_write(TPM_ACCESS(loc), &buf, 1);\n\n\t \n\tstop = jiffies + chip->timeout_a;\n\tdo {\n\t\tif (check_locality(chip, loc))\n\t\t\treturn loc;\n\t\tusleep_range(TPM_TIMEOUT_US_LOW, TPM_TIMEOUT_US_HI);\n\t} while (time_before(jiffies, stop));\n\n\treturn -ETIME;\n}\n\nstatic u8 tpm_tis_i2c_status(struct tpm_chip *chip)\n{\n\t \n\tu8 buf = 0xFF;\n\tu8 i = 0;\n\n\tdo {\n\t\tif (iic_tpm_read(TPM_STS(tpm_dev.locality), &buf, 1) < 0)\n\t\t\treturn 0;\n\n\t\ti++;\n\t \n\t} while ((buf == 0xFF) && i < 10);\n\n\treturn buf;\n}\n\nstatic void tpm_tis_i2c_ready(struct tpm_chip *chip)\n{\n\t \n\tu8 buf = TPM_STS_COMMAND_READY;\n\tiic_tpm_write_long(TPM_STS(tpm_dev.locality), &buf, 1);\n}\n\nstatic ssize_t get_burstcount(struct tpm_chip *chip)\n{\n\tunsigned long stop;\n\tssize_t burstcnt;\n\tu8 buf[3];\n\n\t \n\t \n\tstop = jiffies + chip->timeout_d;\n\tdo {\n\t\t \n\t\tif (iic_tpm_read(TPM_STS(tpm_dev.locality)+1, buf, 3) < 0)\n\t\t\tburstcnt = 0;\n\t\telse\n\t\t\tburstcnt = (buf[2] << 16) + (buf[1] << 8) + buf[0];\n\n\t\tif (burstcnt)\n\t\t\treturn burstcnt;\n\n\t\tusleep_range(TPM_TIMEOUT_US_LOW, TPM_TIMEOUT_US_HI);\n\t} while (time_before(jiffies, stop));\n\treturn -EBUSY;\n}\n\nstatic int wait_for_stat(struct tpm_chip *chip, u8 mask, unsigned long timeout,\n\t\t\t int *status)\n{\n\tunsigned long stop;\n\n\t \n\t*status = tpm_tis_i2c_status(chip);\n\tif ((*status != 0xFF) && (*status & mask) == mask)\n\t\treturn 0;\n\n\tstop = jiffies + timeout;\n\tdo {\n\t\t \n\t\tusleep_range(TPM_TIMEOUT_US_LOW, TPM_TIMEOUT_US_HI);\n\t\t*status = tpm_tis_i2c_status(chip);\n\t\tif ((*status & mask) == mask)\n\t\t\treturn 0;\n\n\t} while (time_before(jiffies, stop));\n\n\treturn -ETIME;\n}\n\nstatic int recv_data(struct tpm_chip *chip, u8 *buf, size_t count)\n{\n\tsize_t size = 0;\n\tssize_t burstcnt;\n\tu8 retries = 0;\n\tint rc;\n\n\twhile (size < count) {\n\t\tburstcnt = get_burstcount(chip);\n\n\t\t \n\t\tif (burstcnt < 0)\n\t\t\treturn burstcnt;\n\n\t\t \n\t\tif (burstcnt > (count - size))\n\t\t\tburstcnt = count - size;\n\n\t\trc = iic_tpm_read(TPM_DATA_FIFO(tpm_dev.locality),\n\t\t\t\t  &(buf[size]), burstcnt);\n\t\tif (rc == 0)\n\t\t\tsize += burstcnt;\n\t\telse if (rc < 0)\n\t\t\tretries++;\n\n\t\t \n\t\tif (retries > MAX_COUNT_LONG)\n\t\t\treturn -EIO;\n\t}\n\treturn size;\n}\n\nstatic int tpm_tis_i2c_recv(struct tpm_chip *chip, u8 *buf, size_t count)\n{\n\tint size = 0;\n\tint status;\n\tu32 expected;\n\n\tif (count < TPM_HEADER_SIZE) {\n\t\tsize = -EIO;\n\t\tgoto out;\n\t}\n\n\t \n\tsize = recv_data(chip, buf, TPM_HEADER_SIZE);\n\tif (size < TPM_HEADER_SIZE) {\n\t\tdev_err(&chip->dev, \"Unable to read header\\n\");\n\t\tgoto out;\n\t}\n\n\texpected = be32_to_cpu(*(__be32 *)(buf + 2));\n\tif (((size_t) expected > count) || (expected < TPM_HEADER_SIZE)) {\n\t\tsize = -EIO;\n\t\tgoto out;\n\t}\n\n\tsize += recv_data(chip, &buf[TPM_HEADER_SIZE],\n\t\t\t  expected - TPM_HEADER_SIZE);\n\tif (size < expected) {\n\t\tdev_err(&chip->dev, \"Unable to read remainder of result\\n\");\n\t\tsize = -ETIME;\n\t\tgoto out;\n\t}\n\n\twait_for_stat(chip, TPM_STS_VALID, chip->timeout_c, &status);\n\tif (status & TPM_STS_DATA_AVAIL) {\t \n\t\tdev_err(&chip->dev, \"Error left over data\\n\");\n\t\tsize = -EIO;\n\t\tgoto out;\n\t}\n\nout:\n\ttpm_tis_i2c_ready(chip);\n\t \n\tusleep_range(SLEEP_DURATION_RESET_LOW, SLEEP_DURATION_RESET_HI);\n\trelease_locality(chip, tpm_dev.locality, 0);\n\treturn size;\n}\n\nstatic int tpm_tis_i2c_send(struct tpm_chip *chip, u8 *buf, size_t len)\n{\n\tint rc, status;\n\tssize_t burstcnt;\n\tsize_t count = 0;\n\tu8 retries = 0;\n\tu8 sts = TPM_STS_GO;\n\n\tif (len > TPM_I2C_INFINEON_BUFSIZE)\n\t\treturn -E2BIG;\n\n\tif (request_locality(chip, 0) < 0)\n\t\treturn -EBUSY;\n\n\tstatus = tpm_tis_i2c_status(chip);\n\tif ((status & TPM_STS_COMMAND_READY) == 0) {\n\t\ttpm_tis_i2c_ready(chip);\n\t\tif (wait_for_stat\n\t\t    (chip, TPM_STS_COMMAND_READY,\n\t\t     chip->timeout_b, &status) < 0) {\n\t\t\trc = -ETIME;\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\twhile (count < len - 1) {\n\t\tburstcnt = get_burstcount(chip);\n\n\t\t \n\t\tif (burstcnt < 0)\n\t\t\treturn burstcnt;\n\n\t\tif (burstcnt > (len - 1 - count))\n\t\t\tburstcnt = len - 1 - count;\n\n\t\trc = iic_tpm_write(TPM_DATA_FIFO(tpm_dev.locality),\n\t\t\t\t   &(buf[count]), burstcnt);\n\t\tif (rc == 0)\n\t\t\tcount += burstcnt;\n\t\telse if (rc < 0)\n\t\t\tretries++;\n\n\t\t \n\t\tif (retries > MAX_COUNT_LONG) {\n\t\t\trc = -EIO;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\twait_for_stat(chip, TPM_STS_VALID,\n\t\t\t      chip->timeout_c, &status);\n\n\t\tif ((status & TPM_STS_DATA_EXPECT) == 0) {\n\t\t\trc = -EIO;\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\t \n\tiic_tpm_write(TPM_DATA_FIFO(tpm_dev.locality), &(buf[count]), 1);\n\twait_for_stat(chip, TPM_STS_VALID, chip->timeout_c, &status);\n\tif ((status & TPM_STS_DATA_EXPECT) != 0) {\n\t\trc = -EIO;\n\t\tgoto out_err;\n\t}\n\n\t \n\tiic_tpm_write(TPM_STS(tpm_dev.locality), &sts, 1);\n\n\treturn 0;\nout_err:\n\ttpm_tis_i2c_ready(chip);\n\t \n\tusleep_range(SLEEP_DURATION_RESET_LOW, SLEEP_DURATION_RESET_HI);\n\trelease_locality(chip, tpm_dev.locality, 0);\n\treturn rc;\n}\n\nstatic bool tpm_tis_i2c_req_canceled(struct tpm_chip *chip, u8 status)\n{\n\treturn (status == TPM_STS_COMMAND_READY);\n}\n\nstatic const struct tpm_class_ops tpm_tis_i2c = {\n\t.flags = TPM_OPS_AUTO_STARTUP,\n\t.status = tpm_tis_i2c_status,\n\t.recv = tpm_tis_i2c_recv,\n\t.send = tpm_tis_i2c_send,\n\t.cancel = tpm_tis_i2c_ready,\n\t.req_complete_mask = TPM_STS_DATA_AVAIL | TPM_STS_VALID,\n\t.req_complete_val = TPM_STS_DATA_AVAIL | TPM_STS_VALID,\n\t.req_canceled = tpm_tis_i2c_req_canceled,\n};\n\nstatic int tpm_tis_i2c_init(struct device *dev)\n{\n\tu32 vendor;\n\tint rc = 0;\n\tstruct tpm_chip *chip;\n\n\tchip = tpmm_chip_alloc(dev, &tpm_tis_i2c);\n\tif (IS_ERR(chip))\n\t\treturn PTR_ERR(chip);\n\n\t \n\tchip->timeout_a = msecs_to_jiffies(TIS_SHORT_TIMEOUT);\n\tchip->timeout_b = msecs_to_jiffies(TIS_LONG_TIMEOUT);\n\tchip->timeout_c = msecs_to_jiffies(TIS_SHORT_TIMEOUT);\n\tchip->timeout_d = msecs_to_jiffies(TIS_SHORT_TIMEOUT);\n\n\tif (request_locality(chip, 0) != 0) {\n\t\tdev_err(dev, \"could not request locality\\n\");\n\t\trc = -ENODEV;\n\t\tgoto out_err;\n\t}\n\n\t \n\tif (iic_tpm_read(TPM_DID_VID(0), (u8 *)&vendor, 4) < 0) {\n\t\tdev_err(dev, \"could not read vendor id\\n\");\n\t\trc = -EIO;\n\t\tgoto out_release;\n\t}\n\n\tif (vendor == TPM_TIS_I2C_DID_VID_9645) {\n\t\ttpm_dev.chip_type = SLB9645;\n\t} else if (vendor == TPM_TIS_I2C_DID_VID_9635) {\n\t\ttpm_dev.chip_type = SLB9635;\n\t} else {\n\t\tdev_err(dev, \"vendor id did not match! ID was %08x\\n\", vendor);\n\t\trc = -ENODEV;\n\t\tgoto out_release;\n\t}\n\n\tdev_info(dev, \"1.2 TPM (device-id 0x%X)\\n\", vendor >> 16);\n\n\ttpm_dev.chip = chip;\n\n\treturn tpm_chip_register(chip);\nout_release:\n\trelease_locality(chip, tpm_dev.locality, 1);\n\ttpm_dev.client = NULL;\nout_err:\n\treturn rc;\n}\n\nstatic const struct i2c_device_id tpm_tis_i2c_table[] = {\n\t{\"tpm_i2c_infineon\"},\n\t{\"slb9635tt\"},\n\t{\"slb9645tt\"},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(i2c, tpm_tis_i2c_table);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id tpm_tis_i2c_of_match[] = {\n\t{.compatible = \"infineon,tpm_i2c_infineon\"},\n\t{.compatible = \"infineon,slb9635tt\"},\n\t{.compatible = \"infineon,slb9645tt\"},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, tpm_tis_i2c_of_match);\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(tpm_tis_i2c_ops, tpm_pm_suspend, tpm_pm_resume);\n\nstatic int tpm_tis_i2c_probe(struct i2c_client *client)\n{\n\tint rc;\n\tstruct device *dev = &(client->dev);\n\n\tif (tpm_dev.client != NULL) {\n\t\tdev_err(dev, \"This driver only supports one client at a time\\n\");\n\t\treturn -EBUSY;\t \n\t}\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\n\t\tdev_err(dev, \"no algorithms associated to the i2c bus\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\ttpm_dev.client = client;\n\trc = tpm_tis_i2c_init(&client->dev);\n\tif (rc != 0) {\n\t\ttpm_dev.client = NULL;\n\t\trc = -ENODEV;\n\t}\n\treturn rc;\n}\n\nstatic void tpm_tis_i2c_remove(struct i2c_client *client)\n{\n\tstruct tpm_chip *chip = tpm_dev.chip;\n\n\ttpm_chip_unregister(chip);\n\trelease_locality(chip, tpm_dev.locality, 1);\n\ttpm_dev.client = NULL;\n}\n\nstatic struct i2c_driver tpm_tis_i2c_driver = {\n\t.id_table = tpm_tis_i2c_table,\n\t.probe = tpm_tis_i2c_probe,\n\t.remove = tpm_tis_i2c_remove,\n\t.driver = {\n\t\t   .name = \"tpm_i2c_infineon\",\n\t\t   .pm = &tpm_tis_i2c_ops,\n\t\t   .of_match_table = of_match_ptr(tpm_tis_i2c_of_match),\n\t\t   },\n};\n\nmodule_i2c_driver(tpm_tis_i2c_driver);\nMODULE_AUTHOR(\"Peter Huewe <peter.huewe@infineon.com>\");\nMODULE_DESCRIPTION(\"TPM TIS I2C Infineon Driver\");\nMODULE_VERSION(\"2.2.0\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}