{
  "module_name": "tpm_i2c_atmel.c",
  "hash_id": "dab8b51fa920447bb4e9eb4b51d7bfd40f65b959378ee6349b9c982adb96c656",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/tpm/tpm_i2c_atmel.c",
  "human_readable_source": "\n \n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include \"tpm.h\"\n\n#define I2C_DRIVER_NAME \"tpm_i2c_atmel\"\n\n#define TPM_I2C_SHORT_TIMEOUT  750      \n#define TPM_I2C_LONG_TIMEOUT   2000     \n\n#define ATMEL_STS_OK 1\n\nstruct priv_data {\n\tsize_t len;\n\t \n\tu8 buffer[sizeof(struct tpm_header) + 25];\n};\n\nstatic int i2c_atmel_send(struct tpm_chip *chip, u8 *buf, size_t len)\n{\n\tstruct priv_data *priv = dev_get_drvdata(&chip->dev);\n\tstruct i2c_client *client = to_i2c_client(chip->dev.parent);\n\ts32 status;\n\n\tpriv->len = 0;\n\n\tif (len <= 2)\n\t\treturn -EIO;\n\n\tstatus = i2c_master_send(client, buf, len);\n\n\tdev_dbg(&chip->dev,\n\t\t\"%s(buf=%*ph len=%0zx) -> sts=%d\\n\", __func__,\n\t\t(int)min_t(size_t, 64, len), buf, len, status);\n\n\tif (status < 0)\n\t\treturn status;\n\n\t \n\tif (status != len)\n\t\treturn -E2BIG;\n\n\treturn 0;\n}\n\nstatic int i2c_atmel_recv(struct tpm_chip *chip, u8 *buf, size_t count)\n{\n\tstruct priv_data *priv = dev_get_drvdata(&chip->dev);\n\tstruct i2c_client *client = to_i2c_client(chip->dev.parent);\n\tstruct tpm_header *hdr = (struct tpm_header *)priv->buffer;\n\tu32 expected_len;\n\tint rc;\n\n\tif (priv->len == 0)\n\t\treturn -EIO;\n\n\t \n\texpected_len = be32_to_cpu(hdr->length);\n\tif (expected_len > count)\n\t\treturn -ENOMEM;\n\n\tif (priv->len >= expected_len) {\n\t\tdev_dbg(&chip->dev,\n\t\t\t\"%s early(buf=%*ph count=%0zx) -> ret=%d\\n\", __func__,\n\t\t\t(int)min_t(size_t, 64, expected_len), buf, count,\n\t\t\texpected_len);\n\t\tmemcpy(buf, priv->buffer, expected_len);\n\t\treturn expected_len;\n\t}\n\n\trc = i2c_master_recv(client, buf, expected_len);\n\tdev_dbg(&chip->dev,\n\t\t\"%s reread(buf=%*ph count=%0zx) -> ret=%d\\n\", __func__,\n\t\t(int)min_t(size_t, 64, expected_len), buf, count,\n\t\texpected_len);\n\treturn rc;\n}\n\nstatic void i2c_atmel_cancel(struct tpm_chip *chip)\n{\n\tdev_err(&chip->dev, \"TPM operation cancellation was requested, but is not supported\");\n}\n\nstatic u8 i2c_atmel_read_status(struct tpm_chip *chip)\n{\n\tstruct priv_data *priv = dev_get_drvdata(&chip->dev);\n\tstruct i2c_client *client = to_i2c_client(chip->dev.parent);\n\tint rc;\n\n\t \n\tpriv->len = 0;\n\tmemset(priv->buffer, 0, sizeof(priv->buffer));\n\n\n\t \n\trc = i2c_master_recv(client, priv->buffer, sizeof(priv->buffer));\n\tdev_dbg(&chip->dev,\n\t\t\"%s: sts=%d\", __func__, rc);\n\tif (rc <= 0)\n\t\treturn 0;\n\n\tpriv->len = rc;\n\n\treturn ATMEL_STS_OK;\n}\n\nstatic bool i2c_atmel_req_canceled(struct tpm_chip *chip, u8 status)\n{\n\treturn false;\n}\n\nstatic const struct tpm_class_ops i2c_atmel = {\n\t.flags = TPM_OPS_AUTO_STARTUP,\n\t.status = i2c_atmel_read_status,\n\t.recv = i2c_atmel_recv,\n\t.send = i2c_atmel_send,\n\t.cancel = i2c_atmel_cancel,\n\t.req_complete_mask = ATMEL_STS_OK,\n\t.req_complete_val = ATMEL_STS_OK,\n\t.req_canceled = i2c_atmel_req_canceled,\n};\n\nstatic int i2c_atmel_probe(struct i2c_client *client)\n{\n\tstruct tpm_chip *chip;\n\tstruct device *dev = &client->dev;\n\tstruct priv_data *priv;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))\n\t\treturn -ENODEV;\n\n\tchip = tpmm_chip_alloc(dev, &i2c_atmel);\n\tif (IS_ERR(chip))\n\t\treturn PTR_ERR(chip);\n\n\tpriv = devm_kzalloc(dev, sizeof(struct priv_data), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\t \n\tchip->timeout_a = msecs_to_jiffies(TPM_I2C_SHORT_TIMEOUT);\n\tchip->timeout_b = msecs_to_jiffies(TPM_I2C_LONG_TIMEOUT);\n\tchip->timeout_c = msecs_to_jiffies(TPM_I2C_SHORT_TIMEOUT);\n\tchip->timeout_d = msecs_to_jiffies(TPM_I2C_SHORT_TIMEOUT);\n\n\tdev_set_drvdata(&chip->dev, priv);\n\n\t \n\n\treturn tpm_chip_register(chip);\n}\n\nstatic void i2c_atmel_remove(struct i2c_client *client)\n{\n\tstruct device *dev = &(client->dev);\n\tstruct tpm_chip *chip = dev_get_drvdata(dev);\n\ttpm_chip_unregister(chip);\n}\n\nstatic const struct i2c_device_id i2c_atmel_id[] = {\n\t{I2C_DRIVER_NAME, 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, i2c_atmel_id);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id i2c_atmel_of_match[] = {\n\t{.compatible = \"atmel,at97sc3204t\"},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, i2c_atmel_of_match);\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(i2c_atmel_pm_ops, tpm_pm_suspend, tpm_pm_resume);\n\nstatic struct i2c_driver i2c_atmel_driver = {\n\t.id_table = i2c_atmel_id,\n\t.probe = i2c_atmel_probe,\n\t.remove = i2c_atmel_remove,\n\t.driver = {\n\t\t.name = I2C_DRIVER_NAME,\n\t\t.pm = &i2c_atmel_pm_ops,\n\t\t.of_match_table = of_match_ptr(i2c_atmel_of_match),\n\t},\n};\n\nmodule_i2c_driver(i2c_atmel_driver);\n\nMODULE_AUTHOR(\"Jason Gunthorpe <jgunthorpe@obsidianresearch.com>\");\nMODULE_DESCRIPTION(\"Atmel TPM I2C Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}