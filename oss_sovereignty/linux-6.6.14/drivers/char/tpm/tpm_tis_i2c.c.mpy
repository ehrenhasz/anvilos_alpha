{
  "module_name": "tpm_tis_i2c.c",
  "hash_id": "3dcc0c18e5cc4d54922cffef9275f8350b5e088ad841871b7b417a5cb2759760",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/tpm/tpm_tis_i2c.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/crc-ccitt.h>\n#include \"tpm_tis_core.h\"\n\n \n#define TPM_I2C_LOC_SEL 0x00\n#define TPM_I2C_ACCESS 0x04\n#define TPM_I2C_INTERFACE_CAPABILITY 0x30\n#define TPM_I2C_DEVICE_ADDRESS 0x38\n#define TPM_I2C_DATA_CSUM_ENABLE 0x40\n#define TPM_DATA_CSUM 0x44\n#define TPM_I2C_DID_VID 0x48\n#define TPM_I2C_RID 0x4C\n\n \n#define TPM_LOC_SEL 0x0FFF\n\n \n#define TPM_TIS_REGISTER_MASK 0x0FFF\n\n \n#define GUARD_TIME_DEFAULT_MIN 250\n#define GUARD_TIME_DEFAULT_MAX 300\n\n \n#define GUARD_TIME_ERR_MIN 250\n#define GUARD_TIME_ERR_MAX 300\n\n \n#define TPM_GUARD_TIME_SR_MASK 0x40000000\n#define TPM_GUARD_TIME_RR_MASK 0x00100000\n#define TPM_GUARD_TIME_RW_MASK 0x00080000\n#define TPM_GUARD_TIME_WR_MASK 0x00040000\n#define TPM_GUARD_TIME_WW_MASK 0x00020000\n#define TPM_GUARD_TIME_MIN_MASK 0x0001FE00\n#define TPM_GUARD_TIME_MIN_SHIFT 9\n\n \n#define TPM_ACCESS_READ_ZERO 0x48\n#define TPM_INT_ENABLE_ZERO 0x7FFFFF60\n#define TPM_STS_READ_ZERO 0x23\n#define TPM_INTF_CAPABILITY_ZERO 0x0FFFF000\n#define TPM_I2C_INTERFACE_CAPABILITY_ZERO 0x80000000\n\nstruct tpm_tis_i2c_phy {\n\tstruct tpm_tis_data priv;\n\tstruct i2c_client *i2c_client;\n\tbool guard_time_read;\n\tbool guard_time_write;\n\tu16 guard_time_min;\n\tu16 guard_time_max;\n\tu8 *io_buf;\n};\n\nstatic inline struct tpm_tis_i2c_phy *\nto_tpm_tis_i2c_phy(struct tpm_tis_data *data)\n{\n\treturn container_of(data, struct tpm_tis_i2c_phy, priv);\n}\n\n \nstatic u8 tpm_tis_i2c_address_to_register(u32 addr)\n{\n\taddr &= TPM_TIS_REGISTER_MASK;\n\n\tswitch (addr) {\n\tcase TPM_ACCESS(0):\n\t\treturn TPM_I2C_ACCESS;\n\tcase TPM_LOC_SEL:\n\t\treturn TPM_I2C_LOC_SEL;\n\tcase TPM_DID_VID(0):\n\t\treturn TPM_I2C_DID_VID;\n\tcase TPM_RID(0):\n\t\treturn TPM_I2C_RID;\n\tdefault:\n\t\treturn addr;\n\t}\n}\n\nstatic int tpm_tis_i2c_retry_transfer_until_ack(struct tpm_tis_data *data,\n\t\t\t\t\t\tstruct i2c_msg *msg)\n{\n\tstruct tpm_tis_i2c_phy *phy = to_tpm_tis_i2c_phy(data);\n\tbool guard_time;\n\tint i = 0;\n\tint ret;\n\n\tif (msg->flags & I2C_M_RD)\n\t\tguard_time = phy->guard_time_read;\n\telse\n\t\tguard_time = phy->guard_time_write;\n\n\tdo {\n\t\tret = i2c_transfer(phy->i2c_client->adapter, msg, 1);\n\t\tif (ret < 0)\n\t\t\tusleep_range(GUARD_TIME_ERR_MIN, GUARD_TIME_ERR_MAX);\n\t\telse if (guard_time)\n\t\t\tusleep_range(phy->guard_time_min, phy->guard_time_max);\n\t\t \n\t} while (ret < 0 && i++ < TPM_RETRY);\n\n\treturn ret;\n}\n\n \nstatic int tpm_tis_i2c_sanity_check_read(u8 reg, u16 len, u8 *buf)\n{\n\tu32 zero_mask;\n\tu32 value;\n\n\tswitch (len) {\n\tcase sizeof(u8):\n\t\tvalue = buf[0];\n\t\tbreak;\n\tcase sizeof(u16):\n\t\tvalue = le16_to_cpup((__le16 *)buf);\n\t\tbreak;\n\tcase sizeof(u32):\n\t\tvalue = le32_to_cpup((__le32 *)buf);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn 0;\n\t}\n\n\tswitch (reg) {\n\tcase TPM_I2C_ACCESS:\n\t\tzero_mask = TPM_ACCESS_READ_ZERO;\n\t\tbreak;\n\tcase TPM_INT_ENABLE(0) & TPM_TIS_REGISTER_MASK:\n\t\tzero_mask = TPM_INT_ENABLE_ZERO;\n\t\tbreak;\n\tcase TPM_STS(0) & TPM_TIS_REGISTER_MASK:\n\t\tzero_mask = TPM_STS_READ_ZERO;\n\t\tbreak;\n\tcase TPM_INTF_CAPS(0) & TPM_TIS_REGISTER_MASK:\n\t\tzero_mask = TPM_INTF_CAPABILITY_ZERO;\n\t\tbreak;\n\tcase TPM_I2C_INTERFACE_CAPABILITY:\n\t\tzero_mask = TPM_I2C_INTERFACE_CAPABILITY_ZERO;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn 0;\n\t}\n\n\tif (unlikely((value & zero_mask) != 0x00)) {\n\t\tpr_debug(\"TPM I2C read of register 0x%02x failed sanity check: 0x%x\\n\", reg, value);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int tpm_tis_i2c_read_bytes(struct tpm_tis_data *data, u32 addr, u16 len,\n\t\t\t\t  u8 *result, enum tpm_tis_io_mode io_mode)\n{\n\tstruct tpm_tis_i2c_phy *phy = to_tpm_tis_i2c_phy(data);\n\tstruct i2c_msg msg = { .addr = phy->i2c_client->addr };\n\tu8 reg = tpm_tis_i2c_address_to_register(addr);\n\tint i;\n\tint ret;\n\n\tfor (i = 0; i < TPM_RETRY; i++) {\n\t\tu16 read = 0;\n\n\t\twhile (read < len) {\n\t\t\t \n\t\t\tmsg.len = sizeof(reg);\n\t\t\tmsg.buf = &reg;\n\t\t\tmsg.flags = 0;\n\t\t\tret = tpm_tis_i2c_retry_transfer_until_ack(data, &msg);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\t \n\t\t\tmsg.buf = result + read;\n\t\t\tmsg.len = len - read;\n\t\t\tmsg.flags = I2C_M_RD;\n\t\t\tif (msg.len > I2C_SMBUS_BLOCK_MAX)\n\t\t\t\tmsg.len = I2C_SMBUS_BLOCK_MAX;\n\t\t\tret = tpm_tis_i2c_retry_transfer_until_ack(data, &msg);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tread += msg.len;\n\t\t}\n\n\t\tret = tpm_tis_i2c_sanity_check_read(reg, len, result);\n\t\tif (ret == 0)\n\t\t\treturn 0;\n\n\t\tusleep_range(GUARD_TIME_ERR_MIN, GUARD_TIME_ERR_MAX);\n\t}\n\n\treturn ret;\n}\n\nstatic int tpm_tis_i2c_write_bytes(struct tpm_tis_data *data, u32 addr, u16 len,\n\t\t\t\t   const u8 *value,\n\t\t\t\t   enum tpm_tis_io_mode io_mode)\n{\n\tstruct tpm_tis_i2c_phy *phy = to_tpm_tis_i2c_phy(data);\n\tstruct i2c_msg msg = { .addr = phy->i2c_client->addr };\n\tu8 reg = tpm_tis_i2c_address_to_register(addr);\n\tint ret;\n\tu16 wrote = 0;\n\n\tif (len > TPM_BUFSIZE - 1)\n\t\treturn -EIO;\n\n\tphy->io_buf[0] = reg;\n\tmsg.buf = phy->io_buf;\n\twhile (wrote < len) {\n\t\t \n\t\tmsg.len = sizeof(reg) + len - wrote;\n\t\tif (msg.len > I2C_SMBUS_BLOCK_MAX)\n\t\t\tmsg.len = I2C_SMBUS_BLOCK_MAX;\n\n\t\tmemcpy(phy->io_buf + sizeof(reg), value + wrote,\n\t\t       msg.len - sizeof(reg));\n\n\t\tret = tpm_tis_i2c_retry_transfer_until_ack(data, &msg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\twrote += msg.len - sizeof(reg);\n\t}\n\n\treturn 0;\n}\n\nstatic int tpm_tis_i2c_verify_crc(struct tpm_tis_data *data, size_t len,\n\t\t\t\t  const u8 *value)\n{\n\tu16 crc_tpm, crc_host;\n\tint rc;\n\n\trc = tpm_tis_read16(data, TPM_DATA_CSUM, &crc_tpm);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\tcrc_host = swab16(crc_ccitt(0, value, len));\n\tif (crc_tpm != crc_host)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\n \nstatic int tpm_tis_i2c_init_guard_time(struct tpm_tis_i2c_phy *phy)\n{\n\tu32 i2c_caps;\n\tint ret;\n\n\tphy->guard_time_read = true;\n\tphy->guard_time_write = true;\n\tphy->guard_time_min = GUARD_TIME_DEFAULT_MIN;\n\tphy->guard_time_max = GUARD_TIME_DEFAULT_MAX;\n\n\tret = tpm_tis_i2c_read_bytes(&phy->priv, TPM_I2C_INTERFACE_CAPABILITY,\n\t\t\t\t     sizeof(i2c_caps), (u8 *)&i2c_caps,\n\t\t\t\t     TPM_TIS_PHYS_32);\n\tif (ret)\n\t\treturn ret;\n\n\tphy->guard_time_read = (i2c_caps & TPM_GUARD_TIME_RR_MASK) ||\n\t\t\t       (i2c_caps & TPM_GUARD_TIME_RW_MASK);\n\tphy->guard_time_write = (i2c_caps & TPM_GUARD_TIME_WR_MASK) ||\n\t\t\t\t(i2c_caps & TPM_GUARD_TIME_WW_MASK);\n\tphy->guard_time_min = (i2c_caps & TPM_GUARD_TIME_MIN_MASK) >>\n\t\t\t      TPM_GUARD_TIME_MIN_SHIFT;\n\t \n\tphy->guard_time_max = phy->guard_time_min + phy->guard_time_min / 5;\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(tpm_tis_pm, tpm_pm_suspend, tpm_tis_resume);\n\nstatic const struct tpm_tis_phy_ops tpm_i2c_phy_ops = {\n\t.read_bytes = tpm_tis_i2c_read_bytes,\n\t.write_bytes = tpm_tis_i2c_write_bytes,\n\t.verify_crc = tpm_tis_i2c_verify_crc,\n};\n\nstatic int tpm_tis_i2c_probe(struct i2c_client *dev)\n{\n\tstruct tpm_tis_i2c_phy *phy;\n\tconst u8 crc_enable = 1;\n\tconst u8 locality = 0;\n\tint ret;\n\n\tphy = devm_kzalloc(&dev->dev, sizeof(struct tpm_tis_i2c_phy),\n\t\t\t   GFP_KERNEL);\n\tif (!phy)\n\t\treturn -ENOMEM;\n\n\tphy->io_buf = devm_kzalloc(&dev->dev, TPM_BUFSIZE, GFP_KERNEL);\n\tif (!phy->io_buf)\n\t\treturn -ENOMEM;\n\n\tset_bit(TPM_TIS_DEFAULT_CANCELLATION, &phy->priv.flags);\n\tphy->i2c_client = dev;\n\n\t \n\tret = tpm_tis_i2c_init_guard_time(phy);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tpm_tis_i2c_write_bytes(&phy->priv, TPM_LOC_SEL, sizeof(locality),\n\t\t\t\t      &locality, TPM_TIS_PHYS_8);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tpm_tis_i2c_write_bytes(&phy->priv, TPM_I2C_DATA_CSUM_ENABLE,\n\t\t\t\t      sizeof(crc_enable), &crc_enable,\n\t\t\t\t      TPM_TIS_PHYS_8);\n\tif (ret)\n\t\treturn ret;\n\n\treturn tpm_tis_core_init(&dev->dev, &phy->priv, -1, &tpm_i2c_phy_ops,\n\t\t\t\t NULL);\n}\n\nstatic void tpm_tis_i2c_remove(struct i2c_client *client)\n{\n\tstruct tpm_chip *chip = i2c_get_clientdata(client);\n\n\ttpm_chip_unregister(chip);\n\ttpm_tis_remove(chip);\n}\n\nstatic const struct i2c_device_id tpm_tis_i2c_id[] = {\n\t{ \"tpm_tis_i2c\", 0 },\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, tpm_tis_i2c_id);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id of_tis_i2c_match[] = {\n\t{ .compatible = \"infineon,slb9673\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, of_tis_i2c_match);\n#endif\n\nstatic struct i2c_driver tpm_tis_i2c_driver = {\n\t.driver = {\n\t\t.name = \"tpm_tis_i2c\",\n\t\t.pm = &tpm_tis_pm,\n\t\t.of_match_table = of_match_ptr(of_tis_i2c_match),\n\t},\n\t.probe = tpm_tis_i2c_probe,\n\t.remove = tpm_tis_i2c_remove,\n\t.id_table = tpm_tis_i2c_id,\n};\nmodule_i2c_driver(tpm_tis_i2c_driver);\n\nMODULE_DESCRIPTION(\"TPM Driver for native I2C access\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}