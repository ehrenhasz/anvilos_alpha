{
  "module_name": "tpm2-cmd.c",
  "hash_id": "ec1b2eaeb378133b499911c837ac9aeb222d8f13c4550864bd5089aab81edc7f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/tpm/tpm2-cmd.c",
  "human_readable_source": "\n \n\n#include \"tpm.h\"\n#include <crypto/hash_info.h>\n\nstatic struct tpm2_hash tpm2_hash_map[] = {\n\t{HASH_ALGO_SHA1, TPM_ALG_SHA1},\n\t{HASH_ALGO_SHA256, TPM_ALG_SHA256},\n\t{HASH_ALGO_SHA384, TPM_ALG_SHA384},\n\t{HASH_ALGO_SHA512, TPM_ALG_SHA512},\n\t{HASH_ALGO_SM3_256, TPM_ALG_SM3_256},\n};\n\nint tpm2_get_timeouts(struct tpm_chip *chip)\n{\n\t \n\tchip->timeout_a = msecs_to_jiffies(TPM2_TIMEOUT_A);\n\tchip->timeout_b = msecs_to_jiffies(TPM2_TIMEOUT_B);\n\tchip->timeout_c = msecs_to_jiffies(TPM2_TIMEOUT_C);\n\tchip->timeout_d = msecs_to_jiffies(TPM2_TIMEOUT_D);\n\n\t \n\tchip->duration[TPM_SHORT] = msecs_to_jiffies(TPM2_DURATION_SHORT);\n\tchip->duration[TPM_MEDIUM] = msecs_to_jiffies(TPM2_DURATION_MEDIUM);\n\tchip->duration[TPM_LONG] = msecs_to_jiffies(TPM2_DURATION_LONG);\n\n\t \n\tchip->duration[TPM_LONG_LONG] =\n\t\tmsecs_to_jiffies(TPM2_DURATION_LONG_LONG);\n\n\tchip->flags |= TPM_CHIP_FLAG_HAVE_TIMEOUTS;\n\n\treturn 0;\n}\n\n \nstatic u8 tpm2_ordinal_duration_index(u32 ordinal)\n{\n\tswitch (ordinal) {\n\t \n\tcase TPM2_CC_STARTUP:                  \n\t\treturn TPM_MEDIUM;\n\n\tcase TPM2_CC_SELF_TEST:                \n\t\treturn TPM_LONG;\n\n\tcase TPM2_CC_GET_RANDOM:               \n\t\treturn TPM_LONG;\n\n\tcase TPM2_CC_SEQUENCE_UPDATE:          \n\t\treturn TPM_MEDIUM;\n\tcase TPM2_CC_SEQUENCE_COMPLETE:        \n\t\treturn TPM_MEDIUM;\n\tcase TPM2_CC_EVENT_SEQUENCE_COMPLETE:  \n\t\treturn TPM_MEDIUM;\n\tcase TPM2_CC_HASH_SEQUENCE_START:      \n\t\treturn TPM_MEDIUM;\n\n\tcase TPM2_CC_VERIFY_SIGNATURE:         \n\t\treturn TPM_LONG_LONG;\n\n\tcase TPM2_CC_PCR_EXTEND:               \n\t\treturn TPM_MEDIUM;\n\n\tcase TPM2_CC_HIERARCHY_CONTROL:        \n\t\treturn TPM_LONG;\n\tcase TPM2_CC_HIERARCHY_CHANGE_AUTH:    \n\t\treturn TPM_LONG;\n\n\tcase TPM2_CC_GET_CAPABILITY:           \n\t\treturn TPM_MEDIUM;\n\n\tcase TPM2_CC_NV_READ:                  \n\t\treturn TPM_LONG;\n\n\tcase TPM2_CC_CREATE_PRIMARY:           \n\t\treturn TPM_LONG_LONG;\n\tcase TPM2_CC_CREATE:                   \n\t\treturn TPM_LONG_LONG;\n\tcase TPM2_CC_CREATE_LOADED:            \n\t\treturn TPM_LONG_LONG;\n\n\tdefault:\n\t\treturn TPM_UNDEFINED;\n\t}\n}\n\n \nunsigned long tpm2_calc_ordinal_duration(struct tpm_chip *chip, u32 ordinal)\n{\n\tunsigned int index;\n\n\tindex = tpm2_ordinal_duration_index(ordinal);\n\n\tif (index != TPM_UNDEFINED)\n\t\treturn chip->duration[index];\n\telse\n\t\treturn msecs_to_jiffies(TPM2_DURATION_DEFAULT);\n}\n\n\nstruct tpm2_pcr_read_out {\n\t__be32\tupdate_cnt;\n\t__be32\tpcr_selects_cnt;\n\t__be16\thash_alg;\n\tu8\tpcr_select_size;\n\tu8\tpcr_select[TPM2_PCR_SELECT_MIN];\n\t__be32\tdigests_cnt;\n\t__be16\tdigest_size;\n\tu8\tdigest[];\n} __packed;\n\n \nint tpm2_pcr_read(struct tpm_chip *chip, u32 pcr_idx,\n\t\t  struct tpm_digest *digest, u16 *digest_size_ptr)\n{\n\tint i;\n\tint rc;\n\tstruct tpm_buf buf;\n\tstruct tpm2_pcr_read_out *out;\n\tu8 pcr_select[TPM2_PCR_SELECT_MIN] = {0};\n\tu16 digest_size;\n\tu16 expected_digest_size = 0;\n\n\tif (pcr_idx >= TPM2_PLATFORM_PCR)\n\t\treturn -EINVAL;\n\n\tif (!digest_size_ptr) {\n\t\tfor (i = 0; i < chip->nr_allocated_banks &&\n\t\t     chip->allocated_banks[i].alg_id != digest->alg_id; i++)\n\t\t\t;\n\n\t\tif (i == chip->nr_allocated_banks)\n\t\t\treturn -EINVAL;\n\n\t\texpected_digest_size = chip->allocated_banks[i].digest_size;\n\t}\n\n\trc = tpm_buf_init(&buf, TPM2_ST_NO_SESSIONS, TPM2_CC_PCR_READ);\n\tif (rc)\n\t\treturn rc;\n\n\tpcr_select[pcr_idx >> 3] = 1 << (pcr_idx & 0x7);\n\n\ttpm_buf_append_u32(&buf, 1);\n\ttpm_buf_append_u16(&buf, digest->alg_id);\n\ttpm_buf_append_u8(&buf, TPM2_PCR_SELECT_MIN);\n\ttpm_buf_append(&buf, (const unsigned char *)pcr_select,\n\t\t       sizeof(pcr_select));\n\n\trc = tpm_transmit_cmd(chip, &buf, 0, \"attempting to read a pcr value\");\n\tif (rc)\n\t\tgoto out;\n\n\tout = (struct tpm2_pcr_read_out *)&buf.data[TPM_HEADER_SIZE];\n\tdigest_size = be16_to_cpu(out->digest_size);\n\tif (digest_size > sizeof(digest->digest) ||\n\t    (!digest_size_ptr && digest_size != expected_digest_size)) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (digest_size_ptr)\n\t\t*digest_size_ptr = digest_size;\n\n\tmemcpy(digest->digest, out->digest, digest_size);\nout:\n\ttpm_buf_destroy(&buf);\n\treturn rc;\n}\n\nstruct tpm2_null_auth_area {\n\t__be32  handle;\n\t__be16  nonce_size;\n\tu8  attributes;\n\t__be16  auth_size;\n} __packed;\n\n \nint tpm2_pcr_extend(struct tpm_chip *chip, u32 pcr_idx,\n\t\t    struct tpm_digest *digests)\n{\n\tstruct tpm_buf buf;\n\tstruct tpm2_null_auth_area auth_area;\n\tint rc;\n\tint i;\n\n\trc = tpm_buf_init(&buf, TPM2_ST_SESSIONS, TPM2_CC_PCR_EXTEND);\n\tif (rc)\n\t\treturn rc;\n\n\ttpm_buf_append_u32(&buf, pcr_idx);\n\n\tauth_area.handle = cpu_to_be32(TPM2_RS_PW);\n\tauth_area.nonce_size = 0;\n\tauth_area.attributes = 0;\n\tauth_area.auth_size = 0;\n\n\ttpm_buf_append_u32(&buf, sizeof(struct tpm2_null_auth_area));\n\ttpm_buf_append(&buf, (const unsigned char *)&auth_area,\n\t\t       sizeof(auth_area));\n\ttpm_buf_append_u32(&buf, chip->nr_allocated_banks);\n\n\tfor (i = 0; i < chip->nr_allocated_banks; i++) {\n\t\ttpm_buf_append_u16(&buf, digests[i].alg_id);\n\t\ttpm_buf_append(&buf, (const unsigned char *)&digests[i].digest,\n\t\t\t       chip->allocated_banks[i].digest_size);\n\t}\n\n\trc = tpm_transmit_cmd(chip, &buf, 0, \"attempting extend a PCR value\");\n\n\ttpm_buf_destroy(&buf);\n\n\treturn rc;\n}\n\nstruct tpm2_get_random_out {\n\t__be16 size;\n\tu8 buffer[TPM_MAX_RNG_DATA];\n} __packed;\n\n \nint tpm2_get_random(struct tpm_chip *chip, u8 *dest, size_t max)\n{\n\tstruct tpm2_get_random_out *out;\n\tstruct tpm_buf buf;\n\tu32 recd;\n\tu32 num_bytes = max;\n\tint err;\n\tint total = 0;\n\tint retries = 5;\n\tu8 *dest_ptr = dest;\n\n\tif (!num_bytes || max > TPM_MAX_RNG_DATA)\n\t\treturn -EINVAL;\n\n\terr = tpm_buf_init(&buf, 0, 0);\n\tif (err)\n\t\treturn err;\n\n\tdo {\n\t\ttpm_buf_reset(&buf, TPM2_ST_NO_SESSIONS, TPM2_CC_GET_RANDOM);\n\t\ttpm_buf_append_u16(&buf, num_bytes);\n\t\terr = tpm_transmit_cmd(chip, &buf,\n\t\t\t\t       offsetof(struct tpm2_get_random_out,\n\t\t\t\t\t\tbuffer),\n\t\t\t\t       \"attempting get random\");\n\t\tif (err) {\n\t\t\tif (err > 0)\n\t\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\tout = (struct tpm2_get_random_out *)\n\t\t\t&buf.data[TPM_HEADER_SIZE];\n\t\trecd = min_t(u32, be16_to_cpu(out->size), num_bytes);\n\t\tif (tpm_buf_length(&buf) <\n\t\t    TPM_HEADER_SIZE +\n\t\t    offsetof(struct tpm2_get_random_out, buffer) +\n\t\t    recd) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(dest_ptr, out->buffer, recd);\n\n\t\tdest_ptr += recd;\n\t\ttotal += recd;\n\t\tnum_bytes -= recd;\n\t} while (retries-- && total < max);\n\n\ttpm_buf_destroy(&buf);\n\treturn total ? total : -EIO;\nout:\n\ttpm_buf_destroy(&buf);\n\treturn err;\n}\n\n \nvoid tpm2_flush_context(struct tpm_chip *chip, u32 handle)\n{\n\tstruct tpm_buf buf;\n\tint rc;\n\n\trc = tpm_buf_init(&buf, TPM2_ST_NO_SESSIONS, TPM2_CC_FLUSH_CONTEXT);\n\tif (rc) {\n\t\tdev_warn(&chip->dev, \"0x%08x was not flushed, out of memory\\n\",\n\t\t\t handle);\n\t\treturn;\n\t}\n\n\ttpm_buf_append_u32(&buf, handle);\n\n\ttpm_transmit_cmd(chip, &buf, 0, \"flushing context\");\n\ttpm_buf_destroy(&buf);\n}\nEXPORT_SYMBOL_GPL(tpm2_flush_context);\n\nstruct tpm2_get_cap_out {\n\tu8 more_data;\n\t__be32 subcap_id;\n\t__be32 property_cnt;\n\t__be32 property_id;\n\t__be32 value;\n} __packed;\n\n \nssize_t tpm2_get_tpm_pt(struct tpm_chip *chip, u32 property_id,  u32 *value,\n\t\t\tconst char *desc)\n{\n\tstruct tpm2_get_cap_out *out;\n\tstruct tpm_buf buf;\n\tint rc;\n\n\trc = tpm_buf_init(&buf, TPM2_ST_NO_SESSIONS, TPM2_CC_GET_CAPABILITY);\n\tif (rc)\n\t\treturn rc;\n\ttpm_buf_append_u32(&buf, TPM2_CAP_TPM_PROPERTIES);\n\ttpm_buf_append_u32(&buf, property_id);\n\ttpm_buf_append_u32(&buf, 1);\n\trc = tpm_transmit_cmd(chip, &buf, 0, NULL);\n\tif (!rc) {\n\t\tout = (struct tpm2_get_cap_out *)\n\t\t\t&buf.data[TPM_HEADER_SIZE];\n\t\t \n\t\tif (be32_to_cpu(out->property_cnt) > 0)\n\t\t\t*value = be32_to_cpu(out->value);\n\t\telse\n\t\t\trc = -ENODATA;\n\t}\n\ttpm_buf_destroy(&buf);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(tpm2_get_tpm_pt);\n\n \nvoid tpm2_shutdown(struct tpm_chip *chip, u16 shutdown_type)\n{\n\tstruct tpm_buf buf;\n\tint rc;\n\n\trc = tpm_buf_init(&buf, TPM2_ST_NO_SESSIONS, TPM2_CC_SHUTDOWN);\n\tif (rc)\n\t\treturn;\n\ttpm_buf_append_u16(&buf, shutdown_type);\n\ttpm_transmit_cmd(chip, &buf, 0, \"stopping the TPM\");\n\ttpm_buf_destroy(&buf);\n}\n\n \nstatic int tpm2_do_selftest(struct tpm_chip *chip)\n{\n\tstruct tpm_buf buf;\n\tint full;\n\tint rc;\n\n\tfor (full = 0; full < 2; full++) {\n\t\trc = tpm_buf_init(&buf, TPM2_ST_NO_SESSIONS, TPM2_CC_SELF_TEST);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\ttpm_buf_append_u8(&buf, full);\n\t\trc = tpm_transmit_cmd(chip, &buf, 0,\n\t\t\t\t      \"attempting the self test\");\n\t\ttpm_buf_destroy(&buf);\n\n\t\tif (rc == TPM2_RC_TESTING)\n\t\t\trc = TPM2_RC_SUCCESS;\n\t\tif (rc == TPM2_RC_INITIALIZE || rc == TPM2_RC_SUCCESS)\n\t\t\treturn rc;\n\t}\n\n\treturn rc;\n}\n\n \nint tpm2_probe(struct tpm_chip *chip)\n{\n\tstruct tpm_header *out;\n\tstruct tpm_buf buf;\n\tint rc;\n\n\trc = tpm_buf_init(&buf, TPM2_ST_NO_SESSIONS, TPM2_CC_GET_CAPABILITY);\n\tif (rc)\n\t\treturn rc;\n\ttpm_buf_append_u32(&buf, TPM2_CAP_TPM_PROPERTIES);\n\ttpm_buf_append_u32(&buf, TPM_PT_TOTAL_COMMANDS);\n\ttpm_buf_append_u32(&buf, 1);\n\trc = tpm_transmit_cmd(chip, &buf, 0, NULL);\n\t \n\tif (rc >=  0) {\n\t\tout = (struct tpm_header *)buf.data;\n\t\tif (be16_to_cpu(out->tag) == TPM2_ST_NO_SESSIONS)\n\t\t\tchip->flags |= TPM_CHIP_FLAG_TPM2;\n\t}\n\ttpm_buf_destroy(&buf);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(tpm2_probe);\n\nstatic int tpm2_init_bank_info(struct tpm_chip *chip, u32 bank_index)\n{\n\tstruct tpm_bank_info *bank = chip->allocated_banks + bank_index;\n\tstruct tpm_digest digest = { .alg_id = bank->alg_id };\n\tint i;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(tpm2_hash_map); i++) {\n\t\tenum hash_algo crypto_algo = tpm2_hash_map[i].crypto_id;\n\n\t\tif (bank->alg_id != tpm2_hash_map[i].tpm_id)\n\t\t\tcontinue;\n\n\t\tbank->digest_size = hash_digest_size[crypto_algo];\n\t\tbank->crypto_id = crypto_algo;\n\t\treturn 0;\n\t}\n\n\tbank->crypto_id = HASH_ALGO__LAST;\n\n\treturn tpm2_pcr_read(chip, 0, &digest, &bank->digest_size);\n}\n\nstruct tpm2_pcr_selection {\n\t__be16  hash_alg;\n\tu8  size_of_select;\n\tu8  pcr_select[3];\n} __packed;\n\nssize_t tpm2_get_pcr_allocation(struct tpm_chip *chip)\n{\n\tstruct tpm2_pcr_selection pcr_selection;\n\tstruct tpm_buf buf;\n\tvoid *marker;\n\tvoid *end;\n\tvoid *pcr_select_offset;\n\tu32 sizeof_pcr_selection;\n\tu32 nr_possible_banks;\n\tu32 nr_alloc_banks = 0;\n\tu16 hash_alg;\n\tu32 rsp_len;\n\tint rc;\n\tint i = 0;\n\n\trc = tpm_buf_init(&buf, TPM2_ST_NO_SESSIONS, TPM2_CC_GET_CAPABILITY);\n\tif (rc)\n\t\treturn rc;\n\n\ttpm_buf_append_u32(&buf, TPM2_CAP_PCRS);\n\ttpm_buf_append_u32(&buf, 0);\n\ttpm_buf_append_u32(&buf, 1);\n\n\trc = tpm_transmit_cmd(chip, &buf, 9, \"get tpm pcr allocation\");\n\tif (rc)\n\t\tgoto out;\n\n\tnr_possible_banks = be32_to_cpup(\n\t\t(__be32 *)&buf.data[TPM_HEADER_SIZE + 5]);\n\n\tchip->allocated_banks = kcalloc(nr_possible_banks,\n\t\t\t\t\tsizeof(*chip->allocated_banks),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!chip->allocated_banks) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmarker = &buf.data[TPM_HEADER_SIZE + 9];\n\n\trsp_len = be32_to_cpup((__be32 *)&buf.data[2]);\n\tend = &buf.data[rsp_len];\n\n\tfor (i = 0; i < nr_possible_banks; i++) {\n\t\tpcr_select_offset = marker +\n\t\t\toffsetof(struct tpm2_pcr_selection, size_of_select);\n\t\tif (pcr_select_offset >= end) {\n\t\t\trc = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tmemcpy(&pcr_selection, marker, sizeof(pcr_selection));\n\t\thash_alg = be16_to_cpu(pcr_selection.hash_alg);\n\n\t\tpcr_select_offset = memchr_inv(pcr_selection.pcr_select, 0,\n\t\t\t\t\t       pcr_selection.size_of_select);\n\t\tif (pcr_select_offset) {\n\t\t\tchip->allocated_banks[nr_alloc_banks].alg_id = hash_alg;\n\n\t\t\trc = tpm2_init_bank_info(chip, nr_alloc_banks);\n\t\t\tif (rc < 0)\n\t\t\t\tbreak;\n\n\t\t\tnr_alloc_banks++;\n\t\t}\n\n\t\tsizeof_pcr_selection = sizeof(pcr_selection.hash_alg) +\n\t\t\tsizeof(pcr_selection.size_of_select) +\n\t\t\tpcr_selection.size_of_select;\n\t\tmarker = marker + sizeof_pcr_selection;\n\t}\n\n\tchip->nr_allocated_banks = nr_alloc_banks;\nout:\n\ttpm_buf_destroy(&buf);\n\n\treturn rc;\n}\n\nint tpm2_get_cc_attrs_tbl(struct tpm_chip *chip)\n{\n\tstruct tpm_buf buf;\n\tu32 nr_commands;\n\t__be32 *attrs;\n\tu32 cc;\n\tint i;\n\tint rc;\n\n\trc = tpm2_get_tpm_pt(chip, TPM_PT_TOTAL_COMMANDS, &nr_commands, NULL);\n\tif (rc)\n\t\tgoto out;\n\n\tif (nr_commands > 0xFFFFF) {\n\t\trc = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tchip->cc_attrs_tbl = devm_kcalloc(&chip->dev, 4, nr_commands,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!chip->cc_attrs_tbl) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\trc = tpm_buf_init(&buf, TPM2_ST_NO_SESSIONS, TPM2_CC_GET_CAPABILITY);\n\tif (rc)\n\t\tgoto out;\n\n\ttpm_buf_append_u32(&buf, TPM2_CAP_COMMANDS);\n\ttpm_buf_append_u32(&buf, TPM2_CC_FIRST);\n\ttpm_buf_append_u32(&buf, nr_commands);\n\n\trc = tpm_transmit_cmd(chip, &buf, 9 + 4 * nr_commands, NULL);\n\tif (rc) {\n\t\ttpm_buf_destroy(&buf);\n\t\tgoto out;\n\t}\n\n\tif (nr_commands !=\n\t    be32_to_cpup((__be32 *)&buf.data[TPM_HEADER_SIZE + 5])) {\n\t\trc = -EFAULT;\n\t\ttpm_buf_destroy(&buf);\n\t\tgoto out;\n\t}\n\n\tchip->nr_commands = nr_commands;\n\n\tattrs = (__be32 *)&buf.data[TPM_HEADER_SIZE + 9];\n\tfor (i = 0; i < nr_commands; i++, attrs++) {\n\t\tchip->cc_attrs_tbl[i] = be32_to_cpup(attrs);\n\t\tcc = chip->cc_attrs_tbl[i] & 0xFFFF;\n\n\t\tif (cc == TPM2_CC_CONTEXT_SAVE || cc == TPM2_CC_FLUSH_CONTEXT) {\n\t\t\tchip->cc_attrs_tbl[i] &=\n\t\t\t\t~(GENMASK(2, 0) << TPM2_CC_ATTR_CHANDLES);\n\t\t\tchip->cc_attrs_tbl[i] |= 1 << TPM2_CC_ATTR_CHANDLES;\n\t\t}\n\t}\n\n\ttpm_buf_destroy(&buf);\n\nout:\n\tif (rc > 0)\n\t\trc = -ENODEV;\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(tpm2_get_cc_attrs_tbl);\n\n \n\nstatic int tpm2_startup(struct tpm_chip *chip)\n{\n\tstruct tpm_buf buf;\n\tint rc;\n\n\tdev_info(&chip->dev, \"starting up the TPM manually\\n\");\n\n\trc = tpm_buf_init(&buf, TPM2_ST_NO_SESSIONS, TPM2_CC_STARTUP);\n\tif (rc < 0)\n\t\treturn rc;\n\n\ttpm_buf_append_u16(&buf, TPM2_SU_CLEAR);\n\trc = tpm_transmit_cmd(chip, &buf, 0, \"attempting to start the TPM\");\n\ttpm_buf_destroy(&buf);\n\n\treturn rc;\n}\n\n \nint tpm2_auto_startup(struct tpm_chip *chip)\n{\n\tint rc;\n\n\trc = tpm2_get_timeouts(chip);\n\tif (rc)\n\t\tgoto out;\n\n\trc = tpm2_do_selftest(chip);\n\tif (rc && rc != TPM2_RC_INITIALIZE)\n\t\tgoto out;\n\n\tif (rc == TPM2_RC_INITIALIZE) {\n\t\trc = tpm2_startup(chip);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\trc = tpm2_do_selftest(chip);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\trc = tpm2_get_cc_attrs_tbl(chip);\n\tif (rc == TPM2_RC_FAILURE || (rc < 0 && rc != -ENOMEM)) {\n\t\tdev_info(&chip->dev,\n\t\t\t \"TPM in field failure mode, requires firmware upgrade\\n\");\n\t\tchip->flags |= TPM_CHIP_FLAG_FIRMWARE_UPGRADE;\n\t\trc = 0;\n\t}\n\nout:\n\t \n\tif (rc == TPM2_RC_UPGRADE || rc == -ENODATA) {\n\t\tdev_info(&chip->dev, \"TPM in field upgrade mode, requires firmware upgrade\\n\");\n\t\tchip->flags |= TPM_CHIP_FLAG_FIRMWARE_UPGRADE;\n\t\trc = 0;\n\t}\n\n\tif (rc > 0)\n\t\trc = -ENODEV;\n\treturn rc;\n}\n\nint tpm2_find_cc(struct tpm_chip *chip, u32 cc)\n{\n\tu32 cc_mask;\n\tint i;\n\n\tcc_mask = 1 << TPM2_CC_ATTR_VENDOR | GENMASK(15, 0);\n\tfor (i = 0; i < chip->nr_commands; i++)\n\t\tif (cc == (chip->cc_attrs_tbl[i] & cc_mask))\n\t\t\treturn i;\n\n\treturn -1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}