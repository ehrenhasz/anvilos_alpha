{
  "module_name": "tpm_crb.c",
  "hash_id": "ca4e9cae45993d5dfbbc44713f8173732233024f90b0040884d193271a8b4dd7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/tpm/tpm_crb.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/highmem.h>\n#include <linux/rculist.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n#ifdef CONFIG_ARM64\n#include <linux/arm-smccc.h>\n#endif\n#include \"tpm.h\"\n\n#define ACPI_SIG_TPM2 \"TPM2\"\n#define TPM_CRB_MAX_RESOURCES 3\n\nstatic const guid_t crb_acpi_start_guid =\n\tGUID_INIT(0x6BBF6CAB, 0x5463, 0x4714,\n\t\t  0xB7, 0xCD, 0xF0, 0x20, 0x3C, 0x03, 0x68, 0xD4);\n\nenum crb_defaults {\n\tCRB_ACPI_START_REVISION_ID = 1,\n\tCRB_ACPI_START_INDEX = 1,\n};\n\nenum crb_loc_ctrl {\n\tCRB_LOC_CTRL_REQUEST_ACCESS\t= BIT(0),\n\tCRB_LOC_CTRL_RELINQUISH\t\t= BIT(1),\n};\n\nenum crb_loc_state {\n\tCRB_LOC_STATE_LOC_ASSIGNED\t= BIT(1),\n\tCRB_LOC_STATE_TPM_REG_VALID_STS\t= BIT(7),\n};\n\nenum crb_ctrl_req {\n\tCRB_CTRL_REQ_CMD_READY\t= BIT(0),\n\tCRB_CTRL_REQ_GO_IDLE\t= BIT(1),\n};\n\nenum crb_ctrl_sts {\n\tCRB_CTRL_STS_ERROR\t= BIT(0),\n\tCRB_CTRL_STS_TPM_IDLE\t= BIT(1),\n};\n\nenum crb_start {\n\tCRB_START_INVOKE\t= BIT(0),\n};\n\nenum crb_cancel {\n\tCRB_CANCEL_INVOKE\t= BIT(0),\n};\n\nstruct crb_regs_head {\n\tu32 loc_state;\n\tu32 reserved1;\n\tu32 loc_ctrl;\n\tu32 loc_sts;\n\tu8 reserved2[32];\n\tu64 intf_id;\n\tu64 ctrl_ext;\n} __packed;\n\nstruct crb_regs_tail {\n\tu32 ctrl_req;\n\tu32 ctrl_sts;\n\tu32 ctrl_cancel;\n\tu32 ctrl_start;\n\tu32 ctrl_int_enable;\n\tu32 ctrl_int_sts;\n\tu32 ctrl_cmd_size;\n\tu32 ctrl_cmd_pa_low;\n\tu32 ctrl_cmd_pa_high;\n\tu32 ctrl_rsp_size;\n\tu64 ctrl_rsp_pa;\n} __packed;\n\nenum crb_status {\n\tCRB_DRV_STS_COMPLETE\t= BIT(0),\n};\n\nstruct crb_priv {\n\tu32 sm;\n\tconst char *hid;\n\tstruct crb_regs_head __iomem *regs_h;\n\tstruct crb_regs_tail __iomem *regs_t;\n\tu8 __iomem *cmd;\n\tu8 __iomem *rsp;\n\tu32 cmd_size;\n\tu32 smc_func_id;\n\tu32 __iomem *pluton_start_addr;\n\tu32 __iomem *pluton_reply_addr;\n};\n\nstruct tpm2_crb_smc {\n\tu32 interrupt;\n\tu8 interrupt_flags;\n\tu8 op_flags;\n\tu16 reserved2;\n\tu32 smc_func_id;\n};\n\nstruct tpm2_crb_pluton {\n\tu64 start_addr;\n\tu64 reply_addr;\n};\n\nstatic bool crb_wait_for_reg_32(u32 __iomem *reg, u32 mask, u32 value,\n\t\t\t\tunsigned long timeout)\n{\n\tktime_t start;\n\tktime_t stop;\n\n\tstart = ktime_get();\n\tstop = ktime_add(start, ms_to_ktime(timeout));\n\n\tdo {\n\t\tif ((ioread32(reg) & mask) == value)\n\t\t\treturn true;\n\n\t\tusleep_range(50, 100);\n\t} while (ktime_before(ktime_get(), stop));\n\n\treturn ((ioread32(reg) & mask) == value);\n}\n\nstatic int crb_try_pluton_doorbell(struct crb_priv *priv, bool wait_for_complete)\n{\n\tif (priv->sm != ACPI_TPM2_COMMAND_BUFFER_WITH_PLUTON)\n\t\treturn 0;\n\n\tif (!crb_wait_for_reg_32(priv->pluton_reply_addr, ~0, 1, TPM2_TIMEOUT_C))\n\t\treturn -ETIME;\n\n\tiowrite32(1, priv->pluton_start_addr);\n\tif (wait_for_complete == false)\n\t\treturn 0;\n\n\tif (!crb_wait_for_reg_32(priv->pluton_start_addr,\n\t\t\t\t 0xffffffff, 0, 200))\n\t\treturn -ETIME;\n\n\treturn 0;\n}\n\n \nstatic int __crb_go_idle(struct device *dev, struct crb_priv *priv)\n{\n\tint rc;\n\n\tif ((priv->sm == ACPI_TPM2_START_METHOD) ||\n\t    (priv->sm == ACPI_TPM2_COMMAND_BUFFER_WITH_START_METHOD) ||\n\t    (priv->sm == ACPI_TPM2_COMMAND_BUFFER_WITH_ARM_SMC))\n\t\treturn 0;\n\n\tiowrite32(CRB_CTRL_REQ_GO_IDLE, &priv->regs_t->ctrl_req);\n\n\trc = crb_try_pluton_doorbell(priv, true);\n\tif (rc)\n\t\treturn rc;\n\n\tif (!crb_wait_for_reg_32(&priv->regs_t->ctrl_req,\n\t\t\t\t CRB_CTRL_REQ_GO_IDLE ,\n\t\t\t\t 0,  \n\t\t\t\t TPM2_TIMEOUT_C)) {\n\t\tdev_warn(dev, \"goIdle timed out\\n\");\n\t\treturn -ETIME;\n\t}\n\n\treturn 0;\n}\n\nstatic int crb_go_idle(struct tpm_chip *chip)\n{\n\tstruct device *dev = &chip->dev;\n\tstruct crb_priv *priv = dev_get_drvdata(dev);\n\n\treturn __crb_go_idle(dev, priv);\n}\n\n \nstatic int __crb_cmd_ready(struct device *dev, struct crb_priv *priv)\n{\n\tint rc;\n\n\tif ((priv->sm == ACPI_TPM2_START_METHOD) ||\n\t    (priv->sm == ACPI_TPM2_COMMAND_BUFFER_WITH_START_METHOD) ||\n\t    (priv->sm == ACPI_TPM2_COMMAND_BUFFER_WITH_ARM_SMC))\n\t\treturn 0;\n\n\tiowrite32(CRB_CTRL_REQ_CMD_READY, &priv->regs_t->ctrl_req);\n\n\trc = crb_try_pluton_doorbell(priv, true);\n\tif (rc)\n\t\treturn rc;\n\n\tif (!crb_wait_for_reg_32(&priv->regs_t->ctrl_req,\n\t\t\t\t CRB_CTRL_REQ_CMD_READY  ,\n\t\t\t\t 0,  \n\t\t\t\t TPM2_TIMEOUT_C)) {\n\t\tdev_warn(dev, \"cmdReady timed out\\n\");\n\t\treturn -ETIME;\n\t}\n\n\treturn 0;\n}\n\nstatic int crb_cmd_ready(struct tpm_chip *chip)\n{\n\tstruct device *dev = &chip->dev;\n\tstruct crb_priv *priv = dev_get_drvdata(dev);\n\n\treturn __crb_cmd_ready(dev, priv);\n}\n\nstatic int __crb_request_locality(struct device *dev,\n\t\t\t\t  struct crb_priv *priv, int loc)\n{\n\tu32 value = CRB_LOC_STATE_LOC_ASSIGNED |\n\t\t    CRB_LOC_STATE_TPM_REG_VALID_STS;\n\n\tif (!priv->regs_h)\n\t\treturn 0;\n\n\tiowrite32(CRB_LOC_CTRL_REQUEST_ACCESS, &priv->regs_h->loc_ctrl);\n\tif (!crb_wait_for_reg_32(&priv->regs_h->loc_state, value, value,\n\t\t\t\t TPM2_TIMEOUT_C)) {\n\t\tdev_warn(dev, \"TPM_LOC_STATE_x.requestAccess timed out\\n\");\n\t\treturn -ETIME;\n\t}\n\n\treturn 0;\n}\n\nstatic int crb_request_locality(struct tpm_chip *chip, int loc)\n{\n\tstruct crb_priv *priv = dev_get_drvdata(&chip->dev);\n\n\treturn __crb_request_locality(&chip->dev, priv, loc);\n}\n\nstatic int __crb_relinquish_locality(struct device *dev,\n\t\t\t\t     struct crb_priv *priv, int loc)\n{\n\tu32 mask = CRB_LOC_STATE_LOC_ASSIGNED |\n\t\t   CRB_LOC_STATE_TPM_REG_VALID_STS;\n\tu32 value = CRB_LOC_STATE_TPM_REG_VALID_STS;\n\n\tif (!priv->regs_h)\n\t\treturn 0;\n\n\tiowrite32(CRB_LOC_CTRL_RELINQUISH, &priv->regs_h->loc_ctrl);\n\tif (!crb_wait_for_reg_32(&priv->regs_h->loc_state, mask, value,\n\t\t\t\t TPM2_TIMEOUT_C)) {\n\t\tdev_warn(dev, \"TPM_LOC_STATE_x.Relinquish timed out\\n\");\n\t\treturn -ETIME;\n\t}\n\n\treturn 0;\n}\n\nstatic int crb_relinquish_locality(struct tpm_chip *chip, int loc)\n{\n\tstruct crb_priv *priv = dev_get_drvdata(&chip->dev);\n\n\treturn __crb_relinquish_locality(&chip->dev, priv, loc);\n}\n\nstatic u8 crb_status(struct tpm_chip *chip)\n{\n\tstruct crb_priv *priv = dev_get_drvdata(&chip->dev);\n\tu8 sts = 0;\n\n\tif ((ioread32(&priv->regs_t->ctrl_start) & CRB_START_INVOKE) !=\n\t    CRB_START_INVOKE)\n\t\tsts |= CRB_DRV_STS_COMPLETE;\n\n\treturn sts;\n}\n\nstatic int crb_recv(struct tpm_chip *chip, u8 *buf, size_t count)\n{\n\tstruct crb_priv *priv = dev_get_drvdata(&chip->dev);\n\tunsigned int expected;\n\n\t \n\tif (count < TPM_HEADER_SIZE)\n\t\treturn -EIO;\n\n\t \n\tif (ioread32(&priv->regs_t->ctrl_sts) & CRB_CTRL_STS_ERROR)\n\t\treturn -EIO;\n\n\t \n\tmemcpy_fromio(buf, priv->rsp, 8);\n\n\texpected = be32_to_cpup((__be32 *)&buf[2]);\n\tif (expected > count || expected < TPM_HEADER_SIZE)\n\t\treturn -EIO;\n\n\tmemcpy_fromio(&buf[8], &priv->rsp[8], expected - 8);\n\n\treturn expected;\n}\n\nstatic int crb_do_acpi_start(struct tpm_chip *chip)\n{\n\tunion acpi_object *obj;\n\tint rc;\n\n\tobj = acpi_evaluate_dsm(chip->acpi_dev_handle,\n\t\t\t\t&crb_acpi_start_guid,\n\t\t\t\tCRB_ACPI_START_REVISION_ID,\n\t\t\t\tCRB_ACPI_START_INDEX,\n\t\t\t\tNULL);\n\tif (!obj)\n\t\treturn -ENXIO;\n\trc = obj->integer.value == 0 ? 0 : -ENXIO;\n\tACPI_FREE(obj);\n\treturn rc;\n}\n\n#ifdef CONFIG_ARM64\n \nstatic int tpm_crb_smc_start(struct device *dev, unsigned long func_id)\n{\n\tstruct arm_smccc_res res;\n\n\tarm_smccc_smc(func_id, 0, 0, 0, 0, 0, 0, 0, &res);\n\tif (res.a0 != 0) {\n\t\tdev_err(dev,\n\t\t\tFW_BUG \"tpm_crb_smc_start() returns res.a0 = 0x%lx\\n\",\n\t\t\tres.a0);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n#else\nstatic int tpm_crb_smc_start(struct device *dev, unsigned long func_id)\n{\n\tdev_err(dev, FW_BUG \"tpm_crb: incorrect start method\\n\");\n\treturn -EINVAL;\n}\n#endif\n\nstatic int crb_send(struct tpm_chip *chip, u8 *buf, size_t len)\n{\n\tstruct crb_priv *priv = dev_get_drvdata(&chip->dev);\n\tint rc = 0;\n\n\t \n\tiowrite32(0, &priv->regs_t->ctrl_cancel);\n\n\tif (len > priv->cmd_size) {\n\t\tdev_err(&chip->dev, \"invalid command count value %zd %d\\n\",\n\t\t\tlen, priv->cmd_size);\n\t\treturn -E2BIG;\n\t}\n\n\t \n\tif (priv->sm == ACPI_TPM2_COMMAND_BUFFER_WITH_PLUTON)\n\t\t__crb_cmd_ready(&chip->dev, priv);\n\n\tmemcpy_toio(priv->cmd, buf, len);\n\n\t \n\twmb();\n\n\t \n\tif ((priv->sm == ACPI_TPM2_COMMAND_BUFFER) ||\n\t    (priv->sm == ACPI_TPM2_MEMORY_MAPPED) ||\n\t    (!strcmp(priv->hid, \"MSFT0101\")))\n\t\tiowrite32(CRB_START_INVOKE, &priv->regs_t->ctrl_start);\n\n\tif ((priv->sm == ACPI_TPM2_START_METHOD) ||\n\t    (priv->sm == ACPI_TPM2_COMMAND_BUFFER_WITH_START_METHOD))\n\t\trc = crb_do_acpi_start(chip);\n\n\tif (priv->sm == ACPI_TPM2_COMMAND_BUFFER_WITH_ARM_SMC) {\n\t\tiowrite32(CRB_START_INVOKE, &priv->regs_t->ctrl_start);\n\t\trc = tpm_crb_smc_start(&chip->dev, priv->smc_func_id);\n\t}\n\n\tif (rc)\n\t\treturn rc;\n\n\treturn crb_try_pluton_doorbell(priv, false);\n}\n\nstatic void crb_cancel(struct tpm_chip *chip)\n{\n\tstruct crb_priv *priv = dev_get_drvdata(&chip->dev);\n\n\tiowrite32(CRB_CANCEL_INVOKE, &priv->regs_t->ctrl_cancel);\n\n\tif (((priv->sm == ACPI_TPM2_START_METHOD) ||\n\t    (priv->sm == ACPI_TPM2_COMMAND_BUFFER_WITH_START_METHOD)) &&\n\t     crb_do_acpi_start(chip))\n\t\tdev_err(&chip->dev, \"ACPI Start failed\\n\");\n}\n\nstatic bool crb_req_canceled(struct tpm_chip *chip, u8 status)\n{\n\tstruct crb_priv *priv = dev_get_drvdata(&chip->dev);\n\tu32 cancel = ioread32(&priv->regs_t->ctrl_cancel);\n\n\treturn (cancel & CRB_CANCEL_INVOKE) == CRB_CANCEL_INVOKE;\n}\n\nstatic const struct tpm_class_ops tpm_crb = {\n\t.flags = TPM_OPS_AUTO_STARTUP,\n\t.status = crb_status,\n\t.recv = crb_recv,\n\t.send = crb_send,\n\t.cancel = crb_cancel,\n\t.req_canceled = crb_req_canceled,\n\t.go_idle  = crb_go_idle,\n\t.cmd_ready = crb_cmd_ready,\n\t.request_locality = crb_request_locality,\n\t.relinquish_locality = crb_relinquish_locality,\n\t.req_complete_mask = CRB_DRV_STS_COMPLETE,\n\t.req_complete_val = CRB_DRV_STS_COMPLETE,\n};\n\nstatic int crb_check_resource(struct acpi_resource *ares, void *data)\n{\n\tstruct resource *iores_array = data;\n\tstruct resource_win win;\n\tstruct resource *res = &(win.res);\n\tint i;\n\n\tif (acpi_dev_resource_memory(ares, res) ||\n\t    acpi_dev_resource_address_space(ares, &win)) {\n\t\tfor (i = 0; i < TPM_CRB_MAX_RESOURCES + 1; ++i) {\n\t\t\tif (resource_type(iores_array + i) != IORESOURCE_MEM) {\n\t\t\t\tiores_array[i] = *res;\n\t\t\t\tiores_array[i].name = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 1;\n}\n\nstatic void __iomem *crb_map_res(struct device *dev, struct resource *iores,\n\t\t\t\t void __iomem **iobase_ptr, u64 start, u32 size)\n{\n\tstruct resource new_res = {\n\t\t.start\t= start,\n\t\t.end\t= start + size - 1,\n\t\t.flags\t= IORESOURCE_MEM,\n\t};\n\n\t \n\tif (start != new_res.start)\n\t\treturn IOMEM_ERR_PTR(-EINVAL);\n\n\tif (!iores)\n\t\treturn devm_ioremap_resource(dev, &new_res);\n\n\tif (!*iobase_ptr) {\n\t\t*iobase_ptr = devm_ioremap_resource(dev, iores);\n\t\tif (IS_ERR(*iobase_ptr))\n\t\t\treturn *iobase_ptr;\n\t}\n\n\treturn *iobase_ptr + (new_res.start - iores->start);\n}\n\n \nstatic u64 crb_fixup_cmd_size(struct device *dev, struct resource *io_res,\n\t\t\t      u64 start, u64 size)\n{\n\tif (io_res->start > start || io_res->end < start)\n\t\treturn size;\n\n\tif (start + size - 1 <= io_res->end)\n\t\treturn size;\n\n\tdev_err(dev,\n\t\tFW_BUG \"ACPI region does not cover the entire command/response buffer. %pr vs %llx %llx\\n\",\n\t\tio_res, start, size);\n\n\treturn io_res->end - start + 1;\n}\n\nstatic int crb_map_io(struct acpi_device *device, struct crb_priv *priv,\n\t\t      struct acpi_table_tpm2 *buf)\n{\n\tstruct list_head acpi_resource_list;\n\tstruct resource iores_array[TPM_CRB_MAX_RESOURCES + 1] = { {0} };\n\tvoid __iomem *iobase_array[TPM_CRB_MAX_RESOURCES] = {NULL};\n\tstruct device *dev = &device->dev;\n\tstruct resource *iores;\n\tvoid __iomem **iobase_ptr;\n\tint i;\n\tu32 pa_high, pa_low;\n\tu64 cmd_pa;\n\tu32 cmd_size;\n\t__le64 __rsp_pa;\n\tu64 rsp_pa;\n\tu32 rsp_size;\n\tint ret;\n\n\t \n\tif (priv->sm != ACPI_TPM2_COMMAND_BUFFER_WITH_PLUTON) {\n\t\tINIT_LIST_HEAD(&acpi_resource_list);\n\t\tret = acpi_dev_get_resources(device, &acpi_resource_list,\n\t\t\t\t\t     crb_check_resource, iores_array);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tacpi_dev_free_resource_list(&acpi_resource_list);\n\n\t\tif (resource_type(iores_array) != IORESOURCE_MEM) {\n\t\t\tdev_err(dev, FW_BUG \"TPM2 ACPI table does not define a memory resource\\n\");\n\t\t\treturn -EINVAL;\n\t\t} else if (resource_type(iores_array + TPM_CRB_MAX_RESOURCES) ==\n\t\t\t   IORESOURCE_MEM) {\n\t\t\tdev_warn(dev, \"TPM2 ACPI table defines too many memory resources\\n\");\n\t\t\tmemset(iores_array + TPM_CRB_MAX_RESOURCES,\n\t\t\t       0, sizeof(*iores_array));\n\t\t\tiores_array[TPM_CRB_MAX_RESOURCES].flags = 0;\n\t\t}\n\t}\n\n\tiores = NULL;\n\tiobase_ptr = NULL;\n\tfor (i = 0; resource_type(iores_array + i) == IORESOURCE_MEM; ++i) {\n\t\tif (buf->control_address >= iores_array[i].start &&\n\t\t    buf->control_address + sizeof(struct crb_regs_tail) - 1 <=\n\t\t    iores_array[i].end) {\n\t\t\tiores = iores_array + i;\n\t\t\tiobase_ptr = iobase_array + i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tpriv->regs_t = crb_map_res(dev, iores, iobase_ptr, buf->control_address,\n\t\t\t\t   sizeof(struct crb_regs_tail));\n\n\tif (IS_ERR(priv->regs_t))\n\t\treturn PTR_ERR(priv->regs_t);\n\n\t \n\tif ((priv->sm == ACPI_TPM2_COMMAND_BUFFER) ||\n\t    (priv->sm == ACPI_TPM2_MEMORY_MAPPED)) {\n\t\tif (iores &&\n\t\t    buf->control_address == iores->start +\n\t\t    sizeof(*priv->regs_h))\n\t\t\tpriv->regs_h = *iobase_ptr;\n\t\telse\n\t\t\tdev_warn(dev, FW_BUG \"Bad ACPI memory layout\");\n\t}\n\n\tret = __crb_request_locality(dev, priv, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = __crb_cmd_ready(dev, priv);\n\tif (ret)\n\t\tgoto out_relinquish_locality;\n\n\tpa_high = ioread32(&priv->regs_t->ctrl_cmd_pa_high);\n\tpa_low  = ioread32(&priv->regs_t->ctrl_cmd_pa_low);\n\tcmd_pa = ((u64)pa_high << 32) | pa_low;\n\tcmd_size = ioread32(&priv->regs_t->ctrl_cmd_size);\n\n\tiores = NULL;\n\tiobase_ptr = NULL;\n\tfor (i = 0; iores_array[i].end; ++i) {\n\t\tif (cmd_pa >= iores_array[i].start &&\n\t\t    cmd_pa <= iores_array[i].end) {\n\t\t\tiores = iores_array + i;\n\t\t\tiobase_ptr = iobase_array + i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (iores)\n\t\tcmd_size = crb_fixup_cmd_size(dev, iores, cmd_pa, cmd_size);\n\n\tdev_dbg(dev, \"cmd_hi = %X cmd_low = %X cmd_size %X\\n\",\n\t\tpa_high, pa_low, cmd_size);\n\n\tpriv->cmd = crb_map_res(dev, iores, iobase_ptr,\tcmd_pa, cmd_size);\n\tif (IS_ERR(priv->cmd)) {\n\t\tret = PTR_ERR(priv->cmd);\n\t\tgoto out;\n\t}\n\n\tmemcpy_fromio(&__rsp_pa, &priv->regs_t->ctrl_rsp_pa, 8);\n\trsp_pa = le64_to_cpu(__rsp_pa);\n\trsp_size = ioread32(&priv->regs_t->ctrl_rsp_size);\n\n\tiores = NULL;\n\tiobase_ptr = NULL;\n\tfor (i = 0; resource_type(iores_array + i) == IORESOURCE_MEM; ++i) {\n\t\tif (rsp_pa >= iores_array[i].start &&\n\t\t    rsp_pa <= iores_array[i].end) {\n\t\t\tiores = iores_array + i;\n\t\t\tiobase_ptr = iobase_array + i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (iores)\n\t\trsp_size = crb_fixup_cmd_size(dev, iores, rsp_pa, rsp_size);\n\n\tif (cmd_pa != rsp_pa) {\n\t\tpriv->rsp = crb_map_res(dev, iores, iobase_ptr,\n\t\t\t\t\trsp_pa, rsp_size);\n\t\tret = PTR_ERR_OR_ZERO(priv->rsp);\n\t\tgoto out;\n\t}\n\n\t \n\tif (cmd_size != rsp_size) {\n\t\tdev_err(dev, FW_BUG \"overlapping command and response buffer sizes are not identical\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tpriv->rsp = priv->cmd;\n\nout:\n\tif (!ret)\n\t\tpriv->cmd_size = cmd_size;\n\n\t__crb_go_idle(dev, priv);\n\nout_relinquish_locality:\n\n\t__crb_relinquish_locality(dev, priv, 0);\n\n\treturn ret;\n}\n\nstatic int crb_map_pluton(struct device *dev, struct crb_priv *priv,\n\t       struct acpi_table_tpm2 *buf, struct tpm2_crb_pluton *crb_pluton)\n{\n\tpriv->pluton_start_addr = crb_map_res(dev, NULL, NULL,\n\t\t\t\t\t      crb_pluton->start_addr, 4);\n\tif (IS_ERR(priv->pluton_start_addr))\n\t\treturn PTR_ERR(priv->pluton_start_addr);\n\n\tpriv->pluton_reply_addr = crb_map_res(dev, NULL, NULL,\n\t\t\t\t\t      crb_pluton->reply_addr, 4);\n\tif (IS_ERR(priv->pluton_reply_addr))\n\t\treturn PTR_ERR(priv->pluton_reply_addr);\n\n\treturn 0;\n}\n\nstatic int crb_acpi_add(struct acpi_device *device)\n{\n\tstruct acpi_table_tpm2 *buf;\n\tstruct crb_priv *priv;\n\tstruct tpm_chip *chip;\n\tstruct device *dev = &device->dev;\n\tstruct tpm2_crb_smc *crb_smc;\n\tstruct tpm2_crb_pluton *crb_pluton;\n\tacpi_status status;\n\tu32 sm;\n\tint rc;\n\n\tstatus = acpi_get_table(ACPI_SIG_TPM2, 1,\n\t\t\t\t(struct acpi_table_header **) &buf);\n\tif (ACPI_FAILURE(status) || buf->header.length < sizeof(*buf)) {\n\t\tdev_err(dev, FW_BUG \"failed to get TPM2 ACPI table\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tsm = buf->start_method;\n\tif (sm == ACPI_TPM2_MEMORY_MAPPED) {\n\t\trc = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tpriv = devm_kzalloc(dev, sizeof(struct crb_priv), GFP_KERNEL);\n\tif (!priv) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (sm == ACPI_TPM2_COMMAND_BUFFER_WITH_ARM_SMC) {\n\t\tif (buf->header.length < (sizeof(*buf) + sizeof(*crb_smc))) {\n\t\t\tdev_err(dev,\n\t\t\t\tFW_BUG \"TPM2 ACPI table has wrong size %u for start method type %d\\n\",\n\t\t\t\tbuf->header.length,\n\t\t\t\tACPI_TPM2_COMMAND_BUFFER_WITH_ARM_SMC);\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tcrb_smc = ACPI_ADD_PTR(struct tpm2_crb_smc, buf, sizeof(*buf));\n\t\tpriv->smc_func_id = crb_smc->smc_func_id;\n\t}\n\n\tif (sm == ACPI_TPM2_COMMAND_BUFFER_WITH_PLUTON) {\n\t\tif (buf->header.length < (sizeof(*buf) + sizeof(*crb_pluton))) {\n\t\t\tdev_err(dev,\n\t\t\t\tFW_BUG \"TPM2 ACPI table has wrong size %u for start method type %d\\n\",\n\t\t\t\tbuf->header.length,\n\t\t\t\tACPI_TPM2_COMMAND_BUFFER_WITH_PLUTON);\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tcrb_pluton = ACPI_ADD_PTR(struct tpm2_crb_pluton, buf, sizeof(*buf));\n\t\trc = crb_map_pluton(dev, priv, buf, crb_pluton);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\tpriv->sm = sm;\n\tpriv->hid = acpi_device_hid(device);\n\n\trc = crb_map_io(device, priv, buf);\n\tif (rc)\n\t\tgoto out;\n\n\tchip = tpmm_chip_alloc(dev, &tpm_crb);\n\tif (IS_ERR(chip)) {\n\t\trc = PTR_ERR(chip);\n\t\tgoto out;\n\t}\n\n\tdev_set_drvdata(&chip->dev, priv);\n\tchip->acpi_dev_handle = device->handle;\n\tchip->flags = TPM_CHIP_FLAG_TPM2;\n\n\trc = tpm_chip_bootstrap(chip);\n\tif (rc)\n\t\tgoto out;\n\n#ifdef CONFIG_X86\n\t \n\n\trc = tpm_chip_register(chip);\n\nout:\n\tacpi_put_table((struct acpi_table_header *)buf);\n\treturn rc;\n}\n\nstatic void crb_acpi_remove(struct acpi_device *device)\n{\n\tstruct device *dev = &device->dev;\n\tstruct tpm_chip *chip = dev_get_drvdata(dev);\n\n\ttpm_chip_unregister(chip);\n}\n\nstatic const struct dev_pm_ops crb_pm = {\n\tSET_SYSTEM_SLEEP_PM_OPS(tpm_pm_suspend, tpm_pm_resume)\n};\n\nstatic const struct acpi_device_id crb_device_ids[] = {\n\t{\"MSFT0101\", 0},\n\t{\"\", 0},\n};\nMODULE_DEVICE_TABLE(acpi, crb_device_ids);\n\nstatic struct acpi_driver crb_acpi_driver = {\n\t.name = \"tpm_crb\",\n\t.ids = crb_device_ids,\n\t.ops = {\n\t\t.add = crb_acpi_add,\n\t\t.remove = crb_acpi_remove,\n\t},\n\t.drv = {\n\t\t.pm = &crb_pm,\n\t},\n};\n\nmodule_acpi_driver(crb_acpi_driver);\nMODULE_AUTHOR(\"Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>\");\nMODULE_DESCRIPTION(\"TPM2 Driver\");\nMODULE_VERSION(\"0.1\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}