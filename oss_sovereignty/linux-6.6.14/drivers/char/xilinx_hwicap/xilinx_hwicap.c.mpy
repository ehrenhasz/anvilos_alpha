{
  "module_name": "xilinx_hwicap.c",
  "hash_id": "b3cf1c06ecfb42aa27ce651cba20a9ab3f6708e85436b584c987fe685c3f2ee7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/xilinx_hwicap/xilinx_hwicap.c",
  "human_readable_source": " \n\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/ioport.h>\n#include <linux/interrupt.h>\n#include <linux/fcntl.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/proc_fs.h>\n#include <linux/mutex.h>\n#include <linux/sysctl.h>\n#include <linux/fs.h>\n#include <linux/cdev.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n\n#ifdef CONFIG_OF\n \n#include <linux/of_address.h>\n#include <linux/of_device.h>\n#include <linux/of_platform.h>\n#endif\n\n#include \"xilinx_hwicap.h\"\n#include \"buffer_icap.h\"\n#include \"fifo_icap.h\"\n\n#define DRIVER_NAME \"icap\"\n\n#define HWICAP_REGS   (0x10000)\n\n#define XHWICAP_MAJOR 259\n#define XHWICAP_MINOR 0\n#define HWICAP_DEVICES 1\n\n \nstatic DEFINE_MUTEX(hwicap_mutex);\nstatic bool probed_devices[HWICAP_DEVICES];\nstatic struct mutex icap_sem;\n\nstatic const struct class icap_class = {\n\t.name = \"xilinx_config\",\n};\n\n#define UNIMPLEMENTED 0xFFFF\n\nstatic const struct config_registers v2_config_registers = {\n\t.CRC = 0,\n\t.FAR = 1,\n\t.FDRI = 2,\n\t.FDRO = 3,\n\t.CMD = 4,\n\t.CTL = 5,\n\t.MASK = 6,\n\t.STAT = 7,\n\t.LOUT = 8,\n\t.COR = 9,\n\t.MFWR = 10,\n\t.FLR = 11,\n\t.KEY = 12,\n\t.CBC = 13,\n\t.IDCODE = 14,\n\t.AXSS = UNIMPLEMENTED,\n\t.C0R_1 = UNIMPLEMENTED,\n\t.CSOB = UNIMPLEMENTED,\n\t.WBSTAR = UNIMPLEMENTED,\n\t.TIMER = UNIMPLEMENTED,\n\t.BOOTSTS = UNIMPLEMENTED,\n\t.CTL_1 = UNIMPLEMENTED,\n};\n\nstatic const struct config_registers v4_config_registers = {\n\t.CRC = 0,\n\t.FAR = 1,\n\t.FDRI = 2,\n\t.FDRO = 3,\n\t.CMD = 4,\n\t.CTL = 5,\n\t.MASK = 6,\n\t.STAT = 7,\n\t.LOUT = 8,\n\t.COR = 9,\n\t.MFWR = 10,\n\t.FLR = UNIMPLEMENTED,\n\t.KEY = UNIMPLEMENTED,\n\t.CBC = 11,\n\t.IDCODE = 12,\n\t.AXSS = 13,\n\t.C0R_1 = UNIMPLEMENTED,\n\t.CSOB = UNIMPLEMENTED,\n\t.WBSTAR = UNIMPLEMENTED,\n\t.TIMER = UNIMPLEMENTED,\n\t.BOOTSTS = UNIMPLEMENTED,\n\t.CTL_1 = UNIMPLEMENTED,\n};\n\nstatic const struct config_registers v5_config_registers = {\n\t.CRC = 0,\n\t.FAR = 1,\n\t.FDRI = 2,\n\t.FDRO = 3,\n\t.CMD = 4,\n\t.CTL = 5,\n\t.MASK = 6,\n\t.STAT = 7,\n\t.LOUT = 8,\n\t.COR = 9,\n\t.MFWR = 10,\n\t.FLR = UNIMPLEMENTED,\n\t.KEY = UNIMPLEMENTED,\n\t.CBC = 11,\n\t.IDCODE = 12,\n\t.AXSS = 13,\n\t.C0R_1 = 14,\n\t.CSOB = 15,\n\t.WBSTAR = 16,\n\t.TIMER = 17,\n\t.BOOTSTS = 18,\n\t.CTL_1 = 19,\n};\n\nstatic const struct config_registers v6_config_registers = {\n\t.CRC = 0,\n\t.FAR = 1,\n\t.FDRI = 2,\n\t.FDRO = 3,\n\t.CMD = 4,\n\t.CTL = 5,\n\t.MASK = 6,\n\t.STAT = 7,\n\t.LOUT = 8,\n\t.COR = 9,\n\t.MFWR = 10,\n\t.FLR = UNIMPLEMENTED,\n\t.KEY = UNIMPLEMENTED,\n\t.CBC = 11,\n\t.IDCODE = 12,\n\t.AXSS = 13,\n\t.C0R_1 = 14,\n\t.CSOB = 15,\n\t.WBSTAR = 16,\n\t.TIMER = 17,\n\t.BOOTSTS = 22,\n\t.CTL_1 = 24,\n};\n\n \nstatic int hwicap_command_desync(struct hwicap_drvdata *drvdata)\n{\n\tu32 buffer[4];\n\tu32 index = 0;\n\n\t \n\tbuffer[index++] = hwicap_type_1_write(drvdata->config_regs->CMD) | 1;\n\tbuffer[index++] = XHI_CMD_DESYNCH;\n\tbuffer[index++] = XHI_NOOP_PACKET;\n\tbuffer[index++] = XHI_NOOP_PACKET;\n\n\t \n\treturn drvdata->config->set_configuration(drvdata,\n\t\t\t&buffer[0], index);\n}\n\n \nstatic int hwicap_get_configuration_register(struct hwicap_drvdata *drvdata,\n\t\tu32 reg, u32 *reg_data)\n{\n\tint status;\n\tu32 buffer[6];\n\tu32 index = 0;\n\n\t \n\tbuffer[index++] = XHI_DUMMY_PACKET;\n\tbuffer[index++] = XHI_NOOP_PACKET;\n\tbuffer[index++] = XHI_SYNC_PACKET;\n\tbuffer[index++] = XHI_NOOP_PACKET;\n\tbuffer[index++] = XHI_NOOP_PACKET;\n\n\t \n\tstatus = drvdata->config->set_configuration(drvdata,\n\t\t\t\t\t\t    &buffer[0], index);\n\tif (status)\n\t\treturn status;\n\n\t \n\tstatus = drvdata->config->get_status(drvdata);\n\tif ((status & XHI_SR_DALIGN_MASK) != XHI_SR_DALIGN_MASK)\n\t\treturn -EIO;\n\n\tindex = 0;\n\tbuffer[index++] = hwicap_type_1_read(reg) | 1;\n\tbuffer[index++] = XHI_NOOP_PACKET;\n\tbuffer[index++] = XHI_NOOP_PACKET;\n\n\t \n\tstatus = drvdata->config->set_configuration(drvdata,\n\t\t\t&buffer[0], index);\n\tif (status)\n\t\treturn status;\n\n\t \n\tstatus = drvdata->config->get_configuration(drvdata, reg_data, 1);\n\tif (status)\n\t\treturn status;\n\n\treturn 0;\n}\n\nstatic int hwicap_initialize_hwicap(struct hwicap_drvdata *drvdata)\n{\n\tint status;\n\tu32 idcode;\n\n\tdev_dbg(drvdata->dev, \"initializing\\n\");\n\n\t \n\tdev_dbg(drvdata->dev, \"Reset...\\n\");\n\tdrvdata->config->reset(drvdata);\n\n\tdev_dbg(drvdata->dev, \"Desync...\\n\");\n\tstatus = hwicap_command_desync(drvdata);\n\tif (status)\n\t\treturn status;\n\n\t \n\tdev_dbg(drvdata->dev, \"Reading IDCODE...\\n\");\n\tstatus = hwicap_get_configuration_register(\n\t\t\tdrvdata, drvdata->config_regs->IDCODE, &idcode);\n\tdev_dbg(drvdata->dev, \"IDCODE = %x\\n\", idcode);\n\tif (status)\n\t\treturn status;\n\n\tdev_dbg(drvdata->dev, \"Desync...\\n\");\n\tstatus = hwicap_command_desync(drvdata);\n\tif (status)\n\t\treturn status;\n\n\treturn 0;\n}\n\nstatic ssize_t\nhwicap_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct hwicap_drvdata *drvdata = file->private_data;\n\tssize_t bytes_to_read = 0;\n\tu32 *kbuf;\n\tu32 words;\n\tu32 bytes_remaining;\n\tint status;\n\n\tstatus = mutex_lock_interruptible(&drvdata->sem);\n\tif (status)\n\t\treturn status;\n\n\tif (drvdata->read_buffer_in_use) {\n\t\t \n\t\t \n\t\t \n\t\tbytes_to_read =\n\t\t\t(count < drvdata->read_buffer_in_use) ? count :\n\t\t\tdrvdata->read_buffer_in_use;\n\n\t\t \n\t\tif (copy_to_user(buf, drvdata->read_buffer, bytes_to_read)) {\n\t\t\tstatus = -EFAULT;\n\t\t\tgoto error;\n\t\t}\n\t\tdrvdata->read_buffer_in_use -= bytes_to_read;\n\t\tmemmove(drvdata->read_buffer,\n\t\t       drvdata->read_buffer + bytes_to_read,\n\t\t       4 - bytes_to_read);\n\t} else {\n\t\t \n\t\tkbuf = (u32 *) get_zeroed_page(GFP_KERNEL);\n\t\tif (!kbuf) {\n\t\t\tstatus = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\n\t\t \n\t\t \n\t\twords = ((count + 3) >> 2);\n\t\tbytes_to_read = words << 2;\n\n\t\tif (bytes_to_read > PAGE_SIZE)\n\t\t\tbytes_to_read = PAGE_SIZE;\n\n\t\t \n\t\tbytes_remaining = bytes_to_read & 3;\n\t\tbytes_to_read &= ~3;\n\t\twords = bytes_to_read >> 2;\n\n\t\tstatus = drvdata->config->get_configuration(drvdata,\n\t\t\t\tkbuf, words);\n\n\t\t \n\t\tif (status) {\n\t\t\tfree_page((unsigned long)kbuf);\n\t\t\tgoto error;\n\t\t}\n\n\t\t \n\t\tif (copy_to_user(buf, kbuf, bytes_to_read)) {\n\t\t\tfree_page((unsigned long)kbuf);\n\t\t\tstatus = -EFAULT;\n\t\t\tgoto error;\n\t\t}\n\t\tmemcpy(drvdata->read_buffer,\n\t\t       kbuf,\n\t\t       bytes_remaining);\n\t\tdrvdata->read_buffer_in_use = bytes_remaining;\n\t\tfree_page((unsigned long)kbuf);\n\t}\n\tstatus = bytes_to_read;\n error:\n\tmutex_unlock(&drvdata->sem);\n\treturn status;\n}\n\nstatic ssize_t\nhwicap_write(struct file *file, const char __user *buf,\n\t\tsize_t count, loff_t *ppos)\n{\n\tstruct hwicap_drvdata *drvdata = file->private_data;\n\tssize_t written = 0;\n\tssize_t left = count;\n\tu32 *kbuf;\n\tssize_t len;\n\tssize_t status;\n\n\tstatus = mutex_lock_interruptible(&drvdata->sem);\n\tif (status)\n\t\treturn status;\n\n\tleft += drvdata->write_buffer_in_use;\n\n\t \n\tif (left < 4) {\n\t\tstatus = 0;\n\t\tgoto error;\n\t}\n\n\tkbuf = (u32 *) __get_free_page(GFP_KERNEL);\n\tif (!kbuf) {\n\t\tstatus = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\twhile (left > 3) {\n\t\t \n\t\t \n\t\tlen = left;\n\n\t\tif (len > PAGE_SIZE)\n\t\t\tlen = PAGE_SIZE;\n\t\tlen &= ~3;\n\n\t\tif (drvdata->write_buffer_in_use) {\n\t\t\tmemcpy(kbuf, drvdata->write_buffer,\n\t\t\t\t\tdrvdata->write_buffer_in_use);\n\t\t\tif (copy_from_user(\n\t\t\t    (((char *)kbuf) + drvdata->write_buffer_in_use),\n\t\t\t    buf + written,\n\t\t\t    len - (drvdata->write_buffer_in_use))) {\n\t\t\t\tfree_page((unsigned long)kbuf);\n\t\t\t\tstatus = -EFAULT;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t} else {\n\t\t\tif (copy_from_user(kbuf, buf + written, len)) {\n\t\t\t\tfree_page((unsigned long)kbuf);\n\t\t\t\tstatus = -EFAULT;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\n\t\tstatus = drvdata->config->set_configuration(drvdata,\n\t\t\t\tkbuf, len >> 2);\n\n\t\tif (status) {\n\t\t\tfree_page((unsigned long)kbuf);\n\t\t\tstatus = -EFAULT;\n\t\t\tgoto error;\n\t\t}\n\t\tif (drvdata->write_buffer_in_use) {\n\t\t\tlen -= drvdata->write_buffer_in_use;\n\t\t\tleft -= drvdata->write_buffer_in_use;\n\t\t\tdrvdata->write_buffer_in_use = 0;\n\t\t}\n\t\twritten += len;\n\t\tleft -= len;\n\t}\n\tif ((left > 0) && (left < 4)) {\n\t\tif (!copy_from_user(drvdata->write_buffer,\n\t\t\t\t\t\tbuf + written, left)) {\n\t\t\tdrvdata->write_buffer_in_use = left;\n\t\t\twritten += left;\n\t\t\tleft = 0;\n\t\t}\n\t}\n\n\tfree_page((unsigned long)kbuf);\n\tstatus = written;\n error:\n\tmutex_unlock(&drvdata->sem);\n\treturn status;\n}\n\nstatic int hwicap_open(struct inode *inode, struct file *file)\n{\n\tstruct hwicap_drvdata *drvdata;\n\tint status;\n\n\tmutex_lock(&hwicap_mutex);\n\tdrvdata = container_of(inode->i_cdev, struct hwicap_drvdata, cdev);\n\n\tstatus = mutex_lock_interruptible(&drvdata->sem);\n\tif (status)\n\t\tgoto out;\n\n\tif (drvdata->is_open) {\n\t\tstatus = -EBUSY;\n\t\tgoto error;\n\t}\n\n\tstatus = hwicap_initialize_hwicap(drvdata);\n\tif (status) {\n\t\tdev_err(drvdata->dev, \"Failed to open file\");\n\t\tgoto error;\n\t}\n\n\tfile->private_data = drvdata;\n\tdrvdata->write_buffer_in_use = 0;\n\tdrvdata->read_buffer_in_use = 0;\n\tdrvdata->is_open = 1;\n\n error:\n\tmutex_unlock(&drvdata->sem);\n out:\n\tmutex_unlock(&hwicap_mutex);\n\treturn status;\n}\n\nstatic int hwicap_release(struct inode *inode, struct file *file)\n{\n\tstruct hwicap_drvdata *drvdata = file->private_data;\n\tint i;\n\tint status = 0;\n\n\tmutex_lock(&drvdata->sem);\n\n\tif (drvdata->write_buffer_in_use) {\n\t\t \n\t\tfor (i = drvdata->write_buffer_in_use; i < 4; i++)\n\t\t\tdrvdata->write_buffer[i] = 0;\n\n\t\tstatus = drvdata->config->set_configuration(drvdata,\n\t\t\t\t(u32 *) drvdata->write_buffer, 1);\n\t\tif (status)\n\t\t\tgoto error;\n\t}\n\n\tstatus = hwicap_command_desync(drvdata);\n\tif (status)\n\t\tgoto error;\n\n error:\n\tdrvdata->is_open = 0;\n\tmutex_unlock(&drvdata->sem);\n\treturn status;\n}\n\nstatic const struct file_operations hwicap_fops = {\n\t.owner = THIS_MODULE,\n\t.write = hwicap_write,\n\t.read = hwicap_read,\n\t.open = hwicap_open,\n\t.release = hwicap_release,\n\t.llseek = noop_llseek,\n};\n\nstatic int hwicap_setup(struct device *dev, int id,\n\t\tconst struct resource *regs_res,\n\t\tconst struct hwicap_driver_config *config,\n\t\tconst struct config_registers *config_regs)\n{\n\tdev_t devt;\n\tstruct hwicap_drvdata *drvdata = NULL;\n\tint retval = 0;\n\n\tdev_info(dev, \"Xilinx icap port driver\\n\");\n\n\tmutex_lock(&icap_sem);\n\n\tif (id < 0) {\n\t\tfor (id = 0; id < HWICAP_DEVICES; id++)\n\t\t\tif (!probed_devices[id])\n\t\t\t\tbreak;\n\t}\n\tif (id < 0 || id >= HWICAP_DEVICES) {\n\t\tmutex_unlock(&icap_sem);\n\t\tdev_err(dev, \"%s%i too large\\n\", DRIVER_NAME, id);\n\t\treturn -EINVAL;\n\t}\n\tif (probed_devices[id]) {\n\t\tmutex_unlock(&icap_sem);\n\t\tdev_err(dev, \"cannot assign to %s%i; it is already in use\\n\",\n\t\t\tDRIVER_NAME, id);\n\t\treturn -EBUSY;\n\t}\n\n\tprobed_devices[id] = 1;\n\tmutex_unlock(&icap_sem);\n\n\tdevt = MKDEV(XHWICAP_MAJOR, XHWICAP_MINOR + id);\n\n\tdrvdata = kzalloc(sizeof(struct hwicap_drvdata), GFP_KERNEL);\n\tif (!drvdata) {\n\t\tretval = -ENOMEM;\n\t\tgoto failed0;\n\t}\n\tdev_set_drvdata(dev, (void *)drvdata);\n\n\tif (!regs_res) {\n\t\tdev_err(dev, \"Couldn't get registers resource\\n\");\n\t\tretval = -EFAULT;\n\t\tgoto failed1;\n\t}\n\n\tdrvdata->mem_start = regs_res->start;\n\tdrvdata->mem_end = regs_res->end;\n\tdrvdata->mem_size = resource_size(regs_res);\n\n\tif (!request_mem_region(drvdata->mem_start,\n\t\t\t\t\tdrvdata->mem_size, DRIVER_NAME)) {\n\t\tdev_err(dev, \"Couldn't lock memory region at %Lx\\n\",\n\t\t\t(unsigned long long) regs_res->start);\n\t\tretval = -EBUSY;\n\t\tgoto failed1;\n\t}\n\n\tdrvdata->devt = devt;\n\tdrvdata->dev = dev;\n\tdrvdata->base_address = ioremap(drvdata->mem_start, drvdata->mem_size);\n\tif (!drvdata->base_address) {\n\t\tdev_err(dev, \"ioremap() failed\\n\");\n\t\tretval = -ENOMEM;\n\t\tgoto failed2;\n\t}\n\n\tdrvdata->config = config;\n\tdrvdata->config_regs = config_regs;\n\n\tmutex_init(&drvdata->sem);\n\tdrvdata->is_open = 0;\n\n\tdev_info(dev, \"ioremap %llx to %p with size %llx\\n\",\n\t\t (unsigned long long) drvdata->mem_start,\n\t\t drvdata->base_address,\n\t\t (unsigned long long) drvdata->mem_size);\n\n\tcdev_init(&drvdata->cdev, &hwicap_fops);\n\tdrvdata->cdev.owner = THIS_MODULE;\n\tretval = cdev_add(&drvdata->cdev, devt, 1);\n\tif (retval) {\n\t\tdev_err(dev, \"cdev_add() failed\\n\");\n\t\tgoto failed3;\n\t}\n\n\tdevice_create(&icap_class, dev, devt, NULL, \"%s%d\", DRIVER_NAME, id);\n\treturn 0;\t\t \n\n failed3:\n\tiounmap(drvdata->base_address);\n\n failed2:\n\trelease_mem_region(regs_res->start, drvdata->mem_size);\n\n failed1:\n\tkfree(drvdata);\n\n failed0:\n\tmutex_lock(&icap_sem);\n\tprobed_devices[id] = 0;\n\tmutex_unlock(&icap_sem);\n\n\treturn retval;\n}\n\nstatic struct hwicap_driver_config buffer_icap_config = {\n\t.get_configuration = buffer_icap_get_configuration,\n\t.set_configuration = buffer_icap_set_configuration,\n\t.get_status = buffer_icap_get_status,\n\t.reset = buffer_icap_reset,\n};\n\nstatic struct hwicap_driver_config fifo_icap_config = {\n\t.get_configuration = fifo_icap_get_configuration,\n\t.set_configuration = fifo_icap_set_configuration,\n\t.get_status = fifo_icap_get_status,\n\t.reset = fifo_icap_reset,\n};\n\n#ifdef CONFIG_OF\nstatic int hwicap_of_probe(struct platform_device *op,\n\t\t\t\t     const struct hwicap_driver_config *config)\n{\n\tstruct resource res;\n\tconst unsigned int *id;\n\tconst char *family;\n\tint rc;\n\tconst struct config_registers *regs;\n\n\n\trc = of_address_to_resource(op->dev.of_node, 0, &res);\n\tif (rc) {\n\t\tdev_err(&op->dev, \"invalid address\\n\");\n\t\treturn rc;\n\t}\n\n\tid = of_get_property(op->dev.of_node, \"port-number\", NULL);\n\n\t \n\tregs = &v4_config_registers;\n\tfamily = of_get_property(op->dev.of_node, \"xlnx,family\", NULL);\n\n\tif (family) {\n\t\tif (!strcmp(family, \"virtex2p\"))\n\t\t\tregs = &v2_config_registers;\n\t\telse if (!strcmp(family, \"virtex4\"))\n\t\t\tregs = &v4_config_registers;\n\t\telse if (!strcmp(family, \"virtex5\"))\n\t\t\tregs = &v5_config_registers;\n\t\telse if (!strcmp(family, \"virtex6\"))\n\t\t\tregs = &v6_config_registers;\n\t}\n\treturn hwicap_setup(&op->dev, id ? *id : -1, &res, config,\n\t\t\tregs);\n}\n#else\nstatic inline int hwicap_of_probe(struct platform_device *op,\n\t\t\t\t  const struct hwicap_driver_config *config)\n{\n\treturn -EINVAL;\n}\n#endif  \n\nstatic const struct of_device_id hwicap_of_match[];\nstatic int hwicap_drv_probe(struct platform_device *pdev)\n{\n\tconst struct of_device_id *match;\n\tstruct resource *res;\n\tconst struct config_registers *regs;\n\tconst char *family;\n\n\tmatch = of_match_device(hwicap_of_match, &pdev->dev);\n\tif (match)\n\t\treturn hwicap_of_probe(pdev, match->data);\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -ENODEV;\n\n\t \n\tregs = &v4_config_registers;\n\tfamily = pdev->dev.platform_data;\n\n\tif (family) {\n\t\tif (!strcmp(family, \"virtex2p\"))\n\t\t\tregs = &v2_config_registers;\n\t\telse if (!strcmp(family, \"virtex4\"))\n\t\t\tregs = &v4_config_registers;\n\t\telse if (!strcmp(family, \"virtex5\"))\n\t\t\tregs = &v5_config_registers;\n\t\telse if (!strcmp(family, \"virtex6\"))\n\t\t\tregs = &v6_config_registers;\n\t}\n\n\treturn hwicap_setup(&pdev->dev, pdev->id, res,\n\t\t\t&buffer_icap_config, regs);\n}\n\nstatic void hwicap_drv_remove(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct hwicap_drvdata *drvdata;\n\n\tdrvdata = dev_get_drvdata(dev);\n\n\tdevice_destroy(&icap_class, drvdata->devt);\n\tcdev_del(&drvdata->cdev);\n\tiounmap(drvdata->base_address);\n\trelease_mem_region(drvdata->mem_start, drvdata->mem_size);\n\tkfree(drvdata);\n\n\tmutex_lock(&icap_sem);\n\tprobed_devices[MINOR(dev->devt)-XHWICAP_MINOR] = 0;\n\tmutex_unlock(&icap_sem);\n}\n\n#ifdef CONFIG_OF\n \nstatic const struct of_device_id hwicap_of_match[] = {\n\t{ .compatible = \"xlnx,opb-hwicap-1.00.b\", .data = &buffer_icap_config},\n\t{ .compatible = \"xlnx,xps-hwicap-1.00.a\", .data = &fifo_icap_config},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, hwicap_of_match);\n#else\n#define hwicap_of_match NULL\n#endif\n\nstatic struct platform_driver hwicap_platform_driver = {\n\t.probe = hwicap_drv_probe,\n\t.remove_new = hwicap_drv_remove,\n\t.driver = {\n\t\t.name = DRIVER_NAME,\n\t\t.of_match_table = hwicap_of_match,\n\t},\n};\n\nstatic int __init hwicap_module_init(void)\n{\n\tdev_t devt;\n\tint retval;\n\n\tretval = class_register(&icap_class);\n\tif (retval)\n\t\treturn retval;\n\tmutex_init(&icap_sem);\n\n\tdevt = MKDEV(XHWICAP_MAJOR, XHWICAP_MINOR);\n\tretval = register_chrdev_region(devt,\n\t\t\t\t\tHWICAP_DEVICES,\n\t\t\t\t\tDRIVER_NAME);\n\tif (retval < 0)\n\t\treturn retval;\n\n\tretval = platform_driver_register(&hwicap_platform_driver);\n\tif (retval)\n\t\tgoto failed;\n\n\treturn retval;\n\n failed:\n\tunregister_chrdev_region(devt, HWICAP_DEVICES);\n\n\treturn retval;\n}\n\nstatic void __exit hwicap_module_cleanup(void)\n{\n\tdev_t devt = MKDEV(XHWICAP_MAJOR, XHWICAP_MINOR);\n\n\tclass_unregister(&icap_class);\n\n\tplatform_driver_unregister(&hwicap_platform_driver);\n\n\tunregister_chrdev_region(devt, HWICAP_DEVICES);\n}\n\nmodule_init(hwicap_module_init);\nmodule_exit(hwicap_module_cleanup);\n\nMODULE_AUTHOR(\"Xilinx, Inc; Xilinx Research Labs Group\");\nMODULE_DESCRIPTION(\"Xilinx ICAP Port Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}