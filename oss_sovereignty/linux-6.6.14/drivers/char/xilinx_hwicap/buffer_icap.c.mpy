{
  "module_name": "buffer_icap.c",
  "hash_id": "f74aef7adf5506cfe0f9cd2ab21b3af688550e499eb4c94063701f7aacf8eb36",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/xilinx_hwicap/buffer_icap.c",
  "human_readable_source": " \n\n#include \"buffer_icap.h\"\n\n \n#define XHI_MAX_BUFFER_BYTES        2048\n#define XHI_MAX_BUFFER_INTS         (XHI_MAX_BUFFER_BYTES >> 2)\n\n \n#define XHI_DEVICE_READ_ERROR       -1\n#define XHI_DEVICE_WRITE_ERROR      -2\n#define XHI_BUFFER_OVERFLOW_ERROR   -3\n\n#define XHI_DEVICE_READ             0x1\n#define XHI_DEVICE_WRITE            0x0\n\n \n#define XHI_CYCLE_DONE              0\n#define XHI_CYCLE_EXECUTING         1\n\n \n\n \n#define XHI_SIZE_REG_OFFSET        0x800L\n \n#define XHI_BRAM_OFFSET_REG_OFFSET 0x804L\n \n#define XHI_RNC_REG_OFFSET         0x808L\n \n#define XHI_STATUS_REG_OFFSET      0x80CL\n\n \n#define XHI_CONFIGURE              0x0UL\n#define XHI_READBACK               0x1UL\n\n \n#define XHI_NOT_FINISHED           0x0UL\n#define XHI_FINISHED               0x1UL\n\n#define XHI_BUFFER_START 0\n\n \nu32 buffer_icap_get_status(struct hwicap_drvdata *drvdata)\n{\n\treturn in_be32(drvdata->base_address + XHI_STATUS_REG_OFFSET);\n}\n\n \nstatic inline u32 buffer_icap_get_bram(void __iomem *base_address,\n\t\tu32 offset)\n{\n\treturn in_be32(base_address + (offset << 2));\n}\n\n \nstatic inline bool buffer_icap_busy(void __iomem *base_address)\n{\n\tu32 status = in_be32(base_address + XHI_STATUS_REG_OFFSET);\n\treturn (status & 1) == XHI_NOT_FINISHED;\n}\n\n \nstatic inline void buffer_icap_set_size(void __iomem *base_address,\n\t\tu32 data)\n{\n\tout_be32(base_address + XHI_SIZE_REG_OFFSET, data);\n}\n\n \nstatic inline void buffer_icap_set_offset(void __iomem *base_address,\n\t\tu32 data)\n{\n\tout_be32(base_address + XHI_BRAM_OFFSET_REG_OFFSET, data);\n}\n\n \nstatic inline void buffer_icap_set_rnc(void __iomem *base_address,\n\t\tu32 data)\n{\n\tout_be32(base_address + XHI_RNC_REG_OFFSET, data);\n}\n\n \nstatic inline void buffer_icap_set_bram(void __iomem *base_address,\n\t\tu32 offset, u32 data)\n{\n\tout_be32(base_address + (offset << 2), data);\n}\n\n \nstatic int buffer_icap_device_read(struct hwicap_drvdata *drvdata,\n\t\tu32 offset, u32 count)\n{\n\n\ts32 retries = 0;\n\tvoid __iomem *base_address = drvdata->base_address;\n\n\tif (buffer_icap_busy(base_address))\n\t\treturn -EBUSY;\n\n\tif ((offset + count) > XHI_MAX_BUFFER_INTS)\n\t\treturn -EINVAL;\n\n\t \n\tbuffer_icap_set_size(base_address, (count << 2));\n\tbuffer_icap_set_offset(base_address, offset);\n\tbuffer_icap_set_rnc(base_address, XHI_READBACK);\n\n\twhile (buffer_icap_busy(base_address)) {\n\t\tretries++;\n\t\tif (retries > XHI_MAX_RETRIES)\n\t\t\treturn -EBUSY;\n\t}\n\treturn 0;\n\n};\n\n \nstatic int buffer_icap_device_write(struct hwicap_drvdata *drvdata,\n\t\tu32 offset, u32 count)\n{\n\n\ts32 retries = 0;\n\tvoid __iomem *base_address = drvdata->base_address;\n\n\tif (buffer_icap_busy(base_address))\n\t\treturn -EBUSY;\n\n\tif ((offset + count) > XHI_MAX_BUFFER_INTS)\n\t\treturn -EINVAL;\n\n\t \n\tbuffer_icap_set_size(base_address, count << 2);\n\tbuffer_icap_set_offset(base_address, offset);\n\tbuffer_icap_set_rnc(base_address, XHI_CONFIGURE);\n\n\twhile (buffer_icap_busy(base_address)) {\n\t\tretries++;\n\t\tif (retries > XHI_MAX_RETRIES)\n\t\t\treturn -EBUSY;\n\t}\n\treturn 0;\n\n};\n\n \nvoid buffer_icap_reset(struct hwicap_drvdata *drvdata)\n{\n    out_be32(drvdata->base_address + XHI_STATUS_REG_OFFSET, 0xFEFE);\n}\n\n \nint buffer_icap_set_configuration(struct hwicap_drvdata *drvdata, u32 *data,\n\t\t\t     u32 size)\n{\n\tint status;\n\ts32 buffer_count = 0;\n\tbool dirty = false;\n\tu32 i;\n\tvoid __iomem *base_address = drvdata->base_address;\n\n\t \n\tfor (i = 0, buffer_count = 0; i < size; i++) {\n\n\t\t \n\t\tbuffer_icap_set_bram(base_address, buffer_count, data[i]);\n\t\tdirty = true;\n\n\t\tif (buffer_count < XHI_MAX_BUFFER_INTS - 1) {\n\t\t\tbuffer_count++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tstatus = buffer_icap_device_write(\n\t\t\t\tdrvdata,\n\t\t\t\tXHI_BUFFER_START,\n\t\t\t\tXHI_MAX_BUFFER_INTS);\n\t\tif (status != 0) {\n\t\t\t \n\t\t\tbuffer_icap_reset(drvdata);\n\t\t\treturn status;\n\t\t}\n\n\t\tbuffer_count = 0;\n\t\tdirty = false;\n\t}\n\n\t \n\tif (dirty) {\n\t\t \n\t\tstatus = buffer_icap_device_write(drvdata, XHI_BUFFER_START,\n\t\t\t\t\t     buffer_count);\n\t\tif (status != 0) {\n\t\t\t \n\t\t\tbuffer_icap_reset(drvdata);\n\t\t}\n\t\treturn status;\n\t}\n\n\treturn 0;\n};\n\n \nint buffer_icap_get_configuration(struct hwicap_drvdata *drvdata, u32 *data,\n\t\t\t     u32 size)\n{\n\tint status;\n\ts32 buffer_count = 0;\n\tu32 i;\n\tvoid __iomem *base_address = drvdata->base_address;\n\n\t \n\tfor (i = 0, buffer_count = XHI_MAX_BUFFER_INTS; i < size; i++) {\n\t\tif (buffer_count == XHI_MAX_BUFFER_INTS) {\n\t\t\tu32 words_remaining = size - i;\n\t\t\tu32 words_to_read =\n\t\t\t\twords_remaining <\n\t\t\t\tXHI_MAX_BUFFER_INTS ? words_remaining :\n\t\t\t\tXHI_MAX_BUFFER_INTS;\n\n\t\t\t \n\t\t\tstatus = buffer_icap_device_read(\n\t\t\t\t\tdrvdata,\n\t\t\t\t\tXHI_BUFFER_START,\n\t\t\t\t\twords_to_read);\n\t\t\tif (status != 0) {\n\t\t\t\t \n\t\t\t\tbuffer_icap_reset(drvdata);\n\t\t\t\treturn status;\n\t\t\t}\n\n\t\t\tbuffer_count = 0;\n\t\t}\n\n\t\t \n\t\tdata[i] = buffer_icap_get_bram(base_address, buffer_count);\n\t\tbuffer_count++;\n\t}\n\n\treturn 0;\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}