{
  "module_name": "lp.c",
  "hash_id": "28af4d8a7e02844bb4d8057a2dc028eeeacccc082824407fd8d53a8de3e6bf3e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/lp.c",
  "human_readable_source": "\n \n\n \n\n \n\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/major.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/delay.h>\n#include <linux/poll.h>\n#include <linux/console.h>\n#include <linux/device.h>\n#include <linux/wait.h>\n#include <linux/jiffies.h>\n#include <linux/mutex.h>\n#include <linux/compat.h>\n\n#include <linux/parport.h>\n#undef LP_STATS\n#include <linux/lp.h>\n\n#include <asm/irq.h>\n#include <linux/uaccess.h>\n\n \n#define LP_NO 8\n\nstatic DEFINE_MUTEX(lp_mutex);\nstatic struct lp_struct lp_table[LP_NO];\nstatic int port_num[LP_NO];\n\nstatic unsigned int lp_count = 0;\nstatic const struct class lp_class = {\n\t.name = \"printer\",\n};\n\n#ifdef CONFIG_LP_CONSOLE\nstatic struct parport *console_registered;\n#endif  \n\n#undef LP_DEBUG\n\n \n#define LP_PREEMPT_REQUEST 1\n#define LP_PARPORT_CLAIMED 2\n\n \n\n#define r_dtr(x)\t(parport_read_data(lp_table[(x)].dev->port))\n#define r_str(x)\t(parport_read_status(lp_table[(x)].dev->port))\n#define w_ctr(x,y)\tdo { parport_write_control(lp_table[(x)].dev->port, (y)); } while (0)\n#define w_dtr(x,y)\tdo { parport_write_data(lp_table[(x)].dev->port, (y)); } while (0)\n\n \nstatic void lp_claim_parport_or_block(struct lp_struct *this_lp)\n{\n\tif (!test_and_set_bit(LP_PARPORT_CLAIMED, &this_lp->bits)) {\n\t\tparport_claim_or_block(this_lp->dev);\n\t}\n}\n\n \nstatic void lp_release_parport(struct lp_struct *this_lp)\n{\n\tif (test_and_clear_bit(LP_PARPORT_CLAIMED, &this_lp->bits)) {\n\t\tparport_release(this_lp->dev);\n\t}\n}\n\n\n\nstatic int lp_preempt(void *handle)\n{\n\tstruct lp_struct *this_lp = (struct lp_struct *)handle;\n\tset_bit(LP_PREEMPT_REQUEST, &this_lp->bits);\n\treturn 1;\n}\n\n\n \nstatic int lp_negotiate(struct parport *port, int mode)\n{\n\tif (parport_negotiate(port, mode) != 0) {\n\t\tmode = IEEE1284_MODE_COMPAT;\n\t\tparport_negotiate(port, mode);\n\t}\n\n\treturn mode;\n}\n\nstatic int lp_reset(int minor)\n{\n\tint retval;\n\tlp_claim_parport_or_block(&lp_table[minor]);\n\tw_ctr(minor, LP_PSELECP);\n\tudelay(LP_DELAY);\n\tw_ctr(minor, LP_PSELECP | LP_PINITP);\n\tretval = r_str(minor);\n\tlp_release_parport(&lp_table[minor]);\n\treturn retval;\n}\n\nstatic void lp_error(int minor)\n{\n\tDEFINE_WAIT(wait);\n\tint polling;\n\n\tif (LP_F(minor) & LP_ABORT)\n\t\treturn;\n\n\tpolling = lp_table[minor].dev->port->irq == PARPORT_IRQ_NONE;\n\tif (polling)\n\t\tlp_release_parport(&lp_table[minor]);\n\tprepare_to_wait(&lp_table[minor].waitq, &wait, TASK_INTERRUPTIBLE);\n\tschedule_timeout(LP_TIMEOUT_POLLED);\n\tfinish_wait(&lp_table[minor].waitq, &wait);\n\tif (polling)\n\t\tlp_claim_parport_or_block(&lp_table[minor]);\n\telse\n\t\tparport_yield_blocking(lp_table[minor].dev);\n}\n\nstatic int lp_check_status(int minor)\n{\n\tint error = 0;\n\tunsigned int last = lp_table[minor].last_error;\n\tunsigned char status = r_str(minor);\n\tif ((status & LP_PERRORP) && !(LP_F(minor) & LP_CAREFUL))\n\t\t \n\t\tlast = 0;\n\telse if ((status & LP_POUTPA)) {\n\t\tif (last != LP_POUTPA) {\n\t\t\tlast = LP_POUTPA;\n\t\t\tprintk(KERN_INFO \"lp%d out of paper\\n\", minor);\n\t\t}\n\t\terror = -ENOSPC;\n\t} else if (!(status & LP_PSELECD)) {\n\t\tif (last != LP_PSELECD) {\n\t\t\tlast = LP_PSELECD;\n\t\t\tprintk(KERN_INFO \"lp%d off-line\\n\", minor);\n\t\t}\n\t\terror = -EIO;\n\t} else if (!(status & LP_PERRORP)) {\n\t\tif (last != LP_PERRORP) {\n\t\t\tlast = LP_PERRORP;\n\t\t\tprintk(KERN_INFO \"lp%d on fire\\n\", minor);\n\t\t}\n\t\terror = -EIO;\n\t} else {\n\t\tlast = 0;  \n\t}\n\n\tlp_table[minor].last_error = last;\n\n\tif (last != 0)\n\t\tlp_error(minor);\n\n\treturn error;\n}\n\nstatic int lp_wait_ready(int minor, int nonblock)\n{\n\tint error = 0;\n\n\t \n\tif (lp_table[minor].current_mode != IEEE1284_MODE_COMPAT) {\n\t\treturn 0;\n\t}\n\n\tdo {\n\t\terror = lp_check_status(minor);\n\t\tif (error && (nonblock || (LP_F(minor) & LP_ABORT)))\n\t\t\tbreak;\n\t\tif (signal_pending(current)) {\n\t\t\terror = -EINTR;\n\t\t\tbreak;\n\t\t}\n\t} while (error);\n\treturn error;\n}\n\nstatic ssize_t lp_write(struct file *file, const char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tunsigned int minor = iminor(file_inode(file));\n\tstruct parport *port = lp_table[minor].dev->port;\n\tchar *kbuf = lp_table[minor].lp_buffer;\n\tssize_t retv = 0;\n\tssize_t written;\n\tsize_t copy_size = count;\n\tint nonblock = ((file->f_flags & O_NONBLOCK) ||\n\t\t\t(LP_F(minor) & LP_ABORT));\n\n#ifdef LP_STATS\n\tif (time_after(jiffies, lp_table[minor].lastcall + LP_TIME(minor)))\n\t\tlp_table[minor].runchars = 0;\n\n\tlp_table[minor].lastcall = jiffies;\n#endif\n\n\t \n\tif (copy_size > LP_BUFFER_SIZE)\n\t\tcopy_size = LP_BUFFER_SIZE;\n\n\tif (mutex_lock_interruptible(&lp_table[minor].port_mutex))\n\t\treturn -EINTR;\n\n\tif (copy_from_user(kbuf, buf, copy_size)) {\n\t\tretv = -EFAULT;\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tlp_claim_parport_or_block(&lp_table[minor]);\n\t \n\tlp_table[minor].current_mode = lp_negotiate(port,\n\t\t\t\t\t\t    lp_table[minor].best_mode);\n\n\tparport_set_timeout(lp_table[minor].dev,\n\t\t\t    (nonblock ? PARPORT_INACTIVITY_O_NONBLOCK\n\t\t\t     : lp_table[minor].timeout));\n\n\tif ((retv = lp_wait_ready(minor, nonblock)) == 0)\n\tdo {\n\t\t \n\t\twritten = parport_write(port, kbuf, copy_size);\n\t\tif (written > 0) {\n\t\t\tcopy_size -= written;\n\t\t\tcount -= written;\n\t\t\tbuf  += written;\n\t\t\tretv += written;\n\t\t}\n\n\t\tif (signal_pending(current)) {\n\t\t\tif (retv == 0)\n\t\t\t\tretv = -EINTR;\n\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_size > 0) {\n\t\t\t \n\t\t\tint error;\n\n\t\t\tparport_negotiate(lp_table[minor].dev->port,\n\t\t\t\t\t  IEEE1284_MODE_COMPAT);\n\t\t\tlp_table[minor].current_mode = IEEE1284_MODE_COMPAT;\n\n\t\t\terror = lp_wait_ready(minor, nonblock);\n\n\t\t\tif (error) {\n\t\t\t\tif (retv == 0)\n\t\t\t\t\tretv = error;\n\t\t\t\tbreak;\n\t\t\t} else if (nonblock) {\n\t\t\t\tif (retv == 0)\n\t\t\t\t\tretv = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tparport_yield_blocking(lp_table[minor].dev);\n\t\t\tlp_table[minor].current_mode\n\t\t\t  = lp_negotiate(port,\n\t\t\t\t\t lp_table[minor].best_mode);\n\n\t\t} else if (need_resched())\n\t\t\tschedule();\n\n\t\tif (count) {\n\t\t\tcopy_size = count;\n\t\t\tif (copy_size > LP_BUFFER_SIZE)\n\t\t\t\tcopy_size = LP_BUFFER_SIZE;\n\n\t\t\tif (copy_from_user(kbuf, buf, copy_size)) {\n\t\t\t\tif (retv == 0)\n\t\t\t\t\tretv = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} while (count > 0);\n\n\tif (test_and_clear_bit(LP_PREEMPT_REQUEST,\n\t\t\t       &lp_table[minor].bits)) {\n\t\tprintk(KERN_INFO \"lp%d releasing parport\\n\", minor);\n\t\tparport_negotiate(lp_table[minor].dev->port,\n\t\t\t\t  IEEE1284_MODE_COMPAT);\n\t\tlp_table[minor].current_mode = IEEE1284_MODE_COMPAT;\n\t\tlp_release_parport(&lp_table[minor]);\n\t}\nout_unlock:\n\tmutex_unlock(&lp_table[minor].port_mutex);\n\n\treturn retv;\n}\n\n#ifdef CONFIG_PARPORT_1284\n\n \nstatic ssize_t lp_read(struct file *file, char __user *buf,\n\t\t       size_t count, loff_t *ppos)\n{\n\tDEFINE_WAIT(wait);\n\tunsigned int minor=iminor(file_inode(file));\n\tstruct parport *port = lp_table[minor].dev->port;\n\tssize_t retval = 0;\n\tchar *kbuf = lp_table[minor].lp_buffer;\n\tint nonblock = ((file->f_flags & O_NONBLOCK) ||\n\t\t\t(LP_F(minor) & LP_ABORT));\n\n\tif (count > LP_BUFFER_SIZE)\n\t\tcount = LP_BUFFER_SIZE;\n\n\tif (mutex_lock_interruptible(&lp_table[minor].port_mutex))\n\t\treturn -EINTR;\n\n\tlp_claim_parport_or_block(&lp_table[minor]);\n\n\tparport_set_timeout(lp_table[minor].dev,\n\t\t\t    (nonblock ? PARPORT_INACTIVITY_O_NONBLOCK\n\t\t\t     : lp_table[minor].timeout));\n\n\tparport_negotiate(lp_table[minor].dev->port, IEEE1284_MODE_COMPAT);\n\tif (parport_negotiate(lp_table[minor].dev->port,\n\t\t\t      IEEE1284_MODE_NIBBLE)) {\n\t\tretval = -EIO;\n\t\tgoto out;\n\t}\n\n\twhile (retval == 0) {\n\t\tretval = parport_read(port, kbuf, count);\n\n\t\tif (retval > 0)\n\t\t\tbreak;\n\n\t\tif (nonblock) {\n\t\t\tretval = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\n\t\tif (lp_table[minor].dev->port->irq == PARPORT_IRQ_NONE) {\n\t\t\tparport_negotiate(lp_table[minor].dev->port,\n\t\t\t\t\t  IEEE1284_MODE_COMPAT);\n\t\t\tlp_error(minor);\n\t\t\tif (parport_negotiate(lp_table[minor].dev->port,\n\t\t\t\t\t      IEEE1284_MODE_NIBBLE)) {\n\t\t\t\tretval = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\tprepare_to_wait(&lp_table[minor].waitq, &wait, TASK_INTERRUPTIBLE);\n\t\t\tschedule_timeout(LP_TIMEOUT_POLLED);\n\t\t\tfinish_wait(&lp_table[minor].waitq, &wait);\n\t\t}\n\n\t\tif (signal_pending(current)) {\n\t\t\tretval = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\n\t\tcond_resched();\n\t}\n\tparport_negotiate(lp_table[minor].dev->port, IEEE1284_MODE_COMPAT);\n out:\n\tlp_release_parport(&lp_table[minor]);\n\n\tif (retval > 0 && copy_to_user(buf, kbuf, retval))\n\t\tretval = -EFAULT;\n\n\tmutex_unlock(&lp_table[minor].port_mutex);\n\n\treturn retval;\n}\n\n#endif  \n\nstatic int lp_open(struct inode *inode, struct file *file)\n{\n\tunsigned int minor = iminor(inode);\n\tint ret = 0;\n\n\tmutex_lock(&lp_mutex);\n\tif (minor >= LP_NO) {\n\t\tret = -ENXIO;\n\t\tgoto out;\n\t}\n\tif ((LP_F(minor) & LP_EXIST) == 0) {\n\t\tret = -ENXIO;\n\t\tgoto out;\n\t}\n\tif (test_and_set_bit(LP_BUSY_BIT_POS, &LP_F(minor))) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\t \n\tif ((LP_F(minor) & LP_ABORTOPEN) && !(file->f_flags & O_NONBLOCK)) {\n\t\tint status;\n\t\tlp_claim_parport_or_block(&lp_table[minor]);\n\t\tstatus = r_str(minor);\n\t\tlp_release_parport(&lp_table[minor]);\n\t\tif (status & LP_POUTPA) {\n\t\t\tprintk(KERN_INFO \"lp%d out of paper\\n\", minor);\n\t\t\tLP_F(minor) &= ~LP_BUSY;\n\t\t\tret = -ENOSPC;\n\t\t\tgoto out;\n\t\t} else if (!(status & LP_PSELECD)) {\n\t\t\tprintk(KERN_INFO \"lp%d off-line\\n\", minor);\n\t\t\tLP_F(minor) &= ~LP_BUSY;\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t} else if (!(status & LP_PERRORP)) {\n\t\t\tprintk(KERN_ERR \"lp%d printer error\\n\", minor);\n\t\t\tLP_F(minor) &= ~LP_BUSY;\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tlp_table[minor].lp_buffer = kmalloc(LP_BUFFER_SIZE, GFP_KERNEL);\n\tif (!lp_table[minor].lp_buffer) {\n\t\tLP_F(minor) &= ~LP_BUSY;\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\t \n\tlp_claim_parport_or_block(&lp_table[minor]);\n\tif ((lp_table[minor].dev->port->modes & PARPORT_MODE_ECP) &&\n\t     !parport_negotiate(lp_table[minor].dev->port,\n\t\t\t\t IEEE1284_MODE_ECP)) {\n\t\tprintk(KERN_INFO \"lp%d: ECP mode\\n\", minor);\n\t\tlp_table[minor].best_mode = IEEE1284_MODE_ECP;\n\t} else {\n\t\tlp_table[minor].best_mode = IEEE1284_MODE_COMPAT;\n\t}\n\t \n\tparport_negotiate(lp_table[minor].dev->port, IEEE1284_MODE_COMPAT);\n\tlp_release_parport(&lp_table[minor]);\n\tlp_table[minor].current_mode = IEEE1284_MODE_COMPAT;\nout:\n\tmutex_unlock(&lp_mutex);\n\treturn ret;\n}\n\nstatic int lp_release(struct inode *inode, struct file *file)\n{\n\tunsigned int minor = iminor(inode);\n\n\tlp_claim_parport_or_block(&lp_table[minor]);\n\tparport_negotiate(lp_table[minor].dev->port, IEEE1284_MODE_COMPAT);\n\tlp_table[minor].current_mode = IEEE1284_MODE_COMPAT;\n\tlp_release_parport(&lp_table[minor]);\n\tkfree(lp_table[minor].lp_buffer);\n\tlp_table[minor].lp_buffer = NULL;\n\tLP_F(minor) &= ~LP_BUSY;\n\treturn 0;\n}\n\nstatic int lp_do_ioctl(unsigned int minor, unsigned int cmd,\n\tunsigned long arg, void __user *argp)\n{\n\tint status;\n\tint retval = 0;\n\n#ifdef LP_DEBUG\n\tprintk(KERN_DEBUG \"lp%d ioctl, cmd: 0x%x, arg: 0x%lx\\n\", minor, cmd, arg);\n#endif\n\tif (minor >= LP_NO)\n\t\treturn -ENODEV;\n\tif ((LP_F(minor) & LP_EXIST) == 0)\n\t\treturn -ENODEV;\n\tswitch (cmd) {\n\t\tcase LPTIME:\n\t\t\tif (arg > UINT_MAX / HZ)\n\t\t\t\treturn -EINVAL;\n\t\t\tLP_TIME(minor) = arg * HZ/100;\n\t\t\tbreak;\n\t\tcase LPCHAR:\n\t\t\tLP_CHAR(minor) = arg;\n\t\t\tbreak;\n\t\tcase LPABORT:\n\t\t\tif (arg)\n\t\t\t\tLP_F(minor) |= LP_ABORT;\n\t\t\telse\n\t\t\t\tLP_F(minor) &= ~LP_ABORT;\n\t\t\tbreak;\n\t\tcase LPABORTOPEN:\n\t\t\tif (arg)\n\t\t\t\tLP_F(minor) |= LP_ABORTOPEN;\n\t\t\telse\n\t\t\t\tLP_F(minor) &= ~LP_ABORTOPEN;\n\t\t\tbreak;\n\t\tcase LPCAREFUL:\n\t\t\tif (arg)\n\t\t\t\tLP_F(minor) |= LP_CAREFUL;\n\t\t\telse\n\t\t\t\tLP_F(minor) &= ~LP_CAREFUL;\n\t\t\tbreak;\n\t\tcase LPWAIT:\n\t\t\tLP_WAIT(minor) = arg;\n\t\t\tbreak;\n\t\tcase LPSETIRQ:\n\t\t\treturn -EINVAL;\n\t\tcase LPGETIRQ:\n\t\t\tif (copy_to_user(argp, &LP_IRQ(minor),\n\t\t\t\t\tsizeof(int)))\n\t\t\t\treturn -EFAULT;\n\t\t\tbreak;\n\t\tcase LPGETSTATUS:\n\t\t\tif (mutex_lock_interruptible(&lp_table[minor].port_mutex))\n\t\t\t\treturn -EINTR;\n\t\t\tlp_claim_parport_or_block(&lp_table[minor]);\n\t\t\tstatus = r_str(minor);\n\t\t\tlp_release_parport(&lp_table[minor]);\n\t\t\tmutex_unlock(&lp_table[minor].port_mutex);\n\n\t\t\tif (copy_to_user(argp, &status, sizeof(int)))\n\t\t\t\treturn -EFAULT;\n\t\t\tbreak;\n\t\tcase LPRESET:\n\t\t\tlp_reset(minor);\n\t\t\tbreak;\n#ifdef LP_STATS\n\t\tcase LPGETSTATS:\n\t\t\tif (copy_to_user(argp, &LP_STAT(minor),\n\t\t\t\t\tsizeof(struct lp_stats)))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (capable(CAP_SYS_ADMIN))\n\t\t\t\tmemset(&LP_STAT(minor), 0,\n\t\t\t\t\t\tsizeof(struct lp_stats));\n\t\t\tbreak;\n#endif\n\t\tcase LPGETFLAGS:\n\t\t\tstatus = LP_F(minor);\n\t\t\tif (copy_to_user(argp, &status, sizeof(int)))\n\t\t\t\treturn -EFAULT;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tretval = -EINVAL;\n\t}\n\treturn retval;\n}\n\nstatic int lp_set_timeout(unsigned int minor, s64 tv_sec, long tv_usec)\n{\n\tlong to_jiffies;\n\n\t \n\tif (tv_sec < 0 || tv_usec < 0)\n\t\treturn -EINVAL;\n\n\t \n\tif (tv_usec > 999999)\n\t\ttv_usec = 999999;\n\n\tif (tv_sec >= MAX_SEC_IN_JIFFIES - 1) {\n\t\tto_jiffies = MAX_JIFFY_OFFSET;\n\t} else {\n\t\tto_jiffies = DIV_ROUND_UP(tv_usec, 1000000/HZ);\n\t\tto_jiffies += tv_sec * (long) HZ;\n\t}\n\n\tif (to_jiffies <= 0) {\n\t\treturn -EINVAL;\n\t}\n\tlp_table[minor].timeout = to_jiffies;\n\treturn 0;\n}\n\nstatic int lp_set_timeout32(unsigned int minor, void __user *arg)\n{\n\ts32 karg[2];\n\n\tif (copy_from_user(karg, arg, sizeof(karg)))\n\t\treturn -EFAULT;\n\n\treturn lp_set_timeout(minor, karg[0], karg[1]);\n}\n\nstatic int lp_set_timeout64(unsigned int minor, void __user *arg)\n{\n\ts64 karg[2];\n\n\tif (copy_from_user(karg, arg, sizeof(karg)))\n\t\treturn -EFAULT;\n\n\t \n\tif (IS_ENABLED(CONFIG_SPARC64) && !in_compat_syscall())\n\t\tkarg[1] >>= 32;\n\n\treturn lp_set_timeout(minor, karg[0], karg[1]);\n}\n\nstatic long lp_ioctl(struct file *file, unsigned int cmd,\n\t\t\tunsigned long arg)\n{\n\tunsigned int minor;\n\tint ret;\n\n\tminor = iminor(file_inode(file));\n\tmutex_lock(&lp_mutex);\n\tswitch (cmd) {\n\tcase LPSETTIMEOUT_OLD:\n\t\tif (BITS_PER_LONG == 32) {\n\t\t\tret = lp_set_timeout32(minor, (void __user *)arg);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\t \n\tcase LPSETTIMEOUT_NEW:\n\t\tret = lp_set_timeout64(minor, (void __user *)arg);\n\t\tbreak;\n\tdefault:\n\t\tret = lp_do_ioctl(minor, cmd, arg, (void __user *)arg);\n\t\tbreak;\n\t}\n\tmutex_unlock(&lp_mutex);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_COMPAT\nstatic long lp_compat_ioctl(struct file *file, unsigned int cmd,\n\t\t\tunsigned long arg)\n{\n\tunsigned int minor;\n\tint ret;\n\n\tminor = iminor(file_inode(file));\n\tmutex_lock(&lp_mutex);\n\tswitch (cmd) {\n\tcase LPSETTIMEOUT_OLD:\n\t\tif (!COMPAT_USE_64BIT_TIME) {\n\t\t\tret = lp_set_timeout32(minor, (void __user *)arg);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\t \n\tcase LPSETTIMEOUT_NEW:\n\t\tret = lp_set_timeout64(minor, (void __user *)arg);\n\t\tbreak;\n#ifdef LP_STATS\n\tcase LPGETSTATS:\n\t\t \n\t\tret = -EINVAL;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tret = lp_do_ioctl(minor, cmd, arg, compat_ptr(arg));\n\t\tbreak;\n\t}\n\tmutex_unlock(&lp_mutex);\n\n\treturn ret;\n}\n#endif\n\nstatic const struct file_operations lp_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.write\t\t= lp_write,\n\t.unlocked_ioctl\t= lp_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t= lp_compat_ioctl,\n#endif\n\t.open\t\t= lp_open,\n\t.release\t= lp_release,\n#ifdef CONFIG_PARPORT_1284\n\t.read\t\t= lp_read,\n#endif\n\t.llseek\t\t= noop_llseek,\n};\n\n \n\n#ifdef CONFIG_LP_CONSOLE\n\n#define CONSOLE_LP 0\n\n \n#define CONSOLE_LP_STRICT 1\n\n \n\nstatic void lp_console_write(struct console *co, const char *s,\n\t\t\t     unsigned count)\n{\n\tstruct pardevice *dev = lp_table[CONSOLE_LP].dev;\n\tstruct parport *port = dev->port;\n\tssize_t written;\n\n\tif (parport_claim(dev))\n\t\t \n\t\treturn;\n\n\tparport_set_timeout(dev, 0);\n\n\t \n\tparport_negotiate(port, IEEE1284_MODE_COMPAT);\n\n\tdo {\n\t\t \n\t\tssize_t canwrite = count;\n\t\tchar *lf = memchr(s, '\\n', count);\n\t\tif (lf)\n\t\t\tcanwrite = lf - s;\n\n\t\tif (canwrite > 0) {\n\t\t\twritten = parport_write(port, s, canwrite);\n\n\t\t\tif (written <= 0)\n\t\t\t\tcontinue;\n\n\t\t\ts += written;\n\t\t\tcount -= written;\n\t\t\tcanwrite -= written;\n\t\t}\n\n\t\tif (lf && canwrite <= 0) {\n\t\t\tconst char *crlf = \"\\r\\n\";\n\t\t\tint i = 2;\n\n\t\t\t \n\t\t\ts++;\n\t\t\tcount--;\n\t\t\tdo {\n\t\t\t\twritten = parport_write(port, crlf, i);\n\t\t\t\tif (written > 0) {\n\t\t\t\t\ti -= written;\n\t\t\t\t\tcrlf += written;\n\t\t\t\t}\n\t\t\t} while (i > 0 && (CONSOLE_LP_STRICT || written > 0));\n\t\t}\n\t} while (count > 0 && (CONSOLE_LP_STRICT || written > 0));\n\n\tparport_release(dev);\n}\n\nstatic struct console lpcons = {\n\t.name\t\t= \"lp\",\n\t.write\t\t= lp_console_write,\n\t.flags\t\t= CON_PRINTBUFFER,\n};\n\n#endif  \n\n \n\nstatic int parport_nr[LP_NO] = { [0 ... LP_NO-1] = LP_PARPORT_UNSPEC };\nstatic char *parport[LP_NO];\nstatic bool reset;\n\nmodule_param_array(parport, charp, NULL, 0);\nmodule_param(reset, bool, 0);\n\n#ifndef MODULE\nstatic int __init lp_setup(char *str)\n{\n\tstatic int parport_ptr;\n\tint x;\n\n\tif (get_option(&str, &x)) {\n\t\tif (x == 0) {\n\t\t\t \n\t\t\tparport_nr[0] = LP_PARPORT_OFF;\n\t\t} else {\n\t\t\tprintk(KERN_WARNING \"warning: 'lp=0x%x' is deprecated, ignored\\n\", x);\n\t\t\treturn 0;\n\t\t}\n\t} else if (!strncmp(str, \"parport\", 7)) {\n\t\tint n = simple_strtoul(str+7, NULL, 10);\n\t\tif (parport_ptr < LP_NO)\n\t\t\tparport_nr[parport_ptr++] = n;\n\t\telse\n\t\t\tprintk(KERN_INFO \"lp: too many ports, %s ignored.\\n\",\n\t\t\t       str);\n\t} else if (!strcmp(str, \"auto\")) {\n\t\tparport_nr[0] = LP_PARPORT_AUTO;\n\t} else if (!strcmp(str, \"none\")) {\n\t\tif (parport_ptr < LP_NO)\n\t\t\tparport_nr[parport_ptr++] = LP_PARPORT_NONE;\n\t\telse\n\t\t\tprintk(KERN_INFO \"lp: too many ports, %s ignored.\\n\",\n\t\t\t       str);\n\t} else if (!strcmp(str, \"reset\")) {\n\t\treset = true;\n\t}\n\treturn 1;\n}\n#endif\n\nstatic int lp_register(int nr, struct parport *port)\n{\n\tstruct pardev_cb ppdev_cb;\n\n\tmemset(&ppdev_cb, 0, sizeof(ppdev_cb));\n\tppdev_cb.preempt = lp_preempt;\n\tppdev_cb.private = &lp_table[nr];\n\tlp_table[nr].dev = parport_register_dev_model(port, \"lp\",\n\t\t\t\t\t\t      &ppdev_cb, nr);\n\tif (lp_table[nr].dev == NULL)\n\t\treturn 1;\n\tlp_table[nr].flags |= LP_EXIST;\n\n\tif (reset)\n\t\tlp_reset(nr);\n\n\tdevice_create(&lp_class, port->dev, MKDEV(LP_MAJOR, nr), NULL,\n\t\t      \"lp%d\", nr);\n\n\tprintk(KERN_INFO \"lp%d: using %s (%s).\\n\", nr, port->name,\n\t       (port->irq == PARPORT_IRQ_NONE)?\"polling\":\"interrupt-driven\");\n\n#ifdef CONFIG_LP_CONSOLE\n\tif (!nr) {\n\t\tif (port->modes & PARPORT_MODE_SAFEININT) {\n\t\t\tregister_console(&lpcons);\n\t\t\tconsole_registered = port;\n\t\t\tprintk(KERN_INFO \"lp%d: console ready\\n\", CONSOLE_LP);\n\t\t} else\n\t\t\tprintk(KERN_ERR \"lp%d: cannot run console on %s\\n\",\n\t\t\t       CONSOLE_LP, port->name);\n\t}\n#endif\n\tport_num[nr] = port->number;\n\n\treturn 0;\n}\n\nstatic void lp_attach(struct parport *port)\n{\n\tunsigned int i;\n\n\tswitch (parport_nr[0]) {\n\tcase LP_PARPORT_UNSPEC:\n\tcase LP_PARPORT_AUTO:\n\t\tif (parport_nr[0] == LP_PARPORT_AUTO &&\n\t\t    port->probe_info[0].class != PARPORT_CLASS_PRINTER)\n\t\t\treturn;\n\t\tif (lp_count == LP_NO) {\n\t\t\tprintk(KERN_INFO \"lp: ignoring parallel port (max. %d)\\n\",LP_NO);\n\t\t\treturn;\n\t\t}\n\t\tfor (i = 0; i < LP_NO; i++)\n\t\t\tif (port_num[i] == -1)\n\t\t\t\tbreak;\n\n\t\tif (!lp_register(i, port))\n\t\t\tlp_count++;\n\t\tbreak;\n\n\tdefault:\n\t\tfor (i = 0; i < LP_NO; i++) {\n\t\t\tif (port->number == parport_nr[i]) {\n\t\t\t\tif (!lp_register(i, port))\n\t\t\t\t\tlp_count++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic void lp_detach(struct parport *port)\n{\n\tint n;\n\n\t \n#ifdef CONFIG_LP_CONSOLE\n\tif (console_registered == port) {\n\t\tunregister_console(&lpcons);\n\t\tconsole_registered = NULL;\n\t}\n#endif  \n\n\tfor (n = 0; n < LP_NO; n++) {\n\t\tif (port_num[n] == port->number) {\n\t\t\tport_num[n] = -1;\n\t\t\tlp_count--;\n\t\t\tdevice_destroy(&lp_class, MKDEV(LP_MAJOR, n));\n\t\t\tparport_unregister_device(lp_table[n].dev);\n\t\t}\n\t}\n}\n\nstatic struct parport_driver lp_driver = {\n\t.name = \"lp\",\n\t.match_port = lp_attach,\n\t.detach = lp_detach,\n\t.devmodel = true,\n};\n\nstatic int __init lp_init(void)\n{\n\tint i, err;\n\n\tif (parport_nr[0] == LP_PARPORT_OFF)\n\t\treturn 0;\n\n\tfor (i = 0; i < LP_NO; i++) {\n\t\tlp_table[i].dev = NULL;\n\t\tlp_table[i].flags = 0;\n\t\tlp_table[i].chars = LP_INIT_CHAR;\n\t\tlp_table[i].time = LP_INIT_TIME;\n\t\tlp_table[i].wait = LP_INIT_WAIT;\n\t\tlp_table[i].lp_buffer = NULL;\n#ifdef LP_STATS\n\t\tlp_table[i].lastcall = 0;\n\t\tlp_table[i].runchars = 0;\n\t\tmemset(&lp_table[i].stats, 0, sizeof(struct lp_stats));\n#endif\n\t\tlp_table[i].last_error = 0;\n\t\tinit_waitqueue_head(&lp_table[i].waitq);\n\t\tinit_waitqueue_head(&lp_table[i].dataq);\n\t\tmutex_init(&lp_table[i].port_mutex);\n\t\tlp_table[i].timeout = 10 * HZ;\n\t\tport_num[i] = -1;\n\t}\n\n\tif (register_chrdev(LP_MAJOR, \"lp\", &lp_fops)) {\n\t\tprintk(KERN_ERR \"lp: unable to get major %d\\n\", LP_MAJOR);\n\t\treturn -EIO;\n\t}\n\n\terr = class_register(&lp_class);\n\tif (err)\n\t\tgoto out_reg;\n\n\tif (parport_register_driver(&lp_driver)) {\n\t\tprintk(KERN_ERR \"lp: unable to register with parport\\n\");\n\t\terr = -EIO;\n\t\tgoto out_class;\n\t}\n\n\tif (!lp_count) {\n\t\tprintk(KERN_INFO \"lp: driver loaded but no devices found\\n\");\n#ifndef CONFIG_PARPORT_1284\n\t\tif (parport_nr[0] == LP_PARPORT_AUTO)\n\t\t\tprintk(KERN_INFO \"lp: (is IEEE 1284 support enabled?)\\n\");\n#endif\n\t}\n\n\treturn 0;\n\nout_class:\n\tclass_unregister(&lp_class);\nout_reg:\n\tunregister_chrdev(LP_MAJOR, \"lp\");\n\treturn err;\n}\n\nstatic int __init lp_init_module(void)\n{\n\tif (parport[0]) {\n\t\t \n\t\tif (!strncmp(parport[0], \"auto\", 4))\n\t\t\tparport_nr[0] = LP_PARPORT_AUTO;\n\t\telse {\n\t\t\tint n;\n\t\t\tfor (n = 0; n < LP_NO && parport[n]; n++) {\n\t\t\t\tif (!strncmp(parport[n], \"none\", 4))\n\t\t\t\t\tparport_nr[n] = LP_PARPORT_NONE;\n\t\t\t\telse {\n\t\t\t\t\tchar *ep;\n\t\t\t\t\tunsigned long r = simple_strtoul(parport[n], &ep, 0);\n\t\t\t\t\tif (ep != parport[n])\n\t\t\t\t\t\tparport_nr[n] = r;\n\t\t\t\t\telse {\n\t\t\t\t\t\tprintk(KERN_ERR \"lp: bad port specifier `%s'\\n\", parport[n]);\n\t\t\t\t\t\treturn -ENODEV;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn lp_init();\n}\n\nstatic void lp_cleanup_module(void)\n{\n\tparport_unregister_driver(&lp_driver);\n\n#ifdef CONFIG_LP_CONSOLE\n\tunregister_console(&lpcons);\n#endif\n\n\tunregister_chrdev(LP_MAJOR, \"lp\");\n\tclass_unregister(&lp_class);\n}\n\n__setup(\"lp=\", lp_setup);\nmodule_init(lp_init_module);\nmodule_exit(lp_cleanup_module);\n\nMODULE_ALIAS_CHARDEV_MAJOR(LP_MAJOR);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}