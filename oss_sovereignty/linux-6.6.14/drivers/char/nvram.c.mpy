{
  "module_name": "nvram.c",
  "hash_id": "bb060cdd90730a1a0c3f9310e0548b43232b58e7c87fec9de83d0ff888969652",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/nvram.c",
  "human_readable_source": "\n \n\n#define NVRAM_VERSION\t\"1.3\"\n\n#include <linux/module.h>\n#include <linux/nvram.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/miscdevice.h>\n#include <linux/ioport.h>\n#include <linux/fcntl.h>\n#include <linux/mc146818rtc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/pagemap.h>\n\n#ifdef CONFIG_PPC\n#include <asm/nvram.h>\n#endif\n\nstatic DEFINE_MUTEX(nvram_mutex);\nstatic DEFINE_SPINLOCK(nvram_state_lock);\nstatic int nvram_open_cnt;\t \nstatic int nvram_open_mode;\t \nstatic ssize_t nvram_size;\n#define NVRAM_WRITE\t\t1  \n#define NVRAM_EXCL\t\t2  \n\n#ifdef CONFIG_X86\n \n\n#define NVRAM_BYTES\t\t(128 - NVRAM_FIRST_BYTE)\n\n \n\nstatic unsigned char __nvram_read_byte(int i)\n{\n\treturn CMOS_READ(NVRAM_FIRST_BYTE + i);\n}\n\nstatic unsigned char pc_nvram_read_byte(int i)\n{\n\tunsigned long flags;\n\tunsigned char c;\n\n\tspin_lock_irqsave(&rtc_lock, flags);\n\tc = __nvram_read_byte(i);\n\tspin_unlock_irqrestore(&rtc_lock, flags);\n\treturn c;\n}\n\n \nstatic void __nvram_write_byte(unsigned char c, int i)\n{\n\tCMOS_WRITE(c, NVRAM_FIRST_BYTE + i);\n}\n\nstatic void pc_nvram_write_byte(unsigned char c, int i)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rtc_lock, flags);\n\t__nvram_write_byte(c, i);\n\tspin_unlock_irqrestore(&rtc_lock, flags);\n}\n\n \n#define PC_CKS_RANGE_START\t2\n#define PC_CKS_RANGE_END\t31\n#define PC_CKS_LOC\t\t32\n\nstatic int __nvram_check_checksum(void)\n{\n\tint i;\n\tunsigned short sum = 0;\n\tunsigned short expect;\n\n\tfor (i = PC_CKS_RANGE_START; i <= PC_CKS_RANGE_END; ++i)\n\t\tsum += __nvram_read_byte(i);\n\texpect = __nvram_read_byte(PC_CKS_LOC)<<8 |\n\t    __nvram_read_byte(PC_CKS_LOC+1);\n\treturn (sum & 0xffff) == expect;\n}\n\nstatic void __nvram_set_checksum(void)\n{\n\tint i;\n\tunsigned short sum = 0;\n\n\tfor (i = PC_CKS_RANGE_START; i <= PC_CKS_RANGE_END; ++i)\n\t\tsum += __nvram_read_byte(i);\n\t__nvram_write_byte(sum >> 8, PC_CKS_LOC);\n\t__nvram_write_byte(sum & 0xff, PC_CKS_LOC + 1);\n}\n\nstatic long pc_nvram_set_checksum(void)\n{\n\tspin_lock_irq(&rtc_lock);\n\t__nvram_set_checksum();\n\tspin_unlock_irq(&rtc_lock);\n\treturn 0;\n}\n\nstatic long pc_nvram_initialize(void)\n{\n\tssize_t i;\n\n\tspin_lock_irq(&rtc_lock);\n\tfor (i = 0; i < NVRAM_BYTES; ++i)\n\t\t__nvram_write_byte(0, i);\n\t__nvram_set_checksum();\n\tspin_unlock_irq(&rtc_lock);\n\treturn 0;\n}\n\nstatic ssize_t pc_nvram_get_size(void)\n{\n\treturn NVRAM_BYTES;\n}\n\nstatic ssize_t pc_nvram_read(char *buf, size_t count, loff_t *ppos)\n{\n\tchar *p = buf;\n\tloff_t i;\n\n\tspin_lock_irq(&rtc_lock);\n\tif (!__nvram_check_checksum()) {\n\t\tspin_unlock_irq(&rtc_lock);\n\t\treturn -EIO;\n\t}\n\tfor (i = *ppos; count > 0 && i < NVRAM_BYTES; --count, ++i, ++p)\n\t\t*p = __nvram_read_byte(i);\n\tspin_unlock_irq(&rtc_lock);\n\n\t*ppos = i;\n\treturn p - buf;\n}\n\nstatic ssize_t pc_nvram_write(char *buf, size_t count, loff_t *ppos)\n{\n\tchar *p = buf;\n\tloff_t i;\n\n\tspin_lock_irq(&rtc_lock);\n\tif (!__nvram_check_checksum()) {\n\t\tspin_unlock_irq(&rtc_lock);\n\t\treturn -EIO;\n\t}\n\tfor (i = *ppos; count > 0 && i < NVRAM_BYTES; --count, ++i, ++p)\n\t\t__nvram_write_byte(*p, i);\n\t__nvram_set_checksum();\n\tspin_unlock_irq(&rtc_lock);\n\n\t*ppos = i;\n\treturn p - buf;\n}\n\nconst struct nvram_ops arch_nvram_ops = {\n\t.read           = pc_nvram_read,\n\t.write          = pc_nvram_write,\n\t.read_byte      = pc_nvram_read_byte,\n\t.write_byte     = pc_nvram_write_byte,\n\t.get_size       = pc_nvram_get_size,\n\t.set_checksum   = pc_nvram_set_checksum,\n\t.initialize     = pc_nvram_initialize,\n};\nEXPORT_SYMBOL(arch_nvram_ops);\n#endif  \n\n \n\nstatic loff_t nvram_misc_llseek(struct file *file, loff_t offset, int origin)\n{\n\treturn generic_file_llseek_size(file, offset, origin, MAX_LFS_FILESIZE,\n\t\t\t\t\tnvram_size);\n}\n\nstatic ssize_t nvram_misc_read(struct file *file, char __user *buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tchar *tmp;\n\tssize_t ret;\n\n\n\tif (*ppos >= nvram_size)\n\t\treturn 0;\n\n\tcount = min_t(size_t, count, nvram_size - *ppos);\n\tcount = min_t(size_t, count, PAGE_SIZE);\n\n\ttmp = kmalloc(count, GFP_KERNEL);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\tret = nvram_read(tmp, count, ppos);\n\tif (ret <= 0)\n\t\tgoto out;\n\n\tif (copy_to_user(buf, tmp, ret)) {\n\t\t*ppos -= ret;\n\t\tret = -EFAULT;\n\t}\n\nout:\n\tkfree(tmp);\n\treturn ret;\n}\n\nstatic ssize_t nvram_misc_write(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tchar *tmp;\n\tssize_t ret;\n\n\tif (*ppos >= nvram_size)\n\t\treturn 0;\n\n\tcount = min_t(size_t, count, nvram_size - *ppos);\n\tcount = min_t(size_t, count, PAGE_SIZE);\n\n\ttmp = memdup_user(buf, count);\n\tif (IS_ERR(tmp))\n\t\treturn PTR_ERR(tmp);\n\n\tret = nvram_write(tmp, count, ppos);\n\tkfree(tmp);\n\treturn ret;\n}\n\nstatic long nvram_misc_ioctl(struct file *file, unsigned int cmd,\n\t\t\t     unsigned long arg)\n{\n\tlong ret = -ENOTTY;\n\n\tswitch (cmd) {\n#ifdef CONFIG_PPC\n\tcase OBSOLETE_PMAC_NVRAM_GET_OFFSET:\n\t\tpr_warn(\"nvram: Using obsolete PMAC_NVRAM_GET_OFFSET ioctl\\n\");\n\t\tfallthrough;\n\tcase IOC_NVRAM_GET_OFFSET:\n\t\tret = -EINVAL;\n#ifdef CONFIG_PPC_PMAC\n\t\tif (machine_is(powermac)) {\n\t\t\tint part, offset;\n\n\t\t\tif (copy_from_user(&part, (void __user *)arg,\n\t\t\t\t\t   sizeof(part)) != 0)\n\t\t\t\treturn -EFAULT;\n\t\t\tif (part < pmac_nvram_OF || part > pmac_nvram_NR)\n\t\t\t\treturn -EINVAL;\n\t\t\toffset = pmac_get_partition(part);\n\t\t\tif (offset < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (copy_to_user((void __user *)arg,\n\t\t\t\t\t &offset, sizeof(offset)) != 0)\n\t\t\t\treturn -EFAULT;\n\t\t\tret = 0;\n\t\t}\n#endif\n\t\tbreak;\n#ifdef CONFIG_PPC32\n\tcase IOC_NVRAM_SYNC:\n\t\tif (ppc_md.nvram_sync != NULL) {\n\t\t\tmutex_lock(&nvram_mutex);\n\t\t\tppc_md.nvram_sync();\n\t\t\tmutex_unlock(&nvram_mutex);\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n#endif\n#elif defined(CONFIG_X86) || defined(CONFIG_M68K)\n\tcase NVRAM_INIT:\n\t\t \n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EACCES;\n\n\t\tif (arch_nvram_ops.initialize != NULL) {\n\t\t\tmutex_lock(&nvram_mutex);\n\t\t\tret = arch_nvram_ops.initialize();\n\t\t\tmutex_unlock(&nvram_mutex);\n\t\t}\n\t\tbreak;\n\tcase NVRAM_SETCKS:\n\t\t \n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EACCES;\n\n\t\tif (arch_nvram_ops.set_checksum != NULL) {\n\t\t\tmutex_lock(&nvram_mutex);\n\t\t\tret = arch_nvram_ops.set_checksum();\n\t\t\tmutex_unlock(&nvram_mutex);\n\t\t}\n\t\tbreak;\n#endif  \n\t}\n\treturn ret;\n}\n\nstatic int nvram_misc_open(struct inode *inode, struct file *file)\n{\n\tspin_lock(&nvram_state_lock);\n\n\t \n\tif ((nvram_open_cnt && (file->f_flags & O_EXCL)) ||\n\t    (nvram_open_mode & NVRAM_EXCL)) {\n\t\tspin_unlock(&nvram_state_lock);\n\t\treturn -EBUSY;\n\t}\n\n#if defined(CONFIG_X86) || defined(CONFIG_M68K)\n\t \n\tif ((arch_nvram_ops.set_checksum != NULL) &&\n\t    (file->f_mode & FMODE_WRITE) && (nvram_open_mode & NVRAM_WRITE)) {\n\t\tspin_unlock(&nvram_state_lock);\n\t\treturn -EBUSY;\n\t}\n#endif\n\n\tif (file->f_flags & O_EXCL)\n\t\tnvram_open_mode |= NVRAM_EXCL;\n\tif (file->f_mode & FMODE_WRITE)\n\t\tnvram_open_mode |= NVRAM_WRITE;\n\tnvram_open_cnt++;\n\n\tspin_unlock(&nvram_state_lock);\n\n\treturn 0;\n}\n\nstatic int nvram_misc_release(struct inode *inode, struct file *file)\n{\n\tspin_lock(&nvram_state_lock);\n\n\tnvram_open_cnt--;\n\n\t \n\tif (nvram_open_mode & NVRAM_EXCL)\n\t\tnvram_open_mode &= ~NVRAM_EXCL;\n\tif (file->f_mode & FMODE_WRITE)\n\t\tnvram_open_mode &= ~NVRAM_WRITE;\n\n\tspin_unlock(&nvram_state_lock);\n\n\treturn 0;\n}\n\n#if defined(CONFIG_X86) && defined(CONFIG_PROC_FS)\nstatic const char * const floppy_types[] = {\n\t\"none\", \"5.25'' 360k\", \"5.25'' 1.2M\", \"3.5'' 720k\", \"3.5'' 1.44M\",\n\t\"3.5'' 2.88M\", \"3.5'' 2.88M\"\n};\n\nstatic const char * const gfx_types[] = {\n\t\"EGA, VGA, ... (with BIOS)\",\n\t\"CGA (40 cols)\",\n\t\"CGA (80 cols)\",\n\t\"monochrome\",\n};\n\nstatic void pc_nvram_proc_read(unsigned char *nvram, struct seq_file *seq,\n\t\t\t       void *offset)\n{\n\tint checksum;\n\tint type;\n\n\tspin_lock_irq(&rtc_lock);\n\tchecksum = __nvram_check_checksum();\n\tspin_unlock_irq(&rtc_lock);\n\n\tseq_printf(seq, \"Checksum status: %svalid\\n\", checksum ? \"\" : \"not \");\n\n\tseq_printf(seq, \"# floppies     : %d\\n\",\n\t    (nvram[6] & 1) ? (nvram[6] >> 6) + 1 : 0);\n\tseq_printf(seq, \"Floppy 0 type  : \");\n\ttype = nvram[2] >> 4;\n\tif (type < ARRAY_SIZE(floppy_types))\n\t\tseq_printf(seq, \"%s\\n\", floppy_types[type]);\n\telse\n\t\tseq_printf(seq, \"%d (unknown)\\n\", type);\n\tseq_printf(seq, \"Floppy 1 type  : \");\n\ttype = nvram[2] & 0x0f;\n\tif (type < ARRAY_SIZE(floppy_types))\n\t\tseq_printf(seq, \"%s\\n\", floppy_types[type]);\n\telse\n\t\tseq_printf(seq, \"%d (unknown)\\n\", type);\n\n\tseq_printf(seq, \"HD 0 type      : \");\n\ttype = nvram[4] >> 4;\n\tif (type)\n\t\tseq_printf(seq, \"%02x\\n\", type == 0x0f ? nvram[11] : type);\n\telse\n\t\tseq_printf(seq, \"none\\n\");\n\n\tseq_printf(seq, \"HD 1 type      : \");\n\ttype = nvram[4] & 0x0f;\n\tif (type)\n\t\tseq_printf(seq, \"%02x\\n\", type == 0x0f ? nvram[12] : type);\n\telse\n\t\tseq_printf(seq, \"none\\n\");\n\n\tseq_printf(seq, \"HD type 48 data: %d/%d/%d C/H/S, precomp %d, lz %d\\n\",\n\t    nvram[18] | (nvram[19] << 8),\n\t    nvram[20], nvram[25],\n\t    nvram[21] | (nvram[22] << 8), nvram[23] | (nvram[24] << 8));\n\tseq_printf(seq, \"HD type 49 data: %d/%d/%d C/H/S, precomp %d, lz %d\\n\",\n\t    nvram[39] | (nvram[40] << 8),\n\t    nvram[41], nvram[46],\n\t    nvram[42] | (nvram[43] << 8), nvram[44] | (nvram[45] << 8));\n\n\tseq_printf(seq, \"DOS base memory: %d kB\\n\", nvram[7] | (nvram[8] << 8));\n\tseq_printf(seq, \"Extended memory: %d kB (configured), %d kB (tested)\\n\",\n\t    nvram[9] | (nvram[10] << 8), nvram[34] | (nvram[35] << 8));\n\n\tseq_printf(seq, \"Gfx adapter    : %s\\n\",\n\t    gfx_types[(nvram[6] >> 4) & 3]);\n\n\tseq_printf(seq, \"FPU            : %sinstalled\\n\",\n\t    (nvram[6] & 2) ? \"\" : \"not \");\n\n\treturn;\n}\n\nstatic int nvram_proc_read(struct seq_file *seq, void *offset)\n{\n\tunsigned char contents[NVRAM_BYTES];\n\tint i = 0;\n\n\tspin_lock_irq(&rtc_lock);\n\tfor (i = 0; i < NVRAM_BYTES; ++i)\n\t\tcontents[i] = __nvram_read_byte(i);\n\tspin_unlock_irq(&rtc_lock);\n\n\tpc_nvram_proc_read(contents, seq, offset);\n\n\treturn 0;\n}\n#endif  \n\nstatic const struct file_operations nvram_misc_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.llseek\t\t= nvram_misc_llseek,\n\t.read\t\t= nvram_misc_read,\n\t.write\t\t= nvram_misc_write,\n\t.unlocked_ioctl\t= nvram_misc_ioctl,\n\t.open\t\t= nvram_misc_open,\n\t.release\t= nvram_misc_release,\n};\n\nstatic struct miscdevice nvram_misc = {\n\tNVRAM_MINOR,\n\t\"nvram\",\n\t&nvram_misc_fops,\n};\n\nstatic int __init nvram_module_init(void)\n{\n\tint ret;\n\n\tnvram_size = nvram_get_size();\n\tif (nvram_size < 0)\n\t\treturn nvram_size;\n\n\tret = misc_register(&nvram_misc);\n\tif (ret) {\n\t\tpr_err(\"nvram: can't misc_register on minor=%d\\n\", NVRAM_MINOR);\n\t\treturn ret;\n\t}\n\n#if defined(CONFIG_X86) && defined(CONFIG_PROC_FS)\n\tif (!proc_create_single(\"driver/nvram\", 0, NULL, nvram_proc_read)) {\n\t\tpr_err(\"nvram: can't create /proc/driver/nvram\\n\");\n\t\tmisc_deregister(&nvram_misc);\n\t\treturn -ENOMEM;\n\t}\n#endif\n\n\tpr_info(\"Non-volatile memory driver v\" NVRAM_VERSION \"\\n\");\n\treturn 0;\n}\n\nstatic void __exit nvram_module_exit(void)\n{\n#if defined(CONFIG_X86) && defined(CONFIG_PROC_FS)\n\tremove_proc_entry(\"driver/nvram\", NULL);\n#endif\n\tmisc_deregister(&nvram_misc);\n}\n\nmodule_init(nvram_module_init);\nmodule_exit(nvram_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_MISCDEV(NVRAM_MINOR);\nMODULE_ALIAS(\"devname:nvram\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}