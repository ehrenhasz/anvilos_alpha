{
  "module_name": "powernv-op-panel.c",
  "hash_id": "e7b9c9c90383ac6067a2e9c780a958cd8e359a7631b6ef273af8de30959e7563",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/powernv-op-panel.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/miscdevice.h>\n\n#include <asm/opal.h>\n\n \n\nstatic DEFINE_MUTEX(oppanel_mutex);\n\nstatic u32\t\tnum_lines, oppanel_size;\nstatic oppanel_line_t\t*oppanel_lines;\nstatic char\t\t*oppanel_data;\n\nstatic loff_t oppanel_llseek(struct file *filp, loff_t offset, int whence)\n{\n\treturn fixed_size_llseek(filp, offset, whence, oppanel_size);\n}\n\nstatic ssize_t oppanel_read(struct file *filp, char __user *userbuf, size_t len,\n\t\t\t    loff_t *f_pos)\n{\n\treturn simple_read_from_buffer(userbuf, len, f_pos, oppanel_data,\n\t\t\toppanel_size);\n}\n\nstatic int __op_panel_update_display(void)\n{\n\tstruct opal_msg msg;\n\tint rc, token;\n\n\ttoken = opal_async_get_token_interruptible();\n\tif (token < 0) {\n\t\tif (token != -ERESTARTSYS)\n\t\t\tpr_debug(\"Couldn't get OPAL async token [token=%d]\\n\",\n\t\t\t\ttoken);\n\t\treturn token;\n\t}\n\n\trc = opal_write_oppanel_async(token, oppanel_lines, num_lines);\n\tswitch (rc) {\n\tcase OPAL_ASYNC_COMPLETION:\n\t\trc = opal_async_wait_response(token, &msg);\n\t\tif (rc) {\n\t\t\tpr_debug(\"Failed to wait for async response [rc=%d]\\n\",\n\t\t\t\trc);\n\t\t\tbreak;\n\t\t}\n\t\trc = opal_get_async_rc(msg);\n\t\tif (rc != OPAL_SUCCESS) {\n\t\t\tpr_debug(\"OPAL async call returned failed [rc=%d]\\n\",\n\t\t\t\trc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase OPAL_SUCCESS:\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"OPAL write op-panel call failed [rc=%d]\\n\", rc);\n\t}\n\n\topal_async_release_token(token);\n\treturn rc;\n}\n\nstatic ssize_t oppanel_write(struct file *filp, const char __user *userbuf,\n\t\t\t     size_t len, loff_t *f_pos)\n{\n\tloff_t f_pos_prev = *f_pos;\n\tssize_t ret;\n\tint rc;\n\n\tif (!*f_pos)\n\t\tmemset(oppanel_data, ' ', oppanel_size);\n\telse if (*f_pos >= oppanel_size)\n\t\treturn -EFBIG;\n\n\tret = simple_write_to_buffer(oppanel_data, oppanel_size, f_pos, userbuf,\n\t\t\tlen);\n\tif (ret > 0) {\n\t\trc = __op_panel_update_display();\n\t\tif (rc != OPAL_SUCCESS) {\n\t\t\tpr_err_ratelimited(\"OPAL call failed to write to op panel display [rc=%d]\\n\",\n\t\t\t\trc);\n\t\t\t*f_pos = f_pos_prev;\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int oppanel_open(struct inode *inode, struct file *filp)\n{\n\tif (!mutex_trylock(&oppanel_mutex)) {\n\t\tpr_debug(\"Device Busy\\n\");\n\t\treturn -EBUSY;\n\t}\n\treturn 0;\n}\n\nstatic int oppanel_release(struct inode *inode, struct file *filp)\n{\n\tmutex_unlock(&oppanel_mutex);\n\treturn 0;\n}\n\nstatic const struct file_operations oppanel_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.llseek\t\t= oppanel_llseek,\n\t.read\t\t= oppanel_read,\n\t.write\t\t= oppanel_write,\n\t.open\t\t= oppanel_open,\n\t.release\t= oppanel_release\n};\n\nstatic struct miscdevice oppanel_dev = {\n\t.minor\t\t= MISC_DYNAMIC_MINOR,\n\t.name\t\t= \"op_panel\",\n\t.fops\t\t= &oppanel_fops\n};\n\nstatic int oppanel_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tu32 line_len;\n\tint rc, i;\n\n\trc = of_property_read_u32(np, \"#length\", &line_len);\n\tif (rc) {\n\t\tpr_err_ratelimited(\"Operator panel length property not found\\n\");\n\t\treturn rc;\n\t}\n\trc = of_property_read_u32(np, \"#lines\", &num_lines);\n\tif (rc) {\n\t\tpr_err_ratelimited(\"Operator panel lines property not found\\n\");\n\t\treturn rc;\n\t}\n\toppanel_size = line_len * num_lines;\n\n\tpr_devel(\"Operator panel of size %u found with %u lines of length %u\\n\",\n\t\t\toppanel_size, num_lines, line_len);\n\n\toppanel_data = kcalloc(oppanel_size, sizeof(*oppanel_data), GFP_KERNEL);\n\tif (!oppanel_data)\n\t\treturn -ENOMEM;\n\n\toppanel_lines = kcalloc(num_lines, sizeof(oppanel_line_t), GFP_KERNEL);\n\tif (!oppanel_lines) {\n\t\trc = -ENOMEM;\n\t\tgoto free_oppanel_data;\n\t}\n\n\tmemset(oppanel_data, ' ', oppanel_size);\n\tfor (i = 0; i < num_lines; i++) {\n\t\toppanel_lines[i].line_len = cpu_to_be64(line_len);\n\t\toppanel_lines[i].line = cpu_to_be64(__pa(&oppanel_data[i *\n\t\t\t\t\t\tline_len]));\n\t}\n\n\trc = misc_register(&oppanel_dev);\n\tif (rc) {\n\t\tpr_err_ratelimited(\"Failed to register as misc device\\n\");\n\t\tgoto free_oppanel;\n\t}\n\n\treturn 0;\n\nfree_oppanel:\n\tkfree(oppanel_lines);\nfree_oppanel_data:\n\tkfree(oppanel_data);\n\treturn rc;\n}\n\nstatic int oppanel_remove(struct platform_device *pdev)\n{\n\tmisc_deregister(&oppanel_dev);\n\tkfree(oppanel_lines);\n\tkfree(oppanel_data);\n\treturn 0;\n}\n\nstatic const struct of_device_id oppanel_match[] = {\n\t{ .compatible = \"ibm,opal-oppanel\" },\n\t{ },\n};\n\nstatic struct platform_driver oppanel_driver = {\n\t.driver\t= {\n\t\t.name\t\t= \"powernv-op-panel\",\n\t\t.of_match_table\t= oppanel_match,\n\t},\n\t.probe\t= oppanel_probe,\n\t.remove\t= oppanel_remove,\n};\n\nmodule_platform_driver(oppanel_driver);\n\nMODULE_DEVICE_TABLE(of, oppanel_match);\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"PowerNV Operator Panel LCD Display Driver\");\nMODULE_AUTHOR(\"Suraj Jitindar Singh <sjitindarsingh@gmail.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}