{
  "module_name": "mspec.c",
  "hash_id": "8a78421ae404e69239f7d87082d0858317e203f29de7bc2fd43988c4a029cc16",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/mspec.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/miscdevice.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/numa.h>\n#include <linux/refcount.h>\n#include <asm/page.h>\n#include <linux/atomic.h>\n#include <asm/tlbflush.h>\n#include <asm/uncached.h>\n\n\n#define CACHED_ID\t\"Cached,\"\n#define UNCACHED_ID\t\"Uncached\"\n#define REVISION\t\"4.0\"\n#define MSPEC_BASENAME\t\"mspec\"\n\n \nenum mspec_page_type {\n\tMSPEC_CACHED = 2,\n\tMSPEC_UNCACHED\n};\n\n \nstruct vma_data {\n\trefcount_t refcnt;\t \n\tspinlock_t lock;\t \n\tint count;\t\t \n\tenum mspec_page_type type;  \n\tunsigned long vm_start;\t \n\tunsigned long vm_end;\t \n\tunsigned long maddr[];\t \n};\n\n \nstatic void\nmspec_open(struct vm_area_struct *vma)\n{\n\tstruct vma_data *vdata;\n\n\tvdata = vma->vm_private_data;\n\trefcount_inc(&vdata->refcnt);\n}\n\n \nstatic void\nmspec_close(struct vm_area_struct *vma)\n{\n\tstruct vma_data *vdata;\n\tint index, last_index;\n\tunsigned long my_page;\n\n\tvdata = vma->vm_private_data;\n\n\tif (!refcount_dec_and_test(&vdata->refcnt))\n\t\treturn;\n\n\tlast_index = (vdata->vm_end - vdata->vm_start) >> PAGE_SHIFT;\n\tfor (index = 0; index < last_index; index++) {\n\t\tif (vdata->maddr[index] == 0)\n\t\t\tcontinue;\n\t\t \n\t\tmy_page = vdata->maddr[index];\n\t\tvdata->maddr[index] = 0;\n\t\tmemset((char *)my_page, 0, PAGE_SIZE);\n\t\tuncached_free_page(my_page, 1);\n\t}\n\n\tkvfree(vdata);\n}\n\n \nstatic vm_fault_t\nmspec_fault(struct vm_fault *vmf)\n{\n\tunsigned long paddr, maddr;\n\tunsigned long pfn;\n\tpgoff_t index = vmf->pgoff;\n\tstruct vma_data *vdata = vmf->vma->vm_private_data;\n\n\tmaddr = (volatile unsigned long) vdata->maddr[index];\n\tif (maddr == 0) {\n\t\tmaddr = uncached_alloc_page(numa_node_id(), 1);\n\t\tif (maddr == 0)\n\t\t\treturn VM_FAULT_OOM;\n\n\t\tspin_lock(&vdata->lock);\n\t\tif (vdata->maddr[index] == 0) {\n\t\t\tvdata->count++;\n\t\t\tvdata->maddr[index] = maddr;\n\t\t} else {\n\t\t\tuncached_free_page(maddr, 1);\n\t\t\tmaddr = vdata->maddr[index];\n\t\t}\n\t\tspin_unlock(&vdata->lock);\n\t}\n\n\tpaddr = maddr & ~__IA64_UNCACHED_OFFSET;\n\tpfn = paddr >> PAGE_SHIFT;\n\n\treturn vmf_insert_pfn(vmf->vma, vmf->address, pfn);\n}\n\nstatic const struct vm_operations_struct mspec_vm_ops = {\n\t.open = mspec_open,\n\t.close = mspec_close,\n\t.fault = mspec_fault,\n};\n\n \nstatic int\nmspec_mmap(struct file *file, struct vm_area_struct *vma,\n\t\t\t\t\tenum mspec_page_type type)\n{\n\tstruct vma_data *vdata;\n\tint pages, vdata_size;\n\n\tif (vma->vm_pgoff != 0)\n\t\treturn -EINVAL;\n\n\tif ((vma->vm_flags & VM_SHARED) == 0)\n\t\treturn -EINVAL;\n\n\tif ((vma->vm_flags & VM_WRITE) == 0)\n\t\treturn -EPERM;\n\n\tpages = vma_pages(vma);\n\tvdata_size = sizeof(struct vma_data) + pages * sizeof(long);\n\tvdata = kvzalloc(vdata_size, GFP_KERNEL);\n\tif (!vdata)\n\t\treturn -ENOMEM;\n\n\tvdata->vm_start = vma->vm_start;\n\tvdata->vm_end = vma->vm_end;\n\tvdata->type = type;\n\tspin_lock_init(&vdata->lock);\n\trefcount_set(&vdata->refcnt, 1);\n\tvma->vm_private_data = vdata;\n\n\tvm_flags_set(vma, VM_IO | VM_PFNMAP | VM_DONTEXPAND | VM_DONTDUMP);\n\tif (vdata->type == MSPEC_UNCACHED)\n\t\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\tvma->vm_ops = &mspec_vm_ops;\n\n\treturn 0;\n}\n\nstatic int\ncached_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\treturn mspec_mmap(file, vma, MSPEC_CACHED);\n}\n\nstatic int\nuncached_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\treturn mspec_mmap(file, vma, MSPEC_UNCACHED);\n}\n\nstatic const struct file_operations cached_fops = {\n\t.owner = THIS_MODULE,\n\t.mmap = cached_mmap,\n\t.llseek = noop_llseek,\n};\n\nstatic struct miscdevice cached_miscdev = {\n\t.minor = MISC_DYNAMIC_MINOR,\n\t.name = \"mspec_cached\",\n\t.fops = &cached_fops\n};\n\nstatic const struct file_operations uncached_fops = {\n\t.owner = THIS_MODULE,\n\t.mmap = uncached_mmap,\n\t.llseek = noop_llseek,\n};\n\nstatic struct miscdevice uncached_miscdev = {\n\t.minor = MISC_DYNAMIC_MINOR,\n\t.name = \"mspec_uncached\",\n\t.fops = &uncached_fops\n};\n\n \nstatic int __init\nmspec_init(void)\n{\n\tint ret;\n\n\tret = misc_register(&cached_miscdev);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"%s: failed to register device %i\\n\",\n\t\t       CACHED_ID, ret);\n\t\treturn ret;\n\t}\n\tret = misc_register(&uncached_miscdev);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"%s: failed to register device %i\\n\",\n\t\t       UNCACHED_ID, ret);\n\t\tmisc_deregister(&cached_miscdev);\n\t\treturn ret;\n\t}\n\n\tprintk(KERN_INFO \"%s %s initialized devices: %s %s\\n\",\n\t       MSPEC_BASENAME, REVISION, CACHED_ID, UNCACHED_ID);\n\n\treturn 0;\n}\n\nstatic void __exit\nmspec_exit(void)\n{\n\tmisc_deregister(&uncached_miscdev);\n\tmisc_deregister(&cached_miscdev);\n}\n\nmodule_init(mspec_init);\nmodule_exit(mspec_exit);\n\nMODULE_AUTHOR(\"Silicon Graphics, Inc. <linux-altix@sgi.com>\");\nMODULE_DESCRIPTION(\"Driver for SGI SN special memory operations\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}