{
  "module_name": "dtlk.c",
  "hash_id": "7626b052d10c2cccbfc2253accce0b03059ff7fdc3c94fe0ce196a46729daa59",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/dtlk.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n\n#define KERNEL\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\t \n#include <linux/ioport.h>\t \n#include <linux/delay.h>\t \n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <asm/io.h>\t\t \n#include <linux/uaccess.h>\t \n#include <linux/wait.h>\t\t \n#include <linux/init.h>\t\t \n#include <linux/poll.h>\t\t \n#include <linux/dtlk.h>\t\t \n\n#ifdef TRACING\n#define TRACE_TEXT(str) printk(str);\n#define TRACE_RET printk(\")\")\n#else\t\t\t\t \n#define TRACE_TEXT(str) ((void) 0)\n#define TRACE_RET ((void) 0)\n#endif\t\t\t\t \n\nstatic DEFINE_MUTEX(dtlk_mutex);\nstatic void dtlk_timer_tick(struct timer_list *unused);\n\nstatic int dtlk_major;\nstatic int dtlk_port_lpc;\nstatic int dtlk_port_tts;\nstatic int dtlk_busy;\nstatic int dtlk_has_indexing;\nstatic unsigned int dtlk_portlist[] =\n{0x25e, 0x29e, 0x2de, 0x31e, 0x35e, 0x39e, 0};\nstatic wait_queue_head_t dtlk_process_list;\nstatic DEFINE_TIMER(dtlk_timer, dtlk_timer_tick);\n\n \nstatic ssize_t dtlk_read(struct file *, char __user *,\n\t\t\t size_t nbytes, loff_t * ppos);\nstatic ssize_t dtlk_write(struct file *, const char __user *,\n\t\t\t  size_t nbytes, loff_t * ppos);\nstatic __poll_t dtlk_poll(struct file *, poll_table *);\nstatic int dtlk_open(struct inode *, struct file *);\nstatic int dtlk_release(struct inode *, struct file *);\nstatic long dtlk_ioctl(struct file *file,\n\t\t       unsigned int cmd, unsigned long arg);\n\nstatic const struct file_operations dtlk_fops =\n{\n\t.owner\t\t= THIS_MODULE,\n\t.read\t\t= dtlk_read,\n\t.write\t\t= dtlk_write,\n\t.poll\t\t= dtlk_poll,\n\t.unlocked_ioctl\t= dtlk_ioctl,\n\t.open\t\t= dtlk_open,\n\t.release\t= dtlk_release,\n\t.llseek\t\t= no_llseek,\n};\n\n \nstatic int dtlk_dev_probe(void);\nstatic struct dtlk_settings *dtlk_interrogate(void);\nstatic int dtlk_readable(void);\nstatic char dtlk_read_lpc(void);\nstatic char dtlk_read_tts(void);\nstatic int dtlk_writeable(void);\nstatic char dtlk_write_bytes(const char *buf, int n);\nstatic char dtlk_write_tts(char);\n \n\nstatic ssize_t dtlk_read(struct file *file, char __user *buf,\n\t\t\t size_t count, loff_t * ppos)\n{\n\tunsigned int minor = iminor(file_inode(file));\n\tchar ch;\n\tint i = 0, retries;\n\n\tTRACE_TEXT(\"(dtlk_read\");\n\t \n\n\tif (minor != DTLK_MINOR || !dtlk_has_indexing)\n\t\treturn -EINVAL;\n\n\tfor (retries = 0; retries < loops_per_jiffy; retries++) {\n\t\twhile (i < count && dtlk_readable()) {\n\t\t\tch = dtlk_read_lpc();\n\t\t\t \n\t\t\tif (put_user(ch, buf++))\n\t\t\t\treturn -EFAULT;\n\t\t\ti++;\n\t\t}\n\t\tif (i)\n\t\t\treturn i;\n\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\tbreak;\n\t\tmsleep_interruptible(100);\n\t}\n\tif (retries == loops_per_jiffy)\n\t\tprintk(KERN_ERR \"dtlk_read times out\\n\");\n\tTRACE_RET;\n\treturn -EAGAIN;\n}\n\nstatic ssize_t dtlk_write(struct file *file, const char __user *buf,\n\t\t\t  size_t count, loff_t * ppos)\n{\n\tint i = 0, retries = 0, ch;\n\n\tTRACE_TEXT(\"(dtlk_write\");\n#ifdef TRACING\n\tprintk(\" \\\"\");\n\t{\n\t\tint i, ch;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tif (get_user(ch, buf + i))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (' ' <= ch && ch <= '~')\n\t\t\t\tprintk(\"%c\", ch);\n\t\t\telse\n\t\t\t\tprintk(\"\\\\%03o\", ch);\n\t\t}\n\t\tprintk(\"\\\"\");\n\t}\n#endif\n\n\tif (iminor(file_inode(file)) != DTLK_MINOR)\n\t\treturn -EINVAL;\n\n\twhile (1) {\n\t\twhile (i < count && !get_user(ch, buf) &&\n\t\t       (ch == DTLK_CLEAR || dtlk_writeable())) {\n\t\t\tdtlk_write_tts(ch);\n\t\t\tbuf++;\n\t\t\ti++;\n\t\t\tif (i % 5 == 0)\n\t\t\t\t \n\t\t\t\tmsleep_interruptible(1);\n\t\t\telse {\n\t\t\t\t \n\t\t\t\tfor (retries = 0;\n\t\t\t\t     retries < loops_per_jiffy / (4000/HZ);\n\t\t\t\t     retries++)\n\t\t\t\t\tif (inb_p(dtlk_port_tts) &\n\t\t\t\t\t    TTS_WRITABLE)\n\t\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tretries = 0;\n\t\t}\n\t\tif (i == count)\n\t\t\treturn i;\n\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\tbreak;\n\n\t\tmsleep_interruptible(1);\n\n\t\tif (++retries > 10 * HZ) {  \n\t\t\tprintk(\"dtlk: write timeout.  \"\n\t\t\t       \"inb_p(dtlk_port_tts) = 0x%02x\\n\",\n\t\t\t       inb_p(dtlk_port_tts));\n\t\t\tTRACE_RET;\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\tTRACE_RET;\n\treturn -EAGAIN;\n}\n\nstatic __poll_t dtlk_poll(struct file *file, poll_table * wait)\n{\n\t__poll_t mask = 0;\n\tunsigned long expires;\n\n\tTRACE_TEXT(\" dtlk_poll\");\n\t \n\tpoll_wait(file, &dtlk_process_list, wait);\n\n\tif (dtlk_has_indexing && dtlk_readable()) {\n\t        del_timer(&dtlk_timer);\n\t\tmask = EPOLLIN | EPOLLRDNORM;\n\t}\n\tif (dtlk_writeable()) {\n\t        del_timer(&dtlk_timer);\n\t\tmask |= EPOLLOUT | EPOLLWRNORM;\n\t}\n\t \n\n\t \n\texpires = jiffies + 3*HZ / 100;\n\tmod_timer(&dtlk_timer, expires);\n\n\treturn mask;\n}\n\nstatic void dtlk_timer_tick(struct timer_list *unused)\n{\n\tTRACE_TEXT(\" dtlk_timer_tick\");\n\twake_up_interruptible(&dtlk_process_list);\n}\n\nstatic long dtlk_ioctl(struct file *file,\n\t\t       unsigned int cmd,\n\t\t       unsigned long arg)\n{\n\tchar __user *argp = (char __user *)arg;\n\tstruct dtlk_settings *sp;\n\tchar portval;\n\tTRACE_TEXT(\" dtlk_ioctl\");\n\n\tswitch (cmd) {\n\n\tcase DTLK_INTERROGATE:\n\t\tmutex_lock(&dtlk_mutex);\n\t\tsp = dtlk_interrogate();\n\t\tmutex_unlock(&dtlk_mutex);\n\t\tif (copy_to_user(argp, sp, sizeof(struct dtlk_settings)))\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\n\tcase DTLK_STATUS:\n\t\tportval = inb_p(dtlk_port_tts);\n\t\treturn put_user(portval, argp);\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n \nstatic int dtlk_open(struct inode *inode, struct file *file)\n{\n\tTRACE_TEXT(\"(dtlk_open\");\n\n\tswitch (iminor(inode)) {\n\tcase DTLK_MINOR:\n\t\tif (dtlk_busy)\n\t\t\treturn -EBUSY;\n\t\treturn stream_open(inode, file);\n\n\tdefault:\n\t\treturn -ENXIO;\n\t}\n}\n\nstatic int dtlk_release(struct inode *inode, struct file *file)\n{\n\tTRACE_TEXT(\"(dtlk_release\");\n\n\tswitch (iminor(inode)) {\n\tcase DTLK_MINOR:\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\tTRACE_RET;\n\t\n\tdel_timer_sync(&dtlk_timer);\n\n\treturn 0;\n}\n\nstatic int __init dtlk_init(void)\n{\n\tint err;\n\n\tdtlk_port_lpc = 0;\n\tdtlk_port_tts = 0;\n\tdtlk_busy = 0;\n\tdtlk_major = register_chrdev(0, \"dtlk\", &dtlk_fops);\n\tif (dtlk_major < 0) {\n\t\tprintk(KERN_ERR \"DoubleTalk PC - cannot register device\\n\");\n\t\treturn dtlk_major;\n\t}\n\terr = dtlk_dev_probe();\n\tif (err) {\n\t\tunregister_chrdev(dtlk_major, \"dtlk\");\n\t\treturn err;\n\t}\n\tprintk(\", MAJOR %d\\n\", dtlk_major);\n\n\tinit_waitqueue_head(&dtlk_process_list);\n\n\treturn 0;\n}\n\nstatic void __exit dtlk_cleanup (void)\n{\n\tdtlk_write_bytes(\"goodbye\", 8);\n\tmsleep_interruptible(500);\t\t \n\n\tdtlk_write_tts(DTLK_CLEAR);\n\tunregister_chrdev(dtlk_major, \"dtlk\");\n\trelease_region(dtlk_port_lpc, DTLK_IO_EXTENT);\n}\n\nmodule_init(dtlk_init);\nmodule_exit(dtlk_cleanup);\n\n \n\nstatic int dtlk_readable(void)\n{\n#ifdef TRACING\n\tprintk(\" dtlk_readable=%u@%u\", inb_p(dtlk_port_lpc) != 0x7f, jiffies);\n#endif\n\treturn inb_p(dtlk_port_lpc) != 0x7f;\n}\n\nstatic int dtlk_writeable(void)\n{\n\t \n#ifdef TRACINGMORE\n\tprintk(\" dtlk_writeable=%u\", (inb_p(dtlk_port_tts) & TTS_WRITABLE)!=0);\n#endif\n\treturn inb_p(dtlk_port_tts) & TTS_WRITABLE;\n}\n\nstatic int __init dtlk_dev_probe(void)\n{\n\tunsigned int testval = 0;\n\tint i = 0;\n\tstruct dtlk_settings *sp;\n\n\tif (dtlk_port_lpc | dtlk_port_tts)\n\t\treturn -EBUSY;\n\n\tfor (i = 0; dtlk_portlist[i]; i++) {\n#if 0\n\t\tprintk(\"DoubleTalk PC - Port %03x = %04x\\n\",\n\t\t       dtlk_portlist[i], (testval = inw_p(dtlk_portlist[i])));\n#endif\n\n\t\tif (!request_region(dtlk_portlist[i], DTLK_IO_EXTENT, \n\t\t\t       \"dtlk\"))\n\t\t\tcontinue;\n\t\ttestval = inw_p(dtlk_portlist[i]);\n\t\tif ((testval &= 0xfbff) == 0x107f) {\n\t\t\tdtlk_port_lpc = dtlk_portlist[i];\n\t\t\tdtlk_port_tts = dtlk_port_lpc + 1;\n\n\t\t\tsp = dtlk_interrogate();\n\t\t\tprintk(\"DoubleTalk PC at %03x-%03x, \"\n\t\t\t       \"ROM version %s, serial number %u\",\n\t\t\t       dtlk_portlist[i], dtlk_portlist[i] +\n\t\t\t       DTLK_IO_EXTENT - 1,\n\t\t\t       sp->rom_version, sp->serial_number);\n\n                         \n\t\t\toutb_p(0xff, dtlk_port_lpc); \n\n                         \n\t\t\tdtlk_write_bytes(\"\\036\\1@\\0\\0012I\\r\", 8);\n\t\t\t \n\t\t\tmsleep_interruptible(100);\n\t\t\tdtlk_has_indexing = dtlk_readable();\n#ifdef TRACING\n\t\t\tprintk(\", indexing %d\\n\", dtlk_has_indexing);\n#endif\n#ifdef INSCOPE\n\t\t\t{\n \n#define LOOK\t\t\t\t\t\\\nfor (i = 0; i < 10; i++)\t\t\t\\\n  {\t\t\t\t\t\t\\\n    buffer[b++] = inb_p(dtlk_port_lpc);\t\t\\\n    __delay(loops_per_jiffy/(1000000/HZ));             \\\n  }\n\t\t\t\tchar buffer[1000];\n\t\t\t\tint b = 0, i, j;\n\n\t\t\t\tLOOK\n\t\t\t\toutb_p(0xff, dtlk_port_lpc);\n\t\t\t\tbuffer[b++] = 0;\n\t\t\t\tLOOK\n\t\t\t\tdtlk_write_bytes(\"\\0012I\\r\", 4);\n\t\t\t\tbuffer[b++] = 0;\n\t\t\t\t__delay(50 * loops_per_jiffy / (1000/HZ));\n\t\t\t\toutb_p(0xff, dtlk_port_lpc);\n\t\t\t\tbuffer[b++] = 0;\n\t\t\t\tLOOK\n\n\t\t\t\tprintk(\"\\n\");\n\t\t\t\tfor (j = 0; j < b; j++)\n\t\t\t\t\tprintk(\" %02x\", buffer[j]);\n\t\t\t\tprintk(\"\\n\");\n\t\t\t}\n#endif\t\t\t\t \n\n#ifdef OUTSCOPE\n\t\t\t{\n \n#define LOOK\t\t\t\t\t\\\nfor (i = 0; i < 10; i++)\t\t\t\\\n  {\t\t\t\t\t\t\\\n    buffer[b++] = inb_p(dtlk_port_tts);\t\t\\\n    __delay(loops_per_jiffy/(1000000/HZ));    \\\n  }\n\t\t\t\tchar buffer[1000];\n\t\t\t\tint b = 0, i, j;\n\n\t\t\t\tmdelay(10);\t \n\t\t\t\tLOOK\n\t\t\t\toutb_p(0x03, dtlk_port_tts);\n\t\t\t\tbuffer[b++] = 0;\n\t\t\t\tLOOK\n\t\t\t\tLOOK\n\n\t\t\t\tprintk(\"\\n\");\n\t\t\t\tfor (j = 0; j < b; j++)\n\t\t\t\t\tprintk(\" %02x\", buffer[j]);\n\t\t\t\tprintk(\"\\n\");\n\t\t\t}\n#endif\t\t\t\t \n\n\t\t\tdtlk_write_bytes(\"Double Talk found\", 18);\n\n\t\t\treturn 0;\n\t\t}\n\t\trelease_region(dtlk_portlist[i], DTLK_IO_EXTENT);\n\t}\n\n\tprintk(KERN_INFO \"DoubleTalk PC - not found\\n\");\n\treturn -ENODEV;\n}\n\n \n\n \nstatic struct dtlk_settings *dtlk_interrogate(void)\n{\n\tunsigned char *t;\n\tstatic char buf[sizeof(struct dtlk_settings) + 1];\n\tint total, i;\n\tstatic struct dtlk_settings status;\n\tTRACE_TEXT(\"(dtlk_interrogate\");\n\tdtlk_write_bytes(\"\\030\\001?\", 3);\n\tfor (total = 0, i = 0; i < 50; i++) {\n\t\tbuf[total] = dtlk_read_tts();\n\t\tif (total > 2 && buf[total] == 0x7f)\n\t\t\tbreak;\n\t\tif (total < sizeof(struct dtlk_settings))\n\t\t\ttotal++;\n\t}\n\t \n\tt = buf;\n\tstatus.serial_number = t[0] + t[1] * 256;  \n\tt += 2;\n\n\ti = 0;\n\twhile (*t != '\\r') {\n\t\tstatus.rom_version[i] = *t;\n\t\tif (i < sizeof(status.rom_version) - 1)\n\t\t\ti++;\n\t\tt++;\n\t}\n\tstatus.rom_version[i] = 0;\n\tt++;\n\n\tstatus.mode = *t++;\n\tstatus.punc_level = *t++;\n\tstatus.formant_freq = *t++;\n\tstatus.pitch = *t++;\n\tstatus.speed = *t++;\n\tstatus.volume = *t++;\n\tstatus.tone = *t++;\n\tstatus.expression = *t++;\n\tstatus.ext_dict_loaded = *t++;\n\tstatus.ext_dict_status = *t++;\n\tstatus.free_ram = *t++;\n\tstatus.articulation = *t++;\n\tstatus.reverb = *t++;\n\tstatus.eob = *t++;\n\tstatus.has_indexing = dtlk_has_indexing;\n\tTRACE_RET;\n\treturn &status;\n}\n\nstatic char dtlk_read_tts(void)\n{\n\tint portval, retries = 0;\n\tchar ch;\n\tTRACE_TEXT(\"(dtlk_read_tts\");\n\n\t \n\tdo {\n\t\tportval = inb_p(dtlk_port_tts);\n\t} while ((portval & TTS_READABLE) == 0 &&\n\t\t retries++ < DTLK_MAX_RETRIES);\n\tif (retries > DTLK_MAX_RETRIES)\n\t\tprintk(KERN_ERR \"dtlk_read_tts() timeout\\n\");\n\n\tch = inb_p(dtlk_port_tts);\t \n\tch &= 0x7f;\n\toutb_p(ch, dtlk_port_tts);\n\n\tretries = 0;\n\tdo {\n\t\tportval = inb_p(dtlk_port_tts);\n\t} while ((portval & TTS_READABLE) != 0 &&\n\t\t retries++ < DTLK_MAX_RETRIES);\n\tif (retries > DTLK_MAX_RETRIES)\n\t\tprintk(KERN_ERR \"dtlk_read_tts() timeout\\n\");\n\n\tTRACE_RET;\n\treturn ch;\n}\n\nstatic char dtlk_read_lpc(void)\n{\n\tint retries = 0;\n\tchar ch;\n\tTRACE_TEXT(\"(dtlk_read_lpc\");\n\n\t \n\n\tch = inb_p(dtlk_port_lpc);\t \n\n\toutb_p(0xff, dtlk_port_lpc);\n\n\t \n\tretries = (loops_per_jiffy * 20) / (1000000/HZ);\n\twhile (inb_p(dtlk_port_lpc) != 0x7f && --retries > 0);\n\tif (retries == 0)\n\t\tprintk(KERN_ERR \"dtlk_read_lpc() timeout\\n\");\n\n\tTRACE_RET;\n\treturn ch;\n}\n\n \nstatic char dtlk_write_bytes(const char *buf, int n)\n{\n\tchar val = 0;\n\t \n\tTRACE_TEXT(\"(dtlk_write_bytes\");\n\twhile (n-- > 0)\n\t\tval = dtlk_write_tts(*buf++);\n\tTRACE_RET;\n\treturn val;\n}\n\nstatic char dtlk_write_tts(char ch)\n{\n\tint retries = 0;\n#ifdef TRACINGMORE\n\tprintk(\"  dtlk_write_tts(\");\n\tif (' ' <= ch && ch <= '~')\n\t\tprintk(\"'%c'\", ch);\n\telse\n\t\tprintk(\"0x%02x\", ch);\n#endif\n\tif (ch != DTLK_CLEAR)\t \n\t\twhile ((inb_p(dtlk_port_tts) & TTS_WRITABLE) == 0 &&\n\t\t       retries++ < DTLK_MAX_RETRIES)\t \n\t\t\t;\n\tif (retries > DTLK_MAX_RETRIES)\n\t\tprintk(KERN_ERR \"dtlk_write_tts() timeout\\n\");\n\n\toutb_p(ch, dtlk_port_tts);\t \n\t \n\tfor (retries = 0; retries < loops_per_jiffy / (100000/HZ); retries++)\n\t\tif ((inb_p(dtlk_port_tts) & TTS_WRITABLE) == 0)\n\t\t\tbreak;\n\n#ifdef TRACINGMORE\n\tprintk(\")\\n\");\n#endif\n\treturn 0;\n}\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}