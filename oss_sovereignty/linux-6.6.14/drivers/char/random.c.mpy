{
  "module_name": "random.c",
  "hash_id": "491c61efd9c93eb0ce5903b47f3ab128e23208262a911bae3ebe66bed07127b5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/random.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/utsname.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/major.h>\n#include <linux/string.h>\n#include <linux/fcntl.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/blkdev.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n#include <linux/nodemask.h>\n#include <linux/spinlock.h>\n#include <linux/kthread.h>\n#include <linux/percpu.h>\n#include <linux/ptrace.h>\n#include <linux/workqueue.h>\n#include <linux/irq.h>\n#include <linux/ratelimit.h>\n#include <linux/syscalls.h>\n#include <linux/completion.h>\n#include <linux/uuid.h>\n#include <linux/uaccess.h>\n#include <linux/suspend.h>\n#include <linux/siphash.h>\n#include <linux/sched/isolation.h>\n#include <crypto/chacha.h>\n#include <crypto/blake2s.h>\n#include <asm/archrandom.h>\n#include <asm/processor.h>\n#include <asm/irq.h>\n#include <asm/irq_regs.h>\n#include <asm/io.h>\n\n \n\n \nstatic enum {\n\tCRNG_EMPTY = 0,  \n\tCRNG_EARLY = 1,  \n\tCRNG_READY = 2   \n} crng_init __read_mostly = CRNG_EMPTY;\nstatic DEFINE_STATIC_KEY_FALSE(crng_is_ready);\n#define crng_ready() (static_branch_likely(&crng_is_ready) || crng_init >= CRNG_READY)\n \nstatic DECLARE_WAIT_QUEUE_HEAD(crng_init_wait);\nstatic struct fasync_struct *fasync;\nstatic ATOMIC_NOTIFIER_HEAD(random_ready_notifier);\n\n \nstatic struct ratelimit_state urandom_warning =\n\tRATELIMIT_STATE_INIT_FLAGS(\"urandom_warning\", HZ, 3, RATELIMIT_MSG_ON_RELEASE);\nstatic int ratelimit_disable __read_mostly =\n\tIS_ENABLED(CONFIG_WARN_ALL_UNSEEDED_RANDOM);\nmodule_param_named(ratelimit_disable, ratelimit_disable, int, 0644);\nMODULE_PARM_DESC(ratelimit_disable, \"Disable random ratelimit suppression\");\n\n \nbool rng_is_initialized(void)\n{\n\treturn crng_ready();\n}\nEXPORT_SYMBOL(rng_is_initialized);\n\nstatic void __cold crng_set_ready(struct work_struct *work)\n{\n\tstatic_branch_enable(&crng_is_ready);\n}\n\n \nstatic void try_to_generate_entropy(void);\n\n \nint wait_for_random_bytes(void)\n{\n\twhile (!crng_ready()) {\n\t\tint ret;\n\n\t\ttry_to_generate_entropy();\n\t\tret = wait_event_interruptible_timeout(crng_init_wait, crng_ready(), HZ);\n\t\tif (ret)\n\t\t\treturn ret > 0 ? 0 : ret;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(wait_for_random_bytes);\n\n \nint __cold execute_with_initialized_rng(struct notifier_block *nb)\n{\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&random_ready_notifier.lock, flags);\n\tif (crng_ready())\n\t\tnb->notifier_call(nb, 0, NULL);\n\telse\n\t\tret = raw_notifier_chain_register((struct raw_notifier_head *)&random_ready_notifier.head, nb);\n\tspin_unlock_irqrestore(&random_ready_notifier.lock, flags);\n\treturn ret;\n}\n\n#define warn_unseeded_randomness() \\\n\tif (IS_ENABLED(CONFIG_WARN_ALL_UNSEEDED_RANDOM) && !crng_ready()) \\\n\t\tprintk_deferred(KERN_NOTICE \"random: %s called from %pS with crng_init=%d\\n\", \\\n\t\t\t\t__func__, (void *)_RET_IP_, crng_init)\n\n\n \n\nenum {\n\tCRNG_RESEED_START_INTERVAL = HZ,\n\tCRNG_RESEED_INTERVAL = 60 * HZ\n};\n\nstatic struct {\n\tu8 key[CHACHA_KEY_SIZE] __aligned(__alignof__(long));\n\tunsigned long generation;\n\tspinlock_t lock;\n} base_crng = {\n\t.lock = __SPIN_LOCK_UNLOCKED(base_crng.lock)\n};\n\nstruct crng {\n\tu8 key[CHACHA_KEY_SIZE];\n\tunsigned long generation;\n\tlocal_lock_t lock;\n};\n\nstatic DEFINE_PER_CPU(struct crng, crngs) = {\n\t.generation = ULONG_MAX,\n\t.lock = INIT_LOCAL_LOCK(crngs.lock),\n};\n\n \nstatic unsigned int crng_reseed_interval(void)\n{\n\tstatic bool early_boot = true;\n\n\tif (unlikely(READ_ONCE(early_boot))) {\n\t\ttime64_t uptime = ktime_get_seconds();\n\t\tif (uptime >= CRNG_RESEED_INTERVAL / HZ * 2)\n\t\t\tWRITE_ONCE(early_boot, false);\n\t\telse\n\t\t\treturn max_t(unsigned int, CRNG_RESEED_START_INTERVAL,\n\t\t\t\t     (unsigned int)uptime / 2 * HZ);\n\t}\n\treturn CRNG_RESEED_INTERVAL;\n}\n\n \nstatic void extract_entropy(void *buf, size_t len);\n\n \nstatic void crng_reseed(struct work_struct *work)\n{\n\tstatic DECLARE_DELAYED_WORK(next_reseed, crng_reseed);\n\tunsigned long flags;\n\tunsigned long next_gen;\n\tu8 key[CHACHA_KEY_SIZE];\n\n\t \n\tif (likely(system_unbound_wq))\n\t\tqueue_delayed_work(system_unbound_wq, &next_reseed, crng_reseed_interval());\n\n\textract_entropy(key, sizeof(key));\n\n\t \n\tspin_lock_irqsave(&base_crng.lock, flags);\n\tmemcpy(base_crng.key, key, sizeof(base_crng.key));\n\tnext_gen = base_crng.generation + 1;\n\tif (next_gen == ULONG_MAX)\n\t\t++next_gen;\n\tWRITE_ONCE(base_crng.generation, next_gen);\n\tif (!static_branch_likely(&crng_is_ready))\n\t\tcrng_init = CRNG_READY;\n\tspin_unlock_irqrestore(&base_crng.lock, flags);\n\tmemzero_explicit(key, sizeof(key));\n}\n\n \nstatic void crng_fast_key_erasure(u8 key[CHACHA_KEY_SIZE],\n\t\t\t\t  u32 chacha_state[CHACHA_STATE_WORDS],\n\t\t\t\t  u8 *random_data, size_t random_data_len)\n{\n\tu8 first_block[CHACHA_BLOCK_SIZE];\n\n\tBUG_ON(random_data_len > 32);\n\n\tchacha_init_consts(chacha_state);\n\tmemcpy(&chacha_state[4], key, CHACHA_KEY_SIZE);\n\tmemset(&chacha_state[12], 0, sizeof(u32) * 4);\n\tchacha20_block(chacha_state, first_block);\n\n\tmemcpy(key, first_block, CHACHA_KEY_SIZE);\n\tmemcpy(random_data, first_block + CHACHA_KEY_SIZE, random_data_len);\n\tmemzero_explicit(first_block, sizeof(first_block));\n}\n\n \nstatic void crng_make_state(u32 chacha_state[CHACHA_STATE_WORDS],\n\t\t\t    u8 *random_data, size_t random_data_len)\n{\n\tunsigned long flags;\n\tstruct crng *crng;\n\n\tBUG_ON(random_data_len > 32);\n\n\t \n\tif (!crng_ready()) {\n\t\tbool ready;\n\n\t\tspin_lock_irqsave(&base_crng.lock, flags);\n\t\tready = crng_ready();\n\t\tif (!ready) {\n\t\t\tif (crng_init == CRNG_EMPTY)\n\t\t\t\textract_entropy(base_crng.key, sizeof(base_crng.key));\n\t\t\tcrng_fast_key_erasure(base_crng.key, chacha_state,\n\t\t\t\t\t      random_data, random_data_len);\n\t\t}\n\t\tspin_unlock_irqrestore(&base_crng.lock, flags);\n\t\tif (!ready)\n\t\t\treturn;\n\t}\n\n\tlocal_lock_irqsave(&crngs.lock, flags);\n\tcrng = raw_cpu_ptr(&crngs);\n\n\t \n\tif (unlikely(crng->generation != READ_ONCE(base_crng.generation))) {\n\t\tspin_lock(&base_crng.lock);\n\t\tcrng_fast_key_erasure(base_crng.key, chacha_state,\n\t\t\t\t      crng->key, sizeof(crng->key));\n\t\tcrng->generation = base_crng.generation;\n\t\tspin_unlock(&base_crng.lock);\n\t}\n\n\t \n\tcrng_fast_key_erasure(crng->key, chacha_state, random_data, random_data_len);\n\tlocal_unlock_irqrestore(&crngs.lock, flags);\n}\n\nstatic void _get_random_bytes(void *buf, size_t len)\n{\n\tu32 chacha_state[CHACHA_STATE_WORDS];\n\tu8 tmp[CHACHA_BLOCK_SIZE];\n\tsize_t first_block_len;\n\n\tif (!len)\n\t\treturn;\n\n\tfirst_block_len = min_t(size_t, 32, len);\n\tcrng_make_state(chacha_state, buf, first_block_len);\n\tlen -= first_block_len;\n\tbuf += first_block_len;\n\n\twhile (len) {\n\t\tif (len < CHACHA_BLOCK_SIZE) {\n\t\t\tchacha20_block(chacha_state, tmp);\n\t\t\tmemcpy(buf, tmp, len);\n\t\t\tmemzero_explicit(tmp, sizeof(tmp));\n\t\t\tbreak;\n\t\t}\n\n\t\tchacha20_block(chacha_state, buf);\n\t\tif (unlikely(chacha_state[12] == 0))\n\t\t\t++chacha_state[13];\n\t\tlen -= CHACHA_BLOCK_SIZE;\n\t\tbuf += CHACHA_BLOCK_SIZE;\n\t}\n\n\tmemzero_explicit(chacha_state, sizeof(chacha_state));\n}\n\n \nvoid get_random_bytes(void *buf, size_t len)\n{\n\twarn_unseeded_randomness();\n\t_get_random_bytes(buf, len);\n}\nEXPORT_SYMBOL(get_random_bytes);\n\nstatic ssize_t get_random_bytes_user(struct iov_iter *iter)\n{\n\tu32 chacha_state[CHACHA_STATE_WORDS];\n\tu8 block[CHACHA_BLOCK_SIZE];\n\tsize_t ret = 0, copied;\n\n\tif (unlikely(!iov_iter_count(iter)))\n\t\treturn 0;\n\n\t \n\tcrng_make_state(chacha_state, (u8 *)&chacha_state[4], CHACHA_KEY_SIZE);\n\t \n\tif (iov_iter_count(iter) <= CHACHA_KEY_SIZE) {\n\t\tret = copy_to_iter(&chacha_state[4], CHACHA_KEY_SIZE, iter);\n\t\tgoto out_zero_chacha;\n\t}\n\n\tfor (;;) {\n\t\tchacha20_block(chacha_state, block);\n\t\tif (unlikely(chacha_state[12] == 0))\n\t\t\t++chacha_state[13];\n\n\t\tcopied = copy_to_iter(block, sizeof(block), iter);\n\t\tret += copied;\n\t\tif (!iov_iter_count(iter) || copied != sizeof(block))\n\t\t\tbreak;\n\n\t\tBUILD_BUG_ON(PAGE_SIZE % sizeof(block) != 0);\n\t\tif (ret % PAGE_SIZE == 0) {\n\t\t\tif (signal_pending(current))\n\t\t\t\tbreak;\n\t\t\tcond_resched();\n\t\t}\n\t}\n\n\tmemzero_explicit(block, sizeof(block));\nout_zero_chacha:\n\tmemzero_explicit(chacha_state, sizeof(chacha_state));\n\treturn ret ? ret : -EFAULT;\n}\n\n \n\n#define DEFINE_BATCHED_ENTROPY(type)\t\t\t\t\t\t\\\nstruct batch_ ##type {\t\t\t\t\t\t\t\t\\\n\t \t\t\t\t\t\t\t\t\t\\\n\ttype entropy[CHACHA_BLOCK_SIZE * 3 / (2 * sizeof(type))];\t\t\\\n\tlocal_lock_t lock;\t\t\t\t\t\t\t\\\n\tunsigned long generation;\t\t\t\t\t\t\\\n\tunsigned int position;\t\t\t\t\t\t\t\\\n};\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\nstatic DEFINE_PER_CPU(struct batch_ ##type, batched_entropy_ ##type) = {\t\\\n\t.lock = INIT_LOCAL_LOCK(batched_entropy_ ##type.lock),\t\t\t\\\n\t.position = UINT_MAX\t\t\t\t\t\t\t\\\n};\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\ntype get_random_ ##type(void)\t\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\t\\\n\ttype ret;\t\t\t\t\t\t\t\t\\\n\tunsigned long flags;\t\t\t\t\t\t\t\\\n\tstruct batch_ ##type *batch;\t\t\t\t\t\t\\\n\tunsigned long next_gen;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\twarn_unseeded_randomness();\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\tif  (!crng_ready()) {\t\t\t\t\t\t\t\\\n\t\t_get_random_bytes(&ret, sizeof(ret));\t\t\t\t\\\n\t\treturn ret;\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\tlocal_lock_irqsave(&batched_entropy_ ##type.lock, flags);\t\t\\\n\tbatch = raw_cpu_ptr(&batched_entropy_##type);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\tnext_gen = READ_ONCE(base_crng.generation);\t\t\t\t\\\n\tif (batch->position >= ARRAY_SIZE(batch->entropy) ||\t\t\t\\\n\t    next_gen != batch->generation) {\t\t\t\t\t\\\n\t\t_get_random_bytes(batch->entropy, sizeof(batch->entropy));\t\\\n\t\tbatch->position = 0;\t\t\t\t\t\t\\\n\t\tbatch->generation = next_gen;\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\tret = batch->entropy[batch->position];\t\t\t\t\t\\\n\tbatch->entropy[batch->position] = 0;\t\t\t\t\t\\\n\t++batch->position;\t\t\t\t\t\t\t\\\n\tlocal_unlock_irqrestore(&batched_entropy_ ##type.lock, flags);\t\t\\\n\treturn ret;\t\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\t\\\nEXPORT_SYMBOL(get_random_ ##type);\n\nDEFINE_BATCHED_ENTROPY(u8)\nDEFINE_BATCHED_ENTROPY(u16)\nDEFINE_BATCHED_ENTROPY(u32)\nDEFINE_BATCHED_ENTROPY(u64)\n\nu32 __get_random_u32_below(u32 ceil)\n{\n\t \n\tu32 rand = get_random_u32();\n\tu64 mult;\n\n\t \n\tif (unlikely(!ceil))\n\t\treturn rand;\n\n\tmult = (u64)ceil * rand;\n\tif (unlikely((u32)mult < ceil)) {\n\t\tu32 bound = -ceil % ceil;\n\t\twhile (unlikely((u32)mult < bound))\n\t\t\tmult = (u64)ceil * get_random_u32();\n\t}\n\treturn mult >> 32;\n}\nEXPORT_SYMBOL(__get_random_u32_below);\n\n#ifdef CONFIG_SMP\n \nint __cold random_prepare_cpu(unsigned int cpu)\n{\n\t \n\tper_cpu_ptr(&crngs, cpu)->generation = ULONG_MAX;\n\tper_cpu_ptr(&batched_entropy_u8, cpu)->position = UINT_MAX;\n\tper_cpu_ptr(&batched_entropy_u16, cpu)->position = UINT_MAX;\n\tper_cpu_ptr(&batched_entropy_u32, cpu)->position = UINT_MAX;\n\tper_cpu_ptr(&batched_entropy_u64, cpu)->position = UINT_MAX;\n\treturn 0;\n}\n#endif\n\n\n \n\nenum {\n\tPOOL_BITS = BLAKE2S_HASH_SIZE * 8,\n\tPOOL_READY_BITS = POOL_BITS,  \n\tPOOL_EARLY_BITS = POOL_READY_BITS / 2  \n};\n\nstatic struct {\n\tstruct blake2s_state hash;\n\tspinlock_t lock;\n\tunsigned int init_bits;\n} input_pool = {\n\t.hash.h = { BLAKE2S_IV0 ^ (0x01010000 | BLAKE2S_HASH_SIZE),\n\t\t    BLAKE2S_IV1, BLAKE2S_IV2, BLAKE2S_IV3, BLAKE2S_IV4,\n\t\t    BLAKE2S_IV5, BLAKE2S_IV6, BLAKE2S_IV7 },\n\t.hash.outlen = BLAKE2S_HASH_SIZE,\n\t.lock = __SPIN_LOCK_UNLOCKED(input_pool.lock),\n};\n\nstatic void _mix_pool_bytes(const void *buf, size_t len)\n{\n\tblake2s_update(&input_pool.hash, buf, len);\n}\n\n \nstatic void mix_pool_bytes(const void *buf, size_t len)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&input_pool.lock, flags);\n\t_mix_pool_bytes(buf, len);\n\tspin_unlock_irqrestore(&input_pool.lock, flags);\n}\n\n \nstatic void extract_entropy(void *buf, size_t len)\n{\n\tunsigned long flags;\n\tu8 seed[BLAKE2S_HASH_SIZE], next_key[BLAKE2S_HASH_SIZE];\n\tstruct {\n\t\tunsigned long rdseed[32 / sizeof(long)];\n\t\tsize_t counter;\n\t} block;\n\tsize_t i, longs;\n\n\tfor (i = 0; i < ARRAY_SIZE(block.rdseed);) {\n\t\tlongs = arch_get_random_seed_longs(&block.rdseed[i], ARRAY_SIZE(block.rdseed) - i);\n\t\tif (longs) {\n\t\t\ti += longs;\n\t\t\tcontinue;\n\t\t}\n\t\tlongs = arch_get_random_longs(&block.rdseed[i], ARRAY_SIZE(block.rdseed) - i);\n\t\tif (longs) {\n\t\t\ti += longs;\n\t\t\tcontinue;\n\t\t}\n\t\tblock.rdseed[i++] = random_get_entropy();\n\t}\n\n\tspin_lock_irqsave(&input_pool.lock, flags);\n\n\t \n\tblake2s_final(&input_pool.hash, seed);\n\n\t \n\tblock.counter = 0;\n\tblake2s(next_key, (u8 *)&block, seed, sizeof(next_key), sizeof(block), sizeof(seed));\n\tblake2s_init_key(&input_pool.hash, BLAKE2S_HASH_SIZE, next_key, sizeof(next_key));\n\n\tspin_unlock_irqrestore(&input_pool.lock, flags);\n\tmemzero_explicit(next_key, sizeof(next_key));\n\n\twhile (len) {\n\t\ti = min_t(size_t, len, BLAKE2S_HASH_SIZE);\n\t\t \n\t\t++block.counter;\n\t\tblake2s(buf, (u8 *)&block, seed, i, sizeof(block), sizeof(seed));\n\t\tlen -= i;\n\t\tbuf += i;\n\t}\n\n\tmemzero_explicit(seed, sizeof(seed));\n\tmemzero_explicit(&block, sizeof(block));\n}\n\n#define credit_init_bits(bits) if (!crng_ready()) _credit_init_bits(bits)\n\nstatic void __cold _credit_init_bits(size_t bits)\n{\n\tstatic struct execute_work set_ready;\n\tunsigned int new, orig, add;\n\tunsigned long flags;\n\n\tif (!bits)\n\t\treturn;\n\n\tadd = min_t(size_t, bits, POOL_BITS);\n\n\torig = READ_ONCE(input_pool.init_bits);\n\tdo {\n\t\tnew = min_t(unsigned int, POOL_BITS, orig + add);\n\t} while (!try_cmpxchg(&input_pool.init_bits, &orig, new));\n\n\tif (orig < POOL_READY_BITS && new >= POOL_READY_BITS) {\n\t\tcrng_reseed(NULL);  \n\t\tif (static_key_initialized)\n\t\t\texecute_in_process_context(crng_set_ready, &set_ready);\n\t\tatomic_notifier_call_chain(&random_ready_notifier, 0, NULL);\n\t\twake_up_interruptible(&crng_init_wait);\n\t\tkill_fasync(&fasync, SIGIO, POLL_IN);\n\t\tpr_notice(\"crng init done\\n\");\n\t\tif (urandom_warning.missed)\n\t\t\tpr_notice(\"%d urandom warning(s) missed due to ratelimiting\\n\",\n\t\t\t\t  urandom_warning.missed);\n\t} else if (orig < POOL_EARLY_BITS && new >= POOL_EARLY_BITS) {\n\t\tspin_lock_irqsave(&base_crng.lock, flags);\n\t\t \n\t\tif (crng_init == CRNG_EMPTY) {\n\t\t\textract_entropy(base_crng.key, sizeof(base_crng.key));\n\t\t\tcrng_init = CRNG_EARLY;\n\t\t}\n\t\tspin_unlock_irqrestore(&base_crng.lock, flags);\n\t}\n}\n\n\n \n\nstatic bool trust_cpu __initdata = true;\nstatic bool trust_bootloader __initdata = true;\nstatic int __init parse_trust_cpu(char *arg)\n{\n\treturn kstrtobool(arg, &trust_cpu);\n}\nstatic int __init parse_trust_bootloader(char *arg)\n{\n\treturn kstrtobool(arg, &trust_bootloader);\n}\nearly_param(\"random.trust_cpu\", parse_trust_cpu);\nearly_param(\"random.trust_bootloader\", parse_trust_bootloader);\n\nstatic int random_pm_notification(struct notifier_block *nb, unsigned long action, void *data)\n{\n\tunsigned long flags, entropy = random_get_entropy();\n\n\t \n\tktime_t stamps[] = { ktime_get(), ktime_get_boottime(), ktime_get_real() };\n\n\tspin_lock_irqsave(&input_pool.lock, flags);\n\t_mix_pool_bytes(&action, sizeof(action));\n\t_mix_pool_bytes(stamps, sizeof(stamps));\n\t_mix_pool_bytes(&entropy, sizeof(entropy));\n\tspin_unlock_irqrestore(&input_pool.lock, flags);\n\n\tif (crng_ready() && (action == PM_RESTORE_PREPARE ||\n\t    (action == PM_POST_SUSPEND && !IS_ENABLED(CONFIG_PM_AUTOSLEEP) &&\n\t     !IS_ENABLED(CONFIG_PM_USERSPACE_AUTOSLEEP)))) {\n\t\tcrng_reseed(NULL);\n\t\tpr_notice(\"crng reseeded on system resumption\\n\");\n\t}\n\treturn 0;\n}\n\nstatic struct notifier_block pm_notifier = { .notifier_call = random_pm_notification };\n\n \nvoid __init random_init_early(const char *command_line)\n{\n\tunsigned long entropy[BLAKE2S_BLOCK_SIZE / sizeof(long)];\n\tsize_t i, longs, arch_bits;\n\n#if defined(LATENT_ENTROPY_PLUGIN)\n\tstatic const u8 compiletime_seed[BLAKE2S_BLOCK_SIZE] __initconst __latent_entropy;\n\t_mix_pool_bytes(compiletime_seed, sizeof(compiletime_seed));\n#endif\n\n\tfor (i = 0, arch_bits = sizeof(entropy) * 8; i < ARRAY_SIZE(entropy);) {\n\t\tlongs = arch_get_random_seed_longs(entropy, ARRAY_SIZE(entropy) - i);\n\t\tif (longs) {\n\t\t\t_mix_pool_bytes(entropy, sizeof(*entropy) * longs);\n\t\t\ti += longs;\n\t\t\tcontinue;\n\t\t}\n\t\tlongs = arch_get_random_longs(entropy, ARRAY_SIZE(entropy) - i);\n\t\tif (longs) {\n\t\t\t_mix_pool_bytes(entropy, sizeof(*entropy) * longs);\n\t\t\ti += longs;\n\t\t\tcontinue;\n\t\t}\n\t\tarch_bits -= sizeof(*entropy) * 8;\n\t\t++i;\n\t}\n\n\t_mix_pool_bytes(init_utsname(), sizeof(*(init_utsname())));\n\t_mix_pool_bytes(command_line, strlen(command_line));\n\n\t \n\tif (crng_ready())\n\t\tcrng_reseed(NULL);\n\telse if (trust_cpu)\n\t\t_credit_init_bits(arch_bits);\n}\n\n \nvoid __init random_init(void)\n{\n\tunsigned long entropy = random_get_entropy();\n\tktime_t now = ktime_get_real();\n\n\t_mix_pool_bytes(&now, sizeof(now));\n\t_mix_pool_bytes(&entropy, sizeof(entropy));\n\tadd_latent_entropy();\n\n\t \n\tif (!static_branch_likely(&crng_is_ready) && crng_init >= CRNG_READY)\n\t\tcrng_set_ready(NULL);\n\n\t \n\tif (crng_ready())\n\t\tcrng_reseed(NULL);\n\n\tWARN_ON(register_pm_notifier(&pm_notifier));\n\n\tWARN(!entropy, \"Missing cycle counter and fallback timer; RNG \"\n\t\t       \"entropy collection will consequently suffer.\");\n}\n\n \nvoid add_device_randomness(const void *buf, size_t len)\n{\n\tunsigned long entropy = random_get_entropy();\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&input_pool.lock, flags);\n\t_mix_pool_bytes(&entropy, sizeof(entropy));\n\t_mix_pool_bytes(buf, len);\n\tspin_unlock_irqrestore(&input_pool.lock, flags);\n}\nEXPORT_SYMBOL(add_device_randomness);\n\n \nvoid add_hwgenerator_randomness(const void *buf, size_t len, size_t entropy, bool sleep_after)\n{\n\tmix_pool_bytes(buf, len);\n\tcredit_init_bits(entropy);\n\n\t \n\tif (sleep_after && !kthread_should_stop() && (crng_ready() || !entropy))\n\t\tschedule_timeout_interruptible(crng_reseed_interval());\n}\nEXPORT_SYMBOL_GPL(add_hwgenerator_randomness);\n\n \nvoid __init add_bootloader_randomness(const void *buf, size_t len)\n{\n\tmix_pool_bytes(buf, len);\n\tif (trust_bootloader)\n\t\tcredit_init_bits(len * 8);\n}\n\n#if IS_ENABLED(CONFIG_VMGENID)\nstatic BLOCKING_NOTIFIER_HEAD(vmfork_chain);\n\n \nvoid __cold add_vmfork_randomness(const void *unique_vm_id, size_t len)\n{\n\tadd_device_randomness(unique_vm_id, len);\n\tif (crng_ready()) {\n\t\tcrng_reseed(NULL);\n\t\tpr_notice(\"crng reseeded due to virtual machine fork\\n\");\n\t}\n\tblocking_notifier_call_chain(&vmfork_chain, 0, NULL);\n}\n#if IS_MODULE(CONFIG_VMGENID)\nEXPORT_SYMBOL_GPL(add_vmfork_randomness);\n#endif\n\nint __cold register_random_vmfork_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_register(&vmfork_chain, nb);\n}\nEXPORT_SYMBOL_GPL(register_random_vmfork_notifier);\n\nint __cold unregister_random_vmfork_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&vmfork_chain, nb);\n}\nEXPORT_SYMBOL_GPL(unregister_random_vmfork_notifier);\n#endif\n\nstruct fast_pool {\n\tunsigned long pool[4];\n\tunsigned long last;\n\tunsigned int count;\n\tstruct timer_list mix;\n};\n\nstatic void mix_interrupt_randomness(struct timer_list *work);\n\nstatic DEFINE_PER_CPU(struct fast_pool, irq_randomness) = {\n#ifdef CONFIG_64BIT\n#define FASTMIX_PERM SIPHASH_PERMUTATION\n\t.pool = { SIPHASH_CONST_0, SIPHASH_CONST_1, SIPHASH_CONST_2, SIPHASH_CONST_3 },\n#else\n#define FASTMIX_PERM HSIPHASH_PERMUTATION\n\t.pool = { HSIPHASH_CONST_0, HSIPHASH_CONST_1, HSIPHASH_CONST_2, HSIPHASH_CONST_3 },\n#endif\n\t.mix = __TIMER_INITIALIZER(mix_interrupt_randomness, 0)\n};\n\n \nstatic void fast_mix(unsigned long s[4], unsigned long v1, unsigned long v2)\n{\n\ts[3] ^= v1;\n\tFASTMIX_PERM(s[0], s[1], s[2], s[3]);\n\ts[0] ^= v1;\n\ts[3] ^= v2;\n\tFASTMIX_PERM(s[0], s[1], s[2], s[3]);\n\ts[0] ^= v2;\n}\n\n#ifdef CONFIG_SMP\n \nint __cold random_online_cpu(unsigned int cpu)\n{\n\t \n\tper_cpu_ptr(&irq_randomness, cpu)->count = 0;\n\treturn 0;\n}\n#endif\n\nstatic void mix_interrupt_randomness(struct timer_list *work)\n{\n\tstruct fast_pool *fast_pool = container_of(work, struct fast_pool, mix);\n\t \n\tunsigned long pool[2];\n\tunsigned int count;\n\n\t \n\tlocal_irq_disable();\n\tif (fast_pool != this_cpu_ptr(&irq_randomness)) {\n\t\tlocal_irq_enable();\n\t\treturn;\n\t}\n\n\t \n\tmemcpy(pool, fast_pool->pool, sizeof(pool));\n\tcount = fast_pool->count;\n\tfast_pool->count = 0;\n\tfast_pool->last = jiffies;\n\tlocal_irq_enable();\n\n\tmix_pool_bytes(pool, sizeof(pool));\n\tcredit_init_bits(clamp_t(unsigned int, (count & U16_MAX) / 64, 1, sizeof(pool) * 8));\n\n\tmemzero_explicit(pool, sizeof(pool));\n}\n\nvoid add_interrupt_randomness(int irq)\n{\n\tenum { MIX_INFLIGHT = 1U << 31 };\n\tunsigned long entropy = random_get_entropy();\n\tstruct fast_pool *fast_pool = this_cpu_ptr(&irq_randomness);\n\tstruct pt_regs *regs = get_irq_regs();\n\tunsigned int new_count;\n\n\tfast_mix(fast_pool->pool, entropy,\n\t\t (regs ? instruction_pointer(regs) : _RET_IP_) ^ swab(irq));\n\tnew_count = ++fast_pool->count;\n\n\tif (new_count & MIX_INFLIGHT)\n\t\treturn;\n\n\tif (new_count < 1024 && !time_is_before_jiffies(fast_pool->last + HZ))\n\t\treturn;\n\n\tfast_pool->count |= MIX_INFLIGHT;\n\tif (!timer_pending(&fast_pool->mix)) {\n\t\tfast_pool->mix.expires = jiffies;\n\t\tadd_timer_on(&fast_pool->mix, raw_smp_processor_id());\n\t}\n}\nEXPORT_SYMBOL_GPL(add_interrupt_randomness);\n\n \nstruct timer_rand_state {\n\tunsigned long last_time;\n\tlong last_delta, last_delta2;\n};\n\n \nstatic void add_timer_randomness(struct timer_rand_state *state, unsigned int num)\n{\n\tunsigned long entropy = random_get_entropy(), now = jiffies, flags;\n\tlong delta, delta2, delta3;\n\tunsigned int bits;\n\n\t \n\tif (in_hardirq()) {\n\t\tfast_mix(this_cpu_ptr(&irq_randomness)->pool, entropy, num);\n\t} else {\n\t\tspin_lock_irqsave(&input_pool.lock, flags);\n\t\t_mix_pool_bytes(&entropy, sizeof(entropy));\n\t\t_mix_pool_bytes(&num, sizeof(num));\n\t\tspin_unlock_irqrestore(&input_pool.lock, flags);\n\t}\n\n\tif (crng_ready())\n\t\treturn;\n\n\t \n\tdelta = now - READ_ONCE(state->last_time);\n\tWRITE_ONCE(state->last_time, now);\n\n\tdelta2 = delta - READ_ONCE(state->last_delta);\n\tWRITE_ONCE(state->last_delta, delta);\n\n\tdelta3 = delta2 - READ_ONCE(state->last_delta2);\n\tWRITE_ONCE(state->last_delta2, delta2);\n\n\tif (delta < 0)\n\t\tdelta = -delta;\n\tif (delta2 < 0)\n\t\tdelta2 = -delta2;\n\tif (delta3 < 0)\n\t\tdelta3 = -delta3;\n\tif (delta > delta2)\n\t\tdelta = delta2;\n\tif (delta > delta3)\n\t\tdelta = delta3;\n\n\t \n\tbits = min(fls(delta >> 1), 11);\n\n\t \n\tif (in_hardirq())\n\t\tthis_cpu_ptr(&irq_randomness)->count += max(1u, bits * 64) - 1;\n\telse\n\t\t_credit_init_bits(bits);\n}\n\nvoid add_input_randomness(unsigned int type, unsigned int code, unsigned int value)\n{\n\tstatic unsigned char last_value;\n\tstatic struct timer_rand_state input_timer_state = { INITIAL_JIFFIES };\n\n\t \n\tif (value == last_value)\n\t\treturn;\n\n\tlast_value = value;\n\tadd_timer_randomness(&input_timer_state,\n\t\t\t     (type << 4) ^ code ^ (code >> 4) ^ value);\n}\nEXPORT_SYMBOL_GPL(add_input_randomness);\n\n#ifdef CONFIG_BLOCK\nvoid add_disk_randomness(struct gendisk *disk)\n{\n\tif (!disk || !disk->random)\n\t\treturn;\n\t \n\tadd_timer_randomness(disk->random, 0x100 + disk_devt(disk));\n}\nEXPORT_SYMBOL_GPL(add_disk_randomness);\n\nvoid __cold rand_initialize_disk(struct gendisk *disk)\n{\n\tstruct timer_rand_state *state;\n\n\t \n\tstate = kzalloc(sizeof(struct timer_rand_state), GFP_KERNEL);\n\tif (state) {\n\t\tstate->last_time = INITIAL_JIFFIES;\n\t\tdisk->random = state;\n\t}\n}\n#endif\n\nstruct entropy_timer_state {\n\tunsigned long entropy;\n\tstruct timer_list timer;\n\tatomic_t samples;\n\tunsigned int samples_per_bit;\n};\n\n \nstatic void __cold entropy_timer(struct timer_list *timer)\n{\n\tstruct entropy_timer_state *state = container_of(timer, struct entropy_timer_state, timer);\n\tunsigned long entropy = random_get_entropy();\n\n\tmix_pool_bytes(&entropy, sizeof(entropy));\n\tif (atomic_inc_return(&state->samples) % state->samples_per_bit == 0)\n\t\tcredit_init_bits(1);\n}\n\n \nstatic void __cold try_to_generate_entropy(void)\n{\n\tenum { NUM_TRIAL_SAMPLES = 8192, MAX_SAMPLES_PER_BIT = HZ / 15 };\n\tu8 stack_bytes[sizeof(struct entropy_timer_state) + SMP_CACHE_BYTES - 1];\n\tstruct entropy_timer_state *stack = PTR_ALIGN((void *)stack_bytes, SMP_CACHE_BYTES);\n\tunsigned int i, num_different = 0;\n\tunsigned long last = random_get_entropy();\n\tint cpu = -1;\n\n\tfor (i = 0; i < NUM_TRIAL_SAMPLES - 1; ++i) {\n\t\tstack->entropy = random_get_entropy();\n\t\tif (stack->entropy != last)\n\t\t\t++num_different;\n\t\tlast = stack->entropy;\n\t}\n\tstack->samples_per_bit = DIV_ROUND_UP(NUM_TRIAL_SAMPLES, num_different + 1);\n\tif (stack->samples_per_bit > MAX_SAMPLES_PER_BIT)\n\t\treturn;\n\n\tatomic_set(&stack->samples, 0);\n\ttimer_setup_on_stack(&stack->timer, entropy_timer, 0);\n\twhile (!crng_ready() && !signal_pending(current)) {\n\t\t \n\t\tif (!timer_pending(&stack->timer) && try_to_del_timer_sync(&stack->timer) >= 0) {\n\t\t\tstruct cpumask timer_cpus;\n\t\t\tunsigned int num_cpus;\n\n\t\t\t \n\t\t\tpreempt_disable();\n\n\t\t\t \n\t\t\tcpumask_and(&timer_cpus, housekeeping_cpumask(HK_TYPE_TIMER), cpu_online_mask);\n\t\t\tnum_cpus = cpumask_weight(&timer_cpus);\n\t\t\t \n\t\t\tif (unlikely(num_cpus == 0)) {\n\t\t\t\ttimer_cpus = *cpu_online_mask;\n\t\t\t\tnum_cpus = cpumask_weight(&timer_cpus);\n\t\t\t}\n\n\t\t\t \n\t\t\tdo {\n\t\t\t\tcpu = cpumask_next(cpu, &timer_cpus);\n\t\t\t\tif (cpu >= nr_cpu_ids)\n\t\t\t\t\tcpu = cpumask_first(&timer_cpus);\n\t\t\t} while (cpu == smp_processor_id() && num_cpus > 1);\n\n\t\t\t \n\t\t\tstack->timer.expires = jiffies;\n\n\t\t\tadd_timer_on(&stack->timer, cpu);\n\n\t\t\tpreempt_enable();\n\t\t}\n\t\tmix_pool_bytes(&stack->entropy, sizeof(stack->entropy));\n\t\tschedule();\n\t\tstack->entropy = random_get_entropy();\n\t}\n\tmix_pool_bytes(&stack->entropy, sizeof(stack->entropy));\n\n\tdel_timer_sync(&stack->timer);\n\tdestroy_timer_on_stack(&stack->timer);\n}\n\n\n \n\nSYSCALL_DEFINE3(getrandom, char __user *, ubuf, size_t, len, unsigned int, flags)\n{\n\tstruct iov_iter iter;\n\tstruct iovec iov;\n\tint ret;\n\n\tif (flags & ~(GRND_NONBLOCK | GRND_RANDOM | GRND_INSECURE))\n\t\treturn -EINVAL;\n\n\t \n\tif ((flags & (GRND_INSECURE | GRND_RANDOM)) == (GRND_INSECURE | GRND_RANDOM))\n\t\treturn -EINVAL;\n\n\tif (!crng_ready() && !(flags & GRND_INSECURE)) {\n\t\tif (flags & GRND_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\t\tret = wait_for_random_bytes();\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\t}\n\n\tret = import_single_range(ITER_DEST, ubuf, len, &iov, &iter);\n\tif (unlikely(ret))\n\t\treturn ret;\n\treturn get_random_bytes_user(&iter);\n}\n\nstatic __poll_t random_poll(struct file *file, poll_table *wait)\n{\n\tpoll_wait(file, &crng_init_wait, wait);\n\treturn crng_ready() ? EPOLLIN | EPOLLRDNORM : EPOLLOUT | EPOLLWRNORM;\n}\n\nstatic ssize_t write_pool_user(struct iov_iter *iter)\n{\n\tu8 block[BLAKE2S_BLOCK_SIZE];\n\tssize_t ret = 0;\n\tsize_t copied;\n\n\tif (unlikely(!iov_iter_count(iter)))\n\t\treturn 0;\n\n\tfor (;;) {\n\t\tcopied = copy_from_iter(block, sizeof(block), iter);\n\t\tret += copied;\n\t\tmix_pool_bytes(block, copied);\n\t\tif (!iov_iter_count(iter) || copied != sizeof(block))\n\t\t\tbreak;\n\n\t\tBUILD_BUG_ON(PAGE_SIZE % sizeof(block) != 0);\n\t\tif (ret % PAGE_SIZE == 0) {\n\t\t\tif (signal_pending(current))\n\t\t\t\tbreak;\n\t\t\tcond_resched();\n\t\t}\n\t}\n\n\tmemzero_explicit(block, sizeof(block));\n\treturn ret ? ret : -EFAULT;\n}\n\nstatic ssize_t random_write_iter(struct kiocb *kiocb, struct iov_iter *iter)\n{\n\treturn write_pool_user(iter);\n}\n\nstatic ssize_t urandom_read_iter(struct kiocb *kiocb, struct iov_iter *iter)\n{\n\tstatic int maxwarn = 10;\n\n\t \n\tif (!crng_ready())\n\t\ttry_to_generate_entropy();\n\n\tif (!crng_ready()) {\n\t\tif (!ratelimit_disable && maxwarn <= 0)\n\t\t\t++urandom_warning.missed;\n\t\telse if (ratelimit_disable || __ratelimit(&urandom_warning)) {\n\t\t\t--maxwarn;\n\t\t\tpr_notice(\"%s: uninitialized urandom read (%zu bytes read)\\n\",\n\t\t\t\t  current->comm, iov_iter_count(iter));\n\t\t}\n\t}\n\n\treturn get_random_bytes_user(iter);\n}\n\nstatic ssize_t random_read_iter(struct kiocb *kiocb, struct iov_iter *iter)\n{\n\tint ret;\n\n\tif (!crng_ready() &&\n\t    ((kiocb->ki_flags & (IOCB_NOWAIT | IOCB_NOIO)) ||\n\t     (kiocb->ki_filp->f_flags & O_NONBLOCK)))\n\t\treturn -EAGAIN;\n\n\tret = wait_for_random_bytes();\n\tif (ret != 0)\n\t\treturn ret;\n\treturn get_random_bytes_user(iter);\n}\n\nstatic long random_ioctl(struct file *f, unsigned int cmd, unsigned long arg)\n{\n\tint __user *p = (int __user *)arg;\n\tint ent_count;\n\n\tswitch (cmd) {\n\tcase RNDGETENTCNT:\n\t\t \n\t\tif (put_user(input_pool.init_bits, p))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tcase RNDADDTOENTCNT:\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (get_user(ent_count, p))\n\t\t\treturn -EFAULT;\n\t\tif (ent_count < 0)\n\t\t\treturn -EINVAL;\n\t\tcredit_init_bits(ent_count);\n\t\treturn 0;\n\tcase RNDADDENTROPY: {\n\t\tstruct iov_iter iter;\n\t\tstruct iovec iov;\n\t\tssize_t ret;\n\t\tint len;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (get_user(ent_count, p++))\n\t\t\treturn -EFAULT;\n\t\tif (ent_count < 0)\n\t\t\treturn -EINVAL;\n\t\tif (get_user(len, p++))\n\t\t\treturn -EFAULT;\n\t\tret = import_single_range(ITER_SOURCE, p, len, &iov, &iter);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\t\tret = write_pool_user(&iter);\n\t\tif (unlikely(ret < 0))\n\t\t\treturn ret;\n\t\t \n\t\tif (unlikely(ret != len))\n\t\t\treturn -EFAULT;\n\t\tcredit_init_bits(ent_count);\n\t\treturn 0;\n\t}\n\tcase RNDZAPENTCNT:\n\tcase RNDCLEARPOOL:\n\t\t \n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\treturn 0;\n\tcase RNDRESEEDCRNG:\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (!crng_ready())\n\t\t\treturn -ENODATA;\n\t\tcrng_reseed(NULL);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int random_fasync(int fd, struct file *filp, int on)\n{\n\treturn fasync_helper(fd, filp, on, &fasync);\n}\n\nconst struct file_operations random_fops = {\n\t.read_iter = random_read_iter,\n\t.write_iter = random_write_iter,\n\t.poll = random_poll,\n\t.unlocked_ioctl = random_ioctl,\n\t.compat_ioctl = compat_ptr_ioctl,\n\t.fasync = random_fasync,\n\t.llseek = noop_llseek,\n\t.splice_read = copy_splice_read,\n\t.splice_write = iter_file_splice_write,\n};\n\nconst struct file_operations urandom_fops = {\n\t.read_iter = urandom_read_iter,\n\t.write_iter = random_write_iter,\n\t.unlocked_ioctl = random_ioctl,\n\t.compat_ioctl = compat_ptr_ioctl,\n\t.fasync = random_fasync,\n\t.llseek = noop_llseek,\n\t.splice_read = copy_splice_read,\n\t.splice_write = iter_file_splice_write,\n};\n\n\n \n\n#ifdef CONFIG_SYSCTL\n\n#include <linux/sysctl.h>\n\nstatic int sysctl_random_min_urandom_seed = CRNG_RESEED_INTERVAL / HZ;\nstatic int sysctl_random_write_wakeup_bits = POOL_READY_BITS;\nstatic int sysctl_poolsize = POOL_BITS;\nstatic u8 sysctl_bootid[UUID_SIZE];\n\n \nstatic int proc_do_uuid(struct ctl_table *table, int write, void *buf,\n\t\t\tsize_t *lenp, loff_t *ppos)\n{\n\tu8 tmp_uuid[UUID_SIZE], *uuid;\n\tchar uuid_string[UUID_STRING_LEN + 1];\n\tstruct ctl_table fake_table = {\n\t\t.data = uuid_string,\n\t\t.maxlen = UUID_STRING_LEN\n\t};\n\n\tif (write)\n\t\treturn -EPERM;\n\n\tuuid = table->data;\n\tif (!uuid) {\n\t\tuuid = tmp_uuid;\n\t\tgenerate_random_uuid(uuid);\n\t} else {\n\t\tstatic DEFINE_SPINLOCK(bootid_spinlock);\n\n\t\tspin_lock(&bootid_spinlock);\n\t\tif (!uuid[8])\n\t\t\tgenerate_random_uuid(uuid);\n\t\tspin_unlock(&bootid_spinlock);\n\t}\n\n\tsnprintf(uuid_string, sizeof(uuid_string), \"%pU\", uuid);\n\treturn proc_dostring(&fake_table, 0, buf, lenp, ppos);\n}\n\n \nstatic int proc_do_rointvec(struct ctl_table *table, int write, void *buf,\n\t\t\t    size_t *lenp, loff_t *ppos)\n{\n\treturn write ? 0 : proc_dointvec(table, 0, buf, lenp, ppos);\n}\n\nstatic struct ctl_table random_table[] = {\n\t{\n\t\t.procname\t= \"poolsize\",\n\t\t.data\t\t= &sysctl_poolsize,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"entropy_avail\",\n\t\t.data\t\t= &input_pool.init_bits,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"write_wakeup_threshold\",\n\t\t.data\t\t= &sysctl_random_write_wakeup_bits,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_do_rointvec,\n\t},\n\t{\n\t\t.procname\t= \"urandom_min_reseed_secs\",\n\t\t.data\t\t= &sysctl_random_min_urandom_seed,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_do_rointvec,\n\t},\n\t{\n\t\t.procname\t= \"boot_id\",\n\t\t.data\t\t= &sysctl_bootid,\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= proc_do_uuid,\n\t},\n\t{\n\t\t.procname\t= \"uuid\",\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= proc_do_uuid,\n\t},\n\t{ }\n};\n\n \nstatic int __init random_sysctls_init(void)\n{\n\tregister_sysctl_init(\"kernel/random\", random_table);\n\treturn 0;\n}\ndevice_initcall(random_sysctls_init);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}