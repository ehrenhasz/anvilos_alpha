{
  "module_name": "apm-emulation.c",
  "hash_id": "e2c363b33698a00af2c91a2fbc319801e3e5eea47be2117725b6d46dab634239",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/apm-emulation.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/miscdevice.h>\n#include <linux/apm_bios.h>\n#include <linux/capability.h>\n#include <linux/sched.h>\n#include <linux/suspend.h>\n#include <linux/apm-emulation.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n\n \n\n \n#define APM_MAX_EVENTS\t\t16\n\nstruct apm_queue {\n\tunsigned int\t\tevent_head;\n\tunsigned int\t\tevent_tail;\n\tapm_event_t\t\tevents[APM_MAX_EVENTS];\n};\n\n \nenum apm_suspend_state {\n\tSUSPEND_NONE,\n\tSUSPEND_PENDING,\n\tSUSPEND_READ,\n\tSUSPEND_ACKED,\n\tSUSPEND_ACKTO,\n\tSUSPEND_WAIT,\n\tSUSPEND_DONE,\n};\n\n \nstruct apm_user {\n\tstruct list_head\tlist;\n\n\tunsigned int\t\tsuser: 1;\n\tunsigned int\t\twriter: 1;\n\tunsigned int\t\treader: 1;\n\n\tint\t\t\tsuspend_result;\n\tenum apm_suspend_state\tsuspend_state;\n\n\tstruct apm_queue\tqueue;\n};\n\n \nstatic atomic_t suspend_acks_pending = ATOMIC_INIT(0);\nstatic atomic_t userspace_notification_inhibit = ATOMIC_INIT(0);\nstatic int apm_disabled;\nstatic struct task_struct *kapmd_tsk;\n\nstatic DECLARE_WAIT_QUEUE_HEAD(apm_waitqueue);\nstatic DECLARE_WAIT_QUEUE_HEAD(apm_suspend_waitqueue);\n\n \nstatic DECLARE_RWSEM(user_list_lock);\nstatic LIST_HEAD(apm_user_list);\n\n \nstatic DECLARE_WAIT_QUEUE_HEAD(kapmd_wait);\nstatic DEFINE_SPINLOCK(kapmd_queue_lock);\nstatic struct apm_queue kapmd_queue;\n\nstatic DEFINE_MUTEX(state_lock);\n\nstatic const char driver_version[] = \"1.13\";\t \n\n\n\n \nstatic void __apm_get_power_status(struct apm_power_info *info)\n{\n}\n\n \nvoid (*apm_get_power_status)(struct apm_power_info *) = __apm_get_power_status;\nEXPORT_SYMBOL(apm_get_power_status);\n\n\n \nstatic inline int queue_empty(struct apm_queue *q)\n{\n\treturn q->event_head == q->event_tail;\n}\n\nstatic inline apm_event_t queue_get_event(struct apm_queue *q)\n{\n\tq->event_tail = (q->event_tail + 1) % APM_MAX_EVENTS;\n\treturn q->events[q->event_tail];\n}\n\nstatic void queue_add_event(struct apm_queue *q, apm_event_t event)\n{\n\tq->event_head = (q->event_head + 1) % APM_MAX_EVENTS;\n\tif (q->event_head == q->event_tail) {\n\t\tstatic int notified;\n\n\t\tif (notified++ == 0)\n\t\t    printk(KERN_ERR \"apm: an event queue overflowed\\n\");\n\t\tq->event_tail = (q->event_tail + 1) % APM_MAX_EVENTS;\n\t}\n\tq->events[q->event_head] = event;\n}\n\nstatic void queue_event(apm_event_t event)\n{\n\tstruct apm_user *as;\n\n\tdown_read(&user_list_lock);\n\tlist_for_each_entry(as, &apm_user_list, list) {\n\t\tif (as->reader)\n\t\t\tqueue_add_event(&as->queue, event);\n\t}\n\tup_read(&user_list_lock);\n\twake_up_interruptible(&apm_waitqueue);\n}\n\nstatic ssize_t apm_read(struct file *fp, char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct apm_user *as = fp->private_data;\n\tapm_event_t event;\n\tint i = count, ret = 0;\n\n\tif (count < sizeof(apm_event_t))\n\t\treturn -EINVAL;\n\n\tif (queue_empty(&as->queue) && fp->f_flags & O_NONBLOCK)\n\t\treturn -EAGAIN;\n\n\twait_event_interruptible(apm_waitqueue, !queue_empty(&as->queue));\n\n\twhile ((i >= sizeof(event)) && !queue_empty(&as->queue)) {\n\t\tevent = queue_get_event(&as->queue);\n\n\t\tret = -EFAULT;\n\t\tif (copy_to_user(buf, &event, sizeof(event)))\n\t\t\tbreak;\n\n\t\tmutex_lock(&state_lock);\n\t\tif (as->suspend_state == SUSPEND_PENDING &&\n\t\t    (event == APM_SYS_SUSPEND || event == APM_USER_SUSPEND))\n\t\t\tas->suspend_state = SUSPEND_READ;\n\t\tmutex_unlock(&state_lock);\n\n\t\tbuf += sizeof(event);\n\t\ti -= sizeof(event);\n\t}\n\n\tif (i < count)\n\t\tret = count - i;\n\n\treturn ret;\n}\n\nstatic __poll_t apm_poll(struct file *fp, poll_table * wait)\n{\n\tstruct apm_user *as = fp->private_data;\n\n\tpoll_wait(fp, &apm_waitqueue, wait);\n\treturn queue_empty(&as->queue) ? 0 : EPOLLIN | EPOLLRDNORM;\n}\n\n \nstatic long\napm_ioctl(struct file *filp, u_int cmd, u_long arg)\n{\n\tstruct apm_user *as = filp->private_data;\n\tint err = -EINVAL;\n\n\tif (!as->suser || !as->writer)\n\t\treturn -EPERM;\n\n\tswitch (cmd) {\n\tcase APM_IOC_SUSPEND:\n\t\tmutex_lock(&state_lock);\n\n\t\tas->suspend_result = -EINTR;\n\n\t\tswitch (as->suspend_state) {\n\t\tcase SUSPEND_READ:\n\t\t\t \n\t\t\tas->suspend_state = SUSPEND_ACKED;\n\t\t\tatomic_dec(&suspend_acks_pending);\n\t\t\tmutex_unlock(&state_lock);\n\n\t\t\t \n\t\t\twake_up(&apm_suspend_waitqueue);\n\n\t\t\t \n\t\t\twhile (wait_event_freezable(apm_suspend_waitqueue,\n\t\t\t\t\tas->suspend_state != SUSPEND_ACKED))\n\t\t\t\tmsleep(10);\n\t\t\tbreak;\n\t\tcase SUSPEND_ACKTO:\n\t\t\tas->suspend_result = -ETIMEDOUT;\n\t\t\tmutex_unlock(&state_lock);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tas->suspend_state = SUSPEND_WAIT;\n\t\t\tmutex_unlock(&state_lock);\n\n\t\t\t \n\t\t\tas->suspend_result = pm_suspend(PM_SUSPEND_MEM);\n\t\t}\n\n\t\tmutex_lock(&state_lock);\n\t\terr = as->suspend_result;\n\t\tas->suspend_state = SUSPEND_NONE;\n\t\tmutex_unlock(&state_lock);\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int apm_release(struct inode * inode, struct file * filp)\n{\n\tstruct apm_user *as = filp->private_data;\n\n\tfilp->private_data = NULL;\n\n\tdown_write(&user_list_lock);\n\tlist_del(&as->list);\n\tup_write(&user_list_lock);\n\n\t \n\tmutex_lock(&state_lock);\n\tif (as->suspend_state == SUSPEND_PENDING ||\n\t    as->suspend_state == SUSPEND_READ)\n\t\tatomic_dec(&suspend_acks_pending);\n\tmutex_unlock(&state_lock);\n\n\twake_up(&apm_suspend_waitqueue);\n\n\tkfree(as);\n\treturn 0;\n}\n\nstatic int apm_open(struct inode * inode, struct file * filp)\n{\n\tstruct apm_user *as;\n\n\tas = kzalloc(sizeof(*as), GFP_KERNEL);\n\tif (as) {\n\t\t \n\t\tas->suser = capable(CAP_SYS_ADMIN);\n\t\tas->writer = (filp->f_mode & FMODE_WRITE) == FMODE_WRITE;\n\t\tas->reader = (filp->f_mode & FMODE_READ) == FMODE_READ;\n\n\t\tdown_write(&user_list_lock);\n\t\tlist_add(&as->list, &apm_user_list);\n\t\tup_write(&user_list_lock);\n\n\t\tfilp->private_data = as;\n\t}\n\n\treturn as ? 0 : -ENOMEM;\n}\n\nstatic const struct file_operations apm_bios_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.read\t\t= apm_read,\n\t.poll\t\t= apm_poll,\n\t.unlocked_ioctl\t= apm_ioctl,\n\t.open\t\t= apm_open,\n\t.release\t= apm_release,\n\t.llseek\t\t= noop_llseek,\n};\n\nstatic struct miscdevice apm_device = {\n\t.minor\t\t= APM_MINOR_DEV,\n\t.name\t\t= \"apm_bios\",\n\t.fops\t\t= &apm_bios_fops\n};\n\n\n#ifdef CONFIG_PROC_FS\n \nstatic int proc_apm_show(struct seq_file *m, void *v)\n{\n\tstruct apm_power_info info;\n\tchar *units;\n\n\tinfo.ac_line_status = 0xff;\n\tinfo.battery_status = 0xff;\n\tinfo.battery_flag   = 0xff;\n\tinfo.battery_life   = -1;\n\tinfo.time\t    = -1;\n\tinfo.units\t    = -1;\n\n\tif (apm_get_power_status)\n\t\tapm_get_power_status(&info);\n\n\tswitch (info.units) {\n\tdefault:\tunits = \"?\";\tbreak;\n\tcase 0: \tunits = \"min\";\tbreak;\n\tcase 1: \tunits = \"sec\";\tbreak;\n\t}\n\n\tseq_printf(m, \"%s 1.2 0x%02x 0x%02x 0x%02x 0x%02x %d%% %d %s\\n\",\n\t\t     driver_version, APM_32_BIT_SUPPORT,\n\t\t     info.ac_line_status, info.battery_status,\n\t\t     info.battery_flag, info.battery_life,\n\t\t     info.time, units);\n\n\treturn 0;\n}\n#endif\n\nstatic int kapmd(void *arg)\n{\n\tdo {\n\t\tapm_event_t event;\n\n\t\twait_event_interruptible(kapmd_wait,\n\t\t\t\t!queue_empty(&kapmd_queue) || kthread_should_stop());\n\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\n\t\tspin_lock_irq(&kapmd_queue_lock);\n\t\tevent = 0;\n\t\tif (!queue_empty(&kapmd_queue))\n\t\t\tevent = queue_get_event(&kapmd_queue);\n\t\tspin_unlock_irq(&kapmd_queue_lock);\n\n\t\tswitch (event) {\n\t\tcase 0:\n\t\t\tbreak;\n\n\t\tcase APM_LOW_BATTERY:\n\t\tcase APM_POWER_STATUS_CHANGE:\n\t\t\tqueue_event(event);\n\t\t\tbreak;\n\n\t\tcase APM_USER_SUSPEND:\n\t\tcase APM_SYS_SUSPEND:\n\t\t\tpm_suspend(PM_SUSPEND_MEM);\n\t\t\tbreak;\n\n\t\tcase APM_CRITICAL_SUSPEND:\n\t\t\tatomic_inc(&userspace_notification_inhibit);\n\t\t\tpm_suspend(PM_SUSPEND_MEM);\n\t\t\tatomic_dec(&userspace_notification_inhibit);\n\t\t\tbreak;\n\t\t}\n\t} while (1);\n\n\treturn 0;\n}\n\nstatic int apm_suspend_notifier(struct notifier_block *nb,\n\t\t\t\tunsigned long event,\n\t\t\t\tvoid *dummy)\n{\n\tstruct apm_user *as;\n\tint err;\n\tunsigned long apm_event;\n\n\t \n\tif (atomic_read(&userspace_notification_inhibit))\n\t\treturn NOTIFY_DONE;\n\n\tswitch (event) {\n\tcase PM_SUSPEND_PREPARE:\n\tcase PM_HIBERNATION_PREPARE:\n\t\tapm_event = (event == PM_SUSPEND_PREPARE) ?\n\t\t\tAPM_USER_SUSPEND : APM_USER_HIBERNATION;\n\t\t \n\t\tmutex_lock(&state_lock);\n\t\tdown_read(&user_list_lock);\n\n\t\tlist_for_each_entry(as, &apm_user_list, list) {\n\t\t\tif (as->suspend_state != SUSPEND_WAIT && as->reader &&\n\t\t\t    as->writer && as->suser) {\n\t\t\t\tas->suspend_state = SUSPEND_PENDING;\n\t\t\t\tatomic_inc(&suspend_acks_pending);\n\t\t\t\tqueue_add_event(&as->queue, apm_event);\n\t\t\t}\n\t\t}\n\n\t\tup_read(&user_list_lock);\n\t\tmutex_unlock(&state_lock);\n\t\twake_up_interruptible(&apm_waitqueue);\n\n\t\t \n\t\terr = wait_event_interruptible_timeout(\n\t\t\tapm_suspend_waitqueue,\n\t\t\tatomic_read(&suspend_acks_pending) == 0,\n\t\t\t5*HZ);\n\n\t\t \n\t\tif (err == 0) {\n\t\t\t \n\t\t\tmutex_lock(&state_lock);\n\t\t\tdown_read(&user_list_lock);\n\t\t\tlist_for_each_entry(as, &apm_user_list, list) {\n\t\t\t\tif (as->suspend_state == SUSPEND_PENDING ||\n\t\t\t\t    as->suspend_state == SUSPEND_READ) {\n\t\t\t\t\tas->suspend_state = SUSPEND_ACKTO;\n\t\t\t\t\tatomic_dec(&suspend_acks_pending);\n\t\t\t\t}\n\t\t\t}\n\t\t\tup_read(&user_list_lock);\n\t\t\tmutex_unlock(&state_lock);\n\t\t}\n\n\t\t \n\t\tif (err >= 0)\n\t\t\treturn NOTIFY_OK;\n\n\t\t \n\t\treturn notifier_from_errno(err);\n\n\tcase PM_POST_SUSPEND:\n\tcase PM_POST_HIBERNATION:\n\t\tapm_event = (event == PM_POST_SUSPEND) ?\n\t\t\tAPM_NORMAL_RESUME : APM_HIBERNATION_RESUME;\n\t\t \n\t\tqueue_event(apm_event);\n\n\t\t \n\t\tmutex_lock(&state_lock);\n\t\tdown_read(&user_list_lock);\n\t\tlist_for_each_entry(as, &apm_user_list, list) {\n\t\t\tif (as->suspend_state == SUSPEND_ACKED) {\n\t\t\t\t \n\t\t\t\tas->suspend_result = 0;\n\t\t\t\tas->suspend_state = SUSPEND_DONE;\n\t\t\t}\n\t\t}\n\t\tup_read(&user_list_lock);\n\t\tmutex_unlock(&state_lock);\n\n\t\twake_up(&apm_suspend_waitqueue);\n\t\treturn NOTIFY_OK;\n\n\tdefault:\n\t\treturn NOTIFY_DONE;\n\t}\n}\n\nstatic struct notifier_block apm_notif_block = {\n\t.notifier_call = apm_suspend_notifier,\n};\n\nstatic int __init apm_init(void)\n{\n\tint ret;\n\n\tif (apm_disabled) {\n\t\tprintk(KERN_NOTICE \"apm: disabled on user request.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tkapmd_tsk = kthread_create(kapmd, NULL, \"kapmd\");\n\tif (IS_ERR(kapmd_tsk)) {\n\t\tret = PTR_ERR(kapmd_tsk);\n\t\tkapmd_tsk = NULL;\n\t\tgoto out;\n\t}\n\twake_up_process(kapmd_tsk);\n\n#ifdef CONFIG_PROC_FS\n\tproc_create_single(\"apm\", 0, NULL, proc_apm_show);\n#endif\n\n\tret = misc_register(&apm_device);\n\tif (ret)\n\t\tgoto out_stop;\n\n\tret = register_pm_notifier(&apm_notif_block);\n\tif (ret)\n\t\tgoto out_unregister;\n\n\treturn 0;\n\n out_unregister:\n\tmisc_deregister(&apm_device);\n out_stop:\n\tremove_proc_entry(\"apm\", NULL);\n\tkthread_stop(kapmd_tsk);\n out:\n\treturn ret;\n}\n\nstatic void __exit apm_exit(void)\n{\n\tunregister_pm_notifier(&apm_notif_block);\n\tmisc_deregister(&apm_device);\n\tremove_proc_entry(\"apm\", NULL);\n\n\tkthread_stop(kapmd_tsk);\n}\n\nmodule_init(apm_init);\nmodule_exit(apm_exit);\n\nMODULE_AUTHOR(\"Stephen Rothwell\");\nMODULE_DESCRIPTION(\"Advanced Power Management\");\nMODULE_LICENSE(\"GPL\");\n\n#ifndef MODULE\nstatic int __init apm_setup(char *str)\n{\n\twhile ((str != NULL) && (*str != '\\0')) {\n\t\tif (strncmp(str, \"off\", 3) == 0)\n\t\t\tapm_disabled = 1;\n\t\tif (strncmp(str, \"on\", 2) == 0)\n\t\t\tapm_disabled = 0;\n\t\tstr = strchr(str, ',');\n\t\tif (str != NULL)\n\t\t\tstr += strspn(str, \", \\t\");\n\t}\n\treturn 1;\n}\n\n__setup(\"apm=\", apm_setup);\n#endif\n\n \nvoid apm_queue_event(apm_event_t event)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&kapmd_queue_lock, flags);\n\tqueue_add_event(&kapmd_queue, event);\n\tspin_unlock_irqrestore(&kapmd_queue_lock, flags);\n\n\twake_up_interruptible(&kapmd_wait);\n}\nEXPORT_SYMBOL(apm_queue_event);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}