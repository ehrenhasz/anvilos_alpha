{
  "module_name": "ipmi_si_port_io.c",
  "hash_id": "74b7264d6153bb429f273169e4eb50a63c2406b28676197d56a9b09fd20f45b6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/ipmi/ipmi_si_port_io.c",
  "human_readable_source": "\n\n#include <linux/io.h>\n#include \"ipmi_si.h\"\n\nstatic unsigned char port_inb(const struct si_sm_io *io, unsigned int offset)\n{\n\tunsigned int addr = io->addr_data;\n\n\treturn inb(addr + (offset * io->regspacing));\n}\n\nstatic void port_outb(const struct si_sm_io *io, unsigned int offset,\n\t\t      unsigned char b)\n{\n\tunsigned int addr = io->addr_data;\n\n\toutb(b, addr + (offset * io->regspacing));\n}\n\nstatic unsigned char port_inw(const struct si_sm_io *io, unsigned int offset)\n{\n\tunsigned int addr = io->addr_data;\n\n\treturn (inw(addr + (offset * io->regspacing)) >> io->regshift) & 0xff;\n}\n\nstatic void port_outw(const struct si_sm_io *io, unsigned int offset,\n\t\t      unsigned char b)\n{\n\tunsigned int addr = io->addr_data;\n\n\toutw(b << io->regshift, addr + (offset * io->regspacing));\n}\n\nstatic unsigned char port_inl(const struct si_sm_io *io, unsigned int offset)\n{\n\tunsigned int addr = io->addr_data;\n\n\treturn (inl(addr + (offset * io->regspacing)) >> io->regshift) & 0xff;\n}\n\nstatic void port_outl(const struct si_sm_io *io, unsigned int offset,\n\t\t      unsigned char b)\n{\n\tunsigned int addr = io->addr_data;\n\n\toutl(b << io->regshift, addr+(offset * io->regspacing));\n}\n\nstatic void port_cleanup(struct si_sm_io *io)\n{\n\tunsigned int addr = io->addr_data;\n\tint          idx;\n\n\tif (addr) {\n\t\tfor (idx = 0; idx < io->io_size; idx++)\n\t\t\trelease_region(addr + idx * io->regspacing,\n\t\t\t\t       io->regsize);\n\t}\n}\n\nint ipmi_si_port_setup(struct si_sm_io *io)\n{\n\tunsigned int addr = io->addr_data;\n\tint          idx;\n\n\tif (!addr)\n\t\treturn -ENODEV;\n\n\t \n\tswitch (io->regsize) {\n\tcase 1:\n\t\tio->inputb = port_inb;\n\t\tio->outputb = port_outb;\n\t\tbreak;\n\tcase 2:\n\t\tio->inputb = port_inw;\n\t\tio->outputb = port_outw;\n\t\tbreak;\n\tcase 4:\n\t\tio->inputb = port_inl;\n\t\tio->outputb = port_outl;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(io->dev, \"Invalid register size: %d\\n\",\n\t\t\t io->regsize);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor (idx = 0; idx < io->io_size; idx++) {\n\t\tif (request_region(addr + idx * io->regspacing,\n\t\t\t\t   io->regsize, SI_DEVICE_NAME) == NULL) {\n\t\t\t \n\t\t\twhile (idx--)\n\t\t\t\trelease_region(addr + idx * io->regspacing,\n\t\t\t\t\t       io->regsize);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tio->io_cleanup = port_cleanup;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}