{
  "module_name": "ipmi_smic_sm.c",
  "hash_id": "cda6f255583d6c9091de50d7485dbe9da6237a00feac6491d79ed88e99d86006",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/ipmi/ipmi_smic_sm.c",
  "human_readable_source": "\n \n\n#define DEBUG  \n\n#include <linux/kernel.h>  \n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/ipmi_msgdefs.h>\t\t \n#include \"ipmi_si_sm.h\"\n\n \n#define SMIC_DEBUG_STATES\t4\n#define SMIC_DEBUG_MSG\t\t2\n#define\tSMIC_DEBUG_ENABLE\t1\n\nstatic int smic_debug = 1;\nmodule_param(smic_debug, int, 0644);\nMODULE_PARM_DESC(smic_debug, \"debug bitmask, 1=enable, 2=messages, 4=states\");\n\nenum smic_states {\n\tSMIC_IDLE,\n\tSMIC_START_OP,\n\tSMIC_OP_OK,\n\tSMIC_WRITE_START,\n\tSMIC_WRITE_NEXT,\n\tSMIC_WRITE_END,\n\tSMIC_WRITE2READ,\n\tSMIC_READ_START,\n\tSMIC_READ_NEXT,\n\tSMIC_READ_END,\n\tSMIC_HOSED\n};\n\n#define MAX_SMIC_READ_SIZE 80\n#define MAX_SMIC_WRITE_SIZE 80\n#define SMIC_MAX_ERROR_RETRIES 3\n\n \n#define SMIC_RETRY_TIMEOUT (2*USEC_PER_SEC)\n\n \n#define SMIC_RX_DATA_READY\t0x80\n#define SMIC_TX_DATA_READY\t0x40\n\n \n#define SMIC_SMI\t\t0x10\n#define SMIC_EVM_DATA_AVAIL\t0x08\n#define SMIC_SMS_DATA_AVAIL\t0x04\n#define SMIC_FLAG_BSY\t\t0x01\n\n \n#define\tEC_NO_ERROR\t\t0x00\n#define\tEC_ABORTED\t\t0x01\n#define\tEC_ILLEGAL_CONTROL\t0x02\n#define\tEC_NO_RESPONSE\t\t0x03\n#define\tEC_ILLEGAL_COMMAND\t0x04\n#define\tEC_BUFFER_FULL\t\t0x05\n\nstruct si_sm_data {\n\tenum smic_states state;\n\tstruct si_sm_io *io;\n\tunsigned char\t write_data[MAX_SMIC_WRITE_SIZE];\n\tint\t\t write_pos;\n\tint\t\t write_count;\n\tint\t\t orig_write_count;\n\tunsigned char\t read_data[MAX_SMIC_READ_SIZE];\n\tint\t\t read_pos;\n\tint\t\t truncated;\n\tunsigned int\t error_retries;\n\tlong\t\t smic_timeout;\n};\n\nstatic unsigned int init_smic_data(struct si_sm_data *smic,\n\t\t\t\t   struct si_sm_io *io)\n{\n\tsmic->state = SMIC_IDLE;\n\tsmic->io = io;\n\tsmic->write_pos = 0;\n\tsmic->write_count = 0;\n\tsmic->orig_write_count = 0;\n\tsmic->read_pos = 0;\n\tsmic->error_retries = 0;\n\tsmic->truncated = 0;\n\tsmic->smic_timeout = SMIC_RETRY_TIMEOUT;\n\n\t \n\treturn 3;\n}\n\nstatic int start_smic_transaction(struct si_sm_data *smic,\n\t\t\t\t  unsigned char *data, unsigned int size)\n{\n\tunsigned int i;\n\n\tif (size < 2)\n\t\treturn IPMI_REQ_LEN_INVALID_ERR;\n\tif (size > MAX_SMIC_WRITE_SIZE)\n\t\treturn IPMI_REQ_LEN_EXCEEDED_ERR;\n\n\tif ((smic->state != SMIC_IDLE) && (smic->state != SMIC_HOSED)) {\n\t\tdev_warn(smic->io->dev,\n\t\t\t \"SMIC in invalid state %d\\n\", smic->state);\n\t\treturn IPMI_NOT_IN_MY_STATE_ERR;\n\t}\n\n\tif (smic_debug & SMIC_DEBUG_MSG) {\n\t\tdev_dbg(smic->io->dev, \"%s -\", __func__);\n\t\tfor (i = 0; i < size; i++)\n\t\t\tpr_cont(\" %02x\", data[i]);\n\t\tpr_cont(\"\\n\");\n\t}\n\tsmic->error_retries = 0;\n\tmemcpy(smic->write_data, data, size);\n\tsmic->write_count = size;\n\tsmic->orig_write_count = size;\n\tsmic->write_pos = 0;\n\tsmic->read_pos = 0;\n\tsmic->state = SMIC_START_OP;\n\tsmic->smic_timeout = SMIC_RETRY_TIMEOUT;\n\treturn 0;\n}\n\nstatic int smic_get_result(struct si_sm_data *smic,\n\t\t\t   unsigned char *data, unsigned int length)\n{\n\tint i;\n\n\tif (smic_debug & SMIC_DEBUG_MSG) {\n\t\tdev_dbg(smic->io->dev, \"smic_get result -\");\n\t\tfor (i = 0; i < smic->read_pos; i++)\n\t\t\tpr_cont(\" %02x\", smic->read_data[i]);\n\t\tpr_cont(\"\\n\");\n\t}\n\tif (length < smic->read_pos) {\n\t\tsmic->read_pos = length;\n\t\tsmic->truncated = 1;\n\t}\n\tmemcpy(data, smic->read_data, smic->read_pos);\n\n\tif ((length >= 3) && (smic->read_pos < 3)) {\n\t\tdata[2] = IPMI_ERR_UNSPECIFIED;\n\t\tsmic->read_pos = 3;\n\t}\n\tif (smic->truncated) {\n\t\tdata[2] = IPMI_ERR_MSG_TRUNCATED;\n\t\tsmic->truncated = 0;\n\t}\n\treturn smic->read_pos;\n}\n\nstatic inline unsigned char read_smic_flags(struct si_sm_data *smic)\n{\n\treturn smic->io->inputb(smic->io, 2);\n}\n\nstatic inline unsigned char read_smic_status(struct si_sm_data *smic)\n{\n\treturn smic->io->inputb(smic->io, 1);\n}\n\nstatic inline unsigned char read_smic_data(struct si_sm_data *smic)\n{\n\treturn smic->io->inputb(smic->io, 0);\n}\n\nstatic inline void write_smic_flags(struct si_sm_data *smic,\n\t\t\t\t    unsigned char   flags)\n{\n\tsmic->io->outputb(smic->io, 2, flags);\n}\n\nstatic inline void write_smic_control(struct si_sm_data *smic,\n\t\t\t\t      unsigned char   control)\n{\n\tsmic->io->outputb(smic->io, 1, control);\n}\n\nstatic inline void write_si_sm_data(struct si_sm_data *smic,\n\t\t\t\t    unsigned char   data)\n{\n\tsmic->io->outputb(smic->io, 0, data);\n}\n\nstatic inline void start_error_recovery(struct si_sm_data *smic, char *reason)\n{\n\t(smic->error_retries)++;\n\tif (smic->error_retries > SMIC_MAX_ERROR_RETRIES) {\n\t\tif (smic_debug & SMIC_DEBUG_ENABLE)\n\t\t\tpr_warn(\"ipmi_smic_drv: smic hosed: %s\\n\", reason);\n\t\tsmic->state = SMIC_HOSED;\n\t} else {\n\t\tsmic->write_count = smic->orig_write_count;\n\t\tsmic->write_pos = 0;\n\t\tsmic->read_pos = 0;\n\t\tsmic->state = SMIC_START_OP;\n\t\tsmic->smic_timeout = SMIC_RETRY_TIMEOUT;\n\t}\n}\n\nstatic inline void write_next_byte(struct si_sm_data *smic)\n{\n\twrite_si_sm_data(smic, smic->write_data[smic->write_pos]);\n\t(smic->write_pos)++;\n\t(smic->write_count)--;\n}\n\nstatic inline void read_next_byte(struct si_sm_data *smic)\n{\n\tif (smic->read_pos >= MAX_SMIC_READ_SIZE) {\n\t\tread_smic_data(smic);\n\t\tsmic->truncated = 1;\n\t} else {\n\t\tsmic->read_data[smic->read_pos] = read_smic_data(smic);\n\t\tsmic->read_pos++;\n\t}\n}\n\n \n#define\tSMIC_GET_STATUS\t\t0x00\t \n#define\tSMIC_READY\t\t0x00\t \n#define\tSMIC_WR_START\t\t0x01\t \n#define\tSMIC_WR_NEXT\t\t0x02\n#define\tSMIC_WR_END\t\t0x03\n#define\tSMIC_RD_START\t\t0x04\n#define\tSMIC_RD_NEXT\t\t0x05\n#define\tSMIC_RD_END\t\t0x06\n#define\tSMIC_CODE_MASK\t\t0x0f\n\n#define\tSMIC_CONTROL\t\t0x00\n#define\tSMIC_STATUS\t\t0x80\n#define\tSMIC_CS_MASK\t\t0x80\n\n#define\tSMIC_SMS\t\t0x40\n#define\tSMIC_SMM\t\t0x60\n#define\tSMIC_STREAM_MASK\t0x60\n\n \n#define\tSMIC_CC_SMS_GET_STATUS\t(SMIC_CONTROL|SMIC_SMS|SMIC_GET_STATUS)\n#define\tSMIC_CC_SMS_WR_START\t(SMIC_CONTROL|SMIC_SMS|SMIC_WR_START)\n#define\tSMIC_CC_SMS_WR_NEXT\t(SMIC_CONTROL|SMIC_SMS|SMIC_WR_NEXT)\n#define\tSMIC_CC_SMS_WR_END\t(SMIC_CONTROL|SMIC_SMS|SMIC_WR_END)\n#define\tSMIC_CC_SMS_RD_START\t(SMIC_CONTROL|SMIC_SMS|SMIC_RD_START)\n#define\tSMIC_CC_SMS_RD_NEXT\t(SMIC_CONTROL|SMIC_SMS|SMIC_RD_NEXT)\n#define\tSMIC_CC_SMS_RD_END\t(SMIC_CONTROL|SMIC_SMS|SMIC_RD_END)\n\n#define\tSMIC_CC_SMM_GET_STATUS\t(SMIC_CONTROL|SMIC_SMM|SMIC_GET_STATUS)\n#define\tSMIC_CC_SMM_WR_START\t(SMIC_CONTROL|SMIC_SMM|SMIC_WR_START)\n#define\tSMIC_CC_SMM_WR_NEXT\t(SMIC_CONTROL|SMIC_SMM|SMIC_WR_NEXT)\n#define\tSMIC_CC_SMM_WR_END\t(SMIC_CONTROL|SMIC_SMM|SMIC_WR_END)\n#define\tSMIC_CC_SMM_RD_START\t(SMIC_CONTROL|SMIC_SMM|SMIC_RD_START)\n#define\tSMIC_CC_SMM_RD_NEXT\t(SMIC_CONTROL|SMIC_SMM|SMIC_RD_NEXT)\n#define\tSMIC_CC_SMM_RD_END\t(SMIC_CONTROL|SMIC_SMM|SMIC_RD_END)\n\n \n#define\tSMIC_SC_SMS_READY\t(SMIC_STATUS|SMIC_SMS|SMIC_READY)\n#define\tSMIC_SC_SMS_WR_START\t(SMIC_STATUS|SMIC_SMS|SMIC_WR_START)\n#define\tSMIC_SC_SMS_WR_NEXT\t(SMIC_STATUS|SMIC_SMS|SMIC_WR_NEXT)\n#define\tSMIC_SC_SMS_WR_END\t(SMIC_STATUS|SMIC_SMS|SMIC_WR_END)\n#define\tSMIC_SC_SMS_RD_START\t(SMIC_STATUS|SMIC_SMS|SMIC_RD_START)\n#define\tSMIC_SC_SMS_RD_NEXT\t(SMIC_STATUS|SMIC_SMS|SMIC_RD_NEXT)\n#define\tSMIC_SC_SMS_RD_END\t(SMIC_STATUS|SMIC_SMS|SMIC_RD_END)\n\n#define\tSMIC_SC_SMM_READY\t(SMIC_STATUS|SMIC_SMM|SMIC_READY)\n#define\tSMIC_SC_SMM_WR_START\t(SMIC_STATUS|SMIC_SMM|SMIC_WR_START)\n#define\tSMIC_SC_SMM_WR_NEXT\t(SMIC_STATUS|SMIC_SMM|SMIC_WR_NEXT)\n#define\tSMIC_SC_SMM_WR_END\t(SMIC_STATUS|SMIC_SMM|SMIC_WR_END)\n#define\tSMIC_SC_SMM_RD_START\t(SMIC_STATUS|SMIC_SMM|SMIC_RD_START)\n#define\tSMIC_SC_SMM_RD_NEXT\t(SMIC_STATUS|SMIC_SMM|SMIC_RD_NEXT)\n#define\tSMIC_SC_SMM_RD_END\t(SMIC_STATUS|SMIC_SMM|SMIC_RD_END)\n\n \n\nstatic enum si_sm_result smic_event(struct si_sm_data *smic, long time)\n{\n\tunsigned char status;\n\tunsigned char flags;\n\tunsigned char data;\n\n\tif (smic->state == SMIC_HOSED) {\n\t\tinit_smic_data(smic, smic->io);\n\t\treturn SI_SM_HOSED;\n\t}\n\tif (smic->state != SMIC_IDLE) {\n\t\tif (smic_debug & SMIC_DEBUG_STATES)\n\t\t\tdev_dbg(smic->io->dev,\n\t\t\t\t\"%s - smic->smic_timeout = %ld, time = %ld\\n\",\n\t\t\t\t__func__, smic->smic_timeout, time);\n\t\t \n\t\tif (time < SMIC_RETRY_TIMEOUT) {\n\t\t\tsmic->smic_timeout -= time;\n\t\t\tif (smic->smic_timeout < 0) {\n\t\t\t\tstart_error_recovery(smic, \"smic timed out.\");\n\t\t\t\treturn SI_SM_CALL_WITH_DELAY;\n\t\t\t}\n\t\t}\n\t}\n\tflags = read_smic_flags(smic);\n\tif (flags & SMIC_FLAG_BSY)\n\t\treturn SI_SM_CALL_WITH_DELAY;\n\n\tstatus = read_smic_status(smic);\n\tif (smic_debug & SMIC_DEBUG_STATES)\n\t\tdev_dbg(smic->io->dev,\n\t\t\t\"%s - state = %d, flags = 0x%02x, status = 0x%02x\\n\",\n\t\t\t__func__, smic->state, flags, status);\n\n\tswitch (smic->state) {\n\tcase SMIC_IDLE:\n\t\t \n\t\tif (flags & SMIC_SMS_DATA_AVAIL)\n\t\t\treturn SI_SM_ATTN;\n\t\treturn SI_SM_IDLE;\n\n\tcase SMIC_START_OP:\n\t\t \n\t\twrite_smic_control(smic, SMIC_CC_SMS_GET_STATUS);\n\t\twrite_smic_flags(smic, flags | SMIC_FLAG_BSY);\n\t\tsmic->state = SMIC_OP_OK;\n\t\tbreak;\n\n\tcase SMIC_OP_OK:\n\t\tif (status != SMIC_SC_SMS_READY) {\n\t\t\t \n\t\t\tstart_error_recovery(smic,\n\t\t\t\t\t     \"state = SMIC_OP_OK,\"\n\t\t\t\t\t     \" status != SMIC_SC_SMS_READY\");\n\t\t\treturn SI_SM_CALL_WITH_DELAY;\n\t\t}\n\t\t \n\t\twrite_smic_control(smic, SMIC_CC_SMS_WR_START);\n\t\twrite_next_byte(smic);\n\t\twrite_smic_flags(smic, flags | SMIC_FLAG_BSY);\n\t\tsmic->state = SMIC_WRITE_START;\n\t\tbreak;\n\n\tcase SMIC_WRITE_START:\n\t\tif (status != SMIC_SC_SMS_WR_START) {\n\t\t\tstart_error_recovery(smic,\n\t\t\t\t\t     \"state = SMIC_WRITE_START, \"\n\t\t\t\t\t     \"status != SMIC_SC_SMS_WR_START\");\n\t\t\treturn SI_SM_CALL_WITH_DELAY;\n\t\t}\n\t\t \n\t\tif (flags & SMIC_TX_DATA_READY) {\n\t\t\tif (smic->write_count == 1) {\n\t\t\t\t \n\t\t\t\twrite_smic_control(smic, SMIC_CC_SMS_WR_END);\n\t\t\t\tsmic->state = SMIC_WRITE_END;\n\t\t\t} else {\n\t\t\t\twrite_smic_control(smic, SMIC_CC_SMS_WR_NEXT);\n\t\t\t\tsmic->state = SMIC_WRITE_NEXT;\n\t\t\t}\n\t\t\twrite_next_byte(smic);\n\t\t\twrite_smic_flags(smic, flags | SMIC_FLAG_BSY);\n\t\t} else\n\t\t\treturn SI_SM_CALL_WITH_DELAY;\n\t\tbreak;\n\n\tcase SMIC_WRITE_NEXT:\n\t\tif (status != SMIC_SC_SMS_WR_NEXT) {\n\t\t\tstart_error_recovery(smic,\n\t\t\t\t\t     \"state = SMIC_WRITE_NEXT, \"\n\t\t\t\t\t     \"status != SMIC_SC_SMS_WR_NEXT\");\n\t\t\treturn SI_SM_CALL_WITH_DELAY;\n\t\t}\n\t\t \n\t\tif (flags & SMIC_TX_DATA_READY) {\n\t\t\tif (smic->write_count == 1) {\n\t\t\t\twrite_smic_control(smic, SMIC_CC_SMS_WR_END);\n\t\t\t\tsmic->state = SMIC_WRITE_END;\n\t\t\t} else {\n\t\t\t\twrite_smic_control(smic, SMIC_CC_SMS_WR_NEXT);\n\t\t\t\tsmic->state = SMIC_WRITE_NEXT;\n\t\t\t}\n\t\t\twrite_next_byte(smic);\n\t\t\twrite_smic_flags(smic, flags | SMIC_FLAG_BSY);\n\t\t} else\n\t\t\treturn SI_SM_CALL_WITH_DELAY;\n\t\tbreak;\n\n\tcase SMIC_WRITE_END:\n\t\tif (status != SMIC_SC_SMS_WR_END) {\n\t\t\tstart_error_recovery(smic,\n\t\t\t\t\t     \"state = SMIC_WRITE_END, \"\n\t\t\t\t\t     \"status != SMIC_SC_SMS_WR_END\");\n\t\t\treturn SI_SM_CALL_WITH_DELAY;\n\t\t}\n\t\t \n\t\tdata = read_smic_data(smic);\n\t\tif (data != 0) {\n\t\t\tif (smic_debug & SMIC_DEBUG_ENABLE)\n\t\t\t\tdev_dbg(smic->io->dev,\n\t\t\t\t\t\"SMIC_WRITE_END: data = %02x\\n\",\n\t\t\t\t\tdata);\n\t\t\tstart_error_recovery(smic,\n\t\t\t\t\t     \"state = SMIC_WRITE_END, \"\n\t\t\t\t\t     \"data != SUCCESS\");\n\t\t\treturn SI_SM_CALL_WITH_DELAY;\n\t\t} else\n\t\t\tsmic->state = SMIC_WRITE2READ;\n\t\tbreak;\n\n\tcase SMIC_WRITE2READ:\n\t\t \n\t\tif (flags & SMIC_RX_DATA_READY) {\n\t\t\twrite_smic_control(smic, SMIC_CC_SMS_RD_START);\n\t\t\twrite_smic_flags(smic, flags | SMIC_FLAG_BSY);\n\t\t\tsmic->state = SMIC_READ_START;\n\t\t} else\n\t\t\treturn SI_SM_CALL_WITH_DELAY;\n\t\tbreak;\n\n\tcase SMIC_READ_START:\n\t\tif (status != SMIC_SC_SMS_RD_START) {\n\t\t\tstart_error_recovery(smic,\n\t\t\t\t\t     \"state = SMIC_READ_START, \"\n\t\t\t\t\t     \"status != SMIC_SC_SMS_RD_START\");\n\t\t\treturn SI_SM_CALL_WITH_DELAY;\n\t\t}\n\t\tif (flags & SMIC_RX_DATA_READY) {\n\t\t\tread_next_byte(smic);\n\t\t\twrite_smic_control(smic, SMIC_CC_SMS_RD_NEXT);\n\t\t\twrite_smic_flags(smic, flags | SMIC_FLAG_BSY);\n\t\t\tsmic->state = SMIC_READ_NEXT;\n\t\t} else\n\t\t\treturn SI_SM_CALL_WITH_DELAY;\n\t\tbreak;\n\n\tcase SMIC_READ_NEXT:\n\t\tswitch (status) {\n\t\t \n\t\tcase SMIC_SC_SMS_RD_END:\n\t\t\tread_next_byte(smic);\n\t\t\twrite_smic_control(smic, SMIC_CC_SMS_RD_END);\n\t\t\twrite_smic_flags(smic, flags | SMIC_FLAG_BSY);\n\t\t\tsmic->state = SMIC_READ_END;\n\t\t\tbreak;\n\t\tcase SMIC_SC_SMS_RD_NEXT:\n\t\t\tif (flags & SMIC_RX_DATA_READY) {\n\t\t\t\tread_next_byte(smic);\n\t\t\t\twrite_smic_control(smic, SMIC_CC_SMS_RD_NEXT);\n\t\t\t\twrite_smic_flags(smic, flags | SMIC_FLAG_BSY);\n\t\t\t\tsmic->state = SMIC_READ_NEXT;\n\t\t\t} else\n\t\t\t\treturn SI_SM_CALL_WITH_DELAY;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstart_error_recovery(\n\t\t\t\tsmic,\n\t\t\t\t\"state = SMIC_READ_NEXT, \"\n\t\t\t\t\"status != SMIC_SC_SMS_RD_(NEXT|END)\");\n\t\t\treturn SI_SM_CALL_WITH_DELAY;\n\t\t}\n\t\tbreak;\n\n\tcase SMIC_READ_END:\n\t\tif (status != SMIC_SC_SMS_READY) {\n\t\t\tstart_error_recovery(smic,\n\t\t\t\t\t     \"state = SMIC_READ_END, \"\n\t\t\t\t\t     \"status != SMIC_SC_SMS_READY\");\n\t\t\treturn SI_SM_CALL_WITH_DELAY;\n\t\t}\n\t\tdata = read_smic_data(smic);\n\t\t \n\t\tif (data != 0) {\n\t\t\tif (smic_debug & SMIC_DEBUG_ENABLE)\n\t\t\t\tdev_dbg(smic->io->dev,\n\t\t\t\t\t\"SMIC_READ_END: data = %02x\\n\",\n\t\t\t\t\tdata);\n\t\t\tstart_error_recovery(smic,\n\t\t\t\t\t     \"state = SMIC_READ_END, \"\n\t\t\t\t\t     \"data != SUCCESS\");\n\t\t\treturn SI_SM_CALL_WITH_DELAY;\n\t\t} else {\n\t\t\tsmic->state = SMIC_IDLE;\n\t\t\treturn SI_SM_TRANSACTION_COMPLETE;\n\t\t}\n\n\tcase SMIC_HOSED:\n\t\tinit_smic_data(smic, smic->io);\n\t\treturn SI_SM_HOSED;\n\n\tdefault:\n\t\tif (smic_debug & SMIC_DEBUG_ENABLE) {\n\t\t\tdev_dbg(smic->io->dev,\n\t\t\t\t\"smic->state = %d\\n\", smic->state);\n\t\t\tstart_error_recovery(smic, \"state = UNKNOWN\");\n\t\t\treturn SI_SM_CALL_WITH_DELAY;\n\t\t}\n\t}\n\tsmic->smic_timeout = SMIC_RETRY_TIMEOUT;\n\treturn SI_SM_CALL_WITHOUT_DELAY;\n}\n\nstatic int smic_detect(struct si_sm_data *smic)\n{\n\t \n\tif (read_smic_flags(smic) == 0xff)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic void smic_cleanup(struct si_sm_data *kcs)\n{\n}\n\nstatic int smic_size(void)\n{\n\treturn sizeof(struct si_sm_data);\n}\n\nconst struct si_sm_handlers smic_smi_handlers = {\n\t.init_data         = init_smic_data,\n\t.start_transaction = start_smic_transaction,\n\t.get_result        = smic_get_result,\n\t.event             = smic_event,\n\t.detect            = smic_detect,\n\t.cleanup           = smic_cleanup,\n\t.size              = smic_size,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}