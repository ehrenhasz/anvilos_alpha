{
  "module_name": "ipmi_ssif.c",
  "hash_id": "0d892c488bffee0bfb8f38f60368e185368b8776c9aae215aaaf695230c62060",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/ipmi/ipmi_ssif.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) \"ipmi_ssif: \" fmt\n#define dev_fmt(fmt) \"ipmi_ssif: \" fmt\n\n#if defined(MODVERSIONS)\n#include <linux/modversions.h>\n#endif\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/sched.h>\n#include <linux/seq_file.h>\n#include <linux/timer.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/i2c.h>\n#include <linux/ipmi_smi.h>\n#include <linux/init.h>\n#include <linux/dmi.h>\n#include <linux/kthread.h>\n#include <linux/acpi.h>\n#include <linux/ctype.h>\n#include <linux/time64.h>\n#include \"ipmi_dmi.h\"\n\n#define DEVICE_NAME \"ipmi_ssif\"\n\n#define IPMI_GET_SYSTEM_INTERFACE_CAPABILITIES_CMD\t0x57\n\n#define\tSSIF_IPMI_REQUEST\t\t\t2\n#define\tSSIF_IPMI_MULTI_PART_REQUEST_START\t6\n#define\tSSIF_IPMI_MULTI_PART_REQUEST_MIDDLE\t7\n#define\tSSIF_IPMI_MULTI_PART_REQUEST_END\t8\n#define\tSSIF_IPMI_RESPONSE\t\t\t3\n#define\tSSIF_IPMI_MULTI_PART_RESPONSE_MIDDLE\t9\n\n \n#define SSIF_DEBUG_TIMING\t4\n#define SSIF_DEBUG_STATE\t2\n#define SSIF_DEBUG_MSG\t\t1\n#define SSIF_NODEBUG\t\t0\n#define SSIF_DEFAULT_DEBUG\t(SSIF_NODEBUG)\n\n \n#define SSIF_MSG_USEC\t\t60000\t \n#define SSIF_REQ_RETRY_USEC\t60000\t \n#define SSIF_MSG_PART_USEC\t5000\t \n\n \n#define\tSSIF_SEND_RETRIES\t5\n#define\tSSIF_RECV_RETRIES\t250\n\n#define SSIF_MSG_MSEC\t\t(SSIF_MSG_USEC / 1000)\n#define SSIF_REQ_RETRY_MSEC\t(SSIF_REQ_RETRY_USEC / 1000)\n#define SSIF_MSG_JIFFIES\t((SSIF_MSG_USEC * 1000) / TICK_NSEC)\n#define SSIF_REQ_RETRY_JIFFIES\t((SSIF_REQ_RETRY_USEC * 1000) / TICK_NSEC)\n#define SSIF_MSG_PART_JIFFIES\t((SSIF_MSG_PART_USEC * 1000) / TICK_NSEC)\n\n \n#define SSIF_WATCH_MSG_TIMEOUT\t\tmsecs_to_jiffies(10)\n#define SSIF_WATCH_WATCHDOG_TIMEOUT\tmsecs_to_jiffies(250)\n\nenum ssif_intf_state {\n\tSSIF_IDLE,\n\tSSIF_GETTING_FLAGS,\n\tSSIF_GETTING_EVENTS,\n\tSSIF_CLEARING_FLAGS,\n\tSSIF_GETTING_MESSAGES,\n\t \n};\n\n#define IS_SSIF_IDLE(ssif) ((ssif)->ssif_state == SSIF_IDLE \\\n\t\t\t    && (ssif)->curr_msg == NULL)\n\n \nenum ssif_stat_indexes {\n\t \n\tSSIF_STAT_sent_messages = 0,\n\n\t \n\tSSIF_STAT_sent_messages_parts,\n\n\t \n\tSSIF_STAT_send_retries,\n\n\t \n\tSSIF_STAT_send_errors,\n\n\t \n\tSSIF_STAT_received_messages,\n\n\t \n\tSSIF_STAT_received_message_parts,\n\n\t \n\tSSIF_STAT_receive_retries,\n\n\t \n\tSSIF_STAT_receive_errors,\n\n\t \n\tSSIF_STAT_flag_fetches,\n\n\t \n\tSSIF_STAT_hosed,\n\n\t \n\tSSIF_STAT_events,\n\n\t \n\tSSIF_STAT_incoming_messages,\n\n\t \n\tSSIF_STAT_watchdog_pretimeouts,\n\n\t \n\tSSIF_STAT_alerts,\n\n\t \n\tSSIF_NUM_STATS\n};\n\nstruct ssif_addr_info {\n\tstruct i2c_board_info binfo;\n\tchar *adapter_name;\n\tint debug;\n\tint slave_addr;\n\tenum ipmi_addr_src addr_src;\n\tunion ipmi_smi_info_union addr_info;\n\tstruct device *dev;\n\tstruct i2c_client *client;\n\n\tstruct mutex clients_mutex;\n\tstruct list_head clients;\n\n\tstruct list_head link;\n};\n\nstruct ssif_info;\n\ntypedef void (*ssif_i2c_done)(struct ssif_info *ssif_info, int result,\n\t\t\t     unsigned char *data, unsigned int len);\n\nstruct ssif_info {\n\tstruct ipmi_smi     *intf;\n\tspinlock_t\t    lock;\n\tstruct ipmi_smi_msg *waiting_msg;\n\tstruct ipmi_smi_msg *curr_msg;\n\tenum ssif_intf_state ssif_state;\n\tunsigned long       ssif_debug;\n\n\tstruct ipmi_smi_handlers handlers;\n\n\tenum ipmi_addr_src addr_source;  \n\tunion ipmi_smi_info_union addr_info;\n\n\t \n#define RECEIVE_MSG_AVAIL\t0x01\n#define EVENT_MSG_BUFFER_FULL\t0x02\n#define WDT_PRE_TIMEOUT_INT\t0x08\n\tunsigned char       msg_flags;\n\n\tu8\t\t    global_enables;\n\tbool\t\t    has_event_buffer;\n\tbool\t\t    supports_alert;\n\n\t \n\tbool\t\t    got_alert;\n\tbool\t\t    waiting_alert;\n\n\t \n\tbool\t\t    do_resend;\n\n\t \n\tbool                req_events;\n\n\t \n\tbool                req_flags;\n\n\t \n\tunsigned char data[IPMI_MAX_MSG_LENGTH + 1];\n\tunsigned int  data_len;\n\n\t \n\tunsigned char recv[I2C_SMBUS_BLOCK_MAX];\n\n\tstruct i2c_client *client;\n\tssif_i2c_done done_handler;\n\n\t \n\tstruct task_struct *thread;\n\tstruct completion wake_thread;\n\tbool stopping;\n\tint i2c_read_write;\n\tint i2c_command;\n\tunsigned char *i2c_data;\n\tunsigned int i2c_size;\n\n\tstruct timer_list retry_timer;\n\tint retries_left;\n\n\tlong watch_timeout;\t\t \n\tstruct timer_list watch_timer;\t \n\n\t \n\tunsigned char max_xmit_msg_size;\n\tunsigned char max_recv_msg_size;\n\tbool cmd8_works;  \n\tunsigned int  multi_support;\n\tint           supports_pec;\n\n#define SSIF_NO_MULTI\t\t0\n#define SSIF_MULTI_2_PART\t1\n#define SSIF_MULTI_n_PART\t2\n\tunsigned char *multi_data;\n\tunsigned int  multi_len;\n\tunsigned int  multi_pos;\n\n\tatomic_t stats[SSIF_NUM_STATS];\n};\n\n#define ssif_inc_stat(ssif, stat) \\\n\tatomic_inc(&(ssif)->stats[SSIF_STAT_ ## stat])\n#define ssif_get_stat(ssif, stat) \\\n\t((unsigned int) atomic_read(&(ssif)->stats[SSIF_STAT_ ## stat]))\n\nstatic bool initialized;\nstatic bool platform_registered;\n\nstatic void return_hosed_msg(struct ssif_info *ssif_info,\n\t\t\t     struct ipmi_smi_msg *msg);\nstatic void start_next_msg(struct ssif_info *ssif_info, unsigned long *flags);\nstatic int start_send(struct ssif_info *ssif_info,\n\t\t      unsigned char   *data,\n\t\t      unsigned int    len);\n\nstatic unsigned long *ipmi_ssif_lock_cond(struct ssif_info *ssif_info,\n\t\t\t\t\t  unsigned long *flags)\n\t__acquires(&ssif_info->lock)\n{\n\tspin_lock_irqsave(&ssif_info->lock, *flags);\n\treturn flags;\n}\n\nstatic void ipmi_ssif_unlock_cond(struct ssif_info *ssif_info,\n\t\t\t\t  unsigned long *flags)\n\t__releases(&ssif_info->lock)\n{\n\tspin_unlock_irqrestore(&ssif_info->lock, *flags);\n}\n\nstatic void deliver_recv_msg(struct ssif_info *ssif_info,\n\t\t\t     struct ipmi_smi_msg *msg)\n{\n\tif (msg->rsp_size < 0) {\n\t\treturn_hosed_msg(ssif_info, msg);\n\t\tdev_err(&ssif_info->client->dev,\n\t\t\t\"%s: Malformed message: rsp_size = %d\\n\",\n\t\t       __func__, msg->rsp_size);\n\t} else {\n\t\tipmi_smi_msg_received(ssif_info->intf, msg);\n\t}\n}\n\nstatic void return_hosed_msg(struct ssif_info *ssif_info,\n\t\t\t     struct ipmi_smi_msg *msg)\n{\n\tssif_inc_stat(ssif_info, hosed);\n\n\t \n\tmsg->rsp[0] = msg->data[0] | 4;\n\tmsg->rsp[1] = msg->data[1];\n\tmsg->rsp[2] = 0xFF;  \n\tmsg->rsp_size = 3;\n\n\tdeliver_recv_msg(ssif_info, msg);\n}\n\n \nstatic void start_clear_flags(struct ssif_info *ssif_info, unsigned long *flags)\n{\n\tunsigned char msg[3];\n\n\tssif_info->msg_flags &= ~WDT_PRE_TIMEOUT_INT;\n\tssif_info->ssif_state = SSIF_CLEARING_FLAGS;\n\tipmi_ssif_unlock_cond(ssif_info, flags);\n\n\t \n\tmsg[0] = (IPMI_NETFN_APP_REQUEST << 2);\n\tmsg[1] = IPMI_CLEAR_MSG_FLAGS_CMD;\n\tmsg[2] = WDT_PRE_TIMEOUT_INT;\n\n\tif (start_send(ssif_info, msg, 3) != 0) {\n\t\t \n\t\tssif_info->ssif_state = SSIF_IDLE;\n\t}\n}\n\nstatic void start_flag_fetch(struct ssif_info *ssif_info, unsigned long *flags)\n{\n\tunsigned char mb[2];\n\n\tssif_info->req_flags = false;\n\tssif_info->ssif_state = SSIF_GETTING_FLAGS;\n\tipmi_ssif_unlock_cond(ssif_info, flags);\n\n\tmb[0] = (IPMI_NETFN_APP_REQUEST << 2);\n\tmb[1] = IPMI_GET_MSG_FLAGS_CMD;\n\tif (start_send(ssif_info, mb, 2) != 0)\n\t\tssif_info->ssif_state = SSIF_IDLE;\n}\n\nstatic void check_start_send(struct ssif_info *ssif_info, unsigned long *flags,\n\t\t\t     struct ipmi_smi_msg *msg)\n{\n\tif (start_send(ssif_info, msg->data, msg->data_size) != 0) {\n\t\tunsigned long oflags;\n\n\t\tflags = ipmi_ssif_lock_cond(ssif_info, &oflags);\n\t\tssif_info->curr_msg = NULL;\n\t\tssif_info->ssif_state = SSIF_IDLE;\n\t\tipmi_ssif_unlock_cond(ssif_info, flags);\n\t\tipmi_free_smi_msg(msg);\n\t}\n}\n\nstatic void start_event_fetch(struct ssif_info *ssif_info, unsigned long *flags)\n{\n\tstruct ipmi_smi_msg *msg;\n\n\tssif_info->req_events = false;\n\n\tmsg = ipmi_alloc_smi_msg();\n\tif (!msg) {\n\t\tssif_info->ssif_state = SSIF_IDLE;\n\t\tipmi_ssif_unlock_cond(ssif_info, flags);\n\t\treturn;\n\t}\n\n\tssif_info->curr_msg = msg;\n\tssif_info->ssif_state = SSIF_GETTING_EVENTS;\n\tipmi_ssif_unlock_cond(ssif_info, flags);\n\n\tmsg->data[0] = (IPMI_NETFN_APP_REQUEST << 2);\n\tmsg->data[1] = IPMI_READ_EVENT_MSG_BUFFER_CMD;\n\tmsg->data_size = 2;\n\n\tcheck_start_send(ssif_info, flags, msg);\n}\n\nstatic void start_recv_msg_fetch(struct ssif_info *ssif_info,\n\t\t\t\t unsigned long *flags)\n{\n\tstruct ipmi_smi_msg *msg;\n\n\tmsg = ipmi_alloc_smi_msg();\n\tif (!msg) {\n\t\tssif_info->ssif_state = SSIF_IDLE;\n\t\tipmi_ssif_unlock_cond(ssif_info, flags);\n\t\treturn;\n\t}\n\n\tssif_info->curr_msg = msg;\n\tssif_info->ssif_state = SSIF_GETTING_MESSAGES;\n\tipmi_ssif_unlock_cond(ssif_info, flags);\n\n\tmsg->data[0] = (IPMI_NETFN_APP_REQUEST << 2);\n\tmsg->data[1] = IPMI_GET_MSG_CMD;\n\tmsg->data_size = 2;\n\n\tcheck_start_send(ssif_info, flags, msg);\n}\n\n \nstatic void handle_flags(struct ssif_info *ssif_info, unsigned long *flags)\n{\n\tif (ssif_info->msg_flags & WDT_PRE_TIMEOUT_INT) {\n\t\t \n\t\tssif_inc_stat(ssif_info, watchdog_pretimeouts);\n\t\tstart_clear_flags(ssif_info, flags);\n\t\tipmi_smi_watchdog_pretimeout(ssif_info->intf);\n\t} else if (ssif_info->msg_flags & RECEIVE_MSG_AVAIL)\n\t\t \n\t\tstart_recv_msg_fetch(ssif_info, flags);\n\telse if (ssif_info->msg_flags & EVENT_MSG_BUFFER_FULL)\n\t\t \n\t\tstart_event_fetch(ssif_info, flags);\n\telse {\n\t\tssif_info->ssif_state = SSIF_IDLE;\n\t\tipmi_ssif_unlock_cond(ssif_info, flags);\n\t}\n}\n\nstatic int ipmi_ssif_thread(void *data)\n{\n\tstruct ssif_info *ssif_info = data;\n\n\twhile (!kthread_should_stop()) {\n\t\tint result;\n\n\t\t \n\t\tresult = wait_for_completion_interruptible(\n\t\t\t\t\t\t&ssif_info->wake_thread);\n\t\tif (ssif_info->stopping)\n\t\t\tbreak;\n\t\tif (result == -ERESTARTSYS)\n\t\t\tcontinue;\n\t\tinit_completion(&ssif_info->wake_thread);\n\n\t\tif (ssif_info->i2c_read_write == I2C_SMBUS_WRITE) {\n\t\t\tresult = i2c_smbus_write_block_data(\n\t\t\t\tssif_info->client, ssif_info->i2c_command,\n\t\t\t\tssif_info->i2c_data[0],\n\t\t\t\tssif_info->i2c_data + 1);\n\t\t\tssif_info->done_handler(ssif_info, result, NULL, 0);\n\t\t} else {\n\t\t\tresult = i2c_smbus_read_block_data(\n\t\t\t\tssif_info->client, ssif_info->i2c_command,\n\t\t\t\tssif_info->i2c_data);\n\t\t\tif (result < 0)\n\t\t\t\tssif_info->done_handler(ssif_info, result,\n\t\t\t\t\t\t\tNULL, 0);\n\t\t\telse\n\t\t\t\tssif_info->done_handler(ssif_info, 0,\n\t\t\t\t\t\t\tssif_info->i2c_data,\n\t\t\t\t\t\t\tresult);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void ssif_i2c_send(struct ssif_info *ssif_info,\n\t\t\tssif_i2c_done handler,\n\t\t\tint read_write, int command,\n\t\t\tunsigned char *data, unsigned int size)\n{\n\tssif_info->done_handler = handler;\n\n\tssif_info->i2c_read_write = read_write;\n\tssif_info->i2c_command = command;\n\tssif_info->i2c_data = data;\n\tssif_info->i2c_size = size;\n\tcomplete(&ssif_info->wake_thread);\n}\n\n\nstatic void msg_done_handler(struct ssif_info *ssif_info, int result,\n\t\t\t     unsigned char *data, unsigned int len);\n\nstatic void start_get(struct ssif_info *ssif_info)\n{\n\tssif_info->multi_pos = 0;\n\n\tssif_i2c_send(ssif_info, msg_done_handler, I2C_SMBUS_READ,\n\t\t  SSIF_IPMI_RESPONSE,\n\t\t  ssif_info->recv, I2C_SMBUS_BLOCK_DATA);\n}\n\nstatic void start_resend(struct ssif_info *ssif_info);\n\nstatic void retry_timeout(struct timer_list *t)\n{\n\tstruct ssif_info *ssif_info = from_timer(ssif_info, t, retry_timer);\n\tunsigned long oflags, *flags;\n\tbool waiting, resend;\n\n\tif (ssif_info->stopping)\n\t\treturn;\n\n\tflags = ipmi_ssif_lock_cond(ssif_info, &oflags);\n\tresend = ssif_info->do_resend;\n\tssif_info->do_resend = false;\n\twaiting = ssif_info->waiting_alert;\n\tssif_info->waiting_alert = false;\n\tipmi_ssif_unlock_cond(ssif_info, flags);\n\n\tif (waiting)\n\t\tstart_get(ssif_info);\n\tif (resend) {\n\t\tstart_resend(ssif_info);\n\t\tssif_inc_stat(ssif_info, send_retries);\n\t}\n}\n\nstatic void watch_timeout(struct timer_list *t)\n{\n\tstruct ssif_info *ssif_info = from_timer(ssif_info, t, watch_timer);\n\tunsigned long oflags, *flags;\n\n\tif (ssif_info->stopping)\n\t\treturn;\n\n\tflags = ipmi_ssif_lock_cond(ssif_info, &oflags);\n\tif (ssif_info->watch_timeout) {\n\t\tmod_timer(&ssif_info->watch_timer,\n\t\t\t  jiffies + ssif_info->watch_timeout);\n\t\tif (IS_SSIF_IDLE(ssif_info)) {\n\t\t\tstart_flag_fetch(ssif_info, flags);  \n\t\t\treturn;\n\t\t}\n\t\tssif_info->req_flags = true;\n\t}\n\tipmi_ssif_unlock_cond(ssif_info, flags);\n}\n\nstatic void ssif_alert(struct i2c_client *client, enum i2c_alert_protocol type,\n\t\t       unsigned int data)\n{\n\tstruct ssif_info *ssif_info = i2c_get_clientdata(client);\n\tunsigned long oflags, *flags;\n\tbool do_get = false;\n\n\tif (type != I2C_PROTOCOL_SMBUS_ALERT)\n\t\treturn;\n\n\tssif_inc_stat(ssif_info, alerts);\n\n\tflags = ipmi_ssif_lock_cond(ssif_info, &oflags);\n\tif (ssif_info->waiting_alert) {\n\t\tssif_info->waiting_alert = false;\n\t\tdel_timer(&ssif_info->retry_timer);\n\t\tdo_get = true;\n\t} else if (ssif_info->curr_msg) {\n\t\tssif_info->got_alert = true;\n\t}\n\tipmi_ssif_unlock_cond(ssif_info, flags);\n\tif (do_get)\n\t\tstart_get(ssif_info);\n}\n\nstatic void msg_done_handler(struct ssif_info *ssif_info, int result,\n\t\t\t     unsigned char *data, unsigned int len)\n{\n\tstruct ipmi_smi_msg *msg;\n\tunsigned long oflags, *flags;\n\n\t \n\n\tif (result < 0) {\n\t\tssif_info->retries_left--;\n\t\tif (ssif_info->retries_left > 0) {\n\t\t\tssif_inc_stat(ssif_info, receive_retries);\n\n\t\t\tflags = ipmi_ssif_lock_cond(ssif_info, &oflags);\n\t\t\tssif_info->waiting_alert = true;\n\t\t\tif (!ssif_info->stopping)\n\t\t\t\tmod_timer(&ssif_info->retry_timer,\n\t\t\t\t\t  jiffies + SSIF_MSG_JIFFIES);\n\t\t\tipmi_ssif_unlock_cond(ssif_info, flags);\n\t\t\treturn;\n\t\t}\n\n\t\tssif_inc_stat(ssif_info, receive_errors);\n\n\t\tif  (ssif_info->ssif_debug & SSIF_DEBUG_MSG)\n\t\t\tdev_dbg(&ssif_info->client->dev,\n\t\t\t\t\"%s: Error %d\\n\", __func__, result);\n\t\tlen = 0;\n\t\tgoto continue_op;\n\t}\n\n\tif ((len > 1) && (ssif_info->multi_pos == 0)\n\t\t\t\t&& (data[0] == 0x00) && (data[1] == 0x01)) {\n\t\t \n\t\tint i;\n\n\t\tssif_inc_stat(ssif_info, received_message_parts);\n\n\t\t \n\t\tlen -= 2;\n\t\tdata += 2;\n\t\tfor (i = 0; i < len; i++)\n\t\t\tssif_info->data[i] = data[i];\n\t\tssif_info->multi_len = len;\n\t\tssif_info->multi_pos = 1;\n\n\t\tssif_i2c_send(ssif_info, msg_done_handler, I2C_SMBUS_READ,\n\t\t\t SSIF_IPMI_MULTI_PART_RESPONSE_MIDDLE,\n\t\t\t ssif_info->recv, I2C_SMBUS_BLOCK_DATA);\n\t\treturn;\n\t} else if (ssif_info->multi_pos) {\n\t\t \n\t\tint i;\n\t\tunsigned char blocknum;\n\n\t\tif (len == 0) {\n\t\t\tresult = -EIO;\n\t\t\tif (ssif_info->ssif_debug & SSIF_DEBUG_MSG)\n\t\t\t\tdev_dbg(&ssif_info->client->dev,\n\t\t\t\t\t\"Middle message with no data\\n\");\n\n\t\t\tgoto continue_op;\n\t\t}\n\n\t\tblocknum = data[0];\n\t\tlen--;\n\t\tdata++;\n\n\t\tif (blocknum != 0xff && len != 31) {\n\t\t     \n\t\t\tresult = -EIO;\n\t\t\tif (ssif_info->ssif_debug & SSIF_DEBUG_MSG)\n\t\t\t\tdev_dbg(&ssif_info->client->dev,\n\t\t\t\t\t\"Received middle message <31\\n\");\n\n\t\t\tgoto continue_op;\n\t\t}\n\n\t\tif (ssif_info->multi_len + len > IPMI_MAX_MSG_LENGTH) {\n\t\t\t \n\t\t\tresult = -E2BIG;\n\t\t\tif (ssif_info->ssif_debug & SSIF_DEBUG_MSG)\n\t\t\t\tdev_dbg(&ssif_info->client->dev,\n\t\t\t\t\t\"Received message too big\\n\");\n\n\t\t\tgoto continue_op;\n\t\t}\n\n\t\tfor (i = 0; i < len; i++)\n\t\t\tssif_info->data[i + ssif_info->multi_len] = data[i];\n\t\tssif_info->multi_len += len;\n\t\tif (blocknum == 0xff) {\n\t\t\t \n\t\t\tlen = ssif_info->multi_len;\n\t\t\tdata = ssif_info->data;\n\t\t} else if (blocknum + 1 != ssif_info->multi_pos) {\n\t\t\t \n\t\t\tif (ssif_info->ssif_debug & SSIF_DEBUG_MSG)\n\t\t\t\tdev_dbg(&ssif_info->client->dev,\n\t\t\t\t\t\"Received message out of sequence, expected %u, got %u\\n\",\n\t\t\t\t\tssif_info->multi_pos - 1, blocknum);\n\t\t\tresult = -EIO;\n\t\t} else {\n\t\t\tssif_inc_stat(ssif_info, received_message_parts);\n\n\t\t\tssif_info->multi_pos++;\n\n\t\t\tssif_i2c_send(ssif_info, msg_done_handler,\n\t\t\t\t  I2C_SMBUS_READ,\n\t\t\t\t  SSIF_IPMI_MULTI_PART_RESPONSE_MIDDLE,\n\t\t\t\t  ssif_info->recv,\n\t\t\t\t  I2C_SMBUS_BLOCK_DATA);\n\t\t\treturn;\n\t\t}\n\t}\n\n continue_op:\n\tif (result < 0) {\n\t\tssif_inc_stat(ssif_info, receive_errors);\n\t} else {\n\t\tssif_inc_stat(ssif_info, received_messages);\n\t\tssif_inc_stat(ssif_info, received_message_parts);\n\t}\n\n\tif (ssif_info->ssif_debug & SSIF_DEBUG_STATE)\n\t\tdev_dbg(&ssif_info->client->dev,\n\t\t\t\"DONE 1: state = %d, result=%d\\n\",\n\t\t\tssif_info->ssif_state, result);\n\n\tflags = ipmi_ssif_lock_cond(ssif_info, &oflags);\n\tmsg = ssif_info->curr_msg;\n\tif (msg) {\n\t\tif (data) {\n\t\t\tif (len > IPMI_MAX_MSG_LENGTH)\n\t\t\t\tlen = IPMI_MAX_MSG_LENGTH;\n\t\t\tmemcpy(msg->rsp, data, len);\n\t\t} else {\n\t\t\tlen = 0;\n\t\t}\n\t\tmsg->rsp_size = len;\n\t\tssif_info->curr_msg = NULL;\n\t}\n\n\tswitch (ssif_info->ssif_state) {\n\tcase SSIF_IDLE:\n\t\tipmi_ssif_unlock_cond(ssif_info, flags);\n\t\tif (!msg)\n\t\t\tbreak;\n\n\t\tif (result < 0)\n\t\t\treturn_hosed_msg(ssif_info, msg);\n\t\telse\n\t\t\tdeliver_recv_msg(ssif_info, msg);\n\t\tbreak;\n\n\tcase SSIF_GETTING_FLAGS:\n\t\t \n\t\tif ((result < 0) || (len < 4) || (data[2] != 0)) {\n\t\t\t \n\t\t\tssif_info->ssif_state = SSIF_IDLE;\n\t\t\tipmi_ssif_unlock_cond(ssif_info, flags);\n\t\t\tdev_warn(&ssif_info->client->dev,\n\t\t\t\t \"Error getting flags: %d %d, %x\\n\",\n\t\t\t\t result, len, (len >= 3) ? data[2] : 0);\n\t\t} else if (data[0] != (IPMI_NETFN_APP_REQUEST | 1) << 2\n\t\t\t   || data[1] != IPMI_GET_MSG_FLAGS_CMD) {\n\t\t\t \n\t\t\tssif_info->ssif_state = SSIF_IDLE;\n\t\t\tipmi_ssif_unlock_cond(ssif_info, flags);\n\t\t\tdev_warn(&ssif_info->client->dev,\n\t\t\t\t \"Invalid response getting flags: %x %x\\n\",\n\t\t\t\t data[0], data[1]);\n\t\t} else {\n\t\t\tssif_inc_stat(ssif_info, flag_fetches);\n\t\t\tssif_info->msg_flags = data[3];\n\t\t\thandle_flags(ssif_info, flags);\n\t\t}\n\t\tbreak;\n\n\tcase SSIF_CLEARING_FLAGS:\n\t\t \n\t\tif ((result < 0) || (len < 3) || (data[2] != 0)) {\n\t\t\t \n\t\t\tdev_warn(&ssif_info->client->dev,\n\t\t\t\t \"Error clearing flags: %d %d, %x\\n\",\n\t\t\t\t result, len, (len >= 3) ? data[2] : 0);\n\t\t} else if (data[0] != (IPMI_NETFN_APP_REQUEST | 1) << 2\n\t\t\t   || data[1] != IPMI_CLEAR_MSG_FLAGS_CMD) {\n\t\t\tdev_warn(&ssif_info->client->dev,\n\t\t\t\t \"Invalid response clearing flags: %x %x\\n\",\n\t\t\t\t data[0], data[1]);\n\t\t}\n\t\tssif_info->ssif_state = SSIF_IDLE;\n\t\tipmi_ssif_unlock_cond(ssif_info, flags);\n\t\tbreak;\n\n\tcase SSIF_GETTING_EVENTS:\n\t\tif (!msg) {\n\t\t\t \n\t\t\tdev_warn(&ssif_info->client->dev,\n\t\t\t\t \"No message set while getting events\\n\");\n\t\t\tipmi_ssif_unlock_cond(ssif_info, flags);\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((result < 0) || (len < 3) || (msg->rsp[2] != 0)) {\n\t\t\t \n\t\t\tmsg->done(msg);\n\n\t\t\t \n\t\t\tssif_info->msg_flags &= ~EVENT_MSG_BUFFER_FULL;\n\t\t\thandle_flags(ssif_info, flags);\n\t\t} else if (msg->rsp[0] != (IPMI_NETFN_APP_REQUEST | 1) << 2\n\t\t\t   || msg->rsp[1] != IPMI_READ_EVENT_MSG_BUFFER_CMD) {\n\t\t\tdev_warn(&ssif_info->client->dev,\n\t\t\t\t \"Invalid response getting events: %x %x\\n\",\n\t\t\t\t msg->rsp[0], msg->rsp[1]);\n\t\t\tmsg->done(msg);\n\t\t\t \n\t\t\tssif_info->msg_flags &= ~EVENT_MSG_BUFFER_FULL;\n\t\t\thandle_flags(ssif_info, flags);\n\t\t} else {\n\t\t\thandle_flags(ssif_info, flags);\n\t\t\tssif_inc_stat(ssif_info, events);\n\t\t\tdeliver_recv_msg(ssif_info, msg);\n\t\t}\n\t\tbreak;\n\n\tcase SSIF_GETTING_MESSAGES:\n\t\tif (!msg) {\n\t\t\t \n\t\t\tdev_warn(&ssif_info->client->dev,\n\t\t\t\t \"No message set while getting messages\\n\");\n\t\t\tipmi_ssif_unlock_cond(ssif_info, flags);\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((result < 0) || (len < 3) || (msg->rsp[2] != 0)) {\n\t\t\t \n\t\t\tmsg->done(msg);\n\n\t\t\t \n\t\t\tssif_info->msg_flags &= ~RECEIVE_MSG_AVAIL;\n\t\t\thandle_flags(ssif_info, flags);\n\t\t} else if (msg->rsp[0] != (IPMI_NETFN_APP_REQUEST | 1) << 2\n\t\t\t   || msg->rsp[1] != IPMI_GET_MSG_CMD) {\n\t\t\tdev_warn(&ssif_info->client->dev,\n\t\t\t\t \"Invalid response clearing flags: %x %x\\n\",\n\t\t\t\t msg->rsp[0], msg->rsp[1]);\n\t\t\tmsg->done(msg);\n\n\t\t\t \n\t\t\tssif_info->msg_flags &= ~RECEIVE_MSG_AVAIL;\n\t\t\thandle_flags(ssif_info, flags);\n\t\t} else {\n\t\t\tssif_inc_stat(ssif_info, incoming_messages);\n\t\t\thandle_flags(ssif_info, flags);\n\t\t\tdeliver_recv_msg(ssif_info, msg);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tdev_warn(&ssif_info->client->dev,\n\t\t\t \"Invalid state in message done handling: %d\\n\",\n\t\t\t ssif_info->ssif_state);\n\t\tipmi_ssif_unlock_cond(ssif_info, flags);\n\t}\n\n\tflags = ipmi_ssif_lock_cond(ssif_info, &oflags);\n\tif (IS_SSIF_IDLE(ssif_info) && !ssif_info->stopping) {\n\t\tif (ssif_info->req_events)\n\t\t\tstart_event_fetch(ssif_info, flags);\n\t\telse if (ssif_info->req_flags)\n\t\t\tstart_flag_fetch(ssif_info, flags);\n\t\telse\n\t\t\tstart_next_msg(ssif_info, flags);\n\t} else\n\t\tipmi_ssif_unlock_cond(ssif_info, flags);\n\n\tif (ssif_info->ssif_debug & SSIF_DEBUG_STATE)\n\t\tdev_dbg(&ssif_info->client->dev,\n\t\t\t\"DONE 2: state = %d.\\n\", ssif_info->ssif_state);\n}\n\nstatic void msg_written_handler(struct ssif_info *ssif_info, int result,\n\t\t\t\tunsigned char *data, unsigned int len)\n{\n\t \n\tif (result < 0) {\n\t\tssif_info->retries_left--;\n\t\tif (ssif_info->retries_left > 0) {\n\t\t\t \n\t\t\tssif_info->do_resend = true;\n\t\t\tmod_timer(&ssif_info->retry_timer,\n\t\t\t\t  jiffies + SSIF_REQ_RETRY_JIFFIES);\n\t\t\treturn;\n\t\t}\n\n\t\tssif_inc_stat(ssif_info, send_errors);\n\n\t\tif (ssif_info->ssif_debug & SSIF_DEBUG_MSG)\n\t\t\tdev_dbg(&ssif_info->client->dev,\n\t\t\t\t\"%s: Out of retries\\n\", __func__);\n\n\t\tmsg_done_handler(ssif_info, -EIO, NULL, 0);\n\t\treturn;\n\t}\n\n\tif (ssif_info->multi_data) {\n\t\t \n\t\tint left, to_write;\n\t\tunsigned char *data_to_send;\n\t\tunsigned char cmd;\n\n\t\tssif_inc_stat(ssif_info, sent_messages_parts);\n\n\t\tleft = ssif_info->multi_len - ssif_info->multi_pos;\n\t\tto_write = left;\n\t\tif (to_write > 32)\n\t\t\tto_write = 32;\n\t\t \n\t\tssif_info->multi_data[ssif_info->multi_pos] = to_write;\n\t\tdata_to_send = ssif_info->multi_data + ssif_info->multi_pos;\n\t\tssif_info->multi_pos += to_write;\n\t\tcmd = SSIF_IPMI_MULTI_PART_REQUEST_MIDDLE;\n\t\tif (ssif_info->cmd8_works) {\n\t\t\tif (left == to_write) {\n\t\t\t\tcmd = SSIF_IPMI_MULTI_PART_REQUEST_END;\n\t\t\t\tssif_info->multi_data = NULL;\n\t\t\t}\n\t\t} else if (to_write < 32) {\n\t\t\tssif_info->multi_data = NULL;\n\t\t}\n\n\t\tssif_i2c_send(ssif_info, msg_written_handler,\n\t\t\t  I2C_SMBUS_WRITE, cmd,\n\t\t\t  data_to_send, I2C_SMBUS_BLOCK_DATA);\n\t} else {\n\t\t \n\t\tunsigned long oflags, *flags;\n\n\t\tssif_inc_stat(ssif_info, sent_messages);\n\t\tssif_inc_stat(ssif_info, sent_messages_parts);\n\n\t\tflags = ipmi_ssif_lock_cond(ssif_info, &oflags);\n\t\tif (ssif_info->got_alert) {\n\t\t\t \n\t\t\tssif_info->got_alert = false;\n\t\t\tipmi_ssif_unlock_cond(ssif_info, flags);\n\t\t\tstart_get(ssif_info);\n\t\t} else {\n\t\t\t \n\t\t\tssif_info->waiting_alert = true;\n\t\t\tssif_info->retries_left = SSIF_RECV_RETRIES;\n\t\t\tif (!ssif_info->stopping)\n\t\t\t\tmod_timer(&ssif_info->retry_timer,\n\t\t\t\t\t  jiffies + SSIF_MSG_PART_JIFFIES);\n\t\t\tipmi_ssif_unlock_cond(ssif_info, flags);\n\t\t}\n\t}\n}\n\nstatic void start_resend(struct ssif_info *ssif_info)\n{\n\tint command;\n\n\tssif_info->got_alert = false;\n\n\tif (ssif_info->data_len > 32) {\n\t\tcommand = SSIF_IPMI_MULTI_PART_REQUEST_START;\n\t\tssif_info->multi_data = ssif_info->data;\n\t\tssif_info->multi_len = ssif_info->data_len;\n\t\t \n\t\tssif_info->multi_pos = 32;\n\t\tssif_info->data[0] = 32;\n\t} else {\n\t\tssif_info->multi_data = NULL;\n\t\tcommand = SSIF_IPMI_REQUEST;\n\t\tssif_info->data[0] = ssif_info->data_len;\n\t}\n\n\tssif_i2c_send(ssif_info, msg_written_handler, I2C_SMBUS_WRITE,\n\t\t   command, ssif_info->data, I2C_SMBUS_BLOCK_DATA);\n}\n\nstatic int start_send(struct ssif_info *ssif_info,\n\t\t      unsigned char   *data,\n\t\t      unsigned int    len)\n{\n\tif (len > IPMI_MAX_MSG_LENGTH)\n\t\treturn -E2BIG;\n\tif (len > ssif_info->max_xmit_msg_size)\n\t\treturn -E2BIG;\n\n\tssif_info->retries_left = SSIF_SEND_RETRIES;\n\tmemcpy(ssif_info->data + 1, data, len);\n\tssif_info->data_len = len;\n\tstart_resend(ssif_info);\n\treturn 0;\n}\n\n \nstatic void start_next_msg(struct ssif_info *ssif_info, unsigned long *flags)\n{\n\tstruct ipmi_smi_msg *msg;\n\tunsigned long oflags;\n\n restart:\n\tif (!IS_SSIF_IDLE(ssif_info)) {\n\t\tipmi_ssif_unlock_cond(ssif_info, flags);\n\t\treturn;\n\t}\n\n\tif (!ssif_info->waiting_msg) {\n\t\tssif_info->curr_msg = NULL;\n\t\tipmi_ssif_unlock_cond(ssif_info, flags);\n\t} else {\n\t\tint rv;\n\n\t\tssif_info->curr_msg = ssif_info->waiting_msg;\n\t\tssif_info->waiting_msg = NULL;\n\t\tipmi_ssif_unlock_cond(ssif_info, flags);\n\t\trv = start_send(ssif_info,\n\t\t\t\tssif_info->curr_msg->data,\n\t\t\t\tssif_info->curr_msg->data_size);\n\t\tif (rv) {\n\t\t\tmsg = ssif_info->curr_msg;\n\t\t\tssif_info->curr_msg = NULL;\n\t\t\treturn_hosed_msg(ssif_info, msg);\n\t\t\tflags = ipmi_ssif_lock_cond(ssif_info, &oflags);\n\t\t\tgoto restart;\n\t\t}\n\t}\n}\n\nstatic void sender(void                *send_info,\n\t\t   struct ipmi_smi_msg *msg)\n{\n\tstruct ssif_info *ssif_info = send_info;\n\tunsigned long oflags, *flags;\n\n\tBUG_ON(ssif_info->waiting_msg);\n\tssif_info->waiting_msg = msg;\n\n\tflags = ipmi_ssif_lock_cond(ssif_info, &oflags);\n\tstart_next_msg(ssif_info, flags);\n\n\tif (ssif_info->ssif_debug & SSIF_DEBUG_TIMING) {\n\t\tstruct timespec64 t;\n\n\t\tktime_get_real_ts64(&t);\n\t\tdev_dbg(&ssif_info->client->dev,\n\t\t\t\"**Enqueue %02x %02x: %lld.%6.6ld\\n\",\n\t\t\tmsg->data[0], msg->data[1],\n\t\t\t(long long)t.tv_sec, (long)t.tv_nsec / NSEC_PER_USEC);\n\t}\n}\n\nstatic int get_smi_info(void *send_info, struct ipmi_smi_info *data)\n{\n\tstruct ssif_info *ssif_info = send_info;\n\n\tdata->addr_src = ssif_info->addr_source;\n\tdata->dev = &ssif_info->client->dev;\n\tdata->addr_info = ssif_info->addr_info;\n\tget_device(data->dev);\n\n\treturn 0;\n}\n\n \nstatic void request_events(void *send_info)\n{\n\tstruct ssif_info *ssif_info = send_info;\n\tunsigned long oflags, *flags;\n\n\tif (!ssif_info->has_event_buffer)\n\t\treturn;\n\n\tflags = ipmi_ssif_lock_cond(ssif_info, &oflags);\n\tssif_info->req_events = true;\n\tipmi_ssif_unlock_cond(ssif_info, flags);\n}\n\n \nstatic void ssif_set_need_watch(void *send_info, unsigned int watch_mask)\n{\n\tstruct ssif_info *ssif_info = send_info;\n\tunsigned long oflags, *flags;\n\tlong timeout = 0;\n\n\tif (watch_mask & IPMI_WATCH_MASK_CHECK_MESSAGES)\n\t\ttimeout = SSIF_WATCH_MSG_TIMEOUT;\n\telse if (watch_mask)\n\t\ttimeout = SSIF_WATCH_WATCHDOG_TIMEOUT;\n\n\tflags = ipmi_ssif_lock_cond(ssif_info, &oflags);\n\tif (timeout != ssif_info->watch_timeout) {\n\t\tssif_info->watch_timeout = timeout;\n\t\tif (ssif_info->watch_timeout)\n\t\t\tmod_timer(&ssif_info->watch_timer,\n\t\t\t\t  jiffies + ssif_info->watch_timeout);\n\t}\n\tipmi_ssif_unlock_cond(ssif_info, flags);\n}\n\nstatic int ssif_start_processing(void            *send_info,\n\t\t\t\t struct ipmi_smi *intf)\n{\n\tstruct ssif_info *ssif_info = send_info;\n\n\tssif_info->intf = intf;\n\n\treturn 0;\n}\n\n#define MAX_SSIF_BMCS 4\n\nstatic unsigned short addr[MAX_SSIF_BMCS];\nstatic int num_addrs;\nmodule_param_array(addr, ushort, &num_addrs, 0);\nMODULE_PARM_DESC(addr, \"The addresses to scan for IPMI BMCs on the SSIFs.\");\n\nstatic char *adapter_name[MAX_SSIF_BMCS];\nstatic int num_adapter_names;\nmodule_param_array(adapter_name, charp, &num_adapter_names, 0);\nMODULE_PARM_DESC(adapter_name, \"The string name of the I2C device that has the BMC.  By default all devices are scanned.\");\n\nstatic int slave_addrs[MAX_SSIF_BMCS];\nstatic int num_slave_addrs;\nmodule_param_array(slave_addrs, int, &num_slave_addrs, 0);\nMODULE_PARM_DESC(slave_addrs,\n\t\t \"The default IPMB slave address for the controller.\");\n\nstatic bool alerts_broken;\nmodule_param(alerts_broken, bool, 0);\nMODULE_PARM_DESC(alerts_broken, \"Don't enable alerts for the controller.\");\n\n \nstatic int dbg[MAX_SSIF_BMCS];\nstatic int num_dbg;\nmodule_param_array(dbg, int, &num_dbg, 0);\nMODULE_PARM_DESC(dbg, \"Turn on debugging.\");\n\nstatic bool ssif_dbg_probe;\nmodule_param_named(dbg_probe, ssif_dbg_probe, bool, 0);\nMODULE_PARM_DESC(dbg_probe, \"Enable debugging of probing of adapters.\");\n\nstatic bool ssif_tryacpi = true;\nmodule_param_named(tryacpi, ssif_tryacpi, bool, 0);\nMODULE_PARM_DESC(tryacpi, \"Setting this to zero will disable the default scan of the interfaces identified via ACPI\");\n\nstatic bool ssif_trydmi = true;\nmodule_param_named(trydmi, ssif_trydmi, bool, 0);\nMODULE_PARM_DESC(trydmi, \"Setting this to zero will disable the default scan of the interfaces identified via DMI (SMBIOS)\");\n\nstatic DEFINE_MUTEX(ssif_infos_mutex);\nstatic LIST_HEAD(ssif_infos);\n\n#define IPMI_SSIF_ATTR(name) \\\nstatic ssize_t ipmi_##name##_show(struct device *dev,\t\t\t\\\n\t\t\t\t  struct device_attribute *attr,\t\\\n\t\t\t\t  char *buf)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct ssif_info *ssif_info = dev_get_drvdata(dev);\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn sysfs_emit(buf, \"%u\\n\", ssif_get_stat(ssif_info, name));\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR(name, S_IRUGO, ipmi_##name##_show, NULL)\n\nstatic ssize_t ipmi_type_show(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\treturn sysfs_emit(buf, \"ssif\\n\");\n}\nstatic DEVICE_ATTR(type, S_IRUGO, ipmi_type_show, NULL);\n\nIPMI_SSIF_ATTR(sent_messages);\nIPMI_SSIF_ATTR(sent_messages_parts);\nIPMI_SSIF_ATTR(send_retries);\nIPMI_SSIF_ATTR(send_errors);\nIPMI_SSIF_ATTR(received_messages);\nIPMI_SSIF_ATTR(received_message_parts);\nIPMI_SSIF_ATTR(receive_retries);\nIPMI_SSIF_ATTR(receive_errors);\nIPMI_SSIF_ATTR(flag_fetches);\nIPMI_SSIF_ATTR(hosed);\nIPMI_SSIF_ATTR(events);\nIPMI_SSIF_ATTR(watchdog_pretimeouts);\nIPMI_SSIF_ATTR(alerts);\n\nstatic struct attribute *ipmi_ssif_dev_attrs[] = {\n\t&dev_attr_type.attr,\n\t&dev_attr_sent_messages.attr,\n\t&dev_attr_sent_messages_parts.attr,\n\t&dev_attr_send_retries.attr,\n\t&dev_attr_send_errors.attr,\n\t&dev_attr_received_messages.attr,\n\t&dev_attr_received_message_parts.attr,\n\t&dev_attr_receive_retries.attr,\n\t&dev_attr_receive_errors.attr,\n\t&dev_attr_flag_fetches.attr,\n\t&dev_attr_hosed.attr,\n\t&dev_attr_events.attr,\n\t&dev_attr_watchdog_pretimeouts.attr,\n\t&dev_attr_alerts.attr,\n\tNULL\n};\n\nstatic const struct attribute_group ipmi_ssif_dev_attr_group = {\n\t.attrs\t\t= ipmi_ssif_dev_attrs,\n};\n\nstatic void shutdown_ssif(void *send_info)\n{\n\tstruct ssif_info *ssif_info = send_info;\n\n\tdevice_remove_group(&ssif_info->client->dev, &ipmi_ssif_dev_attr_group);\n\tdev_set_drvdata(&ssif_info->client->dev, NULL);\n\n\t \n\twhile (ssif_info->ssif_state != SSIF_IDLE)\n\t\tschedule_timeout(1);\n\n\tssif_info->stopping = true;\n\tdel_timer_sync(&ssif_info->watch_timer);\n\tdel_timer_sync(&ssif_info->retry_timer);\n\tif (ssif_info->thread) {\n\t\tcomplete(&ssif_info->wake_thread);\n\t\tkthread_stop(ssif_info->thread);\n\t}\n}\n\nstatic void ssif_remove(struct i2c_client *client)\n{\n\tstruct ssif_info *ssif_info = i2c_get_clientdata(client);\n\tstruct ssif_addr_info *addr_info;\n\n\t \n\tipmi_unregister_smi(ssif_info->intf);\n\n\tlist_for_each_entry(addr_info, &ssif_infos, link) {\n\t\tif (addr_info->client == client) {\n\t\t\taddr_info->client = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tkfree(ssif_info);\n}\n\nstatic int read_response(struct i2c_client *client, unsigned char *resp)\n{\n\tint ret = -ENODEV, retry_cnt = SSIF_RECV_RETRIES;\n\n\twhile (retry_cnt > 0) {\n\t\tret = i2c_smbus_read_block_data(client, SSIF_IPMI_RESPONSE,\n\t\t\t\t\t\tresp);\n\t\tif (ret > 0)\n\t\t\tbreak;\n\t\tmsleep(SSIF_MSG_MSEC);\n\t\tretry_cnt--;\n\t\tif (retry_cnt <= 0)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int do_cmd(struct i2c_client *client, int len, unsigned char *msg,\n\t\t  int *resp_len, unsigned char *resp)\n{\n\tint retry_cnt;\n\tint ret;\n\n\tretry_cnt = SSIF_SEND_RETRIES;\n retry1:\n\tret = i2c_smbus_write_block_data(client, SSIF_IPMI_REQUEST, len, msg);\n\tif (ret) {\n\t\tretry_cnt--;\n\t\tif (retry_cnt > 0) {\n\t\t\tmsleep(SSIF_REQ_RETRY_MSEC);\n\t\t\tgoto retry1;\n\t\t}\n\t\treturn -ENODEV;\n\t}\n\n\tret = read_response(client, resp);\n\tif (ret > 0) {\n\t\t \n\t\tif (ret < 3 ||\n\t\t    (resp[0] != (msg[0] | (1 << 2))) ||\n\t\t    (resp[1] != msg[1]))\n\t\t\tret = -EINVAL;\n\t\telse if (ret > IPMI_MAX_MSG_LENGTH) {\n\t\t\tret = -E2BIG;\n\t\t} else {\n\t\t\t*resp_len = ret;\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int ssif_detect(struct i2c_client *client, struct i2c_board_info *info)\n{\n\tunsigned char *resp;\n\tunsigned char msg[3];\n\tint           rv;\n\tint           len;\n\n\tresp = kmalloc(IPMI_MAX_MSG_LENGTH, GFP_KERNEL);\n\tif (!resp)\n\t\treturn -ENOMEM;\n\n\t \n\tmsg[0] = IPMI_NETFN_APP_REQUEST << 2;\n\tmsg[1] = IPMI_GET_DEVICE_ID_CMD;\n\trv = do_cmd(client, 2, msg, &len, resp);\n\tif (rv)\n\t\trv = -ENODEV;\n\telse\n\t\tstrscpy(info->type, DEVICE_NAME, I2C_NAME_SIZE);\n\tkfree(resp);\n\treturn rv;\n}\n\nstatic int strcmp_nospace(char *s1, char *s2)\n{\n\twhile (*s1 && *s2) {\n\t\twhile (isspace(*s1))\n\t\t\ts1++;\n\t\twhile (isspace(*s2))\n\t\t\ts2++;\n\t\tif (*s1 > *s2)\n\t\t\treturn 1;\n\t\tif (*s1 < *s2)\n\t\t\treturn -1;\n\t\ts1++;\n\t\ts2++;\n\t}\n\treturn 0;\n}\n\nstatic struct ssif_addr_info *ssif_info_find(unsigned short addr,\n\t\t\t\t\t     char *adapter_name,\n\t\t\t\t\t     bool match_null_name)\n{\n\tstruct ssif_addr_info *info, *found = NULL;\n\nrestart:\n\tlist_for_each_entry(info, &ssif_infos, link) {\n\t\tif (info->binfo.addr == addr) {\n\t\t\tif (info->addr_src == SI_SMBIOS && !info->adapter_name)\n\t\t\t\tinfo->adapter_name = kstrdup(adapter_name,\n\t\t\t\t\t\t\t     GFP_KERNEL);\n\n\t\t\tif (info->adapter_name || adapter_name) {\n\t\t\t\tif (!info->adapter_name != !adapter_name) {\n\t\t\t\t\t \n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (adapter_name &&\n\t\t\t\t    strcmp_nospace(info->adapter_name,\n\t\t\t\t\t\t   adapter_name))\n\t\t\t\t\t \n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfound = info;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found && match_null_name) {\n\t\t \n\t\tadapter_name = NULL;\n\t\tmatch_null_name = false;\n\t\tgoto restart;\n\t}\n\n\treturn found;\n}\n\nstatic bool check_acpi(struct ssif_info *ssif_info, struct device *dev)\n{\n#ifdef CONFIG_ACPI\n\tacpi_handle acpi_handle;\n\n\tacpi_handle = ACPI_HANDLE(dev);\n\tif (acpi_handle) {\n\t\tssif_info->addr_source = SI_ACPI;\n\t\tssif_info->addr_info.acpi_info.acpi_handle = acpi_handle;\n\t\trequest_module_nowait(\"acpi_ipmi\");\n\t\treturn true;\n\t}\n#endif\n\treturn false;\n}\n\nstatic int find_slave_address(struct i2c_client *client, int slave_addr)\n{\n#ifdef CONFIG_IPMI_DMI_DECODE\n\tif (!slave_addr)\n\t\tslave_addr = ipmi_dmi_get_slave_addr(\n\t\t\tSI_TYPE_INVALID,\n\t\t\ti2c_adapter_id(client->adapter),\n\t\t\tclient->addr);\n#endif\n\n\treturn slave_addr;\n}\n\nstatic int start_multipart_test(struct i2c_client *client,\n\t\t\t\tunsigned char *msg, bool do_middle)\n{\n\tint retry_cnt = SSIF_SEND_RETRIES, ret;\n\nretry_write:\n\tret = i2c_smbus_write_block_data(client,\n\t\t\t\t\t SSIF_IPMI_MULTI_PART_REQUEST_START,\n\t\t\t\t\t 32, msg);\n\tif (ret) {\n\t\tretry_cnt--;\n\t\tif (retry_cnt > 0) {\n\t\t\tmsleep(SSIF_REQ_RETRY_MSEC);\n\t\t\tgoto retry_write;\n\t\t}\n\t\tdev_err(&client->dev, \"Could not write multi-part start, though the BMC said it could handle it.  Just limit sends to one part.\\n\");\n\t\treturn ret;\n\t}\n\n\tif (!do_middle)\n\t\treturn 0;\n\n\tret = i2c_smbus_write_block_data(client,\n\t\t\t\t\t SSIF_IPMI_MULTI_PART_REQUEST_MIDDLE,\n\t\t\t\t\t 32, msg + 32);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"Could not write multi-part middle, though the BMC said it could handle it.  Just limit sends to one part.\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void test_multipart_messages(struct i2c_client *client,\n\t\t\t\t    struct ssif_info *ssif_info,\n\t\t\t\t    unsigned char *resp)\n{\n\tunsigned char msg[65];\n\tint ret;\n\tbool do_middle;\n\n\tif (ssif_info->max_xmit_msg_size <= 32)\n\t\treturn;\n\n\tdo_middle = ssif_info->max_xmit_msg_size > 63;\n\n\tmemset(msg, 0, sizeof(msg));\n\tmsg[0] = IPMI_NETFN_APP_REQUEST << 2;\n\tmsg[1] = IPMI_GET_DEVICE_ID_CMD;\n\n\t \n\n\tret = start_multipart_test(client, msg, do_middle);\n\tif (ret)\n\t\tgoto out_no_multi_part;\n\n\tret = i2c_smbus_write_block_data(client,\n\t\t\t\t\t SSIF_IPMI_MULTI_PART_REQUEST_END,\n\t\t\t\t\t 1, msg + 64);\n\n\tif (!ret)\n\t\tret = read_response(client, resp);\n\n\tif (ret > 0) {\n\t\t \n\t\tssif_info->cmd8_works = true;\n\t\treturn;\n\t}\n\n\tret = start_multipart_test(client, msg, do_middle);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"Second multipart test failed.\\n\");\n\t\tgoto out_no_multi_part;\n\t}\n\n\tret = i2c_smbus_write_block_data(client,\n\t\t\t\t\t SSIF_IPMI_MULTI_PART_REQUEST_MIDDLE,\n\t\t\t\t\t 0, msg + 64);\n\tif (!ret)\n\t\tret = read_response(client, resp);\n\tif (ret > 0)\n\t\t \n\t\treturn;\n\n\t \n\tif (ssif_info->max_xmit_msg_size > 63)\n\t\tssif_info->max_xmit_msg_size = 63;\n\treturn;\n\nout_no_multi_part:\n\tssif_info->max_xmit_msg_size = 32;\n\treturn;\n}\n\n \n#define GLOBAL_ENABLES_MASK (IPMI_BMC_EVT_MSG_BUFF | IPMI_BMC_RCV_MSG_INTR | \\\n\t\t\t     IPMI_BMC_EVT_MSG_INTR)\n\nstatic void ssif_remove_dup(struct i2c_client *client)\n{\n\tstruct ssif_info *ssif_info = i2c_get_clientdata(client);\n\n\tipmi_unregister_smi(ssif_info->intf);\n\tkfree(ssif_info);\n}\n\nstatic int ssif_add_infos(struct i2c_client *client)\n{\n\tstruct ssif_addr_info *info;\n\n\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\tinfo->addr_src = SI_ACPI;\n\tinfo->client = client;\n\tinfo->adapter_name = kstrdup(client->adapter->name, GFP_KERNEL);\n\tif (!info->adapter_name) {\n\t\tkfree(info);\n\t\treturn -ENOMEM;\n\t}\n\n\tinfo->binfo.addr = client->addr;\n\tlist_add_tail(&info->link, &ssif_infos);\n\treturn 0;\n}\n\n \nstatic int ssif_check_and_remove(struct i2c_client *client,\n\t\t\t      struct ssif_info *ssif_info)\n{\n\tstruct ssif_addr_info *info;\n\n\tlist_for_each_entry(info, &ssif_infos, link) {\n\t\tif (!info->client)\n\t\t\treturn 0;\n\t\tif (!strcmp(info->adapter_name, client->adapter->name) &&\n\t\t    info->binfo.addr == client->addr) {\n\t\t\tif (info->addr_src == SI_ACPI)\n\t\t\t\treturn -EEXIST;\n\n\t\t\tif (ssif_info->addr_source == SI_ACPI &&\n\t\t\t    info->addr_src == SI_SMBIOS) {\n\t\t\t\tdev_info(&client->dev,\n\t\t\t\t\t \"Removing %s-specified SSIF interface in favor of ACPI\\n\",\n\t\t\t\t\t ipmi_addr_src_to_str(info->addr_src));\n\t\t\t\tssif_remove_dup(info->client);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int ssif_probe(struct i2c_client *client)\n{\n\tunsigned char     msg[3];\n\tunsigned char     *resp;\n\tstruct ssif_info   *ssif_info;\n\tint               rv = 0;\n\tint               len = 0;\n\tint               i;\n\tu8\t\t  slave_addr = 0;\n\tstruct ssif_addr_info *addr_info = NULL;\n\n\tmutex_lock(&ssif_infos_mutex);\n\tresp = kmalloc(IPMI_MAX_MSG_LENGTH, GFP_KERNEL);\n\tif (!resp) {\n\t\tmutex_unlock(&ssif_infos_mutex);\n\t\treturn -ENOMEM;\n\t}\n\n\tssif_info = kzalloc(sizeof(*ssif_info), GFP_KERNEL);\n\tif (!ssif_info) {\n\t\tkfree(resp);\n\t\tmutex_unlock(&ssif_infos_mutex);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (!check_acpi(ssif_info, &client->dev)) {\n\t\taddr_info = ssif_info_find(client->addr, client->adapter->name,\n\t\t\t\t\t   true);\n\t\tif (!addr_info) {\n\t\t\t \n\t\t\tssif_info->addr_source = SI_HOTMOD;\n\t\t} else {\n\t\t\tssif_info->addr_source = addr_info->addr_src;\n\t\t\tssif_info->ssif_debug = addr_info->debug;\n\t\t\tssif_info->addr_info = addr_info->addr_info;\n\t\t\taddr_info->client = client;\n\t\t\tslave_addr = addr_info->slave_addr;\n\t\t}\n\t}\n\n\tssif_info->client = client;\n\ti2c_set_clientdata(client, ssif_info);\n\n\trv = ssif_check_and_remove(client, ssif_info);\n\t \n\tif (!rv && ssif_info->addr_source == SI_ACPI) {\n\t\trv = ssif_add_infos(client);\n\t\tif (rv) {\n\t\t\tdev_err(&client->dev, \"Out of memory!, exiting ..\\n\");\n\t\t\tgoto out;\n\t\t}\n\t} else if (rv) {\n\t\tdev_err(&client->dev, \"Not probing, Interface already present\\n\");\n\t\tgoto out;\n\t}\n\n\tslave_addr = find_slave_address(client, slave_addr);\n\n\tdev_info(&client->dev,\n\t\t \"Trying %s-specified SSIF interface at i2c address 0x%x, adapter %s, slave address 0x%x\\n\",\n\t\tipmi_addr_src_to_str(ssif_info->addr_source),\n\t\tclient->addr, client->adapter->name, slave_addr);\n\n\t \n\tmsg[0] = IPMI_NETFN_APP_REQUEST << 2;\n\tmsg[1] = IPMI_GET_SYSTEM_INTERFACE_CAPABILITIES_CMD;\n\tmsg[2] = 0;  \n\trv = do_cmd(client, 3, msg, &len, resp);\n\tif (!rv && (len >= 3) && (resp[2] == 0)) {\n\t\tif (len < 7) {\n\t\t\tif (ssif_dbg_probe)\n\t\t\t\tdev_dbg(&ssif_info->client->dev,\n\t\t\t\t\t\"SSIF info too short: %d\\n\", len);\n\t\t\tgoto no_support;\n\t\t}\n\n\t\t \n\t\tssif_info->max_xmit_msg_size = resp[5];\n\t\tssif_info->max_recv_msg_size = resp[6];\n\t\tssif_info->multi_support = (resp[4] >> 6) & 0x3;\n\t\tssif_info->supports_pec = (resp[4] >> 3) & 0x1;\n\n\t\t \n\t\tswitch (ssif_info->multi_support) {\n\t\tcase SSIF_NO_MULTI:\n\t\t\tif (ssif_info->max_xmit_msg_size > 32)\n\t\t\t\tssif_info->max_xmit_msg_size = 32;\n\t\t\tif (ssif_info->max_recv_msg_size > 32)\n\t\t\t\tssif_info->max_recv_msg_size = 32;\n\t\t\tbreak;\n\n\t\tcase SSIF_MULTI_2_PART:\n\t\t\tif (ssif_info->max_xmit_msg_size > 63)\n\t\t\t\tssif_info->max_xmit_msg_size = 63;\n\t\t\tif (ssif_info->max_recv_msg_size > 62)\n\t\t\t\tssif_info->max_recv_msg_size = 62;\n\t\t\tbreak;\n\n\t\tcase SSIF_MULTI_n_PART:\n\t\t\t \n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t \n\t\t\tgoto no_support;\n\t\t}\n\t} else {\n no_support:\n\t\t \n\t\tdev_info(&ssif_info->client->dev,\n\t\t\t \"Error fetching SSIF: %d %d %2.2x, your system probably doesn't support this command so using defaults\\n\",\n\t\t\trv, len, resp[2]);\n\n\t\tssif_info->max_xmit_msg_size = 32;\n\t\tssif_info->max_recv_msg_size = 32;\n\t\tssif_info->multi_support = SSIF_NO_MULTI;\n\t\tssif_info->supports_pec = 0;\n\t}\n\n\ttest_multipart_messages(client, ssif_info, resp);\n\n\t \n\tmsg[0] = IPMI_NETFN_APP_REQUEST << 2;\n\tmsg[1] = IPMI_CLEAR_MSG_FLAGS_CMD;\n\tmsg[2] = WDT_PRE_TIMEOUT_INT;\n\trv = do_cmd(client, 3, msg, &len, resp);\n\tif (rv || (len < 3) || (resp[2] != 0))\n\t\tdev_warn(&ssif_info->client->dev,\n\t\t\t \"Unable to clear message flags: %d %d %2.2x\\n\",\n\t\t\t rv, len, resp[2]);\n\n\t \n\tmsg[0] = IPMI_NETFN_APP_REQUEST << 2;\n\tmsg[1] = IPMI_GET_BMC_GLOBAL_ENABLES_CMD;\n\trv = do_cmd(client, 2, msg, &len, resp);\n\tif (rv || (len < 4) || (resp[2] != 0)) {\n\t\tdev_warn(&ssif_info->client->dev,\n\t\t\t \"Error getting global enables: %d %d %2.2x\\n\",\n\t\t\t rv, len, resp[2]);\n\t\trv = 0;  \n\t\tgoto found;\n\t}\n\n\tssif_info->global_enables = resp[3];\n\n\tif (resp[3] & IPMI_BMC_EVT_MSG_BUFF) {\n\t\tssif_info->has_event_buffer = true;\n\t\t \n\t\tgoto found;\n\t}\n\n\tmsg[0] = IPMI_NETFN_APP_REQUEST << 2;\n\tmsg[1] = IPMI_SET_BMC_GLOBAL_ENABLES_CMD;\n\tmsg[2] = ssif_info->global_enables | IPMI_BMC_EVT_MSG_BUFF;\n\trv = do_cmd(client, 3, msg, &len, resp);\n\tif (rv || (len < 2)) {\n\t\tdev_warn(&ssif_info->client->dev,\n\t\t\t \"Error setting global enables: %d %d %2.2x\\n\",\n\t\t\t rv, len, resp[2]);\n\t\trv = 0;  \n\t\tgoto found;\n\t}\n\n\tif (resp[2] == 0) {\n\t\t \n\t\tssif_info->has_event_buffer = true;\n\t\tssif_info->global_enables |= IPMI_BMC_EVT_MSG_BUFF;\n\t}\n\n\t \n\tif (alerts_broken)\n\t\tgoto found;\n\n\tmsg[0] = IPMI_NETFN_APP_REQUEST << 2;\n\tmsg[1] = IPMI_SET_BMC_GLOBAL_ENABLES_CMD;\n\tmsg[2] = ssif_info->global_enables | IPMI_BMC_RCV_MSG_INTR;\n\trv = do_cmd(client, 3, msg, &len, resp);\n\tif (rv || (len < 2)) {\n\t\tdev_warn(&ssif_info->client->dev,\n\t\t\t \"Error setting global enables: %d %d %2.2x\\n\",\n\t\t\t rv, len, resp[2]);\n\t\trv = 0;  \n\t\tgoto found;\n\t}\n\n\tif (resp[2] == 0) {\n\t\t \n\t\tssif_info->supports_alert = true;\n\t\tssif_info->global_enables |= IPMI_BMC_RCV_MSG_INTR;\n\t}\n\n found:\n\tif (ssif_dbg_probe) {\n\t\tdev_dbg(&ssif_info->client->dev,\n\t\t       \"%s: i2c_probe found device at i2c address %x\\n\",\n\t\t       __func__, client->addr);\n\t}\n\n\tspin_lock_init(&ssif_info->lock);\n\tssif_info->ssif_state = SSIF_IDLE;\n\ttimer_setup(&ssif_info->retry_timer, retry_timeout, 0);\n\ttimer_setup(&ssif_info->watch_timer, watch_timeout, 0);\n\n\tfor (i = 0; i < SSIF_NUM_STATS; i++)\n\t\tatomic_set(&ssif_info->stats[i], 0);\n\n\tif (ssif_info->supports_pec)\n\t\tssif_info->client->flags |= I2C_CLIENT_PEC;\n\n\tssif_info->handlers.owner = THIS_MODULE;\n\tssif_info->handlers.start_processing = ssif_start_processing;\n\tssif_info->handlers.shutdown = shutdown_ssif;\n\tssif_info->handlers.get_smi_info = get_smi_info;\n\tssif_info->handlers.sender = sender;\n\tssif_info->handlers.request_events = request_events;\n\tssif_info->handlers.set_need_watch = ssif_set_need_watch;\n\n\t{\n\t\tunsigned int thread_num;\n\n\t\tthread_num = ((i2c_adapter_id(ssif_info->client->adapter)\n\t\t\t       << 8) |\n\t\t\t      ssif_info->client->addr);\n\t\tinit_completion(&ssif_info->wake_thread);\n\t\tssif_info->thread = kthread_run(ipmi_ssif_thread, ssif_info,\n\t\t\t\t\t       \"kssif%4.4x\", thread_num);\n\t\tif (IS_ERR(ssif_info->thread)) {\n\t\t\trv = PTR_ERR(ssif_info->thread);\n\t\t\tdev_notice(&ssif_info->client->dev,\n\t\t\t\t   \"Could not start kernel thread: error %d\\n\",\n\t\t\t\t   rv);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tdev_set_drvdata(&ssif_info->client->dev, ssif_info);\n\trv = device_add_group(&ssif_info->client->dev,\n\t\t\t      &ipmi_ssif_dev_attr_group);\n\tif (rv) {\n\t\tdev_err(&ssif_info->client->dev,\n\t\t\t\"Unable to add device attributes: error %d\\n\",\n\t\t\trv);\n\t\tgoto out;\n\t}\n\n\trv = ipmi_register_smi(&ssif_info->handlers,\n\t\t\t       ssif_info,\n\t\t\t       &ssif_info->client->dev,\n\t\t\t       slave_addr);\n\tif (rv) {\n\t\tdev_err(&ssif_info->client->dev,\n\t\t\t\"Unable to register device: error %d\\n\", rv);\n\t\tgoto out_remove_attr;\n\t}\n\n out:\n\tif (rv) {\n\t\tif (addr_info)\n\t\t\taddr_info->client = NULL;\n\n\t\tdev_err(&ssif_info->client->dev,\n\t\t\t\"Unable to start IPMI SSIF: %d\\n\", rv);\n\t\ti2c_set_clientdata(client, NULL);\n\t\tkfree(ssif_info);\n\t}\n\tkfree(resp);\n\tmutex_unlock(&ssif_infos_mutex);\n\treturn rv;\n\nout_remove_attr:\n\tdevice_remove_group(&ssif_info->client->dev, &ipmi_ssif_dev_attr_group);\n\tdev_set_drvdata(&ssif_info->client->dev, NULL);\n\tgoto out;\n}\n\nstatic int new_ssif_client(int addr, char *adapter_name,\n\t\t\t   int debug, int slave_addr,\n\t\t\t   enum ipmi_addr_src addr_src,\n\t\t\t   struct device *dev)\n{\n\tstruct ssif_addr_info *addr_info;\n\tint rv = 0;\n\n\tmutex_lock(&ssif_infos_mutex);\n\tif (ssif_info_find(addr, adapter_name, false)) {\n\t\trv = -EEXIST;\n\t\tgoto out_unlock;\n\t}\n\n\taddr_info = kzalloc(sizeof(*addr_info), GFP_KERNEL);\n\tif (!addr_info) {\n\t\trv = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\tif (adapter_name) {\n\t\taddr_info->adapter_name = kstrdup(adapter_name, GFP_KERNEL);\n\t\tif (!addr_info->adapter_name) {\n\t\t\tkfree(addr_info);\n\t\t\trv = -ENOMEM;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tstrncpy(addr_info->binfo.type, DEVICE_NAME,\n\t\tsizeof(addr_info->binfo.type));\n\taddr_info->binfo.addr = addr;\n\taddr_info->binfo.platform_data = addr_info;\n\taddr_info->debug = debug;\n\taddr_info->slave_addr = slave_addr;\n\taddr_info->addr_src = addr_src;\n\taddr_info->dev = dev;\n\n\tif (dev)\n\t\tdev_set_drvdata(dev, addr_info);\n\n\tlist_add_tail(&addr_info->link, &ssif_infos);\n\n\t \n\nout_unlock:\n\tmutex_unlock(&ssif_infos_mutex);\n\treturn rv;\n}\n\nstatic void free_ssif_clients(void)\n{\n\tstruct ssif_addr_info *info, *tmp;\n\n\tmutex_lock(&ssif_infos_mutex);\n\tlist_for_each_entry_safe(info, tmp, &ssif_infos, link) {\n\t\tlist_del(&info->link);\n\t\tkfree(info->adapter_name);\n\t\tkfree(info);\n\t}\n\tmutex_unlock(&ssif_infos_mutex);\n}\n\nstatic unsigned short *ssif_address_list(void)\n{\n\tstruct ssif_addr_info *info;\n\tunsigned int count = 0, i = 0;\n\tunsigned short *address_list;\n\n\tlist_for_each_entry(info, &ssif_infos, link)\n\t\tcount++;\n\n\taddress_list = kcalloc(count + 1, sizeof(*address_list),\n\t\t\t       GFP_KERNEL);\n\tif (!address_list)\n\t\treturn NULL;\n\n\tlist_for_each_entry(info, &ssif_infos, link) {\n\t\tunsigned short addr = info->binfo.addr;\n\t\tint j;\n\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tif (address_list[j] == addr)\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t}\n\t\tif (j == i)  \n\t\t\taddress_list[i++] = addr;\n\t}\n\taddress_list[i] = I2C_CLIENT_END;\n\n\treturn address_list;\n}\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id ssif_acpi_match[] = {\n\t{ \"IPI0001\", 0 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(acpi, ssif_acpi_match);\n#endif\n\n#ifdef CONFIG_DMI\nstatic int dmi_ipmi_probe(struct platform_device *pdev)\n{\n\tu8 slave_addr = 0;\n\tu16 i2c_addr;\n\tint rv;\n\n\tif (!ssif_trydmi)\n\t\treturn -ENODEV;\n\n\trv = device_property_read_u16(&pdev->dev, \"i2c-addr\", &i2c_addr);\n\tif (rv) {\n\t\tdev_warn(&pdev->dev, \"No i2c-addr property\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\trv = device_property_read_u8(&pdev->dev, \"slave-addr\", &slave_addr);\n\tif (rv)\n\t\tslave_addr = 0x20;\n\n\treturn new_ssif_client(i2c_addr, NULL, 0,\n\t\t\t       slave_addr, SI_SMBIOS, &pdev->dev);\n}\n#else\nstatic int dmi_ipmi_probe(struct platform_device *pdev)\n{\n\treturn -ENODEV;\n}\n#endif\n\nstatic const struct i2c_device_id ssif_id[] = {\n\t{ DEVICE_NAME, 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, ssif_id);\n\nstatic struct i2c_driver ssif_i2c_driver = {\n\t.class\t\t= I2C_CLASS_HWMON,\n\t.driver\t\t= {\n\t\t.name\t\t\t= DEVICE_NAME\n\t},\n\t.probe\t\t= ssif_probe,\n\t.remove\t\t= ssif_remove,\n\t.alert\t\t= ssif_alert,\n\t.id_table\t= ssif_id,\n\t.detect\t\t= ssif_detect\n};\n\nstatic int ssif_platform_probe(struct platform_device *dev)\n{\n\treturn dmi_ipmi_probe(dev);\n}\n\nstatic int ssif_platform_remove(struct platform_device *dev)\n{\n\tstruct ssif_addr_info *addr_info = dev_get_drvdata(&dev->dev);\n\n\tmutex_lock(&ssif_infos_mutex);\n\tlist_del(&addr_info->link);\n\tkfree(addr_info);\n\tmutex_unlock(&ssif_infos_mutex);\n\treturn 0;\n}\n\nstatic const struct platform_device_id ssif_plat_ids[] = {\n    { \"dmi-ipmi-ssif\", 0 },\n    { }\n};\n\nstatic struct platform_driver ipmi_driver = {\n\t.driver = {\n\t\t.name = DEVICE_NAME,\n\t},\n\t.probe\t\t= ssif_platform_probe,\n\t.remove\t\t= ssif_platform_remove,\n\t.id_table       = ssif_plat_ids\n};\n\nstatic int __init init_ipmi_ssif(void)\n{\n\tint i;\n\tint rv;\n\n\tif (initialized)\n\t\treturn 0;\n\n\tpr_info(\"IPMI SSIF Interface driver\\n\");\n\n\t \n\tfor (i = 0; i < num_addrs; i++) {\n\t\trv = new_ssif_client(addr[i], adapter_name[i],\n\t\t\t\t     dbg[i], slave_addrs[i],\n\t\t\t\t     SI_HARDCODED, NULL);\n\t\tif (rv)\n\t\t\tpr_err(\"Couldn't add hardcoded device at addr 0x%x\\n\",\n\t\t\t       addr[i]);\n\t}\n\n\tif (ssif_tryacpi)\n\t\tssif_i2c_driver.driver.acpi_match_table\t=\n\t\t\tACPI_PTR(ssif_acpi_match);\n\n\tif (ssif_trydmi) {\n\t\trv = platform_driver_register(&ipmi_driver);\n\t\tif (rv)\n\t\t\tpr_err(\"Unable to register driver: %d\\n\", rv);\n\t\telse\n\t\t\tplatform_registered = true;\n\t}\n\n\tssif_i2c_driver.address_list = ssif_address_list();\n\n\trv = i2c_add_driver(&ssif_i2c_driver);\n\tif (!rv)\n\t\tinitialized = true;\n\n\treturn rv;\n}\nmodule_init(init_ipmi_ssif);\n\nstatic void __exit cleanup_ipmi_ssif(void)\n{\n\tif (!initialized)\n\t\treturn;\n\n\tinitialized = false;\n\n\ti2c_del_driver(&ssif_i2c_driver);\n\n\tkfree(ssif_i2c_driver.address_list);\n\n\tif (ssif_trydmi && platform_registered)\n\t\tplatform_driver_unregister(&ipmi_driver);\n\n\tfree_ssif_clients();\n}\nmodule_exit(cleanup_ipmi_ssif);\n\nMODULE_ALIAS(\"platform:dmi-ipmi-ssif\");\nMODULE_AUTHOR(\"Todd C Davis <todd.c.davis@intel.com>, Corey Minyard <minyard@acm.org>\");\nMODULE_DESCRIPTION(\"IPMI driver for management controllers on a SMBus\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}