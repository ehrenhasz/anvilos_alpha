{
  "module_name": "ipmi_kcs_sm.c",
  "hash_id": "bd16e10d9d2e747e79dc080d192e1d41bbb11ca0b1a9c0ff202a17dce33c464f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/ipmi/ipmi_kcs_sm.c",
  "human_readable_source": "\n \n\n \n\n#define DEBUG  \n\n#include <linux/kernel.h>  \n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/string.h>\n#include <linux/jiffies.h>\n#include <linux/ipmi_msgdefs.h>\t\t \n#include \"ipmi_si_sm.h\"\n\n \n#define KCS_DEBUG_STATES\t4\n#define KCS_DEBUG_MSG\t\t2\n#define\tKCS_DEBUG_ENABLE\t1\n\nstatic int kcs_debug;\nmodule_param(kcs_debug, int, 0644);\nMODULE_PARM_DESC(kcs_debug, \"debug bitmask, 1=enable, 2=messages, 4=states\");\n\n \nenum kcs_states {\n\t \n\tKCS_IDLE,\n\n\t \n\tKCS_START_OP,\n\n\t \n\tKCS_WAIT_WRITE_START,\n\n\t \n\tKCS_WAIT_WRITE,\n\n\t \n\tKCS_WAIT_WRITE_END,\n\n\t \n\tKCS_WAIT_READ,\n\n\t \n\tKCS_ERROR0,\n\n\t \n\tKCS_ERROR1,\n\n\t \n\tKCS_ERROR2,\n\n\t \n\tKCS_ERROR3,\n\n\t \n\tKCS_HOSED\n};\n\n#define MAX_KCS_READ_SIZE IPMI_MAX_MSG_LENGTH\n#define MAX_KCS_WRITE_SIZE IPMI_MAX_MSG_LENGTH\n\n \n#define IBF_RETRY_TIMEOUT (5*USEC_PER_SEC)\n#define OBF_RETRY_TIMEOUT (5*USEC_PER_SEC)\n#define MAX_ERROR_RETRIES 10\n#define ERROR0_OBF_WAIT_JIFFIES (2*HZ)\n\nstruct si_sm_data {\n\tenum kcs_states  state;\n\tstruct si_sm_io *io;\n\tunsigned char    write_data[MAX_KCS_WRITE_SIZE];\n\tint              write_pos;\n\tint              write_count;\n\tint              orig_write_count;\n\tunsigned char    read_data[MAX_KCS_READ_SIZE];\n\tint              read_pos;\n\tint\t         truncated;\n\n\tunsigned int  error_retries;\n\tlong          ibf_timeout;\n\tlong          obf_timeout;\n\tunsigned long  error0_timeout;\n};\n\nstatic unsigned int init_kcs_data_with_state(struct si_sm_data *kcs,\n\t\t\t\t  struct si_sm_io *io, enum kcs_states state)\n{\n\tkcs->state = state;\n\tkcs->io = io;\n\tkcs->write_pos = 0;\n\tkcs->write_count = 0;\n\tkcs->orig_write_count = 0;\n\tkcs->read_pos = 0;\n\tkcs->error_retries = 0;\n\tkcs->truncated = 0;\n\tkcs->ibf_timeout = IBF_RETRY_TIMEOUT;\n\tkcs->obf_timeout = OBF_RETRY_TIMEOUT;\n\n\t \n\treturn 2;\n}\n\nstatic unsigned int init_kcs_data(struct si_sm_data *kcs,\n\t\t\t\t  struct si_sm_io *io)\n{\n\treturn init_kcs_data_with_state(kcs, io, KCS_IDLE);\n}\n\nstatic inline unsigned char read_status(struct si_sm_data *kcs)\n{\n\treturn kcs->io->inputb(kcs->io, 1);\n}\n\nstatic inline unsigned char read_data(struct si_sm_data *kcs)\n{\n\treturn kcs->io->inputb(kcs->io, 0);\n}\n\nstatic inline void write_cmd(struct si_sm_data *kcs, unsigned char data)\n{\n\tkcs->io->outputb(kcs->io, 1, data);\n}\n\nstatic inline void write_data(struct si_sm_data *kcs, unsigned char data)\n{\n\tkcs->io->outputb(kcs->io, 0, data);\n}\n\n \n#define KCS_GET_STATUS_ABORT\t0x60\n#define KCS_WRITE_START\t\t0x61\n#define KCS_WRITE_END\t\t0x62\n#define KCS_READ_BYTE\t\t0x68\n\n \n#define GET_STATUS_STATE(status) (((status) >> 6) & 0x03)\n#define KCS_IDLE_STATE\t0\n#define KCS_READ_STATE\t1\n#define KCS_WRITE_STATE\t2\n#define KCS_ERROR_STATE\t3\n#define GET_STATUS_ATN(status) ((status) & 0x04)\n#define GET_STATUS_IBF(status) ((status) & 0x02)\n#define GET_STATUS_OBF(status) ((status) & 0x01)\n\n\nstatic inline void write_next_byte(struct si_sm_data *kcs)\n{\n\twrite_data(kcs, kcs->write_data[kcs->write_pos]);\n\t(kcs->write_pos)++;\n\t(kcs->write_count)--;\n}\n\nstatic inline void start_error_recovery(struct si_sm_data *kcs, char *reason)\n{\n\t(kcs->error_retries)++;\n\tif (kcs->error_retries > MAX_ERROR_RETRIES) {\n\t\tif (kcs_debug & KCS_DEBUG_ENABLE)\n\t\t\tdev_dbg(kcs->io->dev, \"ipmi_kcs_sm: kcs hosed: %s\\n\",\n\t\t\t\treason);\n\t\tkcs->state = KCS_HOSED;\n\t} else {\n\t\tkcs->error0_timeout = jiffies + ERROR0_OBF_WAIT_JIFFIES;\n\t\tkcs->state = KCS_ERROR0;\n\t}\n}\n\nstatic inline void read_next_byte(struct si_sm_data *kcs)\n{\n\tif (kcs->read_pos >= MAX_KCS_READ_SIZE) {\n\t\t \n\t\tread_data(kcs);\n\t\tkcs->truncated = 1;\n\t} else {\n\t\tkcs->read_data[kcs->read_pos] = read_data(kcs);\n\t\t(kcs->read_pos)++;\n\t}\n\twrite_data(kcs, KCS_READ_BYTE);\n}\n\nstatic inline int check_ibf(struct si_sm_data *kcs, unsigned char status,\n\t\t\t    long time)\n{\n\tif (GET_STATUS_IBF(status)) {\n\t\tkcs->ibf_timeout -= time;\n\t\tif (kcs->ibf_timeout < 0) {\n\t\t\tstart_error_recovery(kcs, \"IBF not ready in time\");\n\t\t\tkcs->ibf_timeout = IBF_RETRY_TIMEOUT;\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\tkcs->ibf_timeout = IBF_RETRY_TIMEOUT;\n\treturn 1;\n}\n\nstatic inline int check_obf(struct si_sm_data *kcs, unsigned char status,\n\t\t\t    long time)\n{\n\tif (!GET_STATUS_OBF(status)) {\n\t\tkcs->obf_timeout -= time;\n\t\tif (kcs->obf_timeout < 0) {\n\t\t\tkcs->obf_timeout = OBF_RETRY_TIMEOUT;\n\t\t\tstart_error_recovery(kcs, \"OBF not ready in time\");\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\tkcs->obf_timeout = OBF_RETRY_TIMEOUT;\n\treturn 1;\n}\n\nstatic void clear_obf(struct si_sm_data *kcs, unsigned char status)\n{\n\tif (GET_STATUS_OBF(status))\n\t\tread_data(kcs);\n}\n\nstatic void restart_kcs_transaction(struct si_sm_data *kcs)\n{\n\tkcs->write_count = kcs->orig_write_count;\n\tkcs->write_pos = 0;\n\tkcs->read_pos = 0;\n\tkcs->state = KCS_WAIT_WRITE_START;\n\tkcs->ibf_timeout = IBF_RETRY_TIMEOUT;\n\tkcs->obf_timeout = OBF_RETRY_TIMEOUT;\n\twrite_cmd(kcs, KCS_WRITE_START);\n}\n\nstatic int start_kcs_transaction(struct si_sm_data *kcs, unsigned char *data,\n\t\t\t\t unsigned int size)\n{\n\tunsigned int i;\n\n\tif (size < 2)\n\t\treturn IPMI_REQ_LEN_INVALID_ERR;\n\tif (size > MAX_KCS_WRITE_SIZE)\n\t\treturn IPMI_REQ_LEN_EXCEEDED_ERR;\n\n\tif (kcs->state != KCS_IDLE) {\n\t\tdev_warn(kcs->io->dev, \"KCS in invalid state %d\\n\", kcs->state);\n\t\treturn IPMI_NOT_IN_MY_STATE_ERR;\n\t}\n\n\tif (kcs_debug & KCS_DEBUG_MSG) {\n\t\tdev_dbg(kcs->io->dev, \"%s -\", __func__);\n\t\tfor (i = 0; i < size; i++)\n\t\t\tpr_cont(\" %02x\", data[i]);\n\t\tpr_cont(\"\\n\");\n\t}\n\tkcs->error_retries = 0;\n\tmemcpy(kcs->write_data, data, size);\n\tkcs->write_count = size;\n\tkcs->orig_write_count = size;\n\tkcs->write_pos = 0;\n\tkcs->read_pos = 0;\n\tkcs->state = KCS_START_OP;\n\tkcs->ibf_timeout = IBF_RETRY_TIMEOUT;\n\tkcs->obf_timeout = OBF_RETRY_TIMEOUT;\n\treturn 0;\n}\n\nstatic int get_kcs_result(struct si_sm_data *kcs, unsigned char *data,\n\t\t\t  unsigned int length)\n{\n\tif (length < kcs->read_pos) {\n\t\tkcs->read_pos = length;\n\t\tkcs->truncated = 1;\n\t}\n\n\tmemcpy(data, kcs->read_data, kcs->read_pos);\n\n\tif ((length >= 3) && (kcs->read_pos < 3)) {\n\t\t \n\t\tdata[2] = IPMI_ERR_UNSPECIFIED;\n\t\tkcs->read_pos = 3;\n\t}\n\tif (kcs->truncated) {\n\t\t \n\t\tdata[2] = IPMI_ERR_MSG_TRUNCATED;\n\t\tkcs->truncated = 0;\n\t}\n\n\treturn kcs->read_pos;\n}\n\n \nstatic enum si_sm_result kcs_event(struct si_sm_data *kcs, long time)\n{\n\tunsigned char status;\n\tunsigned char state;\n\n\tstatus = read_status(kcs);\n\n\tif (kcs_debug & KCS_DEBUG_STATES)\n\t\tdev_dbg(kcs->io->dev,\n\t\t\t\"KCS: State = %d, %x\\n\", kcs->state, status);\n\n\t \n\tif (!check_ibf(kcs, status, time))\n\t\treturn SI_SM_CALL_WITH_DELAY;\n\n\t \n\tstate = GET_STATUS_STATE(status);\n\n\tswitch (kcs->state) {\n\tcase KCS_IDLE:\n\t\t \n\t\tclear_obf(kcs, status);\n\n\t\tif (GET_STATUS_ATN(status))\n\t\t\treturn SI_SM_ATTN;\n\t\telse\n\t\t\treturn SI_SM_IDLE;\n\n\tcase KCS_START_OP:\n\t\tif (state != KCS_IDLE_STATE) {\n\t\t\tstart_error_recovery(kcs,\n\t\t\t\t\t     \"State machine not idle at start\");\n\t\t\tbreak;\n\t\t}\n\n\t\tclear_obf(kcs, status);\n\t\twrite_cmd(kcs, KCS_WRITE_START);\n\t\tkcs->state = KCS_WAIT_WRITE_START;\n\t\tbreak;\n\n\tcase KCS_WAIT_WRITE_START:\n\t\tif (state != KCS_WRITE_STATE) {\n\t\t\tstart_error_recovery(\n\t\t\t\tkcs,\n\t\t\t\t\"Not in write state at write start\");\n\t\t\tbreak;\n\t\t}\n\t\tread_data(kcs);\n\t\tif (kcs->write_count == 1) {\n\t\t\twrite_cmd(kcs, KCS_WRITE_END);\n\t\t\tkcs->state = KCS_WAIT_WRITE_END;\n\t\t} else {\n\t\t\twrite_next_byte(kcs);\n\t\t\tkcs->state = KCS_WAIT_WRITE;\n\t\t}\n\t\tbreak;\n\n\tcase KCS_WAIT_WRITE:\n\t\tif (state != KCS_WRITE_STATE) {\n\t\t\tstart_error_recovery(kcs,\n\t\t\t\t\t     \"Not in write state for write\");\n\t\t\tbreak;\n\t\t}\n\t\tclear_obf(kcs, status);\n\t\tif (kcs->write_count == 1) {\n\t\t\twrite_cmd(kcs, KCS_WRITE_END);\n\t\t\tkcs->state = KCS_WAIT_WRITE_END;\n\t\t} else {\n\t\t\twrite_next_byte(kcs);\n\t\t}\n\t\tbreak;\n\n\tcase KCS_WAIT_WRITE_END:\n\t\tif (state != KCS_WRITE_STATE) {\n\t\t\tstart_error_recovery(kcs,\n\t\t\t\t\t     \"Not in write state\"\n\t\t\t\t\t     \" for write end\");\n\t\t\tbreak;\n\t\t}\n\t\tclear_obf(kcs, status);\n\t\twrite_next_byte(kcs);\n\t\tkcs->state = KCS_WAIT_READ;\n\t\tbreak;\n\n\tcase KCS_WAIT_READ:\n\t\tif ((state != KCS_READ_STATE) && (state != KCS_IDLE_STATE)) {\n\t\t\tstart_error_recovery(\n\t\t\t\tkcs,\n\t\t\t\t\"Not in read or idle in read state\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (state == KCS_READ_STATE) {\n\t\t\tif (!check_obf(kcs, status, time))\n\t\t\t\treturn SI_SM_CALL_WITH_DELAY;\n\t\t\tread_next_byte(kcs);\n\t\t} else {\n\t\t\t \n\t\t\tclear_obf(kcs, status);\n\t\t\tkcs->orig_write_count = 0;\n\t\t\tkcs->state = KCS_IDLE;\n\t\t\treturn SI_SM_TRANSACTION_COMPLETE;\n\t\t}\n\t\tbreak;\n\n\tcase KCS_ERROR0:\n\t\tclear_obf(kcs, status);\n\t\tstatus = read_status(kcs);\n\t\tif (GET_STATUS_OBF(status))\n\t\t\t \n\t\t\tif (time_before(jiffies, kcs->error0_timeout))\n\t\t\t\treturn SI_SM_CALL_WITH_TICK_DELAY;\n\t\twrite_cmd(kcs, KCS_GET_STATUS_ABORT);\n\t\tkcs->state = KCS_ERROR1;\n\t\tbreak;\n\n\tcase KCS_ERROR1:\n\t\tclear_obf(kcs, status);\n\t\twrite_data(kcs, 0);\n\t\tkcs->state = KCS_ERROR2;\n\t\tbreak;\n\n\tcase KCS_ERROR2:\n\t\tif (state != KCS_READ_STATE) {\n\t\t\tstart_error_recovery(kcs,\n\t\t\t\t\t     \"Not in read state for error2\");\n\t\t\tbreak;\n\t\t}\n\t\tif (!check_obf(kcs, status, time))\n\t\t\treturn SI_SM_CALL_WITH_DELAY;\n\n\t\tclear_obf(kcs, status);\n\t\twrite_data(kcs, KCS_READ_BYTE);\n\t\tkcs->state = KCS_ERROR3;\n\t\tbreak;\n\n\tcase KCS_ERROR3:\n\t\tif (state != KCS_IDLE_STATE) {\n\t\t\tstart_error_recovery(kcs,\n\t\t\t\t\t     \"Not in idle state for error3\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!check_obf(kcs, status, time))\n\t\t\treturn SI_SM_CALL_WITH_DELAY;\n\n\t\tclear_obf(kcs, status);\n\t\tif (kcs->orig_write_count) {\n\t\t\trestart_kcs_transaction(kcs);\n\t\t} else {\n\t\t\tkcs->state = KCS_IDLE;\n\t\t\treturn SI_SM_TRANSACTION_COMPLETE;\n\t\t}\n\t\tbreak;\n\n\tcase KCS_HOSED:\n\t\tbreak;\n\t}\n\n\tif (kcs->state == KCS_HOSED) {\n\t\tinit_kcs_data_with_state(kcs, kcs->io, KCS_ERROR0);\n\t\treturn SI_SM_HOSED;\n\t}\n\n\treturn SI_SM_CALL_WITHOUT_DELAY;\n}\n\nstatic int kcs_size(void)\n{\n\treturn sizeof(struct si_sm_data);\n}\n\nstatic int kcs_detect(struct si_sm_data *kcs)\n{\n\t \n\tif (read_status(kcs) == 0xff)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic void kcs_cleanup(struct si_sm_data *kcs)\n{\n}\n\nconst struct si_sm_handlers kcs_smi_handlers = {\n\t.init_data         = init_kcs_data,\n\t.start_transaction = start_kcs_transaction,\n\t.get_result        = get_kcs_result,\n\t.event             = kcs_event,\n\t.detect            = kcs_detect,\n\t.cleanup           = kcs_cleanup,\n\t.size              = kcs_size,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}