{
  "module_name": "bt-bmc.c",
  "hash_id": "109a431b6f7144e8a2f4759bf3ed5298c2146d2db9ad324dd7350c6ccf02f30e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/ipmi/bt-bmc.c",
  "human_readable_source": "\n \n\n#include <linux/atomic.h>\n#include <linux/bt-bmc.h>\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/miscdevice.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/poll.h>\n#include <linux/sched.h>\n#include <linux/timer.h>\n\n \n#define DEVICE_NAME\t\"ipmi-bt-host\"\n\n#define BT_IO_BASE\t0xe4\n#define BT_IRQ\t\t10\n\n#define BT_CR0\t\t0x0\n#define   BT_CR0_IO_BASE\t\t16\n#define   BT_CR0_IRQ\t\t\t12\n#define   BT_CR0_EN_CLR_SLV_RDP\t\t0x8\n#define   BT_CR0_EN_CLR_SLV_WRP\t\t0x4\n#define   BT_CR0_ENABLE_IBT\t\t0x1\n#define BT_CR1\t\t0x4\n#define   BT_CR1_IRQ_H2B\t0x01\n#define   BT_CR1_IRQ_HBUSY\t0x40\n#define BT_CR2\t\t0x8\n#define   BT_CR2_IRQ_H2B\t0x01\n#define   BT_CR2_IRQ_HBUSY\t0x40\n#define BT_CR3\t\t0xc\n#define BT_CTRL\t\t0x10\n#define   BT_CTRL_B_BUSY\t\t0x80\n#define   BT_CTRL_H_BUSY\t\t0x40\n#define   BT_CTRL_OEM0\t\t\t0x20\n#define   BT_CTRL_SMS_ATN\t\t0x10\n#define   BT_CTRL_B2H_ATN\t\t0x08\n#define   BT_CTRL_H2B_ATN\t\t0x04\n#define   BT_CTRL_CLR_RD_PTR\t\t0x02\n#define   BT_CTRL_CLR_WR_PTR\t\t0x01\n#define BT_BMC2HOST\t0x14\n#define BT_INTMASK\t0x18\n#define   BT_INTMASK_B2H_IRQEN\t\t0x01\n#define   BT_INTMASK_B2H_IRQ\t\t0x02\n#define   BT_INTMASK_BMC_HWRST\t\t0x80\n\n#define BT_BMC_BUFFER_SIZE 256\n\nstruct bt_bmc {\n\tstruct device\t\tdev;\n\tstruct miscdevice\tmiscdev;\n\tvoid __iomem\t\t*base;\n\tint\t\t\tirq;\n\twait_queue_head_t\tqueue;\n\tstruct timer_list\tpoll_timer;\n\tstruct mutex\t\tmutex;\n};\n\nstatic atomic_t open_count = ATOMIC_INIT(0);\n\nstatic u8 bt_inb(struct bt_bmc *bt_bmc, int reg)\n{\n\treturn readb(bt_bmc->base + reg);\n}\n\nstatic void bt_outb(struct bt_bmc *bt_bmc, u8 data, int reg)\n{\n\twriteb(data, bt_bmc->base + reg);\n}\n\nstatic void clr_rd_ptr(struct bt_bmc *bt_bmc)\n{\n\tbt_outb(bt_bmc, BT_CTRL_CLR_RD_PTR, BT_CTRL);\n}\n\nstatic void clr_wr_ptr(struct bt_bmc *bt_bmc)\n{\n\tbt_outb(bt_bmc, BT_CTRL_CLR_WR_PTR, BT_CTRL);\n}\n\nstatic void clr_h2b_atn(struct bt_bmc *bt_bmc)\n{\n\tbt_outb(bt_bmc, BT_CTRL_H2B_ATN, BT_CTRL);\n}\n\nstatic void set_b_busy(struct bt_bmc *bt_bmc)\n{\n\tif (!(bt_inb(bt_bmc, BT_CTRL) & BT_CTRL_B_BUSY))\n\t\tbt_outb(bt_bmc, BT_CTRL_B_BUSY, BT_CTRL);\n}\n\nstatic void clr_b_busy(struct bt_bmc *bt_bmc)\n{\n\tif (bt_inb(bt_bmc, BT_CTRL) & BT_CTRL_B_BUSY)\n\t\tbt_outb(bt_bmc, BT_CTRL_B_BUSY, BT_CTRL);\n}\n\nstatic void set_b2h_atn(struct bt_bmc *bt_bmc)\n{\n\tbt_outb(bt_bmc, BT_CTRL_B2H_ATN, BT_CTRL);\n}\n\nstatic u8 bt_read(struct bt_bmc *bt_bmc)\n{\n\treturn bt_inb(bt_bmc, BT_BMC2HOST);\n}\n\nstatic ssize_t bt_readn(struct bt_bmc *bt_bmc, u8 *buf, size_t n)\n{\n\tint i;\n\n\tfor (i = 0; i < n; i++)\n\t\tbuf[i] = bt_read(bt_bmc);\n\treturn n;\n}\n\nstatic void bt_write(struct bt_bmc *bt_bmc, u8 c)\n{\n\tbt_outb(bt_bmc, c, BT_BMC2HOST);\n}\n\nstatic ssize_t bt_writen(struct bt_bmc *bt_bmc, u8 *buf, size_t n)\n{\n\tint i;\n\n\tfor (i = 0; i < n; i++)\n\t\tbt_write(bt_bmc, buf[i]);\n\treturn n;\n}\n\nstatic void set_sms_atn(struct bt_bmc *bt_bmc)\n{\n\tbt_outb(bt_bmc, BT_CTRL_SMS_ATN, BT_CTRL);\n}\n\nstatic struct bt_bmc *file_bt_bmc(struct file *file)\n{\n\treturn container_of(file->private_data, struct bt_bmc, miscdev);\n}\n\nstatic int bt_bmc_open(struct inode *inode, struct file *file)\n{\n\tstruct bt_bmc *bt_bmc = file_bt_bmc(file);\n\n\tif (atomic_inc_return(&open_count) == 1) {\n\t\tclr_b_busy(bt_bmc);\n\t\treturn 0;\n\t}\n\n\tatomic_dec(&open_count);\n\treturn -EBUSY;\n}\n\n \nstatic ssize_t bt_bmc_read(struct file *file, char __user *buf,\n\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct bt_bmc *bt_bmc = file_bt_bmc(file);\n\tu8 len;\n\tint len_byte = 1;\n\tu8 kbuffer[BT_BMC_BUFFER_SIZE];\n\tssize_t ret = 0;\n\tssize_t nread;\n\n\tWARN_ON(*ppos);\n\n\tif (wait_event_interruptible(bt_bmc->queue,\n\t\t\t\t     bt_inb(bt_bmc, BT_CTRL) & BT_CTRL_H2B_ATN))\n\t\treturn -ERESTARTSYS;\n\n\tmutex_lock(&bt_bmc->mutex);\n\n\tif (unlikely(!(bt_inb(bt_bmc, BT_CTRL) & BT_CTRL_H2B_ATN))) {\n\t\tret = -EIO;\n\t\tgoto out_unlock;\n\t}\n\n\tset_b_busy(bt_bmc);\n\tclr_h2b_atn(bt_bmc);\n\tclr_rd_ptr(bt_bmc);\n\n\t \n\tkbuffer[0] = bt_read(bt_bmc);\n\tlen = kbuffer[0];\n\n\t \n\tif (len + 1 > count)\n\t\tlen = count - 1;\n\n\twhile (len) {\n\t\tnread = min_t(ssize_t, len, sizeof(kbuffer) - len_byte);\n\n\t\tbt_readn(bt_bmc, kbuffer + len_byte, nread);\n\n\t\tif (copy_to_user(buf, kbuffer, nread + len_byte)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tlen -= nread;\n\t\tbuf += nread + len_byte;\n\t\tret += nread + len_byte;\n\t\tlen_byte = 0;\n\t}\n\n\tclr_b_busy(bt_bmc);\n\nout_unlock:\n\tmutex_unlock(&bt_bmc->mutex);\n\treturn ret;\n}\n\n \nstatic ssize_t bt_bmc_write(struct file *file, const char __user *buf,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct bt_bmc *bt_bmc = file_bt_bmc(file);\n\tu8 kbuffer[BT_BMC_BUFFER_SIZE];\n\tssize_t ret = 0;\n\tssize_t nwritten;\n\n\t \n\tif (count < 5)\n\t\treturn -EINVAL;\n\n\tWARN_ON(*ppos);\n\n\t \n\tif (wait_event_interruptible(bt_bmc->queue,\n\t\t\t\t     !(bt_inb(bt_bmc, BT_CTRL) &\n\t\t\t\t       (BT_CTRL_H_BUSY | BT_CTRL_B2H_ATN))))\n\t\treturn -ERESTARTSYS;\n\n\tmutex_lock(&bt_bmc->mutex);\n\n\tif (unlikely(bt_inb(bt_bmc, BT_CTRL) &\n\t\t     (BT_CTRL_H_BUSY | BT_CTRL_B2H_ATN))) {\n\t\tret = -EIO;\n\t\tgoto out_unlock;\n\t}\n\n\tclr_wr_ptr(bt_bmc);\n\n\twhile (count) {\n\t\tnwritten = min_t(ssize_t, count, sizeof(kbuffer));\n\t\tif (copy_from_user(&kbuffer, buf, nwritten)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tbt_writen(bt_bmc, kbuffer, nwritten);\n\n\t\tcount -= nwritten;\n\t\tbuf += nwritten;\n\t\tret += nwritten;\n\t}\n\n\tset_b2h_atn(bt_bmc);\n\nout_unlock:\n\tmutex_unlock(&bt_bmc->mutex);\n\treturn ret;\n}\n\nstatic long bt_bmc_ioctl(struct file *file, unsigned int cmd,\n\t\t\t unsigned long param)\n{\n\tstruct bt_bmc *bt_bmc = file_bt_bmc(file);\n\n\tswitch (cmd) {\n\tcase BT_BMC_IOCTL_SMS_ATN:\n\t\tset_sms_atn(bt_bmc);\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int bt_bmc_release(struct inode *inode, struct file *file)\n{\n\tstruct bt_bmc *bt_bmc = file_bt_bmc(file);\n\n\tatomic_dec(&open_count);\n\tset_b_busy(bt_bmc);\n\treturn 0;\n}\n\nstatic __poll_t bt_bmc_poll(struct file *file, poll_table *wait)\n{\n\tstruct bt_bmc *bt_bmc = file_bt_bmc(file);\n\t__poll_t mask = 0;\n\tu8 ctrl;\n\n\tpoll_wait(file, &bt_bmc->queue, wait);\n\n\tctrl = bt_inb(bt_bmc, BT_CTRL);\n\n\tif (ctrl & BT_CTRL_H2B_ATN)\n\t\tmask |= EPOLLIN;\n\n\tif (!(ctrl & (BT_CTRL_H_BUSY | BT_CTRL_B2H_ATN)))\n\t\tmask |= EPOLLOUT;\n\n\treturn mask;\n}\n\nstatic const struct file_operations bt_bmc_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= bt_bmc_open,\n\t.read\t\t= bt_bmc_read,\n\t.write\t\t= bt_bmc_write,\n\t.release\t= bt_bmc_release,\n\t.poll\t\t= bt_bmc_poll,\n\t.unlocked_ioctl\t= bt_bmc_ioctl,\n};\n\nstatic void poll_timer(struct timer_list *t)\n{\n\tstruct bt_bmc *bt_bmc = from_timer(bt_bmc, t, poll_timer);\n\n\tbt_bmc->poll_timer.expires += msecs_to_jiffies(500);\n\twake_up(&bt_bmc->queue);\n\tadd_timer(&bt_bmc->poll_timer);\n}\n\nstatic irqreturn_t bt_bmc_irq(int irq, void *arg)\n{\n\tstruct bt_bmc *bt_bmc = arg;\n\tu32 reg;\n\n\treg = readl(bt_bmc->base + BT_CR2);\n\n\treg &= BT_CR2_IRQ_H2B | BT_CR2_IRQ_HBUSY;\n\tif (!reg)\n\t\treturn IRQ_NONE;\n\n\t \n\twritel(reg, bt_bmc->base + BT_CR2);\n\n\twake_up(&bt_bmc->queue);\n\treturn IRQ_HANDLED;\n}\n\nstatic int bt_bmc_config_irq(struct bt_bmc *bt_bmc,\n\t\t\t     struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tint rc;\n\tu32 reg;\n\n\tbt_bmc->irq = platform_get_irq_optional(pdev, 0);\n\tif (bt_bmc->irq < 0)\n\t\treturn bt_bmc->irq;\n\n\trc = devm_request_irq(dev, bt_bmc->irq, bt_bmc_irq, IRQF_SHARED,\n\t\t\t      DEVICE_NAME, bt_bmc);\n\tif (rc < 0) {\n\t\tdev_warn(dev, \"Unable to request IRQ %d\\n\", bt_bmc->irq);\n\t\tbt_bmc->irq = rc;\n\t\treturn rc;\n\t}\n\n\t \n\treg = readl(bt_bmc->base + BT_CR1);\n\treg |= BT_CR1_IRQ_H2B | BT_CR1_IRQ_HBUSY;\n\twritel(reg, bt_bmc->base + BT_CR1);\n\n\treturn 0;\n}\n\nstatic int bt_bmc_probe(struct platform_device *pdev)\n{\n\tstruct bt_bmc *bt_bmc;\n\tstruct device *dev;\n\tint rc;\n\n\tdev = &pdev->dev;\n\tdev_info(dev, \"Found bt bmc device\\n\");\n\n\tbt_bmc = devm_kzalloc(dev, sizeof(*bt_bmc), GFP_KERNEL);\n\tif (!bt_bmc)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(&pdev->dev, bt_bmc);\n\n\tbt_bmc->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(bt_bmc->base))\n\t\treturn PTR_ERR(bt_bmc->base);\n\n\tmutex_init(&bt_bmc->mutex);\n\tinit_waitqueue_head(&bt_bmc->queue);\n\n\tbt_bmc->miscdev.minor\t= MISC_DYNAMIC_MINOR;\n\tbt_bmc->miscdev.name\t= DEVICE_NAME;\n\tbt_bmc->miscdev.fops\t= &bt_bmc_fops;\n\tbt_bmc->miscdev.parent = dev;\n\trc = misc_register(&bt_bmc->miscdev);\n\tif (rc) {\n\t\tdev_err(dev, \"Unable to register misc device\\n\");\n\t\treturn rc;\n\t}\n\n\tbt_bmc_config_irq(bt_bmc, pdev);\n\n\tif (bt_bmc->irq >= 0) {\n\t\tdev_info(dev, \"Using IRQ %d\\n\", bt_bmc->irq);\n\t} else {\n\t\tdev_info(dev, \"No IRQ; using timer\\n\");\n\t\ttimer_setup(&bt_bmc->poll_timer, poll_timer, 0);\n\t\tbt_bmc->poll_timer.expires = jiffies + msecs_to_jiffies(10);\n\t\tadd_timer(&bt_bmc->poll_timer);\n\t}\n\n\twritel((BT_IO_BASE << BT_CR0_IO_BASE) |\n\t\t     (BT_IRQ << BT_CR0_IRQ) |\n\t\t     BT_CR0_EN_CLR_SLV_RDP |\n\t\t     BT_CR0_EN_CLR_SLV_WRP |\n\t\t     BT_CR0_ENABLE_IBT,\n\t\tbt_bmc->base + BT_CR0);\n\n\tclr_b_busy(bt_bmc);\n\n\treturn 0;\n}\n\nstatic int bt_bmc_remove(struct platform_device *pdev)\n{\n\tstruct bt_bmc *bt_bmc = dev_get_drvdata(&pdev->dev);\n\n\tmisc_deregister(&bt_bmc->miscdev);\n\tif (bt_bmc->irq < 0)\n\t\tdel_timer_sync(&bt_bmc->poll_timer);\n\treturn 0;\n}\n\nstatic const struct of_device_id bt_bmc_match[] = {\n\t{ .compatible = \"aspeed,ast2400-ibt-bmc\" },\n\t{ .compatible = \"aspeed,ast2500-ibt-bmc\" },\n\t{ .compatible = \"aspeed,ast2600-ibt-bmc\" },\n\t{ },\n};\n\nstatic struct platform_driver bt_bmc_driver = {\n\t.driver = {\n\t\t.name\t\t= DEVICE_NAME,\n\t\t.of_match_table = bt_bmc_match,\n\t},\n\t.probe = bt_bmc_probe,\n\t.remove = bt_bmc_remove,\n};\n\nmodule_platform_driver(bt_bmc_driver);\n\nMODULE_DEVICE_TABLE(of, bt_bmc_match);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Alistair Popple <alistair@popple.id.au>\");\nMODULE_DESCRIPTION(\"Linux device interface to the IPMI BT interface\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}