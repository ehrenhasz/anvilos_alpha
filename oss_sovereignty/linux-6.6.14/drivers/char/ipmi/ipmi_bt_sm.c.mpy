{
  "module_name": "ipmi_bt_sm.c",
  "hash_id": "8f4084a902b427b101f7c7361dabcb0edfedde17979d8a0dec318d1d41a6d394",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/ipmi/ipmi_bt_sm.c",
  "human_readable_source": "\n \n\n#define DEBUG  \n\n#include <linux/kernel.h>  \n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/ipmi_msgdefs.h>\t\t \n#include \"ipmi_si_sm.h\"\n\n#define BT_DEBUG_OFF\t0\t \n#define BT_DEBUG_ENABLE\t1\t \n#define BT_DEBUG_MSG\t2\t \n#define BT_DEBUG_STATES\t4\t \n \n\nstatic int bt_debug;  \n\nmodule_param(bt_debug, int, 0644);\nMODULE_PARM_DESC(bt_debug, \"debug bitmask, 1=enable, 2=messages, 4=states\");\n\n \n\n#define BT_NORMAL_TIMEOUT\t5\t \n#define BT_NORMAL_RETRY_LIMIT\t2\n#define BT_RESET_DELAY\t\t6\t \n\n \n\nenum bt_states {\n\tBT_STATE_IDLE = 0,\t \n\tBT_STATE_XACTION_START,\n\tBT_STATE_WRITE_BYTES,\n\tBT_STATE_WRITE_CONSUME,\n\tBT_STATE_READ_WAIT,\n\tBT_STATE_CLEAR_B2H,\n\tBT_STATE_READ_BYTES,\n\tBT_STATE_RESET1,\t \n\tBT_STATE_RESET2,\n\tBT_STATE_RESET3,\n\tBT_STATE_RESTART,\n\tBT_STATE_PRINTME,\n\tBT_STATE_LONG_BUSY\t \n};\n\n \n\n#define BT_STATE_CHANGE(X, Y) { bt->state = X; return Y; }\n\n#define BT_SI_SM_RETURN(Y)   { last_printed = BT_STATE_PRINTME; return Y; }\n\nstruct si_sm_data {\n\tenum bt_states\tstate;\n\tunsigned char\tseq;\t\t \n\tstruct si_sm_io\t*io;\n\tunsigned char\twrite_data[IPMI_MAX_MSG_LENGTH + 2];  \n\tint\t\twrite_count;\n\tunsigned char\tread_data[IPMI_MAX_MSG_LENGTH + 2];  \n\tint\t\tread_count;\n\tint\t\ttruncated;\n\tlong\t\ttimeout;\t \n\tint\t\terror_retries;\t \n\tint\t\tnonzero_status;\t \n\tenum bt_states\tcomplete;\t \n\tlong\t\tBT_CAP_req2rsp;\n\tint\t\tBT_CAP_retries;\t \n};\n\n#define BT_CLR_WR_PTR\t0x01\t \n#define BT_CLR_RD_PTR\t0x02\n#define BT_H2B_ATN\t0x04\n#define BT_B2H_ATN\t0x08\n#define BT_SMS_ATN\t0x10\n#define BT_OEM0\t\t0x20\n#define BT_H_BUSY\t0x40\n#define BT_B_BUSY\t0x80\n\n \n\n#define BT_STATUS\tbt->io->inputb(bt->io, 0)\n#define BT_CONTROL(x)\tbt->io->outputb(bt->io, 0, x)\n\n#define BMC2HOST\tbt->io->inputb(bt->io, 1)\n#define HOST2BMC(x)\tbt->io->outputb(bt->io, 1, x)\n\n#define BT_INTMASK_R\tbt->io->inputb(bt->io, 2)\n#define BT_INTMASK_W(x)\tbt->io->outputb(bt->io, 2, x)\n\n \n\nstatic char *state2txt(unsigned char state)\n{\n\tswitch (state) {\n\tcase BT_STATE_IDLE:\t\treturn(\"IDLE\");\n\tcase BT_STATE_XACTION_START:\treturn(\"XACTION\");\n\tcase BT_STATE_WRITE_BYTES:\treturn(\"WR_BYTES\");\n\tcase BT_STATE_WRITE_CONSUME:\treturn(\"WR_CONSUME\");\n\tcase BT_STATE_READ_WAIT:\treturn(\"RD_WAIT\");\n\tcase BT_STATE_CLEAR_B2H:\treturn(\"CLEAR_B2H\");\n\tcase BT_STATE_READ_BYTES:\treturn(\"RD_BYTES\");\n\tcase BT_STATE_RESET1:\t\treturn(\"RESET1\");\n\tcase BT_STATE_RESET2:\t\treturn(\"RESET2\");\n\tcase BT_STATE_RESET3:\t\treturn(\"RESET3\");\n\tcase BT_STATE_RESTART:\t\treturn(\"RESTART\");\n\tcase BT_STATE_LONG_BUSY:\treturn(\"LONG_BUSY\");\n\t}\n\treturn(\"BAD STATE\");\n}\n#define STATE2TXT state2txt(bt->state)\n\nstatic char *status2txt(unsigned char status)\n{\n\t \n\tstatic char buf[40];\n\n\tstrcpy(buf, \"[ \");\n\tif (status & BT_B_BUSY)\n\t\tstrcat(buf, \"B_BUSY \");\n\tif (status & BT_H_BUSY)\n\t\tstrcat(buf, \"H_BUSY \");\n\tif (status & BT_OEM0)\n\t\tstrcat(buf, \"OEM0 \");\n\tif (status & BT_SMS_ATN)\n\t\tstrcat(buf, \"SMS \");\n\tif (status & BT_B2H_ATN)\n\t\tstrcat(buf, \"B2H \");\n\tif (status & BT_H2B_ATN)\n\t\tstrcat(buf, \"H2B \");\n\tstrcat(buf, \"]\");\n\treturn buf;\n}\n#define STATUS2TXT status2txt(status)\n\n \n\nstatic unsigned int bt_init_data(struct si_sm_data *bt, struct si_sm_io *io)\n{\n\tmemset(bt, 0, sizeof(struct si_sm_data));\n\tif (bt->io != io) {\n\t\t \n\t\tbt->io = io;\n\t\tbt->seq = 0;\n\t}\n\tbt->state = BT_STATE_IDLE;\t \n\tbt->complete = BT_STATE_IDLE;\t \n\tbt->BT_CAP_req2rsp = BT_NORMAL_TIMEOUT * USEC_PER_SEC;\n\tbt->BT_CAP_retries = BT_NORMAL_RETRY_LIMIT;\n\treturn 3;  \n}\n\n \n\nstatic void force_result(struct si_sm_data *bt, unsigned char completion_code)\n{\n\tbt->read_data[0] = 4;\t\t\t\t \n\tbt->read_data[1] = bt->write_data[1] | 4;\t \n\tbt->read_data[2] = bt->write_data[2];\t\t \n\tbt->read_data[3] = bt->write_data[3];\t\t \n\tbt->read_data[4] = completion_code;\n\tbt->read_count = 5;\n}\n\n \n\nstatic int bt_start_transaction(struct si_sm_data *bt,\n\t\t\t\tunsigned char *data,\n\t\t\t\tunsigned int size)\n{\n\tunsigned int i;\n\n\tif (size < 2)\n\t\treturn IPMI_REQ_LEN_INVALID_ERR;\n\tif (size > IPMI_MAX_MSG_LENGTH)\n\t\treturn IPMI_REQ_LEN_EXCEEDED_ERR;\n\n\tif (bt->state == BT_STATE_LONG_BUSY)\n\t\treturn IPMI_NODE_BUSY_ERR;\n\n\tif (bt->state != BT_STATE_IDLE) {\n\t\tdev_warn(bt->io->dev, \"BT in invalid state %d\\n\", bt->state);\n\t\treturn IPMI_NOT_IN_MY_STATE_ERR;\n\t}\n\n\tif (bt_debug & BT_DEBUG_MSG) {\n\t\tdev_dbg(bt->io->dev, \"+++++++++++++++++ New command\\n\");\n\t\tdev_dbg(bt->io->dev, \"NetFn/LUN CMD [%d data]:\", size - 2);\n\t\tfor (i = 0; i < size; i ++)\n\t\t\tpr_cont(\" %02x\", data[i]);\n\t\tpr_cont(\"\\n\");\n\t}\n\tbt->write_data[0] = size + 1;\t \n\tbt->write_data[1] = *data;\t \n\tbt->write_data[2] = bt->seq++;\n\tmemcpy(bt->write_data + 3, data + 1, size - 1);\n\tbt->write_count = size + 2;\n\tbt->error_retries = 0;\n\tbt->nonzero_status = 0;\n\tbt->truncated = 0;\n\tbt->state = BT_STATE_XACTION_START;\n\tbt->timeout = bt->BT_CAP_req2rsp;\n\tforce_result(bt, IPMI_ERR_UNSPECIFIED);\n\treturn 0;\n}\n\n \n\nstatic int bt_get_result(struct si_sm_data *bt,\n\t\t\t unsigned char *data,\n\t\t\t unsigned int length)\n{\n\tint i, msg_len;\n\n\tmsg_len = bt->read_count - 2;\t\t \n\tif (msg_len < 3 || msg_len > IPMI_MAX_MSG_LENGTH) {\n\t\tforce_result(bt, IPMI_ERR_UNSPECIFIED);\n\t\tmsg_len = 3;\n\t}\n\tdata[0] = bt->read_data[1];\n\tdata[1] = bt->read_data[3];\n\tif (length < msg_len || bt->truncated) {\n\t\tdata[2] = IPMI_ERR_MSG_TRUNCATED;\n\t\tmsg_len = 3;\n\t} else\n\t\tmemcpy(data + 2, bt->read_data + 4, msg_len - 2);\n\n\tif (bt_debug & BT_DEBUG_MSG) {\n\t\tdev_dbg(bt->io->dev, \"result %d bytes:\", msg_len);\n\t\tfor (i = 0; i < msg_len; i++)\n\t\t\tpr_cont(\" %02x\", data[i]);\n\t\tpr_cont(\"\\n\");\n\t}\n\treturn msg_len;\n}\n\n \n#define BT_BMC_HWRST\t0x80\n\nstatic void reset_flags(struct si_sm_data *bt)\n{\n\tif (bt_debug)\n\t\tdev_dbg(bt->io->dev, \"flag reset %s\\n\", status2txt(BT_STATUS));\n\tif (BT_STATUS & BT_H_BUSY)\n\t\tBT_CONTROL(BT_H_BUSY);\t \n\tBT_CONTROL(BT_CLR_WR_PTR);\t \n\tBT_CONTROL(BT_SMS_ATN);\t\t \n\tBT_INTMASK_W(BT_BMC_HWRST);\n}\n\n \n\nstatic void drain_BMC2HOST(struct si_sm_data *bt)\n{\n\tint i, size;\n\n\tif (!(BT_STATUS & BT_B2H_ATN)) \t \n\t\treturn;\n\n\tBT_CONTROL(BT_H_BUSY);\t\t \n\tBT_CONTROL(BT_B2H_ATN);\t\t \n\tBT_STATUS;\t\t\t \n\tBT_CONTROL(BT_B2H_ATN);\t\t \n\tBT_CONTROL(BT_CLR_RD_PTR);\t \n\tif (bt_debug)\n\t\tdev_dbg(bt->io->dev, \"stale response %s; \",\n\t\t\tstatus2txt(BT_STATUS));\n\tsize = BMC2HOST;\n\tfor (i = 0; i < size ; i++)\n\t\tBMC2HOST;\n\tBT_CONTROL(BT_H_BUSY);\t\t \n\tif (bt_debug)\n\t\tpr_cont(\"drained %d bytes\\n\", size + 1);\n}\n\nstatic inline void write_all_bytes(struct si_sm_data *bt)\n{\n\tint i;\n\n\tif (bt_debug & BT_DEBUG_MSG) {\n\t\tdev_dbg(bt->io->dev, \"write %d bytes seq=0x%02X\",\n\t\t\tbt->write_count, bt->seq);\n\t\tfor (i = 0; i < bt->write_count; i++)\n\t\t\tpr_cont(\" %02x\", bt->write_data[i]);\n\t\tpr_cont(\"\\n\");\n\t}\n\tfor (i = 0; i < bt->write_count; i++)\n\t\tHOST2BMC(bt->write_data[i]);\n}\n\nstatic inline int read_all_bytes(struct si_sm_data *bt)\n{\n\tunsigned int i;\n\n\t \n\n\tbt->read_data[0] = BMC2HOST;\n\tbt->read_count = bt->read_data[0];\n\n\tif (bt->read_count < 4 || bt->read_count >= IPMI_MAX_MSG_LENGTH) {\n\t\tif (bt_debug & BT_DEBUG_MSG)\n\t\t\tdev_dbg(bt->io->dev,\n\t\t\t\t\"bad raw rsp len=%d\\n\", bt->read_count);\n\t\tbt->truncated = 1;\n\t\treturn 1;\t \n\t}\n\tfor (i = 1; i <= bt->read_count; i++)\n\t\tbt->read_data[i] = BMC2HOST;\n\tbt->read_count++;\t \n\n\tif (bt_debug & BT_DEBUG_MSG) {\n\t\tint max = bt->read_count;\n\n\t\tdev_dbg(bt->io->dev,\n\t\t\t\"got %d bytes seq=0x%02X\", max, bt->read_data[2]);\n\t\tif (max > 16)\n\t\t\tmax = 16;\n\t\tfor (i = 0; i < max; i++)\n\t\t\tpr_cont(\" %02x\", bt->read_data[i]);\n\t\tpr_cont(\"%s\\n\", bt->read_count == max ? \"\" : \" ...\");\n\t}\n\n\t \n\tif ((bt->read_data[3] == bt->write_data[3]) &&\n\t    (bt->read_data[2] == bt->write_data[2]) &&\n\t    ((bt->read_data[1] & 0xF8) == (bt->write_data[1] & 0xF8)))\n\t\t\treturn 1;\n\n\tif (bt_debug & BT_DEBUG_MSG)\n\t\tdev_dbg(bt->io->dev,\n\t\t\t\"IPMI BT: bad packet: want 0x(%02X, %02X, %02X) got (%02X, %02X, %02X)\\n\",\n\t\t\tbt->write_data[1] | 0x04, bt->write_data[2],\n\t\t\tbt->write_data[3],\n\t\t\tbt->read_data[1],  bt->read_data[2],  bt->read_data[3]);\n\treturn 0;\n}\n\n \n\nstatic enum si_sm_result error_recovery(struct si_sm_data *bt,\n\t\t\t\t\tunsigned char status,\n\t\t\t\t\tunsigned char cCode)\n{\n\tchar *reason;\n\n\tbt->timeout = bt->BT_CAP_req2rsp;\n\n\tswitch (cCode) {\n\tcase IPMI_TIMEOUT_ERR:\n\t\treason = \"timeout\";\n\t\tbreak;\n\tdefault:\n\t\treason = \"internal error\";\n\t\tbreak;\n\t}\n\n\tdev_warn(bt->io->dev, \"IPMI BT: %s in %s %s \",  \n\t\t reason, STATE2TXT, STATUS2TXT);\n\n\t \n\t(bt->error_retries)++;\n\tif (bt->error_retries < bt->BT_CAP_retries) {\n\t\tpr_cont(\"%d retries left\\n\",\n\t\t\tbt->BT_CAP_retries - bt->error_retries);\n\t\tbt->state = BT_STATE_RESTART;\n\t\treturn SI_SM_CALL_WITHOUT_DELAY;\n\t}\n\n\tdev_warn(bt->io->dev, \"failed %d retries, sending error response\\n\",\n\t\t bt->BT_CAP_retries);\n\tif (!bt->nonzero_status)\n\t\tdev_err(bt->io->dev, \"stuck, try power cycle\\n\");\n\n\t \n\telse if (bt->seq <= (unsigned char)(bt->BT_CAP_retries & 0xFF)) {\n\t\tdev_warn(bt->io->dev, \"BT reset (takes 5 secs)\\n\");\n\t\tbt->state = BT_STATE_RESET1;\n\t\treturn SI_SM_CALL_WITHOUT_DELAY;\n\t}\n\n\t \n\n\tbt->state = BT_STATE_IDLE;\n\tswitch (cCode) {\n\tcase IPMI_TIMEOUT_ERR:\n\t\tif (status & BT_B_BUSY) {\n\t\t\tcCode = IPMI_NODE_BUSY_ERR;\n\t\t\tbt->state = BT_STATE_LONG_BUSY;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tforce_result(bt, cCode);\n\treturn SI_SM_TRANSACTION_COMPLETE;\n}\n\n \n\nstatic enum si_sm_result bt_event(struct si_sm_data *bt, long time)\n{\n\tunsigned char status;\n\tstatic enum bt_states last_printed = BT_STATE_PRINTME;\n\tint i;\n\n\tstatus = BT_STATUS;\n\tbt->nonzero_status |= status;\n\tif ((bt_debug & BT_DEBUG_STATES) && (bt->state != last_printed)) {\n\t\tdev_dbg(bt->io->dev, \"BT: %s %s TO=%ld - %ld\\n\",\n\t\t\tSTATE2TXT,\n\t\t\tSTATUS2TXT,\n\t\t\tbt->timeout,\n\t\t\ttime);\n\t\tlast_printed = bt->state;\n\t}\n\n\t \n\n\tif ((bt->state < BT_STATE_WRITE_BYTES) && (status & BT_B2H_ATN)) {\n\t\tdrain_BMC2HOST(bt);\n\t\tBT_SI_SM_RETURN(SI_SM_CALL_WITH_DELAY);\n\t}\n\n\tif ((bt->state != BT_STATE_IDLE) &&\n\t    (bt->state <  BT_STATE_PRINTME)) {\n\t\t \n\t\tbt->timeout -= time;\n\t\tif ((bt->timeout < 0) && (bt->state < BT_STATE_RESET1))\n\t\t\treturn error_recovery(bt,\n\t\t\t\t\t      status,\n\t\t\t\t\t      IPMI_TIMEOUT_ERR);\n\t}\n\n\tswitch (bt->state) {\n\n\t \n\n\tcase BT_STATE_IDLE:\n\t\tif (status & BT_SMS_ATN) {\n\t\t\tBT_CONTROL(BT_SMS_ATN);\t \n\t\t\treturn SI_SM_ATTN;\n\t\t}\n\n\t\tif (status & BT_H_BUSY)\t\t \n\t\t\tBT_CONTROL(BT_H_BUSY);\n\n\t\tBT_SI_SM_RETURN(SI_SM_IDLE);\n\n\tcase BT_STATE_XACTION_START:\n\t\tif (status & (BT_B_BUSY | BT_H2B_ATN))\n\t\t\tBT_SI_SM_RETURN(SI_SM_CALL_WITH_DELAY);\n\t\tif (BT_STATUS & BT_H_BUSY)\n\t\t\tBT_CONTROL(BT_H_BUSY);\t \n\t\tBT_STATE_CHANGE(BT_STATE_WRITE_BYTES,\n\t\t\t\tSI_SM_CALL_WITHOUT_DELAY);\n\n\tcase BT_STATE_WRITE_BYTES:\n\t\tif (status & BT_H_BUSY)\n\t\t\tBT_CONTROL(BT_H_BUSY);\t \n\t\tBT_CONTROL(BT_CLR_WR_PTR);\n\t\twrite_all_bytes(bt);\n\t\tBT_CONTROL(BT_H2B_ATN);\t \n\t\tBT_STATE_CHANGE(BT_STATE_WRITE_CONSUME,\n\t\t\t\tSI_SM_CALL_WITHOUT_DELAY);\n\n\tcase BT_STATE_WRITE_CONSUME:\n\t\tif (status & (BT_B_BUSY | BT_H2B_ATN))\n\t\t\tBT_SI_SM_RETURN(SI_SM_CALL_WITH_DELAY);\n\t\tBT_STATE_CHANGE(BT_STATE_READ_WAIT,\n\t\t\t\tSI_SM_CALL_WITHOUT_DELAY);\n\n\t \n\n\tcase BT_STATE_READ_WAIT:\n\t\tif (!(status & BT_B2H_ATN))\n\t\t\tBT_SI_SM_RETURN(SI_SM_CALL_WITH_DELAY);\n\t\tBT_CONTROL(BT_H_BUSY);\t\t \n\n\t\t \n\n\t\tBT_CONTROL(BT_B2H_ATN);\t\t \n\t\tBT_STATE_CHANGE(BT_STATE_CLEAR_B2H,\n\t\t\t\tSI_SM_CALL_WITHOUT_DELAY);\n\n\tcase BT_STATE_CLEAR_B2H:\n\t\tif (status & BT_B2H_ATN) {\n\t\t\t \n\t\t\tBT_CONTROL(BT_B2H_ATN);\n\t\t\tBT_SI_SM_RETURN(SI_SM_CALL_WITH_DELAY);\n\t\t}\n\t\tBT_STATE_CHANGE(BT_STATE_READ_BYTES,\n\t\t\t\tSI_SM_CALL_WITHOUT_DELAY);\n\n\tcase BT_STATE_READ_BYTES:\n\t\tif (!(status & BT_H_BUSY))\n\t\t\t \n\t\t\tBT_CONTROL(BT_H_BUSY);\n\t\tBT_CONTROL(BT_CLR_RD_PTR);\t \n\t\ti = read_all_bytes(bt);\t\t \n\t\tBT_CONTROL(BT_H_BUSY);\t\t \n\t\tif (!i) \t\t\t \n\t\t\tBT_STATE_CHANGE(BT_STATE_READ_WAIT,\n\t\t\t\t\tSI_SM_CALL_WITHOUT_DELAY);\n\t\tbt->state = bt->complete;\n\t\treturn bt->state == BT_STATE_IDLE ?\t \n\t\t\tSI_SM_TRANSACTION_COMPLETE :\t \n\t\t\tSI_SM_CALL_WITHOUT_DELAY;\t \n\n\tcase BT_STATE_LONG_BUSY:\t \n\t\tif (!(status & BT_B_BUSY)) {\n\t\t\treset_flags(bt);\t \n\t\t\tbt_init_data(bt, bt->io);\n\t\t}\n\t\treturn SI_SM_CALL_WITH_DELAY;\t \n\n\tcase BT_STATE_RESET1:\n\t\treset_flags(bt);\n\t\tdrain_BMC2HOST(bt);\n\t\tBT_STATE_CHANGE(BT_STATE_RESET2,\n\t\t\t\tSI_SM_CALL_WITH_DELAY);\n\n\tcase BT_STATE_RESET2:\t\t \n\t\tBT_CONTROL(BT_CLR_WR_PTR);\n\t\tHOST2BMC(3);\t\t \n\t\tHOST2BMC(0x18);\t\t \n\t\tHOST2BMC(42);\t\t \n\t\tHOST2BMC(3);\t\t \n\t\tBT_CONTROL(BT_H2B_ATN);\n\t\tbt->timeout = BT_RESET_DELAY * USEC_PER_SEC;\n\t\tBT_STATE_CHANGE(BT_STATE_RESET3,\n\t\t\t\tSI_SM_CALL_WITH_DELAY);\n\n\tcase BT_STATE_RESET3:\t\t \n\t\tif (bt->timeout > 0)\n\t\t\treturn SI_SM_CALL_WITH_DELAY;\n\t\tdrain_BMC2HOST(bt);\n\t\tBT_STATE_CHANGE(BT_STATE_RESTART,\n\t\t\t\tSI_SM_CALL_WITH_DELAY);\n\n\tcase BT_STATE_RESTART:\t\t \n\t\tbt->read_count = 0;\n\t\tbt->nonzero_status = 0;\n\t\tbt->timeout = bt->BT_CAP_req2rsp;\n\t\tBT_STATE_CHANGE(BT_STATE_XACTION_START,\n\t\t\t\tSI_SM_CALL_WITH_DELAY);\n\n\tdefault:\t \n\t\treturn error_recovery(bt,\n\t\t\t\t      status,\n\t\t\t\t      IPMI_ERR_UNSPECIFIED);\n\t}\n\treturn SI_SM_CALL_WITH_DELAY;\n}\n\nstatic int bt_detect(struct si_sm_data *bt)\n{\n\tunsigned char GetBT_CAP[] = { 0x18, 0x36 };\n\tunsigned char BT_CAP[8];\n\tenum si_sm_result smi_result;\n\tint rv;\n\n\t \n\n\tif ((BT_STATUS == 0xFF) && (BT_INTMASK_R == 0xFF))\n\t\treturn 1;\n\treset_flags(bt);\n\n\t \n\trv = bt_start_transaction(bt, GetBT_CAP, sizeof(GetBT_CAP));\n\tif (rv) {\n\t\tdev_warn(bt->io->dev,\n\t\t\t \"Can't start capabilities transaction: %d\\n\", rv);\n\t\tgoto out_no_bt_cap;\n\t}\n\n\tsmi_result = SI_SM_CALL_WITHOUT_DELAY;\n\tfor (;;) {\n\t\tif (smi_result == SI_SM_CALL_WITH_DELAY ||\n\t\t    smi_result == SI_SM_CALL_WITH_TICK_DELAY) {\n\t\t\tschedule_timeout_uninterruptible(1);\n\t\t\tsmi_result = bt_event(bt, jiffies_to_usecs(1));\n\t\t} else if (smi_result == SI_SM_CALL_WITHOUT_DELAY) {\n\t\t\tsmi_result = bt_event(bt, 0);\n\t\t} else\n\t\t\tbreak;\n\t}\n\n\trv = bt_get_result(bt, BT_CAP, sizeof(BT_CAP));\n\tbt_init_data(bt, bt->io);\n\tif (rv < 8) {\n\t\tdev_warn(bt->io->dev, \"bt cap response too short: %d\\n\", rv);\n\t\tgoto out_no_bt_cap;\n\t}\n\n\tif (BT_CAP[2]) {\n\t\tdev_warn(bt->io->dev, \"Error fetching bt cap: %x\\n\", BT_CAP[2]);\nout_no_bt_cap:\n\t\tdev_warn(bt->io->dev, \"using default values\\n\");\n\t} else {\n\t\tbt->BT_CAP_req2rsp = BT_CAP[6] * USEC_PER_SEC;\n\t\tbt->BT_CAP_retries = BT_CAP[7];\n\t}\n\n\tdev_info(bt->io->dev, \"req2rsp=%ld secs retries=%d\\n\",\n\t\t bt->BT_CAP_req2rsp / USEC_PER_SEC, bt->BT_CAP_retries);\n\n\treturn 0;\n}\n\nstatic void bt_cleanup(struct si_sm_data *bt)\n{\n}\n\nstatic int bt_size(void)\n{\n\treturn sizeof(struct si_sm_data);\n}\n\nconst struct si_sm_handlers bt_smi_handlers = {\n\t.init_data\t\t= bt_init_data,\n\t.start_transaction\t= bt_start_transaction,\n\t.get_result\t\t= bt_get_result,\n\t.event\t\t\t= bt_event,\n\t.detect\t\t\t= bt_detect,\n\t.cleanup\t\t= bt_cleanup,\n\t.size\t\t\t= bt_size,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}