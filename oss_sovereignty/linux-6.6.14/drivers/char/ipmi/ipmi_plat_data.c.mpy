{
  "module_name": "ipmi_plat_data.c",
  "hash_id": "1ff2bc7b46e6cb9dc2cd9056c44e3473f27410ce003940f206af906b7842dd21",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/ipmi/ipmi_plat_data.c",
  "human_readable_source": "\n\n \n\n#include <linux/platform_device.h>\n#include \"ipmi_plat_data.h\"\n#include \"ipmi_si.h\"\n\nstruct platform_device *ipmi_platform_add(const char *name, unsigned int inst,\n\t\t\t\t\t  struct ipmi_plat_data *p)\n{\n\tstruct platform_device *pdev;\n\tunsigned int num_r = 1, size = 0, pidx = 0;\n\tstruct resource r[4];\n\tstruct property_entry pr[6];\n\tu32 flags;\n\tint rv;\n\n\tmemset(pr, 0, sizeof(pr));\n\tmemset(r, 0, sizeof(r));\n\n\tif (p->iftype == IPMI_PLAT_IF_SI) {\n\t\tif (p->type == SI_BT)\n\t\t\tsize = 3;\n\t\telse if (p->type != SI_TYPE_INVALID)\n\t\t\tsize = 2;\n\n\t\tif (p->regsize == 0)\n\t\t\tp->regsize = DEFAULT_REGSIZE;\n\t\tif (p->regspacing == 0)\n\t\t\tp->regspacing = p->regsize;\n\n\t\tpr[pidx++] = PROPERTY_ENTRY_U8(\"ipmi-type\", p->type);\n\t} else if (p->iftype == IPMI_PLAT_IF_SSIF) {\n\t\tpr[pidx++] = PROPERTY_ENTRY_U16(\"i2c-addr\", p->addr);\n\t}\n\n\tif (p->slave_addr)\n\t\tpr[pidx++] = PROPERTY_ENTRY_U8(\"slave-addr\", p->slave_addr);\n\tpr[pidx++] = PROPERTY_ENTRY_U8(\"addr-source\", p->addr_source);\n\tif (p->regshift)\n\t\tpr[pidx++] = PROPERTY_ENTRY_U8(\"reg-shift\", p->regshift);\n\tpr[pidx++] = PROPERTY_ENTRY_U8(\"reg-size\", p->regsize);\n\t \n\n\tpdev = platform_device_alloc(name, inst);\n\tif (!pdev) {\n\t\tpr_err(\"Error allocating IPMI platform device %s.%d\\n\",\n\t\t       name, inst);\n\t\treturn NULL;\n\t}\n\n\tif (size == 0)\n\t\t \n\t\tgoto add_properties;\n\n\t \n\n\tif (p->space == IPMI_IO_ADDR_SPACE)\n\t\tflags = IORESOURCE_IO;\n\telse\n\t\tflags = IORESOURCE_MEM;\n\n\tr[0].start = p->addr;\n\tr[0].end = r[0].start + p->regsize - 1;\n\tr[0].name = \"IPMI Address 1\";\n\tr[0].flags = flags;\n\n\tif (size > 1) {\n\t\tr[1].start = r[0].start + p->regspacing;\n\t\tr[1].end = r[1].start + p->regsize - 1;\n\t\tr[1].name = \"IPMI Address 2\";\n\t\tr[1].flags = flags;\n\t\tnum_r++;\n\t}\n\n\tif (size > 2) {\n\t\tr[2].start = r[1].start + p->regspacing;\n\t\tr[2].end = r[2].start + p->regsize - 1;\n\t\tr[2].name = \"IPMI Address 3\";\n\t\tr[2].flags = flags;\n\t\tnum_r++;\n\t}\n\n\tif (p->irq) {\n\t\tr[num_r].start = p->irq;\n\t\tr[num_r].end = p->irq;\n\t\tr[num_r].name = \"IPMI IRQ\";\n\t\tr[num_r].flags = IORESOURCE_IRQ;\n\t\tnum_r++;\n\t}\n\n\trv = platform_device_add_resources(pdev, r, num_r);\n\tif (rv) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Unable to add hard-code resources: %d\\n\", rv);\n\t\tgoto err;\n\t}\n add_properties:\n\trv = device_create_managed_software_node(&pdev->dev, pr, NULL);\n\tif (rv) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Unable to add hard-code properties: %d\\n\", rv);\n\t\tgoto err;\n\t}\n\n\trv = platform_device_add(pdev);\n\tif (rv) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Unable to add hard-code device: %d\\n\", rv);\n\t\tgoto err;\n\t}\n\treturn pdev;\n\nerr:\n\tplatform_device_put(pdev);\n\treturn NULL;\n}\nEXPORT_SYMBOL(ipmi_platform_add);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}