{
  "module_name": "kcs_bmc_npcm7xx.c",
  "hash_id": "d8aa05a78631e8fc869bd91e75dba34a2ea0f585c7b2adadc8f40f205ad6fe11",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/ipmi/kcs_bmc_npcm7xx.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"nuvoton-kcs-bmc: \" fmt\n\n#include <linux/atomic.h>\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n#include \"kcs_bmc_device.h\"\n\n#define DEVICE_NAME\t\"npcm-kcs-bmc\"\n#define KCS_CHANNEL_MAX\t3\n\n#define KCS1ST\t\t0x0C\n#define KCS2ST\t\t0x1E\n#define KCS3ST\t\t0x30\n\n#define KCS1DO\t\t0x0E\n#define KCS2DO\t\t0x20\n#define KCS3DO\t\t0x32\n\n#define KCS1DI\t\t0x10\n#define KCS2DI\t\t0x22\n#define KCS3DI\t\t0x34\n\n#define KCS1CTL\t\t0x18\n#define KCS2CTL\t\t0x2A\n#define KCS3CTL\t\t0x3C\n#define    KCS_CTL_IBFIE\tBIT(0)\n#define    KCS_CTL_OBEIE\tBIT(1)\n\n#define KCS1IE\t\t0x1C\n#define KCS2IE\t\t0x2E\n#define KCS3IE\t\t0x40\n#define    KCS_IE_IRQE          BIT(0)\n#define    KCS_IE_HIRQE         BIT(3)\n\n \nstruct npcm7xx_kcs_reg {\n\tu32 sts;\n\tu32 dob;\n\tu32 dib;\n\tu32 ctl;\n\tu32 ie;\n};\n\nstruct npcm7xx_kcs_bmc {\n\tstruct kcs_bmc_device kcs_bmc;\n\n\tstruct regmap *map;\n\n\tconst struct npcm7xx_kcs_reg *reg;\n};\n\nstatic const struct npcm7xx_kcs_reg npcm7xx_kcs_reg_tbl[KCS_CHANNEL_MAX] = {\n\t{ .sts = KCS1ST, .dob = KCS1DO, .dib = KCS1DI, .ctl = KCS1CTL, .ie = KCS1IE },\n\t{ .sts = KCS2ST, .dob = KCS2DO, .dib = KCS2DI, .ctl = KCS2CTL, .ie = KCS2IE },\n\t{ .sts = KCS3ST, .dob = KCS3DO, .dib = KCS3DI, .ctl = KCS3CTL, .ie = KCS3IE },\n};\n\nstatic inline struct npcm7xx_kcs_bmc *to_npcm7xx_kcs_bmc(struct kcs_bmc_device *kcs_bmc)\n{\n\treturn container_of(kcs_bmc, struct npcm7xx_kcs_bmc, kcs_bmc);\n}\n\nstatic u8 npcm7xx_kcs_inb(struct kcs_bmc_device *kcs_bmc, u32 reg)\n{\n\tstruct npcm7xx_kcs_bmc *priv = to_npcm7xx_kcs_bmc(kcs_bmc);\n\tu32 val = 0;\n\tint rc;\n\n\trc = regmap_read(priv->map, reg, &val);\n\tWARN(rc != 0, \"regmap_read() failed: %d\\n\", rc);\n\n\treturn rc == 0 ? (u8)val : 0;\n}\n\nstatic void npcm7xx_kcs_outb(struct kcs_bmc_device *kcs_bmc, u32 reg, u8 data)\n{\n\tstruct npcm7xx_kcs_bmc *priv = to_npcm7xx_kcs_bmc(kcs_bmc);\n\tint rc;\n\n\trc = regmap_write(priv->map, reg, data);\n\tWARN(rc != 0, \"regmap_write() failed: %d\\n\", rc);\n}\n\nstatic void npcm7xx_kcs_updateb(struct kcs_bmc_device *kcs_bmc, u32 reg, u8 mask, u8 data)\n{\n\tstruct npcm7xx_kcs_bmc *priv = to_npcm7xx_kcs_bmc(kcs_bmc);\n\tint rc;\n\n\trc = regmap_update_bits(priv->map, reg, mask, data);\n\tWARN(rc != 0, \"regmap_update_bits() failed: %d\\n\", rc);\n}\n\nstatic void npcm7xx_kcs_enable_channel(struct kcs_bmc_device *kcs_bmc, bool enable)\n{\n\tstruct npcm7xx_kcs_bmc *priv = to_npcm7xx_kcs_bmc(kcs_bmc);\n\n\tregmap_update_bits(priv->map, priv->reg->ie, KCS_IE_IRQE | KCS_IE_HIRQE,\n\t\t\t   enable ? KCS_IE_IRQE | KCS_IE_HIRQE : 0);\n}\n\nstatic void npcm7xx_kcs_irq_mask_update(struct kcs_bmc_device *kcs_bmc, u8 mask, u8 state)\n{\n\tstruct npcm7xx_kcs_bmc *priv = to_npcm7xx_kcs_bmc(kcs_bmc);\n\n\tif (mask & KCS_BMC_EVENT_TYPE_OBE)\n\t\tregmap_update_bits(priv->map, priv->reg->ctl, KCS_CTL_OBEIE,\n\t\t\t\t   !!(state & KCS_BMC_EVENT_TYPE_OBE) * KCS_CTL_OBEIE);\n\n\tif (mask & KCS_BMC_EVENT_TYPE_IBF)\n\t\tregmap_update_bits(priv->map, priv->reg->ctl, KCS_CTL_IBFIE,\n\t\t\t\t   !!(state & KCS_BMC_EVENT_TYPE_IBF) * KCS_CTL_IBFIE);\n}\n\nstatic irqreturn_t npcm7xx_kcs_irq(int irq, void *arg)\n{\n\tstruct kcs_bmc_device *kcs_bmc = arg;\n\n\treturn kcs_bmc_handle_event(kcs_bmc);\n}\n\nstatic int npcm7xx_kcs_config_irq(struct kcs_bmc_device *kcs_bmc,\n\t\t\t\t  struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tint irq;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\treturn devm_request_irq(dev, irq, npcm7xx_kcs_irq, IRQF_SHARED,\n\t\t\t\tdev_name(dev), kcs_bmc);\n}\n\nstatic const struct kcs_bmc_device_ops npcm7xx_kcs_ops = {\n\t.irq_mask_update = npcm7xx_kcs_irq_mask_update,\n\t.io_inputb = npcm7xx_kcs_inb,\n\t.io_outputb = npcm7xx_kcs_outb,\n\t.io_updateb = npcm7xx_kcs_updateb,\n};\n\nstatic int npcm7xx_kcs_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct npcm7xx_kcs_bmc *priv;\n\tstruct kcs_bmc_device *kcs_bmc;\n\tu32 chan;\n\tint rc;\n\n\trc = of_property_read_u32(dev->of_node, \"kcs_chan\", &chan);\n\tif (rc != 0 || chan == 0 || chan > KCS_CHANNEL_MAX) {\n\t\tdev_err(dev, \"no valid 'kcs_chan' configured\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->map = syscon_node_to_regmap(dev->parent->of_node);\n\tif (IS_ERR(priv->map)) {\n\t\tdev_err(dev, \"Couldn't get regmap\\n\");\n\t\treturn -ENODEV;\n\t}\n\tpriv->reg = &npcm7xx_kcs_reg_tbl[chan - 1];\n\n\tkcs_bmc = &priv->kcs_bmc;\n\tkcs_bmc->dev = &pdev->dev;\n\tkcs_bmc->channel = chan;\n\tkcs_bmc->ioreg.idr = priv->reg->dib;\n\tkcs_bmc->ioreg.odr = priv->reg->dob;\n\tkcs_bmc->ioreg.str = priv->reg->sts;\n\tkcs_bmc->ops = &npcm7xx_kcs_ops;\n\n\tplatform_set_drvdata(pdev, priv);\n\n\trc = npcm7xx_kcs_config_irq(kcs_bmc, pdev);\n\tif (rc)\n\t\treturn rc;\n\n\tnpcm7xx_kcs_irq_mask_update(kcs_bmc, (KCS_BMC_EVENT_TYPE_IBF | KCS_BMC_EVENT_TYPE_OBE), 0);\n\tnpcm7xx_kcs_enable_channel(kcs_bmc, true);\n\n\trc = kcs_bmc_add_device(kcs_bmc);\n\tif (rc) {\n\t\tdev_warn(&pdev->dev, \"Failed to register channel %d: %d\\n\", kcs_bmc->channel, rc);\n\t\treturn rc;\n\t}\n\n\tpr_info(\"channel=%u idr=0x%x odr=0x%x str=0x%x\\n\",\n\t\tchan,\n\t\tkcs_bmc->ioreg.idr, kcs_bmc->ioreg.odr, kcs_bmc->ioreg.str);\n\n\treturn 0;\n}\n\nstatic int npcm7xx_kcs_remove(struct platform_device *pdev)\n{\n\tstruct npcm7xx_kcs_bmc *priv = platform_get_drvdata(pdev);\n\tstruct kcs_bmc_device *kcs_bmc = &priv->kcs_bmc;\n\n\tkcs_bmc_remove_device(kcs_bmc);\n\n\tnpcm7xx_kcs_enable_channel(kcs_bmc, false);\n\tnpcm7xx_kcs_irq_mask_update(kcs_bmc, (KCS_BMC_EVENT_TYPE_IBF | KCS_BMC_EVENT_TYPE_OBE), 0);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id npcm_kcs_bmc_match[] = {\n\t{ .compatible = \"nuvoton,npcm750-kcs-bmc\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, npcm_kcs_bmc_match);\n\nstatic struct platform_driver npcm_kcs_bmc_driver = {\n\t.driver = {\n\t\t.name\t\t= DEVICE_NAME,\n\t\t.of_match_table\t= npcm_kcs_bmc_match,\n\t},\n\t.probe\t= npcm7xx_kcs_probe,\n\t.remove\t= npcm7xx_kcs_remove,\n};\nmodule_platform_driver(npcm_kcs_bmc_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Avi Fishman <avifishman70@gmail.com>\");\nMODULE_AUTHOR(\"Haiyue Wang <haiyue.wang@linux.intel.com>\");\nMODULE_DESCRIPTION(\"NPCM7xx device interface to the KCS BMC device\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}