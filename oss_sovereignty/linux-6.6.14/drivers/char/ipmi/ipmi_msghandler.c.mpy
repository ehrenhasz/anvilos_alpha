{
  "module_name": "ipmi_msghandler.c",
  "hash_id": "3a260e03fe4c2aa9cd634d01a49c730096bd539dc404f4bf2597fe82780b1b46",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/ipmi/ipmi_msghandler.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"IPMI message handler: \" fmt\n#define dev_fmt(fmt) pr_fmt(fmt)\n\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/panic_notifier.h>\n#include <linux/poll.h>\n#include <linux/sched.h>\n#include <linux/seq_file.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/ipmi.h>\n#include <linux/ipmi_smi.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/rcupdate.h>\n#include <linux/interrupt.h>\n#include <linux/moduleparam.h>\n#include <linux/workqueue.h>\n#include <linux/uuid.h>\n#include <linux/nospec.h>\n#include <linux/vmalloc.h>\n#include <linux/delay.h>\n\n#define IPMI_DRIVER_VERSION \"39.2\"\n\nstatic struct ipmi_recv_msg *ipmi_alloc_recv_msg(void);\nstatic int ipmi_init_msghandler(void);\nstatic void smi_recv_tasklet(struct tasklet_struct *t);\nstatic void handle_new_recv_msgs(struct ipmi_smi *intf);\nstatic void need_waiter(struct ipmi_smi *intf);\nstatic int handle_one_recv_msg(struct ipmi_smi *intf,\n\t\t\t       struct ipmi_smi_msg *msg);\n\nstatic bool initialized;\nstatic bool drvregistered;\n\n \nenum ipmi_panic_event_op {\n\tIPMI_SEND_PANIC_EVENT_NONE,\n\tIPMI_SEND_PANIC_EVENT,\n\tIPMI_SEND_PANIC_EVENT_STRING,\n\tIPMI_SEND_PANIC_EVENT_MAX\n};\n\n \nstatic const char *const ipmi_panic_event_str[] = { \"none\", \"event\", \"string\", NULL };\n\n#ifdef CONFIG_IPMI_PANIC_STRING\n#define IPMI_PANIC_DEFAULT IPMI_SEND_PANIC_EVENT_STRING\n#elif defined(CONFIG_IPMI_PANIC_EVENT)\n#define IPMI_PANIC_DEFAULT IPMI_SEND_PANIC_EVENT\n#else\n#define IPMI_PANIC_DEFAULT IPMI_SEND_PANIC_EVENT_NONE\n#endif\n\nstatic enum ipmi_panic_event_op ipmi_send_panic_event = IPMI_PANIC_DEFAULT;\n\nstatic int panic_op_write_handler(const char *val,\n\t\t\t\t  const struct kernel_param *kp)\n{\n\tchar valcp[16];\n\tint e;\n\n\tstrscpy(valcp, val, sizeof(valcp));\n\te = match_string(ipmi_panic_event_str, -1, strstrip(valcp));\n\tif (e < 0)\n\t\treturn e;\n\n\tipmi_send_panic_event = e;\n\treturn 0;\n}\n\nstatic int panic_op_read_handler(char *buffer, const struct kernel_param *kp)\n{\n\tconst char *event_str;\n\n\tif (ipmi_send_panic_event >= IPMI_SEND_PANIC_EVENT_MAX)\n\t\tevent_str = \"???\";\n\telse\n\t\tevent_str = ipmi_panic_event_str[ipmi_send_panic_event];\n\n\treturn sprintf(buffer, \"%s\\n\", event_str);\n}\n\nstatic const struct kernel_param_ops panic_op_ops = {\n\t.set = panic_op_write_handler,\n\t.get = panic_op_read_handler\n};\nmodule_param_cb(panic_op, &panic_op_ops, NULL, 0600);\nMODULE_PARM_DESC(panic_op, \"Sets if the IPMI driver will attempt to store panic information in the event log in the event of a panic.  Set to 'none' for no, 'event' for a single event, or 'string' for a generic event and the panic string in IPMI OEM events.\");\n\n\n#define MAX_EVENTS_IN_QUEUE\t25\n\n \nstatic unsigned long maintenance_mode_timeout_ms = 30000;\nmodule_param(maintenance_mode_timeout_ms, ulong, 0644);\nMODULE_PARM_DESC(maintenance_mode_timeout_ms,\n\t\t \"The time (milliseconds) after the last maintenance message that the connection stays in maintenance mode.\");\n\n \n#define MAX_MSG_TIMEOUT\t\t60000\n\n \n\n \nstatic unsigned long default_retry_ms = 2000;\nmodule_param(default_retry_ms, ulong, 0644);\nMODULE_PARM_DESC(default_retry_ms,\n\t\t \"The time (milliseconds) between retry sends\");\n\n \nstatic unsigned long default_maintenance_retry_ms = 3000;\nmodule_param(default_maintenance_retry_ms, ulong, 0644);\nMODULE_PARM_DESC(default_maintenance_retry_ms,\n\t\t \"The time (milliseconds) between retry sends in maintenance mode\");\n\n \nstatic unsigned int default_max_retries = 4;\nmodule_param(default_max_retries, uint, 0644);\nMODULE_PARM_DESC(default_max_retries,\n\t\t \"The time (milliseconds) between retry sends in maintenance mode\");\n\n \nstatic unsigned int max_users = 30;\nmodule_param(max_users, uint, 0644);\nMODULE_PARM_DESC(max_users,\n\t\t \"The most users that may use the IPMI stack at one time.\");\n\n \nstatic unsigned int max_msgs_per_user = 100;\nmodule_param(max_msgs_per_user, uint, 0644);\nMODULE_PARM_DESC(max_msgs_per_user,\n\t\t \"The most message a user may have outstanding.\");\n\n \n#define IPMI_TIMEOUT_TIME\t1000\n\n \n#define IPMI_TIMEOUT_JIFFIES\t((IPMI_TIMEOUT_TIME * HZ) / 1000)\n\n \n#define IPMI_REQUEST_EV_TIME\t(1000 / (IPMI_TIMEOUT_TIME))\n\n \n#define IPMI_DYN_DEV_ID_EXPIRY\t(10 * HZ)\n\n \nstruct ipmi_user {\n\tstruct list_head link;\n\n\t \n\tstruct ipmi_user *self;\n\tstruct srcu_struct release_barrier;\n\n\tstruct kref refcount;\n\n\t \n\tconst struct ipmi_user_hndl *handler;\n\tvoid             *handler_data;\n\n\t \n\tstruct ipmi_smi *intf;\n\n\t \n\tbool gets_events;\n\n\tatomic_t nr_msgs;\n\n\t \n\tstruct work_struct remove_work;\n};\n\nstatic struct workqueue_struct *remove_work_wq;\n\nstatic struct ipmi_user *acquire_ipmi_user(struct ipmi_user *user, int *index)\n\t__acquires(user->release_barrier)\n{\n\tstruct ipmi_user *ruser;\n\n\t*index = srcu_read_lock(&user->release_barrier);\n\truser = srcu_dereference(user->self, &user->release_barrier);\n\tif (!ruser)\n\t\tsrcu_read_unlock(&user->release_barrier, *index);\n\treturn ruser;\n}\n\nstatic void release_ipmi_user(struct ipmi_user *user, int index)\n{\n\tsrcu_read_unlock(&user->release_barrier, index);\n}\n\nstruct cmd_rcvr {\n\tstruct list_head link;\n\n\tstruct ipmi_user *user;\n\tunsigned char netfn;\n\tunsigned char cmd;\n\tunsigned int  chans;\n\n\t \n\tstruct cmd_rcvr *next;\n};\n\nstruct seq_table {\n\tunsigned int         inuse : 1;\n\tunsigned int         broadcast : 1;\n\n\tunsigned long        timeout;\n\tunsigned long        orig_timeout;\n\tunsigned int         retries_left;\n\n\t \n\tlong                 seqid;\n\n\t \n\tstruct ipmi_recv_msg *recv_msg;\n};\n\n \n#define STORE_SEQ_IN_MSGID(seq, seqid) \\\n\t((((seq) & 0x3f) << 26) | ((seqid) & 0x3ffffff))\n\n#define GET_SEQ_FROM_MSGID(msgid, seq, seqid) \\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tseq = (((msgid) >> 26) & 0x3f);\t\t\t\t\\\n\t\tseqid = ((msgid) & 0x3ffffff);\t\t\t\t\\\n\t} while (0)\n\n#define NEXT_SEQID(seqid) (((seqid) + 1) & 0x3ffffff)\n\n#define IPMI_MAX_CHANNELS       16\nstruct ipmi_channel {\n\tunsigned char medium;\n\tunsigned char protocol;\n};\n\nstruct ipmi_channel_set {\n\tstruct ipmi_channel c[IPMI_MAX_CHANNELS];\n};\n\nstruct ipmi_my_addrinfo {\n\t \n\tunsigned char address;\n\n\t \n\tunsigned char lun;\n};\n\n \nstruct bmc_device {\n\tstruct platform_device pdev;\n\tstruct list_head       intfs;  \n\tstruct ipmi_device_id  id;\n\tstruct ipmi_device_id  fetch_id;\n\tint                    dyn_id_set;\n\tunsigned long          dyn_id_expiry;\n\tstruct mutex           dyn_mutex;  \n\tguid_t                 guid;\n\tguid_t                 fetch_guid;\n\tint                    dyn_guid_set;\n\tstruct kref\t       usecount;\n\tstruct work_struct     remove_work;\n\tunsigned char\t       cc;  \n};\n#define to_bmc_device(x) container_of((x), struct bmc_device, pdev.dev)\n\nstatic int bmc_get_device_id(struct ipmi_smi *intf, struct bmc_device *bmc,\n\t\t\t     struct ipmi_device_id *id,\n\t\t\t     bool *guid_set, guid_t *guid);\n\n \nenum ipmi_stat_indexes {\n\t \n\tIPMI_STAT_sent_invalid_commands = 0,\n\n\t \n\tIPMI_STAT_sent_local_commands,\n\n\t \n\tIPMI_STAT_handled_local_responses,\n\n\t \n\tIPMI_STAT_unhandled_local_responses,\n\n\t \n\tIPMI_STAT_sent_ipmb_commands,\n\n\t \n\tIPMI_STAT_sent_ipmb_command_errs,\n\n\t \n\tIPMI_STAT_retransmitted_ipmb_commands,\n\n\t \n\tIPMI_STAT_timed_out_ipmb_commands,\n\n\t \n\tIPMI_STAT_timed_out_ipmb_broadcasts,\n\n\t \n\tIPMI_STAT_sent_ipmb_responses,\n\n\t \n\tIPMI_STAT_handled_ipmb_responses,\n\n\t \n\tIPMI_STAT_invalid_ipmb_responses,\n\n\t \n\tIPMI_STAT_unhandled_ipmb_responses,\n\n\t \n\tIPMI_STAT_sent_lan_commands,\n\n\t \n\tIPMI_STAT_sent_lan_command_errs,\n\n\t \n\tIPMI_STAT_retransmitted_lan_commands,\n\n\t \n\tIPMI_STAT_timed_out_lan_commands,\n\n\t \n\tIPMI_STAT_sent_lan_responses,\n\n\t \n\tIPMI_STAT_handled_lan_responses,\n\n\t \n\tIPMI_STAT_invalid_lan_responses,\n\n\t \n\tIPMI_STAT_unhandled_lan_responses,\n\n\t \n\tIPMI_STAT_handled_commands,\n\n\t \n\tIPMI_STAT_invalid_commands,\n\n\t \n\tIPMI_STAT_unhandled_commands,\n\n\t \n\tIPMI_STAT_invalid_events,\n\n\t \n\tIPMI_STAT_events,\n\n\t \n\tIPMI_STAT_dropped_rexmit_ipmb_commands,\n\n\t \n\tIPMI_STAT_dropped_rexmit_lan_commands,\n\n\t \n\tIPMI_NUM_STATS\n};\n\n\n#define IPMI_IPMB_NUM_SEQ\t64\nstruct ipmi_smi {\n\tstruct module *owner;\n\n\t \n\tint intf_num;\n\n\tstruct kref refcount;\n\n\t \n\tbool in_shutdown;\n\n\t \n\tstruct list_head link;\n\n\t \n\tstruct list_head users;\n\tstruct srcu_struct users_srcu;\n\tatomic_t nr_users;\n\tstruct device_attribute nr_users_devattr;\n\tstruct device_attribute nr_msgs_devattr;\n\n\n\t \n\twait_queue_head_t waitq;\n\n\t \n\tstruct mutex bmc_reg_mutex;\n\n\tstruct bmc_device tmp_bmc;\n\tstruct bmc_device *bmc;\n\tbool bmc_registered;\n\tstruct list_head bmc_link;\n\tchar *my_dev_name;\n\tbool in_bmc_register;   \n\tstruct work_struct bmc_reg_work;\n\n\tconst struct ipmi_smi_handlers *handlers;\n\tvoid                     *send_info;\n\n\t \n\tstruct device          *si_dev;\n\n\t \n\tspinlock_t       seq_lock;\n\tstruct seq_table seq_table[IPMI_IPMB_NUM_SEQ];\n\tint curr_seq;\n\n\t \n\tspinlock_t       waiting_rcv_msgs_lock;\n\tstruct list_head waiting_rcv_msgs;\n\tatomic_t\t watchdog_pretimeouts_to_deliver;\n\tstruct tasklet_struct recv_tasklet;\n\n\tspinlock_t             xmit_msgs_lock;\n\tstruct list_head       xmit_msgs;\n\tstruct ipmi_smi_msg    *curr_msg;\n\tstruct list_head       hp_xmit_msgs;\n\n\t \n\tstruct mutex     cmd_rcvrs_mutex;\n\tstruct list_head cmd_rcvrs;\n\n\t \n\tspinlock_t       events_lock;  \n\tstruct list_head waiting_events;\n\tunsigned int     waiting_events_count;  \n\tchar             delivering_events;\n\tchar             event_msg_printed;\n\n\t \n\tatomic_t         event_waiters;\n\tunsigned int     ticks_to_req_ev;\n\n\tspinlock_t       watch_lock;  \n\n\t \n\tunsigned int     command_waiters;\n\n\t \n\tunsigned int     watchdog_waiters;\n\n\t \n\tunsigned int     response_waiters;\n\n\t \n\tunsigned int     last_watch_mask;\n\n\t \n\tunsigned char event_receiver;\n\tunsigned char event_receiver_lun;\n\tunsigned char local_sel_device;\n\tunsigned char local_event_generator;\n\n\t \n\tint maintenance_mode;\n\tbool maintenance_mode_enable;\n\tint auto_maintenance_timeout;\n\tspinlock_t maintenance_mode_lock;  \n\n\t \n\tint ipmb_maintenance_mode_timeout;\n\n\t \n\tvoid (*null_user_handler)(struct ipmi_smi *intf,\n\t\t\t\t  struct ipmi_recv_msg *msg);\n\n\t \n\tint curr_channel;\n\n\t \n\tstruct ipmi_channel_set *channel_list;\n\tunsigned int curr_working_cset;  \n\tstruct ipmi_channel_set wchannels[2];\n\tstruct ipmi_my_addrinfo addrinfo[IPMI_MAX_CHANNELS];\n\tbool channels_ready;\n\n\tatomic_t stats[IPMI_NUM_STATS];\n\n\t \n\tint run_to_completion;\n};\n#define to_si_intf_from_dev(device) container_of(device, struct ipmi_smi, dev)\n\nstatic void __get_guid(struct ipmi_smi *intf);\nstatic void __ipmi_bmc_unregister(struct ipmi_smi *intf);\nstatic int __ipmi_bmc_register(struct ipmi_smi *intf,\n\t\t\t       struct ipmi_device_id *id,\n\t\t\t       bool guid_set, guid_t *guid, int intf_num);\nstatic int __scan_channels(struct ipmi_smi *intf, struct ipmi_device_id *id);\n\n\n \nstatic struct platform_driver ipmidriver = {\n\t.driver = {\n\t\t.name = \"ipmi\",\n\t\t.bus = &platform_bus_type\n\t}\n};\n \nstatic DEFINE_MUTEX(ipmidriver_mutex);\n\nstatic LIST_HEAD(ipmi_interfaces);\nstatic DEFINE_MUTEX(ipmi_interfaces_mutex);\n#define ipmi_interfaces_mutex_held() \\\n\tlockdep_is_held(&ipmi_interfaces_mutex)\nstatic struct srcu_struct ipmi_interfaces_srcu;\n\n \nstatic LIST_HEAD(smi_watchers);\nstatic DEFINE_MUTEX(smi_watchers_mutex);\n\n#define ipmi_inc_stat(intf, stat) \\\n\tatomic_inc(&(intf)->stats[IPMI_STAT_ ## stat])\n#define ipmi_get_stat(intf, stat) \\\n\t((unsigned int) atomic_read(&(intf)->stats[IPMI_STAT_ ## stat]))\n\nstatic const char * const addr_src_to_str[] = {\n\t\"invalid\", \"hotmod\", \"hardcoded\", \"SPMI\", \"ACPI\", \"SMBIOS\", \"PCI\",\n\t\"device-tree\", \"platform\"\n};\n\nconst char *ipmi_addr_src_to_str(enum ipmi_addr_src src)\n{\n\tif (src >= SI_LAST)\n\t\tsrc = 0;  \n\treturn addr_src_to_str[src];\n}\nEXPORT_SYMBOL(ipmi_addr_src_to_str);\n\nstatic int is_lan_addr(struct ipmi_addr *addr)\n{\n\treturn addr->addr_type == IPMI_LAN_ADDR_TYPE;\n}\n\nstatic int is_ipmb_addr(struct ipmi_addr *addr)\n{\n\treturn addr->addr_type == IPMI_IPMB_ADDR_TYPE;\n}\n\nstatic int is_ipmb_bcast_addr(struct ipmi_addr *addr)\n{\n\treturn addr->addr_type == IPMI_IPMB_BROADCAST_ADDR_TYPE;\n}\n\nstatic int is_ipmb_direct_addr(struct ipmi_addr *addr)\n{\n\treturn addr->addr_type == IPMI_IPMB_DIRECT_ADDR_TYPE;\n}\n\nstatic void free_recv_msg_list(struct list_head *q)\n{\n\tstruct ipmi_recv_msg *msg, *msg2;\n\n\tlist_for_each_entry_safe(msg, msg2, q, link) {\n\t\tlist_del(&msg->link);\n\t\tipmi_free_recv_msg(msg);\n\t}\n}\n\nstatic void free_smi_msg_list(struct list_head *q)\n{\n\tstruct ipmi_smi_msg *msg, *msg2;\n\n\tlist_for_each_entry_safe(msg, msg2, q, link) {\n\t\tlist_del(&msg->link);\n\t\tipmi_free_smi_msg(msg);\n\t}\n}\n\nstatic void clean_up_interface_data(struct ipmi_smi *intf)\n{\n\tint              i;\n\tstruct cmd_rcvr  *rcvr, *rcvr2;\n\tstruct list_head list;\n\n\ttasklet_kill(&intf->recv_tasklet);\n\n\tfree_smi_msg_list(&intf->waiting_rcv_msgs);\n\tfree_recv_msg_list(&intf->waiting_events);\n\n\t \n\tmutex_lock(&intf->cmd_rcvrs_mutex);\n\tINIT_LIST_HEAD(&list);\n\tlist_splice_init_rcu(&intf->cmd_rcvrs, &list, synchronize_rcu);\n\tmutex_unlock(&intf->cmd_rcvrs_mutex);\n\n\tlist_for_each_entry_safe(rcvr, rcvr2, &list, link)\n\t\tkfree(rcvr);\n\n\tfor (i = 0; i < IPMI_IPMB_NUM_SEQ; i++) {\n\t\tif ((intf->seq_table[i].inuse)\n\t\t\t\t\t&& (intf->seq_table[i].recv_msg))\n\t\t\tipmi_free_recv_msg(intf->seq_table[i].recv_msg);\n\t}\n}\n\nstatic void intf_free(struct kref *ref)\n{\n\tstruct ipmi_smi *intf = container_of(ref, struct ipmi_smi, refcount);\n\n\tclean_up_interface_data(intf);\n\tkfree(intf);\n}\n\nint ipmi_smi_watcher_register(struct ipmi_smi_watcher *watcher)\n{\n\tstruct ipmi_smi *intf;\n\tint index, rv;\n\n\t \n\trv = ipmi_init_msghandler();\n\tif (rv)\n\t\treturn rv;\n\n\tmutex_lock(&smi_watchers_mutex);\n\n\tlist_add(&watcher->link, &smi_watchers);\n\n\tindex = srcu_read_lock(&ipmi_interfaces_srcu);\n\tlist_for_each_entry_rcu(intf, &ipmi_interfaces, link,\n\t\t\tlockdep_is_held(&smi_watchers_mutex)) {\n\t\tint intf_num = READ_ONCE(intf->intf_num);\n\n\t\tif (intf_num == -1)\n\t\t\tcontinue;\n\t\twatcher->new_smi(intf_num, intf->si_dev);\n\t}\n\tsrcu_read_unlock(&ipmi_interfaces_srcu, index);\n\n\tmutex_unlock(&smi_watchers_mutex);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ipmi_smi_watcher_register);\n\nint ipmi_smi_watcher_unregister(struct ipmi_smi_watcher *watcher)\n{\n\tmutex_lock(&smi_watchers_mutex);\n\tlist_del(&watcher->link);\n\tmutex_unlock(&smi_watchers_mutex);\n\treturn 0;\n}\nEXPORT_SYMBOL(ipmi_smi_watcher_unregister);\n\n \nstatic void\ncall_smi_watchers(int i, struct device *dev)\n{\n\tstruct ipmi_smi_watcher *w;\n\n\tmutex_lock(&smi_watchers_mutex);\n\tlist_for_each_entry(w, &smi_watchers, link) {\n\t\tif (try_module_get(w->owner)) {\n\t\t\tw->new_smi(i, dev);\n\t\t\tmodule_put(w->owner);\n\t\t}\n\t}\n\tmutex_unlock(&smi_watchers_mutex);\n}\n\nstatic int\nipmi_addr_equal(struct ipmi_addr *addr1, struct ipmi_addr *addr2)\n{\n\tif (addr1->addr_type != addr2->addr_type)\n\t\treturn 0;\n\n\tif (addr1->channel != addr2->channel)\n\t\treturn 0;\n\n\tif (addr1->addr_type == IPMI_SYSTEM_INTERFACE_ADDR_TYPE) {\n\t\tstruct ipmi_system_interface_addr *smi_addr1\n\t\t    = (struct ipmi_system_interface_addr *) addr1;\n\t\tstruct ipmi_system_interface_addr *smi_addr2\n\t\t    = (struct ipmi_system_interface_addr *) addr2;\n\t\treturn (smi_addr1->lun == smi_addr2->lun);\n\t}\n\n\tif (is_ipmb_addr(addr1) || is_ipmb_bcast_addr(addr1)) {\n\t\tstruct ipmi_ipmb_addr *ipmb_addr1\n\t\t    = (struct ipmi_ipmb_addr *) addr1;\n\t\tstruct ipmi_ipmb_addr *ipmb_addr2\n\t\t    = (struct ipmi_ipmb_addr *) addr2;\n\n\t\treturn ((ipmb_addr1->slave_addr == ipmb_addr2->slave_addr)\n\t\t\t&& (ipmb_addr1->lun == ipmb_addr2->lun));\n\t}\n\n\tif (is_ipmb_direct_addr(addr1)) {\n\t\tstruct ipmi_ipmb_direct_addr *daddr1\n\t\t\t= (struct ipmi_ipmb_direct_addr *) addr1;\n\t\tstruct ipmi_ipmb_direct_addr *daddr2\n\t\t\t= (struct ipmi_ipmb_direct_addr *) addr2;\n\n\t\treturn daddr1->slave_addr == daddr2->slave_addr &&\n\t\t\tdaddr1->rq_lun == daddr2->rq_lun &&\n\t\t\tdaddr1->rs_lun == daddr2->rs_lun;\n\t}\n\n\tif (is_lan_addr(addr1)) {\n\t\tstruct ipmi_lan_addr *lan_addr1\n\t\t\t= (struct ipmi_lan_addr *) addr1;\n\t\tstruct ipmi_lan_addr *lan_addr2\n\t\t    = (struct ipmi_lan_addr *) addr2;\n\n\t\treturn ((lan_addr1->remote_SWID == lan_addr2->remote_SWID)\n\t\t\t&& (lan_addr1->local_SWID == lan_addr2->local_SWID)\n\t\t\t&& (lan_addr1->session_handle\n\t\t\t    == lan_addr2->session_handle)\n\t\t\t&& (lan_addr1->lun == lan_addr2->lun));\n\t}\n\n\treturn 1;\n}\n\nint ipmi_validate_addr(struct ipmi_addr *addr, int len)\n{\n\tif (len < sizeof(struct ipmi_system_interface_addr))\n\t\treturn -EINVAL;\n\n\tif (addr->addr_type == IPMI_SYSTEM_INTERFACE_ADDR_TYPE) {\n\t\tif (addr->channel != IPMI_BMC_CHANNEL)\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n\n\tif ((addr->channel == IPMI_BMC_CHANNEL)\n\t    || (addr->channel >= IPMI_MAX_CHANNELS)\n\t    || (addr->channel < 0))\n\t\treturn -EINVAL;\n\n\tif (is_ipmb_addr(addr) || is_ipmb_bcast_addr(addr)) {\n\t\tif (len < sizeof(struct ipmi_ipmb_addr))\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n\n\tif (is_ipmb_direct_addr(addr)) {\n\t\tstruct ipmi_ipmb_direct_addr *daddr = (void *) addr;\n\n\t\tif (addr->channel != 0)\n\t\t\treturn -EINVAL;\n\t\tif (len < sizeof(struct ipmi_ipmb_direct_addr))\n\t\t\treturn -EINVAL;\n\n\t\tif (daddr->slave_addr & 0x01)\n\t\t\treturn -EINVAL;\n\t\tif (daddr->rq_lun >= 4)\n\t\t\treturn -EINVAL;\n\t\tif (daddr->rs_lun >= 4)\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n\n\tif (is_lan_addr(addr)) {\n\t\tif (len < sizeof(struct ipmi_lan_addr))\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL(ipmi_validate_addr);\n\nunsigned int ipmi_addr_length(int addr_type)\n{\n\tif (addr_type == IPMI_SYSTEM_INTERFACE_ADDR_TYPE)\n\t\treturn sizeof(struct ipmi_system_interface_addr);\n\n\tif ((addr_type == IPMI_IPMB_ADDR_TYPE)\n\t\t\t|| (addr_type == IPMI_IPMB_BROADCAST_ADDR_TYPE))\n\t\treturn sizeof(struct ipmi_ipmb_addr);\n\n\tif (addr_type == IPMI_IPMB_DIRECT_ADDR_TYPE)\n\t\treturn sizeof(struct ipmi_ipmb_direct_addr);\n\n\tif (addr_type == IPMI_LAN_ADDR_TYPE)\n\t\treturn sizeof(struct ipmi_lan_addr);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ipmi_addr_length);\n\nstatic int deliver_response(struct ipmi_smi *intf, struct ipmi_recv_msg *msg)\n{\n\tint rv = 0;\n\n\tif (!msg->user) {\n\t\t \n\t\tif (intf->null_user_handler) {\n\t\t\tintf->null_user_handler(intf, msg);\n\t\t} else {\n\t\t\t \n\t\t\trv = -EINVAL;\n\t\t}\n\t\tipmi_free_recv_msg(msg);\n\t} else if (oops_in_progress) {\n\t\t \n\t\tipmi_free_recv_msg(msg);\n\t\tatomic_dec(&msg->user->nr_msgs);\n\t} else {\n\t\tint index;\n\t\tstruct ipmi_user *user = acquire_ipmi_user(msg->user, &index);\n\n\t\tif (user) {\n\t\t\tatomic_dec(&user->nr_msgs);\n\t\t\tuser->handler->ipmi_recv_hndl(msg, user->handler_data);\n\t\t\trelease_ipmi_user(user, index);\n\t\t} else {\n\t\t\t \n\t\t\tipmi_free_recv_msg(msg);\n\t\t\trv = -EINVAL;\n\t\t}\n\t}\n\n\treturn rv;\n}\n\nstatic void deliver_local_response(struct ipmi_smi *intf,\n\t\t\t\t   struct ipmi_recv_msg *msg)\n{\n\tif (deliver_response(intf, msg))\n\t\tipmi_inc_stat(intf, unhandled_local_responses);\n\telse\n\t\tipmi_inc_stat(intf, handled_local_responses);\n}\n\nstatic void deliver_err_response(struct ipmi_smi *intf,\n\t\t\t\t struct ipmi_recv_msg *msg, int err)\n{\n\tmsg->recv_type = IPMI_RESPONSE_RECV_TYPE;\n\tmsg->msg_data[0] = err;\n\tmsg->msg.netfn |= 1;  \n\tmsg->msg.data_len = 1;\n\tmsg->msg.data = msg->msg_data;\n\tdeliver_local_response(intf, msg);\n}\n\nstatic void smi_add_watch(struct ipmi_smi *intf, unsigned int flags)\n{\n\tunsigned long iflags;\n\n\tif (!intf->handlers->set_need_watch)\n\t\treturn;\n\n\tspin_lock_irqsave(&intf->watch_lock, iflags);\n\tif (flags & IPMI_WATCH_MASK_CHECK_MESSAGES)\n\t\tintf->response_waiters++;\n\n\tif (flags & IPMI_WATCH_MASK_CHECK_WATCHDOG)\n\t\tintf->watchdog_waiters++;\n\n\tif (flags & IPMI_WATCH_MASK_CHECK_COMMANDS)\n\t\tintf->command_waiters++;\n\n\tif ((intf->last_watch_mask & flags) != flags) {\n\t\tintf->last_watch_mask |= flags;\n\t\tintf->handlers->set_need_watch(intf->send_info,\n\t\t\t\t\t       intf->last_watch_mask);\n\t}\n\tspin_unlock_irqrestore(&intf->watch_lock, iflags);\n}\n\nstatic void smi_remove_watch(struct ipmi_smi *intf, unsigned int flags)\n{\n\tunsigned long iflags;\n\n\tif (!intf->handlers->set_need_watch)\n\t\treturn;\n\n\tspin_lock_irqsave(&intf->watch_lock, iflags);\n\tif (flags & IPMI_WATCH_MASK_CHECK_MESSAGES)\n\t\tintf->response_waiters--;\n\n\tif (flags & IPMI_WATCH_MASK_CHECK_WATCHDOG)\n\t\tintf->watchdog_waiters--;\n\n\tif (flags & IPMI_WATCH_MASK_CHECK_COMMANDS)\n\t\tintf->command_waiters--;\n\n\tflags = 0;\n\tif (intf->response_waiters)\n\t\tflags |= IPMI_WATCH_MASK_CHECK_MESSAGES;\n\tif (intf->watchdog_waiters)\n\t\tflags |= IPMI_WATCH_MASK_CHECK_WATCHDOG;\n\tif (intf->command_waiters)\n\t\tflags |= IPMI_WATCH_MASK_CHECK_COMMANDS;\n\n\tif (intf->last_watch_mask != flags) {\n\t\tintf->last_watch_mask = flags;\n\t\tintf->handlers->set_need_watch(intf->send_info,\n\t\t\t\t\t       intf->last_watch_mask);\n\t}\n\tspin_unlock_irqrestore(&intf->watch_lock, iflags);\n}\n\n \nstatic int intf_next_seq(struct ipmi_smi      *intf,\n\t\t\t struct ipmi_recv_msg *recv_msg,\n\t\t\t unsigned long        timeout,\n\t\t\t int                  retries,\n\t\t\t int                  broadcast,\n\t\t\t unsigned char        *seq,\n\t\t\t long                 *seqid)\n{\n\tint          rv = 0;\n\tunsigned int i;\n\n\tif (timeout == 0)\n\t\ttimeout = default_retry_ms;\n\tif (retries < 0)\n\t\tretries = default_max_retries;\n\n\tfor (i = intf->curr_seq; (i+1)%IPMI_IPMB_NUM_SEQ != intf->curr_seq;\n\t\t\t\t\ti = (i+1)%IPMI_IPMB_NUM_SEQ) {\n\t\tif (!intf->seq_table[i].inuse)\n\t\t\tbreak;\n\t}\n\n\tif (!intf->seq_table[i].inuse) {\n\t\tintf->seq_table[i].recv_msg = recv_msg;\n\n\t\t \n\t\tintf->seq_table[i].timeout = MAX_MSG_TIMEOUT;\n\t\tintf->seq_table[i].orig_timeout = timeout;\n\t\tintf->seq_table[i].retries_left = retries;\n\t\tintf->seq_table[i].broadcast = broadcast;\n\t\tintf->seq_table[i].inuse = 1;\n\t\tintf->seq_table[i].seqid = NEXT_SEQID(intf->seq_table[i].seqid);\n\t\t*seq = i;\n\t\t*seqid = intf->seq_table[i].seqid;\n\t\tintf->curr_seq = (i+1)%IPMI_IPMB_NUM_SEQ;\n\t\tsmi_add_watch(intf, IPMI_WATCH_MASK_CHECK_MESSAGES);\n\t\tneed_waiter(intf);\n\t} else {\n\t\trv = -EAGAIN;\n\t}\n\n\treturn rv;\n}\n\n \nstatic int intf_find_seq(struct ipmi_smi      *intf,\n\t\t\t unsigned char        seq,\n\t\t\t short                channel,\n\t\t\t unsigned char        cmd,\n\t\t\t unsigned char        netfn,\n\t\t\t struct ipmi_addr     *addr,\n\t\t\t struct ipmi_recv_msg **recv_msg)\n{\n\tint           rv = -ENODEV;\n\tunsigned long flags;\n\n\tif (seq >= IPMI_IPMB_NUM_SEQ)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&intf->seq_lock, flags);\n\tif (intf->seq_table[seq].inuse) {\n\t\tstruct ipmi_recv_msg *msg = intf->seq_table[seq].recv_msg;\n\n\t\tif ((msg->addr.channel == channel) && (msg->msg.cmd == cmd)\n\t\t\t\t&& (msg->msg.netfn == netfn)\n\t\t\t\t&& (ipmi_addr_equal(addr, &msg->addr))) {\n\t\t\t*recv_msg = msg;\n\t\t\tintf->seq_table[seq].inuse = 0;\n\t\t\tsmi_remove_watch(intf, IPMI_WATCH_MASK_CHECK_MESSAGES);\n\t\t\trv = 0;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&intf->seq_lock, flags);\n\n\treturn rv;\n}\n\n\n \nstatic int intf_start_seq_timer(struct ipmi_smi *intf,\n\t\t\t\tlong       msgid)\n{\n\tint           rv = -ENODEV;\n\tunsigned long flags;\n\tunsigned char seq;\n\tunsigned long seqid;\n\n\n\tGET_SEQ_FROM_MSGID(msgid, seq, seqid);\n\n\tspin_lock_irqsave(&intf->seq_lock, flags);\n\t \n\tif ((intf->seq_table[seq].inuse)\n\t\t\t\t&& (intf->seq_table[seq].seqid == seqid)) {\n\t\tstruct seq_table *ent = &intf->seq_table[seq];\n\t\tent->timeout = ent->orig_timeout;\n\t\trv = 0;\n\t}\n\tspin_unlock_irqrestore(&intf->seq_lock, flags);\n\n\treturn rv;\n}\n\n \nstatic int intf_err_seq(struct ipmi_smi *intf,\n\t\t\tlong         msgid,\n\t\t\tunsigned int err)\n{\n\tint                  rv = -ENODEV;\n\tunsigned long        flags;\n\tunsigned char        seq;\n\tunsigned long        seqid;\n\tstruct ipmi_recv_msg *msg = NULL;\n\n\n\tGET_SEQ_FROM_MSGID(msgid, seq, seqid);\n\n\tspin_lock_irqsave(&intf->seq_lock, flags);\n\t \n\tif ((intf->seq_table[seq].inuse)\n\t\t\t\t&& (intf->seq_table[seq].seqid == seqid)) {\n\t\tstruct seq_table *ent = &intf->seq_table[seq];\n\n\t\tent->inuse = 0;\n\t\tsmi_remove_watch(intf, IPMI_WATCH_MASK_CHECK_MESSAGES);\n\t\tmsg = ent->recv_msg;\n\t\trv = 0;\n\t}\n\tspin_unlock_irqrestore(&intf->seq_lock, flags);\n\n\tif (msg)\n\t\tdeliver_err_response(intf, msg, err);\n\n\treturn rv;\n}\n\nstatic void free_user_work(struct work_struct *work)\n{\n\tstruct ipmi_user *user = container_of(work, struct ipmi_user,\n\t\t\t\t\t      remove_work);\n\n\tcleanup_srcu_struct(&user->release_barrier);\n\tvfree(user);\n}\n\nint ipmi_create_user(unsigned int          if_num,\n\t\t     const struct ipmi_user_hndl *handler,\n\t\t     void                  *handler_data,\n\t\t     struct ipmi_user      **user)\n{\n\tunsigned long flags;\n\tstruct ipmi_user *new_user;\n\tint           rv, index;\n\tstruct ipmi_smi *intf;\n\n\t \n\n\tif (handler == NULL)\n\t\treturn -EINVAL;\n\n\t \n\trv = ipmi_init_msghandler();\n\tif (rv)\n\t\treturn rv;\n\n\tnew_user = vzalloc(sizeof(*new_user));\n\tif (!new_user)\n\t\treturn -ENOMEM;\n\n\tindex = srcu_read_lock(&ipmi_interfaces_srcu);\n\tlist_for_each_entry_rcu(intf, &ipmi_interfaces, link) {\n\t\tif (intf->intf_num == if_num)\n\t\t\tgoto found;\n\t}\n\t \n\trv = -EINVAL;\n\tgoto out_kfree;\n\n found:\n\tif (atomic_add_return(1, &intf->nr_users) > max_users) {\n\t\trv = -EBUSY;\n\t\tgoto out_kfree;\n\t}\n\n\tINIT_WORK(&new_user->remove_work, free_user_work);\n\n\trv = init_srcu_struct(&new_user->release_barrier);\n\tif (rv)\n\t\tgoto out_kfree;\n\n\tif (!try_module_get(intf->owner)) {\n\t\trv = -ENODEV;\n\t\tgoto out_kfree;\n\t}\n\n\t \n\tkref_get(&intf->refcount);\n\n\tatomic_set(&new_user->nr_msgs, 0);\n\tkref_init(&new_user->refcount);\n\tnew_user->handler = handler;\n\tnew_user->handler_data = handler_data;\n\tnew_user->intf = intf;\n\tnew_user->gets_events = false;\n\n\trcu_assign_pointer(new_user->self, new_user);\n\tspin_lock_irqsave(&intf->seq_lock, flags);\n\tlist_add_rcu(&new_user->link, &intf->users);\n\tspin_unlock_irqrestore(&intf->seq_lock, flags);\n\tif (handler->ipmi_watchdog_pretimeout)\n\t\t \n\t\tsmi_add_watch(intf, IPMI_WATCH_MASK_CHECK_WATCHDOG);\n\tsrcu_read_unlock(&ipmi_interfaces_srcu, index);\n\t*user = new_user;\n\treturn 0;\n\nout_kfree:\n\tatomic_dec(&intf->nr_users);\n\tsrcu_read_unlock(&ipmi_interfaces_srcu, index);\n\tvfree(new_user);\n\treturn rv;\n}\nEXPORT_SYMBOL(ipmi_create_user);\n\nint ipmi_get_smi_info(int if_num, struct ipmi_smi_info *data)\n{\n\tint rv, index;\n\tstruct ipmi_smi *intf;\n\n\tindex = srcu_read_lock(&ipmi_interfaces_srcu);\n\tlist_for_each_entry_rcu(intf, &ipmi_interfaces, link) {\n\t\tif (intf->intf_num == if_num)\n\t\t\tgoto found;\n\t}\n\tsrcu_read_unlock(&ipmi_interfaces_srcu, index);\n\n\t \n\treturn -EINVAL;\n\nfound:\n\tif (!intf->handlers->get_smi_info)\n\t\trv = -ENOTTY;\n\telse\n\t\trv = intf->handlers->get_smi_info(intf->send_info, data);\n\tsrcu_read_unlock(&ipmi_interfaces_srcu, index);\n\n\treturn rv;\n}\nEXPORT_SYMBOL(ipmi_get_smi_info);\n\nstatic void free_user(struct kref *ref)\n{\n\tstruct ipmi_user *user = container_of(ref, struct ipmi_user, refcount);\n\n\t \n\tqueue_work(remove_work_wq, &user->remove_work);\n}\n\nstatic void _ipmi_destroy_user(struct ipmi_user *user)\n{\n\tstruct ipmi_smi  *intf = user->intf;\n\tint              i;\n\tunsigned long    flags;\n\tstruct cmd_rcvr  *rcvr;\n\tstruct cmd_rcvr  *rcvrs = NULL;\n\tstruct module    *owner;\n\n\tif (!acquire_ipmi_user(user, &i)) {\n\t\t \n\t\tsynchronize_srcu(&user->release_barrier);\n\t\treturn;\n\t}\n\n\trcu_assign_pointer(user->self, NULL);\n\trelease_ipmi_user(user, i);\n\n\tsynchronize_srcu(&user->release_barrier);\n\n\tif (user->handler->shutdown)\n\t\tuser->handler->shutdown(user->handler_data);\n\n\tif (user->handler->ipmi_watchdog_pretimeout)\n\t\tsmi_remove_watch(intf, IPMI_WATCH_MASK_CHECK_WATCHDOG);\n\n\tif (user->gets_events)\n\t\tatomic_dec(&intf->event_waiters);\n\n\t \n\tspin_lock_irqsave(&intf->seq_lock, flags);\n\tlist_del_rcu(&user->link);\n\tatomic_dec(&intf->nr_users);\n\n\tfor (i = 0; i < IPMI_IPMB_NUM_SEQ; i++) {\n\t\tif (intf->seq_table[i].inuse\n\t\t    && (intf->seq_table[i].recv_msg->user == user)) {\n\t\t\tintf->seq_table[i].inuse = 0;\n\t\t\tsmi_remove_watch(intf, IPMI_WATCH_MASK_CHECK_MESSAGES);\n\t\t\tipmi_free_recv_msg(intf->seq_table[i].recv_msg);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&intf->seq_lock, flags);\n\n\t \n\tmutex_lock(&intf->cmd_rcvrs_mutex);\n\tlist_for_each_entry_rcu(rcvr, &intf->cmd_rcvrs, link,\n\t\t\t\tlockdep_is_held(&intf->cmd_rcvrs_mutex)) {\n\t\tif (rcvr->user == user) {\n\t\t\tlist_del_rcu(&rcvr->link);\n\t\t\trcvr->next = rcvrs;\n\t\t\trcvrs = rcvr;\n\t\t}\n\t}\n\tmutex_unlock(&intf->cmd_rcvrs_mutex);\n\tsynchronize_rcu();\n\twhile (rcvrs) {\n\t\trcvr = rcvrs;\n\t\trcvrs = rcvr->next;\n\t\tkfree(rcvr);\n\t}\n\n\towner = intf->owner;\n\tkref_put(&intf->refcount, intf_free);\n\tmodule_put(owner);\n}\n\nint ipmi_destroy_user(struct ipmi_user *user)\n{\n\t_ipmi_destroy_user(user);\n\n\tkref_put(&user->refcount, free_user);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ipmi_destroy_user);\n\nint ipmi_get_version(struct ipmi_user *user,\n\t\t     unsigned char *major,\n\t\t     unsigned char *minor)\n{\n\tstruct ipmi_device_id id;\n\tint rv, index;\n\n\tuser = acquire_ipmi_user(user, &index);\n\tif (!user)\n\t\treturn -ENODEV;\n\n\trv = bmc_get_device_id(user->intf, NULL, &id, NULL, NULL);\n\tif (!rv) {\n\t\t*major = ipmi_version_major(&id);\n\t\t*minor = ipmi_version_minor(&id);\n\t}\n\trelease_ipmi_user(user, index);\n\n\treturn rv;\n}\nEXPORT_SYMBOL(ipmi_get_version);\n\nint ipmi_set_my_address(struct ipmi_user *user,\n\t\t\tunsigned int  channel,\n\t\t\tunsigned char address)\n{\n\tint index, rv = 0;\n\n\tuser = acquire_ipmi_user(user, &index);\n\tif (!user)\n\t\treturn -ENODEV;\n\n\tif (channel >= IPMI_MAX_CHANNELS) {\n\t\trv = -EINVAL;\n\t} else {\n\t\tchannel = array_index_nospec(channel, IPMI_MAX_CHANNELS);\n\t\tuser->intf->addrinfo[channel].address = address;\n\t}\n\trelease_ipmi_user(user, index);\n\n\treturn rv;\n}\nEXPORT_SYMBOL(ipmi_set_my_address);\n\nint ipmi_get_my_address(struct ipmi_user *user,\n\t\t\tunsigned int  channel,\n\t\t\tunsigned char *address)\n{\n\tint index, rv = 0;\n\n\tuser = acquire_ipmi_user(user, &index);\n\tif (!user)\n\t\treturn -ENODEV;\n\n\tif (channel >= IPMI_MAX_CHANNELS) {\n\t\trv = -EINVAL;\n\t} else {\n\t\tchannel = array_index_nospec(channel, IPMI_MAX_CHANNELS);\n\t\t*address = user->intf->addrinfo[channel].address;\n\t}\n\trelease_ipmi_user(user, index);\n\n\treturn rv;\n}\nEXPORT_SYMBOL(ipmi_get_my_address);\n\nint ipmi_set_my_LUN(struct ipmi_user *user,\n\t\t    unsigned int  channel,\n\t\t    unsigned char LUN)\n{\n\tint index, rv = 0;\n\n\tuser = acquire_ipmi_user(user, &index);\n\tif (!user)\n\t\treturn -ENODEV;\n\n\tif (channel >= IPMI_MAX_CHANNELS) {\n\t\trv = -EINVAL;\n\t} else {\n\t\tchannel = array_index_nospec(channel, IPMI_MAX_CHANNELS);\n\t\tuser->intf->addrinfo[channel].lun = LUN & 0x3;\n\t}\n\trelease_ipmi_user(user, index);\n\n\treturn rv;\n}\nEXPORT_SYMBOL(ipmi_set_my_LUN);\n\nint ipmi_get_my_LUN(struct ipmi_user *user,\n\t\t    unsigned int  channel,\n\t\t    unsigned char *address)\n{\n\tint index, rv = 0;\n\n\tuser = acquire_ipmi_user(user, &index);\n\tif (!user)\n\t\treturn -ENODEV;\n\n\tif (channel >= IPMI_MAX_CHANNELS) {\n\t\trv = -EINVAL;\n\t} else {\n\t\tchannel = array_index_nospec(channel, IPMI_MAX_CHANNELS);\n\t\t*address = user->intf->addrinfo[channel].lun;\n\t}\n\trelease_ipmi_user(user, index);\n\n\treturn rv;\n}\nEXPORT_SYMBOL(ipmi_get_my_LUN);\n\nint ipmi_get_maintenance_mode(struct ipmi_user *user)\n{\n\tint mode, index;\n\tunsigned long flags;\n\n\tuser = acquire_ipmi_user(user, &index);\n\tif (!user)\n\t\treturn -ENODEV;\n\n\tspin_lock_irqsave(&user->intf->maintenance_mode_lock, flags);\n\tmode = user->intf->maintenance_mode;\n\tspin_unlock_irqrestore(&user->intf->maintenance_mode_lock, flags);\n\trelease_ipmi_user(user, index);\n\n\treturn mode;\n}\nEXPORT_SYMBOL(ipmi_get_maintenance_mode);\n\nstatic void maintenance_mode_update(struct ipmi_smi *intf)\n{\n\tif (intf->handlers->set_maintenance_mode)\n\t\tintf->handlers->set_maintenance_mode(\n\t\t\tintf->send_info, intf->maintenance_mode_enable);\n}\n\nint ipmi_set_maintenance_mode(struct ipmi_user *user, int mode)\n{\n\tint rv = 0, index;\n\tunsigned long flags;\n\tstruct ipmi_smi *intf = user->intf;\n\n\tuser = acquire_ipmi_user(user, &index);\n\tif (!user)\n\t\treturn -ENODEV;\n\n\tspin_lock_irqsave(&intf->maintenance_mode_lock, flags);\n\tif (intf->maintenance_mode != mode) {\n\t\tswitch (mode) {\n\t\tcase IPMI_MAINTENANCE_MODE_AUTO:\n\t\t\tintf->maintenance_mode_enable\n\t\t\t\t= (intf->auto_maintenance_timeout > 0);\n\t\t\tbreak;\n\n\t\tcase IPMI_MAINTENANCE_MODE_OFF:\n\t\t\tintf->maintenance_mode_enable = false;\n\t\t\tbreak;\n\n\t\tcase IPMI_MAINTENANCE_MODE_ON:\n\t\t\tintf->maintenance_mode_enable = true;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\trv = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tintf->maintenance_mode = mode;\n\n\t\tmaintenance_mode_update(intf);\n\t}\n out_unlock:\n\tspin_unlock_irqrestore(&intf->maintenance_mode_lock, flags);\n\trelease_ipmi_user(user, index);\n\n\treturn rv;\n}\nEXPORT_SYMBOL(ipmi_set_maintenance_mode);\n\nint ipmi_set_gets_events(struct ipmi_user *user, bool val)\n{\n\tunsigned long        flags;\n\tstruct ipmi_smi      *intf = user->intf;\n\tstruct ipmi_recv_msg *msg, *msg2;\n\tstruct list_head     msgs;\n\tint index;\n\n\tuser = acquire_ipmi_user(user, &index);\n\tif (!user)\n\t\treturn -ENODEV;\n\n\tINIT_LIST_HEAD(&msgs);\n\n\tspin_lock_irqsave(&intf->events_lock, flags);\n\tif (user->gets_events == val)\n\t\tgoto out;\n\n\tuser->gets_events = val;\n\n\tif (val) {\n\t\tif (atomic_inc_return(&intf->event_waiters) == 1)\n\t\t\tneed_waiter(intf);\n\t} else {\n\t\tatomic_dec(&intf->event_waiters);\n\t}\n\n\tif (intf->delivering_events)\n\t\t \n\t\tgoto out;\n\n\t \n\twhile (user->gets_events && !list_empty(&intf->waiting_events)) {\n\t\tlist_for_each_entry_safe(msg, msg2, &intf->waiting_events, link)\n\t\t\tlist_move_tail(&msg->link, &msgs);\n\t\tintf->waiting_events_count = 0;\n\t\tif (intf->event_msg_printed) {\n\t\t\tdev_warn(intf->si_dev, \"Event queue no longer full\\n\");\n\t\t\tintf->event_msg_printed = 0;\n\t\t}\n\n\t\tintf->delivering_events = 1;\n\t\tspin_unlock_irqrestore(&intf->events_lock, flags);\n\n\t\tlist_for_each_entry_safe(msg, msg2, &msgs, link) {\n\t\t\tmsg->user = user;\n\t\t\tkref_get(&user->refcount);\n\t\t\tdeliver_local_response(intf, msg);\n\t\t}\n\n\t\tspin_lock_irqsave(&intf->events_lock, flags);\n\t\tintf->delivering_events = 0;\n\t}\n\n out:\n\tspin_unlock_irqrestore(&intf->events_lock, flags);\n\trelease_ipmi_user(user, index);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ipmi_set_gets_events);\n\nstatic struct cmd_rcvr *find_cmd_rcvr(struct ipmi_smi *intf,\n\t\t\t\t      unsigned char netfn,\n\t\t\t\t      unsigned char cmd,\n\t\t\t\t      unsigned char chan)\n{\n\tstruct cmd_rcvr *rcvr;\n\n\tlist_for_each_entry_rcu(rcvr, &intf->cmd_rcvrs, link,\n\t\t\t\tlockdep_is_held(&intf->cmd_rcvrs_mutex)) {\n\t\tif ((rcvr->netfn == netfn) && (rcvr->cmd == cmd)\n\t\t\t\t\t&& (rcvr->chans & (1 << chan)))\n\t\t\treturn rcvr;\n\t}\n\treturn NULL;\n}\n\nstatic int is_cmd_rcvr_exclusive(struct ipmi_smi *intf,\n\t\t\t\t unsigned char netfn,\n\t\t\t\t unsigned char cmd,\n\t\t\t\t unsigned int  chans)\n{\n\tstruct cmd_rcvr *rcvr;\n\n\tlist_for_each_entry_rcu(rcvr, &intf->cmd_rcvrs, link,\n\t\t\t\tlockdep_is_held(&intf->cmd_rcvrs_mutex)) {\n\t\tif ((rcvr->netfn == netfn) && (rcvr->cmd == cmd)\n\t\t\t\t\t&& (rcvr->chans & chans))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nint ipmi_register_for_cmd(struct ipmi_user *user,\n\t\t\t  unsigned char netfn,\n\t\t\t  unsigned char cmd,\n\t\t\t  unsigned int  chans)\n{\n\tstruct ipmi_smi *intf = user->intf;\n\tstruct cmd_rcvr *rcvr;\n\tint rv = 0, index;\n\n\tuser = acquire_ipmi_user(user, &index);\n\tif (!user)\n\t\treturn -ENODEV;\n\n\trcvr = kmalloc(sizeof(*rcvr), GFP_KERNEL);\n\tif (!rcvr) {\n\t\trv = -ENOMEM;\n\t\tgoto out_release;\n\t}\n\trcvr->cmd = cmd;\n\trcvr->netfn = netfn;\n\trcvr->chans = chans;\n\trcvr->user = user;\n\n\tmutex_lock(&intf->cmd_rcvrs_mutex);\n\t \n\tif (!is_cmd_rcvr_exclusive(intf, netfn, cmd, chans)) {\n\t\trv = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\n\tsmi_add_watch(intf, IPMI_WATCH_MASK_CHECK_COMMANDS);\n\n\tlist_add_rcu(&rcvr->link, &intf->cmd_rcvrs);\n\nout_unlock:\n\tmutex_unlock(&intf->cmd_rcvrs_mutex);\n\tif (rv)\n\t\tkfree(rcvr);\nout_release:\n\trelease_ipmi_user(user, index);\n\n\treturn rv;\n}\nEXPORT_SYMBOL(ipmi_register_for_cmd);\n\nint ipmi_unregister_for_cmd(struct ipmi_user *user,\n\t\t\t    unsigned char netfn,\n\t\t\t    unsigned char cmd,\n\t\t\t    unsigned int  chans)\n{\n\tstruct ipmi_smi *intf = user->intf;\n\tstruct cmd_rcvr *rcvr;\n\tstruct cmd_rcvr *rcvrs = NULL;\n\tint i, rv = -ENOENT, index;\n\n\tuser = acquire_ipmi_user(user, &index);\n\tif (!user)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&intf->cmd_rcvrs_mutex);\n\tfor (i = 0; i < IPMI_NUM_CHANNELS; i++) {\n\t\tif (((1 << i) & chans) == 0)\n\t\t\tcontinue;\n\t\trcvr = find_cmd_rcvr(intf, netfn, cmd, i);\n\t\tif (rcvr == NULL)\n\t\t\tcontinue;\n\t\tif (rcvr->user == user) {\n\t\t\trv = 0;\n\t\t\trcvr->chans &= ~chans;\n\t\t\tif (rcvr->chans == 0) {\n\t\t\t\tlist_del_rcu(&rcvr->link);\n\t\t\t\trcvr->next = rcvrs;\n\t\t\t\trcvrs = rcvr;\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&intf->cmd_rcvrs_mutex);\n\tsynchronize_rcu();\n\trelease_ipmi_user(user, index);\n\twhile (rcvrs) {\n\t\tsmi_remove_watch(intf, IPMI_WATCH_MASK_CHECK_COMMANDS);\n\t\trcvr = rcvrs;\n\t\trcvrs = rcvr->next;\n\t\tkfree(rcvr);\n\t}\n\n\treturn rv;\n}\nEXPORT_SYMBOL(ipmi_unregister_for_cmd);\n\nunsigned char\nipmb_checksum(unsigned char *data, int size)\n{\n\tunsigned char csum = 0;\n\n\tfor (; size > 0; size--, data++)\n\t\tcsum += *data;\n\n\treturn -csum;\n}\nEXPORT_SYMBOL(ipmb_checksum);\n\nstatic inline void format_ipmb_msg(struct ipmi_smi_msg   *smi_msg,\n\t\t\t\t   struct kernel_ipmi_msg *msg,\n\t\t\t\t   struct ipmi_ipmb_addr *ipmb_addr,\n\t\t\t\t   long                  msgid,\n\t\t\t\t   unsigned char         ipmb_seq,\n\t\t\t\t   int                   broadcast,\n\t\t\t\t   unsigned char         source_address,\n\t\t\t\t   unsigned char         source_lun)\n{\n\tint i = broadcast;\n\n\t \n\tsmi_msg->data[0] = (IPMI_NETFN_APP_REQUEST << 2);\n\tsmi_msg->data[1] = IPMI_SEND_MSG_CMD;\n\tsmi_msg->data[2] = ipmb_addr->channel;\n\tif (broadcast)\n\t\tsmi_msg->data[3] = 0;\n\tsmi_msg->data[i+3] = ipmb_addr->slave_addr;\n\tsmi_msg->data[i+4] = (msg->netfn << 2) | (ipmb_addr->lun & 0x3);\n\tsmi_msg->data[i+5] = ipmb_checksum(&smi_msg->data[i + 3], 2);\n\tsmi_msg->data[i+6] = source_address;\n\tsmi_msg->data[i+7] = (ipmb_seq << 2) | source_lun;\n\tsmi_msg->data[i+8] = msg->cmd;\n\n\t \n\tif (msg->data_len > 0)\n\t\tmemcpy(&smi_msg->data[i + 9], msg->data, msg->data_len);\n\tsmi_msg->data_size = msg->data_len + 9;\n\n\t \n\tsmi_msg->data[i+smi_msg->data_size]\n\t\t= ipmb_checksum(&smi_msg->data[i + 6], smi_msg->data_size - 6);\n\n\t \n\tsmi_msg->data_size += 1 + i;\n\n\tsmi_msg->msgid = msgid;\n}\n\nstatic inline void format_lan_msg(struct ipmi_smi_msg   *smi_msg,\n\t\t\t\t  struct kernel_ipmi_msg *msg,\n\t\t\t\t  struct ipmi_lan_addr  *lan_addr,\n\t\t\t\t  long                  msgid,\n\t\t\t\t  unsigned char         ipmb_seq,\n\t\t\t\t  unsigned char         source_lun)\n{\n\t \n\tsmi_msg->data[0] = (IPMI_NETFN_APP_REQUEST << 2);\n\tsmi_msg->data[1] = IPMI_SEND_MSG_CMD;\n\tsmi_msg->data[2] = lan_addr->channel;\n\tsmi_msg->data[3] = lan_addr->session_handle;\n\tsmi_msg->data[4] = lan_addr->remote_SWID;\n\tsmi_msg->data[5] = (msg->netfn << 2) | (lan_addr->lun & 0x3);\n\tsmi_msg->data[6] = ipmb_checksum(&smi_msg->data[4], 2);\n\tsmi_msg->data[7] = lan_addr->local_SWID;\n\tsmi_msg->data[8] = (ipmb_seq << 2) | source_lun;\n\tsmi_msg->data[9] = msg->cmd;\n\n\t \n\tif (msg->data_len > 0)\n\t\tmemcpy(&smi_msg->data[10], msg->data, msg->data_len);\n\tsmi_msg->data_size = msg->data_len + 10;\n\n\t \n\tsmi_msg->data[smi_msg->data_size]\n\t\t= ipmb_checksum(&smi_msg->data[7], smi_msg->data_size - 7);\n\n\t \n\tsmi_msg->data_size += 1;\n\n\tsmi_msg->msgid = msgid;\n}\n\nstatic struct ipmi_smi_msg *smi_add_send_msg(struct ipmi_smi *intf,\n\t\t\t\t\t     struct ipmi_smi_msg *smi_msg,\n\t\t\t\t\t     int priority)\n{\n\tif (intf->curr_msg) {\n\t\tif (priority > 0)\n\t\t\tlist_add_tail(&smi_msg->link, &intf->hp_xmit_msgs);\n\t\telse\n\t\t\tlist_add_tail(&smi_msg->link, &intf->xmit_msgs);\n\t\tsmi_msg = NULL;\n\t} else {\n\t\tintf->curr_msg = smi_msg;\n\t}\n\n\treturn smi_msg;\n}\n\nstatic void smi_send(struct ipmi_smi *intf,\n\t\t     const struct ipmi_smi_handlers *handlers,\n\t\t     struct ipmi_smi_msg *smi_msg, int priority)\n{\n\tint run_to_completion = intf->run_to_completion;\n\tunsigned long flags = 0;\n\n\tif (!run_to_completion)\n\t\tspin_lock_irqsave(&intf->xmit_msgs_lock, flags);\n\tsmi_msg = smi_add_send_msg(intf, smi_msg, priority);\n\n\tif (!run_to_completion)\n\t\tspin_unlock_irqrestore(&intf->xmit_msgs_lock, flags);\n\n\tif (smi_msg)\n\t\thandlers->sender(intf->send_info, smi_msg);\n}\n\nstatic bool is_maintenance_mode_cmd(struct kernel_ipmi_msg *msg)\n{\n\treturn (((msg->netfn == IPMI_NETFN_APP_REQUEST)\n\t\t && ((msg->cmd == IPMI_COLD_RESET_CMD)\n\t\t     || (msg->cmd == IPMI_WARM_RESET_CMD)))\n\t\t|| (msg->netfn == IPMI_NETFN_FIRMWARE_REQUEST));\n}\n\nstatic int i_ipmi_req_sysintf(struct ipmi_smi        *intf,\n\t\t\t      struct ipmi_addr       *addr,\n\t\t\t      long                   msgid,\n\t\t\t      struct kernel_ipmi_msg *msg,\n\t\t\t      struct ipmi_smi_msg    *smi_msg,\n\t\t\t      struct ipmi_recv_msg   *recv_msg,\n\t\t\t      int                    retries,\n\t\t\t      unsigned int           retry_time_ms)\n{\n\tstruct ipmi_system_interface_addr *smi_addr;\n\n\tif (msg->netfn & 1)\n\t\t \n\t\treturn -EINVAL;\n\n\tsmi_addr = (struct ipmi_system_interface_addr *) addr;\n\tif (smi_addr->lun > 3) {\n\t\tipmi_inc_stat(intf, sent_invalid_commands);\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(&recv_msg->addr, smi_addr, sizeof(*smi_addr));\n\n\tif ((msg->netfn == IPMI_NETFN_APP_REQUEST)\n\t    && ((msg->cmd == IPMI_SEND_MSG_CMD)\n\t\t|| (msg->cmd == IPMI_GET_MSG_CMD)\n\t\t|| (msg->cmd == IPMI_READ_EVENT_MSG_BUFFER_CMD))) {\n\t\t \n\t\tipmi_inc_stat(intf, sent_invalid_commands);\n\t\treturn -EINVAL;\n\t}\n\n\tif (is_maintenance_mode_cmd(msg)) {\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&intf->maintenance_mode_lock, flags);\n\t\tintf->auto_maintenance_timeout\n\t\t\t= maintenance_mode_timeout_ms;\n\t\tif (!intf->maintenance_mode\n\t\t    && !intf->maintenance_mode_enable) {\n\t\t\tintf->maintenance_mode_enable = true;\n\t\t\tmaintenance_mode_update(intf);\n\t\t}\n\t\tspin_unlock_irqrestore(&intf->maintenance_mode_lock,\n\t\t\t\t       flags);\n\t}\n\n\tif (msg->data_len + 2 > IPMI_MAX_MSG_LENGTH) {\n\t\tipmi_inc_stat(intf, sent_invalid_commands);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tsmi_msg->data[0] = (msg->netfn << 2) | (smi_addr->lun & 0x3);\n\tsmi_msg->data[1] = msg->cmd;\n\tsmi_msg->msgid = msgid;\n\tsmi_msg->user_data = recv_msg;\n\tif (msg->data_len > 0)\n\t\tmemcpy(&smi_msg->data[2], msg->data, msg->data_len);\n\tsmi_msg->data_size = msg->data_len + 2;\n\tipmi_inc_stat(intf, sent_local_commands);\n\n\treturn 0;\n}\n\nstatic int i_ipmi_req_ipmb(struct ipmi_smi        *intf,\n\t\t\t   struct ipmi_addr       *addr,\n\t\t\t   long                   msgid,\n\t\t\t   struct kernel_ipmi_msg *msg,\n\t\t\t   struct ipmi_smi_msg    *smi_msg,\n\t\t\t   struct ipmi_recv_msg   *recv_msg,\n\t\t\t   unsigned char          source_address,\n\t\t\t   unsigned char          source_lun,\n\t\t\t   int                    retries,\n\t\t\t   unsigned int           retry_time_ms)\n{\n\tstruct ipmi_ipmb_addr *ipmb_addr;\n\tunsigned char ipmb_seq;\n\tlong seqid;\n\tint broadcast = 0;\n\tstruct ipmi_channel *chans;\n\tint rv = 0;\n\n\tif (addr->channel >= IPMI_MAX_CHANNELS) {\n\t\tipmi_inc_stat(intf, sent_invalid_commands);\n\t\treturn -EINVAL;\n\t}\n\n\tchans = READ_ONCE(intf->channel_list)->c;\n\n\tif (chans[addr->channel].medium != IPMI_CHANNEL_MEDIUM_IPMB) {\n\t\tipmi_inc_stat(intf, sent_invalid_commands);\n\t\treturn -EINVAL;\n\t}\n\n\tif (addr->addr_type == IPMI_IPMB_BROADCAST_ADDR_TYPE) {\n\t\t \n\t\taddr->addr_type = IPMI_IPMB_ADDR_TYPE;\n\t\tbroadcast = 1;\n\t\tretries = 0;  \n\t}\n\n\t \n\tif ((msg->data_len + 10 + broadcast) > IPMI_MAX_MSG_LENGTH) {\n\t\tipmi_inc_stat(intf, sent_invalid_commands);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tipmb_addr = (struct ipmi_ipmb_addr *) addr;\n\tif (ipmb_addr->lun > 3) {\n\t\tipmi_inc_stat(intf, sent_invalid_commands);\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(&recv_msg->addr, ipmb_addr, sizeof(*ipmb_addr));\n\n\tif (recv_msg->msg.netfn & 0x1) {\n\t\t \n\t\tipmi_inc_stat(intf, sent_ipmb_responses);\n\t\tformat_ipmb_msg(smi_msg, msg, ipmb_addr, msgid,\n\t\t\t\tmsgid, broadcast,\n\t\t\t\tsource_address, source_lun);\n\n\t\t \n\t\tsmi_msg->user_data = recv_msg;\n\t} else {\n\t\t \n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&intf->seq_lock, flags);\n\n\t\tif (is_maintenance_mode_cmd(msg))\n\t\t\tintf->ipmb_maintenance_mode_timeout =\n\t\t\t\tmaintenance_mode_timeout_ms;\n\n\t\tif (intf->ipmb_maintenance_mode_timeout && retry_time_ms == 0)\n\t\t\t \n\t\t\tretry_time_ms = default_maintenance_retry_ms;\n\n\t\t \n\t\trv = intf_next_seq(intf,\n\t\t\t\t   recv_msg,\n\t\t\t\t   retry_time_ms,\n\t\t\t\t   retries,\n\t\t\t\t   broadcast,\n\t\t\t\t   &ipmb_seq,\n\t\t\t\t   &seqid);\n\t\tif (rv)\n\t\t\t \n\t\t\tgoto out_err;\n\n\t\tipmi_inc_stat(intf, sent_ipmb_commands);\n\n\t\t \n\t\tformat_ipmb_msg(smi_msg, msg, ipmb_addr,\n\t\t\t\tSTORE_SEQ_IN_MSGID(ipmb_seq, seqid),\n\t\t\t\tipmb_seq, broadcast,\n\t\t\t\tsource_address, source_lun);\n\n\t\t \n\t\tmemcpy(recv_msg->msg_data, smi_msg->data,\n\t\t       smi_msg->data_size);\n\t\trecv_msg->msg.data = recv_msg->msg_data;\n\t\trecv_msg->msg.data_len = smi_msg->data_size;\n\n\t\t \nout_err:\n\t\tspin_unlock_irqrestore(&intf->seq_lock, flags);\n\t}\n\n\treturn rv;\n}\n\nstatic int i_ipmi_req_ipmb_direct(struct ipmi_smi        *intf,\n\t\t\t\t  struct ipmi_addr       *addr,\n\t\t\t\t  long\t\t\t msgid,\n\t\t\t\t  struct kernel_ipmi_msg *msg,\n\t\t\t\t  struct ipmi_smi_msg    *smi_msg,\n\t\t\t\t  struct ipmi_recv_msg   *recv_msg,\n\t\t\t\t  unsigned char          source_lun)\n{\n\tstruct ipmi_ipmb_direct_addr *daddr;\n\tbool is_cmd = !(recv_msg->msg.netfn & 0x1);\n\n\tif (!(intf->handlers->flags & IPMI_SMI_CAN_HANDLE_IPMB_DIRECT))\n\t\treturn -EAFNOSUPPORT;\n\n\t \n\tif (!is_cmd && msg->data_len < 1) {\n\t\tipmi_inc_stat(intf, sent_invalid_commands);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((msg->data_len + 4) > IPMI_MAX_MSG_LENGTH) {\n\t\tipmi_inc_stat(intf, sent_invalid_commands);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tdaddr = (struct ipmi_ipmb_direct_addr *) addr;\n\tif (daddr->rq_lun > 3 || daddr->rs_lun > 3) {\n\t\tipmi_inc_stat(intf, sent_invalid_commands);\n\t\treturn -EINVAL;\n\t}\n\n\tsmi_msg->type = IPMI_SMI_MSG_TYPE_IPMB_DIRECT;\n\tsmi_msg->msgid = msgid;\n\n\tif (is_cmd) {\n\t\tsmi_msg->data[0] = msg->netfn << 2 | daddr->rs_lun;\n\t\tsmi_msg->data[2] = recv_msg->msgid << 2 | daddr->rq_lun;\n\t} else {\n\t\tsmi_msg->data[0] = msg->netfn << 2 | daddr->rq_lun;\n\t\tsmi_msg->data[2] = recv_msg->msgid << 2 | daddr->rs_lun;\n\t}\n\tsmi_msg->data[1] = daddr->slave_addr;\n\tsmi_msg->data[3] = msg->cmd;\n\n\tmemcpy(smi_msg->data + 4, msg->data, msg->data_len);\n\tsmi_msg->data_size = msg->data_len + 4;\n\n\tsmi_msg->user_data = recv_msg;\n\n\treturn 0;\n}\n\nstatic int i_ipmi_req_lan(struct ipmi_smi        *intf,\n\t\t\t  struct ipmi_addr       *addr,\n\t\t\t  long                   msgid,\n\t\t\t  struct kernel_ipmi_msg *msg,\n\t\t\t  struct ipmi_smi_msg    *smi_msg,\n\t\t\t  struct ipmi_recv_msg   *recv_msg,\n\t\t\t  unsigned char          source_lun,\n\t\t\t  int                    retries,\n\t\t\t  unsigned int           retry_time_ms)\n{\n\tstruct ipmi_lan_addr  *lan_addr;\n\tunsigned char ipmb_seq;\n\tlong seqid;\n\tstruct ipmi_channel *chans;\n\tint rv = 0;\n\n\tif (addr->channel >= IPMI_MAX_CHANNELS) {\n\t\tipmi_inc_stat(intf, sent_invalid_commands);\n\t\treturn -EINVAL;\n\t}\n\n\tchans = READ_ONCE(intf->channel_list)->c;\n\n\tif ((chans[addr->channel].medium\n\t\t\t\t!= IPMI_CHANNEL_MEDIUM_8023LAN)\n\t\t\t&& (chans[addr->channel].medium\n\t\t\t    != IPMI_CHANNEL_MEDIUM_ASYNC)) {\n\t\tipmi_inc_stat(intf, sent_invalid_commands);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif ((msg->data_len + 12) > IPMI_MAX_MSG_LENGTH) {\n\t\tipmi_inc_stat(intf, sent_invalid_commands);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tlan_addr = (struct ipmi_lan_addr *) addr;\n\tif (lan_addr->lun > 3) {\n\t\tipmi_inc_stat(intf, sent_invalid_commands);\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(&recv_msg->addr, lan_addr, sizeof(*lan_addr));\n\n\tif (recv_msg->msg.netfn & 0x1) {\n\t\t \n\t\tipmi_inc_stat(intf, sent_lan_responses);\n\t\tformat_lan_msg(smi_msg, msg, lan_addr, msgid,\n\t\t\t       msgid, source_lun);\n\n\t\t \n\t\tsmi_msg->user_data = recv_msg;\n\t} else {\n\t\t \n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&intf->seq_lock, flags);\n\n\t\t \n\t\trv = intf_next_seq(intf,\n\t\t\t\t   recv_msg,\n\t\t\t\t   retry_time_ms,\n\t\t\t\t   retries,\n\t\t\t\t   0,\n\t\t\t\t   &ipmb_seq,\n\t\t\t\t   &seqid);\n\t\tif (rv)\n\t\t\t \n\t\t\tgoto out_err;\n\n\t\tipmi_inc_stat(intf, sent_lan_commands);\n\n\t\t \n\t\tformat_lan_msg(smi_msg, msg, lan_addr,\n\t\t\t       STORE_SEQ_IN_MSGID(ipmb_seq, seqid),\n\t\t\t       ipmb_seq, source_lun);\n\n\t\t \n\t\tmemcpy(recv_msg->msg_data, smi_msg->data,\n\t\t       smi_msg->data_size);\n\t\trecv_msg->msg.data = recv_msg->msg_data;\n\t\trecv_msg->msg.data_len = smi_msg->data_size;\n\n\t\t \nout_err:\n\t\tspin_unlock_irqrestore(&intf->seq_lock, flags);\n\t}\n\n\treturn rv;\n}\n\n \nstatic int i_ipmi_request(struct ipmi_user     *user,\n\t\t\t  struct ipmi_smi      *intf,\n\t\t\t  struct ipmi_addr     *addr,\n\t\t\t  long                 msgid,\n\t\t\t  struct kernel_ipmi_msg *msg,\n\t\t\t  void                 *user_msg_data,\n\t\t\t  void                 *supplied_smi,\n\t\t\t  struct ipmi_recv_msg *supplied_recv,\n\t\t\t  int                  priority,\n\t\t\t  unsigned char        source_address,\n\t\t\t  unsigned char        source_lun,\n\t\t\t  int                  retries,\n\t\t\t  unsigned int         retry_time_ms)\n{\n\tstruct ipmi_smi_msg *smi_msg;\n\tstruct ipmi_recv_msg *recv_msg;\n\tint rv = 0;\n\n\tif (user) {\n\t\tif (atomic_add_return(1, &user->nr_msgs) > max_msgs_per_user) {\n\t\t\t \n\t\t\trv = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (supplied_recv)\n\t\trecv_msg = supplied_recv;\n\telse {\n\t\trecv_msg = ipmi_alloc_recv_msg();\n\t\tif (recv_msg == NULL) {\n\t\t\trv = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\trecv_msg->user_msg_data = user_msg_data;\n\n\tif (supplied_smi)\n\t\tsmi_msg = supplied_smi;\n\telse {\n\t\tsmi_msg = ipmi_alloc_smi_msg();\n\t\tif (smi_msg == NULL) {\n\t\t\tif (!supplied_recv)\n\t\t\t\tipmi_free_recv_msg(recv_msg);\n\t\t\trv = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\trcu_read_lock();\n\tif (intf->in_shutdown) {\n\t\trv = -ENODEV;\n\t\tgoto out_err;\n\t}\n\n\trecv_msg->user = user;\n\tif (user)\n\t\t \n\t\tkref_get(&user->refcount);\n\trecv_msg->msgid = msgid;\n\t \n\trecv_msg->msg = *msg;\n\n\tif (addr->addr_type == IPMI_SYSTEM_INTERFACE_ADDR_TYPE) {\n\t\trv = i_ipmi_req_sysintf(intf, addr, msgid, msg, smi_msg,\n\t\t\t\t\trecv_msg, retries, retry_time_ms);\n\t} else if (is_ipmb_addr(addr) || is_ipmb_bcast_addr(addr)) {\n\t\trv = i_ipmi_req_ipmb(intf, addr, msgid, msg, smi_msg, recv_msg,\n\t\t\t\t     source_address, source_lun,\n\t\t\t\t     retries, retry_time_ms);\n\t} else if (is_ipmb_direct_addr(addr)) {\n\t\trv = i_ipmi_req_ipmb_direct(intf, addr, msgid, msg, smi_msg,\n\t\t\t\t\t    recv_msg, source_lun);\n\t} else if (is_lan_addr(addr)) {\n\t\trv = i_ipmi_req_lan(intf, addr, msgid, msg, smi_msg, recv_msg,\n\t\t\t\t    source_lun, retries, retry_time_ms);\n\t} else {\n\t     \n\t\tipmi_inc_stat(intf, sent_invalid_commands);\n\t\trv = -EINVAL;\n\t}\n\n\tif (rv) {\nout_err:\n\t\tipmi_free_smi_msg(smi_msg);\n\t\tipmi_free_recv_msg(recv_msg);\n\t} else {\n\t\tdev_dbg(intf->si_dev, \"Send: %*ph\\n\",\n\t\t\tsmi_msg->data_size, smi_msg->data);\n\n\t\tsmi_send(intf, intf->handlers, smi_msg, priority);\n\t}\n\trcu_read_unlock();\n\nout:\n\tif (rv && user)\n\t\tatomic_dec(&user->nr_msgs);\n\treturn rv;\n}\n\nstatic int check_addr(struct ipmi_smi  *intf,\n\t\t      struct ipmi_addr *addr,\n\t\t      unsigned char    *saddr,\n\t\t      unsigned char    *lun)\n{\n\tif (addr->channel >= IPMI_MAX_CHANNELS)\n\t\treturn -EINVAL;\n\taddr->channel = array_index_nospec(addr->channel, IPMI_MAX_CHANNELS);\n\t*lun = intf->addrinfo[addr->channel].lun;\n\t*saddr = intf->addrinfo[addr->channel].address;\n\treturn 0;\n}\n\nint ipmi_request_settime(struct ipmi_user *user,\n\t\t\t struct ipmi_addr *addr,\n\t\t\t long             msgid,\n\t\t\t struct kernel_ipmi_msg  *msg,\n\t\t\t void             *user_msg_data,\n\t\t\t int              priority,\n\t\t\t int              retries,\n\t\t\t unsigned int     retry_time_ms)\n{\n\tunsigned char saddr = 0, lun = 0;\n\tint rv, index;\n\n\tif (!user)\n\t\treturn -EINVAL;\n\n\tuser = acquire_ipmi_user(user, &index);\n\tif (!user)\n\t\treturn -ENODEV;\n\n\trv = check_addr(user->intf, addr, &saddr, &lun);\n\tif (!rv)\n\t\trv = i_ipmi_request(user,\n\t\t\t\t    user->intf,\n\t\t\t\t    addr,\n\t\t\t\t    msgid,\n\t\t\t\t    msg,\n\t\t\t\t    user_msg_data,\n\t\t\t\t    NULL, NULL,\n\t\t\t\t    priority,\n\t\t\t\t    saddr,\n\t\t\t\t    lun,\n\t\t\t\t    retries,\n\t\t\t\t    retry_time_ms);\n\n\trelease_ipmi_user(user, index);\n\treturn rv;\n}\nEXPORT_SYMBOL(ipmi_request_settime);\n\nint ipmi_request_supply_msgs(struct ipmi_user     *user,\n\t\t\t     struct ipmi_addr     *addr,\n\t\t\t     long                 msgid,\n\t\t\t     struct kernel_ipmi_msg *msg,\n\t\t\t     void                 *user_msg_data,\n\t\t\t     void                 *supplied_smi,\n\t\t\t     struct ipmi_recv_msg *supplied_recv,\n\t\t\t     int                  priority)\n{\n\tunsigned char saddr = 0, lun = 0;\n\tint rv, index;\n\n\tif (!user)\n\t\treturn -EINVAL;\n\n\tuser = acquire_ipmi_user(user, &index);\n\tif (!user)\n\t\treturn -ENODEV;\n\n\trv = check_addr(user->intf, addr, &saddr, &lun);\n\tif (!rv)\n\t\trv = i_ipmi_request(user,\n\t\t\t\t    user->intf,\n\t\t\t\t    addr,\n\t\t\t\t    msgid,\n\t\t\t\t    msg,\n\t\t\t\t    user_msg_data,\n\t\t\t\t    supplied_smi,\n\t\t\t\t    supplied_recv,\n\t\t\t\t    priority,\n\t\t\t\t    saddr,\n\t\t\t\t    lun,\n\t\t\t\t    -1, 0);\n\n\trelease_ipmi_user(user, index);\n\treturn rv;\n}\nEXPORT_SYMBOL(ipmi_request_supply_msgs);\n\nstatic void bmc_device_id_handler(struct ipmi_smi *intf,\n\t\t\t\t  struct ipmi_recv_msg *msg)\n{\n\tint rv;\n\n\tif ((msg->addr.addr_type != IPMI_SYSTEM_INTERFACE_ADDR_TYPE)\n\t\t\t|| (msg->msg.netfn != IPMI_NETFN_APP_RESPONSE)\n\t\t\t|| (msg->msg.cmd != IPMI_GET_DEVICE_ID_CMD)) {\n\t\tdev_warn(intf->si_dev,\n\t\t\t \"invalid device_id msg: addr_type=%d netfn=%x cmd=%x\\n\",\n\t\t\t msg->addr.addr_type, msg->msg.netfn, msg->msg.cmd);\n\t\treturn;\n\t}\n\n\tif (msg->msg.data[0]) {\n\t\tdev_warn(intf->si_dev, \"device id fetch failed: 0x%2.2x\\n\",\n\t\t\t msg->msg.data[0]);\n\t\tintf->bmc->dyn_id_set = 0;\n\t\tgoto out;\n\t}\n\n\trv = ipmi_demangle_device_id(msg->msg.netfn, msg->msg.cmd,\n\t\t\tmsg->msg.data, msg->msg.data_len, &intf->bmc->fetch_id);\n\tif (rv) {\n\t\tdev_warn(intf->si_dev, \"device id demangle failed: %d\\n\", rv);\n\t\t \n\t\tintf->bmc->cc = msg->msg.data[0];\n\t\tintf->bmc->dyn_id_set = 0;\n\t} else {\n\t\t \n\t\tsmp_wmb();\n\t\tintf->bmc->dyn_id_set = 1;\n\t}\nout:\n\twake_up(&intf->waitq);\n}\n\nstatic int\nsend_get_device_id_cmd(struct ipmi_smi *intf)\n{\n\tstruct ipmi_system_interface_addr si;\n\tstruct kernel_ipmi_msg msg;\n\n\tsi.addr_type = IPMI_SYSTEM_INTERFACE_ADDR_TYPE;\n\tsi.channel = IPMI_BMC_CHANNEL;\n\tsi.lun = 0;\n\n\tmsg.netfn = IPMI_NETFN_APP_REQUEST;\n\tmsg.cmd = IPMI_GET_DEVICE_ID_CMD;\n\tmsg.data = NULL;\n\tmsg.data_len = 0;\n\n\treturn i_ipmi_request(NULL,\n\t\t\t      intf,\n\t\t\t      (struct ipmi_addr *) &si,\n\t\t\t      0,\n\t\t\t      &msg,\n\t\t\t      intf,\n\t\t\t      NULL,\n\t\t\t      NULL,\n\t\t\t      0,\n\t\t\t      intf->addrinfo[0].address,\n\t\t\t      intf->addrinfo[0].lun,\n\t\t\t      -1, 0);\n}\n\nstatic int __get_device_id(struct ipmi_smi *intf, struct bmc_device *bmc)\n{\n\tint rv;\n\tunsigned int retry_count = 0;\n\n\tintf->null_user_handler = bmc_device_id_handler;\n\nretry:\n\tbmc->cc = 0;\n\tbmc->dyn_id_set = 2;\n\n\trv = send_get_device_id_cmd(intf);\n\tif (rv)\n\t\tgoto out_reset_handler;\n\n\twait_event(intf->waitq, bmc->dyn_id_set != 2);\n\n\tif (!bmc->dyn_id_set) {\n\t\tif (bmc->cc != IPMI_CC_NO_ERROR &&\n\t\t    ++retry_count <= GET_DEVICE_ID_MAX_RETRY) {\n\t\t\tmsleep(500);\n\t\t\tdev_warn(intf->si_dev,\n\t\t\t    \"BMC returned 0x%2.2x, retry get bmc device id\\n\",\n\t\t\t    bmc->cc);\n\t\t\tgoto retry;\n\t\t}\n\n\t\trv = -EIO;  \n\t}\n\n\t \n\tsmp_rmb();\n\nout_reset_handler:\n\tintf->null_user_handler = NULL;\n\n\treturn rv;\n}\n\n \nstatic int __bmc_get_device_id(struct ipmi_smi *intf, struct bmc_device *bmc,\n\t\t\t       struct ipmi_device_id *id,\n\t\t\t       bool *guid_set, guid_t *guid, int intf_num)\n{\n\tint rv = 0;\n\tint prev_dyn_id_set, prev_guid_set;\n\tbool intf_set = intf != NULL;\n\n\tif (!intf) {\n\t\tmutex_lock(&bmc->dyn_mutex);\nretry_bmc_lock:\n\t\tif (list_empty(&bmc->intfs)) {\n\t\t\tmutex_unlock(&bmc->dyn_mutex);\n\t\t\treturn -ENOENT;\n\t\t}\n\t\tintf = list_first_entry(&bmc->intfs, struct ipmi_smi,\n\t\t\t\t\tbmc_link);\n\t\tkref_get(&intf->refcount);\n\t\tmutex_unlock(&bmc->dyn_mutex);\n\t\tmutex_lock(&intf->bmc_reg_mutex);\n\t\tmutex_lock(&bmc->dyn_mutex);\n\t\tif (intf != list_first_entry(&bmc->intfs, struct ipmi_smi,\n\t\t\t\t\t     bmc_link)) {\n\t\t\tmutex_unlock(&intf->bmc_reg_mutex);\n\t\t\tkref_put(&intf->refcount, intf_free);\n\t\t\tgoto retry_bmc_lock;\n\t\t}\n\t} else {\n\t\tmutex_lock(&intf->bmc_reg_mutex);\n\t\tbmc = intf->bmc;\n\t\tmutex_lock(&bmc->dyn_mutex);\n\t\tkref_get(&intf->refcount);\n\t}\n\n\t \n\tif (intf->in_bmc_register ||\n\t    (bmc->dyn_id_set && time_is_after_jiffies(bmc->dyn_id_expiry)))\n\t\tgoto out_noprocessing;\n\n\tprev_guid_set = bmc->dyn_guid_set;\n\t__get_guid(intf);\n\n\tprev_dyn_id_set = bmc->dyn_id_set;\n\trv = __get_device_id(intf, bmc);\n\tif (rv)\n\t\tgoto out;\n\n\t \n\tif (!intf->bmc_registered\n\t    || (!prev_guid_set && bmc->dyn_guid_set)\n\t    || (!prev_dyn_id_set && bmc->dyn_id_set)\n\t    || (prev_guid_set && bmc->dyn_guid_set\n\t\t&& !guid_equal(&bmc->guid, &bmc->fetch_guid))\n\t    || bmc->id.device_id != bmc->fetch_id.device_id\n\t    || bmc->id.manufacturer_id != bmc->fetch_id.manufacturer_id\n\t    || bmc->id.product_id != bmc->fetch_id.product_id) {\n\t\tstruct ipmi_device_id id = bmc->fetch_id;\n\t\tint guid_set = bmc->dyn_guid_set;\n\t\tguid_t guid;\n\n\t\tguid = bmc->fetch_guid;\n\t\tmutex_unlock(&bmc->dyn_mutex);\n\n\t\t__ipmi_bmc_unregister(intf);\n\t\t \n\t\tintf->bmc->id = id;\n\t\tintf->bmc->dyn_guid_set = guid_set;\n\t\tintf->bmc->guid = guid;\n\t\tif (__ipmi_bmc_register(intf, &id, guid_set, &guid, intf_num))\n\t\t\tneed_waiter(intf);  \n\t\telse\n\t\t\t__scan_channels(intf, &id);\n\n\n\t\tif (!intf_set) {\n\t\t\t \n\t\t\tmutex_unlock(&intf->bmc_reg_mutex);\n\t\t\tmutex_lock(&bmc->dyn_mutex);\n\t\t\tgoto retry_bmc_lock;\n\t\t}\n\n\t\t \n\t\tbmc = intf->bmc;\n\t\tmutex_lock(&bmc->dyn_mutex);\n\t\tgoto out_noprocessing;\n\t} else if (memcmp(&bmc->fetch_id, &bmc->id, sizeof(bmc->id)))\n\t\t \n\t\t__scan_channels(intf, &bmc->fetch_id);\n\n\tbmc->dyn_id_expiry = jiffies + IPMI_DYN_DEV_ID_EXPIRY;\n\nout:\n\tif (rv && prev_dyn_id_set) {\n\t\trv = 0;  \n\t\tbmc->dyn_id_set = prev_dyn_id_set;\n\t}\n\tif (!rv) {\n\t\tbmc->id = bmc->fetch_id;\n\t\tif (bmc->dyn_guid_set)\n\t\t\tbmc->guid = bmc->fetch_guid;\n\t\telse if (prev_guid_set)\n\t\t\t \n\t\t\tbmc->dyn_guid_set = prev_guid_set;\n\t}\nout_noprocessing:\n\tif (!rv) {\n\t\tif (id)\n\t\t\t*id = bmc->id;\n\n\t\tif (guid_set)\n\t\t\t*guid_set = bmc->dyn_guid_set;\n\n\t\tif (guid && bmc->dyn_guid_set)\n\t\t\t*guid =  bmc->guid;\n\t}\n\n\tmutex_unlock(&bmc->dyn_mutex);\n\tmutex_unlock(&intf->bmc_reg_mutex);\n\n\tkref_put(&intf->refcount, intf_free);\n\treturn rv;\n}\n\nstatic int bmc_get_device_id(struct ipmi_smi *intf, struct bmc_device *bmc,\n\t\t\t     struct ipmi_device_id *id,\n\t\t\t     bool *guid_set, guid_t *guid)\n{\n\treturn __bmc_get_device_id(intf, bmc, id, guid_set, guid, -1);\n}\n\nstatic ssize_t device_id_show(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct bmc_device *bmc = to_bmc_device(dev);\n\tstruct ipmi_device_id id;\n\tint rv;\n\n\trv = bmc_get_device_id(NULL, bmc, &id, NULL, NULL);\n\tif (rv)\n\t\treturn rv;\n\n\treturn sysfs_emit(buf, \"%u\\n\", id.device_id);\n}\nstatic DEVICE_ATTR_RO(device_id);\n\nstatic ssize_t provides_device_sdrs_show(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\tstruct bmc_device *bmc = to_bmc_device(dev);\n\tstruct ipmi_device_id id;\n\tint rv;\n\n\trv = bmc_get_device_id(NULL, bmc, &id, NULL, NULL);\n\tif (rv)\n\t\treturn rv;\n\n\treturn sysfs_emit(buf, \"%u\\n\", (id.device_revision & 0x80) >> 7);\n}\nstatic DEVICE_ATTR_RO(provides_device_sdrs);\n\nstatic ssize_t revision_show(struct device *dev, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct bmc_device *bmc = to_bmc_device(dev);\n\tstruct ipmi_device_id id;\n\tint rv;\n\n\trv = bmc_get_device_id(NULL, bmc, &id, NULL, NULL);\n\tif (rv)\n\t\treturn rv;\n\n\treturn sysfs_emit(buf, \"%u\\n\", id.device_revision & 0x0F);\n}\nstatic DEVICE_ATTR_RO(revision);\n\nstatic ssize_t firmware_revision_show(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      char *buf)\n{\n\tstruct bmc_device *bmc = to_bmc_device(dev);\n\tstruct ipmi_device_id id;\n\tint rv;\n\n\trv = bmc_get_device_id(NULL, bmc, &id, NULL, NULL);\n\tif (rv)\n\t\treturn rv;\n\n\treturn sysfs_emit(buf, \"%u.%x\\n\", id.firmware_revision_1,\n\t\t\tid.firmware_revision_2);\n}\nstatic DEVICE_ATTR_RO(firmware_revision);\n\nstatic ssize_t ipmi_version_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t char *buf)\n{\n\tstruct bmc_device *bmc = to_bmc_device(dev);\n\tstruct ipmi_device_id id;\n\tint rv;\n\n\trv = bmc_get_device_id(NULL, bmc, &id, NULL, NULL);\n\tif (rv)\n\t\treturn rv;\n\n\treturn sysfs_emit(buf, \"%u.%u\\n\",\n\t\t\tipmi_version_major(&id),\n\t\t\tipmi_version_minor(&id));\n}\nstatic DEVICE_ATTR_RO(ipmi_version);\n\nstatic ssize_t add_dev_support_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    char *buf)\n{\n\tstruct bmc_device *bmc = to_bmc_device(dev);\n\tstruct ipmi_device_id id;\n\tint rv;\n\n\trv = bmc_get_device_id(NULL, bmc, &id, NULL, NULL);\n\tif (rv)\n\t\treturn rv;\n\n\treturn sysfs_emit(buf, \"0x%02x\\n\", id.additional_device_support);\n}\nstatic DEVICE_ATTR(additional_device_support, S_IRUGO, add_dev_support_show,\n\t\t   NULL);\n\nstatic ssize_t manufacturer_id_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    char *buf)\n{\n\tstruct bmc_device *bmc = to_bmc_device(dev);\n\tstruct ipmi_device_id id;\n\tint rv;\n\n\trv = bmc_get_device_id(NULL, bmc, &id, NULL, NULL);\n\tif (rv)\n\t\treturn rv;\n\n\treturn sysfs_emit(buf, \"0x%6.6x\\n\", id.manufacturer_id);\n}\nstatic DEVICE_ATTR_RO(manufacturer_id);\n\nstatic ssize_t product_id_show(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       char *buf)\n{\n\tstruct bmc_device *bmc = to_bmc_device(dev);\n\tstruct ipmi_device_id id;\n\tint rv;\n\n\trv = bmc_get_device_id(NULL, bmc, &id, NULL, NULL);\n\tif (rv)\n\t\treturn rv;\n\n\treturn sysfs_emit(buf, \"0x%4.4x\\n\", id.product_id);\n}\nstatic DEVICE_ATTR_RO(product_id);\n\nstatic ssize_t aux_firmware_rev_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     char *buf)\n{\n\tstruct bmc_device *bmc = to_bmc_device(dev);\n\tstruct ipmi_device_id id;\n\tint rv;\n\n\trv = bmc_get_device_id(NULL, bmc, &id, NULL, NULL);\n\tif (rv)\n\t\treturn rv;\n\n\treturn sysfs_emit(buf, \"0x%02x 0x%02x 0x%02x 0x%02x\\n\",\n\t\t\tid.aux_firmware_revision[3],\n\t\t\tid.aux_firmware_revision[2],\n\t\t\tid.aux_firmware_revision[1],\n\t\t\tid.aux_firmware_revision[0]);\n}\nstatic DEVICE_ATTR(aux_firmware_revision, S_IRUGO, aux_firmware_rev_show, NULL);\n\nstatic ssize_t guid_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct bmc_device *bmc = to_bmc_device(dev);\n\tbool guid_set;\n\tguid_t guid;\n\tint rv;\n\n\trv = bmc_get_device_id(NULL, bmc, NULL, &guid_set, &guid);\n\tif (rv)\n\t\treturn rv;\n\tif (!guid_set)\n\t\treturn -ENOENT;\n\n\treturn sysfs_emit(buf, \"%pUl\\n\", &guid);\n}\nstatic DEVICE_ATTR_RO(guid);\n\nstatic struct attribute *bmc_dev_attrs[] = {\n\t&dev_attr_device_id.attr,\n\t&dev_attr_provides_device_sdrs.attr,\n\t&dev_attr_revision.attr,\n\t&dev_attr_firmware_revision.attr,\n\t&dev_attr_ipmi_version.attr,\n\t&dev_attr_additional_device_support.attr,\n\t&dev_attr_manufacturer_id.attr,\n\t&dev_attr_product_id.attr,\n\t&dev_attr_aux_firmware_revision.attr,\n\t&dev_attr_guid.attr,\n\tNULL\n};\n\nstatic umode_t bmc_dev_attr_is_visible(struct kobject *kobj,\n\t\t\t\t       struct attribute *attr, int idx)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct bmc_device *bmc = to_bmc_device(dev);\n\tumode_t mode = attr->mode;\n\tint rv;\n\n\tif (attr == &dev_attr_aux_firmware_revision.attr) {\n\t\tstruct ipmi_device_id id;\n\n\t\trv = bmc_get_device_id(NULL, bmc, &id, NULL, NULL);\n\t\treturn (!rv && id.aux_firmware_revision_set) ? mode : 0;\n\t}\n\tif (attr == &dev_attr_guid.attr) {\n\t\tbool guid_set;\n\n\t\trv = bmc_get_device_id(NULL, bmc, NULL, &guid_set, NULL);\n\t\treturn (!rv && guid_set) ? mode : 0;\n\t}\n\treturn mode;\n}\n\nstatic const struct attribute_group bmc_dev_attr_group = {\n\t.attrs\t\t= bmc_dev_attrs,\n\t.is_visible\t= bmc_dev_attr_is_visible,\n};\n\nstatic const struct attribute_group *bmc_dev_attr_groups[] = {\n\t&bmc_dev_attr_group,\n\tNULL\n};\n\nstatic const struct device_type bmc_device_type = {\n\t.groups\t\t= bmc_dev_attr_groups,\n};\n\nstatic int __find_bmc_guid(struct device *dev, const void *data)\n{\n\tconst guid_t *guid = data;\n\tstruct bmc_device *bmc;\n\tint rv;\n\n\tif (dev->type != &bmc_device_type)\n\t\treturn 0;\n\n\tbmc = to_bmc_device(dev);\n\trv = bmc->dyn_guid_set && guid_equal(&bmc->guid, guid);\n\tif (rv)\n\t\trv = kref_get_unless_zero(&bmc->usecount);\n\treturn rv;\n}\n\n \nstatic struct bmc_device *ipmi_find_bmc_guid(struct device_driver *drv,\n\t\t\t\t\t     guid_t *guid)\n{\n\tstruct device *dev;\n\tstruct bmc_device *bmc = NULL;\n\n\tdev = driver_find_device(drv, NULL, guid, __find_bmc_guid);\n\tif (dev) {\n\t\tbmc = to_bmc_device(dev);\n\t\tput_device(dev);\n\t}\n\treturn bmc;\n}\n\nstruct prod_dev_id {\n\tunsigned int  product_id;\n\tunsigned char device_id;\n};\n\nstatic int __find_bmc_prod_dev_id(struct device *dev, const void *data)\n{\n\tconst struct prod_dev_id *cid = data;\n\tstruct bmc_device *bmc;\n\tint rv;\n\n\tif (dev->type != &bmc_device_type)\n\t\treturn 0;\n\n\tbmc = to_bmc_device(dev);\n\trv = (bmc->id.product_id == cid->product_id\n\t      && bmc->id.device_id == cid->device_id);\n\tif (rv)\n\t\trv = kref_get_unless_zero(&bmc->usecount);\n\treturn rv;\n}\n\n \nstatic struct bmc_device *ipmi_find_bmc_prod_dev_id(\n\tstruct device_driver *drv,\n\tunsigned int product_id, unsigned char device_id)\n{\n\tstruct prod_dev_id id = {\n\t\t.product_id = product_id,\n\t\t.device_id = device_id,\n\t};\n\tstruct device *dev;\n\tstruct bmc_device *bmc = NULL;\n\n\tdev = driver_find_device(drv, NULL, &id, __find_bmc_prod_dev_id);\n\tif (dev) {\n\t\tbmc = to_bmc_device(dev);\n\t\tput_device(dev);\n\t}\n\treturn bmc;\n}\n\nstatic DEFINE_IDA(ipmi_bmc_ida);\n\nstatic void\nrelease_bmc_device(struct device *dev)\n{\n\tkfree(to_bmc_device(dev));\n}\n\nstatic void cleanup_bmc_work(struct work_struct *work)\n{\n\tstruct bmc_device *bmc = container_of(work, struct bmc_device,\n\t\t\t\t\t      remove_work);\n\tint id = bmc->pdev.id;  \n\n\tplatform_device_unregister(&bmc->pdev);\n\tida_simple_remove(&ipmi_bmc_ida, id);\n}\n\nstatic void\ncleanup_bmc_device(struct kref *ref)\n{\n\tstruct bmc_device *bmc = container_of(ref, struct bmc_device, usecount);\n\n\t \n\tqueue_work(remove_work_wq, &bmc->remove_work);\n}\n\n \nstatic void __ipmi_bmc_unregister(struct ipmi_smi *intf)\n{\n\tstruct bmc_device *bmc = intf->bmc;\n\n\tif (!intf->bmc_registered)\n\t\treturn;\n\n\tsysfs_remove_link(&intf->si_dev->kobj, \"bmc\");\n\tsysfs_remove_link(&bmc->pdev.dev.kobj, intf->my_dev_name);\n\tkfree(intf->my_dev_name);\n\tintf->my_dev_name = NULL;\n\n\tmutex_lock(&bmc->dyn_mutex);\n\tlist_del(&intf->bmc_link);\n\tmutex_unlock(&bmc->dyn_mutex);\n\tintf->bmc = &intf->tmp_bmc;\n\tkref_put(&bmc->usecount, cleanup_bmc_device);\n\tintf->bmc_registered = false;\n}\n\nstatic void ipmi_bmc_unregister(struct ipmi_smi *intf)\n{\n\tmutex_lock(&intf->bmc_reg_mutex);\n\t__ipmi_bmc_unregister(intf);\n\tmutex_unlock(&intf->bmc_reg_mutex);\n}\n\n \nstatic int __ipmi_bmc_register(struct ipmi_smi *intf,\n\t\t\t       struct ipmi_device_id *id,\n\t\t\t       bool guid_set, guid_t *guid, int intf_num)\n{\n\tint               rv;\n\tstruct bmc_device *bmc;\n\tstruct bmc_device *old_bmc;\n\n\t \n\tintf->in_bmc_register = true;\n\tmutex_unlock(&intf->bmc_reg_mutex);\n\n\t \n\tmutex_lock(&ipmidriver_mutex);\n\tif (guid_set)\n\t\told_bmc = ipmi_find_bmc_guid(&ipmidriver.driver, guid);\n\telse\n\t\told_bmc = ipmi_find_bmc_prod_dev_id(&ipmidriver.driver,\n\t\t\t\t\t\t    id->product_id,\n\t\t\t\t\t\t    id->device_id);\n\n\t \n\tif (old_bmc) {\n\t\tbmc = old_bmc;\n\t\t \n\t\tintf->bmc = old_bmc;\n\t\tmutex_lock(&bmc->dyn_mutex);\n\t\tlist_add_tail(&intf->bmc_link, &bmc->intfs);\n\t\tmutex_unlock(&bmc->dyn_mutex);\n\n\t\tdev_info(intf->si_dev,\n\t\t\t \"interfacing existing BMC (man_id: 0x%6.6x, prod_id: 0x%4.4x, dev_id: 0x%2.2x)\\n\",\n\t\t\t bmc->id.manufacturer_id,\n\t\t\t bmc->id.product_id,\n\t\t\t bmc->id.device_id);\n\t} else {\n\t\tbmc = kzalloc(sizeof(*bmc), GFP_KERNEL);\n\t\tif (!bmc) {\n\t\t\trv = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tINIT_LIST_HEAD(&bmc->intfs);\n\t\tmutex_init(&bmc->dyn_mutex);\n\t\tINIT_WORK(&bmc->remove_work, cleanup_bmc_work);\n\n\t\tbmc->id = *id;\n\t\tbmc->dyn_id_set = 1;\n\t\tbmc->dyn_guid_set = guid_set;\n\t\tbmc->guid = *guid;\n\t\tbmc->dyn_id_expiry = jiffies + IPMI_DYN_DEV_ID_EXPIRY;\n\n\t\tbmc->pdev.name = \"ipmi_bmc\";\n\n\t\trv = ida_simple_get(&ipmi_bmc_ida, 0, 0, GFP_KERNEL);\n\t\tif (rv < 0) {\n\t\t\tkfree(bmc);\n\t\t\tgoto out;\n\t\t}\n\n\t\tbmc->pdev.dev.driver = &ipmidriver.driver;\n\t\tbmc->pdev.id = rv;\n\t\tbmc->pdev.dev.release = release_bmc_device;\n\t\tbmc->pdev.dev.type = &bmc_device_type;\n\t\tkref_init(&bmc->usecount);\n\n\t\tintf->bmc = bmc;\n\t\tmutex_lock(&bmc->dyn_mutex);\n\t\tlist_add_tail(&intf->bmc_link, &bmc->intfs);\n\t\tmutex_unlock(&bmc->dyn_mutex);\n\n\t\trv = platform_device_register(&bmc->pdev);\n\t\tif (rv) {\n\t\t\tdev_err(intf->si_dev,\n\t\t\t\t\"Unable to register bmc device: %d\\n\",\n\t\t\t\trv);\n\t\t\tgoto out_list_del;\n\t\t}\n\n\t\tdev_info(intf->si_dev,\n\t\t\t \"Found new BMC (man_id: 0x%6.6x, prod_id: 0x%4.4x, dev_id: 0x%2.2x)\\n\",\n\t\t\t bmc->id.manufacturer_id,\n\t\t\t bmc->id.product_id,\n\t\t\t bmc->id.device_id);\n\t}\n\n\t \n\trv = sysfs_create_link(&intf->si_dev->kobj, &bmc->pdev.dev.kobj, \"bmc\");\n\tif (rv) {\n\t\tdev_err(intf->si_dev, \"Unable to create bmc symlink: %d\\n\", rv);\n\t\tgoto out_put_bmc;\n\t}\n\n\tif (intf_num == -1)\n\t\tintf_num = intf->intf_num;\n\tintf->my_dev_name = kasprintf(GFP_KERNEL, \"ipmi%d\", intf_num);\n\tif (!intf->my_dev_name) {\n\t\trv = -ENOMEM;\n\t\tdev_err(intf->si_dev, \"Unable to allocate link from BMC: %d\\n\",\n\t\t\trv);\n\t\tgoto out_unlink1;\n\t}\n\n\trv = sysfs_create_link(&bmc->pdev.dev.kobj, &intf->si_dev->kobj,\n\t\t\t       intf->my_dev_name);\n\tif (rv) {\n\t\tdev_err(intf->si_dev, \"Unable to create symlink to bmc: %d\\n\",\n\t\t\trv);\n\t\tgoto out_free_my_dev_name;\n\t}\n\n\tintf->bmc_registered = true;\n\nout:\n\tmutex_unlock(&ipmidriver_mutex);\n\tmutex_lock(&intf->bmc_reg_mutex);\n\tintf->in_bmc_register = false;\n\treturn rv;\n\n\nout_free_my_dev_name:\n\tkfree(intf->my_dev_name);\n\tintf->my_dev_name = NULL;\n\nout_unlink1:\n\tsysfs_remove_link(&intf->si_dev->kobj, \"bmc\");\n\nout_put_bmc:\n\tmutex_lock(&bmc->dyn_mutex);\n\tlist_del(&intf->bmc_link);\n\tmutex_unlock(&bmc->dyn_mutex);\n\tintf->bmc = &intf->tmp_bmc;\n\tkref_put(&bmc->usecount, cleanup_bmc_device);\n\tgoto out;\n\nout_list_del:\n\tmutex_lock(&bmc->dyn_mutex);\n\tlist_del(&intf->bmc_link);\n\tmutex_unlock(&bmc->dyn_mutex);\n\tintf->bmc = &intf->tmp_bmc;\n\tput_device(&bmc->pdev.dev);\n\tgoto out;\n}\n\nstatic int\nsend_guid_cmd(struct ipmi_smi *intf, int chan)\n{\n\tstruct kernel_ipmi_msg            msg;\n\tstruct ipmi_system_interface_addr si;\n\n\tsi.addr_type = IPMI_SYSTEM_INTERFACE_ADDR_TYPE;\n\tsi.channel = IPMI_BMC_CHANNEL;\n\tsi.lun = 0;\n\n\tmsg.netfn = IPMI_NETFN_APP_REQUEST;\n\tmsg.cmd = IPMI_GET_DEVICE_GUID_CMD;\n\tmsg.data = NULL;\n\tmsg.data_len = 0;\n\treturn i_ipmi_request(NULL,\n\t\t\t      intf,\n\t\t\t      (struct ipmi_addr *) &si,\n\t\t\t      0,\n\t\t\t      &msg,\n\t\t\t      intf,\n\t\t\t      NULL,\n\t\t\t      NULL,\n\t\t\t      0,\n\t\t\t      intf->addrinfo[0].address,\n\t\t\t      intf->addrinfo[0].lun,\n\t\t\t      -1, 0);\n}\n\nstatic void guid_handler(struct ipmi_smi *intf, struct ipmi_recv_msg *msg)\n{\n\tstruct bmc_device *bmc = intf->bmc;\n\n\tif ((msg->addr.addr_type != IPMI_SYSTEM_INTERFACE_ADDR_TYPE)\n\t    || (msg->msg.netfn != IPMI_NETFN_APP_RESPONSE)\n\t    || (msg->msg.cmd != IPMI_GET_DEVICE_GUID_CMD))\n\t\t \n\t\treturn;\n\n\tif (msg->msg.data[0] != 0) {\n\t\t \n\t\tbmc->dyn_guid_set = 0;\n\t\tgoto out;\n\t}\n\n\tif (msg->msg.data_len < UUID_SIZE + 1) {\n\t\tbmc->dyn_guid_set = 0;\n\t\tdev_warn(intf->si_dev,\n\t\t\t \"The GUID response from the BMC was too short, it was %d but should have been %d.  Assuming GUID is not available.\\n\",\n\t\t\t msg->msg.data_len, UUID_SIZE + 1);\n\t\tgoto out;\n\t}\n\n\timport_guid(&bmc->fetch_guid, msg->msg.data + 1);\n\t \n\tsmp_wmb();\n\tbmc->dyn_guid_set = 1;\n out:\n\twake_up(&intf->waitq);\n}\n\nstatic void __get_guid(struct ipmi_smi *intf)\n{\n\tint rv;\n\tstruct bmc_device *bmc = intf->bmc;\n\n\tbmc->dyn_guid_set = 2;\n\tintf->null_user_handler = guid_handler;\n\trv = send_guid_cmd(intf, 0);\n\tif (rv)\n\t\t \n\t\tbmc->dyn_guid_set = 0;\n\telse\n\t\twait_event(intf->waitq, bmc->dyn_guid_set != 2);\n\n\t \n\tsmp_rmb();\n\n\tintf->null_user_handler = NULL;\n}\n\nstatic int\nsend_channel_info_cmd(struct ipmi_smi *intf, int chan)\n{\n\tstruct kernel_ipmi_msg            msg;\n\tunsigned char                     data[1];\n\tstruct ipmi_system_interface_addr si;\n\n\tsi.addr_type = IPMI_SYSTEM_INTERFACE_ADDR_TYPE;\n\tsi.channel = IPMI_BMC_CHANNEL;\n\tsi.lun = 0;\n\n\tmsg.netfn = IPMI_NETFN_APP_REQUEST;\n\tmsg.cmd = IPMI_GET_CHANNEL_INFO_CMD;\n\tmsg.data = data;\n\tmsg.data_len = 1;\n\tdata[0] = chan;\n\treturn i_ipmi_request(NULL,\n\t\t\t      intf,\n\t\t\t      (struct ipmi_addr *) &si,\n\t\t\t      0,\n\t\t\t      &msg,\n\t\t\t      intf,\n\t\t\t      NULL,\n\t\t\t      NULL,\n\t\t\t      0,\n\t\t\t      intf->addrinfo[0].address,\n\t\t\t      intf->addrinfo[0].lun,\n\t\t\t      -1, 0);\n}\n\nstatic void\nchannel_handler(struct ipmi_smi *intf, struct ipmi_recv_msg *msg)\n{\n\tint rv = 0;\n\tint ch;\n\tunsigned int set = intf->curr_working_cset;\n\tstruct ipmi_channel *chans;\n\n\tif ((msg->addr.addr_type == IPMI_SYSTEM_INTERFACE_ADDR_TYPE)\n\t    && (msg->msg.netfn == IPMI_NETFN_APP_RESPONSE)\n\t    && (msg->msg.cmd == IPMI_GET_CHANNEL_INFO_CMD)) {\n\t\t \n\t\tif (msg->msg.data[0] != 0) {\n\t\t\t \n\t\t\tif (msg->msg.data[0] == IPMI_INVALID_COMMAND_ERR) {\n\t\t\t\t \n\t\t\t\tintf->wchannels[set].c[0].medium\n\t\t\t\t\t= IPMI_CHANNEL_MEDIUM_IPMB;\n\t\t\t\tintf->wchannels[set].c[0].protocol\n\t\t\t\t\t= IPMI_CHANNEL_PROTOCOL_IPMB;\n\n\t\t\t\tintf->channel_list = intf->wchannels + set;\n\t\t\t\tintf->channels_ready = true;\n\t\t\t\twake_up(&intf->waitq);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tgoto next_channel;\n\t\t}\n\t\tif (msg->msg.data_len < 4) {\n\t\t\t \n\t\t\tgoto next_channel;\n\t\t}\n\t\tch = intf->curr_channel;\n\t\tchans = intf->wchannels[set].c;\n\t\tchans[ch].medium = msg->msg.data[2] & 0x7f;\n\t\tchans[ch].protocol = msg->msg.data[3] & 0x1f;\n\n next_channel:\n\t\tintf->curr_channel++;\n\t\tif (intf->curr_channel >= IPMI_MAX_CHANNELS) {\n\t\t\tintf->channel_list = intf->wchannels + set;\n\t\t\tintf->channels_ready = true;\n\t\t\twake_up(&intf->waitq);\n\t\t} else {\n\t\t\tintf->channel_list = intf->wchannels + set;\n\t\t\tintf->channels_ready = true;\n\t\t\trv = send_channel_info_cmd(intf, intf->curr_channel);\n\t\t}\n\n\t\tif (rv) {\n\t\t\t \n\t\t\tdev_warn(intf->si_dev,\n\t\t\t\t \"Error sending channel information for channel %d: %d\\n\",\n\t\t\t\t intf->curr_channel, rv);\n\n\t\t\tintf->channel_list = intf->wchannels + set;\n\t\t\tintf->channels_ready = true;\n\t\t\twake_up(&intf->waitq);\n\t\t}\n\t}\n out:\n\treturn;\n}\n\n \nstatic int __scan_channels(struct ipmi_smi *intf, struct ipmi_device_id *id)\n{\n\tint rv;\n\n\tif (ipmi_version_major(id) > 1\n\t\t\t|| (ipmi_version_major(id) == 1\n\t\t\t    && ipmi_version_minor(id) >= 5)) {\n\t\tunsigned int set;\n\n\t\t \n\t\tset = !intf->curr_working_cset;\n\t\tintf->curr_working_cset = set;\n\t\tmemset(&intf->wchannels[set], 0,\n\t\t       sizeof(struct ipmi_channel_set));\n\n\t\tintf->null_user_handler = channel_handler;\n\t\tintf->curr_channel = 0;\n\t\trv = send_channel_info_cmd(intf, 0);\n\t\tif (rv) {\n\t\t\tdev_warn(intf->si_dev,\n\t\t\t\t \"Error sending channel information for channel 0, %d\\n\",\n\t\t\t\t rv);\n\t\t\tintf->null_user_handler = NULL;\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t \n\t\twait_event(intf->waitq, intf->channels_ready);\n\t\tintf->null_user_handler = NULL;\n\t} else {\n\t\tunsigned int set = intf->curr_working_cset;\n\n\t\t \n\t\tintf->wchannels[set].c[0].medium = IPMI_CHANNEL_MEDIUM_IPMB;\n\t\tintf->wchannels[set].c[0].protocol = IPMI_CHANNEL_PROTOCOL_IPMB;\n\t\tintf->channel_list = intf->wchannels + set;\n\t\tintf->channels_ready = true;\n\t}\n\n\treturn 0;\n}\n\nstatic void ipmi_poll(struct ipmi_smi *intf)\n{\n\tif (intf->handlers->poll)\n\t\tintf->handlers->poll(intf->send_info);\n\t \n\thandle_new_recv_msgs(intf);\n}\n\nvoid ipmi_poll_interface(struct ipmi_user *user)\n{\n\tipmi_poll(user->intf);\n}\nEXPORT_SYMBOL(ipmi_poll_interface);\n\nstatic ssize_t nr_users_show(struct device *dev,\n\t\t\t     struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct ipmi_smi *intf = container_of(attr,\n\t\t\t struct ipmi_smi, nr_users_devattr);\n\n\treturn sysfs_emit(buf, \"%d\\n\", atomic_read(&intf->nr_users));\n}\nstatic DEVICE_ATTR_RO(nr_users);\n\nstatic ssize_t nr_msgs_show(struct device *dev,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct ipmi_smi *intf = container_of(attr,\n\t\t\t struct ipmi_smi, nr_msgs_devattr);\n\tstruct ipmi_user *user;\n\tint index;\n\tunsigned int count = 0;\n\n\tindex = srcu_read_lock(&intf->users_srcu);\n\tlist_for_each_entry_rcu(user, &intf->users, link)\n\t\tcount += atomic_read(&user->nr_msgs);\n\tsrcu_read_unlock(&intf->users_srcu, index);\n\n\treturn sysfs_emit(buf, \"%u\\n\", count);\n}\nstatic DEVICE_ATTR_RO(nr_msgs);\n\nstatic void redo_bmc_reg(struct work_struct *work)\n{\n\tstruct ipmi_smi *intf = container_of(work, struct ipmi_smi,\n\t\t\t\t\t     bmc_reg_work);\n\n\tif (!intf->in_shutdown)\n\t\tbmc_get_device_id(intf, NULL, NULL, NULL, NULL);\n\n\tkref_put(&intf->refcount, intf_free);\n}\n\nint ipmi_add_smi(struct module         *owner,\n\t\t const struct ipmi_smi_handlers *handlers,\n\t\t void\t\t       *send_info,\n\t\t struct device         *si_dev,\n\t\t unsigned char         slave_addr)\n{\n\tint              i, j;\n\tint              rv;\n\tstruct ipmi_smi *intf, *tintf;\n\tstruct list_head *link;\n\tstruct ipmi_device_id id;\n\n\t \n\trv = ipmi_init_msghandler();\n\tif (rv)\n\t\treturn rv;\n\n\tintf = kzalloc(sizeof(*intf), GFP_KERNEL);\n\tif (!intf)\n\t\treturn -ENOMEM;\n\n\trv = init_srcu_struct(&intf->users_srcu);\n\tif (rv) {\n\t\tkfree(intf);\n\t\treturn rv;\n\t}\n\n\tintf->owner = owner;\n\tintf->bmc = &intf->tmp_bmc;\n\tINIT_LIST_HEAD(&intf->bmc->intfs);\n\tmutex_init(&intf->bmc->dyn_mutex);\n\tINIT_LIST_HEAD(&intf->bmc_link);\n\tmutex_init(&intf->bmc_reg_mutex);\n\tintf->intf_num = -1;  \n\tkref_init(&intf->refcount);\n\tINIT_WORK(&intf->bmc_reg_work, redo_bmc_reg);\n\tintf->si_dev = si_dev;\n\tfor (j = 0; j < IPMI_MAX_CHANNELS; j++) {\n\t\tintf->addrinfo[j].address = IPMI_BMC_SLAVE_ADDR;\n\t\tintf->addrinfo[j].lun = 2;\n\t}\n\tif (slave_addr != 0)\n\t\tintf->addrinfo[0].address = slave_addr;\n\tINIT_LIST_HEAD(&intf->users);\n\tatomic_set(&intf->nr_users, 0);\n\tintf->handlers = handlers;\n\tintf->send_info = send_info;\n\tspin_lock_init(&intf->seq_lock);\n\tfor (j = 0; j < IPMI_IPMB_NUM_SEQ; j++) {\n\t\tintf->seq_table[j].inuse = 0;\n\t\tintf->seq_table[j].seqid = 0;\n\t}\n\tintf->curr_seq = 0;\n\tspin_lock_init(&intf->waiting_rcv_msgs_lock);\n\tINIT_LIST_HEAD(&intf->waiting_rcv_msgs);\n\ttasklet_setup(&intf->recv_tasklet,\n\t\t     smi_recv_tasklet);\n\tatomic_set(&intf->watchdog_pretimeouts_to_deliver, 0);\n\tspin_lock_init(&intf->xmit_msgs_lock);\n\tINIT_LIST_HEAD(&intf->xmit_msgs);\n\tINIT_LIST_HEAD(&intf->hp_xmit_msgs);\n\tspin_lock_init(&intf->events_lock);\n\tspin_lock_init(&intf->watch_lock);\n\tatomic_set(&intf->event_waiters, 0);\n\tintf->ticks_to_req_ev = IPMI_REQUEST_EV_TIME;\n\tINIT_LIST_HEAD(&intf->waiting_events);\n\tintf->waiting_events_count = 0;\n\tmutex_init(&intf->cmd_rcvrs_mutex);\n\tspin_lock_init(&intf->maintenance_mode_lock);\n\tINIT_LIST_HEAD(&intf->cmd_rcvrs);\n\tinit_waitqueue_head(&intf->waitq);\n\tfor (i = 0; i < IPMI_NUM_STATS; i++)\n\t\tatomic_set(&intf->stats[i], 0);\n\n\tmutex_lock(&ipmi_interfaces_mutex);\n\t \n\ti = 0;\n\tlink = &ipmi_interfaces;\n\tlist_for_each_entry_rcu(tintf, &ipmi_interfaces, link,\n\t\t\t\tipmi_interfaces_mutex_held()) {\n\t\tif (tintf->intf_num != i) {\n\t\t\tlink = &tintf->link;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\t \n\tif (i == 0)\n\t\tlist_add_rcu(&intf->link, &ipmi_interfaces);\n\telse\n\t\tlist_add_tail_rcu(&intf->link, link);\n\n\trv = handlers->start_processing(send_info, intf);\n\tif (rv)\n\t\tgoto out_err;\n\n\trv = __bmc_get_device_id(intf, NULL, &id, NULL, NULL, i);\n\tif (rv) {\n\t\tdev_err(si_dev, \"Unable to get the device id: %d\\n\", rv);\n\t\tgoto out_err_started;\n\t}\n\n\tmutex_lock(&intf->bmc_reg_mutex);\n\trv = __scan_channels(intf, &id);\n\tmutex_unlock(&intf->bmc_reg_mutex);\n\tif (rv)\n\t\tgoto out_err_bmc_reg;\n\n\tintf->nr_users_devattr = dev_attr_nr_users;\n\tsysfs_attr_init(&intf->nr_users_devattr.attr);\n\trv = device_create_file(intf->si_dev, &intf->nr_users_devattr);\n\tif (rv)\n\t\tgoto out_err_bmc_reg;\n\n\tintf->nr_msgs_devattr = dev_attr_nr_msgs;\n\tsysfs_attr_init(&intf->nr_msgs_devattr.attr);\n\trv = device_create_file(intf->si_dev, &intf->nr_msgs_devattr);\n\tif (rv) {\n\t\tdevice_remove_file(intf->si_dev, &intf->nr_users_devattr);\n\t\tgoto out_err_bmc_reg;\n\t}\n\n\t \n\tsmp_wmb();\n\tintf->intf_num = i;\n\tmutex_unlock(&ipmi_interfaces_mutex);\n\n\t \n\tcall_smi_watchers(i, intf->si_dev);\n\n\treturn 0;\n\n out_err_bmc_reg:\n\tipmi_bmc_unregister(intf);\n out_err_started:\n\tif (intf->handlers->shutdown)\n\t\tintf->handlers->shutdown(intf->send_info);\n out_err:\n\tlist_del_rcu(&intf->link);\n\tmutex_unlock(&ipmi_interfaces_mutex);\n\tsynchronize_srcu(&ipmi_interfaces_srcu);\n\tcleanup_srcu_struct(&intf->users_srcu);\n\tkref_put(&intf->refcount, intf_free);\n\n\treturn rv;\n}\nEXPORT_SYMBOL(ipmi_add_smi);\n\nstatic void deliver_smi_err_response(struct ipmi_smi *intf,\n\t\t\t\t     struct ipmi_smi_msg *msg,\n\t\t\t\t     unsigned char err)\n{\n\tint rv;\n\tmsg->rsp[0] = msg->data[0] | 4;\n\tmsg->rsp[1] = msg->data[1];\n\tmsg->rsp[2] = err;\n\tmsg->rsp_size = 3;\n\n\t \n\trv = handle_one_recv_msg(intf, msg);\n\tif (rv == 0)\n\t\tipmi_free_smi_msg(msg);\n}\n\nstatic void cleanup_smi_msgs(struct ipmi_smi *intf)\n{\n\tint              i;\n\tstruct seq_table *ent;\n\tstruct ipmi_smi_msg *msg;\n\tstruct list_head *entry;\n\tstruct list_head tmplist;\n\n\t \n\tINIT_LIST_HEAD(&tmplist);\n\tlist_splice_tail(&intf->hp_xmit_msgs, &tmplist);\n\tlist_splice_tail(&intf->xmit_msgs, &tmplist);\n\n\t \n\twhile (intf->curr_msg && !list_empty(&intf->waiting_rcv_msgs)) {\n\t\t \n\t\tschedule_timeout(1);\n\t}\n\n\t \n\n\t \n\twhile (!list_empty(&tmplist)) {\n\t\tentry = tmplist.next;\n\t\tlist_del(entry);\n\t\tmsg = list_entry(entry, struct ipmi_smi_msg, link);\n\t\tdeliver_smi_err_response(intf, msg, IPMI_ERR_UNSPECIFIED);\n\t}\n\n\tfor (i = 0; i < IPMI_IPMB_NUM_SEQ; i++) {\n\t\tent = &intf->seq_table[i];\n\t\tif (!ent->inuse)\n\t\t\tcontinue;\n\t\tdeliver_err_response(intf, ent->recv_msg, IPMI_ERR_UNSPECIFIED);\n\t}\n}\n\nvoid ipmi_unregister_smi(struct ipmi_smi *intf)\n{\n\tstruct ipmi_smi_watcher *w;\n\tint intf_num, index;\n\n\tif (!intf)\n\t\treturn;\n\tintf_num = intf->intf_num;\n\tmutex_lock(&ipmi_interfaces_mutex);\n\tintf->intf_num = -1;\n\tintf->in_shutdown = true;\n\tlist_del_rcu(&intf->link);\n\tmutex_unlock(&ipmi_interfaces_mutex);\n\tsynchronize_srcu(&ipmi_interfaces_srcu);\n\n\t \n\n\tdevice_remove_file(intf->si_dev, &intf->nr_msgs_devattr);\n\tdevice_remove_file(intf->si_dev, &intf->nr_users_devattr);\n\n\t \n\tmutex_lock(&smi_watchers_mutex);\n\tlist_for_each_entry(w, &smi_watchers, link)\n\t\tw->smi_gone(intf_num);\n\tmutex_unlock(&smi_watchers_mutex);\n\n\tindex = srcu_read_lock(&intf->users_srcu);\n\twhile (!list_empty(&intf->users)) {\n\t\tstruct ipmi_user *user =\n\t\t\tcontainer_of(list_next_rcu(&intf->users),\n\t\t\t\t     struct ipmi_user, link);\n\n\t\t_ipmi_destroy_user(user);\n\t}\n\tsrcu_read_unlock(&intf->users_srcu, index);\n\n\tif (intf->handlers->shutdown)\n\t\tintf->handlers->shutdown(intf->send_info);\n\n\tcleanup_smi_msgs(intf);\n\n\tipmi_bmc_unregister(intf);\n\n\tcleanup_srcu_struct(&intf->users_srcu);\n\tkref_put(&intf->refcount, intf_free);\n}\nEXPORT_SYMBOL(ipmi_unregister_smi);\n\nstatic int handle_ipmb_get_msg_rsp(struct ipmi_smi *intf,\n\t\t\t\t   struct ipmi_smi_msg *msg)\n{\n\tstruct ipmi_ipmb_addr ipmb_addr;\n\tstruct ipmi_recv_msg  *recv_msg;\n\n\t \n\tif (msg->rsp_size < 11) {\n\t\t \n\t\tipmi_inc_stat(intf, invalid_ipmb_responses);\n\t\treturn 0;\n\t}\n\n\tif (msg->rsp[2] != 0) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tipmb_addr.addr_type = IPMI_IPMB_ADDR_TYPE;\n\tipmb_addr.slave_addr = msg->rsp[6];\n\tipmb_addr.channel = msg->rsp[3] & 0x0f;\n\tipmb_addr.lun = msg->rsp[7] & 3;\n\n\t \n\tif (intf_find_seq(intf,\n\t\t\t  msg->rsp[7] >> 2,\n\t\t\t  msg->rsp[3] & 0x0f,\n\t\t\t  msg->rsp[8],\n\t\t\t  (msg->rsp[4] >> 2) & (~1),\n\t\t\t  (struct ipmi_addr *) &ipmb_addr,\n\t\t\t  &recv_msg)) {\n\t\t \n\t\tipmi_inc_stat(intf, unhandled_ipmb_responses);\n\t\treturn 0;\n\t}\n\n\tmemcpy(recv_msg->msg_data, &msg->rsp[9], msg->rsp_size - 9);\n\t \n\trecv_msg->msg.netfn = msg->rsp[4] >> 2;\n\trecv_msg->msg.data = recv_msg->msg_data;\n\trecv_msg->msg.data_len = msg->rsp_size - 10;\n\trecv_msg->recv_type = IPMI_RESPONSE_RECV_TYPE;\n\tif (deliver_response(intf, recv_msg))\n\t\tipmi_inc_stat(intf, unhandled_ipmb_responses);\n\telse\n\t\tipmi_inc_stat(intf, handled_ipmb_responses);\n\n\treturn 0;\n}\n\nstatic int handle_ipmb_get_msg_cmd(struct ipmi_smi *intf,\n\t\t\t\t   struct ipmi_smi_msg *msg)\n{\n\tstruct cmd_rcvr          *rcvr;\n\tint                      rv = 0;\n\tunsigned char            netfn;\n\tunsigned char            cmd;\n\tunsigned char            chan;\n\tstruct ipmi_user         *user = NULL;\n\tstruct ipmi_ipmb_addr    *ipmb_addr;\n\tstruct ipmi_recv_msg     *recv_msg;\n\n\tif (msg->rsp_size < 10) {\n\t\t \n\t\tipmi_inc_stat(intf, invalid_commands);\n\t\treturn 0;\n\t}\n\n\tif (msg->rsp[2] != 0) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tnetfn = msg->rsp[4] >> 2;\n\tcmd = msg->rsp[8];\n\tchan = msg->rsp[3] & 0xf;\n\n\trcu_read_lock();\n\trcvr = find_cmd_rcvr(intf, netfn, cmd, chan);\n\tif (rcvr) {\n\t\tuser = rcvr->user;\n\t\tkref_get(&user->refcount);\n\t} else\n\t\tuser = NULL;\n\trcu_read_unlock();\n\n\tif (user == NULL) {\n\t\t \n\t\tipmi_inc_stat(intf, unhandled_commands);\n\n\t\tmsg->data[0] = (IPMI_NETFN_APP_REQUEST << 2);\n\t\tmsg->data[1] = IPMI_SEND_MSG_CMD;\n\t\tmsg->data[2] = msg->rsp[3];\n\t\tmsg->data[3] = msg->rsp[6];\n\t\tmsg->data[4] = ((netfn + 1) << 2) | (msg->rsp[7] & 0x3);\n\t\tmsg->data[5] = ipmb_checksum(&msg->data[3], 2);\n\t\tmsg->data[6] = intf->addrinfo[msg->rsp[3] & 0xf].address;\n\t\t \n\t\tmsg->data[7] = (msg->rsp[7] & 0xfc) | (msg->rsp[4] & 0x3);\n\t\tmsg->data[8] = msg->rsp[8];  \n\t\tmsg->data[9] = IPMI_INVALID_CMD_COMPLETION_CODE;\n\t\tmsg->data[10] = ipmb_checksum(&msg->data[6], 4);\n\t\tmsg->data_size = 11;\n\n\t\tdev_dbg(intf->si_dev, \"Invalid command: %*ph\\n\",\n\t\t\tmsg->data_size, msg->data);\n\n\t\trcu_read_lock();\n\t\tif (!intf->in_shutdown) {\n\t\t\tsmi_send(intf, intf->handlers, msg, 0);\n\t\t\t \n\t\t\trv = -1;\n\t\t}\n\t\trcu_read_unlock();\n\t} else {\n\t\trecv_msg = ipmi_alloc_recv_msg();\n\t\tif (!recv_msg) {\n\t\t\t \n\t\t\trv = 1;\n\t\t\tkref_put(&user->refcount, free_user);\n\t\t} else {\n\t\t\t \n\t\t\tipmb_addr = (struct ipmi_ipmb_addr *) &recv_msg->addr;\n\t\t\tipmb_addr->addr_type = IPMI_IPMB_ADDR_TYPE;\n\t\t\tipmb_addr->slave_addr = msg->rsp[6];\n\t\t\tipmb_addr->lun = msg->rsp[7] & 3;\n\t\t\tipmb_addr->channel = msg->rsp[3] & 0xf;\n\n\t\t\t \n\t\t\trecv_msg->user = user;\n\t\t\trecv_msg->recv_type = IPMI_CMD_RECV_TYPE;\n\t\t\trecv_msg->msgid = msg->rsp[7] >> 2;\n\t\t\trecv_msg->msg.netfn = msg->rsp[4] >> 2;\n\t\t\trecv_msg->msg.cmd = msg->rsp[8];\n\t\t\trecv_msg->msg.data = recv_msg->msg_data;\n\n\t\t\t \n\t\t\trecv_msg->msg.data_len = msg->rsp_size - 10;\n\t\t\tmemcpy(recv_msg->msg_data, &msg->rsp[9],\n\t\t\t       msg->rsp_size - 10);\n\t\t\tif (deliver_response(intf, recv_msg))\n\t\t\t\tipmi_inc_stat(intf, unhandled_commands);\n\t\t\telse\n\t\t\t\tipmi_inc_stat(intf, handled_commands);\n\t\t}\n\t}\n\n\treturn rv;\n}\n\nstatic int handle_ipmb_direct_rcv_cmd(struct ipmi_smi *intf,\n\t\t\t\t      struct ipmi_smi_msg *msg)\n{\n\tstruct cmd_rcvr          *rcvr;\n\tint                      rv = 0;\n\tstruct ipmi_user         *user = NULL;\n\tstruct ipmi_ipmb_direct_addr *daddr;\n\tstruct ipmi_recv_msg     *recv_msg;\n\tunsigned char netfn = msg->rsp[0] >> 2;\n\tunsigned char cmd = msg->rsp[3];\n\n\trcu_read_lock();\n\t \n\trcvr = find_cmd_rcvr(intf, netfn, cmd, 0);\n\tif (rcvr) {\n\t\tuser = rcvr->user;\n\t\tkref_get(&user->refcount);\n\t} else\n\t\tuser = NULL;\n\trcu_read_unlock();\n\n\tif (user == NULL) {\n\t\t \n\t\tipmi_inc_stat(intf, unhandled_commands);\n\n\t\tmsg->data[0] = (netfn + 1) << 2;\n\t\tmsg->data[0] |= msg->rsp[2] & 0x3;  \n\t\tmsg->data[1] = msg->rsp[1];  \n\t\tmsg->data[2] = msg->rsp[2] & ~0x3;  \n\t\tmsg->data[2] |= msg->rsp[0] & 0x3;  \n\t\tmsg->data[3] = cmd;\n\t\tmsg->data[4] = IPMI_INVALID_CMD_COMPLETION_CODE;\n\t\tmsg->data_size = 5;\n\n\t\trcu_read_lock();\n\t\tif (!intf->in_shutdown) {\n\t\t\tsmi_send(intf, intf->handlers, msg, 0);\n\t\t\t \n\t\t\trv = -1;\n\t\t}\n\t\trcu_read_unlock();\n\t} else {\n\t\trecv_msg = ipmi_alloc_recv_msg();\n\t\tif (!recv_msg) {\n\t\t\t \n\t\t\trv = 1;\n\t\t\tkref_put(&user->refcount, free_user);\n\t\t} else {\n\t\t\t \n\t\t\tdaddr = (struct ipmi_ipmb_direct_addr *)&recv_msg->addr;\n\t\t\tdaddr->addr_type = IPMI_IPMB_DIRECT_ADDR_TYPE;\n\t\t\tdaddr->channel = 0;\n\t\t\tdaddr->slave_addr = msg->rsp[1];\n\t\t\tdaddr->rs_lun = msg->rsp[0] & 3;\n\t\t\tdaddr->rq_lun = msg->rsp[2] & 3;\n\n\t\t\t \n\t\t\trecv_msg->user = user;\n\t\t\trecv_msg->recv_type = IPMI_CMD_RECV_TYPE;\n\t\t\trecv_msg->msgid = (msg->rsp[2] >> 2);\n\t\t\trecv_msg->msg.netfn = msg->rsp[0] >> 2;\n\t\t\trecv_msg->msg.cmd = msg->rsp[3];\n\t\t\trecv_msg->msg.data = recv_msg->msg_data;\n\n\t\t\trecv_msg->msg.data_len = msg->rsp_size - 4;\n\t\t\tmemcpy(recv_msg->msg_data, msg->rsp + 4,\n\t\t\t       msg->rsp_size - 4);\n\t\t\tif (deliver_response(intf, recv_msg))\n\t\t\t\tipmi_inc_stat(intf, unhandled_commands);\n\t\t\telse\n\t\t\t\tipmi_inc_stat(intf, handled_commands);\n\t\t}\n\t}\n\n\treturn rv;\n}\n\nstatic int handle_ipmb_direct_rcv_rsp(struct ipmi_smi *intf,\n\t\t\t\t      struct ipmi_smi_msg *msg)\n{\n\tstruct ipmi_recv_msg *recv_msg;\n\tstruct ipmi_ipmb_direct_addr *daddr;\n\n\trecv_msg = msg->user_data;\n\tif (recv_msg == NULL) {\n\t\tdev_warn(intf->si_dev,\n\t\t\t \"IPMI direct message received with no owner. This could be because of a malformed message, or because of a hardware error.  Contact your hardware vendor for assistance.\\n\");\n\t\treturn 0;\n\t}\n\n\trecv_msg->recv_type = IPMI_RESPONSE_RECV_TYPE;\n\trecv_msg->msgid = msg->msgid;\n\tdaddr = (struct ipmi_ipmb_direct_addr *) &recv_msg->addr;\n\tdaddr->addr_type = IPMI_IPMB_DIRECT_ADDR_TYPE;\n\tdaddr->channel = 0;\n\tdaddr->slave_addr = msg->rsp[1];\n\tdaddr->rq_lun = msg->rsp[0] & 3;\n\tdaddr->rs_lun = msg->rsp[2] & 3;\n\trecv_msg->msg.netfn = msg->rsp[0] >> 2;\n\trecv_msg->msg.cmd = msg->rsp[3];\n\tmemcpy(recv_msg->msg_data, &msg->rsp[4], msg->rsp_size - 4);\n\trecv_msg->msg.data = recv_msg->msg_data;\n\trecv_msg->msg.data_len = msg->rsp_size - 4;\n\tdeliver_local_response(intf, recv_msg);\n\n\treturn 0;\n}\n\nstatic int handle_lan_get_msg_rsp(struct ipmi_smi *intf,\n\t\t\t\t  struct ipmi_smi_msg *msg)\n{\n\tstruct ipmi_lan_addr  lan_addr;\n\tstruct ipmi_recv_msg  *recv_msg;\n\n\n\t \n\tif (msg->rsp_size < 13) {\n\t\t \n\t\tipmi_inc_stat(intf, invalid_lan_responses);\n\t\treturn 0;\n\t}\n\n\tif (msg->rsp[2] != 0) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tlan_addr.addr_type = IPMI_LAN_ADDR_TYPE;\n\tlan_addr.session_handle = msg->rsp[4];\n\tlan_addr.remote_SWID = msg->rsp[8];\n\tlan_addr.local_SWID = msg->rsp[5];\n\tlan_addr.channel = msg->rsp[3] & 0x0f;\n\tlan_addr.privilege = msg->rsp[3] >> 4;\n\tlan_addr.lun = msg->rsp[9] & 3;\n\n\t \n\tif (intf_find_seq(intf,\n\t\t\t  msg->rsp[9] >> 2,\n\t\t\t  msg->rsp[3] & 0x0f,\n\t\t\t  msg->rsp[10],\n\t\t\t  (msg->rsp[6] >> 2) & (~1),\n\t\t\t  (struct ipmi_addr *) &lan_addr,\n\t\t\t  &recv_msg)) {\n\t\t \n\t\tipmi_inc_stat(intf, unhandled_lan_responses);\n\t\treturn 0;\n\t}\n\n\tmemcpy(recv_msg->msg_data, &msg->rsp[11], msg->rsp_size - 11);\n\t \n\trecv_msg->msg.netfn = msg->rsp[6] >> 2;\n\trecv_msg->msg.data = recv_msg->msg_data;\n\trecv_msg->msg.data_len = msg->rsp_size - 12;\n\trecv_msg->recv_type = IPMI_RESPONSE_RECV_TYPE;\n\tif (deliver_response(intf, recv_msg))\n\t\tipmi_inc_stat(intf, unhandled_lan_responses);\n\telse\n\t\tipmi_inc_stat(intf, handled_lan_responses);\n\n\treturn 0;\n}\n\nstatic int handle_lan_get_msg_cmd(struct ipmi_smi *intf,\n\t\t\t\t  struct ipmi_smi_msg *msg)\n{\n\tstruct cmd_rcvr          *rcvr;\n\tint                      rv = 0;\n\tunsigned char            netfn;\n\tunsigned char            cmd;\n\tunsigned char            chan;\n\tstruct ipmi_user         *user = NULL;\n\tstruct ipmi_lan_addr     *lan_addr;\n\tstruct ipmi_recv_msg     *recv_msg;\n\n\tif (msg->rsp_size < 12) {\n\t\t \n\t\tipmi_inc_stat(intf, invalid_commands);\n\t\treturn 0;\n\t}\n\n\tif (msg->rsp[2] != 0) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tnetfn = msg->rsp[6] >> 2;\n\tcmd = msg->rsp[10];\n\tchan = msg->rsp[3] & 0xf;\n\n\trcu_read_lock();\n\trcvr = find_cmd_rcvr(intf, netfn, cmd, chan);\n\tif (rcvr) {\n\t\tuser = rcvr->user;\n\t\tkref_get(&user->refcount);\n\t} else\n\t\tuser = NULL;\n\trcu_read_unlock();\n\n\tif (user == NULL) {\n\t\t \n\t\tipmi_inc_stat(intf, unhandled_commands);\n\n\t\t \n\t\trv = 0;\n\t} else {\n\t\trecv_msg = ipmi_alloc_recv_msg();\n\t\tif (!recv_msg) {\n\t\t\t \n\t\t\trv = 1;\n\t\t\tkref_put(&user->refcount, free_user);\n\t\t} else {\n\t\t\t \n\t\t\tlan_addr = (struct ipmi_lan_addr *) &recv_msg->addr;\n\t\t\tlan_addr->addr_type = IPMI_LAN_ADDR_TYPE;\n\t\t\tlan_addr->session_handle = msg->rsp[4];\n\t\t\tlan_addr->remote_SWID = msg->rsp[8];\n\t\t\tlan_addr->local_SWID = msg->rsp[5];\n\t\t\tlan_addr->lun = msg->rsp[9] & 3;\n\t\t\tlan_addr->channel = msg->rsp[3] & 0xf;\n\t\t\tlan_addr->privilege = msg->rsp[3] >> 4;\n\n\t\t\t \n\t\t\trecv_msg->user = user;\n\t\t\trecv_msg->recv_type = IPMI_CMD_RECV_TYPE;\n\t\t\trecv_msg->msgid = msg->rsp[9] >> 2;\n\t\t\trecv_msg->msg.netfn = msg->rsp[6] >> 2;\n\t\t\trecv_msg->msg.cmd = msg->rsp[10];\n\t\t\trecv_msg->msg.data = recv_msg->msg_data;\n\n\t\t\t \n\t\t\trecv_msg->msg.data_len = msg->rsp_size - 12;\n\t\t\tmemcpy(recv_msg->msg_data, &msg->rsp[11],\n\t\t\t       msg->rsp_size - 12);\n\t\t\tif (deliver_response(intf, recv_msg))\n\t\t\t\tipmi_inc_stat(intf, unhandled_commands);\n\t\t\telse\n\t\t\t\tipmi_inc_stat(intf, handled_commands);\n\t\t}\n\t}\n\n\treturn rv;\n}\n\n \nstatic int handle_oem_get_msg_cmd(struct ipmi_smi *intf,\n\t\t\t\t  struct ipmi_smi_msg *msg)\n{\n\tstruct cmd_rcvr       *rcvr;\n\tint                   rv = 0;\n\tunsigned char         netfn;\n\tunsigned char         cmd;\n\tunsigned char         chan;\n\tstruct ipmi_user *user = NULL;\n\tstruct ipmi_system_interface_addr *smi_addr;\n\tstruct ipmi_recv_msg  *recv_msg;\n\n\t \n\tif (msg->rsp_size < 4) {\n\t\t \n\t\tipmi_inc_stat(intf, invalid_commands);\n\t\treturn 0;\n\t}\n\n\tif (msg->rsp[2] != 0) {\n\t\t \n\t\treturn 0;\n\t}\n\n\t \n\tnetfn = msg->rsp[0] >> 2;\n\tcmd = msg->rsp[1];\n\tchan = msg->rsp[3] & 0xf;\n\n\trcu_read_lock();\n\trcvr = find_cmd_rcvr(intf, netfn, cmd, chan);\n\tif (rcvr) {\n\t\tuser = rcvr->user;\n\t\tkref_get(&user->refcount);\n\t} else\n\t\tuser = NULL;\n\trcu_read_unlock();\n\n\tif (user == NULL) {\n\t\t \n\t\tipmi_inc_stat(intf, unhandled_commands);\n\n\t\t \n\n\t\trv = 0;\n\t} else {\n\t\trecv_msg = ipmi_alloc_recv_msg();\n\t\tif (!recv_msg) {\n\t\t\t \n\t\t\trv = 1;\n\t\t\tkref_put(&user->refcount, free_user);\n\t\t} else {\n\t\t\t \n\t\t\tsmi_addr = ((struct ipmi_system_interface_addr *)\n\t\t\t\t    &recv_msg->addr);\n\t\t\tsmi_addr->addr_type = IPMI_SYSTEM_INTERFACE_ADDR_TYPE;\n\t\t\tsmi_addr->channel = IPMI_BMC_CHANNEL;\n\t\t\tsmi_addr->lun = msg->rsp[0] & 3;\n\n\t\t\trecv_msg->user = user;\n\t\t\trecv_msg->user_msg_data = NULL;\n\t\t\trecv_msg->recv_type = IPMI_OEM_RECV_TYPE;\n\t\t\trecv_msg->msg.netfn = msg->rsp[0] >> 2;\n\t\t\trecv_msg->msg.cmd = msg->rsp[1];\n\t\t\trecv_msg->msg.data = recv_msg->msg_data;\n\n\t\t\t \n\t\t\trecv_msg->msg.data_len = msg->rsp_size - 4;\n\t\t\tmemcpy(recv_msg->msg_data, &msg->rsp[4],\n\t\t\t       msg->rsp_size - 4);\n\t\t\tif (deliver_response(intf, recv_msg))\n\t\t\t\tipmi_inc_stat(intf, unhandled_commands);\n\t\t\telse\n\t\t\t\tipmi_inc_stat(intf, handled_commands);\n\t\t}\n\t}\n\n\treturn rv;\n}\n\nstatic void copy_event_into_recv_msg(struct ipmi_recv_msg *recv_msg,\n\t\t\t\t     struct ipmi_smi_msg  *msg)\n{\n\tstruct ipmi_system_interface_addr *smi_addr;\n\n\trecv_msg->msgid = 0;\n\tsmi_addr = (struct ipmi_system_interface_addr *) &recv_msg->addr;\n\tsmi_addr->addr_type = IPMI_SYSTEM_INTERFACE_ADDR_TYPE;\n\tsmi_addr->channel = IPMI_BMC_CHANNEL;\n\tsmi_addr->lun = msg->rsp[0] & 3;\n\trecv_msg->recv_type = IPMI_ASYNC_EVENT_RECV_TYPE;\n\trecv_msg->msg.netfn = msg->rsp[0] >> 2;\n\trecv_msg->msg.cmd = msg->rsp[1];\n\tmemcpy(recv_msg->msg_data, &msg->rsp[3], msg->rsp_size - 3);\n\trecv_msg->msg.data = recv_msg->msg_data;\n\trecv_msg->msg.data_len = msg->rsp_size - 3;\n}\n\nstatic int handle_read_event_rsp(struct ipmi_smi *intf,\n\t\t\t\t struct ipmi_smi_msg *msg)\n{\n\tstruct ipmi_recv_msg *recv_msg, *recv_msg2;\n\tstruct list_head     msgs;\n\tstruct ipmi_user     *user;\n\tint rv = 0, deliver_count = 0, index;\n\tunsigned long        flags;\n\n\tif (msg->rsp_size < 19) {\n\t\t \n\t\tipmi_inc_stat(intf, invalid_events);\n\t\treturn 0;\n\t}\n\n\tif (msg->rsp[2] != 0) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tINIT_LIST_HEAD(&msgs);\n\n\tspin_lock_irqsave(&intf->events_lock, flags);\n\n\tipmi_inc_stat(intf, events);\n\n\t \n\tindex = srcu_read_lock(&intf->users_srcu);\n\tlist_for_each_entry_rcu(user, &intf->users, link) {\n\t\tif (!user->gets_events)\n\t\t\tcontinue;\n\n\t\trecv_msg = ipmi_alloc_recv_msg();\n\t\tif (!recv_msg) {\n\t\t\trcu_read_unlock();\n\t\t\tlist_for_each_entry_safe(recv_msg, recv_msg2, &msgs,\n\t\t\t\t\t\t link) {\n\t\t\t\tlist_del(&recv_msg->link);\n\t\t\t\tipmi_free_recv_msg(recv_msg);\n\t\t\t}\n\t\t\t \n\t\t\trv = 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tdeliver_count++;\n\n\t\tcopy_event_into_recv_msg(recv_msg, msg);\n\t\trecv_msg->user = user;\n\t\tkref_get(&user->refcount);\n\t\tlist_add_tail(&recv_msg->link, &msgs);\n\t}\n\tsrcu_read_unlock(&intf->users_srcu, index);\n\n\tif (deliver_count) {\n\t\t \n\t\tlist_for_each_entry_safe(recv_msg, recv_msg2, &msgs, link) {\n\t\t\tlist_del(&recv_msg->link);\n\t\t\tdeliver_local_response(intf, recv_msg);\n\t\t}\n\t} else if (intf->waiting_events_count < MAX_EVENTS_IN_QUEUE) {\n\t\t \n\t\trecv_msg = ipmi_alloc_recv_msg();\n\t\tif (!recv_msg) {\n\t\t\t \n\t\t\trv = 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tcopy_event_into_recv_msg(recv_msg, msg);\n\t\tlist_add_tail(&recv_msg->link, &intf->waiting_events);\n\t\tintf->waiting_events_count++;\n\t} else if (!intf->event_msg_printed) {\n\t\t \n\t\tdev_warn(intf->si_dev,\n\t\t\t \"Event queue full, discarding incoming events\\n\");\n\t\tintf->event_msg_printed = 1;\n\t}\n\n out:\n\tspin_unlock_irqrestore(&intf->events_lock, flags);\n\n\treturn rv;\n}\n\nstatic int handle_bmc_rsp(struct ipmi_smi *intf,\n\t\t\t  struct ipmi_smi_msg *msg)\n{\n\tstruct ipmi_recv_msg *recv_msg;\n\tstruct ipmi_system_interface_addr *smi_addr;\n\n\trecv_msg = msg->user_data;\n\tif (recv_msg == NULL) {\n\t\tdev_warn(intf->si_dev,\n\t\t\t \"IPMI SMI message received with no owner. This could be because of a malformed message, or because of a hardware error.  Contact your hardware vendor for assistance.\\n\");\n\t\treturn 0;\n\t}\n\n\trecv_msg->recv_type = IPMI_RESPONSE_RECV_TYPE;\n\trecv_msg->msgid = msg->msgid;\n\tsmi_addr = ((struct ipmi_system_interface_addr *)\n\t\t    &recv_msg->addr);\n\tsmi_addr->addr_type = IPMI_SYSTEM_INTERFACE_ADDR_TYPE;\n\tsmi_addr->channel = IPMI_BMC_CHANNEL;\n\tsmi_addr->lun = msg->rsp[0] & 3;\n\trecv_msg->msg.netfn = msg->rsp[0] >> 2;\n\trecv_msg->msg.cmd = msg->rsp[1];\n\tmemcpy(recv_msg->msg_data, &msg->rsp[2], msg->rsp_size - 2);\n\trecv_msg->msg.data = recv_msg->msg_data;\n\trecv_msg->msg.data_len = msg->rsp_size - 2;\n\tdeliver_local_response(intf, recv_msg);\n\n\treturn 0;\n}\n\n \nstatic int handle_one_recv_msg(struct ipmi_smi *intf,\n\t\t\t       struct ipmi_smi_msg *msg)\n{\n\tint requeue = 0;\n\tint chan;\n\tunsigned char cc;\n\tbool is_cmd = !((msg->rsp[0] >> 2) & 1);\n\n\tdev_dbg(intf->si_dev, \"Recv: %*ph\\n\", msg->rsp_size, msg->rsp);\n\n\tif (msg->rsp_size < 2) {\n\t\t \n\t\tdev_warn(intf->si_dev,\n\t\t\t \"BMC returned too small a message for netfn %x cmd %x, got %d bytes\\n\",\n\t\t\t (msg->data[0] >> 2) | 1, msg->data[1], msg->rsp_size);\n\nreturn_unspecified:\n\t\t \n\t\tmsg->rsp[0] = msg->data[0] | (1 << 2);\n\t\tmsg->rsp[1] = msg->data[1];\n\t\tmsg->rsp[2] = IPMI_ERR_UNSPECIFIED;\n\t\tmsg->rsp_size = 3;\n\t} else if (msg->type == IPMI_SMI_MSG_TYPE_IPMB_DIRECT) {\n\t\t \n\t\tif (is_cmd && (msg->rsp_size < 4)) {\n\t\t\tipmi_inc_stat(intf, invalid_commands);\n\t\t\tgoto out;\n\t\t}\n\t\tif (!is_cmd && (msg->rsp_size < 5)) {\n\t\t\tipmi_inc_stat(intf, invalid_ipmb_responses);\n\t\t\t \n\t\t\tmsg->rsp[0] = msg->data[0] & 0xfc;  \n\t\t\tmsg->rsp[0] |= (1 << 2);  \n\t\t\tmsg->rsp[0] |= msg->data[2] & 3;  \n\t\t\tmsg->rsp[1] = msg->data[1];  \n\t\t\tmsg->rsp[2] = msg->data[2] & 0xfc;  \n\t\t\tmsg->rsp[2] |= msg->data[0] & 0x3;  \n\t\t\tmsg->rsp[3] = msg->data[3];  \n\t\t\tmsg->rsp[4] = IPMI_ERR_UNSPECIFIED;\n\t\t\tmsg->rsp_size = 5;\n\t\t}\n\t} else if ((msg->data_size >= 2)\n\t    && (msg->data[0] == (IPMI_NETFN_APP_REQUEST << 2))\n\t    && (msg->data[1] == IPMI_SEND_MSG_CMD)\n\t    && (msg->user_data == NULL)) {\n\n\t\tif (intf->in_shutdown)\n\t\t\tgoto out;\n\n\t\t \n\n\t\t \n\t\tif ((msg->rsp_size >= 3) && (msg->rsp[2] != 0)\n\t\t    && (msg->rsp[2] != IPMI_NODE_BUSY_ERR)\n\t\t    && (msg->rsp[2] != IPMI_LOST_ARBITRATION_ERR)\n\t\t    && (msg->rsp[2] != IPMI_BUS_ERR)\n\t\t    && (msg->rsp[2] != IPMI_NAK_ON_WRITE_ERR)) {\n\t\t\tint ch = msg->rsp[3] & 0xf;\n\t\t\tstruct ipmi_channel *chans;\n\n\t\t\t \n\n\t\t\tchans = READ_ONCE(intf->channel_list)->c;\n\t\t\tif ((chans[ch].medium == IPMI_CHANNEL_MEDIUM_8023LAN)\n\t\t\t    || (chans[ch].medium == IPMI_CHANNEL_MEDIUM_ASYNC))\n\t\t\t\tipmi_inc_stat(intf, sent_lan_command_errs);\n\t\t\telse\n\t\t\t\tipmi_inc_stat(intf, sent_ipmb_command_errs);\n\t\t\tintf_err_seq(intf, msg->msgid, msg->rsp[2]);\n\t\t} else\n\t\t\t \n\t\t\tintf_start_seq_timer(intf, msg->msgid);\n\t\trequeue = 0;\n\t\tgoto out;\n\t} else if (((msg->rsp[0] >> 2) != ((msg->data[0] >> 2) | 1))\n\t\t   || (msg->rsp[1] != msg->data[1])) {\n\t\t \n\t\tdev_warn(intf->si_dev,\n\t\t\t \"BMC returned incorrect response, expected netfn %x cmd %x, got netfn %x cmd %x\\n\",\n\t\t\t (msg->data[0] >> 2) | 1, msg->data[1],\n\t\t\t msg->rsp[0] >> 2, msg->rsp[1]);\n\n\t\tgoto return_unspecified;\n\t}\n\n\tif (msg->type == IPMI_SMI_MSG_TYPE_IPMB_DIRECT) {\n\t\tif ((msg->data[0] >> 2) & 1) {\n\t\t\t \n\t\t\tchan = 0;\n\t\t\tcc = msg->rsp[4];\n\t\t\tgoto process_response_response;\n\t\t}\n\t\tif (is_cmd)\n\t\t\trequeue = handle_ipmb_direct_rcv_cmd(intf, msg);\n\t\telse\n\t\t\trequeue = handle_ipmb_direct_rcv_rsp(intf, msg);\n\t} else if ((msg->rsp[0] == ((IPMI_NETFN_APP_REQUEST|1) << 2))\n\t\t   && (msg->rsp[1] == IPMI_SEND_MSG_CMD)\n\t\t   && (msg->user_data != NULL)) {\n\t\t \n\t\tstruct ipmi_recv_msg *recv_msg;\n\n\t\tchan = msg->data[2] & 0x0f;\n\t\tif (chan >= IPMI_MAX_CHANNELS)\n\t\t\t \n\t\t\tgoto out;\n\t\tcc = msg->rsp[2];\n\nprocess_response_response:\n\t\trecv_msg = msg->user_data;\n\n\t\trequeue = 0;\n\t\tif (!recv_msg)\n\t\t\tgoto out;\n\n\t\trecv_msg->recv_type = IPMI_RESPONSE_RESPONSE_TYPE;\n\t\trecv_msg->msg.data = recv_msg->msg_data;\n\t\trecv_msg->msg_data[0] = cc;\n\t\trecv_msg->msg.data_len = 1;\n\t\tdeliver_local_response(intf, recv_msg);\n\t} else if ((msg->rsp[0] == ((IPMI_NETFN_APP_REQUEST|1) << 2))\n\t\t   && (msg->rsp[1] == IPMI_GET_MSG_CMD)) {\n\t\tstruct ipmi_channel   *chans;\n\n\t\t \n\t\tchan = msg->rsp[3] & 0xf;\n\t\tif (chan >= IPMI_MAX_CHANNELS) {\n\t\t\t \n\t\t\trequeue = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (!intf->channels_ready) {\n\t\t\trequeue = 0;  \n\t\t\tgoto out;\n\t\t}\n\n\t\tchans = READ_ONCE(intf->channel_list)->c;\n\n\t\tswitch (chans[chan].medium) {\n\t\tcase IPMI_CHANNEL_MEDIUM_IPMB:\n\t\t\tif (msg->rsp[4] & 0x04) {\n\t\t\t\t \n\t\t\t\trequeue = handle_ipmb_get_msg_rsp(intf, msg);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\trequeue = handle_ipmb_get_msg_cmd(intf, msg);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase IPMI_CHANNEL_MEDIUM_8023LAN:\n\t\tcase IPMI_CHANNEL_MEDIUM_ASYNC:\n\t\t\tif (msg->rsp[6] & 0x04) {\n\t\t\t\t \n\t\t\t\trequeue = handle_lan_get_msg_rsp(intf, msg);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\trequeue = handle_lan_get_msg_cmd(intf, msg);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t \n\t\t\tif ((chans[chan].medium >= IPMI_CHANNEL_MEDIUM_OEM_MIN)\n\t\t\t    && (chans[chan].medium\n\t\t\t\t<= IPMI_CHANNEL_MEDIUM_OEM_MAX)) {\n\t\t\t\trequeue = handle_oem_get_msg_cmd(intf, msg);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\trequeue = 0;\n\t\t\t}\n\t\t}\n\n\t} else if ((msg->rsp[0] == ((IPMI_NETFN_APP_REQUEST|1) << 2))\n\t\t   && (msg->rsp[1] == IPMI_READ_EVENT_MSG_BUFFER_CMD)) {\n\t\t \n\t\trequeue = handle_read_event_rsp(intf, msg);\n\t} else {\n\t\t \n\t\trequeue = handle_bmc_rsp(intf, msg);\n\t}\n\n out:\n\treturn requeue;\n}\n\n \nstatic void handle_new_recv_msgs(struct ipmi_smi *intf)\n{\n\tstruct ipmi_smi_msg  *smi_msg;\n\tunsigned long        flags = 0;\n\tint                  rv;\n\tint                  run_to_completion = intf->run_to_completion;\n\n\t \n\tif (!run_to_completion)\n\t\tspin_lock_irqsave(&intf->waiting_rcv_msgs_lock, flags);\n\twhile (!list_empty(&intf->waiting_rcv_msgs)) {\n\t\tsmi_msg = list_entry(intf->waiting_rcv_msgs.next,\n\t\t\t\t     struct ipmi_smi_msg, link);\n\t\tlist_del(&smi_msg->link);\n\t\tif (!run_to_completion)\n\t\t\tspin_unlock_irqrestore(&intf->waiting_rcv_msgs_lock,\n\t\t\t\t\t       flags);\n\t\trv = handle_one_recv_msg(intf, smi_msg);\n\t\tif (!run_to_completion)\n\t\t\tspin_lock_irqsave(&intf->waiting_rcv_msgs_lock, flags);\n\t\tif (rv > 0) {\n\t\t\t \n\t\t\tlist_add(&smi_msg->link, &intf->waiting_rcv_msgs);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tif (rv == 0)\n\t\t\t\t \n\t\t\t\tipmi_free_smi_msg(smi_msg);\n\t\t\t \n\t\t}\n\t}\n\tif (!run_to_completion)\n\t\tspin_unlock_irqrestore(&intf->waiting_rcv_msgs_lock, flags);\n\n\t \n\tif (atomic_add_unless(&intf->watchdog_pretimeouts_to_deliver, -1, 0)) {\n\t\tstruct ipmi_user *user;\n\t\tint index;\n\n\t\tindex = srcu_read_lock(&intf->users_srcu);\n\t\tlist_for_each_entry_rcu(user, &intf->users, link) {\n\t\t\tif (user->handler->ipmi_watchdog_pretimeout)\n\t\t\t\tuser->handler->ipmi_watchdog_pretimeout(\n\t\t\t\t\tuser->handler_data);\n\t\t}\n\t\tsrcu_read_unlock(&intf->users_srcu, index);\n\t}\n}\n\nstatic void smi_recv_tasklet(struct tasklet_struct *t)\n{\n\tunsigned long flags = 0;  \n\tstruct ipmi_smi *intf = from_tasklet(intf, t, recv_tasklet);\n\tint run_to_completion = intf->run_to_completion;\n\tstruct ipmi_smi_msg *newmsg = NULL;\n\n\t \n\n\trcu_read_lock();\n\n\tif (!run_to_completion)\n\t\tspin_lock_irqsave(&intf->xmit_msgs_lock, flags);\n\tif (intf->curr_msg == NULL && !intf->in_shutdown) {\n\t\tstruct list_head *entry = NULL;\n\n\t\t \n\t\tif (!list_empty(&intf->hp_xmit_msgs))\n\t\t\tentry = intf->hp_xmit_msgs.next;\n\t\telse if (!list_empty(&intf->xmit_msgs))\n\t\t\tentry = intf->xmit_msgs.next;\n\n\t\tif (entry) {\n\t\t\tlist_del(entry);\n\t\t\tnewmsg = list_entry(entry, struct ipmi_smi_msg, link);\n\t\t\tintf->curr_msg = newmsg;\n\t\t}\n\t}\n\n\tif (!run_to_completion)\n\t\tspin_unlock_irqrestore(&intf->xmit_msgs_lock, flags);\n\tif (newmsg)\n\t\tintf->handlers->sender(intf->send_info, newmsg);\n\n\trcu_read_unlock();\n\n\thandle_new_recv_msgs(intf);\n}\n\n \nvoid ipmi_smi_msg_received(struct ipmi_smi *intf,\n\t\t\t   struct ipmi_smi_msg *msg)\n{\n\tunsigned long flags = 0;  \n\tint run_to_completion = intf->run_to_completion;\n\n\t \n\tif (!run_to_completion)\n\t\tspin_lock_irqsave(&intf->waiting_rcv_msgs_lock, flags);\n\tlist_add_tail(&msg->link, &intf->waiting_rcv_msgs);\n\tif (!run_to_completion)\n\t\tspin_unlock_irqrestore(&intf->waiting_rcv_msgs_lock,\n\t\t\t\t       flags);\n\n\tif (!run_to_completion)\n\t\tspin_lock_irqsave(&intf->xmit_msgs_lock, flags);\n\t \n\tif (msg == intf->curr_msg)\n\t\tintf->curr_msg = NULL;\n\tif (!run_to_completion)\n\t\tspin_unlock_irqrestore(&intf->xmit_msgs_lock, flags);\n\n\tif (run_to_completion)\n\t\tsmi_recv_tasklet(&intf->recv_tasklet);\n\telse\n\t\ttasklet_schedule(&intf->recv_tasklet);\n}\nEXPORT_SYMBOL(ipmi_smi_msg_received);\n\nvoid ipmi_smi_watchdog_pretimeout(struct ipmi_smi *intf)\n{\n\tif (intf->in_shutdown)\n\t\treturn;\n\n\tatomic_set(&intf->watchdog_pretimeouts_to_deliver, 1);\n\ttasklet_schedule(&intf->recv_tasklet);\n}\nEXPORT_SYMBOL(ipmi_smi_watchdog_pretimeout);\n\nstatic struct ipmi_smi_msg *\nsmi_from_recv_msg(struct ipmi_smi *intf, struct ipmi_recv_msg *recv_msg,\n\t\t  unsigned char seq, long seqid)\n{\n\tstruct ipmi_smi_msg *smi_msg = ipmi_alloc_smi_msg();\n\tif (!smi_msg)\n\t\t \n\t\treturn NULL;\n\n\tmemcpy(smi_msg->data, recv_msg->msg.data, recv_msg->msg.data_len);\n\tsmi_msg->data_size = recv_msg->msg.data_len;\n\tsmi_msg->msgid = STORE_SEQ_IN_MSGID(seq, seqid);\n\n\tdev_dbg(intf->si_dev, \"Resend: %*ph\\n\",\n\t\tsmi_msg->data_size, smi_msg->data);\n\n\treturn smi_msg;\n}\n\nstatic void check_msg_timeout(struct ipmi_smi *intf, struct seq_table *ent,\n\t\t\t      struct list_head *timeouts,\n\t\t\t      unsigned long timeout_period,\n\t\t\t      int slot, unsigned long *flags,\n\t\t\t      bool *need_timer)\n{\n\tstruct ipmi_recv_msg *msg;\n\n\tif (intf->in_shutdown)\n\t\treturn;\n\n\tif (!ent->inuse)\n\t\treturn;\n\n\tif (timeout_period < ent->timeout) {\n\t\tent->timeout -= timeout_period;\n\t\t*need_timer = true;\n\t\treturn;\n\t}\n\n\tif (ent->retries_left == 0) {\n\t\t \n\t\tent->inuse = 0;\n\t\tsmi_remove_watch(intf, IPMI_WATCH_MASK_CHECK_MESSAGES);\n\t\tmsg = ent->recv_msg;\n\t\tlist_add_tail(&msg->link, timeouts);\n\t\tif (ent->broadcast)\n\t\t\tipmi_inc_stat(intf, timed_out_ipmb_broadcasts);\n\t\telse if (is_lan_addr(&ent->recv_msg->addr))\n\t\t\tipmi_inc_stat(intf, timed_out_lan_commands);\n\t\telse\n\t\t\tipmi_inc_stat(intf, timed_out_ipmb_commands);\n\t} else {\n\t\tstruct ipmi_smi_msg *smi_msg;\n\t\t \n\n\t\t*need_timer = true;\n\n\t\t \n\t\tent->timeout = MAX_MSG_TIMEOUT;\n\t\tent->retries_left--;\n\t\tsmi_msg = smi_from_recv_msg(intf, ent->recv_msg, slot,\n\t\t\t\t\t    ent->seqid);\n\t\tif (!smi_msg) {\n\t\t\tif (is_lan_addr(&ent->recv_msg->addr))\n\t\t\t\tipmi_inc_stat(intf,\n\t\t\t\t\t      dropped_rexmit_lan_commands);\n\t\t\telse\n\t\t\t\tipmi_inc_stat(intf,\n\t\t\t\t\t      dropped_rexmit_ipmb_commands);\n\t\t\treturn;\n\t\t}\n\n\t\tspin_unlock_irqrestore(&intf->seq_lock, *flags);\n\n\t\t \n\t\tif (intf->handlers) {\n\t\t\tif (is_lan_addr(&ent->recv_msg->addr))\n\t\t\t\tipmi_inc_stat(intf,\n\t\t\t\t\t      retransmitted_lan_commands);\n\t\t\telse\n\t\t\t\tipmi_inc_stat(intf,\n\t\t\t\t\t      retransmitted_ipmb_commands);\n\n\t\t\tsmi_send(intf, intf->handlers, smi_msg, 0);\n\t\t} else\n\t\t\tipmi_free_smi_msg(smi_msg);\n\n\t\tspin_lock_irqsave(&intf->seq_lock, *flags);\n\t}\n}\n\nstatic bool ipmi_timeout_handler(struct ipmi_smi *intf,\n\t\t\t\t unsigned long timeout_period)\n{\n\tstruct list_head     timeouts;\n\tstruct ipmi_recv_msg *msg, *msg2;\n\tunsigned long        flags;\n\tint                  i;\n\tbool                 need_timer = false;\n\n\tif (!intf->bmc_registered) {\n\t\tkref_get(&intf->refcount);\n\t\tif (!schedule_work(&intf->bmc_reg_work)) {\n\t\t\tkref_put(&intf->refcount, intf_free);\n\t\t\tneed_timer = true;\n\t\t}\n\t}\n\n\t \n\tINIT_LIST_HEAD(&timeouts);\n\tspin_lock_irqsave(&intf->seq_lock, flags);\n\tif (intf->ipmb_maintenance_mode_timeout) {\n\t\tif (intf->ipmb_maintenance_mode_timeout <= timeout_period)\n\t\t\tintf->ipmb_maintenance_mode_timeout = 0;\n\t\telse\n\t\t\tintf->ipmb_maintenance_mode_timeout -= timeout_period;\n\t}\n\tfor (i = 0; i < IPMI_IPMB_NUM_SEQ; i++)\n\t\tcheck_msg_timeout(intf, &intf->seq_table[i],\n\t\t\t\t  &timeouts, timeout_period, i,\n\t\t\t\t  &flags, &need_timer);\n\tspin_unlock_irqrestore(&intf->seq_lock, flags);\n\n\tlist_for_each_entry_safe(msg, msg2, &timeouts, link)\n\t\tdeliver_err_response(intf, msg, IPMI_TIMEOUT_COMPLETION_CODE);\n\n\t \n\tif (intf->auto_maintenance_timeout > 0) {\n\t\tspin_lock_irqsave(&intf->maintenance_mode_lock, flags);\n\t\tif (intf->auto_maintenance_timeout > 0) {\n\t\t\tintf->auto_maintenance_timeout\n\t\t\t\t-= timeout_period;\n\t\t\tif (!intf->maintenance_mode\n\t\t\t    && (intf->auto_maintenance_timeout <= 0)) {\n\t\t\t\tintf->maintenance_mode_enable = false;\n\t\t\t\tmaintenance_mode_update(intf);\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&intf->maintenance_mode_lock,\n\t\t\t\t       flags);\n\t}\n\n\ttasklet_schedule(&intf->recv_tasklet);\n\n\treturn need_timer;\n}\n\nstatic void ipmi_request_event(struct ipmi_smi *intf)\n{\n\t \n\tif (intf->maintenance_mode_enable)\n\t\treturn;\n\n\tif (!intf->in_shutdown)\n\t\tintf->handlers->request_events(intf->send_info);\n}\n\nstatic struct timer_list ipmi_timer;\n\nstatic atomic_t stop_operation;\n\nstatic void ipmi_timeout(struct timer_list *unused)\n{\n\tstruct ipmi_smi *intf;\n\tbool need_timer = false;\n\tint index;\n\n\tif (atomic_read(&stop_operation))\n\t\treturn;\n\n\tindex = srcu_read_lock(&ipmi_interfaces_srcu);\n\tlist_for_each_entry_rcu(intf, &ipmi_interfaces, link) {\n\t\tif (atomic_read(&intf->event_waiters)) {\n\t\t\tintf->ticks_to_req_ev--;\n\t\t\tif (intf->ticks_to_req_ev == 0) {\n\t\t\t\tipmi_request_event(intf);\n\t\t\t\tintf->ticks_to_req_ev = IPMI_REQUEST_EV_TIME;\n\t\t\t}\n\t\t\tneed_timer = true;\n\t\t}\n\n\t\tneed_timer |= ipmi_timeout_handler(intf, IPMI_TIMEOUT_TIME);\n\t}\n\tsrcu_read_unlock(&ipmi_interfaces_srcu, index);\n\n\tif (need_timer)\n\t\tmod_timer(&ipmi_timer, jiffies + IPMI_TIMEOUT_JIFFIES);\n}\n\nstatic void need_waiter(struct ipmi_smi *intf)\n{\n\t \n\tif (!timer_pending(&ipmi_timer))\n\t\tmod_timer(&ipmi_timer, jiffies + IPMI_TIMEOUT_JIFFIES);\n}\n\nstatic atomic_t smi_msg_inuse_count = ATOMIC_INIT(0);\nstatic atomic_t recv_msg_inuse_count = ATOMIC_INIT(0);\n\nstatic void free_smi_msg(struct ipmi_smi_msg *msg)\n{\n\tatomic_dec(&smi_msg_inuse_count);\n\t \n\tif (!oops_in_progress)\n\t\tkfree(msg);\n}\n\nstruct ipmi_smi_msg *ipmi_alloc_smi_msg(void)\n{\n\tstruct ipmi_smi_msg *rv;\n\trv = kmalloc(sizeof(struct ipmi_smi_msg), GFP_ATOMIC);\n\tif (rv) {\n\t\trv->done = free_smi_msg;\n\t\trv->user_data = NULL;\n\t\trv->type = IPMI_SMI_MSG_TYPE_NORMAL;\n\t\tatomic_inc(&smi_msg_inuse_count);\n\t}\n\treturn rv;\n}\nEXPORT_SYMBOL(ipmi_alloc_smi_msg);\n\nstatic void free_recv_msg(struct ipmi_recv_msg *msg)\n{\n\tatomic_dec(&recv_msg_inuse_count);\n\t \n\tif (!oops_in_progress)\n\t\tkfree(msg);\n}\n\nstatic struct ipmi_recv_msg *ipmi_alloc_recv_msg(void)\n{\n\tstruct ipmi_recv_msg *rv;\n\n\trv = kmalloc(sizeof(struct ipmi_recv_msg), GFP_ATOMIC);\n\tif (rv) {\n\t\trv->user = NULL;\n\t\trv->done = free_recv_msg;\n\t\tatomic_inc(&recv_msg_inuse_count);\n\t}\n\treturn rv;\n}\n\nvoid ipmi_free_recv_msg(struct ipmi_recv_msg *msg)\n{\n\tif (msg->user && !oops_in_progress)\n\t\tkref_put(&msg->user->refcount, free_user);\n\tmsg->done(msg);\n}\nEXPORT_SYMBOL(ipmi_free_recv_msg);\n\nstatic atomic_t panic_done_count = ATOMIC_INIT(0);\n\nstatic void dummy_smi_done_handler(struct ipmi_smi_msg *msg)\n{\n\tatomic_dec(&panic_done_count);\n}\n\nstatic void dummy_recv_done_handler(struct ipmi_recv_msg *msg)\n{\n\tatomic_dec(&panic_done_count);\n}\n\n \nstatic void ipmi_panic_request_and_wait(struct ipmi_smi *intf,\n\t\t\t\t\tstruct ipmi_addr *addr,\n\t\t\t\t\tstruct kernel_ipmi_msg *msg)\n{\n\tstruct ipmi_smi_msg  smi_msg;\n\tstruct ipmi_recv_msg recv_msg;\n\tint rv;\n\n\tsmi_msg.done = dummy_smi_done_handler;\n\trecv_msg.done = dummy_recv_done_handler;\n\tatomic_add(2, &panic_done_count);\n\trv = i_ipmi_request(NULL,\n\t\t\t    intf,\n\t\t\t    addr,\n\t\t\t    0,\n\t\t\t    msg,\n\t\t\t    intf,\n\t\t\t    &smi_msg,\n\t\t\t    &recv_msg,\n\t\t\t    0,\n\t\t\t    intf->addrinfo[0].address,\n\t\t\t    intf->addrinfo[0].lun,\n\t\t\t    0, 1);  \n\tif (rv)\n\t\tatomic_sub(2, &panic_done_count);\n\telse if (intf->handlers->flush_messages)\n\t\tintf->handlers->flush_messages(intf->send_info);\n\n\twhile (atomic_read(&panic_done_count) != 0)\n\t\tipmi_poll(intf);\n}\n\nstatic void event_receiver_fetcher(struct ipmi_smi *intf,\n\t\t\t\t   struct ipmi_recv_msg *msg)\n{\n\tif ((msg->addr.addr_type == IPMI_SYSTEM_INTERFACE_ADDR_TYPE)\n\t    && (msg->msg.netfn == IPMI_NETFN_SENSOR_EVENT_RESPONSE)\n\t    && (msg->msg.cmd == IPMI_GET_EVENT_RECEIVER_CMD)\n\t    && (msg->msg.data[0] == IPMI_CC_NO_ERROR)) {\n\t\t \n\t\tintf->event_receiver = msg->msg.data[1];\n\t\tintf->event_receiver_lun = msg->msg.data[2] & 0x3;\n\t}\n}\n\nstatic void device_id_fetcher(struct ipmi_smi *intf, struct ipmi_recv_msg *msg)\n{\n\tif ((msg->addr.addr_type == IPMI_SYSTEM_INTERFACE_ADDR_TYPE)\n\t    && (msg->msg.netfn == IPMI_NETFN_APP_RESPONSE)\n\t    && (msg->msg.cmd == IPMI_GET_DEVICE_ID_CMD)\n\t    && (msg->msg.data[0] == IPMI_CC_NO_ERROR)) {\n\t\t \n\t\tintf->local_sel_device = (msg->msg.data[6] >> 2) & 1;\n\t\tintf->local_event_generator = (msg->msg.data[6] >> 5) & 1;\n\t}\n}\n\nstatic void send_panic_events(struct ipmi_smi *intf, char *str)\n{\n\tstruct kernel_ipmi_msg msg;\n\tunsigned char data[16];\n\tstruct ipmi_system_interface_addr *si;\n\tstruct ipmi_addr addr;\n\tchar *p = str;\n\tstruct ipmi_ipmb_addr *ipmb;\n\tint j;\n\n\tif (ipmi_send_panic_event == IPMI_SEND_PANIC_EVENT_NONE)\n\t\treturn;\n\n\tsi = (struct ipmi_system_interface_addr *) &addr;\n\tsi->addr_type = IPMI_SYSTEM_INTERFACE_ADDR_TYPE;\n\tsi->channel = IPMI_BMC_CHANNEL;\n\tsi->lun = 0;\n\n\t \n\tmsg.netfn = 0x04;  \n\tmsg.cmd = 2;  \n\tmsg.data = data;\n\tmsg.data_len = 8;\n\tdata[0] = 0x41;  \n\tdata[1] = 0x03;  \n\tdata[2] = 0x20;  \n\tdata[4] = 0x6f;  \n\tdata[5] = 0xa1;  \n\n\t \n\tif (str) {\n\t\tdata[3] = str[0];\n\t\tdata[6] = str[1];\n\t\tdata[7] = str[2];\n\t}\n\n\t \n\tipmi_panic_request_and_wait(intf, &addr, &msg);\n\n\t \n\tif (ipmi_send_panic_event != IPMI_SEND_PANIC_EVENT_STRING || !str)\n\t\treturn;\n\n\t \n\tsmp_rmb();\n\n\t \n\n\t \n\tintf->local_sel_device = 0;\n\tintf->local_event_generator = 0;\n\tintf->event_receiver = 0;\n\n\t \n\tmsg.netfn = IPMI_NETFN_APP_REQUEST;\n\tmsg.cmd = IPMI_GET_DEVICE_ID_CMD;\n\tmsg.data = NULL;\n\tmsg.data_len = 0;\n\tintf->null_user_handler = device_id_fetcher;\n\tipmi_panic_request_and_wait(intf, &addr, &msg);\n\n\tif (intf->local_event_generator) {\n\t\t \n\t\tmsg.netfn = IPMI_NETFN_SENSOR_EVENT_REQUEST;\n\t\tmsg.cmd = IPMI_GET_EVENT_RECEIVER_CMD;\n\t\tmsg.data = NULL;\n\t\tmsg.data_len = 0;\n\t\tintf->null_user_handler = event_receiver_fetcher;\n\t\tipmi_panic_request_and_wait(intf, &addr, &msg);\n\t}\n\tintf->null_user_handler = NULL;\n\n\t \n\tif (((intf->event_receiver & 1) == 0)\n\t    && (intf->event_receiver != 0)\n\t    && (intf->event_receiver != intf->addrinfo[0].address)) {\n\t\t \n\t\tipmb = (struct ipmi_ipmb_addr *) &addr;\n\t\tipmb->addr_type = IPMI_IPMB_ADDR_TYPE;\n\t\tipmb->channel = 0;  \n\t\tipmb->lun = intf->event_receiver_lun;\n\t\tipmb->slave_addr = intf->event_receiver;\n\t} else if (intf->local_sel_device) {\n\t\t \n\t\tsi = (struct ipmi_system_interface_addr *) &addr;\n\t\tsi->addr_type = IPMI_SYSTEM_INTERFACE_ADDR_TYPE;\n\t\tsi->channel = IPMI_BMC_CHANNEL;\n\t\tsi->lun = 0;\n\t} else\n\t\treturn;  \n\n\tmsg.netfn = IPMI_NETFN_STORAGE_REQUEST;  \n\tmsg.cmd = IPMI_ADD_SEL_ENTRY_CMD;\n\tmsg.data = data;\n\tmsg.data_len = 16;\n\n\tj = 0;\n\twhile (*p) {\n\t\tint size = strlen(p);\n\n\t\tif (size > 11)\n\t\t\tsize = 11;\n\t\tdata[0] = 0;\n\t\tdata[1] = 0;\n\t\tdata[2] = 0xf0;  \n\t\tdata[3] = intf->addrinfo[0].address;\n\t\tdata[4] = j++;  \n\t\t \n\t\tstrncpy(data+5, p, 11);\n\t\tp += size;\n\n\t\tipmi_panic_request_and_wait(intf, &addr, &msg);\n\t}\n}\n\nstatic int has_panicked;\n\nstatic int panic_event(struct notifier_block *this,\n\t\t       unsigned long         event,\n\t\t       void                  *ptr)\n{\n\tstruct ipmi_smi *intf;\n\tstruct ipmi_user *user;\n\n\tif (has_panicked)\n\t\treturn NOTIFY_DONE;\n\thas_panicked = 1;\n\n\t \n\tlist_for_each_entry_rcu(intf, &ipmi_interfaces, link) {\n\t\tif (!intf->handlers || intf->intf_num == -1)\n\t\t\t \n\t\t\tcontinue;\n\n\t\tif (!intf->handlers->poll)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!spin_trylock(&intf->xmit_msgs_lock)) {\n\t\t\tINIT_LIST_HEAD(&intf->xmit_msgs);\n\t\t\tINIT_LIST_HEAD(&intf->hp_xmit_msgs);\n\t\t} else\n\t\t\tspin_unlock(&intf->xmit_msgs_lock);\n\n\t\tif (!spin_trylock(&intf->waiting_rcv_msgs_lock))\n\t\t\tINIT_LIST_HEAD(&intf->waiting_rcv_msgs);\n\t\telse\n\t\t\tspin_unlock(&intf->waiting_rcv_msgs_lock);\n\n\t\tintf->run_to_completion = 1;\n\t\tif (intf->handlers->set_run_to_completion)\n\t\t\tintf->handlers->set_run_to_completion(intf->send_info,\n\t\t\t\t\t\t\t      1);\n\n\t\tlist_for_each_entry_rcu(user, &intf->users, link) {\n\t\t\tif (user->handler->ipmi_panic_handler)\n\t\t\t\tuser->handler->ipmi_panic_handler(\n\t\t\t\t\tuser->handler_data);\n\t\t}\n\n\t\tsend_panic_events(intf, ptr);\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\n \nstatic int ipmi_register_driver(void)\n{\n\tint rv;\n\n\tif (drvregistered)\n\t\treturn 0;\n\n\trv = driver_register(&ipmidriver.driver);\n\tif (rv)\n\t\tpr_err(\"Could not register IPMI driver\\n\");\n\telse\n\t\tdrvregistered = true;\n\treturn rv;\n}\n\nstatic struct notifier_block panic_block = {\n\t.notifier_call\t= panic_event,\n\t.next\t\t= NULL,\n\t.priority\t= 200\t \n};\n\nstatic int ipmi_init_msghandler(void)\n{\n\tint rv;\n\n\tmutex_lock(&ipmi_interfaces_mutex);\n\trv = ipmi_register_driver();\n\tif (rv)\n\t\tgoto out;\n\tif (initialized)\n\t\tgoto out;\n\n\trv = init_srcu_struct(&ipmi_interfaces_srcu);\n\tif (rv)\n\t\tgoto out;\n\n\tremove_work_wq = create_singlethread_workqueue(\"ipmi-msghandler-remove-wq\");\n\tif (!remove_work_wq) {\n\t\tpr_err(\"unable to create ipmi-msghandler-remove-wq workqueue\");\n\t\trv = -ENOMEM;\n\t\tgoto out_wq;\n\t}\n\n\ttimer_setup(&ipmi_timer, ipmi_timeout, 0);\n\tmod_timer(&ipmi_timer, jiffies + IPMI_TIMEOUT_JIFFIES);\n\n\tatomic_notifier_chain_register(&panic_notifier_list, &panic_block);\n\n\tinitialized = true;\n\nout_wq:\n\tif (rv)\n\t\tcleanup_srcu_struct(&ipmi_interfaces_srcu);\nout:\n\tmutex_unlock(&ipmi_interfaces_mutex);\n\treturn rv;\n}\n\nstatic int __init ipmi_init_msghandler_mod(void)\n{\n\tint rv;\n\n\tpr_info(\"version \" IPMI_DRIVER_VERSION \"\\n\");\n\n\tmutex_lock(&ipmi_interfaces_mutex);\n\trv = ipmi_register_driver();\n\tmutex_unlock(&ipmi_interfaces_mutex);\n\n\treturn rv;\n}\n\nstatic void __exit cleanup_ipmi(void)\n{\n\tint count;\n\n\tif (initialized) {\n\t\tdestroy_workqueue(remove_work_wq);\n\n\t\tatomic_notifier_chain_unregister(&panic_notifier_list,\n\t\t\t\t\t\t &panic_block);\n\n\t\t \n\n\t\t \n\t\tatomic_set(&stop_operation, 1);\n\t\tdel_timer_sync(&ipmi_timer);\n\n\t\tinitialized = false;\n\n\t\t \n\t\tcount = atomic_read(&smi_msg_inuse_count);\n\t\tif (count != 0)\n\t\t\tpr_warn(\"SMI message count %d at exit\\n\", count);\n\t\tcount = atomic_read(&recv_msg_inuse_count);\n\t\tif (count != 0)\n\t\t\tpr_warn(\"recv message count %d at exit\\n\", count);\n\n\t\tcleanup_srcu_struct(&ipmi_interfaces_srcu);\n\t}\n\tif (drvregistered)\n\t\tdriver_unregister(&ipmidriver.driver);\n}\nmodule_exit(cleanup_ipmi);\n\nmodule_init(ipmi_init_msghandler_mod);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Corey Minyard <minyard@mvista.com>\");\nMODULE_DESCRIPTION(\"Incoming and outgoing message routing for an IPMI interface.\");\nMODULE_VERSION(IPMI_DRIVER_VERSION);\nMODULE_SOFTDEP(\"post: ipmi_devintf\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}