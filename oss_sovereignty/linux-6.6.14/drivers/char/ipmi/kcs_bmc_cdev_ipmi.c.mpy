{
  "module_name": "kcs_bmc_cdev_ipmi.c",
  "hash_id": "f93f501d0027586ca3fe687d8eaffd8b96db27002b634de631b7268155b3518e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/ipmi/kcs_bmc_cdev_ipmi.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"kcs-bmc: \" fmt\n\n#include <linux/errno.h>\n#include <linux/io.h>\n#include <linux/ipmi_bmc.h>\n#include <linux/list.h>\n#include <linux/miscdevice.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/platform_device.h>\n#include <linux/poll.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#include \"kcs_bmc_client.h\"\n\n \nenum kcs_ipmi_phases {\n\tKCS_PHASE_IDLE,\n\n\tKCS_PHASE_WRITE_START,\n\tKCS_PHASE_WRITE_DATA,\n\tKCS_PHASE_WRITE_END_CMD,\n\tKCS_PHASE_WRITE_DONE,\n\n\tKCS_PHASE_WAIT_READ,\n\tKCS_PHASE_READ,\n\n\tKCS_PHASE_ABORT_ERROR1,\n\tKCS_PHASE_ABORT_ERROR2,\n\tKCS_PHASE_ERROR\n};\n\n \nenum kcs_ipmi_errors {\n\tKCS_NO_ERROR                = 0x00,\n\tKCS_ABORTED_BY_COMMAND      = 0x01,\n\tKCS_ILLEGAL_CONTROL_CODE    = 0x02,\n\tKCS_LENGTH_ERROR            = 0x06,\n\tKCS_UNSPECIFIED_ERROR       = 0xFF\n};\n\nstruct kcs_bmc_ipmi {\n\tstruct list_head entry;\n\n\tstruct kcs_bmc_client client;\n\n\tspinlock_t lock;\n\n\tenum kcs_ipmi_phases phase;\n\tenum kcs_ipmi_errors error;\n\n\twait_queue_head_t queue;\n\tbool data_in_avail;\n\tint  data_in_idx;\n\tu8  *data_in;\n\n\tint  data_out_idx;\n\tint  data_out_len;\n\tu8  *data_out;\n\n\tstruct mutex mutex;\n\tu8 *kbuffer;\n\n\tstruct miscdevice miscdev;\n};\n\n#define DEVICE_NAME \"ipmi-kcs\"\n\n#define KCS_MSG_BUFSIZ    1000\n\n#define KCS_ZERO_DATA     0\n\n \n#define KCS_STATUS_STATE(state) (state << 6)\n#define KCS_STATUS_STATE_MASK   GENMASK(7, 6)\n#define KCS_STATUS_CMD_DAT      BIT(3)\n#define KCS_STATUS_SMS_ATN      BIT(2)\n#define KCS_STATUS_IBF          BIT(1)\n#define KCS_STATUS_OBF          BIT(0)\n\n \nenum kcs_states {\n\tIDLE_STATE  = 0,\n\tREAD_STATE  = 1,\n\tWRITE_STATE = 2,\n\tERROR_STATE = 3,\n};\n\n \n#define KCS_CMD_GET_STATUS_ABORT  0x60\n#define KCS_CMD_WRITE_START       0x61\n#define KCS_CMD_WRITE_END         0x62\n#define KCS_CMD_READ_BYTE         0x68\n\nstatic inline void set_state(struct kcs_bmc_ipmi *priv, u8 state)\n{\n\tkcs_bmc_update_status(priv->client.dev, KCS_STATUS_STATE_MASK, KCS_STATUS_STATE(state));\n}\n\nstatic void kcs_bmc_ipmi_force_abort(struct kcs_bmc_ipmi *priv)\n{\n\tset_state(priv, ERROR_STATE);\n\tkcs_bmc_read_data(priv->client.dev);\n\tkcs_bmc_write_data(priv->client.dev, KCS_ZERO_DATA);\n\n\tpriv->phase = KCS_PHASE_ERROR;\n\tpriv->data_in_avail = false;\n\tpriv->data_in_idx = 0;\n}\n\nstatic void kcs_bmc_ipmi_handle_data(struct kcs_bmc_ipmi *priv)\n{\n\tstruct kcs_bmc_device *dev;\n\tu8 data;\n\n\tdev = priv->client.dev;\n\n\tswitch (priv->phase) {\n\tcase KCS_PHASE_WRITE_START:\n\t\tpriv->phase = KCS_PHASE_WRITE_DATA;\n\t\tfallthrough;\n\n\tcase KCS_PHASE_WRITE_DATA:\n\t\tif (priv->data_in_idx < KCS_MSG_BUFSIZ) {\n\t\t\tset_state(priv, WRITE_STATE);\n\t\t\tkcs_bmc_write_data(dev, KCS_ZERO_DATA);\n\t\t\tpriv->data_in[priv->data_in_idx++] = kcs_bmc_read_data(dev);\n\t\t} else {\n\t\t\tkcs_bmc_ipmi_force_abort(priv);\n\t\t\tpriv->error = KCS_LENGTH_ERROR;\n\t\t}\n\t\tbreak;\n\n\tcase KCS_PHASE_WRITE_END_CMD:\n\t\tif (priv->data_in_idx < KCS_MSG_BUFSIZ) {\n\t\t\tset_state(priv, READ_STATE);\n\t\t\tpriv->data_in[priv->data_in_idx++] = kcs_bmc_read_data(dev);\n\t\t\tpriv->phase = KCS_PHASE_WRITE_DONE;\n\t\t\tpriv->data_in_avail = true;\n\t\t\twake_up_interruptible(&priv->queue);\n\t\t} else {\n\t\t\tkcs_bmc_ipmi_force_abort(priv);\n\t\t\tpriv->error = KCS_LENGTH_ERROR;\n\t\t}\n\t\tbreak;\n\n\tcase KCS_PHASE_READ:\n\t\tif (priv->data_out_idx == priv->data_out_len)\n\t\t\tset_state(priv, IDLE_STATE);\n\n\t\tdata = kcs_bmc_read_data(dev);\n\t\tif (data != KCS_CMD_READ_BYTE) {\n\t\t\tset_state(priv, ERROR_STATE);\n\t\t\tkcs_bmc_write_data(dev, KCS_ZERO_DATA);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (priv->data_out_idx == priv->data_out_len) {\n\t\t\tkcs_bmc_write_data(dev, KCS_ZERO_DATA);\n\t\t\tpriv->phase = KCS_PHASE_IDLE;\n\t\t\tbreak;\n\t\t}\n\n\t\tkcs_bmc_write_data(dev, priv->data_out[priv->data_out_idx++]);\n\t\tbreak;\n\n\tcase KCS_PHASE_ABORT_ERROR1:\n\t\tset_state(priv, READ_STATE);\n\t\tkcs_bmc_read_data(dev);\n\t\tkcs_bmc_write_data(dev, priv->error);\n\t\tpriv->phase = KCS_PHASE_ABORT_ERROR2;\n\t\tbreak;\n\n\tcase KCS_PHASE_ABORT_ERROR2:\n\t\tset_state(priv, IDLE_STATE);\n\t\tkcs_bmc_read_data(dev);\n\t\tkcs_bmc_write_data(dev, KCS_ZERO_DATA);\n\t\tpriv->phase = KCS_PHASE_IDLE;\n\t\tbreak;\n\n\tdefault:\n\t\tkcs_bmc_ipmi_force_abort(priv);\n\t\tbreak;\n\t}\n}\n\nstatic void kcs_bmc_ipmi_handle_cmd(struct kcs_bmc_ipmi *priv)\n{\n\tu8 cmd;\n\n\tset_state(priv, WRITE_STATE);\n\tkcs_bmc_write_data(priv->client.dev, KCS_ZERO_DATA);\n\n\tcmd = kcs_bmc_read_data(priv->client.dev);\n\tswitch (cmd) {\n\tcase KCS_CMD_WRITE_START:\n\t\tpriv->phase = KCS_PHASE_WRITE_START;\n\t\tpriv->error = KCS_NO_ERROR;\n\t\tpriv->data_in_avail = false;\n\t\tpriv->data_in_idx = 0;\n\t\tbreak;\n\n\tcase KCS_CMD_WRITE_END:\n\t\tif (priv->phase != KCS_PHASE_WRITE_DATA) {\n\t\t\tkcs_bmc_ipmi_force_abort(priv);\n\t\t\tbreak;\n\t\t}\n\n\t\tpriv->phase = KCS_PHASE_WRITE_END_CMD;\n\t\tbreak;\n\n\tcase KCS_CMD_GET_STATUS_ABORT:\n\t\tif (priv->error == KCS_NO_ERROR)\n\t\t\tpriv->error = KCS_ABORTED_BY_COMMAND;\n\n\t\tpriv->phase = KCS_PHASE_ABORT_ERROR1;\n\t\tpriv->data_in_avail = false;\n\t\tpriv->data_in_idx = 0;\n\t\tbreak;\n\n\tdefault:\n\t\tkcs_bmc_ipmi_force_abort(priv);\n\t\tpriv->error = KCS_ILLEGAL_CONTROL_CODE;\n\t\tbreak;\n\t}\n}\n\nstatic inline struct kcs_bmc_ipmi *client_to_kcs_bmc_ipmi(struct kcs_bmc_client *client)\n{\n\treturn container_of(client, struct kcs_bmc_ipmi, client);\n}\n\nstatic irqreturn_t kcs_bmc_ipmi_event(struct kcs_bmc_client *client)\n{\n\tstruct kcs_bmc_ipmi *priv;\n\tu8 status;\n\tint ret;\n\n\tpriv = client_to_kcs_bmc_ipmi(client);\n\tif (!priv)\n\t\treturn IRQ_NONE;\n\n\tspin_lock(&priv->lock);\n\n\tstatus = kcs_bmc_read_status(client->dev);\n\tif (status & KCS_STATUS_IBF) {\n\t\tif (status & KCS_STATUS_CMD_DAT)\n\t\t\tkcs_bmc_ipmi_handle_cmd(priv);\n\t\telse\n\t\t\tkcs_bmc_ipmi_handle_data(priv);\n\n\t\tret = IRQ_HANDLED;\n\t} else {\n\t\tret = IRQ_NONE;\n\t}\n\n\tspin_unlock(&priv->lock);\n\n\treturn ret;\n}\n\nstatic const struct kcs_bmc_client_ops kcs_bmc_ipmi_client_ops = {\n\t.event = kcs_bmc_ipmi_event,\n};\n\nstatic inline struct kcs_bmc_ipmi *to_kcs_bmc(struct file *filp)\n{\n\treturn container_of(filp->private_data, struct kcs_bmc_ipmi, miscdev);\n}\n\nstatic int kcs_bmc_ipmi_open(struct inode *inode, struct file *filp)\n{\n\tstruct kcs_bmc_ipmi *priv = to_kcs_bmc(filp);\n\n\treturn kcs_bmc_enable_device(priv->client.dev, &priv->client);\n}\n\nstatic __poll_t kcs_bmc_ipmi_poll(struct file *filp, poll_table *wait)\n{\n\tstruct kcs_bmc_ipmi *priv = to_kcs_bmc(filp);\n\t__poll_t mask = 0;\n\n\tpoll_wait(filp, &priv->queue, wait);\n\n\tspin_lock_irq(&priv->lock);\n\tif (priv->data_in_avail)\n\t\tmask |= EPOLLIN;\n\tspin_unlock_irq(&priv->lock);\n\n\treturn mask;\n}\n\nstatic ssize_t kcs_bmc_ipmi_read(struct file *filp, char __user *buf,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct kcs_bmc_ipmi *priv = to_kcs_bmc(filp);\n\tbool data_avail;\n\tsize_t data_len;\n\tssize_t ret;\n\n\tif (!(filp->f_flags & O_NONBLOCK))\n\t\twait_event_interruptible(priv->queue,\n\t\t\t\t\t priv->data_in_avail);\n\n\tmutex_lock(&priv->mutex);\n\n\tspin_lock_irq(&priv->lock);\n\tdata_avail = priv->data_in_avail;\n\tif (data_avail) {\n\t\tdata_len = priv->data_in_idx;\n\t\tmemcpy(priv->kbuffer, priv->data_in, data_len);\n\t}\n\tspin_unlock_irq(&priv->lock);\n\n\tif (!data_avail) {\n\t\tret = -EAGAIN;\n\t\tgoto out_unlock;\n\t}\n\n\tif (count < data_len) {\n\t\tpr_err(\"channel=%u with too large data : %zu\\n\",\n\t\t\tpriv->client.dev->channel, data_len);\n\n\t\tspin_lock_irq(&priv->lock);\n\t\tkcs_bmc_ipmi_force_abort(priv);\n\t\tspin_unlock_irq(&priv->lock);\n\n\t\tret = -EOVERFLOW;\n\t\tgoto out_unlock;\n\t}\n\n\tif (copy_to_user(buf, priv->kbuffer, data_len)) {\n\t\tret = -EFAULT;\n\t\tgoto out_unlock;\n\t}\n\n\tret = data_len;\n\n\tspin_lock_irq(&priv->lock);\n\tif (priv->phase == KCS_PHASE_WRITE_DONE) {\n\t\tpriv->phase = KCS_PHASE_WAIT_READ;\n\t\tpriv->data_in_avail = false;\n\t\tpriv->data_in_idx = 0;\n\t} else {\n\t\tret = -EAGAIN;\n\t}\n\tspin_unlock_irq(&priv->lock);\n\nout_unlock:\n\tmutex_unlock(&priv->mutex);\n\n\treturn ret;\n}\n\nstatic ssize_t kcs_bmc_ipmi_write(struct file *filp, const char __user *buf,\n\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct kcs_bmc_ipmi *priv = to_kcs_bmc(filp);\n\tssize_t ret;\n\n\t \n\tif (count < 3 || count > KCS_MSG_BUFSIZ)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&priv->mutex);\n\n\tif (copy_from_user(priv->kbuffer, buf, count)) {\n\t\tret = -EFAULT;\n\t\tgoto out_unlock;\n\t}\n\n\tspin_lock_irq(&priv->lock);\n\tif (priv->phase == KCS_PHASE_WAIT_READ) {\n\t\tpriv->phase = KCS_PHASE_READ;\n\t\tpriv->data_out_idx = 1;\n\t\tpriv->data_out_len = count;\n\t\tmemcpy(priv->data_out, priv->kbuffer, count);\n\t\tkcs_bmc_write_data(priv->client.dev, priv->data_out[0]);\n\t\tret = count;\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\tspin_unlock_irq(&priv->lock);\n\nout_unlock:\n\tmutex_unlock(&priv->mutex);\n\n\treturn ret;\n}\n\nstatic long kcs_bmc_ipmi_ioctl(struct file *filp, unsigned int cmd,\n\t\t\t  unsigned long arg)\n{\n\tstruct kcs_bmc_ipmi *priv = to_kcs_bmc(filp);\n\tlong ret = 0;\n\n\tspin_lock_irq(&priv->lock);\n\n\tswitch (cmd) {\n\tcase IPMI_BMC_IOCTL_SET_SMS_ATN:\n\t\tkcs_bmc_update_status(priv->client.dev, KCS_STATUS_SMS_ATN, KCS_STATUS_SMS_ATN);\n\t\tbreak;\n\n\tcase IPMI_BMC_IOCTL_CLEAR_SMS_ATN:\n\t\tkcs_bmc_update_status(priv->client.dev, KCS_STATUS_SMS_ATN, 0);\n\t\tbreak;\n\n\tcase IPMI_BMC_IOCTL_FORCE_ABORT:\n\t\tkcs_bmc_ipmi_force_abort(priv);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tspin_unlock_irq(&priv->lock);\n\n\treturn ret;\n}\n\nstatic int kcs_bmc_ipmi_release(struct inode *inode, struct file *filp)\n{\n\tstruct kcs_bmc_ipmi *priv = to_kcs_bmc(filp);\n\n\tkcs_bmc_ipmi_force_abort(priv);\n\tkcs_bmc_disable_device(priv->client.dev, &priv->client);\n\n\treturn 0;\n}\n\nstatic const struct file_operations kcs_bmc_ipmi_fops = {\n\t.owner          = THIS_MODULE,\n\t.open           = kcs_bmc_ipmi_open,\n\t.read           = kcs_bmc_ipmi_read,\n\t.write          = kcs_bmc_ipmi_write,\n\t.release        = kcs_bmc_ipmi_release,\n\t.poll           = kcs_bmc_ipmi_poll,\n\t.unlocked_ioctl = kcs_bmc_ipmi_ioctl,\n};\n\nstatic DEFINE_SPINLOCK(kcs_bmc_ipmi_instances_lock);\nstatic LIST_HEAD(kcs_bmc_ipmi_instances);\n\nstatic int kcs_bmc_ipmi_add_device(struct kcs_bmc_device *kcs_bmc)\n{\n\tstruct kcs_bmc_ipmi *priv;\n\tint rc;\n\n\tpriv = devm_kzalloc(kcs_bmc->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&priv->lock);\n\tmutex_init(&priv->mutex);\n\n\tinit_waitqueue_head(&priv->queue);\n\n\tpriv->client.dev = kcs_bmc;\n\tpriv->client.ops = &kcs_bmc_ipmi_client_ops;\n\tpriv->data_in = devm_kmalloc(kcs_bmc->dev, KCS_MSG_BUFSIZ, GFP_KERNEL);\n\tpriv->data_out = devm_kmalloc(kcs_bmc->dev, KCS_MSG_BUFSIZ, GFP_KERNEL);\n\tpriv->kbuffer = devm_kmalloc(kcs_bmc->dev, KCS_MSG_BUFSIZ, GFP_KERNEL);\n\n\tpriv->miscdev.minor = MISC_DYNAMIC_MINOR;\n\tpriv->miscdev.name = devm_kasprintf(kcs_bmc->dev, GFP_KERNEL, \"%s%u\", DEVICE_NAME,\n\t\t\t\t\t   kcs_bmc->channel);\n\tif (!priv->data_in || !priv->data_out || !priv->kbuffer || !priv->miscdev.name)\n\t\treturn -EINVAL;\n\n\tpriv->miscdev.fops = &kcs_bmc_ipmi_fops;\n\n\trc = misc_register(&priv->miscdev);\n\tif (rc) {\n\t\tdev_err(kcs_bmc->dev, \"Unable to register device: %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tspin_lock_irq(&kcs_bmc_ipmi_instances_lock);\n\tlist_add(&priv->entry, &kcs_bmc_ipmi_instances);\n\tspin_unlock_irq(&kcs_bmc_ipmi_instances_lock);\n\n\tdev_info(kcs_bmc->dev, \"Initialised IPMI client for channel %d\", kcs_bmc->channel);\n\n\treturn 0;\n}\n\nstatic int kcs_bmc_ipmi_remove_device(struct kcs_bmc_device *kcs_bmc)\n{\n\tstruct kcs_bmc_ipmi *priv = NULL, *pos;\n\n\tspin_lock_irq(&kcs_bmc_ipmi_instances_lock);\n\tlist_for_each_entry(pos, &kcs_bmc_ipmi_instances, entry) {\n\t\tif (pos->client.dev == kcs_bmc) {\n\t\t\tpriv = pos;\n\t\t\tlist_del(&pos->entry);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irq(&kcs_bmc_ipmi_instances_lock);\n\n\tif (!priv)\n\t\treturn -ENODEV;\n\n\tmisc_deregister(&priv->miscdev);\n\tkcs_bmc_disable_device(priv->client.dev, &priv->client);\n\tdevm_kfree(kcs_bmc->dev, priv->kbuffer);\n\tdevm_kfree(kcs_bmc->dev, priv->data_out);\n\tdevm_kfree(kcs_bmc->dev, priv->data_in);\n\tdevm_kfree(kcs_bmc->dev, priv);\n\n\treturn 0;\n}\n\nstatic const struct kcs_bmc_driver_ops kcs_bmc_ipmi_driver_ops = {\n\t.add_device = kcs_bmc_ipmi_add_device,\n\t.remove_device = kcs_bmc_ipmi_remove_device,\n};\n\nstatic struct kcs_bmc_driver kcs_bmc_ipmi_driver = {\n\t.ops = &kcs_bmc_ipmi_driver_ops,\n};\n\nstatic int __init kcs_bmc_ipmi_init(void)\n{\n\tkcs_bmc_register_driver(&kcs_bmc_ipmi_driver);\n\n\treturn 0;\n}\nmodule_init(kcs_bmc_ipmi_init);\n\nstatic void __exit kcs_bmc_ipmi_exit(void)\n{\n\tkcs_bmc_unregister_driver(&kcs_bmc_ipmi_driver);\n}\nmodule_exit(kcs_bmc_ipmi_exit);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Haiyue Wang <haiyue.wang@linux.intel.com>\");\nMODULE_AUTHOR(\"Andrew Jeffery <andrew@aj.id.au>\");\nMODULE_DESCRIPTION(\"KCS BMC to handle the IPMI request from system software\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}