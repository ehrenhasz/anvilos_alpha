{
  "module_name": "ssif_bmc.c",
  "hash_id": "84a168a117f22177f112ef6666b4cd792759df1186ed37e6b3a2fb2e3a475e8c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/ipmi/ssif_bmc.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/miscdevice.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/poll.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/timer.h>\n#include <linux/jiffies.h>\n#include <linux/ipmi_ssif_bmc.h>\n\n#define DEVICE_NAME                             \"ipmi-ssif-host\"\n\n#define GET_8BIT_ADDR(addr_7bit)                (((addr_7bit) << 1) & 0xff)\n\n \n#define MAX_PAYLOAD_PER_TRANSACTION             32\n \n#define MAX_TRANSACTION                         (MAX_PAYLOAD_PER_TRANSACTION + 4)\n\n#define MAX_IPMI_DATA_PER_START_TRANSACTION     30\n#define MAX_IPMI_DATA_PER_MIDDLE_TRANSACTION    31\n\n#define SSIF_IPMI_SINGLEPART_WRITE              0x2\n#define SSIF_IPMI_SINGLEPART_READ               0x3\n#define SSIF_IPMI_MULTIPART_WRITE_START         0x6\n#define SSIF_IPMI_MULTIPART_WRITE_MIDDLE        0x7\n#define SSIF_IPMI_MULTIPART_WRITE_END           0x8\n#define SSIF_IPMI_MULTIPART_READ_START          0x3\n#define SSIF_IPMI_MULTIPART_READ_MIDDLE         0x9\n\n \n#define RESPONSE_TIMEOUT                        500  \n\nstruct ssif_part_buffer {\n\tu8 address;\n\tu8 smbus_cmd;\n\tu8 length;\n\tu8 payload[MAX_PAYLOAD_PER_TRANSACTION];\n\tu8 pec;\n\tu8 index;\n};\n\n \nenum ssif_state {\n\tSSIF_READY,\n\tSSIF_START,\n\tSSIF_SMBUS_CMD,\n\tSSIF_REQ_RECVING,\n\tSSIF_RES_SENDING,\n\tSSIF_ABORTING,\n\tSSIF_STATE_MAX\n};\n\nstruct ssif_bmc_ctx {\n\tstruct i2c_client       *client;\n\tstruct miscdevice       miscdev;\n\tint                     msg_idx;\n\tbool                    pec_support;\n\t \n\tspinlock_t              lock;\n\twait_queue_head_t       wait_queue;\n\tu8                      running;\n\tenum ssif_state         state;\n\t \n\tstruct timer_list       response_timer;\n\tbool                    response_timer_inited;\n\t \n\tbool                    is_singlepart_read;\n\tu8                      nbytes_processed;\n\tu8                      remain_len;\n\tu8                      recv_len;\n\t \n\tu8                      block_num;\n\tbool                    request_available;\n\tbool                    response_in_progress;\n\tbool                    busy;\n\tbool                    aborting;\n\t \n\tstruct ssif_part_buffer part_buf;\n\tstruct ipmi_ssif_msg    response;\n\tstruct ipmi_ssif_msg    request;\n};\n\nstatic inline struct ssif_bmc_ctx *to_ssif_bmc(struct file *file)\n{\n\treturn container_of(file->private_data, struct ssif_bmc_ctx, miscdev);\n}\n\nstatic const char *state_to_string(enum ssif_state state)\n{\n\tswitch (state) {\n\tcase SSIF_READY:\n\t\treturn \"SSIF_READY\";\n\tcase SSIF_START:\n\t\treturn \"SSIF_START\";\n\tcase SSIF_SMBUS_CMD:\n\t\treturn \"SSIF_SMBUS_CMD\";\n\tcase SSIF_REQ_RECVING:\n\t\treturn \"SSIF_REQ_RECVING\";\n\tcase SSIF_RES_SENDING:\n\t\treturn \"SSIF_RES_SENDING\";\n\tcase SSIF_ABORTING:\n\t\treturn \"SSIF_ABORTING\";\n\tdefault:\n\t\treturn \"SSIF_STATE_UNKNOWN\";\n\t}\n}\n\n \nstatic ssize_t ssif_bmc_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct ssif_bmc_ctx *ssif_bmc = to_ssif_bmc(file);\n\tstruct ipmi_ssif_msg msg;\n\tunsigned long flags;\n\tssize_t ret;\n\n\tspin_lock_irqsave(&ssif_bmc->lock, flags);\n\twhile (!ssif_bmc->request_available) {\n\t\tspin_unlock_irqrestore(&ssif_bmc->lock, flags);\n\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\t\tret = wait_event_interruptible(ssif_bmc->wait_queue,\n\t\t\t\t\t       ssif_bmc->request_available);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tspin_lock_irqsave(&ssif_bmc->lock, flags);\n\t}\n\n\tif (count < min_t(ssize_t,\n\t\t\t  sizeof_field(struct ipmi_ssif_msg, len) + ssif_bmc->request.len,\n\t\t\t  sizeof(struct ipmi_ssif_msg))) {\n\t\tspin_unlock_irqrestore(&ssif_bmc->lock, flags);\n\t\tret = -EINVAL;\n\t} else {\n\t\tcount = min_t(ssize_t,\n\t\t\t      sizeof_field(struct ipmi_ssif_msg, len) + ssif_bmc->request.len,\n\t\t\t      sizeof(struct ipmi_ssif_msg));\n\t\tmemcpy(&msg, &ssif_bmc->request, count);\n\t\tssif_bmc->request_available = false;\n\t\tspin_unlock_irqrestore(&ssif_bmc->lock, flags);\n\n\t\tret = copy_to_user(buf, &msg, count);\n\t}\n\n\treturn (ret < 0) ? ret : count;\n}\n\n \nstatic ssize_t ssif_bmc_write(struct file *file, const char __user *buf, size_t count,\n\t\t\t      loff_t *ppos)\n{\n\tstruct ssif_bmc_ctx *ssif_bmc = to_ssif_bmc(file);\n\tstruct ipmi_ssif_msg msg;\n\tunsigned long flags;\n\tssize_t ret;\n\n\tif (count > sizeof(struct ipmi_ssif_msg))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&msg, buf, count))\n\t\treturn -EFAULT;\n\n\tif (!msg.len || count < sizeof_field(struct ipmi_ssif_msg, len) + msg.len)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&ssif_bmc->lock, flags);\n\twhile (ssif_bmc->response_in_progress) {\n\t\tspin_unlock_irqrestore(&ssif_bmc->lock, flags);\n\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\t\tret = wait_event_interruptible(ssif_bmc->wait_queue,\n\t\t\t\t\t       !ssif_bmc->response_in_progress);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tspin_lock_irqsave(&ssif_bmc->lock, flags);\n\t}\n\n\t \n\tret = (ssif_bmc->response_timer_inited) ? 0 : -EINVAL;\n\tif (ret)\n\t\tgoto exit;\n\n\tdel_timer(&ssif_bmc->response_timer);\n\tssif_bmc->response_timer_inited = false;\n\n\tmemcpy(&ssif_bmc->response, &msg, count);\n\tssif_bmc->is_singlepart_read = (msg.len <= MAX_PAYLOAD_PER_TRANSACTION);\n\n\tssif_bmc->response_in_progress = true;\n\n\t \n\tssif_bmc->busy = false;\n\n\t \n\tmemset(&ssif_bmc->request, 0, sizeof(struct ipmi_ssif_msg));\nexit:\n\tspin_unlock_irqrestore(&ssif_bmc->lock, flags);\n\n\treturn (ret < 0) ? ret : count;\n}\n\nstatic int ssif_bmc_open(struct inode *inode, struct file *file)\n{\n\tstruct ssif_bmc_ctx *ssif_bmc = to_ssif_bmc(file);\n\tint ret = 0;\n\n\tspin_lock_irq(&ssif_bmc->lock);\n\tif (!ssif_bmc->running)\n\t\tssif_bmc->running = 1;\n\telse\n\t\tret = -EBUSY;\n\tspin_unlock_irq(&ssif_bmc->lock);\n\n\treturn ret;\n}\n\nstatic __poll_t ssif_bmc_poll(struct file *file, poll_table *wait)\n{\n\tstruct ssif_bmc_ctx *ssif_bmc = to_ssif_bmc(file);\n\t__poll_t mask = 0;\n\n\tpoll_wait(file, &ssif_bmc->wait_queue, wait);\n\n\tspin_lock_irq(&ssif_bmc->lock);\n\t \n\tif (ssif_bmc->request_available)\n\t\tmask |= EPOLLIN;\n\n\tspin_unlock_irq(&ssif_bmc->lock);\n\n\treturn mask;\n}\n\nstatic int ssif_bmc_release(struct inode *inode, struct file *file)\n{\n\tstruct ssif_bmc_ctx *ssif_bmc = to_ssif_bmc(file);\n\n\tspin_lock_irq(&ssif_bmc->lock);\n\tssif_bmc->running = 0;\n\tspin_unlock_irq(&ssif_bmc->lock);\n\n\treturn 0;\n}\n\n \nstatic const struct file_operations ssif_bmc_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= ssif_bmc_open,\n\t.read\t\t= ssif_bmc_read,\n\t.write\t\t= ssif_bmc_write,\n\t.release\t= ssif_bmc_release,\n\t.poll\t\t= ssif_bmc_poll,\n};\n\n \nstatic void complete_response(struct ssif_bmc_ctx *ssif_bmc)\n{\n\t \n\tssif_bmc->response.len = 0;\n\tssif_bmc->response_in_progress = false;\n\tssif_bmc->nbytes_processed = 0;\n\tssif_bmc->remain_len = 0;\n\tssif_bmc->busy = false;\n\tmemset(&ssif_bmc->part_buf, 0, sizeof(struct ssif_part_buffer));\n\twake_up_all(&ssif_bmc->wait_queue);\n}\n\nstatic void response_timeout(struct timer_list *t)\n{\n\tstruct ssif_bmc_ctx *ssif_bmc = from_timer(ssif_bmc, t, response_timer);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ssif_bmc->lock, flags);\n\n\t \n\tif (!ssif_bmc->response_in_progress) {\n\t\t \n\t\tssif_bmc->busy = false;\n\t\tssif_bmc->response_timer_inited = false;\n\t\t \n\t\tssif_bmc->aborting = true;\n\t}\n\n\tspin_unlock_irqrestore(&ssif_bmc->lock, flags);\n}\n\n \nstatic void handle_request(struct ssif_bmc_ctx *ssif_bmc)\n{\n\t \n\tssif_bmc->busy = true;\n\t \n\tssif_bmc->request_available = true;\n\t \n\tmemset(&ssif_bmc->response, 0, sizeof(struct ipmi_ssif_msg));\n\t \n\twake_up_all(&ssif_bmc->wait_queue);\n\n\t \n\tif (!ssif_bmc->response_timer_inited) {\n\t\ttimer_setup(&ssif_bmc->response_timer, response_timeout, 0);\n\t\tssif_bmc->response_timer_inited = true;\n\t}\n\tmod_timer(&ssif_bmc->response_timer, jiffies + msecs_to_jiffies(RESPONSE_TIMEOUT));\n}\n\nstatic void calculate_response_part_pec(struct ssif_part_buffer *part)\n{\n\tu8 addr = part->address;\n\n\t \n\tpart->pec = i2c_smbus_pec(0, &addr, 1);\n\t \n\tpart->pec = i2c_smbus_pec(part->pec, &part->smbus_cmd, 1);\n\t \n\taddr = addr | 0x01;\n\tpart->pec = i2c_smbus_pec(part->pec, &addr, 1);\n\tpart->pec = i2c_smbus_pec(part->pec, &part->length, 1);\n\tif (part->length)\n\t\tpart->pec = i2c_smbus_pec(part->pec, part->payload, part->length);\n}\n\nstatic void set_singlepart_response_buffer(struct ssif_bmc_ctx *ssif_bmc)\n{\n\tstruct ssif_part_buffer *part = &ssif_bmc->part_buf;\n\n\tpart->address = GET_8BIT_ADDR(ssif_bmc->client->addr);\n\tpart->length = (u8)ssif_bmc->response.len;\n\n\t \n\tmemset(part->payload + part->length, 0, MAX_PAYLOAD_PER_TRANSACTION - part->length);\n\tmemcpy(&part->payload[0], &ssif_bmc->response.payload[0], part->length);\n}\n\nstatic void set_multipart_response_buffer(struct ssif_bmc_ctx *ssif_bmc)\n{\n\tstruct ssif_part_buffer *part = &ssif_bmc->part_buf;\n\tu8 part_len = 0;\n\n\tpart->address = GET_8BIT_ADDR(ssif_bmc->client->addr);\n\tswitch (part->smbus_cmd) {\n\tcase SSIF_IPMI_MULTIPART_READ_START:\n\t\t \n\t\tssif_bmc->nbytes_processed = 0;\n\t\tssif_bmc->block_num = 0;\n\t\tpart->length = MAX_PAYLOAD_PER_TRANSACTION;\n\t\tpart_len = MAX_IPMI_DATA_PER_START_TRANSACTION;\n\t\tssif_bmc->remain_len = ssif_bmc->response.len - part_len;\n\n\t\tpart->payload[0] = 0x00;  \n\t\tpart->payload[1] = 0x01;  \n\n\t\tmemcpy(&part->payload[2], &ssif_bmc->response.payload[0], part_len);\n\t\tbreak;\n\n\tcase SSIF_IPMI_MULTIPART_READ_MIDDLE:\n\t\t \n\t\tif (ssif_bmc->remain_len <= MAX_IPMI_DATA_PER_MIDDLE_TRANSACTION) {\n\t\t\t \n\t\t\t \n\t\t\tmemset(&part->payload[0], 0, MAX_PAYLOAD_PER_TRANSACTION);\n\t\t\tpart->length = ssif_bmc->remain_len + 1;\n\t\t\tpart_len = ssif_bmc->remain_len;\n\t\t\tssif_bmc->block_num = 0xFF;\n\t\t\tpart->payload[0] = ssif_bmc->block_num;\n\t\t} else {\n\t\t\t \n\t\t\tpart->length = MAX_PAYLOAD_PER_TRANSACTION;\n\t\t\tpart_len = MAX_IPMI_DATA_PER_MIDDLE_TRANSACTION;\n\t\t\tpart->payload[0] = ssif_bmc->block_num;\n\t\t\tssif_bmc->block_num++;\n\t\t}\n\n\t\tssif_bmc->remain_len -= part_len;\n\t\tmemcpy(&part->payload[1], ssif_bmc->response.payload + ssif_bmc->nbytes_processed,\n\t\t       part_len);\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tdev_err(&ssif_bmc->client->dev, \"%s: Unexpected SMBus command 0x%x\\n\",\n\t\t\t__func__, part->smbus_cmd);\n\t\tbreak;\n\t}\n\n\tssif_bmc->nbytes_processed += part_len;\n}\n\nstatic bool supported_read_cmd(u8 cmd)\n{\n\tif (cmd == SSIF_IPMI_SINGLEPART_READ ||\n\t    cmd == SSIF_IPMI_MULTIPART_READ_START ||\n\t    cmd == SSIF_IPMI_MULTIPART_READ_MIDDLE)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool supported_write_cmd(u8 cmd)\n{\n\tif (cmd == SSIF_IPMI_SINGLEPART_WRITE ||\n\t    cmd == SSIF_IPMI_MULTIPART_WRITE_START ||\n\t    cmd == SSIF_IPMI_MULTIPART_WRITE_MIDDLE ||\n\t    cmd == SSIF_IPMI_MULTIPART_WRITE_END)\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic void handle_read_processed(struct ssif_bmc_ctx *ssif_bmc, u8 *val)\n{\n\tstruct ssif_part_buffer *part = &ssif_bmc->part_buf;\n\n\t \n\tif (part->index < part->length)\n\t\t*val = part->payload[part->index];\n\telse if (part->index == part->length && ssif_bmc->pec_support)\n\t\t*val = part->pec;\n\telse\n\t\t*val = 0;\n\n\tpart->index++;\n}\n\nstatic void handle_write_received(struct ssif_bmc_ctx *ssif_bmc, u8 *val)\n{\n\t \n\tif (ssif_bmc->msg_idx < 1  || ssif_bmc->msg_idx > MAX_TRANSACTION)\n\t\treturn;\n\n\tif (ssif_bmc->msg_idx == 1) {\n\t\tssif_bmc->part_buf.length = *val;\n\t\tssif_bmc->part_buf.index = 0;\n\t} else {\n\t\tssif_bmc->part_buf.payload[ssif_bmc->part_buf.index++] = *val;\n\t}\n\n\tssif_bmc->msg_idx++;\n}\n\nstatic bool validate_request_part(struct ssif_bmc_ctx *ssif_bmc)\n{\n\tstruct ssif_part_buffer *part = &ssif_bmc->part_buf;\n\tbool ret = true;\n\tu8 cpec;\n\tu8 addr;\n\n\tif (part->index == part->length) {\n\t\t \n\t\tssif_bmc->pec_support = false;\n\t\tret = true;\n\t\tgoto exit;\n\t}\n\n\tif (part->index != part->length + 1) {\n\t\tret = false;\n\t\tgoto exit;\n\t}\n\n\t \n\tssif_bmc->pec_support = true;\n\tpart->pec = part->payload[part->length];\n\taddr = GET_8BIT_ADDR(ssif_bmc->client->addr);\n\tcpec = i2c_smbus_pec(0, &addr, 1);\n\tcpec = i2c_smbus_pec(cpec, &part->smbus_cmd, 1);\n\tcpec = i2c_smbus_pec(cpec, &part->length, 1);\n\t \n\tif (part->length)\n\t\tcpec = i2c_smbus_pec(cpec, part->payload, part->length);\n\n\tif (cpec != part->pec)\n\t\tret = false;\n\nexit:\n\treturn ret;\n}\n\nstatic void process_request_part(struct ssif_bmc_ctx *ssif_bmc)\n{\n\tstruct ssif_part_buffer *part = &ssif_bmc->part_buf;\n\tunsigned int len;\n\n\tswitch (part->smbus_cmd) {\n\tcase SSIF_IPMI_SINGLEPART_WRITE:\n\t\t \n\t\tssif_bmc->request.len = part->length;\n\t\tmemcpy(ssif_bmc->request.payload, part->payload, part->length);\n\n\t\tbreak;\n\tcase SSIF_IPMI_MULTIPART_WRITE_START:\n\t\tssif_bmc->request.len = 0;\n\n\t\tfallthrough;\n\tcase SSIF_IPMI_MULTIPART_WRITE_MIDDLE:\n\tcase SSIF_IPMI_MULTIPART_WRITE_END:\n\t\tlen = ssif_bmc->request.len + part->length;\n\t\t \n\t\tif (len > IPMI_SSIF_PAYLOAD_MAX) {\n\t\t\tdev_warn(&ssif_bmc->client->dev,\n\t\t\t\t \"Warn: Request exceeded 254 bytes, aborting\");\n\t\t\t \n\t\t\tssif_bmc->aborting =  true;\n\t\t} else {\n\t\t\tmemcpy(ssif_bmc->request.payload + ssif_bmc->request.len,\n\t\t\t       part->payload, part->length);\n\t\t\tssif_bmc->request.len += part->length;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tdev_err(&ssif_bmc->client->dev, \"%s: Unexpected SMBus command 0x%x\\n\",\n\t\t\t__func__, part->smbus_cmd);\n\t\tbreak;\n\t}\n}\n\nstatic void process_smbus_cmd(struct ssif_bmc_ctx *ssif_bmc, u8 *val)\n{\n\t \n\tssif_bmc->part_buf.smbus_cmd = *val;\n\tssif_bmc->msg_idx = 1;\n\tmemset(&ssif_bmc->part_buf.payload[0], 0, MAX_PAYLOAD_PER_TRANSACTION);\n\n\tif (*val == SSIF_IPMI_SINGLEPART_WRITE || *val == SSIF_IPMI_MULTIPART_WRITE_START) {\n\t\t \n\t\tif (ssif_bmc->response_in_progress)\n\t\t\tcomplete_response(ssif_bmc);\n\n\t\t \n\t\tif (ssif_bmc->aborting)\n\t\t\tssif_bmc->aborting = false;\n\t}\n}\n\nstatic void on_read_requested_event(struct ssif_bmc_ctx *ssif_bmc, u8 *val)\n{\n\tif (ssif_bmc->state == SSIF_READY ||\n\t    ssif_bmc->state == SSIF_START ||\n\t    ssif_bmc->state == SSIF_REQ_RECVING ||\n\t    ssif_bmc->state == SSIF_RES_SENDING) {\n\t\tdev_warn(&ssif_bmc->client->dev,\n\t\t\t \"Warn: %s unexpected READ REQUESTED in state=%s\\n\",\n\t\t\t __func__, state_to_string(ssif_bmc->state));\n\t\tssif_bmc->state = SSIF_ABORTING;\n\t\t*val = 0;\n\t\treturn;\n\n\t} else if (ssif_bmc->state == SSIF_SMBUS_CMD) {\n\t\tif (!supported_read_cmd(ssif_bmc->part_buf.smbus_cmd)) {\n\t\t\tdev_warn(&ssif_bmc->client->dev, \"Warn: Unknown SMBus read command=0x%x\",\n\t\t\t\t ssif_bmc->part_buf.smbus_cmd);\n\t\t\tssif_bmc->aborting = true;\n\t\t}\n\n\t\tif (ssif_bmc->aborting)\n\t\t\tssif_bmc->state = SSIF_ABORTING;\n\t\telse\n\t\t\tssif_bmc->state = SSIF_RES_SENDING;\n\t}\n\n\tssif_bmc->msg_idx = 0;\n\n\t \n\tif (!ssif_bmc->response_in_progress || ssif_bmc->state == SSIF_ABORTING) {\n\t\t*val = 0;\n\t\treturn;\n\t}\n\n\tif (ssif_bmc->is_singlepart_read)\n\t\tset_singlepart_response_buffer(ssif_bmc);\n\telse\n\t\tset_multipart_response_buffer(ssif_bmc);\n\n\tcalculate_response_part_pec(&ssif_bmc->part_buf);\n\tssif_bmc->part_buf.index = 0;\n\t*val = ssif_bmc->part_buf.length;\n}\n\nstatic void on_read_processed_event(struct ssif_bmc_ctx *ssif_bmc, u8 *val)\n{\n\tif (ssif_bmc->state == SSIF_READY ||\n\t    ssif_bmc->state == SSIF_START ||\n\t    ssif_bmc->state == SSIF_REQ_RECVING ||\n\t    ssif_bmc->state == SSIF_SMBUS_CMD) {\n\t\tdev_warn(&ssif_bmc->client->dev,\n\t\t\t \"Warn: %s unexpected READ PROCESSED in state=%s\\n\",\n\t\t\t __func__, state_to_string(ssif_bmc->state));\n\t\tssif_bmc->state = SSIF_ABORTING;\n\t\t*val = 0;\n\t\treturn;\n\t}\n\n\t \n\tif (!ssif_bmc->response_in_progress || ssif_bmc->state == SSIF_ABORTING) {\n\t\t*val = 0;\n\t\treturn;\n\t}\n\n\thandle_read_processed(ssif_bmc, val);\n}\n\nstatic void on_write_requested_event(struct ssif_bmc_ctx *ssif_bmc, u8 *val)\n{\n\tif (ssif_bmc->state == SSIF_READY || ssif_bmc->state == SSIF_SMBUS_CMD) {\n\t\tssif_bmc->state = SSIF_START;\n\n\t} else if (ssif_bmc->state == SSIF_START ||\n\t\t   ssif_bmc->state == SSIF_REQ_RECVING ||\n\t\t   ssif_bmc->state == SSIF_RES_SENDING) {\n\t\tdev_warn(&ssif_bmc->client->dev,\n\t\t\t \"Warn: %s unexpected WRITE REQUEST in state=%s\\n\",\n\t\t\t __func__, state_to_string(ssif_bmc->state));\n\t\tssif_bmc->state = SSIF_ABORTING;\n\t\treturn;\n\t}\n\n\tssif_bmc->msg_idx = 0;\n\tssif_bmc->part_buf.address = *val;\n}\n\nstatic void on_write_received_event(struct ssif_bmc_ctx *ssif_bmc, u8 *val)\n{\n\tif (ssif_bmc->state == SSIF_READY ||\n\t    ssif_bmc->state == SSIF_RES_SENDING) {\n\t\tdev_warn(&ssif_bmc->client->dev,\n\t\t\t \"Warn: %s unexpected WRITE RECEIVED in state=%s\\n\",\n\t\t\t __func__, state_to_string(ssif_bmc->state));\n\t\tssif_bmc->state = SSIF_ABORTING;\n\n\t} else if (ssif_bmc->state == SSIF_START) {\n\t\tssif_bmc->state = SSIF_SMBUS_CMD;\n\n\t} else if (ssif_bmc->state == SSIF_SMBUS_CMD) {\n\t\tif (!supported_write_cmd(ssif_bmc->part_buf.smbus_cmd)) {\n\t\t\tdev_warn(&ssif_bmc->client->dev, \"Warn: Unknown SMBus write command=0x%x\",\n\t\t\t\t ssif_bmc->part_buf.smbus_cmd);\n\t\t\tssif_bmc->aborting = true;\n\t\t}\n\n\t\tif (ssif_bmc->aborting)\n\t\t\tssif_bmc->state = SSIF_ABORTING;\n\t\telse\n\t\t\tssif_bmc->state = SSIF_REQ_RECVING;\n\t}\n\n\t \n\tif (ssif_bmc->state == SSIF_REQ_RECVING)\n\t\thandle_write_received(ssif_bmc, val);\n\telse if (ssif_bmc->state == SSIF_SMBUS_CMD)\n\t\tprocess_smbus_cmd(ssif_bmc, val);\n}\n\nstatic void on_stop_event(struct ssif_bmc_ctx *ssif_bmc, u8 *val)\n{\n\tif (ssif_bmc->state == SSIF_READY ||\n\t    ssif_bmc->state == SSIF_START ||\n\t    ssif_bmc->state == SSIF_SMBUS_CMD ||\n\t    ssif_bmc->state == SSIF_ABORTING) {\n\t\tdev_warn(&ssif_bmc->client->dev,\n\t\t\t \"Warn: %s unexpected SLAVE STOP in state=%s\\n\",\n\t\t\t __func__, state_to_string(ssif_bmc->state));\n\t\tssif_bmc->state = SSIF_READY;\n\n\t} else if (ssif_bmc->state == SSIF_REQ_RECVING) {\n\t\tif (validate_request_part(ssif_bmc)) {\n\t\t\tprocess_request_part(ssif_bmc);\n\t\t\tif (ssif_bmc->part_buf.smbus_cmd == SSIF_IPMI_SINGLEPART_WRITE ||\n\t\t\t    ssif_bmc->part_buf.smbus_cmd == SSIF_IPMI_MULTIPART_WRITE_END)\n\t\t\t\thandle_request(ssif_bmc);\n\t\t\tssif_bmc->state = SSIF_READY;\n\t\t} else {\n\t\t\t \n\t\t\tdev_err(&ssif_bmc->client->dev, \"Error: invalid pec\\n\");\n\t\t\tssif_bmc->aborting = true;\n\t\t}\n\t} else if (ssif_bmc->state == SSIF_RES_SENDING) {\n\t\tif (ssif_bmc->is_singlepart_read || ssif_bmc->block_num == 0xFF)\n\t\t\t \n\t\t\tcomplete_response(ssif_bmc);\n\t\tssif_bmc->state = SSIF_READY;\n\t}\n\n\t \n\tssif_bmc->msg_idx = 0;\n}\n\n \nstatic int ssif_bmc_cb(struct i2c_client *client, enum i2c_slave_event event, u8 *val)\n{\n\tunsigned long flags;\n\tstruct ssif_bmc_ctx *ssif_bmc = i2c_get_clientdata(client);\n\tint ret = 0;\n\n\tspin_lock_irqsave(&ssif_bmc->lock, flags);\n\n\tswitch (event) {\n\tcase I2C_SLAVE_READ_REQUESTED:\n\t\ton_read_requested_event(ssif_bmc, val);\n\t\tbreak;\n\n\tcase I2C_SLAVE_WRITE_REQUESTED:\n\t\ton_write_requested_event(ssif_bmc, val);\n\t\tbreak;\n\n\tcase I2C_SLAVE_READ_PROCESSED:\n\t\ton_read_processed_event(ssif_bmc, val);\n\t\tbreak;\n\n\tcase I2C_SLAVE_WRITE_RECEIVED:\n\t\ton_write_received_event(ssif_bmc, val);\n\t\tbreak;\n\n\tcase I2C_SLAVE_STOP:\n\t\ton_stop_event(ssif_bmc, val);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_warn(&ssif_bmc->client->dev, \"Warn: Unknown i2c slave event\\n\");\n\t\tbreak;\n\t}\n\n\tif (!ssif_bmc->aborting && ssif_bmc->busy)\n\t\tret = -EBUSY;\n\n\tspin_unlock_irqrestore(&ssif_bmc->lock, flags);\n\n\treturn ret;\n}\n\nstatic int ssif_bmc_probe(struct i2c_client *client)\n{\n\tstruct ssif_bmc_ctx *ssif_bmc;\n\tint ret;\n\n\tssif_bmc = devm_kzalloc(&client->dev, sizeof(*ssif_bmc), GFP_KERNEL);\n\tif (!ssif_bmc)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&ssif_bmc->lock);\n\n\tinit_waitqueue_head(&ssif_bmc->wait_queue);\n\tssif_bmc->request_available = false;\n\tssif_bmc->response_in_progress = false;\n\tssif_bmc->busy = false;\n\tssif_bmc->response_timer_inited = false;\n\n\t \n\tssif_bmc->miscdev.minor = MISC_DYNAMIC_MINOR;\n\tssif_bmc->miscdev.name = DEVICE_NAME;\n\tssif_bmc->miscdev.fops = &ssif_bmc_fops;\n\tssif_bmc->miscdev.parent = &client->dev;\n\tret = misc_register(&ssif_bmc->miscdev);\n\tif (ret)\n\t\treturn ret;\n\n\tssif_bmc->client = client;\n\tssif_bmc->client->flags |= I2C_CLIENT_SLAVE;\n\n\t \n\ti2c_set_clientdata(client, ssif_bmc);\n\tret = i2c_slave_register(client, ssif_bmc_cb);\n\tif (ret)\n\t\tmisc_deregister(&ssif_bmc->miscdev);\n\n\treturn ret;\n}\n\nstatic void ssif_bmc_remove(struct i2c_client *client)\n{\n\tstruct ssif_bmc_ctx *ssif_bmc = i2c_get_clientdata(client);\n\n\ti2c_slave_unregister(client);\n\tmisc_deregister(&ssif_bmc->miscdev);\n}\n\nstatic const struct of_device_id ssif_bmc_match[] = {\n\t{ .compatible = \"ssif-bmc\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, ssif_bmc_match);\n\nstatic const struct i2c_device_id ssif_bmc_id[] = {\n\t{ DEVICE_NAME, 0 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(i2c, ssif_bmc_id);\n\nstatic struct i2c_driver ssif_bmc_driver = {\n\t.driver         = {\n\t\t.name           = DEVICE_NAME,\n\t\t.of_match_table = ssif_bmc_match,\n\t},\n\t.probe          = ssif_bmc_probe,\n\t.remove         = ssif_bmc_remove,\n\t.id_table       = ssif_bmc_id,\n};\n\nmodule_i2c_driver(ssif_bmc_driver);\n\nMODULE_AUTHOR(\"Quan Nguyen <quan@os.amperecomputing.com>\");\nMODULE_AUTHOR(\"Chuong Tran <chuong@os.amperecomputing.com>\");\nMODULE_DESCRIPTION(\"Linux device driver of the BMC IPMI SSIF interface.\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}