{
  "module_name": "ipmi_powernv.c",
  "hash_id": "b5294527a515250c77b561aaaa50aa0bd42923430c9b3bc3030fc40fa23ed28e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/ipmi/ipmi_powernv.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)        \"ipmi-powernv: \" fmt\n\n#include <linux/ipmi_smi.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/interrupt.h>\n\n#include <asm/opal.h>\n\n\nstruct ipmi_smi_powernv {\n\tu64\t\t\tinterface_id;\n\tstruct ipmi_smi\t\t*intf;\n\tunsigned int\t\tirq;\n\n\t \n\tspinlock_t\t\tmsg_lock;\n\tstruct ipmi_smi_msg\t*cur_msg;\n\tstruct opal_ipmi_msg\t*opal_msg;\n};\n\nstatic int ipmi_powernv_start_processing(void *send_info, struct ipmi_smi *intf)\n{\n\tstruct ipmi_smi_powernv *smi = send_info;\n\n\tsmi->intf = intf;\n\treturn 0;\n}\n\nstatic void send_error_reply(struct ipmi_smi_powernv *smi,\n\t\tstruct ipmi_smi_msg *msg, u8 completion_code)\n{\n\tmsg->rsp[0] = msg->data[0] | 0x4;\n\tmsg->rsp[1] = msg->data[1];\n\tmsg->rsp[2] = completion_code;\n\tmsg->rsp_size = 3;\n\tipmi_smi_msg_received(smi->intf, msg);\n}\n\nstatic void ipmi_powernv_send(void *send_info, struct ipmi_smi_msg *msg)\n{\n\tstruct ipmi_smi_powernv *smi = send_info;\n\tstruct opal_ipmi_msg *opal_msg;\n\tunsigned long flags;\n\tint comp, rc;\n\tsize_t size;\n\n\t \n\tif (msg->data_size > IPMI_MAX_MSG_LENGTH) {\n\t\tcomp = IPMI_REQ_LEN_EXCEEDED_ERR;\n\t\tgoto err;\n\t}\n\n\t \n\tif (msg->data_size < 2) {\n\t\tcomp = IPMI_REQ_LEN_INVALID_ERR;\n\t\tgoto err;\n\t}\n\n\tspin_lock_irqsave(&smi->msg_lock, flags);\n\n\tif (smi->cur_msg) {\n\t\tcomp = IPMI_NODE_BUSY_ERR;\n\t\tgoto err_unlock;\n\t}\n\n\t \n\topal_msg = smi->opal_msg;\n\topal_msg->version = OPAL_IPMI_MSG_FORMAT_VERSION_1;\n\topal_msg->netfn = msg->data[0];\n\topal_msg->cmd = msg->data[1];\n\tif (msg->data_size > 2)\n\t\tmemcpy(opal_msg->data, msg->data + 2, msg->data_size - 2);\n\n\t \n\tsize = sizeof(*opal_msg) + msg->data_size - 2;\n\n\tpr_devel(\"%s: opal_ipmi_send(0x%llx, %p, %ld)\\n\", __func__,\n\t\t\tsmi->interface_id, opal_msg, size);\n\trc = opal_ipmi_send(smi->interface_id, opal_msg, size);\n\tpr_devel(\"%s:  -> %d\\n\", __func__, rc);\n\n\tif (!rc) {\n\t\tsmi->cur_msg = msg;\n\t\tspin_unlock_irqrestore(&smi->msg_lock, flags);\n\t\treturn;\n\t}\n\n\tcomp = IPMI_ERR_UNSPECIFIED;\nerr_unlock:\n\tspin_unlock_irqrestore(&smi->msg_lock, flags);\nerr:\n\tsend_error_reply(smi, msg, comp);\n}\n\nstatic int ipmi_powernv_recv(struct ipmi_smi_powernv *smi)\n{\n\tstruct opal_ipmi_msg *opal_msg;\n\tstruct ipmi_smi_msg *msg;\n\tunsigned long flags;\n\tuint64_t size;\n\tint rc;\n\n\tpr_devel(\"%s: opal_ipmi_recv(%llx, msg, sz)\\n\", __func__,\n\t\t\tsmi->interface_id);\n\n\tspin_lock_irqsave(&smi->msg_lock, flags);\n\n\tif (!smi->cur_msg) {\n\t\tspin_unlock_irqrestore(&smi->msg_lock, flags);\n\t\tpr_warn(\"no current message?\\n\");\n\t\treturn 0;\n\t}\n\n\tmsg = smi->cur_msg;\n\topal_msg = smi->opal_msg;\n\n\tsize = cpu_to_be64(sizeof(*opal_msg) + IPMI_MAX_MSG_LENGTH);\n\n\trc = opal_ipmi_recv(smi->interface_id,\n\t\t\topal_msg,\n\t\t\t&size);\n\tsize = be64_to_cpu(size);\n\tpr_devel(\"%s:   -> %d (size %lld)\\n\", __func__,\n\t\t\trc, rc == 0 ? size : 0);\n\tif (rc) {\n\t\t \n\t\tif (rc == OPAL_EMPTY) {\n\t\t\tspin_unlock_irqrestore(&smi->msg_lock, flags);\n\t\t\treturn 0;\n\t\t}\n\n\t\tsmi->cur_msg = NULL;\n\t\tspin_unlock_irqrestore(&smi->msg_lock, flags);\n\t\tsend_error_reply(smi, msg, IPMI_ERR_UNSPECIFIED);\n\t\treturn 0;\n\t}\n\n\tif (size < sizeof(*opal_msg)) {\n\t\tspin_unlock_irqrestore(&smi->msg_lock, flags);\n\t\tpr_warn(\"unexpected IPMI message size %lld\\n\", size);\n\t\treturn 0;\n\t}\n\n\tif (opal_msg->version != OPAL_IPMI_MSG_FORMAT_VERSION_1) {\n\t\tspin_unlock_irqrestore(&smi->msg_lock, flags);\n\t\tpr_warn(\"unexpected IPMI message format (version %d)\\n\",\n\t\t\t\topal_msg->version);\n\t\treturn 0;\n\t}\n\n\tmsg->rsp[0] = opal_msg->netfn;\n\tmsg->rsp[1] = opal_msg->cmd;\n\tif (size > sizeof(*opal_msg))\n\t\tmemcpy(&msg->rsp[2], opal_msg->data, size - sizeof(*opal_msg));\n\tmsg->rsp_size = 2 + size - sizeof(*opal_msg);\n\n\tsmi->cur_msg = NULL;\n\tspin_unlock_irqrestore(&smi->msg_lock, flags);\n\tipmi_smi_msg_received(smi->intf, msg);\n\treturn 0;\n}\n\nstatic void ipmi_powernv_request_events(void *send_info)\n{\n}\n\nstatic void ipmi_powernv_set_run_to_completion(void *send_info,\n\t\tbool run_to_completion)\n{\n}\n\nstatic void ipmi_powernv_poll(void *send_info)\n{\n\tstruct ipmi_smi_powernv *smi = send_info;\n\n\tipmi_powernv_recv(smi);\n}\n\nstatic const struct ipmi_smi_handlers ipmi_powernv_smi_handlers = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.start_processing\t= ipmi_powernv_start_processing,\n\t.sender\t\t\t= ipmi_powernv_send,\n\t.request_events\t\t= ipmi_powernv_request_events,\n\t.set_run_to_completion\t= ipmi_powernv_set_run_to_completion,\n\t.poll\t\t\t= ipmi_powernv_poll,\n};\n\nstatic irqreturn_t ipmi_opal_event(int irq, void *data)\n{\n\tstruct ipmi_smi_powernv *smi = data;\n\n\tipmi_powernv_recv(smi);\n\treturn IRQ_HANDLED;\n}\n\nstatic int ipmi_powernv_probe(struct platform_device *pdev)\n{\n\tstruct ipmi_smi_powernv *ipmi;\n\tstruct device *dev;\n\tu32 prop;\n\tint rc;\n\n\tif (!pdev || !pdev->dev.of_node)\n\t\treturn -ENODEV;\n\n\tdev = &pdev->dev;\n\n\tipmi = devm_kzalloc(dev, sizeof(*ipmi), GFP_KERNEL);\n\tif (!ipmi)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&ipmi->msg_lock);\n\n\trc = of_property_read_u32(dev->of_node, \"ibm,ipmi-interface-id\",\n\t\t\t&prop);\n\tif (rc) {\n\t\tdev_warn(dev, \"No interface ID property\\n\");\n\t\tgoto err_free;\n\t}\n\tipmi->interface_id = prop;\n\n\trc = of_property_read_u32(dev->of_node, \"interrupts\", &prop);\n\tif (rc) {\n\t\tdev_warn(dev, \"No interrupts property\\n\");\n\t\tgoto err_free;\n\t}\n\n\tipmi->irq = irq_of_parse_and_map(dev->of_node, 0);\n\tif (!ipmi->irq) {\n\t\tdev_info(dev, \"Unable to map irq from device tree\\n\");\n\t\tipmi->irq = opal_event_request(prop);\n\t}\n\n\trc = request_irq(ipmi->irq, ipmi_opal_event, IRQ_TYPE_LEVEL_HIGH,\n\t\t\t \"opal-ipmi\", ipmi);\n\tif (rc) {\n\t\tdev_warn(dev, \"Unable to request irq\\n\");\n\t\tgoto err_dispose;\n\t}\n\n\tipmi->opal_msg = devm_kmalloc(dev,\n\t\t\tsizeof(*ipmi->opal_msg) + IPMI_MAX_MSG_LENGTH,\n\t\t\tGFP_KERNEL);\n\tif (!ipmi->opal_msg) {\n\t\trc = -ENOMEM;\n\t\tgoto err_unregister;\n\t}\n\n\trc = ipmi_register_smi(&ipmi_powernv_smi_handlers, ipmi, dev, 0);\n\tif (rc) {\n\t\tdev_warn(dev, \"IPMI SMI registration failed (%d)\\n\", rc);\n\t\tgoto err_free_msg;\n\t}\n\n\tdev_set_drvdata(dev, ipmi);\n\treturn 0;\n\nerr_free_msg:\n\tdevm_kfree(dev, ipmi->opal_msg);\nerr_unregister:\n\tfree_irq(ipmi->irq, ipmi);\nerr_dispose:\n\tirq_dispose_mapping(ipmi->irq);\nerr_free:\n\tdevm_kfree(dev, ipmi);\n\treturn rc;\n}\n\nstatic int ipmi_powernv_remove(struct platform_device *pdev)\n{\n\tstruct ipmi_smi_powernv *smi = dev_get_drvdata(&pdev->dev);\n\n\tipmi_unregister_smi(smi->intf);\n\tfree_irq(smi->irq, smi);\n\tirq_dispose_mapping(smi->irq);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id ipmi_powernv_match[] = {\n\t{ .compatible = \"ibm,opal-ipmi\" },\n\t{ },\n};\n\n\nstatic struct platform_driver powernv_ipmi_driver = {\n\t.driver = {\n\t\t.name\t\t= \"ipmi-powernv\",\n\t\t.of_match_table\t= ipmi_powernv_match,\n\t},\n\t.probe\t= ipmi_powernv_probe,\n\t.remove\t= ipmi_powernv_remove,\n};\n\n\nmodule_platform_driver(powernv_ipmi_driver);\n\nMODULE_DEVICE_TABLE(of, ipmi_powernv_match);\nMODULE_DESCRIPTION(\"powernv IPMI driver\");\nMODULE_AUTHOR(\"Jeremy Kerr <jk@ozlabs.org>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}