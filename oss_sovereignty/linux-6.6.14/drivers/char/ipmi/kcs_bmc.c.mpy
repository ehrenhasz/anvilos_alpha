{
  "module_name": "kcs_bmc.c",
  "hash_id": "f7f2a79a4c2a4ffecca682cbd1246a02d4bfa91c1dc55443ab7b54b35283c4e9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/ipmi/kcs_bmc.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n\n#include \"kcs_bmc.h\"\n\n \n#include \"kcs_bmc_device.h\"\n#include \"kcs_bmc_client.h\"\n\n \nstatic DEFINE_MUTEX(kcs_bmc_lock);\nstatic LIST_HEAD(kcs_bmc_devices);\nstatic LIST_HEAD(kcs_bmc_drivers);\n\n \n\nu8 kcs_bmc_read_data(struct kcs_bmc_device *kcs_bmc)\n{\n\treturn kcs_bmc->ops->io_inputb(kcs_bmc, kcs_bmc->ioreg.idr);\n}\nEXPORT_SYMBOL(kcs_bmc_read_data);\n\nvoid kcs_bmc_write_data(struct kcs_bmc_device *kcs_bmc, u8 data)\n{\n\tkcs_bmc->ops->io_outputb(kcs_bmc, kcs_bmc->ioreg.odr, data);\n}\nEXPORT_SYMBOL(kcs_bmc_write_data);\n\nu8 kcs_bmc_read_status(struct kcs_bmc_device *kcs_bmc)\n{\n\treturn kcs_bmc->ops->io_inputb(kcs_bmc, kcs_bmc->ioreg.str);\n}\nEXPORT_SYMBOL(kcs_bmc_read_status);\n\nvoid kcs_bmc_write_status(struct kcs_bmc_device *kcs_bmc, u8 data)\n{\n\tkcs_bmc->ops->io_outputb(kcs_bmc, kcs_bmc->ioreg.str, data);\n}\nEXPORT_SYMBOL(kcs_bmc_write_status);\n\nvoid kcs_bmc_update_status(struct kcs_bmc_device *kcs_bmc, u8 mask, u8 val)\n{\n\tkcs_bmc->ops->io_updateb(kcs_bmc, kcs_bmc->ioreg.str, mask, val);\n}\nEXPORT_SYMBOL(kcs_bmc_update_status);\n\nirqreturn_t kcs_bmc_handle_event(struct kcs_bmc_device *kcs_bmc)\n{\n\tstruct kcs_bmc_client *client;\n\tirqreturn_t rc = IRQ_NONE;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&kcs_bmc->lock, flags);\n\tclient = kcs_bmc->client;\n\tif (client)\n\t\trc = client->ops->event(client);\n\tspin_unlock_irqrestore(&kcs_bmc->lock, flags);\n\n\treturn rc;\n}\nEXPORT_SYMBOL(kcs_bmc_handle_event);\n\nint kcs_bmc_enable_device(struct kcs_bmc_device *kcs_bmc, struct kcs_bmc_client *client)\n{\n\tint rc;\n\n\tspin_lock_irq(&kcs_bmc->lock);\n\tif (kcs_bmc->client) {\n\t\trc = -EBUSY;\n\t} else {\n\t\tu8 mask = KCS_BMC_EVENT_TYPE_IBF;\n\n\t\tkcs_bmc->client = client;\n\t\tkcs_bmc_update_event_mask(kcs_bmc, mask, mask);\n\t\trc = 0;\n\t}\n\tspin_unlock_irq(&kcs_bmc->lock);\n\n\treturn rc;\n}\nEXPORT_SYMBOL(kcs_bmc_enable_device);\n\nvoid kcs_bmc_disable_device(struct kcs_bmc_device *kcs_bmc, struct kcs_bmc_client *client)\n{\n\tspin_lock_irq(&kcs_bmc->lock);\n\tif (client == kcs_bmc->client) {\n\t\tu8 mask = KCS_BMC_EVENT_TYPE_IBF | KCS_BMC_EVENT_TYPE_OBE;\n\n\t\tkcs_bmc_update_event_mask(kcs_bmc, mask, 0);\n\t\tkcs_bmc->client = NULL;\n\t}\n\tspin_unlock_irq(&kcs_bmc->lock);\n}\nEXPORT_SYMBOL(kcs_bmc_disable_device);\n\nint kcs_bmc_add_device(struct kcs_bmc_device *kcs_bmc)\n{\n\tstruct kcs_bmc_driver *drv;\n\tint error = 0;\n\tint rc;\n\n\tspin_lock_init(&kcs_bmc->lock);\n\tkcs_bmc->client = NULL;\n\n\tmutex_lock(&kcs_bmc_lock);\n\tlist_add(&kcs_bmc->entry, &kcs_bmc_devices);\n\tlist_for_each_entry(drv, &kcs_bmc_drivers, entry) {\n\t\trc = drv->ops->add_device(kcs_bmc);\n\t\tif (!rc)\n\t\t\tcontinue;\n\n\t\tdev_err(kcs_bmc->dev, \"Failed to add chardev for KCS channel %d: %d\",\n\t\t\tkcs_bmc->channel, rc);\n\t\terror = rc;\n\t}\n\tmutex_unlock(&kcs_bmc_lock);\n\n\treturn error;\n}\nEXPORT_SYMBOL(kcs_bmc_add_device);\n\nvoid kcs_bmc_remove_device(struct kcs_bmc_device *kcs_bmc)\n{\n\tstruct kcs_bmc_driver *drv;\n\tint rc;\n\n\tmutex_lock(&kcs_bmc_lock);\n\tlist_del(&kcs_bmc->entry);\n\tlist_for_each_entry(drv, &kcs_bmc_drivers, entry) {\n\t\trc = drv->ops->remove_device(kcs_bmc);\n\t\tif (rc)\n\t\t\tdev_err(kcs_bmc->dev, \"Failed to remove chardev for KCS channel %d: %d\",\n\t\t\t\tkcs_bmc->channel, rc);\n\t}\n\tmutex_unlock(&kcs_bmc_lock);\n}\nEXPORT_SYMBOL(kcs_bmc_remove_device);\n\nvoid kcs_bmc_register_driver(struct kcs_bmc_driver *drv)\n{\n\tstruct kcs_bmc_device *kcs_bmc;\n\tint rc;\n\n\tmutex_lock(&kcs_bmc_lock);\n\tlist_add(&drv->entry, &kcs_bmc_drivers);\n\tlist_for_each_entry(kcs_bmc, &kcs_bmc_devices, entry) {\n\t\trc = drv->ops->add_device(kcs_bmc);\n\t\tif (rc)\n\t\t\tdev_err(kcs_bmc->dev, \"Failed to add driver for KCS channel %d: %d\",\n\t\t\t\tkcs_bmc->channel, rc);\n\t}\n\tmutex_unlock(&kcs_bmc_lock);\n}\nEXPORT_SYMBOL(kcs_bmc_register_driver);\n\nvoid kcs_bmc_unregister_driver(struct kcs_bmc_driver *drv)\n{\n\tstruct kcs_bmc_device *kcs_bmc;\n\tint rc;\n\n\tmutex_lock(&kcs_bmc_lock);\n\tlist_del(&drv->entry);\n\tlist_for_each_entry(kcs_bmc, &kcs_bmc_devices, entry) {\n\t\trc = drv->ops->remove_device(kcs_bmc);\n\t\tif (rc)\n\t\t\tdev_err(kcs_bmc->dev, \"Failed to remove driver for KCS channel %d: %d\",\n\t\t\t\tkcs_bmc->channel, rc);\n\t}\n\tmutex_unlock(&kcs_bmc_lock);\n}\nEXPORT_SYMBOL(kcs_bmc_unregister_driver);\n\nvoid kcs_bmc_update_event_mask(struct kcs_bmc_device *kcs_bmc, u8 mask, u8 events)\n{\n\tkcs_bmc->ops->irq_mask_update(kcs_bmc, mask, events);\n}\nEXPORT_SYMBOL(kcs_bmc_update_event_mask);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Haiyue Wang <haiyue.wang@linux.intel.com>\");\nMODULE_AUTHOR(\"Andrew Jeffery <andrew@aj.id.au>\");\nMODULE_DESCRIPTION(\"KCS BMC to handle the IPMI request from system software\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}