{
  "module_name": "ipmi_si_hardcode.c",
  "hash_id": "be8017d630837e53ffa3a0aac0dd86a668357dbedb5e782aeef86bbf103467c2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/ipmi/ipmi_si_hardcode.c",
  "human_readable_source": "\n\n#define pr_fmt(fmt) \"ipmi_hardcode: \" fmt\n\n#include <linux/moduleparam.h>\n#include <linux/platform_device.h>\n#include \"ipmi_si.h\"\n#include \"ipmi_plat_data.h\"\n\n \n\n#define SI_MAX_PARMS 4\n\n#define MAX_SI_TYPE_STR 30\nstatic char          si_type_str[MAX_SI_TYPE_STR] __initdata;\nstatic unsigned long addrs[SI_MAX_PARMS];\nstatic unsigned int num_addrs;\nstatic unsigned int  ports[SI_MAX_PARMS];\nstatic unsigned int num_ports;\nstatic int           irqs[SI_MAX_PARMS] __initdata;\nstatic unsigned int num_irqs __initdata;\nstatic int           regspacings[SI_MAX_PARMS] __initdata;\nstatic unsigned int num_regspacings __initdata;\nstatic int           regsizes[SI_MAX_PARMS] __initdata;\nstatic unsigned int num_regsizes __initdata;\nstatic int           regshifts[SI_MAX_PARMS] __initdata;\nstatic unsigned int num_regshifts __initdata;\nstatic int slave_addrs[SI_MAX_PARMS] __initdata;\nstatic unsigned int num_slave_addrs __initdata;\n\nmodule_param_string(type, si_type_str, MAX_SI_TYPE_STR, 0);\nMODULE_PARM_DESC(type,\n\t\t \"Defines the type of each interface, each interface separated by commas.  The types are 'kcs', 'smic', and 'bt'.  For example si_type=kcs,bt will set the first interface to kcs and the second to bt\");\nmodule_param_hw_array(addrs, ulong, iomem, &num_addrs, 0);\nMODULE_PARM_DESC(addrs,\n\t\t \"Sets the memory address of each interface, the addresses separated by commas.  Only use if an interface is in memory.  Otherwise, set it to zero or leave it blank.\");\nmodule_param_hw_array(ports, uint, ioport, &num_ports, 0);\nMODULE_PARM_DESC(ports,\n\t\t \"Sets the port address of each interface, the addresses separated by commas.  Only use if an interface is a port.  Otherwise, set it to zero or leave it blank.\");\nmodule_param_hw_array(irqs, int, irq, &num_irqs, 0);\nMODULE_PARM_DESC(irqs,\n\t\t \"Sets the interrupt of each interface, the addresses separated by commas.  Only use if an interface has an interrupt.  Otherwise, set it to zero or leave it blank.\");\nmodule_param_hw_array(regspacings, int, other, &num_regspacings, 0);\nMODULE_PARM_DESC(regspacings,\n\t\t \"The number of bytes between the start address and each successive register used by the interface.  For instance, if the start address is 0xca2 and the spacing is 2, then the second address is at 0xca4.  Defaults to 1.\");\nmodule_param_hw_array(regsizes, int, other, &num_regsizes, 0);\nMODULE_PARM_DESC(regsizes,\n\t\t \"The size of the specific IPMI register in bytes. This should generally be 1, 2, 4, or 8 for an 8-bit, 16-bit, 32-bit, or 64-bit register.  Use this if you the 8-bit IPMI register has to be read from a larger register.\");\nmodule_param_hw_array(regshifts, int, other, &num_regshifts, 0);\nMODULE_PARM_DESC(regshifts,\n\t\t \"The amount to shift the data read from the. IPMI register, in bits.  For instance, if the data is read from a 32-bit word and the IPMI data is in bit 8-15, then the shift would be 8\");\nmodule_param_hw_array(slave_addrs, int, other, &num_slave_addrs, 0);\nMODULE_PARM_DESC(slave_addrs,\n\t\t \"Set the default IPMB slave address for the controller.  Normally this is 0x20, but can be overridden by this parm.  This is an array indexed by interface number.\");\n\nstatic void __init ipmi_hardcode_init_one(const char *si_type_str,\n\t\t\t\t\t  unsigned int i,\n\t\t\t\t\t  unsigned long addr,\n\t\t\t\t\t  enum ipmi_addr_space addr_space)\n{\n\tstruct ipmi_plat_data p;\n\tint t;\n\n\tmemset(&p, 0, sizeof(p));\n\n\tp.iftype = IPMI_PLAT_IF_SI;\n\tif (!si_type_str || !*si_type_str) {\n\t\tp.type = SI_KCS;\n\t} else {\n\t\tt = match_string(si_to_str, -1, si_type_str);\n\t\tif (t < 0) {\n\t\t\tpr_warn(\"Interface type specified for interface %d, was invalid: %s\\n\",\n\t\t\t\ti, si_type_str);\n\t\t\treturn;\n\t\t}\n\t\tp.type = t;\n\t}\n\n\tp.regsize = regsizes[i];\n\tp.slave_addr = slave_addrs[i];\n\tp.addr_source = SI_HARDCODED;\n\tp.regshift = regshifts[i];\n\tp.regsize = regsizes[i];\n\tp.addr = addr;\n\tp.space = addr_space;\n\n\tipmi_platform_add(\"hardcode-ipmi-si\", i, &p);\n}\n\nvoid __init ipmi_hardcode_init(void)\n{\n\tunsigned int i;\n\tchar *str;\n\tchar *si_type[SI_MAX_PARMS];\n\n\tmemset(si_type, 0, sizeof(si_type));\n\n\t \n\tstr = si_type_str;\n\tif (*str != '\\0') {\n\t\tfor (i = 0; (i < SI_MAX_PARMS) && (*str != '\\0'); i++) {\n\t\t\tsi_type[i] = str;\n\t\t\tstr = strchr(str, ',');\n\t\t\tif (str) {\n\t\t\t\t*str = '\\0';\n\t\t\t\tstr++;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < SI_MAX_PARMS; i++) {\n\t\tif (i < num_ports && ports[i])\n\t\t\tipmi_hardcode_init_one(si_type[i], i, ports[i],\n\t\t\t\t\t       IPMI_IO_ADDR_SPACE);\n\t\tif (i < num_addrs && addrs[i])\n\t\t\tipmi_hardcode_init_one(si_type[i], i, addrs[i],\n\t\t\t\t\t       IPMI_MEM_ADDR_SPACE);\n\t}\n}\n\n\nvoid ipmi_si_hardcode_exit(void)\n{\n\tipmi_remove_platform_device_by_name(\"hardcode-ipmi-si\");\n}\n\n \nint ipmi_si_hardcode_match(int addr_space, unsigned long addr)\n{\n\tunsigned int i;\n\n\tif (addr_space == IPMI_IO_ADDR_SPACE) {\n\t\tfor (i = 0; i < num_ports; i++) {\n\t\t\tif (ports[i] == addr)\n\t\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < num_addrs; i++) {\n\t\t\tif (addrs[i] == addr)\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}