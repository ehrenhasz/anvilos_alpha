{
  "module_name": "ipmi_si_mem_io.c",
  "hash_id": "c470060663b070a4590c877f5cc3f0630e53cc442ff6c2ac70144d24049041bc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/ipmi/ipmi_si_mem_io.c",
  "human_readable_source": "\n\n#include <linux/io.h>\n#include \"ipmi_si.h\"\n\nstatic unsigned char intf_mem_inb(const struct si_sm_io *io,\n\t\t\t\t  unsigned int offset)\n{\n\treturn readb((io->addr)+(offset * io->regspacing));\n}\n\nstatic void intf_mem_outb(const struct si_sm_io *io, unsigned int offset,\n\t\t\t  unsigned char b)\n{\n\twriteb(b, (io->addr)+(offset * io->regspacing));\n}\n\nstatic unsigned char intf_mem_inw(const struct si_sm_io *io,\n\t\t\t\t  unsigned int offset)\n{\n\treturn (readw((io->addr)+(offset * io->regspacing)) >> io->regshift)\n\t\t& 0xff;\n}\n\nstatic void intf_mem_outw(const struct si_sm_io *io, unsigned int offset,\n\t\t\t  unsigned char b)\n{\n\twriteb(b << io->regshift, (io->addr)+(offset * io->regspacing));\n}\n\nstatic unsigned char intf_mem_inl(const struct si_sm_io *io,\n\t\t\t\t  unsigned int offset)\n{\n\treturn (readl((io->addr)+(offset * io->regspacing)) >> io->regshift)\n\t\t& 0xff;\n}\n\nstatic void intf_mem_outl(const struct si_sm_io *io, unsigned int offset,\n\t\t\t  unsigned char b)\n{\n\twritel(b << io->regshift, (io->addr)+(offset * io->regspacing));\n}\n\n#ifdef readq\nstatic unsigned char mem_inq(const struct si_sm_io *io, unsigned int offset)\n{\n\treturn (readq((io->addr)+(offset * io->regspacing)) >> io->regshift)\n\t\t& 0xff;\n}\n\nstatic void mem_outq(const struct si_sm_io *io, unsigned int offset,\n\t\t     unsigned char b)\n{\n\twriteq((u64)b << io->regshift, (io->addr)+(offset * io->regspacing));\n}\n#endif\n\nstatic void mem_region_cleanup(struct si_sm_io *io, int num)\n{\n\tunsigned long addr = io->addr_data;\n\tint idx;\n\n\tfor (idx = 0; idx < num; idx++)\n\t\trelease_mem_region(addr + idx * io->regspacing,\n\t\t\t\t   io->regsize);\n}\n\nstatic void mem_cleanup(struct si_sm_io *io)\n{\n\tif (io->addr) {\n\t\tiounmap(io->addr);\n\t\tmem_region_cleanup(io, io->io_size);\n\t}\n}\n\nint ipmi_si_mem_setup(struct si_sm_io *io)\n{\n\tunsigned long addr = io->addr_data;\n\tint           mapsize, idx;\n\n\tif (!addr)\n\t\treturn -ENODEV;\n\n\t \n\tswitch (io->regsize) {\n\tcase 1:\n\t\tio->inputb = intf_mem_inb;\n\t\tio->outputb = intf_mem_outb;\n\t\tbreak;\n\tcase 2:\n\t\tio->inputb = intf_mem_inw;\n\t\tio->outputb = intf_mem_outw;\n\t\tbreak;\n\tcase 4:\n\t\tio->inputb = intf_mem_inl;\n\t\tio->outputb = intf_mem_outl;\n\t\tbreak;\n#ifdef readq\n\tcase 8:\n\t\tio->inputb = mem_inq;\n\t\tio->outputb = mem_outq;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tdev_warn(io->dev, \"Invalid register size: %d\\n\",\n\t\t\t io->regsize);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor (idx = 0; idx < io->io_size; idx++) {\n\t\tif (request_mem_region(addr + idx * io->regspacing,\n\t\t\t\t       io->regsize, SI_DEVICE_NAME) == NULL) {\n\t\t\t \n\t\t\tmem_region_cleanup(io, idx);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\t \n\tmapsize = ((io->io_size * io->regspacing)\n\t\t   - (io->regspacing - io->regsize));\n\tio->addr = ioremap(addr, mapsize);\n\tif (io->addr == NULL) {\n\t\tmem_region_cleanup(io, io->io_size);\n\t\treturn -EIO;\n\t}\n\n\tio->io_cleanup = mem_cleanup;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}