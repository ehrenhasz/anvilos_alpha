{
  "module_name": "ipmi_ipmb.c",
  "hash_id": "603fd73a1cad37955b3122f14853dc259e6d6961627dd155829236a58647236e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/ipmi/ipmi_ipmb.c",
  "human_readable_source": "\n\n \n\n#include <linux/acpi.h>\n#include <linux/errno.h>\n#include <linux/i2c.h>\n#include <linux/miscdevice.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/semaphore.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/ipmi_msgdefs.h>\n#include <linux/ipmi_smi.h>\n\n#define DEVICE_NAME \"ipmi-ipmb\"\n\nstatic int bmcaddr = 0x20;\nmodule_param(bmcaddr, int, 0644);\nMODULE_PARM_DESC(bmcaddr, \"Address to use for BMC.\");\n\nstatic unsigned int retry_time_ms = 250;\nmodule_param(retry_time_ms, uint, 0644);\nMODULE_PARM_DESC(retry_time_ms, \"Timeout time between retries, in milliseconds.\");\n\nstatic unsigned int max_retries = 1;\nmodule_param(max_retries, uint, 0644);\nMODULE_PARM_DESC(max_retries, \"Max resends of a command before timing out.\");\n\n \n#define IPMB_MAX_MSG_LEN (IPMI_MAX_MSG_LENGTH + 5)\n\nstruct ipmi_ipmb_dev {\n\tstruct ipmi_smi *intf;\n\tstruct i2c_client *client;\n\tstruct i2c_client *slave;\n\n\tstruct ipmi_smi_handlers handlers;\n\n\tbool ready;\n\n\tu8 curr_seq;\n\n\tu8 bmcaddr;\n\tu32 retry_time_ms;\n\tu32 max_retries;\n\n\tstruct ipmi_smi_msg *next_msg;\n\tstruct ipmi_smi_msg *working_msg;\n\n\t \n\tstruct task_struct *thread;\n\tstruct semaphore wake_thread;\n\tstruct semaphore got_rsp;\n\tspinlock_t lock;\n\tbool stopping;\n\n\tu8 xmitmsg[IPMB_MAX_MSG_LEN];\n\tunsigned int xmitlen;\n\n\tu8 rcvmsg[IPMB_MAX_MSG_LEN];\n\tunsigned int rcvlen;\n\tbool overrun;\n};\n\nstatic bool valid_ipmb(struct ipmi_ipmb_dev *iidev)\n{\n\tu8 *msg = iidev->rcvmsg;\n\tu8 netfn;\n\n\tif (iidev->overrun)\n\t\treturn false;\n\n\t \n\tif (iidev->rcvlen < 7)\n\t\treturn false;\n\n\t \n\tnetfn = msg[1] >> 2;\n\tif (netfn & 1) {\n\t\t \n\t\tif (iidev->rcvlen < 8)\n\t\t\treturn false;\n\t}\n\n\tif (ipmb_checksum(msg, 3) != 0)\n\t\treturn false;\n\tif (ipmb_checksum(msg + 3, iidev->rcvlen - 3) != 0)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void ipmi_ipmb_check_msg_done(struct ipmi_ipmb_dev *iidev)\n{\n\tstruct ipmi_smi_msg *imsg = NULL;\n\tu8 *msg = iidev->rcvmsg;\n\tbool is_cmd;\n\tunsigned long flags;\n\n\tif (iidev->rcvlen == 0)\n\t\treturn;\n\tif (!valid_ipmb(iidev))\n\t\tgoto done;\n\n\tis_cmd = ((msg[1] >> 2) & 1) == 0;\n\n\tif (is_cmd) {\n\t\t \n\t\tif (!iidev->ready)\n\t\t\tgoto done;\n\n\t\t \n\t\timsg = ipmi_alloc_smi_msg();\n\t\tif (!imsg)\n\t\t\tgoto done;\n\t\timsg->type = IPMI_SMI_MSG_TYPE_IPMB_DIRECT;\n\t\timsg->data_size = 0;\n\t} else {\n\t\tspin_lock_irqsave(&iidev->lock, flags);\n\t\tif (iidev->working_msg) {\n\t\t\tu8 seq = msg[4] >> 2;\n\t\t\tbool xmit_rsp = (iidev->working_msg->data[0] >> 2) & 1;\n\n\t\t\t \n\t\t\tif (!xmit_rsp && seq == iidev->curr_seq) {\n\t\t\t\tiidev->curr_seq = (iidev->curr_seq + 1) & 0x3f;\n\n\t\t\t\timsg = iidev->working_msg;\n\t\t\t\tiidev->working_msg = NULL;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&iidev->lock, flags);\n\t}\n\n\tif (!imsg)\n\t\tgoto done;\n\n\tif (imsg->type == IPMI_SMI_MSG_TYPE_IPMB_DIRECT) {\n\t\timsg->rsp[0] = msg[1];  \n\t\t \n\t\tmemcpy(imsg->rsp + 1, msg + 3, iidev->rcvlen - 4);\n\t\timsg->rsp_size = iidev->rcvlen - 3;\n\t} else {\n\t\timsg->rsp[0] = msg[1];  \n\t\t \n\t\tmemcpy(imsg->rsp + 1, msg + 5, iidev->rcvlen - 6);\n\t\timsg->rsp_size = iidev->rcvlen - 5;\n\t}\n\tipmi_smi_msg_received(iidev->intf, imsg);\n\tif (!is_cmd)\n\t\tup(&iidev->got_rsp);\n\ndone:\n\tiidev->overrun = false;\n\tiidev->rcvlen = 0;\n}\n\n \nstatic int ipmi_ipmb_slave_cb(struct i2c_client *client,\n\t\t\t      enum i2c_slave_event event, u8 *val)\n{\n\tstruct ipmi_ipmb_dev *iidev = i2c_get_clientdata(client);\n\n\tswitch (event) {\n\tcase I2C_SLAVE_WRITE_REQUESTED:\n\t\tipmi_ipmb_check_msg_done(iidev);\n\t\t \n\t\tiidev->rcvmsg[0] = client->addr << 1;\n\t\tiidev->rcvlen = 1;\n\t\tbreak;\n\n\tcase I2C_SLAVE_WRITE_RECEIVED:\n\t\tif (iidev->rcvlen >= sizeof(iidev->rcvmsg))\n\t\t\tiidev->overrun = true;\n\t\telse\n\t\t\tiidev->rcvmsg[iidev->rcvlen++] = *val;\n\t\tbreak;\n\n\tcase I2C_SLAVE_READ_REQUESTED:\n\tcase I2C_SLAVE_STOP:\n\t\tipmi_ipmb_check_msg_done(iidev);\n\t\tbreak;\n\n\tcase I2C_SLAVE_READ_PROCESSED:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void ipmi_ipmb_send_response(struct ipmi_ipmb_dev *iidev,\n\t\t\t\t    struct ipmi_smi_msg *msg, u8 cc)\n{\n\tif ((msg->data[0] >> 2) & 1) {\n\t\t \n\t\tmsg->data[0] = (IPMI_NETFN_APP_REQUEST | 1) << 2;\n\t\tmsg->data[3] = IPMI_SEND_MSG_CMD;\n\t\tmsg->data[4] = cc;\n\t\tmsg->data_size = 5;\n\t}\n\tmsg->rsp[0] = msg->data[0] | (1 << 2);\n\tif (msg->type == IPMI_SMI_MSG_TYPE_IPMB_DIRECT) {\n\t\tmsg->rsp[1] = msg->data[1];\n\t\tmsg->rsp[2] = msg->data[2];\n\t\tmsg->rsp[3] = msg->data[3];\n\t\tmsg->rsp[4] = cc;\n\t\tmsg->rsp_size = 5;\n\t} else {\n\t\tmsg->rsp[1] = msg->data[1];\n\t\tmsg->rsp[2] = cc;\n\t\tmsg->rsp_size = 3;\n\t}\n\tipmi_smi_msg_received(iidev->intf, msg);\n}\n\nstatic void ipmi_ipmb_format_for_xmit(struct ipmi_ipmb_dev *iidev,\n\t\t\t\t      struct ipmi_smi_msg *msg)\n{\n\tif (msg->type == IPMI_SMI_MSG_TYPE_IPMB_DIRECT) {\n\t\tiidev->xmitmsg[0] = msg->data[1];\n\t\tiidev->xmitmsg[1] = msg->data[0];\n\t\tmemcpy(iidev->xmitmsg + 4, msg->data + 2, msg->data_size - 2);\n\t\tiidev->xmitlen = msg->data_size + 2;\n\t} else {\n\t\tiidev->xmitmsg[0] = iidev->bmcaddr;\n\t\tiidev->xmitmsg[1] = msg->data[0];\n\t\tiidev->xmitmsg[4] = 0;\n\t\tmemcpy(iidev->xmitmsg + 5, msg->data + 1, msg->data_size - 1);\n\t\tiidev->xmitlen = msg->data_size + 4;\n\t}\n\tiidev->xmitmsg[3] = iidev->slave->addr << 1;\n\tif (((msg->data[0] >> 2) & 1) == 0)\n\t\t \n\t\tiidev->xmitmsg[4] = ((iidev->xmitmsg[4] & 0x03) |\n\t\t\t\t     (iidev->curr_seq << 2));\n\n\t \n\tiidev->xmitmsg[2] = ipmb_checksum(iidev->xmitmsg, 2);\n\tiidev->xmitmsg[iidev->xmitlen] =\n\t\tipmb_checksum(iidev->xmitmsg + 3, iidev->xmitlen - 3);\n\tiidev->xmitlen++;\n}\n\nstatic int ipmi_ipmb_thread(void *data)\n{\n\tstruct ipmi_ipmb_dev *iidev = data;\n\n\twhile (!kthread_should_stop()) {\n\t\tlong ret;\n\t\tstruct i2c_msg i2c_msg;\n\t\tstruct ipmi_smi_msg *msg = NULL;\n\t\tunsigned long flags;\n\t\tunsigned int retries = 0;\n\n\t\t \n\t\tret = down_interruptible(&iidev->wake_thread);\n\t\tif (iidev->stopping)\n\t\t\tbreak;\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\tspin_lock_irqsave(&iidev->lock, flags);\n\t\tif (iidev->next_msg) {\n\t\t\tmsg = iidev->next_msg;\n\t\t\tiidev->next_msg = NULL;\n\t\t}\n\t\tspin_unlock_irqrestore(&iidev->lock, flags);\n\t\tif (!msg)\n\t\t\tcontinue;\n\n\t\tipmi_ipmb_format_for_xmit(iidev, msg);\n\nretry:\n\t\ti2c_msg.len = iidev->xmitlen - 1;\n\t\tif (i2c_msg.len > 32) {\n\t\t\tipmi_ipmb_send_response(iidev, msg,\n\t\t\t\t\t\tIPMI_REQ_LEN_EXCEEDED_ERR);\n\t\t\tcontinue;\n\t\t}\n\n\t\ti2c_msg.addr = iidev->xmitmsg[0] >> 1;\n\t\ti2c_msg.flags = 0;\n\t\ti2c_msg.buf = iidev->xmitmsg + 1;\n\n\t\t \n\t\tiidev->working_msg = msg;\n\n\t\tret = i2c_transfer(iidev->client->adapter, &i2c_msg, 1);\n\n\t\tif ((msg->data[0] >> 2) & 1) {\n\t\t\t \n\n\t\t\tiidev->working_msg = NULL;\n\t\t\tipmi_ipmb_send_response(iidev, msg,\n\t\t\t\t\t\tret < 0 ? IPMI_BUS_ERR : 0);\n\t\t\tcontinue;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tiidev->working_msg = NULL;\n\t\t\tipmi_ipmb_send_response(iidev, msg, IPMI_BUS_ERR);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tret = down_timeout(&iidev->got_rsp,\n\t\t\t\t   msecs_to_jiffies(iidev->retry_time_ms));\n\n\t\t \n\t\tspin_lock_irqsave(&iidev->lock, flags);\n\t\tmsg = iidev->working_msg;\n\t\tiidev->working_msg = NULL;\n\t\tspin_unlock_irqrestore(&iidev->lock, flags);\n\n\t\tif (!msg && ret) {\n\t\t\t \n\t\t\tdown(&iidev->got_rsp);\n\t\t} else if (msg && ++retries <= iidev->max_retries) {\n\t\t\tspin_lock_irqsave(&iidev->lock, flags);\n\t\t\tiidev->working_msg = msg;\n\t\t\tspin_unlock_irqrestore(&iidev->lock, flags);\n\t\t\tgoto retry;\n\t\t}\n\n\t\tif (msg)\n\t\t\tipmi_ipmb_send_response(iidev, msg, IPMI_TIMEOUT_ERR);\n\t}\n\n\tif (iidev->next_msg)\n\t\t \n\t\tipmi_ipmb_send_response(iidev, iidev->next_msg, 0xff);\n\n\treturn 0;\n}\n\nstatic int ipmi_ipmb_start_processing(void *send_info,\n\t\t\t\t      struct ipmi_smi *new_intf)\n{\n\tstruct ipmi_ipmb_dev *iidev = send_info;\n\n\tiidev->intf = new_intf;\n\tiidev->ready = true;\n\treturn 0;\n}\n\nstatic void ipmi_ipmb_stop_thread(struct ipmi_ipmb_dev *iidev)\n{\n\tif (iidev->thread) {\n\t\tstruct task_struct *t = iidev->thread;\n\n\t\tiidev->thread = NULL;\n\t\tiidev->stopping = true;\n\t\tup(&iidev->wake_thread);\n\t\tup(&iidev->got_rsp);\n\t\tkthread_stop(t);\n\t}\n}\n\nstatic void ipmi_ipmb_shutdown(void *send_info)\n{\n\tstruct ipmi_ipmb_dev *iidev = send_info;\n\n\tipmi_ipmb_stop_thread(iidev);\n}\n\nstatic void ipmi_ipmb_sender(void *send_info,\n\t\t\t     struct ipmi_smi_msg *msg)\n{\n\tstruct ipmi_ipmb_dev *iidev = send_info;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&iidev->lock, flags);\n\tBUG_ON(iidev->next_msg);\n\n\tiidev->next_msg = msg;\n\tspin_unlock_irqrestore(&iidev->lock, flags);\n\n\tup(&iidev->wake_thread);\n}\n\nstatic void ipmi_ipmb_request_events(void *send_info)\n{\n\t \n}\n\nstatic void ipmi_ipmb_cleanup(struct ipmi_ipmb_dev *iidev)\n{\n\tif (iidev->slave) {\n\t\ti2c_slave_unregister(iidev->slave);\n\t\tif (iidev->slave != iidev->client)\n\t\t\ti2c_unregister_device(iidev->slave);\n\t}\n\tiidev->slave = NULL;\n\tiidev->client = NULL;\n\tipmi_ipmb_stop_thread(iidev);\n}\n\nstatic void ipmi_ipmb_remove(struct i2c_client *client)\n{\n\tstruct ipmi_ipmb_dev *iidev = i2c_get_clientdata(client);\n\n\tipmi_ipmb_cleanup(iidev);\n\tipmi_unregister_smi(iidev->intf);\n}\n\nstatic int ipmi_ipmb_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct ipmi_ipmb_dev *iidev;\n\tstruct device_node *slave_np;\n\tstruct i2c_adapter *slave_adap = NULL;\n\tstruct i2c_client *slave = NULL;\n\tint rv;\n\n\tiidev = devm_kzalloc(&client->dev, sizeof(*iidev), GFP_KERNEL);\n\tif (!iidev)\n\t\treturn -ENOMEM;\n\n\tif (of_property_read_u8(dev->of_node, \"bmcaddr\", &iidev->bmcaddr) != 0)\n\t\tiidev->bmcaddr = bmcaddr;\n\tif (iidev->bmcaddr == 0 || iidev->bmcaddr & 1) {\n\t\t \n\t\tdev_notice(&client->dev,\n\t\t\t   \"Invalid bmc address value %2.2x\\n\", iidev->bmcaddr);\n\t\treturn -EINVAL;\n\t}\n\n\tif (of_property_read_u32(dev->of_node, \"retry-time\",\n\t\t\t\t &iidev->retry_time_ms) != 0)\n\t\tiidev->retry_time_ms = retry_time_ms;\n\n\tif (of_property_read_u32(dev->of_node, \"max-retries\",\n\t\t\t\t &iidev->max_retries) != 0)\n\t\tiidev->max_retries = max_retries;\n\n\tslave_np = of_parse_phandle(dev->of_node, \"slave-dev\", 0);\n\tif (slave_np) {\n\t\tslave_adap = of_get_i2c_adapter_by_node(slave_np);\n\t\tof_node_put(slave_np);\n\t\tif (!slave_adap) {\n\t\t\tdev_notice(&client->dev,\n\t\t\t\t   \"Could not find slave adapter\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tiidev->client = client;\n\n\tif (slave_adap) {\n\t\tstruct i2c_board_info binfo;\n\n\t\tmemset(&binfo, 0, sizeof(binfo));\n\t\tstrscpy(binfo.type, \"ipmb-slave\", I2C_NAME_SIZE);\n\t\tbinfo.addr = client->addr;\n\t\tbinfo.flags = I2C_CLIENT_SLAVE;\n\t\tslave = i2c_new_client_device(slave_adap, &binfo);\n\t\ti2c_put_adapter(slave_adap);\n\t\tif (IS_ERR(slave)) {\n\t\t\trv = PTR_ERR(slave);\n\t\t\tdev_notice(&client->dev,\n\t\t\t\t   \"Could not allocate slave device: %d\\n\", rv);\n\t\t\treturn rv;\n\t\t}\n\t\ti2c_set_clientdata(slave, iidev);\n\t} else {\n\t\tslave = client;\n\t}\n\ti2c_set_clientdata(client, iidev);\n\tslave->flags |= I2C_CLIENT_SLAVE;\n\n\trv = i2c_slave_register(slave, ipmi_ipmb_slave_cb);\n\tif (rv)\n\t\tgoto out_err;\n\tiidev->slave = slave;\n\tslave = NULL;\n\n\tiidev->handlers.flags = IPMI_SMI_CAN_HANDLE_IPMB_DIRECT;\n\tiidev->handlers.start_processing = ipmi_ipmb_start_processing;\n\tiidev->handlers.shutdown = ipmi_ipmb_shutdown;\n\tiidev->handlers.sender = ipmi_ipmb_sender;\n\tiidev->handlers.request_events = ipmi_ipmb_request_events;\n\n\tspin_lock_init(&iidev->lock);\n\tsema_init(&iidev->wake_thread, 0);\n\tsema_init(&iidev->got_rsp, 0);\n\n\tiidev->thread = kthread_run(ipmi_ipmb_thread, iidev,\n\t\t\t\t    \"kipmb%4.4x\", client->addr);\n\tif (IS_ERR(iidev->thread)) {\n\t\trv = PTR_ERR(iidev->thread);\n\t\tdev_notice(&client->dev,\n\t\t\t   \"Could not start kernel thread: error %d\\n\", rv);\n\t\tgoto out_err;\n\t}\n\n\trv = ipmi_register_smi(&iidev->handlers,\n\t\t\t       iidev,\n\t\t\t       &client->dev,\n\t\t\t       iidev->bmcaddr);\n\tif (rv)\n\t\tgoto out_err;\n\n\treturn 0;\n\nout_err:\n\tif (slave && slave != client)\n\t\ti2c_unregister_device(slave);\n\tipmi_ipmb_cleanup(iidev);\n\treturn rv;\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id of_ipmi_ipmb_match[] = {\n\t{ .type = \"ipmi\", .compatible = DEVICE_NAME },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, of_ipmi_ipmb_match);\n#else\n#define of_ipmi_ipmb_match NULL\n#endif\n\nstatic const struct i2c_device_id ipmi_ipmb_id[] = {\n\t{ DEVICE_NAME, 0 },\n\t{},\n};\nMODULE_DEVICE_TABLE(i2c, ipmi_ipmb_id);\n\nstatic struct i2c_driver ipmi_ipmb_driver = {\n\t.class\t\t= I2C_CLASS_HWMON,\n\t.driver = {\n\t\t.name = DEVICE_NAME,\n\t\t.of_match_table = of_ipmi_ipmb_match,\n\t},\n\t.probe\t\t= ipmi_ipmb_probe,\n\t.remove\t\t= ipmi_ipmb_remove,\n\t.id_table\t= ipmi_ipmb_id,\n};\nmodule_i2c_driver(ipmi_ipmb_driver);\n\nMODULE_AUTHOR(\"Corey Minyard\");\nMODULE_DESCRIPTION(\"IPMI IPMB driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}