{
  "module_name": "ipmi_si_hotmod.c",
  "hash_id": "00d435438402e6e1d624fdeedd22ea16d6effdcf3a43dee554cba238a118e02b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/ipmi/ipmi_si_hotmod.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"ipmi_hotmod: \" fmt\n\n#include <linux/moduleparam.h>\n#include <linux/ipmi.h>\n#include <linux/atomic.h>\n#include \"ipmi_si.h\"\n#include \"ipmi_plat_data.h\"\n\nstatic int hotmod_handler(const char *val, const struct kernel_param *kp);\n\nmodule_param_call(hotmod, hotmod_handler, NULL, NULL, 0200);\nMODULE_PARM_DESC(hotmod,\n\t\t \"Add and remove interfaces.  See Documentation/driver-api/ipmi.rst in the kernel sources for the gory details.\");\n\n \nenum hotmod_op { HM_ADD, HM_REMOVE };\nstruct hotmod_vals {\n\tconst char *name;\n\tconst int  val;\n};\n\nstatic const struct hotmod_vals hotmod_ops[] = {\n\t{ \"add\",\tHM_ADD },\n\t{ \"remove\",\tHM_REMOVE },\n\t{ NULL }\n};\n\nstatic const struct hotmod_vals hotmod_si[] = {\n\t{ \"kcs\",\tSI_KCS },\n\t{ \"smic\",\tSI_SMIC },\n\t{ \"bt\",\t\tSI_BT },\n\t{ NULL }\n};\n\nstatic const struct hotmod_vals hotmod_as[] = {\n\t{ \"mem\",\tIPMI_MEM_ADDR_SPACE },\n\t{ \"i/o\",\tIPMI_IO_ADDR_SPACE },\n\t{ NULL }\n};\n\nstatic int parse_str(const struct hotmod_vals *v, unsigned int *val, char *name,\n\t\t     const char **curr)\n{\n\tchar *s;\n\tint  i;\n\n\ts = strchr(*curr, ',');\n\tif (!s) {\n\t\tpr_warn(\"No hotmod %s given\\n\", name);\n\t\treturn -EINVAL;\n\t}\n\t*s = '\\0';\n\ts++;\n\tfor (i = 0; v[i].name; i++) {\n\t\tif (strcmp(*curr, v[i].name) == 0) {\n\t\t\t*val = v[i].val;\n\t\t\t*curr = s;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tpr_warn(\"Invalid hotmod %s '%s'\\n\", name, *curr);\n\treturn -EINVAL;\n}\n\nstatic int check_hotmod_int_op(const char *curr, const char *option,\n\t\t\t       const char *name, unsigned int *val)\n{\n\tchar *n;\n\n\tif (strcmp(curr, name) == 0) {\n\t\tif (!option) {\n\t\t\tpr_warn(\"No option given for '%s'\\n\", curr);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*val = simple_strtoul(option, &n, 0);\n\t\tif ((*n != '\\0') || (*option == '\\0')) {\n\t\t\tpr_warn(\"Bad option given for '%s'\\n\", curr);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int parse_hotmod_str(const char *curr, enum hotmod_op *op,\n\t\t\t    struct ipmi_plat_data *h)\n{\n\tchar *s, *o;\n\tint rv;\n\tunsigned int ival;\n\n\th->iftype = IPMI_PLAT_IF_SI;\n\trv = parse_str(hotmod_ops, &ival, \"operation\", &curr);\n\tif (rv)\n\t\treturn rv;\n\t*op = ival;\n\n\trv = parse_str(hotmod_si, &ival, \"interface type\", &curr);\n\tif (rv)\n\t\treturn rv;\n\th->type = ival;\n\n\trv = parse_str(hotmod_as, &ival, \"address space\", &curr);\n\tif (rv)\n\t\treturn rv;\n\th->space = ival;\n\n\ts = strchr(curr, ',');\n\tif (s) {\n\t\t*s = '\\0';\n\t\ts++;\n\t}\n\trv = kstrtoul(curr, 0, &h->addr);\n\tif (rv) {\n\t\tpr_warn(\"Invalid hotmod address '%s': %d\\n\", curr, rv);\n\t\treturn rv;\n\t}\n\n\twhile (s) {\n\t\tcurr = s;\n\t\ts = strchr(curr, ',');\n\t\tif (s) {\n\t\t\t*s = '\\0';\n\t\t\ts++;\n\t\t}\n\t\to = strchr(curr, '=');\n\t\tif (o) {\n\t\t\t*o = '\\0';\n\t\t\to++;\n\t\t}\n\t\trv = check_hotmod_int_op(curr, o, \"rsp\", &h->regspacing);\n\t\tif (rv < 0)\n\t\t\treturn rv;\n\t\telse if (rv)\n\t\t\tcontinue;\n\t\trv = check_hotmod_int_op(curr, o, \"rsi\", &h->regsize);\n\t\tif (rv < 0)\n\t\t\treturn rv;\n\t\telse if (rv)\n\t\t\tcontinue;\n\t\trv = check_hotmod_int_op(curr, o, \"rsh\", &h->regshift);\n\t\tif (rv < 0)\n\t\t\treturn rv;\n\t\telse if (rv)\n\t\t\tcontinue;\n\t\trv = check_hotmod_int_op(curr, o, \"irq\", &h->irq);\n\t\tif (rv < 0)\n\t\t\treturn rv;\n\t\telse if (rv)\n\t\t\tcontinue;\n\t\trv = check_hotmod_int_op(curr, o, \"ipmb\", &h->slave_addr);\n\t\tif (rv < 0)\n\t\t\treturn rv;\n\t\telse if (rv)\n\t\t\tcontinue;\n\n\t\tpr_warn(\"Invalid hotmod option '%s'\\n\", curr);\n\t\treturn -EINVAL;\n\t}\n\n\th->addr_source = SI_HOTMOD;\n\treturn 0;\n}\n\nstatic atomic_t hotmod_nr;\n\nstatic int hotmod_handler(const char *val, const struct kernel_param *kp)\n{\n\tint  rv;\n\tstruct ipmi_plat_data h;\n\tchar *str, *curr, *next;\n\n\tstr = kstrdup(val, GFP_KERNEL);\n\tif (!str)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (curr = strstrip(str); curr; curr = next) {\n\t\tenum hotmod_op op;\n\n\t\tnext = strchr(curr, ':');\n\t\tif (next) {\n\t\t\t*next = '\\0';\n\t\t\tnext++;\n\t\t}\n\n\t\tmemset(&h, 0, sizeof(h));\n\t\trv = parse_hotmod_str(curr, &op, &h);\n\t\tif (rv)\n\t\t\tgoto out;\n\n\t\tif (op == HM_ADD) {\n\t\t\tipmi_platform_add(\"hotmod-ipmi-si\",\n\t\t\t\t\t  atomic_inc_return(&hotmod_nr),\n\t\t\t\t\t  &h);\n\t\t} else {\n\t\t\tstruct device *dev;\n\n\t\t\tdev = ipmi_si_remove_by_data(h.space, h.type, h.addr);\n\t\t\tif (dev && dev_is_platform(dev)) {\n\t\t\t\tstruct platform_device *pdev;\n\n\t\t\t\tpdev = to_platform_device(dev);\n\t\t\t\tif (strcmp(pdev->name, \"hotmod-ipmi-si\") == 0)\n\t\t\t\t\tplatform_device_unregister(pdev);\n\t\t\t}\n\t\t\tput_device(dev);\n\t\t}\n\t}\n\trv = strlen(val);\nout:\n\tkfree(str);\n\treturn rv;\n}\n\nvoid ipmi_si_hotmod_exit(void)\n{\n\tipmi_remove_platform_device_by_name(\"hotmod-ipmi-si\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}