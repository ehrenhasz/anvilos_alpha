{
  "module_name": "kcs_bmc_aspeed.c",
  "hash_id": "71fd6c996719540118b236876d6754e0710313a6f41f70dc8ef8392ab66ed1e5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/ipmi/kcs_bmc_aspeed.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"aspeed-kcs-bmc: \" fmt\n\n#include <linux/atomic.h>\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/poll.h>\n#include <linux/regmap.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n\n#include \"kcs_bmc_device.h\"\n\n\n#define DEVICE_NAME     \"ast-kcs-bmc\"\n\n#define KCS_CHANNEL_MAX     4\n\n \n\n#define LPC_TYIRQX_LOW       0b00\n#define LPC_TYIRQX_HIGH      0b01\n#define LPC_TYIRQX_RSVD      0b10\n#define LPC_TYIRQX_RISING    0b11\n\n#define LPC_HICR0            0x000\n#define     LPC_HICR0_LPC3E          BIT(7)\n#define     LPC_HICR0_LPC2E          BIT(6)\n#define     LPC_HICR0_LPC1E          BIT(5)\n#define LPC_HICR2            0x008\n#define     LPC_HICR2_IBFIE3         BIT(3)\n#define     LPC_HICR2_IBFIE2         BIT(2)\n#define     LPC_HICR2_IBFIE1         BIT(1)\n#define LPC_HICR4            0x010\n#define     LPC_HICR4_LADR12AS       BIT(7)\n#define     LPC_HICR4_KCSENBL        BIT(2)\n#define LPC_SIRQCR0\t     0x070\n \n#define     LPC_SIRQCR0_IRQ12E1\t     BIT(1)\n#define     LPC_SIRQCR0_IRQ1E1\t     BIT(0)\n#define LPC_HICR5\t     0x080\n#define     LPC_HICR5_ID3IRQX_MASK   GENMASK(23, 20)\n#define     LPC_HICR5_ID3IRQX_SHIFT  20\n#define     LPC_HICR5_ID2IRQX_MASK   GENMASK(19, 16)\n#define     LPC_HICR5_ID2IRQX_SHIFT  16\n#define     LPC_HICR5_SEL3IRQX       BIT(15)\n#define     LPC_HICR5_IRQXE3         BIT(14)\n#define     LPC_HICR5_SEL2IRQX       BIT(13)\n#define     LPC_HICR5_IRQXE2         BIT(12)\n#define LPC_LADR3H           0x014\n#define LPC_LADR3L           0x018\n#define LPC_LADR12H          0x01C\n#define LPC_LADR12L          0x020\n#define LPC_IDR1             0x024\n#define LPC_IDR2             0x028\n#define LPC_IDR3             0x02C\n#define LPC_ODR1             0x030\n#define LPC_ODR2             0x034\n#define LPC_ODR3             0x038\n#define LPC_STR1             0x03C\n#define LPC_STR2             0x040\n#define LPC_STR3             0x044\n#define LPC_HICRB            0x100\n#define     LPC_HICRB_EN16LADR2      BIT(5)\n#define     LPC_HICRB_EN16LADR1      BIT(4)\n#define     LPC_HICRB_IBFIE4         BIT(1)\n#define     LPC_HICRB_LPC4E          BIT(0)\n#define LPC_HICRC            0x104\n#define     LPC_HICRC_ID4IRQX_MASK   GENMASK(7, 4)\n#define     LPC_HICRC_ID4IRQX_SHIFT  4\n#define     LPC_HICRC_TY4IRQX_MASK   GENMASK(3, 2)\n#define     LPC_HICRC_TY4IRQX_SHIFT  2\n#define     LPC_HICRC_OBF4_AUTO_CLR  BIT(1)\n#define     LPC_HICRC_IRQXE4         BIT(0)\n#define LPC_LADR4            0x110\n#define LPC_IDR4             0x114\n#define LPC_ODR4             0x118\n#define LPC_STR4             0x11C\n#define LPC_LSADR12\t     0x120\n#define     LPC_LSADR12_LSADR2_MASK  GENMASK(31, 16)\n#define     LPC_LSADR12_LSADR2_SHIFT 16\n#define     LPC_LSADR12_LSADR1_MASK  GENMASK(15, 0)\n#define     LPC_LSADR12_LSADR1_SHIFT 0\n\n#define OBE_POLL_PERIOD\t     (HZ / 2)\n\nenum aspeed_kcs_irq_mode {\n\taspeed_kcs_irq_none,\n\taspeed_kcs_irq_serirq,\n};\n\nstruct aspeed_kcs_bmc {\n\tstruct kcs_bmc_device kcs_bmc;\n\n\tstruct regmap *map;\n\n\tstruct {\n\t\tenum aspeed_kcs_irq_mode mode;\n\t\tint id;\n\t} upstream_irq;\n\n\tstruct {\n\t\tspinlock_t lock;\n\t\tbool remove;\n\t\tstruct timer_list timer;\n\t} obe;\n};\n\nstatic inline struct aspeed_kcs_bmc *to_aspeed_kcs_bmc(struct kcs_bmc_device *kcs_bmc)\n{\n\treturn container_of(kcs_bmc, struct aspeed_kcs_bmc, kcs_bmc);\n}\n\nstatic u8 aspeed_kcs_inb(struct kcs_bmc_device *kcs_bmc, u32 reg)\n{\n\tstruct aspeed_kcs_bmc *priv = to_aspeed_kcs_bmc(kcs_bmc);\n\tu32 val = 0;\n\tint rc;\n\n\trc = regmap_read(priv->map, reg, &val);\n\tWARN(rc != 0, \"regmap_read() failed: %d\\n\", rc);\n\n\treturn rc == 0 ? (u8) val : 0;\n}\n\nstatic void aspeed_kcs_outb(struct kcs_bmc_device *kcs_bmc, u32 reg, u8 data)\n{\n\tstruct aspeed_kcs_bmc *priv = to_aspeed_kcs_bmc(kcs_bmc);\n\tint rc;\n\n\trc = regmap_write(priv->map, reg, data);\n\tWARN(rc != 0, \"regmap_write() failed: %d\\n\", rc);\n\n\t \n\n\tswitch (reg) {\n\tcase LPC_ODR1:\n\tcase LPC_ODR2:\n\tcase LPC_ODR3:\n\tcase LPC_ODR4:\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (priv->upstream_irq.mode != aspeed_kcs_irq_serirq)\n\t\treturn;\n\n\tswitch (kcs_bmc->channel) {\n\tcase 1:\n\t\tswitch (priv->upstream_irq.id) {\n\t\tcase 12:\n\t\t\tregmap_update_bits(priv->map, LPC_SIRQCR0, LPC_SIRQCR0_IRQ12E1,\n\t\t\t\t\t   LPC_SIRQCR0_IRQ12E1);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tregmap_update_bits(priv->map, LPC_SIRQCR0, LPC_SIRQCR0_IRQ1E1,\n\t\t\t\t\t   LPC_SIRQCR0_IRQ1E1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tregmap_update_bits(priv->map, LPC_HICR5, LPC_HICR5_IRQXE2, LPC_HICR5_IRQXE2);\n\t\tbreak;\n\tcase 3:\n\t\tregmap_update_bits(priv->map, LPC_HICR5, LPC_HICR5_IRQXE3, LPC_HICR5_IRQXE3);\n\t\tbreak;\n\tcase 4:\n\t\tregmap_update_bits(priv->map, LPC_HICRC, LPC_HICRC_IRQXE4, LPC_HICRC_IRQXE4);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void aspeed_kcs_updateb(struct kcs_bmc_device *kcs_bmc, u32 reg, u8 mask, u8 val)\n{\n\tstruct aspeed_kcs_bmc *priv = to_aspeed_kcs_bmc(kcs_bmc);\n\tint rc;\n\n\trc = regmap_update_bits(priv->map, reg, mask, val);\n\tWARN(rc != 0, \"regmap_update_bits() failed: %d\\n\", rc);\n}\n\n \nstatic int aspeed_kcs_set_address(struct kcs_bmc_device *kcs_bmc, u32 addrs[2], int nr_addrs)\n{\n\tstruct aspeed_kcs_bmc *priv = to_aspeed_kcs_bmc(kcs_bmc);\n\n\tif (WARN_ON(nr_addrs < 1 || nr_addrs > 2))\n\t\treturn -EINVAL;\n\n\tswitch (priv->kcs_bmc.channel) {\n\tcase 1:\n\t\tregmap_update_bits(priv->map, LPC_HICR4, LPC_HICR4_LADR12AS, 0);\n\t\tregmap_write(priv->map, LPC_LADR12H, addrs[0] >> 8);\n\t\tregmap_write(priv->map, LPC_LADR12L, addrs[0] & 0xFF);\n\t\tif (nr_addrs == 2) {\n\t\t\tregmap_update_bits(priv->map, LPC_LSADR12, LPC_LSADR12_LSADR1_MASK,\n\t\t\t\t\t   addrs[1] << LPC_LSADR12_LSADR1_SHIFT);\n\n\t\t\tregmap_update_bits(priv->map, LPC_HICRB, LPC_HICRB_EN16LADR1,\n\t\t\t\t\t   LPC_HICRB_EN16LADR1);\n\t\t}\n\t\tbreak;\n\n\tcase 2:\n\t\tregmap_update_bits(priv->map, LPC_HICR4, LPC_HICR4_LADR12AS, LPC_HICR4_LADR12AS);\n\t\tregmap_write(priv->map, LPC_LADR12H, addrs[0] >> 8);\n\t\tregmap_write(priv->map, LPC_LADR12L, addrs[0] & 0xFF);\n\t\tif (nr_addrs == 2) {\n\t\t\tregmap_update_bits(priv->map, LPC_LSADR12, LPC_LSADR12_LSADR2_MASK,\n\t\t\t\t\t   addrs[1] << LPC_LSADR12_LSADR2_SHIFT);\n\n\t\t\tregmap_update_bits(priv->map, LPC_HICRB, LPC_HICRB_EN16LADR2,\n\t\t\t\t\t   LPC_HICRB_EN16LADR2);\n\t\t}\n\t\tbreak;\n\n\tcase 3:\n\t\tif (nr_addrs == 2) {\n\t\t\tdev_err(priv->kcs_bmc.dev,\n\t\t\t\t\"Channel 3 only supports inferred status IO address\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tregmap_write(priv->map, LPC_LADR3H, addrs[0] >> 8);\n\t\tregmap_write(priv->map, LPC_LADR3L, addrs[0] & 0xFF);\n\t\tbreak;\n\n\tcase 4:\n\t\tif (nr_addrs == 1)\n\t\t\tregmap_write(priv->map, LPC_LADR4, ((addrs[0] + 1) << 16) | addrs[0]);\n\t\telse\n\t\t\tregmap_write(priv->map, LPC_LADR4, (addrs[1] << 16) | addrs[0]);\n\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int aspeed_kcs_map_serirq_type(u32 dt_type)\n{\n\tswitch (dt_type) {\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\treturn LPC_TYIRQX_RISING;\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\treturn LPC_TYIRQX_HIGH;\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\treturn LPC_TYIRQX_LOW;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int aspeed_kcs_config_upstream_irq(struct aspeed_kcs_bmc *priv, u32 id, u32 dt_type)\n{\n\tunsigned int mask, val, hw_type;\n\tint ret;\n\n\tif (id > 15)\n\t\treturn -EINVAL;\n\n\tret = aspeed_kcs_map_serirq_type(dt_type);\n\tif (ret < 0)\n\t\treturn ret;\n\thw_type = ret;\n\n\tpriv->upstream_irq.mode = aspeed_kcs_irq_serirq;\n\tpriv->upstream_irq.id = id;\n\n\tswitch (priv->kcs_bmc.channel) {\n\tcase 1:\n\t\t \n\t\tbreak;\n\tcase 2:\n\t\tif (!(hw_type == LPC_TYIRQX_LOW || hw_type == LPC_TYIRQX_HIGH))\n\t\t\treturn -EINVAL;\n\n\t\tmask = LPC_HICR5_SEL2IRQX | LPC_HICR5_ID2IRQX_MASK;\n\t\tval = (id << LPC_HICR5_ID2IRQX_SHIFT);\n\t\tval |= (hw_type == LPC_TYIRQX_HIGH) ? LPC_HICR5_SEL2IRQX : 0;\n\t\tregmap_update_bits(priv->map, LPC_HICR5, mask, val);\n\n\t\tbreak;\n\tcase 3:\n\t\tif (!(hw_type == LPC_TYIRQX_LOW || hw_type == LPC_TYIRQX_HIGH))\n\t\t\treturn -EINVAL;\n\n\t\tmask = LPC_HICR5_SEL3IRQX | LPC_HICR5_ID3IRQX_MASK;\n\t\tval = (id << LPC_HICR5_ID3IRQX_SHIFT);\n\t\tval |= (hw_type == LPC_TYIRQX_HIGH) ? LPC_HICR5_SEL3IRQX : 0;\n\t\tregmap_update_bits(priv->map, LPC_HICR5, mask, val);\n\n\t\tbreak;\n\tcase 4:\n\t\tmask = LPC_HICRC_ID4IRQX_MASK | LPC_HICRC_TY4IRQX_MASK | LPC_HICRC_OBF4_AUTO_CLR;\n\t\tval = (id << LPC_HICRC_ID4IRQX_SHIFT) | (hw_type << LPC_HICRC_TY4IRQX_SHIFT);\n\t\tregmap_update_bits(priv->map, LPC_HICRC, mask, val);\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(priv->kcs_bmc.dev,\n\t\t\t \"SerIRQ configuration not supported on KCS channel %d\\n\",\n\t\t\t priv->kcs_bmc.channel);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void aspeed_kcs_enable_channel(struct kcs_bmc_device *kcs_bmc, bool enable)\n{\n\tstruct aspeed_kcs_bmc *priv = to_aspeed_kcs_bmc(kcs_bmc);\n\n\tswitch (kcs_bmc->channel) {\n\tcase 1:\n\t\tregmap_update_bits(priv->map, LPC_HICR0, LPC_HICR0_LPC1E, enable * LPC_HICR0_LPC1E);\n\t\treturn;\n\tcase 2:\n\t\tregmap_update_bits(priv->map, LPC_HICR0, LPC_HICR0_LPC2E, enable * LPC_HICR0_LPC2E);\n\t\treturn;\n\tcase 3:\n\t\tregmap_update_bits(priv->map, LPC_HICR0, LPC_HICR0_LPC3E, enable * LPC_HICR0_LPC3E);\n\t\tregmap_update_bits(priv->map, LPC_HICR4,\n\t\t\t\t   LPC_HICR4_KCSENBL, enable * LPC_HICR4_KCSENBL);\n\t\treturn;\n\tcase 4:\n\t\tregmap_update_bits(priv->map, LPC_HICRB, LPC_HICRB_LPC4E, enable * LPC_HICRB_LPC4E);\n\t\treturn;\n\tdefault:\n\t\tpr_warn(\"%s: Unsupported channel: %d\", __func__, kcs_bmc->channel);\n\t\treturn;\n\t}\n}\n\nstatic void aspeed_kcs_check_obe(struct timer_list *timer)\n{\n\tstruct aspeed_kcs_bmc *priv = container_of(timer, struct aspeed_kcs_bmc, obe.timer);\n\tunsigned long flags;\n\tu8 str;\n\n\tspin_lock_irqsave(&priv->obe.lock, flags);\n\tif (priv->obe.remove) {\n\t\tspin_unlock_irqrestore(&priv->obe.lock, flags);\n\t\treturn;\n\t}\n\n\tstr = aspeed_kcs_inb(&priv->kcs_bmc, priv->kcs_bmc.ioreg.str);\n\tif (str & KCS_BMC_STR_OBF) {\n\t\tmod_timer(timer, jiffies + OBE_POLL_PERIOD);\n\t\tspin_unlock_irqrestore(&priv->obe.lock, flags);\n\t\treturn;\n\t}\n\tspin_unlock_irqrestore(&priv->obe.lock, flags);\n\n\tkcs_bmc_handle_event(&priv->kcs_bmc);\n}\n\nstatic void aspeed_kcs_irq_mask_update(struct kcs_bmc_device *kcs_bmc, u8 mask, u8 state)\n{\n\tstruct aspeed_kcs_bmc *priv = to_aspeed_kcs_bmc(kcs_bmc);\n\tint rc;\n\tu8 str;\n\n\t \n\tif (mask & KCS_BMC_EVENT_TYPE_OBE) {\n\t\tif (KCS_BMC_EVENT_TYPE_OBE & state) {\n\t\t\t \n\t\t\trc = read_poll_timeout_atomic(aspeed_kcs_inb, str,\n\t\t\t\t\t\t      !(str & KCS_BMC_STR_OBF), 1, 100, false,\n\t\t\t\t\t\t      &priv->kcs_bmc, priv->kcs_bmc.ioreg.str);\n\t\t\t \n\t\t\tif (rc == -ETIMEDOUT)\n\t\t\t\tmod_timer(&priv->obe.timer, jiffies + OBE_POLL_PERIOD);\n\t\t} else {\n\t\t\tdel_timer(&priv->obe.timer);\n\t\t}\n\t}\n\n\tif (mask & KCS_BMC_EVENT_TYPE_IBF) {\n\t\tconst bool enable = !!(state & KCS_BMC_EVENT_TYPE_IBF);\n\n\t\tswitch (kcs_bmc->channel) {\n\t\tcase 1:\n\t\t\tregmap_update_bits(priv->map, LPC_HICR2, LPC_HICR2_IBFIE1,\n\t\t\t\t\t   enable * LPC_HICR2_IBFIE1);\n\t\t\treturn;\n\t\tcase 2:\n\t\t\tregmap_update_bits(priv->map, LPC_HICR2, LPC_HICR2_IBFIE2,\n\t\t\t\t\t   enable * LPC_HICR2_IBFIE2);\n\t\t\treturn;\n\t\tcase 3:\n\t\t\tregmap_update_bits(priv->map, LPC_HICR2, LPC_HICR2_IBFIE3,\n\t\t\t\t\t   enable * LPC_HICR2_IBFIE3);\n\t\t\treturn;\n\t\tcase 4:\n\t\t\tregmap_update_bits(priv->map, LPC_HICRB, LPC_HICRB_IBFIE4,\n\t\t\t\t\t   enable * LPC_HICRB_IBFIE4);\n\t\t\treturn;\n\t\tdefault:\n\t\t\tpr_warn(\"%s: Unsupported channel: %d\", __func__, kcs_bmc->channel);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic const struct kcs_bmc_device_ops aspeed_kcs_ops = {\n\t.irq_mask_update = aspeed_kcs_irq_mask_update,\n\t.io_inputb = aspeed_kcs_inb,\n\t.io_outputb = aspeed_kcs_outb,\n\t.io_updateb = aspeed_kcs_updateb,\n};\n\nstatic irqreturn_t aspeed_kcs_irq(int irq, void *arg)\n{\n\tstruct kcs_bmc_device *kcs_bmc = arg;\n\n\treturn kcs_bmc_handle_event(kcs_bmc);\n}\n\nstatic int aspeed_kcs_config_downstream_irq(struct kcs_bmc_device *kcs_bmc,\n\t\t\tstruct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tint irq;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\treturn devm_request_irq(dev, irq, aspeed_kcs_irq, IRQF_SHARED,\n\t\t\t\tdev_name(dev), kcs_bmc);\n}\n\nstatic const struct kcs_ioreg ast_kcs_bmc_ioregs[KCS_CHANNEL_MAX] = {\n\t{ .idr = LPC_IDR1, .odr = LPC_ODR1, .str = LPC_STR1 },\n\t{ .idr = LPC_IDR2, .odr = LPC_ODR2, .str = LPC_STR2 },\n\t{ .idr = LPC_IDR3, .odr = LPC_ODR3, .str = LPC_STR3 },\n\t{ .idr = LPC_IDR4, .odr = LPC_ODR4, .str = LPC_STR4 },\n};\n\nstatic int aspeed_kcs_of_get_channel(struct platform_device *pdev)\n{\n\tstruct device_node *np;\n\tstruct kcs_ioreg ioreg;\n\tconst __be32 *reg;\n\tint i;\n\n\tnp = pdev->dev.of_node;\n\n\t \n\treg = of_get_address(np, 0, NULL, NULL);\n\tif (!reg)\n\t\treturn -EINVAL;\n\tioreg.idr = be32_to_cpup(reg);\n\n\treg = of_get_address(np, 1, NULL, NULL);\n\tif (!reg)\n\t\treturn -EINVAL;\n\tioreg.odr = be32_to_cpup(reg);\n\n\treg = of_get_address(np, 2, NULL, NULL);\n\tif (!reg)\n\t\treturn -EINVAL;\n\tioreg.str = be32_to_cpup(reg);\n\n\tfor (i = 0; i < ARRAY_SIZE(ast_kcs_bmc_ioregs); i++) {\n\t\tif (!memcmp(&ast_kcs_bmc_ioregs[i], &ioreg, sizeof(ioreg)))\n\t\t\treturn i + 1;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int\naspeed_kcs_of_get_io_address(struct platform_device *pdev, u32 addrs[2])\n{\n\tint rc;\n\n\trc = of_property_read_variable_u32_array(pdev->dev.of_node,\n\t\t\t\t\t\t \"aspeed,lpc-io-reg\",\n\t\t\t\t\t\t addrs, 1, 2);\n\tif (rc < 0) {\n\t\tdev_err(&pdev->dev, \"No valid 'aspeed,lpc-io-reg' configured\\n\");\n\t\treturn rc;\n\t}\n\n\tif (addrs[0] > 0xffff) {\n\t\tdev_err(&pdev->dev, \"Invalid data address in 'aspeed,lpc-io-reg'\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (rc == 2 && addrs[1] > 0xffff) {\n\t\tdev_err(&pdev->dev, \"Invalid status address in 'aspeed,lpc-io-reg'\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn rc;\n}\n\nstatic int aspeed_kcs_probe(struct platform_device *pdev)\n{\n\tstruct kcs_bmc_device *kcs_bmc;\n\tstruct aspeed_kcs_bmc *priv;\n\tstruct device_node *np;\n\tbool have_upstream_irq;\n\tu32 upstream_irq[2];\n\tint rc, channel;\n\tint nr_addrs;\n\tu32 addrs[2];\n\n\tnp = pdev->dev.of_node->parent;\n\tif (!of_device_is_compatible(np, \"aspeed,ast2400-lpc-v2\") &&\n\t    !of_device_is_compatible(np, \"aspeed,ast2500-lpc-v2\") &&\n\t    !of_device_is_compatible(np, \"aspeed,ast2600-lpc-v2\")) {\n\t\tdev_err(&pdev->dev, \"unsupported LPC device binding\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tchannel = aspeed_kcs_of_get_channel(pdev);\n\tif (channel < 0)\n\t\treturn channel;\n\n\tnr_addrs = aspeed_kcs_of_get_io_address(pdev, addrs);\n\tif (nr_addrs < 0)\n\t\treturn nr_addrs;\n\n\tnp = pdev->dev.of_node;\n\trc = of_property_read_u32_array(np, \"aspeed,lpc-interrupts\", upstream_irq, 2);\n\tif (rc && rc != -EINVAL)\n\t\treturn -EINVAL;\n\n\thave_upstream_irq = !rc;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tkcs_bmc = &priv->kcs_bmc;\n\tkcs_bmc->dev = &pdev->dev;\n\tkcs_bmc->channel = channel;\n\tkcs_bmc->ioreg = ast_kcs_bmc_ioregs[channel - 1];\n\tkcs_bmc->ops = &aspeed_kcs_ops;\n\n\tpriv->map = syscon_node_to_regmap(pdev->dev.parent->of_node);\n\tif (IS_ERR(priv->map)) {\n\t\tdev_err(&pdev->dev, \"Couldn't get regmap\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tspin_lock_init(&priv->obe.lock);\n\tpriv->obe.remove = false;\n\ttimer_setup(&priv->obe.timer, aspeed_kcs_check_obe, 0);\n\n\trc = aspeed_kcs_set_address(kcs_bmc, addrs, nr_addrs);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\trc = aspeed_kcs_config_downstream_irq(kcs_bmc, pdev);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tif (have_upstream_irq) {\n\t\trc = aspeed_kcs_config_upstream_irq(priv, upstream_irq[0], upstream_irq[1]);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t} else {\n\t\tpriv->upstream_irq.mode = aspeed_kcs_irq_none;\n\t}\n\n\tplatform_set_drvdata(pdev, priv);\n\n\taspeed_kcs_irq_mask_update(kcs_bmc, (KCS_BMC_EVENT_TYPE_IBF | KCS_BMC_EVENT_TYPE_OBE), 0);\n\taspeed_kcs_enable_channel(kcs_bmc, true);\n\n\trc = kcs_bmc_add_device(&priv->kcs_bmc);\n\tif (rc) {\n\t\tdev_warn(&pdev->dev, \"Failed to register channel %d: %d\\n\", kcs_bmc->channel, rc);\n\t\treturn rc;\n\t}\n\n\tdev_info(&pdev->dev, \"Initialised channel %d at 0x%x\\n\",\n\t\t\tkcs_bmc->channel, addrs[0]);\n\n\treturn 0;\n}\n\nstatic int aspeed_kcs_remove(struct platform_device *pdev)\n{\n\tstruct aspeed_kcs_bmc *priv = platform_get_drvdata(pdev);\n\tstruct kcs_bmc_device *kcs_bmc = &priv->kcs_bmc;\n\n\tkcs_bmc_remove_device(kcs_bmc);\n\n\taspeed_kcs_enable_channel(kcs_bmc, false);\n\taspeed_kcs_irq_mask_update(kcs_bmc, (KCS_BMC_EVENT_TYPE_IBF | KCS_BMC_EVENT_TYPE_OBE), 0);\n\n\t \n\tspin_lock_irq(&priv->obe.lock);\n\tpriv->obe.remove = true;\n\tspin_unlock_irq(&priv->obe.lock);\n\tdel_timer_sync(&priv->obe.timer);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id ast_kcs_bmc_match[] = {\n\t{ .compatible = \"aspeed,ast2400-kcs-bmc-v2\" },\n\t{ .compatible = \"aspeed,ast2500-kcs-bmc-v2\" },\n\t{ .compatible = \"aspeed,ast2600-kcs-bmc\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ast_kcs_bmc_match);\n\nstatic struct platform_driver ast_kcs_bmc_driver = {\n\t.driver = {\n\t\t.name           = DEVICE_NAME,\n\t\t.of_match_table = ast_kcs_bmc_match,\n\t},\n\t.probe  = aspeed_kcs_probe,\n\t.remove = aspeed_kcs_remove,\n};\nmodule_platform_driver(ast_kcs_bmc_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Haiyue Wang <haiyue.wang@linux.intel.com>\");\nMODULE_AUTHOR(\"Andrew Jeffery <andrew@aj.id.au>\");\nMODULE_DESCRIPTION(\"Aspeed device interface to the KCS BMC device\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}