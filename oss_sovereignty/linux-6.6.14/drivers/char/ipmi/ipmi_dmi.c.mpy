{
  "module_name": "ipmi_dmi.c",
  "hash_id": "a3c600b4b0bb67b7cb775b8f851761a0b71b136d7f855373c39bbd31e08c7048",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/ipmi/ipmi_dmi.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"%s\" fmt, \"ipmi:dmi: \"\n#define dev_fmt pr_fmt\n\n#include <linux/ipmi.h>\n#include <linux/init.h>\n#include <linux/dmi.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include \"ipmi_dmi.h\"\n#include \"ipmi_plat_data.h\"\n\n#define IPMI_DMI_TYPE_KCS\t0x01\n#define IPMI_DMI_TYPE_SMIC\t0x02\n#define IPMI_DMI_TYPE_BT\t0x03\n#define IPMI_DMI_TYPE_SSIF\t0x04\n\nstruct ipmi_dmi_info {\n\tenum si_type si_type;\n\tunsigned int space;  \n\tunsigned long addr;\n\tu8 slave_addr;\n\tstruct ipmi_dmi_info *next;\n};\n\nstatic struct ipmi_dmi_info *ipmi_dmi_infos;\n\nstatic int ipmi_dmi_nr __initdata;\n\nstatic void __init dmi_add_platform_ipmi(unsigned long base_addr,\n\t\t\t\t\t unsigned int space,\n\t\t\t\t\t u8 slave_addr,\n\t\t\t\t\t int irq,\n\t\t\t\t\t int offset,\n\t\t\t\t\t int type)\n{\n\tconst char *name;\n\tstruct ipmi_dmi_info *info;\n\tstruct ipmi_plat_data p;\n\n\tmemset(&p, 0, sizeof(p));\n\n\tname = \"dmi-ipmi-si\";\n\tp.iftype = IPMI_PLAT_IF_SI;\n\tswitch (type) {\n\tcase IPMI_DMI_TYPE_SSIF:\n\t\tname = \"dmi-ipmi-ssif\";\n\t\tp.iftype = IPMI_PLAT_IF_SSIF;\n\t\tp.type = SI_TYPE_INVALID;\n\t\tbreak;\n\tcase IPMI_DMI_TYPE_BT:\n\t\tp.type = SI_BT;\n\t\tbreak;\n\tcase IPMI_DMI_TYPE_KCS:\n\t\tp.type = SI_KCS;\n\t\tbreak;\n\tcase IPMI_DMI_TYPE_SMIC:\n\t\tp.type = SI_SMIC;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Invalid IPMI type: %d\\n\", type);\n\t\treturn;\n\t}\n\n\tp.addr = base_addr;\n\tp.space = space;\n\tp.regspacing = offset;\n\tp.irq = irq;\n\tp.slave_addr = slave_addr;\n\tp.addr_source = SI_SMBIOS;\n\n\tinfo = kmalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info) {\n\t\tpr_warn(\"Could not allocate dmi info\\n\");\n\t} else {\n\t\tinfo->si_type = p.type;\n\t\tinfo->space = space;\n\t\tinfo->addr = base_addr;\n\t\tinfo->slave_addr = slave_addr;\n\t\tinfo->next = ipmi_dmi_infos;\n\t\tipmi_dmi_infos = info;\n\t}\n\n\tif (ipmi_platform_add(name, ipmi_dmi_nr, &p))\n\t\tipmi_dmi_nr++;\n}\n\n \nint ipmi_dmi_get_slave_addr(enum si_type si_type, unsigned int space,\n\t\t\t    unsigned long base_addr)\n{\n\tstruct ipmi_dmi_info *info = ipmi_dmi_infos;\n\n\twhile (info) {\n\t\tif (info->si_type == si_type &&\n\t\t    info->space == space &&\n\t\t    info->addr == base_addr)\n\t\t\treturn info->slave_addr;\n\t\tinfo = info->next;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ipmi_dmi_get_slave_addr);\n\n#define DMI_IPMI_MIN_LENGTH\t0x10\n#define DMI_IPMI_VER2_LENGTH\t0x12\n#define DMI_IPMI_TYPE\t\t4\n#define DMI_IPMI_SLAVEADDR\t6\n#define DMI_IPMI_ADDR\t\t8\n#define DMI_IPMI_ACCESS\t\t0x10\n#define DMI_IPMI_IRQ\t\t0x11\n#define DMI_IPMI_IO_MASK\t0xfffe\n\nstatic void __init dmi_decode_ipmi(const struct dmi_header *dm)\n{\n\tconst u8 *data = (const u8 *) dm;\n\tint space = IPMI_IO_ADDR_SPACE;\n\tunsigned long base_addr;\n\tu8 len = dm->length;\n\tu8 slave_addr;\n\tint irq = 0, offset = 0;\n\tint type;\n\n\tif (len < DMI_IPMI_MIN_LENGTH)\n\t\treturn;\n\n\ttype = data[DMI_IPMI_TYPE];\n\tslave_addr = data[DMI_IPMI_SLAVEADDR];\n\n\tmemcpy(&base_addr, data + DMI_IPMI_ADDR, sizeof(unsigned long));\n\tif (!base_addr) {\n\t\tpr_err(\"Base address is zero, assuming no IPMI interface\\n\");\n\t\treturn;\n\t}\n\tif (len >= DMI_IPMI_VER2_LENGTH) {\n\t\tif (type == IPMI_DMI_TYPE_SSIF) {\n\t\t\tspace = 0;  \n\t\t\tbase_addr = data[DMI_IPMI_ADDR] >> 1;\n\t\t\tif (base_addr == 0) {\n\t\t\t\t \n\t\t\t\tbase_addr = data[DMI_IPMI_SLAVEADDR] >> 1;\n\t\t\t\tslave_addr = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tif (base_addr & 1) {\n\t\t\t\t \n\t\t\t\tbase_addr &= DMI_IPMI_IO_MASK;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tspace = IPMI_MEM_ADDR_SPACE;\n\t\t\t}\n\n\t\t\t \n\t\t\tbase_addr |= (data[DMI_IPMI_ACCESS] >> 4) & 1;\n\n\t\t\tirq = data[DMI_IPMI_IRQ];\n\n\t\t\t \n\t\t\tswitch ((data[DMI_IPMI_ACCESS] >> 6) & 3) {\n\t\t\tcase 0:  \n\t\t\t\toffset = 1;\n\t\t\t\tbreak;\n\t\t\tcase 1:  \n\t\t\t\toffset = 4;\n\t\t\t\tbreak;\n\t\t\tcase 2:  \n\t\t\t\toffset = 16;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpr_err(\"Invalid offset: 0\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\t \n\t\tbase_addr = base_addr & DMI_IPMI_IO_MASK;\n\t\toffset = 1;\n\t}\n\n\tdmi_add_platform_ipmi(base_addr, space, slave_addr, irq,\n\t\t\t      offset, type);\n}\n\nstatic int __init scan_for_dmi_ipmi(void)\n{\n\tconst struct dmi_device *dev = NULL;\n\n\twhile ((dev = dmi_find_device(DMI_DEV_TYPE_IPMI, NULL, dev)))\n\t\tdmi_decode_ipmi((const struct dmi_header *) dev->device_data);\n\n\treturn 0;\n}\nsubsys_initcall(scan_for_dmi_ipmi);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}