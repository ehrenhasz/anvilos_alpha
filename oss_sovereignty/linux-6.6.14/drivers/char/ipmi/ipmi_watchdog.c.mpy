{
  "module_name": "ipmi_watchdog.c",
  "hash_id": "5baaf20e3073d4399230fe8eba93b5088ea58b2f38a60da3a3ab02417dfecfba",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/ipmi/ipmi_watchdog.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"IPMI Watchdog: \" fmt\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/ipmi.h>\n#include <linux/ipmi_smi.h>\n#include <linux/mutex.h>\n#include <linux/watchdog.h>\n#include <linux/miscdevice.h>\n#include <linux/init.h>\n#include <linux/completion.h>\n#include <linux/kdebug.h>\n#include <linux/kstrtox.h>\n#include <linux/rwsem.h>\n#include <linux/errno.h>\n#include <linux/uaccess.h>\n#include <linux/notifier.h>\n#include <linux/nmi.h>\n#include <linux/reboot.h>\n#include <linux/wait.h>\n#include <linux/poll.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/delay.h>\n#include <linux/atomic.h>\n#include <linux/sched/signal.h>\n\n#ifdef CONFIG_X86\n \n#include <asm/kdebug.h>\n#include <asm/nmi.h>\n#define HAVE_DIE_NMI\n#endif\n\n \n\n \n#define WDOG_DONT_LOG\t\t(1 << 7)\n#define WDOG_DONT_STOP_ON_SET\t(1 << 6)\n#define WDOG_SET_TIMER_USE(byte, use) \\\n\tbyte = ((byte) & 0xf8) | ((use) & 0x7)\n#define WDOG_GET_TIMER_USE(byte) ((byte) & 0x7)\n#define WDOG_TIMER_USE_BIOS_FRB2\t1\n#define WDOG_TIMER_USE_BIOS_POST\t2\n#define WDOG_TIMER_USE_OS_LOAD\t\t3\n#define WDOG_TIMER_USE_SMS_OS\t\t4\n#define WDOG_TIMER_USE_OEM\t\t5\n\n \n#define WDOG_SET_PRETIMEOUT_ACT(byte, use) \\\n\tbyte = ((byte) & 0x8f) | (((use) & 0x7) << 4)\n#define WDOG_GET_PRETIMEOUT_ACT(byte) (((byte) >> 4) & 0x7)\n#define WDOG_PRETIMEOUT_NONE\t\t0\n#define WDOG_PRETIMEOUT_SMI\t\t1\n#define WDOG_PRETIMEOUT_NMI\t\t2\n#define WDOG_PRETIMEOUT_MSG_INT\t\t3\n\n \n#define WDOG_PREOP_NONE\t\t0\n#define WDOG_PREOP_PANIC\t1\n \n#define WDOG_PREOP_GIVE_DATA\t2\n\n \n#define WDOG_SET_TIMEOUT_ACT(byte, use) \\\n\tbyte = ((byte) & 0xf8) | ((use) & 0x7)\n#define WDOG_GET_TIMEOUT_ACT(byte) ((byte) & 0x7)\n#define WDOG_TIMEOUT_NONE\t\t0\n#define WDOG_TIMEOUT_RESET\t\t1\n#define WDOG_TIMEOUT_POWER_DOWN\t\t2\n#define WDOG_TIMEOUT_POWER_CYCLE\t3\n\n \n\n \n#define WDOG_EXPIRE_CLEAR_BIOS_FRB2\t(1 << 1)\n#define WDOG_EXPIRE_CLEAR_BIOS_POST\t(1 << 2)\n#define WDOG_EXPIRE_CLEAR_OS_LOAD\t(1 << 3)\n#define WDOG_EXPIRE_CLEAR_SMS_OS\t(1 << 4)\n#define WDOG_EXPIRE_CLEAR_OEM\t\t(1 << 5)\n\n \n#define WDOG_SET_TIMEOUT(byte1, byte2, val) \\\n\t(byte1) = (((val) * 10) & 0xff), (byte2) = (((val) * 10) >> 8)\n#define WDOG_GET_TIMEOUT(byte1, byte2) \\\n\t(((byte1) | ((byte2) << 8)) / 10)\n\n#define IPMI_WDOG_RESET_TIMER\t\t0x22\n#define IPMI_WDOG_SET_TIMER\t\t0x24\n#define IPMI_WDOG_GET_TIMER\t\t0x25\n\n#define IPMI_WDOG_TIMER_NOT_INIT_RESP\t0x80\n\nstatic DEFINE_MUTEX(ipmi_watchdog_mutex);\nstatic bool nowayout = WATCHDOG_NOWAYOUT;\n\nstatic struct ipmi_user *watchdog_user;\nstatic int watchdog_ifnum;\n\n \nstatic int timeout = 10;\n\n \nstatic int pretimeout;\n\n \nstatic int panic_wdt_timeout = 255;\n\n \nstatic unsigned char action_val = WDOG_TIMEOUT_RESET;\n\nstatic char action[16] = \"reset\";\n\nstatic unsigned char preaction_val = WDOG_PRETIMEOUT_NONE;\n\nstatic char preaction[16] = \"pre_none\";\n\nstatic unsigned char preop_val = WDOG_PREOP_NONE;\n\nstatic char preop[16] = \"preop_none\";\nstatic DEFINE_SPINLOCK(ipmi_read_lock);\nstatic char data_to_read;\nstatic DECLARE_WAIT_QUEUE_HEAD(read_q);\nstatic struct fasync_struct *fasync_q;\nstatic atomic_t pretimeout_since_last_heartbeat;\nstatic char expect_close;\n\nstatic int ifnum_to_use = -1;\n\n \n#define IPMI_SET_TIMEOUT_NO_HB\t\t\t0\n#define IPMI_SET_TIMEOUT_HB_IF_NECESSARY\t1\n#define IPMI_SET_TIMEOUT_FORCE_HB\t\t2\n\nstatic int ipmi_set_timeout(int do_heartbeat);\nstatic void ipmi_register_watchdog(int ipmi_intf);\nstatic void ipmi_unregister_watchdog(int ipmi_intf);\n\n \nstatic int start_now;\n\nstatic int set_param_timeout(const char *val, const struct kernel_param *kp)\n{\n\tchar *endp;\n\tint  l;\n\tint  rv = 0;\n\n\tif (!val)\n\t\treturn -EINVAL;\n\tl = simple_strtoul(val, &endp, 0);\n\tif (endp == val)\n\t\treturn -EINVAL;\n\n\t*((int *)kp->arg) = l;\n\tif (watchdog_user)\n\t\trv = ipmi_set_timeout(IPMI_SET_TIMEOUT_HB_IF_NECESSARY);\n\n\treturn rv;\n}\n\nstatic const struct kernel_param_ops param_ops_timeout = {\n\t.set = set_param_timeout,\n\t.get = param_get_int,\n};\n#define param_check_timeout param_check_int\n\ntypedef int (*action_fn)(const char *intval, char *outval);\n\nstatic int action_op(const char *inval, char *outval);\nstatic int preaction_op(const char *inval, char *outval);\nstatic int preop_op(const char *inval, char *outval);\nstatic void check_parms(void);\n\nstatic int set_param_str(const char *val, const struct kernel_param *kp)\n{\n\taction_fn  fn = (action_fn) kp->arg;\n\tint        rv = 0;\n\tchar       valcp[16];\n\tchar       *s;\n\n\tstrscpy(valcp, val, 16);\n\n\ts = strstrip(valcp);\n\n\trv = fn(s, NULL);\n\tif (rv)\n\t\tgoto out;\n\n\tcheck_parms();\n\tif (watchdog_user)\n\t\trv = ipmi_set_timeout(IPMI_SET_TIMEOUT_HB_IF_NECESSARY);\n\n out:\n\treturn rv;\n}\n\nstatic int get_param_str(char *buffer, const struct kernel_param *kp)\n{\n\taction_fn fn = (action_fn) kp->arg;\n\tint rv, len;\n\n\trv = fn(NULL, buffer);\n\tif (rv)\n\t\treturn rv;\n\n\tlen = strlen(buffer);\n\tbuffer[len++] = '\\n';\n\tbuffer[len] = 0;\n\n\treturn len;\n}\n\n\nstatic int set_param_wdog_ifnum(const char *val, const struct kernel_param *kp)\n{\n\tint rv = param_set_int(val, kp);\n\tif (rv)\n\t\treturn rv;\n\tif ((ifnum_to_use < 0) || (ifnum_to_use == watchdog_ifnum))\n\t\treturn 0;\n\n\tipmi_unregister_watchdog(watchdog_ifnum);\n\tipmi_register_watchdog(ifnum_to_use);\n\treturn 0;\n}\n\nstatic const struct kernel_param_ops param_ops_wdog_ifnum = {\n\t.set = set_param_wdog_ifnum,\n\t.get = param_get_int,\n};\n\n#define param_check_wdog_ifnum param_check_int\n\nstatic const struct kernel_param_ops param_ops_str = {\n\t.set = set_param_str,\n\t.get = get_param_str,\n};\n\nmodule_param(ifnum_to_use, wdog_ifnum, 0644);\nMODULE_PARM_DESC(ifnum_to_use, \"The interface number to use for the watchdog \"\n\t\t \"timer.  Setting to -1 defaults to the first registered \"\n\t\t \"interface\");\n\nmodule_param(timeout, timeout, 0644);\nMODULE_PARM_DESC(timeout, \"Timeout value in seconds.\");\n\nmodule_param(pretimeout, timeout, 0644);\nMODULE_PARM_DESC(pretimeout, \"Pretimeout value in seconds.\");\n\nmodule_param(panic_wdt_timeout, timeout, 0644);\nMODULE_PARM_DESC(panic_wdt_timeout, \"Timeout value on kernel panic in seconds.\");\n\nmodule_param_cb(action, &param_ops_str, action_op, 0644);\nMODULE_PARM_DESC(action, \"Timeout action. One of: \"\n\t\t \"reset, none, power_cycle, power_off.\");\n\nmodule_param_cb(preaction, &param_ops_str, preaction_op, 0644);\nMODULE_PARM_DESC(preaction, \"Pretimeout action.  One of: \"\n\t\t \"pre_none, pre_smi, pre_nmi, pre_int.\");\n\nmodule_param_cb(preop, &param_ops_str, preop_op, 0644);\nMODULE_PARM_DESC(preop, \"Pretimeout driver operation.  One of: \"\n\t\t \"preop_none, preop_panic, preop_give_data.\");\n\nmodule_param(start_now, int, 0444);\nMODULE_PARM_DESC(start_now, \"Set to 1 to start the watchdog as\"\n\t\t \"soon as the driver is loaded.\");\n\nmodule_param(nowayout, bool, 0644);\nMODULE_PARM_DESC(nowayout, \"Watchdog cannot be stopped once started \"\n\t\t \"(default=CONFIG_WATCHDOG_NOWAYOUT)\");\n\n \nstatic unsigned char ipmi_watchdog_state = WDOG_TIMEOUT_NONE;\n\n \nstatic unsigned long ipmi_wdog_open;\n\n \nstatic int ipmi_start_timer_on_heartbeat;\n\n \nstatic unsigned char ipmi_version_major;\nstatic unsigned char ipmi_version_minor;\n\n \nstatic atomic_t preop_panic_excl = ATOMIC_INIT(-1);\n\n#ifdef HAVE_DIE_NMI\nstatic int testing_nmi;\nstatic int nmi_handler_registered;\n#endif\n\nstatic int __ipmi_heartbeat(void);\n\n \nstatic atomic_t msg_tofree = ATOMIC_INIT(0);\nstatic DECLARE_COMPLETION(msg_wait);\nstatic void msg_free_smi(struct ipmi_smi_msg *msg)\n{\n\tif (atomic_dec_and_test(&msg_tofree)) {\n\t\tif (!oops_in_progress)\n\t\t\tcomplete(&msg_wait);\n\t}\n}\nstatic void msg_free_recv(struct ipmi_recv_msg *msg)\n{\n\tif (atomic_dec_and_test(&msg_tofree)) {\n\t\tif (!oops_in_progress)\n\t\t\tcomplete(&msg_wait);\n\t}\n}\nstatic struct ipmi_smi_msg smi_msg = INIT_IPMI_SMI_MSG(msg_free_smi);\nstatic struct ipmi_recv_msg recv_msg = INIT_IPMI_RECV_MSG(msg_free_recv);\n\nstatic int __ipmi_set_timeout(struct ipmi_smi_msg  *smi_msg,\n\t\t\t      struct ipmi_recv_msg *recv_msg,\n\t\t\t      int                  *send_heartbeat_now)\n{\n\tstruct kernel_ipmi_msg            msg;\n\tunsigned char                     data[6];\n\tint                               rv;\n\tstruct ipmi_system_interface_addr addr;\n\tint                               hbnow = 0;\n\n\n\tdata[0] = 0;\n\tWDOG_SET_TIMER_USE(data[0], WDOG_TIMER_USE_SMS_OS);\n\n\tif (ipmi_watchdog_state != WDOG_TIMEOUT_NONE) {\n\t\tif ((ipmi_version_major > 1) ||\n\t\t    ((ipmi_version_major == 1) && (ipmi_version_minor >= 5))) {\n\t\t\t \n\t\t\tdata[0] |= WDOG_DONT_STOP_ON_SET;\n\t\t} else {\n\t\t\t \n\t\t\thbnow = 1;\n\t\t}\n\t}\n\n\tdata[1] = 0;\n\tWDOG_SET_TIMEOUT_ACT(data[1], ipmi_watchdog_state);\n\tif ((pretimeout > 0) && (ipmi_watchdog_state != WDOG_TIMEOUT_NONE)) {\n\t    WDOG_SET_PRETIMEOUT_ACT(data[1], preaction_val);\n\t    data[2] = pretimeout;\n\t} else {\n\t    WDOG_SET_PRETIMEOUT_ACT(data[1], WDOG_PRETIMEOUT_NONE);\n\t    data[2] = 0;  \n\t}\n\tdata[3] = 0;\n\tWDOG_SET_TIMEOUT(data[4], data[5], timeout);\n\n\taddr.addr_type = IPMI_SYSTEM_INTERFACE_ADDR_TYPE;\n\taddr.channel = IPMI_BMC_CHANNEL;\n\taddr.lun = 0;\n\n\tmsg.netfn = 0x06;\n\tmsg.cmd = IPMI_WDOG_SET_TIMER;\n\tmsg.data = data;\n\tmsg.data_len = sizeof(data);\n\trv = ipmi_request_supply_msgs(watchdog_user,\n\t\t\t\t      (struct ipmi_addr *) &addr,\n\t\t\t\t      0,\n\t\t\t\t      &msg,\n\t\t\t\t      NULL,\n\t\t\t\t      smi_msg,\n\t\t\t\t      recv_msg,\n\t\t\t\t      1);\n\tif (rv)\n\t\tpr_warn(\"set timeout error: %d\\n\", rv);\n\telse if (send_heartbeat_now)\n\t\t*send_heartbeat_now = hbnow;\n\n\treturn rv;\n}\n\nstatic int _ipmi_set_timeout(int do_heartbeat)\n{\n\tint send_heartbeat_now;\n\tint rv;\n\n\tif (!watchdog_user)\n\t\treturn -ENODEV;\n\n\tatomic_set(&msg_tofree, 2);\n\n\trv = __ipmi_set_timeout(&smi_msg,\n\t\t\t\t&recv_msg,\n\t\t\t\t&send_heartbeat_now);\n\tif (rv) {\n\t\tatomic_set(&msg_tofree, 0);\n\t\treturn rv;\n\t}\n\n\twait_for_completion(&msg_wait);\n\n\tif ((do_heartbeat == IPMI_SET_TIMEOUT_FORCE_HB)\n\t\t|| ((send_heartbeat_now)\n\t\t    && (do_heartbeat == IPMI_SET_TIMEOUT_HB_IF_NECESSARY)))\n\t\trv = __ipmi_heartbeat();\n\n\treturn rv;\n}\n\nstatic int ipmi_set_timeout(int do_heartbeat)\n{\n\tint rv;\n\n\tmutex_lock(&ipmi_watchdog_mutex);\n\trv = _ipmi_set_timeout(do_heartbeat);\n\tmutex_unlock(&ipmi_watchdog_mutex);\n\n\treturn rv;\n}\n\nstatic atomic_t panic_done_count = ATOMIC_INIT(0);\n\nstatic void panic_smi_free(struct ipmi_smi_msg *msg)\n{\n\tatomic_dec(&panic_done_count);\n}\nstatic void panic_recv_free(struct ipmi_recv_msg *msg)\n{\n\tatomic_dec(&panic_done_count);\n}\n\nstatic struct ipmi_smi_msg panic_halt_heartbeat_smi_msg =\n\tINIT_IPMI_SMI_MSG(panic_smi_free);\nstatic struct ipmi_recv_msg panic_halt_heartbeat_recv_msg =\n\tINIT_IPMI_RECV_MSG(panic_recv_free);\n\nstatic void panic_halt_ipmi_heartbeat(void)\n{\n\tstruct kernel_ipmi_msg             msg;\n\tstruct ipmi_system_interface_addr addr;\n\tint rv;\n\n\t \n\tif (ipmi_watchdog_state == WDOG_TIMEOUT_NONE)\n\t\treturn;\n\n\taddr.addr_type = IPMI_SYSTEM_INTERFACE_ADDR_TYPE;\n\taddr.channel = IPMI_BMC_CHANNEL;\n\taddr.lun = 0;\n\n\tmsg.netfn = 0x06;\n\tmsg.cmd = IPMI_WDOG_RESET_TIMER;\n\tmsg.data = NULL;\n\tmsg.data_len = 0;\n\tatomic_add(2, &panic_done_count);\n\trv = ipmi_request_supply_msgs(watchdog_user,\n\t\t\t\t      (struct ipmi_addr *) &addr,\n\t\t\t\t      0,\n\t\t\t\t      &msg,\n\t\t\t\t      NULL,\n\t\t\t\t      &panic_halt_heartbeat_smi_msg,\n\t\t\t\t      &panic_halt_heartbeat_recv_msg,\n\t\t\t\t      1);\n\tif (rv)\n\t\tatomic_sub(2, &panic_done_count);\n}\n\nstatic struct ipmi_smi_msg panic_halt_smi_msg =\n\tINIT_IPMI_SMI_MSG(panic_smi_free);\nstatic struct ipmi_recv_msg panic_halt_recv_msg =\n\tINIT_IPMI_RECV_MSG(panic_recv_free);\n\n \nstatic void panic_halt_ipmi_set_timeout(void)\n{\n\tint send_heartbeat_now;\n\tint rv;\n\n\t \n\twhile (atomic_read(&panic_done_count) != 0)\n\t\tipmi_poll_interface(watchdog_user);\n\tatomic_add(2, &panic_done_count);\n\trv = __ipmi_set_timeout(&panic_halt_smi_msg,\n\t\t\t\t&panic_halt_recv_msg,\n\t\t\t\t&send_heartbeat_now);\n\tif (rv) {\n\t\tatomic_sub(2, &panic_done_count);\n\t\tpr_warn(\"Unable to extend the watchdog timeout\\n\");\n\t} else {\n\t\tif (send_heartbeat_now)\n\t\t\tpanic_halt_ipmi_heartbeat();\n\t}\n\twhile (atomic_read(&panic_done_count) != 0)\n\t\tipmi_poll_interface(watchdog_user);\n}\n\nstatic int __ipmi_heartbeat(void)\n{\n\tstruct kernel_ipmi_msg msg;\n\tint rv;\n\tstruct ipmi_system_interface_addr addr;\n\tint timeout_retries = 0;\n\nrestart:\n\t \n\tif (ipmi_watchdog_state == WDOG_TIMEOUT_NONE)\n\t\treturn 0;\n\n\tatomic_set(&msg_tofree, 2);\n\n\taddr.addr_type = IPMI_SYSTEM_INTERFACE_ADDR_TYPE;\n\taddr.channel = IPMI_BMC_CHANNEL;\n\taddr.lun = 0;\n\n\tmsg.netfn = 0x06;\n\tmsg.cmd = IPMI_WDOG_RESET_TIMER;\n\tmsg.data = NULL;\n\tmsg.data_len = 0;\n\trv = ipmi_request_supply_msgs(watchdog_user,\n\t\t\t\t      (struct ipmi_addr *) &addr,\n\t\t\t\t      0,\n\t\t\t\t      &msg,\n\t\t\t\t      NULL,\n\t\t\t\t      &smi_msg,\n\t\t\t\t      &recv_msg,\n\t\t\t\t      1);\n\tif (rv) {\n\t\tatomic_set(&msg_tofree, 0);\n\t\tpr_warn(\"heartbeat send failure: %d\\n\", rv);\n\t\treturn rv;\n\t}\n\n\t \n\twait_for_completion(&msg_wait);\n\n\tif (recv_msg.msg.data[0] == IPMI_WDOG_TIMER_NOT_INIT_RESP)  {\n\t\ttimeout_retries++;\n\t\tif (timeout_retries > 3) {\n\t\t\tpr_err(\"Unable to restore the IPMI watchdog's settings, giving up\\n\");\n\t\t\trv = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\trv = _ipmi_set_timeout(IPMI_SET_TIMEOUT_NO_HB);\n\t\tif (rv) {\n\t\t\tpr_err(\"Unable to send the command to set the watchdog's settings, giving up\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tgoto restart;\n\t} else if (recv_msg.msg.data[0] != 0) {\n\t\t \n\t\trv = -EINVAL;\n\t}\n\nout:\n\treturn rv;\n}\n\nstatic int _ipmi_heartbeat(void)\n{\n\tint rv;\n\n\tif (!watchdog_user)\n\t\treturn -ENODEV;\n\n\tif (ipmi_start_timer_on_heartbeat) {\n\t\tipmi_start_timer_on_heartbeat = 0;\n\t\tipmi_watchdog_state = action_val;\n\t\trv = _ipmi_set_timeout(IPMI_SET_TIMEOUT_FORCE_HB);\n\t} else if (atomic_cmpxchg(&pretimeout_since_last_heartbeat, 1, 0)) {\n\t\t \n\t\trv = _ipmi_set_timeout(IPMI_SET_TIMEOUT_HB_IF_NECESSARY);\n\t} else {\n\t\trv = __ipmi_heartbeat();\n\t}\n\n\treturn rv;\n}\n\nstatic int ipmi_heartbeat(void)\n{\n\tint rv;\n\n\tmutex_lock(&ipmi_watchdog_mutex);\n\trv = _ipmi_heartbeat();\n\tmutex_unlock(&ipmi_watchdog_mutex);\n\n\treturn rv;\n}\n\nstatic const struct watchdog_info ident = {\n\t.options\t= 0,\t \n\t.firmware_version = 1,\n\t.identity\t= \"IPMI\"\n};\n\nstatic int ipmi_ioctl(struct file *file,\n\t\t      unsigned int cmd, unsigned long arg)\n{\n\tvoid __user *argp = (void __user *)arg;\n\tint i;\n\tint val;\n\n\tswitch (cmd) {\n\tcase WDIOC_GETSUPPORT:\n\t\ti = copy_to_user(argp, &ident, sizeof(ident));\n\t\treturn i ? -EFAULT : 0;\n\n\tcase WDIOC_SETTIMEOUT:\n\t\ti = copy_from_user(&val, argp, sizeof(int));\n\t\tif (i)\n\t\t\treturn -EFAULT;\n\t\ttimeout = val;\n\t\treturn _ipmi_set_timeout(IPMI_SET_TIMEOUT_HB_IF_NECESSARY);\n\n\tcase WDIOC_GETTIMEOUT:\n\t\ti = copy_to_user(argp, &timeout, sizeof(timeout));\n\t\tif (i)\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\n\tcase WDIOC_SETPRETIMEOUT:\n\t\ti = copy_from_user(&val, argp, sizeof(int));\n\t\tif (i)\n\t\t\treturn -EFAULT;\n\t\tpretimeout = val;\n\t\treturn _ipmi_set_timeout(IPMI_SET_TIMEOUT_HB_IF_NECESSARY);\n\n\tcase WDIOC_GETPRETIMEOUT:\n\t\ti = copy_to_user(argp, &pretimeout, sizeof(pretimeout));\n\t\tif (i)\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\n\tcase WDIOC_KEEPALIVE:\n\t\treturn _ipmi_heartbeat();\n\n\tcase WDIOC_SETOPTIONS:\n\t\ti = copy_from_user(&val, argp, sizeof(int));\n\t\tif (i)\n\t\t\treturn -EFAULT;\n\t\tif (val & WDIOS_DISABLECARD) {\n\t\t\tipmi_watchdog_state = WDOG_TIMEOUT_NONE;\n\t\t\t_ipmi_set_timeout(IPMI_SET_TIMEOUT_NO_HB);\n\t\t\tipmi_start_timer_on_heartbeat = 0;\n\t\t}\n\n\t\tif (val & WDIOS_ENABLECARD) {\n\t\t\tipmi_watchdog_state = action_val;\n\t\t\t_ipmi_set_timeout(IPMI_SET_TIMEOUT_FORCE_HB);\n\t\t}\n\t\treturn 0;\n\n\tcase WDIOC_GETSTATUS:\n\t\tval = 0;\n\t\ti = copy_to_user(argp, &val, sizeof(val));\n\t\tif (i)\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n}\n\nstatic long ipmi_unlocked_ioctl(struct file *file,\n\t\t\t\tunsigned int cmd,\n\t\t\t\tunsigned long arg)\n{\n\tint ret;\n\n\tmutex_lock(&ipmi_watchdog_mutex);\n\tret = ipmi_ioctl(file, cmd, arg);\n\tmutex_unlock(&ipmi_watchdog_mutex);\n\n\treturn ret;\n}\n\nstatic ssize_t ipmi_write(struct file *file,\n\t\t\t  const char  __user *buf,\n\t\t\t  size_t      len,\n\t\t\t  loff_t      *ppos)\n{\n\tint rv;\n\n\tif (len) {\n\t\tif (!nowayout) {\n\t\t\tsize_t i;\n\n\t\t\t \n\t\t\texpect_close = 0;\n\n\t\t\tfor (i = 0; i != len; i++) {\n\t\t\t\tchar c;\n\n\t\t\t\tif (get_user(c, buf + i))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tif (c == 'V')\n\t\t\t\t\texpect_close = 42;\n\t\t\t}\n\t\t}\n\t\trv = ipmi_heartbeat();\n\t\tif (rv)\n\t\t\treturn rv;\n\t}\n\treturn len;\n}\n\nstatic ssize_t ipmi_read(struct file *file,\n\t\t\t char        __user *buf,\n\t\t\t size_t      count,\n\t\t\t loff_t      *ppos)\n{\n\tint          rv = 0;\n\twait_queue_entry_t wait;\n\n\tif (count <= 0)\n\t\treturn 0;\n\n\t \n\tspin_lock_irq(&ipmi_read_lock);\n\tif (!data_to_read) {\n\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\trv = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\n\t\tinit_waitqueue_entry(&wait, current);\n\t\tadd_wait_queue(&read_q, &wait);\n\t\twhile (!data_to_read && !signal_pending(current)) {\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tspin_unlock_irq(&ipmi_read_lock);\n\t\t\tschedule();\n\t\t\tspin_lock_irq(&ipmi_read_lock);\n\t\t}\n\t\tremove_wait_queue(&read_q, &wait);\n\n\t\tif (signal_pending(current)) {\n\t\t\trv = -ERESTARTSYS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tdata_to_read = 0;\n\n out:\n\tspin_unlock_irq(&ipmi_read_lock);\n\n\tif (rv == 0) {\n\t\tif (copy_to_user(buf, &data_to_read, 1))\n\t\t\trv = -EFAULT;\n\t\telse\n\t\t\trv = 1;\n\t}\n\n\treturn rv;\n}\n\nstatic int ipmi_open(struct inode *ino, struct file *filep)\n{\n\tswitch (iminor(ino)) {\n\tcase WATCHDOG_MINOR:\n\t\tif (test_and_set_bit(0, &ipmi_wdog_open))\n\t\t\treturn -EBUSY;\n\n\n\t\t \n\t\tipmi_start_timer_on_heartbeat = 1;\n\t\treturn stream_open(ino, filep);\n\n\tdefault:\n\t\treturn (-ENODEV);\n\t}\n}\n\nstatic __poll_t ipmi_poll(struct file *file, poll_table *wait)\n{\n\t__poll_t mask = 0;\n\n\tpoll_wait(file, &read_q, wait);\n\n\tspin_lock_irq(&ipmi_read_lock);\n\tif (data_to_read)\n\t\tmask |= (EPOLLIN | EPOLLRDNORM);\n\tspin_unlock_irq(&ipmi_read_lock);\n\n\treturn mask;\n}\n\nstatic int ipmi_fasync(int fd, struct file *file, int on)\n{\n\tint result;\n\n\tresult = fasync_helper(fd, file, on, &fasync_q);\n\n\treturn (result);\n}\n\nstatic int ipmi_close(struct inode *ino, struct file *filep)\n{\n\tif (iminor(ino) == WATCHDOG_MINOR) {\n\t\tif (expect_close == 42) {\n\t\t\tmutex_lock(&ipmi_watchdog_mutex);\n\t\t\tipmi_watchdog_state = WDOG_TIMEOUT_NONE;\n\t\t\t_ipmi_set_timeout(IPMI_SET_TIMEOUT_NO_HB);\n\t\t\tmutex_unlock(&ipmi_watchdog_mutex);\n\t\t} else {\n\t\t\tpr_crit(\"Unexpected close, not stopping watchdog!\\n\");\n\t\t\tipmi_heartbeat();\n\t\t}\n\t\tclear_bit(0, &ipmi_wdog_open);\n\t}\n\n\texpect_close = 0;\n\n\treturn 0;\n}\n\nstatic const struct file_operations ipmi_wdog_fops = {\n\t.owner   = THIS_MODULE,\n\t.read    = ipmi_read,\n\t.poll    = ipmi_poll,\n\t.write   = ipmi_write,\n\t.unlocked_ioctl = ipmi_unlocked_ioctl,\n\t.compat_ioctl\t= compat_ptr_ioctl,\n\t.open    = ipmi_open,\n\t.release = ipmi_close,\n\t.fasync  = ipmi_fasync,\n\t.llseek  = no_llseek,\n};\n\nstatic struct miscdevice ipmi_wdog_miscdev = {\n\t.minor\t\t= WATCHDOG_MINOR,\n\t.name\t\t= \"watchdog\",\n\t.fops\t\t= &ipmi_wdog_fops\n};\n\nstatic void ipmi_wdog_msg_handler(struct ipmi_recv_msg *msg,\n\t\t\t\t  void                 *handler_data)\n{\n\tif (msg->msg.cmd == IPMI_WDOG_RESET_TIMER &&\n\t\t\tmsg->msg.data[0] == IPMI_WDOG_TIMER_NOT_INIT_RESP)\n\t\tpr_info(\"response: The IPMI controller appears to have been reset, will attempt to reinitialize the watchdog timer\\n\");\n\telse if (msg->msg.data[0] != 0)\n\t\tpr_err(\"response: Error %x on cmd %x\\n\",\n\t\t       msg->msg.data[0],\n\t\t       msg->msg.cmd);\n\n\tipmi_free_recv_msg(msg);\n}\n\nstatic void ipmi_wdog_pretimeout_handler(void *handler_data)\n{\n\tif (preaction_val != WDOG_PRETIMEOUT_NONE) {\n\t\tif (preop_val == WDOG_PREOP_PANIC) {\n\t\t\tif (atomic_inc_and_test(&preop_panic_excl))\n\t\t\t\tpanic(\"Watchdog pre-timeout\");\n\t\t} else if (preop_val == WDOG_PREOP_GIVE_DATA) {\n\t\t\tunsigned long flags;\n\n\t\t\tspin_lock_irqsave(&ipmi_read_lock, flags);\n\t\t\tdata_to_read = 1;\n\t\t\twake_up_interruptible(&read_q);\n\t\t\tkill_fasync(&fasync_q, SIGIO, POLL_IN);\n\t\t\tspin_unlock_irqrestore(&ipmi_read_lock, flags);\n\t\t}\n\t}\n\n\t \n\tatomic_set(&pretimeout_since_last_heartbeat, 1);\n}\n\nstatic void ipmi_wdog_panic_handler(void *user_data)\n{\n\tstatic int panic_event_handled;\n\n\t \n\tif (watchdog_user && !panic_event_handled &&\n\t    ipmi_watchdog_state != WDOG_TIMEOUT_NONE) {\n\t\t \n\t\tpanic_event_handled = 1;\n\n\t\ttimeout = panic_wdt_timeout;\n\t\tpretimeout = 0;\n\t\tpanic_halt_ipmi_set_timeout();\n\t}\n}\n\nstatic const struct ipmi_user_hndl ipmi_hndlrs = {\n\t.ipmi_recv_hndl           = ipmi_wdog_msg_handler,\n\t.ipmi_watchdog_pretimeout = ipmi_wdog_pretimeout_handler,\n\t.ipmi_panic_handler       = ipmi_wdog_panic_handler\n};\n\nstatic void ipmi_register_watchdog(int ipmi_intf)\n{\n\tint rv = -EBUSY;\n\n\tif (watchdog_user)\n\t\tgoto out;\n\n\tif ((ifnum_to_use >= 0) && (ifnum_to_use != ipmi_intf))\n\t\tgoto out;\n\n\twatchdog_ifnum = ipmi_intf;\n\n\trv = ipmi_create_user(ipmi_intf, &ipmi_hndlrs, NULL, &watchdog_user);\n\tif (rv < 0) {\n\t\tpr_crit(\"Unable to register with ipmi\\n\");\n\t\tgoto out;\n\t}\n\n\trv = ipmi_get_version(watchdog_user,\n\t\t\t      &ipmi_version_major,\n\t\t\t      &ipmi_version_minor);\n\tif (rv) {\n\t\tpr_warn(\"Unable to get IPMI version, assuming 1.0\\n\");\n\t\tipmi_version_major = 1;\n\t\tipmi_version_minor = 0;\n\t}\n\n\trv = misc_register(&ipmi_wdog_miscdev);\n\tif (rv < 0) {\n\t\tipmi_destroy_user(watchdog_user);\n\t\twatchdog_user = NULL;\n\t\tpr_crit(\"Unable to register misc device\\n\");\n\t}\n\n#ifdef HAVE_DIE_NMI\n\tif (nmi_handler_registered) {\n\t\tint old_pretimeout = pretimeout;\n\t\tint old_timeout = timeout;\n\t\tint old_preop_val = preop_val;\n\n\t\t \n\t\tipmi_watchdog_state = WDOG_TIMEOUT_RESET;\n\t\tpreop_val = WDOG_PREOP_NONE;  \n\t\tpretimeout = 99;\n\t\ttimeout = 100;\n\n\t\ttesting_nmi = 1;\n\n\t\trv = ipmi_set_timeout(IPMI_SET_TIMEOUT_FORCE_HB);\n\t\tif (rv) {\n\t\t\tpr_warn(\"Error starting timer to test NMI: 0x%x.  The NMI pretimeout will likely not work\\n\",\n\t\t\t\trv);\n\t\t\trv = 0;\n\t\t\tgoto out_restore;\n\t\t}\n\n\t\tmsleep(1500);\n\n\t\tif (testing_nmi != 2) {\n\t\t\tpr_warn(\"IPMI NMI didn't seem to occur.  The NMI pretimeout will likely not work\\n\");\n\t\t}\n out_restore:\n\t\ttesting_nmi = 0;\n\t\tpreop_val = old_preop_val;\n\t\tpretimeout = old_pretimeout;\n\t\ttimeout = old_timeout;\n\t}\n#endif\n\n out:\n\tif ((start_now) && (rv == 0)) {\n\t\t \n\t\tstart_now = 0;  \n\t\tipmi_watchdog_state = action_val;\n\t\tipmi_set_timeout(IPMI_SET_TIMEOUT_FORCE_HB);\n\t\tpr_info(\"Starting now!\\n\");\n\t} else {\n\t\t \n\t\tipmi_watchdog_state = WDOG_TIMEOUT_NONE;\n\t\tipmi_set_timeout(IPMI_SET_TIMEOUT_NO_HB);\n\t}\n}\n\nstatic void ipmi_unregister_watchdog(int ipmi_intf)\n{\n\tint rv;\n\tstruct ipmi_user *loc_user = watchdog_user;\n\n\tif (!loc_user)\n\t\treturn;\n\n\tif (watchdog_ifnum != ipmi_intf)\n\t\treturn;\n\n\t \n\tmisc_deregister(&ipmi_wdog_miscdev);\n\n\twatchdog_user = NULL;\n\n\t \n\twhile (atomic_read(&msg_tofree))\n\t\tmsg_free_smi(NULL);\n\n\tmutex_lock(&ipmi_watchdog_mutex);\n\n\t \n\trv = ipmi_destroy_user(loc_user);\n\tif (rv)\n\t\tpr_warn(\"error unlinking from IPMI: %d\\n\",  rv);\n\n\t \n\tipmi_start_timer_on_heartbeat = 1;\n\n\tmutex_unlock(&ipmi_watchdog_mutex);\n}\n\n#ifdef HAVE_DIE_NMI\nstatic int\nipmi_nmi(unsigned int val, struct pt_regs *regs)\n{\n\t \n\n\tif (testing_nmi) {\n\t\ttesting_nmi = 2;\n\t\treturn NMI_HANDLED;\n\t}\n\n\t \n\tif (ipmi_watchdog_state == WDOG_TIMEOUT_NONE)\n\t\treturn NMI_DONE;\n\n\tif (preaction_val != WDOG_PRETIMEOUT_NMI)\n\t\treturn NMI_DONE;\n\n\t \n\tif (preop_val == WDOG_PREOP_PANIC) {\n\t\t \n\t\tatomic_set(&pretimeout_since_last_heartbeat, 1);\n\t\tif (atomic_inc_and_test(&preop_panic_excl))\n\t\t\tnmi_panic(regs, \"pre-timeout\");\n\t}\n\n\treturn NMI_HANDLED;\n}\n#endif\n\nstatic int wdog_reboot_handler(struct notifier_block *this,\n\t\t\t       unsigned long         code,\n\t\t\t       void                  *unused)\n{\n\tstatic int reboot_event_handled;\n\n\tif ((watchdog_user) && (!reboot_event_handled)) {\n\t\t \n\t\treboot_event_handled = 1;\n\n\t\tif (code == SYS_POWER_OFF || code == SYS_HALT) {\n\t\t\t \n\t\t\tipmi_watchdog_state = WDOG_TIMEOUT_NONE;\n\t\t\tipmi_set_timeout(IPMI_SET_TIMEOUT_NO_HB);\n\t\t} else if (ipmi_watchdog_state != WDOG_TIMEOUT_NONE) {\n\t\t\t \n\t\t\tif (timeout < 120)\n\t\t\t\ttimeout = 120;\n\t\t\tpretimeout = 0;\n\t\t\tipmi_watchdog_state = WDOG_TIMEOUT_RESET;\n\t\t\tipmi_set_timeout(IPMI_SET_TIMEOUT_NO_HB);\n\t\t}\n\t}\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block wdog_reboot_notifier = {\n\t.notifier_call\t= wdog_reboot_handler,\n\t.next\t\t= NULL,\n\t.priority\t= 0\n};\n\nstatic void ipmi_new_smi(int if_num, struct device *device)\n{\n\tipmi_register_watchdog(if_num);\n}\n\nstatic void ipmi_smi_gone(int if_num)\n{\n\tipmi_unregister_watchdog(if_num);\n}\n\nstatic struct ipmi_smi_watcher smi_watcher = {\n\t.owner    = THIS_MODULE,\n\t.new_smi  = ipmi_new_smi,\n\t.smi_gone = ipmi_smi_gone\n};\n\nstatic int action_op(const char *inval, char *outval)\n{\n\tif (outval)\n\t\tstrcpy(outval, action);\n\n\tif (!inval)\n\t\treturn 0;\n\n\tif (strcmp(inval, \"reset\") == 0)\n\t\taction_val = WDOG_TIMEOUT_RESET;\n\telse if (strcmp(inval, \"none\") == 0)\n\t\taction_val = WDOG_TIMEOUT_NONE;\n\telse if (strcmp(inval, \"power_cycle\") == 0)\n\t\taction_val = WDOG_TIMEOUT_POWER_CYCLE;\n\telse if (strcmp(inval, \"power_off\") == 0)\n\t\taction_val = WDOG_TIMEOUT_POWER_DOWN;\n\telse\n\t\treturn -EINVAL;\n\tstrcpy(action, inval);\n\treturn 0;\n}\n\nstatic int preaction_op(const char *inval, char *outval)\n{\n\tif (outval)\n\t\tstrcpy(outval, preaction);\n\n\tif (!inval)\n\t\treturn 0;\n\n\tif (strcmp(inval, \"pre_none\") == 0)\n\t\tpreaction_val = WDOG_PRETIMEOUT_NONE;\n\telse if (strcmp(inval, \"pre_smi\") == 0)\n\t\tpreaction_val = WDOG_PRETIMEOUT_SMI;\n#ifdef HAVE_DIE_NMI\n\telse if (strcmp(inval, \"pre_nmi\") == 0)\n\t\tpreaction_val = WDOG_PRETIMEOUT_NMI;\n#endif\n\telse if (strcmp(inval, \"pre_int\") == 0)\n\t\tpreaction_val = WDOG_PRETIMEOUT_MSG_INT;\n\telse\n\t\treturn -EINVAL;\n\tstrcpy(preaction, inval);\n\treturn 0;\n}\n\nstatic int preop_op(const char *inval, char *outval)\n{\n\tif (outval)\n\t\tstrcpy(outval, preop);\n\n\tif (!inval)\n\t\treturn 0;\n\n\tif (strcmp(inval, \"preop_none\") == 0)\n\t\tpreop_val = WDOG_PREOP_NONE;\n\telse if (strcmp(inval, \"preop_panic\") == 0)\n\t\tpreop_val = WDOG_PREOP_PANIC;\n\telse if (strcmp(inval, \"preop_give_data\") == 0)\n\t\tpreop_val = WDOG_PREOP_GIVE_DATA;\n\telse\n\t\treturn -EINVAL;\n\tstrcpy(preop, inval);\n\treturn 0;\n}\n\nstatic void check_parms(void)\n{\n#ifdef HAVE_DIE_NMI\n\tint do_nmi = 0;\n\tint rv;\n\n\tif (preaction_val == WDOG_PRETIMEOUT_NMI) {\n\t\tdo_nmi = 1;\n\t\tif (preop_val == WDOG_PREOP_GIVE_DATA) {\n\t\t\tpr_warn(\"Pretimeout op is to give data but NMI pretimeout is enabled, setting pretimeout op to none\\n\");\n\t\t\tpreop_op(\"preop_none\", NULL);\n\t\t\tdo_nmi = 0;\n\t\t}\n\t}\n\tif (do_nmi && !nmi_handler_registered) {\n\t\trv = register_nmi_handler(NMI_UNKNOWN, ipmi_nmi, 0,\n\t\t\t\t\t\t\"ipmi\");\n\t\tif (rv) {\n\t\t\tpr_warn(\"Can't register nmi handler\\n\");\n\t\t\treturn;\n\t\t} else\n\t\t\tnmi_handler_registered = 1;\n\t} else if (!do_nmi && nmi_handler_registered) {\n\t\tunregister_nmi_handler(NMI_UNKNOWN, \"ipmi\");\n\t\tnmi_handler_registered = 0;\n\t}\n#endif\n}\n\nstatic int __init ipmi_wdog_init(void)\n{\n\tint rv;\n\n\tif (action_op(action, NULL)) {\n\t\taction_op(\"reset\", NULL);\n\t\tpr_info(\"Unknown action '%s', defaulting to reset\\n\", action);\n\t}\n\n\tif (preaction_op(preaction, NULL)) {\n\t\tpreaction_op(\"pre_none\", NULL);\n\t\tpr_info(\"Unknown preaction '%s', defaulting to none\\n\",\n\t\t\tpreaction);\n\t}\n\n\tif (preop_op(preop, NULL)) {\n\t\tpreop_op(\"preop_none\", NULL);\n\t\tpr_info(\"Unknown preop '%s', defaulting to none\\n\", preop);\n\t}\n\n\tcheck_parms();\n\n\tregister_reboot_notifier(&wdog_reboot_notifier);\n\n\trv = ipmi_smi_watcher_register(&smi_watcher);\n\tif (rv) {\n#ifdef HAVE_DIE_NMI\n\t\tif (nmi_handler_registered)\n\t\t\tunregister_nmi_handler(NMI_UNKNOWN, \"ipmi\");\n#endif\n\t\tunregister_reboot_notifier(&wdog_reboot_notifier);\n\t\tpr_warn(\"can't register smi watcher\\n\");\n\t\treturn rv;\n\t}\n\n\tpr_info(\"driver initialized\\n\");\n\n\treturn 0;\n}\n\nstatic void __exit ipmi_wdog_exit(void)\n{\n\tipmi_smi_watcher_unregister(&smi_watcher);\n\tipmi_unregister_watchdog(watchdog_ifnum);\n\n#ifdef HAVE_DIE_NMI\n\tif (nmi_handler_registered)\n\t\tunregister_nmi_handler(NMI_UNKNOWN, \"ipmi\");\n#endif\n\n\tunregister_reboot_notifier(&wdog_reboot_notifier);\n}\nmodule_exit(ipmi_wdog_exit);\nmodule_init(ipmi_wdog_init);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Corey Minyard <minyard@mvista.com>\");\nMODULE_DESCRIPTION(\"watchdog timer based upon the IPMI interface.\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}