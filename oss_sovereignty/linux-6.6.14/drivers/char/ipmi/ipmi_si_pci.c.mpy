{
  "module_name": "ipmi_si_pci.c",
  "hash_id": "a2ba8e78e2fcc958a48af993a18b27e18539e33b8b2cb99b8179a235cbbf8efa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/ipmi/ipmi_si_pci.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"ipmi_pci: \" fmt\n\n#include <linux/module.h>\n#include <linux/pci.h>\n#include \"ipmi_si.h\"\n\nstatic bool pci_registered;\n\nstatic bool si_trypci = true;\n\nmodule_param_named(trypci, si_trypci, bool, 0);\nMODULE_PARM_DESC(trypci,\n\t\t \"Setting this to zero will disable the default scan of the interfaces identified via pci\");\n\n#define PCI_DEVICE_ID_HP_MMC 0x121A\n\nstatic int ipmi_pci_probe_regspacing(struct si_sm_io *io)\n{\n\tif (io->si_type == SI_KCS) {\n\t\tunsigned char\tstatus;\n\t\tint\t\tregspacing;\n\n\t\tio->regsize = DEFAULT_REGSIZE;\n\t\tio->regshift = 0;\n\n\t\t \n\t\tfor (regspacing = DEFAULT_REGSPACING; regspacing <= 16;) {\n\t\t\tio->regspacing = regspacing;\n\t\t\tif (io->io_setup(io)) {\n\t\t\t\tdev_err(io->dev, \"Could not setup I/O space\\n\");\n\t\t\t\treturn DEFAULT_REGSPACING;\n\t\t\t}\n\t\t\t \n\t\t\tio->outputb(io, 1, 0x10);\n\t\t\t \n\t\t\tstatus = io->inputb(io, 1);\n\t\t\tio->io_cleanup(io);\n\t\t\tif (status)\n\t\t\t\treturn regspacing;\n\t\t\tregspacing *= 4;\n\t\t}\n\t}\n\treturn DEFAULT_REGSPACING;\n}\n\nstatic struct pci_device_id ipmi_pci_blacklist[] = {\n\t \n\t{ PCI_VDEVICE(REALTEK, 0x816c) },\n\t{ 0, }\n};\n\nstatic int ipmi_pci_probe(struct pci_dev *pdev,\n\t\t\t\t    const struct pci_device_id *ent)\n{\n\tint rv;\n\tstruct si_sm_io io;\n\n\tif (pci_match_id(ipmi_pci_blacklist, pdev))\n\t\treturn -ENODEV;\n\n\tmemset(&io, 0, sizeof(io));\n\tio.addr_source = SI_PCI;\n\tdev_info(&pdev->dev, \"probing via PCI\");\n\n\tswitch (pdev->class) {\n\tcase PCI_CLASS_SERIAL_IPMI_SMIC:\n\t\tio.si_type = SI_SMIC;\n\t\tbreak;\n\n\tcase PCI_CLASS_SERIAL_IPMI_KCS:\n\t\tio.si_type = SI_KCS;\n\t\tbreak;\n\n\tcase PCI_CLASS_SERIAL_IPMI_BT:\n\t\tio.si_type = SI_BT;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_info(&pdev->dev, \"Unknown IPMI class: %x\\n\", pdev->class);\n\t\treturn -ENOMEM;\n\t}\n\n\trv = pcim_enable_device(pdev);\n\tif (rv) {\n\t\tdev_err(&pdev->dev, \"couldn't enable PCI device\\n\");\n\t\treturn rv;\n\t}\n\n\tif (pci_resource_flags(pdev, 0) & IORESOURCE_IO) {\n\t\tio.addr_space = IPMI_IO_ADDR_SPACE;\n\t\tio.io_setup = ipmi_si_port_setup;\n\t} else {\n\t\tio.addr_space = IPMI_MEM_ADDR_SPACE;\n\t\tio.io_setup = ipmi_si_mem_setup;\n\t}\n\tio.addr_data = pci_resource_start(pdev, 0);\n\n\tio.dev = &pdev->dev;\n\n\tio.regspacing = ipmi_pci_probe_regspacing(&io);\n\tio.regsize = DEFAULT_REGSIZE;\n\tio.regshift = 0;\n\n\tio.irq = pdev->irq;\n\tif (io.irq)\n\t\tio.irq_setup = ipmi_std_irq_setup;\n\n\tdev_info(&pdev->dev, \"%pR regsize %d spacing %d irq %d\\n\",\n\t\t &pdev->resource[0], io.regsize, io.regspacing, io.irq);\n\n\treturn ipmi_si_add_smi(&io);\n}\n\nstatic void ipmi_pci_remove(struct pci_dev *pdev)\n{\n\tipmi_si_remove_by_dev(&pdev->dev);\n}\n\nstatic const struct pci_device_id ipmi_pci_devices[] = {\n\t{ PCI_VDEVICE(HP, PCI_DEVICE_ID_HP_MMC) },\n\t{ PCI_DEVICE_CLASS(PCI_CLASS_SERIAL_IPMI_SMIC, ~0) },\n\t{ PCI_DEVICE_CLASS(PCI_CLASS_SERIAL_IPMI_KCS, ~0) },\n\t{ PCI_DEVICE_CLASS(PCI_CLASS_SERIAL_IPMI_BT, ~0) },\n\t{ 0, }\n};\nMODULE_DEVICE_TABLE(pci, ipmi_pci_devices);\n\nstatic struct pci_driver ipmi_pci_driver = {\n\t.name =         SI_DEVICE_NAME,\n\t.id_table =     ipmi_pci_devices,\n\t.probe =        ipmi_pci_probe,\n\t.remove =       ipmi_pci_remove,\n};\n\nvoid ipmi_si_pci_init(void)\n{\n\tif (si_trypci) {\n\t\tint rv = pci_register_driver(&ipmi_pci_driver);\n\t\tif (rv)\n\t\t\tpr_err(\"Unable to register PCI driver: %d\\n\", rv);\n\t\telse\n\t\t\tpci_registered = true;\n\t}\n}\n\nvoid ipmi_si_pci_shutdown(void)\n{\n\tif (pci_registered)\n\t\tpci_unregister_driver(&ipmi_pci_driver);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}