{
  "module_name": "ipmi_si_platform.c",
  "hash_id": "6b53371f0fccb963f762a98b06c38e4ebabca0ecd3c1e2efeea8065e749b94b4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/ipmi/ipmi_si_platform.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"ipmi_platform: \" fmt\n#define dev_fmt pr_fmt\n\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/of_device.h>\n#include <linux/of_platform.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/acpi.h>\n#include \"ipmi_si.h\"\n#include \"ipmi_dmi.h\"\n\nstatic bool platform_registered;\nstatic bool si_tryplatform = true;\n#ifdef CONFIG_ACPI\nstatic bool          si_tryacpi = true;\n#endif\n#ifdef CONFIG_OF\nstatic bool          si_tryopenfirmware = true;\n#endif\n#ifdef CONFIG_DMI\nstatic bool          si_trydmi = true;\n#else\nstatic bool          si_trydmi = false;\n#endif\n\nmodule_param_named(tryplatform, si_tryplatform, bool, 0);\nMODULE_PARM_DESC(tryplatform,\n\t\t \"Setting this to zero will disable the default scan of the interfaces identified via platform interfaces besides ACPI, OpenFirmware, and DMI\");\n#ifdef CONFIG_ACPI\nmodule_param_named(tryacpi, si_tryacpi, bool, 0);\nMODULE_PARM_DESC(tryacpi,\n\t\t \"Setting this to zero will disable the default scan of the interfaces identified via ACPI\");\n#endif\n#ifdef CONFIG_OF\nmodule_param_named(tryopenfirmware, si_tryopenfirmware, bool, 0);\nMODULE_PARM_DESC(tryopenfirmware,\n\t\t \"Setting this to zero will disable the default scan of the interfaces identified via OpenFirmware\");\n#endif\n#ifdef CONFIG_DMI\nmodule_param_named(trydmi, si_trydmi, bool, 0);\nMODULE_PARM_DESC(trydmi,\n\t\t \"Setting this to zero will disable the default scan of the interfaces identified via DMI\");\n#endif\n\n#ifdef CONFIG_ACPI\n \nstatic u32 ipmi_acpi_gpe(acpi_handle gpe_device,\n\tu32 gpe_number, void *context)\n{\n\tstruct si_sm_io *io = context;\n\n\tipmi_si_irq_handler(io->irq, io->irq_handler_data);\n\treturn ACPI_INTERRUPT_HANDLED;\n}\n\nstatic void acpi_gpe_irq_cleanup(struct si_sm_io *io)\n{\n\tif (!io->irq)\n\t\treturn;\n\n\tipmi_irq_start_cleanup(io);\n\tacpi_remove_gpe_handler(NULL, io->irq, &ipmi_acpi_gpe);\n}\n\nstatic int acpi_gpe_irq_setup(struct si_sm_io *io)\n{\n\tacpi_status status;\n\n\tif (!io->irq)\n\t\treturn 0;\n\n\tstatus = acpi_install_gpe_handler(NULL,\n\t\t\t\t\t  io->irq,\n\t\t\t\t\t  ACPI_GPE_LEVEL_TRIGGERED,\n\t\t\t\t\t  &ipmi_acpi_gpe,\n\t\t\t\t\t  io);\n\tif (ACPI_FAILURE(status)) {\n\t\tdev_warn(io->dev,\n\t\t\t \"Unable to claim ACPI GPE %d, running polled\\n\",\n\t\t\t io->irq);\n\t\tio->irq = 0;\n\t\treturn -EINVAL;\n\t}\n\n\tio->irq_cleanup = acpi_gpe_irq_cleanup;\n\tipmi_irq_finish_setup(io);\n\tdev_info(io->dev, \"Using ACPI GPE %d\\n\", io->irq);\n\treturn 0;\n}\n#endif\n\nstatic void ipmi_set_addr_data_and_space(struct resource *r, struct si_sm_io *io)\n{\n\tif (resource_type(r) == IORESOURCE_IO)\n\t\tio->addr_space = IPMI_IO_ADDR_SPACE;\n\telse\n\t\tio->addr_space = IPMI_MEM_ADDR_SPACE;\n\tio->addr_data = r->start;\n}\n\nstatic struct resource *\nipmi_get_info_from_resources(struct platform_device *pdev,\n\t\t\t     struct si_sm_io *io)\n{\n\tstruct resource *res, *res_second;\n\n\tres = platform_get_mem_or_io(pdev, 0);\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"no I/O or memory address\\n\");\n\t\treturn NULL;\n\t}\n\tipmi_set_addr_data_and_space(res, io);\n\n\tio->regspacing = DEFAULT_REGSPACING;\n\tres_second = platform_get_mem_or_io(pdev, 1);\n\tif (res_second && resource_type(res_second) == resource_type(res)) {\n\t\tif (res_second->start > io->addr_data)\n\t\t\tio->regspacing = res_second->start - io->addr_data;\n\t}\n\n\treturn res;\n}\n\nstatic int platform_ipmi_probe(struct platform_device *pdev)\n{\n\tstruct si_sm_io io;\n\tu8 type, slave_addr, addr_source, regsize, regshift;\n\tint rv;\n\n\trv = device_property_read_u8(&pdev->dev, \"addr-source\", &addr_source);\n\tif (rv)\n\t\taddr_source = SI_PLATFORM;\n\tif (addr_source >= SI_LAST)\n\t\treturn -EINVAL;\n\n\tif (addr_source == SI_SMBIOS) {\n\t\tif (!si_trydmi)\n\t\t\treturn -ENODEV;\n\t} else if (addr_source != SI_HARDCODED) {\n\t\tif (!si_tryplatform)\n\t\t\treturn -ENODEV;\n\t}\n\n\trv = device_property_read_u8(&pdev->dev, \"ipmi-type\", &type);\n\tif (rv)\n\t\treturn -ENODEV;\n\n\tmemset(&io, 0, sizeof(io));\n\tio.addr_source = addr_source;\n\tdev_info(&pdev->dev, \"probing via %s\\n\",\n\t\t ipmi_addr_src_to_str(addr_source));\n\n\tswitch (type) {\n\tcase SI_KCS:\n\tcase SI_SMIC:\n\tcase SI_BT:\n\t\tio.si_type = type;\n\t\tbreak;\n\tcase SI_TYPE_INVALID:  \n\t\treturn -ENODEV;\n\tdefault:\n\t\tdev_err(&pdev->dev, \"ipmi-type property is invalid\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tio.regsize = DEFAULT_REGSIZE;\n\trv = device_property_read_u8(&pdev->dev, \"reg-size\", &regsize);\n\tif (!rv)\n\t\tio.regsize = regsize;\n\n\tio.regshift = 0;\n\trv = device_property_read_u8(&pdev->dev, \"reg-shift\", &regshift);\n\tif (!rv)\n\t\tio.regshift = regshift;\n\n\tif (!ipmi_get_info_from_resources(pdev, &io))\n\t\treturn -EINVAL;\n\n\trv = device_property_read_u8(&pdev->dev, \"slave-addr\", &slave_addr);\n\tif (rv)\n\t\tio.slave_addr = 0x20;\n\telse\n\t\tio.slave_addr = slave_addr;\n\n\tio.irq = platform_get_irq_optional(pdev, 0);\n\tif (io.irq > 0)\n\t\tio.irq_setup = ipmi_std_irq_setup;\n\telse\n\t\tio.irq = 0;\n\n\tio.dev = &pdev->dev;\n\n\tpr_info(\"ipmi_si: %s: %s %#lx regsize %d spacing %d irq %d\\n\",\n\t\tipmi_addr_src_to_str(addr_source),\n\t\t(io.addr_space == IPMI_IO_ADDR_SPACE) ? \"io\" : \"mem\",\n\t\tio.addr_data, io.regsize, io.regspacing, io.irq);\n\n\tipmi_si_add_smi(&io);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id of_ipmi_match[] = {\n\t{ .type = \"ipmi\", .compatible = \"ipmi-kcs\",\n\t  .data = (void *)(unsigned long) SI_KCS },\n\t{ .type = \"ipmi\", .compatible = \"ipmi-smic\",\n\t  .data = (void *)(unsigned long) SI_SMIC },\n\t{ .type = \"ipmi\", .compatible = \"ipmi-bt\",\n\t  .data = (void *)(unsigned long) SI_BT },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, of_ipmi_match);\n\nstatic int of_ipmi_probe(struct platform_device *pdev)\n{\n\tconst struct of_device_id *match;\n\tstruct si_sm_io io;\n\tstruct resource resource;\n\tconst __be32 *regsize, *regspacing, *regshift;\n\tstruct device_node *np = pdev->dev.of_node;\n\tint ret;\n\tint proplen;\n\n\tif (!si_tryopenfirmware)\n\t\treturn -ENODEV;\n\n\tdev_info(&pdev->dev, \"probing via device tree\\n\");\n\n\tmatch = of_match_device(of_ipmi_match, &pdev->dev);\n\tif (!match)\n\t\treturn -ENODEV;\n\n\tif (!of_device_is_available(np))\n\t\treturn -EINVAL;\n\n\tret = of_address_to_resource(np, 0, &resource);\n\tif (ret) {\n\t\tdev_warn(&pdev->dev, \"invalid address from OF\\n\");\n\t\treturn ret;\n\t}\n\n\tregsize = of_get_property(np, \"reg-size\", &proplen);\n\tif (regsize && proplen != 4) {\n\t\tdev_warn(&pdev->dev, \"invalid regsize from OF\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tregspacing = of_get_property(np, \"reg-spacing\", &proplen);\n\tif (regspacing && proplen != 4) {\n\t\tdev_warn(&pdev->dev, \"invalid regspacing from OF\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tregshift = of_get_property(np, \"reg-shift\", &proplen);\n\tif (regshift && proplen != 4) {\n\t\tdev_warn(&pdev->dev, \"invalid regshift from OF\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(&io, 0, sizeof(io));\n\tio.si_type\t= (unsigned long) match->data;\n\tio.addr_source\t= SI_DEVICETREE;\n\tio.irq_setup\t= ipmi_std_irq_setup;\n\n\tipmi_set_addr_data_and_space(&resource, &io);\n\n\tio.regsize\t= regsize ? be32_to_cpup(regsize) : DEFAULT_REGSIZE;\n\tio.regspacing\t= regspacing ? be32_to_cpup(regspacing) : DEFAULT_REGSPACING;\n\tio.regshift\t= regshift ? be32_to_cpup(regshift) : 0;\n\n\tio.irq\t\t= irq_of_parse_and_map(pdev->dev.of_node, 0);\n\tio.dev\t\t= &pdev->dev;\n\n\tdev_dbg(&pdev->dev, \"addr 0x%lx regsize %d spacing %d irq %d\\n\",\n\t\tio.addr_data, io.regsize, io.regspacing, io.irq);\n\n\treturn ipmi_si_add_smi(&io);\n}\n#else\n#define of_ipmi_match NULL\nstatic int of_ipmi_probe(struct platform_device *dev)\n{\n\treturn -ENODEV;\n}\n#endif\n\n#ifdef CONFIG_ACPI\nstatic int find_slave_address(struct si_sm_io *io, int slave_addr)\n{\n#ifdef CONFIG_IPMI_DMI_DECODE\n\tif (!slave_addr)\n\t\tslave_addr = ipmi_dmi_get_slave_addr(io->si_type,\n\t\t\t\t\t\t     io->addr_space,\n\t\t\t\t\t\t     io->addr_data);\n#endif\n\n\treturn slave_addr;\n}\n\nstatic int acpi_ipmi_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct si_sm_io io;\n\tacpi_handle handle;\n\tacpi_status status;\n\tunsigned long long tmp;\n\tstruct resource *res;\n\n\tif (!si_tryacpi)\n\t\treturn -ENODEV;\n\n\thandle = ACPI_HANDLE(dev);\n\tif (!handle)\n\t\treturn -ENODEV;\n\n\tmemset(&io, 0, sizeof(io));\n\tio.addr_source = SI_ACPI;\n\tdev_info(dev, \"probing via ACPI\\n\");\n\n\tio.addr_info.acpi_info.acpi_handle = handle;\n\n\t \n\tstatus = acpi_evaluate_integer(handle, \"_IFT\", NULL, &tmp);\n\tif (ACPI_FAILURE(status)) {\n\t\tdev_err(dev, \"Could not find ACPI IPMI interface type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (tmp) {\n\tcase 1:\n\t\tio.si_type = SI_KCS;\n\t\tbreak;\n\tcase 2:\n\t\tio.si_type = SI_SMIC;\n\t\tbreak;\n\tcase 3:\n\t\tio.si_type = SI_BT;\n\t\tbreak;\n\tcase 4:  \n\t\treturn -ENODEV;\n\tdefault:\n\t\tdev_info(dev, \"unknown IPMI type %lld\\n\", tmp);\n\t\treturn -EINVAL;\n\t}\n\n\tio.dev = dev;\n\tio.regsize = DEFAULT_REGSIZE;\n\tio.regshift = 0;\n\n\tres = ipmi_get_info_from_resources(pdev, &io);\n\tif (!res)\n\t\treturn -EINVAL;\n\n\t \n\tstatus = acpi_evaluate_integer(handle, \"_GPE\", NULL, &tmp);\n\tif (ACPI_SUCCESS(status)) {\n\t\tio.irq = tmp;\n\t\tio.irq_setup = acpi_gpe_irq_setup;\n\t} else {\n\t\tint irq = platform_get_irq_optional(pdev, 0);\n\n\t\tif (irq > 0) {\n\t\t\tio.irq = irq;\n\t\t\tio.irq_setup = ipmi_std_irq_setup;\n\t\t}\n\t}\n\n\tio.slave_addr = find_slave_address(&io, io.slave_addr);\n\n\tdev_info(dev, \"%pR regsize %d spacing %d irq %d\\n\",\n\t\t res, io.regsize, io.regspacing, io.irq);\n\n\trequest_module_nowait(\"acpi_ipmi\");\n\n\treturn ipmi_si_add_smi(&io);\n}\n\nstatic const struct acpi_device_id acpi_ipmi_match[] = {\n\t{ \"IPI0001\", 0 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(acpi, acpi_ipmi_match);\n#else\nstatic int acpi_ipmi_probe(struct platform_device *dev)\n{\n\treturn -ENODEV;\n}\n#endif\n\nstatic int ipmi_probe(struct platform_device *pdev)\n{\n\tif (pdev->dev.of_node && of_ipmi_probe(pdev) == 0)\n\t\treturn 0;\n\n\tif (acpi_ipmi_probe(pdev) == 0)\n\t\treturn 0;\n\n\treturn platform_ipmi_probe(pdev);\n}\n\nstatic int ipmi_remove(struct platform_device *pdev)\n{\n\tipmi_si_remove_by_dev(&pdev->dev);\n\n\treturn 0;\n}\n\nstatic int pdev_match_name(struct device *dev, const void *data)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tconst char *name = data;\n\n\treturn strcmp(pdev->name, name) == 0;\n}\n\nvoid ipmi_remove_platform_device_by_name(char *name)\n{\n\tstruct device *dev;\n\n\twhile ((dev = bus_find_device(&platform_bus_type, NULL, name,\n\t\t\t\t      pdev_match_name))) {\n\t\tstruct platform_device *pdev = to_platform_device(dev);\n\n\t\tplatform_device_unregister(pdev);\n\t\tput_device(dev);\n\t}\n}\n\nstatic const struct platform_device_id si_plat_ids[] = {\n\t{ \"dmi-ipmi-si\", 0 },\n\t{ \"hardcode-ipmi-si\", 0 },\n\t{ \"hotmod-ipmi-si\", 0 },\n\t{ }\n};\n\nstruct platform_driver ipmi_platform_driver = {\n\t.driver = {\n\t\t.name = SI_DEVICE_NAME,\n\t\t.of_match_table = of_ipmi_match,\n\t\t.acpi_match_table = ACPI_PTR(acpi_ipmi_match),\n\t},\n\t.probe\t\t= ipmi_probe,\n\t.remove\t\t= ipmi_remove,\n\t.id_table       = si_plat_ids\n};\n\nvoid ipmi_si_platform_init(void)\n{\n\tint rv = platform_driver_register(&ipmi_platform_driver);\n\tif (rv)\n\t\tpr_err(\"Unable to register driver: %d\\n\", rv);\n\telse\n\t\tplatform_registered = true;\n}\n\nvoid ipmi_si_platform_shutdown(void)\n{\n\tif (platform_registered)\n\t\tplatform_driver_unregister(&ipmi_platform_driver);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}