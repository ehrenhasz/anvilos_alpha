{
  "module_name": "ipmi_poweroff.c",
  "hash_id": "a05ceeec96bd52c42e00bb4faf25f5455057937cef520a14d284de720f12d234",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/ipmi/ipmi_poweroff.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"IPMI poweroff: \" fmt\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/proc_fs.h>\n#include <linux/string.h>\n#include <linux/completion.h>\n#include <linux/pm.h>\n#include <linux/kdev_t.h>\n#include <linux/ipmi.h>\n#include <linux/ipmi_smi.h>\n\nstatic void ipmi_po_smi_gone(int if_num);\nstatic void ipmi_po_new_smi(int if_num, struct device *device);\n\n \n#define IPMI_CHASSIS_POWER_DOWN\t\t0\t \n#define IPMI_CHASSIS_POWER_CYCLE\t0x02\t \n\n \nstatic int poweroff_powercycle;\n\n \nstatic int ifnum_to_use = -1;\n\n \nstatic int ready;\nstatic struct ipmi_user *ipmi_user;\nstatic int ipmi_ifnum;\nstatic void (*specific_poweroff_func)(struct ipmi_user *user);\n\n \nstatic void (*old_poweroff_func)(void);\n\nstatic int set_param_ifnum(const char *val, const struct kernel_param *kp)\n{\n\tint rv = param_set_int(val, kp);\n\tif (rv)\n\t\treturn rv;\n\tif ((ifnum_to_use < 0) || (ifnum_to_use == ipmi_ifnum))\n\t\treturn 0;\n\n\tipmi_po_smi_gone(ipmi_ifnum);\n\tipmi_po_new_smi(ifnum_to_use, NULL);\n\treturn 0;\n}\n\nmodule_param_call(ifnum_to_use, set_param_ifnum, param_get_int,\n\t\t  &ifnum_to_use, 0644);\nMODULE_PARM_DESC(ifnum_to_use, \"The interface number to use for the watchdog \"\n\t\t \"timer.  Setting to -1 defaults to the first registered \"\n\t\t \"interface\");\n\n \nmodule_param(poweroff_powercycle, int, 0644);\nMODULE_PARM_DESC(poweroff_powercycle,\n\t\t \" Set to non-zero to enable power cycle instead of power\"\n\t\t \" down. Power cycle is contingent on hardware support,\"\n\t\t \" otherwise it defaults back to power down.\");\n\n \nstatic unsigned int mfg_id;\nstatic unsigned int prod_id;\nstatic unsigned char capabilities;\nstatic unsigned char ipmi_version;\n\n \nstatic atomic_t dummy_count = ATOMIC_INIT(0);\nstatic void dummy_smi_free(struct ipmi_smi_msg *msg)\n{\n\tatomic_dec(&dummy_count);\n}\nstatic void dummy_recv_free(struct ipmi_recv_msg *msg)\n{\n\tatomic_dec(&dummy_count);\n}\nstatic struct ipmi_smi_msg halt_smi_msg = INIT_IPMI_SMI_MSG(dummy_smi_free);\nstatic struct ipmi_recv_msg halt_recv_msg = INIT_IPMI_RECV_MSG(dummy_recv_free);\n\n\n \n\nstatic void receive_handler(struct ipmi_recv_msg *recv_msg, void *handler_data)\n{\n\tstruct completion *comp = recv_msg->user_msg_data;\n\n\tif (comp)\n\t\tcomplete(comp);\n}\n\nstatic const struct ipmi_user_hndl ipmi_poweroff_handler = {\n\t.ipmi_recv_hndl = receive_handler\n};\n\n\nstatic int ipmi_request_wait_for_response(struct ipmi_user       *user,\n\t\t\t\t\t  struct ipmi_addr       *addr,\n\t\t\t\t\t  struct kernel_ipmi_msg *send_msg)\n{\n\tint               rv;\n\tstruct completion comp;\n\n\tinit_completion(&comp);\n\n\trv = ipmi_request_supply_msgs(user, addr, 0, send_msg, &comp,\n\t\t\t\t      &halt_smi_msg, &halt_recv_msg, 0);\n\tif (rv)\n\t\treturn rv;\n\n\twait_for_completion(&comp);\n\n\treturn halt_recv_msg.msg.data[0];\n}\n\n \nstatic int ipmi_request_in_rc_mode(struct ipmi_user       *user,\n\t\t\t\t   struct ipmi_addr       *addr,\n\t\t\t\t   struct kernel_ipmi_msg *send_msg)\n{\n\tint rv;\n\n\tatomic_set(&dummy_count, 2);\n\trv = ipmi_request_supply_msgs(user, addr, 0, send_msg, NULL,\n\t\t\t\t      &halt_smi_msg, &halt_recv_msg, 0);\n\tif (rv) {\n\t\tatomic_set(&dummy_count, 0);\n\t\treturn rv;\n\t}\n\n\t \n\twhile (atomic_read(&dummy_count) > 0) {\n\t\tipmi_poll_interface(user);\n\t\tcpu_relax();\n\t}\n\n\treturn halt_recv_msg.msg.data[0];\n}\n\n \n\n#define IPMI_NETFN_ATCA\t\t\t0x2c\n#define IPMI_ATCA_SET_POWER_CMD\t\t0x11\n#define IPMI_ATCA_GET_ADDR_INFO_CMD\t0x01\n#define IPMI_PICMG_ID\t\t\t0\n\n#define IPMI_NETFN_OEM\t\t\t\t0x2e\n#define IPMI_ATCA_PPS_GRACEFUL_RESTART\t\t0x11\n#define IPMI_ATCA_PPS_IANA\t\t\t\"\\x00\\x40\\x0A\"\n#define IPMI_MOTOROLA_MANUFACTURER_ID\t\t0x0000A1\n#define IPMI_MOTOROLA_PPS_IPMC_PRODUCT_ID\t0x0051\n\nstatic void (*atca_oem_poweroff_hook)(struct ipmi_user *user);\n\nstatic void pps_poweroff_atca(struct ipmi_user *user)\n{\n\tstruct ipmi_system_interface_addr smi_addr;\n\tstruct kernel_ipmi_msg            send_msg;\n\tint                               rv;\n\t \n\tsmi_addr.addr_type = IPMI_SYSTEM_INTERFACE_ADDR_TYPE;\n\tsmi_addr.channel = IPMI_BMC_CHANNEL;\n\tsmi_addr.lun = 0;\n\n\tpr_info(\"PPS powerdown hook used\\n\");\n\n\tsend_msg.netfn = IPMI_NETFN_OEM;\n\tsend_msg.cmd = IPMI_ATCA_PPS_GRACEFUL_RESTART;\n\tsend_msg.data = IPMI_ATCA_PPS_IANA;\n\tsend_msg.data_len = 3;\n\trv = ipmi_request_in_rc_mode(user,\n\t\t\t\t     (struct ipmi_addr *) &smi_addr,\n\t\t\t\t     &send_msg);\n\tif (rv && rv != IPMI_UNKNOWN_ERR_COMPLETION_CODE)\n\t\tpr_err(\"Unable to send ATCA, IPMI error 0x%x\\n\", rv);\n\n\treturn;\n}\n\nstatic int ipmi_atca_detect(struct ipmi_user *user)\n{\n\tstruct ipmi_system_interface_addr smi_addr;\n\tstruct kernel_ipmi_msg            send_msg;\n\tint                               rv;\n\tunsigned char                     data[1];\n\n\t \n\tsmi_addr.addr_type = IPMI_SYSTEM_INTERFACE_ADDR_TYPE;\n\tsmi_addr.channel = IPMI_BMC_CHANNEL;\n\tsmi_addr.lun = 0;\n\n\t \n\tsend_msg.netfn = IPMI_NETFN_ATCA;\n\tsend_msg.cmd = IPMI_ATCA_GET_ADDR_INFO_CMD;\n\tdata[0] = IPMI_PICMG_ID;\n\tsend_msg.data = data;\n\tsend_msg.data_len = sizeof(data);\n\trv = ipmi_request_wait_for_response(user,\n\t\t\t\t\t    (struct ipmi_addr *) &smi_addr,\n\t\t\t\t\t    &send_msg);\n\n\tpr_info(\"ATCA Detect mfg 0x%X prod 0x%X\\n\", mfg_id, prod_id);\n\tif ((mfg_id == IPMI_MOTOROLA_MANUFACTURER_ID)\n\t    && (prod_id == IPMI_MOTOROLA_PPS_IPMC_PRODUCT_ID)) {\n\t\tpr_info(\"Installing Pigeon Point Systems Poweroff Hook\\n\");\n\t\tatca_oem_poweroff_hook = pps_poweroff_atca;\n\t}\n\treturn !rv;\n}\n\nstatic void ipmi_poweroff_atca(struct ipmi_user *user)\n{\n\tstruct ipmi_system_interface_addr smi_addr;\n\tstruct kernel_ipmi_msg            send_msg;\n\tint                               rv;\n\tunsigned char                     data[4];\n\n\t \n\tsmi_addr.addr_type = IPMI_SYSTEM_INTERFACE_ADDR_TYPE;\n\tsmi_addr.channel = IPMI_BMC_CHANNEL;\n\tsmi_addr.lun = 0;\n\n\tpr_info(\"Powering down via ATCA power command\\n\");\n\n\t \n\tsend_msg.netfn = IPMI_NETFN_ATCA;\n\tsend_msg.cmd = IPMI_ATCA_SET_POWER_CMD;\n\tdata[0] = IPMI_PICMG_ID;\n\tdata[1] = 0;  \n\tdata[2] = 0;  \n\tdata[3] = 0;  \n\tsend_msg.data = data;\n\tsend_msg.data_len = sizeof(data);\n\trv = ipmi_request_in_rc_mode(user,\n\t\t\t\t     (struct ipmi_addr *) &smi_addr,\n\t\t\t\t     &send_msg);\n\t \n\tif (rv && rv != IPMI_UNKNOWN_ERR_COMPLETION_CODE) {\n\t\tpr_err(\"Unable to send ATCA powerdown message, IPMI error 0x%x\\n\",\n\t\t       rv);\n\t\tgoto out;\n\t}\n\n\tif (atca_oem_poweroff_hook)\n\t\tatca_oem_poweroff_hook(user);\n out:\n\treturn;\n}\n\n \n\n#define IPMI_NETFN_OEM_1\t\t\t\t0xf8\n#define OEM_GRP_CMD_SET_RESET_STATE\t\t0x84\n#define OEM_GRP_CMD_SET_POWER_STATE\t\t0x82\n#define IPMI_NETFN_OEM_8\t\t\t\t0xf8\n#define OEM_GRP_CMD_REQUEST_HOTSWAP_CTRL\t0x80\n#define OEM_GRP_CMD_GET_SLOT_GA\t\t\t0xa3\n#define IPMI_NETFN_SENSOR_EVT\t\t\t0x10\n#define IPMI_CMD_GET_EVENT_RECEIVER\t\t0x01\n\n#define IPMI_CPI1_PRODUCT_ID\t\t0x000157\n#define IPMI_CPI1_MANUFACTURER_ID\t0x0108\n\nstatic int ipmi_cpi1_detect(struct ipmi_user *user)\n{\n\treturn ((mfg_id == IPMI_CPI1_MANUFACTURER_ID)\n\t\t&& (prod_id == IPMI_CPI1_PRODUCT_ID));\n}\n\nstatic void ipmi_poweroff_cpi1(struct ipmi_user *user)\n{\n\tstruct ipmi_system_interface_addr smi_addr;\n\tstruct ipmi_ipmb_addr             ipmb_addr;\n\tstruct kernel_ipmi_msg            send_msg;\n\tint                               rv;\n\tunsigned char                     data[1];\n\tint                               slot;\n\tunsigned char                     hotswap_ipmb;\n\tunsigned char                     aer_addr;\n\tunsigned char                     aer_lun;\n\n\t \n\tsmi_addr.addr_type = IPMI_SYSTEM_INTERFACE_ADDR_TYPE;\n\tsmi_addr.channel = IPMI_BMC_CHANNEL;\n\tsmi_addr.lun = 0;\n\n\tpr_info(\"Powering down via CPI1 power command\\n\");\n\n\t \n\tsend_msg.netfn = IPMI_NETFN_OEM_8 >> 2;\n\tsend_msg.cmd = OEM_GRP_CMD_GET_SLOT_GA;\n\tsend_msg.data = NULL;\n\tsend_msg.data_len = 0;\n\trv = ipmi_request_in_rc_mode(user,\n\t\t\t\t     (struct ipmi_addr *) &smi_addr,\n\t\t\t\t     &send_msg);\n\tif (rv)\n\t\tgoto out;\n\tslot = halt_recv_msg.msg.data[1];\n\thotswap_ipmb = (slot > 9) ? (0xb0 + 2 * slot) : (0xae + 2 * slot);\n\n\t \n\tsend_msg.netfn = IPMI_NETFN_SENSOR_EVT >> 2;\n\tsend_msg.cmd = IPMI_CMD_GET_EVENT_RECEIVER;\n\tsend_msg.data = NULL;\n\tsend_msg.data_len = 0;\n\trv = ipmi_request_in_rc_mode(user,\n\t\t\t\t     (struct ipmi_addr *) &smi_addr,\n\t\t\t\t     &send_msg);\n\tif (rv)\n\t\tgoto out;\n\taer_addr = halt_recv_msg.msg.data[1];\n\taer_lun = halt_recv_msg.msg.data[2];\n\n\t \n\tipmb_addr.addr_type = IPMI_IPMB_ADDR_TYPE;\n\tipmb_addr.channel = 0;\n\tipmb_addr.slave_addr = aer_addr;\n\tipmb_addr.lun = aer_lun;\n\n\t \n\tsend_msg.netfn = IPMI_NETFN_OEM_8 >> 2;\n\tsend_msg.cmd = OEM_GRP_CMD_REQUEST_HOTSWAP_CTRL;\n\tsend_msg.data = &hotswap_ipmb;\n\tsend_msg.data_len = 1;\n\tipmi_request_in_rc_mode(user,\n\t\t\t\t(struct ipmi_addr *) &ipmb_addr,\n\t\t\t\t&send_msg);\n\n\t \n\tsend_msg.netfn = IPMI_NETFN_OEM_1 >> 2;\n\tsend_msg.cmd = OEM_GRP_CMD_SET_RESET_STATE;\n\tsend_msg.data = data;\n\tdata[0] = 1;  \n\tsend_msg.data_len = 1;\n\trv = ipmi_request_in_rc_mode(user,\n\t\t\t\t     (struct ipmi_addr *) &smi_addr,\n\t\t\t\t     &send_msg);\n\tif (rv)\n\t\tgoto out;\n\n\t \n\tsend_msg.netfn = IPMI_NETFN_OEM_1 >> 2;\n\tsend_msg.cmd = OEM_GRP_CMD_SET_POWER_STATE;\n\tsend_msg.data = data;\n\tdata[0] = 1;  \n\tsend_msg.data_len = 1;\n\trv = ipmi_request_in_rc_mode(user,\n\t\t\t\t     (struct ipmi_addr *) &smi_addr,\n\t\t\t\t     &send_msg);\n\tif (rv)\n\t\tgoto out;\n\n out:\n\treturn;\n}\n\n \n\n#define DELL_IANA_MFR_ID {0xA2, 0x02, 0x00}\nstatic int ipmi_dell_chassis_detect(struct ipmi_user *user)\n{\n\tconst char ipmi_version_major = ipmi_version & 0xF;\n\tconst char ipmi_version_minor = (ipmi_version >> 4) & 0xF;\n\tconst char mfr[3] = DELL_IANA_MFR_ID;\n\tif (!memcmp(mfr, &mfg_id, sizeof(mfr)) &&\n\t    ipmi_version_major <= 1 &&\n\t    ipmi_version_minor < 5)\n\t\treturn 1;\n\treturn 0;\n}\n\n \n\n#define HP_IANA_MFR_ID 0x0b\n#define HP_BMC_PROD_ID 0x8201\nstatic int ipmi_hp_chassis_detect(struct ipmi_user *user)\n{\n\tif (mfg_id == HP_IANA_MFR_ID\n\t\t&& prod_id == HP_BMC_PROD_ID\n\t\t&& ipmi_version == 1)\n\t\treturn 1;\n\treturn 0;\n}\n\n \n\n#define IPMI_NETFN_CHASSIS_REQUEST\t0\n#define IPMI_CHASSIS_CONTROL_CMD\t0x02\n\nstatic int ipmi_chassis_detect(struct ipmi_user *user)\n{\n\t \n\treturn (capabilities & 0x80);\n}\n\nstatic void ipmi_poweroff_chassis(struct ipmi_user *user)\n{\n\tstruct ipmi_system_interface_addr smi_addr;\n\tstruct kernel_ipmi_msg            send_msg;\n\tint                               rv;\n\tunsigned char                     data[1];\n\n\t \n\tsmi_addr.addr_type = IPMI_SYSTEM_INTERFACE_ADDR_TYPE;\n\tsmi_addr.channel = IPMI_BMC_CHANNEL;\n\tsmi_addr.lun = 0;\n\n powercyclefailed:\n\tpr_info(\"Powering %s via IPMI chassis control command\\n\",\n\t\t(poweroff_powercycle ? \"cycle\" : \"down\"));\n\n\t \n\tsend_msg.netfn = IPMI_NETFN_CHASSIS_REQUEST;\n\tsend_msg.cmd = IPMI_CHASSIS_CONTROL_CMD;\n\tif (poweroff_powercycle)\n\t\tdata[0] = IPMI_CHASSIS_POWER_CYCLE;\n\telse\n\t\tdata[0] = IPMI_CHASSIS_POWER_DOWN;\n\tsend_msg.data = data;\n\tsend_msg.data_len = sizeof(data);\n\trv = ipmi_request_in_rc_mode(user,\n\t\t\t\t     (struct ipmi_addr *) &smi_addr,\n\t\t\t\t     &send_msg);\n\tif (rv) {\n\t\tif (poweroff_powercycle) {\n\t\t\t \n\t\t\tpr_err(\"Unable to send chassis power cycle message, IPMI error 0x%x\\n\",\n\t\t\t       rv);\n\t\t\tpoweroff_powercycle = 0;\n\t\t\tgoto powercyclefailed;\n\t\t}\n\n\t\tpr_err(\"Unable to send chassis power down message, IPMI error 0x%x\\n\",\n\t\t       rv);\n\t}\n}\n\n\n \nstruct poweroff_function {\n\tchar *platform_type;\n\tint  (*detect)(struct ipmi_user *user);\n\tvoid (*poweroff_func)(struct ipmi_user *user);\n};\n\nstatic struct poweroff_function poweroff_functions[] = {\n\t{ .platform_type\t= \"ATCA\",\n\t  .detect\t\t= ipmi_atca_detect,\n\t  .poweroff_func\t= ipmi_poweroff_atca },\n\t{ .platform_type\t= \"CPI1\",\n\t  .detect\t\t= ipmi_cpi1_detect,\n\t  .poweroff_func\t= ipmi_poweroff_cpi1 },\n\t{ .platform_type\t= \"chassis\",\n\t  .detect\t\t= ipmi_dell_chassis_detect,\n\t  .poweroff_func\t= ipmi_poweroff_chassis },\n\t{ .platform_type\t= \"chassis\",\n\t  .detect\t\t= ipmi_hp_chassis_detect,\n\t  .poweroff_func\t= ipmi_poweroff_chassis },\n\t \n\t{ .platform_type\t= \"chassis\",\n\t  .detect\t\t= ipmi_chassis_detect,\n\t  .poweroff_func\t= ipmi_poweroff_chassis },\n};\n#define NUM_PO_FUNCS ARRAY_SIZE(poweroff_functions)\n\n\n \nstatic void ipmi_poweroff_function(void)\n{\n\tif (!ready)\n\t\treturn;\n\n\t \n\tspecific_poweroff_func(ipmi_user);\n}\n\n \nstatic void ipmi_po_new_smi(int if_num, struct device *device)\n{\n\tstruct ipmi_system_interface_addr smi_addr;\n\tstruct kernel_ipmi_msg            send_msg;\n\tint                               rv;\n\tint                               i;\n\n\tif (ready)\n\t\treturn;\n\n\tif ((ifnum_to_use >= 0) && (ifnum_to_use != if_num))\n\t\treturn;\n\n\trv = ipmi_create_user(if_num, &ipmi_poweroff_handler, NULL,\n\t\t\t      &ipmi_user);\n\tif (rv) {\n\t\tpr_err(\"could not create IPMI user, error %d\\n\", rv);\n\t\treturn;\n\t}\n\n\tipmi_ifnum = if_num;\n\n\t \n\tsmi_addr.addr_type = IPMI_SYSTEM_INTERFACE_ADDR_TYPE;\n\tsmi_addr.channel = IPMI_BMC_CHANNEL;\n\tsmi_addr.lun = 0;\n\n\tsend_msg.netfn = IPMI_NETFN_APP_REQUEST;\n\tsend_msg.cmd = IPMI_GET_DEVICE_ID_CMD;\n\tsend_msg.data = NULL;\n\tsend_msg.data_len = 0;\n\trv = ipmi_request_wait_for_response(ipmi_user,\n\t\t\t\t\t    (struct ipmi_addr *) &smi_addr,\n\t\t\t\t\t    &send_msg);\n\tif (rv) {\n\t\tpr_err(\"Unable to send IPMI get device id info, IPMI error 0x%x\\n\",\n\t\t       rv);\n\t\tgoto out_err;\n\t}\n\n\tif (halt_recv_msg.msg.data_len < 12) {\n\t\tpr_err(\"(chassis) IPMI get device id info too short, was %d bytes, needed %d bytes\\n\",\n\t\t       halt_recv_msg.msg.data_len, 12);\n\t\tgoto out_err;\n\t}\n\n\tmfg_id = (halt_recv_msg.msg.data[7]\n\t\t  | (halt_recv_msg.msg.data[8] << 8)\n\t\t  | (halt_recv_msg.msg.data[9] << 16));\n\tprod_id = (halt_recv_msg.msg.data[10]\n\t\t   | (halt_recv_msg.msg.data[11] << 8));\n\tcapabilities = halt_recv_msg.msg.data[6];\n\tipmi_version = halt_recv_msg.msg.data[5];\n\n\n\t \n\tfor (i = 0; i < NUM_PO_FUNCS; i++) {\n\t\tif (poweroff_functions[i].detect(ipmi_user))\n\t\t\tgoto found;\n\t}\n\n out_err:\n\tpr_err(\"Unable to find a poweroff function that will work, giving up\\n\");\n\tipmi_destroy_user(ipmi_user);\n\treturn;\n\n found:\n\tpr_info(\"Found a %s style poweroff function\\n\",\n\t\tpoweroff_functions[i].platform_type);\n\tspecific_poweroff_func = poweroff_functions[i].poweroff_func;\n\told_poweroff_func = pm_power_off;\n\tpm_power_off = ipmi_poweroff_function;\n\tready = 1;\n}\n\nstatic void ipmi_po_smi_gone(int if_num)\n{\n\tif (!ready)\n\t\treturn;\n\n\tif (ipmi_ifnum != if_num)\n\t\treturn;\n\n\tready = 0;\n\tipmi_destroy_user(ipmi_user);\n\tpm_power_off = old_poweroff_func;\n}\n\nstatic struct ipmi_smi_watcher smi_watcher = {\n\t.owner    = THIS_MODULE,\n\t.new_smi  = ipmi_po_new_smi,\n\t.smi_gone = ipmi_po_smi_gone\n};\n\n\n#ifdef CONFIG_PROC_FS\n#include <linux/sysctl.h>\n\nstatic struct ctl_table ipmi_table[] = {\n\t{ .procname\t= \"poweroff_powercycle\",\n\t  .data\t\t= &poweroff_powercycle,\n\t  .maxlen\t= sizeof(poweroff_powercycle),\n\t  .mode\t\t= 0644,\n\t  .proc_handler\t= proc_dointvec },\n\t{ }\n};\n\nstatic struct ctl_table_header *ipmi_table_header;\n#endif  \n\n \nstatic int __init ipmi_poweroff_init(void)\n{\n\tint rv;\n\n\tpr_info(\"Copyright (C) 2004 MontaVista Software - IPMI Powerdown via sys_reboot\\n\");\n\n\tif (poweroff_powercycle)\n\t\tpr_info(\"Power cycle is enabled\\n\");\n\n#ifdef CONFIG_PROC_FS\n\tipmi_table_header = register_sysctl(\"dev/ipmi\", ipmi_table);\n\tif (!ipmi_table_header) {\n\t\tpr_err(\"Unable to register powercycle sysctl\\n\");\n\t\trv = -ENOMEM;\n\t\tgoto out_err;\n\t}\n#endif\n\n\trv = ipmi_smi_watcher_register(&smi_watcher);\n\n#ifdef CONFIG_PROC_FS\n\tif (rv) {\n\t\tunregister_sysctl_table(ipmi_table_header);\n\t\tpr_err(\"Unable to register SMI watcher: %d\\n\", rv);\n\t\tgoto out_err;\n\t}\n\n out_err:\n#endif\n\treturn rv;\n}\n\n#ifdef MODULE\nstatic void __exit ipmi_poweroff_cleanup(void)\n{\n\tint rv;\n\n#ifdef CONFIG_PROC_FS\n\tunregister_sysctl_table(ipmi_table_header);\n#endif\n\n\tipmi_smi_watcher_unregister(&smi_watcher);\n\n\tif (ready) {\n\t\trv = ipmi_destroy_user(ipmi_user);\n\t\tif (rv)\n\t\t\tpr_err(\"could not cleanup the IPMI user: 0x%x\\n\", rv);\n\t\tpm_power_off = old_poweroff_func;\n\t}\n}\nmodule_exit(ipmi_poweroff_cleanup);\n#endif\n\nmodule_init(ipmi_poweroff_init);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Corey Minyard <minyard@mvista.com>\");\nMODULE_DESCRIPTION(\"IPMI Poweroff extension to sys_reboot\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}