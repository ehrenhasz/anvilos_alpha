{
  "module_name": "ipmi_devintf.c",
  "hash_id": "c8d18c5e052bd9b13a91fcf5919d41c2fc590591d670486c6b49e5bf8b616be0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/ipmi/ipmi_devintf.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/errno.h>\n#include <linux/poll.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/ipmi.h>\n#include <linux/mutex.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/compat.h>\n\nstruct ipmi_file_private\n{\n\tstruct ipmi_user     *user;\n\tspinlock_t           recv_msg_lock;\n\tstruct list_head     recv_msgs;\n\tstruct fasync_struct *fasync_queue;\n\twait_queue_head_t    wait;\n\tstruct mutex\t     recv_mutex;\n\tint                  default_retries;\n\tunsigned int         default_retry_time_ms;\n};\n\nstatic void file_receive_handler(struct ipmi_recv_msg *msg,\n\t\t\t\t void                 *handler_data)\n{\n\tstruct ipmi_file_private *priv = handler_data;\n\tint                      was_empty;\n\tunsigned long            flags;\n\n\tspin_lock_irqsave(&priv->recv_msg_lock, flags);\n\twas_empty = list_empty(&priv->recv_msgs);\n\tlist_add_tail(&msg->link, &priv->recv_msgs);\n\tspin_unlock_irqrestore(&priv->recv_msg_lock, flags);\n\n\tif (was_empty) {\n\t\twake_up_interruptible(&priv->wait);\n\t\tkill_fasync(&priv->fasync_queue, SIGIO, POLL_IN);\n\t}\n}\n\nstatic __poll_t ipmi_poll(struct file *file, poll_table *wait)\n{\n\tstruct ipmi_file_private *priv = file->private_data;\n\t__poll_t             mask = 0;\n\tunsigned long            flags;\n\n\tpoll_wait(file, &priv->wait, wait);\n\n\tspin_lock_irqsave(&priv->recv_msg_lock, flags);\n\n\tif (!list_empty(&priv->recv_msgs))\n\t\tmask |= (EPOLLIN | EPOLLRDNORM);\n\n\tspin_unlock_irqrestore(&priv->recv_msg_lock, flags);\n\n\treturn mask;\n}\n\nstatic int ipmi_fasync(int fd, struct file *file, int on)\n{\n\tstruct ipmi_file_private *priv = file->private_data;\n\n\treturn fasync_helper(fd, file, on, &priv->fasync_queue);\n}\n\nstatic const struct ipmi_user_hndl ipmi_hndlrs =\n{\n\t.ipmi_recv_hndl\t= file_receive_handler,\n};\n\nstatic int ipmi_open(struct inode *inode, struct file *file)\n{\n\tint                      if_num = iminor(inode);\n\tint                      rv;\n\tstruct ipmi_file_private *priv;\n\n\tpriv = kmalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\trv = ipmi_create_user(if_num,\n\t\t\t      &ipmi_hndlrs,\n\t\t\t      priv,\n\t\t\t      &priv->user);\n\tif (rv) {\n\t\tkfree(priv);\n\t\tgoto out;\n\t}\n\n\tfile->private_data = priv;\n\n\tspin_lock_init(&priv->recv_msg_lock);\n\tINIT_LIST_HEAD(&priv->recv_msgs);\n\tinit_waitqueue_head(&priv->wait);\n\tpriv->fasync_queue = NULL;\n\tmutex_init(&priv->recv_mutex);\n\n\t \n\tpriv->default_retries = -1;\n\tpriv->default_retry_time_ms = 0;\n\nout:\n\treturn rv;\n}\n\nstatic int ipmi_release(struct inode *inode, struct file *file)\n{\n\tstruct ipmi_file_private *priv = file->private_data;\n\tint                      rv;\n\tstruct ipmi_recv_msg *msg, *next;\n\n\trv = ipmi_destroy_user(priv->user);\n\tif (rv)\n\t\treturn rv;\n\n\tlist_for_each_entry_safe(msg, next, &priv->recv_msgs, link)\n\t\tipmi_free_recv_msg(msg);\n\n\tkfree(priv);\n\n\treturn 0;\n}\n\nstatic int handle_send_req(struct ipmi_user *user,\n\t\t\t   struct ipmi_req *req,\n\t\t\t   int             retries,\n\t\t\t   unsigned int    retry_time_ms)\n{\n\tint              rv;\n\tstruct ipmi_addr addr;\n\tstruct kernel_ipmi_msg msg;\n\n\tif (req->addr_len > sizeof(struct ipmi_addr))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&addr, req->addr, req->addr_len))\n\t\treturn -EFAULT;\n\n\tmsg.netfn = req->msg.netfn;\n\tmsg.cmd = req->msg.cmd;\n\tmsg.data_len = req->msg.data_len;\n\tmsg.data = kmalloc(IPMI_MAX_MSG_LENGTH, GFP_KERNEL);\n\tif (!msg.data)\n\t\treturn -ENOMEM;\n\n\t \n\n\trv = ipmi_validate_addr(&addr, req->addr_len);\n\tif (rv)\n\t\tgoto out;\n\n\tif (req->msg.data != NULL) {\n\t\tif (req->msg.data_len > IPMI_MAX_MSG_LENGTH) {\n\t\t\trv = -EMSGSIZE;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (copy_from_user(msg.data,\n\t\t\t\t   req->msg.data,\n\t\t\t\t   req->msg.data_len)) {\n\t\t\trv = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tmsg.data_len = 0;\n\t}\n\n\trv = ipmi_request_settime(user,\n\t\t\t\t  &addr,\n\t\t\t\t  req->msgid,\n\t\t\t\t  &msg,\n\t\t\t\t  NULL,\n\t\t\t\t  0,\n\t\t\t\t  retries,\n\t\t\t\t  retry_time_ms);\n out:\n\tkfree(msg.data);\n\treturn rv;\n}\n\nstatic int handle_recv(struct ipmi_file_private *priv,\n\t\t\tbool trunc, struct ipmi_recv *rsp,\n\t\t\tint (*copyout)(struct ipmi_recv *, void __user *),\n\t\t\tvoid __user *to)\n{\n\tint              addr_len;\n\tstruct list_head *entry;\n\tstruct ipmi_recv_msg  *msg;\n\tunsigned long    flags;\n\tint rv = 0, rv2 = 0;\n\n\t \n\tmutex_lock(&priv->recv_mutex);\n\n\t \n\tspin_lock_irqsave(&priv->recv_msg_lock, flags);\n\tif (list_empty(&(priv->recv_msgs))) {\n\t\tspin_unlock_irqrestore(&priv->recv_msg_lock, flags);\n\t\trv = -EAGAIN;\n\t\tgoto recv_err;\n\t}\n\tentry = priv->recv_msgs.next;\n\tmsg = list_entry(entry, struct ipmi_recv_msg, link);\n\tlist_del(entry);\n\tspin_unlock_irqrestore(&priv->recv_msg_lock, flags);\n\n\taddr_len = ipmi_addr_length(msg->addr.addr_type);\n\tif (rsp->addr_len < addr_len) {\n\t\trv = -EINVAL;\n\t\tgoto recv_putback_on_err;\n\t}\n\n\tif (copy_to_user(rsp->addr, &msg->addr, addr_len)) {\n\t\trv = -EFAULT;\n\t\tgoto recv_putback_on_err;\n\t}\n\trsp->addr_len = addr_len;\n\n\trsp->recv_type = msg->recv_type;\n\trsp->msgid = msg->msgid;\n\trsp->msg.netfn = msg->msg.netfn;\n\trsp->msg.cmd = msg->msg.cmd;\n\n\tif (msg->msg.data_len > 0) {\n\t\tif (rsp->msg.data_len < msg->msg.data_len) {\n\t\t\tif (trunc) {\n\t\t\t\trv2 = -EMSGSIZE;\n\t\t\t\tmsg->msg.data_len = rsp->msg.data_len;\n\t\t\t} else {\n\t\t\t\trv = -EMSGSIZE;\n\t\t\t\tgoto recv_putback_on_err;\n\t\t\t}\n\t\t}\n\n\t\tif (copy_to_user(rsp->msg.data,\n\t\t\t\t msg->msg.data,\n\t\t\t\t msg->msg.data_len)) {\n\t\t\trv = -EFAULT;\n\t\t\tgoto recv_putback_on_err;\n\t\t}\n\t\trsp->msg.data_len = msg->msg.data_len;\n\t} else {\n\t\trsp->msg.data_len = 0;\n\t}\n\n\trv = copyout(rsp, to);\n\tif (rv)\n\t\tgoto recv_putback_on_err;\n\n\tmutex_unlock(&priv->recv_mutex);\n\tipmi_free_recv_msg(msg);\n\treturn rv2;\n\nrecv_putback_on_err:\n\t \n\tspin_lock_irqsave(&priv->recv_msg_lock, flags);\n\tlist_add(entry, &priv->recv_msgs);\n\tspin_unlock_irqrestore(&priv->recv_msg_lock, flags);\nrecv_err:\n\tmutex_unlock(&priv->recv_mutex);\n\treturn rv;\n}\n\nstatic int copyout_recv(struct ipmi_recv *rsp, void __user *to)\n{\n\treturn copy_to_user(to, rsp, sizeof(struct ipmi_recv)) ? -EFAULT : 0;\n}\n\nstatic long ipmi_ioctl(struct file   *file,\n\t\t       unsigned int  cmd,\n\t\t       unsigned long data)\n{\n\tint                      rv = -EINVAL;\n\tstruct ipmi_file_private *priv = file->private_data;\n\tvoid __user *arg = (void __user *)data;\n\n\tswitch (cmd) \n\t{\n\tcase IPMICTL_SEND_COMMAND:\n\t{\n\t\tstruct ipmi_req req;\n\t\tint retries;\n\t\tunsigned int retry_time_ms;\n\n\t\tif (copy_from_user(&req, arg, sizeof(req))) {\n\t\t\trv = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tmutex_lock(&priv->recv_mutex);\n\t\tretries = priv->default_retries;\n\t\tretry_time_ms = priv->default_retry_time_ms;\n\t\tmutex_unlock(&priv->recv_mutex);\n\n\t\trv = handle_send_req(priv->user, &req, retries, retry_time_ms);\n\t\tbreak;\n\t}\n\n\tcase IPMICTL_SEND_COMMAND_SETTIME:\n\t{\n\t\tstruct ipmi_req_settime req;\n\n\t\tif (copy_from_user(&req, arg, sizeof(req))) {\n\t\t\trv = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\trv = handle_send_req(priv->user,\n\t\t\t\t     &req.req,\n\t\t\t\t     req.retries,\n\t\t\t\t     req.retry_time_ms);\n\t\tbreak;\n\t}\n\n\tcase IPMICTL_RECEIVE_MSG:\n\tcase IPMICTL_RECEIVE_MSG_TRUNC:\n\t{\n\t\tstruct ipmi_recv      rsp;\n\n\t\tif (copy_from_user(&rsp, arg, sizeof(rsp)))\n\t\t\trv = -EFAULT;\n\t\telse\n\t\t\trv = handle_recv(priv, cmd == IPMICTL_RECEIVE_MSG_TRUNC,\n\t\t\t\t\t &rsp, copyout_recv, arg);\n\t\tbreak;\n\t}\n\n\tcase IPMICTL_REGISTER_FOR_CMD:\n\t{\n\t\tstruct ipmi_cmdspec val;\n\n\t\tif (copy_from_user(&val, arg, sizeof(val))) {\n\t\t\trv = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\trv = ipmi_register_for_cmd(priv->user, val.netfn, val.cmd,\n\t\t\t\t\t   IPMI_CHAN_ALL);\n\t\tbreak;\n\t}\n\n\tcase IPMICTL_UNREGISTER_FOR_CMD:\n\t{\n\t\tstruct ipmi_cmdspec   val;\n\n\t\tif (copy_from_user(&val, arg, sizeof(val))) {\n\t\t\trv = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\trv = ipmi_unregister_for_cmd(priv->user, val.netfn, val.cmd,\n\t\t\t\t\t     IPMI_CHAN_ALL);\n\t\tbreak;\n\t}\n\n\tcase IPMICTL_REGISTER_FOR_CMD_CHANS:\n\t{\n\t\tstruct ipmi_cmdspec_chans val;\n\n\t\tif (copy_from_user(&val, arg, sizeof(val))) {\n\t\t\trv = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\trv = ipmi_register_for_cmd(priv->user, val.netfn, val.cmd,\n\t\t\t\t\t   val.chans);\n\t\tbreak;\n\t}\n\n\tcase IPMICTL_UNREGISTER_FOR_CMD_CHANS:\n\t{\n\t\tstruct ipmi_cmdspec_chans val;\n\n\t\tif (copy_from_user(&val, arg, sizeof(val))) {\n\t\t\trv = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\trv = ipmi_unregister_for_cmd(priv->user, val.netfn, val.cmd,\n\t\t\t\t\t     val.chans);\n\t\tbreak;\n\t}\n\n\tcase IPMICTL_SET_GETS_EVENTS_CMD:\n\t{\n\t\tint val;\n\n\t\tif (copy_from_user(&val, arg, sizeof(val))) {\n\t\t\trv = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\trv = ipmi_set_gets_events(priv->user, val);\n\t\tbreak;\n\t}\n\n\t \n\tcase IPMICTL_SET_MY_ADDRESS_CMD:\n\t{\n\t\tunsigned int val;\n\n\t\tif (copy_from_user(&val, arg, sizeof(val))) {\n\t\t\trv = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\trv = ipmi_set_my_address(priv->user, 0, val);\n\t\tbreak;\n\t}\n\n\tcase IPMICTL_GET_MY_ADDRESS_CMD:\n\t{\n\t\tunsigned int  val;\n\t\tunsigned char rval;\n\n\t\trv = ipmi_get_my_address(priv->user, 0, &rval);\n\t\tif (rv)\n\t\t\tbreak;\n\n\t\tval = rval;\n\n\t\tif (copy_to_user(arg, &val, sizeof(val))) {\n\t\t\trv = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase IPMICTL_SET_MY_LUN_CMD:\n\t{\n\t\tunsigned int val;\n\n\t\tif (copy_from_user(&val, arg, sizeof(val))) {\n\t\t\trv = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\trv = ipmi_set_my_LUN(priv->user, 0, val);\n\t\tbreak;\n\t}\n\n\tcase IPMICTL_GET_MY_LUN_CMD:\n\t{\n\t\tunsigned int  val;\n\t\tunsigned char rval;\n\n\t\trv = ipmi_get_my_LUN(priv->user, 0, &rval);\n\t\tif (rv)\n\t\t\tbreak;\n\n\t\tval = rval;\n\n\t\tif (copy_to_user(arg, &val, sizeof(val))) {\n\t\t\trv = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase IPMICTL_SET_MY_CHANNEL_ADDRESS_CMD:\n\t{\n\t\tstruct ipmi_channel_lun_address_set val;\n\n\t\tif (copy_from_user(&val, arg, sizeof(val))) {\n\t\t\trv = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\treturn ipmi_set_my_address(priv->user, val.channel, val.value);\n\t}\n\n\tcase IPMICTL_GET_MY_CHANNEL_ADDRESS_CMD:\n\t{\n\t\tstruct ipmi_channel_lun_address_set val;\n\n\t\tif (copy_from_user(&val, arg, sizeof(val))) {\n\t\t\trv = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\trv = ipmi_get_my_address(priv->user, val.channel, &val.value);\n\t\tif (rv)\n\t\t\tbreak;\n\n\t\tif (copy_to_user(arg, &val, sizeof(val))) {\n\t\t\trv = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase IPMICTL_SET_MY_CHANNEL_LUN_CMD:\n\t{\n\t\tstruct ipmi_channel_lun_address_set val;\n\n\t\tif (copy_from_user(&val, arg, sizeof(val))) {\n\t\t\trv = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\trv = ipmi_set_my_LUN(priv->user, val.channel, val.value);\n\t\tbreak;\n\t}\n\n\tcase IPMICTL_GET_MY_CHANNEL_LUN_CMD:\n\t{\n\t\tstruct ipmi_channel_lun_address_set val;\n\n\t\tif (copy_from_user(&val, arg, sizeof(val))) {\n\t\t\trv = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\trv = ipmi_get_my_LUN(priv->user, val.channel, &val.value);\n\t\tif (rv)\n\t\t\tbreak;\n\n\t\tif (copy_to_user(arg, &val, sizeof(val))) {\n\t\t\trv = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase IPMICTL_SET_TIMING_PARMS_CMD:\n\t{\n\t\tstruct ipmi_timing_parms parms;\n\n\t\tif (copy_from_user(&parms, arg, sizeof(parms))) {\n\t\t\trv = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tmutex_lock(&priv->recv_mutex);\n\t\tpriv->default_retries = parms.retries;\n\t\tpriv->default_retry_time_ms = parms.retry_time_ms;\n\t\tmutex_unlock(&priv->recv_mutex);\n\t\trv = 0;\n\t\tbreak;\n\t}\n\n\tcase IPMICTL_GET_TIMING_PARMS_CMD:\n\t{\n\t\tstruct ipmi_timing_parms parms;\n\n\t\tmutex_lock(&priv->recv_mutex);\n\t\tparms.retries = priv->default_retries;\n\t\tparms.retry_time_ms = priv->default_retry_time_ms;\n\t\tmutex_unlock(&priv->recv_mutex);\n\n\t\tif (copy_to_user(arg, &parms, sizeof(parms))) {\n\t\t\trv = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\trv = 0;\n\t\tbreak;\n\t}\n\n\tcase IPMICTL_GET_MAINTENANCE_MODE_CMD:\n\t{\n\t\tint mode;\n\n\t\tmode = ipmi_get_maintenance_mode(priv->user);\n\t\tif (copy_to_user(arg, &mode, sizeof(mode))) {\n\t\t\trv = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\trv = 0;\n\t\tbreak;\n\t}\n\n\tcase IPMICTL_SET_MAINTENANCE_MODE_CMD:\n\t{\n\t\tint mode;\n\n\t\tif (copy_from_user(&mode, arg, sizeof(mode))) {\n\t\t\trv = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\trv = ipmi_set_maintenance_mode(priv->user, mode);\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\trv = -ENOTTY;\n\t\tbreak;\n\t}\n  \n\treturn rv;\n}\n\n#ifdef CONFIG_COMPAT\n \n#define COMPAT_IPMICTL_SEND_COMMAND\t\\\n\t_IOR(IPMI_IOC_MAGIC, 13, struct compat_ipmi_req)\n#define COMPAT_IPMICTL_SEND_COMMAND_SETTIME\t\\\n\t_IOR(IPMI_IOC_MAGIC, 21, struct compat_ipmi_req_settime)\n#define COMPAT_IPMICTL_RECEIVE_MSG\t\\\n\t_IOWR(IPMI_IOC_MAGIC, 12, struct compat_ipmi_recv)\n#define COMPAT_IPMICTL_RECEIVE_MSG_TRUNC\t\\\n\t_IOWR(IPMI_IOC_MAGIC, 11, struct compat_ipmi_recv)\n\nstruct compat_ipmi_msg {\n\tu8\t\tnetfn;\n\tu8\t\tcmd;\n\tu16\t\tdata_len;\n\tcompat_uptr_t\tdata;\n};\n\nstruct compat_ipmi_req {\n\tcompat_uptr_t\t\taddr;\n\tcompat_uint_t\t\taddr_len;\n\tcompat_long_t\t\tmsgid;\n\tstruct compat_ipmi_msg\tmsg;\n};\n\nstruct compat_ipmi_recv {\n\tcompat_int_t\t\trecv_type;\n\tcompat_uptr_t\t\taddr;\n\tcompat_uint_t\t\taddr_len;\n\tcompat_long_t\t\tmsgid;\n\tstruct compat_ipmi_msg\tmsg;\n};\n\nstruct compat_ipmi_req_settime {\n\tstruct compat_ipmi_req\treq;\n\tcompat_int_t\t\tretries;\n\tcompat_uint_t\t\tretry_time_ms;\n};\n\n \nstatic void get_compat_ipmi_msg(struct ipmi_msg *p64,\n\t\t\t\tstruct compat_ipmi_msg *p32)\n{\n\tp64->netfn = p32->netfn;\n\tp64->cmd = p32->cmd;\n\tp64->data_len = p32->data_len;\n\tp64->data = compat_ptr(p32->data);\n}\n\nstatic void get_compat_ipmi_req(struct ipmi_req *p64,\n\t\t\t\tstruct compat_ipmi_req *p32)\n{\n\tp64->addr = compat_ptr(p32->addr);\n\tp64->addr_len = p32->addr_len;\n\tp64->msgid = p32->msgid;\n\tget_compat_ipmi_msg(&p64->msg, &p32->msg);\n}\n\nstatic void get_compat_ipmi_req_settime(struct ipmi_req_settime *p64,\n\t\tstruct compat_ipmi_req_settime *p32)\n{\n\tget_compat_ipmi_req(&p64->req, &p32->req);\n\tp64->retries = p32->retries;\n\tp64->retry_time_ms = p32->retry_time_ms;\n}\n\nstatic void get_compat_ipmi_recv(struct ipmi_recv *p64,\n\t\t\t\t struct compat_ipmi_recv *p32)\n{\n\tmemset(p64, 0, sizeof(struct ipmi_recv));\n\tp64->recv_type = p32->recv_type;\n\tp64->addr = compat_ptr(p32->addr);\n\tp64->addr_len = p32->addr_len;\n\tp64->msgid = p32->msgid;\n\tget_compat_ipmi_msg(&p64->msg, &p32->msg);\n}\n\nstatic int copyout_recv32(struct ipmi_recv *p64, void __user *to)\n{\n\tstruct compat_ipmi_recv v32;\n\tmemset(&v32, 0, sizeof(struct compat_ipmi_recv));\n\tv32.recv_type = p64->recv_type;\n\tv32.addr = ptr_to_compat(p64->addr);\n\tv32.addr_len = p64->addr_len;\n\tv32.msgid = p64->msgid;\n\tv32.msg.netfn = p64->msg.netfn;\n\tv32.msg.cmd = p64->msg.cmd;\n\tv32.msg.data_len = p64->msg.data_len;\n\tv32.msg.data = ptr_to_compat(p64->msg.data);\n\treturn copy_to_user(to, &v32, sizeof(v32)) ? -EFAULT : 0;\n}\n\n \nstatic long compat_ipmi_ioctl(struct file *filep, unsigned int cmd,\n\t\t\t      unsigned long arg)\n{\n\tstruct ipmi_file_private *priv = filep->private_data;\n\n\tswitch(cmd) {\n\tcase COMPAT_IPMICTL_SEND_COMMAND:\n\t{\n\t\tstruct ipmi_req\trp;\n\t\tstruct compat_ipmi_req r32;\n\t\tint retries;\n\t\tunsigned int retry_time_ms;\n\n\t\tif (copy_from_user(&r32, compat_ptr(arg), sizeof(r32)))\n\t\t\treturn -EFAULT;\n\n\t\tget_compat_ipmi_req(&rp, &r32);\n\n\t\tmutex_lock(&priv->recv_mutex);\n\t\tretries = priv->default_retries;\n\t\tretry_time_ms = priv->default_retry_time_ms;\n\t\tmutex_unlock(&priv->recv_mutex);\n\n\t\treturn handle_send_req(priv->user, &rp,\n\t\t\t\t       retries, retry_time_ms);\n\t}\n\tcase COMPAT_IPMICTL_SEND_COMMAND_SETTIME:\n\t{\n\t\tstruct ipmi_req_settime\tsp;\n\t\tstruct compat_ipmi_req_settime sp32;\n\n\t\tif (copy_from_user(&sp32, compat_ptr(arg), sizeof(sp32)))\n\t\t\treturn -EFAULT;\n\n\t\tget_compat_ipmi_req_settime(&sp, &sp32);\n\n\t\treturn handle_send_req(priv->user, &sp.req,\n\t\t\t\tsp.retries, sp.retry_time_ms);\n\t}\n\tcase COMPAT_IPMICTL_RECEIVE_MSG:\n\tcase COMPAT_IPMICTL_RECEIVE_MSG_TRUNC:\n\t{\n\t\tstruct ipmi_recv   recv64;\n\t\tstruct compat_ipmi_recv recv32;\n\n\t\tif (copy_from_user(&recv32, compat_ptr(arg), sizeof(recv32)))\n\t\t\treturn -EFAULT;\n\n\t\tget_compat_ipmi_recv(&recv64, &recv32);\n\n\t\treturn handle_recv(priv,\n\t\t\t\t cmd == COMPAT_IPMICTL_RECEIVE_MSG_TRUNC,\n\t\t\t\t &recv64, copyout_recv32, compat_ptr(arg));\n\t}\n\tdefault:\n\t\treturn ipmi_ioctl(filep, cmd, arg);\n\t}\n}\n#endif\n\nstatic const struct file_operations ipmi_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.unlocked_ioctl\t= ipmi_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl   = compat_ipmi_ioctl,\n#endif\n\t.open\t\t= ipmi_open,\n\t.release\t= ipmi_release,\n\t.fasync\t\t= ipmi_fasync,\n\t.poll\t\t= ipmi_poll,\n\t.llseek\t\t= noop_llseek,\n};\n\n#define DEVICE_NAME     \"ipmidev\"\n\nstatic int ipmi_major;\nmodule_param(ipmi_major, int, 0);\nMODULE_PARM_DESC(ipmi_major, \"Sets the major number of the IPMI device.  By\"\n\t\t \" default, or if you set it to zero, it will choose the next\"\n\t\t \" available device.  Setting it to -1 will disable the\"\n\t\t \" interface.  Other values will set the major device number\"\n\t\t \" to that value.\");\n\n \nstruct ipmi_reg_list {\n\tdev_t            dev;\n\tstruct list_head link;\n};\nstatic LIST_HEAD(reg_list);\nstatic DEFINE_MUTEX(reg_list_mutex);\n\nstatic const struct class ipmi_class = {\n\t.name = \"ipmi\",\n};\n\nstatic void ipmi_new_smi(int if_num, struct device *device)\n{\n\tdev_t dev = MKDEV(ipmi_major, if_num);\n\tstruct ipmi_reg_list *entry;\n\n\tentry = kmalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry) {\n\t\tpr_err(\"ipmi_devintf: Unable to create the ipmi class device link\\n\");\n\t\treturn;\n\t}\n\tentry->dev = dev;\n\n\tmutex_lock(&reg_list_mutex);\n\tdevice_create(&ipmi_class, device, dev, NULL, \"ipmi%d\", if_num);\n\tlist_add(&entry->link, &reg_list);\n\tmutex_unlock(&reg_list_mutex);\n}\n\nstatic void ipmi_smi_gone(int if_num)\n{\n\tdev_t dev = MKDEV(ipmi_major, if_num);\n\tstruct ipmi_reg_list *entry;\n\n\tmutex_lock(&reg_list_mutex);\n\tlist_for_each_entry(entry, &reg_list, link) {\n\t\tif (entry->dev == dev) {\n\t\t\tlist_del(&entry->link);\n\t\t\tkfree(entry);\n\t\t\tbreak;\n\t\t}\n\t}\n\tdevice_destroy(&ipmi_class, dev);\n\tmutex_unlock(&reg_list_mutex);\n}\n\nstatic struct ipmi_smi_watcher smi_watcher =\n{\n\t.owner    = THIS_MODULE,\n\t.new_smi  = ipmi_new_smi,\n\t.smi_gone = ipmi_smi_gone,\n};\n\nstatic int __init init_ipmi_devintf(void)\n{\n\tint rv;\n\n\tif (ipmi_major < 0)\n\t\treturn -EINVAL;\n\n\tpr_info(\"ipmi device interface\\n\");\n\n\trv = class_register(&ipmi_class);\n\tif (rv)\n\t\treturn rv;\n\n\trv = register_chrdev(ipmi_major, DEVICE_NAME, &ipmi_fops);\n\tif (rv < 0) {\n\t\tclass_unregister(&ipmi_class);\n\t\tpr_err(\"ipmi: can't get major %d\\n\", ipmi_major);\n\t\treturn rv;\n\t}\n\n\tif (ipmi_major == 0) {\n\t\tipmi_major = rv;\n\t}\n\n\trv = ipmi_smi_watcher_register(&smi_watcher);\n\tif (rv) {\n\t\tunregister_chrdev(ipmi_major, DEVICE_NAME);\n\t\tclass_unregister(&ipmi_class);\n\t\tpr_warn(\"ipmi: can't register smi watcher\\n\");\n\t\treturn rv;\n\t}\n\n\treturn 0;\n}\nmodule_init(init_ipmi_devintf);\n\nstatic void __exit cleanup_ipmi(void)\n{\n\tstruct ipmi_reg_list *entry, *entry2;\n\tmutex_lock(&reg_list_mutex);\n\tlist_for_each_entry_safe(entry, entry2, &reg_list, link) {\n\t\tlist_del(&entry->link);\n\t\tdevice_destroy(&ipmi_class, entry->dev);\n\t\tkfree(entry);\n\t}\n\tmutex_unlock(&reg_list_mutex);\n\tclass_unregister(&ipmi_class);\n\tipmi_smi_watcher_unregister(&smi_watcher);\n\tunregister_chrdev(ipmi_major, DEVICE_NAME);\n}\nmodule_exit(cleanup_ipmi);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Corey Minyard <minyard@mvista.com>\");\nMODULE_DESCRIPTION(\"Linux device interface for the IPMI message handler.\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}