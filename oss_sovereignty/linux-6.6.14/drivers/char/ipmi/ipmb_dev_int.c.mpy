{
  "module_name": "ipmb_dev_int.c",
  "hash_id": "f46810a8e9e445e37a522ac0db87b1b38ec72d5b97a7842f0ae5ca6a6e670a35",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/ipmi/ipmb_dev_int.c",
  "human_readable_source": "\n\n \n\n#include <linux/acpi.h>\n#include <linux/errno.h>\n#include <linux/i2c.h>\n#include <linux/miscdevice.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/wait.h>\n\n#define MAX_MSG_LEN\t\t240\n#define IPMB_REQUEST_LEN_MIN\t7\n#define NETFN_RSP_BIT_MASK\t0x4\n#define REQUEST_QUEUE_MAX_LEN\t256\n\n#define IPMB_MSG_LEN_IDX\t0\n#define RQ_SA_8BIT_IDX\t\t1\n#define NETFN_LUN_IDX\t\t2\n\n#define GET_7BIT_ADDR(addr_8bit)\t(addr_8bit >> 1)\n#define GET_8BIT_ADDR(addr_7bit)\t((addr_7bit << 1) & 0xff)\n\n#define IPMB_MSG_PAYLOAD_LEN_MAX (MAX_MSG_LEN - IPMB_REQUEST_LEN_MIN - 1)\n\n#define SMBUS_MSG_HEADER_LENGTH\t2\n#define SMBUS_MSG_IDX_OFFSET\t(SMBUS_MSG_HEADER_LENGTH + 1)\n\nstruct ipmb_msg {\n\tu8 len;\n\tu8 rs_sa;\n\tu8 netfn_rs_lun;\n\tu8 checksum1;\n\tu8 rq_sa;\n\tu8 rq_seq_rq_lun;\n\tu8 cmd;\n\tu8 payload[IPMB_MSG_PAYLOAD_LEN_MAX];\n\t \n} __packed;\n\nstruct ipmb_request_elem {\n\tstruct list_head list;\n\tstruct ipmb_msg request;\n};\n\nstruct ipmb_dev {\n\tstruct i2c_client *client;\n\tstruct miscdevice miscdev;\n\tstruct ipmb_msg request;\n\tstruct list_head request_queue;\n\tatomic_t request_queue_len;\n\tsize_t msg_idx;\n\tspinlock_t lock;\n\twait_queue_head_t wait_queue;\n\tstruct mutex file_mutex;\n\tbool is_i2c_protocol;\n};\n\nstatic inline struct ipmb_dev *to_ipmb_dev(struct file *file)\n{\n\treturn container_of(file->private_data, struct ipmb_dev, miscdev);\n}\n\nstatic ssize_t ipmb_read(struct file *file, char __user *buf, size_t count,\n\t\t\tloff_t *ppos)\n{\n\tstruct ipmb_dev *ipmb_dev = to_ipmb_dev(file);\n\tstruct ipmb_request_elem *queue_elem;\n\tstruct ipmb_msg msg;\n\tssize_t ret = 0;\n\n\tmemset(&msg, 0, sizeof(msg));\n\n\tspin_lock_irq(&ipmb_dev->lock);\n\n\twhile (list_empty(&ipmb_dev->request_queue)) {\n\t\tspin_unlock_irq(&ipmb_dev->lock);\n\n\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\n\t\tret = wait_event_interruptible(ipmb_dev->wait_queue,\n\t\t\t\t!list_empty(&ipmb_dev->request_queue));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tspin_lock_irq(&ipmb_dev->lock);\n\t}\n\n\tqueue_elem = list_first_entry(&ipmb_dev->request_queue,\n\t\t\t\t\tstruct ipmb_request_elem, list);\n\tmemcpy(&msg, &queue_elem->request, sizeof(msg));\n\tlist_del(&queue_elem->list);\n\tkfree(queue_elem);\n\tatomic_dec(&ipmb_dev->request_queue_len);\n\n\tspin_unlock_irq(&ipmb_dev->lock);\n\n\tcount = min_t(size_t, count, msg.len + 1);\n\tif (copy_to_user(buf, &msg, count))\n\t\tret = -EFAULT;\n\n\treturn ret < 0 ? ret : count;\n}\n\nstatic int ipmb_i2c_write(struct i2c_client *client, u8 *msg, u8 addr)\n{\n\tstruct i2c_msg i2c_msg;\n\n\t \n\ti2c_msg.len = msg[IPMB_MSG_LEN_IDX] - 1;\n\n\t \n\ti2c_msg.buf = msg + 2;\n\n\ti2c_msg.addr = addr;\n\ti2c_msg.flags = client->flags & I2C_CLIENT_PEC;\n\n\treturn i2c_transfer(client->adapter, &i2c_msg, 1);\n}\n\nstatic ssize_t ipmb_write(struct file *file, const char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct ipmb_dev *ipmb_dev = to_ipmb_dev(file);\n\tu8 rq_sa, netf_rq_lun, msg_len;\n\tstruct i2c_client *temp_client;\n\tu8 msg[MAX_MSG_LEN];\n\tssize_t ret;\n\n\tif (count > sizeof(msg))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&msg, buf, count))\n\t\treturn -EFAULT;\n\n\tif (count < msg[0])\n\t\treturn -EINVAL;\n\n\trq_sa = GET_7BIT_ADDR(msg[RQ_SA_8BIT_IDX]);\n\tnetf_rq_lun = msg[NETFN_LUN_IDX];\n\n\t \n\tif (ipmb_dev->is_i2c_protocol) {\n\t\tret = ipmb_i2c_write(ipmb_dev->client, msg, rq_sa);\n\t\treturn (ret == 1) ? count : ret;\n\t}\n\n\t \n\tmsg_len = msg[IPMB_MSG_LEN_IDX] - SMBUS_MSG_HEADER_LENGTH;\n\ttemp_client = kmemdup(ipmb_dev->client, sizeof(*temp_client), GFP_KERNEL);\n\tif (!temp_client)\n\t\treturn -ENOMEM;\n\n\ttemp_client->addr = rq_sa;\n\n\tret = i2c_smbus_write_block_data(temp_client, netf_rq_lun, msg_len,\n\t\t\t\t\t msg + SMBUS_MSG_IDX_OFFSET);\n\tkfree(temp_client);\n\n\treturn ret < 0 ? ret : count;\n}\n\nstatic __poll_t ipmb_poll(struct file *file, poll_table *wait)\n{\n\tstruct ipmb_dev *ipmb_dev = to_ipmb_dev(file);\n\t__poll_t mask = EPOLLOUT;\n\n\tmutex_lock(&ipmb_dev->file_mutex);\n\tpoll_wait(file, &ipmb_dev->wait_queue, wait);\n\n\tif (atomic_read(&ipmb_dev->request_queue_len))\n\t\tmask |= EPOLLIN;\n\tmutex_unlock(&ipmb_dev->file_mutex);\n\n\treturn mask;\n}\n\nstatic const struct file_operations ipmb_fops = {\n\t.owner\t= THIS_MODULE,\n\t.read\t= ipmb_read,\n\t.write\t= ipmb_write,\n\t.poll\t= ipmb_poll,\n};\n\n \nstatic void ipmb_handle_request(struct ipmb_dev *ipmb_dev)\n{\n\tstruct ipmb_request_elem *queue_elem;\n\n\tif (atomic_read(&ipmb_dev->request_queue_len) >=\n\t\t\tREQUEST_QUEUE_MAX_LEN)\n\t\treturn;\n\n\tqueue_elem = kmalloc(sizeof(*queue_elem), GFP_ATOMIC);\n\tif (!queue_elem)\n\t\treturn;\n\n\tmemcpy(&queue_elem->request, &ipmb_dev->request,\n\t\tsizeof(struct ipmb_msg));\n\tlist_add(&queue_elem->list, &ipmb_dev->request_queue);\n\tatomic_inc(&ipmb_dev->request_queue_len);\n\twake_up_all(&ipmb_dev->wait_queue);\n}\n\nstatic u8 ipmb_verify_checksum1(struct ipmb_dev *ipmb_dev, u8 rs_sa)\n{\n\t \n\treturn (rs_sa + ipmb_dev->request.netfn_rs_lun +\n\t\tipmb_dev->request.checksum1);\n}\n\n \nstatic bool is_ipmb_msg(struct ipmb_dev *ipmb_dev, u8 rs_sa)\n{\n\tif ((ipmb_dev->msg_idx >= IPMB_REQUEST_LEN_MIN) &&\n\t   (!ipmb_verify_checksum1(ipmb_dev, rs_sa)))\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic int ipmb_slave_cb(struct i2c_client *client,\n\t\t\tenum i2c_slave_event event, u8 *val)\n{\n\tstruct ipmb_dev *ipmb_dev = i2c_get_clientdata(client);\n\tu8 *buf = (u8 *)&ipmb_dev->request;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ipmb_dev->lock, flags);\n\tswitch (event) {\n\tcase I2C_SLAVE_WRITE_REQUESTED:\n\t\tmemset(&ipmb_dev->request, 0, sizeof(ipmb_dev->request));\n\t\tipmb_dev->msg_idx = 0;\n\n\t\t \n\t\tbuf[++ipmb_dev->msg_idx] = GET_8BIT_ADDR(client->addr);\n\t\tbreak;\n\n\tcase I2C_SLAVE_WRITE_RECEIVED:\n\t\tif (ipmb_dev->msg_idx >= sizeof(struct ipmb_msg) - 1)\n\t\t\tbreak;\n\n\t\tbuf[++ipmb_dev->msg_idx] = *val;\n\t\tbreak;\n\n\tcase I2C_SLAVE_STOP:\n\t\tipmb_dev->request.len = ipmb_dev->msg_idx;\n\t\tif (is_ipmb_msg(ipmb_dev, GET_8BIT_ADDR(client->addr)))\n\t\t\tipmb_handle_request(ipmb_dev);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&ipmb_dev->lock, flags);\n\n\treturn 0;\n}\n\nstatic int ipmb_probe(struct i2c_client *client)\n{\n\tstruct ipmb_dev *ipmb_dev;\n\tint ret;\n\n\tipmb_dev = devm_kzalloc(&client->dev, sizeof(*ipmb_dev),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!ipmb_dev)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&ipmb_dev->lock);\n\tinit_waitqueue_head(&ipmb_dev->wait_queue);\n\tatomic_set(&ipmb_dev->request_queue_len, 0);\n\tINIT_LIST_HEAD(&ipmb_dev->request_queue);\n\n\tmutex_init(&ipmb_dev->file_mutex);\n\n\tipmb_dev->miscdev.minor = MISC_DYNAMIC_MINOR;\n\n\tipmb_dev->miscdev.name = devm_kasprintf(&client->dev, GFP_KERNEL,\n\t\t\t\t\t\t\"%s%d\", \"ipmb-\",\n\t\t\t\t\t\tclient->adapter->nr);\n\tipmb_dev->miscdev.fops = &ipmb_fops;\n\tipmb_dev->miscdev.parent = &client->dev;\n\tret = misc_register(&ipmb_dev->miscdev);\n\tif (ret)\n\t\treturn ret;\n\n\tipmb_dev->is_i2c_protocol\n\t\t= device_property_read_bool(&client->dev, \"i2c-protocol\");\n\n\tipmb_dev->client = client;\n\ti2c_set_clientdata(client, ipmb_dev);\n\tret = i2c_slave_register(client, ipmb_slave_cb);\n\tif (ret) {\n\t\tmisc_deregister(&ipmb_dev->miscdev);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void ipmb_remove(struct i2c_client *client)\n{\n\tstruct ipmb_dev *ipmb_dev = i2c_get_clientdata(client);\n\n\ti2c_slave_unregister(client);\n\tmisc_deregister(&ipmb_dev->miscdev);\n}\n\nstatic const struct i2c_device_id ipmb_id[] = {\n\t{ \"ipmb-dev\", 0 },\n\t{},\n};\nMODULE_DEVICE_TABLE(i2c, ipmb_id);\n\nstatic const struct acpi_device_id acpi_ipmb_id[] = {\n\t{ \"IPMB0001\", 0 },\n\t{},\n};\nMODULE_DEVICE_TABLE(acpi, acpi_ipmb_id);\n\nstatic struct i2c_driver ipmb_driver = {\n\t.driver = {\n\t\t.name = \"ipmb-dev\",\n\t\t.acpi_match_table = ACPI_PTR(acpi_ipmb_id),\n\t},\n\t.probe = ipmb_probe,\n\t.remove = ipmb_remove,\n\t.id_table = ipmb_id,\n};\nmodule_i2c_driver(ipmb_driver);\n\nMODULE_AUTHOR(\"Mellanox Technologies\");\nMODULE_DESCRIPTION(\"IPMB driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}