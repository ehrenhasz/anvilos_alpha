{
  "module_name": "hpet.c",
  "hash_id": "5006787ffe2fa6148b2bb7c0a23246c83a17028351b2a1e0f2f4c6a40431be01",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/hpet.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/miscdevice.h>\n#include <linux/major.h>\n#include <linux/ioport.h>\n#include <linux/fcntl.h>\n#include <linux/init.h>\n#include <linux/io-64-nonatomic-lo-hi.h>\n#include <linux/poll.h>\n#include <linux/mm.h>\n#include <linux/proc_fs.h>\n#include <linux/spinlock.h>\n#include <linux/sysctl.h>\n#include <linux/wait.h>\n#include <linux/sched/signal.h>\n#include <linux/bcd.h>\n#include <linux/seq_file.h>\n#include <linux/bitops.h>\n#include <linux/compat.h>\n#include <linux/clocksource.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/acpi.h>\n#include <linux/hpet.h>\n#include <asm/current.h>\n#include <asm/irq.h>\n#include <asm/div64.h>\n\n \n#define\tHPET_USER_FREQ\t(64)\n#define\tHPET_DRIFT\t(500)\n\n#define HPET_RANGE_SIZE\t\t1024\t \n\n\n \n#if BITS_PER_LONG == 64\n#define\twrite_counter(V, MC)\twriteq(V, MC)\n#define\tread_counter(MC)\treadq(MC)\n#else\n#define\twrite_counter(V, MC)\twritel(V, MC)\n#define\tread_counter(MC)\treadl(MC)\n#endif\n\nstatic DEFINE_MUTEX(hpet_mutex);  \nstatic u32 hpet_nhpet, hpet_max_freq = HPET_USER_FREQ;\n\n \n#ifdef CONFIG_IA64\nstatic void __iomem *hpet_mctr;\n\nstatic u64 read_hpet(struct clocksource *cs)\n{\n\treturn (u64)read_counter((void __iomem *)hpet_mctr);\n}\n\nstatic struct clocksource clocksource_hpet = {\n\t.name\t\t= \"hpet\",\n\t.rating\t\t= 250,\n\t.read\t\t= read_hpet,\n\t.mask\t\t= CLOCKSOURCE_MASK(64),\n\t.flags\t\t= CLOCK_SOURCE_IS_CONTINUOUS,\n};\nstatic struct clocksource *hpet_clocksource;\n#endif\n\n \nstatic DEFINE_SPINLOCK(hpet_lock);\n\n#define\tHPET_DEV_NAME\t(7)\n\nstruct hpet_dev {\n\tstruct hpets *hd_hpets;\n\tstruct hpet __iomem *hd_hpet;\n\tstruct hpet_timer __iomem *hd_timer;\n\tunsigned long hd_ireqfreq;\n\tunsigned long hd_irqdata;\n\twait_queue_head_t hd_waitqueue;\n\tstruct fasync_struct *hd_async_queue;\n\tunsigned int hd_flags;\n\tunsigned int hd_irq;\n\tunsigned int hd_hdwirq;\n\tchar hd_name[HPET_DEV_NAME];\n};\n\nstruct hpets {\n\tstruct hpets *hp_next;\n\tstruct hpet __iomem *hp_hpet;\n\tunsigned long hp_hpet_phys;\n\tstruct clocksource *hp_clocksource;\n\tunsigned long long hp_tick_freq;\n\tunsigned long hp_delta;\n\tunsigned int hp_ntimer;\n\tunsigned int hp_which;\n\tstruct hpet_dev hp_dev[];\n};\n\nstatic struct hpets *hpets;\n\n#define\tHPET_OPEN\t\t0x0001\n#define\tHPET_IE\t\t\t0x0002\t \n#define\tHPET_PERIODIC\t\t0x0004\n#define\tHPET_SHARED_IRQ\t\t0x0008\n\nstatic irqreturn_t hpet_interrupt(int irq, void *data)\n{\n\tstruct hpet_dev *devp;\n\tunsigned long isr;\n\n\tdevp = data;\n\tisr = 1 << (devp - devp->hd_hpets->hp_dev);\n\n\tif ((devp->hd_flags & HPET_SHARED_IRQ) &&\n\t    !(isr & readl(&devp->hd_hpet->hpet_isr)))\n\t\treturn IRQ_NONE;\n\n\tspin_lock(&hpet_lock);\n\tdevp->hd_irqdata++;\n\n\t \n\tif ((devp->hd_flags & (HPET_IE | HPET_PERIODIC)) == HPET_IE) {\n\t\tunsigned long t, mc, base, k;\n\t\tstruct hpet __iomem *hpet = devp->hd_hpet;\n\t\tstruct hpets *hpetp = devp->hd_hpets;\n\n\t\tt = devp->hd_ireqfreq;\n\t\tread_counter(&devp->hd_timer->hpet_compare);\n\t\tmc = read_counter(&hpet->hpet_mc);\n\t\t \n\t\tbase = mc % t;\n\t\tk = (mc - base + hpetp->hp_delta) / t;\n\t\twrite_counter(t * (k + 1) + base,\n\t\t\t      &devp->hd_timer->hpet_compare);\n\t}\n\n\tif (devp->hd_flags & HPET_SHARED_IRQ)\n\t\twritel(isr, &devp->hd_hpet->hpet_isr);\n\tspin_unlock(&hpet_lock);\n\n\twake_up_interruptible(&devp->hd_waitqueue);\n\n\tkill_fasync(&devp->hd_async_queue, SIGIO, POLL_IN);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void hpet_timer_set_irq(struct hpet_dev *devp)\n{\n\tunsigned long v;\n\tint irq, gsi;\n\tstruct hpet_timer __iomem *timer;\n\n\tspin_lock_irq(&hpet_lock);\n\tif (devp->hd_hdwirq) {\n\t\tspin_unlock_irq(&hpet_lock);\n\t\treturn;\n\t}\n\n\ttimer = devp->hd_timer;\n\n\t \n\tv = readl(&timer->hpet_config);\n\tif (!(v & Tn_INT_TYPE_CNF_MASK)) {\n\t\tv |= Tn_INT_TYPE_CNF_MASK;\n\t\twritel(v, &timer->hpet_config);\n\t}\n\tspin_unlock_irq(&hpet_lock);\n\n\tv = (readq(&timer->hpet_config) & Tn_INT_ROUTE_CAP_MASK) >>\n\t\t\t\t Tn_INT_ROUTE_CAP_SHIFT;\n\n\t \n\tif (acpi_irq_model == ACPI_IRQ_MODEL_PIC)\n\t\tv &= ~0xf3df;\n\telse\n\t\tv &= ~0xffff;\n\n\tfor_each_set_bit(irq, &v, HPET_MAX_IRQ) {\n\t\tif (irq >= nr_irqs) {\n\t\t\tirq = HPET_MAX_IRQ;\n\t\t\tbreak;\n\t\t}\n\n\t\tgsi = acpi_register_gsi(NULL, irq, ACPI_LEVEL_SENSITIVE,\n\t\t\t\t\tACPI_ACTIVE_LOW);\n\t\tif (gsi > 0)\n\t\t\tbreak;\n\n\t\t \n\t}\n\n\tif (irq < HPET_MAX_IRQ) {\n\t\tspin_lock_irq(&hpet_lock);\n\t\tv = readl(&timer->hpet_config);\n\t\tv |= irq << Tn_INT_ROUTE_CNF_SHIFT;\n\t\twritel(v, &timer->hpet_config);\n\t\tdevp->hd_hdwirq = gsi;\n\t\tspin_unlock_irq(&hpet_lock);\n\t}\n\treturn;\n}\n\nstatic int hpet_open(struct inode *inode, struct file *file)\n{\n\tstruct hpet_dev *devp;\n\tstruct hpets *hpetp;\n\tint i;\n\n\tif (file->f_mode & FMODE_WRITE)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&hpet_mutex);\n\tspin_lock_irq(&hpet_lock);\n\n\tfor (devp = NULL, hpetp = hpets; hpetp && !devp; hpetp = hpetp->hp_next)\n\t\tfor (i = 0; i < hpetp->hp_ntimer; i++)\n\t\t\tif (hpetp->hp_dev[i].hd_flags & HPET_OPEN) {\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tdevp = &hpetp->hp_dev[i];\n\t\t\t\tbreak;\n\t\t\t}\n\n\tif (!devp) {\n\t\tspin_unlock_irq(&hpet_lock);\n\t\tmutex_unlock(&hpet_mutex);\n\t\treturn -EBUSY;\n\t}\n\n\tfile->private_data = devp;\n\tdevp->hd_irqdata = 0;\n\tdevp->hd_flags |= HPET_OPEN;\n\tspin_unlock_irq(&hpet_lock);\n\tmutex_unlock(&hpet_mutex);\n\n\thpet_timer_set_irq(devp);\n\n\treturn 0;\n}\n\nstatic ssize_t\nhpet_read(struct file *file, char __user *buf, size_t count, loff_t * ppos)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\tunsigned long data;\n\tssize_t retval;\n\tstruct hpet_dev *devp;\n\n\tdevp = file->private_data;\n\tif (!devp->hd_ireqfreq)\n\t\treturn -EIO;\n\n\tif (count < sizeof(unsigned long))\n\t\treturn -EINVAL;\n\n\tadd_wait_queue(&devp->hd_waitqueue, &wait);\n\n\tfor ( ; ; ) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t\tspin_lock_irq(&hpet_lock);\n\t\tdata = devp->hd_irqdata;\n\t\tdevp->hd_irqdata = 0;\n\t\tspin_unlock_irq(&hpet_lock);\n\n\t\tif (data) {\n\t\t\tbreak;\n\t\t} else if (file->f_flags & O_NONBLOCK) {\n\t\t\tretval = -EAGAIN;\n\t\t\tgoto out;\n\t\t} else if (signal_pending(current)) {\n\t\t\tretval = -ERESTARTSYS;\n\t\t\tgoto out;\n\t\t}\n\t\tschedule();\n\t}\n\n\tretval = put_user(data, (unsigned long __user *)buf);\n\tif (!retval)\n\t\tretval = sizeof(unsigned long);\nout:\n\t__set_current_state(TASK_RUNNING);\n\tremove_wait_queue(&devp->hd_waitqueue, &wait);\n\n\treturn retval;\n}\n\nstatic __poll_t hpet_poll(struct file *file, poll_table * wait)\n{\n\tunsigned long v;\n\tstruct hpet_dev *devp;\n\n\tdevp = file->private_data;\n\n\tif (!devp->hd_ireqfreq)\n\t\treturn 0;\n\n\tpoll_wait(file, &devp->hd_waitqueue, wait);\n\n\tspin_lock_irq(&hpet_lock);\n\tv = devp->hd_irqdata;\n\tspin_unlock_irq(&hpet_lock);\n\n\tif (v != 0)\n\t\treturn EPOLLIN | EPOLLRDNORM;\n\n\treturn 0;\n}\n\n#ifdef CONFIG_HPET_MMAP\n#ifdef CONFIG_HPET_MMAP_DEFAULT\nstatic int hpet_mmap_enabled = 1;\n#else\nstatic int hpet_mmap_enabled = 0;\n#endif\n\nstatic __init int hpet_mmap_enable(char *str)\n{\n\tget_option(&str, &hpet_mmap_enabled);\n\tpr_info(\"HPET mmap %s\\n\", hpet_mmap_enabled ? \"enabled\" : \"disabled\");\n\treturn 1;\n}\n__setup(\"hpet_mmap=\", hpet_mmap_enable);\n\nstatic int hpet_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct hpet_dev *devp;\n\tunsigned long addr;\n\n\tif (!hpet_mmap_enabled)\n\t\treturn -EACCES;\n\n\tdevp = file->private_data;\n\taddr = devp->hd_hpets->hp_hpet_phys;\n\n\tif (addr & (PAGE_SIZE - 1))\n\t\treturn -ENOSYS;\n\n\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\treturn vm_iomap_memory(vma, addr, PAGE_SIZE);\n}\n#else\nstatic int hpet_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\treturn -ENOSYS;\n}\n#endif\n\nstatic int hpet_fasync(int fd, struct file *file, int on)\n{\n\tstruct hpet_dev *devp;\n\n\tdevp = file->private_data;\n\n\tif (fasync_helper(fd, file, on, &devp->hd_async_queue) >= 0)\n\t\treturn 0;\n\telse\n\t\treturn -EIO;\n}\n\nstatic int hpet_release(struct inode *inode, struct file *file)\n{\n\tstruct hpet_dev *devp;\n\tstruct hpet_timer __iomem *timer;\n\tint irq = 0;\n\n\tdevp = file->private_data;\n\ttimer = devp->hd_timer;\n\n\tspin_lock_irq(&hpet_lock);\n\n\twriteq((readq(&timer->hpet_config) & ~Tn_INT_ENB_CNF_MASK),\n\t       &timer->hpet_config);\n\n\tirq = devp->hd_irq;\n\tdevp->hd_irq = 0;\n\n\tdevp->hd_ireqfreq = 0;\n\n\tif (devp->hd_flags & HPET_PERIODIC\n\t    && readq(&timer->hpet_config) & Tn_TYPE_CNF_MASK) {\n\t\tunsigned long v;\n\n\t\tv = readq(&timer->hpet_config);\n\t\tv ^= Tn_TYPE_CNF_MASK;\n\t\twriteq(v, &timer->hpet_config);\n\t}\n\n\tdevp->hd_flags &= ~(HPET_OPEN | HPET_IE | HPET_PERIODIC);\n\tspin_unlock_irq(&hpet_lock);\n\n\tif (irq)\n\t\tfree_irq(irq, devp);\n\n\tfile->private_data = NULL;\n\treturn 0;\n}\n\nstatic int hpet_ioctl_ieon(struct hpet_dev *devp)\n{\n\tstruct hpet_timer __iomem *timer;\n\tstruct hpet __iomem *hpet;\n\tstruct hpets *hpetp;\n\tint irq;\n\tunsigned long g, v, t, m;\n\tunsigned long flags, isr;\n\n\ttimer = devp->hd_timer;\n\thpet = devp->hd_hpet;\n\thpetp = devp->hd_hpets;\n\n\tif (!devp->hd_ireqfreq)\n\t\treturn -EIO;\n\n\tspin_lock_irq(&hpet_lock);\n\n\tif (devp->hd_flags & HPET_IE) {\n\t\tspin_unlock_irq(&hpet_lock);\n\t\treturn -EBUSY;\n\t}\n\n\tdevp->hd_flags |= HPET_IE;\n\n\tif (readl(&timer->hpet_config) & Tn_INT_TYPE_CNF_MASK)\n\t\tdevp->hd_flags |= HPET_SHARED_IRQ;\n\tspin_unlock_irq(&hpet_lock);\n\n\tirq = devp->hd_hdwirq;\n\n\tif (irq) {\n\t\tunsigned long irq_flags;\n\n\t\tif (devp->hd_flags & HPET_SHARED_IRQ) {\n\t\t\t \n\t\t\twritel(readl(&timer->hpet_config) & ~Tn_TYPE_CNF_MASK,\n\t\t\t       &timer->hpet_config);\n\t\t\twrite_counter(read_counter(&hpet->hpet_mc),\n\t\t\t\t      &timer->hpet_compare);\n\t\t\t \n\t\t\tisr = 1 << (devp - devp->hd_hpets->hp_dev);\n\t\t\twritel(isr, &hpet->hpet_isr);\n\t\t}\n\n\t\tsprintf(devp->hd_name, \"hpet%d\", (int)(devp - hpetp->hp_dev));\n\t\tirq_flags = devp->hd_flags & HPET_SHARED_IRQ ? IRQF_SHARED : 0;\n\t\tif (request_irq(irq, hpet_interrupt, irq_flags,\n\t\t\t\tdevp->hd_name, (void *)devp)) {\n\t\t\tprintk(KERN_ERR \"hpet: IRQ %d is not free\\n\", irq);\n\t\t\tirq = 0;\n\t\t}\n\t}\n\n\tif (irq == 0) {\n\t\tspin_lock_irq(&hpet_lock);\n\t\tdevp->hd_flags ^= HPET_IE;\n\t\tspin_unlock_irq(&hpet_lock);\n\t\treturn -EIO;\n\t}\n\n\tdevp->hd_irq = irq;\n\tt = devp->hd_ireqfreq;\n\tv = readq(&timer->hpet_config);\n\n\t \n\tg = v | Tn_32MODE_CNF_MASK | Tn_INT_ENB_CNF_MASK;\n\n\tif (devp->hd_flags & HPET_PERIODIC) {\n\t\tg |= Tn_TYPE_CNF_MASK;\n\t\tv |= Tn_TYPE_CNF_MASK | Tn_VAL_SET_CNF_MASK;\n\t\twriteq(v, &timer->hpet_config);\n\t\tlocal_irq_save(flags);\n\n\t\t \n\t\tm = read_counter(&hpet->hpet_mc);\n\t\twrite_counter(t + m + hpetp->hp_delta, &timer->hpet_compare);\n\t\t \n\t\twrite_counter(t, &timer->hpet_compare);\n\t} else {\n\t\tlocal_irq_save(flags);\n\t\tm = read_counter(&hpet->hpet_mc);\n\t\twrite_counter(t + m + hpetp->hp_delta, &timer->hpet_compare);\n\t}\n\n\tif (devp->hd_flags & HPET_SHARED_IRQ) {\n\t\tisr = 1 << (devp - devp->hd_hpets->hp_dev);\n\t\twritel(isr, &hpet->hpet_isr);\n\t}\n\twriteq(g, &timer->hpet_config);\n\tlocal_irq_restore(flags);\n\n\treturn 0;\n}\n\n \nstatic inline unsigned long hpet_time_div(struct hpets *hpets,\n\t\t\t\t\t  unsigned long dis)\n{\n\tunsigned long long m;\n\n\tm = hpets->hp_tick_freq + (dis >> 1);\n\treturn div64_ul(m, dis);\n}\n\nstatic int\nhpet_ioctl_common(struct hpet_dev *devp, unsigned int cmd, unsigned long arg,\n\t\t  struct hpet_info *info)\n{\n\tstruct hpet_timer __iomem *timer;\n\tstruct hpets *hpetp;\n\tint err;\n\tunsigned long v;\n\n\tswitch (cmd) {\n\tcase HPET_IE_OFF:\n\tcase HPET_INFO:\n\tcase HPET_EPI:\n\tcase HPET_DPI:\n\tcase HPET_IRQFREQ:\n\t\ttimer = devp->hd_timer;\n\t\thpetp = devp->hd_hpets;\n\t\tbreak;\n\tcase HPET_IE_ON:\n\t\treturn hpet_ioctl_ieon(devp);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\terr = 0;\n\n\tswitch (cmd) {\n\tcase HPET_IE_OFF:\n\t\tif ((devp->hd_flags & HPET_IE) == 0)\n\t\t\tbreak;\n\t\tv = readq(&timer->hpet_config);\n\t\tv &= ~Tn_INT_ENB_CNF_MASK;\n\t\twriteq(v, &timer->hpet_config);\n\t\tif (devp->hd_irq) {\n\t\t\tfree_irq(devp->hd_irq, devp);\n\t\t\tdevp->hd_irq = 0;\n\t\t}\n\t\tdevp->hd_flags ^= HPET_IE;\n\t\tbreak;\n\tcase HPET_INFO:\n\t\t{\n\t\t\tmemset(info, 0, sizeof(*info));\n\t\t\tif (devp->hd_ireqfreq)\n\t\t\t\tinfo->hi_ireqfreq =\n\t\t\t\t\thpet_time_div(hpetp, devp->hd_ireqfreq);\n\t\t\tinfo->hi_flags =\n\t\t\t    readq(&timer->hpet_config) & Tn_PER_INT_CAP_MASK;\n\t\t\tinfo->hi_hpet = hpetp->hp_which;\n\t\t\tinfo->hi_timer = devp - hpetp->hp_dev;\n\t\t\tbreak;\n\t\t}\n\tcase HPET_EPI:\n\t\tv = readq(&timer->hpet_config);\n\t\tif ((v & Tn_PER_INT_CAP_MASK) == 0) {\n\t\t\terr = -ENXIO;\n\t\t\tbreak;\n\t\t}\n\t\tdevp->hd_flags |= HPET_PERIODIC;\n\t\tbreak;\n\tcase HPET_DPI:\n\t\tv = readq(&timer->hpet_config);\n\t\tif ((v & Tn_PER_INT_CAP_MASK) == 0) {\n\t\t\terr = -ENXIO;\n\t\t\tbreak;\n\t\t}\n\t\tif (devp->hd_flags & HPET_PERIODIC &&\n\t\t    readq(&timer->hpet_config) & Tn_TYPE_CNF_MASK) {\n\t\t\tv = readq(&timer->hpet_config);\n\t\t\tv ^= Tn_TYPE_CNF_MASK;\n\t\t\twriteq(v, &timer->hpet_config);\n\t\t}\n\t\tdevp->hd_flags &= ~HPET_PERIODIC;\n\t\tbreak;\n\tcase HPET_IRQFREQ:\n\t\tif ((arg > hpet_max_freq) &&\n\t\t    !capable(CAP_SYS_RESOURCE)) {\n\t\t\terr = -EACCES;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!arg) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tdevp->hd_ireqfreq = hpet_time_div(hpetp, arg);\n\t}\n\n\treturn err;\n}\n\nstatic long\nhpet_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct hpet_info info;\n\tint err;\n\n\tmutex_lock(&hpet_mutex);\n\terr = hpet_ioctl_common(file->private_data, cmd, arg, &info);\n\tmutex_unlock(&hpet_mutex);\n\n\tif ((cmd == HPET_INFO) && !err &&\n\t    (copy_to_user((void __user *)arg, &info, sizeof(info))))\n\t\terr = -EFAULT;\n\n\treturn err;\n}\n\n#ifdef CONFIG_COMPAT\nstruct compat_hpet_info {\n\tcompat_ulong_t hi_ireqfreq;\t \n\tcompat_ulong_t hi_flags;\t \n\tunsigned short hi_hpet;\n\tunsigned short hi_timer;\n};\n\nstatic long\nhpet_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct hpet_info info;\n\tint err;\n\n\tmutex_lock(&hpet_mutex);\n\terr = hpet_ioctl_common(file->private_data, cmd, arg, &info);\n\tmutex_unlock(&hpet_mutex);\n\n\tif ((cmd == HPET_INFO) && !err) {\n\t\tstruct compat_hpet_info __user *u = compat_ptr(arg);\n\t\tif (put_user(info.hi_ireqfreq, &u->hi_ireqfreq) ||\n\t\t    put_user(info.hi_flags, &u->hi_flags) ||\n\t\t    put_user(info.hi_hpet, &u->hi_hpet) ||\n\t\t    put_user(info.hi_timer, &u->hi_timer))\n\t\t\terr = -EFAULT;\n\t}\n\n\treturn err;\n}\n#endif\n\nstatic const struct file_operations hpet_fops = {\n\t.owner = THIS_MODULE,\n\t.llseek = no_llseek,\n\t.read = hpet_read,\n\t.poll = hpet_poll,\n\t.unlocked_ioctl = hpet_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl = hpet_compat_ioctl,\n#endif\n\t.open = hpet_open,\n\t.release = hpet_release,\n\t.fasync = hpet_fasync,\n\t.mmap = hpet_mmap,\n};\n\nstatic int hpet_is_known(struct hpet_data *hdp)\n{\n\tstruct hpets *hpetp;\n\n\tfor (hpetp = hpets; hpetp; hpetp = hpetp->hp_next)\n\t\tif (hpetp->hp_hpet_phys == hdp->hd_phys_address)\n\t\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic struct ctl_table hpet_table[] = {\n\t{\n\t .procname = \"max-user-freq\",\n\t .data = &hpet_max_freq,\n\t .maxlen = sizeof(int),\n\t .mode = 0644,\n\t .proc_handler = proc_dointvec,\n\t },\n\t{}\n};\n\nstatic struct ctl_table_header *sysctl_header;\n\n \n#define\tTICK_CALIBRATE\t(1000UL)\n\nstatic unsigned long __hpet_calibrate(struct hpets *hpetp)\n{\n\tstruct hpet_timer __iomem *timer = NULL;\n\tunsigned long t, m, count, i, flags, start;\n\tstruct hpet_dev *devp;\n\tint j;\n\tstruct hpet __iomem *hpet;\n\n\tfor (j = 0, devp = hpetp->hp_dev; j < hpetp->hp_ntimer; j++, devp++)\n\t\tif ((devp->hd_flags & HPET_OPEN) == 0) {\n\t\t\ttimer = devp->hd_timer;\n\t\t\tbreak;\n\t\t}\n\n\tif (!timer)\n\t\treturn 0;\n\n\thpet = hpetp->hp_hpet;\n\tt = read_counter(&timer->hpet_compare);\n\n\ti = 0;\n\tcount = hpet_time_div(hpetp, TICK_CALIBRATE);\n\n\tlocal_irq_save(flags);\n\n\tstart = read_counter(&hpet->hpet_mc);\n\n\tdo {\n\t\tm = read_counter(&hpet->hpet_mc);\n\t\twrite_counter(t + m + hpetp->hp_delta, &timer->hpet_compare);\n\t} while (i++, (m - start) < count);\n\n\tlocal_irq_restore(flags);\n\n\treturn (m - start) / i;\n}\n\nstatic unsigned long hpet_calibrate(struct hpets *hpetp)\n{\n\tunsigned long ret = ~0UL;\n\tunsigned long tmp;\n\n\t \n\tfor ( ; ; ) {\n\t\ttmp = __hpet_calibrate(hpetp);\n\t\tif (ret <= tmp)\n\t\t\tbreak;\n\t\tret = tmp;\n\t}\n\n\treturn ret;\n}\n\nint hpet_alloc(struct hpet_data *hdp)\n{\n\tu64 cap, mcfg;\n\tstruct hpet_dev *devp;\n\tu32 i, ntimer;\n\tstruct hpets *hpetp;\n\tstruct hpet __iomem *hpet;\n\tstatic struct hpets *last;\n\tunsigned long period;\n\tunsigned long long temp;\n\tu32 remainder;\n\n\t \n\tif (hpet_is_known(hdp)) {\n\t\tprintk(KERN_DEBUG \"%s: duplicate HPET ignored\\n\",\n\t\t\t__func__);\n\t\treturn 0;\n\t}\n\n\thpetp = kzalloc(struct_size(hpetp, hp_dev, hdp->hd_nirqs),\n\t\t\tGFP_KERNEL);\n\n\tif (!hpetp)\n\t\treturn -ENOMEM;\n\n\thpetp->hp_which = hpet_nhpet++;\n\thpetp->hp_hpet = hdp->hd_address;\n\thpetp->hp_hpet_phys = hdp->hd_phys_address;\n\n\thpetp->hp_ntimer = hdp->hd_nirqs;\n\n\tfor (i = 0; i < hdp->hd_nirqs; i++)\n\t\thpetp->hp_dev[i].hd_hdwirq = hdp->hd_irq[i];\n\n\thpet = hpetp->hp_hpet;\n\n\tcap = readq(&hpet->hpet_cap);\n\n\tntimer = ((cap & HPET_NUM_TIM_CAP_MASK) >> HPET_NUM_TIM_CAP_SHIFT) + 1;\n\n\tif (hpetp->hp_ntimer != ntimer) {\n\t\tprintk(KERN_WARNING \"hpet: number irqs doesn't agree\"\n\t\t       \" with number of timers\\n\");\n\t\tkfree(hpetp);\n\t\treturn -ENODEV;\n\t}\n\n\tif (last)\n\t\tlast->hp_next = hpetp;\n\telse\n\t\thpets = hpetp;\n\n\tlast = hpetp;\n\n\tperiod = (cap & HPET_COUNTER_CLK_PERIOD_MASK) >>\n\t\tHPET_COUNTER_CLK_PERIOD_SHIFT;  \n\ttemp = 1000000000000000uLL;  \n\ttemp += period >> 1;  \n\tdo_div(temp, period);\n\thpetp->hp_tick_freq = temp;  \n\n\tprintk(KERN_INFO \"hpet%d: at MMIO 0x%lx, IRQ%s\",\n\t\thpetp->hp_which, hdp->hd_phys_address,\n\t\thpetp->hp_ntimer > 1 ? \"s\" : \"\");\n\tfor (i = 0; i < hpetp->hp_ntimer; i++)\n\t\tprintk(KERN_CONT \"%s %d\", i > 0 ? \",\" : \"\", hdp->hd_irq[i]);\n\tprintk(KERN_CONT \"\\n\");\n\n\ttemp = hpetp->hp_tick_freq;\n\tremainder = do_div(temp, 1000000);\n\tprintk(KERN_INFO\n\t\t\"hpet%u: %u comparators, %d-bit %u.%06u MHz counter\\n\",\n\t\thpetp->hp_which, hpetp->hp_ntimer,\n\t\tcap & HPET_COUNTER_SIZE_MASK ? 64 : 32,\n\t\t(unsigned) temp, remainder);\n\n\tmcfg = readq(&hpet->hpet_config);\n\tif ((mcfg & HPET_ENABLE_CNF_MASK) == 0) {\n\t\twrite_counter(0L, &hpet->hpet_mc);\n\t\tmcfg |= HPET_ENABLE_CNF_MASK;\n\t\twriteq(mcfg, &hpet->hpet_config);\n\t}\n\n\tfor (i = 0, devp = hpetp->hp_dev; i < hpetp->hp_ntimer; i++, devp++) {\n\t\tstruct hpet_timer __iomem *timer;\n\n\t\ttimer = &hpet->hpet_timers[devp - hpetp->hp_dev];\n\n\t\tdevp->hd_hpets = hpetp;\n\t\tdevp->hd_hpet = hpet;\n\t\tdevp->hd_timer = timer;\n\n\t\t \n\t\tif (hdp->hd_state & (1 << i)) {\n\t\t\tdevp->hd_flags = HPET_OPEN;\n\t\t\tcontinue;\n\t\t}\n\n\t\tinit_waitqueue_head(&devp->hd_waitqueue);\n\t}\n\n\thpetp->hp_delta = hpet_calibrate(hpetp);\n\n \n#ifdef CONFIG_IA64\n\tif (!hpet_clocksource) {\n\t\thpet_mctr = (void __iomem *)&hpetp->hp_hpet->hpet_mc;\n\t\tclocksource_hpet.archdata.fsys_mmio = hpet_mctr;\n\t\tclocksource_register_hz(&clocksource_hpet, hpetp->hp_tick_freq);\n\t\thpetp->hp_clocksource = &clocksource_hpet;\n\t\thpet_clocksource = &clocksource_hpet;\n\t}\n#endif\n\n\treturn 0;\n}\n\nstatic acpi_status hpet_resources(struct acpi_resource *res, void *data)\n{\n\tstruct hpet_data *hdp;\n\tacpi_status status;\n\tstruct acpi_resource_address64 addr;\n\n\thdp = data;\n\n\tstatus = acpi_resource_to_address64(res, &addr);\n\n\tif (ACPI_SUCCESS(status)) {\n\t\thdp->hd_phys_address = addr.address.minimum;\n\t\thdp->hd_address = ioremap(addr.address.minimum, addr.address.address_length);\n\t\tif (!hdp->hd_address)\n\t\t\treturn AE_ERROR;\n\n\t\tif (hpet_is_known(hdp)) {\n\t\t\tiounmap(hdp->hd_address);\n\t\t\treturn AE_ALREADY_EXISTS;\n\t\t}\n\t} else if (res->type == ACPI_RESOURCE_TYPE_FIXED_MEMORY32) {\n\t\tstruct acpi_resource_fixed_memory32 *fixmem32;\n\n\t\tfixmem32 = &res->data.fixed_memory32;\n\n\t\thdp->hd_phys_address = fixmem32->address;\n\t\thdp->hd_address = ioremap(fixmem32->address,\n\t\t\t\t\t\tHPET_RANGE_SIZE);\n\t\tif (!hdp->hd_address)\n\t\t\treturn AE_ERROR;\n\n\t\tif (hpet_is_known(hdp)) {\n\t\t\tiounmap(hdp->hd_address);\n\t\t\treturn AE_ALREADY_EXISTS;\n\t\t}\n\t} else if (res->type == ACPI_RESOURCE_TYPE_EXTENDED_IRQ) {\n\t\tstruct acpi_resource_extended_irq *irqp;\n\t\tint i, irq;\n\n\t\tirqp = &res->data.extended_irq;\n\n\t\tfor (i = 0; i < irqp->interrupt_count; i++) {\n\t\t\tif (hdp->hd_nirqs >= HPET_MAX_TIMERS)\n\t\t\t\tbreak;\n\n\t\t\tirq = acpi_register_gsi(NULL, irqp->interrupts[i],\n\t\t\t\t\t\tirqp->triggering,\n\t\t\t\t\t\tirqp->polarity);\n\t\t\tif (irq < 0)\n\t\t\t\treturn AE_ERROR;\n\n\t\t\thdp->hd_irq[hdp->hd_nirqs] = irq;\n\t\t\thdp->hd_nirqs++;\n\t\t}\n\t}\n\n\treturn AE_OK;\n}\n\nstatic int hpet_acpi_add(struct acpi_device *device)\n{\n\tacpi_status result;\n\tstruct hpet_data data;\n\n\tmemset(&data, 0, sizeof(data));\n\n\tresult =\n\t    acpi_walk_resources(device->handle, METHOD_NAME__CRS,\n\t\t\t\thpet_resources, &data);\n\n\tif (ACPI_FAILURE(result))\n\t\treturn -ENODEV;\n\n\tif (!data.hd_address || !data.hd_nirqs) {\n\t\tif (data.hd_address)\n\t\t\tiounmap(data.hd_address);\n\t\tprintk(\"%s: no address or irqs in _CRS\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\n\treturn hpet_alloc(&data);\n}\n\nstatic const struct acpi_device_id hpet_device_ids[] = {\n\t{\"PNP0103\", 0},\n\t{\"\", 0},\n};\n\nstatic struct acpi_driver hpet_acpi_driver = {\n\t.name = \"hpet\",\n\t.ids = hpet_device_ids,\n\t.ops = {\n\t\t.add = hpet_acpi_add,\n\t\t},\n};\n\nstatic struct miscdevice hpet_misc = { HPET_MINOR, \"hpet\", &hpet_fops };\n\nstatic int __init hpet_init(void)\n{\n\tint result;\n\n\tresult = misc_register(&hpet_misc);\n\tif (result < 0)\n\t\treturn -ENODEV;\n\n\tsysctl_header = register_sysctl(\"dev/hpet\", hpet_table);\n\n\tresult = acpi_bus_register_driver(&hpet_acpi_driver);\n\tif (result < 0) {\n\t\tif (sysctl_header)\n\t\t\tunregister_sysctl_table(sysctl_header);\n\t\tmisc_deregister(&hpet_misc);\n\t\treturn result;\n\t}\n\n\treturn 0;\n}\ndevice_initcall(hpet_init);\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}