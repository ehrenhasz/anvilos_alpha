{
  "module_name": "bsr.c",
  "hash_id": "e2c7c9c9d1b934c2dc5c2c719707147540194b4e38999e9c2b603b8499982b3e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/bsr.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/cdev.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <asm/io.h>\n\n \n\n \n#define BSR_MAX_DEVS (32)\n\nstruct bsr_dev {\n\tu64      bsr_addr;      \n\tu64      bsr_len;       \n\tunsigned bsr_bytes;     \n\tunsigned bsr_stride;    \n\tunsigned bsr_type;      \n\tunsigned bsr_num;       \n\tint      bsr_minor;\n\n\tstruct list_head bsr_list;\n\n\tdev_t    bsr_dev;\n\tstruct cdev bsr_cdev;\n\tstruct device *bsr_device;\n\tchar     bsr_name[32];\n\n};\n\nstatic unsigned total_bsr_devs;\nstatic LIST_HEAD(bsr_devs);\nstatic int bsr_major;\n\nenum {\n\tBSR_8    = 0,\n\tBSR_16   = 1,\n\tBSR_64   = 2,\n\tBSR_128  = 3,\n\tBSR_4096 = 4,\n\tBSR_UNKNOWN = 5,\n\tBSR_MAX  = 6,\n};\n\nstatic unsigned bsr_types[BSR_MAX];\n\nstatic ssize_t\nbsr_size_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct bsr_dev *bsr_dev = dev_get_drvdata(dev);\n\treturn sprintf(buf, \"%u\\n\", bsr_dev->bsr_bytes);\n}\nstatic DEVICE_ATTR_RO(bsr_size);\n\nstatic ssize_t\nbsr_stride_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct bsr_dev *bsr_dev = dev_get_drvdata(dev);\n\treturn sprintf(buf, \"%u\\n\", bsr_dev->bsr_stride);\n}\nstatic DEVICE_ATTR_RO(bsr_stride);\n\nstatic ssize_t\nbsr_length_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct bsr_dev *bsr_dev = dev_get_drvdata(dev);\n\treturn sprintf(buf, \"%llu\\n\", bsr_dev->bsr_len);\n}\nstatic DEVICE_ATTR_RO(bsr_length);\n\nstatic struct attribute *bsr_dev_attrs[] = {\n\t&dev_attr_bsr_size.attr,\n\t&dev_attr_bsr_stride.attr,\n\t&dev_attr_bsr_length.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(bsr_dev);\n\nstatic const struct class bsr_class = {\n\t.name\t\t= \"bsr\",\n\t.dev_groups\t= bsr_dev_groups,\n};\n\nstatic int bsr_mmap(struct file *filp, struct vm_area_struct *vma)\n{\n\tunsigned long size   = vma->vm_end - vma->vm_start;\n\tstruct bsr_dev *dev = filp->private_data;\n\tint ret;\n\n\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\n\t \n\tif (dev->bsr_len < PAGE_SIZE && size == PAGE_SIZE)\n\t\tret = remap_4k_pfn(vma, vma->vm_start, dev->bsr_addr >> 12,\n\t\t\t\t   vma->vm_page_prot);\n\telse if (size <= dev->bsr_len)\n\t\tret = io_remap_pfn_range(vma, vma->vm_start,\n\t\t\t\t\t dev->bsr_addr >> PAGE_SHIFT,\n\t\t\t\t\t size, vma->vm_page_prot);\n\telse\n\t\treturn -EINVAL;\n\n\tif (ret)\n\t\treturn -EAGAIN;\n\n\treturn 0;\n}\n\nstatic int bsr_open(struct inode *inode, struct file *filp)\n{\n\tstruct cdev *cdev = inode->i_cdev;\n\tstruct bsr_dev *dev = container_of(cdev, struct bsr_dev, bsr_cdev);\n\n\tfilp->private_data = dev;\n\treturn 0;\n}\n\nstatic const struct file_operations bsr_fops = {\n\t.owner = THIS_MODULE,\n\t.mmap  = bsr_mmap,\n\t.open  = bsr_open,\n\t.llseek = noop_llseek,\n};\n\nstatic void bsr_cleanup_devs(void)\n{\n\tstruct bsr_dev *cur, *n;\n\n\tlist_for_each_entry_safe(cur, n, &bsr_devs, bsr_list) {\n\t\tif (cur->bsr_device) {\n\t\t\tcdev_del(&cur->bsr_cdev);\n\t\t\tdevice_del(cur->bsr_device);\n\t\t}\n\t\tlist_del(&cur->bsr_list);\n\t\tkfree(cur);\n\t}\n}\n\nstatic int bsr_add_node(struct device_node *bn)\n{\n\tint bsr_stride_len, bsr_bytes_len, num_bsr_devs;\n\tconst u32 *bsr_stride;\n\tconst u32 *bsr_bytes;\n\tunsigned i;\n\tint ret = -ENODEV;\n\n\tbsr_stride = of_get_property(bn, \"ibm,lock-stride\", &bsr_stride_len);\n\tbsr_bytes  = of_get_property(bn, \"ibm,#lock-bytes\", &bsr_bytes_len);\n\n\tif (!bsr_stride || !bsr_bytes ||\n\t    (bsr_stride_len != bsr_bytes_len)) {\n\t\tprintk(KERN_ERR \"bsr of-node has missing/incorrect property\\n\");\n\t\treturn ret;\n\t}\n\n\tnum_bsr_devs = bsr_bytes_len / sizeof(u32);\n\n\tfor (i = 0 ; i < num_bsr_devs; i++) {\n\t\tstruct bsr_dev *cur = kzalloc(sizeof(struct bsr_dev),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tstruct resource res;\n\t\tint result;\n\n\t\tif (!cur) {\n\t\t\tprintk(KERN_ERR \"Unable to alloc bsr dev\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tresult = of_address_to_resource(bn, i, &res);\n\t\tif (result < 0) {\n\t\t\tprintk(KERN_ERR \"bsr of-node has invalid reg property, skipping\\n\");\n\t\t\tkfree(cur);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcur->bsr_minor  = i + total_bsr_devs;\n\t\tcur->bsr_addr   = res.start;\n\t\tcur->bsr_len    = resource_size(&res);\n\t\tcur->bsr_bytes  = bsr_bytes[i];\n\t\tcur->bsr_stride = bsr_stride[i];\n\t\tcur->bsr_dev    = MKDEV(bsr_major, i + total_bsr_devs);\n\n\t\t \n\t\t \n\t\tif (cur->bsr_len > 4096 && cur->bsr_len < PAGE_SIZE)\n\t\t\tcur->bsr_len = 4096;\n\n\t\tswitch(cur->bsr_bytes) {\n\t\tcase 8:\n\t\t\tcur->bsr_type = BSR_8;\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tcur->bsr_type = BSR_16;\n\t\t\tbreak;\n\t\tcase 64:\n\t\t\tcur->bsr_type = BSR_64;\n\t\t\tbreak;\n\t\tcase 128:\n\t\t\tcur->bsr_type = BSR_128;\n\t\t\tbreak;\n\t\tcase 4096:\n\t\t\tcur->bsr_type = BSR_4096;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcur->bsr_type = BSR_UNKNOWN;\n\t\t}\n\n\t\tcur->bsr_num = bsr_types[cur->bsr_type];\n\t\tsnprintf(cur->bsr_name, 32, \"bsr%d_%d\",\n\t\t\t cur->bsr_bytes, cur->bsr_num);\n\n\t\tcdev_init(&cur->bsr_cdev, &bsr_fops);\n\t\tresult = cdev_add(&cur->bsr_cdev, cur->bsr_dev, 1);\n\t\tif (result) {\n\t\t\tkfree(cur);\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tcur->bsr_device = device_create(&bsr_class, NULL, cur->bsr_dev,\n\t\t\t\t\t\tcur, \"%s\", cur->bsr_name);\n\t\tif (IS_ERR(cur->bsr_device)) {\n\t\t\tprintk(KERN_ERR \"device_create failed for %s\\n\",\n\t\t\t       cur->bsr_name);\n\t\t\tcdev_del(&cur->bsr_cdev);\n\t\t\tkfree(cur);\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tbsr_types[cur->bsr_type] = cur->bsr_num + 1;\n\t\tlist_add_tail(&cur->bsr_list, &bsr_devs);\n\t}\n\n\ttotal_bsr_devs += num_bsr_devs;\n\n\treturn 0;\n\n out_err:\n\n\tbsr_cleanup_devs();\n\treturn ret;\n}\n\nstatic int bsr_create_devs(struct device_node *bn)\n{\n\tint ret;\n\n\twhile (bn) {\n\t\tret = bsr_add_node(bn);\n\t\tif (ret) {\n\t\t\tof_node_put(bn);\n\t\t\treturn ret;\n\t\t}\n\t\tbn = of_find_compatible_node(bn, NULL, \"ibm,bsr\");\n\t}\n\treturn 0;\n}\n\nstatic int __init bsr_init(void)\n{\n\tstruct device_node *np;\n\tdev_t bsr_dev;\n\tint ret = -ENODEV;\n\n\tnp = of_find_compatible_node(NULL, NULL, \"ibm,bsr\");\n\tif (!np)\n\t\tgoto out_err;\n\n\tret = class_register(&bsr_class);\n\tif (ret)\n\t\tgoto out_err_1;\n\n\tret = alloc_chrdev_region(&bsr_dev, 0, BSR_MAX_DEVS, \"bsr\");\n\tbsr_major = MAJOR(bsr_dev);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR \"alloc_chrdev_region() failed for bsr\\n\");\n\t\tgoto out_err_2;\n\t}\n\n\tret = bsr_create_devs(np);\n\tif (ret < 0) {\n\t\tnp = NULL;\n\t\tgoto out_err_3;\n\t}\n\n\treturn 0;\n\n out_err_3:\n\tunregister_chrdev_region(bsr_dev, BSR_MAX_DEVS);\n\n out_err_2:\n\tclass_unregister(&bsr_class);\n\n out_err_1:\n\tof_node_put(np);\n\n out_err:\n\n\treturn ret;\n}\n\nstatic void __exit  bsr_exit(void)\n{\n\n\tbsr_cleanup_devs();\n\n\tclass_unregister(&bsr_class);\n\n\tif (bsr_major)\n\t\tunregister_chrdev_region(MKDEV(bsr_major, 0), BSR_MAX_DEVS);\n}\n\nmodule_init(bsr_init);\nmodule_exit(bsr_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Sonny Rao <sonnyrao@us.ibm.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}