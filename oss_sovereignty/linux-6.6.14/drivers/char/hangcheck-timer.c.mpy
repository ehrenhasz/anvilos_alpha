{
  "module_name": "hangcheck-timer.c",
  "hash_id": "9d0ad8af285a9050e916345cf8aff9c41945ccc33cc39a3fff897542c1aa7d9a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/hangcheck-timer.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/reboot.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/uaccess.h>\n#include <linux/sysrq.h>\n#include <linux/timer.h>\n#include <linux/hrtimer.h>\n\n#define VERSION_STR \"0.9.1\"\n\n#define DEFAULT_IOFENCE_MARGIN 60\t \n#define DEFAULT_IOFENCE_TICK 180\t \n\nstatic int hangcheck_tick = DEFAULT_IOFENCE_TICK;\nstatic int hangcheck_margin = DEFAULT_IOFENCE_MARGIN;\nstatic int hangcheck_reboot;   \nstatic int hangcheck_dump_tasks;   \n\n \nmodule_param(hangcheck_tick, int, 0);\nMODULE_PARM_DESC(hangcheck_tick, \"Timer delay.\");\nmodule_param(hangcheck_margin, int, 0);\nMODULE_PARM_DESC(hangcheck_margin, \"If the hangcheck timer has been delayed more than hangcheck_margin seconds, the driver will fire.\");\nmodule_param(hangcheck_reboot, int, 0);\nMODULE_PARM_DESC(hangcheck_reboot, \"If nonzero, the machine will reboot when the timer margin is exceeded.\");\nmodule_param(hangcheck_dump_tasks, int, 0);\nMODULE_PARM_DESC(hangcheck_dump_tasks, \"If nonzero, the machine will dump the system task state when the timer margin is exceeded.\");\n\nMODULE_AUTHOR(\"Oracle\");\nMODULE_DESCRIPTION(\"Hangcheck-timer detects when the system has gone out to lunch past a certain margin.\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(VERSION_STR);\n\n \n#ifndef MODULE\n\nstatic int __init hangcheck_parse_tick(char *str)\n{\n\tint par;\n\tif (get_option(&str,&par))\n\t\thangcheck_tick = par;\n\treturn 1;\n}\n\nstatic int __init hangcheck_parse_margin(char *str)\n{\n\tint par;\n\tif (get_option(&str,&par))\n\t\thangcheck_margin = par;\n\treturn 1;\n}\n\nstatic int __init hangcheck_parse_reboot(char *str)\n{\n\tint par;\n\tif (get_option(&str,&par))\n\t\thangcheck_reboot = par;\n\treturn 1;\n}\n\nstatic int __init hangcheck_parse_dump_tasks(char *str)\n{\n\tint par;\n\tif (get_option(&str,&par))\n\t\thangcheck_dump_tasks = par;\n\treturn 1;\n}\n\n__setup(\"hcheck_tick\", hangcheck_parse_tick);\n__setup(\"hcheck_margin\", hangcheck_parse_margin);\n__setup(\"hcheck_reboot\", hangcheck_parse_reboot);\n__setup(\"hcheck_dump_tasks\", hangcheck_parse_dump_tasks);\n#endif  \n\n#define TIMER_FREQ 1000000000ULL\n\n \nstatic unsigned long long hangcheck_tsc, hangcheck_tsc_margin;\n\nstatic void hangcheck_fire(struct timer_list *);\n\nstatic DEFINE_TIMER(hangcheck_ticktock, hangcheck_fire);\n\nstatic void hangcheck_fire(struct timer_list *unused)\n{\n\tunsigned long long cur_tsc, tsc_diff;\n\n\tcur_tsc = ktime_get_ns();\n\n\tif (cur_tsc > hangcheck_tsc)\n\t\ttsc_diff = cur_tsc - hangcheck_tsc;\n\telse\n\t\ttsc_diff = (cur_tsc + (~0ULL - hangcheck_tsc));  \n\n\tif (tsc_diff > hangcheck_tsc_margin) {\n\t\tif (hangcheck_dump_tasks) {\n\t\t\tprintk(KERN_CRIT \"Hangcheck: Task state:\\n\");\n#ifdef CONFIG_MAGIC_SYSRQ\n\t\t\thandle_sysrq('t');\n#endif   \n\t\t}\n\t\tif (hangcheck_reboot) {\n\t\t\tprintk(KERN_CRIT \"Hangcheck: hangcheck is restarting the machine.\\n\");\n\t\t\temergency_restart();\n\t\t} else {\n\t\t\tprintk(KERN_CRIT \"Hangcheck: hangcheck value past margin!\\n\");\n\t\t}\n\t}\n#if 0\n\t \n\tprintk(\"Hangcheck: called %Ld ns since last time (%Ld ns overshoot)\\n\",\n\t\t\ttsc_diff, tsc_diff - hangcheck_tick*TIMER_FREQ);\n#endif\n\tmod_timer(&hangcheck_ticktock, jiffies + (hangcheck_tick*HZ));\n\thangcheck_tsc = ktime_get_ns();\n}\n\n\nstatic int __init hangcheck_init(void)\n{\n\tprintk(\"Hangcheck: starting hangcheck timer %s (tick is %d seconds, margin is %d seconds).\\n\",\n\t       VERSION_STR, hangcheck_tick, hangcheck_margin);\n\thangcheck_tsc_margin =\n\t\t(unsigned long long)hangcheck_margin + hangcheck_tick;\n\thangcheck_tsc_margin *= TIMER_FREQ;\n\n\thangcheck_tsc = ktime_get_ns();\n\tmod_timer(&hangcheck_ticktock, jiffies + (hangcheck_tick*HZ));\n\n\treturn 0;\n}\n\n\nstatic void __exit hangcheck_exit(void)\n{\n\tdel_timer_sync(&hangcheck_ticktock);\n        printk(\"Hangcheck: Stopped hangcheck timer.\\n\");\n}\n\nmodule_init(hangcheck_init);\nmodule_exit(hangcheck_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}