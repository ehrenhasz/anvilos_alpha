{
  "module_name": "ati-agp.c",
  "hash_id": "a6be6495595ee55f8533ff8a42ce325b84e895d76f055e9008ab4de2c8f597c6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/agp/ati-agp.c",
  "human_readable_source": " \n\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/agp_backend.h>\n#include <asm/agp.h>\n#include <asm/set_memory.h>\n#include \"agp.h\"\n\n#define ATI_GART_MMBASE_BAR\t1\n#define ATI_RS100_APSIZE\t0xac\n#define ATI_RS100_IG_AGPMODE\t0xb0\n#define ATI_RS300_APSIZE\t0xf8\n#define ATI_RS300_IG_AGPMODE\t0xfc\n#define ATI_GART_FEATURE_ID\t\t0x00\n#define ATI_GART_BASE\t\t\t0x04\n#define ATI_GART_CACHE_SZBASE\t\t0x08\n#define ATI_GART_CACHE_CNTRL\t\t0x0c\n#define ATI_GART_CACHE_ENTRY_CNTRL\t0x10\n\n\nstatic const struct aper_size_info_lvl2 ati_generic_sizes[7] =\n{\n\t{2048, 524288, 0x0000000c},\n\t{1024, 262144, 0x0000000a},\n\t{512, 131072, 0x00000008},\n\t{256, 65536, 0x00000006},\n\t{128, 32768, 0x00000004},\n\t{64, 16384, 0x00000002},\n\t{32, 8192, 0x00000000}\n};\n\nstatic struct gatt_mask ati_generic_masks[] =\n{\n\t{ .mask = 1, .type = 0}\n};\n\n\nstruct ati_page_map {\n\tunsigned long *real;\n\tunsigned long __iomem *remapped;\n};\n\nstatic struct _ati_generic_private {\n\tvolatile u8 __iomem *registers;\n\tstruct ati_page_map **gatt_pages;\n\tint num_tables;\n} ati_generic_private;\n\nstatic int ati_create_page_map(struct ati_page_map *page_map)\n{\n\tint i, err;\n\n\tpage_map->real = (unsigned long *) __get_free_page(GFP_KERNEL);\n\tif (page_map->real == NULL)\n\t\treturn -ENOMEM;\n\n\tset_memory_uc((unsigned long)page_map->real, 1);\n\terr = map_page_into_agp(virt_to_page(page_map->real));\n\tif (err) {\n\t\tfree_page((unsigned long)page_map->real);\n\t\treturn err;\n\t}\n\tpage_map->remapped = page_map->real;\n\n\tfor (i = 0; i < PAGE_SIZE / sizeof(unsigned long); i++) {\n\t\twritel(agp_bridge->scratch_page, page_map->remapped+i);\n\t\treadl(page_map->remapped+i);\t \n\t}\n\n\treturn 0;\n}\n\n\nstatic void ati_free_page_map(struct ati_page_map *page_map)\n{\n\tunmap_page_from_agp(virt_to_page(page_map->real));\n\tset_memory_wb((unsigned long)page_map->real, 1);\n\tfree_page((unsigned long) page_map->real);\n}\n\n\nstatic void ati_free_gatt_pages(void)\n{\n\tint i;\n\tstruct ati_page_map **tables;\n\tstruct ati_page_map *entry;\n\n\ttables = ati_generic_private.gatt_pages;\n\tfor (i = 0; i < ati_generic_private.num_tables; i++) {\n\t\tentry = tables[i];\n\t\tif (entry != NULL) {\n\t\t\tif (entry->real != NULL)\n\t\t\t\tati_free_page_map(entry);\n\t\t\tkfree(entry);\n\t\t}\n\t}\n\tkfree(tables);\n}\n\n\nstatic int ati_create_gatt_pages(int nr_tables)\n{\n\tstruct ati_page_map **tables;\n\tstruct ati_page_map *entry;\n\tint retval = 0;\n\tint i;\n\n\ttables = kcalloc(nr_tables + 1, sizeof(struct ati_page_map *),\n\t\t\t GFP_KERNEL);\n\tif (tables == NULL)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < nr_tables; i++) {\n\t\tentry = kzalloc(sizeof(struct ati_page_map), GFP_KERNEL);\n\t\ttables[i] = entry;\n\t\tif (entry == NULL) {\n\t\t\tretval = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\tretval = ati_create_page_map(entry);\n\t\tif (retval != 0)\n\t\t\tbreak;\n\t}\n\tati_generic_private.num_tables = i;\n\tati_generic_private.gatt_pages = tables;\n\n\tif (retval != 0)\n\t\tati_free_gatt_pages();\n\n\treturn retval;\n}\n\nstatic int is_r200(void)\n{\n\tif ((agp_bridge->dev->device == PCI_DEVICE_ID_ATI_RS100) ||\n\t    (agp_bridge->dev->device == PCI_DEVICE_ID_ATI_RS200) ||\n\t    (agp_bridge->dev->device == PCI_DEVICE_ID_ATI_RS200_B) ||\n\t    (agp_bridge->dev->device == PCI_DEVICE_ID_ATI_RS250))\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int ati_fetch_size(void)\n{\n\tint i;\n\tu32 temp;\n\tstruct aper_size_info_lvl2 *values;\n\n\tif (is_r200())\n\t\tpci_read_config_dword(agp_bridge->dev, ATI_RS100_APSIZE, &temp);\n\telse\n\t\tpci_read_config_dword(agp_bridge->dev, ATI_RS300_APSIZE, &temp);\n\n\ttemp = (temp & 0x0000000e);\n\tvalues = A_SIZE_LVL2(agp_bridge->driver->aperture_sizes);\n\tfor (i = 0; i < agp_bridge->driver->num_aperture_sizes; i++) {\n\t\tif (temp == values[i].size_value) {\n\t\t\tagp_bridge->previous_size =\n\t\t\t    agp_bridge->current_size = (void *) (values + i);\n\n\t\t\tagp_bridge->aperture_size_idx = i;\n\t\t\treturn values[i].size;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void ati_tlbflush(struct agp_memory * mem)\n{\n\twritel(1, ati_generic_private.registers+ATI_GART_CACHE_CNTRL);\n\treadl(ati_generic_private.registers+ATI_GART_CACHE_CNTRL);\t \n}\n\nstatic void ati_cleanup(void)\n{\n\tstruct aper_size_info_lvl2 *previous_size;\n\tu32 temp;\n\n\tprevious_size = A_SIZE_LVL2(agp_bridge->previous_size);\n\n\t \n\tif (is_r200()) {\n\t\tpci_read_config_dword(agp_bridge->dev, ATI_RS100_APSIZE, &temp);\n\t\ttemp = ((temp & ~(0x0000000f)) | previous_size->size_value);\n\t\tpci_write_config_dword(agp_bridge->dev, ATI_RS100_APSIZE, temp);\n\t} else {\n\t\tpci_read_config_dword(agp_bridge->dev, ATI_RS300_APSIZE, &temp);\n\t\ttemp = ((temp & ~(0x0000000f)) | previous_size->size_value);\n\t\tpci_write_config_dword(agp_bridge->dev, ATI_RS300_APSIZE, temp);\n\t}\n\tiounmap((volatile u8 __iomem *)ati_generic_private.registers);\n}\n\n\nstatic int ati_configure(void)\n{\n\tphys_addr_t reg;\n\tu32 temp;\n\n\t \n\treg = pci_resource_start(agp_bridge->dev, ATI_GART_MMBASE_BAR);\n\tati_generic_private.registers = (volatile u8 __iomem *) ioremap(reg, 4096);\n\n\tif (!ati_generic_private.registers)\n\t\treturn -ENOMEM;\n\n\tif (is_r200())\n\t\tpci_write_config_dword(agp_bridge->dev, ATI_RS100_IG_AGPMODE, 0x20000);\n\telse\n\t\tpci_write_config_dword(agp_bridge->dev, ATI_RS300_IG_AGPMODE, 0x20000);\n\n\t \n\t \n\twritel(0x60000, ati_generic_private.registers+ATI_GART_FEATURE_ID);\n\treadl(ati_generic_private.registers+ATI_GART_FEATURE_ID);\t \n\n\t \n\tpci_read_config_dword(agp_bridge->dev, PCI_COMMAND, &temp);\n\tpci_write_config_dword(agp_bridge->dev, PCI_COMMAND, temp | (1<<14));\n\n\t \n\twritel(agp_bridge->gatt_bus_addr, ati_generic_private.registers+ATI_GART_BASE);\n\treadl(ati_generic_private.registers+ATI_GART_BASE);\t \n\n\treturn 0;\n}\n\n\nstatic int agp_ati_resume(struct device *dev)\n{\n\treturn ati_configure();\n}\n\n \n\n#define GET_PAGE_DIR_OFF(addr) (addr >> 22)\n#define GET_PAGE_DIR_IDX(addr) (GET_PAGE_DIR_OFF(addr) - \\\n\tGET_PAGE_DIR_OFF(agp_bridge->gart_bus_addr))\n#define GET_GATT_OFF(addr) ((addr & 0x003ff000) >> 12)\n#undef  GET_GATT\n#define GET_GATT(addr) (ati_generic_private.gatt_pages[\\\n\tGET_PAGE_DIR_IDX(addr)]->remapped)\n\nstatic int ati_insert_memory(struct agp_memory * mem,\n\t\t\t     off_t pg_start, int type)\n{\n\tint i, j, num_entries;\n\tunsigned long __iomem *cur_gatt;\n\tunsigned long addr;\n\tint mask_type;\n\n\tnum_entries = A_SIZE_LVL2(agp_bridge->current_size)->num_entries;\n\n\tmask_type = agp_generic_type_to_mask_type(mem->bridge, type);\n\tif (mask_type != 0 || type != mem->type)\n\t\treturn -EINVAL;\n\n\tif (mem->page_count == 0)\n\t\treturn 0;\n\n\tif ((pg_start + mem->page_count) > num_entries)\n\t\treturn -EINVAL;\n\n\tj = pg_start;\n\twhile (j < (pg_start + mem->page_count)) {\n\t\taddr = (j * PAGE_SIZE) + agp_bridge->gart_bus_addr;\n\t\tcur_gatt = GET_GATT(addr);\n\t\tif (!PGE_EMPTY(agp_bridge,readl(cur_gatt+GET_GATT_OFF(addr))))\n\t\t\treturn -EBUSY;\n\t\tj++;\n\t}\n\n\tif (!mem->is_flushed) {\n\t\t \n\t\tglobal_cache_flush();\n\t\tmem->is_flushed = true;\n\t}\n\n\tfor (i = 0, j = pg_start; i < mem->page_count; i++, j++) {\n\t\taddr = (j * PAGE_SIZE) + agp_bridge->gart_bus_addr;\n\t\tcur_gatt = GET_GATT(addr);\n\t\twritel(agp_bridge->driver->mask_memory(agp_bridge,\n\t\t\t\t\t\t       page_to_phys(mem->pages[i]),\n\t\t\t\t\t\t       mem->type),\n\t\t       cur_gatt+GET_GATT_OFF(addr));\n\t}\n\treadl(GET_GATT(agp_bridge->gart_bus_addr));  \n\tagp_bridge->driver->tlb_flush(mem);\n\treturn 0;\n}\n\nstatic int ati_remove_memory(struct agp_memory * mem, off_t pg_start,\n\t\t\t     int type)\n{\n\tint i;\n\tunsigned long __iomem *cur_gatt;\n\tunsigned long addr;\n\tint mask_type;\n\n\tmask_type = agp_generic_type_to_mask_type(mem->bridge, type);\n\tif (mask_type != 0 || type != mem->type)\n\t\treturn -EINVAL;\n\n\tif (mem->page_count == 0)\n\t\treturn 0;\n\n\tfor (i = pg_start; i < (mem->page_count + pg_start); i++) {\n\t\taddr = (i * PAGE_SIZE) + agp_bridge->gart_bus_addr;\n\t\tcur_gatt = GET_GATT(addr);\n\t\twritel(agp_bridge->scratch_page, cur_gatt+GET_GATT_OFF(addr));\n\t}\n\n\treadl(GET_GATT(agp_bridge->gart_bus_addr));  \n\tagp_bridge->driver->tlb_flush(mem);\n\treturn 0;\n}\n\nstatic int ati_create_gatt_table(struct agp_bridge_data *bridge)\n{\n\tstruct aper_size_info_lvl2 *value;\n\tstruct ati_page_map page_dir;\n\tunsigned long __iomem *cur_gatt;\n\tunsigned long addr;\n\tint retval;\n\tu32 temp;\n\tint i;\n\tstruct aper_size_info_lvl2 *current_size;\n\n\tvalue = A_SIZE_LVL2(agp_bridge->current_size);\n\tretval = ati_create_page_map(&page_dir);\n\tif (retval != 0)\n\t\treturn retval;\n\n\tretval = ati_create_gatt_pages(value->num_entries / 1024);\n\tif (retval != 0) {\n\t\tati_free_page_map(&page_dir);\n\t\treturn retval;\n\t}\n\n\tagp_bridge->gatt_table_real = (u32 *)page_dir.real;\n\tagp_bridge->gatt_table = (u32 __iomem *) page_dir.remapped;\n\tagp_bridge->gatt_bus_addr = virt_to_phys(page_dir.real);\n\n\t \n\tcurrent_size = A_SIZE_LVL2(agp_bridge->current_size);\n\n\tif (is_r200()) {\n\t\tpci_read_config_dword(agp_bridge->dev, ATI_RS100_APSIZE, &temp);\n\t\ttemp = (((temp & ~(0x0000000e)) | current_size->size_value)\n\t\t\t| 0x00000001);\n\t\tpci_write_config_dword(agp_bridge->dev, ATI_RS100_APSIZE, temp);\n\t\tpci_read_config_dword(agp_bridge->dev, ATI_RS100_APSIZE, &temp);\n\t} else {\n\t\tpci_read_config_dword(agp_bridge->dev, ATI_RS300_APSIZE, &temp);\n\t\ttemp = (((temp & ~(0x0000000e)) | current_size->size_value)\n\t\t\t| 0x00000001);\n\t\tpci_write_config_dword(agp_bridge->dev, ATI_RS300_APSIZE, temp);\n\t\tpci_read_config_dword(agp_bridge->dev, ATI_RS300_APSIZE, &temp);\n\t}\n\n\t \n\taddr = pci_bus_address(agp_bridge->dev, AGP_APERTURE_BAR);\n\tagp_bridge->gart_bus_addr = addr;\n\n\t \n\tfor (i = 0; i < value->num_entries / 1024; i++, addr += 0x00400000) {\n\t\twritel(virt_to_phys(ati_generic_private.gatt_pages[i]->real) | 1,\n\t\t\tpage_dir.remapped+GET_PAGE_DIR_OFF(addr));\n\t\treadl(page_dir.remapped+GET_PAGE_DIR_OFF(addr));\t \n\t}\n\n\tfor (i = 0; i < value->num_entries; i++) {\n\t\taddr = (i * PAGE_SIZE) + agp_bridge->gart_bus_addr;\n\t\tcur_gatt = GET_GATT(addr);\n\t\twritel(agp_bridge->scratch_page, cur_gatt+GET_GATT_OFF(addr));\n\t}\n\n\treturn 0;\n}\n\nstatic int ati_free_gatt_table(struct agp_bridge_data *bridge)\n{\n\tstruct ati_page_map page_dir;\n\n\tpage_dir.real = (unsigned long *)agp_bridge->gatt_table_real;\n\tpage_dir.remapped = (unsigned long __iomem *)agp_bridge->gatt_table;\n\n\tati_free_gatt_pages();\n\tati_free_page_map(&page_dir);\n\treturn 0;\n}\n\nstatic const struct agp_bridge_driver ati_generic_bridge = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.aperture_sizes\t\t= ati_generic_sizes,\n\t.size_type\t\t= LVL2_APER_SIZE,\n\t.num_aperture_sizes\t= 7,\n\t.needs_scratch_page\t= true,\n\t.configure\t\t= ati_configure,\n\t.fetch_size\t\t= ati_fetch_size,\n\t.cleanup\t\t= ati_cleanup,\n\t.tlb_flush\t\t= ati_tlbflush,\n\t.mask_memory\t\t= agp_generic_mask_memory,\n\t.masks\t\t\t= ati_generic_masks,\n\t.agp_enable\t\t= agp_generic_enable,\n\t.cache_flush\t\t= global_cache_flush,\n\t.create_gatt_table\t= ati_create_gatt_table,\n\t.free_gatt_table\t= ati_free_gatt_table,\n\t.insert_memory\t\t= ati_insert_memory,\n\t.remove_memory\t\t= ati_remove_memory,\n\t.alloc_by_type\t\t= agp_generic_alloc_by_type,\n\t.free_by_type\t\t= agp_generic_free_by_type,\n\t.agp_alloc_page\t\t= agp_generic_alloc_page,\n\t.agp_alloc_pages\t= agp_generic_alloc_pages,\n\t.agp_destroy_page\t= agp_generic_destroy_page,\n\t.agp_destroy_pages\t= agp_generic_destroy_pages,\n\t.agp_type_to_mask_type  = agp_generic_type_to_mask_type,\n};\n\n\nstatic struct agp_device_ids ati_agp_device_ids[] =\n{\n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_ATI_RS100,\n\t\t.chipset_name\t= \"IGP320/M\",\n\t},\n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_ATI_RS200,\n\t\t.chipset_name\t= \"IGP330/340/345/350/M\",\n\t},\n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_ATI_RS200_B,\n\t\t.chipset_name\t= \"IGP345M\",\n\t},\n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_ATI_RS250,\n\t\t.chipset_name\t= \"IGP7000/M\",\n\t},\n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_ATI_RS300_100,\n\t\t.chipset_name\t= \"IGP9100/M\",\n\t},\n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_ATI_RS300_133,\n\t\t.chipset_name\t= \"IGP9100/M\",\n\t},\n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_ATI_RS300_166,\n\t\t.chipset_name\t= \"IGP9100/M\",\n\t},\n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_ATI_RS300_200,\n\t\t.chipset_name\t= \"IGP9100/M\",\n\t},\n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_ATI_RS350_133,\n\t\t.chipset_name\t= \"IGP9000/M\",\n\t},\n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_ATI_RS350_200,\n\t\t.chipset_name\t= \"IGP9100/M\",\n\t},\n\t{ },  \n};\n\nstatic int agp_ati_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct agp_device_ids *devs = ati_agp_device_ids;\n\tstruct agp_bridge_data *bridge;\n\tu8 cap_ptr;\n\tint j;\n\n\tcap_ptr = pci_find_capability(pdev, PCI_CAP_ID_AGP);\n\tif (!cap_ptr)\n\t\treturn -ENODEV;\n\n\t \n\tfor (j = 0; devs[j].chipset_name; j++) {\n\t\tif (pdev->device == devs[j].device_id)\n\t\t\tgoto found;\n\t}\n\n\tdev_err(&pdev->dev, \"unsupported Ati chipset [%04x/%04x])\\n\",\n\t\tpdev->vendor, pdev->device);\n\treturn -ENODEV;\n\nfound:\n\tbridge = agp_alloc_bridge();\n\tif (!bridge)\n\t\treturn -ENOMEM;\n\n\tbridge->dev = pdev;\n\tbridge->capndx = cap_ptr;\n\n\tbridge->driver = &ati_generic_bridge;\n\n\tdev_info(&pdev->dev, \"Ati %s chipset\\n\", devs[j].chipset_name);\n\n\t \n\tpci_read_config_dword(pdev,\n\t\t\tbridge->capndx+PCI_AGP_STATUS,\n\t\t\t&bridge->mode);\n\n\tpci_set_drvdata(pdev, bridge);\n\treturn agp_add_bridge(bridge);\n}\n\nstatic void agp_ati_remove(struct pci_dev *pdev)\n{\n\tstruct agp_bridge_data *bridge = pci_get_drvdata(pdev);\n\n\tagp_remove_bridge(bridge);\n\tagp_put_bridge(bridge);\n}\n\nstatic const struct pci_device_id agp_ati_pci_table[] = {\n\t{\n\t.class\t\t= (PCI_CLASS_BRIDGE_HOST << 8),\n\t.class_mask\t= ~0,\n\t.vendor\t\t= PCI_VENDOR_ID_ATI,\n\t.device\t\t= PCI_ANY_ID,\n\t.subvendor\t= PCI_ANY_ID,\n\t.subdevice\t= PCI_ANY_ID,\n\t},\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(pci, agp_ati_pci_table);\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(agp_ati_pm_ops, NULL, agp_ati_resume);\n\nstatic struct pci_driver agp_ati_pci_driver = {\n\t.name\t\t= \"agpgart-ati\",\n\t.id_table\t= agp_ati_pci_table,\n\t.probe\t\t= agp_ati_probe,\n\t.remove\t\t= agp_ati_remove,\n\t.driver.pm\t= &agp_ati_pm_ops,\n};\n\nstatic int __init agp_ati_init(void)\n{\n\tif (agp_off)\n\t\treturn -EINVAL;\n\treturn pci_register_driver(&agp_ati_pci_driver);\n}\n\nstatic void __exit agp_ati_cleanup(void)\n{\n\tpci_unregister_driver(&agp_ati_pci_driver);\n}\n\nmodule_init(agp_ati_init);\nmodule_exit(agp_ati_cleanup);\n\nMODULE_AUTHOR(\"Dave Jones\");\nMODULE_LICENSE(\"GPL and additional rights\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}