{
  "module_name": "amd64-agp.c",
  "hash_id": "05d23cddeb206ae366d1420a66b7c4c439e170547170312fe3033b1ace450f27",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/agp/amd64-agp.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/init.h>\n#include <linux/agp_backend.h>\n#include <linux/mmzone.h>\n#include <asm/page.h>\t\t \n#include <asm/e820/api.h>\n#include <asm/amd_nb.h>\n#include <asm/gart.h>\n#include \"agp.h\"\n\n \n#define NVIDIA_X86_64_0_APBASE\t\t0x10\n#define NVIDIA_X86_64_1_APBASE1\t\t0x50\n#define NVIDIA_X86_64_1_APLIMIT1\t0x54\n#define NVIDIA_X86_64_1_APSIZE\t\t0xa8\n#define NVIDIA_X86_64_1_APBASE2\t\t0xd8\n#define NVIDIA_X86_64_1_APLIMIT2\t0xdc\n\n \n#define ULI_X86_64_BASE_ADDR\t\t0x10\n#define ULI_X86_64_HTT_FEA_REG\t\t0x50\n#define ULI_X86_64_ENU_SCR_REG\t\t0x54\n\nstatic struct resource *aperture_resource;\nstatic bool __initdata agp_try_unsupported = 1;\nstatic int agp_bridges_found;\n\nstatic void amd64_tlbflush(struct agp_memory *temp)\n{\n\tamd_flush_garts();\n}\n\nstatic int amd64_insert_memory(struct agp_memory *mem, off_t pg_start, int type)\n{\n\tint i, j, num_entries;\n\tlong long tmp;\n\tint mask_type;\n\tstruct agp_bridge_data *bridge = mem->bridge;\n\tu32 pte;\n\n\tnum_entries = agp_num_entries();\n\n\tif (type != mem->type)\n\t\treturn -EINVAL;\n\tmask_type = bridge->driver->agp_type_to_mask_type(bridge, type);\n\tif (mask_type != 0)\n\t\treturn -EINVAL;\n\n\n\t \n\t \n\tif (((unsigned long)pg_start + mem->page_count) > num_entries)\n\t\treturn -EINVAL;\n\n\tj = pg_start;\n\n\t \n\twhile (j < (pg_start + mem->page_count)) {\n\t\tif (!PGE_EMPTY(agp_bridge, readl(agp_bridge->gatt_table+j)))\n\t\t\treturn -EBUSY;\n\t\tj++;\n\t}\n\n\tif (!mem->is_flushed) {\n\t\tglobal_cache_flush();\n\t\tmem->is_flushed = true;\n\t}\n\n\tfor (i = 0, j = pg_start; i < mem->page_count; i++, j++) {\n\t\ttmp = agp_bridge->driver->mask_memory(agp_bridge,\n\t\t\t\t\t\t      page_to_phys(mem->pages[i]),\n\t\t\t\t\t\t      mask_type);\n\n\t\tBUG_ON(tmp & 0xffffff0000000ffcULL);\n\t\tpte = (tmp & 0x000000ff00000000ULL) >> 28;\n\t\tpte |=(tmp & 0x00000000fffff000ULL);\n\t\tpte |= GPTE_VALID | GPTE_COHERENT;\n\n\t\twritel(pte, agp_bridge->gatt_table+j);\n\t\treadl(agp_bridge->gatt_table+j);\t \n\t}\n\tamd64_tlbflush(mem);\n\treturn 0;\n}\n\n \nstatic struct aper_size_info_32 amd64_aperture_sizes[7] =\n{\n\t{32,   8192,   3+(sizeof(long)/8), 0 },\n\t{64,   16384,  4+(sizeof(long)/8), 1<<1 },\n\t{128,  32768,  5+(sizeof(long)/8), 1<<2 },\n\t{256,  65536,  6+(sizeof(long)/8), 1<<1 | 1<<2 },\n\t{512,  131072, 7+(sizeof(long)/8), 1<<3 },\n\t{1024, 262144, 8+(sizeof(long)/8), 1<<1 | 1<<3},\n\t{2048, 524288, 9+(sizeof(long)/8), 1<<2 | 1<<3}\n};\n\n\n \nstatic int amd64_fetch_size(void)\n{\n\tstruct pci_dev *dev;\n\tint i;\n\tu32 temp;\n\tstruct aper_size_info_32 *values;\n\n\tdev = node_to_amd_nb(0)->misc;\n\tif (dev==NULL)\n\t\treturn 0;\n\n\tpci_read_config_dword(dev, AMD64_GARTAPERTURECTL, &temp);\n\ttemp = (temp & 0xe);\n\tvalues = A_SIZE_32(amd64_aperture_sizes);\n\n\tfor (i = 0; i < agp_bridge->driver->num_aperture_sizes; i++) {\n\t\tif (temp == values[i].size_value) {\n\t\t\tagp_bridge->previous_size =\n\t\t\t    agp_bridge->current_size = (void *) (values + i);\n\n\t\t\tagp_bridge->aperture_size_idx = i;\n\t\t\treturn values[i].size;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic u64 amd64_configure(struct pci_dev *hammer, u64 gatt_table)\n{\n\tu64 aperturebase;\n\tu32 tmp;\n\tu64 aper_base;\n\n\t \n\tpci_read_config_dword(hammer, AMD64_GARTAPERTUREBASE, &tmp);\n\taperturebase = (u64)tmp << 25;\n\taper_base = (aperturebase & PCI_BASE_ADDRESS_MEM_MASK);\n\n\tenable_gart_translation(hammer, gatt_table);\n\n\treturn aper_base;\n}\n\n\nstatic const struct aper_size_info_32 amd_8151_sizes[7] =\n{\n\t{2048, 524288, 9, 0x00000000 },\t \n\t{1024, 262144, 8, 0x00000400 },\t \n\t{512,  131072, 7, 0x00000600 },\t \n\t{256,  65536,  6, 0x00000700 },\t \n\t{128,  32768,  5, 0x00000720 },\t \n\t{64,   16384,  4, 0x00000730 },\t \n\t{32,   8192,   3, 0x00000738 }\t \n};\n\nstatic int amd_8151_configure(void)\n{\n\tunsigned long gatt_bus = virt_to_phys(agp_bridge->gatt_table_real);\n\tint i;\n\n\tif (!amd_nb_has_feature(AMD_NB_GART))\n\t\treturn 0;\n\n\t \n\tfor (i = 0; i < amd_nb_num(); i++) {\n\t\tagp_bridge->gart_bus_addr =\n\t\t\tamd64_configure(node_to_amd_nb(i)->misc, gatt_bus);\n\t}\n\tamd_flush_garts();\n\treturn 0;\n}\n\n\nstatic void amd64_cleanup(void)\n{\n\tu32 tmp;\n\tint i;\n\n\tif (!amd_nb_has_feature(AMD_NB_GART))\n\t\treturn;\n\n\tfor (i = 0; i < amd_nb_num(); i++) {\n\t\tstruct pci_dev *dev = node_to_amd_nb(i)->misc;\n\t\t \n\t\tpci_read_config_dword(dev, AMD64_GARTAPERTURECTL, &tmp);\n\t\ttmp &= ~GARTEN;\n\t\tpci_write_config_dword(dev, AMD64_GARTAPERTURECTL, tmp);\n\t}\n}\n\n\nstatic const struct agp_bridge_driver amd_8151_driver = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.aperture_sizes\t\t= amd_8151_sizes,\n\t.size_type\t\t= U32_APER_SIZE,\n\t.num_aperture_sizes\t= 7,\n\t.needs_scratch_page\t= true,\n\t.configure\t\t= amd_8151_configure,\n\t.fetch_size\t\t= amd64_fetch_size,\n\t.cleanup\t\t= amd64_cleanup,\n\t.tlb_flush\t\t= amd64_tlbflush,\n\t.mask_memory\t\t= agp_generic_mask_memory,\n\t.masks\t\t\t= NULL,\n\t.agp_enable\t\t= agp_generic_enable,\n\t.cache_flush\t\t= global_cache_flush,\n\t.create_gatt_table\t= agp_generic_create_gatt_table,\n\t.free_gatt_table\t= agp_generic_free_gatt_table,\n\t.insert_memory\t\t= amd64_insert_memory,\n\t.remove_memory\t\t= agp_generic_remove_memory,\n\t.alloc_by_type\t\t= agp_generic_alloc_by_type,\n\t.free_by_type\t\t= agp_generic_free_by_type,\n\t.agp_alloc_page\t\t= agp_generic_alloc_page,\n\t.agp_alloc_pages\t= agp_generic_alloc_pages,\n\t.agp_destroy_page\t= agp_generic_destroy_page,\n\t.agp_destroy_pages\t= agp_generic_destroy_pages,\n\t.agp_type_to_mask_type  = agp_generic_type_to_mask_type,\n};\n\n \nstatic int agp_aperture_valid(u64 aper, u32 size)\n{\n\tif (!aperture_valid(aper, size, 32*1024*1024))\n\t\treturn 0;\n\n\t \n\tif (!aperture_resource &&\n\t    !(aperture_resource = request_mem_region(aper, size, \"aperture\"))) {\n\t\tprintk(KERN_ERR PFX \"Aperture conflicts with PCI mapping.\\n\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n \nstatic int fix_northbridge(struct pci_dev *nb, struct pci_dev *agp, u16 cap)\n{\n\tu64 aper, nb_aper;\n\tint order = 0;\n\tu32 nb_order, nb_base;\n\tu16 apsize;\n\n\tpci_read_config_dword(nb, AMD64_GARTAPERTURECTL, &nb_order);\n\tnb_order = (nb_order >> 1) & 7;\n\tpci_read_config_dword(nb, AMD64_GARTAPERTUREBASE, &nb_base);\n\tnb_aper = (u64)nb_base << 25;\n\n\t \n\n\tpci_read_config_word(agp, cap+0x14, &apsize);\n\tif (apsize == 0xffff) {\n\t\tif (agp_aperture_valid(nb_aper, (32*1024*1024)<<nb_order))\n\t\t\treturn 0;\n\t\treturn -1;\n\t}\n\n\tapsize &= 0xfff;\n\t \n\tif (apsize & 0xff)\n\t\tapsize |= 0xf00;\n\torder = 7 - hweight16(apsize);\n\n\taper = pci_bus_address(agp, AGP_APERTURE_BAR);\n\n\t \n\tif (order >=0 && aper + (32ULL<<(20 + order)) > 0x100000000ULL) {\n\t\tdev_info(&agp->dev, \"aperture size %u MB is not right, using settings from NB\\n\",\n\t\t\t 32 << order);\n\t\torder = nb_order;\n\t}\n\n\tif (nb_order >= order) {\n\t\tif (agp_aperture_valid(nb_aper, (32*1024*1024)<<nb_order))\n\t\t\treturn 0;\n\t}\n\n\tdev_info(&agp->dev, \"aperture from AGP @ %Lx size %u MB\\n\",\n\t\t aper, 32 << order);\n\tif (order < 0 || !agp_aperture_valid(aper, (32*1024*1024)<<order))\n\t\treturn -1;\n\n\tgart_set_size_and_enable(nb, order);\n\tpci_write_config_dword(nb, AMD64_GARTAPERTUREBASE, aper >> 25);\n\n\treturn 0;\n}\n\nstatic int cache_nbs(struct pci_dev *pdev, u32 cap_ptr)\n{\n\tint i;\n\n\tif (!amd_nb_num())\n\t\treturn -ENODEV;\n\n\tif (!amd_nb_has_feature(AMD_NB_GART))\n\t\treturn -ENODEV;\n\n\ti = 0;\n\tfor (i = 0; i < amd_nb_num(); i++) {\n\t\tstruct pci_dev *dev = node_to_amd_nb(i)->misc;\n\t\tif (fix_northbridge(dev, pdev, cap_ptr) < 0) {\n\t\t\tdev_err(&dev->dev, \"no usable aperture found\\n\");\n#ifdef __x86_64__\n\t\t\t \n\t\t\tdev_err(&dev->dev, \"consider rebooting with iommu=memaper=2 to get a good aperture\\n\");\n#endif\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic void amd8151_init(struct pci_dev *pdev, struct agp_bridge_data *bridge)\n{\n\tchar *revstring;\n\n\tswitch (pdev->revision) {\n\tcase 0x01: revstring=\"A0\"; break;\n\tcase 0x02: revstring=\"A1\"; break;\n\tcase 0x11: revstring=\"B0\"; break;\n\tcase 0x12: revstring=\"B1\"; break;\n\tcase 0x13: revstring=\"B2\"; break;\n\tcase 0x14: revstring=\"B3\"; break;\n\tdefault:   revstring=\"??\"; break;\n\t}\n\n\tdev_info(&pdev->dev, \"AMD 8151 AGP Bridge rev %s\\n\", revstring);\n\n\t \n\tif (pdev->revision < 0x13) {\n\t\tdev_info(&pdev->dev, \"correcting AGP revision (reports 3.5, is really 3.0)\\n\");\n\t\tbridge->major_version = 3;\n\t\tbridge->minor_version = 0;\n\t}\n}\n\n\nstatic const struct aper_size_info_32 uli_sizes[7] =\n{\n\t{256, 65536, 6, 10},\n\t{128, 32768, 5, 9},\n\t{64, 16384, 4, 8},\n\t{32, 8192, 3, 7},\n\t{16, 4096, 2, 6},\n\t{8, 2048, 1, 4},\n\t{4, 1024, 0, 3}\n};\nstatic int uli_agp_init(struct pci_dev *pdev)\n{\n\tu32 httfea,baseaddr,enuscr;\n\tstruct pci_dev *dev1;\n\tint i, ret;\n\tunsigned size = amd64_fetch_size();\n\n\tdev_info(&pdev->dev, \"setting up ULi AGP\\n\");\n\tdev1 = pci_get_slot (pdev->bus,PCI_DEVFN(0,0));\n\tif (dev1 == NULL) {\n\t\tdev_info(&pdev->dev, \"can't find ULi secondary device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(uli_sizes); i++)\n\t\tif (uli_sizes[i].size == size)\n\t\t\tbreak;\n\n\tif (i == ARRAY_SIZE(uli_sizes)) {\n\t\tdev_info(&pdev->dev, \"no ULi size found for %d\\n\", size);\n\t\tret = -ENODEV;\n\t\tgoto put;\n\t}\n\n\t \n\tpci_read_config_dword (node_to_amd_nb(0)->misc, AMD64_GARTAPERTUREBASE,\n\t\t\t       &httfea);\n\n\t \n\tif ((httfea & 0x7fff) >> (32 - 25)) {\n\t\tret = -ENODEV;\n\t\tgoto put;\n\t}\n\n\thttfea = (httfea& 0x7fff) << 25;\n\n\tpci_read_config_dword(pdev, ULI_X86_64_BASE_ADDR, &baseaddr);\n\tbaseaddr&= ~PCI_BASE_ADDRESS_MEM_MASK;\n\tbaseaddr|= httfea;\n\tpci_write_config_dword(pdev, ULI_X86_64_BASE_ADDR, baseaddr);\n\n\tenuscr= httfea+ (size * 1024 * 1024) - 1;\n\tpci_write_config_dword(dev1, ULI_X86_64_HTT_FEA_REG, httfea);\n\tpci_write_config_dword(dev1, ULI_X86_64_ENU_SCR_REG, enuscr);\n\tret = 0;\nput:\n\tpci_dev_put(dev1);\n\treturn ret;\n}\n\n\nstatic const struct aper_size_info_32 nforce3_sizes[5] =\n{\n\t{512,  131072, 7, 0x00000000 },\n\t{256,  65536,  6, 0x00000008 },\n\t{128,  32768,  5, 0x0000000C },\n\t{64,   16384,  4, 0x0000000E },\n\t{32,   8192,   3, 0x0000000F }\n};\n\n \n \nstatic int nforce3_agp_init(struct pci_dev *pdev)\n{\n\tu32 tmp, apbase, apbar, aplimit;\n\tstruct pci_dev *dev1;\n\tint i, ret;\n\tunsigned size = amd64_fetch_size();\n\n\tdev_info(&pdev->dev, \"setting up Nforce3 AGP\\n\");\n\n\tdev1 = pci_get_slot(pdev->bus, PCI_DEVFN(11, 0));\n\tif (dev1 == NULL) {\n\t\tdev_info(&pdev->dev, \"can't find Nforce3 secondary device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(nforce3_sizes); i++)\n\t\tif (nforce3_sizes[i].size == size)\n\t\t\tbreak;\n\n\tif (i == ARRAY_SIZE(nforce3_sizes)) {\n\t\tdev_info(&pdev->dev, \"no NForce3 size found for %d\\n\", size);\n\t\tret = -ENODEV;\n\t\tgoto put;\n\t}\n\n\tpci_read_config_dword(dev1, NVIDIA_X86_64_1_APSIZE, &tmp);\n\ttmp &= ~(0xf);\n\ttmp |= nforce3_sizes[i].size_value;\n\tpci_write_config_dword(dev1, NVIDIA_X86_64_1_APSIZE, tmp);\n\n\t \n\tpci_read_config_dword (node_to_amd_nb(0)->misc, AMD64_GARTAPERTUREBASE,\n\t\t\t       &apbase);\n\n\t \n\tif ( (apbase & 0x7fff) >> (32 - 25) ) {\n\t\tdev_info(&pdev->dev, \"aperture base > 4G\\n\");\n\t\tret = -ENODEV;\n\t\tgoto put;\n\t}\n\n\tapbase = (apbase & 0x7fff) << 25;\n\n\tpci_read_config_dword(pdev, NVIDIA_X86_64_0_APBASE, &apbar);\n\tapbar &= ~PCI_BASE_ADDRESS_MEM_MASK;\n\tapbar |= apbase;\n\tpci_write_config_dword(pdev, NVIDIA_X86_64_0_APBASE, apbar);\n\n\taplimit = apbase + (size * 1024 * 1024) - 1;\n\tpci_write_config_dword(dev1, NVIDIA_X86_64_1_APBASE1, apbase);\n\tpci_write_config_dword(dev1, NVIDIA_X86_64_1_APLIMIT1, aplimit);\n\tpci_write_config_dword(dev1, NVIDIA_X86_64_1_APBASE2, apbase);\n\tpci_write_config_dword(dev1, NVIDIA_X86_64_1_APLIMIT2, aplimit);\n\n\tret = 0;\nput:\n\tpci_dev_put(dev1);\n\n\treturn ret;\n}\n\nstatic int agp_amd64_probe(struct pci_dev *pdev,\n\t\t\t   const struct pci_device_id *ent)\n{\n\tstruct agp_bridge_data *bridge;\n\tu8 cap_ptr;\n\tint err;\n\n\t \n\tif (agp_bridges_found)\n\t\treturn -ENODEV;\n\n\tcap_ptr = pci_find_capability(pdev, PCI_CAP_ID_AGP);\n\tif (!cap_ptr)\n\t\treturn -ENODEV;\n\n\t \n\n\tbridge = agp_alloc_bridge();\n\tif (!bridge)\n\t\treturn -ENOMEM;\n\n\tif (pdev->vendor == PCI_VENDOR_ID_AMD &&\n\t    pdev->device == PCI_DEVICE_ID_AMD_8151_0) {\n\t\tamd8151_init(pdev, bridge);\n\t} else {\n\t\tdev_info(&pdev->dev, \"AGP bridge [%04x/%04x]\\n\",\n\t\t\t pdev->vendor, pdev->device);\n\t}\n\n\tbridge->driver = &amd_8151_driver;\n\tbridge->dev = pdev;\n\tbridge->capndx = cap_ptr;\n\n\t \n\tpci_read_config_dword(pdev, bridge->capndx+PCI_AGP_STATUS, &bridge->mode);\n\n\tif (cache_nbs(pdev, cap_ptr) == -1) {\n\t\tagp_put_bridge(bridge);\n\t\treturn -ENODEV;\n\t}\n\n\tif (pdev->vendor == PCI_VENDOR_ID_NVIDIA) {\n\t\tint ret = nforce3_agp_init(pdev);\n\t\tif (ret) {\n\t\t\tagp_put_bridge(bridge);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (pdev->vendor == PCI_VENDOR_ID_AL) {\n\t\tint ret = uli_agp_init(pdev);\n\t\tif (ret) {\n\t\t\tagp_put_bridge(bridge);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpci_set_drvdata(pdev, bridge);\n\terr = agp_add_bridge(bridge);\n\tif (err < 0)\n\t\treturn err;\n\n\tagp_bridges_found++;\n\treturn 0;\n}\n\nstatic void agp_amd64_remove(struct pci_dev *pdev)\n{\n\tstruct agp_bridge_data *bridge = pci_get_drvdata(pdev);\n\n\trelease_mem_region(virt_to_phys(bridge->gatt_table_real),\n\t\t\t   amd64_aperture_sizes[bridge->aperture_size_idx].size);\n\tagp_remove_bridge(bridge);\n\tagp_put_bridge(bridge);\n\n\tagp_bridges_found--;\n}\n\nstatic int agp_amd64_resume(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\n\tif (pdev->vendor == PCI_VENDOR_ID_NVIDIA)\n\t\tnforce3_agp_init(pdev);\n\n\treturn amd_8151_configure();\n}\n\nstatic const struct pci_device_id agp_amd64_pci_table[] = {\n\t{\n\t.class\t\t= (PCI_CLASS_BRIDGE_HOST << 8),\n\t.class_mask\t= ~0,\n\t.vendor\t\t= PCI_VENDOR_ID_AMD,\n\t.device\t\t= PCI_DEVICE_ID_AMD_8151_0,\n\t.subvendor\t= PCI_ANY_ID,\n\t.subdevice\t= PCI_ANY_ID,\n\t},\n\t \n\t{\n\t.class\t\t= (PCI_CLASS_BRIDGE_HOST << 8),\n\t.class_mask\t= ~0,\n\t.vendor\t\t= PCI_VENDOR_ID_AL,\n\t.device\t\t= PCI_DEVICE_ID_AL_M1689,\n\t.subvendor\t= PCI_ANY_ID,\n\t.subdevice\t= PCI_ANY_ID,\n\t},\n\t \n\t{\n\t.class\t\t= (PCI_CLASS_BRIDGE_HOST << 8),\n\t.class_mask\t= ~0,\n\t.vendor\t\t= PCI_VENDOR_ID_VIA,\n\t.device\t\t= PCI_DEVICE_ID_VIA_K8T800PRO_0,\n\t.subvendor\t= PCI_ANY_ID,\n\t.subdevice\t= PCI_ANY_ID,\n\t},\n\t \n\t{\n\t.class\t\t= (PCI_CLASS_BRIDGE_HOST << 8),\n\t.class_mask\t= ~0,\n\t.vendor\t\t= PCI_VENDOR_ID_VIA,\n\t.device\t\t= PCI_DEVICE_ID_VIA_8385_0,\n\t.subvendor\t= PCI_ANY_ID,\n\t.subdevice\t= PCI_ANY_ID,\n\t},\n\t \n\t{\n\t.class\t\t= (PCI_CLASS_BRIDGE_HOST << 8),\n\t.class_mask\t= ~0,\n\t.vendor\t\t= PCI_VENDOR_ID_VIA,\n\t.device\t\t= PCI_DEVICE_ID_VIA_8380_0,\n\t.subvendor\t= PCI_ANY_ID,\n\t.subdevice\t= PCI_ANY_ID,\n\t},\n\t \n\t{\n\t.class          = (PCI_CLASS_BRIDGE_HOST << 8),\n\t.class_mask     = ~0,\n\t.vendor         = PCI_VENDOR_ID_VIA,\n\t.device         = PCI_DEVICE_ID_VIA_VT3336,\n\t.subvendor      = PCI_ANY_ID,\n\t.subdevice      = PCI_ANY_ID,\n\t},\n\t \n\t{\n\t.class\t\t= (PCI_CLASS_BRIDGE_HOST << 8),\n\t.class_mask\t= ~0,\n\t.vendor\t\t= PCI_VENDOR_ID_VIA,\n\t.device\t\t= PCI_DEVICE_ID_VIA_3238_0,\n\t.subvendor\t= PCI_ANY_ID,\n\t.subdevice\t= PCI_ANY_ID,\n\t},\n\t \n\t{\n\t.class\t\t= (PCI_CLASS_BRIDGE_HOST << 8),\n\t.class_mask\t= ~0,\n\t.vendor\t\t= PCI_VENDOR_ID_VIA,\n\t.device\t\t= PCI_DEVICE_ID_VIA_838X_1,\n\t.subvendor\t= PCI_ANY_ID,\n\t.subdevice\t= PCI_ANY_ID,\n\t},\n\t \n\t{\n\t.class\t\t= (PCI_CLASS_BRIDGE_HOST << 8),\n\t.class_mask\t= ~0,\n\t.vendor\t\t= PCI_VENDOR_ID_NVIDIA,\n\t.device\t\t= PCI_DEVICE_ID_NVIDIA_NFORCE3,\n\t.subvendor\t= PCI_ANY_ID,\n\t.subdevice\t= PCI_ANY_ID,\n\t},\n\t{\n\t.class\t\t= (PCI_CLASS_BRIDGE_HOST << 8),\n\t.class_mask\t= ~0,\n\t.vendor\t\t= PCI_VENDOR_ID_NVIDIA,\n\t.device\t\t= PCI_DEVICE_ID_NVIDIA_NFORCE3S,\n\t.subvendor\t= PCI_ANY_ID,\n\t.subdevice\t= PCI_ANY_ID,\n\t},\n\t \n\t{\n\t.class\t\t= (PCI_CLASS_BRIDGE_HOST << 8),\n\t.class_mask\t= ~0,\n\t.vendor\t\t= PCI_VENDOR_ID_SI,\n\t.device\t\t= PCI_DEVICE_ID_SI_755,\n\t.subvendor\t= PCI_ANY_ID,\n\t.subdevice\t= PCI_ANY_ID,\n\t},\n\t \n\t{\n\t.class\t\t= (PCI_CLASS_BRIDGE_HOST << 8),\n\t.class_mask\t= ~0,\n\t.vendor\t\t= PCI_VENDOR_ID_SI,\n\t.device\t\t= PCI_DEVICE_ID_SI_760,\n\t.subvendor\t= PCI_ANY_ID,\n\t.subdevice\t= PCI_ANY_ID,\n\t},\n\t \n\t{\n\t.class\t\t= (PCI_CLASS_BRIDGE_HOST << 8),\n\t.class_mask\t= ~0,\n\t.vendor\t\t= PCI_VENDOR_ID_AL,\n\t.device\t\t= 0x1695,\n\t.subvendor\t= PCI_ANY_ID,\n\t.subdevice\t= PCI_ANY_ID,\n\t},\n\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(pci, agp_amd64_pci_table);\n\nstatic const struct pci_device_id agp_amd64_pci_promisc_table[] = {\n\t{ PCI_DEVICE_CLASS(0, 0) },\n\t{ }\n};\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(agp_amd64_pm_ops, NULL, agp_amd64_resume);\n\nstatic struct pci_driver agp_amd64_pci_driver = {\n\t.name\t\t= \"agpgart-amd64\",\n\t.id_table\t= agp_amd64_pci_table,\n\t.probe\t\t= agp_amd64_probe,\n\t.remove\t\t= agp_amd64_remove,\n\t.driver.pm  = &agp_amd64_pm_ops,\n};\n\n\n \nint __init agp_amd64_init(void)\n{\n\tint err = 0;\n\n\tif (agp_off)\n\t\treturn -EINVAL;\n\n\terr = pci_register_driver(&agp_amd64_pci_driver);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (agp_bridges_found == 0) {\n\t\tif (!agp_try_unsupported && !agp_try_unsupported_boot) {\n\t\t\tprintk(KERN_INFO PFX \"No supported AGP bridge found.\\n\");\n#ifdef MODULE\n\t\t\tprintk(KERN_INFO PFX \"You can try agp_try_unsupported=1\\n\");\n#else\n\t\t\tprintk(KERN_INFO PFX \"You can boot with agp=try_unsupported\\n\");\n#endif\n\t\t\tpci_unregister_driver(&agp_amd64_pci_driver);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\t \n\t\tif (!amd_nb_num()) {\n\t\t\tpci_unregister_driver(&agp_amd64_pci_driver);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\t \n\t\tagp_amd64_pci_driver.id_table = agp_amd64_pci_promisc_table;\n\t\terr = driver_attach(&agp_amd64_pci_driver.driver);\n\t\tif (err == 0 && agp_bridges_found == 0) {\n\t\t\tpci_unregister_driver(&agp_amd64_pci_driver);\n\t\t\terr = -ENODEV;\n\t\t}\n\t}\n\treturn err;\n}\n\nstatic int __init agp_amd64_mod_init(void)\n{\n#ifndef MODULE\n\tif (gart_iommu_aperture)\n\t\treturn agp_bridges_found ? 0 : -ENODEV;\n#endif\n\treturn agp_amd64_init();\n}\n\nstatic void __exit agp_amd64_cleanup(void)\n{\n#ifndef MODULE\n\tif (gart_iommu_aperture)\n\t\treturn;\n#endif\n\tif (aperture_resource)\n\t\trelease_resource(aperture_resource);\n\tpci_unregister_driver(&agp_amd64_pci_driver);\n}\n\nmodule_init(agp_amd64_mod_init);\nmodule_exit(agp_amd64_cleanup);\n\nMODULE_AUTHOR(\"Dave Jones, Andi Kleen\");\nmodule_param(agp_try_unsupported, bool, 0);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}