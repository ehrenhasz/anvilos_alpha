{
  "module_name": "ali-agp.c",
  "hash_id": "f7868d0339e32f1d8d7bc0c35e4d14e87ff74e70e3ed5713169866b209571d13",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/agp/ali-agp.c",
  "human_readable_source": " \n\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/init.h>\n#include <linux/agp_backend.h>\n#include <asm/page.h>\t\t \n#include \"agp.h\"\n\n#define ALI_AGPCTRL\t0xb8\n#define ALI_ATTBASE\t0xbc\n#define ALI_TLBCTRL\t0xc0\n#define ALI_TAGCTRL\t0xc4\n#define ALI_CACHE_FLUSH_CTRL\t0xD0\n#define ALI_CACHE_FLUSH_ADDR_MASK\t0xFFFFF000\n#define ALI_CACHE_FLUSH_EN\t0x100\n\nstatic int ali_fetch_size(void)\n{\n\tint i;\n\tu32 temp;\n\tstruct aper_size_info_32 *values;\n\n\tpci_read_config_dword(agp_bridge->dev, ALI_ATTBASE, &temp);\n\ttemp &= ~(0xfffffff0);\n\tvalues = A_SIZE_32(agp_bridge->driver->aperture_sizes);\n\n\tfor (i = 0; i < agp_bridge->driver->num_aperture_sizes; i++) {\n\t\tif (temp == values[i].size_value) {\n\t\t\tagp_bridge->previous_size =\n\t\t\t    agp_bridge->current_size = (void *) (values + i);\n\t\t\tagp_bridge->aperture_size_idx = i;\n\t\t\treturn values[i].size;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void ali_tlbflush(struct agp_memory *mem)\n{\n\tu32 temp;\n\n\tpci_read_config_dword(agp_bridge->dev, ALI_TLBCTRL, &temp);\n\ttemp &= 0xfffffff0;\n\ttemp |= (1<<0 | 1<<1);\n\tpci_write_config_dword(agp_bridge->dev, ALI_TAGCTRL, temp);\n}\n\nstatic void ali_cleanup(void)\n{\n\tstruct aper_size_info_32 *previous_size;\n\tu32 temp;\n\n\tprevious_size = A_SIZE_32(agp_bridge->previous_size);\n\n\tpci_read_config_dword(agp_bridge->dev, ALI_TLBCTRL, &temp);\n\n\tpci_write_config_dword(agp_bridge->dev, ALI_TAGCTRL,\n\t\t\t((temp & 0xffffff00) | 0x00000001|0x00000002));\n\n\tpci_read_config_dword(agp_bridge->dev,  ALI_ATTBASE, &temp);\n\tpci_write_config_dword(agp_bridge->dev, ALI_ATTBASE,\n\t\t\t((temp & 0x00000ff0) | previous_size->size_value));\n}\n\nstatic int ali_configure(void)\n{\n\tu32 temp;\n\tstruct aper_size_info_32 *current_size;\n\n\tcurrent_size = A_SIZE_32(agp_bridge->current_size);\n\n\t \n\tpci_read_config_dword(agp_bridge->dev, ALI_ATTBASE, &temp);\n\ttemp = (((temp & 0x00000ff0) | (agp_bridge->gatt_bus_addr & 0xfffff000))\n\t\t\t| (current_size->size_value & 0xf));\n\tpci_write_config_dword(agp_bridge->dev, ALI_ATTBASE, temp);\n\n\t \n\tpci_read_config_dword(agp_bridge->dev, ALI_TLBCTRL, &temp);\n\tpci_write_config_dword(agp_bridge->dev, ALI_TLBCTRL, ((temp & 0xffffff00) | 0x00000010));\n\n\t \n\tagp_bridge->gart_bus_addr = pci_bus_address(agp_bridge->dev,\n\t\t\t\t\t\t    AGP_APERTURE_BAR);\n\n#if 0\n\tif (agp_bridge->type == ALI_M1541) {\n\t\tu32 nlvm_addr = 0;\n\n\t\tswitch (current_size->size_value) {\n\t\t\tcase 0:  break;\n\t\t\tcase 1:  nlvm_addr = 0x100000;break;\n\t\t\tcase 2:  nlvm_addr = 0x200000;break;\n\t\t\tcase 3:  nlvm_addr = 0x400000;break;\n\t\t\tcase 4:  nlvm_addr = 0x800000;break;\n\t\t\tcase 6:  nlvm_addr = 0x1000000;break;\n\t\t\tcase 7:  nlvm_addr = 0x2000000;break;\n\t\t\tcase 8:  nlvm_addr = 0x4000000;break;\n\t\t\tcase 9:  nlvm_addr = 0x8000000;break;\n\t\t\tcase 10: nlvm_addr = 0x10000000;break;\n\t\t\tdefault: break;\n\t\t}\n\t\tnlvm_addr--;\n\t\tnlvm_addr&=0xfff00000;\n\n\t\tnlvm_addr+= agp_bridge->gart_bus_addr;\n\t\tnlvm_addr|=(agp_bridge->gart_bus_addr>>12);\n\t\tdev_info(&agp_bridge->dev->dev, \"nlvm top &base = %8x\\n\",\n\t\t\t nlvm_addr);\n\t}\n#endif\n\n\tpci_read_config_dword(agp_bridge->dev, ALI_TLBCTRL, &temp);\n\ttemp &= 0xffffff7f;\t\t\n\tpci_write_config_dword(agp_bridge->dev, ALI_TLBCTRL, temp);\n\n\treturn 0;\n}\n\n\nstatic void m1541_cache_flush(void)\n{\n\tint i, page_count;\n\tu32 temp;\n\n\tglobal_cache_flush();\n\n\tpage_count = 1 << A_SIZE_32(agp_bridge->current_size)->page_order;\n\tfor (i = 0; i < PAGE_SIZE * page_count; i += PAGE_SIZE) {\n\t\tpci_read_config_dword(agp_bridge->dev, ALI_CACHE_FLUSH_CTRL,\n\t\t\t\t&temp);\n\t\tpci_write_config_dword(agp_bridge->dev, ALI_CACHE_FLUSH_CTRL,\n\t\t\t\t(((temp & ALI_CACHE_FLUSH_ADDR_MASK) |\n\t\t\t\t  (agp_bridge->gatt_bus_addr + i)) |\n\t\t\t\t ALI_CACHE_FLUSH_EN));\n\t}\n}\n\nstatic struct page *m1541_alloc_page(struct agp_bridge_data *bridge)\n{\n\tstruct page *page = agp_generic_alloc_page(agp_bridge);\n\tu32 temp;\n\n\tif (!page)\n\t\treturn NULL;\n\n\tpci_read_config_dword(agp_bridge->dev, ALI_CACHE_FLUSH_CTRL, &temp);\n\tpci_write_config_dword(agp_bridge->dev, ALI_CACHE_FLUSH_CTRL,\n\t\t\t(((temp & ALI_CACHE_FLUSH_ADDR_MASK) |\n\t\t\t  page_to_phys(page)) | ALI_CACHE_FLUSH_EN ));\n\treturn page;\n}\n\nstatic void ali_destroy_page(struct page *page, int flags)\n{\n\tif (page) {\n\t\tif (flags & AGP_PAGE_DESTROY_UNMAP) {\n\t\t\tglobal_cache_flush();\t \n\t\t\tagp_generic_destroy_page(page, flags);\n\t\t} else\n\t\t\tagp_generic_destroy_page(page, flags);\n\t}\n}\n\nstatic void m1541_destroy_page(struct page *page, int flags)\n{\n\tu32 temp;\n\n\tif (page == NULL)\n\t\treturn;\n\n\tif (flags & AGP_PAGE_DESTROY_UNMAP) {\n\t\tglobal_cache_flush();\n\n\t\tpci_read_config_dword(agp_bridge->dev, ALI_CACHE_FLUSH_CTRL, &temp);\n\t\tpci_write_config_dword(agp_bridge->dev, ALI_CACHE_FLUSH_CTRL,\n\t\t\t\t       (((temp & ALI_CACHE_FLUSH_ADDR_MASK) |\n\t\t\t\t\t page_to_phys(page)) | ALI_CACHE_FLUSH_EN));\n\t}\n\tagp_generic_destroy_page(page, flags);\n}\n\n\n \n\nstatic const struct aper_size_info_32 ali_generic_sizes[7] =\n{\n\t{256, 65536, 6, 10},\n\t{128, 32768, 5, 9},\n\t{64, 16384, 4, 8},\n\t{32, 8192, 3, 7},\n\t{16, 4096, 2, 6},\n\t{8, 2048, 1, 4},\n\t{4, 1024, 0, 3}\n};\n\nstatic const struct agp_bridge_driver ali_generic_bridge = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.aperture_sizes\t\t= ali_generic_sizes,\n\t.size_type\t\t= U32_APER_SIZE,\n\t.num_aperture_sizes\t= 7,\n\t.needs_scratch_page\t= true,\n\t.configure\t\t= ali_configure,\n\t.fetch_size\t\t= ali_fetch_size,\n\t.cleanup\t\t= ali_cleanup,\n\t.tlb_flush\t\t= ali_tlbflush,\n\t.mask_memory\t\t= agp_generic_mask_memory,\n\t.masks\t\t\t= NULL,\n\t.agp_enable\t\t= agp_generic_enable,\n\t.cache_flush\t\t= global_cache_flush,\n\t.create_gatt_table\t= agp_generic_create_gatt_table,\n\t.free_gatt_table\t= agp_generic_free_gatt_table,\n\t.insert_memory\t\t= agp_generic_insert_memory,\n\t.remove_memory\t\t= agp_generic_remove_memory,\n\t.alloc_by_type\t\t= agp_generic_alloc_by_type,\n\t.free_by_type\t\t= agp_generic_free_by_type,\n\t.agp_alloc_page\t\t= agp_generic_alloc_page,\n\t.agp_destroy_page\t= ali_destroy_page,\n\t.agp_type_to_mask_type  = agp_generic_type_to_mask_type,\n};\n\nstatic const struct agp_bridge_driver ali_m1541_bridge = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.aperture_sizes\t\t= ali_generic_sizes,\n\t.size_type\t\t= U32_APER_SIZE,\n\t.num_aperture_sizes\t= 7,\n\t.configure\t\t= ali_configure,\n\t.fetch_size\t\t= ali_fetch_size,\n\t.cleanup\t\t= ali_cleanup,\n\t.tlb_flush\t\t= ali_tlbflush,\n\t.mask_memory\t\t= agp_generic_mask_memory,\n\t.masks\t\t\t= NULL,\n\t.agp_enable\t\t= agp_generic_enable,\n\t.cache_flush\t\t= m1541_cache_flush,\n\t.create_gatt_table\t= agp_generic_create_gatt_table,\n\t.free_gatt_table\t= agp_generic_free_gatt_table,\n\t.insert_memory\t\t= agp_generic_insert_memory,\n\t.remove_memory\t\t= agp_generic_remove_memory,\n\t.alloc_by_type\t\t= agp_generic_alloc_by_type,\n\t.free_by_type\t\t= agp_generic_free_by_type,\n\t.agp_alloc_page\t\t= m1541_alloc_page,\n\t.agp_destroy_page\t= m1541_destroy_page,\n\t.agp_type_to_mask_type  = agp_generic_type_to_mask_type,\n};\n\n\nstatic struct agp_device_ids ali_agp_device_ids[] =\n{\n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_AL_M1541,\n\t\t.chipset_name\t= \"M1541\",\n\t},\n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_AL_M1621,\n\t\t.chipset_name\t= \"M1621\",\n\t},\n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_AL_M1631,\n\t\t.chipset_name\t= \"M1631\",\n\t},\n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_AL_M1632,\n\t\t.chipset_name\t= \"M1632\",\n\t},\n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_AL_M1641,\n\t\t.chipset_name\t= \"M1641\",\n\t},\n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_AL_M1644,\n\t\t.chipset_name\t= \"M1644\",\n\t},\n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_AL_M1647,\n\t\t.chipset_name\t= \"M1647\",\n\t},\n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_AL_M1651,\n\t\t.chipset_name\t= \"M1651\",\n\t},\n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_AL_M1671,\n\t\t.chipset_name\t= \"M1671\",\n\t},\n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_AL_M1681,\n\t\t.chipset_name\t= \"M1681\",\n\t},\n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_AL_M1683,\n\t\t.chipset_name\t= \"M1683\",\n\t},\n\n\t{ },  \n};\n\nstatic int agp_ali_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct agp_device_ids *devs = ali_agp_device_ids;\n\tstruct agp_bridge_data *bridge;\n\tu8 hidden_1621_id, cap_ptr;\n\tint j;\n\n\tcap_ptr = pci_find_capability(pdev, PCI_CAP_ID_AGP);\n\tif (!cap_ptr)\n\t\treturn -ENODEV;\n\n\t \n\tfor (j = 0; devs[j].chipset_name; j++) {\n\t\tif (pdev->device == devs[j].device_id)\n\t\t\tgoto found;\n\t}\n\n\tdev_err(&pdev->dev, \"unsupported ALi chipset [%04x/%04x])\\n\",\n\t\tpdev->vendor, pdev->device);\n\treturn -ENODEV;\n\n\nfound:\n\tbridge = agp_alloc_bridge();\n\tif (!bridge)\n\t\treturn -ENOMEM;\n\n\tbridge->dev = pdev;\n\tbridge->capndx = cap_ptr;\n\n\tswitch (pdev->device) {\n\tcase PCI_DEVICE_ID_AL_M1541:\n\t\tbridge->driver = &ali_m1541_bridge;\n\t\tbreak;\n\tcase PCI_DEVICE_ID_AL_M1621:\n\t\tpci_read_config_byte(pdev, 0xFB, &hidden_1621_id);\n\t\tswitch (hidden_1621_id) {\n\t\tcase 0x31:\n\t\t\tdevs[j].chipset_name = \"M1631\";\n\t\t\tbreak;\n\t\tcase 0x32:\n\t\t\tdevs[j].chipset_name = \"M1632\";\n\t\t\tbreak;\n\t\tcase 0x41:\n\t\t\tdevs[j].chipset_name = \"M1641\";\n\t\t\tbreak;\n\t\tcase 0x43:\n\t\t\tdevs[j].chipset_name = \"M1621\";\n\t\t\tbreak;\n\t\tcase 0x47:\n\t\t\tdevs[j].chipset_name = \"M1647\";\n\t\t\tbreak;\n\t\tcase 0x51:\n\t\t\tdevs[j].chipset_name = \"M1651\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tbridge->driver = &ali_generic_bridge;\n\t}\n\n\tdev_info(&pdev->dev, \"ALi %s chipset\\n\", devs[j].chipset_name);\n\n\t \n\tpci_read_config_dword(pdev,\n\t\t\tbridge->capndx+PCI_AGP_STATUS,\n\t\t\t&bridge->mode);\n\n\tpci_set_drvdata(pdev, bridge);\n\treturn agp_add_bridge(bridge);\n}\n\nstatic void agp_ali_remove(struct pci_dev *pdev)\n{\n\tstruct agp_bridge_data *bridge = pci_get_drvdata(pdev);\n\n\tagp_remove_bridge(bridge);\n\tagp_put_bridge(bridge);\n}\n\nstatic const struct pci_device_id agp_ali_pci_table[] = {\n\t{\n\t.class\t\t= (PCI_CLASS_BRIDGE_HOST << 8),\n\t.class_mask\t= ~0,\n\t.vendor\t\t= PCI_VENDOR_ID_AL,\n\t.device\t\t= PCI_ANY_ID,\n\t.subvendor\t= PCI_ANY_ID,\n\t.subdevice\t= PCI_ANY_ID,\n\t},\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(pci, agp_ali_pci_table);\n\nstatic struct pci_driver agp_ali_pci_driver = {\n\t.name\t\t= \"agpgart-ali\",\n\t.id_table\t= agp_ali_pci_table,\n\t.probe\t\t= agp_ali_probe,\n\t.remove\t\t= agp_ali_remove,\n};\n\nstatic int __init agp_ali_init(void)\n{\n\tif (agp_off)\n\t\treturn -EINVAL;\n\treturn pci_register_driver(&agp_ali_pci_driver);\n}\n\nstatic void __exit agp_ali_cleanup(void)\n{\n\tpci_unregister_driver(&agp_ali_pci_driver);\n}\n\nmodule_init(agp_ali_init);\nmodule_exit(agp_ali_cleanup);\n\nMODULE_AUTHOR(\"Dave Jones\");\nMODULE_LICENSE(\"GPL and additional rights\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}