{
  "module_name": "uninorth-agp.c",
  "hash_id": "01445dc9225fbe76eea4734682e3f4a9628303cb6dbd09d9bd040ece4252cc19",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/agp/uninorth-agp.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/agp_backend.h>\n#include <linux/delay.h>\n#include <linux/vmalloc.h>\n#include <asm/uninorth.h>\n#include <asm/prom.h>\n#include <asm/pmac_feature.h>\n#include \"agp.h\"\n\n \nstatic int uninorth_rev;\nstatic int is_u3;\nstatic u32 scratch_value;\n\n#define DEFAULT_APERTURE_SIZE 256\n#define DEFAULT_APERTURE_STRING \"256\"\nstatic char *aperture = NULL;\n\nstatic int uninorth_fetch_size(void)\n{\n\tint i, size = 0;\n\tstruct aper_size_info_32 *values =\n\t    A_SIZE_32(agp_bridge->driver->aperture_sizes);\n\n\tif (aperture) {\n\t\tchar *save = aperture;\n\n\t\tsize = memparse(aperture, &aperture) >> 20;\n\t\taperture = save;\n\n\t\tfor (i = 0; i < agp_bridge->driver->num_aperture_sizes; i++)\n\t\t\tif (size == values[i].size)\n\t\t\t\tbreak;\n\n\t\tif (i == agp_bridge->driver->num_aperture_sizes) {\n\t\t\tdev_err(&agp_bridge->dev->dev, \"invalid aperture size, \"\n\t\t\t\t\"using default\\n\");\n\t\t\tsize = 0;\n\t\t\taperture = NULL;\n\t\t}\n\t}\n\n\tif (!size) {\n\t\tfor (i = 0; i < agp_bridge->driver->num_aperture_sizes; i++)\n\t\t\tif (values[i].size == DEFAULT_APERTURE_SIZE)\n\t\t\t\tbreak;\n\t}\n\n\tagp_bridge->previous_size =\n\t    agp_bridge->current_size = (void *)(values + i);\n\tagp_bridge->aperture_size_idx = i;\n\treturn values[i].size;\n}\n\nstatic void uninorth_tlbflush(struct agp_memory *mem)\n{\n\tu32 ctrl = UNI_N_CFG_GART_ENABLE;\n\n\tif (is_u3)\n\t\tctrl |= U3_N_CFG_GART_PERFRD;\n\tpci_write_config_dword(agp_bridge->dev, UNI_N_CFG_GART_CTRL,\n\t\t\t       ctrl | UNI_N_CFG_GART_INVAL);\n\tpci_write_config_dword(agp_bridge->dev, UNI_N_CFG_GART_CTRL, ctrl);\n\n\tif (!mem && uninorth_rev <= 0x30) {\n\t\tpci_write_config_dword(agp_bridge->dev, UNI_N_CFG_GART_CTRL,\n\t\t\t\t       ctrl | UNI_N_CFG_GART_2xRESET);\n\t\tpci_write_config_dword(agp_bridge->dev, UNI_N_CFG_GART_CTRL,\n\t\t\t\t       ctrl);\n\t}\n}\n\nstatic void uninorth_cleanup(void)\n{\n\tu32 tmp;\n\n\tpci_read_config_dword(agp_bridge->dev, UNI_N_CFG_GART_CTRL, &tmp);\n\tif (!(tmp & UNI_N_CFG_GART_ENABLE))\n\t\treturn;\n\ttmp |= UNI_N_CFG_GART_INVAL;\n\tpci_write_config_dword(agp_bridge->dev, UNI_N_CFG_GART_CTRL, tmp);\n\tpci_write_config_dword(agp_bridge->dev, UNI_N_CFG_GART_CTRL, 0);\n\n\tif (uninorth_rev <= 0x30) {\n\t\tpci_write_config_dword(agp_bridge->dev, UNI_N_CFG_GART_CTRL,\n\t\t\t\t       UNI_N_CFG_GART_2xRESET);\n\t\tpci_write_config_dword(agp_bridge->dev, UNI_N_CFG_GART_CTRL,\n\t\t\t\t       0);\n\t}\n}\n\nstatic int uninorth_configure(void)\n{\n\tstruct aper_size_info_32 *current_size;\n\n\tcurrent_size = A_SIZE_32(agp_bridge->current_size);\n\n\tdev_info(&agp_bridge->dev->dev, \"configuring for size idx: %d\\n\",\n\t\t current_size->size_value);\n\n\t \n\tpci_write_config_dword(agp_bridge->dev,\n\t\tUNI_N_CFG_GART_BASE,\n\t\t(agp_bridge->gatt_bus_addr & 0xfffff000)\n\t\t\t| current_size->size_value);\n\n\t \n\tagp_bridge->gart_bus_addr = 0;\n#ifdef CONFIG_PPC64\n\t \n\t \n\tpci_write_config_dword(agp_bridge->dev, UNI_N_CFG_AGP_BASE,\n\t\t\t       (agp_bridge->gatt_bus_addr >> 32) & 0xf);\n#else\n\tpci_write_config_dword(agp_bridge->dev,\n\t\tUNI_N_CFG_AGP_BASE, agp_bridge->gart_bus_addr);\n#endif\n\n\tif (is_u3) {\n\t\tpci_write_config_dword(agp_bridge->dev,\n\t\t\t\t       UNI_N_CFG_GART_DUMMY_PAGE,\n\t\t\t\t       page_to_phys(agp_bridge->scratch_page_page) >> 12);\n\t}\n\n\treturn 0;\n}\n\nstatic int uninorth_insert_memory(struct agp_memory *mem, off_t pg_start, int type)\n{\n\tint i, num_entries;\n\tvoid *temp;\n\tu32 *gp;\n\tint mask_type;\n\n\tif (type != mem->type)\n\t\treturn -EINVAL;\n\n\tmask_type = agp_bridge->driver->agp_type_to_mask_type(agp_bridge, type);\n\tif (mask_type != 0) {\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\tif (mem->page_count == 0)\n\t\treturn 0;\n\n\ttemp = agp_bridge->current_size;\n\tnum_entries = A_SIZE_32(temp)->num_entries;\n\n\tif ((pg_start + mem->page_count) > num_entries)\n\t\treturn -EINVAL;\n\n\tgp = (u32 *) &agp_bridge->gatt_table[pg_start];\n\tfor (i = 0; i < mem->page_count; ++i) {\n\t\tif (gp[i] != scratch_value) {\n\t\t\tdev_info(&agp_bridge->dev->dev,\n\t\t\t\t \"uninorth_insert_memory: entry 0x%x occupied (%x)\\n\",\n\t\t\t\t i, gp[i]);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\tfor (i = 0; i < mem->page_count; i++) {\n\t\tif (is_u3)\n\t\t\tgp[i] = (page_to_phys(mem->pages[i]) >> PAGE_SHIFT) | 0x80000000UL;\n\t\telse\n\t\t\tgp[i] =\tcpu_to_le32((page_to_phys(mem->pages[i]) & 0xFFFFF000UL) |\n\t\t\t\t\t    0x1UL);\n\t\tflush_dcache_range((unsigned long)__va(page_to_phys(mem->pages[i])),\n\t\t\t\t   (unsigned long)__va(page_to_phys(mem->pages[i]))+0x1000);\n\t}\n\tmb();\n\tuninorth_tlbflush(mem);\n\n\treturn 0;\n}\n\nstatic int uninorth_remove_memory(struct agp_memory *mem, off_t pg_start, int type)\n{\n\tsize_t i;\n\tu32 *gp;\n\tint mask_type;\n\n\tif (type != mem->type)\n\t\treturn -EINVAL;\n\n\tmask_type = agp_bridge->driver->agp_type_to_mask_type(agp_bridge, type);\n\tif (mask_type != 0) {\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\tif (mem->page_count == 0)\n\t\treturn 0;\n\n\tgp = (u32 *) &agp_bridge->gatt_table[pg_start];\n\tfor (i = 0; i < mem->page_count; ++i) {\n\t\tgp[i] = scratch_value;\n\t}\n\tmb();\n\tuninorth_tlbflush(mem);\n\n\treturn 0;\n}\n\nstatic void uninorth_agp_enable(struct agp_bridge_data *bridge, u32 mode)\n{\n\tu32 command, scratch, status;\n\tint timeout;\n\n\tpci_read_config_dword(bridge->dev,\n\t\t\t      bridge->capndx + PCI_AGP_STATUS,\n\t\t\t      &status);\n\n\tcommand = agp_collect_device_status(bridge, mode, status);\n\tcommand |= PCI_AGP_COMMAND_AGP;\n\n\tif (uninorth_rev == 0x21) {\n\t\t \n\t\tcommand &= ~AGPSTAT2_4X;\n\t}\n\n\tif ((uninorth_rev >= 0x30) && (uninorth_rev <= 0x33)) {\n\t\t \n\t\tif ((command >> AGPSTAT_RQ_DEPTH_SHIFT) > 7)\n\t\t\tcommand = (command & ~AGPSTAT_RQ_DEPTH)\n\t\t\t\t| (7 << AGPSTAT_RQ_DEPTH_SHIFT);\n\t}\n\n\tuninorth_tlbflush(NULL);\n\n\ttimeout = 0;\n\tdo {\n\t\tpci_write_config_dword(bridge->dev,\n\t\t\t\t       bridge->capndx + PCI_AGP_COMMAND,\n\t\t\t\t       command);\n\t\tpci_read_config_dword(bridge->dev,\n\t\t\t\t      bridge->capndx + PCI_AGP_COMMAND,\n\t\t\t\t       &scratch);\n\t} while ((scratch & PCI_AGP_COMMAND_AGP) == 0 && ++timeout < 1000);\n\tif ((scratch & PCI_AGP_COMMAND_AGP) == 0)\n\t\tdev_err(&bridge->dev->dev, \"can't write UniNorth AGP \"\n\t\t\t\"command register\\n\");\n\n\tif (uninorth_rev >= 0x30) {\n\t\t \n\t\tagp_device_command(command, (status & AGPSTAT_MODE_3_0) != 0);\n\t} else {\n\t\t \n\t\tagp_device_command(command, false);\n\t}\n\n\tuninorth_tlbflush(NULL);\n}\n\n#ifdef CONFIG_PM\n \nstatic int agp_uninorth_suspend(struct pci_dev *pdev)\n{\n\tstruct agp_bridge_data *bridge;\n\tu32 cmd;\n\tu8 agp;\n\tstruct pci_dev *device = NULL;\n\n\tbridge = agp_find_bridge(pdev);\n\tif (bridge == NULL)\n\t\treturn -ENODEV;\n\n\t \n\tif (bridge->dev_private_data)\n\t\treturn 0;\n\n\t \n\tfor_each_pci_dev(device) {\n\t\t \n\t\tif (device == pdev)\n\t\t\tcontinue;\n\t\t \n\t\tif (device->bus != pdev->bus)\n\t\t\tcontinue;\n\t\tagp = pci_find_capability(device, PCI_CAP_ID_AGP);\n\t\tif (!agp)\n\t\t\tcontinue;\n\t\tpci_read_config_dword(device, agp + PCI_AGP_COMMAND, &cmd);\n\t\tif (!(cmd & PCI_AGP_COMMAND_AGP))\n\t\t\tcontinue;\n\t\tdev_info(&pdev->dev, \"disabling AGP on device %s\\n\",\n\t\t\t pci_name(device));\n\t\tcmd &= ~PCI_AGP_COMMAND_AGP;\n\t\tpci_write_config_dword(device, agp + PCI_AGP_COMMAND, cmd);\n\t}\n\n\t \n\tagp = pci_find_capability(pdev, PCI_CAP_ID_AGP);\n\tpci_read_config_dword(pdev, agp + PCI_AGP_COMMAND, &cmd);\n\tbridge->dev_private_data = (void *)(long)cmd;\n\tif (cmd & PCI_AGP_COMMAND_AGP) {\n\t\tdev_info(&pdev->dev, \"disabling AGP on bridge\\n\");\n\t\tcmd &= ~PCI_AGP_COMMAND_AGP;\n\t\tpci_write_config_dword(pdev, agp + PCI_AGP_COMMAND, cmd);\n\t}\n\t \n\tuninorth_cleanup();\n\n\treturn 0;\n}\n\nstatic int agp_uninorth_resume(struct pci_dev *pdev)\n{\n\tstruct agp_bridge_data *bridge;\n\tu32 command;\n\n\tbridge = agp_find_bridge(pdev);\n\tif (bridge == NULL)\n\t\treturn -ENODEV;\n\n\tcommand = (long)bridge->dev_private_data;\n\tbridge->dev_private_data = NULL;\n\tif (!(command & PCI_AGP_COMMAND_AGP))\n\t\treturn 0;\n\n\tuninorth_agp_enable(bridge, command);\n\n\treturn 0;\n}\n#endif  \n\nstatic struct {\n\tstruct page **pages_arr;\n} uninorth_priv;\n\nstatic int uninorth_create_gatt_table(struct agp_bridge_data *bridge)\n{\n\tchar *table;\n\tchar *table_end;\n\tint size;\n\tint page_order;\n\tint num_entries;\n\tint i;\n\tvoid *temp;\n\tstruct page *page;\n\n\t \n\tif (bridge->driver->size_type == LVL2_APER_SIZE)\n\t\treturn -EINVAL;\n\n\ttable = NULL;\n\ti = bridge->aperture_size_idx;\n\ttemp = bridge->current_size;\n\tsize = page_order = num_entries = 0;\n\n\tdo {\n\t\tsize = A_SIZE_32(temp)->size;\n\t\tpage_order = A_SIZE_32(temp)->page_order;\n\t\tnum_entries = A_SIZE_32(temp)->num_entries;\n\n\t\ttable = (char *) __get_free_pages(GFP_KERNEL, page_order);\n\n\t\tif (table == NULL) {\n\t\t\ti++;\n\t\t\tbridge->current_size = A_IDX32(bridge);\n\t\t} else {\n\t\t\tbridge->aperture_size_idx = i;\n\t\t}\n\t} while (!table && (i < bridge->driver->num_aperture_sizes));\n\n\tif (table == NULL)\n\t\treturn -ENOMEM;\n\n\tuninorth_priv.pages_arr = kmalloc_array(1 << page_order,\n\t\t\t\t\t\tsizeof(struct page *),\n\t\t\t\t\t\tGFP_KERNEL);\n\tif (uninorth_priv.pages_arr == NULL)\n\t\tgoto enomem;\n\n\ttable_end = table + ((PAGE_SIZE * (1 << page_order)) - 1);\n\n\tfor (page = virt_to_page(table), i = 0; page <= virt_to_page(table_end);\n\t     page++, i++) {\n\t\tSetPageReserved(page);\n\t\tuninorth_priv.pages_arr[i] = page;\n\t}\n\n\tbridge->gatt_table_real = (u32 *) table;\n\t \n\tflush_dcache_range((unsigned long)table,\n\t\t\t   (unsigned long)table_end + 1);\n\tbridge->gatt_table = vmap(uninorth_priv.pages_arr, (1 << page_order), 0, PAGE_KERNEL_NCG);\n\n\tif (bridge->gatt_table == NULL)\n\t\tgoto enomem;\n\n\tbridge->gatt_bus_addr = virt_to_phys(table);\n\n\tif (is_u3)\n\t\tscratch_value = (page_to_phys(agp_bridge->scratch_page_page) >> PAGE_SHIFT) | 0x80000000UL;\n\telse\n\t\tscratch_value =\tcpu_to_le32((page_to_phys(agp_bridge->scratch_page_page) & 0xFFFFF000UL) |\n\t\t\t\t0x1UL);\n\tfor (i = 0; i < num_entries; i++)\n\t\tbridge->gatt_table[i] = scratch_value;\n\n\treturn 0;\n\nenomem:\n\tkfree(uninorth_priv.pages_arr);\n\tif (table)\n\t\tfree_pages((unsigned long)table, page_order);\n\treturn -ENOMEM;\n}\n\nstatic int uninorth_free_gatt_table(struct agp_bridge_data *bridge)\n{\n\tint page_order;\n\tchar *table, *table_end;\n\tvoid *temp;\n\tstruct page *page;\n\n\ttemp = bridge->current_size;\n\tpage_order = A_SIZE_32(temp)->page_order;\n\n\t \n\n\tvunmap(bridge->gatt_table);\n\tkfree(uninorth_priv.pages_arr);\n\ttable = (char *) bridge->gatt_table_real;\n\ttable_end = table + ((PAGE_SIZE * (1 << page_order)) - 1);\n\n\tfor (page = virt_to_page(table); page <= virt_to_page(table_end); page++)\n\t\tClearPageReserved(page);\n\n\tfree_pages((unsigned long) bridge->gatt_table_real, page_order);\n\n\treturn 0;\n}\n\nstatic void null_cache_flush(void)\n{\n\tmb();\n}\n\n \n\nstatic const struct aper_size_info_32 uninorth_sizes[] =\n{\n\t{256, 65536, 6, 64},\n\t{128, 32768, 5, 32},\n\t{64, 16384, 4, 16},\n\t{32, 8192, 3, 8},\n\t{16, 4096, 2, 4},\n\t{8, 2048, 1, 2},\n\t{4, 1024, 0, 1}\n};\n\n \nstatic const struct aper_size_info_32 u3_sizes[] =\n{\n\t{512, 131072, 7, 128},\n\t{256, 65536, 6, 64},\n\t{128, 32768, 5, 32},\n\t{64, 16384, 4, 16},\n\t{32, 8192, 3, 8},\n\t{16, 4096, 2, 4},\n\t{8, 2048, 1, 2},\n\t{4, 1024, 0, 1}\n};\n\nconst struct agp_bridge_driver uninorth_agp_driver = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.aperture_sizes\t\t= (void *)uninorth_sizes,\n\t.size_type\t\t= U32_APER_SIZE,\n\t.num_aperture_sizes\t= ARRAY_SIZE(uninorth_sizes),\n\t.configure\t\t= uninorth_configure,\n\t.fetch_size\t\t= uninorth_fetch_size,\n\t.cleanup\t\t= uninorth_cleanup,\n\t.tlb_flush\t\t= uninorth_tlbflush,\n\t.mask_memory\t\t= agp_generic_mask_memory,\n\t.masks\t\t\t= NULL,\n\t.cache_flush\t\t= null_cache_flush,\n\t.agp_enable\t\t= uninorth_agp_enable,\n\t.create_gatt_table\t= uninorth_create_gatt_table,\n\t.free_gatt_table\t= uninorth_free_gatt_table,\n\t.insert_memory\t\t= uninorth_insert_memory,\n\t.remove_memory\t\t= uninorth_remove_memory,\n\t.alloc_by_type\t\t= agp_generic_alloc_by_type,\n\t.free_by_type\t\t= agp_generic_free_by_type,\n\t.agp_alloc_page\t\t= agp_generic_alloc_page,\n\t.agp_alloc_pages\t= agp_generic_alloc_pages,\n\t.agp_destroy_page\t= agp_generic_destroy_page,\n\t.agp_destroy_pages\t= agp_generic_destroy_pages,\n\t.agp_type_to_mask_type  = agp_generic_type_to_mask_type,\n\t.cant_use_aperture\t= true,\n\t.needs_scratch_page\t= true,\n};\n\nconst struct agp_bridge_driver u3_agp_driver = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.aperture_sizes\t\t= (void *)u3_sizes,\n\t.size_type\t\t= U32_APER_SIZE,\n\t.num_aperture_sizes\t= ARRAY_SIZE(u3_sizes),\n\t.configure\t\t= uninorth_configure,\n\t.fetch_size\t\t= uninorth_fetch_size,\n\t.cleanup\t\t= uninorth_cleanup,\n\t.tlb_flush\t\t= uninorth_tlbflush,\n\t.mask_memory\t\t= agp_generic_mask_memory,\n\t.masks\t\t\t= NULL,\n\t.cache_flush\t\t= null_cache_flush,\n\t.agp_enable\t\t= uninorth_agp_enable,\n\t.create_gatt_table\t= uninorth_create_gatt_table,\n\t.free_gatt_table\t= uninorth_free_gatt_table,\n\t.insert_memory\t\t= uninorth_insert_memory,\n\t.remove_memory\t\t= uninorth_remove_memory,\n\t.alloc_by_type\t\t= agp_generic_alloc_by_type,\n\t.free_by_type\t\t= agp_generic_free_by_type,\n\t.agp_alloc_page\t\t= agp_generic_alloc_page,\n\t.agp_alloc_pages\t= agp_generic_alloc_pages,\n\t.agp_destroy_page\t= agp_generic_destroy_page,\n\t.agp_destroy_pages\t= agp_generic_destroy_pages,\n\t.agp_type_to_mask_type  = agp_generic_type_to_mask_type,\n\t.cant_use_aperture\t= true,\n\t.needs_scratch_page\t= true,\n};\n\nstatic struct agp_device_ids uninorth_agp_device_ids[] = {\n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_APPLE_UNI_N_AGP,\n\t\t.chipset_name\t= \"UniNorth\",\n\t},\n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_APPLE_UNI_N_AGP_P,\n\t\t.chipset_name\t= \"UniNorth/Pangea\",\n\t},\n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_APPLE_UNI_N_AGP15,\n\t\t.chipset_name\t= \"UniNorth 1.5\",\n\t},\n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_APPLE_UNI_N_AGP2,\n\t\t.chipset_name\t= \"UniNorth 2\",\n\t},\n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_APPLE_U3_AGP,\n\t\t.chipset_name\t= \"U3\",\n\t},\n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_APPLE_U3L_AGP,\n\t\t.chipset_name\t= \"U3L\",\n\t},\n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_APPLE_U3H_AGP,\n\t\t.chipset_name\t= \"U3H\",\n\t},\n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_APPLE_IPID2_AGP,\n\t\t.chipset_name\t= \"UniNorth/Intrepid2\",\n\t},\n};\n\nstatic int agp_uninorth_probe(struct pci_dev *pdev,\n\t\t\t      const struct pci_device_id *ent)\n{\n\tstruct agp_device_ids *devs = uninorth_agp_device_ids;\n\tstruct agp_bridge_data *bridge;\n\tstruct device_node *uninorth_node;\n\tu8 cap_ptr;\n\tint j;\n\n\tcap_ptr = pci_find_capability(pdev, PCI_CAP_ID_AGP);\n\tif (cap_ptr == 0)\n\t\treturn -ENODEV;\n\n\t \n\tfor (j = 0; devs[j].chipset_name != NULL; ++j) {\n\t\tif (pdev->device == devs[j].device_id) {\n\t\t\tdev_info(&pdev->dev, \"Apple %s chipset\\n\",\n\t\t\t\t devs[j].chipset_name);\n\t\t\tgoto found;\n\t\t}\n\t}\n\n\tdev_err(&pdev->dev, \"unsupported Apple chipset [%04x/%04x]\\n\",\n\t\tpdev->vendor, pdev->device);\n\treturn -ENODEV;\n\n found:\n\t \n\tuninorth_rev = 0;\n\tis_u3 = 0;\n\t \n\tuninorth_node = of_find_node_by_name(NULL, \"uni-n\");\n\t \n\tif (uninorth_node == NULL) {\n\t\tis_u3 = 1;\n\t\tuninorth_node = of_find_node_by_name(NULL, \"u3\");\n\t}\n\tif (uninorth_node) {\n\t\tconst int *revprop = of_get_property(uninorth_node,\n\t\t\t\t\"device-rev\", NULL);\n\t\tif (revprop != NULL)\n\t\t\tuninorth_rev = *revprop & 0x3f;\n\t\tof_node_put(uninorth_node);\n\t}\n\n#ifdef CONFIG_PM\n\t \n\tpmac_register_agp_pm(pdev, agp_uninorth_suspend, agp_uninorth_resume);\n#endif\n\n\t \n\tbridge = agp_alloc_bridge();\n\tif (!bridge)\n\t\treturn -ENOMEM;\n\n\tif (is_u3)\n\t\tbridge->driver = &u3_agp_driver;\n\telse\n\t\tbridge->driver = &uninorth_agp_driver;\n\n\tbridge->dev = pdev;\n\tbridge->capndx = cap_ptr;\n\tbridge->flags = AGP_ERRATA_FASTWRITES;\n\n\t \n\tpci_read_config_dword(pdev, cap_ptr+PCI_AGP_STATUS, &bridge->mode);\n\n\tpci_set_drvdata(pdev, bridge);\n\treturn agp_add_bridge(bridge);\n}\n\nstatic void agp_uninorth_remove(struct pci_dev *pdev)\n{\n\tstruct agp_bridge_data *bridge = pci_get_drvdata(pdev);\n\n#ifdef CONFIG_PM\n\t \n\tpmac_register_agp_pm(pdev, NULL, NULL);\n#endif\n\n\tagp_remove_bridge(bridge);\n\tagp_put_bridge(bridge);\n}\n\nstatic const struct pci_device_id agp_uninorth_pci_table[] = {\n\t{\n\t.class\t\t= (PCI_CLASS_BRIDGE_HOST << 8),\n\t.class_mask\t= ~0,\n\t.vendor\t\t= PCI_VENDOR_ID_APPLE,\n\t.device\t\t= PCI_ANY_ID,\n\t.subvendor\t= PCI_ANY_ID,\n\t.subdevice\t= PCI_ANY_ID,\n\t},\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(pci, agp_uninorth_pci_table);\n\nstatic struct pci_driver agp_uninorth_pci_driver = {\n\t.name\t\t= \"agpgart-uninorth\",\n\t.id_table\t= agp_uninorth_pci_table,\n\t.probe\t\t= agp_uninorth_probe,\n\t.remove\t\t= agp_uninorth_remove,\n};\n\nstatic int __init agp_uninorth_init(void)\n{\n\tif (agp_off)\n\t\treturn -EINVAL;\n\treturn pci_register_driver(&agp_uninorth_pci_driver);\n}\n\nstatic void __exit agp_uninorth_cleanup(void)\n{\n\tpci_unregister_driver(&agp_uninorth_pci_driver);\n}\n\nmodule_init(agp_uninorth_init);\nmodule_exit(agp_uninorth_cleanup);\n\nmodule_param(aperture, charp, 0);\nMODULE_PARM_DESC(aperture,\n\t\t \"Aperture size, must be power of two between 4MB and an\\n\"\n\t\t \"\\t\\tupper limit specific to the UniNorth revision.\\n\"\n\t\t \"\\t\\tDefault: \" DEFAULT_APERTURE_STRING \"M\");\n\nMODULE_AUTHOR(\"Ben Herrenschmidt & Paul Mackerras\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}