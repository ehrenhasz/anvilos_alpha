{
  "module_name": "sworks-agp.c",
  "hash_id": "cdce92f5b97edc3bae8b23a4ea59aafd58d770bf4f8065688e1bad2f17dee3db",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/agp/sworks-agp.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/agp_backend.h>\n#include <asm/set_memory.h>\n#include \"agp.h\"\n\n#define SVWRKS_COMMAND\t\t0x04\n#define SVWRKS_APSIZE\t\t0x10\n#define SVWRKS_MMBASE\t\t0x14\n#define SVWRKS_CACHING\t\t0x4b\n#define SVWRKS_AGP_ENABLE\t0x60\n#define SVWRKS_FEATURE\t\t0x68\n\n#define SVWRKS_SIZE_MASK\t0xfe000000\n\n \n#define SVWRKS_GART_CACHE\t0x02\n#define SVWRKS_GATTBASE\t\t0x04\n#define SVWRKS_TLBFLUSH\t\t0x10\n#define SVWRKS_POSTFLUSH\t0x14\n#define SVWRKS_DIRFLUSH\t\t0x0c\n\n\nstruct serverworks_page_map {\n\tunsigned long *real;\n\tunsigned long __iomem *remapped;\n};\n\nstatic struct _serverworks_private {\n\tstruct pci_dev *svrwrks_dev;\t \n\tvolatile u8 __iomem *registers;\n\tstruct serverworks_page_map **gatt_pages;\n\tint num_tables;\n\tstruct serverworks_page_map scratch_dir;\n\n\tint gart_addr_ofs;\n\tint mm_addr_ofs;\n} serverworks_private;\n\nstatic int serverworks_create_page_map(struct serverworks_page_map *page_map)\n{\n\tint i;\n\n\tpage_map->real = (unsigned long *) __get_free_page(GFP_KERNEL);\n\tif (page_map->real == NULL) {\n\t\treturn -ENOMEM;\n\t}\n\n\tset_memory_uc((unsigned long)page_map->real, 1);\n\tpage_map->remapped = page_map->real;\n\n\tfor (i = 0; i < PAGE_SIZE / sizeof(unsigned long); i++)\n\t\twritel(agp_bridge->scratch_page, page_map->remapped+i);\n\t\t \n\n\treturn 0;\n}\n\nstatic void serverworks_free_page_map(struct serverworks_page_map *page_map)\n{\n\tset_memory_wb((unsigned long)page_map->real, 1);\n\tfree_page((unsigned long) page_map->real);\n}\n\nstatic void serverworks_free_gatt_pages(void)\n{\n\tint i;\n\tstruct serverworks_page_map **tables;\n\tstruct serverworks_page_map *entry;\n\n\ttables = serverworks_private.gatt_pages;\n\tfor (i = 0; i < serverworks_private.num_tables; i++) {\n\t\tentry = tables[i];\n\t\tif (entry != NULL) {\n\t\t\tif (entry->real != NULL) {\n\t\t\t\tserverworks_free_page_map(entry);\n\t\t\t}\n\t\t\tkfree(entry);\n\t\t}\n\t}\n\tkfree(tables);\n}\n\nstatic int serverworks_create_gatt_pages(int nr_tables)\n{\n\tstruct serverworks_page_map **tables;\n\tstruct serverworks_page_map *entry;\n\tint retval = 0;\n\tint i;\n\n\ttables = kcalloc(nr_tables + 1, sizeof(struct serverworks_page_map *),\n\t\t\t GFP_KERNEL);\n\tif (tables == NULL)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < nr_tables; i++) {\n\t\tentry = kzalloc(sizeof(struct serverworks_page_map), GFP_KERNEL);\n\t\tif (entry == NULL) {\n\t\t\tretval = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\ttables[i] = entry;\n\t\tretval = serverworks_create_page_map(entry);\n\t\tif (retval != 0) break;\n\t}\n\tserverworks_private.num_tables = nr_tables;\n\tserverworks_private.gatt_pages = tables;\n\n\tif (retval != 0) serverworks_free_gatt_pages();\n\n\treturn retval;\n}\n\n#define SVRWRKS_GET_GATT(addr) (serverworks_private.gatt_pages[\\\n\tGET_PAGE_DIR_IDX(addr)]->remapped)\n\n#ifndef GET_PAGE_DIR_OFF\n#define GET_PAGE_DIR_OFF(addr) (addr >> 22)\n#endif\n\n#ifndef GET_PAGE_DIR_IDX\n#define GET_PAGE_DIR_IDX(addr) (GET_PAGE_DIR_OFF(addr) - \\\n\tGET_PAGE_DIR_OFF(agp_bridge->gart_bus_addr))\n#endif\n\n#ifndef GET_GATT_OFF\n#define GET_GATT_OFF(addr) ((addr & 0x003ff000) >> 12)\n#endif\n\nstatic int serverworks_create_gatt_table(struct agp_bridge_data *bridge)\n{\n\tstruct aper_size_info_lvl2 *value;\n\tstruct serverworks_page_map page_dir;\n\tint retval;\n\tu32 temp;\n\tint i;\n\n\tvalue = A_SIZE_LVL2(agp_bridge->current_size);\n\tretval = serverworks_create_page_map(&page_dir);\n\tif (retval != 0) {\n\t\treturn retval;\n\t}\n\tretval = serverworks_create_page_map(&serverworks_private.scratch_dir);\n\tif (retval != 0) {\n\t\tserverworks_free_page_map(&page_dir);\n\t\treturn retval;\n\t}\n\t \n\tfor (i = 0; i < 1024; i++) {\n\t\twritel(agp_bridge->scratch_page, serverworks_private.scratch_dir.remapped+i);\n\t\twritel(virt_to_phys(serverworks_private.scratch_dir.real) | 1, page_dir.remapped+i);\n\t}\n\n\tretval = serverworks_create_gatt_pages(value->num_entries / 1024);\n\tif (retval != 0) {\n\t\tserverworks_free_page_map(&page_dir);\n\t\tserverworks_free_page_map(&serverworks_private.scratch_dir);\n\t\treturn retval;\n\t}\n\n\tagp_bridge->gatt_table_real = (u32 *)page_dir.real;\n\tagp_bridge->gatt_table = (u32 __iomem *)page_dir.remapped;\n\tagp_bridge->gatt_bus_addr = virt_to_phys(page_dir.real);\n\n\t \n\n\tpci_read_config_dword(agp_bridge->dev,serverworks_private.gart_addr_ofs,&temp);\n\tagp_bridge->gart_bus_addr = (temp & PCI_BASE_ADDRESS_MEM_MASK);\n\n\t \n\tfor (i = 0; i < value->num_entries / 1024; i++)\n\t\twritel(virt_to_phys(serverworks_private.gatt_pages[i]->real)|1, page_dir.remapped+i);\n\n\treturn 0;\n}\n\nstatic int serverworks_free_gatt_table(struct agp_bridge_data *bridge)\n{\n\tstruct serverworks_page_map page_dir;\n\n\tpage_dir.real = (unsigned long *)agp_bridge->gatt_table_real;\n\tpage_dir.remapped = (unsigned long __iomem *)agp_bridge->gatt_table;\n\n\tserverworks_free_gatt_pages();\n\tserverworks_free_page_map(&page_dir);\n\tserverworks_free_page_map(&serverworks_private.scratch_dir);\n\treturn 0;\n}\n\nstatic int serverworks_fetch_size(void)\n{\n\tint i;\n\tu32 temp;\n\tu32 temp2;\n\tstruct aper_size_info_lvl2 *values;\n\n\tvalues = A_SIZE_LVL2(agp_bridge->driver->aperture_sizes);\n\tpci_read_config_dword(agp_bridge->dev,serverworks_private.gart_addr_ofs,&temp);\n\tpci_write_config_dword(agp_bridge->dev,serverworks_private.gart_addr_ofs,\n\t\t\t\t\tSVWRKS_SIZE_MASK);\n\tpci_read_config_dword(agp_bridge->dev,serverworks_private.gart_addr_ofs,&temp2);\n\tpci_write_config_dword(agp_bridge->dev,serverworks_private.gart_addr_ofs,temp);\n\ttemp2 &= SVWRKS_SIZE_MASK;\n\n\tfor (i = 0; i < agp_bridge->driver->num_aperture_sizes; i++) {\n\t\tif (temp2 == values[i].size_value) {\n\t\t\tagp_bridge->previous_size =\n\t\t\t    agp_bridge->current_size = (void *) (values + i);\n\n\t\t\tagp_bridge->aperture_size_idx = i;\n\t\t\treturn values[i].size;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic void serverworks_tlbflush(struct agp_memory *temp)\n{\n\tunsigned long timeout;\n\n\twriteb(1, serverworks_private.registers+SVWRKS_POSTFLUSH);\n\ttimeout = jiffies + 3*HZ;\n\twhile (readb(serverworks_private.registers+SVWRKS_POSTFLUSH) == 1) {\n\t\tcpu_relax();\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\tdev_err(&serverworks_private.svrwrks_dev->dev,\n\t\t\t\t\"TLB post flush took more than 3 seconds\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\twritel(1, serverworks_private.registers+SVWRKS_DIRFLUSH);\n\ttimeout = jiffies + 3*HZ;\n\twhile (readl(serverworks_private.registers+SVWRKS_DIRFLUSH) == 1) {\n\t\tcpu_relax();\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\tdev_err(&serverworks_private.svrwrks_dev->dev,\n\t\t\t\t\"TLB Dir flush took more than 3 seconds\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int serverworks_configure(void)\n{\n\tu32 temp;\n\tu8 enable_reg;\n\tu16 cap_reg;\n\n\t \n\tpci_read_config_dword(agp_bridge->dev, serverworks_private.mm_addr_ofs, &temp);\n\ttemp = (temp & PCI_BASE_ADDRESS_MEM_MASK);\n\tserverworks_private.registers = (volatile u8 __iomem *) ioremap(temp, 4096);\n\tif (!serverworks_private.registers) {\n\t\tdev_err(&agp_bridge->dev->dev, \"can't ioremap(%#x)\\n\", temp);\n\t\treturn -ENOMEM;\n\t}\n\n\twriteb(0xA, serverworks_private.registers+SVWRKS_GART_CACHE);\n\treadb(serverworks_private.registers+SVWRKS_GART_CACHE);\t \n\n\twritel(agp_bridge->gatt_bus_addr, serverworks_private.registers+SVWRKS_GATTBASE);\n\treadl(serverworks_private.registers+SVWRKS_GATTBASE);\t \n\n\tcap_reg = readw(serverworks_private.registers+SVWRKS_COMMAND);\n\tcap_reg &= ~0x0007;\n\tcap_reg |= 0x4;\n\twritew(cap_reg, serverworks_private.registers+SVWRKS_COMMAND);\n\treadw(serverworks_private.registers+SVWRKS_COMMAND);\n\n\tpci_read_config_byte(serverworks_private.svrwrks_dev,SVWRKS_AGP_ENABLE, &enable_reg);\n\tenable_reg |= 0x1;  \n\tpci_write_config_byte(serverworks_private.svrwrks_dev,SVWRKS_AGP_ENABLE, enable_reg);\n\tserverworks_tlbflush(NULL);\n\n\tagp_bridge->capndx = pci_find_capability(serverworks_private.svrwrks_dev, PCI_CAP_ID_AGP);\n\n\t \n\tpci_read_config_dword(serverworks_private.svrwrks_dev,\n\t\t\t      agp_bridge->capndx+PCI_AGP_STATUS, &agp_bridge->mode);\n\n\tpci_read_config_byte(agp_bridge->dev, SVWRKS_CACHING, &enable_reg);\n\tenable_reg &= ~0x3;\n\tpci_write_config_byte(agp_bridge->dev, SVWRKS_CACHING, enable_reg);\n\n\tpci_read_config_byte(agp_bridge->dev, SVWRKS_FEATURE, &enable_reg);\n\tenable_reg |= (1<<6);\n\tpci_write_config_byte(agp_bridge->dev,SVWRKS_FEATURE, enable_reg);\n\n\treturn 0;\n}\n\nstatic void serverworks_cleanup(void)\n{\n\tiounmap((void __iomem *) serverworks_private.registers);\n}\n\nstatic int serverworks_insert_memory(struct agp_memory *mem,\n\t\t\t     off_t pg_start, int type)\n{\n\tint i, j, num_entries;\n\tunsigned long __iomem *cur_gatt;\n\tunsigned long addr;\n\n\tnum_entries = A_SIZE_LVL2(agp_bridge->current_size)->num_entries;\n\n\tif (type != 0 || mem->type != 0) {\n\t\treturn -EINVAL;\n\t}\n\tif ((pg_start + mem->page_count) > num_entries) {\n\t\treturn -EINVAL;\n\t}\n\n\tj = pg_start;\n\twhile (j < (pg_start + mem->page_count)) {\n\t\taddr = (j * PAGE_SIZE) + agp_bridge->gart_bus_addr;\n\t\tcur_gatt = SVRWRKS_GET_GATT(addr);\n\t\tif (!PGE_EMPTY(agp_bridge, readl(cur_gatt+GET_GATT_OFF(addr))))\n\t\t\treturn -EBUSY;\n\t\tj++;\n\t}\n\n\tif (!mem->is_flushed) {\n\t\tglobal_cache_flush();\n\t\tmem->is_flushed = true;\n\t}\n\n\tfor (i = 0, j = pg_start; i < mem->page_count; i++, j++) {\n\t\taddr = (j * PAGE_SIZE) + agp_bridge->gart_bus_addr;\n\t\tcur_gatt = SVRWRKS_GET_GATT(addr);\n\t\twritel(agp_bridge->driver->mask_memory(agp_bridge,\n\t\t\t\tpage_to_phys(mem->pages[i]), mem->type),\n\t\t       cur_gatt+GET_GATT_OFF(addr));\n\t}\n\tserverworks_tlbflush(mem);\n\treturn 0;\n}\n\nstatic int serverworks_remove_memory(struct agp_memory *mem, off_t pg_start,\n\t\t\t     int type)\n{\n\tint i;\n\tunsigned long __iomem *cur_gatt;\n\tunsigned long addr;\n\n\tif (type != 0 || mem->type != 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tglobal_cache_flush();\n\tserverworks_tlbflush(mem);\n\n\tfor (i = pg_start; i < (mem->page_count + pg_start); i++) {\n\t\taddr = (i * PAGE_SIZE) + agp_bridge->gart_bus_addr;\n\t\tcur_gatt = SVRWRKS_GET_GATT(addr);\n\t\twritel(agp_bridge->scratch_page, cur_gatt+GET_GATT_OFF(addr));\n\t}\n\n\tserverworks_tlbflush(mem);\n\treturn 0;\n}\n\nstatic const struct gatt_mask serverworks_masks[] =\n{\n\t{.mask = 1, .type = 0}\n};\n\nstatic const struct aper_size_info_lvl2 serverworks_sizes[7] =\n{\n\t{2048, 524288, 0x80000000},\n\t{1024, 262144, 0xc0000000},\n\t{512, 131072, 0xe0000000},\n\t{256, 65536, 0xf0000000},\n\t{128, 32768, 0xf8000000},\n\t{64, 16384, 0xfc000000},\n\t{32, 8192, 0xfe000000}\n};\n\nstatic void serverworks_agp_enable(struct agp_bridge_data *bridge, u32 mode)\n{\n\tu32 command;\n\n\tpci_read_config_dword(serverworks_private.svrwrks_dev,\n\t\t\t      bridge->capndx + PCI_AGP_STATUS,\n\t\t\t      &command);\n\n\tcommand = agp_collect_device_status(bridge, mode, command);\n\n\tcommand &= ~0x10;\t \n\tcommand &= ~0x08;\n\n\tcommand |= 0x100;\n\n\tpci_write_config_dword(serverworks_private.svrwrks_dev,\n\t\t\t       bridge->capndx + PCI_AGP_COMMAND,\n\t\t\t       command);\n\n\tagp_device_command(command, false);\n}\n\nstatic const struct agp_bridge_driver sworks_driver = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.aperture_sizes\t\t= serverworks_sizes,\n\t.size_type\t\t= LVL2_APER_SIZE,\n\t.num_aperture_sizes\t= 7,\n\t.configure\t\t= serverworks_configure,\n\t.fetch_size\t\t= serverworks_fetch_size,\n\t.cleanup\t\t= serverworks_cleanup,\n\t.tlb_flush\t\t= serverworks_tlbflush,\n\t.mask_memory\t\t= agp_generic_mask_memory,\n\t.masks\t\t\t= serverworks_masks,\n\t.agp_enable\t\t= serverworks_agp_enable,\n\t.cache_flush\t\t= global_cache_flush,\n\t.create_gatt_table\t= serverworks_create_gatt_table,\n\t.free_gatt_table\t= serverworks_free_gatt_table,\n\t.insert_memory\t\t= serverworks_insert_memory,\n\t.remove_memory\t\t= serverworks_remove_memory,\n\t.alloc_by_type\t\t= agp_generic_alloc_by_type,\n\t.free_by_type\t\t= agp_generic_free_by_type,\n\t.agp_alloc_page\t\t= agp_generic_alloc_page,\n\t.agp_alloc_pages\t= agp_generic_alloc_pages,\n\t.agp_destroy_page\t= agp_generic_destroy_page,\n\t.agp_destroy_pages\t= agp_generic_destroy_pages,\n\t.agp_type_to_mask_type  = agp_generic_type_to_mask_type,\n};\n\nstatic int agp_serverworks_probe(struct pci_dev *pdev,\n\t\t\t\t const struct pci_device_id *ent)\n{\n\tstruct agp_bridge_data *bridge;\n\tstruct pci_dev *bridge_dev;\n\tu32 temp, temp2;\n\tu8 cap_ptr = 0;\n\n\tcap_ptr = pci_find_capability(pdev, PCI_CAP_ID_AGP);\n\n\tswitch (pdev->device) {\n\tcase 0x0006:\n\t\tdev_err(&pdev->dev, \"ServerWorks CNB20HE is unsupported due to lack of documentation\\n\");\n\t\treturn -ENODEV;\n\n\tcase PCI_DEVICE_ID_SERVERWORKS_HE:\n\tcase PCI_DEVICE_ID_SERVERWORKS_LE:\n\tcase 0x0007:\n\t\tbreak;\n\n\tdefault:\n\t\tif (cap_ptr)\n\t\t\tdev_err(&pdev->dev, \"unsupported Serverworks chipset \"\n\t\t\t\t\"[%04x/%04x]\\n\", pdev->vendor, pdev->device);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tbridge_dev = pci_get_domain_bus_and_slot(pci_domain_nr(pdev->bus),\n\t\t\t(unsigned int)pdev->bus->number,\n\t\t\tPCI_DEVFN(0, 1));\n\tif (!bridge_dev) {\n\t\tdev_info(&pdev->dev, \"can't find secondary device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tserverworks_private.svrwrks_dev = bridge_dev;\n\tserverworks_private.gart_addr_ofs = 0x10;\n\n\tpci_read_config_dword(pdev, SVWRKS_APSIZE, &temp);\n\tif (temp & PCI_BASE_ADDRESS_MEM_TYPE_64) {\n\t\tpci_read_config_dword(pdev, SVWRKS_APSIZE + 4, &temp2);\n\t\tif (temp2 != 0) {\n\t\t\tdev_info(&pdev->dev, \"64 bit aperture address, \"\n\t\t\t\t \"but top bits are not zero; disabling AGP\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tserverworks_private.mm_addr_ofs = 0x18;\n\t} else\n\t\tserverworks_private.mm_addr_ofs = 0x14;\n\n\tpci_read_config_dword(pdev, serverworks_private.mm_addr_ofs, &temp);\n\tif (temp & PCI_BASE_ADDRESS_MEM_TYPE_64) {\n\t\tpci_read_config_dword(pdev,\n\t\t\t\tserverworks_private.mm_addr_ofs + 4, &temp2);\n\t\tif (temp2 != 0) {\n\t\t\tdev_info(&pdev->dev, \"64 bit MMIO address, but top \"\n\t\t\t\t \"bits are not zero; disabling AGP\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\tbridge = agp_alloc_bridge();\n\tif (!bridge)\n\t\treturn -ENOMEM;\n\n\tbridge->driver = &sworks_driver;\n\tbridge->dev_private_data = &serverworks_private;\n\tbridge->dev = pci_dev_get(pdev);\n\n\tpci_set_drvdata(pdev, bridge);\n\treturn agp_add_bridge(bridge);\n}\n\nstatic void agp_serverworks_remove(struct pci_dev *pdev)\n{\n\tstruct agp_bridge_data *bridge = pci_get_drvdata(pdev);\n\n\tpci_dev_put(bridge->dev);\n\tagp_remove_bridge(bridge);\n\tagp_put_bridge(bridge);\n\tpci_dev_put(serverworks_private.svrwrks_dev);\n\tserverworks_private.svrwrks_dev = NULL;\n}\n\nstatic struct pci_device_id agp_serverworks_pci_table[] = {\n\t{\n\t.class\t\t= (PCI_CLASS_BRIDGE_HOST << 8),\n\t.class_mask\t= ~0,\n\t.vendor\t\t= PCI_VENDOR_ID_SERVERWORKS,\n\t.device\t\t= PCI_ANY_ID,\n\t.subvendor\t= PCI_ANY_ID,\n\t.subdevice\t= PCI_ANY_ID,\n\t},\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(pci, agp_serverworks_pci_table);\n\nstatic struct pci_driver agp_serverworks_pci_driver = {\n\t.name\t\t= \"agpgart-serverworks\",\n\t.id_table\t= agp_serverworks_pci_table,\n\t.probe\t\t= agp_serverworks_probe,\n\t.remove\t\t= agp_serverworks_remove,\n};\n\nstatic int __init agp_serverworks_init(void)\n{\n\tif (agp_off)\n\t\treturn -EINVAL;\n\treturn pci_register_driver(&agp_serverworks_pci_driver);\n}\n\nstatic void __exit agp_serverworks_cleanup(void)\n{\n\tpci_unregister_driver(&agp_serverworks_pci_driver);\n}\n\nmodule_init(agp_serverworks_init);\nmodule_exit(agp_serverworks_cleanup);\n\nMODULE_LICENSE(\"GPL and additional rights\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}