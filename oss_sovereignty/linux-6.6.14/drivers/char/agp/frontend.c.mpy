{
  "module_name": "frontend.c",
  "hash_id": "d1de5259948474a4a64be1daeade56d1503b31d2dcdc13dbf89fe42524feee4e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/agp/frontend.c",
  "human_readable_source": " \n\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mman.h>\n#include <linux/pci.h>\n#include <linux/miscdevice.h>\n#include <linux/agp_backend.h>\n#include <linux/agpgart.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/uaccess.h>\n\n#include \"agp.h\"\n#include \"compat_ioctl.h\"\n\nstruct agp_front_data agp_fe;\n\nstruct agp_memory *agp_find_mem_by_key(int key)\n{\n\tstruct agp_memory *curr;\n\n\tif (agp_fe.current_controller == NULL)\n\t\treturn NULL;\n\n\tcurr = agp_fe.current_controller->pool;\n\n\twhile (curr != NULL) {\n\t\tif (curr->key == key)\n\t\t\tbreak;\n\t\tcurr = curr->next;\n\t}\n\n\tDBG(\"key=%d -> mem=%p\", key, curr);\n\treturn curr;\n}\n\nstatic void agp_remove_from_pool(struct agp_memory *temp)\n{\n\tstruct agp_memory *prev;\n\tstruct agp_memory *next;\n\n\t \n\n\tDBG(\"mem=%p\", temp);\n\tif (agp_find_mem_by_key(temp->key) != NULL) {\n\t\tnext = temp->next;\n\t\tprev = temp->prev;\n\n\t\tif (prev != NULL) {\n\t\t\tprev->next = next;\n\t\t\tif (next != NULL)\n\t\t\t\tnext->prev = prev;\n\n\t\t} else {\n\t\t\t \n\t\t\tif (next != NULL)\n\t\t\t\tnext->prev = NULL;\n\n\t\t\tagp_fe.current_controller->pool = next;\n\t\t}\n\t}\n}\n\n \n\nstatic struct\nagp_segment_priv *agp_find_seg_in_client(const struct agp_client *client,\n\t\t\t\t\t\tunsigned long offset,\n\t\t\t\t\t    int size, pgprot_t page_prot)\n{\n\tstruct agp_segment_priv *seg;\n\tint i;\n\toff_t pg_start;\n\tsize_t pg_count;\n\n\tpg_start = offset / 4096;\n\tpg_count = size / 4096;\n\tseg = *(client->segments);\n\n\tfor (i = 0; i < client->num_segments; i++) {\n\t\tif ((seg[i].pg_start == pg_start) &&\n\t\t    (seg[i].pg_count == pg_count) &&\n\t\t    (pgprot_val(seg[i].prot) == pgprot_val(page_prot))) {\n\t\t\treturn seg + i;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic void agp_remove_seg_from_client(struct agp_client *client)\n{\n\tDBG(\"client=%p\", client);\n\n\tif (client->segments != NULL) {\n\t\tif (*(client->segments) != NULL) {\n\t\t\tDBG(\"Freeing %p from client %p\", *(client->segments), client);\n\t\t\tkfree(*(client->segments));\n\t\t}\n\t\tDBG(\"Freeing %p from client %p\", client->segments, client);\n\t\tkfree(client->segments);\n\t\tclient->segments = NULL;\n\t}\n}\n\nstatic void agp_add_seg_to_client(struct agp_client *client,\n\t\t\t       struct agp_segment_priv ** seg, int num_segments)\n{\n\tstruct agp_segment_priv **prev_seg;\n\n\tprev_seg = client->segments;\n\n\tif (prev_seg != NULL)\n\t\tagp_remove_seg_from_client(client);\n\n\tDBG(\"Adding seg %p (%d segments) to client %p\", seg, num_segments, client);\n\tclient->num_segments = num_segments;\n\tclient->segments = seg;\n}\n\nstatic pgprot_t agp_convert_mmap_flags(int prot)\n{\n\tunsigned long prot_bits;\n\n\tprot_bits = calc_vm_prot_bits(prot, 0) | VM_SHARED;\n\treturn vm_get_page_prot(prot_bits);\n}\n\nint agp_create_segment(struct agp_client *client, struct agp_region *region)\n{\n\tstruct agp_segment_priv **ret_seg;\n\tstruct agp_segment_priv *seg;\n\tstruct agp_segment *user_seg;\n\tsize_t i;\n\n\tseg = kzalloc((sizeof(struct agp_segment_priv) * region->seg_count), GFP_KERNEL);\n\tif (seg == NULL) {\n\t\tkfree(region->seg_list);\n\t\tregion->seg_list = NULL;\n\t\treturn -ENOMEM;\n\t}\n\tuser_seg = region->seg_list;\n\n\tfor (i = 0; i < region->seg_count; i++) {\n\t\tseg[i].pg_start = user_seg[i].pg_start;\n\t\tseg[i].pg_count = user_seg[i].pg_count;\n\t\tseg[i].prot = agp_convert_mmap_flags(user_seg[i].prot);\n\t}\n\tkfree(region->seg_list);\n\tregion->seg_list = NULL;\n\n\tret_seg = kmalloc(sizeof(void *), GFP_KERNEL);\n\tif (ret_seg == NULL) {\n\t\tkfree(seg);\n\t\treturn -ENOMEM;\n\t}\n\t*ret_seg = seg;\n\tagp_add_seg_to_client(client, ret_seg, region->seg_count);\n\treturn 0;\n}\n\n \n\n \nstatic void agp_insert_into_pool(struct agp_memory * temp)\n{\n\tstruct agp_memory *prev;\n\n\tprev = agp_fe.current_controller->pool;\n\n\tif (prev != NULL) {\n\t\tprev->prev = temp;\n\t\ttemp->next = prev;\n\t}\n\tagp_fe.current_controller->pool = temp;\n}\n\n\n \n\nstruct agp_file_private *agp_find_private(pid_t pid)\n{\n\tstruct agp_file_private *curr;\n\n\tcurr = agp_fe.file_priv_list;\n\n\twhile (curr != NULL) {\n\t\tif (curr->my_pid == pid)\n\t\t\treturn curr;\n\t\tcurr = curr->next;\n\t}\n\n\treturn NULL;\n}\n\nstatic void agp_insert_file_private(struct agp_file_private * priv)\n{\n\tstruct agp_file_private *prev;\n\n\tprev = agp_fe.file_priv_list;\n\n\tif (prev != NULL)\n\t\tprev->prev = priv;\n\tpriv->next = prev;\n\tagp_fe.file_priv_list = priv;\n}\n\nstatic void agp_remove_file_private(struct agp_file_private * priv)\n{\n\tstruct agp_file_private *next;\n\tstruct agp_file_private *prev;\n\n\tnext = priv->next;\n\tprev = priv->prev;\n\n\tif (prev != NULL) {\n\t\tprev->next = next;\n\n\t\tif (next != NULL)\n\t\t\tnext->prev = prev;\n\n\t} else {\n\t\tif (next != NULL)\n\t\t\tnext->prev = NULL;\n\n\t\tagp_fe.file_priv_list = next;\n\t}\n}\n\n \n\n \nvoid agp_free_memory_wrap(struct agp_memory *memory)\n{\n\tagp_remove_from_pool(memory);\n\tagp_free_memory(memory);\n}\n\nstruct agp_memory *agp_allocate_memory_wrap(size_t pg_count, u32 type)\n{\n\tstruct agp_memory *memory;\n\n\tmemory = agp_allocate_memory(agp_bridge, pg_count, type);\n\tif (memory == NULL)\n\t\treturn NULL;\n\n\tagp_insert_into_pool(memory);\n\treturn memory;\n}\n\n \n\nstatic struct agp_controller *agp_find_controller_by_pid(pid_t id)\n{\n\tstruct agp_controller *controller;\n\n\tcontroller = agp_fe.controllers;\n\n\twhile (controller != NULL) {\n\t\tif (controller->pid == id)\n\t\t\treturn controller;\n\t\tcontroller = controller->next;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct agp_controller *agp_create_controller(pid_t id)\n{\n\tstruct agp_controller *controller;\n\n\tcontroller = kzalloc(sizeof(struct agp_controller), GFP_KERNEL);\n\tif (controller == NULL)\n\t\treturn NULL;\n\n\tcontroller->pid = id;\n\treturn controller;\n}\n\nstatic int agp_insert_controller(struct agp_controller *controller)\n{\n\tstruct agp_controller *prev_controller;\n\n\tprev_controller = agp_fe.controllers;\n\tcontroller->next = prev_controller;\n\n\tif (prev_controller != NULL)\n\t\tprev_controller->prev = controller;\n\n\tagp_fe.controllers = controller;\n\n\treturn 0;\n}\n\nstatic void agp_remove_all_clients(struct agp_controller *controller)\n{\n\tstruct agp_client *client;\n\tstruct agp_client *temp;\n\n\tclient = controller->clients;\n\n\twhile (client) {\n\t\tstruct agp_file_private *priv;\n\n\t\ttemp = client;\n\t\tagp_remove_seg_from_client(temp);\n\t\tpriv = agp_find_private(temp->pid);\n\n\t\tif (priv != NULL) {\n\t\t\tclear_bit(AGP_FF_IS_VALID, &priv->access_flags);\n\t\t\tclear_bit(AGP_FF_IS_CLIENT, &priv->access_flags);\n\t\t}\n\t\tclient = client->next;\n\t\tkfree(temp);\n\t}\n}\n\nstatic void agp_remove_all_memory(struct agp_controller *controller)\n{\n\tstruct agp_memory *memory;\n\tstruct agp_memory *temp;\n\n\tmemory = controller->pool;\n\n\twhile (memory) {\n\t\ttemp = memory;\n\t\tmemory = memory->next;\n\t\tagp_free_memory_wrap(temp);\n\t}\n}\n\nstatic int agp_remove_controller(struct agp_controller *controller)\n{\n\tstruct agp_controller *prev_controller;\n\tstruct agp_controller *next_controller;\n\n\tprev_controller = controller->prev;\n\tnext_controller = controller->next;\n\n\tif (prev_controller != NULL) {\n\t\tprev_controller->next = next_controller;\n\t\tif (next_controller != NULL)\n\t\t\tnext_controller->prev = prev_controller;\n\n\t} else {\n\t\tif (next_controller != NULL)\n\t\t\tnext_controller->prev = NULL;\n\n\t\tagp_fe.controllers = next_controller;\n\t}\n\n\tagp_remove_all_memory(controller);\n\tagp_remove_all_clients(controller);\n\n\tif (agp_fe.current_controller == controller) {\n\t\tagp_fe.current_controller = NULL;\n\t\tagp_fe.backend_acquired = false;\n\t\tagp_backend_release(agp_bridge);\n\t}\n\tkfree(controller);\n\treturn 0;\n}\n\nstatic void agp_controller_make_current(struct agp_controller *controller)\n{\n\tstruct agp_client *clients;\n\n\tclients = controller->clients;\n\n\twhile (clients != NULL) {\n\t\tstruct agp_file_private *priv;\n\n\t\tpriv = agp_find_private(clients->pid);\n\n\t\tif (priv != NULL) {\n\t\t\tset_bit(AGP_FF_IS_VALID, &priv->access_flags);\n\t\t\tset_bit(AGP_FF_IS_CLIENT, &priv->access_flags);\n\t\t}\n\t\tclients = clients->next;\n\t}\n\n\tagp_fe.current_controller = controller;\n}\n\nstatic void agp_controller_release_current(struct agp_controller *controller,\n\t\t\t\t      struct agp_file_private *controller_priv)\n{\n\tstruct agp_client *clients;\n\n\tclear_bit(AGP_FF_IS_VALID, &controller_priv->access_flags);\n\tclients = controller->clients;\n\n\twhile (clients != NULL) {\n\t\tstruct agp_file_private *priv;\n\n\t\tpriv = agp_find_private(clients->pid);\n\n\t\tif (priv != NULL)\n\t\t\tclear_bit(AGP_FF_IS_VALID, &priv->access_flags);\n\n\t\tclients = clients->next;\n\t}\n\n\tagp_fe.current_controller = NULL;\n\tagp_fe.used_by_controller = false;\n\tagp_backend_release(agp_bridge);\n}\n\n \n\nstatic struct agp_client\n*agp_find_client_in_controller(struct agp_controller *controller, pid_t id)\n{\n\tstruct agp_client *client;\n\n\tif (controller == NULL)\n\t\treturn NULL;\n\n\tclient = controller->clients;\n\n\twhile (client != NULL) {\n\t\tif (client->pid == id)\n\t\t\treturn client;\n\t\tclient = client->next;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct agp_controller *agp_find_controller_for_client(pid_t id)\n{\n\tstruct agp_controller *controller;\n\n\tcontroller = agp_fe.controllers;\n\n\twhile (controller != NULL) {\n\t\tif ((agp_find_client_in_controller(controller, id)) != NULL)\n\t\t\treturn controller;\n\t\tcontroller = controller->next;\n\t}\n\n\treturn NULL;\n}\n\nstruct agp_client *agp_find_client_by_pid(pid_t id)\n{\n\tstruct agp_client *temp;\n\n\tif (agp_fe.current_controller == NULL)\n\t\treturn NULL;\n\n\ttemp = agp_find_client_in_controller(agp_fe.current_controller, id);\n\treturn temp;\n}\n\nstatic void agp_insert_client(struct agp_client *client)\n{\n\tstruct agp_client *prev_client;\n\n\tprev_client = agp_fe.current_controller->clients;\n\tclient->next = prev_client;\n\n\tif (prev_client != NULL)\n\t\tprev_client->prev = client;\n\n\tagp_fe.current_controller->clients = client;\n\tagp_fe.current_controller->num_clients++;\n}\n\nstruct agp_client *agp_create_client(pid_t id)\n{\n\tstruct agp_client *new_client;\n\n\tnew_client = kzalloc(sizeof(struct agp_client), GFP_KERNEL);\n\tif (new_client == NULL)\n\t\treturn NULL;\n\n\tnew_client->pid = id;\n\tagp_insert_client(new_client);\n\treturn new_client;\n}\n\nint agp_remove_client(pid_t id)\n{\n\tstruct agp_client *client;\n\tstruct agp_client *prev_client;\n\tstruct agp_client *next_client;\n\tstruct agp_controller *controller;\n\n\tcontroller = agp_find_controller_for_client(id);\n\tif (controller == NULL)\n\t\treturn -EINVAL;\n\n\tclient = agp_find_client_in_controller(controller, id);\n\tif (client == NULL)\n\t\treturn -EINVAL;\n\n\tprev_client = client->prev;\n\tnext_client = client->next;\n\n\tif (prev_client != NULL) {\n\t\tprev_client->next = next_client;\n\t\tif (next_client != NULL)\n\t\t\tnext_client->prev = prev_client;\n\n\t} else {\n\t\tif (next_client != NULL)\n\t\t\tnext_client->prev = NULL;\n\t\tcontroller->clients = next_client;\n\t}\n\n\tcontroller->num_clients--;\n\tagp_remove_seg_from_client(client);\n\tkfree(client);\n\treturn 0;\n}\n\n \n\n \n\nstatic int agp_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tunsigned int size, current_size;\n\tunsigned long offset;\n\tstruct agp_client *client;\n\tstruct agp_file_private *priv = file->private_data;\n\tstruct agp_kern_info kerninfo;\n\n\tmutex_lock(&(agp_fe.agp_mutex));\n\n\tif (agp_fe.backend_acquired != true)\n\t\tgoto out_eperm;\n\n\tif (!(test_bit(AGP_FF_IS_VALID, &priv->access_flags)))\n\t\tgoto out_eperm;\n\n\tagp_copy_info(agp_bridge, &kerninfo);\n\tsize = vma->vm_end - vma->vm_start;\n\tcurrent_size = kerninfo.aper_size;\n\tcurrent_size = current_size * 0x100000;\n\toffset = vma->vm_pgoff << PAGE_SHIFT;\n\tDBG(\"%lx:%lx\", offset, offset+size);\n\n\tif (test_bit(AGP_FF_IS_CLIENT, &priv->access_flags)) {\n\t\tif ((size + offset) > current_size)\n\t\t\tgoto out_inval;\n\n\t\tclient = agp_find_client_by_pid(current->pid);\n\n\t\tif (client == NULL)\n\t\t\tgoto out_eperm;\n\n\t\tif (!agp_find_seg_in_client(client, offset, size, vma->vm_page_prot))\n\t\t\tgoto out_inval;\n\n\t\tDBG(\"client vm_ops=%p\", kerninfo.vm_ops);\n\t\tif (kerninfo.vm_ops) {\n\t\t\tvma->vm_ops = kerninfo.vm_ops;\n\t\t} else if (io_remap_pfn_range(vma, vma->vm_start,\n\t\t\t\t(kerninfo.aper_base + offset) >> PAGE_SHIFT,\n\t\t\t\tsize,\n\t\t\t\tpgprot_writecombine(vma->vm_page_prot))) {\n\t\t\tgoto out_again;\n\t\t}\n\t\tmutex_unlock(&(agp_fe.agp_mutex));\n\t\treturn 0;\n\t}\n\n\tif (test_bit(AGP_FF_IS_CONTROLLER, &priv->access_flags)) {\n\t\tif (size != current_size)\n\t\t\tgoto out_inval;\n\n\t\tDBG(\"controller vm_ops=%p\", kerninfo.vm_ops);\n\t\tif (kerninfo.vm_ops) {\n\t\t\tvma->vm_ops = kerninfo.vm_ops;\n\t\t} else if (io_remap_pfn_range(vma, vma->vm_start,\n\t\t\t\tkerninfo.aper_base >> PAGE_SHIFT,\n\t\t\t\tsize,\n\t\t\t\tpgprot_writecombine(vma->vm_page_prot))) {\n\t\t\tgoto out_again;\n\t\t}\n\t\tmutex_unlock(&(agp_fe.agp_mutex));\n\t\treturn 0;\n\t}\n\nout_eperm:\n\tmutex_unlock(&(agp_fe.agp_mutex));\n\treturn -EPERM;\n\nout_inval:\n\tmutex_unlock(&(agp_fe.agp_mutex));\n\treturn -EINVAL;\n\nout_again:\n\tmutex_unlock(&(agp_fe.agp_mutex));\n\treturn -EAGAIN;\n}\n\nstatic int agp_release(struct inode *inode, struct file *file)\n{\n\tstruct agp_file_private *priv = file->private_data;\n\n\tmutex_lock(&(agp_fe.agp_mutex));\n\n\tDBG(\"priv=%p\", priv);\n\n\tif (test_bit(AGP_FF_IS_CONTROLLER, &priv->access_flags)) {\n\t\tstruct agp_controller *controller;\n\n\t\tcontroller = agp_find_controller_by_pid(priv->my_pid);\n\n\t\tif (controller != NULL) {\n\t\t\tif (controller == agp_fe.current_controller)\n\t\t\t\tagp_controller_release_current(controller, priv);\n\t\t\tagp_remove_controller(controller);\n\t\t\tcontroller = NULL;\n\t\t}\n\t}\n\n\tif (test_bit(AGP_FF_IS_CLIENT, &priv->access_flags))\n\t\tagp_remove_client(priv->my_pid);\n\n\tagp_remove_file_private(priv);\n\tkfree(priv);\n\tfile->private_data = NULL;\n\tmutex_unlock(&(agp_fe.agp_mutex));\n\treturn 0;\n}\n\nstatic int agp_open(struct inode *inode, struct file *file)\n{\n\tint minor = iminor(inode);\n\tstruct agp_file_private *priv;\n\tstruct agp_client *client;\n\n\tif (minor != AGPGART_MINOR)\n\t\treturn -ENXIO;\n\n\tmutex_lock(&(agp_fe.agp_mutex));\n\n\tpriv = kzalloc(sizeof(struct agp_file_private), GFP_KERNEL);\n\tif (priv == NULL) {\n\t\tmutex_unlock(&(agp_fe.agp_mutex));\n\t\treturn -ENOMEM;\n\t}\n\n\tset_bit(AGP_FF_ALLOW_CLIENT, &priv->access_flags);\n\tpriv->my_pid = current->pid;\n\n\tif (capable(CAP_SYS_RAWIO))\n\t\t \n\t\tset_bit(AGP_FF_ALLOW_CONTROLLER, &priv->access_flags);\n\n\tclient = agp_find_client_by_pid(current->pid);\n\n\tif (client != NULL) {\n\t\tset_bit(AGP_FF_IS_CLIENT, &priv->access_flags);\n\t\tset_bit(AGP_FF_IS_VALID, &priv->access_flags);\n\t}\n\tfile->private_data = (void *) priv;\n\tagp_insert_file_private(priv);\n\tDBG(\"private=%p, client=%p\", priv, client);\n\n\tmutex_unlock(&(agp_fe.agp_mutex));\n\n\treturn 0;\n}\n\nstatic int agpioc_info_wrap(struct agp_file_private *priv, void __user *arg)\n{\n\tstruct agp_info userinfo;\n\tstruct agp_kern_info kerninfo;\n\n\tagp_copy_info(agp_bridge, &kerninfo);\n\n\tmemset(&userinfo, 0, sizeof(userinfo));\n\tuserinfo.version.major = kerninfo.version.major;\n\tuserinfo.version.minor = kerninfo.version.minor;\n\tuserinfo.bridge_id = kerninfo.device->vendor |\n\t    (kerninfo.device->device << 16);\n\tuserinfo.agp_mode = kerninfo.mode;\n\tuserinfo.aper_base = kerninfo.aper_base;\n\tuserinfo.aper_size = kerninfo.aper_size;\n\tuserinfo.pg_total = userinfo.pg_system = kerninfo.max_memory;\n\tuserinfo.pg_used = kerninfo.current_memory;\n\n\tif (copy_to_user(arg, &userinfo, sizeof(struct agp_info)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nint agpioc_acquire_wrap(struct agp_file_private *priv)\n{\n\tstruct agp_controller *controller;\n\n\tDBG(\"\");\n\n\tif (!(test_bit(AGP_FF_ALLOW_CONTROLLER, &priv->access_flags)))\n\t\treturn -EPERM;\n\n\tif (agp_fe.current_controller != NULL)\n\t\treturn -EBUSY;\n\n\tif (!agp_bridge)\n\t\treturn -ENODEV;\n\n        if (atomic_read(&agp_bridge->agp_in_use))\n                return -EBUSY;\n\n\tatomic_inc(&agp_bridge->agp_in_use);\n\n\tagp_fe.backend_acquired = true;\n\n\tcontroller = agp_find_controller_by_pid(priv->my_pid);\n\n\tif (controller != NULL) {\n\t\tagp_controller_make_current(controller);\n\t} else {\n\t\tcontroller = agp_create_controller(priv->my_pid);\n\n\t\tif (controller == NULL) {\n\t\t\tagp_fe.backend_acquired = false;\n\t\t\tagp_backend_release(agp_bridge);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tagp_insert_controller(controller);\n\t\tagp_controller_make_current(controller);\n\t}\n\n\tset_bit(AGP_FF_IS_CONTROLLER, &priv->access_flags);\n\tset_bit(AGP_FF_IS_VALID, &priv->access_flags);\n\treturn 0;\n}\n\nint agpioc_release_wrap(struct agp_file_private *priv)\n{\n\tDBG(\"\");\n\tagp_controller_release_current(agp_fe.current_controller, priv);\n\treturn 0;\n}\n\nint agpioc_setup_wrap(struct agp_file_private *priv, void __user *arg)\n{\n\tstruct agp_setup mode;\n\n\tDBG(\"\");\n\tif (copy_from_user(&mode, arg, sizeof(struct agp_setup)))\n\t\treturn -EFAULT;\n\n\tagp_enable(agp_bridge, mode.agp_mode);\n\treturn 0;\n}\n\nstatic int agpioc_reserve_wrap(struct agp_file_private *priv, void __user *arg)\n{\n\tstruct agp_region reserve;\n\tstruct agp_client *client;\n\tstruct agp_file_private *client_priv;\n\n\tDBG(\"\");\n\tif (copy_from_user(&reserve, arg, sizeof(struct agp_region)))\n\t\treturn -EFAULT;\n\n\tif ((unsigned) reserve.seg_count >= ~0U/sizeof(struct agp_segment))\n\t\treturn -EFAULT;\n\n\tclient = agp_find_client_by_pid(reserve.pid);\n\n\tif (reserve.seg_count == 0) {\n\t\t \n\t\tclient_priv = agp_find_private(reserve.pid);\n\n\t\tif (client_priv != NULL) {\n\t\t\tset_bit(AGP_FF_IS_CLIENT, &client_priv->access_flags);\n\t\t\tset_bit(AGP_FF_IS_VALID, &client_priv->access_flags);\n\t\t}\n\t\tif (client == NULL) {\n\t\t\t \n\t\t\treturn 0;\n\t\t}\n\t\treturn agp_remove_client(reserve.pid);\n\t} else {\n\t\tstruct agp_segment *segment;\n\n\t\tif (reserve.seg_count >= 16384)\n\t\t\treturn -EINVAL;\n\n\t\tsegment = kmalloc((sizeof(struct agp_segment) * reserve.seg_count),\n\t\t\t\t  GFP_KERNEL);\n\n\t\tif (segment == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tif (copy_from_user(segment, (void __user *) reserve.seg_list,\n\t\t\t\t   sizeof(struct agp_segment) * reserve.seg_count)) {\n\t\t\tkfree(segment);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\treserve.seg_list = segment;\n\n\t\tif (client == NULL) {\n\t\t\t \n\t\t\tclient = agp_create_client(reserve.pid);\n\n\t\t\tif (client == NULL) {\n\t\t\t\tkfree(segment);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tclient_priv = agp_find_private(reserve.pid);\n\n\t\t\tif (client_priv != NULL) {\n\t\t\t\tset_bit(AGP_FF_IS_CLIENT, &client_priv->access_flags);\n\t\t\t\tset_bit(AGP_FF_IS_VALID, &client_priv->access_flags);\n\t\t\t}\n\t\t}\n\t\treturn agp_create_segment(client, &reserve);\n\t}\n\t \n\treturn -EINVAL;\n}\n\nint agpioc_protect_wrap(struct agp_file_private *priv)\n{\n\tDBG(\"\");\n\t \n\treturn -EINVAL;\n}\n\nstatic int agpioc_allocate_wrap(struct agp_file_private *priv, void __user *arg)\n{\n\tstruct agp_memory *memory;\n\tstruct agp_allocate alloc;\n\n\tDBG(\"\");\n\tif (copy_from_user(&alloc, arg, sizeof(struct agp_allocate)))\n\t\treturn -EFAULT;\n\n\tif (alloc.type >= AGP_USER_TYPES)\n\t\treturn -EINVAL;\n\n\tmemory = agp_allocate_memory_wrap(alloc.pg_count, alloc.type);\n\n\tif (memory == NULL)\n\t\treturn -ENOMEM;\n\n\talloc.key = memory->key;\n\talloc.physical = memory->physical;\n\n\tif (copy_to_user(arg, &alloc, sizeof(struct agp_allocate))) {\n\t\tagp_free_memory_wrap(memory);\n\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\n\nint agpioc_deallocate_wrap(struct agp_file_private *priv, int arg)\n{\n\tstruct agp_memory *memory;\n\n\tDBG(\"\");\n\tmemory = agp_find_mem_by_key(arg);\n\n\tif (memory == NULL)\n\t\treturn -EINVAL;\n\n\tagp_free_memory_wrap(memory);\n\treturn 0;\n}\n\nstatic int agpioc_bind_wrap(struct agp_file_private *priv, void __user *arg)\n{\n\tstruct agp_bind bind_info;\n\tstruct agp_memory *memory;\n\n\tDBG(\"\");\n\tif (copy_from_user(&bind_info, arg, sizeof(struct agp_bind)))\n\t\treturn -EFAULT;\n\n\tmemory = agp_find_mem_by_key(bind_info.key);\n\n\tif (memory == NULL)\n\t\treturn -EINVAL;\n\n\treturn agp_bind_memory(memory, bind_info.pg_start);\n}\n\nstatic int agpioc_unbind_wrap(struct agp_file_private *priv, void __user *arg)\n{\n\tstruct agp_memory *memory;\n\tstruct agp_unbind unbind;\n\n\tDBG(\"\");\n\tif (copy_from_user(&unbind, arg, sizeof(struct agp_unbind)))\n\t\treturn -EFAULT;\n\n\tmemory = agp_find_mem_by_key(unbind.key);\n\n\tif (memory == NULL)\n\t\treturn -EINVAL;\n\n\treturn agp_unbind_memory(memory);\n}\n\nstatic long agp_ioctl(struct file *file,\n\t\t     unsigned int cmd, unsigned long arg)\n{\n\tstruct agp_file_private *curr_priv = file->private_data;\n\tint ret_val = -ENOTTY;\n\n\tDBG(\"priv=%p, cmd=%x\", curr_priv, cmd);\n\tmutex_lock(&(agp_fe.agp_mutex));\n\n\tif ((agp_fe.current_controller == NULL) &&\n\t    (cmd != AGPIOC_ACQUIRE)) {\n\t\tret_val = -EINVAL;\n\t\tgoto ioctl_out;\n\t}\n\tif ((agp_fe.backend_acquired != true) &&\n\t    (cmd != AGPIOC_ACQUIRE)) {\n\t\tret_val = -EBUSY;\n\t\tgoto ioctl_out;\n\t}\n\tif (cmd != AGPIOC_ACQUIRE) {\n\t\tif (!(test_bit(AGP_FF_IS_CONTROLLER, &curr_priv->access_flags))) {\n\t\t\tret_val = -EPERM;\n\t\t\tgoto ioctl_out;\n\t\t}\n\t\t \n\n\t\tif (agp_fe.current_controller->pid != curr_priv->my_pid) {\n\t\t\tret_val = -EBUSY;\n\t\t\tgoto ioctl_out;\n\t\t}\n\t}\n\n\tswitch (cmd) {\n\tcase AGPIOC_INFO:\n\t\tret_val = agpioc_info_wrap(curr_priv, (void __user *) arg);\n\t\tbreak;\n\n\tcase AGPIOC_ACQUIRE:\n\t\tret_val = agpioc_acquire_wrap(curr_priv);\n\t\tbreak;\n\n\tcase AGPIOC_RELEASE:\n\t\tret_val = agpioc_release_wrap(curr_priv);\n\t\tbreak;\n\n\tcase AGPIOC_SETUP:\n\t\tret_val = agpioc_setup_wrap(curr_priv, (void __user *) arg);\n\t\tbreak;\n\n\tcase AGPIOC_RESERVE:\n\t\tret_val = agpioc_reserve_wrap(curr_priv, (void __user *) arg);\n\t\tbreak;\n\n\tcase AGPIOC_PROTECT:\n\t\tret_val = agpioc_protect_wrap(curr_priv);\n\t\tbreak;\n\n\tcase AGPIOC_ALLOCATE:\n\t\tret_val = agpioc_allocate_wrap(curr_priv, (void __user *) arg);\n\t\tbreak;\n\n\tcase AGPIOC_DEALLOCATE:\n\t\tret_val = agpioc_deallocate_wrap(curr_priv, (int) arg);\n\t\tbreak;\n\n\tcase AGPIOC_BIND:\n\t\tret_val = agpioc_bind_wrap(curr_priv, (void __user *) arg);\n\t\tbreak;\n\n\tcase AGPIOC_UNBIND:\n\t\tret_val = agpioc_unbind_wrap(curr_priv, (void __user *) arg);\n\t\tbreak;\n\n\tcase AGPIOC_CHIPSET_FLUSH:\n\t\tbreak;\n\t}\n\nioctl_out:\n\tDBG(\"ioctl returns %d\\n\", ret_val);\n\tmutex_unlock(&(agp_fe.agp_mutex));\n\treturn ret_val;\n}\n\nstatic const struct file_operations agp_fops =\n{\n\t.owner\t\t= THIS_MODULE,\n\t.llseek\t\t= no_llseek,\n\t.unlocked_ioctl\t= agp_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t= compat_agp_ioctl,\n#endif\n\t.mmap\t\t= agp_mmap,\n\t.open\t\t= agp_open,\n\t.release\t= agp_release,\n};\n\nstatic struct miscdevice agp_miscdev =\n{\n\t.minor\t= AGPGART_MINOR,\n\t.name\t= \"agpgart\",\n\t.fops\t= &agp_fops\n};\n\nint agp_frontend_initialize(void)\n{\n\tmemset(&agp_fe, 0, sizeof(struct agp_front_data));\n\tmutex_init(&(agp_fe.agp_mutex));\n\n\tif (misc_register(&agp_miscdev)) {\n\t\tprintk(KERN_ERR PFX \"unable to get minor: %d\\n\", AGPGART_MINOR);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nvoid agp_frontend_cleanup(void)\n{\n\tmisc_deregister(&agp_miscdev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}