{
  "module_name": "compat_ioctl.c",
  "hash_id": "20ef8c60a88347d5b6b9e849daef6887f738be887aff5f5fa374b459d33c8531",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/agp/compat_ioctl.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/pci.h>\n#include <linux/fs.h>\n#include <linux/agpgart.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include \"agp.h\"\n#include \"compat_ioctl.h\"\n\nstatic int compat_agpioc_info_wrap(struct agp_file_private *priv, void __user *arg)\n{\n\tstruct agp_info32 userinfo;\n\tstruct agp_kern_info kerninfo;\n\n\tagp_copy_info(agp_bridge, &kerninfo);\n\n\tuserinfo.version.major = kerninfo.version.major;\n\tuserinfo.version.minor = kerninfo.version.minor;\n\tuserinfo.bridge_id = kerninfo.device->vendor |\n\t    (kerninfo.device->device << 16);\n\tuserinfo.agp_mode = kerninfo.mode;\n\tuserinfo.aper_base = (compat_long_t)kerninfo.aper_base;\n\tuserinfo.aper_size = kerninfo.aper_size;\n\tuserinfo.pg_total = userinfo.pg_system = kerninfo.max_memory;\n\tuserinfo.pg_used = kerninfo.current_memory;\n\n\tif (copy_to_user(arg, &userinfo, sizeof(userinfo)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int compat_agpioc_reserve_wrap(struct agp_file_private *priv, void __user *arg)\n{\n\tstruct agp_region32 ureserve;\n\tstruct agp_region kreserve;\n\tstruct agp_client *client;\n\tstruct agp_file_private *client_priv;\n\n\tDBG(\"\");\n\tif (copy_from_user(&ureserve, arg, sizeof(ureserve)))\n\t\treturn -EFAULT;\n\n\tif ((unsigned) ureserve.seg_count >= ~0U/sizeof(struct agp_segment32))\n\t\treturn -EFAULT;\n\n\tkreserve.pid = ureserve.pid;\n\tkreserve.seg_count = ureserve.seg_count;\n\n\tclient = agp_find_client_by_pid(kreserve.pid);\n\n\tif (kreserve.seg_count == 0) {\n\t\t \n\t\tclient_priv = agp_find_private(kreserve.pid);\n\n\t\tif (client_priv != NULL) {\n\t\t\tset_bit(AGP_FF_IS_CLIENT, &client_priv->access_flags);\n\t\t\tset_bit(AGP_FF_IS_VALID, &client_priv->access_flags);\n\t\t}\n\t\tif (client == NULL) {\n\t\t\t \n\t\t\treturn 0;\n\t\t}\n\t\treturn agp_remove_client(kreserve.pid);\n\t} else {\n\t\tstruct agp_segment32 *usegment;\n\t\tstruct agp_segment *ksegment;\n\t\tint seg;\n\n\t\tif (ureserve.seg_count >= 16384)\n\t\t\treturn -EINVAL;\n\n\t\tusegment = kmalloc_array(ureserve.seg_count,\n\t\t\t\t\t sizeof(*usegment),\n\t\t\t\t\t GFP_KERNEL);\n\t\tif (!usegment)\n\t\t\treturn -ENOMEM;\n\n\t\tksegment = kmalloc_array(kreserve.seg_count,\n\t\t\t\t\t sizeof(*ksegment),\n\t\t\t\t\t GFP_KERNEL);\n\t\tif (!ksegment) {\n\t\t\tkfree(usegment);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (copy_from_user(usegment, (void __user *) ureserve.seg_list,\n\t\t\t\t   sizeof(*usegment) * ureserve.seg_count)) {\n\t\t\tkfree(usegment);\n\t\t\tkfree(ksegment);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tfor (seg = 0; seg < ureserve.seg_count; seg++) {\n\t\t\tksegment[seg].pg_start = usegment[seg].pg_start;\n\t\t\tksegment[seg].pg_count = usegment[seg].pg_count;\n\t\t\tksegment[seg].prot = usegment[seg].prot;\n\t\t}\n\n\t\tkfree(usegment);\n\t\tkreserve.seg_list = ksegment;\n\n\t\tif (client == NULL) {\n\t\t\t \n\t\t\tclient = agp_create_client(kreserve.pid);\n\n\t\t\tif (client == NULL) {\n\t\t\t\tkfree(ksegment);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tclient_priv = agp_find_private(kreserve.pid);\n\n\t\t\tif (client_priv != NULL) {\n\t\t\t\tset_bit(AGP_FF_IS_CLIENT, &client_priv->access_flags);\n\t\t\t\tset_bit(AGP_FF_IS_VALID, &client_priv->access_flags);\n\t\t\t}\n\t\t}\n\t\treturn agp_create_segment(client, &kreserve);\n\t}\n\t \n\treturn -EINVAL;\n}\n\nstatic int compat_agpioc_allocate_wrap(struct agp_file_private *priv, void __user *arg)\n{\n\tstruct agp_memory *memory;\n\tstruct agp_allocate32 alloc;\n\n\tDBG(\"\");\n\tif (copy_from_user(&alloc, arg, sizeof(alloc)))\n\t\treturn -EFAULT;\n\n\tmemory = agp_allocate_memory_wrap(alloc.pg_count, alloc.type);\n\n\tif (memory == NULL)\n\t\treturn -ENOMEM;\n\n\talloc.key = memory->key;\n\talloc.physical = memory->physical;\n\n\tif (copy_to_user(arg, &alloc, sizeof(alloc))) {\n\t\tagp_free_memory_wrap(memory);\n\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\n\nstatic int compat_agpioc_bind_wrap(struct agp_file_private *priv, void __user *arg)\n{\n\tstruct agp_bind32 bind_info;\n\tstruct agp_memory *memory;\n\n\tDBG(\"\");\n\tif (copy_from_user(&bind_info, arg, sizeof(bind_info)))\n\t\treturn -EFAULT;\n\n\tmemory = agp_find_mem_by_key(bind_info.key);\n\n\tif (memory == NULL)\n\t\treturn -EINVAL;\n\n\treturn agp_bind_memory(memory, bind_info.pg_start);\n}\n\nstatic int compat_agpioc_unbind_wrap(struct agp_file_private *priv, void __user *arg)\n{\n\tstruct agp_memory *memory;\n\tstruct agp_unbind32 unbind;\n\n\tDBG(\"\");\n\tif (copy_from_user(&unbind, arg, sizeof(unbind)))\n\t\treturn -EFAULT;\n\n\tmemory = agp_find_mem_by_key(unbind.key);\n\n\tif (memory == NULL)\n\t\treturn -EINVAL;\n\n\treturn agp_unbind_memory(memory);\n}\n\nlong compat_agp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct agp_file_private *curr_priv = file->private_data;\n\tint ret_val = -ENOTTY;\n\n\tmutex_lock(&(agp_fe.agp_mutex));\n\n\tif ((agp_fe.current_controller == NULL) &&\n\t    (cmd != AGPIOC_ACQUIRE32)) {\n\t\tret_val = -EINVAL;\n\t\tgoto ioctl_out;\n\t}\n\tif ((agp_fe.backend_acquired != true) &&\n\t    (cmd != AGPIOC_ACQUIRE32)) {\n\t\tret_val = -EBUSY;\n\t\tgoto ioctl_out;\n\t}\n\tif (cmd != AGPIOC_ACQUIRE32) {\n\t\tif (!(test_bit(AGP_FF_IS_CONTROLLER, &curr_priv->access_flags))) {\n\t\t\tret_val = -EPERM;\n\t\t\tgoto ioctl_out;\n\t\t}\n\t\t \n\n\t\tif (agp_fe.current_controller->pid != curr_priv->my_pid) {\n\t\t\tret_val = -EBUSY;\n\t\t\tgoto ioctl_out;\n\t\t}\n\t}\n\n\tswitch (cmd) {\n\tcase AGPIOC_INFO32:\n\t\tret_val = compat_agpioc_info_wrap(curr_priv, (void __user *) arg);\n\t\tbreak;\n\n\tcase AGPIOC_ACQUIRE32:\n\t\tret_val = agpioc_acquire_wrap(curr_priv);\n\t\tbreak;\n\n\tcase AGPIOC_RELEASE32:\n\t\tret_val = agpioc_release_wrap(curr_priv);\n\t\tbreak;\n\n\tcase AGPIOC_SETUP32:\n\t\tret_val = agpioc_setup_wrap(curr_priv, (void __user *) arg);\n\t\tbreak;\n\n\tcase AGPIOC_RESERVE32:\n\t\tret_val = compat_agpioc_reserve_wrap(curr_priv, (void __user *) arg);\n\t\tbreak;\n\n\tcase AGPIOC_PROTECT32:\n\t\tret_val = agpioc_protect_wrap(curr_priv);\n\t\tbreak;\n\n\tcase AGPIOC_ALLOCATE32:\n\t\tret_val = compat_agpioc_allocate_wrap(curr_priv, (void __user *) arg);\n\t\tbreak;\n\n\tcase AGPIOC_DEALLOCATE32:\n\t\tret_val = agpioc_deallocate_wrap(curr_priv, (int) arg);\n\t\tbreak;\n\n\tcase AGPIOC_BIND32:\n\t\tret_val = compat_agpioc_bind_wrap(curr_priv, (void __user *) arg);\n\t\tbreak;\n\n\tcase AGPIOC_UNBIND32:\n\t\tret_val = compat_agpioc_unbind_wrap(curr_priv, (void __user *) arg);\n\t\tbreak;\n\n\tcase AGPIOC_CHIPSET_FLUSH32:\n\t\tbreak;\n\t}\n\nioctl_out:\n\tDBG(\"ioctl returns %d\\n\", ret_val);\n\tmutex_unlock(&(agp_fe.agp_mutex));\n\treturn ret_val;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}