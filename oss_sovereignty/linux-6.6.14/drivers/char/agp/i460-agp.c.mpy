{
  "module_name": "i460-agp.c",
  "hash_id": "a32b09c109862384b97c0a4a37bf0cc93028bc00d724db81e188494949cfcf5f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/agp/i460-agp.c",
  "human_readable_source": " \n \n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/agp_backend.h>\n#include <linux/log2.h>\n\n#include \"agp.h\"\n\n#define INTEL_I460_BAPBASE\t\t0x98\n#define INTEL_I460_GXBCTL\t\t0xa0\n#define INTEL_I460_AGPSIZ\t\t0xa2\n#define INTEL_I460_ATTBASE\t\t0xfe200000\n#define INTEL_I460_GATT_VALID\t\t(1UL << 24)\n#define INTEL_I460_GATT_COHERENT\t(1UL << 25)\n\n \n#define I460_LARGE_IO_PAGES\t\t0\n\n#if I460_LARGE_IO_PAGES\n# define I460_IO_PAGE_SHIFT\t\ti460.io_page_shift\n#else\n# define I460_IO_PAGE_SHIFT\t\t12\n#endif\n\n#define I460_IOPAGES_PER_KPAGE\t\t(PAGE_SIZE >> I460_IO_PAGE_SHIFT)\n#define I460_KPAGES_PER_IOPAGE\t\t(1 << (I460_IO_PAGE_SHIFT - PAGE_SHIFT))\n#define I460_SRAM_IO_DISABLE\t\t(1 << 4)\n#define I460_BAPBASE_ENABLE\t\t(1 << 3)\n#define I460_AGPSIZ_MASK\t\t0x7\n#define I460_4M_PS\t\t\t(1 << 1)\n\n \n#define I460_GXBCTL_OOG\t\t(1UL << 0)\n#define I460_GXBCTL_BWC\t\t(1UL << 2)\n\n \n#define RD_GATT(index)\t\treadl((u32 *) i460.gatt + (index))\n#define WR_GATT(index, val)\twritel((val), (u32 *) i460.gatt + (index))\n \n#define WR_FLUSH_GATT(index)\tRD_GATT(index)\n\nstatic unsigned long i460_mask_memory (struct agp_bridge_data *bridge,\n\t\t\t\t       dma_addr_t addr, int type);\n\nstatic struct {\n\tvoid *gatt;\t\t\t\t \n\n\t \n\tu8 io_page_shift;\n\n\t \n\tu8 dynamic_apbase;\n\n\t \n\tstruct lp_desc {\n\t\tunsigned long *alloced_map;\t \n\t\tint refcount;\t\t\t \n\t\tu64 paddr;\t\t\t \n\t\tstruct page *page; \t\t \n\t} *lp_desc;\n} i460;\n\nstatic const struct aper_size_info_8 i460_sizes[3] =\n{\n\t \n\t{32768, 0, 0, 4},\n\t{1024, 0, 0, 2},\n\t{256, 0, 0, 1}\n};\n\nstatic struct gatt_mask i460_masks[] =\n{\n\t{\n\t  .mask = INTEL_I460_GATT_VALID | INTEL_I460_GATT_COHERENT,\n\t  .type = 0\n\t}\n};\n\nstatic int i460_fetch_size (void)\n{\n\tint i;\n\tu8 temp;\n\tstruct aper_size_info_8 *values;\n\n\t \n\tpci_read_config_byte(agp_bridge->dev, INTEL_I460_GXBCTL, &temp);\n\ti460.io_page_shift = (temp & I460_4M_PS) ? 22 : 12;\n\tpr_debug(\"i460_fetch_size: io_page_shift=%d\\n\", i460.io_page_shift);\n\n\tif (i460.io_page_shift != I460_IO_PAGE_SHIFT) {\n\t\tprintk(KERN_ERR PFX\n\t\t\t\"I/O (GART) page-size %luKB doesn't match expected \"\n\t\t\t\t\"size %luKB\\n\",\n\t\t\t1UL << (i460.io_page_shift - 10),\n\t\t\t1UL << (I460_IO_PAGE_SHIFT));\n\t\treturn 0;\n\t}\n\n\tvalues = A_SIZE_8(agp_bridge->driver->aperture_sizes);\n\n\tpci_read_config_byte(agp_bridge->dev, INTEL_I460_AGPSIZ, &temp);\n\n\t \n\tif (temp & I460_SRAM_IO_DISABLE) {\n\t\tprintk(KERN_ERR PFX \"GART SRAMS disabled on 460GX chipset\\n\");\n\t\tprintk(KERN_ERR PFX \"AGPGART operation not possible\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tif ((i460.io_page_shift == 0) && ((temp & I460_AGPSIZ_MASK) == 4)) {\n\t\tprintk(KERN_ERR PFX \"We can't have a 32GB aperture with 4KB GART pages\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tif (temp & I460_BAPBASE_ENABLE)\n\t\ti460.dynamic_apbase = INTEL_I460_BAPBASE;\n\telse\n\t\ti460.dynamic_apbase = AGP_APBASE;\n\n\tfor (i = 0; i < agp_bridge->driver->num_aperture_sizes; i++) {\n\t\t \n\t\tvalues[i].num_entries = (values[i].size << 8) >> (I460_IO_PAGE_SHIFT - 12);\n\t\tvalues[i].page_order = ilog2((sizeof(u32)*values[i].num_entries) >> PAGE_SHIFT);\n\t}\n\n\tfor (i = 0; i < agp_bridge->driver->num_aperture_sizes; i++) {\n\t\t \n\t\tif ((temp & I460_AGPSIZ_MASK) == values[i].size_value) {\n\t\t\tagp_bridge->previous_size = agp_bridge->current_size = (void *) (values + i);\n\t\t\tagp_bridge->aperture_size_idx = i;\n\t\t\treturn values[i].size;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic void i460_tlb_flush (struct agp_memory *mem)\n{\n\treturn;\n}\n\n \nstatic void i460_write_agpsiz (u8 size_value)\n{\n\tu8 temp;\n\n\tpci_read_config_byte(agp_bridge->dev, INTEL_I460_AGPSIZ, &temp);\n\tpci_write_config_byte(agp_bridge->dev, INTEL_I460_AGPSIZ,\n\t\t\t      ((temp & ~I460_AGPSIZ_MASK) | size_value));\n}\n\nstatic void i460_cleanup (void)\n{\n\tstruct aper_size_info_8 *previous_size;\n\n\tprevious_size = A_SIZE_8(agp_bridge->previous_size);\n\ti460_write_agpsiz(previous_size->size_value);\n\n\tif (I460_IO_PAGE_SHIFT > PAGE_SHIFT)\n\t\tkfree(i460.lp_desc);\n}\n\nstatic int i460_configure (void)\n{\n\tunion {\n\t\tu32 small[2];\n\t\tu64 large;\n\t} temp;\n\tsize_t size;\n\tu8 scratch;\n\tstruct aper_size_info_8 *current_size;\n\n\ttemp.large = 0;\n\n\tcurrent_size = A_SIZE_8(agp_bridge->current_size);\n\ti460_write_agpsiz(current_size->size_value);\n\n\t \n\tpci_read_config_dword(agp_bridge->dev, i460.dynamic_apbase, &(temp.small[0]));\n\tpci_read_config_dword(agp_bridge->dev, i460.dynamic_apbase + 4, &(temp.small[1]));\n\n\t \n\tagp_bridge->gart_bus_addr = temp.large & ~((1UL << 3) - 1);\n\n\tpci_read_config_byte(agp_bridge->dev, INTEL_I460_GXBCTL, &scratch);\n\tpci_write_config_byte(agp_bridge->dev, INTEL_I460_GXBCTL,\n\t\t\t      (scratch & 0x02) | I460_GXBCTL_OOG | I460_GXBCTL_BWC);\n\n\t \n\tif (I460_IO_PAGE_SHIFT > PAGE_SHIFT) {\n\t\tsize = current_size->num_entries * sizeof(i460.lp_desc[0]);\n\t\ti460.lp_desc = kzalloc(size, GFP_KERNEL);\n\t\tif (!i460.lp_desc)\n\t\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nstatic int i460_create_gatt_table (struct agp_bridge_data *bridge)\n{\n\tint page_order, num_entries, i;\n\tvoid *temp;\n\n\t \n\ttemp = agp_bridge->current_size;\n\tpage_order = A_SIZE_8(temp)->page_order;\n\tnum_entries = A_SIZE_8(temp)->num_entries;\n\n\ti460.gatt = ioremap(INTEL_I460_ATTBASE, PAGE_SIZE << page_order);\n\tif (!i460.gatt) {\n\t\tprintk(KERN_ERR PFX \"ioremap failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tagp_bridge->gatt_table_real = NULL;\n\tagp_bridge->gatt_table = NULL;\n\tagp_bridge->gatt_bus_addr = 0;\n\n\tfor (i = 0; i < num_entries; ++i)\n\t\tWR_GATT(i, 0);\n\tWR_FLUSH_GATT(i - 1);\n\treturn 0;\n}\n\nstatic int i460_free_gatt_table (struct agp_bridge_data *bridge)\n{\n\tint num_entries, i;\n\tvoid *temp;\n\n\ttemp = agp_bridge->current_size;\n\n\tnum_entries = A_SIZE_8(temp)->num_entries;\n\n\tfor (i = 0; i < num_entries; ++i)\n\t\tWR_GATT(i, 0);\n\tWR_FLUSH_GATT(num_entries - 1);\n\n\tiounmap(i460.gatt);\n\treturn 0;\n}\n\n \n\nstatic int i460_insert_memory_small_io_page (struct agp_memory *mem,\n\t\t\t\toff_t pg_start, int type)\n{\n\tunsigned long paddr, io_pg_start, io_page_size;\n\tint i, j, k, num_entries;\n\tvoid *temp;\n\n\tpr_debug(\"i460_insert_memory_small_io_page(mem=%p, pg_start=%ld, type=%d, paddr0=0x%lx)\\n\",\n\t\t mem, pg_start, type, page_to_phys(mem->pages[0]));\n\n\tif (type >= AGP_USER_TYPES || mem->type >= AGP_USER_TYPES)\n\t\treturn -EINVAL;\n\n\tio_pg_start = I460_IOPAGES_PER_KPAGE * pg_start;\n\n\ttemp = agp_bridge->current_size;\n\tnum_entries = A_SIZE_8(temp)->num_entries;\n\n\tif ((io_pg_start + I460_IOPAGES_PER_KPAGE * mem->page_count) > num_entries) {\n\t\tprintk(KERN_ERR PFX \"Looks like we're out of AGP memory\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tj = io_pg_start;\n\twhile (j < (io_pg_start + I460_IOPAGES_PER_KPAGE * mem->page_count)) {\n\t\tif (!PGE_EMPTY(agp_bridge, RD_GATT(j))) {\n\t\t\tpr_debug(\"i460_insert_memory_small_io_page: GATT[%d]=0x%x is busy\\n\",\n\t\t\t\t j, RD_GATT(j));\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tj++;\n\t}\n\n\tio_page_size = 1UL << I460_IO_PAGE_SHIFT;\n\tfor (i = 0, j = io_pg_start; i < mem->page_count; i++) {\n\t\tpaddr = page_to_phys(mem->pages[i]);\n\t\tfor (k = 0; k < I460_IOPAGES_PER_KPAGE; k++, j++, paddr += io_page_size)\n\t\t\tWR_GATT(j, i460_mask_memory(agp_bridge, paddr, mem->type));\n\t}\n\tWR_FLUSH_GATT(j - 1);\n\treturn 0;\n}\n\nstatic int i460_remove_memory_small_io_page(struct agp_memory *mem,\n\t\t\t\toff_t pg_start, int type)\n{\n\tint i;\n\n\tpr_debug(\"i460_remove_memory_small_io_page(mem=%p, pg_start=%ld, type=%d)\\n\",\n\t\t mem, pg_start, type);\n\n\tpg_start = I460_IOPAGES_PER_KPAGE * pg_start;\n\n\tfor (i = pg_start; i < (pg_start + I460_IOPAGES_PER_KPAGE * mem->page_count); i++)\n\t\tWR_GATT(i, 0);\n\tWR_FLUSH_GATT(i - 1);\n\treturn 0;\n}\n\n#if I460_LARGE_IO_PAGES\n\n \n\nstatic int i460_alloc_large_page (struct lp_desc *lp)\n{\n\tunsigned long order = I460_IO_PAGE_SHIFT - PAGE_SHIFT;\n\tsize_t map_size;\n\n\tlp->page = alloc_pages(GFP_KERNEL, order);\n\tif (!lp->page) {\n\t\tprintk(KERN_ERR PFX \"Couldn't alloc 4M GART page...\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmap_size = ((I460_KPAGES_PER_IOPAGE + BITS_PER_LONG - 1) & -BITS_PER_LONG)/8;\n\tlp->alloced_map = kzalloc(map_size, GFP_KERNEL);\n\tif (!lp->alloced_map) {\n\t\t__free_pages(lp->page, order);\n\t\tprintk(KERN_ERR PFX \"Out of memory, we're in trouble...\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tlp->paddr = page_to_phys(lp->page);\n\tlp->refcount = 0;\n\tatomic_add(I460_KPAGES_PER_IOPAGE, &agp_bridge->current_memory_agp);\n\treturn 0;\n}\n\nstatic void i460_free_large_page (struct lp_desc *lp)\n{\n\tkfree(lp->alloced_map);\n\tlp->alloced_map = NULL;\n\n\t__free_pages(lp->page, I460_IO_PAGE_SHIFT - PAGE_SHIFT);\n\tatomic_sub(I460_KPAGES_PER_IOPAGE, &agp_bridge->current_memory_agp);\n}\n\nstatic int i460_insert_memory_large_io_page (struct agp_memory *mem,\n\t\t\t\toff_t pg_start, int type)\n{\n\tint i, start_offset, end_offset, idx, pg, num_entries;\n\tstruct lp_desc *start, *end, *lp;\n\tvoid *temp;\n\n\tif (type >= AGP_USER_TYPES || mem->type >= AGP_USER_TYPES)\n\t\treturn -EINVAL;\n\n\ttemp = agp_bridge->current_size;\n\tnum_entries = A_SIZE_8(temp)->num_entries;\n\n\t \n\tstart = &i460.lp_desc[pg_start / I460_KPAGES_PER_IOPAGE];\n\tend = &i460.lp_desc[(pg_start + mem->page_count - 1) / I460_KPAGES_PER_IOPAGE];\n\tstart_offset = pg_start % I460_KPAGES_PER_IOPAGE;\n\tend_offset = (pg_start + mem->page_count - 1) % I460_KPAGES_PER_IOPAGE;\n\n\tif (end > i460.lp_desc + num_entries) {\n\t\tprintk(KERN_ERR PFX \"Looks like we're out of AGP memory\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor (lp = start; lp <= end; ++lp) {\n\t\tif (!lp->alloced_map)\n\t\t\tcontinue;\t \n\n\t\tfor (idx = ((lp == start) ? start_offset : 0);\n\t\t     idx < ((lp == end) ? (end_offset + 1) : I460_KPAGES_PER_IOPAGE);\n\t\t     idx++)\n\t\t{\n\t\t\tif (test_bit(idx, lp->alloced_map))\n\t\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\tfor (lp = start, i = 0; lp <= end; ++lp) {\n\t\tif (!lp->alloced_map) {\n\t\t\t \n\t\t\tif (i460_alloc_large_page(lp) < 0)\n\t\t\t\treturn -ENOMEM;\n\t\t\tpg = lp - i460.lp_desc;\n\t\t\tWR_GATT(pg, i460_mask_memory(agp_bridge,\n\t\t\t\t\t\t     lp->paddr, 0));\n\t\t\tWR_FLUSH_GATT(pg);\n\t\t}\n\n\t\tfor (idx = ((lp == start) ? start_offset : 0);\n\t\t     idx < ((lp == end) ? (end_offset + 1) : I460_KPAGES_PER_IOPAGE);\n\t\t     idx++, i++)\n\t\t{\n\t\t\tmem->pages[i] = lp->page;\n\t\t\t__set_bit(idx, lp->alloced_map);\n\t\t\t++lp->refcount;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int i460_remove_memory_large_io_page (struct agp_memory *mem,\n\t\t\t\toff_t pg_start, int type)\n{\n\tint i, pg, start_offset, end_offset, idx, num_entries;\n\tstruct lp_desc *start, *end, *lp;\n\tvoid *temp;\n\n\ttemp = agp_bridge->current_size;\n\tnum_entries = A_SIZE_8(temp)->num_entries;\n\n\t \n\tstart = &i460.lp_desc[pg_start / I460_KPAGES_PER_IOPAGE];\n\tend = &i460.lp_desc[(pg_start + mem->page_count - 1) / I460_KPAGES_PER_IOPAGE];\n\tstart_offset = pg_start % I460_KPAGES_PER_IOPAGE;\n\tend_offset = (pg_start + mem->page_count - 1) % I460_KPAGES_PER_IOPAGE;\n\n\tfor (i = 0, lp = start; lp <= end; ++lp) {\n\t\tfor (idx = ((lp == start) ? start_offset : 0);\n\t\t     idx < ((lp == end) ? (end_offset + 1) : I460_KPAGES_PER_IOPAGE);\n\t\t     idx++, i++)\n\t\t{\n\t\t\tmem->pages[i] = NULL;\n\t\t\t__clear_bit(idx, lp->alloced_map);\n\t\t\t--lp->refcount;\n\t\t}\n\n\t\t \n\t\tif (lp->refcount == 0) {\n\t\t\tpg = lp - i460.lp_desc;\n\t\t\tWR_GATT(pg, 0);\n\t\t\tWR_FLUSH_GATT(pg);\n\t\t\ti460_free_large_page(lp);\n\t\t}\n\t}\n\treturn 0;\n}\n\n \n\nstatic int i460_insert_memory (struct agp_memory *mem,\n\t\t\t\toff_t pg_start, int type)\n{\n\tif (I460_IO_PAGE_SHIFT <= PAGE_SHIFT)\n\t\treturn i460_insert_memory_small_io_page(mem, pg_start, type);\n\telse\n\t\treturn i460_insert_memory_large_io_page(mem, pg_start, type);\n}\n\nstatic int i460_remove_memory (struct agp_memory *mem,\n\t\t\t\toff_t pg_start, int type)\n{\n\tif (I460_IO_PAGE_SHIFT <= PAGE_SHIFT)\n\t\treturn i460_remove_memory_small_io_page(mem, pg_start, type);\n\telse\n\t\treturn i460_remove_memory_large_io_page(mem, pg_start, type);\n}\n\n \nstatic struct page *i460_alloc_page (struct agp_bridge_data *bridge)\n{\n\tvoid *page;\n\n\tif (I460_IO_PAGE_SHIFT <= PAGE_SHIFT) {\n\t\tpage = agp_generic_alloc_page(agp_bridge);\n\t} else\n\t\t \n\t\t \n\t\tpage = (void *)~0UL;\n\treturn page;\n}\n\nstatic void i460_destroy_page (struct page *page, int flags)\n{\n\tif (I460_IO_PAGE_SHIFT <= PAGE_SHIFT) {\n\t\tagp_generic_destroy_page(page, flags);\n\t}\n}\n\n#endif  \n\nstatic unsigned long i460_mask_memory (struct agp_bridge_data *bridge,\n\t\t\t\t       dma_addr_t addr, int type)\n{\n\t \n\treturn bridge->driver->masks[0].mask\n\t\t| (((addr & ~((1 << I460_IO_PAGE_SHIFT) - 1)) & 0xfffff000) >> 12);\n}\n\nconst struct agp_bridge_driver intel_i460_driver = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.aperture_sizes\t\t= i460_sizes,\n\t.size_type\t\t= U8_APER_SIZE,\n\t.num_aperture_sizes\t= 3,\n\t.configure\t\t= i460_configure,\n\t.fetch_size\t\t= i460_fetch_size,\n\t.cleanup\t\t= i460_cleanup,\n\t.tlb_flush\t\t= i460_tlb_flush,\n\t.mask_memory\t\t= i460_mask_memory,\n\t.masks\t\t\t= i460_masks,\n\t.agp_enable\t\t= agp_generic_enable,\n\t.cache_flush\t\t= global_cache_flush,\n\t.create_gatt_table\t= i460_create_gatt_table,\n\t.free_gatt_table\t= i460_free_gatt_table,\n#if I460_LARGE_IO_PAGES\n\t.insert_memory\t\t= i460_insert_memory,\n\t.remove_memory\t\t= i460_remove_memory,\n\t.agp_alloc_page\t\t= i460_alloc_page,\n\t.agp_destroy_page\t= i460_destroy_page,\n#else\n\t.insert_memory\t\t= i460_insert_memory_small_io_page,\n\t.remove_memory\t\t= i460_remove_memory_small_io_page,\n\t.agp_alloc_page\t\t= agp_generic_alloc_page,\n\t.agp_alloc_pages\t= agp_generic_alloc_pages,\n\t.agp_destroy_page\t= agp_generic_destroy_page,\n\t.agp_destroy_pages\t= agp_generic_destroy_pages,\n#endif\n\t.alloc_by_type\t\t= agp_generic_alloc_by_type,\n\t.free_by_type\t\t= agp_generic_free_by_type,\n\t.agp_type_to_mask_type  = agp_generic_type_to_mask_type,\n\t.cant_use_aperture\t= true,\n};\n\nstatic int agp_intel_i460_probe(struct pci_dev *pdev,\n\t\t\t\tconst struct pci_device_id *ent)\n{\n\tstruct agp_bridge_data *bridge;\n\tu8 cap_ptr;\n\n\tcap_ptr = pci_find_capability(pdev, PCI_CAP_ID_AGP);\n\tif (!cap_ptr)\n\t\treturn -ENODEV;\n\n\tbridge = agp_alloc_bridge();\n\tif (!bridge)\n\t\treturn -ENOMEM;\n\n\tbridge->driver = &intel_i460_driver;\n\tbridge->dev = pdev;\n\tbridge->capndx = cap_ptr;\n\n\tprintk(KERN_INFO PFX \"Detected Intel 460GX chipset\\n\");\n\n\tpci_set_drvdata(pdev, bridge);\n\treturn agp_add_bridge(bridge);\n}\n\nstatic void agp_intel_i460_remove(struct pci_dev *pdev)\n{\n\tstruct agp_bridge_data *bridge = pci_get_drvdata(pdev);\n\n\tagp_remove_bridge(bridge);\n\tagp_put_bridge(bridge);\n}\n\nstatic struct pci_device_id agp_intel_i460_pci_table[] = {\n\t{\n\t.class\t\t= (PCI_CLASS_BRIDGE_HOST << 8),\n\t.class_mask\t= ~0,\n\t.vendor\t\t= PCI_VENDOR_ID_INTEL,\n\t.device\t\t= PCI_DEVICE_ID_INTEL_84460GX,\n\t.subvendor\t= PCI_ANY_ID,\n\t.subdevice\t= PCI_ANY_ID,\n\t},\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(pci, agp_intel_i460_pci_table);\n\nstatic struct pci_driver agp_intel_i460_pci_driver = {\n\t.name\t\t= \"agpgart-intel-i460\",\n\t.id_table\t= agp_intel_i460_pci_table,\n\t.probe\t\t= agp_intel_i460_probe,\n\t.remove\t\t= agp_intel_i460_remove,\n};\n\nstatic int __init agp_intel_i460_init(void)\n{\n\tif (agp_off)\n\t\treturn -EINVAL;\n\treturn pci_register_driver(&agp_intel_i460_pci_driver);\n}\n\nstatic void __exit agp_intel_i460_cleanup(void)\n{\n\tpci_unregister_driver(&agp_intel_i460_pci_driver);\n}\n\nmodule_init(agp_intel_i460_init);\nmodule_exit(agp_intel_i460_cleanup);\n\nMODULE_AUTHOR(\"Chris Ahna <Christopher.J.Ahna@intel.com>\");\nMODULE_LICENSE(\"GPL and additional rights\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}