{
  "module_name": "backend.c",
  "hash_id": "b42c2311e188f5627cf6bbf91bf47fdffc7513f0b1197cc0ca23a669c184e64c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/agp/backend.c",
  "human_readable_source": " \n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/pm.h>\n#include <linux/agp_backend.h>\n#include <linux/agpgart.h>\n#include <linux/vmalloc.h>\n#include <asm/io.h>\n#include \"agp.h\"\n\n \n#define AGPGART_VERSION_MAJOR 0\n#define AGPGART_VERSION_MINOR 103\nstatic const struct agp_version agp_current_version =\n{\n\t.major = AGPGART_VERSION_MAJOR,\n\t.minor = AGPGART_VERSION_MINOR,\n};\n\nstruct agp_bridge_data *(*agp_find_bridge)(struct pci_dev *) =\n\t&agp_generic_find_bridge;\n\nstruct agp_bridge_data *agp_bridge;\nLIST_HEAD(agp_bridges);\nEXPORT_SYMBOL(agp_bridge);\nEXPORT_SYMBOL(agp_bridges);\nEXPORT_SYMBOL(agp_find_bridge);\n\n \nstruct agp_bridge_data *agp_backend_acquire(struct pci_dev *pdev)\n{\n\tstruct agp_bridge_data *bridge;\n\n\tbridge = agp_find_bridge(pdev);\n\n\tif (!bridge)\n\t\treturn NULL;\n\n\tif (atomic_read(&bridge->agp_in_use))\n\t\treturn NULL;\n\tatomic_inc(&bridge->agp_in_use);\n\treturn bridge;\n}\nEXPORT_SYMBOL(agp_backend_acquire);\n\n\n \nvoid agp_backend_release(struct agp_bridge_data *bridge)\n{\n\n\tif (bridge)\n\t\tatomic_dec(&bridge->agp_in_use);\n}\nEXPORT_SYMBOL(agp_backend_release);\n\n\nstatic const struct { int mem, agp; } maxes_table[] = {\n\t{0, 0},\n\t{32, 4},\n\t{64, 28},\n\t{128, 96},\n\t{256, 204},\n\t{512, 440},\n\t{1024, 942},\n\t{2048, 1920},\n\t{4096, 3932}\n};\n\nstatic int agp_find_max(void)\n{\n\tlong memory, index, result;\n\n#if PAGE_SHIFT < 20\n\tmemory = totalram_pages() >> (20 - PAGE_SHIFT);\n#else\n\tmemory = totalram_pages() << (PAGE_SHIFT - 20);\n#endif\n\tindex = 1;\n\n\twhile ((memory > maxes_table[index].mem) && (index < 8))\n\t\tindex++;\n\n\tresult = maxes_table[index - 1].agp +\n\t   ( (memory - maxes_table[index - 1].mem)  *\n\t     (maxes_table[index].agp - maxes_table[index - 1].agp)) /\n\t   (maxes_table[index].mem - maxes_table[index - 1].mem);\n\n\tresult = result << (20 - PAGE_SHIFT);\n\treturn result;\n}\n\n\nstatic int agp_backend_initialize(struct agp_bridge_data *bridge)\n{\n\tint size_value, rc, got_gatt=0, got_keylist=0;\n\n\tbridge->max_memory_agp = agp_find_max();\n\tbridge->version = &agp_current_version;\n\n\tif (bridge->driver->needs_scratch_page) {\n\t\tstruct page *page = bridge->driver->agp_alloc_page(bridge);\n\n\t\tif (!page) {\n\t\t\tdev_err(&bridge->dev->dev,\n\t\t\t\t\"can't get memory for scratch page\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tbridge->scratch_page_page = page;\n\t\tbridge->scratch_page_dma = page_to_phys(page);\n\n\t\tbridge->scratch_page = bridge->driver->mask_memory(bridge,\n\t\t\t\t\t\t   bridge->scratch_page_dma, 0);\n\t}\n\n\tsize_value = bridge->driver->fetch_size();\n\tif (size_value == 0) {\n\t\tdev_err(&bridge->dev->dev, \"can't determine aperture size\\n\");\n\t\trc = -EINVAL;\n\t\tgoto err_out;\n\t}\n\tif (bridge->driver->create_gatt_table(bridge)) {\n\t\tdev_err(&bridge->dev->dev,\n\t\t\t\"can't get memory for graphics translation table\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\tgot_gatt = 1;\n\n\tbridge->key_list = vzalloc(PAGE_SIZE * 4);\n\tif (bridge->key_list == NULL) {\n\t\tdev_err(&bridge->dev->dev,\n\t\t\t\"can't allocate memory for key lists\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\tgot_keylist = 1;\n\n\t \n\n\tif (bridge->driver->configure()) {\n\t\tdev_err(&bridge->dev->dev, \"error configuring host chipset\\n\");\n\t\trc = -EINVAL;\n\t\tgoto err_out;\n\t}\n\tINIT_LIST_HEAD(&bridge->mapped_list);\n\tspin_lock_init(&bridge->mapped_lock);\n\n\treturn 0;\n\nerr_out:\n\tif (bridge->driver->needs_scratch_page) {\n\t\tstruct page *page = bridge->scratch_page_page;\n\n\t\tbridge->driver->agp_destroy_page(page, AGP_PAGE_DESTROY_UNMAP);\n\t\tbridge->driver->agp_destroy_page(page, AGP_PAGE_DESTROY_FREE);\n\t}\n\tif (got_gatt)\n\t\tbridge->driver->free_gatt_table(bridge);\n\tif (got_keylist) {\n\t\tvfree(bridge->key_list);\n\t\tbridge->key_list = NULL;\n\t}\n\treturn rc;\n}\n\n \nstatic void agp_backend_cleanup(struct agp_bridge_data *bridge)\n{\n\tif (bridge->driver->cleanup)\n\t\tbridge->driver->cleanup();\n\tif (bridge->driver->free_gatt_table)\n\t\tbridge->driver->free_gatt_table(bridge);\n\n\tvfree(bridge->key_list);\n\tbridge->key_list = NULL;\n\n\tif (bridge->driver->agp_destroy_page &&\n\t    bridge->driver->needs_scratch_page) {\n\t\tstruct page *page = bridge->scratch_page_page;\n\n\t\tbridge->driver->agp_destroy_page(page, AGP_PAGE_DESTROY_UNMAP);\n\t\tbridge->driver->agp_destroy_page(page, AGP_PAGE_DESTROY_FREE);\n\t}\n}\n\n \n\nstruct agp_bridge_data *agp_alloc_bridge(void)\n{\n\tstruct agp_bridge_data *bridge;\n\n\tbridge = kzalloc(sizeof(*bridge), GFP_KERNEL);\n\tif (!bridge)\n\t\treturn NULL;\n\n\tatomic_set(&bridge->agp_in_use, 0);\n\tatomic_set(&bridge->current_memory_agp, 0);\n\n\tif (list_empty(&agp_bridges))\n\t\tagp_bridge = bridge;\n\n\treturn bridge;\n}\nEXPORT_SYMBOL(agp_alloc_bridge);\n\n\nvoid agp_put_bridge(struct agp_bridge_data *bridge)\n{\n        kfree(bridge);\n\n        if (list_empty(&agp_bridges))\n                agp_bridge = NULL;\n}\nEXPORT_SYMBOL(agp_put_bridge);\n\n\nint agp_add_bridge(struct agp_bridge_data *bridge)\n{\n\tint error;\n\n\tif (agp_off) {\n\t\terror = -ENODEV;\n\t\tgoto err_put_bridge;\n\t}\n\n\tif (!bridge->dev) {\n\t\tprintk (KERN_DEBUG PFX \"Erk, registering with no pci_dev!\\n\");\n\t\terror = -EINVAL;\n\t\tgoto err_put_bridge;\n\t}\n\n\t \n\tif (!try_module_get(bridge->driver->owner)) {\n\t\tdev_info(&bridge->dev->dev, \"can't lock chipset driver\\n\");\n\t\terror = -EINVAL;\n\t\tgoto err_put_bridge;\n\t}\n\n\terror = agp_backend_initialize(bridge);\n\tif (error) {\n\t\tdev_info(&bridge->dev->dev,\n\t\t\t \"agp_backend_initialize() failed\\n\");\n\t\tgoto err_out;\n\t}\n\n\tif (list_empty(&agp_bridges)) {\n\t\terror = agp_frontend_initialize();\n\t\tif (error) {\n\t\t\tdev_info(&bridge->dev->dev,\n\t\t\t\t \"agp_frontend_initialize() failed\\n\");\n\t\t\tgoto frontend_err;\n\t\t}\n\n\t\tdev_info(&bridge->dev->dev, \"AGP aperture is %dM @ 0x%lx\\n\",\n\t\t\t bridge->driver->fetch_size(), bridge->gart_bus_addr);\n\n\t}\n\n\tlist_add(&bridge->list, &agp_bridges);\n\treturn 0;\n\nfrontend_err:\n\tagp_backend_cleanup(bridge);\nerr_out:\n\tmodule_put(bridge->driver->owner);\nerr_put_bridge:\n\tagp_put_bridge(bridge);\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(agp_add_bridge);\n\n\nvoid agp_remove_bridge(struct agp_bridge_data *bridge)\n{\n\tagp_backend_cleanup(bridge);\n\tlist_del(&bridge->list);\n\tif (list_empty(&agp_bridges))\n\t\tagp_frontend_cleanup();\n\tmodule_put(bridge->driver->owner);\n}\nEXPORT_SYMBOL_GPL(agp_remove_bridge);\n\nint agp_off;\nint agp_try_unsupported_boot;\nEXPORT_SYMBOL(agp_off);\nEXPORT_SYMBOL(agp_try_unsupported_boot);\n\nstatic int __init agp_init(void)\n{\n\tif (!agp_off)\n\t\tprintk(KERN_INFO \"Linux agpgart interface v%d.%d\\n\",\n\t\t\tAGPGART_VERSION_MAJOR, AGPGART_VERSION_MINOR);\n\treturn 0;\n}\n\nstatic void __exit agp_exit(void)\n{\n}\n\n#ifndef MODULE\nstatic __init int agp_setup(char *s)\n{\n\tif (!strcmp(s,\"off\"))\n\t\tagp_off = 1;\n\tif (!strcmp(s,\"try_unsupported\"))\n\t\tagp_try_unsupported_boot = 1;\n\treturn 1;\n}\n__setup(\"agp=\", agp_setup);\n#endif\n\nMODULE_AUTHOR(\"Dave Jones, Jeff Hartmann\");\nMODULE_DESCRIPTION(\"AGP GART driver\");\nMODULE_LICENSE(\"GPL and additional rights\");\nMODULE_ALIAS_MISCDEV(AGPGART_MINOR);\n\nmodule_init(agp_init);\nmodule_exit(agp_exit);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}