{
  "module_name": "via-agp.c",
  "hash_id": "380376fa71085d785820a0f6c7e4bc9cdb79cc60f66657a0c95d753a42a3c514",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/agp/via-agp.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/init.h>\n#include <linux/agp_backend.h>\n#include \"agp.h\"\n\nstatic const struct pci_device_id agp_via_pci_table[];\n\n#define VIA_GARTCTRL\t0x80\n#define VIA_APSIZE\t0x84\n#define VIA_ATTBASE\t0x88\n\n#define VIA_AGP3_GARTCTRL\t0x90\n#define VIA_AGP3_APSIZE\t\t0x94\n#define VIA_AGP3_ATTBASE\t0x98\n#define VIA_AGPSEL\t\t0xfd\n\nstatic int via_fetch_size(void)\n{\n\tint i;\n\tu8 temp;\n\tstruct aper_size_info_8 *values;\n\n\tvalues = A_SIZE_8(agp_bridge->driver->aperture_sizes);\n\tpci_read_config_byte(agp_bridge->dev, VIA_APSIZE, &temp);\n\tfor (i = 0; i < agp_bridge->driver->num_aperture_sizes; i++) {\n\t\tif (temp == values[i].size_value) {\n\t\t\tagp_bridge->previous_size =\n\t\t\t    agp_bridge->current_size = (void *) (values + i);\n\t\t\tagp_bridge->aperture_size_idx = i;\n\t\t\treturn values[i].size;\n\t\t}\n\t}\n\tprintk(KERN_ERR PFX \"Unknown aperture size from AGP bridge (0x%x)\\n\", temp);\n\treturn 0;\n}\n\n\nstatic int via_configure(void)\n{\n\tstruct aper_size_info_8 *current_size;\n\n\tcurrent_size = A_SIZE_8(agp_bridge->current_size);\n\t \n\tpci_write_config_byte(agp_bridge->dev, VIA_APSIZE,\n\t\t\t      current_size->size_value);\n\t \n\tagp_bridge->gart_bus_addr = pci_bus_address(agp_bridge->dev,\n\t\t\t\t\t\t    AGP_APERTURE_BAR);\n\n\t \n\tpci_write_config_dword(agp_bridge->dev, VIA_GARTCTRL, 0x0000000f);\n\n\t \n\tpci_write_config_dword(agp_bridge->dev, VIA_ATTBASE,\n\t\t\t    (agp_bridge->gatt_bus_addr & 0xfffff000) | 3);\n\treturn 0;\n}\n\n\nstatic void via_cleanup(void)\n{\n\tstruct aper_size_info_8 *previous_size;\n\n\tprevious_size = A_SIZE_8(agp_bridge->previous_size);\n\tpci_write_config_byte(agp_bridge->dev, VIA_APSIZE,\n\t\t\t      previous_size->size_value);\n\t \n}\n\n\nstatic void via_tlbflush(struct agp_memory *mem)\n{\n\tu32 temp;\n\n\tpci_read_config_dword(agp_bridge->dev, VIA_GARTCTRL, &temp);\n\ttemp |= (1<<7);\n\tpci_write_config_dword(agp_bridge->dev, VIA_GARTCTRL, temp);\n\ttemp &= ~(1<<7);\n\tpci_write_config_dword(agp_bridge->dev, VIA_GARTCTRL, temp);\n}\n\n\nstatic const struct aper_size_info_8 via_generic_sizes[9] =\n{\n\t{256, 65536, 6, 0},\n\t{128, 32768, 5, 128},\n\t{64, 16384, 4, 192},\n\t{32, 8192, 3, 224},\n\t{16, 4096, 2, 240},\n\t{8, 2048, 1, 248},\n\t{4, 1024, 0, 252},\n\t{2, 512, 0, 254},\n\t{1, 256, 0, 255}\n};\n\n\nstatic int via_fetch_size_agp3(void)\n{\n\tint i;\n\tu16 temp;\n\tstruct aper_size_info_16 *values;\n\n\tvalues = A_SIZE_16(agp_bridge->driver->aperture_sizes);\n\tpci_read_config_word(agp_bridge->dev, VIA_AGP3_APSIZE, &temp);\n\ttemp &= 0xfff;\n\n\tfor (i = 0; i < agp_bridge->driver->num_aperture_sizes; i++) {\n\t\tif (temp == values[i].size_value) {\n\t\t\tagp_bridge->previous_size =\n\t\t\t\tagp_bridge->current_size = (void *) (values + i);\n\t\t\tagp_bridge->aperture_size_idx = i;\n\t\t\treturn values[i].size;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nstatic int via_configure_agp3(void)\n{\n\tu32 temp;\n\n\t \n\tagp_bridge->gart_bus_addr = pci_bus_address(agp_bridge->dev,\n\t\t\t\t\t\t    AGP_APERTURE_BAR);\n\n\t \n\tpci_write_config_dword(agp_bridge->dev, VIA_AGP3_ATTBASE,\n\t\tagp_bridge->gatt_bus_addr & 0xfffff000);\n\n\t \n\tpci_read_config_dword(agp_bridge->dev, VIA_AGP3_GARTCTRL, &temp);\n\tpci_write_config_dword(agp_bridge->dev, VIA_AGP3_GARTCTRL, temp | (3<<7));\n\treturn 0;\n}\n\n\nstatic void via_cleanup_agp3(void)\n{\n\tstruct aper_size_info_16 *previous_size;\n\n\tprevious_size = A_SIZE_16(agp_bridge->previous_size);\n\tpci_write_config_byte(agp_bridge->dev, VIA_APSIZE, previous_size->size_value);\n}\n\n\nstatic void via_tlbflush_agp3(struct agp_memory *mem)\n{\n\tu32 temp;\n\n\tpci_read_config_dword(agp_bridge->dev, VIA_AGP3_GARTCTRL, &temp);\n\tpci_write_config_dword(agp_bridge->dev, VIA_AGP3_GARTCTRL, temp & ~(1<<7));\n\tpci_write_config_dword(agp_bridge->dev, VIA_AGP3_GARTCTRL, temp);\n}\n\n\nstatic const struct agp_bridge_driver via_agp3_driver = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.aperture_sizes\t\t= agp3_generic_sizes,\n\t.size_type\t\t= U8_APER_SIZE,\n\t.num_aperture_sizes\t= 10,\n\t.needs_scratch_page\t= true,\n\t.configure\t\t= via_configure_agp3,\n\t.fetch_size\t\t= via_fetch_size_agp3,\n\t.cleanup\t\t= via_cleanup_agp3,\n\t.tlb_flush\t\t= via_tlbflush_agp3,\n\t.mask_memory\t\t= agp_generic_mask_memory,\n\t.masks\t\t\t= NULL,\n\t.agp_enable\t\t= agp_generic_enable,\n\t.cache_flush\t\t= global_cache_flush,\n\t.create_gatt_table\t= agp_generic_create_gatt_table,\n\t.free_gatt_table\t= agp_generic_free_gatt_table,\n\t.insert_memory\t\t= agp_generic_insert_memory,\n\t.remove_memory\t\t= agp_generic_remove_memory,\n\t.alloc_by_type\t\t= agp_generic_alloc_by_type,\n\t.free_by_type\t\t= agp_generic_free_by_type,\n\t.agp_alloc_page\t\t= agp_generic_alloc_page,\n\t.agp_alloc_pages\t= agp_generic_alloc_pages,\n\t.agp_destroy_page\t= agp_generic_destroy_page,\n\t.agp_destroy_pages\t= agp_generic_destroy_pages,\n\t.agp_type_to_mask_type  = agp_generic_type_to_mask_type,\n};\n\nstatic const struct agp_bridge_driver via_driver = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.aperture_sizes\t\t= via_generic_sizes,\n\t.size_type\t\t= U8_APER_SIZE,\n\t.num_aperture_sizes\t= 9,\n\t.needs_scratch_page\t= true,\n\t.configure\t\t= via_configure,\n\t.fetch_size\t\t= via_fetch_size,\n\t.cleanup\t\t= via_cleanup,\n\t.tlb_flush\t\t= via_tlbflush,\n\t.mask_memory\t\t= agp_generic_mask_memory,\n\t.masks\t\t\t= NULL,\n\t.agp_enable\t\t= agp_generic_enable,\n\t.cache_flush\t\t= global_cache_flush,\n\t.create_gatt_table\t= agp_generic_create_gatt_table,\n\t.free_gatt_table\t= agp_generic_free_gatt_table,\n\t.insert_memory\t\t= agp_generic_insert_memory,\n\t.remove_memory\t\t= agp_generic_remove_memory,\n\t.alloc_by_type\t\t= agp_generic_alloc_by_type,\n\t.free_by_type\t\t= agp_generic_free_by_type,\n\t.agp_alloc_page\t\t= agp_generic_alloc_page,\n\t.agp_alloc_pages\t= agp_generic_alloc_pages,\n\t.agp_destroy_page\t= agp_generic_destroy_page,\n\t.agp_destroy_pages\t= agp_generic_destroy_pages,\n\t.agp_type_to_mask_type  = agp_generic_type_to_mask_type,\n};\n\nstatic struct agp_device_ids via_agp_device_ids[] =\n{\n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_VIA_82C597_0,\n\t\t.chipset_name\t= \"Apollo VP3\",\n\t},\n\n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_VIA_82C598_0,\n\t\t.chipset_name\t= \"Apollo MVP3\",\n\t},\n\n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_VIA_8501_0,\n\t\t.chipset_name\t= \"Apollo MVP4\",\n\t},\n\n\t \n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_VIA_8601_0,\n\t\t.chipset_name\t= \"Apollo ProMedia/PLE133Ta\",\n\t},\n\n\t \n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_VIA_82C691_0,\n\t\t.chipset_name\t= \"Apollo Pro 133\",\n\t},\n\n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_VIA_8371_0,\n\t\t.chipset_name\t= \"KX133\",\n\t},\n\n\t \n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_VIA_8633_0,\n\t\t.chipset_name\t= \"Pro 266\",\n\t},\n\n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_VIA_XN266,\n\t\t.chipset_name\t= \"Apollo Pro266\",\n\t},\n\n\t \n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_VIA_8361,\n\t\t.chipset_name\t= \"KLE133\",\n\t},\n\n\t \n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_VIA_8363_0,\n\t\t.chipset_name\t= \"Twister-K/KT133x/KM133\",\n\t},\n\n\t \n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_VIA_8753_0,\n\t\t.chipset_name\t= \"P4X266\",\n\t},\n\n\t \n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_VIA_8367_0,\n\t\t.chipset_name\t= \"KT266/KY266x/KT333\",\n\t},\n\n\t \n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_VIA_8653_0,\n\t\t.chipset_name\t= \"Pro266T\",\n\t},\n\n\t \n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_VIA_XM266,\n\t\t.chipset_name\t= \"PM266/KM266\",\n\t},\n\n\t \n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_VIA_862X_0,\n\t\t.chipset_name\t= \"CLE266\",\n\t},\n\n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_VIA_8377_0,\n\t\t.chipset_name\t= \"KT400/KT400A/KT600\",\n\t},\n\n\t \n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_VIA_8605_0,\n\t\t.chipset_name\t= \"ProSavage PM133/PL133/PN133\"\n\t},\n\n\t \n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_VIA_8703_51_0,\n\t\t.chipset_name\t= \"P4M266x/P4N266\",\n\t},\n\n\t \n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_VIA_8754C_0,\n\t\t.chipset_name\t= \"PT800\",\n\t},\n\n\t \n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_VIA_8763_0,\n\t\t.chipset_name\t= \"P4X600\"\n\t},\n\n\t \n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_VIA_8378_0,\n\t\t.chipset_name\t= \"KM400/KM400A\",\n\t},\n\n\t \n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_VIA_PT880,\n\t\t.chipset_name\t= \"PT880\",\n\t},\n\n\t \n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_VIA_PT880ULTRA,\n\t\t.chipset_name\t= \"PT880 Ultra\",\n\t},\n\n\t \n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_VIA_8783_0,\n\t\t.chipset_name\t= \"PT890\",\n\t},\n\n\t \n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_VIA_PX8X0_0,\n\t\t.chipset_name\t= \"PM800/PN800/PM880/PN880\",\n\t},\n\t \n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_VIA_3269_0,\n\t\t.chipset_name\t= \"KT880\",\n\t},\n\t \n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_VIA_83_87XX_1,\n\t\t.chipset_name\t= \"VT83xx/VT87xx/KTxxx/Px8xx\",\n\t},\n\t \n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_VIA_3296_0,\n\t\t.chipset_name\t= \"P4M800\",\n\t},\n\t \n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_VIA_P4M800CE,\n\t\t.chipset_name\t= \"VT3314\",\n\t},\n\t \n\t{\n\t\t.device_id  = PCI_DEVICE_ID_VIA_VT3324,\n\t\t.chipset_name   = \"CX700\",\n\t},\n\t \n#if 0\n\t{\n\t\t.device_id  = PCI_DEVICE_ID_VIA_VT3336,\n\t\t.chipset_name   = \"VT3336\",\n\t},\n#endif\n\t \n\t{\n\t\t.device_id  = PCI_DEVICE_ID_VIA_P4M890,\n\t\t.chipset_name   = \"P4M890\",\n\t},\n\t \n\t{\n\t\t.device_id  = PCI_DEVICE_ID_VIA_VT3364,\n\t\t.chipset_name   = \"P4M900\",\n\t},\n\t{ },  \n};\n\n\n \nstatic void check_via_agp3 (struct agp_bridge_data *bridge)\n{\n\tu8 reg;\n\n\tpci_read_config_byte(bridge->dev, VIA_AGPSEL, &reg);\n\t \n\tif ((reg & (1<<1))==0)\n\t\tbridge->driver = &via_agp3_driver;\n}\n\n\nstatic int agp_via_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct agp_device_ids *devs = via_agp_device_ids;\n\tstruct agp_bridge_data *bridge;\n\tint j = 0;\n\tu8 cap_ptr;\n\n\tcap_ptr = pci_find_capability(pdev, PCI_CAP_ID_AGP);\n\tif (!cap_ptr)\n\t\treturn -ENODEV;\n\n\tj = ent - agp_via_pci_table;\n\tprintk (KERN_INFO PFX \"Detected VIA %s chipset\\n\", devs[j].chipset_name);\n\n\tbridge = agp_alloc_bridge();\n\tif (!bridge)\n\t\treturn -ENOMEM;\n\n\tbridge->dev = pdev;\n\tbridge->capndx = cap_ptr;\n\tbridge->driver = &via_driver;\n\n\t \n\tif (pdev->device == PCI_DEVICE_ID_VIA_8367_0) {\n\t\t \n\t\tif (pdev->subsystem_device == PCI_DEVICE_ID_VIA_8377_0) {\n\t\t\tprintk(KERN_INFO PFX \"Found KT400 in disguise as a KT266.\\n\");\n\t\t\tcheck_via_agp3(bridge);\n\t\t}\n\t}\n\n\t \n\tget_agp_version(bridge);\n\tif (bridge->major_version >= 3)\n\t\tcheck_via_agp3(bridge);\n\n\t \n\tpci_read_config_dword(pdev,\n\t\t\tbridge->capndx+PCI_AGP_STATUS, &bridge->mode);\n\n\tpci_set_drvdata(pdev, bridge);\n\treturn agp_add_bridge(bridge);\n}\n\nstatic void agp_via_remove(struct pci_dev *pdev)\n{\n\tstruct agp_bridge_data *bridge = pci_get_drvdata(pdev);\n\n\tagp_remove_bridge(bridge);\n\tagp_put_bridge(bridge);\n}\n\nstatic int agp_via_resume(struct device *dev)\n{\n\tstruct agp_bridge_data *bridge = dev_get_drvdata(dev);\n\n\tif (bridge->driver == &via_agp3_driver)\n\t\treturn via_configure_agp3();\n\telse if (bridge->driver == &via_driver)\n\t\treturn via_configure();\n\n\treturn 0;\n}\n\n \nstatic const struct pci_device_id agp_via_pci_table[] = {\n#define ID(x) \\\n\t{\t\t\t\t\t\t\\\n\t.class\t\t= (PCI_CLASS_BRIDGE_HOST << 8),\t\\\n\t.class_mask\t= ~0,\t\t\t\t\\\n\t.vendor\t\t= PCI_VENDOR_ID_VIA,\t\t\\\n\t.device\t\t= x,\t\t\t\t\\\n\t.subvendor\t= PCI_ANY_ID,\t\t\t\\\n\t.subdevice\t= PCI_ANY_ID,\t\t\t\\\n\t}\n\tID(PCI_DEVICE_ID_VIA_82C597_0),\n\tID(PCI_DEVICE_ID_VIA_82C598_0),\n\tID(PCI_DEVICE_ID_VIA_8501_0),\n\tID(PCI_DEVICE_ID_VIA_8601_0),\n\tID(PCI_DEVICE_ID_VIA_82C691_0),\n\tID(PCI_DEVICE_ID_VIA_8371_0),\n\tID(PCI_DEVICE_ID_VIA_8633_0),\n\tID(PCI_DEVICE_ID_VIA_XN266),\n\tID(PCI_DEVICE_ID_VIA_8361),\n\tID(PCI_DEVICE_ID_VIA_8363_0),\n\tID(PCI_DEVICE_ID_VIA_8753_0),\n\tID(PCI_DEVICE_ID_VIA_8367_0),\n\tID(PCI_DEVICE_ID_VIA_8653_0),\n\tID(PCI_DEVICE_ID_VIA_XM266),\n\tID(PCI_DEVICE_ID_VIA_862X_0),\n\tID(PCI_DEVICE_ID_VIA_8377_0),\n\tID(PCI_DEVICE_ID_VIA_8605_0),\n\tID(PCI_DEVICE_ID_VIA_8703_51_0),\n\tID(PCI_DEVICE_ID_VIA_8754C_0),\n\tID(PCI_DEVICE_ID_VIA_8763_0),\n\tID(PCI_DEVICE_ID_VIA_8378_0),\n\tID(PCI_DEVICE_ID_VIA_PT880),\n\tID(PCI_DEVICE_ID_VIA_PT880ULTRA),\n\tID(PCI_DEVICE_ID_VIA_8783_0),\n\tID(PCI_DEVICE_ID_VIA_PX8X0_0),\n\tID(PCI_DEVICE_ID_VIA_3269_0),\n\tID(PCI_DEVICE_ID_VIA_83_87XX_1),\n\tID(PCI_DEVICE_ID_VIA_3296_0),\n\tID(PCI_DEVICE_ID_VIA_P4M800CE),\n\tID(PCI_DEVICE_ID_VIA_VT3324),\n\tID(PCI_DEVICE_ID_VIA_P4M890),\n\tID(PCI_DEVICE_ID_VIA_VT3364),\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(pci, agp_via_pci_table);\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(agp_via_pm_ops, NULL, agp_via_resume);\n\nstatic struct pci_driver agp_via_pci_driver = {\n\t.name\t\t= \"agpgart-via\",\n\t.id_table\t= agp_via_pci_table,\n\t.probe\t\t= agp_via_probe,\n\t.remove\t\t= agp_via_remove,\n\t.driver.pm      = &agp_via_pm_ops,\n};\n\n\nstatic int __init agp_via_init(void)\n{\n\tif (agp_off)\n\t\treturn -EINVAL;\n\treturn pci_register_driver(&agp_via_pci_driver);\n}\n\nstatic void __exit agp_via_cleanup(void)\n{\n\tpci_unregister_driver(&agp_via_pci_driver);\n}\n\nmodule_init(agp_via_init);\nmodule_exit(agp_via_cleanup);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Dave Jones\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}