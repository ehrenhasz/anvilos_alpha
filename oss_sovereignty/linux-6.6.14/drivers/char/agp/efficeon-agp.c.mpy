{
  "module_name": "efficeon-agp.c",
  "hash_id": "d7d0bb3a39519862bd03f8576ad089ac32bf87cd1e50ce31f5261c9478198221",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/agp/efficeon-agp.c",
  "human_readable_source": " \n\n \n\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/init.h>\n#include <linux/agp_backend.h>\n#include <linux/gfp.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include \"agp.h\"\n#include \"intel-agp.h\"\n\n \n#define EFFICEON_ATTPAGE\t0xb8\n#define EFFICEON_L1_SIZE\t64\t \n\n#define EFFICEON_PATI\t\t(0 << 9)\n#define EFFICEON_PRESENT\t(1 << 8)\n\nstatic struct _efficeon_private {\n\tunsigned long l1_table[EFFICEON_L1_SIZE];\n} efficeon_private;\n\nstatic const struct gatt_mask efficeon_generic_masks[] =\n{\n\t{.mask = 0x00000001, .type = 0}\n};\n\n \nstatic inline unsigned long efficeon_mask_memory(struct page *page)\n{\n\tunsigned long addr = page_to_phys(page);\n\treturn addr | 0x00000001;\n}\n\nstatic const struct aper_size_info_lvl2 efficeon_generic_sizes[4] =\n{\n\t{256, 65536, 0},\n\t{128, 32768, 32},\n\t{64, 16384, 48},\n\t{32, 8192, 56}\n};\n\n \n\nstatic int efficeon_fetch_size(void)\n{\n\tint i;\n\tu16 temp;\n\tstruct aper_size_info_lvl2 *values;\n\n\tpci_read_config_word(agp_bridge->dev, INTEL_APSIZE, &temp);\n\tvalues = A_SIZE_LVL2(agp_bridge->driver->aperture_sizes);\n\n\tfor (i = 0; i < agp_bridge->driver->num_aperture_sizes; i++) {\n\t\tif (temp == values[i].size_value) {\n\t\t\tagp_bridge->previous_size =\n\t\t\t    agp_bridge->current_size = (void *) (values + i);\n\t\t\tagp_bridge->aperture_size_idx = i;\n\t\t\treturn values[i].size;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void efficeon_tlbflush(struct agp_memory * mem)\n{\n\tprintk(KERN_DEBUG PFX \"efficeon_tlbflush()\\n\");\n\tpci_write_config_dword(agp_bridge->dev, INTEL_AGPCTRL, 0x2200);\n\tpci_write_config_dword(agp_bridge->dev, INTEL_AGPCTRL, 0x2280);\n}\n\nstatic void efficeon_cleanup(void)\n{\n\tu16 temp;\n\tstruct aper_size_info_lvl2 *previous_size;\n\n\tprintk(KERN_DEBUG PFX \"efficeon_cleanup()\\n\");\n\tprevious_size = A_SIZE_LVL2(agp_bridge->previous_size);\n\tpci_read_config_word(agp_bridge->dev, INTEL_NBXCFG, &temp);\n\tpci_write_config_word(agp_bridge->dev, INTEL_NBXCFG, temp & ~(1 << 9));\n\tpci_write_config_word(agp_bridge->dev, INTEL_APSIZE,\n\t\t\t      previous_size->size_value);\n}\n\nstatic int efficeon_configure(void)\n{\n\tu16 temp2;\n\tstruct aper_size_info_lvl2 *current_size;\n\n\tprintk(KERN_DEBUG PFX \"efficeon_configure()\\n\");\n\n\tcurrent_size = A_SIZE_LVL2(agp_bridge->current_size);\n\n\t \n\tpci_write_config_word(agp_bridge->dev, INTEL_APSIZE,\n\t\t\t      current_size->size_value);\n\n\t \n\tagp_bridge->gart_bus_addr = pci_bus_address(agp_bridge->dev,\n\t\t\t\t\t\t    AGP_APERTURE_BAR);\n\n\t \n\tpci_write_config_dword(agp_bridge->dev, INTEL_AGPCTRL, 0x2280);\n\n\t \n\tpci_read_config_word(agp_bridge->dev, INTEL_NBXCFG, &temp2);\n\tpci_write_config_word(agp_bridge->dev, INTEL_NBXCFG,\n\t\t\t      (temp2 & ~(1 << 10)) | (1 << 9) | (1 << 11));\n\t \n\tpci_write_config_byte(agp_bridge->dev, INTEL_ERRSTS + 1, 7);\n\treturn 0;\n}\n\nstatic int efficeon_free_gatt_table(struct agp_bridge_data *bridge)\n{\n\tint index, freed = 0;\n\n\tfor (index = 0; index < EFFICEON_L1_SIZE; index++) {\n\t\tunsigned long page = efficeon_private.l1_table[index];\n\t\tif (page) {\n\t\t\tefficeon_private.l1_table[index] = 0;\n\t\t\tfree_page(page);\n\t\t\tfreed++;\n\t\t}\n\t\tprintk(KERN_DEBUG PFX \"efficeon_free_gatt_table(%p, %02x, %08x)\\n\",\n\t\t\tagp_bridge->dev, EFFICEON_ATTPAGE, index);\n\t\tpci_write_config_dword(agp_bridge->dev,\n\t\t\tEFFICEON_ATTPAGE, index);\n\t}\n\tprintk(KERN_DEBUG PFX \"efficeon_free_gatt_table() freed %d pages\\n\", freed);\n\treturn 0;\n}\n\n\n \n\n#define GET_PAGE_DIR_OFF(addr) (addr >> 22)\n#define GET_PAGE_DIR_IDX(addr) (GET_PAGE_DIR_OFF(addr) - \\\n\tGET_PAGE_DIR_OFF(agp_bridge->gart_bus_addr))\n#define GET_GATT_OFF(addr) ((addr & 0x003ff000) >> 12)\n#undef  GET_GATT\n#define GET_GATT(addr) (efficeon_private.gatt_pages[\\\n\tGET_PAGE_DIR_IDX(addr)]->remapped)\n\nstatic int efficeon_create_gatt_table(struct agp_bridge_data *bridge)\n{\n\tint index;\n\tconst int pati    = EFFICEON_PATI;\n\tconst int present = EFFICEON_PRESENT;\n\tconst int clflush_chunk = ((cpuid_ebx(1) >> 8) & 0xff) << 3;\n\tint num_entries, l1_pages;\n\n\tnum_entries = A_SIZE_LVL2(agp_bridge->current_size)->num_entries;\n\n\tprintk(KERN_DEBUG PFX \"efficeon_create_gatt_table(%d)\\n\", num_entries);\n\n\t \n\tBUG_ON(num_entries & 0x3ff);\n\tl1_pages = num_entries >> 10;\n\n\tfor (index = 0 ; index < l1_pages ; index++) {\n\t\tint offset;\n\t\tunsigned long page;\n\t\tunsigned long value;\n\n\t\tpage = efficeon_private.l1_table[index];\n\t\tBUG_ON(page);\n\n\t\tpage = get_zeroed_page(GFP_KERNEL);\n\t\tif (!page) {\n\t\t\tefficeon_free_gatt_table(agp_bridge);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tfor (offset = 0; offset < PAGE_SIZE; offset += clflush_chunk)\n\t\t\tclflush((char *)page+offset);\n\n\t\tefficeon_private.l1_table[index] = page;\n\n\t\tvalue = virt_to_phys((unsigned long *)page) | pati | present | index;\n\n\t\tpci_write_config_dword(agp_bridge->dev,\n\t\t\tEFFICEON_ATTPAGE, value);\n\t}\n\n\treturn 0;\n}\n\nstatic int efficeon_insert_memory(struct agp_memory * mem, off_t pg_start, int type)\n{\n\tint i, count = mem->page_count, num_entries;\n\tunsigned int *page, *last_page;\n\tconst int clflush_chunk = ((cpuid_ebx(1) >> 8) & 0xff) << 3;\n\tconst unsigned long clflush_mask = ~(clflush_chunk-1);\n\n\tprintk(KERN_DEBUG PFX \"efficeon_insert_memory(%lx, %d)\\n\", pg_start, count);\n\n\tnum_entries = A_SIZE_LVL2(agp_bridge->current_size)->num_entries;\n\tif ((pg_start + mem->page_count) > num_entries)\n\t\treturn -EINVAL;\n\tif (type != 0 || mem->type != 0)\n\t\treturn -EINVAL;\n\n\tif (!mem->is_flushed) {\n\t\tglobal_cache_flush();\n\t\tmem->is_flushed = true;\n\t}\n\n\tlast_page = NULL;\n\tfor (i = 0; i < count; i++) {\n\t\tint index = pg_start + i;\n\t\tunsigned long insert = efficeon_mask_memory(mem->pages[i]);\n\n\t\tpage = (unsigned int *) efficeon_private.l1_table[index >> 10];\n\n\t\tif (!page)\n\t\t\tcontinue;\n\n\t\tpage += (index & 0x3ff);\n\t\t*page = insert;\n\n\t\t \n\t\tif (last_page &&\n\t\t    (((unsigned long)page^(unsigned long)last_page) &\n\t\t     clflush_mask))\n\t\t\tclflush(last_page);\n\n\t\tlast_page = page;\n\t}\n\n\tif ( last_page )\n\t\tclflush(last_page);\n\n\tagp_bridge->driver->tlb_flush(mem);\n\treturn 0;\n}\n\nstatic int efficeon_remove_memory(struct agp_memory * mem, off_t pg_start, int type)\n{\n\tint i, count = mem->page_count, num_entries;\n\n\tprintk(KERN_DEBUG PFX \"efficeon_remove_memory(%lx, %d)\\n\", pg_start, count);\n\n\tnum_entries = A_SIZE_LVL2(agp_bridge->current_size)->num_entries;\n\n\tif ((pg_start + mem->page_count) > num_entries)\n\t\treturn -EINVAL;\n\tif (type != 0 || mem->type != 0)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < count; i++) {\n\t\tint index = pg_start + i;\n\t\tunsigned int *page = (unsigned int *) efficeon_private.l1_table[index >> 10];\n\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tpage += (index & 0x3ff);\n\t\t*page = 0;\n\t}\n\tagp_bridge->driver->tlb_flush(mem);\n\treturn 0;\n}\n\n\nstatic const struct agp_bridge_driver efficeon_driver = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.aperture_sizes\t\t= efficeon_generic_sizes,\n\t.size_type\t\t= LVL2_APER_SIZE,\n\t.num_aperture_sizes\t= 4,\n\t.configure\t\t= efficeon_configure,\n\t.fetch_size\t\t= efficeon_fetch_size,\n\t.cleanup\t\t= efficeon_cleanup,\n\t.tlb_flush\t\t= efficeon_tlbflush,\n\t.mask_memory\t\t= agp_generic_mask_memory,\n\t.masks\t\t\t= efficeon_generic_masks,\n\t.agp_enable\t\t= agp_generic_enable,\n\t.cache_flush\t\t= global_cache_flush,\n\n\t\n\t.create_gatt_table\t= efficeon_create_gatt_table,\n\t.free_gatt_table\t= efficeon_free_gatt_table,\n\t.insert_memory\t\t= efficeon_insert_memory,\n\t.remove_memory\t\t= efficeon_remove_memory,\n\t.cant_use_aperture\t= false,\t\n\n\t\n\t.alloc_by_type\t\t= agp_generic_alloc_by_type,\n\t.free_by_type\t\t= agp_generic_free_by_type,\n\t.agp_alloc_page\t\t= agp_generic_alloc_page,\n\t.agp_alloc_pages\t= agp_generic_alloc_pages,\n\t.agp_destroy_page\t= agp_generic_destroy_page,\n\t.agp_destroy_pages\t= agp_generic_destroy_pages,\n\t.agp_type_to_mask_type  = agp_generic_type_to_mask_type,\n};\n\nstatic int agp_efficeon_probe(struct pci_dev *pdev,\n\t\t\t      const struct pci_device_id *ent)\n{\n\tstruct agp_bridge_data *bridge;\n\tu8 cap_ptr;\n\tstruct resource *r;\n\n\tcap_ptr = pci_find_capability(pdev, PCI_CAP_ID_AGP);\n\tif (!cap_ptr)\n\t\treturn -ENODEV;\n\n\t \n\tif (pdev->device != PCI_DEVICE_ID_EFFICEON) {\n\t\tprintk(KERN_ERR PFX \"Unsupported Efficeon chipset (device id: %04x)\\n\",\n\t\t    pdev->device);\n\t\treturn -ENODEV;\n\t}\n\n\tprintk(KERN_INFO PFX \"Detected Transmeta Efficeon TM8000 series chipset\\n\");\n\n\tbridge = agp_alloc_bridge();\n\tif (!bridge)\n\t\treturn -ENOMEM;\n\n\tbridge->driver = &efficeon_driver;\n\tbridge->dev = pdev;\n\tbridge->capndx = cap_ptr;\n\n\t \n\tif (pci_enable_device(pdev)) {\n\t\tprintk(KERN_ERR PFX \"Unable to Enable PCI device\\n\");\n\t\tagp_put_bridge(bridge);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tr = &pdev->resource[0];\n\tif (!r->start && r->end) {\n\t\tif (pci_assign_resource(pdev, 0)) {\n\t\t\tprintk(KERN_ERR PFX \"could not assign resource 0\\n\");\n\t\t\tagp_put_bridge(bridge);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\t \n\tif (cap_ptr) {\n\t\tpci_read_config_dword(pdev,\n\t\t\t\tbridge->capndx+PCI_AGP_STATUS,\n\t\t\t\t&bridge->mode);\n\t}\n\n\tpci_set_drvdata(pdev, bridge);\n\treturn agp_add_bridge(bridge);\n}\n\nstatic void agp_efficeon_remove(struct pci_dev *pdev)\n{\n\tstruct agp_bridge_data *bridge = pci_get_drvdata(pdev);\n\n\tagp_remove_bridge(bridge);\n\tagp_put_bridge(bridge);\n}\n\nstatic int agp_efficeon_resume(struct device *dev)\n{\n\tprintk(KERN_DEBUG PFX \"agp_efficeon_resume()\\n\");\n\treturn efficeon_configure();\n}\n\nstatic const struct pci_device_id agp_efficeon_pci_table[] = {\n\t{\n\t.class\t\t= (PCI_CLASS_BRIDGE_HOST << 8),\n\t.class_mask\t= ~0,\n\t.vendor\t\t= PCI_VENDOR_ID_TRANSMETA,\n\t.device\t\t= PCI_ANY_ID,\n\t.subvendor\t= PCI_ANY_ID,\n\t.subdevice\t= PCI_ANY_ID,\n\t},\n\t{ }\n};\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(agp_efficeon_pm_ops, NULL, agp_efficeon_resume);\n\nMODULE_DEVICE_TABLE(pci, agp_efficeon_pci_table);\n\nstatic struct pci_driver agp_efficeon_pci_driver = {\n\t.name\t\t= \"agpgart-efficeon\",\n\t.id_table\t= agp_efficeon_pci_table,\n\t.probe\t\t= agp_efficeon_probe,\n\t.remove\t\t= agp_efficeon_remove,\n\t.driver.pm\t= &agp_efficeon_pm_ops,\n};\n\nstatic int __init agp_efficeon_init(void)\n{\n\tstatic int agp_initialised=0;\n\n\tif (agp_off)\n\t\treturn -EINVAL;\n\n\tif (agp_initialised == 1)\n\t\treturn 0;\n\tagp_initialised=1;\n\n\treturn pci_register_driver(&agp_efficeon_pci_driver);\n}\n\nstatic void __exit agp_efficeon_cleanup(void)\n{\n\tpci_unregister_driver(&agp_efficeon_pci_driver);\n}\n\nmodule_init(agp_efficeon_init);\nmodule_exit(agp_efficeon_cleanup);\n\nMODULE_AUTHOR(\"Carlos Puchol <cpglinux@puchol.com>\");\nMODULE_LICENSE(\"GPL and additional rights\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}