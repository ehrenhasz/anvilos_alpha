{
  "module_name": "sis-agp.c",
  "hash_id": "2cb864559ddb9f60189d46b2c6b2681b10daa92c1be0461a30e3459e8f402998",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/agp/sis-agp.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/init.h>\n#include <linux/agp_backend.h>\n#include <linux/delay.h>\n#include \"agp.h\"\n\n#define SIS_ATTBASE\t0x90\n#define SIS_APSIZE\t0x94\n#define SIS_TLBCNTRL\t0x97\n#define SIS_TLBFLUSH\t0x98\n\n#define PCI_DEVICE_ID_SI_662\t0x0662\n#define PCI_DEVICE_ID_SI_671\t0x0671\n\nstatic bool agp_sis_force_delay = 0;\nstatic int agp_sis_agp_spec = -1;\n\nstatic int sis_fetch_size(void)\n{\n\tu8 temp_size;\n\tint i;\n\tstruct aper_size_info_8 *values;\n\n\tpci_read_config_byte(agp_bridge->dev, SIS_APSIZE, &temp_size);\n\tvalues = A_SIZE_8(agp_bridge->driver->aperture_sizes);\n\tfor (i = 0; i < agp_bridge->driver->num_aperture_sizes; i++) {\n\t\tif ((temp_size == values[i].size_value) ||\n\t\t    ((temp_size & ~(0x07)) ==\n\t\t     (values[i].size_value & ~(0x07)))) {\n\t\t\tagp_bridge->previous_size =\n\t\t\t    agp_bridge->current_size = (void *) (values + i);\n\n\t\t\tagp_bridge->aperture_size_idx = i;\n\t\t\treturn values[i].size;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void sis_tlbflush(struct agp_memory *mem)\n{\n\tpci_write_config_byte(agp_bridge->dev, SIS_TLBFLUSH, 0x02);\n}\n\nstatic int sis_configure(void)\n{\n\tstruct aper_size_info_8 *current_size;\n\n\tcurrent_size = A_SIZE_8(agp_bridge->current_size);\n\tpci_write_config_byte(agp_bridge->dev, SIS_TLBCNTRL, 0x05);\n\tagp_bridge->gart_bus_addr = pci_bus_address(agp_bridge->dev,\n\t\t\t\t\t\t    AGP_APERTURE_BAR);\n\tpci_write_config_dword(agp_bridge->dev, SIS_ATTBASE,\n\t\t\t       agp_bridge->gatt_bus_addr);\n\tpci_write_config_byte(agp_bridge->dev, SIS_APSIZE,\n\t\t\t      current_size->size_value);\n\treturn 0;\n}\n\nstatic void sis_cleanup(void)\n{\n\tstruct aper_size_info_8 *previous_size;\n\n\tprevious_size = A_SIZE_8(agp_bridge->previous_size);\n\tpci_write_config_byte(agp_bridge->dev, SIS_APSIZE,\n\t\t\t      (previous_size->size_value & ~(0x03)));\n}\n\nstatic void sis_delayed_enable(struct agp_bridge_data *bridge, u32 mode)\n{\n\tstruct pci_dev *device = NULL;\n\tu32 command;\n\tint rate;\n\n\tdev_info(&agp_bridge->dev->dev, \"AGP %d.%d bridge\\n\",\n\t\t agp_bridge->major_version, agp_bridge->minor_version);\n\n\tpci_read_config_dword(agp_bridge->dev, agp_bridge->capndx + PCI_AGP_STATUS, &command);\n\tcommand = agp_collect_device_status(bridge, mode, command);\n\tcommand |= AGPSTAT_AGP_ENABLE;\n\trate = (command & 0x7) << 2;\n\n\tfor_each_pci_dev(device) {\n\t\tu8 agp = pci_find_capability(device, PCI_CAP_ID_AGP);\n\t\tif (!agp)\n\t\t\tcontinue;\n\n\t\tdev_info(&agp_bridge->dev->dev, \"putting AGP V3 device at %s into %dx mode\\n\",\n\t\t\t pci_name(device), rate);\n\n\t\tpci_write_config_dword(device, agp + PCI_AGP_COMMAND, command);\n\n\t\t \n\t\tif (device->device == bridge->dev->device) {\n\t\t\tdev_info(&agp_bridge->dev->dev, \"SiS delay workaround: giving bridge time to recover\\n\");\n\t\t\tmsleep(10);\n\t\t}\n\t}\n}\n\nstatic const struct aper_size_info_8 sis_generic_sizes[7] =\n{\n\t{256, 65536, 6, 99},\n\t{128, 32768, 5, 83},\n\t{64, 16384, 4, 67},\n\t{32, 8192, 3, 51},\n\t{16, 4096, 2, 35},\n\t{8, 2048, 1, 19},\n\t{4, 1024, 0, 3}\n};\n\nstatic struct agp_bridge_driver sis_driver = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.aperture_sizes\t\t= sis_generic_sizes,\n\t.size_type\t\t= U8_APER_SIZE,\n\t.num_aperture_sizes\t= 7,\n\t.needs_scratch_page\t= true,\n\t.configure\t\t= sis_configure,\n\t.fetch_size\t\t= sis_fetch_size,\n\t.cleanup\t\t= sis_cleanup,\n\t.tlb_flush\t\t= sis_tlbflush,\n\t.mask_memory\t\t= agp_generic_mask_memory,\n\t.masks\t\t\t= NULL,\n\t.agp_enable\t\t= agp_generic_enable,\n\t.cache_flush\t\t= global_cache_flush,\n\t.create_gatt_table\t= agp_generic_create_gatt_table,\n\t.free_gatt_table\t= agp_generic_free_gatt_table,\n\t.insert_memory\t\t= agp_generic_insert_memory,\n\t.remove_memory\t\t= agp_generic_remove_memory,\n\t.alloc_by_type\t\t= agp_generic_alloc_by_type,\n\t.free_by_type\t\t= agp_generic_free_by_type,\n\t.agp_alloc_page\t\t= agp_generic_alloc_page,\n\t.agp_alloc_pages\t= agp_generic_alloc_pages,\n\t.agp_destroy_page\t= agp_generic_destroy_page,\n\t.agp_destroy_pages\t= agp_generic_destroy_pages,\n\t.agp_type_to_mask_type  = agp_generic_type_to_mask_type,\n};\n\n\nstatic int sis_broken_chipsets[] = {\n\tPCI_DEVICE_ID_SI_648,\n\tPCI_DEVICE_ID_SI_746,\n\t0 \n};\n\nstatic void sis_get_driver(struct agp_bridge_data *bridge)\n{\n\tint i;\n\n\tfor (i=0; sis_broken_chipsets[i]!=0; ++i)\n\t\tif (bridge->dev->device==sis_broken_chipsets[i])\n\t\t\tbreak;\n\n\tif (sis_broken_chipsets[i] || agp_sis_force_delay)\n\t\tsis_driver.agp_enable=sis_delayed_enable;\n\n\t\n\t\n\tif ((agp_bridge->major_version == 3 && agp_bridge->minor_version >= 5\n\t     && agp_sis_agp_spec!=0) || agp_sis_agp_spec==1) {\n\t\tsis_driver.aperture_sizes = agp3_generic_sizes;\n\t\tsis_driver.size_type = U16_APER_SIZE;\n\t\tsis_driver.num_aperture_sizes = AGP_GENERIC_SIZES_ENTRIES;\n\t\tsis_driver.configure = agp3_generic_configure;\n\t\tsis_driver.fetch_size = agp3_generic_fetch_size;\n\t\tsis_driver.cleanup = agp3_generic_cleanup;\n\t\tsis_driver.tlb_flush = agp3_generic_tlbflush;\n\t}\n}\n\n\nstatic int agp_sis_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct agp_bridge_data *bridge;\n\tu8 cap_ptr;\n\n\tcap_ptr = pci_find_capability(pdev, PCI_CAP_ID_AGP);\n\tif (!cap_ptr)\n\t\treturn -ENODEV;\n\n\n\tdev_info(&pdev->dev, \"SiS chipset [%04x/%04x]\\n\",\n\t\t pdev->vendor, pdev->device);\n\tbridge = agp_alloc_bridge();\n\tif (!bridge)\n\t\treturn -ENOMEM;\n\n\tbridge->driver = &sis_driver;\n\tbridge->dev = pdev;\n\tbridge->capndx = cap_ptr;\n\n\tget_agp_version(bridge);\n\n\t \n\tpci_read_config_dword(pdev, bridge->capndx+PCI_AGP_STATUS, &bridge->mode);\n\tsis_get_driver(bridge);\n\n\tpci_set_drvdata(pdev, bridge);\n\treturn agp_add_bridge(bridge);\n}\n\nstatic void agp_sis_remove(struct pci_dev *pdev)\n{\n\tstruct agp_bridge_data *bridge = pci_get_drvdata(pdev);\n\n\tagp_remove_bridge(bridge);\n\tagp_put_bridge(bridge);\n}\n\nstatic int agp_sis_resume(__attribute__((unused)) struct device *dev)\n{\n\treturn sis_driver.configure();\n}\n\nstatic const struct pci_device_id agp_sis_pci_table[] = {\n\t{\n\t\t.class\t\t= (PCI_CLASS_BRIDGE_HOST << 8),\n\t\t.class_mask\t= ~0,\n\t\t.vendor\t\t= PCI_VENDOR_ID_SI,\n\t\t.device\t\t= PCI_DEVICE_ID_SI_5591,\n\t\t.subvendor\t= PCI_ANY_ID,\n\t\t.subdevice\t= PCI_ANY_ID,\n\t},\n\t{\n\t\t.class\t\t= (PCI_CLASS_BRIDGE_HOST << 8),\n\t\t.class_mask\t= ~0,\n\t\t.vendor\t\t= PCI_VENDOR_ID_SI,\n\t\t.device\t\t= PCI_DEVICE_ID_SI_530,\n\t\t.subvendor\t= PCI_ANY_ID,\n\t\t.subdevice\t= PCI_ANY_ID,\n\t},\n\t{\n\t\t.class\t\t= (PCI_CLASS_BRIDGE_HOST << 8),\n\t\t.class_mask\t= ~0,\n\t\t.vendor\t\t= PCI_VENDOR_ID_SI,\n\t\t.device\t\t= PCI_DEVICE_ID_SI_540,\n\t\t.subvendor\t= PCI_ANY_ID,\n\t\t.subdevice\t= PCI_ANY_ID,\n\t},\n\t{\n\t\t.class\t\t= (PCI_CLASS_BRIDGE_HOST << 8),\n\t\t.class_mask\t= ~0,\n\t\t.vendor\t\t= PCI_VENDOR_ID_SI,\n\t\t.device\t\t= PCI_DEVICE_ID_SI_550,\n\t\t.subvendor\t= PCI_ANY_ID,\n\t\t.subdevice\t= PCI_ANY_ID,\n\t},\n\t{\n\t\t.class\t\t= (PCI_CLASS_BRIDGE_HOST << 8),\n\t\t.class_mask\t= ~0,\n\t\t.vendor\t\t= PCI_VENDOR_ID_SI,\n\t\t.device\t\t= PCI_DEVICE_ID_SI_620,\n\t\t.subvendor\t= PCI_ANY_ID,\n\t\t.subdevice\t= PCI_ANY_ID,\n\t},\n\t{\n\t\t.class\t\t= (PCI_CLASS_BRIDGE_HOST << 8),\n\t\t.class_mask\t= ~0,\n\t\t.vendor\t\t= PCI_VENDOR_ID_SI,\n\t\t.device\t\t= PCI_DEVICE_ID_SI_630,\n\t\t.subvendor\t= PCI_ANY_ID,\n\t\t.subdevice\t= PCI_ANY_ID,\n\t},\n\t{\n\t\t.class\t\t= (PCI_CLASS_BRIDGE_HOST << 8),\n\t\t.class_mask\t= ~0,\n\t\t.vendor\t\t= PCI_VENDOR_ID_SI,\n\t\t.device\t\t= PCI_DEVICE_ID_SI_635,\n\t\t.subvendor\t= PCI_ANY_ID,\n\t\t.subdevice\t= PCI_ANY_ID,\n\t},\n\t{\n\t\t.class\t\t= (PCI_CLASS_BRIDGE_HOST << 8),\n\t\t.class_mask\t= ~0,\n\t\t.vendor\t\t= PCI_VENDOR_ID_SI,\n\t\t.device\t\t= PCI_DEVICE_ID_SI_645,\n\t\t.subvendor\t= PCI_ANY_ID,\n\t\t.subdevice\t= PCI_ANY_ID,\n\t},\n\t{\n\t\t.class\t\t= (PCI_CLASS_BRIDGE_HOST << 8),\n\t\t.class_mask\t= ~0,\n\t\t.vendor\t\t= PCI_VENDOR_ID_SI,\n\t\t.device\t\t= PCI_DEVICE_ID_SI_646,\n\t\t.subvendor\t= PCI_ANY_ID,\n\t\t.subdevice\t= PCI_ANY_ID,\n\t},\n\t{\n\t\t.class\t\t= (PCI_CLASS_BRIDGE_HOST << 8),\n\t\t.class_mask\t= ~0,\n\t\t.vendor\t\t= PCI_VENDOR_ID_SI,\n\t\t.device\t\t= PCI_DEVICE_ID_SI_648,\n\t\t.subvendor\t= PCI_ANY_ID,\n\t\t.subdevice\t= PCI_ANY_ID,\n\t},\n\t{\n\t\t.class\t\t= (PCI_CLASS_BRIDGE_HOST << 8),\n\t\t.class_mask\t= ~0,\n\t\t.vendor\t\t= PCI_VENDOR_ID_SI,\n\t\t.device\t\t= PCI_DEVICE_ID_SI_650,\n\t\t.subvendor\t= PCI_ANY_ID,\n\t\t.subdevice\t= PCI_ANY_ID,\n\t},\n\t{\n\t\t.class\t\t= (PCI_CLASS_BRIDGE_HOST << 8),\n\t\t.class_mask\t= ~0,\n\t\t.vendor\t\t= PCI_VENDOR_ID_SI,\n\t\t.device\t\t= PCI_DEVICE_ID_SI_651,\n\t\t.subvendor\t= PCI_ANY_ID,\n\t\t.subdevice\t= PCI_ANY_ID,\n\t},\n\t{\n\t\t.class\t\t= (PCI_CLASS_BRIDGE_HOST << 8),\n\t\t.class_mask\t= ~0,\n\t\t.vendor\t\t= PCI_VENDOR_ID_SI,\n\t\t.device\t\t= PCI_DEVICE_ID_SI_655,\n\t\t.subvendor\t= PCI_ANY_ID,\n\t\t.subdevice\t= PCI_ANY_ID,\n\t},\n\t{\n\t\t.class\t\t= (PCI_CLASS_BRIDGE_HOST << 8),\n\t\t.class_mask\t= ~0,\n\t\t.vendor\t\t= PCI_VENDOR_ID_SI,\n\t\t.device\t\t= PCI_DEVICE_ID_SI_661,\n\t\t.subvendor\t= PCI_ANY_ID,\n\t\t.subdevice\t= PCI_ANY_ID,\n\t},\n\t{\n\t\t.class\t\t= (PCI_CLASS_BRIDGE_HOST << 8),\n\t\t.class_mask\t= ~0,\n\t\t.vendor\t\t= PCI_VENDOR_ID_SI,\n\t\t.device\t\t= PCI_DEVICE_ID_SI_662,\n\t\t.subvendor\t= PCI_ANY_ID,\n\t\t.subdevice\t= PCI_ANY_ID,\n\t},\n\t{\n\t\t.class\t\t= (PCI_CLASS_BRIDGE_HOST << 8),\n\t\t.class_mask\t= ~0,\n\t\t.vendor\t\t= PCI_VENDOR_ID_SI,\n\t\t.device\t\t= PCI_DEVICE_ID_SI_671,\n\t\t.subvendor\t= PCI_ANY_ID,\n\t\t.subdevice\t= PCI_ANY_ID,\n\t},\n\t{\n\t\t.class\t\t= (PCI_CLASS_BRIDGE_HOST << 8),\n\t\t.class_mask\t= ~0,\n\t\t.vendor\t\t= PCI_VENDOR_ID_SI,\n\t\t.device\t\t= PCI_DEVICE_ID_SI_730,\n\t\t.subvendor\t= PCI_ANY_ID,\n\t\t.subdevice\t= PCI_ANY_ID,\n\t},\n\t{\n\t\t.class\t\t= (PCI_CLASS_BRIDGE_HOST << 8),\n\t\t.class_mask\t= ~0,\n\t\t.vendor\t\t= PCI_VENDOR_ID_SI,\n\t\t.device\t\t= PCI_DEVICE_ID_SI_735,\n\t\t.subvendor\t= PCI_ANY_ID,\n\t\t.subdevice\t= PCI_ANY_ID,\n\t},\n\t{\n\t\t.class\t\t= (PCI_CLASS_BRIDGE_HOST << 8),\n\t\t.class_mask\t= ~0,\n\t\t.vendor\t\t= PCI_VENDOR_ID_SI,\n\t\t.device\t\t= PCI_DEVICE_ID_SI_740,\n\t\t.subvendor\t= PCI_ANY_ID,\n\t\t.subdevice\t= PCI_ANY_ID,\n\t},\n\t{\n\t\t.class\t\t= (PCI_CLASS_BRIDGE_HOST << 8),\n\t\t.class_mask\t= ~0,\n\t\t.vendor\t\t= PCI_VENDOR_ID_SI,\n\t\t.device\t\t= PCI_DEVICE_ID_SI_741,\n\t\t.subvendor\t= PCI_ANY_ID,\n\t\t.subdevice\t= PCI_ANY_ID,\n\t},\n\t{\n\t\t.class\t\t= (PCI_CLASS_BRIDGE_HOST << 8),\n\t\t.class_mask\t= ~0,\n\t\t.vendor\t\t= PCI_VENDOR_ID_SI,\n\t\t.device\t\t= PCI_DEVICE_ID_SI_745,\n\t\t.subvendor\t= PCI_ANY_ID,\n\t\t.subdevice\t= PCI_ANY_ID,\n\t},\n\t{\n\t\t.class\t\t= (PCI_CLASS_BRIDGE_HOST << 8),\n\t\t.class_mask\t= ~0,\n\t\t.vendor\t\t= PCI_VENDOR_ID_SI,\n\t\t.device\t\t= PCI_DEVICE_ID_SI_746,\n\t\t.subvendor\t= PCI_ANY_ID,\n\t\t.subdevice\t= PCI_ANY_ID,\n\t},\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(pci, agp_sis_pci_table);\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(agp_sis_pm_ops, NULL, agp_sis_resume);\n\nstatic struct pci_driver agp_sis_pci_driver = {\n\t.name\t\t= \"agpgart-sis\",\n\t.id_table\t= agp_sis_pci_table,\n\t.probe\t\t= agp_sis_probe,\n\t.remove\t\t= agp_sis_remove,\n\t.driver.pm      = &agp_sis_pm_ops,\n};\n\nstatic int __init agp_sis_init(void)\n{\n\tif (agp_off)\n\t\treturn -EINVAL;\n\treturn pci_register_driver(&agp_sis_pci_driver);\n}\n\nstatic void __exit agp_sis_cleanup(void)\n{\n\tpci_unregister_driver(&agp_sis_pci_driver);\n}\n\nmodule_init(agp_sis_init);\nmodule_exit(agp_sis_cleanup);\n\nmodule_param(agp_sis_force_delay, bool, 0);\nMODULE_PARM_DESC(agp_sis_force_delay,\"forces sis delay hack\");\nmodule_param(agp_sis_agp_spec, int, 0);\nMODULE_PARM_DESC(agp_sis_agp_spec,\"0=force sis init, 1=force generic agp3 init, default: autodetect\");\nMODULE_LICENSE(\"GPL and additional rights\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}