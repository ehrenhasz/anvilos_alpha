{
  "module_name": "generic.c",
  "hash_id": "330d55297be2b0f67117672c6aee46548c7cf699d3ece047c1c73d3abb197809",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/agp/generic.c",
  "human_readable_source": " \n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/pm.h>\n#include <linux/agp_backend.h>\n#include <linux/vmalloc.h>\n#include <linux/dma-mapping.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <asm/io.h>\n#ifdef CONFIG_X86\n#include <asm/set_memory.h>\n#endif\n#include \"agp.h\"\n\n__u32 *agp_gatt_table;\nint agp_memory_reserved;\n\n \nEXPORT_SYMBOL_GPL(agp_memory_reserved);\n\n \n\nvoid agp_free_key(int key)\n{\n\tif (key < 0)\n\t\treturn;\n\n\tif (key < MAXKEY)\n\t\tclear_bit(key, agp_bridge->key_list);\n}\nEXPORT_SYMBOL(agp_free_key);\n\n\nstatic int agp_get_key(void)\n{\n\tint bit;\n\n\tbit = find_first_zero_bit(agp_bridge->key_list, MAXKEY);\n\tif (bit < MAXKEY) {\n\t\tset_bit(bit, agp_bridge->key_list);\n\t\treturn bit;\n\t}\n\treturn -1;\n}\n\n \n\nvoid agp_alloc_page_array(size_t size, struct agp_memory *mem)\n{\n\tmem->pages = kvmalloc(size, GFP_KERNEL);\n}\nEXPORT_SYMBOL(agp_alloc_page_array);\n\nstatic struct agp_memory *agp_create_user_memory(unsigned long num_agp_pages)\n{\n\tstruct agp_memory *new;\n\tunsigned long alloc_size = num_agp_pages*sizeof(struct page *);\n\n\tif (INT_MAX/sizeof(struct page *) < num_agp_pages)\n\t\treturn NULL;\n\n\tnew = kzalloc(sizeof(struct agp_memory), GFP_KERNEL);\n\tif (new == NULL)\n\t\treturn NULL;\n\n\tnew->key = agp_get_key();\n\n\tif (new->key < 0) {\n\t\tkfree(new);\n\t\treturn NULL;\n\t}\n\n\tagp_alloc_page_array(alloc_size, new);\n\n\tif (new->pages == NULL) {\n\t\tagp_free_key(new->key);\n\t\tkfree(new);\n\t\treturn NULL;\n\t}\n\tnew->num_scratch_pages = 0;\n\treturn new;\n}\n\nstruct agp_memory *agp_create_memory(int scratch_pages)\n{\n\tstruct agp_memory *new;\n\n\tnew = kzalloc(sizeof(struct agp_memory), GFP_KERNEL);\n\tif (new == NULL)\n\t\treturn NULL;\n\n\tnew->key = agp_get_key();\n\n\tif (new->key < 0) {\n\t\tkfree(new);\n\t\treturn NULL;\n\t}\n\n\tagp_alloc_page_array(PAGE_SIZE * scratch_pages, new);\n\n\tif (new->pages == NULL) {\n\t\tagp_free_key(new->key);\n\t\tkfree(new);\n\t\treturn NULL;\n\t}\n\tnew->num_scratch_pages = scratch_pages;\n\tnew->type = AGP_NORMAL_MEMORY;\n\treturn new;\n}\nEXPORT_SYMBOL(agp_create_memory);\n\n \nvoid agp_free_memory(struct agp_memory *curr)\n{\n\tsize_t i;\n\n\tif (curr == NULL)\n\t\treturn;\n\n\tif (curr->is_bound)\n\t\tagp_unbind_memory(curr);\n\n\tif (curr->type >= AGP_USER_TYPES) {\n\t\tagp_generic_free_by_type(curr);\n\t\treturn;\n\t}\n\n\tif (curr->type != 0) {\n\t\tcurr->bridge->driver->free_by_type(curr);\n\t\treturn;\n\t}\n\tif (curr->page_count != 0) {\n\t\tif (curr->bridge->driver->agp_destroy_pages) {\n\t\t\tcurr->bridge->driver->agp_destroy_pages(curr);\n\t\t} else {\n\n\t\t\tfor (i = 0; i < curr->page_count; i++) {\n\t\t\t\tcurr->bridge->driver->agp_destroy_page(\n\t\t\t\t\tcurr->pages[i],\n\t\t\t\t\tAGP_PAGE_DESTROY_UNMAP);\n\t\t\t}\n\t\t\tfor (i = 0; i < curr->page_count; i++) {\n\t\t\t\tcurr->bridge->driver->agp_destroy_page(\n\t\t\t\t\tcurr->pages[i],\n\t\t\t\t\tAGP_PAGE_DESTROY_FREE);\n\t\t\t}\n\t\t}\n\t}\n\tagp_free_key(curr->key);\n\tagp_free_page_array(curr);\n\tkfree(curr);\n}\nEXPORT_SYMBOL(agp_free_memory);\n\n#define ENTRIES_PER_PAGE\t\t(PAGE_SIZE / sizeof(unsigned long))\n\n \nstruct agp_memory *agp_allocate_memory(struct agp_bridge_data *bridge,\n\t\t\t\t\tsize_t page_count, u32 type)\n{\n\tint scratch_pages;\n\tstruct agp_memory *new;\n\tsize_t i;\n\tint cur_memory;\n\n\tif (!bridge)\n\t\treturn NULL;\n\n\tcur_memory = atomic_read(&bridge->current_memory_agp);\n\tif ((cur_memory + page_count > bridge->max_memory_agp) ||\n\t    (cur_memory + page_count < page_count))\n\t\treturn NULL;\n\n\tif (type >= AGP_USER_TYPES) {\n\t\tnew = agp_generic_alloc_user(page_count, type);\n\t\tif (new)\n\t\t\tnew->bridge = bridge;\n\t\treturn new;\n\t}\n\n\tif (type != 0) {\n\t\tnew = bridge->driver->alloc_by_type(page_count, type);\n\t\tif (new)\n\t\t\tnew->bridge = bridge;\n\t\treturn new;\n\t}\n\n\tscratch_pages = (page_count + ENTRIES_PER_PAGE - 1) / ENTRIES_PER_PAGE;\n\n\tnew = agp_create_memory(scratch_pages);\n\n\tif (new == NULL)\n\t\treturn NULL;\n\n\tif (bridge->driver->agp_alloc_pages) {\n\t\tif (bridge->driver->agp_alloc_pages(bridge, new, page_count)) {\n\t\t\tagp_free_memory(new);\n\t\t\treturn NULL;\n\t\t}\n\t\tnew->bridge = bridge;\n\t\treturn new;\n\t}\n\n\tfor (i = 0; i < page_count; i++) {\n\t\tstruct page *page = bridge->driver->agp_alloc_page(bridge);\n\n\t\tif (page == NULL) {\n\t\t\tagp_free_memory(new);\n\t\t\treturn NULL;\n\t\t}\n\t\tnew->pages[i] = page;\n\t\tnew->page_count++;\n\t}\n\tnew->bridge = bridge;\n\n\treturn new;\n}\nEXPORT_SYMBOL(agp_allocate_memory);\n\n\n \n\n\nstatic int agp_return_size(void)\n{\n\tint current_size;\n\tvoid *temp;\n\n\ttemp = agp_bridge->current_size;\n\n\tswitch (agp_bridge->driver->size_type) {\n\tcase U8_APER_SIZE:\n\t\tcurrent_size = A_SIZE_8(temp)->size;\n\t\tbreak;\n\tcase U16_APER_SIZE:\n\t\tcurrent_size = A_SIZE_16(temp)->size;\n\t\tbreak;\n\tcase U32_APER_SIZE:\n\t\tcurrent_size = A_SIZE_32(temp)->size;\n\t\tbreak;\n\tcase LVL2_APER_SIZE:\n\t\tcurrent_size = A_SIZE_LVL2(temp)->size;\n\t\tbreak;\n\tcase FIXED_APER_SIZE:\n\t\tcurrent_size = A_SIZE_FIX(temp)->size;\n\t\tbreak;\n\tdefault:\n\t\tcurrent_size = 0;\n\t\tbreak;\n\t}\n\n\tcurrent_size -= (agp_memory_reserved / (1024*1024));\n\tif (current_size <0)\n\t\tcurrent_size = 0;\n\treturn current_size;\n}\n\n\nint agp_num_entries(void)\n{\n\tint num_entries;\n\tvoid *temp;\n\n\ttemp = agp_bridge->current_size;\n\n\tswitch (agp_bridge->driver->size_type) {\n\tcase U8_APER_SIZE:\n\t\tnum_entries = A_SIZE_8(temp)->num_entries;\n\t\tbreak;\n\tcase U16_APER_SIZE:\n\t\tnum_entries = A_SIZE_16(temp)->num_entries;\n\t\tbreak;\n\tcase U32_APER_SIZE:\n\t\tnum_entries = A_SIZE_32(temp)->num_entries;\n\t\tbreak;\n\tcase LVL2_APER_SIZE:\n\t\tnum_entries = A_SIZE_LVL2(temp)->num_entries;\n\t\tbreak;\n\tcase FIXED_APER_SIZE:\n\t\tnum_entries = A_SIZE_FIX(temp)->num_entries;\n\t\tbreak;\n\tdefault:\n\t\tnum_entries = 0;\n\t\tbreak;\n\t}\n\n\tnum_entries -= agp_memory_reserved>>PAGE_SHIFT;\n\tif (num_entries<0)\n\t\tnum_entries = 0;\n\treturn num_entries;\n}\nEXPORT_SYMBOL_GPL(agp_num_entries);\n\n\n \nint agp_copy_info(struct agp_bridge_data *bridge, struct agp_kern_info *info)\n{\n\tmemset(info, 0, sizeof(struct agp_kern_info));\n\tif (!bridge) {\n\t\tinfo->chipset = NOT_SUPPORTED;\n\t\treturn -EIO;\n\t}\n\n\tinfo->version.major = bridge->version->major;\n\tinfo->version.minor = bridge->version->minor;\n\tinfo->chipset = SUPPORTED;\n\tinfo->device = bridge->dev;\n\tif (bridge->mode & AGPSTAT_MODE_3_0)\n\t\tinfo->mode = bridge->mode & ~AGP3_RESERVED_MASK;\n\telse\n\t\tinfo->mode = bridge->mode & ~AGP2_RESERVED_MASK;\n\tinfo->aper_base = bridge->gart_bus_addr;\n\tinfo->aper_size = agp_return_size();\n\tinfo->max_memory = bridge->max_memory_agp;\n\tinfo->current_memory = atomic_read(&bridge->current_memory_agp);\n\tinfo->cant_use_aperture = bridge->driver->cant_use_aperture;\n\tinfo->vm_ops = bridge->vm_ops;\n\tinfo->page_mask = ~0UL;\n\treturn 0;\n}\nEXPORT_SYMBOL(agp_copy_info);\n\n \n\n \n\n \nint agp_bind_memory(struct agp_memory *curr, off_t pg_start)\n{\n\tint ret_val;\n\n\tif (curr == NULL)\n\t\treturn -EINVAL;\n\n\tif (curr->is_bound) {\n\t\tprintk(KERN_INFO PFX \"memory %p is already bound!\\n\", curr);\n\t\treturn -EINVAL;\n\t}\n\tif (!curr->is_flushed) {\n\t\tcurr->bridge->driver->cache_flush();\n\t\tcurr->is_flushed = true;\n\t}\n\n\tret_val = curr->bridge->driver->insert_memory(curr, pg_start, curr->type);\n\n\tif (ret_val != 0)\n\t\treturn ret_val;\n\n\tcurr->is_bound = true;\n\tcurr->pg_start = pg_start;\n\tspin_lock(&agp_bridge->mapped_lock);\n\tlist_add(&curr->mapped_list, &agp_bridge->mapped_list);\n\tspin_unlock(&agp_bridge->mapped_lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(agp_bind_memory);\n\n\n \nint agp_unbind_memory(struct agp_memory *curr)\n{\n\tint ret_val;\n\n\tif (curr == NULL)\n\t\treturn -EINVAL;\n\n\tif (!curr->is_bound) {\n\t\tprintk(KERN_INFO PFX \"memory %p was not bound!\\n\", curr);\n\t\treturn -EINVAL;\n\t}\n\n\tret_val = curr->bridge->driver->remove_memory(curr, curr->pg_start, curr->type);\n\n\tif (ret_val != 0)\n\t\treturn ret_val;\n\n\tcurr->is_bound = false;\n\tcurr->pg_start = 0;\n\tspin_lock(&curr->bridge->mapped_lock);\n\tlist_del(&curr->mapped_list);\n\tspin_unlock(&curr->bridge->mapped_lock);\n\treturn 0;\n}\nEXPORT_SYMBOL(agp_unbind_memory);\n\n\n \n\n\n \nstatic void agp_v2_parse_one(u32 *requested_mode, u32 *bridge_agpstat, u32 *vga_agpstat)\n{\n\tu32 tmp;\n\n\tif (*requested_mode & AGP2_RESERVED_MASK) {\n\t\tprintk(KERN_INFO PFX \"reserved bits set (%x) in mode 0x%x. Fixed.\\n\",\n\t\t\t*requested_mode & AGP2_RESERVED_MASK, *requested_mode);\n\t\t*requested_mode &= ~AGP2_RESERVED_MASK;\n\t}\n\n\t \n\tswitch (*bridge_agpstat & 7) {\n\tcase 4:\n\t\t*bridge_agpstat |= (AGPSTAT2_2X | AGPSTAT2_1X);\n\t\tprintk(KERN_INFO PFX \"BIOS bug. AGP bridge claims to only support x4 rate. \"\n\t\t\t\"Fixing up support for x2 & x1\\n\");\n\t\tbreak;\n\tcase 2:\n\t\t*bridge_agpstat |= AGPSTAT2_1X;\n\t\tprintk(KERN_INFO PFX \"BIOS bug. AGP bridge claims to only support x2 rate. \"\n\t\t\t\"Fixing up support for x1\\n\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\ttmp = *requested_mode & 7;\n\tswitch (tmp) {\n\t\tcase 0:\n\t\t\tprintk(KERN_INFO PFX \"%s tried to set rate=x0. Setting to x1 mode.\\n\", current->comm);\n\t\t\t*requested_mode |= AGPSTAT2_1X;\n\t\t\tbreak;\n\t\tcase 1:\n\t\tcase 2:\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\t*requested_mode &= ~(AGPSTAT2_1X);\t \n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tbreak;\n\t\tcase 5:\n\t\tcase 6:\n\t\tcase 7:\n\t\t\t*requested_mode &= ~(AGPSTAT2_1X|AGPSTAT2_2X);  \n\t\t\tbreak;\n\t}\n\n\t \n\tif (!((*bridge_agpstat & AGPSTAT_SBA) && (*vga_agpstat & AGPSTAT_SBA) && (*requested_mode & AGPSTAT_SBA)))\n\t\t*bridge_agpstat &= ~AGPSTAT_SBA;\n\n\t \n\tif (!((*bridge_agpstat & AGPSTAT2_4X) && (*vga_agpstat & AGPSTAT2_4X) && (*requested_mode & AGPSTAT2_4X)))\n\t\t*bridge_agpstat &= ~AGPSTAT2_4X;\n\n\tif (!((*bridge_agpstat & AGPSTAT2_2X) && (*vga_agpstat & AGPSTAT2_2X) && (*requested_mode & AGPSTAT2_2X)))\n\t\t*bridge_agpstat &= ~AGPSTAT2_2X;\n\n\tif (!((*bridge_agpstat & AGPSTAT2_1X) && (*vga_agpstat & AGPSTAT2_1X) && (*requested_mode & AGPSTAT2_1X)))\n\t\t*bridge_agpstat &= ~AGPSTAT2_1X;\n\n\t \n\tif (*bridge_agpstat & AGPSTAT2_4X)\n\t\t*bridge_agpstat &= ~(AGPSTAT2_1X | AGPSTAT2_2X);\t \n\n\tif (*bridge_agpstat & AGPSTAT2_2X)\n\t\t*bridge_agpstat &= ~(AGPSTAT2_1X | AGPSTAT2_4X);\t \n\n\tif (*bridge_agpstat & AGPSTAT2_1X)\n\t\t*bridge_agpstat &= ~(AGPSTAT2_2X | AGPSTAT2_4X);\t \n\n\t \n\tif (agp_bridge->flags & AGP_ERRATA_FASTWRITES)\n\t\t*bridge_agpstat &= ~AGPSTAT_FW;\n\n\tif (agp_bridge->flags & AGP_ERRATA_SBA)\n\t\t*bridge_agpstat &= ~AGPSTAT_SBA;\n\n\tif (agp_bridge->flags & AGP_ERRATA_1X) {\n\t\t*bridge_agpstat &= ~(AGPSTAT2_2X | AGPSTAT2_4X);\n\t\t*bridge_agpstat |= AGPSTAT2_1X;\n\t}\n\n\t \n\tif (*bridge_agpstat & AGPSTAT2_1X)\n\t\t*bridge_agpstat &= ~AGPSTAT_FW;\n}\n\n \nstatic void agp_v3_parse_one(u32 *requested_mode, u32 *bridge_agpstat, u32 *vga_agpstat)\n{\n\tu32 origbridge=*bridge_agpstat, origvga=*vga_agpstat;\n\tu32 tmp;\n\n\tif (*requested_mode & AGP3_RESERVED_MASK) {\n\t\tprintk(KERN_INFO PFX \"reserved bits set (%x) in mode 0x%x. Fixed.\\n\",\n\t\t\t*requested_mode & AGP3_RESERVED_MASK, *requested_mode);\n\t\t*requested_mode &= ~AGP3_RESERVED_MASK;\n\t}\n\n\t \n\ttmp = *requested_mode & 7;\n\tif (tmp == 0) {\n\t\tprintk(KERN_INFO PFX \"%s tried to set rate=x0. Setting to AGP3 x4 mode.\\n\", current->comm);\n\t\t*requested_mode |= AGPSTAT3_4X;\n\t}\n\tif (tmp >= 3) {\n\t\tprintk(KERN_INFO PFX \"%s tried to set rate=x%d. Setting to AGP3 x8 mode.\\n\", current->comm, tmp * 4);\n\t\t*requested_mode = (*requested_mode & ~7) | AGPSTAT3_8X;\n\t}\n\n\t \n\t*bridge_agpstat = ((*bridge_agpstat & ~AGPSTAT_ARQSZ) |\n\t\tmax_t(u32,(*bridge_agpstat & AGPSTAT_ARQSZ),(*vga_agpstat & AGPSTAT_ARQSZ)));\n\n\t \n\t*bridge_agpstat = ((*bridge_agpstat & ~AGPSTAT_CAL_MASK) |\n\t\tmin_t(u32,(*bridge_agpstat & AGPSTAT_CAL_MASK),(*vga_agpstat & AGPSTAT_CAL_MASK)));\n\n\t \n\t*bridge_agpstat |= AGPSTAT_SBA;\n\n\t \n\tif (*requested_mode & AGPSTAT_MODE_3_0) {\n\t\t \n\t\tif (*requested_mode & AGPSTAT2_4X) {\n\t\t\tprintk(KERN_INFO PFX \"%s passes broken AGP3 flags (%x). Fixed.\\n\",\n\t\t\t\t\t\tcurrent->comm, *requested_mode);\n\t\t\t*requested_mode &= ~AGPSTAT2_4X;\n\t\t\t*requested_mode |= AGPSTAT3_4X;\n\t\t}\n\t} else {\n\t\t \n\t\tprintk(KERN_INFO PFX \"%s passes broken AGP2 flags (%x) in AGP3 mode. Fixed.\\n\",\n\t\t\t\t\tcurrent->comm, *requested_mode);\n\t\t*requested_mode &= ~(AGPSTAT2_4X | AGPSTAT2_2X | AGPSTAT2_1X);\n\t\t*requested_mode |= AGPSTAT3_4X;\n\t}\n\n\tif (*requested_mode & AGPSTAT3_8X) {\n\t\tif (!(*bridge_agpstat & AGPSTAT3_8X)) {\n\t\t\t*bridge_agpstat &= ~(AGPSTAT3_8X | AGPSTAT3_RSVD);\n\t\t\t*bridge_agpstat |= AGPSTAT3_4X;\n\t\t\tprintk(KERN_INFO PFX \"%s requested AGPx8 but bridge not capable.\\n\", current->comm);\n\t\t\treturn;\n\t\t}\n\t\tif (!(*vga_agpstat & AGPSTAT3_8X)) {\n\t\t\t*bridge_agpstat &= ~(AGPSTAT3_8X | AGPSTAT3_RSVD);\n\t\t\t*bridge_agpstat |= AGPSTAT3_4X;\n\t\t\tprintk(KERN_INFO PFX \"%s requested AGPx8 but graphic card not capable.\\n\", current->comm);\n\t\t\treturn;\n\t\t}\n\t\t \n\t\t*bridge_agpstat &= ~(AGPSTAT3_4X | AGPSTAT3_RSVD);\n\t\tgoto done;\n\n\t} else if (*requested_mode & AGPSTAT3_4X) {\n\t\t*bridge_agpstat &= ~(AGPSTAT3_8X | AGPSTAT3_RSVD);\n\t\t*bridge_agpstat |= AGPSTAT3_4X;\n\t\tgoto done;\n\n\t} else {\n\n\t\t \n\t\tif ((*bridge_agpstat & AGPSTAT3_8X) && (*vga_agpstat & AGPSTAT3_8X)) {\n\t\t\tprintk(KERN_INFO PFX \"No AGP mode specified. Setting to highest mode \"\n\t\t\t\t\"supported by bridge & card (x8).\\n\");\n\t\t\t*bridge_agpstat &= ~(AGPSTAT3_4X | AGPSTAT3_RSVD);\n\t\t\t*vga_agpstat &= ~(AGPSTAT3_4X | AGPSTAT3_RSVD);\n\t\t} else {\n\t\t\tprintk(KERN_INFO PFX \"Fell back to AGPx4 mode because \");\n\t\t\tif (!(*bridge_agpstat & AGPSTAT3_8X)) {\n\t\t\t\tprintk(KERN_INFO PFX \"bridge couldn't do x8. bridge_agpstat:%x (orig=%x)\\n\",\n\t\t\t\t\t*bridge_agpstat, origbridge);\n\t\t\t\t*bridge_agpstat &= ~(AGPSTAT3_8X | AGPSTAT3_RSVD);\n\t\t\t\t*bridge_agpstat |= AGPSTAT3_4X;\n\t\t\t}\n\t\t\tif (!(*vga_agpstat & AGPSTAT3_8X)) {\n\t\t\t\tprintk(KERN_INFO PFX \"graphics card couldn't do x8. vga_agpstat:%x (orig=%x)\\n\",\n\t\t\t\t\t*vga_agpstat, origvga);\n\t\t\t\t*vga_agpstat &= ~(AGPSTAT3_8X | AGPSTAT3_RSVD);\n\t\t\t\t*vga_agpstat |= AGPSTAT3_4X;\n\t\t\t}\n\t\t}\n\t}\n\ndone:\n\t \n\tif (agp_bridge->flags & AGP_ERRATA_FASTWRITES)\n\t\t*bridge_agpstat &= ~AGPSTAT_FW;\n\n\tif (agp_bridge->flags & AGP_ERRATA_SBA)\n\t\t*bridge_agpstat &= ~AGPSTAT_SBA;\n\n\tif (agp_bridge->flags & AGP_ERRATA_1X) {\n\t\t*bridge_agpstat &= ~(AGPSTAT2_2X | AGPSTAT2_4X);\n\t\t*bridge_agpstat |= AGPSTAT2_1X;\n\t}\n}\n\n\n \nu32 agp_collect_device_status(struct agp_bridge_data *bridge, u32 requested_mode, u32 bridge_agpstat)\n{\n\tstruct pci_dev *device = NULL;\n\tu32 vga_agpstat;\n\tu8 cap_ptr;\n\n\tfor (;;) {\n\t\tdevice = pci_get_class(PCI_CLASS_DISPLAY_VGA << 8, device);\n\t\tif (!device) {\n\t\t\tprintk(KERN_INFO PFX \"Couldn't find an AGP VGA controller.\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tcap_ptr = pci_find_capability(device, PCI_CAP_ID_AGP);\n\t\tif (cap_ptr)\n\t\t\tbreak;\n\t}\n\n\t \n\tpci_read_config_dword(device, cap_ptr+PCI_AGP_STATUS, &vga_agpstat);\n\n\t \n\tbridge_agpstat = ((bridge_agpstat & ~AGPSTAT_RQ_DEPTH) |\n\t     min_t(u32, (requested_mode & AGPSTAT_RQ_DEPTH),\n\t\t min_t(u32, (bridge_agpstat & AGPSTAT_RQ_DEPTH), (vga_agpstat & AGPSTAT_RQ_DEPTH))));\n\n\t \n\tif (!((bridge_agpstat & AGPSTAT_FW) &&\n\t\t (vga_agpstat & AGPSTAT_FW) &&\n\t\t (requested_mode & AGPSTAT_FW)))\n\t\tbridge_agpstat &= ~AGPSTAT_FW;\n\n\t \n\tif (agp_bridge->mode & AGPSTAT_MODE_3_0)\n\t\tagp_v3_parse_one(&requested_mode, &bridge_agpstat, &vga_agpstat);\n\telse\n\t\tagp_v2_parse_one(&requested_mode, &bridge_agpstat, &vga_agpstat);\n\n\tpci_dev_put(device);\n\treturn bridge_agpstat;\n}\nEXPORT_SYMBOL(agp_collect_device_status);\n\n\nvoid agp_device_command(u32 bridge_agpstat, bool agp_v3)\n{\n\tstruct pci_dev *device = NULL;\n\tint mode;\n\n\tmode = bridge_agpstat & 0x7;\n\tif (agp_v3)\n\t\tmode *= 4;\n\n\tfor_each_pci_dev(device) {\n\t\tu8 agp = pci_find_capability(device, PCI_CAP_ID_AGP);\n\t\tif (!agp)\n\t\t\tcontinue;\n\n\t\tdev_info(&device->dev, \"putting AGP V%d device into %dx mode\\n\",\n\t\t\t agp_v3 ? 3 : 2, mode);\n\t\tpci_write_config_dword(device, agp + PCI_AGP_COMMAND, bridge_agpstat);\n\t}\n}\nEXPORT_SYMBOL(agp_device_command);\n\n\nvoid get_agp_version(struct agp_bridge_data *bridge)\n{\n\tu32 ncapid;\n\n\t \n\tif (bridge->major_version != 0)\n\t\treturn;\n\n\tpci_read_config_dword(bridge->dev, bridge->capndx, &ncapid);\n\tbridge->major_version = (ncapid >> AGP_MAJOR_VERSION_SHIFT) & 0xf;\n\tbridge->minor_version = (ncapid >> AGP_MINOR_VERSION_SHIFT) & 0xf;\n}\nEXPORT_SYMBOL(get_agp_version);\n\n\nvoid agp_generic_enable(struct agp_bridge_data *bridge, u32 requested_mode)\n{\n\tu32 bridge_agpstat, temp;\n\n\tget_agp_version(agp_bridge);\n\n\tdev_info(&agp_bridge->dev->dev, \"AGP %d.%d bridge\\n\",\n\t\t agp_bridge->major_version, agp_bridge->minor_version);\n\n\tpci_read_config_dword(agp_bridge->dev,\n\t\t      agp_bridge->capndx + PCI_AGP_STATUS, &bridge_agpstat);\n\n\tbridge_agpstat = agp_collect_device_status(agp_bridge, requested_mode, bridge_agpstat);\n\tif (bridge_agpstat == 0)\n\t\t \n\t\treturn;\n\n\tbridge_agpstat |= AGPSTAT_AGP_ENABLE;\n\n\t \n\tif (bridge->major_version >= 3) {\n\t\tif (bridge->mode & AGPSTAT_MODE_3_0) {\n\t\t\t \n\t\t\tif (bridge->minor_version >= 5)\n\t\t\t\tagp_3_5_enable(bridge);\n\t\t\tagp_device_command(bridge_agpstat, true);\n\t\t\treturn;\n\t\t} else {\n\t\t     \n\t\t    bridge_agpstat &= ~(7<<10) ;\n\t\t    pci_read_config_dword(bridge->dev,\n\t\t\t\t\tbridge->capndx+AGPCTRL, &temp);\n\t\t    temp |= (1<<9);\n\t\t    pci_write_config_dword(bridge->dev,\n\t\t\t\t\tbridge->capndx+AGPCTRL, temp);\n\n\t\t    dev_info(&bridge->dev->dev, \"bridge is in legacy mode, falling back to 2.x\\n\");\n\t\t}\n\t}\n\n\t \n\tagp_device_command(bridge_agpstat, false);\n}\nEXPORT_SYMBOL(agp_generic_enable);\n\n\nint agp_generic_create_gatt_table(struct agp_bridge_data *bridge)\n{\n\tchar *table;\n\tchar *table_end;\n\tint page_order;\n\tint num_entries;\n\tint i;\n\tvoid *temp;\n\tstruct page *page;\n\n\t \n\tif (bridge->driver->size_type == LVL2_APER_SIZE)\n\t\treturn -EINVAL;\n\n\ttable = NULL;\n\ti = bridge->aperture_size_idx;\n\ttemp = bridge->current_size;\n\tpage_order = num_entries = 0;\n\n\tif (bridge->driver->size_type != FIXED_APER_SIZE) {\n\t\tdo {\n\t\t\tswitch (bridge->driver->size_type) {\n\t\t\tcase U8_APER_SIZE:\n\t\t\t\tpage_order =\n\t\t\t\t    A_SIZE_8(temp)->page_order;\n\t\t\t\tnum_entries =\n\t\t\t\t    A_SIZE_8(temp)->num_entries;\n\t\t\t\tbreak;\n\t\t\tcase U16_APER_SIZE:\n\t\t\t\tpage_order = A_SIZE_16(temp)->page_order;\n\t\t\t\tnum_entries = A_SIZE_16(temp)->num_entries;\n\t\t\t\tbreak;\n\t\t\tcase U32_APER_SIZE:\n\t\t\t\tpage_order = A_SIZE_32(temp)->page_order;\n\t\t\t\tnum_entries = A_SIZE_32(temp)->num_entries;\n\t\t\t\tbreak;\n\t\t\t\t \n\t\t\tcase FIXED_APER_SIZE:\n\t\t\tcase LVL2_APER_SIZE:\n\t\t\tdefault:\n\t\t\t\tpage_order = num_entries = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ttable = alloc_gatt_pages(page_order);\n\n\t\t\tif (table == NULL) {\n\t\t\t\ti++;\n\t\t\t\tswitch (bridge->driver->size_type) {\n\t\t\t\tcase U8_APER_SIZE:\n\t\t\t\t\tbridge->current_size = A_IDX8(bridge);\n\t\t\t\t\tbreak;\n\t\t\t\tcase U16_APER_SIZE:\n\t\t\t\t\tbridge->current_size = A_IDX16(bridge);\n\t\t\t\t\tbreak;\n\t\t\t\tcase U32_APER_SIZE:\n\t\t\t\t\tbridge->current_size = A_IDX32(bridge);\n\t\t\t\t\tbreak;\n\t\t\t\t \n\t\t\t\tcase FIXED_APER_SIZE:\n\t\t\t\tcase LVL2_APER_SIZE:\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttemp = bridge->current_size;\n\t\t\t} else {\n\t\t\t\tbridge->aperture_size_idx = i;\n\t\t\t}\n\t\t} while (!table && (i < bridge->driver->num_aperture_sizes));\n\t} else {\n\t\tpage_order = ((struct aper_size_info_fixed *) temp)->page_order;\n\t\tnum_entries = ((struct aper_size_info_fixed *) temp)->num_entries;\n\t\ttable = alloc_gatt_pages(page_order);\n\t}\n\n\tif (table == NULL)\n\t\treturn -ENOMEM;\n\n\ttable_end = table + ((PAGE_SIZE * (1 << page_order)) - 1);\n\n\tfor (page = virt_to_page(table); page <= virt_to_page(table_end); page++)\n\t\tSetPageReserved(page);\n\n\tbridge->gatt_table_real = (u32 *) table;\n\tagp_gatt_table = (void *)table;\n\n\tbridge->driver->cache_flush();\n#ifdef CONFIG_X86\n\tif (set_memory_uc((unsigned long)table, 1 << page_order))\n\t\tprintk(KERN_WARNING \"Could not set GATT table memory to UC!\\n\");\n\n\tbridge->gatt_table = (u32 __iomem *)table;\n#else\n\tbridge->gatt_table = ioremap(virt_to_phys(table),\n\t\t\t\t\t(PAGE_SIZE * (1 << page_order)));\n\tbridge->driver->cache_flush();\n#endif\n\n\tif (bridge->gatt_table == NULL) {\n\t\tfor (page = virt_to_page(table); page <= virt_to_page(table_end); page++)\n\t\t\tClearPageReserved(page);\n\n\t\tfree_gatt_pages(table, page_order);\n\n\t\treturn -ENOMEM;\n\t}\n\tbridge->gatt_bus_addr = virt_to_phys(bridge->gatt_table_real);\n\n\t \n\tfor (i = 0; i < num_entries; i++) {\n\t\twritel(bridge->scratch_page, bridge->gatt_table+i);\n\t\treadl(bridge->gatt_table+i);\t \n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(agp_generic_create_gatt_table);\n\nint agp_generic_free_gatt_table(struct agp_bridge_data *bridge)\n{\n\tint page_order;\n\tchar *table, *table_end;\n\tvoid *temp;\n\tstruct page *page;\n\n\ttemp = bridge->current_size;\n\n\tswitch (bridge->driver->size_type) {\n\tcase U8_APER_SIZE:\n\t\tpage_order = A_SIZE_8(temp)->page_order;\n\t\tbreak;\n\tcase U16_APER_SIZE:\n\t\tpage_order = A_SIZE_16(temp)->page_order;\n\t\tbreak;\n\tcase U32_APER_SIZE:\n\t\tpage_order = A_SIZE_32(temp)->page_order;\n\t\tbreak;\n\tcase FIXED_APER_SIZE:\n\t\tpage_order = A_SIZE_FIX(temp)->page_order;\n\t\tbreak;\n\tcase LVL2_APER_SIZE:\n\t\t \n\t\treturn -EINVAL;\n\tdefault:\n\t\tpage_order = 0;\n\t\tbreak;\n\t}\n\n\t \n\n#ifdef CONFIG_X86\n\tset_memory_wb((unsigned long)bridge->gatt_table, 1 << page_order);\n#else\n\tiounmap(bridge->gatt_table);\n#endif\n\ttable = (char *) bridge->gatt_table_real;\n\ttable_end = table + ((PAGE_SIZE * (1 << page_order)) - 1);\n\n\tfor (page = virt_to_page(table); page <= virt_to_page(table_end); page++)\n\t\tClearPageReserved(page);\n\n\tfree_gatt_pages(bridge->gatt_table_real, page_order);\n\n\tagp_gatt_table = NULL;\n\tbridge->gatt_table = NULL;\n\tbridge->gatt_table_real = NULL;\n\tbridge->gatt_bus_addr = 0;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(agp_generic_free_gatt_table);\n\n\nint agp_generic_insert_memory(struct agp_memory * mem, off_t pg_start, int type)\n{\n\tint num_entries;\n\tsize_t i;\n\toff_t j;\n\tvoid *temp;\n\tstruct agp_bridge_data *bridge;\n\tint mask_type;\n\n\tbridge = mem->bridge;\n\tif (!bridge)\n\t\treturn -EINVAL;\n\n\tif (mem->page_count == 0)\n\t\treturn 0;\n\n\ttemp = bridge->current_size;\n\n\tswitch (bridge->driver->size_type) {\n\tcase U8_APER_SIZE:\n\t\tnum_entries = A_SIZE_8(temp)->num_entries;\n\t\tbreak;\n\tcase U16_APER_SIZE:\n\t\tnum_entries = A_SIZE_16(temp)->num_entries;\n\t\tbreak;\n\tcase U32_APER_SIZE:\n\t\tnum_entries = A_SIZE_32(temp)->num_entries;\n\t\tbreak;\n\tcase FIXED_APER_SIZE:\n\t\tnum_entries = A_SIZE_FIX(temp)->num_entries;\n\t\tbreak;\n\tcase LVL2_APER_SIZE:\n\t\t \n\t\treturn -EINVAL;\n\tdefault:\n\t\tnum_entries = 0;\n\t\tbreak;\n\t}\n\n\tnum_entries -= agp_memory_reserved/PAGE_SIZE;\n\tif (num_entries < 0) num_entries = 0;\n\n\tif (type != mem->type)\n\t\treturn -EINVAL;\n\n\tmask_type = bridge->driver->agp_type_to_mask_type(bridge, type);\n\tif (mask_type != 0) {\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\tif (((pg_start + mem->page_count) > num_entries) ||\n\t    ((pg_start + mem->page_count) < pg_start))\n\t\treturn -EINVAL;\n\n\tj = pg_start;\n\n\twhile (j < (pg_start + mem->page_count)) {\n\t\tif (!PGE_EMPTY(bridge, readl(bridge->gatt_table+j)))\n\t\t\treturn -EBUSY;\n\t\tj++;\n\t}\n\n\tif (!mem->is_flushed) {\n\t\tbridge->driver->cache_flush();\n\t\tmem->is_flushed = true;\n\t}\n\n\tfor (i = 0, j = pg_start; i < mem->page_count; i++, j++) {\n\t\twritel(bridge->driver->mask_memory(bridge,\n\t\t\t\t\t\t   page_to_phys(mem->pages[i]),\n\t\t\t\t\t\t   mask_type),\n\t\t       bridge->gatt_table+j);\n\t}\n\treadl(bridge->gatt_table+j-1);\t \n\n\tbridge->driver->tlb_flush(mem);\n\treturn 0;\n}\nEXPORT_SYMBOL(agp_generic_insert_memory);\n\n\nint agp_generic_remove_memory(struct agp_memory *mem, off_t pg_start, int type)\n{\n\tsize_t i;\n\tstruct agp_bridge_data *bridge;\n\tint mask_type, num_entries;\n\n\tbridge = mem->bridge;\n\tif (!bridge)\n\t\treturn -EINVAL;\n\n\tif (mem->page_count == 0)\n\t\treturn 0;\n\n\tif (type != mem->type)\n\t\treturn -EINVAL;\n\n\tnum_entries = agp_num_entries();\n\tif (((pg_start + mem->page_count) > num_entries) ||\n\t    ((pg_start + mem->page_count) < pg_start))\n\t\treturn -EINVAL;\n\n\tmask_type = bridge->driver->agp_type_to_mask_type(bridge, type);\n\tif (mask_type != 0) {\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor (i = pg_start; i < (mem->page_count + pg_start); i++) {\n\t\twritel(bridge->scratch_page, bridge->gatt_table+i);\n\t}\n\treadl(bridge->gatt_table+i-1);\t \n\n\tbridge->driver->tlb_flush(mem);\n\treturn 0;\n}\nEXPORT_SYMBOL(agp_generic_remove_memory);\n\nstruct agp_memory *agp_generic_alloc_by_type(size_t page_count, int type)\n{\n\treturn NULL;\n}\nEXPORT_SYMBOL(agp_generic_alloc_by_type);\n\nvoid agp_generic_free_by_type(struct agp_memory *curr)\n{\n\tagp_free_page_array(curr);\n\tagp_free_key(curr->key);\n\tkfree(curr);\n}\nEXPORT_SYMBOL(agp_generic_free_by_type);\n\nstruct agp_memory *agp_generic_alloc_user(size_t page_count, int type)\n{\n\tstruct agp_memory *new;\n\tint i;\n\tint pages;\n\n\tpages = (page_count + ENTRIES_PER_PAGE - 1) / ENTRIES_PER_PAGE;\n\tnew = agp_create_user_memory(page_count);\n\tif (new == NULL)\n\t\treturn NULL;\n\n\tfor (i = 0; i < page_count; i++)\n\t\tnew->pages[i] = NULL;\n\tnew->page_count = 0;\n\tnew->type = type;\n\tnew->num_scratch_pages = pages;\n\n\treturn new;\n}\nEXPORT_SYMBOL(agp_generic_alloc_user);\n\n \n\nint agp_generic_alloc_pages(struct agp_bridge_data *bridge, struct agp_memory *mem, size_t num_pages)\n{\n\tstruct page * page;\n\tint i, ret = -ENOMEM;\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\tpage = alloc_page(GFP_KERNEL | GFP_DMA32 | __GFP_ZERO);\n\t\t \n\t\tif (page == NULL)\n\t\t\tgoto out;\n\n#ifndef CONFIG_X86\n\t\tmap_page_into_agp(page);\n#endif\n\t\tget_page(page);\n\t\tatomic_inc(&agp_bridge->current_memory_agp);\n\n\t\tmem->pages[i] = page;\n\t\tmem->page_count++;\n\t}\n\n#ifdef CONFIG_X86\n\tset_pages_array_uc(mem->pages, num_pages);\n#endif\n\tret = 0;\nout:\n\treturn ret;\n}\nEXPORT_SYMBOL(agp_generic_alloc_pages);\n\nstruct page *agp_generic_alloc_page(struct agp_bridge_data *bridge)\n{\n\tstruct page * page;\n\n\tpage = alloc_page(GFP_KERNEL | GFP_DMA32 | __GFP_ZERO);\n\tif (page == NULL)\n\t\treturn NULL;\n\n\tmap_page_into_agp(page);\n\n\tget_page(page);\n\tatomic_inc(&agp_bridge->current_memory_agp);\n\treturn page;\n}\nEXPORT_SYMBOL(agp_generic_alloc_page);\n\nvoid agp_generic_destroy_pages(struct agp_memory *mem)\n{\n\tint i;\n\tstruct page *page;\n\n\tif (!mem)\n\t\treturn;\n\n#ifdef CONFIG_X86\n\tset_pages_array_wb(mem->pages, mem->page_count);\n#endif\n\n\tfor (i = 0; i < mem->page_count; i++) {\n\t\tpage = mem->pages[i];\n\n#ifndef CONFIG_X86\n\t\tunmap_page_from_agp(page);\n#endif\n\t\tput_page(page);\n\t\t__free_page(page);\n\t\tatomic_dec(&agp_bridge->current_memory_agp);\n\t\tmem->pages[i] = NULL;\n\t}\n}\nEXPORT_SYMBOL(agp_generic_destroy_pages);\n\nvoid agp_generic_destroy_page(struct page *page, int flags)\n{\n\tif (page == NULL)\n\t\treturn;\n\n\tif (flags & AGP_PAGE_DESTROY_UNMAP)\n\t\tunmap_page_from_agp(page);\n\n\tif (flags & AGP_PAGE_DESTROY_FREE) {\n\t\tput_page(page);\n\t\t__free_page(page);\n\t\tatomic_dec(&agp_bridge->current_memory_agp);\n\t}\n}\nEXPORT_SYMBOL(agp_generic_destroy_page);\n\n \n\n\n \nvoid agp_enable(struct agp_bridge_data *bridge, u32 mode)\n{\n\tif (!bridge)\n\t\treturn;\n\tbridge->driver->agp_enable(bridge, mode);\n}\nEXPORT_SYMBOL(agp_enable);\n\n \n\nstruct agp_bridge_data *agp_generic_find_bridge(struct pci_dev *pdev)\n{\n\tif (list_empty(&agp_bridges))\n\t\treturn NULL;\n\n\treturn agp_bridge;\n}\n\nstatic void ipi_handler(void *null)\n{\n\tflush_agp_cache();\n}\n\nvoid global_cache_flush(void)\n{\n\ton_each_cpu(ipi_handler, NULL, 1);\n}\nEXPORT_SYMBOL(global_cache_flush);\n\nunsigned long agp_generic_mask_memory(struct agp_bridge_data *bridge,\n\t\t\t\t      dma_addr_t addr, int type)\n{\n\t \n\tif (bridge->driver->masks)\n\t\treturn addr | bridge->driver->masks[0].mask;\n\telse\n\t\treturn addr;\n}\nEXPORT_SYMBOL(agp_generic_mask_memory);\n\nint agp_generic_type_to_mask_type(struct agp_bridge_data *bridge,\n\t\t\t\t  int type)\n{\n\tif (type >= AGP_USER_TYPES)\n\t\treturn 0;\n\treturn type;\n}\nEXPORT_SYMBOL(agp_generic_type_to_mask_type);\n\n \n\nint agp3_generic_fetch_size(void)\n{\n\tu16 temp_size;\n\tint i;\n\tstruct aper_size_info_16 *values;\n\n\tpci_read_config_word(agp_bridge->dev, agp_bridge->capndx+AGPAPSIZE, &temp_size);\n\tvalues = A_SIZE_16(agp_bridge->driver->aperture_sizes);\n\n\tfor (i = 0; i < agp_bridge->driver->num_aperture_sizes; i++) {\n\t\tif (temp_size == values[i].size_value) {\n\t\t\tagp_bridge->previous_size =\n\t\t\t\tagp_bridge->current_size = (void *) (values + i);\n\n\t\t\tagp_bridge->aperture_size_idx = i;\n\t\t\treturn values[i].size;\n\t\t}\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(agp3_generic_fetch_size);\n\nvoid agp3_generic_tlbflush(struct agp_memory *mem)\n{\n\tu32 ctrl;\n\tpci_read_config_dword(agp_bridge->dev, agp_bridge->capndx+AGPCTRL, &ctrl);\n\tpci_write_config_dword(agp_bridge->dev, agp_bridge->capndx+AGPCTRL, ctrl & ~AGPCTRL_GTLBEN);\n\tpci_write_config_dword(agp_bridge->dev, agp_bridge->capndx+AGPCTRL, ctrl);\n}\nEXPORT_SYMBOL(agp3_generic_tlbflush);\n\nint agp3_generic_configure(void)\n{\n\tu32 temp;\n\tstruct aper_size_info_16 *current_size;\n\n\tcurrent_size = A_SIZE_16(agp_bridge->current_size);\n\n\tagp_bridge->gart_bus_addr = pci_bus_address(agp_bridge->dev,\n\t\t\t\t\t\t    AGP_APERTURE_BAR);\n\n\t \n\tpci_write_config_word(agp_bridge->dev, agp_bridge->capndx+AGPAPSIZE, current_size->size_value);\n\t \n\tpci_write_config_dword(agp_bridge->dev, agp_bridge->capndx+AGPGARTLO, agp_bridge->gatt_bus_addr);\n\t \n\tpci_read_config_dword(agp_bridge->dev, agp_bridge->capndx+AGPCTRL, &temp);\n\tpci_write_config_dword(agp_bridge->dev, agp_bridge->capndx+AGPCTRL, temp | AGPCTRL_APERENB | AGPCTRL_GTLBEN);\n\treturn 0;\n}\nEXPORT_SYMBOL(agp3_generic_configure);\n\nvoid agp3_generic_cleanup(void)\n{\n\tu32 ctrl;\n\tpci_read_config_dword(agp_bridge->dev, agp_bridge->capndx+AGPCTRL, &ctrl);\n\tpci_write_config_dword(agp_bridge->dev, agp_bridge->capndx+AGPCTRL, ctrl & ~AGPCTRL_APERENB);\n}\nEXPORT_SYMBOL(agp3_generic_cleanup);\n\nconst struct aper_size_info_16 agp3_generic_sizes[AGP_GENERIC_SIZES_ENTRIES] =\n{\n\t{4096, 1048576, 10,0x000},\n\t{2048,  524288, 9, 0x800},\n\t{1024,  262144, 8, 0xc00},\n\t{ 512,  131072, 7, 0xe00},\n\t{ 256,   65536, 6, 0xf00},\n\t{ 128,   32768, 5, 0xf20},\n\t{  64,   16384, 4, 0xf30},\n\t{  32,    8192, 3, 0xf38},\n\t{  16,    4096, 2, 0xf3c},\n\t{   8,    2048, 1, 0xf3e},\n\t{   4,    1024, 0, 0xf3f}\n};\nEXPORT_SYMBOL(agp3_generic_sizes);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}