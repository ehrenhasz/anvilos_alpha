{
  "module_name": "alpha-agp.c",
  "hash_id": "effc3cc6eef8274304fd923b75af6db306fd1139f57961fdab9c48f3404bf29a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/agp/alpha-agp.c",
  "human_readable_source": "#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/init.h>\n#include <linux/agp_backend.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\n#include <asm/machvec.h>\n#include <asm/agp_backend.h>\n#include \"../../../arch/alpha/kernel/pci_impl.h\"\n\n#include \"agp.h\"\n\nstatic vm_fault_t alpha_core_agp_vm_fault(struct vm_fault *vmf)\n{\n\talpha_agp_info *agp = agp_bridge->dev_private_data;\n\tdma_addr_t dma_addr;\n\tunsigned long pa;\n\tstruct page *page;\n\n\tdma_addr = vmf->address - vmf->vma->vm_start + agp->aperture.bus_base;\n\tpa = agp->ops->translate(agp, dma_addr);\n\n\tif (pa == (unsigned long)-EINVAL)\n\t\treturn VM_FAULT_SIGBUS;\t \n\n\t \n\tpage = virt_to_page(__va(pa));\n\tget_page(page);\n\tvmf->page = page;\n\treturn 0;\n}\n\nstatic struct aper_size_info_fixed alpha_core_agp_sizes[] =\n{\n\t{ 0, 0, 0 },  \n};\n\nstatic const struct vm_operations_struct alpha_core_agp_vm_ops = {\n\t.fault = alpha_core_agp_vm_fault,\n};\n\n\nstatic int alpha_core_agp_fetch_size(void)\n{\n\treturn alpha_core_agp_sizes[0].size;\n}\n\nstatic int alpha_core_agp_configure(void)\n{\n\talpha_agp_info *agp = agp_bridge->dev_private_data;\n\tagp_bridge->gart_bus_addr = agp->aperture.bus_base;\n\treturn 0;\n}\n\nstatic void alpha_core_agp_cleanup(void)\n{\n\talpha_agp_info *agp = agp_bridge->dev_private_data;\n\n\tagp->ops->cleanup(agp);\n}\n\nstatic void alpha_core_agp_tlbflush(struct agp_memory *mem)\n{\n\talpha_agp_info *agp = agp_bridge->dev_private_data;\n\talpha_mv.mv_pci_tbi(agp->hose, 0, -1);\n}\n\nstatic void alpha_core_agp_enable(struct agp_bridge_data *bridge, u32 mode)\n{\n\talpha_agp_info *agp = bridge->dev_private_data;\n\n\tagp->mode.lw = agp_collect_device_status(bridge, mode,\n\t\t\t\t\tagp->capability.lw);\n\n\tagp->mode.bits.enable = 1;\n\tagp->ops->configure(agp);\n\n\tagp_device_command(agp->mode.lw, false);\n}\n\nstatic int alpha_core_agp_insert_memory(struct agp_memory *mem, off_t pg_start,\n\t\t\t\t\tint type)\n{\n\talpha_agp_info *agp = agp_bridge->dev_private_data;\n\tint num_entries, status;\n\tvoid *temp;\n\n\tif (type >= AGP_USER_TYPES || mem->type >= AGP_USER_TYPES)\n\t\treturn -EINVAL;\n\n\ttemp = agp_bridge->current_size;\n\tnum_entries = A_SIZE_FIX(temp)->num_entries;\n\tif ((pg_start + mem->page_count) > num_entries)\n\t\treturn -EINVAL;\n\n\tstatus = agp->ops->bind(agp, pg_start, mem);\n\tmb();\n\talpha_core_agp_tlbflush(mem);\n\n\treturn status;\n}\n\nstatic int alpha_core_agp_remove_memory(struct agp_memory *mem, off_t pg_start,\n\t\t\t\t\tint type)\n{\n\talpha_agp_info *agp = agp_bridge->dev_private_data;\n\tint status;\n\n\tstatus = agp->ops->unbind(agp, pg_start, mem);\n\talpha_core_agp_tlbflush(mem);\n\treturn status;\n}\n\nstatic int alpha_core_agp_create_free_gatt_table(struct agp_bridge_data *a)\n{\n\treturn 0;\n}\n\nstruct agp_bridge_driver alpha_core_agp_driver = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.aperture_sizes\t\t= alpha_core_agp_sizes,\n\t.num_aperture_sizes\t= 1,\n\t.size_type\t\t= FIXED_APER_SIZE,\n\t.cant_use_aperture\t= true,\n\t.masks\t\t\t= NULL,\n\n\t.fetch_size\t\t= alpha_core_agp_fetch_size,\n\t.configure\t\t= alpha_core_agp_configure,\n\t.agp_enable\t\t= alpha_core_agp_enable,\n\t.cleanup\t\t= alpha_core_agp_cleanup,\n\t.tlb_flush\t\t= alpha_core_agp_tlbflush,\n\t.mask_memory\t\t= agp_generic_mask_memory,\n\t.cache_flush\t\t= global_cache_flush,\n\t.create_gatt_table\t= alpha_core_agp_create_free_gatt_table,\n\t.free_gatt_table\t= alpha_core_agp_create_free_gatt_table,\n\t.insert_memory\t\t= alpha_core_agp_insert_memory,\n\t.remove_memory\t\t= alpha_core_agp_remove_memory,\n\t.alloc_by_type\t\t= agp_generic_alloc_by_type,\n\t.free_by_type\t\t= agp_generic_free_by_type,\n\t.agp_alloc_page\t\t= agp_generic_alloc_page,\n\t.agp_alloc_pages\t= agp_generic_alloc_pages,\n\t.agp_destroy_page\t= agp_generic_destroy_page,\n\t.agp_destroy_pages\t= agp_generic_destroy_pages,\n\t.agp_type_to_mask_type  = agp_generic_type_to_mask_type,\n};\n\nstruct agp_bridge_data *alpha_bridge;\n\nint __init\nalpha_core_agp_setup(void)\n{\n\talpha_agp_info *agp = alpha_mv.agp_info();\n\tstruct pci_dev *pdev;\t \n\tstruct aper_size_info_fixed *aper_size;\n\n\tif (!agp)\n\t\treturn -ENODEV;\n\tif (agp->ops->setup(agp))\n\t\treturn -ENODEV;\n\n\t \n\taper_size = alpha_core_agp_sizes;\n\taper_size->size = agp->aperture.size / (1024 * 1024);\n\taper_size->num_entries = agp->aperture.size / PAGE_SIZE;\n\taper_size->page_order = __ffs(aper_size->num_entries / 1024);\n\n\t \n\tpdev = pci_alloc_dev(NULL);\n\tif (!pdev)\n\t\treturn -ENOMEM;\n\tpdev->vendor = 0xffff;\n\tpdev->device = 0xffff;\n\tpdev->sysdata = agp->hose;\n\n\talpha_bridge = agp_alloc_bridge();\n\tif (!alpha_bridge)\n\t\tgoto fail;\n\n\talpha_bridge->driver = &alpha_core_agp_driver;\n\talpha_bridge->vm_ops = &alpha_core_agp_vm_ops;\n\talpha_bridge->current_size = aper_size;  \n\talpha_bridge->dev_private_data = agp;\n\talpha_bridge->dev = pdev;\n\talpha_bridge->mode = agp->capability.lw;\n\n\tprintk(KERN_INFO PFX \"Detected AGP on hose %d\\n\", agp->hose->index);\n\treturn agp_add_bridge(alpha_bridge);\n\n fail:\n\tkfree(pdev);\n\treturn -ENOMEM;\n}\n\nstatic int __init agp_alpha_core_init(void)\n{\n\tif (agp_off)\n\t\treturn -EINVAL;\n\tif (alpha_mv.agp_info)\n\t\treturn alpha_core_agp_setup();\n\treturn -ENODEV;\n}\n\nstatic void __exit agp_alpha_core_cleanup(void)\n{\n\tagp_remove_bridge(alpha_bridge);\n\tagp_put_bridge(alpha_bridge);\n}\n\nmodule_init(agp_alpha_core_init);\nmodule_exit(agp_alpha_core_cleanup);\n\nMODULE_AUTHOR(\"Jeff Wiedemeier <Jeff.Wiedemeier@hp.com>\");\nMODULE_LICENSE(\"GPL and additional rights\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}