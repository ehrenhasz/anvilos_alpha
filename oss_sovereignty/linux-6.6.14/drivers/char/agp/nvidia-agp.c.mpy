{
  "module_name": "nvidia-agp.c",
  "hash_id": "100ca92cce7282de3bf8df047e97b3304fab9d0117f6eca0b7d54cb6949cece8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/agp/nvidia-agp.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/init.h>\n#include <linux/agp_backend.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/jiffies.h>\n#include \"agp.h\"\n\n \n#define NVIDIA_0_APSIZE\t\t0x80\n#define NVIDIA_1_WBC\t\t0xf0\n#define NVIDIA_2_GARTCTRL\t0xd0\n#define NVIDIA_2_APBASE\t\t0xd8\n#define NVIDIA_2_APLIMIT\t0xdc\n#define NVIDIA_2_ATTBASE(i)\t(0xe0 + (i) * 4)\n#define NVIDIA_3_APBASE\t\t0x50\n#define NVIDIA_3_APLIMIT\t0x54\n\n\nstatic struct _nvidia_private {\n\tstruct pci_dev *dev_1;\n\tstruct pci_dev *dev_2;\n\tstruct pci_dev *dev_3;\n\tvolatile u32 __iomem *aperture;\n\tint num_active_entries;\n\toff_t pg_offset;\n\tu32 wbc_mask;\n} nvidia_private;\n\n\nstatic int nvidia_fetch_size(void)\n{\n\tint i;\n\tu8 size_value;\n\tstruct aper_size_info_8 *values;\n\n\tpci_read_config_byte(agp_bridge->dev, NVIDIA_0_APSIZE, &size_value);\n\tsize_value &= 0x0f;\n\tvalues = A_SIZE_8(agp_bridge->driver->aperture_sizes);\n\n\tfor (i = 0; i < agp_bridge->driver->num_aperture_sizes; i++) {\n\t\tif (size_value == values[i].size_value) {\n\t\t\tagp_bridge->previous_size =\n\t\t\t\tagp_bridge->current_size = (void *) (values + i);\n\t\t\tagp_bridge->aperture_size_idx = i;\n\t\t\treturn values[i].size;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n#define SYSCFG          0xC0010010\n#define IORR_BASE0      0xC0010016\n#define IORR_MASK0      0xC0010017\n#define AMD_K7_NUM_IORR 2\n\nstatic int nvidia_init_iorr(u32 base, u32 size)\n{\n\tu32 base_hi, base_lo;\n\tu32 mask_hi, mask_lo;\n\tu32 sys_hi, sys_lo;\n\tu32 iorr_addr, free_iorr_addr;\n\n\t \n\t \n\tfree_iorr_addr = AMD_K7_NUM_IORR;\n\tfor (iorr_addr = 0; iorr_addr < AMD_K7_NUM_IORR; iorr_addr++) {\n\t\trdmsr(IORR_BASE0 + 2 * iorr_addr, base_lo, base_hi);\n\t\trdmsr(IORR_MASK0 + 2 * iorr_addr, mask_lo, mask_hi);\n\n\t\tif ((base_lo & 0xfffff000) == (base & 0xfffff000))\n\t\t\tbreak;\n\n\t\tif ((mask_lo & 0x00000800) == 0)\n\t\t\tfree_iorr_addr = iorr_addr;\n\t}\n\n\tif (iorr_addr >= AMD_K7_NUM_IORR) {\n\t\tiorr_addr = free_iorr_addr;\n\t\tif (iorr_addr >= AMD_K7_NUM_IORR)\n\t\t\treturn -EINVAL;\n\t}\n    base_hi = 0x0;\n    base_lo = (base & ~0xfff) | 0x18;\n    mask_hi = 0xf;\n    mask_lo = ((~(size - 1)) & 0xfffff000) | 0x800;\n    wrmsr(IORR_BASE0 + 2 * iorr_addr, base_lo, base_hi);\n    wrmsr(IORR_MASK0 + 2 * iorr_addr, mask_lo, mask_hi);\n\n    rdmsr(SYSCFG, sys_lo, sys_hi);\n    sys_lo |= 0x00100000;\n    wrmsr(SYSCFG, sys_lo, sys_hi);\n\n\treturn 0;\n}\n\nstatic int nvidia_configure(void)\n{\n\tint i, rc, num_dirs;\n\tu32 apbase, aplimit;\n\tphys_addr_t apbase_phys;\n\tstruct aper_size_info_8 *current_size;\n\tu32 temp;\n\n\tcurrent_size = A_SIZE_8(agp_bridge->current_size);\n\n\t \n\tpci_write_config_byte(agp_bridge->dev, NVIDIA_0_APSIZE,\n\t\tcurrent_size->size_value);\n\n\t \n\tapbase = pci_bus_address(agp_bridge->dev, AGP_APERTURE_BAR);\n\tagp_bridge->gart_bus_addr = apbase;\n\taplimit = apbase + (current_size->size * 1024 * 1024) - 1;\n\tpci_write_config_dword(nvidia_private.dev_2, NVIDIA_2_APBASE, apbase);\n\tpci_write_config_dword(nvidia_private.dev_2, NVIDIA_2_APLIMIT, aplimit);\n\tpci_write_config_dword(nvidia_private.dev_3, NVIDIA_3_APBASE, apbase);\n\tpci_write_config_dword(nvidia_private.dev_3, NVIDIA_3_APLIMIT, aplimit);\n\tif (0 != (rc = nvidia_init_iorr(apbase, current_size->size * 1024 * 1024)))\n\t\treturn rc;\n\n\t \n\tnum_dirs = current_size->size / 64;\n\tnvidia_private.num_active_entries = current_size->num_entries;\n\tnvidia_private.pg_offset = 0;\n\tif (num_dirs == 0) {\n\t\tnum_dirs = 1;\n\t\tnvidia_private.num_active_entries /= (64 / current_size->size);\n\t\tnvidia_private.pg_offset = (apbase & (64 * 1024 * 1024 - 1) &\n\t\t\t~(current_size->size * 1024 * 1024 - 1)) / PAGE_SIZE;\n\t}\n\n\t \n\tfor (i = 0; i < 8; i++) {\n\t\tpci_write_config_dword(nvidia_private.dev_2, NVIDIA_2_ATTBASE(i),\n\t\t\t(agp_bridge->gatt_bus_addr + (i % num_dirs) * 64 * 1024) | 1);\n\t}\n\n\t \n\tpci_read_config_dword(nvidia_private.dev_2, NVIDIA_2_GARTCTRL, &temp);\n\tpci_write_config_dword(nvidia_private.dev_2, NVIDIA_2_GARTCTRL, temp | 0x11);\n\n\t \n\tpci_read_config_dword(agp_bridge->dev, NVIDIA_0_APSIZE, &temp);\n\tpci_write_config_dword(agp_bridge->dev, NVIDIA_0_APSIZE, temp | 0x100);\n\n\t \n\tapbase_phys = pci_resource_start(agp_bridge->dev, AGP_APERTURE_BAR);\n\tnvidia_private.aperture =\n\t\t(volatile u32 __iomem *) ioremap(apbase_phys, 33 * PAGE_SIZE);\n\n\tif (!nvidia_private.aperture)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void nvidia_cleanup(void)\n{\n\tstruct aper_size_info_8 *previous_size;\n\tu32 temp;\n\n\t \n\tpci_read_config_dword(agp_bridge->dev, NVIDIA_0_APSIZE, &temp);\n\tpci_write_config_dword(agp_bridge->dev, NVIDIA_0_APSIZE, temp & ~(0x100));\n\n\t \n\tpci_read_config_dword(nvidia_private.dev_2, NVIDIA_2_GARTCTRL, &temp);\n\tpci_write_config_dword(nvidia_private.dev_2, NVIDIA_2_GARTCTRL, temp & ~(0x11));\n\n\t \n\tiounmap((void __iomem *) nvidia_private.aperture);\n\n\t \n\tprevious_size = A_SIZE_8(agp_bridge->previous_size);\n\tpci_write_config_byte(agp_bridge->dev, NVIDIA_0_APSIZE,\n\t\tprevious_size->size_value);\n\n\t \n\tnvidia_init_iorr(agp_bridge->gart_bus_addr,\n\t\tprevious_size->size * 1024 * 1024);\n}\n\n\n \nextern int agp_memory_reserved;\n\nstatic int nvidia_insert_memory(struct agp_memory *mem, off_t pg_start, int type)\n{\n\tint i, j;\n\tint mask_type;\n\n\tmask_type = agp_generic_type_to_mask_type(mem->bridge, type);\n\tif (mask_type != 0 || type != mem->type)\n\t\treturn -EINVAL;\n\n\tif (mem->page_count == 0)\n\t\treturn 0;\n\n\tif ((pg_start + mem->page_count) >\n\t\t(nvidia_private.num_active_entries - agp_memory_reserved/PAGE_SIZE))\n\t\treturn -EINVAL;\n\n\tfor (j = pg_start; j < (pg_start + mem->page_count); j++) {\n\t\tif (!PGE_EMPTY(agp_bridge, readl(agp_bridge->gatt_table+nvidia_private.pg_offset+j)))\n\t\t\treturn -EBUSY;\n\t}\n\n\tif (!mem->is_flushed) {\n\t\tglobal_cache_flush();\n\t\tmem->is_flushed = true;\n\t}\n\tfor (i = 0, j = pg_start; i < mem->page_count; i++, j++) {\n\t\twritel(agp_bridge->driver->mask_memory(agp_bridge,\n\t\t\t       page_to_phys(mem->pages[i]), mask_type),\n\t\t\tagp_bridge->gatt_table+nvidia_private.pg_offset+j);\n\t}\n\n\t \n\treadl(agp_bridge->gatt_table+nvidia_private.pg_offset+j - 1);\n\n\tagp_bridge->driver->tlb_flush(mem);\n\treturn 0;\n}\n\n\nstatic int nvidia_remove_memory(struct agp_memory *mem, off_t pg_start, int type)\n{\n\tint i;\n\n\tint mask_type;\n\n\tmask_type = agp_generic_type_to_mask_type(mem->bridge, type);\n\tif (mask_type != 0 || type != mem->type)\n\t\treturn -EINVAL;\n\n\tif (mem->page_count == 0)\n\t\treturn 0;\n\n\tfor (i = pg_start; i < (mem->page_count + pg_start); i++)\n\t\twritel(agp_bridge->scratch_page, agp_bridge->gatt_table+nvidia_private.pg_offset+i);\n\n\tagp_bridge->driver->tlb_flush(mem);\n\treturn 0;\n}\n\n\nstatic void nvidia_tlbflush(struct agp_memory *mem)\n{\n\tunsigned long end;\n\tu32 wbc_reg;\n\tu32 __maybe_unused temp;\n\tint i;\n\n\t \n\tif (nvidia_private.wbc_mask) {\n\t\tpci_read_config_dword(nvidia_private.dev_1, NVIDIA_1_WBC, &wbc_reg);\n\t\twbc_reg |= nvidia_private.wbc_mask;\n\t\tpci_write_config_dword(nvidia_private.dev_1, NVIDIA_1_WBC, wbc_reg);\n\n\t\tend = jiffies + 3*HZ;\n\t\tdo {\n\t\t\tpci_read_config_dword(nvidia_private.dev_1,\n\t\t\t\t\tNVIDIA_1_WBC, &wbc_reg);\n\t\t\tif (time_before_eq(end, jiffies)) {\n\t\t\t\tprintk(KERN_ERR PFX\n\t\t\t\t    \"TLB flush took more than 3 seconds.\\n\");\n\t\t\t}\n\t\t} while (wbc_reg & nvidia_private.wbc_mask);\n\t}\n\n\t \n\tfor (i = 0; i < 32 + 1; i++)\n\t\ttemp = readl(nvidia_private.aperture+(i * PAGE_SIZE / sizeof(u32)));\n\tfor (i = 0; i < 32 + 1; i++)\n\t\ttemp = readl(nvidia_private.aperture+(i * PAGE_SIZE / sizeof(u32)));\n}\n\n\nstatic const struct aper_size_info_8 nvidia_generic_sizes[5] =\n{\n\t{512, 131072, 7, 0},\n\t{256, 65536, 6, 8},\n\t{128, 32768, 5, 12},\n\t{64, 16384, 4, 14},\n\t \n\t{32, 16384, 4, 15}\n};\n\n\nstatic const struct gatt_mask nvidia_generic_masks[] =\n{\n\t{ .mask = 1, .type = 0}\n};\n\n\nstatic const struct agp_bridge_driver nvidia_driver = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.aperture_sizes\t\t= nvidia_generic_sizes,\n\t.size_type\t\t= U8_APER_SIZE,\n\t.num_aperture_sizes\t= 5,\n\t.needs_scratch_page\t= true,\n\t.configure\t\t= nvidia_configure,\n\t.fetch_size\t\t= nvidia_fetch_size,\n\t.cleanup\t\t= nvidia_cleanup,\n\t.tlb_flush\t\t= nvidia_tlbflush,\n\t.mask_memory\t\t= agp_generic_mask_memory,\n\t.masks\t\t\t= nvidia_generic_masks,\n\t.agp_enable\t\t= agp_generic_enable,\n\t.cache_flush\t\t= global_cache_flush,\n\t.create_gatt_table\t= agp_generic_create_gatt_table,\n\t.free_gatt_table\t= agp_generic_free_gatt_table,\n\t.insert_memory\t\t= nvidia_insert_memory,\n\t.remove_memory\t\t= nvidia_remove_memory,\n\t.alloc_by_type\t\t= agp_generic_alloc_by_type,\n\t.free_by_type\t\t= agp_generic_free_by_type,\n\t.agp_alloc_page\t\t= agp_generic_alloc_page,\n\t.agp_alloc_pages\t= agp_generic_alloc_pages,\n\t.agp_destroy_page\t= agp_generic_destroy_page,\n\t.agp_destroy_pages\t= agp_generic_destroy_pages,\n\t.agp_type_to_mask_type  = agp_generic_type_to_mask_type,\n};\n\nstatic int agp_nvidia_probe(struct pci_dev *pdev,\n\t\t\t    const struct pci_device_id *ent)\n{\n\tstruct agp_bridge_data *bridge;\n\tu8 cap_ptr;\n\n\tnvidia_private.dev_1 =\n\t\tpci_get_domain_bus_and_slot(pci_domain_nr(pdev->bus),\n\t\t\t\t\t    (unsigned int)pdev->bus->number,\n\t\t\t\t\t    PCI_DEVFN(0, 1));\n\tnvidia_private.dev_2 =\n\t\tpci_get_domain_bus_and_slot(pci_domain_nr(pdev->bus),\n\t\t\t\t\t    (unsigned int)pdev->bus->number,\n\t\t\t\t\t    PCI_DEVFN(0, 2));\n\tnvidia_private.dev_3 =\n\t\tpci_get_domain_bus_and_slot(pci_domain_nr(pdev->bus),\n\t\t\t\t\t    (unsigned int)pdev->bus->number,\n\t\t\t\t\t    PCI_DEVFN(30, 0));\n\n\tif (!nvidia_private.dev_1 || !nvidia_private.dev_2 || !nvidia_private.dev_3) {\n\t\tprintk(KERN_INFO PFX \"Detected an NVIDIA nForce/nForce2 \"\n\t\t\t\"chipset, but could not find the secondary devices.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tcap_ptr = pci_find_capability(pdev, PCI_CAP_ID_AGP);\n\tif (!cap_ptr)\n\t\treturn -ENODEV;\n\n\tswitch (pdev->device) {\n\tcase PCI_DEVICE_ID_NVIDIA_NFORCE:\n\t\tprintk(KERN_INFO PFX \"Detected NVIDIA nForce chipset\\n\");\n\t\tnvidia_private.wbc_mask = 0x00010000;\n\t\tbreak;\n\tcase PCI_DEVICE_ID_NVIDIA_NFORCE2:\n\t\tprintk(KERN_INFO PFX \"Detected NVIDIA nForce2 chipset\\n\");\n\t\tnvidia_private.wbc_mask = 0x80000000;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR PFX \"Unsupported NVIDIA chipset (device id: %04x)\\n\",\n\t\t\t    pdev->device);\n\t\treturn -ENODEV;\n\t}\n\n\tbridge = agp_alloc_bridge();\n\tif (!bridge)\n\t\treturn -ENOMEM;\n\n\tbridge->driver = &nvidia_driver;\n\tbridge->dev_private_data = &nvidia_private;\n\tbridge->dev = pdev;\n\tbridge->capndx = cap_ptr;\n\n\t \n\tpci_read_config_dword(pdev,\n\t\t\tbridge->capndx+PCI_AGP_STATUS,\n\t\t\t&bridge->mode);\n\n\tpci_set_drvdata(pdev, bridge);\n\treturn agp_add_bridge(bridge);\n}\n\nstatic void agp_nvidia_remove(struct pci_dev *pdev)\n{\n\tstruct agp_bridge_data *bridge = pci_get_drvdata(pdev);\n\n\tagp_remove_bridge(bridge);\n\tagp_put_bridge(bridge);\n}\n\nstatic int agp_nvidia_resume(struct device *dev)\n{\n\t \n\tnvidia_configure();\n\n\treturn 0;\n}\n\nstatic const struct pci_device_id agp_nvidia_pci_table[] = {\n\t{\n\t.class\t\t= (PCI_CLASS_BRIDGE_HOST << 8),\n\t.class_mask\t= ~0,\n\t.vendor\t\t= PCI_VENDOR_ID_NVIDIA,\n\t.device\t\t= PCI_DEVICE_ID_NVIDIA_NFORCE,\n\t.subvendor\t= PCI_ANY_ID,\n\t.subdevice\t= PCI_ANY_ID,\n\t},\n\t{\n\t.class\t\t= (PCI_CLASS_BRIDGE_HOST << 8),\n\t.class_mask\t= ~0,\n\t.vendor\t\t= PCI_VENDOR_ID_NVIDIA,\n\t.device\t\t= PCI_DEVICE_ID_NVIDIA_NFORCE2,\n\t.subvendor\t= PCI_ANY_ID,\n\t.subdevice\t= PCI_ANY_ID,\n\t},\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(pci, agp_nvidia_pci_table);\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(agp_nvidia_pm_ops, NULL, agp_nvidia_resume);\n\nstatic struct pci_driver agp_nvidia_pci_driver = {\n\t.name\t\t= \"agpgart-nvidia\",\n\t.id_table\t= agp_nvidia_pci_table,\n\t.probe\t\t= agp_nvidia_probe,\n\t.remove\t\t= agp_nvidia_remove,\n\t.driver.pm\t= &agp_nvidia_pm_ops,\n};\n\nstatic int __init agp_nvidia_init(void)\n{\n\tif (agp_off)\n\t\treturn -EINVAL;\n\treturn pci_register_driver(&agp_nvidia_pci_driver);\n}\n\nstatic void __exit agp_nvidia_cleanup(void)\n{\n\tpci_unregister_driver(&agp_nvidia_pci_driver);\n\tpci_dev_put(nvidia_private.dev_1);\n\tpci_dev_put(nvidia_private.dev_2);\n\tpci_dev_put(nvidia_private.dev_3);\n}\n\nmodule_init(agp_nvidia_init);\nmodule_exit(agp_nvidia_cleanup);\n\nMODULE_LICENSE(\"GPL and additional rights\");\nMODULE_AUTHOR(\"NVIDIA Corporation\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}