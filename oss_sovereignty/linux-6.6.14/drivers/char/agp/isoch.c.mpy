{
  "module_name": "isoch.c",
  "hash_id": "d7fa7aba41a3d73b71ca8c0a6948204835df118f373884b79a115c48140b3bc3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/agp/isoch.c",
  "human_readable_source": "\n \n\n#include <linux/list.h>\n#include <linux/pci.h>\n#include <linux/agp_backend.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include \"agp.h\"\n\n \n\nstruct agp_3_5_dev {\n\tstruct list_head list;\n\tu8 capndx;\n\tu32 maxbw;\n\tstruct pci_dev *dev;\n};\n\nstatic void agp_3_5_dev_list_insert(struct list_head *head, struct list_head *new)\n{\n\tstruct agp_3_5_dev *cur, *n = list_entry(new, struct agp_3_5_dev, list);\n\tstruct list_head *pos;\n\n\tlist_for_each(pos, head) {\n\t\tcur = list_entry(pos, struct agp_3_5_dev, list);\n\t\tif (cur->maxbw > n->maxbw)\n\t\t\tbreak;\n\t}\n\tlist_add_tail(new, pos);\n}\n\nstatic void agp_3_5_dev_list_sort(struct agp_3_5_dev *list, unsigned int ndevs)\n{\n\tstruct agp_3_5_dev *cur;\n\tstruct pci_dev *dev;\n\tstruct list_head *pos, *tmp, *head = &list->list, *start = head->next;\n\tu32 nistat;\n\n\tINIT_LIST_HEAD(head);\n\n\tfor (pos=start; pos!=head; ) {\n\t\tcur = list_entry(pos, struct agp_3_5_dev, list);\n\t\tdev = cur->dev;\n\n\t\tpci_read_config_dword(dev, cur->capndx+AGPNISTAT, &nistat);\n\t\tcur->maxbw = (nistat >> 16) & 0xff;\n\n\t\ttmp = pos;\n\t\tpos = pos->next;\n\t\tagp_3_5_dev_list_insert(head, tmp);\n\t}\n}\n\n \n\nstatic int agp_3_5_isochronous_node_enable(struct agp_bridge_data *bridge,\n\t\tstruct agp_3_5_dev *dev_list, unsigned int ndevs)\n{\n\t \n\tstruct isoch_data {\n\t\tu32 maxbw;\n\t\tu32 n;\n\t\tu32 y;\n\t\tu32 l;\n\t\tu32 rq;\n\t\tstruct agp_3_5_dev *dev;\n\t};\n\n\tstruct pci_dev *td = bridge->dev, *dev;\n\tstruct list_head *head = &dev_list->list, *pos;\n\tstruct agp_3_5_dev *cur;\n\tstruct isoch_data *master, target;\n\tunsigned int cdev = 0;\n\tu32 mnistat, tnistat, tstatus, mcmd;\n\tu16 tnicmd, mnicmd;\n\tu32 tot_bw = 0, tot_n = 0, tot_rq = 0, y_max, rq_isoch, rq_async;\n\tu32 step, rem, rem_isoch, rem_async;\n\tint ret = 0;\n\n\t \n\tmaster = kmalloc_array(ndevs, sizeof(*master), GFP_KERNEL);\n\tif (master == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto get_out;\n\t}\n\n\t \n\tagp_3_5_dev_list_sort(dev_list, ndevs);\n\n\tpci_read_config_dword(td, bridge->capndx+AGPNISTAT, &tnistat);\n\tpci_read_config_dword(td, bridge->capndx+AGPSTAT, &tstatus);\n\n\t \n\ttarget.maxbw = (tnistat >> 16) & 0xff;\n\ttarget.n     = (tnistat >> 8)  & 0xff;\n\ttarget.y     = (tnistat >> 6)  & 0x3;\n\ttarget.l     = (tnistat >> 3)  & 0x7;\n\ttarget.rq    = (tstatus >> 24) & 0xff;\n\n\ty_max = target.y;\n\n\t \n\tlist_for_each(pos, head) {\n\t\tcur = list_entry(pos, struct agp_3_5_dev, list);\n\t\tdev = cur->dev;\n\n\t\tpci_read_config_dword(dev, cur->capndx+AGPNISTAT, &mnistat);\n\n\t\tmaster[cdev].maxbw = (mnistat >> 16) & 0xff;\n\t\tmaster[cdev].n     = (mnistat >> 8)  & 0xff;\n\t\tmaster[cdev].y     = (mnistat >> 6)  & 0x3;\n\t\tmaster[cdev].dev   = cur;\n\n\t\ttot_bw += master[cdev].maxbw;\n\t\ty_max = max(y_max, master[cdev].y);\n\n\t\tcdev++;\n\t}\n\n\t \n\tif (tot_bw > target.maxbw) {\n\t\tdev_err(&td->dev, \"isochronous bandwidth required \"\n\t\t\t\"by AGP 3.0 devices exceeds that which is supported by \"\n\t\t\t\"the AGP 3.0 bridge!\\n\");\n\t\tret = -ENODEV;\n\t\tgoto free_and_exit;\n\t}\n\n\ttarget.y = y_max;\n\n\t \n\tpci_read_config_word(td, bridge->capndx+AGPNICMD, &tnicmd);\n\ttnicmd &= ~(0x3 << 6);\n\ttnicmd |= target.y << 6;\n\tpci_write_config_word(td, bridge->capndx+AGPNICMD, tnicmd);\n\n\t \n\tpci_read_config_dword(td, bridge->capndx+AGPNISTAT, &tnistat);\n\ttarget.n = (tnistat >> 8) & 0xff;\n\n\t \n\tfor (cdev=0; cdev<ndevs; cdev++) {\n\t\tmaster[cdev].y = target.y;\n\t\tmaster[cdev].n = master[cdev].maxbw / (master[cdev].y + 1);\n\n\t\ttot_n += master[cdev].n;\n\t}\n\n\t \n\tif (tot_n > target.n) {\n\t\tdev_err(&td->dev, \"number of isochronous \"\n\t\t\t\"transactions per period required by AGP 3.0 devices \"\n\t\t\t\"exceeds that which is supported by the AGP 3.0 \"\n\t\t\t\"bridge!\\n\");\n\t\tret = -ENODEV;\n\t\tgoto free_and_exit;\n\t}\n\n\t \n\trem  = target.n - tot_n;\n\n\t \n\tfor (cdev=0; cdev<ndevs; cdev++) {\n\t\t \n\t\tmaster[cdev].rq = master[cdev].n;\n\t\tif (master[cdev].y > 0x1)\n\t\t\tmaster[cdev].rq *= (1 << (master[cdev].y - 1));\n\n\t\ttot_rq += master[cdev].rq;\n\t}\n\tmaster[ndevs-1].n += rem;\n\n\t \n\trq_isoch = (target.y > 0x1) ? target.n * (1 << (target.y - 1)) : target.n;\n\trq_async = target.rq - rq_isoch;\n\n\t \n\tif (tot_rq > rq_isoch) {\n\t\tdev_err(&td->dev, \"number of request queue slots \"\n\t\t\t\"required by the isochronous bandwidth requested by \"\n\t\t\t\"AGP 3.0 devices exceeds the number provided by the \"\n\t\t\t\"AGP 3.0 bridge!\\n\");\n\t\tret = -ENODEV;\n\t\tgoto free_and_exit;\n\t}\n\n\t \n\tstep      = rq_async / ndevs;\n\trem_async = step + (rq_async % ndevs);\n\trem_isoch = rq_isoch - tot_rq;\n\n\t \n\tfor (cdev=0; cdev<ndevs; cdev++) {\n\t\tcur = master[cdev].dev;\n\t\tdev = cur->dev;\n\n\t\tmaster[cdev].rq += (cdev == ndevs - 1)\n\t\t              ? (rem_async + rem_isoch) : step;\n\n\t\tpci_read_config_word(dev, cur->capndx+AGPNICMD, &mnicmd);\n\t\tpci_read_config_dword(dev, cur->capndx+AGPCMD, &mcmd);\n\n\t\tmnicmd &= ~(0xff << 8);\n\t\tmnicmd &= ~(0x3  << 6);\n\t\tmcmd   &= ~(0xff << 24);\n\n\t\tmnicmd |= master[cdev].n  << 8;\n\t\tmnicmd |= master[cdev].y  << 6;\n\t\tmcmd   |= master[cdev].rq << 24;\n\n\t\tpci_write_config_dword(dev, cur->capndx+AGPCMD, mcmd);\n\t\tpci_write_config_word(dev, cur->capndx+AGPNICMD, mnicmd);\n\t}\n\nfree_and_exit:\n\tkfree(master);\n\nget_out:\n\treturn ret;\n}\n\n \nstatic void agp_3_5_nonisochronous_node_enable(struct agp_bridge_data *bridge,\n\t\tstruct agp_3_5_dev *dev_list, unsigned int ndevs)\n{\n\tstruct agp_3_5_dev *cur;\n\tstruct list_head *head = &dev_list->list, *pos;\n\tu32 tstatus, mcmd;\n\tu32 trq, mrq, rem;\n\tunsigned int cdev = 0;\n\n\tpci_read_config_dword(bridge->dev, bridge->capndx+AGPSTAT, &tstatus);\n\n\ttrq = (tstatus >> 24) & 0xff;\n\tmrq = trq / ndevs;\n\n\trem = mrq + (trq % ndevs);\n\n\tfor (pos=head->next; cdev<ndevs; cdev++, pos=pos->next) {\n\t\tcur = list_entry(pos, struct agp_3_5_dev, list);\n\n\t\tpci_read_config_dword(cur->dev, cur->capndx+AGPCMD, &mcmd);\n\t\tmcmd &= ~(0xff << 24);\n\t\tmcmd |= ((cdev == ndevs - 1) ? rem : mrq) << 24;\n\t\tpci_write_config_dword(cur->dev, cur->capndx+AGPCMD, mcmd);\n\t}\n}\n\n \nint agp_3_5_enable(struct agp_bridge_data *bridge)\n{\n\tstruct pci_dev *td = bridge->dev, *dev = NULL;\n\tu8 mcapndx;\n\tu32 isoch;\n\tu32 tstatus, mstatus, ncapid;\n\tu32 mmajor;\n\tu16 mpstat;\n\tstruct agp_3_5_dev *dev_list, *cur;\n\tstruct list_head *head, *pos;\n\tunsigned int ndevs = 0;\n\tint ret = 0;\n\n\t \n\tpci_read_config_dword(td, bridge->capndx+AGPSTAT, &tstatus);\n\tisoch     = (tstatus >> 17) & 0x1;\n\tif (isoch == 0)\t \n\t\treturn -ENODEV;\n\n\t \n\tif ((dev_list = kmalloc(sizeof(*dev_list), GFP_KERNEL)) == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto get_out;\n\t}\n\thead = &dev_list->list;\n\tINIT_LIST_HEAD(head);\n\n\t \n\tfor_each_pci_dev(dev) {\n\t\tmcapndx = pci_find_capability(dev, PCI_CAP_ID_AGP);\n\t\tif (mcapndx == 0)\n\t\t\tcontinue;\n\n\t\tswitch ((dev->class >>8) & 0xff00) {\n\t\t\tcase 0x0600:     \n\t\t\t\t \n\t\t\t\tcontinue;\n\n\t\t\tcase 0x0001:     \n\t\t\t\t \n\t\t\t\tif (mcapndx != 0) {\n\t\t\t\t\tdev_info(&td->dev, \"wacky, found unclassified AGP device %s [%04x/%04x]\\n\",\n\t\t\t\t\t\t pci_name(dev),\n\t\t\t\t\t\t dev->vendor, dev->device);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\n\t\t\tcase 0x0300:     \n\t\t\tcase 0x0400:     \n\t\t\t\tif ((cur = kmalloc(sizeof(*cur), GFP_KERNEL)) == NULL) {\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\tgoto free_and_exit;\n\t\t\t\t}\n\t\t\t\tcur->dev = dev;\n\n\t\t\t\tpos = &cur->list;\n\t\t\t\tlist_add(pos, head);\n\t\t\t\tndevs++;\n\t\t\t\tcontinue;\n\n\t\t\tdefault:\n\t\t\t\tcontinue;\n\t\t}\n\t}\n\n\t \n\tlist_for_each(pos, head) {\n\t\tcur = list_entry(pos, struct agp_3_5_dev, list);\n\t\tdev = cur->dev;\n\n\t\tpci_read_config_word(dev, PCI_STATUS, &mpstat);\n\t\tif ((mpstat & PCI_STATUS_CAP_LIST) == 0)\n\t\t\tcontinue;\n\n\t\tpci_read_config_byte(dev, PCI_CAPABILITY_LIST, &mcapndx);\n\t\tif (mcapndx != 0) {\n\t\t\tdo {\n\t\t\t\tpci_read_config_dword(dev, mcapndx, &ncapid);\n\t\t\t\tif ((ncapid & 0xff) != 2)\n\t\t\t\t\tmcapndx = (ncapid >> 8) & 0xff;\n\t\t\t}\n\t\t\twhile (((ncapid & 0xff) != 2) && (mcapndx != 0));\n\t\t}\n\n\t\tif (mcapndx == 0) {\n\t\t\tdev_err(&td->dev, \"woah!  Non-AGP device %s on \"\n\t\t\t\t\"secondary bus of AGP 3.5 bridge!\\n\",\n\t\t\t\tpci_name(dev));\n\t\t\tret = -ENODEV;\n\t\t\tgoto free_and_exit;\n\t\t}\n\n\t\tmmajor = (ncapid >> AGP_MAJOR_VERSION_SHIFT) & 0xf;\n\t\tif (mmajor < 3) {\n\t\t\tdev_err(&td->dev, \"woah!  AGP 2.0 device %s on \"\n\t\t\t\t\"secondary bus of AGP 3.5 bridge operating \"\n\t\t\t\t\"with AGP 3.0 electricals!\\n\", pci_name(dev));\n\t\t\tret = -ENODEV;\n\t\t\tgoto free_and_exit;\n\t\t}\n\n\t\tcur->capndx = mcapndx;\n\n\t\tpci_read_config_dword(dev, cur->capndx+AGPSTAT, &mstatus);\n\n\t\tif (((mstatus >> 3) & 0x1) == 0) {\n\t\t\tdev_err(&td->dev, \"woah!  AGP 3.x device %s not \"\n\t\t\t\t\"operating in AGP 3.x mode on secondary bus \"\n\t\t\t\t\"of AGP 3.5 bridge operating with AGP 3.0 \"\n\t\t\t\t\"electricals!\\n\", pci_name(dev));\n\t\t\tret = -ENODEV;\n\t\t\tgoto free_and_exit;\n\t\t}\n\t}\t\t\n\n\t \n\tif (isoch) {\n\t\tret = agp_3_5_isochronous_node_enable(bridge, dev_list, ndevs);\n\t\tif (ret) {\n\t\t\tdev_info(&td->dev, \"something bad happened setting \"\n\t\t\t\t \"up isochronous xfers; falling back to \"\n\t\t\t\t \"non-isochronous xfer mode\\n\");\n\t\t} else {\n\t\t\tgoto free_and_exit;\n\t\t}\n\t}\n\tagp_3_5_nonisochronous_node_enable(bridge, dev_list, ndevs);\n\nfree_and_exit:\n\t \n\tfor (pos=head->next; pos!=head; ) {\n\t\tcur = list_entry(pos, struct agp_3_5_dev, list);\n\n\t\tpos = pos->next;\n\t\tkfree(cur);\n\t}\n\tkfree(dev_list);\n\nget_out:\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}