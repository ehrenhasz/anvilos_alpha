{
  "module_name": "hp-agp.c",
  "hash_id": "08acb72398cddcceb408d9840cf87fafcfb43c8f68422cb9d8ceedf11435e853",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/agp/hp-agp.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/init.h>\n#include <linux/agp_backend.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n\n#include <asm/acpi-ext.h>\n\n#include \"agp.h\"\n\n#define HP_ZX1_IOC_OFFSET\t0x1000   \n\n \n#define HP_ZX1_IBASE\t\t0x300\n#define HP_ZX1_IMASK\t\t0x308\n#define HP_ZX1_PCOM\t\t0x310\n#define HP_ZX1_TCNFG\t\t0x318\n#define HP_ZX1_PDIR_BASE\t0x320\n\n#define HP_ZX1_IOVA_BASE\tGB(1UL)\n#define HP_ZX1_IOVA_SIZE\tGB(1UL)\n#define HP_ZX1_GART_SIZE\t(HP_ZX1_IOVA_SIZE / 2)\n#define HP_ZX1_SBA_IOMMU_COOKIE\t0x0000badbadc0ffeeUL\n\n#define HP_ZX1_PDIR_VALID_BIT\t0x8000000000000000UL\n#define HP_ZX1_IOVA_TO_PDIR(va)\t((va - hp_private.iova_base) >> hp_private.io_tlb_shift)\n\n#define AGP8X_MODE_BIT\t\t3\n#define AGP8X_MODE\t\t(1 << AGP8X_MODE_BIT)\n\n \nstatic struct pci_dev fake_bridge_dev;\n\nstatic int hp_zx1_gart_found;\n\nstatic struct aper_size_info_fixed hp_zx1_sizes[] =\n{\n\t{0, 0, 0},\t\t \n};\n\nstatic struct gatt_mask hp_zx1_masks[] =\n{\n\t{.mask = HP_ZX1_PDIR_VALID_BIT, .type = 0}\n};\n\nstatic struct _hp_private {\n\tvolatile u8 __iomem *ioc_regs;\n\tvolatile u8 __iomem *lba_regs;\n\tint lba_cap_offset;\n\tu64 *io_pdir;\t\t\n\tu64 *gatt;\t\t\n\tu64 gatt_entries;\n\tu64 iova_base;\n\tu64 gart_base;\n\tu64 gart_size;\n\tu64 io_pdir_size;\n\tint io_pdir_owner;\t\n\tint io_page_size;\n\tint io_tlb_shift;\n\tint io_tlb_ps;\t\t\n\tint io_pages_per_kpage;\n} hp_private;\n\nstatic int __init hp_zx1_ioc_shared(void)\n{\n\tstruct _hp_private *hp = &hp_private;\n\n\tprintk(KERN_INFO PFX \"HP ZX1 IOC: IOPDIR shared with sba_iommu\\n\");\n\n\t \n\thp->io_tlb_ps = readq(hp->ioc_regs+HP_ZX1_TCNFG);\n\tswitch (hp->io_tlb_ps) {\n\t\tcase 0: hp->io_tlb_shift = 12; break;\n\t\tcase 1: hp->io_tlb_shift = 13; break;\n\t\tcase 2: hp->io_tlb_shift = 14; break;\n\t\tcase 3: hp->io_tlb_shift = 16; break;\n\t\tdefault:\n\t\t\tprintk(KERN_ERR PFX \"Invalid IOTLB page size \"\n\t\t\t       \"configuration 0x%x\\n\", hp->io_tlb_ps);\n\t\t\thp->gatt = NULL;\n\t\t\thp->gatt_entries = 0;\n\t\t\treturn -ENODEV;\n\t}\n\thp->io_page_size = 1 << hp->io_tlb_shift;\n\thp->io_pages_per_kpage = PAGE_SIZE / hp->io_page_size;\n\n\thp->iova_base = readq(hp->ioc_regs+HP_ZX1_IBASE) & ~0x1;\n\thp->gart_base = hp->iova_base + HP_ZX1_IOVA_SIZE - HP_ZX1_GART_SIZE;\n\n\thp->gart_size = HP_ZX1_GART_SIZE;\n\thp->gatt_entries = hp->gart_size / hp->io_page_size;\n\n\thp->io_pdir = phys_to_virt(readq(hp->ioc_regs+HP_ZX1_PDIR_BASE));\n\thp->gatt = &hp->io_pdir[HP_ZX1_IOVA_TO_PDIR(hp->gart_base)];\n\n\tif (hp->gatt[0] != HP_ZX1_SBA_IOMMU_COOKIE) {\n\t\t \n\t\thp->gatt = NULL;\n\t\thp->gatt_entries = 0;\n\t\tprintk(KERN_ERR PFX \"No reserved IO PDIR entry found; \"\n\t\t       \"GART disabled\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int __init\nhp_zx1_ioc_owner (void)\n{\n\tstruct _hp_private *hp = &hp_private;\n\n\tprintk(KERN_INFO PFX \"HP ZX1 IOC: IOPDIR dedicated to GART\\n\");\n\n\t \n\tif (PAGE_SIZE >= KB(64)) {\n\t\thp->io_tlb_shift = 16;\n\t\thp->io_tlb_ps = 3;\n\t} else if (PAGE_SIZE >= KB(16)) {\n\t\thp->io_tlb_shift = 14;\n\t\thp->io_tlb_ps = 2;\n\t} else if (PAGE_SIZE >= KB(8)) {\n\t\thp->io_tlb_shift = 13;\n\t\thp->io_tlb_ps = 1;\n\t} else {\n\t\thp->io_tlb_shift = 12;\n\t\thp->io_tlb_ps = 0;\n\t}\n\thp->io_page_size = 1 << hp->io_tlb_shift;\n\thp->io_pages_per_kpage = PAGE_SIZE / hp->io_page_size;\n\n\thp->iova_base = HP_ZX1_IOVA_BASE;\n\thp->gart_size = HP_ZX1_GART_SIZE;\n\thp->gart_base = hp->iova_base + HP_ZX1_IOVA_SIZE - hp->gart_size;\n\n\thp->gatt_entries = hp->gart_size / hp->io_page_size;\n\thp->io_pdir_size = (HP_ZX1_IOVA_SIZE / hp->io_page_size) * sizeof(u64);\n\n\treturn 0;\n}\n\nstatic int __init\nhp_zx1_ioc_init (u64 hpa)\n{\n\tstruct _hp_private *hp = &hp_private;\n\n\thp->ioc_regs = ioremap(hpa, 1024);\n\tif (!hp->ioc_regs)\n\t\treturn -ENOMEM;\n\n\t \n\thp->io_pdir_owner = (readq(hp->ioc_regs+HP_ZX1_IBASE) & 0x1) == 0;\n\n\tif (hp->io_pdir_owner)\n\t\treturn hp_zx1_ioc_owner();\n\n\treturn hp_zx1_ioc_shared();\n}\n\nstatic int\nhp_zx1_lba_find_capability (volatile u8 __iomem *hpa, int cap)\n{\n\tu16 status;\n\tu8 pos, id;\n\tint ttl = 48;\n\n\tstatus = readw(hpa+PCI_STATUS);\n\tif (!(status & PCI_STATUS_CAP_LIST))\n\t\treturn 0;\n\tpos = readb(hpa+PCI_CAPABILITY_LIST);\n\twhile (ttl-- && pos >= 0x40) {\n\t\tpos &= ~3;\n\t\tid = readb(hpa+pos+PCI_CAP_LIST_ID);\n\t\tif (id == 0xff)\n\t\t\tbreak;\n\t\tif (id == cap)\n\t\t\treturn pos;\n\t\tpos = readb(hpa+pos+PCI_CAP_LIST_NEXT);\n\t}\n\treturn 0;\n}\n\nstatic int __init\nhp_zx1_lba_init (u64 hpa)\n{\n\tstruct _hp_private *hp = &hp_private;\n\tint cap;\n\n\thp->lba_regs = ioremap(hpa, 256);\n\tif (!hp->lba_regs)\n\t\treturn -ENOMEM;\n\n\thp->lba_cap_offset = hp_zx1_lba_find_capability(hp->lba_regs, PCI_CAP_ID_AGP);\n\n\tcap = readl(hp->lba_regs+hp->lba_cap_offset) & 0xff;\n\tif (cap != PCI_CAP_ID_AGP) {\n\t\tprintk(KERN_ERR PFX \"Invalid capability ID 0x%02x at 0x%x\\n\",\n\t\t       cap, hp->lba_cap_offset);\n\t\tiounmap(hp->lba_regs);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nhp_zx1_fetch_size(void)\n{\n\tint size;\n\n\tsize = hp_private.gart_size / MB(1);\n\thp_zx1_sizes[0].size = size;\n\tagp_bridge->current_size = (void *) &hp_zx1_sizes[0];\n\treturn size;\n}\n\nstatic int\nhp_zx1_configure (void)\n{\n\tstruct _hp_private *hp = &hp_private;\n\n\tagp_bridge->gart_bus_addr = hp->gart_base;\n\tagp_bridge->capndx = hp->lba_cap_offset;\n\tagp_bridge->mode = readl(hp->lba_regs+hp->lba_cap_offset+PCI_AGP_STATUS);\n\n\tif (hp->io_pdir_owner) {\n\t\twritel(virt_to_phys(hp->io_pdir), hp->ioc_regs+HP_ZX1_PDIR_BASE);\n\t\treadl(hp->ioc_regs+HP_ZX1_PDIR_BASE);\n\t\twritel(hp->io_tlb_ps, hp->ioc_regs+HP_ZX1_TCNFG);\n\t\treadl(hp->ioc_regs+HP_ZX1_TCNFG);\n\t\twritel((unsigned int)(~(HP_ZX1_IOVA_SIZE-1)), hp->ioc_regs+HP_ZX1_IMASK);\n\t\treadl(hp->ioc_regs+HP_ZX1_IMASK);\n\t\twritel(hp->iova_base|1, hp->ioc_regs+HP_ZX1_IBASE);\n\t\treadl(hp->ioc_regs+HP_ZX1_IBASE);\n\t\twritel(hp->iova_base|ilog2(HP_ZX1_IOVA_SIZE), hp->ioc_regs+HP_ZX1_PCOM);\n\t\treadl(hp->ioc_regs+HP_ZX1_PCOM);\n\t}\n\n\treturn 0;\n}\n\nstatic void\nhp_zx1_cleanup (void)\n{\n\tstruct _hp_private *hp = &hp_private;\n\n\tif (hp->ioc_regs) {\n\t\tif (hp->io_pdir_owner) {\n\t\t\twriteq(0, hp->ioc_regs+HP_ZX1_IBASE);\n\t\t\treadq(hp->ioc_regs+HP_ZX1_IBASE);\n\t\t}\n\t\tiounmap(hp->ioc_regs);\n\t}\n\tif (hp->lba_regs)\n\t\tiounmap(hp->lba_regs);\n}\n\nstatic void\nhp_zx1_tlbflush (struct agp_memory *mem)\n{\n\tstruct _hp_private *hp = &hp_private;\n\n\twriteq(hp->gart_base | ilog2(hp->gart_size), hp->ioc_regs+HP_ZX1_PCOM);\n\treadq(hp->ioc_regs+HP_ZX1_PCOM);\n}\n\nstatic int\nhp_zx1_create_gatt_table (struct agp_bridge_data *bridge)\n{\n\tstruct _hp_private *hp = &hp_private;\n\tint i;\n\n\tif (hp->io_pdir_owner) {\n\t\thp->io_pdir = (u64 *) __get_free_pages(GFP_KERNEL,\n\t\t\t\t\t\tget_order(hp->io_pdir_size));\n\t\tif (!hp->io_pdir) {\n\t\t\tprintk(KERN_ERR PFX \"Couldn't allocate contiguous \"\n\t\t\t\t\"memory for I/O PDIR\\n\");\n\t\t\thp->gatt = NULL;\n\t\t\thp->gatt_entries = 0;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemset(hp->io_pdir, 0, hp->io_pdir_size);\n\n\t\thp->gatt = &hp->io_pdir[HP_ZX1_IOVA_TO_PDIR(hp->gart_base)];\n\t}\n\n\tfor (i = 0; i < hp->gatt_entries; i++) {\n\t\thp->gatt[i] = (unsigned long) agp_bridge->scratch_page;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nhp_zx1_free_gatt_table (struct agp_bridge_data *bridge)\n{\n\tstruct _hp_private *hp = &hp_private;\n\n\tif (hp->io_pdir_owner)\n\t\tfree_pages((unsigned long) hp->io_pdir,\n\t\t\t    get_order(hp->io_pdir_size));\n\telse\n\t\thp->gatt[0] = HP_ZX1_SBA_IOMMU_COOKIE;\n\treturn 0;\n}\n\nstatic int\nhp_zx1_insert_memory (struct agp_memory *mem, off_t pg_start, int type)\n{\n\tstruct _hp_private *hp = &hp_private;\n\tint i, k;\n\toff_t j, io_pg_start;\n\tint io_pg_count;\n\n\tif (type != mem->type ||\n\t\tagp_bridge->driver->agp_type_to_mask_type(agp_bridge, type)) {\n\t\treturn -EINVAL;\n\t}\n\n\tio_pg_start = hp->io_pages_per_kpage * pg_start;\n\tio_pg_count = hp->io_pages_per_kpage * mem->page_count;\n\tif ((io_pg_start + io_pg_count) > hp->gatt_entries) {\n\t\treturn -EINVAL;\n\t}\n\n\tj = io_pg_start;\n\twhile (j < (io_pg_start + io_pg_count)) {\n\t\tif (hp->gatt[j]) {\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tj++;\n\t}\n\n\tif (!mem->is_flushed) {\n\t\tglobal_cache_flush();\n\t\tmem->is_flushed = true;\n\t}\n\n\tfor (i = 0, j = io_pg_start; i < mem->page_count; i++) {\n\t\tunsigned long paddr;\n\n\t\tpaddr = page_to_phys(mem->pages[i]);\n\t\tfor (k = 0;\n\t\t     k < hp->io_pages_per_kpage;\n\t\t     k++, j++, paddr += hp->io_page_size) {\n\t\t\thp->gatt[j] = HP_ZX1_PDIR_VALID_BIT | paddr;\n\t\t}\n\t}\n\n\tagp_bridge->driver->tlb_flush(mem);\n\treturn 0;\n}\n\nstatic int\nhp_zx1_remove_memory (struct agp_memory *mem, off_t pg_start, int type)\n{\n\tstruct _hp_private *hp = &hp_private;\n\tint i, io_pg_start, io_pg_count;\n\n\tif (type != mem->type ||\n\t\tagp_bridge->driver->agp_type_to_mask_type(agp_bridge, type)) {\n\t\treturn -EINVAL;\n\t}\n\n\tio_pg_start = hp->io_pages_per_kpage * pg_start;\n\tio_pg_count = hp->io_pages_per_kpage * mem->page_count;\n\tfor (i = io_pg_start; i < io_pg_count + io_pg_start; i++) {\n\t\thp->gatt[i] = agp_bridge->scratch_page;\n\t}\n\n\tagp_bridge->driver->tlb_flush(mem);\n\treturn 0;\n}\n\nstatic unsigned long\nhp_zx1_mask_memory (struct agp_bridge_data *bridge, dma_addr_t addr, int type)\n{\n\treturn HP_ZX1_PDIR_VALID_BIT | addr;\n}\n\nstatic void\nhp_zx1_enable (struct agp_bridge_data *bridge, u32 mode)\n{\n\tstruct _hp_private *hp = &hp_private;\n\tu32 command;\n\n\tcommand = readl(hp->lba_regs+hp->lba_cap_offset+PCI_AGP_STATUS);\n\tcommand = agp_collect_device_status(bridge, mode, command);\n\tcommand |= 0x00000100;\n\n\twritel(command, hp->lba_regs+hp->lba_cap_offset+PCI_AGP_COMMAND);\n\n\tagp_device_command(command, (mode & AGP8X_MODE) != 0);\n}\n\nconst struct agp_bridge_driver hp_zx1_driver = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.size_type\t\t= FIXED_APER_SIZE,\n\t.configure\t\t= hp_zx1_configure,\n\t.fetch_size\t\t= hp_zx1_fetch_size,\n\t.cleanup\t\t= hp_zx1_cleanup,\n\t.tlb_flush\t\t= hp_zx1_tlbflush,\n\t.mask_memory\t\t= hp_zx1_mask_memory,\n\t.masks\t\t\t= hp_zx1_masks,\n\t.agp_enable\t\t= hp_zx1_enable,\n\t.cache_flush\t\t= global_cache_flush,\n\t.create_gatt_table\t= hp_zx1_create_gatt_table,\n\t.free_gatt_table\t= hp_zx1_free_gatt_table,\n\t.insert_memory\t\t= hp_zx1_insert_memory,\n\t.remove_memory\t\t= hp_zx1_remove_memory,\n\t.alloc_by_type\t\t= agp_generic_alloc_by_type,\n\t.free_by_type\t\t= agp_generic_free_by_type,\n\t.agp_alloc_page\t\t= agp_generic_alloc_page,\n\t.agp_alloc_pages\t= agp_generic_alloc_pages,\n\t.agp_destroy_page\t= agp_generic_destroy_page,\n\t.agp_destroy_pages\t= agp_generic_destroy_pages,\n\t.agp_type_to_mask_type  = agp_generic_type_to_mask_type,\n\t.cant_use_aperture\t= true,\n};\n\nstatic int __init\nhp_zx1_setup (u64 ioc_hpa, u64 lba_hpa)\n{\n\tstruct agp_bridge_data *bridge;\n\tint error = 0;\n\n\terror = hp_zx1_ioc_init(ioc_hpa);\n\tif (error)\n\t\tgoto fail;\n\n\terror = hp_zx1_lba_init(lba_hpa);\n\tif (error)\n\t\tgoto fail;\n\n\tbridge = agp_alloc_bridge();\n\tif (!bridge) {\n\t\terror = -ENOMEM;\n\t\tgoto fail;\n\t}\n\tbridge->driver = &hp_zx1_driver;\n\n\tfake_bridge_dev.vendor = PCI_VENDOR_ID_HP;\n\tfake_bridge_dev.device = PCI_DEVICE_ID_HP_PCIX_LBA;\n\tbridge->dev = &fake_bridge_dev;\n\n\terror = agp_add_bridge(bridge);\n  fail:\n\tif (error)\n\t\thp_zx1_cleanup();\n\treturn error;\n}\n\nstatic acpi_status __init\nzx1_gart_probe (acpi_handle obj, u32 depth, void *context, void **ret)\n{\n\tacpi_handle handle, parent;\n\tacpi_status status;\n\tstruct acpi_device_info *info;\n\tu64 lba_hpa, sba_hpa, length;\n\tint match;\n\n\tstatus = hp_acpi_csr_space(obj, &lba_hpa, &length);\n\tif (ACPI_FAILURE(status))\n\t\treturn AE_OK;  \n\n\t \n\thandle = obj;\n\tdo {\n\t\tstatus = acpi_get_object_info(handle, &info);\n\t\tif (ACPI_SUCCESS(status) && (info->valid & ACPI_VALID_HID)) {\n\t\t\t \n\t\t\tmatch = (strcmp(info->hardware_id.string, \"HWP0001\") == 0);\n\t\t\tkfree(info);\n\t\t\tif (match) {\n\t\t\t\tstatus = hp_acpi_csr_space(handle, &sba_hpa, &length);\n\t\t\t\tif (ACPI_SUCCESS(status))\n\t\t\t\t\tbreak;\n\t\t\t\telse {\n\t\t\t\t\tprintk(KERN_ERR PFX \"Detected HP ZX1 \"\n\t\t\t\t\t       \"AGP LBA but no IOC.\\n\");\n\t\t\t\t\treturn AE_OK;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstatus = acpi_get_parent(handle, &parent);\n\t\thandle = parent;\n\t} while (ACPI_SUCCESS(status));\n\n\tif (ACPI_FAILURE(status))\n\t\treturn AE_OK;\t \n\n\tif (hp_zx1_setup(sba_hpa + HP_ZX1_IOC_OFFSET, lba_hpa))\n\t\treturn AE_OK;\n\n\tprintk(KERN_INFO PFX \"Detected HP ZX1 %s AGP chipset \"\n\t\t\"(ioc=%llx, lba=%llx)\\n\", (char *)context,\n\t\tsba_hpa + HP_ZX1_IOC_OFFSET, lba_hpa);\n\n\thp_zx1_gart_found = 1;\n\treturn AE_CTRL_TERMINATE;  \n}\n\nstatic int __init\nagp_hp_init (void)\n{\n\tif (agp_off)\n\t\treturn -EINVAL;\n\n\tacpi_get_devices(\"HWP0003\", zx1_gart_probe, \"HWP0003\", NULL);\n\tif (hp_zx1_gart_found)\n\t\treturn 0;\n\n\tacpi_get_devices(\"HWP0007\", zx1_gart_probe, \"HWP0007\", NULL);\n\tif (hp_zx1_gart_found)\n\t\treturn 0;\n\n\treturn -ENODEV;\n}\n\nstatic void __exit\nagp_hp_cleanup (void)\n{\n}\n\nmodule_init(agp_hp_init);\nmodule_exit(agp_hp_cleanup);\n\nMODULE_LICENSE(\"GPL and additional rights\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}