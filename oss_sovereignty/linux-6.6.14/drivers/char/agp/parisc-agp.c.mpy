{
  "module_name": "parisc-agp.c",
  "hash_id": "abe830f273e4751b1dbaa85058e1b8b5c7ef23525f9c448667b001eb871d90a2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/agp/parisc-agp.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/init.h>\n#include <linux/klist.h>\n#include <linux/agp_backend.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n\n#include <asm/parisc-device.h>\n#include <asm/ropes.h>\n\n#include \"agp.h\"\n\n#define DRVNAME\t\"quicksilver\"\n#define DRVPFX\tDRVNAME \": \"\n\n#define AGP8X_MODE_BIT\t\t3\n#define AGP8X_MODE\t\t(1 << AGP8X_MODE_BIT)\n\nstatic unsigned long\nparisc_agp_mask_memory(struct agp_bridge_data *bridge, dma_addr_t addr,\n\t\t       int type);\n\nstatic struct _parisc_agp_info {\n\tvoid __iomem *ioc_regs;\n\tvoid __iomem *lba_regs;\n\n\tint lba_cap_offset;\n\n\t__le64 *gatt;\n\tu64 gatt_entries;\n\n\tu64 gart_base;\n\tu64 gart_size;\n\n\tint io_page_size;\n\tint io_pages_per_kpage;\n} parisc_agp_info;\n\nstatic struct gatt_mask parisc_agp_masks[] =\n{\n        {\n\t\t.mask = SBA_PDIR_VALID_BIT,\n\t\t.type = 0\n\t}\n};\n\nstatic struct aper_size_info_fixed parisc_agp_sizes[] =\n{\n        {0, 0, 0},               \n};\n\nstatic int\nparisc_agp_fetch_size(void)\n{\n\tint size;\n\n\tsize = parisc_agp_info.gart_size / MB(1);\n\tparisc_agp_sizes[0].size = size;\n\tagp_bridge->current_size = (void *) &parisc_agp_sizes[0];\n\n\treturn size;\n}\n\nstatic int\nparisc_agp_configure(void)\n{\n\tstruct _parisc_agp_info *info = &parisc_agp_info;\n\n\tagp_bridge->gart_bus_addr = info->gart_base;\n\tagp_bridge->capndx = info->lba_cap_offset;\n\tagp_bridge->mode = readl(info->lba_regs+info->lba_cap_offset+PCI_AGP_STATUS);\n\n\treturn 0;\n}\n\nstatic void\nparisc_agp_tlbflush(struct agp_memory *mem)\n{\n\tstruct _parisc_agp_info *info = &parisc_agp_info;\n\n\t \n\tasm_io_sync();\n\n\twriteq(info->gart_base | ilog2(info->gart_size), info->ioc_regs+IOC_PCOM);\n\treadq(info->ioc_regs+IOC_PCOM);\t \n}\n\nstatic int\nparisc_agp_create_gatt_table(struct agp_bridge_data *bridge)\n{\n\tstruct _parisc_agp_info *info = &parisc_agp_info;\n\tint i;\n\n\tfor (i = 0; i < info->gatt_entries; i++) {\n\t\tinfo->gatt[i] = cpu_to_le64(agp_bridge->scratch_page);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nparisc_agp_free_gatt_table(struct agp_bridge_data *bridge)\n{\n\tstruct _parisc_agp_info *info = &parisc_agp_info;\n\n\tinfo->gatt[0] = SBA_AGPGART_COOKIE;\n\n\treturn 0;\n}\n\nstatic int\nparisc_agp_insert_memory(struct agp_memory *mem, off_t pg_start, int type)\n{\n\tstruct _parisc_agp_info *info = &parisc_agp_info;\n\tint i, k;\n\toff_t j, io_pg_start;\n\tint io_pg_count;\n\n\tif (type != mem->type ||\n\t\tagp_bridge->driver->agp_type_to_mask_type(agp_bridge, type)) {\n\t\treturn -EINVAL;\n\t}\n\n\tio_pg_start = info->io_pages_per_kpage * pg_start;\n\tio_pg_count = info->io_pages_per_kpage * mem->page_count;\n\tif ((io_pg_start + io_pg_count) > info->gatt_entries) {\n\t\treturn -EINVAL;\n\t}\n\n\tj = io_pg_start;\n\twhile (j < (io_pg_start + io_pg_count)) {\n\t\tif (info->gatt[j])\n\t\t\treturn -EBUSY;\n\t\tj++;\n\t}\n\n\tif (!mem->is_flushed) {\n\t\tglobal_cache_flush();\n\t\tmem->is_flushed = true;\n\t}\n\n\tfor (i = 0, j = io_pg_start; i < mem->page_count; i++) {\n\t\tunsigned long paddr;\n\n\t\tpaddr = page_to_phys(mem->pages[i]);\n\t\tfor (k = 0;\n\t\t     k < info->io_pages_per_kpage;\n\t\t     k++, j++, paddr += info->io_page_size) {\n\t\t\tinfo->gatt[j] = cpu_to_le64(\n\t\t\t\tparisc_agp_mask_memory(agp_bridge,\n\t\t\t\t\tpaddr, type));\n\t\t\tasm_io_fdc(&info->gatt[j]);\n\t\t}\n\t}\n\n\tagp_bridge->driver->tlb_flush(mem);\n\n\treturn 0;\n}\n\nstatic int\nparisc_agp_remove_memory(struct agp_memory *mem, off_t pg_start, int type)\n{\n\tstruct _parisc_agp_info *info = &parisc_agp_info;\n\tint i, io_pg_start, io_pg_count;\n\n\tif (type != mem->type ||\n\t\tagp_bridge->driver->agp_type_to_mask_type(agp_bridge, type)) {\n\t\treturn -EINVAL;\n\t}\n\n\tio_pg_start = info->io_pages_per_kpage * pg_start;\n\tio_pg_count = info->io_pages_per_kpage * mem->page_count;\n\tfor (i = io_pg_start; i < io_pg_count + io_pg_start; i++) {\n\t\tinfo->gatt[i] = cpu_to_le64(agp_bridge->scratch_page);\n\t}\n\n\tagp_bridge->driver->tlb_flush(mem);\n\treturn 0;\n}\n\nstatic unsigned long\nparisc_agp_mask_memory(struct agp_bridge_data *bridge, dma_addr_t addr,\n\t\t       int type)\n{\n\tunsigned ci;\t\t\t \n\tdma_addr_t pa;\n\n\tpa = addr & IOVP_MASK;\n\tasm(\"lci 0(%1), %0\" : \"=r\" (ci) : \"r\" (phys_to_virt(pa)));\n\n\tpa |= (ci >> PAGE_SHIFT) & 0xff; \n\tpa |= SBA_PDIR_VALID_BIT;\t \n\n\t \n\treturn pa;\n}\n\nstatic void\nparisc_agp_enable(struct agp_bridge_data *bridge, u32 mode)\n{\n\tstruct _parisc_agp_info *info = &parisc_agp_info;\n\tu32 command;\n\n\tcommand = readl(info->lba_regs + info->lba_cap_offset + PCI_AGP_STATUS);\n\n\tcommand = agp_collect_device_status(bridge, mode, command);\n\tcommand |= 0x00000100;\n\n\twritel(command, info->lba_regs + info->lba_cap_offset + PCI_AGP_COMMAND);\n\n\tagp_device_command(command, (mode & AGP8X_MODE) != 0);\n}\n\nstatic const struct agp_bridge_driver parisc_agp_driver = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.size_type\t\t= FIXED_APER_SIZE,\n\t.configure\t\t= parisc_agp_configure,\n\t.fetch_size\t\t= parisc_agp_fetch_size,\n\t.tlb_flush\t\t= parisc_agp_tlbflush,\n\t.mask_memory\t\t= parisc_agp_mask_memory,\n\t.masks\t\t\t= parisc_agp_masks,\n\t.agp_enable\t\t= parisc_agp_enable,\n\t.cache_flush\t\t= global_cache_flush,\n\t.create_gatt_table\t= parisc_agp_create_gatt_table,\n\t.free_gatt_table\t= parisc_agp_free_gatt_table,\n\t.insert_memory\t\t= parisc_agp_insert_memory,\n\t.remove_memory\t\t= parisc_agp_remove_memory,\n\t.alloc_by_type\t\t= agp_generic_alloc_by_type,\n\t.free_by_type\t\t= agp_generic_free_by_type,\n\t.agp_alloc_page\t\t= agp_generic_alloc_page,\n\t.agp_alloc_pages\t= agp_generic_alloc_pages,\n\t.agp_destroy_page\t= agp_generic_destroy_page,\n\t.agp_destroy_pages\t= agp_generic_destroy_pages,\n\t.agp_type_to_mask_type  = agp_generic_type_to_mask_type,\n\t.cant_use_aperture\t= true,\n};\n\nstatic int __init\nagp_ioc_init(void __iomem *ioc_regs)\n{\n\tstruct _parisc_agp_info *info = &parisc_agp_info;\n        u64 iova_base, io_tlb_ps;\n\t__le64 *io_pdir;\n        int io_tlb_shift;\n\n        printk(KERN_INFO DRVPFX \"IO PDIR shared with sba_iommu\\n\");\n\n        info->ioc_regs = ioc_regs;\n\n        io_tlb_ps = readq(info->ioc_regs+IOC_TCNFG);\n        switch (io_tlb_ps) {\n        case 0: io_tlb_shift = 12; break;\n        case 1: io_tlb_shift = 13; break;\n        case 2: io_tlb_shift = 14; break;\n        case 3: io_tlb_shift = 16; break;\n        default:\n                printk(KERN_ERR DRVPFX \"Invalid IOTLB page size \"\n                       \"configuration 0x%llx\\n\", io_tlb_ps);\n                info->gatt = NULL;\n                info->gatt_entries = 0;\n                return -ENODEV;\n        }\n        info->io_page_size = 1 << io_tlb_shift;\n        info->io_pages_per_kpage = PAGE_SIZE / info->io_page_size;\n\n        iova_base = readq(info->ioc_regs+IOC_IBASE) & ~0x1;\n        info->gart_base = iova_base + PLUTO_IOVA_SIZE - PLUTO_GART_SIZE;\n\n        info->gart_size = PLUTO_GART_SIZE;\n        info->gatt_entries = info->gart_size / info->io_page_size;\n\n        io_pdir = phys_to_virt(readq(info->ioc_regs+IOC_PDIR_BASE));\n        info->gatt = &io_pdir[(PLUTO_IOVA_SIZE/2) >> PAGE_SHIFT];\n\n        if (info->gatt[0] != SBA_AGPGART_COOKIE) {\n                info->gatt = NULL;\n                info->gatt_entries = 0;\n                printk(KERN_ERR DRVPFX \"No reserved IO PDIR entry found; \"\n                       \"GART disabled\\n\");\n                return -ENODEV;\n        }\n\n        return 0;\n}\n\nstatic int __init\nlba_find_capability(int cap)\n{\n\tstruct _parisc_agp_info *info = &parisc_agp_info;\n        u16 status;\n        u8 pos, id;\n        int ttl = 48;\n\n        status = readw(info->lba_regs + PCI_STATUS);\n        if (!(status & PCI_STATUS_CAP_LIST))\n                return 0;\n        pos = readb(info->lba_regs + PCI_CAPABILITY_LIST);\n        while (ttl-- && pos >= 0x40) {\n                pos &= ~3;\n                id = readb(info->lba_regs + pos + PCI_CAP_LIST_ID);\n                if (id == 0xff)\n                        break;\n                if (id == cap)\n                        return pos;\n                pos = readb(info->lba_regs + pos + PCI_CAP_LIST_NEXT);\n        }\n        return 0;\n}\n\nstatic int __init\nagp_lba_init(void __iomem *lba_hpa)\n{\n\tstruct _parisc_agp_info *info = &parisc_agp_info;\n        int cap;\n\n\tinfo->lba_regs = lba_hpa;\n        info->lba_cap_offset = lba_find_capability(PCI_CAP_ID_AGP);\n\n        cap = readl(lba_hpa + info->lba_cap_offset) & 0xff;\n        if (cap != PCI_CAP_ID_AGP) {\n                printk(KERN_ERR DRVPFX \"Invalid capability ID 0x%02x at 0x%x\\n\",\n                       cap, info->lba_cap_offset);\n                return -ENODEV;\n        }\n\n        return 0;\n}\n\nstatic int __init\nparisc_agp_setup(void __iomem *ioc_hpa, void __iomem *lba_hpa)\n{\n\tstruct pci_dev *fake_bridge_dev = NULL;\n\tstruct agp_bridge_data *bridge;\n\tint error = 0;\n\n\tfake_bridge_dev = pci_alloc_dev(NULL);\n\tif (!fake_bridge_dev) {\n\t\terror = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\terror = agp_ioc_init(ioc_hpa);\n\tif (error)\n\t\tgoto fail;\n\n\terror = agp_lba_init(lba_hpa);\n\tif (error)\n\t\tgoto fail;\n\n\tbridge = agp_alloc_bridge();\n\tif (!bridge) {\n\t\terror = -ENOMEM;\n\t\tgoto fail;\n\t}\n\tbridge->driver = &parisc_agp_driver;\n\n\tfake_bridge_dev->vendor = PCI_VENDOR_ID_HP;\n\tfake_bridge_dev->device = PCI_DEVICE_ID_HP_PCIX_LBA;\n\tbridge->dev = fake_bridge_dev;\n\n\terror = agp_add_bridge(bridge);\n\tif (error)\n\t\tgoto fail;\n\treturn 0;\n\nfail:\n\tkfree(fake_bridge_dev);\n\treturn error;\n}\n\nstatic int __init\nfind_quicksilver(struct device *dev, void *data)\n{\n\tstruct parisc_device **lba = data;\n\tstruct parisc_device *padev = to_parisc_device(dev);\n\n\tif (IS_QUICKSILVER(padev))\n\t\t*lba = padev;\n\n\treturn 0;\n}\n\nstatic int __init\nparisc_agp_init(void)\n{\n\tint err = -1;\n\tstruct parisc_device *sba = NULL, *lba = NULL;\n\tstruct lba_device *lbadev = NULL;\n\n\tif (!sba_list)\n\t\tgoto out;\n\n\t \n\tsba = sba_list->dev;\n\tif (!IS_PLUTO(sba)) {\n\t\tprintk(KERN_INFO DRVPFX \"No Pluto found, so no AGPGART for you.\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tdevice_for_each_child(&sba->dev, &lba, find_quicksilver);\n\n\tif (!lba) {\n\t\tprintk(KERN_INFO DRVPFX \"No AGP devices found.\\n\");\n\t\tgoto out;\n\t}\n\n\tlbadev = parisc_get_drvdata(lba);\n\n\t \n\tparisc_agp_setup(sba_list->ioc[0].ioc_hpa, lbadev->hba.base_addr);\n\n\treturn 0;\n\nout:\n\treturn err;\n}\n\nmodule_init(parisc_agp_init);\n\nMODULE_AUTHOR(\"Kyle McMartin <kyle@parisc-linux.org>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}