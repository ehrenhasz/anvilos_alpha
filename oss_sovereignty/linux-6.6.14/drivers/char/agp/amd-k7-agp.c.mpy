{
  "module_name": "amd-k7-agp.c",
  "hash_id": "b5fef4dbc998a8ca267fc739898d8fb7eb72c3430a01804d159fe2c3883ff92c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/agp/amd-k7-agp.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/init.h>\n#include <linux/agp_backend.h>\n#include <linux/page-flags.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <asm/set_memory.h>\n#include \"agp.h\"\n\n#define AMD_MMBASE_BAR\t1\n#define AMD_APSIZE\t0xac\n#define AMD_MODECNTL\t0xb0\n#define AMD_MODECNTL2\t0xb2\n#define AMD_GARTENABLE\t0x02\t \n#define AMD_ATTBASE\t0x04\t \n#define AMD_TLBFLUSH\t0x0c\t \n#define AMD_CACHEENTRY\t0x10\t \n\nstatic const struct pci_device_id agp_amdk7_pci_table[];\n\nstruct amd_page_map {\n\tunsigned long *real;\n\tunsigned long __iomem *remapped;\n};\n\nstatic struct _amd_irongate_private {\n\tvolatile u8 __iomem *registers;\n\tstruct amd_page_map **gatt_pages;\n\tint num_tables;\n} amd_irongate_private;\n\nstatic int amd_create_page_map(struct amd_page_map *page_map)\n{\n\tint i;\n\n\tpage_map->real = (unsigned long *) __get_free_page(GFP_KERNEL);\n\tif (page_map->real == NULL)\n\t\treturn -ENOMEM;\n\n\tset_memory_uc((unsigned long)page_map->real, 1);\n\tpage_map->remapped = page_map->real;\n\n\tfor (i = 0; i < PAGE_SIZE / sizeof(unsigned long); i++) {\n\t\twritel(agp_bridge->scratch_page, page_map->remapped+i);\n\t\treadl(page_map->remapped+i);\t \n\t}\n\n\treturn 0;\n}\n\nstatic void amd_free_page_map(struct amd_page_map *page_map)\n{\n\tset_memory_wb((unsigned long)page_map->real, 1);\n\tfree_page((unsigned long) page_map->real);\n}\n\nstatic void amd_free_gatt_pages(void)\n{\n\tint i;\n\tstruct amd_page_map **tables;\n\tstruct amd_page_map *entry;\n\n\ttables = amd_irongate_private.gatt_pages;\n\tfor (i = 0; i < amd_irongate_private.num_tables; i++) {\n\t\tentry = tables[i];\n\t\tif (entry != NULL) {\n\t\t\tif (entry->real != NULL)\n\t\t\t\tamd_free_page_map(entry);\n\t\t\tkfree(entry);\n\t\t}\n\t}\n\tkfree(tables);\n\tamd_irongate_private.gatt_pages = NULL;\n}\n\nstatic int amd_create_gatt_pages(int nr_tables)\n{\n\tstruct amd_page_map **tables;\n\tstruct amd_page_map *entry;\n\tint retval = 0;\n\tint i;\n\n\ttables = kcalloc(nr_tables + 1, sizeof(struct amd_page_map *),\n\t\t\t GFP_KERNEL);\n\tif (tables == NULL)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < nr_tables; i++) {\n\t\tentry = kzalloc(sizeof(struct amd_page_map), GFP_KERNEL);\n\t\ttables[i] = entry;\n\t\tif (entry == NULL) {\n\t\t\tretval = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\tretval = amd_create_page_map(entry);\n\t\tif (retval != 0)\n\t\t\tbreak;\n\t}\n\tamd_irongate_private.num_tables = i;\n\tamd_irongate_private.gatt_pages = tables;\n\n\tif (retval != 0)\n\t\tamd_free_gatt_pages();\n\n\treturn retval;\n}\n\n \n\n#define GET_PAGE_DIR_OFF(addr) (addr >> 22)\n#define GET_PAGE_DIR_IDX(addr) (GET_PAGE_DIR_OFF(addr) - \\\n\tGET_PAGE_DIR_OFF(agp_bridge->gart_bus_addr))\n#define GET_GATT_OFF(addr) ((addr & 0x003ff000) >> 12)\n#define GET_GATT(addr) (amd_irongate_private.gatt_pages[\\\n\tGET_PAGE_DIR_IDX(addr)]->remapped)\n\nstatic int amd_create_gatt_table(struct agp_bridge_data *bridge)\n{\n\tstruct aper_size_info_lvl2 *value;\n\tstruct amd_page_map page_dir;\n\tunsigned long __iomem *cur_gatt;\n\tunsigned long addr;\n\tint retval;\n\tint i;\n\n\tvalue = A_SIZE_LVL2(agp_bridge->current_size);\n\tretval = amd_create_page_map(&page_dir);\n\tif (retval != 0)\n\t\treturn retval;\n\n\tretval = amd_create_gatt_pages(value->num_entries / 1024);\n\tif (retval != 0) {\n\t\tamd_free_page_map(&page_dir);\n\t\treturn retval;\n\t}\n\n\tagp_bridge->gatt_table_real = (u32 *)page_dir.real;\n\tagp_bridge->gatt_table = (u32 __iomem *)page_dir.remapped;\n\tagp_bridge->gatt_bus_addr = virt_to_phys(page_dir.real);\n\n\t \n\n\taddr = pci_bus_address(agp_bridge->dev, AGP_APERTURE_BAR);\n\tagp_bridge->gart_bus_addr = addr;\n\n\t \n\tfor (i = 0; i < value->num_entries / 1024; i++, addr += 0x00400000) {\n\t\twritel(virt_to_phys(amd_irongate_private.gatt_pages[i]->real) | 1,\n\t\t\tpage_dir.remapped+GET_PAGE_DIR_OFF(addr));\n\t\treadl(page_dir.remapped+GET_PAGE_DIR_OFF(addr));\t \n\t}\n\n\tfor (i = 0; i < value->num_entries; i++) {\n\t\taddr = (i * PAGE_SIZE) + agp_bridge->gart_bus_addr;\n\t\tcur_gatt = GET_GATT(addr);\n\t\twritel(agp_bridge->scratch_page, cur_gatt+GET_GATT_OFF(addr));\n\t\treadl(cur_gatt+GET_GATT_OFF(addr));\t \n\t}\n\n\treturn 0;\n}\n\nstatic int amd_free_gatt_table(struct agp_bridge_data *bridge)\n{\n\tstruct amd_page_map page_dir;\n\n\tpage_dir.real = (unsigned long *)agp_bridge->gatt_table_real;\n\tpage_dir.remapped = (unsigned long __iomem *)agp_bridge->gatt_table;\n\n\tamd_free_gatt_pages();\n\tamd_free_page_map(&page_dir);\n\treturn 0;\n}\n\nstatic int amd_irongate_fetch_size(void)\n{\n\tint i;\n\tu32 temp;\n\tstruct aper_size_info_lvl2 *values;\n\n\tpci_read_config_dword(agp_bridge->dev, AMD_APSIZE, &temp);\n\ttemp = (temp & 0x0000000e);\n\tvalues = A_SIZE_LVL2(agp_bridge->driver->aperture_sizes);\n\tfor (i = 0; i < agp_bridge->driver->num_aperture_sizes; i++) {\n\t\tif (temp == values[i].size_value) {\n\t\t\tagp_bridge->previous_size =\n\t\t\t    agp_bridge->current_size = (void *) (values + i);\n\n\t\t\tagp_bridge->aperture_size_idx = i;\n\t\t\treturn values[i].size;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int amd_irongate_configure(void)\n{\n\tstruct aper_size_info_lvl2 *current_size;\n\tphys_addr_t reg;\n\tu32 temp;\n\tu16 enable_reg;\n\n\tcurrent_size = A_SIZE_LVL2(agp_bridge->current_size);\n\n\tif (!amd_irongate_private.registers) {\n\t\t \n\t\treg = pci_resource_start(agp_bridge->dev, AMD_MMBASE_BAR);\n\t\tamd_irongate_private.registers = (volatile u8 __iomem *) ioremap(reg, 4096);\n\t\tif (!amd_irongate_private.registers)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t \n\twritel(agp_bridge->gatt_bus_addr, amd_irongate_private.registers+AMD_ATTBASE);\n\treadl(amd_irongate_private.registers+AMD_ATTBASE);\t \n\n\t \n\tpci_write_config_byte(agp_bridge->dev, AMD_MODECNTL, 0x80);\n\n\t \n\tpci_write_config_byte(agp_bridge->dev, AMD_MODECNTL2, 0x00);\n\n\t \n\tenable_reg = readw(amd_irongate_private.registers+AMD_GARTENABLE);\n\tenable_reg = (enable_reg | 0x0004);\n\twritew(enable_reg, amd_irongate_private.registers+AMD_GARTENABLE);\n\treadw(amd_irongate_private.registers+AMD_GARTENABLE);\t \n\n\t \n\tpci_read_config_dword(agp_bridge->dev, AMD_APSIZE, &temp);\n\ttemp = (((temp & ~(0x0000000e)) | current_size->size_value) | 1);\n\tpci_write_config_dword(agp_bridge->dev, AMD_APSIZE, temp);\n\n\t \n\twritel(1, amd_irongate_private.registers+AMD_TLBFLUSH);\n\treadl(amd_irongate_private.registers+AMD_TLBFLUSH);\t \n\treturn 0;\n}\n\nstatic void amd_irongate_cleanup(void)\n{\n\tstruct aper_size_info_lvl2 *previous_size;\n\tu32 temp;\n\tu16 enable_reg;\n\n\tprevious_size = A_SIZE_LVL2(agp_bridge->previous_size);\n\n\tenable_reg = readw(amd_irongate_private.registers+AMD_GARTENABLE);\n\tenable_reg = (enable_reg & ~(0x0004));\n\twritew(enable_reg, amd_irongate_private.registers+AMD_GARTENABLE);\n\treadw(amd_irongate_private.registers+AMD_GARTENABLE);\t \n\n\t \n\tpci_read_config_dword(agp_bridge->dev, AMD_APSIZE, &temp);\n\ttemp = ((temp & ~(0x0000000f)) | previous_size->size_value);\n\tpci_write_config_dword(agp_bridge->dev, AMD_APSIZE, temp);\n\tiounmap((void __iomem *) amd_irongate_private.registers);\n}\n\n \n\nstatic void amd_irongate_tlbflush(struct agp_memory *temp)\n{\n\twritel(1, amd_irongate_private.registers+AMD_TLBFLUSH);\n\treadl(amd_irongate_private.registers+AMD_TLBFLUSH);\t \n}\n\nstatic int amd_insert_memory(struct agp_memory *mem, off_t pg_start, int type)\n{\n\tint i, j, num_entries;\n\tunsigned long __iomem *cur_gatt;\n\tunsigned long addr;\n\n\tnum_entries = A_SIZE_LVL2(agp_bridge->current_size)->num_entries;\n\n\tif (type != mem->type ||\n\t    agp_bridge->driver->agp_type_to_mask_type(agp_bridge, type))\n\t\treturn -EINVAL;\n\n\tif ((pg_start + mem->page_count) > num_entries)\n\t\treturn -EINVAL;\n\n\tj = pg_start;\n\twhile (j < (pg_start + mem->page_count)) {\n\t\taddr = (j * PAGE_SIZE) + agp_bridge->gart_bus_addr;\n\t\tcur_gatt = GET_GATT(addr);\n\t\tif (!PGE_EMPTY(agp_bridge, readl(cur_gatt+GET_GATT_OFF(addr))))\n\t\t\treturn -EBUSY;\n\t\tj++;\n\t}\n\n\tif (!mem->is_flushed) {\n\t\tglobal_cache_flush();\n\t\tmem->is_flushed = true;\n\t}\n\n\tfor (i = 0, j = pg_start; i < mem->page_count; i++, j++) {\n\t\taddr = (j * PAGE_SIZE) + agp_bridge->gart_bus_addr;\n\t\tcur_gatt = GET_GATT(addr);\n\t\twritel(agp_generic_mask_memory(agp_bridge,\n\t\t\t\t\t       page_to_phys(mem->pages[i]),\n\t\t\t\t\t       mem->type),\n\t\t       cur_gatt+GET_GATT_OFF(addr));\n\t\treadl(cur_gatt+GET_GATT_OFF(addr));\t \n\t}\n\tamd_irongate_tlbflush(mem);\n\treturn 0;\n}\n\nstatic int amd_remove_memory(struct agp_memory *mem, off_t pg_start, int type)\n{\n\tint i;\n\tunsigned long __iomem *cur_gatt;\n\tunsigned long addr;\n\n\tif (type != mem->type ||\n\t    agp_bridge->driver->agp_type_to_mask_type(agp_bridge, type))\n\t\treturn -EINVAL;\n\n\tfor (i = pg_start; i < (mem->page_count + pg_start); i++) {\n\t\taddr = (i * PAGE_SIZE) + agp_bridge->gart_bus_addr;\n\t\tcur_gatt = GET_GATT(addr);\n\t\twritel(agp_bridge->scratch_page, cur_gatt+GET_GATT_OFF(addr));\n\t\treadl(cur_gatt+GET_GATT_OFF(addr));\t \n\t}\n\n\tamd_irongate_tlbflush(mem);\n\treturn 0;\n}\n\nstatic const struct aper_size_info_lvl2 amd_irongate_sizes[7] =\n{\n\t{2048, 524288, 0x0000000c},\n\t{1024, 262144, 0x0000000a},\n\t{512, 131072, 0x00000008},\n\t{256, 65536, 0x00000006},\n\t{128, 32768, 0x00000004},\n\t{64, 16384, 0x00000002},\n\t{32, 8192, 0x00000000}\n};\n\nstatic const struct gatt_mask amd_irongate_masks[] =\n{\n\t{.mask = 1, .type = 0}\n};\n\nstatic const struct agp_bridge_driver amd_irongate_driver = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.aperture_sizes\t\t= amd_irongate_sizes,\n\t.size_type\t\t= LVL2_APER_SIZE,\n\t.num_aperture_sizes\t= 7,\n\t.needs_scratch_page\t= true,\n\t.configure\t\t= amd_irongate_configure,\n\t.fetch_size\t\t= amd_irongate_fetch_size,\n\t.cleanup\t\t= amd_irongate_cleanup,\n\t.tlb_flush\t\t= amd_irongate_tlbflush,\n\t.mask_memory\t\t= agp_generic_mask_memory,\n\t.masks\t\t\t= amd_irongate_masks,\n\t.agp_enable\t\t= agp_generic_enable,\n\t.cache_flush\t\t= global_cache_flush,\n\t.create_gatt_table\t= amd_create_gatt_table,\n\t.free_gatt_table\t= amd_free_gatt_table,\n\t.insert_memory\t\t= amd_insert_memory,\n\t.remove_memory\t\t= amd_remove_memory,\n\t.alloc_by_type\t\t= agp_generic_alloc_by_type,\n\t.free_by_type\t\t= agp_generic_free_by_type,\n\t.agp_alloc_page\t\t= agp_generic_alloc_page,\n\t.agp_alloc_pages\t= agp_generic_alloc_pages,\n\t.agp_destroy_page\t= agp_generic_destroy_page,\n\t.agp_destroy_pages\t= agp_generic_destroy_pages,\n\t.agp_type_to_mask_type  = agp_generic_type_to_mask_type,\n};\n\nstatic struct agp_device_ids amd_agp_device_ids[] =\n{\n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_AMD_FE_GATE_7006,\n\t\t.chipset_name\t= \"Irongate\",\n\t},\n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_AMD_FE_GATE_700E,\n\t\t.chipset_name\t= \"761\",\n\t},\n\t{\n\t\t.device_id\t= PCI_DEVICE_ID_AMD_FE_GATE_700C,\n\t\t.chipset_name\t= \"760MP\",\n\t},\n\t{ },  \n};\n\nstatic int agp_amdk7_probe(struct pci_dev *pdev,\n\t\t\t   const struct pci_device_id *ent)\n{\n\tstruct agp_bridge_data *bridge;\n\tu8 cap_ptr;\n\tint j;\n\n\tcap_ptr = pci_find_capability(pdev, PCI_CAP_ID_AGP);\n\tif (!cap_ptr)\n\t\treturn -ENODEV;\n\n\tj = ent - agp_amdk7_pci_table;\n\tdev_info(&pdev->dev, \"AMD %s chipset\\n\",\n\t\t amd_agp_device_ids[j].chipset_name);\n\n\tbridge = agp_alloc_bridge();\n\tif (!bridge)\n\t\treturn -ENOMEM;\n\n\tbridge->driver = &amd_irongate_driver;\n\tbridge->dev_private_data = &amd_irongate_private;\n\tbridge->dev = pdev;\n\tbridge->capndx = cap_ptr;\n\n\t \n\tif (agp_bridge->dev->device == PCI_DEVICE_ID_AMD_FE_GATE_7006) {\n\t\tstruct pci_dev *gfxcard=NULL;\n\n\t\tcap_ptr = 0;\n\t\twhile (!cap_ptr) {\n\t\t\tgfxcard = pci_get_class(PCI_CLASS_DISPLAY_VGA<<8, gfxcard);\n\t\t\tif (!gfxcard) {\n\t\t\t\tdev_info(&pdev->dev, \"no AGP VGA controller\\n\");\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\t\t\tcap_ptr = pci_find_capability(gfxcard, PCI_CAP_ID_AGP);\n\t\t}\n\n\t\t \n\t\tif (gfxcard->vendor == PCI_VENDOR_ID_NVIDIA) {\n\t\t\tagp_bridge->flags |= AGP_ERRATA_1X;\n\t\t\tdev_info(&pdev->dev, \"AMD 751 chipset with NVidia GeForce; forcing 1X due to errata\\n\");\n\t\t}\n\t\tpci_dev_put(gfxcard);\n\t}\n\n\t \n\tif (agp_bridge->dev->device == PCI_DEVICE_ID_AMD_FE_GATE_700E) {\n\t\tif (pdev->revision == 0x10 || pdev->revision == 0x11) {\n\t\t\tagp_bridge->flags = AGP_ERRATA_FASTWRITES;\n\t\t\tagp_bridge->flags |= AGP_ERRATA_SBA;\n\t\t\tagp_bridge->flags |= AGP_ERRATA_1X;\n\t\t\tdev_info(&pdev->dev, \"AMD 761 chipset with errata; disabling AGP fast writes & SBA and forcing to 1X\\n\");\n\t\t}\n\t}\n\n\t \n\tpci_read_config_dword(pdev,\n\t\t\tbridge->capndx+PCI_AGP_STATUS,\n\t\t\t&bridge->mode);\n\n\tpci_set_drvdata(pdev, bridge);\n\treturn agp_add_bridge(bridge);\n}\n\nstatic void agp_amdk7_remove(struct pci_dev *pdev)\n{\n\tstruct agp_bridge_data *bridge = pci_get_drvdata(pdev);\n\n\tagp_remove_bridge(bridge);\n\tagp_put_bridge(bridge);\n}\n\nstatic int agp_amdk7_resume(struct device *dev)\n{\n\treturn amd_irongate_driver.configure();\n}\n\n \nstatic const struct pci_device_id agp_amdk7_pci_table[] = {\n\t{\n\t.class\t\t= (PCI_CLASS_BRIDGE_HOST << 8),\n\t.class_mask\t= ~0,\n\t.vendor\t\t= PCI_VENDOR_ID_AMD,\n\t.device\t\t= PCI_DEVICE_ID_AMD_FE_GATE_7006,\n\t.subvendor\t= PCI_ANY_ID,\n\t.subdevice\t= PCI_ANY_ID,\n\t},\n\t{\n\t.class\t\t= (PCI_CLASS_BRIDGE_HOST << 8),\n\t.class_mask\t= ~0,\n\t.vendor\t\t= PCI_VENDOR_ID_AMD,\n\t.device\t\t= PCI_DEVICE_ID_AMD_FE_GATE_700E,\n\t.subvendor\t= PCI_ANY_ID,\n\t.subdevice\t= PCI_ANY_ID,\n\t},\n\t{\n\t.class\t\t= (PCI_CLASS_BRIDGE_HOST << 8),\n\t.class_mask\t= ~0,\n\t.vendor\t\t= PCI_VENDOR_ID_AMD,\n\t.device\t\t= PCI_DEVICE_ID_AMD_FE_GATE_700C,\n\t.subvendor\t= PCI_ANY_ID,\n\t.subdevice\t= PCI_ANY_ID,\n\t},\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(pci, agp_amdk7_pci_table);\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(agp_amdk7_pm_ops, NULL, agp_amdk7_resume);\n\nstatic struct pci_driver agp_amdk7_pci_driver = {\n\t.name\t\t= \"agpgart-amdk7\",\n\t.id_table\t= agp_amdk7_pci_table,\n\t.probe\t\t= agp_amdk7_probe,\n\t.remove\t\t= agp_amdk7_remove,\n\t.driver.pm\t= &agp_amdk7_pm_ops,\n};\n\nstatic int __init agp_amdk7_init(void)\n{\n\tif (agp_off)\n\t\treturn -EINVAL;\n\treturn pci_register_driver(&agp_amdk7_pci_driver);\n}\n\nstatic void __exit agp_amdk7_cleanup(void)\n{\n\tpci_unregister_driver(&agp_amdk7_pci_driver);\n}\n\nmodule_init(agp_amdk7_init);\nmodule_exit(agp_amdk7_cleanup);\n\nMODULE_LICENSE(\"GPL and additional rights\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}