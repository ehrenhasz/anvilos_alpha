{
  "module_name": "agp.h",
  "hash_id": "c8748eaff0a55863e1094da380e8a1f77bfd96c842047228dadbef64bfbdf336",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/agp/agp.h",
  "human_readable_source": " \n\n#ifndef _AGP_BACKEND_PRIV_H\n#define _AGP_BACKEND_PRIV_H 1\n\n#include <asm/agp.h>\t \n\n#define PFX \"agpgart: \"\n\n\n#ifdef AGP_DEBUG\n#define DBG(x,y...) printk (KERN_DEBUG PFX \"%s: \" x \"\\n\", __func__ , ## y)\n#else\n#define DBG(x,y...) do { } while (0)\n#endif\n\nextern struct agp_bridge_data *agp_bridge;\n\nenum aper_size_type {\n\tU8_APER_SIZE,\n\tU16_APER_SIZE,\n\tU32_APER_SIZE,\n\tLVL2_APER_SIZE,\n\tFIXED_APER_SIZE\n};\n\nstruct gatt_mask {\n\tunsigned long mask;\n\tu32 type;\n\t \n};\n\n#define AGP_PAGE_DESTROY_UNMAP 1\n#define AGP_PAGE_DESTROY_FREE 2\n\nstruct aper_size_info_8 {\n\tint size;\n\tint num_entries;\n\tint page_order;\n\tu8 size_value;\n};\n\nstruct aper_size_info_16 {\n\tint size;\n\tint num_entries;\n\tint page_order;\n\tu16 size_value;\n};\n\nstruct aper_size_info_32 {\n\tint size;\n\tint num_entries;\n\tint page_order;\n\tu32 size_value;\n};\n\nstruct aper_size_info_lvl2 {\n\tint size;\n\tint num_entries;\n\tu32 size_value;\n};\n\nstruct aper_size_info_fixed {\n\tint size;\n\tint num_entries;\n\tint page_order;\n};\n\nstruct agp_bridge_driver {\n\tstruct module *owner;\n\tconst void *aperture_sizes;\n\tint num_aperture_sizes;\n\tenum aper_size_type size_type;\n\tbool cant_use_aperture;\n\tbool needs_scratch_page;\n\tconst struct gatt_mask *masks;\n\tint (*fetch_size)(void);\n\tint (*configure)(void);\n\tvoid (*agp_enable)(struct agp_bridge_data *, u32);\n\tvoid (*cleanup)(void);\n\tvoid (*tlb_flush)(struct agp_memory *);\n\tunsigned long (*mask_memory)(struct agp_bridge_data *, dma_addr_t, int);\n\tvoid (*cache_flush)(void);\n\tint (*create_gatt_table)(struct agp_bridge_data *);\n\tint (*free_gatt_table)(struct agp_bridge_data *);\n\tint (*insert_memory)(struct agp_memory *, off_t, int);\n\tint (*remove_memory)(struct agp_memory *, off_t, int);\n\tstruct agp_memory *(*alloc_by_type) (size_t, int);\n\tvoid (*free_by_type)(struct agp_memory *);\n\tstruct page *(*agp_alloc_page)(struct agp_bridge_data *);\n\tint (*agp_alloc_pages)(struct agp_bridge_data *, struct agp_memory *, size_t);\n\tvoid (*agp_destroy_page)(struct page *, int flags);\n\tvoid (*agp_destroy_pages)(struct agp_memory *);\n\tint (*agp_type_to_mask_type) (struct agp_bridge_data *, int);\n};\n\nstruct agp_bridge_data {\n\tconst struct agp_version *version;\n\tconst struct agp_bridge_driver *driver;\n\tconst struct vm_operations_struct *vm_ops;\n\tvoid *previous_size;\n\tvoid *current_size;\n\tvoid *dev_private_data;\n\tstruct pci_dev *dev;\n\tu32 __iomem *gatt_table;\n\tu32 *gatt_table_real;\n\tunsigned long scratch_page;\n\tstruct page *scratch_page_page;\n\tdma_addr_t scratch_page_dma;\n\tunsigned long gart_bus_addr;\n\tunsigned long gatt_bus_addr;\n\tu32 mode;\n\tenum chipset_type type;\n\tunsigned long *key_list;\n\tatomic_t current_memory_agp;\n\tatomic_t agp_in_use;\n\tint max_memory_agp;\t \n\tint aperture_size_idx;\n\tint capndx;\n\tint flags;\n\tchar major_version;\n\tchar minor_version;\n\tstruct list_head list;\n\tu32 apbase_config;\n\t \n\tstruct list_head mapped_list;\n\tspinlock_t mapped_lock;\n};\n\n#define KB(x)\t((x) * 1024)\n#define MB(x)\t(KB (KB (x)))\n#define GB(x)\t(MB (KB (x)))\n\n#define A_SIZE_8(x)\t((struct aper_size_info_8 *) x)\n#define A_SIZE_16(x)\t((struct aper_size_info_16 *) x)\n#define A_SIZE_32(x)\t((struct aper_size_info_32 *) x)\n#define A_SIZE_LVL2(x)\t((struct aper_size_info_lvl2 *) x)\n#define A_SIZE_FIX(x)\t((struct aper_size_info_fixed *) x)\n#define A_IDX8(bridge)\t(A_SIZE_8((bridge)->driver->aperture_sizes) + i)\n#define A_IDX16(bridge)\t(A_SIZE_16((bridge)->driver->aperture_sizes) + i)\n#define A_IDX32(bridge)\t(A_SIZE_32((bridge)->driver->aperture_sizes) + i)\n#define MAXKEY\t\t(4096 * 32)\n\n#define PGE_EMPTY(b, p)\t(!(p) || (p) == (unsigned long) (b)->scratch_page)\n\n\nstruct agp_device_ids {\n\tunsigned short device_id;  \n\tenum chipset_type chipset;\n\tconst char *chipset_name;\n\tint (*chipset_setup) (struct pci_dev *pdev);\t \n};\n\n \nstruct agp_bridge_data *agp_alloc_bridge(void);\nvoid agp_put_bridge(struct agp_bridge_data *bridge);\nint agp_add_bridge(struct agp_bridge_data *bridge);\nvoid agp_remove_bridge(struct agp_bridge_data *bridge);\n\n \n#if IS_ENABLED(CONFIG_DRM_LEGACY)\nint agp_frontend_initialize(void);\nvoid agp_frontend_cleanup(void);\n#else\nstatic inline int agp_frontend_initialize(void) { return 0; }\nstatic inline void agp_frontend_cleanup(void) {}\n#endif\n\n \nvoid agp_generic_enable(struct agp_bridge_data *bridge, u32 mode);\nint agp_generic_create_gatt_table(struct agp_bridge_data *bridge);\nint agp_generic_free_gatt_table(struct agp_bridge_data *bridge);\nstruct agp_memory *agp_create_memory(int scratch_pages);\nint agp_generic_insert_memory(struct agp_memory *mem, off_t pg_start, int type);\nint agp_generic_remove_memory(struct agp_memory *mem, off_t pg_start, int type);\nstruct agp_memory *agp_generic_alloc_by_type(size_t page_count, int type);\nvoid agp_generic_free_by_type(struct agp_memory *curr);\nstruct page *agp_generic_alloc_page(struct agp_bridge_data *bridge);\nint agp_generic_alloc_pages(struct agp_bridge_data *agp_bridge,\n\t\t\t    struct agp_memory *memory, size_t page_count);\nvoid agp_generic_destroy_page(struct page *page, int flags);\nvoid agp_generic_destroy_pages(struct agp_memory *memory);\nvoid agp_free_key(int key);\nint agp_num_entries(void);\nu32 agp_collect_device_status(struct agp_bridge_data *bridge, u32 mode, u32 command);\nvoid agp_device_command(u32 command, bool agp_v3);\nint agp_3_5_enable(struct agp_bridge_data *bridge);\nvoid global_cache_flush(void);\nvoid get_agp_version(struct agp_bridge_data *bridge);\nunsigned long agp_generic_mask_memory(struct agp_bridge_data *bridge,\n\t\t\t\t      dma_addr_t phys, int type);\nint agp_generic_type_to_mask_type(struct agp_bridge_data *bridge,\n\t\t\t\t  int type);\nstruct agp_bridge_data *agp_generic_find_bridge(struct pci_dev *pdev);\n\n \nstruct agp_memory *agp_generic_alloc_user(size_t page_count, int type);\nvoid agp_alloc_page_array(size_t size, struct agp_memory *mem);\nstatic inline void agp_free_page_array(struct agp_memory *mem)\n{\n\tkvfree(mem->pages);\n}\n\n\n \nint agp3_generic_fetch_size(void);\nvoid agp3_generic_tlbflush(struct agp_memory *mem);\nint agp3_generic_configure(void);\nvoid agp3_generic_cleanup(void);\n\n \n#define alloc_gatt_pages(order)\t\t\\\n\t((char *)__get_free_pages(GFP_KERNEL, (order)))\n#define free_gatt_pages(table, order)\t\\\n\tfree_pages((unsigned long)(table), (order))\n\n \n#define AGP_GENERIC_SIZES_ENTRIES 11\nextern const struct aper_size_info_16 agp3_generic_sizes[];\n\nextern int agp_off;\nextern int agp_try_unsupported_boot;\n\nlong compat_agp_ioctl(struct file *file, unsigned int cmd, unsigned long arg);\n\n \n#define AGP_APBASE\t0x10\n#define AGP_APERTURE_BAR\t0\n\n#define AGPSTAT\t\t0x4\n#define AGPCMD\t\t0x8\n#define AGPNISTAT\t0xc\n#define AGPCTRL\t\t0x10\n#define AGPAPSIZE\t0x14\n#define AGPNEPG\t\t0x16\n#define AGPGARTLO\t0x18\n#define AGPGARTHI\t0x1c\n#define AGPNICMD\t0x20\n\n#define AGP_MAJOR_VERSION_SHIFT\t(20)\n#define AGP_MINOR_VERSION_SHIFT\t(16)\n\n#define AGPSTAT_RQ_DEPTH\t(0xff000000)\n#define AGPSTAT_RQ_DEPTH_SHIFT\t24\n\n#define AGPSTAT_CAL_MASK\t(1<<12|1<<11|1<<10)\n#define AGPSTAT_ARQSZ\t\t(1<<15|1<<14|1<<13)\n#define AGPSTAT_ARQSZ_SHIFT\t13\n\n#define AGPSTAT_SBA\t\t(1<<9)\n#define AGPSTAT_AGP_ENABLE\t(1<<8)\n#define AGPSTAT_FW\t\t(1<<4)\n#define AGPSTAT_MODE_3_0\t(1<<3)\n\n#define AGPSTAT2_1X\t\t(1<<0)\n#define AGPSTAT2_2X\t\t(1<<1)\n#define AGPSTAT2_4X\t\t(1<<2)\n\n#define AGPSTAT3_RSVD\t\t(1<<2)\n#define AGPSTAT3_8X\t\t(1<<1)\n#define AGPSTAT3_4X\t\t(1)\n\n#define AGPCTRL_APERENB\t\t(1<<8)\n#define AGPCTRL_GTLBEN\t\t(1<<7)\n\n#define AGP2_RESERVED_MASK 0x00fffcc8\n#define AGP3_RESERVED_MASK 0x00ff00c4\n\n#define AGP_ERRATA_FASTWRITES 1<<0\n#define AGP_ERRATA_SBA\t 1<<1\n#define AGP_ERRATA_1X 1<<2\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}