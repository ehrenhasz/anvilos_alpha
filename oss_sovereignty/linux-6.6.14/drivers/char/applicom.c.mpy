{
  "module_name": "applicom.c",
  "hash_id": "468da996d4d3dec4a004868dac3a36a17d6b1466503800933e0f1c2749ec2702",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/applicom.c",
  "human_readable_source": "\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/pci.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/nospec.h>\n\n#include <asm/io.h>\n#include <linux/uaccess.h>\n\n#include \"applicom.h\"\n\n\n \n\n\n#undef DEBUG\n\n#define MAX_BOARD 8\t\t \n#define MAX_ISA_BOARD 4\n#define LEN_RAM_IO 0x800\n\n#ifndef PCI_VENDOR_ID_APPLICOM\n#define PCI_VENDOR_ID_APPLICOM                0x1389\n#define PCI_DEVICE_ID_APPLICOM_PCIGENERIC     0x0001\n#define PCI_DEVICE_ID_APPLICOM_PCI2000IBS_CAN 0x0002\n#define PCI_DEVICE_ID_APPLICOM_PCI2000PFB     0x0003\n#endif\n\nstatic DEFINE_MUTEX(ac_mutex);\nstatic char *applicom_pci_devnames[] = {\n\t\"PCI board\",\n\t\"PCI2000IBS / PCI2000CAN\",\n\t\"PCI2000PFB\"\n};\n\nstatic const struct pci_device_id applicom_pci_tbl[] = {\n\t{ PCI_VDEVICE(APPLICOM, PCI_DEVICE_ID_APPLICOM_PCIGENERIC) },\n\t{ PCI_VDEVICE(APPLICOM, PCI_DEVICE_ID_APPLICOM_PCI2000IBS_CAN) },\n\t{ PCI_VDEVICE(APPLICOM, PCI_DEVICE_ID_APPLICOM_PCI2000PFB) },\n\t{ 0 }\n};\nMODULE_DEVICE_TABLE(pci, applicom_pci_tbl);\n\nMODULE_AUTHOR(\"David Woodhouse & Applicom International\");\nMODULE_DESCRIPTION(\"Driver for Applicom Profibus card\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_MISCDEV(AC_MINOR);\n\nstatic struct applicom_board {\n\tunsigned long PhysIO;\n\tvoid __iomem *RamIO;\n\twait_queue_head_t FlagSleepSend;\n\tlong irq;\n\tspinlock_t mutex;\n} apbs[MAX_BOARD];\n\nstatic unsigned int irq;\t \nstatic unsigned long mem;\t \n\nmodule_param_hw(irq, uint, irq, 0);\nMODULE_PARM_DESC(irq, \"IRQ of the Applicom board\");\nmodule_param_hw(mem, ulong, iomem, 0);\nMODULE_PARM_DESC(mem, \"Shared Memory Address of Applicom board\");\n\nstatic unsigned int numboards;\t \nstatic volatile unsigned char Dummy;\nstatic DECLARE_WAIT_QUEUE_HEAD(FlagSleepRec);\nstatic unsigned int WriteErrorCount;\t \nstatic unsigned int ReadErrorCount;\t \nstatic unsigned int DeviceErrorCount;\t \n\nstatic ssize_t ac_read (struct file *, char __user *, size_t, loff_t *);\nstatic ssize_t ac_write (struct file *, const char __user *, size_t, loff_t *);\nstatic long ac_ioctl(struct file *, unsigned int, unsigned long);\nstatic irqreturn_t ac_interrupt(int, void *);\n\nstatic const struct file_operations ac_fops = {\n\t.owner = THIS_MODULE,\n\t.llseek = no_llseek,\n\t.read = ac_read,\n\t.write = ac_write,\n\t.unlocked_ioctl = ac_ioctl,\n};\n\nstatic struct miscdevice ac_miscdev = {\n\tAC_MINOR,\n\t\"ac\",\n\t&ac_fops\n};\n\nstatic int dummy;\t \n\nstatic int ac_register_board(unsigned long physloc, void __iomem *loc, \n\t\t      unsigned char boardno)\n{\n\tvolatile unsigned char byte_reset_it;\n\n\tif((readb(loc + CONF_END_TEST)     != 0x00) ||\n\t   (readb(loc + CONF_END_TEST + 1) != 0x55) ||\n\t   (readb(loc + CONF_END_TEST + 2) != 0xAA) ||\n\t   (readb(loc + CONF_END_TEST + 3) != 0xFF))\n\t\treturn 0;\n\n\tif (!boardno)\n\t\tboardno = readb(loc + NUMCARD_OWNER_TO_PC);\n\n\tif (!boardno || boardno > MAX_BOARD) {\n\t\tprintk(KERN_WARNING \"Board #%d (at 0x%lx) is out of range (1 <= x <= %d).\\n\",\n\t\t       boardno, physloc, MAX_BOARD);\n\t\treturn 0;\n\t}\n\n\tif (apbs[boardno - 1].RamIO) {\n\t\tprintk(KERN_WARNING \"Board #%d (at 0x%lx) conflicts with previous board #%d (at 0x%lx)\\n\", \n\t\t       boardno, physloc, boardno, apbs[boardno-1].PhysIO);\n\t\treturn 0;\n\t}\n\n\tboardno--;\n\n\tapbs[boardno].PhysIO = physloc;\n\tapbs[boardno].RamIO = loc;\n\tinit_waitqueue_head(&apbs[boardno].FlagSleepSend);\n\tspin_lock_init(&apbs[boardno].mutex);\n\tbyte_reset_it = readb(loc + RAM_IT_TO_PC);\n\n\tnumboards++;\n\treturn boardno + 1;\n}\n\nstatic void __exit applicom_exit(void)\n{\n\tunsigned int i;\n\n\tmisc_deregister(&ac_miscdev);\n\n\tfor (i = 0; i < MAX_BOARD; i++) {\n\n\t\tif (!apbs[i].RamIO)\n\t\t\tcontinue;\n\n\t\tif (apbs[i].irq)\n\t\t\tfree_irq(apbs[i].irq, &dummy);\n\n\t\tiounmap(apbs[i].RamIO);\n\t}\n}\n\nstatic int __init applicom_init(void)\n{\n\tint i, numisa = 0;\n\tstruct pci_dev *dev = NULL;\n\tvoid __iomem *RamIO;\n\tint boardno, ret;\n\n\tprintk(KERN_INFO \"Applicom driver: $Id: ac.c,v 1.30 2000/03/22 16:03:57 dwmw2 Exp $\\n\");\n\n\t \n\n\twhile ( (dev = pci_get_class(PCI_CLASS_OTHERS << 16, dev))) {\n\n\t\tif (!pci_match_id(applicom_pci_tbl, dev))\n\t\t\tcontinue;\n\t\t\n\t\tif (pci_enable_device(dev)) {\n\t\t\tpci_dev_put(dev);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tRamIO = ioremap(pci_resource_start(dev, 0), LEN_RAM_IO);\n\n\t\tif (!RamIO) {\n\t\t\tprintk(KERN_INFO \"ac.o: Failed to ioremap PCI memory \"\n\t\t\t\t\"space at 0x%llx\\n\",\n\t\t\t\t(unsigned long long)pci_resource_start(dev, 0));\n\t\t\tpci_disable_device(dev);\n\t\t\tpci_dev_put(dev);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tprintk(KERN_INFO \"Applicom %s found at mem 0x%llx, irq %d\\n\",\n\t\t       applicom_pci_devnames[dev->device-1],\n\t\t\t   (unsigned long long)pci_resource_start(dev, 0),\n\t\t       dev->irq);\n\n\t\tboardno = ac_register_board(pci_resource_start(dev, 0),\n\t\t\t\tRamIO, 0);\n\t\tif (!boardno) {\n\t\t\tprintk(KERN_INFO \"ac.o: PCI Applicom device doesn't have correct signature.\\n\");\n\t\t\tiounmap(RamIO);\n\t\t\tpci_disable_device(dev);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (request_irq(dev->irq, &ac_interrupt, IRQF_SHARED, \"Applicom PCI\", &dummy)) {\n\t\t\tprintk(KERN_INFO \"Could not allocate IRQ %d for PCI Applicom device.\\n\", dev->irq);\n\t\t\tiounmap(RamIO);\n\t\t\tpci_disable_device(dev);\n\t\t\tapbs[boardno - 1].RamIO = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\n\t\twriteb(0x40, apbs[boardno - 1].RamIO + RAM_IT_FROM_PC);\n\n\t\tapbs[boardno - 1].irq = dev->irq;\n\t}\n\n\t \n\n\tif (!mem || !irq) {\n\t\tif (numboards)\n\t\t\tgoto fin;\n\t\telse {\n\t\t\tprintk(KERN_INFO \"ac.o: No PCI boards found.\\n\");\n\t\t\tprintk(KERN_INFO \"ac.o: For an ISA board you must supply memory and irq parameters.\\n\");\n\t\t\treturn -ENXIO;\n\t\t}\n\t}\n\n\t \n\n\tfor (i = 0; i < MAX_ISA_BOARD; i++) {\n\t\tRamIO = ioremap(mem + (LEN_RAM_IO * i), LEN_RAM_IO);\n\n\t\tif (!RamIO) {\n\t\t\tprintk(KERN_INFO \"ac.o: Failed to ioremap the ISA card's memory space (slot #%d)\\n\", i + 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!(boardno = ac_register_board((unsigned long)mem+ (LEN_RAM_IO*i),\n\t\t\t\t\t\t  RamIO,i+1))) {\n\t\t\tiounmap(RamIO);\n\t\t\tcontinue;\n\t\t}\n\n\t\tprintk(KERN_NOTICE \"Applicom ISA card found at mem 0x%lx, irq %d\\n\", mem + (LEN_RAM_IO*i), irq);\n\n\t\tif (!numisa) {\n\t\t\tif (request_irq(irq, &ac_interrupt, IRQF_SHARED, \"Applicom ISA\", &dummy)) {\n\t\t\t\tprintk(KERN_WARNING \"Could not allocate IRQ %d for ISA Applicom device.\\n\", irq);\n\t\t\t\tiounmap(RamIO);\n\t\t\t\tapbs[boardno - 1].RamIO = NULL;\n\t\t\t}\n\t\t\telse\n\t\t\t\tapbs[boardno - 1].irq = irq;\n\t\t}\n\t\telse\n\t\t\tapbs[boardno - 1].irq = 0;\n\n\t\tnumisa++;\n\t}\n\n\tif (!numisa)\n\t\tprintk(KERN_WARNING \"ac.o: No valid ISA Applicom boards found \"\n\t\t\t\t\"at mem 0x%lx\\n\", mem);\n\n fin:\n\tinit_waitqueue_head(&FlagSleepRec);\n\n\tWriteErrorCount = 0;\n\tReadErrorCount = 0;\n\tDeviceErrorCount = 0;\n\n\tif (numboards) {\n\t\tret = misc_register(&ac_miscdev);\n\t\tif (ret) {\n\t\t\tprintk(KERN_WARNING \"ac.o: Unable to register misc device\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tfor (i = 0; i < MAX_BOARD; i++) {\n\t\t\tint serial;\n\t\t\tchar boardname[(SERIAL_NUMBER - TYPE_CARD) + 1];\n\n\t\t\tif (!apbs[i].RamIO)\n\t\t\t\tcontinue;\n\n\t\t\tfor (serial = 0; serial < SERIAL_NUMBER - TYPE_CARD; serial++)\n\t\t\t\tboardname[serial] = readb(apbs[i].RamIO + TYPE_CARD + serial);\n\n\t\t\tboardname[serial] = 0;\n\n\n\t\t\tprintk(KERN_INFO \"Applicom board %d: %s, PROM V%d.%d\",\n\t\t\t       i+1, boardname,\n\t\t\t       (int)(readb(apbs[i].RamIO + VERS) >> 4),\n\t\t\t       (int)(readb(apbs[i].RamIO + VERS) & 0xF));\n\t\t\t\n\t\t\tserial = (readb(apbs[i].RamIO + SERIAL_NUMBER) << 16) + \n\t\t\t\t(readb(apbs[i].RamIO + SERIAL_NUMBER + 1) << 8) + \n\t\t\t\t(readb(apbs[i].RamIO + SERIAL_NUMBER + 2) );\n\n\t\t\tif (serial != 0)\n\t\t\t\tprintk(\" S/N %d\\n\", serial);\n\t\t\telse\n\t\t\t\tprintk(\"\\n\");\n\t\t}\n\t\treturn 0;\n\t}\n\n\telse\n\t\treturn -ENXIO;\n\nout:\n\tfor (i = 0; i < MAX_BOARD; i++) {\n\t\tif (!apbs[i].RamIO)\n\t\t\tcontinue;\n\t\tif (apbs[i].irq)\n\t\t\tfree_irq(apbs[i].irq, &dummy);\n\t\tiounmap(apbs[i].RamIO);\n\t}\n\treturn ret;\n}\n\nmodule_init(applicom_init);\nmodule_exit(applicom_exit);\n\n\nstatic ssize_t ac_write(struct file *file, const char __user *buf, size_t count, loff_t * ppos)\n{\n\tunsigned int NumCard;\t \n\tunsigned int IndexCard;\t \n\tunsigned char TicCard;\t \n\tunsigned long flags;\t \n\tstruct st_ram_io st_loc;\n\tstruct mailbox tmpmailbox;\n#ifdef DEBUG\n\tint c;\n#endif\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tif (count != sizeof(struct st_ram_io) + sizeof(struct mailbox)) {\n\t\tstatic int warncount = 5;\n\t\tif (warncount) {\n\t\t\tprintk(KERN_INFO \"Hmmm. write() of Applicom card, length %zd != expected %zd\\n\",\n\t\t\t       count, sizeof(struct st_ram_io) + sizeof(struct mailbox));\n\t\t\twarncount--;\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\n\tif(copy_from_user(&st_loc, buf, sizeof(struct st_ram_io))) \n\t\treturn -EFAULT;\n\t\n\tif(copy_from_user(&tmpmailbox, &buf[sizeof(struct st_ram_io)],\n\t\t\t  sizeof(struct mailbox))) \n\t\treturn -EFAULT;\n\n\tNumCard = st_loc.num_card;\t \n\tTicCard = st_loc.tic_des_from_pc;\t \n\tIndexCard = NumCard - 1;\n\n\tif (IndexCard >= MAX_BOARD)\n\t\treturn -EINVAL;\n\tIndexCard = array_index_nospec(IndexCard, MAX_BOARD);\n\n\tif (!apbs[IndexCard].RamIO)\n\t\treturn -EINVAL;\n\n#ifdef DEBUG\n\tprintk(\"Write to applicom card #%d. struct st_ram_io follows:\",\n\t       IndexCard+1);\n\n\t\tfor (c = 0; c < sizeof(struct st_ram_io);) {\n\t\t\n\t\t\tprintk(\"\\n%5.5X: %2.2X\", c, ((unsigned char *) &st_loc)[c]);\n\n\t\t\tfor (c++; c % 8 && c < sizeof(struct st_ram_io); c++) {\n\t\t\t\tprintk(\" %2.2X\", ((unsigned char *) &st_loc)[c]);\n\t\t\t}\n\t\t}\n\n\t\tprintk(\"\\nstruct mailbox follows:\");\n\n\t\tfor (c = 0; c < sizeof(struct mailbox);) {\n\t\t\tprintk(\"\\n%5.5X: %2.2X\", c, ((unsigned char *) &tmpmailbox)[c]);\n\n\t\t\tfor (c++; c % 8 && c < sizeof(struct mailbox); c++) {\n\t\t\t\tprintk(\" %2.2X\", ((unsigned char *) &tmpmailbox)[c]);\n\t\t\t}\n\t\t}\n\n\t\tprintk(\"\\n\");\n#endif\n\n\tspin_lock_irqsave(&apbs[IndexCard].mutex, flags);\n\n\t \n\tif(readb(apbs[IndexCard].RamIO + DATA_FROM_PC_READY) > 2) { \n\t\tDummy = readb(apbs[IndexCard].RamIO + VERS);\n\t\tspin_unlock_irqrestore(&apbs[IndexCard].mutex, flags);\n\t\tprintk(KERN_WARNING \"APPLICOM driver write error board %d, DataFromPcReady = %d\\n\",\n\t\t       IndexCard,(int)readb(apbs[IndexCard].RamIO + DATA_FROM_PC_READY));\n\t\tDeviceErrorCount++;\n\t\treturn -EIO;\n\t}\n\t\n\t \n\tset_current_state(TASK_INTERRUPTIBLE);\n\tadd_wait_queue(&apbs[IndexCard].FlagSleepSend, &wait);\n\n\t \n\twhile (readb(apbs[IndexCard].RamIO + DATA_FROM_PC_READY) != 0) {\n\t\tDummy = readb(apbs[IndexCard].RamIO + VERS);\n\t\t \n\n\t\tspin_unlock_irqrestore(&apbs[IndexCard].mutex, flags);\n\t\tschedule();\n\t\tif (signal_pending(current)) {\n\t\t\tremove_wait_queue(&apbs[IndexCard].FlagSleepSend,\n\t\t\t\t\t  &wait);\n\t\t\treturn -EINTR;\n\t\t}\n\t\tspin_lock_irqsave(&apbs[IndexCard].mutex, flags);\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t}\n\n\t \n\tset_current_state(TASK_RUNNING);\n\tremove_wait_queue(&apbs[IndexCard].FlagSleepSend, &wait);\n\n\twriteb(1, apbs[IndexCard].RamIO + DATA_FROM_PC_READY);\n\n\t \n\t{\n\t\tunsigned char *from = (unsigned char *) &tmpmailbox;\n\t\tvoid __iomem *to = apbs[IndexCard].RamIO + RAM_FROM_PC;\n\t\tint c;\n\n\t\tfor (c = 0; c < sizeof(struct mailbox); c++)\n\t\t\twriteb(*(from++), to++);\n\t}\n\n\twriteb(0x20, apbs[IndexCard].RamIO + TIC_OWNER_FROM_PC);\n\twriteb(0xff, apbs[IndexCard].RamIO + NUMCARD_OWNER_FROM_PC);\n\twriteb(TicCard, apbs[IndexCard].RamIO + TIC_DES_FROM_PC);\n\twriteb(NumCard, apbs[IndexCard].RamIO + NUMCARD_DES_FROM_PC);\n\twriteb(2, apbs[IndexCard].RamIO + DATA_FROM_PC_READY);\n\twriteb(1, apbs[IndexCard].RamIO + RAM_IT_FROM_PC);\n\tDummy = readb(apbs[IndexCard].RamIO + VERS);\n\tspin_unlock_irqrestore(&apbs[IndexCard].mutex, flags);\n\treturn 0;\n}\n\nstatic int do_ac_read(int IndexCard, char __user *buf,\n\t\tstruct st_ram_io *st_loc, struct mailbox *mailbox)\n{\n\tvoid __iomem *from = apbs[IndexCard].RamIO + RAM_TO_PC;\n\tunsigned char *to = (unsigned char *)mailbox;\n#ifdef DEBUG\n\tint c;\n#endif\n\n\tst_loc->tic_owner_to_pc = readb(apbs[IndexCard].RamIO + TIC_OWNER_TO_PC);\n\tst_loc->numcard_owner_to_pc = readb(apbs[IndexCard].RamIO + NUMCARD_OWNER_TO_PC);\n\n\n\t{\n\t\tint c;\n\n\t\tfor (c = 0; c < sizeof(struct mailbox); c++)\n\t\t\t*(to++) = readb(from++);\n\t}\n\twriteb(1, apbs[IndexCard].RamIO + ACK_FROM_PC_READY);\n\twriteb(1, apbs[IndexCard].RamIO + TYP_ACK_FROM_PC);\n\twriteb(IndexCard+1, apbs[IndexCard].RamIO + NUMCARD_ACK_FROM_PC);\n\twriteb(readb(apbs[IndexCard].RamIO + TIC_OWNER_TO_PC), \n\t       apbs[IndexCard].RamIO + TIC_ACK_FROM_PC);\n\twriteb(2, apbs[IndexCard].RamIO + ACK_FROM_PC_READY);\n\twriteb(0, apbs[IndexCard].RamIO + DATA_TO_PC_READY);\n\twriteb(2, apbs[IndexCard].RamIO + RAM_IT_FROM_PC);\n\tDummy = readb(apbs[IndexCard].RamIO + VERS);\n\n#ifdef DEBUG\n\t\tprintk(\"Read from applicom card #%d. struct st_ram_io follows:\", NumCard);\n\n\t\tfor (c = 0; c < sizeof(struct st_ram_io);) {\n\t\t\tprintk(\"\\n%5.5X: %2.2X\", c, ((unsigned char *)st_loc)[c]);\n\n\t\t\tfor (c++; c % 8 && c < sizeof(struct st_ram_io); c++) {\n\t\t\t\tprintk(\" %2.2X\", ((unsigned char *)st_loc)[c]);\n\t\t\t}\n\t\t}\n\n\t\tprintk(\"\\nstruct mailbox follows:\");\n\n\t\tfor (c = 0; c < sizeof(struct mailbox);) {\n\t\t\tprintk(\"\\n%5.5X: %2.2X\", c, ((unsigned char *)mailbox)[c]);\n\n\t\t\tfor (c++; c % 8 && c < sizeof(struct mailbox); c++) {\n\t\t\t\tprintk(\" %2.2X\", ((unsigned char *)mailbox)[c]);\n\t\t\t}\n\t\t}\n\t\tprintk(\"\\n\");\n#endif\n\treturn (sizeof(struct st_ram_io) + sizeof(struct mailbox));\n}\n\nstatic ssize_t ac_read (struct file *filp, char __user *buf, size_t count, loff_t *ptr)\n{\n\tunsigned long flags;\n\tunsigned int i;\n\tunsigned char tmp;\n\tint ret = 0;\n\tDECLARE_WAITQUEUE(wait, current);\n#ifdef DEBUG\n\tint loopcount=0;\n#endif\n\t \n\tif (count != sizeof(struct st_ram_io) + sizeof(struct mailbox)) {\n\t\tprintk( KERN_WARNING \"Hmmm. read() of Applicom card, length %zd != expected %zd\\n\",\n\t\t\tcount,sizeof(struct st_ram_io) + sizeof(struct mailbox));\n\t\treturn -EINVAL;\n\t}\n\t\n\twhile(1) {\n\t\t \n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tadd_wait_queue(&FlagSleepRec, &wait);\n\t\t\n\t\t \n\t\tfor (i=0; i < MAX_BOARD; i++) {\n\t\t\tif (!apbs[i].RamIO)\n\t\t\t\tcontinue;\n\t\t\tspin_lock_irqsave(&apbs[i].mutex, flags);\n\t\t\t\n\t\t\ttmp = readb(apbs[i].RamIO + DATA_TO_PC_READY);\n\t\t\t\n\t\t\tif (tmp == 2) {\n\t\t\t\tstruct st_ram_io st_loc;\n\t\t\t\tstruct mailbox mailbox;\n\n\t\t\t\t \n\t\t\t\tmemset(&st_loc, 0, sizeof(st_loc));\n\t\t\t\tret = do_ac_read(i, buf, &st_loc, &mailbox);\n\t\t\t\tspin_unlock_irqrestore(&apbs[i].mutex, flags);\n\t\t\t\tset_current_state(TASK_RUNNING);\n\t\t\t\tremove_wait_queue(&FlagSleepRec, &wait);\n\n\t\t\t\tif (copy_to_user(buf, &st_loc, sizeof(st_loc)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tif (copy_to_user(buf + sizeof(st_loc), &mailbox, sizeof(mailbox)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\t\n\t\t\tif (tmp > 2) {\n\t\t\t\t \n\t\t\t\tDummy = readb(apbs[i].RamIO + VERS);\n\t\t\t\t\n\t\t\t\tspin_unlock_irqrestore(&apbs[i].mutex, flags);\n\t\t\t\tset_current_state(TASK_RUNNING);\n\t\t\t\tremove_wait_queue(&FlagSleepRec, &wait);\n\t\t\t\t\n\t\t\t\tprintk(KERN_WARNING \"APPLICOM driver read error board %d, DataToPcReady = %d\\n\",\n\t\t\t\t       i,(int)readb(apbs[i].RamIO + DATA_TO_PC_READY));\n\t\t\t\tDeviceErrorCount++;\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\t\n\t\t\t \n\t\t\tDummy = readb(apbs[i].RamIO + VERS);\n\t\t\tspin_unlock_irqrestore(&apbs[i].mutex, flags);\n\t\t\t\n\t\t}  \n\n\t\t \n\n\t\tschedule();\n\t\tremove_wait_queue(&FlagSleepRec, &wait);\n\n\t\tif (signal_pending(current))\n\t\t\treturn -EINTR;\n\n#ifdef DEBUG\n\t\tif (loopcount++ > 2) {\n\t\t\tprintk(KERN_DEBUG \"Looping in ac_read. loopcount %d\\n\", loopcount);\n\t\t}\n#endif\n\t} \n}\n\nstatic irqreturn_t ac_interrupt(int vec, void *dev_instance)\n{\n\tunsigned int i;\n\tunsigned int FlagInt;\n\tunsigned int LoopCount;\n\tint handled = 0;\n\n\t\n\n\tLoopCount = 0;\n\n\tdo {\n\t\tFlagInt = 0;\n\t\tfor (i = 0; i < MAX_BOARD; i++) {\n\t\t\t\n\t\t\t \n\t\t\tif (!apbs[i].RamIO)\n\t\t\t\tcontinue;\n\n\t\t\tspin_lock(&apbs[i].mutex);\n\n\t\t\t \n\t\t\tif(readb(apbs[i].RamIO + RAM_IT_TO_PC) == 0) {\n\t\t\t\tspin_unlock(&apbs[i].mutex);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\thandled = 1;\n\t\t\tFlagInt = 1;\n\t\t\twriteb(0, apbs[i].RamIO + RAM_IT_TO_PC);\n\n\t\t\tif (readb(apbs[i].RamIO + DATA_TO_PC_READY) > 2) {\n\t\t\t\tprintk(KERN_WARNING \"APPLICOM driver interrupt err board %d, DataToPcReady = %d\\n\",\n\t\t\t\t       i+1,(int)readb(apbs[i].RamIO + DATA_TO_PC_READY));\n\t\t\t\tDeviceErrorCount++;\n\t\t\t}\n\n\t\t\tif((readb(apbs[i].RamIO + DATA_FROM_PC_READY) > 2) && \n\t\t\t   (readb(apbs[i].RamIO + DATA_FROM_PC_READY) != 6)) {\n\t\t\t\t\n\t\t\t\tprintk(KERN_WARNING \"APPLICOM driver interrupt err board %d, DataFromPcReady = %d\\n\",\n\t\t\t\t       i+1,(int)readb(apbs[i].RamIO + DATA_FROM_PC_READY));\n\t\t\t\tDeviceErrorCount++;\n\t\t\t}\n\n\t\t\tif (readb(apbs[i].RamIO + DATA_TO_PC_READY) == 2) {\t \n\t\t\t\tif (waitqueue_active(&FlagSleepRec)) {\n\t\t\t\twake_up_interruptible(&FlagSleepRec);\n\t\t\t}\n\t\t\t}\n\n\t\t\tif (readb(apbs[i].RamIO + DATA_FROM_PC_READY) == 0) {\t \n\t\t\t\tif (waitqueue_active(&apbs[i].FlagSleepSend)) {\t \n\t\t\t\t\twake_up_interruptible(&apbs[i].FlagSleepSend);\n\t\t\t\t}\n\t\t\t}\n\t\t\tDummy = readb(apbs[i].RamIO + VERS);\n\n\t\t\tif(readb(apbs[i].RamIO + RAM_IT_TO_PC)) {\n\t\t\t\t \n\t\t\t\tspin_unlock(&apbs[i].mutex);\n\t\t\t\ti--;\n\t\t\t} else {\n\t\t\t\tspin_unlock(&apbs[i].mutex);\n\t\t\t}\n\t\t}\n\t\tif (FlagInt)\n\t\t\tLoopCount = 0;\n\t\telse\n\t\t\tLoopCount++;\n\t} while(LoopCount < 2);\n\treturn IRQ_RETVAL(handled);\n}\n\n\n\nstatic long ac_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n     \n{\t\t\t\t \n\tint i;\n\tunsigned char IndexCard;\n\tvoid __iomem *pmem;\n\tint ret = 0;\n\tstatic int warncount = 10;\n\tvolatile unsigned char byte_reset_it;\n\tstruct st_ram_io *adgl;\n\tvoid __user *argp = (void __user *)arg;\n\n\t \n\n\tadgl = memdup_user(argp, sizeof(struct st_ram_io));\n\tif (IS_ERR(adgl))\n\t\treturn PTR_ERR(adgl);\n\n\tmutex_lock(&ac_mutex);\t\n\tIndexCard = adgl->num_card-1;\n\t \n\tif (cmd != 6 && IndexCard >= MAX_BOARD)\n\t\tgoto err;\n\tIndexCard = array_index_nospec(IndexCard, MAX_BOARD);\n\n\tif (cmd != 6 && !apbs[IndexCard].RamIO)\n\t\tgoto err;\n\n\tswitch (cmd) {\n\t\t\n\tcase 0:\n\t\tpmem = apbs[IndexCard].RamIO;\n\t\tfor (i = 0; i < sizeof(struct st_ram_io); i++)\n\t\t\t((unsigned char *)adgl)[i]=readb(pmem++);\n\t\tif (copy_to_user(argp, adgl, sizeof(struct st_ram_io)))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\tcase 1:\n\t\tpmem = apbs[IndexCard].RamIO + CONF_END_TEST;\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tadgl->conf_end_test[i] = readb(pmem++);\n\t\tfor (i = 0; i < 2; i++)\n\t\t\tadgl->error_code[i] = readb(pmem++);\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tadgl->parameter_error[i] = readb(pmem++);\n\t\tpmem = apbs[IndexCard].RamIO + VERS;\n\t\tadgl->vers = readb(pmem);\n\t\tpmem = apbs[IndexCard].RamIO + TYPE_CARD;\n\t\tfor (i = 0; i < 20; i++)\n\t\t\tadgl->reserv1[i] = readb(pmem++);\n\t\t*(int *)&adgl->reserv1[20] =  \n\t\t\t(readb(apbs[IndexCard].RamIO + SERIAL_NUMBER) << 16) + \n\t\t\t(readb(apbs[IndexCard].RamIO + SERIAL_NUMBER + 1) << 8) + \n\t\t\t(readb(apbs[IndexCard].RamIO + SERIAL_NUMBER + 2) );\n\n\t\tif (copy_to_user(argp, adgl, sizeof(struct st_ram_io)))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\tcase 2:\n\t\tpmem = apbs[IndexCard].RamIO + CONF_END_TEST;\n\t\tfor (i = 0; i < 10; i++)\n\t\t\twriteb(0xff, pmem++);\n\t\twriteb(adgl->data_from_pc_ready, \n\t\t       apbs[IndexCard].RamIO + DATA_FROM_PC_READY);\n\n\t\twriteb(1, apbs[IndexCard].RamIO + RAM_IT_FROM_PC);\n\t\t\n\t\tfor (i = 0; i < MAX_BOARD; i++) {\n\t\t\tif (apbs[i].RamIO) {\n\t\t\t\tbyte_reset_it = readb(apbs[i].RamIO + RAM_IT_TO_PC);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 3:\n\t\tpmem = apbs[IndexCard].RamIO + TIC_DES_FROM_PC;\n\t\twriteb(adgl->tic_des_from_pc, pmem);\n\t\tbreak;\n\tcase 4:\n\t\tpmem = apbs[IndexCard].RamIO + TIC_OWNER_TO_PC;\n\t\tadgl->tic_owner_to_pc     = readb(pmem++);\n\t\tadgl->numcard_owner_to_pc = readb(pmem);\n\t\tif (copy_to_user(argp, adgl,sizeof(struct st_ram_io)))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\tcase 5:\n\t\twriteb(adgl->num_card, apbs[IndexCard].RamIO + NUMCARD_OWNER_TO_PC);\n\t\twriteb(adgl->num_card, apbs[IndexCard].RamIO + NUMCARD_DES_FROM_PC);\n\t\twriteb(adgl->num_card, apbs[IndexCard].RamIO + NUMCARD_ACK_FROM_PC);\n\t\twriteb(4, apbs[IndexCard].RamIO + DATA_FROM_PC_READY);\n\t\twriteb(1, apbs[IndexCard].RamIO + RAM_IT_FROM_PC);\n\t\tbreak;\n\tcase 6:\n\t\tprintk(KERN_INFO \"APPLICOM driver release .... V2.8.0 ($Revision: 1.30 $)\\n\");\n\t\tprintk(KERN_INFO \"Number of installed boards . %d\\n\", (int) numboards);\n\t\tprintk(KERN_INFO \"Segment of board ........... %X\\n\", (int) mem);\n\t\tprintk(KERN_INFO \"Interrupt IRQ number ....... %d\\n\", (int) irq);\n\t\tfor (i = 0; i < MAX_BOARD; i++) {\n\t\t\tint serial;\n\t\t\tchar boardname[(SERIAL_NUMBER - TYPE_CARD) + 1];\n\n\t\t\tif (!apbs[i].RamIO)\n\t\t\t\tcontinue;\n\n\t\t\tfor (serial = 0; serial < SERIAL_NUMBER - TYPE_CARD; serial++)\n\t\t\t\tboardname[serial] = readb(apbs[i].RamIO + TYPE_CARD + serial);\n\t\t\tboardname[serial] = 0;\n\n\t\t\tprintk(KERN_INFO \"Prom version board %d ....... V%d.%d %s\",\n\t\t\t       i+1,\n\t\t\t       (int)(readb(apbs[i].RamIO + VERS) >> 4),\n\t\t\t       (int)(readb(apbs[i].RamIO + VERS) & 0xF),\n\t\t\t       boardname);\n\n\n\t\t\tserial = (readb(apbs[i].RamIO + SERIAL_NUMBER) << 16) + \n\t\t\t\t(readb(apbs[i].RamIO + SERIAL_NUMBER + 1) << 8) + \n\t\t\t\t(readb(apbs[i].RamIO + SERIAL_NUMBER + 2) );\n\n\t\t\tif (serial != 0)\n\t\t\t\tprintk(\" S/N %d\\n\", serial);\n\t\t\telse\n\t\t\t\tprintk(\"\\n\");\n\t\t}\n\t\tif (DeviceErrorCount != 0)\n\t\t\tprintk(KERN_INFO \"DeviceErrorCount ........... %d\\n\", DeviceErrorCount);\n\t\tif (ReadErrorCount != 0)\n\t\t\tprintk(KERN_INFO \"ReadErrorCount ............. %d\\n\", ReadErrorCount);\n\t\tif (WriteErrorCount != 0)\n\t\t\tprintk(KERN_INFO \"WriteErrorCount ............ %d\\n\", WriteErrorCount);\n\t\tif (waitqueue_active(&FlagSleepRec))\n\t\t\tprintk(KERN_INFO \"Process in read pending\\n\");\n\t\tfor (i = 0; i < MAX_BOARD; i++) {\n\t\t\tif (apbs[i].RamIO && waitqueue_active(&apbs[i].FlagSleepSend))\n\t\t\t\tprintk(KERN_INFO \"Process in write pending board %d\\n\",i+1);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOTTY;\n\t\tbreak;\n\t}\n\tDummy = readb(apbs[IndexCard].RamIO + VERS);\n\tkfree(adgl);\n\tmutex_unlock(&ac_mutex);\n\treturn ret;\n\nerr:\n\tif (warncount) {\n\t\tpr_warn(\"APPLICOM driver IOCTL, bad board number %d\\n\",\n\t\t\t(int)IndexCard + 1);\n\t\twarncount--;\n\t}\n\tkfree(adgl);\n\tmutex_unlock(&ac_mutex);\n\treturn -EINVAL;\n\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}