{
  "module_name": "toshiba.c",
  "hash_id": "fd814e383b684b761b5674bca4d87f65bf6cc573cd2c5671483a5208c3e409de",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/toshiba.c",
  "human_readable_source": "\n \n\n#define TOSH_VERSION \"1.11 26/9/2001\"\n#define TOSH_DEBUG 0\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/ioport.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/init.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/toshiba.h>\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Jonathan Buzzard <jonathan@buzzard.org.uk>\");\nMODULE_DESCRIPTION(\"Toshiba laptop SMM driver\");\n\nstatic DEFINE_MUTEX(tosh_mutex);\nstatic int tosh_fn;\nmodule_param_named(fn, tosh_fn, int, 0);\nMODULE_PARM_DESC(fn, \"User specified Fn key detection port\");\n\nstatic int tosh_id;\nstatic int tosh_bios;\nstatic int tosh_date;\nstatic int tosh_sci;\nstatic int tosh_fan;\n\nstatic long tosh_ioctl(struct file *, unsigned int,\n\tunsigned long);\n\n\nstatic const struct file_operations tosh_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.unlocked_ioctl\t= tosh_ioctl,\n\t.llseek\t\t= noop_llseek,\n};\n\nstatic struct miscdevice tosh_device = {\n\tTOSH_MINOR_DEV,\n\t\"toshiba\",\n\t&tosh_fops\n};\n\n \n#ifdef CONFIG_PROC_FS\nstatic int tosh_fn_status(void)\n{\n        unsigned char scan;\n\tunsigned long flags;\n\n\tif (tosh_fn!=0) {\n\t\tscan = inb(tosh_fn);\n\t} else {\n\t\tlocal_irq_save(flags);\n\t\toutb(0x8e, 0xe4);\n\t\tscan = inb(0xe5);\n\t\tlocal_irq_restore(flags);\n\t}\n\n        return (int) scan;\n}\n#endif\n\n\n \nstatic int tosh_emulate_fan(SMMRegisters *regs)\n{\n\tunsigned long eax,ecx,flags;\n\tunsigned char al;\n\n\teax = regs->eax & 0xff00;\n\tecx = regs->ecx & 0xffff;\n\n\t \n\n\tif (tosh_id==0xfccb) {\n\t\tif (eax==0xfe00) {\n\t\t\t \n\t\t\tlocal_irq_save(flags);\n\t\t\toutb(0xbe, 0xe4);\n\t\t\tal = inb(0xe5);\n\t\t\tlocal_irq_restore(flags);\n\t\t\tregs->eax = 0x00;\n\t\t\tregs->ecx = (unsigned int) (al & 0x01);\n\t\t}\n\t\tif ((eax==0xff00) && (ecx==0x0000)) {\n\t\t\t \n\t\t\tlocal_irq_save(flags);\n\t\t\toutb(0xbe, 0xe4);\n\t\t\tal = inb(0xe5);\n\t\t\toutb(0xbe, 0xe4);\n\t\t\toutb (al | 0x01, 0xe5);\n\t\t\tlocal_irq_restore(flags);\n\t\t\tregs->eax = 0x00;\n\t\t\tregs->ecx = 0x00;\n\t\t}\n\t\tif ((eax==0xff00) && (ecx==0x0001)) {\n\t\t\t \n\t\t\tlocal_irq_save(flags);\n\t\t\toutb(0xbe, 0xe4);\n\t\t\tal = inb(0xe5);\n\t\t\toutb(0xbe, 0xe4);\n\t\t\toutb(al & 0xfe, 0xe5);\n\t\t\tlocal_irq_restore(flags);\n\t\t\tregs->eax = 0x00;\n\t\t\tregs->ecx = 0x01;\n\t\t}\n\t}\n\n\t \n\n\tif (tosh_id==0xfccc) {\n\t\tif (eax==0xfe00) {\n\t\t\t \n\t\t\tlocal_irq_save(flags);\n\t\t\toutb(0xe0, 0xe4);\n\t\t\tal = inb(0xe5);\n\t\t\tlocal_irq_restore(flags);\n\t\t\tregs->eax = 0x00;\n\t\t\tregs->ecx = al & 0x01;\n\t\t}\n\t\tif ((eax==0xff00) && (ecx==0x0000)) {\n\t\t\t \n\t\t\tlocal_irq_save(flags);\n\t\t\toutb(0xe0, 0xe4);\n\t\t\tal = inb(0xe5);\n\t\t\toutw(0xe0 | ((al & 0xfe) << 8), 0xe4);\n\t\t\tlocal_irq_restore(flags);\n\t\t\tregs->eax = 0x00;\n\t\t\tregs->ecx = 0x00;\n\t\t}\n\t\tif ((eax==0xff00) && (ecx==0x0001)) {\n\t\t\t \n\t\t\tlocal_irq_save(flags);\n\t\t\toutb(0xe0, 0xe4);\n\t\t\tal = inb(0xe5);\n\t\t\toutw(0xe0 | ((al | 0x01) << 8), 0xe4);\n\t\t\tlocal_irq_restore(flags);\n\t\t\tregs->eax = 0x00;\n\t\t\tregs->ecx = 0x01;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\n \nint tosh_smm(SMMRegisters *regs)\n{\n\tint eax;\n\n\tasm (\"# load the values into the registers\\n\\t\" \\\n\t\t\"pushl %%eax\\n\\t\" \\\n\t\t\"movl 0(%%eax),%%edx\\n\\t\" \\\n\t\t\"push %%edx\\n\\t\" \\\n\t\t\"movl 4(%%eax),%%ebx\\n\\t\" \\\n\t\t\"movl 8(%%eax),%%ecx\\n\\t\" \\\n\t\t\"movl 12(%%eax),%%edx\\n\\t\" \\\n\t\t\"movl 16(%%eax),%%esi\\n\\t\" \\\n\t\t\"movl 20(%%eax),%%edi\\n\\t\" \\\n\t\t\"popl %%eax\\n\\t\" \\\n\t\t\"# call the System Management mode\\n\\t\" \\\n\t\t\"inb $0xb2,%%al\\n\\t\"\n\t\t\"# fill out the memory with the values in the registers\\n\\t\" \\\n\t\t\"xchgl %%eax,(%%esp)\\n\\t\"\n\t\t\"movl %%ebx,4(%%eax)\\n\\t\" \\\n\t\t\"movl %%ecx,8(%%eax)\\n\\t\" \\\n\t\t\"movl %%edx,12(%%eax)\\n\\t\" \\\n\t\t\"movl %%esi,16(%%eax)\\n\\t\" \\\n\t\t\"movl %%edi,20(%%eax)\\n\\t\" \\\n\t\t\"popl %%edx\\n\\t\" \\\n\t\t\"movl %%edx,0(%%eax)\\n\\t\" \\\n\t\t\"# setup the return value to the carry flag\\n\\t\" \\\n\t\t\"lahf\\n\\t\" \\\n\t\t\"shrl $8,%%eax\\n\\t\" \\\n\t\t\"andl $1,%%eax\\n\" \\\n\t\t: \"=a\" (eax)\n\t\t: \"a\" (regs)\n\t\t: \"%ebx\", \"%ecx\", \"%edx\", \"%esi\", \"%edi\", \"memory\");\n\n\treturn eax;\n}\nEXPORT_SYMBOL(tosh_smm);\n\n\nstatic long tosh_ioctl(struct file *fp, unsigned int cmd, unsigned long arg)\n{\n\tSMMRegisters regs;\n\tSMMRegisters __user *argp = (SMMRegisters __user *)arg;\n\tunsigned short ax,bx;\n\tint err;\n\n\tif (!argp)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&regs, argp, sizeof(SMMRegisters)))\n\t\treturn -EFAULT;\n\n\tswitch (cmd) {\n\t\tcase TOSH_SMM:\n\t\t\tax = regs.eax & 0xff00;\n\t\t\tbx = regs.ebx & 0xffff;\n\t\t\t \n\t\t\tif (((ax==0xff00) || (ax==0xfe00)) && (bx>0x0069))\n\t\t\t\treturn -EINVAL;\n\n\t\t\t \n\t\t\tmutex_lock(&tosh_mutex);\n\t\t\tif (tosh_fan==1) {\n\t\t\t\tif (((ax==0xf300) || (ax==0xf400)) && (bx==0x0004)) {\n\t\t\t\t\terr = tosh_emulate_fan(&regs);\n\t\t\t\t\tmutex_unlock(&tosh_mutex);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\terr = tosh_smm(&regs);\n\t\t\tmutex_unlock(&tosh_mutex);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\n        if (copy_to_user(argp, &regs, sizeof(SMMRegisters)))\n        \treturn -EFAULT;\n\n\treturn (err==0) ? 0:-EINVAL;\n}\n\n\n \n#ifdef CONFIG_PROC_FS\nstatic int proc_toshiba_show(struct seq_file *m, void *v)\n{\n\tint key;\n\n\tkey = tosh_fn_status();\n\n\t \n\tseq_printf(m, \"1.1 0x%04x %d.%d %d.%d 0x%04x 0x%02x\\n\",\n\t\ttosh_id,\n\t\t(tosh_sci & 0xff00)>>8,\n\t\ttosh_sci & 0xff,\n\t\t(tosh_bios & 0xff00)>>8,\n\t\ttosh_bios & 0xff,\n\t\ttosh_date,\n\t\tkey);\n\treturn 0;\n}\n#endif\n\n\n \nstatic void tosh_set_fn_port(void)\n{\n\tswitch (tosh_id) {\n\t\tcase 0xfc02: case 0xfc04: case 0xfc09: case 0xfc0a: case 0xfc10:\n\t\tcase 0xfc11: case 0xfc13: case 0xfc15: case 0xfc1a: case 0xfc1b:\n\t\tcase 0xfc5a:\n\t\t\ttosh_fn = 0x62;\n\t\t\tbreak;\n\t\tcase 0xfc08: case 0xfc17: case 0xfc1d: case 0xfcd1: case 0xfce0:\n\t\tcase 0xfce2:\n\t\t\ttosh_fn = 0x68;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttosh_fn = 0x00;\n\t\t\tbreak;\n\t}\n\n\treturn;\n}\n\n\n \nstatic int tosh_get_machine_id(void __iomem *bios)\n{\n\tint id;\n\tSMMRegisters regs;\n\tunsigned short bx,cx;\n\tunsigned long address;\n\n\tid = (0x100*(int) readb(bios+0xfffe))+((int) readb(bios+0xfffa));\n\n\t \n\n\tif (id==0xfc2f) {\n\n\t\t \n\n\t\tregs.eax = 0xc000;\n\t\tregs.ebx = 0x0000;\n\t\tregs.ecx = 0x0000;\n\t\ttosh_smm(&regs);\n\t\tbx = (unsigned short) (regs.ebx & 0xffff);\n\n\t\t \n#if TOSH_DEBUG\n\t\tpr_debug(\"toshiba: debugging ID ebx=0x%04x\\n\", regs.ebx);\n#endif\n\t\tbx = 0xe6f5;\n\n\t\t \n\n\t\taddress = bx;\n\t\tcx = readw(bios + address);\n\t\taddress = 9+bx+cx;\n\t\tcx = readw(bios + address);\n\t\taddress = 0xa+cx;\n\t\tcx = readw(bios + address);\n\n\t\t \n\n\t\tid = ((cx & 0xff)<<8)+((cx & 0xff00)>>8);\n\t}\n\n\treturn id;\n}\n\n\n \nstatic int tosh_probe(void)\n{\n\tint i,major,minor,day,year,month,flag;\n\tunsigned char signature[7] = { 0x54,0x4f,0x53,0x48,0x49,0x42,0x41 };\n\tSMMRegisters regs;\n\tvoid __iomem *bios = ioremap(0xf0000, 0x10000);\n\n\tif (!bios)\n\t\treturn -ENOMEM;\n\n\t \n\n\tfor (i=0;i<7;i++) {\n\t\tif (readb(bios+0xe010+i)!=signature[i]) {\n\t\t\tpr_err(\"toshiba: not a supported Toshiba laptop\\n\");\n\t\t\tiounmap(bios);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\t \n\n\tregs.eax = 0xf0f0;\n\tregs.ebx = 0x0000;\n\tregs.ecx = 0x0000;\n\tflag = tosh_smm(&regs);\n\n\t \n\n\tif ((flag==1) || ((regs.eax & 0xff00)==0x8600)) {\n\t\tpr_err(\"toshiba: not a supported Toshiba laptop\\n\");\n\t\tiounmap(bios);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\n\ttosh_sci = regs.edx & 0xffff;\n\n\t \n\n\ttosh_id = tosh_get_machine_id(bios);\n\n\t \n\n\tmajor = readb(bios+0xe009)-'0';\n\tminor = ((readb(bios+0xe00b)-'0')*10)+(readb(bios+0xe00c)-'0');\n\ttosh_bios = (major*0x100)+minor;\n\n\t \n\n\tday = ((readb(bios+0xfff5)-'0')*10)+(readb(bios+0xfff6)-'0');\n\tmonth = ((readb(bios+0xfff8)-'0')*10)+(readb(bios+0xfff9)-'0');\n\tyear = ((readb(bios+0xfffb)-'0')*10)+(readb(bios+0xfffc)-'0');\n\ttosh_date = (((year-90) & 0x1f)<<10) | ((month & 0xf)<<6)\n\t\t| ((day & 0x1f)<<1);\n\n\n\t \n\n\t \n\n\tif ((tosh_id==0xfccb) || (tosh_id==0xfccc))\n\t\ttosh_fan = 1;\n\n\tiounmap(bios);\n\n\treturn 0;\n}\n\nstatic int __init toshiba_init(void)\n{\n\tint retval;\n\t \n\n\tif (tosh_probe())\n\t\treturn -ENODEV;\n\n\tpr_info(\"Toshiba System Management Mode driver v\" TOSH_VERSION \"\\n\");\n\n\t \n\tif (tosh_fn==0x00)\n\t\ttosh_set_fn_port();\n\n\t \n\tretval = misc_register(&tosh_device);\n\tif (retval < 0)\n\t\treturn retval;\n\n#ifdef CONFIG_PROC_FS\n\t{\n\t\tstruct proc_dir_entry *pde;\n\n\t\tpde = proc_create_single(\"toshiba\", 0, NULL, proc_toshiba_show);\n\t\tif (!pde) {\n\t\t\tmisc_deregister(&tosh_device);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n#endif\n\n\treturn 0;\n}\n\nstatic void __exit toshiba_exit(void)\n{\n\tremove_proc_entry(\"toshiba\", NULL);\n\tmisc_deregister(&tosh_device);\n}\n\nmodule_init(toshiba_init);\nmodule_exit(toshiba_exit);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}