{
  "module_name": "misc.c",
  "hash_id": "25224bf713935f004de1f61f40472ad34e003ffbe823d398b4999c545df61315",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/misc.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/miscdevice.h>\n#include <linux/kernel.h>\n#include <linux/major.h>\n#include <linux/mutex.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/stat.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/tty.h>\n#include <linux/kmod.h>\n#include <linux/gfp.h>\n\n \nstatic LIST_HEAD(misc_list);\nstatic DEFINE_MUTEX(misc_mtx);\n\n \n#define DYNAMIC_MINORS 128  \nstatic DEFINE_IDA(misc_minors_ida);\n\nstatic int misc_minor_alloc(void)\n{\n\tint ret;\n\n\tret = ida_alloc_max(&misc_minors_ida, DYNAMIC_MINORS - 1, GFP_KERNEL);\n\tif (ret >= 0) {\n\t\tret = DYNAMIC_MINORS - ret - 1;\n\t} else {\n\t\tret = ida_alloc_range(&misc_minors_ida, MISC_DYNAMIC_MINOR + 1,\n\t\t\t\t      MINORMASK, GFP_KERNEL);\n\t}\n\treturn ret;\n}\n\nstatic void misc_minor_free(int minor)\n{\n\tif (minor < DYNAMIC_MINORS)\n\t\tida_free(&misc_minors_ida, DYNAMIC_MINORS - minor - 1);\n\telse if (minor > MISC_DYNAMIC_MINOR)\n\t\tida_free(&misc_minors_ida, minor);\n}\n\n#ifdef CONFIG_PROC_FS\nstatic void *misc_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\tmutex_lock(&misc_mtx);\n\treturn seq_list_start(&misc_list, *pos);\n}\n\nstatic void *misc_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\treturn seq_list_next(v, &misc_list, pos);\n}\n\nstatic void misc_seq_stop(struct seq_file *seq, void *v)\n{\n\tmutex_unlock(&misc_mtx);\n}\n\nstatic int misc_seq_show(struct seq_file *seq, void *v)\n{\n\tconst struct miscdevice *p = list_entry(v, struct miscdevice, list);\n\n\tseq_printf(seq, \"%3i %s\\n\", p->minor, p->name ? p->name : \"\");\n\treturn 0;\n}\n\n\nstatic const struct seq_operations misc_seq_ops = {\n\t.start = misc_seq_start,\n\t.next  = misc_seq_next,\n\t.stop  = misc_seq_stop,\n\t.show  = misc_seq_show,\n};\n#endif\n\nstatic int misc_open(struct inode *inode, struct file *file)\n{\n\tint minor = iminor(inode);\n\tstruct miscdevice *c = NULL, *iter;\n\tint err = -ENODEV;\n\tconst struct file_operations *new_fops = NULL;\n\n\tmutex_lock(&misc_mtx);\n\n\tlist_for_each_entry(iter, &misc_list, list) {\n\t\tif (iter->minor != minor)\n\t\t\tcontinue;\n\t\tc = iter;\n\t\tnew_fops = fops_get(iter->fops);\n\t\tbreak;\n\t}\n\n\tif (!new_fops) {\n\t\tmutex_unlock(&misc_mtx);\n\t\trequest_module(\"char-major-%d-%d\", MISC_MAJOR, minor);\n\t\tmutex_lock(&misc_mtx);\n\n\t\tlist_for_each_entry(iter, &misc_list, list) {\n\t\t\tif (iter->minor != minor)\n\t\t\t\tcontinue;\n\t\t\tc = iter;\n\t\t\tnew_fops = fops_get(iter->fops);\n\t\t\tbreak;\n\t\t}\n\t\tif (!new_fops)\n\t\t\tgoto fail;\n\t}\n\n\t \n\tfile->private_data = c;\n\n\terr = 0;\n\treplace_fops(file, new_fops);\n\tif (file->f_op->open)\n\t\terr = file->f_op->open(inode, file);\nfail:\n\tmutex_unlock(&misc_mtx);\n\treturn err;\n}\n\nstatic char *misc_devnode(const struct device *dev, umode_t *mode)\n{\n\tconst struct miscdevice *c = dev_get_drvdata(dev);\n\n\tif (mode && c->mode)\n\t\t*mode = c->mode;\n\tif (c->nodename)\n\t\treturn kstrdup(c->nodename, GFP_KERNEL);\n\treturn NULL;\n}\n\nstatic const struct class misc_class = {\n\t.name\t\t= \"misc\",\n\t.devnode\t= misc_devnode,\n};\n\nstatic const struct file_operations misc_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= misc_open,\n\t.llseek\t\t= noop_llseek,\n};\n\n \n\nint misc_register(struct miscdevice *misc)\n{\n\tdev_t dev;\n\tint err = 0;\n\tbool is_dynamic = (misc->minor == MISC_DYNAMIC_MINOR);\n\n\tINIT_LIST_HEAD(&misc->list);\n\n\tmutex_lock(&misc_mtx);\n\n\tif (is_dynamic) {\n\t\tint i = misc_minor_alloc();\n\n\t\tif (i < 0) {\n\t\t\terr = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t\tmisc->minor = i;\n\t} else {\n\t\tstruct miscdevice *c;\n\n\t\tlist_for_each_entry(c, &misc_list, list) {\n\t\t\tif (c->minor == misc->minor) {\n\t\t\t\terr = -EBUSY;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tdev = MKDEV(MISC_MAJOR, misc->minor);\n\n\tmisc->this_device =\n\t\tdevice_create_with_groups(&misc_class, misc->parent, dev,\n\t\t\t\t\t  misc, misc->groups, \"%s\", misc->name);\n\tif (IS_ERR(misc->this_device)) {\n\t\tif (is_dynamic) {\n\t\t\tmisc_minor_free(misc->minor);\n\t\t\tmisc->minor = MISC_DYNAMIC_MINOR;\n\t\t}\n\t\terr = PTR_ERR(misc->this_device);\n\t\tgoto out;\n\t}\n\n\t \n\tlist_add(&misc->list, &misc_list);\n out:\n\tmutex_unlock(&misc_mtx);\n\treturn err;\n}\nEXPORT_SYMBOL(misc_register);\n\n \n\nvoid misc_deregister(struct miscdevice *misc)\n{\n\tif (WARN_ON(list_empty(&misc->list)))\n\t\treturn;\n\n\tmutex_lock(&misc_mtx);\n\tlist_del(&misc->list);\n\tdevice_destroy(&misc_class, MKDEV(MISC_MAJOR, misc->minor));\n\tmisc_minor_free(misc->minor);\n\tmutex_unlock(&misc_mtx);\n}\nEXPORT_SYMBOL(misc_deregister);\n\nstatic int __init misc_init(void)\n{\n\tint err;\n\tstruct proc_dir_entry *ret;\n\n\tret = proc_create_seq(\"misc\", 0, NULL, &misc_seq_ops);\n\terr = class_register(&misc_class);\n\tif (err)\n\t\tgoto fail_remove;\n\n\terr = -EIO;\n\tif (register_chrdev(MISC_MAJOR, \"misc\", &misc_fops))\n\t\tgoto fail_printk;\n\treturn 0;\n\nfail_printk:\n\tpr_err(\"unable to get major %d for misc devices\\n\", MISC_MAJOR);\n\tclass_unregister(&misc_class);\nfail_remove:\n\tif (ret)\n\t\tremove_proc_entry(\"misc\", NULL);\n\treturn err;\n}\nsubsys_initcall(misc_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}