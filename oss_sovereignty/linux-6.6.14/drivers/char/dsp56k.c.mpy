{
  "module_name": "dsp56k.c",
  "hash_id": "4b1da215030eaf385bb491c82bd31bf1a7ced256f6d510a1c8e4d69a0d5ad338",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/dsp56k.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/major.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\t \n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/mutex.h>\n#include <linux/firmware.h>\n#include <linux/platform_device.h>\n#include <linux/uaccess.h>\t \n\n#include <asm/atarihw.h>\n#include <asm/traps.h>\n\n#include <asm/dsp56k.h>\n\n \n#define DSP56K_DEV_56001        0     \n\n#define TIMEOUT    10    \n#define MAXIO    2048    \n#define DSP56K_MAX_BINARY_LENGTH (3*64*1024)\n\n#define DSP56K_TX_INT_ON\tdsp56k_host_interface.icr |=  DSP56K_ICR_TREQ\n#define DSP56K_RX_INT_ON\tdsp56k_host_interface.icr |=  DSP56K_ICR_RREQ\n#define DSP56K_TX_INT_OFF\tdsp56k_host_interface.icr &= ~DSP56K_ICR_TREQ\n#define DSP56K_RX_INT_OFF\tdsp56k_host_interface.icr &= ~DSP56K_ICR_RREQ\n\n#define DSP56K_TRANSMIT\t\t(dsp56k_host_interface.isr & DSP56K_ISR_TXDE)\n#define DSP56K_RECEIVE\t\t(dsp56k_host_interface.isr & DSP56K_ISR_RXDF)\n\n#define handshake(count, maxio, timeout, ENABLE, f) \\\n{ \\\n\tlong i, t, m; \\\n\twhile (count > 0) { \\\n\t\tm = min_t(unsigned long, count, maxio); \\\n\t\tfor (i = 0; i < m; i++) { \\\n\t\t\tfor (t = 0; t < timeout && !ENABLE; t++) \\\n\t\t\t\tmsleep(20); \\\n\t\t\tif(!ENABLE) \\\n\t\t\t\treturn -EIO; \\\n\t\t\tf; \\\n\t\t} \\\n\t\tcount -= m; \\\n\t\tif (m == maxio) msleep(20); \\\n\t} \\\n}\n\n#define tx_wait(n) \\\n{ \\\n\tint t; \\\n\tfor(t = 0; t < n && !DSP56K_TRANSMIT; t++) \\\n\t\tmsleep(10); \\\n\tif(!DSP56K_TRANSMIT) { \\\n\t\treturn -EIO; \\\n\t} \\\n}\n\n#define rx_wait(n) \\\n{ \\\n\tint t; \\\n\tfor(t = 0; t < n && !DSP56K_RECEIVE; t++) \\\n\t\tmsleep(10); \\\n\tif(!DSP56K_RECEIVE) { \\\n\t\treturn -EIO; \\\n\t} \\\n}\n\nstatic DEFINE_MUTEX(dsp56k_mutex);\nstatic struct dsp56k_device {\n\tunsigned long in_use;\n\tlong maxio, timeout;\n\tint tx_wsize, rx_wsize;\n} dsp56k;\n\nstatic const struct class dsp56k_class = {\n\t.name = \"dsp56k\",\n};\n\nstatic int dsp56k_reset(void)\n{\n\tu_char status;\n\t\n\t \n\tsound_ym.rd_data_reg_sel = 14;\n\tstatus = sound_ym.rd_data_reg_sel & 0xef;\n\tsound_ym.wd_data = status;\n\tsound_ym.wd_data = status | 0x10;\n  \n\tudelay(10);\n  \n\t \n\tsound_ym.rd_data_reg_sel = 14;\n\tsound_ym.wd_data = sound_ym.rd_data_reg_sel & 0xef;\n\n\treturn 0;\n}\n\nstatic int dsp56k_upload(u_char __user *bin, int len)\n{\n\tstruct platform_device *pdev;\n\tconst struct firmware *fw;\n\tconst char fw_name[] = \"dsp56k/bootstrap.bin\";\n\tint err;\n\tint i;\n\n\tdsp56k_reset();\n\n\tpdev = platform_device_register_simple(\"dsp56k\", 0, NULL, 0);\n\tif (IS_ERR(pdev)) {\n\t\tprintk(KERN_ERR \"Failed to register device for \\\"%s\\\"\\n\",\n\t\t       fw_name);\n\t\treturn -EINVAL;\n\t}\n\terr = request_firmware(&fw, fw_name, &pdev->dev);\n\tplatform_device_unregister(pdev);\n\tif (err) {\n\t\tprintk(KERN_ERR \"Failed to load image \\\"%s\\\" err %d\\n\",\n\t\t       fw_name, err);\n\t\treturn err;\n\t}\n\tif (fw->size % 3) {\n\t\tprintk(KERN_ERR \"Bogus length %d in image \\\"%s\\\"\\n\",\n\t\t       fw->size, fw_name);\n\t\trelease_firmware(fw);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < fw->size; i = i + 3) {\n\t\t \n\t\tdsp56k_host_interface.data.b[1] = fw->data[i];\n\t\tdsp56k_host_interface.data.b[2] = fw->data[i + 1];\n\t\tdsp56k_host_interface.data.b[3] = fw->data[i + 2];\n\t}\n\trelease_firmware(fw);\n\tfor (; i < 512; i++) {\n\t\t \n\t\tdsp56k_host_interface.data.b[1] = 0;\n\t\tdsp56k_host_interface.data.b[2] = 0;\n\t\tdsp56k_host_interface.data.b[3] = 0;\n\t}\n  \n\tfor (i = 0; i < len; i++) {\n\t\ttx_wait(10);\n\t\tget_user(dsp56k_host_interface.data.b[1], bin++);\n\t\tget_user(dsp56k_host_interface.data.b[2], bin++);\n\t\tget_user(dsp56k_host_interface.data.b[3], bin++);\n\t}\n\n\ttx_wait(10);\n\tdsp56k_host_interface.data.l = 3;     \n\n\treturn 0;\n}\n\nstatic ssize_t dsp56k_read(struct file *file, char __user *buf, size_t count,\n\t\t\t   loff_t *ppos)\n{\n\tstruct inode *inode = file_inode(file);\n\tint dev = iminor(inode) & 0x0f;\n\n\tswitch(dev)\n\t{\n\tcase DSP56K_DEV_56001:\n\t{\n\n\t\tlong n;\n\n\t\t \n\t\tif (!count) return 0;\n\n\t\tn = 0;\n\t\tswitch (dsp56k.rx_wsize) {\n\t\tcase 1:   \n\t\t{\n\t\t\thandshake(count, dsp56k.maxio, dsp56k.timeout, DSP56K_RECEIVE,\n\t\t\t\t  put_user(dsp56k_host_interface.data.b[3], buf+n++));\n\t\t\treturn n;\n\t\t}\n\t\tcase 2:   \n\t\t{\n\t\t\tshort __user *data;\n\n\t\t\tcount /= 2;\n\t\t\tdata = (short __user *) buf;\n\t\t\thandshake(count, dsp56k.maxio, dsp56k.timeout, DSP56K_RECEIVE,\n\t\t\t\t  put_user(dsp56k_host_interface.data.w[1], data+n++));\n\t\t\treturn 2*n;\n\t\t}\n\t\tcase 3:   \n\t\t{\n\t\t\tcount /= 3;\n\t\t\thandshake(count, dsp56k.maxio, dsp56k.timeout, DSP56K_RECEIVE,\n\t\t\t\t  put_user(dsp56k_host_interface.data.b[1], buf+n++);\n\t\t\t\t  put_user(dsp56k_host_interface.data.b[2], buf+n++);\n\t\t\t\t  put_user(dsp56k_host_interface.data.b[3], buf+n++));\n\t\t\treturn 3*n;\n\t\t}\n\t\tcase 4:   \n\t\t{\n\t\t\tlong __user *data;\n\n\t\t\tcount /= 4;\n\t\t\tdata = (long __user *) buf;\n\t\t\thandshake(count, dsp56k.maxio, dsp56k.timeout, DSP56K_RECEIVE,\n\t\t\t\t  put_user(dsp56k_host_interface.data.l, data+n++));\n\t\t\treturn 4*n;\n\t\t}\n\t\t}\n\t\treturn -EFAULT;\n\t}\n\n\tdefault:\n\t\tprintk(KERN_ERR \"DSP56k driver: Unknown minor device: %d\\n\", dev);\n\t\treturn -ENXIO;\n\t}\n}\n\nstatic ssize_t dsp56k_write(struct file *file, const char __user *buf, size_t count,\n\t\t\t    loff_t *ppos)\n{\n\tstruct inode *inode = file_inode(file);\n\tint dev = iminor(inode) & 0x0f;\n\n\tswitch(dev)\n\t{\n\tcase DSP56K_DEV_56001:\n\t{\n\t\tlong n;\n\n\t\t \n\t\tif (!count) return 0;\n\n\t\tn = 0;\n\t\tswitch (dsp56k.tx_wsize) {\n\t\tcase 1:   \n\t\t{\n\t\t\thandshake(count, dsp56k.maxio, dsp56k.timeout, DSP56K_TRANSMIT,\n\t\t\t\t  get_user(dsp56k_host_interface.data.b[3], buf+n++));\n\t\t\treturn n;\n\t\t}\n\t\tcase 2:   \n\t\t{\n\t\t\tconst short __user *data;\n\n\t\t\tcount /= 2;\n\t\t\tdata = (const short __user *)buf;\n\t\t\thandshake(count, dsp56k.maxio, dsp56k.timeout, DSP56K_TRANSMIT,\n\t\t\t\t  get_user(dsp56k_host_interface.data.w[1], data+n++));\n\t\t\treturn 2*n;\n\t\t}\n\t\tcase 3:   \n\t\t{\n\t\t\tcount /= 3;\n\t\t\thandshake(count, dsp56k.maxio, dsp56k.timeout, DSP56K_TRANSMIT,\n\t\t\t\t  get_user(dsp56k_host_interface.data.b[1], buf+n++);\n\t\t\t\t  get_user(dsp56k_host_interface.data.b[2], buf+n++);\n\t\t\t\t  get_user(dsp56k_host_interface.data.b[3], buf+n++));\n\t\t\treturn 3*n;\n\t\t}\n\t\tcase 4:   \n\t\t{\n\t\t\tconst long __user *data;\n\n\t\t\tcount /= 4;\n\t\t\tdata = (const long __user *)buf;\n\t\t\thandshake(count, dsp56k.maxio, dsp56k.timeout, DSP56K_TRANSMIT,\n\t\t\t\t  get_user(dsp56k_host_interface.data.l, data+n++));\n\t\t\treturn 4*n;\n\t\t}\n\t\t}\n\n\t\treturn -EFAULT;\n\t}\n\tdefault:\n\t\tprintk(KERN_ERR \"DSP56k driver: Unknown minor device: %d\\n\", dev);\n\t\treturn -ENXIO;\n\t}\n}\n\nstatic long dsp56k_ioctl(struct file *file, unsigned int cmd,\n\t\t\t unsigned long arg)\n{\n\tint dev = iminor(file_inode(file)) & 0x0f;\n\tvoid __user *argp = (void __user *)arg;\n\n\tswitch(dev)\n\t{\n\tcase DSP56K_DEV_56001:\n\n\t\tswitch(cmd) {\n\t\tcase DSP56K_UPLOAD:\n\t\t{\n\t\t\tchar __user *bin;\n\t\t\tint r, len;\n\t\t\tstruct dsp56k_upload __user *binary = argp;\n    \n\t\t\tif(get_user(len, &binary->len) < 0)\n\t\t\t\treturn -EFAULT;\n\t\t\tif(get_user(bin, &binary->bin) < 0)\n\t\t\t\treturn -EFAULT;\n\t\t\n\t\t\tif (len <= 0) {\n\t\t\t\treturn -EINVAL;       \n\t\t\t}\n\t\t\tif (len > DSP56K_MAX_BINARY_LENGTH) {\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tmutex_lock(&dsp56k_mutex);\n\t\t\tr = dsp56k_upload(bin, len);\n\t\t\tmutex_unlock(&dsp56k_mutex);\n\t\t\tif (r < 0) {\n\t\t\t\treturn r;\n\t\t\t}\n    \n\t\t\tbreak;\n\t\t}\n\t\tcase DSP56K_SET_TX_WSIZE:\n\t\t\tif (arg > 4 || arg < 1)\n\t\t\t\treturn -EINVAL;\n\t\t\tmutex_lock(&dsp56k_mutex);\n\t\t\tdsp56k.tx_wsize = (int) arg;\n\t\t\tmutex_unlock(&dsp56k_mutex);\n\t\t\tbreak;\n\t\tcase DSP56K_SET_RX_WSIZE:\n\t\t\tif (arg > 4 || arg < 1)\n\t\t\t\treturn -EINVAL;\n\t\t\tmutex_lock(&dsp56k_mutex);\n\t\t\tdsp56k.rx_wsize = (int) arg;\n\t\t\tmutex_unlock(&dsp56k_mutex);\n\t\t\tbreak;\n\t\tcase DSP56K_HOST_FLAGS:\n\t\t{\n\t\t\tint dir, out, status;\n\t\t\tstruct dsp56k_host_flags __user *hf = argp;\n    \n\t\t\tif(get_user(dir, &hf->dir) < 0)\n\t\t\t\treturn -EFAULT;\n\t\t\tif(get_user(out, &hf->out) < 0)\n\t\t\t\treturn -EFAULT;\n\n\t\t\tmutex_lock(&dsp56k_mutex);\n\t\t\tif ((dir & 0x1) && (out & 0x1))\n\t\t\t\tdsp56k_host_interface.icr |= DSP56K_ICR_HF0;\n\t\t\telse if (dir & 0x1)\n\t\t\t\tdsp56k_host_interface.icr &= ~DSP56K_ICR_HF0;\n\t\t\tif ((dir & 0x2) && (out & 0x2))\n\t\t\t\tdsp56k_host_interface.icr |= DSP56K_ICR_HF1;\n\t\t\telse if (dir & 0x2)\n\t\t\t\tdsp56k_host_interface.icr &= ~DSP56K_ICR_HF1;\n\n\t\t\tstatus = 0;\n\t\t\tif (dsp56k_host_interface.icr & DSP56K_ICR_HF0) status |= 0x1;\n\t\t\tif (dsp56k_host_interface.icr & DSP56K_ICR_HF1) status |= 0x2;\n\t\t\tif (dsp56k_host_interface.isr & DSP56K_ISR_HF2) status |= 0x4;\n\t\t\tif (dsp56k_host_interface.isr & DSP56K_ISR_HF3) status |= 0x8;\n\t\t\tmutex_unlock(&dsp56k_mutex);\n\t\t\treturn put_user(status, &hf->status);\n\t\t}\n\t\tcase DSP56K_HOST_CMD:\n\t\t\tif (arg > 31)\n\t\t\t\treturn -EINVAL;\n\t\t\tmutex_lock(&dsp56k_mutex);\n\t\t\tdsp56k_host_interface.cvr = (u_char)((arg & DSP56K_CVR_HV_MASK) |\n\t\t\t\t\t\t\t     DSP56K_CVR_HC);\n\t\t\tmutex_unlock(&dsp56k_mutex);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\n\tdefault:\n\t\tprintk(KERN_ERR \"DSP56k driver: Unknown minor device: %d\\n\", dev);\n\t\treturn -ENXIO;\n\t}\n}\n\n \n#if 0\nstatic __poll_t dsp56k_poll(struct file *file, poll_table *wait)\n{\n\tint dev = iminor(file_inode(file)) & 0x0f;\n\n\tswitch(dev)\n\t{\n\tcase DSP56K_DEV_56001:\n\t\t \n\t\treturn EPOLLIN | EPOLLRDNORM | EPOLLOUT;\n\n\tdefault:\n\t\tprintk(\"DSP56k driver: Unknown minor device: %d\\n\", dev);\n\t\treturn 0;\n\t}\n}\n#endif\n\nstatic int dsp56k_open(struct inode *inode, struct file *file)\n{\n\tint dev = iminor(inode) & 0x0f;\n\tint ret = 0;\n\n\tmutex_lock(&dsp56k_mutex);\n\tswitch(dev)\n\t{\n\tcase DSP56K_DEV_56001:\n\n\t\tif (test_and_set_bit(0, &dsp56k.in_use)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\n\t\tdsp56k.timeout = TIMEOUT;\n\t\tdsp56k.maxio = MAXIO;\n\t\tdsp56k.rx_wsize = dsp56k.tx_wsize = 4; \n\n\t\tDSP56K_TX_INT_OFF;\n\t\tDSP56K_RX_INT_OFF;\n\n\t\t \n\t\tdsp56k_host_interface.icr &= ~DSP56K_ICR_HF0;\n\t\tdsp56k_host_interface.icr &= ~DSP56K_ICR_HF1;\n\n\t\tbreak;\n\n\tdefault:\n\t\tret = -ENODEV;\n\t}\nout:\n\tmutex_unlock(&dsp56k_mutex);\n\treturn ret;\n}\n\nstatic int dsp56k_release(struct inode *inode, struct file *file)\n{\n\tint dev = iminor(inode) & 0x0f;\n\n\tswitch(dev)\n\t{\n\tcase DSP56K_DEV_56001:\n\t\tclear_bit(0, &dsp56k.in_use);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"DSP56k driver: Unknown minor device: %d\\n\", dev);\n\t\treturn -ENXIO;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct file_operations dsp56k_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.read\t\t= dsp56k_read,\n\t.write\t\t= dsp56k_write,\n\t.unlocked_ioctl\t= dsp56k_ioctl,\n\t.open\t\t= dsp56k_open,\n\t.release\t= dsp56k_release,\n\t.llseek\t\t= noop_llseek,\n};\n\n\n \n\nstatic const char banner[] __initconst = KERN_INFO \"DSP56k driver installed\\n\";\n\nstatic int __init dsp56k_init_driver(void)\n{\n\tint err;\n\n\tif(!MACH_IS_ATARI || !ATARIHW_PRESENT(DSP56K)) {\n\t\tprintk(\"DSP56k driver: Hardware not present\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif(register_chrdev(DSP56K_MAJOR, \"dsp56k\", &dsp56k_fops)) {\n\t\tprintk(\"DSP56k driver: Unable to register driver\\n\");\n\t\treturn -ENODEV;\n\t}\n\terr = class_register(&dsp56k_class);\n\tif (err)\n\t\tgoto out_chrdev;\n\tdevice_create(&dsp56k_class, NULL, MKDEV(DSP56K_MAJOR, 0), NULL,\n\t\t      \"dsp56k\");\n\n\tprintk(banner);\n\tgoto out;\n\nout_chrdev:\n\tunregister_chrdev(DSP56K_MAJOR, \"dsp56k\");\nout:\n\treturn err;\n}\nmodule_init(dsp56k_init_driver);\n\nstatic void __exit dsp56k_cleanup_driver(void)\n{\n\tdevice_destroy(&dsp56k_class, MKDEV(DSP56K_MAJOR, 0));\n\tclass_unregister(&dsp56k_class);\n\tunregister_chrdev(DSP56K_MAJOR, \"dsp56k\");\n}\nmodule_exit(dsp56k_cleanup_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(\"dsp56k/bootstrap.bin\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}