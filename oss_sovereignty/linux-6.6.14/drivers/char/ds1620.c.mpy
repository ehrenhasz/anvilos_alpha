{
  "module_name": "ds1620.c",
  "hash_id": "c35a906b3fa243bc09d832ff7bf1dab90257d17c17b1c2b0551410223e924032",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/ds1620.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/miscdevice.h>\n#include <linux/delay.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n\n#include <mach/hardware.h>\n#include <asm/mach-types.h>\n#include <linux/uaccess.h>\n#include <asm/therm.h>\n\n#ifdef CONFIG_PROC_FS\n \n#define THERM_USE_PROC\n#endif\n\n \n#define THERM_START_CONVERT\t0xee\n#define THERM_RESET\t\t0xaf\n#define THERM_READ_CONFIG\t0xac\n#define THERM_READ_TEMP\t\t0xaa\n#define THERM_READ_TL\t\t0xa2\n#define THERM_READ_TH\t\t0xa1\n#define THERM_WRITE_CONFIG\t0x0c\n#define THERM_WRITE_TL\t\t0x02\n#define THERM_WRITE_TH\t\t0x01\n\n#define CFG_CPU\t\t\t2\n#define CFG_1SHOT\t\t1\n\nstatic DEFINE_MUTEX(ds1620_mutex);\nstatic const char *fan_state[] = { \"off\", \"on\", \"on (hardwired)\" };\n\n \nextern unsigned int system_rev;\n\nstatic inline void netwinder_ds1620_set_clk(int clk)\n{\n\tnw_gpio_modify_op(GPIO_DSCLK, clk ? GPIO_DSCLK : 0);\n}\n\nstatic inline void netwinder_ds1620_set_data(int dat)\n{\n\tnw_gpio_modify_op(GPIO_DATA, dat ? GPIO_DATA : 0);\n}\n\nstatic inline int netwinder_ds1620_get_data(void)\n{\n\treturn nw_gpio_read() & GPIO_DATA;\n}\n\nstatic inline void netwinder_ds1620_set_data_dir(int dir)\n{\n\tnw_gpio_modify_io(GPIO_DATA, dir ? GPIO_DATA : 0);\n}\n\nstatic inline void netwinder_ds1620_reset(void)\n{\n\tnw_cpld_modify(CPLD_DS_ENABLE, 0);\n\tnw_cpld_modify(CPLD_DS_ENABLE, CPLD_DS_ENABLE);\n}\n\nstatic inline void netwinder_lock(unsigned long *flags)\n{\n\traw_spin_lock_irqsave(&nw_gpio_lock, *flags);\n}\n\nstatic inline void netwinder_unlock(unsigned long *flags)\n{\n\traw_spin_unlock_irqrestore(&nw_gpio_lock, *flags);\n}\n\nstatic inline void netwinder_set_fan(int i)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&nw_gpio_lock, flags);\n\tnw_gpio_modify_op(GPIO_FAN, i ? GPIO_FAN : 0);\n\traw_spin_unlock_irqrestore(&nw_gpio_lock, flags);\n}\n\nstatic inline int netwinder_get_fan(void)\n{\n\tif ((system_rev & 0xf000) == 0x4000)\n\t\treturn FAN_ALWAYS_ON;\n\n\treturn (nw_gpio_read() & GPIO_FAN) ? FAN_ON : FAN_OFF;\n}\n\n \n\nstatic void ds1620_send_bits(int nr, int value)\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tnetwinder_ds1620_set_data(value & 1);\n\t\tnetwinder_ds1620_set_clk(0);\n\t\tudelay(1);\n\t\tnetwinder_ds1620_set_clk(1);\n\t\tudelay(1);\n\n\t\tvalue >>= 1;\n\t}\n}\n\nstatic unsigned int ds1620_recv_bits(int nr)\n{\n\tunsigned int value = 0, mask = 1;\n\tint i;\n\n\tnetwinder_ds1620_set_data(0);\n\n\tfor (i = 0; i < nr; i++) {\n\t\tnetwinder_ds1620_set_clk(0);\n\t\tudelay(1);\n\n\t\tif (netwinder_ds1620_get_data())\n\t\t\tvalue |= mask;\n\n\t\tmask <<= 1;\n\n\t\tnetwinder_ds1620_set_clk(1);\n\t\tudelay(1);\n\t}\n\n\treturn value;\n}\n\nstatic void ds1620_out(int cmd, int bits, int value)\n{\n\tunsigned long flags;\n\n\tnetwinder_lock(&flags);\n\tnetwinder_ds1620_set_clk(1);\n\tnetwinder_ds1620_set_data_dir(0);\n\tnetwinder_ds1620_reset();\n\n\tudelay(1);\n\n\tds1620_send_bits(8, cmd);\n\tif (bits)\n\t\tds1620_send_bits(bits, value);\n\n\tudelay(1);\n\n\tnetwinder_ds1620_reset();\n\tnetwinder_unlock(&flags);\n\n\tmsleep(20);\n}\n\nstatic unsigned int ds1620_in(int cmd, int bits)\n{\n\tunsigned long flags;\n\tunsigned int value;\n\n\tnetwinder_lock(&flags);\n\tnetwinder_ds1620_set_clk(1);\n\tnetwinder_ds1620_set_data_dir(0);\n\tnetwinder_ds1620_reset();\n\n\tudelay(1);\n\n\tds1620_send_bits(8, cmd);\n\n\tnetwinder_ds1620_set_data_dir(1);\n\tvalue = ds1620_recv_bits(bits);\n\n\tnetwinder_ds1620_reset();\n\tnetwinder_unlock(&flags);\n\n\treturn value;\n}\n\nstatic int cvt_9_to_int(unsigned int val)\n{\n\tif (val & 0x100)\n\t\tval |= 0xfffffe00;\n\n\treturn val;\n}\n\nstatic void ds1620_write_state(struct therm *therm)\n{\n\tds1620_out(THERM_WRITE_CONFIG, 8, CFG_CPU);\n\tds1620_out(THERM_WRITE_TL, 9, therm->lo);\n\tds1620_out(THERM_WRITE_TH, 9, therm->hi);\n\tds1620_out(THERM_START_CONVERT, 0, 0);\n}\n\nstatic void ds1620_read_state(struct therm *therm)\n{\n\ttherm->lo = cvt_9_to_int(ds1620_in(THERM_READ_TL, 9));\n\ttherm->hi = cvt_9_to_int(ds1620_in(THERM_READ_TH, 9));\n}\n\nstatic int ds1620_open(struct inode *inode, struct file *file)\n{\n\treturn stream_open(inode, file);\n}\n\nstatic ssize_t\nds1620_read(struct file *file, char __user *buf, size_t count, loff_t *ptr)\n{\n\tsigned int cur_temp;\n\tsigned char cur_temp_degF;\n\n\tcur_temp = cvt_9_to_int(ds1620_in(THERM_READ_TEMP, 9)) >> 1;\n\n\t \n\tcur_temp_degF = (cur_temp * 9) / 5 + 32;\n\n\tif (copy_to_user(buf, &cur_temp_degF, 1))\n\t\treturn -EFAULT;\n\n\treturn 1;\n}\n\nstatic int\nds1620_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct therm therm;\n\tunion {\n\t\tstruct therm __user *therm;\n\t\tint __user *i;\n\t} uarg;\n\tint i;\n\n\tuarg.i = (int __user *)arg;\n\n\tswitch(cmd) {\n\tcase CMD_SET_THERMOSTATE:\n\tcase CMD_SET_THERMOSTATE2:\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (cmd == CMD_SET_THERMOSTATE) {\n\t\t\tif (get_user(therm.hi, uarg.i))\n\t\t\t\treturn -EFAULT;\n\t\t\ttherm.lo = therm.hi - 3;\n\t\t} else {\n\t\t\tif (copy_from_user(&therm, uarg.therm, sizeof(therm)))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\n\t\ttherm.lo <<= 1;\n\t\ttherm.hi <<= 1;\n\n\t\tds1620_write_state(&therm);\n\t\tbreak;\n\n\tcase CMD_GET_THERMOSTATE:\n\tcase CMD_GET_THERMOSTATE2:\n\t\tds1620_read_state(&therm);\n\n\t\ttherm.lo >>= 1;\n\t\ttherm.hi >>= 1;\n\n\t\tif (cmd == CMD_GET_THERMOSTATE) {\n\t\t\tif (put_user(therm.hi, uarg.i))\n\t\t\t\treturn -EFAULT;\n\t\t} else {\n\t\t\tif (copy_to_user(uarg.therm, &therm, sizeof(therm)))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t\tbreak;\n\n\tcase CMD_GET_TEMPERATURE:\n\tcase CMD_GET_TEMPERATURE2:\n\t\ti = cvt_9_to_int(ds1620_in(THERM_READ_TEMP, 9));\n\n\t\tif (cmd == CMD_GET_TEMPERATURE)\n\t\t\ti >>= 1;\n\n\t\treturn put_user(i, uarg.i) ? -EFAULT : 0;\n\n\tcase CMD_GET_STATUS:\n\t\ti = ds1620_in(THERM_READ_CONFIG, 8) & 0xe3;\n\n\t\treturn put_user(i, uarg.i) ? -EFAULT : 0;\n\n\tcase CMD_GET_FAN:\n\t\ti = netwinder_get_fan();\n\n\t\treturn put_user(i, uarg.i) ? -EFAULT : 0;\n\n\tcase CMD_SET_FAN:\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (get_user(i, uarg.i))\n\t\t\treturn -EFAULT;\n\n\t\tnetwinder_set_fan(i);\n\t\tbreak;\n\t\t\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\n\treturn 0;\n}\n\nstatic long\nds1620_unlocked_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tint ret;\n\n\tmutex_lock(&ds1620_mutex);\n\tret = ds1620_ioctl(file, cmd, arg);\n\tmutex_unlock(&ds1620_mutex);\n\n\treturn ret;\n}\n\n#ifdef THERM_USE_PROC\nstatic int ds1620_proc_therm_show(struct seq_file *m, void *v)\n{\n\tstruct therm th;\n\tint temp;\n\n\tds1620_read_state(&th);\n\ttemp =  cvt_9_to_int(ds1620_in(THERM_READ_TEMP, 9));\n\n\tseq_printf(m, \"Thermostat: HI %i.%i, LOW %i.%i; temperature: %i.%i C, fan %s\\n\",\n\t\t   th.hi >> 1, th.hi & 1 ? 5 : 0,\n\t\t   th.lo >> 1, th.lo & 1 ? 5 : 0,\n\t\t   temp  >> 1, temp  & 1 ? 5 : 0,\n\t\t   fan_state[netwinder_get_fan()]);\n\treturn 0;\n}\n#endif\n\nstatic const struct file_operations ds1620_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= ds1620_open,\n\t.read\t\t= ds1620_read,\n\t.unlocked_ioctl\t= ds1620_unlocked_ioctl,\n\t.llseek\t\t= no_llseek,\n};\n\nstatic struct miscdevice ds1620_miscdev = {\n\tTEMP_MINOR,\n\t\"temp\",\n\t&ds1620_fops\n};\n\nstatic int __init ds1620_init(void)\n{\n\tint ret;\n\tstruct therm th, th_start;\n\n\tif (!machine_is_netwinder())\n\t\treturn -ENODEV;\n\n\tds1620_out(THERM_RESET, 0, 0);\n\tds1620_out(THERM_WRITE_CONFIG, 8, CFG_CPU);\n\tds1620_out(THERM_START_CONVERT, 0, 0);\n\n\t \n\tds1620_read_state(&th);\n\tth_start.lo = 0;\n\tth_start.hi = 1;\n\tds1620_write_state(&th_start);\n\n\tmsleep(2000);\n\n\tds1620_write_state(&th);\n\n\tret = misc_register(&ds1620_miscdev);\n\tif (ret < 0)\n\t\treturn ret;\n\n#ifdef THERM_USE_PROC\n\tif (!proc_create_single(\"therm\", 0, NULL, ds1620_proc_therm_show))\n\t\tprintk(KERN_ERR \"therm: unable to register /proc/therm\\n\");\n#endif\n\n\tds1620_read_state(&th);\n\tret = cvt_9_to_int(ds1620_in(THERM_READ_TEMP, 9));\n\n\tprintk(KERN_INFO \"Thermostat: high %i.%i, low %i.%i, \"\n\t       \"current %i.%i C, fan %s.\\n\",\n\t       th.hi >> 1, th.hi & 1 ? 5 : 0,\n\t       th.lo >> 1, th.lo & 1 ? 5 : 0,\n\t       ret   >> 1, ret   & 1 ? 5 : 0,\n\t       fan_state[netwinder_get_fan()]);\n\n\treturn 0;\n}\n\nstatic void __exit ds1620_exit(void)\n{\n#ifdef THERM_USE_PROC\n\tremove_proc_entry(\"therm\", NULL);\n#endif\n\tmisc_deregister(&ds1620_miscdev);\n}\n\nmodule_init(ds1620_init);\nmodule_exit(ds1620_exit);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}