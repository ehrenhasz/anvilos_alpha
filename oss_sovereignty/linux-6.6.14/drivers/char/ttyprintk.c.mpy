{
  "module_name": "ttyprintk.c",
  "hash_id": "211cf59c35e90b76428af449b82b790f66358eb5e77af53e8bb9672ea087e180",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/ttyprintk.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/console.h>\n#include <linux/device.h>\n#include <linux/serial.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n\nstruct ttyprintk_port {\n\tstruct tty_port port;\n\tspinlock_t spinlock;\n};\n\nstatic struct ttyprintk_port tpk_port;\n\n \n#define TPK_STR_SIZE 508  \n#define TPK_MAX_ROOM 4096  \n#define TPK_PREFIX KERN_SOH __stringify(CONFIG_TTY_PRINTK_LEVEL)\n\nstatic int tpk_curr;\n\nstatic char tpk_buffer[TPK_STR_SIZE + 4];\n\nstatic void tpk_flush(void)\n{\n\tif (tpk_curr > 0) {\n\t\ttpk_buffer[tpk_curr] = '\\0';\n\t\tprintk(TPK_PREFIX \"[U] %s\\n\", tpk_buffer);\n\t\ttpk_curr = 0;\n\t}\n}\n\nstatic int tpk_printk(const u8 *buf, int count)\n{\n\tint i;\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (tpk_curr >= TPK_STR_SIZE) {\n\t\t\t \n\t\t\ttpk_buffer[tpk_curr++] = '\\\\';\n\t\t\ttpk_flush();\n\t\t}\n\n\t\tswitch (buf[i]) {\n\t\tcase '\\r':\n\t\t\ttpk_flush();\n\t\t\tif ((i + 1) < count && buf[i + 1] == '\\n')\n\t\t\t\ti++;\n\t\t\tbreak;\n\t\tcase '\\n':\n\t\t\ttpk_flush();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttpk_buffer[tpk_curr++] = buf[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn count;\n}\n\n \nstatic int tpk_open(struct tty_struct *tty, struct file *filp)\n{\n\ttty->driver_data = &tpk_port;\n\n\treturn tty_port_open(&tpk_port.port, tty, filp);\n}\n\n \nstatic void tpk_close(struct tty_struct *tty, struct file *filp)\n{\n\tstruct ttyprintk_port *tpkp = tty->driver_data;\n\n\ttty_port_close(&tpkp->port, tty, filp);\n}\n\n \nstatic ssize_t tpk_write(struct tty_struct *tty, const u8 *buf, size_t count)\n{\n\tstruct ttyprintk_port *tpkp = tty->driver_data;\n\tunsigned long flags;\n\tint ret;\n\n\t \n\tspin_lock_irqsave(&tpkp->spinlock, flags);\n\tret = tpk_printk(buf, count);\n\tspin_unlock_irqrestore(&tpkp->spinlock, flags);\n\n\treturn ret;\n}\n\n \nstatic unsigned int tpk_write_room(struct tty_struct *tty)\n{\n\treturn TPK_MAX_ROOM;\n}\n\n \nstatic void tpk_hangup(struct tty_struct *tty)\n{\n\tstruct ttyprintk_port *tpkp = tty->driver_data;\n\n\ttty_port_hangup(&tpkp->port);\n}\n\n \nstatic void tpk_port_shutdown(struct tty_port *tport)\n{\n\tstruct ttyprintk_port *tpkp =\n\t\tcontainer_of(tport, struct ttyprintk_port, port);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tpkp->spinlock, flags);\n\ttpk_flush();\n\tspin_unlock_irqrestore(&tpkp->spinlock, flags);\n}\n\nstatic const struct tty_operations ttyprintk_ops = {\n\t.open = tpk_open,\n\t.close = tpk_close,\n\t.write = tpk_write,\n\t.write_room = tpk_write_room,\n\t.hangup = tpk_hangup,\n};\n\nstatic const struct tty_port_operations tpk_port_ops = {\n\t.shutdown = tpk_port_shutdown,\n};\n\nstatic struct tty_driver *ttyprintk_driver;\n\nstatic struct tty_driver *ttyprintk_console_device(struct console *c,\n\t\t\t\t\t\t   int *index)\n{\n\t*index = 0;\n\treturn ttyprintk_driver;\n}\n\nstatic struct console ttyprintk_console = {\n\t.name = \"ttyprintk\",\n\t.device = ttyprintk_console_device,\n};\n\nstatic int __init ttyprintk_init(void)\n{\n\tint ret;\n\n\tspin_lock_init(&tpk_port.spinlock);\n\n\tttyprintk_driver = tty_alloc_driver(1,\n\t\t\tTTY_DRIVER_RESET_TERMIOS |\n\t\t\tTTY_DRIVER_REAL_RAW |\n\t\t\tTTY_DRIVER_UNNUMBERED_NODE);\n\tif (IS_ERR(ttyprintk_driver))\n\t\treturn PTR_ERR(ttyprintk_driver);\n\n\ttty_port_init(&tpk_port.port);\n\ttpk_port.port.ops = &tpk_port_ops;\n\n\tttyprintk_driver->driver_name = \"ttyprintk\";\n\tttyprintk_driver->name = \"ttyprintk\";\n\tttyprintk_driver->major = TTYAUX_MAJOR;\n\tttyprintk_driver->minor_start = 3;\n\tttyprintk_driver->type = TTY_DRIVER_TYPE_CONSOLE;\n\tttyprintk_driver->init_termios = tty_std_termios;\n\tttyprintk_driver->init_termios.c_oflag = OPOST | OCRNL | ONOCR | ONLRET;\n\ttty_set_operations(ttyprintk_driver, &ttyprintk_ops);\n\ttty_port_link_device(&tpk_port.port, ttyprintk_driver, 0);\n\n\tret = tty_register_driver(ttyprintk_driver);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR \"Couldn't register ttyprintk driver\\n\");\n\t\tgoto error;\n\t}\n\n\tregister_console(&ttyprintk_console);\n\n\treturn 0;\n\nerror:\n\ttty_driver_kref_put(ttyprintk_driver);\n\ttty_port_destroy(&tpk_port.port);\n\treturn ret;\n}\n\nstatic void __exit ttyprintk_exit(void)\n{\n\tunregister_console(&ttyprintk_console);\n\ttty_unregister_driver(ttyprintk_driver);\n\ttty_driver_kref_put(ttyprintk_driver);\n\ttty_port_destroy(&tpk_port.port);\n}\n\ndevice_initcall(ttyprintk_init);\nmodule_exit(ttyprintk_exit);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}