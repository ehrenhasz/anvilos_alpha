{
  "module_name": "nwflash.c",
  "hash_id": "6991432053e1abe52fe53401f30b8127389e987ce3f3096a1cc08367b13c80df",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/nwflash.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/delay.h>\n#include <linux/proc_fs.h>\n#include <linux/miscdevice.h>\n#include <linux/spinlock.h>\n#include <linux/rwsem.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/jiffies.h>\n\n#include <asm/hardware/dec21285.h>\n#include <asm/io.h>\n#include <asm/mach-types.h>\n#include <linux/uaccess.h>\n\n \n#include <asm/nwflash.h>\n\n#define\tNWFLASH_VERSION \"6.4\"\n\nstatic DEFINE_MUTEX(flash_mutex);\nstatic void kick_open(void);\nstatic int get_flash_id(void);\nstatic int erase_block(int nBlock);\nstatic int write_block(unsigned long p, const char __user *buf, int count);\n\n#define KFLASH_SIZE\t1024*1024\t\n#define KFLASH_SIZE4\t4*1024*1024\t\n#define KFLASH_ID\t0x89A6\t\t\n#define KFLASH_ID4\t0xB0D4\t\t\n\nstatic bool flashdebug;\t\t\n\nstatic int gbWriteEnable;\nstatic int gbWriteBase64Enable;\nstatic volatile unsigned char *FLASH_BASE;\nstatic int gbFlashSize = KFLASH_SIZE;\nstatic DEFINE_MUTEX(nwflash_mutex);\n\nstatic int get_flash_id(void)\n{\n\tvolatile unsigned int c1, c2;\n\n\t \n\tkick_open();\n\tc2 = inb(0x80);\n\t*(volatile unsigned char *) (FLASH_BASE + 0x8000) = 0x90;\n\tudelay(15);\n\tc1 = *(volatile unsigned char *) FLASH_BASE;\n\tc2 = inb(0x80);\n\n\t \n\tif (c1 == 0xB0)\n\t\tc2 = *(volatile unsigned char *) (FLASH_BASE + 2);\n\telse\n\t\tc2 = *(volatile unsigned char *) (FLASH_BASE + 1);\n\n\tc2 += (c1 << 8);\n\n\t \n\t*(volatile unsigned char *) (FLASH_BASE + 0x8000) = 0xFF;\n\n\tif (c2 == KFLASH_ID4)\n\t\tgbFlashSize = KFLASH_SIZE4;\n\n\treturn c2;\n}\n\nstatic long flash_ioctl(struct file *filep, unsigned int cmd, unsigned long arg)\n{\n\tmutex_lock(&flash_mutex);\n\tswitch (cmd) {\n\tcase CMD_WRITE_DISABLE:\n\t\tgbWriteBase64Enable = 0;\n\t\tgbWriteEnable = 0;\n\t\tbreak;\n\n\tcase CMD_WRITE_ENABLE:\n\t\tgbWriteEnable = 1;\n\t\tbreak;\n\n\tcase CMD_WRITE_BASE64K_ENABLE:\n\t\tgbWriteBase64Enable = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tgbWriteBase64Enable = 0;\n\t\tgbWriteEnable = 0;\n\t\tmutex_unlock(&flash_mutex);\n\t\treturn -EINVAL;\n\t}\n\tmutex_unlock(&flash_mutex);\n\treturn 0;\n}\n\nstatic ssize_t flash_read(struct file *file, char __user *buf, size_t size,\n\t\t\t  loff_t *ppos)\n{\n\tssize_t ret;\n\n\tif (flashdebug)\n\t\tprintk(KERN_DEBUG \"flash_read: flash_read: offset=0x%llx, \"\n\t\t       \"buffer=%p, count=0x%zx.\\n\", *ppos, buf, size);\n\t \n\tif (mutex_lock_interruptible(&nwflash_mutex))\n\t\treturn -ERESTARTSYS;\n\n\tret = simple_read_from_buffer(buf, size, ppos, (void *)FLASH_BASE, gbFlashSize);\n\tmutex_unlock(&nwflash_mutex);\n\n\treturn ret;\n}\n\nstatic ssize_t flash_write(struct file *file, const char __user *buf,\n\t\t\t   size_t size, loff_t * ppos)\n{\n\tunsigned long p = *ppos;\n\tunsigned int count = size;\n\tint written;\n\tint nBlock, temp, rc;\n\tint i, j;\n\n\tif (flashdebug)\n\t\tprintk(\"flash_write: offset=0x%lX, buffer=0x%p, count=0x%X.\\n\",\n\t\t       p, buf, count);\n\n\tif (!gbWriteEnable)\n\t\treturn -EINVAL;\n\n\tif (p < 64 * 1024 && (!gbWriteBase64Enable))\n\t\treturn -EINVAL;\n\n\t \n\tif (p >= gbFlashSize)\n\t\treturn count ? -ENXIO : 0;\n\n\tif (count > gbFlashSize - p)\n\t\tcount = gbFlashSize - p;\n\t\t\t\n\tif (!access_ok(buf, count))\n\t\treturn -EFAULT;\n\n\t \n\tif (mutex_lock_interruptible(&nwflash_mutex))\n\t\treturn -ERESTARTSYS;\n\n\twritten = 0;\n\n\tnBlock = (int) p >> 16;\t\n\n\t \n\ttemp = ((int) (p + count) >> 16) - nBlock + 1;\n\n\t \n\tif (((int) (p + count) & 0xFFFF) == 0)\n\t\ttemp -= 1;\n\n\tif (flashdebug)\n\t\tprintk(KERN_DEBUG \"flash_write: writing %d block(s) \"\n\t\t\t\"starting at %d.\\n\", temp, nBlock);\n\n\tfor (; temp; temp--, nBlock++) {\n\t\tif (flashdebug)\n\t\t\tprintk(KERN_DEBUG \"flash_write: erasing block %d.\\n\", nBlock);\n\n\t\t \n\t\ti = 0;\n\t\tj = 0;\n\t  RetryBlock:\n\t\tdo {\n\t\t\trc = erase_block(nBlock);\n\t\t\ti++;\n\t\t} while (rc && i < 10);\n\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"flash_write: erase error %x\\n\", rc);\n\t\t\tbreak;\n\t\t}\n\t\tif (flashdebug)\n\t\t\tprintk(KERN_DEBUG \"flash_write: writing offset %lX, \"\n\t\t\t       \"from buf %p, bytes left %X.\\n\", p, buf,\n\t\t\t       count - written);\n\n\t\t \n\t\trc = write_block(p, buf, count - written);\n\t\tj++;\n\n\t\t \n\t\tif (!rc) {\n\t\t\t \n\t\t\tif (j < 10)\n\t\t\t\tgoto RetryBlock;\n\t\t\telse\n\t\t\t\t \n\t\t\t\trc = -1;\n\n\t\t}\n\t\tif (rc < 0) {\n\t\t\tprintk(KERN_ERR \"flash_write: write error %X\\n\", rc);\n\t\t\tbreak;\n\t\t}\n\t\tp += rc;\n\t\tbuf += rc;\n\t\twritten += rc;\n\t\t*ppos += rc;\n\n\t\tif (flashdebug)\n\t\t\tprintk(KERN_DEBUG \"flash_write: written 0x%X bytes OK.\\n\", written);\n\t}\n\n\tmutex_unlock(&nwflash_mutex);\n\n\treturn written;\n}\n\n\n \nstatic loff_t flash_llseek(struct file *file, loff_t offset, int orig)\n{\n\tloff_t ret;\n\n\tmutex_lock(&flash_mutex);\n\tif (flashdebug)\n\t\tprintk(KERN_DEBUG \"flash_llseek: offset=0x%X, orig=0x%X.\\n\",\n\t\t       (unsigned int) offset, orig);\n\n\tret = no_seek_end_llseek_size(file, offset, orig, gbFlashSize);\n\tmutex_unlock(&flash_mutex);\n\treturn ret;\n}\n\n\n \n\nstatic int erase_block(int nBlock)\n{\n\tvolatile unsigned int c1;\n\tvolatile unsigned char *pWritePtr;\n\tunsigned long timeout;\n\tint temp, temp1;\n\n\t \n\t*CSR_ROMWRITEREG = 0;\n\n\t \n\tc1 = *(volatile unsigned char *) (FLASH_BASE + 0x8000);\n\n\tkick_open();\n\t \n\t*(volatile unsigned char *) (FLASH_BASE + 0x8000) = 0x50;\n\n\t \n\tpWritePtr = (unsigned char *) ((unsigned int) (FLASH_BASE + 0x8000 + (nBlock << 16)));\n\t \n\tc1 = *pWritePtr;\n\n\tkick_open();\n\t \n\t*(volatile unsigned char *) pWritePtr = 0x20;\n\n\t \n\t*(volatile unsigned char *) pWritePtr = 0xD0;\n\n\t \n\tmsleep(10);\n\n\t \n\ttimeout = jiffies + 10 * HZ;\n\tc1 = 0;\n\twhile (!(c1 & 0x80) && time_before(jiffies, timeout)) {\n\t\tmsleep(10);\n\t\t \n\t\tc1 = *(volatile unsigned char *) (pWritePtr);\n\t\t\n\t}\n\n\t \n\tkick_open();\n\n\t*(volatile unsigned char *) pWritePtr = 0xFF;\t\n\n\t \n\tif (c1 & 0x20) {\n\t\tprintk(KERN_ERR \"flash_erase: err at %p\\n\", pWritePtr);\n\n\t\t \n\t\t*(volatile unsigned char *) (FLASH_BASE + 0x8000) = 0x50;\n\t\treturn -2;\n\t}\n\n\t \n\tmsleep(10);\n\n\tpWritePtr = (unsigned char *) ((unsigned int) (FLASH_BASE + (nBlock << 16)));\n\n\tfor (temp = 0; temp < 16 * 1024; temp++, pWritePtr += 4) {\n\t\tif ((temp1 = *(volatile unsigned int *) pWritePtr) != 0xFFFFFFFF) {\n\t\t\tprintk(KERN_ERR \"flash_erase: verify err at %p = %X\\n\",\n\t\t\t       pWritePtr, temp1);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n\n}\n\n \nstatic int write_block(unsigned long p, const char __user *buf, int count)\n{\n\tvolatile unsigned int c1;\n\tvolatile unsigned int c2;\n\tunsigned char *pWritePtr;\n\tunsigned int uAddress;\n\tunsigned int offset;\n\tunsigned long timeout;\n\tunsigned long timeout1;\n\n\tpWritePtr = (unsigned char *) ((unsigned int) (FLASH_BASE + p));\n\n\t \n\toffset = p & 0xFFFF;\n\n\tif (offset + count > 0x10000)\n\t\tcount = 0x10000 - offset;\n\n\t \n\ttimeout = jiffies + 30 * HZ;\n\n\tfor (offset = 0; offset < count; offset++, pWritePtr++) {\n\t\tuAddress = (unsigned int) pWritePtr;\n\t\tuAddress &= 0xFFFFFFFC;\n\t\tif (__get_user(c2, buf + offset))\n\t\t\treturn -EFAULT;\n\n\t  WriteRetry:\n\t  \t \n\t\tc1 = *(volatile unsigned char *) (FLASH_BASE + 0x8000);\n\n\t\t \n\t\tkick_open();\n\n\t\t \n\t\t*CSR_ROMWRITEREG = (unsigned int) pWritePtr & 3;\n\n\t\t \n\t\t*(volatile unsigned char *) (uAddress) = 0x40;\n\n\t\t \n\t\t*(volatile unsigned char *) (uAddress) = c2;\n\n\t\t \n\t\t*(volatile unsigned char *) (FLASH_BASE + 0x10000) = 0x70;\n\n\t\tc1 = 0;\n\n\t\t \n\t\ttimeout1 = jiffies + 1 * HZ;\n\n\t\t \n\t\twhile (!(c1 & 0x80) && time_before(jiffies, timeout1))\n\t\t\tc1 = *(volatile unsigned char *) (FLASH_BASE + 0x8000);\n\n\t\t \n\t\tif (time_after_eq(jiffies, timeout1)) {\n\t\t\tkick_open();\n\t\t\t \n\t\t\t*(volatile unsigned char *) (FLASH_BASE + 0x8000) = 0x50;\n\n\t\t\tgoto WriteRetry;\n\t\t}\n\t\t \n\t\tkick_open();\n\t\t \n\t\t*(volatile unsigned char *) (FLASH_BASE + 0x8000) = 0xFF;\n\n\t\t \n\t\tif (c1 & 0x10) {\n\t\t\tkick_open();\n\t\t\t \n\t\t\t*(volatile unsigned char *) (FLASH_BASE + 0x8000) = 0x50;\n\n\t\t\t \n\t\t\tif (time_before(jiffies, timeout)) {\n\t\t\t\tif (flashdebug)\n\t\t\t\t\tprintk(KERN_DEBUG \"write_block: Retrying write at 0x%X)n\",\n\t\t\t\t\t       pWritePtr - FLASH_BASE);\n\n\t\t\t\t \n\t\t\t\tmsleep(10);\n\n\t\t\t\tgoto WriteRetry;\n\t\t\t} else {\n\t\t\t\tprintk(KERN_ERR \"write_block: timeout at 0x%X\\n\",\n\t\t\t\t       pWritePtr - FLASH_BASE);\n\t\t\t\t \n\t\t\t\treturn -2;\n\n\t\t\t}\n\t\t}\n\t}\n\n\tmsleep(10);\n\n\tpWritePtr = (unsigned char *) ((unsigned int) (FLASH_BASE + p));\n\n\tfor (offset = 0; offset < count; offset++) {\n\t\tchar c, c1;\n\t\tif (__get_user(c, buf))\n\t\t\treturn -EFAULT;\n\t\tbuf++;\n\t\tif ((c1 = *pWritePtr++) != c) {\n\t\t\tprintk(KERN_ERR \"write_block: verify error at 0x%X (%02X!=%02X)\\n\",\n\t\t\t       pWritePtr - FLASH_BASE, c1, c);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn count;\n}\n\n\nstatic void kick_open(void)\n{\n\tunsigned long flags;\n\n\t \n\traw_spin_lock_irqsave(&nw_gpio_lock, flags);\n\tnw_cpld_modify(CPLD_FLASH_WR_ENABLE, CPLD_FLASH_WR_ENABLE);\n\traw_spin_unlock_irqrestore(&nw_gpio_lock, flags);\n\n\t \n\tudelay(25);\n}\n\nstatic const struct file_operations flash_fops =\n{\n\t.owner\t\t= THIS_MODULE,\n\t.llseek\t\t= flash_llseek,\n\t.read\t\t= flash_read,\n\t.write\t\t= flash_write,\n\t.unlocked_ioctl\t= flash_ioctl,\n};\n\nstatic struct miscdevice flash_miscdev =\n{\n\tNWFLASH_MINOR,\n\t\"nwflash\",\n\t&flash_fops\n};\n\nstatic int __init nwflash_init(void)\n{\n\tint ret = -ENODEV;\n\n\tif (machine_is_netwinder()) {\n\t\tint id;\n\n\t\tFLASH_BASE = ioremap(DC21285_FLASH, KFLASH_SIZE4);\n\t\tif (!FLASH_BASE)\n\t\t\tgoto out;\n\n\t\tid = get_flash_id();\n\t\tif ((id != KFLASH_ID) && (id != KFLASH_ID4)) {\n\t\t\tret = -ENXIO;\n\t\t\tiounmap((void *)FLASH_BASE);\n\t\t\tprintk(\"Flash: incorrect ID 0x%04X.\\n\", id);\n\t\t\tgoto out;\n\t\t}\n\n\t\tprintk(\"Flash ROM driver v.%s, flash device ID 0x%04X, size %d Mb.\\n\",\n\t\t       NWFLASH_VERSION, id, gbFlashSize / (1024 * 1024));\n\n\t\tret = misc_register(&flash_miscdev);\n\t\tif (ret < 0) {\n\t\t\tiounmap((void *)FLASH_BASE);\n\t\t}\n\t}\nout:\n\treturn ret;\n}\n\nstatic void __exit nwflash_exit(void)\n{\n\tmisc_deregister(&flash_miscdev);\n\tiounmap((void *)FLASH_BASE);\n}\n\nMODULE_LICENSE(\"GPL\");\n\nmodule_param(flashdebug, bool, 0644);\n\nmodule_init(nwflash_init);\nmodule_exit(nwflash_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}