{
  "module_name": "adi.c",
  "hash_id": "04cb6da7c52faaa99235b9153816bb94e74252ab33f790ad5e3b6c2aa9e5e4c1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/adi.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/miscdevice.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <asm/asi.h>\n\n#define MAX_BUF_SZ\tPAGE_SIZE\n\nstatic int adi_open(struct inode *inode, struct file *file)\n{\n\tfile->f_mode |= FMODE_UNSIGNED_OFFSET;\n\treturn 0;\n}\n\nstatic int read_mcd_tag(unsigned long addr)\n{\n\tlong err;\n\tint ver;\n\n\t__asm__ __volatile__(\n\t\t\"1:\tldxa [%[addr]] %[asi], %[ver]\\n\"\n\t\t\"\tmov 0, %[err]\\n\"\n\t\t\"2:\\n\"\n\t\t\"\t.section .fixup,#alloc,#execinstr\\n\"\n\t\t\"\t.align 4\\n\"\n\t\t\"3:\tsethi %%hi(2b), %%g1\\n\"\n\t\t\"\tjmpl  %%g1 + %%lo(2b), %%g0\\n\"\n\t\t\"\tmov %[invalid], %[err]\\n\"\n\t\t\"\t.previous\\n\"\n\t\t\"\t.section __ex_table, \\\"a\\\"\\n\"\n\t\t\"\t.align 4\\n\"\n\t\t\"\t.word  1b, 3b\\n\"\n\t\t\"\t.previous\\n\"\n\t\t: [ver] \"=r\" (ver), [err] \"=r\" (err)\n\t\t: [addr] \"r\"  (addr), [invalid] \"i\" (EFAULT),\n\t\t  [asi] \"i\" (ASI_MCD_REAL)\n\t\t: \"memory\", \"g1\"\n\t\t);\n\n\tif (err)\n\t\treturn -EFAULT;\n\telse\n\t\treturn ver;\n}\n\nstatic ssize_t adi_read(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *offp)\n{\n\tsize_t ver_buf_sz, bytes_read = 0;\n\tint ver_buf_idx = 0;\n\tloff_t offset;\n\tu8 *ver_buf;\n\tssize_t ret;\n\n\tver_buf_sz = min_t(size_t, count, MAX_BUF_SZ);\n\tver_buf = kmalloc(ver_buf_sz, GFP_KERNEL);\n\tif (!ver_buf)\n\t\treturn -ENOMEM;\n\n\toffset = (*offp) * adi_blksize();\n\n\twhile (bytes_read < count) {\n\t\tret = read_mcd_tag(offset);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tver_buf[ver_buf_idx] = (u8)ret;\n\t\tver_buf_idx++;\n\t\toffset += adi_blksize();\n\n\t\tif (ver_buf_idx >= ver_buf_sz) {\n\t\t\tif (copy_to_user(buf + bytes_read, ver_buf,\n\t\t\t\t\t ver_buf_sz)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tbytes_read += ver_buf_sz;\n\t\t\tver_buf_idx = 0;\n\n\t\t\tver_buf_sz = min(count - bytes_read,\n\t\t\t\t\t (size_t)MAX_BUF_SZ);\n\t\t}\n\t}\n\n\t(*offp) += bytes_read;\n\tret = bytes_read;\nout:\n\tkfree(ver_buf);\n\treturn ret;\n}\n\nstatic int set_mcd_tag(unsigned long addr, u8 ver)\n{\n\tlong err;\n\n\t__asm__ __volatile__(\n\t\t\"1:\tstxa %[ver], [%[addr]] %[asi]\\n\"\n\t\t\"\tmov 0, %[err]\\n\"\n\t\t\"2:\\n\"\n\t\t\"\t.section .fixup,#alloc,#execinstr\\n\"\n\t\t\"\t.align 4\\n\"\n\t\t\"3:\tsethi %%hi(2b), %%g1\\n\"\n\t\t\"\tjmpl %%g1 + %%lo(2b), %%g0\\n\"\n\t\t\"\tmov %[invalid], %[err]\\n\"\n\t\t\"\t.previous\\n\"\n\t\t\"\t.section __ex_table, \\\"a\\\"\\n\"\n\t\t\"\t.align 4\\n\"\n\t\t\"\t.word 1b, 3b\\n\"\n\t\t\"\t.previous\\n\"\n\t\t: [err] \"=r\" (err)\n\t\t: [ver] \"r\" (ver), [addr] \"r\"  (addr),\n\t\t  [invalid] \"i\" (EFAULT), [asi] \"i\" (ASI_MCD_REAL)\n\t\t: \"memory\", \"g1\"\n\t\t);\n\n\tif (err)\n\t\treturn -EFAULT;\n\telse\n\t\treturn ver;\n}\n\nstatic ssize_t adi_write(struct file *file, const char __user *buf,\n\t\t\t size_t count, loff_t *offp)\n{\n\tsize_t ver_buf_sz, bytes_written = 0;\n\tloff_t offset;\n\tu8 *ver_buf;\n\tssize_t ret;\n\tint i;\n\n\tif (count <= 0)\n\t\treturn -EINVAL;\n\n\tver_buf_sz = min_t(size_t, count, MAX_BUF_SZ);\n\tver_buf = kmalloc(ver_buf_sz, GFP_KERNEL);\n\tif (!ver_buf)\n\t\treturn -ENOMEM;\n\n\toffset = (*offp) * adi_blksize();\n\n\tdo {\n\t\tif (copy_from_user(ver_buf, &buf[bytes_written],\n\t\t\t\t   ver_buf_sz)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (i = 0; i < ver_buf_sz; i++) {\n\t\t\tret = set_mcd_tag(offset, ver_buf[i]);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\n\t\t\toffset += adi_blksize();\n\t\t}\n\n\t\tbytes_written += ver_buf_sz;\n\t\tver_buf_sz = min(count - bytes_written, (size_t)MAX_BUF_SZ);\n\t} while (bytes_written < count);\n\n\t(*offp) += bytes_written;\n\tret = bytes_written;\nout:\n\t__asm__ __volatile__(\"membar #Sync\");\n\tkfree(ver_buf);\n\treturn ret;\n}\n\nstatic loff_t adi_llseek(struct file *file, loff_t offset, int whence)\n{\n\tloff_t ret = -EINVAL;\n\n\tswitch (whence) {\n\tcase SEEK_END:\n\tcase SEEK_DATA:\n\tcase SEEK_HOLE:\n\t\t \n\t\treturn -EINVAL;\n\tcase SEEK_CUR:\n\t\tif (offset == 0)\n\t\t\treturn file->f_pos;\n\n\t\toffset += file->f_pos;\n\t\tbreak;\n\tcase SEEK_SET:\n\t\tbreak;\n\t}\n\n\tif (offset != file->f_pos) {\n\t\tfile->f_pos = offset;\n\t\tfile->f_version = 0;\n\t\tret = offset;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct file_operations adi_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.llseek\t\t= adi_llseek,\n\t.open\t\t= adi_open,\n\t.read\t\t= adi_read,\n\t.write\t\t= adi_write,\n};\n\nstatic struct miscdevice adi_miscdev = {\n\t.minor = MISC_DYNAMIC_MINOR,\n\t.name = KBUILD_MODNAME,\n\t.fops = &adi_fops,\n};\n\nstatic int __init adi_init(void)\n{\n\tif (!adi_capable())\n\t\treturn -EPERM;\n\n\treturn misc_register(&adi_miscdev);\n}\n\nstatic void __exit adi_exit(void)\n{\n\tmisc_deregister(&adi_miscdev);\n}\n\nmodule_init(adi_init);\nmodule_exit(adi_exit);\n\nMODULE_AUTHOR(\"Tom Hromatka <tom.hromatka@oracle.com>\");\nMODULE_DESCRIPTION(\"Privileged interface to ADI\");\nMODULE_VERSION(\"1.0\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}