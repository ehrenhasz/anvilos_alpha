{
  "module_name": "virtio_console.c",
  "hash_id": "4c1a1852801bc14c0ded175a3ac930a3859fdd3309aea93944ff733de1f1d2d1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/virtio_console.c",
  "human_readable_source": "\n \n#include <linux/cdev.h>\n#include <linux/debugfs.h>\n#include <linux/completion.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/freezer.h>\n#include <linux/fs.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/poll.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/virtio.h>\n#include <linux/virtio_console.h>\n#include <linux/wait.h>\n#include <linux/workqueue.h>\n#include <linux/module.h>\n#include <linux/dma-mapping.h>\n#include \"../tty/hvc/hvc_console.h\"\n\n#define is_rproc_enabled IS_ENABLED(CONFIG_REMOTEPROC)\n#define VIRTCONS_MAX_PORTS 0x8000\n\n \nstruct ports_driver_data {\n\t \n\tstruct dentry *debugfs_dir;\n\n\t \n\tstruct list_head portdevs;\n\n\t \n\tstruct list_head consoles;\n};\n\nstatic struct ports_driver_data pdrvdata;\n\nstatic const struct class port_class = {\n\t.name = \"virtio-ports\",\n};\n\nstatic DEFINE_SPINLOCK(pdrvdata_lock);\nstatic DECLARE_COMPLETION(early_console_added);\n\n \nstruct console {\n\t \n\tstruct list_head list;\n\n\t \n\tstruct hvc_struct *hvc;\n\n\t \n\tstruct winsize ws;\n\n\t \n\tu32 vtermno;\n};\n\nstatic DEFINE_IDA(vtermno_ida);\n\nstruct port_buffer {\n\tchar *buf;\n\n\t \n\tsize_t size;\n\n\t \n\tsize_t len;\n\t \n\tsize_t offset;\n\n\t \n\tdma_addr_t dma;\n\n\t \n\tstruct device *dev;\n\n\t \n\tstruct list_head list;\n\n\t \n\tunsigned int sgpages;\n\n\t \n\tstruct scatterlist sg[];\n};\n\n \nstruct ports_device {\n\t \n\tstruct list_head list;\n\n\t \n\tstruct work_struct control_work;\n\tstruct work_struct config_work;\n\n\tstruct list_head ports;\n\n\t \n\tspinlock_t ports_lock;\n\n\t \n\tspinlock_t c_ivq_lock;\n\tspinlock_t c_ovq_lock;\n\n\t \n\tu32 max_nr_ports;\n\n\t \n\tstruct virtio_device *vdev;\n\n\t \n\tstruct virtqueue *c_ivq, *c_ovq;\n\n\t \n\tstruct virtio_console_control cpkt;\n\n\t \n\tstruct virtqueue **in_vqs, **out_vqs;\n\n\t \n\tint chr_major;\n};\n\nstruct port_stats {\n\tunsigned long bytes_sent, bytes_received, bytes_discarded;\n};\n\n \nstruct port {\n\t \n\tstruct list_head list;\n\n\t \n\tstruct ports_device *portdev;\n\n\t \n\tstruct port_buffer *inbuf;\n\n\t \n\tspinlock_t inbuf_lock;\n\n\t \n\tspinlock_t outvq_lock;\n\n\t \n\tstruct virtqueue *in_vq, *out_vq;\n\n\t \n\tstruct dentry *debugfs_file;\n\n\t \n\tstruct port_stats stats;\n\n\t \n\tstruct console cons;\n\n\t \n\tstruct cdev *cdev;\n\tstruct device *dev;\n\n\t \n\tstruct kref kref;\n\n\t \n\twait_queue_head_t waitqueue;\n\n\t \n\tchar *name;\n\n\t \n\tstruct fasync_struct *async_queue;\n\n\t \n\tu32 id;\n\n\tbool outvq_full;\n\n\t \n\tbool host_connected;\n\n\t \n\tbool guest_connected;\n};\n\n \nstatic int (*early_put_chars)(u32, const char *, int);\n\nstatic struct port *find_port_by_vtermno(u32 vtermno)\n{\n\tstruct port *port;\n\tstruct console *cons;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pdrvdata_lock, flags);\n\tlist_for_each_entry(cons, &pdrvdata.consoles, list) {\n\t\tif (cons->vtermno == vtermno) {\n\t\t\tport = container_of(cons, struct port, cons);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tport = NULL;\nout:\n\tspin_unlock_irqrestore(&pdrvdata_lock, flags);\n\treturn port;\n}\n\nstatic struct port *find_port_by_devt_in_portdev(struct ports_device *portdev,\n\t\t\t\t\t\t dev_t dev)\n{\n\tstruct port *port;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&portdev->ports_lock, flags);\n\tlist_for_each_entry(port, &portdev->ports, list) {\n\t\tif (port->cdev->dev == dev) {\n\t\t\tkref_get(&port->kref);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tport = NULL;\nout:\n\tspin_unlock_irqrestore(&portdev->ports_lock, flags);\n\n\treturn port;\n}\n\nstatic struct port *find_port_by_devt(dev_t dev)\n{\n\tstruct ports_device *portdev;\n\tstruct port *port;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pdrvdata_lock, flags);\n\tlist_for_each_entry(portdev, &pdrvdata.portdevs, list) {\n\t\tport = find_port_by_devt_in_portdev(portdev, dev);\n\t\tif (port)\n\t\t\tgoto out;\n\t}\n\tport = NULL;\nout:\n\tspin_unlock_irqrestore(&pdrvdata_lock, flags);\n\treturn port;\n}\n\nstatic struct port *find_port_by_id(struct ports_device *portdev, u32 id)\n{\n\tstruct port *port;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&portdev->ports_lock, flags);\n\tlist_for_each_entry(port, &portdev->ports, list)\n\t\tif (port->id == id)\n\t\t\tgoto out;\n\tport = NULL;\nout:\n\tspin_unlock_irqrestore(&portdev->ports_lock, flags);\n\n\treturn port;\n}\n\nstatic struct port *find_port_by_vq(struct ports_device *portdev,\n\t\t\t\t    struct virtqueue *vq)\n{\n\tstruct port *port;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&portdev->ports_lock, flags);\n\tlist_for_each_entry(port, &portdev->ports, list)\n\t\tif (port->in_vq == vq || port->out_vq == vq)\n\t\t\tgoto out;\n\tport = NULL;\nout:\n\tspin_unlock_irqrestore(&portdev->ports_lock, flags);\n\treturn port;\n}\n\nstatic bool is_console_port(struct port *port)\n{\n\tif (port->cons.hvc)\n\t\treturn true;\n\treturn false;\n}\n\nstatic bool is_rproc_serial(const struct virtio_device *vdev)\n{\n\treturn is_rproc_enabled && vdev->id.device == VIRTIO_ID_RPROC_SERIAL;\n}\n\nstatic inline bool use_multiport(struct ports_device *portdev)\n{\n\t \n\tif (!portdev->vdev)\n\t\treturn false;\n\treturn __virtio_test_bit(portdev->vdev, VIRTIO_CONSOLE_F_MULTIPORT);\n}\n\nstatic DEFINE_SPINLOCK(dma_bufs_lock);\nstatic LIST_HEAD(pending_free_dma_bufs);\n\nstatic void free_buf(struct port_buffer *buf, bool can_sleep)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < buf->sgpages; i++) {\n\t\tstruct page *page = sg_page(&buf->sg[i]);\n\t\tif (!page)\n\t\t\tbreak;\n\t\tput_page(page);\n\t}\n\n\tif (!buf->dev) {\n\t\tkfree(buf->buf);\n\t} else if (is_rproc_enabled) {\n\t\tunsigned long flags;\n\n\t\t \n\t\tif (!can_sleep) {\n\t\t\t \n\t\t\tspin_lock_irqsave(&dma_bufs_lock, flags);\n\t\t\tlist_add_tail(&buf->list, &pending_free_dma_bufs);\n\t\t\tspin_unlock_irqrestore(&dma_bufs_lock, flags);\n\t\t\treturn;\n\t\t}\n\t\tdma_free_coherent(buf->dev, buf->size, buf->buf, buf->dma);\n\n\t\t \n\t\tput_device(buf->dev);\n\t}\n\n\tkfree(buf);\n}\n\nstatic void reclaim_dma_bufs(void)\n{\n\tunsigned long flags;\n\tstruct port_buffer *buf, *tmp;\n\tLIST_HEAD(tmp_list);\n\n\tif (list_empty(&pending_free_dma_bufs))\n\t\treturn;\n\n\t \n\tspin_lock_irqsave(&dma_bufs_lock, flags);\n\tlist_cut_position(&tmp_list, &pending_free_dma_bufs,\n\t\t\t  pending_free_dma_bufs.prev);\n\tspin_unlock_irqrestore(&dma_bufs_lock, flags);\n\n\t \n\tlist_for_each_entry_safe(buf, tmp, &tmp_list, list) {\n\t\tlist_del(&buf->list);\n\t\tfree_buf(buf, true);\n\t}\n}\n\nstatic struct port_buffer *alloc_buf(struct virtio_device *vdev, size_t buf_size,\n\t\t\t\t     int pages)\n{\n\tstruct port_buffer *buf;\n\n\treclaim_dma_bufs();\n\n\t \n\tbuf = kmalloc(struct_size(buf, sg, pages), GFP_KERNEL);\n\tif (!buf)\n\t\tgoto fail;\n\n\tbuf->sgpages = pages;\n\tif (pages > 0) {\n\t\tbuf->dev = NULL;\n\t\tbuf->buf = NULL;\n\t\treturn buf;\n\t}\n\n\tif (is_rproc_serial(vdev)) {\n\t\t \n\t\tbuf->dev = vdev->dev.parent;\n\t\tif (!buf->dev)\n\t\t\tgoto free_buf;\n\n\t\t \n\t\tget_device(buf->dev);\n\t\tbuf->buf = dma_alloc_coherent(buf->dev, buf_size, &buf->dma,\n\t\t\t\t\t      GFP_KERNEL);\n\t} else {\n\t\tbuf->dev = NULL;\n\t\tbuf->buf = kmalloc(buf_size, GFP_KERNEL);\n\t}\n\n\tif (!buf->buf)\n\t\tgoto free_buf;\n\tbuf->len = 0;\n\tbuf->offset = 0;\n\tbuf->size = buf_size;\n\treturn buf;\n\nfree_buf:\n\tkfree(buf);\nfail:\n\treturn NULL;\n}\n\n \nstatic struct port_buffer *get_inbuf(struct port *port)\n{\n\tstruct port_buffer *buf;\n\tunsigned int len;\n\n\tif (port->inbuf)\n\t\treturn port->inbuf;\n\n\tbuf = virtqueue_get_buf(port->in_vq, &len);\n\tif (buf) {\n\t\tbuf->len = min_t(size_t, len, buf->size);\n\t\tbuf->offset = 0;\n\t\tport->stats.bytes_received += len;\n\t}\n\treturn buf;\n}\n\n \nstatic int add_inbuf(struct virtqueue *vq, struct port_buffer *buf)\n{\n\tstruct scatterlist sg[1];\n\tint ret;\n\n\tsg_init_one(sg, buf->buf, buf->size);\n\n\tret = virtqueue_add_inbuf(vq, sg, 1, buf, GFP_ATOMIC);\n\tvirtqueue_kick(vq);\n\tif (!ret)\n\t\tret = vq->num_free;\n\treturn ret;\n}\n\n \nstatic void discard_port_data(struct port *port)\n{\n\tstruct port_buffer *buf;\n\tunsigned int err;\n\n\tif (!port->portdev) {\n\t\t \n\t\treturn;\n\t}\n\tbuf = get_inbuf(port);\n\n\terr = 0;\n\twhile (buf) {\n\t\tport->stats.bytes_discarded += buf->len - buf->offset;\n\t\tif (add_inbuf(port->in_vq, buf) < 0) {\n\t\t\terr++;\n\t\t\tfree_buf(buf, false);\n\t\t}\n\t\tport->inbuf = NULL;\n\t\tbuf = get_inbuf(port);\n\t}\n\tif (err)\n\t\tdev_warn(port->dev, \"Errors adding %d buffers back to vq\\n\",\n\t\t\t err);\n}\n\nstatic bool port_has_data(struct port *port)\n{\n\tunsigned long flags;\n\tbool ret;\n\n\tret = false;\n\tspin_lock_irqsave(&port->inbuf_lock, flags);\n\tport->inbuf = get_inbuf(port);\n\tif (port->inbuf)\n\t\tret = true;\n\n\tspin_unlock_irqrestore(&port->inbuf_lock, flags);\n\treturn ret;\n}\n\nstatic ssize_t __send_control_msg(struct ports_device *portdev, u32 port_id,\n\t\t\t\t  unsigned int event, unsigned int value)\n{\n\tstruct scatterlist sg[1];\n\tstruct virtqueue *vq;\n\tunsigned int len;\n\n\tif (!use_multiport(portdev))\n\t\treturn 0;\n\n\tvq = portdev->c_ovq;\n\n\tspin_lock(&portdev->c_ovq_lock);\n\n\tportdev->cpkt.id = cpu_to_virtio32(portdev->vdev, port_id);\n\tportdev->cpkt.event = cpu_to_virtio16(portdev->vdev, event);\n\tportdev->cpkt.value = cpu_to_virtio16(portdev->vdev, value);\n\n\tsg_init_one(sg, &portdev->cpkt, sizeof(struct virtio_console_control));\n\n\tif (virtqueue_add_outbuf(vq, sg, 1, &portdev->cpkt, GFP_ATOMIC) == 0) {\n\t\tvirtqueue_kick(vq);\n\t\twhile (!virtqueue_get_buf(vq, &len)\n\t\t\t&& !virtqueue_is_broken(vq))\n\t\t\tcpu_relax();\n\t}\n\n\tspin_unlock(&portdev->c_ovq_lock);\n\treturn 0;\n}\n\nstatic ssize_t send_control_msg(struct port *port, unsigned int event,\n\t\t\t\tunsigned int value)\n{\n\t \n\tif (port->portdev)\n\t\treturn __send_control_msg(port->portdev, port->id, event, value);\n\treturn 0;\n}\n\n\n \nstatic void reclaim_consumed_buffers(struct port *port)\n{\n\tstruct port_buffer *buf;\n\tunsigned int len;\n\n\tif (!port->portdev) {\n\t\t \n\t\treturn;\n\t}\n\twhile ((buf = virtqueue_get_buf(port->out_vq, &len))) {\n\t\tfree_buf(buf, false);\n\t\tport->outvq_full = false;\n\t}\n}\n\nstatic ssize_t __send_to_port(struct port *port, struct scatterlist *sg,\n\t\t\t      int nents, size_t in_count,\n\t\t\t      void *data, bool nonblock)\n{\n\tstruct virtqueue *out_vq;\n\tint err;\n\tunsigned long flags;\n\tunsigned int len;\n\n\tout_vq = port->out_vq;\n\n\tspin_lock_irqsave(&port->outvq_lock, flags);\n\n\treclaim_consumed_buffers(port);\n\n\terr = virtqueue_add_outbuf(out_vq, sg, nents, data, GFP_ATOMIC);\n\n\t \n\tvirtqueue_kick(out_vq);\n\n\tif (err) {\n\t\tin_count = 0;\n\t\tgoto done;\n\t}\n\n\tif (out_vq->num_free == 0)\n\t\tport->outvq_full = true;\n\n\tif (nonblock)\n\t\tgoto done;\n\n\t \n\twhile (!virtqueue_get_buf(out_vq, &len)\n\t\t&& !virtqueue_is_broken(out_vq))\n\t\tcpu_relax();\ndone:\n\tspin_unlock_irqrestore(&port->outvq_lock, flags);\n\n\tport->stats.bytes_sent += in_count;\n\t \n\treturn in_count;\n}\n\n \nstatic ssize_t fill_readbuf(struct port *port, char __user *out_buf,\n\t\t\t    size_t out_count, bool to_user)\n{\n\tstruct port_buffer *buf;\n\tunsigned long flags;\n\n\tif (!out_count || !port_has_data(port))\n\t\treturn 0;\n\n\tbuf = port->inbuf;\n\tout_count = min(out_count, buf->len - buf->offset);\n\n\tif (to_user) {\n\t\tssize_t ret;\n\n\t\tret = copy_to_user(out_buf, buf->buf + buf->offset, out_count);\n\t\tif (ret)\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tmemcpy((__force char *)out_buf, buf->buf + buf->offset,\n\t\t       out_count);\n\t}\n\n\tbuf->offset += out_count;\n\n\tif (buf->offset == buf->len) {\n\t\t \n\t\tspin_lock_irqsave(&port->inbuf_lock, flags);\n\t\tport->inbuf = NULL;\n\n\t\tif (add_inbuf(port->in_vq, buf) < 0)\n\t\t\tdev_warn(port->dev, \"failed add_buf\\n\");\n\n\t\tspin_unlock_irqrestore(&port->inbuf_lock, flags);\n\t}\n\t \n\treturn out_count;\n}\n\n \nstatic bool will_read_block(struct port *port)\n{\n\tif (!port->guest_connected) {\n\t\t \n\t\treturn false;\n\t}\n\treturn !port_has_data(port) && port->host_connected;\n}\n\nstatic bool will_write_block(struct port *port)\n{\n\tbool ret;\n\n\tif (!port->guest_connected) {\n\t\t \n\t\treturn false;\n\t}\n\tif (!port->host_connected)\n\t\treturn true;\n\n\tspin_lock_irq(&port->outvq_lock);\n\t \n\treclaim_consumed_buffers(port);\n\tret = port->outvq_full;\n\tspin_unlock_irq(&port->outvq_lock);\n\n\treturn ret;\n}\n\nstatic ssize_t port_fops_read(struct file *filp, char __user *ubuf,\n\t\t\t      size_t count, loff_t *offp)\n{\n\tstruct port *port;\n\tssize_t ret;\n\n\tport = filp->private_data;\n\n\t \n\tif (!port->guest_connected)\n\t\treturn -ENODEV;\n\n\tif (!port_has_data(port)) {\n\t\t \n\t\tif (!port->host_connected)\n\t\t\treturn 0;\n\t\tif (filp->f_flags & O_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\n\t\tret = wait_event_freezable(port->waitqueue,\n\t\t\t\t\t   !will_read_block(port));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\t \n\tif (!port->guest_connected)\n\t\treturn -ENODEV;\n\t \n\tif (!port_has_data(port) && !port->host_connected)\n\t\treturn 0;\n\n\treturn fill_readbuf(port, ubuf, count, true);\n}\n\nstatic int wait_port_writable(struct port *port, bool nonblock)\n{\n\tint ret;\n\n\tif (will_write_block(port)) {\n\t\tif (nonblock)\n\t\t\treturn -EAGAIN;\n\n\t\tret = wait_event_freezable(port->waitqueue,\n\t\t\t\t\t   !will_write_block(port));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\t \n\tif (!port->guest_connected)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic ssize_t port_fops_write(struct file *filp, const char __user *ubuf,\n\t\t\t       size_t count, loff_t *offp)\n{\n\tstruct port *port;\n\tstruct port_buffer *buf;\n\tssize_t ret;\n\tbool nonblock;\n\tstruct scatterlist sg[1];\n\n\t \n\tif (!count)\n\t\treturn 0;\n\n\tport = filp->private_data;\n\n\tnonblock = filp->f_flags & O_NONBLOCK;\n\n\tret = wait_port_writable(port, nonblock);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcount = min((size_t)(32 * 1024), count);\n\n\tbuf = alloc_buf(port->portdev->vdev, count, 0);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = copy_from_user(buf->buf, ubuf, count);\n\tif (ret) {\n\t\tret = -EFAULT;\n\t\tgoto free_buf;\n\t}\n\n\t \n\tnonblock = true;\n\tsg_init_one(sg, buf->buf, count);\n\tret = __send_to_port(port, sg, 1, count, buf, nonblock);\n\n\tif (nonblock && ret > 0)\n\t\tgoto out;\n\nfree_buf:\n\tfree_buf(buf, true);\nout:\n\treturn ret;\n}\n\nstruct sg_list {\n\tunsigned int n;\n\tunsigned int size;\n\tsize_t len;\n\tstruct scatterlist *sg;\n};\n\nstatic int pipe_to_sg(struct pipe_inode_info *pipe, struct pipe_buffer *buf,\n\t\t\tstruct splice_desc *sd)\n{\n\tstruct sg_list *sgl = sd->u.data;\n\tunsigned int offset, len;\n\n\tif (sgl->n == sgl->size)\n\t\treturn 0;\n\n\t \n\tif (pipe_buf_try_steal(pipe, buf)) {\n\t\t \n\t\tget_page(buf->page);\n\t\tunlock_page(buf->page);\n\n\t\tlen = min(buf->len, sd->len);\n\t\tsg_set_page(&(sgl->sg[sgl->n]), buf->page, len, buf->offset);\n\t} else {\n\t\t \n\t\tstruct page *page = alloc_page(GFP_KERNEL);\n\t\tchar *src;\n\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\n\t\toffset = sd->pos & ~PAGE_MASK;\n\n\t\tlen = sd->len;\n\t\tif (len + offset > PAGE_SIZE)\n\t\t\tlen = PAGE_SIZE - offset;\n\n\t\tsrc = kmap_atomic(buf->page);\n\t\tmemcpy(page_address(page) + offset, src + buf->offset, len);\n\t\tkunmap_atomic(src);\n\n\t\tsg_set_page(&(sgl->sg[sgl->n]), page, len, offset);\n\t}\n\tsgl->n++;\n\tsgl->len += len;\n\n\treturn len;\n}\n\n \nstatic ssize_t port_fops_splice_write(struct pipe_inode_info *pipe,\n\t\t\t\t      struct file *filp, loff_t *ppos,\n\t\t\t\t      size_t len, unsigned int flags)\n{\n\tstruct port *port = filp->private_data;\n\tstruct sg_list sgl;\n\tssize_t ret;\n\tstruct port_buffer *buf;\n\tstruct splice_desc sd = {\n\t\t.total_len = len,\n\t\t.flags = flags,\n\t\t.pos = *ppos,\n\t\t.u.data = &sgl,\n\t};\n\tunsigned int occupancy;\n\n\t \n\tif (is_rproc_serial(port->out_vq->vdev))\n\t\treturn -EINVAL;\n\n\tpipe_lock(pipe);\n\tret = 0;\n\tif (pipe_empty(pipe->head, pipe->tail))\n\t\tgoto error_out;\n\n\tret = wait_port_writable(port, filp->f_flags & O_NONBLOCK);\n\tif (ret < 0)\n\t\tgoto error_out;\n\n\toccupancy = pipe_occupancy(pipe->head, pipe->tail);\n\tbuf = alloc_buf(port->portdev->vdev, 0, occupancy);\n\n\tif (!buf) {\n\t\tret = -ENOMEM;\n\t\tgoto error_out;\n\t}\n\n\tsgl.n = 0;\n\tsgl.len = 0;\n\tsgl.size = occupancy;\n\tsgl.sg = buf->sg;\n\tsg_init_table(sgl.sg, sgl.size);\n\tret = __splice_from_pipe(pipe, &sd, pipe_to_sg);\n\tpipe_unlock(pipe);\n\tif (likely(ret > 0))\n\t\tret = __send_to_port(port, buf->sg, sgl.n, sgl.len, buf, true);\n\n\tif (unlikely(ret <= 0))\n\t\tfree_buf(buf, true);\n\treturn ret;\n\nerror_out:\n\tpipe_unlock(pipe);\n\treturn ret;\n}\n\nstatic __poll_t port_fops_poll(struct file *filp, poll_table *wait)\n{\n\tstruct port *port;\n\t__poll_t ret;\n\n\tport = filp->private_data;\n\tpoll_wait(filp, &port->waitqueue, wait);\n\n\tif (!port->guest_connected) {\n\t\t \n\t\treturn EPOLLHUP;\n\t}\n\tret = 0;\n\tif (!will_read_block(port))\n\t\tret |= EPOLLIN | EPOLLRDNORM;\n\tif (!will_write_block(port))\n\t\tret |= EPOLLOUT;\n\tif (!port->host_connected)\n\t\tret |= EPOLLHUP;\n\n\treturn ret;\n}\n\nstatic void remove_port(struct kref *kref);\n\nstatic int port_fops_release(struct inode *inode, struct file *filp)\n{\n\tstruct port *port;\n\n\tport = filp->private_data;\n\n\t \n\tsend_control_msg(port, VIRTIO_CONSOLE_PORT_OPEN, 0);\n\n\tspin_lock_irq(&port->inbuf_lock);\n\tport->guest_connected = false;\n\n\tdiscard_port_data(port);\n\n\tspin_unlock_irq(&port->inbuf_lock);\n\n\tspin_lock_irq(&port->outvq_lock);\n\treclaim_consumed_buffers(port);\n\tspin_unlock_irq(&port->outvq_lock);\n\n\treclaim_dma_bufs();\n\t \n\tkref_put(&port->kref, remove_port);\n\n\treturn 0;\n}\n\nstatic int port_fops_open(struct inode *inode, struct file *filp)\n{\n\tstruct cdev *cdev = inode->i_cdev;\n\tstruct port *port;\n\tint ret;\n\n\t \n\tport = find_port_by_devt(cdev->dev);\n\tif (!port) {\n\t\t \n\t\treturn -ENXIO;\n\t}\n\tfilp->private_data = port;\n\n\t \n\tif (is_console_port(port)) {\n\t\tret = -ENXIO;\n\t\tgoto out;\n\t}\n\n\t \n\tspin_lock_irq(&port->inbuf_lock);\n\tif (port->guest_connected) {\n\t\tspin_unlock_irq(&port->inbuf_lock);\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tport->guest_connected = true;\n\tspin_unlock_irq(&port->inbuf_lock);\n\n\tspin_lock_irq(&port->outvq_lock);\n\t \n\treclaim_consumed_buffers(port);\n\tspin_unlock_irq(&port->outvq_lock);\n\n\tnonseekable_open(inode, filp);\n\n\t \n\tsend_control_msg(filp->private_data, VIRTIO_CONSOLE_PORT_OPEN, 1);\n\n\treturn 0;\nout:\n\tkref_put(&port->kref, remove_port);\n\treturn ret;\n}\n\nstatic int port_fops_fasync(int fd, struct file *filp, int mode)\n{\n\tstruct port *port;\n\n\tport = filp->private_data;\n\treturn fasync_helper(fd, filp, mode, &port->async_queue);\n}\n\n \nstatic const struct file_operations port_fops = {\n\t.owner = THIS_MODULE,\n\t.open  = port_fops_open,\n\t.read  = port_fops_read,\n\t.write = port_fops_write,\n\t.splice_write = port_fops_splice_write,\n\t.poll  = port_fops_poll,\n\t.release = port_fops_release,\n\t.fasync = port_fops_fasync,\n\t.llseek = no_llseek,\n};\n\n \nstatic int put_chars(u32 vtermno, const char *buf, int count)\n{\n\tstruct port *port;\n\tstruct scatterlist sg[1];\n\tvoid *data;\n\tint ret;\n\n\tif (unlikely(early_put_chars))\n\t\treturn early_put_chars(vtermno, buf, count);\n\n\tport = find_port_by_vtermno(vtermno);\n\tif (!port)\n\t\treturn -EPIPE;\n\n\tdata = kmemdup(buf, count, GFP_ATOMIC);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tsg_init_one(sg, data, count);\n\tret = __send_to_port(port, sg, 1, count, data, false);\n\tkfree(data);\n\treturn ret;\n}\n\n \nstatic int get_chars(u32 vtermno, char *buf, int count)\n{\n\tstruct port *port;\n\n\t \n\tif (unlikely(early_put_chars))\n\t\treturn 0;\n\n\tport = find_port_by_vtermno(vtermno);\n\tif (!port)\n\t\treturn -EPIPE;\n\n\t \n\tBUG_ON(!port->in_vq);\n\n\treturn fill_readbuf(port, (__force char __user *)buf, count, false);\n}\n\nstatic void resize_console(struct port *port)\n{\n\tstruct virtio_device *vdev;\n\n\t \n\tif (!port || !is_console_port(port))\n\t\treturn;\n\n\tvdev = port->portdev->vdev;\n\n\t \n\tif (!is_rproc_serial(vdev) &&\n\t    virtio_has_feature(vdev, VIRTIO_CONSOLE_F_SIZE))\n\t\thvc_resize(port->cons.hvc, port->cons.ws);\n}\n\n \nstatic int notifier_add_vio(struct hvc_struct *hp, int data)\n{\n\tstruct port *port;\n\n\tport = find_port_by_vtermno(hp->vtermno);\n\tif (!port)\n\t\treturn -EINVAL;\n\n\thp->irq_requested = 1;\n\tresize_console(port);\n\n\treturn 0;\n}\n\nstatic void notifier_del_vio(struct hvc_struct *hp, int data)\n{\n\thp->irq_requested = 0;\n}\n\n \nstatic const struct hv_ops hv_ops = {\n\t.get_chars = get_chars,\n\t.put_chars = put_chars,\n\t.notifier_add = notifier_add_vio,\n\t.notifier_del = notifier_del_vio,\n\t.notifier_hangup = notifier_del_vio,\n};\n\n \nint __init virtio_cons_early_init(int (*put_chars)(u32, const char *, int))\n{\n\tearly_put_chars = put_chars;\n\treturn hvc_instantiate(0, 0, &hv_ops);\n}\n\nstatic int init_port_console(struct port *port)\n{\n\tint ret;\n\n\t \n\tret = ida_alloc_min(&vtermno_ida, 1, GFP_KERNEL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tport->cons.vtermno = ret;\n\tport->cons.hvc = hvc_alloc(port->cons.vtermno, 0, &hv_ops, PAGE_SIZE);\n\tif (IS_ERR(port->cons.hvc)) {\n\t\tret = PTR_ERR(port->cons.hvc);\n\t\tdev_err(port->dev,\n\t\t\t\"error %d allocating hvc for port\\n\", ret);\n\t\tport->cons.hvc = NULL;\n\t\tida_free(&vtermno_ida, port->cons.vtermno);\n\t\treturn ret;\n\t}\n\tspin_lock_irq(&pdrvdata_lock);\n\tlist_add_tail(&port->cons.list, &pdrvdata.consoles);\n\tspin_unlock_irq(&pdrvdata_lock);\n\tport->guest_connected = true;\n\n\t \n\tif (early_put_chars)\n\t\tearly_put_chars = NULL;\n\n\t \n\tsend_control_msg(port, VIRTIO_CONSOLE_PORT_OPEN, 1);\n\n\treturn 0;\n}\n\nstatic ssize_t show_port_name(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buffer)\n{\n\tstruct port *port;\n\n\tport = dev_get_drvdata(dev);\n\n\treturn sprintf(buffer, \"%s\\n\", port->name);\n}\n\nstatic DEVICE_ATTR(name, S_IRUGO, show_port_name, NULL);\n\nstatic struct attribute *port_sysfs_entries[] = {\n\t&dev_attr_name.attr,\n\tNULL\n};\n\nstatic const struct attribute_group port_attribute_group = {\n\t.name = NULL,\t\t \n\t.attrs = port_sysfs_entries,\n};\n\nstatic int port_debugfs_show(struct seq_file *s, void *data)\n{\n\tstruct port *port = s->private;\n\n\tseq_printf(s, \"name: %s\\n\", port->name ? port->name : \"\");\n\tseq_printf(s, \"guest_connected: %d\\n\", port->guest_connected);\n\tseq_printf(s, \"host_connected: %d\\n\", port->host_connected);\n\tseq_printf(s, \"outvq_full: %d\\n\", port->outvq_full);\n\tseq_printf(s, \"bytes_sent: %lu\\n\", port->stats.bytes_sent);\n\tseq_printf(s, \"bytes_received: %lu\\n\", port->stats.bytes_received);\n\tseq_printf(s, \"bytes_discarded: %lu\\n\", port->stats.bytes_discarded);\n\tseq_printf(s, \"is_console: %s\\n\",\n\t\t   is_console_port(port) ? \"yes\" : \"no\");\n\tseq_printf(s, \"console_vtermno: %u\\n\", port->cons.vtermno);\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(port_debugfs);\n\nstatic void set_console_size(struct port *port, u16 rows, u16 cols)\n{\n\tif (!port || !is_console_port(port))\n\t\treturn;\n\n\tport->cons.ws.ws_row = rows;\n\tport->cons.ws.ws_col = cols;\n}\n\nstatic int fill_queue(struct virtqueue *vq, spinlock_t *lock)\n{\n\tstruct port_buffer *buf;\n\tint nr_added_bufs;\n\tint ret;\n\n\tnr_added_bufs = 0;\n\tdo {\n\t\tbuf = alloc_buf(vq->vdev, PAGE_SIZE, 0);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\n\t\tspin_lock_irq(lock);\n\t\tret = add_inbuf(vq, buf);\n\t\tif (ret < 0) {\n\t\t\tspin_unlock_irq(lock);\n\t\t\tfree_buf(buf, true);\n\t\t\treturn ret;\n\t\t}\n\t\tnr_added_bufs++;\n\t\tspin_unlock_irq(lock);\n\t} while (ret > 0);\n\n\treturn nr_added_bufs;\n}\n\nstatic void send_sigio_to_port(struct port *port)\n{\n\tif (port->async_queue && port->guest_connected)\n\t\tkill_fasync(&port->async_queue, SIGIO, POLL_OUT);\n}\n\nstatic int add_port(struct ports_device *portdev, u32 id)\n{\n\tchar debugfs_name[16];\n\tstruct port *port;\n\tdev_t devt;\n\tint err;\n\n\tport = kmalloc(sizeof(*port), GFP_KERNEL);\n\tif (!port) {\n\t\terr = -ENOMEM;\n\t\tgoto fail;\n\t}\n\tkref_init(&port->kref);\n\n\tport->portdev = portdev;\n\tport->id = id;\n\n\tport->name = NULL;\n\tport->inbuf = NULL;\n\tport->cons.hvc = NULL;\n\tport->async_queue = NULL;\n\n\tport->cons.ws.ws_row = port->cons.ws.ws_col = 0;\n\tport->cons.vtermno = 0;\n\n\tport->host_connected = port->guest_connected = false;\n\tport->stats = (struct port_stats) { 0 };\n\n\tport->outvq_full = false;\n\n\tport->in_vq = portdev->in_vqs[port->id];\n\tport->out_vq = portdev->out_vqs[port->id];\n\n\tport->cdev = cdev_alloc();\n\tif (!port->cdev) {\n\t\tdev_err(&port->portdev->vdev->dev, \"Error allocating cdev\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto free_port;\n\t}\n\tport->cdev->ops = &port_fops;\n\n\tdevt = MKDEV(portdev->chr_major, id);\n\terr = cdev_add(port->cdev, devt, 1);\n\tif (err < 0) {\n\t\tdev_err(&port->portdev->vdev->dev,\n\t\t\t\"Error %d adding cdev for port %u\\n\", err, id);\n\t\tgoto free_cdev;\n\t}\n\tport->dev = device_create(&port_class, &port->portdev->vdev->dev,\n\t\t\t\t  devt, port, \"vport%up%u\",\n\t\t\t\t  port->portdev->vdev->index, id);\n\tif (IS_ERR(port->dev)) {\n\t\terr = PTR_ERR(port->dev);\n\t\tdev_err(&port->portdev->vdev->dev,\n\t\t\t\"Error %d creating device for port %u\\n\",\n\t\t\terr, id);\n\t\tgoto free_cdev;\n\t}\n\n\tspin_lock_init(&port->inbuf_lock);\n\tspin_lock_init(&port->outvq_lock);\n\tinit_waitqueue_head(&port->waitqueue);\n\n\t \n\terr = fill_queue(port->in_vq, &port->inbuf_lock);\n\tif (err < 0 && err != -ENOSPC) {\n\t\tdev_err(port->dev, \"Error allocating inbufs\\n\");\n\t\tgoto free_device;\n\t}\n\n\tif (is_rproc_serial(port->portdev->vdev))\n\t\t \n\t\tport->host_connected = true;\n\telse if (!use_multiport(port->portdev)) {\n\t\t \n\t\terr = init_port_console(port);\n\t\tif (err)\n\t\t\tgoto free_inbufs;\n\t}\n\n\tspin_lock_irq(&portdev->ports_lock);\n\tlist_add_tail(&port->list, &port->portdev->ports);\n\tspin_unlock_irq(&portdev->ports_lock);\n\n\t \n\tsend_control_msg(port, VIRTIO_CONSOLE_PORT_READY, 1);\n\n\t \n\tsnprintf(debugfs_name, sizeof(debugfs_name), \"vport%up%u\",\n\t\t port->portdev->vdev->index, id);\n\tport->debugfs_file = debugfs_create_file(debugfs_name, 0444,\n\t\t\t\t\t\t pdrvdata.debugfs_dir,\n\t\t\t\t\t\t port, &port_debugfs_fops);\n\treturn 0;\n\nfree_inbufs:\nfree_device:\n\tdevice_destroy(&port_class, port->dev->devt);\nfree_cdev:\n\tcdev_del(port->cdev);\nfree_port:\n\tkfree(port);\nfail:\n\t \n\t__send_control_msg(portdev, id, VIRTIO_CONSOLE_PORT_READY, 0);\n\treturn err;\n}\n\n \nstatic void remove_port(struct kref *kref)\n{\n\tstruct port *port;\n\n\tport = container_of(kref, struct port, kref);\n\n\tkfree(port);\n}\n\nstatic void remove_port_data(struct port *port)\n{\n\tspin_lock_irq(&port->inbuf_lock);\n\t \n\tdiscard_port_data(port);\n\tspin_unlock_irq(&port->inbuf_lock);\n\n\tspin_lock_irq(&port->outvq_lock);\n\treclaim_consumed_buffers(port);\n\tspin_unlock_irq(&port->outvq_lock);\n}\n\n \nstatic void unplug_port(struct port *port)\n{\n\tspin_lock_irq(&port->portdev->ports_lock);\n\tlist_del(&port->list);\n\tspin_unlock_irq(&port->portdev->ports_lock);\n\n\tspin_lock_irq(&port->inbuf_lock);\n\tif (port->guest_connected) {\n\t\t \n\t\tsend_sigio_to_port(port);\n\n\t\t \n\t\tport->guest_connected = false;\n\t\tport->host_connected = false;\n\n\t\twake_up_interruptible(&port->waitqueue);\n\t}\n\tspin_unlock_irq(&port->inbuf_lock);\n\n\tif (is_console_port(port)) {\n\t\tspin_lock_irq(&pdrvdata_lock);\n\t\tlist_del(&port->cons.list);\n\t\tspin_unlock_irq(&pdrvdata_lock);\n\t\thvc_remove(port->cons.hvc);\n\t\tida_free(&vtermno_ida, port->cons.vtermno);\n\t}\n\n\tremove_port_data(port);\n\n\t \n\tport->portdev = NULL;\n\n\tsysfs_remove_group(&port->dev->kobj, &port_attribute_group);\n\tdevice_destroy(&port_class, port->dev->devt);\n\tcdev_del(port->cdev);\n\n\tdebugfs_remove(port->debugfs_file);\n\tkfree(port->name);\n\n\t \n\tkref_put(&port->kref, remove_port);\n}\n\n \nstatic void handle_control_message(struct virtio_device *vdev,\n\t\t\t\t   struct ports_device *portdev,\n\t\t\t\t   struct port_buffer *buf)\n{\n\tstruct virtio_console_control *cpkt;\n\tstruct port *port;\n\tsize_t name_size;\n\tint err;\n\n\tcpkt = (struct virtio_console_control *)(buf->buf + buf->offset);\n\n\tport = find_port_by_id(portdev, virtio32_to_cpu(vdev, cpkt->id));\n\tif (!port &&\n\t    cpkt->event != cpu_to_virtio16(vdev, VIRTIO_CONSOLE_PORT_ADD)) {\n\t\t \n\t\tdev_dbg(&portdev->vdev->dev,\n\t\t\t\"Invalid index %u in control packet\\n\", cpkt->id);\n\t\treturn;\n\t}\n\n\tswitch (virtio16_to_cpu(vdev, cpkt->event)) {\n\tcase VIRTIO_CONSOLE_PORT_ADD:\n\t\tif (port) {\n\t\t\tdev_dbg(&portdev->vdev->dev,\n\t\t\t\t\"Port %u already added\\n\", port->id);\n\t\t\tsend_control_msg(port, VIRTIO_CONSOLE_PORT_READY, 1);\n\t\t\tbreak;\n\t\t}\n\t\tif (virtio32_to_cpu(vdev, cpkt->id) >=\n\t\t    portdev->max_nr_ports) {\n\t\t\tdev_warn(&portdev->vdev->dev,\n\t\t\t\t\"Request for adding port with \"\n\t\t\t\t\"out-of-bound id %u, max. supported id: %u\\n\",\n\t\t\t\tcpkt->id, portdev->max_nr_ports - 1);\n\t\t\tbreak;\n\t\t}\n\t\tadd_port(portdev, virtio32_to_cpu(vdev, cpkt->id));\n\t\tbreak;\n\tcase VIRTIO_CONSOLE_PORT_REMOVE:\n\t\tunplug_port(port);\n\t\tbreak;\n\tcase VIRTIO_CONSOLE_CONSOLE_PORT:\n\t\tif (!cpkt->value)\n\t\t\tbreak;\n\t\tif (is_console_port(port))\n\t\t\tbreak;\n\n\t\tinit_port_console(port);\n\t\tcomplete(&early_console_added);\n\t\t \n\t\tbreak;\n\tcase VIRTIO_CONSOLE_RESIZE: {\n\t\tstruct {\n\t\t\t__u16 rows;\n\t\t\t__u16 cols;\n\t\t} size;\n\n\t\tif (!is_console_port(port))\n\t\t\tbreak;\n\n\t\tmemcpy(&size, buf->buf + buf->offset + sizeof(*cpkt),\n\t\t       sizeof(size));\n\t\tset_console_size(port, size.rows, size.cols);\n\n\t\tport->cons.hvc->irq_requested = 1;\n\t\tresize_console(port);\n\t\tbreak;\n\t}\n\tcase VIRTIO_CONSOLE_PORT_OPEN:\n\t\tport->host_connected = virtio16_to_cpu(vdev, cpkt->value);\n\t\twake_up_interruptible(&port->waitqueue);\n\t\t \n\t\tspin_lock_irq(&port->outvq_lock);\n\t\treclaim_consumed_buffers(port);\n\t\tspin_unlock_irq(&port->outvq_lock);\n\n\t\t \n\t\tspin_lock_irq(&port->inbuf_lock);\n\t\tsend_sigio_to_port(port);\n\t\tspin_unlock_irq(&port->inbuf_lock);\n\t\tbreak;\n\tcase VIRTIO_CONSOLE_PORT_NAME:\n\t\t \n\t\tif (port->name)\n\t\t\tbreak;\n\n\t\t \n\t\tname_size = buf->len - buf->offset - sizeof(*cpkt) + 1;\n\n\t\tport->name = kmalloc(name_size, GFP_KERNEL);\n\t\tif (!port->name) {\n\t\t\tdev_err(port->dev,\n\t\t\t\t\"Not enough space to store port name\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tstrscpy(port->name, buf->buf + buf->offset + sizeof(*cpkt),\n\t\t\tname_size);\n\n\t\t \n\t\terr = sysfs_create_group(&port->dev->kobj,\n\t\t\t\t\t &port_attribute_group);\n\t\tif (err) {\n\t\t\tdev_err(port->dev,\n\t\t\t\t\"Error %d creating sysfs device attributes\\n\",\n\t\t\t\terr);\n\t\t} else {\n\t\t\t \n\t\t\tkobject_uevent(&port->dev->kobj, KOBJ_CHANGE);\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic void control_work_handler(struct work_struct *work)\n{\n\tstruct ports_device *portdev;\n\tstruct virtqueue *vq;\n\tstruct port_buffer *buf;\n\tunsigned int len;\n\n\tportdev = container_of(work, struct ports_device, control_work);\n\tvq = portdev->c_ivq;\n\n\tspin_lock(&portdev->c_ivq_lock);\n\twhile ((buf = virtqueue_get_buf(vq, &len))) {\n\t\tspin_unlock(&portdev->c_ivq_lock);\n\n\t\tbuf->len = min_t(size_t, len, buf->size);\n\t\tbuf->offset = 0;\n\n\t\thandle_control_message(vq->vdev, portdev, buf);\n\n\t\tspin_lock(&portdev->c_ivq_lock);\n\t\tif (add_inbuf(portdev->c_ivq, buf) < 0) {\n\t\t\tdev_warn(&portdev->vdev->dev,\n\t\t\t\t \"Error adding buffer to queue\\n\");\n\t\t\tfree_buf(buf, false);\n\t\t}\n\t}\n\tspin_unlock(&portdev->c_ivq_lock);\n}\n\nstatic void flush_bufs(struct virtqueue *vq, bool can_sleep)\n{\n\tstruct port_buffer *buf;\n\tunsigned int len;\n\n\twhile ((buf = virtqueue_get_buf(vq, &len)))\n\t\tfree_buf(buf, can_sleep);\n}\n\nstatic void out_intr(struct virtqueue *vq)\n{\n\tstruct port *port;\n\n\tport = find_port_by_vq(vq->vdev->priv, vq);\n\tif (!port) {\n\t\tflush_bufs(vq, false);\n\t\treturn;\n\t}\n\n\twake_up_interruptible(&port->waitqueue);\n}\n\nstatic void in_intr(struct virtqueue *vq)\n{\n\tstruct port *port;\n\tunsigned long flags;\n\n\tport = find_port_by_vq(vq->vdev->priv, vq);\n\tif (!port) {\n\t\tflush_bufs(vq, false);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&port->inbuf_lock, flags);\n\tport->inbuf = get_inbuf(port);\n\n\t \n\n\tif (!port->guest_connected && !is_rproc_serial(port->portdev->vdev))\n\t\tdiscard_port_data(port);\n\n\t \n\tsend_sigio_to_port(port);\n\n\tspin_unlock_irqrestore(&port->inbuf_lock, flags);\n\n\twake_up_interruptible(&port->waitqueue);\n\n\tif (is_console_port(port) && hvc_poll(port->cons.hvc))\n\t\thvc_kick();\n}\n\nstatic void control_intr(struct virtqueue *vq)\n{\n\tstruct ports_device *portdev;\n\n\tportdev = vq->vdev->priv;\n\tschedule_work(&portdev->control_work);\n}\n\nstatic void config_intr(struct virtio_device *vdev)\n{\n\tstruct ports_device *portdev;\n\n\tportdev = vdev->priv;\n\n\tif (!use_multiport(portdev))\n\t\tschedule_work(&portdev->config_work);\n}\n\nstatic void config_work_handler(struct work_struct *work)\n{\n\tstruct ports_device *portdev;\n\n\tportdev = container_of(work, struct ports_device, config_work);\n\tif (!use_multiport(portdev)) {\n\t\tstruct virtio_device *vdev;\n\t\tstruct port *port;\n\t\tu16 rows, cols;\n\n\t\tvdev = portdev->vdev;\n\t\tvirtio_cread(vdev, struct virtio_console_config, cols, &cols);\n\t\tvirtio_cread(vdev, struct virtio_console_config, rows, &rows);\n\n\t\tport = find_port_by_id(portdev, 0);\n\t\tset_console_size(port, rows, cols);\n\n\t\t \n\t\tresize_console(port);\n\t}\n}\n\nstatic int init_vqs(struct ports_device *portdev)\n{\n\tvq_callback_t **io_callbacks;\n\tchar **io_names;\n\tstruct virtqueue **vqs;\n\tu32 i, j, nr_ports, nr_queues;\n\tint err;\n\n\tnr_ports = portdev->max_nr_ports;\n\tnr_queues = use_multiport(portdev) ? (nr_ports + 1) * 2 : 2;\n\n\tvqs = kmalloc_array(nr_queues, sizeof(struct virtqueue *), GFP_KERNEL);\n\tio_callbacks = kmalloc_array(nr_queues, sizeof(vq_callback_t *),\n\t\t\t\t     GFP_KERNEL);\n\tio_names = kmalloc_array(nr_queues, sizeof(char *), GFP_KERNEL);\n\tportdev->in_vqs = kmalloc_array(nr_ports, sizeof(struct virtqueue *),\n\t\t\t\t\tGFP_KERNEL);\n\tportdev->out_vqs = kmalloc_array(nr_ports, sizeof(struct virtqueue *),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!vqs || !io_callbacks || !io_names || !portdev->in_vqs ||\n\t    !portdev->out_vqs) {\n\t\terr = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\t \n\tj = 0;\n\tio_callbacks[j] = in_intr;\n\tio_callbacks[j + 1] = out_intr;\n\tio_names[j] = \"input\";\n\tio_names[j + 1] = \"output\";\n\tj += 2;\n\n\tif (use_multiport(portdev)) {\n\t\tio_callbacks[j] = control_intr;\n\t\tio_callbacks[j + 1] = NULL;\n\t\tio_names[j] = \"control-i\";\n\t\tio_names[j + 1] = \"control-o\";\n\n\t\tfor (i = 1; i < nr_ports; i++) {\n\t\t\tj += 2;\n\t\t\tio_callbacks[j] = in_intr;\n\t\t\tio_callbacks[j + 1] = out_intr;\n\t\t\tio_names[j] = \"input\";\n\t\t\tio_names[j + 1] = \"output\";\n\t\t}\n\t}\n\t \n\terr = virtio_find_vqs(portdev->vdev, nr_queues, vqs,\n\t\t\t      io_callbacks,\n\t\t\t      (const char **)io_names, NULL);\n\tif (err)\n\t\tgoto free;\n\n\tj = 0;\n\tportdev->in_vqs[0] = vqs[0];\n\tportdev->out_vqs[0] = vqs[1];\n\tj += 2;\n\tif (use_multiport(portdev)) {\n\t\tportdev->c_ivq = vqs[j];\n\t\tportdev->c_ovq = vqs[j + 1];\n\n\t\tfor (i = 1; i < nr_ports; i++) {\n\t\t\tj += 2;\n\t\t\tportdev->in_vqs[i] = vqs[j];\n\t\t\tportdev->out_vqs[i] = vqs[j + 1];\n\t\t}\n\t}\n\tkfree(io_names);\n\tkfree(io_callbacks);\n\tkfree(vqs);\n\n\treturn 0;\n\nfree:\n\tkfree(portdev->out_vqs);\n\tkfree(portdev->in_vqs);\n\tkfree(io_names);\n\tkfree(io_callbacks);\n\tkfree(vqs);\n\n\treturn err;\n}\n\nstatic const struct file_operations portdev_fops = {\n\t.owner = THIS_MODULE,\n};\n\nstatic void remove_vqs(struct ports_device *portdev)\n{\n\tstruct virtqueue *vq;\n\n\tvirtio_device_for_each_vq(portdev->vdev, vq) {\n\t\tstruct port_buffer *buf;\n\n\t\tflush_bufs(vq, true);\n\t\twhile ((buf = virtqueue_detach_unused_buf(vq)))\n\t\t\tfree_buf(buf, true);\n\t\tcond_resched();\n\t}\n\tportdev->vdev->config->del_vqs(portdev->vdev);\n\tkfree(portdev->in_vqs);\n\tkfree(portdev->out_vqs);\n}\n\nstatic void virtcons_remove(struct virtio_device *vdev)\n{\n\tstruct ports_device *portdev;\n\tstruct port *port, *port2;\n\n\tportdev = vdev->priv;\n\n\tspin_lock_irq(&pdrvdata_lock);\n\tlist_del(&portdev->list);\n\tspin_unlock_irq(&pdrvdata_lock);\n\n\t \n\tvirtio_break_device(vdev);\n\tif (use_multiport(portdev))\n\t\tflush_work(&portdev->control_work);\n\telse\n\t\tflush_work(&portdev->config_work);\n\n\t \n\tvirtio_reset_device(vdev);\n\t \n\tif (use_multiport(portdev))\n\t\tcancel_work_sync(&portdev->control_work);\n\telse\n\t\tcancel_work_sync(&portdev->config_work);\n\n\tlist_for_each_entry_safe(port, port2, &portdev->ports, list)\n\t\tunplug_port(port);\n\n\tunregister_chrdev(portdev->chr_major, \"virtio-portsdev\");\n\n\t \n\tremove_vqs(portdev);\n\tkfree(portdev);\n}\n\n \nstatic int virtcons_probe(struct virtio_device *vdev)\n{\n\tstruct ports_device *portdev;\n\tint err;\n\tbool multiport;\n\tbool early = early_put_chars != NULL;\n\n\t \n\tif (!vdev->config->get &&\n\t    (virtio_has_feature(vdev, VIRTIO_CONSOLE_F_SIZE)\n\t     || virtio_has_feature(vdev, VIRTIO_CONSOLE_F_MULTIPORT))) {\n\t\tdev_err(&vdev->dev, \"%s failure: config access disabled\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tbarrier();\n\n\tportdev = kmalloc(sizeof(*portdev), GFP_KERNEL);\n\tif (!portdev) {\n\t\terr = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\t \n\tportdev->vdev = vdev;\n\tvdev->priv = portdev;\n\n\tportdev->chr_major = register_chrdev(0, \"virtio-portsdev\",\n\t\t\t\t\t     &portdev_fops);\n\tif (portdev->chr_major < 0) {\n\t\tdev_err(&vdev->dev,\n\t\t\t\"Error %d registering chrdev for device %u\\n\",\n\t\t\tportdev->chr_major, vdev->index);\n\t\terr = portdev->chr_major;\n\t\tgoto free;\n\t}\n\n\tmultiport = false;\n\tportdev->max_nr_ports = 1;\n\n\t \n\tif (!is_rproc_serial(vdev) &&\n\t    virtio_cread_feature(vdev, VIRTIO_CONSOLE_F_MULTIPORT,\n\t\t\t\t struct virtio_console_config, max_nr_ports,\n\t\t\t\t &portdev->max_nr_ports) == 0) {\n\t\tif (portdev->max_nr_ports == 0 ||\n\t\t    portdev->max_nr_ports > VIRTCONS_MAX_PORTS) {\n\t\t\tdev_err(&vdev->dev,\n\t\t\t\t\"Invalidate max_nr_ports %d\",\n\t\t\t\tportdev->max_nr_ports);\n\t\t\terr = -EINVAL;\n\t\t\tgoto free;\n\t\t}\n\t\tmultiport = true;\n\t}\n\n\terr = init_vqs(portdev);\n\tif (err < 0) {\n\t\tdev_err(&vdev->dev, \"Error %d initializing vqs\\n\", err);\n\t\tgoto free_chrdev;\n\t}\n\n\tspin_lock_init(&portdev->ports_lock);\n\tINIT_LIST_HEAD(&portdev->ports);\n\tINIT_LIST_HEAD(&portdev->list);\n\n\tvirtio_device_ready(portdev->vdev);\n\n\tINIT_WORK(&portdev->config_work, &config_work_handler);\n\tINIT_WORK(&portdev->control_work, &control_work_handler);\n\n\tif (multiport) {\n\t\tspin_lock_init(&portdev->c_ivq_lock);\n\t\tspin_lock_init(&portdev->c_ovq_lock);\n\n\t\terr = fill_queue(portdev->c_ivq, &portdev->c_ivq_lock);\n\t\tif (err < 0) {\n\t\t\tdev_err(&vdev->dev,\n\t\t\t\t\"Error allocating buffers for control queue\\n\");\n\t\t\t \n\t\t\t__send_control_msg(portdev, VIRTIO_CONSOLE_BAD_ID,\n\t\t\t\t\t   VIRTIO_CONSOLE_DEVICE_READY, 0);\n\t\t\t \n\t\t\tvirtcons_remove(vdev);\n\t\t\treturn err;\n\t\t}\n\t} else {\n\t\t \n\t\tadd_port(portdev, 0);\n\t}\n\n\tspin_lock_irq(&pdrvdata_lock);\n\tlist_add_tail(&portdev->list, &pdrvdata.portdevs);\n\tspin_unlock_irq(&pdrvdata_lock);\n\n\t__send_control_msg(portdev, VIRTIO_CONSOLE_BAD_ID,\n\t\t\t   VIRTIO_CONSOLE_DEVICE_READY, 1);\n\n\t \n\tif (multiport && early)\n\t\twait_for_completion(&early_console_added);\n\n\treturn 0;\n\nfree_chrdev:\n\tunregister_chrdev(portdev->chr_major, \"virtio-portsdev\");\nfree:\n\tkfree(portdev);\nfail:\n\treturn err;\n}\n\nstatic const struct virtio_device_id id_table[] = {\n\t{ VIRTIO_ID_CONSOLE, VIRTIO_DEV_ANY_ID },\n\t{ 0 },\n};\nMODULE_DEVICE_TABLE(virtio, id_table);\n\nstatic const unsigned int features[] = {\n\tVIRTIO_CONSOLE_F_SIZE,\n\tVIRTIO_CONSOLE_F_MULTIPORT,\n};\n\nstatic const struct virtio_device_id rproc_serial_id_table[] = {\n#if IS_ENABLED(CONFIG_REMOTEPROC)\n\t{ VIRTIO_ID_RPROC_SERIAL, VIRTIO_DEV_ANY_ID },\n#endif\n\t{ 0 },\n};\nMODULE_DEVICE_TABLE(virtio, rproc_serial_id_table);\n\nstatic const unsigned int rproc_serial_features[] = {\n};\n\n#ifdef CONFIG_PM_SLEEP\nstatic int virtcons_freeze(struct virtio_device *vdev)\n{\n\tstruct ports_device *portdev;\n\tstruct port *port;\n\n\tportdev = vdev->priv;\n\n\tvirtio_reset_device(vdev);\n\n\tif (use_multiport(portdev))\n\t\tvirtqueue_disable_cb(portdev->c_ivq);\n\tcancel_work_sync(&portdev->control_work);\n\tcancel_work_sync(&portdev->config_work);\n\t \n\tif (use_multiport(portdev))\n\t\tvirtqueue_disable_cb(portdev->c_ivq);\n\n\tlist_for_each_entry(port, &portdev->ports, list) {\n\t\tvirtqueue_disable_cb(port->in_vq);\n\t\tvirtqueue_disable_cb(port->out_vq);\n\t\t \n\t\tport->host_connected = false;\n\t\tremove_port_data(port);\n\t}\n\tremove_vqs(portdev);\n\n\treturn 0;\n}\n\nstatic int virtcons_restore(struct virtio_device *vdev)\n{\n\tstruct ports_device *portdev;\n\tstruct port *port;\n\tint ret;\n\n\tportdev = vdev->priv;\n\n\tret = init_vqs(portdev);\n\tif (ret)\n\t\treturn ret;\n\n\tvirtio_device_ready(portdev->vdev);\n\n\tif (use_multiport(portdev))\n\t\tfill_queue(portdev->c_ivq, &portdev->c_ivq_lock);\n\n\tlist_for_each_entry(port, &portdev->ports, list) {\n\t\tport->in_vq = portdev->in_vqs[port->id];\n\t\tport->out_vq = portdev->out_vqs[port->id];\n\n\t\tfill_queue(port->in_vq, &port->inbuf_lock);\n\n\t\t \n\t\tsend_control_msg(port, VIRTIO_CONSOLE_PORT_READY, 1);\n\n\t\t \n\t\tif (port->guest_connected)\n\t\t\tsend_control_msg(port, VIRTIO_CONSOLE_PORT_OPEN, 1);\n\t}\n\treturn 0;\n}\n#endif\n\nstatic struct virtio_driver virtio_console = {\n\t.feature_table = features,\n\t.feature_table_size = ARRAY_SIZE(features),\n\t.driver.name =\tKBUILD_MODNAME,\n\t.driver.owner =\tTHIS_MODULE,\n\t.id_table =\tid_table,\n\t.probe =\tvirtcons_probe,\n\t.remove =\tvirtcons_remove,\n\t.config_changed = config_intr,\n#ifdef CONFIG_PM_SLEEP\n\t.freeze =\tvirtcons_freeze,\n\t.restore =\tvirtcons_restore,\n#endif\n};\n\nstatic struct virtio_driver virtio_rproc_serial = {\n\t.feature_table = rproc_serial_features,\n\t.feature_table_size = ARRAY_SIZE(rproc_serial_features),\n\t.driver.name =\t\"virtio_rproc_serial\",\n\t.driver.owner =\tTHIS_MODULE,\n\t.id_table =\trproc_serial_id_table,\n\t.probe =\tvirtcons_probe,\n\t.remove =\tvirtcons_remove,\n};\n\nstatic int __init virtio_console_init(void)\n{\n\tint err;\n\n\terr = class_register(&port_class);\n\tif (err)\n\t\treturn err;\n\n\tpdrvdata.debugfs_dir = debugfs_create_dir(\"virtio-ports\", NULL);\n\tINIT_LIST_HEAD(&pdrvdata.consoles);\n\tINIT_LIST_HEAD(&pdrvdata.portdevs);\n\n\terr = register_virtio_driver(&virtio_console);\n\tif (err < 0) {\n\t\tpr_err(\"Error %d registering virtio driver\\n\", err);\n\t\tgoto free;\n\t}\n\terr = register_virtio_driver(&virtio_rproc_serial);\n\tif (err < 0) {\n\t\tpr_err(\"Error %d registering virtio rproc serial driver\\n\",\n\t\t       err);\n\t\tgoto unregister;\n\t}\n\treturn 0;\nunregister:\n\tunregister_virtio_driver(&virtio_console);\nfree:\n\tdebugfs_remove_recursive(pdrvdata.debugfs_dir);\n\tclass_unregister(&port_class);\n\treturn err;\n}\n\nstatic void __exit virtio_console_fini(void)\n{\n\treclaim_dma_bufs();\n\n\tunregister_virtio_driver(&virtio_console);\n\tunregister_virtio_driver(&virtio_rproc_serial);\n\n\tclass_unregister(&port_class);\n\tdebugfs_remove_recursive(pdrvdata.debugfs_dir);\n}\nmodule_init(virtio_console_init);\nmodule_exit(virtio_console_fini);\n\nMODULE_DESCRIPTION(\"Virtio console driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}