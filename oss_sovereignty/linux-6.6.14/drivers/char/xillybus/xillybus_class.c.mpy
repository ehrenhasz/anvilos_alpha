{
  "module_name": "xillybus_class.c",
  "hash_id": "ae0768978b2529ec2886be96888a4bf36483a81cc972786370d736b1bba8e612",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/xillybus/xillybus_class.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/fs.h>\n#include <linux/cdev.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n\n#include \"xillybus_class.h\"\n\nMODULE_DESCRIPTION(\"Driver for Xillybus class\");\nMODULE_AUTHOR(\"Eli Billauer, Xillybus Ltd.\");\nMODULE_ALIAS(\"xillybus_class\");\nMODULE_LICENSE(\"GPL v2\");\n\nstatic DEFINE_MUTEX(unit_mutex);\nstatic LIST_HEAD(unit_list);\nstatic const struct class xillybus_class = {\n\t.name = \"xillybus\",\n};\n\n#define UNITNAMELEN 16\n\nstruct xilly_unit {\n\tstruct list_head list_entry;\n\tvoid *private_data;\n\n\tstruct cdev *cdev;\n\tchar name[UNITNAMELEN];\n\tint major;\n\tint lowest_minor;\n\tint num_nodes;\n};\n\nint xillybus_init_chrdev(struct device *dev,\n\t\t\t const struct file_operations *fops,\n\t\t\t struct module *owner,\n\t\t\t void *private_data,\n\t\t\t unsigned char *idt, unsigned int len,\n\t\t\t int num_nodes,\n\t\t\t const char *prefix, bool enumerate)\n{\n\tint rc;\n\tdev_t mdev;\n\tint i;\n\tchar devname[48];\n\n\tstruct device *device;\n\tsize_t namelen;\n\tstruct xilly_unit *unit, *u;\n\n\tunit = kzalloc(sizeof(*unit), GFP_KERNEL);\n\n\tif (!unit)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&unit_mutex);\n\n\tif (!enumerate)\n\t\tsnprintf(unit->name, UNITNAMELEN, \"%s\", prefix);\n\n\tfor (i = 0; enumerate; i++) {\n\t\tsnprintf(unit->name, UNITNAMELEN, \"%s_%02d\",\n\t\t\t prefix, i);\n\n\t\tenumerate = false;\n\t\tlist_for_each_entry(u, &unit_list, list_entry)\n\t\t\tif (!strcmp(unit->name, u->name)) {\n\t\t\t\tenumerate = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\trc = alloc_chrdev_region(&mdev, 0, num_nodes, unit->name);\n\n\tif (rc) {\n\t\tdev_warn(dev, \"Failed to obtain major/minors\");\n\t\tgoto fail_obtain;\n\t}\n\n\tunit->major = MAJOR(mdev);\n\tunit->lowest_minor = MINOR(mdev);\n\tunit->num_nodes = num_nodes;\n\tunit->private_data = private_data;\n\n\tunit->cdev = cdev_alloc();\n\tif (!unit->cdev) {\n\t\trc = -ENOMEM;\n\t\tgoto unregister_chrdev;\n\t}\n\tunit->cdev->ops = fops;\n\tunit->cdev->owner = owner;\n\n\trc = cdev_add(unit->cdev, MKDEV(unit->major, unit->lowest_minor),\n\t\t      unit->num_nodes);\n\tif (rc) {\n\t\tdev_err(dev, \"Failed to add cdev.\\n\");\n\t\t \n\t\tkobject_put(&unit->cdev->kobj);\n\t\tgoto unregister_chrdev;\n\t}\n\n\tfor (i = 0; i < num_nodes; i++) {\n\t\tnamelen = strnlen(idt, len);\n\n\t\tif (namelen == len) {\n\t\t\tdev_err(dev, \"IDT's list of names is too short. This is exceptionally weird, because its CRC is OK\\n\");\n\t\t\trc = -ENODEV;\n\t\t\tgoto unroll_device_create;\n\t\t}\n\n\t\tsnprintf(devname, sizeof(devname), \"%s_%s\",\n\t\t\t unit->name, idt);\n\n\t\tlen -= namelen + 1;\n\t\tidt += namelen + 1;\n\n\t\tdevice = device_create(&xillybus_class,\n\t\t\t\t       NULL,\n\t\t\t\t       MKDEV(unit->major,\n\t\t\t\t\t     i + unit->lowest_minor),\n\t\t\t\t       NULL,\n\t\t\t\t       \"%s\", devname);\n\n\t\tif (IS_ERR(device)) {\n\t\t\tdev_err(dev, \"Failed to create %s device. Aborting.\\n\",\n\t\t\t\tdevname);\n\t\t\trc = -ENODEV;\n\t\t\tgoto unroll_device_create;\n\t\t}\n\t}\n\n\tif (len) {\n\t\tdev_err(dev, \"IDT's list of names is too long. This is exceptionally weird, because its CRC is OK\\n\");\n\t\trc = -ENODEV;\n\t\tgoto unroll_device_create;\n\t}\n\n\tlist_add_tail(&unit->list_entry, &unit_list);\n\n\tdev_info(dev, \"Created %d device files.\\n\", num_nodes);\n\n\tmutex_unlock(&unit_mutex);\n\n\treturn 0;\n\nunroll_device_create:\n\tfor (i--; i >= 0; i--)\n\t\tdevice_destroy(&xillybus_class, MKDEV(unit->major,\n\t\t\t\t\t\t     i + unit->lowest_minor));\n\n\tcdev_del(unit->cdev);\n\nunregister_chrdev:\n\tunregister_chrdev_region(MKDEV(unit->major, unit->lowest_minor),\n\t\t\t\t unit->num_nodes);\n\nfail_obtain:\n\tmutex_unlock(&unit_mutex);\n\n\tkfree(unit);\n\n\treturn rc;\n}\nEXPORT_SYMBOL(xillybus_init_chrdev);\n\nvoid xillybus_cleanup_chrdev(void *private_data,\n\t\t\t     struct device *dev)\n{\n\tint minor;\n\tstruct xilly_unit *unit = NULL, *iter;\n\n\tmutex_lock(&unit_mutex);\n\n\tlist_for_each_entry(iter, &unit_list, list_entry)\n\t\tif (iter->private_data == private_data) {\n\t\t\tunit = iter;\n\t\t\tbreak;\n\t\t}\n\n\tif (!unit) {\n\t\tdev_err(dev, \"Weird bug: Failed to find unit\\n\");\n\t\tmutex_unlock(&unit_mutex);\n\t\treturn;\n\t}\n\n\tfor (minor = unit->lowest_minor;\n\t     minor < (unit->lowest_minor + unit->num_nodes);\n\t     minor++)\n\t\tdevice_destroy(&xillybus_class, MKDEV(unit->major, minor));\n\n\tcdev_del(unit->cdev);\n\n\tunregister_chrdev_region(MKDEV(unit->major, unit->lowest_minor),\n\t\t\t\t unit->num_nodes);\n\n\tdev_info(dev, \"Removed %d device files.\\n\",\n\t\t unit->num_nodes);\n\n\tlist_del(&unit->list_entry);\n\tkfree(unit);\n\n\tmutex_unlock(&unit_mutex);\n}\nEXPORT_SYMBOL(xillybus_cleanup_chrdev);\n\nint xillybus_find_inode(struct inode *inode,\n\t\t\tvoid **private_data, int *index)\n{\n\tint minor = iminor(inode);\n\tint major = imajor(inode);\n\tstruct xilly_unit *unit = NULL, *iter;\n\n\tmutex_lock(&unit_mutex);\n\n\tlist_for_each_entry(iter, &unit_list, list_entry)\n\t\tif (iter->major == major &&\n\t\t    minor >= iter->lowest_minor &&\n\t\t    minor < (iter->lowest_minor + iter->num_nodes)) {\n\t\t\tunit = iter;\n\t\t\tbreak;\n\t\t}\n\n\tif (!unit) {\n\t\tmutex_unlock(&unit_mutex);\n\t\treturn -ENODEV;\n\t}\n\n\t*private_data = unit->private_data;\n\t*index = minor - unit->lowest_minor;\n\n\tmutex_unlock(&unit_mutex);\n\treturn 0;\n}\nEXPORT_SYMBOL(xillybus_find_inode);\n\nstatic int __init xillybus_class_init(void)\n{\n\treturn class_register(&xillybus_class);\n}\n\nstatic void __exit xillybus_class_exit(void)\n{\n\tclass_unregister(&xillybus_class);\n}\n\nmodule_init(xillybus_class_init);\nmodule_exit(xillybus_class_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}