{
  "module_name": "xillybus_core.c",
  "hash_id": "a4438c67a6c0eb246d06cd8af196cbba8fdbcf86e4bdf98154f15bea92ab48b0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/xillybus/xillybus_core.c",
  "human_readable_source": "\n \n\n#include <linux/list.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/dma-mapping.h>\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/crc32.h>\n#include <linux/poll.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include \"xillybus.h\"\n#include \"xillybus_class.h\"\n\nMODULE_DESCRIPTION(\"Xillybus core functions\");\nMODULE_AUTHOR(\"Eli Billauer, Xillybus Ltd.\");\nMODULE_ALIAS(\"xillybus_core\");\nMODULE_LICENSE(\"GPL v2\");\n\n \n#define XILLY_RX_TIMEOUT (10*HZ/1000)\n#define XILLY_TIMEOUT (100*HZ/1000)\n\n#define fpga_msg_ctrl_reg              0x0008\n#define fpga_dma_control_reg           0x0020\n#define fpga_dma_bufno_reg             0x0024\n#define fpga_dma_bufaddr_lowaddr_reg   0x0028\n#define fpga_dma_bufaddr_highaddr_reg  0x002c\n#define fpga_buf_ctrl_reg              0x0030\n#define fpga_buf_offset_reg            0x0034\n#define fpga_endian_reg                0x0040\n\n#define XILLYMSG_OPCODE_RELEASEBUF 1\n#define XILLYMSG_OPCODE_QUIESCEACK 2\n#define XILLYMSG_OPCODE_FIFOEOF 3\n#define XILLYMSG_OPCODE_FATAL_ERROR 4\n#define XILLYMSG_OPCODE_NONEMPTY 5\n\nstatic const char xillyname[] = \"xillybus\";\n\nstatic struct workqueue_struct *xillybus_wq;\n\n \n\nstatic void malformed_message(struct xilly_endpoint *endpoint, u32 *buf)\n{\n\tint opcode;\n\tint msg_channel, msg_bufno, msg_data, msg_dir;\n\n\topcode = (buf[0] >> 24) & 0xff;\n\tmsg_dir = buf[0] & 1;\n\tmsg_channel = (buf[0] >> 1) & 0x7ff;\n\tmsg_bufno = (buf[0] >> 12) & 0x3ff;\n\tmsg_data = buf[1] & 0xfffffff;\n\n\tdev_warn(endpoint->dev,\n\t\t \"Malformed message (skipping): opcode=%d, channel=%03x, dir=%d, bufno=%03x, data=%07x\\n\",\n\t\t opcode, msg_channel, msg_dir, msg_bufno, msg_data);\n}\n\n \n\nirqreturn_t xillybus_isr(int irq, void *data)\n{\n\tstruct xilly_endpoint *ep = data;\n\tu32 *buf;\n\tunsigned int buf_size;\n\tint i;\n\tint opcode;\n\tunsigned int msg_channel, msg_bufno, msg_data, msg_dir;\n\tstruct xilly_channel *channel;\n\n\tbuf = ep->msgbuf_addr;\n\tbuf_size = ep->msg_buf_size/sizeof(u32);\n\n\tdma_sync_single_for_cpu(ep->dev, ep->msgbuf_dma_addr,\n\t\t\t\tep->msg_buf_size, DMA_FROM_DEVICE);\n\n\tfor (i = 0; i < buf_size; i += 2) {\n\t\tif (((buf[i+1] >> 28) & 0xf) != ep->msg_counter) {\n\t\t\tmalformed_message(ep, &buf[i]);\n\t\t\tdev_warn(ep->dev,\n\t\t\t\t \"Sending a NACK on counter %x (instead of %x) on entry %d\\n\",\n\t\t\t\t ((buf[i+1] >> 28) & 0xf),\n\t\t\t\t ep->msg_counter,\n\t\t\t\t i/2);\n\n\t\t\tif (++ep->failed_messages > 10) {\n\t\t\t\tdev_err(ep->dev,\n\t\t\t\t\t\"Lost sync with interrupt messages. Stopping.\\n\");\n\t\t\t} else {\n\t\t\t\tdma_sync_single_for_device(ep->dev,\n\t\t\t\t\t\t\t   ep->msgbuf_dma_addr,\n\t\t\t\t\t\t\t   ep->msg_buf_size,\n\t\t\t\t\t\t\t   DMA_FROM_DEVICE);\n\n\t\t\t\tiowrite32(0x01,   \n\t\t\t\t\t  ep->registers + fpga_msg_ctrl_reg);\n\t\t\t}\n\t\t\treturn IRQ_HANDLED;\n\t\t} else if (buf[i] & (1 << 22))  \n\t\t\tbreak;\n\t}\n\n\tif (i >= buf_size) {\n\t\tdev_err(ep->dev, \"Bad interrupt message. Stopping.\\n\");\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tbuf_size = i + 2;\n\n\tfor (i = 0; i < buf_size; i += 2) {  \n\t\topcode = (buf[i] >> 24) & 0xff;\n\n\t\tmsg_dir = buf[i] & 1;\n\t\tmsg_channel = (buf[i] >> 1) & 0x7ff;\n\t\tmsg_bufno = (buf[i] >> 12) & 0x3ff;\n\t\tmsg_data = buf[i+1] & 0xfffffff;\n\n\t\tswitch (opcode) {\n\t\tcase XILLYMSG_OPCODE_RELEASEBUF:\n\t\t\tif ((msg_channel > ep->num_channels) ||\n\t\t\t    (msg_channel == 0)) {\n\t\t\t\tmalformed_message(ep, &buf[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchannel = ep->channels[msg_channel];\n\n\t\t\tif (msg_dir) {  \n\t\t\t\tif (msg_bufno >= channel->num_wr_buffers) {\n\t\t\t\t\tmalformed_message(ep, &buf[i]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tspin_lock(&channel->wr_spinlock);\n\t\t\t\tchannel->wr_buffers[msg_bufno]->end_offset =\n\t\t\t\t\tmsg_data;\n\t\t\t\tchannel->wr_fpga_buf_idx = msg_bufno;\n\t\t\t\tchannel->wr_empty = 0;\n\t\t\t\tchannel->wr_sleepy = 0;\n\t\t\t\tspin_unlock(&channel->wr_spinlock);\n\n\t\t\t\twake_up_interruptible(&channel->wr_wait);\n\n\t\t\t} else {\n\t\t\t\t \n\n\t\t\t\tif (msg_bufno >= channel->num_rd_buffers) {\n\t\t\t\t\tmalformed_message(ep, &buf[i]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tspin_lock(&channel->rd_spinlock);\n\t\t\t\tchannel->rd_fpga_buf_idx = msg_bufno;\n\t\t\t\tchannel->rd_full = 0;\n\t\t\t\tspin_unlock(&channel->rd_spinlock);\n\n\t\t\t\twake_up_interruptible(&channel->rd_wait);\n\t\t\t\tif (!channel->rd_synchronous)\n\t\t\t\t\tqueue_delayed_work(\n\t\t\t\t\t\txillybus_wq,\n\t\t\t\t\t\t&channel->rd_workitem,\n\t\t\t\t\t\tXILLY_RX_TIMEOUT);\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase XILLYMSG_OPCODE_NONEMPTY:\n\t\t\tif ((msg_channel > ep->num_channels) ||\n\t\t\t    (msg_channel == 0) || (!msg_dir) ||\n\t\t\t    !ep->channels[msg_channel]->wr_supports_nonempty) {\n\t\t\t\tmalformed_message(ep, &buf[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchannel = ep->channels[msg_channel];\n\n\t\t\tif (msg_bufno >= channel->num_wr_buffers) {\n\t\t\t\tmalformed_message(ep, &buf[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tspin_lock(&channel->wr_spinlock);\n\t\t\tif (msg_bufno == channel->wr_host_buf_idx)\n\t\t\t\tchannel->wr_ready = 1;\n\t\t\tspin_unlock(&channel->wr_spinlock);\n\n\t\t\twake_up_interruptible(&channel->wr_ready_wait);\n\n\t\t\tbreak;\n\t\tcase XILLYMSG_OPCODE_QUIESCEACK:\n\t\t\tep->idtlen = msg_data;\n\t\t\twake_up_interruptible(&ep->ep_wait);\n\n\t\t\tbreak;\n\t\tcase XILLYMSG_OPCODE_FIFOEOF:\n\t\t\tif ((msg_channel > ep->num_channels) ||\n\t\t\t    (msg_channel == 0) || (!msg_dir) ||\n\t\t\t    !ep->channels[msg_channel]->num_wr_buffers) {\n\t\t\t\tmalformed_message(ep, &buf[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tchannel = ep->channels[msg_channel];\n\t\t\tspin_lock(&channel->wr_spinlock);\n\t\t\tchannel->wr_eof = msg_bufno;\n\t\t\tchannel->wr_sleepy = 0;\n\n\t\t\tchannel->wr_hangup = channel->wr_empty &&\n\t\t\t\t(channel->wr_host_buf_idx == msg_bufno);\n\n\t\t\tspin_unlock(&channel->wr_spinlock);\n\n\t\t\twake_up_interruptible(&channel->wr_wait);\n\n\t\t\tbreak;\n\t\tcase XILLYMSG_OPCODE_FATAL_ERROR:\n\t\t\tep->fatal_error = 1;\n\t\t\twake_up_interruptible(&ep->ep_wait);  \n\t\t\tdev_err(ep->dev,\n\t\t\t\t\"FPGA reported a fatal error. This means that the low-level communication with the device has failed. This hardware problem is most likely unrelated to Xillybus (neither kernel module nor FPGA core), but reports are still welcome. All I/O is aborted.\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmalformed_message(ep, &buf[i]);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdma_sync_single_for_device(ep->dev, ep->msgbuf_dma_addr,\n\t\t\t\t   ep->msg_buf_size, DMA_FROM_DEVICE);\n\n\tep->msg_counter = (ep->msg_counter + 1) & 0xf;\n\tep->failed_messages = 0;\n\tiowrite32(0x03, ep->registers + fpga_msg_ctrl_reg);  \n\n\treturn IRQ_HANDLED;\n}\nEXPORT_SYMBOL(xillybus_isr);\n\n \n\nstatic void xillybus_autoflush(struct work_struct *work);\n\nstruct xilly_alloc_state {\n\tvoid *salami;\n\tint left_of_salami;\n\tint nbuffer;\n\tenum dma_data_direction direction;\n\tu32 regdirection;\n};\n\nstatic void xilly_unmap(void *ptr)\n{\n\tstruct xilly_mapping *data = ptr;\n\n\tdma_unmap_single(data->device, data->dma_addr,\n\t\t\t data->size, data->direction);\n\n\tkfree(ptr);\n}\n\nstatic int xilly_map_single(struct xilly_endpoint *ep,\n\t\t\t    void *ptr,\n\t\t\t    size_t size,\n\t\t\t    int direction,\n\t\t\t    dma_addr_t *ret_dma_handle\n\t)\n{\n\tdma_addr_t addr;\n\tstruct xilly_mapping *this;\n\n\tthis = kzalloc(sizeof(*this), GFP_KERNEL);\n\tif (!this)\n\t\treturn -ENOMEM;\n\n\taddr = dma_map_single(ep->dev, ptr, size, direction);\n\n\tif (dma_mapping_error(ep->dev, addr)) {\n\t\tkfree(this);\n\t\treturn -ENODEV;\n\t}\n\n\tthis->device = ep->dev;\n\tthis->dma_addr = addr;\n\tthis->size = size;\n\tthis->direction = direction;\n\n\t*ret_dma_handle = addr;\n\n\treturn devm_add_action_or_reset(ep->dev, xilly_unmap, this);\n}\n\nstatic int xilly_get_dma_buffers(struct xilly_endpoint *ep,\n\t\t\t\t struct xilly_alloc_state *s,\n\t\t\t\t struct xilly_buffer **buffers,\n\t\t\t\t int bufnum, int bytebufsize)\n{\n\tint i, rc;\n\tdma_addr_t dma_addr;\n\tstruct device *dev = ep->dev;\n\tstruct xilly_buffer *this_buffer = NULL;  \n\n\tif (buffers) {  \n\t\tthis_buffer = devm_kcalloc(dev, bufnum,\n\t\t\t\t\t   sizeof(struct xilly_buffer),\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!this_buffer)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < bufnum; i++) {\n\t\t \n\n\t\tif ((s->left_of_salami < bytebufsize) &&\n\t\t    (s->left_of_salami > 0)) {\n\t\t\tdev_err(ep->dev,\n\t\t\t\t\"Corrupt buffer allocation in IDT. Aborting.\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tif (s->left_of_salami == 0) {\n\t\t\tint allocorder, allocsize;\n\n\t\t\tallocsize = PAGE_SIZE;\n\t\t\tallocorder = 0;\n\t\t\twhile (bytebufsize > allocsize) {\n\t\t\t\tallocsize *= 2;\n\t\t\t\tallocorder++;\n\t\t\t}\n\n\t\t\ts->salami = (void *) devm_get_free_pages(\n\t\t\t\tdev,\n\t\t\t\tGFP_KERNEL | __GFP_DMA32 | __GFP_ZERO,\n\t\t\t\tallocorder);\n\t\t\tif (!s->salami)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\ts->left_of_salami = allocsize;\n\t\t}\n\n\t\trc = xilly_map_single(ep, s->salami,\n\t\t\t\t      bytebufsize, s->direction,\n\t\t\t\t      &dma_addr);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tiowrite32((u32) (dma_addr & 0xffffffff),\n\t\t\t  ep->registers + fpga_dma_bufaddr_lowaddr_reg);\n\t\tiowrite32(((u32) ((((u64) dma_addr) >> 32) & 0xffffffff)),\n\t\t\t  ep->registers + fpga_dma_bufaddr_highaddr_reg);\n\n\t\tif (buffers) {  \n\t\t\tthis_buffer->addr = s->salami;\n\t\t\tthis_buffer->dma_addr = dma_addr;\n\t\t\tbuffers[i] = this_buffer++;\n\n\t\t\tiowrite32(s->regdirection | s->nbuffer++,\n\t\t\t\t  ep->registers + fpga_dma_bufno_reg);\n\t\t} else {\n\t\t\tep->msgbuf_addr = s->salami;\n\t\t\tep->msgbuf_dma_addr = dma_addr;\n\t\t\tep->msg_buf_size = bytebufsize;\n\n\t\t\tiowrite32(s->regdirection,\n\t\t\t\t  ep->registers + fpga_dma_bufno_reg);\n\t\t}\n\n\t\ts->left_of_salami -= bytebufsize;\n\t\ts->salami += bytebufsize;\n\t}\n\treturn 0;\n}\n\nstatic int xilly_setupchannels(struct xilly_endpoint *ep,\n\t\t\t       unsigned char *chandesc,\n\t\t\t       int entries)\n{\n\tstruct device *dev = ep->dev;\n\tint i, entry, rc;\n\tstruct xilly_channel *channel;\n\tint channelnum, bufnum, bufsize, format, is_writebuf;\n\tint bytebufsize;\n\tint synchronous, allowpartial, exclusive_open, seekable;\n\tint supports_nonempty;\n\tint msg_buf_done = 0;\n\n\tstruct xilly_alloc_state rd_alloc = {\n\t\t.salami = NULL,\n\t\t.left_of_salami = 0,\n\t\t.nbuffer = 1,\n\t\t.direction = DMA_TO_DEVICE,\n\t\t.regdirection = 0,\n\t};\n\n\tstruct xilly_alloc_state wr_alloc = {\n\t\t.salami = NULL,\n\t\t.left_of_salami = 0,\n\t\t.nbuffer = 1,\n\t\t.direction = DMA_FROM_DEVICE,\n\t\t.regdirection = 0x80000000,\n\t};\n\n\tchannel = devm_kcalloc(dev, ep->num_channels,\n\t\t\t       sizeof(struct xilly_channel), GFP_KERNEL);\n\tif (!channel)\n\t\treturn -ENOMEM;\n\n\tep->channels = devm_kcalloc(dev, ep->num_channels + 1,\n\t\t\t\t    sizeof(struct xilly_channel *),\n\t\t\t\t    GFP_KERNEL);\n\tif (!ep->channels)\n\t\treturn -ENOMEM;\n\n\tep->channels[0] = NULL;  \n\n\t \n\n\tfor (i = 1; i <= ep->num_channels; i++) {\n\t\tchannel->wr_buffers = NULL;\n\t\tchannel->rd_buffers = NULL;\n\t\tchannel->num_wr_buffers = 0;\n\t\tchannel->num_rd_buffers = 0;\n\t\tchannel->wr_fpga_buf_idx = -1;\n\t\tchannel->wr_host_buf_idx = 0;\n\t\tchannel->wr_host_buf_pos = 0;\n\t\tchannel->wr_empty = 1;\n\t\tchannel->wr_ready = 0;\n\t\tchannel->wr_sleepy = 1;\n\t\tchannel->rd_fpga_buf_idx = 0;\n\t\tchannel->rd_host_buf_idx = 0;\n\t\tchannel->rd_host_buf_pos = 0;\n\t\tchannel->rd_full = 0;\n\t\tchannel->wr_ref_count = 0;\n\t\tchannel->rd_ref_count = 0;\n\n\t\tspin_lock_init(&channel->wr_spinlock);\n\t\tspin_lock_init(&channel->rd_spinlock);\n\t\tmutex_init(&channel->wr_mutex);\n\t\tmutex_init(&channel->rd_mutex);\n\t\tinit_waitqueue_head(&channel->rd_wait);\n\t\tinit_waitqueue_head(&channel->wr_wait);\n\t\tinit_waitqueue_head(&channel->wr_ready_wait);\n\n\t\tINIT_DELAYED_WORK(&channel->rd_workitem, xillybus_autoflush);\n\n\t\tchannel->endpoint = ep;\n\t\tchannel->chan_num = i;\n\n\t\tchannel->log2_element_size = 0;\n\n\t\tep->channels[i] = channel++;\n\t}\n\n\tfor (entry = 0; entry < entries; entry++, chandesc += 4) {\n\t\tstruct xilly_buffer **buffers = NULL;\n\n\t\tis_writebuf = chandesc[0] & 0x01;\n\t\tchannelnum = (chandesc[0] >> 1) | ((chandesc[1] & 0x0f) << 7);\n\t\tformat = (chandesc[1] >> 4) & 0x03;\n\t\tallowpartial = (chandesc[1] >> 6) & 0x01;\n\t\tsynchronous = (chandesc[1] >> 7) & 0x01;\n\t\tbufsize = 1 << (chandesc[2] & 0x1f);\n\t\tbufnum = 1 << (chandesc[3] & 0x0f);\n\t\texclusive_open = (chandesc[2] >> 7) & 0x01;\n\t\tseekable = (chandesc[2] >> 6) & 0x01;\n\t\tsupports_nonempty = (chandesc[2] >> 5) & 0x01;\n\n\t\tif ((channelnum > ep->num_channels) ||\n\t\t    ((channelnum == 0) && !is_writebuf)) {\n\t\t\tdev_err(ep->dev,\n\t\t\t\t\"IDT requests channel out of range. Aborting.\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tchannel = ep->channels[channelnum];  \n\n\t\tif (!is_writebuf || channelnum > 0) {\n\t\t\tchannel->log2_element_size = ((format > 2) ?\n\t\t\t\t\t\t      2 : format);\n\n\t\t\tbytebufsize = bufsize *\n\t\t\t\t(1 << channel->log2_element_size);\n\n\t\t\tbuffers = devm_kcalloc(dev, bufnum,\n\t\t\t\t\t       sizeof(struct xilly_buffer *),\n\t\t\t\t\t       GFP_KERNEL);\n\t\t\tif (!buffers)\n\t\t\t\treturn -ENOMEM;\n\t\t} else {\n\t\t\tbytebufsize = bufsize << 2;\n\t\t}\n\n\t\tif (!is_writebuf) {\n\t\t\tchannel->num_rd_buffers = bufnum;\n\t\t\tchannel->rd_buf_size = bytebufsize;\n\t\t\tchannel->rd_allow_partial = allowpartial;\n\t\t\tchannel->rd_synchronous = synchronous;\n\t\t\tchannel->rd_exclusive_open = exclusive_open;\n\t\t\tchannel->seekable = seekable;\n\n\t\t\tchannel->rd_buffers = buffers;\n\t\t\trc = xilly_get_dma_buffers(ep, &rd_alloc, buffers,\n\t\t\t\t\t\t   bufnum, bytebufsize);\n\t\t} else if (channelnum > 0) {\n\t\t\tchannel->num_wr_buffers = bufnum;\n\t\t\tchannel->wr_buf_size = bytebufsize;\n\n\t\t\tchannel->seekable = seekable;\n\t\t\tchannel->wr_supports_nonempty = supports_nonempty;\n\n\t\t\tchannel->wr_allow_partial = allowpartial;\n\t\t\tchannel->wr_synchronous = synchronous;\n\t\t\tchannel->wr_exclusive_open = exclusive_open;\n\n\t\t\tchannel->wr_buffers = buffers;\n\t\t\trc = xilly_get_dma_buffers(ep, &wr_alloc, buffers,\n\t\t\t\t\t\t   bufnum, bytebufsize);\n\t\t} else {\n\t\t\trc = xilly_get_dma_buffers(ep, &wr_alloc, NULL,\n\t\t\t\t\t\t   bufnum, bytebufsize);\n\t\t\tmsg_buf_done++;\n\t\t}\n\n\t\tif (rc)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (!msg_buf_done) {\n\t\tdev_err(ep->dev,\n\t\t\t\"Corrupt IDT: No message buffer. Aborting.\\n\");\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\nstatic int xilly_scan_idt(struct xilly_endpoint *endpoint,\n\t\t\t  struct xilly_idt_handle *idt_handle)\n{\n\tint count = 0;\n\tunsigned char *idt = endpoint->channels[1]->wr_buffers[0]->addr;\n\tunsigned char *end_of_idt = idt + endpoint->idtlen - 4;\n\tunsigned char *scan;\n\tint len;\n\n\tscan = idt + 1;\n\tidt_handle->names = scan;\n\n\twhile ((scan <= end_of_idt) && *scan) {\n\t\twhile ((scan <= end_of_idt) && *scan++)\n\t\t\t ;\n\t\tcount++;\n\t}\n\n\tidt_handle->names_len = scan - idt_handle->names;\n\n\tscan++;\n\n\tif (scan > end_of_idt) {\n\t\tdev_err(endpoint->dev,\n\t\t\t\"IDT device name list overflow. Aborting.\\n\");\n\t\treturn -ENODEV;\n\t}\n\tidt_handle->chandesc = scan;\n\n\tlen = endpoint->idtlen - (3 + ((int) (scan - idt)));\n\n\tif (len & 0x03) {\n\t\tdev_err(endpoint->dev,\n\t\t\t\"Corrupt IDT device name list. Aborting.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tidt_handle->entries = len >> 2;\n\tendpoint->num_channels = count;\n\n\treturn 0;\n}\n\nstatic int xilly_obtain_idt(struct xilly_endpoint *endpoint)\n{\n\tstruct xilly_channel *channel;\n\tunsigned char *version;\n\tlong t;\n\n\tchannel = endpoint->channels[1];  \n\n\tchannel->wr_sleepy = 1;\n\n\tiowrite32(1 |\n\t\t  (3 << 24),  \n\t\t  endpoint->registers + fpga_buf_ctrl_reg);\n\n\tt = wait_event_interruptible_timeout(channel->wr_wait,\n\t\t\t\t\t     (!channel->wr_sleepy),\n\t\t\t\t\t     XILLY_TIMEOUT);\n\n\tif (t <= 0) {\n\t\tdev_err(endpoint->dev, \"Failed to obtain IDT. Aborting.\\n\");\n\n\t\tif (endpoint->fatal_error)\n\t\t\treturn -EIO;\n\n\t\treturn -ENODEV;\n\t}\n\n\tdma_sync_single_for_cpu(channel->endpoint->dev,\n\t\t\t\tchannel->wr_buffers[0]->dma_addr,\n\t\t\t\tchannel->wr_buf_size,\n\t\t\t\tDMA_FROM_DEVICE);\n\n\tif (channel->wr_buffers[0]->end_offset != endpoint->idtlen) {\n\t\tdev_err(endpoint->dev,\n\t\t\t\"IDT length mismatch (%d != %d). Aborting.\\n\",\n\t\t\tchannel->wr_buffers[0]->end_offset, endpoint->idtlen);\n\t\treturn -ENODEV;\n\t}\n\n\tif (crc32_le(~0, channel->wr_buffers[0]->addr,\n\t\t     endpoint->idtlen+1) != 0) {\n\t\tdev_err(endpoint->dev, \"IDT failed CRC check. Aborting.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tversion = channel->wr_buffers[0]->addr;\n\n\t \n\tif (*version > 0x82) {\n\t\tdev_err(endpoint->dev,\n\t\t\t\"No support for IDT version 0x%02x. Maybe the xillybus driver needs an upgrade. Aborting.\\n\",\n\t\t\t*version);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t xillybus_read(struct file *filp, char __user *userbuf,\n\t\t\t     size_t count, loff_t *f_pos)\n{\n\tssize_t rc;\n\tunsigned long flags;\n\tint bytes_done = 0;\n\tint no_time_left = 0;\n\tlong deadline, left_to_sleep;\n\tstruct xilly_channel *channel = filp->private_data;\n\n\tint empty, reached_eof, exhausted, ready;\n\t \n\n\tint howmany = 0, bufpos = 0, bufidx = 0, bufferdone = 0;\n\tint waiting_bufidx;\n\n\tif (channel->endpoint->fatal_error)\n\t\treturn -EIO;\n\n\tdeadline = jiffies + 1 + XILLY_RX_TIMEOUT;\n\n\trc = mutex_lock_interruptible(&channel->wr_mutex);\n\tif (rc)\n\t\treturn rc;\n\n\twhile (1) {  \n\t\tint bytes_to_do = count - bytes_done;\n\n\t\tspin_lock_irqsave(&channel->wr_spinlock, flags);\n\n\t\tempty = channel->wr_empty;\n\t\tready = !empty || channel->wr_ready;\n\n\t\tif (!empty) {\n\t\t\tbufidx = channel->wr_host_buf_idx;\n\t\t\tbufpos = channel->wr_host_buf_pos;\n\t\t\thowmany = ((channel->wr_buffers[bufidx]->end_offset\n\t\t\t\t    + 1) << channel->log2_element_size)\n\t\t\t\t- bufpos;\n\n\t\t\t \n\t\t\tif (howmany > bytes_to_do) {\n\t\t\t\tbufferdone = 0;\n\n\t\t\t\thowmany = bytes_to_do;\n\t\t\t\tchannel->wr_host_buf_pos += howmany;\n\t\t\t} else {\n\t\t\t\tbufferdone = 1;\n\n\t\t\t\tchannel->wr_host_buf_pos = 0;\n\n\t\t\t\tif (bufidx == channel->wr_fpga_buf_idx) {\n\t\t\t\t\tchannel->wr_empty = 1;\n\t\t\t\t\tchannel->wr_sleepy = 1;\n\t\t\t\t\tchannel->wr_ready = 0;\n\t\t\t\t}\n\n\t\t\t\tif (bufidx >= (channel->num_wr_buffers - 1))\n\t\t\t\t\tchannel->wr_host_buf_idx = 0;\n\t\t\t\telse\n\t\t\t\t\tchannel->wr_host_buf_idx++;\n\t\t\t}\n\t\t}\n\n\t\t \n\n\t\treached_eof = channel->wr_empty &&\n\t\t\t(channel->wr_host_buf_idx == channel->wr_eof);\n\t\tchannel->wr_hangup = reached_eof;\n\t\texhausted = channel->wr_empty;\n\t\twaiting_bufidx = channel->wr_host_buf_idx;\n\n\t\tspin_unlock_irqrestore(&channel->wr_spinlock, flags);\n\n\t\tif (!empty) {  \n\n\t\t\tif (bufpos == 0)  \n\t\t\t\tdma_sync_single_for_cpu(channel->endpoint->dev,\n\t\t\t\t\t\t\tchannel->wr_buffers[bufidx]->dma_addr,\n\t\t\t\t\t\t\tchannel->wr_buf_size,\n\t\t\t\t\t\t\tDMA_FROM_DEVICE);\n\n\t\t\tif (copy_to_user(\n\t\t\t\t    userbuf,\n\t\t\t\t    channel->wr_buffers[bufidx]->addr\n\t\t\t\t    + bufpos, howmany))\n\t\t\t\trc = -EFAULT;\n\n\t\t\tuserbuf += howmany;\n\t\t\tbytes_done += howmany;\n\n\t\t\tif (bufferdone) {\n\t\t\t\tdma_sync_single_for_device(channel->endpoint->dev,\n\t\t\t\t\t\t\t   channel->wr_buffers[bufidx]->dma_addr,\n\t\t\t\t\t\t\t   channel->wr_buf_size,\n\t\t\t\t\t\t\t   DMA_FROM_DEVICE);\n\n\t\t\t\t \n\n\t\t\t\tiowrite32(1 | (channel->chan_num << 1) |\n\t\t\t\t\t  (bufidx << 12),\n\t\t\t\t\t  channel->endpoint->registers +\n\t\t\t\t\t  fpga_buf_ctrl_reg);\n\t\t\t}\n\n\t\t\tif (rc) {\n\t\t\t\tmutex_unlock(&channel->wr_mutex);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif ((bytes_done >= count) || reached_eof)\n\t\t\tbreak;\n\n\t\tif (!exhausted)\n\t\t\tcontinue;  \n\n\t\tif ((bytes_done > 0) &&\n\t\t    (no_time_left ||\n\t\t     (channel->wr_synchronous && channel->wr_allow_partial)))\n\t\t\tbreak;\n\n\t\t \n\n\t\tif (!no_time_left && (filp->f_flags & O_NONBLOCK)) {\n\t\t\tif (bytes_done > 0)\n\t\t\t\tbreak;\n\n\t\t\tif (ready)\n\t\t\t\tgoto desperate;\n\n\t\t\trc = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!no_time_left || (bytes_done > 0)) {\n\t\t\t \n\t\t\tint offsetlimit = ((count - bytes_done) - 1) >>\n\t\t\t\tchannel->log2_element_size;\n\t\t\tint buf_elements = channel->wr_buf_size >>\n\t\t\t\tchannel->log2_element_size;\n\n\t\t\t \n\n\t\t\tif (channel->wr_synchronous) {\n\t\t\t\t \n\t\t\t\tif (channel->wr_allow_partial &&\n\t\t\t\t    (offsetlimit >= buf_elements))\n\t\t\t\t\toffsetlimit = buf_elements - 1;\n\n\t\t\t\t \n\t\t\t\tif (!channel->wr_allow_partial &&\n\t\t\t\t    (offsetlimit >=\n\t\t\t\t     (buf_elements * channel->num_wr_buffers)))\n\t\t\t\t\toffsetlimit = buf_elements *\n\t\t\t\t\t\tchannel->num_wr_buffers - 1;\n\t\t\t}\n\n\t\t\t \n\n\t\t\tif (channel->wr_synchronous ||\n\t\t\t    (offsetlimit < (buf_elements - 1))) {\n\t\t\t\tmutex_lock(&channel->endpoint->register_mutex);\n\n\t\t\t\tiowrite32(offsetlimit,\n\t\t\t\t\t  channel->endpoint->registers +\n\t\t\t\t\t  fpga_buf_offset_reg);\n\n\t\t\t\tiowrite32(1 | (channel->chan_num << 1) |\n\t\t\t\t\t  (2 << 24) |   \n\t\t\t\t\t  (waiting_bufidx << 12),\n\t\t\t\t\t  channel->endpoint->registers +\n\t\t\t\t\t  fpga_buf_ctrl_reg);\n\n\t\t\t\tmutex_unlock(&channel->endpoint->\n\t\t\t\t\t     register_mutex);\n\t\t\t}\n\t\t}\n\n\t\t \n\n\t\tif (!channel->wr_allow_partial ||\n\t\t    (no_time_left && (bytes_done == 0))) {\n\t\t\t \n\n\t\t\tdo {\n\t\t\t\tmutex_unlock(&channel->wr_mutex);\n\n\t\t\t\tif (wait_event_interruptible(\n\t\t\t\t\t    channel->wr_wait,\n\t\t\t\t\t    (!channel->wr_sleepy)))\n\t\t\t\t\tgoto interrupted;\n\n\t\t\t\tif (mutex_lock_interruptible(\n\t\t\t\t\t    &channel->wr_mutex))\n\t\t\t\t\tgoto interrupted;\n\t\t\t} while (channel->wr_sleepy);\n\n\t\t\tcontinue;\n\ninterrupted:  \n\t\t\tif (channel->endpoint->fatal_error)\n\t\t\t\treturn -EIO;\n\t\t\tif (bytes_done)\n\t\t\t\treturn bytes_done;\n\t\t\tif (filp->f_flags & O_NONBLOCK)\n\t\t\t\treturn -EAGAIN;  \n\t\t\treturn -EINTR;\n\t\t}\n\n\t\tleft_to_sleep = deadline - ((long) jiffies);\n\n\t\t \n\n\t\tif (left_to_sleep > 0) {\n\t\t\tleft_to_sleep =\n\t\t\t\twait_event_interruptible_timeout(\n\t\t\t\t\tchannel->wr_wait,\n\t\t\t\t\t(!channel->wr_sleepy),\n\t\t\t\t\tleft_to_sleep);\n\n\t\t\tif (left_to_sleep > 0)  \n\t\t\t\tcontinue;\n\n\t\t\tif (left_to_sleep < 0) {  \n\t\t\t\tmutex_unlock(&channel->wr_mutex);\n\t\t\t\tif (channel->endpoint->fatal_error)\n\t\t\t\t\treturn -EIO;\n\t\t\t\tif (bytes_done)\n\t\t\t\t\treturn bytes_done;\n\t\t\t\treturn -EINTR;\n\t\t\t}\n\t\t}\n\ndesperate:\n\t\tno_time_left = 1;  \n\n\t\tif (bytes_done == 0) {\n\t\t\t \n\n\t\t\tiowrite32(1 | (channel->chan_num << 1) |\n\t\t\t\t  (3 << 24) |   \n\t\t\t\t  (waiting_bufidx << 12),\n\t\t\t\t  channel->endpoint->registers +\n\t\t\t\t  fpga_buf_ctrl_reg);\n\t\t}\n\n\t\t \n\t}\n\n\tmutex_unlock(&channel->wr_mutex);\n\n\tif (channel->endpoint->fatal_error)\n\t\treturn -EIO;\n\n\tif (rc)\n\t\treturn rc;\n\n\treturn bytes_done;\n}\n\n \n\nstatic int xillybus_myflush(struct xilly_channel *channel, long timeout)\n{\n\tint rc;\n\tunsigned long flags;\n\n\tint end_offset_plus1;\n\tint bufidx, bufidx_minus1;\n\tint i;\n\tint empty;\n\tint new_rd_host_buf_pos;\n\n\tif (channel->endpoint->fatal_error)\n\t\treturn -EIO;\n\trc = mutex_lock_interruptible(&channel->rd_mutex);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\n\tif (!channel->rd_ref_count)\n\t\tgoto done;\n\n\tbufidx = channel->rd_host_buf_idx;\n\n\tbufidx_minus1 = (bufidx == 0) ?\n\t\tchannel->num_rd_buffers - 1 :\n\t\tbufidx - 1;\n\n\tend_offset_plus1 = channel->rd_host_buf_pos >>\n\t\tchannel->log2_element_size;\n\n\tnew_rd_host_buf_pos = channel->rd_host_buf_pos -\n\t\t(end_offset_plus1 << channel->log2_element_size);\n\n\t \n\tif (end_offset_plus1) {\n\t\tunsigned char *tail = channel->rd_buffers[bufidx]->addr +\n\t\t\t(end_offset_plus1 << channel->log2_element_size);\n\n\t\t \n\t\tfor (i = 0; i < new_rd_host_buf_pos; i++)\n\t\t\tchannel->rd_leftovers[i] = *tail++;\n\n\t\tspin_lock_irqsave(&channel->rd_spinlock, flags);\n\n\t\t \n\n\t\tif ((timeout < 0) &&\n\t\t    (channel->rd_full ||\n\t\t     (bufidx_minus1 != channel->rd_fpga_buf_idx))) {\n\t\t\tspin_unlock_irqrestore(&channel->rd_spinlock, flags);\n\t\t\t \n\t\t\tgoto done;\n\t\t}\n\n\t\t \n\t\tchannel->rd_leftovers[3] = (new_rd_host_buf_pos != 0);\n\n\t\t \n\n\t\tif (bufidx == channel->rd_fpga_buf_idx)\n\t\t\tchannel->rd_full = 1;\n\t\tspin_unlock_irqrestore(&channel->rd_spinlock, flags);\n\n\t\tif (bufidx >= (channel->num_rd_buffers - 1))\n\t\t\tchannel->rd_host_buf_idx = 0;\n\t\telse\n\t\t\tchannel->rd_host_buf_idx++;\n\n\t\tdma_sync_single_for_device(channel->endpoint->dev,\n\t\t\t\t\t   channel->rd_buffers[bufidx]->dma_addr,\n\t\t\t\t\t   channel->rd_buf_size,\n\t\t\t\t\t   DMA_TO_DEVICE);\n\n\t\tmutex_lock(&channel->endpoint->register_mutex);\n\n\t\tiowrite32(end_offset_plus1 - 1,\n\t\t\t  channel->endpoint->registers + fpga_buf_offset_reg);\n\n\t\tiowrite32((channel->chan_num << 1) |  \n\t\t\t  (2 << 24) |   \n\t\t\t  (bufidx << 12),\n\t\t\t  channel->endpoint->registers + fpga_buf_ctrl_reg);\n\n\t\tmutex_unlock(&channel->endpoint->register_mutex);\n\t} else if (bufidx == 0) {\n\t\tbufidx = channel->num_rd_buffers - 1;\n\t} else {\n\t\tbufidx--;\n\t}\n\n\tchannel->rd_host_buf_pos = new_rd_host_buf_pos;\n\n\tif (timeout < 0)\n\t\tgoto done;  \n\n\t \n\n\twhile (1) {  \n\t\tspin_lock_irqsave(&channel->rd_spinlock, flags);\n\n\t\tif (bufidx != channel->rd_fpga_buf_idx)\n\t\t\tchannel->rd_full = 1;  \n\n\t\tempty = !channel->rd_full;\n\n\t\tspin_unlock_irqrestore(&channel->rd_spinlock, flags);\n\n\t\tif (empty)\n\t\t\tbreak;\n\n\t\t \n\t\tif (timeout == 0)\n\t\t\twait_event_interruptible(channel->rd_wait,\n\t\t\t\t\t\t (!channel->rd_full));\n\n\t\telse if (wait_event_interruptible_timeout(\n\t\t\t\t channel->rd_wait,\n\t\t\t\t (!channel->rd_full),\n\t\t\t\t timeout) == 0) {\n\t\t\tdev_warn(channel->endpoint->dev,\n\t\t\t\t \"Timed out while flushing. Output data may be lost.\\n\");\n\n\t\t\trc = -ETIMEDOUT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (channel->rd_full) {\n\t\t\trc = -EINTR;\n\t\t\tbreak;\n\t\t}\n\t}\n\ndone:\n\tmutex_unlock(&channel->rd_mutex);\n\n\tif (channel->endpoint->fatal_error)\n\t\treturn -EIO;\n\n\treturn rc;\n}\n\nstatic int xillybus_flush(struct file *filp, fl_owner_t id)\n{\n\tif (!(filp->f_mode & FMODE_WRITE))\n\t\treturn 0;\n\n\treturn xillybus_myflush(filp->private_data, HZ);  \n}\n\nstatic void xillybus_autoflush(struct work_struct *work)\n{\n\tstruct delayed_work *workitem = container_of(\n\t\twork, struct delayed_work, work);\n\tstruct xilly_channel *channel = container_of(\n\t\tworkitem, struct xilly_channel, rd_workitem);\n\tint rc;\n\n\trc = xillybus_myflush(channel, -1);\n\tif (rc == -EINTR)\n\t\tdev_warn(channel->endpoint->dev,\n\t\t\t \"Autoflush failed because work queue thread got a signal.\\n\");\n\telse if (rc)\n\t\tdev_err(channel->endpoint->dev,\n\t\t\t\"Autoflush failed under weird circumstances.\\n\");\n}\n\nstatic ssize_t xillybus_write(struct file *filp, const char __user *userbuf,\n\t\t\t      size_t count, loff_t *f_pos)\n{\n\tssize_t rc;\n\tunsigned long flags;\n\tint bytes_done = 0;\n\tstruct xilly_channel *channel = filp->private_data;\n\n\tint full, exhausted;\n\t \n\n\tint howmany = 0, bufpos = 0, bufidx = 0, bufferdone = 0;\n\tint end_offset_plus1 = 0;\n\n\tif (channel->endpoint->fatal_error)\n\t\treturn -EIO;\n\n\trc = mutex_lock_interruptible(&channel->rd_mutex);\n\tif (rc)\n\t\treturn rc;\n\n\twhile (1) {\n\t\tint bytes_to_do = count - bytes_done;\n\n\t\tspin_lock_irqsave(&channel->rd_spinlock, flags);\n\n\t\tfull = channel->rd_full;\n\n\t\tif (!full) {\n\t\t\tbufidx = channel->rd_host_buf_idx;\n\t\t\tbufpos = channel->rd_host_buf_pos;\n\t\t\thowmany = channel->rd_buf_size - bufpos;\n\n\t\t\t \n\n\t\t\tif ((howmany > bytes_to_do) &&\n\t\t\t    (count ||\n\t\t\t     ((bufpos >> channel->log2_element_size) == 0))) {\n\t\t\t\tbufferdone = 0;\n\n\t\t\t\thowmany = bytes_to_do;\n\t\t\t\tchannel->rd_host_buf_pos += howmany;\n\t\t\t} else {\n\t\t\t\tbufferdone = 1;\n\n\t\t\t\tif (count) {\n\t\t\t\t\tend_offset_plus1 =\n\t\t\t\t\t\tchannel->rd_buf_size >>\n\t\t\t\t\t\tchannel->log2_element_size;\n\t\t\t\t\tchannel->rd_host_buf_pos = 0;\n\t\t\t\t} else {\n\t\t\t\t\tunsigned char *tail;\n\t\t\t\t\tint i;\n\n\t\t\t\t\thowmany = 0;\n\n\t\t\t\t\tend_offset_plus1 = bufpos >>\n\t\t\t\t\t\tchannel->log2_element_size;\n\n\t\t\t\t\tchannel->rd_host_buf_pos -=\n\t\t\t\t\t\tend_offset_plus1 <<\n\t\t\t\t\t\tchannel->log2_element_size;\n\n\t\t\t\t\ttail = channel->\n\t\t\t\t\t\trd_buffers[bufidx]->addr +\n\t\t\t\t\t\t(end_offset_plus1 <<\n\t\t\t\t\t\t channel->log2_element_size);\n\n\t\t\t\t\tfor (i = 0;\n\t\t\t\t\t     i < channel->rd_host_buf_pos;\n\t\t\t\t\t     i++)\n\t\t\t\t\t\tchannel->rd_leftovers[i] =\n\t\t\t\t\t\t\t*tail++;\n\t\t\t\t}\n\n\t\t\t\tif (bufidx == channel->rd_fpga_buf_idx)\n\t\t\t\t\tchannel->rd_full = 1;\n\n\t\t\t\tif (bufidx >= (channel->num_rd_buffers - 1))\n\t\t\t\t\tchannel->rd_host_buf_idx = 0;\n\t\t\t\telse\n\t\t\t\t\tchannel->rd_host_buf_idx++;\n\t\t\t}\n\t\t}\n\n\t\t \n\n\t\texhausted = channel->rd_full;\n\n\t\tspin_unlock_irqrestore(&channel->rd_spinlock, flags);\n\n\t\tif (!full) {  \n\t\t\tunsigned char *head =\n\t\t\t\tchannel->rd_buffers[bufidx]->addr;\n\t\t\tint i;\n\n\t\t\tif ((bufpos == 0) ||  \n\t\t\t    (channel->rd_leftovers[3] != 0)) {\n\t\t\t\tdma_sync_single_for_cpu(channel->endpoint->dev,\n\t\t\t\t\t\t\tchannel->rd_buffers[bufidx]->dma_addr,\n\t\t\t\t\t\t\tchannel->rd_buf_size,\n\t\t\t\t\t\t\tDMA_TO_DEVICE);\n\n\t\t\t\t \n\t\t\t\tfor (i = 0; i < bufpos; i++)\n\t\t\t\t\t*head++ = channel->rd_leftovers[i];\n\n\t\t\t\tchannel->rd_leftovers[3] = 0;  \n\t\t\t}\n\n\t\t\tif (copy_from_user(\n\t\t\t\t    channel->rd_buffers[bufidx]->addr + bufpos,\n\t\t\t\t    userbuf, howmany))\n\t\t\t\trc = -EFAULT;\n\n\t\t\tuserbuf += howmany;\n\t\t\tbytes_done += howmany;\n\n\t\t\tif (bufferdone) {\n\t\t\t\tdma_sync_single_for_device(channel->endpoint->dev,\n\t\t\t\t\t\t\t   channel->rd_buffers[bufidx]->dma_addr,\n\t\t\t\t\t\t\t   channel->rd_buf_size,\n\t\t\t\t\t\t\t   DMA_TO_DEVICE);\n\n\t\t\t\tmutex_lock(&channel->endpoint->register_mutex);\n\n\t\t\t\tiowrite32(end_offset_plus1 - 1,\n\t\t\t\t\t  channel->endpoint->registers +\n\t\t\t\t\t  fpga_buf_offset_reg);\n\n\t\t\t\tiowrite32((channel->chan_num << 1) |\n\t\t\t\t\t  (2 << 24) |   \n\t\t\t\t\t  (bufidx << 12),\n\t\t\t\t\t  channel->endpoint->registers +\n\t\t\t\t\t  fpga_buf_ctrl_reg);\n\n\t\t\t\tmutex_unlock(&channel->endpoint->\n\t\t\t\t\t     register_mutex);\n\n\t\t\t\tchannel->rd_leftovers[3] =\n\t\t\t\t\t(channel->rd_host_buf_pos != 0);\n\t\t\t}\n\n\t\t\tif (rc) {\n\t\t\t\tmutex_unlock(&channel->rd_mutex);\n\n\t\t\t\tif (channel->endpoint->fatal_error)\n\t\t\t\t\treturn -EIO;\n\n\t\t\t\tif (!channel->rd_synchronous)\n\t\t\t\t\tqueue_delayed_work(\n\t\t\t\t\t\txillybus_wq,\n\t\t\t\t\t\t&channel->rd_workitem,\n\t\t\t\t\t\tXILLY_RX_TIMEOUT);\n\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tif (bytes_done >= count)\n\t\t\tbreak;\n\n\t\tif (!exhausted)\n\t\t\tcontinue;  \n\n\t\tif ((bytes_done > 0) && channel->rd_allow_partial)\n\t\t\tbreak;\n\n\t\t \n\n\t\tif (filp->f_flags & O_NONBLOCK) {\n\t\t\trc = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (wait_event_interruptible(channel->rd_wait,\n\t\t\t\t\t     (!channel->rd_full))) {\n\t\t\tmutex_unlock(&channel->rd_mutex);\n\n\t\t\tif (channel->endpoint->fatal_error)\n\t\t\t\treturn -EIO;\n\n\t\t\tif (bytes_done)\n\t\t\t\treturn bytes_done;\n\t\t\treturn -EINTR;\n\t\t}\n\t}\n\n\tmutex_unlock(&channel->rd_mutex);\n\n\tif (!channel->rd_synchronous)\n\t\tqueue_delayed_work(xillybus_wq,\n\t\t\t\t   &channel->rd_workitem,\n\t\t\t\t   XILLY_RX_TIMEOUT);\n\n\tif (channel->endpoint->fatal_error)\n\t\treturn -EIO;\n\n\tif (rc)\n\t\treturn rc;\n\n\tif ((channel->rd_synchronous) && (bytes_done > 0)) {\n\t\trc = xillybus_myflush(filp->private_data, 0);  \n\n\t\tif (rc && (rc != -EINTR))\n\t\t\treturn rc;\n\t}\n\n\treturn bytes_done;\n}\n\nstatic int xillybus_open(struct inode *inode, struct file *filp)\n{\n\tint rc;\n\tunsigned long flags;\n\tstruct xilly_endpoint *endpoint;\n\tstruct xilly_channel *channel;\n\tint index;\n\n\trc = xillybus_find_inode(inode, (void **)&endpoint, &index);\n\tif (rc)\n\t\treturn rc;\n\n\tif (endpoint->fatal_error)\n\t\treturn -EIO;\n\n\tchannel = endpoint->channels[1 + index];\n\tfilp->private_data = channel;\n\n\t \n\n\tif ((filp->f_mode & FMODE_READ) && (!channel->num_wr_buffers))\n\t\treturn -ENODEV;\n\n\tif ((filp->f_mode & FMODE_WRITE) && (!channel->num_rd_buffers))\n\t\treturn -ENODEV;\n\n\tif ((filp->f_mode & FMODE_READ) && (filp->f_flags & O_NONBLOCK) &&\n\t    (channel->wr_synchronous || !channel->wr_allow_partial ||\n\t     !channel->wr_supports_nonempty)) {\n\t\tdev_err(endpoint->dev,\n\t\t\t\"open() failed: O_NONBLOCK not allowed for read on this device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif ((filp->f_mode & FMODE_WRITE) && (filp->f_flags & O_NONBLOCK) &&\n\t    (channel->rd_synchronous || !channel->rd_allow_partial)) {\n\t\tdev_err(endpoint->dev,\n\t\t\t\"open() failed: O_NONBLOCK not allowed for write on this device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\n\tif (filp->f_mode & FMODE_READ) {\n\t\trc = mutex_lock_interruptible(&channel->wr_mutex);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tif (filp->f_mode & FMODE_WRITE) {\n\t\trc = mutex_lock_interruptible(&channel->rd_mutex);\n\t\tif (rc)\n\t\t\tgoto unlock_wr;\n\t}\n\n\tif ((filp->f_mode & FMODE_READ) &&\n\t    (channel->wr_ref_count != 0) &&\n\t    (channel->wr_exclusive_open)) {\n\t\trc = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\tif ((filp->f_mode & FMODE_WRITE) &&\n\t    (channel->rd_ref_count != 0) &&\n\t    (channel->rd_exclusive_open)) {\n\t\trc = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\tif (filp->f_mode & FMODE_READ) {\n\t\tif (channel->wr_ref_count == 0) {  \n\t\t\t \n\t\t\tspin_lock_irqsave(&channel->wr_spinlock, flags);\n\t\t\tchannel->wr_host_buf_idx = 0;\n\t\t\tchannel->wr_host_buf_pos = 0;\n\t\t\tchannel->wr_fpga_buf_idx = -1;\n\t\t\tchannel->wr_empty = 1;\n\t\t\tchannel->wr_ready = 0;\n\t\t\tchannel->wr_sleepy = 1;\n\t\t\tchannel->wr_eof = -1;\n\t\t\tchannel->wr_hangup = 0;\n\n\t\t\tspin_unlock_irqrestore(&channel->wr_spinlock, flags);\n\n\t\t\tiowrite32(1 | (channel->chan_num << 1) |\n\t\t\t\t  (4 << 24) |   \n\t\t\t\t  ((channel->wr_synchronous & 1) << 23),\n\t\t\t\t  channel->endpoint->registers +\n\t\t\t\t  fpga_buf_ctrl_reg);\n\t\t}\n\n\t\tchannel->wr_ref_count++;\n\t}\n\n\tif (filp->f_mode & FMODE_WRITE) {\n\t\tif (channel->rd_ref_count == 0) {  \n\t\t\t \n\t\t\tspin_lock_irqsave(&channel->rd_spinlock, flags);\n\t\t\tchannel->rd_host_buf_idx = 0;\n\t\t\tchannel->rd_host_buf_pos = 0;\n\t\t\tchannel->rd_leftovers[3] = 0;  \n\t\t\tchannel->rd_fpga_buf_idx = channel->num_rd_buffers - 1;\n\t\t\tchannel->rd_full = 0;\n\n\t\t\tspin_unlock_irqrestore(&channel->rd_spinlock, flags);\n\n\t\t\tiowrite32((channel->chan_num << 1) |\n\t\t\t\t  (4 << 24),    \n\t\t\t\t  channel->endpoint->registers +\n\t\t\t\t  fpga_buf_ctrl_reg);\n\t\t}\n\n\t\tchannel->rd_ref_count++;\n\t}\n\nunlock:\n\tif (filp->f_mode & FMODE_WRITE)\n\t\tmutex_unlock(&channel->rd_mutex);\nunlock_wr:\n\tif (filp->f_mode & FMODE_READ)\n\t\tmutex_unlock(&channel->wr_mutex);\n\n\tif (!rc && (!channel->seekable))\n\t\treturn nonseekable_open(inode, filp);\n\n\treturn rc;\n}\n\nstatic int xillybus_release(struct inode *inode, struct file *filp)\n{\n\tunsigned long flags;\n\tstruct xilly_channel *channel = filp->private_data;\n\n\tint buf_idx;\n\tint eof;\n\n\tif (channel->endpoint->fatal_error)\n\t\treturn -EIO;\n\n\tif (filp->f_mode & FMODE_WRITE) {\n\t\tmutex_lock(&channel->rd_mutex);\n\n\t\tchannel->rd_ref_count--;\n\n\t\tif (channel->rd_ref_count == 0) {\n\t\t\t \n\n\t\t\tiowrite32((channel->chan_num << 1) |  \n\t\t\t\t  (5 << 24),   \n\t\t\t\t  channel->endpoint->registers +\n\t\t\t\t  fpga_buf_ctrl_reg);\n\t\t}\n\t\tmutex_unlock(&channel->rd_mutex);\n\t}\n\n\tif (filp->f_mode & FMODE_READ) {\n\t\tmutex_lock(&channel->wr_mutex);\n\n\t\tchannel->wr_ref_count--;\n\n\t\tif (channel->wr_ref_count == 0) {\n\t\t\tiowrite32(1 | (channel->chan_num << 1) |\n\t\t\t\t  (5 << 24),   \n\t\t\t\t  channel->endpoint->registers +\n\t\t\t\t  fpga_buf_ctrl_reg);\n\n\t\t\t \n\n\t\t\twhile (1) {\n\t\t\t\tspin_lock_irqsave(&channel->wr_spinlock,\n\t\t\t\t\t\t  flags);\n\t\t\t\tbuf_idx = channel->wr_fpga_buf_idx;\n\t\t\t\teof = channel->wr_eof;\n\t\t\t\tchannel->wr_sleepy = 1;\n\t\t\t\tspin_unlock_irqrestore(&channel->wr_spinlock,\n\t\t\t\t\t\t       flags);\n\n\t\t\t\t \n\n\t\t\t\tbuf_idx++;\n\t\t\t\tif (buf_idx == channel->num_wr_buffers)\n\t\t\t\t\tbuf_idx = 0;\n\n\t\t\t\tif (buf_idx == eof)\n\t\t\t\t\tbreak;\n\n\t\t\t\t \n\n\t\t\t\tif (wait_event_interruptible(\n\t\t\t\t\t    channel->wr_wait,\n\t\t\t\t\t    (!channel->wr_sleepy)))\n\t\t\t\t\tmsleep(100);\n\n\t\t\t\tif (channel->wr_sleepy) {\n\t\t\t\t\tmutex_unlock(&channel->wr_mutex);\n\t\t\t\t\tdev_warn(channel->endpoint->dev,\n\t\t\t\t\t\t \"Hardware failed to respond to close command, therefore left in messy state.\\n\");\n\t\t\t\t\treturn -EINTR;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmutex_unlock(&channel->wr_mutex);\n\t}\n\n\treturn 0;\n}\n\nstatic loff_t xillybus_llseek(struct file *filp, loff_t offset, int whence)\n{\n\tstruct xilly_channel *channel = filp->private_data;\n\tloff_t pos = filp->f_pos;\n\tint rc = 0;\n\n\t \n\n\tif (channel->endpoint->fatal_error)\n\t\treturn -EIO;\n\n\tmutex_lock(&channel->wr_mutex);\n\tmutex_lock(&channel->rd_mutex);\n\n\tswitch (whence) {\n\tcase SEEK_SET:\n\t\tpos = offset;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\tpos += offset;\n\t\tbreak;\n\tcase SEEK_END:\n\t\tpos = offset;  \n\t\tbreak;\n\tdefault:\n\t\trc = -EINVAL;\n\t\tgoto end;\n\t}\n\n\t \n\tif (pos & ((1 << channel->log2_element_size) - 1)) {\n\t\trc = -EINVAL;\n\t\tgoto end;\n\t}\n\n\tmutex_lock(&channel->endpoint->register_mutex);\n\n\tiowrite32(pos >> channel->log2_element_size,\n\t\t  channel->endpoint->registers + fpga_buf_offset_reg);\n\n\tiowrite32((channel->chan_num << 1) |\n\t\t  (6 << 24),   \n\t\t  channel->endpoint->registers + fpga_buf_ctrl_reg);\n\n\tmutex_unlock(&channel->endpoint->register_mutex);\n\nend:\n\tmutex_unlock(&channel->rd_mutex);\n\tmutex_unlock(&channel->wr_mutex);\n\n\tif (rc)  \n\t\treturn rc;\n\n\tfilp->f_pos = pos;\n\n\t \n\n\tchannel->rd_leftovers[3] = 0;\n\n\treturn pos;\n}\n\nstatic __poll_t xillybus_poll(struct file *filp, poll_table *wait)\n{\n\tstruct xilly_channel *channel = filp->private_data;\n\t__poll_t mask = 0;\n\tunsigned long flags;\n\n\tpoll_wait(filp, &channel->endpoint->ep_wait, wait);\n\n\t \n\n\tif (!channel->wr_synchronous && channel->wr_supports_nonempty) {\n\t\tpoll_wait(filp, &channel->wr_wait, wait);\n\t\tpoll_wait(filp, &channel->wr_ready_wait, wait);\n\n\t\tspin_lock_irqsave(&channel->wr_spinlock, flags);\n\t\tif (!channel->wr_empty || channel->wr_ready)\n\t\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\n\t\tif (channel->wr_hangup)\n\t\t\t \n\t\t\tmask |=  EPOLLIN | EPOLLRDNORM;\n\t\tspin_unlock_irqrestore(&channel->wr_spinlock, flags);\n\t}\n\n\t \n\n\tif (channel->rd_allow_partial) {\n\t\tpoll_wait(filp, &channel->rd_wait, wait);\n\n\t\tspin_lock_irqsave(&channel->rd_spinlock, flags);\n\t\tif (!channel->rd_full)\n\t\t\tmask |= EPOLLOUT | EPOLLWRNORM;\n\t\tspin_unlock_irqrestore(&channel->rd_spinlock, flags);\n\t}\n\n\tif (channel->endpoint->fatal_error)\n\t\tmask |= EPOLLERR;\n\n\treturn mask;\n}\n\nstatic const struct file_operations xillybus_fops = {\n\t.owner      = THIS_MODULE,\n\t.read       = xillybus_read,\n\t.write      = xillybus_write,\n\t.open       = xillybus_open,\n\t.flush      = xillybus_flush,\n\t.release    = xillybus_release,\n\t.llseek     = xillybus_llseek,\n\t.poll       = xillybus_poll,\n};\n\nstruct xilly_endpoint *xillybus_init_endpoint(struct device *dev)\n{\n\tstruct xilly_endpoint *endpoint;\n\n\tendpoint = devm_kzalloc(dev, sizeof(*endpoint), GFP_KERNEL);\n\tif (!endpoint)\n\t\treturn NULL;\n\n\tendpoint->dev = dev;\n\tendpoint->msg_counter = 0x0b;\n\tendpoint->failed_messages = 0;\n\tendpoint->fatal_error = 0;\n\n\tinit_waitqueue_head(&endpoint->ep_wait);\n\tmutex_init(&endpoint->register_mutex);\n\n\treturn endpoint;\n}\nEXPORT_SYMBOL(xillybus_init_endpoint);\n\nstatic int xilly_quiesce(struct xilly_endpoint *endpoint)\n{\n\tlong t;\n\n\tendpoint->idtlen = -1;\n\n\tiowrite32((u32) (endpoint->dma_using_dac & 0x0001),\n\t\t  endpoint->registers + fpga_dma_control_reg);\n\n\tt = wait_event_interruptible_timeout(endpoint->ep_wait,\n\t\t\t\t\t     (endpoint->idtlen >= 0),\n\t\t\t\t\t     XILLY_TIMEOUT);\n\tif (t <= 0) {\n\t\tdev_err(endpoint->dev,\n\t\t\t\"Failed to quiesce the device on exit.\\n\");\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\nint xillybus_endpoint_discovery(struct xilly_endpoint *endpoint)\n{\n\tint rc;\n\tlong t;\n\n\tvoid *bootstrap_resources;\n\tint idtbuffersize = (1 << PAGE_SHIFT);\n\tstruct device *dev = endpoint->dev;\n\n\t \n\n\tunsigned char bogus_idt[8] = { 1, 224, (PAGE_SHIFT)-2, 0,\n\t\t\t\t       3, 192, PAGE_SHIFT, 0 };\n\tstruct xilly_idt_handle idt_handle;\n\n\t \n\n\tiowrite32(1, endpoint->registers + fpga_endian_reg);\n\n\t \n\n\tbootstrap_resources = devres_open_group(dev, NULL, GFP_KERNEL);\n\tif (!bootstrap_resources)\n\t\treturn -ENOMEM;\n\n\tendpoint->num_channels = 0;\n\n\trc = xilly_setupchannels(endpoint, bogus_idt, 1);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tiowrite32(0x04, endpoint->registers + fpga_msg_ctrl_reg);\n\n\tendpoint->idtlen = -1;\n\n\t \n\tiowrite32((u32) (endpoint->dma_using_dac & 0x0001),\n\t\t  endpoint->registers + fpga_dma_control_reg);\n\n\tt = wait_event_interruptible_timeout(endpoint->ep_wait,\n\t\t\t\t\t     (endpoint->idtlen >= 0),\n\t\t\t\t\t     XILLY_TIMEOUT);\n\tif (t <= 0) {\n\t\tdev_err(endpoint->dev, \"No response from FPGA. Aborting.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tiowrite32((u32) (0x0002 | (endpoint->dma_using_dac & 0x0001)),\n\t\t  endpoint->registers + fpga_dma_control_reg);\n\n\t \n\twhile (endpoint->idtlen >= idtbuffersize) {\n\t\tidtbuffersize *= 2;\n\t\tbogus_idt[6]++;\n\t}\n\n\tendpoint->num_channels = 1;\n\n\trc = xilly_setupchannels(endpoint, bogus_idt, 2);\n\tif (rc)\n\t\tgoto failed_idt;\n\n\trc = xilly_obtain_idt(endpoint);\n\tif (rc)\n\t\tgoto failed_idt;\n\n\trc = xilly_scan_idt(endpoint, &idt_handle);\n\tif (rc)\n\t\tgoto failed_idt;\n\n\tdevres_close_group(dev, bootstrap_resources);\n\n\t \n\n\trc = xilly_setupchannels(endpoint,\n\t\t\t\t idt_handle.chandesc,\n\t\t\t\t idt_handle.entries);\n\tif (rc)\n\t\tgoto failed_idt;\n\n\trc = xillybus_init_chrdev(dev, &xillybus_fops,\n\t\t\t\t  endpoint->owner, endpoint,\n\t\t\t\t  idt_handle.names,\n\t\t\t\t  idt_handle.names_len,\n\t\t\t\t  endpoint->num_channels,\n\t\t\t\t  xillyname, false);\n\n\tif (rc)\n\t\tgoto failed_idt;\n\n\tdevres_release_group(dev, bootstrap_resources);\n\n\treturn 0;\n\nfailed_idt:\n\txilly_quiesce(endpoint);\n\tflush_workqueue(xillybus_wq);\n\n\treturn rc;\n}\nEXPORT_SYMBOL(xillybus_endpoint_discovery);\n\nvoid xillybus_endpoint_remove(struct xilly_endpoint *endpoint)\n{\n\txillybus_cleanup_chrdev(endpoint, endpoint->dev);\n\n\txilly_quiesce(endpoint);\n\n\t \n\tflush_workqueue(xillybus_wq);\n}\nEXPORT_SYMBOL(xillybus_endpoint_remove);\n\nstatic int __init xillybus_init(void)\n{\n\txillybus_wq = alloc_workqueue(xillyname, 0, 0);\n\tif (!xillybus_wq)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void __exit xillybus_exit(void)\n{\n\t \n\tdestroy_workqueue(xillybus_wq);\n}\n\nmodule_init(xillybus_init);\nmodule_exit(xillybus_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}