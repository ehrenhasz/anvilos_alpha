{
  "module_name": "xillyusb.c",
  "hash_id": "37611471a39cde89e8b9c64642878713027e076df7cac32c6458e9f8d6573d70",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/xillybus/xillyusb.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <asm/byteorder.h>\n#include <linux/io.h>\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/workqueue.h>\n#include <linux/crc32.h>\n#include <linux/poll.h>\n#include <linux/delay.h>\n#include <linux/usb.h>\n\n#include \"xillybus_class.h\"\n\nMODULE_DESCRIPTION(\"Driver for XillyUSB FPGA IP Core\");\nMODULE_AUTHOR(\"Eli Billauer, Xillybus Ltd.\");\nMODULE_ALIAS(\"xillyusb\");\nMODULE_LICENSE(\"GPL v2\");\n\n#define XILLY_RX_TIMEOUT\t\t(10 * HZ / 1000)\n#define XILLY_RESPONSE_TIMEOUT\t\t(500 * HZ / 1000)\n\n#define BUF_SIZE_ORDER\t\t\t4\n#define BUFNUM\t\t\t\t8\n#define LOG2_IDT_FIFO_SIZE\t\t16\n#define LOG2_INITIAL_FIFO_BUF_SIZE\t16\n\n#define MSG_EP_NUM\t\t\t1\n#define IN_EP_NUM\t\t\t1\n\nstatic const char xillyname[] = \"xillyusb\";\n\nstatic unsigned int fifo_buf_order;\n\n#define USB_VENDOR_ID_XILINX\t\t0x03fd\n#define USB_VENDOR_ID_ALTERA\t\t0x09fb\n\n#define USB_PRODUCT_ID_XILLYUSB\t\t0xebbe\n\nstatic const struct usb_device_id xillyusb_table[] = {\n\t{ USB_DEVICE(USB_VENDOR_ID_XILINX, USB_PRODUCT_ID_XILLYUSB) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ALTERA, USB_PRODUCT_ID_XILLYUSB) },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(usb, xillyusb_table);\n\nstruct xillyusb_dev;\n\nstruct xillyfifo {\n\tunsigned int bufsize;  \n\tunsigned int bufnum;\n\tunsigned int size;  \n\tunsigned int buf_order;\n\n\tint fill;  \n\tspinlock_t lock;\n\twait_queue_head_t waitq;\n\n\tunsigned int readpos;\n\tunsigned int readbuf;\n\tunsigned int writepos;\n\tunsigned int writebuf;\n\tchar **mem;\n};\n\nstruct xillyusb_channel;\n\nstruct xillyusb_endpoint {\n\tstruct xillyusb_dev *xdev;\n\n\tstruct mutex ep_mutex;  \n\n\tstruct list_head buffers;\n\tstruct list_head filled_buffers;\n\tspinlock_t buffers_lock;  \n\n\tunsigned int order;\n\tunsigned int buffer_size;\n\n\tunsigned int fill_mask;\n\n\tint outstanding_urbs;\n\n\tstruct usb_anchor anchor;\n\n\tstruct xillyfifo fifo;\n\n\tstruct work_struct workitem;\n\n\tbool shutting_down;\n\tbool drained;\n\tbool wake_on_drain;\n\n\tu8 ep_num;\n};\n\nstruct xillyusb_channel {\n\tstruct xillyusb_dev *xdev;\n\n\tstruct xillyfifo *in_fifo;\n\tstruct xillyusb_endpoint *out_ep;\n\tstruct mutex lock;  \n\n\tstruct mutex in_mutex;  \n\tstruct mutex out_mutex;  \n\twait_queue_head_t flushq;\n\n\tint chan_idx;\n\n\tu32 in_consumed_bytes;\n\tu32 in_current_checkpoint;\n\tu32 out_bytes;\n\n\tunsigned int in_log2_element_size;\n\tunsigned int out_log2_element_size;\n\tunsigned int in_log2_fifo_size;\n\tunsigned int out_log2_fifo_size;\n\n\tunsigned int read_data_ok;  \n\tunsigned int poll_used;\n\tunsigned int flushing;\n\tunsigned int flushed;\n\tunsigned int canceled;\n\n\t \n\tunsigned readable:1;\n\tunsigned writable:1;\n\tunsigned open_for_read:1;\n\tunsigned open_for_write:1;\n\tunsigned in_synchronous:1;\n\tunsigned out_synchronous:1;\n\tunsigned in_seekable:1;\n\tunsigned out_seekable:1;\n};\n\nstruct xillybuffer {\n\tstruct list_head entry;\n\tstruct xillyusb_endpoint *ep;\n\tvoid *buf;\n\tunsigned int len;\n};\n\nstruct xillyusb_dev {\n\tstruct xillyusb_channel *channels;\n\n\tstruct usb_device\t*udev;\n\tstruct device\t\t*dev;  \n\tstruct kref\t\tkref;\n\tstruct workqueue_struct\t*workq;\n\n\tint error;\n\tspinlock_t error_lock;  \n\tstruct work_struct wakeup_workitem;\n\n\tint num_channels;\n\n\tstruct xillyusb_endpoint *msg_ep;\n\tstruct xillyusb_endpoint *in_ep;\n\n\tstruct mutex msg_mutex;  \n\tint in_bytes_left;\n\tint leftover_chan_num;\n\tunsigned int in_counter;\n\tstruct mutex process_in_mutex;  \n};\n\n \n\nstatic DEFINE_MUTEX(kref_mutex);\n\n \nenum {\n\tOPCODE_DATA = 0,\n\tOPCODE_QUIESCE_ACK = 1,\n\tOPCODE_EOF = 2,\n\tOPCODE_REACHED_CHECKPOINT = 3,\n\tOPCODE_CANCELED_CHECKPOINT = 4,\n};\n\n \nenum {\n\tOPCODE_QUIESCE = 0,\n\tOPCODE_REQ_IDT = 1,\n\tOPCODE_SET_CHECKPOINT = 2,\n\tOPCODE_CLOSE = 3,\n\tOPCODE_SET_PUSH = 4,\n\tOPCODE_UPDATE_PUSH = 5,\n\tOPCODE_CANCEL_CHECKPOINT = 6,\n\tOPCODE_SET_ADDR = 7,\n};\n\n \n\nstatic int fifo_write(struct xillyfifo *fifo,\n\t\t      const void *data, unsigned int len,\n\t\t      int (*copier)(void *, const void *, int))\n{\n\tunsigned int done = 0;\n\tunsigned int todo = len;\n\tunsigned int nmax;\n\tunsigned int writepos = fifo->writepos;\n\tunsigned int writebuf = fifo->writebuf;\n\tunsigned long flags;\n\tint rc;\n\n\tnmax = fifo->size - READ_ONCE(fifo->fill);\n\n\twhile (1) {\n\t\tunsigned int nrail = fifo->bufsize - writepos;\n\t\tunsigned int n = min(todo, nmax);\n\n\t\tif (n == 0) {\n\t\t\tspin_lock_irqsave(&fifo->lock, flags);\n\t\t\tfifo->fill += done;\n\t\t\tspin_unlock_irqrestore(&fifo->lock, flags);\n\n\t\t\tfifo->writepos = writepos;\n\t\t\tfifo->writebuf = writebuf;\n\n\t\t\treturn done;\n\t\t}\n\n\t\tif (n > nrail)\n\t\t\tn = nrail;\n\n\t\trc = (*copier)(fifo->mem[writebuf] + writepos, data + done, n);\n\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tdone += n;\n\t\ttodo -= n;\n\n\t\twritepos += n;\n\t\tnmax -= n;\n\n\t\tif (writepos == fifo->bufsize) {\n\t\t\twritepos = 0;\n\t\t\twritebuf++;\n\n\t\t\tif (writebuf == fifo->bufnum)\n\t\t\t\twritebuf = 0;\n\t\t}\n\t}\n}\n\nstatic int fifo_read(struct xillyfifo *fifo,\n\t\t     void *data, unsigned int len,\n\t\t     int (*copier)(void *, const void *, int))\n{\n\tunsigned int done = 0;\n\tunsigned int todo = len;\n\tunsigned int fill;\n\tunsigned int readpos = fifo->readpos;\n\tunsigned int readbuf = fifo->readbuf;\n\tunsigned long flags;\n\tint rc;\n\n\t \n\n\tspin_lock_irqsave(&fifo->lock, flags);\n\tfill = fifo->fill;\n\tspin_unlock_irqrestore(&fifo->lock, flags);\n\n\twhile (1) {\n\t\tunsigned int nrail = fifo->bufsize - readpos;\n\t\tunsigned int n = min(todo, fill);\n\n\t\tif (n == 0) {\n\t\t\tspin_lock_irqsave(&fifo->lock, flags);\n\t\t\tfifo->fill -= done;\n\t\t\tspin_unlock_irqrestore(&fifo->lock, flags);\n\n\t\t\tfifo->readpos = readpos;\n\t\t\tfifo->readbuf = readbuf;\n\n\t\t\treturn done;\n\t\t}\n\n\t\tif (n > nrail)\n\t\t\tn = nrail;\n\n\t\trc = (*copier)(data + done, fifo->mem[readbuf] + readpos, n);\n\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tdone += n;\n\t\ttodo -= n;\n\n\t\treadpos += n;\n\t\tfill -= n;\n\n\t\tif (readpos == fifo->bufsize) {\n\t\t\treadpos = 0;\n\t\t\treadbuf++;\n\n\t\t\tif (readbuf == fifo->bufnum)\n\t\t\t\treadbuf = 0;\n\t\t}\n\t}\n}\n\n \n\nstatic int xilly_copy_from_user(void *dst, const void *src, int n)\n{\n\tif (copy_from_user(dst, (const void __user *)src, n))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int xilly_copy_to_user(void *dst, const void *src, int n)\n{\n\tif (copy_to_user((void __user *)dst, src, n))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int xilly_memcpy(void *dst, const void *src, int n)\n{\n\tmemcpy(dst, src, n);\n\n\treturn 0;\n}\n\nstatic int fifo_init(struct xillyfifo *fifo,\n\t\t     unsigned int log2_size)\n{\n\tunsigned int log2_bufnum;\n\tunsigned int buf_order;\n\tint i;\n\n\tunsigned int log2_fifo_buf_size;\n\nretry:\n\tlog2_fifo_buf_size = fifo_buf_order + PAGE_SHIFT;\n\n\tif (log2_size > log2_fifo_buf_size) {\n\t\tlog2_bufnum = log2_size - log2_fifo_buf_size;\n\t\tbuf_order = fifo_buf_order;\n\t\tfifo->bufsize = 1 << log2_fifo_buf_size;\n\t} else {\n\t\tlog2_bufnum = 0;\n\t\tbuf_order = (log2_size > PAGE_SHIFT) ?\n\t\t\tlog2_size - PAGE_SHIFT : 0;\n\t\tfifo->bufsize = 1 << log2_size;\n\t}\n\n\tfifo->bufnum = 1 << log2_bufnum;\n\tfifo->size = fifo->bufnum * fifo->bufsize;\n\tfifo->buf_order = buf_order;\n\n\tfifo->mem = kmalloc_array(fifo->bufnum, sizeof(void *), GFP_KERNEL);\n\n\tif (!fifo->mem)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < fifo->bufnum; i++) {\n\t\tfifo->mem[i] = (void *)\n\t\t\t__get_free_pages(GFP_KERNEL, buf_order);\n\n\t\tif (!fifo->mem[i])\n\t\t\tgoto memfail;\n\t}\n\n\tfifo->fill = 0;\n\tfifo->readpos = 0;\n\tfifo->readbuf = 0;\n\tfifo->writepos = 0;\n\tfifo->writebuf = 0;\n\tspin_lock_init(&fifo->lock);\n\tinit_waitqueue_head(&fifo->waitq);\n\treturn 0;\n\nmemfail:\n\tfor (i--; i >= 0; i--)\n\t\tfree_pages((unsigned long)fifo->mem[i], buf_order);\n\n\tkfree(fifo->mem);\n\tfifo->mem = NULL;\n\n\tif (fifo_buf_order) {\n\t\tfifo_buf_order--;\n\t\tgoto retry;\n\t} else {\n\t\treturn -ENOMEM;\n\t}\n}\n\nstatic void fifo_mem_release(struct xillyfifo *fifo)\n{\n\tint i;\n\n\tif (!fifo->mem)\n\t\treturn;\n\n\tfor (i = 0; i < fifo->bufnum; i++)\n\t\tfree_pages((unsigned long)fifo->mem[i], fifo->buf_order);\n\n\tkfree(fifo->mem);\n}\n\n \n\nstatic void endpoint_quiesce(struct xillyusb_endpoint *ep)\n{\n\tmutex_lock(&ep->ep_mutex);\n\tep->shutting_down = true;\n\tmutex_unlock(&ep->ep_mutex);\n\n\tusb_kill_anchored_urbs(&ep->anchor);\n\tcancel_work_sync(&ep->workitem);\n}\n\n \n\nstatic void endpoint_dealloc(struct xillyusb_endpoint *ep)\n{\n\tstruct list_head *this, *next;\n\n\tfifo_mem_release(&ep->fifo);\n\n\t \n\tlist_splice(&ep->filled_buffers, &ep->buffers);\n\n\tlist_for_each_safe(this, next, &ep->buffers) {\n\t\tstruct xillybuffer *xb =\n\t\t\tlist_entry(this, struct xillybuffer, entry);\n\n\t\tfree_pages((unsigned long)xb->buf, ep->order);\n\t\tkfree(xb);\n\t}\n\n\tkfree(ep);\n}\n\nstatic struct xillyusb_endpoint\n*endpoint_alloc(struct xillyusb_dev *xdev,\n\t\tu8 ep_num,\n\t\tvoid (*work)(struct work_struct *),\n\t\tunsigned int order,\n\t\tint bufnum)\n{\n\tint i;\n\n\tstruct xillyusb_endpoint *ep;\n\n\tep = kzalloc(sizeof(*ep), GFP_KERNEL);\n\n\tif (!ep)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&ep->buffers);\n\tINIT_LIST_HEAD(&ep->filled_buffers);\n\n\tspin_lock_init(&ep->buffers_lock);\n\tmutex_init(&ep->ep_mutex);\n\n\tinit_usb_anchor(&ep->anchor);\n\tINIT_WORK(&ep->workitem, work);\n\n\tep->order = order;\n\tep->buffer_size =  1 << (PAGE_SHIFT + order);\n\tep->outstanding_urbs = 0;\n\tep->drained = true;\n\tep->wake_on_drain = false;\n\tep->xdev = xdev;\n\tep->ep_num = ep_num;\n\tep->shutting_down = false;\n\n\tfor (i = 0; i < bufnum; i++) {\n\t\tstruct xillybuffer *xb;\n\t\tunsigned long addr;\n\n\t\txb = kzalloc(sizeof(*xb), GFP_KERNEL);\n\n\t\tif (!xb) {\n\t\t\tendpoint_dealloc(ep);\n\t\t\treturn NULL;\n\t\t}\n\n\t\taddr = __get_free_pages(GFP_KERNEL, order);\n\n\t\tif (!addr) {\n\t\t\tkfree(xb);\n\t\t\tendpoint_dealloc(ep);\n\t\t\treturn NULL;\n\t\t}\n\n\t\txb->buf = (void *)addr;\n\t\txb->ep = ep;\n\t\tlist_add_tail(&xb->entry, &ep->buffers);\n\t}\n\treturn ep;\n}\n\nstatic void cleanup_dev(struct kref *kref)\n{\n\tstruct xillyusb_dev *xdev =\n\t\tcontainer_of(kref, struct xillyusb_dev, kref);\n\n\tif (xdev->in_ep)\n\t\tendpoint_dealloc(xdev->in_ep);\n\n\tif (xdev->msg_ep)\n\t\tendpoint_dealloc(xdev->msg_ep);\n\n\tif (xdev->workq)\n\t\tdestroy_workqueue(xdev->workq);\n\n\tusb_put_dev(xdev->udev);\n\tkfree(xdev->channels);  \n\tkfree(xdev);\n}\n\n \n\nstatic void wakeup_all(struct work_struct *work)\n{\n\tint i;\n\tstruct xillyusb_dev *xdev = container_of(work, struct xillyusb_dev,\n\t\t\t\t\t\t wakeup_workitem);\n\n\tmutex_lock(&xdev->process_in_mutex);\n\n\tfor (i = 0; i < xdev->num_channels; i++) {\n\t\tstruct xillyusb_channel *chan = &xdev->channels[i];\n\n\t\tmutex_lock(&chan->lock);\n\n\t\tif (chan->in_fifo) {\n\t\t\t \n\t\t\tchan->read_data_ok = 0;\n\t\t\twake_up_interruptible(&chan->in_fifo->waitq);\n\t\t}\n\n\t\tif (chan->out_ep)\n\t\t\twake_up_interruptible(&chan->out_ep->fifo.waitq);\n\n\t\tmutex_unlock(&chan->lock);\n\n\t\twake_up_interruptible(&chan->flushq);\n\t}\n\n\tmutex_unlock(&xdev->process_in_mutex);\n\n\twake_up_interruptible(&xdev->msg_ep->fifo.waitq);\n\n\tkref_put(&xdev->kref, cleanup_dev);\n}\n\nstatic void report_io_error(struct xillyusb_dev *xdev,\n\t\t\t    int errcode)\n{\n\tunsigned long flags;\n\tbool do_once = false;\n\n\tspin_lock_irqsave(&xdev->error_lock, flags);\n\tif (!xdev->error) {\n\t\txdev->error = errcode;\n\t\tdo_once = true;\n\t}\n\tspin_unlock_irqrestore(&xdev->error_lock, flags);\n\n\tif (do_once) {\n\t\tkref_get(&xdev->kref);  \n\t\tqueue_work(xdev->workq, &xdev->wakeup_workitem);\n\t}\n}\n\n \n\nstatic void safely_assign_in_fifo(struct xillyusb_channel *chan,\n\t\t\t\t  struct xillyfifo *fifo)\n{\n\tmutex_lock(&chan->lock);\n\tchan->in_fifo = fifo;\n\tmutex_unlock(&chan->lock);\n\n\tflush_work(&chan->xdev->in_ep->workitem);\n}\n\nstatic void bulk_in_completer(struct urb *urb)\n{\n\tstruct xillybuffer *xb = urb->context;\n\tstruct xillyusb_endpoint *ep = xb->ep;\n\tunsigned long flags;\n\n\tif (urb->status) {\n\t\tif (!(urb->status == -ENOENT ||\n\t\t      urb->status == -ECONNRESET ||\n\t\t      urb->status == -ESHUTDOWN))\n\t\t\treport_io_error(ep->xdev, -EIO);\n\n\t\tspin_lock_irqsave(&ep->buffers_lock, flags);\n\t\tlist_add_tail(&xb->entry, &ep->buffers);\n\t\tep->outstanding_urbs--;\n\t\tspin_unlock_irqrestore(&ep->buffers_lock, flags);\n\n\t\treturn;\n\t}\n\n\txb->len = urb->actual_length;\n\n\tspin_lock_irqsave(&ep->buffers_lock, flags);\n\tlist_add_tail(&xb->entry, &ep->filled_buffers);\n\tspin_unlock_irqrestore(&ep->buffers_lock, flags);\n\n\tif (!ep->shutting_down)\n\t\tqueue_work(ep->xdev->workq, &ep->workitem);\n}\n\nstatic void bulk_out_completer(struct urb *urb)\n{\n\tstruct xillybuffer *xb = urb->context;\n\tstruct xillyusb_endpoint *ep = xb->ep;\n\tunsigned long flags;\n\n\tif (urb->status &&\n\t    (!(urb->status == -ENOENT ||\n\t       urb->status == -ECONNRESET ||\n\t       urb->status == -ESHUTDOWN)))\n\t\treport_io_error(ep->xdev, -EIO);\n\n\tspin_lock_irqsave(&ep->buffers_lock, flags);\n\tlist_add_tail(&xb->entry, &ep->buffers);\n\tep->outstanding_urbs--;\n\tspin_unlock_irqrestore(&ep->buffers_lock, flags);\n\n\tif (!ep->shutting_down)\n\t\tqueue_work(ep->xdev->workq, &ep->workitem);\n}\n\nstatic void try_queue_bulk_in(struct xillyusb_endpoint *ep)\n{\n\tstruct xillyusb_dev *xdev = ep->xdev;\n\tstruct xillybuffer *xb;\n\tstruct urb *urb;\n\n\tint rc;\n\tunsigned long flags;\n\tunsigned int bufsize = ep->buffer_size;\n\n\tmutex_lock(&ep->ep_mutex);\n\n\tif (ep->shutting_down || xdev->error)\n\t\tgoto done;\n\n\twhile (1) {\n\t\tspin_lock_irqsave(&ep->buffers_lock, flags);\n\n\t\tif (list_empty(&ep->buffers)) {\n\t\t\tspin_unlock_irqrestore(&ep->buffers_lock, flags);\n\t\t\tgoto done;\n\t\t}\n\n\t\txb = list_first_entry(&ep->buffers, struct xillybuffer, entry);\n\t\tlist_del(&xb->entry);\n\t\tep->outstanding_urbs++;\n\n\t\tspin_unlock_irqrestore(&ep->buffers_lock, flags);\n\n\t\turb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!urb) {\n\t\t\treport_io_error(xdev, -ENOMEM);\n\t\t\tgoto relist;\n\t\t}\n\n\t\tusb_fill_bulk_urb(urb, xdev->udev,\n\t\t\t\t  usb_rcvbulkpipe(xdev->udev, ep->ep_num),\n\t\t\t\t  xb->buf, bufsize, bulk_in_completer, xb);\n\n\t\tusb_anchor_urb(urb, &ep->anchor);\n\n\t\trc = usb_submit_urb(urb, GFP_KERNEL);\n\n\t\tif (rc) {\n\t\t\treport_io_error(xdev, (rc == -ENOMEM) ? -ENOMEM :\n\t\t\t\t\t-EIO);\n\t\t\tgoto unanchor;\n\t\t}\n\n\t\tusb_free_urb(urb);  \n\t}\n\nunanchor:\n\tusb_unanchor_urb(urb);\n\tusb_free_urb(urb);\n\nrelist:\n\tspin_lock_irqsave(&ep->buffers_lock, flags);\n\tlist_add_tail(&xb->entry, &ep->buffers);\n\tep->outstanding_urbs--;\n\tspin_unlock_irqrestore(&ep->buffers_lock, flags);\n\ndone:\n\tmutex_unlock(&ep->ep_mutex);\n}\n\nstatic void try_queue_bulk_out(struct xillyusb_endpoint *ep)\n{\n\tstruct xillyfifo *fifo = &ep->fifo;\n\tstruct xillyusb_dev *xdev = ep->xdev;\n\tstruct xillybuffer *xb;\n\tstruct urb *urb;\n\n\tint rc;\n\tunsigned int fill;\n\tunsigned long flags;\n\tbool do_wake = false;\n\n\tmutex_lock(&ep->ep_mutex);\n\n\tif (ep->shutting_down || xdev->error)\n\t\tgoto done;\n\n\tfill = READ_ONCE(fifo->fill) & ep->fill_mask;\n\n\twhile (1) {\n\t\tint count;\n\t\tunsigned int max_read;\n\n\t\tspin_lock_irqsave(&ep->buffers_lock, flags);\n\n\t\t \n\n\t\tif (!fill) {\n\t\t\tep->drained = !ep->outstanding_urbs;\n\t\t\tif (ep->drained && ep->wake_on_drain)\n\t\t\t\tdo_wake = true;\n\n\t\t\tspin_unlock_irqrestore(&ep->buffers_lock, flags);\n\t\t\tgoto done;\n\t\t}\n\n\t\tep->drained = false;\n\n\t\tif ((fill < ep->buffer_size && ep->outstanding_urbs) ||\n\t\t    list_empty(&ep->buffers)) {\n\t\t\tspin_unlock_irqrestore(&ep->buffers_lock, flags);\n\t\t\tgoto done;\n\t\t}\n\n\t\txb = list_first_entry(&ep->buffers, struct xillybuffer, entry);\n\t\tlist_del(&xb->entry);\n\t\tep->outstanding_urbs++;\n\n\t\tspin_unlock_irqrestore(&ep->buffers_lock, flags);\n\n\t\tmax_read = min(fill, ep->buffer_size);\n\n\t\tcount = fifo_read(&ep->fifo, xb->buf, max_read, xilly_memcpy);\n\n\t\t \n\n\t\turb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!urb) {\n\t\t\treport_io_error(xdev, -ENOMEM);\n\t\t\tgoto relist;\n\t\t}\n\n\t\tusb_fill_bulk_urb(urb, xdev->udev,\n\t\t\t\t  usb_sndbulkpipe(xdev->udev, ep->ep_num),\n\t\t\t\t  xb->buf, count, bulk_out_completer, xb);\n\n\t\tusb_anchor_urb(urb, &ep->anchor);\n\n\t\trc = usb_submit_urb(urb, GFP_KERNEL);\n\n\t\tif (rc) {\n\t\t\treport_io_error(xdev, (rc == -ENOMEM) ? -ENOMEM :\n\t\t\t\t\t-EIO);\n\t\t\tgoto unanchor;\n\t\t}\n\n\t\tusb_free_urb(urb);  \n\n\t\tfill -= count;\n\t\tdo_wake = true;\n\t}\n\nunanchor:\n\tusb_unanchor_urb(urb);\n\tusb_free_urb(urb);\n\nrelist:\n\tspin_lock_irqsave(&ep->buffers_lock, flags);\n\tlist_add_tail(&xb->entry, &ep->buffers);\n\tep->outstanding_urbs--;\n\tspin_unlock_irqrestore(&ep->buffers_lock, flags);\n\ndone:\n\tmutex_unlock(&ep->ep_mutex);\n\n\tif (do_wake)\n\t\twake_up_interruptible(&fifo->waitq);\n}\n\nstatic void bulk_out_work(struct work_struct *work)\n{\n\tstruct xillyusb_endpoint *ep = container_of(work,\n\t\t\t\t\t\t    struct xillyusb_endpoint,\n\t\t\t\t\t\t    workitem);\n\ttry_queue_bulk_out(ep);\n}\n\nstatic int process_in_opcode(struct xillyusb_dev *xdev,\n\t\t\t     int opcode,\n\t\t\t     int chan_num)\n{\n\tstruct xillyusb_channel *chan;\n\tstruct device *dev = xdev->dev;\n\tint chan_idx = chan_num >> 1;\n\n\tif (chan_idx >= xdev->num_channels) {\n\t\tdev_err(dev, \"Received illegal channel ID %d from FPGA\\n\",\n\t\t\tchan_num);\n\t\treturn -EIO;\n\t}\n\n\tchan = &xdev->channels[chan_idx];\n\n\tswitch (opcode) {\n\tcase OPCODE_EOF:\n\t\tif (!chan->read_data_ok) {\n\t\t\tdev_err(dev, \"Received unexpected EOF for channel %d\\n\",\n\t\t\t\tchan_num);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t \n\t\tsmp_wmb();\n\t\tWRITE_ONCE(chan->read_data_ok, 0);\n\t\twake_up_interruptible(&chan->in_fifo->waitq);\n\t\tbreak;\n\n\tcase OPCODE_REACHED_CHECKPOINT:\n\t\tchan->flushing = 0;\n\t\twake_up_interruptible(&chan->flushq);\n\t\tbreak;\n\n\tcase OPCODE_CANCELED_CHECKPOINT:\n\t\tchan->canceled = 1;\n\t\twake_up_interruptible(&chan->flushq);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"Received illegal opcode %d from FPGA\\n\",\n\t\t\topcode);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int process_bulk_in(struct xillybuffer *xb)\n{\n\tstruct xillyusb_endpoint *ep = xb->ep;\n\tstruct xillyusb_dev *xdev = ep->xdev;\n\tstruct device *dev = xdev->dev;\n\tint dws = xb->len >> 2;\n\t__le32 *p = xb->buf;\n\tu32 ctrlword;\n\tstruct xillyusb_channel *chan;\n\tstruct xillyfifo *fifo;\n\tint chan_num = 0, opcode;\n\tint chan_idx;\n\tint bytes, count, dwconsume;\n\tint in_bytes_left = 0;\n\tint rc;\n\n\tif ((dws << 2) != xb->len) {\n\t\tdev_err(dev, \"Received BULK IN transfer with %d bytes, not a multiple of 4\\n\",\n\t\t\txb->len);\n\t\treturn -EIO;\n\t}\n\n\tif (xdev->in_bytes_left) {\n\t\tbytes = min(xdev->in_bytes_left, dws << 2);\n\t\tin_bytes_left = xdev->in_bytes_left - bytes;\n\t\tchan_num = xdev->leftover_chan_num;\n\t\tgoto resume_leftovers;\n\t}\n\n\twhile (dws) {\n\t\tctrlword = le32_to_cpu(*p++);\n\t\tdws--;\n\n\t\tchan_num = ctrlword & 0xfff;\n\t\tcount = (ctrlword >> 12) & 0x3ff;\n\t\topcode = (ctrlword >> 24) & 0xf;\n\n\t\tif (opcode != OPCODE_DATA) {\n\t\t\tunsigned int in_counter = xdev->in_counter++ & 0x3ff;\n\n\t\t\tif (count != in_counter) {\n\t\t\t\tdev_err(dev, \"Expected opcode counter %d, got %d\\n\",\n\t\t\t\t\tin_counter, count);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\n\t\t\trc = process_in_opcode(xdev, opcode, chan_num);\n\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tbytes = min(count + 1, dws << 2);\n\t\tin_bytes_left = count + 1 - bytes;\n\nresume_leftovers:\n\t\tchan_idx = chan_num >> 1;\n\n\t\tif (!(chan_num & 1) || chan_idx >= xdev->num_channels ||\n\t\t    !xdev->channels[chan_idx].read_data_ok) {\n\t\t\tdev_err(dev, \"Received illegal channel ID %d from FPGA\\n\",\n\t\t\t\tchan_num);\n\t\t\treturn -EIO;\n\t\t}\n\t\tchan = &xdev->channels[chan_idx];\n\n\t\tfifo = chan->in_fifo;\n\n\t\tif (unlikely(!fifo))\n\t\t\treturn -EIO;  \n\n\t\tif (bytes != fifo_write(fifo, p, bytes, xilly_memcpy)) {\n\t\t\tdev_err(dev, \"Misbehaving FPGA overflowed an upstream FIFO!\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\twake_up_interruptible(&fifo->waitq);\n\n\t\tdwconsume = (bytes + 3) >> 2;\n\t\tdws -= dwconsume;\n\t\tp += dwconsume;\n\t}\n\n\txdev->in_bytes_left = in_bytes_left;\n\txdev->leftover_chan_num = chan_num;\n\treturn 0;\n}\n\nstatic void bulk_in_work(struct work_struct *work)\n{\n\tstruct xillyusb_endpoint *ep =\n\t\tcontainer_of(work, struct xillyusb_endpoint, workitem);\n\tstruct xillyusb_dev *xdev = ep->xdev;\n\tunsigned long flags;\n\tstruct xillybuffer *xb;\n\tbool consumed = false;\n\tint rc = 0;\n\n\tmutex_lock(&xdev->process_in_mutex);\n\n\tspin_lock_irqsave(&ep->buffers_lock, flags);\n\n\twhile (1) {\n\t\tif (rc || list_empty(&ep->filled_buffers)) {\n\t\t\tspin_unlock_irqrestore(&ep->buffers_lock, flags);\n\t\t\tmutex_unlock(&xdev->process_in_mutex);\n\n\t\t\tif (rc)\n\t\t\t\treport_io_error(xdev, rc);\n\t\t\telse if (consumed)\n\t\t\t\ttry_queue_bulk_in(ep);\n\n\t\t\treturn;\n\t\t}\n\n\t\txb = list_first_entry(&ep->filled_buffers, struct xillybuffer,\n\t\t\t\t      entry);\n\t\tlist_del(&xb->entry);\n\n\t\tspin_unlock_irqrestore(&ep->buffers_lock, flags);\n\n\t\tconsumed = true;\n\n\t\tif (!xdev->error)\n\t\t\trc = process_bulk_in(xb);\n\n\t\tspin_lock_irqsave(&ep->buffers_lock, flags);\n\t\tlist_add_tail(&xb->entry, &ep->buffers);\n\t\tep->outstanding_urbs--;\n\t}\n}\n\nstatic int xillyusb_send_opcode(struct xillyusb_dev *xdev,\n\t\t\t\tint chan_num, char opcode, u32 data)\n{\n\tstruct xillyusb_endpoint *ep = xdev->msg_ep;\n\tstruct xillyfifo *fifo = &ep->fifo;\n\t__le32 msg[2];\n\n\tint rc = 0;\n\n\tmsg[0] = cpu_to_le32((chan_num & 0xfff) |\n\t\t\t     ((opcode & 0xf) << 24));\n\tmsg[1] = cpu_to_le32(data);\n\n\tmutex_lock(&xdev->msg_mutex);\n\n\t \n\n\twhile (wait_event_interruptible(fifo->waitq,\n\t\t\t\t\tfifo->fill <= (fifo->size - 8) ||\n\t\t\t\t\txdev->error))\n\t\t;  \n\n\tif (xdev->error) {\n\t\trc = xdev->error;\n\t\tgoto unlock_done;\n\t}\n\n\tfifo_write(fifo, (void *)msg, 8, xilly_memcpy);\n\n\ttry_queue_bulk_out(ep);\n\nunlock_done:\n\tmutex_unlock(&xdev->msg_mutex);\n\n\treturn rc;\n}\n\n \n\nstatic int flush_downstream(struct xillyusb_channel *chan,\n\t\t\t    long timeout,\n\t\t\t    bool interruptible)\n{\n\tstruct xillyusb_dev *xdev = chan->xdev;\n\tint chan_num = chan->chan_idx << 1;\n\tlong deadline, left_to_sleep;\n\tint rc;\n\n\tif (chan->flushed)\n\t\treturn 0;\n\n\tdeadline = jiffies + 1 + timeout;\n\n\tif (chan->flushing) {\n\t\tlong cancel_deadline = jiffies + 1 + XILLY_RESPONSE_TIMEOUT;\n\n\t\tchan->canceled = 0;\n\t\trc = xillyusb_send_opcode(xdev, chan_num,\n\t\t\t\t\t  OPCODE_CANCEL_CHECKPOINT, 0);\n\n\t\tif (rc)\n\t\t\treturn rc;  \n\n\t\t \n\t\twhile (!chan->canceled) {\n\t\t\tleft_to_sleep = cancel_deadline - ((long)jiffies);\n\n\t\t\tif (left_to_sleep <= 0) {\n\t\t\t\treport_io_error(xdev, -EIO);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\n\t\t\trc = wait_event_interruptible_timeout(chan->flushq,\n\t\t\t\t\t\t\t      chan->canceled ||\n\t\t\t\t\t\t\t      xdev->error,\n\t\t\t\t\t\t\t      left_to_sleep);\n\n\t\t\tif (xdev->error)\n\t\t\t\treturn xdev->error;\n\t\t}\n\t}\n\n\tchan->flushing = 1;\n\n\t \n\n\trc = xillyusb_send_opcode(xdev, chan_num,\n\t\t\t\t  OPCODE_SET_CHECKPOINT,\n\t\t\t\t  chan->out_bytes >>\n\t\t\t\t  chan->out_log2_element_size);\n\n\tif (rc)\n\t\treturn rc;  \n\n\tif (!timeout) {\n\t\twhile (chan->flushing) {\n\t\t\trc = wait_event_interruptible(chan->flushq,\n\t\t\t\t\t\t      !chan->flushing ||\n\t\t\t\t\t\t      xdev->error);\n\t\t\tif (xdev->error)\n\t\t\t\treturn xdev->error;\n\n\t\t\tif (interruptible && rc)\n\t\t\t\treturn -EINTR;\n\t\t}\n\n\t\tgoto done;\n\t}\n\n\twhile (chan->flushing) {\n\t\tleft_to_sleep = deadline - ((long)jiffies);\n\n\t\tif (left_to_sleep <= 0)\n\t\t\treturn -ETIMEDOUT;\n\n\t\trc = wait_event_interruptible_timeout(chan->flushq,\n\t\t\t\t\t\t      !chan->flushing ||\n\t\t\t\t\t\t      xdev->error,\n\t\t\t\t\t\t      left_to_sleep);\n\n\t\tif (xdev->error)\n\t\t\treturn xdev->error;\n\n\t\tif (interruptible && rc < 0)\n\t\t\treturn -EINTR;\n\t}\n\ndone:\n\tchan->flushed = 1;\n\treturn 0;\n}\n\n \nstatic int request_read_anything(struct xillyusb_channel *chan,\n\t\t\t\t char opcode)\n{\n\tstruct xillyusb_dev *xdev = chan->xdev;\n\tunsigned int sh = chan->in_log2_element_size;\n\tint chan_num = (chan->chan_idx << 1) | 1;\n\tu32 mercy = chan->in_consumed_bytes + (2 << sh) - 1;\n\n\treturn xillyusb_send_opcode(xdev, chan_num, opcode, mercy >> sh);\n}\n\nstatic int xillyusb_open(struct inode *inode, struct file *filp)\n{\n\tstruct xillyusb_dev *xdev;\n\tstruct xillyusb_channel *chan;\n\tstruct xillyfifo *in_fifo = NULL;\n\tstruct xillyusb_endpoint *out_ep = NULL;\n\tint rc;\n\tint index;\n\n\tmutex_lock(&kref_mutex);\n\n\trc = xillybus_find_inode(inode, (void **)&xdev, &index);\n\tif (rc) {\n\t\tmutex_unlock(&kref_mutex);\n\t\treturn rc;\n\t}\n\n\tkref_get(&xdev->kref);\n\tmutex_unlock(&kref_mutex);\n\n\tchan = &xdev->channels[index];\n\tfilp->private_data = chan;\n\n\tmutex_lock(&chan->lock);\n\n\trc = -ENODEV;\n\n\tif (xdev->error)\n\t\tgoto unmutex_fail;\n\n\tif (((filp->f_mode & FMODE_READ) && !chan->readable) ||\n\t    ((filp->f_mode & FMODE_WRITE) && !chan->writable))\n\t\tgoto unmutex_fail;\n\n\tif ((filp->f_flags & O_NONBLOCK) && (filp->f_mode & FMODE_READ) &&\n\t    chan->in_synchronous) {\n\t\tdev_err(xdev->dev,\n\t\t\t\"open() failed: O_NONBLOCK not allowed for read on this device\\n\");\n\t\tgoto unmutex_fail;\n\t}\n\n\tif ((filp->f_flags & O_NONBLOCK) && (filp->f_mode & FMODE_WRITE) &&\n\t    chan->out_synchronous) {\n\t\tdev_err(xdev->dev,\n\t\t\t\"open() failed: O_NONBLOCK not allowed for write on this device\\n\");\n\t\tgoto unmutex_fail;\n\t}\n\n\trc = -EBUSY;\n\n\tif (((filp->f_mode & FMODE_READ) && chan->open_for_read) ||\n\t    ((filp->f_mode & FMODE_WRITE) && chan->open_for_write))\n\t\tgoto unmutex_fail;\n\n\tif (filp->f_mode & FMODE_READ)\n\t\tchan->open_for_read = 1;\n\n\tif (filp->f_mode & FMODE_WRITE)\n\t\tchan->open_for_write = 1;\n\n\tmutex_unlock(&chan->lock);\n\n\tif (filp->f_mode & FMODE_WRITE) {\n\t\tout_ep = endpoint_alloc(xdev,\n\t\t\t\t\t(chan->chan_idx + 2) | USB_DIR_OUT,\n\t\t\t\t\tbulk_out_work, BUF_SIZE_ORDER, BUFNUM);\n\n\t\tif (!out_ep) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto unopen;\n\t\t}\n\n\t\trc = fifo_init(&out_ep->fifo, chan->out_log2_fifo_size);\n\n\t\tif (rc)\n\t\t\tgoto late_unopen;\n\n\t\tout_ep->fill_mask = -(1 << chan->out_log2_element_size);\n\t\tchan->out_bytes = 0;\n\t\tchan->flushed = 0;\n\n\t\t \n\t\trc = flush_downstream(chan, XILLY_RESPONSE_TIMEOUT, false);\n\n\t\tif (rc == -ETIMEDOUT) {\n\t\t\trc = -EIO;\n\t\t\treport_io_error(xdev, rc);\n\t\t}\n\n\t\tif (rc)\n\t\t\tgoto late_unopen;\n\t}\n\n\tif (filp->f_mode & FMODE_READ) {\n\t\tin_fifo = kzalloc(sizeof(*in_fifo), GFP_KERNEL);\n\n\t\tif (!in_fifo) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto late_unopen;\n\t\t}\n\n\t\trc = fifo_init(in_fifo, chan->in_log2_fifo_size);\n\n\t\tif (rc) {\n\t\t\tkfree(in_fifo);\n\t\t\tgoto late_unopen;\n\t\t}\n\t}\n\n\tmutex_lock(&chan->lock);\n\tif (in_fifo) {\n\t\tchan->in_fifo = in_fifo;\n\t\tchan->read_data_ok = 1;\n\t}\n\tif (out_ep)\n\t\tchan->out_ep = out_ep;\n\tmutex_unlock(&chan->lock);\n\n\tif (in_fifo) {\n\t\tu32 in_checkpoint = 0;\n\n\t\tif (!chan->in_synchronous)\n\t\t\tin_checkpoint = in_fifo->size >>\n\t\t\t\tchan->in_log2_element_size;\n\n\t\tchan->in_consumed_bytes = 0;\n\t\tchan->poll_used = 0;\n\t\tchan->in_current_checkpoint = in_checkpoint;\n\t\trc = xillyusb_send_opcode(xdev, (chan->chan_idx << 1) | 1,\n\t\t\t\t\t  OPCODE_SET_CHECKPOINT,\n\t\t\t\t\t  in_checkpoint);\n\n\t\tif (rc)  \n\t\t\tgoto unfifo;\n\n\t\t \n\t\tif (filp->f_flags & O_NONBLOCK)\n\t\t\trequest_read_anything(chan, OPCODE_SET_PUSH);\n\t}\n\n\treturn 0;\n\nunfifo:\n\tchan->read_data_ok = 0;\n\tsafely_assign_in_fifo(chan, NULL);\n\tfifo_mem_release(in_fifo);\n\tkfree(in_fifo);\n\n\tif (out_ep) {\n\t\tmutex_lock(&chan->lock);\n\t\tchan->out_ep = NULL;\n\t\tmutex_unlock(&chan->lock);\n\t}\n\nlate_unopen:\n\tif (out_ep)\n\t\tendpoint_dealloc(out_ep);\n\nunopen:\n\tmutex_lock(&chan->lock);\n\n\tif (filp->f_mode & FMODE_READ)\n\t\tchan->open_for_read = 0;\n\n\tif (filp->f_mode & FMODE_WRITE)\n\t\tchan->open_for_write = 0;\n\n\tmutex_unlock(&chan->lock);\n\n\tkref_put(&xdev->kref, cleanup_dev);\n\n\treturn rc;\n\nunmutex_fail:\n\tkref_put(&xdev->kref, cleanup_dev);\n\tmutex_unlock(&chan->lock);\n\treturn rc;\n}\n\nstatic ssize_t xillyusb_read(struct file *filp, char __user *userbuf,\n\t\t\t     size_t count, loff_t *f_pos)\n{\n\tstruct xillyusb_channel *chan = filp->private_data;\n\tstruct xillyusb_dev *xdev = chan->xdev;\n\tstruct xillyfifo *fifo = chan->in_fifo;\n\tint chan_num = (chan->chan_idx << 1) | 1;\n\n\tlong deadline, left_to_sleep;\n\tint bytes_done = 0;\n\tbool sent_set_push = false;\n\tint rc;\n\n\tdeadline = jiffies + 1 + XILLY_RX_TIMEOUT;\n\n\trc = mutex_lock_interruptible(&chan->in_mutex);\n\n\tif (rc)\n\t\treturn rc;\n\n\twhile (1) {\n\t\tu32 fifo_checkpoint_bytes, complete_checkpoint_bytes;\n\t\tu32 complete_checkpoint, fifo_checkpoint;\n\t\tu32 checkpoint;\n\t\ts32 diff, leap;\n\t\tunsigned int sh = chan->in_log2_element_size;\n\t\tbool checkpoint_for_complete;\n\n\t\trc = fifo_read(fifo, (__force void *)userbuf + bytes_done,\n\t\t\t       count - bytes_done, xilly_copy_to_user);\n\n\t\tif (rc < 0)\n\t\t\tbreak;\n\n\t\tbytes_done += rc;\n\t\tchan->in_consumed_bytes += rc;\n\n\t\tleft_to_sleep = deadline - ((long)jiffies);\n\n\t\t \n\n\t\tfifo_checkpoint_bytes = chan->in_consumed_bytes + fifo->size;\n\t\tcomplete_checkpoint_bytes =\n\t\t\tchan->in_consumed_bytes + count - bytes_done;\n\n\t\tfifo_checkpoint = fifo_checkpoint_bytes >> sh;\n\t\tcomplete_checkpoint =\n\t\t\t(complete_checkpoint_bytes + (1 << sh) - 1) >> sh;\n\n\t\tdiff = (fifo_checkpoint - complete_checkpoint) << sh;\n\n\t\tif (chan->in_synchronous && diff >= 0) {\n\t\t\tcheckpoint = complete_checkpoint;\n\t\t\tcheckpoint_for_complete = true;\n\t\t} else {\n\t\t\tcheckpoint = fifo_checkpoint;\n\t\t\tcheckpoint_for_complete = false;\n\t\t}\n\n\t\tleap = (checkpoint - chan->in_current_checkpoint) << sh;\n\n\t\t \n\n\t\tif (chan->read_data_ok &&\n\t\t    (leap > (fifo->size >> 3) ||\n\t\t     (checkpoint_for_complete && leap > 0))) {\n\t\t\tchan->in_current_checkpoint = checkpoint;\n\t\t\trc = xillyusb_send_opcode(xdev, chan_num,\n\t\t\t\t\t\t  OPCODE_SET_CHECKPOINT,\n\t\t\t\t\t\t  checkpoint);\n\n\t\t\tif (rc)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (bytes_done == count ||\n\t\t    (left_to_sleep <= 0 && bytes_done))\n\t\t\tbreak;\n\n\t\t \n\n\t\tif (!READ_ONCE(chan->read_data_ok)) {  \n\t\t\t \n\t\t\tsmp_rmb();\n\t\t\tif (READ_ONCE(fifo->fill))\n\t\t\t\tcontinue;\n\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (xdev->error) {\n\t\t\trc = xdev->error;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (filp->f_flags & O_NONBLOCK) {\n\t\t\trc = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!sent_set_push) {\n\t\t\trc = xillyusb_send_opcode(xdev, chan_num,\n\t\t\t\t\t\t  OPCODE_SET_PUSH,\n\t\t\t\t\t\t  complete_checkpoint);\n\n\t\t\tif (rc)\n\t\t\t\tbreak;\n\n\t\t\tsent_set_push = true;\n\t\t}\n\n\t\tif (left_to_sleep > 0) {\n\t\t\t \n\n\t\t\trc = wait_event_interruptible_timeout\n\t\t\t\t(fifo->waitq,\n\t\t\t\t fifo->fill || !chan->read_data_ok,\n\t\t\t\t left_to_sleep);\n\t\t} else {  \n\t\t\t \n\t\t\trc = request_read_anything(chan, OPCODE_UPDATE_PUSH);\n\n\t\t\tif (rc)\n\t\t\t\tbreak;\n\n\t\t\trc = wait_event_interruptible\n\t\t\t\t(fifo->waitq,\n\t\t\t\t fifo->fill || !chan->read_data_ok);\n\t\t}\n\n\t\tif (rc < 0) {\n\t\t\trc = -EINTR;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (((filp->f_flags & O_NONBLOCK) || chan->poll_used) &&\n\t    !READ_ONCE(fifo->fill))\n\t\trequest_read_anything(chan, OPCODE_SET_PUSH);\n\n\tmutex_unlock(&chan->in_mutex);\n\n\tif (bytes_done)\n\t\treturn bytes_done;\n\n\treturn rc;\n}\n\nstatic int xillyusb_flush(struct file *filp, fl_owner_t id)\n{\n\tstruct xillyusb_channel *chan = filp->private_data;\n\tint rc;\n\n\tif (!(filp->f_mode & FMODE_WRITE))\n\t\treturn 0;\n\n\trc = mutex_lock_interruptible(&chan->out_mutex);\n\n\tif (rc)\n\t\treturn rc;\n\n\t \n\trc = flush_downstream(chan, HZ, false);\n\n\tmutex_unlock(&chan->out_mutex);\n\n\tif (rc == -ETIMEDOUT) {\n\t\t \n\t\tstruct xillyusb_dev *xdev = chan->xdev;\n\n\t\tmutex_lock(&chan->lock);\n\t\tif (!xdev->error)\n\t\t\tdev_warn(xdev->dev,\n\t\t\t\t \"Timed out while flushing. Output data may be lost.\\n\");\n\t\tmutex_unlock(&chan->lock);\n\t}\n\n\treturn rc;\n}\n\nstatic ssize_t xillyusb_write(struct file *filp, const char __user *userbuf,\n\t\t\t      size_t count, loff_t *f_pos)\n{\n\tstruct xillyusb_channel *chan = filp->private_data;\n\tstruct xillyusb_dev *xdev = chan->xdev;\n\tstruct xillyfifo *fifo = &chan->out_ep->fifo;\n\tint rc;\n\n\trc = mutex_lock_interruptible(&chan->out_mutex);\n\n\tif (rc)\n\t\treturn rc;\n\n\twhile (1) {\n\t\tif (xdev->error) {\n\t\t\trc = xdev->error;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (count == 0)\n\t\t\tbreak;\n\n\t\trc = fifo_write(fifo, (__force void *)userbuf, count,\n\t\t\t\txilly_copy_from_user);\n\n\t\tif (rc != 0)\n\t\t\tbreak;\n\n\t\tif (filp->f_flags & O_NONBLOCK) {\n\t\t\trc = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (wait_event_interruptible\n\t\t    (fifo->waitq,\n\t\t     fifo->fill != fifo->size || xdev->error)) {\n\t\t\trc = -EINTR;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (rc < 0)\n\t\tgoto done;\n\n\tchan->out_bytes += rc;\n\n\tif (rc) {\n\t\ttry_queue_bulk_out(chan->out_ep);\n\t\tchan->flushed = 0;\n\t}\n\n\tif (chan->out_synchronous) {\n\t\tint flush_rc = flush_downstream(chan, 0, true);\n\n\t\tif (flush_rc && !rc)\n\t\t\trc = flush_rc;\n\t}\n\ndone:\n\tmutex_unlock(&chan->out_mutex);\n\n\treturn rc;\n}\n\nstatic int xillyusb_release(struct inode *inode, struct file *filp)\n{\n\tstruct xillyusb_channel *chan = filp->private_data;\n\tstruct xillyusb_dev *xdev = chan->xdev;\n\tint rc_read = 0, rc_write = 0;\n\n\tif (filp->f_mode & FMODE_READ) {\n\t\tstruct xillyfifo *in_fifo = chan->in_fifo;\n\n\t\trc_read = xillyusb_send_opcode(xdev, (chan->chan_idx << 1) | 1,\n\t\t\t\t\t       OPCODE_CLOSE, 0);\n\t\t \n\n\t\twhile (wait_event_interruptible(in_fifo->waitq,\n\t\t\t\t\t\t!chan->read_data_ok))\n\t\t\t;  \n\n\t\tsafely_assign_in_fifo(chan, NULL);\n\t\tfifo_mem_release(in_fifo);\n\t\tkfree(in_fifo);\n\n\t\tmutex_lock(&chan->lock);\n\t\tchan->open_for_read = 0;\n\t\tmutex_unlock(&chan->lock);\n\t}\n\n\tif (filp->f_mode & FMODE_WRITE) {\n\t\tstruct xillyusb_endpoint *ep = chan->out_ep;\n\t\t \n\n\t\tmutex_lock(&chan->lock);\n\t\tchan->out_ep = NULL;\n\t\tmutex_unlock(&chan->lock);\n\n\t\tendpoint_quiesce(ep);\n\t\tendpoint_dealloc(ep);\n\n\t\t \n\t\trc_write = xillyusb_send_opcode(xdev, chan->chan_idx << 1,\n\t\t\t\t\t\tOPCODE_CLOSE, 0);\n\n\t\tmutex_lock(&chan->lock);\n\t\tchan->open_for_write = 0;\n\t\tmutex_unlock(&chan->lock);\n\t}\n\n\tkref_put(&xdev->kref, cleanup_dev);\n\n\treturn rc_read ? rc_read : rc_write;\n}\n\n \n\nstatic loff_t xillyusb_llseek(struct file *filp, loff_t offset, int whence)\n{\n\tstruct xillyusb_channel *chan = filp->private_data;\n\tstruct xillyusb_dev *xdev = chan->xdev;\n\tloff_t pos = filp->f_pos;\n\tint rc = 0;\n\tunsigned int log2_element_size = chan->readable ?\n\t\tchan->in_log2_element_size : chan->out_log2_element_size;\n\n\t \n\n\tmutex_lock(&chan->out_mutex);\n\tmutex_lock(&chan->in_mutex);\n\n\tswitch (whence) {\n\tcase SEEK_SET:\n\t\tpos = offset;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\tpos += offset;\n\t\tbreak;\n\tcase SEEK_END:\n\t\tpos = offset;  \n\t\tbreak;\n\tdefault:\n\t\trc = -EINVAL;\n\t\tgoto end;\n\t}\n\n\t \n\tif (pos & ((1 << log2_element_size) - 1)) {\n\t\trc = -EINVAL;\n\t\tgoto end;\n\t}\n\n\trc = xillyusb_send_opcode(xdev, chan->chan_idx << 1,\n\t\t\t\t  OPCODE_SET_ADDR,\n\t\t\t\t  pos >> log2_element_size);\n\n\tif (rc)\n\t\tgoto end;\n\n\tif (chan->writable) {\n\t\tchan->flushed = 0;\n\t\trc = flush_downstream(chan, HZ, false);\n\t}\n\nend:\n\tmutex_unlock(&chan->out_mutex);\n\tmutex_unlock(&chan->in_mutex);\n\n\tif (rc)  \n\t\treturn rc;\n\n\tfilp->f_pos = pos;\n\n\treturn pos;\n}\n\nstatic __poll_t xillyusb_poll(struct file *filp, poll_table *wait)\n{\n\tstruct xillyusb_channel *chan = filp->private_data;\n\t__poll_t mask = 0;\n\n\tif (chan->in_fifo)\n\t\tpoll_wait(filp, &chan->in_fifo->waitq, wait);\n\n\tif (chan->out_ep)\n\t\tpoll_wait(filp, &chan->out_ep->fifo.waitq, wait);\n\n\t \n\n\tif (!chan->poll_used && chan->in_fifo) {\n\t\tchan->poll_used = 1;\n\t\trequest_read_anything(chan, OPCODE_SET_PUSH);\n\t}\n\n\t \n\n\tif (chan->in_fifo && !chan->in_synchronous &&\n\t    (READ_ONCE(chan->in_fifo->fill) || !chan->read_data_ok))\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\n\tif (chan->out_ep &&\n\t    (READ_ONCE(chan->out_ep->fifo.fill) != chan->out_ep->fifo.size))\n\t\tmask |= EPOLLOUT | EPOLLWRNORM;\n\n\tif (chan->xdev->error)\n\t\tmask |= EPOLLERR;\n\n\treturn mask;\n}\n\nstatic const struct file_operations xillyusb_fops = {\n\t.owner      = THIS_MODULE,\n\t.read       = xillyusb_read,\n\t.write      = xillyusb_write,\n\t.open       = xillyusb_open,\n\t.flush      = xillyusb_flush,\n\t.release    = xillyusb_release,\n\t.llseek     = xillyusb_llseek,\n\t.poll       = xillyusb_poll,\n};\n\nstatic int xillyusb_setup_base_eps(struct xillyusb_dev *xdev)\n{\n\txdev->msg_ep = endpoint_alloc(xdev, MSG_EP_NUM | USB_DIR_OUT,\n\t\t\t\t      bulk_out_work, 1, 2);\n\tif (!xdev->msg_ep)\n\t\treturn -ENOMEM;\n\n\tif (fifo_init(&xdev->msg_ep->fifo, 13))  \n\t\tgoto dealloc;\n\n\txdev->msg_ep->fill_mask = -8;  \n\n\txdev->in_ep = endpoint_alloc(xdev, IN_EP_NUM | USB_DIR_IN,\n\t\t\t\t     bulk_in_work, BUF_SIZE_ORDER, BUFNUM);\n\tif (!xdev->in_ep)\n\t\tgoto dealloc;\n\n\ttry_queue_bulk_in(xdev->in_ep);\n\n\treturn 0;\n\ndealloc:\n\tendpoint_dealloc(xdev->msg_ep);  \n\txdev->msg_ep = NULL;\n\treturn -ENOMEM;\n}\n\nstatic int setup_channels(struct xillyusb_dev *xdev,\n\t\t\t  __le16 *chandesc,\n\t\t\t  int num_channels)\n{\n\tstruct xillyusb_channel *chan;\n\tint i;\n\n\tchan = kcalloc(num_channels, sizeof(*chan), GFP_KERNEL);\n\tif (!chan)\n\t\treturn -ENOMEM;\n\n\txdev->channels = chan;\n\n\tfor (i = 0; i < num_channels; i++, chan++) {\n\t\tunsigned int in_desc = le16_to_cpu(*chandesc++);\n\t\tunsigned int out_desc = le16_to_cpu(*chandesc++);\n\n\t\tchan->xdev = xdev;\n\t\tmutex_init(&chan->in_mutex);\n\t\tmutex_init(&chan->out_mutex);\n\t\tmutex_init(&chan->lock);\n\t\tinit_waitqueue_head(&chan->flushq);\n\n\t\tchan->chan_idx = i;\n\n\t\tif (in_desc & 0x80) {  \n\t\t\tchan->readable = 1;\n\t\t\tchan->in_synchronous = !!(in_desc & 0x40);\n\t\t\tchan->in_seekable = !!(in_desc & 0x20);\n\t\t\tchan->in_log2_element_size = in_desc & 0x0f;\n\t\t\tchan->in_log2_fifo_size = ((in_desc >> 8) & 0x1f) + 16;\n\t\t}\n\n\t\t \n\n\t\tif ((out_desc & 0x80) && i < 14) {  \n\t\t\tchan->writable = 1;\n\t\t\tchan->out_synchronous = !!(out_desc & 0x40);\n\t\t\tchan->out_seekable = !!(out_desc & 0x20);\n\t\t\tchan->out_log2_element_size = out_desc & 0x0f;\n\t\t\tchan->out_log2_fifo_size =\n\t\t\t\t((out_desc >> 8) & 0x1f) + 16;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int xillyusb_discovery(struct usb_interface *interface)\n{\n\tint rc;\n\tstruct xillyusb_dev *xdev = usb_get_intfdata(interface);\n\t__le16 bogus_chandesc[2];\n\tstruct xillyfifo idt_fifo;\n\tstruct xillyusb_channel *chan;\n\tunsigned int idt_len, names_offset;\n\tunsigned char *idt;\n\tint num_channels;\n\n\trc = xillyusb_send_opcode(xdev, ~0, OPCODE_QUIESCE, 0);\n\n\tif (rc) {\n\t\tdev_err(&interface->dev, \"Failed to send quiesce request. Aborting.\\n\");\n\t\treturn rc;\n\t}\n\n\t \n\n\t \n\tbogus_chandesc[0] = cpu_to_le16(0x80);\n\tbogus_chandesc[1] = cpu_to_le16(0);\n\n\trc = setup_channels(xdev, bogus_chandesc, 1);\n\n\tif (rc)\n\t\treturn rc;\n\n\trc = fifo_init(&idt_fifo, LOG2_IDT_FIFO_SIZE);\n\n\tif (rc)\n\t\treturn rc;\n\n\tchan = xdev->channels;\n\n\tchan->in_fifo = &idt_fifo;\n\tchan->read_data_ok = 1;\n\n\txdev->num_channels = 1;\n\n\trc = xillyusb_send_opcode(xdev, ~0, OPCODE_REQ_IDT, 0);\n\n\tif (rc) {\n\t\tdev_err(&interface->dev, \"Failed to send IDT request. Aborting.\\n\");\n\t\tgoto unfifo;\n\t}\n\n\trc = wait_event_interruptible_timeout(idt_fifo.waitq,\n\t\t\t\t\t      !chan->read_data_ok,\n\t\t\t\t\t      XILLY_RESPONSE_TIMEOUT);\n\n\tif (xdev->error) {\n\t\trc = xdev->error;\n\t\tgoto unfifo;\n\t}\n\n\tif (rc < 0) {\n\t\trc = -EINTR;  \n\t\tgoto unfifo;\n\t}\n\n\tif (chan->read_data_ok) {\n\t\trc = -ETIMEDOUT;\n\t\tdev_err(&interface->dev, \"No response from FPGA. Aborting.\\n\");\n\t\tgoto unfifo;\n\t}\n\n\tidt_len = READ_ONCE(idt_fifo.fill);\n\tidt = kmalloc(idt_len, GFP_KERNEL);\n\n\tif (!idt) {\n\t\trc = -ENOMEM;\n\t\tgoto unfifo;\n\t}\n\n\tfifo_read(&idt_fifo, idt, idt_len, xilly_memcpy);\n\n\tif (crc32_le(~0, idt, idt_len) != 0) {\n\t\tdev_err(&interface->dev, \"IDT failed CRC check. Aborting.\\n\");\n\t\trc = -ENODEV;\n\t\tgoto unidt;\n\t}\n\n\tif (*idt > 0x90) {\n\t\tdev_err(&interface->dev, \"No support for IDT version 0x%02x. Maybe the xillyusb driver needs an upgrade. Aborting.\\n\",\n\t\t\t(int)*idt);\n\t\trc = -ENODEV;\n\t\tgoto unidt;\n\t}\n\n\t \n\n\tnum_channels = le16_to_cpu(*((__le16 *)(idt + 1)));\n\tnames_offset = 3 + num_channels * 4;\n\tidt_len -= 4;  \n\n\tif (idt_len < names_offset) {\n\t\tdev_err(&interface->dev, \"IDT too short. This is exceptionally weird, because its CRC is OK\\n\");\n\t\trc = -ENODEV;\n\t\tgoto unidt;\n\t}\n\n\trc = setup_channels(xdev, (void *)idt + 3, num_channels);\n\n\tif (rc)\n\t\tgoto unidt;\n\n\t \n\tflush_workqueue(xdev->workq);\n\n\txdev->num_channels = num_channels;\n\n\tfifo_mem_release(&idt_fifo);\n\tkfree(chan);\n\n\trc = xillybus_init_chrdev(&interface->dev, &xillyusb_fops,\n\t\t\t\t  THIS_MODULE, xdev,\n\t\t\t\t  idt + names_offset,\n\t\t\t\t  idt_len - names_offset,\n\t\t\t\t  num_channels,\n\t\t\t\t  xillyname, true);\n\n\tkfree(idt);\n\n\treturn rc;\n\nunidt:\n\tkfree(idt);\n\nunfifo:\n\tsafely_assign_in_fifo(chan, NULL);\n\tfifo_mem_release(&idt_fifo);\n\n\treturn rc;\n}\n\nstatic int xillyusb_probe(struct usb_interface *interface,\n\t\t\t  const struct usb_device_id *id)\n{\n\tstruct xillyusb_dev *xdev;\n\tint rc;\n\n\txdev = kzalloc(sizeof(*xdev), GFP_KERNEL);\n\tif (!xdev)\n\t\treturn -ENOMEM;\n\n\tkref_init(&xdev->kref);\n\tmutex_init(&xdev->process_in_mutex);\n\tmutex_init(&xdev->msg_mutex);\n\n\txdev->udev = usb_get_dev(interface_to_usbdev(interface));\n\txdev->dev = &interface->dev;\n\txdev->error = 0;\n\tspin_lock_init(&xdev->error_lock);\n\txdev->in_counter = 0;\n\txdev->in_bytes_left = 0;\n\txdev->workq = alloc_workqueue(xillyname, WQ_HIGHPRI, 0);\n\n\tif (!xdev->workq) {\n\t\tdev_err(&interface->dev, \"Failed to allocate work queue\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tINIT_WORK(&xdev->wakeup_workitem, wakeup_all);\n\n\tusb_set_intfdata(interface, xdev);\n\n\trc = xillyusb_setup_base_eps(xdev);\n\tif (rc)\n\t\tgoto fail;\n\n\trc = xillyusb_discovery(interface);\n\tif (rc)\n\t\tgoto latefail;\n\n\treturn 0;\n\nlatefail:\n\tendpoint_quiesce(xdev->in_ep);\n\tendpoint_quiesce(xdev->msg_ep);\n\nfail:\n\tusb_set_intfdata(interface, NULL);\n\tkref_put(&xdev->kref, cleanup_dev);\n\treturn rc;\n}\n\nstatic void xillyusb_disconnect(struct usb_interface *interface)\n{\n\tstruct xillyusb_dev *xdev = usb_get_intfdata(interface);\n\tstruct xillyusb_endpoint *msg_ep = xdev->msg_ep;\n\tstruct xillyfifo *fifo = &msg_ep->fifo;\n\tint rc;\n\tint i;\n\n\txillybus_cleanup_chrdev(xdev, &interface->dev);\n\n\t \n\n\tmsg_ep->wake_on_drain = true;\n\txillyusb_send_opcode(xdev, ~0, OPCODE_QUIESCE, 0);\n\n\t \n\n\trc = wait_event_interruptible_timeout(fifo->waitq,\n\t\t\t\t\t      msg_ep->drained || xdev->error,\n\t\t\t\t\t      XILLY_RESPONSE_TIMEOUT);\n\n\tif (!rc)\n\t\tdev_err(&interface->dev,\n\t\t\t\"Weird timeout condition on sending quiesce request.\\n\");\n\n\treport_io_error(xdev, -ENODEV);  \n\n\t \n\n\tfor (i = 0; i < xdev->num_channels; i++) {\n\t\tstruct xillyusb_channel *chan = &xdev->channels[i];\n\n\t\t \n\t\tmutex_lock(&chan->lock);\n\t\tif (chan->out_ep)\n\t\t\tendpoint_quiesce(chan->out_ep);\n\t\tmutex_unlock(&chan->lock);\n\t}\n\n\tendpoint_quiesce(xdev->in_ep);\n\tendpoint_quiesce(xdev->msg_ep);\n\n\tusb_set_intfdata(interface, NULL);\n\n\txdev->dev = NULL;\n\n\tmutex_lock(&kref_mutex);\n\tkref_put(&xdev->kref, cleanup_dev);\n\tmutex_unlock(&kref_mutex);\n}\n\nstatic struct usb_driver xillyusb_driver = {\n\t.name = xillyname,\n\t.id_table = xillyusb_table,\n\t.probe = xillyusb_probe,\n\t.disconnect = xillyusb_disconnect,\n\t.soft_unbind = 1,\n};\n\nstatic int __init xillyusb_init(void)\n{\n\tint rc = 0;\n\n\tif (LOG2_INITIAL_FIFO_BUF_SIZE > PAGE_SHIFT)\n\t\tfifo_buf_order = LOG2_INITIAL_FIFO_BUF_SIZE - PAGE_SHIFT;\n\telse\n\t\tfifo_buf_order = 0;\n\n\trc = usb_register(&xillyusb_driver);\n\n\treturn rc;\n}\n\nstatic void __exit xillyusb_exit(void)\n{\n\tusb_deregister(&xillyusb_driver);\n}\n\nmodule_init(xillyusb_init);\nmodule_exit(xillyusb_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}