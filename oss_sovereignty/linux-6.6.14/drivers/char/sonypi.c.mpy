{
  "module_name": "sonypi.c",
  "hash_id": "9418af4cdacb3d4f331f422ced9b2480d4a70c05915a4f3688b8b2d4c7175f22",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/sonypi.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/input.h>\n#include <linux/pci.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/miscdevice.h>\n#include <linux/poll.h>\n#include <linux/delay.h>\n#include <linux/wait.h>\n#include <linux/acpi.h>\n#include <linux/dmi.h>\n#include <linux/err.h>\n#include <linux/kfifo.h>\n#include <linux/platform_device.h>\n#include <linux/gfp.h>\n\n#include <linux/uaccess.h>\n#include <asm/io.h>\n\n#include <linux/sonypi.h>\n\n#define SONYPI_DRIVER_VERSION\t \"1.26\"\n\nMODULE_AUTHOR(\"Stelian Pop <stelian@popies.net>\");\nMODULE_DESCRIPTION(\"Sony Programmable I/O Control Device driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(SONYPI_DRIVER_VERSION);\n\nstatic int minor = -1;\nmodule_param(minor, int, 0);\nMODULE_PARM_DESC(minor,\n\t\t \"minor number of the misc device, default is -1 (automatic)\");\n\nstatic int verbose;\t\t \nmodule_param(verbose, int, 0644);\nMODULE_PARM_DESC(verbose, \"be verbose, default is 0 (no)\");\n\nstatic int fnkeyinit;\t\t \nmodule_param(fnkeyinit, int, 0444);\nMODULE_PARM_DESC(fnkeyinit,\n\t\t \"set this if your Fn keys do not generate any event\");\n\nstatic int camera;\t\t \nmodule_param(camera, int, 0444);\nMODULE_PARM_DESC(camera,\n\t\t \"set this if you have a MotionEye camera (PictureBook series)\");\n\nstatic int compat;\t\t \nmodule_param(compat, int, 0444);\nMODULE_PARM_DESC(compat,\n\t\t \"set this if you want to enable backward compatibility mode\");\n\nstatic unsigned long mask = 0xffffffff;\nmodule_param(mask, ulong, 0644);\nMODULE_PARM_DESC(mask,\n\t\t \"set this to the mask of event you want to enable (see doc)\");\n\nstatic int useinput = 1;\nmodule_param(useinput, int, 0444);\nMODULE_PARM_DESC(useinput,\n\t\t \"set this if you would like sonypi to feed events to the input subsystem\");\n\nstatic int check_ioport = 1;\nmodule_param(check_ioport, int, 0444);\nMODULE_PARM_DESC(check_ioport,\n\t\t \"set this to 0 if you think the automatic ioport check for sony-laptop is wrong\");\n\n#define SONYPI_DEVICE_MODEL_TYPE1\t1\n#define SONYPI_DEVICE_MODEL_TYPE2\t2\n#define SONYPI_DEVICE_MODEL_TYPE3\t3\n\n \n#define SONYPI_IRQ_PORT\t\t\t0x8034\n#define SONYPI_IRQ_SHIFT\t\t22\n#define SONYPI_TYPE1_BASE\t\t0x50\n#define SONYPI_G10A\t\t\t(SONYPI_TYPE1_BASE+0x14)\n#define SONYPI_TYPE1_REGION_SIZE\t0x08\n#define SONYPI_TYPE1_EVTYPE_OFFSET\t0x04\n\n \n#define SONYPI_SIRQ\t\t\t0x9b\n#define SONYPI_SLOB\t\t\t0x9c\n#define SONYPI_SHIB\t\t\t0x9d\n#define SONYPI_TYPE2_REGION_SIZE\t0x20\n#define SONYPI_TYPE2_EVTYPE_OFFSET\t0x12\n\n \n#define SONYPI_TYPE3_BASE\t\t0x40\n#define SONYPI_TYPE3_GID2\t\t(SONYPI_TYPE3_BASE+0x48)  \n#define SONYPI_TYPE3_MISC\t\t(SONYPI_TYPE3_BASE+0x6d)  \n#define SONYPI_TYPE3_REGION_SIZE\t0x20\n#define SONYPI_TYPE3_EVTYPE_OFFSET\t0x12\n\n \n#define SONYPI_BAT_FLAGS\t0x81\n#define SONYPI_LCD_LIGHT\t0x96\n#define SONYPI_BAT1_PCTRM\t0xa0\n#define SONYPI_BAT1_LEFT\t0xa2\n#define SONYPI_BAT1_MAXRT\t0xa4\n#define SONYPI_BAT2_PCTRM\t0xa8\n#define SONYPI_BAT2_LEFT\t0xaa\n#define SONYPI_BAT2_MAXRT\t0xac\n#define SONYPI_BAT1_MAXTK\t0xb0\n#define SONYPI_BAT1_FULL\t0xb2\n#define SONYPI_BAT2_MAXTK\t0xb8\n#define SONYPI_BAT2_FULL\t0xba\n\n \n#define SONYPI_FAN0_STATUS\t0x93\n#define SONYPI_TEMP_STATUS\t0xC1\n\n \n#define SONYPI_DATA_IOPORT\t0x62\n#define SONYPI_CST_IOPORT\t0x66\n\n \nstruct sonypi_ioport_list {\n\tu16\tport1;\n\tu16\tport2;\n};\n\nstatic struct sonypi_ioport_list sonypi_type1_ioport_list[] = {\n\t{ 0x10c0, 0x10c4 },\t \n\t{ 0x1080, 0x1084 },\n\t{ 0x1090, 0x1094 },\n\t{ 0x10a0, 0x10a4 },\n\t{ 0x10b0, 0x10b4 },\n\t{ 0x0, 0x0 }\n};\n\nstatic struct sonypi_ioport_list sonypi_type2_ioport_list[] = {\n\t{ 0x1080, 0x1084 },\n\t{ 0x10a0, 0x10a4 },\n\t{ 0x10c0, 0x10c4 },\n\t{ 0x10e0, 0x10e4 },\n\t{ 0x0, 0x0 }\n};\n\n \nstatic struct sonypi_ioport_list *sonypi_type3_ioport_list =\n\tsonypi_type2_ioport_list;\n\n \nstruct sonypi_irq_list {\n\tu16\tirq;\n\tu16\tbits;\n};\n\nstatic struct sonypi_irq_list sonypi_type1_irq_list[] = {\n\t{ 11, 0x2 },\t \n\t{ 10, 0x1 },\t \n\t{  5, 0x0 },\t \n\t{  0, 0x3 }\t \n};\n\nstatic struct sonypi_irq_list sonypi_type2_irq_list[] = {\n\t{ 11, 0x80 },\t \n\t{ 10, 0x40 },\t \n\t{  9, 0x20 },\t \n\t{  6, 0x10 },\t \n\t{  0, 0x00 }\t \n};\n\n \nstatic struct sonypi_irq_list *sonypi_type3_irq_list = sonypi_type2_irq_list;\n\n#define SONYPI_CAMERA_BRIGHTNESS\t\t0\n#define SONYPI_CAMERA_CONTRAST\t\t\t1\n#define SONYPI_CAMERA_HUE\t\t\t2\n#define SONYPI_CAMERA_COLOR\t\t\t3\n#define SONYPI_CAMERA_SHARPNESS\t\t\t4\n\n#define SONYPI_CAMERA_PICTURE\t\t\t5\n#define SONYPI_CAMERA_EXPOSURE_MASK\t\t0xC\n#define SONYPI_CAMERA_WHITE_BALANCE_MASK\t0x3\n#define SONYPI_CAMERA_PICTURE_MODE_MASK\t\t0x30\n#define SONYPI_CAMERA_MUTE_MASK\t\t\t0x40\n\n \n#define SONYPI_CAMERA_AGC\t\t\t6\n#define SONYPI_CAMERA_AGC_MASK\t\t\t0x30\n#define SONYPI_CAMERA_SHUTTER_MASK \t\t0x7\n\n#define SONYPI_CAMERA_SHUTDOWN_REQUEST\t\t7\n#define SONYPI_CAMERA_CONTROL\t\t\t0x10\n\n#define SONYPI_CAMERA_STATUS \t\t\t7\n#define SONYPI_CAMERA_STATUS_READY \t\t0x2\n#define SONYPI_CAMERA_STATUS_POSITION\t\t0x4\n\n#define SONYPI_DIRECTION_BACKWARDS \t\t0x4\n\n#define SONYPI_CAMERA_REVISION \t\t\t8\n#define SONYPI_CAMERA_ROMVERSION \t\t9\n\n \n#define SONYPI_JOGGER_MASK\t\t\t0x00000001\n#define SONYPI_CAPTURE_MASK\t\t\t0x00000002\n#define SONYPI_FNKEY_MASK\t\t\t0x00000004\n#define SONYPI_BLUETOOTH_MASK\t\t\t0x00000008\n#define SONYPI_PKEY_MASK\t\t\t0x00000010\n#define SONYPI_BACK_MASK\t\t\t0x00000020\n#define SONYPI_HELP_MASK\t\t\t0x00000040\n#define SONYPI_LID_MASK\t\t\t\t0x00000080\n#define SONYPI_ZOOM_MASK\t\t\t0x00000100\n#define SONYPI_THUMBPHRASE_MASK\t\t\t0x00000200\n#define SONYPI_MEYE_MASK\t\t\t0x00000400\n#define SONYPI_MEMORYSTICK_MASK\t\t\t0x00000800\n#define SONYPI_BATTERY_MASK\t\t\t0x00001000\n#define SONYPI_WIRELESS_MASK\t\t\t0x00002000\n\nstruct sonypi_event {\n\tu8\tdata;\n\tu8\tevent;\n};\n\n \nstatic struct sonypi_event sonypi_releaseev[] = {\n\t{ 0x00, SONYPI_EVENT_ANYBUTTON_RELEASED },\n\t{ 0, 0 }\n};\n\n \nstatic struct sonypi_event sonypi_joggerev[] = {\n\t{ 0x1f, SONYPI_EVENT_JOGDIAL_UP },\n\t{ 0x01, SONYPI_EVENT_JOGDIAL_DOWN },\n\t{ 0x5f, SONYPI_EVENT_JOGDIAL_UP_PRESSED },\n\t{ 0x41, SONYPI_EVENT_JOGDIAL_DOWN_PRESSED },\n\t{ 0x1e, SONYPI_EVENT_JOGDIAL_FAST_UP },\n\t{ 0x02, SONYPI_EVENT_JOGDIAL_FAST_DOWN },\n\t{ 0x5e, SONYPI_EVENT_JOGDIAL_FAST_UP_PRESSED },\n\t{ 0x42, SONYPI_EVENT_JOGDIAL_FAST_DOWN_PRESSED },\n\t{ 0x1d, SONYPI_EVENT_JOGDIAL_VFAST_UP },\n\t{ 0x03, SONYPI_EVENT_JOGDIAL_VFAST_DOWN },\n\t{ 0x5d, SONYPI_EVENT_JOGDIAL_VFAST_UP_PRESSED },\n\t{ 0x43, SONYPI_EVENT_JOGDIAL_VFAST_DOWN_PRESSED },\n\t{ 0x40, SONYPI_EVENT_JOGDIAL_PRESSED },\n\t{ 0, 0 }\n};\n\n \nstatic struct sonypi_event sonypi_captureev[] = {\n\t{ 0x05, SONYPI_EVENT_CAPTURE_PARTIALPRESSED },\n\t{ 0x07, SONYPI_EVENT_CAPTURE_PRESSED },\n\t{ 0x01, SONYPI_EVENT_CAPTURE_PARTIALRELEASED },\n\t{ 0, 0 }\n};\n\n \nstatic struct sonypi_event sonypi_fnkeyev[] = {\n\t{ 0x10, SONYPI_EVENT_FNKEY_ESC },\n\t{ 0x11, SONYPI_EVENT_FNKEY_F1 },\n\t{ 0x12, SONYPI_EVENT_FNKEY_F2 },\n\t{ 0x13, SONYPI_EVENT_FNKEY_F3 },\n\t{ 0x14, SONYPI_EVENT_FNKEY_F4 },\n\t{ 0x15, SONYPI_EVENT_FNKEY_F5 },\n\t{ 0x16, SONYPI_EVENT_FNKEY_F6 },\n\t{ 0x17, SONYPI_EVENT_FNKEY_F7 },\n\t{ 0x18, SONYPI_EVENT_FNKEY_F8 },\n\t{ 0x19, SONYPI_EVENT_FNKEY_F9 },\n\t{ 0x1a, SONYPI_EVENT_FNKEY_F10 },\n\t{ 0x1b, SONYPI_EVENT_FNKEY_F11 },\n\t{ 0x1c, SONYPI_EVENT_FNKEY_F12 },\n\t{ 0x1f, SONYPI_EVENT_FNKEY_RELEASED },\n\t{ 0x21, SONYPI_EVENT_FNKEY_1 },\n\t{ 0x22, SONYPI_EVENT_FNKEY_2 },\n\t{ 0x31, SONYPI_EVENT_FNKEY_D },\n\t{ 0x32, SONYPI_EVENT_FNKEY_E },\n\t{ 0x33, SONYPI_EVENT_FNKEY_F },\n\t{ 0x34, SONYPI_EVENT_FNKEY_S },\n\t{ 0x35, SONYPI_EVENT_FNKEY_B },\n\t{ 0x36, SONYPI_EVENT_FNKEY_ONLY },\n\t{ 0, 0 }\n};\n\n \nstatic struct sonypi_event sonypi_pkeyev[] = {\n\t{ 0x01, SONYPI_EVENT_PKEY_P1 },\n\t{ 0x02, SONYPI_EVENT_PKEY_P2 },\n\t{ 0x04, SONYPI_EVENT_PKEY_P3 },\n\t{ 0x5c, SONYPI_EVENT_PKEY_P1 },\n\t{ 0, 0 }\n};\n\n \nstatic struct sonypi_event sonypi_blueev[] = {\n\t{ 0x55, SONYPI_EVENT_BLUETOOTH_PRESSED },\n\t{ 0x59, SONYPI_EVENT_BLUETOOTH_ON },\n\t{ 0x5a, SONYPI_EVENT_BLUETOOTH_OFF },\n\t{ 0, 0 }\n};\n\n \nstatic struct sonypi_event sonypi_wlessev[] = {\n\t{ 0x59, SONYPI_EVENT_WIRELESS_ON },\n\t{ 0x5a, SONYPI_EVENT_WIRELESS_OFF },\n\t{ 0, 0 }\n};\n\n \nstatic struct sonypi_event sonypi_backev[] = {\n\t{ 0x20, SONYPI_EVENT_BACK_PRESSED },\n\t{ 0, 0 }\n};\n\n \nstatic struct sonypi_event sonypi_helpev[] = {\n\t{ 0x3b, SONYPI_EVENT_HELP_PRESSED },\n\t{ 0, 0 }\n};\n\n\n \nstatic struct sonypi_event sonypi_lidev[] = {\n\t{ 0x51, SONYPI_EVENT_LID_CLOSED },\n\t{ 0x50, SONYPI_EVENT_LID_OPENED },\n\t{ 0, 0 }\n};\n\n \nstatic struct sonypi_event sonypi_zoomev[] = {\n\t{ 0x39, SONYPI_EVENT_ZOOM_PRESSED },\n\t{ 0, 0 }\n};\n\n \nstatic struct sonypi_event sonypi_thumbphraseev[] = {\n\t{ 0x3a, SONYPI_EVENT_THUMBPHRASE_PRESSED },\n\t{ 0, 0 }\n};\n\n \nstatic struct sonypi_event sonypi_meyeev[] = {\n\t{ 0x00, SONYPI_EVENT_MEYE_FACE },\n\t{ 0x01, SONYPI_EVENT_MEYE_OPPOSITE },\n\t{ 0, 0 }\n};\n\n \nstatic struct sonypi_event sonypi_memorystickev[] = {\n\t{ 0x53, SONYPI_EVENT_MEMORYSTICK_INSERT },\n\t{ 0x54, SONYPI_EVENT_MEMORYSTICK_EJECT },\n\t{ 0, 0 }\n};\n\n \nstatic struct sonypi_event sonypi_batteryev[] = {\n\t{ 0x20, SONYPI_EVENT_BATTERY_INSERT },\n\t{ 0x30, SONYPI_EVENT_BATTERY_REMOVE },\n\t{ 0, 0 }\n};\n\nstatic struct sonypi_eventtypes {\n\tint\t\t\tmodel;\n\tu8\t\t\tdata;\n\tunsigned long\t\tmask;\n\tstruct sonypi_event *\tevents;\n} sonypi_eventtypes[] = {\n\t{ SONYPI_DEVICE_MODEL_TYPE1, 0, 0xffffffff, sonypi_releaseev },\n\t{ SONYPI_DEVICE_MODEL_TYPE1, 0x70, SONYPI_MEYE_MASK, sonypi_meyeev },\n\t{ SONYPI_DEVICE_MODEL_TYPE1, 0x30, SONYPI_LID_MASK, sonypi_lidev },\n\t{ SONYPI_DEVICE_MODEL_TYPE1, 0x60, SONYPI_CAPTURE_MASK, sonypi_captureev },\n\t{ SONYPI_DEVICE_MODEL_TYPE1, 0x10, SONYPI_JOGGER_MASK, sonypi_joggerev },\n\t{ SONYPI_DEVICE_MODEL_TYPE1, 0x20, SONYPI_FNKEY_MASK, sonypi_fnkeyev },\n\t{ SONYPI_DEVICE_MODEL_TYPE1, 0x30, SONYPI_BLUETOOTH_MASK, sonypi_blueev },\n\t{ SONYPI_DEVICE_MODEL_TYPE1, 0x40, SONYPI_PKEY_MASK, sonypi_pkeyev },\n\t{ SONYPI_DEVICE_MODEL_TYPE1, 0x30, SONYPI_MEMORYSTICK_MASK, sonypi_memorystickev },\n\t{ SONYPI_DEVICE_MODEL_TYPE1, 0x40, SONYPI_BATTERY_MASK, sonypi_batteryev },\n\n\t{ SONYPI_DEVICE_MODEL_TYPE2, 0, 0xffffffff, sonypi_releaseev },\n\t{ SONYPI_DEVICE_MODEL_TYPE2, 0x38, SONYPI_LID_MASK, sonypi_lidev },\n\t{ SONYPI_DEVICE_MODEL_TYPE2, 0x11, SONYPI_JOGGER_MASK, sonypi_joggerev },\n\t{ SONYPI_DEVICE_MODEL_TYPE2, 0x61, SONYPI_CAPTURE_MASK, sonypi_captureev },\n\t{ SONYPI_DEVICE_MODEL_TYPE2, 0x21, SONYPI_FNKEY_MASK, sonypi_fnkeyev },\n\t{ SONYPI_DEVICE_MODEL_TYPE2, 0x31, SONYPI_BLUETOOTH_MASK, sonypi_blueev },\n\t{ SONYPI_DEVICE_MODEL_TYPE2, 0x08, SONYPI_PKEY_MASK, sonypi_pkeyev },\n\t{ SONYPI_DEVICE_MODEL_TYPE2, 0x11, SONYPI_BACK_MASK, sonypi_backev },\n\t{ SONYPI_DEVICE_MODEL_TYPE2, 0x21, SONYPI_HELP_MASK, sonypi_helpev },\n\t{ SONYPI_DEVICE_MODEL_TYPE2, 0x21, SONYPI_ZOOM_MASK, sonypi_zoomev },\n\t{ SONYPI_DEVICE_MODEL_TYPE2, 0x20, SONYPI_THUMBPHRASE_MASK, sonypi_thumbphraseev },\n\t{ SONYPI_DEVICE_MODEL_TYPE2, 0x31, SONYPI_MEMORYSTICK_MASK, sonypi_memorystickev },\n\t{ SONYPI_DEVICE_MODEL_TYPE2, 0x41, SONYPI_BATTERY_MASK, sonypi_batteryev },\n\t{ SONYPI_DEVICE_MODEL_TYPE2, 0x31, SONYPI_PKEY_MASK, sonypi_pkeyev },\n\n\t{ SONYPI_DEVICE_MODEL_TYPE3, 0, 0xffffffff, sonypi_releaseev },\n\t{ SONYPI_DEVICE_MODEL_TYPE3, 0x21, SONYPI_FNKEY_MASK, sonypi_fnkeyev },\n\t{ SONYPI_DEVICE_MODEL_TYPE3, 0x31, SONYPI_WIRELESS_MASK, sonypi_wlessev },\n\t{ SONYPI_DEVICE_MODEL_TYPE3, 0x31, SONYPI_MEMORYSTICK_MASK, sonypi_memorystickev },\n\t{ SONYPI_DEVICE_MODEL_TYPE3, 0x41, SONYPI_BATTERY_MASK, sonypi_batteryev },\n\t{ SONYPI_DEVICE_MODEL_TYPE3, 0x31, SONYPI_PKEY_MASK, sonypi_pkeyev },\n\t{ 0 }\n};\n\n#define SONYPI_BUF_SIZE\t128\n\n \nstatic struct {\n\tint sonypiev;\n\tint inputev;\n} sonypi_inputkeys[] = {\n\t{ SONYPI_EVENT_CAPTURE_PRESSED,\t \tKEY_CAMERA },\n\t{ SONYPI_EVENT_FNKEY_ONLY, \t\tKEY_FN },\n\t{ SONYPI_EVENT_FNKEY_ESC, \t\tKEY_FN_ESC },\n\t{ SONYPI_EVENT_FNKEY_F1, \t\tKEY_FN_F1 },\n\t{ SONYPI_EVENT_FNKEY_F2, \t\tKEY_FN_F2 },\n\t{ SONYPI_EVENT_FNKEY_F3, \t\tKEY_FN_F3 },\n\t{ SONYPI_EVENT_FNKEY_F4, \t\tKEY_FN_F4 },\n\t{ SONYPI_EVENT_FNKEY_F5, \t\tKEY_FN_F5 },\n\t{ SONYPI_EVENT_FNKEY_F6, \t\tKEY_FN_F6 },\n\t{ SONYPI_EVENT_FNKEY_F7, \t\tKEY_FN_F7 },\n\t{ SONYPI_EVENT_FNKEY_F8, \t\tKEY_FN_F8 },\n\t{ SONYPI_EVENT_FNKEY_F9,\t\tKEY_FN_F9 },\n\t{ SONYPI_EVENT_FNKEY_F10,\t\tKEY_FN_F10 },\n\t{ SONYPI_EVENT_FNKEY_F11, \t\tKEY_FN_F11 },\n\t{ SONYPI_EVENT_FNKEY_F12,\t\tKEY_FN_F12 },\n\t{ SONYPI_EVENT_FNKEY_1, \t\tKEY_FN_1 },\n\t{ SONYPI_EVENT_FNKEY_2, \t\tKEY_FN_2 },\n\t{ SONYPI_EVENT_FNKEY_D,\t\t\tKEY_FN_D },\n\t{ SONYPI_EVENT_FNKEY_E,\t\t\tKEY_FN_E },\n\t{ SONYPI_EVENT_FNKEY_F,\t\t\tKEY_FN_F },\n\t{ SONYPI_EVENT_FNKEY_S,\t\t\tKEY_FN_S },\n\t{ SONYPI_EVENT_FNKEY_B,\t\t\tKEY_FN_B },\n\t{ SONYPI_EVENT_BLUETOOTH_PRESSED, \tKEY_BLUE },\n\t{ SONYPI_EVENT_BLUETOOTH_ON, \t\tKEY_BLUE },\n\t{ SONYPI_EVENT_PKEY_P1, \t\tKEY_PROG1 },\n\t{ SONYPI_EVENT_PKEY_P2, \t\tKEY_PROG2 },\n\t{ SONYPI_EVENT_PKEY_P3, \t\tKEY_PROG3 },\n\t{ SONYPI_EVENT_BACK_PRESSED, \t\tKEY_BACK },\n\t{ SONYPI_EVENT_HELP_PRESSED, \t\tKEY_HELP },\n\t{ SONYPI_EVENT_ZOOM_PRESSED, \t\tKEY_ZOOM },\n\t{ SONYPI_EVENT_THUMBPHRASE_PRESSED, \tBTN_THUMB },\n\t{ 0, 0 },\n};\n\nstruct sonypi_keypress {\n\tstruct input_dev *dev;\n\tint key;\n};\n\nstatic struct sonypi_device {\n\tstruct pci_dev *dev;\n\tu16 irq;\n\tu16 bits;\n\tu16 ioport1;\n\tu16 ioport2;\n\tu16 region_size;\n\tu16 evtype_offset;\n\tint camera_power;\n\tint bluetooth_power;\n\tstruct mutex lock;\n\tstruct kfifo fifo;\n\tspinlock_t fifo_lock;\n\twait_queue_head_t fifo_proc_list;\n\tstruct fasync_struct *fifo_async;\n\tint open_count;\n\tint model;\n\tstruct input_dev *input_jog_dev;\n\tstruct input_dev *input_key_dev;\n\tstruct work_struct input_work;\n\tstruct kfifo input_fifo;\n\tspinlock_t input_fifo_lock;\n} sonypi_device;\n\n#define ITERATIONS_LONG\t\t10000\n#define ITERATIONS_SHORT\t10\n\n#define wait_on_command(quiet, command, iterations) { \\\n\tunsigned int n = iterations; \\\n\twhile (--n && (command)) \\\n\t\tudelay(1); \\\n\tif (!n && (verbose || !quiet)) \\\n\t\tprintk(KERN_WARNING \"sonypi command failed at %s : %s (line %d)\\n\", __FILE__, __func__, __LINE__); \\\n}\n\n#ifdef CONFIG_ACPI\n#define SONYPI_ACPI_ACTIVE (!acpi_disabled)\n#else\n#define SONYPI_ACPI_ACTIVE 0\n#endif\t\t\t\t \n\n#ifdef CONFIG_ACPI\nstatic struct acpi_device *sonypi_acpi_device;\nstatic int acpi_driver_registered;\n#endif\n\nstatic int sonypi_ec_write(u8 addr, u8 value)\n{\n#ifdef CONFIG_ACPI\n\tif (SONYPI_ACPI_ACTIVE)\n\t\treturn ec_write(addr, value);\n#endif\n\twait_on_command(1, inb_p(SONYPI_CST_IOPORT) & 3, ITERATIONS_LONG);\n\toutb_p(0x81, SONYPI_CST_IOPORT);\n\twait_on_command(0, inb_p(SONYPI_CST_IOPORT) & 2, ITERATIONS_LONG);\n\toutb_p(addr, SONYPI_DATA_IOPORT);\n\twait_on_command(0, inb_p(SONYPI_CST_IOPORT) & 2, ITERATIONS_LONG);\n\toutb_p(value, SONYPI_DATA_IOPORT);\n\twait_on_command(0, inb_p(SONYPI_CST_IOPORT) & 2, ITERATIONS_LONG);\n\treturn 0;\n}\n\nstatic int sonypi_ec_read(u8 addr, u8 *value)\n{\n#ifdef CONFIG_ACPI\n\tif (SONYPI_ACPI_ACTIVE)\n\t\treturn ec_read(addr, value);\n#endif\n\twait_on_command(1, inb_p(SONYPI_CST_IOPORT) & 3, ITERATIONS_LONG);\n\toutb_p(0x80, SONYPI_CST_IOPORT);\n\twait_on_command(0, inb_p(SONYPI_CST_IOPORT) & 2, ITERATIONS_LONG);\n\toutb_p(addr, SONYPI_DATA_IOPORT);\n\twait_on_command(0, inb_p(SONYPI_CST_IOPORT) & 2, ITERATIONS_LONG);\n\t*value = inb_p(SONYPI_DATA_IOPORT);\n\treturn 0;\n}\n\nstatic int ec_read16(u8 addr, u16 *value)\n{\n\tu8 val_lb, val_hb;\n\tif (sonypi_ec_read(addr, &val_lb))\n\t\treturn -1;\n\tif (sonypi_ec_read(addr + 1, &val_hb))\n\t\treturn -1;\n\t*value = val_lb | (val_hb << 8);\n\treturn 0;\n}\n\n \nstatic void sonypi_type1_srs(void)\n{\n\tu32 v;\n\n\tpci_read_config_dword(sonypi_device.dev, SONYPI_G10A, &v);\n\tv = (v & 0xFFFF0000) | ((u32) sonypi_device.ioport1);\n\tpci_write_config_dword(sonypi_device.dev, SONYPI_G10A, v);\n\n\tpci_read_config_dword(sonypi_device.dev, SONYPI_G10A, &v);\n\tv = (v & 0xFFF0FFFF) |\n\t    (((u32) sonypi_device.ioport1 ^ sonypi_device.ioport2) << 16);\n\tpci_write_config_dword(sonypi_device.dev, SONYPI_G10A, v);\n\n\tv = inl(SONYPI_IRQ_PORT);\n\tv &= ~(((u32) 0x3) << SONYPI_IRQ_SHIFT);\n\tv |= (((u32) sonypi_device.bits) << SONYPI_IRQ_SHIFT);\n\toutl(v, SONYPI_IRQ_PORT);\n\n\tpci_read_config_dword(sonypi_device.dev, SONYPI_G10A, &v);\n\tv = (v & 0xFF1FFFFF) | 0x00C00000;\n\tpci_write_config_dword(sonypi_device.dev, SONYPI_G10A, v);\n}\n\nstatic void sonypi_type2_srs(void)\n{\n\tif (sonypi_ec_write(SONYPI_SHIB, (sonypi_device.ioport1 & 0xFF00) >> 8))\n\t\tprintk(KERN_WARNING \"ec_write failed\\n\");\n\tif (sonypi_ec_write(SONYPI_SLOB, sonypi_device.ioport1 & 0x00FF))\n\t\tprintk(KERN_WARNING \"ec_write failed\\n\");\n\tif (sonypi_ec_write(SONYPI_SIRQ, sonypi_device.bits))\n\t\tprintk(KERN_WARNING \"ec_write failed\\n\");\n\tudelay(10);\n}\n\nstatic void sonypi_type3_srs(void)\n{\n\tu16 v16;\n\tu8  v8;\n\n\t \n\tsonypi_type2_srs();\n\n\t \n\tv16 = (sonypi_device.ioport1 & 0xFFF0) | 0x01;\n\tpci_write_config_word(sonypi_device.dev, SONYPI_TYPE3_GID2, v16);\n\tpci_read_config_byte(sonypi_device.dev, SONYPI_TYPE3_MISC, &v8);\n\tv8 = (v8 & 0xCF) | 0x10;\n\tpci_write_config_byte(sonypi_device.dev, SONYPI_TYPE3_MISC, v8);\n}\n\n \nstatic void sonypi_type1_dis(void)\n{\n\tu32 v;\n\n\tpci_read_config_dword(sonypi_device.dev, SONYPI_G10A, &v);\n\tv = v & 0xFF3FFFFF;\n\tpci_write_config_dword(sonypi_device.dev, SONYPI_G10A, v);\n\n\tv = inl(SONYPI_IRQ_PORT);\n\tv |= (0x3 << SONYPI_IRQ_SHIFT);\n\toutl(v, SONYPI_IRQ_PORT);\n}\n\nstatic void sonypi_type2_dis(void)\n{\n\tif (sonypi_ec_write(SONYPI_SHIB, 0))\n\t\tprintk(KERN_WARNING \"ec_write failed\\n\");\n\tif (sonypi_ec_write(SONYPI_SLOB, 0))\n\t\tprintk(KERN_WARNING \"ec_write failed\\n\");\n\tif (sonypi_ec_write(SONYPI_SIRQ, 0))\n\t\tprintk(KERN_WARNING \"ec_write failed\\n\");\n}\n\nstatic void sonypi_type3_dis(void)\n{\n\tsonypi_type2_dis();\n\tudelay(10);\n\tpci_write_config_word(sonypi_device.dev, SONYPI_TYPE3_GID2, 0);\n}\n\nstatic u8 sonypi_call1(u8 dev)\n{\n\tu8 v1, v2;\n\n\twait_on_command(0, inb_p(sonypi_device.ioport2) & 2, ITERATIONS_LONG);\n\toutb(dev, sonypi_device.ioport2);\n\tv1 = inb_p(sonypi_device.ioport2);\n\tv2 = inb_p(sonypi_device.ioport1);\n\treturn v2;\n}\n\nstatic u8 sonypi_call2(u8 dev, u8 fn)\n{\n\tu8 v1;\n\n\twait_on_command(0, inb_p(sonypi_device.ioport2) & 2, ITERATIONS_LONG);\n\toutb(dev, sonypi_device.ioport2);\n\twait_on_command(0, inb_p(sonypi_device.ioport2) & 2, ITERATIONS_LONG);\n\toutb(fn, sonypi_device.ioport1);\n\tv1 = inb_p(sonypi_device.ioport1);\n\treturn v1;\n}\n\nstatic u8 sonypi_call3(u8 dev, u8 fn, u8 v)\n{\n\tu8 v1;\n\n\twait_on_command(0, inb_p(sonypi_device.ioport2) & 2, ITERATIONS_LONG);\n\toutb(dev, sonypi_device.ioport2);\n\twait_on_command(0, inb_p(sonypi_device.ioport2) & 2, ITERATIONS_LONG);\n\toutb(fn, sonypi_device.ioport1);\n\twait_on_command(0, inb_p(sonypi_device.ioport2) & 2, ITERATIONS_LONG);\n\toutb(v, sonypi_device.ioport1);\n\tv1 = inb_p(sonypi_device.ioport1);\n\treturn v1;\n}\n\n#if 0\n \nstatic u8 sonypi_read(u8 fn)\n{\n\tu8 v1, v2;\n\tint n = 100;\n\n\twhile (n--) {\n\t\tv1 = sonypi_call2(0x8f, fn);\n\t\tv2 = sonypi_call2(0x8f, fn);\n\t\tif (v1 == v2 && v1 != 0xff)\n\t\t\treturn v1;\n\t}\n\treturn 0xff;\n}\n#endif\n\n \nstatic void sonypi_set(u8 fn, u8 v)\n{\n\twait_on_command(0, sonypi_call3(0x90, fn, v), ITERATIONS_SHORT);\n}\n\n \nstatic int sonypi_camera_ready(void)\n{\n\tu8 v;\n\n\tv = sonypi_call2(0x8f, SONYPI_CAMERA_STATUS);\n\treturn (v != 0xff && (v & SONYPI_CAMERA_STATUS_READY));\n}\n\n \nstatic void sonypi_camera_off(void)\n{\n\tsonypi_set(SONYPI_CAMERA_PICTURE, SONYPI_CAMERA_MUTE_MASK);\n\n\tif (!sonypi_device.camera_power)\n\t\treturn;\n\n\tsonypi_call2(0x91, 0);\n\tsonypi_device.camera_power = 0;\n}\n\n \nstatic void sonypi_camera_on(void)\n{\n\tint i, j;\n\n\tif (sonypi_device.camera_power)\n\t\treturn;\n\n\tfor (j = 5; j > 0; j--) {\n\n\t\twhile (sonypi_call2(0x91, 0x1))\n\t\t\tmsleep(10);\n\t\tsonypi_call1(0x93);\n\n\t\tfor (i = 400; i > 0; i--) {\n\t\t\tif (sonypi_camera_ready())\n\t\t\t\tbreak;\n\t\t\tmsleep(10);\n\t\t}\n\t\tif (i)\n\t\t\tbreak;\n\t}\n\n\tif (j == 0) {\n\t\tprintk(KERN_WARNING \"sonypi: failed to power on camera\\n\");\n\t\treturn;\n\t}\n\n\tsonypi_set(0x10, 0x5a);\n\tsonypi_device.camera_power = 1;\n}\n\n \nstatic void sonypi_setbluetoothpower(u8 state)\n{\n\tstate = !!state;\n\n\tif (sonypi_device.bluetooth_power == state)\n\t\treturn;\n\n\tsonypi_call2(0x96, state);\n\tsonypi_call1(0x82);\n\tsonypi_device.bluetooth_power = state;\n}\n\nstatic void input_keyrelease(struct work_struct *work)\n{\n\tstruct sonypi_keypress kp;\n\n\twhile (kfifo_out_locked(&sonypi_device.input_fifo, (unsigned char *)&kp,\n\t\t\t sizeof(kp), &sonypi_device.input_fifo_lock)\n\t\t\t== sizeof(kp)) {\n\t\tmsleep(10);\n\t\tinput_report_key(kp.dev, kp.key, 0);\n\t\tinput_sync(kp.dev);\n\t}\n}\n\nstatic void sonypi_report_input_event(u8 event)\n{\n\tstruct input_dev *jog_dev = sonypi_device.input_jog_dev;\n\tstruct input_dev *key_dev = sonypi_device.input_key_dev;\n\tstruct sonypi_keypress kp = { NULL };\n\tint i;\n\n\tswitch (event) {\n\tcase SONYPI_EVENT_JOGDIAL_UP:\n\tcase SONYPI_EVENT_JOGDIAL_UP_PRESSED:\n\t\tinput_report_rel(jog_dev, REL_WHEEL, 1);\n\t\tinput_sync(jog_dev);\n\t\tbreak;\n\n\tcase SONYPI_EVENT_JOGDIAL_DOWN:\n\tcase SONYPI_EVENT_JOGDIAL_DOWN_PRESSED:\n\t\tinput_report_rel(jog_dev, REL_WHEEL, -1);\n\t\tinput_sync(jog_dev);\n\t\tbreak;\n\n\tcase SONYPI_EVENT_JOGDIAL_PRESSED:\n\t\tkp.key = BTN_MIDDLE;\n\t\tkp.dev = jog_dev;\n\t\tbreak;\n\n\tcase SONYPI_EVENT_FNKEY_RELEASED:\n\t\t \n\t\tbreak;\n\n\tdefault:\n\t\tfor (i = 0; sonypi_inputkeys[i].sonypiev; i++)\n\t\t\tif (event == sonypi_inputkeys[i].sonypiev) {\n\t\t\t\tkp.dev = key_dev;\n\t\t\t\tkp.key = sonypi_inputkeys[i].inputev;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tbreak;\n\t}\n\n\tif (kp.dev) {\n\t\tinput_report_key(kp.dev, kp.key, 1);\n\t\tinput_sync(kp.dev);\n\t\tkfifo_in_locked(&sonypi_device.input_fifo,\n\t\t\t(unsigned char *)&kp, sizeof(kp),\n\t\t\t&sonypi_device.input_fifo_lock);\n\t\tschedule_work(&sonypi_device.input_work);\n\t}\n}\n\n \nstatic irqreturn_t sonypi_irq(int irq, void *dev_id)\n{\n\tu8 v1, v2, event = 0;\n\tint i, j;\n\n\tv1 = inb_p(sonypi_device.ioport1);\n\tv2 = inb_p(sonypi_device.ioport1 + sonypi_device.evtype_offset);\n\n\tfor (i = 0; sonypi_eventtypes[i].model; i++) {\n\t\tif (sonypi_device.model != sonypi_eventtypes[i].model)\n\t\t\tcontinue;\n\t\tif ((v2 & sonypi_eventtypes[i].data) !=\n\t\t    sonypi_eventtypes[i].data)\n\t\t\tcontinue;\n\t\tif (!(mask & sonypi_eventtypes[i].mask))\n\t\t\tcontinue;\n\t\tfor (j = 0; sonypi_eventtypes[i].events[j].event; j++) {\n\t\t\tif (v1 == sonypi_eventtypes[i].events[j].data) {\n\t\t\t\tevent = sonypi_eventtypes[i].events[j].event;\n\t\t\t\tgoto found;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (verbose)\n\t\tprintk(KERN_WARNING\n\t\t       \"sonypi: unknown event port1=0x%02x,port2=0x%02x\\n\",\n\t\t       v1, v2);\n\t \n\treturn IRQ_HANDLED;\n\nfound:\n\tif (verbose > 1)\n\t\tprintk(KERN_INFO\n\t\t       \"sonypi: event port1=0x%02x,port2=0x%02x\\n\", v1, v2);\n\n\tif (useinput)\n\t\tsonypi_report_input_event(event);\n\n\tkfifo_in_locked(&sonypi_device.fifo, (unsigned char *)&event,\n\t\t\tsizeof(event), &sonypi_device.fifo_lock);\n\tkill_fasync(&sonypi_device.fifo_async, SIGIO, POLL_IN);\n\twake_up_interruptible(&sonypi_device.fifo_proc_list);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int sonypi_misc_fasync(int fd, struct file *filp, int on)\n{\n\treturn fasync_helper(fd, filp, on, &sonypi_device.fifo_async);\n}\n\nstatic int sonypi_misc_release(struct inode *inode, struct file *file)\n{\n\tmutex_lock(&sonypi_device.lock);\n\tsonypi_device.open_count--;\n\tmutex_unlock(&sonypi_device.lock);\n\treturn 0;\n}\n\nstatic int sonypi_misc_open(struct inode *inode, struct file *file)\n{\n\tmutex_lock(&sonypi_device.lock);\n\t \n\tif (!sonypi_device.open_count)\n\t\tkfifo_reset(&sonypi_device.fifo);\n\tsonypi_device.open_count++;\n\tmutex_unlock(&sonypi_device.lock);\n\n\treturn 0;\n}\n\nstatic ssize_t sonypi_misc_read(struct file *file, char __user *buf,\n\t\t\t\tsize_t count, loff_t *pos)\n{\n\tssize_t ret;\n\tunsigned char c;\n\n\tif ((kfifo_len(&sonypi_device.fifo) == 0) &&\n\t    (file->f_flags & O_NONBLOCK))\n\t\treturn -EAGAIN;\n\n\tret = wait_event_interruptible(sonypi_device.fifo_proc_list,\n\t\t\t\t       kfifo_len(&sonypi_device.fifo) != 0);\n\tif (ret)\n\t\treturn ret;\n\n\twhile (ret < count &&\n\t       (kfifo_out_locked(&sonypi_device.fifo, &c, sizeof(c),\n\t\t\t\t &sonypi_device.fifo_lock) == sizeof(c))) {\n\t\tif (put_user(c, buf++))\n\t\t\treturn -EFAULT;\n\t\tret++;\n\t}\n\n\tif (ret > 0) {\n\t\tstruct inode *inode = file_inode(file);\n\t\tinode->i_atime = current_time(inode);\n\t}\n\n\treturn ret;\n}\n\nstatic __poll_t sonypi_misc_poll(struct file *file, poll_table *wait)\n{\n\tpoll_wait(file, &sonypi_device.fifo_proc_list, wait);\n\tif (kfifo_len(&sonypi_device.fifo))\n\t\treturn EPOLLIN | EPOLLRDNORM;\n\treturn 0;\n}\n\nstatic long sonypi_misc_ioctl(struct file *fp,\n\t\t\t     unsigned int cmd, unsigned long arg)\n{\n\tlong ret = 0;\n\tvoid __user *argp = (void __user *)arg;\n\tu8 val8;\n\tu16 val16;\n\n\tmutex_lock(&sonypi_device.lock);\n\tswitch (cmd) {\n\tcase SONYPI_IOCGBRT:\n\t\tif (sonypi_ec_read(SONYPI_LCD_LIGHT, &val8)) {\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tif (copy_to_user(argp, &val8, sizeof(val8)))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\tcase SONYPI_IOCSBRT:\n\t\tif (copy_from_user(&val8, argp, sizeof(val8))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (sonypi_ec_write(SONYPI_LCD_LIGHT, val8))\n\t\t\tret = -EIO;\n\t\tbreak;\n\tcase SONYPI_IOCGBAT1CAP:\n\t\tif (ec_read16(SONYPI_BAT1_FULL, &val16)) {\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tif (copy_to_user(argp, &val16, sizeof(val16)))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\tcase SONYPI_IOCGBAT1REM:\n\t\tif (ec_read16(SONYPI_BAT1_LEFT, &val16)) {\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tif (copy_to_user(argp, &val16, sizeof(val16)))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\tcase SONYPI_IOCGBAT2CAP:\n\t\tif (ec_read16(SONYPI_BAT2_FULL, &val16)) {\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tif (copy_to_user(argp, &val16, sizeof(val16)))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\tcase SONYPI_IOCGBAT2REM:\n\t\tif (ec_read16(SONYPI_BAT2_LEFT, &val16)) {\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tif (copy_to_user(argp, &val16, sizeof(val16)))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\tcase SONYPI_IOCGBATFLAGS:\n\t\tif (sonypi_ec_read(SONYPI_BAT_FLAGS, &val8)) {\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tval8 &= 0x07;\n\t\tif (copy_to_user(argp, &val8, sizeof(val8)))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\tcase SONYPI_IOCGBLUE:\n\t\tval8 = sonypi_device.bluetooth_power;\n\t\tif (copy_to_user(argp, &val8, sizeof(val8)))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\tcase SONYPI_IOCSBLUE:\n\t\tif (copy_from_user(&val8, argp, sizeof(val8))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tsonypi_setbluetoothpower(val8);\n\t\tbreak;\n\t \n\tcase SONYPI_IOCGFAN:\n\t\tif (sonypi_ec_read(SONYPI_FAN0_STATUS, &val8)) {\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tif (copy_to_user(argp, &val8, sizeof(val8)))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\tcase SONYPI_IOCSFAN:\n\t\tif (copy_from_user(&val8, argp, sizeof(val8))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (sonypi_ec_write(SONYPI_FAN0_STATUS, val8))\n\t\t\tret = -EIO;\n\t\tbreak;\n\t \n\tcase SONYPI_IOCGTEMP:\n\t\tif (sonypi_ec_read(SONYPI_TEMP_STATUS, &val8)) {\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tif (copy_to_user(argp, &val8, sizeof(val8)))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\tmutex_unlock(&sonypi_device.lock);\n\treturn ret;\n}\n\nstatic const struct file_operations sonypi_misc_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.read\t\t= sonypi_misc_read,\n\t.poll\t\t= sonypi_misc_poll,\n\t.open\t\t= sonypi_misc_open,\n\t.release\t= sonypi_misc_release,\n\t.fasync\t\t= sonypi_misc_fasync,\n\t.unlocked_ioctl\t= sonypi_misc_ioctl,\n\t.llseek\t\t= no_llseek,\n};\n\nstatic struct miscdevice sonypi_misc_device = {\n\t.minor\t\t= MISC_DYNAMIC_MINOR,\n\t.name\t\t= \"sonypi\",\n\t.fops\t\t= &sonypi_misc_fops,\n};\n\nstatic void sonypi_enable(unsigned int camera_on)\n{\n\tswitch (sonypi_device.model) {\n\tcase SONYPI_DEVICE_MODEL_TYPE1:\n\t\tsonypi_type1_srs();\n\t\tbreak;\n\tcase SONYPI_DEVICE_MODEL_TYPE2:\n\t\tsonypi_type2_srs();\n\t\tbreak;\n\tcase SONYPI_DEVICE_MODEL_TYPE3:\n\t\tsonypi_type3_srs();\n\t\tbreak;\n\t}\n\n\tsonypi_call1(0x82);\n\tsonypi_call2(0x81, 0xff);\n\tsonypi_call1(compat ? 0x92 : 0x82);\n\n\t \n\tif (!SONYPI_ACPI_ACTIVE && fnkeyinit)\n\t\toutb(0xf0, 0xb2);\n\n\tif (camera && camera_on)\n\t\tsonypi_camera_on();\n}\n\nstatic int sonypi_disable(void)\n{\n\tsonypi_call2(0x81, 0);\t \n\tif (camera)\n\t\tsonypi_camera_off();\n\n\t \n\tif (!SONYPI_ACPI_ACTIVE && fnkeyinit)\n\t\toutb(0xf1, 0xb2);\n\n\tswitch (sonypi_device.model) {\n\tcase SONYPI_DEVICE_MODEL_TYPE1:\n\t\tsonypi_type1_dis();\n\t\tbreak;\n\tcase SONYPI_DEVICE_MODEL_TYPE2:\n\t\tsonypi_type2_dis();\n\t\tbreak;\n\tcase SONYPI_DEVICE_MODEL_TYPE3:\n\t\tsonypi_type3_dis();\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_ACPI\nstatic int sonypi_acpi_add(struct acpi_device *device)\n{\n\tsonypi_acpi_device = device;\n\tstrcpy(acpi_device_name(device), \"Sony laptop hotkeys\");\n\tstrcpy(acpi_device_class(device), \"sony/hotkey\");\n\treturn 0;\n}\n\nstatic void sonypi_acpi_remove(struct acpi_device *device)\n{\n\tsonypi_acpi_device = NULL;\n}\n\nstatic const struct acpi_device_id sonypi_device_ids[] = {\n\t{\"SNY6001\", 0},\n\t{\"\", 0},\n};\n\nstatic struct acpi_driver sonypi_acpi_driver = {\n\t.name           = \"sonypi\",\n\t.class          = \"hkey\",\n\t.ids            = sonypi_device_ids,\n\t.ops            = {\n\t\t           .add = sonypi_acpi_add,\n\t\t\t   .remove = sonypi_acpi_remove,\n\t},\n};\n#endif\n\nstatic int sonypi_create_input_devices(struct platform_device *pdev)\n{\n\tstruct input_dev *jog_dev;\n\tstruct input_dev *key_dev;\n\tint i;\n\tint error;\n\n\tsonypi_device.input_jog_dev = jog_dev = input_allocate_device();\n\tif (!jog_dev)\n\t\treturn -ENOMEM;\n\n\tjog_dev->name = \"Sony Vaio Jogdial\";\n\tjog_dev->id.bustype = BUS_ISA;\n\tjog_dev->id.vendor = PCI_VENDOR_ID_SONY;\n\tjog_dev->dev.parent = &pdev->dev;\n\n\tjog_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REL);\n\tjog_dev->keybit[BIT_WORD(BTN_MOUSE)] = BIT_MASK(BTN_MIDDLE);\n\tjog_dev->relbit[0] = BIT_MASK(REL_WHEEL);\n\n\tsonypi_device.input_key_dev = key_dev = input_allocate_device();\n\tif (!key_dev) {\n\t\terror = -ENOMEM;\n\t\tgoto err_free_jogdev;\n\t}\n\n\tkey_dev->name = \"Sony Vaio Keys\";\n\tkey_dev->id.bustype = BUS_ISA;\n\tkey_dev->id.vendor = PCI_VENDOR_ID_SONY;\n\tkey_dev->dev.parent = &pdev->dev;\n\n\t \n\tkey_dev->evbit[0] = BIT_MASK(EV_KEY);\n\tfor (i = 0; sonypi_inputkeys[i].sonypiev; i++)\n\t\tif (sonypi_inputkeys[i].inputev)\n\t\t\tset_bit(sonypi_inputkeys[i].inputev, key_dev->keybit);\n\n\terror = input_register_device(jog_dev);\n\tif (error)\n\t\tgoto err_free_keydev;\n\n\terror = input_register_device(key_dev);\n\tif (error)\n\t\tgoto err_unregister_jogdev;\n\n\treturn 0;\n\n err_unregister_jogdev:\n\tinput_unregister_device(jog_dev);\n\t \n\tjog_dev = NULL;\n err_free_keydev:\n\tinput_free_device(key_dev);\n\tsonypi_device.input_key_dev = NULL;\n err_free_jogdev:\n\tinput_free_device(jog_dev);\n\tsonypi_device.input_jog_dev = NULL;\n\n\treturn error;\n}\n\nstatic int sonypi_setup_ioports(struct sonypi_device *dev,\n\t\t\t\tconst struct sonypi_ioport_list *ioport_list)\n{\n\t \n\tconst struct sonypi_ioport_list *check = ioport_list;\n\twhile (check_ioport && check->port1) {\n\t\tif (!request_region(check->port1,\n\t\t\t\t   sonypi_device.region_size,\n\t\t\t\t   \"Sony Programmable I/O Device Check\")) {\n\t\t\tprintk(KERN_ERR \"sonypi: ioport 0x%.4x busy, using sony-laptop? \"\n\t\t\t\t\t\"if not use check_ioport=0\\n\",\n\t\t\t\t\tcheck->port1);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\trelease_region(check->port1, sonypi_device.region_size);\n\t\tcheck++;\n\t}\n\n\twhile (ioport_list->port1) {\n\n\t\tif (request_region(ioport_list->port1,\n\t\t\t\t   sonypi_device.region_size,\n\t\t\t\t   \"Sony Programmable I/O Device\")) {\n\t\t\tdev->ioport1 = ioport_list->port1;\n\t\t\tdev->ioport2 = ioport_list->port2;\n\t\t\treturn 0;\n\t\t}\n\t\tioport_list++;\n\t}\n\n\treturn -EBUSY;\n}\n\nstatic int sonypi_setup_irq(struct sonypi_device *dev,\n\t\t\t\t      const struct sonypi_irq_list *irq_list)\n{\n\twhile (irq_list->irq) {\n\n\t\tif (!request_irq(irq_list->irq, sonypi_irq,\n\t\t\t\t IRQF_SHARED, \"sonypi\", sonypi_irq)) {\n\t\t\tdev->irq = irq_list->irq;\n\t\t\tdev->bits = irq_list->bits;\n\t\t\treturn 0;\n\t\t}\n\t\tirq_list++;\n\t}\n\n\treturn -EBUSY;\n}\n\nstatic void sonypi_display_info(void)\n{\n\tprintk(KERN_INFO \"sonypi: detected type%d model, \"\n\t       \"verbose = %d, fnkeyinit = %s, camera = %s, \"\n\t       \"compat = %s, mask = 0x%08lx, useinput = %s, acpi = %s\\n\",\n\t       sonypi_device.model,\n\t       verbose,\n\t       fnkeyinit ? \"on\" : \"off\",\n\t       camera ? \"on\" : \"off\",\n\t       compat ? \"on\" : \"off\",\n\t       mask,\n\t       useinput ? \"on\" : \"off\",\n\t       SONYPI_ACPI_ACTIVE ? \"on\" : \"off\");\n\tprintk(KERN_INFO \"sonypi: enabled at irq=%d, port1=0x%x, port2=0x%x\\n\",\n\t       sonypi_device.irq,\n\t       sonypi_device.ioport1, sonypi_device.ioport2);\n\n\tif (minor == -1)\n\t\tprintk(KERN_INFO \"sonypi: device allocated minor is %d\\n\",\n\t\t       sonypi_misc_device.minor);\n}\n\nstatic int sonypi_probe(struct platform_device *dev)\n{\n\tconst struct sonypi_ioport_list *ioport_list;\n\tconst struct sonypi_irq_list *irq_list;\n\tstruct pci_dev *pcidev;\n\tint error;\n\n\tprintk(KERN_WARNING \"sonypi: please try the sony-laptop module instead \"\n\t\t\t\"and report failures, see also \"\n\t\t\t\"http://www.linux.it/~malattia/wiki/index.php/Sony_drivers\\n\");\n\n\tspin_lock_init(&sonypi_device.fifo_lock);\n\terror = kfifo_alloc(&sonypi_device.fifo, SONYPI_BUF_SIZE, GFP_KERNEL);\n\tif (error) {\n\t\tprintk(KERN_ERR \"sonypi: kfifo_alloc failed\\n\");\n\t\treturn error;\n\t}\n\n\tinit_waitqueue_head(&sonypi_device.fifo_proc_list);\n\tmutex_init(&sonypi_device.lock);\n\tsonypi_device.bluetooth_power = -1;\n\n\tif ((pcidev = pci_get_device(PCI_VENDOR_ID_INTEL,\n\t\t\t\t     PCI_DEVICE_ID_INTEL_82371AB_3, NULL)))\n\t\tsonypi_device.model = SONYPI_DEVICE_MODEL_TYPE1;\n\telse if ((pcidev = pci_get_device(PCI_VENDOR_ID_INTEL,\n\t\t\t\t\t  PCI_DEVICE_ID_INTEL_ICH6_1, NULL)))\n\t\tsonypi_device.model = SONYPI_DEVICE_MODEL_TYPE3;\n\telse if ((pcidev = pci_get_device(PCI_VENDOR_ID_INTEL,\n\t\t\t\t\t  PCI_DEVICE_ID_INTEL_ICH7_1, NULL)))\n\t\tsonypi_device.model = SONYPI_DEVICE_MODEL_TYPE3;\n\telse\n\t\tsonypi_device.model = SONYPI_DEVICE_MODEL_TYPE2;\n\n\tif (pcidev && pci_enable_device(pcidev)) {\n\t\tprintk(KERN_ERR \"sonypi: pci_enable_device failed\\n\");\n\t\terror = -EIO;\n\t\tgoto err_put_pcidev;\n\t}\n\n\tsonypi_device.dev = pcidev;\n\n\tif (sonypi_device.model == SONYPI_DEVICE_MODEL_TYPE1) {\n\t\tioport_list = sonypi_type1_ioport_list;\n\t\tsonypi_device.region_size = SONYPI_TYPE1_REGION_SIZE;\n\t\tsonypi_device.evtype_offset = SONYPI_TYPE1_EVTYPE_OFFSET;\n\t\tirq_list = sonypi_type1_irq_list;\n\t} else if (sonypi_device.model == SONYPI_DEVICE_MODEL_TYPE2) {\n\t\tioport_list = sonypi_type2_ioport_list;\n\t\tsonypi_device.region_size = SONYPI_TYPE2_REGION_SIZE;\n\t\tsonypi_device.evtype_offset = SONYPI_TYPE2_EVTYPE_OFFSET;\n\t\tirq_list = sonypi_type2_irq_list;\n\t} else {\n\t\tioport_list = sonypi_type3_ioport_list;\n\t\tsonypi_device.region_size = SONYPI_TYPE3_REGION_SIZE;\n\t\tsonypi_device.evtype_offset = SONYPI_TYPE3_EVTYPE_OFFSET;\n\t\tirq_list = sonypi_type3_irq_list;\n\t}\n\n\terror = sonypi_setup_ioports(&sonypi_device, ioport_list);\n\tif (error) {\n\t\tprintk(KERN_ERR \"sonypi: failed to request ioports\\n\");\n\t\tgoto err_disable_pcidev;\n\t}\n\n\terror = sonypi_setup_irq(&sonypi_device, irq_list);\n\tif (error) {\n\t\tprintk(KERN_ERR \"sonypi: request_irq failed\\n\");\n\t\tgoto err_free_ioports;\n\t}\n\n\tif (minor != -1)\n\t\tsonypi_misc_device.minor = minor;\n\terror = misc_register(&sonypi_misc_device);\n\tif (error) {\n\t\tprintk(KERN_ERR \"sonypi: misc_register failed\\n\");\n\t\tgoto err_free_irq;\n\t}\n\n\tsonypi_display_info();\n\n\tif (useinput) {\n\n\t\terror = sonypi_create_input_devices(dev);\n\t\tif (error) {\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"sonypi: failed to create input devices\\n\");\n\t\t\tgoto err_miscdev_unregister;\n\t\t}\n\n\t\tspin_lock_init(&sonypi_device.input_fifo_lock);\n\t\terror = kfifo_alloc(&sonypi_device.input_fifo, SONYPI_BUF_SIZE,\n\t\t\t\tGFP_KERNEL);\n\t\tif (error) {\n\t\t\tprintk(KERN_ERR \"sonypi: kfifo_alloc failed\\n\");\n\t\t\tgoto err_inpdev_unregister;\n\t\t}\n\n\t\tINIT_WORK(&sonypi_device.input_work, input_keyrelease);\n\t}\n\n\tsonypi_enable(0);\n\n\treturn 0;\n\n err_inpdev_unregister:\n\tinput_unregister_device(sonypi_device.input_key_dev);\n\tinput_unregister_device(sonypi_device.input_jog_dev);\n err_miscdev_unregister:\n\tmisc_deregister(&sonypi_misc_device);\n err_free_irq:\n\tfree_irq(sonypi_device.irq, sonypi_irq);\n err_free_ioports:\n\trelease_region(sonypi_device.ioport1, sonypi_device.region_size);\n err_disable_pcidev:\n\tif (pcidev)\n\t\tpci_disable_device(pcidev);\n err_put_pcidev:\n\tpci_dev_put(pcidev);\n\tkfifo_free(&sonypi_device.fifo);\n\n\treturn error;\n}\n\nstatic int sonypi_remove(struct platform_device *dev)\n{\n\tsonypi_disable();\n\n\tsynchronize_irq(sonypi_device.irq);\n\tflush_work(&sonypi_device.input_work);\n\n\tif (useinput) {\n\t\tinput_unregister_device(sonypi_device.input_key_dev);\n\t\tinput_unregister_device(sonypi_device.input_jog_dev);\n\t\tkfifo_free(&sonypi_device.input_fifo);\n\t}\n\n\tmisc_deregister(&sonypi_misc_device);\n\n\tfree_irq(sonypi_device.irq, sonypi_irq);\n\trelease_region(sonypi_device.ioport1, sonypi_device.region_size);\n\n\tif (sonypi_device.dev) {\n\t\tpci_disable_device(sonypi_device.dev);\n\t\tpci_dev_put(sonypi_device.dev);\n\t}\n\n\tkfifo_free(&sonypi_device.fifo);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int old_camera_power;\n\nstatic int sonypi_suspend(struct device *dev)\n{\n\told_camera_power = sonypi_device.camera_power;\n\tsonypi_disable();\n\n\treturn 0;\n}\n\nstatic int sonypi_resume(struct device *dev)\n{\n\tsonypi_enable(old_camera_power);\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(sonypi_pm, sonypi_suspend, sonypi_resume);\n#define SONYPI_PM\t(&sonypi_pm)\n#else\n#define SONYPI_PM\tNULL\n#endif\n\nstatic void sonypi_shutdown(struct platform_device *dev)\n{\n\tsonypi_disable();\n}\n\nstatic struct platform_driver sonypi_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"sonypi\",\n\t\t.pm\t= SONYPI_PM,\n\t},\n\t.probe\t\t= sonypi_probe,\n\t.remove\t\t= sonypi_remove,\n\t.shutdown\t= sonypi_shutdown,\n};\n\nstatic struct platform_device *sonypi_platform_device;\n\nstatic const struct dmi_system_id sonypi_dmi_table[] __initconst = {\n\t{\n\t\t.ident = \"Sony Vaio\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Sony Corporation\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"PCG-\"),\n\t\t},\n\t},\n\t{\n\t\t.ident = \"Sony Vaio\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Sony Corporation\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"VGN-\"),\n\t\t},\n\t},\n\t{ }\n};\n\nstatic int __init sonypi_init(void)\n{\n\tint error;\n\n\tprintk(KERN_INFO\n\t\t\"sonypi: Sony Programmable I/O Controller Driver v%s.\\n\",\n\t\tSONYPI_DRIVER_VERSION);\n\n\tif (!dmi_check_system(sonypi_dmi_table))\n\t\treturn -ENODEV;\n\n\terror = platform_driver_register(&sonypi_driver);\n\tif (error)\n\t\treturn error;\n\n\tsonypi_platform_device = platform_device_alloc(\"sonypi\", -1);\n\tif (!sonypi_platform_device) {\n\t\terror = -ENOMEM;\n\t\tgoto err_driver_unregister;\n\t}\n\n\terror = platform_device_add(sonypi_platform_device);\n\tif (error)\n\t\tgoto err_free_device;\n\n#ifdef CONFIG_ACPI\n\tif (acpi_bus_register_driver(&sonypi_acpi_driver) >= 0)\n\t\tacpi_driver_registered = 1;\n#endif\n\n\treturn 0;\n\n err_free_device:\n\tplatform_device_put(sonypi_platform_device);\n err_driver_unregister:\n\tplatform_driver_unregister(&sonypi_driver);\n\treturn error;\n}\n\nstatic void __exit sonypi_exit(void)\n{\n#ifdef CONFIG_ACPI\n\tif (acpi_driver_registered)\n\t\tacpi_bus_unregister_driver(&sonypi_acpi_driver);\n#endif\n\tplatform_device_unregister(sonypi_platform_device);\n\tplatform_driver_unregister(&sonypi_driver);\n\tprintk(KERN_INFO \"sonypi: removed.\\n\");\n}\n\nmodule_init(sonypi_init);\nmodule_exit(sonypi_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}