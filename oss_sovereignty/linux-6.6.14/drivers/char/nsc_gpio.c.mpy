{
  "module_name": "nsc_gpio.c",
  "hash_id": "63e29b59721b88dfe604688cba99b1340aec5c2852de9c8d883fedb5af4e8fb7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/char/nsc_gpio.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/nsc_gpio.h>\n#include <linux/platform_device.h>\n#include <linux/uaccess.h>\n#include <asm/io.h>\n\n#define NAME \"nsc_gpio\"\n\nvoid nsc_gpio_dump(struct nsc_gpio_ops *amp, unsigned index)\n{\n\t \n\tu32 config = amp->gpio_config(index, ~0, 0);\n\n\t \n\tdev_info(amp->dev, \"io%02u: 0x%04x %s %s %s %s %s %s %s\\tio:%d/%d\\n\",\n\t\t index, config,\n\t\t (config & 1) ? \"OE\" : \"TS\",       \n\t\t (config & 2) ? \"PP\" : \"OD\",       \n\t\t (config & 4) ? \"PUE\" : \"PUD\",     \n\t\t (config & 8) ? \"LOCKED\" : \"\",     \n\t\t (config & 16) ? \"LEVEL\" : \"EDGE\", \n\t\t (config & 32) ? \"HI\" : \"LO\",      \n\t\t (config & 64) ? \"DEBOUNCE\" : \"\",  \n\n\t\t amp->gpio_get(index), amp->gpio_current(index));\n}\n\nssize_t nsc_gpio_write(struct file *file, const char __user *data,\n\t\t       size_t len, loff_t *ppos)\n{\n\tunsigned m = iminor(file_inode(file));\n\tstruct nsc_gpio_ops *amp = file->private_data;\n\tstruct device *dev = amp->dev;\n\tsize_t i;\n\tint err = 0;\n\n\tfor (i = 0; i < len; ++i) {\n\t\tchar c;\n\t\tif (get_user(c, data + i))\n\t\t\treturn -EFAULT;\n\t\tswitch (c) {\n\t\tcase '0':\n\t\t\tamp->gpio_set(m, 0);\n\t\t\tbreak;\n\t\tcase '1':\n\t\t\tamp->gpio_set(m, 1);\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tdev_dbg(dev, \"GPIO%d output enabled\\n\", m);\n\t\t\tamp->gpio_config(m, ~1, 1);\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tdev_dbg(dev, \"GPIO%d output disabled\\n\", m);\n\t\t\tamp->gpio_config(m, ~1, 0);\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tdev_dbg(dev, \"GPIO%d output is push pull\\n\", m);\n\t\t\tamp->gpio_config(m, ~2, 2);\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tdev_dbg(dev, \"GPIO%d output is open drain\\n\", m);\n\t\t\tamp->gpio_config(m, ~2, 0);\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tdev_dbg(dev, \"GPIO%d pull up enabled\\n\", m);\n\t\t\tamp->gpio_config(m, ~4, 4);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tdev_dbg(dev, \"GPIO%d pull up disabled\\n\", m);\n\t\t\tamp->gpio_config(m, ~4, 0);\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\t \n\t\t\tamp->gpio_dump(amp, m);\n\t\t\tbreak;\n\t\tcase '\\n':\n\t\t\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(dev, \"io%2d bad setting: chr<0x%2x>\\n\",\n\t\t\t\tm, (int)c);\n\t\t\terr++;\n\t\t}\n\t}\n\tif (err)\n\t\treturn -EINVAL;\t \n\n\treturn len;\n}\n\nssize_t nsc_gpio_read(struct file *file, char __user * buf,\n\t\t      size_t len, loff_t * ppos)\n{\n\tunsigned m = iminor(file_inode(file));\n\tint value;\n\tstruct nsc_gpio_ops *amp = file->private_data;\n\n\tvalue = amp->gpio_get(m);\n\tif (put_user(value ? '1' : '0', buf))\n\t\treturn -EFAULT;\n\n\treturn 1;\n}\n\n \nEXPORT_SYMBOL(nsc_gpio_write);\nEXPORT_SYMBOL(nsc_gpio_read);\nEXPORT_SYMBOL(nsc_gpio_dump);\n\nstatic int __init nsc_gpio_init(void)\n{\n\tprintk(KERN_DEBUG NAME \" initializing\\n\");\n\treturn 0;\n}\n\nstatic void __exit nsc_gpio_cleanup(void)\n{\n\tprintk(KERN_DEBUG NAME \" cleanup\\n\");\n}\n\nmodule_init(nsc_gpio_init);\nmodule_exit(nsc_gpio_cleanup);\n\nMODULE_AUTHOR(\"Jim Cromie <jim.cromie@gmail.com>\");\nMODULE_DESCRIPTION(\"NatSemi GPIO Common Methods\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}