{
  "module_name": "most_usb.c",
  "hash_id": "6fbb9fae821d33cfe8cef898a61a041733e484b38ccf14fa1f28809c49f4f225",
  "original_prompt": "Ingested from linux-6.6.14/drivers/most/most_usb.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/usb.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/cdev.h>\n#include <linux/device.h>\n#include <linux/list.h>\n#include <linux/completion.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/workqueue.h>\n#include <linux/sysfs.h>\n#include <linux/dma-mapping.h>\n#include <linux/etherdevice.h>\n#include <linux/uaccess.h>\n#include <linux/most.h>\n\n#define USB_MTU\t\t\t512\n#define NO_ISOCHRONOUS_URB\t0\n#define AV_PACKETS_PER_XACT\t2\n#define BUF_CHAIN_SIZE\t\t0xFFFF\n#define MAX_NUM_ENDPOINTS\t30\n#define MAX_SUFFIX_LEN\t\t10\n#define MAX_STRING_LEN\t\t80\n#define MAX_BUF_SIZE\t\t0xFFFF\n\n#define USB_VENDOR_ID_SMSC\t0x0424   \n#define USB_DEV_ID_BRDG\t\t0xC001   \n#define USB_DEV_ID_OS81118\t0xCF18   \n#define USB_DEV_ID_OS81119\t0xCF19   \n#define USB_DEV_ID_OS81210\t0xCF30   \n \n#define DRCI_REG_NI_STATE\t0x0100\n#define DRCI_REG_PACKET_BW\t0x0101\n#define DRCI_REG_NODE_ADDR\t0x0102\n#define DRCI_REG_NODE_POS\t0x0103\n#define DRCI_REG_MEP_FILTER\t0x0140\n#define DRCI_REG_HASH_TBL0\t0x0141\n#define DRCI_REG_HASH_TBL1\t0x0142\n#define DRCI_REG_HASH_TBL2\t0x0143\n#define DRCI_REG_HASH_TBL3\t0x0144\n#define DRCI_REG_HW_ADDR_HI\t0x0145\n#define DRCI_REG_HW_ADDR_MI\t0x0146\n#define DRCI_REG_HW_ADDR_LO\t0x0147\n#define DRCI_REG_BASE\t\t0x1100\n#define DRCI_COMMAND\t\t0x02\n#define DRCI_READ_REQ\t\t0xA0\n#define DRCI_WRITE_REQ\t\t0xA1\n\n \nstruct most_dci_obj {\n\tstruct device dev;\n\tstruct usb_device *usb_device;\n\tu16 reg_addr;\n};\n\n#define to_dci_obj(p) container_of(p, struct most_dci_obj, dev)\n\nstruct most_dev;\n\nstruct clear_hold_work {\n\tstruct work_struct ws;\n\tstruct most_dev *mdev;\n\tunsigned int channel;\n\tint pipe;\n};\n\n#define to_clear_hold_work(w) container_of(w, struct clear_hold_work, ws)\n\n \nstruct most_dev {\n\tstruct device dev;\n\tstruct usb_device *usb_device;\n\tstruct most_interface iface;\n\tstruct most_channel_capability *cap;\n\tstruct most_channel_config *conf;\n\tstruct most_dci_obj *dci;\n\tu8 *ep_address;\n\tchar description[MAX_STRING_LEN];\n\tchar suffix[MAX_NUM_ENDPOINTS][MAX_SUFFIX_LEN];\n\tspinlock_t channel_lock[MAX_NUM_ENDPOINTS];  \n\tbool padding_active[MAX_NUM_ENDPOINTS];\n\tbool is_channel_healthy[MAX_NUM_ENDPOINTS];\n\tstruct clear_hold_work clear_work[MAX_NUM_ENDPOINTS];\n\tstruct usb_anchor *busy_urbs;\n\tstruct mutex io_mutex;\n\tstruct timer_list link_stat_timer;\n\tstruct work_struct poll_work_obj;\n\tvoid (*on_netinfo)(struct most_interface *most_iface,\n\t\t\t   unsigned char link_state, unsigned char *addrs);\n};\n\n#define to_mdev(d) container_of(d, struct most_dev, iface)\n#define to_mdev_from_dev(d) container_of(d, struct most_dev, dev)\n#define to_mdev_from_work(w) container_of(w, struct most_dev, poll_work_obj)\n\nstatic void wq_clear_halt(struct work_struct *wq_obj);\nstatic void wq_netinfo(struct work_struct *wq_obj);\n\n \nstatic inline int drci_rd_reg(struct usb_device *dev, u16 reg, u16 *buf)\n{\n\tint retval;\n\t__le16 *dma_buf;\n\tu8 req_type = USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE;\n\n\tdma_buf = kzalloc(sizeof(*dma_buf), GFP_KERNEL);\n\tif (!dma_buf)\n\t\treturn -ENOMEM;\n\n\tretval = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\n\t\t\t\t DRCI_READ_REQ, req_type,\n\t\t\t\t 0x0000,\n\t\t\t\t reg, dma_buf, sizeof(*dma_buf),\n\t\t\t\t USB_CTRL_GET_TIMEOUT);\n\t*buf = le16_to_cpu(*dma_buf);\n\tkfree(dma_buf);\n\n\tif (retval < 0)\n\t\treturn retval;\n\treturn 0;\n}\n\n \nstatic inline int drci_wr_reg(struct usb_device *dev, u16 reg, u16 data)\n{\n\treturn usb_control_msg(dev,\n\t\t\t       usb_sndctrlpipe(dev, 0),\n\t\t\t       DRCI_WRITE_REQ,\n\t\t\t       USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t       data,\n\t\t\t       reg,\n\t\t\t       NULL,\n\t\t\t       0,\n\t\t\t       USB_CTRL_SET_TIMEOUT);\n}\n\nstatic inline int start_sync_ep(struct usb_device *usb_dev, u16 ep)\n{\n\treturn drci_wr_reg(usb_dev, DRCI_REG_BASE + DRCI_COMMAND + ep * 16, 1);\n}\n\n \nstatic unsigned int get_stream_frame_size(struct device *dev,\n\t\t\t\t\t  struct most_channel_config *cfg)\n{\n\tunsigned int frame_size;\n\tunsigned int sub_size = cfg->subbuffer_size;\n\n\tif (!sub_size) {\n\t\tdev_warn(dev, \"Misconfig: Subbuffer size zero.\\n\");\n\t\treturn 0;\n\t}\n\tswitch (cfg->data_type) {\n\tcase MOST_CH_ISOC:\n\t\tframe_size = AV_PACKETS_PER_XACT * sub_size;\n\t\tbreak;\n\tcase MOST_CH_SYNC:\n\t\tif (cfg->packets_per_xact == 0) {\n\t\t\tdev_warn(dev, \"Misconfig: Packets per XACT zero\\n\");\n\t\t\tframe_size = 0;\n\t\t} else if (cfg->packets_per_xact == 0xFF) {\n\t\t\tframe_size = (USB_MTU / sub_size) * sub_size;\n\t\t} else {\n\t\t\tframe_size = cfg->packets_per_xact * sub_size;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(dev, \"Query frame size of non-streaming channel\\n\");\n\t\tframe_size = 0;\n\t\tbreak;\n\t}\n\treturn frame_size;\n}\n\n \nstatic int hdm_poison_channel(struct most_interface *iface, int channel)\n{\n\tstruct most_dev *mdev = to_mdev(iface);\n\tunsigned long flags;\n\tspinlock_t *lock;  \n\n\tif (channel < 0 || channel >= iface->num_channels) {\n\t\tdev_warn(&mdev->usb_device->dev, \"Channel ID out of range.\\n\");\n\t\treturn -ECHRNG;\n\t}\n\n\tlock = mdev->channel_lock + channel;\n\tspin_lock_irqsave(lock, flags);\n\tmdev->is_channel_healthy[channel] = false;\n\tspin_unlock_irqrestore(lock, flags);\n\n\tcancel_work_sync(&mdev->clear_work[channel].ws);\n\n\tmutex_lock(&mdev->io_mutex);\n\tusb_kill_anchored_urbs(&mdev->busy_urbs[channel]);\n\tif (mdev->padding_active[channel])\n\t\tmdev->padding_active[channel] = false;\n\n\tif (mdev->conf[channel].data_type == MOST_CH_ASYNC) {\n\t\tdel_timer_sync(&mdev->link_stat_timer);\n\t\tcancel_work_sync(&mdev->poll_work_obj);\n\t}\n\tmutex_unlock(&mdev->io_mutex);\n\treturn 0;\n}\n\n \nstatic int hdm_add_padding(struct most_dev *mdev, int channel, struct mbo *mbo)\n{\n\tstruct most_channel_config *conf = &mdev->conf[channel];\n\tunsigned int frame_size = get_stream_frame_size(&mdev->dev, conf);\n\tunsigned int j, num_frames;\n\n\tif (!frame_size)\n\t\treturn -EINVAL;\n\tnum_frames = mbo->buffer_length / frame_size;\n\n\tif (num_frames < 1) {\n\t\tdev_err(&mdev->usb_device->dev,\n\t\t\t\"Missed minimal transfer unit.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (j = num_frames - 1; j > 0; j--)\n\t\tmemmove(mbo->virt_address + j * USB_MTU,\n\t\t\tmbo->virt_address + j * frame_size,\n\t\t\tframe_size);\n\tmbo->buffer_length = num_frames * USB_MTU;\n\treturn 0;\n}\n\n \nstatic int hdm_remove_padding(struct most_dev *mdev, int channel,\n\t\t\t      struct mbo *mbo)\n{\n\tstruct most_channel_config *const conf = &mdev->conf[channel];\n\tunsigned int frame_size = get_stream_frame_size(&mdev->dev, conf);\n\tunsigned int j, num_frames;\n\n\tif (!frame_size)\n\t\treturn -EINVAL;\n\tnum_frames = mbo->processed_length / USB_MTU;\n\n\tfor (j = 1; j < num_frames; j++)\n\t\tmemmove(mbo->virt_address + frame_size * j,\n\t\t\tmbo->virt_address + USB_MTU * j,\n\t\t\tframe_size);\n\n\tmbo->processed_length = frame_size * num_frames;\n\treturn 0;\n}\n\n \nstatic void hdm_write_completion(struct urb *urb)\n{\n\tstruct mbo *mbo = urb->context;\n\tstruct most_dev *mdev = to_mdev(mbo->ifp);\n\tunsigned int channel = mbo->hdm_channel_id;\n\tspinlock_t *lock = mdev->channel_lock + channel;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(lock, flags);\n\n\tmbo->processed_length = 0;\n\tmbo->status = MBO_E_INVAL;\n\tif (likely(mdev->is_channel_healthy[channel])) {\n\t\tswitch (urb->status) {\n\t\tcase 0:\n\t\tcase -ESHUTDOWN:\n\t\t\tmbo->processed_length = urb->actual_length;\n\t\t\tmbo->status = MBO_SUCCESS;\n\t\t\tbreak;\n\t\tcase -EPIPE:\n\t\t\tdev_warn(&mdev->usb_device->dev,\n\t\t\t\t \"Broken pipe on ep%02x\\n\",\n\t\t\t\t mdev->ep_address[channel]);\n\t\t\tmdev->is_channel_healthy[channel] = false;\n\t\t\tmdev->clear_work[channel].pipe = urb->pipe;\n\t\t\tschedule_work(&mdev->clear_work[channel].ws);\n\t\t\tbreak;\n\t\tcase -ENODEV:\n\t\tcase -EPROTO:\n\t\t\tmbo->status = MBO_E_CLOSE;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(lock, flags);\n\n\tif (likely(mbo->complete))\n\t\tmbo->complete(mbo);\n\tusb_free_urb(urb);\n}\n\n \nstatic void hdm_read_completion(struct urb *urb)\n{\n\tstruct mbo *mbo = urb->context;\n\tstruct most_dev *mdev = to_mdev(mbo->ifp);\n\tunsigned int channel = mbo->hdm_channel_id;\n\tstruct device *dev = &mdev->usb_device->dev;\n\tspinlock_t *lock = mdev->channel_lock + channel;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(lock, flags);\n\n\tmbo->processed_length = 0;\n\tmbo->status = MBO_E_INVAL;\n\tif (likely(mdev->is_channel_healthy[channel])) {\n\t\tswitch (urb->status) {\n\t\tcase 0:\n\t\tcase -ESHUTDOWN:\n\t\t\tmbo->processed_length = urb->actual_length;\n\t\t\tmbo->status = MBO_SUCCESS;\n\t\t\tif (mdev->padding_active[channel] &&\n\t\t\t    hdm_remove_padding(mdev, channel, mbo)) {\n\t\t\t\tmbo->processed_length = 0;\n\t\t\t\tmbo->status = MBO_E_INVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase -EPIPE:\n\t\t\tdev_warn(dev, \"Broken pipe on ep%02x\\n\",\n\t\t\t\t mdev->ep_address[channel]);\n\t\t\tmdev->is_channel_healthy[channel] = false;\n\t\t\tmdev->clear_work[channel].pipe = urb->pipe;\n\t\t\tschedule_work(&mdev->clear_work[channel].ws);\n\t\t\tbreak;\n\t\tcase -ENODEV:\n\t\tcase -EPROTO:\n\t\t\tmbo->status = MBO_E_CLOSE;\n\t\t\tbreak;\n\t\tcase -EOVERFLOW:\n\t\t\tdev_warn(dev, \"Babble on ep%02x\\n\",\n\t\t\t\t mdev->ep_address[channel]);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(lock, flags);\n\n\tif (likely(mbo->complete))\n\t\tmbo->complete(mbo);\n\tusb_free_urb(urb);\n}\n\n \nstatic int hdm_enqueue(struct most_interface *iface, int channel,\n\t\t       struct mbo *mbo)\n{\n\tstruct most_dev *mdev = to_mdev(iface);\n\tstruct most_channel_config *conf;\n\tint retval = 0;\n\tstruct urb *urb;\n\tunsigned long length;\n\tvoid *virt_address;\n\n\tif (!mbo)\n\t\treturn -EINVAL;\n\tif (iface->num_channels <= channel || channel < 0)\n\t\treturn -ECHRNG;\n\n\turb = usb_alloc_urb(NO_ISOCHRONOUS_URB, GFP_KERNEL);\n\tif (!urb)\n\t\treturn -ENOMEM;\n\n\tconf = &mdev->conf[channel];\n\n\tmutex_lock(&mdev->io_mutex);\n\tif (!mdev->usb_device) {\n\t\tretval = -ENODEV;\n\t\tgoto err_free_urb;\n\t}\n\n\tif ((conf->direction & MOST_CH_TX) && mdev->padding_active[channel] &&\n\t    hdm_add_padding(mdev, channel, mbo)) {\n\t\tretval = -EINVAL;\n\t\tgoto err_free_urb;\n\t}\n\n\turb->transfer_dma = mbo->bus_address;\n\tvirt_address = mbo->virt_address;\n\tlength = mbo->buffer_length;\n\n\tif (conf->direction & MOST_CH_TX) {\n\t\tusb_fill_bulk_urb(urb, mdev->usb_device,\n\t\t\t\t  usb_sndbulkpipe(mdev->usb_device,\n\t\t\t\t\t\t  mdev->ep_address[channel]),\n\t\t\t\t  virt_address,\n\t\t\t\t  length,\n\t\t\t\t  hdm_write_completion,\n\t\t\t\t  mbo);\n\t\tif (conf->data_type != MOST_CH_ISOC &&\n\t\t    conf->data_type != MOST_CH_SYNC)\n\t\t\turb->transfer_flags |= URB_ZERO_PACKET;\n\t} else {\n\t\tusb_fill_bulk_urb(urb, mdev->usb_device,\n\t\t\t\t  usb_rcvbulkpipe(mdev->usb_device,\n\t\t\t\t\t\t  mdev->ep_address[channel]),\n\t\t\t\t  virt_address,\n\t\t\t\t  length + conf->extra_len,\n\t\t\t\t  hdm_read_completion,\n\t\t\t\t  mbo);\n\t}\n\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\tusb_anchor_urb(urb, &mdev->busy_urbs[channel]);\n\n\tretval = usb_submit_urb(urb, GFP_KERNEL);\n\tif (retval) {\n\t\tdev_err(&mdev->usb_device->dev,\n\t\t\t\"URB submit failed with error %d.\\n\", retval);\n\t\tgoto err_unanchor_urb;\n\t}\n\tmutex_unlock(&mdev->io_mutex);\n\treturn 0;\n\nerr_unanchor_urb:\n\tusb_unanchor_urb(urb);\nerr_free_urb:\n\tusb_free_urb(urb);\n\tmutex_unlock(&mdev->io_mutex);\n\treturn retval;\n}\n\nstatic void *hdm_dma_alloc(struct mbo *mbo, u32 size)\n{\n\tstruct most_dev *mdev = to_mdev(mbo->ifp);\n\n\treturn usb_alloc_coherent(mdev->usb_device, size, GFP_KERNEL,\n\t\t\t\t  &mbo->bus_address);\n}\n\nstatic void hdm_dma_free(struct mbo *mbo, u32 size)\n{\n\tstruct most_dev *mdev = to_mdev(mbo->ifp);\n\n\tusb_free_coherent(mdev->usb_device, size, mbo->virt_address,\n\t\t\t  mbo->bus_address);\n}\n\n \nstatic int hdm_configure_channel(struct most_interface *iface, int channel,\n\t\t\t\t struct most_channel_config *conf)\n{\n\tunsigned int num_frames;\n\tunsigned int frame_size;\n\tstruct most_dev *mdev = to_mdev(iface);\n\tstruct device *dev = &mdev->usb_device->dev;\n\n\tif (!conf) {\n\t\tdev_err(dev, \"Bad config pointer.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (channel < 0 || channel >= iface->num_channels) {\n\t\tdev_err(dev, \"Channel ID out of range.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmdev->is_channel_healthy[channel] = true;\n\tmdev->clear_work[channel].channel = channel;\n\tmdev->clear_work[channel].mdev = mdev;\n\tINIT_WORK(&mdev->clear_work[channel].ws, wq_clear_halt);\n\n\tif (!conf->num_buffers || !conf->buffer_size) {\n\t\tdev_err(dev, \"Misconfig: buffer size or #buffers zero.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (conf->data_type != MOST_CH_SYNC &&\n\t    !(conf->data_type == MOST_CH_ISOC &&\n\t      conf->packets_per_xact != 0xFF)) {\n\t\tmdev->padding_active[channel] = false;\n\t\t \n\t\tgoto exit;\n\t}\n\n\tmdev->padding_active[channel] = true;\n\n\tframe_size = get_stream_frame_size(&mdev->dev, conf);\n\tif (frame_size == 0 || frame_size > USB_MTU) {\n\t\tdev_warn(dev, \"Misconfig: frame size wrong\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tnum_frames = conf->buffer_size / frame_size;\n\n\tif (conf->buffer_size % frame_size) {\n\t\tu16 old_size = conf->buffer_size;\n\n\t\tconf->buffer_size = num_frames * frame_size;\n\t\tdev_warn(dev, \"%s: fixed buffer size (%d -> %d)\\n\",\n\t\t\t mdev->suffix[channel], old_size, conf->buffer_size);\n\t}\n\n\t \n\tconf->extra_len = num_frames * (USB_MTU - frame_size);\n\nexit:\n\tmdev->conf[channel] = *conf;\n\tif (conf->data_type == MOST_CH_ASYNC) {\n\t\tu16 ep = mdev->ep_address[channel];\n\n\t\tif (start_sync_ep(mdev->usb_device, ep) < 0)\n\t\t\tdev_warn(dev, \"sync for ep%02x failed\", ep);\n\t}\n\treturn 0;\n}\n\n \nstatic void hdm_request_netinfo(struct most_interface *iface, int channel,\n\t\t\t\tvoid (*on_netinfo)(struct most_interface *,\n\t\t\t\t\t\t   unsigned char,\n\t\t\t\t\t\t   unsigned char *))\n{\n\tstruct most_dev *mdev = to_mdev(iface);\n\n\tmdev->on_netinfo = on_netinfo;\n\tif (!on_netinfo)\n\t\treturn;\n\n\tmdev->link_stat_timer.expires = jiffies + HZ;\n\tmod_timer(&mdev->link_stat_timer, mdev->link_stat_timer.expires);\n}\n\n \nstatic void link_stat_timer_handler(struct timer_list *t)\n{\n\tstruct most_dev *mdev = from_timer(mdev, t, link_stat_timer);\n\n\tschedule_work(&mdev->poll_work_obj);\n\tmdev->link_stat_timer.expires = jiffies + (2 * HZ);\n\tadd_timer(&mdev->link_stat_timer);\n}\n\n \nstatic void wq_netinfo(struct work_struct *wq_obj)\n{\n\tstruct most_dev *mdev = to_mdev_from_work(wq_obj);\n\tstruct usb_device *usb_device = mdev->usb_device;\n\tstruct device *dev = &usb_device->dev;\n\tu16 hi, mi, lo, link;\n\tu8 hw_addr[6];\n\n\tif (drci_rd_reg(usb_device, DRCI_REG_HW_ADDR_HI, &hi)) {\n\t\tdev_err(dev, \"Vendor request 'hw_addr_hi' failed\\n\");\n\t\treturn;\n\t}\n\n\tif (drci_rd_reg(usb_device, DRCI_REG_HW_ADDR_MI, &mi)) {\n\t\tdev_err(dev, \"Vendor request 'hw_addr_mid' failed\\n\");\n\t\treturn;\n\t}\n\n\tif (drci_rd_reg(usb_device, DRCI_REG_HW_ADDR_LO, &lo)) {\n\t\tdev_err(dev, \"Vendor request 'hw_addr_low' failed\\n\");\n\t\treturn;\n\t}\n\n\tif (drci_rd_reg(usb_device, DRCI_REG_NI_STATE, &link)) {\n\t\tdev_err(dev, \"Vendor request 'link status' failed\\n\");\n\t\treturn;\n\t}\n\n\thw_addr[0] = hi >> 8;\n\thw_addr[1] = hi;\n\thw_addr[2] = mi >> 8;\n\thw_addr[3] = mi;\n\thw_addr[4] = lo >> 8;\n\thw_addr[5] = lo;\n\n\tif (mdev->on_netinfo)\n\t\tmdev->on_netinfo(&mdev->iface, link, hw_addr);\n}\n\n \nstatic void wq_clear_halt(struct work_struct *wq_obj)\n{\n\tstruct clear_hold_work *clear_work = to_clear_hold_work(wq_obj);\n\tstruct most_dev *mdev = clear_work->mdev;\n\tunsigned int channel = clear_work->channel;\n\tint pipe = clear_work->pipe;\n\tint snd_pipe;\n\tint peer;\n\n\tmutex_lock(&mdev->io_mutex);\n\tmost_stop_enqueue(&mdev->iface, channel);\n\tusb_kill_anchored_urbs(&mdev->busy_urbs[channel]);\n\tif (usb_clear_halt(mdev->usb_device, pipe))\n\t\tdev_warn(&mdev->usb_device->dev, \"Failed to reset endpoint.\\n\");\n\n\t \n\tif (mdev->conf[channel].data_type == MOST_CH_ASYNC &&\n\t    mdev->conf[channel].direction == MOST_CH_RX) {\n\t\tif (channel == 0)\n\t\t\tpeer = 1;\n\t\telse\n\t\t\tpeer = 0;\n\t\tsnd_pipe = usb_sndbulkpipe(mdev->usb_device,\n\t\t\t\t\t   mdev->ep_address[peer]);\n\t\tusb_clear_halt(mdev->usb_device, snd_pipe);\n\t}\n\tmdev->is_channel_healthy[channel] = true;\n\tmost_resume_enqueue(&mdev->iface, channel);\n\tmutex_unlock(&mdev->io_mutex);\n}\n\n \nstatic const struct file_operations hdm_usb_fops = {\n\t.owner = THIS_MODULE,\n};\n\n \nstatic const struct usb_device_id usbid[] = {\n\t{ USB_DEVICE(USB_VENDOR_ID_SMSC, USB_DEV_ID_BRDG), },\n\t{ USB_DEVICE(USB_VENDOR_ID_SMSC, USB_DEV_ID_OS81118), },\n\t{ USB_DEVICE(USB_VENDOR_ID_SMSC, USB_DEV_ID_OS81119), },\n\t{ USB_DEVICE(USB_VENDOR_ID_SMSC, USB_DEV_ID_OS81210), },\n\t{ }  \n};\n\nstruct regs {\n\tconst char *name;\n\tu16 reg;\n};\n\nstatic const struct regs ro_regs[] = {\n\t{ \"ni_state\", DRCI_REG_NI_STATE },\n\t{ \"packet_bandwidth\", DRCI_REG_PACKET_BW },\n\t{ \"node_address\", DRCI_REG_NODE_ADDR },\n\t{ \"node_position\", DRCI_REG_NODE_POS },\n};\n\nstatic const struct regs rw_regs[] = {\n\t{ \"mep_filter\", DRCI_REG_MEP_FILTER },\n\t{ \"mep_hash0\", DRCI_REG_HASH_TBL0 },\n\t{ \"mep_hash1\", DRCI_REG_HASH_TBL1 },\n\t{ \"mep_hash2\", DRCI_REG_HASH_TBL2 },\n\t{ \"mep_hash3\", DRCI_REG_HASH_TBL3 },\n\t{ \"mep_eui48_hi\", DRCI_REG_HW_ADDR_HI },\n\t{ \"mep_eui48_mi\", DRCI_REG_HW_ADDR_MI },\n\t{ \"mep_eui48_lo\", DRCI_REG_HW_ADDR_LO },\n};\n\nstatic int get_stat_reg_addr(const struct regs *regs, int size,\n\t\t\t     const char *name, u16 *reg_addr)\n{\n\tint i;\n\n\tfor (i = 0; i < size; i++) {\n\t\tif (sysfs_streq(name, regs[i].name)) {\n\t\t\t*reg_addr = regs[i].reg;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\n#define get_static_reg_addr(regs, name, reg_addr) \\\n\tget_stat_reg_addr(regs, ARRAY_SIZE(regs), name, reg_addr)\n\nstatic ssize_t value_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tconst char *name = attr->attr.name;\n\tstruct most_dci_obj *dci_obj = to_dci_obj(dev);\n\tu16 val;\n\tu16 reg_addr;\n\tint err;\n\n\tif (sysfs_streq(name, \"arb_address\"))\n\t\treturn sysfs_emit(buf, \"%04x\\n\", dci_obj->reg_addr);\n\n\tif (sysfs_streq(name, \"arb_value\"))\n\t\treg_addr = dci_obj->reg_addr;\n\telse if (get_static_reg_addr(ro_regs, name, &reg_addr) &&\n\t\t get_static_reg_addr(rw_regs, name, &reg_addr))\n\t\treturn -EINVAL;\n\n\terr = drci_rd_reg(dci_obj->usb_device, reg_addr, &val);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn sysfs_emit(buf, \"%04x\\n\", val);\n}\n\nstatic ssize_t value_store(struct device *dev, struct device_attribute *attr,\n\t\t\t   const char *buf, size_t count)\n{\n\tu16 val;\n\tu16 reg_addr;\n\tconst char *name = attr->attr.name;\n\tstruct most_dci_obj *dci_obj = to_dci_obj(dev);\n\tstruct usb_device *usb_dev = dci_obj->usb_device;\n\tint err;\n\n\terr = kstrtou16(buf, 16, &val);\n\tif (err)\n\t\treturn err;\n\n\tif (sysfs_streq(name, \"arb_address\")) {\n\t\tdci_obj->reg_addr = val;\n\t\treturn count;\n\t}\n\n\tif (sysfs_streq(name, \"arb_value\"))\n\t\terr = drci_wr_reg(usb_dev, dci_obj->reg_addr, val);\n\telse if (sysfs_streq(name, \"sync_ep\"))\n\t\terr = start_sync_ep(usb_dev, val);\n\telse if (!get_static_reg_addr(rw_regs, name, &reg_addr))\n\t\terr = drci_wr_reg(usb_dev, reg_addr, val);\n\telse\n\t\treturn -EINVAL;\n\n\tif (err < 0)\n\t\treturn err;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR(ni_state, 0444, value_show, NULL);\nstatic DEVICE_ATTR(packet_bandwidth, 0444, value_show, NULL);\nstatic DEVICE_ATTR(node_address, 0444, value_show, NULL);\nstatic DEVICE_ATTR(node_position, 0444, value_show, NULL);\nstatic DEVICE_ATTR(sync_ep, 0200, NULL, value_store);\nstatic DEVICE_ATTR(mep_filter, 0644, value_show, value_store);\nstatic DEVICE_ATTR(mep_hash0, 0644, value_show, value_store);\nstatic DEVICE_ATTR(mep_hash1, 0644, value_show, value_store);\nstatic DEVICE_ATTR(mep_hash2, 0644, value_show, value_store);\nstatic DEVICE_ATTR(mep_hash3, 0644, value_show, value_store);\nstatic DEVICE_ATTR(mep_eui48_hi, 0644, value_show, value_store);\nstatic DEVICE_ATTR(mep_eui48_mi, 0644, value_show, value_store);\nstatic DEVICE_ATTR(mep_eui48_lo, 0644, value_show, value_store);\nstatic DEVICE_ATTR(arb_address, 0644, value_show, value_store);\nstatic DEVICE_ATTR(arb_value, 0644, value_show, value_store);\n\nstatic struct attribute *dci_attrs[] = {\n\t&dev_attr_ni_state.attr,\n\t&dev_attr_packet_bandwidth.attr,\n\t&dev_attr_node_address.attr,\n\t&dev_attr_node_position.attr,\n\t&dev_attr_sync_ep.attr,\n\t&dev_attr_mep_filter.attr,\n\t&dev_attr_mep_hash0.attr,\n\t&dev_attr_mep_hash1.attr,\n\t&dev_attr_mep_hash2.attr,\n\t&dev_attr_mep_hash3.attr,\n\t&dev_attr_mep_eui48_hi.attr,\n\t&dev_attr_mep_eui48_mi.attr,\n\t&dev_attr_mep_eui48_lo.attr,\n\t&dev_attr_arb_address.attr,\n\t&dev_attr_arb_value.attr,\n\tNULL,\n};\n\nATTRIBUTE_GROUPS(dci);\n\nstatic void release_dci(struct device *dev)\n{\n\tstruct most_dci_obj *dci = to_dci_obj(dev);\n\n\tput_device(dev->parent);\n\tkfree(dci);\n}\n\nstatic void release_mdev(struct device *dev)\n{\n\tstruct most_dev *mdev = to_mdev_from_dev(dev);\n\n\tkfree(mdev);\n}\n \nstatic int\nhdm_probe(struct usb_interface *interface, const struct usb_device_id *id)\n{\n\tstruct usb_host_interface *usb_iface_desc = interface->cur_altsetting;\n\tstruct usb_device *usb_dev = interface_to_usbdev(interface);\n\tstruct device *dev = &usb_dev->dev;\n\tstruct most_dev *mdev;\n\tunsigned int i;\n\tunsigned int num_endpoints;\n\tstruct most_channel_capability *tmp_cap;\n\tstruct usb_endpoint_descriptor *ep_desc;\n\tint ret = -ENOMEM;\n\n\tmdev = kzalloc(sizeof(*mdev), GFP_KERNEL);\n\tif (!mdev)\n\t\treturn -ENOMEM;\n\n\tusb_set_intfdata(interface, mdev);\n\tnum_endpoints = usb_iface_desc->desc.bNumEndpoints;\n\tif (num_endpoints > MAX_NUM_ENDPOINTS) {\n\t\tkfree(mdev);\n\t\treturn -EINVAL;\n\t}\n\tmutex_init(&mdev->io_mutex);\n\tINIT_WORK(&mdev->poll_work_obj, wq_netinfo);\n\ttimer_setup(&mdev->link_stat_timer, link_stat_timer_handler, 0);\n\n\tmdev->usb_device = usb_dev;\n\tmdev->link_stat_timer.expires = jiffies + (2 * HZ);\n\n\tmdev->iface.mod = hdm_usb_fops.owner;\n\tmdev->iface.dev = &mdev->dev;\n\tmdev->iface.driver_dev = &interface->dev;\n\tmdev->iface.interface = ITYPE_USB;\n\tmdev->iface.configure = hdm_configure_channel;\n\tmdev->iface.request_netinfo = hdm_request_netinfo;\n\tmdev->iface.enqueue = hdm_enqueue;\n\tmdev->iface.poison_channel = hdm_poison_channel;\n\tmdev->iface.dma_alloc = hdm_dma_alloc;\n\tmdev->iface.dma_free = hdm_dma_free;\n\tmdev->iface.description = mdev->description;\n\tmdev->iface.num_channels = num_endpoints;\n\n\tsnprintf(mdev->description, sizeof(mdev->description),\n\t\t \"%d-%s:%d.%d\",\n\t\t usb_dev->bus->busnum,\n\t\t usb_dev->devpath,\n\t\t usb_dev->config->desc.bConfigurationValue,\n\t\t usb_iface_desc->desc.bInterfaceNumber);\n\n\tmdev->dev.init_name = mdev->description;\n\tmdev->dev.parent = &interface->dev;\n\tmdev->dev.release = release_mdev;\n\tmdev->conf = kcalloc(num_endpoints, sizeof(*mdev->conf), GFP_KERNEL);\n\tif (!mdev->conf)\n\t\tgoto err_free_mdev;\n\n\tmdev->cap = kcalloc(num_endpoints, sizeof(*mdev->cap), GFP_KERNEL);\n\tif (!mdev->cap)\n\t\tgoto err_free_conf;\n\n\tmdev->iface.channel_vector = mdev->cap;\n\tmdev->ep_address =\n\t\tkcalloc(num_endpoints, sizeof(*mdev->ep_address), GFP_KERNEL);\n\tif (!mdev->ep_address)\n\t\tgoto err_free_cap;\n\n\tmdev->busy_urbs =\n\t\tkcalloc(num_endpoints, sizeof(*mdev->busy_urbs), GFP_KERNEL);\n\tif (!mdev->busy_urbs)\n\t\tgoto err_free_ep_address;\n\n\ttmp_cap = mdev->cap;\n\tfor (i = 0; i < num_endpoints; i++) {\n\t\tep_desc = &usb_iface_desc->endpoint[i].desc;\n\t\tmdev->ep_address[i] = ep_desc->bEndpointAddress;\n\t\tmdev->padding_active[i] = false;\n\t\tmdev->is_channel_healthy[i] = true;\n\n\t\tsnprintf(&mdev->suffix[i][0], MAX_SUFFIX_LEN, \"ep%02x\",\n\t\t\t mdev->ep_address[i]);\n\n\t\ttmp_cap->name_suffix = &mdev->suffix[i][0];\n\t\ttmp_cap->buffer_size_packet = MAX_BUF_SIZE;\n\t\ttmp_cap->buffer_size_streaming = MAX_BUF_SIZE;\n\t\ttmp_cap->num_buffers_packet = BUF_CHAIN_SIZE;\n\t\ttmp_cap->num_buffers_streaming = BUF_CHAIN_SIZE;\n\t\ttmp_cap->data_type = MOST_CH_CONTROL | MOST_CH_ASYNC |\n\t\t\t\t     MOST_CH_ISOC | MOST_CH_SYNC;\n\t\tif (usb_endpoint_dir_in(ep_desc))\n\t\t\ttmp_cap->direction = MOST_CH_RX;\n\t\telse\n\t\t\ttmp_cap->direction = MOST_CH_TX;\n\t\ttmp_cap++;\n\t\tinit_usb_anchor(&mdev->busy_urbs[i]);\n\t\tspin_lock_init(&mdev->channel_lock[i]);\n\t}\n\tdev_dbg(dev, \"claimed gadget: Vendor=%4.4x ProdID=%4.4x Bus=%02x Device=%02x\\n\",\n\t\tle16_to_cpu(usb_dev->descriptor.idVendor),\n\t\tle16_to_cpu(usb_dev->descriptor.idProduct),\n\t\tusb_dev->bus->busnum,\n\t\tusb_dev->devnum);\n\n\tdev_dbg(dev, \"device path: /sys/bus/usb/devices/%d-%s:%d.%d\\n\",\n\t\tusb_dev->bus->busnum,\n\t\tusb_dev->devpath,\n\t\tusb_dev->config->desc.bConfigurationValue,\n\t\tusb_iface_desc->desc.bInterfaceNumber);\n\n\tret = most_register_interface(&mdev->iface);\n\tif (ret)\n\t\tgoto err_free_busy_urbs;\n\n\tmutex_lock(&mdev->io_mutex);\n\tif (le16_to_cpu(usb_dev->descriptor.idProduct) == USB_DEV_ID_OS81118 ||\n\t    le16_to_cpu(usb_dev->descriptor.idProduct) == USB_DEV_ID_OS81119 ||\n\t    le16_to_cpu(usb_dev->descriptor.idProduct) == USB_DEV_ID_OS81210) {\n\t\tmdev->dci = kzalloc(sizeof(*mdev->dci), GFP_KERNEL);\n\t\tif (!mdev->dci) {\n\t\t\tmutex_unlock(&mdev->io_mutex);\n\t\t\tmost_deregister_interface(&mdev->iface);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_free_busy_urbs;\n\t\t}\n\n\t\tmdev->dci->dev.init_name = \"dci\";\n\t\tmdev->dci->dev.parent = get_device(mdev->iface.dev);\n\t\tmdev->dci->dev.groups = dci_groups;\n\t\tmdev->dci->dev.release = release_dci;\n\t\tif (device_register(&mdev->dci->dev)) {\n\t\t\tmutex_unlock(&mdev->io_mutex);\n\t\t\tmost_deregister_interface(&mdev->iface);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_free_dci;\n\t\t}\n\t\tmdev->dci->usb_device = mdev->usb_device;\n\t}\n\tmutex_unlock(&mdev->io_mutex);\n\treturn 0;\nerr_free_dci:\n\tput_device(&mdev->dci->dev);\nerr_free_busy_urbs:\n\tkfree(mdev->busy_urbs);\nerr_free_ep_address:\n\tkfree(mdev->ep_address);\nerr_free_cap:\n\tkfree(mdev->cap);\nerr_free_conf:\n\tkfree(mdev->conf);\nerr_free_mdev:\n\tput_device(&mdev->dev);\n\treturn ret;\n}\n\n \nstatic void hdm_disconnect(struct usb_interface *interface)\n{\n\tstruct most_dev *mdev = usb_get_intfdata(interface);\n\n\tmutex_lock(&mdev->io_mutex);\n\tusb_set_intfdata(interface, NULL);\n\tmdev->usb_device = NULL;\n\tmutex_unlock(&mdev->io_mutex);\n\n\tdel_timer_sync(&mdev->link_stat_timer);\n\tcancel_work_sync(&mdev->poll_work_obj);\n\n\tif (mdev->dci)\n\t\tdevice_unregister(&mdev->dci->dev);\n\tmost_deregister_interface(&mdev->iface);\n\n\tkfree(mdev->busy_urbs);\n\tkfree(mdev->cap);\n\tkfree(mdev->conf);\n\tkfree(mdev->ep_address);\n\tput_device(&mdev->dci->dev);\n\tput_device(&mdev->dev);\n}\n\nstatic int hdm_suspend(struct usb_interface *interface, pm_message_t message)\n{\n\tstruct most_dev *mdev = usb_get_intfdata(interface);\n\tint i;\n\n\tmutex_lock(&mdev->io_mutex);\n\tfor (i = 0; i < mdev->iface.num_channels; i++) {\n\t\tmost_stop_enqueue(&mdev->iface, i);\n\t\tusb_kill_anchored_urbs(&mdev->busy_urbs[i]);\n\t}\n\tmutex_unlock(&mdev->io_mutex);\n\treturn 0;\n}\n\nstatic int hdm_resume(struct usb_interface *interface)\n{\n\tstruct most_dev *mdev = usb_get_intfdata(interface);\n\tint i;\n\n\tmutex_lock(&mdev->io_mutex);\n\tfor (i = 0; i < mdev->iface.num_channels; i++)\n\t\tmost_resume_enqueue(&mdev->iface, i);\n\tmutex_unlock(&mdev->io_mutex);\n\treturn 0;\n}\n\nstatic struct usb_driver hdm_usb = {\n\t.name = \"hdm_usb\",\n\t.id_table = usbid,\n\t.probe = hdm_probe,\n\t.disconnect = hdm_disconnect,\n\t.resume = hdm_resume,\n\t.suspend = hdm_suspend,\n};\n\nmodule_usb_driver(hdm_usb);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Christian Gromm <christian.gromm@microchip.com>\");\nMODULE_DESCRIPTION(\"HDM_4_USB\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}