{
  "module_name": "most_snd.c",
  "hash_id": "c76f205690e7265db63f873ada7485fe99f8f844067a54f15ea5e1d3921da350",
  "original_prompt": "Ingested from linux-6.6.14/drivers/most/most_snd.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <linux/sched.h>\n#include <linux/kthread.h>\n#include <linux/most.h>\n\n#define DRIVER_NAME \"sound\"\n#define STRING_SIZE\t80\n\nstatic struct most_component comp;\n\n \nstruct channel {\n\tstruct snd_pcm_substream *substream;\n\tstruct snd_pcm_hardware pcm_hardware;\n\tstruct most_interface *iface;\n\tstruct most_channel_config *cfg;\n\tstruct snd_card *card;\n\tstruct list_head list;\n\tint id;\n\tunsigned int period_pos;\n\tunsigned int buffer_pos;\n\tbool is_stream_running;\n\tstruct task_struct *playback_task;\n\twait_queue_head_t playback_waitq;\n\tvoid (*copy_fn)(void *alsa, void *most, unsigned int bytes);\n};\n\nstruct sound_adapter {\n\tstruct list_head dev_list;\n\tstruct most_interface *iface;\n\tstruct snd_card *card;\n\tstruct list_head list;\n\tbool registered;\n\tint pcm_dev_idx;\n};\n\nstatic struct list_head adpt_list;\n\n#define MOST_PCM_INFO (SNDRV_PCM_INFO_MMAP | \\\n\t\t       SNDRV_PCM_INFO_MMAP_VALID | \\\n\t\t       SNDRV_PCM_INFO_BATCH | \\\n\t\t       SNDRV_PCM_INFO_INTERLEAVED | \\\n\t\t       SNDRV_PCM_INFO_BLOCK_TRANSFER)\n\nstatic void swap_copy16(u16 *dest, const u16 *source, unsigned int bytes)\n{\n\tunsigned int i = 0;\n\n\twhile (i < (bytes / 2)) {\n\t\tdest[i] = swab16(source[i]);\n\t\ti++;\n\t}\n}\n\nstatic void swap_copy24(u8 *dest, const u8 *source, unsigned int bytes)\n{\n\tunsigned int i = 0;\n\n\tif (bytes < 2)\n\t\treturn;\n\twhile (i < bytes - 2) {\n\t\tdest[i] = source[i + 2];\n\t\tdest[i + 1] = source[i + 1];\n\t\tdest[i + 2] = source[i];\n\t\ti += 3;\n\t}\n}\n\nstatic void swap_copy32(u32 *dest, const u32 *source, unsigned int bytes)\n{\n\tunsigned int i = 0;\n\n\twhile (i < bytes / 4) {\n\t\tdest[i] = swab32(source[i]);\n\t\ti++;\n\t}\n}\n\nstatic void alsa_to_most_memcpy(void *alsa, void *most, unsigned int bytes)\n{\n\tmemcpy(most, alsa, bytes);\n}\n\nstatic void alsa_to_most_copy16(void *alsa, void *most, unsigned int bytes)\n{\n\tswap_copy16(most, alsa, bytes);\n}\n\nstatic void alsa_to_most_copy24(void *alsa, void *most, unsigned int bytes)\n{\n\tswap_copy24(most, alsa, bytes);\n}\n\nstatic void alsa_to_most_copy32(void *alsa, void *most, unsigned int bytes)\n{\n\tswap_copy32(most, alsa, bytes);\n}\n\nstatic void most_to_alsa_memcpy(void *alsa, void *most, unsigned int bytes)\n{\n\tmemcpy(alsa, most, bytes);\n}\n\nstatic void most_to_alsa_copy16(void *alsa, void *most, unsigned int bytes)\n{\n\tswap_copy16(alsa, most, bytes);\n}\n\nstatic void most_to_alsa_copy24(void *alsa, void *most, unsigned int bytes)\n{\n\tswap_copy24(alsa, most, bytes);\n}\n\nstatic void most_to_alsa_copy32(void *alsa, void *most, unsigned int bytes)\n{\n\tswap_copy32(alsa, most, bytes);\n}\n\n \nstatic struct channel *get_channel(struct most_interface *iface,\n\t\t\t\t   int channel_id)\n{\n\tstruct sound_adapter *adpt = iface->priv;\n\tstruct channel *channel;\n\n\tlist_for_each_entry(channel, &adpt->dev_list, list) {\n\t\tif ((channel->iface == iface) && (channel->id == channel_id))\n\t\t\treturn channel;\n\t}\n\treturn NULL;\n}\n\n \nstatic bool copy_data(struct channel *channel, struct mbo *mbo)\n{\n\tstruct snd_pcm_runtime *const runtime = channel->substream->runtime;\n\tunsigned int const frame_bytes = channel->cfg->subbuffer_size;\n\tunsigned int const buffer_size = runtime->buffer_size;\n\tunsigned int frames;\n\tunsigned int fr0;\n\n\tif (channel->cfg->direction & MOST_CH_RX)\n\t\tframes = mbo->processed_length / frame_bytes;\n\telse\n\t\tframes = mbo->buffer_length / frame_bytes;\n\tfr0 = min(buffer_size - channel->buffer_pos, frames);\n\n\tchannel->copy_fn(runtime->dma_area + channel->buffer_pos * frame_bytes,\n\t\t\t mbo->virt_address,\n\t\t\t fr0 * frame_bytes);\n\n\tif (frames > fr0) {\n\t\t \n\t\tchannel->copy_fn(runtime->dma_area,\n\t\t\t\t mbo->virt_address + fr0 * frame_bytes,\n\t\t\t\t (frames - fr0) * frame_bytes);\n\t}\n\n\tchannel->buffer_pos += frames;\n\tif (channel->buffer_pos >= buffer_size)\n\t\tchannel->buffer_pos -= buffer_size;\n\tchannel->period_pos += frames;\n\tif (channel->period_pos >= runtime->period_size) {\n\t\tchannel->period_pos -= runtime->period_size;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nstatic int playback_thread(void *data)\n{\n\tstruct channel *const channel = data;\n\n\twhile (!kthread_should_stop()) {\n\t\tstruct mbo *mbo = NULL;\n\t\tbool period_elapsed = false;\n\n\t\twait_event_interruptible(\n\t\t\tchannel->playback_waitq,\n\t\t\tkthread_should_stop() ||\n\t\t\t(channel->is_stream_running &&\n\t\t\t (mbo = most_get_mbo(channel->iface, channel->id,\n\t\t\t\t\t     &comp))));\n\t\tif (!mbo)\n\t\t\tcontinue;\n\n\t\tif (channel->is_stream_running)\n\t\t\tperiod_elapsed = copy_data(channel, mbo);\n\t\telse\n\t\t\tmemset(mbo->virt_address, 0, mbo->buffer_length);\n\n\t\tmost_submit_mbo(mbo);\n\t\tif (period_elapsed)\n\t\t\tsnd_pcm_period_elapsed(channel->substream);\n\t}\n\treturn 0;\n}\n\n \nstatic int pcm_open(struct snd_pcm_substream *substream)\n{\n\tstruct channel *channel = substream->private_data;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct most_channel_config *cfg = channel->cfg;\n\tint ret;\n\n\tchannel->substream = substream;\n\n\tif (cfg->direction == MOST_CH_TX) {\n\t\tchannel->playback_task = kthread_run(playback_thread, channel,\n\t\t\t\t\t\t     \"most_audio_playback\");\n\t\tif (IS_ERR(channel->playback_task)) {\n\t\t\tpr_err(\"Couldn't start thread\\n\");\n\t\t\treturn PTR_ERR(channel->playback_task);\n\t\t}\n\t}\n\n\tret = most_start_channel(channel->iface, channel->id, &comp);\n\tif (ret) {\n\t\tpr_err(\"most_start_channel() failed!\\n\");\n\t\tif (cfg->direction == MOST_CH_TX)\n\t\t\tkthread_stop(channel->playback_task);\n\t\treturn ret;\n\t}\n\n\truntime->hw = channel->pcm_hardware;\n\treturn 0;\n}\n\n \nstatic int pcm_close(struct snd_pcm_substream *substream)\n{\n\tstruct channel *channel = substream->private_data;\n\n\tif (channel->cfg->direction == MOST_CH_TX)\n\t\tkthread_stop(channel->playback_task);\n\tmost_stop_channel(channel->iface, channel->id, &comp);\n\treturn 0;\n}\n\n \nstatic int pcm_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct channel *channel = substream->private_data;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct most_channel_config *cfg = channel->cfg;\n\tint width = snd_pcm_format_physical_width(runtime->format);\n\n\tchannel->copy_fn = NULL;\n\n\tif (cfg->direction == MOST_CH_TX) {\n\t\tif (snd_pcm_format_big_endian(runtime->format) || width == 8)\n\t\t\tchannel->copy_fn = alsa_to_most_memcpy;\n\t\telse if (width == 16)\n\t\t\tchannel->copy_fn = alsa_to_most_copy16;\n\t\telse if (width == 24)\n\t\t\tchannel->copy_fn = alsa_to_most_copy24;\n\t\telse if (width == 32)\n\t\t\tchannel->copy_fn = alsa_to_most_copy32;\n\t} else {\n\t\tif (snd_pcm_format_big_endian(runtime->format) || width == 8)\n\t\t\tchannel->copy_fn = most_to_alsa_memcpy;\n\t\telse if (width == 16)\n\t\t\tchannel->copy_fn = most_to_alsa_copy16;\n\t\telse if (width == 24)\n\t\t\tchannel->copy_fn = most_to_alsa_copy24;\n\t\telse if (width == 32)\n\t\t\tchannel->copy_fn = most_to_alsa_copy32;\n\t}\n\n\tif (!channel->copy_fn)\n\t\treturn -EINVAL;\n\tchannel->period_pos = 0;\n\tchannel->buffer_pos = 0;\n\treturn 0;\n}\n\n \nstatic int pcm_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct channel *channel = substream->private_data;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tchannel->is_stream_running = true;\n\t\twake_up_interruptible(&channel->playback_waitq);\n\t\treturn 0;\n\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tchannel->is_stream_running = false;\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nstatic snd_pcm_uframes_t pcm_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct channel *channel = substream->private_data;\n\n\treturn channel->buffer_pos;\n}\n\n \nstatic const struct snd_pcm_ops pcm_ops = {\n\t.open       = pcm_open,\n\t.close      = pcm_close,\n\t.prepare    = pcm_prepare,\n\t.trigger    = pcm_trigger,\n\t.pointer    = pcm_pointer,\n};\n\nstatic int split_arg_list(char *buf, u16 *ch_num, char **sample_res)\n{\n\tchar *num;\n\tint ret;\n\n\tnum = strsep(&buf, \"x\");\n\tif (!num)\n\t\tgoto err;\n\tret = kstrtou16(num, 0, ch_num);\n\tif (ret)\n\t\tgoto err;\n\t*sample_res = strsep(&buf, \".\\n\");\n\tif (!*sample_res)\n\t\tgoto err;\n\treturn 0;\n\nerr:\n\tpr_err(\"Bad PCM format\\n\");\n\treturn -EINVAL;\n}\n\nstatic const struct sample_resolution_info {\n\tconst char *sample_res;\n\tint bytes;\n\tu64 formats;\n} sinfo[] = {\n\t{ \"8\", 1, SNDRV_PCM_FMTBIT_S8 },\n\t{ \"16\", 2, SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S16_BE },\n\t{ \"24\", 3, SNDRV_PCM_FMTBIT_S24_3LE | SNDRV_PCM_FMTBIT_S24_3BE },\n\t{ \"32\", 4, SNDRV_PCM_FMTBIT_S32_LE | SNDRV_PCM_FMTBIT_S32_BE },\n};\n\nstatic int audio_set_hw_params(struct snd_pcm_hardware *pcm_hw,\n\t\t\t       u16 ch_num, char *sample_res,\n\t\t\t       struct most_channel_config *cfg)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(sinfo); i++) {\n\t\tif (!strcmp(sample_res, sinfo[i].sample_res))\n\t\t\tgoto found;\n\t}\n\tpr_err(\"Unsupported PCM format\\n\");\n\treturn -EINVAL;\n\nfound:\n\tif (!ch_num) {\n\t\tpr_err(\"Bad number of channels\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (cfg->subbuffer_size != ch_num * sinfo[i].bytes) {\n\t\tpr_err(\"Audio resolution doesn't fit subbuffer size\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpcm_hw->info = MOST_PCM_INFO;\n\tpcm_hw->rates = SNDRV_PCM_RATE_48000;\n\tpcm_hw->rate_min = 48000;\n\tpcm_hw->rate_max = 48000;\n\tpcm_hw->buffer_bytes_max = cfg->num_buffers * cfg->buffer_size;\n\tpcm_hw->period_bytes_min = cfg->buffer_size;\n\tpcm_hw->period_bytes_max = cfg->buffer_size;\n\tpcm_hw->periods_min = 1;\n\tpcm_hw->periods_max = cfg->num_buffers;\n\tpcm_hw->channels_min = ch_num;\n\tpcm_hw->channels_max = ch_num;\n\tpcm_hw->formats = sinfo[i].formats;\n\treturn 0;\n}\n\nstatic void release_adapter(struct sound_adapter *adpt)\n{\n\tstruct channel *channel, *tmp;\n\n\tlist_for_each_entry_safe(channel, tmp, &adpt->dev_list, list) {\n\t\tlist_del(&channel->list);\n\t\tkfree(channel);\n\t}\n\tif (adpt->card)\n\t\tsnd_card_free(adpt->card);\n\tlist_del(&adpt->list);\n\tkfree(adpt);\n}\n\n \nstatic int audio_probe_channel(struct most_interface *iface, int channel_id,\n\t\t\t       struct most_channel_config *cfg,\n\t\t\t       char *device_name, char *arg_list)\n{\n\tstruct channel *channel;\n\tstruct sound_adapter *adpt;\n\tstruct snd_pcm *pcm;\n\tint playback_count = 0;\n\tint capture_count = 0;\n\tint ret;\n\tint direction;\n\tu16 ch_num;\n\tchar *sample_res;\n\tchar arg_list_cpy[STRING_SIZE];\n\n\tif (cfg->data_type != MOST_CH_SYNC) {\n\t\tpr_err(\"Incompatible channel type\\n\");\n\t\treturn -EINVAL;\n\t}\n\tstrscpy(arg_list_cpy, arg_list, STRING_SIZE);\n\tret = split_arg_list(arg_list_cpy, &ch_num, &sample_res);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tlist_for_each_entry(adpt, &adpt_list, list) {\n\t\tif (adpt->iface != iface)\n\t\t\tcontinue;\n\t\tif (adpt->registered)\n\t\t\treturn -ENOSPC;\n\t\tadpt->pcm_dev_idx++;\n\t\tgoto skip_adpt_alloc;\n\t}\n\tadpt = kzalloc(sizeof(*adpt), GFP_KERNEL);\n\tif (!adpt)\n\t\treturn -ENOMEM;\n\n\tadpt->iface = iface;\n\tINIT_LIST_HEAD(&adpt->dev_list);\n\tiface->priv = adpt;\n\tlist_add_tail(&adpt->list, &adpt_list);\n\tret = snd_card_new(iface->driver_dev, -1, \"INIC\", THIS_MODULE,\n\t\t\t   sizeof(*channel), &adpt->card);\n\tif (ret < 0)\n\t\tgoto err_free_adpt;\n\tsnprintf(adpt->card->driver, sizeof(adpt->card->driver),\n\t\t \"%s\", DRIVER_NAME);\n\tsnprintf(adpt->card->shortname, sizeof(adpt->card->shortname),\n\t\t \"Microchip INIC\");\n\tsnprintf(adpt->card->longname, sizeof(adpt->card->longname),\n\t\t \"%s at %s\", adpt->card->shortname, iface->description);\nskip_adpt_alloc:\n\tif (get_channel(iface, channel_id)) {\n\t\tpr_err(\"channel (%s:%d) is already linked\\n\",\n\t\t       iface->description, channel_id);\n\t\treturn -EEXIST;\n\t}\n\n\tif (cfg->direction == MOST_CH_TX) {\n\t\tplayback_count = 1;\n\t\tdirection = SNDRV_PCM_STREAM_PLAYBACK;\n\t} else {\n\t\tcapture_count = 1;\n\t\tdirection = SNDRV_PCM_STREAM_CAPTURE;\n\t}\n\tchannel = kzalloc(sizeof(*channel), GFP_KERNEL);\n\tif (!channel) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_adpt;\n\t}\n\tchannel->card = adpt->card;\n\tchannel->cfg = cfg;\n\tchannel->iface = iface;\n\tchannel->id = channel_id;\n\tinit_waitqueue_head(&channel->playback_waitq);\n\tlist_add_tail(&channel->list, &adpt->dev_list);\n\n\tret = audio_set_hw_params(&channel->pcm_hardware, ch_num, sample_res,\n\t\t\t\t  cfg);\n\tif (ret)\n\t\tgoto err_free_adpt;\n\n\tret = snd_pcm_new(adpt->card, device_name, adpt->pcm_dev_idx,\n\t\t\t  playback_count, capture_count, &pcm);\n\n\tif (ret < 0)\n\t\tgoto err_free_adpt;\n\n\tpcm->private_data = channel;\n\tstrscpy(pcm->name, device_name, sizeof(pcm->name));\n\tsnd_pcm_set_ops(pcm, direction, &pcm_ops);\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_VMALLOC, NULL, 0, 0);\n\treturn 0;\n\nerr_free_adpt:\n\trelease_adapter(adpt);\n\treturn ret;\n}\n\nstatic int audio_create_sound_card(void)\n{\n\tint ret;\n\tstruct sound_adapter *adpt;\n\n\tlist_for_each_entry(adpt, &adpt_list, list) {\n\t\tif (!adpt->registered)\n\t\t\tgoto adpt_alloc;\n\t}\n\treturn -ENODEV;\nadpt_alloc:\n\tret = snd_card_register(adpt->card);\n\tif (ret < 0) {\n\t\trelease_adapter(adpt);\n\t\treturn ret;\n\t}\n\tadpt->registered = true;\n\treturn 0;\n}\n\n \nstatic int audio_disconnect_channel(struct most_interface *iface,\n\t\t\t\t    int channel_id)\n{\n\tstruct channel *channel;\n\tstruct sound_adapter *adpt = iface->priv;\n\n\tchannel = get_channel(iface, channel_id);\n\tif (!channel)\n\t\treturn -EINVAL;\n\n\tlist_del(&channel->list);\n\n\tkfree(channel);\n\tif (list_empty(&adpt->dev_list))\n\t\trelease_adapter(adpt);\n\treturn 0;\n}\n\n \nstatic int audio_rx_completion(struct mbo *mbo)\n{\n\tstruct channel *channel = get_channel(mbo->ifp, mbo->hdm_channel_id);\n\tbool period_elapsed = false;\n\n\tif (!channel)\n\t\treturn -EINVAL;\n\tif (channel->is_stream_running)\n\t\tperiod_elapsed = copy_data(channel, mbo);\n\tmost_put_mbo(mbo);\n\tif (period_elapsed)\n\t\tsnd_pcm_period_elapsed(channel->substream);\n\treturn 0;\n}\n\n \nstatic int audio_tx_completion(struct most_interface *iface, int channel_id)\n{\n\tstruct channel *channel = get_channel(iface, channel_id);\n\n\tif (!channel)\n\t\treturn -EINVAL;\n\n\twake_up_interruptible(&channel->playback_waitq);\n\treturn 0;\n}\n\n \nstatic struct most_component comp = {\n\t.mod = THIS_MODULE,\n\t.name = DRIVER_NAME,\n\t.probe_channel = audio_probe_channel,\n\t.disconnect_channel = audio_disconnect_channel,\n\t.rx_completion = audio_rx_completion,\n\t.tx_completion = audio_tx_completion,\n\t.cfg_complete = audio_create_sound_card,\n};\n\nstatic int __init audio_init(void)\n{\n\tint ret;\n\n\tINIT_LIST_HEAD(&adpt_list);\n\n\tret = most_register_component(&comp);\n\tif (ret) {\n\t\tpr_err(\"Failed to register %s\\n\", comp.name);\n\t\treturn ret;\n\t}\n\tret = most_register_configfs_subsys(&comp);\n\tif (ret) {\n\t\tpr_err(\"Failed to register %s configfs subsys\\n\", comp.name);\n\t\tmost_deregister_component(&comp);\n\t}\n\treturn ret;\n}\n\nstatic void __exit audio_exit(void)\n{\n\tmost_deregister_configfs_subsys(&comp);\n\tmost_deregister_component(&comp);\n}\n\nmodule_init(audio_init);\nmodule_exit(audio_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Christian Gromm <christian.gromm@microchip.com>\");\nMODULE_DESCRIPTION(\"Sound Component Module for Mostcore\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}