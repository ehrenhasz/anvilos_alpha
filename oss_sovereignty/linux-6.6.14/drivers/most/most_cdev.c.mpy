{
  "module_name": "most_cdev.c",
  "hash_id": "51e4d64a37cdea1721516eaf8ae66b487270a2eb9fe2287705891cb53fffb0cb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/most/most_cdev.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n#include <linux/poll.h>\n#include <linux/kfifo.h>\n#include <linux/uaccess.h>\n#include <linux/idr.h>\n#include <linux/most.h>\n\n#define CHRDEV_REGION_SIZE 50\n\nstatic struct cdev_component {\n\tdev_t devno;\n\tstruct ida minor_id;\n\tunsigned int major;\n\tstruct class *class;\n\tstruct most_component cc;\n} comp;\n\nstruct comp_channel {\n\twait_queue_head_t wq;\n\tspinlock_t unlink;\t \n\tstruct cdev cdev;\n\tstruct device *dev;\n\tstruct mutex io_mutex;\n\tstruct most_interface *iface;\n\tstruct most_channel_config *cfg;\n\tunsigned int channel_id;\n\tdev_t devno;\n\tsize_t mbo_offs;\n\tDECLARE_KFIFO_PTR(fifo, typeof(struct mbo *));\n\tint access_ref;\n\tstruct list_head list;\n};\n\n#define to_channel(d) container_of(d, struct comp_channel, cdev)\nstatic LIST_HEAD(channel_list);\nstatic DEFINE_SPINLOCK(ch_list_lock);\n\nstatic inline bool ch_has_mbo(struct comp_channel *c)\n{\n\treturn channel_has_mbo(c->iface, c->channel_id, &comp.cc) > 0;\n}\n\nstatic inline struct mbo *ch_get_mbo(struct comp_channel *c, struct mbo **mbo)\n{\n\tif (!kfifo_peek(&c->fifo, mbo)) {\n\t\t*mbo = most_get_mbo(c->iface, c->channel_id, &comp.cc);\n\t\tif (*mbo)\n\t\t\tkfifo_in(&c->fifo, mbo, 1);\n\t}\n\treturn *mbo;\n}\n\nstatic struct comp_channel *get_channel(struct most_interface *iface, int id)\n{\n\tstruct comp_channel *c, *tmp;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ch_list_lock, flags);\n\tlist_for_each_entry_safe(c, tmp, &channel_list, list) {\n\t\tif ((c->iface == iface) && (c->channel_id == id)) {\n\t\t\tspin_unlock_irqrestore(&ch_list_lock, flags);\n\t\t\treturn c;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&ch_list_lock, flags);\n\treturn NULL;\n}\n\nstatic void stop_channel(struct comp_channel *c)\n{\n\tstruct mbo *mbo;\n\n\twhile (kfifo_out((struct kfifo *)&c->fifo, &mbo, 1))\n\t\tmost_put_mbo(mbo);\n\tmost_stop_channel(c->iface, c->channel_id, &comp.cc);\n}\n\nstatic void destroy_cdev(struct comp_channel *c)\n{\n\tunsigned long flags;\n\n\tdevice_destroy(comp.class, c->devno);\n\tcdev_del(&c->cdev);\n\tspin_lock_irqsave(&ch_list_lock, flags);\n\tlist_del(&c->list);\n\tspin_unlock_irqrestore(&ch_list_lock, flags);\n}\n\nstatic void destroy_channel(struct comp_channel *c)\n{\n\tida_simple_remove(&comp.minor_id, MINOR(c->devno));\n\tkfifo_free(&c->fifo);\n\tkfree(c);\n}\n\n \nstatic int comp_open(struct inode *inode, struct file *filp)\n{\n\tstruct comp_channel *c;\n\tint ret;\n\n\tc = to_channel(inode->i_cdev);\n\tfilp->private_data = c;\n\n\tif (((c->cfg->direction == MOST_CH_RX) &&\n\t     ((filp->f_flags & O_ACCMODE) != O_RDONLY)) ||\n\t     ((c->cfg->direction == MOST_CH_TX) &&\n\t\t((filp->f_flags & O_ACCMODE) != O_WRONLY))) {\n\t\treturn -EACCES;\n\t}\n\n\tmutex_lock(&c->io_mutex);\n\tif (!c->dev) {\n\t\tmutex_unlock(&c->io_mutex);\n\t\treturn -ENODEV;\n\t}\n\n\tif (c->access_ref) {\n\t\tmutex_unlock(&c->io_mutex);\n\t\treturn -EBUSY;\n\t}\n\n\tc->mbo_offs = 0;\n\tret = most_start_channel(c->iface, c->channel_id, &comp.cc);\n\tif (!ret)\n\t\tc->access_ref = 1;\n\tmutex_unlock(&c->io_mutex);\n\treturn ret;\n}\n\n \nstatic int comp_close(struct inode *inode, struct file *filp)\n{\n\tstruct comp_channel *c = to_channel(inode->i_cdev);\n\n\tmutex_lock(&c->io_mutex);\n\tspin_lock(&c->unlink);\n\tc->access_ref = 0;\n\tspin_unlock(&c->unlink);\n\tif (c->dev) {\n\t\tstop_channel(c);\n\t\tmutex_unlock(&c->io_mutex);\n\t} else {\n\t\tmutex_unlock(&c->io_mutex);\n\t\tdestroy_channel(c);\n\t}\n\treturn 0;\n}\n\n \nstatic ssize_t comp_write(struct file *filp, const char __user *buf,\n\t\t\t  size_t count, loff_t *offset)\n{\n\tint ret;\n\tsize_t to_copy, left;\n\tstruct mbo *mbo = NULL;\n\tstruct comp_channel *c = filp->private_data;\n\n\tmutex_lock(&c->io_mutex);\n\twhile (c->dev && !ch_get_mbo(c, &mbo)) {\n\t\tmutex_unlock(&c->io_mutex);\n\n\t\tif ((filp->f_flags & O_NONBLOCK))\n\t\t\treturn -EAGAIN;\n\t\tif (wait_event_interruptible(c->wq, ch_has_mbo(c) || !c->dev))\n\t\t\treturn -ERESTARTSYS;\n\t\tmutex_lock(&c->io_mutex);\n\t}\n\n\tif (unlikely(!c->dev)) {\n\t\tret = -ENODEV;\n\t\tgoto unlock;\n\t}\n\n\tto_copy = min(count, c->cfg->buffer_size - c->mbo_offs);\n\tleft = copy_from_user(mbo->virt_address + c->mbo_offs, buf, to_copy);\n\tif (left == to_copy) {\n\t\tret = -EFAULT;\n\t\tgoto unlock;\n\t}\n\n\tc->mbo_offs += to_copy - left;\n\tif (c->mbo_offs >= c->cfg->buffer_size ||\n\t    c->cfg->data_type == MOST_CH_CONTROL ||\n\t    c->cfg->data_type == MOST_CH_ASYNC) {\n\t\tkfifo_skip(&c->fifo);\n\t\tmbo->buffer_length = c->mbo_offs;\n\t\tc->mbo_offs = 0;\n\t\tmost_submit_mbo(mbo);\n\t}\n\n\tret = to_copy - left;\nunlock:\n\tmutex_unlock(&c->io_mutex);\n\treturn ret;\n}\n\n \nstatic ssize_t\ncomp_read(struct file *filp, char __user *buf, size_t count, loff_t *offset)\n{\n\tsize_t to_copy, not_copied, copied;\n\tstruct mbo *mbo = NULL;\n\tstruct comp_channel *c = filp->private_data;\n\n\tmutex_lock(&c->io_mutex);\n\twhile (c->dev && !kfifo_peek(&c->fifo, &mbo)) {\n\t\tmutex_unlock(&c->io_mutex);\n\t\tif (filp->f_flags & O_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\t\tif (wait_event_interruptible(c->wq,\n\t\t\t\t\t     (!kfifo_is_empty(&c->fifo) ||\n\t\t\t\t\t      (!c->dev))))\n\t\t\treturn -ERESTARTSYS;\n\t\tmutex_lock(&c->io_mutex);\n\t}\n\n\t \n\tif (unlikely(!c->dev)) {\n\t\tmutex_unlock(&c->io_mutex);\n\t\treturn -ENODEV;\n\t}\n\n\tto_copy = min_t(size_t,\n\t\t\tcount,\n\t\t\tmbo->processed_length - c->mbo_offs);\n\n\tnot_copied = copy_to_user(buf,\n\t\t\t\t  mbo->virt_address + c->mbo_offs,\n\t\t\t\t  to_copy);\n\n\tcopied = to_copy - not_copied;\n\n\tc->mbo_offs += copied;\n\tif (c->mbo_offs >= mbo->processed_length) {\n\t\tkfifo_skip(&c->fifo);\n\t\tmost_put_mbo(mbo);\n\t\tc->mbo_offs = 0;\n\t}\n\tmutex_unlock(&c->io_mutex);\n\treturn copied;\n}\n\nstatic __poll_t comp_poll(struct file *filp, poll_table *wait)\n{\n\tstruct comp_channel *c = filp->private_data;\n\t__poll_t mask = 0;\n\n\tpoll_wait(filp, &c->wq, wait);\n\n\tmutex_lock(&c->io_mutex);\n\tif (c->cfg->direction == MOST_CH_RX) {\n\t\tif (!c->dev || !kfifo_is_empty(&c->fifo))\n\t\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\t} else {\n\t\tif (!c->dev || !kfifo_is_empty(&c->fifo) || ch_has_mbo(c))\n\t\t\tmask |= EPOLLOUT | EPOLLWRNORM;\n\t}\n\tmutex_unlock(&c->io_mutex);\n\treturn mask;\n}\n\n \nstatic const struct file_operations channel_fops = {\n\t.owner = THIS_MODULE,\n\t.read = comp_read,\n\t.write = comp_write,\n\t.open = comp_open,\n\t.release = comp_close,\n\t.poll = comp_poll,\n};\n\n \nstatic int comp_disconnect_channel(struct most_interface *iface, int channel_id)\n{\n\tstruct comp_channel *c;\n\n\tc = get_channel(iface, channel_id);\n\tif (!c)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&c->io_mutex);\n\tspin_lock(&c->unlink);\n\tc->dev = NULL;\n\tspin_unlock(&c->unlink);\n\tdestroy_cdev(c);\n\tif (c->access_ref) {\n\t\tstop_channel(c);\n\t\twake_up_interruptible(&c->wq);\n\t\tmutex_unlock(&c->io_mutex);\n\t} else {\n\t\tmutex_unlock(&c->io_mutex);\n\t\tdestroy_channel(c);\n\t}\n\treturn 0;\n}\n\n \nstatic int comp_rx_completion(struct mbo *mbo)\n{\n\tstruct comp_channel *c;\n\n\tif (!mbo)\n\t\treturn -EINVAL;\n\n\tc = get_channel(mbo->ifp, mbo->hdm_channel_id);\n\tif (!c)\n\t\treturn -EINVAL;\n\n\tspin_lock(&c->unlink);\n\tif (!c->access_ref || !c->dev) {\n\t\tspin_unlock(&c->unlink);\n\t\treturn -ENODEV;\n\t}\n\tkfifo_in(&c->fifo, &mbo, 1);\n\tspin_unlock(&c->unlink);\n#ifdef DEBUG_MESG\n\tif (kfifo_is_full(&c->fifo))\n\t\tdev_warn(c->dev, \"Fifo is full\\n\");\n#endif\n\twake_up_interruptible(&c->wq);\n\treturn 0;\n}\n\n \nstatic int comp_tx_completion(struct most_interface *iface, int channel_id)\n{\n\tstruct comp_channel *c;\n\n\tc = get_channel(iface, channel_id);\n\tif (!c)\n\t\treturn -EINVAL;\n\n\tif ((channel_id < 0) || (channel_id >= iface->num_channels)) {\n\t\tdev_warn(c->dev, \"Channel ID out of range\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\twake_up_interruptible(&c->wq);\n\treturn 0;\n}\n\n \nstatic int comp_probe(struct most_interface *iface, int channel_id,\n\t\t      struct most_channel_config *cfg, char *name, char *args)\n{\n\tstruct comp_channel *c;\n\tunsigned long cl_flags;\n\tint retval;\n\tint current_minor;\n\n\tif (!cfg || !name)\n\t\treturn -EINVAL;\n\n\tc = get_channel(iface, channel_id);\n\tif (c)\n\t\treturn -EEXIST;\n\n\tcurrent_minor = ida_simple_get(&comp.minor_id, 0, 0, GFP_KERNEL);\n\tif (current_minor < 0)\n\t\treturn current_minor;\n\n\tc = kzalloc(sizeof(*c), GFP_KERNEL);\n\tif (!c) {\n\t\tretval = -ENOMEM;\n\t\tgoto err_remove_ida;\n\t}\n\n\tc->devno = MKDEV(comp.major, current_minor);\n\tcdev_init(&c->cdev, &channel_fops);\n\tc->cdev.owner = THIS_MODULE;\n\tretval = cdev_add(&c->cdev, c->devno, 1);\n\tif (retval < 0)\n\t\tgoto err_free_c;\n\tc->iface = iface;\n\tc->cfg = cfg;\n\tc->channel_id = channel_id;\n\tc->access_ref = 0;\n\tspin_lock_init(&c->unlink);\n\tINIT_KFIFO(c->fifo);\n\tretval = kfifo_alloc(&c->fifo, cfg->num_buffers, GFP_KERNEL);\n\tif (retval)\n\t\tgoto err_del_cdev_and_free_channel;\n\tinit_waitqueue_head(&c->wq);\n\tmutex_init(&c->io_mutex);\n\tspin_lock_irqsave(&ch_list_lock, cl_flags);\n\tlist_add_tail(&c->list, &channel_list);\n\tspin_unlock_irqrestore(&ch_list_lock, cl_flags);\n\tc->dev = device_create(comp.class, NULL, c->devno, NULL, \"%s\", name);\n\n\tif (IS_ERR(c->dev)) {\n\t\tretval = PTR_ERR(c->dev);\n\t\tgoto err_free_kfifo_and_del_list;\n\t}\n\tkobject_uevent(&c->dev->kobj, KOBJ_ADD);\n\treturn 0;\n\nerr_free_kfifo_and_del_list:\n\tkfifo_free(&c->fifo);\n\tlist_del(&c->list);\nerr_del_cdev_and_free_channel:\n\tcdev_del(&c->cdev);\nerr_free_c:\n\tkfree(c);\nerr_remove_ida:\n\tida_simple_remove(&comp.minor_id, current_minor);\n\treturn retval;\n}\n\nstatic struct cdev_component comp = {\n\t.cc = {\n\t\t.mod = THIS_MODULE,\n\t\t.name = \"cdev\",\n\t\t.probe_channel = comp_probe,\n\t\t.disconnect_channel = comp_disconnect_channel,\n\t\t.rx_completion = comp_rx_completion,\n\t\t.tx_completion = comp_tx_completion,\n\t},\n};\n\nstatic int __init most_cdev_init(void)\n{\n\tint err;\n\n\tcomp.class = class_create(\"most_cdev\");\n\tif (IS_ERR(comp.class))\n\t\treturn PTR_ERR(comp.class);\n\n\tida_init(&comp.minor_id);\n\n\terr = alloc_chrdev_region(&comp.devno, 0, CHRDEV_REGION_SIZE, \"cdev\");\n\tif (err < 0)\n\t\tgoto dest_ida;\n\tcomp.major = MAJOR(comp.devno);\n\terr = most_register_component(&comp.cc);\n\tif (err)\n\t\tgoto free_cdev;\n\terr = most_register_configfs_subsys(&comp.cc);\n\tif (err)\n\t\tgoto deregister_comp;\n\treturn 0;\n\nderegister_comp:\n\tmost_deregister_component(&comp.cc);\nfree_cdev:\n\tunregister_chrdev_region(comp.devno, CHRDEV_REGION_SIZE);\ndest_ida:\n\tida_destroy(&comp.minor_id);\n\tclass_destroy(comp.class);\n\treturn err;\n}\n\nstatic void __exit most_cdev_exit(void)\n{\n\tstruct comp_channel *c, *tmp;\n\n\tmost_deregister_configfs_subsys(&comp.cc);\n\tmost_deregister_component(&comp.cc);\n\n\tlist_for_each_entry_safe(c, tmp, &channel_list, list) {\n\t\tdestroy_cdev(c);\n\t\tdestroy_channel(c);\n\t}\n\tunregister_chrdev_region(comp.devno, CHRDEV_REGION_SIZE);\n\tida_destroy(&comp.minor_id);\n\tclass_destroy(comp.class);\n}\n\nmodule_init(most_cdev_init);\nmodule_exit(most_cdev_exit);\nMODULE_AUTHOR(\"Christian Gromm <christian.gromm@microchip.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"character device component for mostcore\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}