{
  "module_name": "configfs.c",
  "hash_id": "c8ba0b931a4695bbdefa58b8b321feabf850b12689ac65bb27b6996fa29a2257",
  "original_prompt": "Ingested from linux-6.6.14/drivers/most/configfs.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/configfs.h>\n#include <linux/most.h>\n\n#define MAX_STRING_SIZE 80\n\nstruct mdev_link {\n\tstruct config_item item;\n\tstruct list_head list;\n\tbool create_link;\n\tbool destroy_link;\n\tu16 num_buffers;\n\tu16 buffer_size;\n\tu16 subbuffer_size;\n\tu16 packets_per_xact;\n\tu16 dbr_size;\n\tchar datatype[MAX_STRING_SIZE];\n\tchar direction[MAX_STRING_SIZE];\n\tchar name[MAX_STRING_SIZE];\n\tchar device[MAX_STRING_SIZE];\n\tchar channel[MAX_STRING_SIZE];\n\tchar comp[MAX_STRING_SIZE];\n\tchar comp_params[MAX_STRING_SIZE];\n};\n\nstatic struct list_head mdev_link_list;\n\nstatic int set_cfg_buffer_size(struct mdev_link *link)\n{\n\treturn most_set_cfg_buffer_size(link->device, link->channel,\n\t\t\t\t\tlink->buffer_size);\n}\n\nstatic int set_cfg_subbuffer_size(struct mdev_link *link)\n{\n\treturn most_set_cfg_subbuffer_size(link->device, link->channel,\n\t\t\t\t\t   link->subbuffer_size);\n}\n\nstatic int set_cfg_dbr_size(struct mdev_link *link)\n{\n\treturn most_set_cfg_dbr_size(link->device, link->channel,\n\t\t\t\t     link->dbr_size);\n}\n\nstatic int set_cfg_num_buffers(struct mdev_link *link)\n{\n\treturn most_set_cfg_num_buffers(link->device, link->channel,\n\t\t\t\t\tlink->num_buffers);\n}\n\nstatic int set_cfg_packets_xact(struct mdev_link *link)\n{\n\treturn most_set_cfg_packets_xact(link->device, link->channel,\n\t\t\t\t\t link->packets_per_xact);\n}\n\nstatic int set_cfg_direction(struct mdev_link *link)\n{\n\treturn most_set_cfg_direction(link->device, link->channel,\n\t\t\t\t      link->direction);\n}\n\nstatic int set_cfg_datatype(struct mdev_link *link)\n{\n\treturn most_set_cfg_datatype(link->device, link->channel,\n\t\t\t\t     link->datatype);\n}\n\nstatic int (*set_config_val[])(struct mdev_link *link) = {\n\tset_cfg_buffer_size,\n\tset_cfg_subbuffer_size,\n\tset_cfg_dbr_size,\n\tset_cfg_num_buffers,\n\tset_cfg_packets_xact,\n\tset_cfg_direction,\n\tset_cfg_datatype,\n};\n\nstatic struct mdev_link *to_mdev_link(struct config_item *item)\n{\n\treturn container_of(item, struct mdev_link, item);\n}\n\nstatic int set_config_and_add_link(struct mdev_link *mdev_link)\n{\n\tint i;\n\tint ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(set_config_val); i++) {\n\t\tret = set_config_val[i](mdev_link);\n\t\tif (ret < 0 && ret != -ENODEV) {\n\t\t\tpr_err(\"Config failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn most_add_link(mdev_link->device, mdev_link->channel,\n\t\t\t     mdev_link->comp, mdev_link->name,\n\t\t\t     mdev_link->comp_params);\n}\n\nstatic ssize_t mdev_link_create_link_store(struct config_item *item,\n\t\t\t\t\t   const char *page, size_t count)\n{\n\tstruct mdev_link *mdev_link = to_mdev_link(item);\n\tbool tmp;\n\tint ret;\n\n\tret = kstrtobool(page, &tmp);\n\tif (ret)\n\t\treturn ret;\n\tif (!tmp)\n\t\treturn count;\n\tret = set_config_and_add_link(mdev_link);\n\tif (ret && ret != -ENODEV)\n\t\treturn ret;\n\tlist_add_tail(&mdev_link->list, &mdev_link_list);\n\tmdev_link->create_link = tmp;\n\tmdev_link->destroy_link = false;\n\n\treturn count;\n}\n\nstatic ssize_t mdev_link_destroy_link_store(struct config_item *item,\n\t\t\t\t\t    const char *page, size_t count)\n{\n\tstruct mdev_link *mdev_link = to_mdev_link(item);\n\tbool tmp;\n\tint ret;\n\n\tret = kstrtobool(page, &tmp);\n\tif (ret)\n\t\treturn ret;\n\tif (!tmp)\n\t\treturn count;\n\n\tret = most_remove_link(mdev_link->device, mdev_link->channel,\n\t\t\t       mdev_link->comp);\n\tif (ret)\n\t\treturn ret;\n\tif (!list_empty(&mdev_link_list))\n\t\tlist_del(&mdev_link->list);\n\n\tmdev_link->destroy_link = tmp;\n\n\treturn count;\n}\n\nstatic ssize_t mdev_link_direction_show(struct config_item *item, char *page)\n{\n\treturn snprintf(page, PAGE_SIZE, \"%s\\n\", to_mdev_link(item)->direction);\n}\n\nstatic ssize_t mdev_link_direction_store(struct config_item *item,\n\t\t\t\t\t const char *page, size_t count)\n{\n\tstruct mdev_link *mdev_link = to_mdev_link(item);\n\n\tif (!sysfs_streq(page, \"dir_rx\") && !sysfs_streq(page, \"rx\") &&\n\t    !sysfs_streq(page, \"dir_tx\") && !sysfs_streq(page, \"tx\"))\n\t\treturn -EINVAL;\n\tstrcpy(mdev_link->direction, page);\n\tstrim(mdev_link->direction);\n\treturn count;\n}\n\nstatic ssize_t mdev_link_datatype_show(struct config_item *item, char *page)\n{\n\treturn snprintf(page, PAGE_SIZE, \"%s\\n\", to_mdev_link(item)->datatype);\n}\n\nstatic ssize_t mdev_link_datatype_store(struct config_item *item,\n\t\t\t\t\tconst char *page, size_t count)\n{\n\tstruct mdev_link *mdev_link = to_mdev_link(item);\n\n\tif (!sysfs_streq(page, \"control\") && !sysfs_streq(page, \"async\") &&\n\t    !sysfs_streq(page, \"sync\") && !sysfs_streq(page, \"isoc\") &&\n\t    !sysfs_streq(page, \"isoc_avp\"))\n\t\treturn -EINVAL;\n\tstrcpy(mdev_link->datatype, page);\n\tstrim(mdev_link->datatype);\n\treturn count;\n}\n\nstatic ssize_t mdev_link_device_show(struct config_item *item, char *page)\n{\n\treturn snprintf(page, PAGE_SIZE, \"%s\\n\", to_mdev_link(item)->device);\n}\n\nstatic ssize_t mdev_link_device_store(struct config_item *item,\n\t\t\t\t      const char *page, size_t count)\n{\n\tstruct mdev_link *mdev_link = to_mdev_link(item);\n\n\tstrscpy(mdev_link->device, page, sizeof(mdev_link->device));\n\tstrim(mdev_link->device);\n\treturn count;\n}\n\nstatic ssize_t mdev_link_channel_show(struct config_item *item, char *page)\n{\n\treturn snprintf(page, PAGE_SIZE, \"%s\\n\", to_mdev_link(item)->channel);\n}\n\nstatic ssize_t mdev_link_channel_store(struct config_item *item,\n\t\t\t\t       const char *page, size_t count)\n{\n\tstruct mdev_link *mdev_link = to_mdev_link(item);\n\n\tstrscpy(mdev_link->channel, page, sizeof(mdev_link->channel));\n\tstrim(mdev_link->channel);\n\treturn count;\n}\n\nstatic ssize_t mdev_link_comp_show(struct config_item *item, char *page)\n{\n\treturn snprintf(page, PAGE_SIZE, \"%s\\n\", to_mdev_link(item)->comp);\n}\n\nstatic ssize_t mdev_link_comp_store(struct config_item *item,\n\t\t\t\t    const char *page, size_t count)\n{\n\tstruct mdev_link *mdev_link = to_mdev_link(item);\n\n\tstrscpy(mdev_link->comp, page, sizeof(mdev_link->comp));\n\tstrim(mdev_link->comp);\n\treturn count;\n}\n\nstatic ssize_t mdev_link_comp_params_show(struct config_item *item, char *page)\n{\n\treturn snprintf(page, PAGE_SIZE, \"%s\\n\",\n\t\t\tto_mdev_link(item)->comp_params);\n}\n\nstatic ssize_t mdev_link_comp_params_store(struct config_item *item,\n\t\t\t\t\t   const char *page, size_t count)\n{\n\tstruct mdev_link *mdev_link = to_mdev_link(item);\n\n\tstrscpy(mdev_link->comp_params, page, sizeof(mdev_link->comp_params));\n\tstrim(mdev_link->comp_params);\n\treturn count;\n}\n\nstatic ssize_t mdev_link_num_buffers_show(struct config_item *item, char *page)\n{\n\treturn snprintf(page, PAGE_SIZE, \"%d\\n\",\n\t\t\tto_mdev_link(item)->num_buffers);\n}\n\nstatic ssize_t mdev_link_num_buffers_store(struct config_item *item,\n\t\t\t\t\t   const char *page, size_t count)\n{\n\tstruct mdev_link *mdev_link = to_mdev_link(item);\n\tint ret;\n\n\tret = kstrtou16(page, 0, &mdev_link->num_buffers);\n\tif (ret)\n\t\treturn ret;\n\treturn count;\n}\n\nstatic ssize_t mdev_link_buffer_size_show(struct config_item *item, char *page)\n{\n\treturn snprintf(page, PAGE_SIZE, \"%d\\n\",\n\t\t\tto_mdev_link(item)->buffer_size);\n}\n\nstatic ssize_t mdev_link_buffer_size_store(struct config_item *item,\n\t\t\t\t\t   const char *page, size_t count)\n{\n\tstruct mdev_link *mdev_link = to_mdev_link(item);\n\tint ret;\n\n\tret = kstrtou16(page, 0, &mdev_link->buffer_size);\n\tif (ret)\n\t\treturn ret;\n\treturn count;\n}\n\nstatic ssize_t mdev_link_subbuffer_size_show(struct config_item *item,\n\t\t\t\t\t     char *page)\n{\n\treturn snprintf(page, PAGE_SIZE, \"%d\\n\",\n\t\t\tto_mdev_link(item)->subbuffer_size);\n}\n\nstatic ssize_t mdev_link_subbuffer_size_store(struct config_item *item,\n\t\t\t\t\t      const char *page, size_t count)\n{\n\tstruct mdev_link *mdev_link = to_mdev_link(item);\n\tint ret;\n\n\tret = kstrtou16(page, 0, &mdev_link->subbuffer_size);\n\tif (ret)\n\t\treturn ret;\n\treturn count;\n}\n\nstatic ssize_t mdev_link_packets_per_xact_show(struct config_item *item,\n\t\t\t\t\t       char *page)\n{\n\treturn snprintf(page, PAGE_SIZE, \"%d\\n\",\n\t\t\tto_mdev_link(item)->packets_per_xact);\n}\n\nstatic ssize_t mdev_link_packets_per_xact_store(struct config_item *item,\n\t\t\t\t\t\tconst char *page, size_t count)\n{\n\tstruct mdev_link *mdev_link = to_mdev_link(item);\n\tint ret;\n\n\tret = kstrtou16(page, 0, &mdev_link->packets_per_xact);\n\tif (ret)\n\t\treturn ret;\n\treturn count;\n}\n\nstatic ssize_t mdev_link_dbr_size_show(struct config_item *item, char *page)\n{\n\treturn snprintf(page, PAGE_SIZE, \"%d\\n\", to_mdev_link(item)->dbr_size);\n}\n\nstatic ssize_t mdev_link_dbr_size_store(struct config_item *item,\n\t\t\t\t\tconst char *page, size_t count)\n{\n\tstruct mdev_link *mdev_link = to_mdev_link(item);\n\tint ret;\n\n\tret = kstrtou16(page, 0, &mdev_link->dbr_size);\n\tif (ret)\n\t\treturn ret;\n\treturn count;\n}\n\nCONFIGFS_ATTR_WO(mdev_link_, create_link);\nCONFIGFS_ATTR_WO(mdev_link_, destroy_link);\nCONFIGFS_ATTR(mdev_link_, device);\nCONFIGFS_ATTR(mdev_link_, channel);\nCONFIGFS_ATTR(mdev_link_, comp);\nCONFIGFS_ATTR(mdev_link_, comp_params);\nCONFIGFS_ATTR(mdev_link_, num_buffers);\nCONFIGFS_ATTR(mdev_link_, buffer_size);\nCONFIGFS_ATTR(mdev_link_, subbuffer_size);\nCONFIGFS_ATTR(mdev_link_, packets_per_xact);\nCONFIGFS_ATTR(mdev_link_, datatype);\nCONFIGFS_ATTR(mdev_link_, direction);\nCONFIGFS_ATTR(mdev_link_, dbr_size);\n\nstatic struct configfs_attribute *mdev_link_attrs[] = {\n\t&mdev_link_attr_create_link,\n\t&mdev_link_attr_destroy_link,\n\t&mdev_link_attr_device,\n\t&mdev_link_attr_channel,\n\t&mdev_link_attr_comp,\n\t&mdev_link_attr_comp_params,\n\t&mdev_link_attr_num_buffers,\n\t&mdev_link_attr_buffer_size,\n\t&mdev_link_attr_subbuffer_size,\n\t&mdev_link_attr_packets_per_xact,\n\t&mdev_link_attr_datatype,\n\t&mdev_link_attr_direction,\n\t&mdev_link_attr_dbr_size,\n\tNULL,\n};\n\nstatic void mdev_link_release(struct config_item *item)\n{\n\tstruct mdev_link *mdev_link = to_mdev_link(item);\n\tint ret;\n\n\tif (mdev_link->destroy_link)\n\t\tgoto free_item;\n\n\tret = most_remove_link(mdev_link->device, mdev_link->channel,\n\t\t\t       mdev_link->comp);\n\tif (ret) {\n\t\tpr_err(\"Removing link failed.\\n\");\n\t\tgoto free_item;\n\t}\n\n\tif (!list_empty(&mdev_link_list))\n\t\tlist_del(&mdev_link->list);\n\nfree_item:\n\tkfree(to_mdev_link(item));\n}\n\nstatic struct configfs_item_operations mdev_link_item_ops = {\n\t.release\t\t= mdev_link_release,\n};\n\nstatic const struct config_item_type mdev_link_type = {\n\t.ct_item_ops\t= &mdev_link_item_ops,\n\t.ct_attrs\t= mdev_link_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstruct most_common {\n\tstruct config_group group;\n\tstruct module *mod;\n\tstruct configfs_subsystem subsys;\n};\n\nstatic struct most_common *to_most_common(struct configfs_subsystem *subsys)\n{\n\treturn container_of(subsys, struct most_common, subsys);\n}\n\nstatic struct config_item *most_common_make_item(struct config_group *group,\n\t\t\t\t\t\t const char *name)\n{\n\tstruct mdev_link *mdev_link;\n\tstruct most_common *mc = to_most_common(group->cg_subsys);\n\n\tmdev_link = kzalloc(sizeof(*mdev_link), GFP_KERNEL);\n\tif (!mdev_link)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!try_module_get(mc->mod)) {\n\t\tkfree(mdev_link);\n\t\treturn ERR_PTR(-ENOLCK);\n\t}\n\tconfig_item_init_type_name(&mdev_link->item, name,\n\t\t\t\t   &mdev_link_type);\n\n\tif (!strcmp(group->cg_item.ci_namebuf, \"most_cdev\"))\n\t\tstrcpy(mdev_link->comp, \"cdev\");\n\telse if (!strcmp(group->cg_item.ci_namebuf, \"most_net\"))\n\t\tstrcpy(mdev_link->comp, \"net\");\n\telse if (!strcmp(group->cg_item.ci_namebuf, \"most_video\"))\n\t\tstrcpy(mdev_link->comp, \"video\");\n\tstrcpy(mdev_link->name, name);\n\treturn &mdev_link->item;\n}\n\nstatic void most_common_release(struct config_item *item)\n{\n\tstruct config_group *group = to_config_group(item);\n\n\tkfree(to_most_common(group->cg_subsys));\n}\n\nstatic struct configfs_item_operations most_common_item_ops = {\n\t.release\t= most_common_release,\n};\n\nstatic void most_common_disconnect(struct config_group *group,\n\t\t\t\t   struct config_item *item)\n{\n\tstruct most_common *mc = to_most_common(group->cg_subsys);\n\n\tmodule_put(mc->mod);\n}\n\nstatic struct configfs_group_operations most_common_group_ops = {\n\t.make_item\t= most_common_make_item,\n\t.disconnect_notify = most_common_disconnect,\n};\n\nstatic const struct config_item_type most_common_type = {\n\t.ct_item_ops\t= &most_common_item_ops,\n\t.ct_group_ops\t= &most_common_group_ops,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstatic struct most_common most_cdev = {\n\t.subsys = {\n\t\t.su_group = {\n\t\t\t.cg_item = {\n\t\t\t\t.ci_namebuf = \"most_cdev\",\n\t\t\t\t.ci_type = &most_common_type,\n\t\t\t},\n\t\t},\n\t},\n};\n\nstatic struct most_common most_net = {\n\t.subsys = {\n\t\t.su_group = {\n\t\t\t.cg_item = {\n\t\t\t\t.ci_namebuf = \"most_net\",\n\t\t\t\t.ci_type = &most_common_type,\n\t\t\t},\n\t\t},\n\t},\n};\n\nstatic struct most_common most_video = {\n\t.subsys = {\n\t\t.su_group = {\n\t\t\t.cg_item = {\n\t\t\t\t.ci_namebuf = \"most_video\",\n\t\t\t\t.ci_type = &most_common_type,\n\t\t\t},\n\t\t},\n\t},\n};\n\nstruct most_snd_grp {\n\tstruct config_group group;\n\tbool create_card;\n\tstruct list_head list;\n};\n\nstatic struct most_snd_grp *to_most_snd_grp(struct config_item *item)\n{\n\treturn container_of(to_config_group(item), struct most_snd_grp, group);\n}\n\nstatic struct config_item *most_snd_grp_make_item(struct config_group *group,\n\t\t\t\t\t\t  const char *name)\n{\n\tstruct mdev_link *mdev_link;\n\n\tmdev_link = kzalloc(sizeof(*mdev_link), GFP_KERNEL);\n\tif (!mdev_link)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tconfig_item_init_type_name(&mdev_link->item, name, &mdev_link_type);\n\tmdev_link->create_link = false;\n\tstrcpy(mdev_link->name, name);\n\tstrcpy(mdev_link->comp, \"sound\");\n\treturn &mdev_link->item;\n}\n\nstatic ssize_t most_snd_grp_create_card_store(struct config_item *item,\n\t\t\t\t\t      const char *page, size_t count)\n{\n\tstruct most_snd_grp *snd_grp = to_most_snd_grp(item);\n\tint ret;\n\tbool tmp;\n\n\tret = kstrtobool(page, &tmp);\n\tif (ret)\n\t\treturn ret;\n\tif (tmp) {\n\t\tret = most_cfg_complete(\"sound\");\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tsnd_grp->create_card = tmp;\n\treturn count;\n}\n\nCONFIGFS_ATTR_WO(most_snd_grp_, create_card);\n\nstatic struct configfs_attribute *most_snd_grp_attrs[] = {\n\t&most_snd_grp_attr_create_card,\n\tNULL,\n};\n\nstatic void most_snd_grp_release(struct config_item *item)\n{\n\tstruct most_snd_grp *group = to_most_snd_grp(item);\n\n\tlist_del(&group->list);\n\tkfree(group);\n}\n\nstatic struct configfs_item_operations most_snd_grp_item_ops = {\n\t.release\t= most_snd_grp_release,\n};\n\nstatic struct configfs_group_operations most_snd_grp_group_ops = {\n\t.make_item\t= most_snd_grp_make_item,\n};\n\nstatic const struct config_item_type most_snd_grp_type = {\n\t.ct_item_ops\t= &most_snd_grp_item_ops,\n\t.ct_group_ops\t= &most_snd_grp_group_ops,\n\t.ct_attrs\t= most_snd_grp_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstruct most_sound {\n\tstruct configfs_subsystem subsys;\n\tstruct list_head soundcard_list;\n\tstruct module *mod;\n};\n\nstatic struct config_group *most_sound_make_group(struct config_group *group,\n\t\t\t\t\t\t  const char *name)\n{\n\tstruct most_snd_grp *most;\n\tstruct most_sound *ms = container_of(group->cg_subsys,\n\t\t\t\t\t     struct most_sound, subsys);\n\n\tlist_for_each_entry(most, &ms->soundcard_list, list) {\n\t\tif (!most->create_card) {\n\t\t\tpr_info(\"adapter configuration still in progress.\\n\");\n\t\t\treturn ERR_PTR(-EPROTO);\n\t\t}\n\t}\n\tif (!try_module_get(ms->mod))\n\t\treturn ERR_PTR(-ENOLCK);\n\tmost = kzalloc(sizeof(*most), GFP_KERNEL);\n\tif (!most) {\n\t\tmodule_put(ms->mod);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tconfig_group_init_type_name(&most->group, name, &most_snd_grp_type);\n\tlist_add_tail(&most->list, &ms->soundcard_list);\n\treturn &most->group;\n}\n\nstatic void most_sound_disconnect(struct config_group *group,\n\t\t\t\t  struct config_item *item)\n{\n\tstruct most_sound *ms = container_of(group->cg_subsys,\n\t\t\t\t\t     struct most_sound, subsys);\n\tmodule_put(ms->mod);\n}\n\nstatic struct configfs_group_operations most_sound_group_ops = {\n\t.make_group\t= most_sound_make_group,\n\t.disconnect_notify = most_sound_disconnect,\n};\n\nstatic const struct config_item_type most_sound_type = {\n\t.ct_group_ops\t= &most_sound_group_ops,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstatic struct most_sound most_sound_subsys = {\n\t.subsys = {\n\t\t.su_group = {\n\t\t\t.cg_item = {\n\t\t\t\t.ci_namebuf = \"most_sound\",\n\t\t\t\t.ci_type = &most_sound_type,\n\t\t\t},\n\t\t},\n\t},\n};\n\nint most_register_configfs_subsys(struct most_component *c)\n{\n\tint ret;\n\n\tif (!strcmp(c->name, \"cdev\")) {\n\t\tmost_cdev.mod = c->mod;\n\t\tret = configfs_register_subsystem(&most_cdev.subsys);\n\t} else if (!strcmp(c->name, \"net\")) {\n\t\tmost_net.mod = c->mod;\n\t\tret = configfs_register_subsystem(&most_net.subsys);\n\t} else if (!strcmp(c->name, \"video\")) {\n\t\tmost_video.mod = c->mod;\n\t\tret = configfs_register_subsystem(&most_video.subsys);\n\t} else if (!strcmp(c->name, \"sound\")) {\n\t\tmost_sound_subsys.mod = c->mod;\n\t\tret = configfs_register_subsystem(&most_sound_subsys.subsys);\n\t} else {\n\t\treturn -ENODEV;\n\t}\n\n\tif (ret) {\n\t\tpr_err(\"Error %d while registering subsystem %s\\n\",\n\t\t       ret, c->name);\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(most_register_configfs_subsys);\n\nvoid most_interface_register_notify(const char *mdev)\n{\n\tbool register_snd_card = false;\n\tstruct mdev_link *mdev_link;\n\n\tlist_for_each_entry(mdev_link, &mdev_link_list, list) {\n\t\tif (!strcmp(mdev_link->device, mdev)) {\n\t\t\tset_config_and_add_link(mdev_link);\n\t\t\tif (!strcmp(mdev_link->comp, \"sound\"))\n\t\t\t\tregister_snd_card = true;\n\t\t}\n\t}\n\tif (register_snd_card)\n\t\tmost_cfg_complete(\"sound\");\n}\n\nvoid most_deregister_configfs_subsys(struct most_component *c)\n{\n\tif (!strcmp(c->name, \"cdev\"))\n\t\tconfigfs_unregister_subsystem(&most_cdev.subsys);\n\telse if (!strcmp(c->name, \"net\"))\n\t\tconfigfs_unregister_subsystem(&most_net.subsys);\n\telse if (!strcmp(c->name, \"video\"))\n\t\tconfigfs_unregister_subsystem(&most_video.subsys);\n\telse if (!strcmp(c->name, \"sound\"))\n\t\tconfigfs_unregister_subsystem(&most_sound_subsys.subsys);\n}\nEXPORT_SYMBOL_GPL(most_deregister_configfs_subsys);\n\nint __init configfs_init(void)\n{\n\tconfig_group_init(&most_cdev.subsys.su_group);\n\tmutex_init(&most_cdev.subsys.su_mutex);\n\n\tconfig_group_init(&most_net.subsys.su_group);\n\tmutex_init(&most_net.subsys.su_mutex);\n\n\tconfig_group_init(&most_video.subsys.su_group);\n\tmutex_init(&most_video.subsys.su_mutex);\n\n\tconfig_group_init(&most_sound_subsys.subsys.su_group);\n\tmutex_init(&most_sound_subsys.subsys.su_mutex);\n\n\tINIT_LIST_HEAD(&most_sound_subsys.soundcard_list);\n\tINIT_LIST_HEAD(&mdev_link_list);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}