{
  "module_name": "kcomedilib_main.c",
  "hash_id": "15c32bc9c303e814545890273b8f407e4cb2f1804426971ec360467ffd7b0c67",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/kcomedilib/kcomedilib_main.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/io.h>\n\n#include <linux/comedi.h>\n#include <linux/comedi/comedidev.h>\n#include <linux/comedi/comedilib.h>\n\nMODULE_AUTHOR(\"David Schleef <ds@schleef.org>\");\nMODULE_DESCRIPTION(\"Comedi kernel library\");\nMODULE_LICENSE(\"GPL\");\n\nstruct comedi_device *comedi_open(const char *filename)\n{\n\tstruct comedi_device *dev, *retval = NULL;\n\tunsigned int minor;\n\n\tif (strncmp(filename, \"/dev/comedi\", 11) != 0)\n\t\treturn NULL;\n\n\tif (kstrtouint(filename + 11, 0, &minor))\n\t\treturn NULL;\n\n\tif (minor >= COMEDI_NUM_BOARD_MINORS)\n\t\treturn NULL;\n\n\tdev = comedi_dev_get_from_minor(minor);\n\tif (!dev)\n\t\treturn NULL;\n\n\tdown_read(&dev->attach_lock);\n\tif (dev->attached)\n\t\tretval = dev;\n\telse\n\t\tretval = NULL;\n\tup_read(&dev->attach_lock);\n\n\tif (!retval)\n\t\tcomedi_dev_put(dev);\n\n\treturn retval;\n}\nEXPORT_SYMBOL_GPL(comedi_open);\n\nint comedi_close(struct comedi_device *dev)\n{\n\tcomedi_dev_put(dev);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(comedi_close);\n\nstatic int comedi_do_insn(struct comedi_device *dev,\n\t\t\t  struct comedi_insn *insn,\n\t\t\t  unsigned int *data)\n{\n\tstruct comedi_subdevice *s;\n\tint ret;\n\n\tmutex_lock(&dev->mutex);\n\n\tif (!dev->attached) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\t \n\tif (insn->subdev >= dev->n_subdevices) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\ts = &dev->subdevices[insn->subdev];\n\n\tif (s->type == COMEDI_SUBD_UNUSED) {\n\t\tdev_err(dev->class_dev,\n\t\t\t\"%d not usable subdevice\\n\", insn->subdev);\n\t\tret = -EIO;\n\t\tgoto error;\n\t}\n\n\t \n\n\tret = comedi_check_chanlist(s, 1, &insn->chanspec);\n\tif (ret < 0) {\n\t\tdev_err(dev->class_dev, \"bad chanspec\\n\");\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tif (s->busy) {\n\t\tret = -EBUSY;\n\t\tgoto error;\n\t}\n\ts->busy = dev;\n\n\tswitch (insn->insn) {\n\tcase INSN_BITS:\n\t\tret = s->insn_bits(dev, s, insn, data);\n\t\tbreak;\n\tcase INSN_CONFIG:\n\t\t \n\t\tret = s->insn_config(dev, s, insn, data);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\ts->busy = NULL;\nerror:\n\n\tmutex_unlock(&dev->mutex);\n\treturn ret;\n}\n\nint comedi_dio_get_config(struct comedi_device *dev, unsigned int subdev,\n\t\t\t  unsigned int chan, unsigned int *io)\n{\n\tstruct comedi_insn insn;\n\tunsigned int data[2];\n\tint ret;\n\n\tmemset(&insn, 0, sizeof(insn));\n\tinsn.insn = INSN_CONFIG;\n\tinsn.n = 2;\n\tinsn.subdev = subdev;\n\tinsn.chanspec = CR_PACK(chan, 0, 0);\n\tdata[0] = INSN_CONFIG_DIO_QUERY;\n\tdata[1] = 0;\n\tret = comedi_do_insn(dev, &insn, data);\n\tif (ret >= 0)\n\t\t*io = data[1];\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(comedi_dio_get_config);\n\nint comedi_dio_config(struct comedi_device *dev, unsigned int subdev,\n\t\t      unsigned int chan, unsigned int io)\n{\n\tstruct comedi_insn insn;\n\n\tmemset(&insn, 0, sizeof(insn));\n\tinsn.insn = INSN_CONFIG;\n\tinsn.n = 1;\n\tinsn.subdev = subdev;\n\tinsn.chanspec = CR_PACK(chan, 0, 0);\n\n\treturn comedi_do_insn(dev, &insn, &io);\n}\nEXPORT_SYMBOL_GPL(comedi_dio_config);\n\nint comedi_dio_bitfield2(struct comedi_device *dev, unsigned int subdev,\n\t\t\t unsigned int mask, unsigned int *bits,\n\t\t\t unsigned int base_channel)\n{\n\tstruct comedi_insn insn;\n\tunsigned int data[2];\n\tunsigned int n_chan;\n\tunsigned int shift;\n\tint ret;\n\n\tbase_channel = CR_CHAN(base_channel);\n\tn_chan = comedi_get_n_channels(dev, subdev);\n\tif (base_channel >= n_chan)\n\t\treturn -EINVAL;\n\n\tmemset(&insn, 0, sizeof(insn));\n\tinsn.insn = INSN_BITS;\n\tinsn.chanspec = base_channel;\n\tinsn.n = 2;\n\tinsn.subdev = subdev;\n\n\tdata[0] = mask;\n\tdata[1] = *bits;\n\n\t \n\tif (n_chan <= 32) {\n\t\tshift = base_channel;\n\t\tif (shift) {\n\t\t\tinsn.chanspec = 0;\n\t\t\tdata[0] <<= shift;\n\t\t\tdata[1] <<= shift;\n\t\t}\n\t} else {\n\t\tshift = 0;\n\t}\n\n\tret = comedi_do_insn(dev, &insn, data);\n\t*bits = data[1] >> shift;\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(comedi_dio_bitfield2);\n\nint comedi_find_subdevice_by_type(struct comedi_device *dev, int type,\n\t\t\t\t  unsigned int subd)\n{\n\tstruct comedi_subdevice *s;\n\tint ret = -ENODEV;\n\n\tdown_read(&dev->attach_lock);\n\tif (dev->attached)\n\t\tfor (; subd < dev->n_subdevices; subd++) {\n\t\t\ts = &dev->subdevices[subd];\n\t\t\tif (s->type == type) {\n\t\t\t\tret = subd;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\tup_read(&dev->attach_lock);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(comedi_find_subdevice_by_type);\n\nint comedi_get_n_channels(struct comedi_device *dev, unsigned int subdevice)\n{\n\tint n;\n\n\tdown_read(&dev->attach_lock);\n\tif (!dev->attached || subdevice >= dev->n_subdevices)\n\t\tn = 0;\n\telse\n\t\tn = dev->subdevices[subdevice].n_chan;\n\tup_read(&dev->attach_lock);\n\n\treturn n;\n}\nEXPORT_SYMBOL_GPL(comedi_get_n_channels);\n\nstatic int __init kcomedilib_module_init(void)\n{\n\treturn 0;\n}\n\nstatic void __exit kcomedilib_module_exit(void)\n{\n}\n\nmodule_init(kcomedilib_module_init);\nmodule_exit(kcomedilib_module_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}