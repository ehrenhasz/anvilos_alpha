{
  "module_name": "comedi_buf.c",
  "hash_id": "4d10630c2307c7911aa65835f981bf6be75f86736f4d4229e4ff6fb65f2b3051",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/comedi_buf.c",
  "human_readable_source": "\n \n\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/comedi/comedidev.h>\n#include \"comedi_internal.h\"\n\n#ifdef PAGE_KERNEL_NOCACHE\n#define COMEDI_PAGE_PROTECTION\t\tPAGE_KERNEL_NOCACHE\n#else\n#define COMEDI_PAGE_PROTECTION\t\tPAGE_KERNEL\n#endif\n\nstatic void comedi_buf_map_kref_release(struct kref *kref)\n{\n\tstruct comedi_buf_map *bm =\n\t\tcontainer_of(kref, struct comedi_buf_map, refcount);\n\tstruct comedi_buf_page *buf;\n\tunsigned int i;\n\n\tif (bm->page_list) {\n\t\tif (bm->dma_dir != DMA_NONE) {\n\t\t\t \n\t\t\tbuf = &bm->page_list[0];\n\t\t\tdma_free_coherent(bm->dma_hw_dev,\n\t\t\t\t\t  PAGE_SIZE * bm->n_pages,\n\t\t\t\t\t  buf->virt_addr, buf->dma_addr);\n\t\t} else {\n\t\t\tfor (i = 0; i < bm->n_pages; i++) {\n\t\t\t\tbuf = &bm->page_list[i];\n\t\t\t\tClearPageReserved(virt_to_page(buf->virt_addr));\n\t\t\t\tfree_page((unsigned long)buf->virt_addr);\n\t\t\t}\n\t\t}\n\t\tvfree(bm->page_list);\n\t}\n\tif (bm->dma_dir != DMA_NONE)\n\t\tput_device(bm->dma_hw_dev);\n\tkfree(bm);\n}\n\nstatic void __comedi_buf_free(struct comedi_device *dev,\n\t\t\t      struct comedi_subdevice *s)\n{\n\tstruct comedi_async *async = s->async;\n\tstruct comedi_buf_map *bm;\n\tunsigned long flags;\n\n\tif (async->prealloc_buf) {\n\t\tif (s->async_dma_dir == DMA_NONE)\n\t\t\tvunmap(async->prealloc_buf);\n\t\tasync->prealloc_buf = NULL;\n\t\tasync->prealloc_bufsz = 0;\n\t}\n\n\tspin_lock_irqsave(&s->spin_lock, flags);\n\tbm = async->buf_map;\n\tasync->buf_map = NULL;\n\tspin_unlock_irqrestore(&s->spin_lock, flags);\n\tcomedi_buf_map_put(bm);\n}\n\nstatic struct comedi_buf_map *\ncomedi_buf_map_alloc(struct comedi_device *dev, enum dma_data_direction dma_dir,\n\t\t     unsigned int n_pages)\n{\n\tstruct comedi_buf_map *bm;\n\tstruct comedi_buf_page *buf;\n\tunsigned int i;\n\n\tbm = kzalloc(sizeof(*bm), GFP_KERNEL);\n\tif (!bm)\n\t\treturn NULL;\n\n\tkref_init(&bm->refcount);\n\tbm->dma_dir = dma_dir;\n\tif (bm->dma_dir != DMA_NONE) {\n\t\t \n\t\tbm->dma_hw_dev = get_device(dev->hw_dev);\n\t}\n\n\tbm->page_list = vzalloc(sizeof(*buf) * n_pages);\n\tif (!bm->page_list)\n\t\tgoto err;\n\n\tif (bm->dma_dir != DMA_NONE) {\n\t\tvoid *virt_addr;\n\t\tdma_addr_t dma_addr;\n\n\t\t \n\t\tvirt_addr = dma_alloc_coherent(bm->dma_hw_dev,\n\t\t\t\t\t       PAGE_SIZE * n_pages, &dma_addr,\n\t\t\t\t\t       GFP_KERNEL);\n\t\tif (!virt_addr)\n\t\t\tgoto err;\n\n\t\tfor (i = 0; i < n_pages; i++) {\n\t\t\tbuf = &bm->page_list[i];\n\t\t\tbuf->virt_addr = virt_addr + (i << PAGE_SHIFT);\n\t\t\tbuf->dma_addr = dma_addr + (i << PAGE_SHIFT);\n\t\t}\n\n\t\tbm->n_pages = i;\n\t} else {\n\t\tfor (i = 0; i < n_pages; i++) {\n\t\t\tbuf = &bm->page_list[i];\n\t\t\tbuf->virt_addr = (void *)get_zeroed_page(GFP_KERNEL);\n\t\t\tif (!buf->virt_addr)\n\t\t\t\tbreak;\n\n\t\t\tSetPageReserved(virt_to_page(buf->virt_addr));\n\t\t}\n\n\t\tbm->n_pages = i;\n\t\tif (i < n_pages)\n\t\t\tgoto err;\n\t}\n\n\treturn bm;\n\nerr:\n\tcomedi_buf_map_put(bm);\n\treturn NULL;\n}\n\nstatic void __comedi_buf_alloc(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       unsigned int n_pages)\n{\n\tstruct comedi_async *async = s->async;\n\tstruct page **pages = NULL;\n\tstruct comedi_buf_map *bm;\n\tstruct comedi_buf_page *buf;\n\tunsigned long flags;\n\tunsigned int i;\n\n\tif (!IS_ENABLED(CONFIG_HAS_DMA) && s->async_dma_dir != DMA_NONE) {\n\t\tdev_err(dev->class_dev,\n\t\t\t\"dma buffer allocation not supported\\n\");\n\t\treturn;\n\t}\n\n\tbm = comedi_buf_map_alloc(dev, s->async_dma_dir, n_pages);\n\tif (!bm)\n\t\treturn;\n\n\tspin_lock_irqsave(&s->spin_lock, flags);\n\tasync->buf_map = bm;\n\tspin_unlock_irqrestore(&s->spin_lock, flags);\n\n\tif (bm->dma_dir != DMA_NONE) {\n\t\t \n\t\tbuf = &bm->page_list[0];\n\t\tasync->prealloc_buf = buf->virt_addr;\n\t} else {\n\t\tpages = vmalloc(sizeof(struct page *) * n_pages);\n\t\tif (!pages)\n\t\t\treturn;\n\n\t\tfor (i = 0; i < n_pages; i++) {\n\t\t\tbuf = &bm->page_list[i];\n\t\t\tpages[i] = virt_to_page(buf->virt_addr);\n\t\t}\n\n\t\t \n\t\tasync->prealloc_buf = vmap(pages, n_pages, VM_MAP,\n\t\t\t\t\t   COMEDI_PAGE_PROTECTION);\n\n\t\tvfree(pages);\n\t}\n}\n\nvoid comedi_buf_map_get(struct comedi_buf_map *bm)\n{\n\tif (bm)\n\t\tkref_get(&bm->refcount);\n}\n\nint comedi_buf_map_put(struct comedi_buf_map *bm)\n{\n\tif (bm)\n\t\treturn kref_put(&bm->refcount, comedi_buf_map_kref_release);\n\treturn 1;\n}\n\n \nint comedi_buf_map_access(struct comedi_buf_map *bm, unsigned long offset,\n\t\t\t  void *buf, int len, int write)\n{\n\tunsigned int pgoff = offset_in_page(offset);\n\tunsigned long pg = offset >> PAGE_SHIFT;\n\tint done = 0;\n\n\twhile (done < len && pg < bm->n_pages) {\n\t\tint l = min_t(int, len - done, PAGE_SIZE - pgoff);\n\t\tvoid *b = bm->page_list[pg].virt_addr + pgoff;\n\n\t\tif (write)\n\t\t\tmemcpy(b, buf, l);\n\t\telse\n\t\t\tmemcpy(buf, b, l);\n\t\tbuf += l;\n\t\tdone += l;\n\t\tpg++;\n\t\tpgoff = 0;\n\t}\n\treturn done;\n}\n\n \nstruct comedi_buf_map *\ncomedi_buf_map_from_subdev_get(struct comedi_subdevice *s)\n{\n\tstruct comedi_async *async = s->async;\n\tstruct comedi_buf_map *bm = NULL;\n\tunsigned long flags;\n\n\tif (!async)\n\t\treturn NULL;\n\n\tspin_lock_irqsave(&s->spin_lock, flags);\n\tbm = async->buf_map;\n\t \n\tif (bm && bm->n_pages)\n\t\tcomedi_buf_map_get(bm);\n\telse\n\t\tbm = NULL;\n\tspin_unlock_irqrestore(&s->spin_lock, flags);\n\n\treturn bm;\n}\n\nbool comedi_buf_is_mmapped(struct comedi_subdevice *s)\n{\n\tstruct comedi_buf_map *bm = s->async->buf_map;\n\n\treturn bm && (kref_read(&bm->refcount) > 1);\n}\n\nint comedi_buf_alloc(struct comedi_device *dev, struct comedi_subdevice *s,\n\t\t     unsigned long new_size)\n{\n\tstruct comedi_async *async = s->async;\n\n\tlockdep_assert_held(&dev->mutex);\n\n\t \n\tnew_size = (new_size + PAGE_SIZE - 1) & PAGE_MASK;\n\n\t \n\tif (async->prealloc_buf && async->prealloc_bufsz == new_size)\n\t\treturn 0;\n\n\t \n\t__comedi_buf_free(dev, s);\n\n\t \n\tif (new_size) {\n\t\tunsigned int n_pages = new_size >> PAGE_SHIFT;\n\n\t\t__comedi_buf_alloc(dev, s, n_pages);\n\n\t\tif (!async->prealloc_buf) {\n\t\t\t \n\t\t\t__comedi_buf_free(dev, s);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\tasync->prealloc_bufsz = new_size;\n\n\treturn 0;\n}\n\nvoid comedi_buf_reset(struct comedi_subdevice *s)\n{\n\tstruct comedi_async *async = s->async;\n\n\tasync->buf_write_alloc_count = 0;\n\tasync->buf_write_count = 0;\n\tasync->buf_read_alloc_count = 0;\n\tasync->buf_read_count = 0;\n\n\tasync->buf_write_ptr = 0;\n\tasync->buf_read_ptr = 0;\n\n\tasync->cur_chan = 0;\n\tasync->scans_done = 0;\n\tasync->scan_progress = 0;\n\tasync->munge_chan = 0;\n\tasync->munge_count = 0;\n\tasync->munge_ptr = 0;\n\n\tasync->events = 0;\n}\n\nstatic unsigned int comedi_buf_write_n_unalloc(struct comedi_subdevice *s)\n{\n\tstruct comedi_async *async = s->async;\n\tunsigned int free_end = async->buf_read_count + async->prealloc_bufsz;\n\n\treturn free_end - async->buf_write_alloc_count;\n}\n\nunsigned int comedi_buf_write_n_available(struct comedi_subdevice *s)\n{\n\tstruct comedi_async *async = s->async;\n\tunsigned int free_end = async->buf_read_count + async->prealloc_bufsz;\n\n\treturn free_end - async->buf_write_count;\n}\n\n \nunsigned int comedi_buf_write_alloc(struct comedi_subdevice *s,\n\t\t\t\t    unsigned int nbytes)\n{\n\tstruct comedi_async *async = s->async;\n\tunsigned int unalloc = comedi_buf_write_n_unalloc(s);\n\n\tif (nbytes > unalloc)\n\t\tnbytes = unalloc;\n\n\tasync->buf_write_alloc_count += nbytes;\n\n\t \n\tsmp_mb();\n\n\treturn nbytes;\n}\nEXPORT_SYMBOL_GPL(comedi_buf_write_alloc);\n\n \nstatic unsigned int comedi_buf_munge(struct comedi_subdevice *s,\n\t\t\t\t     unsigned int num_bytes)\n{\n\tstruct comedi_async *async = s->async;\n\tunsigned int count = 0;\n\tconst unsigned int num_sample_bytes = comedi_bytes_per_sample(s);\n\n\tif (!s->munge || (async->cmd.flags & CMDF_RAWDATA)) {\n\t\tasync->munge_count += num_bytes;\n\t\treturn num_bytes;\n\t}\n\n\t \n\tnum_bytes -= num_bytes % num_sample_bytes;\n\twhile (count < num_bytes) {\n\t\tint block_size = num_bytes - count;\n\t\tunsigned int buf_end;\n\n\t\tbuf_end = async->prealloc_bufsz - async->munge_ptr;\n\t\tif (block_size > buf_end)\n\t\t\tblock_size = buf_end;\n\n\t\ts->munge(s->device, s,\n\t\t\t async->prealloc_buf + async->munge_ptr,\n\t\t\t block_size, async->munge_chan);\n\n\t\t \n\t\tsmp_wmb();\n\n\t\tasync->munge_chan += block_size / num_sample_bytes;\n\t\tasync->munge_chan %= async->cmd.chanlist_len;\n\t\tasync->munge_count += block_size;\n\t\tasync->munge_ptr += block_size;\n\t\tasync->munge_ptr %= async->prealloc_bufsz;\n\t\tcount += block_size;\n\t}\n\n\treturn count;\n}\n\nunsigned int comedi_buf_write_n_allocated(struct comedi_subdevice *s)\n{\n\tstruct comedi_async *async = s->async;\n\n\treturn async->buf_write_alloc_count - async->buf_write_count;\n}\n\n \nunsigned int comedi_buf_write_free(struct comedi_subdevice *s,\n\t\t\t\t   unsigned int nbytes)\n{\n\tstruct comedi_async *async = s->async;\n\tunsigned int allocated = comedi_buf_write_n_allocated(s);\n\n\tif (nbytes > allocated)\n\t\tnbytes = allocated;\n\n\tasync->buf_write_count += nbytes;\n\tasync->buf_write_ptr += nbytes;\n\tcomedi_buf_munge(s, async->buf_write_count - async->munge_count);\n\tif (async->buf_write_ptr >= async->prealloc_bufsz)\n\t\tasync->buf_write_ptr %= async->prealloc_bufsz;\n\n\treturn nbytes;\n}\nEXPORT_SYMBOL_GPL(comedi_buf_write_free);\n\n \nunsigned int comedi_buf_read_n_available(struct comedi_subdevice *s)\n{\n\tstruct comedi_async *async = s->async;\n\tunsigned int num_bytes;\n\n\tif (!async)\n\t\treturn 0;\n\n\tnum_bytes = async->munge_count - async->buf_read_count;\n\n\t \n\tsmp_rmb();\n\n\treturn num_bytes;\n}\nEXPORT_SYMBOL_GPL(comedi_buf_read_n_available);\n\n \nunsigned int comedi_buf_read_alloc(struct comedi_subdevice *s,\n\t\t\t\t   unsigned int nbytes)\n{\n\tstruct comedi_async *async = s->async;\n\tunsigned int available;\n\n\tavailable = async->munge_count - async->buf_read_alloc_count;\n\tif (nbytes > available)\n\t\tnbytes = available;\n\n\tasync->buf_read_alloc_count += nbytes;\n\n\t \n\tsmp_rmb();\n\n\treturn nbytes;\n}\nEXPORT_SYMBOL_GPL(comedi_buf_read_alloc);\n\nstatic unsigned int comedi_buf_read_n_allocated(struct comedi_async *async)\n{\n\treturn async->buf_read_alloc_count - async->buf_read_count;\n}\n\n \nunsigned int comedi_buf_read_free(struct comedi_subdevice *s,\n\t\t\t\t  unsigned int nbytes)\n{\n\tstruct comedi_async *async = s->async;\n\tunsigned int allocated;\n\n\t \n\tsmp_mb();\n\n\tallocated = comedi_buf_read_n_allocated(async);\n\tif (nbytes > allocated)\n\t\tnbytes = allocated;\n\n\tasync->buf_read_count += nbytes;\n\tasync->buf_read_ptr += nbytes;\n\tasync->buf_read_ptr %= async->prealloc_bufsz;\n\treturn nbytes;\n}\nEXPORT_SYMBOL_GPL(comedi_buf_read_free);\n\nstatic void comedi_buf_memcpy_to(struct comedi_subdevice *s,\n\t\t\t\t const void *data, unsigned int num_bytes)\n{\n\tstruct comedi_async *async = s->async;\n\tunsigned int write_ptr = async->buf_write_ptr;\n\n\twhile (num_bytes) {\n\t\tunsigned int block_size;\n\n\t\tif (write_ptr + num_bytes > async->prealloc_bufsz)\n\t\t\tblock_size = async->prealloc_bufsz - write_ptr;\n\t\telse\n\t\t\tblock_size = num_bytes;\n\n\t\tmemcpy(async->prealloc_buf + write_ptr, data, block_size);\n\n\t\tdata += block_size;\n\t\tnum_bytes -= block_size;\n\n\t\twrite_ptr = 0;\n\t}\n}\n\nstatic void comedi_buf_memcpy_from(struct comedi_subdevice *s,\n\t\t\t\t   void *dest, unsigned int nbytes)\n{\n\tvoid *src;\n\tstruct comedi_async *async = s->async;\n\tunsigned int read_ptr = async->buf_read_ptr;\n\n\twhile (nbytes) {\n\t\tunsigned int block_size;\n\n\t\tsrc = async->prealloc_buf + read_ptr;\n\n\t\tif (nbytes >= async->prealloc_bufsz - read_ptr)\n\t\t\tblock_size = async->prealloc_bufsz - read_ptr;\n\t\telse\n\t\t\tblock_size = nbytes;\n\n\t\tmemcpy(dest, src, block_size);\n\t\tnbytes -= block_size;\n\t\tdest += block_size;\n\t\tread_ptr = 0;\n\t}\n}\n\n \nunsigned int comedi_buf_write_samples(struct comedi_subdevice *s,\n\t\t\t\t      const void *data, unsigned int nsamples)\n{\n\tunsigned int max_samples;\n\tunsigned int nbytes;\n\n\t \n\tmax_samples = comedi_bytes_to_samples(s, comedi_buf_write_n_unalloc(s));\n\tif (nsamples > max_samples) {\n\t\tdev_warn(s->device->class_dev, \"buffer overrun\\n\");\n\t\ts->async->events |= COMEDI_CB_OVERFLOW;\n\t\tnsamples = max_samples;\n\t}\n\n\tif (nsamples == 0)\n\t\treturn 0;\n\n\tnbytes = comedi_buf_write_alloc(s,\n\t\t\t\t\tcomedi_samples_to_bytes(s, nsamples));\n\tcomedi_buf_memcpy_to(s, data, nbytes);\n\tcomedi_buf_write_free(s, nbytes);\n\tcomedi_inc_scan_progress(s, nbytes);\n\ts->async->events |= COMEDI_CB_BLOCK;\n\n\treturn nbytes;\n}\nEXPORT_SYMBOL_GPL(comedi_buf_write_samples);\n\n \nunsigned int comedi_buf_read_samples(struct comedi_subdevice *s,\n\t\t\t\t     void *data, unsigned int nsamples)\n{\n\tunsigned int max_samples;\n\tunsigned int nbytes;\n\n\t \n\tmax_samples = comedi_bytes_to_samples(s,\n\t\t\t\t\t      comedi_buf_read_n_available(s));\n\tif (nsamples > max_samples)\n\t\tnsamples = max_samples;\n\n\tif (nsamples == 0)\n\t\treturn 0;\n\n\tnbytes = comedi_buf_read_alloc(s,\n\t\t\t\t       comedi_samples_to_bytes(s, nsamples));\n\tcomedi_buf_memcpy_from(s, data, nbytes);\n\tcomedi_buf_read_free(s, nbytes);\n\tcomedi_inc_scan_progress(s, nbytes);\n\ts->async->events |= COMEDI_CB_BLOCK;\n\n\treturn nbytes;\n}\nEXPORT_SYMBOL_GPL(comedi_buf_read_samples);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}