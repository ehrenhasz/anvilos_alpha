{
  "module_name": "drivers.c",
  "hash_id": "765d7cff93cac238e07fcab18b48e1a993a98005b554ebf783308516f2eff3a8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/ioport.h>\n#include <linux/slab.h>\n#include <linux/dma-direction.h>\n#include <linux/interrupt.h>\n#include <linux/firmware.h>\n#include <linux/comedi/comedidev.h>\n#include \"comedi_internal.h\"\n\nstruct comedi_driver *comedi_drivers;\n \nDEFINE_MUTEX(comedi_drivers_list_lock);\n\n \nint comedi_set_hw_dev(struct comedi_device *dev, struct device *hw_dev)\n{\n\tif (hw_dev == dev->hw_dev)\n\t\treturn 0;\n\tif (dev->hw_dev)\n\t\treturn -EEXIST;\n\tdev->hw_dev = get_device(hw_dev);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(comedi_set_hw_dev);\n\nstatic void comedi_clear_hw_dev(struct comedi_device *dev)\n{\n\tput_device(dev->hw_dev);\n\tdev->hw_dev = NULL;\n}\n\n \nvoid *comedi_alloc_devpriv(struct comedi_device *dev, size_t size)\n{\n\tdev->private = kzalloc(size, GFP_KERNEL);\n\treturn dev->private;\n}\nEXPORT_SYMBOL_GPL(comedi_alloc_devpriv);\n\n \nint comedi_alloc_subdevices(struct comedi_device *dev, int num_subdevices)\n{\n\tstruct comedi_subdevice *s;\n\tint i;\n\n\tif (num_subdevices < 1)\n\t\treturn -EINVAL;\n\n\ts = kcalloc(num_subdevices, sizeof(*s), GFP_KERNEL);\n\tif (!s)\n\t\treturn -ENOMEM;\n\tdev->subdevices = s;\n\tdev->n_subdevices = num_subdevices;\n\n\tfor (i = 0; i < num_subdevices; ++i) {\n\t\ts = &dev->subdevices[i];\n\t\ts->device = dev;\n\t\ts->index = i;\n\t\ts->async_dma_dir = DMA_NONE;\n\t\tspin_lock_init(&s->spin_lock);\n\t\ts->minor = -1;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(comedi_alloc_subdevices);\n\n \nint comedi_alloc_subdev_readback(struct comedi_subdevice *s)\n{\n\tif (!s->n_chan)\n\t\treturn -EINVAL;\n\n\ts->readback = kcalloc(s->n_chan, sizeof(*s->readback), GFP_KERNEL);\n\tif (!s->readback)\n\t\treturn -ENOMEM;\n\n\tif (!s->insn_read)\n\t\ts->insn_read = comedi_readback_insn_read;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(comedi_alloc_subdev_readback);\n\nstatic void comedi_device_detach_cleanup(struct comedi_device *dev)\n{\n\tint i;\n\tstruct comedi_subdevice *s;\n\n\tlockdep_assert_held(&dev->attach_lock);\n\tlockdep_assert_held(&dev->mutex);\n\tif (dev->subdevices) {\n\t\tfor (i = 0; i < dev->n_subdevices; i++) {\n\t\t\ts = &dev->subdevices[i];\n\t\t\tif (comedi_can_auto_free_spriv(s))\n\t\t\t\tkfree(s->private);\n\t\t\tcomedi_free_subdevice_minor(s);\n\t\t\tif (s->async) {\n\t\t\t\tcomedi_buf_alloc(dev, s, 0);\n\t\t\t\tkfree(s->async);\n\t\t\t}\n\t\t\tkfree(s->readback);\n\t\t}\n\t\tkfree(dev->subdevices);\n\t\tdev->subdevices = NULL;\n\t\tdev->n_subdevices = 0;\n\t}\n\tkfree(dev->private);\n\tkfree(dev->pacer);\n\tdev->private = NULL;\n\tdev->pacer = NULL;\n\tdev->driver = NULL;\n\tdev->board_name = NULL;\n\tdev->board_ptr = NULL;\n\tdev->mmio = NULL;\n\tdev->iobase = 0;\n\tdev->iolen = 0;\n\tdev->ioenabled = false;\n\tdev->irq = 0;\n\tdev->read_subdev = NULL;\n\tdev->write_subdev = NULL;\n\tdev->open = NULL;\n\tdev->close = NULL;\n\tcomedi_clear_hw_dev(dev);\n}\n\nvoid comedi_device_detach(struct comedi_device *dev)\n{\n\tlockdep_assert_held(&dev->mutex);\n\tcomedi_device_cancel_all(dev);\n\tdown_write(&dev->attach_lock);\n\tdev->attached = false;\n\tdev->detach_count++;\n\tif (dev->driver)\n\t\tdev->driver->detach(dev);\n\tcomedi_device_detach_cleanup(dev);\n\tup_write(&dev->attach_lock);\n}\n\nstatic int poll_invalid(struct comedi_device *dev, struct comedi_subdevice *s)\n{\n\treturn -EINVAL;\n}\n\nstatic int insn_device_inval(struct comedi_device *dev,\n\t\t\t     struct comedi_insn *insn, unsigned int *data)\n{\n\treturn -EINVAL;\n}\n\nstatic unsigned int get_zero_valid_routes(struct comedi_device *dev,\n\t\t\t\t\t  unsigned int n_pairs,\n\t\t\t\t\t  unsigned int *pair_data)\n{\n\treturn 0;\n}\n\nint insn_inval(struct comedi_device *dev, struct comedi_subdevice *s,\n\t       struct comedi_insn *insn, unsigned int *data)\n{\n\treturn -EINVAL;\n}\n\n \nint comedi_readback_insn_read(struct comedi_device *dev,\n\t\t\t      struct comedi_subdevice *s,\n\t\t\t      struct comedi_insn *insn,\n\t\t\t      unsigned int *data)\n{\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tint i;\n\n\tif (!s->readback)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < insn->n; i++)\n\t\tdata[i] = s->readback[chan];\n\n\treturn insn->n;\n}\nEXPORT_SYMBOL_GPL(comedi_readback_insn_read);\n\n \nint comedi_timeout(struct comedi_device *dev,\n\t\t   struct comedi_subdevice *s,\n\t\t   struct comedi_insn *insn,\n\t\t   int (*cb)(struct comedi_device *dev,\n\t\t\t     struct comedi_subdevice *s,\n\t\t\t     struct comedi_insn *insn,\n\t\t\t     unsigned long context),\n\t\t   unsigned long context)\n{\n\tunsigned long timeout = jiffies + msecs_to_jiffies(COMEDI_TIMEOUT_MS);\n\tint ret;\n\n\twhile (time_before(jiffies, timeout)) {\n\t\tret = cb(dev, s, insn, context);\n\t\tif (ret != -EBUSY)\n\t\t\treturn ret;\t \n\t\tcpu_relax();\n\t}\n\treturn -ETIMEDOUT;\n}\nEXPORT_SYMBOL_GPL(comedi_timeout);\n\n \nint comedi_dio_insn_config(struct comedi_device *dev,\n\t\t\t   struct comedi_subdevice *s,\n\t\t\t   struct comedi_insn *insn,\n\t\t\t   unsigned int *data,\n\t\t\t   unsigned int mask)\n{\n\tunsigned int chan_mask = 1 << CR_CHAN(insn->chanspec);\n\n\tif (!mask)\n\t\tmask = chan_mask;\n\n\tswitch (data[0]) {\n\tcase INSN_CONFIG_DIO_INPUT:\n\t\ts->io_bits &= ~mask;\n\t\tbreak;\n\n\tcase INSN_CONFIG_DIO_OUTPUT:\n\t\ts->io_bits |= mask;\n\t\tbreak;\n\n\tcase INSN_CONFIG_DIO_QUERY:\n\t\tdata[1] = (s->io_bits & mask) ? COMEDI_OUTPUT : COMEDI_INPUT;\n\t\treturn insn->n;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(comedi_dio_insn_config);\n\n \nunsigned int comedi_dio_update_state(struct comedi_subdevice *s,\n\t\t\t\t     unsigned int *data)\n{\n\tunsigned int chanmask = (s->n_chan < 32) ? ((1 << s->n_chan) - 1)\n\t\t\t\t\t\t : 0xffffffff;\n\tunsigned int mask = data[0] & chanmask;\n\tunsigned int bits = data[1];\n\n\tif (mask) {\n\t\ts->state &= ~mask;\n\t\ts->state |= (bits & mask);\n\t}\n\n\treturn mask;\n}\nEXPORT_SYMBOL_GPL(comedi_dio_update_state);\n\n \nunsigned int comedi_bytes_per_scan_cmd(struct comedi_subdevice *s,\n\t\t\t\t       struct comedi_cmd *cmd)\n{\n\tunsigned int num_samples;\n\tunsigned int bits_per_sample;\n\n\tswitch (s->type) {\n\tcase COMEDI_SUBD_DI:\n\tcase COMEDI_SUBD_DO:\n\tcase COMEDI_SUBD_DIO:\n\t\tbits_per_sample = 8 * comedi_bytes_per_sample(s);\n\t\tnum_samples = DIV_ROUND_UP(cmd->scan_end_arg, bits_per_sample);\n\t\tbreak;\n\tdefault:\n\t\tnum_samples = cmd->scan_end_arg;\n\t\tbreak;\n\t}\n\treturn comedi_samples_to_bytes(s, num_samples);\n}\nEXPORT_SYMBOL_GPL(comedi_bytes_per_scan_cmd);\n\n \nunsigned int comedi_bytes_per_scan(struct comedi_subdevice *s)\n{\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\n\treturn comedi_bytes_per_scan_cmd(s, cmd);\n}\nEXPORT_SYMBOL_GPL(comedi_bytes_per_scan);\n\nstatic unsigned int __comedi_nscans_left(struct comedi_subdevice *s,\n\t\t\t\t\t unsigned int nscans)\n{\n\tstruct comedi_async *async = s->async;\n\tstruct comedi_cmd *cmd = &async->cmd;\n\n\tif (cmd->stop_src == TRIG_COUNT) {\n\t\tunsigned int scans_left = 0;\n\n\t\tif (async->scans_done < cmd->stop_arg)\n\t\t\tscans_left = cmd->stop_arg - async->scans_done;\n\n\t\tif (nscans > scans_left)\n\t\t\tnscans = scans_left;\n\t}\n\treturn nscans;\n}\n\n \nunsigned int comedi_nscans_left(struct comedi_subdevice *s,\n\t\t\t\tunsigned int nscans)\n{\n\tif (nscans == 0) {\n\t\tunsigned int nbytes = comedi_buf_read_n_available(s);\n\n\t\tnscans = nbytes / comedi_bytes_per_scan(s);\n\t}\n\treturn __comedi_nscans_left(s, nscans);\n}\nEXPORT_SYMBOL_GPL(comedi_nscans_left);\n\n \nunsigned int comedi_nsamples_left(struct comedi_subdevice *s,\n\t\t\t\t  unsigned int nsamples)\n{\n\tstruct comedi_async *async = s->async;\n\tstruct comedi_cmd *cmd = &async->cmd;\n\tunsigned long long scans_left;\n\tunsigned long long samples_left;\n\n\tif (cmd->stop_src != TRIG_COUNT)\n\t\treturn nsamples;\n\n\tscans_left = __comedi_nscans_left(s, cmd->stop_arg);\n\tif (!scans_left)\n\t\treturn 0;\n\n\tsamples_left = scans_left * cmd->scan_end_arg -\n\t\tcomedi_bytes_to_samples(s, async->scan_progress);\n\n\tif (samples_left < nsamples)\n\t\treturn samples_left;\n\treturn nsamples;\n}\nEXPORT_SYMBOL_GPL(comedi_nsamples_left);\n\n \nvoid comedi_inc_scan_progress(struct comedi_subdevice *s,\n\t\t\t      unsigned int num_bytes)\n{\n\tstruct comedi_async *async = s->async;\n\tstruct comedi_cmd *cmd = &async->cmd;\n\tunsigned int scan_length = comedi_bytes_per_scan(s);\n\n\t \n\tif (!(s->subdev_flags & SDF_PACKED)) {\n\t\tasync->cur_chan += comedi_bytes_to_samples(s, num_bytes);\n\t\tasync->cur_chan %= cmd->chanlist_len;\n\t}\n\n\tasync->scan_progress += num_bytes;\n\tif (async->scan_progress >= scan_length) {\n\t\tunsigned int nscans = async->scan_progress / scan_length;\n\n\t\tif (async->scans_done < (UINT_MAX - nscans))\n\t\t\tasync->scans_done += nscans;\n\t\telse\n\t\t\tasync->scans_done = UINT_MAX;\n\n\t\tasync->scan_progress %= scan_length;\n\t\tasync->events |= COMEDI_CB_EOS;\n\t}\n}\nEXPORT_SYMBOL_GPL(comedi_inc_scan_progress);\n\n \nunsigned int comedi_handle_events(struct comedi_device *dev,\n\t\t\t\t  struct comedi_subdevice *s)\n{\n\tunsigned int events = s->async->events;\n\n\tif (events == 0)\n\t\treturn events;\n\n\tif ((events & COMEDI_CB_CANCEL_MASK) && s->cancel)\n\t\ts->cancel(dev, s);\n\n\tcomedi_event(dev, s);\n\n\treturn events;\n}\nEXPORT_SYMBOL_GPL(comedi_handle_events);\n\nstatic int insn_rw_emulate_bits(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tstruct comedi_insn *insn,\n\t\t\t\tunsigned int *data)\n{\n\tstruct comedi_insn _insn;\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int base_chan = (chan < 32) ? 0 : chan;\n\tunsigned int _data[2];\n\tint ret;\n\n\tmemset(_data, 0, sizeof(_data));\n\tmemset(&_insn, 0, sizeof(_insn));\n\t_insn.insn = INSN_BITS;\n\t_insn.chanspec = base_chan;\n\t_insn.n = 2;\n\t_insn.subdev = insn->subdev;\n\n\tif (insn->insn == INSN_WRITE) {\n\t\tif (!(s->subdev_flags & SDF_WRITABLE))\n\t\t\treturn -EINVAL;\n\t\t_data[0] = 1 << (chan - base_chan);\t\t     \n\t\t_data[1] = data[0] ? (1 << (chan - base_chan)) : 0;  \n\t}\n\n\tret = s->insn_bits(dev, s, &_insn, _data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (insn->insn == INSN_READ)\n\t\tdata[0] = (_data[1] >> (chan - base_chan)) & 1;\n\n\treturn 1;\n}\n\nstatic int __comedi_device_postconfig_async(struct comedi_device *dev,\n\t\t\t\t\t    struct comedi_subdevice *s)\n{\n\tstruct comedi_async *async;\n\tunsigned int buf_size;\n\tint ret;\n\n\tlockdep_assert_held(&dev->mutex);\n\tif ((s->subdev_flags & (SDF_CMD_READ | SDF_CMD_WRITE)) == 0) {\n\t\tdev_warn(dev->class_dev,\n\t\t\t \"async subdevices must support SDF_CMD_READ or SDF_CMD_WRITE\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (!s->do_cmdtest) {\n\t\tdev_warn(dev->class_dev,\n\t\t\t \"async subdevices must have a do_cmdtest() function\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (!s->cancel)\n\t\tdev_warn(dev->class_dev,\n\t\t\t \"async subdevices should have a cancel() function\\n\");\n\n\tasync = kzalloc(sizeof(*async), GFP_KERNEL);\n\tif (!async)\n\t\treturn -ENOMEM;\n\n\tinit_waitqueue_head(&async->wait_head);\n\ts->async = async;\n\n\tasync->max_bufsize = comedi_default_buf_maxsize_kb * 1024;\n\tbuf_size = comedi_default_buf_size_kb * 1024;\n\tif (buf_size > async->max_bufsize)\n\t\tbuf_size = async->max_bufsize;\n\n\tif (comedi_buf_alloc(dev, s, buf_size) < 0) {\n\t\tdev_warn(dev->class_dev, \"Buffer allocation failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tif (s->buf_change) {\n\t\tret = s->buf_change(dev, s);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tcomedi_alloc_subdevice_minor(s);\n\n\treturn 0;\n}\n\nstatic int __comedi_device_postconfig(struct comedi_device *dev)\n{\n\tstruct comedi_subdevice *s;\n\tint ret;\n\tint i;\n\n\tlockdep_assert_held(&dev->mutex);\n\tif (!dev->insn_device_config)\n\t\tdev->insn_device_config = insn_device_inval;\n\n\tif (!dev->get_valid_routes)\n\t\tdev->get_valid_routes = get_zero_valid_routes;\n\n\tfor (i = 0; i < dev->n_subdevices; i++) {\n\t\ts = &dev->subdevices[i];\n\n\t\tif (s->type == COMEDI_SUBD_UNUSED)\n\t\t\tcontinue;\n\n\t\tif (s->type == COMEDI_SUBD_DO) {\n\t\t\tif (s->n_chan < 32)\n\t\t\t\ts->io_bits = (1 << s->n_chan) - 1;\n\t\t\telse\n\t\t\t\ts->io_bits = 0xffffffff;\n\t\t}\n\n\t\tif (s->len_chanlist == 0)\n\t\t\ts->len_chanlist = 1;\n\n\t\tif (s->do_cmd) {\n\t\t\tret = __comedi_device_postconfig_async(dev, s);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tif (!s->range_table && !s->range_table_list)\n\t\t\ts->range_table = &range_unknown;\n\n\t\tif (!s->insn_read && s->insn_bits)\n\t\t\ts->insn_read = insn_rw_emulate_bits;\n\t\tif (!s->insn_write && s->insn_bits)\n\t\t\ts->insn_write = insn_rw_emulate_bits;\n\n\t\tif (!s->insn_read)\n\t\t\ts->insn_read = insn_inval;\n\t\tif (!s->insn_write)\n\t\t\ts->insn_write = insn_inval;\n\t\tif (!s->insn_bits)\n\t\t\ts->insn_bits = insn_inval;\n\t\tif (!s->insn_config)\n\t\t\ts->insn_config = insn_inval;\n\n\t\tif (!s->poll)\n\t\t\ts->poll = poll_invalid;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int comedi_device_postconfig(struct comedi_device *dev)\n{\n\tint ret;\n\n\tlockdep_assert_held(&dev->mutex);\n\tret = __comedi_device_postconfig(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\tdown_write(&dev->attach_lock);\n\tdev->attached = true;\n\tup_write(&dev->attach_lock);\n\treturn 0;\n}\n\n \nstatic void *comedi_recognize(struct comedi_driver *driv, const char *name)\n{\n\tchar **name_ptr = (char **)driv->board_name;\n\tint i;\n\n\tfor (i = 0; i < driv->num_names; i++) {\n\t\tif (strcmp(*name_ptr, name) == 0)\n\t\t\treturn name_ptr;\n\t\tname_ptr = (void *)name_ptr + driv->offset;\n\t}\n\n\treturn NULL;\n}\n\nstatic void comedi_report_boards(struct comedi_driver *driv)\n{\n\tunsigned int i;\n\tconst char *const *name_ptr;\n\n\tpr_info(\"comedi: valid board names for %s driver are:\\n\",\n\t\tdriv->driver_name);\n\n\tname_ptr = driv->board_name;\n\tfor (i = 0; i < driv->num_names; i++) {\n\t\tpr_info(\" %s\\n\", *name_ptr);\n\t\tname_ptr = (const char **)((char *)name_ptr + driv->offset);\n\t}\n\n\tif (driv->num_names == 0)\n\t\tpr_info(\" %s\\n\", driv->driver_name);\n}\n\n \nint comedi_load_firmware(struct comedi_device *dev,\n\t\t\t struct device *device,\n\t\t\t const char *name,\n\t\t\t int (*cb)(struct comedi_device *dev,\n\t\t\t\t   const u8 *data, size_t size,\n\t\t\t\t   unsigned long context),\n\t\t\t unsigned long context)\n{\n\tconst struct firmware *fw;\n\tint ret;\n\n\tif (!cb)\n\t\treturn -EINVAL;\n\n\tret = request_firmware(&fw, name, device);\n\tif (ret == 0) {\n\t\tret = cb(dev, fw->data, fw->size, context);\n\t\trelease_firmware(fw);\n\t}\n\n\treturn min(ret, 0);\n}\nEXPORT_SYMBOL_GPL(comedi_load_firmware);\n\n \nint __comedi_request_region(struct comedi_device *dev,\n\t\t\t    unsigned long start, unsigned long len)\n{\n\tif (!start) {\n\t\tdev_warn(dev->class_dev,\n\t\t\t \"%s: a I/O base address must be specified\\n\",\n\t\t\t dev->board_name);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!request_region(start, len, dev->board_name)) {\n\t\tdev_warn(dev->class_dev, \"%s: I/O port conflict (%#lx,%lu)\\n\",\n\t\t\t dev->board_name, start, len);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(__comedi_request_region);\n\n \nint comedi_request_region(struct comedi_device *dev,\n\t\t\t  unsigned long start, unsigned long len)\n{\n\tint ret;\n\n\tret = __comedi_request_region(dev, start, len);\n\tif (ret == 0) {\n\t\tdev->iobase = start;\n\t\tdev->iolen = len;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(comedi_request_region);\n\n \nvoid comedi_legacy_detach(struct comedi_device *dev)\n{\n\tif (dev->irq) {\n\t\tfree_irq(dev->irq, dev);\n\t\tdev->irq = 0;\n\t}\n\tif (dev->iobase && dev->iolen) {\n\t\trelease_region(dev->iobase, dev->iolen);\n\t\tdev->iobase = 0;\n\t\tdev->iolen = 0;\n\t}\n}\nEXPORT_SYMBOL_GPL(comedi_legacy_detach);\n\nint comedi_device_attach(struct comedi_device *dev, struct comedi_devconfig *it)\n{\n\tstruct comedi_driver *driv;\n\tint ret;\n\n\tlockdep_assert_held(&dev->mutex);\n\tif (dev->attached)\n\t\treturn -EBUSY;\n\n\tmutex_lock(&comedi_drivers_list_lock);\n\tfor (driv = comedi_drivers; driv; driv = driv->next) {\n\t\tif (!try_module_get(driv->module))\n\t\t\tcontinue;\n\t\tif (driv->num_names) {\n\t\t\tdev->board_ptr = comedi_recognize(driv, it->board_name);\n\t\t\tif (dev->board_ptr)\n\t\t\t\tbreak;\n\t\t} else if (strcmp(driv->driver_name, it->board_name) == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tmodule_put(driv->module);\n\t}\n\tif (!driv) {\n\t\t \n\t\t \n\t\tfor (driv = comedi_drivers; driv; driv = driv->next) {\n\t\t\tif (!try_module_get(driv->module))\n\t\t\t\tcontinue;\n\t\t\tcomedi_report_boards(driv);\n\t\t\tmodule_put(driv->module);\n\t\t}\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\tif (!driv->attach) {\n\t\t \n\t\tdev_warn(dev->class_dev,\n\t\t\t \"driver '%s' does not support attach using comedi_config\\n\",\n\t\t\t driv->driver_name);\n\t\tmodule_put(driv->module);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\tdev->driver = driv;\n\tdev->board_name = dev->board_ptr ? *(const char **)dev->board_ptr\n\t\t\t\t\t : dev->driver->driver_name;\n\tret = driv->attach(dev, it);\n\tif (ret >= 0)\n\t\tret = comedi_device_postconfig(dev);\n\tif (ret < 0) {\n\t\tcomedi_device_detach(dev);\n\t\tmodule_put(driv->module);\n\t}\n\t \nout:\n\tmutex_unlock(&comedi_drivers_list_lock);\n\treturn ret;\n}\n\n \nint comedi_auto_config(struct device *hardware_device,\n\t\t       struct comedi_driver *driver, unsigned long context)\n{\n\tstruct comedi_device *dev;\n\tint ret;\n\n\tif (!hardware_device) {\n\t\tpr_warn(\"BUG! %s called with NULL hardware_device\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\tif (!driver) {\n\t\tdev_warn(hardware_device,\n\t\t\t \"BUG! %s called with NULL comedi driver\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!driver->auto_attach) {\n\t\tdev_warn(hardware_device,\n\t\t\t \"BUG! comedi driver '%s' has no auto_attach handler\\n\",\n\t\t\t driver->driver_name);\n\t\treturn -EINVAL;\n\t}\n\n\tdev = comedi_alloc_board_minor(hardware_device);\n\tif (IS_ERR(dev)) {\n\t\tdev_warn(hardware_device,\n\t\t\t \"driver '%s' could not create device.\\n\",\n\t\t\t driver->driver_name);\n\t\treturn PTR_ERR(dev);\n\t}\n\t \n\tlockdep_assert_held(&dev->mutex);\n\n\tdev->driver = driver;\n\tdev->board_name = dev->driver->driver_name;\n\tret = driver->auto_attach(dev, context);\n\tif (ret >= 0)\n\t\tret = comedi_device_postconfig(dev);\n\n\tif (ret < 0) {\n\t\tdev_warn(hardware_device,\n\t\t\t \"driver '%s' failed to auto-configure device.\\n\",\n\t\t\t driver->driver_name);\n\t\tmutex_unlock(&dev->mutex);\n\t\tcomedi_release_hardware_device(hardware_device);\n\t} else {\n\t\t \n\t\tdev_info(dev->class_dev,\n\t\t\t \"driver '%s' has successfully auto-configured '%s'.\\n\",\n\t\t\t driver->driver_name, dev->board_name);\n\t\tmutex_unlock(&dev->mutex);\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(comedi_auto_config);\n\n \nvoid comedi_auto_unconfig(struct device *hardware_device)\n{\n\tif (!hardware_device)\n\t\treturn;\n\tcomedi_release_hardware_device(hardware_device);\n}\nEXPORT_SYMBOL_GPL(comedi_auto_unconfig);\n\n \nint comedi_driver_register(struct comedi_driver *driver)\n{\n\tmutex_lock(&comedi_drivers_list_lock);\n\tdriver->next = comedi_drivers;\n\tcomedi_drivers = driver;\n\tmutex_unlock(&comedi_drivers_list_lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(comedi_driver_register);\n\n \nvoid comedi_driver_unregister(struct comedi_driver *driver)\n{\n\tstruct comedi_driver *prev;\n\tint i;\n\n\t \n\tmutex_lock(&comedi_drivers_list_lock);\n\tif (comedi_drivers == driver) {\n\t\tcomedi_drivers = driver->next;\n\t} else {\n\t\tfor (prev = comedi_drivers; prev->next; prev = prev->next) {\n\t\t\tif (prev->next == driver) {\n\t\t\t\tprev->next = driver->next;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&comedi_drivers_list_lock);\n\n\t \n\tfor (i = 0; i < COMEDI_NUM_BOARD_MINORS; i++) {\n\t\tstruct comedi_device *dev = comedi_dev_get_from_minor(i);\n\n\t\tif (!dev)\n\t\t\tcontinue;\n\n\t\tmutex_lock(&dev->mutex);\n\t\tif (dev->attached && dev->driver == driver) {\n\t\t\tif (dev->use_count)\n\t\t\t\tdev_warn(dev->class_dev,\n\t\t\t\t\t \"BUG! detaching device with use_count=%d\\n\",\n\t\t\t\t\t dev->use_count);\n\t\t\tcomedi_device_detach(dev);\n\t\t}\n\t\tmutex_unlock(&dev->mutex);\n\t\tcomedi_dev_put(dev);\n\t}\n}\nEXPORT_SYMBOL_GPL(comedi_driver_unregister);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}