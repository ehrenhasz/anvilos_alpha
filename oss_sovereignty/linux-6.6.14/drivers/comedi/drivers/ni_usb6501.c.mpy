{
  "module_name": "ni_usb6501.c",
  "hash_id": "a57221e3574151eb0aa5dd7146d43d1d1d036c1f5e7a3a990262376e3e201e17",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/ni_usb6501.c",
  "human_readable_source": "\n \n\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/comedi/comedi_usb.h>\n\n#define\tNI6501_TIMEOUT\t1000\n\n \nstatic const u8 READ_PORT_REQUEST[]\t= {0x00, 0x01, 0x00, 0x10,\n\t\t\t\t\t   0x00, 0x0C, 0x01, 0x0E,\n\t\t\t\t\t   0x02, 0x10, 0x00, 0x00,\n\t\t\t\t\t   0x00, 0x03, 0x00, 0x00};\n\nstatic const u8 WRITE_PORT_REQUEST[]\t= {0x00, 0x01, 0x00, 0x14,\n\t\t\t\t\t   0x00, 0x10, 0x01, 0x0F,\n\t\t\t\t\t   0x02, 0x10, 0x00, 0x00,\n\t\t\t\t\t   0x00, 0x03, 0x00, 0x00,\n\t\t\t\t\t   0x03, 0x00, 0x00, 0x00};\n\nstatic const u8 SET_PORT_DIR_REQUEST[]\t= {0x00, 0x01, 0x00, 0x18,\n\t\t\t\t\t   0x00, 0x14, 0x01, 0x12,\n\t\t\t\t\t   0x02, 0x10, 0x00, 0x00,\n\t\t\t\t\t   0x00, 0x05, 0x00, 0x00,\n\t\t\t\t\t   0x00, 0x00, 0x05, 0x00,\n\t\t\t\t\t   0x00, 0x00, 0x00, 0x00};\n\n \nstatic const u8 START_COUNTER_REQUEST[]\t= {0x00, 0x01, 0x00, 0x0C,\n\t\t\t\t\t   0x00, 0x08, 0x01, 0x09,\n\t\t\t\t\t   0x02, 0x20, 0x00, 0x00};\n\nstatic const u8 STOP_COUNTER_REQUEST[]\t= {0x00, 0x01, 0x00, 0x0C,\n\t\t\t\t\t   0x00, 0x08, 0x01, 0x0C,\n\t\t\t\t\t   0x02, 0x20, 0x00, 0x00};\n\nstatic const u8 READ_COUNTER_REQUEST[]\t= {0x00, 0x01, 0x00, 0x0C,\n\t\t\t\t\t   0x00, 0x08, 0x01, 0x0E,\n\t\t\t\t\t   0x02, 0x20, 0x00, 0x00};\n\nstatic const u8 WRITE_COUNTER_REQUEST[]\t= {0x00, 0x01, 0x00, 0x10,\n\t\t\t\t\t   0x00, 0x0C, 0x01, 0x0F,\n\t\t\t\t\t   0x02, 0x20, 0x00, 0x00,\n\t\t\t\t\t   0x00, 0x00, 0x00, 0x00};\n\n \nstatic const u8 GENERIC_RESPONSE[]\t= {0x00, 0x01, 0x00, 0x0C,\n\t\t\t\t\t   0x00, 0x08, 0x01, 0x00,\n\t\t\t\t\t   0x00, 0x00, 0x00, 0x02};\n\nstatic const u8 READ_PORT_RESPONSE[]\t= {0x00, 0x01, 0x00, 0x10,\n\t\t\t\t\t   0x00, 0x0C, 0x01, 0x00,\n\t\t\t\t\t   0x00, 0x00, 0x00, 0x02,\n\t\t\t\t\t   0x00, 0x03, 0x00, 0x00};\n\nstatic const u8 READ_COUNTER_RESPONSE[]\t= {0x00, 0x01, 0x00, 0x10,\n\t\t\t\t\t   0x00, 0x0C, 0x01, 0x00,\n\t\t\t\t\t   0x00, 0x00, 0x00, 0x02,\n\t\t\t\t\t   0x00, 0x00, 0x00, 0x00};\n\n \nstatic const size_t TX_MAX_SIZE\t= sizeof(SET_PORT_DIR_REQUEST);\nstatic const size_t RX_MAX_SIZE\t= sizeof(READ_PORT_RESPONSE);\n\nenum commands {\n\tREAD_PORT,\n\tWRITE_PORT,\n\tSET_PORT_DIR,\n\tSTART_COUNTER,\n\tSTOP_COUNTER,\n\tREAD_COUNTER,\n\tWRITE_COUNTER\n};\n\nstruct ni6501_private {\n\tstruct usb_endpoint_descriptor *ep_rx;\n\tstruct usb_endpoint_descriptor *ep_tx;\n\tstruct mutex mut;\n\tu8 *usb_rx_buf;\n\tu8 *usb_tx_buf;\n};\n\nstatic int ni6501_port_command(struct comedi_device *dev, int command,\n\t\t\t       unsigned int val, u8 *bitmap)\n{\n\tstruct usb_device *usb = comedi_to_usb_dev(dev);\n\tstruct ni6501_private *devpriv = dev->private;\n\tint request_size, response_size;\n\tu8 *tx = devpriv->usb_tx_buf;\n\tint ret;\n\n\tif (command != SET_PORT_DIR && !bitmap)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&devpriv->mut);\n\n\tswitch (command) {\n\tcase READ_PORT:\n\t\trequest_size = sizeof(READ_PORT_REQUEST);\n\t\tresponse_size = sizeof(READ_PORT_RESPONSE);\n\t\tmemcpy(tx, READ_PORT_REQUEST, request_size);\n\t\ttx[14] = val & 0xff;\n\t\tbreak;\n\tcase WRITE_PORT:\n\t\trequest_size = sizeof(WRITE_PORT_REQUEST);\n\t\tresponse_size = sizeof(GENERIC_RESPONSE);\n\t\tmemcpy(tx, WRITE_PORT_REQUEST, request_size);\n\t\ttx[14] = val & 0xff;\n\t\ttx[17] = *bitmap;\n\t\tbreak;\n\tcase SET_PORT_DIR:\n\t\trequest_size = sizeof(SET_PORT_DIR_REQUEST);\n\t\tresponse_size = sizeof(GENERIC_RESPONSE);\n\t\tmemcpy(tx, SET_PORT_DIR_REQUEST, request_size);\n\t\ttx[14] = val & 0xff;\n\t\ttx[15] = (val >> 8) & 0xff;\n\t\ttx[16] = (val >> 16) & 0xff;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto end;\n\t}\n\n\tret = usb_bulk_msg(usb,\n\t\t\t   usb_sndbulkpipe(usb,\n\t\t\t\t\t   devpriv->ep_tx->bEndpointAddress),\n\t\t\t   devpriv->usb_tx_buf,\n\t\t\t   request_size,\n\t\t\t   NULL,\n\t\t\t   NI6501_TIMEOUT);\n\tif (ret)\n\t\tgoto end;\n\n\tret = usb_bulk_msg(usb,\n\t\t\t   usb_rcvbulkpipe(usb,\n\t\t\t\t\t   devpriv->ep_rx->bEndpointAddress),\n\t\t\t   devpriv->usb_rx_buf,\n\t\t\t   response_size,\n\t\t\t   NULL,\n\t\t\t   NI6501_TIMEOUT);\n\tif (ret)\n\t\tgoto end;\n\n\t \n\n\tif (command == READ_PORT) {\n\t\t*bitmap = devpriv->usb_rx_buf[14];\n\t\t \n\t\tdevpriv->usb_rx_buf[14] = 0x00;\n\n\t\tif (memcmp(devpriv->usb_rx_buf, READ_PORT_RESPONSE,\n\t\t\t   sizeof(READ_PORT_RESPONSE))) {\n\t\t\tret = -EINVAL;\n\t\t}\n\t} else if (memcmp(devpriv->usb_rx_buf, GENERIC_RESPONSE,\n\t\t\t  sizeof(GENERIC_RESPONSE))) {\n\t\tret = -EINVAL;\n\t}\nend:\n\tmutex_unlock(&devpriv->mut);\n\n\treturn ret;\n}\n\nstatic int ni6501_counter_command(struct comedi_device *dev, int command,\n\t\t\t\t  u32 *val)\n{\n\tstruct usb_device *usb = comedi_to_usb_dev(dev);\n\tstruct ni6501_private *devpriv = dev->private;\n\tint request_size, response_size;\n\tu8 *tx = devpriv->usb_tx_buf;\n\tint ret;\n\n\tif ((command == READ_COUNTER || command ==  WRITE_COUNTER) && !val)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&devpriv->mut);\n\n\tswitch (command) {\n\tcase START_COUNTER:\n\t\trequest_size = sizeof(START_COUNTER_REQUEST);\n\t\tresponse_size = sizeof(GENERIC_RESPONSE);\n\t\tmemcpy(tx, START_COUNTER_REQUEST, request_size);\n\t\tbreak;\n\tcase STOP_COUNTER:\n\t\trequest_size = sizeof(STOP_COUNTER_REQUEST);\n\t\tresponse_size = sizeof(GENERIC_RESPONSE);\n\t\tmemcpy(tx, STOP_COUNTER_REQUEST, request_size);\n\t\tbreak;\n\tcase READ_COUNTER:\n\t\trequest_size = sizeof(READ_COUNTER_REQUEST);\n\t\tresponse_size = sizeof(READ_COUNTER_RESPONSE);\n\t\tmemcpy(tx, READ_COUNTER_REQUEST, request_size);\n\t\tbreak;\n\tcase WRITE_COUNTER:\n\t\trequest_size = sizeof(WRITE_COUNTER_REQUEST);\n\t\tresponse_size = sizeof(GENERIC_RESPONSE);\n\t\tmemcpy(tx, WRITE_COUNTER_REQUEST, request_size);\n\t\t \n\t\t \n\t\t*((__be32 *)&tx[12]) = cpu_to_be32(*val);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto end;\n\t}\n\n\tret = usb_bulk_msg(usb,\n\t\t\t   usb_sndbulkpipe(usb,\n\t\t\t\t\t   devpriv->ep_tx->bEndpointAddress),\n\t\t\t   devpriv->usb_tx_buf,\n\t\t\t   request_size,\n\t\t\t   NULL,\n\t\t\t   NI6501_TIMEOUT);\n\tif (ret)\n\t\tgoto end;\n\n\tret = usb_bulk_msg(usb,\n\t\t\t   usb_rcvbulkpipe(usb,\n\t\t\t\t\t   devpriv->ep_rx->bEndpointAddress),\n\t\t\t   devpriv->usb_rx_buf,\n\t\t\t   response_size,\n\t\t\t   NULL,\n\t\t\t   NI6501_TIMEOUT);\n\tif (ret)\n\t\tgoto end;\n\n\t \n\n\tif (command == READ_COUNTER) {\n\t\tint i;\n\n\t\t \n\t\t \n\t\t*val = be32_to_cpu(*((__be32 *)&devpriv->usb_rx_buf[12]));\n\n\t\t \n\t\tfor (i = 12; i < sizeof(READ_COUNTER_RESPONSE); ++i)\n\t\t\tdevpriv->usb_rx_buf[i] = 0x00;\n\n\t\tif (memcmp(devpriv->usb_rx_buf, READ_COUNTER_RESPONSE,\n\t\t\t   sizeof(READ_COUNTER_RESPONSE))) {\n\t\t\tret = -EINVAL;\n\t\t}\n\t} else if (memcmp(devpriv->usb_rx_buf, GENERIC_RESPONSE,\n\t\t\t  sizeof(GENERIC_RESPONSE))) {\n\t\tret = -EINVAL;\n\t}\nend:\n\tmutex_unlock(&devpriv->mut);\n\n\treturn ret;\n}\n\nstatic int ni6501_dio_insn_config(struct comedi_device *dev,\n\t\t\t\t  struct comedi_subdevice *s,\n\t\t\t\t  struct comedi_insn *insn,\n\t\t\t\t  unsigned int *data)\n{\n\tint ret;\n\n\tret = comedi_dio_insn_config(dev, s, insn, data, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ni6501_port_command(dev, SET_PORT_DIR, s->io_bits, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\treturn insn->n;\n}\n\nstatic int ni6501_dio_insn_bits(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tstruct comedi_insn *insn,\n\t\t\t\tunsigned int *data)\n{\n\tunsigned int mask;\n\tint ret;\n\tu8 port;\n\tu8 bitmap;\n\n\tmask = comedi_dio_update_state(s, data);\n\n\tfor (port = 0; port < 3; port++) {\n\t\tif (mask & (0xFF << port * 8)) {\n\t\t\tbitmap = (s->state >> port * 8) & 0xFF;\n\t\t\tret = ni6501_port_command(dev, WRITE_PORT,\n\t\t\t\t\t\t  port, &bitmap);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tdata[1] = 0;\n\n\tfor (port = 0; port < 3; port++) {\n\t\tret = ni6501_port_command(dev, READ_PORT, port, &bitmap);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tdata[1] |= bitmap << port * 8;\n\t}\n\n\treturn insn->n;\n}\n\nstatic int ni6501_cnt_insn_config(struct comedi_device *dev,\n\t\t\t\t  struct comedi_subdevice *s,\n\t\t\t\t  struct comedi_insn *insn,\n\t\t\t\t  unsigned int *data)\n{\n\tint ret;\n\tu32 val = 0;\n\n\tswitch (data[0]) {\n\tcase INSN_CONFIG_ARM:\n\t\tret = ni6501_counter_command(dev, START_COUNTER, NULL);\n\t\tbreak;\n\tcase INSN_CONFIG_DISARM:\n\t\tret = ni6501_counter_command(dev, STOP_COUNTER, NULL);\n\t\tbreak;\n\tcase INSN_CONFIG_RESET:\n\t\tret = ni6501_counter_command(dev, STOP_COUNTER, NULL);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = ni6501_counter_command(dev, WRITE_COUNTER, &val);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret ? ret : insn->n;\n}\n\nstatic int ni6501_cnt_insn_read(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tstruct comedi_insn *insn,\n\t\t\t\tunsigned int *data)\n{\n\tint ret;\n\tu32 val;\n\tunsigned int i;\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\tret = ni6501_counter_command(dev, READ_COUNTER,\t&val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tdata[i] = val;\n\t}\n\n\treturn insn->n;\n}\n\nstatic int ni6501_cnt_insn_write(struct comedi_device *dev,\n\t\t\t\t struct comedi_subdevice *s,\n\t\t\t\t struct comedi_insn *insn,\n\t\t\t\t unsigned int *data)\n{\n\tint ret;\n\n\tif (insn->n) {\n\t\tu32 val = data[insn->n - 1];\n\n\t\tret = ni6501_counter_command(dev, WRITE_COUNTER, &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn insn->n;\n}\n\nstatic int ni6501_alloc_usb_buffers(struct comedi_device *dev)\n{\n\tstruct ni6501_private *devpriv = dev->private;\n\tsize_t size;\n\n\tsize = usb_endpoint_maxp(devpriv->ep_rx);\n\tdevpriv->usb_rx_buf = kzalloc(size, GFP_KERNEL);\n\tif (!devpriv->usb_rx_buf)\n\t\treturn -ENOMEM;\n\n\tsize = usb_endpoint_maxp(devpriv->ep_tx);\n\tdevpriv->usb_tx_buf = kzalloc(size, GFP_KERNEL);\n\tif (!devpriv->usb_tx_buf)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int ni6501_find_endpoints(struct comedi_device *dev)\n{\n\tstruct usb_interface *intf = comedi_to_usb_interface(dev);\n\tstruct ni6501_private *devpriv = dev->private;\n\tstruct usb_host_interface *iface_desc = intf->cur_altsetting;\n\tstruct usb_endpoint_descriptor *ep_desc;\n\tint i;\n\n\tif (iface_desc->desc.bNumEndpoints != 2) {\n\t\tdev_err(dev->class_dev, \"Wrong number of endpoints\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tfor (i = 0; i < iface_desc->desc.bNumEndpoints; i++) {\n\t\tep_desc = &iface_desc->endpoint[i].desc;\n\n\t\tif (usb_endpoint_is_bulk_in(ep_desc)) {\n\t\t\tif (!devpriv->ep_rx)\n\t\t\t\tdevpriv->ep_rx = ep_desc;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (usb_endpoint_is_bulk_out(ep_desc)) {\n\t\t\tif (!devpriv->ep_tx)\n\t\t\t\tdevpriv->ep_tx = ep_desc;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tif (!devpriv->ep_rx || !devpriv->ep_tx)\n\t\treturn -ENODEV;\n\n\tif (usb_endpoint_maxp(devpriv->ep_rx) < RX_MAX_SIZE)\n\t\treturn -ENODEV;\n\n\tif (usb_endpoint_maxp(devpriv->ep_tx) < TX_MAX_SIZE)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic int ni6501_auto_attach(struct comedi_device *dev,\n\t\t\t      unsigned long context)\n{\n\tstruct usb_interface *intf = comedi_to_usb_interface(dev);\n\tstruct ni6501_private *devpriv;\n\tstruct comedi_subdevice *s;\n\tint ret;\n\n\tdevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\n\tif (!devpriv)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&devpriv->mut);\n\tusb_set_intfdata(intf, devpriv);\n\n\tret = ni6501_find_endpoints(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ni6501_alloc_usb_buffers(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = comedi_alloc_subdevices(dev, 2);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ts = &dev->subdevices[0];\n\ts->type\t\t= COMEDI_SUBD_DIO;\n\ts->subdev_flags\t= SDF_READABLE | SDF_WRITABLE;\n\ts->n_chan\t= 24;\n\ts->maxdata\t= 1;\n\ts->range_table\t= &range_digital;\n\ts->insn_bits\t= ni6501_dio_insn_bits;\n\ts->insn_config\t= ni6501_dio_insn_config;\n\n\t \n\ts = &dev->subdevices[1];\n\ts->type\t\t= COMEDI_SUBD_COUNTER;\n\ts->subdev_flags\t= SDF_READABLE | SDF_WRITABLE | SDF_LSAMPL;\n\ts->n_chan\t= 1;\n\ts->maxdata\t= 0xffffffff;\n\ts->insn_read\t= ni6501_cnt_insn_read;\n\ts->insn_write\t= ni6501_cnt_insn_write;\n\ts->insn_config\t= ni6501_cnt_insn_config;\n\n\treturn 0;\n}\n\nstatic void ni6501_detach(struct comedi_device *dev)\n{\n\tstruct usb_interface *intf = comedi_to_usb_interface(dev);\n\tstruct ni6501_private *devpriv = dev->private;\n\n\tif (!devpriv)\n\t\treturn;\n\n\tmutex_destroy(&devpriv->mut);\n\n\tusb_set_intfdata(intf, NULL);\n\n\tkfree(devpriv->usb_rx_buf);\n\tkfree(devpriv->usb_tx_buf);\n}\n\nstatic struct comedi_driver ni6501_driver = {\n\t.module\t\t= THIS_MODULE,\n\t.driver_name\t= \"ni6501\",\n\t.auto_attach\t= ni6501_auto_attach,\n\t.detach\t\t= ni6501_detach,\n};\n\nstatic int ni6501_usb_probe(struct usb_interface *intf,\n\t\t\t    const struct usb_device_id *id)\n{\n\treturn comedi_usb_auto_config(intf, &ni6501_driver, id->driver_info);\n}\n\nstatic const struct usb_device_id ni6501_usb_table[] = {\n\t{ USB_DEVICE(0x3923, 0x718a) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(usb, ni6501_usb_table);\n\nstatic struct usb_driver ni6501_usb_driver = {\n\t.name\t\t= \"ni6501\",\n\t.id_table\t= ni6501_usb_table,\n\t.probe\t\t= ni6501_usb_probe,\n\t.disconnect\t= comedi_usb_auto_unconfig,\n};\nmodule_comedi_usb_driver(ni6501_driver, ni6501_usb_driver);\n\nMODULE_AUTHOR(\"Luca Ellero\");\nMODULE_DESCRIPTION(\"Comedi driver for National Instruments USB-6501\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}