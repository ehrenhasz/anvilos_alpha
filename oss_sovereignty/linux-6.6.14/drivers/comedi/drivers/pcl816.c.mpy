{
  "module_name": "pcl816.c",
  "hash_id": "bb87f4cddaabf59025d80b77b8279739cc6c8c5773f223eabdeb95db9de6c267",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/pcl816.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/interrupt.h>\n#include <linux/comedi/comedidev.h>\n#include <linux/comedi/comedi_8254.h>\n#include <linux/comedi/comedi_isadma.h>\n\n \n#define PCL816_DO_DI_LSB_REG\t\t\t0x00\n#define PCL816_DO_DI_MSB_REG\t\t\t0x01\n#define PCL816_TIMER_BASE\t\t\t0x04\n#define PCL816_AI_LSB_REG\t\t\t0x08\n#define PCL816_AI_MSB_REG\t\t\t0x09\n#define PCL816_RANGE_REG\t\t\t0x09\n#define PCL816_CLRINT_REG\t\t\t0x0a\n#define PCL816_MUX_REG\t\t\t\t0x0b\n#define PCL816_MUX_SCAN(_first, _last)\t\t(((_last) << 4) | (_first))\n#define PCL816_CTRL_REG\t\t\t\t0x0c\n#define PCL816_CTRL_SOFT_TRIG\t\t\tBIT(0)\n#define PCL816_CTRL_PACER_TRIG\t\t\tBIT(1)\n#define PCL816_CTRL_EXT_TRIG\t\t\tBIT(2)\n#define PCL816_CTRL_POE\t\t\t\tBIT(3)\n#define PCL816_CTRL_DMAEN\t\t\tBIT(4)\n#define PCL816_CTRL_INTEN\t\t\tBIT(5)\n#define PCL816_CTRL_DMASRC_SLOT(x)\t\t(((x) & 0x3) << 6)\n#define PCL816_STATUS_REG\t\t\t0x0d\n#define PCL816_STATUS_NEXT_CHAN_MASK\t\t(0xf << 0)\n#define PCL816_STATUS_INTSRC_SLOT(x)\t\t(((x) & 0x3) << 4)\n#define PCL816_STATUS_INTSRC_DMA\t\tPCL816_STATUS_INTSRC_SLOT(3)\n#define PCL816_STATUS_INTSRC_MASK\t\tPCL816_STATUS_INTSRC_SLOT(3)\n#define PCL816_STATUS_INTACT\t\t\tBIT(6)\n#define PCL816_STATUS_DRDY\t\t\tBIT(7)\n\n#define MAGIC_DMA_WORD 0x5a5a\n\nstatic const struct comedi_lrange range_pcl816 = {\n\t8, {\n\t\tBIP_RANGE(10),\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(2.5),\n\t\tBIP_RANGE(1.25),\n\t\tUNI_RANGE(10),\n\t\tUNI_RANGE(5),\n\t\tUNI_RANGE(2.5),\n\t\tUNI_RANGE(1.25)\n\t}\n};\n\nstruct pcl816_board {\n\tconst char *name;\n\tint ai_maxdata;\n\tint ai_chanlist;\n};\n\nstatic const struct pcl816_board boardtypes[] = {\n\t{\n\t\t.name\t\t= \"pcl816\",\n\t\t.ai_maxdata\t= 0xffff,\n\t\t.ai_chanlist\t= 1024,\n\t}, {\n\t\t.name\t\t= \"pcl814b\",\n\t\t.ai_maxdata\t= 0x3fff,\n\t\t.ai_chanlist\t= 1024,\n\t},\n};\n\nstruct pcl816_private {\n\tstruct comedi_isadma *dma;\n\tunsigned int ai_poll_ptr;\t \n\tunsigned int ai_cmd_running:1;\n\tunsigned int ai_cmd_canceled:1;\n};\n\nstatic void pcl816_ai_setup_dma(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tunsigned int unread_samples)\n{\n\tstruct pcl816_private *devpriv = dev->private;\n\tstruct comedi_isadma *dma = devpriv->dma;\n\tstruct comedi_isadma_desc *desc = &dma->desc[dma->cur_dma];\n\tunsigned int max_samples = comedi_bytes_to_samples(s, desc->maxsize);\n\tunsigned int nsamples;\n\n\tcomedi_isadma_disable(dma->chan);\n\n\t \n\tnsamples = comedi_nsamples_left(s, max_samples + unread_samples);\n\tif (nsamples > unread_samples) {\n\t\tnsamples -= unread_samples;\n\t\tdesc->size = comedi_samples_to_bytes(s, nsamples);\n\t\tcomedi_isadma_program(desc);\n\t}\n}\n\nstatic void pcl816_ai_set_chan_range(struct comedi_device *dev,\n\t\t\t\t     unsigned int chan,\n\t\t\t\t     unsigned int range)\n{\n\toutb(chan, dev->iobase + PCL816_MUX_REG);\n\toutb(range, dev->iobase + PCL816_RANGE_REG);\n}\n\nstatic void pcl816_ai_set_chan_scan(struct comedi_device *dev,\n\t\t\t\t    unsigned int first_chan,\n\t\t\t\t    unsigned int last_chan)\n{\n\toutb(PCL816_MUX_SCAN(first_chan, last_chan),\n\t     dev->iobase + PCL816_MUX_REG);\n}\n\nstatic void pcl816_ai_setup_chanlist(struct comedi_device *dev,\n\t\t\t\t     unsigned int *chanlist,\n\t\t\t\t     unsigned int seglen)\n{\n\tunsigned int first_chan = CR_CHAN(chanlist[0]);\n\tunsigned int last_chan;\n\tunsigned int range;\n\tunsigned int i;\n\n\t \n\tfor (i = 0; i < seglen; i++) {\n\t\tlast_chan = CR_CHAN(chanlist[i]);\n\t\trange = CR_RANGE(chanlist[i]);\n\n\t\tpcl816_ai_set_chan_range(dev, last_chan, range);\n\t}\n\n\tudelay(1);\n\n\tpcl816_ai_set_chan_scan(dev, first_chan, last_chan);\n}\n\nstatic void pcl816_ai_clear_eoc(struct comedi_device *dev)\n{\n\t \n\toutb(0, dev->iobase + PCL816_CLRINT_REG);\n}\n\nstatic void pcl816_ai_soft_trig(struct comedi_device *dev)\n{\n\t \n\toutb(0, dev->iobase + PCL816_AI_LSB_REG);\n}\n\nstatic unsigned int pcl816_ai_get_sample(struct comedi_device *dev,\n\t\t\t\t\t struct comedi_subdevice *s)\n{\n\tunsigned int val;\n\n\tval = inb(dev->iobase + PCL816_AI_MSB_REG) << 8;\n\tval |= inb(dev->iobase + PCL816_AI_LSB_REG);\n\n\treturn val & s->maxdata;\n}\n\nstatic int pcl816_ai_eoc(struct comedi_device *dev,\n\t\t\t struct comedi_subdevice *s,\n\t\t\t struct comedi_insn *insn,\n\t\t\t unsigned long context)\n{\n\tunsigned int status;\n\n\tstatus = inb(dev->iobase + PCL816_STATUS_REG);\n\tif ((status & PCL816_STATUS_DRDY) == 0)\n\t\treturn 0;\n\treturn -EBUSY;\n}\n\nstatic bool pcl816_ai_next_chan(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s)\n{\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\n\tif (cmd->stop_src == TRIG_COUNT &&\n\t    s->async->scans_done >= cmd->stop_arg) {\n\t\ts->async->events |= COMEDI_CB_EOA;\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void transfer_from_dma_buf(struct comedi_device *dev,\n\t\t\t\t  struct comedi_subdevice *s,\n\t\t\t\t  unsigned short *ptr,\n\t\t\t\t  unsigned int bufptr, unsigned int len)\n{\n\tunsigned short val;\n\tint i;\n\n\tfor (i = 0; i < len; i++) {\n\t\tval = ptr[bufptr++];\n\t\tcomedi_buf_write_samples(s, &val, 1);\n\n\t\tif (!pcl816_ai_next_chan(dev, s))\n\t\t\treturn;\n\t}\n}\n\nstatic irqreturn_t pcl816_interrupt(int irq, void *d)\n{\n\tstruct comedi_device *dev = d;\n\tstruct comedi_subdevice *s = dev->read_subdev;\n\tstruct pcl816_private *devpriv = dev->private;\n\tstruct comedi_isadma *dma = devpriv->dma;\n\tstruct comedi_isadma_desc *desc = &dma->desc[dma->cur_dma];\n\tunsigned int nsamples;\n\tunsigned int bufptr;\n\n\tif (!dev->attached || !devpriv->ai_cmd_running) {\n\t\tpcl816_ai_clear_eoc(dev);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (devpriv->ai_cmd_canceled) {\n\t\tdevpriv->ai_cmd_canceled = 0;\n\t\tpcl816_ai_clear_eoc(dev);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tnsamples = comedi_bytes_to_samples(s, desc->size) -\n\t\t   devpriv->ai_poll_ptr;\n\tbufptr = devpriv->ai_poll_ptr;\n\tdevpriv->ai_poll_ptr = 0;\n\n\t \n\tdma->cur_dma = 1 - dma->cur_dma;\n\tpcl816_ai_setup_dma(dev, s, nsamples);\n\n\ttransfer_from_dma_buf(dev, s, desc->virt_addr, bufptr, nsamples);\n\n\tpcl816_ai_clear_eoc(dev);\n\n\tcomedi_handle_events(dev, s);\n\treturn IRQ_HANDLED;\n}\n\nstatic int check_channel_list(struct comedi_device *dev,\n\t\t\t      struct comedi_subdevice *s,\n\t\t\t      unsigned int *chanlist,\n\t\t\t      unsigned int chanlen)\n{\n\tunsigned int chansegment[16];\n\tunsigned int i, nowmustbechan, seglen;\n\n\t \n\tif (chanlen < 1) {\n\t\tdev_err(dev->class_dev, \"range/channel list is empty!\\n\");\n\t\treturn 0;\n\t}\n\n\tif (chanlen > 1) {\n\t\t \n\t\tchansegment[0] = chanlist[0];\n\t\tfor (i = 1, seglen = 1; i < chanlen; i++, seglen++) {\n\t\t\t \n\t\t\tif (chanlist[0] == chanlist[i])\n\t\t\t\tbreak;\n\t\t\tnowmustbechan =\n\t\t\t    (CR_CHAN(chansegment[i - 1]) + 1) % chanlen;\n\t\t\tif (nowmustbechan != CR_CHAN(chanlist[i])) {\n\t\t\t\t \n\t\t\t\tdev_dbg(dev->class_dev,\n\t\t\t\t\t\"channel list must be continuous! chanlist[%i]=%d but must be %d or %d!\\n\",\n\t\t\t\t\ti, CR_CHAN(chanlist[i]), nowmustbechan,\n\t\t\t\t\tCR_CHAN(chanlist[0]));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t \n\t\t\tchansegment[i] = chanlist[i];\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < chanlen; i++) {\n\t\t\tif (chanlist[i] != chansegment[i % seglen]) {\n\t\t\t\tdev_dbg(dev->class_dev,\n\t\t\t\t\t\"bad channel or range number! chanlist[%i]=%d,%d,%d and not %d,%d,%d!\\n\",\n\t\t\t\t\ti, CR_CHAN(chansegment[i]),\n\t\t\t\t\tCR_RANGE(chansegment[i]),\n\t\t\t\t\tCR_AREF(chansegment[i]),\n\t\t\t\t\tCR_CHAN(chanlist[i % seglen]),\n\t\t\t\t\tCR_RANGE(chanlist[i % seglen]),\n\t\t\t\t\tCR_AREF(chansegment[i % seglen]));\n\t\t\t\treturn 0;\t \n\t\t\t}\n\t\t}\n\t} else {\n\t\tseglen = 1;\n\t}\n\n\treturn seglen;\t \n}\n\nstatic int pcl816_ai_cmdtest(struct comedi_device *dev,\n\t\t\t     struct comedi_subdevice *s, struct comedi_cmd *cmd)\n{\n\tint err = 0;\n\n\t \n\n\terr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW);\n\terr |= comedi_check_trigger_src(&cmd->scan_begin_src, TRIG_FOLLOW);\n\terr |= comedi_check_trigger_src(&cmd->convert_src,\n\t\t\t\t\tTRIG_EXT | TRIG_TIMER);\n\terr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\n\terr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\n\n\tif (err)\n\t\treturn 1;\n\n\t \n\n\terr |= comedi_check_trigger_is_unique(cmd->convert_src);\n\terr |= comedi_check_trigger_is_unique(cmd->stop_src);\n\n\t \n\n\tif (err)\n\t\treturn 2;\n\n\t \n\n\terr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);\n\n\tif (cmd->convert_src == TRIG_TIMER)\n\t\terr |= comedi_check_trigger_arg_min(&cmd->convert_arg, 10000);\n\telse\t \n\t\terr |= comedi_check_trigger_arg_is(&cmd->convert_arg, 0);\n\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\n\t\t\t\t\t   cmd->chanlist_len);\n\n\tif (cmd->stop_src == TRIG_COUNT)\n\t\terr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\n\telse\t \n\t\terr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\n\n\tif (err)\n\t\treturn 3;\n\n\t \n\tif (cmd->convert_src == TRIG_TIMER) {\n\t\tunsigned int arg = cmd->convert_arg;\n\n\t\tcomedi_8254_cascade_ns_to_timer(dev->pacer, &arg, cmd->flags);\n\t\terr |= comedi_check_trigger_arg_is(&cmd->convert_arg, arg);\n\t}\n\n\tif (err)\n\t\treturn 4;\n\n\t \n\n\tif (cmd->chanlist) {\n\t\tif (!check_channel_list(dev, s, cmd->chanlist,\n\t\t\t\t\tcmd->chanlist_len))\n\t\t\treturn 5;\t \n\t}\n\n\treturn 0;\n}\n\nstatic int pcl816_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\n{\n\tstruct pcl816_private *devpriv = dev->private;\n\tstruct comedi_isadma *dma = devpriv->dma;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tunsigned int ctrl;\n\tunsigned int seglen;\n\n\tif (devpriv->ai_cmd_running)\n\t\treturn -EBUSY;\n\n\tseglen = check_channel_list(dev, s, cmd->chanlist, cmd->chanlist_len);\n\tif (seglen < 1)\n\t\treturn -EINVAL;\n\tpcl816_ai_setup_chanlist(dev, cmd->chanlist, seglen);\n\tudelay(1);\n\n\tdevpriv->ai_cmd_running = 1;\n\tdevpriv->ai_poll_ptr = 0;\n\tdevpriv->ai_cmd_canceled = 0;\n\n\t \n\tdma->cur_dma = 0;\n\tpcl816_ai_setup_dma(dev, s, 0);\n\n\tcomedi_8254_set_mode(dev->pacer, 0, I8254_MODE1 | I8254_BINARY);\n\tcomedi_8254_write(dev->pacer, 0, 0x0ff);\n\tudelay(1);\n\tcomedi_8254_update_divisors(dev->pacer);\n\tcomedi_8254_pacer_enable(dev->pacer, 1, 2, true);\n\n\tctrl = PCL816_CTRL_INTEN | PCL816_CTRL_DMAEN |\n\t       PCL816_CTRL_DMASRC_SLOT(0);\n\tif (cmd->convert_src == TRIG_TIMER)\n\t\tctrl |= PCL816_CTRL_PACER_TRIG;\n\telse\t \n\t\tctrl |= PCL816_CTRL_EXT_TRIG;\n\n\toutb(ctrl, dev->iobase + PCL816_CTRL_REG);\n\toutb((dma->chan << 4) | dev->irq,\n\t     dev->iobase + PCL816_STATUS_REG);\n\n\treturn 0;\n}\n\nstatic int pcl816_ai_poll(struct comedi_device *dev, struct comedi_subdevice *s)\n{\n\tstruct pcl816_private *devpriv = dev->private;\n\tstruct comedi_isadma *dma = devpriv->dma;\n\tstruct comedi_isadma_desc *desc;\n\tunsigned long flags;\n\tunsigned int poll;\n\tint ret;\n\n\tspin_lock_irqsave(&dev->spinlock, flags);\n\n\tpoll = comedi_isadma_poll(dma);\n\tpoll = comedi_bytes_to_samples(s, poll);\n\tif (poll > devpriv->ai_poll_ptr) {\n\t\tdesc = &dma->desc[dma->cur_dma];\n\t\ttransfer_from_dma_buf(dev, s, desc->virt_addr,\n\t\t\t\t      devpriv->ai_poll_ptr,\n\t\t\t\t      poll - devpriv->ai_poll_ptr);\n\t\t \n\t\tdevpriv->ai_poll_ptr = poll;\n\n\t\tcomedi_handle_events(dev, s);\n\n\t\tret = comedi_buf_n_bytes_ready(s);\n\t} else {\n\t\t \n\t\tret = 0;\n\t}\n\tspin_unlock_irqrestore(&dev->spinlock, flags);\n\n\treturn ret;\n}\n\nstatic int pcl816_ai_cancel(struct comedi_device *dev,\n\t\t\t    struct comedi_subdevice *s)\n{\n\tstruct pcl816_private *devpriv = dev->private;\n\n\tif (!devpriv->ai_cmd_running)\n\t\treturn 0;\n\n\toutb(0, dev->iobase + PCL816_CTRL_REG);\n\tpcl816_ai_clear_eoc(dev);\n\n\tcomedi_8254_pacer_enable(dev->pacer, 1, 2, false);\n\n\tdevpriv->ai_cmd_running = 0;\n\tdevpriv->ai_cmd_canceled = 1;\n\n\treturn 0;\n}\n\nstatic int pcl816_ai_insn_read(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       struct comedi_insn *insn,\n\t\t\t       unsigned int *data)\n{\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int range = CR_RANGE(insn->chanspec);\n\tint ret = 0;\n\tint i;\n\n\toutb(PCL816_CTRL_SOFT_TRIG, dev->iobase + PCL816_CTRL_REG);\n\n\tpcl816_ai_set_chan_range(dev, chan, range);\n\tpcl816_ai_set_chan_scan(dev, chan, chan);\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\tpcl816_ai_clear_eoc(dev);\n\t\tpcl816_ai_soft_trig(dev);\n\n\t\tret = comedi_timeout(dev, s, insn, pcl816_ai_eoc, 0);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tdata[i] = pcl816_ai_get_sample(dev, s);\n\t}\n\toutb(0, dev->iobase + PCL816_CTRL_REG);\n\tpcl816_ai_clear_eoc(dev);\n\n\treturn ret ? ret : insn->n;\n}\n\nstatic int pcl816_di_insn_bits(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       struct comedi_insn *insn,\n\t\t\t       unsigned int *data)\n{\n\tdata[1] = inb(dev->iobase + PCL816_DO_DI_LSB_REG) |\n\t\t  (inb(dev->iobase + PCL816_DO_DI_MSB_REG) << 8);\n\n\treturn insn->n;\n}\n\nstatic int pcl816_do_insn_bits(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       struct comedi_insn *insn,\n\t\t\t       unsigned int *data)\n{\n\tif (comedi_dio_update_state(s, data)) {\n\t\toutb(s->state & 0xff, dev->iobase + PCL816_DO_DI_LSB_REG);\n\t\toutb((s->state >> 8), dev->iobase + PCL816_DO_DI_MSB_REG);\n\t}\n\n\tdata[1] = s->state;\n\n\treturn insn->n;\n}\n\nstatic void pcl816_reset(struct comedi_device *dev)\n{\n\toutb(0, dev->iobase + PCL816_CTRL_REG);\n\tpcl816_ai_set_chan_range(dev, 0, 0);\n\tpcl816_ai_clear_eoc(dev);\n\n\t \n\toutb(0, dev->iobase + PCL816_DO_DI_LSB_REG);\n\toutb(0, dev->iobase + PCL816_DO_DI_MSB_REG);\n}\n\nstatic void pcl816_alloc_irq_and_dma(struct comedi_device *dev,\n\t\t\t\t     struct comedi_devconfig *it)\n{\n\tstruct pcl816_private *devpriv = dev->private;\n\tunsigned int irq_num = it->options[1];\n\tunsigned int dma_chan = it->options[2];\n\n\t \n\tif (!(irq_num >= 2 && irq_num <= 7) ||\n\t    !(dma_chan == 3 || dma_chan == 1))\n\t\treturn;\n\n\tif (request_irq(irq_num, pcl816_interrupt, 0, dev->board_name, dev))\n\t\treturn;\n\n\t \n\tdevpriv->dma = comedi_isadma_alloc(dev, 2, dma_chan, dma_chan,\n\t\t\t\t\t   PAGE_SIZE * 4, COMEDI_ISADMA_READ);\n\tif (!devpriv->dma)\n\t\tfree_irq(irq_num, dev);\n\telse\n\t\tdev->irq = irq_num;\n}\n\nstatic void pcl816_free_dma(struct comedi_device *dev)\n{\n\tstruct pcl816_private *devpriv = dev->private;\n\n\tif (devpriv)\n\t\tcomedi_isadma_free(devpriv->dma);\n}\n\nstatic int pcl816_attach(struct comedi_device *dev, struct comedi_devconfig *it)\n{\n\tconst struct pcl816_board *board = dev->board_ptr;\n\tstruct pcl816_private *devpriv;\n\tstruct comedi_subdevice *s;\n\tint ret;\n\n\tdevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\n\tif (!devpriv)\n\t\treturn -ENOMEM;\n\n\tret = comedi_request_region(dev, it->options[0], 0x10);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tpcl816_alloc_irq_and_dma(dev, it);\n\n\tdev->pacer = comedi_8254_init(dev->iobase + PCL816_TIMER_BASE,\n\t\t\t\t      I8254_OSC_BASE_10MHZ, I8254_IO8, 0);\n\tif (!dev->pacer)\n\t\treturn -ENOMEM;\n\n\tret = comedi_alloc_subdevices(dev, 4);\n\tif (ret)\n\t\treturn ret;\n\n\ts = &dev->subdevices[0];\n\ts->type\t\t= COMEDI_SUBD_AI;\n\ts->subdev_flags\t= SDF_CMD_READ | SDF_DIFF;\n\ts->n_chan\t= 16;\n\ts->maxdata\t= board->ai_maxdata;\n\ts->range_table\t= &range_pcl816;\n\ts->insn_read\t= pcl816_ai_insn_read;\n\tif (dev->irq) {\n\t\tdev->read_subdev = s;\n\t\ts->subdev_flags\t|= SDF_CMD_READ;\n\t\ts->len_chanlist\t= board->ai_chanlist;\n\t\ts->do_cmdtest\t= pcl816_ai_cmdtest;\n\t\ts->do_cmd\t= pcl816_ai_cmd;\n\t\ts->poll\t\t= pcl816_ai_poll;\n\t\ts->cancel\t= pcl816_ai_cancel;\n\t}\n\n\t \n\ts = &dev->subdevices[1];\n\ts->type\t\t= COMEDI_SUBD_UNUSED;\n\n\t \n\ts = &dev->subdevices[2];\n\ts->type\t\t= COMEDI_SUBD_DI;\n\ts->subdev_flags\t= SDF_READABLE;\n\ts->n_chan\t= 16;\n\ts->maxdata\t= 1;\n\ts->range_table\t= &range_digital;\n\ts->insn_bits\t= pcl816_di_insn_bits;\n\n\t \n\ts = &dev->subdevices[3];\n\ts->type\t\t= COMEDI_SUBD_DO;\n\ts->subdev_flags\t= SDF_WRITABLE;\n\ts->n_chan\t= 16;\n\ts->maxdata\t= 1;\n\ts->range_table\t= &range_digital;\n\ts->insn_bits\t= pcl816_do_insn_bits;\n\n\tpcl816_reset(dev);\n\n\treturn 0;\n}\n\nstatic void pcl816_detach(struct comedi_device *dev)\n{\n\tif (dev->private) {\n\t\tpcl816_ai_cancel(dev, dev->read_subdev);\n\t\tpcl816_reset(dev);\n\t}\n\tpcl816_free_dma(dev);\n\tcomedi_legacy_detach(dev);\n}\n\nstatic struct comedi_driver pcl816_driver = {\n\t.driver_name\t= \"pcl816\",\n\t.module\t\t= THIS_MODULE,\n\t.attach\t\t= pcl816_attach,\n\t.detach\t\t= pcl816_detach,\n\t.board_name\t= &boardtypes[0].name,\n\t.num_names\t= ARRAY_SIZE(boardtypes),\n\t.offset\t\t= sizeof(struct pcl816_board),\n};\nmodule_comedi_driver(pcl816_driver);\n\nMODULE_AUTHOR(\"Comedi https://www.comedi.org\");\nMODULE_DESCRIPTION(\"Comedi low-level driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}