{
  "module_name": "dt2811.c",
  "hash_id": "777bc03c28d31dc1e2da3912956b11b7f68d30c565fbc3f3063dfe653076709f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/dt2811.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/comedi/comedidev.h>\n\n \n#define DT2811_ADCSR_REG\t\t0x00\t \n#define DT2811_ADCSR_ADDONE\t\tBIT(7)\t \n#define DT2811_ADCSR_ADERROR\t\tBIT(6)\t \n#define DT2811_ADCSR_ADBUSY\t\tBIT(5)\t \n#define DT2811_ADCSR_CLRERROR\t\tBIT(4)\n#define DT2811_ADCSR_DMAENB\t\tBIT(3)\t \n#define DT2811_ADCSR_INTENB\t\tBIT(2)\t \n#define DT2811_ADCSR_ADMODE(x)\t\t(((x) & 0x3) << 0)\n\n#define DT2811_ADGCR_REG\t\t0x01\t \n#define DT2811_ADGCR_GAIN(x)\t\t(((x) & 0x3) << 6)\n#define DT2811_ADGCR_CHAN(x)\t\t(((x) & 0xf) << 0)\n\n#define DT2811_ADDATA_LO_REG\t\t0x02\t \n#define DT2811_ADDATA_HI_REG\t\t0x03\t \n\n#define DT2811_DADATA_LO_REG(x)\t\t(0x02 + ((x) * 2))  \n#define DT2811_DADATA_HI_REG(x)\t\t(0x03 + ((x) * 2))  \n\n#define DT2811_DI_REG\t\t\t0x06\t \n#define DT2811_DO_REG\t\t\t0x06\t \n\n#define DT2811_TMRCTR_REG\t\t0x07\t \n#define DT2811_TMRCTR_MANTISSA(x)\t(((x) & 0x7) << 3)\n#define DT2811_TMRCTR_EXPONENT(x)\t(((x) & 0x7) << 0)\n\n#define DT2811_OSC_BASE\t\t\t1666\t \n\n \nstatic const unsigned int dt2811_clk_dividers[] = {\n\t1, 10, 2, 3, 4, 5, 6, 12\n};\n\nstatic const unsigned int dt2811_clk_multipliers[] = {\n\t1, 10, 100, 1000, 10000, 100000, 1000000, 10000000\n};\n\n \nstatic const struct comedi_lrange dt2811_pgh_ai_ranges = {\n\t12, {\n\t\tBIP_RANGE(5),\t\t \n\t\tBIP_RANGE(2.5),\t\t \n\t\tBIP_RANGE(1.25),\t \n\t\tBIP_RANGE(0.625),\t \n\n\t\tBIP_RANGE(2.5),\t\t \n\t\tBIP_RANGE(1.25),\t \n\t\tBIP_RANGE(0.625),\t \n\t\tBIP_RANGE(0.3125),\t \n\n\t\tUNI_RANGE(5),\t\t \n\t\tUNI_RANGE(2.5),\t\t \n\t\tUNI_RANGE(1.25),\t \n\t\tUNI_RANGE(0.625)\t \n\t}\n};\n\nstatic const struct comedi_lrange dt2811_pgl_ai_ranges = {\n\t12, {\n\t\tBIP_RANGE(5),\t\t \n\t\tBIP_RANGE(0.5),\t\t \n\t\tBIP_RANGE(0.05),\t \n\t\tBIP_RANGE(0.01),\t \n\n\t\tBIP_RANGE(2.5),\t\t \n\t\tBIP_RANGE(0.25),\t \n\t\tBIP_RANGE(0.025),\t \n\t\tBIP_RANGE(0.005),\t \n\n\t\tUNI_RANGE(5),\t\t \n\t\tUNI_RANGE(0.5),\t\t \n\t\tUNI_RANGE(0.05),\t \n\t\tUNI_RANGE(0.01)\t\t \n\t}\n};\n\n \nstatic const struct comedi_lrange dt2811_ao_ranges = {\n\t3, {\n\t\tBIP_RANGE(5),\t \n\t\tBIP_RANGE(2.5),\n\t\tUNI_RANGE(5)\n\t}\n};\n\nstruct dt2811_board {\n\tconst char *name;\n\tunsigned int is_pgh:1;\n};\n\nstatic const struct dt2811_board dt2811_boards[] = {\n\t{\n\t\t.name\t\t= \"dt2811-pgh\",\n\t\t.is_pgh\t\t= 1,\n\t}, {\n\t\t.name\t\t= \"dt2811-pgl\",\n\t},\n};\n\nstruct dt2811_private {\n\tunsigned int ai_divisor;\n};\n\nstatic unsigned int dt2811_ai_read_sample(struct comedi_device *dev,\n\t\t\t\t\t  struct comedi_subdevice *s)\n{\n\tunsigned int val;\n\n\tval = inb(dev->iobase + DT2811_ADDATA_LO_REG) |\n\t      (inb(dev->iobase + DT2811_ADDATA_HI_REG) << 8);\n\n\treturn val & s->maxdata;\n}\n\nstatic irqreturn_t dt2811_interrupt(int irq, void *d)\n{\n\tstruct comedi_device *dev = d;\n\tstruct comedi_subdevice *s = dev->read_subdev;\n\tstruct comedi_async *async = s->async;\n\tstruct comedi_cmd *cmd = &async->cmd;\n\tunsigned int status;\n\n\tif (!dev->attached)\n\t\treturn IRQ_NONE;\n\n\tstatus = inb(dev->iobase + DT2811_ADCSR_REG);\n\n\tif (status & DT2811_ADCSR_ADERROR) {\n\t\tasync->events |= COMEDI_CB_OVERFLOW;\n\n\t\toutb(status | DT2811_ADCSR_CLRERROR,\n\t\t     dev->iobase + DT2811_ADCSR_REG);\n\t}\n\n\tif (status & DT2811_ADCSR_ADDONE) {\n\t\tunsigned short val;\n\n\t\tval = dt2811_ai_read_sample(dev, s);\n\t\tcomedi_buf_write_samples(s, &val, 1);\n\t}\n\n\tif (cmd->stop_src == TRIG_COUNT && async->scans_done >= cmd->stop_arg)\n\t\tasync->events |= COMEDI_CB_EOA;\n\n\tcomedi_handle_events(dev, s);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int dt2811_ai_cancel(struct comedi_device *dev,\n\t\t\t    struct comedi_subdevice *s)\n{\n\t \n\toutb(DT2811_ADCSR_ADMODE(0), dev->iobase + DT2811_ADCSR_REG);\n\n\treturn 0;\n}\n\nstatic void dt2811_ai_set_chanspec(struct comedi_device *dev,\n\t\t\t\t   unsigned int chanspec)\n{\n\tunsigned int chan = CR_CHAN(chanspec);\n\tunsigned int range = CR_RANGE(chanspec);\n\n\toutb(DT2811_ADGCR_CHAN(chan) | DT2811_ADGCR_GAIN(range),\n\t     dev->iobase + DT2811_ADGCR_REG);\n}\n\nstatic int dt2811_ai_cmd(struct comedi_device *dev,\n\t\t\t struct comedi_subdevice *s)\n{\n\tstruct dt2811_private *devpriv = dev->private;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tunsigned int mode;\n\n\tif (cmd->start_src == TRIG_NOW) {\n\t\t \n\t\tmode = DT2811_ADCSR_ADMODE(1);\n\t} else {  \n\t\tif (cmd->convert_src == TRIG_TIMER) {\n\t\t\t \n\t\t\tmode = DT2811_ADCSR_ADMODE(2);\n\t\t} else {  \n\t\t\t \n\t\t\tmode = DT2811_ADCSR_ADMODE(3);\n\t\t}\n\t}\n\toutb(mode | DT2811_ADCSR_INTENB, dev->iobase + DT2811_ADCSR_REG);\n\n\t \n\toutb(devpriv->ai_divisor, dev->iobase + DT2811_TMRCTR_REG);\n\n\t \n\tdt2811_ai_set_chanspec(dev, cmd->chanlist[0]);\n\n\treturn 0;\n}\n\nstatic unsigned int dt2811_ns_to_timer(unsigned int *nanosec,\n\t\t\t\t       unsigned int flags)\n{\n\tunsigned long long ns;\n\tunsigned int ns_lo = COMEDI_MIN_SPEED;\n\tunsigned int ns_hi = 0;\n\tunsigned int divisor_hi = 0;\n\tunsigned int divisor_lo = 0;\n\tunsigned int _div;\n\tunsigned int _mult;\n\n\t \n\tfor (_div = 0; _div <= 7; _div++) {\n\t\tfor (_mult = 0; _mult <= 7; _mult++) {\n\t\t\tunsigned int div = dt2811_clk_dividers[_div];\n\t\t\tunsigned int mult = dt2811_clk_multipliers[_mult];\n\t\t\tunsigned long long divider = div * mult;\n\t\t\tunsigned int divisor = DT2811_TMRCTR_MANTISSA(_div) |\n\t\t\t\t\t       DT2811_TMRCTR_EXPONENT(_mult);\n\n\t\t\t \n\t\t\tns = divider * DT2811_OSC_BASE;\n\t\t\tif (ns > COMEDI_MIN_SPEED)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (ns <= *nanosec && ns > ns_hi) {\n\t\t\t\tns_hi = ns;\n\t\t\t\tdivisor_hi = divisor;\n\t\t\t}\n\t\t\t \n\t\t\tif (ns >= *nanosec && ns < ns_lo) {\n\t\t\t\tns_lo = ns;\n\t\t\t\tdivisor_lo = divisor;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (ns_lo == COMEDI_MIN_SPEED) {\n\t\tns_lo = ns_hi;\n\t\tdivisor_lo = divisor_hi;\n\t}\n\t \n\tif (ns_hi == 0) {\n\t\tns_hi = ns_lo;\n\t\tdivisor_hi = divisor_lo;\n\t}\n\n\tswitch (flags & CMDF_ROUND_MASK) {\n\tcase CMDF_ROUND_NEAREST:\n\tdefault:\n\t\tif (ns_hi - *nanosec < *nanosec - ns_lo) {\n\t\t\t*nanosec = ns_lo;\n\t\t\treturn divisor_lo;\n\t\t}\n\t\t*nanosec = ns_hi;\n\t\treturn divisor_hi;\n\tcase CMDF_ROUND_UP:\n\t\t*nanosec = ns_lo;\n\t\treturn divisor_lo;\n\tcase CMDF_ROUND_DOWN:\n\t\t*nanosec = ns_hi;\n\t\treturn divisor_hi;\n\t}\n}\n\nstatic int dt2811_ai_cmdtest(struct comedi_device *dev,\n\t\t\t     struct comedi_subdevice *s,\n\t\t\t     struct comedi_cmd *cmd)\n{\n\tstruct dt2811_private *devpriv = dev->private;\n\tunsigned int arg;\n\tint err = 0;\n\n\t \n\n\terr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_EXT);\n\terr |= comedi_check_trigger_src(&cmd->scan_begin_src, TRIG_FOLLOW);\n\terr |= comedi_check_trigger_src(&cmd->convert_src,\n\t\t\t\t\tTRIG_TIMER | TRIG_EXT);\n\terr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\n\terr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\n\n\tif (err)\n\t\treturn 1;\n\n\t \n\n\terr |= comedi_check_trigger_is_unique(cmd->start_src);\n\terr |= comedi_check_trigger_is_unique(cmd->convert_src);\n\terr |= comedi_check_trigger_is_unique(cmd->stop_src);\n\n\t \n\n\tif (cmd->convert_src == TRIG_EXT && cmd->start_src != TRIG_EXT)\n\t\terr |= -EINVAL;\n\n\tif (err)\n\t\treturn 2;\n\n\t \n\n\terr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);\n\tif (cmd->convert_src == TRIG_TIMER)\n\t\terr |= comedi_check_trigger_arg_min(&cmd->convert_arg, 12500);\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\n\t\t\t\t\t   cmd->chanlist_len);\n\tif (cmd->stop_src == TRIG_COUNT)\n\t\terr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\n\telse\t \n\t\terr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\n\n\tif (err)\n\t\treturn 3;\n\n\t \n\n\tif (cmd->convert_src == TRIG_TIMER) {\n\t\targ = cmd->convert_arg;\n\t\tdevpriv->ai_divisor = dt2811_ns_to_timer(&arg, cmd->flags);\n\t\terr |= comedi_check_trigger_arg_is(&cmd->convert_arg, arg);\n\t} else {  \n\t\t \n\t\tdevpriv->ai_divisor = cmd->convert_arg;\n\t}\n\n\tif (err)\n\t\treturn 4;\n\n\t \n\n\treturn 0;\n}\n\nstatic int dt2811_ai_eoc(struct comedi_device *dev,\n\t\t\t struct comedi_subdevice *s,\n\t\t\t struct comedi_insn *insn,\n\t\t\t unsigned long context)\n{\n\tunsigned int status;\n\n\tstatus = inb(dev->iobase + DT2811_ADCSR_REG);\n\tif ((status & DT2811_ADCSR_ADBUSY) == 0)\n\t\treturn 0;\n\treturn -EBUSY;\n}\n\nstatic int dt2811_ai_insn_read(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       struct comedi_insn *insn,\n\t\t\t       unsigned int *data)\n{\n\tint ret;\n\tint i;\n\n\t \n\tfor (i = 0; i < insn->n; i++) {\n\t\t \n\t\tdt2811_ai_set_chanspec(dev, insn->chanspec);\n\n\t\tret = comedi_timeout(dev, s, insn, dt2811_ai_eoc, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdata[i] = dt2811_ai_read_sample(dev, s);\n\t}\n\n\treturn insn->n;\n}\n\nstatic int dt2811_ao_insn_write(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tstruct comedi_insn *insn,\n\t\t\t\tunsigned int *data)\n{\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int val = s->readback[chan];\n\tint i;\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\tval = data[i];\n\t\toutb(val & 0xff, dev->iobase + DT2811_DADATA_LO_REG(chan));\n\t\toutb((val >> 8) & 0xff,\n\t\t     dev->iobase + DT2811_DADATA_HI_REG(chan));\n\t}\n\ts->readback[chan] = val;\n\n\treturn insn->n;\n}\n\nstatic int dt2811_di_insn_bits(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       struct comedi_insn *insn,\n\t\t\t       unsigned int *data)\n{\n\tdata[1] = inb(dev->iobase + DT2811_DI_REG);\n\n\treturn insn->n;\n}\n\nstatic int dt2811_do_insn_bits(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       struct comedi_insn *insn,\n\t\t\t       unsigned int *data)\n{\n\tif (comedi_dio_update_state(s, data))\n\t\toutb(s->state, dev->iobase + DT2811_DO_REG);\n\n\tdata[1] = s->state;\n\n\treturn insn->n;\n}\n\nstatic void dt2811_reset(struct comedi_device *dev)\n{\n\t \n\toutb(DT2811_ADCSR_ADMODE(0), dev->iobase + DT2811_ADCSR_REG);\n\tusleep_range(100, 1000);\n\tinb(dev->iobase + DT2811_ADDATA_LO_REG);\n\tinb(dev->iobase + DT2811_ADDATA_HI_REG);\n\toutb(DT2811_ADCSR_ADMODE(0) | DT2811_ADCSR_CLRERROR,\n\t     dev->iobase + DT2811_ADCSR_REG);\n}\n\nstatic int dt2811_attach(struct comedi_device *dev, struct comedi_devconfig *it)\n{\n\tconst struct dt2811_board *board = dev->board_ptr;\n\tstruct dt2811_private *devpriv;\n\tstruct comedi_subdevice *s;\n\tint ret;\n\n\tdevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\n\tif (!devpriv)\n\t\treturn -ENOMEM;\n\n\tret = comedi_request_region(dev, it->options[0], 0x8);\n\tif (ret)\n\t\treturn ret;\n\n\tdt2811_reset(dev);\n\n\t \n\tif (it->options[1] <= 7  && (BIT(it->options[1]) & 0xac)) {\n\t\tret = request_irq(it->options[1], dt2811_interrupt, 0,\n\t\t\t\t  dev->board_name, dev);\n\t\tif (ret == 0)\n\t\t\tdev->irq = it->options[1];\n\t}\n\n\tret = comedi_alloc_subdevices(dev, 4);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ts = &dev->subdevices[0];\n\ts->type\t\t= COMEDI_SUBD_AI;\n\ts->subdev_flags\t= SDF_READABLE |\n\t\t\t  ((it->options[2] == 1) ? SDF_DIFF :\n\t\t\t   (it->options[2] == 2) ? SDF_COMMON : SDF_GROUND);\n\ts->n_chan\t= (it->options[2] == 1) ? 8 : 16;\n\ts->maxdata\t= 0x0fff;\n\ts->range_table\t= board->is_pgh ? &dt2811_pgh_ai_ranges\n\t\t\t\t\t: &dt2811_pgl_ai_ranges;\n\ts->insn_read\t= dt2811_ai_insn_read;\n\tif (dev->irq) {\n\t\tdev->read_subdev = s;\n\t\ts->subdev_flags\t|= SDF_CMD_READ;\n\t\ts->len_chanlist\t= 1;\n\t\ts->do_cmdtest\t= dt2811_ai_cmdtest;\n\t\ts->do_cmd\t= dt2811_ai_cmd;\n\t\ts->cancel\t= dt2811_ai_cancel;\n\t}\n\n\t \n\ts = &dev->subdevices[1];\n\ts->type\t\t= COMEDI_SUBD_AO;\n\ts->subdev_flags\t= SDF_WRITABLE;\n\ts->n_chan\t= 2;\n\ts->maxdata\t= 0x0fff;\n\ts->range_table\t= &dt2811_ao_ranges;\n\ts->insn_write\t= dt2811_ao_insn_write;\n\n\tret = comedi_alloc_subdev_readback(s);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ts = &dev->subdevices[2];\n\ts->type\t\t= COMEDI_SUBD_DI;\n\ts->subdev_flags\t= SDF_READABLE;\n\ts->n_chan\t= 8;\n\ts->maxdata\t= 1;\n\ts->range_table\t= &range_digital;\n\ts->insn_bits\t= dt2811_di_insn_bits;\n\n\t \n\ts = &dev->subdevices[3];\n\ts->type\t\t= COMEDI_SUBD_DO;\n\ts->subdev_flags\t= SDF_WRITABLE;\n\ts->n_chan\t= 8;\n\ts->maxdata\t= 1;\n\ts->range_table\t= &range_digital;\n\ts->insn_bits\t= dt2811_do_insn_bits;\n\n\treturn 0;\n}\n\nstatic struct comedi_driver dt2811_driver = {\n\t.driver_name\t= \"dt2811\",\n\t.module\t\t= THIS_MODULE,\n\t.attach\t\t= dt2811_attach,\n\t.detach\t\t= comedi_legacy_detach,\n\t.board_name\t= &dt2811_boards[0].name,\n\t.num_names\t= ARRAY_SIZE(dt2811_boards),\n\t.offset\t\t= sizeof(struct dt2811_board),\n};\nmodule_comedi_driver(dt2811_driver);\n\nMODULE_AUTHOR(\"Comedi https://www.comedi.org\");\nMODULE_DESCRIPTION(\"Comedi driver for Data Translation DT2811 series boards\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}