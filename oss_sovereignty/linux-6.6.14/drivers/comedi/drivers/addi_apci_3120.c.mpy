{
  "module_name": "addi_apci_3120.c",
  "hash_id": "8c54d1a848596b5c5a2df3cf725200256d8a29205af594662f424776847a67ec",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/addi_apci_3120.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/comedi/comedi_pci.h>\n\n#include \"amcc_s5933.h\"\n\n \n#define APCI3120_FIFO_ADVANCE_ON_BYTE_2\t\tBIT(29)\n\n \n#define APCI3120_AI_FIFO_REG\t\t\t0x00\n#define APCI3120_CTRL_REG\t\t\t0x00\n#define APCI3120_CTRL_EXT_TRIG\t\t\tBIT(15)\n#define APCI3120_CTRL_GATE(x)\t\t\tBIT(12 + (x))\n#define APCI3120_CTRL_PR(x)\t\t\t(((x) & 0xf) << 8)\n#define APCI3120_CTRL_PA(x)\t\t\t(((x) & 0xf) << 0)\n#define APCI3120_AI_SOFTTRIG_REG\t\t0x02\n#define APCI3120_STATUS_REG\t\t\t0x02\n#define APCI3120_STATUS_EOC_INT\t\t\tBIT(15)\n#define APCI3120_STATUS_AMCC_INT\t\tBIT(14)\n#define APCI3120_STATUS_EOS_INT\t\t\tBIT(13)\n#define APCI3120_STATUS_TIMER2_INT\t\tBIT(12)\n#define APCI3120_STATUS_INT_MASK\t\t(0xf << 12)\n#define APCI3120_STATUS_TO_DI_BITS(x)\t\t(((x) >> 8) & 0xf)\n#define APCI3120_STATUS_TO_VERSION(x)\t\t(((x) >> 4) & 0xf)\n#define APCI3120_STATUS_FIFO_FULL\t\tBIT(2)\n#define APCI3120_STATUS_FIFO_EMPTY\t\tBIT(1)\n#define APCI3120_STATUS_DA_READY\t\tBIT(0)\n#define APCI3120_TIMER_REG\t\t\t0x04\n#define APCI3120_CHANLIST_REG\t\t\t0x06\n#define APCI3120_CHANLIST_INDEX(x)\t\t(((x) & 0xf) << 8)\n#define APCI3120_CHANLIST_UNIPOLAR\t\tBIT(7)\n#define APCI3120_CHANLIST_GAIN(x)\t\t(((x) & 0x3) << 4)\n#define APCI3120_CHANLIST_MUX(x)\t\t(((x) & 0xf) << 0)\n#define APCI3120_AO_REG(x)\t\t\t(0x08 + (((x) / 4) * 2))\n#define APCI3120_AO_MUX(x)\t\t\t(((x) & 0x3) << 14)\n#define APCI3120_AO_DATA(x)\t\t\t((x) << 0)\n#define APCI3120_TIMER_MODE_REG\t\t\t0x0c\n#define APCI3120_TIMER_MODE(_t, _m)\t\t((_m) << ((_t) * 2))\n#define APCI3120_TIMER_MODE0\t\t\t0   \n#define APCI3120_TIMER_MODE2\t\t\t1   \n#define APCI3120_TIMER_MODE4\t\t\t2   \n#define APCI3120_TIMER_MODE5\t\t\t3   \n#define APCI3120_TIMER_MODE_MASK(_t)\t\t(3 << ((_t) * 2))\n#define APCI3120_CTR0_REG\t\t\t0x0d\n#define APCI3120_CTR0_DO_BITS(x)\t\t((x) << 4)\n#define APCI3120_CTR0_TIMER_SEL(x)\t\t((x) << 0)\n#define APCI3120_MODE_REG\t\t\t0x0e\n#define APCI3120_MODE_TIMER2_CLK(x)\t\t(((x) & 0x3) << 6)\n#define APCI3120_MODE_TIMER2_CLK_OSC\t\tAPCI3120_MODE_TIMER2_CLK(0)\n#define APCI3120_MODE_TIMER2_CLK_OUT1\t\tAPCI3120_MODE_TIMER2_CLK(1)\n#define APCI3120_MODE_TIMER2_CLK_EOC\t\tAPCI3120_MODE_TIMER2_CLK(2)\n#define APCI3120_MODE_TIMER2_CLK_EOS\t\tAPCI3120_MODE_TIMER2_CLK(3)\n#define APCI3120_MODE_TIMER2_CLK_MASK\t\tAPCI3120_MODE_TIMER2_CLK(3)\n#define APCI3120_MODE_TIMER2_AS(x)\t\t(((x) & 0x3) << 4)\n#define APCI3120_MODE_TIMER2_AS_TIMER\t\tAPCI3120_MODE_TIMER2_AS(0)\n#define APCI3120_MODE_TIMER2_AS_COUNTER\t\tAPCI3120_MODE_TIMER2_AS(1)\n#define APCI3120_MODE_TIMER2_AS_WDOG\t\tAPCI3120_MODE_TIMER2_AS(2)\n#define APCI3120_MODE_TIMER2_AS_MASK\t\tAPCI3120_MODE_TIMER2_AS(3)\n#define APCI3120_MODE_SCAN_ENA\t\t\tBIT(3)\n#define APCI3120_MODE_TIMER2_IRQ_ENA\t\tBIT(2)\n#define APCI3120_MODE_EOS_IRQ_ENA\t\tBIT(1)\n#define APCI3120_MODE_EOC_IRQ_ENA\t\tBIT(0)\n\n \n#define APCI3120_ADDON_ADDR_REG\t\t\t0x00\n#define APCI3120_ADDON_DATA_REG\t\t\t0x02\n#define APCI3120_ADDON_CTRL_REG\t\t\t0x04\n#define APCI3120_ADDON_CTRL_AMWEN_ENA\t\tBIT(1)\n#define APCI3120_ADDON_CTRL_A2P_FIFO_ENA\tBIT(0)\n\n \n#define APCI3120_REVA\t\t\t\t0xa\n#define APCI3120_REVB\t\t\t\t0xb\n#define APCI3120_REVA_OSC_BASE\t\t\t70\t \n#define APCI3120_REVB_OSC_BASE\t\t\t50\t \n\nstatic const struct comedi_lrange apci3120_ai_range = {\n\t8, {\n\t\tBIP_RANGE(10),\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(2),\n\t\tBIP_RANGE(1),\n\t\tUNI_RANGE(10),\n\t\tUNI_RANGE(5),\n\t\tUNI_RANGE(2),\n\t\tUNI_RANGE(1)\n\t}\n};\n\nenum apci3120_boardid {\n\tBOARD_APCI3120,\n\tBOARD_APCI3001,\n};\n\nstruct apci3120_board {\n\tconst char *name;\n\tunsigned int ai_is_16bit:1;\n\tunsigned int has_ao:1;\n};\n\nstatic const struct apci3120_board apci3120_boardtypes[] = {\n\t[BOARD_APCI3120] = {\n\t\t.name\t\t= \"apci3120\",\n\t\t.ai_is_16bit\t= 1,\n\t\t.has_ao\t\t= 1,\n\t},\n\t[BOARD_APCI3001] = {\n\t\t.name\t\t= \"apci3001\",\n\t},\n};\n\nstruct apci3120_dmabuf {\n\tunsigned short *virt;\n\tdma_addr_t hw;\n\tunsigned int size;\n\tunsigned int use_size;\n};\n\nstruct apci3120_private {\n\tunsigned long amcc;\n\tunsigned long addon;\n\tunsigned int osc_base;\n\tunsigned int use_dma:1;\n\tunsigned int use_double_buffer:1;\n\tunsigned int cur_dmabuf:1;\n\tstruct apci3120_dmabuf dmabuf[2];\n\tunsigned char do_bits;\n\tunsigned char timer_mode;\n\tunsigned char mode;\n\tunsigned short ctrl;\n};\n\nstatic void apci3120_addon_write(struct comedi_device *dev,\n\t\t\t\t unsigned int val, unsigned int reg)\n{\n\tstruct apci3120_private *devpriv = dev->private;\n\n\t \n\n\toutw(reg, devpriv->addon + APCI3120_ADDON_ADDR_REG);\n\toutw(val & 0xffff, devpriv->addon + APCI3120_ADDON_DATA_REG);\n\n\toutw(reg + 2, devpriv->addon + APCI3120_ADDON_ADDR_REG);\n\toutw((val >> 16) & 0xffff, devpriv->addon + APCI3120_ADDON_DATA_REG);\n}\n\nstatic void apci3120_init_dma(struct comedi_device *dev,\n\t\t\t      struct apci3120_dmabuf *dmabuf)\n{\n\tstruct apci3120_private *devpriv = dev->private;\n\n\t \n\toutl(AGCSTS_TC_ENABLE | AGCSTS_RESET_A2P_FIFO,\n\t     devpriv->amcc + AMCC_OP_REG_AGCSTS);\n\n\t \n\tapci3120_addon_write(dev, AGCSTS_TC_ENABLE | AGCSTS_RESET_A2P_FIFO,\n\t\t\t     AMCC_OP_REG_AGCSTS);\n\n\t \n\toutl(RESET_A2P_FLAGS | EN_A2P_TRANSFERS,\n\t     devpriv->amcc + AMCC_OP_REG_MCSR);\n\n\t \n\tapci3120_addon_write(dev, dmabuf->hw, AMCC_OP_REG_AMWAR);\n\n\t \n\tapci3120_addon_write(dev, dmabuf->use_size, AMCC_OP_REG_AMWTC);\n\n\t \n\toutl(APCI3120_FIFO_ADVANCE_ON_BYTE_2 | AINT_WRITE_COMPL,\n\t     devpriv->amcc + AMCC_OP_REG_INTCSR);\n\n\t \n\toutw(APCI3120_ADDON_CTRL_AMWEN_ENA | APCI3120_ADDON_CTRL_A2P_FIFO_ENA,\n\t     devpriv->addon + APCI3120_ADDON_CTRL_REG);\n}\n\nstatic void apci3120_setup_dma(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s)\n{\n\tstruct apci3120_private *devpriv = dev->private;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tstruct apci3120_dmabuf *dmabuf0 = &devpriv->dmabuf[0];\n\tstruct apci3120_dmabuf *dmabuf1 = &devpriv->dmabuf[1];\n\tunsigned int dmalen0 = dmabuf0->size;\n\tunsigned int dmalen1 = dmabuf1->size;\n\tunsigned int scan_bytes;\n\n\tscan_bytes = comedi_samples_to_bytes(s, cmd->scan_end_arg);\n\n\tif (cmd->stop_src == TRIG_COUNT) {\n\t\t \n\t\tif (dmalen0 > (cmd->stop_arg * scan_bytes))\n\t\t\tdmalen0 = cmd->stop_arg * scan_bytes;\n\t\telse if (dmalen1 > (cmd->stop_arg * scan_bytes - dmalen0))\n\t\t\tdmalen1 = cmd->stop_arg * scan_bytes - dmalen0;\n\t}\n\n\tif (cmd->flags & CMDF_WAKE_EOS) {\n\t\t \n\t\tif (dmalen0 > scan_bytes) {\n\t\t\tdmalen0 = scan_bytes;\n\t\t\tif (cmd->scan_end_arg & 1)\n\t\t\t\tdmalen0 += 2;\n\t\t}\n\t\tif (dmalen1 > scan_bytes) {\n\t\t\tdmalen1 = scan_bytes;\n\t\t\tif (cmd->scan_end_arg & 1)\n\t\t\t\tdmalen1 -= 2;\n\t\t\tif (dmalen1 < 4)\n\t\t\t\tdmalen1 = 4;\n\t\t}\n\t} else {\n\t\t \n\t\tif (dmalen0 > s->async->prealloc_bufsz)\n\t\t\tdmalen0 = s->async->prealloc_bufsz;\n\t\tif (dmalen1 > s->async->prealloc_bufsz)\n\t\t\tdmalen1 = s->async->prealloc_bufsz;\n\t}\n\tdmabuf0->use_size = dmalen0;\n\tdmabuf1->use_size = dmalen1;\n\n\tapci3120_init_dma(dev, dmabuf0);\n}\n\n \nstatic unsigned int apci3120_ns_to_timer(struct comedi_device *dev,\n\t\t\t\t\t unsigned int timer,\n\t\t\t\t\t unsigned int ns,\n\t\t\t\t\t unsigned int flags)\n{\n\tstruct apci3120_private *devpriv = dev->private;\n\tunsigned int prescale = (timer == 0) ? 10 : 1000;\n\tunsigned int timer_base = devpriv->osc_base * prescale;\n\tunsigned int divisor;\n\n\tswitch (flags & CMDF_ROUND_MASK) {\n\tcase CMDF_ROUND_UP:\n\t\tdivisor = DIV_ROUND_UP(ns, timer_base);\n\t\tbreak;\n\tcase CMDF_ROUND_DOWN:\n\t\tdivisor = ns / timer_base;\n\t\tbreak;\n\tcase CMDF_ROUND_NEAREST:\n\tdefault:\n\t\tdivisor = DIV_ROUND_CLOSEST(ns, timer_base);\n\t\tbreak;\n\t}\n\n\tif (timer == 2) {\n\t\t \n\t\tif (divisor > 0x00ffffff)\n\t\t\tdivisor = 0x00ffffff;\n\t} else {\n\t\t \n\t\tif (divisor > 0xffff)\n\t\t\tdivisor = 0xffff;\n\t}\n\t \n\tif (divisor < 2)\n\t\tdivisor = 2;\n\n\treturn divisor;\n}\n\nstatic void apci3120_clr_timer2_interrupt(struct comedi_device *dev)\n{\n\t \n\tinb(dev->iobase + APCI3120_CTR0_REG);\n}\n\nstatic void apci3120_timer_write(struct comedi_device *dev,\n\t\t\t\t unsigned int timer, unsigned int val)\n{\n\tstruct apci3120_private *devpriv = dev->private;\n\n\t \n\toutb(APCI3120_CTR0_DO_BITS(devpriv->do_bits) |\n\t     APCI3120_CTR0_TIMER_SEL(timer),\n\t     dev->iobase + APCI3120_CTR0_REG);\n\toutw(val & 0xffff, dev->iobase + APCI3120_TIMER_REG);\n\n\tif (timer == 2) {\n\t\t \n\t\toutb(APCI3120_CTR0_DO_BITS(devpriv->do_bits) |\n\t\t     APCI3120_CTR0_TIMER_SEL(timer + 1),\n\t\t     dev->iobase + APCI3120_CTR0_REG);\n\t\toutw((val >> 16) & 0xffff, dev->iobase + APCI3120_TIMER_REG);\n\t}\n}\n\nstatic unsigned int apci3120_timer_read(struct comedi_device *dev,\n\t\t\t\t\tunsigned int timer)\n{\n\tstruct apci3120_private *devpriv = dev->private;\n\tunsigned int val;\n\n\t \n\toutb(APCI3120_CTR0_DO_BITS(devpriv->do_bits) |\n\t     APCI3120_CTR0_TIMER_SEL(timer),\n\t     dev->iobase + APCI3120_CTR0_REG);\n\tval = inw(dev->iobase + APCI3120_TIMER_REG);\n\n\tif (timer == 2) {\n\t\t \n\t\toutb(APCI3120_CTR0_DO_BITS(devpriv->do_bits) |\n\t\t     APCI3120_CTR0_TIMER_SEL(timer + 1),\n\t\t     dev->iobase + APCI3120_CTR0_REG);\n\t\tval |= (inw(dev->iobase + APCI3120_TIMER_REG) << 16);\n\t}\n\n\treturn val;\n}\n\nstatic void apci3120_timer_set_mode(struct comedi_device *dev,\n\t\t\t\t    unsigned int timer, unsigned int mode)\n{\n\tstruct apci3120_private *devpriv = dev->private;\n\n\tdevpriv->timer_mode &= ~APCI3120_TIMER_MODE_MASK(timer);\n\tdevpriv->timer_mode |= APCI3120_TIMER_MODE(timer, mode);\n\toutb(devpriv->timer_mode, dev->iobase + APCI3120_TIMER_MODE_REG);\n}\n\nstatic void apci3120_timer_enable(struct comedi_device *dev,\n\t\t\t\t  unsigned int timer, bool enable)\n{\n\tstruct apci3120_private *devpriv = dev->private;\n\n\tif (enable)\n\t\tdevpriv->ctrl |= APCI3120_CTRL_GATE(timer);\n\telse\n\t\tdevpriv->ctrl &= ~APCI3120_CTRL_GATE(timer);\n\toutw(devpriv->ctrl, dev->iobase + APCI3120_CTRL_REG);\n}\n\nstatic void apci3120_exttrig_enable(struct comedi_device *dev, bool enable)\n{\n\tstruct apci3120_private *devpriv = dev->private;\n\n\tif (enable)\n\t\tdevpriv->ctrl |= APCI3120_CTRL_EXT_TRIG;\n\telse\n\t\tdevpriv->ctrl &= ~APCI3120_CTRL_EXT_TRIG;\n\toutw(devpriv->ctrl, dev->iobase + APCI3120_CTRL_REG);\n}\n\nstatic void apci3120_set_chanlist(struct comedi_device *dev,\n\t\t\t\t  struct comedi_subdevice *s,\n\t\t\t\t  int n_chan, unsigned int *chanlist)\n{\n\tstruct apci3120_private *devpriv = dev->private;\n\tint i;\n\n\t \n\tfor (i = 0; i < n_chan; i++) {\n\t\tunsigned int chan = CR_CHAN(chanlist[i]);\n\t\tunsigned int range = CR_RANGE(chanlist[i]);\n\t\tunsigned int val;\n\n\t\tval = APCI3120_CHANLIST_MUX(chan) |\n\t\t      APCI3120_CHANLIST_GAIN(range) |\n\t\t      APCI3120_CHANLIST_INDEX(i);\n\n\t\tif (comedi_range_is_unipolar(s, range))\n\t\t\tval |= APCI3120_CHANLIST_UNIPOLAR;\n\n\t\toutw(val, dev->iobase + APCI3120_CHANLIST_REG);\n\t}\n\n\t \n\tinw(dev->iobase + APCI3120_TIMER_MODE_REG);\n\n\t \n\tdevpriv->ctrl = APCI3120_CTRL_PR(n_chan - 1) | APCI3120_CTRL_PA(0);\n\toutw(devpriv->ctrl, dev->iobase + APCI3120_CTRL_REG);\n\n\t \n\tif (n_chan > 1)\n\t\tdevpriv->mode |= APCI3120_MODE_SCAN_ENA;\n}\n\nstatic void apci3120_interrupt_dma(struct comedi_device *dev,\n\t\t\t\t   struct comedi_subdevice *s)\n{\n\tstruct apci3120_private *devpriv = dev->private;\n\tstruct comedi_async *async = s->async;\n\tstruct comedi_cmd *cmd = &async->cmd;\n\tstruct apci3120_dmabuf *dmabuf;\n\tunsigned int nbytes;\n\tunsigned int nsamples;\n\n\tdmabuf = &devpriv->dmabuf[devpriv->cur_dmabuf];\n\n\tnbytes = dmabuf->use_size - inl(devpriv->amcc + AMCC_OP_REG_MWTC);\n\n\tif (nbytes < dmabuf->use_size)\n\t\tdev_err(dev->class_dev, \"Interrupted DMA transfer!\\n\");\n\tif (nbytes & 1) {\n\t\tdev_err(dev->class_dev, \"Odd count of bytes in DMA ring!\\n\");\n\t\tasync->events |= COMEDI_CB_ERROR;\n\t\treturn;\n\t}\n\n\tnsamples = comedi_bytes_to_samples(s, nbytes);\n\tif (nsamples) {\n\t\tcomedi_buf_write_samples(s, dmabuf->virt, nsamples);\n\n\t\tif (!(cmd->flags & CMDF_WAKE_EOS))\n\t\t\tasync->events |= COMEDI_CB_EOS;\n\t}\n\n\tif ((async->events & COMEDI_CB_CANCEL_MASK) ||\n\t    (cmd->stop_src == TRIG_COUNT && async->scans_done >= cmd->stop_arg))\n\t\treturn;\n\n\tif (devpriv->use_double_buffer) {\n\t\t \n\t\tdevpriv->cur_dmabuf = !devpriv->cur_dmabuf;\n\t\tdmabuf = &devpriv->dmabuf[devpriv->cur_dmabuf];\n\t\tapci3120_init_dma(dev, dmabuf);\n\t} else {\n\t\t \n\t\tapci3120_init_dma(dev, dmabuf);\n\t}\n}\n\nstatic irqreturn_t apci3120_interrupt(int irq, void *d)\n{\n\tstruct comedi_device *dev = d;\n\tstruct apci3120_private *devpriv = dev->private;\n\tstruct comedi_subdevice *s = dev->read_subdev;\n\tstruct comedi_async *async = s->async;\n\tstruct comedi_cmd *cmd = &async->cmd;\n\tunsigned int status;\n\tunsigned int int_amcc;\n\n\tstatus = inw(dev->iobase + APCI3120_STATUS_REG);\n\tint_amcc = inl(devpriv->amcc + AMCC_OP_REG_INTCSR);\n\n\tif (!(status & APCI3120_STATUS_INT_MASK) &&\n\t    !(int_amcc & ANY_S593X_INT)) {\n\t\tdev_err(dev->class_dev, \"IRQ from unknown source\\n\");\n\t\treturn IRQ_NONE;\n\t}\n\n\toutl(int_amcc | AINT_INT_MASK, devpriv->amcc + AMCC_OP_REG_INTCSR);\n\n\tif (devpriv->ctrl & APCI3120_CTRL_EXT_TRIG)\n\t\tapci3120_exttrig_enable(dev, false);\n\n\tif (int_amcc & MASTER_ABORT_INT)\n\t\tdev_err(dev->class_dev, \"AMCC IRQ - MASTER DMA ABORT!\\n\");\n\tif (int_amcc & TARGET_ABORT_INT)\n\t\tdev_err(dev->class_dev, \"AMCC IRQ - TARGET DMA ABORT!\\n\");\n\n\tif ((status & APCI3120_STATUS_EOS_INT) &&\n\t    (devpriv->mode & APCI3120_MODE_EOS_IRQ_ENA)) {\n\t\tunsigned short val;\n\t\tint i;\n\n\t\tfor (i = 0; i < cmd->chanlist_len; i++) {\n\t\t\tval = inw(dev->iobase + APCI3120_AI_FIFO_REG);\n\t\t\tcomedi_buf_write_samples(s, &val, 1);\n\t\t}\n\n\t\tdevpriv->mode |= APCI3120_MODE_EOS_IRQ_ENA;\n\t\toutb(devpriv->mode, dev->iobase + APCI3120_MODE_REG);\n\t}\n\n\tif (status & APCI3120_STATUS_TIMER2_INT) {\n\t\t \n\t\tapci3120_clr_timer2_interrupt(dev);\n\t}\n\n\tif (status & APCI3120_STATUS_AMCC_INT) {\n\t\t \n\t\toutl(AINT_WT_COMPLETE, devpriv->amcc + AMCC_OP_REG_INTCSR);\n\n\t\t \n\t\tapci3120_interrupt_dma(dev, s);\n\t}\n\n\tif (cmd->stop_src == TRIG_COUNT && async->scans_done >= cmd->stop_arg)\n\t\tasync->events |= COMEDI_CB_EOA;\n\n\tcomedi_handle_events(dev, s);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int apci3120_ai_cmd(struct comedi_device *dev,\n\t\t\t   struct comedi_subdevice *s)\n{\n\tstruct apci3120_private *devpriv = dev->private;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tunsigned int divisor;\n\n\t \n\tdevpriv->mode = APCI3120_MODE_TIMER2_CLK_OSC |\n\t\t\tAPCI3120_MODE_TIMER2_AS_TIMER;\n\n\t \n\toutl(AINT_WT_COMPLETE, devpriv->amcc + AMCC_OP_REG_INTCSR);\n\n\tdevpriv->cur_dmabuf = 0;\n\n\t \n\tapci3120_set_chanlist(dev, s, cmd->chanlist_len, cmd->chanlist);\n\n\tif (cmd->start_src == TRIG_EXT)\n\t\tapci3120_exttrig_enable(dev, true);\n\n\tif (cmd->scan_begin_src == TRIG_TIMER) {\n\t\t \n\t\tdivisor = apci3120_ns_to_timer(dev, 1, cmd->scan_begin_arg,\n\t\t\t\t\t       cmd->flags);\n\t\tapci3120_timer_set_mode(dev, 1, APCI3120_TIMER_MODE2);\n\t\tapci3120_timer_write(dev, 1, divisor);\n\t}\n\n\t \n\tdivisor = apci3120_ns_to_timer(dev, 0, cmd->convert_arg, cmd->flags);\n\tapci3120_timer_set_mode(dev, 0, APCI3120_TIMER_MODE2);\n\tapci3120_timer_write(dev, 0, divisor);\n\n\tif (devpriv->use_dma)\n\t\tapci3120_setup_dma(dev, s);\n\telse\n\t\tdevpriv->mode |= APCI3120_MODE_EOS_IRQ_ENA;\n\n\t \n\toutb(devpriv->mode, dev->iobase + APCI3120_MODE_REG);\n\n\tif (cmd->scan_begin_src == TRIG_TIMER)\n\t\tapci3120_timer_enable(dev, 1, true);\n\tapci3120_timer_enable(dev, 0, true);\n\n\treturn 0;\n}\n\nstatic int apci3120_ai_cmdtest(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       struct comedi_cmd *cmd)\n{\n\tunsigned int arg;\n\tint err = 0;\n\n\t \n\n\terr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_EXT);\n\terr |= comedi_check_trigger_src(&cmd->scan_begin_src,\n\t\t\t\t\tTRIG_TIMER | TRIG_FOLLOW);\n\terr |= comedi_check_trigger_src(&cmd->convert_src, TRIG_TIMER);\n\terr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\n\terr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\n\n\tif (err)\n\t\treturn 1;\n\n\t \n\n\terr |= comedi_check_trigger_is_unique(cmd->start_src);\n\terr |= comedi_check_trigger_is_unique(cmd->scan_begin_src);\n\terr |= comedi_check_trigger_is_unique(cmd->stop_src);\n\n\t \n\n\tif (err)\n\t\treturn 2;\n\n\t \n\n\terr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\n\n\tif (cmd->scan_begin_src == TRIG_TIMER) {\t \n\t\terr |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,\n\t\t\t\t\t\t    100000);\n\t}\n\n\t \n\terr |= comedi_check_trigger_arg_min(&cmd->convert_arg, 10000);\n\n\terr |= comedi_check_trigger_arg_min(&cmd->chanlist_len, 1);\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\n\t\t\t\t\t   cmd->chanlist_len);\n\n\tif (cmd->stop_src == TRIG_COUNT)\n\t\terr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\n\telse\t \n\t\terr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\n\n\tif (err)\n\t\treturn 3;\n\n\t \n\n\tif (cmd->scan_begin_src == TRIG_TIMER) {\n\t\t \n\t\targ = cmd->convert_arg * cmd->scan_end_arg;\n\t\terr |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg, arg);\n\t}\n\n\tif (err)\n\t\treturn 4;\n\n\t \n\n\treturn 0;\n}\n\nstatic int apci3120_cancel(struct comedi_device *dev,\n\t\t\t   struct comedi_subdevice *s)\n{\n\tstruct apci3120_private *devpriv = dev->private;\n\n\t \n\toutw(0, devpriv->addon + 4);\n\n\t \n\tapci3120_addon_write(dev, 0, AMCC_OP_REG_AGCSTS);\n\n\t \n\toutl(0, devpriv->amcc + AMCC_OP_REG_MCSR);\n\n\t \n\tdevpriv->ctrl = 0;\n\toutw(devpriv->ctrl, dev->iobase + APCI3120_CTRL_REG);\n\n\t \n\tdevpriv->mode = 0;\n\toutb(devpriv->mode, dev->iobase + APCI3120_MODE_REG);\n\n\tinw(dev->iobase + APCI3120_STATUS_REG);\n\tdevpriv->cur_dmabuf = 0;\n\n\treturn 0;\n}\n\nstatic int apci3120_ai_eoc(struct comedi_device *dev,\n\t\t\t   struct comedi_subdevice *s,\n\t\t\t   struct comedi_insn *insn,\n\t\t\t   unsigned long context)\n{\n\tunsigned int status;\n\n\tstatus = inw(dev->iobase + APCI3120_STATUS_REG);\n\tif ((status & APCI3120_STATUS_EOC_INT) == 0)\n\t\treturn 0;\n\treturn -EBUSY;\n}\n\nstatic int apci3120_ai_insn_read(struct comedi_device *dev,\n\t\t\t\t struct comedi_subdevice *s,\n\t\t\t\t struct comedi_insn *insn,\n\t\t\t\t unsigned int *data)\n{\n\tstruct apci3120_private *devpriv = dev->private;\n\tunsigned int divisor;\n\tint ret;\n\tint i;\n\n\t \n\tdevpriv->mode = APCI3120_MODE_TIMER2_CLK_OSC |\n\t\t\tAPCI3120_MODE_TIMER2_AS_TIMER;\n\toutb(devpriv->mode, dev->iobase + APCI3120_MODE_REG);\n\n\t \n\tapci3120_set_chanlist(dev, s, 1, &insn->chanspec);\n\n\t \n\tapci3120_timer_set_mode(dev, 0, APCI3120_TIMER_MODE4);\n\tapci3120_timer_enable(dev, 0, true);\n\n\t \n\tdivisor = apci3120_ns_to_timer(dev, 0, 10000, CMDF_ROUND_NEAREST);\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\t \n\t\tapci3120_timer_write(dev, 0, divisor);\n\n\t\tret = comedi_timeout(dev, s, insn, apci3120_ai_eoc, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdata[i] = inw(dev->iobase + APCI3120_AI_FIFO_REG);\n\t}\n\n\treturn insn->n;\n}\n\nstatic int apci3120_ao_ready(struct comedi_device *dev,\n\t\t\t     struct comedi_subdevice *s,\n\t\t\t     struct comedi_insn *insn,\n\t\t\t     unsigned long context)\n{\n\tunsigned int status;\n\n\tstatus = inw(dev->iobase + APCI3120_STATUS_REG);\n\tif (status & APCI3120_STATUS_DA_READY)\n\t\treturn 0;\n\treturn -EBUSY;\n}\n\nstatic int apci3120_ao_insn_write(struct comedi_device *dev,\n\t\t\t\t  struct comedi_subdevice *s,\n\t\t\t\t  struct comedi_insn *insn,\n\t\t\t\t  unsigned int *data)\n{\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tint i;\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\tunsigned int val = data[i];\n\t\tint ret;\n\n\t\tret = comedi_timeout(dev, s, insn, apci3120_ao_ready, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\toutw(APCI3120_AO_MUX(chan) | APCI3120_AO_DATA(val),\n\t\t     dev->iobase + APCI3120_AO_REG(chan));\n\n\t\ts->readback[chan] = val;\n\t}\n\n\treturn insn->n;\n}\n\nstatic int apci3120_di_insn_bits(struct comedi_device *dev,\n\t\t\t\t struct comedi_subdevice *s,\n\t\t\t\t struct comedi_insn *insn,\n\t\t\t\t unsigned int *data)\n{\n\tunsigned int status;\n\n\tstatus = inw(dev->iobase + APCI3120_STATUS_REG);\n\tdata[1] = APCI3120_STATUS_TO_DI_BITS(status);\n\n\treturn insn->n;\n}\n\nstatic int apci3120_do_insn_bits(struct comedi_device *dev,\n\t\t\t\t struct comedi_subdevice *s,\n\t\t\t\t struct comedi_insn *insn,\n\t\t\t\t unsigned int *data)\n{\n\tstruct apci3120_private *devpriv = dev->private;\n\n\tif (comedi_dio_update_state(s, data)) {\n\t\tdevpriv->do_bits = s->state;\n\t\toutb(APCI3120_CTR0_DO_BITS(devpriv->do_bits),\n\t\t     dev->iobase + APCI3120_CTR0_REG);\n\t}\n\n\tdata[1] = s->state;\n\n\treturn insn->n;\n}\n\nstatic int apci3120_timer_insn_config(struct comedi_device *dev,\n\t\t\t\t      struct comedi_subdevice *s,\n\t\t\t\t      struct comedi_insn *insn,\n\t\t\t\t      unsigned int *data)\n{\n\tstruct apci3120_private *devpriv = dev->private;\n\tunsigned int divisor;\n\tunsigned int status;\n\tunsigned int mode;\n\tunsigned int timer_mode;\n\n\tswitch (data[0]) {\n\tcase INSN_CONFIG_ARM:\n\t\tapci3120_clr_timer2_interrupt(dev);\n\t\tdivisor = apci3120_ns_to_timer(dev, 2, data[1],\n\t\t\t\t\t       CMDF_ROUND_DOWN);\n\t\tapci3120_timer_write(dev, 2, divisor);\n\t\tapci3120_timer_enable(dev, 2, true);\n\t\tbreak;\n\n\tcase INSN_CONFIG_DISARM:\n\t\tapci3120_timer_enable(dev, 2, false);\n\t\tapci3120_clr_timer2_interrupt(dev);\n\t\tbreak;\n\n\tcase INSN_CONFIG_GET_COUNTER_STATUS:\n\t\tdata[1] = 0;\n\t\tdata[2] = COMEDI_COUNTER_ARMED | COMEDI_COUNTER_COUNTING |\n\t\t\t  COMEDI_COUNTER_TERMINAL_COUNT;\n\n\t\tif (devpriv->ctrl & APCI3120_CTRL_GATE(2)) {\n\t\t\tdata[1] |= COMEDI_COUNTER_ARMED;\n\t\t\tdata[1] |= COMEDI_COUNTER_COUNTING;\n\t\t}\n\t\tstatus = inw(dev->iobase + APCI3120_STATUS_REG);\n\t\tif (status & APCI3120_STATUS_TIMER2_INT) {\n\t\t\tdata[1] &= ~COMEDI_COUNTER_COUNTING;\n\t\t\tdata[1] |= COMEDI_COUNTER_TERMINAL_COUNT;\n\t\t}\n\t\tbreak;\n\n\tcase INSN_CONFIG_SET_COUNTER_MODE:\n\t\tswitch (data[1]) {\n\t\tcase I8254_MODE0:\n\t\t\tmode = APCI3120_MODE_TIMER2_AS_COUNTER;\n\t\t\ttimer_mode = APCI3120_TIMER_MODE0;\n\t\t\tbreak;\n\t\tcase I8254_MODE2:\n\t\t\tmode = APCI3120_MODE_TIMER2_AS_TIMER;\n\t\t\ttimer_mode = APCI3120_TIMER_MODE2;\n\t\t\tbreak;\n\t\tcase I8254_MODE4:\n\t\t\tmode = APCI3120_MODE_TIMER2_AS_TIMER;\n\t\t\ttimer_mode = APCI3120_TIMER_MODE4;\n\t\t\tbreak;\n\t\tcase I8254_MODE5:\n\t\t\tmode = APCI3120_MODE_TIMER2_AS_WDOG;\n\t\t\ttimer_mode = APCI3120_TIMER_MODE5;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tapci3120_timer_enable(dev, 2, false);\n\t\tapci3120_clr_timer2_interrupt(dev);\n\t\tapci3120_timer_set_mode(dev, 2, timer_mode);\n\t\tdevpriv->mode &= ~APCI3120_MODE_TIMER2_AS_MASK;\n\t\tdevpriv->mode |= mode;\n\t\toutb(devpriv->mode, dev->iobase + APCI3120_MODE_REG);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn insn->n;\n}\n\nstatic int apci3120_timer_insn_read(struct comedi_device *dev,\n\t\t\t\t    struct comedi_subdevice *s,\n\t\t\t\t    struct comedi_insn *insn,\n\t\t\t\t    unsigned int *data)\n{\n\tint i;\n\n\tfor (i = 0; i < insn->n; i++)\n\t\tdata[i] = apci3120_timer_read(dev, 2);\n\n\treturn insn->n;\n}\n\nstatic void apci3120_dma_alloc(struct comedi_device *dev)\n{\n\tstruct apci3120_private *devpriv = dev->private;\n\tstruct apci3120_dmabuf *dmabuf;\n\tint order;\n\tint i;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tdmabuf = &devpriv->dmabuf[i];\n\t\tfor (order = 2; order >= 0; order--) {\n\t\t\tdmabuf->virt = dma_alloc_coherent(dev->hw_dev,\n\t\t\t\t\t\t\t  PAGE_SIZE << order,\n\t\t\t\t\t\t\t  &dmabuf->hw,\n\t\t\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (dmabuf->virt)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!dmabuf->virt)\n\t\t\tbreak;\n\t\tdmabuf->size = PAGE_SIZE << order;\n\n\t\tif (i == 0)\n\t\t\tdevpriv->use_dma = 1;\n\t\tif (i == 1)\n\t\t\tdevpriv->use_double_buffer = 1;\n\t}\n}\n\nstatic void apci3120_dma_free(struct comedi_device *dev)\n{\n\tstruct apci3120_private *devpriv = dev->private;\n\tstruct apci3120_dmabuf *dmabuf;\n\tint i;\n\n\tif (!devpriv)\n\t\treturn;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tdmabuf = &devpriv->dmabuf[i];\n\t\tif (dmabuf->virt) {\n\t\t\tdma_free_coherent(dev->hw_dev, dmabuf->size,\n\t\t\t\t\t  dmabuf->virt, dmabuf->hw);\n\t\t}\n\t}\n}\n\nstatic void apci3120_reset(struct comedi_device *dev)\n{\n\t \n\toutb(0, dev->iobase + APCI3120_MODE_REG);\n\n\t \n\toutw(0, dev->iobase + APCI3120_CTRL_REG);\n\n\t \n\tinw(dev->iobase + APCI3120_STATUS_REG);\n}\n\nstatic int apci3120_auto_attach(struct comedi_device *dev,\n\t\t\t\tunsigned long context)\n{\n\tstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\n\tconst struct apci3120_board *board = NULL;\n\tstruct apci3120_private *devpriv;\n\tstruct comedi_subdevice *s;\n\tunsigned int status;\n\tint ret;\n\n\tif (context < ARRAY_SIZE(apci3120_boardtypes))\n\t\tboard = &apci3120_boardtypes[context];\n\tif (!board)\n\t\treturn -ENODEV;\n\tdev->board_ptr = board;\n\tdev->board_name = board->name;\n\n\tdevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\n\tif (!devpriv)\n\t\treturn -ENOMEM;\n\n\tret = comedi_pci_enable(dev);\n\tif (ret)\n\t\treturn ret;\n\tpci_set_master(pcidev);\n\n\tdev->iobase = pci_resource_start(pcidev, 1);\n\tdevpriv->amcc = pci_resource_start(pcidev, 0);\n\tdevpriv->addon = pci_resource_start(pcidev, 2);\n\n\tapci3120_reset(dev);\n\n\tif (pcidev->irq > 0) {\n\t\tret = request_irq(pcidev->irq, apci3120_interrupt, IRQF_SHARED,\n\t\t\t\t  dev->board_name, dev);\n\t\tif (ret == 0) {\n\t\t\tdev->irq = pcidev->irq;\n\n\t\t\tapci3120_dma_alloc(dev);\n\t\t}\n\t}\n\n\tstatus = inw(dev->iobase + APCI3120_STATUS_REG);\n\tif (APCI3120_STATUS_TO_VERSION(status) == APCI3120_REVB ||\n\t    context == BOARD_APCI3001)\n\t\tdevpriv->osc_base = APCI3120_REVB_OSC_BASE;\n\telse\n\t\tdevpriv->osc_base = APCI3120_REVA_OSC_BASE;\n\n\tret = comedi_alloc_subdevices(dev, 5);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ts = &dev->subdevices[0];\n\ts->type\t\t= COMEDI_SUBD_AI;\n\ts->subdev_flags\t= SDF_READABLE | SDF_COMMON | SDF_GROUND | SDF_DIFF;\n\ts->n_chan\t= 16;\n\ts->maxdata\t= board->ai_is_16bit ? 0xffff : 0x0fff;\n\ts->range_table\t= &apci3120_ai_range;\n\ts->insn_read\t= apci3120_ai_insn_read;\n\tif (dev->irq) {\n\t\tdev->read_subdev = s;\n\t\ts->subdev_flags\t|= SDF_CMD_READ;\n\t\ts->len_chanlist\t= s->n_chan;\n\t\ts->do_cmdtest\t= apci3120_ai_cmdtest;\n\t\ts->do_cmd\t= apci3120_ai_cmd;\n\t\ts->cancel\t= apci3120_cancel;\n\t}\n\n\t \n\ts = &dev->subdevices[1];\n\tif (board->has_ao) {\n\t\ts->type\t\t= COMEDI_SUBD_AO;\n\t\ts->subdev_flags\t= SDF_WRITABLE | SDF_GROUND | SDF_COMMON;\n\t\ts->n_chan\t= 8;\n\t\ts->maxdata\t= 0x3fff;\n\t\ts->range_table\t= &range_bipolar10;\n\t\ts->insn_write\t= apci3120_ao_insn_write;\n\n\t\tret = comedi_alloc_subdev_readback(s);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\ts->type\t\t= COMEDI_SUBD_UNUSED;\n\t}\n\n\t \n\ts = &dev->subdevices[2];\n\ts->type\t\t= COMEDI_SUBD_DI;\n\ts->subdev_flags\t= SDF_READABLE;\n\ts->n_chan\t= 4;\n\ts->maxdata\t= 1;\n\ts->range_table\t= &range_digital;\n\ts->insn_bits\t= apci3120_di_insn_bits;\n\n\t \n\ts = &dev->subdevices[3];\n\ts->type\t\t= COMEDI_SUBD_DO;\n\ts->subdev_flags\t= SDF_WRITABLE;\n\ts->n_chan\t= 4;\n\ts->maxdata\t= 1;\n\ts->range_table\t= &range_digital;\n\ts->insn_bits\t= apci3120_do_insn_bits;\n\n\t \n\ts = &dev->subdevices[4];\n\ts->type\t\t= COMEDI_SUBD_TIMER;\n\ts->subdev_flags\t= SDF_READABLE;\n\ts->n_chan\t= 1;\n\ts->maxdata\t= 0x00ffffff;\n\ts->insn_config\t= apci3120_timer_insn_config;\n\ts->insn_read\t= apci3120_timer_insn_read;\n\n\treturn 0;\n}\n\nstatic void apci3120_detach(struct comedi_device *dev)\n{\n\tcomedi_pci_detach(dev);\n\tapci3120_dma_free(dev);\n}\n\nstatic struct comedi_driver apci3120_driver = {\n\t.driver_name\t= \"addi_apci_3120\",\n\t.module\t\t= THIS_MODULE,\n\t.auto_attach\t= apci3120_auto_attach,\n\t.detach\t\t= apci3120_detach,\n};\n\nstatic int apci3120_pci_probe(struct pci_dev *dev,\n\t\t\t      const struct pci_device_id *id)\n{\n\treturn comedi_pci_auto_config(dev, &apci3120_driver, id->driver_data);\n}\n\nstatic const struct pci_device_id apci3120_pci_table[] = {\n\t{ PCI_VDEVICE(AMCC, 0x818d), BOARD_APCI3120 },\n\t{ PCI_VDEVICE(AMCC, 0x828d), BOARD_APCI3001 },\n\t{ 0 }\n};\nMODULE_DEVICE_TABLE(pci, apci3120_pci_table);\n\nstatic struct pci_driver apci3120_pci_driver = {\n\t.name\t\t= \"addi_apci_3120\",\n\t.id_table\t= apci3120_pci_table,\n\t.probe\t\t= apci3120_pci_probe,\n\t.remove\t\t= comedi_pci_auto_unconfig,\n};\nmodule_comedi_pci_driver(apci3120_driver, apci3120_pci_driver);\n\nMODULE_AUTHOR(\"Comedi https://www.comedi.org\");\nMODULE_DESCRIPTION(\"ADDI-DATA APCI-3120, Analog input board\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}