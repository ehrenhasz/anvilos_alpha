{
  "module_name": "cb_pcimdas.c",
  "hash_id": "8cbd1becc079015d42f98bc9def84475c57c395ad9b86eb6a5244f955566ac86",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/cb_pcimdas.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/comedi/comedi_pci.h>\n#include <linux/comedi/comedi_8255.h>\n#include <linux/comedi/comedi_8254.h>\n\n#include \"plx9052.h\"\n\n \n\n \n#define PCIMDAS_AI_REG\t\t\t0x00\n#define PCIMDAS_AI_SOFTTRIG_REG\t\t0x00\n#define PCIMDAS_AO_REG(x)\t\t(0x02 + ((x) * 2))\n\n \n#define PCIMDAS_MUX_REG\t\t\t0x00\n#define PCIMDAS_MUX(_lo, _hi)\t\t((_lo) | ((_hi) << 4))\n#define PCIMDAS_DI_DO_REG\t\t0x01\n#define PCIMDAS_STATUS_REG\t\t0x02\n#define PCIMDAS_STATUS_EOC\t\tBIT(7)\n#define PCIMDAS_STATUS_UB\t\tBIT(6)\n#define PCIMDAS_STATUS_MUX\t\tBIT(5)\n#define PCIMDAS_STATUS_CLK\t\tBIT(4)\n#define PCIMDAS_STATUS_TO_CURR_MUX(x)\t((x) & 0xf)\n#define PCIMDAS_CONV_STATUS_REG\t\t0x03\n#define PCIMDAS_CONV_STATUS_EOC\t\tBIT(7)\n#define PCIMDAS_CONV_STATUS_EOB\t\tBIT(6)\n#define PCIMDAS_CONV_STATUS_EOA\t\tBIT(5)\n#define PCIMDAS_CONV_STATUS_FNE\t\tBIT(4)\n#define PCIMDAS_CONV_STATUS_FHF\t\tBIT(3)\n#define PCIMDAS_CONV_STATUS_OVERRUN\tBIT(2)\n#define PCIMDAS_IRQ_REG\t\t\t0x04\n#define PCIMDAS_IRQ_INTE\t\tBIT(7)\n#define PCIMDAS_IRQ_INT\t\t\tBIT(6)\n#define PCIMDAS_IRQ_OVERRUN\t\tBIT(4)\n#define PCIMDAS_IRQ_EOA\t\t\tBIT(3)\n#define PCIMDAS_IRQ_EOA_INT_SEL\t\tBIT(2)\n#define PCIMDAS_IRQ_INTSEL(x)\t\t((x) << 0)\n#define PCIMDAS_IRQ_INTSEL_EOC\t\tPCIMDAS_IRQ_INTSEL(0)\n#define PCIMDAS_IRQ_INTSEL_FNE\t\tPCIMDAS_IRQ_INTSEL(1)\n#define PCIMDAS_IRQ_INTSEL_EOB\t\tPCIMDAS_IRQ_INTSEL(2)\n#define PCIMDAS_IRQ_INTSEL_FHF_EOA\tPCIMDAS_IRQ_INTSEL(3)\n#define PCIMDAS_PACER_REG\t\t0x05\n#define PCIMDAS_PACER_GATE_STATUS\tBIT(6)\n#define PCIMDAS_PACER_GATE_POL\t\tBIT(5)\n#define PCIMDAS_PACER_GATE_LATCH\tBIT(4)\n#define PCIMDAS_PACER_GATE_EN\t\tBIT(3)\n#define PCIMDAS_PACER_EXT_PACER_POL\tBIT(2)\n#define PCIMDAS_PACER_SRC(x)\t\t((x) << 0)\n#define PCIMDAS_PACER_SRC_POLLED\tPCIMDAS_PACER_SRC(0)\n#define PCIMDAS_PACER_SRC_EXT\t\tPCIMDAS_PACER_SRC(2)\n#define PCIMDAS_PACER_SRC_INT\t\tPCIMDAS_PACER_SRC(3)\n#define PCIMDAS_PACER_SRC_MASK\t\t(3 << 0)\n#define PCIMDAS_BURST_REG\t\t0x06\n#define PCIMDAS_BURST_BME\t\tBIT(1)\n#define PCIMDAS_BURST_CONV_EN\t\tBIT(0)\n#define PCIMDAS_GAIN_REG\t\t0x07\n#define PCIMDAS_8254_BASE\t\t0x08\n#define PCIMDAS_USER_CNTR_REG\t\t0x0c\n#define PCIMDAS_USER_CNTR_CTR1_CLK_SEL\tBIT(0)\n#define PCIMDAS_RESIDUE_MSB_REG\t\t0x0d\n#define PCIMDAS_RESIDUE_LSB_REG\t\t0x0e\n\n \n#define PCIMDAS_8255_BASE\t\t0x00\n\nstatic const struct comedi_lrange cb_pcimdas_ai_bip_range = {\n\t4, {\n\t\tBIP_RANGE(10),\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(2.5),\n\t\tBIP_RANGE(1.25)\n\t}\n};\n\nstatic const struct comedi_lrange cb_pcimdas_ai_uni_range = {\n\t4, {\n\t\tUNI_RANGE(10),\n\t\tUNI_RANGE(5),\n\t\tUNI_RANGE(2.5),\n\t\tUNI_RANGE(1.25)\n\t}\n};\n\n \nstatic const struct comedi_lrange cb_pcimdas_ao_range = {\n\t6, {\n\t\tBIP_RANGE(10),\n\t\tBIP_RANGE(5),\n\t\tUNI_RANGE(10),\n\t\tUNI_RANGE(5),\n\t\tRANGE_ext(-1, 1),\n\t\tRANGE_ext(0, 1)\n\t}\n};\n\n \nstruct cb_pcimdas_private {\n\t \n\tunsigned long daqio;\n\tunsigned long BADR3;\n};\n\nstatic int cb_pcimdas_ai_eoc(struct comedi_device *dev,\n\t\t\t     struct comedi_subdevice *s,\n\t\t\t     struct comedi_insn *insn,\n\t\t\t     unsigned long context)\n{\n\tstruct cb_pcimdas_private *devpriv = dev->private;\n\tunsigned int status;\n\n\tstatus = inb(devpriv->BADR3 + PCIMDAS_STATUS_REG);\n\tif ((status & PCIMDAS_STATUS_EOC) == 0)\n\t\treturn 0;\n\treturn -EBUSY;\n}\n\nstatic int cb_pcimdas_ai_insn_read(struct comedi_device *dev,\n\t\t\t\t   struct comedi_subdevice *s,\n\t\t\t\t   struct comedi_insn *insn,\n\t\t\t\t   unsigned int *data)\n{\n\tstruct cb_pcimdas_private *devpriv = dev->private;\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int range = CR_RANGE(insn->chanspec);\n\tint n;\n\tunsigned int d;\n\tint ret;\n\n\t \n\n\t \n\td = inb(devpriv->BADR3 + PCIMDAS_PACER_REG);\n\tif ((d & PCIMDAS_PACER_SRC_MASK) != PCIMDAS_PACER_SRC_POLLED) {\n\t\td &= ~PCIMDAS_PACER_SRC_MASK;\n\t\td |= PCIMDAS_PACER_SRC_POLLED;\n\t\toutb(d, devpriv->BADR3 + PCIMDAS_PACER_REG);\n\t}\n\n\t \n\toutb(PCIMDAS_BURST_CONV_EN, devpriv->BADR3 + PCIMDAS_BURST_REG);\n\n\t \n\toutb(range, devpriv->BADR3 + PCIMDAS_GAIN_REG);\n\n\t \n\toutb(PCIMDAS_MUX(chan, chan), devpriv->BADR3 + PCIMDAS_MUX_REG);\n\n\t \n\tfor (n = 0; n < insn->n; n++) {\n\t\t \n\t\toutw(0, devpriv->daqio + PCIMDAS_AI_SOFTTRIG_REG);\n\n\t\t \n\t\tret = comedi_timeout(dev, s, insn, cb_pcimdas_ai_eoc, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tdata[n] = inw(devpriv->daqio + PCIMDAS_AI_REG);\n\t}\n\n\t \n\treturn n;\n}\n\nstatic int cb_pcimdas_ao_insn_write(struct comedi_device *dev,\n\t\t\t\t    struct comedi_subdevice *s,\n\t\t\t\t    struct comedi_insn *insn,\n\t\t\t\t    unsigned int *data)\n{\n\tstruct cb_pcimdas_private *devpriv = dev->private;\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int val = s->readback[chan];\n\tint i;\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\tval = data[i];\n\t\toutw(val, devpriv->daqio + PCIMDAS_AO_REG(chan));\n\t}\n\ts->readback[chan] = val;\n\n\treturn insn->n;\n}\n\nstatic int cb_pcimdas_di_insn_bits(struct comedi_device *dev,\n\t\t\t\t   struct comedi_subdevice *s,\n\t\t\t\t   struct comedi_insn *insn,\n\t\t\t\t   unsigned int *data)\n{\n\tstruct cb_pcimdas_private *devpriv = dev->private;\n\tunsigned int val;\n\n\tval = inb(devpriv->BADR3 + PCIMDAS_DI_DO_REG);\n\n\tdata[1] = val & 0x0f;\n\n\treturn insn->n;\n}\n\nstatic int cb_pcimdas_do_insn_bits(struct comedi_device *dev,\n\t\t\t\t   struct comedi_subdevice *s,\n\t\t\t\t   struct comedi_insn *insn,\n\t\t\t\t   unsigned int *data)\n{\n\tstruct cb_pcimdas_private *devpriv = dev->private;\n\n\tif (comedi_dio_update_state(s, data))\n\t\toutb(s->state, devpriv->BADR3 + PCIMDAS_DI_DO_REG);\n\n\tdata[1] = s->state;\n\n\treturn insn->n;\n}\n\nstatic int cb_pcimdas_counter_insn_config(struct comedi_device *dev,\n\t\t\t\t\t  struct comedi_subdevice *s,\n\t\t\t\t\t  struct comedi_insn *insn,\n\t\t\t\t\t  unsigned int *data)\n{\n\tstruct cb_pcimdas_private *devpriv = dev->private;\n\tunsigned int ctrl;\n\n\tswitch (data[0]) {\n\tcase INSN_CONFIG_SET_CLOCK_SRC:\n\t\tswitch (data[1]) {\n\t\tcase 0:\t \n\t\t\tctrl = PCIMDAS_USER_CNTR_CTR1_CLK_SEL;\n\t\t\tbreak;\n\t\tcase 1:\t \n\t\t\tctrl = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\toutb(ctrl, devpriv->BADR3 + PCIMDAS_USER_CNTR_REG);\n\t\tbreak;\n\tcase INSN_CONFIG_GET_CLOCK_SRC:\n\t\tctrl = inb(devpriv->BADR3 + PCIMDAS_USER_CNTR_REG);\n\t\tif (ctrl & PCIMDAS_USER_CNTR_CTR1_CLK_SEL) {\n\t\t\tdata[1] = 0;\n\t\t\tdata[2] = I8254_OSC_BASE_100KHZ;\n\t\t} else {\n\t\t\tdata[1] = 1;\n\t\t\tdata[2] = 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn insn->n;\n}\n\nstatic unsigned int cb_pcimdas_pacer_clk(struct comedi_device *dev)\n{\n\tstruct cb_pcimdas_private *devpriv = dev->private;\n\tunsigned int status;\n\n\t \n\tstatus = inb(devpriv->BADR3 + PCIMDAS_STATUS_REG);\n\tif (status & PCIMDAS_STATUS_CLK)\n\t\treturn I8254_OSC_BASE_10MHZ;\n\treturn I8254_OSC_BASE_1MHZ;\n}\n\nstatic bool cb_pcimdas_is_ai_se(struct comedi_device *dev)\n{\n\tstruct cb_pcimdas_private *devpriv = dev->private;\n\tunsigned int status;\n\n\t \n\tstatus = inb(devpriv->BADR3 + PCIMDAS_STATUS_REG);\n\treturn status & PCIMDAS_STATUS_MUX;\n}\n\nstatic bool cb_pcimdas_is_ai_uni(struct comedi_device *dev)\n{\n\tstruct cb_pcimdas_private *devpriv = dev->private;\n\tunsigned int status;\n\n\t \n\tstatus = inb(devpriv->BADR3 + PCIMDAS_STATUS_REG);\n\treturn status & PCIMDAS_STATUS_UB;\n}\n\nstatic int cb_pcimdas_auto_attach(struct comedi_device *dev,\n\t\t\t\t  unsigned long context_unused)\n{\n\tstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\n\tstruct cb_pcimdas_private *devpriv;\n\tstruct comedi_subdevice *s;\n\tint ret;\n\n\tdevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\n\tif (!devpriv)\n\t\treturn -ENOMEM;\n\n\tret = comedi_pci_enable(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tdevpriv->daqio = pci_resource_start(pcidev, 2);\n\tdevpriv->BADR3 = pci_resource_start(pcidev, 3);\n\tdev->iobase = pci_resource_start(pcidev, 4);\n\n\tdev->pacer = comedi_8254_init(devpriv->BADR3 + PCIMDAS_8254_BASE,\n\t\t\t\t      cb_pcimdas_pacer_clk(dev),\n\t\t\t\t      I8254_IO8, 0);\n\tif (!dev->pacer)\n\t\treturn -ENOMEM;\n\n\tret = comedi_alloc_subdevices(dev, 6);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ts = &dev->subdevices[0];\n\ts->type\t\t= COMEDI_SUBD_AI;\n\ts->subdev_flags\t= SDF_READABLE;\n\tif (cb_pcimdas_is_ai_se(dev)) {\n\t\ts->subdev_flags\t|= SDF_GROUND;\n\t\ts->n_chan\t= 16;\n\t} else {\n\t\ts->subdev_flags\t|= SDF_DIFF;\n\t\ts->n_chan\t= 8;\n\t}\n\ts->maxdata\t= 0xffff;\n\ts->range_table\t= cb_pcimdas_is_ai_uni(dev) ? &cb_pcimdas_ai_uni_range\n\t\t\t\t\t\t    : &cb_pcimdas_ai_bip_range;\n\ts->insn_read\t= cb_pcimdas_ai_insn_read;\n\n\t \n\ts = &dev->subdevices[1];\n\ts->type\t\t= COMEDI_SUBD_AO;\n\ts->subdev_flags\t= SDF_WRITABLE;\n\ts->n_chan\t= 2;\n\ts->maxdata\t= 0xfff;\n\ts->range_table\t= &cb_pcimdas_ao_range;\n\ts->insn_write\t= cb_pcimdas_ao_insn_write;\n\n\tret = comedi_alloc_subdev_readback(s);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ts = &dev->subdevices[2];\n\tret = subdev_8255_init(dev, s, NULL, PCIMDAS_8255_BASE);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ts = &dev->subdevices[3];\n\ts->type\t\t= COMEDI_SUBD_DI;\n\ts->subdev_flags\t= SDF_READABLE;\n\ts->n_chan\t= 4;\n\ts->maxdata\t= 1;\n\ts->range_table\t= &range_digital;\n\ts->insn_bits\t= cb_pcimdas_di_insn_bits;\n\n\t \n\ts = &dev->subdevices[4];\n\ts->type\t\t= COMEDI_SUBD_DO;\n\ts->subdev_flags\t= SDF_WRITABLE;\n\ts->n_chan\t= 4;\n\ts->maxdata\t= 1;\n\ts->range_table\t= &range_digital;\n\ts->insn_bits\t= cb_pcimdas_do_insn_bits;\n\n\t \n\ts = &dev->subdevices[5];\n\tcomedi_8254_subdevice_init(s, dev->pacer);\n\n\tdev->pacer->insn_config = cb_pcimdas_counter_insn_config;\n\n\t \n\tcomedi_8254_set_busy(dev->pacer, 1, true);\n\tcomedi_8254_set_busy(dev->pacer, 2, true);\n\n\treturn 0;\n}\n\nstatic struct comedi_driver cb_pcimdas_driver = {\n\t.driver_name\t= \"cb_pcimdas\",\n\t.module\t\t= THIS_MODULE,\n\t.auto_attach\t= cb_pcimdas_auto_attach,\n\t.detach\t\t= comedi_pci_detach,\n};\n\nstatic int cb_pcimdas_pci_probe(struct pci_dev *dev,\n\t\t\t\tconst struct pci_device_id *id)\n{\n\treturn comedi_pci_auto_config(dev, &cb_pcimdas_driver,\n\t\t\t\t      id->driver_data);\n}\n\nstatic const struct pci_device_id cb_pcimdas_pci_table[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x0056) },\t \n\t{ PCI_DEVICE(PCI_VENDOR_ID_CB, 0x0115) },\t \n\t{ 0 }\n};\nMODULE_DEVICE_TABLE(pci, cb_pcimdas_pci_table);\n\nstatic struct pci_driver cb_pcimdas_pci_driver = {\n\t.name\t\t= \"cb_pcimdas\",\n\t.id_table\t= cb_pcimdas_pci_table,\n\t.probe\t\t= cb_pcimdas_pci_probe,\n\t.remove\t\t= comedi_pci_auto_unconfig,\n};\nmodule_comedi_pci_driver(cb_pcimdas_driver, cb_pcimdas_pci_driver);\n\nMODULE_AUTHOR(\"Comedi https://www.comedi.org\");\nMODULE_DESCRIPTION(\"Comedi driver for PCIM-DAS1602/16 and PCIe-DAS1602/16\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}