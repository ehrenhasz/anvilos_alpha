{
  "module_name": "dyna_pci10xx.c",
  "hash_id": "6bef0a3dac68420c83a755a2e3a2e1f9de5783d4dad1eb01ea5541ae4ecb6e73",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/dyna_pci10xx.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/comedi/comedi_pci.h>\n\n#define READ_TIMEOUT 50\n\nstatic const struct comedi_lrange range_pci1050_ai = {\n\t3, {\n\t\tBIP_RANGE(10),\n\t\tBIP_RANGE(5),\n\t\tUNI_RANGE(10)\n\t}\n};\n\nstatic const char range_codes_pci1050_ai[] = { 0x00, 0x10, 0x30 };\n\nstruct dyna_pci10xx_private {\n\tstruct mutex mutex;\n\tunsigned long BADR3;\n};\n\nstatic int dyna_pci10xx_ai_eoc(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       struct comedi_insn *insn,\n\t\t\t       unsigned long context)\n{\n\tunsigned int status;\n\n\tstatus = inw_p(dev->iobase);\n\tif (status & BIT(15))\n\t\treturn 0;\n\treturn -EBUSY;\n}\n\nstatic int dyna_pci10xx_insn_read_ai(struct comedi_device *dev,\n\t\t\t\t     struct comedi_subdevice *s,\n\t\t\t\t     struct comedi_insn *insn,\n\t\t\t\t     unsigned int *data)\n{\n\tstruct dyna_pci10xx_private *devpriv = dev->private;\n\tint n;\n\tu16 d = 0;\n\tint ret = 0;\n\tunsigned int chan, range;\n\n\t \n\tchan = CR_CHAN(insn->chanspec);\n\trange = range_codes_pci1050_ai[CR_RANGE((insn->chanspec))];\n\n\tmutex_lock(&devpriv->mutex);\n\t \n\tfor (n = 0; n < insn->n; n++) {\n\t\t \n\t\tsmp_mb();\n\t\toutw_p(0x0000 + range + chan, dev->iobase + 2);\n\t\tusleep_range(10, 20);\n\n\t\tret = comedi_timeout(dev, s, insn, dyna_pci10xx_ai_eoc, 0);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\t \n\t\td = inw_p(dev->iobase);\n\t\t \n\t\td &= 0x0FFF;\n\t\tdata[n] = d;\n\t}\n\tmutex_unlock(&devpriv->mutex);\n\n\t \n\treturn ret ? ret : n;\n}\n\n \nstatic int dyna_pci10xx_insn_write_ao(struct comedi_device *dev,\n\t\t\t\t      struct comedi_subdevice *s,\n\t\t\t\t      struct comedi_insn *insn,\n\t\t\t\t      unsigned int *data)\n{\n\tstruct dyna_pci10xx_private *devpriv = dev->private;\n\tint n;\n\n\tmutex_lock(&devpriv->mutex);\n\tfor (n = 0; n < insn->n; n++) {\n\t\tsmp_mb();\n\t\t \n\t\toutw_p(data[n], dev->iobase);\n\t\tusleep_range(10, 20);\n\t}\n\tmutex_unlock(&devpriv->mutex);\n\treturn n;\n}\n\n \nstatic int dyna_pci10xx_di_insn_bits(struct comedi_device *dev,\n\t\t\t\t     struct comedi_subdevice *s,\n\t\t\t\t     struct comedi_insn *insn,\n\t\t\t\t     unsigned int *data)\n{\n\tstruct dyna_pci10xx_private *devpriv = dev->private;\n\tu16 d = 0;\n\n\tmutex_lock(&devpriv->mutex);\n\tsmp_mb();\n\td = inw_p(devpriv->BADR3);\n\tusleep_range(10, 100);\n\n\t \n\tdata[1] = d;\n\tdata[0] = s->state;\n\tmutex_unlock(&devpriv->mutex);\n\treturn insn->n;\n}\n\nstatic int dyna_pci10xx_do_insn_bits(struct comedi_device *dev,\n\t\t\t\t     struct comedi_subdevice *s,\n\t\t\t\t     struct comedi_insn *insn,\n\t\t\t\t     unsigned int *data)\n{\n\tstruct dyna_pci10xx_private *devpriv = dev->private;\n\n\tmutex_lock(&devpriv->mutex);\n\tif (comedi_dio_update_state(s, data)) {\n\t\tsmp_mb();\n\t\toutw_p(s->state, devpriv->BADR3);\n\t\tusleep_range(10, 100);\n\t}\n\n\tdata[1] = s->state;\n\tmutex_unlock(&devpriv->mutex);\n\n\treturn insn->n;\n}\n\nstatic int dyna_pci10xx_auto_attach(struct comedi_device *dev,\n\t\t\t\t    unsigned long context_unused)\n{\n\tstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\n\tstruct dyna_pci10xx_private *devpriv;\n\tstruct comedi_subdevice *s;\n\tint ret;\n\n\tdevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\n\tif (!devpriv)\n\t\treturn -ENOMEM;\n\n\tret = comedi_pci_enable(dev);\n\tif (ret)\n\t\treturn ret;\n\tdev->iobase = pci_resource_start(pcidev, 2);\n\tdevpriv->BADR3 = pci_resource_start(pcidev, 3);\n\n\tmutex_init(&devpriv->mutex);\n\n\tret = comedi_alloc_subdevices(dev, 4);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ts = &dev->subdevices[0];\n\ts->type = COMEDI_SUBD_AI;\n\ts->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_DIFF;\n\ts->n_chan = 16;\n\ts->maxdata = 0x0FFF;\n\ts->range_table = &range_pci1050_ai;\n\ts->insn_read = dyna_pci10xx_insn_read_ai;\n\n\t \n\ts = &dev->subdevices[1];\n\ts->type = COMEDI_SUBD_AO;\n\ts->subdev_flags = SDF_WRITABLE;\n\ts->n_chan = 1;\n\ts->maxdata = 0x0FFF;\n\ts->range_table = &range_unipolar10;\n\ts->insn_write = dyna_pci10xx_insn_write_ao;\n\n\t \n\ts = &dev->subdevices[2];\n\ts->type = COMEDI_SUBD_DI;\n\ts->subdev_flags = SDF_READABLE;\n\ts->n_chan = 16;\n\ts->maxdata = 1;\n\ts->range_table = &range_digital;\n\ts->insn_bits = dyna_pci10xx_di_insn_bits;\n\n\t \n\ts = &dev->subdevices[3];\n\ts->type = COMEDI_SUBD_DO;\n\ts->subdev_flags = SDF_WRITABLE;\n\ts->n_chan = 16;\n\ts->maxdata = 1;\n\ts->range_table = &range_digital;\n\ts->state = 0;\n\ts->insn_bits = dyna_pci10xx_do_insn_bits;\n\n\treturn 0;\n}\n\nstatic void dyna_pci10xx_detach(struct comedi_device *dev)\n{\n\tstruct dyna_pci10xx_private *devpriv = dev->private;\n\n\tcomedi_pci_detach(dev);\n\tif (devpriv)\n\t\tmutex_destroy(&devpriv->mutex);\n}\n\nstatic struct comedi_driver dyna_pci10xx_driver = {\n\t.driver_name\t= \"dyna_pci10xx\",\n\t.module\t\t= THIS_MODULE,\n\t.auto_attach\t= dyna_pci10xx_auto_attach,\n\t.detach\t\t= dyna_pci10xx_detach,\n};\n\nstatic int dyna_pci10xx_pci_probe(struct pci_dev *dev,\n\t\t\t\t  const struct pci_device_id *id)\n{\n\treturn comedi_pci_auto_config(dev, &dyna_pci10xx_driver,\n\t\t\t\t      id->driver_data);\n}\n\nstatic const struct pci_device_id dyna_pci10xx_pci_table[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_PLX, 0x1050) },\n\t{ 0 }\n};\nMODULE_DEVICE_TABLE(pci, dyna_pci10xx_pci_table);\n\nstatic struct pci_driver dyna_pci10xx_pci_driver = {\n\t.name\t\t= \"dyna_pci10xx\",\n\t.id_table\t= dyna_pci10xx_pci_table,\n\t.probe\t\t= dyna_pci10xx_pci_probe,\n\t.remove\t\t= comedi_pci_auto_unconfig,\n};\nmodule_comedi_pci_driver(dyna_pci10xx_driver, dyna_pci10xx_pci_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Prashant Shah <pshah.mumbai@gmail.com>\");\nMODULE_DESCRIPTION(\"Comedi based drivers for Dynalog PCI DAQ cards\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}