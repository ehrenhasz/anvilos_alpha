{
  "module_name": "adl_pci9118.c",
  "hash_id": "23fa863211a5c3129675c907ecd921eed7dbcca6b2435e11c4affb098aaf1441",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/adl_pci9118.c",
  "human_readable_source": "\n \n\n \n\n \n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/comedi/comedi_pci.h>\n#include <linux/comedi/comedi_8254.h>\n\n#include \"amcc_s5933.h\"\n\n \n#define PCI9118_TIMER_BASE\t\t0x00\n#define PCI9118_AI_FIFO_REG\t\t0x10\n#define PCI9118_AO_REG(x)\t\t(0x10 + ((x) * 4))\n#define PCI9118_AI_STATUS_REG\t\t0x18\n#define PCI9118_AI_STATUS_NFULL\t\tBIT(8)\t \n#define PCI9118_AI_STATUS_NHFULL\tBIT(7)\t \n#define PCI9118_AI_STATUS_NEPTY\t\tBIT(6)\t \n#define PCI9118_AI_STATUS_ACMP\t\tBIT(5)\t \n#define PCI9118_AI_STATUS_DTH\t\tBIT(4)\t \n#define PCI9118_AI_STATUS_BOVER\t\tBIT(3)\t \n#define PCI9118_AI_STATUS_ADOS\t\tBIT(2)\t \n#define PCI9118_AI_STATUS_ADOR\t\tBIT(1)\t \n#define PCI9118_AI_STATUS_ADRDY\t\tBIT(0)\t \n#define PCI9118_AI_CTRL_REG\t\t0x18\n#define PCI9118_AI_CTRL_UNIP\t\tBIT(7)\t \n#define PCI9118_AI_CTRL_DIFF\t\tBIT(6)\t \n#define PCI9118_AI_CTRL_SOFTG\t\tBIT(5)\t \n#define PCI9118_AI_CTRL_EXTG\t\tBIT(4)\t \n#define PCI9118_AI_CTRL_EXTM\t\tBIT(3)\t \n#define PCI9118_AI_CTRL_TMRTR\t\tBIT(2)\t \n#define PCI9118_AI_CTRL_INT\t\tBIT(1)\t \n#define PCI9118_AI_CTRL_DMA\t\tBIT(0)\t \n#define PCI9118_DIO_REG\t\t\t0x1c\n#define PCI9118_SOFTTRG_REG\t\t0x20\n#define PCI9118_AI_CHANLIST_REG\t\t0x24\n#define PCI9118_AI_CHANLIST_RANGE(x)\t(((x) & 0x3) << 8)\n#define PCI9118_AI_CHANLIST_CHAN(x)\t((x) << 0)\n#define PCI9118_AI_BURST_NUM_REG\t0x28\n#define PCI9118_AI_AUTOSCAN_MODE_REG\t0x2c\n#define PCI9118_AI_CFG_REG\t\t0x30\n#define PCI9118_AI_CFG_PDTRG\t\tBIT(7)\t \n#define PCI9118_AI_CFG_PETRG\t\tBIT(6)\t \n#define PCI9118_AI_CFG_BSSH\t\tBIT(5)\t \n#define PCI9118_AI_CFG_BM\t\tBIT(4)\t \n#define PCI9118_AI_CFG_BS\t\tBIT(3)\t \n#define PCI9118_AI_CFG_PM\t\tBIT(2)\t \n#define PCI9118_AI_CFG_AM\t\tBIT(1)\t \n#define PCI9118_AI_CFG_START\t\tBIT(0)\t \n#define PCI9118_FIFO_RESET_REG\t\t0x34\n#define PCI9118_INT_CTRL_REG\t\t0x38\n#define PCI9118_INT_CTRL_TIMER\t\tBIT(3)\t \n#define PCI9118_INT_CTRL_ABOUT\t\tBIT(2)\t \n#define PCI9118_INT_CTRL_HFULL\t\tBIT(1)\t \n#define PCI9118_INT_CTRL_DTRG\t\tBIT(0)\t \n\n#define START_AI_EXT\t0x01\t \n#define STOP_AI_EXT\t0x02\t \n#define STOP_AI_INT\t0x08\t \n\nstatic const struct comedi_lrange pci9118_ai_range = {\n\t8, {\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(2.5),\n\t\tBIP_RANGE(1.25),\n\t\tBIP_RANGE(0.625),\n\t\tUNI_RANGE(10),\n\t\tUNI_RANGE(5),\n\t\tUNI_RANGE(2.5),\n\t\tUNI_RANGE(1.25)\n\t}\n};\n\nstatic const struct comedi_lrange pci9118hg_ai_range = {\n\t8, {\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(0.5),\n\t\tBIP_RANGE(0.05),\n\t\tBIP_RANGE(0.005),\n\t\tUNI_RANGE(10),\n\t\tUNI_RANGE(1),\n\t\tUNI_RANGE(0.1),\n\t\tUNI_RANGE(0.01)\n\t}\n};\n\nenum pci9118_boardid {\n\tBOARD_PCI9118DG,\n\tBOARD_PCI9118HG,\n\tBOARD_PCI9118HR,\n};\n\nstruct pci9118_boardinfo {\n\tconst char *name;\n\tunsigned int ai_is_16bit:1;\n\tunsigned int is_hg:1;\n};\n\nstatic const struct pci9118_boardinfo pci9118_boards[] = {\n\t[BOARD_PCI9118DG] = {\n\t\t.name\t\t= \"pci9118dg\",\n\t},\n\t[BOARD_PCI9118HG] = {\n\t\t.name\t\t= \"pci9118hg\",\n\t\t.is_hg\t\t= 1,\n\t},\n\t[BOARD_PCI9118HR] = {\n\t\t.name\t\t= \"pci9118hr\",\n\t\t.ai_is_16bit\t= 1,\n\t},\n};\n\nstruct pci9118_dmabuf {\n\tunsigned short *virt;\t \n\tdma_addr_t hw;\t\t \n\tunsigned int size;\t \n\tunsigned int use_size;\t \n};\n\nstruct pci9118_private {\n\tunsigned long iobase_a;\t \n\tunsigned int master:1;\n\tunsigned int dma_doublebuf:1;\n\tunsigned int ai_neverending:1;\n\tunsigned int usedma:1;\n\tunsigned int usemux:1;\n\tunsigned char ai_ctrl;\n\tunsigned char int_ctrl;\n\tunsigned char ai_cfg;\n\tunsigned int ai_do;\t\t \n\tunsigned int ai_n_realscanlen;\t \n\tunsigned int ai_act_dmapos;\t \n\tunsigned int ai_add_front;\t \n\tunsigned int ai_add_back;\t \n\tunsigned int ai_flags;\n\tchar ai12_startstop;\t\t \n\tunsigned int dma_actbuf;\t\t \n\tstruct pci9118_dmabuf dmabuf[2];\n\tint softsshdelay;\t\t \n\tunsigned char softsshsample;\t \n\tunsigned char softsshhold;\t \n\tunsigned int ai_ns_min;\n};\n\nstatic void pci9118_amcc_setup_dma(struct comedi_device *dev, unsigned int buf)\n{\n\tstruct pci9118_private *devpriv = dev->private;\n\tstruct pci9118_dmabuf *dmabuf = &devpriv->dmabuf[buf];\n\n\t \n\toutl(dmabuf->hw, devpriv->iobase_a + AMCC_OP_REG_MWAR);\n\toutl(dmabuf->use_size, devpriv->iobase_a + AMCC_OP_REG_MWTC);\n}\n\nstatic void pci9118_amcc_dma_ena(struct comedi_device *dev, bool enable)\n{\n\tstruct pci9118_private *devpriv = dev->private;\n\tunsigned int mcsr;\n\n\tmcsr = inl(devpriv->iobase_a + AMCC_OP_REG_MCSR);\n\tif (enable)\n\t\tmcsr |= RESET_A2P_FLAGS | A2P_HI_PRIORITY | EN_A2P_TRANSFERS;\n\telse\n\t\tmcsr &= ~EN_A2P_TRANSFERS;\n\toutl(mcsr, devpriv->iobase_a + AMCC_OP_REG_MCSR);\n}\n\nstatic void pci9118_amcc_int_ena(struct comedi_device *dev, bool enable)\n{\n\tstruct pci9118_private *devpriv = dev->private;\n\tunsigned int intcsr;\n\n\t \n\tintcsr = inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR);\n\tif (enable)\n\t\tintcsr |= 0x1f00;\n\telse\n\t\tintcsr &= ~0x1f00;\n\toutl(intcsr, devpriv->iobase_a + AMCC_OP_REG_INTCSR);\n}\n\nstatic void pci9118_ai_reset_fifo(struct comedi_device *dev)\n{\n\t \n\toutl(0, dev->iobase + PCI9118_FIFO_RESET_REG);\n}\n\nstatic int pci9118_ai_check_chanlist(struct comedi_device *dev,\n\t\t\t\t     struct comedi_subdevice *s,\n\t\t\t\t     struct comedi_cmd *cmd)\n{\n\tstruct pci9118_private *devpriv = dev->private;\n\tunsigned int range0 = CR_RANGE(cmd->chanlist[0]);\n\tunsigned int aref0 = CR_AREF(cmd->chanlist[0]);\n\tint i;\n\n\t \n\tif (cmd->chanlist_len == 1)\n\t\treturn 0;\n\n\tfor (i = 1; i < cmd->chanlist_len; i++) {\n\t\tunsigned int chan = CR_CHAN(cmd->chanlist[i]);\n\t\tunsigned int range = CR_RANGE(cmd->chanlist[i]);\n\t\tunsigned int aref = CR_AREF(cmd->chanlist[i]);\n\n\t\tif (aref != aref0) {\n\t\t\tdev_err(dev->class_dev,\n\t\t\t\t\"Differential and single ended inputs can't be mixed!\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (comedi_range_is_bipolar(s, range) !=\n\t\t    comedi_range_is_bipolar(s, range0)) {\n\t\t\tdev_err(dev->class_dev,\n\t\t\t\t\"Bipolar and unipolar ranges can't be mixed!\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!devpriv->usemux && aref == AREF_DIFF &&\n\t\t    (chan >= (s->n_chan / 2))) {\n\t\t\tdev_err(dev->class_dev,\n\t\t\t\t\"AREF_DIFF is only available for the first 8 channels!\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void pci9118_set_chanlist(struct comedi_device *dev,\n\t\t\t\t struct comedi_subdevice *s,\n\t\t\t\t int n_chan, unsigned int *chanlist,\n\t\t\t\t int frontadd, int backadd)\n{\n\tstruct pci9118_private *devpriv = dev->private;\n\tunsigned int chan0 = CR_CHAN(chanlist[0]);\n\tunsigned int range0 = CR_RANGE(chanlist[0]);\n\tunsigned int aref0 = CR_AREF(chanlist[0]);\n\tunsigned int ssh = 0x00;\n\tunsigned int val;\n\tint i;\n\n\t \n\tdevpriv->ai_ctrl = 0;\n\tif (comedi_range_is_unipolar(s, range0))\n\t\tdevpriv->ai_ctrl |= PCI9118_AI_CTRL_UNIP;\n\tif (aref0 == AREF_DIFF)\n\t\tdevpriv->ai_ctrl |= PCI9118_AI_CTRL_DIFF;\n\toutl(devpriv->ai_ctrl, dev->iobase + PCI9118_AI_CTRL_REG);\n\n\t \n\toutl(2, dev->iobase + PCI9118_AI_AUTOSCAN_MODE_REG);\n\toutl(0, dev->iobase + PCI9118_AI_AUTOSCAN_MODE_REG);\n\toutl(1, dev->iobase + PCI9118_AI_AUTOSCAN_MODE_REG);\n\n\t \n\tif (frontadd) {\n\t\tval = PCI9118_AI_CHANLIST_CHAN(chan0) |\n\t\t      PCI9118_AI_CHANLIST_RANGE(range0);\n\t\tssh = devpriv->softsshsample;\n\t\tfor (i = 0; i < frontadd; i++) {\n\t\t\toutl(val | ssh, dev->iobase + PCI9118_AI_CHANLIST_REG);\n\t\t\tssh = devpriv->softsshhold;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < n_chan; i++) {\n\t\tunsigned int chan = CR_CHAN(chanlist[i]);\n\t\tunsigned int range = CR_RANGE(chanlist[i]);\n\n\t\tval = PCI9118_AI_CHANLIST_CHAN(chan) |\n\t\t      PCI9118_AI_CHANLIST_RANGE(range);\n\t\toutl(val | ssh, dev->iobase + PCI9118_AI_CHANLIST_REG);\n\t}\n\n\t \n\tif (backadd) {\n\t\tval = PCI9118_AI_CHANLIST_CHAN(chan0) |\n\t\t      PCI9118_AI_CHANLIST_RANGE(range0);\n\t\tfor (i = 0; i < backadd; i++)\n\t\t\toutl(val | ssh, dev->iobase + PCI9118_AI_CHANLIST_REG);\n\t}\n\t \n\toutl(0, dev->iobase + PCI9118_AI_AUTOSCAN_MODE_REG);\n\t \n}\n\nstatic void pci9118_ai_mode4_switch(struct comedi_device *dev,\n\t\t\t\t    unsigned int next_buf)\n{\n\tstruct pci9118_private *devpriv = dev->private;\n\tstruct pci9118_dmabuf *dmabuf = &devpriv->dmabuf[next_buf];\n\n\tdevpriv->ai_cfg = PCI9118_AI_CFG_PDTRG | PCI9118_AI_CFG_PETRG |\n\t\t\t  PCI9118_AI_CFG_AM;\n\toutl(devpriv->ai_cfg, dev->iobase + PCI9118_AI_CFG_REG);\n\tcomedi_8254_load(dev->pacer, 0, dmabuf->hw >> 1,\n\t\t\t I8254_MODE0 | I8254_BINARY);\n\tdevpriv->ai_cfg |= PCI9118_AI_CFG_START;\n\toutl(devpriv->ai_cfg, dev->iobase + PCI9118_AI_CFG_REG);\n}\n\nstatic unsigned int pci9118_ai_samples_ready(struct comedi_device *dev,\n\t\t\t\t\t     struct comedi_subdevice *s,\n\t\t\t\t\t     unsigned int n_raw_samples)\n{\n\tstruct pci9118_private *devpriv = dev->private;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tunsigned int start_pos = devpriv->ai_add_front;\n\tunsigned int stop_pos = start_pos + cmd->chanlist_len;\n\tunsigned int span_len = stop_pos + devpriv->ai_add_back;\n\tunsigned int dma_pos = devpriv->ai_act_dmapos;\n\tunsigned int whole_spans, n_samples, x;\n\n\tif (span_len == cmd->chanlist_len)\n\t\treturn n_raw_samples;\t \n\n\t \n\twhole_spans = n_raw_samples / span_len;\n\tn_samples = whole_spans * cmd->chanlist_len;\n\tn_raw_samples -= whole_spans * span_len;\n\n\t \n\twhile (n_raw_samples) {\n\t\tif (dma_pos < start_pos) {\n\t\t\t \n\t\t\tx = start_pos - dma_pos;\n\t\t\tif (x > n_raw_samples)\n\t\t\t\tx = n_raw_samples;\n\t\t\tdma_pos += x;\n\t\t\tn_raw_samples -= x;\n\t\t\tif (!n_raw_samples)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (dma_pos < stop_pos) {\n\t\t\t \n\t\t\tx = stop_pos - dma_pos;\n\t\t\tif (x > n_raw_samples)\n\t\t\t\tx = n_raw_samples;\n\t\t\tn_samples += x;\n\t\t\tdma_pos += x;\n\t\t\tn_raw_samples -= x;\n\t\t}\n\t\t \n\t\tstart_pos += span_len;\n\t\tstop_pos += span_len;\n\t}\n\treturn n_samples;\n}\n\nstatic void pci9118_ai_dma_xfer(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tunsigned short *dma_buffer,\n\t\t\t\tunsigned int n_raw_samples)\n{\n\tstruct pci9118_private *devpriv = dev->private;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tunsigned int start_pos = devpriv->ai_add_front;\n\tunsigned int stop_pos = start_pos + cmd->chanlist_len;\n\tunsigned int span_len = stop_pos + devpriv->ai_add_back;\n\tunsigned int dma_pos = devpriv->ai_act_dmapos;\n\tunsigned int x;\n\n\tif (span_len == cmd->chanlist_len) {\n\t\t \n\t\tcomedi_buf_write_samples(s, dma_buffer, n_raw_samples);\n\t\tdma_pos += n_raw_samples;\n\t} else {\n\t\t \n\t\twhile (n_raw_samples) {\n\t\t\tif (dma_pos < start_pos) {\n\t\t\t\t \n\t\t\t\tx = start_pos - dma_pos;\n\t\t\t\tif (x > n_raw_samples)\n\t\t\t\t\tx = n_raw_samples;\n\t\t\t\tdma_pos += x;\n\t\t\t\tn_raw_samples -= x;\n\t\t\t\tif (!n_raw_samples)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (dma_pos < stop_pos) {\n\t\t\t\t \n\t\t\t\tx = stop_pos - dma_pos;\n\t\t\t\tif (x > n_raw_samples)\n\t\t\t\t\tx = n_raw_samples;\n\t\t\t\tcomedi_buf_write_samples(s, dma_buffer, x);\n\t\t\t\tdma_pos += x;\n\t\t\t\tn_raw_samples -= x;\n\t\t\t}\n\t\t\t \n\t\t\tstart_pos += span_len;\n\t\t\tstop_pos += span_len;\n\t\t}\n\t}\n\t \n\tdevpriv->ai_act_dmapos = dma_pos % span_len;\n}\n\nstatic void pci9118_exttrg_enable(struct comedi_device *dev, bool enable)\n{\n\tstruct pci9118_private *devpriv = dev->private;\n\n\tif (enable)\n\t\tdevpriv->int_ctrl |= PCI9118_INT_CTRL_DTRG;\n\telse\n\t\tdevpriv->int_ctrl &= ~PCI9118_INT_CTRL_DTRG;\n\toutl(devpriv->int_ctrl, dev->iobase + PCI9118_INT_CTRL_REG);\n\n\tif (devpriv->int_ctrl)\n\t\tpci9118_amcc_int_ena(dev, true);\n\telse\n\t\tpci9118_amcc_int_ena(dev, false);\n}\n\nstatic void pci9118_calc_divisors(struct comedi_device *dev,\n\t\t\t\t  struct comedi_subdevice *s,\n\t\t\t\t  unsigned int *tim1, unsigned int *tim2,\n\t\t\t\t  unsigned int flags, int chans,\n\t\t\t\t  unsigned int *div1, unsigned int *div2,\n\t\t\t\t  unsigned int chnsshfront)\n{\n\tstruct comedi_8254 *pacer = dev->pacer;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\n\t*div1 = *tim2 / pacer->osc_base;\t \n\t*div2 = *tim1 / pacer->osc_base;\t \n\t*div2 = *div2 / *div1;\t\t\t \n\tif (*div2 < chans)\n\t\t*div2 = chans;\n\n\t*tim2 = *div1 * pacer->osc_base;\t \n\n\tif (cmd->convert_src == TRIG_NOW && !chnsshfront) {\n\t\t \n\t\tif (*div2 < (chans + 2))\n\t\t\t*div2 = chans + 2;\n\t}\n\n\t*tim1 = *div1 * *div2 * pacer->osc_base;\n}\n\nstatic void pci9118_start_pacer(struct comedi_device *dev, int mode)\n{\n\tif (mode == 1 || mode == 2 || mode == 4)\n\t\tcomedi_8254_pacer_enable(dev->pacer, 1, 2, true);\n}\n\nstatic int pci9118_ai_cancel(struct comedi_device *dev,\n\t\t\t     struct comedi_subdevice *s)\n{\n\tstruct pci9118_private *devpriv = dev->private;\n\n\tif (devpriv->usedma)\n\t\tpci9118_amcc_dma_ena(dev, false);\n\tpci9118_exttrg_enable(dev, false);\n\tcomedi_8254_pacer_enable(dev->pacer, 1, 2, false);\n\t \n\tdevpriv->ai_cfg = PCI9118_AI_CFG_PDTRG | PCI9118_AI_CFG_PETRG;\n\toutl(devpriv->ai_cfg, dev->iobase + PCI9118_AI_CFG_REG);\n\t \n\tdevpriv->ai_ctrl = 0;\n\toutl(devpriv->ai_ctrl, dev->iobase + PCI9118_AI_CTRL_REG);\n\toutl(0, dev->iobase + PCI9118_AI_BURST_NUM_REG);\n\t \n\toutl(1, dev->iobase + PCI9118_AI_AUTOSCAN_MODE_REG);\n\toutl(2, dev->iobase + PCI9118_AI_AUTOSCAN_MODE_REG);\n\tpci9118_ai_reset_fifo(dev);\n\n\tdevpriv->int_ctrl = 0;\n\toutl(devpriv->int_ctrl, dev->iobase + PCI9118_INT_CTRL_REG);\n\tpci9118_amcc_int_ena(dev, false);\n\n\tdevpriv->ai_do = 0;\n\tdevpriv->usedma = 0;\n\n\tdevpriv->ai_act_dmapos = 0;\n\ts->async->inttrig = NULL;\n\tdevpriv->ai_neverending = 0;\n\tdevpriv->dma_actbuf = 0;\n\n\treturn 0;\n}\n\nstatic void pci9118_ai_munge(struct comedi_device *dev,\n\t\t\t     struct comedi_subdevice *s, void *data,\n\t\t\t     unsigned int num_bytes,\n\t\t\t     unsigned int start_chan_index)\n{\n\tstruct pci9118_private *devpriv = dev->private;\n\tunsigned short *array = data;\n\tunsigned int num_samples = comedi_bytes_to_samples(s, num_bytes);\n\tunsigned int i;\n\t__be16 *barray = data;\n\n\tfor (i = 0; i < num_samples; i++) {\n\t\tif (devpriv->usedma)\n\t\t\tarray[i] = be16_to_cpu(barray[i]);\n\t\tif (s->maxdata == 0xffff)\n\t\t\tarray[i] ^= 0x8000;\n\t\telse\n\t\t\tarray[i] = (array[i] >> 4) & 0x0fff;\n\t}\n}\n\nstatic void pci9118_ai_get_onesample(struct comedi_device *dev,\n\t\t\t\t     struct comedi_subdevice *s)\n{\n\tstruct pci9118_private *devpriv = dev->private;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tunsigned short sampl;\n\n\tsampl = inl(dev->iobase + PCI9118_AI_FIFO_REG);\n\n\tcomedi_buf_write_samples(s, &sampl, 1);\n\n\tif (!devpriv->ai_neverending) {\n\t\tif (s->async->scans_done >= cmd->stop_arg)\n\t\t\ts->async->events |= COMEDI_CB_EOA;\n\t}\n}\n\nstatic void pci9118_ai_get_dma(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s)\n{\n\tstruct pci9118_private *devpriv = dev->private;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tstruct pci9118_dmabuf *dmabuf = &devpriv->dmabuf[devpriv->dma_actbuf];\n\tunsigned int n_all = comedi_bytes_to_samples(s, dmabuf->use_size);\n\tunsigned int n_valid;\n\tbool more_dma;\n\n\t \n\tn_valid = pci9118_ai_samples_ready(dev, s, n_all);\n\tmore_dma = n_valid < comedi_nsamples_left(s, n_valid + 1);\n\n\t \n\tif (more_dma && devpriv->dma_doublebuf) {\n\t\tdevpriv->dma_actbuf = 1 - devpriv->dma_actbuf;\n\t\tpci9118_amcc_setup_dma(dev, devpriv->dma_actbuf);\n\t\tif (devpriv->ai_do == 4)\n\t\t\tpci9118_ai_mode4_switch(dev, devpriv->dma_actbuf);\n\t}\n\n\tif (n_all)\n\t\tpci9118_ai_dma_xfer(dev, s, dmabuf->virt, n_all);\n\n\tif (!devpriv->ai_neverending) {\n\t\tif (s->async->scans_done >= cmd->stop_arg)\n\t\t\ts->async->events |= COMEDI_CB_EOA;\n\t}\n\n\tif (s->async->events & COMEDI_CB_CANCEL_MASK)\n\t\tmore_dma = false;\n\n\t \n\tif (more_dma && !devpriv->dma_doublebuf) {\n\t\tpci9118_amcc_setup_dma(dev, 0);\n\t\tif (devpriv->ai_do == 4)\n\t\t\tpci9118_ai_mode4_switch(dev, 0);\n\t}\n}\n\nstatic irqreturn_t pci9118_interrupt(int irq, void *d)\n{\n\tstruct comedi_device *dev = d;\n\tstruct comedi_subdevice *s = dev->read_subdev;\n\tstruct pci9118_private *devpriv = dev->private;\n\tunsigned int intsrc;\t \n\tunsigned int intcsr;\t \n\tunsigned int adstat;\t \n\n\tif (!dev->attached)\n\t\treturn IRQ_NONE;\n\n\tintsrc = inl(dev->iobase + PCI9118_INT_CTRL_REG) & 0xf;\n\tintcsr = inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR);\n\n\tif (!intsrc && !(intcsr & ANY_S593X_INT))\n\t\treturn IRQ_NONE;\n\n\toutl(intcsr | 0x00ff0000, devpriv->iobase_a + AMCC_OP_REG_INTCSR);\n\n\tif (intcsr & MASTER_ABORT_INT) {\n\t\tdev_err(dev->class_dev, \"AMCC IRQ - MASTER DMA ABORT!\\n\");\n\t\ts->async->events |= COMEDI_CB_ERROR;\n\t\tgoto interrupt_exit;\n\t}\n\n\tif (intcsr & TARGET_ABORT_INT) {\n\t\tdev_err(dev->class_dev, \"AMCC IRQ - TARGET DMA ABORT!\\n\");\n\t\ts->async->events |= COMEDI_CB_ERROR;\n\t\tgoto interrupt_exit;\n\t}\n\n\tadstat = inl(dev->iobase + PCI9118_AI_STATUS_REG);\n\tif ((adstat & PCI9118_AI_STATUS_NFULL) == 0) {\n\t\tdev_err(dev->class_dev,\n\t\t\t\"A/D FIFO Full status (Fatal Error!)\\n\");\n\t\ts->async->events |= COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW;\n\t\tgoto interrupt_exit;\n\t}\n\tif (adstat & PCI9118_AI_STATUS_BOVER) {\n\t\tdev_err(dev->class_dev,\n\t\t\t\"A/D Burst Mode Overrun Status (Fatal Error!)\\n\");\n\t\ts->async->events |= COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW;\n\t\tgoto interrupt_exit;\n\t}\n\tif (adstat & PCI9118_AI_STATUS_ADOS) {\n\t\tdev_err(dev->class_dev, \"A/D Over Speed Status (Warning!)\\n\");\n\t\ts->async->events |= COMEDI_CB_ERROR;\n\t\tgoto interrupt_exit;\n\t}\n\tif (adstat & PCI9118_AI_STATUS_ADOR) {\n\t\tdev_err(dev->class_dev, \"A/D Overrun Status (Fatal Error!)\\n\");\n\t\ts->async->events |= COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW;\n\t\tgoto interrupt_exit;\n\t}\n\n\tif (!devpriv->ai_do)\n\t\treturn IRQ_HANDLED;\n\n\tif (devpriv->ai12_startstop) {\n\t\tif ((adstat & PCI9118_AI_STATUS_DTH) &&\n\t\t    (intsrc & PCI9118_INT_CTRL_DTRG)) {\n\t\t\t \n\t\t\tif (devpriv->ai12_startstop & START_AI_EXT) {\n\t\t\t\t \n\t\t\t\tdevpriv->ai12_startstop &= ~START_AI_EXT;\n\t\t\t\tif (!(devpriv->ai12_startstop & STOP_AI_EXT))\n\t\t\t\t\tpci9118_exttrg_enable(dev, false);\n\n\t\t\t\t \n\t\t\t\tpci9118_start_pacer(dev, devpriv->ai_do);\n\t\t\t\toutl(devpriv->ai_ctrl,\n\t\t\t\t     dev->iobase + PCI9118_AI_CTRL_REG);\n\t\t\t} else if (devpriv->ai12_startstop & STOP_AI_EXT) {\n\t\t\t\t \n\t\t\t\tdevpriv->ai12_startstop &= ~STOP_AI_EXT;\n\t\t\t\tpci9118_exttrg_enable(dev, false);\n\n\t\t\t\t \n\t\t\t\tdevpriv->ai_neverending = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (devpriv->usedma)\n\t\tpci9118_ai_get_dma(dev, s);\n\telse\n\t\tpci9118_ai_get_onesample(dev, s);\n\ninterrupt_exit:\n\tcomedi_handle_events(dev, s);\n\treturn IRQ_HANDLED;\n}\n\nstatic void pci9118_ai_cmd_start(struct comedi_device *dev)\n{\n\tstruct pci9118_private *devpriv = dev->private;\n\n\toutl(devpriv->int_ctrl, dev->iobase + PCI9118_INT_CTRL_REG);\n\toutl(devpriv->ai_cfg, dev->iobase + PCI9118_AI_CFG_REG);\n\tif (devpriv->ai_do != 3) {\n\t\tpci9118_start_pacer(dev, devpriv->ai_do);\n\t\tdevpriv->ai_ctrl |= PCI9118_AI_CTRL_SOFTG;\n\t}\n\toutl(devpriv->ai_ctrl, dev->iobase + PCI9118_AI_CTRL_REG);\n}\n\nstatic int pci9118_ai_inttrig(struct comedi_device *dev,\n\t\t\t      struct comedi_subdevice *s,\n\t\t\t      unsigned int trig_num)\n{\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\n\tif (trig_num != cmd->start_arg)\n\t\treturn -EINVAL;\n\n\ts->async->inttrig = NULL;\n\tpci9118_ai_cmd_start(dev);\n\n\treturn 1;\n}\n\nstatic int pci9118_ai_setup_dma(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s)\n{\n\tstruct pci9118_private *devpriv = dev->private;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tstruct pci9118_dmabuf *dmabuf0 = &devpriv->dmabuf[0];\n\tstruct pci9118_dmabuf *dmabuf1 = &devpriv->dmabuf[1];\n\tunsigned int dmalen0 = dmabuf0->size;\n\tunsigned int dmalen1 = dmabuf1->size;\n\tunsigned int scan_bytes = devpriv->ai_n_realscanlen *\n\t\t\t\t  comedi_bytes_per_sample(s);\n\n\t \n\tif (dmalen0 > s->async->prealloc_bufsz) {\n\t\t \n\t\tdmalen0 = s->async->prealloc_bufsz & ~3L;\n\t}\n\tif (dmalen1 > s->async->prealloc_bufsz) {\n\t\t \n\t\tdmalen1 = s->async->prealloc_bufsz & ~3L;\n\t}\n\n\t \n\tif (devpriv->ai_flags & CMDF_WAKE_EOS) {\n\t\tif (dmalen0 < scan_bytes) {\n\t\t\t \n\t\t\tdevpriv->ai_flags &= (~CMDF_WAKE_EOS);\n\t\t\tdev_info(dev->class_dev,\n\t\t\t\t \"WAR: DMA0 buf too short, can't support CMDF_WAKE_EOS (%d<%d)\\n\",\n\t\t\t\t  dmalen0, scan_bytes);\n\t\t} else {\n\t\t\t \n\t\t\tdmalen0 = scan_bytes;\n\t\t\tif (dmalen0 < 4) {\n\t\t\t\tdev_info(dev->class_dev,\n\t\t\t\t\t \"ERR: DMA0 buf len bug? (%d<4)\\n\",\n\t\t\t\t\t dmalen0);\n\t\t\t\tdmalen0 = 4;\n\t\t\t}\n\t\t}\n\t}\n\tif (devpriv->ai_flags & CMDF_WAKE_EOS) {\n\t\tif (dmalen1 < scan_bytes) {\n\t\t\t \n\t\t\tdevpriv->ai_flags &= (~CMDF_WAKE_EOS);\n\t\t\tdev_info(dev->class_dev,\n\t\t\t\t \"WAR: DMA1 buf too short, can't support CMDF_WAKE_EOS (%d<%d)\\n\",\n\t\t\t\t dmalen1, scan_bytes);\n\t\t} else {\n\t\t\t \n\t\t\tdmalen1 = scan_bytes;\n\t\t\tif (dmalen1 < 4) {\n\t\t\t\tdev_info(dev->class_dev,\n\t\t\t\t\t \"ERR: DMA1 buf len bug? (%d<4)\\n\",\n\t\t\t\t\t dmalen1);\n\t\t\t\tdmalen1 = 4;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (!(devpriv->ai_flags & CMDF_WAKE_EOS)) {\n\t\tunsigned int tmp;\n\n\t\t \n\t\ttmp = dmalen0;\n\t\tdmalen0 = (dmalen0 / scan_bytes) * scan_bytes;\n\t\tdmalen0 &= ~3L;\n\t\tif (!dmalen0)\n\t\t\tdmalen0 = tmp;\t \n\t\ttmp = dmalen1;\n\t\tdmalen1 = (dmalen1 / scan_bytes) * scan_bytes;\n\t\tdmalen1 &= ~3L;\n\t\tif (!dmalen1)\n\t\t\tdmalen1 = tmp;\t \n\t\t \n\t\tif (!devpriv->ai_neverending) {\n\t\t\tunsigned long long scanlen;\n\n\t\t\tscanlen = (unsigned long long)scan_bytes *\n\t\t\t\t  cmd->stop_arg;\n\n\t\t\t \n\t\t\tif (dmalen0 > scanlen) {\n\t\t\t\tdmalen0 = scanlen;\n\t\t\t\tdmalen0 &= ~3L;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (dmalen1 > (scanlen - dmalen0)) {\n\t\t\t\t\tdmalen1 = scanlen - dmalen0;\n\t\t\t\t\tdmalen1 &= ~3L;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tdevpriv->dma_actbuf = 0;\n\tdmabuf0->use_size = dmalen0;\n\tdmabuf1->use_size = dmalen1;\n\n\tpci9118_amcc_dma_ena(dev, false);\n\tpci9118_amcc_setup_dma(dev, 0);\n\t \n\toutl(0x00000000 | AINT_WRITE_COMPL,\n\t     devpriv->iobase_a + AMCC_OP_REG_INTCSR);\n \n\tpci9118_amcc_dma_ena(dev, true);\n\toutl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) | EN_A2P_TRANSFERS,\n\t     devpriv->iobase_a + AMCC_OP_REG_INTCSR);\n\t\t\t\t\t\t \n\n\treturn 0;\n}\n\nstatic int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\n{\n\tstruct pci9118_private *devpriv = dev->private;\n\tstruct comedi_8254 *pacer = dev->pacer;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tunsigned int addchans = 0;\n\tunsigned int scanlen;\n\n\tdevpriv->ai12_startstop = 0;\n\tdevpriv->ai_flags = cmd->flags;\n\tdevpriv->ai_add_front = 0;\n\tdevpriv->ai_add_back = 0;\n\n\t \n\tif (cmd->start_src == TRIG_EXT)\n\t\tdevpriv->ai12_startstop |= START_AI_EXT;\n\tif (cmd->stop_src == TRIG_EXT) {\n\t\tdevpriv->ai_neverending = 1;\n\t\tdevpriv->ai12_startstop |= STOP_AI_EXT;\n\t}\n\tif (cmd->stop_src == TRIG_NONE)\n\t\tdevpriv->ai_neverending = 1;\n\tif (cmd->stop_src == TRIG_COUNT)\n\t\tdevpriv->ai_neverending = 0;\n\n\t \n\tdevpriv->ai_add_front = 0;\n\tdevpriv->ai_add_back = 0;\n\tif (devpriv->master) {\n\t\tdevpriv->usedma = 1;\n\t\tif ((cmd->flags & CMDF_WAKE_EOS) &&\n\t\t    (cmd->scan_end_arg == 1)) {\n\t\t\tif (cmd->convert_src == TRIG_NOW)\n\t\t\t\tdevpriv->ai_add_back = 1;\n\t\t\tif (cmd->convert_src == TRIG_TIMER) {\n\t\t\t\tdevpriv->usedma = 0;\n\t\t\t\t\t \n\t\t\t}\n\t\t}\n\t\tif ((cmd->flags & CMDF_WAKE_EOS) &&\n\t\t    (cmd->scan_end_arg & 1) &&\n\t\t    (cmd->scan_end_arg > 1)) {\n\t\t\tif (cmd->scan_begin_src == TRIG_FOLLOW) {\n\t\t\t\tdevpriv->usedma = 0;\n\t\t\t\t \n\t\t\t} else {\t \n\t\t\t\tdevpriv->ai_add_back = 1;\n\t\t\t}\n\t\t}\n\t} else {\t \n\t\tdevpriv->usedma = 0;\n\t}\n\n\t \n\tif (cmd->convert_src == TRIG_NOW && devpriv->softsshdelay) {\n\t\tdevpriv->ai_add_front = 2;\n\t\tif ((devpriv->usedma == 1) && (devpriv->ai_add_back == 1)) {\n\t\t\t\t\t\t\t \n\t\t\tdevpriv->ai_add_front++;\n\t\t\tdevpriv->ai_add_back = 0;\n\t\t}\n\t\tif (cmd->convert_arg < devpriv->ai_ns_min)\n\t\t\tcmd->convert_arg = devpriv->ai_ns_min;\n\t\taddchans = devpriv->softsshdelay / cmd->convert_arg;\n\t\tif (devpriv->softsshdelay % cmd->convert_arg)\n\t\t\taddchans++;\n\t\tif (addchans > (devpriv->ai_add_front - 1)) {\n\t\t\t\t\t\t\t \n\t\t\tdevpriv->ai_add_front = addchans + 1;\n\t\t\tif (devpriv->usedma == 1)\n\t\t\t\tif ((devpriv->ai_add_front +\n\t\t\t\t     cmd->chanlist_len +\n\t\t\t\t     devpriv->ai_add_back) & 1)\n\t\t\t\t\tdevpriv->ai_add_front++;\n\t\t\t\t\t\t\t \n\t\t}\n\t}\n\t \n\tscanlen = devpriv->ai_add_front + cmd->chanlist_len +\n\t\t  devpriv->ai_add_back;\n\t \n\tdevpriv->ai_n_realscanlen = scanlen *\n\t\t\t\t    (cmd->scan_end_arg / cmd->chanlist_len);\n\n\tif (scanlen > s->len_chanlist) {\n\t\tdev_err(dev->class_dev,\n\t\t\t\"range/channel list is too long for actual configuration!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tpci9118_set_chanlist(dev, s, cmd->chanlist_len, cmd->chanlist,\n\t\t\t     devpriv->ai_add_front, devpriv->ai_add_back);\n\n\t \n\tdevpriv->ai_do = 0;\n\tif (cmd->scan_begin_src != TRIG_TIMER &&\n\t    cmd->convert_src == TRIG_TIMER) {\n\t\t \n\t\tif (cmd->scan_begin_src == TRIG_EXT)\n\t\t\tdevpriv->ai_do = 4;\n\t\telse\n\t\t\tdevpriv->ai_do = 1;\n\n\t\tcomedi_8254_cascade_ns_to_timer(pacer, &cmd->convert_arg,\n\t\t\t\t\t\tdevpriv->ai_flags &\n\t\t\t\t\t\tCMDF_ROUND_NEAREST);\n\t\tcomedi_8254_update_divisors(pacer);\n\n\t\tdevpriv->ai_ctrl |= PCI9118_AI_CTRL_TMRTR;\n\n\t\tif (!devpriv->usedma) {\n\t\t\tdevpriv->ai_ctrl |= PCI9118_AI_CTRL_INT;\n\t\t\tdevpriv->int_ctrl |= PCI9118_INT_CTRL_TIMER;\n\t\t}\n\n\t\tif (cmd->scan_begin_src == TRIG_EXT) {\n\t\t\tstruct pci9118_dmabuf *dmabuf = &devpriv->dmabuf[0];\n\n\t\t\tdevpriv->ai_cfg |= PCI9118_AI_CFG_AM;\n\t\t\toutl(devpriv->ai_cfg, dev->iobase + PCI9118_AI_CFG_REG);\n\t\t\tcomedi_8254_load(pacer, 0, dmabuf->hw >> 1,\n\t\t\t\t\t I8254_MODE0 | I8254_BINARY);\n\t\t\tdevpriv->ai_cfg |= PCI9118_AI_CFG_START;\n\t\t}\n\t}\n\n\tif (cmd->scan_begin_src == TRIG_TIMER &&\n\t    cmd->convert_src != TRIG_EXT) {\n\t\tif (!devpriv->usedma) {\n\t\t\tdev_err(dev->class_dev,\n\t\t\t\t\"cmd->scan_begin_src=TRIG_TIMER works only with bus mastering!\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t \n\t\tdevpriv->ai_do = 2;\n\n\t\tpci9118_calc_divisors(dev, s,\n\t\t\t\t      &cmd->scan_begin_arg, &cmd->convert_arg,\n\t\t\t\t      devpriv->ai_flags,\n\t\t\t\t      devpriv->ai_n_realscanlen,\n\t\t\t\t      &pacer->divisor1,\n\t\t\t\t      &pacer->divisor2,\n\t\t\t\t      devpriv->ai_add_front);\n\n\t\tdevpriv->ai_ctrl |= PCI9118_AI_CTRL_TMRTR;\n\t\tdevpriv->ai_cfg |= PCI9118_AI_CFG_BM | PCI9118_AI_CFG_BS;\n\t\tif (cmd->convert_src == TRIG_NOW && !devpriv->softsshdelay)\n\t\t\tdevpriv->ai_cfg |= PCI9118_AI_CFG_BSSH;\n\t\toutl(devpriv->ai_n_realscanlen,\n\t\t     dev->iobase + PCI9118_AI_BURST_NUM_REG);\n\t}\n\n\tif (cmd->scan_begin_src == TRIG_FOLLOW &&\n\t    cmd->convert_src == TRIG_EXT) {\n\t\t \n\t\tdevpriv->ai_do = 3;\n\n\t\tdevpriv->ai_ctrl |= PCI9118_AI_CTRL_EXTM;\n\t}\n\n\tif (devpriv->ai_do == 0) {\n\t\tdev_err(dev->class_dev,\n\t\t\t\"Unable to determine acquisition mode! BUG in (*do_cmdtest)?\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (devpriv->usedma)\n\t\tdevpriv->ai_ctrl |= PCI9118_AI_CTRL_DMA;\n\n\t \n\tdevpriv->ai_cfg = PCI9118_AI_CFG_PDTRG | PCI9118_AI_CFG_PETRG;\n\toutl(devpriv->ai_cfg, dev->iobase + PCI9118_AI_CFG_REG);\n\tudelay(1);\n\tpci9118_ai_reset_fifo(dev);\n\n\t \n\tinl(dev->iobase + PCI9118_AI_STATUS_REG);\n\tinl(dev->iobase + PCI9118_INT_CTRL_REG);\n\n\tdevpriv->ai_act_dmapos = 0;\n\n\tif (devpriv->usedma) {\n\t\tpci9118_ai_setup_dma(dev, s);\n\n\t\toutl(0x02000000 | AINT_WRITE_COMPL,\n\t\t     devpriv->iobase_a + AMCC_OP_REG_INTCSR);\n\t} else {\n\t\tpci9118_amcc_int_ena(dev, true);\n\t}\n\n\t \n\tif (cmd->start_src == TRIG_NOW)\n\t\tpci9118_ai_cmd_start(dev);\n\telse if (cmd->start_src == TRIG_INT)\n\t\ts->async->inttrig = pci9118_ai_inttrig;\n\n\t \n\tif (cmd->start_src == TRIG_EXT || cmd->stop_src == TRIG_EXT)\n\t\tpci9118_exttrg_enable(dev, true);\n\n\treturn 0;\n}\n\nstatic int pci9118_ai_cmdtest(struct comedi_device *dev,\n\t\t\t      struct comedi_subdevice *s,\n\t\t\t      struct comedi_cmd *cmd)\n{\n\tstruct pci9118_private *devpriv = dev->private;\n\tint err = 0;\n\tunsigned int flags;\n\tunsigned int arg;\n\n\t \n\n\terr |= comedi_check_trigger_src(&cmd->start_src,\n\t\t\t\t\tTRIG_NOW | TRIG_EXT | TRIG_INT);\n\n\tflags = TRIG_FOLLOW;\n\tif (devpriv->master)\n\t\tflags |= TRIG_TIMER | TRIG_EXT;\n\terr |= comedi_check_trigger_src(&cmd->scan_begin_src, flags);\n\n\tflags = TRIG_TIMER | TRIG_EXT;\n\tif (devpriv->master)\n\t\tflags |= TRIG_NOW;\n\terr |= comedi_check_trigger_src(&cmd->convert_src, flags);\n\n\terr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\n\terr |= comedi_check_trigger_src(&cmd->stop_src,\n\t\t\t\t\tTRIG_COUNT | TRIG_NONE | TRIG_EXT);\n\n\tif (err)\n\t\treturn 1;\n\n\t \n\n\terr |= comedi_check_trigger_is_unique(cmd->start_src);\n\terr |= comedi_check_trigger_is_unique(cmd->scan_begin_src);\n\terr |= comedi_check_trigger_is_unique(cmd->convert_src);\n\terr |= comedi_check_trigger_is_unique(cmd->stop_src);\n\n\t \n\n\tif (cmd->start_src == TRIG_EXT && cmd->scan_begin_src == TRIG_EXT)\n\t\terr |= -EINVAL;\n\n\tif ((cmd->scan_begin_src & (TRIG_TIMER | TRIG_EXT)) &&\n\t    (!(cmd->convert_src & (TRIG_TIMER | TRIG_NOW))))\n\t\terr |= -EINVAL;\n\n\tif ((cmd->scan_begin_src == TRIG_FOLLOW) &&\n\t    (!(cmd->convert_src & (TRIG_TIMER | TRIG_EXT))))\n\t\terr |= -EINVAL;\n\n\tif (cmd->stop_src == TRIG_EXT && cmd->scan_begin_src == TRIG_EXT)\n\t\terr |= -EINVAL;\n\n\tif (err)\n\t\treturn 2;\n\n\t \n\n\tswitch (cmd->start_src) {\n\tcase TRIG_NOW:\n\tcase TRIG_EXT:\n\t\terr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\n\t\tbreak;\n\tcase TRIG_INT:\n\t\t \n\t\tbreak;\n\t}\n\n\tif (cmd->scan_begin_src & (TRIG_FOLLOW | TRIG_EXT))\n\t\terr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);\n\n\tif ((cmd->scan_begin_src == TRIG_TIMER) &&\n\t    (cmd->convert_src == TRIG_TIMER) && (cmd->scan_end_arg == 1)) {\n\t\tcmd->scan_begin_src = TRIG_FOLLOW;\n\t\tcmd->convert_arg = cmd->scan_begin_arg;\n\t\tcmd->scan_begin_arg = 0;\n\t}\n\n\tif (cmd->scan_begin_src == TRIG_TIMER) {\n\t\terr |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,\n\t\t\t\t\t\t    devpriv->ai_ns_min);\n\t}\n\n\tif (cmd->scan_begin_src == TRIG_EXT) {\n\t\tif (cmd->scan_begin_arg) {\n\t\t\tcmd->scan_begin_arg = 0;\n\t\t\terr |= -EINVAL;\n\t\t\terr |= comedi_check_trigger_arg_max(&cmd->scan_end_arg,\n\t\t\t\t\t\t\t    65535);\n\t\t}\n\t}\n\n\tif (cmd->convert_src & (TRIG_TIMER | TRIG_NOW)) {\n\t\terr |= comedi_check_trigger_arg_min(&cmd->convert_arg,\n\t\t\t\t\t\t    devpriv->ai_ns_min);\n\t}\n\n\tif (cmd->convert_src == TRIG_EXT)\n\t\terr |= comedi_check_trigger_arg_is(&cmd->convert_arg, 0);\n\n\tif (cmd->stop_src == TRIG_COUNT)\n\t\terr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\n\telse\t \n\t\terr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\n\n\terr |= comedi_check_trigger_arg_min(&cmd->chanlist_len, 1);\n\n\terr |= comedi_check_trigger_arg_min(&cmd->scan_end_arg,\n\t\t\t\t\t    cmd->chanlist_len);\n\n\tif ((cmd->scan_end_arg % cmd->chanlist_len)) {\n\t\tcmd->scan_end_arg =\n\t\t    cmd->chanlist_len * (cmd->scan_end_arg / cmd->chanlist_len);\n\t\terr |= -EINVAL;\n\t}\n\n\tif (err)\n\t\treturn 3;\n\n\t \n\n\tif (cmd->scan_begin_src == TRIG_TIMER) {\n\t\targ = cmd->scan_begin_arg;\n\t\tcomedi_8254_cascade_ns_to_timer(dev->pacer, &arg, cmd->flags);\n\t\terr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, arg);\n\t}\n\n\tif (cmd->convert_src & (TRIG_TIMER | TRIG_NOW)) {\n\t\targ = cmd->convert_arg;\n\t\tcomedi_8254_cascade_ns_to_timer(dev->pacer, &arg, cmd->flags);\n\t\terr |= comedi_check_trigger_arg_is(&cmd->convert_arg, arg);\n\n\t\tif (cmd->scan_begin_src == TRIG_TIMER &&\n\t\t    cmd->convert_src == TRIG_NOW) {\n\t\t\tif (cmd->convert_arg == 0) {\n\t\t\t\targ = devpriv->ai_ns_min *\n\t\t\t\t      (cmd->scan_end_arg + 2);\n\t\t\t} else {\n\t\t\t\targ = cmd->convert_arg * cmd->chanlist_len;\n\t\t\t}\n\t\t\terr |= comedi_check_trigger_arg_min(\n\t\t\t\t&cmd->scan_begin_arg, arg);\n\t\t}\n\t}\n\n\tif (err)\n\t\treturn 4;\n\n\t \n\n\tif (cmd->chanlist)\n\t\terr |= pci9118_ai_check_chanlist(dev, s, cmd);\n\n\tif (err)\n\t\treturn 5;\n\n\treturn 0;\n}\n\nstatic int pci9118_ai_eoc(struct comedi_device *dev,\n\t\t\t  struct comedi_subdevice *s,\n\t\t\t  struct comedi_insn *insn,\n\t\t\t  unsigned long context)\n{\n\tunsigned int status;\n\n\tstatus = inl(dev->iobase + PCI9118_AI_STATUS_REG);\n\tif (status & PCI9118_AI_STATUS_ADRDY)\n\t\treturn 0;\n\treturn -EBUSY;\n}\n\nstatic void pci9118_ai_start_conv(struct comedi_device *dev)\n{\n\t \n\toutl(0, dev->iobase + PCI9118_SOFTTRG_REG);\n}\n\nstatic int pci9118_ai_insn_read(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tstruct comedi_insn *insn,\n\t\t\t\tunsigned int *data)\n{\n\tstruct pci9118_private *devpriv = dev->private;\n\tunsigned int val;\n\tint ret;\n\tint i;\n\n        \n\tpci9118_set_chanlist(dev, s, 1, &insn->chanspec, 0, 0);\n\n\t \n\tdevpriv->ai_cfg = PCI9118_AI_CFG_PDTRG | PCI9118_AI_CFG_PETRG;\n\toutl(devpriv->ai_cfg, dev->iobase + PCI9118_AI_CFG_REG);\n\n\tpci9118_ai_reset_fifo(dev);\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\tpci9118_ai_start_conv(dev);\n\n\t\tret = comedi_timeout(dev, s, insn, pci9118_ai_eoc, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tval = inl(dev->iobase + PCI9118_AI_FIFO_REG);\n\t\tif (s->maxdata == 0xffff)\n\t\t\tdata[i] = (val & 0xffff) ^ 0x8000;\n\t\telse\n\t\t\tdata[i] = (val >> 4) & 0xfff;\n\t}\n\n\treturn insn->n;\n}\n\nstatic int pci9118_ao_insn_write(struct comedi_device *dev,\n\t\t\t\t struct comedi_subdevice *s,\n\t\t\t\t struct comedi_insn *insn,\n\t\t\t\t unsigned int *data)\n{\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int val = s->readback[chan];\n\tint i;\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\tval = data[i];\n\t\toutl(val, dev->iobase + PCI9118_AO_REG(chan));\n\t}\n\ts->readback[chan] = val;\n\n\treturn insn->n;\n}\n\nstatic int pci9118_di_insn_bits(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tstruct comedi_insn *insn,\n\t\t\t\tunsigned int *data)\n{\n\t \n\tdata[1] = inl(dev->iobase + PCI9118_DIO_REG) & 0xf;\n\n\treturn insn->n;\n}\n\nstatic int pci9118_do_insn_bits(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tstruct comedi_insn *insn,\n\t\t\t\tunsigned int *data)\n{\n\t \n\tif (comedi_dio_update_state(s, data))\n\t\toutl(s->state, dev->iobase + PCI9118_DIO_REG);\n\n\tdata[1] = s->state;\n\n\treturn insn->n;\n}\n\nstatic void pci9118_reset(struct comedi_device *dev)\n{\n\t \n\toutl(0, dev->iobase + PCI9118_INT_CTRL_REG);\n\toutl(0, dev->iobase + PCI9118_AI_CTRL_REG);\n\toutl(0, dev->iobase + PCI9118_AI_CFG_REG);\n\tpci9118_ai_reset_fifo(dev);\n\n\t \n\tinl(dev->iobase + PCI9118_INT_CTRL_REG);\n\tinl(dev->iobase + PCI9118_AI_STATUS_REG);\n\n\t \n\toutl(0, dev->iobase + PCI9118_AI_BURST_NUM_REG);\n\toutl(1, dev->iobase + PCI9118_AI_AUTOSCAN_MODE_REG);\n\toutl(2, dev->iobase + PCI9118_AI_AUTOSCAN_MODE_REG);\n\n\t \n\toutl(2047, dev->iobase + PCI9118_AO_REG(0));\n\toutl(2047, dev->iobase + PCI9118_AO_REG(1));\n}\n\nstatic struct pci_dev *pci9118_find_pci(struct comedi_device *dev,\n\t\t\t\t\tstruct comedi_devconfig *it)\n{\n\tstruct pci_dev *pcidev = NULL;\n\tint bus = it->options[0];\n\tint slot = it->options[1];\n\n\tfor_each_pci_dev(pcidev) {\n\t\tif (pcidev->vendor != PCI_VENDOR_ID_AMCC)\n\t\t\tcontinue;\n\t\tif (pcidev->device != 0x80d9)\n\t\t\tcontinue;\n\t\tif (bus || slot) {\n\t\t\t \n\t\t\tif (pcidev->bus->number != bus ||\n\t\t\t    PCI_SLOT(pcidev->devfn) != slot)\n\t\t\t\tcontinue;\n\t\t}\n\t\treturn pcidev;\n\t}\n\tdev_err(dev->class_dev,\n\t\t\"no supported board found! (req. bus/slot : %d/%d)\\n\",\n\t\tbus, slot);\n\treturn NULL;\n}\n\nstatic void pci9118_alloc_dma(struct comedi_device *dev)\n{\n\tstruct pci9118_private *devpriv = dev->private;\n\tstruct pci9118_dmabuf *dmabuf;\n\tint order;\n\tint i;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tdmabuf = &devpriv->dmabuf[i];\n\t\tfor (order = 2; order >= 0; order--) {\n\t\t\tdmabuf->virt =\n\t\t\t    dma_alloc_coherent(dev->hw_dev, PAGE_SIZE << order,\n\t\t\t\t\t       &dmabuf->hw, GFP_KERNEL);\n\t\t\tif (dmabuf->virt)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!dmabuf->virt)\n\t\t\tbreak;\n\t\tdmabuf->size = PAGE_SIZE << order;\n\n\t\tif (i == 0)\n\t\t\tdevpriv->master = 1;\n\t\tif (i == 1)\n\t\t\tdevpriv->dma_doublebuf = 1;\n\t}\n}\n\nstatic void pci9118_free_dma(struct comedi_device *dev)\n{\n\tstruct pci9118_private *devpriv = dev->private;\n\tstruct pci9118_dmabuf *dmabuf;\n\tint i;\n\n\tif (!devpriv)\n\t\treturn;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tdmabuf = &devpriv->dmabuf[i];\n\t\tif (dmabuf->virt) {\n\t\t\tdma_free_coherent(dev->hw_dev, dmabuf->size,\n\t\t\t\t\t  dmabuf->virt, dmabuf->hw);\n\t\t}\n\t}\n}\n\nstatic int pci9118_common_attach(struct comedi_device *dev,\n\t\t\t\t int ext_mux, int softsshdelay)\n{\n\tconst struct pci9118_boardinfo *board = dev->board_ptr;\n\tstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\n\tstruct pci9118_private *devpriv;\n\tstruct comedi_subdevice *s;\n\tint ret;\n\tint i;\n\tu16 u16w;\n\n\tdevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\n\tif (!devpriv)\n\t\treturn -ENOMEM;\n\n\tret = comedi_pci_enable(dev);\n\tif (ret)\n\t\treturn ret;\n\tpci_set_master(pcidev);\n\n\tdevpriv->iobase_a = pci_resource_start(pcidev, 0);\n\tdev->iobase = pci_resource_start(pcidev, 2);\n\n\tdev->pacer = comedi_8254_init(dev->iobase + PCI9118_TIMER_BASE,\n\t\t\t\t      I8254_OSC_BASE_4MHZ, I8254_IO32, 0);\n\tif (!dev->pacer)\n\t\treturn -ENOMEM;\n\n\tpci9118_reset(dev);\n\n\tif (pcidev->irq) {\n\t\tret = request_irq(pcidev->irq, pci9118_interrupt, IRQF_SHARED,\n\t\t\t\t  dev->board_name, dev);\n\t\tif (ret == 0) {\n\t\t\tdev->irq = pcidev->irq;\n\n\t\t\tpci9118_alloc_dma(dev);\n\t\t}\n\t}\n\n\tif (ext_mux > 0) {\n\t\tif (ext_mux > 256)\n\t\t\text_mux = 256;\t \n\t\tif (softsshdelay > 0)\n\t\t\tif (ext_mux > 128)\n\t\t\t\text_mux = 128;\n\t\tdevpriv->usemux = 1;\n\t} else {\n\t\tdevpriv->usemux = 0;\n\t}\n\n\tif (softsshdelay < 0) {\n\t\t \n\t\tdevpriv->softsshdelay = -softsshdelay;\n\t\tdevpriv->softsshsample = 0x80;\n\t\tdevpriv->softsshhold = 0x00;\n\t} else {\n\t\tdevpriv->softsshdelay = softsshdelay;\n\t\tdevpriv->softsshsample = 0x00;\n\t\tdevpriv->softsshhold = 0x80;\n\t}\n\n\tpci_read_config_word(pcidev, PCI_COMMAND, &u16w);\n\tpci_write_config_word(pcidev, PCI_COMMAND, u16w | 64);\n\t\t\t\t \n\n\tret = comedi_alloc_subdevices(dev, 4);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ts = &dev->subdevices[0];\n\ts->type\t\t= COMEDI_SUBD_AI;\n\ts->subdev_flags\t= SDF_READABLE | SDF_COMMON | SDF_GROUND | SDF_DIFF;\n\ts->n_chan\t= (devpriv->usemux) ? ext_mux : 16;\n\ts->maxdata\t= board->ai_is_16bit ? 0xffff : 0x0fff;\n\ts->range_table\t= board->is_hg ? &pci9118hg_ai_range\n\t\t\t\t       : &pci9118_ai_range;\n\ts->insn_read\t= pci9118_ai_insn_read;\n\tif (dev->irq) {\n\t\tdev->read_subdev = s;\n\t\ts->subdev_flags\t|= SDF_CMD_READ;\n\t\ts->len_chanlist\t= 255;\n\t\ts->do_cmdtest\t= pci9118_ai_cmdtest;\n\t\ts->do_cmd\t= pci9118_ai_cmd;\n\t\ts->cancel\t= pci9118_ai_cancel;\n\t\ts->munge\t= pci9118_ai_munge;\n\t}\n\n\tif (s->maxdata == 0xffff) {\n\t\t \n\t\tdevpriv->ai_ns_min = 10000;\n\t} else {\n\t\t \n\t\tdevpriv->ai_ns_min = 3000;\n\t}\n\n\t \n\ts = &dev->subdevices[1];\n\ts->type\t\t= COMEDI_SUBD_AO;\n\ts->subdev_flags\t= SDF_WRITABLE | SDF_GROUND | SDF_COMMON;\n\ts->n_chan\t= 2;\n\ts->maxdata\t= 0x0fff;\n\ts->range_table\t= &range_bipolar10;\n\ts->insn_write\t= pci9118_ao_insn_write;\n\n\tret = comedi_alloc_subdev_readback(s);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor (i = 0; i < s->n_chan; i++)\n\t\ts->readback[i] = 2047;\n\n\t \n\ts = &dev->subdevices[2];\n\ts->type\t\t= COMEDI_SUBD_DI;\n\ts->subdev_flags\t= SDF_READABLE;\n\ts->n_chan\t= 4;\n\ts->maxdata\t= 1;\n\ts->range_table\t= &range_digital;\n\ts->insn_bits\t= pci9118_di_insn_bits;\n\n\t \n\ts = &dev->subdevices[3];\n\ts->type\t\t= COMEDI_SUBD_DO;\n\ts->subdev_flags\t= SDF_WRITABLE;\n\ts->n_chan\t= 4;\n\ts->maxdata\t= 1;\n\ts->range_table\t= &range_digital;\n\ts->insn_bits\t= pci9118_do_insn_bits;\n\n\t \n\ts->state = inl(dev->iobase + PCI9118_DIO_REG) >> 4;\n\n\treturn 0;\n}\n\nstatic int pci9118_attach(struct comedi_device *dev,\n\t\t\t  struct comedi_devconfig *it)\n{\n\tstruct pci_dev *pcidev;\n\tint ext_mux, softsshdelay;\n\n\text_mux = it->options[2];\n\tsoftsshdelay = it->options[4];\n\n\tpcidev = pci9118_find_pci(dev, it);\n\tif (!pcidev)\n\t\treturn -EIO;\n\tcomedi_set_hw_dev(dev, &pcidev->dev);\n\n\treturn pci9118_common_attach(dev, ext_mux, softsshdelay);\n}\n\nstatic int pci9118_auto_attach(struct comedi_device *dev,\n\t\t\t       unsigned long context)\n{\n\tstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\n\tconst struct pci9118_boardinfo *board = NULL;\n\n\tif (context < ARRAY_SIZE(pci9118_boards))\n\t\tboard = &pci9118_boards[context];\n\tif (!board)\n\t\treturn -ENODEV;\n\tdev->board_ptr = board;\n\tdev->board_name = board->name;\n\n\t \n\tpci_dev_get(pcidev);\n\t \n\treturn pci9118_common_attach(dev, 0, 0);\n}\n\nstatic void pci9118_detach(struct comedi_device *dev)\n{\n\tstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\n\n\tif (dev->iobase)\n\t\tpci9118_reset(dev);\n\tcomedi_pci_detach(dev);\n\tpci9118_free_dma(dev);\n\tpci_dev_put(pcidev);\n}\n\nstatic struct comedi_driver adl_pci9118_driver = {\n\t.driver_name\t= \"adl_pci9118\",\n\t.module\t\t= THIS_MODULE,\n\t.attach\t\t= pci9118_attach,\n\t.auto_attach\t= pci9118_auto_attach,\n\t.detach\t\t= pci9118_detach,\n\t.num_names\t= ARRAY_SIZE(pci9118_boards),\n\t.board_name\t= &pci9118_boards[0].name,\n\t.offset\t\t= sizeof(struct pci9118_boardinfo),\n};\n\nstatic int adl_pci9118_pci_probe(struct pci_dev *dev,\n\t\t\t\t const struct pci_device_id *id)\n{\n\treturn comedi_pci_auto_config(dev, &adl_pci9118_driver,\n\t\t\t\t      id->driver_data);\n}\n\n \nstatic const struct pci_device_id adl_pci9118_pci_table[] = {\n\t{ PCI_VDEVICE(AMCC, 0x80d9), BOARD_PCI9118DG },\n \n \n\t{ 0 }\n};\nMODULE_DEVICE_TABLE(pci, adl_pci9118_pci_table);\n\nstatic struct pci_driver adl_pci9118_pci_driver = {\n\t.name\t\t= \"adl_pci9118\",\n\t.id_table\t= adl_pci9118_pci_table,\n\t.probe\t\t= adl_pci9118_pci_probe,\n\t.remove\t\t= comedi_pci_auto_unconfig,\n};\nmodule_comedi_pci_driver(adl_pci9118_driver, adl_pci9118_pci_driver);\n\nMODULE_AUTHOR(\"Comedi https://www.comedi.org\");\nMODULE_DESCRIPTION(\"Comedi low-level driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}