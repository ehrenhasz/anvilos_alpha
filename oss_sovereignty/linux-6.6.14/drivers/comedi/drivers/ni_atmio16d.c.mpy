{
  "module_name": "ni_atmio16d.c",
  "hash_id": "062415de7da335ffd23ba45ca41e1ed17d8f20d9e8679e49a8c9118016ec0b2a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/ni_atmio16d.c",
  "human_readable_source": "\n \n\n \n\n \n\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/comedi/comedidev.h>\n#include <linux/comedi/comedi_8255.h>\n\n \n#define COM_REG_1\t0x00\t \n#define STAT_REG\t0x00\t \n#define COM_REG_2\t0x02\t \n \n#define START_CONVERT_REG\t0x08\t \n#define START_DAQ_REG\t\t0x0A\t \n#define AD_CLEAR_REG\t\t0x0C\t \n#define EXT_STROBE_REG\t\t0x0E\t \n \n#define DAC0_REG\t\t0x10\t \n#define DAC1_REG\t\t0x12\t \n#define INT2CLR_REG\t\t0x14\t \n \n#define MUX_CNTR_REG\t\t0x04\t \n#define MUX_GAIN_REG\t\t0x06\t \n#define AD_FIFO_REG\t\t0x16\t \n#define DMA_TC_INT_CLR_REG\t0x16\t \n \n#define AM9513A_DATA_REG\t0x18\t \n#define AM9513A_COM_REG\t\t0x1A\t \n#define AM9513A_STAT_REG\t0x1A\t \n \n#define MIO_16_DIG_IN_REG\t0x1C\t \n#define MIO_16_DIG_OUT_REG\t0x1C\t \n \n#define RTSI_SW_SHIFT_REG\t0x1E\t \n#define RTSI_SW_STROBE_REG\t0x1F\t \n \n#define DIO_24_PORTA_REG\t0x00\t \n#define DIO_24_PORTB_REG\t0x01\t \n#define DIO_24_PORTC_REG\t0x02\t \n#define DIO_24_CNFG_REG\t\t0x03\t \n\n \n#define COMREG1_2SCADC\t\t0x0001\n#define COMREG1_1632CNT\t\t0x0002\n#define COMREG1_SCANEN\t\t0x0008\n#define COMREG1_DAQEN\t\t0x0010\n#define COMREG1_DMAEN\t\t0x0020\n#define COMREG1_CONVINTEN\t0x0080\n#define COMREG2_SCN2\t\t0x0010\n#define COMREG2_INTEN\t\t0x0080\n#define COMREG2_DOUTEN0\t\t0x0100\n#define COMREG2_DOUTEN1\t\t0x0200\n \n#define STAT_AD_OVERRUN\t\t0x0100\n#define STAT_AD_OVERFLOW\t0x0200\n#define STAT_AD_DAQPROG\t\t0x0800\n#define STAT_AD_CONVAVAIL\t0x2000\n#define STAT_AD_DAQSTOPINT\t0x4000\n \n#define CLOCK_1_MHZ\t\t0x8B25\n#define CLOCK_100_KHZ\t0x8C25\n#define CLOCK_10_KHZ\t0x8D25\n#define CLOCK_1_KHZ\t\t0x8E25\n#define CLOCK_100_HZ\t0x8F25\n\nstruct atmio16_board_t {\n\tconst char *name;\n\tint has_8255;\n};\n\n \nstatic const struct comedi_lrange range_atmio16d_ai_10_bipolar = {\n\t4, {\n\t\tBIP_RANGE(10),\n\t\tBIP_RANGE(1),\n\t\tBIP_RANGE(0.1),\n\t\tBIP_RANGE(0.02)\n\t}\n};\n\nstatic const struct comedi_lrange range_atmio16d_ai_5_bipolar = {\n\t4, {\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(0.5),\n\t\tBIP_RANGE(0.05),\n\t\tBIP_RANGE(0.01)\n\t}\n};\n\nstatic const struct comedi_lrange range_atmio16d_ai_unipolar = {\n\t4, {\n\t\tUNI_RANGE(10),\n\t\tUNI_RANGE(1),\n\t\tUNI_RANGE(0.1),\n\t\tUNI_RANGE(0.02)\n\t}\n};\n\n \nstruct atmio16d_private {\n\tenum { adc_diff, adc_singleended } adc_mux;\n\tenum { adc_bipolar10, adc_bipolar5, adc_unipolar10 } adc_range;\n\tenum { adc_2comp, adc_straight } adc_coding;\n\tenum { dac_bipolar, dac_unipolar } dac0_range, dac1_range;\n\tenum { dac_internal, dac_external } dac0_reference, dac1_reference;\n\tenum { dac_2comp, dac_straight } dac0_coding, dac1_coding;\n\tconst struct comedi_lrange *ao_range_type_list[2];\n\tunsigned int com_reg_1_state;  \n\tunsigned int com_reg_2_state;  \n};\n\nstatic void reset_counters(struct comedi_device *dev)\n{\n\t \n\toutw(0xFFC2, dev->iobase + AM9513A_COM_REG);\n\toutw(0xFF02, dev->iobase + AM9513A_COM_REG);\n\toutw(0x4, dev->iobase + AM9513A_DATA_REG);\n\toutw(0xFF0A, dev->iobase + AM9513A_COM_REG);\n\toutw(0x3, dev->iobase + AM9513A_DATA_REG);\n\toutw(0xFF42, dev->iobase + AM9513A_COM_REG);\n\toutw(0xFF42, dev->iobase + AM9513A_COM_REG);\n\t \n\toutw(0xFFC4, dev->iobase + AM9513A_COM_REG);\n\toutw(0xFF03, dev->iobase + AM9513A_COM_REG);\n\toutw(0x4, dev->iobase + AM9513A_DATA_REG);\n\toutw(0xFF0B, dev->iobase + AM9513A_COM_REG);\n\toutw(0x3, dev->iobase + AM9513A_DATA_REG);\n\toutw(0xFF44, dev->iobase + AM9513A_COM_REG);\n\toutw(0xFF44, dev->iobase + AM9513A_COM_REG);\n\t \n\toutw(0xFFC8, dev->iobase + AM9513A_COM_REG);\n\toutw(0xFF04, dev->iobase + AM9513A_COM_REG);\n\toutw(0x4, dev->iobase + AM9513A_DATA_REG);\n\toutw(0xFF0C, dev->iobase + AM9513A_COM_REG);\n\toutw(0x3, dev->iobase + AM9513A_DATA_REG);\n\toutw(0xFF48, dev->iobase + AM9513A_COM_REG);\n\toutw(0xFF48, dev->iobase + AM9513A_COM_REG);\n\t \n\toutw(0xFFD0, dev->iobase + AM9513A_COM_REG);\n\toutw(0xFF05, dev->iobase + AM9513A_COM_REG);\n\toutw(0x4, dev->iobase + AM9513A_DATA_REG);\n\toutw(0xFF0D, dev->iobase + AM9513A_COM_REG);\n\toutw(0x3, dev->iobase + AM9513A_DATA_REG);\n\toutw(0xFF50, dev->iobase + AM9513A_COM_REG);\n\toutw(0xFF50, dev->iobase + AM9513A_COM_REG);\n\n\toutw(0, dev->iobase + AD_CLEAR_REG);\n}\n\nstatic void reset_atmio16d(struct comedi_device *dev)\n{\n\tstruct atmio16d_private *devpriv = dev->private;\n\tint i;\n\n\t \n\toutw(0, dev->iobase + COM_REG_1);\n\toutw(0, dev->iobase + COM_REG_2);\n\toutw(0, dev->iobase + MUX_GAIN_REG);\n\t \n\toutw(0xFFFF, dev->iobase + AM9513A_COM_REG);\n\toutw(0xFFEF, dev->iobase + AM9513A_COM_REG);\n\toutw(0xFF17, dev->iobase + AM9513A_COM_REG);\n\toutw(0xF000, dev->iobase + AM9513A_DATA_REG);\n\tfor (i = 1; i <= 5; ++i) {\n\t\toutw(0xFF00 + i, dev->iobase + AM9513A_COM_REG);\n\t\toutw(0x0004, dev->iobase + AM9513A_DATA_REG);\n\t\toutw(0xFF08 + i, dev->iobase + AM9513A_COM_REG);\n\t\toutw(0x3, dev->iobase + AM9513A_DATA_REG);\n\t}\n\toutw(0xFF5F, dev->iobase + AM9513A_COM_REG);\n\t \n\toutw(0, dev->iobase + AD_CLEAR_REG);\n\toutw(0, dev->iobase + INT2CLR_REG);\n\t \n\tdevpriv->com_reg_1_state |= 1;\n\toutw(devpriv->com_reg_1_state, dev->iobase + COM_REG_1);\n\tdevpriv->adc_coding = adc_straight;\n\t \n\toutw(2048, dev->iobase + DAC0_REG);\n\toutw(2048, dev->iobase + DAC1_REG);\n}\n\nstatic irqreturn_t atmio16d_interrupt(int irq, void *d)\n{\n\tstruct comedi_device *dev = d;\n\tstruct comedi_subdevice *s = dev->read_subdev;\n\tunsigned short val;\n\n\tval = inw(dev->iobase + AD_FIFO_REG);\n\tcomedi_buf_write_samples(s, &val, 1);\n\tcomedi_handle_events(dev, s);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int atmio16d_ai_cmdtest(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       struct comedi_cmd *cmd)\n{\n\tint err = 0;\n\n\t \n\n\terr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW);\n\terr |= comedi_check_trigger_src(&cmd->scan_begin_src,\n\t\t\t\t\tTRIG_FOLLOW | TRIG_TIMER);\n\terr |= comedi_check_trigger_src(&cmd->convert_src, TRIG_TIMER);\n\terr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\n\terr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\n\n\tif (err)\n\t\treturn 1;\n\n\t \n\n\terr |= comedi_check_trigger_is_unique(cmd->scan_begin_src);\n\terr |= comedi_check_trigger_is_unique(cmd->stop_src);\n\n\t \n\n\tif (err)\n\t\treturn 2;\n\n\t \n\n\terr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\n\n\tif (cmd->scan_begin_src == TRIG_FOLLOW) {\n\t\t \n\t\terr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);\n\t}\n\n\terr |= comedi_check_trigger_arg_min(&cmd->convert_arg, 10000);\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\n\t\t\t\t\t   cmd->chanlist_len);\n\n\tif (cmd->stop_src == TRIG_COUNT)\n\t\terr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\n\telse\t \n\t\terr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\n\n\tif (err)\n\t\treturn 3;\n\n\treturn 0;\n}\n\nstatic int atmio16d_ai_cmd(struct comedi_device *dev,\n\t\t\t   struct comedi_subdevice *s)\n{\n\tstruct atmio16d_private *devpriv = dev->private;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tunsigned int timer, base_clock;\n\tunsigned int sample_count, tmp, chan, gain;\n\tint i;\n\n\t \n\n\treset_counters(dev);\n\n\t \n\tif (cmd->chanlist_len < 2) {\n\t\tdevpriv->com_reg_1_state &= ~COMREG1_SCANEN;\n\t\toutw(devpriv->com_reg_1_state, dev->iobase + COM_REG_1);\n\t} else {\n\t\tdevpriv->com_reg_1_state |= COMREG1_SCANEN;\n\t\tdevpriv->com_reg_2_state |= COMREG2_SCN2;\n\t\toutw(devpriv->com_reg_1_state, dev->iobase + COM_REG_1);\n\t\toutw(devpriv->com_reg_2_state, dev->iobase + COM_REG_2);\n\t}\n\n\t \n\tfor (i = 0; i < cmd->chanlist_len; ++i) {\n\t\tchan = CR_CHAN(cmd->chanlist[i]);\n\t\tgain = CR_RANGE(cmd->chanlist[i]);\n\t\toutw(i, dev->iobase + MUX_CNTR_REG);\n\t\ttmp = chan | (gain << 6);\n\t\tif (i == cmd->scan_end_arg - 1)\n\t\t\ttmp |= 0x0010;\t \n\t\toutw(tmp, dev->iobase + MUX_GAIN_REG);\n\t}\n\n\t \n\tif (cmd->convert_arg < 65536000) {\n\t\tbase_clock = CLOCK_1_MHZ;\n\t\ttimer = cmd->convert_arg / 1000;\n\t} else if (cmd->convert_arg < 655360000) {\n\t\tbase_clock = CLOCK_100_KHZ;\n\t\ttimer = cmd->convert_arg / 10000;\n\t} else   {\n\t\tbase_clock = CLOCK_10_KHZ;\n\t\ttimer = cmd->convert_arg / 100000;\n\t}\n\toutw(0xFF03, dev->iobase + AM9513A_COM_REG);\n\toutw(base_clock, dev->iobase + AM9513A_DATA_REG);\n\toutw(0xFF0B, dev->iobase + AM9513A_COM_REG);\n\toutw(0x2, dev->iobase + AM9513A_DATA_REG);\n\toutw(0xFF44, dev->iobase + AM9513A_COM_REG);\n\toutw(0xFFF3, dev->iobase + AM9513A_COM_REG);\n\toutw(timer, dev->iobase + AM9513A_DATA_REG);\n\toutw(0xFF24, dev->iobase + AM9513A_COM_REG);\n\n\t \n\t \n\tsample_count = cmd->stop_arg * cmd->scan_end_arg;\n\toutw(0xFF04, dev->iobase + AM9513A_COM_REG);\n\toutw(0x1025, dev->iobase + AM9513A_DATA_REG);\n\toutw(0xFF0C, dev->iobase + AM9513A_COM_REG);\n\tif (sample_count < 65536) {\n\t\t \n\t\toutw(sample_count, dev->iobase + AM9513A_DATA_REG);\n\t\toutw(0xFF48, dev->iobase + AM9513A_COM_REG);\n\t\toutw(0xFFF4, dev->iobase + AM9513A_COM_REG);\n\t\toutw(0xFF28, dev->iobase + AM9513A_COM_REG);\n\t\tdevpriv->com_reg_1_state &= ~COMREG1_1632CNT;\n\t\toutw(devpriv->com_reg_1_state, dev->iobase + COM_REG_1);\n\t} else {\n\t\t \n\n\t\ttmp = sample_count & 0xFFFF;\n\t\tif (tmp)\n\t\t\toutw(tmp - 1, dev->iobase + AM9513A_DATA_REG);\n\t\telse\n\t\t\toutw(0xFFFF, dev->iobase + AM9513A_DATA_REG);\n\n\t\toutw(0xFF48, dev->iobase + AM9513A_COM_REG);\n\t\toutw(0, dev->iobase + AM9513A_DATA_REG);\n\t\toutw(0xFF28, dev->iobase + AM9513A_COM_REG);\n\t\toutw(0xFF05, dev->iobase + AM9513A_COM_REG);\n\t\toutw(0x25, dev->iobase + AM9513A_DATA_REG);\n\t\toutw(0xFF0D, dev->iobase + AM9513A_COM_REG);\n\t\ttmp = sample_count & 0xFFFF;\n\t\tif ((tmp == 0) || (tmp == 1)) {\n\t\t\toutw((sample_count >> 16) & 0xFFFF,\n\t\t\t     dev->iobase + AM9513A_DATA_REG);\n\t\t} else {\n\t\t\toutw(((sample_count >> 16) & 0xFFFF) + 1,\n\t\t\t     dev->iobase + AM9513A_DATA_REG);\n\t\t}\n\t\toutw(0xFF70, dev->iobase + AM9513A_COM_REG);\n\t\tdevpriv->com_reg_1_state |= COMREG1_1632CNT;\n\t\toutw(devpriv->com_reg_1_state, dev->iobase + COM_REG_1);\n\t}\n\n\t \n\tif (cmd->chanlist_len > 1) {\n\t\tif (cmd->scan_begin_arg < 65536000) {\n\t\t\tbase_clock = CLOCK_1_MHZ;\n\t\t\ttimer = cmd->scan_begin_arg / 1000;\n\t\t} else if (cmd->scan_begin_arg < 655360000) {\n\t\t\tbase_clock = CLOCK_100_KHZ;\n\t\t\ttimer = cmd->scan_begin_arg / 10000;\n\t\t} else   {\n\t\t\tbase_clock = CLOCK_10_KHZ;\n\t\t\ttimer = cmd->scan_begin_arg / 100000;\n\t\t}\n\t\toutw(0xFF02, dev->iobase + AM9513A_COM_REG);\n\t\toutw(base_clock, dev->iobase + AM9513A_DATA_REG);\n\t\toutw(0xFF0A, dev->iobase + AM9513A_COM_REG);\n\t\toutw(0x2, dev->iobase + AM9513A_DATA_REG);\n\t\toutw(0xFF42, dev->iobase + AM9513A_COM_REG);\n\t\toutw(0xFFF2, dev->iobase + AM9513A_COM_REG);\n\t\toutw(timer, dev->iobase + AM9513A_DATA_REG);\n\t\toutw(0xFF22, dev->iobase + AM9513A_COM_REG);\n\t}\n\n\t \n\toutw(0, dev->iobase + AD_CLEAR_REG);\n\toutw(0, dev->iobase + MUX_CNTR_REG);\n\toutw(0, dev->iobase + INT2CLR_REG);\n\t \n\tdevpriv->com_reg_1_state |= COMREG1_DAQEN;\n\toutw(devpriv->com_reg_1_state, dev->iobase + COM_REG_1);\n\t \n\tdevpriv->com_reg_1_state |= COMREG1_CONVINTEN;\n\tdevpriv->com_reg_2_state |= COMREG2_INTEN;\n\toutw(devpriv->com_reg_1_state, dev->iobase + COM_REG_1);\n\toutw(devpriv->com_reg_2_state, dev->iobase + COM_REG_2);\n\t \n\toutw(0, dev->iobase + START_DAQ_REG);\n\n\treturn 0;\n}\n\n \nstatic int atmio16d_ai_cancel(struct comedi_device *dev,\n\t\t\t      struct comedi_subdevice *s)\n{\n\treset_atmio16d(dev);\n\n\treturn 0;\n}\n\nstatic int atmio16d_ai_eoc(struct comedi_device *dev,\n\t\t\t   struct comedi_subdevice *s,\n\t\t\t   struct comedi_insn *insn,\n\t\t\t   unsigned long context)\n{\n\tunsigned int status;\n\n\tstatus = inw(dev->iobase + STAT_REG);\n\tif (status & STAT_AD_CONVAVAIL)\n\t\treturn 0;\n\tif (status & STAT_AD_OVERFLOW) {\n\t\toutw(0, dev->iobase + AD_CLEAR_REG);\n\t\treturn -EOVERFLOW;\n\t}\n\treturn -EBUSY;\n}\n\nstatic int atmio16d_ai_insn_read(struct comedi_device *dev,\n\t\t\t\t struct comedi_subdevice *s,\n\t\t\t\t struct comedi_insn *insn, unsigned int *data)\n{\n\tstruct atmio16d_private *devpriv = dev->private;\n\tint i;\n\tint chan;\n\tint gain;\n\tint ret;\n\n\tchan = CR_CHAN(insn->chanspec);\n\tgain = CR_RANGE(insn->chanspec);\n\n\t \n\t \n\t \n\t \n\n\t \n\toutw(chan | (gain << 6), dev->iobase + MUX_GAIN_REG);\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\t \n\t\toutw(0, dev->iobase + START_CONVERT_REG);\n\n\t\t \n\t\tret = comedi_timeout(dev, s, insn, atmio16d_ai_eoc, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tdata[i] = inw(dev->iobase + AD_FIFO_REG);\n\t\t \n\t\tif (devpriv->adc_coding == adc_2comp)\n\t\t\tdata[i] ^= 0x800;\n\t}\n\n\treturn i;\n}\n\nstatic int atmio16d_ao_insn_write(struct comedi_device *dev,\n\t\t\t\t  struct comedi_subdevice *s,\n\t\t\t\t  struct comedi_insn *insn,\n\t\t\t\t  unsigned int *data)\n{\n\tstruct atmio16d_private *devpriv = dev->private;\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int reg = (chan) ? DAC1_REG : DAC0_REG;\n\tbool munge = false;\n\tint i;\n\n\tif (chan == 0 && devpriv->dac0_coding == dac_2comp)\n\t\tmunge = true;\n\tif (chan == 1 && devpriv->dac1_coding == dac_2comp)\n\t\tmunge = true;\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\tunsigned int val = data[i];\n\n\t\ts->readback[chan] = val;\n\n\t\tif (munge)\n\t\t\tval ^= 0x800;\n\n\t\toutw(val, dev->iobase + reg);\n\t}\n\n\treturn insn->n;\n}\n\nstatic int atmio16d_dio_insn_bits(struct comedi_device *dev,\n\t\t\t\t  struct comedi_subdevice *s,\n\t\t\t\t  struct comedi_insn *insn,\n\t\t\t\t  unsigned int *data)\n{\n\tif (comedi_dio_update_state(s, data))\n\t\toutw(s->state, dev->iobase + MIO_16_DIG_OUT_REG);\n\n\tdata[1] = inw(dev->iobase + MIO_16_DIG_IN_REG);\n\n\treturn insn->n;\n}\n\nstatic int atmio16d_dio_insn_config(struct comedi_device *dev,\n\t\t\t\t    struct comedi_subdevice *s,\n\t\t\t\t    struct comedi_insn *insn,\n\t\t\t\t    unsigned int *data)\n{\n\tstruct atmio16d_private *devpriv = dev->private;\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int mask;\n\tint ret;\n\n\tif (chan < 4)\n\t\tmask = 0x0f;\n\telse\n\t\tmask = 0xf0;\n\n\tret = comedi_dio_insn_config(dev, s, insn, data, mask);\n\tif (ret)\n\t\treturn ret;\n\n\tdevpriv->com_reg_2_state &= ~(COMREG2_DOUTEN0 | COMREG2_DOUTEN1);\n\tif (s->io_bits & 0x0f)\n\t\tdevpriv->com_reg_2_state |= COMREG2_DOUTEN0;\n\tif (s->io_bits & 0xf0)\n\t\tdevpriv->com_reg_2_state |= COMREG2_DOUTEN1;\n\toutw(devpriv->com_reg_2_state, dev->iobase + COM_REG_2);\n\n\treturn insn->n;\n}\n\nstatic int atmio16d_attach(struct comedi_device *dev,\n\t\t\t   struct comedi_devconfig *it)\n{\n\tconst struct atmio16_board_t *board = dev->board_ptr;\n\tstruct atmio16d_private *devpriv;\n\tstruct comedi_subdevice *s;\n\tint ret;\n\n\tret = comedi_request_region(dev, it->options[0], 0x20);\n\tif (ret)\n\t\treturn ret;\n\n\tret = comedi_alloc_subdevices(dev, 4);\n\tif (ret)\n\t\treturn ret;\n\n\tdevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\n\tif (!devpriv)\n\t\treturn -ENOMEM;\n\n\t \n\treset_atmio16d(dev);\n\n\tif (it->options[1]) {\n\t\tret = request_irq(it->options[1], atmio16d_interrupt, 0,\n\t\t\t\t  dev->board_name, dev);\n\t\tif (ret == 0)\n\t\t\tdev->irq = it->options[1];\n\t}\n\n\t \n\tdevpriv->adc_mux = it->options[5];\n\tdevpriv->adc_range = it->options[6];\n\n\tdevpriv->dac0_range = it->options[7];\n\tdevpriv->dac0_reference = it->options[8];\n\tdevpriv->dac0_coding = it->options[9];\n\tdevpriv->dac1_range = it->options[10];\n\tdevpriv->dac1_reference = it->options[11];\n\tdevpriv->dac1_coding = it->options[12];\n\n\t \n\ts = &dev->subdevices[0];\n\t \n\ts->type = COMEDI_SUBD_AI;\n\ts->subdev_flags = SDF_READABLE | SDF_GROUND;\n\ts->n_chan = (devpriv->adc_mux ? 16 : 8);\n\ts->insn_read = atmio16d_ai_insn_read;\n\ts->maxdata = 0xfff;\t \n\tswitch (devpriv->adc_range) {\n\tcase adc_bipolar10:\n\t\ts->range_table = &range_atmio16d_ai_10_bipolar;\n\t\tbreak;\n\tcase adc_bipolar5:\n\t\ts->range_table = &range_atmio16d_ai_5_bipolar;\n\t\tbreak;\n\tcase adc_unipolar10:\n\t\ts->range_table = &range_atmio16d_ai_unipolar;\n\t\tbreak;\n\t}\n\tif (dev->irq) {\n\t\tdev->read_subdev = s;\n\t\ts->subdev_flags |= SDF_CMD_READ;\n\t\ts->len_chanlist = 16;\n\t\ts->do_cmdtest = atmio16d_ai_cmdtest;\n\t\ts->do_cmd = atmio16d_ai_cmd;\n\t\ts->cancel = atmio16d_ai_cancel;\n\t}\n\n\t \n\ts = &dev->subdevices[1];\n\ts->type = COMEDI_SUBD_AO;\n\ts->subdev_flags = SDF_WRITABLE;\n\ts->n_chan = 2;\n\ts->maxdata = 0xfff;\t \n\ts->range_table_list = devpriv->ao_range_type_list;\n\tswitch (devpriv->dac0_range) {\n\tcase dac_bipolar:\n\t\tdevpriv->ao_range_type_list[0] = &range_bipolar10;\n\t\tbreak;\n\tcase dac_unipolar:\n\t\tdevpriv->ao_range_type_list[0] = &range_unipolar10;\n\t\tbreak;\n\t}\n\tswitch (devpriv->dac1_range) {\n\tcase dac_bipolar:\n\t\tdevpriv->ao_range_type_list[1] = &range_bipolar10;\n\t\tbreak;\n\tcase dac_unipolar:\n\t\tdevpriv->ao_range_type_list[1] = &range_unipolar10;\n\t\tbreak;\n\t}\n\ts->insn_write = atmio16d_ao_insn_write;\n\n\tret = comedi_alloc_subdev_readback(s);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ts = &dev->subdevices[2];\n\ts->type = COMEDI_SUBD_DIO;\n\ts->subdev_flags = SDF_WRITABLE | SDF_READABLE;\n\ts->n_chan = 8;\n\ts->insn_bits = atmio16d_dio_insn_bits;\n\ts->insn_config = atmio16d_dio_insn_config;\n\ts->maxdata = 1;\n\ts->range_table = &range_digital;\n\n\t \n\ts = &dev->subdevices[3];\n\tif (board->has_8255) {\n\t\tret = subdev_8255_init(dev, s, NULL, 0x00);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\ts->type = COMEDI_SUBD_UNUSED;\n\t}\n\n \n#if 0\n\ts = &dev->subdevices[4];\n\t \n\ts->type = COMEDI_SUBD_TIMER;\n\ts->n_chan = 0;\n\ts->maxdata = 0\n#endif\n\n\treturn 0;\n}\n\nstatic void atmio16d_detach(struct comedi_device *dev)\n{\n\treset_atmio16d(dev);\n\tcomedi_legacy_detach(dev);\n}\n\nstatic const struct atmio16_board_t atmio16_boards[] = {\n\t{\n\t\t.name\t\t= \"atmio16\",\n\t\t.has_8255\t= 0,\n\t}, {\n\t\t.name\t\t= \"atmio16d\",\n\t\t.has_8255\t= 1,\n\t},\n};\n\nstatic struct comedi_driver atmio16d_driver = {\n\t.driver_name\t= \"atmio16\",\n\t.module\t\t= THIS_MODULE,\n\t.attach\t\t= atmio16d_attach,\n\t.detach\t\t= atmio16d_detach,\n\t.board_name\t= &atmio16_boards[0].name,\n\t.num_names\t= ARRAY_SIZE(atmio16_boards),\n\t.offset\t\t= sizeof(struct atmio16_board_t),\n};\nmodule_comedi_driver(atmio16d_driver);\n\nMODULE_AUTHOR(\"Comedi https://www.comedi.org\");\nMODULE_DESCRIPTION(\"Comedi low-level driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}