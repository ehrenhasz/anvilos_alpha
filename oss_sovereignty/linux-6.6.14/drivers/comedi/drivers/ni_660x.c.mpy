{
  "module_name": "ni_660x.c",
  "hash_id": "fc8ab860fd5228d357d46fbdf4dc9a3c29329866ff34a820ed8703e916052b64",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/ni_660x.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/comedi/comedi_pci.h>\n\n#include \"mite.h\"\n#include \"ni_tio.h\"\n#include \"ni_routes.h\"\n\n \nenum ni_660x_register {\n\t \n\tNI660X_STC_DIO_PARALLEL_INPUT = NITIO_NUM_REGS,\n\tNI660X_STC_DIO_OUTPUT,\n\tNI660X_STC_DIO_CONTROL,\n\tNI660X_STC_DIO_SERIAL_INPUT,\n\tNI660X_DIO32_INPUT,\n\tNI660X_DIO32_OUTPUT,\n\tNI660X_CLK_CFG,\n\tNI660X_GLOBAL_INT_STATUS,\n\tNI660X_DMA_CFG,\n\tNI660X_GLOBAL_INT_CFG,\n\tNI660X_IO_CFG_0_1,\n\tNI660X_IO_CFG_2_3,\n\tNI660X_IO_CFG_4_5,\n\tNI660X_IO_CFG_6_7,\n\tNI660X_IO_CFG_8_9,\n\tNI660X_IO_CFG_10_11,\n\tNI660X_IO_CFG_12_13,\n\tNI660X_IO_CFG_14_15,\n\tNI660X_IO_CFG_16_17,\n\tNI660X_IO_CFG_18_19,\n\tNI660X_IO_CFG_20_21,\n\tNI660X_IO_CFG_22_23,\n\tNI660X_IO_CFG_24_25,\n\tNI660X_IO_CFG_26_27,\n\tNI660X_IO_CFG_28_29,\n\tNI660X_IO_CFG_30_31,\n\tNI660X_IO_CFG_32_33,\n\tNI660X_IO_CFG_34_35,\n\tNI660X_IO_CFG_36_37,\n\tNI660X_IO_CFG_38_39,\n\tNI660X_NUM_REGS,\n};\n\n#define NI660X_CLK_CFG_COUNTER_SWAP\tBIT(21)\n\n#define NI660X_GLOBAL_INT_COUNTER0\tBIT(8)\n#define NI660X_GLOBAL_INT_COUNTER1\tBIT(9)\n#define NI660X_GLOBAL_INT_COUNTER2\tBIT(10)\n#define NI660X_GLOBAL_INT_COUNTER3\tBIT(11)\n#define NI660X_GLOBAL_INT_CASCADE\tBIT(29)\n#define NI660X_GLOBAL_INT_GLOBAL_POL\tBIT(30)\n#define NI660X_GLOBAL_INT_GLOBAL\tBIT(31)\n\n#define NI660X_DMA_CFG_SEL(_c, _s)\t(((_s) & 0x1f) << (8 * (_c)))\n#define NI660X_DMA_CFG_SEL_MASK(_c)\tNI660X_DMA_CFG_SEL((_c), 0x1f)\n#define NI660X_DMA_CFG_SEL_NONE(_c)\tNI660X_DMA_CFG_SEL((_c), 0x1f)\n#define NI660X_DMA_CFG_RESET(_c)\tNI660X_DMA_CFG_SEL((_c), 0x80)\n\n#define NI660X_IO_CFG(x)\t\t(NI660X_IO_CFG_0_1 + ((x) / 2))\n#define NI660X_IO_CFG_OUT_SEL(_c, _s)\t(((_s) & 0x3) << (((_c) % 2) ? 0 : 8))\n#define NI660X_IO_CFG_OUT_SEL_MASK(_c)\tNI660X_IO_CFG_OUT_SEL((_c), 0x3)\n#define NI660X_IO_CFG_IN_SEL(_c, _s)\t(((_s) & 0x7) << (((_c) % 2) ? 4 : 12))\n#define NI660X_IO_CFG_IN_SEL_MASK(_c)\tNI660X_IO_CFG_IN_SEL((_c), 0x7)\n\nstruct ni_660x_register_data {\n\tint offset;\t\t \n\tchar size;\t\t \n};\n\nstatic const struct ni_660x_register_data ni_660x_reg_data[NI660X_NUM_REGS] = {\n\t[NITIO_G0_INT_ACK]\t\t= { 0x004, 2 },\t \n\t[NITIO_G0_STATUS]\t\t= { 0x004, 2 },\t \n\t[NITIO_G1_INT_ACK]\t\t= { 0x006, 2 },\t \n\t[NITIO_G1_STATUS]\t\t= { 0x006, 2 },\t \n\t[NITIO_G01_STATUS]\t\t= { 0x008, 2 },\t \n\t[NITIO_G0_CMD]\t\t\t= { 0x00c, 2 },\t \n\t[NI660X_STC_DIO_PARALLEL_INPUT]\t= { 0x00e, 2 },\t \n\t[NITIO_G1_CMD]\t\t\t= { 0x00e, 2 },\t \n\t[NITIO_G0_HW_SAVE]\t\t= { 0x010, 4 },\t \n\t[NITIO_G1_HW_SAVE]\t\t= { 0x014, 4 },\t \n\t[NI660X_STC_DIO_OUTPUT]\t\t= { 0x014, 2 },\t \n\t[NI660X_STC_DIO_CONTROL]\t= { 0x016, 2 },\t \n\t[NITIO_G0_SW_SAVE]\t\t= { 0x018, 4 },\t \n\t[NITIO_G1_SW_SAVE]\t\t= { 0x01c, 4 },\t \n\t[NITIO_G0_MODE]\t\t\t= { 0x034, 2 },\t \n\t[NITIO_G01_STATUS1]\t\t= { 0x036, 2 },\t \n\t[NITIO_G1_MODE]\t\t\t= { 0x036, 2 },\t \n\t[NI660X_STC_DIO_SERIAL_INPUT]\t= { 0x038, 2 },\t \n\t[NITIO_G0_LOADA]\t\t= { 0x038, 4 },\t \n\t[NITIO_G01_STATUS2]\t\t= { 0x03a, 2 },\t \n\t[NITIO_G0_LOADB]\t\t= { 0x03c, 4 },\t \n\t[NITIO_G1_LOADA]\t\t= { 0x040, 4 },\t \n\t[NITIO_G1_LOADB]\t\t= { 0x044, 4 },\t \n\t[NITIO_G0_INPUT_SEL]\t\t= { 0x048, 2 },\t \n\t[NITIO_G1_INPUT_SEL]\t\t= { 0x04a, 2 },\t \n\t[NITIO_G0_AUTO_INC]\t\t= { 0x088, 2 },\t \n\t[NITIO_G1_AUTO_INC]\t\t= { 0x08a, 2 },\t \n\t[NITIO_G01_RESET]\t\t= { 0x090, 2 },\t \n\t[NITIO_G0_INT_ENA]\t\t= { 0x092, 2 },\t \n\t[NITIO_G1_INT_ENA]\t\t= { 0x096, 2 },\t \n\t[NITIO_G0_CNT_MODE]\t\t= { 0x0b0, 2 },\t \n\t[NITIO_G1_CNT_MODE]\t\t= { 0x0b2, 2 },\t \n\t[NITIO_G0_GATE2]\t\t= { 0x0b4, 2 },\t \n\t[NITIO_G1_GATE2]\t\t= { 0x0b6, 2 },\t \n\t[NITIO_G0_DMA_CFG]\t\t= { 0x0b8, 2 },\t \n\t[NITIO_G0_DMA_STATUS]\t\t= { 0x0b8, 2 },\t \n\t[NITIO_G1_DMA_CFG]\t\t= { 0x0ba, 2 },\t \n\t[NITIO_G1_DMA_STATUS]\t\t= { 0x0ba, 2 },\t \n\t[NITIO_G2_INT_ACK]\t\t= { 0x104, 2 },\t \n\t[NITIO_G2_STATUS]\t\t= { 0x104, 2 },\t \n\t[NITIO_G3_INT_ACK]\t\t= { 0x106, 2 },\t \n\t[NITIO_G3_STATUS]\t\t= { 0x106, 2 },\t \n\t[NITIO_G23_STATUS]\t\t= { 0x108, 2 },\t \n\t[NITIO_G2_CMD]\t\t\t= { 0x10c, 2 },\t \n\t[NITIO_G3_CMD]\t\t\t= { 0x10e, 2 },\t \n\t[NITIO_G2_HW_SAVE]\t\t= { 0x110, 4 },\t \n\t[NITIO_G3_HW_SAVE]\t\t= { 0x114, 4 },\t \n\t[NITIO_G2_SW_SAVE]\t\t= { 0x118, 4 },\t \n\t[NITIO_G3_SW_SAVE]\t\t= { 0x11c, 4 },\t \n\t[NITIO_G2_MODE]\t\t\t= { 0x134, 2 },\t \n\t[NITIO_G23_STATUS1]\t\t= { 0x136, 2 },\t \n\t[NITIO_G3_MODE]\t\t\t= { 0x136, 2 },\t \n\t[NITIO_G2_LOADA]\t\t= { 0x138, 4 },\t \n\t[NITIO_G23_STATUS2]\t\t= { 0x13a, 2 },\t \n\t[NITIO_G2_LOADB]\t\t= { 0x13c, 4 },\t \n\t[NITIO_G3_LOADA]\t\t= { 0x140, 4 },\t \n\t[NITIO_G3_LOADB]\t\t= { 0x144, 4 },\t \n\t[NITIO_G2_INPUT_SEL]\t\t= { 0x148, 2 },\t \n\t[NITIO_G3_INPUT_SEL]\t\t= { 0x14a, 2 },\t \n\t[NITIO_G2_AUTO_INC]\t\t= { 0x188, 2 },\t \n\t[NITIO_G3_AUTO_INC]\t\t= { 0x18a, 2 },\t \n\t[NITIO_G23_RESET]\t\t= { 0x190, 2 },\t \n\t[NITIO_G2_INT_ENA]\t\t= { 0x192, 2 },\t \n\t[NITIO_G3_INT_ENA]\t\t= { 0x196, 2 },\t \n\t[NITIO_G2_CNT_MODE]\t\t= { 0x1b0, 2 },\t \n\t[NITIO_G3_CNT_MODE]\t\t= { 0x1b2, 2 },\t \n\t[NITIO_G2_GATE2]\t\t= { 0x1b4, 2 },\t \n\t[NITIO_G3_GATE2]\t\t= { 0x1b6, 2 },\t \n\t[NITIO_G2_DMA_CFG]\t\t= { 0x1b8, 2 },\t \n\t[NITIO_G2_DMA_STATUS]\t\t= { 0x1b8, 2 },\t \n\t[NITIO_G3_DMA_CFG]\t\t= { 0x1ba, 2 },\t \n\t[NITIO_G3_DMA_STATUS]\t\t= { 0x1ba, 2 },\t \n\t[NI660X_DIO32_INPUT]\t\t= { 0x414, 4 },\t \n\t[NI660X_DIO32_OUTPUT]\t\t= { 0x510, 4 },\t \n\t[NI660X_CLK_CFG]\t\t= { 0x73c, 4 },\t \n\t[NI660X_GLOBAL_INT_STATUS]\t= { 0x754, 4 },\t \n\t[NI660X_DMA_CFG]\t\t= { 0x76c, 4 },\t \n\t[NI660X_GLOBAL_INT_CFG]\t\t= { 0x770, 4 },\t \n\t[NI660X_IO_CFG_0_1]\t\t= { 0x77c, 2 },\t \n\t[NI660X_IO_CFG_2_3]\t\t= { 0x77e, 2 },\t \n\t[NI660X_IO_CFG_4_5]\t\t= { 0x780, 2 },\t \n\t[NI660X_IO_CFG_6_7]\t\t= { 0x782, 2 },\t \n\t[NI660X_IO_CFG_8_9]\t\t= { 0x784, 2 },\t \n\t[NI660X_IO_CFG_10_11]\t\t= { 0x786, 2 },\t \n\t[NI660X_IO_CFG_12_13]\t\t= { 0x788, 2 },\t \n\t[NI660X_IO_CFG_14_15]\t\t= { 0x78a, 2 },\t \n\t[NI660X_IO_CFG_16_17]\t\t= { 0x78c, 2 },\t \n\t[NI660X_IO_CFG_18_19]\t\t= { 0x78e, 2 },\t \n\t[NI660X_IO_CFG_20_21]\t\t= { 0x790, 2 },\t \n\t[NI660X_IO_CFG_22_23]\t\t= { 0x792, 2 },\t \n\t[NI660X_IO_CFG_24_25]\t\t= { 0x794, 2 },\t \n\t[NI660X_IO_CFG_26_27]\t\t= { 0x796, 2 },\t \n\t[NI660X_IO_CFG_28_29]\t\t= { 0x798, 2 },\t \n\t[NI660X_IO_CFG_30_31]\t\t= { 0x79a, 2 },\t \n\t[NI660X_IO_CFG_32_33]\t\t= { 0x79c, 2 },\t \n\t[NI660X_IO_CFG_34_35]\t\t= { 0x79e, 2 },\t \n\t[NI660X_IO_CFG_36_37]\t\t= { 0x7a0, 2 },\t \n\t[NI660X_IO_CFG_38_39]\t\t= { 0x7a2, 2 }\t \n};\n\n#define NI660X_CHIP_OFFSET\t\t0x800\n\nenum ni_660x_boardid {\n\tBOARD_PCI6601,\n\tBOARD_PCI6602,\n\tBOARD_PXI6602,\n\tBOARD_PCI6608,\n\tBOARD_PXI6608,\n\tBOARD_PCI6624,\n\tBOARD_PXI6624\n};\n\nstruct ni_660x_board {\n\tconst char *name;\n\tunsigned int n_chips;\t \n};\n\nstatic const struct ni_660x_board ni_660x_boards[] = {\n\t[BOARD_PCI6601] = {\n\t\t.name\t\t= \"PCI-6601\",\n\t\t.n_chips\t= 1,\n\t},\n\t[BOARD_PCI6602] = {\n\t\t.name\t\t= \"PCI-6602\",\n\t\t.n_chips\t= 2,\n\t},\n\t[BOARD_PXI6602] = {\n\t\t.name\t\t= \"PXI-6602\",\n\t\t.n_chips\t= 2,\n\t},\n\t[BOARD_PCI6608] = {\n\t\t.name\t\t= \"PCI-6608\",\n\t\t.n_chips\t= 2,\n\t},\n\t[BOARD_PXI6608] = {\n\t\t.name\t\t= \"PXI-6608\",\n\t\t.n_chips\t= 2,\n\t},\n\t[BOARD_PCI6624] = {\n\t\t.name\t\t= \"PCI-6624\",\n\t\t.n_chips\t= 2,\n\t},\n\t[BOARD_PXI6624] = {\n\t\t.name\t\t= \"PXI-6624\",\n\t\t.n_chips\t= 2,\n\t},\n};\n\n#define NI660X_NUM_PFI_CHANNELS\t\t40\n\n \n#define NI660X_MAX_DMA_CHANNEL\t\t4\n\n#define NI660X_COUNTERS_PER_CHIP\t4\n#define NI660X_MAX_CHIPS\t\t2\n#define NI660X_MAX_COUNTERS\t\t(NI660X_MAX_CHIPS *\t\\\n\t\t\t\t\t NI660X_COUNTERS_PER_CHIP)\n\nstruct ni_660x_private {\n\tstruct mite *mite;\n\tstruct ni_gpct_device *counter_dev;\n\tstruct mite_ring *ring[NI660X_MAX_CHIPS][NI660X_COUNTERS_PER_CHIP];\n\t \n\tspinlock_t mite_channel_lock;\n\t \n\tspinlock_t interrupt_lock;\n\tunsigned int dma_cfg[NI660X_MAX_CHIPS];\n\tunsigned int io_cfg[NI660X_NUM_PFI_CHANNELS];\n\tu64 io_dir;\n\tstruct ni_route_tables routing_tables;\n};\n\nstatic void ni_660x_write(struct comedi_device *dev, unsigned int chip,\n\t\t\t  unsigned int bits, unsigned int reg)\n{\n\tunsigned int addr = (chip * NI660X_CHIP_OFFSET) +\n\t\t\t    ni_660x_reg_data[reg].offset;\n\n\tif (ni_660x_reg_data[reg].size == 2)\n\t\twritew(bits, dev->mmio + addr);\n\telse\n\t\twritel(bits, dev->mmio + addr);\n}\n\nstatic unsigned int ni_660x_read(struct comedi_device *dev,\n\t\t\t\t unsigned int chip, unsigned int reg)\n{\n\tunsigned int addr = (chip * NI660X_CHIP_OFFSET) +\n\t\t\t    ni_660x_reg_data[reg].offset;\n\n\tif (ni_660x_reg_data[reg].size == 2)\n\t\treturn readw(dev->mmio + addr);\n\treturn readl(dev->mmio + addr);\n}\n\nstatic void ni_660x_gpct_write(struct ni_gpct *counter, unsigned int bits,\n\t\t\t       enum ni_gpct_register reg)\n{\n\tstruct comedi_device *dev = counter->counter_dev->dev;\n\n\tni_660x_write(dev, counter->chip_index, bits, reg);\n}\n\nstatic unsigned int ni_660x_gpct_read(struct ni_gpct *counter,\n\t\t\t\t      enum ni_gpct_register reg)\n{\n\tstruct comedi_device *dev = counter->counter_dev->dev;\n\n\treturn ni_660x_read(dev, counter->chip_index, reg);\n}\n\nstatic inline void ni_660x_set_dma_channel(struct comedi_device *dev,\n\t\t\t\t\t   unsigned int mite_channel,\n\t\t\t\t\t   struct ni_gpct *counter)\n{\n\tstruct ni_660x_private *devpriv = dev->private;\n\tunsigned int chip = counter->chip_index;\n\n\tdevpriv->dma_cfg[chip] &= ~NI660X_DMA_CFG_SEL_MASK(mite_channel);\n\tdevpriv->dma_cfg[chip] |= NI660X_DMA_CFG_SEL(mite_channel,\n\t\t\t\t\t\t     counter->counter_index);\n\tni_660x_write(dev, chip, devpriv->dma_cfg[chip] |\n\t\t      NI660X_DMA_CFG_RESET(mite_channel),\n\t\t      NI660X_DMA_CFG);\n}\n\nstatic inline void ni_660x_unset_dma_channel(struct comedi_device *dev,\n\t\t\t\t\t     unsigned int mite_channel,\n\t\t\t\t\t     struct ni_gpct *counter)\n{\n\tstruct ni_660x_private *devpriv = dev->private;\n\tunsigned int chip = counter->chip_index;\n\n\tdevpriv->dma_cfg[chip] &= ~NI660X_DMA_CFG_SEL_MASK(mite_channel);\n\tdevpriv->dma_cfg[chip] |= NI660X_DMA_CFG_SEL_NONE(mite_channel);\n\tni_660x_write(dev, chip, devpriv->dma_cfg[chip], NI660X_DMA_CFG);\n}\n\nstatic int ni_660x_request_mite_channel(struct comedi_device *dev,\n\t\t\t\t\tstruct ni_gpct *counter,\n\t\t\t\t\tenum comedi_io_direction direction)\n{\n\tstruct ni_660x_private *devpriv = dev->private;\n\tstruct mite_ring *ring;\n\tstruct mite_channel *mite_chan;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&devpriv->mite_channel_lock, flags);\n\tring = devpriv->ring[counter->chip_index][counter->counter_index];\n\tmite_chan = mite_request_channel(devpriv->mite, ring);\n\tif (!mite_chan) {\n\t\tspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\n\t\tdev_err(dev->class_dev,\n\t\t\t\"failed to reserve mite dma channel for counter\\n\");\n\t\treturn -EBUSY;\n\t}\n\tmite_chan->dir = direction;\n\tni_tio_set_mite_channel(counter, mite_chan);\n\tni_660x_set_dma_channel(dev, mite_chan->channel, counter);\n\tspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\n\treturn 0;\n}\n\nstatic void ni_660x_release_mite_channel(struct comedi_device *dev,\n\t\t\t\t\t struct ni_gpct *counter)\n{\n\tstruct ni_660x_private *devpriv = dev->private;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&devpriv->mite_channel_lock, flags);\n\tif (counter->mite_chan) {\n\t\tstruct mite_channel *mite_chan = counter->mite_chan;\n\n\t\tni_660x_unset_dma_channel(dev, mite_chan->channel, counter);\n\t\tni_tio_set_mite_channel(counter, NULL);\n\t\tmite_release_channel(mite_chan);\n\t}\n\tspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\n}\n\nstatic int ni_660x_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\n{\n\tstruct ni_gpct *counter = s->private;\n\tint retval;\n\n\tretval = ni_660x_request_mite_channel(dev, counter, COMEDI_INPUT);\n\tif (retval) {\n\t\tdev_err(dev->class_dev,\n\t\t\t\"no dma channel available for use by counter\\n\");\n\t\treturn retval;\n\t}\n\tni_tio_acknowledge(counter);\n\n\treturn ni_tio_cmd(dev, s);\n}\n\nstatic int ni_660x_cancel(struct comedi_device *dev, struct comedi_subdevice *s)\n{\n\tstruct ni_gpct *counter = s->private;\n\tint retval;\n\n\tretval = ni_tio_cancel(counter);\n\tni_660x_release_mite_channel(dev, counter);\n\treturn retval;\n}\n\nstatic void set_tio_counterswap(struct comedi_device *dev, int chip)\n{\n\tunsigned int bits = 0;\n\n\t \n\tif (chip)\n\t\tbits = NI660X_CLK_CFG_COUNTER_SWAP;\n\n\tni_660x_write(dev, chip, bits, NI660X_CLK_CFG);\n}\n\nstatic void ni_660x_handle_gpct_interrupt(struct comedi_device *dev,\n\t\t\t\t\t  struct comedi_subdevice *s)\n{\n\tstruct ni_gpct *counter = s->private;\n\n\tni_tio_handle_interrupt(counter, s);\n\tcomedi_handle_events(dev, s);\n}\n\nstatic irqreturn_t ni_660x_interrupt(int irq, void *d)\n{\n\tstruct comedi_device *dev = d;\n\tstruct ni_660x_private *devpriv = dev->private;\n\tstruct comedi_subdevice *s;\n\tunsigned int i;\n\tunsigned long flags;\n\n\tif (!dev->attached)\n\t\treturn IRQ_NONE;\n\t \n\tsmp_mb();\n\n\t \n\tspin_lock_irqsave(&devpriv->interrupt_lock, flags);\n\tfor (i = 0; i < dev->n_subdevices; ++i) {\n\t\ts = &dev->subdevices[i];\n\t\tif (s->type == COMEDI_SUBD_COUNTER)\n\t\t\tni_660x_handle_gpct_interrupt(dev, s);\n\t}\n\tspin_unlock_irqrestore(&devpriv->interrupt_lock, flags);\n\treturn IRQ_HANDLED;\n}\n\nstatic int ni_660x_input_poll(struct comedi_device *dev,\n\t\t\t      struct comedi_subdevice *s)\n{\n\tstruct ni_660x_private *devpriv = dev->private;\n\tstruct ni_gpct *counter = s->private;\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&devpriv->interrupt_lock, flags);\n\tmite_sync_dma(counter->mite_chan, s);\n\tspin_unlock_irqrestore(&devpriv->interrupt_lock, flags);\n\treturn comedi_buf_read_n_available(s);\n}\n\nstatic int ni_660x_buf_change(struct comedi_device *dev,\n\t\t\t      struct comedi_subdevice *s)\n{\n\tstruct ni_660x_private *devpriv = dev->private;\n\tstruct ni_gpct *counter = s->private;\n\tstruct mite_ring *ring;\n\tint ret;\n\n\tring = devpriv->ring[counter->chip_index][counter->counter_index];\n\tret = mite_buf_change(ring, s);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int ni_660x_allocate_private(struct comedi_device *dev)\n{\n\tstruct ni_660x_private *devpriv;\n\tunsigned int i;\n\n\tdevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\n\tif (!devpriv)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&devpriv->mite_channel_lock);\n\tspin_lock_init(&devpriv->interrupt_lock);\n\tfor (i = 0; i < NI660X_NUM_PFI_CHANNELS; ++i)\n\t\tdevpriv->io_cfg[i] = NI_660X_PFI_OUTPUT_COUNTER;\n\n\treturn 0;\n}\n\nstatic int ni_660x_alloc_mite_rings(struct comedi_device *dev)\n{\n\tconst struct ni_660x_board *board = dev->board_ptr;\n\tstruct ni_660x_private *devpriv = dev->private;\n\tunsigned int i;\n\tunsigned int j;\n\n\tfor (i = 0; i < board->n_chips; ++i) {\n\t\tfor (j = 0; j < NI660X_COUNTERS_PER_CHIP; ++j) {\n\t\t\tdevpriv->ring[i][j] = mite_alloc_ring(devpriv->mite);\n\t\t\tif (!devpriv->ring[i][j])\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void ni_660x_free_mite_rings(struct comedi_device *dev)\n{\n\tconst struct ni_660x_board *board = dev->board_ptr;\n\tstruct ni_660x_private *devpriv = dev->private;\n\tunsigned int i;\n\tunsigned int j;\n\n\tfor (i = 0; i < board->n_chips; ++i) {\n\t\tfor (j = 0; j < NI660X_COUNTERS_PER_CHIP; ++j)\n\t\t\tmite_free_ring(devpriv->ring[i][j]);\n\t}\n}\n\nstatic int ni_660x_dio_insn_bits(struct comedi_device *dev,\n\t\t\t\t struct comedi_subdevice *s,\n\t\t\t\t struct comedi_insn *insn,\n\t\t\t\t unsigned int *data)\n{\n\tunsigned int shift = CR_CHAN(insn->chanspec);\n\tunsigned int mask = data[0] << shift;\n\tunsigned int bits = data[1] << shift;\n\n\t \n\tif (mask) {\n\t\ts->state &= ~mask;\n\t\ts->state |= (bits & mask);\n\t\tni_660x_write(dev, 0, s->state, NI660X_DIO32_OUTPUT);\n\t}\n\n\t \n\tdata[1] = ni_660x_read(dev, 0, NI660X_DIO32_INPUT) >> shift;\n\n\treturn insn->n;\n}\n\nstatic void ni_660x_select_pfi_output(struct comedi_device *dev,\n\t\t\t\t      unsigned int chan, unsigned int out_sel)\n{\n\tconst struct ni_660x_board *board = dev->board_ptr;\n\tunsigned int active_chip = 0;\n\tunsigned int idle_chip = 0;\n\tunsigned int bits;\n\n\tif (chan >= NI_PFI(0))\n\t\t \n\t\tchan -= NI_PFI(0);\n\n\tif (board->n_chips > 1) {\n\t\tif (out_sel == NI_660X_PFI_OUTPUT_COUNTER &&\n\t\t    chan >= 8 && chan <= 23) {\n\t\t\t \n\t\t\tactive_chip = 1;\n\t\t\tidle_chip = 0;\n\t\t} else {\n\t\t\t \n\t\t\tactive_chip = 0;\n\t\t\tidle_chip = 1;\n\t\t}\n\t}\n\n\tif (idle_chip != active_chip) {\n\t\t \n\t\tbits = ni_660x_read(dev, idle_chip, NI660X_IO_CFG(chan));\n\t\tbits &= ~NI660X_IO_CFG_OUT_SEL_MASK(chan);\n\t\tbits |= NI660X_IO_CFG_OUT_SEL(chan, 0);\t\t \n\t\tni_660x_write(dev, idle_chip, bits, NI660X_IO_CFG(chan));\n\t}\n\n\t \n\tbits = ni_660x_read(dev, active_chip, NI660X_IO_CFG(chan));\n\tbits &= ~NI660X_IO_CFG_OUT_SEL_MASK(chan);\n\tbits |= NI660X_IO_CFG_OUT_SEL(chan, out_sel);\n\tni_660x_write(dev, active_chip, bits, NI660X_IO_CFG(chan));\n}\n\nstatic void ni_660x_set_pfi_direction(struct comedi_device *dev,\n\t\t\t\t      unsigned int chan,\n\t\t\t\t      unsigned int direction)\n{\n\tstruct ni_660x_private *devpriv = dev->private;\n\tu64 bit;\n\n\tif (chan >= NI_PFI(0))\n\t\t \n\t\tchan -= NI_PFI(0);\n\n\tbit = 1ULL << chan;\n\n\tif (direction == COMEDI_OUTPUT) {\n\t\tdevpriv->io_dir |= bit;\n\t\t \n\t\tni_660x_select_pfi_output(dev, chan, devpriv->io_cfg[chan]);\n\t} else {\n\t\tdevpriv->io_dir &= ~bit;\n\t\t \n\t\tni_660x_select_pfi_output(dev, chan, 0);\n\t}\n}\n\nstatic unsigned int ni_660x_get_pfi_direction(struct comedi_device *dev,\n\t\t\t\t\t      unsigned int chan)\n{\n\tstruct ni_660x_private *devpriv = dev->private;\n\tu64 bit;\n\n\tif (chan >= NI_PFI(0))\n\t\t \n\t\tchan -= NI_PFI(0);\n\n\tbit = 1ULL << chan;\n\n\treturn (devpriv->io_dir & bit) ? COMEDI_OUTPUT : COMEDI_INPUT;\n}\n\nstatic int ni_660x_set_pfi_routing(struct comedi_device *dev,\n\t\t\t\t   unsigned int chan, unsigned int source)\n{\n\tstruct ni_660x_private *devpriv = dev->private;\n\n\tif (chan >= NI_PFI(0))\n\t\t \n\t\tchan -= NI_PFI(0);\n\n\tswitch (source) {\n\tcase NI_660X_PFI_OUTPUT_COUNTER:\n\t\tif (chan < 8)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase NI_660X_PFI_OUTPUT_DIO:\n\t\tif (chan > 31)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tdevpriv->io_cfg[chan] = source;\n\tif (ni_660x_get_pfi_direction(dev, chan) == COMEDI_OUTPUT)\n\t\tni_660x_select_pfi_output(dev, chan, devpriv->io_cfg[chan]);\n\treturn 0;\n}\n\nstatic int ni_660x_get_pfi_routing(struct comedi_device *dev, unsigned int chan)\n{\n\tstruct ni_660x_private *devpriv = dev->private;\n\n\tif (chan >= NI_PFI(0))\n\t\t \n\t\tchan -= NI_PFI(0);\n\n\treturn devpriv->io_cfg[chan];\n}\n\nstatic void ni_660x_set_pfi_filter(struct comedi_device *dev,\n\t\t\t\t   unsigned int chan, unsigned int value)\n{\n\tunsigned int val;\n\n\tif (chan >= NI_PFI(0))\n\t\t \n\t\tchan -= NI_PFI(0);\n\n\tval = ni_660x_read(dev, 0, NI660X_IO_CFG(chan));\n\tval &= ~NI660X_IO_CFG_IN_SEL_MASK(chan);\n\tval |= NI660X_IO_CFG_IN_SEL(chan, value);\n\tni_660x_write(dev, 0, val, NI660X_IO_CFG(chan));\n}\n\nstatic int ni_660x_dio_insn_config(struct comedi_device *dev,\n\t\t\t\t   struct comedi_subdevice *s,\n\t\t\t\t   struct comedi_insn *insn,\n\t\t\t\t   unsigned int *data)\n{\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tint ret;\n\n\tswitch (data[0]) {\n\tcase INSN_CONFIG_DIO_OUTPUT:\n\t\tni_660x_set_pfi_direction(dev, chan, COMEDI_OUTPUT);\n\t\tbreak;\n\n\tcase INSN_CONFIG_DIO_INPUT:\n\t\tni_660x_set_pfi_direction(dev, chan, COMEDI_INPUT);\n\t\tbreak;\n\n\tcase INSN_CONFIG_DIO_QUERY:\n\t\tdata[1] = ni_660x_get_pfi_direction(dev, chan);\n\t\tbreak;\n\n\tcase INSN_CONFIG_SET_ROUTING:\n\t\tret = ni_660x_set_pfi_routing(dev, chan, data[1]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\n\tcase INSN_CONFIG_GET_ROUTING:\n\t\tdata[1] = ni_660x_get_pfi_routing(dev, chan);\n\t\tbreak;\n\n\tcase INSN_CONFIG_FILTER:\n\t\tni_660x_set_pfi_filter(dev, chan, data[1]);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn insn->n;\n}\n\nstatic unsigned int _ni_get_valid_routes(struct comedi_device *dev,\n\t\t\t\t\t unsigned int n_pairs,\n\t\t\t\t\t unsigned int *pair_data)\n{\n\tstruct ni_660x_private *devpriv = dev->private;\n\n\treturn ni_get_valid_routes(&devpriv->routing_tables, n_pairs,\n\t\t\t\t   pair_data);\n}\n\n \nstatic inline int get_output_select_source(int dest, struct comedi_device *dev)\n{\n\tstruct ni_660x_private *devpriv = dev->private;\n\tint reg = -1;\n\n\tif (channel_is_pfi(dest)) {\n\t\tif (ni_660x_get_pfi_direction(dev, dest) == COMEDI_OUTPUT)\n\t\t\treg = ni_660x_get_pfi_routing(dev, dest);\n\t} else if (channel_is_rtsi(dest)) {\n\t\tdev_dbg(dev->class_dev,\n\t\t\t\"%s: unhandled rtsi destination (%d) queried\\n\",\n\t\t\t__func__, dest);\n\t\t \n\t} else if (channel_is_ctr(dest)) {\n\t\treg = ni_tio_get_routing(devpriv->counter_dev, dest);\n\t} else {\n\t\tdev_dbg(dev->class_dev,\n\t\t\t\"%s: unhandled destination (%d) queried\\n\",\n\t\t\t__func__, dest);\n\t}\n\n\tif (reg >= 0)\n\t\treturn ni_find_route_source(CR_CHAN(reg), dest,\n\t\t\t\t\t    &devpriv->routing_tables);\n\treturn -EINVAL;\n}\n\n \nstatic inline int test_route(unsigned int src, unsigned int dest,\n\t\t\t     struct comedi_device *dev)\n{\n\tstruct ni_660x_private *devpriv = dev->private;\n\ts8 reg = ni_route_to_register(CR_CHAN(src), dest,\n\t\t\t\t      &devpriv->routing_tables);\n\n\tif (reg < 0)\n\t\treturn -1;\n\tif (get_output_select_source(dest, dev) != CR_CHAN(src))\n\t\treturn 0;\n\treturn 1;\n}\n\n \nstatic inline int connect_route(unsigned int src, unsigned int dest,\n\t\t\t\tstruct comedi_device *dev)\n{\n\tstruct ni_660x_private *devpriv = dev->private;\n\ts8 reg = ni_route_to_register(CR_CHAN(src), dest,\n\t\t\t\t      &devpriv->routing_tables);\n\ts8 current_src;\n\n\tif (reg < 0)\n\t\t \n\t\treturn -EINVAL;\n\n\tcurrent_src = get_output_select_source(dest, dev);\n\tif (current_src == CR_CHAN(src))\n\t\treturn -EALREADY;\n\tif (current_src >= 0)\n\t\t \n\t\treturn -EBUSY;\n\n\t \n\tif (channel_is_pfi(CR_CHAN(dest))) {\n\t\t \n\t\tni_660x_set_pfi_routing(dev, dest, reg);\n\t\tni_660x_set_pfi_direction(dev, dest, COMEDI_OUTPUT);\n\t} else if (channel_is_rtsi(CR_CHAN(dest))) {\n\t\tdev_dbg(dev->class_dev, \"%s: unhandled rtsi destination (%d)\\n\",\n\t\t\t__func__, dest);\n\t\treturn -EINVAL;\n\t\t \n\t} else if (channel_is_ctr(CR_CHAN(dest))) {\n\t\t \n\t\tni_tio_set_routing(devpriv->counter_dev, dest,\n\t\t\t\t   reg | (src & ~CR_CHAN(-1)));\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic inline int disconnect_route(unsigned int src, unsigned int dest,\n\t\t\t\t   struct comedi_device *dev)\n{\n\tstruct ni_660x_private *devpriv = dev->private;\n\ts8 reg = ni_route_to_register(CR_CHAN(src), CR_CHAN(dest),\n\t\t\t\t      &devpriv->routing_tables);\n\n\tif (reg < 0)\n\t\t \n\t\treturn -EINVAL;\n\tif (get_output_select_source(dest, dev) != CR_CHAN(src))\n\t\t \n\t\treturn -EINVAL;\n\n\t \n\tif (channel_is_pfi(CR_CHAN(dest))) {\n\t\tunsigned int source = ((CR_CHAN(dest) - NI_PFI(0)) < 8)\n\t\t\t\t\t? NI_660X_PFI_OUTPUT_DIO\n\t\t\t\t\t: NI_660X_PFI_OUTPUT_COUNTER;\n\n\t\t \n\t\tni_660x_set_pfi_direction(dev, dest, COMEDI_INPUT);\n\t\tni_660x_set_pfi_routing(dev, dest, source);\n\t} else if (channel_is_rtsi(CR_CHAN(dest))) {\n\t\tdev_dbg(dev->class_dev, \"%s: unhandled rtsi destination (%d)\\n\",\n\t\t\t__func__, dest);\n\t\treturn -EINVAL;\n\t\t \n\t} else if (channel_is_ctr(CR_CHAN(dest))) {\n\t\tni_tio_unset_routing(devpriv->counter_dev, dest);\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int ni_global_insn_config(struct comedi_device *dev,\n\t\t\t\t struct comedi_insn *insn,\n\t\t\t\t unsigned int *data)\n{\n\tswitch (data[0]) {\n\tcase INSN_DEVICE_CONFIG_TEST_ROUTE:\n\t\tdata[0] = test_route(data[1], data[2], dev);\n\t\treturn 2;\n\tcase INSN_DEVICE_CONFIG_CONNECT_ROUTE:\n\t\treturn connect_route(data[1], data[2], dev);\n\tcase INSN_DEVICE_CONFIG_DISCONNECT_ROUTE:\n\t\treturn disconnect_route(data[1], data[2], dev);\n\t \n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 1;\n}\n\nstatic void ni_660x_init_tio_chips(struct comedi_device *dev,\n\t\t\t\t   unsigned int n_chips)\n{\n\tstruct ni_660x_private *devpriv = dev->private;\n\tunsigned int chip;\n\tunsigned int chan;\n\n\t \n\tni_660x_write(dev, 0, 0, NI660X_STC_DIO_CONTROL);\n\n\tfor (chip = 0; chip < n_chips; ++chip) {\n\t\t \n\t\tdevpriv->dma_cfg[chip] = 0;\n\t\tfor (chan = 0; chan < NI660X_MAX_DMA_CHANNEL; ++chan)\n\t\t\tdevpriv->dma_cfg[chip] |= NI660X_DMA_CFG_SEL_NONE(chan);\n\t\tni_660x_write(dev, chip, devpriv->dma_cfg[chip],\n\t\t\t      NI660X_DMA_CFG);\n\n\t\t \n\t\tfor (chan = 0; chan < NI660X_NUM_PFI_CHANNELS; ++chan)\n\t\t\tni_660x_write(dev, chip, 0, NI660X_IO_CFG(chan));\n\t}\n}\n\nstatic int ni_660x_auto_attach(struct comedi_device *dev,\n\t\t\t       unsigned long context)\n{\n\tstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\n\tconst struct ni_660x_board *board = NULL;\n\tstruct ni_660x_private *devpriv;\n\tstruct comedi_subdevice *s;\n\tstruct ni_gpct_device *gpct_dev;\n\tunsigned int n_counters;\n\tint subdev;\n\tint ret;\n\tunsigned int i;\n\tunsigned int global_interrupt_config_bits;\n\n\tif (context < ARRAY_SIZE(ni_660x_boards))\n\t\tboard = &ni_660x_boards[context];\n\tif (!board)\n\t\treturn -ENODEV;\n\tdev->board_ptr = board;\n\tdev->board_name = board->name;\n\n\tret = comedi_pci_enable(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ni_660x_allocate_private(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\tdevpriv = dev->private;\n\n\tdevpriv->mite = mite_attach(dev, true);\t\t \n\tif (!devpriv->mite)\n\t\treturn -ENOMEM;\n\n\tret = ni_660x_alloc_mite_rings(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tni_660x_init_tio_chips(dev, board->n_chips);\n\n\t \n\tif (ni_assign_device_routes(\"ni_660x\", board->name, NULL,\n\t\t\t\t    &devpriv->routing_tables) < 0) {\n\t\tdev_warn(dev->class_dev, \"%s: %s device has no signal routing table.\\n\",\n\t\t\t __func__, board->name);\n\t\tdev_warn(dev->class_dev, \"%s: High level NI signal names will not be available for this %s board.\\n\",\n\t\t\t __func__, board->name);\n\t} else {\n\t\t \n\t\tdev->insn_device_config = ni_global_insn_config;\n\t\tdev->get_valid_routes = _ni_get_valid_routes;\n\t}\n\n\tn_counters = board->n_chips * NI660X_COUNTERS_PER_CHIP;\n\tgpct_dev = ni_gpct_device_construct(dev,\n\t\t\t\t\t    ni_660x_gpct_write,\n\t\t\t\t\t    ni_660x_gpct_read,\n\t\t\t\t\t    ni_gpct_variant_660x,\n\t\t\t\t\t    n_counters,\n\t\t\t\t\t    NI660X_COUNTERS_PER_CHIP,\n\t\t\t\t\t    &devpriv->routing_tables);\n\tif (!gpct_dev)\n\t\treturn -ENOMEM;\n\tdevpriv->counter_dev = gpct_dev;\n\n\tret = comedi_alloc_subdevices(dev, 2 + NI660X_MAX_COUNTERS);\n\tif (ret)\n\t\treturn ret;\n\n\tsubdev = 0;\n\n\ts = &dev->subdevices[subdev++];\n\t \n\ts->type = COMEDI_SUBD_UNUSED;\n\n\t \n\ts = &dev->subdevices[subdev++];\n\ts->type\t\t= COMEDI_SUBD_DIO;\n\ts->subdev_flags\t= SDF_READABLE | SDF_WRITABLE;\n\ts->n_chan\t= NI660X_NUM_PFI_CHANNELS;\n\ts->maxdata\t= 1;\n\ts->range_table\t= &range_digital;\n\ts->insn_bits\t= ni_660x_dio_insn_bits;\n\ts->insn_config\t= ni_660x_dio_insn_config;\n\n\t  \n\tfor (i = 0; i < s->n_chan; ++i) {\n\t\tunsigned int source = (i < 8) ? NI_660X_PFI_OUTPUT_DIO\n\t\t\t\t\t      : NI_660X_PFI_OUTPUT_COUNTER;\n\n\t\tni_660x_set_pfi_routing(dev, i, source);\n\t\tni_660x_set_pfi_direction(dev, i, COMEDI_INPUT); \n\t}\n\n\t \n\tfor (i = 0; i < NI660X_MAX_COUNTERS; ++i) {\n\t\ts = &dev->subdevices[subdev++];\n\t\tif (i < n_counters) {\n\t\t\tstruct ni_gpct *counter = &gpct_dev->counters[i];\n\n\t\t\ts->type\t\t= COMEDI_SUBD_COUNTER;\n\t\t\ts->subdev_flags\t= SDF_READABLE | SDF_WRITABLE |\n\t\t\t\t\t  SDF_LSAMPL | SDF_CMD_READ;\n\t\t\ts->n_chan\t= 3;\n\t\t\ts->maxdata\t= 0xffffffff;\n\t\t\ts->insn_read\t= ni_tio_insn_read;\n\t\t\ts->insn_write\t= ni_tio_insn_write;\n\t\t\ts->insn_config\t= ni_tio_insn_config;\n\t\t\ts->len_chanlist\t= 1;\n\t\t\ts->do_cmd\t= ni_660x_cmd;\n\t\t\ts->do_cmdtest\t= ni_tio_cmdtest;\n\t\t\ts->cancel\t= ni_660x_cancel;\n\t\t\ts->poll\t\t= ni_660x_input_poll;\n\t\t\ts->buf_change\t= ni_660x_buf_change;\n\t\t\ts->async_dma_dir = DMA_BIDIRECTIONAL;\n\t\t\ts->private\t= counter;\n\n\t\t\tni_tio_init_counter(counter);\n\t\t} else {\n\t\t\ts->type\t\t= COMEDI_SUBD_UNUSED;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < board->n_chips; ++i)\n\t\tset_tio_counterswap(dev, i);\n\n\tret = request_irq(pcidev->irq, ni_660x_interrupt, IRQF_SHARED,\n\t\t\t  dev->board_name, dev);\n\tif (ret < 0) {\n\t\tdev_warn(dev->class_dev, \" irq not available\\n\");\n\t\treturn ret;\n\t}\n\tdev->irq = pcidev->irq;\n\tglobal_interrupt_config_bits = NI660X_GLOBAL_INT_GLOBAL;\n\tif (board->n_chips > 1)\n\t\tglobal_interrupt_config_bits |= NI660X_GLOBAL_INT_CASCADE;\n\tni_660x_write(dev, 0, global_interrupt_config_bits,\n\t\t      NI660X_GLOBAL_INT_CFG);\n\n\treturn 0;\n}\n\nstatic void ni_660x_detach(struct comedi_device *dev)\n{\n\tstruct ni_660x_private *devpriv = dev->private;\n\n\tif (dev->irq) {\n\t\tni_660x_write(dev, 0, 0, NI660X_GLOBAL_INT_CFG);\n\t\tfree_irq(dev->irq, dev);\n\t}\n\tif (devpriv) {\n\t\tni_gpct_device_destroy(devpriv->counter_dev);\n\t\tni_660x_free_mite_rings(dev);\n\t\tmite_detach(devpriv->mite);\n\t}\n\tif (dev->mmio)\n\t\tiounmap(dev->mmio);\n\tcomedi_pci_disable(dev);\n}\n\nstatic struct comedi_driver ni_660x_driver = {\n\t.driver_name\t= \"ni_660x\",\n\t.module\t\t= THIS_MODULE,\n\t.auto_attach\t= ni_660x_auto_attach,\n\t.detach\t\t= ni_660x_detach,\n};\n\nstatic int ni_660x_pci_probe(struct pci_dev *dev,\n\t\t\t     const struct pci_device_id *id)\n{\n\treturn comedi_pci_auto_config(dev, &ni_660x_driver, id->driver_data);\n}\n\nstatic const struct pci_device_id ni_660x_pci_table[] = {\n\t{ PCI_VDEVICE(NI, 0x1310), BOARD_PCI6602 },\n\t{ PCI_VDEVICE(NI, 0x1360), BOARD_PXI6602 },\n\t{ PCI_VDEVICE(NI, 0x2c60), BOARD_PCI6601 },\n\t{ PCI_VDEVICE(NI, 0x2db0), BOARD_PCI6608 },\n\t{ PCI_VDEVICE(NI, 0x2cc0), BOARD_PXI6608 },\n\t{ PCI_VDEVICE(NI, 0x1e30), BOARD_PCI6624 },\n\t{ PCI_VDEVICE(NI, 0x1e40), BOARD_PXI6624 },\n\t{ 0 }\n};\nMODULE_DEVICE_TABLE(pci, ni_660x_pci_table);\n\nstatic struct pci_driver ni_660x_pci_driver = {\n\t.name\t\t= \"ni_660x\",\n\t.id_table\t= ni_660x_pci_table,\n\t.probe\t\t= ni_660x_pci_probe,\n\t.remove\t\t= comedi_pci_auto_unconfig,\n};\nmodule_comedi_pci_driver(ni_660x_driver, ni_660x_pci_driver);\n\nMODULE_AUTHOR(\"Comedi https://www.comedi.org\");\nMODULE_DESCRIPTION(\"Comedi driver for NI 660x counter/timer boards\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}