{
  "module_name": "ni_65xx.c",
  "hash_id": "28c2fb542574258395625a082f50c6615af63fbd9c82ce7cb46521537e616d8a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/ni_65xx.c",
  "human_readable_source": "\n \n\n \n\n \n\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/comedi/comedi_pci.h>\n\n \n\n \n#define NI_65XX_ID_REG\t\t\t0x00\n#define NI_65XX_CLR_REG\t\t\t0x01\n#define NI_65XX_CLR_WDOG_INT\t\tBIT(6)\n#define NI_65XX_CLR_WDOG_PING\t\tBIT(5)\n#define NI_65XX_CLR_WDOG_EXP\t\tBIT(4)\n#define NI_65XX_CLR_EDGE_INT\t\tBIT(3)\n#define NI_65XX_CLR_OVERFLOW_INT\tBIT(2)\n#define NI_65XX_STATUS_REG\t\t0x02\n#define NI_65XX_STATUS_WDOG_INT\t\tBIT(5)\n#define NI_65XX_STATUS_FALL_EDGE\tBIT(4)\n#define NI_65XX_STATUS_RISE_EDGE\tBIT(3)\n#define NI_65XX_STATUS_INT\t\tBIT(2)\n#define NI_65XX_STATUS_OVERFLOW_INT\tBIT(1)\n#define NI_65XX_STATUS_EDGE_INT\t\tBIT(0)\n#define NI_65XX_CTRL_REG\t\t0x03\n#define NI_65XX_CTRL_WDOG_ENA\t\tBIT(5)\n#define NI_65XX_CTRL_FALL_EDGE_ENA\tBIT(4)\n#define NI_65XX_CTRL_RISE_EDGE_ENA\tBIT(3)\n#define NI_65XX_CTRL_INT_ENA\t\tBIT(2)\n#define NI_65XX_CTRL_OVERFLOW_ENA\tBIT(1)\n#define NI_65XX_CTRL_EDGE_ENA\t\tBIT(0)\n#define NI_65XX_REV_REG\t\t\t0x04  \n#define NI_65XX_FILTER_REG\t\t0x08  \n#define NI_65XX_RTSI_ROUTE_REG\t\t0x0c  \n#define NI_65XX_RTSI_EDGE_REG\t\t0x0e  \n#define NI_65XX_RTSI_WDOG_REG\t\t0x10  \n#define NI_65XX_RTSI_TRIG_REG\t\t0x12  \n#define NI_65XX_AUTO_CLK_SEL_REG\t0x14  \n#define NI_65XX_AUTO_CLK_SEL_STATUS\tBIT(1)\n#define NI_65XX_AUTO_CLK_SEL_DISABLE\tBIT(0)\n#define NI_65XX_WDOG_CTRL_REG\t\t0x15\n#define NI_65XX_WDOG_CTRL_ENA\t\tBIT(0)\n#define NI_65XX_RTSI_CFG_REG\t\t0x16\n#define NI_65XX_RTSI_CFG_RISE_SENSE\tBIT(2)\n#define NI_65XX_RTSI_CFG_FALL_SENSE\tBIT(1)\n#define NI_65XX_RTSI_CFG_SYNC_DETECT\tBIT(0)\n#define NI_65XX_WDOG_STATUS_REG\t\t0x17\n#define NI_65XX_WDOG_STATUS_EXP\t\tBIT(0)\n#define NI_65XX_WDOG_INTERVAL_REG\t0x18  \n\n \n#define NI_65XX_PORT(x)\t\t\t((x) * 0x10)\n#define NI_65XX_IO_DATA_REG(x)\t\t(0x40 + NI_65XX_PORT(x))\n#define NI_65XX_IO_SEL_REG(x)\t\t(0x41 + NI_65XX_PORT(x))\n#define NI_65XX_IO_SEL_OUTPUT\t\t0\n#define NI_65XX_IO_SEL_INPUT\t\tBIT(0)\n#define NI_65XX_RISE_EDGE_ENA_REG(x)\t(0x42 + NI_65XX_PORT(x))\n#define NI_65XX_FALL_EDGE_ENA_REG(x)\t(0x43 + NI_65XX_PORT(x))\n#define NI_65XX_FILTER_ENA(x)\t\t(0x44 + NI_65XX_PORT(x))\n#define NI_65XX_WDOG_HIZ_REG(x)\t\t(0x46 + NI_65XX_PORT(x))\n#define NI_65XX_WDOG_ENA(x)\t\t(0x47 + NI_65XX_PORT(x))\n#define NI_65XX_WDOG_HI_LO_REG(x)\t(0x48 + NI_65XX_PORT(x))\n#define NI_65XX_RTSI_ENA(x)\t\t(0x49 + NI_65XX_PORT(x))\n\n#define NI_65XX_PORT_TO_CHAN(x)\t\t((x) * 8)\n#define NI_65XX_CHAN_TO_PORT(x)\t\t((x) / 8)\n#define NI_65XX_CHAN_TO_MASK(x)\t\t(1 << ((x) % 8))\n\nenum ni_65xx_boardid {\n\tBOARD_PCI6509,\n\tBOARD_PXI6509,\n\tBOARD_PCI6510,\n\tBOARD_PCI6511,\n\tBOARD_PXI6511,\n\tBOARD_PCI6512,\n\tBOARD_PXI6512,\n\tBOARD_PCI6513,\n\tBOARD_PXI6513,\n\tBOARD_PCI6514,\n\tBOARD_PXI6514,\n\tBOARD_PCI6515,\n\tBOARD_PXI6515,\n\tBOARD_PCI6516,\n\tBOARD_PCI6517,\n\tBOARD_PCI6518,\n\tBOARD_PCI6519,\n\tBOARD_PCI6520,\n\tBOARD_PCI6521,\n\tBOARD_PXI6521,\n\tBOARD_PCI6528,\n\tBOARD_PXI6528,\n};\n\nstruct ni_65xx_board {\n\tconst char *name;\n\tunsigned int num_dio_ports;\n\tunsigned int num_di_ports;\n\tunsigned int num_do_ports;\n\tunsigned int legacy_invert:1;\n};\n\nstatic const struct ni_65xx_board ni_65xx_boards[] = {\n\t[BOARD_PCI6509] = {\n\t\t.name\t\t= \"pci-6509\",\n\t\t.num_dio_ports\t= 12,\n\t},\n\t[BOARD_PXI6509] = {\n\t\t.name\t\t= \"pxi-6509\",\n\t\t.num_dio_ports\t= 12,\n\t},\n\t[BOARD_PCI6510] = {\n\t\t.name\t\t= \"pci-6510\",\n\t\t.num_di_ports\t= 4,\n\t},\n\t[BOARD_PCI6511] = {\n\t\t.name\t\t= \"pci-6511\",\n\t\t.num_di_ports\t= 8,\n\t},\n\t[BOARD_PXI6511] = {\n\t\t.name\t\t= \"pxi-6511\",\n\t\t.num_di_ports\t= 8,\n\t},\n\t[BOARD_PCI6512] = {\n\t\t.name\t\t= \"pci-6512\",\n\t\t.num_do_ports\t= 8,\n\t},\n\t[BOARD_PXI6512] = {\n\t\t.name\t\t= \"pxi-6512\",\n\t\t.num_do_ports\t= 8,\n\t},\n\t[BOARD_PCI6513] = {\n\t\t.name\t\t= \"pci-6513\",\n\t\t.num_do_ports\t= 8,\n\t\t.legacy_invert\t= 1,\n\t},\n\t[BOARD_PXI6513] = {\n\t\t.name\t\t= \"pxi-6513\",\n\t\t.num_do_ports\t= 8,\n\t\t.legacy_invert\t= 1,\n\t},\n\t[BOARD_PCI6514] = {\n\t\t.name\t\t= \"pci-6514\",\n\t\t.num_di_ports\t= 4,\n\t\t.num_do_ports\t= 4,\n\t\t.legacy_invert\t= 1,\n\t},\n\t[BOARD_PXI6514] = {\n\t\t.name\t\t= \"pxi-6514\",\n\t\t.num_di_ports\t= 4,\n\t\t.num_do_ports\t= 4,\n\t\t.legacy_invert\t= 1,\n\t},\n\t[BOARD_PCI6515] = {\n\t\t.name\t\t= \"pci-6515\",\n\t\t.num_di_ports\t= 4,\n\t\t.num_do_ports\t= 4,\n\t\t.legacy_invert\t= 1,\n\t},\n\t[BOARD_PXI6515] = {\n\t\t.name\t\t= \"pxi-6515\",\n\t\t.num_di_ports\t= 4,\n\t\t.num_do_ports\t= 4,\n\t\t.legacy_invert\t= 1,\n\t},\n\t[BOARD_PCI6516] = {\n\t\t.name\t\t= \"pci-6516\",\n\t\t.num_do_ports\t= 4,\n\t\t.legacy_invert\t= 1,\n\t},\n\t[BOARD_PCI6517] = {\n\t\t.name\t\t= \"pci-6517\",\n\t\t.num_do_ports\t= 4,\n\t\t.legacy_invert\t= 1,\n\t},\n\t[BOARD_PCI6518] = {\n\t\t.name\t\t= \"pci-6518\",\n\t\t.num_di_ports\t= 2,\n\t\t.num_do_ports\t= 2,\n\t\t.legacy_invert\t= 1,\n\t},\n\t[BOARD_PCI6519] = {\n\t\t.name\t\t= \"pci-6519\",\n\t\t.num_di_ports\t= 2,\n\t\t.num_do_ports\t= 2,\n\t\t.legacy_invert\t= 1,\n\t},\n\t[BOARD_PCI6520] = {\n\t\t.name\t\t= \"pci-6520\",\n\t\t.num_di_ports\t= 1,\n\t\t.num_do_ports\t= 1,\n\t},\n\t[BOARD_PCI6521] = {\n\t\t.name\t\t= \"pci-6521\",\n\t\t.num_di_ports\t= 1,\n\t\t.num_do_ports\t= 1,\n\t},\n\t[BOARD_PXI6521] = {\n\t\t.name\t\t= \"pxi-6521\",\n\t\t.num_di_ports\t= 1,\n\t\t.num_do_ports\t= 1,\n\t},\n\t[BOARD_PCI6528] = {\n\t\t.name\t\t= \"pci-6528\",\n\t\t.num_di_ports\t= 3,\n\t\t.num_do_ports\t= 3,\n\t},\n\t[BOARD_PXI6528] = {\n\t\t.name\t\t= \"pxi-6528\",\n\t\t.num_di_ports\t= 3,\n\t\t.num_do_ports\t= 3,\n\t},\n};\n\nstatic bool ni_65xx_legacy_invert_outputs;\nmodule_param_named(legacy_invert_outputs, ni_65xx_legacy_invert_outputs,\n\t\t   bool, 0444);\nMODULE_PARM_DESC(legacy_invert_outputs,\n\t\t \"invert outputs of PCI/PXI-6513/6514/6515/6516/6517/6518/6519 for compatibility with old user code\");\n\nstatic unsigned int ni_65xx_num_ports(struct comedi_device *dev)\n{\n\tconst struct ni_65xx_board *board = dev->board_ptr;\n\n\treturn board->num_dio_ports + board->num_di_ports + board->num_do_ports;\n}\n\nstatic void ni_65xx_disable_input_filters(struct comedi_device *dev)\n{\n\tunsigned int num_ports = ni_65xx_num_ports(dev);\n\tint i;\n\n\t \n\tfor (i = 0; i < num_ports; ++i)\n\t\twriteb(0x00, dev->mmio + NI_65XX_FILTER_ENA(i));\n\n\t \n\twritel(0x00000000, dev->mmio + NI_65XX_FILTER_REG);\n}\n\n \nstatic void ni_65xx_update_edge_detection(struct comedi_device *dev,\n\t\t\t\t\t  unsigned int base_chan,\n\t\t\t\t\t  unsigned int rising,\n\t\t\t\t\t  unsigned int falling)\n{\n\tunsigned int num_ports = ni_65xx_num_ports(dev);\n\tunsigned int port;\n\n\tif (base_chan >= NI_65XX_PORT_TO_CHAN(num_ports))\n\t\treturn;\n\n\tfor (port = NI_65XX_CHAN_TO_PORT(base_chan); port < num_ports; port++) {\n\t\tint bitshift = (int)(NI_65XX_PORT_TO_CHAN(port) - base_chan);\n\t\tunsigned int port_mask, port_rising, port_falling;\n\n\t\tif (bitshift >= 32)\n\t\t\tbreak;\n\n\t\tif (bitshift >= 0) {\n\t\t\tport_mask = ~0U >> bitshift;\n\t\t\tport_rising = rising >> bitshift;\n\t\t\tport_falling = falling >> bitshift;\n\t\t} else {\n\t\t\tport_mask = ~0U << -bitshift;\n\t\t\tport_rising = rising << -bitshift;\n\t\t\tport_falling = falling << -bitshift;\n\t\t}\n\t\tif (port_mask & 0xff) {\n\t\t\tif (~port_mask & 0xff) {\n\t\t\t\tport_rising |=\n\t\t\t\t    readb(dev->mmio +\n\t\t\t\t\t  NI_65XX_RISE_EDGE_ENA_REG(port)) &\n\t\t\t\t    ~port_mask;\n\t\t\t\tport_falling |=\n\t\t\t\t    readb(dev->mmio +\n\t\t\t\t\t  NI_65XX_FALL_EDGE_ENA_REG(port)) &\n\t\t\t\t    ~port_mask;\n\t\t\t}\n\t\t\twriteb(port_rising & 0xff,\n\t\t\t       dev->mmio + NI_65XX_RISE_EDGE_ENA_REG(port));\n\t\t\twriteb(port_falling & 0xff,\n\t\t\t       dev->mmio + NI_65XX_FALL_EDGE_ENA_REG(port));\n\t\t}\n\t}\n}\n\nstatic void ni_65xx_disable_edge_detection(struct comedi_device *dev)\n{\n\t \n\tni_65xx_update_edge_detection(dev, 0, 0, 0);\n\t \n\tni_65xx_update_edge_detection(dev, 32, 0, 0);\n\t \n\tni_65xx_update_edge_detection(dev, 64, 0, 0);\n}\n\nstatic int ni_65xx_dio_insn_config(struct comedi_device *dev,\n\t\t\t\t   struct comedi_subdevice *s,\n\t\t\t\t   struct comedi_insn *insn,\n\t\t\t\t   unsigned int *data)\n{\n\tunsigned long base_port = (unsigned long)s->private;\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int chan_mask = NI_65XX_CHAN_TO_MASK(chan);\n\tunsigned int port = base_port + NI_65XX_CHAN_TO_PORT(chan);\n\tunsigned int interval;\n\tunsigned int val;\n\n\tswitch (data[0]) {\n\tcase INSN_CONFIG_FILTER:\n\t\t \n\t\tinterval = (data[1] + 100) / 200;\n\t\tif (interval > 0xfffff)\n\t\t\tinterval = 0xfffff;\n\t\tdata[1] = interval * 200;\n\n\t\t \n\t\tval = readb(dev->mmio + NI_65XX_FILTER_ENA(port));\n\t\tif (interval) {\n\t\t\twritel(interval, dev->mmio + NI_65XX_FILTER_REG);\n\t\t\tval |= chan_mask;\n\t\t} else {\n\t\t\tval &= ~chan_mask;\n\t\t}\n\t\twriteb(val, dev->mmio + NI_65XX_FILTER_ENA(port));\n\t\tbreak;\n\n\tcase INSN_CONFIG_DIO_OUTPUT:\n\t\tif (s->type != COMEDI_SUBD_DIO)\n\t\t\treturn -EINVAL;\n\t\twriteb(NI_65XX_IO_SEL_OUTPUT,\n\t\t       dev->mmio + NI_65XX_IO_SEL_REG(port));\n\t\tbreak;\n\n\tcase INSN_CONFIG_DIO_INPUT:\n\t\tif (s->type != COMEDI_SUBD_DIO)\n\t\t\treturn -EINVAL;\n\t\twriteb(NI_65XX_IO_SEL_INPUT,\n\t\t       dev->mmio + NI_65XX_IO_SEL_REG(port));\n\t\tbreak;\n\n\tcase INSN_CONFIG_DIO_QUERY:\n\t\tif (s->type != COMEDI_SUBD_DIO)\n\t\t\treturn -EINVAL;\n\t\tval = readb(dev->mmio + NI_65XX_IO_SEL_REG(port));\n\t\tdata[1] = (val == NI_65XX_IO_SEL_INPUT) ? COMEDI_INPUT\n\t\t\t\t\t\t\t: COMEDI_OUTPUT;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn insn->n;\n}\n\nstatic int ni_65xx_dio_insn_bits(struct comedi_device *dev,\n\t\t\t\t struct comedi_subdevice *s,\n\t\t\t\t struct comedi_insn *insn,\n\t\t\t\t unsigned int *data)\n{\n\tunsigned long base_port = (unsigned long)s->private;\n\tunsigned int base_chan = CR_CHAN(insn->chanspec);\n\tint last_port_offset = NI_65XX_CHAN_TO_PORT(s->n_chan - 1);\n\tunsigned int read_bits = 0;\n\tint port_offset;\n\n\tfor (port_offset = NI_65XX_CHAN_TO_PORT(base_chan);\n\t     port_offset <= last_port_offset; port_offset++) {\n\t\tunsigned int port = base_port + port_offset;\n\t\tint base_port_channel = NI_65XX_PORT_TO_CHAN(port_offset);\n\t\tunsigned int port_mask, port_data, bits;\n\t\tint bitshift = base_port_channel - base_chan;\n\n\t\tif (bitshift >= 32)\n\t\t\tbreak;\n\t\tport_mask = data[0];\n\t\tport_data = data[1];\n\t\tif (bitshift > 0) {\n\t\t\tport_mask >>= bitshift;\n\t\t\tport_data >>= bitshift;\n\t\t} else {\n\t\t\tport_mask <<= -bitshift;\n\t\t\tport_data <<= -bitshift;\n\t\t}\n\t\tport_mask &= 0xff;\n\t\tport_data &= 0xff;\n\n\t\t \n\t\tif (port_mask) {\n\t\t\tbits = readb(dev->mmio + NI_65XX_IO_DATA_REG(port));\n\t\t\tbits ^= s->io_bits;\t \n\t\t\tbits &= ~port_mask;\n\t\t\tbits |= (port_data & port_mask);\n\t\t\tbits ^= s->io_bits;\t \n\t\t\twriteb(bits, dev->mmio + NI_65XX_IO_DATA_REG(port));\n\t\t}\n\n\t\t \n\t\tbits = readb(dev->mmio + NI_65XX_IO_DATA_REG(port));\n\t\tbits ^= s->io_bits;\t \n\t\tif (bitshift > 0)\n\t\t\tbits <<= bitshift;\n\t\telse\n\t\t\tbits >>= -bitshift;\n\n\t\tread_bits |= bits;\n\t}\n\tdata[1] = read_bits;\n\treturn insn->n;\n}\n\nstatic irqreturn_t ni_65xx_interrupt(int irq, void *d)\n{\n\tstruct comedi_device *dev = d;\n\tstruct comedi_subdevice *s = dev->read_subdev;\n\tunsigned int status;\n\tunsigned short val = 0;\n\n\tstatus = readb(dev->mmio + NI_65XX_STATUS_REG);\n\tif ((status & NI_65XX_STATUS_INT) == 0)\n\t\treturn IRQ_NONE;\n\tif ((status & NI_65XX_STATUS_EDGE_INT) == 0)\n\t\treturn IRQ_NONE;\n\n\twriteb(NI_65XX_CLR_EDGE_INT | NI_65XX_CLR_OVERFLOW_INT,\n\t       dev->mmio + NI_65XX_CLR_REG);\n\n\tcomedi_buf_write_samples(s, &val, 1);\n\tcomedi_handle_events(dev, s);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ni_65xx_intr_cmdtest(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tstruct comedi_cmd *cmd)\n{\n\tint err = 0;\n\n\t \n\n\terr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW);\n\terr |= comedi_check_trigger_src(&cmd->scan_begin_src, TRIG_OTHER);\n\terr |= comedi_check_trigger_src(&cmd->convert_src, TRIG_FOLLOW);\n\terr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\n\terr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT);\n\n\tif (err)\n\t\treturn 1;\n\n\t \n\t \n\n\t \n\n\terr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);\n\terr |= comedi_check_trigger_arg_is(&cmd->convert_arg, 0);\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\n\t\t\t\t\t   cmd->chanlist_len);\n\terr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\n\n\tif (err)\n\t\treturn 3;\n\n\t \n\n\t \n\n\treturn 0;\n}\n\nstatic int ni_65xx_intr_cmd(struct comedi_device *dev,\n\t\t\t    struct comedi_subdevice *s)\n{\n\twriteb(NI_65XX_CLR_EDGE_INT | NI_65XX_CLR_OVERFLOW_INT,\n\t       dev->mmio + NI_65XX_CLR_REG);\n\twriteb(NI_65XX_CTRL_FALL_EDGE_ENA | NI_65XX_CTRL_RISE_EDGE_ENA |\n\t       NI_65XX_CTRL_INT_ENA | NI_65XX_CTRL_EDGE_ENA,\n\t       dev->mmio + NI_65XX_CTRL_REG);\n\n\treturn 0;\n}\n\nstatic int ni_65xx_intr_cancel(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s)\n{\n\twriteb(0x00, dev->mmio + NI_65XX_CTRL_REG);\n\n\treturn 0;\n}\n\nstatic int ni_65xx_intr_insn_bits(struct comedi_device *dev,\n\t\t\t\t  struct comedi_subdevice *s,\n\t\t\t\t  struct comedi_insn *insn,\n\t\t\t\t  unsigned int *data)\n{\n\tdata[1] = 0;\n\treturn insn->n;\n}\n\nstatic int ni_65xx_intr_insn_config(struct comedi_device *dev,\n\t\t\t\t    struct comedi_subdevice *s,\n\t\t\t\t    struct comedi_insn *insn,\n\t\t\t\t    unsigned int *data)\n{\n\tswitch (data[0]) {\n\tcase INSN_CONFIG_CHANGE_NOTIFY:\n\t\t \n\t\tif (insn->n != 3)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tni_65xx_update_edge_detection(dev, 0, data[1], data[2]);\n\t\t \n\t\tni_65xx_update_edge_detection(dev, 32, 0, 0);\n\t\t \n\t\tni_65xx_update_edge_detection(dev, 64, 0, 0);\n\t\tbreak;\n\tcase INSN_CONFIG_DIGITAL_TRIG:\n\t\t \n\t\tif (data[1] != 0)\n\t\t\treturn -EINVAL;\n\t\t \n\t\tswitch (data[2]) {\n\t\tcase COMEDI_DIGITAL_TRIG_DISABLE:\n\t\t\tni_65xx_disable_edge_detection(dev);\n\t\t\tbreak;\n\t\tcase COMEDI_DIGITAL_TRIG_ENABLE_EDGES:\n\t\t\t \n\t\t\tni_65xx_update_edge_detection(dev, data[3],\n\t\t\t\t\t\t      data[4], data[5]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn insn->n;\n}\n\n \n#define MITE_IODWBSR\t0xc0\t  \n#define WENAB\t\t\tBIT(7)  \n\nstatic int ni_65xx_mite_init(struct pci_dev *pcidev)\n{\n\tvoid __iomem *mite_base;\n\tu32 main_phys_addr;\n\n\t \n\tmite_base = pci_ioremap_bar(pcidev, 0);\n\tif (!mite_base)\n\t\treturn -ENOMEM;\n\n\t \n\tmain_phys_addr = pci_resource_start(pcidev, 1);\n\twritel(main_phys_addr | WENAB, mite_base + MITE_IODWBSR);\n\n\t \n\tiounmap(mite_base);\n\treturn 0;\n}\n\nstatic int ni_65xx_auto_attach(struct comedi_device *dev,\n\t\t\t       unsigned long context)\n{\n\tstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\n\tconst struct ni_65xx_board *board = NULL;\n\tstruct comedi_subdevice *s;\n\tunsigned int i;\n\tint ret;\n\n\tif (context < ARRAY_SIZE(ni_65xx_boards))\n\t\tboard = &ni_65xx_boards[context];\n\tif (!board)\n\t\treturn -ENODEV;\n\tdev->board_ptr = board;\n\tdev->board_name = board->name;\n\n\tret = comedi_pci_enable(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ni_65xx_mite_init(pcidev);\n\tif (ret)\n\t\treturn ret;\n\n\tdev->mmio = pci_ioremap_bar(pcidev, 1);\n\tif (!dev->mmio)\n\t\treturn -ENOMEM;\n\n\twriteb(NI_65XX_CLR_EDGE_INT | NI_65XX_CLR_OVERFLOW_INT,\n\t       dev->mmio + NI_65XX_CLR_REG);\n\twriteb(0x00, dev->mmio + NI_65XX_CTRL_REG);\n\n\tif (pcidev->irq) {\n\t\tret = request_irq(pcidev->irq, ni_65xx_interrupt, IRQF_SHARED,\n\t\t\t\t  dev->board_name, dev);\n\t\tif (ret == 0)\n\t\t\tdev->irq = pcidev->irq;\n\t}\n\n\tdev_info(dev->class_dev, \"board: %s, ID=0x%02x\", dev->board_name,\n\t\t readb(dev->mmio + NI_65XX_ID_REG));\n\n\tret = comedi_alloc_subdevices(dev, 4);\n\tif (ret)\n\t\treturn ret;\n\n\ts = &dev->subdevices[0];\n\tif (board->num_di_ports) {\n\t\ts->type\t\t= COMEDI_SUBD_DI;\n\t\ts->subdev_flags\t= SDF_READABLE;\n\t\ts->n_chan\t= NI_65XX_PORT_TO_CHAN(board->num_di_ports);\n\t\ts->maxdata\t= 1;\n\t\ts->range_table\t= &range_digital;\n\t\ts->insn_bits\t= ni_65xx_dio_insn_bits;\n\t\ts->insn_config\t= ni_65xx_dio_insn_config;\n\n\t\t \n\t\ts->private = (void *)0;\n\t} else {\n\t\ts->type\t\t= COMEDI_SUBD_UNUSED;\n\t}\n\n\ts = &dev->subdevices[1];\n\tif (board->num_do_ports) {\n\t\ts->type\t\t= COMEDI_SUBD_DO;\n\t\ts->subdev_flags\t= SDF_WRITABLE;\n\t\ts->n_chan\t= NI_65XX_PORT_TO_CHAN(board->num_do_ports);\n\t\ts->maxdata\t= 1;\n\t\ts->range_table\t= &range_digital;\n\t\ts->insn_bits\t= ni_65xx_dio_insn_bits;\n\n\t\t \n\t\ts->private = (void *)(unsigned long)board->num_di_ports;\n\n\t\t \n\t\tif (ni_65xx_legacy_invert_outputs && board->legacy_invert)\n\t\t\ts->io_bits = 0xff;\n\n\t\t \n\t\tfor (i = 0; i < board->num_do_ports; ++i) {\n\t\t\twriteb(s->io_bits,\t \n\t\t\t       dev->mmio +\n\t\t\t       NI_65XX_IO_DATA_REG(board->num_di_ports + i));\n\t\t}\n\t} else {\n\t\ts->type\t\t= COMEDI_SUBD_UNUSED;\n\t}\n\n\ts = &dev->subdevices[2];\n\tif (board->num_dio_ports) {\n\t\ts->type\t\t= COMEDI_SUBD_DIO;\n\t\ts->subdev_flags\t= SDF_READABLE | SDF_WRITABLE;\n\t\ts->n_chan\t= NI_65XX_PORT_TO_CHAN(board->num_dio_ports);\n\t\ts->maxdata\t= 1;\n\t\ts->range_table\t= &range_digital;\n\t\ts->insn_bits\t= ni_65xx_dio_insn_bits;\n\t\ts->insn_config\t= ni_65xx_dio_insn_config;\n\n\t\t \n\t\ts->private = (void *)0;\n\n\t\t \n\t\tfor (i = 0; i < board->num_dio_ports; ++i) {\n\t\t\twriteb(NI_65XX_IO_SEL_INPUT,\n\t\t\t       dev->mmio + NI_65XX_IO_SEL_REG(i));\n\t\t}\n\t} else {\n\t\ts->type\t\t= COMEDI_SUBD_UNUSED;\n\t}\n\n\ts = &dev->subdevices[3];\n\ts->type\t\t= COMEDI_SUBD_DI;\n\ts->subdev_flags\t= SDF_READABLE;\n\ts->n_chan\t= 1;\n\ts->maxdata\t= 1;\n\ts->range_table\t= &range_digital;\n\ts->insn_bits\t= ni_65xx_intr_insn_bits;\n\tif (dev->irq) {\n\t\tdev->read_subdev = s;\n\t\ts->subdev_flags\t|= SDF_CMD_READ;\n\t\ts->len_chanlist\t= 1;\n\t\ts->insn_config\t= ni_65xx_intr_insn_config;\n\t\ts->do_cmdtest\t= ni_65xx_intr_cmdtest;\n\t\ts->do_cmd\t= ni_65xx_intr_cmd;\n\t\ts->cancel\t= ni_65xx_intr_cancel;\n\t}\n\n\tni_65xx_disable_input_filters(dev);\n\tni_65xx_disable_edge_detection(dev);\n\n\treturn 0;\n}\n\nstatic void ni_65xx_detach(struct comedi_device *dev)\n{\n\tif (dev->mmio)\n\t\twriteb(0x00, dev->mmio + NI_65XX_CTRL_REG);\n\tcomedi_pci_detach(dev);\n}\n\nstatic struct comedi_driver ni_65xx_driver = {\n\t.driver_name\t= \"ni_65xx\",\n\t.module\t\t= THIS_MODULE,\n\t.auto_attach\t= ni_65xx_auto_attach,\n\t.detach\t\t= ni_65xx_detach,\n};\n\nstatic int ni_65xx_pci_probe(struct pci_dev *dev,\n\t\t\t     const struct pci_device_id *id)\n{\n\treturn comedi_pci_auto_config(dev, &ni_65xx_driver, id->driver_data);\n}\n\nstatic const struct pci_device_id ni_65xx_pci_table[] = {\n\t{ PCI_VDEVICE(NI, 0x1710), BOARD_PXI6509 },\n\t{ PCI_VDEVICE(NI, 0x7085), BOARD_PCI6509 },\n\t{ PCI_VDEVICE(NI, 0x7086), BOARD_PXI6528 },\n\t{ PCI_VDEVICE(NI, 0x7087), BOARD_PCI6515 },\n\t{ PCI_VDEVICE(NI, 0x7088), BOARD_PCI6514 },\n\t{ PCI_VDEVICE(NI, 0x70a9), BOARD_PCI6528 },\n\t{ PCI_VDEVICE(NI, 0x70c3), BOARD_PCI6511 },\n\t{ PCI_VDEVICE(NI, 0x70c8), BOARD_PCI6513 },\n\t{ PCI_VDEVICE(NI, 0x70c9), BOARD_PXI6515 },\n\t{ PCI_VDEVICE(NI, 0x70cc), BOARD_PCI6512 },\n\t{ PCI_VDEVICE(NI, 0x70cd), BOARD_PXI6514 },\n\t{ PCI_VDEVICE(NI, 0x70d1), BOARD_PXI6513 },\n\t{ PCI_VDEVICE(NI, 0x70d2), BOARD_PXI6512 },\n\t{ PCI_VDEVICE(NI, 0x70d3), BOARD_PXI6511 },\n\t{ PCI_VDEVICE(NI, 0x7124), BOARD_PCI6510 },\n\t{ PCI_VDEVICE(NI, 0x7125), BOARD_PCI6516 },\n\t{ PCI_VDEVICE(NI, 0x7126), BOARD_PCI6517 },\n\t{ PCI_VDEVICE(NI, 0x7127), BOARD_PCI6518 },\n\t{ PCI_VDEVICE(NI, 0x7128), BOARD_PCI6519 },\n\t{ PCI_VDEVICE(NI, 0x718b), BOARD_PCI6521 },\n\t{ PCI_VDEVICE(NI, 0x718c), BOARD_PXI6521 },\n\t{ PCI_VDEVICE(NI, 0x71c5), BOARD_PCI6520 },\n\t{ 0 }\n};\nMODULE_DEVICE_TABLE(pci, ni_65xx_pci_table);\n\nstatic struct pci_driver ni_65xx_pci_driver = {\n\t.name\t\t= \"ni_65xx\",\n\t.id_table\t= ni_65xx_pci_table,\n\t.probe\t\t= ni_65xx_pci_probe,\n\t.remove\t\t= comedi_pci_auto_unconfig,\n};\nmodule_comedi_pci_driver(ni_65xx_driver, ni_65xx_pci_driver);\n\nMODULE_AUTHOR(\"Comedi https://www.comedi.org\");\nMODULE_DESCRIPTION(\"Comedi driver for NI PCI-65xx static dio boards\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}