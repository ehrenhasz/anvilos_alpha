{
  "module_name": "ke_counter.c",
  "hash_id": "4a90ad07900c2e9282f1bfdd3d2cdb6229430a38fcdb0ca31ac2f6b61b7ecdd8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/ke_counter.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/comedi/comedi_pci.h>\n\n \n#define KE_RESET_REG(x)\t\t\t(0x00 + ((x) * 0x20))\n#define KE_LATCH_REG(x)\t\t\t(0x00 + ((x) * 0x20))\n#define KE_LSB_REG(x)\t\t\t(0x04 + ((x) * 0x20))\n#define KE_MID_REG(x)\t\t\t(0x08 + ((x) * 0x20))\n#define KE_MSB_REG(x)\t\t\t(0x0c + ((x) * 0x20))\n#define KE_SIGN_REG(x)\t\t\t(0x10 + ((x) * 0x20))\n#define KE_OSC_SEL_REG\t\t\t0xf8\n#define KE_OSC_SEL_CLK(x)\t\t(((x) & 0x3) << 0)\n#define KE_OSC_SEL_EXT\t\t\tKE_OSC_SEL_CLK(1)\n#define KE_OSC_SEL_4MHZ\t\t\tKE_OSC_SEL_CLK(2)\n#define KE_OSC_SEL_20MHZ\t\tKE_OSC_SEL_CLK(3)\n#define KE_DO_REG\t\t\t0xfc\n\nstatic int ke_counter_insn_write(struct comedi_device *dev,\n\t\t\t\t struct comedi_subdevice *s,\n\t\t\t\t struct comedi_insn *insn,\n\t\t\t\t unsigned int *data)\n{\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int val;\n\tint i;\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\tval = data[0];\n\n\t\t \n\t\toutb((val >> 24) & 0xff, dev->iobase + KE_SIGN_REG(chan));\n\t\toutb((val >> 16) & 0xff, dev->iobase + KE_MSB_REG(chan));\n\t\toutb((val >> 8) & 0xff, dev->iobase + KE_MID_REG(chan));\n\t\toutb((val >> 0) & 0xff, dev->iobase + KE_LSB_REG(chan));\n\t}\n\n\treturn insn->n;\n}\n\nstatic int ke_counter_insn_read(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tstruct comedi_insn *insn,\n\t\t\t\tunsigned int *data)\n{\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int val;\n\tint i;\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\t \n\t\tinb(dev->iobase + KE_LATCH_REG(chan));\n\n\t\tval = inb(dev->iobase + KE_LSB_REG(chan));\n\t\tval |= (inb(dev->iobase + KE_MID_REG(chan)) << 8);\n\t\tval |= (inb(dev->iobase + KE_MSB_REG(chan)) << 16);\n\t\tval |= (inb(dev->iobase + KE_SIGN_REG(chan)) << 24);\n\n\t\tdata[i] = val;\n\t}\n\n\treturn insn->n;\n}\n\nstatic void ke_counter_reset(struct comedi_device *dev)\n{\n\tunsigned int chan;\n\n\tfor (chan = 0; chan < 3; chan++)\n\t\toutb(0, dev->iobase + KE_RESET_REG(chan));\n}\n\nstatic int ke_counter_insn_config(struct comedi_device *dev,\n\t\t\t\t  struct comedi_subdevice *s,\n\t\t\t\t  struct comedi_insn *insn,\n\t\t\t\t  unsigned int *data)\n{\n\tunsigned char src;\n\n\tswitch (data[0]) {\n\tcase INSN_CONFIG_SET_CLOCK_SRC:\n\t\tswitch (data[1]) {\n\t\tcase KE_CLK_20MHZ:\t \n\t\t\tsrc = KE_OSC_SEL_20MHZ;\n\t\t\tbreak;\n\t\tcase KE_CLK_4MHZ:\t \n\t\t\tsrc = KE_OSC_SEL_4MHZ;\n\t\t\tbreak;\n\t\tcase KE_CLK_EXT:\t \n\t\t\tsrc = KE_OSC_SEL_EXT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\toutb(src, dev->iobase + KE_OSC_SEL_REG);\n\t\tbreak;\n\tcase INSN_CONFIG_GET_CLOCK_SRC:\n\t\tsrc = inb(dev->iobase + KE_OSC_SEL_REG);\n\t\tswitch (src) {\n\t\tcase KE_OSC_SEL_20MHZ:\n\t\t\tdata[1] = KE_CLK_20MHZ;\n\t\t\tdata[2] = 50;\t \n\t\t\tbreak;\n\t\tcase KE_OSC_SEL_4MHZ:\n\t\t\tdata[1] = KE_CLK_4MHZ;\n\t\t\tdata[2] = 250;\t \n\t\t\tbreak;\n\t\tcase KE_OSC_SEL_EXT:\n\t\t\tdata[1] = KE_CLK_EXT;\n\t\t\tdata[2] = 0;\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase INSN_CONFIG_RESET:\n\t\tke_counter_reset(dev);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn insn->n;\n}\n\nstatic int ke_counter_do_insn_bits(struct comedi_device *dev,\n\t\t\t\t   struct comedi_subdevice *s,\n\t\t\t\t   struct comedi_insn *insn,\n\t\t\t\t   unsigned int *data)\n{\n\tif (comedi_dio_update_state(s, data))\n\t\toutb(s->state, dev->iobase + KE_DO_REG);\n\n\tdata[1] = s->state;\n\n\treturn insn->n;\n}\n\nstatic int ke_counter_auto_attach(struct comedi_device *dev,\n\t\t\t\t  unsigned long context_unused)\n{\n\tstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\n\tstruct comedi_subdevice *s;\n\tint ret;\n\n\tret = comedi_pci_enable(dev);\n\tif (ret)\n\t\treturn ret;\n\tdev->iobase = pci_resource_start(pcidev, 0);\n\n\tret = comedi_alloc_subdevices(dev, 2);\n\tif (ret)\n\t\treturn ret;\n\n\ts = &dev->subdevices[0];\n\ts->type\t\t= COMEDI_SUBD_COUNTER;\n\ts->subdev_flags\t= SDF_READABLE;\n\ts->n_chan\t= 3;\n\ts->maxdata\t= 0x01ffffff;\n\ts->range_table\t= &range_unknown;\n\ts->insn_read\t= ke_counter_insn_read;\n\ts->insn_write\t= ke_counter_insn_write;\n\ts->insn_config\t= ke_counter_insn_config;\n\n\ts = &dev->subdevices[1];\n\ts->type\t\t= COMEDI_SUBD_DO;\n\ts->subdev_flags\t= SDF_WRITABLE;\n\ts->n_chan\t= 3;\n\ts->maxdata\t= 1;\n\ts->range_table\t= &range_digital;\n\ts->insn_bits\t= ke_counter_do_insn_bits;\n\n\toutb(KE_OSC_SEL_20MHZ, dev->iobase + KE_OSC_SEL_REG);\n\n\tke_counter_reset(dev);\n\n\treturn 0;\n}\n\nstatic struct comedi_driver ke_counter_driver = {\n\t.driver_name\t= \"ke_counter\",\n\t.module\t\t= THIS_MODULE,\n\t.auto_attach\t= ke_counter_auto_attach,\n\t.detach\t\t= comedi_pci_detach,\n};\n\nstatic int ke_counter_pci_probe(struct pci_dev *dev,\n\t\t\t\tconst struct pci_device_id *id)\n{\n\treturn comedi_pci_auto_config(dev, &ke_counter_driver,\n\t\t\t\t      id->driver_data);\n}\n\nstatic const struct pci_device_id ke_counter_pci_table[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_KOLTER, 0x0014) },\n\t{ 0 }\n};\nMODULE_DEVICE_TABLE(pci, ke_counter_pci_table);\n\nstatic struct pci_driver ke_counter_pci_driver = {\n\t.name\t\t= \"ke_counter\",\n\t.id_table\t= ke_counter_pci_table,\n\t.probe\t\t= ke_counter_pci_probe,\n\t.remove\t\t= comedi_pci_auto_unconfig,\n};\nmodule_comedi_pci_driver(ke_counter_driver, ke_counter_pci_driver);\n\nMODULE_AUTHOR(\"Comedi https://www.comedi.org\");\nMODULE_DESCRIPTION(\"Comedi driver for Kolter Electronic Counter Card\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}