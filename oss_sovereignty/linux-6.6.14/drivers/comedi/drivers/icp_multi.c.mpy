{
  "module_name": "icp_multi.c",
  "hash_id": "db1d8c34abd0f4f8135ebdbc3cdfafd54cbc650e1cab8437d26a3f24dfe3402b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/icp_multi.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/comedi/comedi_pci.h>\n\n#define ICP_MULTI_ADC_CSR\t0x00\t \n#define ICP_MULTI_ADC_CSR_ST\tBIT(0)\t \n#define ICP_MULTI_ADC_CSR_BSY\tBIT(0)\t \n#define ICP_MULTI_ADC_CSR_BI\tBIT(4)\t \n#define ICP_MULTI_ADC_CSR_RA\tBIT(5)\t \n#define ICP_MULTI_ADC_CSR_DI\tBIT(6)\t \n#define ICP_MULTI_ADC_CSR_DI_CHAN(x) (((x) & 0x7) << 9)\n#define ICP_MULTI_ADC_CSR_SE_CHAN(x) (((x) & 0xf) << 8)\n#define ICP_MULTI_AI\t\t2\t \n#define ICP_MULTI_DAC_CSR\t0x04\t \n#define ICP_MULTI_DAC_CSR_ST\tBIT(0)\t \n#define ICP_MULTI_DAC_CSR_BSY\tBIT(0)\t \n#define ICP_MULTI_DAC_CSR_BI\tBIT(4)\t \n#define ICP_MULTI_DAC_CSR_RA\tBIT(5)\t \n#define ICP_MULTI_DAC_CSR_CHAN(x) (((x) & 0x3) << 8)\n#define ICP_MULTI_AO\t\t6\t \n#define ICP_MULTI_DI\t\t8\t \n#define ICP_MULTI_DO\t\t0x0A\t \n#define ICP_MULTI_INT_EN\t0x0c\t \n#define ICP_MULTI_INT_STAT\t0x0e\t \n#define ICP_MULTI_INT_ADC_RDY\tBIT(0)\t \n#define ICP_MULTI_INT_DAC_RDY\tBIT(1)\t \n#define ICP_MULTI_INT_DOUT_ERR\tBIT(2)\t \n#define ICP_MULTI_INT_DIN_STAT\tBIT(3)\t \n#define ICP_MULTI_INT_CIE0\tBIT(4)\t \n#define ICP_MULTI_INT_CIE1\tBIT(5)\t \n#define ICP_MULTI_INT_CIE2\tBIT(6)\t \n#define ICP_MULTI_INT_CIE3\tBIT(7)\t \n#define ICP_MULTI_INT_MASK\t0xff\t \n#define ICP_MULTI_CNTR0\t\t0x10\t \n#define ICP_MULTI_CNTR1\t\t0x12\t \n#define ICP_MULTI_CNTR2\t\t0x14\t \n#define ICP_MULTI_CNTR3\t\t0x16\t \n\n \nstatic const struct comedi_lrange icp_multi_ranges = {\n\t4, {\n\t\tUNI_RANGE(5),\n\t\tUNI_RANGE(10),\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(10)\n\t}\n};\n\nstatic const char range_codes_analog[] = { 0x00, 0x20, 0x10, 0x30 };\n\nstatic int icp_multi_ai_eoc(struct comedi_device *dev,\n\t\t\t    struct comedi_subdevice *s,\n\t\t\t    struct comedi_insn *insn,\n\t\t\t    unsigned long context)\n{\n\tunsigned int status;\n\n\tstatus = readw(dev->mmio + ICP_MULTI_ADC_CSR);\n\tif ((status & ICP_MULTI_ADC_CSR_BSY) == 0)\n\t\treturn 0;\n\treturn -EBUSY;\n}\n\nstatic int icp_multi_ai_insn_read(struct comedi_device *dev,\n\t\t\t\t  struct comedi_subdevice *s,\n\t\t\t\t  struct comedi_insn *insn,\n\t\t\t\t  unsigned int *data)\n{\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int range = CR_RANGE(insn->chanspec);\n\tunsigned int aref = CR_AREF(insn->chanspec);\n\tunsigned int adc_csr;\n\tint ret = 0;\n\tint n;\n\n\t \n\tif (aref == AREF_DIFF) {\n\t\tadc_csr = ICP_MULTI_ADC_CSR_DI_CHAN(chan) |\n\t\t\t  ICP_MULTI_ADC_CSR_DI;\n\t} else {\n\t\tadc_csr = ICP_MULTI_ADC_CSR_SE_CHAN(chan);\n\t}\n\tadc_csr |= range_codes_analog[range];\n\twritew(adc_csr, dev->mmio + ICP_MULTI_ADC_CSR);\n\n\tfor (n = 0; n < insn->n; n++) {\n\t\t \n\t\twritew(adc_csr | ICP_MULTI_ADC_CSR_ST,\n\t\t       dev->mmio + ICP_MULTI_ADC_CSR);\n\n\t\tudelay(1);\n\n\t\t \n\t\tret = comedi_timeout(dev, s, insn, icp_multi_ai_eoc, 0);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tdata[n] = (readw(dev->mmio + ICP_MULTI_AI) >> 4) & 0x0fff;\n\t}\n\n\treturn ret ? ret : n;\n}\n\nstatic int icp_multi_ao_ready(struct comedi_device *dev,\n\t\t\t      struct comedi_subdevice *s,\n\t\t\t      struct comedi_insn *insn,\n\t\t\t      unsigned long context)\n{\n\tunsigned int status;\n\n\tstatus = readw(dev->mmio + ICP_MULTI_DAC_CSR);\n\tif ((status & ICP_MULTI_DAC_CSR_BSY) == 0)\n\t\treturn 0;\n\treturn -EBUSY;\n}\n\nstatic int icp_multi_ao_insn_write(struct comedi_device *dev,\n\t\t\t\t   struct comedi_subdevice *s,\n\t\t\t\t   struct comedi_insn *insn,\n\t\t\t\t   unsigned int *data)\n{\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int range = CR_RANGE(insn->chanspec);\n\tunsigned int dac_csr;\n\tint i;\n\n\t \n\tdac_csr = ICP_MULTI_DAC_CSR_CHAN(chan);\n\tdac_csr |= range_codes_analog[range];\n\twritew(dac_csr, dev->mmio + ICP_MULTI_DAC_CSR);\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\tunsigned int val = data[i];\n\t\tint ret;\n\n\t\t \n\t\tret = comedi_timeout(dev, s, insn, icp_multi_ao_ready, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\twritew(val, dev->mmio + ICP_MULTI_AO);\n\n\t\t \n\t\twritew(dac_csr | ICP_MULTI_DAC_CSR_ST,\n\t\t       dev->mmio + ICP_MULTI_DAC_CSR);\n\n\t\ts->readback[chan] = val;\n\t}\n\n\treturn insn->n;\n}\n\nstatic int icp_multi_di_insn_bits(struct comedi_device *dev,\n\t\t\t\t  struct comedi_subdevice *s,\n\t\t\t\t  struct comedi_insn *insn,\n\t\t\t\t  unsigned int *data)\n{\n\tdata[1] = readw(dev->mmio + ICP_MULTI_DI);\n\n\treturn insn->n;\n}\n\nstatic int icp_multi_do_insn_bits(struct comedi_device *dev,\n\t\t\t\t  struct comedi_subdevice *s,\n\t\t\t\t  struct comedi_insn *insn,\n\t\t\t\t  unsigned int *data)\n{\n\tif (comedi_dio_update_state(s, data))\n\t\twritew(s->state, dev->mmio + ICP_MULTI_DO);\n\n\tdata[1] = s->state;\n\n\treturn insn->n;\n}\n\nstatic int icp_multi_reset(struct comedi_device *dev)\n{\n\tint i;\n\n\t \n\twritew(0, dev->mmio + ICP_MULTI_INT_EN);\n\twritew(ICP_MULTI_INT_MASK, dev->mmio + ICP_MULTI_INT_STAT);\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tunsigned int dac_csr = ICP_MULTI_DAC_CSR_CHAN(i);\n\n\t\t \n\t\twritew(dac_csr, dev->mmio + ICP_MULTI_DAC_CSR);\n\n\t\t \n\t\twritew(0, dev->mmio + ICP_MULTI_AO);\n\n\t\t \n\t\twritew(dac_csr | ICP_MULTI_DAC_CSR_ST,\n\t\t       dev->mmio + ICP_MULTI_DAC_CSR);\n\t\tudelay(1);\n\t}\n\n\t \n\twritew(0, dev->mmio + ICP_MULTI_DO);\n\n\treturn 0;\n}\n\nstatic int icp_multi_auto_attach(struct comedi_device *dev,\n\t\t\t\t unsigned long context_unused)\n{\n\tstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\n\tstruct comedi_subdevice *s;\n\tint ret;\n\n\tret = comedi_pci_enable(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tdev->mmio = pci_ioremap_bar(pcidev, 2);\n\tif (!dev->mmio)\n\t\treturn -ENOMEM;\n\n\tret = comedi_alloc_subdevices(dev, 4);\n\tif (ret)\n\t\treturn ret;\n\n\ticp_multi_reset(dev);\n\n\t \n\ts = &dev->subdevices[0];\n\ts->type\t\t= COMEDI_SUBD_AI;\n\ts->subdev_flags\t= SDF_READABLE | SDF_COMMON | SDF_GROUND | SDF_DIFF;\n\ts->n_chan\t= 16;\n\ts->maxdata\t= 0x0fff;\n\ts->range_table\t= &icp_multi_ranges;\n\ts->insn_read\t= icp_multi_ai_insn_read;\n\n\t \n\ts = &dev->subdevices[1];\n\ts->type\t\t= COMEDI_SUBD_AO;\n\ts->subdev_flags\t= SDF_WRITABLE | SDF_GROUND | SDF_COMMON;\n\ts->n_chan\t= 4;\n\ts->maxdata\t= 0x0fff;\n\ts->range_table\t= &icp_multi_ranges;\n\ts->insn_write\t= icp_multi_ao_insn_write;\n\n\tret = comedi_alloc_subdev_readback(s);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ts = &dev->subdevices[2];\n\ts->type\t\t= COMEDI_SUBD_DI;\n\ts->subdev_flags\t= SDF_READABLE;\n\ts->n_chan\t= 16;\n\ts->maxdata\t= 1;\n\ts->range_table\t= &range_digital;\n\ts->insn_bits\t= icp_multi_di_insn_bits;\n\n\t \n\ts = &dev->subdevices[3];\n\ts->type\t\t= COMEDI_SUBD_DO;\n\ts->subdev_flags\t= SDF_WRITABLE;\n\ts->n_chan\t= 8;\n\ts->maxdata\t= 1;\n\ts->range_table\t= &range_digital;\n\ts->insn_bits\t= icp_multi_do_insn_bits;\n\n\treturn 0;\n}\n\nstatic struct comedi_driver icp_multi_driver = {\n\t.driver_name\t= \"icp_multi\",\n\t.module\t\t= THIS_MODULE,\n\t.auto_attach\t= icp_multi_auto_attach,\n\t.detach\t\t= comedi_pci_detach,\n};\n\nstatic int icp_multi_pci_probe(struct pci_dev *dev,\n\t\t\t       const struct pci_device_id *id)\n{\n\treturn comedi_pci_auto_config(dev, &icp_multi_driver, id->driver_data);\n}\n\nstatic const struct pci_device_id icp_multi_pci_table[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_ICP, 0x8000) },\n\t{ 0 }\n};\nMODULE_DEVICE_TABLE(pci, icp_multi_pci_table);\n\nstatic struct pci_driver icp_multi_pci_driver = {\n\t.name\t\t= \"icp_multi\",\n\t.id_table\t= icp_multi_pci_table,\n\t.probe\t\t= icp_multi_pci_probe,\n\t.remove\t\t= comedi_pci_auto_unconfig,\n};\nmodule_comedi_pci_driver(icp_multi_driver, icp_multi_pci_driver);\n\nMODULE_AUTHOR(\"Comedi https://www.comedi.org\");\nMODULE_DESCRIPTION(\"Comedi driver for Inova ICP_MULTI board\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}