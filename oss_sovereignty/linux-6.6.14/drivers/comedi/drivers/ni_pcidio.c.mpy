{
  "module_name": "ni_pcidio.c",
  "hash_id": "bf885775e50ef45249be9d7f088ce6634ac96d93818544e5f62b42057d3a9379",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/ni_pcidio.c",
  "human_readable_source": "\n \n\n \n\n#define USE_DMA\n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n#include <linux/comedi/comedi_pci.h>\n\n#include \"mite.h\"\n\n \n\n#define WINDOW_ADDRESS\t\t\t4\t \n#define INTERRUPT_AND_WINDOW_STATUS\t4\t \n#define INT_STATUS_1\t\t\t\tBIT(0)\n#define INT_STATUS_2\t\t\t\tBIT(1)\n#define WINDOW_ADDRESS_STATUS_MASK\t\t0x7c\n\n#define MASTER_DMA_AND_INTERRUPT_CONTROL 5\t \n#define INTERRUPT_LINE(x)\t\t\t((x) & 3)\n#define OPEN_INT\t\t\t\tBIT(2)\n#define GROUP_STATUS\t\t\t5\t \n#define DATA_LEFT\t\t\t\tBIT(0)\n#define REQ\t\t\t\t\tBIT(2)\n#define STOP_TRIG\t\t\t\tBIT(3)\n\n#define GROUP_1_FLAGS\t\t\t6\t \n#define GROUP_2_FLAGS\t\t\t7\t \n#define TRANSFER_READY\t\t\t\tBIT(0)\n#define COUNT_EXPIRED\t\t\t\tBIT(1)\n#define WAITED\t\t\t\t\tBIT(5)\n#define PRIMARY_TC\t\t\t\tBIT(6)\n#define SECONDARY_TC\t\t\t\tBIT(7)\n   \n   \n   \n\n#define GROUP_1_FIRST_CLEAR\t\t6\t \n#define GROUP_2_FIRST_CLEAR\t\t7\t \n#define CLEAR_WAITED\t\t\t\tBIT(3)\n#define CLEAR_PRIMARY_TC\t\t\tBIT(4)\n#define CLEAR_SECONDARY_TC\t\t\tBIT(5)\n#define DMA_RESET\t\t\t\tBIT(6)\n#define FIFO_RESET\t\t\t\tBIT(7)\n#define CLEAR_ALL\t\t\t\t0xf8\n\n#define GROUP_1_FIFO\t\t\t8\t \n#define GROUP_2_FIFO\t\t\t12\t \n\n#define TRANSFER_COUNT\t\t\t20\n#define CHIP_ID_D\t\t\t24\n#define CHIP_ID_I\t\t\t25\n#define CHIP_ID_O\t\t\t26\n#define CHIP_VERSION\t\t\t27\n#define PORT_IO(x)\t\t\t(28 + (x))\n#define PORT_PIN_DIRECTIONS(x)\t\t(32 + (x))\n#define PORT_PIN_MASK(x)\t\t(36 + (x))\n#define PORT_PIN_POLARITIES(x)\t\t(40 + (x))\n\n#define MASTER_CLOCK_ROUTING\t\t45\n#define RTSI_CLOCKING(x)\t\t\t(((x) & 3) << 4)\n\n#define GROUP_1_SECOND_CLEAR\t\t46\t \n#define GROUP_2_SECOND_CLEAR\t\t47\t \n#define CLEAR_EXPIRED\t\t\t\tBIT(0)\n\n#define PORT_PATTERN(x)\t\t\t(48 + (x))\n\n#define DATA_PATH\t\t\t64\n#define FIFO_ENABLE_A\t\tBIT(0)\n#define FIFO_ENABLE_B\t\tBIT(1)\n#define FIFO_ENABLE_C\t\tBIT(2)\n#define FIFO_ENABLE_D\t\tBIT(3)\n#define FUNNELING(x)\t\t(((x) & 3) << 4)\n#define GROUP_DIRECTION\t\tBIT(7)\n\n#define PROTOCOL_REGISTER_1\t\t65\n#define OP_MODE\t\t\tPROTOCOL_REGISTER_1\n#define RUN_MODE(x)\t\t((x) & 7)\n#define NUMBERED\t\tBIT(3)\n\n#define PROTOCOL_REGISTER_2\t\t66\n#define CLOCK_REG\t\t\tPROTOCOL_REGISTER_2\n#define CLOCK_LINE(x)\t\t(((x) & 3) << 5)\n#define INVERT_STOP_TRIG\t\tBIT(7)\n#define DATA_LATCHING(x)       (((x) & 3) << 5)\n\n#define PROTOCOL_REGISTER_3\t\t67\n#define SEQUENCE\t\t\tPROTOCOL_REGISTER_3\n\n#define PROTOCOL_REGISTER_14\t\t68\t \n#define CLOCK_SPEED\t\t\tPROTOCOL_REGISTER_14\n\n#define PROTOCOL_REGISTER_4\t\t70\n#define REQ_REG\t\t\tPROTOCOL_REGISTER_4\n#define REQ_CONDITIONING(x)\t(((x) & 7) << 3)\n\n#define PROTOCOL_REGISTER_5\t\t71\n#define BLOCK_MODE\t\t\tPROTOCOL_REGISTER_5\n\n#define FIFO_Control\t\t\t72\n#define READY_LEVEL(x)\t\t((x) & 7)\n\n#define PROTOCOL_REGISTER_6\t\t73\n#define LINE_POLARITIES\t\tPROTOCOL_REGISTER_6\n#define INVERT_ACK\t\tBIT(0)\n#define INVERT_REQ\t\tBIT(1)\n#define INVERT_CLOCK\t\tBIT(2)\n#define INVERT_SERIAL\t\tBIT(3)\n#define OPEN_ACK\t\tBIT(4)\n#define OPEN_CLOCK\t\tBIT(5)\n\n#define PROTOCOL_REGISTER_7\t\t74\n#define ACK_SER\t\t\tPROTOCOL_REGISTER_7\n#define ACK_LINE(x)\t\t(((x) & 3) << 2)\n#define EXCHANGE_PINS\t\tBIT(7)\n\n#define INTERRUPT_CONTROL\t\t75\n \n\n#define DMA_LINE_CONTROL_GROUP1\t\t76\n#define DMA_LINE_CONTROL_GROUP2\t\t108\n\n \nstatic inline unsigned int primary_DMAChannel_bits(unsigned int channel)\n{\n\treturn channel & 0x3;\n}\n\nstatic inline unsigned int secondary_DMAChannel_bits(unsigned int channel)\n{\n\treturn (channel << 2) & 0xc;\n}\n\n#define TRANSFER_SIZE_CONTROL\t\t77\n#define TRANSFER_WIDTH(x)\t((x) & 3)\n#define TRANSFER_LENGTH(x)\t(((x) & 3) << 3)\n#define REQUIRE_R_LEVEL        BIT(5)\n\n#define PROTOCOL_REGISTER_15\t\t79\n#define DAQ_OPTIONS\t\t\tPROTOCOL_REGISTER_15\n#define START_SOURCE(x)\t\t\t((x) & 0x3)\n#define INVERT_START\t\t\t\tBIT(2)\n#define STOP_SOURCE(x)\t\t\t\t(((x) & 0x3) << 3)\n#define REQ_START\t\t\t\tBIT(6)\n#define PRE_START\t\t\t\tBIT(7)\n\n#define PATTERN_DETECTION\t\t81\n#define DETECTION_METHOD\t\t\tBIT(0)\n#define INVERT_MATCH\t\t\t\tBIT(1)\n#define IE_PATTERN_DETECTION\t\t\tBIT(2)\n\n#define PROTOCOL_REGISTER_9\t\t82\n#define REQ_DELAY\t\t\tPROTOCOL_REGISTER_9\n\n#define PROTOCOL_REGISTER_10\t\t83\n#define REQ_NOT_DELAY\t\t\tPROTOCOL_REGISTER_10\n\n#define PROTOCOL_REGISTER_11\t\t84\n#define ACK_DELAY\t\t\tPROTOCOL_REGISTER_11\n\n#define PROTOCOL_REGISTER_12\t\t85\n#define ACK_NOT_DELAY\t\t\tPROTOCOL_REGISTER_12\n\n#define PROTOCOL_REGISTER_13\t\t86\n#define DATA_1_DELAY\t\t\tPROTOCOL_REGISTER_13\n\n#define PROTOCOL_REGISTER_8\t\t88\t \n#define START_DELAY\t\t\tPROTOCOL_REGISTER_8\n\n \n#define FW_PCI_6534_MAIN\t\t\"ni6534a.bin\"\n#define FW_PCI_6534_SCARAB_DI\t\t\"niscrb01.bin\"\n#define FW_PCI_6534_SCARAB_DO\t\t\"niscrb02.bin\"\nMODULE_FIRMWARE(FW_PCI_6534_MAIN);\nMODULE_FIRMWARE(FW_PCI_6534_SCARAB_DI);\nMODULE_FIRMWARE(FW_PCI_6534_SCARAB_DO);\n\nenum pci_6534_firmware_registers {\t \n\tFirmware_Control_Register = 0x100,\n\tFirmware_Status_Register = 0x104,\n\tFirmware_Data_Register = 0x108,\n\tFirmware_Mask_Register = 0x10c,\n\tFirmware_Debug_Register = 0x110,\n};\n\n \nenum pci_6534_fpga_registers {\n\tFPGA_Control1_Register = 0x200,\n\tFPGA_Control2_Register = 0x204,\n\tFPGA_Irq_Mask_Register = 0x208,\n\tFPGA_Status_Register = 0x20c,\n\tFPGA_Signature_Register = 0x210,\n\tFPGA_SCALS_Counter_Register = 0x280,\t \n\tFPGA_SCAMS_Counter_Register = 0x284,\t \n\tFPGA_SCBLS_Counter_Register = 0x288,\t \n\tFPGA_SCBMS_Counter_Register = 0x28c,\t \n\tFPGA_Temp_Control_Register = 0x2a0,\n\tFPGA_DAR_Register = 0x2a8,\n\tFPGA_ELC_Read_Register = 0x2b8,\n\tFPGA_ELC_Write_Register = 0x2bc,\n};\n\nenum FPGA_Control_Bits {\n\tFPGA_Enable_Bit = 0x8000,\n};\n\n#define TIMER_BASE 50\t\t \n\n#ifdef USE_DMA\n#define INT_EN (COUNT_EXPIRED | WAITED | PRIMARY_TC | SECONDARY_TC)\n#else\n#define INT_EN (TRANSFER_READY | COUNT_EXPIRED | WAITED \\\n\t\t| PRIMARY_TC | SECONDARY_TC)\n#endif\n\nenum nidio_boardid {\n\tBOARD_PCIDIO_32HS,\n\tBOARD_PXI6533,\n\tBOARD_PCI6534,\n};\n\nstruct nidio_board {\n\tconst char *name;\n\tunsigned int uses_firmware:1;\n\tunsigned int dio_speed;\n};\n\nstatic const struct nidio_board nidio_boards[] = {\n\t[BOARD_PCIDIO_32HS] = {\n\t\t.name\t\t= \"pci-dio-32hs\",\n\t\t.dio_speed\t= 50,\n\t},\n\t[BOARD_PXI6533] = {\n\t\t.name\t\t= \"pxi-6533\",\n\t\t.dio_speed\t= 50,\n\t},\n\t[BOARD_PCI6534] = {\n\t\t.name\t\t= \"pci-6534\",\n\t\t.uses_firmware\t= 1,\n\t\t.dio_speed\t= 50,\n\t},\n};\n\nstruct nidio96_private {\n\tstruct mite *mite;\n\tint boardtype;\n\tint dio;\n\tunsigned short OP_MODEBits;\n\tstruct mite_channel *di_mite_chan;\n\tstruct mite_ring *di_mite_ring;\n\tspinlock_t mite_channel_lock;\n};\n\nstatic int ni_pcidio_request_di_mite_channel(struct comedi_device *dev)\n{\n\tstruct nidio96_private *devpriv = dev->private;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&devpriv->mite_channel_lock, flags);\n\tBUG_ON(devpriv->di_mite_chan);\n\tdevpriv->di_mite_chan =\n\t    mite_request_channel_in_range(devpriv->mite,\n\t\t\t\t\t  devpriv->di_mite_ring, 1, 2);\n\tif (!devpriv->di_mite_chan) {\n\t\tspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\n\t\tdev_err(dev->class_dev, \"failed to reserve mite dma channel\\n\");\n\t\treturn -EBUSY;\n\t}\n\tdevpriv->di_mite_chan->dir = COMEDI_INPUT;\n\twriteb(primary_DMAChannel_bits(devpriv->di_mite_chan->channel) |\n\t       secondary_DMAChannel_bits(devpriv->di_mite_chan->channel),\n\t       dev->mmio + DMA_LINE_CONTROL_GROUP1);\n\tspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\n\treturn 0;\n}\n\nstatic void ni_pcidio_release_di_mite_channel(struct comedi_device *dev)\n{\n\tstruct nidio96_private *devpriv = dev->private;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&devpriv->mite_channel_lock, flags);\n\tif (devpriv->di_mite_chan) {\n\t\tmite_release_channel(devpriv->di_mite_chan);\n\t\tdevpriv->di_mite_chan = NULL;\n\t\twriteb(primary_DMAChannel_bits(0) |\n\t\t       secondary_DMAChannel_bits(0),\n\t\t       dev->mmio + DMA_LINE_CONTROL_GROUP1);\n\t}\n\tspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\n}\n\nstatic int setup_mite_dma(struct comedi_device *dev, struct comedi_subdevice *s)\n{\n\tstruct nidio96_private *devpriv = dev->private;\n\tint retval;\n\tunsigned long flags;\n\n\tretval = ni_pcidio_request_di_mite_channel(dev);\n\tif (retval)\n\t\treturn retval;\n\n\t \n\tcomedi_buf_write_alloc(s, s->async->prealloc_bufsz);\n\n\tspin_lock_irqsave(&devpriv->mite_channel_lock, flags);\n\tif (devpriv->di_mite_chan) {\n\t\tmite_prep_dma(devpriv->di_mite_chan, 32, 32);\n\t\tmite_dma_arm(devpriv->di_mite_chan);\n\t} else {\n\t\tretval = -EIO;\n\t}\n\tspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\n\n\treturn retval;\n}\n\nstatic int ni_pcidio_poll(struct comedi_device *dev, struct comedi_subdevice *s)\n{\n\tstruct nidio96_private *devpriv = dev->private;\n\tunsigned long irq_flags;\n\tint count;\n\n\tspin_lock_irqsave(&dev->spinlock, irq_flags);\n\tspin_lock(&devpriv->mite_channel_lock);\n\tif (devpriv->di_mite_chan)\n\t\tmite_sync_dma(devpriv->di_mite_chan, s);\n\tspin_unlock(&devpriv->mite_channel_lock);\n\tcount = comedi_buf_n_bytes_ready(s);\n\tspin_unlock_irqrestore(&dev->spinlock, irq_flags);\n\treturn count;\n}\n\nstatic irqreturn_t nidio_interrupt(int irq, void *d)\n{\n\tstruct comedi_device *dev = d;\n\tstruct nidio96_private *devpriv = dev->private;\n\tstruct comedi_subdevice *s = dev->read_subdev;\n\tstruct comedi_async *async = s->async;\n\tunsigned int auxdata;\n\tint flags;\n\tint status;\n\tint work = 0;\n\n\t \n\tif (!dev->attached) {\n\t\t \n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\tspin_lock(&dev->spinlock);\n\n\tstatus = readb(dev->mmio + INTERRUPT_AND_WINDOW_STATUS);\n\tflags = readb(dev->mmio + GROUP_1_FLAGS);\n\n\tspin_lock(&devpriv->mite_channel_lock);\n\tif (devpriv->di_mite_chan) {\n\t\tmite_ack_linkc(devpriv->di_mite_chan, s, false);\n\t\t \n\t}\n\tspin_unlock(&devpriv->mite_channel_lock);\n\n\twhile (status & DATA_LEFT) {\n\t\twork++;\n\t\tif (work > 20) {\n\t\t\tdev_dbg(dev->class_dev, \"too much work in interrupt\\n\");\n\t\t\twriteb(0x00,\n\t\t\t       dev->mmio + MASTER_DMA_AND_INTERRUPT_CONTROL);\n\t\t\tbreak;\n\t\t}\n\n\t\tflags &= INT_EN;\n\n\t\tif (flags & TRANSFER_READY) {\n\t\t\twhile (flags & TRANSFER_READY) {\n\t\t\t\twork++;\n\t\t\t\tif (work > 100) {\n\t\t\t\t\tdev_dbg(dev->class_dev,\n\t\t\t\t\t\t\"too much work in interrupt\\n\");\n\t\t\t\t\twriteb(0x00, dev->mmio +\n\t\t\t\t\t       MASTER_DMA_AND_INTERRUPT_CONTROL\n\t\t\t\t\t      );\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tauxdata = readl(dev->mmio + GROUP_1_FIFO);\n\t\t\t\tcomedi_buf_write_samples(s, &auxdata, 1);\n\t\t\t\tflags = readb(dev->mmio + GROUP_1_FLAGS);\n\t\t\t}\n\t\t}\n\n\t\tif (flags & COUNT_EXPIRED) {\n\t\t\twriteb(CLEAR_EXPIRED, dev->mmio + GROUP_1_SECOND_CLEAR);\n\t\t\tasync->events |= COMEDI_CB_EOA;\n\n\t\t\twriteb(0x00, dev->mmio + OP_MODE);\n\t\t\tbreak;\n\t\t} else if (flags & WAITED) {\n\t\t\twriteb(CLEAR_WAITED, dev->mmio + GROUP_1_FIRST_CLEAR);\n\t\t\tasync->events |= COMEDI_CB_ERROR;\n\t\t\tbreak;\n\t\t} else if (flags & PRIMARY_TC) {\n\t\t\twriteb(CLEAR_PRIMARY_TC,\n\t\t\t       dev->mmio + GROUP_1_FIRST_CLEAR);\n\t\t\tasync->events |= COMEDI_CB_EOA;\n\t\t} else if (flags & SECONDARY_TC) {\n\t\t\twriteb(CLEAR_SECONDARY_TC,\n\t\t\t       dev->mmio + GROUP_1_FIRST_CLEAR);\n\t\t\tasync->events |= COMEDI_CB_EOA;\n\t\t}\n\n\t\tflags = readb(dev->mmio + GROUP_1_FLAGS);\n\t\tstatus = readb(dev->mmio + INTERRUPT_AND_WINDOW_STATUS);\n\t}\n\nout:\n\tcomedi_handle_events(dev, s);\n#if 0\n\tif (!tag)\n\t\twriteb(0x03, dev->mmio + MASTER_DMA_AND_INTERRUPT_CONTROL);\n#endif\n\n\tspin_unlock(&dev->spinlock);\n\treturn IRQ_HANDLED;\n}\n\nstatic int ni_pcidio_insn_config(struct comedi_device *dev,\n\t\t\t\t struct comedi_subdevice *s,\n\t\t\t\t struct comedi_insn *insn,\n\t\t\t\t unsigned int *data)\n{\n\tint ret;\n\n\tif (data[0] == INSN_CONFIG_GET_CMD_TIMING_CONSTRAINTS) {\n\t\tconst struct nidio_board *board = dev->board_ptr;\n\n\t\t \n\t\tdata[1] = board->dio_speed;\n\t\tdata[2] = 0;\n\t\treturn 0;\n\t}\n\n\tret = comedi_dio_insn_config(dev, s, insn, data, 0);\n\tif (ret)\n\t\treturn ret;\n\n\twritel(s->io_bits, dev->mmio + PORT_PIN_DIRECTIONS(0));\n\n\treturn insn->n;\n}\n\nstatic int ni_pcidio_insn_bits(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       struct comedi_insn *insn,\n\t\t\t       unsigned int *data)\n{\n\tif (comedi_dio_update_state(s, data))\n\t\twritel(s->state, dev->mmio + PORT_IO(0));\n\n\tdata[1] = readl(dev->mmio + PORT_IO(0));\n\n\treturn insn->n;\n}\n\nstatic int ni_pcidio_ns_to_timer(int *nanosec, unsigned int flags)\n{\n\tint divider, base;\n\n\tbase = TIMER_BASE;\n\n\tswitch (flags & CMDF_ROUND_MASK) {\n\tcase CMDF_ROUND_NEAREST:\n\tdefault:\n\t\tdivider = DIV_ROUND_CLOSEST(*nanosec, base);\n\t\tbreak;\n\tcase CMDF_ROUND_DOWN:\n\t\tdivider = (*nanosec) / base;\n\t\tbreak;\n\tcase CMDF_ROUND_UP:\n\t\tdivider = DIV_ROUND_UP(*nanosec, base);\n\t\tbreak;\n\t}\n\n\t*nanosec = base * divider;\n\treturn divider;\n}\n\nstatic int ni_pcidio_cmdtest(struct comedi_device *dev,\n\t\t\t     struct comedi_subdevice *s, struct comedi_cmd *cmd)\n{\n\tint err = 0;\n\tunsigned int arg;\n\n\t \n\n\terr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_INT);\n\terr |= comedi_check_trigger_src(&cmd->scan_begin_src,\n\t\t\t\t\tTRIG_TIMER | TRIG_EXT);\n\terr |= comedi_check_trigger_src(&cmd->convert_src, TRIG_NOW);\n\terr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\n\terr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\n\n\tif (err)\n\t\treturn 1;\n\n\t \n\n\terr |= comedi_check_trigger_is_unique(cmd->start_src);\n\terr |= comedi_check_trigger_is_unique(cmd->scan_begin_src);\n\terr |= comedi_check_trigger_is_unique(cmd->stop_src);\n\n\t \n\n\tif (err)\n\t\treturn 2;\n\n\t \n\n\terr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\n\n#define MAX_SPEED\t(TIMER_BASE)\t \n\n\tif (cmd->scan_begin_src == TRIG_TIMER) {\n\t\terr |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,\n\t\t\t\t\t\t    MAX_SPEED);\n\t\t \n\t} else {\n\t\t \n\t\t \n\t\tif ((cmd->scan_begin_arg & ~(CR_EDGE | CR_INVERT)) != 0) {\n\t\t\tcmd->scan_begin_arg &= (CR_EDGE | CR_INVERT);\n\t\t\terr |= -EINVAL;\n\t\t}\n\t}\n\n\terr |= comedi_check_trigger_arg_is(&cmd->convert_arg, 0);\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\n\t\t\t\t\t   cmd->chanlist_len);\n\n\tif (cmd->stop_src == TRIG_COUNT)\n\t\terr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\n\telse\t \n\t\terr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\n\n\tif (err)\n\t\treturn 3;\n\n\t \n\n\tif (cmd->scan_begin_src == TRIG_TIMER) {\n\t\targ = cmd->scan_begin_arg;\n\t\tni_pcidio_ns_to_timer(&arg, cmd->flags);\n\t\terr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, arg);\n\t}\n\n\tif (err)\n\t\treturn 4;\n\n\treturn 0;\n}\n\nstatic int ni_pcidio_inttrig(struct comedi_device *dev,\n\t\t\t     struct comedi_subdevice *s,\n\t\t\t     unsigned int trig_num)\n{\n\tstruct nidio96_private *devpriv = dev->private;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\n\tif (trig_num != cmd->start_arg)\n\t\treturn -EINVAL;\n\n\twriteb(devpriv->OP_MODEBits, dev->mmio + OP_MODE);\n\ts->async->inttrig = NULL;\n\n\treturn 1;\n}\n\nstatic int ni_pcidio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\n{\n\tstruct nidio96_private *devpriv = dev->private;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\n\t \n\twritel(0x0000, dev->mmio + PORT_PIN_DIRECTIONS(0));\n\n\tif (1) {\n\t\t \n\t\twriteb(0x0f, dev->mmio + DATA_PATH);\n\n\t\t \n\t\twriteb(TRANSFER_WIDTH(0) | TRANSFER_LENGTH(0),\n\t\t       dev->mmio + TRANSFER_SIZE_CONTROL);\n\t} else {\n\t\twriteb(0x03, dev->mmio + DATA_PATH);\n\t\twriteb(TRANSFER_WIDTH(3) | TRANSFER_LENGTH(0),\n\t\t       dev->mmio + TRANSFER_SIZE_CONTROL);\n\t}\n\n\t \n\tif (cmd->scan_begin_src == TRIG_TIMER) {\n\t\t \n\t\twriteb(0, dev->mmio + OP_MODE);\n\t\twriteb(0x00, dev->mmio + CLOCK_REG);\n\t\twriteb(1, dev->mmio + SEQUENCE);\n\t\twriteb(0x04, dev->mmio + REQ_REG);\n\t\twriteb(4, dev->mmio + BLOCK_MODE);\n\t\twriteb(3, dev->mmio + LINE_POLARITIES);\n\t\twriteb(0xc0, dev->mmio + ACK_SER);\n\t\twritel(ni_pcidio_ns_to_timer(&cmd->scan_begin_arg,\n\t\t\t\t\t     CMDF_ROUND_NEAREST),\n\t\t       dev->mmio + START_DELAY);\n\t\twriteb(1, dev->mmio + REQ_DELAY);\n\t\twriteb(1, dev->mmio + REQ_NOT_DELAY);\n\t\twriteb(1, dev->mmio + ACK_DELAY);\n\t\twriteb(0x0b, dev->mmio + ACK_NOT_DELAY);\n\t\twriteb(0x01, dev->mmio + DATA_1_DELAY);\n\t\t \n\t\twritew(0, dev->mmio + CLOCK_SPEED);\n\t\twriteb(0, dev->mmio + DAQ_OPTIONS);\n\t} else {\n\t\t \n\t\t \n\t\twriteb(0, dev->mmio + OP_MODE);\n\t\twriteb(0x00, dev->mmio + CLOCK_REG);\n\t\twriteb(0, dev->mmio + SEQUENCE);\n\t\twriteb(0x00, dev->mmio + REQ_REG);\n\t\twriteb(4, dev->mmio + BLOCK_MODE);\n\t\tif (!(cmd->scan_begin_arg & CR_INVERT))\t \n\t\t\twriteb(0, dev->mmio + LINE_POLARITIES);\n\t\telse\t\t\t\t\t \n\t\t\twriteb(2, dev->mmio + LINE_POLARITIES);\n\t\twriteb(0x00, dev->mmio + ACK_SER);\n\t\twritel(1, dev->mmio + START_DELAY);\n\t\twriteb(1, dev->mmio + REQ_DELAY);\n\t\twriteb(1, dev->mmio + REQ_NOT_DELAY);\n\t\twriteb(1, dev->mmio + ACK_DELAY);\n\t\twriteb(0x0C, dev->mmio + ACK_NOT_DELAY);\n\t\twriteb(0x10, dev->mmio + DATA_1_DELAY);\n\t\twritew(0, dev->mmio + CLOCK_SPEED);\n\t\twriteb(0x60, dev->mmio + DAQ_OPTIONS);\n\t}\n\n\tif (cmd->stop_src == TRIG_COUNT) {\n\t\twritel(cmd->stop_arg,\n\t\t       dev->mmio + TRANSFER_COUNT);\n\t} else {\n\t\t \n\t}\n\n#ifdef USE_DMA\n\twriteb(CLEAR_PRIMARY_TC | CLEAR_SECONDARY_TC,\n\t       dev->mmio + GROUP_1_FIRST_CLEAR);\n\n\t{\n\t\tint retval = setup_mite_dma(dev, s);\n\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n#else\n\twriteb(0x00, dev->mmio + DMA_LINE_CONTROL_GROUP1);\n#endif\n\twriteb(0x00, dev->mmio + DMA_LINE_CONTROL_GROUP2);\n\n\t \n\twriteb(0xff, dev->mmio + GROUP_1_FIRST_CLEAR);\n\t \n\n\twriteb(INT_EN, dev->mmio + INTERRUPT_CONTROL);\n\twriteb(0x03, dev->mmio + MASTER_DMA_AND_INTERRUPT_CONTROL);\n\n\tif (cmd->stop_src == TRIG_NONE) {\n\t\tdevpriv->OP_MODEBits = DATA_LATCHING(0) | RUN_MODE(7);\n\t} else {\t\t \n\t\tdevpriv->OP_MODEBits = NUMBERED | RUN_MODE(7);\n\t}\n\tif (cmd->start_src == TRIG_NOW) {\n\t\t \n\t\twriteb(devpriv->OP_MODEBits, dev->mmio + OP_MODE);\n\t\ts->async->inttrig = NULL;\n\t} else {\n\t\t \n\t\ts->async->inttrig = ni_pcidio_inttrig;\n\t}\n\n\treturn 0;\n}\n\nstatic int ni_pcidio_cancel(struct comedi_device *dev,\n\t\t\t    struct comedi_subdevice *s)\n{\n\twriteb(0x00, dev->mmio + MASTER_DMA_AND_INTERRUPT_CONTROL);\n\tni_pcidio_release_di_mite_channel(dev);\n\n\treturn 0;\n}\n\nstatic int ni_pcidio_change(struct comedi_device *dev,\n\t\t\t    struct comedi_subdevice *s)\n{\n\tstruct nidio96_private *devpriv = dev->private;\n\tint ret;\n\n\tret = mite_buf_change(devpriv->di_mite_ring, s);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmemset(s->async->prealloc_buf, 0xaa, s->async->prealloc_bufsz);\n\n\treturn 0;\n}\n\nstatic int pci_6534_load_fpga(struct comedi_device *dev,\n\t\t\t      const u8 *data, size_t data_len,\n\t\t\t      unsigned long context)\n{\n\tstatic const int timeout = 1000;\n\tint fpga_index = context;\n\tint i;\n\tsize_t j;\n\n\twritew(0x80 | fpga_index, dev->mmio + Firmware_Control_Register);\n\twritew(0xc0 | fpga_index, dev->mmio + Firmware_Control_Register);\n\tfor (i = 0;\n\t     (readw(dev->mmio + Firmware_Status_Register) & 0x2) == 0 &&\n\t     i < timeout; ++i) {\n\t\tudelay(1);\n\t}\n\tif (i == timeout) {\n\t\tdev_warn(dev->class_dev,\n\t\t\t \"ni_pcidio: failed to load fpga %i, waiting for status 0x2\\n\",\n\t\t\t fpga_index);\n\t\treturn -EIO;\n\t}\n\twritew(0x80 | fpga_index, dev->mmio + Firmware_Control_Register);\n\tfor (i = 0;\n\t     readw(dev->mmio + Firmware_Status_Register) != 0x3 &&\n\t     i < timeout; ++i) {\n\t\tudelay(1);\n\t}\n\tif (i == timeout) {\n\t\tdev_warn(dev->class_dev,\n\t\t\t \"ni_pcidio: failed to load fpga %i, waiting for status 0x3\\n\",\n\t\t\t fpga_index);\n\t\treturn -EIO;\n\t}\n\tfor (j = 0; j + 1 < data_len;) {\n\t\tunsigned int value = data[j++];\n\n\t\tvalue |= data[j++] << 8;\n\t\twritew(value, dev->mmio + Firmware_Data_Register);\n\t\tfor (i = 0;\n\t\t     (readw(dev->mmio + Firmware_Status_Register) & 0x2) == 0\n\t\t     && i < timeout; ++i) {\n\t\t\tudelay(1);\n\t\t}\n\t\tif (i == timeout) {\n\t\t\tdev_warn(dev->class_dev,\n\t\t\t\t \"ni_pcidio: failed to load word into fpga %i\\n\",\n\t\t\t\t fpga_index);\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (need_resched())\n\t\t\tschedule();\n\t}\n\twritew(0x0, dev->mmio + Firmware_Control_Register);\n\treturn 0;\n}\n\nstatic int pci_6534_reset_fpga(struct comedi_device *dev, int fpga_index)\n{\n\treturn pci_6534_load_fpga(dev, NULL, 0, fpga_index);\n}\n\nstatic int pci_6534_reset_fpgas(struct comedi_device *dev)\n{\n\tint ret;\n\tint i;\n\n\twritew(0x0, dev->mmio + Firmware_Control_Register);\n\tfor (i = 0; i < 3; ++i) {\n\t\tret = pci_6534_reset_fpga(dev, i);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\twritew(0x0, dev->mmio + Firmware_Mask_Register);\n\treturn ret;\n}\n\nstatic void pci_6534_init_main_fpga(struct comedi_device *dev)\n{\n\twritel(0, dev->mmio + FPGA_Control1_Register);\n\twritel(0, dev->mmio + FPGA_Control2_Register);\n\twritel(0, dev->mmio + FPGA_SCALS_Counter_Register);\n\twritel(0, dev->mmio + FPGA_SCAMS_Counter_Register);\n\twritel(0, dev->mmio + FPGA_SCBLS_Counter_Register);\n\twritel(0, dev->mmio + FPGA_SCBMS_Counter_Register);\n}\n\nstatic int pci_6534_upload_firmware(struct comedi_device *dev)\n{\n\tstruct nidio96_private *devpriv = dev->private;\n\tstatic const char *const fw_file[3] = {\n\t\tFW_PCI_6534_SCARAB_DI,\t \n\t\tFW_PCI_6534_SCARAB_DO,\t \n\t\tFW_PCI_6534_MAIN,\t \n\t};\n\tint ret;\n\tint n;\n\n\tret = pci_6534_reset_fpgas(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\t \n\tfor (n = 2; n >= 0; n--) {\n\t\tret = comedi_load_firmware(dev, &devpriv->mite->pcidev->dev,\n\t\t\t\t\t   fw_file[n],\n\t\t\t\t\t   pci_6534_load_fpga, n);\n\t\tif (ret == 0 && n == 2)\n\t\t\tpci_6534_init_main_fpga(dev);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic void nidio_reset_board(struct comedi_device *dev)\n{\n\twritel(0, dev->mmio + PORT_IO(0));\n\twritel(0, dev->mmio + PORT_PIN_DIRECTIONS(0));\n\twritel(0, dev->mmio + PORT_PIN_MASK(0));\n\n\t \n\twriteb(0, dev->mmio + MASTER_DMA_AND_INTERRUPT_CONTROL);\n}\n\nstatic int nidio_auto_attach(struct comedi_device *dev,\n\t\t\t     unsigned long context)\n{\n\tstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\n\tconst struct nidio_board *board = NULL;\n\tstruct nidio96_private *devpriv;\n\tstruct comedi_subdevice *s;\n\tint ret;\n\tunsigned int irq;\n\n\tif (context < ARRAY_SIZE(nidio_boards))\n\t\tboard = &nidio_boards[context];\n\tif (!board)\n\t\treturn -ENODEV;\n\tdev->board_ptr = board;\n\tdev->board_name = board->name;\n\n\tret = comedi_pci_enable(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tdevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\n\tif (!devpriv)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&devpriv->mite_channel_lock);\n\n\tdevpriv->mite = mite_attach(dev, false);\t \n\tif (!devpriv->mite)\n\t\treturn -ENOMEM;\n\n\tdevpriv->di_mite_ring = mite_alloc_ring(devpriv->mite);\n\tif (!devpriv->di_mite_ring)\n\t\treturn -ENOMEM;\n\n\tif (board->uses_firmware) {\n\t\tret = pci_6534_upload_firmware(dev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tnidio_reset_board(dev);\n\n\tret = comedi_alloc_subdevices(dev, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_info(dev->class_dev, \"%s rev=%d\\n\", dev->board_name,\n\t\t readb(dev->mmio + CHIP_VERSION));\n\n\ts = &dev->subdevices[0];\n\n\tdev->read_subdev = s;\n\ts->type = COMEDI_SUBD_DIO;\n\ts->subdev_flags =\n\t\tSDF_READABLE | SDF_WRITABLE | SDF_LSAMPL | SDF_PACKED |\n\t\tSDF_CMD_READ;\n\ts->n_chan = 32;\n\ts->range_table = &range_digital;\n\ts->maxdata = 1;\n\ts->insn_config = &ni_pcidio_insn_config;\n\ts->insn_bits = &ni_pcidio_insn_bits;\n\ts->do_cmd = &ni_pcidio_cmd;\n\ts->do_cmdtest = &ni_pcidio_cmdtest;\n\ts->cancel = &ni_pcidio_cancel;\n\ts->len_chanlist = 32;\t \n\ts->buf_change = &ni_pcidio_change;\n\ts->async_dma_dir = DMA_BIDIRECTIONAL;\n\ts->poll = &ni_pcidio_poll;\n\n\tirq = pcidev->irq;\n\tif (irq) {\n\t\tret = request_irq(irq, nidio_interrupt, IRQF_SHARED,\n\t\t\t\t  dev->board_name, dev);\n\t\tif (ret == 0)\n\t\t\tdev->irq = irq;\n\t}\n\n\treturn 0;\n}\n\nstatic void nidio_detach(struct comedi_device *dev)\n{\n\tstruct nidio96_private *devpriv = dev->private;\n\n\tif (dev->irq)\n\t\tfree_irq(dev->irq, dev);\n\tif (devpriv) {\n\t\tif (devpriv->di_mite_ring) {\n\t\t\tmite_free_ring(devpriv->di_mite_ring);\n\t\t\tdevpriv->di_mite_ring = NULL;\n\t\t}\n\t\tmite_detach(devpriv->mite);\n\t}\n\tif (dev->mmio)\n\t\tiounmap(dev->mmio);\n\tcomedi_pci_disable(dev);\n}\n\nstatic struct comedi_driver ni_pcidio_driver = {\n\t.driver_name\t= \"ni_pcidio\",\n\t.module\t\t= THIS_MODULE,\n\t.auto_attach\t= nidio_auto_attach,\n\t.detach\t\t= nidio_detach,\n};\n\nstatic int ni_pcidio_pci_probe(struct pci_dev *dev,\n\t\t\t       const struct pci_device_id *id)\n{\n\treturn comedi_pci_auto_config(dev, &ni_pcidio_driver, id->driver_data);\n}\n\nstatic const struct pci_device_id ni_pcidio_pci_table[] = {\n\t{ PCI_VDEVICE(NI, 0x1150), BOARD_PCIDIO_32HS },\n\t{ PCI_VDEVICE(NI, 0x12b0), BOARD_PCI6534 },\n\t{ PCI_VDEVICE(NI, 0x1320), BOARD_PXI6533 },\n\t{ 0 }\n};\nMODULE_DEVICE_TABLE(pci, ni_pcidio_pci_table);\n\nstatic struct pci_driver ni_pcidio_pci_driver = {\n\t.name\t\t= \"ni_pcidio\",\n\t.id_table\t= ni_pcidio_pci_table,\n\t.probe\t\t= ni_pcidio_pci_probe,\n\t.remove\t\t= comedi_pci_auto_unconfig,\n};\nmodule_comedi_pci_driver(ni_pcidio_driver, ni_pcidio_pci_driver);\n\nMODULE_AUTHOR(\"Comedi https://www.comedi.org\");\nMODULE_DESCRIPTION(\"Comedi low-level driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}