{
  "module_name": "addi_apci_1500.c",
  "hash_id": "30d737c3d418c51db0b552e9e1e766c6149783de0e40a04639a37d1bcea634fc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/addi_apci_1500.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/comedi/comedi_pci.h>\n\n#include \"amcc_s5933.h\"\n#include \"z8536.h\"\n\n \n\n \n#define APCI1500_Z8536_PORTC_REG\t0x00\n#define APCI1500_Z8536_PORTB_REG\t0x01\n#define APCI1500_Z8536_PORTA_REG\t0x02\n#define APCI1500_Z8536_CTRL_REG\t\t0x03\n\n \n#define APCI1500_CLK_SEL_REG\t\t0x00\n#define APCI1500_DI_REG\t\t\t0x00\n#define APCI1500_DO_REG\t\t\t0x02\n\nstruct apci1500_private {\n\tunsigned long amcc;\n\tunsigned long addon;\n\n\tunsigned int clk_src;\n\n\t \n\tunsigned int pm[2];\t \n\tunsigned int pt[2];\t \n\tunsigned int pp[2];\t \n};\n\nstatic unsigned int z8536_read(struct comedi_device *dev, unsigned int reg)\n{\n\tunsigned long flags;\n\tunsigned int val;\n\n\tspin_lock_irqsave(&dev->spinlock, flags);\n\toutb(reg, dev->iobase + APCI1500_Z8536_CTRL_REG);\n\tval = inb(dev->iobase + APCI1500_Z8536_CTRL_REG);\n\tspin_unlock_irqrestore(&dev->spinlock, flags);\n\n\treturn val;\n}\n\nstatic void z8536_write(struct comedi_device *dev,\n\t\t\tunsigned int val, unsigned int reg)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->spinlock, flags);\n\toutb(reg, dev->iobase + APCI1500_Z8536_CTRL_REG);\n\toutb(val, dev->iobase + APCI1500_Z8536_CTRL_REG);\n\tspin_unlock_irqrestore(&dev->spinlock, flags);\n}\n\nstatic void z8536_reset(struct comedi_device *dev)\n{\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&dev->spinlock, flags);\n\tinb(dev->iobase + APCI1500_Z8536_CTRL_REG);\n\toutb(0, dev->iobase + APCI1500_Z8536_CTRL_REG);\n\tinb(dev->iobase + APCI1500_Z8536_CTRL_REG);\n\toutb(0, dev->iobase + APCI1500_Z8536_CTRL_REG);\n\toutb(1, dev->iobase + APCI1500_Z8536_CTRL_REG);\n\toutb(0, dev->iobase + APCI1500_Z8536_CTRL_REG);\n\tspin_unlock_irqrestore(&dev->spinlock, flags);\n\n\t \n\tz8536_write(dev, 0x00, Z8536_CFG_CTRL_REG);\n\n\t \n\tz8536_write(dev, Z8536_PAB_MODE_PTS_BIT |\n\t\t\t Z8536_PAB_MODE_SB |\n\t\t\t Z8536_PAB_MODE_PMS_DISABLE,\n\t\t    Z8536_PA_MODE_REG);\n\tz8536_write(dev, 0xff, Z8536_PB_DPP_REG);\n\tz8536_write(dev, 0xff, Z8536_PA_DD_REG);\n\n\t \n\tz8536_write(dev, Z8536_PAB_MODE_PTS_BIT |\n\t\t\t Z8536_PAB_MODE_SB |\n\t\t\t Z8536_PAB_MODE_PMS_DISABLE,\n\t\t    Z8536_PB_MODE_REG);\n\tz8536_write(dev, 0x7f, Z8536_PB_DPP_REG);\n\tz8536_write(dev, 0xff, Z8536_PB_DD_REG);\n\n\t \n\tz8536_write(dev, 0x09, Z8536_PC_DPP_REG);\n\tz8536_write(dev, 0x0e, Z8536_PC_DD_REG);\n\n\t \n\tz8536_write(dev, Z8536_CMD_CLR_IP_IUS, Z8536_PA_CMDSTAT_REG);\n\tz8536_write(dev, Z8536_CMD_CLR_IE, Z8536_PA_CMDSTAT_REG);\n\n\tz8536_write(dev, Z8536_CMD_CLR_IP_IUS, Z8536_PB_CMDSTAT_REG);\n\tz8536_write(dev, Z8536_CMD_CLR_IE, Z8536_PB_CMDSTAT_REG);\n\n\tz8536_write(dev, Z8536_CMD_CLR_IP_IUS, Z8536_CT_CMDSTAT_REG(0));\n\tz8536_write(dev, Z8536_CMD_CLR_IE, Z8536_CT_CMDSTAT_REG(0));\n\n\tz8536_write(dev, Z8536_CMD_CLR_IP_IUS, Z8536_CT_CMDSTAT_REG(1));\n\tz8536_write(dev, Z8536_CMD_CLR_IE, Z8536_CT_CMDSTAT_REG(1));\n\n\tz8536_write(dev, Z8536_CMD_CLR_IP_IUS, Z8536_CT_CMDSTAT_REG(2));\n\tz8536_write(dev, Z8536_CMD_CLR_IE, Z8536_CT_CMDSTAT_REG(2));\n\n\t \n\tz8536_write(dev, 0x00, Z8536_INT_CTRL_REG);\n}\n\nstatic void apci1500_port_enable(struct comedi_device *dev, bool enable)\n{\n\tunsigned int cfg;\n\n\tcfg = z8536_read(dev, Z8536_CFG_CTRL_REG);\n\tif (enable)\n\t\tcfg |= (Z8536_CFG_CTRL_PAE | Z8536_CFG_CTRL_PBE);\n\telse\n\t\tcfg &= ~(Z8536_CFG_CTRL_PAE | Z8536_CFG_CTRL_PBE);\n\tz8536_write(dev, cfg, Z8536_CFG_CTRL_REG);\n}\n\nstatic void apci1500_timer_enable(struct comedi_device *dev,\n\t\t\t\t  unsigned int chan, bool enable)\n{\n\tunsigned int bit;\n\tunsigned int cfg;\n\n\tif (chan == 0)\n\t\tbit = Z8536_CFG_CTRL_CT1E;\n\telse if (chan == 1)\n\t\tbit = Z8536_CFG_CTRL_CT2E;\n\telse\n\t\tbit = Z8536_CFG_CTRL_PCE_CT3E;\n\n\tcfg = z8536_read(dev, Z8536_CFG_CTRL_REG);\n\tif (enable) {\n\t\tcfg |= bit;\n\t} else {\n\t\tcfg &= ~bit;\n\t\tz8536_write(dev, 0x00, Z8536_CT_CMDSTAT_REG(chan));\n\t}\n\tz8536_write(dev, cfg, Z8536_CFG_CTRL_REG);\n}\n\nstatic bool apci1500_ack_irq(struct comedi_device *dev,\n\t\t\t     unsigned int reg)\n{\n\tunsigned int val;\n\n\tval = z8536_read(dev, reg);\n\tif ((val & Z8536_STAT_IE_IP) == Z8536_STAT_IE_IP) {\n\t\tval &= 0x0f;\t\t\t \n\t\tval |= Z8536_CMD_CLR_IP_IUS;\n\t\tz8536_write(dev, val, reg);\n\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic irqreturn_t apci1500_interrupt(int irq, void *d)\n{\n\tstruct comedi_device *dev = d;\n\tstruct apci1500_private *devpriv = dev->private;\n\tstruct comedi_subdevice *s = dev->read_subdev;\n\tunsigned short status = 0;\n\tunsigned int val;\n\n\tval = inl(devpriv->amcc + AMCC_OP_REG_INTCSR);\n\tif (!(val & INTCSR_INTR_ASSERTED))\n\t\treturn IRQ_NONE;\n\n\tif (apci1500_ack_irq(dev, Z8536_PA_CMDSTAT_REG))\n\t\tstatus |= 0x01;\t \n\n\tif (apci1500_ack_irq(dev, Z8536_PB_CMDSTAT_REG)) {\n\t\t \n\t\tval = inb(dev->iobase + APCI1500_Z8536_PORTB_REG);\n\t\tval &= 0xc0;\n\t\tif (val) {\n\t\t\tif (val & 0x80)\t \n\t\t\t\tstatus |= 0x40;\n\t\t\tif (val & 0x40)\t \n\t\t\t\tstatus |= 0x80;\n\t\t} else {\n\t\t\tstatus |= 0x02;\t \n\t\t}\n\t}\n\n\t \n\tcomedi_buf_write_samples(s, &status, 1);\n\tcomedi_handle_events(dev, s);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int apci1500_di_cancel(struct comedi_device *dev,\n\t\t\t      struct comedi_subdevice *s)\n{\n\t \n\tz8536_write(dev, 0x00, Z8536_INT_CTRL_REG);\n\n\t \n\tapci1500_port_enable(dev, false);\n\n\t \n\tapci1500_ack_irq(dev, Z8536_PA_CMDSTAT_REG);\n\tapci1500_ack_irq(dev, Z8536_PB_CMDSTAT_REG);\n\n\t \n\tz8536_write(dev, Z8536_CMD_CLR_IE, Z8536_PA_CMDSTAT_REG);\n\tz8536_write(dev, Z8536_CMD_CLR_IE, Z8536_PB_CMDSTAT_REG);\n\n\t \n\tapci1500_port_enable(dev, true);\n\n\treturn 0;\n}\n\nstatic int apci1500_di_inttrig_start(struct comedi_device *dev,\n\t\t\t\t     struct comedi_subdevice *s,\n\t\t\t\t     unsigned int trig_num)\n{\n\tstruct apci1500_private *devpriv = dev->private;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tunsigned int pa_mode = Z8536_PAB_MODE_PMS_DISABLE;\n\tunsigned int pb_mode = Z8536_PAB_MODE_PMS_DISABLE;\n\tunsigned int pa_trig = trig_num & 0x01;\n\tunsigned int pb_trig = (trig_num >> 1) & 0x01;\n\tbool valid_trig = false;\n\tunsigned int val;\n\n\tif (trig_num != cmd->start_arg)\n\t\treturn -EINVAL;\n\n\t \n\tapci1500_port_enable(dev, false);\n\n\t \n\tz8536_write(dev, devpriv->pm[pa_trig] & 0xff, Z8536_PA_PM_REG);\n\tz8536_write(dev, devpriv->pt[pa_trig] & 0xff, Z8536_PA_PT_REG);\n\tz8536_write(dev, devpriv->pp[pa_trig] & 0xff, Z8536_PA_PP_REG);\n\n\t \n\tz8536_write(dev, (devpriv->pm[pb_trig] >> 8) & 0xff, Z8536_PB_PM_REG);\n\tz8536_write(dev, (devpriv->pt[pb_trig] >> 8) & 0xff, Z8536_PB_PT_REG);\n\tz8536_write(dev, (devpriv->pp[pb_trig] >> 8) & 0xff, Z8536_PB_PP_REG);\n\n\t \n\tif (devpriv->pm[pa_trig] & 0xff) {\n\t\tpa_mode = pa_trig ? Z8536_PAB_MODE_PMS_AND\n\t\t\t\t  : Z8536_PAB_MODE_PMS_OR;\n\n\t\tval = z8536_read(dev, Z8536_PA_MODE_REG);\n\t\tval &= ~Z8536_PAB_MODE_PMS_MASK;\n\t\tval |= (pa_mode | Z8536_PAB_MODE_IMO);\n\t\tz8536_write(dev, val, Z8536_PA_MODE_REG);\n\n\t\tz8536_write(dev, Z8536_CMD_SET_IE, Z8536_PA_CMDSTAT_REG);\n\n\t\tvalid_trig = true;\n\n\t\tdev_dbg(dev->class_dev,\n\t\t\t\"Port A configured for %s mode pattern detection\\n\",\n\t\t\tpa_trig ? \"AND\" : \"OR\");\n\t}\n\n\t \n\tif (devpriv->pm[pb_trig] & 0xff00) {\n\t\tpb_mode = pb_trig ? Z8536_PAB_MODE_PMS_AND\n\t\t\t\t  : Z8536_PAB_MODE_PMS_OR;\n\n\t\tval = z8536_read(dev, Z8536_PB_MODE_REG);\n\t\tval &= ~Z8536_PAB_MODE_PMS_MASK;\n\t\tval |= (pb_mode | Z8536_PAB_MODE_IMO);\n\t\tz8536_write(dev, val, Z8536_PB_MODE_REG);\n\n\t\tz8536_write(dev, Z8536_CMD_SET_IE, Z8536_PB_CMDSTAT_REG);\n\n\t\tvalid_trig = true;\n\n\t\tdev_dbg(dev->class_dev,\n\t\t\t\"Port B configured for %s mode pattern detection\\n\",\n\t\t\tpb_trig ? \"AND\" : \"OR\");\n\t}\n\n\t \n\tapci1500_port_enable(dev, true);\n\n\tif (!valid_trig) {\n\t\tdev_dbg(dev->class_dev,\n\t\t\t\"digital trigger %d is not configured\\n\", trig_num);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tz8536_write(dev, Z8536_INT_CTRL_MIE | Z8536_INT_CTRL_DLC,\n\t\t    Z8536_INT_CTRL_REG);\n\n\treturn 0;\n}\n\nstatic int apci1500_di_cmd(struct comedi_device *dev,\n\t\t\t   struct comedi_subdevice *s)\n{\n\ts->async->inttrig = apci1500_di_inttrig_start;\n\n\treturn 0;\n}\n\nstatic int apci1500_di_cmdtest(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       struct comedi_cmd *cmd)\n{\n\tint err = 0;\n\n\t \n\n\terr |= comedi_check_trigger_src(&cmd->start_src, TRIG_INT);\n\terr |= comedi_check_trigger_src(&cmd->scan_begin_src, TRIG_EXT);\n\terr |= comedi_check_trigger_src(&cmd->convert_src, TRIG_FOLLOW);\n\terr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\n\terr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_NONE);\n\n\tif (err)\n\t\treturn 1;\n\n\t \n\t \n\n\t \n\n\t \n\terr |= comedi_check_trigger_arg_max(&cmd->start_arg, 3);\n\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);\n\terr |= comedi_check_trigger_arg_is(&cmd->convert_arg, 0);\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\n\t\t\t\t\t   cmd->chanlist_len);\n\terr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\n\n\tif (err)\n\t\treturn 3;\n\n\t \n\n\t \n\n\treturn 0;\n}\n\n \nstatic int apci1500_di_cfg_trig(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tstruct comedi_insn *insn,\n\t\t\t\tunsigned int *data)\n{\n\tstruct apci1500_private *devpriv = dev->private;\n\tunsigned int trig = data[1];\n\tunsigned int shift = data[3];\n\tunsigned int hi_mask;\n\tunsigned int lo_mask;\n\tunsigned int chan_mask;\n\tunsigned int old_mask;\n\tunsigned int pm;\n\tunsigned int pt;\n\tunsigned int pp;\n\tunsigned int invalid_chan;\n\n\tif (trig > 1) {\n\t\tdev_dbg(dev->class_dev,\n\t\t\t\"invalid digital trigger number (0=AND, 1=OR)\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (shift <= 16) {\n\t\thi_mask = data[4] << shift;\n\t\tlo_mask = data[5] << shift;\n\t\told_mask = (1U << shift) - 1;\n\t\tinvalid_chan = (data[4] | data[5]) >> (16 - shift);\n\t} else {\n\t\thi_mask = 0;\n\t\tlo_mask = 0;\n\t\told_mask = 0xffff;\n\t\tinvalid_chan = data[4] | data[5];\n\t}\n\tchan_mask = hi_mask | lo_mask;\n\n\tif (invalid_chan) {\n\t\tdev_dbg(dev->class_dev, \"invalid digital trigger channel\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpm = devpriv->pm[trig] & old_mask;\n\tpt = devpriv->pt[trig] & old_mask;\n\tpp = devpriv->pp[trig] & old_mask;\n\n\tswitch (data[2]) {\n\tcase COMEDI_DIGITAL_TRIG_DISABLE:\n\t\t \n\t\tpm = 0;\n\t\tpt = 0;\n\t\tpp = 0;\n\t\tbreak;\n\tcase COMEDI_DIGITAL_TRIG_ENABLE_EDGES:\n\t\tpm |= chan_mask;\t \n\t\tpt |= chan_mask;\t \n\t\tpp |= hi_mask;\t\t \n\t\tpp &= ~lo_mask;\t\t \n\t\tbreak;\n\tcase COMEDI_DIGITAL_TRIG_ENABLE_LEVELS:\n\t\tpm |= chan_mask;\t \n\t\tpt &= ~chan_mask;\t \n\t\tpp |= hi_mask;\t\t \n\t\tpp &= ~lo_mask;\t\t \n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (trig == 0) {\n\t\tint ret = 0;\n\t\tunsigned int src;\n\n\t\tsrc = pt & 0xff;\n\t\tif (src)\n\t\t\tret |= comedi_check_trigger_is_unique(src);\n\n\t\tsrc = (pt >> 8) & 0xff;\n\t\tif (src)\n\t\t\tret |= comedi_check_trigger_is_unique(src);\n\n\t\tif (ret) {\n\t\t\tdev_dbg(dev->class_dev,\n\t\t\t\t\"invalid AND trigger configuration\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tdevpriv->pm[trig] = pm;\n\tdevpriv->pt[trig] = pt;\n\tdevpriv->pp[trig] = pp;\n\n\treturn insn->n;\n}\n\nstatic int apci1500_di_insn_config(struct comedi_device *dev,\n\t\t\t\t   struct comedi_subdevice *s,\n\t\t\t\t   struct comedi_insn *insn,\n\t\t\t\t   unsigned int *data)\n{\n\tswitch (data[0]) {\n\tcase INSN_CONFIG_DIGITAL_TRIG:\n\t\treturn apci1500_di_cfg_trig(dev, s, insn, data);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int apci1500_di_insn_bits(struct comedi_device *dev,\n\t\t\t\t struct comedi_subdevice *s,\n\t\t\t\t struct comedi_insn *insn,\n\t\t\t\t unsigned int *data)\n{\n\tstruct apci1500_private *devpriv = dev->private;\n\n\tdata[1] = inw(devpriv->addon + APCI1500_DI_REG);\n\n\treturn insn->n;\n}\n\nstatic int apci1500_do_insn_bits(struct comedi_device *dev,\n\t\t\t\t struct comedi_subdevice *s,\n\t\t\t\t struct comedi_insn *insn,\n\t\t\t\t unsigned int *data)\n{\n\tstruct apci1500_private *devpriv = dev->private;\n\n\tif (comedi_dio_update_state(s, data))\n\t\toutw(s->state, devpriv->addon + APCI1500_DO_REG);\n\n\tdata[1] = s->state;\n\n\treturn insn->n;\n}\n\nstatic int apci1500_timer_insn_config(struct comedi_device *dev,\n\t\t\t\t      struct comedi_subdevice *s,\n\t\t\t\t      struct comedi_insn *insn,\n\t\t\t\t      unsigned int *data)\n{\n\tstruct apci1500_private *devpriv = dev->private;\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int val;\n\n\tswitch (data[0]) {\n\tcase INSN_CONFIG_ARM:\n\t\tval = data[1] & s->maxdata;\n\t\tz8536_write(dev, val & 0xff, Z8536_CT_RELOAD_LSB_REG(chan));\n\t\tz8536_write(dev, (val >> 8) & 0xff,\n\t\t\t    Z8536_CT_RELOAD_MSB_REG(chan));\n\n\t\tapci1500_timer_enable(dev, chan, true);\n\t\tz8536_write(dev, Z8536_CT_CMDSTAT_GCB,\n\t\t\t    Z8536_CT_CMDSTAT_REG(chan));\n\t\tbreak;\n\tcase INSN_CONFIG_DISARM:\n\t\tapci1500_timer_enable(dev, chan, false);\n\t\tbreak;\n\n\tcase INSN_CONFIG_GET_COUNTER_STATUS:\n\t\tdata[1] = 0;\n\t\tval = z8536_read(dev, Z8536_CT_CMDSTAT_REG(chan));\n\t\tif (val & Z8536_CT_STAT_CIP)\n\t\t\tdata[1] |= COMEDI_COUNTER_COUNTING;\n\t\tif (val & Z8536_CT_CMDSTAT_GCB)\n\t\t\tdata[1] |= COMEDI_COUNTER_ARMED;\n\t\tif (val & Z8536_STAT_IP) {\n\t\t\tdata[1] |= COMEDI_COUNTER_TERMINAL_COUNT;\n\t\t\tapci1500_ack_irq(dev, Z8536_CT_CMDSTAT_REG(chan));\n\t\t}\n\t\tdata[2] = COMEDI_COUNTER_ARMED | COMEDI_COUNTER_COUNTING |\n\t\t\t  COMEDI_COUNTER_TERMINAL_COUNT;\n\t\tbreak;\n\n\tcase INSN_CONFIG_SET_COUNTER_MODE:\n\t\t \n\t\tswitch (data[1]) {\n\t\tcase I8254_MODE0:\n\t\t\t \n\t\t\tval = Z8536_CT_MODE_ECE |\n\t\t\t      Z8536_CT_MODE_DCS_ONESHOT;\n\t\t\tbreak;\n\t\tcase I8254_MODE1:\n\t\t\t \n\t\t\tval = Z8536_CT_MODE_ETE |\n\t\t\t      Z8536_CT_MODE_DCS_ONESHOT;\n\t\t\tbreak;\n\t\tcase I8254_MODE2:\n\t\t\t \n\t\t\tval = Z8536_CT_MODE_CSC |\n\t\t\t      Z8536_CT_MODE_DCS_PULSE;\n\t\t\tbreak;\n\t\tcase I8254_MODE3:\n\t\t\t \n\t\t\tval = Z8536_CT_MODE_CSC |\n\t\t\t      Z8536_CT_MODE_DCS_SQRWAVE;\n\t\t\tbreak;\n\t\tcase I8254_MODE4:\n\t\t\t \n\t\t\tval = Z8536_CT_MODE_REB |\n\t\t\t      Z8536_CT_MODE_DCS_PULSE;\n\t\t\tbreak;\n\t\tcase I8254_MODE5:\n\t\t\t \n\t\t\tval = Z8536_CT_MODE_EOE |\n\t\t\t      Z8536_CT_MODE_ETE |\n\t\t\t      Z8536_CT_MODE_REB |\n\t\t\t      Z8536_CT_MODE_DCS_PULSE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tapci1500_timer_enable(dev, chan, false);\n\t\tz8536_write(dev, val, Z8536_CT_MODE_REG(chan));\n\t\tbreak;\n\n\tcase INSN_CONFIG_SET_CLOCK_SRC:\n\t\tif (data[1] > 2)\n\t\t\treturn -EINVAL;\n\t\tdevpriv->clk_src = data[1];\n\t\tif (devpriv->clk_src == 2)\n\t\t\tdevpriv->clk_src = 3;\n\t\toutw(devpriv->clk_src, devpriv->addon + APCI1500_CLK_SEL_REG);\n\t\tbreak;\n\tcase INSN_CONFIG_GET_CLOCK_SRC:\n\t\tswitch (devpriv->clk_src) {\n\t\tcase 0:\n\t\t\tdata[1] = 0;\t\t \n\t\t\tdata[2] = 17879;\t \n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tdata[1] = 1;\t\t \n\t\t\tdata[2] = 573066;\t \n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tdata[1] = 2;\t\t \n\t\t\tdata[2] = 1164822;\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\n\tcase INSN_CONFIG_SET_GATE_SRC:\n\t\tif (chan == 0)\n\t\t\treturn -EINVAL;\n\n\t\tval = z8536_read(dev, Z8536_CT_MODE_REG(chan));\n\t\tval &= Z8536_CT_MODE_EGE;\n\t\tif (data[1] == 1)\n\t\t\tval |= Z8536_CT_MODE_EGE;\n\t\telse if (data[1] > 1)\n\t\t\treturn -EINVAL;\n\t\tz8536_write(dev, val, Z8536_CT_MODE_REG(chan));\n\t\tbreak;\n\tcase INSN_CONFIG_GET_GATE_SRC:\n\t\tif (chan == 0)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn insn->n;\n}\n\nstatic int apci1500_timer_insn_write(struct comedi_device *dev,\n\t\t\t\t     struct comedi_subdevice *s,\n\t\t\t\t     struct comedi_insn *insn,\n\t\t\t\t     unsigned int *data)\n{\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int cmd;\n\n\tcmd = z8536_read(dev, Z8536_CT_CMDSTAT_REG(chan));\n\tcmd &= Z8536_CT_CMDSTAT_GCB;\t \n\tcmd |= Z8536_CT_CMD_TCB;\t \n\n\t \n\tif (insn->n)\n\t\tz8536_write(dev, cmd, Z8536_CT_CMDSTAT_REG(chan));\n\n\treturn insn->n;\n}\n\nstatic int apci1500_timer_insn_read(struct comedi_device *dev,\n\t\t\t\t    struct comedi_subdevice *s,\n\t\t\t\t    struct comedi_insn *insn,\n\t\t\t\t    unsigned int *data)\n{\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int cmd;\n\tunsigned int val;\n\tint i;\n\n\tcmd = z8536_read(dev, Z8536_CT_CMDSTAT_REG(chan));\n\tcmd &= Z8536_CT_CMDSTAT_GCB;\t \n\tcmd |= Z8536_CT_CMD_RCC;\t \n\n\tfor (i = 0; i < insn->n; i++) {\n\t\tz8536_write(dev, cmd, Z8536_CT_CMDSTAT_REG(chan));\n\n\t\tval = z8536_read(dev, Z8536_CT_VAL_MSB_REG(chan)) << 8;\n\t\tval |= z8536_read(dev, Z8536_CT_VAL_LSB_REG(chan));\n\n\t\tdata[i] = val;\n\t}\n\n\treturn insn->n;\n}\n\nstatic int apci1500_auto_attach(struct comedi_device *dev,\n\t\t\t\tunsigned long context)\n{\n\tstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\n\tstruct apci1500_private *devpriv;\n\tstruct comedi_subdevice *s;\n\tint ret;\n\n\tdevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\n\tif (!devpriv)\n\t\treturn -ENOMEM;\n\n\tret = comedi_pci_enable(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tdev->iobase = pci_resource_start(pcidev, 1);\n\tdevpriv->amcc = pci_resource_start(pcidev, 0);\n\tdevpriv->addon = pci_resource_start(pcidev, 2);\n\n\tz8536_reset(dev);\n\n\tif (pcidev->irq > 0) {\n\t\tret = request_irq(pcidev->irq, apci1500_interrupt, IRQF_SHARED,\n\t\t\t\t  dev->board_name, dev);\n\t\tif (ret == 0)\n\t\t\tdev->irq = pcidev->irq;\n\t}\n\n\tret = comedi_alloc_subdevices(dev, 3);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ts = &dev->subdevices[0];\n\ts->type\t\t= COMEDI_SUBD_DI;\n\ts->subdev_flags\t= SDF_READABLE;\n\ts->n_chan\t= 16;\n\ts->maxdata\t= 1;\n\ts->range_table\t= &range_digital;\n\ts->insn_bits\t= apci1500_di_insn_bits;\n\tif (dev->irq) {\n\t\tdev->read_subdev = s;\n\t\ts->subdev_flags |= SDF_CMD_READ;\n\t\ts->len_chanlist\t= 1;\n\t\ts->insn_config\t= apci1500_di_insn_config;\n\t\ts->do_cmdtest\t= apci1500_di_cmdtest;\n\t\ts->do_cmd\t= apci1500_di_cmd;\n\t\ts->cancel\t= apci1500_di_cancel;\n\t}\n\n\t \n\ts = &dev->subdevices[1];\n\ts->type\t\t= COMEDI_SUBD_DO;\n\ts->subdev_flags\t= SDF_WRITABLE;\n\ts->n_chan\t= 16;\n\ts->maxdata\t= 1;\n\ts->range_table\t= &range_digital;\n\ts->insn_bits\t= apci1500_do_insn_bits;\n\n\t \n\toutw(0x0, devpriv->addon + APCI1500_DO_REG);\n\n\t \n\ts = &dev->subdevices[2];\n\ts->type\t\t= COMEDI_SUBD_TIMER;\n\ts->subdev_flags\t= SDF_WRITABLE | SDF_READABLE;\n\ts->n_chan\t= 3;\n\ts->maxdata\t= 0xffff;\n\ts->range_table\t= &range_unknown;\n\ts->insn_config\t= apci1500_timer_insn_config;\n\ts->insn_write\t= apci1500_timer_insn_write;\n\ts->insn_read\t= apci1500_timer_insn_read;\n\n\t \n\tif (dev->irq) {\n\t\toutl(0x2000 | INTCSR_INBOX_FULL_INT,\n\t\t     devpriv->amcc + AMCC_OP_REG_INTCSR);\n\t\tinl(devpriv->amcc + AMCC_OP_REG_IMB1);\n\t\tinl(devpriv->amcc + AMCC_OP_REG_INTCSR);\n\t\toutl(INTCSR_INBOX_INTR_STATUS | 0x2000 | INTCSR_INBOX_FULL_INT,\n\t\t     devpriv->amcc + AMCC_OP_REG_INTCSR);\n\t}\n\n\treturn 0;\n}\n\nstatic void apci1500_detach(struct comedi_device *dev)\n{\n\tstruct apci1500_private *devpriv = dev->private;\n\n\tif (devpriv->amcc)\n\t\toutl(0x0, devpriv->amcc + AMCC_OP_REG_INTCSR);\n\tcomedi_pci_detach(dev);\n}\n\nstatic struct comedi_driver apci1500_driver = {\n\t.driver_name\t= \"addi_apci_1500\",\n\t.module\t\t= THIS_MODULE,\n\t.auto_attach\t= apci1500_auto_attach,\n\t.detach\t\t= apci1500_detach,\n};\n\nstatic int apci1500_pci_probe(struct pci_dev *dev,\n\t\t\t      const struct pci_device_id *id)\n{\n\treturn comedi_pci_auto_config(dev, &apci1500_driver, id->driver_data);\n}\n\nstatic const struct pci_device_id apci1500_pci_table[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMCC, 0x80fc) },\n\t{ 0 }\n};\nMODULE_DEVICE_TABLE(pci, apci1500_pci_table);\n\nstatic struct pci_driver apci1500_pci_driver = {\n\t.name\t\t= \"addi_apci_1500\",\n\t.id_table\t= apci1500_pci_table,\n\t.probe\t\t= apci1500_pci_probe,\n\t.remove\t\t= comedi_pci_auto_unconfig,\n};\nmodule_comedi_pci_driver(apci1500_driver, apci1500_pci_driver);\n\nMODULE_AUTHOR(\"Comedi https://www.comedi.org\");\nMODULE_DESCRIPTION(\"ADDI-DATA APCI-1500, 16 channel DI / 16 channel DO boards\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}