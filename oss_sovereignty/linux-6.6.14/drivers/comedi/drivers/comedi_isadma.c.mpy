{
  "module_name": "comedi_isadma.c",
  "hash_id": "115bb15f06e55b01b4a0ad060b3137a9566ea12e8ec74b5c4d107e98464f0aac",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/comedi_isadma.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/isa-dma.h>\n#include <linux/comedi/comedidev.h>\n#include <linux/comedi/comedi_isadma.h>\n\n \nvoid comedi_isadma_program(struct comedi_isadma_desc *desc)\n{\n\tunsigned long flags;\n\n\tflags = claim_dma_lock();\n\tclear_dma_ff(desc->chan);\n\tset_dma_mode(desc->chan, desc->mode);\n\tset_dma_addr(desc->chan, desc->hw_addr);\n\tset_dma_count(desc->chan, desc->size);\n\tenable_dma(desc->chan);\n\trelease_dma_lock(flags);\n}\nEXPORT_SYMBOL_GPL(comedi_isadma_program);\n\n \nunsigned int comedi_isadma_disable(unsigned int dma_chan)\n{\n\tunsigned long flags;\n\tunsigned int residue;\n\n\tflags = claim_dma_lock();\n\tdisable_dma(dma_chan);\n\tresidue = get_dma_residue(dma_chan);\n\trelease_dma_lock(flags);\n\n\treturn residue;\n}\nEXPORT_SYMBOL_GPL(comedi_isadma_disable);\n\n \nunsigned int comedi_isadma_disable_on_sample(unsigned int dma_chan,\n\t\t\t\t\t     unsigned int size)\n{\n\tint stalled = 0;\n\tunsigned long flags;\n\tunsigned int residue;\n\tunsigned int new_residue;\n\n\tresidue = comedi_isadma_disable(dma_chan);\n\twhile (residue % size) {\n\t\t \n\t\tflags = claim_dma_lock();\n\t\tenable_dma(dma_chan);\n\t\trelease_dma_lock(flags);\n\n\t\tudelay(2);\n\t\tnew_residue = comedi_isadma_disable(dma_chan);\n\n\t\t \n\t\tif (new_residue == residue) {\n\t\t\tstalled++;\n\t\t\tif (stalled > 10)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tresidue = new_residue;\n\t\t\tstalled = 0;\n\t\t}\n\t}\n\treturn residue;\n}\nEXPORT_SYMBOL_GPL(comedi_isadma_disable_on_sample);\n\n \nunsigned int comedi_isadma_poll(struct comedi_isadma *dma)\n{\n\tstruct comedi_isadma_desc *desc = &dma->desc[dma->cur_dma];\n\tunsigned long flags;\n\tunsigned int result;\n\tunsigned int result1;\n\n\tflags = claim_dma_lock();\n\tclear_dma_ff(desc->chan);\n\tif (!isa_dma_bridge_buggy)\n\t\tdisable_dma(desc->chan);\n\tresult = get_dma_residue(desc->chan);\n\t \n\tresult1 = get_dma_residue(desc->chan);\n\tif (!isa_dma_bridge_buggy)\n\t\tenable_dma(desc->chan);\n\trelease_dma_lock(flags);\n\n\tif (result < result1)\n\t\tresult = result1;\n\tif (result >= desc->size || result == 0)\n\t\treturn 0;\n\treturn desc->size - result;\n}\nEXPORT_SYMBOL_GPL(comedi_isadma_poll);\n\n \nvoid comedi_isadma_set_mode(struct comedi_isadma_desc *desc, char dma_dir)\n{\n\tdesc->mode = (dma_dir == COMEDI_ISADMA_READ) ? DMA_MODE_READ\n\t\t\t\t\t\t     : DMA_MODE_WRITE;\n}\nEXPORT_SYMBOL_GPL(comedi_isadma_set_mode);\n\n \nstruct comedi_isadma *comedi_isadma_alloc(struct comedi_device *dev,\n\t\t\t\t\t  int n_desc, unsigned int dma_chan1,\n\t\t\t\t\t  unsigned int dma_chan2,\n\t\t\t\t\t  unsigned int maxsize, char dma_dir)\n{\n\tstruct comedi_isadma *dma = NULL;\n\tstruct comedi_isadma_desc *desc;\n\tunsigned int dma_chans[2];\n\tint i;\n\n\tif (n_desc < 1 || n_desc > 2)\n\t\tgoto no_dma;\n\n\tdma = kzalloc(sizeof(*dma), GFP_KERNEL);\n\tif (!dma)\n\t\tgoto no_dma;\n\n\tdesc = kcalloc(n_desc, sizeof(*desc), GFP_KERNEL);\n\tif (!desc)\n\t\tgoto no_dma;\n\tdma->desc = desc;\n\tdma->n_desc = n_desc;\n\tif (dev->hw_dev) {\n\t\tdma->dev = dev->hw_dev;\n\t} else {\n\t\t \n\t\tif (!dev->class_dev)\n\t\t\tgoto no_dma;\n\t\t \n\t\tif (dma_coerce_mask_and_coherent(dev->class_dev,\n\t\t\t\t\t\t DMA_BIT_MASK(24))) {\n\t\t\tgoto no_dma;\n\t\t}\n\t\tdma->dev = dev->class_dev;\n\t}\n\n\tdma_chans[0] = dma_chan1;\n\tif (dma_chan2 == 0 || dma_chan2 == dma_chan1)\n\t\tdma_chans[1] = dma_chan1;\n\telse\n\t\tdma_chans[1] = dma_chan2;\n\n\tif (request_dma(dma_chans[0], dev->board_name))\n\t\tgoto no_dma;\n\tdma->chan = dma_chans[0];\n\tif (dma_chans[1] != dma_chans[0]) {\n\t\tif (request_dma(dma_chans[1], dev->board_name))\n\t\t\tgoto no_dma;\n\t}\n\tdma->chan2 = dma_chans[1];\n\n\tfor (i = 0; i < n_desc; i++) {\n\t\tdesc = &dma->desc[i];\n\t\tdesc->chan = dma_chans[i];\n\t\tdesc->maxsize = maxsize;\n\t\tdesc->virt_addr = dma_alloc_coherent(dma->dev, desc->maxsize,\n\t\t\t\t\t\t     &desc->hw_addr,\n\t\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!desc->virt_addr)\n\t\t\tgoto no_dma;\n\t\tcomedi_isadma_set_mode(desc, dma_dir);\n\t}\n\n\treturn dma;\n\nno_dma:\n\tcomedi_isadma_free(dma);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(comedi_isadma_alloc);\n\n \nvoid comedi_isadma_free(struct comedi_isadma *dma)\n{\n\tstruct comedi_isadma_desc *desc;\n\tint i;\n\n\tif (!dma)\n\t\treturn;\n\n\tif (dma->desc) {\n\t\tfor (i = 0; i < dma->n_desc; i++) {\n\t\t\tdesc = &dma->desc[i];\n\t\t\tif (desc->virt_addr)\n\t\t\t\tdma_free_coherent(dma->dev, desc->maxsize,\n\t\t\t\t\t\t  desc->virt_addr,\n\t\t\t\t\t\t  desc->hw_addr);\n\t\t}\n\t\tkfree(dma->desc);\n\t}\n\tif (dma->chan2 && dma->chan2 != dma->chan)\n\t\tfree_dma(dma->chan2);\n\tif (dma->chan)\n\t\tfree_dma(dma->chan);\n\tkfree(dma);\n}\nEXPORT_SYMBOL_GPL(comedi_isadma_free);\n\nstatic int __init comedi_isadma_init(void)\n{\n\treturn 0;\n}\nmodule_init(comedi_isadma_init);\n\nstatic void __exit comedi_isadma_exit(void)\n{\n}\nmodule_exit(comedi_isadma_exit);\n\nMODULE_AUTHOR(\"H Hartley Sweeten <hsweeten@visionengravers.com>\");\nMODULE_DESCRIPTION(\"Comedi ISA DMA support\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}