{
  "module_name": "dt9812.c",
  "hash_id": "4fee9bc36270ed3668a908740d37c4ad71274d2f4ee361f87baeca13860619af",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/dt9812.c",
  "human_readable_source": "\n \n\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/comedi/comedi_usb.h>\n\n#define DT9812_DIAGS_BOARD_INFO_ADDR\t0xFBFF\n#define DT9812_MAX_WRITE_CMD_PIPE_SIZE\t32\n#define DT9812_MAX_READ_CMD_PIPE_SIZE\t32\n\n \n#define DT9812_USB_TIMEOUT\t\t1000\n\n \n#define F020_SFR_P4\t\t\t0x84\n#define F020_SFR_P1\t\t\t0x90\n#define F020_SFR_P2\t\t\t0xa0\n#define F020_SFR_P3\t\t\t0xb0\n#define F020_SFR_AMX0CF\t\t\t0xba\n#define F020_SFR_AMX0SL\t\t\t0xbb\n#define F020_SFR_ADC0CF\t\t\t0xbc\n#define F020_SFR_ADC0L\t\t\t0xbe\n#define F020_SFR_ADC0H\t\t\t0xbf\n#define F020_SFR_DAC0L\t\t\t0xd2\n#define F020_SFR_DAC0H\t\t\t0xd3\n#define F020_SFR_DAC0CN\t\t\t0xd4\n#define F020_SFR_DAC1L\t\t\t0xd5\n#define F020_SFR_DAC1H\t\t\t0xd6\n#define F020_SFR_DAC1CN\t\t\t0xd7\n#define F020_SFR_ADC0CN\t\t\t0xe8\n\n#define F020_MASK_ADC0CF_AMP0GN0\t0x01\n#define F020_MASK_ADC0CF_AMP0GN1\t0x02\n#define F020_MASK_ADC0CF_AMP0GN2\t0x04\n\n#define F020_MASK_ADC0CN_AD0EN\t\t0x80\n#define F020_MASK_ADC0CN_AD0INT\t\t0x20\n#define F020_MASK_ADC0CN_AD0BUSY\t0x10\n\n#define F020_MASK_DACXCN_DACXEN\t\t0x80\n\nenum {\n\t\t\t\t\t \n\tDT9812_DEVID_DT9812_10,\t\t \n\tDT9812_DEVID_DT9812_2PT5,\t \n};\n\nenum dt9812_gain {\n\tDT9812_GAIN_0PT25 = 1,\n\tDT9812_GAIN_0PT5 = 2,\n\tDT9812_GAIN_1 = 4,\n\tDT9812_GAIN_2 = 8,\n\tDT9812_GAIN_4 = 16,\n\tDT9812_GAIN_8 = 32,\n\tDT9812_GAIN_16 = 64,\n};\n\nenum {\n\tDT9812_LEAST_USB_FIRMWARE_CMD_CODE = 0,\n\t \n\tDT9812_W_FLASH_DATA = 0,\n\t \n\tDT9812_R_FLASH_DATA = 1,\n\n\t \n\n\t \n\tDT9812_R_SINGLE_BYTE_REG = 2,\n\t \n\tDT9812_W_SINGLE_BYTE_REG = 3,\n\t \n\tDT9812_R_MULTI_BYTE_REG = 4,\n\t \n\tDT9812_W_MULTI_BYTE_REG = 5,\n\t \n\tDT9812_RMW_SINGLE_BYTE_REG = 6,\n\t \n\tDT9812_RMW_MULTI_BYTE_REG = 7,\n\n\t \n\n\t \n\tDT9812_R_SINGLE_BYTE_SMBUS = 8,\n\t \n\tDT9812_W_SINGLE_BYTE_SMBUS = 9,\n\t \n\tDT9812_R_MULTI_BYTE_SMBUS = 10,\n\t \n\tDT9812_W_MULTI_BYTE_SMBUS = 11,\n\n\t \n\n\t \n\tDT9812_R_SINGLE_BYTE_DEV = 12,\n\t \n\tDT9812_W_SINGLE_BYTE_DEV = 13,\n\t \n\tDT9812_R_MULTI_BYTE_DEV = 14,\n\t \n\tDT9812_W_MULTI_BYTE_DEV = 15,\n\n\t \n\tDT9812_W_DAC_THRESHOLD = 16,\n\n\t \n\tDT9812_W_INT_ON_CHANGE_MASK = 17,\n\n\t \n\tDT9812_W_CGL = 18,\n\t \n\tDT9812_R_MULTI_BYTE_USBMEM = 19,\n\t \n\tDT9812_W_MULTI_BYTE_USBMEM = 20,\n\n\t \n\tDT9812_START_SUBSYSTEM = 21,\n\t \n\tDT9812_STOP_SUBSYSTEM = 22,\n\n\t \n\tDT9812_CALIBRATE_POT = 23,\n\t \n\tDT9812_W_DAC_FIFO_SIZE = 24,\n\t \n\tDT9812_W_CGL_DAC = 25,\n\t \n\tDT9812_R_SINGLE_VALUE_CMD = 26,\n\t \n\tDT9812_W_SINGLE_VALUE_CMD = 27,\n\t \n\tDT9812_MAX_USB_FIRMWARE_CMD_CODE,\n};\n\nstruct dt9812_flash_data {\n\t__le16 numbytes;\n\t__le16 address;\n};\n\n#define DT9812_MAX_NUM_MULTI_BYTE_RDS  \\\n\t((DT9812_MAX_WRITE_CMD_PIPE_SIZE - 4 - 1) / sizeof(u8))\n\nstruct dt9812_read_multi {\n\tu8 count;\n\tu8 address[DT9812_MAX_NUM_MULTI_BYTE_RDS];\n};\n\nstruct dt9812_write_byte {\n\tu8 address;\n\tu8 value;\n};\n\n#define DT9812_MAX_NUM_MULTI_BYTE_WRTS  \\\n\t((DT9812_MAX_WRITE_CMD_PIPE_SIZE - 4 - 1) / \\\n\t sizeof(struct dt9812_write_byte))\n\nstruct dt9812_write_multi {\n\tu8 count;\n\tstruct dt9812_write_byte write[DT9812_MAX_NUM_MULTI_BYTE_WRTS];\n};\n\nstruct dt9812_rmw_byte {\n\tu8 address;\n\tu8 and_mask;\n\tu8 or_value;\n};\n\n#define DT9812_MAX_NUM_MULTI_BYTE_RMWS  \\\n\t((DT9812_MAX_WRITE_CMD_PIPE_SIZE - 4 - 1) / \\\n\t sizeof(struct dt9812_rmw_byte))\n\nstruct dt9812_rmw_multi {\n\tu8 count;\n\tstruct dt9812_rmw_byte rmw[DT9812_MAX_NUM_MULTI_BYTE_RMWS];\n};\n\nstruct dt9812_usb_cmd {\n\t__le32 cmd;\n\tunion {\n\t\tstruct dt9812_flash_data flash_data_info;\n\t\tstruct dt9812_read_multi read_multi_info;\n\t\tstruct dt9812_write_multi write_multi_info;\n\t\tstruct dt9812_rmw_multi rmw_multi_info;\n\t} u;\n};\n\nstruct dt9812_private {\n\tstruct mutex mut;\n\tstruct {\n\t\t__u8 addr;\n\t\tsize_t size;\n\t} cmd_wr, cmd_rd;\n\tu16 device;\n};\n\nstatic int dt9812_read_info(struct comedi_device *dev,\n\t\t\t    int offset, void *buf, size_t buf_size)\n{\n\tstruct usb_device *usb = comedi_to_usb_dev(dev);\n\tstruct dt9812_private *devpriv = dev->private;\n\tstruct dt9812_usb_cmd *cmd;\n\tsize_t tbuf_size;\n\tint count, ret;\n\tvoid *tbuf;\n\n\ttbuf_size = max(sizeof(*cmd), buf_size);\n\n\ttbuf = kzalloc(tbuf_size, GFP_KERNEL);\n\tif (!tbuf)\n\t\treturn -ENOMEM;\n\n\tcmd = tbuf;\n\n\tcmd->cmd = cpu_to_le32(DT9812_R_FLASH_DATA);\n\tcmd->u.flash_data_info.address =\n\t    cpu_to_le16(DT9812_DIAGS_BOARD_INFO_ADDR + offset);\n\tcmd->u.flash_data_info.numbytes = cpu_to_le16(buf_size);\n\n\t \n\tret = usb_bulk_msg(usb, usb_sndbulkpipe(usb, devpriv->cmd_wr.addr),\n\t\t\t   cmd, sizeof(*cmd), &count, DT9812_USB_TIMEOUT);\n\tif (ret)\n\t\tgoto out;\n\n\tret = usb_bulk_msg(usb, usb_rcvbulkpipe(usb, devpriv->cmd_rd.addr),\n\t\t\t   tbuf, buf_size, &count, DT9812_USB_TIMEOUT);\n\tif (!ret) {\n\t\tif (count == buf_size)\n\t\t\tmemcpy(buf, tbuf, buf_size);\n\t\telse\n\t\t\tret = -EREMOTEIO;\n\t}\nout:\n\tkfree(tbuf);\n\n\treturn ret;\n}\n\nstatic int dt9812_read_multiple_registers(struct comedi_device *dev,\n\t\t\t\t\t  int reg_count, u8 *address,\n\t\t\t\t\t  u8 *value)\n{\n\tstruct usb_device *usb = comedi_to_usb_dev(dev);\n\tstruct dt9812_private *devpriv = dev->private;\n\tstruct dt9812_usb_cmd *cmd;\n\tint i, count, ret;\n\tsize_t buf_size;\n\tvoid *buf;\n\n\tbuf_size = max_t(size_t, sizeof(*cmd), reg_count);\n\n\tbuf = kzalloc(buf_size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tcmd = buf;\n\n\tcmd->cmd = cpu_to_le32(DT9812_R_MULTI_BYTE_REG);\n\tcmd->u.read_multi_info.count = reg_count;\n\tfor (i = 0; i < reg_count; i++)\n\t\tcmd->u.read_multi_info.address[i] = address[i];\n\n\t \n\tret = usb_bulk_msg(usb, usb_sndbulkpipe(usb, devpriv->cmd_wr.addr),\n\t\t\t   cmd, sizeof(*cmd), &count, DT9812_USB_TIMEOUT);\n\tif (ret)\n\t\tgoto out;\n\n\tret = usb_bulk_msg(usb, usb_rcvbulkpipe(usb, devpriv->cmd_rd.addr),\n\t\t\t   buf, reg_count, &count, DT9812_USB_TIMEOUT);\n\tif (!ret) {\n\t\tif (count == reg_count)\n\t\t\tmemcpy(value, buf, reg_count);\n\t\telse\n\t\t\tret = -EREMOTEIO;\n\t}\nout:\n\tkfree(buf);\n\n\treturn ret;\n}\n\nstatic int dt9812_write_multiple_registers(struct comedi_device *dev,\n\t\t\t\t\t   int reg_count, u8 *address,\n\t\t\t\t\t   u8 *value)\n{\n\tstruct usb_device *usb = comedi_to_usb_dev(dev);\n\tstruct dt9812_private *devpriv = dev->private;\n\tstruct dt9812_usb_cmd *cmd;\n\tint i, count;\n\tint ret;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tcmd->cmd = cpu_to_le32(DT9812_W_MULTI_BYTE_REG);\n\tcmd->u.read_multi_info.count = reg_count;\n\tfor (i = 0; i < reg_count; i++) {\n\t\tcmd->u.write_multi_info.write[i].address = address[i];\n\t\tcmd->u.write_multi_info.write[i].value = value[i];\n\t}\n\n\t \n\tret = usb_bulk_msg(usb, usb_sndbulkpipe(usb, devpriv->cmd_wr.addr),\n\t\t\t   cmd, sizeof(*cmd), &count, DT9812_USB_TIMEOUT);\n\tkfree(cmd);\n\n\treturn ret;\n}\n\nstatic int dt9812_rmw_multiple_registers(struct comedi_device *dev,\n\t\t\t\t\t int reg_count,\n\t\t\t\t\t struct dt9812_rmw_byte *rmw)\n{\n\tstruct usb_device *usb = comedi_to_usb_dev(dev);\n\tstruct dt9812_private *devpriv = dev->private;\n\tstruct dt9812_usb_cmd *cmd;\n\tint i, count;\n\tint ret;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tcmd->cmd = cpu_to_le32(DT9812_RMW_MULTI_BYTE_REG);\n\tcmd->u.rmw_multi_info.count = reg_count;\n\tfor (i = 0; i < reg_count; i++)\n\t\tcmd->u.rmw_multi_info.rmw[i] = rmw[i];\n\n\t \n\tret = usb_bulk_msg(usb, usb_sndbulkpipe(usb, devpriv->cmd_wr.addr),\n\t\t\t   cmd, sizeof(*cmd), &count, DT9812_USB_TIMEOUT);\n\tkfree(cmd);\n\n\treturn ret;\n}\n\nstatic int dt9812_digital_in(struct comedi_device *dev, u8 *bits)\n{\n\tstruct dt9812_private *devpriv = dev->private;\n\tu8 reg[2] = { F020_SFR_P3, F020_SFR_P1 };\n\tu8 value[2];\n\tint ret;\n\n\tmutex_lock(&devpriv->mut);\n\tret = dt9812_read_multiple_registers(dev, 2, reg, value);\n\tif (ret == 0) {\n\t\t \n\t\t*bits = (value[0] & 0x7f) | ((value[1] & 0x08) << 4);\n\t}\n\tmutex_unlock(&devpriv->mut);\n\n\treturn ret;\n}\n\nstatic int dt9812_digital_out(struct comedi_device *dev, u8 bits)\n{\n\tstruct dt9812_private *devpriv = dev->private;\n\tu8 reg[1] = { F020_SFR_P2 };\n\tu8 value[1] = { bits };\n\tint ret;\n\n\tmutex_lock(&devpriv->mut);\n\tret = dt9812_write_multiple_registers(dev, 1, reg, value);\n\tmutex_unlock(&devpriv->mut);\n\n\treturn ret;\n}\n\nstatic void dt9812_configure_mux(struct comedi_device *dev,\n\t\t\t\t struct dt9812_rmw_byte *rmw, int channel)\n{\n\tstruct dt9812_private *devpriv = dev->private;\n\n\tif (devpriv->device == DT9812_DEVID_DT9812_10) {\n\t\t \n\t\trmw->address = F020_SFR_P1;\n\t\trmw->and_mask = 0xe0;\n\t\trmw->or_value = channel << 5;\n\t} else {\n\t\t \n\t\trmw->address = F020_SFR_AMX0SL;\n\t\trmw->and_mask = 0xff;\n\t\trmw->or_value = channel & 0x07;\n\t}\n}\n\nstatic void dt9812_configure_gain(struct comedi_device *dev,\n\t\t\t\t  struct dt9812_rmw_byte *rmw,\n\t\t\t\t  enum dt9812_gain gain)\n{\n\tstruct dt9812_private *devpriv = dev->private;\n\n\t \n\tif (devpriv->device == DT9812_DEVID_DT9812_10)\n\t\tgain <<= 1;\n\n\trmw->address = F020_SFR_ADC0CF;\n\trmw->and_mask = F020_MASK_ADC0CF_AMP0GN2 |\n\t\t\tF020_MASK_ADC0CF_AMP0GN1 |\n\t\t\tF020_MASK_ADC0CF_AMP0GN0;\n\n\tswitch (gain) {\n\t\t \n\tcase DT9812_GAIN_0PT5:\n\t\trmw->or_value = F020_MASK_ADC0CF_AMP0GN2 |\n\t\t\t\tF020_MASK_ADC0CF_AMP0GN1;\n\t\tbreak;\n\tdefault:\n\t\t \n\tcase DT9812_GAIN_1:\n\t\trmw->or_value = 0x00;\n\t\tbreak;\n\tcase DT9812_GAIN_2:\n\t\trmw->or_value = F020_MASK_ADC0CF_AMP0GN0;\n\t\tbreak;\n\tcase DT9812_GAIN_4:\n\t\trmw->or_value = F020_MASK_ADC0CF_AMP0GN1;\n\t\tbreak;\n\tcase DT9812_GAIN_8:\n\t\trmw->or_value = F020_MASK_ADC0CF_AMP0GN1 |\n\t\t\t\tF020_MASK_ADC0CF_AMP0GN0;\n\t\tbreak;\n\tcase DT9812_GAIN_16:\n\t\trmw->or_value = F020_MASK_ADC0CF_AMP0GN2;\n\t\tbreak;\n\t}\n}\n\nstatic int dt9812_analog_in(struct comedi_device *dev,\n\t\t\t    int channel, u16 *value, enum dt9812_gain gain)\n{\n\tstruct dt9812_private *devpriv = dev->private;\n\tstruct dt9812_rmw_byte rmw[3];\n\tu8 reg[3] = {\n\t\tF020_SFR_ADC0CN,\n\t\tF020_SFR_ADC0H,\n\t\tF020_SFR_ADC0L\n\t};\n\tu8 val[3];\n\tint ret;\n\n\tmutex_lock(&devpriv->mut);\n\n\t \n\tdt9812_configure_gain(dev, &rmw[0], gain);\n\n\t \n\tdt9812_configure_mux(dev, &rmw[1], channel);\n\n\t \n\trmw[2].address = F020_SFR_ADC0CN;\n\trmw[2].and_mask = 0xff;\n\trmw[2].or_value = F020_MASK_ADC0CN_AD0EN | F020_MASK_ADC0CN_AD0BUSY;\n\n\tret = dt9812_rmw_multiple_registers(dev, 3, rmw);\n\tif (ret)\n\t\tgoto exit;\n\n\t \n\tret = dt9812_read_multiple_registers(dev, 3, reg, val);\n\tif (ret)\n\t\tgoto exit;\n\n\t \n\tif ((val[0] & (F020_MASK_ADC0CN_AD0INT | F020_MASK_ADC0CN_AD0BUSY)) ==\n\t    F020_MASK_ADC0CN_AD0INT) {\n\t\tswitch (devpriv->device) {\n\t\tcase DT9812_DEVID_DT9812_10:\n\t\t\t \n\t\t\t*value = ((val[1] << 8) | val[2]) + 0x800;\n\t\t\tbreak;\n\t\tcase DT9812_DEVID_DT9812_2PT5:\n\t\t\t*value = (val[1] << 8) | val[2];\n\t\t\tbreak;\n\t\t}\n\t}\n\nexit:\n\tmutex_unlock(&devpriv->mut);\n\n\treturn ret;\n}\n\nstatic int dt9812_analog_out(struct comedi_device *dev, int channel, u16 value)\n{\n\tstruct dt9812_private *devpriv = dev->private;\n\tstruct dt9812_rmw_byte rmw[3];\n\tint ret;\n\n\tmutex_lock(&devpriv->mut);\n\n\tswitch (channel) {\n\tcase 0:\n\t\t \n\t\trmw[0].address = F020_SFR_DAC0CN;\n\t\trmw[0].and_mask = 0xff;\n\t\trmw[0].or_value = F020_MASK_DACXCN_DACXEN;\n\n\t\t \n\t\trmw[1].address = F020_SFR_DAC0L;\n\t\trmw[1].and_mask = 0xff;\n\t\trmw[1].or_value = value & 0xff;\n\n\t\t \n\t\trmw[2].address = F020_SFR_DAC0H;\n\t\trmw[2].and_mask = 0xff;\n\t\trmw[2].or_value = (value >> 8) & 0xf;\n\t\tbreak;\n\n\tcase 1:\n\t\t \n\t\trmw[0].address = F020_SFR_DAC1CN;\n\t\trmw[0].and_mask = 0xff;\n\t\trmw[0].or_value = F020_MASK_DACXCN_DACXEN;\n\n\t\t \n\t\trmw[1].address = F020_SFR_DAC1L;\n\t\trmw[1].and_mask = 0xff;\n\t\trmw[1].or_value = value & 0xff;\n\n\t\t \n\t\trmw[2].address = F020_SFR_DAC1H;\n\t\trmw[2].and_mask = 0xff;\n\t\trmw[2].or_value = (value >> 8) & 0xf;\n\t\tbreak;\n\t}\n\tret = dt9812_rmw_multiple_registers(dev, 3, rmw);\n\n\tmutex_unlock(&devpriv->mut);\n\n\treturn ret;\n}\n\nstatic int dt9812_di_insn_bits(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       struct comedi_insn *insn,\n\t\t\t       unsigned int *data)\n{\n\tu8 bits = 0;\n\tint ret;\n\n\tret = dt9812_digital_in(dev, &bits);\n\tif (ret)\n\t\treturn ret;\n\n\tdata[1] = bits;\n\n\treturn insn->n;\n}\n\nstatic int dt9812_do_insn_bits(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       struct comedi_insn *insn,\n\t\t\t       unsigned int *data)\n{\n\tif (comedi_dio_update_state(s, data))\n\t\tdt9812_digital_out(dev, s->state);\n\n\tdata[1] = s->state;\n\n\treturn insn->n;\n}\n\nstatic int dt9812_ai_insn_read(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       struct comedi_insn *insn,\n\t\t\t       unsigned int *data)\n{\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tu16 val = 0;\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\tret = dt9812_analog_in(dev, chan, &val, DT9812_GAIN_1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tdata[i] = val;\n\t}\n\n\treturn insn->n;\n}\n\nstatic int dt9812_ao_insn_read(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       struct comedi_insn *insn,\n\t\t\t       unsigned int *data)\n{\n\tstruct dt9812_private *devpriv = dev->private;\n\tint ret;\n\n\tmutex_lock(&devpriv->mut);\n\tret = comedi_readback_insn_read(dev, s, insn, data);\n\tmutex_unlock(&devpriv->mut);\n\n\treturn ret;\n}\n\nstatic int dt9812_ao_insn_write(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tstruct comedi_insn *insn,\n\t\t\t\tunsigned int *data)\n{\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tint i;\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\tunsigned int val = data[i];\n\t\tint ret;\n\n\t\tret = dt9812_analog_out(dev, chan, val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\ts->readback[chan] = val;\n\t}\n\n\treturn insn->n;\n}\n\nstatic int dt9812_find_endpoints(struct comedi_device *dev)\n{\n\tstruct usb_interface *intf = comedi_to_usb_interface(dev);\n\tstruct usb_host_interface *host = intf->cur_altsetting;\n\tstruct dt9812_private *devpriv = dev->private;\n\tstruct usb_endpoint_descriptor *ep;\n\tint i;\n\n\tif (host->desc.bNumEndpoints != 5) {\n\t\tdev_err(dev->class_dev, \"Wrong number of endpoints\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tfor (i = 0; i < host->desc.bNumEndpoints; ++i) {\n\t\tint dir = -1;\n\n\t\tep = &host->endpoint[i].desc;\n\t\tswitch (i) {\n\t\tcase 0:\n\t\t\t \n\t\t\tdir = USB_DIR_IN;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tdir = USB_DIR_OUT;\n\t\t\tdevpriv->cmd_wr.addr = ep->bEndpointAddress;\n\t\t\tdevpriv->cmd_wr.size = usb_endpoint_maxp(ep);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdir = USB_DIR_IN;\n\t\t\tdevpriv->cmd_rd.addr = ep->bEndpointAddress;\n\t\t\tdevpriv->cmd_rd.size = usb_endpoint_maxp(ep);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\t \n\t\t\tdir = USB_DIR_OUT;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\t \n\t\t\tdir = USB_DIR_IN;\n\t\t\tbreak;\n\t\t}\n\t\tif ((ep->bEndpointAddress & USB_DIR_IN) != dir) {\n\t\t\tdev_err(dev->class_dev,\n\t\t\t\t\"Endpoint has wrong direction\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int dt9812_reset_device(struct comedi_device *dev)\n{\n\tstruct usb_device *usb = comedi_to_usb_dev(dev);\n\tstruct dt9812_private *devpriv = dev->private;\n\tu32 serial;\n\tu16 vendor;\n\tu16 product;\n\tu8 tmp8;\n\t__le16 tmp16;\n\t__le32 tmp32;\n\tint ret;\n\tint i;\n\n\tret = dt9812_read_info(dev, 0, &tmp8, sizeof(tmp8));\n\tif (ret) {\n\t\t \n\t\tusb_reset_configuration(usb);\n\t\tfor (i = 0; i < 10; i++) {\n\t\t\tret = dt9812_read_info(dev, 1, &tmp8, sizeof(tmp8));\n\t\t\tif (ret == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (ret) {\n\t\t\tdev_err(dev->class_dev,\n\t\t\t\t\"unable to reset configuration\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = dt9812_read_info(dev, 1, &tmp16, sizeof(tmp16));\n\tif (ret) {\n\t\tdev_err(dev->class_dev, \"failed to read vendor id\\n\");\n\t\treturn ret;\n\t}\n\tvendor = le16_to_cpu(tmp16);\n\n\tret = dt9812_read_info(dev, 3, &tmp16, sizeof(tmp16));\n\tif (ret) {\n\t\tdev_err(dev->class_dev, \"failed to read product id\\n\");\n\t\treturn ret;\n\t}\n\tproduct = le16_to_cpu(tmp16);\n\n\tret = dt9812_read_info(dev, 5, &tmp16, sizeof(tmp16));\n\tif (ret) {\n\t\tdev_err(dev->class_dev, \"failed to read device id\\n\");\n\t\treturn ret;\n\t}\n\tdevpriv->device = le16_to_cpu(tmp16);\n\n\tret = dt9812_read_info(dev, 7, &tmp32, sizeof(tmp32));\n\tif (ret) {\n\t\tdev_err(dev->class_dev, \"failed to read serial number\\n\");\n\t\treturn ret;\n\t}\n\tserial = le32_to_cpu(tmp32);\n\n\t \n\tdev_info(dev->class_dev, \"USB DT9812 (%4.4x.%4.4x.%4.4x) #0x%8.8x\\n\",\n\t\t vendor, product, devpriv->device, serial);\n\n\tif (devpriv->device != DT9812_DEVID_DT9812_10 &&\n\t    devpriv->device != DT9812_DEVID_DT9812_2PT5) {\n\t\tdev_err(dev->class_dev, \"Unsupported device!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int dt9812_auto_attach(struct comedi_device *dev,\n\t\t\t      unsigned long context)\n{\n\tstruct usb_interface *intf = comedi_to_usb_interface(dev);\n\tstruct dt9812_private *devpriv;\n\tstruct comedi_subdevice *s;\n\tbool is_unipolar;\n\tint ret;\n\tint i;\n\n\tdevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\n\tif (!devpriv)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&devpriv->mut);\n\tusb_set_intfdata(intf, devpriv);\n\n\tret = dt9812_find_endpoints(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = dt9812_reset_device(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tis_unipolar = (devpriv->device == DT9812_DEVID_DT9812_2PT5);\n\n\tret = comedi_alloc_subdevices(dev, 4);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ts = &dev->subdevices[0];\n\ts->type\t\t= COMEDI_SUBD_DI;\n\ts->subdev_flags\t= SDF_READABLE;\n\ts->n_chan\t= 8;\n\ts->maxdata\t= 1;\n\ts->range_table\t= &range_digital;\n\ts->insn_bits\t= dt9812_di_insn_bits;\n\n\t \n\ts = &dev->subdevices[1];\n\ts->type\t\t= COMEDI_SUBD_DO;\n\ts->subdev_flags\t= SDF_WRITABLE;\n\ts->n_chan\t= 8;\n\ts->maxdata\t= 1;\n\ts->range_table\t= &range_digital;\n\ts->insn_bits\t= dt9812_do_insn_bits;\n\n\t \n\ts = &dev->subdevices[2];\n\ts->type\t\t= COMEDI_SUBD_AI;\n\ts->subdev_flags\t= SDF_READABLE | SDF_GROUND;\n\ts->n_chan\t= 8;\n\ts->maxdata\t= 0x0fff;\n\ts->range_table\t= is_unipolar ? &range_unipolar2_5 : &range_bipolar10;\n\ts->insn_read\t= dt9812_ai_insn_read;\n\n\t \n\ts = &dev->subdevices[3];\n\ts->type\t\t= COMEDI_SUBD_AO;\n\ts->subdev_flags\t= SDF_WRITABLE;\n\ts->n_chan\t= 2;\n\ts->maxdata\t= 0x0fff;\n\ts->range_table\t= is_unipolar ? &range_unipolar2_5 : &range_bipolar10;\n\ts->insn_write\t= dt9812_ao_insn_write;\n\ts->insn_read\t= dt9812_ao_insn_read;\n\n\tret = comedi_alloc_subdev_readback(s);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < s->n_chan; i++)\n\t\ts->readback[i] = is_unipolar ? 0x0000 : 0x0800;\n\n\treturn 0;\n}\n\nstatic void dt9812_detach(struct comedi_device *dev)\n{\n\tstruct usb_interface *intf = comedi_to_usb_interface(dev);\n\tstruct dt9812_private *devpriv = dev->private;\n\n\tif (!devpriv)\n\t\treturn;\n\n\tmutex_destroy(&devpriv->mut);\n\tusb_set_intfdata(intf, NULL);\n}\n\nstatic struct comedi_driver dt9812_driver = {\n\t.driver_name\t= \"dt9812\",\n\t.module\t\t= THIS_MODULE,\n\t.auto_attach\t= dt9812_auto_attach,\n\t.detach\t\t= dt9812_detach,\n};\n\nstatic int dt9812_usb_probe(struct usb_interface *intf,\n\t\t\t    const struct usb_device_id *id)\n{\n\treturn comedi_usb_auto_config(intf, &dt9812_driver, id->driver_info);\n}\n\nstatic const struct usb_device_id dt9812_usb_table[] = {\n\t{ USB_DEVICE(0x0867, 0x9812) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(usb, dt9812_usb_table);\n\nstatic struct usb_driver dt9812_usb_driver = {\n\t.name\t\t= \"dt9812\",\n\t.id_table\t= dt9812_usb_table,\n\t.probe\t\t= dt9812_usb_probe,\n\t.disconnect\t= comedi_usb_auto_unconfig,\n};\nmodule_comedi_usb_driver(dt9812_driver, dt9812_usb_driver);\n\nMODULE_AUTHOR(\"Anders Blomdell <anders.blomdell@control.lth.se>\");\nMODULE_DESCRIPTION(\"Comedi DT9812 driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}