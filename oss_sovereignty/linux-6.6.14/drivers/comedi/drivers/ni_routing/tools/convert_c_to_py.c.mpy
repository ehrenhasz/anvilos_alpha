{
  "module_name": "convert_c_to_py.c",
  "hash_id": "48866a2c070a8169d08fa4040be73d709708baed9c720fd0a5ab55a38aa6f298",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/ni_routing/tools/convert_c_to_py.c",
  "human_readable_source": "\n\n#include <stdint.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <errno.h>\n#include <stdlib.h>\n\ntypedef uint8_t u8;\ntypedef uint16_t u16;\ntypedef int8_t  s8;\n#define __user\n#define BIT(x)  (1UL << (x))\n\n#define NI_ROUTE_VALUE_EXTERNAL_CONVERSION 1\n\n#include \"../ni_route_values.c\"\n#include \"../ni_device_routes.c\"\n#include \"all_cfiles.c\"\n\n#include <stdio.h>\n\n#define RVij(rv, src, dest)\t((rv)->register_values[(dest)][(src)])\n\n \nvoid family_write(const struct family_route_values *rv, FILE *fp)\n{\n\tfprintf(fp,\n\t\t\"  \\\"%s\\\" : {\\n\"\n\t\t\"    # dest -> {src0:val0, src1:val1, ...}\\n\"\n\t\t, rv->family);\n\tfor (unsigned int dest = NI_NAMES_BASE;\n\t     dest < (NI_NAMES_BASE + NI_NUM_NAMES);\n\t     ++dest) {\n\t\tunsigned int src = NI_NAMES_BASE;\n\n\t\tfor (; src < (NI_NAMES_BASE + NI_NUM_NAMES) &&\n\t\t     RVij(rv, B(src), B(dest)) == 0; ++src)\n\t\t\t;\n\n\t\tif (src >= (NI_NAMES_BASE + NI_NUM_NAMES))\n\t\t\tcontinue;  \n\n\t\tfprintf(fp, \"    %u : {\\n\", dest);\n\t\tfor (src = NI_NAMES_BASE; src < (NI_NAMES_BASE + NI_NUM_NAMES);\n\t\t     ++src) {\n\t\t\tregister_type r = RVij(rv, B(src), B(dest));\n\t\t\tconst char *M;\n\n\t\t\tif (r == 0) {\n\t\t\t\tcontinue;\n\t\t\t} else if (MARKED_V(r)) {\n\t\t\t\tM = \"V\";\n\t\t\t} else if (MARKED_I(r)) {\n\t\t\t\tM = \"I\";\n\t\t\t} else if (MARKED_U(r)) {\n\t\t\t\tM = \"U\";\n\t\t\t} else {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"Invalid register marking %s[%u][%u] = %u\\n\",\n\t\t\t\t\trv->family, dest, src, r);\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tfprintf(fp, \"      %u : \\\"%s(%u)\\\",\\n\",\n\t\t\t\tsrc, M, UNMARK(r));\n\t\t}\n\t\tfprintf(fp, \"    },\\n\");\n\t}\n\tfprintf(fp, \"  },\\n\\n\");\n}\n\nbool is_valid_ni_sig(unsigned int sig)\n{\n\treturn (sig >= NI_NAMES_BASE) && (sig < (NI_NAMES_BASE + NI_NUM_NAMES));\n}\n\n \nvoid device_write(const struct ni_device_routes *dR, FILE *fp)\n{\n\tfprintf(fp,\n\t\t\"  \\\"%s\\\" : {\\n\"\n\t\t\"    # dest -> [src0, src1, ...]\\n\"\n\t\t, dR->device);\n\n\tunsigned int i = 0;\n\n\twhile (dR->routes[i].dest != 0) {\n\t\tif (!is_valid_ni_sig(dR->routes[i].dest)) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"Invalid NI signal value [%u] for destination %s.[%u]\\n\",\n\t\t\t\tdR->routes[i].dest, dR->device, i);\n\t\t\texit(1);\n\t\t}\n\n\t\tfprintf(fp, \"    %u : [\", dR->routes[i].dest);\n\n\t\tunsigned int j = 0;\n\n\t\twhile (dR->routes[i].src[j] != 0) {\n\t\t\tif (!is_valid_ni_sig(dR->routes[i].src[j])) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"Invalid NI signal value [%u] for source %s.[%u].[%u]\\n\",\n\t\t\t\t\tdR->routes[i].src[j], dR->device, i, j);\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tfprintf(fp, \"%u,\", dR->routes[i].src[j]);\n\n\t\t\t++j;\n\t\t}\n\t\tfprintf(fp, \"],\\n\");\n\n\t\t++i;\n\t}\n\tfprintf(fp, \"  },\\n\\n\");\n}\n\nint main(void)\n{\n\tFILE *fp = fopen(\"ni_values.py\", \"w\");\n\n\t \n\tfprintf(fp, \"ni_route_values = {\\n\");\n\tfor (int i = 0; ni_all_route_values[i]; ++i)\n\t\tfamily_write(ni_all_route_values[i], fp);\n\tfprintf(fp, \"}\\n\\n\");\n\n\t \n\tfprintf(fp, \"ni_device_routes = {\\n\");\n\tfor (int i = 0; ni_device_routes_list[i]; ++i)\n\t\tdevice_write(ni_device_routes_list[i], fp);\n\tfprintf(fp, \"}\\n\");\n\n\t \n\tfclose(fp);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}