{
  "module_name": "convert_csv_to_c.py",
  "hash_id": "7d0c45fd56522bd64157dc32d8b08f4c01e125e796377277e6e8d822a3ed5cfb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/ni_routing/tools/convert_csv_to_c.py",
  "human_readable_source": "#!/usr/bin/env python3\n# SPDX-License-Identifier: GPL-2.0+\n\n# This is simply to aide in creating the entries in the order of the value of\n# the device-global NI signal/terminal constants defined in comedi.h\nimport comedi_h\nimport os, sys, re\nfrom csv_collection import CSVCollection\n\n\ndef c_to_o(filename, prefix='\\t\\t\\t\\t\\t   ni_routing/', suffix=' \\\\'):\n  if not filename.endswith('.c'):\n    return ''\n  return prefix + filename.rpartition('.c')[0] + '.o' + suffix\n\n\ndef routedict_to_structinit_single(name, D, return_name=False):\n  Locals = dict()\n  lines = [\n    '\\t.family = \"{}\",'.format(name),\n    '\\t.register_values = {',\n    '\\t\\t/*',\n    '\\t\\t * destination = {',\n\t  '\\t\\t *              source          = register value,',\n\t  '\\t\\t *              ...',\n\t  '\\t\\t * }',\n\t\t'\\t\\t */',\n  ]\n  if (False):\n    # print table with index0:src, index1:dest\n    D0 = D # (src-> dest->reg_value)\n    #D1 : destD\n  else:\n    D0 = dict()\n    for src, destD in D.items():\n      for dest, val in destD.items():\n        D0.setdefault(dest, {})[src] = val\n\n\n  D0 = sorted(D0.items(), key=lambda i: eval(i[0], comedi_h.__dict__, Locals))\n\n  for D0_sig, D1_D in D0:\n    D1 = sorted(D1_D.items(), key=lambda i: eval(i[0], comedi_h.__dict__, Locals))\n\n    lines.append('\\t\\t[B({})] = {{'.format(D0_sig))\n    for D1_sig, value in D1:\n      if not re.match('[VIU]\\([^)]*\\)', value):\n        sys.stderr.write('Invalid register format: {}\\n'.format(repr(value)))\n        sys.stderr.write(\n          'Register values should be formatted with V(),I(),or U()\\n')\n        raise RuntimeError('Invalid register values format')\n      lines.append('\\t\\t\\t[B({})]\\t= {},'.format(D1_sig, value))\n    lines.append('\\t\\t},')\n  lines.append('\\t},')\n\n  lines = '\\n'.join(lines)\n  if return_name:\n    return N, lines\n  else:\n    return lines\n\n\ndef routedict_to_routelist_single(name, D, indent=1):\n  Locals = dict()\n\n  indents = dict(\n    I0 = '\\t'*(indent),\n    I1 = '\\t'*(indent+1),\n    I2 = '\\t'*(indent+2),\n    I3 = '\\t'*(indent+3),\n    I4 = '\\t'*(indent+4),\n  )\n\n  if (False):\n    # data is src -> dest-list\n    D0 = D\n    keyname = 'src'\n    valname = 'dest'\n  else:\n    # data is dest -> src-list\n    keyname = 'dest'\n    valname = 'src'\n    D0 = dict()\n    for src, destD in D.items():\n      for dest, val in destD.items():\n        D0.setdefault(dest, {})[src] = val\n\n  # Sort by order of device-global names (numerically)\n  D0 = sorted(D0.items(), key=lambda i: eval(i[0], comedi_h.__dict__, Locals))\n\n  lines = [ '{I0}.device = \"{name}\",\\n'\n            '{I0}.routes = (struct ni_route_set[]){{'\n            .format(name=name, **indents) ]\n  for D0_sig, D1_D in D0:\n    D1 = [ k for k,v in D1_D.items() if v ]\n    D1.sort(key=lambda i: eval(i, comedi_h.__dict__, Locals))\n\n    lines.append('{I1}{{\\n{I2}.{keyname} = {D0_sig},\\n'\n                         '{I2}.{valname} = (int[]){{'\n                 .format(keyname=keyname, valname=valname, D0_sig=D0_sig, **indents)\n    )\n    for D1_sig in D1:\n      lines.append( '{I3}{D1_sig},'.format(D1_sig=D1_sig, **indents) )\n    lines.append( '{I3}0, /* Termination */'.format(**indents) )\n\n    lines.append('{I2}}}\\n{I1}}},'.format(**indents))\n\n  lines.append('{I1}{{ /* Termination of list */\\n{I2}.{keyname} = 0,\\n{I1}}},'\n               .format(keyname=keyname, **indents))\n\n  lines.append('{I0}}},'.format(**indents))\n\n  return '\\n'.join(lines)\n\n\nclass DeviceRoutes(CSVCollection):\n  MKFILE_SEGMENTS = 'device-route.mk'\n  SET_C = 'ni_device_routes.c'\n  ITEMS_DIR = 'ni_device_routes'\n  EXTERN_H = 'all.h'\n  OUTPUT_DIR = 'c'\n\n  output_file_top = \"\"\"\\\n// SPDX-License-Identifier: GPL-2.0+\n/*\n *  comedi/drivers/ni_routing/{filename}\n *  List of valid routes for specific NI boards.\n *\n *  COMEDI - Linux Control and Measurement Device Interface\n *  Copyright (C) 2016 Spencer E. Olson <olsonse@umich.edu>\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n */\n\n/*\n * The contents of this file are generated using the tools in\n * comedi/drivers/ni_routing/tools\n *\n * Please use those tools to help maintain the contents of this file.\n */\n\n#include \"ni_device_routes.h\"\n#include \"{extern_h}\"\\\n\"\"\".format(filename=SET_C, extern_h=os.path.join(ITEMS_DIR, EXTERN_H))\n\n  extern_header = \"\"\"\\\n/* SPDX-License-Identifier: GPL-2.0+ */\n/*\n *  comedi/drivers/ni_routing/{filename}\n *  List of valid routes for specific NI boards.\n *\n *  COMEDI - Linux Control and Measurement Device Interface\n *  Copyright (C) 2016 Spencer E. Olson <olsonse@umich.edu>\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n */\n\n/*\n * The contents of this file are generated using the tools in\n * comedi/drivers/ni_routing/tools\n *\n * Please use those tools to help maintain the contents of this file.\n */\n\n#ifndef _COMEDI_DRIVERS_NI_ROUTING_NI_DEVICE_ROUTES_EXTERN_H\n#define _COMEDI_DRIVERS_NI_ROUTING_NI_DEVICE_ROUTES_EXTERN_H\n\n#include \"../ni_device_routes.h\"\n\n{externs}\n\n#endif //_COMEDI_DRIVERS_NI_ROUTING_NI_DEVICE_ROUTES_EXTERN_H\n\"\"\"\n\n  single_output_file_top = \"\"\"\\\n// SPDX-License-Identifier: GPL-2.0+\n/*\n *  comedi/drivers/ni_routing/{filename}\n *  List of valid routes for specific NI boards.\n *\n *  COMEDI - Linux Control and Measurement Device Interface\n *  Copyright (C) 2016 Spencer E. Olson <olsonse@umich.edu>\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n */\n\n/*\n * The contents of this file are generated using the tools in\n * comedi/drivers/ni_routing/tools\n *\n * Please use those tools to help maintain the contents of this file.\n */\n\n#include \"../ni_device_routes.h\"\n#include \"{extern_h}\"\n\nstruct ni_device_routes {table_name} = {{\\\n\"\"\"\n\n  def __init__(self, pattern='csv/device_routes/*.csv'):\n    super(DeviceRoutes,self).__init__(pattern)\n\n  def to_listinit(self):\n    chunks = [ self.output_file_top,\n      '',\n      'struct ni_device_routes *const ni_device_routes_list[] = {'\n    ]\n    # put the sheets in lexical order of device numbers then bus\n    sheets = sorted(self.items(), key=lambda i : tuple(i[0].split('-')[::-1]) )\n\n    externs = []\n    objs = [c_to_o(self.SET_C)]\n\n    for sheet,D in sheets:\n      S = sheet.lower()\n      dev_table_name = 'ni_{}_device_routes'.format(S.replace('-','_'))\n      sheet_filename = os.path.join(self.ITEMS_DIR,'{}.c'.format(S))\n      externs.append('extern struct ni_device_routes {};'.format(dev_table_name))\n\n      chunks.append('\\t&{},'.format(dev_table_name))\n\n      s_chunks = [\n        self.single_output_file_top.format(\n          filename    = sheet_filename,\n          table_name  = dev_table_name,\n          extern_h    = self.EXTERN_H,\n        ),\n        routedict_to_routelist_single(S, D),\n        '};',\n      ]\n\n      objs.append(c_to_o(sheet_filename))\n\n      with open(os.path.join(self.OUTPUT_DIR, sheet_filename), 'w') as f:\n        f.write('\\n'.join(s_chunks))\n        f.write('\\n')\n\n    with open(os.path.join(self.OUTPUT_DIR, self.MKFILE_SEGMENTS), 'w') as f:\n      f.write('# This is the segment that should be included in comedi/drivers/Makefile\\n')\n      f.write('ni_routing-objs\\t\\t\\t\\t+= \\\\\\n')\n      f.write('\\n'.join(objs))\n      f.write('\\n')\n\n    EXTERN_H = os.path.join(self.ITEMS_DIR, self.EXTERN_H)\n    with open(os.path.join(self.OUTPUT_DIR, EXTERN_H), 'w') as f:\n      f.write(self.extern_header.format(\n        filename=EXTERN_H, externs='\\n'.join(externs)))\n\n    chunks.append('\\tNULL,') # terminate list\n    chunks.append('};')\n    return '\\n'.join(chunks)\n\n  def save(self):\n    filename=os.path.join(self.OUTPUT_DIR, self.SET_C)\n\n    try:\n      os.makedirs(os.path.join(self.OUTPUT_DIR, self.ITEMS_DIR))\n    except:\n      pass\n    with open(filename,'w') as f:\n      f.write( self.to_listinit() )\n      f.write( '\\n' )\n\n\nclass RouteValues(CSVCollection):\n  MKFILE_SEGMENTS = 'route-values.mk'\n  SET_C = 'ni_route_values.c'\n  ITEMS_DIR = 'ni_route_values'\n  EXTERN_H = 'all.h'\n  OUTPUT_DIR = 'c'\n\n  output_file_top = \"\"\"\\\n// SPDX-License-Identifier: GPL-2.0+\n/*\n *  comedi/drivers/ni_routing/{filename}\n *  Route information for NI boards.\n *\n *  COMEDI - Linux Control and Measurement Device Interface\n *  Copyright (C) 2016 Spencer E. Olson <olsonse@umich.edu>\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n */\n\n/*\n * This file includes the tables that are a list of all the values of various\n * signals routes available on NI hardware.  In many cases, one does not\n * explicitly make these routes, rather one might indicate that something is\n * used as the source of one particular trigger or another (using\n * *_src=TRIG_EXT).\n *\n * The contents of this file are generated using the tools in\n * comedi/drivers/ni_routing/tools\n *\n * Please use those tools to help maintain the contents of this file.\n */\n\n#include \"ni_route_values.h\"\n#include \"{extern_h}\"\\\n\"\"\".format(filename=SET_C, extern_h=os.path.join(ITEMS_DIR, EXTERN_H))\n\n  extern_header = \"\"\"\\\n/* SPDX-License-Identifier: GPL-2.0+ */\n/*\n *  comedi/drivers/ni_routing/{filename}\n *  List of valid routes for specific NI boards.\n *\n *  COMEDI - Linux Control and Measurement Device Interface\n *  Copyright (C) 2016 Spencer E. Olson <olsonse@umich.edu>\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n */\n\n/*\n * The contents of this file are generated using the tools in\n * comedi/drivers/ni_routing/tools\n *\n * Please use those tools to help maintain the contents of this file.\n */\n\n#ifndef _COMEDI_DRIVERS_NI_ROUTING_NI_ROUTE_VALUES_EXTERN_H\n#define _COMEDI_DRIVERS_NI_ROUTING_NI_ROUTE_VALUES_EXTERN_H\n\n#include \"../ni_route_values.h\"\n\n{externs}\n\n#endif //_COMEDI_DRIVERS_NI_ROUTING_NI_ROUTE_VALUES_EXTERN_H\n\"\"\"\n\n  single_output_file_top = \"\"\"\\\n// SPDX-License-Identifier: GPL-2.0+\n/*\n *  comedi/drivers/ni_routing/{filename}\n *  Route information for {sheet} boards.\n *\n *  COMEDI - Linux Control and Measurement Device Interface\n *  Copyright (C) 2016 Spencer E. Olson <olsonse@umich.edu>\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n */\n\n/*\n * This file includes a list of all the values of various signals routes\n * available on NI 660x hardware.  In many cases, one does not explicitly make\n * these routes, rather one might indicate that something is used as the source\n * of one particular trigger or another (using *_src=TRIG_EXT).\n *\n * The contents of this file can be generated using the tools in\n * comedi/drivers/ni_routing/tools.  This file also contains specific notes to\n * this family of devices.\n *\n * Please use those tools to help maintain the contents of this file, but be\n * mindful to not lose the notes already made in this file, since these notes\n * are critical to a complete undertsanding of the register values of this\n * family.\n */\n\n#include \"../ni_route_values.h\"\n#include \"{extern_h}\"\n\nconst struct family_route_values {table_name} = {{\\\n\"\"\"\n\n  def __init__(self, pattern='csv/route_values/*.csv'):\n    super(RouteValues,self).__init__(pattern)\n\n  def to_structinit(self):\n    chunks = [ self.output_file_top,\n      '',\n      'const struct family_route_values *const ni_all_route_values[] = {'\n    ]\n    # put the sheets in lexical order for consistency\n    sheets = sorted(self.items(), key=lambda i : i[0] )\n\n    externs = []\n    objs = [c_to_o(self.SET_C)]\n\n    for sheet,D in sheets:\n      S = sheet.lower()\n      fam_table_name = '{}_route_values'.format(S.replace('-','_'))\n      sheet_filename = os.path.join(self.ITEMS_DIR,'{}.c'.format(S))\n      externs.append('extern const struct family_route_values {};'.format(fam_table_name))\n\n      chunks.append('\\t&{},'.format(fam_table_name))\n\n      s_chunks = [\n        self.single_output_file_top.format(\n          filename    = sheet_filename,\n          sheet       = sheet.upper(),\n          table_name  = fam_table_name,\n          extern_h    = self.EXTERN_H,\n        ),\n        routedict_to_structinit_single(S, D),\n        '};',\n      ]\n\n      objs.append(c_to_o(sheet_filename))\n\n      with open(os.path.join(self.OUTPUT_DIR, sheet_filename), 'w') as f:\n        f.write('\\n'.join(s_chunks))\n        f.write( '\\n' )\n\n    with open(os.path.join(self.OUTPUT_DIR, self.MKFILE_SEGMENTS), 'w') as f:\n      f.write('# This is the segment that should be included in comedi/drivers/Makefile\\n')\n      f.write('ni_routing-objs\\t\\t\\t\\t+= \\\\\\n')\n      f.write('\\n'.join(objs))\n      f.write('\\n')\n\n    EXTERN_H = os.path.join(self.ITEMS_DIR, self.EXTERN_H)\n    with open(os.path.join(self.OUTPUT_DIR, EXTERN_H), 'w') as f:\n      f.write(self.extern_header.format(\n        filename=EXTERN_H, externs='\\n'.join(externs)))\n\n    chunks.append('\\tNULL,') # terminate list\n    chunks.append('};')\n    return '\\n'.join(chunks)\n\n  def save(self):\n    filename=os.path.join(self.OUTPUT_DIR, self.SET_C)\n\n    try:\n      os.makedirs(os.path.join(self.OUTPUT_DIR, self.ITEMS_DIR))\n    except:\n      pass\n    with open(filename,'w') as f:\n      f.write( self.to_structinit() )\n      f.write( '\\n' )\n\n\n\nif __name__ == '__main__':\n  import argparse\n  parser = argparse.ArgumentParser()\n  parser.add_argument( '--route_values', action='store_true',\n    help='Extract route values from csv/route_values/*.csv' )\n  parser.add_argument( '--device_routes', action='store_true',\n    help='Extract route values from csv/device_routes/*.csv' )\n  args = parser.parse_args()\n  KL = list()\n  if args.route_values:\n    KL.append( RouteValues )\n  if args.device_routes:\n    KL.append( DeviceRoutes )\n  if not KL:\n    parser.error('nothing to do...')\n  for K in KL:\n    doc = K()\n    doc.save()\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}