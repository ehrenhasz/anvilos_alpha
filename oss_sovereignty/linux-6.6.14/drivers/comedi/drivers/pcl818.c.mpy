{
  "module_name": "pcl818.c",
  "hash_id": "2274ea904cfe13fcfead244b88e90cba66adbd25d7c810077932467db9377ef9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/pcl818.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/interrupt.h>\n#include <linux/comedi/comedidev.h>\n#include <linux/comedi/comedi_8254.h>\n#include <linux/comedi/comedi_isadma.h>\n\n \n#define PCL818_AI_LSB_REG\t\t\t0x00\n#define PCL818_AI_MSB_REG\t\t\t0x01\n#define PCL818_RANGE_REG\t\t\t0x01\n#define PCL818_MUX_REG\t\t\t\t0x02\n#define PCL818_MUX_SCAN(_first, _last)\t\t(((_last) << 4) | (_first))\n#define PCL818_DO_DI_LSB_REG\t\t\t0x03\n#define PCL818_AO_LSB_REG(x)\t\t\t(0x04 + ((x) * 2))\n#define PCL818_AO_MSB_REG(x)\t\t\t(0x05 + ((x) * 2))\n#define PCL818_STATUS_REG\t\t\t0x08\n#define PCL818_STATUS_NEXT_CHAN_MASK\t\t(0xf << 0)\n#define PCL818_STATUS_INT\t\t\tBIT(4)\n#define PCL818_STATUS_MUX\t\t\tBIT(5)\n#define PCL818_STATUS_UNI\t\t\tBIT(6)\n#define PCL818_STATUS_EOC\t\t\tBIT(7)\n#define PCL818_CTRL_REG\t\t\t\t0x09\n#define PCL818_CTRL_TRIG(x)\t\t\t(((x) & 0x3) << 0)\n#define PCL818_CTRL_DISABLE_TRIG\t\tPCL818_CTRL_TRIG(0)\n#define PCL818_CTRL_SOFT_TRIG\t\t\tPCL818_CTRL_TRIG(1)\n#define PCL818_CTRL_EXT_TRIG\t\t\tPCL818_CTRL_TRIG(2)\n#define PCL818_CTRL_PACER_TRIG\t\t\tPCL818_CTRL_TRIG(3)\n#define PCL818_CTRL_DMAE\t\t\tBIT(2)\n#define PCL818_CTRL_IRQ(x)\t\t\t((x) << 4)\n#define PCL818_CTRL_INTE\t\t\tBIT(7)\n#define PCL818_CNTENABLE_REG\t\t\t0x0a\n#define PCL818_CNTENABLE_PACER_TRIG0\t\tBIT(0)\n#define PCL818_CNTENABLE_CNT0_INT_CLK\t\tBIT(1)\t \n#define PCL818_DO_DI_MSB_REG\t\t\t0x0b\n#define PCL818_TIMER_BASE\t\t\t0x0c\n\n \n#define PCL818_FI_ENABLE 6\n \n#define PCL818_FI_INTCLR 20\n \n#define PCL818_FI_FLUSH 25\n \n#define PCL818_FI_STATUS 25\n \n#define PCL818_FI_DATALO 23\n#define PCL818_FI_DATAHI 24\n\n#define MAGIC_DMA_WORD 0x5a5a\n\nstatic const struct comedi_lrange range_pcl818h_ai = {\n\t9, {\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(2.5),\n\t\tBIP_RANGE(1.25),\n\t\tBIP_RANGE(0.625),\n\t\tUNI_RANGE(10),\n\t\tUNI_RANGE(5),\n\t\tUNI_RANGE(2.5),\n\t\tUNI_RANGE(1.25),\n\t\tBIP_RANGE(10)\n\t}\n};\n\nstatic const struct comedi_lrange range_pcl818hg_ai = {\n\t10, {\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(0.5),\n\t\tBIP_RANGE(0.05),\n\t\tBIP_RANGE(0.005),\n\t\tUNI_RANGE(10),\n\t\tUNI_RANGE(1),\n\t\tUNI_RANGE(0.1),\n\t\tUNI_RANGE(0.01),\n\t\tBIP_RANGE(10),\n\t\tBIP_RANGE(1),\n\t\tBIP_RANGE(0.1),\n\t\tBIP_RANGE(0.01)\n\t}\n};\n\nstatic const struct comedi_lrange range_pcl818l_l_ai = {\n\t4, {\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(2.5),\n\t\tBIP_RANGE(1.25),\n\t\tBIP_RANGE(0.625)\n\t}\n};\n\nstatic const struct comedi_lrange range_pcl818l_h_ai = {\n\t4, {\n\t\tBIP_RANGE(10),\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(2.5),\n\t\tBIP_RANGE(1.25)\n\t}\n};\n\nstatic const struct comedi_lrange range718_bipolar1 = {\n\t1, {\n\t\tBIP_RANGE(1)\n\t}\n};\n\nstatic const struct comedi_lrange range718_bipolar0_5 = {\n\t1, {\n\t\tBIP_RANGE(0.5)\n\t}\n};\n\nstatic const struct comedi_lrange range718_unipolar2 = {\n\t1, {\n\t\tUNI_RANGE(2)\n\t}\n};\n\nstatic const struct comedi_lrange range718_unipolar1 = {\n\t1, {\n\t\tBIP_RANGE(1)\n\t}\n};\n\nstruct pcl818_board {\n\tconst char *name;\n\tunsigned int ns_min;\n\tint n_aochan;\n\tconst struct comedi_lrange *ai_range_type;\n\tunsigned int has_dma:1;\n\tunsigned int has_fifo:1;\n\tunsigned int is_818:1;\n};\n\nstatic const struct pcl818_board boardtypes[] = {\n\t{\n\t\t.name\t\t= \"pcl818l\",\n\t\t.ns_min\t\t= 25000,\n\t\t.n_aochan\t= 1,\n\t\t.ai_range_type\t= &range_pcl818l_l_ai,\n\t\t.has_dma\t= 1,\n\t\t.is_818\t\t= 1,\n\t}, {\n\t\t.name\t\t= \"pcl818h\",\n\t\t.ns_min\t\t= 10000,\n\t\t.n_aochan\t= 1,\n\t\t.ai_range_type\t= &range_pcl818h_ai,\n\t\t.has_dma\t= 1,\n\t\t.is_818\t\t= 1,\n\t}, {\n\t\t.name\t\t= \"pcl818hd\",\n\t\t.ns_min\t\t= 10000,\n\t\t.n_aochan\t= 1,\n\t\t.ai_range_type\t= &range_pcl818h_ai,\n\t\t.has_dma\t= 1,\n\t\t.has_fifo\t= 1,\n\t\t.is_818\t\t= 1,\n\t}, {\n\t\t.name\t\t= \"pcl818hg\",\n\t\t.ns_min\t\t= 10000,\n\t\t.n_aochan\t= 1,\n\t\t.ai_range_type\t= &range_pcl818hg_ai,\n\t\t.has_dma\t= 1,\n\t\t.has_fifo\t= 1,\n\t\t.is_818\t\t= 1,\n\t}, {\n\t\t.name\t\t= \"pcl818\",\n\t\t.ns_min\t\t= 10000,\n\t\t.n_aochan\t= 2,\n\t\t.ai_range_type\t= &range_pcl818h_ai,\n\t\t.has_dma\t= 1,\n\t\t.is_818\t\t= 1,\n\t}, {\n\t\t.name\t\t= \"pcl718\",\n\t\t.ns_min\t\t= 16000,\n\t\t.n_aochan\t= 2,\n\t\t.ai_range_type\t= &range_unipolar5,\n\t\t.has_dma\t= 1,\n\t}, {\n\t\t.name\t\t= \"pcm3718\",\n\t\t.ns_min\t\t= 10000,\n\t\t.ai_range_type\t= &range_pcl818h_ai,\n\t\t.has_dma\t= 1,\n\t\t.is_818\t\t= 1,\n\t},\n};\n\nstruct pcl818_private {\n\tstruct comedi_isadma *dma;\n\t \n\tunsigned int ns_min;\n\t \n\tunsigned int act_chanlist[16];\n\tunsigned int act_chanlist_len;\t \n\tunsigned int act_chanlist_pos;\t \n\tunsigned int usefifo:1;\n\tunsigned int ai_cmd_running:1;\n\tunsigned int ai_cmd_canceled:1;\n};\n\nstatic void pcl818_ai_setup_dma(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tunsigned int unread_samples)\n{\n\tstruct pcl818_private *devpriv = dev->private;\n\tstruct comedi_isadma *dma = devpriv->dma;\n\tstruct comedi_isadma_desc *desc = &dma->desc[dma->cur_dma];\n\tunsigned int max_samples = comedi_bytes_to_samples(s, desc->maxsize);\n\tunsigned int nsamples;\n\n\tcomedi_isadma_disable(dma->chan);\n\n\t \n\tnsamples = comedi_nsamples_left(s, max_samples + unread_samples);\n\tif (nsamples > unread_samples) {\n\t\tnsamples -= unread_samples;\n\t\tdesc->size = comedi_samples_to_bytes(s, nsamples);\n\t\tcomedi_isadma_program(desc);\n\t}\n}\n\nstatic void pcl818_ai_set_chan_range(struct comedi_device *dev,\n\t\t\t\t     unsigned int chan,\n\t\t\t\t     unsigned int range)\n{\n\toutb(chan, dev->iobase + PCL818_MUX_REG);\n\toutb(range, dev->iobase + PCL818_RANGE_REG);\n}\n\nstatic void pcl818_ai_set_chan_scan(struct comedi_device *dev,\n\t\t\t\t    unsigned int first_chan,\n\t\t\t\t    unsigned int last_chan)\n{\n\toutb(PCL818_MUX_SCAN(first_chan, last_chan),\n\t     dev->iobase + PCL818_MUX_REG);\n}\n\nstatic void pcl818_ai_setup_chanlist(struct comedi_device *dev,\n\t\t\t\t     unsigned int *chanlist,\n\t\t\t\t     unsigned int seglen)\n{\n\tstruct pcl818_private *devpriv = dev->private;\n\tunsigned int first_chan = CR_CHAN(chanlist[0]);\n\tunsigned int last_chan;\n\tunsigned int range;\n\tint i;\n\n\tdevpriv->act_chanlist_len = seglen;\n\tdevpriv->act_chanlist_pos = 0;\n\n\t \n\tfor (i = 0; i < seglen; i++) {\n\t\tlast_chan = CR_CHAN(chanlist[i]);\n\t\trange = CR_RANGE(chanlist[i]);\n\n\t\tdevpriv->act_chanlist[i] = last_chan;\n\n\t\tpcl818_ai_set_chan_range(dev, last_chan, range);\n\t}\n\n\tudelay(1);\n\n\tpcl818_ai_set_chan_scan(dev, first_chan, last_chan);\n}\n\nstatic void pcl818_ai_clear_eoc(struct comedi_device *dev)\n{\n\t \n\toutb(0, dev->iobase + PCL818_STATUS_REG);\n}\n\nstatic void pcl818_ai_soft_trig(struct comedi_device *dev)\n{\n\t \n\toutb(0, dev->iobase + PCL818_AI_LSB_REG);\n}\n\nstatic unsigned int pcl818_ai_get_fifo_sample(struct comedi_device *dev,\n\t\t\t\t\t      struct comedi_subdevice *s,\n\t\t\t\t\t      unsigned int *chan)\n{\n\tunsigned int val;\n\n\tval = inb(dev->iobase + PCL818_FI_DATALO);\n\tval |= (inb(dev->iobase + PCL818_FI_DATAHI) << 8);\n\n\tif (chan)\n\t\t*chan = val & 0xf;\n\n\treturn (val >> 4) & s->maxdata;\n}\n\nstatic unsigned int pcl818_ai_get_sample(struct comedi_device *dev,\n\t\t\t\t\t struct comedi_subdevice *s,\n\t\t\t\t\t unsigned int *chan)\n{\n\tunsigned int val;\n\n\tval = inb(dev->iobase + PCL818_AI_MSB_REG) << 8;\n\tval |= inb(dev->iobase + PCL818_AI_LSB_REG);\n\n\tif (chan)\n\t\t*chan = val & 0xf;\n\n\treturn (val >> 4) & s->maxdata;\n}\n\nstatic int pcl818_ai_eoc(struct comedi_device *dev,\n\t\t\t struct comedi_subdevice *s,\n\t\t\t struct comedi_insn *insn,\n\t\t\t unsigned long context)\n{\n\tunsigned int status;\n\n\tstatus = inb(dev->iobase + PCL818_STATUS_REG);\n\tif (status & PCL818_STATUS_INT)\n\t\treturn 0;\n\treturn -EBUSY;\n}\n\nstatic bool pcl818_ai_write_sample(struct comedi_device *dev,\n\t\t\t\t   struct comedi_subdevice *s,\n\t\t\t\t   unsigned int chan, unsigned short val)\n{\n\tstruct pcl818_private *devpriv = dev->private;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tunsigned int expected_chan;\n\n\texpected_chan = devpriv->act_chanlist[devpriv->act_chanlist_pos];\n\tif (chan != expected_chan) {\n\t\tdev_dbg(dev->class_dev,\n\t\t\t\"A/D mode1/3 %s - channel dropout %d!=%d !\\n\",\n\t\t\t(devpriv->dma) ? \"DMA\" :\n\t\t\t(devpriv->usefifo) ? \"FIFO\" : \"IRQ\",\n\t\t\tchan, expected_chan);\n\t\ts->async->events |= COMEDI_CB_ERROR;\n\t\treturn false;\n\t}\n\n\tcomedi_buf_write_samples(s, &val, 1);\n\n\tdevpriv->act_chanlist_pos++;\n\tif (devpriv->act_chanlist_pos >= devpriv->act_chanlist_len)\n\t\tdevpriv->act_chanlist_pos = 0;\n\n\tif (cmd->stop_src == TRIG_COUNT &&\n\t    s->async->scans_done >= cmd->stop_arg) {\n\t\ts->async->events |= COMEDI_CB_EOA;\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void pcl818_handle_eoc(struct comedi_device *dev,\n\t\t\t      struct comedi_subdevice *s)\n{\n\tunsigned int chan;\n\tunsigned int val;\n\n\tif (pcl818_ai_eoc(dev, s, NULL, 0)) {\n\t\tdev_err(dev->class_dev, \"A/D mode1/3 IRQ without DRDY!\\n\");\n\t\ts->async->events |= COMEDI_CB_ERROR;\n\t\treturn;\n\t}\n\n\tval = pcl818_ai_get_sample(dev, s, &chan);\n\tpcl818_ai_write_sample(dev, s, chan, val);\n}\n\nstatic void pcl818_handle_dma(struct comedi_device *dev,\n\t\t\t      struct comedi_subdevice *s)\n{\n\tstruct pcl818_private *devpriv = dev->private;\n\tstruct comedi_isadma *dma = devpriv->dma;\n\tstruct comedi_isadma_desc *desc = &dma->desc[dma->cur_dma];\n\tunsigned short *ptr = desc->virt_addr;\n\tunsigned int nsamples = comedi_bytes_to_samples(s, desc->size);\n\tunsigned int chan;\n\tunsigned int val;\n\tint i;\n\n\t \n\tdma->cur_dma = 1 - dma->cur_dma;\n\tpcl818_ai_setup_dma(dev, s, nsamples);\n\n\tfor (i = 0; i < nsamples; i++) {\n\t\tval = ptr[i];\n\t\tchan = val & 0xf;\n\t\tval = (val >> 4) & s->maxdata;\n\t\tif (!pcl818_ai_write_sample(dev, s, chan, val))\n\t\t\tbreak;\n\t}\n}\n\nstatic void pcl818_handle_fifo(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s)\n{\n\tunsigned int status;\n\tunsigned int chan;\n\tunsigned int val;\n\tint i, len;\n\n\tstatus = inb(dev->iobase + PCL818_FI_STATUS);\n\n\tif (status & 4) {\n\t\tdev_err(dev->class_dev, \"A/D mode1/3 FIFO overflow!\\n\");\n\t\ts->async->events |= COMEDI_CB_ERROR;\n\t\treturn;\n\t}\n\n\tif (status & 1) {\n\t\tdev_err(dev->class_dev,\n\t\t\t\"A/D mode1/3 FIFO interrupt without data!\\n\");\n\t\ts->async->events |= COMEDI_CB_ERROR;\n\t\treturn;\n\t}\n\n\tif (status & 2)\n\t\tlen = 512;\n\telse\n\t\tlen = 0;\n\n\tfor (i = 0; i < len; i++) {\n\t\tval = pcl818_ai_get_fifo_sample(dev, s, &chan);\n\t\tif (!pcl818_ai_write_sample(dev, s, chan, val))\n\t\t\tbreak;\n\t}\n}\n\nstatic irqreturn_t pcl818_interrupt(int irq, void *d)\n{\n\tstruct comedi_device *dev = d;\n\tstruct pcl818_private *devpriv = dev->private;\n\tstruct comedi_subdevice *s = dev->read_subdev;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\n\tif (!dev->attached || !devpriv->ai_cmd_running) {\n\t\tpcl818_ai_clear_eoc(dev);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (devpriv->ai_cmd_canceled) {\n\t\t \n\t\ts->async->scans_done = cmd->stop_arg;\n\t\ts->cancel(dev, s);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (devpriv->dma)\n\t\tpcl818_handle_dma(dev, s);\n\telse if (devpriv->usefifo)\n\t\tpcl818_handle_fifo(dev, s);\n\telse\n\t\tpcl818_handle_eoc(dev, s);\n\n\tpcl818_ai_clear_eoc(dev);\n\n\tcomedi_handle_events(dev, s);\n\treturn IRQ_HANDLED;\n}\n\nstatic int check_channel_list(struct comedi_device *dev,\n\t\t\t      struct comedi_subdevice *s,\n\t\t\t      unsigned int *chanlist, unsigned int n_chan)\n{\n\tunsigned int chansegment[16];\n\tunsigned int i, nowmustbechan, seglen;\n\n\t \n\tif (n_chan < 1) {\n\t\tdev_err(dev->class_dev, \"range/channel list is empty!\\n\");\n\t\treturn 0;\n\t}\n\n\tif (n_chan > 1) {\n\t\t \n\t\tchansegment[0] = chanlist[0];\n\t\t \n\t\tfor (i = 1, seglen = 1; i < n_chan; i++, seglen++) {\n\t\t\t \n\n\t\t\tif (chanlist[0] == chanlist[i])\n\t\t\t\tbreak;\n\t\t\tnowmustbechan =\n\t\t\t    (CR_CHAN(chansegment[i - 1]) + 1) % s->n_chan;\n\t\t\tif (nowmustbechan != CR_CHAN(chanlist[i])) {\n\t\t\t\t \n\t\t\t\tdev_dbg(dev->class_dev,\n\t\t\t\t\t\"channel list must be continuous! chanlist[%i]=%d but must be %d or %d!\\n\",\n\t\t\t\t\ti, CR_CHAN(chanlist[i]), nowmustbechan,\n\t\t\t\t\tCR_CHAN(chanlist[0]));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t \n\t\t\tchansegment[i] = chanlist[i];\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < n_chan; i++) {\n\t\t\tif (chanlist[i] != chansegment[i % seglen]) {\n\t\t\t\tdev_dbg(dev->class_dev,\n\t\t\t\t\t\"bad channel or range number! chanlist[%i]=%d,%d,%d and not %d,%d,%d!\\n\",\n\t\t\t\t\ti, CR_CHAN(chansegment[i]),\n\t\t\t\t\tCR_RANGE(chansegment[i]),\n\t\t\t\t\tCR_AREF(chansegment[i]),\n\t\t\t\t\tCR_CHAN(chanlist[i % seglen]),\n\t\t\t\t\tCR_RANGE(chanlist[i % seglen]),\n\t\t\t\t\tCR_AREF(chansegment[i % seglen]));\n\t\t\t\treturn 0;\t \n\t\t\t}\n\t\t}\n\t} else {\n\t\tseglen = 1;\n\t}\n\treturn seglen;\n}\n\nstatic int check_single_ended(unsigned int port)\n{\n\tif (inb(port + PCL818_STATUS_REG) & PCL818_STATUS_MUX)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,\n\t\t      struct comedi_cmd *cmd)\n{\n\tconst struct pcl818_board *board = dev->board_ptr;\n\tint err = 0;\n\n\t \n\n\terr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW);\n\terr |= comedi_check_trigger_src(&cmd->scan_begin_src, TRIG_FOLLOW);\n\terr |= comedi_check_trigger_src(&cmd->convert_src,\n\t\t\t\t\tTRIG_TIMER | TRIG_EXT);\n\terr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\n\terr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\n\n\tif (err)\n\t\treturn 1;\n\n\t \n\n\terr |= comedi_check_trigger_is_unique(cmd->convert_src);\n\terr |= comedi_check_trigger_is_unique(cmd->stop_src);\n\n\t \n\n\tif (err)\n\t\treturn 2;\n\n\t \n\n\terr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);\n\n\tif (cmd->convert_src == TRIG_TIMER) {\n\t\terr |= comedi_check_trigger_arg_min(&cmd->convert_arg,\n\t\t\t\t\t\t    board->ns_min);\n\t} else {\t \n\t\terr |= comedi_check_trigger_arg_is(&cmd->convert_arg, 0);\n\t}\n\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\n\t\t\t\t\t   cmd->chanlist_len);\n\n\tif (cmd->stop_src == TRIG_COUNT)\n\t\terr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\n\telse\t \n\t\terr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\n\n\tif (err)\n\t\treturn 3;\n\n\t \n\n\tif (cmd->convert_src == TRIG_TIMER) {\n\t\tunsigned int arg = cmd->convert_arg;\n\n\t\tcomedi_8254_cascade_ns_to_timer(dev->pacer, &arg, cmd->flags);\n\t\terr |= comedi_check_trigger_arg_is(&cmd->convert_arg, arg);\n\t}\n\n\tif (err)\n\t\treturn 4;\n\n\t \n\n\tif (cmd->chanlist) {\n\t\tif (!check_channel_list(dev, s, cmd->chanlist,\n\t\t\t\t\tcmd->chanlist_len))\n\t\t\treturn 5;\t \n\t}\n\n\treturn 0;\n}\n\nstatic int pcl818_ai_cmd(struct comedi_device *dev,\n\t\t\t struct comedi_subdevice *s)\n{\n\tstruct pcl818_private *devpriv = dev->private;\n\tstruct comedi_isadma *dma = devpriv->dma;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tunsigned int ctrl = 0;\n\tunsigned int seglen;\n\n\tif (devpriv->ai_cmd_running)\n\t\treturn -EBUSY;\n\n\tseglen = check_channel_list(dev, s, cmd->chanlist, cmd->chanlist_len);\n\tif (seglen < 1)\n\t\treturn -EINVAL;\n\tpcl818_ai_setup_chanlist(dev, cmd->chanlist, seglen);\n\n\tdevpriv->ai_cmd_running = 1;\n\tdevpriv->ai_cmd_canceled = 0;\n\tdevpriv->act_chanlist_pos = 0;\n\n\tif (cmd->convert_src == TRIG_TIMER)\n\t\tctrl |= PCL818_CTRL_PACER_TRIG;\n\telse\n\t\tctrl |= PCL818_CTRL_EXT_TRIG;\n\n\toutb(0, dev->iobase + PCL818_CNTENABLE_REG);\n\n\tif (dma) {\n\t\t \n\t\tdma->cur_dma = 0;\n\t\tpcl818_ai_setup_dma(dev, s, 0);\n\n\t\tctrl |= PCL818_CTRL_INTE | PCL818_CTRL_IRQ(dev->irq) |\n\t\t\tPCL818_CTRL_DMAE;\n\t} else if (devpriv->usefifo) {\n\t\t \n\t\toutb(1, dev->iobase + PCL818_FI_ENABLE);\n\t} else {\n\t\tctrl |= PCL818_CTRL_INTE | PCL818_CTRL_IRQ(dev->irq);\n\t}\n\toutb(ctrl, dev->iobase + PCL818_CTRL_REG);\n\n\tif (cmd->convert_src == TRIG_TIMER) {\n\t\tcomedi_8254_update_divisors(dev->pacer);\n\t\tcomedi_8254_pacer_enable(dev->pacer, 1, 2, true);\n\t}\n\n\treturn 0;\n}\n\nstatic int pcl818_ai_cancel(struct comedi_device *dev,\n\t\t\t    struct comedi_subdevice *s)\n{\n\tstruct pcl818_private *devpriv = dev->private;\n\tstruct comedi_isadma *dma = devpriv->dma;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\n\tif (!devpriv->ai_cmd_running)\n\t\treturn 0;\n\n\tif (dma) {\n\t\tif (cmd->stop_src == TRIG_NONE ||\n\t\t    (cmd->stop_src == TRIG_COUNT &&\n\t\t     s->async->scans_done < cmd->stop_arg)) {\n\t\t\tif (!devpriv->ai_cmd_canceled) {\n\t\t\t\t \n\t\t\t\tdevpriv->ai_cmd_canceled = 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tcomedi_isadma_disable(dma->chan);\n\t}\n\n\toutb(PCL818_CTRL_DISABLE_TRIG, dev->iobase + PCL818_CTRL_REG);\n\tcomedi_8254_pacer_enable(dev->pacer, 1, 2, false);\n\tpcl818_ai_clear_eoc(dev);\n\n\tif (devpriv->usefifo) {\t \n\t\toutb(0, dev->iobase + PCL818_FI_INTCLR);\n\t\toutb(0, dev->iobase + PCL818_FI_FLUSH);\n\t\toutb(0, dev->iobase + PCL818_FI_ENABLE);\n\t}\n\tdevpriv->ai_cmd_running = 0;\n\tdevpriv->ai_cmd_canceled = 0;\n\n\treturn 0;\n}\n\nstatic int pcl818_ai_insn_read(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       struct comedi_insn *insn,\n\t\t\t       unsigned int *data)\n{\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int range = CR_RANGE(insn->chanspec);\n\tint ret = 0;\n\tint i;\n\n\toutb(PCL818_CTRL_SOFT_TRIG, dev->iobase + PCL818_CTRL_REG);\n\n\tpcl818_ai_set_chan_range(dev, chan, range);\n\tpcl818_ai_set_chan_scan(dev, chan, chan);\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\tpcl818_ai_clear_eoc(dev);\n\t\tpcl818_ai_soft_trig(dev);\n\n\t\tret = comedi_timeout(dev, s, insn, pcl818_ai_eoc, 0);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tdata[i] = pcl818_ai_get_sample(dev, s, NULL);\n\t}\n\tpcl818_ai_clear_eoc(dev);\n\n\treturn ret ? ret : insn->n;\n}\n\nstatic int pcl818_ao_insn_write(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tstruct comedi_insn *insn,\n\t\t\t\tunsigned int *data)\n{\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int val = s->readback[chan];\n\tint i;\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\tval = data[i];\n\t\toutb((val & 0x000f) << 4,\n\t\t     dev->iobase + PCL818_AO_LSB_REG(chan));\n\t\toutb((val & 0x0ff0) >> 4,\n\t\t     dev->iobase + PCL818_AO_MSB_REG(chan));\n\t}\n\ts->readback[chan] = val;\n\n\treturn insn->n;\n}\n\nstatic int pcl818_di_insn_bits(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       struct comedi_insn *insn,\n\t\t\t       unsigned int *data)\n{\n\tdata[1] = inb(dev->iobase + PCL818_DO_DI_LSB_REG) |\n\t\t  (inb(dev->iobase + PCL818_DO_DI_MSB_REG) << 8);\n\n\treturn insn->n;\n}\n\nstatic int pcl818_do_insn_bits(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       struct comedi_insn *insn,\n\t\t\t       unsigned int *data)\n{\n\tif (comedi_dio_update_state(s, data)) {\n\t\toutb(s->state & 0xff, dev->iobase + PCL818_DO_DI_LSB_REG);\n\t\toutb((s->state >> 8), dev->iobase + PCL818_DO_DI_MSB_REG);\n\t}\n\n\tdata[1] = s->state;\n\n\treturn insn->n;\n}\n\nstatic void pcl818_reset(struct comedi_device *dev)\n{\n\tconst struct pcl818_board *board = dev->board_ptr;\n\tunsigned int chan;\n\n\t \n\tif (board->has_fifo) {\n\t\toutb(0, dev->iobase + PCL818_FI_INTCLR);\n\t\toutb(0, dev->iobase + PCL818_FI_FLUSH);\n\t\toutb(0, dev->iobase + PCL818_FI_ENABLE);\n\t}\n\n\t \n\toutb(PCL818_CTRL_DISABLE_TRIG, dev->iobase + PCL818_CTRL_REG);\n\tpcl818_ai_clear_eoc(dev);\n\n\tpcl818_ai_set_chan_range(dev, 0, 0);\n\n\t \n\toutb(0, dev->iobase + PCL818_CNTENABLE_REG);\n\n\t \n\tfor (chan = 0; chan < board->n_aochan; chan++) {\n\t\toutb(0, dev->iobase + PCL818_AO_LSB_REG(chan));\n\t\toutb(0, dev->iobase + PCL818_AO_MSB_REG(chan));\n\t}\n\n\t \n\toutb(0, dev->iobase + PCL818_DO_DI_MSB_REG);\n\toutb(0, dev->iobase + PCL818_DO_DI_LSB_REG);\n}\n\nstatic void pcl818_set_ai_range_table(struct comedi_device *dev,\n\t\t\t\t      struct comedi_subdevice *s,\n\t\t\t\t      struct comedi_devconfig *it)\n{\n\tconst struct pcl818_board *board = dev->board_ptr;\n\n\t \n\ts->range_table = board->ai_range_type;\n\n\t \n\tif (board->is_818) {\n\t\tif (it->options[4] == 1 || it->options[4] == 10) {\n\t\t\t \n\t\t\ts->range_table = &range_pcl818l_h_ai;\n\t\t}\n\t} else {\n\t\tswitch (it->options[4]) {\n\t\tcase 0:\n\t\t\ts->range_table = &range_bipolar10;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\ts->range_table = &range_bipolar5;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\ts->range_table = &range_bipolar2_5;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\ts->range_table = &range718_bipolar1;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\ts->range_table = &range718_bipolar0_5;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\ts->range_table = &range_unipolar10;\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\ts->range_table = &range_unipolar5;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\ts->range_table = &range718_unipolar2;\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\ts->range_table = &range718_unipolar1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ts->range_table = &range_unknown;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void pcl818_alloc_dma(struct comedi_device *dev, unsigned int dma_chan)\n{\n\tstruct pcl818_private *devpriv = dev->private;\n\n\t \n\tif (!(dma_chan == 3 || dma_chan == 1))\n\t\treturn;\n\n\t \n\tdevpriv->dma = comedi_isadma_alloc(dev, 2, dma_chan, dma_chan,\n\t\t\t\t\t   PAGE_SIZE * 4, COMEDI_ISADMA_READ);\n}\n\nstatic void pcl818_free_dma(struct comedi_device *dev)\n{\n\tstruct pcl818_private *devpriv = dev->private;\n\n\tif (devpriv)\n\t\tcomedi_isadma_free(devpriv->dma);\n}\n\nstatic int pcl818_attach(struct comedi_device *dev, struct comedi_devconfig *it)\n{\n\tconst struct pcl818_board *board = dev->board_ptr;\n\tstruct pcl818_private *devpriv;\n\tstruct comedi_subdevice *s;\n\tunsigned int osc_base;\n\tint ret;\n\n\tdevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\n\tif (!devpriv)\n\t\treturn -ENOMEM;\n\n\tret = comedi_request_region(dev, it->options[0],\n\t\t\t\t    board->has_fifo ? 0x20 : 0x10);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (it->options[1] >= 2 && it->options[1] <= 7) {\n\t\tret = request_irq(it->options[1], pcl818_interrupt, 0,\n\t\t\t\t  dev->board_name, dev);\n\t\tif (ret == 0)\n\t\t\tdev->irq = it->options[1];\n\t}\n\n\t \n\tif (dev->irq && board->has_fifo && it->options[2] == -1)\n\t\tdevpriv->usefifo = 1;\n\n\t \n\tif (dev->irq && board->has_dma)\n\t\tpcl818_alloc_dma(dev, it->options[2]);\n\n\t \n\tif ((it->options[3] == 0) || (it->options[3] == 10))\n\t\tosc_base = I8254_OSC_BASE_10MHZ;\n\telse\n\t\tosc_base = I8254_OSC_BASE_1MHZ;\n\n\tdev->pacer = comedi_8254_init(dev->iobase + PCL818_TIMER_BASE,\n\t\t\t\t      osc_base, I8254_IO8, 0);\n\tif (!dev->pacer)\n\t\treturn -ENOMEM;\n\n\t \n\tdevpriv->ns_min = board->ns_min;\n\tif (!board->is_818) {\n\t\t \n\t\tif ((it->options[6] == 1) || (it->options[6] == 100))\n\t\t\tdevpriv->ns_min = 10000;\n\t}\n\n\tret = comedi_alloc_subdevices(dev, 4);\n\tif (ret)\n\t\treturn ret;\n\n\ts = &dev->subdevices[0];\n\ts->type\t\t= COMEDI_SUBD_AI;\n\ts->subdev_flags\t= SDF_READABLE;\n\tif (check_single_ended(dev->iobase)) {\n\t\ts->n_chan\t= 16;\n\t\ts->subdev_flags\t|= SDF_COMMON | SDF_GROUND;\n\t} else {\n\t\ts->n_chan\t= 8;\n\t\ts->subdev_flags\t|= SDF_DIFF;\n\t}\n\ts->maxdata\t= 0x0fff;\n\n\tpcl818_set_ai_range_table(dev, s, it);\n\n\ts->insn_read\t= pcl818_ai_insn_read;\n\tif (dev->irq) {\n\t\tdev->read_subdev = s;\n\t\ts->subdev_flags\t|= SDF_CMD_READ;\n\t\ts->len_chanlist\t= s->n_chan;\n\t\ts->do_cmdtest\t= ai_cmdtest;\n\t\ts->do_cmd\t= pcl818_ai_cmd;\n\t\ts->cancel\t= pcl818_ai_cancel;\n\t}\n\n\t \n\ts = &dev->subdevices[1];\n\tif (board->n_aochan) {\n\t\ts->type\t\t= COMEDI_SUBD_AO;\n\t\ts->subdev_flags\t= SDF_WRITABLE | SDF_GROUND;\n\t\ts->n_chan\t= board->n_aochan;\n\t\ts->maxdata\t= 0x0fff;\n\t\ts->range_table\t= &range_unipolar5;\n\t\tif (board->is_818) {\n\t\t\tif ((it->options[4] == 1) || (it->options[4] == 10))\n\t\t\t\ts->range_table = &range_unipolar10;\n\t\t\tif (it->options[4] == 2)\n\t\t\t\ts->range_table = &range_unknown;\n\t\t} else {\n\t\t\tif ((it->options[5] == 1) || (it->options[5] == 10))\n\t\t\t\ts->range_table = &range_unipolar10;\n\t\t\tif (it->options[5] == 2)\n\t\t\t\ts->range_table = &range_unknown;\n\t\t}\n\t\ts->insn_write\t= pcl818_ao_insn_write;\n\n\t\tret = comedi_alloc_subdev_readback(s);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\ts->type\t\t= COMEDI_SUBD_UNUSED;\n\t}\n\n\t \n\ts = &dev->subdevices[2];\n\ts->type\t\t= COMEDI_SUBD_DI;\n\ts->subdev_flags\t= SDF_READABLE;\n\ts->n_chan\t= 16;\n\ts->maxdata\t= 1;\n\ts->range_table\t= &range_digital;\n\ts->insn_bits\t= pcl818_di_insn_bits;\n\n\t \n\ts = &dev->subdevices[3];\n\ts->type\t\t= COMEDI_SUBD_DO;\n\ts->subdev_flags\t= SDF_WRITABLE;\n\ts->n_chan\t= 16;\n\ts->maxdata\t= 1;\n\ts->range_table\t= &range_digital;\n\ts->insn_bits\t= pcl818_do_insn_bits;\n\n\tpcl818_reset(dev);\n\n\treturn 0;\n}\n\nstatic void pcl818_detach(struct comedi_device *dev)\n{\n\tstruct pcl818_private *devpriv = dev->private;\n\n\tif (devpriv) {\n\t\tpcl818_ai_cancel(dev, dev->read_subdev);\n\t\tpcl818_reset(dev);\n\t}\n\tpcl818_free_dma(dev);\n\tcomedi_legacy_detach(dev);\n}\n\nstatic struct comedi_driver pcl818_driver = {\n\t.driver_name\t= \"pcl818\",\n\t.module\t\t= THIS_MODULE,\n\t.attach\t\t= pcl818_attach,\n\t.detach\t\t= pcl818_detach,\n\t.board_name\t= &boardtypes[0].name,\n\t.num_names\t= ARRAY_SIZE(boardtypes),\n\t.offset\t\t= sizeof(struct pcl818_board),\n};\nmodule_comedi_driver(pcl818_driver);\n\nMODULE_AUTHOR(\"Comedi https://www.comedi.org\");\nMODULE_DESCRIPTION(\"Comedi low-level driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}