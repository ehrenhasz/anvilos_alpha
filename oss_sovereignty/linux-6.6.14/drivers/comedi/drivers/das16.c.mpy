{
  "module_name": "das16.c",
  "hash_id": "d44e2e67a02f0e81e41aed54db7851ecd0e6f1d3eeb5d0c77c969be1f3baf5af",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/das16.c",
  "human_readable_source": "\n \n\n \n\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/comedi/comedidev.h>\n#include <linux/comedi/comedi_8255.h>\n#include <linux/comedi/comedi_8254.h>\n#include <linux/comedi/comedi_isadma.h>\n\n#define DAS16_DMA_SIZE 0xff00\t \n\n \n#define DAS16_TRIG_REG\t\t\t0x00\n#define DAS16_AI_LSB_REG\t\t0x00\n#define DAS16_AI_MSB_REG\t\t0x01\n#define DAS16_MUX_REG\t\t\t0x02\n#define DAS16_DIO_REG\t\t\t0x03\n#define DAS16_AO_LSB_REG(x)\t\t((x) ? 0x06 : 0x04)\n#define DAS16_AO_MSB_REG(x)\t\t((x) ? 0x07 : 0x05)\n#define DAS16_STATUS_REG\t\t0x08\n#define DAS16_STATUS_BUSY\t\tBIT(7)\n#define DAS16_STATUS_UNIPOLAR\t\tBIT(6)\n#define DAS16_STATUS_MUXBIT\t\tBIT(5)\n#define DAS16_STATUS_INT\t\tBIT(4)\n#define DAS16_CTRL_REG\t\t\t0x09\n#define DAS16_CTRL_INTE\t\t\tBIT(7)\n#define DAS16_CTRL_IRQ(x)\t\t(((x) & 0x7) << 4)\n#define DAS16_CTRL_DMAE\t\t\tBIT(2)\n#define DAS16_CTRL_PACING_MASK\t\t(3 << 0)\n#define DAS16_CTRL_INT_PACER\t\t(3 << 0)\n#define DAS16_CTRL_EXT_PACER\t\t(2 << 0)\n#define DAS16_CTRL_SOFT_PACER\t\t(0 << 0)\n#define DAS16_PACER_REG\t\t\t0x0a\n#define DAS16_PACER_BURST_LEN(x)\t(((x) & 0xf) << 4)\n#define DAS16_PACER_CTR0\t\tBIT(1)\n#define DAS16_PACER_TRIG0\t\tBIT(0)\n#define DAS16_GAIN_REG\t\t\t0x0b\n#define DAS16_TIMER_BASE_REG\t\t0x0c\t \n\n#define DAS1600_CONV_REG\t\t0x404\n#define DAS1600_CONV_DISABLE\t\tBIT(6)\n#define DAS1600_BURST_REG\t\t0x405\n#define DAS1600_BURST_VAL\t\tBIT(6)\n#define DAS1600_ENABLE_REG\t\t0x406\n#define DAS1600_ENABLE_VAL\t\tBIT(6)\n#define DAS1600_STATUS_REG\t\t0x407\n#define DAS1600_STATUS_BME\t\tBIT(6)\n#define DAS1600_STATUS_ME\t\tBIT(5)\n#define DAS1600_STATUS_CD\t\tBIT(4)\n#define DAS1600_STATUS_WS\t\tBIT(1)\n#define DAS1600_STATUS_CLK_10MHZ\tBIT(0)\n\nstatic const struct comedi_lrange range_das1x01_bip = {\n\t4, {\n\t\tBIP_RANGE(10),\n\t\tBIP_RANGE(1),\n\t\tBIP_RANGE(0.1),\n\t\tBIP_RANGE(0.01)\n\t}\n};\n\nstatic const struct comedi_lrange range_das1x01_unip = {\n\t4, {\n\t\tUNI_RANGE(10),\n\t\tUNI_RANGE(1),\n\t\tUNI_RANGE(0.1),\n\t\tUNI_RANGE(0.01)\n\t}\n};\n\nstatic const struct comedi_lrange range_das1x02_bip = {\n\t4, {\n\t\tBIP_RANGE(10),\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(2.5),\n\t\tBIP_RANGE(1.25)\n\t}\n};\n\nstatic const struct comedi_lrange range_das1x02_unip = {\n\t4, {\n\t\tUNI_RANGE(10),\n\t\tUNI_RANGE(5),\n\t\tUNI_RANGE(2.5),\n\t\tUNI_RANGE(1.25)\n\t}\n};\n\nstatic const struct comedi_lrange range_das16jr = {\n\t9, {\n\t\tBIP_RANGE(10),\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(2.5),\n\t\tBIP_RANGE(1.25),\n\t\tBIP_RANGE(0.625),\n\t\tUNI_RANGE(10),\n\t\tUNI_RANGE(5),\n\t\tUNI_RANGE(2.5),\n\t\tUNI_RANGE(1.25)\n\t}\n};\n\nstatic const struct comedi_lrange range_das16jr_16 = {\n\t8, {\n\t\tBIP_RANGE(10),\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(2.5),\n\t\tBIP_RANGE(1.25),\n\t\tUNI_RANGE(10),\n\t\tUNI_RANGE(5),\n\t\tUNI_RANGE(2.5),\n\t\tUNI_RANGE(1.25)\n\t}\n};\n\nstatic const int das16jr_gainlist[] = { 8, 0, 1, 2, 3, 4, 5, 6, 7 };\nstatic const int das16jr_16_gainlist[] = { 0, 1, 2, 3, 4, 5, 6, 7 };\nstatic const int das1600_gainlist[] = { 0, 1, 2, 3 };\n\nenum {\n\tdas16_pg_none = 0,\n\tdas16_pg_16jr,\n\tdas16_pg_16jr_16,\n\tdas16_pg_1601,\n\tdas16_pg_1602,\n};\n\nstatic const int *const das16_gainlists[] = {\n\tNULL,\n\tdas16jr_gainlist,\n\tdas16jr_16_gainlist,\n\tdas1600_gainlist,\n\tdas1600_gainlist,\n};\n\nstatic const struct comedi_lrange *const das16_ai_uni_lranges[] = {\n\t&range_unknown,\n\t&range_das16jr,\n\t&range_das16jr_16,\n\t&range_das1x01_unip,\n\t&range_das1x02_unip,\n};\n\nstatic const struct comedi_lrange *const das16_ai_bip_lranges[] = {\n\t&range_unknown,\n\t&range_das16jr,\n\t&range_das16jr_16,\n\t&range_das1x01_bip,\n\t&range_das1x02_bip,\n};\n\nstruct das16_board {\n\tconst char *name;\n\tunsigned int ai_maxdata;\n\tunsigned int ai_speed;\t \n\tunsigned int ai_pg;\n\tunsigned int has_ao:1;\n\tunsigned int has_8255:1;\n\n\tunsigned int i8255_offset;\n\n\tunsigned int size;\n\tunsigned int id;\n};\n\nstatic const struct das16_board das16_boards[] = {\n\t{\n\t\t.name\t\t= \"das-16\",\n\t\t.ai_maxdata\t= 0x0fff,\n\t\t.ai_speed\t= 15000,\n\t\t.ai_pg\t\t= das16_pg_none,\n\t\t.has_ao\t\t= 1,\n\t\t.has_8255\t= 1,\n\t\t.i8255_offset\t= 0x10,\n\t\t.size\t\t= 0x14,\n\t\t.id\t\t= 0x00,\n\t}, {\n\t\t.name\t\t= \"das-16g\",\n\t\t.ai_maxdata\t= 0x0fff,\n\t\t.ai_speed\t= 15000,\n\t\t.ai_pg\t\t= das16_pg_none,\n\t\t.has_ao\t\t= 1,\n\t\t.has_8255\t= 1,\n\t\t.i8255_offset\t= 0x10,\n\t\t.size\t\t= 0x14,\n\t\t.id\t\t= 0x00,\n\t}, {\n\t\t.name\t\t= \"das-16f\",\n\t\t.ai_maxdata\t= 0x0fff,\n\t\t.ai_speed\t= 8500,\n\t\t.ai_pg\t\t= das16_pg_none,\n\t\t.has_ao\t\t= 1,\n\t\t.has_8255\t= 1,\n\t\t.i8255_offset\t= 0x10,\n\t\t.size\t\t= 0x14,\n\t\t.id\t\t= 0x00,\n\t}, {\n\t\t.name\t\t= \"cio-das16\",\n\t\t.ai_maxdata\t= 0x0fff,\n\t\t.ai_speed\t= 20000,\n\t\t.ai_pg\t\t= das16_pg_none,\n\t\t.has_ao\t\t= 1,\n\t\t.has_8255\t= 1,\n\t\t.i8255_offset\t= 0x10,\n\t\t.size\t\t= 0x14,\n\t\t.id\t\t= 0x80,\n\t}, {\n\t\t.name\t\t= \"cio-das16/f\",\n\t\t.ai_maxdata\t= 0x0fff,\n\t\t.ai_speed\t= 10000,\n\t\t.ai_pg\t\t= das16_pg_none,\n\t\t.has_ao\t\t= 1,\n\t\t.has_8255\t= 1,\n\t\t.i8255_offset\t= 0x10,\n\t\t.size\t\t= 0x14,\n\t\t.id\t\t= 0x80,\n\t}, {\n\t\t.name\t\t= \"cio-das16/jr\",\n\t\t.ai_maxdata\t= 0x0fff,\n\t\t.ai_speed\t= 7692,\n\t\t.ai_pg\t\t= das16_pg_16jr,\n\t\t.size\t\t= 0x10,\n\t\t.id\t\t= 0x00,\n\t}, {\n\t\t.name\t\t= \"pc104-das16jr\",\n\t\t.ai_maxdata\t= 0x0fff,\n\t\t.ai_speed\t= 3300,\n\t\t.ai_pg\t\t= das16_pg_16jr,\n\t\t.size\t\t= 0x10,\n\t\t.id\t\t= 0x00,\n\t}, {\n\t\t.name\t\t= \"cio-das16jr/16\",\n\t\t.ai_maxdata\t= 0xffff,\n\t\t.ai_speed\t= 10000,\n\t\t.ai_pg\t\t= das16_pg_16jr_16,\n\t\t.size\t\t= 0x10,\n\t\t.id\t\t= 0x00,\n\t}, {\n\t\t.name\t\t= \"pc104-das16jr/16\",\n\t\t.ai_maxdata\t= 0xffff,\n\t\t.ai_speed\t= 10000,\n\t\t.ai_pg\t\t= das16_pg_16jr_16,\n\t\t.size\t\t= 0x10,\n\t\t.id\t\t= 0x00,\n\t}, {\n\t\t.name\t\t= \"das-1201\",\n\t\t.ai_maxdata\t= 0x0fff,\n\t\t.ai_speed\t= 20000,\n\t\t.ai_pg\t\t= das16_pg_none,\n\t\t.has_8255\t= 1,\n\t\t.i8255_offset\t= 0x400,\n\t\t.size\t\t= 0x408,\n\t\t.id\t\t= 0x20,\n\t}, {\n\t\t.name\t\t= \"das-1202\",\n\t\t.ai_maxdata\t= 0x0fff,\n\t\t.ai_speed\t= 10000,\n\t\t.ai_pg\t\t= das16_pg_none,\n\t\t.has_8255\t= 1,\n\t\t.i8255_offset\t= 0x400,\n\t\t.size\t\t= 0x408,\n\t\t.id\t\t= 0x20,\n\t}, {\n\t\t.name\t\t= \"das-1401\",\n\t\t.ai_maxdata\t= 0x0fff,\n\t\t.ai_speed\t= 10000,\n\t\t.ai_pg\t\t= das16_pg_1601,\n\t\t.size\t\t= 0x408,\n\t\t.id\t\t= 0xc0,\n\t}, {\n\t\t.name\t\t= \"das-1402\",\n\t\t.ai_maxdata\t= 0x0fff,\n\t\t.ai_speed\t= 10000,\n\t\t.ai_pg\t\t= das16_pg_1602,\n\t\t.size\t\t= 0x408,\n\t\t.id\t\t= 0xc0,\n\t}, {\n\t\t.name\t\t= \"das-1601\",\n\t\t.ai_maxdata\t= 0x0fff,\n\t\t.ai_speed\t= 10000,\n\t\t.ai_pg\t\t= das16_pg_1601,\n\t\t.has_ao\t\t= 1,\n\t\t.has_8255\t= 1,\n\t\t.i8255_offset\t= 0x400,\n\t\t.size\t\t= 0x408,\n\t\t.id\t\t= 0xc0,\n\t}, {\n\t\t.name\t\t= \"das-1602\",\n\t\t.ai_maxdata\t= 0x0fff,\n\t\t.ai_speed\t= 10000,\n\t\t.ai_pg\t\t= das16_pg_1602,\n\t\t.has_ao\t\t= 1,\n\t\t.has_8255\t= 1,\n\t\t.i8255_offset\t= 0x400,\n\t\t.size\t\t= 0x408,\n\t\t.id\t\t= 0xc0,\n\t}, {\n\t\t.name\t\t= \"cio-das1401/12\",\n\t\t.ai_maxdata\t= 0x0fff,\n\t\t.ai_speed\t= 6250,\n\t\t.ai_pg\t\t= das16_pg_1601,\n\t\t.size\t\t= 0x408,\n\t\t.id\t\t= 0xc0,\n\t}, {\n\t\t.name\t\t= \"cio-das1402/12\",\n\t\t.ai_maxdata\t= 0x0fff,\n\t\t.ai_speed\t= 6250,\n\t\t.ai_pg\t\t= das16_pg_1602,\n\t\t.size\t\t= 0x408,\n\t\t.id\t\t= 0xc0,\n\t}, {\n\t\t.name\t\t= \"cio-das1402/16\",\n\t\t.ai_maxdata\t= 0xffff,\n\t\t.ai_speed\t= 10000,\n\t\t.ai_pg\t\t= das16_pg_1602,\n\t\t.size\t\t= 0x408,\n\t\t.id\t\t= 0xc0,\n\t}, {\n\t\t.name\t\t= \"cio-das1601/12\",\n\t\t.ai_maxdata\t= 0x0fff,\n\t\t.ai_speed\t= 6250,\n\t\t.ai_pg\t\t= das16_pg_1601,\n\t\t.has_ao\t\t= 1,\n\t\t.has_8255\t= 1,\n\t\t.i8255_offset\t= 0x400,\n\t\t.size\t\t= 0x408,\n\t\t.id\t\t= 0xc0,\n\t}, {\n\t\t.name\t\t= \"cio-das1602/12\",\n\t\t.ai_maxdata\t= 0x0fff,\n\t\t.ai_speed\t= 10000,\n\t\t.ai_pg\t\t= das16_pg_1602,\n\t\t.has_ao\t\t= 1,\n\t\t.has_8255\t= 1,\n\t\t.i8255_offset\t= 0x400,\n\t\t.size\t\t= 0x408,\n\t\t.id\t\t= 0xc0,\n\t}, {\n\t\t.name\t\t= \"cio-das1602/16\",\n\t\t.ai_maxdata\t= 0xffff,\n\t\t.ai_speed\t= 10000,\n\t\t.ai_pg\t\t= das16_pg_1602,\n\t\t.has_ao\t\t= 1,\n\t\t.has_8255\t= 1,\n\t\t.i8255_offset\t= 0x400,\n\t\t.size\t\t= 0x408,\n\t\t.id\t\t= 0xc0,\n\t}, {\n\t\t.name\t\t= \"cio-das16/330\",\n\t\t.ai_maxdata\t= 0x0fff,\n\t\t.ai_speed\t= 3030,\n\t\t.ai_pg\t\t= das16_pg_16jr,\n\t\t.size\t\t= 0x14,\n\t\t.id\t\t= 0xf0,\n\t},\n};\n\n \nstatic inline int timer_period(void)\n{\n\treturn HZ / 20;\n}\n\nstruct das16_private_struct {\n\tstruct comedi_isadma\t*dma;\n\tstruct comedi_device\t*dev;\n\tunsigned int\t\tclockbase;\n\tunsigned int\t\tctrl_reg;\n\tunsigned int\t\tdivisor1;\n\tunsigned int\t\tdivisor2;\n\tstruct timer_list\ttimer;\n\tunsigned long\t\textra_iobase;\n\tunsigned int\t\tcan_burst:1;\n\tunsigned int\t\ttimer_running:1;\n};\n\nstatic void das16_ai_setup_dma(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       unsigned int unread_samples)\n{\n\tstruct das16_private_struct *devpriv = dev->private;\n\tstruct comedi_isadma *dma = devpriv->dma;\n\tstruct comedi_isadma_desc *desc = &dma->desc[dma->cur_dma];\n\tunsigned int max_samples = comedi_bytes_to_samples(s, desc->maxsize);\n\tunsigned int nsamples;\n\n\t \n\tnsamples = comedi_nsamples_left(s, max_samples + unread_samples);\n\tif (nsamples > unread_samples) {\n\t\tnsamples -= unread_samples;\n\t\tdesc->size = comedi_samples_to_bytes(s, nsamples);\n\t\tcomedi_isadma_program(desc);\n\t}\n}\n\nstatic void das16_interrupt(struct comedi_device *dev)\n{\n\tstruct das16_private_struct *devpriv = dev->private;\n\tstruct comedi_subdevice *s = dev->read_subdev;\n\tstruct comedi_async *async = s->async;\n\tstruct comedi_cmd *cmd = &async->cmd;\n\tstruct comedi_isadma *dma = devpriv->dma;\n\tstruct comedi_isadma_desc *desc = &dma->desc[dma->cur_dma];\n\tunsigned long spin_flags;\n\tunsigned int residue;\n\tunsigned int nbytes;\n\tunsigned int nsamples;\n\n\tspin_lock_irqsave(&dev->spinlock, spin_flags);\n\tif (!(devpriv->ctrl_reg & DAS16_CTRL_DMAE)) {\n\t\tspin_unlock_irqrestore(&dev->spinlock, spin_flags);\n\t\treturn;\n\t}\n\n\t \n\tresidue = comedi_isadma_disable_on_sample(desc->chan,\n\t\t\t\t\t\t  comedi_bytes_per_sample(s));\n\n\t \n\tif (residue > desc->size) {\n\t\tdev_err(dev->class_dev, \"residue > transfer size!\\n\");\n\t\tasync->events |= COMEDI_CB_ERROR;\n\t\tnbytes = 0;\n\t} else {\n\t\tnbytes = desc->size - residue;\n\t}\n\tnsamples = comedi_bytes_to_samples(s, nbytes);\n\n\t \n\tif (nsamples) {\n\t\tdma->cur_dma = 1 - dma->cur_dma;\n\t\tdas16_ai_setup_dma(dev, s, nsamples);\n\t}\n\n\tspin_unlock_irqrestore(&dev->spinlock, spin_flags);\n\n\tcomedi_buf_write_samples(s, desc->virt_addr, nsamples);\n\n\tif (cmd->stop_src == TRIG_COUNT && async->scans_done >= cmd->stop_arg)\n\t\tasync->events |= COMEDI_CB_EOA;\n\n\tcomedi_handle_events(dev, s);\n}\n\nstatic void das16_timer_interrupt(struct timer_list *t)\n{\n\tstruct das16_private_struct *devpriv = from_timer(devpriv, t, timer);\n\tstruct comedi_device *dev = devpriv->dev;\n\tunsigned long flags;\n\n\tdas16_interrupt(dev);\n\n\tspin_lock_irqsave(&dev->spinlock, flags);\n\tif (devpriv->timer_running)\n\t\tmod_timer(&devpriv->timer, jiffies + timer_period());\n\tspin_unlock_irqrestore(&dev->spinlock, flags);\n}\n\nstatic void das16_ai_set_mux_range(struct comedi_device *dev,\n\t\t\t\t   unsigned int first_chan,\n\t\t\t\t   unsigned int last_chan,\n\t\t\t\t   unsigned int range)\n{\n\tconst struct das16_board *board = dev->board_ptr;\n\n\t \n\toutb(first_chan | (last_chan << 4), dev->iobase + DAS16_MUX_REG);\n\n\t \n\tif (board->ai_pg == das16_pg_none)\n\t\treturn;\n\n\t \n\toutb((das16_gainlists[board->ai_pg])[range],\n\t     dev->iobase + DAS16_GAIN_REG);\n}\n\nstatic int das16_ai_check_chanlist(struct comedi_device *dev,\n\t\t\t\t   struct comedi_subdevice *s,\n\t\t\t\t   struct comedi_cmd *cmd)\n{\n\tunsigned int chan0 = CR_CHAN(cmd->chanlist[0]);\n\tunsigned int range0 = CR_RANGE(cmd->chanlist[0]);\n\tint i;\n\n\tfor (i = 1; i < cmd->chanlist_len; i++) {\n\t\tunsigned int chan = CR_CHAN(cmd->chanlist[i]);\n\t\tunsigned int range = CR_RANGE(cmd->chanlist[i]);\n\n\t\tif (chan != ((chan0 + i) % s->n_chan)) {\n\t\t\tdev_dbg(dev->class_dev,\n\t\t\t\t\"entries in chanlist must be consecutive channels, counting upwards\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (range != range0) {\n\t\t\tdev_dbg(dev->class_dev,\n\t\t\t\t\"entries in chanlist must all have the same gain\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int das16_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,\n\t\t\t  struct comedi_cmd *cmd)\n{\n\tconst struct das16_board *board = dev->board_ptr;\n\tstruct das16_private_struct *devpriv = dev->private;\n\tint err = 0;\n\tunsigned int trig_mask;\n\tunsigned int arg;\n\n\t \n\n\terr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW);\n\n\ttrig_mask = TRIG_FOLLOW;\n\tif (devpriv->can_burst)\n\t\ttrig_mask |= TRIG_TIMER | TRIG_EXT;\n\terr |= comedi_check_trigger_src(&cmd->scan_begin_src, trig_mask);\n\n\ttrig_mask = TRIG_TIMER | TRIG_EXT;\n\tif (devpriv->can_burst)\n\t\ttrig_mask |= TRIG_NOW;\n\terr |= comedi_check_trigger_src(&cmd->convert_src, trig_mask);\n\n\terr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\n\terr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\n\n\tif (err)\n\t\treturn 1;\n\n\t \n\n\terr |= comedi_check_trigger_is_unique(cmd->scan_begin_src);\n\terr |= comedi_check_trigger_is_unique(cmd->convert_src);\n\terr |= comedi_check_trigger_is_unique(cmd->stop_src);\n\n\t \n\n\t \n\tif (cmd->scan_begin_src == TRIG_FOLLOW && cmd->convert_src == TRIG_NOW)\n\t\terr |= -EINVAL;\n\tif (cmd->scan_begin_src != TRIG_FOLLOW && cmd->convert_src != TRIG_NOW)\n\t\terr |= -EINVAL;\n\n\tif (err)\n\t\treturn 2;\n\n\t \n\n\terr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\n\n\tif (cmd->scan_begin_src == TRIG_FOLLOW)\t \n\t\terr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);\n\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\n\t\t\t\t\t   cmd->chanlist_len);\n\n\t \n\tif (cmd->scan_begin_src == TRIG_TIMER) {\n\t\terr |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,\n\t\t\t\t\t\t    board->ai_speed *\n\t\t\t\t\t\t    cmd->chanlist_len);\n\t}\n\n\tif (cmd->convert_src == TRIG_TIMER) {\n\t\terr |= comedi_check_trigger_arg_min(&cmd->convert_arg,\n\t\t\t\t\t\t    board->ai_speed);\n\t}\n\n\tif (cmd->stop_src == TRIG_COUNT)\n\t\terr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\n\telse\t \n\t\terr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\n\n\tif (err)\n\t\treturn 3;\n\n\t \n\tif (cmd->scan_begin_src == TRIG_TIMER) {\n\t\targ = cmd->scan_begin_arg;\n\t\tcomedi_8254_cascade_ns_to_timer(dev->pacer, &arg, cmd->flags);\n\t\terr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, arg);\n\t}\n\tif (cmd->convert_src == TRIG_TIMER) {\n\t\targ = cmd->convert_arg;\n\t\tcomedi_8254_cascade_ns_to_timer(dev->pacer, &arg, cmd->flags);\n\t\terr |= comedi_check_trigger_arg_is(&cmd->convert_arg, arg);\n\t}\n\tif (err)\n\t\treturn 4;\n\n\t \n\tif (cmd->chanlist && cmd->chanlist_len > 0)\n\t\terr |= das16_ai_check_chanlist(dev, s, cmd);\n\n\tif (err)\n\t\treturn 5;\n\n\treturn 0;\n}\n\nstatic unsigned int das16_set_pacer(struct comedi_device *dev, unsigned int ns,\n\t\t\t\t    unsigned int flags)\n{\n\tcomedi_8254_cascade_ns_to_timer(dev->pacer, &ns, flags);\n\tcomedi_8254_update_divisors(dev->pacer);\n\tcomedi_8254_pacer_enable(dev->pacer, 1, 2, true);\n\n\treturn ns;\n}\n\nstatic int das16_cmd_exec(struct comedi_device *dev, struct comedi_subdevice *s)\n{\n\tstruct das16_private_struct *devpriv = dev->private;\n\tstruct comedi_isadma *dma = devpriv->dma;\n\tstruct comedi_async *async = s->async;\n\tstruct comedi_cmd *cmd = &async->cmd;\n\tunsigned int first_chan = CR_CHAN(cmd->chanlist[0]);\n\tunsigned int last_chan = CR_CHAN(cmd->chanlist[cmd->chanlist_len - 1]);\n\tunsigned int range = CR_RANGE(cmd->chanlist[0]);\n\tunsigned int byte;\n\tunsigned long flags;\n\n\tif (cmd->flags & CMDF_PRIORITY) {\n\t\tdev_err(dev->class_dev,\n\t\t\t\"isa dma transfers cannot be performed with CMDF_PRIORITY, aborting\\n\");\n\t\treturn -1;\n\t}\n\n\tif (devpriv->can_burst)\n\t\toutb(DAS1600_CONV_DISABLE, dev->iobase + DAS1600_CONV_REG);\n\n\t \n\tdas16_ai_set_mux_range(dev, first_chan, last_chan, range);\n\n\t \n\tcmd->convert_arg = das16_set_pacer(dev, cmd->convert_arg, cmd->flags);\n\n\t \n\tbyte = 0;\n\tif (devpriv->can_burst) {\n\t\tif (cmd->convert_src == TRIG_NOW) {\n\t\t\toutb(DAS1600_BURST_VAL,\n\t\t\t     dev->iobase + DAS1600_BURST_REG);\n\t\t\t \n\t\t\tbyte |= DAS16_PACER_BURST_LEN(cmd->chanlist_len - 1);\n\t\t} else {\n\t\t\toutb(0, dev->iobase + DAS1600_BURST_REG);\n\t\t}\n\t}\n\toutb(byte, dev->iobase + DAS16_PACER_REG);\n\n\t \n\tdma->cur_dma = 0;\n\tdas16_ai_setup_dma(dev, s, 0);\n\n\t \n\tspin_lock_irqsave(&dev->spinlock, flags);\n\tdevpriv->timer_running = 1;\n\tdevpriv->timer.expires = jiffies + timer_period();\n\tadd_timer(&devpriv->timer);\n\n\t \n\tdevpriv->ctrl_reg &= ~(DAS16_CTRL_INTE | DAS16_CTRL_PACING_MASK);\n\tdevpriv->ctrl_reg |= DAS16_CTRL_DMAE;\n\tif (cmd->convert_src == TRIG_EXT)\n\t\tdevpriv->ctrl_reg |= DAS16_CTRL_EXT_PACER;\n\telse\n\t\tdevpriv->ctrl_reg |= DAS16_CTRL_INT_PACER;\n\toutb(devpriv->ctrl_reg, dev->iobase + DAS16_CTRL_REG);\n\n\tif (devpriv->can_burst)\n\t\toutb(0, dev->iobase + DAS1600_CONV_REG);\n\tspin_unlock_irqrestore(&dev->spinlock, flags);\n\n\treturn 0;\n}\n\nstatic int das16_cancel(struct comedi_device *dev, struct comedi_subdevice *s)\n{\n\tstruct das16_private_struct *devpriv = dev->private;\n\tstruct comedi_isadma *dma = devpriv->dma;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->spinlock, flags);\n\n\t \n\tdevpriv->ctrl_reg &= ~(DAS16_CTRL_INTE | DAS16_CTRL_DMAE |\n\t\t\t       DAS16_CTRL_PACING_MASK);\n\toutb(devpriv->ctrl_reg, dev->iobase + DAS16_CTRL_REG);\n\n\tcomedi_isadma_disable(dma->chan);\n\n\t \n\tif (devpriv->timer_running) {\n\t\tdevpriv->timer_running = 0;\n\t\tdel_timer(&devpriv->timer);\n\t}\n\n\tif (devpriv->can_burst)\n\t\toutb(0, dev->iobase + DAS1600_BURST_REG);\n\n\tspin_unlock_irqrestore(&dev->spinlock, flags);\n\n\treturn 0;\n}\n\nstatic void das16_ai_munge(struct comedi_device *dev,\n\t\t\t   struct comedi_subdevice *s, void *array,\n\t\t\t   unsigned int num_bytes,\n\t\t\t   unsigned int start_chan_index)\n{\n\tunsigned short *data = array;\n\tunsigned int num_samples = comedi_bytes_to_samples(s, num_bytes);\n\tunsigned int i;\n\t__le16 *buf = array;\n\n\tfor (i = 0; i < num_samples; i++) {\n\t\tdata[i] = le16_to_cpu(buf[i]);\n\t\tif (s->maxdata == 0x0fff)\n\t\t\tdata[i] >>= 4;\n\t\tdata[i] &= s->maxdata;\n\t}\n}\n\nstatic int das16_ai_eoc(struct comedi_device *dev,\n\t\t\tstruct comedi_subdevice *s,\n\t\t\tstruct comedi_insn *insn,\n\t\t\tunsigned long context)\n{\n\tunsigned int status;\n\n\tstatus = inb(dev->iobase + DAS16_STATUS_REG);\n\tif ((status & DAS16_STATUS_BUSY) == 0)\n\t\treturn 0;\n\treturn -EBUSY;\n}\n\nstatic int das16_ai_insn_read(struct comedi_device *dev,\n\t\t\t      struct comedi_subdevice *s,\n\t\t\t      struct comedi_insn *insn,\n\t\t\t      unsigned int *data)\n{\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int range = CR_RANGE(insn->chanspec);\n\tunsigned int val;\n\tint ret;\n\tint i;\n\n\t \n\tdas16_ai_set_mux_range(dev, chan, chan, range);\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\t \n\t\toutb_p(0, dev->iobase + DAS16_TRIG_REG);\n\n\t\tret = comedi_timeout(dev, s, insn, das16_ai_eoc, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tval = inb(dev->iobase + DAS16_AI_MSB_REG) << 8;\n\t\tval |= inb(dev->iobase + DAS16_AI_LSB_REG);\n\t\tif (s->maxdata == 0x0fff)\n\t\t\tval >>= 4;\n\t\tval &= s->maxdata;\n\n\t\tdata[i] = val;\n\t}\n\n\treturn insn->n;\n}\n\nstatic int das16_ao_insn_write(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       struct comedi_insn *insn,\n\t\t\t       unsigned int *data)\n{\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tint i;\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\tunsigned int val = data[i];\n\n\t\ts->readback[chan] = val;\n\n\t\tval <<= 4;\n\n\t\toutb(val & 0xff, dev->iobase + DAS16_AO_LSB_REG(chan));\n\t\toutb((val >> 8) & 0xff, dev->iobase + DAS16_AO_MSB_REG(chan));\n\t}\n\n\treturn insn->n;\n}\n\nstatic int das16_di_insn_bits(struct comedi_device *dev,\n\t\t\t      struct comedi_subdevice *s,\n\t\t\t      struct comedi_insn *insn,\n\t\t\t      unsigned int *data)\n{\n\tdata[1] = inb(dev->iobase + DAS16_DIO_REG) & 0xf;\n\n\treturn insn->n;\n}\n\nstatic int das16_do_insn_bits(struct comedi_device *dev,\n\t\t\t      struct comedi_subdevice *s,\n\t\t\t      struct comedi_insn *insn,\n\t\t\t      unsigned int *data)\n{\n\tif (comedi_dio_update_state(s, data))\n\t\toutb(s->state, dev->iobase + DAS16_DIO_REG);\n\n\tdata[1] = s->state;\n\n\treturn insn->n;\n}\n\nstatic int das16_probe(struct comedi_device *dev, struct comedi_devconfig *it)\n{\n\tconst struct das16_board *board = dev->board_ptr;\n\tint diobits;\n\n\t \n\tdiobits = inb(dev->iobase + DAS16_DIO_REG) & 0xf0;\n\tif (board->id != diobits) {\n\t\tdev_err(dev->class_dev,\n\t\t\t\"requested board's id bits are incorrect (0x%x != 0x%x)\\n\",\n\t\t\tboard->id, diobits);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void das16_reset(struct comedi_device *dev)\n{\n\toutb(0, dev->iobase + DAS16_STATUS_REG);\n\toutb(0, dev->iobase + DAS16_CTRL_REG);\n\toutb(0, dev->iobase + DAS16_PACER_REG);\n}\n\nstatic void das16_alloc_dma(struct comedi_device *dev, unsigned int dma_chan)\n{\n\tstruct das16_private_struct *devpriv = dev->private;\n\n\ttimer_setup(&devpriv->timer, das16_timer_interrupt, 0);\n\n\t \n\tif (!(dma_chan == 1 || dma_chan == 3))\n\t\treturn;\n\n\t \n\tdevpriv->dma = comedi_isadma_alloc(dev, 2, dma_chan, dma_chan,\n\t\t\t\t\t   DAS16_DMA_SIZE, COMEDI_ISADMA_READ);\n}\n\nstatic void das16_free_dma(struct comedi_device *dev)\n{\n\tstruct das16_private_struct *devpriv = dev->private;\n\n\tif (devpriv) {\n\t\tdel_timer_sync(&devpriv->timer);\n\t\tcomedi_isadma_free(devpriv->dma);\n\t}\n}\n\nstatic const struct comedi_lrange *das16_ai_range(struct comedi_device *dev,\n\t\t\t\t\t\t  struct comedi_subdevice *s,\n\t\t\t\t\t\t  struct comedi_devconfig *it,\n\t\t\t\t\t\t  unsigned int pg_type,\n\t\t\t\t\t\t  unsigned int status)\n{\n\tunsigned int min = it->options[4];\n\tunsigned int max = it->options[5];\n\n\t \n\tif (pg_type == das16_pg_none && (min || max)) {\n\t\tstruct comedi_lrange *lrange;\n\t\tstruct comedi_krange *krange;\n\n\t\t \n\t\tlrange = comedi_alloc_spriv(s,\n\t\t\t\t\t    struct_size(lrange, range, 1));\n\t\tif (!lrange)\n\t\t\treturn &range_unknown;\n\n\t\t \n\t\tlrange->length = 1;\n\t\tkrange = lrange->range;\n\t\tkrange->min = min;\n\t\tkrange->max = max;\n\t\tkrange->flags = UNIT_volt;\n\n\t\treturn lrange;\n\t}\n\n\t \n\tif (status & DAS16_STATUS_UNIPOLAR)\n\t\treturn das16_ai_uni_lranges[pg_type];\n\treturn das16_ai_bip_lranges[pg_type];\n}\n\nstatic const struct comedi_lrange *das16_ao_range(struct comedi_device *dev,\n\t\t\t\t\t\t  struct comedi_subdevice *s,\n\t\t\t\t\t\t  struct comedi_devconfig *it)\n{\n\tunsigned int min = it->options[6];\n\tunsigned int max = it->options[7];\n\n\t \n\tif (min || max) {\n\t\tstruct comedi_lrange *lrange;\n\t\tstruct comedi_krange *krange;\n\n\t\t \n\t\tlrange = comedi_alloc_spriv(s,\n\t\t\t\t\t    struct_size(lrange, range, 1));\n\t\tif (!lrange)\n\t\t\treturn &range_unknown;\n\n\t\t \n\t\tlrange->length = 1;\n\t\tkrange = lrange->range;\n\t\tkrange->min = min;\n\t\tkrange->max = max;\n\t\tkrange->flags = UNIT_volt;\n\n\t\treturn lrange;\n\t}\n\n\treturn &range_unknown;\n}\n\nstatic int das16_attach(struct comedi_device *dev, struct comedi_devconfig *it)\n{\n\tconst struct das16_board *board = dev->board_ptr;\n\tstruct das16_private_struct *devpriv;\n\tstruct comedi_subdevice *s;\n\tunsigned int osc_base;\n\tunsigned int status;\n\tint ret;\n\n\t \n\tif (it->options[3]) {\n\t\tif (it->options[3] != 1 && it->options[3] != 10) {\n\t\t\tdev_err(dev->class_dev,\n\t\t\t\t\"Invalid option. Master clock must be set to 1 or 10 (MHz)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tdevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\n\tif (!devpriv)\n\t\treturn -ENOMEM;\n\tdevpriv->dev = dev;\n\n\tif (board->size < 0x400) {\n\t\tret = comedi_request_region(dev, it->options[0], board->size);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tret = comedi_request_region(dev, it->options[0], 0x10);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t \n\t\tret = __comedi_request_region(dev, dev->iobase + 0x400,\n\t\t\t\t\t      board->size & 0x3ff);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tdevpriv->extra_iobase = dev->iobase + 0x400;\n\t\tdevpriv->can_burst = 1;\n\t}\n\n\t \n\tif (das16_probe(dev, it))\n\t\treturn -EINVAL;\n\n\t \n\tosc_base = I8254_OSC_BASE_1MHZ;\n\tif (devpriv->can_burst) {\n\t\tstatus = inb(dev->iobase + DAS1600_STATUS_REG);\n\t\tif (status & DAS1600_STATUS_CLK_10MHZ)\n\t\t\tosc_base = I8254_OSC_BASE_10MHZ;\n\t} else {\n\t\tif (it->options[3])\n\t\t\tosc_base = I8254_OSC_BASE_1MHZ / it->options[3];\n\t}\n\n\tdev->pacer = comedi_8254_init(dev->iobase + DAS16_TIMER_BASE_REG,\n\t\t\t\t      osc_base, I8254_IO8, 0);\n\tif (!dev->pacer)\n\t\treturn -ENOMEM;\n\n\tdas16_alloc_dma(dev, it->options[2]);\n\n\tret = comedi_alloc_subdevices(dev, 4 + board->has_8255);\n\tif (ret)\n\t\treturn ret;\n\n\tstatus = inb(dev->iobase + DAS16_STATUS_REG);\n\n\t \n\ts = &dev->subdevices[0];\n\ts->type\t\t= COMEDI_SUBD_AI;\n\ts->subdev_flags\t= SDF_READABLE;\n\tif (status & DAS16_STATUS_MUXBIT) {\n\t\ts->subdev_flags\t|= SDF_GROUND;\n\t\ts->n_chan\t= 16;\n\t} else {\n\t\ts->subdev_flags\t|= SDF_DIFF;\n\t\ts->n_chan\t= 8;\n\t}\n\ts->len_chanlist\t= s->n_chan;\n\ts->maxdata\t= board->ai_maxdata;\n\ts->range_table\t= das16_ai_range(dev, s, it, board->ai_pg, status);\n\ts->insn_read\t= das16_ai_insn_read;\n\tif (devpriv->dma) {\n\t\tdev->read_subdev = s;\n\t\ts->subdev_flags\t|= SDF_CMD_READ;\n\t\ts->do_cmdtest\t= das16_cmd_test;\n\t\ts->do_cmd\t= das16_cmd_exec;\n\t\ts->cancel\t= das16_cancel;\n\t\ts->munge\t= das16_ai_munge;\n\t}\n\n\t \n\ts = &dev->subdevices[1];\n\tif (board->has_ao) {\n\t\ts->type\t\t= COMEDI_SUBD_AO;\n\t\ts->subdev_flags\t= SDF_WRITABLE;\n\t\ts->n_chan\t= 2;\n\t\ts->maxdata\t= 0x0fff;\n\t\ts->range_table\t= das16_ao_range(dev, s, it);\n\t\ts->insn_write\t= das16_ao_insn_write;\n\n\t\tret = comedi_alloc_subdev_readback(s);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\ts->type\t\t= COMEDI_SUBD_UNUSED;\n\t}\n\n\t \n\ts = &dev->subdevices[2];\n\ts->type\t\t= COMEDI_SUBD_DI;\n\ts->subdev_flags\t= SDF_READABLE;\n\ts->n_chan\t= 4;\n\ts->maxdata\t= 1;\n\ts->range_table\t= &range_digital;\n\ts->insn_bits\t= das16_di_insn_bits;\n\n\t \n\ts = &dev->subdevices[3];\n\ts->type\t\t= COMEDI_SUBD_DO;\n\ts->subdev_flags\t= SDF_WRITABLE;\n\ts->n_chan\t= 4;\n\ts->maxdata\t= 1;\n\ts->range_table\t= &range_digital;\n\ts->insn_bits\t= das16_do_insn_bits;\n\n\t \n\toutb(s->state, dev->iobase + DAS16_DIO_REG);\n\n\t \n\tif (board->has_8255) {\n\t\ts = &dev->subdevices[4];\n\t\tret = subdev_8255_init(dev, s, NULL, board->i8255_offset);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tdas16_reset(dev);\n\t \n\tdevpriv->ctrl_reg = DAS16_CTRL_IRQ(dev->irq);\n\toutb(devpriv->ctrl_reg, dev->iobase + DAS16_CTRL_REG);\n\n\tif (devpriv->can_burst) {\n\t\toutb(DAS1600_ENABLE_VAL, dev->iobase + DAS1600_ENABLE_REG);\n\t\toutb(0, dev->iobase + DAS1600_CONV_REG);\n\t\toutb(0, dev->iobase + DAS1600_BURST_REG);\n\t}\n\n\treturn 0;\n}\n\nstatic void das16_detach(struct comedi_device *dev)\n{\n\tconst struct das16_board *board = dev->board_ptr;\n\tstruct das16_private_struct *devpriv = dev->private;\n\n\tif (devpriv) {\n\t\tif (dev->iobase)\n\t\t\tdas16_reset(dev);\n\t\tdas16_free_dma(dev);\n\n\t\tif (devpriv->extra_iobase)\n\t\t\trelease_region(devpriv->extra_iobase,\n\t\t\t\t       board->size & 0x3ff);\n\t}\n\n\tcomedi_legacy_detach(dev);\n}\n\nstatic struct comedi_driver das16_driver = {\n\t.driver_name\t= \"das16\",\n\t.module\t\t= THIS_MODULE,\n\t.attach\t\t= das16_attach,\n\t.detach\t\t= das16_detach,\n\t.board_name\t= &das16_boards[0].name,\n\t.num_names\t= ARRAY_SIZE(das16_boards),\n\t.offset\t\t= sizeof(das16_boards[0]),\n};\nmodule_comedi_driver(das16_driver);\n\nMODULE_AUTHOR(\"Comedi https://www.comedi.org\");\nMODULE_DESCRIPTION(\"Comedi driver for DAS16 compatible boards\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}