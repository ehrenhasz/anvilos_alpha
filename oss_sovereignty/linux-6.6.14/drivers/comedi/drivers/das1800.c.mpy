{
  "module_name": "das1800.c",
  "hash_id": "4a736acddbd65411c607d0bb2d8e3485aa0f99e0e3c9561888dbec4b216866e9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/das1800.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/comedi/comedidev.h>\n#include <linux/comedi/comedi_8254.h>\n#include <linux/comedi/comedi_isadma.h>\n\n \n#define DAS1800_SIZE           16\t \n#define FIFO_SIZE              1024\t \n#define DMA_BUF_SIZE           0x1ff00\t \n\n \n#define DAS1800_FIFO            0x0\n#define DAS1800_QRAM            0x0\n#define DAS1800_DAC             0x0\n#define DAS1800_SELECT          0x2\n#define   ADC                     0x0\n#define   QRAM                    0x1\n#define   DAC(a)                  (0x2 + a)\n#define DAS1800_DIGITAL         0x3\n#define DAS1800_CONTROL_A       0x4\n#define   FFEN                    0x1\n#define   CGEN                    0x4\n#define   CGSL                    0x8\n#define   TGEN                    0x10\n#define   TGSL                    0x20\n#define   TGPL                    0x40\n#define   ATEN                    0x80\n#define DAS1800_CONTROL_B       0x5\n#define   DMA_CH5                 0x1\n#define   DMA_CH6                 0x2\n#define   DMA_CH7                 0x3\n#define   DMA_CH5_CH6             0x5\n#define   DMA_CH6_CH7             0x6\n#define   DMA_CH7_CH5             0x7\n#define   DMA_ENABLED             0x3\n#define   DMA_DUAL                0x4\n#define   IRQ3                    0x8\n#define   IRQ5                    0x10\n#define   IRQ7                    0x18\n#define   IRQ10                   0x28\n#define   IRQ11                   0x30\n#define   IRQ15                   0x38\n#define   FIMD                    0x40\n#define DAS1800_CONTROL_C       0X6\n#define   IPCLK                   0x1\n#define   XPCLK                   0x3\n#define   BMDE                    0x4\n#define   CMEN                    0x8\n#define   UQEN                    0x10\n#define   SD                      0x40\n#define   UB                      0x80\n#define DAS1800_STATUS          0x7\n#define   INT                     0x1\n#define   DMATC                   0x2\n#define   CT0TC                   0x8\n#define   OVF                     0x10\n#define   FHF                     0x20\n#define   FNE                     0x40\n#define   CVEN                    0x80\n#define   CVEN_MASK               0x40\n#define   CLEAR_INTR_MASK         (CVEN_MASK | 0x1f)\n#define DAS1800_BURST_LENGTH    0x8\n#define DAS1800_BURST_RATE      0x9\n#define DAS1800_QRAM_ADDRESS    0xa\n#define DAS1800_COUNTER         0xc\n\n#define IOBASE2                   0x400\n\nstatic const struct comedi_lrange das1801_ai_range = {\n\t8, {\n\t\tBIP_RANGE(5),\t\t \n\t\tBIP_RANGE(1),\t\t \n\t\tBIP_RANGE(0.1),\t\t \n\t\tBIP_RANGE(0.02),\t \n\t\tUNI_RANGE(5),\t\t \n\t\tUNI_RANGE(1),\t\t \n\t\tUNI_RANGE(0.1),\t\t \n\t\tUNI_RANGE(0.02)\t\t \n\t}\n};\n\nstatic const struct comedi_lrange das1802_ai_range = {\n\t8, {\n\t\tBIP_RANGE(10),\t\t \n\t\tBIP_RANGE(5),\t\t \n\t\tBIP_RANGE(2.5),\t\t \n\t\tBIP_RANGE(1.25),\t \n\t\tUNI_RANGE(10),\t\t \n\t\tUNI_RANGE(5),\t\t \n\t\tUNI_RANGE(2.5),\t\t \n\t\tUNI_RANGE(1.25)\t\t \n\t}\n};\n\n \n\nenum das1800_boardid {\n\tBOARD_DAS1701ST,\n\tBOARD_DAS1701ST_DA,\n\tBOARD_DAS1702ST,\n\tBOARD_DAS1702ST_DA,\n\tBOARD_DAS1702HR,\n\tBOARD_DAS1702HR_DA,\n\tBOARD_DAS1701AO,\n\tBOARD_DAS1702AO,\n\tBOARD_DAS1801ST,\n\tBOARD_DAS1801ST_DA,\n\tBOARD_DAS1802ST,\n\tBOARD_DAS1802ST_DA,\n\tBOARD_DAS1802HR,\n\tBOARD_DAS1802HR_DA,\n\tBOARD_DAS1801HC,\n\tBOARD_DAS1802HC,\n\tBOARD_DAS1801AO,\n\tBOARD_DAS1802AO\n};\n\n \n#define DAS1800_ID_ST_DA\t\t0x3\n#define DAS1800_ID_HR_DA\t\t0x4\n#define DAS1800_ID_AO\t\t\t0x5\n#define DAS1800_ID_HR\t\t\t0x6\n#define DAS1800_ID_ST\t\t\t0x7\n#define DAS1800_ID_HC\t\t\t0x8\n\nstruct das1800_board {\n\tconst char *name;\n\tunsigned char id;\n\tunsigned int ai_speed;\n\tunsigned int is_01_series:1;\n};\n\nstatic const struct das1800_board das1800_boards[] = {\n\t[BOARD_DAS1701ST] = {\n\t\t.name\t\t= \"das-1701st\",\n\t\t.id\t\t= DAS1800_ID_ST,\n\t\t.ai_speed\t= 6250,\n\t\t.is_01_series\t= 1,\n\t},\n\t[BOARD_DAS1701ST_DA] = {\n\t\t.name\t\t= \"das-1701st-da\",\n\t\t.id\t\t= DAS1800_ID_ST_DA,\n\t\t.ai_speed\t= 6250,\n\t\t.is_01_series\t= 1,\n\t},\n\t[BOARD_DAS1702ST] = {\n\t\t.name\t\t= \"das-1702st\",\n\t\t.id\t\t= DAS1800_ID_ST,\n\t\t.ai_speed\t= 6250,\n\t},\n\t[BOARD_DAS1702ST_DA] = {\n\t\t.name\t\t= \"das-1702st-da\",\n\t\t.id\t\t= DAS1800_ID_ST_DA,\n\t\t.ai_speed\t= 6250,\n\t},\n\t[BOARD_DAS1702HR] = {\n\t\t.name\t\t= \"das-1702hr\",\n\t\t.id\t\t= DAS1800_ID_HR,\n\t\t.ai_speed\t= 20000,\n\t},\n\t[BOARD_DAS1702HR_DA] = {\n\t\t.name\t\t= \"das-1702hr-da\",\n\t\t.id\t\t= DAS1800_ID_HR_DA,\n\t\t.ai_speed\t= 20000,\n\t},\n\t[BOARD_DAS1701AO] = {\n\t\t.name\t\t= \"das-1701ao\",\n\t\t.id\t\t= DAS1800_ID_AO,\n\t\t.ai_speed\t= 6250,\n\t\t.is_01_series\t= 1,\n\t},\n\t[BOARD_DAS1702AO] = {\n\t\t.name\t\t= \"das-1702ao\",\n\t\t.id\t\t= DAS1800_ID_AO,\n\t\t.ai_speed\t= 6250,\n\t},\n\t[BOARD_DAS1801ST] = {\n\t\t.name\t\t= \"das-1801st\",\n\t\t.id\t\t= DAS1800_ID_ST,\n\t\t.ai_speed\t= 3000,\n\t\t.is_01_series\t= 1,\n\t},\n\t[BOARD_DAS1801ST_DA] = {\n\t\t.name\t\t= \"das-1801st-da\",\n\t\t.id\t\t= DAS1800_ID_ST_DA,\n\t\t.ai_speed\t= 3000,\n\t\t.is_01_series\t= 1,\n\t},\n\t[BOARD_DAS1802ST] = {\n\t\t.name\t\t= \"das-1802st\",\n\t\t.id\t\t= DAS1800_ID_ST,\n\t\t.ai_speed\t= 3000,\n\t},\n\t[BOARD_DAS1802ST_DA] = {\n\t\t.name\t\t= \"das-1802st-da\",\n\t\t.id\t\t= DAS1800_ID_ST_DA,\n\t\t.ai_speed\t= 3000,\n\t},\n\t[BOARD_DAS1802HR] = {\n\t\t.name\t\t= \"das-1802hr\",\n\t\t.id\t\t= DAS1800_ID_HR,\n\t\t.ai_speed\t= 10000,\n\t},\n\t[BOARD_DAS1802HR_DA] = {\n\t\t.name\t\t= \"das-1802hr-da\",\n\t\t.id\t\t= DAS1800_ID_HR_DA,\n\t\t.ai_speed\t= 10000,\n\t},\n\t[BOARD_DAS1801HC] = {\n\t\t.name\t\t= \"das-1801hc\",\n\t\t.id\t\t= DAS1800_ID_HC,\n\t\t.ai_speed\t= 3000,\n\t\t.is_01_series\t= 1,\n\t},\n\t[BOARD_DAS1802HC] = {\n\t\t.name\t\t= \"das-1802hc\",\n\t\t.id\t\t= DAS1800_ID_HC,\n\t\t.ai_speed\t= 3000,\n\t},\n\t[BOARD_DAS1801AO] = {\n\t\t.name\t\t= \"das-1801ao\",\n\t\t.id\t\t= DAS1800_ID_AO,\n\t\t.ai_speed\t= 3000,\n\t\t.is_01_series\t= 1,\n\t},\n\t[BOARD_DAS1802AO] = {\n\t\t.name\t\t= \"das-1802ao\",\n\t\t.id\t\t= DAS1800_ID_AO,\n\t\t.ai_speed\t= 3000,\n\t},\n};\n\nstruct das1800_private {\n\tstruct comedi_isadma *dma;\n\tint irq_dma_bits;\n\tint dma_bits;\n\tunsigned short *fifo_buf;\n\tunsigned long iobase2;\n\tbool ai_is_unipolar;\n};\n\nstatic void das1800_ai_munge(struct comedi_device *dev,\n\t\t\t     struct comedi_subdevice *s,\n\t\t\t     void *data, unsigned int num_bytes,\n\t\t\t     unsigned int start_chan_index)\n{\n\tstruct das1800_private *devpriv = dev->private;\n\tunsigned short *array = data;\n\tunsigned int num_samples = comedi_bytes_to_samples(s, num_bytes);\n\tunsigned int i;\n\n\tif (devpriv->ai_is_unipolar)\n\t\treturn;\n\n\tfor (i = 0; i < num_samples; i++)\n\t\tarray[i] = comedi_offset_munge(s, array[i]);\n}\n\nstatic void das1800_handle_fifo_half_full(struct comedi_device *dev,\n\t\t\t\t\t  struct comedi_subdevice *s)\n{\n\tstruct das1800_private *devpriv = dev->private;\n\tunsigned int nsamples = comedi_nsamples_left(s, FIFO_SIZE / 2);\n\n\tinsw(dev->iobase + DAS1800_FIFO, devpriv->fifo_buf, nsamples);\n\tcomedi_buf_write_samples(s, devpriv->fifo_buf, nsamples);\n}\n\nstatic void das1800_handle_fifo_not_empty(struct comedi_device *dev,\n\t\t\t\t\t  struct comedi_subdevice *s)\n{\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tunsigned short dpnt;\n\n\twhile (inb(dev->iobase + DAS1800_STATUS) & FNE) {\n\t\tdpnt = inw(dev->iobase + DAS1800_FIFO);\n\t\tcomedi_buf_write_samples(s, &dpnt, 1);\n\n\t\tif (cmd->stop_src == TRIG_COUNT &&\n\t\t    s->async->scans_done >= cmd->stop_arg)\n\t\t\tbreak;\n\t}\n}\n\nstatic void das1800_flush_dma_channel(struct comedi_device *dev,\n\t\t\t\t      struct comedi_subdevice *s,\n\t\t\t\t      struct comedi_isadma_desc *desc)\n{\n\tunsigned int residue = comedi_isadma_disable(desc->chan);\n\tunsigned int nbytes = desc->size - residue;\n\tunsigned int nsamples;\n\n\t \n\tnsamples = comedi_bytes_to_samples(s, nbytes);\n\tnsamples = comedi_nsamples_left(s, nsamples);\n\n\tcomedi_buf_write_samples(s, desc->virt_addr, nsamples);\n}\n\nstatic void das1800_flush_dma(struct comedi_device *dev,\n\t\t\t      struct comedi_subdevice *s)\n{\n\tstruct das1800_private *devpriv = dev->private;\n\tstruct comedi_isadma *dma = devpriv->dma;\n\tstruct comedi_isadma_desc *desc = &dma->desc[dma->cur_dma];\n\tconst int dual_dma = devpriv->irq_dma_bits & DMA_DUAL;\n\n\tdas1800_flush_dma_channel(dev, s, desc);\n\n\tif (dual_dma) {\n\t\t \n\t\tdma->cur_dma = 1 - dma->cur_dma;\n\t\tdesc = &dma->desc[dma->cur_dma];\n\t\tdas1800_flush_dma_channel(dev, s, desc);\n\t}\n\n\t \n\tdas1800_handle_fifo_not_empty(dev, s);\n}\n\nstatic void das1800_handle_dma(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s, unsigned int status)\n{\n\tstruct das1800_private *devpriv = dev->private;\n\tstruct comedi_isadma *dma = devpriv->dma;\n\tstruct comedi_isadma_desc *desc = &dma->desc[dma->cur_dma];\n\tconst int dual_dma = devpriv->irq_dma_bits & DMA_DUAL;\n\n\tdas1800_flush_dma_channel(dev, s, desc);\n\n\t \n\tcomedi_isadma_program(desc);\n\n\tif (status & DMATC) {\n\t\t \n\t\toutb(CLEAR_INTR_MASK & ~DMATC, dev->iobase + DAS1800_STATUS);\n\t\t \n\t\tif (dual_dma)\n\t\t\tdma->cur_dma = 1 - dma->cur_dma;\n\t}\n}\n\nstatic int das1800_ai_cancel(struct comedi_device *dev,\n\t\t\t     struct comedi_subdevice *s)\n{\n\tstruct das1800_private *devpriv = dev->private;\n\tstruct comedi_isadma *dma = devpriv->dma;\n\tstruct comedi_isadma_desc *desc;\n\tint i;\n\n\t \n\toutb(0x0, dev->iobase + DAS1800_STATUS);\n\toutb(0x0, dev->iobase + DAS1800_CONTROL_B);\n\toutb(0x0, dev->iobase + DAS1800_CONTROL_A);\n\n\tif (dma) {\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tdesc = &dma->desc[i];\n\t\t\tif (desc->chan)\n\t\t\t\tcomedi_isadma_disable(desc->chan);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void das1800_ai_handler(struct comedi_device *dev)\n{\n\tstruct das1800_private *devpriv = dev->private;\n\tstruct comedi_subdevice *s = dev->read_subdev;\n\tstruct comedi_async *async = s->async;\n\tstruct comedi_cmd *cmd = &async->cmd;\n\tunsigned int status = inb(dev->iobase + DAS1800_STATUS);\n\n\t \n\toutb(ADC, dev->iobase + DAS1800_SELECT);\n\n\t \n\tif (devpriv->irq_dma_bits & DMA_ENABLED)\n\t\tdas1800_handle_dma(dev, s, status);\n\telse if (status & FHF)\n\t\tdas1800_handle_fifo_half_full(dev, s);\n\telse if (status & FNE)\n\t\tdas1800_handle_fifo_not_empty(dev, s);\n\n\t \n\tif (status & OVF) {\n\t\t \n\t\toutb(CLEAR_INTR_MASK & ~OVF, dev->iobase + DAS1800_STATUS);\n\t\tdev_err(dev->class_dev, \"FIFO overflow\\n\");\n\t\tasync->events |= COMEDI_CB_ERROR;\n\t\tcomedi_handle_events(dev, s);\n\t\treturn;\n\t}\n\t \n\t \n\tif (status & CT0TC) {\n\t\t \n\t\toutb(CLEAR_INTR_MASK & ~CT0TC, dev->iobase + DAS1800_STATUS);\n\t\t \n\t\tif (devpriv->irq_dma_bits & DMA_ENABLED)\n\t\t\tdas1800_flush_dma(dev, s);\n\t\telse\n\t\t\tdas1800_handle_fifo_not_empty(dev, s);\n\t\tasync->events |= COMEDI_CB_EOA;\n\t} else if (cmd->stop_src == TRIG_COUNT &&\n\t\t   async->scans_done >= cmd->stop_arg) {\n\t\tasync->events |= COMEDI_CB_EOA;\n\t}\n\n\tcomedi_handle_events(dev, s);\n}\n\nstatic int das1800_ai_poll(struct comedi_device *dev,\n\t\t\t   struct comedi_subdevice *s)\n{\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&dev->spinlock, flags);\n\n\tdas1800_ai_handler(dev);\n\n\tspin_unlock_irqrestore(&dev->spinlock, flags);\n\n\treturn comedi_buf_n_bytes_ready(s);\n}\n\nstatic irqreturn_t das1800_interrupt(int irq, void *d)\n{\n\tstruct comedi_device *dev = d;\n\tunsigned int status;\n\n\tif (!dev->attached) {\n\t\tdev_err(dev->class_dev, \"premature interrupt\\n\");\n\t\treturn IRQ_HANDLED;\n\t}\n\n\t \n\tspin_lock(&dev->spinlock);\n\n\tstatus = inb(dev->iobase + DAS1800_STATUS);\n\n\t \n\tif (!(status & INT)) {\n\t\tspin_unlock(&dev->spinlock);\n\t\treturn IRQ_NONE;\n\t}\n\t \n\toutb(CLEAR_INTR_MASK & ~INT, dev->iobase + DAS1800_STATUS);\n\t \n\tdas1800_ai_handler(dev);\n\n\tspin_unlock(&dev->spinlock);\n\treturn IRQ_HANDLED;\n}\n\nstatic int das1800_ai_fixup_paced_timing(struct comedi_device *dev,\n\t\t\t\t\t struct comedi_cmd *cmd)\n{\n\tunsigned int arg = cmd->convert_arg;\n\n\t \n\tcomedi_8254_cascade_ns_to_timer(dev->pacer, &arg, cmd->flags);\n\treturn comedi_check_trigger_arg_is(&cmd->convert_arg, arg);\n}\n\nstatic int das1800_ai_fixup_burst_timing(struct comedi_device *dev,\n\t\t\t\t\t struct comedi_cmd *cmd)\n{\n\tunsigned int arg = cmd->convert_arg;\n\tint err = 0;\n\n\t \n\terr |= comedi_check_trigger_arg_max(&arg, 64000);\n\n\t \n\tswitch (cmd->flags & CMDF_ROUND_MASK) {\n\tcase CMDF_ROUND_NEAREST:\n\tdefault:\n\t\targ = DIV_ROUND_CLOSEST(arg, 1000);\n\t\tbreak;\n\tcase CMDF_ROUND_DOWN:\n\t\targ = arg / 1000;\n\t\tbreak;\n\tcase CMDF_ROUND_UP:\n\t\targ = DIV_ROUND_UP(arg, 1000);\n\t\tbreak;\n\t}\n\terr |= comedi_check_trigger_arg_is(&cmd->convert_arg, arg * 1000);\n\n\t \n\tif (cmd->scan_begin_src == TRIG_TIMER) {\n\t\targ = cmd->convert_arg * cmd->chanlist_len;\n\t\terr |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg, arg);\n\n\t\targ = cmd->scan_begin_arg;\n\t\tcomedi_8254_cascade_ns_to_timer(dev->pacer, &arg, cmd->flags);\n\t\terr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, arg);\n\t}\n\n\treturn err;\n}\n\nstatic int das1800_ai_check_chanlist(struct comedi_device *dev,\n\t\t\t\t     struct comedi_subdevice *s,\n\t\t\t\t     struct comedi_cmd *cmd)\n{\n\tunsigned int range = CR_RANGE(cmd->chanlist[0]);\n\tbool unipolar0 = comedi_range_is_unipolar(s, range);\n\tint i;\n\n\tfor (i = 1; i < cmd->chanlist_len; i++) {\n\t\trange = CR_RANGE(cmd->chanlist[i]);\n\n\t\tif (unipolar0 != comedi_range_is_unipolar(s, range)) {\n\t\t\tdev_dbg(dev->class_dev,\n\t\t\t\t\"unipolar and bipolar ranges cannot be mixed in the chanlist\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int das1800_ai_cmdtest(struct comedi_device *dev,\n\t\t\t      struct comedi_subdevice *s,\n\t\t\t      struct comedi_cmd *cmd)\n{\n\tconst struct das1800_board *board = dev->board_ptr;\n\tint err = 0;\n\n\t \n\n\terr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_EXT);\n\terr |= comedi_check_trigger_src(&cmd->scan_begin_src,\n\t\t\t\t\tTRIG_FOLLOW | TRIG_TIMER | TRIG_EXT);\n\terr |= comedi_check_trigger_src(&cmd->convert_src,\n\t\t\t\t\tTRIG_TIMER | TRIG_EXT);\n\terr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\n\terr |= comedi_check_trigger_src(&cmd->stop_src,\n\t\t\t\t\tTRIG_COUNT | TRIG_EXT | TRIG_NONE);\n\n\tif (err)\n\t\treturn 1;\n\n\t \n\n\terr |= comedi_check_trigger_is_unique(cmd->start_src);\n\terr |= comedi_check_trigger_is_unique(cmd->scan_begin_src);\n\terr |= comedi_check_trigger_is_unique(cmd->convert_src);\n\terr |= comedi_check_trigger_is_unique(cmd->stop_src);\n\n\t \n\n\t \n\tif (cmd->scan_begin_src != TRIG_FOLLOW &&\n\t    cmd->convert_src != TRIG_TIMER)\n\t\terr |= -EINVAL;\n\n\t \n\tif (cmd->start_src == TRIG_EXT && cmd->stop_src == TRIG_EXT)\n\t\terr |= comedi_check_trigger_arg_is(&cmd->start_arg,\n\t\t\t\t\t\t   cmd->stop_arg);\n\n\tif (err)\n\t\treturn 2;\n\n\t \n\n\tif (cmd->start_arg == TRIG_NOW)\n\t\terr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\n\n\tif (cmd->convert_src == TRIG_TIMER) {\n\t\terr |= comedi_check_trigger_arg_min(&cmd->convert_arg,\n\t\t\t\t\t\t    board->ai_speed);\n\t}\n\n\terr |= comedi_check_trigger_arg_min(&cmd->chanlist_len, 1);\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\n\t\t\t\t\t   cmd->chanlist_len);\n\n\tswitch (cmd->stop_src) {\n\tcase TRIG_COUNT:\n\t\terr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\n\t\tbreak;\n\tcase TRIG_NONE:\n\t\terr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (err)\n\t\treturn 3;\n\n\t \n\n\tif (cmd->convert_src == TRIG_TIMER) {\n\t\tif (cmd->scan_begin_src == TRIG_FOLLOW)\n\t\t\terr |= das1800_ai_fixup_paced_timing(dev, cmd);\n\t\telse  \n\t\t\terr |= das1800_ai_fixup_burst_timing(dev, cmd);\n\t}\n\n\tif (err)\n\t\treturn 4;\n\n\t \n\tif (cmd->chanlist && cmd->chanlist_len > 0)\n\t\terr |= das1800_ai_check_chanlist(dev, s, cmd);\n\n\tif (err)\n\t\treturn 5;\n\n\treturn 0;\n}\n\nstatic unsigned char das1800_ai_chanspec_bits(struct comedi_subdevice *s,\n\t\t\t\t\t      unsigned int chanspec)\n{\n\tunsigned int range = CR_RANGE(chanspec);\n\tunsigned int aref = CR_AREF(chanspec);\n\tunsigned char bits;\n\n\tbits = UQEN;\n\tif (aref != AREF_DIFF)\n\t\tbits |= SD;\n\tif (aref == AREF_COMMON)\n\t\tbits |= CMEN;\n\tif (comedi_range_is_unipolar(s, range))\n\t\tbits |= UB;\n\n\treturn bits;\n}\n\nstatic unsigned int das1800_ai_transfer_size(struct comedi_device *dev,\n\t\t\t\t\t     struct comedi_subdevice *s,\n\t\t\t\t\t     unsigned int maxbytes,\n\t\t\t\t\t     unsigned int ns)\n{\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tunsigned int max_samples = comedi_bytes_to_samples(s, maxbytes);\n\tunsigned int samples;\n\n\tsamples = max_samples;\n\n\t \n\tswitch (cmd->scan_begin_src) {\n\tcase TRIG_FOLLOW:\t \n\t\tif (cmd->convert_src == TRIG_TIMER)\n\t\t\tsamples = ns / cmd->convert_arg;\n\t\tbreak;\n\tcase TRIG_TIMER:\n\t\tsamples = ns / (cmd->scan_begin_arg * cmd->chanlist_len);\n\t\tbreak;\n\t}\n\n\t \n\tsamples = comedi_nsamples_left(s, samples);\n\n\tif (samples > max_samples)\n\t\tsamples = max_samples;\n\tif (samples < 1)\n\t\tsamples = 1;\n\n\treturn comedi_samples_to_bytes(s, samples);\n}\n\nstatic void das1800_ai_setup_dma(struct comedi_device *dev,\n\t\t\t\t struct comedi_subdevice *s)\n{\n\tstruct das1800_private *devpriv = dev->private;\n\tstruct comedi_isadma *dma = devpriv->dma;\n\tstruct comedi_isadma_desc *desc;\n\tunsigned int bytes;\n\n\tif ((devpriv->irq_dma_bits & DMA_ENABLED) == 0)\n\t\treturn;\n\n\tdma->cur_dma = 0;\n\tdesc = &dma->desc[0];\n\n\t \n\tbytes = das1800_ai_transfer_size(dev, s, desc->maxsize, 300000000);\n\n\tdesc->size = bytes;\n\tcomedi_isadma_program(desc);\n\n\t \n\tif (devpriv->irq_dma_bits & DMA_DUAL) {\n\t\tdesc = &dma->desc[1];\n\t\tdesc->size = bytes;\n\t\tcomedi_isadma_program(desc);\n\t}\n}\n\nstatic void das1800_ai_set_chanlist(struct comedi_device *dev,\n\t\t\t\t    unsigned int *chanlist, unsigned int len)\n{\n\tunsigned long flags;\n\tunsigned int i;\n\n\t \n\tspin_lock_irqsave(&dev->spinlock, flags);\n\n\t \n\toutb(QRAM, dev->iobase + DAS1800_SELECT);\n\toutb(len - 1, dev->iobase + DAS1800_QRAM_ADDRESS);\n\n\t \n\tfor (i = 0; i < len; i++) {\n\t\tunsigned int chan = CR_CHAN(chanlist[i]);\n\t\tunsigned int range = CR_RANGE(chanlist[i]);\n\t\tunsigned short val;\n\n\t\tval = chan | ((range & 0x3) << 8);\n\t\toutw(val, dev->iobase + DAS1800_QRAM);\n\t}\n\n\t \n\toutb(len - 1, dev->iobase + DAS1800_QRAM_ADDRESS);\n\n\tspin_unlock_irqrestore(&dev->spinlock, flags);\n}\n\nstatic int das1800_ai_cmd(struct comedi_device *dev,\n\t\t\t  struct comedi_subdevice *s)\n{\n\tstruct das1800_private *devpriv = dev->private;\n\tint control_a, control_c;\n\tstruct comedi_async *async = s->async;\n\tconst struct comedi_cmd *cmd = &async->cmd;\n\tunsigned int range0 = CR_RANGE(cmd->chanlist[0]);\n\n\t \n\tif (cmd->flags & (CMDF_WAKE_EOS | CMDF_PRIORITY))\n\t\tdevpriv->irq_dma_bits &= ~DMA_ENABLED;\n\telse\n\t\tdevpriv->irq_dma_bits |= devpriv->dma_bits;\n\t \n\tif (cmd->flags & CMDF_WAKE_EOS) {\n\t\t \n\t\tdevpriv->irq_dma_bits &= ~FIMD;\n\t} else {\n\t\t \n\t\tdevpriv->irq_dma_bits |= FIMD;\n\t}\n\n\tdas1800_ai_cancel(dev, s);\n\n\tdevpriv->ai_is_unipolar = comedi_range_is_unipolar(s, range0);\n\n\tcontrol_a = FFEN;\n\tif (cmd->stop_src == TRIG_EXT)\n\t\tcontrol_a |= ATEN;\n\tif (cmd->start_src == TRIG_EXT)\n\t\tcontrol_a |= TGEN | CGSL;\n\telse  \n\t\tcontrol_a |= CGEN;\n\tif (control_a & (ATEN | TGEN)) {\n\t\tif ((cmd->start_arg & CR_INVERT) || (cmd->stop_arg & CR_INVERT))\n\t\t\tcontrol_a |= TGPL;\n\t}\n\n\tcontrol_c = das1800_ai_chanspec_bits(s, cmd->chanlist[0]);\n\t \n\tif (cmd->scan_begin_src == TRIG_FOLLOW) {\n\t\t \n\t\tif (cmd->convert_src == TRIG_TIMER) {\n\t\t\t \n\t\t\tcontrol_c |= IPCLK;\n\t\t} else {  \n\t\t\t \n\t\t\tcontrol_c |= XPCLK;\n\t\t}\n\t} else if (cmd->scan_begin_src == TRIG_TIMER) {\n\t\t \n\t\tcontrol_c |= BMDE | IPCLK;\n\t} else {  \n\t\t \n\t\tcontrol_c |= BMDE | XPCLK;\n\t}\n\n\tdas1800_ai_set_chanlist(dev, cmd->chanlist, cmd->chanlist_len);\n\n\t \n\tif ((cmd->scan_begin_src == TRIG_FOLLOW ||\n\t     cmd->scan_begin_src == TRIG_TIMER) &&\n\t    cmd->convert_src == TRIG_TIMER) {\n\t\tcomedi_8254_update_divisors(dev->pacer);\n\t\tcomedi_8254_pacer_enable(dev->pacer, 1, 2, true);\n\t}\n\n\t \n\tif (cmd->stop_src == TRIG_EXT)\n\t\tcomedi_8254_load(dev->pacer, 0, 1, I8254_MODE0 | I8254_BINARY);\n\n\tdas1800_ai_setup_dma(dev, s);\n\toutb(control_c, dev->iobase + DAS1800_CONTROL_C);\n\t \n\tif (control_c & BMDE) {\n\t\toutb(cmd->convert_arg / 1000 - 1,\t \n\t\t     dev->iobase + DAS1800_BURST_RATE);\n\t\toutb(cmd->chanlist_len - 1, dev->iobase + DAS1800_BURST_LENGTH);\n\t}\n\n\t \n\toutb(devpriv->irq_dma_bits, dev->iobase + DAS1800_CONTROL_B);\n\toutb(control_a, dev->iobase + DAS1800_CONTROL_A);\n\toutb(CVEN, dev->iobase + DAS1800_STATUS);\n\n\treturn 0;\n}\n\nstatic int das1800_ai_eoc(struct comedi_device *dev,\n\t\t\t  struct comedi_subdevice *s,\n\t\t\t  struct comedi_insn *insn,\n\t\t\t  unsigned long context)\n{\n\tunsigned char status;\n\n\tstatus = inb(dev->iobase + DAS1800_STATUS);\n\tif (status & FNE)\n\t\treturn 0;\n\treturn -EBUSY;\n}\n\nstatic int das1800_ai_insn_read(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tstruct comedi_insn *insn,\n\t\t\t\tunsigned int *data)\n{\n\tunsigned int range = CR_RANGE(insn->chanspec);\n\tbool is_unipolar = comedi_range_is_unipolar(s, range);\n\tint ret = 0;\n\tint n;\n\tunsigned short dpnt;\n\tunsigned long flags;\n\n\toutb(das1800_ai_chanspec_bits(s, insn->chanspec),\n\t     dev->iobase + DAS1800_CONTROL_C);\t\t \n\toutb(CVEN, dev->iobase + DAS1800_STATUS);\t \n\toutb(0x0, dev->iobase + DAS1800_CONTROL_A);\t \n\toutb(FFEN, dev->iobase + DAS1800_CONTROL_A);\n\n\tdas1800_ai_set_chanlist(dev, &insn->chanspec, 1);\n\n\t \n\tspin_lock_irqsave(&dev->spinlock, flags);\n\n\t \n\toutb(ADC, dev->iobase + DAS1800_SELECT);\n\n\tfor (n = 0; n < insn->n; n++) {\n\t\t \n\t\toutb(0, dev->iobase + DAS1800_FIFO);\n\n\t\tret = comedi_timeout(dev, s, insn, das1800_ai_eoc, 0);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tdpnt = inw(dev->iobase + DAS1800_FIFO);\n\t\tif (!is_unipolar)\n\t\t\tdpnt = comedi_offset_munge(s, dpnt);\n\t\tdata[n] = dpnt;\n\t}\n\tspin_unlock_irqrestore(&dev->spinlock, flags);\n\n\treturn ret ? ret : insn->n;\n}\n\nstatic int das1800_ao_insn_write(struct comedi_device *dev,\n\t\t\t\t struct comedi_subdevice *s,\n\t\t\t\t struct comedi_insn *insn,\n\t\t\t\t unsigned int *data)\n{\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int update_chan = s->n_chan - 1;\n\tunsigned long flags;\n\tint i;\n\n\t \n\tspin_lock_irqsave(&dev->spinlock, flags);\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\tunsigned int val = data[i];\n\n\t\ts->readback[chan] = val;\n\n\t\tval = comedi_offset_munge(s, val);\n\n\t\t \n\t\toutb(DAC(chan), dev->iobase + DAS1800_SELECT);\n\t\toutw(val, dev->iobase + DAS1800_DAC);\n\n\t\t \n\t\tif (chan != update_chan) {\n\t\t\tval = comedi_offset_munge(s, s->readback[update_chan]);\n\n\t\t\toutb(DAC(update_chan), dev->iobase + DAS1800_SELECT);\n\t\t\toutw(val, dev->iobase + DAS1800_DAC);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&dev->spinlock, flags);\n\n\treturn insn->n;\n}\n\nstatic int das1800_di_insn_bits(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tstruct comedi_insn *insn,\n\t\t\t\tunsigned int *data)\n{\n\tdata[1] = inb(dev->iobase + DAS1800_DIGITAL) & 0xf;\n\tdata[0] = 0;\n\n\treturn insn->n;\n}\n\nstatic int das1800_do_insn_bits(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tstruct comedi_insn *insn,\n\t\t\t\tunsigned int *data)\n{\n\tif (comedi_dio_update_state(s, data))\n\t\toutb(s->state, dev->iobase + DAS1800_DIGITAL);\n\n\tdata[1] = s->state;\n\n\treturn insn->n;\n}\n\nstatic void das1800_init_dma(struct comedi_device *dev,\n\t\t\t     struct comedi_devconfig *it)\n{\n\tstruct das1800_private *devpriv = dev->private;\n\tunsigned int *dma_chan;\n\n\t \n\tdma_chan = &it->options[2];\n\n\tswitch ((dma_chan[0] & 0x7) | (dma_chan[1] << 4)) {\n\tcase 0x5:\t \n\t\tdevpriv->dma_bits = DMA_CH5;\n\t\tbreak;\n\tcase 0x6:\t \n\t\tdevpriv->dma_bits = DMA_CH6;\n\t\tbreak;\n\tcase 0x7:\t \n\t\tdevpriv->dma_bits = DMA_CH7;\n\t\tbreak;\n\tcase 0x65:\t \n\t\tdevpriv->dma_bits = DMA_CH5_CH6;\n\t\tbreak;\n\tcase 0x76:\t \n\t\tdevpriv->dma_bits = DMA_CH6_CH7;\n\t\tbreak;\n\tcase 0x57:\t \n\t\tdevpriv->dma_bits = DMA_CH7_CH5;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\t \n\tdevpriv->dma = comedi_isadma_alloc(dev, dma_chan[1] ? 2 : 1,\n\t\t\t\t\t   dma_chan[0], dma_chan[1],\n\t\t\t\t\t   DMA_BUF_SIZE, COMEDI_ISADMA_READ);\n\tif (!devpriv->dma)\n\t\tdevpriv->dma_bits = 0;\n}\n\nstatic void das1800_free_dma(struct comedi_device *dev)\n{\n\tstruct das1800_private *devpriv = dev->private;\n\n\tif (devpriv)\n\t\tcomedi_isadma_free(devpriv->dma);\n}\n\nstatic int das1800_probe(struct comedi_device *dev)\n{\n\tconst struct das1800_board *board = dev->board_ptr;\n\tunsigned char id;\n\n\tid = (inb(dev->iobase + DAS1800_DIGITAL) >> 4) & 0xf;\n\n\t \n\tif (board) {\n\t\tif (board->id == id)\n\t\t\treturn 0;\n\t\tdev_err(dev->class_dev,\n\t\t\t\"probed id does not match board id (0x%x != 0x%x)\\n\",\n\t\t\tid, board->id);\n\t\treturn -ENODEV;\n\t}\n\n\t  \n\tswitch (id) {\n\tcase DAS1800_ID_ST_DA:\n\t\t \n\t\tboard = &das1800_boards[BOARD_DAS1801ST_DA];\n\t\tbreak;\n\tcase DAS1800_ID_HR_DA:\n\t\t \n\t\tboard = &das1800_boards[BOARD_DAS1802HR_DA];\n\t\tbreak;\n\tcase DAS1800_ID_AO:\n\t\t \n\t\tboard = &das1800_boards[BOARD_DAS1801AO];\n\t\tbreak;\n\tcase DAS1800_ID_HR:\n\t\t \n\t\tboard = &das1800_boards[BOARD_DAS1802HR];\n\t\tbreak;\n\tcase DAS1800_ID_ST:\n\t\t \n\t\tboard = &das1800_boards[BOARD_DAS1801ST];\n\t\tbreak;\n\tcase DAS1800_ID_HC:\n\t\t \n\t\tboard = &das1800_boards[BOARD_DAS1801HC];\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev->class_dev, \"invalid probe id 0x%x\\n\", id);\n\t\treturn -ENODEV;\n\t}\n\tdev->board_ptr = board;\n\tdev->board_name = board->name;\n\tdev_warn(dev->class_dev,\n\t\t \"probed id 0x%0x: %s series (not recommended)\\n\",\n\t\t id, board->name);\n\treturn 0;\n}\n\nstatic int das1800_attach(struct comedi_device *dev,\n\t\t\t  struct comedi_devconfig *it)\n{\n\tconst struct das1800_board *board;\n\tstruct das1800_private *devpriv;\n\tstruct comedi_subdevice *s;\n\tunsigned int irq = it->options[1];\n\tbool is_16bit;\n\tint ret;\n\tint i;\n\n\tdevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\n\tif (!devpriv)\n\t\treturn -ENOMEM;\n\n\tret = comedi_request_region(dev, it->options[0], DAS1800_SIZE);\n\tif (ret)\n\t\treturn ret;\n\n\tret = das1800_probe(dev);\n\tif (ret)\n\t\treturn ret;\n\tboard = dev->board_ptr;\n\n\tis_16bit = board->id == DAS1800_ID_HR || board->id == DAS1800_ID_HR_DA;\n\n\t \n\tif (board->id == DAS1800_ID_AO) {\n\t\tunsigned long iobase2 = dev->iobase + IOBASE2;\n\n\t\tret = __comedi_request_region(dev, iobase2, DAS1800_SIZE);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tdevpriv->iobase2 = iobase2;\n\t}\n\n\tif (irq == 3 || irq == 5 || irq == 7 || irq == 10 || irq == 11 ||\n\t    irq == 15) {\n\t\tret = request_irq(irq, das1800_interrupt, 0,\n\t\t\t\t  dev->board_name, dev);\n\t\tif (ret == 0) {\n\t\t\tdev->irq = irq;\n\n\t\t\tswitch (irq) {\n\t\t\tcase 3:\n\t\t\t\tdevpriv->irq_dma_bits |= 0x8;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tdevpriv->irq_dma_bits |= 0x10;\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tdevpriv->irq_dma_bits |= 0x18;\n\t\t\t\tbreak;\n\t\t\tcase 10:\n\t\t\t\tdevpriv->irq_dma_bits |= 0x28;\n\t\t\t\tbreak;\n\t\t\tcase 11:\n\t\t\t\tdevpriv->irq_dma_bits |= 0x30;\n\t\t\t\tbreak;\n\t\t\tcase 15:\n\t\t\t\tdevpriv->irq_dma_bits |= 0x38;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (dev->irq & it->options[2])\n\t\tdas1800_init_dma(dev, it);\n\n\tdevpriv->fifo_buf = kmalloc_array(FIFO_SIZE,\n\t\t\t\t\t  sizeof(*devpriv->fifo_buf),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!devpriv->fifo_buf)\n\t\treturn -ENOMEM;\n\n\tdev->pacer = comedi_8254_init(dev->iobase + DAS1800_COUNTER,\n\t\t\t\t      I8254_OSC_BASE_5MHZ, I8254_IO8, 0);\n\tif (!dev->pacer)\n\t\treturn -ENOMEM;\n\n\tret = comedi_alloc_subdevices(dev, 4);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ts = &dev->subdevices[0];\n\ts->type\t\t= COMEDI_SUBD_AI;\n\ts->subdev_flags\t= SDF_READABLE | SDF_DIFF | SDF_GROUND;\n\tif (board->id != DAS1800_ID_HC)\n\t\ts->subdev_flags\t|= SDF_COMMON;\n\ts->n_chan\t= (board->id == DAS1800_ID_HC) ? 64 : 256;\n\ts->maxdata\t= is_16bit ? 0xffff : 0x0fff;\n\ts->range_table\t= board->is_01_series ? &das1801_ai_range\n\t\t\t\t\t      : &das1802_ai_range;\n\ts->insn_read\t= das1800_ai_insn_read;\n\tif (dev->irq) {\n\t\tdev->read_subdev = s;\n\t\ts->subdev_flags\t|= SDF_CMD_READ;\n\t\ts->len_chanlist\t= s->n_chan;\n\t\ts->do_cmd\t= das1800_ai_cmd;\n\t\ts->do_cmdtest\t= das1800_ai_cmdtest;\n\t\ts->poll\t\t= das1800_ai_poll;\n\t\ts->cancel\t= das1800_ai_cancel;\n\t\ts->munge\t= das1800_ai_munge;\n\t}\n\n\t \n\ts = &dev->subdevices[1];\n\tif (board->id == DAS1800_ID_ST_DA || board->id == DAS1800_ID_HR_DA) {\n\t\ts->type\t\t= COMEDI_SUBD_AO;\n\t\ts->subdev_flags\t= SDF_WRITABLE;\n\t\ts->n_chan\t= (board->id == DAS1800_ID_ST_DA) ? 4 : 2;\n\t\ts->maxdata\t= is_16bit ? 0xffff : 0x0fff;\n\t\ts->range_table\t= &range_bipolar10;\n\t\ts->insn_write\t= das1800_ao_insn_write;\n\n\t\tret = comedi_alloc_subdev_readback(s);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tfor (i = 0; i < s->n_chan; i++) {\n\t\t\t \n\t\t\toutb(DAC(i), dev->iobase + DAS1800_SELECT);\n\t\t\toutw(0, dev->iobase + DAS1800_DAC);\n\t\t}\n\t} else if (board->id == DAS1800_ID_AO) {\n\t\t \n\t\ts->type\t\t= COMEDI_SUBD_UNUSED;\n\t} else {\n\t\ts->type\t\t= COMEDI_SUBD_UNUSED;\n\t}\n\n\t \n\ts = &dev->subdevices[2];\n\ts->type\t\t= COMEDI_SUBD_DI;\n\ts->subdev_flags\t= SDF_READABLE;\n\ts->n_chan\t= 4;\n\ts->maxdata\t= 1;\n\ts->range_table\t= &range_digital;\n\ts->insn_bits\t= das1800_di_insn_bits;\n\n\t \n\ts = &dev->subdevices[3];\n\ts->type\t\t= COMEDI_SUBD_DO;\n\ts->subdev_flags\t= SDF_WRITABLE;\n\ts->n_chan\t= (board->id == DAS1800_ID_HC) ? 8 : 4;\n\ts->maxdata\t= 1;\n\ts->range_table\t= &range_digital;\n\ts->insn_bits\t= das1800_do_insn_bits;\n\n\tdas1800_ai_cancel(dev, dev->read_subdev);\n\n\t \n\toutb(0, dev->iobase + DAS1800_DIGITAL);\n\n\treturn 0;\n};\n\nstatic void das1800_detach(struct comedi_device *dev)\n{\n\tstruct das1800_private *devpriv = dev->private;\n\n\tdas1800_free_dma(dev);\n\tif (devpriv) {\n\t\tkfree(devpriv->fifo_buf);\n\t\tif (devpriv->iobase2)\n\t\t\trelease_region(devpriv->iobase2, DAS1800_SIZE);\n\t}\n\tcomedi_legacy_detach(dev);\n}\n\nstatic struct comedi_driver das1800_driver = {\n\t.driver_name\t= \"das1800\",\n\t.module\t\t= THIS_MODULE,\n\t.attach\t\t= das1800_attach,\n\t.detach\t\t= das1800_detach,\n\t.num_names\t= ARRAY_SIZE(das1800_boards),\n\t.board_name\t= &das1800_boards[0].name,\n\t.offset\t\t= sizeof(struct das1800_board),\n};\nmodule_comedi_driver(das1800_driver);\n\nMODULE_AUTHOR(\"Comedi https://www.comedi.org\");\nMODULE_DESCRIPTION(\"Comedi driver for DAS1800 compatible ISA boards\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}