{
  "module_name": "ni_routes.c",
  "hash_id": "5f2d8ba1b645620e6521140ba0950de252c208caa22a3ae43a293a9b47d2d438",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/ni_routes.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/bsearch.h>\n#include <linux/sort.h>\n#include <linux/comedi.h>\n\n#include \"ni_routes.h\"\n#include \"ni_routing/ni_route_values.h\"\n#include \"ni_routing/ni_device_routes.h\"\n\n \n\n \n\n \n#define RVi(table, src, dest)\t((table)[(dest) * NI_NUM_NAMES + (src)])\n\n \nstatic const u8 *ni_find_route_values(const char *device_family)\n{\n\tconst u8 *rv = NULL;\n\tint i;\n\n\tfor (i = 0; ni_all_route_values[i]; ++i) {\n\t\tif (!strcmp(ni_all_route_values[i]->family, device_family)) {\n\t\t\trv = &ni_all_route_values[i]->register_values[0][0];\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn rv;\n}\n\n \nstatic const struct ni_device_routes *\nni_find_valid_routes(const char *board_name)\n{\n\tconst struct ni_device_routes *dr = NULL;\n\tint i;\n\n\tfor (i = 0; ni_device_routes_list[i]; ++i) {\n\t\tif (!strcmp(ni_device_routes_list[i]->device, board_name)) {\n\t\t\tdr = ni_device_routes_list[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn dr;\n}\n\n \nstatic int ni_find_device_routes(const char *device_family,\n\t\t\t\t const char *board_name,\n\t\t\t\t const char *alt_board_name,\n\t\t\t\t struct ni_route_tables *tables)\n{\n\tconst struct ni_device_routes *dr;\n\tconst u8 *rv;\n\n\t \n\trv = ni_find_route_values(device_family);\n\n\t \n\tdr = ni_find_valid_routes(board_name);\n\tif (!dr && alt_board_name)\n\t\tdr = ni_find_valid_routes(alt_board_name);\n\n\ttables->route_values = rv;\n\ttables->valid_routes = dr;\n\n\tif (!rv || !dr)\n\t\treturn -ENODATA;\n\n\treturn 0;\n}\n\n \nint ni_assign_device_routes(const char *device_family,\n\t\t\t    const char *board_name,\n\t\t\t    const char *alt_board_name,\n\t\t\t    struct ni_route_tables *tables)\n{\n\tmemset(tables, 0, sizeof(struct ni_route_tables));\n\treturn ni_find_device_routes(device_family, board_name, alt_board_name,\n\t\t\t\t     tables);\n}\nEXPORT_SYMBOL_GPL(ni_assign_device_routes);\n\n \nunsigned int ni_count_valid_routes(const struct ni_route_tables *tables)\n{\n\tint total = 0;\n\tint i;\n\n\tfor (i = 0; i < tables->valid_routes->n_route_sets; ++i) {\n\t\tconst struct ni_route_set *R = &tables->valid_routes->routes[i];\n\t\tint j;\n\n\t\tfor (j = 0; j < R->n_src; ++j) {\n\t\t\tconst int src  = R->src[j];\n\t\t\tconst int dest = R->dest;\n\t\t\tconst u8 *rv = tables->route_values;\n\n\t\t\tif (RVi(rv, B(src), B(dest)))\n\t\t\t\t \n\t\t\t\t++total;\n\t\t\telse if (channel_is_rtsi(dest) &&\n\t\t\t\t (RVi(rv, B(src), B(NI_RGOUT0)) ||\n\t\t\t\t  RVi(rv, B(src), B(NI_RTSI_BRD(0))) ||\n\t\t\t\t  RVi(rv, B(src), B(NI_RTSI_BRD(1))) ||\n\t\t\t\t  RVi(rv, B(src), B(NI_RTSI_BRD(2))) ||\n\t\t\t\t  RVi(rv, B(src), B(NI_RTSI_BRD(3))))) {\n\t\t\t\t++total;\n\t\t\t}\n\t\t}\n\t}\n\treturn total;\n}\nEXPORT_SYMBOL_GPL(ni_count_valid_routes);\n\n \nunsigned int ni_get_valid_routes(const struct ni_route_tables *tables,\n\t\t\t\t unsigned int n_pairs,\n\t\t\t\t unsigned int *pair_data)\n{\n\tunsigned int n_valid = ni_count_valid_routes(tables);\n\tint i;\n\n\tif (n_pairs == 0 || n_valid == 0)\n\t\treturn n_valid;\n\n\tif (!pair_data)\n\t\treturn 0;\n\n\tn_valid = 0;\n\n\tfor (i = 0; i < tables->valid_routes->n_route_sets; ++i) {\n\t\tconst struct ni_route_set *R = &tables->valid_routes->routes[i];\n\t\tint j;\n\n\t\tfor (j = 0; j < R->n_src; ++j) {\n\t\t\tconst int src  = R->src[j];\n\t\t\tconst int dest = R->dest;\n\t\t\tbool valid = false;\n\t\t\tconst u8 *rv = tables->route_values;\n\n\t\t\tif (RVi(rv, B(src), B(dest)))\n\t\t\t\t \n\t\t\t\tvalid = true;\n\t\t\telse if (channel_is_rtsi(dest) &&\n\t\t\t\t (RVi(rv, B(src), B(NI_RGOUT0)) ||\n\t\t\t\t  RVi(rv, B(src), B(NI_RTSI_BRD(0))) ||\n\t\t\t\t  RVi(rv, B(src), B(NI_RTSI_BRD(1))) ||\n\t\t\t\t  RVi(rv, B(src), B(NI_RTSI_BRD(2))) ||\n\t\t\t\t  RVi(rv, B(src), B(NI_RTSI_BRD(3))))) {\n\t\t\t\t \n\t\t\t\tvalid = true;\n\t\t\t}\n\n\t\t\tif (valid) {\n\t\t\t\tpair_data[2 * n_valid] = src;\n\t\t\t\tpair_data[2 * n_valid + 1] = dest;\n\t\t\t\t++n_valid;\n\t\t\t}\n\n\t\t\tif (n_valid >= n_pairs)\n\t\t\t\treturn n_valid;\n\t\t}\n\t}\n\treturn n_valid;\n}\nEXPORT_SYMBOL_GPL(ni_get_valid_routes);\n\n \nstatic const int NI_CMD_DESTS[] = {\n\tNI_AI_SampleClock,\n\tNI_AI_StartTrigger,\n\tNI_AI_ConvertClock,\n\tNI_AO_SampleClock,\n\tNI_AO_StartTrigger,\n\tNI_DI_SampleClock,\n\tNI_DO_SampleClock,\n};\n\n \nbool ni_is_cmd_dest(int dest)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(NI_CMD_DESTS); ++i)\n\t\tif (NI_CMD_DESTS[i] == dest)\n\t\t\treturn true;\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(ni_is_cmd_dest);\n\n \nstatic int _ni_sort_destcmp(const void *va, const void *vb)\n{\n\tconst struct ni_route_set *a = va;\n\tconst struct ni_route_set *b = vb;\n\n\tif (a->dest < b->dest)\n\t\treturn -1;\n\telse if (a->dest > b->dest)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int _ni_sort_srccmp(const void *vsrc0, const void *vsrc1)\n{\n\tconst int *src0 = vsrc0;\n\tconst int *src1 = vsrc1;\n\n\tif (*src0 < *src1)\n\t\treturn -1;\n\telse if (*src0 > *src1)\n\t\treturn 1;\n\treturn 0;\n}\n\n \nvoid ni_sort_device_routes(struct ni_device_routes *valid_routes)\n{\n\tunsigned int n;\n\n\t \n\tvalid_routes->n_route_sets = 0;\n\twhile (valid_routes->routes[valid_routes->n_route_sets].dest != 0)\n\t\t++valid_routes->n_route_sets;\n\n\t \n\tsort(valid_routes->routes, valid_routes->n_route_sets,\n\t     sizeof(struct ni_route_set), _ni_sort_destcmp, NULL);\n\n\t \n\tfor (n = 0; n < valid_routes->n_route_sets; ++n) {\n\t\tstruct ni_route_set *rs = &valid_routes->routes[n];\n\n\t\t \n\t\trs->n_src = 0;\n\t\twhile (rs->src[rs->n_src])\n\t\t\t++rs->n_src;\n\n\t\t \n\t\tsort(valid_routes->routes[n].src, valid_routes->routes[n].n_src,\n\t\t     sizeof(int), _ni_sort_srccmp, NULL);\n\t}\n}\nEXPORT_SYMBOL_GPL(ni_sort_device_routes);\n\n \nstatic void ni_sort_all_device_routes(void)\n{\n\tunsigned int i;\n\n\tfor (i = 0; ni_device_routes_list[i]; ++i)\n\t\tni_sort_device_routes(ni_device_routes_list[i]);\n}\n\n \nstatic int _ni_bsearch_destcmp(const void *vkey, const void *velt)\n{\n\tconst int *key = vkey;\n\tconst struct ni_route_set *elt = velt;\n\n\tif (*key < elt->dest)\n\t\treturn -1;\n\telse if (*key > elt->dest)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int _ni_bsearch_srccmp(const void *vkey, const void *velt)\n{\n\tconst int *key = vkey;\n\tconst int *elt = velt;\n\n\tif (*key < *elt)\n\t\treturn -1;\n\telse if (*key > *elt)\n\t\treturn 1;\n\treturn 0;\n}\n\n \nconst struct ni_route_set *\nni_find_route_set(const int destination,\n\t\t  const struct ni_device_routes *valid_routes)\n{\n\treturn bsearch(&destination, valid_routes->routes,\n\t\t       valid_routes->n_route_sets, sizeof(struct ni_route_set),\n\t\t       _ni_bsearch_destcmp);\n}\nEXPORT_SYMBOL_GPL(ni_find_route_set);\n\n \nbool ni_route_set_has_source(const struct ni_route_set *routes,\n\t\t\t     const int source)\n{\n\tif (!bsearch(&source, routes->src, routes->n_src, sizeof(int),\n\t\t     _ni_bsearch_srccmp))\n\t\treturn false;\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(ni_route_set_has_source);\n\n \ns8 ni_lookup_route_register(int src, int dest,\n\t\t\t    const struct ni_route_tables *tables)\n{\n\ts8 regval;\n\n\t \n\tsrc = B(src);\n\tdest = B(dest);\n\tif (src < 0 || src >= NI_NUM_NAMES || dest < 0 || dest >= NI_NUM_NAMES)\n\t\treturn -EINVAL;\n\tregval = RVi(tables->route_values, src, dest);\n\tif (!regval)\n\t\treturn -EINVAL;\n\t \n\treturn UNMARK(regval);\n}\nEXPORT_SYMBOL_GPL(ni_lookup_route_register);\n\n \ns8 ni_route_to_register(const int src, const int dest,\n\t\t\tconst struct ni_route_tables *tables)\n{\n\tconst struct ni_route_set *routes =\n\t\tni_find_route_set(dest, tables->valid_routes);\n\tconst u8 *rv;\n\ts8 regval;\n\n\t \n\tif (!routes)\n\t\treturn -1;\n\t \n\tif (!ni_route_set_has_source(routes, src))\n\t\treturn -1;\n\t \n\trv = tables->route_values;\n\tregval = RVi(rv, B(src), B(dest));\n\n\t \n\tif (!regval && channel_is_rtsi(dest)) {\n\t\tregval = RVi(rv, B(src), B(NI_RGOUT0));\n\t\tif (!regval && (RVi(rv, B(src), B(NI_RTSI_BRD(0))) ||\n\t\t\t\tRVi(rv, B(src), B(NI_RTSI_BRD(1))) ||\n\t\t\t\tRVi(rv, B(src), B(NI_RTSI_BRD(2))) ||\n\t\t\t\tRVi(rv, B(src), B(NI_RTSI_BRD(3)))))\n\t\t\tregval = BIT(6);\n\t}\n\n\tif (!regval)\n\t\treturn -1;\n\t \n\treturn UNMARK(regval);\n}\nEXPORT_SYMBOL_GPL(ni_route_to_register);\n\n \nint ni_find_route_source(const u8 src_sel_reg_value, int dest,\n\t\t\t const struct ni_route_tables *tables)\n{\n\tint src;\n\n\tif (!tables->route_values)\n\t\treturn -EINVAL;\n\n\tdest = B(dest);  \n\t \n\tif (dest < 0 || dest >= NI_NUM_NAMES)\n\t\treturn -EINVAL;\n\tfor (src = 0; src < NI_NUM_NAMES; ++src)\n\t\tif (RVi(tables->route_values, src, dest) ==\n\t\t    V(src_sel_reg_value))\n\t\t\treturn src + NI_NAMES_BASE;\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL_GPL(ni_find_route_source);\n\n \n\n \nstatic int __init ni_routes_module_init(void)\n{\n\tni_sort_all_device_routes();\n\treturn 0;\n}\n\nstatic void __exit ni_routes_module_exit(void)\n{\n}\n\nmodule_init(ni_routes_module_init);\nmodule_exit(ni_routes_module_exit);\n\nMODULE_AUTHOR(\"Comedi https://www.comedi.org\");\nMODULE_DESCRIPTION(\"Comedi helper for routing signals-->terminals for NI\");\nMODULE_LICENSE(\"GPL\");\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}