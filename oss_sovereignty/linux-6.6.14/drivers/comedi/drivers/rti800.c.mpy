{
  "module_name": "rti800.c",
  "hash_id": "4d4b42e002a5bb423c182a96a3f526111541ce1d2fa40bdcbc5146c4170ccf14",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/rti800.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/comedi/comedidev.h>\n\n \n#define RTI800_CSR\t\t0x00\n#define RTI800_CSR_BUSY\t\tBIT(7)\n#define RTI800_CSR_DONE\t\tBIT(6)\n#define RTI800_CSR_OVERRUN\tBIT(5)\n#define RTI800_CSR_TCR\t\tBIT(4)\n#define RTI800_CSR_DMA_ENAB\tBIT(3)\n#define RTI800_CSR_INTR_TC\tBIT(2)\n#define RTI800_CSR_INTR_EC\tBIT(1)\n#define RTI800_CSR_INTR_OVRN\tBIT(0)\n#define RTI800_MUXGAIN\t\t0x01\n#define RTI800_CONVERT\t\t0x02\n#define RTI800_ADCLO\t\t0x03\n#define RTI800_ADCHI\t\t0x04\n#define RTI800_DAC0LO\t\t0x05\n#define RTI800_DAC0HI\t\t0x06\n#define RTI800_DAC1LO\t\t0x07\n#define RTI800_DAC1HI\t\t0x08\n#define RTI800_CLRFLAGS\t\t0x09\n#define RTI800_DI\t\t0x0a\n#define RTI800_DO\t\t0x0b\n#define RTI800_9513A_DATA\t0x0c\n#define RTI800_9513A_CNTRL\t0x0d\n#define RTI800_9513A_STATUS\t0x0d\n\nstatic const struct comedi_lrange range_rti800_ai_10_bipolar = {\n\t4, {\n\t\tBIP_RANGE(10),\n\t\tBIP_RANGE(1),\n\t\tBIP_RANGE(0.1),\n\t\tBIP_RANGE(0.02)\n\t}\n};\n\nstatic const struct comedi_lrange range_rti800_ai_5_bipolar = {\n\t4, {\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(0.5),\n\t\tBIP_RANGE(0.05),\n\t\tBIP_RANGE(0.01)\n\t}\n};\n\nstatic const struct comedi_lrange range_rti800_ai_unipolar = {\n\t4, {\n\t\tUNI_RANGE(10),\n\t\tUNI_RANGE(1),\n\t\tUNI_RANGE(0.1),\n\t\tUNI_RANGE(0.02)\n\t}\n};\n\nstatic const struct comedi_lrange *const rti800_ai_ranges[] = {\n\t&range_rti800_ai_10_bipolar,\n\t&range_rti800_ai_5_bipolar,\n\t&range_rti800_ai_unipolar,\n};\n\nstatic const struct comedi_lrange *const rti800_ao_ranges[] = {\n\t&range_bipolar10,\n\t&range_unipolar10,\n};\n\nstruct rti800_board {\n\tconst char *name;\n\tint has_ao;\n};\n\nstatic const struct rti800_board rti800_boardtypes[] = {\n\t{\n\t\t.name\t\t= \"rti800\",\n\t}, {\n\t\t.name\t\t= \"rti815\",\n\t\t.has_ao\t\t= 1,\n\t},\n};\n\nstruct rti800_private {\n\tbool adc_2comp;\n\tbool dac_2comp[2];\n\tconst struct comedi_lrange *ao_range_type_list[2];\n\tunsigned char muxgain_bits;\n};\n\nstatic int rti800_ai_eoc(struct comedi_device *dev,\n\t\t\t struct comedi_subdevice *s,\n\t\t\t struct comedi_insn *insn,\n\t\t\t unsigned long context)\n{\n\tunsigned char status;\n\n\tstatus = inb(dev->iobase + RTI800_CSR);\n\tif (status & RTI800_CSR_OVERRUN) {\n\t\toutb(0, dev->iobase + RTI800_CLRFLAGS);\n\t\treturn -EOVERFLOW;\n\t}\n\tif (status & RTI800_CSR_DONE)\n\t\treturn 0;\n\treturn -EBUSY;\n}\n\nstatic int rti800_ai_insn_read(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       struct comedi_insn *insn,\n\t\t\t       unsigned int *data)\n{\n\tstruct rti800_private *devpriv = dev->private;\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int gain = CR_RANGE(insn->chanspec);\n\tunsigned char muxgain_bits;\n\tint ret;\n\tint i;\n\n\tinb(dev->iobase + RTI800_ADCHI);\n\toutb(0, dev->iobase + RTI800_CLRFLAGS);\n\n\tmuxgain_bits = chan | (gain << 5);\n\tif (muxgain_bits != devpriv->muxgain_bits) {\n\t\tdevpriv->muxgain_bits = muxgain_bits;\n\t\toutb(devpriv->muxgain_bits, dev->iobase + RTI800_MUXGAIN);\n\t\t \n\t\tif (insn->n > 0) {\n\t\t\tint delay = (gain == 0) ? 10 :\n\t\t\t\t    (gain == 1) ? 20 :\n\t\t\t\t    (gain == 2) ? 40 : 80;\n\n\t\t\tudelay(delay);\n\t\t}\n\t}\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\tunsigned int val;\n\n\t\toutb(0, dev->iobase + RTI800_CONVERT);\n\n\t\tret = comedi_timeout(dev, s, insn, rti800_ai_eoc, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tval = inb(dev->iobase + RTI800_ADCLO);\n\t\tval |= (inb(dev->iobase + RTI800_ADCHI) & 0xf) << 8;\n\n\t\tif (devpriv->adc_2comp)\n\t\t\tval = comedi_offset_munge(s, val);\n\n\t\tdata[i] = val;\n\t}\n\n\treturn insn->n;\n}\n\nstatic int rti800_ao_insn_write(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tstruct comedi_insn *insn,\n\t\t\t\tunsigned int *data)\n{\n\tstruct rti800_private *devpriv = dev->private;\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tint reg_lo = chan ? RTI800_DAC1LO : RTI800_DAC0LO;\n\tint reg_hi = chan ? RTI800_DAC1HI : RTI800_DAC0HI;\n\tint i;\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\tunsigned int val = data[i];\n\n\t\ts->readback[chan] = val;\n\n\t\tif (devpriv->dac_2comp[chan])\n\t\t\tval = comedi_offset_munge(s, val);\n\n\t\toutb(val & 0xff, dev->iobase + reg_lo);\n\t\toutb((val >> 8) & 0xff, dev->iobase + reg_hi);\n\t}\n\n\treturn insn->n;\n}\n\nstatic int rti800_di_insn_bits(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       struct comedi_insn *insn,\n\t\t\t       unsigned int *data)\n{\n\tdata[1] = inb(dev->iobase + RTI800_DI);\n\treturn insn->n;\n}\n\nstatic int rti800_do_insn_bits(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       struct comedi_insn *insn,\n\t\t\t       unsigned int *data)\n{\n\tif (comedi_dio_update_state(s, data)) {\n\t\t \n\t\toutb(s->state ^ 0xff, dev->iobase + RTI800_DO);\n\t}\n\n\tdata[1] = s->state;\n\n\treturn insn->n;\n}\n\nstatic int rti800_attach(struct comedi_device *dev, struct comedi_devconfig *it)\n{\n\tconst struct rti800_board *board = dev->board_ptr;\n\tstruct rti800_private *devpriv;\n\tstruct comedi_subdevice *s;\n\tint ret;\n\n\tret = comedi_request_region(dev, it->options[0], 0x10);\n\tif (ret)\n\t\treturn ret;\n\n\toutb(0, dev->iobase + RTI800_CSR);\n\tinb(dev->iobase + RTI800_ADCHI);\n\toutb(0, dev->iobase + RTI800_CLRFLAGS);\n\n\tdevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\n\tif (!devpriv)\n\t\treturn -ENOMEM;\n\n\tdevpriv->adc_2comp = (it->options[4] == 0);\n\tdevpriv->dac_2comp[0] = (it->options[6] == 0);\n\tdevpriv->dac_2comp[1] = (it->options[8] == 0);\n\t \n\tdevpriv->muxgain_bits = 0xff;\n\n\tret = comedi_alloc_subdevices(dev, 4);\n\tif (ret)\n\t\treturn ret;\n\n\ts = &dev->subdevices[0];\n\t \n\ts->type\t\t= COMEDI_SUBD_AI;\n\ts->subdev_flags\t= SDF_READABLE | SDF_GROUND;\n\ts->n_chan\t= (it->options[2] ? 16 : 8);\n\ts->insn_read\t= rti800_ai_insn_read;\n\ts->maxdata\t= 0x0fff;\n\ts->range_table\t= (it->options[3] < ARRAY_SIZE(rti800_ai_ranges))\n\t\t\t\t? rti800_ai_ranges[it->options[3]]\n\t\t\t\t: &range_unknown;\n\n\ts = &dev->subdevices[1];\n\tif (board->has_ao) {\n\t\t \n\t\ts->type\t\t= COMEDI_SUBD_AO;\n\t\ts->subdev_flags\t= SDF_WRITABLE;\n\t\ts->n_chan\t= 2;\n\t\ts->maxdata\t= 0x0fff;\n\t\ts->range_table_list = devpriv->ao_range_type_list;\n\t\tdevpriv->ao_range_type_list[0] =\n\t\t\t(it->options[5] < ARRAY_SIZE(rti800_ao_ranges))\n\t\t\t\t? rti800_ao_ranges[it->options[5]]\n\t\t\t\t: &range_unknown;\n\t\tdevpriv->ao_range_type_list[1] =\n\t\t\t(it->options[7] < ARRAY_SIZE(rti800_ao_ranges))\n\t\t\t\t? rti800_ao_ranges[it->options[7]]\n\t\t\t\t: &range_unknown;\n\t\ts->insn_write\t= rti800_ao_insn_write;\n\n\t\tret = comedi_alloc_subdev_readback(s);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\ts->type\t\t= COMEDI_SUBD_UNUSED;\n\t}\n\n\ts = &dev->subdevices[2];\n\t \n\ts->type\t\t= COMEDI_SUBD_DI;\n\ts->subdev_flags\t= SDF_READABLE;\n\ts->n_chan\t= 8;\n\ts->insn_bits\t= rti800_di_insn_bits;\n\ts->maxdata\t= 1;\n\ts->range_table\t= &range_digital;\n\n\ts = &dev->subdevices[3];\n\t \n\ts->type\t\t= COMEDI_SUBD_DO;\n\ts->subdev_flags\t= SDF_WRITABLE;\n\ts->n_chan\t= 8;\n\ts->insn_bits\t= rti800_do_insn_bits;\n\ts->maxdata\t= 1;\n\ts->range_table\t= &range_digital;\n\n\t \n\n\treturn 0;\n}\n\nstatic struct comedi_driver rti800_driver = {\n\t.driver_name\t= \"rti800\",\n\t.module\t\t= THIS_MODULE,\n\t.attach\t\t= rti800_attach,\n\t.detach\t\t= comedi_legacy_detach,\n\t.num_names\t= ARRAY_SIZE(rti800_boardtypes),\n\t.board_name\t= &rti800_boardtypes[0].name,\n\t.offset\t\t= sizeof(struct rti800_board),\n};\nmodule_comedi_driver(rti800_driver);\n\nMODULE_DESCRIPTION(\"Comedi: RTI-800 Multifunction Analog/Digital board\");\nMODULE_AUTHOR(\"Comedi https://www.comedi.org\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}