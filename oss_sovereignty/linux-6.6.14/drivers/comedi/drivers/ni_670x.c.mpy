{
  "module_name": "ni_670x.c",
  "hash_id": "b1f799b083c33428f24b3aa5e1ccb764d660342e2dbb89f7b873d384fb757464",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/ni_670x.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/comedi/comedi_pci.h>\n\n#define AO_VALUE_OFFSET\t\t\t0x00\n#define\tAO_CHAN_OFFSET\t\t\t0x0c\n#define\tAO_STATUS_OFFSET\t\t0x10\n#define AO_CONTROL_OFFSET\t\t0x10\n#define\tDIO_PORT0_DIR_OFFSET\t0x20\n#define\tDIO_PORT0_DATA_OFFSET\t0x24\n#define\tDIO_PORT1_DIR_OFFSET\t0x28\n#define\tDIO_PORT1_DATA_OFFSET\t0x2c\n#define\tMISC_STATUS_OFFSET\t\t0x14\n#define\tMISC_CONTROL_OFFSET\t\t0x14\n\nenum ni_670x_boardid {\n\tBOARD_PCI6703,\n\tBOARD_PXI6704,\n\tBOARD_PCI6704,\n};\n\nstruct ni_670x_board {\n\tconst char *name;\n\tunsigned short ao_chans;\n};\n\nstatic const struct ni_670x_board ni_670x_boards[] = {\n\t[BOARD_PCI6703] = {\n\t\t.name\t\t= \"PCI-6703\",\n\t\t.ao_chans\t= 16,\n\t},\n\t[BOARD_PXI6704] = {\n\t\t.name\t\t= \"PXI-6704\",\n\t\t.ao_chans\t= 32,\n\t},\n\t[BOARD_PCI6704] = {\n\t\t.name\t\t= \"PCI-6704\",\n\t\t.ao_chans\t= 32,\n\t},\n};\n\nstruct ni_670x_private {\n\tint boardtype;\n\tint dio;\n};\n\nstatic int ni_670x_ao_insn_write(struct comedi_device *dev,\n\t\t\t\t struct comedi_subdevice *s,\n\t\t\t\t struct comedi_insn *insn,\n\t\t\t\t unsigned int *data)\n{\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int val = s->readback[chan];\n\tint i;\n\n\t \n\tfor (i = 0; i < insn->n; i++) {\n\t\tval = data[i];\n\t\t \n\t\twritel(((chan & 15) << 1) | ((chan & 16) >> 4),\n\t\t       dev->mmio + AO_CHAN_OFFSET);\n\t\t \n\t\twritel(val, dev->mmio + AO_VALUE_OFFSET);\n\t}\n\ts->readback[chan] = val;\n\n\treturn insn->n;\n}\n\nstatic int ni_670x_dio_insn_bits(struct comedi_device *dev,\n\t\t\t\t struct comedi_subdevice *s,\n\t\t\t\t struct comedi_insn *insn,\n\t\t\t\t unsigned int *data)\n{\n\tif (comedi_dio_update_state(s, data))\n\t\twritel(s->state, dev->mmio + DIO_PORT0_DATA_OFFSET);\n\n\tdata[1] = readl(dev->mmio + DIO_PORT0_DATA_OFFSET);\n\n\treturn insn->n;\n}\n\nstatic int ni_670x_dio_insn_config(struct comedi_device *dev,\n\t\t\t\t   struct comedi_subdevice *s,\n\t\t\t\t   struct comedi_insn *insn,\n\t\t\t\t   unsigned int *data)\n{\n\tint ret;\n\n\tret = comedi_dio_insn_config(dev, s, insn, data, 0);\n\tif (ret)\n\t\treturn ret;\n\n\twritel(s->io_bits, dev->mmio + DIO_PORT0_DIR_OFFSET);\n\n\treturn insn->n;\n}\n\n \n#define MITE_IODWBSR\t0xc0\t  \n#define WENAB\t\tBIT(7)  \n\nstatic int ni_670x_mite_init(struct pci_dev *pcidev)\n{\n\tvoid __iomem *mite_base;\n\tu32 main_phys_addr;\n\n\t \n\tmite_base = pci_ioremap_bar(pcidev, 0);\n\tif (!mite_base)\n\t\treturn -ENOMEM;\n\n\t \n\tmain_phys_addr = pci_resource_start(pcidev, 1);\n\twritel(main_phys_addr | WENAB, mite_base + MITE_IODWBSR);\n\n\t \n\tiounmap(mite_base);\n\treturn 0;\n}\n\nstatic int ni_670x_auto_attach(struct comedi_device *dev,\n\t\t\t       unsigned long context)\n{\n\tstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\n\tconst struct ni_670x_board *board = NULL;\n\tstruct ni_670x_private *devpriv;\n\tstruct comedi_subdevice *s;\n\tint ret;\n\tint i;\n\n\tif (context < ARRAY_SIZE(ni_670x_boards))\n\t\tboard = &ni_670x_boards[context];\n\tif (!board)\n\t\treturn -ENODEV;\n\tdev->board_ptr = board;\n\tdev->board_name = board->name;\n\n\tret = comedi_pci_enable(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tdevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\n\tif (!devpriv)\n\t\treturn -ENOMEM;\n\n\tret = ni_670x_mite_init(pcidev);\n\tif (ret)\n\t\treturn ret;\n\n\tdev->mmio = pci_ioremap_bar(pcidev, 1);\n\tif (!dev->mmio)\n\t\treturn -ENOMEM;\n\n\tret = comedi_alloc_subdevices(dev, 2);\n\tif (ret)\n\t\treturn ret;\n\n\ts = &dev->subdevices[0];\n\t \n\ts->type = COMEDI_SUBD_AO;\n\ts->subdev_flags = SDF_WRITABLE;\n\ts->n_chan = board->ao_chans;\n\ts->maxdata = 0xffff;\n\tif (s->n_chan == 32) {\n\t\tconst struct comedi_lrange **range_table_list;\n\n\t\trange_table_list = kmalloc_array(32,\n\t\t\t\t\t\t sizeof(struct comedi_lrange *),\n\t\t\t\t\t\t GFP_KERNEL);\n\t\tif (!range_table_list)\n\t\t\treturn -ENOMEM;\n\t\ts->range_table_list = range_table_list;\n\t\tfor (i = 0; i < 16; i++) {\n\t\t\trange_table_list[i] = &range_bipolar10;\n\t\t\trange_table_list[16 + i] = &range_0_20mA;\n\t\t}\n\t} else {\n\t\ts->range_table = &range_bipolar10;\n\t}\n\ts->insn_write = ni_670x_ao_insn_write;\n\n\tret = comedi_alloc_subdev_readback(s);\n\tif (ret)\n\t\treturn ret;\n\n\ts = &dev->subdevices[1];\n\t \n\ts->type = COMEDI_SUBD_DIO;\n\ts->subdev_flags = SDF_READABLE | SDF_WRITABLE;\n\ts->n_chan = 8;\n\ts->maxdata = 1;\n\ts->range_table = &range_digital;\n\ts->insn_bits = ni_670x_dio_insn_bits;\n\ts->insn_config = ni_670x_dio_insn_config;\n\n\t \n\twritel(0x10, dev->mmio + MISC_CONTROL_OFFSET);\n\t \n\twritel(0x00, dev->mmio + AO_CONTROL_OFFSET);\n\n\treturn 0;\n}\n\nstatic void ni_670x_detach(struct comedi_device *dev)\n{\n\tstruct comedi_subdevice *s;\n\n\tcomedi_pci_detach(dev);\n\tif (dev->n_subdevices) {\n\t\ts = &dev->subdevices[0];\n\t\tif (s)\n\t\t\tkfree(s->range_table_list);\n\t}\n}\n\nstatic struct comedi_driver ni_670x_driver = {\n\t.driver_name\t= \"ni_670x\",\n\t.module\t\t= THIS_MODULE,\n\t.auto_attach\t= ni_670x_auto_attach,\n\t.detach\t\t= ni_670x_detach,\n};\n\nstatic int ni_670x_pci_probe(struct pci_dev *dev,\n\t\t\t     const struct pci_device_id *id)\n{\n\treturn comedi_pci_auto_config(dev, &ni_670x_driver, id->driver_data);\n}\n\nstatic const struct pci_device_id ni_670x_pci_table[] = {\n\t{ PCI_VDEVICE(NI, 0x1290), BOARD_PCI6704 },\n\t{ PCI_VDEVICE(NI, 0x1920), BOARD_PXI6704 },\n\t{ PCI_VDEVICE(NI, 0x2c90), BOARD_PCI6703 },\n\t{ 0 }\n};\nMODULE_DEVICE_TABLE(pci, ni_670x_pci_table);\n\nstatic struct pci_driver ni_670x_pci_driver = {\n\t.name\t\t= \"ni_670x\",\n\t.id_table\t= ni_670x_pci_table,\n\t.probe\t\t= ni_670x_pci_probe,\n\t.remove\t\t= comedi_pci_auto_unconfig,\n};\nmodule_comedi_pci_driver(ni_670x_driver, ni_670x_pci_driver);\n\nMODULE_AUTHOR(\"Comedi https://www.comedi.org\");\nMODULE_DESCRIPTION(\"Comedi low-level driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}