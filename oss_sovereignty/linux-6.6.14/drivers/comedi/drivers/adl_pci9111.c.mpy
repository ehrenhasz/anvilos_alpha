{
  "module_name": "adl_pci9111.c",
  "hash_id": "2ac4a7c6f0d52e6dc99c24bec96eebb4e36793e3772e663743c01571f8bfc7a6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/adl_pci9111.c",
  "human_readable_source": "\n \n\n \n\n \n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/comedi/comedi_pci.h>\n#include <linux/comedi/comedi_8254.h>\n\n#include \"plx9052.h\"\n\n#define PCI9111_FIFO_HALF_SIZE\t512\n\n#define PCI9111_AI_ACQUISITION_PERIOD_MIN_NS\t10000\n\n#define PCI9111_RANGE_SETTING_DELAY\t\t10\n#define PCI9111_AI_INSTANT_READ_UDELAY_US\t2\n\n \n#define PCI9111_AI_FIFO_REG\t\t0x00\n#define PCI9111_AO_REG\t\t\t0x00\n#define PCI9111_DIO_REG\t\t\t0x02\n#define PCI9111_EDIO_REG\t\t0x04\n#define PCI9111_AI_CHANNEL_REG\t\t0x06\n#define PCI9111_AI_RANGE_STAT_REG\t0x08\n#define PCI9111_AI_STAT_AD_BUSY\t\tBIT(7)\n#define PCI9111_AI_STAT_FF_FF\t\tBIT(6)\n#define PCI9111_AI_STAT_FF_HF\t\tBIT(5)\n#define PCI9111_AI_STAT_FF_EF\t\tBIT(4)\n#define PCI9111_AI_RANGE(x)\t\t(((x) & 0x7) << 0)\n#define PCI9111_AI_RANGE_MASK\t\tPCI9111_AI_RANGE(7)\n#define PCI9111_AI_TRIG_CTRL_REG\t0x0a\n#define PCI9111_AI_TRIG_CTRL_TRGEVENT\tBIT(5)\n#define PCI9111_AI_TRIG_CTRL_POTRG\tBIT(4)\n#define PCI9111_AI_TRIG_CTRL_PTRG\tBIT(3)\n#define PCI9111_AI_TRIG_CTRL_ETIS\tBIT(2)\n#define PCI9111_AI_TRIG_CTRL_TPST\tBIT(1)\n#define PCI9111_AI_TRIG_CTRL_ASCAN\tBIT(0)\n#define PCI9111_INT_CTRL_REG\t\t0x0c\n#define PCI9111_INT_CTRL_ISC2\t\tBIT(3)\n#define PCI9111_INT_CTRL_FFEN\t\tBIT(2)\n#define PCI9111_INT_CTRL_ISC1\t\tBIT(1)\n#define PCI9111_INT_CTRL_ISC0\t\tBIT(0)\n#define PCI9111_SOFT_TRIG_REG\t\t0x0e\n#define PCI9111_8254_BASE_REG\t\t0x40\n#define PCI9111_INT_CLR_REG\t\t0x48\n\n \n#define PCI9111_LI1_ACTIVE\t(PLX9052_INTCSR_LI1ENAB |\t\\\n\t\t\t\t PLX9052_INTCSR_LI1STAT)\n\n \n#define PCI9111_LI2_ACTIVE\t(PLX9052_INTCSR_LI2ENAB |\t\\\n\t\t\t\t PLX9052_INTCSR_LI2STAT)\n\nstatic const struct comedi_lrange pci9111_ai_range = {\n\t5, {\n\t\tBIP_RANGE(10),\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(2.5),\n\t\tBIP_RANGE(1.25),\n\t\tBIP_RANGE(0.625)\n\t}\n};\n\nstruct pci9111_private_data {\n\tunsigned long lcr_io_base;\n\n\tunsigned int scan_delay;\n\tunsigned int chunk_counter;\n\tunsigned int chunk_num_samples;\n\n\tunsigned short ai_bounce_buffer[2 * PCI9111_FIFO_HALF_SIZE];\n};\n\nstatic void plx9050_interrupt_control(unsigned long io_base,\n\t\t\t\t      bool int1_enable,\n\t\t\t\t      bool int1_active_high,\n\t\t\t\t      bool int2_enable,\n\t\t\t\t      bool int2_active_high,\n\t\t\t\t      bool interrupt_enable)\n{\n\tint flags = 0;\n\n\tif (int1_enable)\n\t\tflags |= PLX9052_INTCSR_LI1ENAB;\n\tif (int1_active_high)\n\t\tflags |= PLX9052_INTCSR_LI1POL;\n\tif (int2_enable)\n\t\tflags |= PLX9052_INTCSR_LI2ENAB;\n\tif (int2_active_high)\n\t\tflags |= PLX9052_INTCSR_LI2POL;\n\n\tif (interrupt_enable)\n\t\tflags |= PLX9052_INTCSR_PCIENAB;\n\n\toutb(flags, io_base + PLX9052_INTCSR);\n}\n\nenum pci9111_ISC0_sources {\n\tirq_on_eoc,\n\tirq_on_fifo_half_full\n};\n\nenum pci9111_ISC1_sources {\n\tirq_on_timer_tick,\n\tirq_on_external_trigger\n};\n\nstatic void pci9111_interrupt_source_set(struct comedi_device *dev,\n\t\t\t\t\t enum pci9111_ISC0_sources irq_0_source,\n\t\t\t\t\t enum pci9111_ISC1_sources irq_1_source)\n{\n\tint flags;\n\n\t \n\tflags = inb(dev->iobase + PCI9111_AI_TRIG_CTRL_REG);\n\t \n\tflags >>= 4;\n\t \n\tflags &= 0xc0;\n\n\t \n\tif (irq_0_source == irq_on_fifo_half_full)\n\t\tflags |= PCI9111_INT_CTRL_ISC0;\n\n\tif (irq_1_source == irq_on_external_trigger)\n\t\tflags |= PCI9111_INT_CTRL_ISC1;\n\n\toutb(flags, dev->iobase + PCI9111_INT_CTRL_REG);\n}\n\nstatic void pci9111_fifo_reset(struct comedi_device *dev)\n{\n\tunsigned long int_ctrl_reg = dev->iobase + PCI9111_INT_CTRL_REG;\n\n\t \n\toutb(0, int_ctrl_reg);\n\toutb(PCI9111_INT_CTRL_FFEN, int_ctrl_reg);\n\toutb(0, int_ctrl_reg);\n}\n\nstatic int pci9111_ai_cancel(struct comedi_device *dev,\n\t\t\t     struct comedi_subdevice *s)\n{\n\tstruct pci9111_private_data *dev_private = dev->private;\n\n\t \n\tplx9050_interrupt_control(dev_private->lcr_io_base, true, true, true,\n\t\t\t\t  true, false);\n\n\t \n\toutb(0, dev->iobase + PCI9111_AI_TRIG_CTRL_REG);\n\n\tpci9111_fifo_reset(dev);\n\n\treturn 0;\n}\n\nstatic int pci9111_ai_check_chanlist(struct comedi_device *dev,\n\t\t\t\t     struct comedi_subdevice *s,\n\t\t\t\t     struct comedi_cmd *cmd)\n{\n\tunsigned int range0 = CR_RANGE(cmd->chanlist[0]);\n\tunsigned int aref0 = CR_AREF(cmd->chanlist[0]);\n\tint i;\n\n\tfor (i = 1; i < cmd->chanlist_len; i++) {\n\t\tunsigned int chan = CR_CHAN(cmd->chanlist[i]);\n\t\tunsigned int range = CR_RANGE(cmd->chanlist[i]);\n\t\tunsigned int aref = CR_AREF(cmd->chanlist[i]);\n\n\t\tif (chan != i) {\n\t\t\tdev_dbg(dev->class_dev,\n\t\t\t\t\"entries in chanlist must be consecutive channels,counting upwards from 0\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (range != range0) {\n\t\t\tdev_dbg(dev->class_dev,\n\t\t\t\t\"entries in chanlist must all have the same gain\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (aref != aref0) {\n\t\t\tdev_dbg(dev->class_dev,\n\t\t\t\t\"entries in chanlist must all have the same reference\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int pci9111_ai_do_cmd_test(struct comedi_device *dev,\n\t\t\t\t  struct comedi_subdevice *s,\n\t\t\t\t  struct comedi_cmd *cmd)\n{\n\tint err = 0;\n\tunsigned int arg;\n\n\t \n\n\terr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW);\n\terr |= comedi_check_trigger_src(&cmd->scan_begin_src,\n\t\t\t\t\tTRIG_TIMER | TRIG_FOLLOW | TRIG_EXT);\n\terr |= comedi_check_trigger_src(&cmd->convert_src,\n\t\t\t\t\tTRIG_TIMER | TRIG_EXT);\n\terr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\n\terr |= comedi_check_trigger_src(&cmd->stop_src,\n\t\t\t\t\tTRIG_COUNT | TRIG_NONE);\n\n\tif (err)\n\t\treturn 1;\n\n\t \n\n\terr |= comedi_check_trigger_is_unique(cmd->scan_begin_src);\n\terr |= comedi_check_trigger_is_unique(cmd->convert_src);\n\terr |= comedi_check_trigger_is_unique(cmd->stop_src);\n\n\t \n\n\tif (cmd->scan_begin_src != TRIG_FOLLOW) {\n\t\tif (cmd->scan_begin_src != cmd->convert_src)\n\t\t\terr |= -EINVAL;\n\t}\n\n\tif (err)\n\t\treturn 2;\n\n\t \n\n\terr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\n\n\tif (cmd->convert_src == TRIG_TIMER) {\n\t\terr |= comedi_check_trigger_arg_min(&cmd->convert_arg,\n\t\t\t\t\tPCI9111_AI_ACQUISITION_PERIOD_MIN_NS);\n\t} else {\t \n\t\terr |= comedi_check_trigger_arg_is(&cmd->convert_arg, 0);\n\t}\n\n\tif (cmd->scan_begin_src == TRIG_TIMER) {\n\t\terr |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,\n\t\t\t\t\tPCI9111_AI_ACQUISITION_PERIOD_MIN_NS);\n\t} else {\t \n\t\terr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);\n\t}\n\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\n\t\t\t\t\t   cmd->chanlist_len);\n\n\tif (cmd->stop_src == TRIG_COUNT)\n\t\terr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\n\telse\t \n\t\terr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\n\n\tif (err)\n\t\treturn 3;\n\n\t \n\n\tif (cmd->convert_src == TRIG_TIMER) {\n\t\targ = cmd->convert_arg;\n\t\tcomedi_8254_cascade_ns_to_timer(dev->pacer, &arg, cmd->flags);\n\t\terr |= comedi_check_trigger_arg_is(&cmd->convert_arg, arg);\n\t}\n\n\t \n\tif (cmd->scan_begin_src == TRIG_TIMER) {\n\t\targ = cmd->chanlist_len * cmd->convert_arg;\n\n\t\tif (arg < cmd->scan_begin_arg)\n\t\t\targ *= (cmd->scan_begin_arg / arg);\n\n\t\terr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, arg);\n\t}\n\n\tif (err)\n\t\treturn 4;\n\n\t \n\tif (cmd->chanlist && cmd->chanlist_len > 0)\n\t\terr |= pci9111_ai_check_chanlist(dev, s, cmd);\n\n\tif (err)\n\t\treturn 5;\n\n\treturn 0;\n}\n\nstatic int pci9111_ai_do_cmd(struct comedi_device *dev,\n\t\t\t     struct comedi_subdevice *s)\n{\n\tstruct pci9111_private_data *dev_private = dev->private;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tunsigned int last_chan = CR_CHAN(cmd->chanlist[cmd->chanlist_len - 1]);\n\tunsigned int range0 = CR_RANGE(cmd->chanlist[0]);\n\tunsigned int trig = 0;\n\n\t \n\t \n\t \n\n\tif (cmd->chanlist_len > 1)\n\t\ttrig |= PCI9111_AI_TRIG_CTRL_ASCAN;\n\n\toutb(last_chan, dev->iobase + PCI9111_AI_CHANNEL_REG);\n\n\t \n\toutb(PCI9111_AI_RANGE(range0), dev->iobase + PCI9111_AI_RANGE_STAT_REG);\n\n\t \n\tdev_private->scan_delay = 0;\n\tif (cmd->convert_src == TRIG_TIMER) {\n\t\ttrig |= PCI9111_AI_TRIG_CTRL_TPST;\n\t\tcomedi_8254_update_divisors(dev->pacer);\n\t\tcomedi_8254_pacer_enable(dev->pacer, 1, 2, true);\n\t\tpci9111_fifo_reset(dev);\n\t\tpci9111_interrupt_source_set(dev, irq_on_fifo_half_full,\n\t\t\t\t\t     irq_on_timer_tick);\n\t\tplx9050_interrupt_control(dev_private->lcr_io_base, true, true,\n\t\t\t\t\t  false, true, true);\n\n\t\tif (cmd->scan_begin_src == TRIG_TIMER) {\n\t\t\tdev_private->scan_delay = (cmd->scan_begin_arg /\n\t\t\t\t(cmd->convert_arg * cmd->chanlist_len)) - 1;\n\t\t}\n\t} else {\t \n\t\ttrig |= PCI9111_AI_TRIG_CTRL_ETIS;\n\t\tpci9111_fifo_reset(dev);\n\t\tpci9111_interrupt_source_set(dev, irq_on_fifo_half_full,\n\t\t\t\t\t     irq_on_timer_tick);\n\t\tplx9050_interrupt_control(dev_private->lcr_io_base, true, true,\n\t\t\t\t\t  false, true, true);\n\t}\n\toutb(trig, dev->iobase + PCI9111_AI_TRIG_CTRL_REG);\n\n\tdev_private->chunk_counter = 0;\n\tdev_private->chunk_num_samples = cmd->chanlist_len *\n\t\t\t\t\t (1 + dev_private->scan_delay);\n\n\treturn 0;\n}\n\nstatic void pci9111_ai_munge(struct comedi_device *dev,\n\t\t\t     struct comedi_subdevice *s, void *data,\n\t\t\t     unsigned int num_bytes,\n\t\t\t     unsigned int start_chan_index)\n{\n\tunsigned short *array = data;\n\tunsigned int maxdata = s->maxdata;\n\tunsigned int invert = (maxdata + 1) >> 1;\n\tunsigned int shift = (maxdata == 0xffff) ? 0 : 4;\n\tunsigned int num_samples = comedi_bytes_to_samples(s, num_bytes);\n\tunsigned int i;\n\n\tfor (i = 0; i < num_samples; i++)\n\t\tarray[i] = ((array[i] >> shift) & maxdata) ^ invert;\n}\n\nstatic void pci9111_handle_fifo_half_full(struct comedi_device *dev,\n\t\t\t\t\t  struct comedi_subdevice *s)\n{\n\tstruct pci9111_private_data *devpriv = dev->private;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tunsigned short *buf = devpriv->ai_bounce_buffer;\n\tunsigned int samples;\n\n\tsamples = comedi_nsamples_left(s, PCI9111_FIFO_HALF_SIZE);\n\tinsw(dev->iobase + PCI9111_AI_FIFO_REG, buf, samples);\n\n\tif (devpriv->scan_delay < 1) {\n\t\tcomedi_buf_write_samples(s, buf, samples);\n\t} else {\n\t\tunsigned int pos = 0;\n\t\tunsigned int to_read;\n\n\t\twhile (pos < samples) {\n\t\t\tif (devpriv->chunk_counter < cmd->chanlist_len) {\n\t\t\t\tto_read = cmd->chanlist_len -\n\t\t\t\t\t  devpriv->chunk_counter;\n\n\t\t\t\tif (to_read > samples - pos)\n\t\t\t\t\tto_read = samples - pos;\n\n\t\t\t\tcomedi_buf_write_samples(s, buf + pos, to_read);\n\t\t\t} else {\n\t\t\t\tto_read = devpriv->chunk_num_samples -\n\t\t\t\t\t  devpriv->chunk_counter;\n\n\t\t\t\tif (to_read > samples - pos)\n\t\t\t\t\tto_read = samples - pos;\n\t\t\t}\n\n\t\t\tpos += to_read;\n\t\t\tdevpriv->chunk_counter += to_read;\n\n\t\t\tif (devpriv->chunk_counter >=\n\t\t\t    devpriv->chunk_num_samples)\n\t\t\t\tdevpriv->chunk_counter = 0;\n\t\t}\n\t}\n}\n\nstatic irqreturn_t pci9111_interrupt(int irq, void *p_device)\n{\n\tstruct comedi_device *dev = p_device;\n\tstruct pci9111_private_data *dev_private = dev->private;\n\tstruct comedi_subdevice *s = dev->read_subdev;\n\tstruct comedi_async *async;\n\tstruct comedi_cmd *cmd;\n\tunsigned int status;\n\tunsigned long irq_flags;\n\tunsigned char intcsr;\n\n\tif (!dev->attached) {\n\t\t \n\t\t \n\t\treturn IRQ_NONE;\n\t}\n\n\tasync = s->async;\n\tcmd = &async->cmd;\n\n\tspin_lock_irqsave(&dev->spinlock, irq_flags);\n\n\t \n\tintcsr = inb(dev_private->lcr_io_base + PLX9052_INTCSR);\n\tif (!(((intcsr & PLX9052_INTCSR_PCIENAB) != 0) &&\n\t      (((intcsr & PCI9111_LI1_ACTIVE) == PCI9111_LI1_ACTIVE) ||\n\t       ((intcsr & PCI9111_LI2_ACTIVE) == PCI9111_LI2_ACTIVE)))) {\n\t\t \n\t\t \n\t\tspin_unlock_irqrestore(&dev->spinlock, irq_flags);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif ((intcsr & PCI9111_LI1_ACTIVE) == PCI9111_LI1_ACTIVE) {\n\t\t \n\n\t\tstatus = inb(dev->iobase + PCI9111_AI_RANGE_STAT_REG);\n\n\t\t \n\t\tif (!(status & PCI9111_AI_STAT_FF_FF)) {\n\t\t\tspin_unlock_irqrestore(&dev->spinlock, irq_flags);\n\t\t\tdev_dbg(dev->class_dev, \"fifo overflow\\n\");\n\t\t\toutb(0, dev->iobase + PCI9111_INT_CLR_REG);\n\t\t\tasync->events |= COMEDI_CB_ERROR;\n\t\t\tcomedi_handle_events(dev, s);\n\n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\n\t\t \n\t\tif (!(status & PCI9111_AI_STAT_FF_HF))\n\t\t\tpci9111_handle_fifo_half_full(dev, s);\n\t}\n\n\tif (cmd->stop_src == TRIG_COUNT && async->scans_done >= cmd->stop_arg)\n\t\tasync->events |= COMEDI_CB_EOA;\n\n\toutb(0, dev->iobase + PCI9111_INT_CLR_REG);\n\n\tspin_unlock_irqrestore(&dev->spinlock, irq_flags);\n\n\tcomedi_handle_events(dev, s);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int pci9111_ai_eoc(struct comedi_device *dev,\n\t\t\t  struct comedi_subdevice *s,\n\t\t\t  struct comedi_insn *insn,\n\t\t\t  unsigned long context)\n{\n\tunsigned int status;\n\n\tstatus = inb(dev->iobase + PCI9111_AI_RANGE_STAT_REG);\n\tif (status & PCI9111_AI_STAT_FF_EF)\n\t\treturn 0;\n\treturn -EBUSY;\n}\n\nstatic int pci9111_ai_insn_read(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tstruct comedi_insn *insn, unsigned int *data)\n{\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int range = CR_RANGE(insn->chanspec);\n\tunsigned int maxdata = s->maxdata;\n\tunsigned int invert = (maxdata + 1) >> 1;\n\tunsigned int shift = (maxdata == 0xffff) ? 0 : 4;\n\tunsigned int status;\n\tint ret;\n\tint i;\n\n\toutb(chan, dev->iobase + PCI9111_AI_CHANNEL_REG);\n\n\tstatus = inb(dev->iobase + PCI9111_AI_RANGE_STAT_REG);\n\tif ((status & PCI9111_AI_RANGE_MASK) != range) {\n\t\toutb(PCI9111_AI_RANGE(range),\n\t\t     dev->iobase + PCI9111_AI_RANGE_STAT_REG);\n\t}\n\n\tpci9111_fifo_reset(dev);\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\t \n\t\toutb(0, dev->iobase + PCI9111_SOFT_TRIG_REG);\n\n\t\tret = comedi_timeout(dev, s, insn, pci9111_ai_eoc, 0);\n\t\tif (ret) {\n\t\t\tpci9111_fifo_reset(dev);\n\t\t\treturn ret;\n\t\t}\n\n\t\tdata[i] = inw(dev->iobase + PCI9111_AI_FIFO_REG);\n\t\tdata[i] = ((data[i] >> shift) & maxdata) ^ invert;\n\t}\n\n\treturn i;\n}\n\nstatic int pci9111_ao_insn_write(struct comedi_device *dev,\n\t\t\t\t struct comedi_subdevice *s,\n\t\t\t\t struct comedi_insn *insn,\n\t\t\t\t unsigned int *data)\n{\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int val = s->readback[chan];\n\tint i;\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\tval = data[i];\n\t\toutw(val, dev->iobase + PCI9111_AO_REG);\n\t}\n\ts->readback[chan] = val;\n\n\treturn insn->n;\n}\n\nstatic int pci9111_di_insn_bits(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tstruct comedi_insn *insn,\n\t\t\t\tunsigned int *data)\n{\n\tdata[1] = inw(dev->iobase + PCI9111_DIO_REG);\n\n\treturn insn->n;\n}\n\nstatic int pci9111_do_insn_bits(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tstruct comedi_insn *insn,\n\t\t\t\tunsigned int *data)\n{\n\tif (comedi_dio_update_state(s, data))\n\t\toutw(s->state, dev->iobase + PCI9111_DIO_REG);\n\n\tdata[1] = s->state;\n\n\treturn insn->n;\n}\n\nstatic int pci9111_reset(struct comedi_device *dev)\n{\n\tstruct pci9111_private_data *dev_private = dev->private;\n\n\t \n\tplx9050_interrupt_control(dev_private->lcr_io_base, true, true, true,\n\t\t\t\t  true, false);\n\n\t \n\toutb(0, dev->iobase + PCI9111_AI_TRIG_CTRL_REG);\n\n\treturn 0;\n}\n\nstatic int pci9111_auto_attach(struct comedi_device *dev,\n\t\t\t       unsigned long context_unused)\n{\n\tstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\n\tstruct pci9111_private_data *dev_private;\n\tstruct comedi_subdevice *s;\n\tint ret;\n\n\tdev_private = comedi_alloc_devpriv(dev, sizeof(*dev_private));\n\tif (!dev_private)\n\t\treturn -ENOMEM;\n\n\tret = comedi_pci_enable(dev);\n\tif (ret)\n\t\treturn ret;\n\tdev_private->lcr_io_base = pci_resource_start(pcidev, 1);\n\tdev->iobase = pci_resource_start(pcidev, 2);\n\n\tpci9111_reset(dev);\n\n\tif (pcidev->irq) {\n\t\tret = request_irq(pcidev->irq, pci9111_interrupt,\n\t\t\t\t  IRQF_SHARED, dev->board_name, dev);\n\t\tif (ret == 0)\n\t\t\tdev->irq = pcidev->irq;\n\t}\n\n\tdev->pacer = comedi_8254_init(dev->iobase + PCI9111_8254_BASE_REG,\n\t\t\t\t      I8254_OSC_BASE_2MHZ, I8254_IO16, 0);\n\tif (!dev->pacer)\n\t\treturn -ENOMEM;\n\n\tret = comedi_alloc_subdevices(dev, 4);\n\tif (ret)\n\t\treturn ret;\n\n\ts = &dev->subdevices[0];\n\ts->type\t\t= COMEDI_SUBD_AI;\n\ts->subdev_flags\t= SDF_READABLE | SDF_COMMON;\n\ts->n_chan\t= 16;\n\ts->maxdata\t= 0xffff;\n\ts->range_table\t= &pci9111_ai_range;\n\ts->insn_read\t= pci9111_ai_insn_read;\n\tif (dev->irq) {\n\t\tdev->read_subdev = s;\n\t\ts->subdev_flags\t|= SDF_CMD_READ;\n\t\ts->len_chanlist\t= s->n_chan;\n\t\ts->do_cmdtest\t= pci9111_ai_do_cmd_test;\n\t\ts->do_cmd\t= pci9111_ai_do_cmd;\n\t\ts->cancel\t= pci9111_ai_cancel;\n\t\ts->munge\t= pci9111_ai_munge;\n\t}\n\n\ts = &dev->subdevices[1];\n\ts->type\t\t= COMEDI_SUBD_AO;\n\ts->subdev_flags\t= SDF_WRITABLE | SDF_COMMON;\n\ts->n_chan\t= 1;\n\ts->maxdata\t= 0x0fff;\n\ts->len_chanlist\t= 1;\n\ts->range_table\t= &range_bipolar10;\n\ts->insn_write\t= pci9111_ao_insn_write;\n\n\tret = comedi_alloc_subdev_readback(s);\n\tif (ret)\n\t\treturn ret;\n\n\ts = &dev->subdevices[2];\n\ts->type\t\t= COMEDI_SUBD_DI;\n\ts->subdev_flags\t= SDF_READABLE;\n\ts->n_chan\t= 16;\n\ts->maxdata\t= 1;\n\ts->range_table\t= &range_digital;\n\ts->insn_bits\t= pci9111_di_insn_bits;\n\n\ts = &dev->subdevices[3];\n\ts->type\t\t= COMEDI_SUBD_DO;\n\ts->subdev_flags\t= SDF_WRITABLE;\n\ts->n_chan\t= 16;\n\ts->maxdata\t= 1;\n\ts->range_table\t= &range_digital;\n\ts->insn_bits\t= pci9111_do_insn_bits;\n\n\treturn 0;\n}\n\nstatic void pci9111_detach(struct comedi_device *dev)\n{\n\tif (dev->iobase)\n\t\tpci9111_reset(dev);\n\tcomedi_pci_detach(dev);\n}\n\nstatic struct comedi_driver adl_pci9111_driver = {\n\t.driver_name\t= \"adl_pci9111\",\n\t.module\t\t= THIS_MODULE,\n\t.auto_attach\t= pci9111_auto_attach,\n\t.detach\t\t= pci9111_detach,\n};\n\nstatic int pci9111_pci_probe(struct pci_dev *dev,\n\t\t\t     const struct pci_device_id *id)\n{\n\treturn comedi_pci_auto_config(dev, &adl_pci9111_driver,\n\t\t\t\t      id->driver_data);\n}\n\nstatic const struct pci_device_id pci9111_pci_table[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_ADLINK, 0x9111) },\n\t \n\t{ 0 }\n};\nMODULE_DEVICE_TABLE(pci, pci9111_pci_table);\n\nstatic struct pci_driver adl_pci9111_pci_driver = {\n\t.name\t\t= \"adl_pci9111\",\n\t.id_table\t= pci9111_pci_table,\n\t.probe\t\t= pci9111_pci_probe,\n\t.remove\t\t= comedi_pci_auto_unconfig,\n};\nmodule_comedi_pci_driver(adl_pci9111_driver, adl_pci9111_pci_driver);\n\nMODULE_AUTHOR(\"Comedi https://www.comedi.org\");\nMODULE_DESCRIPTION(\"Comedi low-level driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}