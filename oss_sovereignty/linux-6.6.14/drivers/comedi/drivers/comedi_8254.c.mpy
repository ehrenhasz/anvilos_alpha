{
  "module_name": "comedi_8254.c",
  "hash_id": "71dbc1b427d889ffdffb8fa290d705f66c0d7a02c53d4610f14f98e82e29dba2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/comedi_8254.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/comedi/comedidev.h>\n#include <linux/comedi/comedi_8254.h>\n\nstatic unsigned int __i8254_read(struct comedi_8254 *i8254, unsigned int reg)\n{\n\tunsigned int reg_offset = (reg * i8254->iosize) << i8254->regshift;\n\tunsigned int val;\n\n\tswitch (i8254->iosize) {\n\tdefault:\n\tcase I8254_IO8:\n\t\tif (i8254->mmio)\n\t\t\tval = readb(i8254->mmio + reg_offset);\n\t\telse\n\t\t\tval = inb(i8254->iobase + reg_offset);\n\t\tbreak;\n\tcase I8254_IO16:\n\t\tif (i8254->mmio)\n\t\t\tval = readw(i8254->mmio + reg_offset);\n\t\telse\n\t\t\tval = inw(i8254->iobase + reg_offset);\n\t\tbreak;\n\tcase I8254_IO32:\n\t\tif (i8254->mmio)\n\t\t\tval = readl(i8254->mmio + reg_offset);\n\t\telse\n\t\t\tval = inl(i8254->iobase + reg_offset);\n\t\tbreak;\n\t}\n\treturn val & 0xff;\n}\n\nstatic void __i8254_write(struct comedi_8254 *i8254,\n\t\t\t  unsigned int val, unsigned int reg)\n{\n\tunsigned int reg_offset = (reg * i8254->iosize) << i8254->regshift;\n\n\tswitch (i8254->iosize) {\n\tdefault:\n\tcase I8254_IO8:\n\t\tif (i8254->mmio)\n\t\t\twriteb(val, i8254->mmio + reg_offset);\n\t\telse\n\t\t\toutb(val, i8254->iobase + reg_offset);\n\t\tbreak;\n\tcase I8254_IO16:\n\t\tif (i8254->mmio)\n\t\t\twritew(val, i8254->mmio + reg_offset);\n\t\telse\n\t\t\toutw(val, i8254->iobase + reg_offset);\n\t\tbreak;\n\tcase I8254_IO32:\n\t\tif (i8254->mmio)\n\t\t\twritel(val, i8254->mmio + reg_offset);\n\t\telse\n\t\t\toutl(val, i8254->iobase + reg_offset);\n\t\tbreak;\n\t}\n}\n\n \nunsigned int comedi_8254_status(struct comedi_8254 *i8254, unsigned int counter)\n{\n\tunsigned int cmd;\n\n\tif (counter > 2)\n\t\treturn 0;\n\n\tcmd = I8254_CTRL_READBACK_STATUS | I8254_CTRL_READBACK_SEL_CTR(counter);\n\t__i8254_write(i8254, cmd, I8254_CTRL_REG);\n\n\treturn __i8254_read(i8254, counter);\n}\nEXPORT_SYMBOL_GPL(comedi_8254_status);\n\n \nunsigned int comedi_8254_read(struct comedi_8254 *i8254, unsigned int counter)\n{\n\tunsigned int val;\n\n\tif (counter > 2)\n\t\treturn 0;\n\n\t \n\t__i8254_write(i8254, I8254_CTRL_SEL_CTR(counter) | I8254_CTRL_LATCH,\n\t\t      I8254_CTRL_REG);\n\n\t \n\tval = __i8254_read(i8254, counter);\n\tval |= (__i8254_read(i8254, counter) << 8);\n\n\treturn val;\n}\nEXPORT_SYMBOL_GPL(comedi_8254_read);\n\n \nvoid comedi_8254_write(struct comedi_8254 *i8254,\n\t\t       unsigned int counter, unsigned int val)\n{\n\tunsigned int byte;\n\n\tif (counter > 2)\n\t\treturn;\n\tif (val > 0xffff)\n\t\treturn;\n\n\t \n\tbyte = val & 0xff;\n\t__i8254_write(i8254, byte, counter);\n\tbyte = (val >> 8) & 0xff;\n\t__i8254_write(i8254, byte, counter);\n}\nEXPORT_SYMBOL_GPL(comedi_8254_write);\n\n \nint comedi_8254_set_mode(struct comedi_8254 *i8254, unsigned int counter,\n\t\t\t unsigned int mode)\n{\n\tunsigned int byte;\n\n\tif (counter > 2)\n\t\treturn -EINVAL;\n\tif (mode > (I8254_MODE5 | I8254_BCD))\n\t\treturn -EINVAL;\n\n\tbyte = I8254_CTRL_SEL_CTR(counter) |\t \n\t       I8254_CTRL_LSB_MSB |\t\t \n\t       mode;\t\t\t\t \n\t__i8254_write(i8254, byte, I8254_CTRL_REG);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(comedi_8254_set_mode);\n\n \nint comedi_8254_load(struct comedi_8254 *i8254, unsigned int counter,\n\t\t     unsigned int val, unsigned int mode)\n{\n\tif (counter > 2)\n\t\treturn -EINVAL;\n\tif (val > 0xffff)\n\t\treturn -EINVAL;\n\tif (mode > (I8254_MODE5 | I8254_BCD))\n\t\treturn -EINVAL;\n\n\tcomedi_8254_set_mode(i8254, counter, mode);\n\tcomedi_8254_write(i8254, counter, val);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(comedi_8254_load);\n\n \nvoid comedi_8254_pacer_enable(struct comedi_8254 *i8254,\n\t\t\t      unsigned int counter1,\n\t\t\t      unsigned int counter2,\n\t\t\t      bool enable)\n{\n\tunsigned int mode;\n\n\tif (counter1 > 2 || counter2 > 2 || counter1 == counter2)\n\t\treturn;\n\n\tif (enable)\n\t\tmode = I8254_MODE2 | I8254_BINARY;\n\telse\n\t\tmode = I8254_MODE0 | I8254_BINARY;\n\n\tcomedi_8254_set_mode(i8254, counter1, mode);\n\tcomedi_8254_set_mode(i8254, counter2, mode);\n\n\tif (enable) {\n\t\t \n\t\tcomedi_8254_write(i8254, counter2, i8254->divisor2);\n\t\tcomedi_8254_write(i8254, counter1, i8254->divisor1);\n\t}\n}\nEXPORT_SYMBOL_GPL(comedi_8254_pacer_enable);\n\n \nvoid comedi_8254_update_divisors(struct comedi_8254 *i8254)\n{\n\t \n\ti8254->divisor = i8254->next_div & 0xffff;\n\ti8254->divisor1 = i8254->next_div1 & 0xffff;\n\ti8254->divisor2 = i8254->next_div2 & 0xffff;\n}\nEXPORT_SYMBOL_GPL(comedi_8254_update_divisors);\n\n \nvoid comedi_8254_cascade_ns_to_timer(struct comedi_8254 *i8254,\n\t\t\t\t     unsigned int *nanosec,\n\t\t\t\t     unsigned int flags)\n{\n\tunsigned int d1 = i8254->next_div1 ? i8254->next_div1 : I8254_MAX_COUNT;\n\tunsigned int d2 = i8254->next_div2 ? i8254->next_div2 : I8254_MAX_COUNT;\n\tunsigned int div = d1 * d2;\n\tunsigned int ns_lub = 0xffffffff;\n\tunsigned int ns_glb = 0;\n\tunsigned int d1_lub = 0;\n\tunsigned int d1_glb = 0;\n\tunsigned int d2_lub = 0;\n\tunsigned int d2_glb = 0;\n\tunsigned int start;\n\tunsigned int ns;\n\tunsigned int ns_low;\n\tunsigned int ns_high;\n\n\t \n\tif (div * i8254->osc_base == *nanosec &&\n\t    d1 > 1 && d1 <= I8254_MAX_COUNT &&\n\t    d2 > 1 && d2 <= I8254_MAX_COUNT &&\n\t     \n\t    div > d1 && div > d2 &&\n\t    div * i8254->osc_base > div &&\n\t    div * i8254->osc_base > i8254->osc_base)\n\t\treturn;\n\n\tdiv = *nanosec / i8254->osc_base;\n\td2 = I8254_MAX_COUNT;\n\tstart = div / d2;\n\tif (start < 2)\n\t\tstart = 2;\n\tfor (d1 = start; d1 <= div / d1 + 1 && d1 <= I8254_MAX_COUNT; d1++) {\n\t\tfor (d2 = div / d1;\n\t\t     d1 * d2 <= div + d1 + 1 && d2 <= I8254_MAX_COUNT; d2++) {\n\t\t\tns = i8254->osc_base * d1 * d2;\n\t\t\tif (ns <= *nanosec && ns > ns_glb) {\n\t\t\t\tns_glb = ns;\n\t\t\t\td1_glb = d1;\n\t\t\t\td2_glb = d2;\n\t\t\t}\n\t\t\tif (ns >= *nanosec && ns < ns_lub) {\n\t\t\t\tns_lub = ns;\n\t\t\t\td1_lub = d1;\n\t\t\t\td2_lub = d2;\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch (flags & CMDF_ROUND_MASK) {\n\tcase CMDF_ROUND_NEAREST:\n\tdefault:\n\t\tns_high = d1_lub * d2_lub * i8254->osc_base;\n\t\tns_low = d1_glb * d2_glb * i8254->osc_base;\n\t\tif (ns_high - *nanosec < *nanosec - ns_low) {\n\t\t\td1 = d1_lub;\n\t\t\td2 = d2_lub;\n\t\t} else {\n\t\t\td1 = d1_glb;\n\t\t\td2 = d2_glb;\n\t\t}\n\t\tbreak;\n\tcase CMDF_ROUND_UP:\n\t\td1 = d1_lub;\n\t\td2 = d2_lub;\n\t\tbreak;\n\tcase CMDF_ROUND_DOWN:\n\t\td1 = d1_glb;\n\t\td2 = d2_glb;\n\t\tbreak;\n\t}\n\n\t*nanosec = d1 * d2 * i8254->osc_base;\n\ti8254->next_div1 = d1;\n\ti8254->next_div2 = d2;\n}\nEXPORT_SYMBOL_GPL(comedi_8254_cascade_ns_to_timer);\n\n \nvoid comedi_8254_ns_to_timer(struct comedi_8254 *i8254,\n\t\t\t     unsigned int *nanosec, unsigned int flags)\n{\n\tunsigned int divisor;\n\n\tswitch (flags & CMDF_ROUND_MASK) {\n\tdefault:\n\tcase CMDF_ROUND_NEAREST:\n\t\tdivisor = DIV_ROUND_CLOSEST(*nanosec, i8254->osc_base);\n\t\tbreak;\n\tcase CMDF_ROUND_UP:\n\t\tdivisor = DIV_ROUND_UP(*nanosec, i8254->osc_base);\n\t\tbreak;\n\tcase CMDF_ROUND_DOWN:\n\t\tdivisor = *nanosec / i8254->osc_base;\n\t\tbreak;\n\t}\n\tif (divisor < 2)\n\t\tdivisor = 2;\n\tif (divisor > I8254_MAX_COUNT)\n\t\tdivisor = I8254_MAX_COUNT;\n\n\t*nanosec = divisor * i8254->osc_base;\n\ti8254->next_div = divisor;\n}\nEXPORT_SYMBOL_GPL(comedi_8254_ns_to_timer);\n\n \nvoid comedi_8254_set_busy(struct comedi_8254 *i8254,\n\t\t\t  unsigned int counter, bool busy)\n{\n\tif (counter < 3)\n\t\ti8254->busy[counter] = busy;\n}\nEXPORT_SYMBOL_GPL(comedi_8254_set_busy);\n\nstatic int comedi_8254_insn_read(struct comedi_device *dev,\n\t\t\t\t struct comedi_subdevice *s,\n\t\t\t\t struct comedi_insn *insn,\n\t\t\t\t unsigned int *data)\n{\n\tstruct comedi_8254 *i8254 = s->private;\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tint i;\n\n\tif (i8254->busy[chan])\n\t\treturn -EBUSY;\n\n\tfor (i = 0; i < insn->n; i++)\n\t\tdata[i] = comedi_8254_read(i8254, chan);\n\n\treturn insn->n;\n}\n\nstatic int comedi_8254_insn_write(struct comedi_device *dev,\n\t\t\t\t  struct comedi_subdevice *s,\n\t\t\t\t  struct comedi_insn *insn,\n\t\t\t\t  unsigned int *data)\n{\n\tstruct comedi_8254 *i8254 = s->private;\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\n\tif (i8254->busy[chan])\n\t\treturn -EBUSY;\n\n\tif (insn->n)\n\t\tcomedi_8254_write(i8254, chan, data[insn->n - 1]);\n\n\treturn insn->n;\n}\n\nstatic int comedi_8254_insn_config(struct comedi_device *dev,\n\t\t\t\t   struct comedi_subdevice *s,\n\t\t\t\t   struct comedi_insn *insn,\n\t\t\t\t   unsigned int *data)\n{\n\tstruct comedi_8254 *i8254 = s->private;\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tint ret;\n\n\tif (i8254->busy[chan])\n\t\treturn -EBUSY;\n\n\tswitch (data[0]) {\n\tcase INSN_CONFIG_RESET:\n\t\tret = comedi_8254_set_mode(i8254, chan,\n\t\t\t\t\t   I8254_MODE0 | I8254_BINARY);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase INSN_CONFIG_SET_COUNTER_MODE:\n\t\tret = comedi_8254_set_mode(i8254, chan, data[1]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase INSN_CONFIG_8254_READ_STATUS:\n\t\tdata[1] = comedi_8254_status(i8254, chan);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tif (i8254->insn_config)\n\t\t\treturn i8254->insn_config(dev, s, insn, data);\n\n\t\treturn -EINVAL;\n\t}\n\n\treturn insn->n;\n}\n\n \nvoid comedi_8254_subdevice_init(struct comedi_subdevice *s,\n\t\t\t\tstruct comedi_8254 *i8254)\n{\n\ts->type\t\t= COMEDI_SUBD_COUNTER;\n\ts->subdev_flags\t= SDF_READABLE | SDF_WRITABLE;\n\ts->n_chan\t= 3;\n\ts->maxdata\t= 0xffff;\n\ts->range_table\t= &range_unknown;\n\ts->insn_read\t= comedi_8254_insn_read;\n\ts->insn_write\t= comedi_8254_insn_write;\n\ts->insn_config\t= comedi_8254_insn_config;\n\n\ts->private\t= i8254;\n}\nEXPORT_SYMBOL_GPL(comedi_8254_subdevice_init);\n\nstatic struct comedi_8254 *__i8254_init(unsigned long iobase,\n\t\t\t\t\tvoid __iomem *mmio,\n\t\t\t\t\tunsigned int osc_base,\n\t\t\t\t\tunsigned int iosize,\n\t\t\t\t\tunsigned int regshift)\n{\n\tstruct comedi_8254 *i8254;\n\tint i;\n\n\t \n\tif (!(iosize == I8254_IO8 || iosize == I8254_IO16 ||\n\t      iosize == I8254_IO32))\n\t\treturn NULL;\n\n\ti8254 = kzalloc(sizeof(*i8254), GFP_KERNEL);\n\tif (!i8254)\n\t\treturn NULL;\n\n\ti8254->iobase\t= iobase;\n\ti8254->mmio\t= mmio;\n\ti8254->iosize\t= iosize;\n\ti8254->regshift\t= regshift;\n\n\t \n\ti8254->osc_base\t= osc_base ? osc_base : I8254_OSC_BASE_10MHZ;\n\n\t \n\tfor (i = 0; i < 3; i++)\n\t\tcomedi_8254_set_mode(i8254, i, I8254_MODE0 | I8254_BINARY);\n\n\treturn i8254;\n}\n\n \nstruct comedi_8254 *comedi_8254_init(unsigned long iobase,\n\t\t\t\t     unsigned int osc_base,\n\t\t\t\t     unsigned int iosize,\n\t\t\t\t     unsigned int regshift)\n{\n\treturn __i8254_init(iobase, NULL, osc_base, iosize, regshift);\n}\nEXPORT_SYMBOL_GPL(comedi_8254_init);\n\n \nstruct comedi_8254 *comedi_8254_mm_init(void __iomem *mmio,\n\t\t\t\t\tunsigned int osc_base,\n\t\t\t\t\tunsigned int iosize,\n\t\t\t\t\tunsigned int regshift)\n{\n\treturn __i8254_init(0, mmio, osc_base, iosize, regshift);\n}\nEXPORT_SYMBOL_GPL(comedi_8254_mm_init);\n\nstatic int __init comedi_8254_module_init(void)\n{\n\treturn 0;\n}\nmodule_init(comedi_8254_module_init);\n\nstatic void __exit comedi_8254_module_exit(void)\n{\n}\nmodule_exit(comedi_8254_module_exit);\n\nMODULE_AUTHOR(\"H Hartley Sweeten <hsweeten@visionengravers.com>\");\nMODULE_DESCRIPTION(\"Comedi: Generic 8254 timer/counter support\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}