{
  "module_name": "das08.c",
  "hash_id": "cf67804db4442d9f2eb8643040c6cc4497b4ba827c539f1faded8bc7986f7d07",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/das08.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/comedi/comedidev.h>\n#include <linux/comedi/comedi_8255.h>\n#include <linux/comedi/comedi_8254.h>\n\n#include \"das08.h\"\n\n \n#define DAS08_AI_LSB_REG\t0x00\t \n#define DAS08_AI_MSB_REG\t0x01\t \n#define DAS08_AI_TRIG_REG\t0x01\t \n#define DAS08_STATUS_REG\t0x02\t \n#define DAS08_STATUS_AI_BUSY\tBIT(7)\t \n \n#define DAS08_STATUS_IRQ\tBIT(3)\t \n \n#define DAS08_STATUS_DI(x)\t(((x) & 0x70) >> 4)\n#define DAS08_CONTROL_REG\t0x02\t \n \n#define DAS08_CONTROL_MUX_MASK\t0x7\t \n#define DAS08_CONTROL_MUX(x)\t((x) & DAS08_CONTROL_MUX_MASK)  \n#define DAS08_CONTROL_INTE\tBIT(3)\t \n#define DAS08_CONTROL_DO_MASK\t0xf0\t \n \n#define DAS08_CONTROL_DO(x)\t(((x) << 4) & DAS08_CONTROL_DO_MASK)\n \n#define DAS08_GAIN_REG\t\t0x03\n\n#define DAS08JR_DI_REG\t\t0x03\t \n#define DAS08JR_DO_REG\t\t0x03\t \n \n#define DAS08JR_AO_LSB_REG(x)\t((x) ? 0x06 : 0x04)\n \n#define DAS08JR_AO_MSB_REG(x)\t((x) ? 0x07 : 0x05)\n \n#define DAS08JR_AO_UPDATE_REG\t0x03\n\n \n#define DAS08AOX_AO_LSB_REG(x)\t((x) ? 0x0a : 0x08)\n \n#define DAS08AOX_AO_MSB_REG(x)\t((x) ? 0x0b : 0x09)\n \n#define DAS08AOX_AO_UPDATE_REG\t0x08\n\n \n\nstatic const struct comedi_lrange das08_pgl_ai_range = {\n\t9, {\n\t\tBIP_RANGE(10),\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(2.5),\n\t\tBIP_RANGE(1.25),\n\t\tBIP_RANGE(0.625),\n\t\tUNI_RANGE(10),\n\t\tUNI_RANGE(5),\n\t\tUNI_RANGE(2.5),\n\t\tUNI_RANGE(1.25)\n\t}\n};\n\nstatic const struct comedi_lrange das08_pgh_ai_range = {\n\t12, {\n\t\tBIP_RANGE(10),\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(1),\n\t\tBIP_RANGE(0.5),\n\t\tBIP_RANGE(0.1),\n\t\tBIP_RANGE(0.05),\n\t\tBIP_RANGE(0.01),\n\t\tBIP_RANGE(0.005),\n\t\tUNI_RANGE(10),\n\t\tUNI_RANGE(1),\n\t\tUNI_RANGE(0.1),\n\t\tUNI_RANGE(0.01)\n\t}\n};\n\nstatic const struct comedi_lrange das08_pgm_ai_range = {\n\t9, {\n\t\tBIP_RANGE(10),\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(0.5),\n\t\tBIP_RANGE(0.05),\n\t\tBIP_RANGE(0.01),\n\t\tUNI_RANGE(10),\n\t\tUNI_RANGE(1),\n\t\tUNI_RANGE(0.1),\n\t\tUNI_RANGE(0.01)\n\t}\n};\n\nstatic const struct comedi_lrange *const das08_ai_lranges[] = {\n\t[das08_pg_none]\t\t= &range_unknown,\n\t[das08_bipolar5]\t= &range_bipolar5,\n\t[das08_pgh]\t\t= &das08_pgh_ai_range,\n\t[das08_pgl]\t\t= &das08_pgl_ai_range,\n\t[das08_pgm]\t\t= &das08_pgm_ai_range,\n};\n\nstatic const int das08_pgh_ai_gainlist[] = {\n\t8, 0, 10, 2, 12, 4, 14, 6, 1, 3, 5, 7\n};\nstatic const int das08_pgl_ai_gainlist[] = { 8, 0, 2, 4, 6, 1, 3, 5, 7 };\nstatic const int das08_pgm_ai_gainlist[] = { 8, 0, 10, 12, 14, 9, 11, 13, 15 };\n\nstatic const int *const das08_ai_gainlists[] = {\n\t[das08_pg_none]\t\t= NULL,\n\t[das08_bipolar5]\t= NULL,\n\t[das08_pgh]\t\t= das08_pgh_ai_gainlist,\n\t[das08_pgl]\t\t= das08_pgl_ai_gainlist,\n\t[das08_pgm]\t\t= das08_pgm_ai_gainlist,\n};\n\nstatic int das08_ai_eoc(struct comedi_device *dev,\n\t\t\tstruct comedi_subdevice *s,\n\t\t\tstruct comedi_insn *insn,\n\t\t\tunsigned long context)\n{\n\tunsigned int status;\n\n\tstatus = inb(dev->iobase + DAS08_STATUS_REG);\n\tif ((status & DAS08_STATUS_AI_BUSY) == 0)\n\t\treturn 0;\n\treturn -EBUSY;\n}\n\nstatic int das08_ai_insn_read(struct comedi_device *dev,\n\t\t\t      struct comedi_subdevice *s,\n\t\t\t      struct comedi_insn *insn, unsigned int *data)\n{\n\tconst struct das08_board_struct *board = dev->board_ptr;\n\tstruct das08_private_struct *devpriv = dev->private;\n\tint n;\n\tint chan;\n\tint range;\n\tint lsb, msb;\n\tint ret;\n\n\tchan = CR_CHAN(insn->chanspec);\n\trange = CR_RANGE(insn->chanspec);\n\n\t \n\tinb(dev->iobase + DAS08_AI_LSB_REG);\n\tinb(dev->iobase + DAS08_AI_MSB_REG);\n\n\t \n\t \n\tspin_lock(&dev->spinlock);\n\tdevpriv->do_mux_bits &= ~DAS08_CONTROL_MUX_MASK;\n\tdevpriv->do_mux_bits |= DAS08_CONTROL_MUX(chan);\n\toutb(devpriv->do_mux_bits, dev->iobase + DAS08_CONTROL_REG);\n\tspin_unlock(&dev->spinlock);\n\n\tif (devpriv->pg_gainlist) {\n\t\t \n\t\trange = CR_RANGE(insn->chanspec);\n\t\toutb(devpriv->pg_gainlist[range],\n\t\t     dev->iobase + DAS08_GAIN_REG);\n\t}\n\n\tfor (n = 0; n < insn->n; n++) {\n\t\t \n\t\tif (board->ai_nbits == 16)\n\t\t\tif (inb(dev->iobase + DAS08_AI_MSB_REG) & 0x80)\n\t\t\t\tdev_info(dev->class_dev, \"over-range\\n\");\n\n\t\t \n\t\toutb_p(0, dev->iobase + DAS08_AI_TRIG_REG);\n\n\t\tret = comedi_timeout(dev, s, insn, das08_ai_eoc, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tmsb = inb(dev->iobase + DAS08_AI_MSB_REG);\n\t\tlsb = inb(dev->iobase + DAS08_AI_LSB_REG);\n\t\tif (board->ai_encoding == das08_encode12) {\n\t\t\tdata[n] = (lsb >> 4) | (msb << 4);\n\t\t} else if (board->ai_encoding == das08_pcm_encode12) {\n\t\t\tdata[n] = (msb << 8) + lsb;\n\t\t} else if (board->ai_encoding == das08_encode16) {\n\t\t\t \n\t\t\tunsigned int magnitude = lsb | ((msb & 0x7f) << 8);\n\n\t\t\t \n\t\t\tif (msb & 0x80)\n\t\t\t\tdata[n] = BIT(15) + magnitude;\n\t\t\telse\n\t\t\t\tdata[n] = BIT(15) - magnitude;\n\t\t} else {\n\t\t\tdev_err(dev->class_dev, \"bug! unknown ai encoding\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn n;\n}\n\nstatic int das08_di_insn_bits(struct comedi_device *dev,\n\t\t\t      struct comedi_subdevice *s,\n\t\t\t      struct comedi_insn *insn, unsigned int *data)\n{\n\tdata[0] = 0;\n\tdata[1] = DAS08_STATUS_DI(inb(dev->iobase + DAS08_STATUS_REG));\n\n\treturn insn->n;\n}\n\nstatic int das08_do_insn_bits(struct comedi_device *dev,\n\t\t\t      struct comedi_subdevice *s,\n\t\t\t      struct comedi_insn *insn, unsigned int *data)\n{\n\tstruct das08_private_struct *devpriv = dev->private;\n\n\tif (comedi_dio_update_state(s, data)) {\n\t\t \n\t\tspin_lock(&dev->spinlock);\n\t\tdevpriv->do_mux_bits &= ~DAS08_CONTROL_DO_MASK;\n\t\tdevpriv->do_mux_bits |= DAS08_CONTROL_DO(s->state);\n\t\toutb(devpriv->do_mux_bits, dev->iobase + DAS08_CONTROL_REG);\n\t\tspin_unlock(&dev->spinlock);\n\t}\n\n\tdata[1] = s->state;\n\n\treturn insn->n;\n}\n\nstatic int das08jr_di_insn_bits(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tstruct comedi_insn *insn, unsigned int *data)\n{\n\tdata[0] = 0;\n\tdata[1] = inb(dev->iobase + DAS08JR_DI_REG);\n\n\treturn insn->n;\n}\n\nstatic int das08jr_do_insn_bits(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tstruct comedi_insn *insn, unsigned int *data)\n{\n\tif (comedi_dio_update_state(s, data))\n\t\toutb(s->state, dev->iobase + DAS08JR_DO_REG);\n\n\tdata[1] = s->state;\n\n\treturn insn->n;\n}\n\nstatic void das08_ao_set_data(struct comedi_device *dev,\n\t\t\t      unsigned int chan, unsigned int data)\n{\n\tconst struct das08_board_struct *board = dev->board_ptr;\n\tunsigned char lsb;\n\tunsigned char msb;\n\n\tlsb = data & 0xff;\n\tmsb = (data >> 8) & 0xff;\n\tif (board->is_jr) {\n\t\toutb(lsb, dev->iobase + DAS08JR_AO_LSB_REG(chan));\n\t\toutb(msb, dev->iobase + DAS08JR_AO_MSB_REG(chan));\n\t\t \n\t\tinb(dev->iobase + DAS08JR_AO_UPDATE_REG);\n\t} else {\n\t\toutb(lsb, dev->iobase + DAS08AOX_AO_LSB_REG(chan));\n\t\toutb(msb, dev->iobase + DAS08AOX_AO_MSB_REG(chan));\n\t\t \n\t\tinb(dev->iobase + DAS08AOX_AO_UPDATE_REG);\n\t}\n}\n\nstatic int das08_ao_insn_write(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       struct comedi_insn *insn,\n\t\t\t       unsigned int *data)\n{\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int val = s->readback[chan];\n\tint i;\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\tval = data[i];\n\t\tdas08_ao_set_data(dev, chan, val);\n\t}\n\ts->readback[chan] = val;\n\n\treturn insn->n;\n}\n\nint das08_common_attach(struct comedi_device *dev, unsigned long iobase)\n{\n\tconst struct das08_board_struct *board = dev->board_ptr;\n\tstruct das08_private_struct *devpriv = dev->private;\n\tstruct comedi_subdevice *s;\n\tint ret;\n\tint i;\n\n\tdev->iobase = iobase;\n\n\tdev->board_name = board->name;\n\n\tret = comedi_alloc_subdevices(dev, 6);\n\tif (ret)\n\t\treturn ret;\n\n\ts = &dev->subdevices[0];\n\t \n\tif (board->ai_nbits) {\n\t\ts->type = COMEDI_SUBD_AI;\n\t\t \n\t\ts->subdev_flags = SDF_READABLE | SDF_GROUND;\n\t\ts->n_chan = 8;\n\t\ts->maxdata = (1 << board->ai_nbits) - 1;\n\t\ts->range_table = das08_ai_lranges[board->ai_pg];\n\t\ts->insn_read = das08_ai_insn_read;\n\t\tdevpriv->pg_gainlist = das08_ai_gainlists[board->ai_pg];\n\t} else {\n\t\ts->type = COMEDI_SUBD_UNUSED;\n\t}\n\n\ts = &dev->subdevices[1];\n\t \n\tif (board->ao_nbits) {\n\t\ts->type = COMEDI_SUBD_AO;\n\t\ts->subdev_flags = SDF_WRITABLE;\n\t\ts->n_chan = 2;\n\t\ts->maxdata = (1 << board->ao_nbits) - 1;\n\t\ts->range_table = &range_bipolar5;\n\t\ts->insn_write = das08_ao_insn_write;\n\n\t\tret = comedi_alloc_subdev_readback(s);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tfor (i = 0; i < s->n_chan; i++) {\n\t\t\ts->readback[i] = s->maxdata / 2;\n\t\t\tdas08_ao_set_data(dev, i, s->readback[i]);\n\t\t}\n\t} else {\n\t\ts->type = COMEDI_SUBD_UNUSED;\n\t}\n\n\ts = &dev->subdevices[2];\n\t \n\tif (board->di_nchan) {\n\t\ts->type = COMEDI_SUBD_DI;\n\t\ts->subdev_flags = SDF_READABLE;\n\t\ts->n_chan = board->di_nchan;\n\t\ts->maxdata = 1;\n\t\ts->range_table = &range_digital;\n\t\ts->insn_bits = board->is_jr ? das08jr_di_insn_bits :\n\t\t\t       das08_di_insn_bits;\n\t} else {\n\t\ts->type = COMEDI_SUBD_UNUSED;\n\t}\n\n\ts = &dev->subdevices[3];\n\t \n\tif (board->do_nchan) {\n\t\ts->type = COMEDI_SUBD_DO;\n\t\ts->subdev_flags = SDF_WRITABLE;\n\t\ts->n_chan = board->do_nchan;\n\t\ts->maxdata = 1;\n\t\ts->range_table = &range_digital;\n\t\ts->insn_bits = board->is_jr ? das08jr_do_insn_bits :\n\t\t\t       das08_do_insn_bits;\n\t} else {\n\t\ts->type = COMEDI_SUBD_UNUSED;\n\t}\n\n\ts = &dev->subdevices[4];\n\t \n\tif (board->i8255_offset != 0) {\n\t\tret = subdev_8255_init(dev, s, NULL, board->i8255_offset);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\ts->type = COMEDI_SUBD_UNUSED;\n\t}\n\n\t \n\ts = &dev->subdevices[5];\n\tif (board->i8254_offset) {\n\t\tdev->pacer = comedi_8254_init(dev->iobase + board->i8254_offset,\n\t\t\t\t\t      0, I8254_IO8, 0);\n\t\tif (!dev->pacer)\n\t\t\treturn -ENOMEM;\n\n\t\tcomedi_8254_subdevice_init(s, dev->pacer);\n\t} else {\n\t\ts->type = COMEDI_SUBD_UNUSED;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(das08_common_attach);\n\nstatic int __init das08_init(void)\n{\n\treturn 0;\n}\nmodule_init(das08_init);\n\nstatic void __exit das08_exit(void)\n{\n}\nmodule_exit(das08_exit);\n\nMODULE_AUTHOR(\"Comedi https://www.comedi.org\");\nMODULE_DESCRIPTION(\"Comedi common DAS08 support module\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}