{
  "module_name": "addi_apci_3501.c",
  "hash_id": "d05811120eca49c6371ba44b2bf95f0359332d798956b62e5a92f8207f4b7c02",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/addi_apci_3501.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/comedi/comedi_pci.h>\n\n#include \"amcc_s5933.h\"\n\n \n#define APCI3501_AO_CTRL_STATUS_REG\t\t0x00\n#define APCI3501_AO_CTRL_BIPOLAR\t\tBIT(0)\n#define APCI3501_AO_STATUS_READY\t\tBIT(8)\n#define APCI3501_AO_DATA_REG\t\t\t0x04\n#define APCI3501_AO_DATA_CHAN(x)\t\t((x) << 0)\n#define APCI3501_AO_DATA_VAL(x)\t\t\t((x) << 8)\n#define APCI3501_AO_DATA_BIPOLAR\t\tBIT(31)\n#define APCI3501_AO_TRIG_SCS_REG\t\t0x08\n#define APCI3501_TIMER_BASE\t\t\t0x20\n#define APCI3501_DO_REG\t\t\t\t0x40\n#define APCI3501_DI_REG\t\t\t\t0x50\n\n \n#define NVRAM_USER_DATA_START\t0x100\n\n#define NVCMD_BEGIN_READ\t(0x7 << 5)\n#define NVCMD_LOAD_LOW\t\t(0x4 << 5)\n#define NVCMD_LOAD_HIGH\t\t(0x5 << 5)\n\n \n#define EEPROM_DIGITALINPUT\t\t0\n#define EEPROM_DIGITALOUTPUT\t\t1\n#define EEPROM_ANALOGINPUT\t\t2\n#define EEPROM_ANALOGOUTPUT\t\t3\n#define EEPROM_TIMER\t\t\t4\n#define EEPROM_WATCHDOG\t\t\t5\n#define EEPROM_TIMER_WATCHDOG_COUNTER\t10\n\nstruct apci3501_private {\n\tunsigned long amcc;\n\tunsigned char timer_mode;\n};\n\nstatic const struct comedi_lrange apci3501_ao_range = {\n\t2, {\n\t\tBIP_RANGE(10),\n\t\tUNI_RANGE(10)\n\t}\n};\n\nstatic int apci3501_wait_for_dac(struct comedi_device *dev)\n{\n\tunsigned int status;\n\n\tdo {\n\t\tstatus = inl(dev->iobase + APCI3501_AO_CTRL_STATUS_REG);\n\t} while (!(status & APCI3501_AO_STATUS_READY));\n\n\treturn 0;\n}\n\nstatic int apci3501_ao_insn_write(struct comedi_device *dev,\n\t\t\t\t  struct comedi_subdevice *s,\n\t\t\t\t  struct comedi_insn *insn,\n\t\t\t\t  unsigned int *data)\n{\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int range = CR_RANGE(insn->chanspec);\n\tunsigned int cfg = APCI3501_AO_DATA_CHAN(chan);\n\tint ret;\n\tint i;\n\n\t \n\tif (range) {\n\t\toutl(0, dev->iobase + APCI3501_AO_CTRL_STATUS_REG);\n\t} else {\n\t\tcfg |= APCI3501_AO_DATA_BIPOLAR;\n\t\toutl(APCI3501_AO_CTRL_BIPOLAR,\n\t\t     dev->iobase + APCI3501_AO_CTRL_STATUS_REG);\n\t}\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\tunsigned int val = data[i];\n\n\t\tif (range == 1) {\n\t\t\tif (data[i] > 0x1fff) {\n\t\t\t\tdev_err(dev->class_dev,\n\t\t\t\t\t\"Unipolar resolution is only 13-bits\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tret = apci3501_wait_for_dac(dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\toutl(cfg | APCI3501_AO_DATA_VAL(val),\n\t\t     dev->iobase + APCI3501_AO_DATA_REG);\n\n\t\ts->readback[chan] = val;\n\t}\n\n\treturn insn->n;\n}\n\nstatic int apci3501_di_insn_bits(struct comedi_device *dev,\n\t\t\t\t struct comedi_subdevice *s,\n\t\t\t\t struct comedi_insn *insn,\n\t\t\t\t unsigned int *data)\n{\n\tdata[1] = inl(dev->iobase + APCI3501_DI_REG) & 0x3;\n\n\treturn insn->n;\n}\n\nstatic int apci3501_do_insn_bits(struct comedi_device *dev,\n\t\t\t\t struct comedi_subdevice *s,\n\t\t\t\t struct comedi_insn *insn,\n\t\t\t\t unsigned int *data)\n{\n\ts->state = inl(dev->iobase + APCI3501_DO_REG);\n\n\tif (comedi_dio_update_state(s, data))\n\t\toutl(s->state, dev->iobase + APCI3501_DO_REG);\n\n\tdata[1] = s->state;\n\n\treturn insn->n;\n}\n\nstatic void apci3501_eeprom_wait(unsigned long iobase)\n{\n\tunsigned char val;\n\n\tdo {\n\t\tval = inb(iobase + AMCC_OP_REG_MCSR_NVCMD);\n\t} while (val & 0x80);\n}\n\nstatic unsigned short apci3501_eeprom_readw(unsigned long iobase,\n\t\t\t\t\t    unsigned short addr)\n{\n\tunsigned short val = 0;\n\tunsigned char tmp;\n\tunsigned char i;\n\n\t \n\taddr += NVRAM_USER_DATA_START;\n\n\tfor (i = 0; i < 2; i++) {\n\t\t \n\t\toutb(NVCMD_LOAD_LOW, iobase + AMCC_OP_REG_MCSR_NVCMD);\n\t\tapci3501_eeprom_wait(iobase);\n\t\toutb((addr + i) & 0xff, iobase + AMCC_OP_REG_MCSR_NVDATA);\n\t\tapci3501_eeprom_wait(iobase);\n\n\t\t \n\t\toutb(NVCMD_LOAD_HIGH, iobase + AMCC_OP_REG_MCSR_NVCMD);\n\t\tapci3501_eeprom_wait(iobase);\n\t\toutb(((addr + i) >> 8) & 0xff,\n\t\t     iobase + AMCC_OP_REG_MCSR_NVDATA);\n\t\tapci3501_eeprom_wait(iobase);\n\n\t\t \n\t\toutb(NVCMD_BEGIN_READ, iobase + AMCC_OP_REG_MCSR_NVCMD);\n\t\tapci3501_eeprom_wait(iobase);\n\t\ttmp = inb(iobase + AMCC_OP_REG_MCSR_NVDATA);\n\t\tapci3501_eeprom_wait(iobase);\n\n\t\tif (i == 0)\n\t\t\tval |= tmp;\n\t\telse\n\t\t\tval |= (tmp << 8);\n\t}\n\n\treturn val;\n}\n\nstatic int apci3501_eeprom_get_ao_n_chan(struct comedi_device *dev)\n{\n\tstruct apci3501_private *devpriv = dev->private;\n\tunsigned char nfuncs;\n\tint i;\n\n\tnfuncs = apci3501_eeprom_readw(devpriv->amcc, 10) & 0xff;\n\n\t \n\tfor (i = 0; i < nfuncs; i++) {\n\t\tunsigned short offset = i * 4;\n\t\tunsigned short addr;\n\t\tunsigned char func;\n\t\tunsigned short val;\n\n\t\tfunc = apci3501_eeprom_readw(devpriv->amcc, 12 + offset) & 0x3f;\n\t\taddr = apci3501_eeprom_readw(devpriv->amcc, 14 + offset);\n\n\t\tif (func == EEPROM_ANALOGOUTPUT) {\n\t\t\tval = apci3501_eeprom_readw(devpriv->amcc, addr + 10);\n\t\t\treturn (val >> 4) & 0x3ff;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int apci3501_eeprom_insn_read(struct comedi_device *dev,\n\t\t\t\t     struct comedi_subdevice *s,\n\t\t\t\t     struct comedi_insn *insn,\n\t\t\t\t     unsigned int *data)\n{\n\tstruct apci3501_private *devpriv = dev->private;\n\tunsigned short addr = CR_CHAN(insn->chanspec);\n\tunsigned int val;\n\tunsigned int i;\n\n\tif (insn->n) {\n\t\t \n\t\tval = apci3501_eeprom_readw(devpriv->amcc, 2 * addr);\n\t\tfor (i = 0; i < insn->n; i++)\n\t\t\tdata[i] = val;\n\t}\n\n\treturn insn->n;\n}\n\nstatic int apci3501_reset(struct comedi_device *dev)\n{\n\tunsigned int val;\n\tint chan;\n\tint ret;\n\n\t \n\toutl(0x0, dev->iobase + APCI3501_DO_REG);\n\n\t \n\toutl(APCI3501_AO_CTRL_BIPOLAR,\n\t     dev->iobase + APCI3501_AO_CTRL_STATUS_REG);\n\tval = APCI3501_AO_DATA_BIPOLAR | APCI3501_AO_DATA_VAL(0);\n\n\t \n\tfor (chan = 0; chan < 8; chan++) {\n\t\tret = apci3501_wait_for_dac(dev);\n\t\tif (ret) {\n\t\t\tdev_warn(dev->class_dev,\n\t\t\t\t \"%s: DAC not-ready for channel %i\\n\",\n\t\t\t\t __func__, chan);\n\t\t} else {\n\t\t\toutl(val | APCI3501_AO_DATA_CHAN(chan),\n\t\t\t     dev->iobase + APCI3501_AO_DATA_REG);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int apci3501_auto_attach(struct comedi_device *dev,\n\t\t\t\tunsigned long context_unused)\n{\n\tstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\n\tstruct apci3501_private *devpriv;\n\tstruct comedi_subdevice *s;\n\tint ao_n_chan;\n\tint ret;\n\n\tdevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\n\tif (!devpriv)\n\t\treturn -ENOMEM;\n\n\tret = comedi_pci_enable(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tdevpriv->amcc = pci_resource_start(pcidev, 0);\n\tdev->iobase = pci_resource_start(pcidev, 1);\n\n\tao_n_chan = apci3501_eeprom_get_ao_n_chan(dev);\n\n\tret = comedi_alloc_subdevices(dev, 5);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ts = &dev->subdevices[0];\n\tif (ao_n_chan) {\n\t\ts->type\t\t= COMEDI_SUBD_AO;\n\t\ts->subdev_flags\t= SDF_WRITABLE | SDF_GROUND | SDF_COMMON;\n\t\ts->n_chan\t= ao_n_chan;\n\t\ts->maxdata\t= 0x3fff;\n\t\ts->range_table\t= &apci3501_ao_range;\n\t\ts->insn_write\t= apci3501_ao_insn_write;\n\n\t\tret = comedi_alloc_subdev_readback(s);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\ts->type\t\t= COMEDI_SUBD_UNUSED;\n\t}\n\n\t \n\ts = &dev->subdevices[1];\n\ts->type\t\t= COMEDI_SUBD_DI;\n\ts->subdev_flags\t= SDF_READABLE;\n\ts->n_chan\t= 2;\n\ts->maxdata\t= 1;\n\ts->range_table\t= &range_digital;\n\ts->insn_bits\t= apci3501_di_insn_bits;\n\n\t \n\ts = &dev->subdevices[2];\n\ts->type\t\t= COMEDI_SUBD_DO;\n\ts->subdev_flags\t= SDF_WRITABLE;\n\ts->n_chan\t= 2;\n\ts->maxdata\t= 1;\n\ts->range_table\t= &range_digital;\n\ts->insn_bits\t= apci3501_do_insn_bits;\n\n\t \n\ts = &dev->subdevices[3];\n\ts->type\t\t= COMEDI_SUBD_UNUSED;\n\n\t \n\ts = &dev->subdevices[4];\n\ts->type\t\t= COMEDI_SUBD_MEMORY;\n\ts->subdev_flags\t= SDF_READABLE | SDF_INTERNAL;\n\ts->n_chan\t= 256;\n\ts->maxdata\t= 0xffff;\n\ts->insn_read\t= apci3501_eeprom_insn_read;\n\n\tapci3501_reset(dev);\n\treturn 0;\n}\n\nstatic void apci3501_detach(struct comedi_device *dev)\n{\n\tif (dev->iobase)\n\t\tapci3501_reset(dev);\n\tcomedi_pci_detach(dev);\n}\n\nstatic struct comedi_driver apci3501_driver = {\n\t.driver_name\t= \"addi_apci_3501\",\n\t.module\t\t= THIS_MODULE,\n\t.auto_attach\t= apci3501_auto_attach,\n\t.detach\t\t= apci3501_detach,\n};\n\nstatic int apci3501_pci_probe(struct pci_dev *dev,\n\t\t\t      const struct pci_device_id *id)\n{\n\treturn comedi_pci_auto_config(dev, &apci3501_driver, id->driver_data);\n}\n\nstatic const struct pci_device_id apci3501_pci_table[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_ADDIDATA, 0x3001) },\n\t{ 0 }\n};\nMODULE_DEVICE_TABLE(pci, apci3501_pci_table);\n\nstatic struct pci_driver apci3501_pci_driver = {\n\t.name\t\t= \"addi_apci_3501\",\n\t.id_table\t= apci3501_pci_table,\n\t.probe\t\t= apci3501_pci_probe,\n\t.remove\t\t= comedi_pci_auto_unconfig,\n};\nmodule_comedi_pci_driver(apci3501_driver, apci3501_pci_driver);\n\nMODULE_DESCRIPTION(\"ADDI-DATA APCI-3501 Analog output board\");\nMODULE_AUTHOR(\"Comedi https://www.comedi.org\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}