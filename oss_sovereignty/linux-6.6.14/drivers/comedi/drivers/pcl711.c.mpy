{
  "module_name": "pcl711.c",
  "hash_id": "292ec8a3a6daa86596b1fe17f84f41e9ff5475e05782247aa09ef9ce0f0e44da",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/pcl711.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/comedi/comedidev.h>\n#include <linux/comedi/comedi_8254.h>\n\n \n#define PCL711_TIMER_BASE\t0x00\n#define PCL711_AI_LSB_REG\t0x04\n#define PCL711_AI_MSB_REG\t0x05\n#define PCL711_AI_MSB_DRDY\tBIT(4)\n#define PCL711_AO_LSB_REG(x)\t(0x04 + ((x) * 2))\n#define PCL711_AO_MSB_REG(x)\t(0x05 + ((x) * 2))\n#define PCL711_DI_LSB_REG\t0x06\n#define PCL711_DI_MSB_REG\t0x07\n#define PCL711_INT_STAT_REG\t0x08\n#define PCL711_INT_STAT_CLR\t(0 << 0)   \n#define PCL711_AI_GAIN_REG\t0x09\n#define PCL711_AI_GAIN(x)\t(((x) & 0xf) << 0)\n#define PCL711_MUX_REG\t\t0x0a\n#define PCL711_MUX_CHAN(x)\t(((x) & 0xf) << 0)\n#define PCL711_MUX_CS0\t\tBIT(4)\n#define PCL711_MUX_CS1\t\tBIT(5)\n#define PCL711_MUX_DIFF\t\t(PCL711_MUX_CS0 | PCL711_MUX_CS1)\n#define PCL711_MODE_REG\t\t0x0b\n#define PCL711_MODE(x)\t\t(((x) & 0x7) << 0)\n#define PCL711_MODE_DEFAULT\tPCL711_MODE(0)\n#define PCL711_MODE_SOFTTRIG\tPCL711_MODE(1)\n#define PCL711_MODE_EXT\t\tPCL711_MODE(2)\n#define PCL711_MODE_EXT_IRQ\tPCL711_MODE(3)\n#define PCL711_MODE_PACER\tPCL711_MODE(4)\n#define PCL711_MODE_PACER_IRQ\tPCL711_MODE(6)\n#define PCL711_MODE_IRQ(x)\t(((x) & 0x7) << 4)\n#define PCL711_SOFTTRIG_REG\t0x0c\n#define PCL711_SOFTTRIG\t\t(0 << 0)   \n#define PCL711_DO_LSB_REG\t0x0d\n#define PCL711_DO_MSB_REG\t0x0e\n\nstatic const struct comedi_lrange range_pcl711b_ai = {\n\t5, {\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(2.5),\n\t\tBIP_RANGE(1.25),\n\t\tBIP_RANGE(0.625),\n\t\tBIP_RANGE(0.3125)\n\t}\n};\n\nstatic const struct comedi_lrange range_acl8112hg_ai = {\n\t12, {\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(0.5),\n\t\tBIP_RANGE(0.05),\n\t\tBIP_RANGE(0.005),\n\t\tUNI_RANGE(10),\n\t\tUNI_RANGE(1),\n\t\tUNI_RANGE(0.1),\n\t\tUNI_RANGE(0.01),\n\t\tBIP_RANGE(10),\n\t\tBIP_RANGE(1),\n\t\tBIP_RANGE(0.1),\n\t\tBIP_RANGE(0.01)\n\t}\n};\n\nstatic const struct comedi_lrange range_acl8112dg_ai = {\n\t9, {\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(2.5),\n\t\tBIP_RANGE(1.25),\n\t\tBIP_RANGE(0.625),\n\t\tUNI_RANGE(10),\n\t\tUNI_RANGE(5),\n\t\tUNI_RANGE(2.5),\n\t\tUNI_RANGE(1.25),\n\t\tBIP_RANGE(10)\n\t}\n};\n\nstruct pcl711_board {\n\tconst char *name;\n\tint n_aichan;\n\tint n_aochan;\n\tint maxirq;\n\tconst struct comedi_lrange *ai_range_type;\n};\n\nstatic const struct pcl711_board boardtypes[] = {\n\t{\n\t\t.name\t\t= \"pcl711\",\n\t\t.n_aichan\t= 8,\n\t\t.n_aochan\t= 1,\n\t\t.ai_range_type\t= &range_bipolar5,\n\t}, {\n\t\t.name\t\t= \"pcl711b\",\n\t\t.n_aichan\t= 8,\n\t\t.n_aochan\t= 1,\n\t\t.maxirq\t\t= 7,\n\t\t.ai_range_type\t= &range_pcl711b_ai,\n\t}, {\n\t\t.name\t\t= \"acl8112hg\",\n\t\t.n_aichan\t= 16,\n\t\t.n_aochan\t= 2,\n\t\t.maxirq\t\t= 15,\n\t\t.ai_range_type\t= &range_acl8112hg_ai,\n\t}, {\n\t\t.name\t\t= \"acl8112dg\",\n\t\t.n_aichan\t= 16,\n\t\t.n_aochan\t= 2,\n\t\t.maxirq\t\t= 15,\n\t\t.ai_range_type\t= &range_acl8112dg_ai,\n\t},\n};\n\nstatic void pcl711_ai_set_mode(struct comedi_device *dev, unsigned int mode)\n{\n\t \n\tif (mode == PCL711_MODE_EXT_IRQ || mode == PCL711_MODE_PACER_IRQ)\n\t\tmode |= PCL711_MODE_IRQ(dev->irq);\n\n\toutb(mode, dev->iobase + PCL711_MODE_REG);\n}\n\nstatic unsigned int pcl711_ai_get_sample(struct comedi_device *dev,\n\t\t\t\t\t struct comedi_subdevice *s)\n{\n\tunsigned int val;\n\n\tval = inb(dev->iobase + PCL711_AI_MSB_REG) << 8;\n\tval |= inb(dev->iobase + PCL711_AI_LSB_REG);\n\n\treturn val & s->maxdata;\n}\n\nstatic int pcl711_ai_cancel(struct comedi_device *dev,\n\t\t\t    struct comedi_subdevice *s)\n{\n\toutb(PCL711_INT_STAT_CLR, dev->iobase + PCL711_INT_STAT_REG);\n\tpcl711_ai_set_mode(dev, PCL711_MODE_SOFTTRIG);\n\treturn 0;\n}\n\nstatic irqreturn_t pcl711_interrupt(int irq, void *d)\n{\n\tstruct comedi_device *dev = d;\n\tstruct comedi_subdevice *s = dev->read_subdev;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tunsigned short data;\n\n\tif (!dev->attached) {\n\t\tdev_err(dev->class_dev, \"spurious interrupt\\n\");\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tdata = pcl711_ai_get_sample(dev, s);\n\n\toutb(PCL711_INT_STAT_CLR, dev->iobase + PCL711_INT_STAT_REG);\n\n\tcomedi_buf_write_samples(s, &data, 1);\n\n\tif (cmd->stop_src == TRIG_COUNT &&\n\t    s->async->scans_done >= cmd->stop_arg)\n\t\ts->async->events |= COMEDI_CB_EOA;\n\n\tcomedi_handle_events(dev, s);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void pcl711_set_changain(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tunsigned int chanspec)\n{\n\tunsigned int chan = CR_CHAN(chanspec);\n\tunsigned int range = CR_RANGE(chanspec);\n\tunsigned int aref = CR_AREF(chanspec);\n\tunsigned int mux = 0;\n\n\toutb(PCL711_AI_GAIN(range), dev->iobase + PCL711_AI_GAIN_REG);\n\n\tif (s->n_chan > 8) {\n\t\t \n\t\tif (aref == AREF_DIFF) {\n\t\t\tchan &= 0x7;\n\t\t\tmux |= PCL711_MUX_DIFF;\n\t\t} else {\n\t\t\tif (chan < 8)\n\t\t\t\tmux |= PCL711_MUX_CS0;\n\t\t\telse\n\t\t\t\tmux |= PCL711_MUX_CS1;\n\t\t}\n\t}\n\toutb(mux | PCL711_MUX_CHAN(chan), dev->iobase + PCL711_MUX_REG);\n}\n\nstatic int pcl711_ai_eoc(struct comedi_device *dev,\n\t\t\t struct comedi_subdevice *s,\n\t\t\t struct comedi_insn *insn,\n\t\t\t unsigned long context)\n{\n\tunsigned int status;\n\n\tstatus = inb(dev->iobase + PCL711_AI_MSB_REG);\n\tif ((status & PCL711_AI_MSB_DRDY) == 0)\n\t\treturn 0;\n\treturn -EBUSY;\n}\n\nstatic int pcl711_ai_insn_read(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       struct comedi_insn *insn,\n\t\t\t       unsigned int *data)\n{\n\tint ret;\n\tint i;\n\n\tpcl711_set_changain(dev, s, insn->chanspec);\n\n\tpcl711_ai_set_mode(dev, PCL711_MODE_SOFTTRIG);\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\toutb(PCL711_SOFTTRIG, dev->iobase + PCL711_SOFTTRIG_REG);\n\n\t\tret = comedi_timeout(dev, s, insn, pcl711_ai_eoc, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdata[i] = pcl711_ai_get_sample(dev, s);\n\t}\n\n\treturn insn->n;\n}\n\nstatic int pcl711_ai_cmdtest(struct comedi_device *dev,\n\t\t\t     struct comedi_subdevice *s, struct comedi_cmd *cmd)\n{\n\tint err = 0;\n\n\t \n\n\terr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW);\n\terr |= comedi_check_trigger_src(&cmd->scan_begin_src,\n\t\t\t\t\tTRIG_TIMER | TRIG_EXT);\n\terr |= comedi_check_trigger_src(&cmd->convert_src, TRIG_NOW);\n\terr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\n\terr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\n\n\tif (err)\n\t\treturn 1;\n\n\t \n\n\terr |= comedi_check_trigger_is_unique(cmd->scan_begin_src);\n\terr |= comedi_check_trigger_is_unique(cmd->stop_src);\n\n\t \n\n\tif (err)\n\t\treturn 2;\n\n\t \n\n\terr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\n\n\tif (cmd->scan_begin_src == TRIG_EXT) {\n\t\terr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);\n\t} else {\n#define MAX_SPEED 1000\n\t\terr |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,\n\t\t\t\t\t\t    MAX_SPEED);\n\t}\n\n\terr |= comedi_check_trigger_arg_is(&cmd->convert_arg, 0);\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\n\t\t\t\t\t   cmd->chanlist_len);\n\n\tif (cmd->stop_src == TRIG_COUNT)\n\t\terr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\n\telse\t \n\t\terr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\n\n\tif (err)\n\t\treturn 3;\n\n\t \n\n\tif (cmd->scan_begin_src == TRIG_TIMER) {\n\t\tunsigned int arg = cmd->scan_begin_arg;\n\n\t\tcomedi_8254_cascade_ns_to_timer(dev->pacer, &arg, cmd->flags);\n\t\terr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, arg);\n\t}\n\n\tif (err)\n\t\treturn 4;\n\n\treturn 0;\n}\n\nstatic int pcl711_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\n{\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\n\tpcl711_set_changain(dev, s, cmd->chanlist[0]);\n\n\tif (cmd->scan_begin_src == TRIG_TIMER) {\n\t\tcomedi_8254_update_divisors(dev->pacer);\n\t\tcomedi_8254_pacer_enable(dev->pacer, 1, 2, true);\n\t\toutb(PCL711_INT_STAT_CLR, dev->iobase + PCL711_INT_STAT_REG);\n\t\tpcl711_ai_set_mode(dev, PCL711_MODE_PACER_IRQ);\n\t} else {\n\t\tpcl711_ai_set_mode(dev, PCL711_MODE_EXT_IRQ);\n\t}\n\n\treturn 0;\n}\n\nstatic void pcl711_ao_write(struct comedi_device *dev,\n\t\t\t    unsigned int chan, unsigned int val)\n{\n\toutb(val & 0xff, dev->iobase + PCL711_AO_LSB_REG(chan));\n\toutb((val >> 8) & 0xff, dev->iobase + PCL711_AO_MSB_REG(chan));\n}\n\nstatic int pcl711_ao_insn_write(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tstruct comedi_insn *insn,\n\t\t\t\tunsigned int *data)\n{\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int val = s->readback[chan];\n\tint i;\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\tval = data[i];\n\t\tpcl711_ao_write(dev, chan, val);\n\t}\n\ts->readback[chan] = val;\n\n\treturn insn->n;\n}\n\nstatic int pcl711_di_insn_bits(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       struct comedi_insn *insn,\n\t\t\t       unsigned int *data)\n{\n\tunsigned int val;\n\n\tval = inb(dev->iobase + PCL711_DI_LSB_REG);\n\tval |= (inb(dev->iobase + PCL711_DI_MSB_REG) << 8);\n\n\tdata[1] = val;\n\n\treturn insn->n;\n}\n\nstatic int pcl711_do_insn_bits(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       struct comedi_insn *insn,\n\t\t\t       unsigned int *data)\n{\n\tunsigned int mask;\n\n\tmask = comedi_dio_update_state(s, data);\n\tif (mask) {\n\t\tif (mask & 0x00ff)\n\t\t\toutb(s->state & 0xff, dev->iobase + PCL711_DO_LSB_REG);\n\t\tif (mask & 0xff00)\n\t\t\toutb((s->state >> 8), dev->iobase + PCL711_DO_MSB_REG);\n\t}\n\n\tdata[1] = s->state;\n\n\treturn insn->n;\n}\n\nstatic int pcl711_attach(struct comedi_device *dev, struct comedi_devconfig *it)\n{\n\tconst struct pcl711_board *board = dev->board_ptr;\n\tstruct comedi_subdevice *s;\n\tint ret;\n\n\tret = comedi_request_region(dev, it->options[0], 0x10);\n\tif (ret)\n\t\treturn ret;\n\n\tif (it->options[1] && it->options[1] <= board->maxirq) {\n\t\tret = request_irq(it->options[1], pcl711_interrupt, 0,\n\t\t\t\t  dev->board_name, dev);\n\t\tif (ret == 0)\n\t\t\tdev->irq = it->options[1];\n\t}\n\n\tdev->pacer = comedi_8254_init(dev->iobase + PCL711_TIMER_BASE,\n\t\t\t\t      I8254_OSC_BASE_2MHZ, I8254_IO8, 0);\n\tif (!dev->pacer)\n\t\treturn -ENOMEM;\n\n\tret = comedi_alloc_subdevices(dev, 4);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ts = &dev->subdevices[0];\n\ts->type\t\t= COMEDI_SUBD_AI;\n\ts->subdev_flags\t= SDF_READABLE | SDF_GROUND;\n\tif (board->n_aichan > 8)\n\t\ts->subdev_flags\t|= SDF_DIFF;\n\ts->n_chan\t= board->n_aichan;\n\ts->maxdata\t= 0xfff;\n\ts->range_table\t= board->ai_range_type;\n\ts->insn_read\t= pcl711_ai_insn_read;\n\tif (dev->irq) {\n\t\tdev->read_subdev = s;\n\t\ts->subdev_flags\t|= SDF_CMD_READ;\n\t\ts->len_chanlist\t= 1;\n\t\ts->do_cmdtest\t= pcl711_ai_cmdtest;\n\t\ts->do_cmd\t= pcl711_ai_cmd;\n\t\ts->cancel\t= pcl711_ai_cancel;\n\t}\n\n\t \n\ts = &dev->subdevices[1];\n\ts->type\t\t= COMEDI_SUBD_AO;\n\ts->subdev_flags\t= SDF_WRITABLE;\n\ts->n_chan\t= board->n_aochan;\n\ts->maxdata\t= 0xfff;\n\ts->range_table\t= &range_bipolar5;\n\ts->insn_write\t= pcl711_ao_insn_write;\n\n\tret = comedi_alloc_subdev_readback(s);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ts = &dev->subdevices[2];\n\ts->type\t\t= COMEDI_SUBD_DI;\n\ts->subdev_flags\t= SDF_READABLE;\n\ts->n_chan\t= 16;\n\ts->maxdata\t= 1;\n\ts->range_table\t= &range_digital;\n\ts->insn_bits\t= pcl711_di_insn_bits;\n\n\t \n\ts = &dev->subdevices[3];\n\ts->type\t\t= COMEDI_SUBD_DO;\n\ts->subdev_flags\t= SDF_WRITABLE;\n\ts->n_chan\t= 16;\n\ts->maxdata\t= 1;\n\ts->range_table\t= &range_digital;\n\ts->insn_bits\t= pcl711_do_insn_bits;\n\n\t \n\tpcl711_ao_write(dev, 0, 0x0);\n\tpcl711_ao_write(dev, 1, 0x0);\n\n\treturn 0;\n}\n\nstatic struct comedi_driver pcl711_driver = {\n\t.driver_name\t= \"pcl711\",\n\t.module\t\t= THIS_MODULE,\n\t.attach\t\t= pcl711_attach,\n\t.detach\t\t= comedi_legacy_detach,\n\t.board_name\t= &boardtypes[0].name,\n\t.num_names\t= ARRAY_SIZE(boardtypes),\n\t.offset\t\t= sizeof(struct pcl711_board),\n};\nmodule_comedi_driver(pcl711_driver);\n\nMODULE_AUTHOR(\"Comedi https://www.comedi.org\");\nMODULE_DESCRIPTION(\"Comedi driver for PCL-711 compatible boards\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}