{
  "module_name": "vmk80xx.c",
  "hash_id": "5be0c7168d426ed1371d1bf1d6128a09dd32df47153ca1b230fb3ea698efe204",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/vmk80xx.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/errno.h>\n#include <linux/input.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/uaccess.h>\n#include <linux/comedi/comedi_usb.h>\n\nenum {\n\tDEVICE_VMK8055,\n\tDEVICE_VMK8061\n};\n\n#define VMK8055_DI_REG\t\t0x00\n#define VMK8055_DO_REG\t\t0x01\n#define VMK8055_AO1_REG\t\t0x02\n#define VMK8055_AO2_REG\t\t0x03\n#define VMK8055_AI1_REG\t\t0x02\n#define VMK8055_AI2_REG\t\t0x03\n#define VMK8055_CNT1_REG\t0x04\n#define VMK8055_CNT2_REG\t0x06\n\n#define VMK8061_CH_REG\t\t0x01\n#define VMK8061_DI_REG\t\t0x01\n#define VMK8061_DO_REG\t\t0x01\n#define VMK8061_PWM_REG1\t0x01\n#define VMK8061_PWM_REG2\t0x02\n#define VMK8061_CNT_REG\t\t0x02\n#define VMK8061_AO_REG\t\t0x02\n#define VMK8061_AI_REG1\t\t0x02\n#define VMK8061_AI_REG2\t\t0x03\n\n#define VMK8055_CMD_RST\t\t0x00\n#define VMK8055_CMD_DEB1_TIME\t0x01\n#define VMK8055_CMD_DEB2_TIME\t0x02\n#define VMK8055_CMD_RST_CNT1\t0x03\n#define VMK8055_CMD_RST_CNT2\t0x04\n#define VMK8055_CMD_WRT_AD\t0x05\n\n#define VMK8061_CMD_RD_AI\t0x00\n#define VMK8061_CMR_RD_ALL_AI\t0x01\t \n#define VMK8061_CMD_SET_AO\t0x02\n#define VMK8061_CMD_SET_ALL_AO\t0x03\t \n#define VMK8061_CMD_OUT_PWM\t0x04\n#define VMK8061_CMD_RD_DI\t0x05\n#define VMK8061_CMD_DO\t\t0x06\t \n#define VMK8061_CMD_CLR_DO\t0x07\n#define VMK8061_CMD_SET_DO\t0x08\n#define VMK8061_CMD_RD_CNT\t0x09\t \n#define VMK8061_CMD_RST_CNT\t0x0a\t \n#define VMK8061_CMD_RD_VERSION\t0x0b\t \n#define VMK8061_CMD_RD_JMP_STAT\t0x0c\t \n#define VMK8061_CMD_RD_PWR_STAT\t0x0d\t \n#define VMK8061_CMD_RD_DO\t0x0e\n#define VMK8061_CMD_RD_AO\t0x0f\n#define VMK8061_CMD_RD_PWM\t0x10\n\n#define IC3_VERSION\t\tBIT(0)\n#define IC6_VERSION\t\tBIT(1)\n\n#define MIN_BUF_SIZE\t\t64\n#define PACKET_TIMEOUT\t\t10000\t \n\nenum vmk80xx_model {\n\tVMK8055_MODEL,\n\tVMK8061_MODEL\n};\n\nstatic const struct comedi_lrange vmk8061_range = {\n\t2, {\n\t\tUNI_RANGE(5),\n\t\tUNI_RANGE(10)\n\t}\n};\n\nstruct vmk80xx_board {\n\tconst char *name;\n\tenum vmk80xx_model model;\n\tconst struct comedi_lrange *range;\n\tint ai_nchans;\n\tunsigned int ai_maxdata;\n\tint ao_nchans;\n\tint di_nchans;\n\tunsigned int cnt_maxdata;\n\tint pwm_nchans;\n\tunsigned int pwm_maxdata;\n};\n\nstatic const struct vmk80xx_board vmk80xx_boardinfo[] = {\n\t[DEVICE_VMK8055] = {\n\t\t.name\t\t= \"K8055 (VM110)\",\n\t\t.model\t\t= VMK8055_MODEL,\n\t\t.range\t\t= &range_unipolar5,\n\t\t.ai_nchans\t= 2,\n\t\t.ai_maxdata\t= 0x00ff,\n\t\t.ao_nchans\t= 2,\n\t\t.di_nchans\t= 6,\n\t\t.cnt_maxdata\t= 0xffff,\n\t},\n\t[DEVICE_VMK8061] = {\n\t\t.name\t\t= \"K8061 (VM140)\",\n\t\t.model\t\t= VMK8061_MODEL,\n\t\t.range\t\t= &vmk8061_range,\n\t\t.ai_nchans\t= 8,\n\t\t.ai_maxdata\t= 0x03ff,\n\t\t.ao_nchans\t= 8,\n\t\t.di_nchans\t= 8,\n\t\t.cnt_maxdata\t= 0,\t \n\t\t.pwm_nchans\t= 1,\n\t\t.pwm_maxdata\t= 0x03ff,\n\t},\n};\n\nstruct vmk80xx_private {\n\tstruct usb_endpoint_descriptor *ep_rx;\n\tstruct usb_endpoint_descriptor *ep_tx;\n\tstruct semaphore limit_sem;\n\tunsigned char *usb_rx_buf;\n\tunsigned char *usb_tx_buf;\n\tenum vmk80xx_model model;\n};\n\nstatic void vmk80xx_do_bulk_msg(struct comedi_device *dev)\n{\n\tstruct vmk80xx_private *devpriv = dev->private;\n\tstruct usb_device *usb = comedi_to_usb_dev(dev);\n\t__u8 tx_addr;\n\t__u8 rx_addr;\n\tunsigned int tx_pipe;\n\tunsigned int rx_pipe;\n\tsize_t tx_size;\n\tsize_t rx_size;\n\n\ttx_addr = devpriv->ep_tx->bEndpointAddress;\n\trx_addr = devpriv->ep_rx->bEndpointAddress;\n\ttx_pipe = usb_sndbulkpipe(usb, tx_addr);\n\trx_pipe = usb_rcvbulkpipe(usb, rx_addr);\n\ttx_size = usb_endpoint_maxp(devpriv->ep_tx);\n\trx_size = usb_endpoint_maxp(devpriv->ep_rx);\n\n\tusb_bulk_msg(usb, tx_pipe, devpriv->usb_tx_buf, tx_size, NULL,\n\t\t     PACKET_TIMEOUT);\n\n\tusb_bulk_msg(usb, rx_pipe, devpriv->usb_rx_buf, rx_size, NULL,\n\t\t     PACKET_TIMEOUT);\n}\n\nstatic int vmk80xx_read_packet(struct comedi_device *dev)\n{\n\tstruct vmk80xx_private *devpriv = dev->private;\n\tstruct usb_device *usb = comedi_to_usb_dev(dev);\n\tstruct usb_endpoint_descriptor *ep;\n\tunsigned int pipe;\n\n\tif (devpriv->model == VMK8061_MODEL) {\n\t\tvmk80xx_do_bulk_msg(dev);\n\t\treturn 0;\n\t}\n\n\tep = devpriv->ep_rx;\n\tpipe = usb_rcvintpipe(usb, ep->bEndpointAddress);\n\treturn usb_interrupt_msg(usb, pipe, devpriv->usb_rx_buf,\n\t\t\t\t usb_endpoint_maxp(ep), NULL,\n\t\t\t\t PACKET_TIMEOUT);\n}\n\nstatic int vmk80xx_write_packet(struct comedi_device *dev, int cmd)\n{\n\tstruct vmk80xx_private *devpriv = dev->private;\n\tstruct usb_device *usb = comedi_to_usb_dev(dev);\n\tstruct usb_endpoint_descriptor *ep;\n\tunsigned int pipe;\n\n\tdevpriv->usb_tx_buf[0] = cmd;\n\n\tif (devpriv->model == VMK8061_MODEL) {\n\t\tvmk80xx_do_bulk_msg(dev);\n\t\treturn 0;\n\t}\n\n\tep = devpriv->ep_tx;\n\tpipe = usb_sndintpipe(usb, ep->bEndpointAddress);\n\treturn usb_interrupt_msg(usb, pipe, devpriv->usb_tx_buf,\n\t\t\t\t usb_endpoint_maxp(ep), NULL,\n\t\t\t\t PACKET_TIMEOUT);\n}\n\nstatic int vmk80xx_reset_device(struct comedi_device *dev)\n{\n\tstruct vmk80xx_private *devpriv = dev->private;\n\tsize_t size;\n\tint retval;\n\n\tsize = usb_endpoint_maxp(devpriv->ep_tx);\n\tmemset(devpriv->usb_tx_buf, 0, size);\n\tretval = vmk80xx_write_packet(dev, VMK8055_CMD_RST);\n\tif (retval)\n\t\treturn retval;\n\t \n\treturn vmk80xx_write_packet(dev, VMK8055_CMD_WRT_AD);\n}\n\nstatic int vmk80xx_ai_insn_read(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tstruct comedi_insn *insn,\n\t\t\t\tunsigned int *data)\n{\n\tstruct vmk80xx_private *devpriv = dev->private;\n\tint chan;\n\tint reg[2];\n\tint n;\n\n\tdown(&devpriv->limit_sem);\n\tchan = CR_CHAN(insn->chanspec);\n\n\tswitch (devpriv->model) {\n\tcase VMK8055_MODEL:\n\t\tif (!chan)\n\t\t\treg[0] = VMK8055_AI1_REG;\n\t\telse\n\t\t\treg[0] = VMK8055_AI2_REG;\n\t\tbreak;\n\tcase VMK8061_MODEL:\n\tdefault:\n\t\treg[0] = VMK8061_AI_REG1;\n\t\treg[1] = VMK8061_AI_REG2;\n\t\tdevpriv->usb_tx_buf[0] = VMK8061_CMD_RD_AI;\n\t\tdevpriv->usb_tx_buf[VMK8061_CH_REG] = chan;\n\t\tbreak;\n\t}\n\n\tfor (n = 0; n < insn->n; n++) {\n\t\tif (vmk80xx_read_packet(dev))\n\t\t\tbreak;\n\n\t\tif (devpriv->model == VMK8055_MODEL) {\n\t\t\tdata[n] = devpriv->usb_rx_buf[reg[0]];\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tdata[n] = devpriv->usb_rx_buf[reg[0]] + 256 *\n\t\t    devpriv->usb_rx_buf[reg[1]];\n\t}\n\n\tup(&devpriv->limit_sem);\n\n\treturn n;\n}\n\nstatic int vmk80xx_ao_insn_write(struct comedi_device *dev,\n\t\t\t\t struct comedi_subdevice *s,\n\t\t\t\t struct comedi_insn *insn,\n\t\t\t\t unsigned int *data)\n{\n\tstruct vmk80xx_private *devpriv = dev->private;\n\tint chan;\n\tint cmd;\n\tint reg;\n\tint n;\n\n\tdown(&devpriv->limit_sem);\n\tchan = CR_CHAN(insn->chanspec);\n\n\tswitch (devpriv->model) {\n\tcase VMK8055_MODEL:\n\t\tcmd = VMK8055_CMD_WRT_AD;\n\t\tif (!chan)\n\t\t\treg = VMK8055_AO1_REG;\n\t\telse\n\t\t\treg = VMK8055_AO2_REG;\n\t\tbreak;\n\tdefault:\t\t \n\t\tcmd = VMK8061_CMD_SET_AO;\n\t\treg = VMK8061_AO_REG;\n\t\tdevpriv->usb_tx_buf[VMK8061_CH_REG] = chan;\n\t\tbreak;\n\t}\n\n\tfor (n = 0; n < insn->n; n++) {\n\t\tdevpriv->usb_tx_buf[reg] = data[n];\n\n\t\tif (vmk80xx_write_packet(dev, cmd))\n\t\t\tbreak;\n\t}\n\n\tup(&devpriv->limit_sem);\n\n\treturn n;\n}\n\nstatic int vmk80xx_ao_insn_read(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tstruct comedi_insn *insn,\n\t\t\t\tunsigned int *data)\n{\n\tstruct vmk80xx_private *devpriv = dev->private;\n\tint chan;\n\tint reg;\n\tint n;\n\n\tdown(&devpriv->limit_sem);\n\tchan = CR_CHAN(insn->chanspec);\n\n\treg = VMK8061_AO_REG - 1;\n\n\tdevpriv->usb_tx_buf[0] = VMK8061_CMD_RD_AO;\n\n\tfor (n = 0; n < insn->n; n++) {\n\t\tif (vmk80xx_read_packet(dev))\n\t\t\tbreak;\n\n\t\tdata[n] = devpriv->usb_rx_buf[reg + chan];\n\t}\n\n\tup(&devpriv->limit_sem);\n\n\treturn n;\n}\n\nstatic int vmk80xx_di_insn_bits(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tstruct comedi_insn *insn,\n\t\t\t\tunsigned int *data)\n{\n\tstruct vmk80xx_private *devpriv = dev->private;\n\tunsigned char *rx_buf;\n\tint reg;\n\tint retval;\n\n\tdown(&devpriv->limit_sem);\n\n\trx_buf = devpriv->usb_rx_buf;\n\n\tif (devpriv->model == VMK8061_MODEL) {\n\t\treg = VMK8061_DI_REG;\n\t\tdevpriv->usb_tx_buf[0] = VMK8061_CMD_RD_DI;\n\t} else {\n\t\treg = VMK8055_DI_REG;\n\t}\n\n\tretval = vmk80xx_read_packet(dev);\n\n\tif (!retval) {\n\t\tif (devpriv->model == VMK8055_MODEL)\n\t\t\tdata[1] = (((rx_buf[reg] >> 4) & 0x03) |\n\t\t\t\t  ((rx_buf[reg] << 2) & 0x04) |\n\t\t\t\t  ((rx_buf[reg] >> 3) & 0x18));\n\t\telse\n\t\t\tdata[1] = rx_buf[reg];\n\n\t\tretval = 2;\n\t}\n\n\tup(&devpriv->limit_sem);\n\n\treturn retval;\n}\n\nstatic int vmk80xx_do_insn_bits(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tstruct comedi_insn *insn,\n\t\t\t\tunsigned int *data)\n{\n\tstruct vmk80xx_private *devpriv = dev->private;\n\tunsigned char *rx_buf = devpriv->usb_rx_buf;\n\tunsigned char *tx_buf = devpriv->usb_tx_buf;\n\tint reg, cmd;\n\tint ret = 0;\n\n\tif (devpriv->model == VMK8061_MODEL) {\n\t\treg = VMK8061_DO_REG;\n\t\tcmd = VMK8061_CMD_DO;\n\t} else {  \n\t\treg = VMK8055_DO_REG;\n\t\tcmd = VMK8055_CMD_WRT_AD;\n\t}\n\n\tdown(&devpriv->limit_sem);\n\n\tif (comedi_dio_update_state(s, data)) {\n\t\ttx_buf[reg] = s->state;\n\t\tret = vmk80xx_write_packet(dev, cmd);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (devpriv->model == VMK8061_MODEL) {\n\t\ttx_buf[0] = VMK8061_CMD_RD_DO;\n\t\tret = vmk80xx_read_packet(dev);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tdata[1] = rx_buf[reg];\n\t} else {\n\t\tdata[1] = s->state;\n\t}\n\nout:\n\tup(&devpriv->limit_sem);\n\n\treturn ret ? ret : insn->n;\n}\n\nstatic int vmk80xx_cnt_insn_read(struct comedi_device *dev,\n\t\t\t\t struct comedi_subdevice *s,\n\t\t\t\t struct comedi_insn *insn,\n\t\t\t\t unsigned int *data)\n{\n\tstruct vmk80xx_private *devpriv = dev->private;\n\tint chan;\n\tint reg[2];\n\tint n;\n\n\tdown(&devpriv->limit_sem);\n\tchan = CR_CHAN(insn->chanspec);\n\n\tswitch (devpriv->model) {\n\tcase VMK8055_MODEL:\n\t\tif (!chan)\n\t\t\treg[0] = VMK8055_CNT1_REG;\n\t\telse\n\t\t\treg[0] = VMK8055_CNT2_REG;\n\t\tbreak;\n\tcase VMK8061_MODEL:\n\tdefault:\n\t\treg[0] = VMK8061_CNT_REG;\n\t\treg[1] = VMK8061_CNT_REG;\n\t\tdevpriv->usb_tx_buf[0] = VMK8061_CMD_RD_CNT;\n\t\tbreak;\n\t}\n\n\tfor (n = 0; n < insn->n; n++) {\n\t\tif (vmk80xx_read_packet(dev))\n\t\t\tbreak;\n\n\t\tif (devpriv->model == VMK8055_MODEL)\n\t\t\tdata[n] = devpriv->usb_rx_buf[reg[0]];\n\t\telse  \n\t\t\tdata[n] = devpriv->usb_rx_buf[reg[0] * (chan + 1) + 1]\n\t\t\t    + 256 * devpriv->usb_rx_buf[reg[1] * 2 + 2];\n\t}\n\n\tup(&devpriv->limit_sem);\n\n\treturn n;\n}\n\nstatic int vmk80xx_cnt_insn_config(struct comedi_device *dev,\n\t\t\t\t   struct comedi_subdevice *s,\n\t\t\t\t   struct comedi_insn *insn,\n\t\t\t\t   unsigned int *data)\n{\n\tstruct vmk80xx_private *devpriv = dev->private;\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tint cmd;\n\tint reg;\n\tint ret;\n\n\tdown(&devpriv->limit_sem);\n\tswitch (data[0]) {\n\tcase INSN_CONFIG_RESET:\n\t\tif (devpriv->model == VMK8055_MODEL) {\n\t\t\tif (!chan) {\n\t\t\t\tcmd = VMK8055_CMD_RST_CNT1;\n\t\t\t\treg = VMK8055_CNT1_REG;\n\t\t\t} else {\n\t\t\t\tcmd = VMK8055_CMD_RST_CNT2;\n\t\t\t\treg = VMK8055_CNT2_REG;\n\t\t\t}\n\t\t\tdevpriv->usb_tx_buf[reg] = 0x00;\n\t\t} else {\n\t\t\tcmd = VMK8061_CMD_RST_CNT;\n\t\t}\n\t\tret = vmk80xx_write_packet(dev, cmd);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\tup(&devpriv->limit_sem);\n\n\treturn ret ? ret : insn->n;\n}\n\nstatic int vmk80xx_cnt_insn_write(struct comedi_device *dev,\n\t\t\t\t  struct comedi_subdevice *s,\n\t\t\t\t  struct comedi_insn *insn,\n\t\t\t\t  unsigned int *data)\n{\n\tstruct vmk80xx_private *devpriv = dev->private;\n\tunsigned long debtime;\n\tunsigned long val;\n\tint chan;\n\tint cmd;\n\tint n;\n\n\tdown(&devpriv->limit_sem);\n\tchan = CR_CHAN(insn->chanspec);\n\n\tif (!chan)\n\t\tcmd = VMK8055_CMD_DEB1_TIME;\n\telse\n\t\tcmd = VMK8055_CMD_DEB2_TIME;\n\n\tfor (n = 0; n < insn->n; n++) {\n\t\tdebtime = data[n];\n\t\tif (debtime == 0)\n\t\t\tdebtime = 1;\n\n\t\t \n\t\tif (debtime > 7450)\n\t\t\tdebtime = 7450;\n\n\t\tval = int_sqrt(debtime * 1000 / 115);\n\t\tif (((val + 1) * val) < debtime * 1000 / 115)\n\t\t\tval += 1;\n\n\t\tdevpriv->usb_tx_buf[6 + chan] = val;\n\n\t\tif (vmk80xx_write_packet(dev, cmd))\n\t\t\tbreak;\n\t}\n\n\tup(&devpriv->limit_sem);\n\n\treturn n;\n}\n\nstatic int vmk80xx_pwm_insn_read(struct comedi_device *dev,\n\t\t\t\t struct comedi_subdevice *s,\n\t\t\t\t struct comedi_insn *insn,\n\t\t\t\t unsigned int *data)\n{\n\tstruct vmk80xx_private *devpriv = dev->private;\n\tunsigned char *tx_buf;\n\tunsigned char *rx_buf;\n\tint reg[2];\n\tint n;\n\n\tdown(&devpriv->limit_sem);\n\n\ttx_buf = devpriv->usb_tx_buf;\n\trx_buf = devpriv->usb_rx_buf;\n\n\treg[0] = VMK8061_PWM_REG1;\n\treg[1] = VMK8061_PWM_REG2;\n\n\ttx_buf[0] = VMK8061_CMD_RD_PWM;\n\n\tfor (n = 0; n < insn->n; n++) {\n\t\tif (vmk80xx_read_packet(dev))\n\t\t\tbreak;\n\n\t\tdata[n] = rx_buf[reg[0]] + 4 * rx_buf[reg[1]];\n\t}\n\n\tup(&devpriv->limit_sem);\n\n\treturn n;\n}\n\nstatic int vmk80xx_pwm_insn_write(struct comedi_device *dev,\n\t\t\t\t  struct comedi_subdevice *s,\n\t\t\t\t  struct comedi_insn *insn,\n\t\t\t\t  unsigned int *data)\n{\n\tstruct vmk80xx_private *devpriv = dev->private;\n\tunsigned char *tx_buf;\n\tint reg[2];\n\tint cmd;\n\tint n;\n\n\tdown(&devpriv->limit_sem);\n\n\ttx_buf = devpriv->usb_tx_buf;\n\n\treg[0] = VMK8061_PWM_REG1;\n\treg[1] = VMK8061_PWM_REG2;\n\n\tcmd = VMK8061_CMD_OUT_PWM;\n\n\t \n\tfor (n = 0; n < insn->n; n++) {\n\t\ttx_buf[reg[0]] = (unsigned char)(data[n] & 0x03);\n\t\ttx_buf[reg[1]] = (unsigned char)(data[n] >> 2) & 0xff;\n\n\t\tif (vmk80xx_write_packet(dev, cmd))\n\t\t\tbreak;\n\t}\n\n\tup(&devpriv->limit_sem);\n\n\treturn n;\n}\n\nstatic int vmk80xx_find_usb_endpoints(struct comedi_device *dev)\n{\n\tstruct vmk80xx_private *devpriv = dev->private;\n\tstruct usb_interface *intf = comedi_to_usb_interface(dev);\n\tstruct usb_host_interface *iface_desc = intf->cur_altsetting;\n\tstruct usb_endpoint_descriptor *ep_desc;\n\tint i;\n\n\tif (iface_desc->desc.bNumEndpoints != 2)\n\t\treturn -ENODEV;\n\n\tfor (i = 0; i < iface_desc->desc.bNumEndpoints; i++) {\n\t\tep_desc = &iface_desc->endpoint[i].desc;\n\n\t\tif (usb_endpoint_is_int_in(ep_desc) ||\n\t\t    usb_endpoint_is_bulk_in(ep_desc)) {\n\t\t\tif (!devpriv->ep_rx)\n\t\t\t\tdevpriv->ep_rx = ep_desc;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (usb_endpoint_is_int_out(ep_desc) ||\n\t\t    usb_endpoint_is_bulk_out(ep_desc)) {\n\t\t\tif (!devpriv->ep_tx)\n\t\t\t\tdevpriv->ep_tx = ep_desc;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tif (!devpriv->ep_rx || !devpriv->ep_tx)\n\t\treturn -ENODEV;\n\n\tif (!usb_endpoint_maxp(devpriv->ep_rx) || !usb_endpoint_maxp(devpriv->ep_tx))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int vmk80xx_alloc_usb_buffers(struct comedi_device *dev)\n{\n\tstruct vmk80xx_private *devpriv = dev->private;\n\tsize_t size;\n\n\tsize = max(usb_endpoint_maxp(devpriv->ep_rx), MIN_BUF_SIZE);\n\tdevpriv->usb_rx_buf = kzalloc(size, GFP_KERNEL);\n\tif (!devpriv->usb_rx_buf)\n\t\treturn -ENOMEM;\n\n\tsize = max(usb_endpoint_maxp(devpriv->ep_tx), MIN_BUF_SIZE);\n\tdevpriv->usb_tx_buf = kzalloc(size, GFP_KERNEL);\n\tif (!devpriv->usb_tx_buf)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int vmk80xx_init_subdevices(struct comedi_device *dev)\n{\n\tconst struct vmk80xx_board *board = dev->board_ptr;\n\tstruct vmk80xx_private *devpriv = dev->private;\n\tstruct comedi_subdevice *s;\n\tint n_subd;\n\tint ret;\n\n\tdown(&devpriv->limit_sem);\n\n\tif (devpriv->model == VMK8055_MODEL)\n\t\tn_subd = 5;\n\telse\n\t\tn_subd = 6;\n\tret = comedi_alloc_subdevices(dev, n_subd);\n\tif (ret) {\n\t\tup(&devpriv->limit_sem);\n\t\treturn ret;\n\t}\n\n\t \n\ts = &dev->subdevices[0];\n\ts->type\t\t= COMEDI_SUBD_AI;\n\ts->subdev_flags\t= SDF_READABLE | SDF_GROUND;\n\ts->n_chan\t= board->ai_nchans;\n\ts->maxdata\t= board->ai_maxdata;\n\ts->range_table\t= board->range;\n\ts->insn_read\t= vmk80xx_ai_insn_read;\n\n\t \n\ts = &dev->subdevices[1];\n\ts->type\t\t= COMEDI_SUBD_AO;\n\ts->subdev_flags\t= SDF_WRITABLE | SDF_GROUND;\n\ts->n_chan\t= board->ao_nchans;\n\ts->maxdata\t= 0x00ff;\n\ts->range_table\t= board->range;\n\ts->insn_write\t= vmk80xx_ao_insn_write;\n\tif (devpriv->model == VMK8061_MODEL) {\n\t\ts->subdev_flags\t|= SDF_READABLE;\n\t\ts->insn_read\t= vmk80xx_ao_insn_read;\n\t}\n\n\t \n\ts = &dev->subdevices[2];\n\ts->type\t\t= COMEDI_SUBD_DI;\n\ts->subdev_flags\t= SDF_READABLE;\n\ts->n_chan\t= board->di_nchans;\n\ts->maxdata\t= 1;\n\ts->range_table\t= &range_digital;\n\ts->insn_bits\t= vmk80xx_di_insn_bits;\n\n\t \n\ts = &dev->subdevices[3];\n\ts->type\t\t= COMEDI_SUBD_DO;\n\ts->subdev_flags\t= SDF_WRITABLE;\n\ts->n_chan\t= 8;\n\ts->maxdata\t= 1;\n\ts->range_table\t= &range_digital;\n\ts->insn_bits\t= vmk80xx_do_insn_bits;\n\n\t \n\ts = &dev->subdevices[4];\n\ts->type\t\t= COMEDI_SUBD_COUNTER;\n\ts->subdev_flags\t= SDF_READABLE;\n\ts->n_chan\t= 2;\n\ts->maxdata\t= board->cnt_maxdata;\n\ts->insn_read\t= vmk80xx_cnt_insn_read;\n\ts->insn_config\t= vmk80xx_cnt_insn_config;\n\tif (devpriv->model == VMK8055_MODEL) {\n\t\ts->subdev_flags\t|= SDF_WRITABLE;\n\t\ts->insn_write\t= vmk80xx_cnt_insn_write;\n\t}\n\n\t \n\tif (devpriv->model == VMK8061_MODEL) {\n\t\ts = &dev->subdevices[5];\n\t\ts->type\t\t= COMEDI_SUBD_PWM;\n\t\ts->subdev_flags\t= SDF_READABLE | SDF_WRITABLE;\n\t\ts->n_chan\t= board->pwm_nchans;\n\t\ts->maxdata\t= board->pwm_maxdata;\n\t\ts->insn_read\t= vmk80xx_pwm_insn_read;\n\t\ts->insn_write\t= vmk80xx_pwm_insn_write;\n\t}\n\n\tup(&devpriv->limit_sem);\n\n\treturn 0;\n}\n\nstatic int vmk80xx_auto_attach(struct comedi_device *dev,\n\t\t\t       unsigned long context)\n{\n\tstruct usb_interface *intf = comedi_to_usb_interface(dev);\n\tconst struct vmk80xx_board *board = NULL;\n\tstruct vmk80xx_private *devpriv;\n\tint ret;\n\n\tif (context < ARRAY_SIZE(vmk80xx_boardinfo))\n\t\tboard = &vmk80xx_boardinfo[context];\n\tif (!board)\n\t\treturn -ENODEV;\n\tdev->board_ptr = board;\n\tdev->board_name = board->name;\n\n\tdevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\n\tif (!devpriv)\n\t\treturn -ENOMEM;\n\n\tdevpriv->model = board->model;\n\n\tsema_init(&devpriv->limit_sem, 8);\n\n\tret = vmk80xx_find_usb_endpoints(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vmk80xx_alloc_usb_buffers(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tusb_set_intfdata(intf, devpriv);\n\n\tif (devpriv->model == VMK8055_MODEL)\n\t\tvmk80xx_reset_device(dev);\n\n\treturn vmk80xx_init_subdevices(dev);\n}\n\nstatic void vmk80xx_detach(struct comedi_device *dev)\n{\n\tstruct usb_interface *intf = comedi_to_usb_interface(dev);\n\tstruct vmk80xx_private *devpriv = dev->private;\n\n\tif (!devpriv)\n\t\treturn;\n\n\tdown(&devpriv->limit_sem);\n\n\tusb_set_intfdata(intf, NULL);\n\n\tkfree(devpriv->usb_rx_buf);\n\tkfree(devpriv->usb_tx_buf);\n\n\tup(&devpriv->limit_sem);\n}\n\nstatic struct comedi_driver vmk80xx_driver = {\n\t.module\t\t= THIS_MODULE,\n\t.driver_name\t= \"vmk80xx\",\n\t.auto_attach\t= vmk80xx_auto_attach,\n\t.detach\t\t= vmk80xx_detach,\n};\n\nstatic int vmk80xx_usb_probe(struct usb_interface *intf,\n\t\t\t     const struct usb_device_id *id)\n{\n\treturn comedi_usb_auto_config(intf, &vmk80xx_driver, id->driver_info);\n}\n\nstatic const struct usb_device_id vmk80xx_usb_id_table[] = {\n\t{ USB_DEVICE(0x10cf, 0x5500), .driver_info = DEVICE_VMK8055 },\n\t{ USB_DEVICE(0x10cf, 0x5501), .driver_info = DEVICE_VMK8055 },\n\t{ USB_DEVICE(0x10cf, 0x5502), .driver_info = DEVICE_VMK8055 },\n\t{ USB_DEVICE(0x10cf, 0x5503), .driver_info = DEVICE_VMK8055 },\n\t{ USB_DEVICE(0x10cf, 0x8061), .driver_info = DEVICE_VMK8061 },\n\t{ USB_DEVICE(0x10cf, 0x8062), .driver_info = DEVICE_VMK8061 },\n\t{ USB_DEVICE(0x10cf, 0x8063), .driver_info = DEVICE_VMK8061 },\n\t{ USB_DEVICE(0x10cf, 0x8064), .driver_info = DEVICE_VMK8061 },\n\t{ USB_DEVICE(0x10cf, 0x8065), .driver_info = DEVICE_VMK8061 },\n\t{ USB_DEVICE(0x10cf, 0x8066), .driver_info = DEVICE_VMK8061 },\n\t{ USB_DEVICE(0x10cf, 0x8067), .driver_info = DEVICE_VMK8061 },\n\t{ USB_DEVICE(0x10cf, 0x8068), .driver_info = DEVICE_VMK8061 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(usb, vmk80xx_usb_id_table);\n\nstatic struct usb_driver vmk80xx_usb_driver = {\n\t.name\t\t= \"vmk80xx\",\n\t.id_table\t= vmk80xx_usb_id_table,\n\t.probe\t\t= vmk80xx_usb_probe,\n\t.disconnect\t= comedi_usb_auto_unconfig,\n};\nmodule_comedi_usb_driver(vmk80xx_driver, vmk80xx_usb_driver);\n\nMODULE_AUTHOR(\"Manuel Gebele <forensixs@gmx.de>\");\nMODULE_DESCRIPTION(\"Velleman USB Board Low-Level Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}