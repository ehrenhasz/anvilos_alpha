{
  "module_name": "das800.c",
  "hash_id": "099ef34926c2a2c2fe28b568039c2f89ea3b8accb47da2cbadce777d2605ba6f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/das800.c",
  "human_readable_source": "\n \n \n\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/comedi/comedidev.h>\n#include <linux/comedi/comedi_8254.h>\n\n#define N_CHAN_AI             8\t \n\n \n\n#define DAS800_LSB            0\n#define   FIFO_EMPTY            0x1\n#define   FIFO_OVF              0x2\n#define DAS800_MSB            1\n#define DAS800_CONTROL1       2\n#define   CONTROL1_INTE         0x8\n#define DAS800_CONV_CONTROL   2\n#define   ITE                   0x1\n#define   CASC                  0x2\n#define   DTEN                  0x4\n#define   IEOC                  0x8\n#define   EACS                  0x10\n#define   CONV_HCEN             0x80\n#define DAS800_SCAN_LIMITS    2\n#define DAS800_STATUS         2\n#define   IRQ                   0x8\n#define   BUSY                  0x80\n#define DAS800_GAIN           3\n#define   CIO_FFOV              0x8    \n#define   CIO_ENHF              0x90   \n#define   CONTROL1              0x80\n#define   CONV_CONTROL          0xa0\n#define   SCAN_LIMITS           0xc0\n#define   ID                    0xe0\n#define DAS800_8254           4\n#define DAS800_STATUS2        7\n#define   STATUS2_HCEN          0x80\n#define   STATUS2_INTE          0X20\n#define DAS800_ID             7\n\n#define DAS802_16_HALF_FIFO_SZ\t128\n\nstruct das800_board {\n\tconst char *name;\n\tint ai_speed;\n\tconst struct comedi_lrange *ai_range;\n\tint resolution;\n};\n\nstatic const struct comedi_lrange range_das801_ai = {\n\t9, {\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(10),\n\t\tUNI_RANGE(10),\n\t\tBIP_RANGE(0.5),\n\t\tUNI_RANGE(1),\n\t\tBIP_RANGE(0.05),\n\t\tUNI_RANGE(0.1),\n\t\tBIP_RANGE(0.01),\n\t\tUNI_RANGE(0.02)\n\t}\n};\n\nstatic const struct comedi_lrange range_cio_das801_ai = {\n\t9, {\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(10),\n\t\tUNI_RANGE(10),\n\t\tBIP_RANGE(0.5),\n\t\tUNI_RANGE(1),\n\t\tBIP_RANGE(0.05),\n\t\tUNI_RANGE(0.1),\n\t\tBIP_RANGE(0.005),\n\t\tUNI_RANGE(0.01)\n\t}\n};\n\nstatic const struct comedi_lrange range_das802_ai = {\n\t9, {\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(10),\n\t\tUNI_RANGE(10),\n\t\tBIP_RANGE(2.5),\n\t\tUNI_RANGE(5),\n\t\tBIP_RANGE(1.25),\n\t\tUNI_RANGE(2.5),\n\t\tBIP_RANGE(0.625),\n\t\tUNI_RANGE(1.25)\n\t}\n};\n\nstatic const struct comedi_lrange range_das80216_ai = {\n\t8, {\n\t\tBIP_RANGE(10),\n\t\tUNI_RANGE(10),\n\t\tBIP_RANGE(5),\n\t\tUNI_RANGE(5),\n\t\tBIP_RANGE(2.5),\n\t\tUNI_RANGE(2.5),\n\t\tBIP_RANGE(1.25),\n\t\tUNI_RANGE(1.25)\n\t}\n};\n\nenum das800_boardinfo {\n\tBOARD_DAS800,\n\tBOARD_CIODAS800,\n\tBOARD_DAS801,\n\tBOARD_CIODAS801,\n\tBOARD_DAS802,\n\tBOARD_CIODAS802,\n\tBOARD_CIODAS80216,\n};\n\nstatic const struct das800_board das800_boards[] = {\n\t[BOARD_DAS800] = {\n\t\t.name\t\t= \"das-800\",\n\t\t.ai_speed\t= 25000,\n\t\t.ai_range\t= &range_bipolar5,\n\t\t.resolution\t= 12,\n\t},\n\t[BOARD_CIODAS800] = {\n\t\t.name\t\t= \"cio-das800\",\n\t\t.ai_speed\t= 20000,\n\t\t.ai_range\t= &range_bipolar5,\n\t\t.resolution\t= 12,\n\t},\n\t[BOARD_DAS801] = {\n\t\t.name\t\t= \"das-801\",\n\t\t.ai_speed\t= 25000,\n\t\t.ai_range\t= &range_das801_ai,\n\t\t.resolution\t= 12,\n\t},\n\t[BOARD_CIODAS801] = {\n\t\t.name\t\t= \"cio-das801\",\n\t\t.ai_speed\t= 20000,\n\t\t.ai_range\t= &range_cio_das801_ai,\n\t\t.resolution\t= 12,\n\t},\n\t[BOARD_DAS802] = {\n\t\t.name\t\t= \"das-802\",\n\t\t.ai_speed\t= 25000,\n\t\t.ai_range\t= &range_das802_ai,\n\t\t.resolution\t= 12,\n\t},\n\t[BOARD_CIODAS802] = {\n\t\t.name\t\t= \"cio-das802\",\n\t\t.ai_speed\t= 20000,\n\t\t.ai_range\t= &range_das802_ai,\n\t\t.resolution\t= 12,\n\t},\n\t[BOARD_CIODAS80216] = {\n\t\t.name\t\t= \"cio-das802/16\",\n\t\t.ai_speed\t= 10000,\n\t\t.ai_range\t= &range_das80216_ai,\n\t\t.resolution\t= 16,\n\t},\n};\n\nstruct das800_private {\n\tunsigned int do_bits;\t \n};\n\nstatic void das800_ind_write(struct comedi_device *dev,\n\t\t\t     unsigned int val, unsigned int reg)\n{\n\t \n\toutb(reg, dev->iobase + DAS800_GAIN);\n\toutb(val, dev->iobase + 2);\n}\n\nstatic unsigned int das800_ind_read(struct comedi_device *dev, unsigned int reg)\n{\n\t \n\toutb(reg, dev->iobase + DAS800_GAIN);\n\treturn inb(dev->iobase + 7);\n}\n\nstatic void das800_enable(struct comedi_device *dev)\n{\n\tconst struct das800_board *board = dev->board_ptr;\n\tstruct das800_private *devpriv = dev->private;\n\tunsigned long irq_flags;\n\n\tspin_lock_irqsave(&dev->spinlock, irq_flags);\n\t \n\tif (board->resolution == 16)\n\t\toutb(CIO_ENHF, dev->iobase + DAS800_GAIN);\n\t \n\tdas800_ind_write(dev, CONV_HCEN, CONV_CONTROL);\n\t \n\tdas800_ind_write(dev, CONTROL1_INTE | devpriv->do_bits, CONTROL1);\n\tspin_unlock_irqrestore(&dev->spinlock, irq_flags);\n}\n\nstatic void das800_disable(struct comedi_device *dev)\n{\n\tunsigned long irq_flags;\n\n\tspin_lock_irqsave(&dev->spinlock, irq_flags);\n\t \n\tdas800_ind_write(dev, 0x0, CONV_CONTROL);\n\tspin_unlock_irqrestore(&dev->spinlock, irq_flags);\n}\n\nstatic int das800_cancel(struct comedi_device *dev, struct comedi_subdevice *s)\n{\n\tdas800_disable(dev);\n\treturn 0;\n}\n\nstatic int das800_ai_check_chanlist(struct comedi_device *dev,\n\t\t\t\t    struct comedi_subdevice *s,\n\t\t\t\t    struct comedi_cmd *cmd)\n{\n\tunsigned int chan0 = CR_CHAN(cmd->chanlist[0]);\n\tunsigned int range0 = CR_RANGE(cmd->chanlist[0]);\n\tint i;\n\n\tfor (i = 1; i < cmd->chanlist_len; i++) {\n\t\tunsigned int chan = CR_CHAN(cmd->chanlist[i]);\n\t\tunsigned int range = CR_RANGE(cmd->chanlist[i]);\n\n\t\tif (chan != (chan0 + i) % s->n_chan) {\n\t\t\tdev_dbg(dev->class_dev,\n\t\t\t\t\"chanlist must be consecutive, counting upwards\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (range != range0) {\n\t\t\tdev_dbg(dev->class_dev,\n\t\t\t\t\"chanlist must all have the same gain\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int das800_ai_do_cmdtest(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tstruct comedi_cmd *cmd)\n{\n\tconst struct das800_board *board = dev->board_ptr;\n\tint err = 0;\n\n\t \n\n\terr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_EXT);\n\terr |= comedi_check_trigger_src(&cmd->scan_begin_src, TRIG_FOLLOW);\n\terr |= comedi_check_trigger_src(&cmd->convert_src,\n\t\t\t\t\tTRIG_TIMER | TRIG_EXT);\n\terr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\n\terr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\n\n\tif (err)\n\t\treturn 1;\n\n\t \n\n\terr |= comedi_check_trigger_is_unique(cmd->start_src);\n\terr |= comedi_check_trigger_is_unique(cmd->convert_src);\n\terr |= comedi_check_trigger_is_unique(cmd->stop_src);\n\n\t \n\n\tif (err)\n\t\treturn 2;\n\n\t \n\n\terr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\n\n\tif (cmd->convert_src == TRIG_TIMER) {\n\t\terr |= comedi_check_trigger_arg_min(&cmd->convert_arg,\n\t\t\t\t\t\t    board->ai_speed);\n\t}\n\n\terr |= comedi_check_trigger_arg_min(&cmd->chanlist_len, 1);\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\n\t\t\t\t\t   cmd->chanlist_len);\n\n\tif (cmd->stop_src == TRIG_COUNT)\n\t\terr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\n\telse\t \n\t\terr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\n\n\tif (err)\n\t\treturn 3;\n\n\t \n\n\tif (cmd->convert_src == TRIG_TIMER) {\n\t\tunsigned int arg = cmd->convert_arg;\n\n\t\tcomedi_8254_cascade_ns_to_timer(dev->pacer, &arg, cmd->flags);\n\t\terr |= comedi_check_trigger_arg_is(&cmd->convert_arg, arg);\n\t}\n\n\tif (err)\n\t\treturn 4;\n\n\t \n\tif (cmd->chanlist && cmd->chanlist_len > 0)\n\t\terr |= das800_ai_check_chanlist(dev, s, cmd);\n\n\tif (err)\n\t\treturn 5;\n\n\treturn 0;\n}\n\nstatic int das800_ai_do_cmd(struct comedi_device *dev,\n\t\t\t    struct comedi_subdevice *s)\n{\n\tconst struct das800_board *board = dev->board_ptr;\n\tstruct comedi_async *async = s->async;\n\tstruct comedi_cmd *cmd = &async->cmd;\n\tunsigned int gain = CR_RANGE(cmd->chanlist[0]);\n\tunsigned int start_chan = CR_CHAN(cmd->chanlist[0]);\n\tunsigned int end_chan = (start_chan + cmd->chanlist_len - 1) % 8;\n\tunsigned int scan_chans = (end_chan << 3) | start_chan;\n\tint conv_bits;\n\tunsigned long irq_flags;\n\n\tdas800_disable(dev);\n\n\tspin_lock_irqsave(&dev->spinlock, irq_flags);\n\t \n\tdas800_ind_write(dev, scan_chans, SCAN_LIMITS);\n\tspin_unlock_irqrestore(&dev->spinlock, irq_flags);\n\n\t \n\tif (board->resolution == 12 && gain > 0)\n\t\tgain += 0x7;\n\tgain &= 0xf;\n\toutb(gain, dev->iobase + DAS800_GAIN);\n\n\t \n\tconv_bits = 0;\n\tconv_bits |= EACS | IEOC;\n\tif (cmd->start_src == TRIG_EXT)\n\t\tconv_bits |= DTEN;\n\tif (cmd->convert_src == TRIG_TIMER) {\n\t\tconv_bits |= CASC | ITE;\n\t\tcomedi_8254_update_divisors(dev->pacer);\n\t\tcomedi_8254_pacer_enable(dev->pacer, 1, 2, true);\n\t}\n\n\tspin_lock_irqsave(&dev->spinlock, irq_flags);\n\tdas800_ind_write(dev, conv_bits, CONV_CONTROL);\n\tspin_unlock_irqrestore(&dev->spinlock, irq_flags);\n\n\tdas800_enable(dev);\n\treturn 0;\n}\n\nstatic unsigned int das800_ai_get_sample(struct comedi_device *dev)\n{\n\tunsigned int lsb = inb(dev->iobase + DAS800_LSB);\n\tunsigned int msb = inb(dev->iobase + DAS800_MSB);\n\n\treturn (msb << 8) | lsb;\n}\n\nstatic irqreturn_t das800_interrupt(int irq, void *d)\n{\n\tstruct comedi_device *dev = d;\n\tstruct das800_private *devpriv = dev->private;\n\tstruct comedi_subdevice *s = dev->read_subdev;\n\tstruct comedi_async *async;\n\tstruct comedi_cmd *cmd;\n\tunsigned long irq_flags;\n\tunsigned int status;\n\tunsigned short val;\n\tbool fifo_empty;\n\tbool fifo_overflow;\n\tint i;\n\n\tstatus = inb(dev->iobase + DAS800_STATUS);\n\tif (!(status & IRQ))\n\t\treturn IRQ_NONE;\n\tif (!dev->attached)\n\t\treturn IRQ_HANDLED;\n\n\tasync = s->async;\n\tcmd = &async->cmd;\n\n\tspin_lock_irqsave(&dev->spinlock, irq_flags);\n\tstatus = das800_ind_read(dev, CONTROL1) & STATUS2_HCEN;\n\t \n\n\t \n\tif (status == 0) {\n\t\tspin_unlock_irqrestore(&dev->spinlock, irq_flags);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tfor (i = 0; i < DAS802_16_HALF_FIFO_SZ; i++) {\n\t\tval = das800_ai_get_sample(dev);\n\t\tif (s->maxdata == 0x0fff) {\n\t\t\tfifo_empty = !!(val & FIFO_EMPTY);\n\t\t\tfifo_overflow = !!(val & FIFO_OVF);\n\t\t} else {\n\t\t\t \n\t\t\tfifo_empty = false;\n\t\t\tfifo_overflow = !!(inb(dev->iobase + DAS800_GAIN) &\n\t\t\t\t\t\tCIO_FFOV);\n\t\t}\n\t\tif (fifo_empty || fifo_overflow)\n\t\t\tbreak;\n\n\t\tif (s->maxdata == 0x0fff)\n\t\t\tval >>= 4;\t \n\n\t\tval &= s->maxdata;\n\t\tcomedi_buf_write_samples(s, &val, 1);\n\n\t\tif (cmd->stop_src == TRIG_COUNT &&\n\t\t    async->scans_done >= cmd->stop_arg) {\n\t\t\tasync->events |= COMEDI_CB_EOA;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (fifo_overflow) {\n\t\tspin_unlock_irqrestore(&dev->spinlock, irq_flags);\n\t\tasync->events |= COMEDI_CB_ERROR;\n\t\tcomedi_handle_events(dev, s);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (!(async->events & COMEDI_CB_CANCEL_MASK)) {\n\t\t \n\t\tdas800_ind_write(dev, CONTROL1_INTE | devpriv->do_bits,\n\t\t\t\t CONTROL1);\n\t\tspin_unlock_irqrestore(&dev->spinlock, irq_flags);\n\t} else {\n\t\t \n\t\tspin_unlock_irqrestore(&dev->spinlock, irq_flags);\n\t\tdas800_disable(dev);\n\t}\n\tcomedi_handle_events(dev, s);\n\treturn IRQ_HANDLED;\n}\n\nstatic int das800_ai_eoc(struct comedi_device *dev,\n\t\t\t struct comedi_subdevice *s,\n\t\t\t struct comedi_insn *insn,\n\t\t\t unsigned long context)\n{\n\tunsigned int status;\n\n\tstatus = inb(dev->iobase + DAS800_STATUS);\n\tif ((status & BUSY) == 0)\n\t\treturn 0;\n\treturn -EBUSY;\n}\n\nstatic int das800_ai_insn_read(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       struct comedi_insn *insn,\n\t\t\t       unsigned int *data)\n{\n\tstruct das800_private *devpriv = dev->private;\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int range = CR_RANGE(insn->chanspec);\n\tunsigned long irq_flags;\n\tunsigned int val;\n\tint ret;\n\tint i;\n\n\tdas800_disable(dev);\n\n\t \n\tspin_lock_irqsave(&dev->spinlock, irq_flags);\n\tdas800_ind_write(dev, chan | devpriv->do_bits, CONTROL1);\n\tspin_unlock_irqrestore(&dev->spinlock, irq_flags);\n\n\t \n\tif (s->maxdata == 0x0fff && range)\n\t\trange += 0x7;\n\trange &= 0xf;\n\toutb(range, dev->iobase + DAS800_GAIN);\n\n\tudelay(5);\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\t \n\t\toutb_p(0, dev->iobase + DAS800_MSB);\n\n\t\tret = comedi_timeout(dev, s, insn, das800_ai_eoc, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tval = das800_ai_get_sample(dev);\n\t\tif (s->maxdata == 0x0fff)\n\t\t\tval >>= 4;\t \n\t\tdata[i] = val & s->maxdata;\n\t}\n\n\treturn insn->n;\n}\n\nstatic int das800_di_insn_bits(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       struct comedi_insn *insn,\n\t\t\t       unsigned int *data)\n{\n\tdata[1] = (inb(dev->iobase + DAS800_STATUS) >> 4) & 0x7;\n\n\treturn insn->n;\n}\n\nstatic int das800_do_insn_bits(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       struct comedi_insn *insn,\n\t\t\t       unsigned int *data)\n{\n\tstruct das800_private *devpriv = dev->private;\n\tunsigned long irq_flags;\n\n\tif (comedi_dio_update_state(s, data)) {\n\t\tdevpriv->do_bits = s->state << 4;\n\n\t\tspin_lock_irqsave(&dev->spinlock, irq_flags);\n\t\tdas800_ind_write(dev, CONTROL1_INTE | devpriv->do_bits,\n\t\t\t\t CONTROL1);\n\t\tspin_unlock_irqrestore(&dev->spinlock, irq_flags);\n\t}\n\n\tdata[1] = s->state;\n\n\treturn insn->n;\n}\n\nstatic const struct das800_board *das800_probe(struct comedi_device *dev)\n{\n\tconst struct das800_board *board = dev->board_ptr;\n\tint index = board ? board - das800_boards : -EINVAL;\n\tint id_bits;\n\tunsigned long irq_flags;\n\n\t \n\tspin_lock_irqsave(&dev->spinlock, irq_flags);\n\tid_bits = das800_ind_read(dev, ID) & 0x3;\n\tspin_unlock_irqrestore(&dev->spinlock, irq_flags);\n\n\tswitch (id_bits) {\n\tcase 0x0:\n\t\tif (index == BOARD_DAS800 || index == BOARD_CIODAS800)\n\t\t\treturn board;\n\t\tindex = BOARD_DAS800;\n\t\tbreak;\n\tcase 0x2:\n\t\tif (index == BOARD_DAS801 || index == BOARD_CIODAS801)\n\t\t\treturn board;\n\t\tindex = BOARD_DAS801;\n\t\tbreak;\n\tcase 0x3:\n\t\tif (index == BOARD_DAS802 || index == BOARD_CIODAS802 ||\n\t\t    index == BOARD_CIODAS80216)\n\t\t\treturn board;\n\t\tindex = BOARD_DAS802;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(dev->class_dev, \"Board model: 0x%x (unknown)\\n\",\n\t\t\tid_bits);\n\t\treturn NULL;\n\t}\n\tdev_dbg(dev->class_dev, \"Board model (probed): %s series\\n\",\n\t\tdas800_boards[index].name);\n\n\treturn &das800_boards[index];\n}\n\nstatic int das800_attach(struct comedi_device *dev, struct comedi_devconfig *it)\n{\n\tconst struct das800_board *board;\n\tstruct das800_private *devpriv;\n\tstruct comedi_subdevice *s;\n\tunsigned int irq = it->options[1];\n\tunsigned long irq_flags;\n\tint ret;\n\n\tdevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\n\tif (!devpriv)\n\t\treturn -ENOMEM;\n\n\tret = comedi_request_region(dev, it->options[0], 0x8);\n\tif (ret)\n\t\treturn ret;\n\n\tboard = das800_probe(dev);\n\tif (!board)\n\t\treturn -ENODEV;\n\tdev->board_ptr = board;\n\tdev->board_name = board->name;\n\n\tif (irq > 1 && irq <= 7) {\n\t\tret = request_irq(irq, das800_interrupt, 0, \"das800\",\n\t\t\t\t  dev);\n\t\tif (ret == 0)\n\t\t\tdev->irq = irq;\n\t}\n\n\tdev->pacer = comedi_8254_init(dev->iobase + DAS800_8254,\n\t\t\t\t      I8254_OSC_BASE_1MHZ, I8254_IO8, 0);\n\tif (!dev->pacer)\n\t\treturn -ENOMEM;\n\n\tret = comedi_alloc_subdevices(dev, 3);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ts = &dev->subdevices[0];\n\tdev->read_subdev = s;\n\ts->type\t\t= COMEDI_SUBD_AI;\n\ts->subdev_flags\t= SDF_READABLE | SDF_GROUND;\n\ts->n_chan\t= 8;\n\ts->maxdata\t= (1 << board->resolution) - 1;\n\ts->range_table\t= board->ai_range;\n\ts->insn_read\t= das800_ai_insn_read;\n\tif (dev->irq) {\n\t\ts->subdev_flags\t|= SDF_CMD_READ;\n\t\ts->len_chanlist\t= 8;\n\t\ts->do_cmdtest\t= das800_ai_do_cmdtest;\n\t\ts->do_cmd\t= das800_ai_do_cmd;\n\t\ts->cancel\t= das800_cancel;\n\t}\n\n\t \n\ts = &dev->subdevices[1];\n\ts->type\t\t= COMEDI_SUBD_DI;\n\ts->subdev_flags\t= SDF_READABLE;\n\ts->n_chan\t= 3;\n\ts->maxdata\t= 1;\n\ts->range_table\t= &range_digital;\n\ts->insn_bits\t= das800_di_insn_bits;\n\n\t \n\ts = &dev->subdevices[2];\n\ts->type\t\t= COMEDI_SUBD_DO;\n\ts->subdev_flags\t= SDF_WRITABLE;\n\ts->n_chan\t= 4;\n\ts->maxdata\t= 1;\n\ts->range_table\t= &range_digital;\n\ts->insn_bits\t= das800_do_insn_bits;\n\n\tdas800_disable(dev);\n\n\t \n\tspin_lock_irqsave(&dev->spinlock, irq_flags);\n\tdas800_ind_write(dev, CONTROL1_INTE | devpriv->do_bits, CONTROL1);\n\tspin_unlock_irqrestore(&dev->spinlock, irq_flags);\n\n\treturn 0;\n};\n\nstatic struct comedi_driver driver_das800 = {\n\t.driver_name\t= \"das800\",\n\t.module\t\t= THIS_MODULE,\n\t.attach\t\t= das800_attach,\n\t.detach\t\t= comedi_legacy_detach,\n\t.num_names\t= ARRAY_SIZE(das800_boards),\n\t.board_name\t= &das800_boards[0].name,\n\t.offset\t\t= sizeof(struct das800_board),\n};\nmodule_comedi_driver(driver_das800);\n\nMODULE_AUTHOR(\"Comedi https://www.comedi.org\");\nMODULE_DESCRIPTION(\"Comedi low-level driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}