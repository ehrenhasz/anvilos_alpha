{
  "module_name": "ni_mio_common.c",
  "hash_id": "bfebf62ca56f44f860f26a179838d1036ee381ef481a46ca5f690a9eb518d135",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/ni_mio_common.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/comedi/comedi_8255.h>\n#include \"mite.h\"\n\n \n#define NI_TIMEOUT 1000\n\n \nstatic const short ni_gainlkup[][16] = {\n\t[ai_gain_16] = {0, 1, 2, 3, 4, 5, 6, 7,\n\t\t\t0x100, 0x101, 0x102, 0x103, 0x104, 0x105, 0x106, 0x107},\n\t[ai_gain_8] = {1, 2, 4, 7, 0x101, 0x102, 0x104, 0x107},\n\t[ai_gain_14] = {1, 2, 3, 4, 5, 6, 7,\n\t\t\t0x101, 0x102, 0x103, 0x104, 0x105, 0x106, 0x107},\n\t[ai_gain_4] = {0, 1, 4, 7},\n\t[ai_gain_611x] = {0x00a, 0x00b, 0x001, 0x002,\n\t\t\t  0x003, 0x004, 0x005, 0x006},\n\t[ai_gain_622x] = {0, 1, 4, 5},\n\t[ai_gain_628x] = {1, 2, 3, 4, 5, 6, 7},\n\t[ai_gain_6143] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n};\n\nstatic const struct comedi_lrange range_ni_E_ai = {\n\t16, {\n\t\tBIP_RANGE(10),\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(2.5),\n\t\tBIP_RANGE(1),\n\t\tBIP_RANGE(0.5),\n\t\tBIP_RANGE(0.25),\n\t\tBIP_RANGE(0.1),\n\t\tBIP_RANGE(0.05),\n\t\tUNI_RANGE(20),\n\t\tUNI_RANGE(10),\n\t\tUNI_RANGE(5),\n\t\tUNI_RANGE(2),\n\t\tUNI_RANGE(1),\n\t\tUNI_RANGE(0.5),\n\t\tUNI_RANGE(0.2),\n\t\tUNI_RANGE(0.1)\n\t}\n};\n\nstatic const struct comedi_lrange range_ni_E_ai_limited = {\n\t8, {\n\t\tBIP_RANGE(10),\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(1),\n\t\tBIP_RANGE(0.1),\n\t\tUNI_RANGE(10),\n\t\tUNI_RANGE(5),\n\t\tUNI_RANGE(1),\n\t\tUNI_RANGE(0.1)\n\t}\n};\n\nstatic const struct comedi_lrange range_ni_E_ai_limited14 = {\n\t14, {\n\t\tBIP_RANGE(10),\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(2),\n\t\tBIP_RANGE(1),\n\t\tBIP_RANGE(0.5),\n\t\tBIP_RANGE(0.2),\n\t\tBIP_RANGE(0.1),\n\t\tUNI_RANGE(10),\n\t\tUNI_RANGE(5),\n\t\tUNI_RANGE(2),\n\t\tUNI_RANGE(1),\n\t\tUNI_RANGE(0.5),\n\t\tUNI_RANGE(0.2),\n\t\tUNI_RANGE(0.1)\n\t}\n};\n\nstatic const struct comedi_lrange range_ni_E_ai_bipolar4 = {\n\t4, {\n\t\tBIP_RANGE(10),\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(0.5),\n\t\tBIP_RANGE(0.05)\n\t}\n};\n\nstatic const struct comedi_lrange range_ni_E_ai_611x = {\n\t8, {\n\t\tBIP_RANGE(50),\n\t\tBIP_RANGE(20),\n\t\tBIP_RANGE(10),\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(2),\n\t\tBIP_RANGE(1),\n\t\tBIP_RANGE(0.5),\n\t\tBIP_RANGE(0.2)\n\t}\n};\n\nstatic const struct comedi_lrange range_ni_M_ai_622x = {\n\t4, {\n\t\tBIP_RANGE(10),\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(1),\n\t\tBIP_RANGE(0.2)\n\t}\n};\n\nstatic const struct comedi_lrange range_ni_M_ai_628x = {\n\t7, {\n\t\tBIP_RANGE(10),\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(2),\n\t\tBIP_RANGE(1),\n\t\tBIP_RANGE(0.5),\n\t\tBIP_RANGE(0.2),\n\t\tBIP_RANGE(0.1)\n\t}\n};\n\nstatic const struct comedi_lrange range_ni_E_ao_ext = {\n\t4, {\n\t\tBIP_RANGE(10),\n\t\tUNI_RANGE(10),\n\t\tRANGE_ext(-1, 1),\n\t\tRANGE_ext(0, 1)\n\t}\n};\n\nstatic const struct comedi_lrange *const ni_range_lkup[] = {\n\t[ai_gain_16] = &range_ni_E_ai,\n\t[ai_gain_8] = &range_ni_E_ai_limited,\n\t[ai_gain_14] = &range_ni_E_ai_limited14,\n\t[ai_gain_4] = &range_ni_E_ai_bipolar4,\n\t[ai_gain_611x] = &range_ni_E_ai_611x,\n\t[ai_gain_622x] = &range_ni_M_ai_622x,\n\t[ai_gain_628x] = &range_ni_M_ai_628x,\n\t[ai_gain_6143] = &range_bipolar5\n};\n\nenum aimodes {\n\tAIMODE_NONE = 0,\n\tAIMODE_HALF_FULL = 1,\n\tAIMODE_SCAN = 2,\n\tAIMODE_SAMPLE = 3,\n};\n\nenum ni_common_subdevices {\n\tNI_AI_SUBDEV,\n\tNI_AO_SUBDEV,\n\tNI_DIO_SUBDEV,\n\tNI_8255_DIO_SUBDEV,\n\tNI_UNUSED_SUBDEV,\n\tNI_CALIBRATION_SUBDEV,\n\tNI_EEPROM_SUBDEV,\n\tNI_PFI_DIO_SUBDEV,\n\tNI_CS5529_CALIBRATION_SUBDEV,\n\tNI_SERIAL_SUBDEV,\n\tNI_RTSI_SUBDEV,\n\tNI_GPCT0_SUBDEV,\n\tNI_GPCT1_SUBDEV,\n\tNI_FREQ_OUT_SUBDEV,\n\tNI_NUM_SUBDEVICES\n};\n\n#define NI_GPCT_SUBDEV(x)\t(NI_GPCT0_SUBDEV + (x))\n\nenum timebase_nanoseconds {\n\tTIMEBASE_1_NS = 50,\n\tTIMEBASE_2_NS = 10000\n};\n\n#define SERIAL_DISABLED\t\t0\n#define SERIAL_600NS\t\t600\n#define SERIAL_1_2US\t\t1200\n#define SERIAL_10US\t\t\t10000\n\nstatic const int num_adc_stages_611x = 3;\n\nstatic void ni_writel(struct comedi_device *dev, unsigned int data, int reg)\n{\n\tif (dev->mmio)\n\t\twritel(data, dev->mmio + reg);\n\telse\n\t\toutl(data, dev->iobase + reg);\n}\n\nstatic void ni_writew(struct comedi_device *dev, unsigned int data, int reg)\n{\n\tif (dev->mmio)\n\t\twritew(data, dev->mmio + reg);\n\telse\n\t\toutw(data, dev->iobase + reg);\n}\n\nstatic void ni_writeb(struct comedi_device *dev, unsigned int data, int reg)\n{\n\tif (dev->mmio)\n\t\twriteb(data, dev->mmio + reg);\n\telse\n\t\toutb(data, dev->iobase + reg);\n}\n\nstatic unsigned int ni_readl(struct comedi_device *dev, int reg)\n{\n\tif (dev->mmio)\n\t\treturn readl(dev->mmio + reg);\n\n\treturn inl(dev->iobase + reg);\n}\n\nstatic unsigned int ni_readw(struct comedi_device *dev, int reg)\n{\n\tif (dev->mmio)\n\t\treturn readw(dev->mmio + reg);\n\n\treturn inw(dev->iobase + reg);\n}\n\nstatic unsigned int ni_readb(struct comedi_device *dev, int reg)\n{\n\tif (dev->mmio)\n\t\treturn readb(dev->mmio + reg);\n\n\treturn inb(dev->iobase + reg);\n}\n\n \n\nstruct mio_regmap {\n\tunsigned int mio_reg;\n\tint size;\n};\n\nstatic const struct mio_regmap m_series_stc_write_regmap[] = {\n\t[NISTC_INTA_ACK_REG]\t\t= { 0x104, 2 },\n\t[NISTC_INTB_ACK_REG]\t\t= { 0x106, 2 },\n\t[NISTC_AI_CMD2_REG]\t\t= { 0x108, 2 },\n\t[NISTC_AO_CMD2_REG]\t\t= { 0x10a, 2 },\n\t[NISTC_G0_CMD_REG]\t\t= { 0x10c, 2 },\n\t[NISTC_G1_CMD_REG]\t\t= { 0x10e, 2 },\n\t[NISTC_AI_CMD1_REG]\t\t= { 0x110, 2 },\n\t[NISTC_AO_CMD1_REG]\t\t= { 0x112, 2 },\n\t \n\t[NISTC_DIO_OUT_REG]\t\t= { 0, 0 },  \n\t[NISTC_DIO_CTRL_REG]\t\t= { 0, 0 },  \n\t[NISTC_AI_MODE1_REG]\t\t= { 0x118, 2 },\n\t[NISTC_AI_MODE2_REG]\t\t= { 0x11a, 2 },\n\t[NISTC_AI_SI_LOADA_REG]\t\t= { 0x11c, 4 },\n\t[NISTC_AI_SI_LOADB_REG]\t\t= { 0x120, 4 },\n\t[NISTC_AI_SC_LOADA_REG]\t\t= { 0x124, 4 },\n\t[NISTC_AI_SC_LOADB_REG]\t\t= { 0x128, 4 },\n\t[NISTC_AI_SI2_LOADA_REG]\t= { 0x12c, 4 },\n\t[NISTC_AI_SI2_LOADB_REG]\t= { 0x130, 4 },\n\t[NISTC_G0_MODE_REG]\t\t= { 0x134, 2 },\n\t[NISTC_G1_MODE_REG]\t\t= { 0x136, 2 },\n\t[NISTC_G0_LOADA_REG]\t\t= { 0x138, 4 },\n\t[NISTC_G0_LOADB_REG]\t\t= { 0x13c, 4 },\n\t[NISTC_G1_LOADA_REG]\t\t= { 0x140, 4 },\n\t[NISTC_G1_LOADB_REG]\t\t= { 0x144, 4 },\n\t[NISTC_G0_INPUT_SEL_REG]\t= { 0x148, 2 },\n\t[NISTC_G1_INPUT_SEL_REG]\t= { 0x14a, 2 },\n\t[NISTC_AO_MODE1_REG]\t\t= { 0x14c, 2 },\n\t[NISTC_AO_MODE2_REG]\t\t= { 0x14e, 2 },\n\t[NISTC_AO_UI_LOADA_REG]\t\t= { 0x150, 4 },\n\t[NISTC_AO_UI_LOADB_REG]\t\t= { 0x154, 4 },\n\t[NISTC_AO_BC_LOADA_REG]\t\t= { 0x158, 4 },\n\t[NISTC_AO_BC_LOADB_REG]\t\t= { 0x15c, 4 },\n\t[NISTC_AO_UC_LOADA_REG]\t\t= { 0x160, 4 },\n\t[NISTC_AO_UC_LOADB_REG]\t\t= { 0x164, 4 },\n\t[NISTC_CLK_FOUT_REG]\t\t= { 0x170, 2 },\n\t[NISTC_IO_BIDIR_PIN_REG]\t= { 0x172, 2 },\n\t[NISTC_RTSI_TRIG_DIR_REG]\t= { 0x174, 2 },\n\t[NISTC_INT_CTRL_REG]\t\t= { 0x176, 2 },\n\t[NISTC_AI_OUT_CTRL_REG]\t\t= { 0x178, 2 },\n\t[NISTC_ATRIG_ETC_REG]\t\t= { 0x17a, 2 },\n\t[NISTC_AI_START_STOP_REG]\t= { 0x17c, 2 },\n\t[NISTC_AI_TRIG_SEL_REG]\t\t= { 0x17e, 2 },\n\t[NISTC_AI_DIV_LOADA_REG]\t= { 0x180, 4 },\n\t[NISTC_AO_START_SEL_REG]\t= { 0x184, 2 },\n\t[NISTC_AO_TRIG_SEL_REG]\t\t= { 0x186, 2 },\n\t[NISTC_G0_AUTOINC_REG]\t\t= { 0x188, 2 },\n\t[NISTC_G1_AUTOINC_REG]\t\t= { 0x18a, 2 },\n\t[NISTC_AO_MODE3_REG]\t\t= { 0x18c, 2 },\n\t[NISTC_RESET_REG]\t\t= { 0x190, 2 },\n\t[NISTC_INTA_ENA_REG]\t\t= { 0x192, 2 },\n\t[NISTC_INTA2_ENA_REG]\t\t= { 0, 0 },  \n\t[NISTC_INTB_ENA_REG]\t\t= { 0x196, 2 },\n\t[NISTC_INTB2_ENA_REG]\t\t= { 0, 0 },  \n\t[NISTC_AI_PERSONAL_REG]\t\t= { 0x19a, 2 },\n\t[NISTC_AO_PERSONAL_REG]\t\t= { 0x19c, 2 },\n\t[NISTC_RTSI_TRIGA_OUT_REG]\t= { 0x19e, 2 },\n\t[NISTC_RTSI_TRIGB_OUT_REG]\t= { 0x1a0, 2 },\n\t \n\t[NISTC_RTSI_BOARD_REG]\t\t= { 0x1a2, 2 },\n\t[NISTC_CFG_MEM_CLR_REG]\t\t= { 0x1a4, 2 },\n\t[NISTC_ADC_FIFO_CLR_REG]\t= { 0x1a6, 2 },\n\t[NISTC_DAC_FIFO_CLR_REG]\t= { 0x1a8, 2 },\n\t[NISTC_AO_OUT_CTRL_REG]\t\t= { 0x1ac, 2 },\n\t[NISTC_AI_MODE3_REG]\t\t= { 0x1ae, 2 },\n};\n\nstatic void m_series_stc_write(struct comedi_device *dev,\n\t\t\t       unsigned int data, unsigned int reg)\n{\n\tconst struct mio_regmap *regmap;\n\n\tif (reg < ARRAY_SIZE(m_series_stc_write_regmap)) {\n\t\tregmap = &m_series_stc_write_regmap[reg];\n\t} else {\n\t\tdev_warn(dev->class_dev, \"%s: unhandled register=0x%x\\n\",\n\t\t\t __func__, reg);\n\t\treturn;\n\t}\n\n\tswitch (regmap->size) {\n\tcase 4:\n\t\tni_writel(dev, data, regmap->mio_reg);\n\t\tbreak;\n\tcase 2:\n\t\tni_writew(dev, data, regmap->mio_reg);\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(dev->class_dev, \"%s: unmapped register=0x%x\\n\",\n\t\t\t __func__, reg);\n\t\tbreak;\n\t}\n}\n\nstatic const struct mio_regmap m_series_stc_read_regmap[] = {\n\t[NISTC_AI_STATUS1_REG]\t\t= { 0x104, 2 },\n\t[NISTC_AO_STATUS1_REG]\t\t= { 0x106, 2 },\n\t[NISTC_G01_STATUS_REG]\t\t= { 0x108, 2 },\n\t[NISTC_AI_STATUS2_REG]\t\t= { 0, 0 },  \n\t[NISTC_AO_STATUS2_REG]\t\t= { 0x10c, 2 },\n\t[NISTC_DIO_IN_REG]\t\t= { 0, 0 },  \n\t[NISTC_G0_HW_SAVE_REG]\t\t= { 0x110, 4 },\n\t[NISTC_G1_HW_SAVE_REG]\t\t= { 0x114, 4 },\n\t[NISTC_G0_SAVE_REG]\t\t= { 0x118, 4 },\n\t[NISTC_G1_SAVE_REG]\t\t= { 0x11c, 4 },\n\t[NISTC_AO_UI_SAVE_REG]\t\t= { 0x120, 4 },\n\t[NISTC_AO_BC_SAVE_REG]\t\t= { 0x124, 4 },\n\t[NISTC_AO_UC_SAVE_REG]\t\t= { 0x128, 4 },\n\t[NISTC_STATUS1_REG]\t\t= { 0x136, 2 },\n\t[NISTC_DIO_SERIAL_IN_REG]\t= { 0x009, 1 },\n\t[NISTC_STATUS2_REG]\t\t= { 0x13a, 2 },\n\t[NISTC_AI_SI_SAVE_REG]\t\t= { 0x180, 4 },\n\t[NISTC_AI_SC_SAVE_REG]\t\t= { 0x184, 4 },\n};\n\nstatic unsigned int m_series_stc_read(struct comedi_device *dev,\n\t\t\t\t      unsigned int reg)\n{\n\tconst struct mio_regmap *regmap;\n\n\tif (reg < ARRAY_SIZE(m_series_stc_read_regmap)) {\n\t\tregmap = &m_series_stc_read_regmap[reg];\n\t} else {\n\t\tdev_warn(dev->class_dev, \"%s: unhandled register=0x%x\\n\",\n\t\t\t __func__, reg);\n\t\treturn 0;\n\t}\n\n\tswitch (regmap->size) {\n\tcase 4:\n\t\treturn ni_readl(dev, regmap->mio_reg);\n\tcase 2:\n\t\treturn ni_readw(dev, regmap->mio_reg);\n\tcase 1:\n\t\treturn ni_readb(dev, regmap->mio_reg);\n\tdefault:\n\t\tdev_warn(dev->class_dev, \"%s: unmapped register=0x%x\\n\",\n\t\t\t __func__, reg);\n\t\treturn 0;\n\t}\n}\n\nstatic void ni_stc_writew(struct comedi_device *dev,\n\t\t\t  unsigned int data, int reg)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tunsigned long flags;\n\n\tif (devpriv->is_m_series) {\n\t\tm_series_stc_write(dev, data, reg);\n\t} else {\n\t\tspin_lock_irqsave(&devpriv->window_lock, flags);\n\t\tif (!devpriv->mite && reg < 8) {\n\t\t\tni_writew(dev, data, reg * 2);\n\t\t} else {\n\t\t\tni_writew(dev, reg, NI_E_STC_WINDOW_ADDR_REG);\n\t\t\tni_writew(dev, data, NI_E_STC_WINDOW_DATA_REG);\n\t\t}\n\t\tspin_unlock_irqrestore(&devpriv->window_lock, flags);\n\t}\n}\n\nstatic void ni_stc_writel(struct comedi_device *dev,\n\t\t\t  unsigned int data, int reg)\n{\n\tstruct ni_private *devpriv = dev->private;\n\n\tif (devpriv->is_m_series) {\n\t\tm_series_stc_write(dev, data, reg);\n\t} else {\n\t\tni_stc_writew(dev, data >> 16, reg);\n\t\tni_stc_writew(dev, data & 0xffff, reg + 1);\n\t}\n}\n\nstatic unsigned int ni_stc_readw(struct comedi_device *dev, int reg)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tunsigned long flags;\n\tunsigned int val;\n\n\tif (devpriv->is_m_series) {\n\t\tval = m_series_stc_read(dev, reg);\n\t} else {\n\t\tspin_lock_irqsave(&devpriv->window_lock, flags);\n\t\tif (!devpriv->mite && reg < 8) {\n\t\t\tval = ni_readw(dev, reg * 2);\n\t\t} else {\n\t\t\tni_writew(dev, reg, NI_E_STC_WINDOW_ADDR_REG);\n\t\t\tval = ni_readw(dev, NI_E_STC_WINDOW_DATA_REG);\n\t\t}\n\t\tspin_unlock_irqrestore(&devpriv->window_lock, flags);\n\t}\n\treturn val;\n}\n\nstatic unsigned int ni_stc_readl(struct comedi_device *dev, int reg)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tunsigned int val;\n\n\tif (devpriv->is_m_series) {\n\t\tval = m_series_stc_read(dev, reg);\n\t} else {\n\t\tval = ni_stc_readw(dev, reg) << 16;\n\t\tval |= ni_stc_readw(dev, reg + 1);\n\t}\n\treturn val;\n}\n\nstatic inline void ni_set_bitfield(struct comedi_device *dev, int reg,\n\t\t\t\t   unsigned int bit_mask,\n\t\t\t\t   unsigned int bit_values)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&devpriv->soft_reg_copy_lock, flags);\n\tswitch (reg) {\n\tcase NISTC_INTA_ENA_REG:\n\t\tdevpriv->int_a_enable_reg &= ~bit_mask;\n\t\tdevpriv->int_a_enable_reg |= bit_values & bit_mask;\n\t\tni_stc_writew(dev, devpriv->int_a_enable_reg, reg);\n\t\tbreak;\n\tcase NISTC_INTB_ENA_REG:\n\t\tdevpriv->int_b_enable_reg &= ~bit_mask;\n\t\tdevpriv->int_b_enable_reg |= bit_values & bit_mask;\n\t\tni_stc_writew(dev, devpriv->int_b_enable_reg, reg);\n\t\tbreak;\n\tcase NISTC_IO_BIDIR_PIN_REG:\n\t\tdevpriv->io_bidirection_pin_reg &= ~bit_mask;\n\t\tdevpriv->io_bidirection_pin_reg |= bit_values & bit_mask;\n\t\tni_stc_writew(dev, devpriv->io_bidirection_pin_reg, reg);\n\t\tbreak;\n\tcase NI_E_DMA_AI_AO_SEL_REG:\n\t\tdevpriv->ai_ao_select_reg &= ~bit_mask;\n\t\tdevpriv->ai_ao_select_reg |= bit_values & bit_mask;\n\t\tni_writeb(dev, devpriv->ai_ao_select_reg, reg);\n\t\tbreak;\n\tcase NI_E_DMA_G0_G1_SEL_REG:\n\t\tdevpriv->g0_g1_select_reg &= ~bit_mask;\n\t\tdevpriv->g0_g1_select_reg |= bit_values & bit_mask;\n\t\tni_writeb(dev, devpriv->g0_g1_select_reg, reg);\n\t\tbreak;\n\tcase NI_M_CDIO_DMA_SEL_REG:\n\t\tdevpriv->cdio_dma_select_reg &= ~bit_mask;\n\t\tdevpriv->cdio_dma_select_reg |= bit_values & bit_mask;\n\t\tni_writeb(dev, devpriv->cdio_dma_select_reg, reg);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev->class_dev, \"called with invalid register %d\\n\",\n\t\t\treg);\n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&devpriv->soft_reg_copy_lock, flags);\n}\n\n#ifdef PCIDMA\n\n \n#define NI_STC_DMA_CHAN_SEL(x)\t(((x) < 4) ? BIT(x) :\t\\\n\t\t\t\t ((x) == 4) ? 0x3 :\t\\\n\t\t\t\t ((x) == 5) ? 0x5 : 0x0)\n\n \nstatic int ni_request_ai_mite_channel(struct comedi_device *dev)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tstruct mite_channel *mite_chan;\n\tunsigned long flags;\n\tunsigned int bits;\n\n\tspin_lock_irqsave(&devpriv->mite_channel_lock, flags);\n\tmite_chan = mite_request_channel(devpriv->mite, devpriv->ai_mite_ring);\n\tif (!mite_chan) {\n\t\tspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\n\t\tdev_err(dev->class_dev,\n\t\t\t\"failed to reserve mite dma channel for analog input\\n\");\n\t\treturn -EBUSY;\n\t}\n\tmite_chan->dir = COMEDI_INPUT;\n\tdevpriv->ai_mite_chan = mite_chan;\n\n\tbits = NI_STC_DMA_CHAN_SEL(mite_chan->channel);\n\tni_set_bitfield(dev, NI_E_DMA_AI_AO_SEL_REG,\n\t\t\tNI_E_DMA_AI_SEL_MASK, NI_E_DMA_AI_SEL(bits));\n\n\tspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\n\treturn 0;\n}\n\nstatic int ni_request_ao_mite_channel(struct comedi_device *dev)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tstruct mite_channel *mite_chan;\n\tunsigned long flags;\n\tunsigned int bits;\n\n\tspin_lock_irqsave(&devpriv->mite_channel_lock, flags);\n\tmite_chan = mite_request_channel(devpriv->mite, devpriv->ao_mite_ring);\n\tif (!mite_chan) {\n\t\tspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\n\t\tdev_err(dev->class_dev,\n\t\t\t\"failed to reserve mite dma channel for analog output\\n\");\n\t\treturn -EBUSY;\n\t}\n\tmite_chan->dir = COMEDI_OUTPUT;\n\tdevpriv->ao_mite_chan = mite_chan;\n\n\tbits = NI_STC_DMA_CHAN_SEL(mite_chan->channel);\n\tni_set_bitfield(dev, NI_E_DMA_AI_AO_SEL_REG,\n\t\t\tNI_E_DMA_AO_SEL_MASK, NI_E_DMA_AO_SEL(bits));\n\n\tspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\n\treturn 0;\n}\n\nstatic int ni_request_gpct_mite_channel(struct comedi_device *dev,\n\t\t\t\t\tunsigned int gpct_index,\n\t\t\t\t\tenum comedi_io_direction direction)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tstruct ni_gpct *counter = &devpriv->counter_dev->counters[gpct_index];\n\tstruct mite_channel *mite_chan;\n\tunsigned long flags;\n\tunsigned int bits;\n\n\tspin_lock_irqsave(&devpriv->mite_channel_lock, flags);\n\tmite_chan = mite_request_channel(devpriv->mite,\n\t\t\t\t\t devpriv->gpct_mite_ring[gpct_index]);\n\tif (!mite_chan) {\n\t\tspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\n\t\tdev_err(dev->class_dev,\n\t\t\t\"failed to reserve mite dma channel for counter\\n\");\n\t\treturn -EBUSY;\n\t}\n\tmite_chan->dir = direction;\n\tni_tio_set_mite_channel(counter, mite_chan);\n\n\tbits = NI_STC_DMA_CHAN_SEL(mite_chan->channel);\n\tni_set_bitfield(dev, NI_E_DMA_G0_G1_SEL_REG,\n\t\t\tNI_E_DMA_G0_G1_SEL_MASK(gpct_index),\n\t\t\tNI_E_DMA_G0_G1_SEL(gpct_index, bits));\n\n\tspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\n\treturn 0;\n}\n\nstatic int ni_request_cdo_mite_channel(struct comedi_device *dev)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tstruct mite_channel *mite_chan;\n\tunsigned long flags;\n\tunsigned int bits;\n\n\tspin_lock_irqsave(&devpriv->mite_channel_lock, flags);\n\tmite_chan = mite_request_channel(devpriv->mite, devpriv->cdo_mite_ring);\n\tif (!mite_chan) {\n\t\tspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\n\t\tdev_err(dev->class_dev,\n\t\t\t\"failed to reserve mite dma channel for correlated digital output\\n\");\n\t\treturn -EBUSY;\n\t}\n\tmite_chan->dir = COMEDI_OUTPUT;\n\tdevpriv->cdo_mite_chan = mite_chan;\n\n\t \n\tbits = NI_STC_DMA_CHAN_SEL(mite_chan->channel);\n\tni_set_bitfield(dev, NI_M_CDIO_DMA_SEL_REG,\n\t\t\tNI_M_CDIO_DMA_SEL_CDO_MASK,\n\t\t\tNI_M_CDIO_DMA_SEL_CDO(bits));\n\n\tspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\n\treturn 0;\n}\n#endif  \n\nstatic void ni_release_ai_mite_channel(struct comedi_device *dev)\n{\n#ifdef PCIDMA\n\tstruct ni_private *devpriv = dev->private;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&devpriv->mite_channel_lock, flags);\n\tif (devpriv->ai_mite_chan) {\n\t\tni_set_bitfield(dev, NI_E_DMA_AI_AO_SEL_REG,\n\t\t\t\tNI_E_DMA_AI_SEL_MASK, 0);\n\t\tmite_release_channel(devpriv->ai_mite_chan);\n\t\tdevpriv->ai_mite_chan = NULL;\n\t}\n\tspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\n#endif  \n}\n\nstatic void ni_release_ao_mite_channel(struct comedi_device *dev)\n{\n#ifdef PCIDMA\n\tstruct ni_private *devpriv = dev->private;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&devpriv->mite_channel_lock, flags);\n\tif (devpriv->ao_mite_chan) {\n\t\tni_set_bitfield(dev, NI_E_DMA_AI_AO_SEL_REG,\n\t\t\t\tNI_E_DMA_AO_SEL_MASK, 0);\n\t\tmite_release_channel(devpriv->ao_mite_chan);\n\t\tdevpriv->ao_mite_chan = NULL;\n\t}\n\tspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\n#endif  \n}\n\n#ifdef PCIDMA\nstatic void ni_release_gpct_mite_channel(struct comedi_device *dev,\n\t\t\t\t\t unsigned int gpct_index)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&devpriv->mite_channel_lock, flags);\n\tif (devpriv->counter_dev->counters[gpct_index].mite_chan) {\n\t\tstruct mite_channel *mite_chan =\n\t\t    devpriv->counter_dev->counters[gpct_index].mite_chan;\n\n\t\tni_set_bitfield(dev, NI_E_DMA_G0_G1_SEL_REG,\n\t\t\t\tNI_E_DMA_G0_G1_SEL_MASK(gpct_index), 0);\n\t\tni_tio_set_mite_channel(&devpriv->counter_dev->counters[gpct_index],\n\t\t\t\t\tNULL);\n\t\tmite_release_channel(mite_chan);\n\t}\n\tspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\n}\n\nstatic void ni_release_cdo_mite_channel(struct comedi_device *dev)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&devpriv->mite_channel_lock, flags);\n\tif (devpriv->cdo_mite_chan) {\n\t\tni_set_bitfield(dev, NI_M_CDIO_DMA_SEL_REG,\n\t\t\t\tNI_M_CDIO_DMA_SEL_CDO_MASK, 0);\n\t\tmite_release_channel(devpriv->cdo_mite_chan);\n\t\tdevpriv->cdo_mite_chan = NULL;\n\t}\n\tspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\n}\n\nstatic void ni_e_series_enable_second_irq(struct comedi_device *dev,\n\t\t\t\t\t  unsigned int gpct_index, short enable)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tunsigned int val = 0;\n\tint reg;\n\n\tif (devpriv->is_m_series || gpct_index > 1)\n\t\treturn;\n\n\t \n\tif (gpct_index == 0) {\n\t\treg = NISTC_INTA2_ENA_REG;\n\t\tif (enable)\n\t\t\tval = NISTC_INTA_ENA_G0_GATE;\n\t} else {\n\t\treg = NISTC_INTB2_ENA_REG;\n\t\tif (enable)\n\t\t\tval = NISTC_INTB_ENA_G1_GATE;\n\t}\n\tni_stc_writew(dev, val, reg);\n}\n#endif  \n\nstatic void ni_clear_ai_fifo(struct comedi_device *dev)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tstatic const int timeout = 10000;\n\tint i;\n\n\tif (devpriv->is_6143) {\n\t\t \n\t\tni_writel(dev, 0x10, NI6143_AI_FIFO_CTRL_REG);\n\t\tni_writel(dev, 0x00, NI6143_AI_FIFO_CTRL_REG);\n\t\t \n\t\tfor (i = 0; i < timeout; i++) {\n\t\t\tif (!(ni_readl(dev, NI6143_AI_FIFO_STATUS_REG) & 0x10))\n\t\t\t\tbreak;\n\t\t\tudelay(1);\n\t\t}\n\t\tif (i == timeout)\n\t\t\tdev_err(dev->class_dev, \"FIFO flush timeout\\n\");\n\t} else {\n\t\tni_stc_writew(dev, 1, NISTC_ADC_FIFO_CLR_REG);\n\t\tif (devpriv->is_625x) {\n\t\t\tni_writeb(dev, 0, NI_M_STATIC_AI_CTRL_REG(0));\n\t\t\tni_writeb(dev, 1, NI_M_STATIC_AI_CTRL_REG(0));\n#if 0\n\t\t\t \n\t\t\tni_stc_writew(dev, NISTC_AI_CMD1_CONVERT_PULSE,\n\t\t\t\t      NISTC_AI_CMD1_REG);\n\t\t\tni_stc_writew(dev, NISTC_AI_CMD1_CONVERT_PULSE,\n\t\t\t\t      NISTC_AI_CMD1_REG);\n\t\t\tni_stc_writew(dev, NISTC_AI_CMD1_CONVERT_PULSE,\n\t\t\t\t      NISTC_AI_CMD1_REG);\n#endif\n\t\t}\n\t}\n}\n\nstatic inline void ni_ao_win_outw(struct comedi_device *dev,\n\t\t\t\t  unsigned int data, int addr)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&devpriv->window_lock, flags);\n\tni_writew(dev, addr, NI611X_AO_WINDOW_ADDR_REG);\n\tni_writew(dev, data, NI611X_AO_WINDOW_DATA_REG);\n\tspin_unlock_irqrestore(&devpriv->window_lock, flags);\n}\n\nstatic inline void ni_ao_win_outl(struct comedi_device *dev,\n\t\t\t\t  unsigned int data, int addr)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&devpriv->window_lock, flags);\n\tni_writew(dev, addr, NI611X_AO_WINDOW_ADDR_REG);\n\tni_writel(dev, data, NI611X_AO_WINDOW_DATA_REG);\n\tspin_unlock_irqrestore(&devpriv->window_lock, flags);\n}\n\nstatic inline unsigned short ni_ao_win_inw(struct comedi_device *dev, int addr)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tunsigned long flags;\n\tunsigned short data;\n\n\tspin_lock_irqsave(&devpriv->window_lock, flags);\n\tni_writew(dev, addr, NI611X_AO_WINDOW_ADDR_REG);\n\tdata = ni_readw(dev, NI611X_AO_WINDOW_DATA_REG);\n\tspin_unlock_irqrestore(&devpriv->window_lock, flags);\n\treturn data;\n}\n\n \nstatic inline void ni_set_bits(struct comedi_device *dev, int reg,\n\t\t\t       unsigned int bits, unsigned int value)\n{\n\tunsigned int bit_values;\n\n\tif (value)\n\t\tbit_values = bits;\n\telse\n\t\tbit_values = 0;\n\tni_set_bitfield(dev, reg, bits, bit_values);\n}\n\n#ifdef PCIDMA\nstatic void ni_sync_ai_dma(struct comedi_device *dev)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tstruct comedi_subdevice *s = dev->read_subdev;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&devpriv->mite_channel_lock, flags);\n\tif (devpriv->ai_mite_chan)\n\t\tmite_sync_dma(devpriv->ai_mite_chan, s);\n\tspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\n}\n\nstatic int ni_ai_drain_dma(struct comedi_device *dev)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tint i;\n\tstatic const int timeout = 10000;\n\tunsigned long flags;\n\tint retval = 0;\n\n\tspin_lock_irqsave(&devpriv->mite_channel_lock, flags);\n\tif (devpriv->ai_mite_chan) {\n\t\tfor (i = 0; i < timeout; i++) {\n\t\t\tif ((ni_stc_readw(dev, NISTC_AI_STATUS1_REG) &\n\t\t\t     NISTC_AI_STATUS1_FIFO_E) &&\n\t\t\t    mite_bytes_in_transit(devpriv->ai_mite_chan) == 0)\n\t\t\t\tbreak;\n\t\t\tudelay(5);\n\t\t}\n\t\tif (i == timeout) {\n\t\t\tdev_err(dev->class_dev, \"timed out\\n\");\n\t\t\tdev_err(dev->class_dev,\n\t\t\t\t\"mite_bytes_in_transit=%i, AI_Status1_Register=0x%x\\n\",\n\t\t\t\tmite_bytes_in_transit(devpriv->ai_mite_chan),\n\t\t\t\tni_stc_readw(dev, NISTC_AI_STATUS1_REG));\n\t\t\tretval = -1;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\n\n\tni_sync_ai_dma(dev);\n\n\treturn retval;\n}\n\nstatic int ni_ao_wait_for_dma_load(struct comedi_device *dev)\n{\n\tstatic const int timeout = 10000;\n\tint i;\n\n\tfor (i = 0; i < timeout; i++) {\n\t\tunsigned short b_status;\n\n\t\tb_status = ni_stc_readw(dev, NISTC_AO_STATUS1_REG);\n\t\tif (b_status & NISTC_AO_STATUS1_FIFO_HF)\n\t\t\tbreak;\n\t\t \n\t\tusleep_range(10, 100);\n\t}\n\tif (i == timeout) {\n\t\tdev_err(dev->class_dev, \"timed out waiting for dma load\\n\");\n\t\treturn -EPIPE;\n\t}\n\treturn 0;\n}\n#endif  \n\n#ifndef PCIDMA\n\nstatic void ni_ao_fifo_load(struct comedi_device *dev,\n\t\t\t    struct comedi_subdevice *s, int n)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tint i;\n\tunsigned short d;\n\tunsigned int packed_data;\n\n\tfor (i = 0; i < n; i++) {\n\t\tcomedi_buf_read_samples(s, &d, 1);\n\n\t\tif (devpriv->is_6xxx) {\n\t\t\tpacked_data = d & 0xffff;\n\t\t\t \n\t\t\tif (!devpriv->is_6711) {\n\t\t\t\tcomedi_buf_read_samples(s, &d, 1);\n\t\t\t\ti++;\n\t\t\t\tpacked_data |= (d << 16) & 0xffff0000;\n\t\t\t}\n\t\t\tni_writel(dev, packed_data, NI611X_AO_FIFO_DATA_REG);\n\t\t} else {\n\t\t\tni_writew(dev, d, NI_E_AO_FIFO_DATA_REG);\n\t\t}\n\t}\n}\n\n \nstatic int ni_ao_fifo_half_empty(struct comedi_device *dev,\n\t\t\t\t struct comedi_subdevice *s)\n{\n\tconst struct ni_board_struct *board = dev->board_ptr;\n\tunsigned int nbytes;\n\tunsigned int nsamples;\n\n\tnbytes = comedi_buf_read_n_available(s);\n\tif (nbytes == 0) {\n\t\ts->async->events |= COMEDI_CB_OVERFLOW;\n\t\treturn 0;\n\t}\n\n\tnsamples = comedi_bytes_to_samples(s, nbytes);\n\tif (nsamples > board->ao_fifo_depth / 2)\n\t\tnsamples = board->ao_fifo_depth / 2;\n\n\tni_ao_fifo_load(dev, s, nsamples);\n\n\treturn 1;\n}\n\nstatic int ni_ao_prep_fifo(struct comedi_device *dev,\n\t\t\t   struct comedi_subdevice *s)\n{\n\tconst struct ni_board_struct *board = dev->board_ptr;\n\tstruct ni_private *devpriv = dev->private;\n\tunsigned int nbytes;\n\tunsigned int nsamples;\n\n\t \n\tni_stc_writew(dev, 1, NISTC_DAC_FIFO_CLR_REG);\n\tif (devpriv->is_6xxx)\n\t\tni_ao_win_outl(dev, 0x6, NI611X_AO_FIFO_OFFSET_LOAD_REG);\n\n\t \n\tnbytes = comedi_buf_read_n_available(s);\n\tif (nbytes == 0)\n\t\treturn 0;\n\n\tnsamples = comedi_bytes_to_samples(s, nbytes);\n\tif (nsamples > board->ao_fifo_depth)\n\t\tnsamples = board->ao_fifo_depth;\n\n\tni_ao_fifo_load(dev, s, nsamples);\n\n\treturn nsamples;\n}\n\nstatic void ni_ai_fifo_read(struct comedi_device *dev,\n\t\t\t    struct comedi_subdevice *s, int n)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tstruct comedi_async *async = s->async;\n\tunsigned int dl;\n\tunsigned short data;\n\tint i;\n\n\tif (devpriv->is_611x) {\n\t\tfor (i = 0; i < n / 2; i++) {\n\t\t\tdl = ni_readl(dev, NI611X_AI_FIFO_DATA_REG);\n\t\t\t \n\t\t\tdata = (dl >> 16) & 0xffff;\n\t\t\tcomedi_buf_write_samples(s, &data, 1);\n\t\t\tdata = dl & 0xffff;\n\t\t\tcomedi_buf_write_samples(s, &data, 1);\n\t\t}\n\t\t \n\t\tif (n % 2) {\n\t\t\tdl = ni_readl(dev, NI611X_AI_FIFO_DATA_REG);\n\t\t\tdata = dl & 0xffff;\n\t\t\tcomedi_buf_write_samples(s, &data, 1);\n\t\t}\n\t} else if (devpriv->is_6143) {\n\t\t \n\t\tfor (i = 0; i < n / 2; i++) {\n\t\t\tdl = ni_readl(dev, NI6143_AI_FIFO_DATA_REG);\n\n\t\t\tdata = (dl >> 16) & 0xffff;\n\t\t\tcomedi_buf_write_samples(s, &data, 1);\n\t\t\tdata = dl & 0xffff;\n\t\t\tcomedi_buf_write_samples(s, &data, 1);\n\t\t}\n\t\tif (n % 2) {\n\t\t\t \n\t\t\t \n\t\t\tni_writel(dev, 0x01, NI6143_AI_FIFO_CTRL_REG);\n\t\t\tdl = ni_readl(dev, NI6143_AI_FIFO_DATA_REG);\n\t\t\tdata = (dl >> 16) & 0xffff;\n\t\t\tcomedi_buf_write_samples(s, &data, 1);\n\t\t}\n\t} else {\n\t\tif (n > ARRAY_SIZE(devpriv->ai_fifo_buffer)) {\n\t\t\tdev_err(dev->class_dev,\n\t\t\t\t\"bug! ai_fifo_buffer too small\\n\");\n\t\t\tasync->events |= COMEDI_CB_ERROR;\n\t\t\treturn;\n\t\t}\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tdevpriv->ai_fifo_buffer[i] =\n\t\t\t    ni_readw(dev, NI_E_AI_FIFO_DATA_REG);\n\t\t}\n\t\tcomedi_buf_write_samples(s, devpriv->ai_fifo_buffer, n);\n\t}\n}\n\nstatic void ni_handle_fifo_half_full(struct comedi_device *dev)\n{\n\tconst struct ni_board_struct *board = dev->board_ptr;\n\tstruct comedi_subdevice *s = dev->read_subdev;\n\tint n;\n\n\tn = board->ai_fifo_depth / 2;\n\n\tni_ai_fifo_read(dev, s, n);\n}\n#endif\n\n \nstatic void ni_handle_fifo_dregs(struct comedi_device *dev)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tstruct comedi_subdevice *s = dev->read_subdev;\n\tunsigned int dl;\n\tunsigned short data;\n\tint i;\n\n\tif (devpriv->is_611x) {\n\t\twhile ((ni_stc_readw(dev, NISTC_AI_STATUS1_REG) &\n\t\t\tNISTC_AI_STATUS1_FIFO_E) == 0) {\n\t\t\tdl = ni_readl(dev, NI611X_AI_FIFO_DATA_REG);\n\n\t\t\t \n\t\t\tdata = dl >> 16;\n\t\t\tcomedi_buf_write_samples(s, &data, 1);\n\t\t\tdata = dl & 0xffff;\n\t\t\tcomedi_buf_write_samples(s, &data, 1);\n\t\t}\n\t} else if (devpriv->is_6143) {\n\t\ti = 0;\n\t\twhile (ni_readl(dev, NI6143_AI_FIFO_STATUS_REG) & 0x04) {\n\t\t\tdl = ni_readl(dev, NI6143_AI_FIFO_DATA_REG);\n\n\t\t\t \n\t\t\tdata = dl >> 16;\n\t\t\tcomedi_buf_write_samples(s, &data, 1);\n\t\t\tdata = dl & 0xffff;\n\t\t\tcomedi_buf_write_samples(s, &data, 1);\n\t\t\ti += 2;\n\t\t}\n\t\t \n\t\tif (ni_readl(dev, NI6143_AI_FIFO_STATUS_REG) & 0x01) {\n\t\t\t \n\t\t\tni_writel(dev, 0x01, NI6143_AI_FIFO_CTRL_REG);\n\t\t\tdl = ni_readl(dev, NI6143_AI_FIFO_DATA_REG);\n\t\t\tdata = (dl >> 16) & 0xffff;\n\t\t\tcomedi_buf_write_samples(s, &data, 1);\n\t\t}\n\n\t} else {\n\t\tunsigned short fe;\t \n\n\t\tfe = ni_stc_readw(dev, NISTC_AI_STATUS1_REG) &\n\t\t     NISTC_AI_STATUS1_FIFO_E;\n\t\twhile (fe == 0) {\n\t\t\tfor (i = 0;\n\t\t\t     i < ARRAY_SIZE(devpriv->ai_fifo_buffer); i++) {\n\t\t\t\tfe = ni_stc_readw(dev, NISTC_AI_STATUS1_REG) &\n\t\t\t\t     NISTC_AI_STATUS1_FIFO_E;\n\t\t\t\tif (fe)\n\t\t\t\t\tbreak;\n\t\t\t\tdevpriv->ai_fifo_buffer[i] =\n\t\t\t\t    ni_readw(dev, NI_E_AI_FIFO_DATA_REG);\n\t\t\t}\n\t\t\tcomedi_buf_write_samples(s, devpriv->ai_fifo_buffer, i);\n\t\t}\n\t}\n}\n\nstatic void get_last_sample_611x(struct comedi_device *dev)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tstruct comedi_subdevice *s = dev->read_subdev;\n\tunsigned short data;\n\tunsigned int dl;\n\n\tif (!devpriv->is_611x)\n\t\treturn;\n\n\t \n\tif (ni_readb(dev, NI_E_STATUS_REG) & 0x80) {\n\t\tdl = ni_readl(dev, NI611X_AI_FIFO_DATA_REG);\n\t\tdata = dl & 0xffff;\n\t\tcomedi_buf_write_samples(s, &data, 1);\n\t}\n}\n\nstatic void get_last_sample_6143(struct comedi_device *dev)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tstruct comedi_subdevice *s = dev->read_subdev;\n\tunsigned short data;\n\tunsigned int dl;\n\n\tif (!devpriv->is_6143)\n\t\treturn;\n\n\t \n\tif (ni_readl(dev, NI6143_AI_FIFO_STATUS_REG) & 0x01) {\n\t\t \n\t\tni_writel(dev, 0x01, NI6143_AI_FIFO_CTRL_REG);\n\t\tdl = ni_readl(dev, NI6143_AI_FIFO_DATA_REG);\n\n\t\t \n\t\tdata = (dl >> 16) & 0xffff;\n\t\tcomedi_buf_write_samples(s, &data, 1);\n\t}\n}\n\nstatic void shutdown_ai_command(struct comedi_device *dev)\n{\n\tstruct comedi_subdevice *s = dev->read_subdev;\n\n#ifdef PCIDMA\n\tni_ai_drain_dma(dev);\n#endif\n\tni_handle_fifo_dregs(dev);\n\tget_last_sample_611x(dev);\n\tget_last_sample_6143(dev);\n\n\ts->async->events |= COMEDI_CB_EOA;\n}\n\nstatic void ni_handle_eos(struct comedi_device *dev, struct comedi_subdevice *s)\n{\n\tstruct ni_private *devpriv = dev->private;\n\n\tif (devpriv->aimode == AIMODE_SCAN) {\n#ifdef PCIDMA\n\t\tstatic const int timeout = 10;\n\t\tint i;\n\n\t\tfor (i = 0; i < timeout; i++) {\n\t\t\tni_sync_ai_dma(dev);\n\t\t\tif ((s->async->events & COMEDI_CB_EOS))\n\t\t\t\tbreak;\n\t\t\tudelay(1);\n\t\t}\n#else\n\t\tni_handle_fifo_dregs(dev);\n\t\ts->async->events |= COMEDI_CB_EOS;\n#endif\n\t}\n\t \n\tif (devpriv->ai_cmd2 & NISTC_AI_CMD2_END_ON_EOS)\n\t\tshutdown_ai_command(dev);\n}\n\nstatic void handle_gpct_interrupt(struct comedi_device *dev,\n\t\t\t\t  unsigned short counter_index)\n{\n#ifdef PCIDMA\n\tstruct ni_private *devpriv = dev->private;\n\tstruct comedi_subdevice *s;\n\n\ts = &dev->subdevices[NI_GPCT_SUBDEV(counter_index)];\n\n\tni_tio_handle_interrupt(&devpriv->counter_dev->counters[counter_index],\n\t\t\t\ts);\n\tcomedi_handle_events(dev, s);\n#endif\n}\n\nstatic void ack_a_interrupt(struct comedi_device *dev, unsigned short a_status)\n{\n\tunsigned short ack = 0;\n\n\tif (a_status & NISTC_AI_STATUS1_SC_TC)\n\t\tack |= NISTC_INTA_ACK_AI_SC_TC;\n\tif (a_status & NISTC_AI_STATUS1_START1)\n\t\tack |= NISTC_INTA_ACK_AI_START1;\n\tif (a_status & NISTC_AI_STATUS1_START)\n\t\tack |= NISTC_INTA_ACK_AI_START;\n\tif (a_status & NISTC_AI_STATUS1_STOP)\n\t\tack |= NISTC_INTA_ACK_AI_STOP;\n\tif (a_status & NISTC_AI_STATUS1_OVER)\n\t\tack |= NISTC_INTA_ACK_AI_ERR;\n\tif (ack)\n\t\tni_stc_writew(dev, ack, NISTC_INTA_ACK_REG);\n}\n\nstatic void handle_a_interrupt(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       unsigned short status)\n{\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\n\t \n\tif (status & (NISTC_AI_STATUS1_ERR |\n\t\t      NISTC_AI_STATUS1_SC_TC | NISTC_AI_STATUS1_START1)) {\n\t\tif (status == 0xffff) {\n\t\t\tdev_err(dev->class_dev, \"Card removed?\\n\");\n\t\t\t \n\t\t\tif (comedi_is_subdevice_running(s))\n\t\t\t\ts->async->events |= COMEDI_CB_ERROR;\n\t\t\treturn;\n\t\t}\n\t\tif (status & NISTC_AI_STATUS1_ERR) {\n\t\t\tdev_err(dev->class_dev, \"ai error a_status=%04x\\n\",\n\t\t\t\tstatus);\n\n\t\t\tshutdown_ai_command(dev);\n\n\t\t\ts->async->events |= COMEDI_CB_ERROR;\n\t\t\tif (status & NISTC_AI_STATUS1_OVER)\n\t\t\t\ts->async->events |= COMEDI_CB_OVERFLOW;\n\t\t\treturn;\n\t\t}\n\t\tif (status & NISTC_AI_STATUS1_SC_TC) {\n\t\t\tif (cmd->stop_src == TRIG_COUNT)\n\t\t\t\tshutdown_ai_command(dev);\n\t\t}\n\t}\n#ifndef PCIDMA\n\tif (status & NISTC_AI_STATUS1_FIFO_HF) {\n\t\tint i;\n\t\tstatic const int timeout = 10;\n\t\t \n\t\tfor (i = 0; i < timeout; ++i) {\n\t\t\tni_handle_fifo_half_full(dev);\n\t\t\tif ((ni_stc_readw(dev, NISTC_AI_STATUS1_REG) &\n\t\t\t     NISTC_AI_STATUS1_FIFO_HF) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n#endif  \n\n\tif (status & NISTC_AI_STATUS1_STOP)\n\t\tni_handle_eos(dev, s);\n}\n\nstatic void ack_b_interrupt(struct comedi_device *dev, unsigned short b_status)\n{\n\tunsigned short ack = 0;\n\n\tif (b_status & NISTC_AO_STATUS1_BC_TC)\n\t\tack |= NISTC_INTB_ACK_AO_BC_TC;\n\tif (b_status & NISTC_AO_STATUS1_OVERRUN)\n\t\tack |= NISTC_INTB_ACK_AO_ERR;\n\tif (b_status & NISTC_AO_STATUS1_START)\n\t\tack |= NISTC_INTB_ACK_AO_START;\n\tif (b_status & NISTC_AO_STATUS1_START1)\n\t\tack |= NISTC_INTB_ACK_AO_START1;\n\tif (b_status & NISTC_AO_STATUS1_UC_TC)\n\t\tack |= NISTC_INTB_ACK_AO_UC_TC;\n\tif (b_status & NISTC_AO_STATUS1_UI2_TC)\n\t\tack |= NISTC_INTB_ACK_AO_UI2_TC;\n\tif (b_status & NISTC_AO_STATUS1_UPDATE)\n\t\tack |= NISTC_INTB_ACK_AO_UPDATE;\n\tif (ack)\n\t\tni_stc_writew(dev, ack, NISTC_INTB_ACK_REG);\n}\n\nstatic void handle_b_interrupt(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       unsigned short b_status)\n{\n\tif (b_status == 0xffff)\n\t\treturn;\n\tif (b_status & NISTC_AO_STATUS1_OVERRUN) {\n\t\tdev_err(dev->class_dev,\n\t\t\t\"AO FIFO underrun status=0x%04x status2=0x%04x\\n\",\n\t\t\tb_status, ni_stc_readw(dev, NISTC_AO_STATUS2_REG));\n\t\ts->async->events |= COMEDI_CB_OVERFLOW;\n\t}\n\n\tif (s->async->cmd.stop_src != TRIG_NONE &&\n\t    b_status & NISTC_AO_STATUS1_BC_TC)\n\t\ts->async->events |= COMEDI_CB_EOA;\n\n#ifndef PCIDMA\n\tif (b_status & NISTC_AO_STATUS1_FIFO_REQ) {\n\t\tint ret;\n\n\t\tret = ni_ao_fifo_half_empty(dev, s);\n\t\tif (!ret) {\n\t\t\tdev_err(dev->class_dev, \"AO buffer underrun\\n\");\n\t\t\tni_set_bits(dev, NISTC_INTB_ENA_REG,\n\t\t\t\t    NISTC_INTB_ENA_AO_FIFO |\n\t\t\t\t    NISTC_INTB_ENA_AO_ERR, 0);\n\t\t\ts->async->events |= COMEDI_CB_OVERFLOW;\n\t\t}\n\t}\n#endif\n}\n\nstatic void ni_ai_munge(struct comedi_device *dev, struct comedi_subdevice *s,\n\t\t\tvoid *data, unsigned int num_bytes,\n\t\t\tunsigned int chan_index)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tstruct comedi_async *async = s->async;\n\tstruct comedi_cmd *cmd = &async->cmd;\n\tunsigned int nsamples = comedi_bytes_to_samples(s, num_bytes);\n\tunsigned short *array = data;\n\tunsigned int *larray = data;\n\tunsigned int i;\n#ifdef PCIDMA\n\t__le16 *barray = data;\n\t__le32 *blarray = data;\n#endif\n\n\tfor (i = 0; i < nsamples; i++) {\n#ifdef PCIDMA\n\t\tif (s->subdev_flags & SDF_LSAMPL)\n\t\t\tlarray[i] = le32_to_cpu(blarray[i]);\n\t\telse\n\t\t\tarray[i] = le16_to_cpu(barray[i]);\n#endif\n\t\tif (s->subdev_flags & SDF_LSAMPL)\n\t\t\tlarray[i] += devpriv->ai_offset[chan_index];\n\t\telse\n\t\t\tarray[i] += devpriv->ai_offset[chan_index];\n\t\tchan_index++;\n\t\tchan_index %= cmd->chanlist_len;\n\t}\n}\n\n#ifdef PCIDMA\n\nstatic int ni_ai_setup_MITE_dma(struct comedi_device *dev)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tstruct comedi_subdevice *s = dev->read_subdev;\n\tint retval;\n\tunsigned long flags;\n\n\tretval = ni_request_ai_mite_channel(dev);\n\tif (retval)\n\t\treturn retval;\n\n\t \n\tcomedi_buf_write_alloc(s, s->async->prealloc_bufsz);\n\n\tspin_lock_irqsave(&devpriv->mite_channel_lock, flags);\n\tif (!devpriv->ai_mite_chan) {\n\t\tspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\n\t\treturn -EIO;\n\t}\n\n\tif (devpriv->is_611x || devpriv->is_6143)\n\t\tmite_prep_dma(devpriv->ai_mite_chan, 32, 16);\n\telse if (devpriv->is_628x)\n\t\tmite_prep_dma(devpriv->ai_mite_chan, 32, 32);\n\telse\n\t\tmite_prep_dma(devpriv->ai_mite_chan, 16, 16);\n\n\t \n\tmite_dma_arm(devpriv->ai_mite_chan);\n\tspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\n\n\treturn 0;\n}\n\nstatic int ni_ao_setup_MITE_dma(struct comedi_device *dev)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tstruct comedi_subdevice *s = dev->write_subdev;\n\tint retval;\n\tunsigned long flags;\n\n\tretval = ni_request_ao_mite_channel(dev);\n\tif (retval)\n\t\treturn retval;\n\n\t \n\tcomedi_buf_read_alloc(s, s->async->prealloc_bufsz);\n\n\tspin_lock_irqsave(&devpriv->mite_channel_lock, flags);\n\tif (devpriv->ao_mite_chan) {\n\t\tif (devpriv->is_611x || devpriv->is_6713) {\n\t\t\tmite_prep_dma(devpriv->ao_mite_chan, 32, 32);\n\t\t} else {\n\t\t\t \n\t\t\tmite_prep_dma(devpriv->ao_mite_chan, 16, 32);\n\t\t}\n\t\tmite_dma_arm(devpriv->ao_mite_chan);\n\t} else {\n\t\tretval = -EIO;\n\t}\n\tspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\n\n\treturn retval;\n}\n\n#endif  \n\n \nstatic int ni_ai_reset(struct comedi_device *dev, struct comedi_subdevice *s)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tunsigned int ai_personal;\n\tunsigned int ai_out_ctrl;\n\n\tni_release_ai_mite_channel(dev);\n\t \n\tni_stc_writew(dev, NISTC_RESET_AI_CFG_START | NISTC_RESET_AI,\n\t\t      NISTC_RESET_REG);\n\n\tni_set_bits(dev, NISTC_INTA_ENA_REG, NISTC_INTA_ENA_AI_MASK, 0);\n\n\tni_clear_ai_fifo(dev);\n\n\tif (!devpriv->is_6143)\n\t\tni_writeb(dev, NI_E_MISC_CMD_EXT_ATRIG, NI_E_MISC_CMD_REG);\n\n\tni_stc_writew(dev, NISTC_AI_CMD1_DISARM, NISTC_AI_CMD1_REG);\n\tni_stc_writew(dev, NISTC_AI_MODE1_START_STOP |\n\t\t\t   NISTC_AI_MODE1_RSVD\n\t\t\t     ,\n\t\t      NISTC_AI_MODE1_REG);\n\tni_stc_writew(dev, 0, NISTC_AI_MODE2_REG);\n\t \n\tni_stc_writew(dev, NISTC_AI_MODE3_FIFO_MODE_NE,\n\t\t      NISTC_AI_MODE3_REG);\n\n\tai_personal = NISTC_AI_PERSONAL_SHIFTIN_PW |\n\t\t      NISTC_AI_PERSONAL_SOC_POLARITY |\n\t\t      NISTC_AI_PERSONAL_LOCALMUX_CLK_PW;\n\tai_out_ctrl = NISTC_AI_OUT_CTRL_SCAN_IN_PROG_SEL(3) |\n\t\t      NISTC_AI_OUT_CTRL_EXTMUX_CLK_SEL(0) |\n\t\t      NISTC_AI_OUT_CTRL_LOCALMUX_CLK_SEL(2) |\n\t\t      NISTC_AI_OUT_CTRL_SC_TC_SEL(3);\n\tif (devpriv->is_611x) {\n\t\tai_out_ctrl |= NISTC_AI_OUT_CTRL_CONVERT_HIGH;\n\t} else if (devpriv->is_6143) {\n\t\tai_out_ctrl |= NISTC_AI_OUT_CTRL_CONVERT_LOW;\n\t} else {\n\t\tai_personal |= NISTC_AI_PERSONAL_CONVERT_PW;\n\t\tif (devpriv->is_622x)\n\t\t\tai_out_ctrl |= NISTC_AI_OUT_CTRL_CONVERT_HIGH;\n\t\telse\n\t\t\tai_out_ctrl |= NISTC_AI_OUT_CTRL_CONVERT_LOW;\n\t}\n\tni_stc_writew(dev, ai_personal, NISTC_AI_PERSONAL_REG);\n\tni_stc_writew(dev, ai_out_ctrl, NISTC_AI_OUT_CTRL_REG);\n\n\t \n\n\t \n\tni_stc_writew(dev, NISTC_INTA_ACK_AI_ALL, NISTC_INTA_ACK_REG);\n\n\tni_stc_writew(dev, NISTC_RESET_AI_CFG_END, NISTC_RESET_REG);\n\n\treturn 0;\n}\n\nstatic int ni_ai_poll(struct comedi_device *dev, struct comedi_subdevice *s)\n{\n\tunsigned long flags;\n\tint count;\n\n\t \n\tspin_lock_irqsave(&dev->spinlock, flags);\n#ifndef PCIDMA\n\tni_handle_fifo_dregs(dev);\n#else\n\tni_sync_ai_dma(dev);\n#endif\n\tcount = comedi_buf_n_bytes_ready(s);\n\tspin_unlock_irqrestore(&dev->spinlock, flags);\n\n\treturn count;\n}\n\nstatic void ni_prime_channelgain_list(struct comedi_device *dev)\n{\n\tint i;\n\n\tni_stc_writew(dev, NISTC_AI_CMD1_CONVERT_PULSE, NISTC_AI_CMD1_REG);\n\tfor (i = 0; i < NI_TIMEOUT; ++i) {\n\t\tif (!(ni_stc_readw(dev, NISTC_AI_STATUS1_REG) &\n\t\t      NISTC_AI_STATUS1_FIFO_E)) {\n\t\t\tni_stc_writew(dev, 1, NISTC_ADC_FIFO_CLR_REG);\n\t\t\treturn;\n\t\t}\n\t\tudelay(1);\n\t}\n\tdev_err(dev->class_dev, \"timeout loading channel/gain list\\n\");\n}\n\nstatic void ni_m_series_load_channelgain_list(struct comedi_device *dev,\n\t\t\t\t\t      unsigned int n_chan,\n\t\t\t\t\t      unsigned int *list)\n{\n\tconst struct ni_board_struct *board = dev->board_ptr;\n\tstruct ni_private *devpriv = dev->private;\n\tunsigned int chan, range, aref;\n\tunsigned int i;\n\tunsigned int dither;\n\tunsigned int range_code;\n\n\tni_stc_writew(dev, 1, NISTC_CFG_MEM_CLR_REG);\n\n\tif ((list[0] & CR_ALT_SOURCE)) {\n\t\tunsigned int bypass_bits;\n\n\t\tchan = CR_CHAN(list[0]);\n\t\trange = CR_RANGE(list[0]);\n\t\trange_code = ni_gainlkup[board->gainlkup][range];\n\t\tdither = (list[0] & CR_ALT_FILTER) != 0;\n\t\tbypass_bits = NI_M_CFG_BYPASS_FIFO |\n\t\t\t      NI_M_CFG_BYPASS_AI_CHAN(chan) |\n\t\t\t      NI_M_CFG_BYPASS_AI_GAIN(range_code) |\n\t\t\t      devpriv->ai_calib_source;\n\t\tif (dither)\n\t\t\tbypass_bits |= NI_M_CFG_BYPASS_AI_DITHER;\n\t\t \n\t\tbypass_bits |= NI_M_CFG_BYPASS_AI_POLARITY;\n\t\tni_writel(dev, bypass_bits, NI_M_CFG_BYPASS_FIFO_REG);\n\t} else {\n\t\tni_writel(dev, 0, NI_M_CFG_BYPASS_FIFO_REG);\n\t}\n\tfor (i = 0; i < n_chan; i++) {\n\t\tunsigned int config_bits = 0;\n\n\t\tchan = CR_CHAN(list[i]);\n\t\taref = CR_AREF(list[i]);\n\t\trange = CR_RANGE(list[i]);\n\t\tdither = (list[i] & CR_ALT_FILTER) != 0;\n\n\t\trange_code = ni_gainlkup[board->gainlkup][range];\n\t\tdevpriv->ai_offset[i] = 0;\n\t\tswitch (aref) {\n\t\tcase AREF_DIFF:\n\t\t\tconfig_bits |= NI_M_AI_CFG_CHAN_TYPE_DIFF;\n\t\t\tbreak;\n\t\tcase AREF_COMMON:\n\t\t\tconfig_bits |= NI_M_AI_CFG_CHAN_TYPE_COMMON;\n\t\t\tbreak;\n\t\tcase AREF_GROUND:\n\t\t\tconfig_bits |= NI_M_AI_CFG_CHAN_TYPE_GROUND;\n\t\t\tbreak;\n\t\tcase AREF_OTHER:\n\t\t\tbreak;\n\t\t}\n\t\tconfig_bits |= NI_M_AI_CFG_CHAN_SEL(chan);\n\t\tconfig_bits |= NI_M_AI_CFG_BANK_SEL(chan);\n\t\tconfig_bits |= NI_M_AI_CFG_GAIN(range_code);\n\t\tif (i == n_chan - 1)\n\t\t\tconfig_bits |= NI_M_AI_CFG_LAST_CHAN;\n\t\tif (dither)\n\t\t\tconfig_bits |= NI_M_AI_CFG_DITHER;\n\t\t \n\t\tconfig_bits |= NI_M_AI_CFG_POLARITY;\n\t\tni_writew(dev, config_bits, NI_M_AI_CFG_FIFO_DATA_REG);\n\t}\n\tni_prime_channelgain_list(dev);\n}\n\n \nstatic void ni_load_channelgain_list(struct comedi_device *dev,\n\t\t\t\t     struct comedi_subdevice *s,\n\t\t\t\t     unsigned int n_chan, unsigned int *list)\n{\n\tconst struct ni_board_struct *board = dev->board_ptr;\n\tstruct ni_private *devpriv = dev->private;\n\tunsigned int offset = (s->maxdata + 1) >> 1;\n\tunsigned int chan, range, aref;\n\tunsigned int i;\n\tunsigned int hi, lo;\n\tunsigned int dither;\n\n\tif (devpriv->is_m_series) {\n\t\tni_m_series_load_channelgain_list(dev, n_chan, list);\n\t\treturn;\n\t}\n\tif (n_chan == 1 && !devpriv->is_611x && !devpriv->is_6143) {\n\t\tif (devpriv->changain_state &&\n\t\t    devpriv->changain_spec == list[0]) {\n\t\t\t \n\t\t\treturn;\n\t\t}\n\t\tdevpriv->changain_state = 1;\n\t\tdevpriv->changain_spec = list[0];\n\t} else {\n\t\tdevpriv->changain_state = 0;\n\t}\n\n\tni_stc_writew(dev, 1, NISTC_CFG_MEM_CLR_REG);\n\n\t \n\tif (devpriv->is_6143) {\n\t\tif ((list[0] & CR_ALT_SOURCE) &&\n\t\t    !devpriv->ai_calib_source_enabled) {\n\t\t\t \n\t\t\tni_writew(dev, devpriv->ai_calib_source |\n\t\t\t\t       NI6143_CALIB_CHAN_RELAY_ON,\n\t\t\t\t  NI6143_CALIB_CHAN_REG);\n\t\t\tni_writew(dev, devpriv->ai_calib_source,\n\t\t\t\t  NI6143_CALIB_CHAN_REG);\n\t\t\tdevpriv->ai_calib_source_enabled = 1;\n\t\t\t \n\t\t\tmsleep_interruptible(100);\n\t\t} else if (!(list[0] & CR_ALT_SOURCE) &&\n\t\t\t   devpriv->ai_calib_source_enabled) {\n\t\t\t \n\t\t\tni_writew(dev, devpriv->ai_calib_source |\n\t\t\t\t       NI6143_CALIB_CHAN_RELAY_OFF,\n\t\t\t\t  NI6143_CALIB_CHAN_REG);\n\t\t\tni_writew(dev, devpriv->ai_calib_source,\n\t\t\t\t  NI6143_CALIB_CHAN_REG);\n\t\t\tdevpriv->ai_calib_source_enabled = 0;\n\t\t\t \n\t\t\tmsleep_interruptible(100);\n\t\t}\n\t}\n\n\tfor (i = 0; i < n_chan; i++) {\n\t\tif (!devpriv->is_6143 && (list[i] & CR_ALT_SOURCE))\n\t\t\tchan = devpriv->ai_calib_source;\n\t\telse\n\t\t\tchan = CR_CHAN(list[i]);\n\t\taref = CR_AREF(list[i]);\n\t\trange = CR_RANGE(list[i]);\n\t\tdither = (list[i] & CR_ALT_FILTER) != 0;\n\n\t\t \n\t\trange = ni_gainlkup[board->gainlkup][range];\n\t\tif (devpriv->is_611x)\n\t\t\tdevpriv->ai_offset[i] = offset;\n\t\telse\n\t\t\tdevpriv->ai_offset[i] = (range & 0x100) ? 0 : offset;\n\n\t\thi = 0;\n\t\tif ((list[i] & CR_ALT_SOURCE)) {\n\t\t\tif (devpriv->is_611x)\n\t\t\t\tni_writew(dev, CR_CHAN(list[i]) & 0x0003,\n\t\t\t\t\t  NI611X_CALIB_CHAN_SEL_REG);\n\t\t} else {\n\t\t\tif (devpriv->is_611x)\n\t\t\t\taref = AREF_DIFF;\n\t\t\telse if (devpriv->is_6143)\n\t\t\t\taref = AREF_OTHER;\n\t\t\tswitch (aref) {\n\t\t\tcase AREF_DIFF:\n\t\t\t\thi |= NI_E_AI_CFG_HI_TYPE_DIFF;\n\t\t\t\tbreak;\n\t\t\tcase AREF_COMMON:\n\t\t\t\thi |= NI_E_AI_CFG_HI_TYPE_COMMON;\n\t\t\t\tbreak;\n\t\t\tcase AREF_GROUND:\n\t\t\t\thi |= NI_E_AI_CFG_HI_TYPE_GROUND;\n\t\t\t\tbreak;\n\t\t\tcase AREF_OTHER:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\thi |= NI_E_AI_CFG_HI_CHAN(chan);\n\n\t\tni_writew(dev, hi, NI_E_AI_CFG_HI_REG);\n\n\t\tif (!devpriv->is_6143) {\n\t\t\tlo = NI_E_AI_CFG_LO_GAIN(range);\n\n\t\t\tif (i == n_chan - 1)\n\t\t\t\tlo |= NI_E_AI_CFG_LO_LAST_CHAN;\n\t\t\tif (dither)\n\t\t\t\tlo |= NI_E_AI_CFG_LO_DITHER;\n\n\t\t\tni_writew(dev, lo, NI_E_AI_CFG_LO_REG);\n\t\t}\n\t}\n\n\t \n\tif (!devpriv->is_611x && !devpriv->is_6143)\n\t\tni_prime_channelgain_list(dev);\n}\n\nstatic int ni_ai_insn_read(struct comedi_device *dev,\n\t\t\t   struct comedi_subdevice *s,\n\t\t\t   struct comedi_insn *insn,\n\t\t\t   unsigned int *data)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tunsigned int mask = s->maxdata;\n\tint i, n;\n\tunsigned int signbits;\n\tunsigned int d;\n\n\tni_load_channelgain_list(dev, s, 1, &insn->chanspec);\n\n\tni_clear_ai_fifo(dev);\n\n\tsignbits = devpriv->ai_offset[0];\n\tif (devpriv->is_611x) {\n\t\tfor (n = 0; n < num_adc_stages_611x; n++) {\n\t\t\tni_stc_writew(dev, NISTC_AI_CMD1_CONVERT_PULSE,\n\t\t\t\t      NISTC_AI_CMD1_REG);\n\t\t\tudelay(1);\n\t\t}\n\t\tfor (n = 0; n < insn->n; n++) {\n\t\t\tni_stc_writew(dev, NISTC_AI_CMD1_CONVERT_PULSE,\n\t\t\t\t      NISTC_AI_CMD1_REG);\n\t\t\t \n\t\t\td = 0;\n\t\t\tfor (i = 0; i < NI_TIMEOUT; i++) {\n\t\t\t\tif (ni_readb(dev, NI_E_STATUS_REG) & 0x80) {\n\t\t\t\t\td = ni_readl(dev,\n\t\t\t\t\t\t     NI611X_AI_FIFO_DATA_REG);\n\t\t\t\t\td >>= 16;\n\t\t\t\t\td &= 0xffff;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!(ni_stc_readw(dev, NISTC_AI_STATUS1_REG) &\n\t\t\t\t      NISTC_AI_STATUS1_FIFO_E)) {\n\t\t\t\t\td = ni_readl(dev,\n\t\t\t\t\t\t     NI611X_AI_FIFO_DATA_REG);\n\t\t\t\t\td &= 0xffff;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == NI_TIMEOUT) {\n\t\t\t\tdev_err(dev->class_dev, \"timeout\\n\");\n\t\t\t\treturn -ETIME;\n\t\t\t}\n\t\t\td += signbits;\n\t\t\tdata[n] = d & 0xffff;\n\t\t}\n\t} else if (devpriv->is_6143) {\n\t\tfor (n = 0; n < insn->n; n++) {\n\t\t\tni_stc_writew(dev, NISTC_AI_CMD1_CONVERT_PULSE,\n\t\t\t\t      NISTC_AI_CMD1_REG);\n\n\t\t\t \n\t\t\td = 0;\n\t\t\tfor (i = 0; i < NI_TIMEOUT; i++) {\n\t\t\t\tif (ni_readl(dev, NI6143_AI_FIFO_STATUS_REG) &\n\t\t\t\t    0x01) {\n\t\t\t\t\t \n\t\t\t\t\tni_writel(dev, 0x01,\n\t\t\t\t\t\t  NI6143_AI_FIFO_CTRL_REG);\n\t\t\t\t\td = ni_readl(dev,\n\t\t\t\t\t\t     NI6143_AI_FIFO_DATA_REG);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == NI_TIMEOUT) {\n\t\t\t\tdev_err(dev->class_dev, \"timeout\\n\");\n\t\t\t\treturn -ETIME;\n\t\t\t}\n\t\t\tdata[n] = (((d >> 16) & 0xFFFF) + signbits) & 0xFFFF;\n\t\t}\n\t} else {\n\t\tfor (n = 0; n < insn->n; n++) {\n\t\t\tni_stc_writew(dev, NISTC_AI_CMD1_CONVERT_PULSE,\n\t\t\t\t      NISTC_AI_CMD1_REG);\n\t\t\tfor (i = 0; i < NI_TIMEOUT; i++) {\n\t\t\t\tif (!(ni_stc_readw(dev, NISTC_AI_STATUS1_REG) &\n\t\t\t\t      NISTC_AI_STATUS1_FIFO_E))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i == NI_TIMEOUT) {\n\t\t\t\tdev_err(dev->class_dev, \"timeout\\n\");\n\t\t\t\treturn -ETIME;\n\t\t\t}\n\t\t\tif (devpriv->is_m_series) {\n\t\t\t\td = ni_readl(dev, NI_M_AI_FIFO_DATA_REG);\n\t\t\t\td &= mask;\n\t\t\t\tdata[n] = d;\n\t\t\t} else {\n\t\t\t\td = ni_readw(dev, NI_E_AI_FIFO_DATA_REG);\n\t\t\t\td += signbits;\n\t\t\t\tdata[n] = d & 0xffff;\n\t\t\t}\n\t\t}\n\t}\n\treturn insn->n;\n}\n\nstatic int ni_ns_to_timer(const struct comedi_device *dev,\n\t\t\t  unsigned int nanosec, unsigned int flags)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tint divider;\n\n\tswitch (flags & CMDF_ROUND_MASK) {\n\tcase CMDF_ROUND_NEAREST:\n\tdefault:\n\t\tdivider = DIV_ROUND_CLOSEST(nanosec, devpriv->clock_ns);\n\t\tbreak;\n\tcase CMDF_ROUND_DOWN:\n\t\tdivider = (nanosec) / devpriv->clock_ns;\n\t\tbreak;\n\tcase CMDF_ROUND_UP:\n\t\tdivider = DIV_ROUND_UP(nanosec, devpriv->clock_ns);\n\t\tbreak;\n\t}\n\treturn divider - 1;\n}\n\nstatic unsigned int ni_timer_to_ns(const struct comedi_device *dev, int timer)\n{\n\tstruct ni_private *devpriv = dev->private;\n\n\treturn devpriv->clock_ns * (timer + 1);\n}\n\nstatic void ni_cmd_set_mite_transfer(struct mite_ring *ring,\n\t\t\t\t     struct comedi_subdevice *sdev,\n\t\t\t\t     const struct comedi_cmd *cmd,\n\t\t\t\t     unsigned int max_count)\n{\n#ifdef PCIDMA\n\tunsigned int nbytes = max_count;\n\n\tif (cmd->stop_arg > 0 && cmd->stop_arg < max_count)\n\t\tnbytes = cmd->stop_arg;\n\tnbytes *= comedi_bytes_per_scan(sdev);\n\n\tif (nbytes > sdev->async->prealloc_bufsz) {\n\t\tif (cmd->stop_arg > 0)\n\t\t\tdev_err(sdev->device->class_dev,\n\t\t\t\t\"%s: tried exact data transfer limits greater than buffer size\\n\",\n\t\t\t\t__func__);\n\n\t\t \n\t\tnbytes = sdev->async->prealloc_bufsz;\n\t}\n\n\tmite_init_ring_descriptors(ring, sdev, nbytes);\n#else\n\tdev_err(sdev->device->class_dev,\n\t\t\"%s: exact data transfer limits not implemented yet without DMA\\n\",\n\t\t__func__);\n#endif\n}\n\nstatic unsigned int ni_min_ai_scan_period_ns(struct comedi_device *dev,\n\t\t\t\t\t     unsigned int num_channels)\n{\n\tconst struct ni_board_struct *board = dev->board_ptr;\n\tstruct ni_private *devpriv = dev->private;\n\n\t \n\tif (devpriv->is_611x || devpriv->is_6143)\n\t\treturn board->ai_speed;\n\n\t \n\treturn board->ai_speed * num_channels;\n}\n\nstatic int ni_ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,\n\t\t\t struct comedi_cmd *cmd)\n{\n\tconst struct ni_board_struct *board = dev->board_ptr;\n\tstruct ni_private *devpriv = dev->private;\n\tint err = 0;\n\tunsigned int sources;\n\n\t \n\n\terr |= comedi_check_trigger_src(&cmd->start_src,\n\t\t\t\t\tTRIG_NOW | TRIG_INT | TRIG_EXT);\n\terr |= comedi_check_trigger_src(&cmd->scan_begin_src,\n\t\t\t\t\tTRIG_TIMER | TRIG_EXT);\n\n\tsources = TRIG_TIMER | TRIG_EXT;\n\tif (devpriv->is_611x || devpriv->is_6143)\n\t\tsources |= TRIG_NOW;\n\terr |= comedi_check_trigger_src(&cmd->convert_src, sources);\n\n\terr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\n\terr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\n\n\tif (err)\n\t\treturn 1;\n\n\t \n\n\terr |= comedi_check_trigger_is_unique(cmd->start_src);\n\terr |= comedi_check_trigger_is_unique(cmd->scan_begin_src);\n\terr |= comedi_check_trigger_is_unique(cmd->convert_src);\n\terr |= comedi_check_trigger_is_unique(cmd->stop_src);\n\n\t \n\n\tif (err)\n\t\treturn 2;\n\n\t \n\n\tswitch (cmd->start_src) {\n\tcase TRIG_NOW:\n\tcase TRIG_INT:\n\t\terr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\n\t\tbreak;\n\tcase TRIG_EXT:\n\t\terr |= ni_check_trigger_arg_roffs(CR_CHAN(cmd->start_arg),\n\t\t\t\t\t\t  NI_AI_StartTrigger,\n\t\t\t\t\t\t  &devpriv->routing_tables, 1);\n\t\tbreak;\n\t}\n\n\tif (cmd->scan_begin_src == TRIG_TIMER) {\n\t\terr |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,\n\t\t\tni_min_ai_scan_period_ns(dev, cmd->chanlist_len));\n\t\terr |= comedi_check_trigger_arg_max(&cmd->scan_begin_arg,\n\t\t\t\t\t\t    devpriv->clock_ns *\n\t\t\t\t\t\t    0xffffff);\n\t} else if (cmd->scan_begin_src == TRIG_EXT) {\n\t\t \n\t\terr |= ni_check_trigger_arg_roffs(CR_CHAN(cmd->scan_begin_arg),\n\t\t\t\t\t\t  NI_AI_SampleClock,\n\t\t\t\t\t\t  &devpriv->routing_tables, 1);\n\t} else {\t\t \n\t\terr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);\n\t}\n\n\tif (cmd->convert_src == TRIG_TIMER) {\n\t\tif (devpriv->is_611x || devpriv->is_6143) {\n\t\t\terr |= comedi_check_trigger_arg_is(&cmd->convert_arg,\n\t\t\t\t\t\t\t   0);\n\t\t} else {\n\t\t\terr |= comedi_check_trigger_arg_min(&cmd->convert_arg,\n\t\t\t\t\t\t\t    board->ai_speed);\n\t\t\terr |= comedi_check_trigger_arg_max(&cmd->convert_arg,\n\t\t\t\t\t\t\t    devpriv->clock_ns *\n\t\t\t\t\t\t\t    0xffff);\n\t\t}\n\t} else if (cmd->convert_src == TRIG_EXT) {\n\t\t \n\t\terr |= ni_check_trigger_arg_roffs(CR_CHAN(cmd->convert_arg),\n\t\t\t\t\t\t  NI_AI_ConvertClock,\n\t\t\t\t\t\t  &devpriv->routing_tables, 1);\n\t} else if (cmd->convert_src == TRIG_NOW) {\n\t\terr |= comedi_check_trigger_arg_is(&cmd->convert_arg, 0);\n\t}\n\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\n\t\t\t\t\t   cmd->chanlist_len);\n\n\tif (cmd->stop_src == TRIG_COUNT) {\n\t\tunsigned int max_count = 0x01000000;\n\n\t\tif (devpriv->is_611x)\n\t\t\tmax_count -= num_adc_stages_611x;\n\t\terr |= comedi_check_trigger_arg_max(&cmd->stop_arg, max_count);\n\t\terr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\n\t} else {\n\t\t \n\t\terr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\n\t}\n\n\tif (err)\n\t\treturn 3;\n\n\t \n\n\tif (cmd->scan_begin_src == TRIG_TIMER) {\n\t\tunsigned int tmp = cmd->scan_begin_arg;\n\n\t\tcmd->scan_begin_arg =\n\t\t    ni_timer_to_ns(dev, ni_ns_to_timer(dev,\n\t\t\t\t\t\t       cmd->scan_begin_arg,\n\t\t\t\t\t\t       cmd->flags));\n\t\tif (tmp != cmd->scan_begin_arg)\n\t\t\terr++;\n\t}\n\tif (cmd->convert_src == TRIG_TIMER) {\n\t\tif (!devpriv->is_611x && !devpriv->is_6143) {\n\t\t\tunsigned int tmp = cmd->convert_arg;\n\n\t\t\tcmd->convert_arg =\n\t\t\t    ni_timer_to_ns(dev, ni_ns_to_timer(dev,\n\t\t\t\t\t\t\t       cmd->convert_arg,\n\t\t\t\t\t\t\t       cmd->flags));\n\t\t\tif (tmp != cmd->convert_arg)\n\t\t\t\terr++;\n\t\t\tif (cmd->scan_begin_src == TRIG_TIMER &&\n\t\t\t    cmd->scan_begin_arg <\n\t\t\t    cmd->convert_arg * cmd->scan_end_arg) {\n\t\t\t\tcmd->scan_begin_arg =\n\t\t\t\t    cmd->convert_arg * cmd->scan_end_arg;\n\t\t\t\terr++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (err)\n\t\treturn 4;\n\n\treturn 0;\n}\n\nstatic int ni_ai_inttrig(struct comedi_device *dev,\n\t\t\t struct comedi_subdevice *s,\n\t\t\t unsigned int trig_num)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\n\tif (trig_num != cmd->start_arg)\n\t\treturn -EINVAL;\n\n\tni_stc_writew(dev, NISTC_AI_CMD2_START1_PULSE | devpriv->ai_cmd2,\n\t\t      NISTC_AI_CMD2_REG);\n\ts->async->inttrig = NULL;\n\n\treturn 1;\n}\n\nstatic int ni_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tconst struct comedi_cmd *cmd = &s->async->cmd;\n\tint timer;\n\tint mode1 = 0;\t\t \n\tint mode2 = 0;\n\tint start_stop_select = 0;\n\tunsigned int stop_count;\n\tint interrupt_a_enable = 0;\n\tunsigned int ai_trig;\n\n\tif (dev->irq == 0) {\n\t\tdev_err(dev->class_dev, \"cannot run command without an irq\\n\");\n\t\treturn -EIO;\n\t}\n\tni_clear_ai_fifo(dev);\n\n\tni_load_channelgain_list(dev, s, cmd->chanlist_len, cmd->chanlist);\n\n\t \n\tni_stc_writew(dev, NISTC_RESET_AI_CFG_START, NISTC_RESET_REG);\n\n\t \n\tdevpriv->an_trig_etc_reg &= ~NISTC_ATRIG_ETC_ENA;\n\tni_stc_writew(dev, devpriv->an_trig_etc_reg, NISTC_ATRIG_ETC_REG);\n\n\tai_trig = NISTC_AI_TRIG_START2_SEL(0) | NISTC_AI_TRIG_START1_SYNC;\n\tswitch (cmd->start_src) {\n\tcase TRIG_INT:\n\tcase TRIG_NOW:\n\t\tai_trig |= NISTC_AI_TRIG_START1_EDGE |\n\t\t\t   NISTC_AI_TRIG_START1_SEL(0);\n\t\tbreak;\n\tcase TRIG_EXT:\n\t\tai_trig |= NISTC_AI_TRIG_START1_SEL(\n\t\t\t\tni_get_reg_value_roffs(\n\t\t\t\t\tCR_CHAN(cmd->start_arg),\n\t\t\t\t\tNI_AI_StartTrigger,\n\t\t\t\t\t&devpriv->routing_tables, 1));\n\n\t\tif (cmd->start_arg & CR_INVERT)\n\t\t\tai_trig |= NISTC_AI_TRIG_START1_POLARITY;\n\t\tif (cmd->start_arg & CR_EDGE)\n\t\t\tai_trig |= NISTC_AI_TRIG_START1_EDGE;\n\t\tbreak;\n\t}\n\tni_stc_writew(dev, ai_trig, NISTC_AI_TRIG_SEL_REG);\n\n\tmode2 &= ~NISTC_AI_MODE2_PRE_TRIGGER;\n\tmode2 &= ~NISTC_AI_MODE2_SC_INIT_LOAD_SRC;\n\tmode2 &= ~NISTC_AI_MODE2_SC_RELOAD_MODE;\n\tni_stc_writew(dev, mode2, NISTC_AI_MODE2_REG);\n\n\tif (cmd->chanlist_len == 1 || devpriv->is_611x || devpriv->is_6143) {\n\t\t \n\t\tstart_stop_select |= NISTC_AI_STOP_POLARITY |\n\t\t\t\t     NISTC_AI_STOP_SEL(31) |\n\t\t\t\t     NISTC_AI_STOP_SYNC;\n\t} else {\n\t\t \n\t\tstart_stop_select |= NISTC_AI_STOP_SEL(19);\n\t}\n\tni_stc_writew(dev, start_stop_select, NISTC_AI_START_STOP_REG);\n\n\tdevpriv->ai_cmd2 = 0;\n\tswitch (cmd->stop_src) {\n\tcase TRIG_COUNT:\n\t\tstop_count = cmd->stop_arg - 1;\n\n\t\tif (devpriv->is_611x) {\n\t\t\t \n\t\t\tstop_count += num_adc_stages_611x;\n\t\t}\n\t\t \n\t\tni_stc_writel(dev, stop_count, NISTC_AI_SC_LOADA_REG);\n\n\t\tmode1 |= NISTC_AI_MODE1_START_STOP |\n\t\t\t NISTC_AI_MODE1_RSVD |\n\t\t\t NISTC_AI_MODE1_TRIGGER_ONCE;\n\t\tni_stc_writew(dev, mode1, NISTC_AI_MODE1_REG);\n\t\t \n\t\tni_stc_writew(dev, NISTC_AI_CMD1_SC_LOAD, NISTC_AI_CMD1_REG);\n\n\t\tif (stop_count == 0) {\n\t\t\tdevpriv->ai_cmd2 |= NISTC_AI_CMD2_END_ON_EOS;\n\t\t\tinterrupt_a_enable |= NISTC_INTA_ENA_AI_STOP;\n\t\t\t \n\t\t\tif (cmd->chanlist_len > 1)\n\t\t\t\tstart_stop_select |= NISTC_AI_STOP_POLARITY |\n\t\t\t\t\t\t     NISTC_AI_STOP_EDGE;\n\t\t}\n\t\tbreak;\n\tcase TRIG_NONE:\n\t\t \n\t\tni_stc_writel(dev, 0, NISTC_AI_SC_LOADA_REG);\n\n\t\tmode1 |= NISTC_AI_MODE1_START_STOP |\n\t\t\t NISTC_AI_MODE1_RSVD |\n\t\t\t NISTC_AI_MODE1_CONTINUOUS;\n\t\tni_stc_writew(dev, mode1, NISTC_AI_MODE1_REG);\n\n\t\t \n\t\tni_stc_writew(dev, NISTC_AI_CMD1_SC_LOAD, NISTC_AI_CMD1_REG);\n\t\tbreak;\n\t}\n\n\tswitch (cmd->scan_begin_src) {\n\tcase TRIG_TIMER:\n\t\t \n\t\tstart_stop_select |= NISTC_AI_START_EDGE | NISTC_AI_START_SYNC;\n\t\tni_stc_writew(dev, start_stop_select, NISTC_AI_START_STOP_REG);\n\n\t\tmode2 &= ~NISTC_AI_MODE2_SI_INIT_LOAD_SRC;\t \n\t\tmode2 |= NISTC_AI_MODE2_SI_RELOAD_MODE(0);\n\t\t \n\t\tni_stc_writew(dev, mode2, NISTC_AI_MODE2_REG);\n\n\t\t \n\t\ttimer = ni_ns_to_timer(dev, cmd->scan_begin_arg,\n\t\t\t\t       CMDF_ROUND_NEAREST);\n\t\tni_stc_writel(dev, timer, NISTC_AI_SI_LOADA_REG);\n\t\tni_stc_writew(dev, NISTC_AI_CMD1_SI_LOAD, NISTC_AI_CMD1_REG);\n\t\tbreak;\n\tcase TRIG_EXT:\n\t\tif (cmd->scan_begin_arg & CR_EDGE)\n\t\t\tstart_stop_select |= NISTC_AI_START_EDGE;\n\t\tif (cmd->scan_begin_arg & CR_INVERT)\t \n\t\t\tstart_stop_select |= NISTC_AI_START_POLARITY;\n\t\tif (cmd->scan_begin_src != cmd->convert_src ||\n\t\t    (cmd->scan_begin_arg & ~CR_EDGE) !=\n\t\t    (cmd->convert_arg & ~CR_EDGE))\n\t\t\tstart_stop_select |= NISTC_AI_START_SYNC;\n\n\t\tstart_stop_select |= NISTC_AI_START_SEL(\n\t\t\t\t\tni_get_reg_value_roffs(\n\t\t\t\t\t\tCR_CHAN(cmd->scan_begin_arg),\n\t\t\t\t\t\tNI_AI_SampleClock,\n\t\t\t\t\t\t&devpriv->routing_tables, 1));\n\t\tni_stc_writew(dev, start_stop_select, NISTC_AI_START_STOP_REG);\n\t\tbreak;\n\t}\n\n\tswitch (cmd->convert_src) {\n\tcase TRIG_TIMER:\n\tcase TRIG_NOW:\n\t\tif (cmd->convert_arg == 0 || cmd->convert_src == TRIG_NOW)\n\t\t\ttimer = 1;\n\t\telse\n\t\t\ttimer = ni_ns_to_timer(dev, cmd->convert_arg,\n\t\t\t\t\t       CMDF_ROUND_NEAREST);\n\t\t \n\t\tni_stc_writew(dev, 1, NISTC_AI_SI2_LOADA_REG);\n\t\tni_stc_writew(dev, timer, NISTC_AI_SI2_LOADB_REG);\n\n\t\tmode2 &= ~NISTC_AI_MODE2_SI2_INIT_LOAD_SRC;\t \n\t\tmode2 |= NISTC_AI_MODE2_SI2_RELOAD_MODE;\t \n\t\tni_stc_writew(dev, mode2, NISTC_AI_MODE2_REG);\n\n\t\tni_stc_writew(dev, NISTC_AI_CMD1_SI2_LOAD, NISTC_AI_CMD1_REG);\n\n\t\tmode2 |= NISTC_AI_MODE2_SI2_INIT_LOAD_SRC;\t \n\t\tmode2 |= NISTC_AI_MODE2_SI2_RELOAD_MODE;\t \n\t\tni_stc_writew(dev, mode2, NISTC_AI_MODE2_REG);\n\t\tbreak;\n\tcase TRIG_EXT:\n\t\tmode1 |= NISTC_AI_MODE1_CONVERT_SRC(\n\t\t\t\tni_get_reg_value_roffs(\n\t\t\t\t\t\tCR_CHAN(cmd->convert_arg),\n\t\t\t\t\t\tNI_AI_ConvertClock,\n\t\t\t\t\t\t&devpriv->routing_tables, 1));\n\t\tif ((cmd->convert_arg & CR_INVERT) == 0)\n\t\t\tmode1 |= NISTC_AI_MODE1_CONVERT_POLARITY;\n\t\tni_stc_writew(dev, mode1, NISTC_AI_MODE1_REG);\n\n\t\tmode2 |= NISTC_AI_MODE2_SC_GATE_ENA |\n\t\t\t NISTC_AI_MODE2_START_STOP_GATE_ENA;\n\t\tni_stc_writew(dev, mode2, NISTC_AI_MODE2_REG);\n\n\t\tbreak;\n\t}\n\n\tif (dev->irq) {\n\t\t \n\t\tinterrupt_a_enable |= NISTC_INTA_ENA_AI_ERR |\n\t\t\t\t      NISTC_INTA_ENA_AI_SC_TC;\n\n#ifndef PCIDMA\n\t\tinterrupt_a_enable |= NISTC_INTA_ENA_AI_FIFO;\n#endif\n\n\t\tif ((cmd->flags & CMDF_WAKE_EOS) ||\n\t\t    (devpriv->ai_cmd2 & NISTC_AI_CMD2_END_ON_EOS)) {\n\t\t\t \n\t\t\tdevpriv->aimode = AIMODE_SCAN;\n\t\t} else {\n\t\t\tdevpriv->aimode = AIMODE_HALF_FULL;\n\t\t}\n\n\t\tswitch (devpriv->aimode) {\n\t\tcase AIMODE_HALF_FULL:\n\t\t\t \n#ifdef PCIDMA\n\t\t\tni_stc_writew(dev, NISTC_AI_MODE3_FIFO_MODE_HF_E,\n\t\t\t\t      NISTC_AI_MODE3_REG);\n#else\n\t\t\tni_stc_writew(dev, NISTC_AI_MODE3_FIFO_MODE_HF,\n\t\t\t\t      NISTC_AI_MODE3_REG);\n#endif\n\t\t\tbreak;\n\t\tcase AIMODE_SAMPLE:\n\t\t\t \n\t\t\tni_stc_writew(dev, NISTC_AI_MODE3_FIFO_MODE_NE,\n\t\t\t\t      NISTC_AI_MODE3_REG);\n\t\t\tbreak;\n\t\tcase AIMODE_SCAN:\n#ifdef PCIDMA\n\t\t\tni_stc_writew(dev, NISTC_AI_MODE3_FIFO_MODE_NE,\n\t\t\t\t      NISTC_AI_MODE3_REG);\n#else\n\t\t\tni_stc_writew(dev, NISTC_AI_MODE3_FIFO_MODE_HF,\n\t\t\t\t      NISTC_AI_MODE3_REG);\n#endif\n\t\t\tinterrupt_a_enable |= NISTC_INTA_ENA_AI_STOP;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tni_stc_writew(dev, NISTC_INTA_ACK_AI_ALL, NISTC_INTA_ACK_REG);\n\n\t\tni_set_bits(dev, NISTC_INTA_ENA_REG, interrupt_a_enable, 1);\n\t} else {\n\t\t \n\t\tni_set_bits(dev, NISTC_INTA_ENA_REG, ~0, 0);\n\n\t\t \n\t}\n\n\t \n\tni_stc_writew(dev, NISTC_RESET_AI_CFG_END, NISTC_RESET_REG);\n\n\tswitch (cmd->scan_begin_src) {\n\tcase TRIG_TIMER:\n\t\tni_stc_writew(dev, NISTC_AI_CMD1_SI2_ARM |\n\t\t\t\t   NISTC_AI_CMD1_SI_ARM |\n\t\t\t\t   NISTC_AI_CMD1_DIV_ARM |\n\t\t\t\t   NISTC_AI_CMD1_SC_ARM,\n\t\t\t      NISTC_AI_CMD1_REG);\n\t\tbreak;\n\tcase TRIG_EXT:\n\t\tni_stc_writew(dev, NISTC_AI_CMD1_SI2_ARM |\n\t\t\t\t   NISTC_AI_CMD1_SI_ARM |\t \n\t\t\t\t   NISTC_AI_CMD1_DIV_ARM |\n\t\t\t\t   NISTC_AI_CMD1_SC_ARM,\n\t\t\t      NISTC_AI_CMD1_REG);\n\t\tbreak;\n\t}\n\n#ifdef PCIDMA\n\t{\n\t\tint retval = ni_ai_setup_MITE_dma(dev);\n\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n#endif\n\n\tif (cmd->start_src == TRIG_NOW) {\n\t\tni_stc_writew(dev, NISTC_AI_CMD2_START1_PULSE |\n\t\t\t\t   devpriv->ai_cmd2,\n\t\t\t      NISTC_AI_CMD2_REG);\n\t\ts->async->inttrig = NULL;\n\t} else if (cmd->start_src == TRIG_EXT) {\n\t\ts->async->inttrig = NULL;\n\t} else {\t \n\t\ts->async->inttrig = ni_ai_inttrig;\n\t}\n\n\treturn 0;\n}\n\nstatic int ni_ai_insn_config(struct comedi_device *dev,\n\t\t\t     struct comedi_subdevice *s,\n\t\t\t     struct comedi_insn *insn, unsigned int *data)\n{\n\tconst struct ni_board_struct *board = dev->board_ptr;\n\tstruct ni_private *devpriv = dev->private;\n\n\tif (insn->n < 1)\n\t\treturn -EINVAL;\n\n\tswitch (data[0]) {\n\tcase INSN_CONFIG_ALT_SOURCE:\n\t\tif (devpriv->is_m_series) {\n\t\t\tif (data[1] & ~NI_M_CFG_BYPASS_AI_CAL_MASK)\n\t\t\t\treturn -EINVAL;\n\t\t\tdevpriv->ai_calib_source = data[1];\n\t\t} else if (devpriv->is_6143) {\n\t\t\tunsigned int calib_source;\n\n\t\t\tcalib_source = data[1] & 0xf;\n\n\t\t\tdevpriv->ai_calib_source = calib_source;\n\t\t\tni_writew(dev, calib_source, NI6143_CALIB_CHAN_REG);\n\t\t} else {\n\t\t\tunsigned int calib_source;\n\t\t\tunsigned int calib_source_adjust;\n\n\t\t\tcalib_source = data[1] & 0xf;\n\t\t\tcalib_source_adjust = (data[1] >> 4) & 0xff;\n\n\t\t\tif (calib_source >= 8)\n\t\t\t\treturn -EINVAL;\n\t\t\tdevpriv->ai_calib_source = calib_source;\n\t\t\tif (devpriv->is_611x) {\n\t\t\t\tni_writeb(dev, calib_source_adjust,\n\t\t\t\t\t  NI611X_CAL_GAIN_SEL_REG);\n\t\t\t}\n\t\t}\n\t\treturn 2;\n\tcase INSN_CONFIG_GET_CMD_TIMING_CONSTRAINTS:\n\t\t \n\t\t \n\t\tdata[1] = ni_min_ai_scan_period_ns(dev, data[3]);\n\t\tif (devpriv->is_611x || devpriv->is_6143)\n\t\t\tdata[2] = 0;  \n\t\telse\n\t\t\tdata[2] = board->ai_speed;\n\t\treturn 0;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic void ni_ao_munge(struct comedi_device *dev, struct comedi_subdevice *s,\n\t\t\tvoid *data, unsigned int num_bytes,\n\t\t\tunsigned int chan_index)\n{\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tunsigned int nsamples = comedi_bytes_to_samples(s, num_bytes);\n\tunsigned short *array = data;\n\tunsigned int i;\n#ifdef PCIDMA\n\t__le16 buf, *barray = data;\n#endif\n\n\tfor (i = 0; i < nsamples; i++) {\n\t\tunsigned int range = CR_RANGE(cmd->chanlist[chan_index]);\n\t\tunsigned short val = array[i];\n\n\t\t \n\t\tif (comedi_range_is_bipolar(s, range))\n\t\t\tval = comedi_offset_munge(s, val);\n#ifdef PCIDMA\n\t\tbuf = cpu_to_le16(val);\n\t\tbarray[i] = buf;\n#else\n\t\tarray[i] = val;\n#endif\n\t\tchan_index++;\n\t\tchan_index %= cmd->chanlist_len;\n\t}\n}\n\nstatic int ni_m_series_ao_config_chanlist(struct comedi_device *dev,\n\t\t\t\t\t  struct comedi_subdevice *s,\n\t\t\t\t\t  unsigned int chanspec[],\n\t\t\t\t\t  unsigned int n_chans, int timed)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tunsigned int range;\n\tunsigned int chan;\n\tunsigned int conf;\n\tint i;\n\tint invert = 0;\n\n\tif (timed) {\n\t\tfor (i = 0; i < s->n_chan; ++i) {\n\t\t\tdevpriv->ao_conf[i] &= ~NI_M_AO_CFG_BANK_UPDATE_TIMED;\n\t\t\tni_writeb(dev, devpriv->ao_conf[i],\n\t\t\t\t  NI_M_AO_CFG_BANK_REG(i));\n\t\t\tni_writeb(dev, 0xf, NI_M_AO_WAVEFORM_ORDER_REG(i));\n\t\t}\n\t}\n\tfor (i = 0; i < n_chans; i++) {\n\t\tconst struct comedi_krange *krange;\n\n\t\tchan = CR_CHAN(chanspec[i]);\n\t\trange = CR_RANGE(chanspec[i]);\n\t\tkrange = s->range_table->range + range;\n\t\tinvert = 0;\n\t\tconf = 0;\n\t\tswitch (krange->max - krange->min) {\n\t\tcase 20000000:\n\t\t\tconf |= NI_M_AO_CFG_BANK_REF_INT_10V;\n\t\t\tni_writeb(dev, 0, NI_M_AO_REF_ATTENUATION_REG(chan));\n\t\t\tbreak;\n\t\tcase 10000000:\n\t\t\tconf |= NI_M_AO_CFG_BANK_REF_INT_5V;\n\t\t\tni_writeb(dev, 0, NI_M_AO_REF_ATTENUATION_REG(chan));\n\t\t\tbreak;\n\t\tcase 4000000:\n\t\t\tconf |= NI_M_AO_CFG_BANK_REF_INT_10V;\n\t\t\tni_writeb(dev, NI_M_AO_REF_ATTENUATION_X5,\n\t\t\t\t  NI_M_AO_REF_ATTENUATION_REG(chan));\n\t\t\tbreak;\n\t\tcase 2000000:\n\t\t\tconf |= NI_M_AO_CFG_BANK_REF_INT_5V;\n\t\t\tni_writeb(dev, NI_M_AO_REF_ATTENUATION_X5,\n\t\t\t\t  NI_M_AO_REF_ATTENUATION_REG(chan));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(dev->class_dev,\n\t\t\t\t\"bug! unhandled ao reference voltage\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tswitch (krange->max + krange->min) {\n\t\tcase 0:\n\t\t\tconf |= NI_M_AO_CFG_BANK_OFFSET_0V;\n\t\t\tbreak;\n\t\tcase 10000000:\n\t\t\tconf |= NI_M_AO_CFG_BANK_OFFSET_5V;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(dev->class_dev,\n\t\t\t\t\"bug! unhandled ao offset voltage\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (timed)\n\t\t\tconf |= NI_M_AO_CFG_BANK_UPDATE_TIMED;\n\t\tni_writeb(dev, conf, NI_M_AO_CFG_BANK_REG(chan));\n\t\tdevpriv->ao_conf[chan] = conf;\n\t\tni_writeb(dev, i, NI_M_AO_WAVEFORM_ORDER_REG(chan));\n\t}\n\treturn invert;\n}\n\nstatic int ni_old_ao_config_chanlist(struct comedi_device *dev,\n\t\t\t\t     struct comedi_subdevice *s,\n\t\t\t\t     unsigned int chanspec[],\n\t\t\t\t     unsigned int n_chans)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tunsigned int range;\n\tunsigned int chan;\n\tunsigned int conf;\n\tint i;\n\tint invert = 0;\n\n\tfor (i = 0; i < n_chans; i++) {\n\t\tchan = CR_CHAN(chanspec[i]);\n\t\trange = CR_RANGE(chanspec[i]);\n\t\tconf = NI_E_AO_DACSEL(chan);\n\n\t\tif (comedi_range_is_bipolar(s, range)) {\n\t\t\tconf |= NI_E_AO_CFG_BIP;\n\t\t\tinvert = (s->maxdata + 1) >> 1;\n\t\t} else {\n\t\t\tinvert = 0;\n\t\t}\n\t\tif (comedi_range_is_external(s, range))\n\t\t\tconf |= NI_E_AO_EXT_REF;\n\n\t\t \n\t\tif (chanspec[i] & CR_DEGLITCH)\n\t\t\tconf |= NI_E_AO_DEGLITCH;\n\n\t\t \n\t\t \n\t\tif (CR_AREF(chanspec[i]) == AREF_OTHER)\n\t\t\tconf |= NI_E_AO_GROUND_REF;\n\n\t\tni_writew(dev, conf, NI_E_AO_CFG_REG);\n\t\tdevpriv->ao_conf[chan] = conf;\n\t}\n\treturn invert;\n}\n\nstatic int ni_ao_config_chanlist(struct comedi_device *dev,\n\t\t\t\t struct comedi_subdevice *s,\n\t\t\t\t unsigned int chanspec[], unsigned int n_chans,\n\t\t\t\t int timed)\n{\n\tstruct ni_private *devpriv = dev->private;\n\n\tif (devpriv->is_m_series)\n\t\treturn ni_m_series_ao_config_chanlist(dev, s, chanspec, n_chans,\n\t\t\t\t\t\t      timed);\n\telse\n\t\treturn ni_old_ao_config_chanlist(dev, s, chanspec, n_chans);\n}\n\nstatic int ni_ao_insn_write(struct comedi_device *dev,\n\t\t\t    struct comedi_subdevice *s,\n\t\t\t    struct comedi_insn *insn,\n\t\t\t    unsigned int *data)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int range = CR_RANGE(insn->chanspec);\n\tint reg;\n\tint i;\n\n\tif (devpriv->is_6xxx) {\n\t\tni_ao_win_outw(dev, 1 << chan, NI671X_AO_IMMEDIATE_REG);\n\n\t\treg = NI671X_DAC_DIRECT_DATA_REG(chan);\n\t} else if (devpriv->is_m_series) {\n\t\treg = NI_M_DAC_DIRECT_DATA_REG(chan);\n\t} else {\n\t\treg = NI_E_DAC_DIRECT_DATA_REG(chan);\n\t}\n\n\tni_ao_config_chanlist(dev, s, &insn->chanspec, 1, 0);\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\tunsigned int val = data[i];\n\n\t\ts->readback[chan] = val;\n\n\t\tif (devpriv->is_6xxx) {\n\t\t\t \n\t\t\tval = comedi_offset_munge(s, val);\n\n\t\t\tni_ao_win_outw(dev, val, reg);\n\t\t} else if (devpriv->is_m_series) {\n\t\t\t \n\t\t\tni_writew(dev, val, reg);\n\t\t} else {\n\t\t\t \n\t\t\tif (comedi_range_is_bipolar(s, range))\n\t\t\t\tval = comedi_offset_munge(s, val);\n\n\t\t\tni_writew(dev, val, reg);\n\t\t}\n\t}\n\n\treturn insn->n;\n}\n\n \nstatic int ni_ao_arm(struct comedi_device *dev,\n\t\t     struct comedi_subdevice *s)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tint ret;\n\tint interrupt_b_bits;\n\tint i;\n\tstatic const int timeout = 1000;\n\n\t \n\tif (!devpriv->ao_needs_arming) {\n\t\tdev_dbg(dev->class_dev, \"%s: device does not need arming!\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tdevpriv->ao_needs_arming = 0;\n\n\tni_set_bits(dev, NISTC_INTB_ENA_REG,\n\t\t    NISTC_INTB_ENA_AO_FIFO | NISTC_INTB_ENA_AO_ERR, 0);\n\tinterrupt_b_bits = NISTC_INTB_ENA_AO_ERR;\n#ifdef PCIDMA\n\tni_stc_writew(dev, 1, NISTC_DAC_FIFO_CLR_REG);\n\tif (devpriv->is_6xxx)\n\t\tni_ao_win_outl(dev, 0x6, NI611X_AO_FIFO_OFFSET_LOAD_REG);\n\tret = ni_ao_setup_MITE_dma(dev);\n\tif (ret)\n\t\treturn ret;\n\tret = ni_ao_wait_for_dma_load(dev);\n\tif (ret < 0)\n\t\treturn ret;\n#else\n\tret = ni_ao_prep_fifo(dev, s);\n\tif (ret == 0)\n\t\treturn -EPIPE;\n\n\tinterrupt_b_bits |= NISTC_INTB_ENA_AO_FIFO;\n#endif\n\n\tni_stc_writew(dev, devpriv->ao_mode3 | NISTC_AO_MODE3_NOT_AN_UPDATE,\n\t\t      NISTC_AO_MODE3_REG);\n\tni_stc_writew(dev, devpriv->ao_mode3, NISTC_AO_MODE3_REG);\n\t \n\tfor (i = 0; i < timeout; i++) {\n\t\tudelay(1);\n\t\tif ((ni_stc_readw(dev, NISTC_STATUS2_REG) &\n\t\t     NISTC_STATUS2_AO_TMRDACWRS_IN_PROGRESS) == 0)\n\t\t\tbreak;\n\t}\n\tif (i == timeout) {\n\t\tdev_err(dev->class_dev,\n\t\t\t\"timed out waiting for AO_TMRDACWRs_In_Progress_St to clear\\n\");\n\t\treturn -EIO;\n\t}\n\t \n\tni_stc_writew(dev, NISTC_INTB_ACK_AO_ERR, NISTC_INTB_ACK_REG);\n\n\tni_set_bits(dev, NISTC_INTB_ENA_REG, interrupt_b_bits, 1);\n\n\tni_stc_writew(dev, NISTC_AO_CMD1_UI_ARM |\n\t\t\t   NISTC_AO_CMD1_UC_ARM |\n\t\t\t   NISTC_AO_CMD1_BC_ARM |\n\t\t\t   devpriv->ao_cmd1,\n\t\t      NISTC_AO_CMD1_REG);\n\n\treturn 0;\n}\n\nstatic int ni_ao_insn_config(struct comedi_device *dev,\n\t\t\t     struct comedi_subdevice *s,\n\t\t\t     struct comedi_insn *insn, unsigned int *data)\n{\n\tconst struct ni_board_struct *board = dev->board_ptr;\n\tstruct ni_private *devpriv = dev->private;\n\tunsigned int nbytes;\n\n\tswitch (data[0]) {\n\tcase INSN_CONFIG_GET_HARDWARE_BUFFER_SIZE:\n\t\tswitch (data[1]) {\n\t\tcase COMEDI_OUTPUT:\n\t\t\tnbytes = comedi_samples_to_bytes(s,\n\t\t\t\t\t\t\t board->ao_fifo_depth);\n\t\t\tdata[2] = 1 + nbytes;\n\t\t\tif (devpriv->mite)\n\t\t\t\tdata[2] += devpriv->mite->fifo_size;\n\t\t\tbreak;\n\t\tcase COMEDI_INPUT:\n\t\t\tdata[2] = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\tcase INSN_CONFIG_ARM:\n\t\treturn ni_ao_arm(dev, s);\n\tcase INSN_CONFIG_GET_CMD_TIMING_CONSTRAINTS:\n\t\t \n\t\t \n\t\tdata[1] = board->ao_speed * data[3];\n\t\tdata[2] = 0;\n\t\treturn 0;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int ni_ao_inttrig(struct comedi_device *dev,\n\t\t\t struct comedi_subdevice *s,\n\t\t\t unsigned int trig_num)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tint ret;\n\n\t \n\tif (!(trig_num == cmd->start_arg ||\n\t      (trig_num == 0 && cmd->start_src != TRIG_INT)))\n\t\treturn -EINVAL;\n\n\t \n\ts->async->inttrig = NULL;\n\n\tif (devpriv->ao_needs_arming) {\n\t\t \n\t\tret = ni_ao_arm(dev, s);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tni_stc_writew(dev, NISTC_AO_CMD2_START1_PULSE | devpriv->ao_cmd2,\n\t\t      NISTC_AO_CMD2_REG);\n\n\treturn 0;\n}\n\n \n\nstatic void ni_ao_cmd_personalize(struct comedi_device *dev,\n\t\t\t\t  const struct comedi_cmd *cmd)\n{\n\tconst struct ni_board_struct *board = dev->board_ptr;\n\tunsigned int bits;\n\n\tni_stc_writew(dev, NISTC_RESET_AO_CFG_START, NISTC_RESET_REG);\n\n\tbits =\n\t   \n\t   \n\t  NISTC_AO_PERSONAL_BC_SRC_SEL  |\n\t  0   |\n\t   \n\t  NISTC_AO_PERSONAL_UPDATE_PW   |\n\t   \n\t  NISTC_AO_PERSONAL_TMRDACWR_PW |\n\t  (board->ao_fifo_depth ?\n\t    NISTC_AO_PERSONAL_FIFO_ENA : NISTC_AO_PERSONAL_DMA_PIO_CTRL)\n\t  ;\n#if 0\n\t \n\n\t \n\tif (devpriv->is_m_series)\n\t\tbits |= NISTC_AO_PERSONAL_NUM_DAC;\n#endif\n\tni_stc_writew(dev, bits, NISTC_AO_PERSONAL_REG);\n\n\tni_stc_writew(dev, NISTC_RESET_AO_CFG_END, NISTC_RESET_REG);\n}\n\nstatic void ni_ao_cmd_set_trigger(struct comedi_device *dev,\n\t\t\t\t  const struct comedi_cmd *cmd)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tunsigned int trigsel;\n\n\tni_stc_writew(dev, NISTC_RESET_AO_CFG_START, NISTC_RESET_REG);\n\n\t \n\tif (cmd->stop_src == TRIG_NONE) {\n\t\tdevpriv->ao_mode1 |= NISTC_AO_MODE1_CONTINUOUS;\n\t\tdevpriv->ao_mode1 &= ~NISTC_AO_MODE1_TRIGGER_ONCE;\n\t} else {\n\t\tdevpriv->ao_mode1 &= ~NISTC_AO_MODE1_CONTINUOUS;\n\t\tdevpriv->ao_mode1 |= NISTC_AO_MODE1_TRIGGER_ONCE;\n\t}\n\tni_stc_writew(dev, devpriv->ao_mode1, NISTC_AO_MODE1_REG);\n\n\tif (cmd->start_src == TRIG_INT) {\n\t\ttrigsel = NISTC_AO_TRIG_START1_EDGE |\n\t\t\t  NISTC_AO_TRIG_START1_SYNC;\n\t} else {  \n\t\ttrigsel = NISTC_AO_TRIG_START1_SEL(\n\t\t\t\tni_get_reg_value_roffs(\n\t\t\t\t\t\tCR_CHAN(cmd->start_arg),\n\t\t\t\t\t\tNI_AO_StartTrigger,\n\t\t\t\t\t\t&devpriv->routing_tables, 1));\n\n\t\t \n\t\tif (cmd->start_arg & CR_INVERT)\n\t\t\ttrigsel |= NISTC_AO_TRIG_START1_POLARITY;\n\t\t \n\t\tif (cmd->start_arg & CR_EDGE)\n\t\t\ttrigsel |= NISTC_AO_TRIG_START1_EDGE;\n\t}\n\tni_stc_writew(dev, trigsel, NISTC_AO_TRIG_SEL_REG);\n\n\t \n\n\t \n\t \n\tdevpriv->ao_mode3 &= ~NISTC_AO_MODE3_TRIG_LEN;\n\tni_stc_writew(dev, devpriv->ao_mode3, NISTC_AO_MODE3_REG);\n\n\tni_stc_writew(dev, NISTC_RESET_AO_CFG_END, NISTC_RESET_REG);\n}\n\nstatic void ni_ao_cmd_set_counters(struct comedi_device *dev,\n\t\t\t\t   const struct comedi_cmd *cmd)\n{\n\tstruct ni_private *devpriv = dev->private;\n\t \n\n\tni_stc_writew(dev, NISTC_RESET_AO_CFG_START, NISTC_RESET_REG);\n\t \n\tni_stc_writew(dev, devpriv->ao_mode1, NISTC_AO_MODE1_REG);\n\n\t \n\t \n\tdevpriv->ao_mode2 &= ~NISTC_AO_MODE2_BC_INIT_LOAD_SRC;\n\tni_stc_writew(dev, devpriv->ao_mode2, NISTC_AO_MODE2_REG);\n\n\t \n\tni_stc_writel(dev, 0, NISTC_AO_BC_LOADA_REG);  \n\n\t \n\tni_stc_writew(dev, NISTC_AO_CMD1_BC_LOAD, NISTC_AO_CMD1_REG);\n\n\t \n\t \n\tdevpriv->ao_mode2 &= ~NISTC_AO_MODE2_UC_INIT_LOAD_SRC;\n\tni_stc_writew(dev, devpriv->ao_mode2, NISTC_AO_MODE2_REG);\n\n\t \n\t{\n\t\tunsigned int stop_arg = cmd->stop_arg > 0 ?\n\t\t\t(cmd->stop_arg & 0xffffff) : 0xffffff;\n\n\t\tif (devpriv->is_m_series) {\n\t\t\t \n\t\t\tni_stc_writel(dev, stop_arg - 1, NISTC_AO_UC_LOADA_REG);\n\n\t\t\t \n\t\t\tni_stc_writew(dev, NISTC_AO_CMD1_UC_LOAD,\n\t\t\t\t      NISTC_AO_CMD1_REG);\n\t\t} else {\n\t\t\tni_stc_writel(dev, stop_arg, NISTC_AO_UC_LOADA_REG);\n\n\t\t\t \n\t\t\tni_stc_writew(dev, NISTC_AO_CMD1_UC_LOAD,\n\t\t\t\t      NISTC_AO_CMD1_REG);\n\n\t\t\t \n\t\t\tni_stc_writel(dev, stop_arg - 1, NISTC_AO_UC_LOADA_REG);\n\t\t}\n\t}\n\n\tni_stc_writew(dev, NISTC_RESET_AO_CFG_END, NISTC_RESET_REG);\n}\n\nstatic void ni_ao_cmd_set_update(struct comedi_device *dev,\n\t\t\t\t const struct comedi_cmd *cmd)\n{\n\tstruct ni_private *devpriv = dev->private;\n\n\tni_stc_writew(dev, NISTC_RESET_AO_CFG_START, NISTC_RESET_REG);\n\n\t \n\tdevpriv->ao_mode1 &=  ~(NISTC_AO_MODE1_UI_SRC_MASK\t   |\n\t\t\t\tNISTC_AO_MODE1_UI_SRC_POLARITY\t   |\n\t\t\t\tNISTC_AO_MODE1_UPDATE_SRC_MASK\t   |\n\t\t\t\tNISTC_AO_MODE1_UPDATE_SRC_POLARITY);\n\n\tif (cmd->scan_begin_src == TRIG_TIMER) {\n\t\tunsigned int trigvar;\n\n\t\tdevpriv->ao_cmd2  &= ~NISTC_AO_CMD2_BC_GATE_ENA;\n\n\t\t \n\n\t\t \n\n\t\t \n\n\t\ttrigvar = ni_ns_to_timer(dev, cmd->scan_begin_arg,\n\t\t\t\t\t CMDF_ROUND_NEAREST);\n\n\t\t \n\t\t \n\t\tni_stc_writel(dev, 1, NISTC_AO_UI_LOADA_REG);\n\t\tni_stc_writew(dev, NISTC_AO_CMD1_UI_LOAD, NISTC_AO_CMD1_REG);\n\t\tni_stc_writel(dev, trigvar, NISTC_AO_UI_LOADA_REG);\n\t} else {  \n\t\t \n\t\tdevpriv->ao_cmd2  |= NISTC_AO_CMD2_BC_GATE_ENA;\n\t\tdevpriv->ao_mode1 |= NISTC_AO_MODE1_UPDATE_SRC(\n\t\t\t\t\tni_get_reg_value(\n\t\t\t\t\t\tCR_CHAN(cmd->scan_begin_arg),\n\t\t\t\t\t\tNI_AO_SampleClock,\n\t\t\t\t\t\t&devpriv->routing_tables));\n\t\tif (cmd->scan_begin_arg & CR_INVERT)\n\t\t\tdevpriv->ao_mode1 |= NISTC_AO_MODE1_UPDATE_SRC_POLARITY;\n\t}\n\n\tni_stc_writew(dev, devpriv->ao_cmd2, NISTC_AO_CMD2_REG);\n\tni_stc_writew(dev, devpriv->ao_mode1, NISTC_AO_MODE1_REG);\n\tdevpriv->ao_mode2 &= ~(NISTC_AO_MODE2_UI_RELOAD_MODE(3) |\n\t\t\t       NISTC_AO_MODE2_UI_INIT_LOAD_SRC);\n\tni_stc_writew(dev, devpriv->ao_mode2, NISTC_AO_MODE2_REG);\n\n\t \n\tdevpriv->ao_cmd1 |= NISTC_AO_CMD1_DAC1_UPDATE_MODE |\n\t\t\t    NISTC_AO_CMD1_DAC0_UPDATE_MODE;\n\t \n\tni_stc_writew(dev, devpriv->ao_cmd1, NISTC_AO_CMD1_REG);\n\n\tni_stc_writew(dev, NISTC_RESET_AO_CFG_END, NISTC_RESET_REG);\n}\n\nstatic void ni_ao_cmd_set_channels(struct comedi_device *dev,\n\t\t\t\t   struct comedi_subdevice *s)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tconst struct comedi_cmd *cmd = &s->async->cmd;\n\tunsigned int bits = 0;\n\n\tni_stc_writew(dev, NISTC_RESET_AO_CFG_START, NISTC_RESET_REG);\n\n\tif (devpriv->is_6xxx) {\n\t\tunsigned int i;\n\n\t\tbits = 0;\n\t\tfor (i = 0; i < cmd->chanlist_len; ++i) {\n\t\t\tint chan = CR_CHAN(cmd->chanlist[i]);\n\n\t\t\tbits |= 1 << chan;\n\t\t\tni_ao_win_outw(dev, chan, NI611X_AO_WAVEFORM_GEN_REG);\n\t\t}\n\t\tni_ao_win_outw(dev, bits, NI611X_AO_TIMED_REG);\n\t}\n\n\tni_ao_config_chanlist(dev, s, cmd->chanlist, cmd->chanlist_len, 1);\n\n\tif (cmd->scan_end_arg > 1) {\n\t\tdevpriv->ao_mode1 |= NISTC_AO_MODE1_MULTI_CHAN;\n\t\tbits = NISTC_AO_OUT_CTRL_CHANS(cmd->scan_end_arg - 1)\n\t\t\t\t | NISTC_AO_OUT_CTRL_UPDATE_SEL_HIGHZ;\n\n\t} else {\n\t\tdevpriv->ao_mode1 &= ~NISTC_AO_MODE1_MULTI_CHAN;\n\t\tbits = NISTC_AO_OUT_CTRL_UPDATE_SEL_HIGHZ;\n\t\tif (devpriv->is_m_series | devpriv->is_6xxx)\n\t\t\tbits |= NISTC_AO_OUT_CTRL_CHANS(0);\n\t\telse\n\t\t\tbits |= NISTC_AO_OUT_CTRL_CHANS(\n\t\t\t\t\tCR_CHAN(cmd->chanlist[0]));\n\t}\n\n\tni_stc_writew(dev, devpriv->ao_mode1, NISTC_AO_MODE1_REG);\n\tni_stc_writew(dev, bits,              NISTC_AO_OUT_CTRL_REG);\n\n\tni_stc_writew(dev, NISTC_RESET_AO_CFG_END, NISTC_RESET_REG);\n}\n\nstatic void ni_ao_cmd_set_stop_conditions(struct comedi_device *dev,\n\t\t\t\t\t  const struct comedi_cmd *cmd)\n{\n\tstruct ni_private *devpriv = dev->private;\n\n\tni_stc_writew(dev, NISTC_RESET_AO_CFG_START, NISTC_RESET_REG);\n\n\tdevpriv->ao_mode3 |= NISTC_AO_MODE3_STOP_ON_OVERRUN_ERR;\n\tni_stc_writew(dev, devpriv->ao_mode3, NISTC_AO_MODE3_REG);\n\n\t \n\n\tni_stc_writew(dev, NISTC_RESET_AO_CFG_END, NISTC_RESET_REG);\n}\n\nstatic void ni_ao_cmd_set_fifo_mode(struct comedi_device *dev)\n{\n\tstruct ni_private *devpriv = dev->private;\n\n\tni_stc_writew(dev, NISTC_RESET_AO_CFG_START, NISTC_RESET_REG);\n\n\tdevpriv->ao_mode2 &= ~NISTC_AO_MODE2_FIFO_MODE_MASK;\n#ifdef PCIDMA\n\tdevpriv->ao_mode2 |= NISTC_AO_MODE2_FIFO_MODE_HF_F;\n#else\n\tdevpriv->ao_mode2 |= NISTC_AO_MODE2_FIFO_MODE_HF;\n#endif\n\t \n\tdevpriv->ao_mode2 &= ~NISTC_AO_MODE2_FIFO_REXMIT_ENA;\n\tni_stc_writew(dev, devpriv->ao_mode2, NISTC_AO_MODE2_REG);\n\n\t \n\tni_stc_writew(dev, NISTC_AO_START_AOFREQ_ENA, NISTC_AO_START_SEL_REG);\n\n\tni_stc_writew(dev, NISTC_RESET_AO_CFG_END, NISTC_RESET_REG);\n\n\t \n}\n\nstatic void ni_ao_cmd_set_interrupts(struct comedi_device *dev,\n\t\t\t\t     struct comedi_subdevice *s)\n{\n\tif (s->async->cmd.stop_src == TRIG_COUNT)\n\t\tni_set_bits(dev, NISTC_INTB_ENA_REG,\n\t\t\t    NISTC_INTB_ENA_AO_BC_TC, 1);\n\n\ts->async->inttrig = ni_ao_inttrig;\n}\n\nstatic int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tconst struct comedi_cmd *cmd = &s->async->cmd;\n\n\tif (dev->irq == 0) {\n\t\tdev_err(dev->class_dev, \"cannot run command without an irq\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tni_ao_cmd_personalize(dev, cmd);\n\t \n\n\tni_ao_cmd_set_trigger(dev, cmd);\n\tni_ao_cmd_set_counters(dev, cmd);\n\tni_ao_cmd_set_update(dev, cmd);\n\tni_ao_cmd_set_channels(dev, s);\n\tni_ao_cmd_set_stop_conditions(dev, cmd);\n\tni_ao_cmd_set_fifo_mode(dev);\n\tni_cmd_set_mite_transfer(devpriv->ao_mite_ring, s, cmd, 0x00ffffff);\n\tni_ao_cmd_set_interrupts(dev, s);\n\n\t \n\tdevpriv->ao_needs_arming = 1;\n\treturn 0;\n}\n\n \n\nstatic int ni_ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,\n\t\t\t struct comedi_cmd *cmd)\n{\n\tconst struct ni_board_struct *board = dev->board_ptr;\n\tstruct ni_private *devpriv = dev->private;\n\tint err = 0;\n\tunsigned int tmp;\n\n\t \n\n\terr |= comedi_check_trigger_src(&cmd->start_src, TRIG_INT | TRIG_EXT);\n\terr |= comedi_check_trigger_src(&cmd->scan_begin_src,\n\t\t\t\t\tTRIG_TIMER | TRIG_EXT);\n\terr |= comedi_check_trigger_src(&cmd->convert_src, TRIG_NOW);\n\terr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\n\terr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\n\n\tif (err)\n\t\treturn 1;\n\n\t \n\n\terr |= comedi_check_trigger_is_unique(cmd->start_src);\n\terr |= comedi_check_trigger_is_unique(cmd->scan_begin_src);\n\terr |= comedi_check_trigger_is_unique(cmd->stop_src);\n\n\t \n\n\tif (err)\n\t\treturn 2;\n\n\t \n\n\tswitch (cmd->start_src) {\n\tcase TRIG_INT:\n\t\terr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\n\t\tbreak;\n\tcase TRIG_EXT:\n\t\terr |= ni_check_trigger_arg_roffs(CR_CHAN(cmd->start_arg),\n\t\t\t\t\t\t  NI_AO_StartTrigger,\n\t\t\t\t\t\t  &devpriv->routing_tables, 1);\n\t\tbreak;\n\t}\n\n\tif (cmd->scan_begin_src == TRIG_TIMER) {\n\t\terr |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,\n\t\t\t\t\t\t    board->ao_speed);\n\t\terr |= comedi_check_trigger_arg_max(&cmd->scan_begin_arg,\n\t\t\t\t\t\t    devpriv->clock_ns *\n\t\t\t\t\t\t    0xffffff);\n\t} else {\t\t \n\t\terr |= ni_check_trigger_arg(CR_CHAN(cmd->scan_begin_arg),\n\t\t\t\t\t    NI_AO_SampleClock,\n\t\t\t\t\t    &devpriv->routing_tables);\n\t}\n\n\terr |= comedi_check_trigger_arg_is(&cmd->convert_arg, 0);\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\n\t\t\t\t\t   cmd->chanlist_len);\n\terr |= comedi_check_trigger_arg_max(&cmd->stop_arg, 0x00ffffff);\n\n\tif (err)\n\t\treturn 3;\n\n\t \n\tif (cmd->scan_begin_src == TRIG_TIMER) {\n\t\ttmp = cmd->scan_begin_arg;\n\t\tcmd->scan_begin_arg =\n\t\t    ni_timer_to_ns(dev, ni_ns_to_timer(dev,\n\t\t\t\t\t\t       cmd->scan_begin_arg,\n\t\t\t\t\t\t       cmd->flags));\n\t\tif (tmp != cmd->scan_begin_arg)\n\t\t\terr++;\n\t}\n\tif (err)\n\t\treturn 4;\n\n\treturn 0;\n}\n\nstatic int ni_ao_reset(struct comedi_device *dev, struct comedi_subdevice *s)\n{\n\t \n\n\t \n\n\tstruct ni_private *devpriv = dev->private;\n\n\tni_release_ao_mite_channel(dev);\n\n\t \n\tif (devpriv->is_m_series)\n\t\t \n\t\tni_stc_writew(dev, NISTC_RESET_AO, NISTC_RESET_REG);\n\n\t \n\tni_stc_writew(dev, NISTC_RESET_AO_CFG_START, NISTC_RESET_REG);\n\n\t \n\tni_stc_writew(dev, NISTC_AO_CMD1_DISARM, NISTC_AO_CMD1_REG);\n\n\t \n\tdevpriv->ao_cmd1  = 0;\n\tdevpriv->ao_cmd2  = 0;\n\tdevpriv->ao_mode1 = 0;\n\tdevpriv->ao_mode2 = 0;\n\tif (devpriv->is_m_series)\n\t\tdevpriv->ao_mode3 = NISTC_AO_MODE3_LAST_GATE_DISABLE;\n\telse\n\t\tdevpriv->ao_mode3 = 0;\n\n\tni_stc_writew(dev, 0, NISTC_AO_PERSONAL_REG);\n\tni_stc_writew(dev, 0, NISTC_AO_CMD1_REG);\n\tni_stc_writew(dev, 0, NISTC_AO_CMD2_REG);\n\tni_stc_writew(dev, 0, NISTC_AO_MODE1_REG);\n\tni_stc_writew(dev, 0, NISTC_AO_MODE2_REG);\n\tni_stc_writew(dev, 0, NISTC_AO_OUT_CTRL_REG);\n\tni_stc_writew(dev, devpriv->ao_mode3, NISTC_AO_MODE3_REG);\n\tni_stc_writew(dev, 0, NISTC_AO_START_SEL_REG);\n\tni_stc_writew(dev, 0, NISTC_AO_TRIG_SEL_REG);\n\n\t \n\tni_set_bits(dev, NISTC_INTB_ENA_REG, ~0, 0);\n\n\t \n\tni_stc_writew(dev, NISTC_AO_PERSONAL_BC_SRC_SEL, NISTC_AO_PERSONAL_REG);\n\tni_stc_writew(dev, NISTC_INTB_ACK_AO_ALL, NISTC_INTB_ACK_REG);\n\n\t \n\tif (devpriv->is_6xxx) {\n\t\tni_ao_win_outw(dev, (1u << s->n_chan) - 1u,\n\t\t\t       NI671X_AO_IMMEDIATE_REG);\n\t\tni_ao_win_outw(dev, NI611X_AO_MISC_CLEAR_WG,\n\t\t\t       NI611X_AO_MISC_REG);\n\t}\n\tni_stc_writew(dev, NISTC_RESET_AO_CFG_END, NISTC_RESET_REG);\n\t \n\n\treturn 0;\n}\n\n \n\nstatic int ni_dio_insn_config(struct comedi_device *dev,\n\t\t\t      struct comedi_subdevice *s,\n\t\t\t      struct comedi_insn *insn,\n\t\t\t      unsigned int *data)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tint ret;\n\n\tret = comedi_dio_insn_config(dev, s, insn, data, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tdevpriv->dio_control &= ~NISTC_DIO_CTRL_DIR_MASK;\n\tdevpriv->dio_control |= NISTC_DIO_CTRL_DIR(s->io_bits);\n\tni_stc_writew(dev, devpriv->dio_control, NISTC_DIO_CTRL_REG);\n\n\treturn insn->n;\n}\n\nstatic int ni_dio_insn_bits(struct comedi_device *dev,\n\t\t\t    struct comedi_subdevice *s,\n\t\t\t    struct comedi_insn *insn,\n\t\t\t    unsigned int *data)\n{\n\tstruct ni_private *devpriv = dev->private;\n\n\t \n\tif ((data[0] & (NISTC_DIO_SDIN | NISTC_DIO_SDOUT)) &&\n\t    devpriv->serial_interval_ns)\n\t\treturn -EBUSY;\n\n\tif (comedi_dio_update_state(s, data)) {\n\t\tdevpriv->dio_output &= ~NISTC_DIO_OUT_PARALLEL_MASK;\n\t\tdevpriv->dio_output |= NISTC_DIO_OUT_PARALLEL(s->state);\n\t\tni_stc_writew(dev, devpriv->dio_output, NISTC_DIO_OUT_REG);\n\t}\n\n\tdata[1] = ni_stc_readw(dev, NISTC_DIO_IN_REG);\n\n\treturn insn->n;\n}\n\n#ifdef PCIDMA\nstatic int ni_m_series_dio_insn_config(struct comedi_device *dev,\n\t\t\t\t       struct comedi_subdevice *s,\n\t\t\t\t       struct comedi_insn *insn,\n\t\t\t\t       unsigned int *data)\n{\n\tint ret;\n\n\tif (data[0] == INSN_CONFIG_GET_CMD_TIMING_CONSTRAINTS) {\n\t\tconst struct ni_board_struct *board = dev->board_ptr;\n\n\t\t \n\t\tdata[1] = board->dio_speed;\n\t\tdata[2] = 0;\n\t\treturn 0;\n\t}\n\n\tret = comedi_dio_insn_config(dev, s, insn, data, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tni_writel(dev, s->io_bits, NI_M_DIO_DIR_REG);\n\n\treturn insn->n;\n}\n\nstatic int ni_m_series_dio_insn_bits(struct comedi_device *dev,\n\t\t\t\t     struct comedi_subdevice *s,\n\t\t\t\t     struct comedi_insn *insn,\n\t\t\t\t     unsigned int *data)\n{\n\tif (comedi_dio_update_state(s, data))\n\t\tni_writel(dev, s->state, NI_M_DIO_REG);\n\n\tdata[1] = ni_readl(dev, NI_M_DIO_REG);\n\n\treturn insn->n;\n}\n\nstatic int ni_cdio_check_chanlist(struct comedi_device *dev,\n\t\t\t\t  struct comedi_subdevice *s,\n\t\t\t\t  struct comedi_cmd *cmd)\n{\n\tint i;\n\n\tfor (i = 0; i < cmd->chanlist_len; ++i) {\n\t\tunsigned int chan = CR_CHAN(cmd->chanlist[i]);\n\n\t\tif (chan != i)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ni_cdio_cmdtest(struct comedi_device *dev,\n\t\t\t   struct comedi_subdevice *s, struct comedi_cmd *cmd)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tunsigned int bytes_per_scan;\n\tint err = 0;\n\n\t \n\n\terr |= comedi_check_trigger_src(&cmd->start_src, TRIG_INT);\n\terr |= comedi_check_trigger_src(&cmd->scan_begin_src, TRIG_EXT);\n\terr |= comedi_check_trigger_src(&cmd->convert_src, TRIG_NOW);\n\terr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\n\terr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_NONE);\n\n\tif (err)\n\t\treturn 1;\n\n\t \n\t \n\n\t \n\n\terr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\n\n\t \n\terr |= ni_check_trigger_arg(CR_CHAN(cmd->scan_begin_arg),\n\t\t\t\t    NI_DO_SampleClock,\n\t\t\t\t    &devpriv->routing_tables);\n\tif (CR_RANGE(cmd->scan_begin_arg) != 0 ||\n\t    CR_AREF(cmd->scan_begin_arg) != 0)\n\t\terr |= -EINVAL;\n\n\terr |= comedi_check_trigger_arg_is(&cmd->convert_arg, 0);\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\n\t\t\t\t\t   cmd->chanlist_len);\n\tbytes_per_scan = comedi_bytes_per_scan_cmd(s, cmd);\n\tif (bytes_per_scan) {\n\t\terr |= comedi_check_trigger_arg_max(&cmd->stop_arg,\n\t\t\t\t\t\t    s->async->prealloc_bufsz /\n\t\t\t\t\t\t    bytes_per_scan);\n\t}\n\n\tif (err)\n\t\treturn 3;\n\n\t \n\n\t \n\n\tif (cmd->chanlist && cmd->chanlist_len > 0)\n\t\terr |= ni_cdio_check_chanlist(dev, s, cmd);\n\n\tif (err)\n\t\treturn 5;\n\n\treturn 0;\n}\n\nstatic int ni_cdo_inttrig(struct comedi_device *dev,\n\t\t\t  struct comedi_subdevice *s,\n\t\t\t  unsigned int trig_num)\n{\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tconst unsigned int timeout = 1000;\n\tint retval = 0;\n\tunsigned int i;\n\tstruct ni_private *devpriv = dev->private;\n\tunsigned long flags;\n\n\tif (trig_num != cmd->start_arg)\n\t\treturn -EINVAL;\n\n\ts->async->inttrig = NULL;\n\n\t \n\tcomedi_buf_read_alloc(s, s->async->prealloc_bufsz);\n\n\tspin_lock_irqsave(&devpriv->mite_channel_lock, flags);\n\tif (devpriv->cdo_mite_chan) {\n\t\tmite_prep_dma(devpriv->cdo_mite_chan, 32, 32);\n\t\tmite_dma_arm(devpriv->cdo_mite_chan);\n\t} else {\n\t\tdev_err(dev->class_dev, \"BUG: no cdo mite channel?\\n\");\n\t\tretval = -EIO;\n\t}\n\tspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\n\tif (retval < 0)\n\t\treturn retval;\n\n\t \n\tfor (i = 0; i < timeout; ++i) {\n\t\tif (ni_readl(dev, NI_M_CDIO_STATUS_REG) &\n\t\t    NI_M_CDIO_STATUS_CDO_FIFO_FULL)\n\t\t\tbreak;\n\t\tusleep_range(10, 100);\n\t}\n\tif (i == timeout) {\n\t\tdev_err(dev->class_dev, \"dma failed to fill cdo fifo!\\n\");\n\t\ts->cancel(dev, s);\n\t\treturn -EIO;\n\t}\n\tni_writel(dev, NI_M_CDO_CMD_ARM |\n\t\t       NI_M_CDO_CMD_ERR_INT_ENA_SET |\n\t\t       NI_M_CDO_CMD_F_E_INT_ENA_SET,\n\t\t  NI_M_CDIO_CMD_REG);\n\treturn retval;\n}\n\nstatic int ni_cdio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tconst struct comedi_cmd *cmd = &s->async->cmd;\n\tunsigned int cdo_mode_bits;\n\tint retval;\n\n\tni_writel(dev, NI_M_CDO_CMD_RESET, NI_M_CDIO_CMD_REG);\n\t \n\tcdo_mode_bits = NI_M_CDO_MODE_FIFO_MODE |\n\t\t\tNI_M_CDO_MODE_HALT_ON_ERROR |\n\t\t\tNI_M_CDO_MODE_SAMPLE_SRC(\n\t\t\t\tni_get_reg_value(\n\t\t\t\t\tCR_CHAN(cmd->scan_begin_arg),\n\t\t\t\t\tNI_DO_SampleClock,\n\t\t\t\t\t&devpriv->routing_tables));\n\tif (cmd->scan_begin_arg & CR_INVERT)\n\t\tcdo_mode_bits |= NI_M_CDO_MODE_POLARITY;\n\tni_writel(dev, cdo_mode_bits, NI_M_CDO_MODE_REG);\n\tif (s->io_bits) {\n\t\tni_writel(dev, s->state, NI_M_CDO_FIFO_DATA_REG);\n\t\tni_writel(dev, NI_M_CDO_CMD_SW_UPDATE, NI_M_CDIO_CMD_REG);\n\t\tni_writel(dev, s->io_bits, NI_M_CDO_MASK_ENA_REG);\n\t} else {\n\t\tdev_err(dev->class_dev,\n\t\t\t\"attempted to run digital output command with no lines configured as outputs\\n\");\n\t\treturn -EIO;\n\t}\n\tretval = ni_request_cdo_mite_channel(dev);\n\tif (retval < 0)\n\t\treturn retval;\n\n\tni_cmd_set_mite_transfer(devpriv->cdo_mite_ring, s, cmd,\n\t\t\t\t s->async->prealloc_bufsz /\n\t\t\t\t comedi_bytes_per_scan(s));\n\n\ts->async->inttrig = ni_cdo_inttrig;\n\n\treturn 0;\n}\n\nstatic int ni_cdio_cancel(struct comedi_device *dev, struct comedi_subdevice *s)\n{\n\tni_writel(dev, NI_M_CDO_CMD_DISARM |\n\t\t       NI_M_CDO_CMD_ERR_INT_ENA_CLR |\n\t\t       NI_M_CDO_CMD_F_E_INT_ENA_CLR |\n\t\t       NI_M_CDO_CMD_F_REQ_INT_ENA_CLR,\n\t\t  NI_M_CDIO_CMD_REG);\n\t \n\tni_writel(dev, 0, NI_M_CDO_MASK_ENA_REG);\n\tni_release_cdo_mite_channel(dev);\n\treturn 0;\n}\n\nstatic void handle_cdio_interrupt(struct comedi_device *dev)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tunsigned int cdio_status;\n\tstruct comedi_subdevice *s = &dev->subdevices[NI_DIO_SUBDEV];\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&devpriv->mite_channel_lock, flags);\n\tif (devpriv->cdo_mite_chan)\n\t\tmite_ack_linkc(devpriv->cdo_mite_chan, s, true);\n\tspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags);\n\n\tcdio_status = ni_readl(dev, NI_M_CDIO_STATUS_REG);\n\tif (cdio_status & NI_M_CDIO_STATUS_CDO_ERROR) {\n\t\t \n\t\tni_writel(dev, NI_M_CDO_CMD_ERR_INT_CONFIRM,\n\t\t\t  NI_M_CDIO_CMD_REG);\n\t\ts->async->events |= COMEDI_CB_OVERFLOW;\n\t}\n\tif (cdio_status & NI_M_CDIO_STATUS_CDO_FIFO_EMPTY) {\n\t\tni_writel(dev, NI_M_CDO_CMD_F_E_INT_ENA_CLR,\n\t\t\t  NI_M_CDIO_CMD_REG);\n\t\t \n\t}\n\tcomedi_handle_events(dev, s);\n}\n#endif  \n\nstatic int ni_serial_hw_readwrite8(struct comedi_device *dev,\n\t\t\t\t   struct comedi_subdevice *s,\n\t\t\t\t   unsigned char data_out,\n\t\t\t\t   unsigned char *data_in)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tunsigned int status1;\n\tint err = 0, count = 20;\n\n\tdevpriv->dio_output &= ~NISTC_DIO_OUT_SERIAL_MASK;\n\tdevpriv->dio_output |= NISTC_DIO_OUT_SERIAL(data_out);\n\tni_stc_writew(dev, devpriv->dio_output, NISTC_DIO_OUT_REG);\n\n\tstatus1 = ni_stc_readw(dev, NISTC_STATUS1_REG);\n\tif (status1 & NISTC_STATUS1_SERIO_IN_PROG) {\n\t\terr = -EBUSY;\n\t\tgoto error;\n\t}\n\n\tdevpriv->dio_control |= NISTC_DIO_CTRL_HW_SER_START;\n\tni_stc_writew(dev, devpriv->dio_control, NISTC_DIO_CTRL_REG);\n\tdevpriv->dio_control &= ~NISTC_DIO_CTRL_HW_SER_START;\n\n\t \n\twhile ((status1 = ni_stc_readw(dev, NISTC_STATUS1_REG)) &\n\t       NISTC_STATUS1_SERIO_IN_PROG) {\n\t\t \n\t\tudelay((devpriv->serial_interval_ns + 999) / 1000);\n\t\tif (--count < 0) {\n\t\t\tdev_err(dev->class_dev,\n\t\t\t\t\"SPI serial I/O didn't finish in time!\\n\");\n\t\t\terr = -ETIME;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t \n\tudelay((devpriv->serial_interval_ns + 999) / 1000);\n\n\tif (data_in)\n\t\t*data_in = ni_stc_readw(dev, NISTC_DIO_SERIAL_IN_REG);\n\nerror:\n\tni_stc_writew(dev, devpriv->dio_control, NISTC_DIO_CTRL_REG);\n\n\treturn err;\n}\n\nstatic int ni_serial_sw_readwrite8(struct comedi_device *dev,\n\t\t\t\t   struct comedi_subdevice *s,\n\t\t\t\t   unsigned char data_out,\n\t\t\t\t   unsigned char *data_in)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tunsigned char mask, input = 0;\n\n\t \n\tudelay((devpriv->serial_interval_ns + 999) / 1000);\n\n\tfor (mask = 0x80; mask; mask >>= 1) {\n\t\t \n\t\tdevpriv->dio_output &= ~NISTC_DIO_SDOUT;\n\t\tif (data_out & mask)\n\t\t\tdevpriv->dio_output |= NISTC_DIO_SDOUT;\n\t\tni_stc_writew(dev, devpriv->dio_output, NISTC_DIO_OUT_REG);\n\n\t\t \n\t\tdevpriv->dio_control |= NISTC_DIO_SDCLK;\n\t\tni_stc_writew(dev, devpriv->dio_control, NISTC_DIO_CTRL_REG);\n\n\t\tudelay((devpriv->serial_interval_ns + 999) / 2000);\n\n\t\tdevpriv->dio_control &= ~NISTC_DIO_SDCLK;\n\t\tni_stc_writew(dev, devpriv->dio_control, NISTC_DIO_CTRL_REG);\n\n\t\tudelay((devpriv->serial_interval_ns + 999) / 2000);\n\n\t\t \n\t\tif (ni_stc_readw(dev, NISTC_DIO_IN_REG) & NISTC_DIO_SDIN)\n\t\t\tinput |= mask;\n\t}\n\n\tif (data_in)\n\t\t*data_in = input;\n\n\treturn 0;\n}\n\nstatic int ni_serial_insn_config(struct comedi_device *dev,\n\t\t\t\t struct comedi_subdevice *s,\n\t\t\t\t struct comedi_insn *insn,\n\t\t\t\t unsigned int *data)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tunsigned int clk_fout = devpriv->clock_and_fout;\n\tint err = insn->n;\n\tunsigned char byte_out, byte_in = 0;\n\n\tif (insn->n != 2)\n\t\treturn -EINVAL;\n\n\tswitch (data[0]) {\n\tcase INSN_CONFIG_SERIAL_CLOCK:\n\t\tdevpriv->serial_hw_mode = 1;\n\t\tdevpriv->dio_control |= NISTC_DIO_CTRL_HW_SER_ENA;\n\n\t\tif (data[1] == SERIAL_DISABLED) {\n\t\t\tdevpriv->serial_hw_mode = 0;\n\t\t\tdevpriv->dio_control &= ~(NISTC_DIO_CTRL_HW_SER_ENA |\n\t\t\t\t\t\t  NISTC_DIO_SDCLK);\n\t\t\tdata[1] = SERIAL_DISABLED;\n\t\t\tdevpriv->serial_interval_ns = data[1];\n\t\t} else if (data[1] <= SERIAL_600NS) {\n\t\t\t \n\t\t\tdevpriv->dio_control &= ~NISTC_DIO_CTRL_HW_SER_TIMEBASE;\n\t\t\tclk_fout |= NISTC_CLK_FOUT_SLOW_TIMEBASE;\n\t\t\tclk_fout &= ~NISTC_CLK_FOUT_DIO_SER_OUT_DIV2;\n\t\t\tdata[1] = SERIAL_600NS;\n\t\t\tdevpriv->serial_interval_ns = data[1];\n\t\t} else if (data[1] <= SERIAL_1_2US) {\n\t\t\tdevpriv->dio_control &= ~NISTC_DIO_CTRL_HW_SER_TIMEBASE;\n\t\t\tclk_fout |= NISTC_CLK_FOUT_SLOW_TIMEBASE |\n\t\t\t\t    NISTC_CLK_FOUT_DIO_SER_OUT_DIV2;\n\t\t\tdata[1] = SERIAL_1_2US;\n\t\t\tdevpriv->serial_interval_ns = data[1];\n\t\t} else if (data[1] <= SERIAL_10US) {\n\t\t\tdevpriv->dio_control |= NISTC_DIO_CTRL_HW_SER_TIMEBASE;\n\t\t\tclk_fout |= NISTC_CLK_FOUT_SLOW_TIMEBASE |\n\t\t\t\t    NISTC_CLK_FOUT_DIO_SER_OUT_DIV2;\n\t\t\t \n\t\t\tdata[1] = SERIAL_10US;\n\t\t\tdevpriv->serial_interval_ns = data[1];\n\t\t} else {\n\t\t\tdevpriv->dio_control &= ~(NISTC_DIO_CTRL_HW_SER_ENA |\n\t\t\t\t\t\t  NISTC_DIO_SDCLK);\n\t\t\tdevpriv->serial_hw_mode = 0;\n\t\t\tdata[1] = (data[1] / 1000) * 1000;\n\t\t\tdevpriv->serial_interval_ns = data[1];\n\t\t}\n\t\tdevpriv->clock_and_fout = clk_fout;\n\n\t\tni_stc_writew(dev, devpriv->dio_control, NISTC_DIO_CTRL_REG);\n\t\tni_stc_writew(dev, devpriv->clock_and_fout, NISTC_CLK_FOUT_REG);\n\t\treturn 1;\n\n\tcase INSN_CONFIG_BIDIRECTIONAL_DATA:\n\n\t\tif (devpriv->serial_interval_ns == 0)\n\t\t\treturn -EINVAL;\n\n\t\tbyte_out = data[1] & 0xFF;\n\n\t\tif (devpriv->serial_hw_mode) {\n\t\t\terr = ni_serial_hw_readwrite8(dev, s, byte_out,\n\t\t\t\t\t\t      &byte_in);\n\t\t} else if (devpriv->serial_interval_ns > 0) {\n\t\t\terr = ni_serial_sw_readwrite8(dev, s, byte_out,\n\t\t\t\t\t\t      &byte_in);\n\t\t} else {\n\t\t\tdev_err(dev->class_dev, \"serial disabled!\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tdata[1] = byte_in & 0xFF;\n\t\treturn insn->n;\n\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic void init_ao_67xx(struct comedi_device *dev, struct comedi_subdevice *s)\n{\n\tint i;\n\n\tfor (i = 0; i < s->n_chan; i++) {\n\t\tni_ao_win_outw(dev, NI_E_AO_DACSEL(i) | 0x0,\n\t\t\t       NI67XX_AO_CFG2_REG);\n\t}\n\tni_ao_win_outw(dev, 0x0, NI67XX_AO_SP_UPDATES_REG);\n}\n\nstatic const struct mio_regmap ni_gpct_to_stc_regmap[] = {\n\t[NITIO_G0_AUTO_INC]\t= { NISTC_G0_AUTOINC_REG, 2 },\n\t[NITIO_G1_AUTO_INC]\t= { NISTC_G1_AUTOINC_REG, 2 },\n\t[NITIO_G0_CMD]\t\t= { NISTC_G0_CMD_REG, 2 },\n\t[NITIO_G1_CMD]\t\t= { NISTC_G1_CMD_REG, 2 },\n\t[NITIO_G0_HW_SAVE]\t= { NISTC_G0_HW_SAVE_REG, 4 },\n\t[NITIO_G1_HW_SAVE]\t= { NISTC_G1_HW_SAVE_REG, 4 },\n\t[NITIO_G0_SW_SAVE]\t= { NISTC_G0_SAVE_REG, 4 },\n\t[NITIO_G1_SW_SAVE]\t= { NISTC_G1_SAVE_REG, 4 },\n\t[NITIO_G0_MODE]\t\t= { NISTC_G0_MODE_REG, 2 },\n\t[NITIO_G1_MODE]\t\t= { NISTC_G1_MODE_REG, 2 },\n\t[NITIO_G0_LOADA]\t= { NISTC_G0_LOADA_REG, 4 },\n\t[NITIO_G1_LOADA]\t= { NISTC_G1_LOADA_REG, 4 },\n\t[NITIO_G0_LOADB]\t= { NISTC_G0_LOADB_REG, 4 },\n\t[NITIO_G1_LOADB]\t= { NISTC_G1_LOADB_REG, 4 },\n\t[NITIO_G0_INPUT_SEL]\t= { NISTC_G0_INPUT_SEL_REG, 2 },\n\t[NITIO_G1_INPUT_SEL]\t= { NISTC_G1_INPUT_SEL_REG, 2 },\n\t[NITIO_G0_CNT_MODE]\t= { 0x1b0, 2 },\t \n\t[NITIO_G1_CNT_MODE]\t= { 0x1b2, 2 },\t \n\t[NITIO_G0_GATE2]\t= { 0x1b4, 2 },\t \n\t[NITIO_G1_GATE2]\t= { 0x1b6, 2 },\t \n\t[NITIO_G01_STATUS]\t= { NISTC_G01_STATUS_REG, 2 },\n\t[NITIO_G01_RESET]\t= { NISTC_RESET_REG, 2 },\n\t[NITIO_G01_STATUS1]\t= { NISTC_STATUS1_REG, 2 },\n\t[NITIO_G01_STATUS2]\t= { NISTC_STATUS2_REG, 2 },\n\t[NITIO_G0_DMA_CFG]\t= { 0x1b8, 2 },\t \n\t[NITIO_G1_DMA_CFG]\t= { 0x1ba, 2 },\t \n\t[NITIO_G0_DMA_STATUS]\t= { 0x1b8, 2 },\t \n\t[NITIO_G1_DMA_STATUS]\t= { 0x1ba, 2 },\t \n\t[NITIO_G0_ABZ]\t\t= { 0x1c0, 2 },\t \n\t[NITIO_G1_ABZ]\t\t= { 0x1c2, 2 },\t \n\t[NITIO_G0_INT_ACK]\t= { NISTC_INTA_ACK_REG, 2 },\n\t[NITIO_G1_INT_ACK]\t= { NISTC_INTB_ACK_REG, 2 },\n\t[NITIO_G0_STATUS]\t= { NISTC_AI_STATUS1_REG, 2 },\n\t[NITIO_G1_STATUS]\t= { NISTC_AO_STATUS1_REG, 2 },\n\t[NITIO_G0_INT_ENA]\t= { NISTC_INTA_ENA_REG, 2 },\n\t[NITIO_G1_INT_ENA]\t= { NISTC_INTB_ENA_REG, 2 },\n};\n\nstatic unsigned int ni_gpct_to_stc_register(struct comedi_device *dev,\n\t\t\t\t\t    enum ni_gpct_register reg)\n{\n\tconst struct mio_regmap *regmap;\n\n\tif (reg < ARRAY_SIZE(ni_gpct_to_stc_regmap)) {\n\t\tregmap = &ni_gpct_to_stc_regmap[reg];\n\t} else {\n\t\tdev_warn(dev->class_dev, \"%s: unhandled register=0x%x\\n\",\n\t\t\t __func__, reg);\n\t\treturn 0;\n\t}\n\n\treturn regmap->mio_reg;\n}\n\nstatic void ni_gpct_write_register(struct ni_gpct *counter, unsigned int bits,\n\t\t\t\t   enum ni_gpct_register reg)\n{\n\tstruct comedi_device *dev = counter->counter_dev->dev;\n\tunsigned int stc_register = ni_gpct_to_stc_register(dev, reg);\n\n\tif (stc_register == 0)\n\t\treturn;\n\n\tswitch (reg) {\n\t\t \n\tcase NITIO_G0_CNT_MODE:\n\tcase NITIO_G1_CNT_MODE:\n\tcase NITIO_G0_GATE2:\n\tcase NITIO_G1_GATE2:\n\tcase NITIO_G0_DMA_CFG:\n\tcase NITIO_G1_DMA_CFG:\n\tcase NITIO_G0_ABZ:\n\tcase NITIO_G1_ABZ:\n\t\tni_writew(dev, bits, stc_register);\n\t\tbreak;\n\n\t\t \n\tcase NITIO_G0_LOADA:\n\tcase NITIO_G1_LOADA:\n\tcase NITIO_G0_LOADB:\n\tcase NITIO_G1_LOADB:\n\t\tni_stc_writel(dev, bits, stc_register);\n\t\tbreak;\n\n\t\t \n\tcase NITIO_G0_INT_ENA:\n\t\tni_set_bitfield(dev, stc_register,\n\t\t\t\tNISTC_INTA_ENA_G0_GATE | NISTC_INTA_ENA_G0_TC,\n\t\t\t\tbits);\n\t\tbreak;\n\tcase NITIO_G1_INT_ENA:\n\t\tni_set_bitfield(dev, stc_register,\n\t\t\t\tNISTC_INTB_ENA_G1_GATE | NISTC_INTB_ENA_G1_TC,\n\t\t\t\tbits);\n\t\tbreak;\n\tdefault:\n\t\tni_stc_writew(dev, bits, stc_register);\n\t}\n}\n\nstatic unsigned int ni_gpct_read_register(struct ni_gpct *counter,\n\t\t\t\t\t  enum ni_gpct_register reg)\n{\n\tstruct comedi_device *dev = counter->counter_dev->dev;\n\tunsigned int stc_register = ni_gpct_to_stc_register(dev, reg);\n\n\tif (stc_register == 0)\n\t\treturn 0;\n\n\tswitch (reg) {\n\t\t \n\tcase NITIO_G0_DMA_STATUS:\n\tcase NITIO_G1_DMA_STATUS:\n\t\treturn ni_readw(dev, stc_register);\n\n\t\t \n\tcase NITIO_G0_HW_SAVE:\n\tcase NITIO_G1_HW_SAVE:\n\tcase NITIO_G0_SW_SAVE:\n\tcase NITIO_G1_SW_SAVE:\n\t\treturn ni_stc_readl(dev, stc_register);\n\n\t\t \n\tdefault:\n\t\treturn ni_stc_readw(dev, stc_register);\n\t}\n}\n\nstatic int ni_freq_out_insn_read(struct comedi_device *dev,\n\t\t\t\t struct comedi_subdevice *s,\n\t\t\t\t struct comedi_insn *insn,\n\t\t\t\t unsigned int *data)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tunsigned int val = NISTC_CLK_FOUT_TO_DIVIDER(devpriv->clock_and_fout);\n\tint i;\n\n\tfor (i = 0; i < insn->n; i++)\n\t\tdata[i] = val;\n\n\treturn insn->n;\n}\n\nstatic int ni_freq_out_insn_write(struct comedi_device *dev,\n\t\t\t\t  struct comedi_subdevice *s,\n\t\t\t\t  struct comedi_insn *insn,\n\t\t\t\t  unsigned int *data)\n{\n\tstruct ni_private *devpriv = dev->private;\n\n\tif (insn->n) {\n\t\tunsigned int val = data[insn->n - 1];\n\n\t\tdevpriv->clock_and_fout &= ~NISTC_CLK_FOUT_ENA;\n\t\tni_stc_writew(dev, devpriv->clock_and_fout, NISTC_CLK_FOUT_REG);\n\t\tdevpriv->clock_and_fout &= ~NISTC_CLK_FOUT_DIVIDER_MASK;\n\n\t\t \n\t\tdevpriv->clock_and_fout |= NISTC_CLK_FOUT_DIVIDER(val);\n\n\t\tdevpriv->clock_and_fout |= NISTC_CLK_FOUT_ENA;\n\t\tni_stc_writew(dev, devpriv->clock_and_fout, NISTC_CLK_FOUT_REG);\n\t}\n\treturn insn->n;\n}\n\nstatic int ni_freq_out_insn_config(struct comedi_device *dev,\n\t\t\t\t   struct comedi_subdevice *s,\n\t\t\t\t   struct comedi_insn *insn,\n\t\t\t\t   unsigned int *data)\n{\n\tstruct ni_private *devpriv = dev->private;\n\n\tswitch (data[0]) {\n\tcase INSN_CONFIG_SET_CLOCK_SRC:\n\t\tswitch (data[1]) {\n\t\tcase NI_FREQ_OUT_TIMEBASE_1_DIV_2_CLOCK_SRC:\n\t\t\tdevpriv->clock_and_fout &= ~NISTC_CLK_FOUT_TIMEBASE_SEL;\n\t\t\tbreak;\n\t\tcase NI_FREQ_OUT_TIMEBASE_2_CLOCK_SRC:\n\t\t\tdevpriv->clock_and_fout |= NISTC_CLK_FOUT_TIMEBASE_SEL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tni_stc_writew(dev, devpriv->clock_and_fout, NISTC_CLK_FOUT_REG);\n\t\tbreak;\n\tcase INSN_CONFIG_GET_CLOCK_SRC:\n\t\tif (devpriv->clock_and_fout & NISTC_CLK_FOUT_TIMEBASE_SEL) {\n\t\t\tdata[1] = NI_FREQ_OUT_TIMEBASE_2_CLOCK_SRC;\n\t\t\tdata[2] = TIMEBASE_2_NS;\n\t\t} else {\n\t\t\tdata[1] = NI_FREQ_OUT_TIMEBASE_1_DIV_2_CLOCK_SRC;\n\t\t\tdata[2] = TIMEBASE_1_NS * 2;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn insn->n;\n}\n\nstatic int ni_8255_callback(struct comedi_device *dev,\n\t\t\t    int dir, int port, int data, unsigned long iobase)\n{\n\tif (dir) {\n\t\tni_writeb(dev, data, iobase + 2 * port);\n\t\treturn 0;\n\t}\n\n\treturn ni_readb(dev, iobase + 2 * port);\n}\n\nstatic int ni_get_pwm_config(struct comedi_device *dev, unsigned int *data)\n{\n\tstruct ni_private *devpriv = dev->private;\n\n\tdata[1] = devpriv->pwm_up_count * devpriv->clock_ns;\n\tdata[2] = devpriv->pwm_down_count * devpriv->clock_ns;\n\treturn 3;\n}\n\nstatic int ni_m_series_pwm_config(struct comedi_device *dev,\n\t\t\t\t  struct comedi_subdevice *s,\n\t\t\t\t  struct comedi_insn *insn,\n\t\t\t\t  unsigned int *data)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tunsigned int up_count, down_count;\n\n\tswitch (data[0]) {\n\tcase INSN_CONFIG_PWM_OUTPUT:\n\t\tswitch (data[1]) {\n\t\tcase CMDF_ROUND_NEAREST:\n\t\t\tup_count = DIV_ROUND_CLOSEST(data[2],\n\t\t\t\t\t\t     devpriv->clock_ns);\n\t\t\tbreak;\n\t\tcase CMDF_ROUND_DOWN:\n\t\t\tup_count = data[2] / devpriv->clock_ns;\n\t\t\tbreak;\n\t\tcase CMDF_ROUND_UP:\n\t\t\tup_count =\n\t\t\t    DIV_ROUND_UP(data[2], devpriv->clock_ns);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tswitch (data[3]) {\n\t\tcase CMDF_ROUND_NEAREST:\n\t\t\tdown_count = DIV_ROUND_CLOSEST(data[4],\n\t\t\t\t\t\t       devpriv->clock_ns);\n\t\t\tbreak;\n\t\tcase CMDF_ROUND_DOWN:\n\t\t\tdown_count = data[4] / devpriv->clock_ns;\n\t\t\tbreak;\n\t\tcase CMDF_ROUND_UP:\n\t\t\tdown_count =\n\t\t\t    DIV_ROUND_UP(data[4], devpriv->clock_ns);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (up_count * devpriv->clock_ns != data[2] ||\n\t\t    down_count * devpriv->clock_ns != data[4]) {\n\t\t\tdata[2] = up_count * devpriv->clock_ns;\n\t\t\tdata[4] = down_count * devpriv->clock_ns;\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\tni_writel(dev, NI_M_CAL_PWM_HIGH_TIME(up_count) |\n\t\t\t       NI_M_CAL_PWM_LOW_TIME(down_count),\n\t\t\t  NI_M_CAL_PWM_REG);\n\t\tdevpriv->pwm_up_count = up_count;\n\t\tdevpriv->pwm_down_count = down_count;\n\t\treturn 5;\n\tcase INSN_CONFIG_GET_PWM_OUTPUT:\n\t\treturn ni_get_pwm_config(dev, data);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int ni_6143_pwm_config(struct comedi_device *dev,\n\t\t\t      struct comedi_subdevice *s,\n\t\t\t      struct comedi_insn *insn,\n\t\t\t      unsigned int *data)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tunsigned int up_count, down_count;\n\n\tswitch (data[0]) {\n\tcase INSN_CONFIG_PWM_OUTPUT:\n\t\tswitch (data[1]) {\n\t\tcase CMDF_ROUND_NEAREST:\n\t\t\tup_count = DIV_ROUND_CLOSEST(data[2],\n\t\t\t\t\t\t     devpriv->clock_ns);\n\t\t\tbreak;\n\t\tcase CMDF_ROUND_DOWN:\n\t\t\tup_count = data[2] / devpriv->clock_ns;\n\t\t\tbreak;\n\t\tcase CMDF_ROUND_UP:\n\t\t\tup_count =\n\t\t\t    DIV_ROUND_UP(data[2], devpriv->clock_ns);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tswitch (data[3]) {\n\t\tcase CMDF_ROUND_NEAREST:\n\t\t\tdown_count = DIV_ROUND_CLOSEST(data[4],\n\t\t\t\t\t\t       devpriv->clock_ns);\n\t\t\tbreak;\n\t\tcase CMDF_ROUND_DOWN:\n\t\t\tdown_count = data[4] / devpriv->clock_ns;\n\t\t\tbreak;\n\t\tcase CMDF_ROUND_UP:\n\t\t\tdown_count =\n\t\t\t    DIV_ROUND_UP(data[4], devpriv->clock_ns);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (up_count * devpriv->clock_ns != data[2] ||\n\t\t    down_count * devpriv->clock_ns != data[4]) {\n\t\t\tdata[2] = up_count * devpriv->clock_ns;\n\t\t\tdata[4] = down_count * devpriv->clock_ns;\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\tni_writel(dev, up_count, NI6143_CALIB_HI_TIME_REG);\n\t\tdevpriv->pwm_up_count = up_count;\n\t\tni_writel(dev, down_count, NI6143_CALIB_LO_TIME_REG);\n\t\tdevpriv->pwm_down_count = down_count;\n\t\treturn 5;\n\tcase INSN_CONFIG_GET_PWM_OUTPUT:\n\t\treturn ni_get_pwm_config(dev, data);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int pack_mb88341(int addr, int val, int *bitstring)\n{\n\t \n\taddr++;\n\t*bitstring = ((addr & 0x1) << 11) |\n\t    ((addr & 0x2) << 9) |\n\t    ((addr & 0x4) << 7) | ((addr & 0x8) << 5) | (val & 0xff);\n\treturn 12;\n}\n\nstatic int pack_dac8800(int addr, int val, int *bitstring)\n{\n\t*bitstring = ((addr & 0x7) << 8) | (val & 0xff);\n\treturn 11;\n}\n\nstatic int pack_dac8043(int addr, int val, int *bitstring)\n{\n\t*bitstring = val & 0xfff;\n\treturn 12;\n}\n\nstatic int pack_ad8522(int addr, int val, int *bitstring)\n{\n\t*bitstring = (val & 0xfff) | (addr ? 0xc000 : 0xa000);\n\treturn 16;\n}\n\nstatic int pack_ad8804(int addr, int val, int *bitstring)\n{\n\t*bitstring = ((addr & 0xf) << 8) | (val & 0xff);\n\treturn 12;\n}\n\nstatic int pack_ad8842(int addr, int val, int *bitstring)\n{\n\t*bitstring = ((addr + 1) << 8) | (val & 0xff);\n\treturn 12;\n}\n\nstruct caldac_struct {\n\tint n_chans;\n\tint n_bits;\n\tint (*packbits)(int address, int value, int *bitstring);\n};\n\nstatic struct caldac_struct caldacs[] = {\n\t[mb88341] = {12, 8, pack_mb88341},\n\t[dac8800] = {8, 8, pack_dac8800},\n\t[dac8043] = {1, 12, pack_dac8043},\n\t[ad8522] = {2, 12, pack_ad8522},\n\t[ad8804] = {12, 8, pack_ad8804},\n\t[ad8842] = {8, 8, pack_ad8842},\n\t[ad8804_debug] = {16, 8, pack_ad8804},\n};\n\nstatic void ni_write_caldac(struct comedi_device *dev, int addr, int val)\n{\n\tconst struct ni_board_struct *board = dev->board_ptr;\n\tstruct ni_private *devpriv = dev->private;\n\tunsigned int loadbit = 0, bits = 0, bit, bitstring = 0;\n\tunsigned int cmd;\n\tint i;\n\tint type;\n\n\tif (devpriv->caldacs[addr] == val)\n\t\treturn;\n\tdevpriv->caldacs[addr] = val;\n\n\tfor (i = 0; i < 3; i++) {\n\t\ttype = board->caldac[i];\n\t\tif (type == caldac_none)\n\t\t\tbreak;\n\t\tif (addr < caldacs[type].n_chans) {\n\t\t\tbits = caldacs[type].packbits(addr, val, &bitstring);\n\t\t\tloadbit = NI_E_SERIAL_CMD_DAC_LD(i);\n\t\t\tbreak;\n\t\t}\n\t\taddr -= caldacs[type].n_chans;\n\t}\n\n\t \n\tif (bits == 0)\n\t\treturn;\n\n\tfor (bit = 1 << (bits - 1); bit; bit >>= 1) {\n\t\tcmd = (bit & bitstring) ? NI_E_SERIAL_CMD_SDATA : 0;\n\t\tni_writeb(dev, cmd, NI_E_SERIAL_CMD_REG);\n\t\tudelay(1);\n\t\tni_writeb(dev, NI_E_SERIAL_CMD_SCLK | cmd, NI_E_SERIAL_CMD_REG);\n\t\tudelay(1);\n\t}\n\tni_writeb(dev, loadbit, NI_E_SERIAL_CMD_REG);\n\tudelay(1);\n\tni_writeb(dev, 0, NI_E_SERIAL_CMD_REG);\n}\n\nstatic int ni_calib_insn_write(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       struct comedi_insn *insn,\n\t\t\t       unsigned int *data)\n{\n\tif (insn->n) {\n\t\t \n\t\tni_write_caldac(dev, CR_CHAN(insn->chanspec),\n\t\t\t\tdata[insn->n - 1]);\n\t}\n\n\treturn insn->n;\n}\n\nstatic int ni_calib_insn_read(struct comedi_device *dev,\n\t\t\t      struct comedi_subdevice *s,\n\t\t\t      struct comedi_insn *insn,\n\t\t\t      unsigned int *data)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tunsigned int i;\n\n\tfor (i = 0; i < insn->n; i++)\n\t\tdata[0] = devpriv->caldacs[CR_CHAN(insn->chanspec)];\n\n\treturn insn->n;\n}\n\nstatic void caldac_setup(struct comedi_device *dev, struct comedi_subdevice *s)\n{\n\tconst struct ni_board_struct *board = dev->board_ptr;\n\tstruct ni_private *devpriv = dev->private;\n\tint i, j;\n\tint n_dacs;\n\tint n_chans = 0;\n\tint n_bits;\n\tint diffbits = 0;\n\tint type;\n\tint chan;\n\n\ttype = board->caldac[0];\n\tif (type == caldac_none)\n\t\treturn;\n\tn_bits = caldacs[type].n_bits;\n\tfor (i = 0; i < 3; i++) {\n\t\ttype = board->caldac[i];\n\t\tif (type == caldac_none)\n\t\t\tbreak;\n\t\tif (caldacs[type].n_bits != n_bits)\n\t\t\tdiffbits = 1;\n\t\tn_chans += caldacs[type].n_chans;\n\t}\n\tn_dacs = i;\n\ts->n_chan = n_chans;\n\n\tif (diffbits) {\n\t\tunsigned int *maxdata_list = devpriv->caldac_maxdata_list;\n\n\t\tif (n_chans > MAX_N_CALDACS)\n\t\t\tdev_err(dev->class_dev,\n\t\t\t\t\"BUG! MAX_N_CALDACS too small\\n\");\n\t\ts->maxdata_list = maxdata_list;\n\t\tchan = 0;\n\t\tfor (i = 0; i < n_dacs; i++) {\n\t\t\ttype = board->caldac[i];\n\t\t\tfor (j = 0; j < caldacs[type].n_chans; j++) {\n\t\t\t\tmaxdata_list[chan] =\n\t\t\t\t    (1 << caldacs[type].n_bits) - 1;\n\t\t\t\tchan++;\n\t\t\t}\n\t\t}\n\n\t\tfor (chan = 0; chan < s->n_chan; chan++)\n\t\t\tni_write_caldac(dev, i, s->maxdata_list[i] / 2);\n\t} else {\n\t\ttype = board->caldac[0];\n\t\ts->maxdata = (1 << caldacs[type].n_bits) - 1;\n\n\t\tfor (chan = 0; chan < s->n_chan; chan++)\n\t\t\tni_write_caldac(dev, i, s->maxdata / 2);\n\t}\n}\n\nstatic int ni_read_eeprom(struct comedi_device *dev, int addr)\n{\n\tunsigned int cmd = NI_E_SERIAL_CMD_EEPROM_CS;\n\tint bit;\n\tint bitstring;\n\n\tbitstring = 0x0300 | ((addr & 0x100) << 3) | (addr & 0xff);\n\tni_writeb(dev, cmd, NI_E_SERIAL_CMD_REG);\n\tfor (bit = 0x8000; bit; bit >>= 1) {\n\t\tif (bit & bitstring)\n\t\t\tcmd |= NI_E_SERIAL_CMD_SDATA;\n\t\telse\n\t\t\tcmd &= ~NI_E_SERIAL_CMD_SDATA;\n\n\t\tni_writeb(dev, cmd, NI_E_SERIAL_CMD_REG);\n\t\tni_writeb(dev, NI_E_SERIAL_CMD_SCLK | cmd, NI_E_SERIAL_CMD_REG);\n\t}\n\tcmd = NI_E_SERIAL_CMD_EEPROM_CS;\n\tbitstring = 0;\n\tfor (bit = 0x80; bit; bit >>= 1) {\n\t\tni_writeb(dev, cmd, NI_E_SERIAL_CMD_REG);\n\t\tni_writeb(dev, NI_E_SERIAL_CMD_SCLK | cmd, NI_E_SERIAL_CMD_REG);\n\t\tif (ni_readb(dev, NI_E_STATUS_REG) & NI_E_STATUS_PROMOUT)\n\t\t\tbitstring |= bit;\n\t}\n\tni_writeb(dev, 0, NI_E_SERIAL_CMD_REG);\n\n\treturn bitstring;\n}\n\nstatic int ni_eeprom_insn_read(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       struct comedi_insn *insn,\n\t\t\t       unsigned int *data)\n{\n\tunsigned int val;\n\tunsigned int i;\n\n\tif (insn->n) {\n\t\tval = ni_read_eeprom(dev, CR_CHAN(insn->chanspec));\n\t\tfor (i = 0; i < insn->n; i++)\n\t\t\tdata[i] = val;\n\t}\n\treturn insn->n;\n}\n\nstatic int ni_m_series_eeprom_insn_read(struct comedi_device *dev,\n\t\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\t\tstruct comedi_insn *insn,\n\t\t\t\t\tunsigned int *data)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tunsigned int i;\n\n\tfor (i = 0; i < insn->n; i++)\n\t\tdata[i] = devpriv->eeprom_buffer[CR_CHAN(insn->chanspec)];\n\n\treturn insn->n;\n}\n\nstatic unsigned int ni_old_get_pfi_routing(struct comedi_device *dev,\n\t\t\t\t\t   unsigned int chan)\n{\n\t \n\tswitch (chan) {\n\tcase 0:\n\t\treturn NI_PFI_OUTPUT_AI_START1;\n\tcase 1:\n\t\treturn NI_PFI_OUTPUT_AI_START2;\n\tcase 2:\n\t\treturn NI_PFI_OUTPUT_AI_CONVERT;\n\tcase 3:\n\t\treturn NI_PFI_OUTPUT_G_SRC1;\n\tcase 4:\n\t\treturn NI_PFI_OUTPUT_G_GATE1;\n\tcase 5:\n\t\treturn NI_PFI_OUTPUT_AO_UPDATE_N;\n\tcase 6:\n\t\treturn NI_PFI_OUTPUT_AO_START1;\n\tcase 7:\n\t\treturn NI_PFI_OUTPUT_AI_START_PULSE;\n\tcase 8:\n\t\treturn NI_PFI_OUTPUT_G_SRC0;\n\tcase 9:\n\t\treturn NI_PFI_OUTPUT_G_GATE0;\n\tdefault:\n\t\tdev_err(dev->class_dev, \"bug, unhandled case in switch.\\n\");\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int ni_old_set_pfi_routing(struct comedi_device *dev,\n\t\t\t\t  unsigned int chan, unsigned int source)\n{\n\t \n\tif (source != ni_old_get_pfi_routing(dev, chan))\n\t\treturn -EINVAL;\n\treturn 2;\n}\n\nstatic unsigned int ni_m_series_get_pfi_routing(struct comedi_device *dev,\n\t\t\t\t\t\tunsigned int chan)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tconst unsigned int array_offset = chan / 3;\n\n\treturn NI_M_PFI_OUT_SEL_TO_SRC(chan,\n\t\t\t\tdevpriv->pfi_output_select_reg[array_offset]);\n}\n\nstatic int ni_m_series_set_pfi_routing(struct comedi_device *dev,\n\t\t\t\t       unsigned int chan, unsigned int source)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tunsigned int index = chan / 3;\n\tunsigned short val = devpriv->pfi_output_select_reg[index];\n\n\tif ((source & 0x1f) != source)\n\t\treturn -EINVAL;\n\n\tval &= ~NI_M_PFI_OUT_SEL_MASK(chan);\n\tval |= NI_M_PFI_OUT_SEL(chan, source);\n\tni_writew(dev, val, NI_M_PFI_OUT_SEL_REG(index));\n\tdevpriv->pfi_output_select_reg[index] = val;\n\n\treturn 2;\n}\n\nstatic unsigned int ni_get_pfi_routing(struct comedi_device *dev,\n\t\t\t\t       unsigned int chan)\n{\n\tstruct ni_private *devpriv = dev->private;\n\n\tif (chan >= NI_PFI(0)) {\n\t\t \n\t\tchan -= NI_PFI(0);\n\t}\n\treturn (devpriv->is_m_series)\n\t\t\t? ni_m_series_get_pfi_routing(dev, chan)\n\t\t\t: ni_old_get_pfi_routing(dev, chan);\n}\n\n \nstatic int ni_set_pfi_routing(struct comedi_device *dev,\n\t\t\t      unsigned int chan, unsigned int source)\n{\n\tstruct ni_private *devpriv = dev->private;\n\n\tif (chan >= NI_PFI(0)) {\n\t\t \n\t\tchan -= NI_PFI(0);\n\t}\n\treturn (devpriv->is_m_series)\n\t\t\t? ni_m_series_set_pfi_routing(dev, chan, source)\n\t\t\t: ni_old_set_pfi_routing(dev, chan, source);\n}\n\nstatic int ni_config_pfi_filter(struct comedi_device *dev,\n\t\t\t\tunsigned int chan,\n\t\t\t\tenum ni_pfi_filter_select filter)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tunsigned int bits;\n\n\tif (!devpriv->is_m_series)\n\t\treturn -ENOTSUPP;\n\n\tif (chan >= NI_PFI(0)) {\n\t\t \n\t\tchan -= NI_PFI(0);\n\t}\n\n\tbits = ni_readl(dev, NI_M_PFI_FILTER_REG);\n\tbits &= ~NI_M_PFI_FILTER_SEL_MASK(chan);\n\tbits |= NI_M_PFI_FILTER_SEL(chan, filter);\n\tni_writel(dev, bits, NI_M_PFI_FILTER_REG);\n\treturn 0;\n}\n\nstatic void ni_set_pfi_direction(struct comedi_device *dev, int chan,\n\t\t\t\t unsigned int direction)\n{\n\tif (chan >= NI_PFI(0)) {\n\t\t \n\t\tchan -= NI_PFI(0);\n\t}\n\tdirection = (direction == COMEDI_OUTPUT) ? 1u : 0u;\n\tni_set_bits(dev, NISTC_IO_BIDIR_PIN_REG, 1 << chan, direction);\n}\n\nstatic int ni_get_pfi_direction(struct comedi_device *dev, int chan)\n{\n\tstruct ni_private *devpriv = dev->private;\n\n\tif (chan >= NI_PFI(0)) {\n\t\t \n\t\tchan -= NI_PFI(0);\n\t}\n\treturn devpriv->io_bidirection_pin_reg & (1 << chan) ?\n\t       COMEDI_OUTPUT : COMEDI_INPUT;\n}\n\nstatic int ni_pfi_insn_config(struct comedi_device *dev,\n\t\t\t      struct comedi_subdevice *s,\n\t\t\t      struct comedi_insn *insn,\n\t\t\t      unsigned int *data)\n{\n\tunsigned int chan;\n\n\tif (insn->n < 1)\n\t\treturn -EINVAL;\n\n\tchan = CR_CHAN(insn->chanspec);\n\n\tswitch (data[0]) {\n\tcase COMEDI_OUTPUT:\n\tcase COMEDI_INPUT:\n\t\tni_set_pfi_direction(dev, chan, data[0]);\n\t\tbreak;\n\tcase INSN_CONFIG_DIO_QUERY:\n\t\tdata[1] = ni_get_pfi_direction(dev, chan);\n\t\tbreak;\n\tcase INSN_CONFIG_SET_ROUTING:\n\t\treturn ni_set_pfi_routing(dev, chan, data[1]);\n\tcase INSN_CONFIG_GET_ROUTING:\n\t\tdata[1] = ni_get_pfi_routing(dev, chan);\n\t\tbreak;\n\tcase INSN_CONFIG_FILTER:\n\t\treturn ni_config_pfi_filter(dev, chan, data[1]);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int ni_pfi_insn_bits(struct comedi_device *dev,\n\t\t\t    struct comedi_subdevice *s,\n\t\t\t    struct comedi_insn *insn,\n\t\t\t    unsigned int *data)\n{\n\tstruct ni_private *devpriv = dev->private;\n\n\tif (!devpriv->is_m_series)\n\t\treturn -ENOTSUPP;\n\n\tif (comedi_dio_update_state(s, data))\n\t\tni_writew(dev, s->state, NI_M_PFI_DO_REG);\n\n\tdata[1] = ni_readw(dev, NI_M_PFI_DI_REG);\n\n\treturn insn->n;\n}\n\nstatic int cs5529_wait_for_idle(struct comedi_device *dev)\n{\n\tunsigned short status;\n\tconst int timeout = HZ;\n\tint i;\n\n\tfor (i = 0; i < timeout; i++) {\n\t\tstatus = ni_ao_win_inw(dev, NI67XX_CAL_STATUS_REG);\n\t\tif ((status & NI67XX_CAL_STATUS_BUSY) == 0)\n\t\t\tbreak;\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (schedule_timeout(1))\n\t\t\treturn -EIO;\n\t}\n\tif (i == timeout) {\n\t\tdev_err(dev->class_dev, \"timeout\\n\");\n\t\treturn -ETIME;\n\t}\n\treturn 0;\n}\n\nstatic void cs5529_command(struct comedi_device *dev, unsigned short value)\n{\n\tstatic const int timeout = 100;\n\tint i;\n\n\tni_ao_win_outw(dev, value, NI67XX_CAL_CMD_REG);\n\t \n\tfor (i = 0; i < timeout; i++) {\n\t\tif (ni_ao_win_inw(dev, NI67XX_CAL_STATUS_REG) &\n\t\t    NI67XX_CAL_STATUS_BUSY)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\tif (i == timeout)\n\t\tdev_err(dev->class_dev,\n\t\t\t\"possible problem - never saw adc go busy?\\n\");\n}\n\nstatic int cs5529_do_conversion(struct comedi_device *dev,\n\t\t\t\tunsigned short *data)\n{\n\tint retval;\n\tunsigned short status;\n\n\tcs5529_command(dev, CS5529_CMD_CB | CS5529_CMD_SINGLE_CONV);\n\tretval = cs5529_wait_for_idle(dev);\n\tif (retval) {\n\t\tdev_err(dev->class_dev,\n\t\t\t\"timeout or signal in %s()\\n\", __func__);\n\t\treturn -ETIME;\n\t}\n\tstatus = ni_ao_win_inw(dev, NI67XX_CAL_STATUS_REG);\n\tif (status & NI67XX_CAL_STATUS_OSC_DETECT) {\n\t\tdev_err(dev->class_dev,\n\t\t\t\"cs5529 conversion error, status CSS_OSC_DETECT\\n\");\n\t\treturn -EIO;\n\t}\n\tif (status & NI67XX_CAL_STATUS_OVERRANGE) {\n\t\tdev_err(dev->class_dev,\n\t\t\t\"cs5529 conversion error, overrange (ignoring)\\n\");\n\t}\n\tif (data) {\n\t\t*data = ni_ao_win_inw(dev, NI67XX_CAL_DATA_REG);\n\t\t \n\t\t*data ^= BIT(15);\n\t}\n\treturn 0;\n}\n\nstatic int cs5529_ai_insn_read(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       struct comedi_insn *insn,\n\t\t\t       unsigned int *data)\n{\n\tint n, retval;\n\tunsigned short sample;\n\tunsigned int channel_select;\n\tconst unsigned int INTERNAL_REF = 0x1000;\n\n\t \n\tif (insn->chanspec & CR_ALT_SOURCE)\n\t\tchannel_select = INTERNAL_REF;\n\telse\n\t\tchannel_select = CR_CHAN(insn->chanspec);\n\tni_ao_win_outw(dev, channel_select, NI67XX_AO_CAL_CHAN_SEL_REG);\n\n\tfor (n = 0; n < insn->n; n++) {\n\t\tretval = cs5529_do_conversion(dev, &sample);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t\tdata[n] = sample;\n\t}\n\treturn insn->n;\n}\n\nstatic void cs5529_config_write(struct comedi_device *dev, unsigned int value,\n\t\t\t\tunsigned int reg_select_bits)\n{\n\tni_ao_win_outw(dev, (value >> 16) & 0xff, NI67XX_CAL_CFG_HI_REG);\n\tni_ao_win_outw(dev, value & 0xffff, NI67XX_CAL_CFG_LO_REG);\n\treg_select_bits &= CS5529_CMD_REG_MASK;\n\tcs5529_command(dev, CS5529_CMD_CB | reg_select_bits);\n\tif (cs5529_wait_for_idle(dev))\n\t\tdev_err(dev->class_dev,\n\t\t\t\"timeout or signal in %s\\n\", __func__);\n}\n\nstatic int init_cs5529(struct comedi_device *dev)\n{\n\tunsigned int config_bits = CS5529_CFG_PORT_FLAG |\n\t\t\t\t   CS5529_CFG_WORD_RATE_2180;\n\n#if 1\n\t \n\tcs5529_config_write(dev, config_bits | CS5529_CFG_CALIB_BOTH_SELF,\n\t\t\t    CS5529_CFG_REG);\n\t \n\tcs5529_do_conversion(dev, NULL);\n#else\n\t \n\tcs5529_config_write(dev, 0x400000, CS5529_GAIN_REG);\n\tcs5529_config_write(dev, config_bits | CS5529_CFG_CALIB_OFFSET_SELF,\n\t\t\t    CS5529_CFG_REG);\n\tif (cs5529_wait_for_idle(dev))\n\t\tdev_err(dev->class_dev,\n\t\t\t\"timeout or signal in %s\\n\", __func__);\n#endif\n\treturn 0;\n}\n\n \nstatic int ni_mseries_get_pll_parameters(unsigned int reference_period_ns,\n\t\t\t\t\t unsigned int *freq_divider,\n\t\t\t\t\t unsigned int *freq_multiplier,\n\t\t\t\t\t unsigned int *actual_period_ns)\n{\n\tunsigned int div;\n\tunsigned int best_div = 1;\n\tunsigned int mult;\n\tunsigned int best_mult = 1;\n\tstatic const unsigned int pico_per_nano = 1000;\n\tconst unsigned int reference_picosec = reference_period_ns *\n\t\t\t\t\t       pico_per_nano;\n\t \n\tstatic const unsigned int target_picosec = 12500;\n\tint best_period_picosec = 0;\n\n\tfor (div = 1; div <= NI_M_PLL_MAX_DIVISOR; ++div) {\n\t\tfor (mult = 1; mult <= NI_M_PLL_MAX_MULTIPLIER; ++mult) {\n\t\t\tunsigned int new_period_ps =\n\t\t\t    (reference_picosec * div) / mult;\n\t\t\tif (abs(new_period_ps - target_picosec) <\n\t\t\t    abs(best_period_picosec - target_picosec)) {\n\t\t\t\tbest_period_picosec = new_period_ps;\n\t\t\t\tbest_div = div;\n\t\t\t\tbest_mult = mult;\n\t\t\t}\n\t\t}\n\t}\n\tif (best_period_picosec == 0)\n\t\treturn -EIO;\n\n\t*freq_divider = best_div;\n\t*freq_multiplier = best_mult;\n\t \n\t*actual_period_ns = DIV_ROUND_CLOSEST(best_period_picosec * 4,\n\t\t\t\t\t      pico_per_nano);\n\treturn 0;\n}\n\nstatic int ni_mseries_set_pll_master_clock(struct comedi_device *dev,\n\t\t\t\t\t   unsigned int source,\n\t\t\t\t\t   unsigned int period_ns)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tstatic const unsigned int min_period_ns = 50;\n\tstatic const unsigned int max_period_ns = 1000;\n\tstatic const unsigned int timeout = 1000;\n\tunsigned int pll_control_bits;\n\tunsigned int freq_divider;\n\tunsigned int freq_multiplier;\n\tunsigned int rtsi;\n\tunsigned int i;\n\tint retval;\n\n\tif (source == NI_MIO_PLL_PXI10_CLOCK)\n\t\tperiod_ns = 100;\n\t \n\tif (period_ns < min_period_ns || period_ns > max_period_ns) {\n\t\tdev_err(dev->class_dev,\n\t\t\t\"%s: you must specify an input clock frequency between %i and %i nanosec for the phased-lock loop\\n\",\n\t\t\t__func__, min_period_ns, max_period_ns);\n\t\treturn -EINVAL;\n\t}\n\tdevpriv->rtsi_trig_direction_reg &= ~NISTC_RTSI_TRIG_USE_CLK;\n\tni_stc_writew(dev, devpriv->rtsi_trig_direction_reg,\n\t\t      NISTC_RTSI_TRIG_DIR_REG);\n\tpll_control_bits = NI_M_PLL_CTRL_ENA | NI_M_PLL_CTRL_VCO_MODE_75_150MHZ;\n\tdevpriv->clock_and_fout2 |= NI_M_CLK_FOUT2_TIMEBASE1_PLL |\n\t\t\t\t    NI_M_CLK_FOUT2_TIMEBASE3_PLL;\n\tdevpriv->clock_and_fout2 &= ~NI_M_CLK_FOUT2_PLL_SRC_MASK;\n\tswitch (source) {\n\tcase NI_MIO_PLL_PXI_STAR_TRIGGER_CLOCK:\n\t\tdevpriv->clock_and_fout2 |= NI_M_CLK_FOUT2_PLL_SRC_STAR;\n\t\tbreak;\n\tcase NI_MIO_PLL_PXI10_CLOCK:\n\t\t \n\t\tdevpriv->clock_and_fout2 |= NI_M_CLK_FOUT2_PLL_SRC_PXI10;\n\t\tbreak;\n\tdefault:\n\t\tfor (rtsi = 0; rtsi <= NI_M_MAX_RTSI_CHAN; ++rtsi) {\n\t\t\tif (source == NI_MIO_PLL_RTSI_CLOCK(rtsi)) {\n\t\t\t\tdevpriv->clock_and_fout2 |=\n\t\t\t\t\tNI_M_CLK_FOUT2_PLL_SRC_RTSI(rtsi);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (rtsi > NI_M_MAX_RTSI_CHAN)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\tretval = ni_mseries_get_pll_parameters(period_ns,\n\t\t\t\t\t       &freq_divider,\n\t\t\t\t\t       &freq_multiplier,\n\t\t\t\t\t       &devpriv->clock_ns);\n\tif (retval < 0) {\n\t\tdev_err(dev->class_dev,\n\t\t\t\"bug, failed to find pll parameters\\n\");\n\t\treturn retval;\n\t}\n\n\tni_writew(dev, devpriv->clock_and_fout2, NI_M_CLK_FOUT2_REG);\n\tpll_control_bits |= NI_M_PLL_CTRL_DIVISOR(freq_divider) |\n\t\t\t    NI_M_PLL_CTRL_MULTIPLIER(freq_multiplier);\n\n\tni_writew(dev, pll_control_bits, NI_M_PLL_CTRL_REG);\n\tdevpriv->clock_source = source;\n\t \n\tfor (i = 0; i < timeout; ++i) {\n\t\tif (ni_readw(dev, NI_M_PLL_STATUS_REG) & NI_M_PLL_STATUS_LOCKED)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\tif (i == timeout) {\n\t\tdev_err(dev->class_dev,\n\t\t\t\"%s: timed out waiting for PLL to lock to reference clock source %i with period %i ns\\n\",\n\t\t\t__func__, source, period_ns);\n\t\treturn -ETIMEDOUT;\n\t}\n\treturn 3;\n}\n\nstatic int ni_set_master_clock(struct comedi_device *dev,\n\t\t\t       unsigned int source, unsigned int period_ns)\n{\n\tstruct ni_private *devpriv = dev->private;\n\n\tif (source == NI_MIO_INTERNAL_CLOCK) {\n\t\tdevpriv->rtsi_trig_direction_reg &= ~NISTC_RTSI_TRIG_USE_CLK;\n\t\tni_stc_writew(dev, devpriv->rtsi_trig_direction_reg,\n\t\t\t      NISTC_RTSI_TRIG_DIR_REG);\n\t\tdevpriv->clock_ns = TIMEBASE_1_NS;\n\t\tif (devpriv->is_m_series) {\n\t\t\tdevpriv->clock_and_fout2 &=\n\t\t\t    ~(NI_M_CLK_FOUT2_TIMEBASE1_PLL |\n\t\t\t      NI_M_CLK_FOUT2_TIMEBASE3_PLL);\n\t\t\tni_writew(dev, devpriv->clock_and_fout2,\n\t\t\t\t  NI_M_CLK_FOUT2_REG);\n\t\t\tni_writew(dev, 0, NI_M_PLL_CTRL_REG);\n\t\t}\n\t\tdevpriv->clock_source = source;\n\t} else {\n\t\tif (devpriv->is_m_series) {\n\t\t\treturn ni_mseries_set_pll_master_clock(dev, source,\n\t\t\t\t\t\t\t       period_ns);\n\t\t} else {\n\t\t\tif (source == NI_MIO_RTSI_CLOCK) {\n\t\t\t\tdevpriv->rtsi_trig_direction_reg |=\n\t\t\t\t    NISTC_RTSI_TRIG_USE_CLK;\n\t\t\t\tni_stc_writew(dev,\n\t\t\t\t\t      devpriv->rtsi_trig_direction_reg,\n\t\t\t\t\t      NISTC_RTSI_TRIG_DIR_REG);\n\t\t\t\tif (period_ns == 0) {\n\t\t\t\t\tdev_err(dev->class_dev,\n\t\t\t\t\t\t\"we don't handle an unspecified clock period correctly yet, returning error\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tdevpriv->clock_ns = period_ns;\n\t\t\t\tdevpriv->clock_source = source;\n\t\t\t} else {\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\treturn 3;\n}\n\nstatic int ni_valid_rtsi_output_source(struct comedi_device *dev,\n\t\t\t\t       unsigned int chan, unsigned int source)\n{\n\tstruct ni_private *devpriv = dev->private;\n\n\tif (chan >= NISTC_RTSI_TRIG_NUM_CHAN(devpriv->is_m_series)) {\n\t\tif (chan == NISTC_RTSI_TRIG_OLD_CLK_CHAN) {\n\t\t\tif (source == NI_RTSI_OUTPUT_RTSI_OSC)\n\t\t\t\treturn 1;\n\n\t\t\tdev_err(dev->class_dev,\n\t\t\t\t\"%s: invalid source for channel=%i, channel %i is always the RTSI clock for pre-m-series boards\\n\",\n\t\t\t\t__func__, chan, NISTC_RTSI_TRIG_OLD_CLK_CHAN);\n\t\t\treturn 0;\n\t\t}\n\t\treturn 0;\n\t}\n\tswitch (source) {\n\tcase NI_RTSI_OUTPUT_ADR_START1:\n\tcase NI_RTSI_OUTPUT_ADR_START2:\n\tcase NI_RTSI_OUTPUT_SCLKG:\n\tcase NI_RTSI_OUTPUT_DACUPDN:\n\tcase NI_RTSI_OUTPUT_DA_START1:\n\tcase NI_RTSI_OUTPUT_G_SRC0:\n\tcase NI_RTSI_OUTPUT_G_GATE0:\n\tcase NI_RTSI_OUTPUT_RGOUT0:\n\tcase NI_RTSI_OUTPUT_RTSI_BRD(0):\n\tcase NI_RTSI_OUTPUT_RTSI_BRD(1):\n\tcase NI_RTSI_OUTPUT_RTSI_BRD(2):\n\tcase NI_RTSI_OUTPUT_RTSI_BRD(3):\n\t\treturn 1;\n\tcase NI_RTSI_OUTPUT_RTSI_OSC:\n\t\treturn (devpriv->is_m_series) ? 1 : 0;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int ni_set_rtsi_routing(struct comedi_device *dev,\n\t\t\t       unsigned int chan, unsigned int src)\n{\n\tstruct ni_private *devpriv = dev->private;\n\n\tif (chan >= TRIGGER_LINE(0))\n\t\t \n\t\tchan -= TRIGGER_LINE(0);\n\n\tif (ni_valid_rtsi_output_source(dev, chan, src) == 0)\n\t\treturn -EINVAL;\n\tif (chan < 4) {\n\t\tdevpriv->rtsi_trig_a_output_reg &= ~NISTC_RTSI_TRIG_MASK(chan);\n\t\tdevpriv->rtsi_trig_a_output_reg |= NISTC_RTSI_TRIG(chan, src);\n\t\tni_stc_writew(dev, devpriv->rtsi_trig_a_output_reg,\n\t\t\t      NISTC_RTSI_TRIGA_OUT_REG);\n\t} else if (chan < NISTC_RTSI_TRIG_NUM_CHAN(devpriv->is_m_series)) {\n\t\tdevpriv->rtsi_trig_b_output_reg &= ~NISTC_RTSI_TRIG_MASK(chan);\n\t\tdevpriv->rtsi_trig_b_output_reg |= NISTC_RTSI_TRIG(chan, src);\n\t\tni_stc_writew(dev, devpriv->rtsi_trig_b_output_reg,\n\t\t\t      NISTC_RTSI_TRIGB_OUT_REG);\n\t} else if (chan != NISTC_RTSI_TRIG_OLD_CLK_CHAN) {\n\t\t \n\t\tdev_err(dev->class_dev, \"%s: unknown rtsi channel\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\treturn 2;\n}\n\nstatic unsigned int ni_get_rtsi_routing(struct comedi_device *dev,\n\t\t\t\t\tunsigned int chan)\n{\n\tstruct ni_private *devpriv = dev->private;\n\n\tif (chan >= TRIGGER_LINE(0))\n\t\t \n\t\tchan -= TRIGGER_LINE(0);\n\n\tif (chan < 4) {\n\t\treturn NISTC_RTSI_TRIG_TO_SRC(chan,\n\t\t\t\t\t      devpriv->rtsi_trig_a_output_reg);\n\t} else if (chan < NISTC_RTSI_TRIG_NUM_CHAN(devpriv->is_m_series)) {\n\t\treturn NISTC_RTSI_TRIG_TO_SRC(chan,\n\t\t\t\t\t      devpriv->rtsi_trig_b_output_reg);\n\t} else if (chan == NISTC_RTSI_TRIG_OLD_CLK_CHAN) {\n\t\treturn NI_RTSI_OUTPUT_RTSI_OSC;\n\t}\n\n\tdev_err(dev->class_dev, \"%s: unknown rtsi channel\\n\", __func__);\n\treturn -EINVAL;\n}\n\nstatic void ni_set_rtsi_direction(struct comedi_device *dev, int chan,\n\t\t\t\t  unsigned int direction)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tunsigned int max_chan = NISTC_RTSI_TRIG_NUM_CHAN(devpriv->is_m_series);\n\n\tif (chan >= TRIGGER_LINE(0))\n\t\t \n\t\tchan -= TRIGGER_LINE(0);\n\n\tif (direction == COMEDI_OUTPUT) {\n\t\tif (chan < max_chan) {\n\t\t\tdevpriv->rtsi_trig_direction_reg |=\n\t\t\t    NISTC_RTSI_TRIG_DIR(chan, devpriv->is_m_series);\n\t\t} else if (chan == NISTC_RTSI_TRIG_OLD_CLK_CHAN) {\n\t\t\tdevpriv->rtsi_trig_direction_reg |=\n\t\t\t    NISTC_RTSI_TRIG_DRV_CLK;\n\t\t}\n\t} else {\n\t\tif (chan < max_chan) {\n\t\t\tdevpriv->rtsi_trig_direction_reg &=\n\t\t\t    ~NISTC_RTSI_TRIG_DIR(chan, devpriv->is_m_series);\n\t\t} else if (chan == NISTC_RTSI_TRIG_OLD_CLK_CHAN) {\n\t\t\tdevpriv->rtsi_trig_direction_reg &=\n\t\t\t    ~NISTC_RTSI_TRIG_DRV_CLK;\n\t\t}\n\t}\n\tni_stc_writew(dev, devpriv->rtsi_trig_direction_reg,\n\t\t      NISTC_RTSI_TRIG_DIR_REG);\n}\n\nstatic int ni_get_rtsi_direction(struct comedi_device *dev, int chan)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tunsigned int max_chan = NISTC_RTSI_TRIG_NUM_CHAN(devpriv->is_m_series);\n\n\tif (chan >= TRIGGER_LINE(0))\n\t\t \n\t\tchan -= TRIGGER_LINE(0);\n\n\tif (chan < max_chan) {\n\t\treturn (devpriv->rtsi_trig_direction_reg &\n\t\t\tNISTC_RTSI_TRIG_DIR(chan, devpriv->is_m_series))\n\t\t\t   ? COMEDI_OUTPUT : COMEDI_INPUT;\n\t} else if (chan == NISTC_RTSI_TRIG_OLD_CLK_CHAN) {\n\t\treturn (devpriv->rtsi_trig_direction_reg &\n\t\t\tNISTC_RTSI_TRIG_DRV_CLK)\n\t\t\t   ? COMEDI_OUTPUT : COMEDI_INPUT;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int ni_rtsi_insn_config(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       struct comedi_insn *insn,\n\t\t\t       unsigned int *data)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\n\tswitch (data[0]) {\n\tcase COMEDI_OUTPUT:\n\tcase COMEDI_INPUT:\n\t\tni_set_rtsi_direction(dev, chan, data[0]);\n\t\tbreak;\n\tcase INSN_CONFIG_DIO_QUERY: {\n\t\tint ret = ni_get_rtsi_direction(dev, chan);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tdata[1] = ret;\n\t\treturn 2;\n\t}\n\tcase INSN_CONFIG_SET_CLOCK_SRC:\n\t\treturn ni_set_master_clock(dev, data[1], data[2]);\n\tcase INSN_CONFIG_GET_CLOCK_SRC:\n\t\tdata[1] = devpriv->clock_source;\n\t\tdata[2] = devpriv->clock_ns;\n\t\treturn 3;\n\tcase INSN_CONFIG_SET_ROUTING:\n\t\treturn ni_set_rtsi_routing(dev, chan, data[1]);\n\tcase INSN_CONFIG_GET_ROUTING: {\n\t\tint ret = ni_get_rtsi_routing(dev, chan);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tdata[1] = ret;\n\t\treturn 2;\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 1;\n}\n\nstatic int ni_rtsi_insn_bits(struct comedi_device *dev,\n\t\t\t     struct comedi_subdevice *s,\n\t\t\t     struct comedi_insn *insn,\n\t\t\t     unsigned int *data)\n{\n\tdata[1] = 0;\n\n\treturn insn->n;\n}\n\n \nstatic const int default_rtsi_routing[] = {\n\t[0] = NI_RTSI_OUTPUT_ADR_START1,\n\t[1] = NI_RTSI_OUTPUT_ADR_START2,\n\t[2] = NI_RTSI_OUTPUT_SCLKG,\n\t[3] = NI_RTSI_OUTPUT_DACUPDN,\n\t[4] = NI_RTSI_OUTPUT_DA_START1,\n\t[5] = NI_RTSI_OUTPUT_G_SRC0,\n\t[6] = NI_RTSI_OUTPUT_G_GATE0,\n\t[7] = NI_RTSI_OUTPUT_RTSI_OSC,\n};\n\n \nstatic void set_rgout0_reg(int reg, struct comedi_device *dev)\n{\n\tstruct ni_private *devpriv = dev->private;\n\n\tif (devpriv->is_m_series) {\n\t\tdevpriv->rtsi_trig_direction_reg &=\n\t\t\t~NISTC_RTSI_TRIG_DIR_SUB_SEL1;\n\t\tdevpriv->rtsi_trig_direction_reg |=\n\t\t\t(reg << NISTC_RTSI_TRIG_DIR_SUB_SEL1_SHIFT) &\n\t\t\tNISTC_RTSI_TRIG_DIR_SUB_SEL1;\n\t\tni_stc_writew(dev, devpriv->rtsi_trig_direction_reg,\n\t\t\t      NISTC_RTSI_TRIG_DIR_REG);\n\t} else {\n\t\tdevpriv->rtsi_trig_b_output_reg &= ~NISTC_RTSI_TRIGB_SUB_SEL1;\n\t\tdevpriv->rtsi_trig_b_output_reg |=\n\t\t\t(reg << NISTC_RTSI_TRIGB_SUB_SEL1_SHIFT) &\n\t\t\tNISTC_RTSI_TRIGB_SUB_SEL1;\n\t\tni_stc_writew(dev, devpriv->rtsi_trig_b_output_reg,\n\t\t\t      NISTC_RTSI_TRIGB_OUT_REG);\n\t}\n}\n\nstatic int get_rgout0_reg(struct comedi_device *dev)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tint reg;\n\n\tif (devpriv->is_m_series)\n\t\treg = (devpriv->rtsi_trig_direction_reg &\n\t\t       NISTC_RTSI_TRIG_DIR_SUB_SEL1)\n\t\t    >> NISTC_RTSI_TRIG_DIR_SUB_SEL1_SHIFT;\n\telse\n\t\treg = (devpriv->rtsi_trig_b_output_reg &\n\t\t       NISTC_RTSI_TRIGB_SUB_SEL1)\n\t\t    >> NISTC_RTSI_TRIGB_SUB_SEL1_SHIFT;\n\treturn reg;\n}\n\nstatic inline int get_rgout0_src(struct comedi_device *dev)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tint reg = get_rgout0_reg(dev);\n\n\treturn ni_find_route_source(reg, NI_RGOUT0, &devpriv->routing_tables);\n}\n\n \nstatic int incr_rgout0_src_use(int src, struct comedi_device *dev)\n{\n\tstruct ni_private *devpriv = dev->private;\n\ts8 reg = ni_lookup_route_register(CR_CHAN(src), NI_RGOUT0,\n\t\t\t\t\t  &devpriv->routing_tables);\n\n\tif (reg < 0)\n\t\treturn -EINVAL;\n\n\tif (devpriv->rgout0_usage > 0 && get_rgout0_reg(dev) != reg)\n\t\treturn -EBUSY;\n\n\t++devpriv->rgout0_usage;\n\tset_rgout0_reg(reg, dev);\n\treturn 0;\n}\n\n \nstatic int decr_rgout0_src_use(int src, struct comedi_device *dev)\n{\n\tstruct ni_private *devpriv = dev->private;\n\ts8 reg = ni_lookup_route_register(CR_CHAN(src), NI_RGOUT0,\n\t\t\t\t\t  &devpriv->routing_tables);\n\n\tif (devpriv->rgout0_usage > 0 && get_rgout0_reg(dev) == reg) {\n\t\t--devpriv->rgout0_usage;\n\t\tif (!devpriv->rgout0_usage)\n\t\t\tset_rgout0_reg(0, dev);  \n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\n \nstatic void set_ith_rtsi_brd_reg(int i, int reg, struct comedi_device *dev)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tint reg_i_sz = 3;  \n\tint reg_i_mask;\n\tint reg_i_shift;\n\n\tif (devpriv->is_m_series)\n\t\treg_i_sz = 4;\n\treg_i_mask = ~((~0) << reg_i_sz);\n\treg_i_shift = i * reg_i_sz;\n\n\t \n\tdevpriv->rtsi_shared_mux_reg &= ~(reg_i_mask       << reg_i_shift);\n\t \n\tdevpriv->rtsi_shared_mux_reg |= (reg & reg_i_mask) << reg_i_shift;\n\t \n\tni_stc_writew(dev, devpriv->rtsi_shared_mux_reg, NISTC_RTSI_BOARD_REG);\n}\n\nstatic int get_ith_rtsi_brd_reg(int i, struct comedi_device *dev)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tint reg_i_sz = 3;  \n\tint reg_i_mask;\n\tint reg_i_shift;\n\n\tif (devpriv->is_m_series)\n\t\treg_i_sz = 4;\n\treg_i_mask = ~((~0) << reg_i_sz);\n\treg_i_shift = i * reg_i_sz;\n\n\treturn (devpriv->rtsi_shared_mux_reg >> reg_i_shift) & reg_i_mask;\n}\n\nstatic inline int get_rtsi_brd_src(int brd, struct comedi_device *dev)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tint brd_index = brd;\n\tint reg;\n\n\tif (brd >= NI_RTSI_BRD(0))\n\t\tbrd_index = brd - NI_RTSI_BRD(0);\n\telse\n\t\tbrd = NI_RTSI_BRD(brd);\n\t \n\n\treg = get_ith_rtsi_brd_reg(brd_index, dev);\n\n\treturn ni_find_route_source(reg, brd, &devpriv->routing_tables);\n}\n\n \nstatic int incr_rtsi_brd_src_use(int src, struct comedi_device *dev)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tint first_available = -1;\n\tint err = -EINVAL;\n\ts8 reg;\n\tint i;\n\n\t \n\tfor (i = 0; i < NUM_RTSI_SHARED_MUXS; ++i) {\n\t\treg = ni_lookup_route_register(CR_CHAN(src), NI_RTSI_BRD(i),\n\t\t\t\t\t       &devpriv->routing_tables);\n\n\t\tif (reg < 0)\n\t\t\tcontinue;  \n\n\t\tif (!devpriv->rtsi_shared_mux_usage[i]) {\n\t\t\tif (first_available < 0)\n\t\t\t\t \n\t\t\t\tfirst_available = i;\n\t\t} else {\n\t\t\t \n\t\t\terr = -EBUSY;\n\n\t\t\tif (get_ith_rtsi_brd_reg(i, dev) == reg) {\n\t\t\t\t \n\t\t\t\tgoto success;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (first_available < 0)\n\t\treturn err;\n\n\t \n\ti = first_available;\n\nsuccess:\n\t++devpriv->rtsi_shared_mux_usage[i];\n\tset_ith_rtsi_brd_reg(i, reg, dev);\n\treturn NI_RTSI_BRD(i);\n}\n\n \nstatic int decr_rtsi_brd_src_use(int src, int rtsi_brd,\n\t\t\t\t struct comedi_device *dev)\n{\n\tstruct ni_private *devpriv = dev->private;\n\ts8 reg = ni_lookup_route_register(CR_CHAN(src), rtsi_brd,\n\t\t\t\t\t  &devpriv->routing_tables);\n\tconst int i = rtsi_brd - NI_RTSI_BRD(0);\n\n\tif (devpriv->rtsi_shared_mux_usage[i] > 0 &&\n\t    get_ith_rtsi_brd_reg(i, dev) == reg) {\n\t\t--devpriv->rtsi_shared_mux_usage[i];\n\t\tif (!devpriv->rtsi_shared_mux_usage[i])\n\t\t\tset_ith_rtsi_brd_reg(i, 0, dev);  \n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic void ni_rtsi_init(struct comedi_device *dev)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tint i;\n\n\t \n\n\t \n\tdevpriv->clock_and_fout2 = NI_M_CLK_FOUT2_RTSI_10MHZ;\n\t \n\tif (ni_set_master_clock(dev, NI_MIO_INTERNAL_CLOCK, 0) < 0)\n\t\tdev_err(dev->class_dev, \"ni_set_master_clock failed, bug?\\n\");\n\n\t \n\tfor (i = 0; i < 8; ++i) {\n\t\tni_set_rtsi_direction(dev, i, COMEDI_INPUT);\n\t\tni_set_rtsi_routing(dev, i, default_rtsi_routing[i]);\n\t}\n\n\t \n\tdevpriv->rtsi_shared_mux_reg = 0;\n\tfor (i = 0; i < 4; ++i)\n\t\tset_ith_rtsi_brd_reg(i, 0, dev);\n\tmemset(devpriv->rtsi_shared_mux_usage, 0,\n\t       sizeof(devpriv->rtsi_shared_mux_usage));\n\n\t \n\tdevpriv->rgout0_usage = 0;\n\tset_rgout0_reg(0, dev);\n}\n\n \nstatic inline int ni_get_gout_routing(unsigned int dest,\n\t\t\t\t      struct comedi_device *dev)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tunsigned int reg = devpriv->an_trig_etc_reg;\n\n\tswitch (dest) {\n\tcase 0:\n\t\tif (reg & NISTC_ATRIG_ETC_GPFO_0_ENA)\n\t\t\treturn NISTC_ATRIG_ETC_GPFO_0_SEL_TO_SRC(reg);\n\t\tbreak;\n\tcase 1:\n\t\tif (reg & NISTC_ATRIG_ETC_GPFO_1_ENA)\n\t\t\treturn NISTC_ATRIG_ETC_GPFO_1_SEL_TO_SRC(reg);\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\n \nstatic inline int ni_disable_gout_routing(unsigned int dest,\n\t\t\t\t\t  struct comedi_device *dev)\n{\n\tstruct ni_private *devpriv = dev->private;\n\n\tswitch (dest) {\n\tcase 0:\n\t\tdevpriv->an_trig_etc_reg &= ~NISTC_ATRIG_ETC_GPFO_0_ENA;\n\t\tbreak;\n\tcase 1:\n\t\tdevpriv->an_trig_etc_reg &= ~NISTC_ATRIG_ETC_GPFO_1_ENA;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tni_stc_writew(dev, devpriv->an_trig_etc_reg, NISTC_ATRIG_ETC_REG);\n\treturn 0;\n}\n\n \nstatic inline int ni_set_gout_routing(unsigned int src, unsigned int dest,\n\t\t\t\t      struct comedi_device *dev)\n{\n\tstruct ni_private *devpriv = dev->private;\n\n\tswitch (dest) {\n\tcase 0:\n\t\t \n\t\tdevpriv->an_trig_etc_reg &= ~NISTC_ATRIG_ETC_GPFO_0_SEL(-1);\n\t\t \n\t\tdevpriv->an_trig_etc_reg |= NISTC_ATRIG_ETC_GPFO_0_ENA\n\t\t\t\t\t |  NISTC_ATRIG_ETC_GPFO_0_SEL(src);\n\t\tbreak;\n\tcase 1:\n\t\t \n\t\tdevpriv->an_trig_etc_reg &= ~NISTC_ATRIG_ETC_GPFO_1_SEL;\n\t\tsrc = src ? NISTC_ATRIG_ETC_GPFO_1_SEL : 0;\n\t\t \n\t\tdevpriv->an_trig_etc_reg |= NISTC_ATRIG_ETC_GPFO_1_ENA | src;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tni_stc_writew(dev, devpriv->an_trig_etc_reg, NISTC_ATRIG_ETC_REG);\n\treturn 0;\n}\n\n \nstatic int get_output_select_source(int dest, struct comedi_device *dev)\n{\n\tstruct ni_private *devpriv = dev->private;\n\tint reg = -1;\n\n\tif (channel_is_pfi(dest)) {\n\t\tif (ni_get_pfi_direction(dev, dest) == COMEDI_OUTPUT)\n\t\t\treg = ni_get_pfi_routing(dev, dest);\n\t} else if (channel_is_rtsi(dest)) {\n\t\tif (ni_get_rtsi_direction(dev, dest) == COMEDI_OUTPUT) {\n\t\t\treg = ni_get_rtsi_routing(dev, dest);\n\n\t\t\tif (reg == NI_RTSI_OUTPUT_RGOUT0) {\n\t\t\t\tdest = NI_RGOUT0;  \n\t\t\t\treg = get_rgout0_reg(dev);\n\t\t\t} else if (reg >= NI_RTSI_OUTPUT_RTSI_BRD(0) &&\n\t\t\t\t   reg <= NI_RTSI_OUTPUT_RTSI_BRD(3)) {\n\t\t\t\tconst int i = reg - NI_RTSI_OUTPUT_RTSI_BRD(0);\n\n\t\t\t\tdest = NI_RTSI_BRD(i);  \n\t\t\t\treg = get_ith_rtsi_brd_reg(i, dev);\n\t\t\t}\n\t\t}\n\t} else if (dest >= NI_CtrOut(0) && dest <= NI_CtrOut(-1)) {\n\t\t \n\t\tdest -= NI_CtrOut(0);\n\t\tif (dest > 1)\n\t\t\t \n\t\t\treturn -EINVAL;\n\t\treg = ni_get_gout_routing(dest, dev);\n\t} else if (channel_is_ctr(dest)) {\n\t\treg = ni_tio_get_routing(devpriv->counter_dev, dest);\n\t} else {\n\t\tdev_dbg(dev->class_dev, \"%s: unhandled destination (%d) queried\\n\",\n\t\t\t__func__, dest);\n\t}\n\n\tif (reg >= 0)\n\t\treturn ni_find_route_source(CR_CHAN(reg), dest,\n\t\t\t\t\t    &devpriv->routing_tables);\n\treturn -EINVAL;\n}\n\n \nstatic int test_route(unsigned int src, unsigned int dest,\n\t\t      struct comedi_device *dev)\n{\n\tstruct ni_private *devpriv = dev->private;\n\ts8 reg = ni_route_to_register(CR_CHAN(src), dest,\n\t\t\t\t      &devpriv->routing_tables);\n\n\tif (reg < 0)\n\t\treturn -1;\n\tif (get_output_select_source(dest, dev) != CR_CHAN(src))\n\t\treturn 0;\n\treturn 1;\n}\n\n \nstatic int connect_route(unsigned int src, unsigned int dest,\n\t\t\t struct comedi_device *dev)\n{\n\tstruct ni_private *devpriv = dev->private;\n\ts8 reg = ni_route_to_register(CR_CHAN(src), dest,\n\t\t\t\t      &devpriv->routing_tables);\n\ts8 current_src;\n\n\tif (reg < 0)\n\t\t \n\t\treturn -EINVAL;\n\n\tcurrent_src = get_output_select_source(dest, dev);\n\tif (current_src == CR_CHAN(src))\n\t\treturn -EALREADY;\n\tif (current_src >= 0)\n\t\t \n\t\treturn -EBUSY;\n\n\t \n\tif (channel_is_pfi(dest)) {\n\t\t \n\t\tni_set_pfi_routing(dev, dest, reg);\n\t\tni_set_pfi_direction(dev, dest, COMEDI_OUTPUT);\n\t} else if (channel_is_rtsi(dest)) {\n\t\tif (reg == NI_RTSI_OUTPUT_RGOUT0) {\n\t\t\tint ret = incr_rgout0_src_use(src, dev);\n\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t} else if (ni_rtsi_route_requires_mux(reg)) {\n\t\t\t \n\t\t\tint brd = incr_rtsi_brd_src_use(src, dev);\n\n\t\t\tif (brd < 0)\n\t\t\t\treturn brd;\n\n\t\t\t \n\t\t\treg = ni_lookup_route_register(\n\t\t\t\tbrd, dest, &devpriv->routing_tables);\n\t\t}\n\n\t\tni_set_rtsi_direction(dev, dest, COMEDI_OUTPUT);\n\t\tni_set_rtsi_routing(dev, dest, reg);\n\t} else if (dest >= NI_CtrOut(0) && dest <= NI_CtrOut(-1)) {\n\t\t \n\t\tdest -= NI_CtrOut(0);\n\t\tif (dest > 1)\n\t\t\t \n\t\t\treturn -EINVAL;\n\t\tif (ni_set_gout_routing(src, dest, dev))\n\t\t\treturn -EINVAL;\n\t} else if (channel_is_ctr(dest)) {\n\t\t \n\t\tni_tio_set_routing(devpriv->counter_dev, dest,\n\t\t\t\t   reg | (src & ~CR_CHAN(-1)));\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int disconnect_route(unsigned int src, unsigned int dest,\n\t\t\t    struct comedi_device *dev)\n{\n\tstruct ni_private *devpriv = dev->private;\n\ts8 reg = ni_route_to_register(CR_CHAN(src), dest,\n\t\t\t\t      &devpriv->routing_tables);\n\n\tif (reg < 0)\n\t\t \n\t\treturn -EINVAL;\n\tif (get_output_select_source(dest, dev) != src)\n\t\t \n\t\treturn -EINVAL;\n\n\t \n\tif (channel_is_pfi(dest)) {\n\t\t \n\t\tni_set_pfi_direction(dev, dest, COMEDI_INPUT);\n\t\tni_set_pfi_routing(dev, dest, NI_PFI_OUTPUT_PFI_DEFAULT);\n\t} else if (channel_is_rtsi(dest)) {\n\t\tif (reg == NI_RTSI_OUTPUT_RGOUT0) {\n\t\t\tint ret = decr_rgout0_src_use(src, dev);\n\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t} else if (ni_rtsi_route_requires_mux(reg)) {\n\t\t\t \n\t\t\tint brd = ni_find_route_source(\n\t\t\t\tni_get_rtsi_routing(dev, dest), dest,\n\t\t\t\t&devpriv->routing_tables);\n\n\t\t\tif (brd < 0)\n\t\t\t\treturn brd;\n\n\t\t\t \n\t\t\tdecr_rtsi_brd_src_use(src, brd, dev);\n\t\t}\n\n\t\t \n\t\treg = default_rtsi_routing[dest - TRIGGER_LINE(0)];\n\t\tni_set_rtsi_direction(dev, dest, COMEDI_INPUT);\n\t\tni_set_rtsi_routing(dev, dest, reg);\n\t} else if (dest >= NI_CtrOut(0) && dest <= NI_CtrOut(-1)) {\n\t\t \n\t\tdest -= NI_CtrOut(0);\n\t\tif (dest > 1)\n\t\t\t \n\t\t\treturn -EINVAL;\n\t\treg = ni_disable_gout_routing(dest, dev);\n\t} else if (channel_is_ctr(dest)) {\n\t\tni_tio_unset_routing(devpriv->counter_dev, dest);\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int ni_global_insn_config(struct comedi_device *dev,\n\t\t\t\t struct comedi_insn *insn,\n\t\t\t\t unsigned int *data)\n{\n\tswitch (data[0]) {\n\tcase INSN_DEVICE_CONFIG_TEST_ROUTE:\n\t\tdata[0] = test_route(data[1], data[2], dev);\n\t\treturn 2;\n\tcase INSN_DEVICE_CONFIG_CONNECT_ROUTE:\n\t\treturn connect_route(data[1], data[2], dev);\n\tcase INSN_DEVICE_CONFIG_DISCONNECT_ROUTE:\n\t\treturn disconnect_route(data[1], data[2], dev);\n\t \n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 1;\n}\n\n#ifdef PCIDMA\nstatic int ni_gpct_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\n{\n\tstruct ni_gpct *counter = s->private;\n\tint retval;\n\n\tretval = ni_request_gpct_mite_channel(dev, counter->counter_index,\n\t\t\t\t\t      COMEDI_INPUT);\n\tif (retval) {\n\t\tdev_err(dev->class_dev,\n\t\t\t\"no dma channel available for use by counter\\n\");\n\t\treturn retval;\n\t}\n\tni_tio_acknowledge(counter);\n\tni_e_series_enable_second_irq(dev, counter->counter_index, 1);\n\n\treturn ni_tio_cmd(dev, s);\n}\n\nstatic int ni_gpct_cancel(struct comedi_device *dev, struct comedi_subdevice *s)\n{\n\tstruct ni_gpct *counter = s->private;\n\tint retval;\n\n\tretval = ni_tio_cancel(counter);\n\tni_e_series_enable_second_irq(dev, counter->counter_index, 0);\n\tni_release_gpct_mite_channel(dev, counter->counter_index);\n\treturn retval;\n}\n#endif\n\nstatic irqreturn_t ni_E_interrupt(int irq, void *d)\n{\n\tstruct comedi_device *dev = d;\n\tstruct comedi_subdevice *s_ai = dev->read_subdev;\n\tstruct comedi_subdevice *s_ao = dev->write_subdev;\n\tunsigned short a_status;\n\tunsigned short b_status;\n\tunsigned long flags;\n#ifdef PCIDMA\n\tstruct ni_private *devpriv = dev->private;\n#endif\n\n\tif (!dev->attached)\n\t\treturn IRQ_NONE;\n\tsmp_mb();\t\t \n\n\t \n\tspin_lock_irqsave(&dev->spinlock, flags);\n\ta_status = ni_stc_readw(dev, NISTC_AI_STATUS1_REG);\n\tb_status = ni_stc_readw(dev, NISTC_AO_STATUS1_REG);\n#ifdef PCIDMA\n\tif (devpriv->mite) {\n\t\tunsigned long flags_too;\n\n\t\tspin_lock_irqsave(&devpriv->mite_channel_lock, flags_too);\n\t\tif (s_ai && devpriv->ai_mite_chan)\n\t\t\tmite_ack_linkc(devpriv->ai_mite_chan, s_ai, false);\n\t\tif (s_ao && devpriv->ao_mite_chan)\n\t\t\tmite_ack_linkc(devpriv->ao_mite_chan, s_ao, false);\n\t\tspin_unlock_irqrestore(&devpriv->mite_channel_lock, flags_too);\n\t}\n#endif\n\tack_a_interrupt(dev, a_status);\n\tack_b_interrupt(dev, b_status);\n\tif (s_ai) {\n\t\tif (a_status & NISTC_AI_STATUS1_INTA)\n\t\t\thandle_a_interrupt(dev, s_ai, a_status);\n\t\t \n\t\tcomedi_handle_events(dev, s_ai);\n\t}\n\tif (s_ao) {\n\t\tif (b_status & NISTC_AO_STATUS1_INTB)\n\t\t\thandle_b_interrupt(dev, s_ao, b_status);\n\t\t \n\t\tcomedi_handle_events(dev, s_ao);\n\t}\n\thandle_gpct_interrupt(dev, 0);\n\thandle_gpct_interrupt(dev, 1);\n#ifdef PCIDMA\n\tif (devpriv->is_m_series)\n\t\thandle_cdio_interrupt(dev);\n#endif\n\n\tspin_unlock_irqrestore(&dev->spinlock, flags);\n\treturn IRQ_HANDLED;\n}\n\nstatic int ni_alloc_private(struct comedi_device *dev)\n{\n\tstruct ni_private *devpriv;\n\n\tdevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\n\tif (!devpriv)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&devpriv->window_lock);\n\tspin_lock_init(&devpriv->soft_reg_copy_lock);\n\tspin_lock_init(&devpriv->mite_channel_lock);\n\n\treturn 0;\n}\n\nstatic unsigned int _ni_get_valid_routes(struct comedi_device *dev,\n\t\t\t\t\t unsigned int n_pairs,\n\t\t\t\t\t unsigned int *pair_data)\n{\n\tstruct ni_private *devpriv = dev->private;\n\n\treturn ni_get_valid_routes(&devpriv->routing_tables, n_pairs,\n\t\t\t\t   pair_data);\n}\n\nstatic int ni_E_init(struct comedi_device *dev,\n\t\t     unsigned int interrupt_pin, unsigned int irq_polarity)\n{\n\tconst struct ni_board_struct *board = dev->board_ptr;\n\tstruct ni_private *devpriv = dev->private;\n\tstruct comedi_subdevice *s;\n\tint ret;\n\tint i;\n\tconst char *dev_family = devpriv->is_m_series ? \"ni_mseries\"\n\t\t\t\t\t\t      : \"ni_eseries\";\n\n\t \n\tif (ni_assign_device_routes(dev_family, board->name,\n\t\t\t\t    board->alt_route_name,\n\t\t\t\t    &devpriv->routing_tables) < 0) {\n\t\tdev_warn(dev->class_dev, \"%s: %s device has no signal routing table.\\n\",\n\t\t\t __func__, board->name);\n\t\tdev_warn(dev->class_dev, \"%s: High level NI signal names will not be available for this %s board.\\n\",\n\t\t\t __func__, board->name);\n\t} else {\n\t\t \n\t\tdev->insn_device_config = ni_global_insn_config;\n\t\tdev->get_valid_routes = _ni_get_valid_routes;\n\t}\n\n\tif (board->n_aochan > MAX_N_AO_CHAN) {\n\t\tdev_err(dev->class_dev, \"bug! n_aochan > MAX_N_AO_CHAN\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tdevpriv->clock_and_fout = NISTC_CLK_FOUT_SLOW_DIV2 |\n\t\t\t\t  NISTC_CLK_FOUT_SLOW_TIMEBASE |\n\t\t\t\t  NISTC_CLK_FOUT_TO_BOARD_DIV2 |\n\t\t\t\t  NISTC_CLK_FOUT_TO_BOARD;\n\tif (!devpriv->is_6xxx) {\n\t\t \n\t\tdevpriv->clock_and_fout |= (NISTC_CLK_FOUT_AI_OUT_DIV2 |\n\t\t\t\t\t    NISTC_CLK_FOUT_AO_OUT_DIV2);\n\t}\n\tni_stc_writew(dev, devpriv->clock_and_fout, NISTC_CLK_FOUT_REG);\n\n\tret = comedi_alloc_subdevices(dev, NI_NUM_SUBDEVICES);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ts = &dev->subdevices[NI_AI_SUBDEV];\n\tif (board->n_adchan) {\n\t\ts->type\t\t= COMEDI_SUBD_AI;\n\t\ts->subdev_flags\t= SDF_READABLE | SDF_DIFF | SDF_DITHER;\n\t\tif (!devpriv->is_611x)\n\t\t\ts->subdev_flags\t|= SDF_GROUND | SDF_COMMON | SDF_OTHER;\n\t\tif (board->ai_maxdata > 0xffff)\n\t\t\ts->subdev_flags\t|= SDF_LSAMPL;\n\t\tif (devpriv->is_m_series)\n\t\t\ts->subdev_flags\t|= SDF_SOFT_CALIBRATED;\n\t\ts->n_chan\t= board->n_adchan;\n\t\ts->maxdata\t= board->ai_maxdata;\n\t\ts->range_table\t= ni_range_lkup[board->gainlkup];\n\t\ts->insn_read\t= ni_ai_insn_read;\n\t\ts->insn_config\t= ni_ai_insn_config;\n\t\tif (dev->irq) {\n\t\t\tdev->read_subdev = s;\n\t\t\ts->subdev_flags\t|= SDF_CMD_READ;\n\t\t\ts->len_chanlist\t= 512;\n\t\t\ts->do_cmdtest\t= ni_ai_cmdtest;\n\t\t\ts->do_cmd\t= ni_ai_cmd;\n\t\t\ts->cancel\t= ni_ai_reset;\n\t\t\ts->poll\t\t= ni_ai_poll;\n\t\t\ts->munge\t= ni_ai_munge;\n\n\t\t\tif (devpriv->mite)\n\t\t\t\ts->async_dma_dir = DMA_FROM_DEVICE;\n\t\t}\n\n\t\t \n\t\tni_ai_reset(dev, s);\n\t} else {\n\t\ts->type\t\t= COMEDI_SUBD_UNUSED;\n\t}\n\n\t \n\ts = &dev->subdevices[NI_AO_SUBDEV];\n\tif (board->n_aochan) {\n\t\ts->type\t\t= COMEDI_SUBD_AO;\n\t\ts->subdev_flags\t= SDF_WRITABLE | SDF_DEGLITCH | SDF_GROUND;\n\t\tif (devpriv->is_m_series)\n\t\t\ts->subdev_flags\t|= SDF_SOFT_CALIBRATED;\n\t\ts->n_chan\t= board->n_aochan;\n\t\ts->maxdata\t= board->ao_maxdata;\n\t\ts->range_table\t= board->ao_range_table;\n\t\ts->insn_config\t= ni_ao_insn_config;\n\t\ts->insn_write\t= ni_ao_insn_write;\n\n\t\tret = comedi_alloc_subdev_readback(s);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tif (dev->irq && (board->ao_fifo_depth || devpriv->mite)) {\n\t\t\tdev->write_subdev = s;\n\t\t\ts->subdev_flags\t|= SDF_CMD_WRITE;\n\t\t\ts->len_chanlist\t= s->n_chan;\n\t\t\ts->do_cmdtest\t= ni_ao_cmdtest;\n\t\t\ts->do_cmd\t= ni_ao_cmd;\n\t\t\ts->cancel\t= ni_ao_reset;\n\t\t\tif (!devpriv->is_m_series)\n\t\t\t\ts->munge\t= ni_ao_munge;\n\n\t\t\tif (devpriv->mite)\n\t\t\t\ts->async_dma_dir = DMA_TO_DEVICE;\n\t\t}\n\n\t\tif (devpriv->is_67xx)\n\t\t\tinit_ao_67xx(dev, s);\n\n\t\t \n\t\tni_ao_reset(dev, s);\n\t} else {\n\t\ts->type\t\t= COMEDI_SUBD_UNUSED;\n\t}\n\n\t \n\ts = &dev->subdevices[NI_DIO_SUBDEV];\n\ts->type\t\t= COMEDI_SUBD_DIO;\n\ts->subdev_flags\t= SDF_WRITABLE | SDF_READABLE;\n\ts->n_chan\t= board->has_32dio_chan ? 32 : 8;\n\ts->maxdata\t= 1;\n\ts->range_table\t= &range_digital;\n\tif (devpriv->is_m_series) {\n#ifdef PCIDMA\n\t\ts->subdev_flags\t|= SDF_LSAMPL;\n\t\ts->insn_bits\t= ni_m_series_dio_insn_bits;\n\t\ts->insn_config\t= ni_m_series_dio_insn_config;\n\t\tif (dev->irq) {\n\t\t\ts->subdev_flags\t|= SDF_CMD_WRITE  ;\n\t\t\ts->len_chanlist\t= s->n_chan;\n\t\t\ts->do_cmdtest\t= ni_cdio_cmdtest;\n\t\t\ts->do_cmd\t= ni_cdio_cmd;\n\t\t\ts->cancel\t= ni_cdio_cancel;\n\n\t\t\t \n\t\t\ts->async_dma_dir = DMA_BIDIRECTIONAL;\n\t\t}\n\n\t\t \n\t\tni_writel(dev, NI_M_CDO_CMD_RESET |\n\t\t\t       NI_M_CDI_CMD_RESET,\n\t\t\t  NI_M_CDIO_CMD_REG);\n\t\tni_writel(dev, s->io_bits, NI_M_DIO_DIR_REG);\n#endif  \n\t} else {\n\t\ts->insn_bits\t= ni_dio_insn_bits;\n\t\ts->insn_config\t= ni_dio_insn_config;\n\n\t\t \n\t\tdevpriv->dio_control = NISTC_DIO_CTRL_DIR(s->io_bits);\n\t\tni_writew(dev, devpriv->dio_control, NISTC_DIO_CTRL_REG);\n\t}\n\n\t \n\ts = &dev->subdevices[NI_8255_DIO_SUBDEV];\n\tif (board->has_8255) {\n\t\tret = subdev_8255_init(dev, s, ni_8255_callback,\n\t\t\t\t       NI_E_8255_BASE);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\ts->type = COMEDI_SUBD_UNUSED;\n\t}\n\n\t \n\ts = &dev->subdevices[NI_UNUSED_SUBDEV];\n\ts->type = COMEDI_SUBD_UNUSED;\n\n\t \n\ts = &dev->subdevices[NI_CALIBRATION_SUBDEV];\n\ts->type\t\t= COMEDI_SUBD_CALIB;\n\ts->subdev_flags\t= SDF_INTERNAL;\n\ts->n_chan\t= 1;\n\ts->maxdata\t= 0;\n\tif (devpriv->is_m_series) {\n\t\t \n\t\ts->insn_config\t= ni_m_series_pwm_config;\n\n\t\tni_writel(dev, 0x0, NI_M_CAL_PWM_REG);\n\t} else if (devpriv->is_6143) {\n\t\t \n\t\ts->insn_config\t= ni_6143_pwm_config;\n\t} else {\n\t\ts->subdev_flags\t|= SDF_WRITABLE;\n\t\ts->insn_read\t= ni_calib_insn_read;\n\t\ts->insn_write\t= ni_calib_insn_write;\n\n\t\t \n\t\tcaldac_setup(dev, s);\n\t}\n\n\t \n\ts = &dev->subdevices[NI_EEPROM_SUBDEV];\n\ts->type\t\t= COMEDI_SUBD_MEMORY;\n\ts->subdev_flags\t= SDF_READABLE | SDF_INTERNAL;\n\ts->maxdata\t= 0xff;\n\tif (devpriv->is_m_series) {\n\t\ts->n_chan\t= M_SERIES_EEPROM_SIZE;\n\t\ts->insn_read\t= ni_m_series_eeprom_insn_read;\n\t} else {\n\t\ts->n_chan\t= 512;\n\t\ts->insn_read\t= ni_eeprom_insn_read;\n\t}\n\n\t \n\ts = &dev->subdevices[NI_PFI_DIO_SUBDEV];\n\ts->type\t\t= COMEDI_SUBD_DIO;\n\ts->maxdata\t= 1;\n\tif (devpriv->is_m_series) {\n\t\ts->n_chan\t= 16;\n\t\ts->insn_bits\t= ni_pfi_insn_bits;\n\t\ts->subdev_flags\t= SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;\n\n\t\tni_writew(dev, s->state, NI_M_PFI_DO_REG);\n\t\tfor (i = 0; i < NUM_PFI_OUTPUT_SELECT_REGS; ++i) {\n\t\t\tni_writew(dev, devpriv->pfi_output_select_reg[i],\n\t\t\t\t  NI_M_PFI_OUT_SEL_REG(i));\n\t\t}\n\t} else {\n\t\ts->n_chan\t= 10;\n\t\ts->subdev_flags\t= SDF_INTERNAL;\n\t}\n\ts->insn_config\t= ni_pfi_insn_config;\n\n\tni_set_bits(dev, NISTC_IO_BIDIR_PIN_REG, ~0, 0);\n\n\t \n\ts = &dev->subdevices[NI_CS5529_CALIBRATION_SUBDEV];\n\tif (devpriv->is_67xx) {\n\t\ts->type = COMEDI_SUBD_AI;\n\t\ts->subdev_flags = SDF_READABLE | SDF_DIFF | SDF_INTERNAL;\n\t\t \n\t\ts->n_chan = board->n_aochan;\n\t\ts->maxdata = BIT(16) - 1;\n\t\ts->range_table = &range_unknown;\t \n\t\ts->insn_read = cs5529_ai_insn_read;\n\t\ts->insn_config = NULL;\n\t\tinit_cs5529(dev);\n\t} else {\n\t\ts->type = COMEDI_SUBD_UNUSED;\n\t}\n\n\t \n\ts = &dev->subdevices[NI_SERIAL_SUBDEV];\n\ts->type = COMEDI_SUBD_SERIAL;\n\ts->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;\n\ts->n_chan = 1;\n\ts->maxdata = 0xff;\n\ts->insn_config = ni_serial_insn_config;\n\tdevpriv->serial_interval_ns = 0;\n\tdevpriv->serial_hw_mode = 0;\n\n\t \n\ts = &dev->subdevices[NI_RTSI_SUBDEV];\n\ts->type = COMEDI_SUBD_DIO;\n\ts->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;\n\ts->n_chan = 8;\n\ts->maxdata = 1;\n\ts->insn_bits = ni_rtsi_insn_bits;\n\ts->insn_config = ni_rtsi_insn_config;\n\tni_rtsi_init(dev);\n\n\t \n\tdevpriv->counter_dev = ni_gpct_device_construct(dev,\n\t\t\t\t\tni_gpct_write_register,\n\t\t\t\t\tni_gpct_read_register,\n\t\t\t\t\t(devpriv->is_m_series)\n\t\t\t\t\t\t? ni_gpct_variant_m_series\n\t\t\t\t\t\t: ni_gpct_variant_e_series,\n\t\t\t\t\tNUM_GPCT,\n\t\t\t\t\tNUM_GPCT,\n\t\t\t\t\t&devpriv->routing_tables);\n\tif (!devpriv->counter_dev)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = 0; i < NUM_GPCT; ++i) {\n\t\tstruct ni_gpct *gpct = &devpriv->counter_dev->counters[i];\n\n\t\t \n\t\tni_tio_init_counter(gpct);\n\n\t\ts = &dev->subdevices[NI_GPCT_SUBDEV(i)];\n\t\ts->type\t\t= COMEDI_SUBD_COUNTER;\n\t\ts->subdev_flags\t= SDF_READABLE | SDF_WRITABLE | SDF_LSAMPL;\n\t\ts->n_chan\t= 3;\n\t\ts->maxdata\t= (devpriv->is_m_series) ? 0xffffffff\n\t\t\t\t\t\t\t : 0x00ffffff;\n\t\ts->insn_read\t= ni_tio_insn_read;\n\t\ts->insn_write\t= ni_tio_insn_write;\n\t\ts->insn_config\t= ni_tio_insn_config;\n#ifdef PCIDMA\n\t\tif (dev->irq && devpriv->mite) {\n\t\t\ts->subdev_flags\t|= SDF_CMD_READ  ;\n\t\t\ts->len_chanlist\t= 1;\n\t\t\ts->do_cmdtest\t= ni_tio_cmdtest;\n\t\t\ts->do_cmd\t= ni_gpct_cmd;\n\t\t\ts->cancel\t= ni_gpct_cancel;\n\n\t\t\ts->async_dma_dir = DMA_BIDIRECTIONAL;\n\t\t}\n#endif\n\t\ts->private\t= gpct;\n\t}\n\n\t \n\tni_set_gout_routing(0, 0, dev);  \n\tni_set_gout_routing(0, 1, dev);  \n\n\t \n\ts = &dev->subdevices[NI_FREQ_OUT_SUBDEV];\n\ts->type\t\t= COMEDI_SUBD_COUNTER;\n\ts->subdev_flags\t= SDF_READABLE | SDF_WRITABLE;\n\ts->n_chan\t= 1;\n\ts->maxdata\t= 0xf;\n\ts->insn_read\t= ni_freq_out_insn_read;\n\ts->insn_write\t= ni_freq_out_insn_write;\n\ts->insn_config\t= ni_freq_out_insn_config;\n\n\tif (dev->irq) {\n\t\tni_stc_writew(dev,\n\t\t\t      (irq_polarity ? NISTC_INT_CTRL_INT_POL : 0) |\n\t\t\t      (NISTC_INT_CTRL_3PIN_INT & 0) |\n\t\t\t      NISTC_INT_CTRL_INTA_ENA |\n\t\t\t      NISTC_INT_CTRL_INTB_ENA |\n\t\t\t      NISTC_INT_CTRL_INTA_SEL(interrupt_pin) |\n\t\t\t      NISTC_INT_CTRL_INTB_SEL(interrupt_pin),\n\t\t\t      NISTC_INT_CTRL_REG);\n\t}\n\n\t \n\tni_writeb(dev, devpriv->ai_ao_select_reg, NI_E_DMA_AI_AO_SEL_REG);\n\tni_writeb(dev, devpriv->g0_g1_select_reg, NI_E_DMA_G0_G1_SEL_REG);\n\n\tif (devpriv->is_6xxx) {\n\t\tni_writeb(dev, 0, NI611X_MAGIC_REG);\n\t} else if (devpriv->is_m_series) {\n\t\tint channel;\n\n\t\tfor (channel = 0; channel < board->n_aochan; ++channel) {\n\t\t\tni_writeb(dev, 0xf,\n\t\t\t\t  NI_M_AO_WAVEFORM_ORDER_REG(channel));\n\t\t\tni_writeb(dev, 0x0,\n\t\t\t\t  NI_M_AO_REF_ATTENUATION_REG(channel));\n\t\t}\n\t\tni_writeb(dev, 0x0, NI_M_AO_CALIB_REG);\n\t}\n\n\treturn 0;\n}\n\nstatic void mio_common_detach(struct comedi_device *dev)\n{\n\tstruct ni_private *devpriv = dev->private;\n\n\tif (devpriv)\n\t\tni_gpct_device_destroy(devpriv->counter_dev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}