{
  "module_name": "cb_pcidas.c",
  "hash_id": "f8ccb2d62b4601a2c9cf58b47fb5f62c472740d3b4c4324cdbf4940a17dcfb97",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/cb_pcidas.c",
  "human_readable_source": "\n \n\n \n\n \n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/comedi/comedi_pci.h>\n#include <linux/comedi/comedi_8255.h>\n#include <linux/comedi/comedi_8254.h>\n\n#include \"amcc_s5933.h\"\n\n#define AI_BUFFER_SIZE\t\t1024\t \n#define AO_BUFFER_SIZE\t\t1024\t \n\n \n#define PCIDAS_CTRL_REG\t\t0x00\t \n#define PCIDAS_CTRL_INT(x)\t(((x) & 0x3) << 0)\n#define PCIDAS_CTRL_INT_NONE\tPCIDAS_CTRL_INT(0)  \n#define PCIDAS_CTRL_INT_EOS\tPCIDAS_CTRL_INT(1)  \n#define PCIDAS_CTRL_INT_FHF\tPCIDAS_CTRL_INT(2)  \n#define PCIDAS_CTRL_INT_FNE\tPCIDAS_CTRL_INT(3)  \n#define PCIDAS_CTRL_INT_MASK\tPCIDAS_CTRL_INT(3)  \n#define PCIDAS_CTRL_INTE\tBIT(2)\t \n#define PCIDAS_CTRL_DAHFIE\tBIT(3)\t \n#define PCIDAS_CTRL_EOAIE\tBIT(4)\t \n#define PCIDAS_CTRL_DAHFI\tBIT(5)\t \n#define PCIDAS_CTRL_EOAI\tBIT(6)\t \n#define PCIDAS_CTRL_INT_CLR\tBIT(7)\t \n#define PCIDAS_CTRL_EOBI\tBIT(9)\t \n#define PCIDAS_CTRL_ADHFI\tBIT(10)\t \n#define PCIDAS_CTRL_ADNEI\tBIT(11)\t \n#define PCIDAS_CTRL_ADNE\tBIT(12)\t \n#define PCIDAS_CTRL_DAEMIE\tBIT(12)\t \n#define PCIDAS_CTRL_LADFUL\tBIT(13)\t \n#define PCIDAS_CTRL_DAEMI\tBIT(14)\t \n\n#define PCIDAS_CTRL_AI_INT\t(PCIDAS_CTRL_EOAI | PCIDAS_CTRL_EOBI |   \\\n\t\t\t\t PCIDAS_CTRL_ADHFI | PCIDAS_CTRL_ADNEI | \\\n\t\t\t\t PCIDAS_CTRL_LADFUL)\n#define PCIDAS_CTRL_AO_INT\t(PCIDAS_CTRL_DAHFI | PCIDAS_CTRL_DAEMI)\n\n#define PCIDAS_AI_REG\t\t0x02\t \n#define PCIDAS_AI_FIRST(x)\t((x) & 0xf)\n#define PCIDAS_AI_LAST(x)\t(((x) & 0xf) << 4)\n#define PCIDAS_AI_CHAN(x)\t(PCIDAS_AI_FIRST(x) | PCIDAS_AI_LAST(x))\n#define PCIDAS_AI_GAIN(x)\t(((x) & 0x3) << 8)\n#define PCIDAS_AI_SE\t\tBIT(10)\t \n#define PCIDAS_AI_UNIP\t\tBIT(11)\t \n#define PCIDAS_AI_PACER(x)\t(((x) & 0x3) << 12)\n#define PCIDAS_AI_PACER_SW\tPCIDAS_AI_PACER(0)  \n#define PCIDAS_AI_PACER_INT\tPCIDAS_AI_PACER(1)  \n#define PCIDAS_AI_PACER_EXTN\tPCIDAS_AI_PACER(2)  \n#define PCIDAS_AI_PACER_EXTP\tPCIDAS_AI_PACER(3)  \n#define PCIDAS_AI_PACER_MASK\tPCIDAS_AI_PACER(3)  \n#define PCIDAS_AI_EOC\t\tBIT(14)\t \n\n#define PCIDAS_TRIG_REG\t\t0x04\t \n#define PCIDAS_TRIG_SEL(x)\t(((x) & 0x3) << 0)\n#define PCIDAS_TRIG_SEL_NONE\tPCIDAS_TRIG_SEL(0)  \n#define PCIDAS_TRIG_SEL_SW\tPCIDAS_TRIG_SEL(1)  \n#define PCIDAS_TRIG_SEL_EXT\tPCIDAS_TRIG_SEL(2)  \n#define PCIDAS_TRIG_SEL_ANALOG\tPCIDAS_TRIG_SEL(3)  \n#define PCIDAS_TRIG_SEL_MASK\tPCIDAS_TRIG_SEL(3)  \n#define PCIDAS_TRIG_POL\t\tBIT(2)\t \n#define PCIDAS_TRIG_MODE\tBIT(3)\t \n#define PCIDAS_TRIG_EN\t\tBIT(4)\t \n#define PCIDAS_TRIG_BURSTE\tBIT(5)\t \n#define PCIDAS_TRIG_CLR\t\tBIT(7)\t \n\n#define PCIDAS_CALIB_REG\t0x06\t \n#define PCIDAS_CALIB_8800_SEL\tBIT(8)\t \n#define PCIDAS_CALIB_TRIM_SEL\tBIT(9)\t \n#define PCIDAS_CALIB_DAC08_SEL\tBIT(10)\t \n#define PCIDAS_CALIB_SRC(x)\t(((x) & 0x7) << 11)\n#define PCIDAS_CALIB_EN\t\tBIT(14)\t \n#define PCIDAS_CALIB_DATA\tBIT(15)\t \n\n#define PCIDAS_AO_REG\t\t0x08\t \n#define PCIDAS_AO_EMPTY\t\tBIT(0)\t \n#define PCIDAS_AO_DACEN\t\tBIT(1)\t \n#define PCIDAS_AO_START\t\tBIT(2)\t \n#define PCIDAS_AO_PACER(x)\t(((x) & 0x3) << 3)  \n#define PCIDAS_AO_PACER_SW\tPCIDAS_AO_PACER(0)  \n#define PCIDAS_AO_PACER_INT\tPCIDAS_AO_PACER(1)  \n#define PCIDAS_AO_PACER_EXTN\tPCIDAS_AO_PACER(2)  \n#define PCIDAS_AO_PACER_EXTP\tPCIDAS_AO_PACER(3)  \n#define PCIDAS_AO_PACER_MASK\tPCIDAS_AO_PACER(3)  \n#define PCIDAS_AO_CHAN_EN(c)\tBIT(5 + ((c) & 0x1))\n#define PCIDAS_AO_CHAN_MASK\t(PCIDAS_AO_CHAN_EN(0) | PCIDAS_AO_CHAN_EN(1))\n#define PCIDAS_AO_UPDATE_BOTH\tBIT(7)\t \n#define PCIDAS_AO_RANGE(c, r)\t(((r) & 0x3) << (8 + 2 * ((c) & 0x1)))\n#define PCIDAS_AO_RANGE_MASK(c)\tPCIDAS_AO_RANGE((c), 0x3)\n\n \n#define PCIDAS_AI_DATA_REG\t0x00\n#define PCIDAS_AI_FIFO_CLR_REG\t0x02\n\n \n#define PCIDAS_AI_8254_BASE\t0x00\n#define PCIDAS_8255_BASE\t0x04\n#define PCIDAS_AO_8254_BASE\t0x08\n\n \n#define PCIDAS_AO_DATA_REG(x)\t(0x00 + ((x) * 2))\n#define PCIDAS_AO_FIFO_REG\t0x00\n#define PCIDAS_AO_FIFO_CLR_REG\t0x02\n\n \nstatic const struct comedi_lrange cb_pcidas_ranges = {\n\t8, {\n\t\tBIP_RANGE(10),\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(2.5),\n\t\tBIP_RANGE(1.25),\n\t\tUNI_RANGE(10),\n\t\tUNI_RANGE(5),\n\t\tUNI_RANGE(2.5),\n\t\tUNI_RANGE(1.25)\n\t}\n};\n\n \nstatic const struct comedi_lrange cb_pcidas_alt_ranges = {\n\t8, {\n\t\tBIP_RANGE(10),\n\t\tBIP_RANGE(1),\n\t\tBIP_RANGE(0.1),\n\t\tBIP_RANGE(0.01),\n\t\tUNI_RANGE(10),\n\t\tUNI_RANGE(1),\n\t\tUNI_RANGE(0.1),\n\t\tUNI_RANGE(0.01)\n\t}\n};\n\n \nstatic const struct comedi_lrange cb_pcidas_ao_ranges = {\n\t4, {\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(10),\n\t\tUNI_RANGE(5),\n\t\tUNI_RANGE(10)\n\t}\n};\n\nenum cb_pcidas_boardid {\n\tBOARD_PCIDAS1602_16,\n\tBOARD_PCIDAS1200,\n\tBOARD_PCIDAS1602_12,\n\tBOARD_PCIDAS1200_JR,\n\tBOARD_PCIDAS1602_16_JR,\n\tBOARD_PCIDAS1000,\n\tBOARD_PCIDAS1001,\n\tBOARD_PCIDAS1002,\n};\n\nstruct cb_pcidas_board {\n\tconst char *name;\n\tint ai_speed;\t\t \n\tint ao_scan_speed;\t \n\tint fifo_size;\t\t \n\tunsigned int is_16bit;\t\t \n\tunsigned int use_alt_range:1;\t \n\tunsigned int has_ao:1;\t\t \n\tunsigned int has_ao_fifo:1;\t \n\tunsigned int has_ad8402:1;\t \n\tunsigned int has_dac08:1;\n\tunsigned int is_1602:1;\n};\n\nstatic const struct cb_pcidas_board cb_pcidas_boards[] = {\n\t[BOARD_PCIDAS1602_16] = {\n\t\t.name\t\t= \"pci-das1602/16\",\n\t\t.ai_speed\t= 5000,\n\t\t.ao_scan_speed\t= 10000,\n\t\t.fifo_size\t= 512,\n\t\t.is_16bit\t= 1,\n\t\t.has_ao\t\t= 1,\n\t\t.has_ao_fifo\t= 1,\n\t\t.has_ad8402\t= 1,\n\t\t.has_dac08\t= 1,\n\t\t.is_1602\t= 1,\n\t},\n\t[BOARD_PCIDAS1200] = {\n\t\t.name\t\t= \"pci-das1200\",\n\t\t.ai_speed\t= 3200,\n\t\t.fifo_size\t= 1024,\n\t\t.has_ao\t\t= 1,\n\t},\n\t[BOARD_PCIDAS1602_12] = {\n\t\t.name\t\t= \"pci-das1602/12\",\n\t\t.ai_speed\t= 3200,\n\t\t.ao_scan_speed\t= 4000,\n\t\t.fifo_size\t= 1024,\n\t\t.has_ao\t\t= 1,\n\t\t.has_ao_fifo\t= 1,\n\t\t.is_1602\t= 1,\n\t},\n\t[BOARD_PCIDAS1200_JR] = {\n\t\t.name\t\t= \"pci-das1200/jr\",\n\t\t.ai_speed\t= 3200,\n\t\t.fifo_size\t= 1024,\n\t},\n\t[BOARD_PCIDAS1602_16_JR] = {\n\t\t.name\t\t= \"pci-das1602/16/jr\",\n\t\t.ai_speed\t= 5000,\n\t\t.fifo_size\t= 512,\n\t\t.is_16bit\t= 1,\n\t\t.has_ad8402\t= 1,\n\t\t.has_dac08\t= 1,\n\t\t.is_1602\t= 1,\n\t},\n\t[BOARD_PCIDAS1000] = {\n\t\t.name\t\t= \"pci-das1000\",\n\t\t.ai_speed\t= 4000,\n\t\t.fifo_size\t= 1024,\n\t},\n\t[BOARD_PCIDAS1001] = {\n\t\t.name\t\t= \"pci-das1001\",\n\t\t.ai_speed\t= 6800,\n\t\t.fifo_size\t= 1024,\n\t\t.use_alt_range\t= 1,\n\t\t.has_ao\t\t= 1,\n\t},\n\t[BOARD_PCIDAS1002] = {\n\t\t.name\t\t= \"pci-das1002\",\n\t\t.ai_speed\t= 6800,\n\t\t.fifo_size\t= 1024,\n\t\t.has_ao\t\t= 1,\n\t},\n};\n\nstruct cb_pcidas_private {\n\tstruct comedi_8254 *ao_pacer;\n\t \n\tunsigned long amcc;\t \n\tunsigned long pcibar1;\n\tunsigned long pcibar2;\n\tunsigned long pcibar4;\n\t \n\tunsigned int ctrl;\n\tunsigned int amcc_intcsr;\n\tunsigned int ao_ctrl;\n\t \n\tunsigned short ai_buffer[AI_BUFFER_SIZE];\n\tunsigned short ao_buffer[AO_BUFFER_SIZE];\n\tunsigned int calib_src;\n};\n\nstatic int cb_pcidas_ai_eoc(struct comedi_device *dev,\n\t\t\t    struct comedi_subdevice *s,\n\t\t\t    struct comedi_insn *insn,\n\t\t\t    unsigned long context)\n{\n\tstruct cb_pcidas_private *devpriv = dev->private;\n\tunsigned int status;\n\n\tstatus = inw(devpriv->pcibar1 + PCIDAS_AI_REG);\n\tif (status & PCIDAS_AI_EOC)\n\t\treturn 0;\n\treturn -EBUSY;\n}\n\nstatic int cb_pcidas_ai_insn_read(struct comedi_device *dev,\n\t\t\t\t  struct comedi_subdevice *s,\n\t\t\t\t  struct comedi_insn *insn,\n\t\t\t\t  unsigned int *data)\n{\n\tstruct cb_pcidas_private *devpriv = dev->private;\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int range = CR_RANGE(insn->chanspec);\n\tunsigned int aref = CR_AREF(insn->chanspec);\n\tunsigned int bits;\n\tint ret;\n\tint n;\n\n\t \n\tif (insn->chanspec & CR_ALT_SOURCE) {\n\t\toutw(PCIDAS_CALIB_EN | PCIDAS_CALIB_SRC(devpriv->calib_src),\n\t\t     devpriv->pcibar1 + PCIDAS_CALIB_REG);\n\t\tchan = 0;\n\t} else {\n\t\toutw(0, devpriv->pcibar1 + PCIDAS_CALIB_REG);\n\t}\n\n\t \n\tbits = PCIDAS_AI_CHAN(chan) | PCIDAS_AI_GAIN(range);\n\t \n\tif (comedi_range_is_unipolar(s, range))\n\t\tbits |= PCIDAS_AI_UNIP;\n\t \n\tif (aref != AREF_DIFF)\n\t\tbits |= PCIDAS_AI_SE;\n\toutw(bits, devpriv->pcibar1 + PCIDAS_AI_REG);\n\n\t \n\toutw(0, devpriv->pcibar2 + PCIDAS_AI_FIFO_CLR_REG);\n\n\t \n\tfor (n = 0; n < insn->n; n++) {\n\t\t \n\t\toutw(0, devpriv->pcibar2 + PCIDAS_AI_DATA_REG);\n\n\t\t \n\t\tret = comedi_timeout(dev, s, insn, cb_pcidas_ai_eoc, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tdata[n] = inw(devpriv->pcibar2 + PCIDAS_AI_DATA_REG);\n\t}\n\n\t \n\treturn n;\n}\n\nstatic int cb_pcidas_ai_insn_config(struct comedi_device *dev,\n\t\t\t\t    struct comedi_subdevice *s,\n\t\t\t\t    struct comedi_insn *insn,\n\t\t\t\t    unsigned int *data)\n{\n\tstruct cb_pcidas_private *devpriv = dev->private;\n\tint id = data[0];\n\tunsigned int source = data[1];\n\n\tswitch (id) {\n\tcase INSN_CONFIG_ALT_SOURCE:\n\t\tif (source >= 8) {\n\t\t\tdev_err(dev->class_dev,\n\t\t\t\t\"invalid calibration source: %i\\n\",\n\t\t\t\tsource);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tdevpriv->calib_src = source;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn insn->n;\n}\n\n \nstatic int cb_pcidas_ao_nofifo_insn_write(struct comedi_device *dev,\n\t\t\t\t\t  struct comedi_subdevice *s,\n\t\t\t\t\t  struct comedi_insn *insn,\n\t\t\t\t\t  unsigned int *data)\n{\n\tstruct cb_pcidas_private *devpriv = dev->private;\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int range = CR_RANGE(insn->chanspec);\n\tunsigned int val = s->readback[chan];\n\tunsigned long flags;\n\tint i;\n\n\t \n\tspin_lock_irqsave(&dev->spinlock, flags);\n\tdevpriv->ao_ctrl &= ~(PCIDAS_AO_UPDATE_BOTH |\n\t\t\t      PCIDAS_AO_RANGE_MASK(chan));\n\tdevpriv->ao_ctrl |= PCIDAS_AO_DACEN | PCIDAS_AO_RANGE(chan, range);\n\toutw(devpriv->ao_ctrl, devpriv->pcibar1 + PCIDAS_AO_REG);\n\tspin_unlock_irqrestore(&dev->spinlock, flags);\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\tval = data[i];\n\t\toutw(val, devpriv->pcibar4 + PCIDAS_AO_DATA_REG(chan));\n\t}\n\n\ts->readback[chan] = val;\n\n\treturn insn->n;\n}\n\n \nstatic int cb_pcidas_ao_fifo_insn_write(struct comedi_device *dev,\n\t\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\t\tstruct comedi_insn *insn,\n\t\t\t\t\tunsigned int *data)\n{\n\tstruct cb_pcidas_private *devpriv = dev->private;\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int range = CR_RANGE(insn->chanspec);\n\tunsigned int val = s->readback[chan];\n\tunsigned long flags;\n\tint i;\n\n\t \n\toutw(0, devpriv->pcibar4 + PCIDAS_AO_FIFO_CLR_REG);\n\n\t \n\tspin_lock_irqsave(&dev->spinlock, flags);\n\tdevpriv->ao_ctrl &= ~(PCIDAS_AO_CHAN_MASK | PCIDAS_AO_RANGE_MASK(chan) |\n\t\t\t      PCIDAS_AO_PACER_MASK);\n\tdevpriv->ao_ctrl |= PCIDAS_AO_DACEN | PCIDAS_AO_RANGE(chan, range) |\n\t\t\t    PCIDAS_AO_CHAN_EN(chan) | PCIDAS_AO_START;\n\toutw(devpriv->ao_ctrl, devpriv->pcibar1 + PCIDAS_AO_REG);\n\tspin_unlock_irqrestore(&dev->spinlock, flags);\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\tval = data[i];\n\t\toutw(val, devpriv->pcibar4 + PCIDAS_AO_FIFO_REG);\n\t}\n\n\ts->readback[chan] = val;\n\n\treturn insn->n;\n}\n\nstatic int cb_pcidas_eeprom_ready(struct comedi_device *dev,\n\t\t\t\t  struct comedi_subdevice *s,\n\t\t\t\t  struct comedi_insn *insn,\n\t\t\t\t  unsigned long context)\n{\n\tstruct cb_pcidas_private *devpriv = dev->private;\n\tunsigned int status;\n\n\tstatus = inb(devpriv->amcc + AMCC_OP_REG_MCSR_NVCMD);\n\tif ((status & MCSR_NV_BUSY) == 0)\n\t\treturn 0;\n\treturn -EBUSY;\n}\n\nstatic int cb_pcidas_eeprom_insn_read(struct comedi_device *dev,\n\t\t\t\t      struct comedi_subdevice *s,\n\t\t\t\t      struct comedi_insn *insn,\n\t\t\t\t      unsigned int *data)\n{\n\tstruct cb_pcidas_private *devpriv = dev->private;\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\t \n\t\tret = comedi_timeout(dev, s, insn, cb_pcidas_eeprom_ready, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\toutb(MCSR_NV_ENABLE | MCSR_NV_LOAD_LOW_ADDR,\n\t\t     devpriv->amcc + AMCC_OP_REG_MCSR_NVCMD);\n\t\toutb(chan & 0xff, devpriv->amcc + AMCC_OP_REG_MCSR_NVDATA);\n\t\toutb(MCSR_NV_ENABLE | MCSR_NV_LOAD_HIGH_ADDR,\n\t\t     devpriv->amcc + AMCC_OP_REG_MCSR_NVCMD);\n\t\toutb((chan >> 8) & 0xff,\n\t\t     devpriv->amcc + AMCC_OP_REG_MCSR_NVDATA);\n\t\toutb(MCSR_NV_ENABLE | MCSR_NV_READ,\n\t\t     devpriv->amcc + AMCC_OP_REG_MCSR_NVCMD);\n\n\t\t \n\t\tret = comedi_timeout(dev, s, insn, cb_pcidas_eeprom_ready, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdata[i] = inb(devpriv->amcc + AMCC_OP_REG_MCSR_NVDATA);\n\t}\n\n\treturn insn->n;\n}\n\nstatic void cb_pcidas_calib_write(struct comedi_device *dev,\n\t\t\t\t  unsigned int val, unsigned int len,\n\t\t\t\t  bool trimpot)\n{\n\tstruct cb_pcidas_private *devpriv = dev->private;\n\tunsigned int calib_bits;\n\tunsigned int bit;\n\n\tcalib_bits = PCIDAS_CALIB_EN | PCIDAS_CALIB_SRC(devpriv->calib_src);\n\tif (trimpot) {\n\t\t \n\t\tcalib_bits |= PCIDAS_CALIB_TRIM_SEL;\n\t\toutw(calib_bits, devpriv->pcibar1 + PCIDAS_CALIB_REG);\n\t}\n\n\t \n\tfor (bit = 1 << (len - 1); bit; bit >>= 1) {\n\t\tif (val & bit)\n\t\t\tcalib_bits |= PCIDAS_CALIB_DATA;\n\t\telse\n\t\t\tcalib_bits &= ~PCIDAS_CALIB_DATA;\n\t\tudelay(1);\n\t\toutw(calib_bits, devpriv->pcibar1 + PCIDAS_CALIB_REG);\n\t}\n\tudelay(1);\n\n\tcalib_bits = PCIDAS_CALIB_EN | PCIDAS_CALIB_SRC(devpriv->calib_src);\n\n\tif (!trimpot) {\n\t\t \n\t\toutw(calib_bits | PCIDAS_CALIB_8800_SEL,\n\t\t     devpriv->pcibar1 + PCIDAS_CALIB_REG);\n\t\tudelay(1);\n\t}\n\n\t \n\toutw(calib_bits, devpriv->pcibar1 + PCIDAS_CALIB_REG);\n}\n\nstatic int cb_pcidas_caldac_insn_write(struct comedi_device *dev,\n\t\t\t\t       struct comedi_subdevice *s,\n\t\t\t\t       struct comedi_insn *insn,\n\t\t\t\t       unsigned int *data)\n{\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\n\tif (insn->n) {\n\t\tunsigned int val = data[insn->n - 1];\n\n\t\tif (s->readback[chan] != val) {\n\t\t\t \n\t\t\tcb_pcidas_calib_write(dev, (chan << 8) | val, 11,\n\t\t\t\t\t      false);\n\t\t\ts->readback[chan] = val;\n\t\t}\n\t}\n\n\treturn insn->n;\n}\n\nstatic void cb_pcidas_dac08_write(struct comedi_device *dev, unsigned int val)\n{\n\tstruct cb_pcidas_private *devpriv = dev->private;\n\n\tval |= PCIDAS_CALIB_EN | PCIDAS_CALIB_SRC(devpriv->calib_src);\n\n\t \n\toutw(val, devpriv->pcibar1 + PCIDAS_CALIB_REG);\n\tudelay(1);\n\toutw(val | PCIDAS_CALIB_DAC08_SEL,\n\t     devpriv->pcibar1 + PCIDAS_CALIB_REG);\n\tudelay(1);\n\toutw(val, devpriv->pcibar1 + PCIDAS_CALIB_REG);\n\tudelay(1);\n}\n\nstatic int cb_pcidas_dac08_insn_write(struct comedi_device *dev,\n\t\t\t\t      struct comedi_subdevice *s,\n\t\t\t\t      struct comedi_insn *insn,\n\t\t\t\t      unsigned int *data)\n{\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\n\tif (insn->n) {\n\t\tunsigned int val = data[insn->n - 1];\n\n\t\tif (s->readback[chan] != val) {\n\t\t\tcb_pcidas_dac08_write(dev, val);\n\t\t\ts->readback[chan] = val;\n\t\t}\n\t}\n\n\treturn insn->n;\n}\n\nstatic void cb_pcidas_trimpot_write(struct comedi_device *dev,\n\t\t\t\t    unsigned int chan, unsigned int val)\n{\n\tconst struct cb_pcidas_board *board = dev->board_ptr;\n\n\tif (board->has_ad8402) {\n\t\t \n\t\tcb_pcidas_calib_write(dev, (chan << 8) | val, 10, true);\n\t} else {\n\t\t \n\t\tcb_pcidas_calib_write(dev, val, 7, true);\n\t}\n}\n\nstatic int cb_pcidas_trimpot_insn_write(struct comedi_device *dev,\n\t\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\t\tstruct comedi_insn *insn,\n\t\t\t\t\tunsigned int *data)\n{\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\n\tif (insn->n) {\n\t\tunsigned int val = data[insn->n - 1];\n\n\t\tif (s->readback[chan] != val) {\n\t\t\tcb_pcidas_trimpot_write(dev, chan, val);\n\t\t\ts->readback[chan] = val;\n\t\t}\n\t}\n\n\treturn insn->n;\n}\n\nstatic int cb_pcidas_ai_check_chanlist(struct comedi_device *dev,\n\t\t\t\t       struct comedi_subdevice *s,\n\t\t\t\t       struct comedi_cmd *cmd)\n{\n\tunsigned int chan0 = CR_CHAN(cmd->chanlist[0]);\n\tunsigned int range0 = CR_RANGE(cmd->chanlist[0]);\n\tint i;\n\n\tfor (i = 1; i < cmd->chanlist_len; i++) {\n\t\tunsigned int chan = CR_CHAN(cmd->chanlist[i]);\n\t\tunsigned int range = CR_RANGE(cmd->chanlist[i]);\n\n\t\tif (chan != (chan0 + i) % s->n_chan) {\n\t\t\tdev_dbg(dev->class_dev,\n\t\t\t\t\"entries in chanlist must be consecutive channels, counting upwards\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (range != range0) {\n\t\t\tdev_dbg(dev->class_dev,\n\t\t\t\t\"entries in chanlist must all have the same gain\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int cb_pcidas_ai_cmdtest(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tstruct comedi_cmd *cmd)\n{\n\tconst struct cb_pcidas_board *board = dev->board_ptr;\n\tint err = 0;\n\tunsigned int arg;\n\n\t \n\n\terr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_EXT);\n\terr |= comedi_check_trigger_src(&cmd->scan_begin_src,\n\t\t\t\t\tTRIG_FOLLOW | TRIG_TIMER | TRIG_EXT);\n\terr |= comedi_check_trigger_src(&cmd->convert_src,\n\t\t\t\t\tTRIG_TIMER | TRIG_NOW | TRIG_EXT);\n\terr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\n\terr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\n\n\tif (err)\n\t\treturn 1;\n\n\t \n\n\terr |= comedi_check_trigger_is_unique(cmd->start_src);\n\terr |= comedi_check_trigger_is_unique(cmd->scan_begin_src);\n\terr |= comedi_check_trigger_is_unique(cmd->convert_src);\n\terr |= comedi_check_trigger_is_unique(cmd->stop_src);\n\n\t \n\n\tif (cmd->scan_begin_src == TRIG_FOLLOW && cmd->convert_src == TRIG_NOW)\n\t\terr |= -EINVAL;\n\tif (cmd->scan_begin_src != TRIG_FOLLOW && cmd->convert_src != TRIG_NOW)\n\t\terr |= -EINVAL;\n\tif (cmd->start_src == TRIG_EXT &&\n\t    (cmd->convert_src == TRIG_EXT || cmd->scan_begin_src == TRIG_EXT))\n\t\terr |= -EINVAL;\n\n\tif (err)\n\t\treturn 2;\n\n\t \n\n\tswitch (cmd->start_src) {\n\tcase TRIG_NOW:\n\t\terr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\n\t\tbreak;\n\tcase TRIG_EXT:\n\t\t \n\t\tif ((cmd->start_arg\n\t\t     & (CR_FLAGS_MASK & ~(CR_EDGE | CR_INVERT))) != 0) {\n\t\t\tcmd->start_arg &= ~(CR_FLAGS_MASK &\n\t\t\t\t\t\t~(CR_EDGE | CR_INVERT));\n\t\t\terr |= -EINVAL;\n\t\t}\n\t\tif (!board->is_1602 && (cmd->start_arg & CR_INVERT)) {\n\t\t\tcmd->start_arg &= (CR_FLAGS_MASK & ~CR_INVERT);\n\t\t\terr |= -EINVAL;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (cmd->scan_begin_src == TRIG_TIMER) {\n\t\terr |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,\n\t\t\t\t\t\t    board->ai_speed *\n\t\t\t\t\t\t    cmd->chanlist_len);\n\t}\n\n\tif (cmd->convert_src == TRIG_TIMER) {\n\t\terr |= comedi_check_trigger_arg_min(&cmd->convert_arg,\n\t\t\t\t\t\t    board->ai_speed);\n\t}\n\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\n\t\t\t\t\t   cmd->chanlist_len);\n\n\tif (cmd->stop_src == TRIG_COUNT)\n\t\terr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\n\telse\t \n\t\terr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\n\n\tif (err)\n\t\treturn 3;\n\n\t \n\n\tif (cmd->scan_begin_src == TRIG_TIMER) {\n\t\targ = cmd->scan_begin_arg;\n\t\tcomedi_8254_cascade_ns_to_timer(dev->pacer, &arg, cmd->flags);\n\t\terr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, arg);\n\t}\n\tif (cmd->convert_src == TRIG_TIMER) {\n\t\targ = cmd->convert_arg;\n\t\tcomedi_8254_cascade_ns_to_timer(dev->pacer, &arg, cmd->flags);\n\t\terr |= comedi_check_trigger_arg_is(&cmd->convert_arg, arg);\n\t}\n\n\tif (err)\n\t\treturn 4;\n\n\t \n\tif (cmd->chanlist && cmd->chanlist_len > 0)\n\t\terr |= cb_pcidas_ai_check_chanlist(dev, s, cmd);\n\n\tif (err)\n\t\treturn 5;\n\n\treturn 0;\n}\n\nstatic int cb_pcidas_ai_cmd(struct comedi_device *dev,\n\t\t\t    struct comedi_subdevice *s)\n{\n\tconst struct cb_pcidas_board *board = dev->board_ptr;\n\tstruct cb_pcidas_private *devpriv = dev->private;\n\tstruct comedi_async *async = s->async;\n\tstruct comedi_cmd *cmd = &async->cmd;\n\tunsigned int range0 = CR_RANGE(cmd->chanlist[0]);\n\tunsigned int bits;\n\tunsigned long flags;\n\n\t \n\toutw(0, devpriv->pcibar1 + PCIDAS_CALIB_REG);\n\t \n\toutw(PCIDAS_TRIG_SEL_NONE, devpriv->pcibar1 + PCIDAS_TRIG_REG);\n\t \n\toutw(0, devpriv->pcibar2 + PCIDAS_AI_FIFO_CLR_REG);\n\n\t \n\tbits = PCIDAS_AI_FIRST(CR_CHAN(cmd->chanlist[0])) |\n\t       PCIDAS_AI_LAST(CR_CHAN(cmd->chanlist[cmd->chanlist_len - 1])) |\n\t       PCIDAS_AI_GAIN(range0);\n\t \n\tif (comedi_range_is_unipolar(s, range0))\n\t\tbits |= PCIDAS_AI_UNIP;\n\t \n\tif (CR_AREF(cmd->chanlist[0]) != AREF_DIFF)\n\t\tbits |= PCIDAS_AI_SE;\n\t \n\tif (cmd->convert_src == TRIG_EXT || cmd->scan_begin_src == TRIG_EXT)\n\t\tbits |= PCIDAS_AI_PACER_EXTP;\n\telse\n\t\tbits |= PCIDAS_AI_PACER_INT;\n\toutw(bits, devpriv->pcibar1 + PCIDAS_AI_REG);\n\n\t \n\tif (cmd->scan_begin_src == TRIG_TIMER ||\n\t    cmd->convert_src == TRIG_TIMER) {\n\t\tcomedi_8254_update_divisors(dev->pacer);\n\t\tcomedi_8254_pacer_enable(dev->pacer, 1, 2, true);\n\t}\n\n\t \n\tspin_lock_irqsave(&dev->spinlock, flags);\n\tdevpriv->ctrl |= PCIDAS_CTRL_INTE;\n\tdevpriv->ctrl &= ~PCIDAS_CTRL_INT_MASK;\n\tif (cmd->flags & CMDF_WAKE_EOS) {\n\t\tif (cmd->convert_src == TRIG_NOW && cmd->chanlist_len > 1) {\n\t\t\t \n\t\t\tdevpriv->ctrl |= PCIDAS_CTRL_INT_EOS;\n\t\t} else {\n\t\t\t \n\t\t\tdevpriv->ctrl |= PCIDAS_CTRL_INT_FNE;\n\t\t}\n\t} else {\n\t\t \n\t\tdevpriv->ctrl |= PCIDAS_CTRL_INT_FHF;\n\t}\n\n\t \n\toutw(devpriv->ctrl |\n\t     PCIDAS_CTRL_EOAI | PCIDAS_CTRL_INT_CLR | PCIDAS_CTRL_LADFUL,\n\t     devpriv->pcibar1 + PCIDAS_CTRL_REG);\n\tspin_unlock_irqrestore(&dev->spinlock, flags);\n\n\t \n\tbits = 0;\n\tif (cmd->start_src == TRIG_NOW) {\n\t\tbits |= PCIDAS_TRIG_SEL_SW;\n\t} else {\t \n\t\tbits |= PCIDAS_TRIG_SEL_EXT | PCIDAS_TRIG_EN | PCIDAS_TRIG_CLR;\n\t\tif (board->is_1602) {\n\t\t\tif (cmd->start_arg & CR_INVERT)\n\t\t\t\tbits |= PCIDAS_TRIG_POL;\n\t\t\tif (cmd->start_arg & CR_EDGE)\n\t\t\t\tbits |= PCIDAS_TRIG_MODE;\n\t\t}\n\t}\n\tif (cmd->convert_src == TRIG_NOW && cmd->chanlist_len > 1)\n\t\tbits |= PCIDAS_TRIG_BURSTE;\n\toutw(bits, devpriv->pcibar1 + PCIDAS_TRIG_REG);\n\n\treturn 0;\n}\n\nstatic int cb_pcidas_ao_check_chanlist(struct comedi_device *dev,\n\t\t\t\t       struct comedi_subdevice *s,\n\t\t\t\t       struct comedi_cmd *cmd)\n{\n\tunsigned int chan0 = CR_CHAN(cmd->chanlist[0]);\n\n\tif (cmd->chanlist_len > 1) {\n\t\tunsigned int chan1 = CR_CHAN(cmd->chanlist[1]);\n\n\t\tif (chan0 != 0 || chan1 != 1) {\n\t\t\tdev_dbg(dev->class_dev,\n\t\t\t\t\"channels must be ordered channel 0, channel 1 in chanlist\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int cb_pcidas_ao_cmdtest(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tstruct comedi_cmd *cmd)\n{\n\tconst struct cb_pcidas_board *board = dev->board_ptr;\n\tstruct cb_pcidas_private *devpriv = dev->private;\n\tint err = 0;\n\n\t \n\n\terr |= comedi_check_trigger_src(&cmd->start_src, TRIG_INT);\n\terr |= comedi_check_trigger_src(&cmd->scan_begin_src,\n\t\t\t\t\tTRIG_TIMER | TRIG_EXT);\n\terr |= comedi_check_trigger_src(&cmd->convert_src, TRIG_NOW);\n\terr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\n\terr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\n\n\tif (err)\n\t\treturn 1;\n\n\t \n\n\terr |= comedi_check_trigger_is_unique(cmd->scan_begin_src);\n\terr |= comedi_check_trigger_is_unique(cmd->stop_src);\n\n\t \n\n\tif (err)\n\t\treturn 2;\n\n\t \n\n\terr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\n\n\tif (cmd->scan_begin_src == TRIG_TIMER) {\n\t\terr |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,\n\t\t\t\t\t\t    board->ao_scan_speed);\n\t}\n\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\n\t\t\t\t\t   cmd->chanlist_len);\n\n\tif (cmd->stop_src == TRIG_COUNT)\n\t\terr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\n\telse\t \n\t\terr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\n\n\tif (err)\n\t\treturn 3;\n\n\t \n\n\tif (cmd->scan_begin_src == TRIG_TIMER) {\n\t\tunsigned int arg = cmd->scan_begin_arg;\n\n\t\tcomedi_8254_cascade_ns_to_timer(devpriv->ao_pacer,\n\t\t\t\t\t\t&arg, cmd->flags);\n\t\terr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, arg);\n\t}\n\n\tif (err)\n\t\treturn 4;\n\n\t \n\tif (cmd->chanlist && cmd->chanlist_len > 0)\n\t\terr |= cb_pcidas_ao_check_chanlist(dev, s, cmd);\n\n\tif (err)\n\t\treturn 5;\n\n\treturn 0;\n}\n\nstatic int cb_pcidas_ai_cancel(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s)\n{\n\tstruct cb_pcidas_private *devpriv = dev->private;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->spinlock, flags);\n\t \n\tdevpriv->ctrl &= ~(PCIDAS_CTRL_INTE | PCIDAS_CTRL_EOAIE);\n\toutw(devpriv->ctrl, devpriv->pcibar1 + PCIDAS_CTRL_REG);\n\tspin_unlock_irqrestore(&dev->spinlock, flags);\n\n\t \n\toutw(PCIDAS_TRIG_SEL_NONE, devpriv->pcibar1 + PCIDAS_TRIG_REG);\n\toutw(PCIDAS_AI_PACER_SW, devpriv->pcibar1 + PCIDAS_AI_REG);\n\n\treturn 0;\n}\n\nstatic void cb_pcidas_ao_load_fifo(struct comedi_device *dev,\n\t\t\t\t   struct comedi_subdevice *s,\n\t\t\t\t   unsigned int nsamples)\n{\n\tstruct cb_pcidas_private *devpriv = dev->private;\n\tunsigned int nbytes;\n\n\tnsamples = comedi_nsamples_left(s, nsamples);\n\tnbytes = comedi_buf_read_samples(s, devpriv->ao_buffer, nsamples);\n\n\tnsamples = comedi_bytes_to_samples(s, nbytes);\n\toutsw(devpriv->pcibar4 + PCIDAS_AO_FIFO_REG,\n\t      devpriv->ao_buffer, nsamples);\n}\n\nstatic int cb_pcidas_ao_inttrig(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tunsigned int trig_num)\n{\n\tconst struct cb_pcidas_board *board = dev->board_ptr;\n\tstruct cb_pcidas_private *devpriv = dev->private;\n\tstruct comedi_async *async = s->async;\n\tstruct comedi_cmd *cmd = &async->cmd;\n\tunsigned long flags;\n\n\tif (trig_num != cmd->start_arg)\n\t\treturn -EINVAL;\n\n\tcb_pcidas_ao_load_fifo(dev, s, board->fifo_size);\n\n\t \n\tspin_lock_irqsave(&dev->spinlock, flags);\n\tdevpriv->ctrl |= PCIDAS_CTRL_DAEMIE | PCIDAS_CTRL_DAHFIE;\n\n\t \n\toutw(devpriv->ctrl | PCIDAS_CTRL_DAEMI | PCIDAS_CTRL_DAHFI,\n\t     devpriv->pcibar1 + PCIDAS_CTRL_REG);\n\n\t \n\tdevpriv->ao_ctrl |= PCIDAS_AO_START | PCIDAS_AO_DACEN | PCIDAS_AO_EMPTY;\n\toutw(devpriv->ao_ctrl, devpriv->pcibar1 + PCIDAS_AO_REG);\n\n\tspin_unlock_irqrestore(&dev->spinlock, flags);\n\n\tasync->inttrig = NULL;\n\n\treturn 0;\n}\n\nstatic int cb_pcidas_ao_cmd(struct comedi_device *dev,\n\t\t\t    struct comedi_subdevice *s)\n{\n\tstruct cb_pcidas_private *devpriv = dev->private;\n\tstruct comedi_async *async = s->async;\n\tstruct comedi_cmd *cmd = &async->cmd;\n\tunsigned int i;\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&dev->spinlock, flags);\n\tfor (i = 0; i < cmd->chanlist_len; i++) {\n\t\tunsigned int chan = CR_CHAN(cmd->chanlist[i]);\n\t\tunsigned int range = CR_RANGE(cmd->chanlist[i]);\n\n\t\t \n\t\tdevpriv->ao_ctrl |= PCIDAS_AO_CHAN_EN(chan);\n\t\t \n\t\tdevpriv->ao_ctrl |= PCIDAS_AO_RANGE(chan, range);\n\t}\n\n\t \n\toutw(devpriv->ao_ctrl, devpriv->pcibar1 + PCIDAS_AO_REG);\n\tspin_unlock_irqrestore(&dev->spinlock, flags);\n\n\t \n\toutw(0, devpriv->pcibar4 + PCIDAS_AO_FIFO_CLR_REG);\n\n\t \n\tif (cmd->scan_begin_src == TRIG_TIMER) {\n\t\tcomedi_8254_update_divisors(devpriv->ao_pacer);\n\t\tcomedi_8254_pacer_enable(devpriv->ao_pacer, 1, 2, true);\n\t}\n\n\t \n\tspin_lock_irqsave(&dev->spinlock, flags);\n\tswitch (cmd->scan_begin_src) {\n\tcase TRIG_TIMER:\n\t\tdevpriv->ao_ctrl |= PCIDAS_AO_PACER_INT;\n\t\tbreak;\n\tcase TRIG_EXT:\n\t\tdevpriv->ao_ctrl |= PCIDAS_AO_PACER_EXTP;\n\t\tbreak;\n\tdefault:\n\t\tspin_unlock_irqrestore(&dev->spinlock, flags);\n\t\tdev_err(dev->class_dev, \"error setting dac pacer source\\n\");\n\t\treturn -1;\n\t}\n\tspin_unlock_irqrestore(&dev->spinlock, flags);\n\n\tasync->inttrig = cb_pcidas_ao_inttrig;\n\n\treturn 0;\n}\n\nstatic int cb_pcidas_ao_cancel(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s)\n{\n\tstruct cb_pcidas_private *devpriv = dev->private;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->spinlock, flags);\n\t \n\tdevpriv->ctrl &= ~(PCIDAS_CTRL_DAHFIE | PCIDAS_CTRL_DAEMIE);\n\toutw(devpriv->ctrl, devpriv->pcibar1 + PCIDAS_CTRL_REG);\n\n\t \n\tdevpriv->ao_ctrl &= ~(PCIDAS_AO_DACEN | PCIDAS_AO_PACER_MASK);\n\toutw(devpriv->ao_ctrl, devpriv->pcibar1 + PCIDAS_AO_REG);\n\tspin_unlock_irqrestore(&dev->spinlock, flags);\n\n\treturn 0;\n}\n\nstatic unsigned int cb_pcidas_ao_interrupt(struct comedi_device *dev,\n\t\t\t\t\t   unsigned int status)\n{\n\tconst struct cb_pcidas_board *board = dev->board_ptr;\n\tstruct cb_pcidas_private *devpriv = dev->private;\n\tstruct comedi_subdevice *s = dev->write_subdev;\n\tstruct comedi_async *async = s->async;\n\tstruct comedi_cmd *cmd = &async->cmd;\n\tunsigned int irq_clr = 0;\n\n\tif (status & PCIDAS_CTRL_DAEMI) {\n\t\tirq_clr |= PCIDAS_CTRL_DAEMI;\n\n\t\tif (inw(devpriv->pcibar4 + PCIDAS_AO_REG) & PCIDAS_AO_EMPTY) {\n\t\t\tif (cmd->stop_src == TRIG_COUNT &&\n\t\t\t    async->scans_done >= cmd->stop_arg) {\n\t\t\t\tasync->events |= COMEDI_CB_EOA;\n\t\t\t} else {\n\t\t\t\tdev_err(dev->class_dev, \"dac fifo underflow\\n\");\n\t\t\t\tasync->events |= COMEDI_CB_ERROR;\n\t\t\t}\n\t\t}\n\t} else if (status & PCIDAS_CTRL_DAHFI) {\n\t\tirq_clr |= PCIDAS_CTRL_DAHFI;\n\n\t\tcb_pcidas_ao_load_fifo(dev, s, board->fifo_size / 2);\n\t}\n\n\tcomedi_handle_events(dev, s);\n\n\treturn irq_clr;\n}\n\nstatic unsigned int cb_pcidas_ai_interrupt(struct comedi_device *dev,\n\t\t\t\t\t   unsigned int status)\n{\n\tconst struct cb_pcidas_board *board = dev->board_ptr;\n\tstruct cb_pcidas_private *devpriv = dev->private;\n\tstruct comedi_subdevice *s = dev->read_subdev;\n\tstruct comedi_async *async = s->async;\n\tstruct comedi_cmd *cmd = &async->cmd;\n\tunsigned int irq_clr = 0;\n\n\tif (status & PCIDAS_CTRL_ADHFI) {\n\t\tunsigned int num_samples;\n\n\t\tirq_clr |= PCIDAS_CTRL_INT_CLR;\n\n\t\t \n\t\tnum_samples = comedi_nsamples_left(s, board->fifo_size / 2);\n\t\tinsw(devpriv->pcibar2 + PCIDAS_AI_DATA_REG,\n\t\t     devpriv->ai_buffer, num_samples);\n\t\tcomedi_buf_write_samples(s, devpriv->ai_buffer, num_samples);\n\n\t\tif (cmd->stop_src == TRIG_COUNT &&\n\t\t    async->scans_done >= cmd->stop_arg)\n\t\t\tasync->events |= COMEDI_CB_EOA;\n\t} else if (status & (PCIDAS_CTRL_ADNEI | PCIDAS_CTRL_EOBI)) {\n\t\tunsigned int i;\n\n\t\tirq_clr |= PCIDAS_CTRL_INT_CLR;\n\n\t\t \n\t\tfor (i = 0; i < 10000; i++) {\n\t\t\tunsigned short val;\n\n\t\t\t \n\t\t\tif ((inw(devpriv->pcibar1 + PCIDAS_CTRL_REG) &\n\t\t\t    PCIDAS_CTRL_ADNE) == 0)\n\t\t\t\tbreak;\n\t\t\tval = inw(devpriv->pcibar2 + PCIDAS_AI_DATA_REG);\n\t\t\tcomedi_buf_write_samples(s, &val, 1);\n\n\t\t\tif (cmd->stop_src == TRIG_COUNT &&\n\t\t\t    async->scans_done >= cmd->stop_arg) {\n\t\t\t\tasync->events |= COMEDI_CB_EOA;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (status & PCIDAS_CTRL_EOAI) {\n\t\tirq_clr |= PCIDAS_CTRL_EOAI;\n\n\t\tdev_err(dev->class_dev,\n\t\t\t\"bug! encountered end of acquisition interrupt?\\n\");\n\t}\n\n\t \n\tif (status & PCIDAS_CTRL_LADFUL) {\n\t\tirq_clr |= PCIDAS_CTRL_LADFUL;\n\n\t\tdev_err(dev->class_dev, \"fifo overflow\\n\");\n\t\tasync->events |= COMEDI_CB_ERROR;\n\t}\n\n\tcomedi_handle_events(dev, s);\n\n\treturn irq_clr;\n}\n\nstatic irqreturn_t cb_pcidas_interrupt(int irq, void *d)\n{\n\tstruct comedi_device *dev = d;\n\tstruct cb_pcidas_private *devpriv = dev->private;\n\tunsigned int irq_clr = 0;\n\tunsigned int amcc_status;\n\tunsigned int status;\n\n\tif (!dev->attached)\n\t\treturn IRQ_NONE;\n\n\tamcc_status = inl(devpriv->amcc + AMCC_OP_REG_INTCSR);\n\n\tif ((INTCSR_INTR_ASSERTED & amcc_status) == 0)\n\t\treturn IRQ_NONE;\n\n\t \n\tinl_p(devpriv->amcc + AMCC_OP_REG_IMB4);\n\t \n\toutl(devpriv->amcc_intcsr | INTCSR_INBOX_INTR_STATUS,\n\t     devpriv->amcc + AMCC_OP_REG_INTCSR);\n\n\tstatus = inw(devpriv->pcibar1 + PCIDAS_CTRL_REG);\n\n\t \n\tif (status & PCIDAS_CTRL_AO_INT)\n\t\tirq_clr |= cb_pcidas_ao_interrupt(dev, status);\n\n\t \n\tif (status & PCIDAS_CTRL_AI_INT)\n\t\tirq_clr |= cb_pcidas_ai_interrupt(dev, status);\n\n\tif (irq_clr) {\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&dev->spinlock, flags);\n\t\toutw(devpriv->ctrl | irq_clr,\n\t\t     devpriv->pcibar1 + PCIDAS_CTRL_REG);\n\t\tspin_unlock_irqrestore(&dev->spinlock, flags);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int cb_pcidas_auto_attach(struct comedi_device *dev,\n\t\t\t\t unsigned long context)\n{\n\tstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\n\tconst struct cb_pcidas_board *board = NULL;\n\tstruct cb_pcidas_private *devpriv;\n\tstruct comedi_subdevice *s;\n\tint i;\n\tint ret;\n\n\tif (context < ARRAY_SIZE(cb_pcidas_boards))\n\t\tboard = &cb_pcidas_boards[context];\n\tif (!board)\n\t\treturn -ENODEV;\n\tdev->board_ptr  = board;\n\tdev->board_name = board->name;\n\n\tdevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\n\tif (!devpriv)\n\t\treturn -ENOMEM;\n\n\tret = comedi_pci_enable(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tdevpriv->amcc = pci_resource_start(pcidev, 0);\n\tdevpriv->pcibar1 = pci_resource_start(pcidev, 1);\n\tdevpriv->pcibar2 = pci_resource_start(pcidev, 2);\n\tdev->iobase = pci_resource_start(pcidev, 3);\n\tif (board->has_ao)\n\t\tdevpriv->pcibar4 = pci_resource_start(pcidev, 4);\n\n\t \n\toutl(INTCSR_INBOX_INTR_STATUS,\n\t     devpriv->amcc + AMCC_OP_REG_INTCSR);\n\n\tret = request_irq(pcidev->irq, cb_pcidas_interrupt, IRQF_SHARED,\n\t\t\t  \"cb_pcidas\", dev);\n\tif (ret) {\n\t\tdev_dbg(dev->class_dev, \"unable to allocate irq %d\\n\",\n\t\t\tpcidev->irq);\n\t\treturn ret;\n\t}\n\tdev->irq = pcidev->irq;\n\n\tdev->pacer = comedi_8254_init(dev->iobase + PCIDAS_AI_8254_BASE,\n\t\t\t\t      I8254_OSC_BASE_10MHZ, I8254_IO8, 0);\n\tif (!dev->pacer)\n\t\treturn -ENOMEM;\n\n\tdevpriv->ao_pacer = comedi_8254_init(dev->iobase + PCIDAS_AO_8254_BASE,\n\t\t\t\t\t     I8254_OSC_BASE_10MHZ,\n\t\t\t\t\t     I8254_IO8, 0);\n\tif (!devpriv->ao_pacer)\n\t\treturn -ENOMEM;\n\n\tret = comedi_alloc_subdevices(dev, 7);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ts = &dev->subdevices[0];\n\ts->type\t\t= COMEDI_SUBD_AI;\n\ts->subdev_flags\t= SDF_READABLE | SDF_GROUND | SDF_DIFF;\n\ts->n_chan\t= 16;\n\ts->maxdata\t= board->is_16bit ? 0xffff : 0x0fff;\n\ts->range_table\t= board->use_alt_range ? &cb_pcidas_alt_ranges\n\t\t\t\t\t       : &cb_pcidas_ranges;\n\ts->insn_read\t= cb_pcidas_ai_insn_read;\n\ts->insn_config\t= cb_pcidas_ai_insn_config;\n\tif (dev->irq) {\n\t\tdev->read_subdev = s;\n\t\ts->subdev_flags\t|= SDF_CMD_READ;\n\t\ts->len_chanlist\t= s->n_chan;\n\t\ts->do_cmd\t= cb_pcidas_ai_cmd;\n\t\ts->do_cmdtest\t= cb_pcidas_ai_cmdtest;\n\t\ts->cancel\t= cb_pcidas_ai_cancel;\n\t}\n\n\t \n\ts = &dev->subdevices[1];\n\tif (board->has_ao) {\n\t\ts->type\t\t= COMEDI_SUBD_AO;\n\t\ts->subdev_flags\t= SDF_WRITABLE | SDF_GROUND;\n\t\ts->n_chan\t= 2;\n\t\ts->maxdata\t= board->is_16bit ? 0xffff : 0x0fff;\n\t\ts->range_table\t= &cb_pcidas_ao_ranges;\n\t\ts->insn_write\t= (board->has_ao_fifo)\n\t\t\t\t\t? cb_pcidas_ao_fifo_insn_write\n\t\t\t\t\t: cb_pcidas_ao_nofifo_insn_write;\n\n\t\tret = comedi_alloc_subdev_readback(s);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (dev->irq && board->has_ao_fifo) {\n\t\t\tdev->write_subdev = s;\n\t\t\ts->subdev_flags\t|= SDF_CMD_WRITE;\n\t\t\ts->len_chanlist\t= s->n_chan;\n\t\t\ts->do_cmdtest\t= cb_pcidas_ao_cmdtest;\n\t\t\ts->do_cmd\t= cb_pcidas_ao_cmd;\n\t\t\ts->cancel\t= cb_pcidas_ao_cancel;\n\t\t}\n\t} else {\n\t\ts->type\t\t= COMEDI_SUBD_UNUSED;\n\t}\n\n\t \n\ts = &dev->subdevices[2];\n\tret = subdev_8255_init(dev, s, NULL, PCIDAS_8255_BASE);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ts = &dev->subdevices[3];\n\ts->type\t\t= COMEDI_SUBD_MEMORY;\n\ts->subdev_flags\t= SDF_READABLE | SDF_INTERNAL;\n\ts->n_chan\t= 256;\n\ts->maxdata\t= 0xff;\n\ts->insn_read\t= cb_pcidas_eeprom_insn_read;\n\n\t \n\ts = &dev->subdevices[4];\n\ts->type\t\t= COMEDI_SUBD_CALIB;\n\ts->subdev_flags\t= SDF_WRITABLE | SDF_INTERNAL;\n\ts->n_chan\t= 8;\n\ts->maxdata\t= 0xff;\n\ts->insn_write\t= cb_pcidas_caldac_insn_write;\n\n\tret = comedi_alloc_subdev_readback(s);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < s->n_chan; i++) {\n\t\tunsigned int val = s->maxdata / 2;\n\n\t\t \n\t\tcb_pcidas_calib_write(dev, (i << 8) | val, 11, false);\n\t\ts->readback[i] = val;\n\t}\n\n\t \n\ts = &dev->subdevices[5];\n\ts->type\t\t= COMEDI_SUBD_CALIB;\n\ts->subdev_flags\t= SDF_WRITABLE | SDF_INTERNAL;\n\tif (board->has_ad8402) {\n\t\t \n\t\ts->n_chan\t= 2;\n\t\ts->maxdata\t= 0xff;\n\t} else {\n\t\t \n\t\ts->n_chan\t= 1;\n\t\ts->maxdata\t= 0x7f;\n\t}\n\ts->insn_write\t= cb_pcidas_trimpot_insn_write;\n\n\tret = comedi_alloc_subdev_readback(s);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < s->n_chan; i++) {\n\t\tcb_pcidas_trimpot_write(dev, i, s->maxdata / 2);\n\t\ts->readback[i] = s->maxdata / 2;\n\t}\n\n\t \n\ts = &dev->subdevices[6];\n\tif (board->has_dac08) {\n\t\ts->type\t\t= COMEDI_SUBD_CALIB;\n\t\ts->subdev_flags\t= SDF_WRITABLE | SDF_INTERNAL;\n\t\ts->n_chan\t= 1;\n\t\ts->maxdata\t= 0xff;\n\t\ts->insn_write\t= cb_pcidas_dac08_insn_write;\n\n\t\tret = comedi_alloc_subdev_readback(s);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tfor (i = 0; i < s->n_chan; i++) {\n\t\t\tcb_pcidas_dac08_write(dev, s->maxdata / 2);\n\t\t\ts->readback[i] = s->maxdata / 2;\n\t\t}\n\t} else {\n\t\ts->type\t\t= COMEDI_SUBD_UNUSED;\n\t}\n\n\t \n\tinl(devpriv->amcc + AMCC_OP_REG_IMB4);\n\t \n\tdevpriv->amcc_intcsr = INTCSR_INBOX_BYTE(3) | INTCSR_INBOX_SELECT(3) |\n\t\t\t       INTCSR_INBOX_FULL_INT;\n\t \n\toutl(devpriv->amcc_intcsr | INTCSR_INBOX_INTR_STATUS,\n\t     devpriv->amcc + AMCC_OP_REG_INTCSR);\n\n\treturn 0;\n}\n\nstatic void cb_pcidas_detach(struct comedi_device *dev)\n{\n\tstruct cb_pcidas_private *devpriv = dev->private;\n\n\tif (devpriv) {\n\t\tif (devpriv->amcc)\n\t\t\toutl(INTCSR_INBOX_INTR_STATUS,\n\t\t\t     devpriv->amcc + AMCC_OP_REG_INTCSR);\n\t\tkfree(devpriv->ao_pacer);\n\t}\n\tcomedi_pci_detach(dev);\n}\n\nstatic struct comedi_driver cb_pcidas_driver = {\n\t.driver_name\t= \"cb_pcidas\",\n\t.module\t\t= THIS_MODULE,\n\t.auto_attach\t= cb_pcidas_auto_attach,\n\t.detach\t\t= cb_pcidas_detach,\n};\n\nstatic int cb_pcidas_pci_probe(struct pci_dev *dev,\n\t\t\t       const struct pci_device_id *id)\n{\n\treturn comedi_pci_auto_config(dev, &cb_pcidas_driver,\n\t\t\t\t      id->driver_data);\n}\n\nstatic const struct pci_device_id cb_pcidas_pci_table[] = {\n\t{ PCI_VDEVICE(CB, 0x0001), BOARD_PCIDAS1602_16 },\n\t{ PCI_VDEVICE(CB, 0x000f), BOARD_PCIDAS1200 },\n\t{ PCI_VDEVICE(CB, 0x0010), BOARD_PCIDAS1602_12 },\n\t{ PCI_VDEVICE(CB, 0x0019), BOARD_PCIDAS1200_JR },\n\t{ PCI_VDEVICE(CB, 0x001c), BOARD_PCIDAS1602_16_JR },\n\t{ PCI_VDEVICE(CB, 0x004c), BOARD_PCIDAS1000 },\n\t{ PCI_VDEVICE(CB, 0x001a), BOARD_PCIDAS1001 },\n\t{ PCI_VDEVICE(CB, 0x001b), BOARD_PCIDAS1002 },\n\t{ 0 }\n};\nMODULE_DEVICE_TABLE(pci, cb_pcidas_pci_table);\n\nstatic struct pci_driver cb_pcidas_pci_driver = {\n\t.name\t\t= \"cb_pcidas\",\n\t.id_table\t= cb_pcidas_pci_table,\n\t.probe\t\t= cb_pcidas_pci_probe,\n\t.remove\t\t= comedi_pci_auto_unconfig,\n};\nmodule_comedi_pci_driver(cb_pcidas_driver, cb_pcidas_pci_driver);\n\nMODULE_AUTHOR(\"Comedi https://www.comedi.org\");\nMODULE_DESCRIPTION(\"Comedi driver for MeasurementComputing PCI-DAS series\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}