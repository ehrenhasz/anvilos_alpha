{
  "module_name": "ni_at_a2150.c",
  "hash_id": "09fef175a45c6935347eff5a17622f13b360ee318d9ba833e5eed659855a8f68",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/ni_at_a2150.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/comedi/comedidev.h>\n#include <linux/comedi/comedi_8254.h>\n#include <linux/comedi/comedi_isadma.h>\n\n#define A2150_DMA_BUFFER_SIZE\t0xff00\t \n\n \n#define CONFIG_REG\t\t0x0\n#define   CHANNEL_BITS(x)\t((x) & 0x7)\n#define   CHANNEL_MASK\t\t0x7\n#define   CLOCK_SELECT_BITS(x)\t(((x) & 0x3) << 3)\n#define   CLOCK_DIVISOR_BITS(x)\t(((x) & 0x3) << 5)\n#define   CLOCK_MASK\t\t(0xf << 3)\n \n#define   ENABLE0_BIT\t\t0x80\n \n#define   ENABLE1_BIT\t\t0x100\n#define   AC0_BIT\t\t0x200\t \n#define   AC1_BIT\t\t0x400\t \n#define   APD_BIT\t\t0x800\t \n#define   DPD_BIT\t\t0x1000\t \n#define TRIGGER_REG\t\t0x2\t \n#define   POST_TRIGGER_BITS\t0x2\n#define   DELAY_TRIGGER_BITS\t0x3\n#define   HW_TRIG_EN\t\t0x10\t \n#define FIFO_START_REG\t\t0x6\t \n#define FIFO_RESET_REG\t\t0x8\t \n#define FIFO_DATA_REG\t\t0xa\t \n#define DMA_TC_CLEAR_REG\t0xe\t \n#define STATUS_REG\t\t0x12\t \n#define   FNE_BIT\t\t0x1\t \n#define   OVFL_BIT\t\t0x8\t \n#define   EDAQ_BIT\t\t0x10\t \n#define   DCAL_BIT\t\t0x20\t \n#define   INTR_BIT\t\t0x40\t \n \n#define   DMA_TC_BIT\t\t0x80\n#define   ID_BITS(x)\t\t(((x) >> 8) & 0x3)\n#define IRQ_DMA_CNTRL_REG\t0x12\t\t\t \n#define   DMA_CHAN_BITS(x)\t((x) & 0x7)\t\t \n#define   DMA_EN_BIT\t\t0x8\t\t\t \n#define   IRQ_LVL_BITS(x)\t(((x) & 0xf) << 4)\t \n#define   FIFO_INTR_EN_BIT\t0x100\t \n#define   FIFO_INTR_FHF_BIT\t0x200\t \n \n#define   DMA_INTR_EN_BIT\t0x800\n#define   DMA_DEM_EN_BIT\t0x1000\t \n#define I8253_BASE_REG\t\t0x14\n\nstruct a2150_board {\n\tconst char *name;\n\tint clock[4];\t\t \n\tint num_clocks;\t\t \n\tint ai_speed;\t\t \n};\n\n \nstatic const struct comedi_lrange range_a2150 = {\n\t1, {\n\t\tBIP_RANGE(2.828)\n\t}\n};\n\n \nenum { a2150_c, a2150_s };\nstatic const struct a2150_board a2150_boards[] = {\n\t{\n\t .name = \"at-a2150c\",\n\t .clock = {31250, 22676, 20833, 19531},\n\t .num_clocks = 4,\n\t .ai_speed = 19531,\n\t },\n\t{\n\t .name = \"at-a2150s\",\n\t .clock = {62500, 50000, 41667, 0},\n\t .num_clocks = 3,\n\t .ai_speed = 41667,\n\t },\n};\n\nstruct a2150_private {\n\tstruct comedi_isadma *dma;\n\tunsigned int count;\t \n\tint irq_dma_bits;\t \n\tint config_bits;\t \n};\n\n \nstatic irqreturn_t a2150_interrupt(int irq, void *d)\n{\n\tstruct comedi_device *dev = d;\n\tstruct a2150_private *devpriv = dev->private;\n\tstruct comedi_isadma *dma = devpriv->dma;\n\tstruct comedi_isadma_desc *desc = &dma->desc[0];\n\tstruct comedi_subdevice *s = dev->read_subdev;\n\tstruct comedi_async *async = s->async;\n\tstruct comedi_cmd *cmd = &async->cmd;\n\tunsigned short *buf = desc->virt_addr;\n\tunsigned int max_points, num_points, residue, leftover;\n\tunsigned short dpnt;\n\tint status;\n\tint i;\n\n\tif (!dev->attached)\n\t\treturn IRQ_HANDLED;\n\n\tstatus = inw(dev->iobase + STATUS_REG);\n\tif ((status & INTR_BIT) == 0)\n\t\treturn IRQ_NONE;\n\n\tif (status & OVFL_BIT) {\n\t\tasync->events |= COMEDI_CB_ERROR;\n\t\tcomedi_handle_events(dev, s);\n\t}\n\n\tif ((status & DMA_TC_BIT) == 0) {\n\t\tasync->events |= COMEDI_CB_ERROR;\n\t\tcomedi_handle_events(dev, s);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\t \n\tresidue = comedi_isadma_disable(desc->chan);\n\n\t \n\tmax_points = comedi_bytes_to_samples(s, desc->size);\n\tnum_points = max_points - comedi_bytes_to_samples(s, residue);\n\tif (devpriv->count < num_points && cmd->stop_src == TRIG_COUNT)\n\t\tnum_points = devpriv->count;\n\n\t \n\tleftover = 0;\n\tif (cmd->stop_src == TRIG_NONE) {\n\t\tleftover = comedi_bytes_to_samples(s, desc->size);\n\t} else if (devpriv->count > max_points) {\n\t\tleftover = devpriv->count - max_points;\n\t\tif (leftover > max_points)\n\t\t\tleftover = max_points;\n\t}\n\t \n\tif (residue)\n\t\tleftover = 0;\n\n\tfor (i = 0; i < num_points; i++) {\n\t\t \n\t\tdpnt = buf[i];\n\t\t \n\t\tdpnt ^= 0x8000;\n\t\tcomedi_buf_write_samples(s, &dpnt, 1);\n\t\tif (cmd->stop_src == TRIG_COUNT) {\n\t\t\tif (--devpriv->count == 0) {\t \n\t\t\t\tasync->events |= COMEDI_CB_EOA;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t \n\tif (leftover) {\n\t\tdesc->size = comedi_samples_to_bytes(s, leftover);\n\t\tcomedi_isadma_program(desc);\n\t}\n\n\tcomedi_handle_events(dev, s);\n\n\t \n\toutw(0x00, dev->iobase + DMA_TC_CLEAR_REG);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int a2150_cancel(struct comedi_device *dev, struct comedi_subdevice *s)\n{\n\tstruct a2150_private *devpriv = dev->private;\n\tstruct comedi_isadma *dma = devpriv->dma;\n\tstruct comedi_isadma_desc *desc = &dma->desc[0];\n\n\t \n\tdevpriv->irq_dma_bits &= ~DMA_INTR_EN_BIT & ~DMA_EN_BIT;\n\toutw(devpriv->irq_dma_bits, dev->iobase + IRQ_DMA_CNTRL_REG);\n\n\t \n\tcomedi_isadma_disable(desc->chan);\n\n\t \n\toutw(0, dev->iobase + FIFO_RESET_REG);\n\n\treturn 0;\n}\n\n \nstatic int a2150_get_timing(struct comedi_device *dev, unsigned int *period,\n\t\t\t    unsigned int flags)\n{\n\tconst struct a2150_board *board = dev->board_ptr;\n\tstruct a2150_private *devpriv = dev->private;\n\tint lub, glb, temp;\n\tint lub_divisor_shift, lub_index, glb_divisor_shift, glb_index;\n\tint i, j;\n\n\t \n\tlub_divisor_shift = 3;\n\tlub_index = 0;\n\tlub = board->clock[lub_index] * (1 << lub_divisor_shift);\n\tglb_divisor_shift = 0;\n\tglb_index = board->num_clocks - 1;\n\tglb = board->clock[glb_index] * (1 << glb_divisor_shift);\n\n\t \n\tif (*period < glb)\n\t\t*period = glb;\n\tif (*period > lub)\n\t\t*period = lub;\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\t \n\t\tfor (j = 0; j < board->num_clocks; j++) {\n\t\t\t \n\t\t\ttemp = board->clock[j] * (1 << i);\n\t\t\t \n\t\t\tif (temp < lub && temp >= *period) {\n\t\t\t\tlub_divisor_shift = i;\n\t\t\t\tlub_index = j;\n\t\t\t\tlub = temp;\n\t\t\t}\n\t\t\tif (temp > glb && temp <= *period) {\n\t\t\t\tglb_divisor_shift = i;\n\t\t\t\tglb_index = j;\n\t\t\t\tglb = temp;\n\t\t\t}\n\t\t}\n\t}\n\tswitch (flags & CMDF_ROUND_MASK) {\n\tcase CMDF_ROUND_NEAREST:\n\tdefault:\n\t\t \n\t\tif (lub - *period < *period - glb)\n\t\t\t*period = lub;\n\t\telse\n\t\t\t*period = glb;\n\t\tbreak;\n\tcase CMDF_ROUND_UP:\n\t\t*period = lub;\n\t\tbreak;\n\tcase CMDF_ROUND_DOWN:\n\t\t*period = glb;\n\t\tbreak;\n\t}\n\n\t \n\tdevpriv->config_bits &= ~CLOCK_MASK;\n\tif (*period == lub) {\n\t\tdevpriv->config_bits |=\n\t\t    CLOCK_SELECT_BITS(lub_index) |\n\t\t    CLOCK_DIVISOR_BITS(lub_divisor_shift);\n\t} else {\n\t\tdevpriv->config_bits |=\n\t\t    CLOCK_SELECT_BITS(glb_index) |\n\t\t    CLOCK_DIVISOR_BITS(glb_divisor_shift);\n\t}\n\n\treturn 0;\n}\n\nstatic int a2150_set_chanlist(struct comedi_device *dev,\n\t\t\t      unsigned int start_channel,\n\t\t\t      unsigned int num_channels)\n{\n\tstruct a2150_private *devpriv = dev->private;\n\n\tif (start_channel + num_channels > 4)\n\t\treturn -1;\n\n\tdevpriv->config_bits &= ~CHANNEL_MASK;\n\n\tswitch (num_channels) {\n\tcase 1:\n\t\tdevpriv->config_bits |= CHANNEL_BITS(0x4 | start_channel);\n\t\tbreak;\n\tcase 2:\n\t\tif (start_channel == 0)\n\t\t\tdevpriv->config_bits |= CHANNEL_BITS(0x2);\n\t\telse if (start_channel == 2)\n\t\t\tdevpriv->config_bits |= CHANNEL_BITS(0x3);\n\t\telse\n\t\t\treturn -1;\n\t\tbreak;\n\tcase 4:\n\t\tdevpriv->config_bits |= CHANNEL_BITS(0x1);\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int a2150_ai_check_chanlist(struct comedi_device *dev,\n\t\t\t\t   struct comedi_subdevice *s,\n\t\t\t\t   struct comedi_cmd *cmd)\n{\n\tunsigned int chan0 = CR_CHAN(cmd->chanlist[0]);\n\tunsigned int aref0 = CR_AREF(cmd->chanlist[0]);\n\tint i;\n\n\tif (cmd->chanlist_len == 2 && (chan0 == 1 || chan0 == 3)) {\n\t\tdev_dbg(dev->class_dev,\n\t\t\t\"length 2 chanlist must be channels 0,1 or channels 2,3\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (cmd->chanlist_len == 3) {\n\t\tdev_dbg(dev->class_dev,\n\t\t\t\"chanlist must have 1,2 or 4 channels\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 1; i < cmd->chanlist_len; i++) {\n\t\tunsigned int chan = CR_CHAN(cmd->chanlist[i]);\n\t\tunsigned int aref = CR_AREF(cmd->chanlist[i]);\n\n\t\tif (chan != (chan0 + i)) {\n\t\t\tdev_dbg(dev->class_dev,\n\t\t\t\t\"entries in chanlist must be consecutive channels, counting upwards\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (chan == 2)\n\t\t\taref0 = aref;\n\t\tif (aref != aref0) {\n\t\t\tdev_dbg(dev->class_dev,\n\t\t\t\t\"channels 0/1 and 2/3 must have the same analog reference\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int a2150_ai_cmdtest(struct comedi_device *dev,\n\t\t\t    struct comedi_subdevice *s, struct comedi_cmd *cmd)\n{\n\tconst struct a2150_board *board = dev->board_ptr;\n\tint err = 0;\n\tunsigned int arg;\n\n\t \n\n\terr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_EXT);\n\terr |= comedi_check_trigger_src(&cmd->scan_begin_src, TRIG_TIMER);\n\terr |= comedi_check_trigger_src(&cmd->convert_src, TRIG_NOW);\n\terr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\n\terr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\n\n\tif (err)\n\t\treturn 1;\n\n\t \n\n\terr |= comedi_check_trigger_is_unique(cmd->start_src);\n\terr |= comedi_check_trigger_is_unique(cmd->stop_src);\n\n\t \n\n\tif (err)\n\t\treturn 2;\n\n\t \n\n\terr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\n\n\tif (cmd->convert_src == TRIG_TIMER) {\n\t\terr |= comedi_check_trigger_arg_min(&cmd->convert_arg,\n\t\t\t\t\t\t    board->ai_speed);\n\t}\n\n\terr |= comedi_check_trigger_arg_min(&cmd->chanlist_len, 1);\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\n\t\t\t\t\t   cmd->chanlist_len);\n\n\tif (cmd->stop_src == TRIG_COUNT)\n\t\terr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\n\telse\t \n\t\terr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\n\n\tif (err)\n\t\treturn 3;\n\n\t \n\n\tif (cmd->scan_begin_src == TRIG_TIMER) {\n\t\targ = cmd->scan_begin_arg;\n\t\ta2150_get_timing(dev, &arg, cmd->flags);\n\t\terr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, arg);\n\t}\n\n\tif (err)\n\t\treturn 4;\n\n\t \n\tif (cmd->chanlist && cmd->chanlist_len > 0)\n\t\terr |= a2150_ai_check_chanlist(dev, s, cmd);\n\n\tif (err)\n\t\treturn 5;\n\n\treturn 0;\n}\n\nstatic int a2150_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\n{\n\tstruct a2150_private *devpriv = dev->private;\n\tstruct comedi_isadma *dma = devpriv->dma;\n\tstruct comedi_isadma_desc *desc = &dma->desc[0];\n\tstruct comedi_async *async = s->async;\n\tstruct comedi_cmd *cmd = &async->cmd;\n\tunsigned int old_config_bits = devpriv->config_bits;\n\tunsigned int trigger_bits;\n\n\tif (cmd->flags & CMDF_PRIORITY) {\n\t\tdev_err(dev->class_dev,\n\t\t\t\"dma incompatible with hard real-time interrupt (CMDF_PRIORITY), aborting\\n\");\n\t\treturn -1;\n\t}\n\t \n\toutw(0, dev->iobase + FIFO_RESET_REG);\n\n\t \n\tif (a2150_set_chanlist(dev, CR_CHAN(cmd->chanlist[0]),\n\t\t\t       cmd->chanlist_len) < 0)\n\t\treturn -1;\n\n\t \n\tif (CR_AREF(cmd->chanlist[0]) == AREF_OTHER)\n\t\tdevpriv->config_bits |= AC0_BIT;\n\telse\n\t\tdevpriv->config_bits &= ~AC0_BIT;\n\tif (CR_AREF(cmd->chanlist[2]) == AREF_OTHER)\n\t\tdevpriv->config_bits |= AC1_BIT;\n\telse\n\t\tdevpriv->config_bits &= ~AC1_BIT;\n\n\t \n\ta2150_get_timing(dev, &cmd->scan_begin_arg, cmd->flags);\n\n\t \n\toutw(devpriv->config_bits, dev->iobase + CONFIG_REG);\n\n\t \n\tdevpriv->count = cmd->stop_arg * cmd->chanlist_len;\n\n\tcomedi_isadma_disable(desc->chan);\n\n\t \n#define ONE_THIRD_SECOND 333333333\n\tdesc->size = comedi_bytes_per_sample(s) * cmd->chanlist_len *\n\t\t    ONE_THIRD_SECOND / cmd->scan_begin_arg;\n\tif (desc->size > desc->maxsize)\n\t\tdesc->size = desc->maxsize;\n\tif (desc->size < comedi_bytes_per_sample(s))\n\t\tdesc->size = comedi_bytes_per_sample(s);\n\tdesc->size -= desc->size % comedi_bytes_per_sample(s);\n\n\tcomedi_isadma_program(desc);\n\n\t \n\toutw(0x00, dev->iobase + DMA_TC_CLEAR_REG);\n\n\t \n\tdevpriv->irq_dma_bits |= DMA_INTR_EN_BIT | DMA_EN_BIT;\n\toutw(devpriv->irq_dma_bits, dev->iobase + IRQ_DMA_CNTRL_REG);\n\n\t \n\tcomedi_8254_load(dev->pacer, 2, 72, I8254_MODE0 | I8254_BINARY);\n\n\t \n\ttrigger_bits = 0;\n\t \n\tif (cmd->start_src == TRIG_NOW &&\n\t    (old_config_bits & CLOCK_MASK) !=\n\t    (devpriv->config_bits & CLOCK_MASK)) {\n\t\t \n\t\ttrigger_bits |= DELAY_TRIGGER_BITS;\n\t} else {\n\t\t \n\t\ttrigger_bits |= POST_TRIGGER_BITS;\n\t}\n\t \n\tif (cmd->start_src == TRIG_EXT) {\n\t\ttrigger_bits |= HW_TRIG_EN;\n\t} else if (cmd->start_src == TRIG_OTHER) {\n\t\t \n\t\tdev_err(dev->class_dev, \"you shouldn't see this?\\n\");\n\t}\n\t \n\toutw(trigger_bits, dev->iobase + TRIGGER_REG);\n\n\t \n\tif (cmd->start_src == TRIG_NOW)\n\t\toutw(0, dev->iobase + FIFO_START_REG);\n\n\treturn 0;\n}\n\nstatic int a2150_ai_eoc(struct comedi_device *dev,\n\t\t\tstruct comedi_subdevice *s,\n\t\t\tstruct comedi_insn *insn,\n\t\t\tunsigned long context)\n{\n\tunsigned int status;\n\n\tstatus = inw(dev->iobase + STATUS_REG);\n\tif (status & FNE_BIT)\n\t\treturn 0;\n\treturn -EBUSY;\n}\n\nstatic int a2150_ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,\n\t\t\t  struct comedi_insn *insn, unsigned int *data)\n{\n\tstruct a2150_private *devpriv = dev->private;\n\tunsigned int n;\n\tint ret;\n\n\t \n\toutw(0, dev->iobase + FIFO_RESET_REG);\n\n\t \n\tif (a2150_set_chanlist(dev, CR_CHAN(insn->chanspec), 1) < 0)\n\t\treturn -1;\n\n\t \n\tdevpriv->config_bits &= ~AC0_BIT;\n\tdevpriv->config_bits &= ~AC1_BIT;\n\n\t \n\toutw(devpriv->config_bits, dev->iobase + CONFIG_REG);\n\n\t \n\tdevpriv->irq_dma_bits &= ~DMA_INTR_EN_BIT & ~DMA_EN_BIT;\n\toutw(devpriv->irq_dma_bits, dev->iobase + IRQ_DMA_CNTRL_REG);\n\n\t \n\toutw(0, dev->iobase + TRIGGER_REG);\n\n\t \n\toutw(0, dev->iobase + FIFO_START_REG);\n\n\t \n\tfor (n = 0; n < 36; n++) {\n\t\tret = comedi_timeout(dev, s, insn, a2150_ai_eoc, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tinw(dev->iobase + FIFO_DATA_REG);\n\t}\n\n\t \n\tfor (n = 0; n < insn->n; n++) {\n\t\tret = comedi_timeout(dev, s, insn, a2150_ai_eoc, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdata[n] = inw(dev->iobase + FIFO_DATA_REG);\n\t\tdata[n] ^= 0x8000;\n\t}\n\n\t \n\toutw(0, dev->iobase + FIFO_RESET_REG);\n\n\treturn n;\n}\n\nstatic void a2150_alloc_irq_and_dma(struct comedi_device *dev,\n\t\t\t\t    struct comedi_devconfig *it)\n{\n\tstruct a2150_private *devpriv = dev->private;\n\tunsigned int irq_num = it->options[1];\n\tunsigned int dma_chan = it->options[2];\n\n\t \n\tif (irq_num > 15 || dma_chan > 7 ||\n\t    !((1 << irq_num) & 0xdef8) || !((1 << dma_chan) & 0xef))\n\t\treturn;\n\n\tif (request_irq(irq_num, a2150_interrupt, 0, dev->board_name, dev))\n\t\treturn;\n\n\t \n\tdevpriv->dma = comedi_isadma_alloc(dev, 1, dma_chan, dma_chan,\n\t\t\t\t\t   A2150_DMA_BUFFER_SIZE,\n\t\t\t\t\t   COMEDI_ISADMA_READ);\n\tif (!devpriv->dma) {\n\t\tfree_irq(irq_num, dev);\n\t} else {\n\t\tdev->irq = irq_num;\n\t\tdevpriv->irq_dma_bits = IRQ_LVL_BITS(irq_num) |\n\t\t\t\t\tDMA_CHAN_BITS(dma_chan);\n\t}\n}\n\nstatic void a2150_free_dma(struct comedi_device *dev)\n{\n\tstruct a2150_private *devpriv = dev->private;\n\n\tif (devpriv)\n\t\tcomedi_isadma_free(devpriv->dma);\n}\n\nstatic const struct a2150_board *a2150_probe(struct comedi_device *dev)\n{\n\tint id = ID_BITS(inw(dev->iobase + STATUS_REG));\n\n\tif (id >= ARRAY_SIZE(a2150_boards))\n\t\treturn NULL;\n\n\treturn &a2150_boards[id];\n}\n\nstatic int a2150_attach(struct comedi_device *dev, struct comedi_devconfig *it)\n{\n\tconst struct a2150_board *board;\n\tstruct a2150_private *devpriv;\n\tstruct comedi_subdevice *s;\n\tstatic const int timeout = 2000;\n\tint i;\n\tint ret;\n\n\tdevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\n\tif (!devpriv)\n\t\treturn -ENOMEM;\n\n\tret = comedi_request_region(dev, it->options[0], 0x1c);\n\tif (ret)\n\t\treturn ret;\n\n\tboard = a2150_probe(dev);\n\tif (!board)\n\t\treturn -ENODEV;\n\tdev->board_ptr = board;\n\tdev->board_name = board->name;\n\n\t \n\ta2150_alloc_irq_and_dma(dev, it);\n\n\tdev->pacer = comedi_8254_init(dev->iobase + I8253_BASE_REG,\n\t\t\t\t      0, I8254_IO8, 0);\n\tif (!dev->pacer)\n\t\treturn -ENOMEM;\n\n\tret = comedi_alloc_subdevices(dev, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ts = &dev->subdevices[0];\n\ts->type = COMEDI_SUBD_AI;\n\ts->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_OTHER;\n\ts->n_chan = 4;\n\ts->maxdata = 0xffff;\n\ts->range_table = &range_a2150;\n\ts->insn_read = a2150_ai_rinsn;\n\tif (dev->irq) {\n\t\tdev->read_subdev = s;\n\t\ts->subdev_flags |= SDF_CMD_READ;\n\t\ts->len_chanlist = s->n_chan;\n\t\ts->do_cmd = a2150_ai_cmd;\n\t\ts->do_cmdtest = a2150_ai_cmdtest;\n\t\ts->cancel = a2150_cancel;\n\t}\n\n\t \n\toutw(devpriv->irq_dma_bits, dev->iobase + IRQ_DMA_CNTRL_REG);\n\n\t \n\toutw_p(DPD_BIT | APD_BIT, dev->iobase + CONFIG_REG);\n\toutw_p(DPD_BIT, dev->iobase + CONFIG_REG);\n\t \n\tdevpriv->config_bits = 0;\n\toutw(devpriv->config_bits, dev->iobase + CONFIG_REG);\n\t \n\tfor (i = 0; i < timeout; i++) {\n\t\tif ((DCAL_BIT & inw(dev->iobase + STATUS_REG)) == 0)\n\t\t\tbreak;\n\t\tusleep_range(1000, 3000);\n\t}\n\tif (i == timeout) {\n\t\tdev_err(dev->class_dev,\n\t\t\t\"timed out waiting for offset calibration to complete\\n\");\n\t\treturn -ETIME;\n\t}\n\tdevpriv->config_bits |= ENABLE0_BIT | ENABLE1_BIT;\n\toutw(devpriv->config_bits, dev->iobase + CONFIG_REG);\n\n\treturn 0;\n};\n\nstatic void a2150_detach(struct comedi_device *dev)\n{\n\tif (dev->iobase)\n\t\toutw(APD_BIT | DPD_BIT, dev->iobase + CONFIG_REG);\n\ta2150_free_dma(dev);\n\tcomedi_legacy_detach(dev);\n};\n\nstatic struct comedi_driver ni_at_a2150_driver = {\n\t.driver_name\t= \"ni_at_a2150\",\n\t.module\t\t= THIS_MODULE,\n\t.attach\t\t= a2150_attach,\n\t.detach\t\t= a2150_detach,\n};\nmodule_comedi_driver(ni_at_a2150_driver);\n\nMODULE_AUTHOR(\"Comedi https:\nMODULE_DESCRIPTION(\"Comedi low-level driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}