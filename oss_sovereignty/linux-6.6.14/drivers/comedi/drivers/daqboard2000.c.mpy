{
  "module_name": "daqboard2000.c",
  "hash_id": "98248978a4cb845f882faa322040e54460c32a7384a07902efac383daba44eb3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/daqboard2000.c",
  "human_readable_source": "\n \n \n \n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/comedi/comedi_pci.h>\n#include <linux/comedi/comedi_8255.h>\n\n#include \"plx9080.h\"\n\n#define DB2K_FIRMWARE\t\t\"daqboard2000_firmware.bin\"\n\nstatic const struct comedi_lrange db2k_ai_range = {\n\t13, {\n\t\tBIP_RANGE(10),\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(2.5),\n\t\tBIP_RANGE(1.25),\n\t\tBIP_RANGE(0.625),\n\t\tBIP_RANGE(0.3125),\n\t\tBIP_RANGE(0.156),\n\t\tUNI_RANGE(10),\n\t\tUNI_RANGE(5),\n\t\tUNI_RANGE(2.5),\n\t\tUNI_RANGE(1.25),\n\t\tUNI_RANGE(0.625),\n\t\tUNI_RANGE(0.3125)\n\t}\n};\n\n \n#define DB2K_REG_ACQ_CONTROL\t\t\t0x00\t\t \n#define DB2K_REG_ACQ_STATUS\t\t\t0x00\t\t \n#define DB2K_REG_ACQ_SCAN_LIST_FIFO\t\t0x02\t\t \n#define DB2K_REG_ACQ_PACER_CLOCK_DIV_LOW\t0x04\t\t \n#define DB2K_REG_ACQ_SCAN_COUNTER\t\t0x08\t\t \n#define DB2K_REG_ACQ_PACER_CLOCK_DIV_HIGH\t0x0a\t\t \n#define DB2K_REG_ACQ_TRIGGER_COUNT\t\t0x0c\t\t \n#define DB2K_REG_ACQ_RESULTS_FIFO\t\t0x10\t\t \n#define DB2K_REG_ACQ_RESULTS_SHADOW\t\t0x14\t\t \n#define DB2K_REG_ACQ_ADC_RESULT\t\t\t0x18\t\t \n#define DB2K_REG_DAC_SCAN_COUNTER\t\t0x1c\t\t \n#define DB2K_REG_DAC_CONTROL\t\t\t0x20\t\t \n#define DB2K_REG_DAC_STATUS\t\t\t0x20\t\t \n#define DB2K_REG_DAC_FIFO\t\t\t0x24\t\t \n#define DB2K_REG_DAC_PACER_CLOCK_DIV\t\t0x2a\t\t \n#define DB2K_REG_REF_DACS\t\t\t0x2c\t\t \n#define DB2K_REG_DIO_CONTROL\t\t\t0x30\t\t \n#define DB2K_REG_P3_HSIO_DATA\t\t\t0x32\t\t \n#define DB2K_REG_P3_CONTROL\t\t\t0x34\t\t \n#define DB2K_REG_CAL_EEPROM_CONTROL\t\t0x36\t\t \n#define DB2K_REG_DAC_SETTING(x)\t\t\t(0x38 + (x) * 2)  \n#define DB2K_REG_DIO_P2_EXP_IO_8_BIT\t\t0x40\t\t \n#define DB2K_REG_COUNTER_TIMER_CONTROL\t\t0x80\t\t \n#define DB2K_REG_COUNTER_INPUT(x)\t\t(0x88 + (x) * 2)  \n#define DB2K_REG_TIMER_DIV(x)\t\t\t(0xa0 + (x) * 2)  \n#define DB2K_REG_DMA_CONTROL\t\t\t0xb0\t\t \n#define DB2K_REG_TRIG_CONTROL\t\t\t0xb2\t\t \n#define DB2K_REG_CAL_EEPROM\t\t\t0xb8\t\t \n#define DB2K_REG_ACQ_DIGITAL_MARK\t\t0xba\t\t \n#define DB2K_REG_TRIG_DACS\t\t\t0xbc\t\t \n#define DB2K_REG_DIO_P2_EXP_IO_16_BIT(x)\t(0xc0 + (x) * 2)  \n\n \n#define DB2K_REG_CPLD_STATUS\t\t\t0x1000\t\t \n#define DB2K_REG_CPLD_WDATA\t\t\t0x1000\t\t \n\n \n#define DB2K_ACQ_CONTROL_SEQ_START_SCAN_LIST\t\t0x0011\n#define DB2K_ACQ_CONTROL_SEQ_STOP_SCAN_LIST\t\t0x0010\n\n \n#define DB2K_ACQ_CONTROL_RESET_SCAN_LIST_FIFO\t\t0x0004\n#define DB2K_ACQ_CONTROL_RESET_RESULTS_FIFO\t\t0x0002\n#define DB2K_ACQ_CONTROL_RESET_CONFIG_PIPE\t\t0x0001\n\n \n#define DB2K_ACQ_CONTROL_ADC_PACER_INTERNAL\t\t0x0030\n#define DB2K_ACQ_CONTROL_ADC_PACER_EXTERNAL\t\t0x0032\n#define DB2K_ACQ_CONTROL_ADC_PACER_ENABLE\t\t0x0031\n#define DB2K_ACQ_CONTROL_ADC_PACER_ENABLE_DAC_PACER\t0x0034\n#define DB2K_ACQ_CONTROL_ADC_PACER_DISABLE\t\t0x0030\n#define DB2K_ACQ_CONTROL_ADC_PACER_NORMAL_MODE\t\t0x0060\n#define DB2K_ACQ_CONTROL_ADC_PACER_COMPATIBILITY_MODE\t0x0061\n#define DB2K_ACQ_CONTROL_ADC_PACER_INTERNAL_OUT_ENABLE\t0x0008\n#define DB2K_ACQ_CONTROL_ADC_PACER_EXTERNAL_RISING\t0x0100\n\n \n#define DB2K_ACQ_STATUS_RESULTS_FIFO_MORE_1_SAMPLE\t0x0001\n#define DB2K_ACQ_STATUS_RESULTS_FIFO_HAS_DATA\t\t0x0002\n#define DB2K_ACQ_STATUS_RESULTS_FIFO_OVERRUN\t\t0x0004\n#define DB2K_ACQ_STATUS_LOGIC_SCANNING\t\t\t0x0008\n#define DB2K_ACQ_STATUS_CONFIG_PIPE_FULL\t\t0x0010\n#define DB2K_ACQ_STATUS_SCAN_LIST_FIFO_EMPTY\t\t0x0020\n#define DB2K_ACQ_STATUS_ADC_NOT_READY\t\t\t0x0040\n#define DB2K_ACQ_STATUS_ARBITRATION_FAILURE\t\t0x0080\n#define DB2K_ACQ_STATUS_ADC_PACER_OVERRUN\t\t0x0100\n#define DB2K_ACQ_STATUS_DAC_PACER_OVERRUN\t\t0x0200\n\n \n#define DB2K_DAC_STATUS_DAC_FULL\t\t\t0x0001\n#define DB2K_DAC_STATUS_REF_BUSY\t\t\t0x0002\n#define DB2K_DAC_STATUS_TRIG_BUSY\t\t\t0x0004\n#define DB2K_DAC_STATUS_CAL_BUSY\t\t\t0x0008\n#define DB2K_DAC_STATUS_DAC_BUSY(x)\t\t\t(0x0010 << (x))\n\n \n#define DB2K_DAC_CONTROL_ENABLE_BIT\t\t\t0x0001\n#define DB2K_DAC_CONTROL_DATA_IS_SIGNED\t\t\t0x0002\n#define DB2K_DAC_CONTROL_RESET_FIFO\t\t\t0x0004\n#define DB2K_DAC_CONTROL_DAC_DISABLE(x)\t\t\t(0x0020 + ((x) << 4))\n#define DB2K_DAC_CONTROL_DAC_ENABLE(x)\t\t\t(0x0021 + ((x) << 4))\n#define DB2K_DAC_CONTROL_PATTERN_DISABLE\t\t0x0060\n#define DB2K_DAC_CONTROL_PATTERN_ENABLE\t\t\t0x0061\n\n \n#define DB2K_TRIG_CONTROL_TYPE_ANALOG\t\t\t0x0000\n#define DB2K_TRIG_CONTROL_TYPE_TTL\t\t\t0x0010\n#define DB2K_TRIG_CONTROL_EDGE_HI_LO\t\t\t0x0004\n#define DB2K_TRIG_CONTROL_EDGE_LO_HI\t\t\t0x0000\n#define DB2K_TRIG_CONTROL_LEVEL_ABOVE\t\t\t0x0000\n#define DB2K_TRIG_CONTROL_LEVEL_BELOW\t\t\t0x0004\n#define DB2K_TRIG_CONTROL_SENSE_LEVEL\t\t\t0x0002\n#define DB2K_TRIG_CONTROL_SENSE_EDGE\t\t\t0x0000\n#define DB2K_TRIG_CONTROL_ENABLE\t\t\t0x0001\n#define DB2K_TRIG_CONTROL_DISABLE\t\t\t0x0000\n\n \n#define DB2K_REF_DACS_SET\t\t\t\t0x0080\n#define DB2K_REF_DACS_SELECT_POS_REF\t\t\t0x0100\n#define DB2K_REF_DACS_SELECT_NEG_REF\t\t\t0x0000\n\n \n#define DB2K_CPLD_STATUS_INIT\t\t\t\t0x0002\n#define DB2K_CPLD_STATUS_TXREADY\t\t\t0x0004\n#define DB2K_CPLD_VERSION_MASK\t\t\t\t0xf000\n \n#define DB2K_CPLD_VERSION_NEW\t\t\t\t0x5000\n\nenum db2k_boardid {\n\tBOARD_DAQBOARD2000,\n\tBOARD_DAQBOARD2001\n};\n\nstruct db2k_boardtype {\n\tconst char *name;\n\tunsigned int has_2_ao:1; \n};\n\nstatic const struct db2k_boardtype db2k_boardtypes[] = {\n\t[BOARD_DAQBOARD2000] = {\n\t\t.name\t\t= \"daqboard2000\",\n\t\t.has_2_ao\t= true,\n\t},\n\t[BOARD_DAQBOARD2001] = {\n\t\t.name\t\t= \"daqboard2001\",\n\t},\n};\n\nstruct db2k_private {\n\tvoid __iomem *plx;\n};\n\nstatic void db2k_write_acq_scan_list_entry(struct comedi_device *dev, u16 entry)\n{\n\twritew(entry & 0x00ff, dev->mmio + DB2K_REG_ACQ_SCAN_LIST_FIFO);\n\twritew((entry >> 8) & 0x00ff,\n\t       dev->mmio + DB2K_REG_ACQ_SCAN_LIST_FIFO);\n}\n\nstatic void db2k_setup_sampling(struct comedi_device *dev, int chan, int gain)\n{\n\tu16 word0, word1, word2, word3;\n\n\t \n\tword0 = 0;\n\tword1 = 0x0004;\t\t \n\tword2 = (chan << 6) & 0x00c0;\n\tswitch (chan / 4) {\n\tcase 0:\n\t\tword3 = 0x0001;\n\t\tbreak;\n\tcase 1:\n\t\tword3 = 0x0002;\n\t\tbreak;\n\tcase 2:\n\t\tword3 = 0x0005;\n\t\tbreak;\n\tcase 3:\n\t\tword3 = 0x0006;\n\t\tbreak;\n\tcase 4:\n\t\tword3 = 0x0041;\n\t\tbreak;\n\tcase 5:\n\t\tword3 = 0x0042;\n\t\tbreak;\n\tdefault:\n\t\tword3 = 0;\n\t\tbreak;\n\t}\n\t \n\tword2 |= 0x0800;\t \n\tword3 |= 0xc000;\t \n\tdb2k_write_acq_scan_list_entry(dev, word0);\n\tdb2k_write_acq_scan_list_entry(dev, word1);\n\tdb2k_write_acq_scan_list_entry(dev, word2);\n\tdb2k_write_acq_scan_list_entry(dev, word3);\n}\n\nstatic int db2k_ai_status(struct comedi_device *dev, struct comedi_subdevice *s,\n\t\t\t  struct comedi_insn *insn, unsigned long context)\n{\n\tunsigned int status;\n\n\tstatus = readw(dev->mmio + DB2K_REG_ACQ_STATUS);\n\tif (status & context)\n\t\treturn 0;\n\treturn -EBUSY;\n}\n\nstatic int db2k_ai_insn_read(struct comedi_device *dev,\n\t\t\t     struct comedi_subdevice *s,\n\t\t\t     struct comedi_insn *insn, unsigned int *data)\n{\n\tint gain, chan;\n\tint ret;\n\tint i;\n\n\twritew(DB2K_ACQ_CONTROL_RESET_SCAN_LIST_FIFO |\n\t       DB2K_ACQ_CONTROL_RESET_RESULTS_FIFO |\n\t       DB2K_ACQ_CONTROL_RESET_CONFIG_PIPE,\n\t       dev->mmio + DB2K_REG_ACQ_CONTROL);\n\n\t \n\t \n\twritel(1000000, dev->mmio + DB2K_REG_ACQ_PACER_CLOCK_DIV_LOW);\n\twritew(0, dev->mmio + DB2K_REG_ACQ_PACER_CLOCK_DIV_HIGH);\n\n\tgain = CR_RANGE(insn->chanspec);\n\tchan = CR_CHAN(insn->chanspec);\n\n\t \n\tfor (i = 0; i < insn->n; i++) {\n\t\tdb2k_setup_sampling(dev, chan, gain);\n\t\t \n\t\twritew(DB2K_ACQ_CONTROL_SEQ_START_SCAN_LIST,\n\t\t       dev->mmio + DB2K_REG_ACQ_CONTROL);\n\n\t\tret = comedi_timeout(dev, s, insn, db2k_ai_status,\n\t\t\t\t     DB2K_ACQ_STATUS_CONFIG_PIPE_FULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\twritew(DB2K_ACQ_CONTROL_ADC_PACER_ENABLE,\n\t\t       dev->mmio + DB2K_REG_ACQ_CONTROL);\n\n\t\tret = comedi_timeout(dev, s, insn, db2k_ai_status,\n\t\t\t\t     DB2K_ACQ_STATUS_LOGIC_SCANNING);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret =\n\t\tcomedi_timeout(dev, s, insn, db2k_ai_status,\n\t\t\t       DB2K_ACQ_STATUS_RESULTS_FIFO_HAS_DATA);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdata[i] = readw(dev->mmio + DB2K_REG_ACQ_RESULTS_FIFO);\n\t\twritew(DB2K_ACQ_CONTROL_ADC_PACER_DISABLE,\n\t\t       dev->mmio + DB2K_REG_ACQ_CONTROL);\n\t\twritew(DB2K_ACQ_CONTROL_SEQ_STOP_SCAN_LIST,\n\t\t       dev->mmio + DB2K_REG_ACQ_CONTROL);\n\t}\n\n\treturn i;\n}\n\nstatic int db2k_ao_eoc(struct comedi_device *dev, struct comedi_subdevice *s,\n\t\t       struct comedi_insn *insn, unsigned long context)\n{\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int status;\n\n\tstatus = readw(dev->mmio + DB2K_REG_DAC_STATUS);\n\tif ((status & DB2K_DAC_STATUS_DAC_BUSY(chan)) == 0)\n\t\treturn 0;\n\treturn -EBUSY;\n}\n\nstatic int db2k_ao_insn_write(struct comedi_device *dev,\n\t\t\t      struct comedi_subdevice *s,\n\t\t\t      struct comedi_insn *insn, unsigned int *data)\n{\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tint i;\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\tunsigned int val = data[i];\n\t\tint ret;\n\n\t\twritew(val, dev->mmio + DB2K_REG_DAC_SETTING(chan));\n\n\t\tret = comedi_timeout(dev, s, insn, db2k_ao_eoc, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\ts->readback[chan] = val;\n\t}\n\n\treturn insn->n;\n}\n\nstatic void db2k_reset_local_bus(struct comedi_device *dev)\n{\n\tstruct db2k_private *devpriv = dev->private;\n\tu32 cntrl;\n\n\tcntrl = readl(devpriv->plx + PLX_REG_CNTRL);\n\tcntrl |= PLX_CNTRL_RESET;\n\twritel(cntrl, devpriv->plx + PLX_REG_CNTRL);\n\tmdelay(10);\n\tcntrl &= ~PLX_CNTRL_RESET;\n\twritel(cntrl, devpriv->plx + PLX_REG_CNTRL);\n\tmdelay(10);\n}\n\nstatic void db2k_reload_plx(struct comedi_device *dev)\n{\n\tstruct db2k_private *devpriv = dev->private;\n\tu32 cntrl;\n\n\tcntrl = readl(devpriv->plx + PLX_REG_CNTRL);\n\tcntrl &= ~PLX_CNTRL_EERELOAD;\n\twritel(cntrl, devpriv->plx + PLX_REG_CNTRL);\n\tmdelay(10);\n\tcntrl |= PLX_CNTRL_EERELOAD;\n\twritel(cntrl, devpriv->plx + PLX_REG_CNTRL);\n\tmdelay(10);\n\tcntrl &= ~PLX_CNTRL_EERELOAD;\n\twritel(cntrl, devpriv->plx + PLX_REG_CNTRL);\n\tmdelay(10);\n}\n\nstatic void db2k_pulse_prog_pin(struct comedi_device *dev)\n{\n\tstruct db2k_private *devpriv = dev->private;\n\tu32 cntrl;\n\n\tcntrl = readl(devpriv->plx + PLX_REG_CNTRL);\n\tcntrl |= PLX_CNTRL_USERO;\n\twritel(cntrl, devpriv->plx + PLX_REG_CNTRL);\n\tmdelay(10);\n\tcntrl &= ~PLX_CNTRL_USERO;\n\twritel(cntrl, devpriv->plx + PLX_REG_CNTRL);\n\tmdelay(10);\t \n}\n\nstatic int db2k_wait_cpld_init(struct comedi_device *dev)\n{\n\tint result = -ETIMEDOUT;\n\tint i;\n\tu16 cpld;\n\n\t \n\tfor (i = 0; i < 50; i++) {\n\t\tcpld = readw(dev->mmio + DB2K_REG_CPLD_STATUS);\n\t\tif (cpld & DB2K_CPLD_STATUS_INIT) {\n\t\t\tresult = 0;\n\t\t\tbreak;\n\t\t}\n\t\tusleep_range(100, 1000);\n\t}\n\tudelay(5);\n\treturn result;\n}\n\nstatic int db2k_wait_cpld_txready(struct comedi_device *dev)\n{\n\tint i;\n\n\tfor (i = 0; i < 100; i++) {\n\t\tif (readw(dev->mmio + DB2K_REG_CPLD_STATUS) &\n\t\t    DB2K_CPLD_STATUS_TXREADY) {\n\t\t\treturn 0;\n\t\t}\n\t\tudelay(1);\n\t}\n\treturn -ETIMEDOUT;\n}\n\nstatic int db2k_write_cpld(struct comedi_device *dev, u16 data, bool new_cpld)\n{\n\tint result = 0;\n\n\tif (new_cpld) {\n\t\tresult = db2k_wait_cpld_txready(dev);\n\t\tif (result)\n\t\t\treturn result;\n\t} else {\n\t\tusleep_range(10, 20);\n\t}\n\twritew(data, dev->mmio + DB2K_REG_CPLD_WDATA);\n\tif (!(readw(dev->mmio + DB2K_REG_CPLD_STATUS) & DB2K_CPLD_STATUS_INIT))\n\t\tresult = -EIO;\n\n\treturn result;\n}\n\nstatic int db2k_wait_fpga_programmed(struct comedi_device *dev)\n{\n\tstruct db2k_private *devpriv = dev->private;\n\tint i;\n\n\t \n\tfor (i = 0; i < 200; i++) {\n\t\tu32 cntrl = readl(devpriv->plx + PLX_REG_CNTRL);\n\t\t \n\t\tif (cntrl & PLX_CNTRL_USERI)\n\t\t\treturn 0;\n\n\t\tusleep_range(100, 1000);\n\t}\n\treturn -ETIMEDOUT;\n}\n\nstatic int db2k_load_firmware(struct comedi_device *dev, const u8 *cpld_array,\n\t\t\t      size_t len, unsigned long context)\n{\n\tstruct db2k_private *devpriv = dev->private;\n\tint result = -EIO;\n\tu32 cntrl;\n\tint retry;\n\tsize_t i;\n\tbool new_cpld;\n\n\t \n\tfor (i = 0; i + 1 < len; i++) {\n\t\tif (cpld_array[i] == 0xff && cpld_array[i + 1] == 0x20)\n\t\t\tbreak;\n\t}\n\tif (i + 1 >= len) {\n\t\tdev_err(dev->class_dev, \"bad firmware - no start sequence\\n\");\n\t\treturn -EINVAL;\n\t}\n\t \n\tif ((len - i) & 1) {\n\t\tdev_err(dev->class_dev,\n\t\t\t\"bad firmware - odd length (%zu = %zu - %zu)\\n\",\n\t\t\tlen - i, len, i);\n\t\treturn -EINVAL;\n\t}\n\t \n\tcpld_array += i;\n\tlen -= i;\n\n\t \n\tcntrl = readl(devpriv->plx + PLX_REG_CNTRL);\n\tif (!(cntrl & PLX_CNTRL_EEPRESENT))\n\t\treturn -EIO;\n\n\tfor (retry = 0; retry < 3; retry++) {\n\t\tdb2k_reset_local_bus(dev);\n\t\tdb2k_reload_plx(dev);\n\t\tdb2k_pulse_prog_pin(dev);\n\t\tresult = db2k_wait_cpld_init(dev);\n\t\tif (result)\n\t\t\tcontinue;\n\n\t\tnew_cpld = (readw(dev->mmio + DB2K_REG_CPLD_STATUS) &\n\t\t\t    DB2K_CPLD_VERSION_MASK) == DB2K_CPLD_VERSION_NEW;\n\t\tfor (; i < len; i += 2) {\n\t\t\tu16 data = (cpld_array[i] << 8) + cpld_array[i + 1];\n\n\t\t\tresult = db2k_write_cpld(dev, data, new_cpld);\n\t\t\tif (result)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (result == 0)\n\t\t\tresult = db2k_wait_fpga_programmed(dev);\n\t\tif (result == 0) {\n\t\t\tdb2k_reset_local_bus(dev);\n\t\t\tdb2k_reload_plx(dev);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n}\n\nstatic void db2k_adc_stop_dma_transfer(struct comedi_device *dev)\n{\n}\n\nstatic void db2k_adc_disarm(struct comedi_device *dev)\n{\n\t \n\tudelay(2);\n\twritew(DB2K_TRIG_CONTROL_TYPE_ANALOG | DB2K_TRIG_CONTROL_DISABLE,\n\t       dev->mmio + DB2K_REG_TRIG_CONTROL);\n\tudelay(2);\n\twritew(DB2K_TRIG_CONTROL_TYPE_TTL | DB2K_TRIG_CONTROL_DISABLE,\n\t       dev->mmio + DB2K_REG_TRIG_CONTROL);\n\n\t \n\tudelay(2);\n\twritew(DB2K_ACQ_CONTROL_SEQ_STOP_SCAN_LIST,\n\t       dev->mmio + DB2K_REG_ACQ_CONTROL);\n\n\t \n\tudelay(2);\n\twritew(DB2K_ACQ_CONTROL_ADC_PACER_DISABLE,\n\t       dev->mmio + DB2K_REG_ACQ_CONTROL);\n\n\t \n\tdb2k_adc_stop_dma_transfer(dev);\n}\n\nstatic void db2k_activate_reference_dacs(struct comedi_device *dev)\n{\n\tunsigned int val;\n\tint timeout;\n\n\t \n\twritew(DB2K_REF_DACS_SET | DB2K_REF_DACS_SELECT_POS_REF,\n\t       dev->mmio + DB2K_REG_REF_DACS);\n\tfor (timeout = 0; timeout < 20; timeout++) {\n\t\tval = readw(dev->mmio + DB2K_REG_DAC_STATUS);\n\t\tif ((val & DB2K_DAC_STATUS_REF_BUSY) == 0)\n\t\t\tbreak;\n\t\tudelay(2);\n\t}\n\n\t \n\twritew(DB2K_REF_DACS_SET | DB2K_REF_DACS_SELECT_NEG_REF,\n\t       dev->mmio + DB2K_REG_REF_DACS);\n\tfor (timeout = 0; timeout < 20; timeout++) {\n\t\tval = readw(dev->mmio + DB2K_REG_DAC_STATUS);\n\t\tif ((val & DB2K_DAC_STATUS_REF_BUSY) == 0)\n\t\t\tbreak;\n\t\tudelay(2);\n\t}\n}\n\nstatic void db2k_initialize_ctrs(struct comedi_device *dev)\n{\n}\n\nstatic void db2k_initialize_tmrs(struct comedi_device *dev)\n{\n}\n\nstatic void db2k_dac_disarm(struct comedi_device *dev)\n{\n}\n\nstatic void db2k_initialize_adc(struct comedi_device *dev)\n{\n\tdb2k_adc_disarm(dev);\n\tdb2k_activate_reference_dacs(dev);\n\tdb2k_initialize_ctrs(dev);\n\tdb2k_initialize_tmrs(dev);\n}\n\nstatic int db2k_8255_cb(struct comedi_device *dev, int dir, int port, int data,\n\t\t\tunsigned long iobase)\n{\n\tif (dir) {\n\t\twritew(data, dev->mmio + iobase + port * 2);\n\t\treturn 0;\n\t}\n\treturn readw(dev->mmio + iobase + port * 2);\n}\n\nstatic int db2k_auto_attach(struct comedi_device *dev, unsigned long context)\n{\n\tstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\n\tconst struct db2k_boardtype *board;\n\tstruct db2k_private *devpriv;\n\tstruct comedi_subdevice *s;\n\tint result;\n\n\tif (context >= ARRAY_SIZE(db2k_boardtypes))\n\t\treturn -ENODEV;\n\tboard = &db2k_boardtypes[context];\n\tif (!board->name)\n\t\treturn -ENODEV;\n\tdev->board_ptr = board;\n\tdev->board_name = board->name;\n\n\tdevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\n\tif (!devpriv)\n\t\treturn -ENOMEM;\n\n\tresult = comedi_pci_enable(dev);\n\tif (result)\n\t\treturn result;\n\n\tdevpriv->plx = pci_ioremap_bar(pcidev, 0);\n\tdev->mmio = pci_ioremap_bar(pcidev, 2);\n\tif (!devpriv->plx || !dev->mmio)\n\t\treturn -ENOMEM;\n\n\tresult = comedi_alloc_subdevices(dev, 3);\n\tif (result)\n\t\treturn result;\n\n\tresult = comedi_load_firmware(dev, &comedi_to_pci_dev(dev)->dev,\n\t\t\t\t      DB2K_FIRMWARE, db2k_load_firmware, 0);\n\tif (result < 0)\n\t\treturn result;\n\n\tdb2k_initialize_adc(dev);\n\tdb2k_dac_disarm(dev);\n\n\ts = &dev->subdevices[0];\n\t \n\ts->type = COMEDI_SUBD_AI;\n\ts->subdev_flags = SDF_READABLE | SDF_GROUND;\n\ts->n_chan = 24;\n\ts->maxdata = 0xffff;\n\ts->insn_read = db2k_ai_insn_read;\n\ts->range_table = &db2k_ai_range;\n\n\ts = &dev->subdevices[1];\n\t \n\ts->type = COMEDI_SUBD_AO;\n\ts->subdev_flags = SDF_WRITABLE;\n\ts->n_chan = board->has_2_ao ? 2 : 4;\n\ts->maxdata = 0xffff;\n\ts->insn_write = db2k_ao_insn_write;\n\ts->range_table = &range_bipolar10;\n\n\tresult = comedi_alloc_subdev_readback(s);\n\tif (result)\n\t\treturn result;\n\n\ts = &dev->subdevices[2];\n\treturn subdev_8255_init(dev, s, db2k_8255_cb,\n\t\t\t\tDB2K_REG_DIO_P2_EXP_IO_8_BIT);\n}\n\nstatic void db2k_detach(struct comedi_device *dev)\n{\n\tstruct db2k_private *devpriv = dev->private;\n\n\tif (devpriv && devpriv->plx)\n\t\tiounmap(devpriv->plx);\n\tcomedi_pci_detach(dev);\n}\n\nstatic struct comedi_driver db2k_driver = {\n\t.driver_name\t= \"daqboard2000\",\n\t.module\t\t= THIS_MODULE,\n\t.auto_attach\t= db2k_auto_attach,\n\t.detach\t\t= db2k_detach,\n};\n\nstatic int db2k_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)\n{\n\treturn comedi_pci_auto_config(dev, &db2k_driver, id->driver_data);\n}\n\nstatic const struct pci_device_id db2k_pci_table[] = {\n\t{ PCI_DEVICE_SUB(PCI_VENDOR_ID_IOTECH, 0x0409, PCI_VENDOR_ID_IOTECH,\n\t\t\t 0x0002), .driver_data = BOARD_DAQBOARD2000, },\n\t{ PCI_DEVICE_SUB(PCI_VENDOR_ID_IOTECH, 0x0409, PCI_VENDOR_ID_IOTECH,\n\t\t\t 0x0004), .driver_data = BOARD_DAQBOARD2001, },\n\t{ 0 }\n};\nMODULE_DEVICE_TABLE(pci, db2k_pci_table);\n\nstatic struct pci_driver db2k_pci_driver = {\n\t.name\t\t= \"daqboard2000\",\n\t.id_table\t= db2k_pci_table,\n\t.probe\t\t= db2k_pci_probe,\n\t.remove\t\t= comedi_pci_auto_unconfig,\n};\nmodule_comedi_pci_driver(db2k_driver, db2k_pci_driver);\n\nMODULE_AUTHOR(\"Comedi https://www.comedi.org\");\nMODULE_DESCRIPTION(\"Comedi low-level driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(DB2K_FIRMWARE);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}