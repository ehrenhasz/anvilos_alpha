{
  "module_name": "dt2814.c",
  "hash_id": "93619a040998c0a191af62f45fab33f05aaa54d6c86ad146840e6a4db69d31fc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/dt2814.c",
  "human_readable_source": "\n \n \n\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/comedi/comedidev.h>\n#include <linux/delay.h>\n\n#define DT2814_CSR 0\n#define DT2814_DATA 1\n\n \n\n#define DT2814_FINISH 0x80\n#define DT2814_ERR 0x40\n#define DT2814_BUSY 0x20\n#define DT2814_ENB 0x10\n#define DT2814_CHANMASK 0x0f\n\n#define DT2814_TIMEOUT 10\n#define DT2814_MAX_SPEED 100000\t \n\nstatic int dt2814_ai_notbusy(struct comedi_device *dev,\n\t\t\t     struct comedi_subdevice *s,\n\t\t\t     struct comedi_insn *insn,\n\t\t\t     unsigned long context)\n{\n\tunsigned int status;\n\n\tstatus = inb(dev->iobase + DT2814_CSR);\n\tif (context)\n\t\t*(unsigned int *)context = status;\n\tif (status & DT2814_BUSY)\n\t\treturn -EBUSY;\n\treturn 0;\n}\n\nstatic int dt2814_ai_clear(struct comedi_device *dev)\n{\n\tunsigned int status = 0;\n\tint ret;\n\n\t \n\tret = comedi_timeout(dev, NULL, NULL, dt2814_ai_notbusy,\n\t\t\t     (unsigned long)&status);\n\tif (ret)\n\t\treturn ret;\n\n\tif (status & (DT2814_FINISH | DT2814_ERR)) {\n\t\t \n\t\tinb(dev->iobase + DT2814_DATA);\n\t\tinb(dev->iobase + DT2814_DATA);\n\t}\n\treturn 0;\n}\n\nstatic int dt2814_ai_eoc(struct comedi_device *dev,\n\t\t\t struct comedi_subdevice *s,\n\t\t\t struct comedi_insn *insn,\n\t\t\t unsigned long context)\n{\n\tunsigned int status;\n\n\tstatus = inb(dev->iobase + DT2814_CSR);\n\tif (status & DT2814_FINISH)\n\t\treturn 0;\n\treturn -EBUSY;\n}\n\nstatic int dt2814_ai_insn_read(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       struct comedi_insn *insn, unsigned int *data)\n{\n\tint n, hi, lo;\n\tint chan;\n\tint ret;\n\n\tdt2814_ai_clear(dev);\t \n\tfor (n = 0; n < insn->n; n++) {\n\t\tchan = CR_CHAN(insn->chanspec);\n\n\t\toutb(chan, dev->iobase + DT2814_CSR);\n\n\t\tret = comedi_timeout(dev, s, insn, dt2814_ai_eoc, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\thi = inb(dev->iobase + DT2814_DATA);\n\t\tlo = inb(dev->iobase + DT2814_DATA);\n\n\t\tdata[n] = (hi << 4) | (lo >> 4);\n\t}\n\n\treturn n;\n}\n\nstatic int dt2814_ns_to_timer(unsigned int *ns, unsigned int flags)\n{\n\tint i;\n\tunsigned int f;\n\n\t \n\n\tf = 10000;\t\t \n\tfor (i = 0; i < 8; i++) {\n\t\tif ((2 * (*ns)) < (f * 11))\n\t\t\tbreak;\n\t\tf *= 10;\n\t}\n\n\t*ns = f;\n\n\treturn i;\n}\n\nstatic int dt2814_ai_cmdtest(struct comedi_device *dev,\n\t\t\t     struct comedi_subdevice *s, struct comedi_cmd *cmd)\n{\n\tint err = 0;\n\tunsigned int arg;\n\n\t \n\n\terr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW);\n\terr |= comedi_check_trigger_src(&cmd->scan_begin_src, TRIG_TIMER);\n\terr |= comedi_check_trigger_src(&cmd->convert_src, TRIG_NOW);\n\terr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\n\terr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\n\n\tif (err)\n\t\treturn 1;\n\n\t \n\n\terr |= comedi_check_trigger_is_unique(cmd->stop_src);\n\n\t \n\n\tif (err)\n\t\treturn 2;\n\n\t \n\n\terr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\n\n\terr |= comedi_check_trigger_arg_max(&cmd->scan_begin_arg, 1000000000);\n\terr |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,\n\t\t\t\t\t    DT2814_MAX_SPEED);\n\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\n\t\t\t\t\t   cmd->chanlist_len);\n\n\tif (cmd->stop_src == TRIG_COUNT)\n\t\terr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 2);\n\telse\t \n\t\terr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\n\n\tif (err)\n\t\treturn 3;\n\n\t \n\n\targ = cmd->scan_begin_arg;\n\tdt2814_ns_to_timer(&arg, cmd->flags);\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, arg);\n\n\tif (err)\n\t\treturn 4;\n\n\treturn 0;\n}\n\nstatic int dt2814_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\n{\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tint chan;\n\tint trigvar;\n\n\tdt2814_ai_clear(dev);\t \n\ttrigvar = dt2814_ns_to_timer(&cmd->scan_begin_arg, cmd->flags);\n\n\tchan = CR_CHAN(cmd->chanlist[0]);\n\n\toutb(chan | DT2814_ENB | (trigvar << 5), dev->iobase + DT2814_CSR);\n\n\treturn 0;\n}\n\nstatic int dt2814_ai_cancel(struct comedi_device *dev,\n\t\t\t    struct comedi_subdevice *s)\n{\n\tunsigned int status;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->spinlock, flags);\n\tstatus = inb(dev->iobase + DT2814_CSR);\n\tif (status & DT2814_ENB) {\n\t\t \n\t\toutb(status & DT2814_CHANMASK, dev->iobase + DT2814_CSR);\n\t}\n\tspin_unlock_irqrestore(&dev->spinlock, flags);\n\treturn 0;\n}\n\nstatic irqreturn_t dt2814_interrupt(int irq, void *d)\n{\n\tstruct comedi_device *dev = d;\n\tstruct comedi_subdevice *s = dev->read_subdev;\n\tstruct comedi_async *async;\n\tunsigned int lo, hi;\n\tunsigned short data;\n\tunsigned int status;\n\n\tif (!dev->attached) {\n\t\tdev_err(dev->class_dev, \"spurious interrupt\\n\");\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tasync = s->async;\n\n\tspin_lock(&dev->spinlock);\n\n\tstatus = inb(dev->iobase + DT2814_CSR);\n\tif (!(status & DT2814_ENB)) {\n\t\t \n\t\tspin_unlock(&dev->spinlock);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (!(status & (DT2814_FINISH | DT2814_ERR))) {\n\t\t \n\t\tspin_unlock(&dev->spinlock);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\t \n\thi = inb(dev->iobase + DT2814_DATA);\n\tlo = inb(dev->iobase + DT2814_DATA);\n\n\tdata = (hi << 4) | (lo >> 4);\n\n\tif (status & DT2814_ERR) {\n\t\tasync->events |= COMEDI_CB_ERROR;\n\t} else {\n\t\tcomedi_buf_write_samples(s, &data, 1);\n\t\tif (async->cmd.stop_src == TRIG_COUNT &&\n\t\t    async->scans_done >=  async->cmd.stop_arg) {\n\t\t\tasync->events |= COMEDI_CB_EOA;\n\t\t}\n\t}\n\tif (async->events & COMEDI_CB_CANCEL_MASK) {\n\t\t \n\t\toutb(status & DT2814_CHANMASK, dev->iobase + DT2814_CSR);\n\t}\n\n\tspin_unlock(&dev->spinlock);\n\n\tcomedi_handle_events(dev, s);\n\treturn IRQ_HANDLED;\n}\n\nstatic int dt2814_attach(struct comedi_device *dev, struct comedi_devconfig *it)\n{\n\tstruct comedi_subdevice *s;\n\tint ret;\n\n\tret = comedi_request_region(dev, it->options[0], 0x2);\n\tif (ret)\n\t\treturn ret;\n\n\toutb(0, dev->iobase + DT2814_CSR);\n\tif (dt2814_ai_clear(dev)) {\n\t\tdev_err(dev->class_dev, \"reset error (fatal)\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (it->options[1]) {\n\t\tret = request_irq(it->options[1], dt2814_interrupt, 0,\n\t\t\t\t  dev->board_name, dev);\n\t\tif (ret == 0)\n\t\t\tdev->irq = it->options[1];\n\t}\n\n\tret = comedi_alloc_subdevices(dev, 1);\n\tif (ret)\n\t\treturn ret;\n\n\ts = &dev->subdevices[0];\n\ts->type = COMEDI_SUBD_AI;\n\ts->subdev_flags = SDF_READABLE | SDF_GROUND;\n\ts->n_chan = 16;\t\t \n\ts->insn_read = dt2814_ai_insn_read;\n\ts->maxdata = 0xfff;\n\ts->range_table = &range_unknown;\t \n\tif (dev->irq) {\n\t\tdev->read_subdev = s;\n\t\ts->subdev_flags |= SDF_CMD_READ;\n\t\ts->len_chanlist = 1;\n\t\ts->do_cmd = dt2814_ai_cmd;\n\t\ts->do_cmdtest = dt2814_ai_cmdtest;\n\t\ts->cancel = dt2814_ai_cancel;\n\t}\n\n\treturn 0;\n}\n\nstatic void dt2814_detach(struct comedi_device *dev)\n{\n\tif (dev->irq) {\n\t\t \n\t\tdt2814_ai_clear(dev);\n\t}\n\tcomedi_legacy_detach(dev);\n}\n\nstatic struct comedi_driver dt2814_driver = {\n\t.driver_name\t= \"dt2814\",\n\t.module\t\t= THIS_MODULE,\n\t.attach\t\t= dt2814_attach,\n\t.detach\t\t= dt2814_detach,\n};\nmodule_comedi_driver(dt2814_driver);\n\nMODULE_AUTHOR(\"Comedi https://www.comedi.org\");\nMODULE_DESCRIPTION(\"Comedi low-level driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}