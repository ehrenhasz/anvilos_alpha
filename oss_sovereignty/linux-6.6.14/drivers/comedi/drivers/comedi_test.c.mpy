{
  "module_name": "comedi_test.c",
  "hash_id": "7d67ce0775e657458e55a412afdda6cd7a3f8c74a3ab454691d9f2ec9b9c0e24",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/comedi_test.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/comedi/comedidev.h>\n#include <asm/div64.h>\n#include <linux/timer.h>\n#include <linux/ktime.h>\n#include <linux/jiffies.h>\n#include <linux/device.h>\n#include <linux/kdev_t.h>\n\n#define N_CHANS 8\n#define DEV_NAME \"comedi_testd\"\n#define CLASS_NAME \"comedi_test\"\n\nstatic bool config_mode;\nstatic unsigned int set_amplitude;\nstatic unsigned int set_period;\nstatic const struct class ctcls = {\n\t.name = CLASS_NAME,\n};\nstatic struct device *ctdev;\n\nmodule_param_named(noauto, config_mode, bool, 0444);\nMODULE_PARM_DESC(noauto, \"Disable auto-configuration: (1=disable [defaults to enable])\");\n\nmodule_param_named(amplitude, set_amplitude, uint, 0444);\nMODULE_PARM_DESC(amplitude, \"Set auto mode wave amplitude in microvolts: (defaults to 1 volt)\");\n\nmodule_param_named(period, set_period, uint, 0444);\nMODULE_PARM_DESC(period, \"Set auto mode wave period in microseconds: (defaults to 0.1 sec)\");\n\n \nstruct waveform_private {\n\tstruct timer_list ai_timer;\t \n\tu64 ai_convert_time;\t\t \n\tunsigned int wf_amplitude;\t \n\tunsigned int wf_period;\t\t \n\tunsigned int wf_current;\t \n\tunsigned int ai_scan_period;\t \n\tunsigned int ai_convert_period;\t \n\tstruct timer_list ao_timer;\t \n\tstruct comedi_device *dev;\t \n\tu64 ao_last_scan_time;\t\t \n\tunsigned int ao_scan_period;\t \n\tunsigned short ao_loopbacks[N_CHANS];\n};\n\n \nstatic const struct comedi_lrange waveform_ai_ranges = {\n\t2, {\n\t\tBIP_RANGE(10),\n\t\tBIP_RANGE(5)\n\t}\n};\n\nstatic unsigned short fake_sawtooth(struct comedi_device *dev,\n\t\t\t\t    unsigned int range_index,\n\t\t\t\t    unsigned int current_time)\n{\n\tstruct waveform_private *devpriv = dev->private;\n\tstruct comedi_subdevice *s = dev->read_subdev;\n\tunsigned int offset = s->maxdata / 2;\n\tu64 value;\n\tconst struct comedi_krange *krange =\n\t    &s->range_table->range[range_index];\n\tu64 binary_amplitude;\n\n\tbinary_amplitude = s->maxdata;\n\tbinary_amplitude *= devpriv->wf_amplitude;\n\tdo_div(binary_amplitude, krange->max - krange->min);\n\n\tvalue = current_time;\n\tvalue *= binary_amplitude * 2;\n\tdo_div(value, devpriv->wf_period);\n\tvalue += offset;\n\t \n\tif (value < binary_amplitude) {\n\t\tvalue = 0;\t\t\t \n\t} else {\n\t\tvalue -= binary_amplitude;\n\t\tif (value > s->maxdata)\n\t\t\tvalue = s->maxdata;\t \n\t}\n\n\treturn value;\n}\n\nstatic unsigned short fake_squarewave(struct comedi_device *dev,\n\t\t\t\t      unsigned int range_index,\n\t\t\t\t      unsigned int current_time)\n{\n\tstruct waveform_private *devpriv = dev->private;\n\tstruct comedi_subdevice *s = dev->read_subdev;\n\tunsigned int offset = s->maxdata / 2;\n\tu64 value;\n\tconst struct comedi_krange *krange =\n\t    &s->range_table->range[range_index];\n\n\tvalue = s->maxdata;\n\tvalue *= devpriv->wf_amplitude;\n\tdo_div(value, krange->max - krange->min);\n\n\t \n\tif (current_time < devpriv->wf_period / 2) {\n\t\tif (offset < value)\n\t\t\tvalue = 0;\t\t \n\t\telse\n\t\t\tvalue = offset - value;\n\t} else {\n\t\tvalue += offset;\n\t\tif (value > s->maxdata)\n\t\t\tvalue = s->maxdata;\t \n\t}\n\n\treturn value;\n}\n\nstatic unsigned short fake_flatline(struct comedi_device *dev,\n\t\t\t\t    unsigned int range_index,\n\t\t\t\t    unsigned int current_time)\n{\n\treturn dev->read_subdev->maxdata / 2;\n}\n\n \nstatic unsigned short fake_waveform(struct comedi_device *dev,\n\t\t\t\t    unsigned int channel, unsigned int range,\n\t\t\t\t    unsigned int current_time)\n{\n\tenum {\n\t\tSAWTOOTH_CHAN,\n\t\tSQUARE_CHAN,\n\t};\n\tswitch (channel) {\n\tcase SAWTOOTH_CHAN:\n\t\treturn fake_sawtooth(dev, range, current_time);\n\tcase SQUARE_CHAN:\n\t\treturn fake_squarewave(dev, range, current_time);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn fake_flatline(dev, range, current_time);\n}\n\n \nstatic void waveform_ai_timer(struct timer_list *t)\n{\n\tstruct waveform_private *devpriv = from_timer(devpriv, t, ai_timer);\n\tstruct comedi_device *dev = devpriv->dev;\n\tstruct comedi_subdevice *s = dev->read_subdev;\n\tstruct comedi_async *async = s->async;\n\tstruct comedi_cmd *cmd = &async->cmd;\n\tu64 now;\n\tunsigned int nsamples;\n\tunsigned int time_increment;\n\n\tnow = ktime_to_us(ktime_get());\n\tnsamples = comedi_nsamples_left(s, UINT_MAX);\n\n\twhile (nsamples && devpriv->ai_convert_time < now) {\n\t\tunsigned int chanspec = cmd->chanlist[async->cur_chan];\n\t\tunsigned short sample;\n\n\t\tsample = fake_waveform(dev, CR_CHAN(chanspec),\n\t\t\t\t       CR_RANGE(chanspec), devpriv->wf_current);\n\t\tif (comedi_buf_write_samples(s, &sample, 1) == 0)\n\t\t\tgoto overrun;\n\t\ttime_increment = devpriv->ai_convert_period;\n\t\tif (async->scan_progress == 0) {\n\t\t\t \n\t\t\ttime_increment += devpriv->ai_scan_period -\n\t\t\t\t\t  devpriv->ai_convert_period *\n\t\t\t\t\t  cmd->scan_end_arg;\n\t\t}\n\t\tdevpriv->wf_current += time_increment;\n\t\tif (devpriv->wf_current >= devpriv->wf_period)\n\t\t\tdevpriv->wf_current %= devpriv->wf_period;\n\t\tdevpriv->ai_convert_time += time_increment;\n\t\tnsamples--;\n\t}\n\n\tif (cmd->stop_src == TRIG_COUNT && async->scans_done >= cmd->stop_arg) {\n\t\tasync->events |= COMEDI_CB_EOA;\n\t} else {\n\t\tif (devpriv->ai_convert_time > now)\n\t\t\ttime_increment = devpriv->ai_convert_time - now;\n\t\telse\n\t\t\ttime_increment = 1;\n\t\tmod_timer(&devpriv->ai_timer,\n\t\t\t  jiffies + usecs_to_jiffies(time_increment));\n\t}\n\noverrun:\n\tcomedi_handle_events(dev, s);\n}\n\nstatic int waveform_ai_cmdtest(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       struct comedi_cmd *cmd)\n{\n\tint err = 0;\n\tunsigned int arg, limit;\n\n\t \n\n\terr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW);\n\terr |= comedi_check_trigger_src(&cmd->scan_begin_src,\n\t\t\t\t\tTRIG_FOLLOW | TRIG_TIMER);\n\terr |= comedi_check_trigger_src(&cmd->convert_src,\n\t\t\t\t\tTRIG_NOW | TRIG_TIMER);\n\terr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\n\terr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\n\n\tif (err)\n\t\treturn 1;\n\n\t \n\n\terr |= comedi_check_trigger_is_unique(cmd->convert_src);\n\terr |= comedi_check_trigger_is_unique(cmd->stop_src);\n\n\t \n\n\tif (cmd->scan_begin_src == TRIG_FOLLOW && cmd->convert_src == TRIG_NOW)\n\t\terr |= -EINVAL;\t\t \n\n\tif (err)\n\t\treturn 2;\n\n\t \n\n\terr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\n\n\tif (cmd->convert_src == TRIG_NOW) {\n\t\terr |= comedi_check_trigger_arg_is(&cmd->convert_arg, 0);\n\t} else {\t \n\t\tif (cmd->scan_begin_src == TRIG_FOLLOW) {\n\t\t\terr |= comedi_check_trigger_arg_min(&cmd->convert_arg,\n\t\t\t\t\t\t\t    NSEC_PER_USEC);\n\t\t}\n\t}\n\n\tif (cmd->scan_begin_src == TRIG_FOLLOW) {\n\t\terr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);\n\t} else {\t \n\t\terr |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,\n\t\t\t\t\t\t    NSEC_PER_USEC);\n\t}\n\n\terr |= comedi_check_trigger_arg_min(&cmd->chanlist_len, 1);\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\n\t\t\t\t\t   cmd->chanlist_len);\n\n\tif (cmd->stop_src == TRIG_COUNT)\n\t\terr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\n\telse\t \n\t\terr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\n\n\tif (err)\n\t\treturn 3;\n\n\t \n\n\tif (cmd->convert_src == TRIG_TIMER) {\n\t\t \n\t\targ = cmd->convert_arg;\n\t\targ = min(arg,\n\t\t\t  rounddown(UINT_MAX, (unsigned int)NSEC_PER_USEC));\n\t\targ = NSEC_PER_USEC * DIV_ROUND_CLOSEST(arg, NSEC_PER_USEC);\n\t\tif (cmd->scan_begin_arg == TRIG_TIMER) {\n\t\t\t \n\t\t\tlimit = UINT_MAX / cmd->scan_end_arg;\n\t\t\tlimit = rounddown(limit, (unsigned int)NSEC_PER_SEC);\n\t\t\targ = min(arg, limit);\n\t\t}\n\t\terr |= comedi_check_trigger_arg_is(&cmd->convert_arg, arg);\n\t}\n\n\tif (cmd->scan_begin_src == TRIG_TIMER) {\n\t\t \n\t\targ = cmd->scan_begin_arg;\n\t\targ = min(arg,\n\t\t\t  rounddown(UINT_MAX, (unsigned int)NSEC_PER_USEC));\n\t\targ = NSEC_PER_USEC * DIV_ROUND_CLOSEST(arg, NSEC_PER_USEC);\n\t\tif (cmd->convert_src == TRIG_TIMER) {\n\t\t\t \n\t\t\targ = max(arg, cmd->convert_arg * cmd->scan_end_arg);\n\t\t}\n\t\terr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, arg);\n\t}\n\n\tif (err)\n\t\treturn 4;\n\n\treturn 0;\n}\n\nstatic int waveform_ai_cmd(struct comedi_device *dev,\n\t\t\t   struct comedi_subdevice *s)\n{\n\tstruct waveform_private *devpriv = dev->private;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tunsigned int first_convert_time;\n\tu64 wf_current;\n\n\tif (cmd->flags & CMDF_PRIORITY) {\n\t\tdev_err(dev->class_dev,\n\t\t\t\"commands at RT priority not supported in this driver\\n\");\n\t\treturn -1;\n\t}\n\n\tif (cmd->convert_src == TRIG_NOW)\n\t\tdevpriv->ai_convert_period = 0;\n\telse\t\t \n\t\tdevpriv->ai_convert_period = cmd->convert_arg / NSEC_PER_USEC;\n\n\tif (cmd->scan_begin_src == TRIG_FOLLOW) {\n\t\tdevpriv->ai_scan_period = devpriv->ai_convert_period *\n\t\t\t\t\t  cmd->scan_end_arg;\n\t} else {\t \n\t\tdevpriv->ai_scan_period = cmd->scan_begin_arg / NSEC_PER_USEC;\n\t}\n\n\t \n\tfirst_convert_time = devpriv->ai_convert_period;\n\tif (cmd->scan_begin_src == TRIG_TIMER)\n\t\tfirst_convert_time += devpriv->ai_scan_period;\n\tdevpriv->ai_convert_time = ktime_to_us(ktime_get()) +\n\t\t\t\t   first_convert_time;\n\n\t \n\twf_current = devpriv->ai_convert_time;\n\tdevpriv->wf_current = do_div(wf_current, devpriv->wf_period);\n\n\t \n\tdevpriv->ai_timer.expires =\n\t\tjiffies + usecs_to_jiffies(devpriv->ai_convert_period) + 1;\n\tadd_timer(&devpriv->ai_timer);\n\treturn 0;\n}\n\nstatic int waveform_ai_cancel(struct comedi_device *dev,\n\t\t\t      struct comedi_subdevice *s)\n{\n\tstruct waveform_private *devpriv = dev->private;\n\n\tif (in_softirq()) {\n\t\t \n\t\tdel_timer(&devpriv->ai_timer);\n\t} else {\n\t\tdel_timer_sync(&devpriv->ai_timer);\n\t}\n\treturn 0;\n}\n\nstatic int waveform_ai_insn_read(struct comedi_device *dev,\n\t\t\t\t struct comedi_subdevice *s,\n\t\t\t\t struct comedi_insn *insn, unsigned int *data)\n{\n\tstruct waveform_private *devpriv = dev->private;\n\tint i, chan = CR_CHAN(insn->chanspec);\n\n\tfor (i = 0; i < insn->n; i++)\n\t\tdata[i] = devpriv->ao_loopbacks[chan];\n\n\treturn insn->n;\n}\n\n \nstatic void waveform_ao_timer(struct timer_list *t)\n{\n\tstruct waveform_private *devpriv = from_timer(devpriv, t, ao_timer);\n\tstruct comedi_device *dev = devpriv->dev;\n\tstruct comedi_subdevice *s = dev->write_subdev;\n\tstruct comedi_async *async = s->async;\n\tstruct comedi_cmd *cmd = &async->cmd;\n\tu64 now;\n\tu64 scans_since;\n\tunsigned int scans_avail = 0;\n\n\t \n\tnow = ktime_to_us(ktime_get());\n\tscans_since = now - devpriv->ao_last_scan_time;\n\tdo_div(scans_since, devpriv->ao_scan_period);\n\tif (scans_since) {\n\t\tunsigned int i;\n\n\t\t \n\t\tscans_avail = comedi_nscans_left(s, 0);\n\t\tif (scans_avail > scans_since)\n\t\t\tscans_avail = scans_since;\n\t\tif (scans_avail) {\n\t\t\t \n\t\t\tif (scans_avail > 1) {\n\t\t\t\tunsigned int skip_bytes, nbytes;\n\n\t\t\t\tskip_bytes =\n\t\t\t\tcomedi_samples_to_bytes(s, cmd->scan_end_arg *\n\t\t\t\t\t\t\t   (scans_avail - 1));\n\t\t\t\tnbytes = comedi_buf_read_alloc(s, skip_bytes);\n\t\t\t\tcomedi_buf_read_free(s, nbytes);\n\t\t\t\tcomedi_inc_scan_progress(s, nbytes);\n\t\t\t\tif (nbytes < skip_bytes) {\n\t\t\t\t\t \n\t\t\t\t\tasync->events |= COMEDI_CB_OVERFLOW;\n\t\t\t\t\tgoto underrun;\n\t\t\t\t}\n\t\t\t}\n\t\t\t \n\t\t\tfor (i = 0; i < cmd->scan_end_arg; i++) {\n\t\t\t\tunsigned int chan = CR_CHAN(cmd->chanlist[i]);\n\t\t\t\tunsigned short *pd;\n\n\t\t\t\tpd = &devpriv->ao_loopbacks[chan];\n\n\t\t\t\tif (!comedi_buf_read_samples(s, pd, 1)) {\n\t\t\t\t\t \n\t\t\t\t\tasync->events |= COMEDI_CB_OVERFLOW;\n\t\t\t\t\tgoto underrun;\n\t\t\t\t}\n\t\t\t}\n\t\t\t \n\t\t\tdevpriv->ao_last_scan_time +=\n\t\t\t\t(u64)scans_avail * devpriv->ao_scan_period;\n\t\t}\n\t}\n\tif (cmd->stop_src == TRIG_COUNT && async->scans_done >= cmd->stop_arg) {\n\t\tasync->events |= COMEDI_CB_EOA;\n\t} else if (scans_avail < scans_since) {\n\t\tasync->events |= COMEDI_CB_OVERFLOW;\n\t} else {\n\t\tunsigned int time_inc = devpriv->ao_last_scan_time +\n\t\t\t\t\tdevpriv->ao_scan_period - now;\n\n\t\tmod_timer(&devpriv->ao_timer,\n\t\t\t  jiffies + usecs_to_jiffies(time_inc));\n\t}\n\nunderrun:\n\tcomedi_handle_events(dev, s);\n}\n\nstatic int waveform_ao_inttrig_start(struct comedi_device *dev,\n\t\t\t\t     struct comedi_subdevice *s,\n\t\t\t\t     unsigned int trig_num)\n{\n\tstruct waveform_private *devpriv = dev->private;\n\tstruct comedi_async *async = s->async;\n\tstruct comedi_cmd *cmd = &async->cmd;\n\n\tif (trig_num != cmd->start_arg)\n\t\treturn -EINVAL;\n\n\tasync->inttrig = NULL;\n\n\tdevpriv->ao_last_scan_time = ktime_to_us(ktime_get());\n\tdevpriv->ao_timer.expires =\n\t\tjiffies + usecs_to_jiffies(devpriv->ao_scan_period);\n\tadd_timer(&devpriv->ao_timer);\n\n\treturn 1;\n}\n\nstatic int waveform_ao_cmdtest(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       struct comedi_cmd *cmd)\n{\n\tint err = 0;\n\tunsigned int arg;\n\n\t \n\n\terr |= comedi_check_trigger_src(&cmd->start_src, TRIG_INT);\n\terr |= comedi_check_trigger_src(&cmd->scan_begin_src, TRIG_TIMER);\n\terr |= comedi_check_trigger_src(&cmd->convert_src, TRIG_NOW);\n\terr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\n\terr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\n\n\tif (err)\n\t\treturn 1;\n\n\t \n\n\terr |= comedi_check_trigger_is_unique(cmd->stop_src);\n\n\t \n\n\tif (err)\n\t\treturn 2;\n\n\t \n\n\terr |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,\n\t\t\t\t\t    NSEC_PER_USEC);\n\terr |= comedi_check_trigger_arg_is(&cmd->convert_arg, 0);\n\terr |= comedi_check_trigger_arg_min(&cmd->chanlist_len, 1);\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\n\t\t\t\t\t   cmd->chanlist_len);\n\tif (cmd->stop_src == TRIG_COUNT)\n\t\terr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\n\telse\t \n\t\terr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\n\n\tif (err)\n\t\treturn 3;\n\n\t \n\n\t \n\targ = cmd->scan_begin_arg;\n\targ = min(arg, rounddown(UINT_MAX, (unsigned int)NSEC_PER_USEC));\n\targ = NSEC_PER_USEC * DIV_ROUND_CLOSEST(arg, NSEC_PER_USEC);\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, arg);\n\n\tif (err)\n\t\treturn 4;\n\n\treturn 0;\n}\n\nstatic int waveform_ao_cmd(struct comedi_device *dev,\n\t\t\t   struct comedi_subdevice *s)\n{\n\tstruct waveform_private *devpriv = dev->private;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\n\tif (cmd->flags & CMDF_PRIORITY) {\n\t\tdev_err(dev->class_dev,\n\t\t\t\"commands at RT priority not supported in this driver\\n\");\n\t\treturn -1;\n\t}\n\n\tdevpriv->ao_scan_period = cmd->scan_begin_arg / NSEC_PER_USEC;\n\ts->async->inttrig = waveform_ao_inttrig_start;\n\treturn 0;\n}\n\nstatic int waveform_ao_cancel(struct comedi_device *dev,\n\t\t\t      struct comedi_subdevice *s)\n{\n\tstruct waveform_private *devpriv = dev->private;\n\n\ts->async->inttrig = NULL;\n\tif (in_softirq()) {\n\t\t \n\t\tdel_timer(&devpriv->ao_timer);\n\t} else {\n\t\tdel_timer_sync(&devpriv->ao_timer);\n\t}\n\treturn 0;\n}\n\nstatic int waveform_ao_insn_write(struct comedi_device *dev,\n\t\t\t\t  struct comedi_subdevice *s,\n\t\t\t\t  struct comedi_insn *insn, unsigned int *data)\n{\n\tstruct waveform_private *devpriv = dev->private;\n\tint i, chan = CR_CHAN(insn->chanspec);\n\n\tfor (i = 0; i < insn->n; i++)\n\t\tdevpriv->ao_loopbacks[chan] = data[i];\n\n\treturn insn->n;\n}\n\nstatic int waveform_ai_insn_config(struct comedi_device *dev,\n\t\t\t\t   struct comedi_subdevice *s,\n\t\t\t\t   struct comedi_insn *insn,\n\t\t\t\t   unsigned int *data)\n{\n\tif (data[0] == INSN_CONFIG_GET_CMD_TIMING_CONSTRAINTS) {\n\t\t \n\t\tif (data[1] == TRIG_FOLLOW) {\n\t\t\t \n\t\t\tdata[1] = 0;\n\t\t\tdata[2] = NSEC_PER_USEC;\n\t\t} else {\n\t\t\tdata[1] = NSEC_PER_USEC;\n\t\t\tif (data[2] & TRIG_TIMER)\n\t\t\t\tdata[2] = NSEC_PER_USEC;\n\t\t\telse\n\t\t\t\tdata[2] = 0;\n\t\t}\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int waveform_ao_insn_config(struct comedi_device *dev,\n\t\t\t\t   struct comedi_subdevice *s,\n\t\t\t\t   struct comedi_insn *insn,\n\t\t\t\t   unsigned int *data)\n{\n\tif (data[0] == INSN_CONFIG_GET_CMD_TIMING_CONSTRAINTS) {\n\t\t \n\t\tdata[1] = NSEC_PER_USEC;  \n\t\tdata[2] = 0;\t\t  \n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int waveform_common_attach(struct comedi_device *dev,\n\t\t\t\t  int amplitude, int period)\n{\n\tstruct waveform_private *devpriv;\n\tstruct comedi_subdevice *s;\n\tint i;\n\tint ret;\n\n\tdevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\n\tif (!devpriv)\n\t\treturn -ENOMEM;\n\n\tdevpriv->wf_amplitude = amplitude;\n\tdevpriv->wf_period = period;\n\n\tret = comedi_alloc_subdevices(dev, 2);\n\tif (ret)\n\t\treturn ret;\n\n\ts = &dev->subdevices[0];\n\tdev->read_subdev = s;\n\t \n\ts->type = COMEDI_SUBD_AI;\n\ts->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_CMD_READ;\n\ts->n_chan = N_CHANS;\n\ts->maxdata = 0xffff;\n\ts->range_table = &waveform_ai_ranges;\n\ts->len_chanlist = s->n_chan * 2;\n\ts->insn_read = waveform_ai_insn_read;\n\ts->do_cmd = waveform_ai_cmd;\n\ts->do_cmdtest = waveform_ai_cmdtest;\n\ts->cancel = waveform_ai_cancel;\n\ts->insn_config = waveform_ai_insn_config;\n\n\ts = &dev->subdevices[1];\n\tdev->write_subdev = s;\n\t \n\ts->type = COMEDI_SUBD_AO;\n\ts->subdev_flags = SDF_WRITABLE | SDF_GROUND | SDF_CMD_WRITE;\n\ts->n_chan = N_CHANS;\n\ts->maxdata = 0xffff;\n\ts->range_table = &waveform_ai_ranges;\n\ts->len_chanlist = s->n_chan;\n\ts->insn_write = waveform_ao_insn_write;\n\ts->insn_read = waveform_ai_insn_read;\t \n\ts->do_cmd = waveform_ao_cmd;\n\ts->do_cmdtest = waveform_ao_cmdtest;\n\ts->cancel = waveform_ao_cancel;\n\ts->insn_config = waveform_ao_insn_config;\n\n\t \n\tfor (i = 0; i < s->n_chan; i++)\n\t\tdevpriv->ao_loopbacks[i] = s->maxdata / 2;\n\n\tdevpriv->dev = dev;\n\ttimer_setup(&devpriv->ai_timer, waveform_ai_timer, 0);\n\ttimer_setup(&devpriv->ao_timer, waveform_ao_timer, 0);\n\n\tdev_info(dev->class_dev,\n\t\t \"%s: %u microvolt, %u microsecond waveform attached\\n\",\n\t\t dev->board_name,\n\t\t devpriv->wf_amplitude, devpriv->wf_period);\n\n\treturn 0;\n}\n\nstatic int waveform_attach(struct comedi_device *dev,\n\t\t\t   struct comedi_devconfig *it)\n{\n\tint amplitude = it->options[0];\n\tint period = it->options[1];\n\n\t \n\tif (amplitude <= 0)\n\t\tamplitude = 1000000;\t \n\tif (period <= 0)\n\t\tperiod = 100000;\t \n\n\treturn waveform_common_attach(dev, amplitude, period);\n}\n\nstatic int waveform_auto_attach(struct comedi_device *dev,\n\t\t\t\tunsigned long context_unused)\n{\n\tint amplitude = set_amplitude;\n\tint period = set_period;\n\n\t \n\tif (!amplitude)\n\t\tamplitude = 1000000;\t \n\tif (!period)\n\t\tperiod = 100000;\t \n\n\treturn waveform_common_attach(dev, amplitude, period);\n}\n\nstatic void waveform_detach(struct comedi_device *dev)\n{\n\tstruct waveform_private *devpriv = dev->private;\n\n\tif (devpriv) {\n\t\tdel_timer_sync(&devpriv->ai_timer);\n\t\tdel_timer_sync(&devpriv->ao_timer);\n\t}\n}\n\nstatic struct comedi_driver waveform_driver = {\n\t.driver_name\t= \"comedi_test\",\n\t.module\t\t= THIS_MODULE,\n\t.attach\t\t= waveform_attach,\n\t.auto_attach\t= waveform_auto_attach,\n\t.detach\t\t= waveform_detach,\n};\n\n \nstatic int __init comedi_test_init(void)\n{\n\tint ret;\n\n\tret = comedi_driver_register(&waveform_driver);\n\tif (ret) {\n\t\tpr_err(\"comedi_test: unable to register driver\\n\");\n\t\treturn ret;\n\t}\n\n\tif (!config_mode) {\n\t\tret = class_register(&ctcls);\n\t\tif (ret) {\n\t\t\tpr_warn(\"comedi_test: unable to create class\\n\");\n\t\t\tgoto clean3;\n\t\t}\n\n\t\tctdev = device_create(&ctcls, NULL, MKDEV(0, 0), NULL, DEV_NAME);\n\t\tif (IS_ERR(ctdev)) {\n\t\t\tpr_warn(\"comedi_test: unable to create device\\n\");\n\t\t\tgoto clean2;\n\t\t}\n\n\t\tret = comedi_auto_config(ctdev, &waveform_driver, 0);\n\t\tif (ret) {\n\t\t\tpr_warn(\"comedi_test: unable to auto-configure device\\n\");\n\t\t\tgoto clean;\n\t\t}\n\t}\n\n\treturn 0;\n\nclean:\n\tdevice_destroy(&ctcls, MKDEV(0, 0));\nclean2:\n\tclass_unregister(&ctcls);\nclean3:\n\treturn 0;\n}\nmodule_init(comedi_test_init);\n\nstatic void __exit comedi_test_exit(void)\n{\n\tif (ctdev)\n\t\tcomedi_auto_unconfig(ctdev);\n\n\tif (class_is_registered(&ctcls)) {\n\t\tdevice_destroy(&ctcls, MKDEV(0, 0));\n\t\tclass_unregister(&ctcls);\n\t}\n\n\tcomedi_driver_unregister(&waveform_driver);\n}\nmodule_exit(comedi_test_exit);\n\nMODULE_AUTHOR(\"Comedi https://www.comedi.org\");\nMODULE_DESCRIPTION(\"Comedi low-level driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}