{
  "module_name": "cb_pcidda.c",
  "hash_id": "5e37780965c75f3cf5a89040f4ef46939a7d41addfa9e923382bcc3a4639ffbb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/cb_pcidda.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/comedi/comedi_pci.h>\n#include <linux/comedi/comedi_8255.h>\n\n#define EEPROM_SIZE\t128\t \n \n#define MAX_AO_CHANNELS 8\n\n \n#define CB_DDA_DIO0_8255_BASE\t\t0x00\n#define CB_DDA_DIO1_8255_BASE\t\t0x04\n\n \n#define CB_DDA_DA_CTRL_REG\t\t0x00\t    \n#define CB_DDA_DA_CTRL_SU\t\tBIT(0)    \n#define CB_DDA_DA_CTRL_EN\t\tBIT(1)    \n#define CB_DDA_DA_CTRL_DAC(x)\t\t((x) << 2)  \n#define CB_DDA_DA_CTRL_RANGE2V5\t\t(0 << 6)    \n#define CB_DDA_DA_CTRL_RANGE5V\t\t(2 << 6)    \n#define CB_DDA_DA_CTRL_RANGE10V\t\t(3 << 6)    \n#define CB_DDA_DA_CTRL_UNIP\t\tBIT(8)    \n\n#define DACALIBRATION1\t4\t \n \n \n#define SERIAL_IN_BIT   0x1\n#define\tCAL_CHANNEL_MASK\t(0x7 << 1)\n#define\tCAL_CHANNEL_BITS(channel)\t(((channel) << 1) & CAL_CHANNEL_MASK)\n \n#define\tCAL_COUNTER_MASK\t0x1f\n \n#define CAL_COUNTER_OVERFLOW_BIT        0x20\n \n#define AO_BELOW_REF_BIT        0x40\n#define\tSERIAL_OUT_BIT\t0x80\t \n\n#define DACALIBRATION2\t6\t \n#define\tSELECT_EEPROM_BIT\t0x1\t \n \n#define DESELECT_REF_DAC_BIT    0x2\n \n#define DESELECT_CALDAC_BIT(n)  (0x4 << (n))\n \n#define DUMMY_BIT       0x40\n\n#define CB_DDA_DA_DATA_REG(x)\t\t(0x08 + ((x) * 2))\n\n \n#define CB_DDA_CALDAC_FINE_GAIN\t\t0\n#define CB_DDA_CALDAC_COURSE_GAIN\t1\n#define CB_DDA_CALDAC_COURSE_OFFSET\t2\n#define CB_DDA_CALDAC_FINE_OFFSET\t3\n\nstatic const struct comedi_lrange cb_pcidda_ranges = {\n\t6, {\n\t\tBIP_RANGE(10),\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(2.5),\n\t\tUNI_RANGE(10),\n\t\tUNI_RANGE(5),\n\t\tUNI_RANGE(2.5)\n\t}\n};\n\nenum cb_pcidda_boardid {\n\tBOARD_DDA02_12,\n\tBOARD_DDA04_12,\n\tBOARD_DDA08_12,\n\tBOARD_DDA02_16,\n\tBOARD_DDA04_16,\n\tBOARD_DDA08_16,\n};\n\nstruct cb_pcidda_board {\n\tconst char *name;\n\tint ao_chans;\n\tint ao_bits;\n};\n\nstatic const struct cb_pcidda_board cb_pcidda_boards[] = {\n\t[BOARD_DDA02_12] = {\n\t\t.name\t\t= \"pci-dda02/12\",\n\t\t.ao_chans\t= 2,\n\t\t.ao_bits\t= 12,\n\t},\n\t[BOARD_DDA04_12] = {\n\t\t.name\t\t= \"pci-dda04/12\",\n\t\t.ao_chans\t= 4,\n\t\t.ao_bits\t= 12,\n\t},\n\t[BOARD_DDA08_12] = {\n\t\t.name\t\t= \"pci-dda08/12\",\n\t\t.ao_chans\t= 8,\n\t\t.ao_bits\t= 12,\n\t},\n\t[BOARD_DDA02_16] = {\n\t\t.name\t\t= \"pci-dda02/16\",\n\t\t.ao_chans\t= 2,\n\t\t.ao_bits\t= 16,\n\t},\n\t[BOARD_DDA04_16] = {\n\t\t.name\t\t= \"pci-dda04/16\",\n\t\t.ao_chans\t= 4,\n\t\t.ao_bits\t= 16,\n\t},\n\t[BOARD_DDA08_16] = {\n\t\t.name\t\t= \"pci-dda08/16\",\n\t\t.ao_chans\t= 8,\n\t\t.ao_bits\t= 16,\n\t},\n};\n\nstruct cb_pcidda_private {\n\tunsigned long daqio;\n\t \n\tunsigned int dac_cal1_bits;\n\t \n\tunsigned int ao_range[MAX_AO_CHANNELS];\n\tu16 eeprom_data[EEPROM_SIZE];\t \n};\n\n \nstatic unsigned int cb_pcidda_serial_in(struct comedi_device *dev)\n{\n\tstruct cb_pcidda_private *devpriv = dev->private;\n\tunsigned int value = 0;\n\tint i;\n\tconst int value_width = 16;\t \n\n\tfor (i = 1; i <= value_width; i++) {\n\t\t \n\t\tif (inw_p(devpriv->daqio + DACALIBRATION1) & SERIAL_OUT_BIT)\n\t\t\tvalue |= 1 << (value_width - i);\n\t}\n\n\treturn value;\n}\n\n \nstatic void cb_pcidda_serial_out(struct comedi_device *dev, unsigned int value,\n\t\t\t\t unsigned int num_bits)\n{\n\tstruct cb_pcidda_private *devpriv = dev->private;\n\tint i;\n\n\tfor (i = 1; i <= num_bits; i++) {\n\t\t \n\t\tif (value & (1 << (num_bits - i)))\n\t\t\tdevpriv->dac_cal1_bits |= SERIAL_IN_BIT;\n\t\telse\n\t\t\tdevpriv->dac_cal1_bits &= ~SERIAL_IN_BIT;\n\t\toutw_p(devpriv->dac_cal1_bits, devpriv->daqio + DACALIBRATION1);\n\t}\n}\n\n \nstatic unsigned int cb_pcidda_read_eeprom(struct comedi_device *dev,\n\t\t\t\t\t  unsigned int address)\n{\n\tstruct cb_pcidda_private *devpriv = dev->private;\n\tunsigned int i;\n\tunsigned int cal2_bits;\n\tunsigned int value;\n\t \n\tconst int max_num_caldacs = 4;\n\t \n\tconst int read_instruction = 0x6;\n\tconst int instruction_length = 3;\n\tconst int address_length = 8;\n\n\t \n\tcal2_bits = SELECT_EEPROM_BIT | DESELECT_REF_DAC_BIT | DUMMY_BIT;\n\t \n\tfor (i = 0; i < max_num_caldacs; i++)\n\t\tcal2_bits |= DESELECT_CALDAC_BIT(i);\n\toutw_p(cal2_bits, devpriv->daqio + DACALIBRATION2);\n\n\t \n\tcb_pcidda_serial_out(dev, read_instruction, instruction_length);\n\t \n\tcb_pcidda_serial_out(dev, address, address_length);\n\n\tvalue = cb_pcidda_serial_in(dev);\n\n\t \n\tcal2_bits &= ~SELECT_EEPROM_BIT;\n\toutw_p(cal2_bits, devpriv->daqio + DACALIBRATION2);\n\n\treturn value;\n}\n\n \nstatic void cb_pcidda_write_caldac(struct comedi_device *dev,\n\t\t\t\t   unsigned int caldac, unsigned int channel,\n\t\t\t\t   unsigned int value)\n{\n\tstruct cb_pcidda_private *devpriv = dev->private;\n\tunsigned int cal2_bits;\n\tunsigned int i;\n\t \n\tconst int num_channel_bits = 3;\n\tconst int num_caldac_bits = 8;\t \n\t \n\tconst int max_num_caldacs = 4;\n\n\t \n\tcb_pcidda_serial_out(dev, channel, num_channel_bits);\n\t \n\tcb_pcidda_serial_out(dev, value, num_caldac_bits);\n\n \n\tcal2_bits = DESELECT_REF_DAC_BIT | DUMMY_BIT;\n\t \n\tfor (i = 0; i < max_num_caldacs; i++)\n\t\tcal2_bits |= DESELECT_CALDAC_BIT(i);\n\t \n\tcal2_bits &= ~DESELECT_CALDAC_BIT(caldac);\n\toutw_p(cal2_bits, devpriv->daqio + DACALIBRATION2);\n\t \n\tcal2_bits |= DESELECT_CALDAC_BIT(caldac);\n\toutw_p(cal2_bits, devpriv->daqio + DACALIBRATION2);\n}\n\n \nstatic void cb_pcidda_calibrate(struct comedi_device *dev, unsigned int channel,\n\t\t\t\tunsigned int range)\n{\n\tstruct cb_pcidda_private *devpriv = dev->private;\n\tunsigned int caldac = channel / 2;\t \n\tunsigned int chan = 4 * (channel % 2);\t \n\tunsigned int index = 2 * range + 12 * channel;\n\tunsigned int offset;\n\tunsigned int gain;\n\n\t \n\tdevpriv->ao_range[channel] = range;\n\n\t \n\toffset = devpriv->eeprom_data[0x7 + index];\n\tgain = devpriv->eeprom_data[0x8 + index];\n\n\t \n\tcb_pcidda_write_caldac(dev, caldac, chan + CB_DDA_CALDAC_COURSE_OFFSET,\n\t\t\t       (offset >> 8) & 0xff);\n\tcb_pcidda_write_caldac(dev, caldac, chan + CB_DDA_CALDAC_FINE_OFFSET,\n\t\t\t       offset & 0xff);\n\tcb_pcidda_write_caldac(dev, caldac, chan + CB_DDA_CALDAC_COURSE_GAIN,\n\t\t\t       (gain >> 8) & 0xff);\n\tcb_pcidda_write_caldac(dev, caldac, chan + CB_DDA_CALDAC_FINE_GAIN,\n\t\t\t       gain & 0xff);\n}\n\nstatic int cb_pcidda_ao_insn_write(struct comedi_device *dev,\n\t\t\t\t   struct comedi_subdevice *s,\n\t\t\t\t   struct comedi_insn *insn,\n\t\t\t\t   unsigned int *data)\n{\n\tstruct cb_pcidda_private *devpriv = dev->private;\n\tunsigned int channel = CR_CHAN(insn->chanspec);\n\tunsigned int range = CR_RANGE(insn->chanspec);\n\tunsigned int ctrl;\n\tunsigned int i;\n\n\tif (range != devpriv->ao_range[channel])\n\t\tcb_pcidda_calibrate(dev, channel, range);\n\n\tctrl = CB_DDA_DA_CTRL_EN | CB_DDA_DA_CTRL_DAC(channel);\n\n\tswitch (range) {\n\tcase 0:\n\tcase 3:\n\t\tctrl |= CB_DDA_DA_CTRL_RANGE10V;\n\t\tbreak;\n\tcase 1:\n\tcase 4:\n\t\tctrl |= CB_DDA_DA_CTRL_RANGE5V;\n\t\tbreak;\n\tcase 2:\n\tcase 5:\n\t\tctrl |= CB_DDA_DA_CTRL_RANGE2V5;\n\t\tbreak;\n\t}\n\n\tif (range > 2)\n\t\tctrl |= CB_DDA_DA_CTRL_UNIP;\n\n\toutw(ctrl, devpriv->daqio + CB_DDA_DA_CTRL_REG);\n\n\tfor (i = 0; i < insn->n; i++)\n\t\toutw(data[i], devpriv->daqio + CB_DDA_DA_DATA_REG(channel));\n\n\treturn insn->n;\n}\n\nstatic int cb_pcidda_auto_attach(struct comedi_device *dev,\n\t\t\t\t unsigned long context)\n{\n\tstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\n\tconst struct cb_pcidda_board *board = NULL;\n\tstruct cb_pcidda_private *devpriv;\n\tstruct comedi_subdevice *s;\n\tint i;\n\tint ret;\n\n\tif (context < ARRAY_SIZE(cb_pcidda_boards))\n\t\tboard = &cb_pcidda_boards[context];\n\tif (!board)\n\t\treturn -ENODEV;\n\tdev->board_ptr = board;\n\tdev->board_name = board->name;\n\n\tdevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\n\tif (!devpriv)\n\t\treturn -ENOMEM;\n\n\tret = comedi_pci_enable(dev);\n\tif (ret)\n\t\treturn ret;\n\tdev->iobase = pci_resource_start(pcidev, 2);\n\tdevpriv->daqio = pci_resource_start(pcidev, 3);\n\n\tret = comedi_alloc_subdevices(dev, 3);\n\tif (ret)\n\t\treturn ret;\n\n\ts = &dev->subdevices[0];\n\t \n\ts->type = COMEDI_SUBD_AO;\n\ts->subdev_flags = SDF_WRITABLE;\n\ts->n_chan = board->ao_chans;\n\ts->maxdata = (1 << board->ao_bits) - 1;\n\ts->range_table = &cb_pcidda_ranges;\n\ts->insn_write = cb_pcidda_ao_insn_write;\n\n\t \n\tfor (i = 0; i < 2; i++) {\n\t\ts = &dev->subdevices[1 + i];\n\t\tret = subdev_8255_init(dev, s, NULL, i * I8255_SIZE);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tfor (i = 0; i < EEPROM_SIZE; i++)\n\t\tdevpriv->eeprom_data[i] = cb_pcidda_read_eeprom(dev, i);\n\n\t \n\tfor (i = 0; i < board->ao_chans; i++)\n\t\tcb_pcidda_calibrate(dev, i, devpriv->ao_range[i]);\n\n\treturn 0;\n}\n\nstatic struct comedi_driver cb_pcidda_driver = {\n\t.driver_name\t= \"cb_pcidda\",\n\t.module\t\t= THIS_MODULE,\n\t.auto_attach\t= cb_pcidda_auto_attach,\n\t.detach\t\t= comedi_pci_detach,\n};\n\nstatic int cb_pcidda_pci_probe(struct pci_dev *dev,\n\t\t\t       const struct pci_device_id *id)\n{\n\treturn comedi_pci_auto_config(dev, &cb_pcidda_driver,\n\t\t\t\t      id->driver_data);\n}\n\nstatic const struct pci_device_id cb_pcidda_pci_table[] = {\n\t{ PCI_VDEVICE(CB, 0x0020), BOARD_DDA02_12 },\n\t{ PCI_VDEVICE(CB, 0x0021), BOARD_DDA04_12 },\n\t{ PCI_VDEVICE(CB, 0x0022), BOARD_DDA08_12 },\n\t{ PCI_VDEVICE(CB, 0x0023), BOARD_DDA02_16 },\n\t{ PCI_VDEVICE(CB, 0x0024), BOARD_DDA04_16 },\n\t{ PCI_VDEVICE(CB, 0x0025), BOARD_DDA08_16 },\n\t{ 0 }\n};\nMODULE_DEVICE_TABLE(pci, cb_pcidda_pci_table);\n\nstatic struct pci_driver cb_pcidda_pci_driver = {\n\t.name\t\t= \"cb_pcidda\",\n\t.id_table\t= cb_pcidda_pci_table,\n\t.probe\t\t= cb_pcidda_pci_probe,\n\t.remove\t\t= comedi_pci_auto_unconfig,\n};\nmodule_comedi_pci_driver(cb_pcidda_driver, cb_pcidda_pci_driver);\n\nMODULE_AUTHOR(\"Comedi https://www.comedi.org\");\nMODULE_DESCRIPTION(\"Comedi low-level driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}