{
  "module_name": "usbduxfast.c",
  "hash_id": "1651b850e4586e9f548f1061b4aaeb1ad02430f674b5e3cbdaf5da18ecf99955",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/usbduxfast.c",
  "human_readable_source": "\n \n\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/input.h>\n#include <linux/fcntl.h>\n#include <linux/compiler.h>\n#include <linux/comedi/comedi_usb.h>\n\n \n#define EZTIMEOUT\t30\n\n \n#define FIRMWARE\t\t\"usbduxfast_firmware.bin\"\n#define FIRMWARE_MAX_LEN\t0x2000\n#define USBDUXFASTSUB_FIRMWARE\t0xA0\n#define VENDOR_DIR_IN\t\t0xC0\n#define VENDOR_DIR_OUT\t\t0x40\n\n \n#define USBDUXFASTSUB_CPUCS\t0xE600\n\n \n#define TB_LEN\t0x2000\n\n \n#define BULKINEP\t6\n\n \n#define CHANNELLISTEP\t4\n\n \n#define NUMCHANNELS\t32\n\n \n#define WAVESIZE\t0x20\n\n \n#define SIZEADIN\t(sizeof(s16))\n\n \n#define SIZEINBUF\t512\n\n \n#define SIZEINSNBUF\t512\n\n \n#define SIZEOFDUXBUF\t256\n\n \n#define NUMOFINBUFFERSHIGH\t10\n\n \n#define MIN_SAMPLING_PERIOD\t9\n\n \n#define MAX_SAMPLING_PERIOD\t500\n\n \n#define PACKETS_TO_IGNORE\t4\n\n \nstatic const struct comedi_lrange range_usbduxfast_ai_range = {\n\t2, {\n\t\tBIP_RANGE(0.75),\n\t\tBIP_RANGE(0.5)\n\t}\n};\n\n \nstruct usbduxfast_private {\n\tstruct urb *urb;\t \n\tu8 *duxbuf;\n\ts8 *inbuf;\n\tshort int ai_cmd_running;\t \n\tint ignore;\t\t \n\tstruct mutex mut;\n};\n\n \n#define SENDADCOMMANDS            0\n#define SENDINITEP6               1\n\nstatic int usbduxfast_send_cmd(struct comedi_device *dev, int cmd_type)\n{\n\tstruct usb_device *usb = comedi_to_usb_dev(dev);\n\tstruct usbduxfast_private *devpriv = dev->private;\n\tint nsent;\n\tint ret;\n\n\tdevpriv->duxbuf[0] = cmd_type;\n\n\tret = usb_bulk_msg(usb, usb_sndbulkpipe(usb, CHANNELLISTEP),\n\t\t\t   devpriv->duxbuf, SIZEOFDUXBUF,\n\t\t\t   &nsent, 10000);\n\tif (ret < 0)\n\t\tdev_err(dev->class_dev,\n\t\t\t\"could not transmit command to the usb-device, err=%d\\n\",\n\t\t\tret);\n\treturn ret;\n}\n\nstatic void usbduxfast_cmd_data(struct comedi_device *dev, int index,\n\t\t\t\tu8 len, u8 op, u8 out, u8 log)\n{\n\tstruct usbduxfast_private *devpriv = dev->private;\n\n\t \n\tdevpriv->duxbuf[1 + 0x00 + index] = len;\n\tdevpriv->duxbuf[1 + 0x08 + index] = op;\n\tdevpriv->duxbuf[1 + 0x10 + index] = out;\n\tdevpriv->duxbuf[1 + 0x18 + index] = log;\n}\n\nstatic int usbduxfast_ai_stop(struct comedi_device *dev, int do_unlink)\n{\n\tstruct usbduxfast_private *devpriv = dev->private;\n\n\t \n\tdevpriv->ai_cmd_running = 0;\n\n\tif (do_unlink && devpriv->urb) {\n\t\t \n\t\tusb_kill_urb(devpriv->urb);\n\t}\n\n\treturn 0;\n}\n\nstatic int usbduxfast_ai_cancel(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s)\n{\n\tstruct usbduxfast_private *devpriv = dev->private;\n\tint ret;\n\n\tmutex_lock(&devpriv->mut);\n\tret = usbduxfast_ai_stop(dev, 1);\n\tmutex_unlock(&devpriv->mut);\n\n\treturn ret;\n}\n\nstatic void usbduxfast_ai_handle_urb(struct comedi_device *dev,\n\t\t\t\t     struct comedi_subdevice *s,\n\t\t\t\t     struct urb *urb)\n{\n\tstruct usbduxfast_private *devpriv = dev->private;\n\tstruct comedi_async *async = s->async;\n\tstruct comedi_cmd *cmd = &async->cmd;\n\tint ret;\n\n\tif (devpriv->ignore) {\n\t\tdevpriv->ignore--;\n\t} else {\n\t\tunsigned int nsamples;\n\n\t\tnsamples = comedi_bytes_to_samples(s, urb->actual_length);\n\t\tnsamples = comedi_nsamples_left(s, nsamples);\n\t\tcomedi_buf_write_samples(s, urb->transfer_buffer, nsamples);\n\n\t\tif (cmd->stop_src == TRIG_COUNT &&\n\t\t    async->scans_done >= cmd->stop_arg)\n\t\t\tasync->events |= COMEDI_CB_EOA;\n\t}\n\n\t \n\tif (!(async->events & COMEDI_CB_CANCEL_MASK)) {\n\t\turb->dev = comedi_to_usb_dev(dev);\n\t\turb->status = 0;\n\t\tret = usb_submit_urb(urb, GFP_ATOMIC);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev->class_dev, \"urb resubm failed: %d\", ret);\n\t\t\tasync->events |= COMEDI_CB_ERROR;\n\t\t}\n\t}\n}\n\nstatic void usbduxfast_ai_interrupt(struct urb *urb)\n{\n\tstruct comedi_device *dev = urb->context;\n\tstruct comedi_subdevice *s = dev->read_subdev;\n\tstruct comedi_async *async = s->async;\n\tstruct usbduxfast_private *devpriv = dev->private;\n\n\t \n\tif (!devpriv->ai_cmd_running)\n\t\treturn;\n\n\tswitch (urb->status) {\n\tcase 0:\n\t\tusbduxfast_ai_handle_urb(dev, s, urb);\n\t\tbreak;\n\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\tcase -ECONNABORTED:\n\t\t \n\t\tasync->events |= COMEDI_CB_ERROR;\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tdev_err(dev->class_dev,\n\t\t\t\"non-zero urb status received in ai intr context: %d\\n\",\n\t\t\turb->status);\n\t\tasync->events |= COMEDI_CB_ERROR;\n\t\tbreak;\n\t}\n\n\t \n\tif (async->events & COMEDI_CB_CANCEL_MASK)\n\t\tusbduxfast_ai_stop(dev, 0);\n\n\tcomedi_event(dev, s);\n}\n\nstatic int usbduxfast_submit_urb(struct comedi_device *dev)\n{\n\tstruct usb_device *usb = comedi_to_usb_dev(dev);\n\tstruct usbduxfast_private *devpriv = dev->private;\n\tint ret;\n\n\tusb_fill_bulk_urb(devpriv->urb, usb, usb_rcvbulkpipe(usb, BULKINEP),\n\t\t\t  devpriv->inbuf, SIZEINBUF,\n\t\t\t  usbduxfast_ai_interrupt, dev);\n\n\tret = usb_submit_urb(devpriv->urb, GFP_ATOMIC);\n\tif (ret) {\n\t\tdev_err(dev->class_dev, \"usb_submit_urb error %d\\n\", ret);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int usbduxfast_ai_check_chanlist(struct comedi_device *dev,\n\t\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\t\tstruct comedi_cmd *cmd)\n{\n\tunsigned int gain0 = CR_RANGE(cmd->chanlist[0]);\n\tint i;\n\n\tif (cmd->chanlist_len > 3 && cmd->chanlist_len != 16) {\n\t\tdev_err(dev->class_dev, \"unsupported combination of channels\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < cmd->chanlist_len; ++i) {\n\t\tunsigned int chan = CR_CHAN(cmd->chanlist[i]);\n\t\tunsigned int gain = CR_RANGE(cmd->chanlist[i]);\n\n\t\tif (chan != i) {\n\t\t\tdev_err(dev->class_dev,\n\t\t\t\t\"channels are not consecutive\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (gain != gain0 && cmd->chanlist_len > 3) {\n\t\t\tdev_err(dev->class_dev,\n\t\t\t\t\"gain must be the same for all channels\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int usbduxfast_ai_cmdtest(struct comedi_device *dev,\n\t\t\t\t struct comedi_subdevice *s,\n\t\t\t\t struct comedi_cmd *cmd)\n{\n\tint err = 0;\n\tint err2 = 0;\n\tunsigned int steps;\n\tunsigned int arg;\n\n\t \n\n\terr |= comedi_check_trigger_src(&cmd->start_src,\n\t\t\t\t\tTRIG_NOW | TRIG_EXT | TRIG_INT);\n\terr |= comedi_check_trigger_src(&cmd->scan_begin_src, TRIG_FOLLOW);\n\terr |= comedi_check_trigger_src(&cmd->convert_src, TRIG_TIMER);\n\terr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\n\terr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\n\n\tif (err)\n\t\treturn 1;\n\n\t \n\n\terr |= comedi_check_trigger_is_unique(cmd->start_src);\n\terr |= comedi_check_trigger_is_unique(cmd->stop_src);\n\n\t \n\n\tif (err)\n\t\treturn 2;\n\n\t \n\n\terr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\n\n\tif (!cmd->chanlist_len)\n\t\terr |= -EINVAL;\n\n\t \n\tif (cmd->start_src == TRIG_EXT &&\n\t    cmd->chanlist_len != 1 && cmd->chanlist_len != 16)\n\t\terr |= -EINVAL;\n\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\n\t\t\t\t\t   cmd->chanlist_len);\n\n\t \n\tsteps = (cmd->convert_arg * 30) / 1000;\n\tif (cmd->chanlist_len !=  1)\n\t\terr2 |= comedi_check_trigger_arg_min(&steps,\n\t\t\t\t\t\t     MIN_SAMPLING_PERIOD);\n\telse\n\t\terr2 |= comedi_check_trigger_arg_min(&steps, 1);\n\terr2 |= comedi_check_trigger_arg_max(&steps, MAX_SAMPLING_PERIOD);\n\tif (err2) {\n\t\terr |= err2;\n\t\targ = (steps * 1000) / 30;\n\t\terr |= comedi_check_trigger_arg_is(&cmd->convert_arg, arg);\n\t}\n\n\tif (cmd->stop_src == TRIG_COUNT)\n\t\terr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\n\telse\t \n\t\terr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\n\n\tif (err)\n\t\treturn 3;\n\n\t \n\n\t \n\tif (cmd->chanlist && cmd->chanlist_len > 0)\n\t\terr |= usbduxfast_ai_check_chanlist(dev, s, cmd);\n\tif (err)\n\t\treturn 5;\n\n\treturn 0;\n}\n\nstatic int usbduxfast_ai_inttrig(struct comedi_device *dev,\n\t\t\t\t struct comedi_subdevice *s,\n\t\t\t\t unsigned int trig_num)\n{\n\tstruct usbduxfast_private *devpriv = dev->private;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tint ret;\n\n\tif (trig_num != cmd->start_arg)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&devpriv->mut);\n\n\tif (!devpriv->ai_cmd_running) {\n\t\tdevpriv->ai_cmd_running = 1;\n\t\tret = usbduxfast_submit_urb(dev);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev->class_dev, \"urbSubmit: err=%d\\n\", ret);\n\t\t\tdevpriv->ai_cmd_running = 0;\n\t\t\tmutex_unlock(&devpriv->mut);\n\t\t\treturn ret;\n\t\t}\n\t\ts->async->inttrig = NULL;\n\t} else {\n\t\tdev_err(dev->class_dev, \"ai is already running\\n\");\n\t}\n\tmutex_unlock(&devpriv->mut);\n\treturn 1;\n}\n\nstatic int usbduxfast_ai_cmd(struct comedi_device *dev,\n\t\t\t     struct comedi_subdevice *s)\n{\n\tstruct usbduxfast_private *devpriv = dev->private;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tunsigned int rngmask = 0xff;\n\tint j, ret;\n\tlong steps, steps_tmp;\n\n\tmutex_lock(&devpriv->mut);\n\tif (devpriv->ai_cmd_running) {\n\t\tret = -EBUSY;\n\t\tgoto cmd_exit;\n\t}\n\n\t \n\tdevpriv->ignore = PACKETS_TO_IGNORE;\n\n\tsteps = (cmd->convert_arg * 30) / 1000;\n\n\tswitch (cmd->chanlist_len) {\n\tcase 1:\n\t\t \n\n\t\tif (CR_RANGE(cmd->chanlist[0]) > 0)\n\t\t\trngmask = 0xff - 0x04;\n\t\telse\n\t\t\trngmask = 0xff;\n\n\t\t \n\n\t\t \n\t\tif (cmd->start_src == TRIG_EXT) {\n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\tusbduxfast_cmd_data(dev, 0, 0x01, 0x01, rngmask, 0x00);\n\t\t} else {\t \n\t\t\tusbduxfast_cmd_data(dev, 0, 0x01, 0x00, rngmask, 0x00);\n\t\t}\n\n\t\tif (steps < MIN_SAMPLING_PERIOD) {\n\t\t\t \n\t\t\tif (steps <= 1) {\n\t\t\t\t \n\n\t\t\t\t \n\t\t\t\t \n\t\t\t\t \n\t\t\t\tusbduxfast_cmd_data(dev, 1,\n\t\t\t\t\t\t    0x89, 0x03, rngmask, 0xff);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\t \n\t\t\t\t \n\t\t\t\tusbduxfast_cmd_data(dev, 1, steps - 1,\n\t\t\t\t\t\t    0x02, rngmask, 0x00);\n\n\t\t\t\t \n\t\t\t\t \n\t\t\t\t \n\t\t\t\tusbduxfast_cmd_data(dev, 2,\n\t\t\t\t\t\t    0x09, 0x01, rngmask, 0xff);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\n\t\t\t \n\t\t\tsteps = steps - 1;\n\n\t\t\t \n\t\t\tusbduxfast_cmd_data(dev, 1,\n\t\t\t\t\t    steps / 2, 0x00, rngmask, 0x00);\n\n\t\t\t \n\t\t\tusbduxfast_cmd_data(dev, 2, steps - steps / 2,\n\t\t\t\t\t    0x00, rngmask, 0x00);\n\n\t\t\t \n\n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\tusbduxfast_cmd_data(dev, 3,\n\t\t\t\t\t    0x09, 0x03, rngmask, 0xff);\n\t\t}\n\t\tbreak;\n\n\tcase 2:\n\t\t \n\n\t\tif (CR_RANGE(cmd->chanlist[0]) > 0)\n\t\t\trngmask = 0xff - 0x04;\n\t\telse\n\t\t\trngmask = 0xff;\n\n\t\t \n\t\tusbduxfast_cmd_data(dev, 0, 0x01, 0x02, rngmask, 0x00);\n\n\t\t \n\t\tsteps_tmp = steps - 1;\n\n\t\tif (CR_RANGE(cmd->chanlist[1]) > 0)\n\t\t\trngmask = 0xff - 0x04;\n\t\telse\n\t\t\trngmask = 0xff;\n\n\t\t \n\t\t \n\t\tusbduxfast_cmd_data(dev, 1, steps_tmp / 2,\n\t\t\t\t    0x00, 0xfe & rngmask, 0x00);\n\n\t\t \n\t\tusbduxfast_cmd_data(dev, 2, steps_tmp  - steps_tmp / 2,\n\t\t\t\t    0x00, rngmask, 0x00);\n\n\t\t \n\t\tusbduxfast_cmd_data(dev, 3, 0x01, 0x02, rngmask, 0x00);\n\n\t\t \n\t\tsteps_tmp = steps - 2;\n\n\t\tif (CR_RANGE(cmd->chanlist[0]) > 0)\n\t\t\trngmask = 0xff - 0x04;\n\t\telse\n\t\t\trngmask = 0xff;\n\n\t\t \n\t\t \n\t\tusbduxfast_cmd_data(dev, 4, steps_tmp / 2,\n\t\t\t\t    0x00, (0xff - 0x02) & rngmask, 0x00);\n\n\t\t \n\t\tusbduxfast_cmd_data(dev, 5, steps_tmp - steps_tmp / 2,\n\t\t\t\t    0x00, rngmask, 0x00);\n\n\t\tusbduxfast_cmd_data(dev, 6, 0x01, 0x00, rngmask, 0x00);\n\t\tbreak;\n\n\tcase 3:\n\t\t \n\t\tfor (j = 0; j < 1; j++) {\n\t\t\tint index = j * 2;\n\n\t\t\tif (CR_RANGE(cmd->chanlist[j]) > 0)\n\t\t\t\trngmask = 0xff - 0x04;\n\t\t\telse\n\t\t\t\trngmask = 0xff;\n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\tusbduxfast_cmd_data(dev, index, steps / 2,\n\t\t\t\t\t    0x02, rngmask, 0x00);\n\n\t\t\tif (CR_RANGE(cmd->chanlist[j + 1]) > 0)\n\t\t\t\trngmask = 0xff - 0x04;\n\t\t\telse\n\t\t\t\trngmask = 0xff;\n\n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\tusbduxfast_cmd_data(dev, index + 1, steps - steps / 2,\n\t\t\t\t\t    0x00, 0xfe & rngmask, 0x00);\n\t\t}\n\n\t\t \n\t\tsteps_tmp = steps - 2;\n\n\t\t \n\t\t \n\t\tusbduxfast_cmd_data(dev, 4, steps_tmp / 2,\n\t\t\t\t    0x02, rngmask, 0x00);\n\n\t\tif (CR_RANGE(cmd->chanlist[0]) > 0)\n\t\t\trngmask = 0xff - 0x04;\n\t\telse\n\t\t\trngmask = 0xff;\n\n\t\t \n\t\t \n\t\t \n\t\tusbduxfast_cmd_data(dev, 5, steps_tmp - steps_tmp / 2,\n\t\t\t\t    0x00, (0xff - 0x02) & rngmask, 0x00);\n\n\t\tusbduxfast_cmd_data(dev, 6, 0x01, 0x00, rngmask, 0x00);\n\t\tbreak;\n\n\tcase 16:\n\t\tif (CR_RANGE(cmd->chanlist[0]) > 0)\n\t\t\trngmask = 0xff - 0x04;\n\t\telse\n\t\t\trngmask = 0xff;\n\n\t\tif (cmd->start_src == TRIG_EXT) {\n\t\t\t \n\n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\tusbduxfast_cmd_data(dev, 0, 0x01, 0x01,\n\t\t\t\t\t    (0xff - 0x02) & rngmask, 0x00);\n\t\t} else {\n\t\t\t \n\n\t\t\t \n\t\t\t \n\t\t\tusbduxfast_cmd_data(dev, 0, 0xff, 0x00,\n\t\t\t\t\t    (0xff - 0x02) & rngmask, 0x00);\n\t\t}\n\n\t\t \n\t\t \n\t\tusbduxfast_cmd_data(dev, 1, 0x01, 0x02, rngmask, 0x00);\n\n\t\t \n\t\tsteps = steps - 2;\n\n\t\t \n\t\tusbduxfast_cmd_data(dev, 2, steps / 2,\n\t\t\t\t    0x00, 0xfe & rngmask, 0x00);\n\n\t\t \n\t\tusbduxfast_cmd_data(dev, 3, steps - steps / 2,\n\t\t\t\t    0x00, rngmask, 0x00);\n\n\t\t \n\t\t \n\t\t \n\t\tusbduxfast_cmd_data(dev, 4, 0x09, 0x01, rngmask, 0xff);\n\n\t\tbreak;\n\t}\n\n\t \n\tret = usbduxfast_send_cmd(dev, SENDADCOMMANDS);\n\tif (ret < 0)\n\t\tgoto cmd_exit;\n\n\tif ((cmd->start_src == TRIG_NOW) || (cmd->start_src == TRIG_EXT)) {\n\t\t \n\t\tdevpriv->ai_cmd_running = 1;\n\t\tret = usbduxfast_submit_urb(dev);\n\t\tif (ret < 0) {\n\t\t\tdevpriv->ai_cmd_running = 0;\n\t\t\t \n\t\t\tgoto cmd_exit;\n\t\t}\n\t\ts->async->inttrig = NULL;\n\t} else {\t \n\t\ts->async->inttrig = usbduxfast_ai_inttrig;\n\t}\n\ncmd_exit:\n\tmutex_unlock(&devpriv->mut);\n\n\treturn ret;\n}\n\n \nstatic int usbduxfast_ai_insn_read(struct comedi_device *dev,\n\t\t\t\t   struct comedi_subdevice *s,\n\t\t\t\t   struct comedi_insn *insn,\n\t\t\t\t   unsigned int *data)\n{\n\tstruct usb_device *usb = comedi_to_usb_dev(dev);\n\tstruct usbduxfast_private *devpriv = dev->private;\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int range = CR_RANGE(insn->chanspec);\n\tu8 rngmask = range ? (0xff - 0x04) : 0xff;\n\tint i, j, n, actual_length;\n\tint ret;\n\n\tmutex_lock(&devpriv->mut);\n\n\tif (devpriv->ai_cmd_running) {\n\t\tdev_err(dev->class_dev,\n\t\t\t\"ai_insn_read not possible, async cmd is running\\n\");\n\t\tmutex_unlock(&devpriv->mut);\n\t\treturn -EBUSY;\n\t}\n\n\t \n\n\t \n\t \n\tusbduxfast_cmd_data(dev, 0, 0x01, 0x02, rngmask, 0x00);\n\n\t \n\tusbduxfast_cmd_data(dev, 1, 0x0c, 0x00, 0xfe & rngmask, 0x00);\n\tusbduxfast_cmd_data(dev, 2, 0x01, 0x00, 0xfe & rngmask, 0x00);\n\tusbduxfast_cmd_data(dev, 3, 0x01, 0x00, 0xfe & rngmask, 0x00);\n\tusbduxfast_cmd_data(dev, 4, 0x01, 0x00, 0xfe & rngmask, 0x00);\n\n\t \n\tusbduxfast_cmd_data(dev, 5, 0x0c, 0x00, rngmask, 0x00);\n\tusbduxfast_cmd_data(dev, 6, 0x01, 0x00, rngmask, 0x00);\n\n\tret = usbduxfast_send_cmd(dev, SENDADCOMMANDS);\n\tif (ret < 0) {\n\t\tmutex_unlock(&devpriv->mut);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < PACKETS_TO_IGNORE; i++) {\n\t\tret = usb_bulk_msg(usb, usb_rcvbulkpipe(usb, BULKINEP),\n\t\t\t\t   devpriv->inbuf, SIZEINBUF,\n\t\t\t\t   &actual_length, 10000);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev->class_dev, \"insn timeout, no data\\n\");\n\t\t\tmutex_unlock(&devpriv->mut);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tfor (i = 0; i < insn->n;) {\n\t\tret = usb_bulk_msg(usb, usb_rcvbulkpipe(usb, BULKINEP),\n\t\t\t\t   devpriv->inbuf, SIZEINBUF,\n\t\t\t\t   &actual_length, 10000);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev->class_dev, \"insn data error: %d\\n\", ret);\n\t\t\tmutex_unlock(&devpriv->mut);\n\t\t\treturn ret;\n\t\t}\n\t\tn = actual_length / sizeof(u16);\n\t\tif ((n % 16) != 0) {\n\t\t\tdev_err(dev->class_dev, \"insn data packet corrupted\\n\");\n\t\t\tmutex_unlock(&devpriv->mut);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tfor (j = chan; (j < n) && (i < insn->n); j = j + 16) {\n\t\t\tdata[i] = ((u16 *)(devpriv->inbuf))[j];\n\t\t\ti++;\n\t\t}\n\t}\n\n\tmutex_unlock(&devpriv->mut);\n\n\treturn insn->n;\n}\n\nstatic int usbduxfast_upload_firmware(struct comedi_device *dev,\n\t\t\t\t      const u8 *data, size_t size,\n\t\t\t\t      unsigned long context)\n{\n\tstruct usb_device *usb = comedi_to_usb_dev(dev);\n\tu8 *buf;\n\tunsigned char *tmp;\n\tint ret;\n\n\tif (!data)\n\t\treturn 0;\n\n\tif (size > FIRMWARE_MAX_LEN) {\n\t\tdev_err(dev->class_dev, \"firmware binary too large for FX2\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tbuf = kmemdup(data, size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t \n\ttmp = kmalloc(1, GFP_KERNEL);\n\tif (!tmp) {\n\t\tkfree(buf);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\t*tmp = 1;\t \n\tret = usb_control_msg(usb, usb_sndctrlpipe(usb, 0),\n\t\t\t      USBDUXFASTSUB_FIRMWARE,\n\t\t\t      VENDOR_DIR_OUT,\n\t\t\t      USBDUXFASTSUB_CPUCS, 0x0000,\n\t\t\t      tmp, 1,\n\t\t\t      EZTIMEOUT);\n\tif (ret < 0) {\n\t\tdev_err(dev->class_dev, \"can not stop firmware\\n\");\n\t\tgoto done;\n\t}\n\n\t \n\tret = usb_control_msg(usb, usb_sndctrlpipe(usb, 0),\n\t\t\t      USBDUXFASTSUB_FIRMWARE,\n\t\t\t      VENDOR_DIR_OUT,\n\t\t\t      0, 0x0000,\n\t\t\t      buf, size,\n\t\t\t      EZTIMEOUT);\n\tif (ret < 0) {\n\t\tdev_err(dev->class_dev, \"firmware upload failed\\n\");\n\t\tgoto done;\n\t}\n\n\t \n\t*tmp = 0;\t \n\tret = usb_control_msg(usb, usb_sndctrlpipe(usb, 0),\n\t\t\t      USBDUXFASTSUB_FIRMWARE,\n\t\t\t      VENDOR_DIR_OUT,\n\t\t\t      USBDUXFASTSUB_CPUCS, 0x0000,\n\t\t\t      tmp, 1,\n\t\t\t      EZTIMEOUT);\n\tif (ret < 0)\n\t\tdev_err(dev->class_dev, \"can not start firmware\\n\");\n\ndone:\n\tkfree(tmp);\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic int usbduxfast_auto_attach(struct comedi_device *dev,\n\t\t\t\t  unsigned long context_unused)\n{\n\tstruct usb_interface *intf = comedi_to_usb_interface(dev);\n\tstruct usb_device *usb = comedi_to_usb_dev(dev);\n\tstruct usbduxfast_private *devpriv;\n\tstruct comedi_subdevice *s;\n\tint ret;\n\n\tif (usb->speed != USB_SPEED_HIGH) {\n\t\tdev_err(dev->class_dev,\n\t\t\t\"This driver needs USB 2.0 to operate. Aborting...\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\n\tif (!devpriv)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&devpriv->mut);\n\tusb_set_intfdata(intf, devpriv);\n\n\tdevpriv->duxbuf = kmalloc(SIZEOFDUXBUF, GFP_KERNEL);\n\tif (!devpriv->duxbuf)\n\t\treturn -ENOMEM;\n\n\tret = usb_set_interface(usb,\n\t\t\t\tintf->altsetting->desc.bInterfaceNumber, 1);\n\tif (ret < 0) {\n\t\tdev_err(dev->class_dev,\n\t\t\t\"could not switch to alternate setting 1\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdevpriv->urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!devpriv->urb)\n\t\treturn -ENOMEM;\n\n\tdevpriv->inbuf = kmalloc(SIZEINBUF, GFP_KERNEL);\n\tif (!devpriv->inbuf)\n\t\treturn -ENOMEM;\n\n\tret = comedi_load_firmware(dev, &usb->dev, FIRMWARE,\n\t\t\t\t   usbduxfast_upload_firmware, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = comedi_alloc_subdevices(dev, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ts = &dev->subdevices[0];\n\tdev->read_subdev = s;\n\ts->type\t\t= COMEDI_SUBD_AI;\n\ts->subdev_flags\t= SDF_READABLE | SDF_GROUND | SDF_CMD_READ;\n\ts->n_chan\t= 16;\n\ts->maxdata\t= 0x1000;\t \n\ts->range_table\t= &range_usbduxfast_ai_range;\n\ts->insn_read\t= usbduxfast_ai_insn_read;\n\ts->len_chanlist\t= s->n_chan;\n\ts->do_cmdtest\t= usbduxfast_ai_cmdtest;\n\ts->do_cmd\t= usbduxfast_ai_cmd;\n\ts->cancel\t= usbduxfast_ai_cancel;\n\n\treturn 0;\n}\n\nstatic void usbduxfast_detach(struct comedi_device *dev)\n{\n\tstruct usb_interface *intf = comedi_to_usb_interface(dev);\n\tstruct usbduxfast_private *devpriv = dev->private;\n\n\tif (!devpriv)\n\t\treturn;\n\n\tmutex_lock(&devpriv->mut);\n\n\tusb_set_intfdata(intf, NULL);\n\n\tif (devpriv->urb) {\n\t\t \n\t\tusb_kill_urb(devpriv->urb);\n\n\t\tkfree(devpriv->inbuf);\n\t\tusb_free_urb(devpriv->urb);\n\t}\n\n\tkfree(devpriv->duxbuf);\n\n\tmutex_unlock(&devpriv->mut);\n\n\tmutex_destroy(&devpriv->mut);\n}\n\nstatic struct comedi_driver usbduxfast_driver = {\n\t.driver_name\t= \"usbduxfast\",\n\t.module\t\t= THIS_MODULE,\n\t.auto_attach\t= usbduxfast_auto_attach,\n\t.detach\t\t= usbduxfast_detach,\n};\n\nstatic int usbduxfast_usb_probe(struct usb_interface *intf,\n\t\t\t\tconst struct usb_device_id *id)\n{\n\treturn comedi_usb_auto_config(intf, &usbduxfast_driver, 0);\n}\n\nstatic const struct usb_device_id usbduxfast_usb_table[] = {\n\t \n\t{ USB_DEVICE(0x13d8, 0x0010) },\t \n\t{ USB_DEVICE(0x13d8, 0x0011) },\t \n\t{ }\n};\nMODULE_DEVICE_TABLE(usb, usbduxfast_usb_table);\n\nstatic struct usb_driver usbduxfast_usb_driver = {\n\t.name\t\t= \"usbduxfast\",\n\t.probe\t\t= usbduxfast_usb_probe,\n\t.disconnect\t= comedi_usb_auto_unconfig,\n\t.id_table\t= usbduxfast_usb_table,\n};\nmodule_comedi_usb_driver(usbduxfast_driver, usbduxfast_usb_driver);\n\nMODULE_AUTHOR(\"Bernd Porr, BerndPorr@f2s.com\");\nMODULE_DESCRIPTION(\"USB-DUXfast, BerndPorr@f2s.com\");\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(FIRMWARE);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}