{
  "module_name": "s626.c",
  "hash_id": "78bee45b815b7ef61a2889fce33cff6680127b5fbd6de80f4bc9d5e67e0dfef9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/s626.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/comedi/comedi_pci.h>\n\n#include \"s626.h\"\n\nstruct s626_buffer_dma {\n\tdma_addr_t physical_base;\n\tvoid *logical_base;\n};\n\n \nstruct s626_private {\n\tu8 ai_cmd_running;\n\tunsigned int ai_sample_timer;\n\tint ai_convert_count;\n\tunsigned int ai_convert_timer;\n\tu16 counter_int_enabs;\n\tu8 adc_items;\n\tstruct s626_buffer_dma rps_buf;\n\tstruct s626_buffer_dma ana_buf;\n\tu32 *dac_wbuf;\n\tu16 dacpol;\n\tu8 trim_setpoint[12];\n\tu32 i2c_adrs;\n};\n\n \n#define S626_INDXMASK(C) (1 << (((C) > 2) ? ((C) * 2 - 1) : ((C) * 2 +  4)))\n#define S626_OVERMASK(C) (1 << (((C) > 2) ? ((C) * 2 + 5) : ((C) * 2 + 10)))\n\n \nstatic void s626_mc_enable(struct comedi_device *dev,\n\t\t\t   unsigned int cmd, unsigned int reg)\n{\n\tunsigned int val = (cmd << 16) | cmd;\n\n\twritel(val, dev->mmio + reg);\n}\n\nstatic void s626_mc_disable(struct comedi_device *dev,\n\t\t\t    unsigned int cmd, unsigned int reg)\n{\n\twritel(cmd << 16, dev->mmio + reg);\n}\n\nstatic bool s626_mc_test(struct comedi_device *dev,\n\t\t\t unsigned int cmd, unsigned int reg)\n{\n\tunsigned int val;\n\n\tval = readl(dev->mmio + reg);\n\n\treturn (val & cmd) ? true : false;\n}\n\n#define S626_BUGFIX_STREG(REGADRS)   ((REGADRS) - 4)\n\n \n#define S626_VECTPORT(VECTNUM)\t\t(S626_P_TSL2 + ((VECTNUM) << 2))\n\nstatic const struct comedi_lrange s626_range_table = {\n\t2, {\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(10)\n\t}\n};\n\n \nstatic void s626_debi_transfer(struct comedi_device *dev)\n{\n\tstatic const int timeout = 10000;\n\tint i;\n\n\t \n\ts626_mc_enable(dev, S626_MC2_UPLD_DEBI, S626_P_MC2);\n\n\t \n\tfor (i = 0; i < timeout; i++) {\n\t\tif (s626_mc_test(dev, S626_MC2_UPLD_DEBI, S626_P_MC2))\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\tif (i == timeout)\n\t\tdev_err(dev->class_dev,\n\t\t\t\"Timeout while uploading to DEBI control register\\n\");\n\n\t \n\tfor (i = 0; i < timeout; i++) {\n\t\tif (!(readl(dev->mmio + S626_P_PSR) & S626_PSR_DEBI_S))\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\tif (i == timeout)\n\t\tdev_err(dev->class_dev, \"DEBI transfer timeout\\n\");\n}\n\n \nstatic u16 s626_debi_read(struct comedi_device *dev, u16 addr)\n{\n\t \n\twritel(S626_DEBI_CMD_RDWORD | addr, dev->mmio + S626_P_DEBICMD);\n\n\t \n\ts626_debi_transfer(dev);\n\n\treturn readl(dev->mmio + S626_P_DEBIAD);\n}\n\n \nstatic void s626_debi_write(struct comedi_device *dev, u16 addr,\n\t\t\t    u16 wdata)\n{\n\t \n\twritel(S626_DEBI_CMD_WRWORD | addr, dev->mmio + S626_P_DEBICMD);\n\twritel(wdata, dev->mmio + S626_P_DEBIAD);\n\n\t \n\ts626_debi_transfer(dev);\n}\n\n \nstatic void s626_debi_replace(struct comedi_device *dev, unsigned int addr,\n\t\t\t      unsigned int mask, unsigned int wdata)\n{\n\tunsigned int val;\n\n\taddr &= 0xffff;\n\twritel(S626_DEBI_CMD_RDWORD | addr, dev->mmio + S626_P_DEBICMD);\n\ts626_debi_transfer(dev);\n\n\twritel(S626_DEBI_CMD_WRWORD | addr, dev->mmio + S626_P_DEBICMD);\n\tval = readl(dev->mmio + S626_P_DEBIAD);\n\tval &= mask;\n\tval |= wdata;\n\twritel(val & 0xffff, dev->mmio + S626_P_DEBIAD);\n\ts626_debi_transfer(dev);\n}\n\n \n\nstatic int s626_i2c_handshake_eoc(struct comedi_device *dev,\n\t\t\t\t  struct comedi_subdevice *s,\n\t\t\t\t  struct comedi_insn *insn,\n\t\t\t\t  unsigned long context)\n{\n\tbool status;\n\n\tstatus = s626_mc_test(dev, S626_MC2_UPLD_IIC, S626_P_MC2);\n\tif (status)\n\t\treturn 0;\n\treturn -EBUSY;\n}\n\nstatic int s626_i2c_handshake(struct comedi_device *dev, u32 val)\n{\n\tunsigned int ctrl;\n\tint ret;\n\n\t \n\twritel(val, dev->mmio + S626_P_I2CCTRL);\n\n\t \n\ts626_mc_enable(dev, S626_MC2_UPLD_IIC, S626_P_MC2);\n\tret = comedi_timeout(dev, NULL, NULL, s626_i2c_handshake_eoc, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tdo {\n\t\tctrl = readl(dev->mmio + S626_P_I2CCTRL);\n\t} while ((ctrl & (S626_I2C_BUSY | S626_I2C_ERR)) == S626_I2C_BUSY);\n\n\t \n\treturn ctrl & S626_I2C_ERR;\n}\n\n \nstatic u8 s626_i2c_read(struct comedi_device *dev, u8 addr)\n{\n\tstruct s626_private *devpriv = dev->private;\n\n\t \n\tif (s626_i2c_handshake(dev, S626_I2C_B2(S626_I2C_ATTRSTART,\n\t\t\t\t\t\tdevpriv->i2c_adrs) |\n\t\t\t\t    S626_I2C_B1(S626_I2C_ATTRSTOP, addr) |\n\t\t\t\t    S626_I2C_B0(S626_I2C_ATTRNOP, 0)))\n\t\t \n\t\treturn 0;\n\n\t \n\tif (s626_i2c_handshake(dev, S626_I2C_B2(S626_I2C_ATTRSTART,\n\t\t\t\t\t\t(devpriv->i2c_adrs | 1)) |\n\t\t\t\t    S626_I2C_B1(S626_I2C_ATTRSTOP, 0) |\n\t\t\t\t    S626_I2C_B0(S626_I2C_ATTRNOP, 0)))\n\t\t \n\t\treturn 0;\n\n\treturn (readl(dev->mmio + S626_P_I2CCTRL) >> 16) & 0xff;\n}\n\n \n\n \nstatic const u8 s626_trimchan[] = { 10, 9, 8, 3, 2, 7, 6, 1, 0, 5, 4 };\n\n \nstatic const u8 s626_trimadrs[] = {\n\t0x40, 0x41, 0x42, 0x50, 0x51, 0x52, 0x53, 0x60, 0x61, 0x62, 0x63\n};\n\nenum {\n\ts626_send_dac_wait_not_mc1_a2out,\n\ts626_send_dac_wait_ssr_af2_out,\n\ts626_send_dac_wait_fb_buffer2_msb_00,\n\ts626_send_dac_wait_fb_buffer2_msb_ff\n};\n\nstatic int s626_send_dac_eoc(struct comedi_device *dev,\n\t\t\t     struct comedi_subdevice *s,\n\t\t\t     struct comedi_insn *insn,\n\t\t\t     unsigned long context)\n{\n\tunsigned int status;\n\n\tswitch (context) {\n\tcase s626_send_dac_wait_not_mc1_a2out:\n\t\tstatus = readl(dev->mmio + S626_P_MC1);\n\t\tif (!(status & S626_MC1_A2OUT))\n\t\t\treturn 0;\n\t\tbreak;\n\tcase s626_send_dac_wait_ssr_af2_out:\n\t\tstatus = readl(dev->mmio + S626_P_SSR);\n\t\tif (status & S626_SSR_AF2_OUT)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase s626_send_dac_wait_fb_buffer2_msb_00:\n\t\tstatus = readl(dev->mmio + S626_P_FB_BUFFER2);\n\t\tif (!(status & 0xff000000))\n\t\t\treturn 0;\n\t\tbreak;\n\tcase s626_send_dac_wait_fb_buffer2_msb_ff:\n\t\tstatus = readl(dev->mmio + S626_P_FB_BUFFER2);\n\t\tif (status & 0xff000000)\n\t\t\treturn 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn -EBUSY;\n}\n\n \nstatic int s626_send_dac(struct comedi_device *dev, u32 val)\n{\n\tstruct s626_private *devpriv = dev->private;\n\tint ret;\n\n\t \n\n\t \n\ts626_debi_write(dev, S626_LP_DACPOL, devpriv->dacpol);\n\n\t \n\n\t \n\t \n\t*devpriv->dac_wbuf = val;\n\n\t \n\ts626_mc_enable(dev, S626_MC1_A2OUT, S626_P_MC1);\n\n\t \n\n\t \n\twritel(S626_ISR_AFOU, dev->mmio + S626_P_ISR);\n\n\t \n\tret = comedi_timeout(dev, NULL, NULL, s626_send_dac_eoc,\n\t\t\t     s626_send_dac_wait_not_mc1_a2out);\n\tif (ret) {\n\t\tdev_err(dev->class_dev, \"DMA transfer timeout\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\n\t \n\twritel(S626_XSD2 | S626_RSD3 | S626_SIB_A2,\n\t       dev->mmio + S626_VECTPORT(0));\n\n\t \n\tret = comedi_timeout(dev, NULL, NULL, s626_send_dac_eoc,\n\t\t\t     s626_send_dac_wait_ssr_af2_out);\n\tif (ret) {\n\t\tdev_err(dev->class_dev,\n\t\t\t\"TSL timeout waiting for slot 1 to execute\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\twritel(S626_XSD2 | S626_XFIFO_2 | S626_RSD2 | S626_SIB_A2 | S626_EOS,\n\t       dev->mmio + S626_VECTPORT(0));\n\n\t \n\n\t \n\tif (readl(dev->mmio + S626_P_FB_BUFFER2) & 0xff000000) {\n\t\t \n\t\tret = comedi_timeout(dev, NULL, NULL, s626_send_dac_eoc,\n\t\t\t\t     s626_send_dac_wait_fb_buffer2_msb_00);\n\t\tif (ret) {\n\t\t\tdev_err(dev->class_dev,\n\t\t\t\t\"TSL timeout waiting for slot 0 to execute\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\t \n\twritel(S626_RSD3 | S626_SIB_A2 | S626_EOS,\n\t       dev->mmio + S626_VECTPORT(0));\n\n\t \n\tret = comedi_timeout(dev, NULL, NULL, s626_send_dac_eoc,\n\t\t\t     s626_send_dac_wait_fb_buffer2_msb_ff);\n\tif (ret) {\n\t\tdev_err(dev->class_dev,\n\t\t\t\"TSL timeout waiting for slot 0 to execute\\n\");\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\n \nstatic int s626_set_dac(struct comedi_device *dev,\n\t\t\tu16 chan, int16_t dacdata)\n{\n\tstruct s626_private *devpriv = dev->private;\n\tu16 signmask;\n\tu32 ws_image;\n\tu32 val;\n\n\t \n\tsignmask = 1 << chan;\n\tif (dacdata < 0) {\n\t\tdacdata = -dacdata;\n\t\tdevpriv->dacpol |= signmask;\n\t} else {\n\t\tdevpriv->dacpol &= ~signmask;\n\t}\n\n\t \n\tif ((u16)dacdata > 0x1FFF)\n\t\tdacdata = 0x1FFF;\n\n\t \n\n\t \n\tws_image = (chan & 2) ? S626_WS1 : S626_WS2;\n\t \n\twritel(S626_XSD2 | S626_XFIFO_1 | ws_image,\n\t       dev->mmio + S626_VECTPORT(2));\n\t \n\twritel(S626_XSD2 | S626_XFIFO_0 | ws_image,\n\t       dev->mmio + S626_VECTPORT(3));\n\t \n\twritel(S626_XSD2 | S626_XFIFO_3 | S626_WS3,\n\t       dev->mmio + S626_VECTPORT(4));\n\t \n\twritel(S626_XSD2 | S626_XFIFO_2 | S626_WS3 | S626_EOS,\n\t       dev->mmio + S626_VECTPORT(5));\n\n\t \n\tval = 0x0F000000;\t \n\tval |= 0x00004000;\t \n\tval |= ((u32)(chan & 1) << 15);\t \n\tval |= (u32)dacdata;\t \n\treturn s626_send_dac(dev, val);\n}\n\nstatic int s626_write_trim_dac(struct comedi_device *dev,\n\t\t\t       u8 logical_chan, u8 dac_data)\n{\n\tstruct s626_private *devpriv = dev->private;\n\tu32 chan;\n\n\t \n\tdevpriv->trim_setpoint[logical_chan] = dac_data;\n\n\t \n\tchan = s626_trimchan[logical_chan];\n\n\t \n\n\t \n\twritel(S626_XSD2 | S626_XFIFO_1 | S626_WS3,\n\t       dev->mmio + S626_VECTPORT(2));\n\t \n\twritel(S626_XSD2 | S626_XFIFO_0 | S626_WS3,\n\t       dev->mmio + S626_VECTPORT(3));\n\t \n\twritel(S626_XSD2 | S626_XFIFO_3 | S626_WS1,\n\t       dev->mmio + S626_VECTPORT(4));\n\t \n\twritel(S626_XSD2 | S626_XFIFO_2 | S626_WS1 | S626_EOS,\n\t       dev->mmio + S626_VECTPORT(5));\n\n\t \n\n\t \n\treturn s626_send_dac(dev, (chan << 8) | dac_data);\n}\n\nstatic int s626_load_trim_dacs(struct comedi_device *dev)\n{\n\tu8 i;\n\tint ret;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(s626_trimchan); i++) {\n\t\tret = s626_write_trim_dac(dev, i,\n\t\t\t\t\t  s626_i2c_read(dev, s626_trimadrs[i]));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\n \n\n \n\n \nstatic void s626_set_latch_source(struct comedi_device *dev,\n\t\t\t\t  unsigned int chan, u16 value)\n{\n\ts626_debi_replace(dev, S626_LP_CRB(chan),\n\t\t\t  ~(S626_CRBMSK_INTCTRL | S626_CRBMSK_LATCHSRC),\n\t\t\t  S626_SET_CRB_LATCHSRC(value));\n}\n\n \nstatic void s626_preload(struct comedi_device *dev,\n\t\t\t unsigned int chan, u32 value)\n{\n\ts626_debi_write(dev, S626_LP_CNTR(chan), value);\n\ts626_debi_write(dev, S626_LP_CNTR(chan) + 2, value >> 16);\n}\n\n \n\n \nstatic void s626_reset_cap_flags(struct comedi_device *dev,\n\t\t\t\t unsigned int chan)\n{\n\tu16 set;\n\n\tset = S626_SET_CRB_INTRESETCMD(1);\n\tif (chan < 3)\n\t\tset |= S626_SET_CRB_INTRESET_A(1);\n\telse\n\t\tset |= S626_SET_CRB_INTRESET_B(1);\n\n\ts626_debi_replace(dev, S626_LP_CRB(chan), ~S626_CRBMSK_INTCTRL, set);\n}\n\n \nstatic void s626_set_mode_a(struct comedi_device *dev,\n\t\t\t    unsigned int chan, u16 setup,\n\t\t\t    u16 disable_int_src)\n{\n\tstruct s626_private *devpriv = dev->private;\n\tu16 cra;\n\tu16 crb;\n\tunsigned int cntsrc, clkmult, clkpol;\n\n\t \n\t \n\tcra = S626_SET_CRA_LOADSRC_A(S626_GET_STD_LOADSRC(setup));\n\t \n\tcra |= S626_SET_CRA_INDXSRC_A(S626_GET_STD_INDXSRC(setup));\n\n\t \n\tcrb = S626_SET_CRB_INTRESETCMD(1) | S626_SET_CRB_INTRESET_A(1);\n\t \n\tcrb |= S626_SET_CRB_CLKENAB_A(S626_GET_STD_CLKENAB(setup));\n\n\t \n\tif (!disable_int_src)\n\t\tcra |= S626_SET_CRA_INTSRC_A(S626_GET_STD_INTSRC(setup));\n\n\t \n\tclkpol = S626_GET_STD_CLKPOL(setup);\n\tswitch (S626_GET_STD_ENCMODE(setup)) {\n\tcase S626_ENCMODE_EXTENDER:  \n\t\t \n\t\t \n\tcase S626_ENCMODE_TIMER:\t \n\t\t \n\t\tcntsrc = S626_CNTSRC_SYSCLK;\n\t\t \n\t\tcntsrc |= clkpol;\n\t\t \n\t\tclkpol = 1;\n\t\t \n\t\tclkmult = S626_CLKMULT_1X;\n\t\tbreak;\n\tdefault:\t\t \n\t\t \n\t\tcntsrc = S626_CNTSRC_ENCODER;\n\t\t \n\t\t \n\t\tclkmult = S626_GET_STD_CLKMULT(setup);\n\t\tif (clkmult == S626_CLKMULT_SPECIAL)\n\t\t\tclkmult = S626_CLKMULT_1X;\n\t\tbreak;\n\t}\n\tcra |= S626_SET_CRA_CNTSRC_A(cntsrc) | S626_SET_CRA_CLKPOL_A(clkpol) |\n\t       S626_SET_CRA_CLKMULT_A(clkmult);\n\n\t \n\tif (S626_GET_STD_INDXSRC(setup) != S626_INDXSRC_SOFT)\n\t\tcra |= S626_SET_CRA_INDXPOL_A(S626_GET_STD_INDXPOL(setup));\n\n\t \n\tif (disable_int_src)\n\t\tdevpriv->counter_int_enabs &= ~(S626_OVERMASK(chan) |\n\t\t\t\t\t\tS626_INDXMASK(chan));\n\n\t \n\ts626_debi_replace(dev, S626_LP_CRA(chan),\n\t\t\t  S626_CRAMSK_INDXSRC_B | S626_CRAMSK_CNTSRC_B, cra);\n\ts626_debi_replace(dev, S626_LP_CRB(chan),\n\t\t\t  ~(S626_CRBMSK_INTCTRL | S626_CRBMSK_CLKENAB_A), crb);\n}\n\nstatic void s626_set_mode_b(struct comedi_device *dev,\n\t\t\t    unsigned int chan, u16 setup,\n\t\t\t    u16 disable_int_src)\n{\n\tstruct s626_private *devpriv = dev->private;\n\tu16 cra;\n\tu16 crb;\n\tunsigned int cntsrc, clkmult, clkpol;\n\n\t \n\t \n\tcra = S626_SET_CRA_INDXSRC_B(S626_GET_STD_INDXSRC(setup));\n\n\t \n\tcrb = S626_SET_CRB_INTRESETCMD(1) | S626_SET_CRB_INTRESET_B(1);\n\t \n\tcrb |= S626_SET_CRB_CLKENAB_B(S626_GET_STD_CLKENAB(setup));\n\t \n\tcrb |= S626_SET_CRB_LOADSRC_B(S626_GET_STD_LOADSRC(setup));\n\n\t \n\tif (!disable_int_src)\n\t\tcrb |= S626_SET_CRB_INTSRC_B(S626_GET_STD_INTSRC(setup));\n\n\t \n\tclkpol = S626_GET_STD_CLKPOL(setup);\n\tswitch (S626_GET_STD_ENCMODE(setup)) {\n\tcase S626_ENCMODE_TIMER:\t \n\t\t \n\t\tcntsrc = S626_CNTSRC_SYSCLK;\n\t\t \n\t\tcntsrc |= clkpol;\n\t\t \n\t\tclkpol = 1;\n\t\t \n\t\tclkmult = S626_CLKMULT_1X;\n\t\tbreak;\n\tcase S626_ENCMODE_EXTENDER:\t \n\t\t \n\t\tcntsrc = S626_CNTSRC_SYSCLK;\n\t\t \n\t\tcntsrc |= clkpol;\n\t\t \n\t\tclkpol = 1;\n\t\t \n\t\tclkmult = S626_CLKMULT_SPECIAL;\n\t\tbreak;\n\tdefault:\t\t \n\t\t \n\t\tcntsrc = S626_CNTSRC_ENCODER;\n\t\t \n\t\t \n\t\tclkmult = S626_GET_STD_CLKMULT(setup);\n\t\tif (clkmult == S626_CLKMULT_SPECIAL)\n\t\t\tclkmult = S626_CLKMULT_1X;\n\t\tbreak;\n\t}\n\tcra |= S626_SET_CRA_CNTSRC_B(cntsrc);\n\tcrb |= S626_SET_CRB_CLKPOL_B(clkpol) | S626_SET_CRB_CLKMULT_B(clkmult);\n\n\t \n\tif (S626_GET_STD_INDXSRC(setup) != S626_INDXSRC_SOFT)\n\t\tcrb |= S626_SET_CRB_INDXPOL_B(S626_GET_STD_INDXPOL(setup));\n\n\t \n\tif (disable_int_src)\n\t\tdevpriv->counter_int_enabs &= ~(S626_OVERMASK(chan) |\n\t\t\t\t\t\tS626_INDXMASK(chan));\n\n\t \n\ts626_debi_replace(dev, S626_LP_CRA(chan),\n\t\t\t  ~(S626_CRAMSK_INDXSRC_B | S626_CRAMSK_CNTSRC_B), cra);\n\ts626_debi_replace(dev, S626_LP_CRB(chan),\n\t\t\t  S626_CRBMSK_CLKENAB_A | S626_CRBMSK_LATCHSRC, crb);\n}\n\nstatic void s626_set_mode(struct comedi_device *dev,\n\t\t\t  unsigned int chan,\n\t\t\t  u16 setup, u16 disable_int_src)\n{\n\tif (chan < 3)\n\t\ts626_set_mode_a(dev, chan, setup, disable_int_src);\n\telse\n\t\ts626_set_mode_b(dev, chan, setup, disable_int_src);\n}\n\n \nstatic void s626_set_enable(struct comedi_device *dev,\n\t\t\t    unsigned int chan, u16 enab)\n{\n\tunsigned int mask = S626_CRBMSK_INTCTRL;\n\tunsigned int set;\n\n\tif (chan < 3) {\n\t\tmask |= S626_CRBMSK_CLKENAB_A;\n\t\tset = S626_SET_CRB_CLKENAB_A(enab);\n\t} else {\n\t\tmask |= S626_CRBMSK_CLKENAB_B;\n\t\tset = S626_SET_CRB_CLKENAB_B(enab);\n\t}\n\ts626_debi_replace(dev, S626_LP_CRB(chan), ~mask, set);\n}\n\n \nstatic void s626_set_load_trig(struct comedi_device *dev,\n\t\t\t       unsigned int chan, u16 trig)\n{\n\tu16 reg;\n\tu16 mask;\n\tu16 set;\n\n\tif (chan < 3) {\n\t\treg = S626_LP_CRA(chan);\n\t\tmask = S626_CRAMSK_LOADSRC_A;\n\t\tset = S626_SET_CRA_LOADSRC_A(trig);\n\t} else {\n\t\treg = S626_LP_CRB(chan);\n\t\tmask = S626_CRBMSK_LOADSRC_B | S626_CRBMSK_INTCTRL;\n\t\tset = S626_SET_CRB_LOADSRC_B(trig);\n\t}\n\ts626_debi_replace(dev, reg, ~mask, set);\n}\n\n \nstatic void s626_set_int_src(struct comedi_device *dev,\n\t\t\t     unsigned int chan, u16 int_source)\n{\n\tstruct s626_private *devpriv = dev->private;\n\tu16 cra_reg = S626_LP_CRA(chan);\n\tu16 crb_reg = S626_LP_CRB(chan);\n\n\tif (chan < 3) {\n\t\t \n\t\ts626_debi_replace(dev, crb_reg, ~S626_CRBMSK_INTCTRL,\n\t\t\t\t  S626_SET_CRB_INTRESETCMD(1) |\n\t\t\t\t  S626_SET_CRB_INTRESET_A(1));\n\n\t\t \n\t\ts626_debi_replace(dev, cra_reg, ~S626_CRAMSK_INTSRC_A,\n\t\t\t\t  S626_SET_CRA_INTSRC_A(int_source));\n\t} else {\n\t\tu16 crb;\n\n\t\t \n\t\tcrb = s626_debi_read(dev, crb_reg);\n\t\tcrb &= ~S626_CRBMSK_INTCTRL;\n\n\t\t \n\t\ts626_debi_write(dev, crb_reg,\n\t\t\t\tcrb | S626_SET_CRB_INTRESETCMD(1) |\n\t\t\t\tS626_SET_CRB_INTRESET_B(1));\n\n\t\t \n\t\ts626_debi_write(dev, crb_reg,\n\t\t\t\t(crb & ~S626_CRBMSK_INTSRC_B) |\n\t\t\t\tS626_SET_CRB_INTSRC_B(int_source));\n\t}\n\n\t \n\tdevpriv->counter_int_enabs &= ~(S626_OVERMASK(chan) |\n\t\t\t\t\tS626_INDXMASK(chan));\n\tswitch (int_source) {\n\tcase 0:\n\tdefault:\n\t\tbreak;\n\tcase 1:\n\t\tdevpriv->counter_int_enabs |= S626_OVERMASK(chan);\n\t\tbreak;\n\tcase 2:\n\t\tdevpriv->counter_int_enabs |= S626_INDXMASK(chan);\n\t\tbreak;\n\tcase 3:\n\t\tdevpriv->counter_int_enabs |= (S626_OVERMASK(chan) |\n\t\t\t\t\t       S626_INDXMASK(chan));\n\t\tbreak;\n\t}\n}\n\n \nstatic void s626_pulse_index(struct comedi_device *dev,\n\t\t\t     unsigned int chan)\n{\n\tif (chan < 3) {\n\t\tu16 cra;\n\n\t\tcra = s626_debi_read(dev, S626_LP_CRA(chan));\n\n\t\t \n\t\ts626_debi_write(dev, S626_LP_CRA(chan),\n\t\t\t\t(cra ^ S626_CRAMSK_INDXPOL_A));\n\t\ts626_debi_write(dev, S626_LP_CRA(chan), cra);\n\t} else {\n\t\tu16 crb;\n\n\t\tcrb = s626_debi_read(dev, S626_LP_CRB(chan));\n\t\tcrb &= ~S626_CRBMSK_INTCTRL;\n\n\t\t \n\t\ts626_debi_write(dev, S626_LP_CRB(chan),\n\t\t\t\t(crb ^ S626_CRBMSK_INDXPOL_B));\n\t\ts626_debi_write(dev, S626_LP_CRB(chan), crb);\n\t}\n}\n\nstatic unsigned int s626_ai_reg_to_uint(unsigned int data)\n{\n\treturn ((data >> 18) & 0x3fff) ^ 0x2000;\n}\n\nstatic int s626_dio_set_irq(struct comedi_device *dev, unsigned int chan)\n{\n\tunsigned int group = chan / 16;\n\tunsigned int mask = 1 << (chan - (16 * group));\n\tunsigned int status;\n\n\t \n\tstatus = s626_debi_read(dev, S626_LP_RDEDGSEL(group));\n\ts626_debi_write(dev, S626_LP_WREDGSEL(group), mask | status);\n\n\t \n\tstatus = s626_debi_read(dev, S626_LP_RDINTSEL(group));\n\ts626_debi_write(dev, S626_LP_WRINTSEL(group), mask | status);\n\n\t \n\ts626_debi_write(dev, S626_LP_MISC1, S626_MISC1_EDCAP);\n\n\t \n\tstatus = s626_debi_read(dev, S626_LP_RDCAPSEL(group));\n\ts626_debi_write(dev, S626_LP_WRCAPSEL(group), mask | status);\n\n\treturn 0;\n}\n\nstatic int s626_dio_reset_irq(struct comedi_device *dev, unsigned int group,\n\t\t\t      unsigned int mask)\n{\n\t \n\ts626_debi_write(dev, S626_LP_MISC1, S626_MISC1_NOEDCAP);\n\n\t \n\ts626_debi_write(dev, S626_LP_WRCAPSEL(group), mask);\n\n\treturn 0;\n}\n\nstatic int s626_dio_clear_irq(struct comedi_device *dev)\n{\n\tunsigned int group;\n\n\t \n\ts626_debi_write(dev, S626_LP_MISC1, S626_MISC1_NOEDCAP);\n\n\t \n\tfor (group = 0; group < S626_DIO_BANKS; group++)\n\t\ts626_debi_write(dev, S626_LP_WRCAPSEL(group), 0xffff);\n\n\treturn 0;\n}\n\nstatic void s626_handle_dio_interrupt(struct comedi_device *dev,\n\t\t\t\t      u16 irqbit, u8 group)\n{\n\tstruct s626_private *devpriv = dev->private;\n\tstruct comedi_subdevice *s = dev->read_subdev;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\n\ts626_dio_reset_irq(dev, group, irqbit);\n\n\tif (devpriv->ai_cmd_running) {\n\t\t \n\t\tif ((irqbit >> (cmd->start_arg - (16 * group))) == 1 &&\n\t\t    cmd->start_src == TRIG_EXT) {\n\t\t\t \n\t\t\ts626_mc_enable(dev, S626_MC1_ERPS1, S626_P_MC1);\n\n\t\t\tif (cmd->scan_begin_src == TRIG_EXT)\n\t\t\t\ts626_dio_set_irq(dev, cmd->scan_begin_arg);\n\t\t}\n\t\tif ((irqbit >> (cmd->scan_begin_arg - (16 * group))) == 1 &&\n\t\t    cmd->scan_begin_src == TRIG_EXT) {\n\t\t\t \n\t\t\ts626_mc_enable(dev, S626_MC2_ADC_RPS, S626_P_MC2);\n\n\t\t\tif (cmd->convert_src == TRIG_EXT) {\n\t\t\t\tdevpriv->ai_convert_count = cmd->chanlist_len;\n\n\t\t\t\ts626_dio_set_irq(dev, cmd->convert_arg);\n\t\t\t}\n\n\t\t\tif (cmd->convert_src == TRIG_TIMER) {\n\t\t\t\tdevpriv->ai_convert_count = cmd->chanlist_len;\n\t\t\t\ts626_set_enable(dev, 5, S626_CLKENAB_ALWAYS);\n\t\t\t}\n\t\t}\n\t\tif ((irqbit >> (cmd->convert_arg - (16 * group))) == 1 &&\n\t\t    cmd->convert_src == TRIG_EXT) {\n\t\t\t \n\t\t\ts626_mc_enable(dev, S626_MC2_ADC_RPS, S626_P_MC2);\n\n\t\t\tdevpriv->ai_convert_count--;\n\t\t\tif (devpriv->ai_convert_count > 0)\n\t\t\t\ts626_dio_set_irq(dev, cmd->convert_arg);\n\t\t}\n\t}\n}\n\nstatic void s626_check_dio_interrupts(struct comedi_device *dev)\n{\n\tu16 irqbit;\n\tu8 group;\n\n\tfor (group = 0; group < S626_DIO_BANKS; group++) {\n\t\t \n\t\tirqbit = s626_debi_read(dev, S626_LP_RDCAPFLG(group));\n\n\t\t \n\t\tif (irqbit) {\n\t\t\ts626_handle_dio_interrupt(dev, irqbit, group);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic void s626_check_counter_interrupts(struct comedi_device *dev)\n{\n\tstruct s626_private *devpriv = dev->private;\n\tstruct comedi_subdevice *s = dev->read_subdev;\n\tstruct comedi_async *async = s->async;\n\tstruct comedi_cmd *cmd = &async->cmd;\n\tu16 irqbit;\n\n\t \n\tirqbit = s626_debi_read(dev, S626_LP_RDMISC2);\n\n\t \n\tif (irqbit & S626_IRQ_COINT1A) {\n\t\t \n\t\ts626_reset_cap_flags(dev, 0);\n\t}\n\tif (irqbit & S626_IRQ_COINT2A) {\n\t\t \n\t\ts626_reset_cap_flags(dev, 1);\n\t}\n\tif (irqbit & S626_IRQ_COINT3A) {\n\t\t \n\t\ts626_reset_cap_flags(dev, 2);\n\t}\n\tif (irqbit & S626_IRQ_COINT1B) {\n\t\t \n\t\ts626_reset_cap_flags(dev, 3);\n\t}\n\tif (irqbit & S626_IRQ_COINT2B) {\n\t\t \n\t\ts626_reset_cap_flags(dev, 4);\n\n\t\tif (devpriv->ai_convert_count > 0) {\n\t\t\tdevpriv->ai_convert_count--;\n\t\t\tif (devpriv->ai_convert_count == 0)\n\t\t\t\ts626_set_enable(dev, 4, S626_CLKENAB_INDEX);\n\n\t\t\tif (cmd->convert_src == TRIG_TIMER) {\n\t\t\t\t \n\t\t\t\ts626_mc_enable(dev, S626_MC2_ADC_RPS,\n\t\t\t\t\t       S626_P_MC2);\n\t\t\t}\n\t\t}\n\t}\n\tif (irqbit & S626_IRQ_COINT3B) {\n\t\t \n\t\ts626_reset_cap_flags(dev, 5);\n\n\t\tif (cmd->scan_begin_src == TRIG_TIMER) {\n\t\t\t \n\t\t\ts626_mc_enable(dev, S626_MC2_ADC_RPS, S626_P_MC2);\n\t\t}\n\n\t\tif (cmd->convert_src == TRIG_TIMER) {\n\t\t\tdevpriv->ai_convert_count = cmd->chanlist_len;\n\t\t\ts626_set_enable(dev, 4, S626_CLKENAB_ALWAYS);\n\t\t}\n\t}\n}\n\nstatic bool s626_handle_eos_interrupt(struct comedi_device *dev)\n{\n\tstruct s626_private *devpriv = dev->private;\n\tstruct comedi_subdevice *s = dev->read_subdev;\n\tstruct comedi_async *async = s->async;\n\tstruct comedi_cmd *cmd = &async->cmd;\n\t \n\tu32 *readaddr = (u32 *)devpriv->ana_buf.logical_base + 1;\n\tint i;\n\n\t \n\tfor (i = 0; i < cmd->chanlist_len; i++) {\n\t\tunsigned short tempdata;\n\n\t\t \n\t\ttempdata = s626_ai_reg_to_uint(*readaddr);\n\t\treadaddr++;\n\n\t\tcomedi_buf_write_samples(s, &tempdata, 1);\n\t}\n\n\tif (cmd->stop_src == TRIG_COUNT && async->scans_done >= cmd->stop_arg)\n\t\tasync->events |= COMEDI_CB_EOA;\n\n\tif (async->events & COMEDI_CB_CANCEL_MASK)\n\t\tdevpriv->ai_cmd_running = 0;\n\n\tif (devpriv->ai_cmd_running && cmd->scan_begin_src == TRIG_EXT)\n\t\ts626_dio_set_irq(dev, cmd->scan_begin_arg);\n\n\tcomedi_handle_events(dev, s);\n\n\treturn !devpriv->ai_cmd_running;\n}\n\nstatic irqreturn_t s626_irq_handler(int irq, void *d)\n{\n\tstruct comedi_device *dev = d;\n\tunsigned long flags;\n\tu32 irqtype, irqstatus;\n\n\tif (!dev->attached)\n\t\treturn IRQ_NONE;\n\t \n\tspin_lock_irqsave(&dev->spinlock, flags);\n\n\t \n\tirqstatus = readl(dev->mmio + S626_P_IER);\n\n\t \n\tirqtype = readl(dev->mmio + S626_P_ISR);\n\n\t \n\twritel(0, dev->mmio + S626_P_IER);\n\n\t \n\twritel(irqtype, dev->mmio + S626_P_ISR);\n\n\tswitch (irqtype) {\n\tcase S626_IRQ_RPS1:\t \n\t\tif (s626_handle_eos_interrupt(dev))\n\t\t\tirqstatus = 0;\n\t\tbreak;\n\tcase S626_IRQ_GPIO3:\t \n\t\t \n\t\ts626_check_dio_interrupts(dev);\n\t\ts626_check_counter_interrupts(dev);\n\t\tbreak;\n\t}\n\n\t \n\twritel(irqstatus, dev->mmio + S626_P_IER);\n\n\tspin_unlock_irqrestore(&dev->spinlock, flags);\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void s626_reset_adc(struct comedi_device *dev, u8 *ppl)\n{\n\tstruct s626_private *devpriv = dev->private;\n\tstruct comedi_subdevice *s = dev->read_subdev;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tu32 *rps;\n\tu32 jmp_adrs;\n\tu16 i;\n\tu16 n;\n\tu32 local_ppl;\n\n\t \n\ts626_mc_disable(dev, S626_MC1_ERPS1, S626_P_MC1);\n\n\t \n\trps = (u32 *)devpriv->rps_buf.logical_base;\n\n\t \n\twritel((u32)devpriv->rps_buf.physical_base,\n\t       dev->mmio + S626_P_RPSADDR1);\n\n\t \n\tif (cmd->scan_begin_src != TRIG_FOLLOW) {\n\t\t \n\t\t*rps++ = S626_RPS_PAUSE | S626_RPS_SIGADC;\n\t\t*rps++ = S626_RPS_CLRSIGNAL | S626_RPS_SIGADC;\n\t}\n\n\t \n\t \n\t*rps++ = S626_RPS_LDREG | (S626_P_DEBICMD >> 2);\n\t*rps++ = S626_DEBI_CMD_WRWORD | S626_LP_GSEL;\n\t*rps++ = S626_RPS_LDREG | (S626_P_DEBIAD >> 2);\n\t \n\t*rps++ = S626_GSEL_BIPOLAR5V;\t \n\t*rps++ = S626_RPS_CLRSIGNAL | S626_RPS_DEBI;\n\t \n\t \n\t*rps++ = S626_RPS_UPLOAD | S626_RPS_DEBI;\n\t \n\t*rps++ = S626_RPS_PAUSE | S626_RPS_DEBI;\n\n\t \n\tfor (devpriv->adc_items = 0; devpriv->adc_items < 16;\n\t     devpriv->adc_items++) {\n\t\t \n\t\tlocal_ppl = (*ppl << 8) | (*ppl & 0x10 ? S626_GSEL_BIPOLAR5V :\n\t\t\t\t\t   S626_GSEL_BIPOLAR10V);\n\n\t\t \n\t\t \n\t\t*rps++ = S626_RPS_LDREG | (S626_P_DEBICMD >> 2);\n\t\t*rps++ = S626_DEBI_CMD_WRWORD | S626_LP_GSEL;\n\t\t \n\t\t*rps++ = S626_RPS_LDREG | (S626_P_DEBIAD >> 2);\n\t\t*rps++ = local_ppl;\n\t\t \n\t\t*rps++ = S626_RPS_CLRSIGNAL | S626_RPS_DEBI;\n\t\t \n\t\t*rps++ = S626_RPS_UPLOAD | S626_RPS_DEBI;\n\t\t \n\t\t*rps++ = S626_RPS_PAUSE | S626_RPS_DEBI;\n\t\t \n\t\t*rps++ = S626_RPS_LDREG | (S626_P_DEBICMD >> 2);\n\t\t \n\t\t*rps++ = S626_DEBI_CMD_WRWORD | S626_LP_ISEL;\n\t\t*rps++ = S626_RPS_LDREG | (S626_P_DEBIAD >> 2);\n\t\t \n\t\t*rps++ = local_ppl;\n\t\t \n\t\t*rps++ = S626_RPS_CLRSIGNAL | S626_RPS_DEBI;\n\t\t \n\t\t*rps++ = S626_RPS_UPLOAD | S626_RPS_DEBI;\n\t\t \n\t\t*rps++ = S626_RPS_PAUSE | S626_RPS_DEBI;\n\n\t\t \n\t\tjmp_adrs =\n\t\t\t(u32)devpriv->rps_buf.physical_base +\n\t\t\t(u32)((unsigned long)rps -\n\t\t\t      (unsigned long)devpriv->rps_buf.logical_base);\n\t\tfor (i = 0; i < (10 * S626_RPSCLK_PER_US / 2); i++) {\n\t\t\tjmp_adrs += 8;\t \n\t\t\t \n\t\t\t*rps++ = S626_RPS_JUMP;\n\t\t\t*rps++ = jmp_adrs;\n\t\t}\n\n\t\tif (cmd->convert_src != TRIG_NOW) {\n\t\t\t \n\t\t\t*rps++ = S626_RPS_PAUSE | S626_RPS_SIGADC;\n\t\t\t*rps++ = S626_RPS_CLRSIGNAL | S626_RPS_SIGADC;\n\t\t}\n\t\t \n\t\t \n\t\t*rps++ = S626_RPS_LDREG | (S626_P_GPIO >> 2);\n\t\t*rps++ = S626_GPIO_BASE | S626_GPIO1_LO;\n\t\t*rps++ = S626_RPS_NOP;\n\t\t \n\t\t \n\t\t*rps++ = S626_RPS_LDREG | (S626_P_GPIO >> 2);\n\t\t*rps++ = S626_GPIO_BASE | S626_GPIO1_HI;\n\t\t \n\t\t \n\t\t*rps++ = S626_RPS_PAUSE | S626_RPS_GPIO2;\n\n\t\t \n\t\t*rps++ = S626_RPS_STREG |\n\t\t\t (S626_BUGFIX_STREG(S626_P_FB_BUFFER1) >> 2);\n\t\t*rps++ = (u32)devpriv->ana_buf.physical_base +\n\t\t\t (devpriv->adc_items << 2);\n\n\t\t \n\t\tif (*ppl++ & S626_EOPL) {\n\t\t\tdevpriv->adc_items++;  \n\t\t\tbreak;\t \n\t\t}\n\t}\n\n\t \n\tfor (n = 0; n < (2 * S626_RPSCLK_PER_US); n++)\n\t\t*rps++ = S626_RPS_NOP;\n\n\t \n\t \n\t*rps++ = S626_RPS_LDREG | (S626_P_GPIO >> 2);\n\t*rps++ = S626_GPIO_BASE | S626_GPIO1_LO;\n\t*rps++ = S626_RPS_NOP;\n\t \n\t*rps++ = S626_RPS_LDREG | (S626_P_GPIO >> 2);  \n\t*rps++ = S626_GPIO_BASE | S626_GPIO1_HI;\n\n\t \n\t*rps++ = S626_RPS_PAUSE | S626_RPS_GPIO2;\t \n\n\t \n\t*rps++ = S626_RPS_STREG | (S626_BUGFIX_STREG(S626_P_FB_BUFFER1) >> 2);\n\t*rps++ = (u32)devpriv->ana_buf.physical_base +\n\t\t (devpriv->adc_items << 2);\n\n\t \n\t \n\t \n\n\t \n\tif (devpriv->ai_cmd_running == 1)\n\t\t*rps++ = S626_RPS_IRQ;\n\n\t \n\t*rps++ = S626_RPS_JUMP;\t \n\t*rps++ = (u32)devpriv->rps_buf.physical_base;\n\n\t \n}\n\nstatic int s626_ai_eoc(struct comedi_device *dev,\n\t\t       struct comedi_subdevice *s,\n\t\t       struct comedi_insn *insn,\n\t\t       unsigned long context)\n{\n\tunsigned int status;\n\n\tstatus = readl(dev->mmio + S626_P_PSR);\n\tif (status & S626_PSR_GPIO2)\n\t\treturn 0;\n\treturn -EBUSY;\n}\n\nstatic int s626_ai_insn_read(struct comedi_device *dev,\n\t\t\t     struct comedi_subdevice *s,\n\t\t\t     struct comedi_insn *insn,\n\t\t\t     unsigned int *data)\n{\n\tu16 chan = CR_CHAN(insn->chanspec);\n\tu16 range = CR_RANGE(insn->chanspec);\n\tu16 adc_spec = 0;\n\tu32 gpio_image;\n\tu32 tmp;\n\tint ret;\n\tint n;\n\n\t \n\tif (range == 0)\n\t\tadc_spec = (chan << 8) | (S626_GSEL_BIPOLAR5V);\n\telse\n\t\tadc_spec = (chan << 8) | (S626_GSEL_BIPOLAR10V);\n\n\t \n\ts626_debi_write(dev, S626_LP_GSEL, adc_spec);\t \n\n\t \n\ts626_debi_write(dev, S626_LP_ISEL, adc_spec);\t \n\n\tfor (n = 0; n < insn->n; n++) {\n\t\t \n\t\tusleep_range(10, 20);\n\n\t\t \n\t\tgpio_image = readl(dev->mmio + S626_P_GPIO);\n\t\t \n\t\twritel(gpio_image & ~S626_GPIO1_HI, dev->mmio + S626_P_GPIO);\n\t\t \n\t\twritel(gpio_image & ~S626_GPIO1_HI, dev->mmio + S626_P_GPIO);\n\t\twritel(gpio_image & ~S626_GPIO1_HI, dev->mmio + S626_P_GPIO);\n\t\t \n\t\twritel(gpio_image | S626_GPIO1_HI, dev->mmio + S626_P_GPIO);\n\n\t\t \n\n\t\t \n\t\tret = comedi_timeout(dev, s, insn, s626_ai_eoc, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tif (n != 0) {\n\t\t\ttmp = readl(dev->mmio + S626_P_FB_BUFFER1);\n\t\t\tdata[n - 1] = s626_ai_reg_to_uint(tmp);\n\t\t}\n\n\t\t \n\t\tudelay(4);\n\t}\n\n\t \n\tgpio_image = readl(dev->mmio + S626_P_GPIO);\n\t \n\twritel(gpio_image & ~S626_GPIO1_HI, dev->mmio + S626_P_GPIO);\n\t \n\twritel(gpio_image & ~S626_GPIO1_HI, dev->mmio + S626_P_GPIO);\n\twritel(gpio_image & ~S626_GPIO1_HI, dev->mmio + S626_P_GPIO);\n\t \n\twritel(gpio_image | S626_GPIO1_HI, dev->mmio + S626_P_GPIO);\n\n\t \n\n\t \n\tret = comedi_timeout(dev, s, insn, s626_ai_eoc, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\t \n\tif (n != 0) {\n\t\ttmp = readl(dev->mmio + S626_P_FB_BUFFER1);\n\t\tdata[n - 1] = s626_ai_reg_to_uint(tmp);\n\t}\n\n\treturn n;\n}\n\nstatic int s626_ai_load_polllist(u8 *ppl, struct comedi_cmd *cmd)\n{\n\tint n;\n\n\tfor (n = 0; n < cmd->chanlist_len; n++) {\n\t\tif (CR_RANGE(cmd->chanlist[n]) == 0)\n\t\t\tppl[n] = CR_CHAN(cmd->chanlist[n]) | S626_RANGE_5V;\n\t\telse\n\t\t\tppl[n] = CR_CHAN(cmd->chanlist[n]) | S626_RANGE_10V;\n\t}\n\tif (n != 0)\n\t\tppl[n - 1] |= S626_EOPL;\n\n\treturn n;\n}\n\nstatic int s626_ai_inttrig(struct comedi_device *dev,\n\t\t\t   struct comedi_subdevice *s,\n\t\t\t   unsigned int trig_num)\n{\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\n\tif (trig_num != cmd->start_arg)\n\t\treturn -EINVAL;\n\n\t \n\ts626_mc_enable(dev, S626_MC1_ERPS1, S626_P_MC1);\n\n\ts->async->inttrig = NULL;\n\n\treturn 1;\n}\n\n \nstatic int s626_ns_to_timer(unsigned int *nanosec, unsigned int flags)\n{\n\tint divider, base;\n\n\tbase = 500;\t\t \n\n\tswitch (flags & CMDF_ROUND_MASK) {\n\tcase CMDF_ROUND_NEAREST:\n\tdefault:\n\t\tdivider = DIV_ROUND_CLOSEST(*nanosec, base);\n\t\tbreak;\n\tcase CMDF_ROUND_DOWN:\n\t\tdivider = (*nanosec) / base;\n\t\tbreak;\n\tcase CMDF_ROUND_UP:\n\t\tdivider = DIV_ROUND_UP(*nanosec, base);\n\t\tbreak;\n\t}\n\n\t*nanosec = base * divider;\n\treturn divider - 1;\n}\n\nstatic void s626_timer_load(struct comedi_device *dev,\n\t\t\t    unsigned int chan, int tick)\n{\n\tu16 setup =\n\t\t \n\t\tS626_SET_STD_LOADSRC(S626_LOADSRC_INDX) |\n\t\t \n\t\tS626_SET_STD_INDXSRC(S626_INDXSRC_SOFT) |\n\t\t \n\t\tS626_SET_STD_ENCMODE(S626_ENCMODE_TIMER) |\n\t\t \n\t\tS626_SET_STD_CLKPOL(S626_CNTDIR_DOWN) |\n\t\t \n\t\tS626_SET_STD_CLKMULT(S626_CLKMULT_1X) |\n\t\t \n\t\tS626_SET_STD_CLKENAB(S626_CLKENAB_INDEX);\n\tu16 value_latchsrc = S626_LATCHSRC_A_INDXA;\n\t \n\n\ts626_set_mode(dev, chan, setup, false);\n\n\t \n\ts626_preload(dev, chan, tick);\n\n\t \n\ts626_set_load_trig(dev, chan, 0);\n\ts626_pulse_index(dev, chan);\n\n\t \n\ts626_set_load_trig(dev, chan, 1);\n\n\t \n\ts626_set_int_src(dev, chan, S626_INTSRC_OVER);\n\n\ts626_set_latch_source(dev, chan, value_latchsrc);\n\t \n}\n\n \nstatic int s626_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\n{\n\tstruct s626_private *devpriv = dev->private;\n\tu8 ppl[16];\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tint tick;\n\n\tif (devpriv->ai_cmd_running) {\n\t\tdev_err(dev->class_dev,\n\t\t\t\"%s: Another ai_cmd is running\\n\", __func__);\n\t\treturn -EBUSY;\n\t}\n\t \n\twritel(0, dev->mmio + S626_P_IER);\n\n\t \n\twritel(S626_IRQ_RPS1 | S626_IRQ_GPIO3, dev->mmio + S626_P_ISR);\n\n\t \n\ts626_dio_clear_irq(dev);\n\t \n\n\t \n\tdevpriv->ai_cmd_running = 0;\n\n\ts626_ai_load_polllist(ppl, cmd);\n\tdevpriv->ai_cmd_running = 1;\n\tdevpriv->ai_convert_count = 0;\n\n\tswitch (cmd->scan_begin_src) {\n\tcase TRIG_FOLLOW:\n\t\tbreak;\n\tcase TRIG_TIMER:\n\t\t \n\t\ttick = s626_ns_to_timer(&cmd->scan_begin_arg, cmd->flags);\n\n\t\t \n\t\ts626_timer_load(dev, 5, tick);\n\t\ts626_set_enable(dev, 5, S626_CLKENAB_ALWAYS);\n\t\tbreak;\n\tcase TRIG_EXT:\n\t\t \n\t\tif (cmd->start_src != TRIG_EXT)\n\t\t\ts626_dio_set_irq(dev, cmd->scan_begin_arg);\n\t\tbreak;\n\t}\n\n\tswitch (cmd->convert_src) {\n\tcase TRIG_NOW:\n\t\tbreak;\n\tcase TRIG_TIMER:\n\t\t \n\t\ttick = s626_ns_to_timer(&cmd->convert_arg, cmd->flags);\n\n\t\t \n\t\ts626_timer_load(dev, 4, tick);\n\t\ts626_set_enable(dev, 4, S626_CLKENAB_INDEX);\n\t\tbreak;\n\tcase TRIG_EXT:\n\t\t \n\t\tif (cmd->scan_begin_src != TRIG_EXT &&\n\t\t    cmd->start_src == TRIG_EXT)\n\t\t\ts626_dio_set_irq(dev, cmd->convert_arg);\n\t\tbreak;\n\t}\n\n\ts626_reset_adc(dev, ppl);\n\n\tswitch (cmd->start_src) {\n\tcase TRIG_NOW:\n\t\t \n\t\t \n\n\t\t \n\t\ts626_mc_enable(dev, S626_MC1_ERPS1, S626_P_MC1);\n\t\ts->async->inttrig = NULL;\n\t\tbreak;\n\tcase TRIG_EXT:\n\t\t \n\t\ts626_dio_set_irq(dev, cmd->start_arg);\n\t\ts->async->inttrig = NULL;\n\t\tbreak;\n\tcase TRIG_INT:\n\t\ts->async->inttrig = s626_ai_inttrig;\n\t\tbreak;\n\t}\n\n\t \n\twritel(S626_IRQ_GPIO3 | S626_IRQ_RPS1, dev->mmio + S626_P_IER);\n\n\treturn 0;\n}\n\nstatic int s626_ai_cmdtest(struct comedi_device *dev,\n\t\t\t   struct comedi_subdevice *s, struct comedi_cmd *cmd)\n{\n\tint err = 0;\n\tunsigned int arg;\n\n\t \n\n\terr |= comedi_check_trigger_src(&cmd->start_src,\n\t\t\t\t\tTRIG_NOW | TRIG_INT | TRIG_EXT);\n\terr |= comedi_check_trigger_src(&cmd->scan_begin_src,\n\t\t\t\t\tTRIG_TIMER | TRIG_EXT | TRIG_FOLLOW);\n\terr |= comedi_check_trigger_src(&cmd->convert_src,\n\t\t\t\t\tTRIG_TIMER | TRIG_EXT | TRIG_NOW);\n\terr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\n\terr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\n\n\tif (err)\n\t\treturn 1;\n\n\t \n\n\terr |= comedi_check_trigger_is_unique(cmd->start_src);\n\terr |= comedi_check_trigger_is_unique(cmd->scan_begin_src);\n\terr |= comedi_check_trigger_is_unique(cmd->convert_src);\n\terr |= comedi_check_trigger_is_unique(cmd->stop_src);\n\n\t \n\n\tif (err)\n\t\treturn 2;\n\n\t \n\n\tswitch (cmd->start_src) {\n\tcase TRIG_NOW:\n\tcase TRIG_INT:\n\t\terr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\n\t\tbreak;\n\tcase TRIG_EXT:\n\t\terr |= comedi_check_trigger_arg_max(&cmd->start_arg, 39);\n\t\tbreak;\n\t}\n\n\tif (cmd->scan_begin_src == TRIG_EXT)\n\t\terr |= comedi_check_trigger_arg_max(&cmd->scan_begin_arg, 39);\n\tif (cmd->convert_src == TRIG_EXT)\n\t\terr |= comedi_check_trigger_arg_max(&cmd->convert_arg, 39);\n\n#define S626_MAX_SPEED\t200000\t \n#define S626_MIN_SPEED\t2000000000\t \n\n\tif (cmd->scan_begin_src == TRIG_TIMER) {\n\t\terr |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,\n\t\t\t\t\t\t    S626_MAX_SPEED);\n\t\terr |= comedi_check_trigger_arg_max(&cmd->scan_begin_arg,\n\t\t\t\t\t\t    S626_MIN_SPEED);\n\t} else {\n\t\t \n\t}\n\tif (cmd->convert_src == TRIG_TIMER) {\n\t\terr |= comedi_check_trigger_arg_min(&cmd->convert_arg,\n\t\t\t\t\t\t    S626_MAX_SPEED);\n\t\terr |= comedi_check_trigger_arg_max(&cmd->convert_arg,\n\t\t\t\t\t\t    S626_MIN_SPEED);\n\t} else {\n\t\t \n\t}\n\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\n\t\t\t\t\t   cmd->chanlist_len);\n\n\tif (cmd->stop_src == TRIG_COUNT)\n\t\terr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\n\telse\t \n\t\terr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\n\n\tif (err)\n\t\treturn 3;\n\n\t \n\n\tif (cmd->scan_begin_src == TRIG_TIMER) {\n\t\targ = cmd->scan_begin_arg;\n\t\ts626_ns_to_timer(&arg, cmd->flags);\n\t\terr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, arg);\n\t}\n\n\tif (cmd->convert_src == TRIG_TIMER) {\n\t\targ = cmd->convert_arg;\n\t\ts626_ns_to_timer(&arg, cmd->flags);\n\t\terr |= comedi_check_trigger_arg_is(&cmd->convert_arg, arg);\n\n\t\tif (cmd->scan_begin_src == TRIG_TIMER) {\n\t\t\targ = cmd->convert_arg * cmd->scan_end_arg;\n\t\t\terr |= comedi_check_trigger_arg_min(\n\t\t\t\t\t&cmd->scan_begin_arg, arg);\n\t\t}\n\t}\n\n\tif (err)\n\t\treturn 4;\n\n\treturn 0;\n}\n\nstatic int s626_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)\n{\n\tstruct s626_private *devpriv = dev->private;\n\n\t \n\ts626_mc_disable(dev, S626_MC1_ERPS1, S626_P_MC1);\n\n\t \n\twritel(0, dev->mmio + S626_P_IER);\n\n\tdevpriv->ai_cmd_running = 0;\n\n\treturn 0;\n}\n\nstatic int s626_ao_insn_write(struct comedi_device *dev,\n\t\t\t      struct comedi_subdevice *s,\n\t\t\t      struct comedi_insn *insn,\n\t\t\t      unsigned int *data)\n{\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tint i;\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\ts16 dacdata = (s16)data[i];\n\t\tint ret;\n\n\t\tdacdata -= (0x1fff);\n\n\t\tret = s626_set_dac(dev, chan, dacdata);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\ts->readback[chan] = data[i];\n\t}\n\n\treturn insn->n;\n}\n\n \n\n \n\nstatic void s626_dio_init(struct comedi_device *dev)\n{\n\tu16 group;\n\n\t \n\ts626_debi_write(dev, S626_LP_MISC1, S626_MISC1_NOEDCAP);\n\n\t \n\tfor (group = 0; group < S626_DIO_BANKS; group++) {\n\t\t \n\t\ts626_debi_write(dev, S626_LP_WRINTSEL(group), 0);\n\t\t \n\t\ts626_debi_write(dev, S626_LP_WRCAPSEL(group), 0xffff);\n\t\t \n\t\ts626_debi_write(dev, S626_LP_WREDGSEL(group), 0);\n\t\t \n\t\ts626_debi_write(dev, S626_LP_WRDOUT(group), 0);\n\t}\n}\n\nstatic int s626_dio_insn_bits(struct comedi_device *dev,\n\t\t\t      struct comedi_subdevice *s,\n\t\t\t      struct comedi_insn *insn,\n\t\t\t      unsigned int *data)\n{\n\tunsigned long group = (unsigned long)s->private;\n\n\tif (comedi_dio_update_state(s, data))\n\t\ts626_debi_write(dev, S626_LP_WRDOUT(group), s->state);\n\n\tdata[1] = s626_debi_read(dev, S626_LP_RDDIN(group));\n\n\treturn insn->n;\n}\n\nstatic int s626_dio_insn_config(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tstruct comedi_insn *insn,\n\t\t\t\tunsigned int *data)\n{\n\tunsigned long group = (unsigned long)s->private;\n\tint ret;\n\n\tret = comedi_dio_insn_config(dev, s, insn, data, 0);\n\tif (ret)\n\t\treturn ret;\n\n\ts626_debi_write(dev, S626_LP_WRDOUT(group), s->io_bits);\n\n\treturn insn->n;\n}\n\n \nstatic int s626_enc_insn_config(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tstruct comedi_insn *insn, unsigned int *data)\n{\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tu16 setup =\n\t\t \n\t\tS626_SET_STD_LOADSRC(S626_LOADSRC_INDX) |\n\t\t \n\t\tS626_SET_STD_INDXSRC(S626_INDXSRC_SOFT) |\n\t\t \n\t\tS626_SET_STD_ENCMODE(S626_ENCMODE_COUNTER) |\n\t\t \n\t\tS626_SET_STD_CLKPOL(S626_CLKPOL_POS) |\n\t\t \n\t\tS626_SET_STD_CLKMULT(S626_CLKMULT_1X) |\n\t\t \n\t\tS626_SET_STD_CLKENAB(S626_CLKENAB_INDEX);\n\t \n\t \n\tu16 value_latchsrc = S626_LATCHSRC_AB_READ;\n\tu16 enab = S626_CLKENAB_ALWAYS;\n\n\t \n\n\ts626_set_mode(dev, chan, setup, true);\n\ts626_preload(dev, chan, data[0]);\n\ts626_pulse_index(dev, chan);\n\ts626_set_latch_source(dev, chan, value_latchsrc);\n\ts626_set_enable(dev, chan, (enab != 0));\n\n\treturn insn->n;\n}\n\nstatic int s626_enc_insn_read(struct comedi_device *dev,\n\t\t\t      struct comedi_subdevice *s,\n\t\t\t      struct comedi_insn *insn,\n\t\t\t      unsigned int *data)\n{\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tu16 cntr_latch_reg = S626_LP_CNTR(chan);\n\tint i;\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\tunsigned int val;\n\n\t\t \n\t\tval = s626_debi_read(dev, cntr_latch_reg);\n\t\tval |= (s626_debi_read(dev, cntr_latch_reg + 2) << 16);\n\t\tdata[i] = val;\n\t}\n\n\treturn insn->n;\n}\n\nstatic int s626_enc_insn_write(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       struct comedi_insn *insn, unsigned int *data)\n{\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\n\t \n\ts626_preload(dev, chan, data[0]);\n\n\t \n\ts626_set_load_trig(dev, chan, 0);\n\ts626_pulse_index(dev, chan);\n\ts626_set_load_trig(dev, chan, 2);\n\n\treturn 1;\n}\n\nstatic void s626_write_misc2(struct comedi_device *dev, u16 new_image)\n{\n\ts626_debi_write(dev, S626_LP_MISC1, S626_MISC1_WENABLE);\n\ts626_debi_write(dev, S626_LP_WRMISC2, new_image);\n\ts626_debi_write(dev, S626_LP_MISC1, S626_MISC1_WDISABLE);\n}\n\nstatic void s626_counters_init(struct comedi_device *dev)\n{\n\tint chan;\n\tu16 setup =\n\t\t \n\t\tS626_SET_STD_LOADSRC(S626_LOADSRC_INDX) |\n\t\t \n\t\tS626_SET_STD_INDXSRC(S626_INDXSRC_SOFT) |\n\t\t \n\t\tS626_SET_STD_ENCMODE(S626_ENCMODE_COUNTER) |\n\t\t \n\t\tS626_SET_STD_CLKPOL(S626_CLKPOL_POS) |\n\t\t \n\t\tS626_SET_STD_CLKMULT(S626_CLKMULT_1X) |\n\t\t \n\t\tS626_SET_STD_CLKENAB(S626_CLKENAB_INDEX);\n\n\t \n\tfor (chan = 0; chan < S626_ENCODER_CHANNELS; chan++) {\n\t\ts626_set_mode(dev, chan, setup, true);\n\t\ts626_set_int_src(dev, chan, 0);\n\t\ts626_reset_cap_flags(dev, chan);\n\t\ts626_set_enable(dev, chan, S626_CLKENAB_ALWAYS);\n\t}\n}\n\nstatic int s626_allocate_dma_buffers(struct comedi_device *dev)\n{\n\tstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\n\tstruct s626_private *devpriv = dev->private;\n\tvoid *addr;\n\tdma_addr_t appdma;\n\n\taddr = dma_alloc_coherent(&pcidev->dev, S626_DMABUF_SIZE, &appdma,\n\t\t\t\t  GFP_KERNEL);\n\tif (!addr)\n\t\treturn -ENOMEM;\n\tdevpriv->ana_buf.logical_base = addr;\n\tdevpriv->ana_buf.physical_base = appdma;\n\n\taddr = dma_alloc_coherent(&pcidev->dev, S626_DMABUF_SIZE, &appdma,\n\t\t\t\t  GFP_KERNEL);\n\tif (!addr)\n\t\treturn -ENOMEM;\n\tdevpriv->rps_buf.logical_base = addr;\n\tdevpriv->rps_buf.physical_base = appdma;\n\n\treturn 0;\n}\n\nstatic void s626_free_dma_buffers(struct comedi_device *dev)\n{\n\tstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\n\tstruct s626_private *devpriv = dev->private;\n\n\tif (!devpriv)\n\t\treturn;\n\n\tif (devpriv->rps_buf.logical_base)\n\t\tdma_free_coherent(&pcidev->dev, S626_DMABUF_SIZE,\n\t\t\t\t  devpriv->rps_buf.logical_base,\n\t\t\t\t  devpriv->rps_buf.physical_base);\n\tif (devpriv->ana_buf.logical_base)\n\t\tdma_free_coherent(&pcidev->dev, S626_DMABUF_SIZE,\n\t\t\t\t  devpriv->ana_buf.logical_base,\n\t\t\t\t  devpriv->ana_buf.physical_base);\n}\n\nstatic int s626_initialize(struct comedi_device *dev)\n{\n\tstruct s626_private *devpriv = dev->private;\n\tdma_addr_t phys_buf;\n\tu16 chan;\n\tint i;\n\tint ret;\n\n\t \n\ts626_mc_enable(dev, S626_MC1_DEBI | S626_MC1_AUDIO | S626_MC1_I2C,\n\t\t       S626_P_MC1);\n\n\t \n\twritel(S626_DEBI_CFG_SLAVE16 |\n\t       (S626_DEBI_TOUT << S626_DEBI_CFG_TOUT_BIT) | S626_DEBI_SWAP |\n\t       S626_DEBI_CFG_INTEL, dev->mmio + S626_P_DEBICFG);\n\n\t \n\twritel(S626_DEBI_PAGE_DISABLE, dev->mmio + S626_P_DEBIPAGE);\n\n\t \n\twritel(S626_GPIO_BASE | S626_GPIO1_HI, dev->mmio + S626_P_GPIO);\n\n\t \n\tdevpriv->i2c_adrs = 0xA0;\n\n\t \n\twritel(S626_I2C_CLKSEL | S626_I2C_ABORT,\n\t       dev->mmio + S626_P_I2CSTAT);\n\ts626_mc_enable(dev, S626_MC2_UPLD_IIC, S626_P_MC2);\n\tret = comedi_timeout(dev, NULL, NULL, s626_i2c_handshake_eoc, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor (i = 0; i < 2; i++) {\n\t\twritel(S626_I2C_CLKSEL, dev->mmio + S626_P_I2CSTAT);\n\t\ts626_mc_enable(dev, S626_MC2_UPLD_IIC, S626_P_MC2);\n\t\tret = comedi_timeout(dev, NULL,\n\t\t\t\t     NULL, s626_i2c_handshake_eoc, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\twritel(S626_ACON2_INIT, dev->mmio + S626_P_ACON2);\n\n\t \n\twritel(S626_RSD1 | S626_SIB_A1, dev->mmio + S626_P_TSL1);\n\twritel(S626_RSD1 | S626_SIB_A1 | S626_EOS,\n\t       dev->mmio + S626_P_TSL1 + 4);\n\n\t \n\twritel(S626_ACON1_ADCSTART, dev->mmio + S626_P_ACON1);\n\n\t \n\n\t \n\twritel((u32)devpriv->rps_buf.physical_base,\n\t       dev->mmio + S626_P_RPSADDR1);\n\t \n\twritel(0, dev->mmio + S626_P_RPSPAGE1);\n\t \n\twritel(0, dev->mmio + S626_P_RPS1_TOUT);\n\n#if 0\n\t \n\t{\n\t\tstruct comedi_subdevice *s = dev->read_subdev;\n\t\tu8 poll_list;\n\t\tu16 adc_data;\n\t\tu16 start_val;\n\t\tu16 index;\n\t\tunsigned int data[16];\n\n\t\t \n\t\tpoll_list = S626_EOPL;\n\t\ts626_reset_adc(dev, &poll_list);\n\n\t\t \n\t\ts626_ai_rinsn(dev, s, NULL, data);\n\t\tstart_val = data[0];\n\n\t\t \n\t\tfor (index = 0; index < 500; index++) {\n\t\t\ts626_ai_rinsn(dev, s, NULL, data);\n\t\t\tadc_data = data[0];\n\t\t\tif (adc_data != start_val)\n\t\t\t\tbreak;\n\t\t}\n\t}\n#endif\t \n\n\t \n\n\t \n\twritel(0, dev->mmio + S626_P_PCI_BT_A);\n\n\t \n\tphys_buf = devpriv->ana_buf.physical_base +\n\t\t   (S626_DAC_WDMABUF_OS * sizeof(u32));\n\twritel((u32)phys_buf, dev->mmio + S626_P_BASEA2_OUT);\n\twritel((u32)(phys_buf + sizeof(u32)),\n\t       dev->mmio + S626_P_PROTA2_OUT);\n\n\t \n\tdevpriv->dac_wbuf = (u32 *)devpriv->ana_buf.logical_base +\n\t\t\t    S626_DAC_WDMABUF_OS;\n\n\t \n\twritel(8, dev->mmio + S626_P_PAGEA2_OUT);\n\n\t \n\n\t \n\twritel(S626_XSD2 | S626_RSD3 | S626_SIB_A2 | S626_EOS,\n\t       dev->mmio + S626_VECTPORT(0));\n\n\t \n\n\t \n\twritel(S626_LF_A2, dev->mmio + S626_VECTPORT(1));\n\n\t \n\twritel(S626_ACON1_DACSTART, dev->mmio + S626_P_ACON1);\n\n\t \n\ts626_load_trim_dacs(dev);\n\tret = s626_load_trim_dacs(dev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\t \n\tfor (chan = 0; chan < S626_DAC_CHANNELS; chan++) {\n\t\tret = s626_set_dac(dev, chan, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\ts626_counters_init(dev);\n\n\t \n\ts626_write_misc2(dev, (s626_debi_read(dev, S626_LP_RDMISC2) &\n\t\t\t       S626_MISC2_BATT_ENABLE));\n\n\t \n\ts626_dio_init(dev);\n\n\treturn 0;\n}\n\nstatic int s626_auto_attach(struct comedi_device *dev,\n\t\t\t    unsigned long context_unused)\n{\n\tstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\n\tstruct s626_private *devpriv;\n\tstruct comedi_subdevice *s;\n\tint ret;\n\n\tdevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\n\tif (!devpriv)\n\t\treturn -ENOMEM;\n\n\tret = comedi_pci_enable(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tdev->mmio = pci_ioremap_bar(pcidev, 0);\n\tif (!dev->mmio)\n\t\treturn -ENOMEM;\n\n\t \n\twritel(0, dev->mmio + S626_P_IER);\n\n\t \n\twritel(S626_MC1_SOFT_RESET, dev->mmio + S626_P_MC1);\n\n\t \n\ts->type\t\t= COMEDI_SUBD_AI;\n\ts->subdev_flags\t= SDF_READABLE | SDF_DIFF;\n\ts->n_chan\t= S626_ADC_CHANNELS;\n\ts->maxdata\t= 0x3fff;\n\ts->range_table\t= &s626_range_table;\n\ts->len_chanlist\t= S626_ADC_CHANNELS;\n\ts->insn_read\t= s626_ai_insn_read;\n\tif (dev->irq) {\n\t\tdev->read_subdev = s;\n\t\ts->subdev_flags\t|= SDF_CMD_READ;\n\t\ts->do_cmd\t= s626_ai_cmd;\n\t\ts->do_cmdtest\t= s626_ai_cmdtest;\n\t\ts->cancel\t= s626_ai_cancel;\n\t}\n\n\ts = &dev->subdevices[1];\n\t \n\ts->type\t\t= COMEDI_SUBD_AO;\n\ts->subdev_flags\t= SDF_WRITABLE | SDF_READABLE;\n\ts->n_chan\t= S626_DAC_CHANNELS;\n\ts->maxdata\t= 0x3fff;\n\ts->range_table\t= &range_bipolar10;\n\ts->insn_write\t= s626_ao_insn_write;\n\n\tret = comedi_alloc_subdev_readback(s);\n\tif (ret)\n\t\treturn ret;\n\n\ts = &dev->subdevices[2];\n\t \n\ts->type\t\t= COMEDI_SUBD_DIO;\n\ts->subdev_flags\t= SDF_WRITABLE | SDF_READABLE;\n\ts->n_chan\t= 16;\n\ts->maxdata\t= 1;\n\ts->io_bits\t= 0xffff;\n\ts->private\t= (void *)0;\t \n\ts->range_table\t= &range_digital;\n\ts->insn_config\t= s626_dio_insn_config;\n\ts->insn_bits\t= s626_dio_insn_bits;\n\n\ts = &dev->subdevices[3];\n\t \n\ts->type\t\t= COMEDI_SUBD_DIO;\n\ts->subdev_flags\t= SDF_WRITABLE | SDF_READABLE;\n\ts->n_chan\t= 16;\n\ts->maxdata\t= 1;\n\ts->io_bits\t= 0xffff;\n\ts->private\t= (void *)1;\t \n\ts->range_table\t= &range_digital;\n\ts->insn_config\t= s626_dio_insn_config;\n\ts->insn_bits\t= s626_dio_insn_bits;\n\n\ts = &dev->subdevices[4];\n\t \n\ts->type\t\t= COMEDI_SUBD_DIO;\n\ts->subdev_flags\t= SDF_WRITABLE | SDF_READABLE;\n\ts->n_chan\t= 16;\n\ts->maxdata\t= 1;\n\ts->io_bits\t= 0xffff;\n\ts->private\t= (void *)2;\t \n\ts->range_table\t= &range_digital;\n\ts->insn_config\t= s626_dio_insn_config;\n\ts->insn_bits\t= s626_dio_insn_bits;\n\n\ts = &dev->subdevices[5];\n\t \n\ts->type\t\t= COMEDI_SUBD_COUNTER;\n\ts->subdev_flags\t= SDF_WRITABLE | SDF_READABLE | SDF_LSAMPL;\n\ts->n_chan\t= S626_ENCODER_CHANNELS;\n\ts->maxdata\t= 0xffffff;\n\ts->range_table\t= &range_unknown;\n\ts->insn_config\t= s626_enc_insn_config;\n\ts->insn_read\t= s626_enc_insn_read;\n\ts->insn_write\t= s626_enc_insn_write;\n\n\treturn s626_initialize(dev);\n}\n\nstatic void s626_detach(struct comedi_device *dev)\n{\n\tstruct s626_private *devpriv = dev->private;\n\n\tif (devpriv) {\n\t\t \n\t\tdevpriv->ai_cmd_running = 0;\n\n\t\tif (dev->mmio) {\n\t\t\t \n\t\t\t \n\t\t\twritel(0, dev->mmio + S626_P_IER);\n\t\t\t \n\t\t\twritel(S626_IRQ_GPIO3 | S626_IRQ_RPS1,\n\t\t\t       dev->mmio + S626_P_ISR);\n\n\t\t\t \n\t\t\ts626_write_misc2(dev, 0);\n\n\t\t\t \n\t\t\twritel(S626_MC1_SHUTDOWN, dev->mmio + S626_P_MC1);\n\t\t\twritel(S626_ACON1_BASE, dev->mmio + S626_P_ACON1);\n\t\t}\n\t}\n\tcomedi_pci_detach(dev);\n\ts626_free_dma_buffers(dev);\n}\n\nstatic struct comedi_driver s626_driver = {\n\t.driver_name\t= \"s626\",\n\t.module\t\t= THIS_MODULE,\n\t.auto_attach\t= s626_auto_attach,\n\t.detach\t\t= s626_detach,\n};\n\nstatic int s626_pci_probe(struct pci_dev *dev,\n\t\t\t  const struct pci_device_id *id)\n{\n\treturn comedi_pci_auto_config(dev, &s626_driver, id->driver_data);\n}\n\n \nstatic const struct pci_device_id s626_pci_table[] = {\n\t{ PCI_DEVICE_SUB(PCI_VENDOR_ID_PHILIPS, PCI_DEVICE_ID_PHILIPS_SAA7146,\n\t\t\t 0x6000, 0x0272) },\n\t{ 0 }\n};\nMODULE_DEVICE_TABLE(pci, s626_pci_table);\n\nstatic struct pci_driver s626_pci_driver = {\n\t.name\t\t= \"s626\",\n\t.id_table\t= s626_pci_table,\n\t.probe\t\t= s626_pci_probe,\n\t.remove\t\t= comedi_pci_auto_unconfig,\n};\nmodule_comedi_pci_driver(s626_driver, s626_pci_driver);\n\nMODULE_AUTHOR(\"Gianluca Palli <gpalli@deis.unibo.it>\");\nMODULE_DESCRIPTION(\"Sensoray 626 Comedi driver module\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}