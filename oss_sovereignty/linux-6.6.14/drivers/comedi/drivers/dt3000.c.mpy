{
  "module_name": "dt3000.c",
  "hash_id": "a41dd34a3f2422c345a28ab3b58cf9cae0b8fb48c7b7d4753f0932af2b7a6b59",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/dt3000.c",
  "human_readable_source": "\n \n\n \n\n \n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/comedi/comedi_pci.h>\n\n \n#define DPR_DAC_BUFFER\t\t(4 * 0x000)\n#define DPR_ADC_BUFFER\t\t(4 * 0x800)\n#define DPR_COMMAND\t\t(4 * 0xfd3)\n#define DPR_SUBSYS\t\t(4 * 0xfd3)\n#define DPR_SUBSYS_AI\t\t0\n#define DPR_SUBSYS_AO\t\t1\n#define DPR_SUBSYS_DIN\t\t2\n#define DPR_SUBSYS_DOUT\t\t3\n#define DPR_SUBSYS_MEM\t\t4\n#define DPR_SUBSYS_CT\t\t5\n#define DPR_ENCODE\t\t(4 * 0xfd4)\n#define DPR_PARAMS(x)\t\t(4 * (0xfd5 + (x)))\n#define DPR_TICK_REG_LO\t\t(4 * 0xff5)\n#define DPR_TICK_REG_HI\t\t(4 * 0xff6)\n#define DPR_DA_BUF_FRONT\t(4 * 0xff7)\n#define DPR_DA_BUF_REAR\t\t(4 * 0xff8)\n#define DPR_AD_BUF_FRONT\t(4 * 0xff9)\n#define DPR_AD_BUF_REAR\t\t(4 * 0xffa)\n#define DPR_INT_MASK\t\t(4 * 0xffb)\n#define DPR_INTR_FLAG\t\t(4 * 0xffc)\n#define DPR_INTR_CMDONE\t\tBIT(7)\n#define DPR_INTR_CTDONE\t\tBIT(6)\n#define DPR_INTR_DAHWERR\tBIT(5)\n#define DPR_INTR_DASWERR\tBIT(4)\n#define DPR_INTR_DAEMPTY\tBIT(3)\n#define DPR_INTR_ADHWERR\tBIT(2)\n#define DPR_INTR_ADSWERR\tBIT(1)\n#define DPR_INTR_ADFULL\t\tBIT(0)\n#define DPR_RESPONSE_MBX\t(4 * 0xffe)\n#define DPR_CMD_MBX\t\t(4 * 0xfff)\n#define DPR_CMD_COMPLETION(x)\t((x) << 8)\n#define DPR_CMD_NOTPROCESSED\tDPR_CMD_COMPLETION(0x00)\n#define DPR_CMD_NOERROR\t\tDPR_CMD_COMPLETION(0x55)\n#define DPR_CMD_ERROR\t\tDPR_CMD_COMPLETION(0xaa)\n#define DPR_CMD_NOTSUPPORTED\tDPR_CMD_COMPLETION(0xff)\n#define DPR_CMD_COMPLETION_MASK\tDPR_CMD_COMPLETION(0xff)\n#define DPR_CMD(x)\t\t((x) << 0)\n#define DPR_CMD_GETBRDINFO\tDPR_CMD(0)\n#define DPR_CMD_CONFIG\t\tDPR_CMD(1)\n#define DPR_CMD_GETCONFIG\tDPR_CMD(2)\n#define DPR_CMD_START\t\tDPR_CMD(3)\n#define DPR_CMD_STOP\t\tDPR_CMD(4)\n#define DPR_CMD_READSINGLE\tDPR_CMD(5)\n#define DPR_CMD_WRITESINGLE\tDPR_CMD(6)\n#define DPR_CMD_CALCCLOCK\tDPR_CMD(7)\n#define DPR_CMD_READEVENTS\tDPR_CMD(8)\n#define DPR_CMD_WRITECTCTRL\tDPR_CMD(16)\n#define DPR_CMD_READCTCTRL\tDPR_CMD(17)\n#define DPR_CMD_WRITECT\t\tDPR_CMD(18)\n#define DPR_CMD_READCT\t\tDPR_CMD(19)\n#define DPR_CMD_WRITEDATA\tDPR_CMD(32)\n#define DPR_CMD_READDATA\tDPR_CMD(33)\n#define DPR_CMD_WRITEIO\t\tDPR_CMD(34)\n#define DPR_CMD_READIO\t\tDPR_CMD(35)\n#define DPR_CMD_WRITECODE\tDPR_CMD(36)\n#define DPR_CMD_READCODE\tDPR_CMD(37)\n#define DPR_CMD_EXECUTE\t\tDPR_CMD(38)\n#define DPR_CMD_HALT\t\tDPR_CMD(48)\n#define DPR_CMD_MASK\t\tDPR_CMD(0xff)\n\n#define DPR_PARAM5_AD_TRIG(x)\t\t(((x) & 0x7) << 2)\n#define DPR_PARAM5_AD_TRIG_INT\t\tDPR_PARAM5_AD_TRIG(0)\n#define DPR_PARAM5_AD_TRIG_EXT\t\tDPR_PARAM5_AD_TRIG(1)\n#define DPR_PARAM5_AD_TRIG_INT_RETRIG\tDPR_PARAM5_AD_TRIG(2)\n#define DPR_PARAM5_AD_TRIG_EXT_RETRIG\tDPR_PARAM5_AD_TRIG(3)\n#define DPR_PARAM5_AD_TRIG_INT_RETRIG2\tDPR_PARAM5_AD_TRIG(4)\n\n#define DPR_PARAM6_AD_DIFF\t\tBIT(0)\n\n#define DPR_AI_FIFO_DEPTH\t\t2003\n#define DPR_AO_FIFO_DEPTH\t\t2048\n\n#define DPR_EXTERNAL_CLOCK\t\t1\n#define DPR_RISING_EDGE\t\t\t2\n\n#define DPR_TMODE_MASK\t\t\t0x1c\n\n#define DPR_CMD_TIMEOUT\t\t\t100\n\nstatic const struct comedi_lrange range_dt3000_ai = {\n\t4, {\n\t\tBIP_RANGE(10),\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(2.5),\n\t\tBIP_RANGE(1.25)\n\t}\n};\n\nstatic const struct comedi_lrange range_dt3000_ai_pgl = {\n\t4, {\n\t\tBIP_RANGE(10),\n\t\tBIP_RANGE(1),\n\t\tBIP_RANGE(0.1),\n\t\tBIP_RANGE(0.02)\n\t}\n};\n\nenum dt3k_boardid {\n\tBOARD_DT3001,\n\tBOARD_DT3001_PGL,\n\tBOARD_DT3002,\n\tBOARD_DT3003,\n\tBOARD_DT3003_PGL,\n\tBOARD_DT3004,\n\tBOARD_DT3005,\n};\n\nstruct dt3k_boardtype {\n\tconst char *name;\n\tint adchan;\n\tint ai_speed;\n\tconst struct comedi_lrange *adrange;\n\tunsigned int ai_is_16bit:1;\n\tunsigned int has_ao:1;\n};\n\nstatic const struct dt3k_boardtype dt3k_boardtypes[] = {\n\t[BOARD_DT3001] = {\n\t\t.name\t\t= \"dt3001\",\n\t\t.adchan\t\t= 16,\n\t\t.adrange\t= &range_dt3000_ai,\n\t\t.ai_speed\t= 3000,\n\t\t.has_ao\t\t= 1,\n\t},\n\t[BOARD_DT3001_PGL] = {\n\t\t.name\t\t= \"dt3001-pgl\",\n\t\t.adchan\t\t= 16,\n\t\t.adrange\t= &range_dt3000_ai_pgl,\n\t\t.ai_speed\t= 3000,\n\t\t.has_ao\t\t= 1,\n\t},\n\t[BOARD_DT3002] = {\n\t\t.name\t\t= \"dt3002\",\n\t\t.adchan\t\t= 32,\n\t\t.adrange\t= &range_dt3000_ai,\n\t\t.ai_speed\t= 3000,\n\t},\n\t[BOARD_DT3003] = {\n\t\t.name\t\t= \"dt3003\",\n\t\t.adchan\t\t= 64,\n\t\t.adrange\t= &range_dt3000_ai,\n\t\t.ai_speed\t= 3000,\n\t\t.has_ao\t\t= 1,\n\t},\n\t[BOARD_DT3003_PGL] = {\n\t\t.name\t\t= \"dt3003-pgl\",\n\t\t.adchan\t\t= 64,\n\t\t.adrange\t= &range_dt3000_ai_pgl,\n\t\t.ai_speed\t= 3000,\n\t\t.has_ao\t\t= 1,\n\t},\n\t[BOARD_DT3004] = {\n\t\t.name\t\t= \"dt3004\",\n\t\t.adchan\t\t= 16,\n\t\t.adrange\t= &range_dt3000_ai,\n\t\t.ai_speed\t= 10000,\n\t\t.ai_is_16bit\t= 1,\n\t\t.has_ao\t\t= 1,\n\t},\n\t[BOARD_DT3005] = {\n\t\t.name\t\t= \"dt3005\",\t \n\t\t.adchan\t\t= 16,\n\t\t.adrange\t= &range_dt3000_ai,\n\t\t.ai_speed\t= 5000,\n\t\t.ai_is_16bit\t= 1,\n\t\t.has_ao\t\t= 1,\n\t},\n};\n\nstruct dt3k_private {\n\tunsigned int lock;\n\tunsigned int ai_front;\n\tunsigned int ai_rear;\n};\n\nstatic void dt3k_send_cmd(struct comedi_device *dev, unsigned int cmd)\n{\n\tint i;\n\tunsigned int status = 0;\n\n\twritew(cmd, dev->mmio + DPR_CMD_MBX);\n\n\tfor (i = 0; i < DPR_CMD_TIMEOUT; i++) {\n\t\tstatus = readw(dev->mmio + DPR_CMD_MBX);\n\t\tstatus &= DPR_CMD_COMPLETION_MASK;\n\t\tif (status != DPR_CMD_NOTPROCESSED)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tif (status != DPR_CMD_NOERROR)\n\t\tdev_dbg(dev->class_dev, \"%s: timeout/error status=0x%04x\\n\",\n\t\t\t__func__, status);\n}\n\nstatic unsigned int dt3k_readsingle(struct comedi_device *dev,\n\t\t\t\t    unsigned int subsys, unsigned int chan,\n\t\t\t\t    unsigned int gain)\n{\n\twritew(subsys, dev->mmio + DPR_SUBSYS);\n\n\twritew(chan, dev->mmio + DPR_PARAMS(0));\n\twritew(gain, dev->mmio + DPR_PARAMS(1));\n\n\tdt3k_send_cmd(dev, DPR_CMD_READSINGLE);\n\n\treturn readw(dev->mmio + DPR_PARAMS(2));\n}\n\nstatic void dt3k_writesingle(struct comedi_device *dev, unsigned int subsys,\n\t\t\t     unsigned int chan, unsigned int data)\n{\n\twritew(subsys, dev->mmio + DPR_SUBSYS);\n\n\twritew(chan, dev->mmio + DPR_PARAMS(0));\n\twritew(0, dev->mmio + DPR_PARAMS(1));\n\twritew(data, dev->mmio + DPR_PARAMS(2));\n\n\tdt3k_send_cmd(dev, DPR_CMD_WRITESINGLE);\n}\n\nstatic void dt3k_ai_empty_fifo(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s)\n{\n\tstruct dt3k_private *devpriv = dev->private;\n\tint front;\n\tint rear;\n\tint count;\n\tint i;\n\tunsigned short data;\n\n\tfront = readw(dev->mmio + DPR_AD_BUF_FRONT);\n\tcount = front - devpriv->ai_front;\n\tif (count < 0)\n\t\tcount += DPR_AI_FIFO_DEPTH;\n\n\trear = devpriv->ai_rear;\n\n\tfor (i = 0; i < count; i++) {\n\t\tdata = readw(dev->mmio + DPR_ADC_BUFFER + rear);\n\t\tcomedi_buf_write_samples(s, &data, 1);\n\t\trear++;\n\t\tif (rear >= DPR_AI_FIFO_DEPTH)\n\t\t\trear = 0;\n\t}\n\n\tdevpriv->ai_rear = rear;\n\twritew(rear, dev->mmio + DPR_AD_BUF_REAR);\n}\n\nstatic int dt3k_ai_cancel(struct comedi_device *dev,\n\t\t\t  struct comedi_subdevice *s)\n{\n\twritew(DPR_SUBSYS_AI, dev->mmio + DPR_SUBSYS);\n\tdt3k_send_cmd(dev, DPR_CMD_STOP);\n\n\twritew(0, dev->mmio + DPR_INT_MASK);\n\n\treturn 0;\n}\n\nstatic int debug_n_ints;\n\n \n \nstatic irqreturn_t dt3k_interrupt(int irq, void *d)\n{\n\tstruct comedi_device *dev = d;\n\tstruct comedi_subdevice *s = dev->read_subdev;\n\tunsigned int status;\n\n\tif (!dev->attached)\n\t\treturn IRQ_NONE;\n\n\tstatus = readw(dev->mmio + DPR_INTR_FLAG);\n\n\tif (status & DPR_INTR_ADFULL)\n\t\tdt3k_ai_empty_fifo(dev, s);\n\n\tif (status & (DPR_INTR_ADSWERR | DPR_INTR_ADHWERR))\n\t\ts->async->events |= COMEDI_CB_ERROR;\n\n\tdebug_n_ints++;\n\tif (debug_n_ints >= 10)\n\t\ts->async->events |= COMEDI_CB_EOA;\n\n\tcomedi_handle_events(dev, s);\n\treturn IRQ_HANDLED;\n}\n\nstatic int dt3k_ns_to_timer(unsigned int timer_base, unsigned int *nanosec,\n\t\t\t    unsigned int flags)\n{\n\tunsigned int divider, base, prescale;\n\n\t \n\t \n\n\tfor (prescale = 0; prescale < 16; prescale++) {\n\t\tbase = timer_base * (prescale + 1);\n\t\tswitch (flags & CMDF_ROUND_MASK) {\n\t\tcase CMDF_ROUND_NEAREST:\n\t\tdefault:\n\t\t\tdivider = DIV_ROUND_CLOSEST(*nanosec, base);\n\t\t\tbreak;\n\t\tcase CMDF_ROUND_DOWN:\n\t\t\tdivider = (*nanosec) / base;\n\t\t\tbreak;\n\t\tcase CMDF_ROUND_UP:\n\t\t\tdivider = DIV_ROUND_UP(*nanosec, base);\n\t\t\tbreak;\n\t\t}\n\t\tif (divider < 65536) {\n\t\t\t*nanosec = divider * base;\n\t\t\treturn (prescale << 16) | (divider);\n\t\t}\n\t}\n\n\tprescale = 15;\n\tbase = timer_base * (prescale + 1);\n\tdivider = 65535;\n\t*nanosec = divider * base;\n\treturn (prescale << 16) | (divider);\n}\n\nstatic int dt3k_ai_cmdtest(struct comedi_device *dev,\n\t\t\t   struct comedi_subdevice *s, struct comedi_cmd *cmd)\n{\n\tconst struct dt3k_boardtype *board = dev->board_ptr;\n\tint err = 0;\n\tunsigned int arg;\n\n\t \n\n\terr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW);\n\terr |= comedi_check_trigger_src(&cmd->scan_begin_src, TRIG_TIMER);\n\terr |= comedi_check_trigger_src(&cmd->convert_src, TRIG_TIMER);\n\terr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\n\terr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT);\n\n\tif (err)\n\t\treturn 1;\n\n\t \n\t \n\n\t \n\n\terr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\n\n\tif (cmd->scan_begin_src == TRIG_TIMER) {\n\t\terr |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,\n\t\t\t\t\t\t    board->ai_speed);\n\t\terr |= comedi_check_trigger_arg_max(&cmd->scan_begin_arg,\n\t\t\t\t\t\t    100 * 16 * 65535);\n\t}\n\n\tif (cmd->convert_src == TRIG_TIMER) {\n\t\terr |= comedi_check_trigger_arg_min(&cmd->convert_arg,\n\t\t\t\t\t\t    board->ai_speed);\n\t\terr |= comedi_check_trigger_arg_max(&cmd->convert_arg,\n\t\t\t\t\t\t    50 * 16 * 65535);\n\t}\n\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\n\t\t\t\t\t   cmd->chanlist_len);\n\n\tif (cmd->stop_src == TRIG_COUNT)\n\t\terr |= comedi_check_trigger_arg_max(&cmd->stop_arg, 0x00ffffff);\n\telse\t \n\t\terr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\n\n\tif (err)\n\t\treturn 3;\n\n\t \n\n\tif (cmd->scan_begin_src == TRIG_TIMER) {\n\t\targ = cmd->scan_begin_arg;\n\t\tdt3k_ns_to_timer(100, &arg, cmd->flags);\n\t\terr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, arg);\n\t}\n\n\tif (cmd->convert_src == TRIG_TIMER) {\n\t\targ = cmd->convert_arg;\n\t\tdt3k_ns_to_timer(50, &arg, cmd->flags);\n\t\terr |= comedi_check_trigger_arg_is(&cmd->convert_arg, arg);\n\n\t\tif (cmd->scan_begin_src == TRIG_TIMER) {\n\t\t\targ = cmd->convert_arg * cmd->scan_end_arg;\n\t\t\terr |= comedi_check_trigger_arg_min(\n\t\t\t\t&cmd->scan_begin_arg, arg);\n\t\t}\n\t}\n\n\tif (err)\n\t\treturn 4;\n\n\treturn 0;\n}\n\nstatic int dt3k_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\n{\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tint i;\n\tunsigned int chan, range, aref;\n\tunsigned int divider;\n\tunsigned int tscandiv;\n\n\tfor (i = 0; i < cmd->chanlist_len; i++) {\n\t\tchan = CR_CHAN(cmd->chanlist[i]);\n\t\trange = CR_RANGE(cmd->chanlist[i]);\n\n\t\twritew((range << 6) | chan, dev->mmio + DPR_ADC_BUFFER + i);\n\t}\n\taref = CR_AREF(cmd->chanlist[0]);\n\n\twritew(cmd->scan_end_arg, dev->mmio + DPR_PARAMS(0));\n\n\tif (cmd->convert_src == TRIG_TIMER) {\n\t\tdivider = dt3k_ns_to_timer(50, &cmd->convert_arg, cmd->flags);\n\t\twritew((divider >> 16), dev->mmio + DPR_PARAMS(1));\n\t\twritew((divider & 0xffff), dev->mmio + DPR_PARAMS(2));\n\t}\n\n\tif (cmd->scan_begin_src == TRIG_TIMER) {\n\t\ttscandiv = dt3k_ns_to_timer(100, &cmd->scan_begin_arg,\n\t\t\t\t\t    cmd->flags);\n\t\twritew((tscandiv >> 16), dev->mmio + DPR_PARAMS(3));\n\t\twritew((tscandiv & 0xffff), dev->mmio + DPR_PARAMS(4));\n\t}\n\n\twritew(DPR_PARAM5_AD_TRIG_INT_RETRIG, dev->mmio + DPR_PARAMS(5));\n\twritew((aref == AREF_DIFF) ? DPR_PARAM6_AD_DIFF : 0,\n\t       dev->mmio + DPR_PARAMS(6));\n\n\twritew(DPR_AI_FIFO_DEPTH / 2, dev->mmio + DPR_PARAMS(7));\n\n\twritew(DPR_SUBSYS_AI, dev->mmio + DPR_SUBSYS);\n\tdt3k_send_cmd(dev, DPR_CMD_CONFIG);\n\n\twritew(DPR_INTR_ADFULL | DPR_INTR_ADSWERR | DPR_INTR_ADHWERR,\n\t       dev->mmio + DPR_INT_MASK);\n\n\tdebug_n_ints = 0;\n\n\twritew(DPR_SUBSYS_AI, dev->mmio + DPR_SUBSYS);\n\tdt3k_send_cmd(dev, DPR_CMD_START);\n\n\treturn 0;\n}\n\nstatic int dt3k_ai_insn_read(struct comedi_device *dev,\n\t\t\t     struct comedi_subdevice *s,\n\t\t\t     struct comedi_insn *insn,\n\t\t\t     unsigned int *data)\n{\n\tint i;\n\tunsigned int chan, gain;\n\n\tchan = CR_CHAN(insn->chanspec);\n\tgain = CR_RANGE(insn->chanspec);\n\t \n\n\tfor (i = 0; i < insn->n; i++)\n\t\tdata[i] = dt3k_readsingle(dev, DPR_SUBSYS_AI, chan, gain);\n\n\treturn i;\n}\n\nstatic int dt3k_ao_insn_write(struct comedi_device *dev,\n\t\t\t      struct comedi_subdevice *s,\n\t\t\t      struct comedi_insn *insn,\n\t\t\t      unsigned int *data)\n{\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int val = s->readback[chan];\n\tint i;\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\tval = data[i];\n\t\tdt3k_writesingle(dev, DPR_SUBSYS_AO, chan, val);\n\t}\n\ts->readback[chan] = val;\n\n\treturn insn->n;\n}\n\nstatic void dt3k_dio_config(struct comedi_device *dev, int bits)\n{\n\t \n\twritew(DPR_SUBSYS_DOUT, dev->mmio + DPR_SUBSYS);\n\n\twritew(bits, dev->mmio + DPR_PARAMS(0));\n\n\t \n\n\tdt3k_send_cmd(dev, DPR_CMD_CONFIG);\n}\n\nstatic int dt3k_dio_insn_config(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tstruct comedi_insn *insn,\n\t\t\t\tunsigned int *data)\n{\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int mask;\n\tint ret;\n\n\tif (chan < 4)\n\t\tmask = 0x0f;\n\telse\n\t\tmask = 0xf0;\n\n\tret = comedi_dio_insn_config(dev, s, insn, data, mask);\n\tif (ret)\n\t\treturn ret;\n\n\tdt3k_dio_config(dev, (s->io_bits & 0x01) | ((s->io_bits & 0x10) >> 3));\n\n\treturn insn->n;\n}\n\nstatic int dt3k_dio_insn_bits(struct comedi_device *dev,\n\t\t\t      struct comedi_subdevice *s,\n\t\t\t      struct comedi_insn *insn,\n\t\t\t      unsigned int *data)\n{\n\tif (comedi_dio_update_state(s, data))\n\t\tdt3k_writesingle(dev, DPR_SUBSYS_DOUT, 0, s->state);\n\n\tdata[1] = dt3k_readsingle(dev, DPR_SUBSYS_DIN, 0, 0);\n\n\treturn insn->n;\n}\n\nstatic int dt3k_mem_insn_read(struct comedi_device *dev,\n\t\t\t      struct comedi_subdevice *s,\n\t\t\t      struct comedi_insn *insn,\n\t\t\t      unsigned int *data)\n{\n\tunsigned int addr = CR_CHAN(insn->chanspec);\n\tint i;\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\twritew(DPR_SUBSYS_MEM, dev->mmio + DPR_SUBSYS);\n\t\twritew(addr, dev->mmio + DPR_PARAMS(0));\n\t\twritew(1, dev->mmio + DPR_PARAMS(1));\n\n\t\tdt3k_send_cmd(dev, DPR_CMD_READCODE);\n\n\t\tdata[i] = readw(dev->mmio + DPR_PARAMS(2));\n\t}\n\n\treturn i;\n}\n\nstatic int dt3000_auto_attach(struct comedi_device *dev,\n\t\t\t      unsigned long context)\n{\n\tstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\n\tconst struct dt3k_boardtype *board = NULL;\n\tstruct dt3k_private *devpriv;\n\tstruct comedi_subdevice *s;\n\tint ret = 0;\n\n\tif (context < ARRAY_SIZE(dt3k_boardtypes))\n\t\tboard = &dt3k_boardtypes[context];\n\tif (!board)\n\t\treturn -ENODEV;\n\tdev->board_ptr = board;\n\tdev->board_name = board->name;\n\n\tdevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\n\tif (!devpriv)\n\t\treturn -ENOMEM;\n\n\tret = comedi_pci_enable(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev->mmio = pci_ioremap_bar(pcidev, 0);\n\tif (!dev->mmio)\n\t\treturn -ENOMEM;\n\n\tif (pcidev->irq) {\n\t\tret = request_irq(pcidev->irq, dt3k_interrupt, IRQF_SHARED,\n\t\t\t\t  dev->board_name, dev);\n\t\tif (ret == 0)\n\t\t\tdev->irq = pcidev->irq;\n\t}\n\n\tret = comedi_alloc_subdevices(dev, 4);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ts = &dev->subdevices[0];\n\ts->type\t\t= COMEDI_SUBD_AI;\n\ts->subdev_flags\t= SDF_READABLE | SDF_GROUND | SDF_DIFF;\n\ts->n_chan\t= board->adchan;\n\ts->maxdata\t= board->ai_is_16bit ? 0xffff : 0x0fff;\n\ts->range_table\t= &range_dt3000_ai;\t \n\ts->insn_read\t= dt3k_ai_insn_read;\n\tif (dev->irq) {\n\t\tdev->read_subdev = s;\n\t\ts->subdev_flags\t|= SDF_CMD_READ;\n\t\ts->len_chanlist\t= 512;\n\t\ts->do_cmd\t= dt3k_ai_cmd;\n\t\ts->do_cmdtest\t= dt3k_ai_cmdtest;\n\t\ts->cancel\t= dt3k_ai_cancel;\n\t}\n\n\t \n\ts = &dev->subdevices[1];\n\tif (board->has_ao) {\n\t\ts->type\t\t= COMEDI_SUBD_AO;\n\t\ts->subdev_flags\t= SDF_WRITABLE;\n\t\ts->n_chan\t= 2;\n\t\ts->maxdata\t= 0x0fff;\n\t\ts->range_table\t= &range_bipolar10;\n\t\ts->insn_write\t= dt3k_ao_insn_write;\n\n\t\tret = comedi_alloc_subdev_readback(s);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t} else {\n\t\ts->type\t\t= COMEDI_SUBD_UNUSED;\n\t}\n\n\t \n\ts = &dev->subdevices[2];\n\ts->type\t\t= COMEDI_SUBD_DIO;\n\ts->subdev_flags\t= SDF_READABLE | SDF_WRITABLE;\n\ts->n_chan\t= 8;\n\ts->maxdata\t= 1;\n\ts->range_table\t= &range_digital;\n\ts->insn_config\t= dt3k_dio_insn_config;\n\ts->insn_bits\t= dt3k_dio_insn_bits;\n\n\t \n\ts = &dev->subdevices[3];\n\ts->type\t\t= COMEDI_SUBD_MEMORY;\n\ts->subdev_flags\t= SDF_READABLE;\n\ts->n_chan\t= 0x1000;\n\ts->maxdata\t= 0xff;\n\ts->range_table\t= &range_unknown;\n\ts->insn_read\t= dt3k_mem_insn_read;\n\n\treturn 0;\n}\n\nstatic struct comedi_driver dt3000_driver = {\n\t.driver_name\t= \"dt3000\",\n\t.module\t\t= THIS_MODULE,\n\t.auto_attach\t= dt3000_auto_attach,\n\t.detach\t\t= comedi_pci_detach,\n};\n\nstatic int dt3000_pci_probe(struct pci_dev *dev,\n\t\t\t    const struct pci_device_id *id)\n{\n\treturn comedi_pci_auto_config(dev, &dt3000_driver, id->driver_data);\n}\n\nstatic const struct pci_device_id dt3000_pci_table[] = {\n\t{ PCI_VDEVICE(DT, 0x0022), BOARD_DT3001 },\n\t{ PCI_VDEVICE(DT, 0x0023), BOARD_DT3002 },\n\t{ PCI_VDEVICE(DT, 0x0024), BOARD_DT3003 },\n\t{ PCI_VDEVICE(DT, 0x0025), BOARD_DT3004 },\n\t{ PCI_VDEVICE(DT, 0x0026), BOARD_DT3005 },\n\t{ PCI_VDEVICE(DT, 0x0027), BOARD_DT3001_PGL },\n\t{ PCI_VDEVICE(DT, 0x0028), BOARD_DT3003_PGL },\n\t{ 0 }\n};\nMODULE_DEVICE_TABLE(pci, dt3000_pci_table);\n\nstatic struct pci_driver dt3000_pci_driver = {\n\t.name\t\t= \"dt3000\",\n\t.id_table\t= dt3000_pci_table,\n\t.probe\t\t= dt3000_pci_probe,\n\t.remove\t\t= comedi_pci_auto_unconfig,\n};\nmodule_comedi_pci_driver(dt3000_driver, dt3000_pci_driver);\n\nMODULE_AUTHOR(\"Comedi https://www.comedi.org\");\nMODULE_DESCRIPTION(\"Comedi driver for Data Translation DT3000 series boards\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}