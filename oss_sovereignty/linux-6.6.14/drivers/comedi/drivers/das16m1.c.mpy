{
  "module_name": "das16m1.c",
  "hash_id": "486b731060aad056adb04fb1ec7850db2efec65e9cf24051c0d365368b02ee6d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/das16m1.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/comedi/comedidev.h>\n#include <linux/comedi/comedi_8255.h>\n#include <linux/comedi/comedi_8254.h>\n\n \n#define DAS16M1_AI_REG\t\t\t0x00\t \n#define DAS16M1_AI_TO_CHAN(x)\t\t(((x) >> 0) & 0xf)\n#define DAS16M1_AI_TO_SAMPLE(x)\t\t(((x) >> 4) & 0xfff)\n#define DAS16M1_CS_REG\t\t\t0x02\n#define DAS16M1_CS_EXT_TRIG\t\tBIT(0)\n#define DAS16M1_CS_OVRUN\t\tBIT(5)\n#define DAS16M1_CS_IRQDATA\t\tBIT(7)\n#define DAS16M1_DI_REG\t\t\t0x03\n#define DAS16M1_DO_REG\t\t\t0x03\n#define DAS16M1_CLR_INTR_REG\t\t0x04\n#define DAS16M1_INTR_CTRL_REG\t\t0x05\n#define DAS16M1_INTR_CTRL_PACER(x)\t(((x) & 0x3) << 0)\n#define DAS16M1_INTR_CTRL_PACER_EXT\tDAS16M1_INTR_CTRL_PACER(2)\n#define DAS16M1_INTR_CTRL_PACER_INT\tDAS16M1_INTR_CTRL_PACER(3)\n#define DAS16M1_INTR_CTRL_PACER_MASK\tDAS16M1_INTR_CTRL_PACER(3)\n#define DAS16M1_INTR_CTRL_IRQ(x)\t(((x) & 0x7) << 4)\n#define DAS16M1_INTR_CTRL_INTE\t\tBIT(7)\n#define DAS16M1_Q_ADDR_REG\t\t0x06\n#define DAS16M1_Q_REG\t\t\t0x07\n#define DAS16M1_Q_CHAN(x)              (((x) & 0x7) << 0)\n#define DAS16M1_Q_RANGE(x)             (((x) & 0xf) << 4)\n#define DAS16M1_8254_IOBASE1\t\t0x08\n#define DAS16M1_8254_IOBASE2\t\t0x0c\n#define DAS16M1_8255_IOBASE\t\t0x400\n#define DAS16M1_8254_IOBASE3\t\t0x404\n\n#define DAS16M1_SIZE2\t\t\t0x08\n\n#define DAS16M1_AI_FIFO_SZ\t\t1024\t \n\nstatic const struct comedi_lrange range_das16m1 = {\n\t9, {\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(2.5),\n\t\tBIP_RANGE(1.25),\n\t\tBIP_RANGE(0.625),\n\t\tUNI_RANGE(10),\n\t\tUNI_RANGE(5),\n\t\tUNI_RANGE(2.5),\n\t\tUNI_RANGE(1.25),\n\t\tBIP_RANGE(10)\n\t}\n};\n\nstruct das16m1_private {\n\tstruct comedi_8254 *counter;\n\tunsigned int intr_ctrl;\n\tunsigned int adc_count;\n\tu16 initial_hw_count;\n\tunsigned short ai_buffer[DAS16M1_AI_FIFO_SZ];\n\tunsigned long extra_iobase;\n};\n\nstatic void das16m1_ai_set_queue(struct comedi_device *dev,\n\t\t\t\t unsigned int *chanspec, unsigned int len)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < len; i++) {\n\t\tunsigned int chan = CR_CHAN(chanspec[i]);\n\t\tunsigned int range = CR_RANGE(chanspec[i]);\n\n\t\toutb(i, dev->iobase + DAS16M1_Q_ADDR_REG);\n\t\toutb(DAS16M1_Q_CHAN(chan) | DAS16M1_Q_RANGE(range),\n\t\t     dev->iobase + DAS16M1_Q_REG);\n\t}\n}\n\nstatic void das16m1_ai_munge(struct comedi_device *dev,\n\t\t\t     struct comedi_subdevice *s,\n\t\t\t     void *data, unsigned int num_bytes,\n\t\t\t     unsigned int start_chan_index)\n{\n\tunsigned short *array = data;\n\tunsigned int nsamples = comedi_bytes_to_samples(s, num_bytes);\n\tunsigned int i;\n\n\t \n\tfor (i = 0; i < nsamples; i++)\n\t\tarray[i] = DAS16M1_AI_TO_SAMPLE(array[i]);\n}\n\nstatic int das16m1_ai_check_chanlist(struct comedi_device *dev,\n\t\t\t\t     struct comedi_subdevice *s,\n\t\t\t\t     struct comedi_cmd *cmd)\n{\n\tint i;\n\n\tif (cmd->chanlist_len == 1)\n\t\treturn 0;\n\n\tif ((cmd->chanlist_len % 2) != 0) {\n\t\tdev_dbg(dev->class_dev,\n\t\t\t\"chanlist must be of even length or length 1\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < cmd->chanlist_len; i++) {\n\t\tunsigned int chan = CR_CHAN(cmd->chanlist[i]);\n\n\t\tif ((i % 2) != (chan % 2)) {\n\t\t\tdev_dbg(dev->class_dev,\n\t\t\t\t\"even/odd channels must go have even/odd chanlist indices\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int das16m1_ai_cmdtest(struct comedi_device *dev,\n\t\t\t      struct comedi_subdevice *s,\n\t\t\t      struct comedi_cmd *cmd)\n{\n\tint err = 0;\n\n\t \n\n\terr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_EXT);\n\terr |= comedi_check_trigger_src(&cmd->scan_begin_src, TRIG_FOLLOW);\n\terr |= comedi_check_trigger_src(&cmd->convert_src,\n\t\t\t\t\tTRIG_TIMER | TRIG_EXT);\n\terr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\n\terr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\n\n\tif (err)\n\t\treturn 1;\n\n\t \n\n\terr |= comedi_check_trigger_is_unique(cmd->start_src);\n\terr |= comedi_check_trigger_is_unique(cmd->convert_src);\n\terr |= comedi_check_trigger_is_unique(cmd->stop_src);\n\n\t \n\n\tif (err)\n\t\treturn 2;\n\n\t \n\n\terr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\n\n\tif (cmd->scan_begin_src == TRIG_FOLLOW)\t \n\t\terr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);\n\n\tif (cmd->convert_src == TRIG_TIMER)\n\t\terr |= comedi_check_trigger_arg_min(&cmd->convert_arg, 1000);\n\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\n\t\t\t\t\t   cmd->chanlist_len);\n\n\tif (cmd->stop_src == TRIG_COUNT)\n\t\terr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\n\telse\t \n\t\terr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\n\n\tif (err)\n\t\treturn 3;\n\n\t \n\n\tif (cmd->convert_src == TRIG_TIMER) {\n\t\tunsigned int arg = cmd->convert_arg;\n\n\t\tcomedi_8254_cascade_ns_to_timer(dev->pacer, &arg, cmd->flags);\n\t\terr |= comedi_check_trigger_arg_is(&cmd->convert_arg, arg);\n\t}\n\n\tif (err)\n\t\treturn 4;\n\n\t \n\tif (cmd->chanlist && cmd->chanlist_len > 0)\n\t\terr |= das16m1_ai_check_chanlist(dev, s, cmd);\n\n\tif (err)\n\t\treturn 5;\n\n\treturn 0;\n}\n\nstatic int das16m1_ai_cmd(struct comedi_device *dev,\n\t\t\t  struct comedi_subdevice *s)\n{\n\tstruct das16m1_private *devpriv = dev->private;\n\tstruct comedi_async *async = s->async;\n\tstruct comedi_cmd *cmd = &async->cmd;\n\tunsigned int byte;\n\n\t \n\tdevpriv->adc_count = 0;\n\n\t \n\tcomedi_8254_set_mode(devpriv->counter, 1, I8254_MODE2 | I8254_BINARY);\n\tcomedi_8254_write(devpriv->counter, 1, 0);\n\n\t \n\tdevpriv->initial_hw_count = comedi_8254_read(devpriv->counter, 1);\n\n\tdas16m1_ai_set_queue(dev, cmd->chanlist, cmd->chanlist_len);\n\n\t \n\tdevpriv->intr_ctrl &= ~DAS16M1_INTR_CTRL_PACER_MASK;\n\tif (cmd->convert_src == TRIG_TIMER) {\n\t\tcomedi_8254_update_divisors(dev->pacer);\n\t\tcomedi_8254_pacer_enable(dev->pacer, 1, 2, true);\n\t\tdevpriv->intr_ctrl |= DAS16M1_INTR_CTRL_PACER_INT;\n\t} else {\t \n\t\tdevpriv->intr_ctrl |= DAS16M1_INTR_CTRL_PACER_EXT;\n\t}\n\n\t \n\tbyte = 0;\n\t \n\tif (cmd->start_src == TRIG_EXT && cmd->convert_src != TRIG_EXT)\n\t\tbyte |= DAS16M1_CS_EXT_TRIG;\n\n\toutb(byte, dev->iobase + DAS16M1_CS_REG);\n\n\t \n\toutb(0, dev->iobase + DAS16M1_CLR_INTR_REG);\n\n\tdevpriv->intr_ctrl |= DAS16M1_INTR_CTRL_INTE;\n\toutb(devpriv->intr_ctrl, dev->iobase + DAS16M1_INTR_CTRL_REG);\n\n\treturn 0;\n}\n\nstatic int das16m1_ai_cancel(struct comedi_device *dev,\n\t\t\t     struct comedi_subdevice *s)\n{\n\tstruct das16m1_private *devpriv = dev->private;\n\n\t \n\tdevpriv->intr_ctrl &= ~(DAS16M1_INTR_CTRL_INTE |\n\t\t\t\tDAS16M1_INTR_CTRL_PACER_MASK);\n\toutb(devpriv->intr_ctrl, dev->iobase + DAS16M1_INTR_CTRL_REG);\n\n\treturn 0;\n}\n\nstatic int das16m1_ai_eoc(struct comedi_device *dev,\n\t\t\t  struct comedi_subdevice *s,\n\t\t\t  struct comedi_insn *insn,\n\t\t\t  unsigned long context)\n{\n\tunsigned int status;\n\n\tstatus = inb(dev->iobase + DAS16M1_CS_REG);\n\tif (status & DAS16M1_CS_IRQDATA)\n\t\treturn 0;\n\treturn -EBUSY;\n}\n\nstatic int das16m1_ai_insn_read(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tstruct comedi_insn *insn,\n\t\t\t\tunsigned int *data)\n{\n\tint ret;\n\tint i;\n\n\tdas16m1_ai_set_queue(dev, &insn->chanspec, 1);\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\tunsigned short val;\n\n\t\t \n\t\toutb(0, dev->iobase + DAS16M1_CLR_INTR_REG);\n\t\t \n\t\toutb(0, dev->iobase + DAS16M1_AI_REG);\n\n\t\tret = comedi_timeout(dev, s, insn, das16m1_ai_eoc, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tval = inw(dev->iobase + DAS16M1_AI_REG);\n\t\tdata[i] = DAS16M1_AI_TO_SAMPLE(val);\n\t}\n\n\treturn insn->n;\n}\n\nstatic int das16m1_di_insn_bits(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tstruct comedi_insn *insn,\n\t\t\t\tunsigned int *data)\n{\n\tdata[1] = inb(dev->iobase + DAS16M1_DI_REG) & 0xf;\n\n\treturn insn->n;\n}\n\nstatic int das16m1_do_insn_bits(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tstruct comedi_insn *insn,\n\t\t\t\tunsigned int *data)\n{\n\tif (comedi_dio_update_state(s, data))\n\t\toutb(s->state, dev->iobase + DAS16M1_DO_REG);\n\n\tdata[1] = s->state;\n\n\treturn insn->n;\n}\n\nstatic void das16m1_handler(struct comedi_device *dev, unsigned int status)\n{\n\tstruct das16m1_private *devpriv = dev->private;\n\tstruct comedi_subdevice *s = dev->read_subdev;\n\tstruct comedi_async *async = s->async;\n\tstruct comedi_cmd *cmd = &async->cmd;\n\tu16 num_samples;\n\tu16 hw_counter;\n\n\t \n\thw_counter = comedi_8254_read(devpriv->counter, 1);\n\t \n\tif (devpriv->adc_count == 0 &&\n\t    hw_counter == devpriv->initial_hw_count) {\n\t\tnum_samples = 0;\n\t} else {\n\t\t \n\t\tnum_samples = -hw_counter - devpriv->adc_count;\n\t}\n\t \n\tif (cmd->stop_src == TRIG_COUNT) {\n\t\tif (num_samples > cmd->stop_arg * cmd->chanlist_len)\n\t\t\tnum_samples = cmd->stop_arg * cmd->chanlist_len;\n\t}\n\t \n\tif (num_samples > DAS16M1_AI_FIFO_SZ)\n\t\tnum_samples = DAS16M1_AI_FIFO_SZ;\n\tinsw(dev->iobase, devpriv->ai_buffer, num_samples);\n\tcomedi_buf_write_samples(s, devpriv->ai_buffer, num_samples);\n\tdevpriv->adc_count += num_samples;\n\n\tif (cmd->stop_src == TRIG_COUNT) {\n\t\tif (devpriv->adc_count >= cmd->stop_arg * cmd->chanlist_len) {\n\t\t\t \n\t\t\tasync->events |= COMEDI_CB_EOA;\n\t\t}\n\t}\n\n\t \n\tif (status & DAS16M1_CS_OVRUN) {\n\t\tasync->events |= COMEDI_CB_ERROR;\n\t\tdev_err(dev->class_dev, \"fifo overflow\\n\");\n\t}\n\n\tcomedi_handle_events(dev, s);\n}\n\nstatic int das16m1_ai_poll(struct comedi_device *dev,\n\t\t\t   struct comedi_subdevice *s)\n{\n\tunsigned long flags;\n\tunsigned int status;\n\n\t \n\tspin_lock_irqsave(&dev->spinlock, flags);\n\tstatus = inb(dev->iobase + DAS16M1_CS_REG);\n\tdas16m1_handler(dev, status);\n\tspin_unlock_irqrestore(&dev->spinlock, flags);\n\n\treturn comedi_buf_n_bytes_ready(s);\n}\n\nstatic irqreturn_t das16m1_interrupt(int irq, void *d)\n{\n\tint status;\n\tstruct comedi_device *dev = d;\n\n\tif (!dev->attached) {\n\t\tdev_err(dev->class_dev, \"premature interrupt\\n\");\n\t\treturn IRQ_HANDLED;\n\t}\n\t \n\tspin_lock(&dev->spinlock);\n\n\tstatus = inb(dev->iobase + DAS16M1_CS_REG);\n\n\tif ((status & (DAS16M1_CS_IRQDATA | DAS16M1_CS_OVRUN)) == 0) {\n\t\tdev_err(dev->class_dev, \"spurious interrupt\\n\");\n\t\tspin_unlock(&dev->spinlock);\n\t\treturn IRQ_NONE;\n\t}\n\n\tdas16m1_handler(dev, status);\n\n\t \n\toutb(0, dev->iobase + DAS16M1_CLR_INTR_REG);\n\n\tspin_unlock(&dev->spinlock);\n\treturn IRQ_HANDLED;\n}\n\nstatic int das16m1_irq_bits(unsigned int irq)\n{\n\tswitch (irq) {\n\tcase 10:\n\t\treturn 0x0;\n\tcase 11:\n\t\treturn 0x1;\n\tcase 12:\n\t\treturn 0x2;\n\tcase 15:\n\t\treturn 0x3;\n\tcase 2:\n\t\treturn 0x4;\n\tcase 3:\n\t\treturn 0x5;\n\tcase 5:\n\t\treturn 0x6;\n\tcase 7:\n\t\treturn 0x7;\n\tdefault:\n\t\treturn 0x0;\n\t}\n}\n\nstatic int das16m1_attach(struct comedi_device *dev,\n\t\t\t  struct comedi_devconfig *it)\n{\n\tstruct das16m1_private *devpriv;\n\tstruct comedi_subdevice *s;\n\tint ret;\n\n\tdevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\n\tif (!devpriv)\n\t\treturn -ENOMEM;\n\n\tret = comedi_request_region(dev, it->options[0], 0x10);\n\tif (ret)\n\t\treturn ret;\n\t \n\tret = __comedi_request_region(dev, dev->iobase + DAS16M1_8255_IOBASE,\n\t\t\t\t      DAS16M1_SIZE2);\n\tif (ret)\n\t\treturn ret;\n\tdevpriv->extra_iobase = dev->iobase + DAS16M1_8255_IOBASE;\n\n\t \n\tif ((1 << it->options[1]) & 0xdcfc) {\n\t\tret = request_irq(it->options[1], das16m1_interrupt, 0,\n\t\t\t\t  dev->board_name, dev);\n\t\tif (ret == 0)\n\t\t\tdev->irq = it->options[1];\n\t}\n\n\tdev->pacer = comedi_8254_init(dev->iobase + DAS16M1_8254_IOBASE2,\n\t\t\t\t      I8254_OSC_BASE_10MHZ, I8254_IO8, 0);\n\tif (!dev->pacer)\n\t\treturn -ENOMEM;\n\n\tdevpriv->counter = comedi_8254_init(dev->iobase + DAS16M1_8254_IOBASE1,\n\t\t\t\t\t    0, I8254_IO8, 0);\n\tif (!devpriv->counter)\n\t\treturn -ENOMEM;\n\n\tret = comedi_alloc_subdevices(dev, 4);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ts = &dev->subdevices[0];\n\ts->type\t\t= COMEDI_SUBD_AI;\n\ts->subdev_flags\t= SDF_READABLE | SDF_DIFF;\n\ts->n_chan\t= 8;\n\ts->maxdata\t= 0x0fff;\n\ts->range_table\t= &range_das16m1;\n\ts->insn_read\t= das16m1_ai_insn_read;\n\tif (dev->irq) {\n\t\tdev->read_subdev = s;\n\t\ts->subdev_flags\t|= SDF_CMD_READ;\n\t\ts->len_chanlist\t= 256;\n\t\ts->do_cmdtest\t= das16m1_ai_cmdtest;\n\t\ts->do_cmd\t= das16m1_ai_cmd;\n\t\ts->cancel\t= das16m1_ai_cancel;\n\t\ts->poll\t\t= das16m1_ai_poll;\n\t\ts->munge\t= das16m1_ai_munge;\n\t}\n\n\t \n\ts = &dev->subdevices[1];\n\ts->type\t\t= COMEDI_SUBD_DI;\n\ts->subdev_flags\t= SDF_READABLE;\n\ts->n_chan\t= 4;\n\ts->maxdata\t= 1;\n\ts->range_table\t= &range_digital;\n\ts->insn_bits\t= das16m1_di_insn_bits;\n\n\t \n\ts = &dev->subdevices[2];\n\ts->type\t\t= COMEDI_SUBD_DO;\n\ts->subdev_flags\t= SDF_WRITABLE;\n\ts->n_chan\t= 4;\n\ts->maxdata\t= 1;\n\ts->range_table\t= &range_digital;\n\ts->insn_bits\t= das16m1_do_insn_bits;\n\n\t \n\ts = &dev->subdevices[3];\n\tret = subdev_8255_init(dev, s, NULL, DAS16M1_8255_IOBASE);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\toutb(0, dev->iobase + DAS16M1_DO_REG);\n\n\t \n\tdevpriv->intr_ctrl = DAS16M1_INTR_CTRL_IRQ(das16m1_irq_bits(dev->irq));\n\toutb(devpriv->intr_ctrl, dev->iobase + DAS16M1_INTR_CTRL_REG);\n\n\treturn 0;\n}\n\nstatic void das16m1_detach(struct comedi_device *dev)\n{\n\tstruct das16m1_private *devpriv = dev->private;\n\n\tif (devpriv) {\n\t\tif (devpriv->extra_iobase)\n\t\t\trelease_region(devpriv->extra_iobase, DAS16M1_SIZE2);\n\t\tkfree(devpriv->counter);\n\t}\n\tcomedi_legacy_detach(dev);\n}\n\nstatic struct comedi_driver das16m1_driver = {\n\t.driver_name\t= \"das16m1\",\n\t.module\t\t= THIS_MODULE,\n\t.attach\t\t= das16m1_attach,\n\t.detach\t\t= das16m1_detach,\n};\nmodule_comedi_driver(das16m1_driver);\n\nMODULE_AUTHOR(\"Comedi https://www.comedi.org\");\nMODULE_DESCRIPTION(\"Comedi driver for CIO-DAS16/M1 ISA cards\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}