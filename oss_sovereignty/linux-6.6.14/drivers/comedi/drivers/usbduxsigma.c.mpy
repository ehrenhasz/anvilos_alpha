{
  "module_name": "usbduxsigma.c",
  "hash_id": "db37c7836dfcac2b02f369931414d0d05e610ec4572d96363a64e40673c937ba",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/usbduxsigma.c",
  "human_readable_source": "\n \n\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/input.h>\n#include <linux/fcntl.h>\n#include <linux/compiler.h>\n#include <asm/unaligned.h>\n#include <linux/comedi/comedi_usb.h>\n\n \n#define BULK_TIMEOUT 1000\n\n \n#define FIRMWARE\t\t\"usbduxsigma_firmware.bin\"\n#define FIRMWARE_MAX_LEN\t0x4000\n#define USBDUXSUB_FIRMWARE\t0xa0\n#define VENDOR_DIR_IN\t\t0xc0\n#define VENDOR_DIR_OUT\t\t0x40\n\n \n#define USBDUXSUB_CPUCS 0xE600\n\n \n#define MIN_PWM_PERIOD  ((long)(1E9 / 300))\n\n \n#define PWM_DEFAULT_PERIOD ((long)(1E9 / 100))\n\n \n#define NUMCHANNELS 16\n\n \n#define SIZEADIN          ((sizeof(u32)))\n\n \n#define SIZEINBUF         (((NUMCHANNELS + 1) * SIZEADIN))\n\n \n#define SIZEINSNBUF       16\n\n \n#define NUMOUTCHANNELS    8\n\n \n#define SIZEDAOUT          ((sizeof(u8) + sizeof(uint16_t)))\n\n \n#define SIZEOUTBUF         ((8 * SIZEDAOUT))\n\n \n#define SIZEOFDUXBUFFER    ((8 * SIZEDAOUT + 2))\n\n \n#define NUMOFINBUFFERSFULL     5\n\n \n#define NUMOFOUTBUFFERSFULL    5\n\n \n \n#define NUMOFINBUFFERSHIGH     10\n\n \n \n#define NUMOFOUTBUFFERSHIGH    10\n\n \n#define RETRIES 10\n\n \n#define USBBUXSIGMA_AD_CMD\t\t9\n#define USBDUXSIGMA_DA_CMD\t\t1\n#define USBDUXSIGMA_DIO_CFG_CMD\t\t2\n#define USBDUXSIGMA_DIO_BITS_CMD\t3\n#define USBDUXSIGMA_SINGLE_AD_CMD\t4\n#define USBDUXSIGMA_PWM_ON_CMD\t\t7\n#define USBDUXSIGMA_PWM_OFF_CMD\t\t8\n\nstatic const struct comedi_lrange usbduxsigma_ai_range = {\n\t1, {\n\t\tBIP_RANGE(2.5 * 0x800000 / 0x780000 / 2.0)\n\t}\n};\n\nstruct usbduxsigma_private {\n\t \n\tint n_ai_urbs;\n\t \n\tint n_ao_urbs;\n\t \n\tstruct urb **ai_urbs;\n\tstruct urb **ao_urbs;\n\t \n\tstruct urb *pwm_urb;\n\t \n\tunsigned int pwm_period;\n\t \n\tu8 pwm_delay;\n\t \n\tint pwm_buf_sz;\n\t \n\t__be32 *in_buf;\n\t \n\tu8 *insn_buf;\n\n\tunsigned high_speed:1;\n\tunsigned ai_cmd_running:1;\n\tunsigned ao_cmd_running:1;\n\tunsigned pwm_cmd_running:1;\n\n\t \n\tunsigned int ai_timer;\n\tunsigned int ao_timer;\n\t \n\tunsigned int ai_counter;\n\tunsigned int ao_counter;\n\t \n\tunsigned int ai_interval;\n\t \n\tu8 *dux_commands;\n\tstruct mutex mut;\n};\n\nstatic void usbduxsigma_unlink_urbs(struct urb **urbs, int num_urbs)\n{\n\tint i;\n\n\tfor (i = 0; i < num_urbs; i++)\n\t\tusb_kill_urb(urbs[i]);\n}\n\nstatic void usbduxsigma_ai_stop(struct comedi_device *dev, int do_unlink)\n{\n\tstruct usbduxsigma_private *devpriv = dev->private;\n\n\tif (do_unlink && devpriv->ai_urbs)\n\t\tusbduxsigma_unlink_urbs(devpriv->ai_urbs, devpriv->n_ai_urbs);\n\n\tdevpriv->ai_cmd_running = 0;\n}\n\nstatic int usbduxsigma_ai_cancel(struct comedi_device *dev,\n\t\t\t\t struct comedi_subdevice *s)\n{\n\tstruct usbduxsigma_private *devpriv = dev->private;\n\n\tmutex_lock(&devpriv->mut);\n\t \n\tusbduxsigma_ai_stop(dev, devpriv->ai_cmd_running);\n\tmutex_unlock(&devpriv->mut);\n\n\treturn 0;\n}\n\nstatic void usbduxsigma_ai_handle_urb(struct comedi_device *dev,\n\t\t\t\t      struct comedi_subdevice *s,\n\t\t\t\t      struct urb *urb)\n{\n\tstruct usbduxsigma_private *devpriv = dev->private;\n\tstruct comedi_async *async = s->async;\n\tstruct comedi_cmd *cmd = &async->cmd;\n\tu32 val;\n\tint ret;\n\tint i;\n\n\tif ((urb->actual_length > 0) && (urb->status != -EXDEV)) {\n\t\tdevpriv->ai_counter--;\n\t\tif (devpriv->ai_counter == 0) {\n\t\t\tdevpriv->ai_counter = devpriv->ai_timer;\n\n\t\t\t \n\t\t\tfor (i = 0; i < cmd->chanlist_len; i++) {\n\t\t\t\tval = be32_to_cpu(devpriv->in_buf[i + 1]);\n\t\t\t\tval &= 0x00ffffff;  \n\t\t\t\tval = comedi_offset_munge(s, val);\n\t\t\t\tif (!comedi_buf_write_samples(s, &val, 1))\n\t\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (cmd->stop_src == TRIG_COUNT &&\n\t\t\t    async->scans_done >= cmd->stop_arg)\n\t\t\t\tasync->events |= COMEDI_CB_EOA;\n\t\t}\n\t}\n\n\t \n\tif (!(async->events & COMEDI_CB_CANCEL_MASK)) {\n\t\turb->dev = comedi_to_usb_dev(dev);\n\t\tret = usb_submit_urb(urb, GFP_ATOMIC);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev->class_dev, \"urb resubmit failed (%d)\\n\",\n\t\t\t\tret);\n\t\t\tif (ret == -EL2NSYNC)\n\t\t\t\tdev_err(dev->class_dev,\n\t\t\t\t\t\"buggy USB host controller or bug in IRQ handler\\n\");\n\t\t\tasync->events |= COMEDI_CB_ERROR;\n\t\t}\n\t}\n}\n\nstatic void usbduxsigma_ai_urb_complete(struct urb *urb)\n{\n\tstruct comedi_device *dev = urb->context;\n\tstruct usbduxsigma_private *devpriv = dev->private;\n\tstruct comedi_subdevice *s = dev->read_subdev;\n\tstruct comedi_async *async = s->async;\n\n\t \n\tif (!devpriv->ai_cmd_running)\n\t\treturn;\n\n\tswitch (urb->status) {\n\tcase 0:\n\t\t \n\t\tmemcpy(devpriv->in_buf, urb->transfer_buffer, SIZEINBUF);\n\t\tusbduxsigma_ai_handle_urb(dev, s, urb);\n\t\tbreak;\n\n\tcase -EILSEQ:\n\t\t \n\t\tdev_dbg(dev->class_dev, \"CRC error in ISO IN stream\\n\");\n\t\tusbduxsigma_ai_handle_urb(dev, s, urb);\n\t\tbreak;\n\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\tcase -ECONNABORTED:\n\t\t \n\t\tasync->events |= COMEDI_CB_ERROR;\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tdev_err(dev->class_dev, \"non-zero urb status (%d)\\n\",\n\t\t\turb->status);\n\t\tasync->events |= COMEDI_CB_ERROR;\n\t\tbreak;\n\t}\n\n\t \n\tif (async->events & COMEDI_CB_CANCEL_MASK)\n\t\tusbduxsigma_ai_stop(dev, 0);\n\n\tcomedi_event(dev, s);\n}\n\nstatic void usbduxsigma_ao_stop(struct comedi_device *dev, int do_unlink)\n{\n\tstruct usbduxsigma_private *devpriv = dev->private;\n\n\tif (do_unlink && devpriv->ao_urbs)\n\t\tusbduxsigma_unlink_urbs(devpriv->ao_urbs, devpriv->n_ao_urbs);\n\n\tdevpriv->ao_cmd_running = 0;\n}\n\nstatic int usbduxsigma_ao_cancel(struct comedi_device *dev,\n\t\t\t\t struct comedi_subdevice *s)\n{\n\tstruct usbduxsigma_private *devpriv = dev->private;\n\n\tmutex_lock(&devpriv->mut);\n\t \n\tusbduxsigma_ao_stop(dev, devpriv->ao_cmd_running);\n\tmutex_unlock(&devpriv->mut);\n\n\treturn 0;\n}\n\nstatic void usbduxsigma_ao_handle_urb(struct comedi_device *dev,\n\t\t\t\t      struct comedi_subdevice *s,\n\t\t\t\t      struct urb *urb)\n{\n\tstruct usbduxsigma_private *devpriv = dev->private;\n\tstruct comedi_async *async = s->async;\n\tstruct comedi_cmd *cmd = &async->cmd;\n\tu8 *datap;\n\tint ret;\n\tint i;\n\n\tdevpriv->ao_counter--;\n\tif (devpriv->ao_counter == 0) {\n\t\tdevpriv->ao_counter = devpriv->ao_timer;\n\n\t\tif (cmd->stop_src == TRIG_COUNT &&\n\t\t    async->scans_done >= cmd->stop_arg) {\n\t\t\tasync->events |= COMEDI_CB_EOA;\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tdatap = urb->transfer_buffer;\n\t\t*datap++ = cmd->chanlist_len;\n\t\tfor (i = 0; i < cmd->chanlist_len; i++) {\n\t\t\tunsigned int chan = CR_CHAN(cmd->chanlist[i]);\n\t\t\tunsigned short val;\n\n\t\t\tif (!comedi_buf_read_samples(s, &val, 1)) {\n\t\t\t\tdev_err(dev->class_dev, \"buffer underflow\\n\");\n\t\t\t\tasync->events |= COMEDI_CB_OVERFLOW;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t*datap++ = val;\n\t\t\t*datap++ = chan;\n\t\t\ts->readback[chan] = val;\n\t\t}\n\t}\n\n\t \n\tif (!(async->events & COMEDI_CB_CANCEL_MASK)) {\n\t\turb->transfer_buffer_length = SIZEOUTBUF;\n\t\turb->dev = comedi_to_usb_dev(dev);\n\t\turb->status = 0;\n\t\turb->interval = 1;\t \n\t\turb->number_of_packets = 1;\n\t\turb->iso_frame_desc[0].offset = 0;\n\t\turb->iso_frame_desc[0].length = SIZEOUTBUF;\n\t\turb->iso_frame_desc[0].status = 0;\n\t\tret = usb_submit_urb(urb, GFP_ATOMIC);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev->class_dev, \"urb resubmit failed (%d)\\n\",\n\t\t\t\tret);\n\t\t\tif (ret == -EL2NSYNC)\n\t\t\t\tdev_err(dev->class_dev,\n\t\t\t\t\t\"buggy USB host controller or bug in IRQ handler\\n\");\n\t\t\tasync->events |= COMEDI_CB_ERROR;\n\t\t}\n\t}\n}\n\nstatic void usbduxsigma_ao_urb_complete(struct urb *urb)\n{\n\tstruct comedi_device *dev = urb->context;\n\tstruct usbduxsigma_private *devpriv = dev->private;\n\tstruct comedi_subdevice *s = dev->write_subdev;\n\tstruct comedi_async *async = s->async;\n\n\t \n\tif (!devpriv->ao_cmd_running)\n\t\treturn;\n\n\tswitch (urb->status) {\n\tcase 0:\n\t\tusbduxsigma_ao_handle_urb(dev, s, urb);\n\t\tbreak;\n\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\tcase -ECONNABORTED:\n\t\t \n\t\tasync->events |= COMEDI_CB_ERROR;\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tdev_err(dev->class_dev, \"non-zero urb status (%d)\\n\",\n\t\t\turb->status);\n\t\tasync->events |= COMEDI_CB_ERROR;\n\t\tbreak;\n\t}\n\n\t \n\tif (async->events & COMEDI_CB_CANCEL_MASK)\n\t\tusbduxsigma_ao_stop(dev, 0);\n\n\tcomedi_event(dev, s);\n}\n\nstatic int usbduxsigma_submit_urbs(struct comedi_device *dev,\n\t\t\t\t   struct urb **urbs, int num_urbs,\n\t\t\t\t   int input_urb)\n{\n\tstruct usb_device *usb = comedi_to_usb_dev(dev);\n\tstruct urb *urb;\n\tint ret;\n\tint i;\n\n\t \n\tfor (i = 0; i < num_urbs; i++) {\n\t\turb = urbs[i];\n\n\t\t \n\t\tif (input_urb)\n\t\t\turb->interval = 1;\n\t\turb->context = dev;\n\t\turb->dev = usb;\n\t\turb->status = 0;\n\t\turb->transfer_flags = URB_ISO_ASAP;\n\n\t\tret = usb_submit_urb(urb, GFP_ATOMIC);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int usbduxsigma_chans_to_interval(int num_chan)\n{\n\tif (num_chan <= 2)\n\t\treturn 2;\t \n\tif (num_chan <= 8)\n\t\treturn 4;\t \n\treturn 8;\t\t \n}\n\nstatic int usbduxsigma_ai_cmdtest(struct comedi_device *dev,\n\t\t\t\t  struct comedi_subdevice *s,\n\t\t\t\t  struct comedi_cmd *cmd)\n{\n\tstruct usbduxsigma_private *devpriv = dev->private;\n\tint high_speed = devpriv->high_speed;\n\tint interval = usbduxsigma_chans_to_interval(cmd->chanlist_len);\n\tunsigned int tmp;\n\tint err = 0;\n\n\t \n\n\terr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_INT);\n\terr |= comedi_check_trigger_src(&cmd->scan_begin_src, TRIG_TIMER);\n\terr |= comedi_check_trigger_src(&cmd->convert_src, TRIG_NOW);\n\terr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\n\terr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\n\n\tif (err)\n\t\treturn 1;\n\n\t \n\n\terr |= comedi_check_trigger_is_unique(cmd->start_src);\n\terr |= comedi_check_trigger_is_unique(cmd->stop_src);\n\n\t \n\n\tif (err)\n\t\treturn 2;\n\n\t \n\n\terr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\n\n\tif (high_speed) {\n\t\t \n\t\terr |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,\n\t\t\t\t\t\t    (125000 * interval));\n\t} else {\n\t\t \n\t\t \n\t\terr |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,\n\t\t\t\t\t\t    1000000);\n\t}\n\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\n\t\t\t\t\t   cmd->chanlist_len);\n\n\tif (cmd->stop_src == TRIG_COUNT)\n\t\terr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\n\telse\t \n\t\terr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\n\n\tif (err)\n\t\treturn 3;\n\n\t \n\n\ttmp = rounddown(cmd->scan_begin_arg, high_speed ? 125000 : 1000000);\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, tmp);\n\n\tif (err)\n\t\treturn 4;\n\n\treturn 0;\n}\n\n \nstatic void create_adc_command(unsigned int chan,\n\t\t\t       u8 *muxsg0, u8 *muxsg1)\n{\n\tif (chan < 8)\n\t\t(*muxsg0) = (*muxsg0) | (1 << chan);\n\telse if (chan < 16)\n\t\t(*muxsg1) = (*muxsg1) | (1 << (chan - 8));\n}\n\nstatic int usbbuxsigma_send_cmd(struct comedi_device *dev, int cmd_type)\n{\n\tstruct usb_device *usb = comedi_to_usb_dev(dev);\n\tstruct usbduxsigma_private *devpriv = dev->private;\n\tint nsent;\n\n\tdevpriv->dux_commands[0] = cmd_type;\n\n\treturn usb_bulk_msg(usb, usb_sndbulkpipe(usb, 1),\n\t\t\t    devpriv->dux_commands, SIZEOFDUXBUFFER,\n\t\t\t    &nsent, BULK_TIMEOUT);\n}\n\nstatic int usbduxsigma_receive_cmd(struct comedi_device *dev, int command)\n{\n\tstruct usb_device *usb = comedi_to_usb_dev(dev);\n\tstruct usbduxsigma_private *devpriv = dev->private;\n\tint nrec;\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < RETRIES; i++) {\n\t\tret = usb_bulk_msg(usb, usb_rcvbulkpipe(usb, 8),\n\t\t\t\t   devpriv->insn_buf, SIZEINSNBUF,\n\t\t\t\t   &nrec, BULK_TIMEOUT);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (devpriv->insn_buf[0] == command)\n\t\t\treturn 0;\n\t}\n\t \n\treturn -EFAULT;\n}\n\nstatic int usbduxsigma_ai_inttrig(struct comedi_device *dev,\n\t\t\t\t  struct comedi_subdevice *s,\n\t\t\t\t  unsigned int trig_num)\n{\n\tstruct usbduxsigma_private *devpriv = dev->private;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tint ret;\n\n\tif (trig_num != cmd->start_arg)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&devpriv->mut);\n\tif (!devpriv->ai_cmd_running) {\n\t\tdevpriv->ai_cmd_running = 1;\n\t\tret = usbduxsigma_submit_urbs(dev, devpriv->ai_urbs,\n\t\t\t\t\t      devpriv->n_ai_urbs, 1);\n\t\tif (ret < 0) {\n\t\t\tdevpriv->ai_cmd_running = 0;\n\t\t\tmutex_unlock(&devpriv->mut);\n\t\t\treturn ret;\n\t\t}\n\t\ts->async->inttrig = NULL;\n\t}\n\tmutex_unlock(&devpriv->mut);\n\n\treturn 1;\n}\n\nstatic int usbduxsigma_ai_cmd(struct comedi_device *dev,\n\t\t\t      struct comedi_subdevice *s)\n{\n\tstruct usbduxsigma_private *devpriv = dev->private;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tunsigned int len = cmd->chanlist_len;\n\tu8 muxsg0 = 0;\n\tu8 muxsg1 = 0;\n\tu8 sysred = 0;\n\tint ret;\n\tint i;\n\n\tmutex_lock(&devpriv->mut);\n\n\tif (devpriv->high_speed) {\n\t\t \n\t\tunsigned int interval = usbduxsigma_chans_to_interval(len);\n\n\t\tdevpriv->ai_interval = interval;\n\t\tdevpriv->ai_timer = cmd->scan_begin_arg / (125000 * interval);\n\t} else {\n\t\t \n\t\tdevpriv->ai_interval = 1;\n\t\tdevpriv->ai_timer = cmd->scan_begin_arg / 1000000;\n\t}\n\n\tfor (i = 0; i < len; i++) {\n\t\tunsigned int chan  = CR_CHAN(cmd->chanlist[i]);\n\n\t\tcreate_adc_command(chan, &muxsg0, &muxsg1);\n\t}\n\n\tdevpriv->dux_commands[1] = devpriv->ai_interval;\n\tdevpriv->dux_commands[2] = len;   \n\tdevpriv->dux_commands[3] = 0x12;  \n\tdevpriv->dux_commands[4] = 0x03;  \n\tdevpriv->dux_commands[5] = 0x00;  \n\tdevpriv->dux_commands[6] = muxsg0;\n\tdevpriv->dux_commands[7] = muxsg1;\n\tdevpriv->dux_commands[8] = sysred;\n\n\tret = usbbuxsigma_send_cmd(dev, USBBUXSIGMA_AD_CMD);\n\tif (ret < 0) {\n\t\tmutex_unlock(&devpriv->mut);\n\t\treturn ret;\n\t}\n\n\tdevpriv->ai_counter = devpriv->ai_timer;\n\n\tif (cmd->start_src == TRIG_NOW) {\n\t\t \n\t\tdevpriv->ai_cmd_running = 1;\n\t\tret = usbduxsigma_submit_urbs(dev, devpriv->ai_urbs,\n\t\t\t\t\t      devpriv->n_ai_urbs, 1);\n\t\tif (ret < 0) {\n\t\t\tdevpriv->ai_cmd_running = 0;\n\t\t\tmutex_unlock(&devpriv->mut);\n\t\t\treturn ret;\n\t\t}\n\t\ts->async->inttrig = NULL;\n\t} else {\t \n\t\ts->async->inttrig = usbduxsigma_ai_inttrig;\n\t}\n\n\tmutex_unlock(&devpriv->mut);\n\n\treturn 0;\n}\n\nstatic int usbduxsigma_ai_insn_read(struct comedi_device *dev,\n\t\t\t\t    struct comedi_subdevice *s,\n\t\t\t\t    struct comedi_insn *insn,\n\t\t\t\t    unsigned int *data)\n{\n\tstruct usbduxsigma_private *devpriv = dev->private;\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tu8 muxsg0 = 0;\n\tu8 muxsg1 = 0;\n\tu8 sysred = 0;\n\tint ret;\n\tint i;\n\n\tmutex_lock(&devpriv->mut);\n\tif (devpriv->ai_cmd_running) {\n\t\tmutex_unlock(&devpriv->mut);\n\t\treturn -EBUSY;\n\t}\n\n\tcreate_adc_command(chan, &muxsg0, &muxsg1);\n\n\t \n\tdevpriv->dux_commands[1] = 0x16;  \n\tdevpriv->dux_commands[2] = 0x80;  \n\tdevpriv->dux_commands[3] = 0x00;  \n\tdevpriv->dux_commands[4] = muxsg0;\n\tdevpriv->dux_commands[5] = muxsg1;\n\tdevpriv->dux_commands[6] = sysred;\n\n\t \n\tret = usbbuxsigma_send_cmd(dev, USBDUXSIGMA_SINGLE_AD_CMD);\n\tif (ret < 0) {\n\t\tmutex_unlock(&devpriv->mut);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\tu32 val;\n\n\t\tret = usbduxsigma_receive_cmd(dev, USBDUXSIGMA_SINGLE_AD_CMD);\n\t\tif (ret < 0) {\n\t\t\tmutex_unlock(&devpriv->mut);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tval = be32_to_cpu(get_unaligned((__be32\n\t\t\t\t\t\t *)(devpriv->insn_buf + 1)));\n\t\tval &= 0x00ffffff;\t \n\t\tdata[i] = comedi_offset_munge(s, val);\n\t}\n\tmutex_unlock(&devpriv->mut);\n\n\treturn insn->n;\n}\n\nstatic int usbduxsigma_ao_insn_read(struct comedi_device *dev,\n\t\t\t\t    struct comedi_subdevice *s,\n\t\t\t\t    struct comedi_insn *insn,\n\t\t\t\t    unsigned int *data)\n{\n\tstruct usbduxsigma_private *devpriv = dev->private;\n\tint ret;\n\n\tmutex_lock(&devpriv->mut);\n\tret = comedi_readback_insn_read(dev, s, insn, data);\n\tmutex_unlock(&devpriv->mut);\n\n\treturn ret;\n}\n\nstatic int usbduxsigma_ao_insn_write(struct comedi_device *dev,\n\t\t\t\t     struct comedi_subdevice *s,\n\t\t\t\t     struct comedi_insn *insn,\n\t\t\t\t     unsigned int *data)\n{\n\tstruct usbduxsigma_private *devpriv = dev->private;\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tint ret;\n\tint i;\n\n\tmutex_lock(&devpriv->mut);\n\tif (devpriv->ao_cmd_running) {\n\t\tmutex_unlock(&devpriv->mut);\n\t\treturn -EBUSY;\n\t}\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\tdevpriv->dux_commands[1] = 1;\t\t \n\t\tdevpriv->dux_commands[2] = data[i];\t \n\t\tdevpriv->dux_commands[3] = chan;\t \n\t\tret = usbbuxsigma_send_cmd(dev, USBDUXSIGMA_DA_CMD);\n\t\tif (ret < 0) {\n\t\t\tmutex_unlock(&devpriv->mut);\n\t\t\treturn ret;\n\t\t}\n\t\ts->readback[chan] = data[i];\n\t}\n\tmutex_unlock(&devpriv->mut);\n\n\treturn insn->n;\n}\n\nstatic int usbduxsigma_ao_inttrig(struct comedi_device *dev,\n\t\t\t\t  struct comedi_subdevice *s,\n\t\t\t\t  unsigned int trig_num)\n{\n\tstruct usbduxsigma_private *devpriv = dev->private;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tint ret;\n\n\tif (trig_num != cmd->start_arg)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&devpriv->mut);\n\tif (!devpriv->ao_cmd_running) {\n\t\tdevpriv->ao_cmd_running = 1;\n\t\tret = usbduxsigma_submit_urbs(dev, devpriv->ao_urbs,\n\t\t\t\t\t      devpriv->n_ao_urbs, 0);\n\t\tif (ret < 0) {\n\t\t\tdevpriv->ao_cmd_running = 0;\n\t\t\tmutex_unlock(&devpriv->mut);\n\t\t\treturn ret;\n\t\t}\n\t\ts->async->inttrig = NULL;\n\t}\n\tmutex_unlock(&devpriv->mut);\n\n\treturn 1;\n}\n\nstatic int usbduxsigma_ao_cmdtest(struct comedi_device *dev,\n\t\t\t\t  struct comedi_subdevice *s,\n\t\t\t\t  struct comedi_cmd *cmd)\n{\n\tstruct usbduxsigma_private *devpriv = dev->private;\n\tunsigned int tmp;\n\tint err = 0;\n\n\t \n\n\terr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_INT);\n\n\t \n\terr |= comedi_check_trigger_src(&cmd->scan_begin_src, TRIG_TIMER);\n\terr |= comedi_check_trigger_src(&cmd->convert_src, TRIG_NOW);\n\terr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\n\terr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\n\n\tif (err) {\n\t\tmutex_unlock(&devpriv->mut);\n\t\treturn 1;\n\t}\n\n\t \n\n\terr |= comedi_check_trigger_is_unique(cmd->start_src);\n\terr |= comedi_check_trigger_is_unique(cmd->stop_src);\n\n\t \n\n\tif (err)\n\t\treturn 2;\n\n\t \n\n\terr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\n\n\terr |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg, 1000000);\n\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\n\t\t\t\t\t   cmd->chanlist_len);\n\n\tif (cmd->stop_src == TRIG_COUNT)\n\t\terr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\n\telse\t \n\t\terr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\n\n\tif (err)\n\t\treturn 3;\n\n\t \n\n\ttmp = rounddown(cmd->scan_begin_arg, 1000000);\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, tmp);\n\n\tif (err)\n\t\treturn 4;\n\n\treturn 0;\n}\n\nstatic int usbduxsigma_ao_cmd(struct comedi_device *dev,\n\t\t\t      struct comedi_subdevice *s)\n{\n\tstruct usbduxsigma_private *devpriv = dev->private;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tint ret;\n\n\tmutex_lock(&devpriv->mut);\n\n\t \n\tdevpriv->ao_timer = cmd->scan_begin_arg / 1000000;\n\n\tdevpriv->ao_counter = devpriv->ao_timer;\n\n\tif (cmd->start_src == TRIG_NOW) {\n\t\t \n\t\tdevpriv->ao_cmd_running = 1;\n\t\tret = usbduxsigma_submit_urbs(dev, devpriv->ao_urbs,\n\t\t\t\t\t      devpriv->n_ao_urbs, 0);\n\t\tif (ret < 0) {\n\t\t\tdevpriv->ao_cmd_running = 0;\n\t\t\tmutex_unlock(&devpriv->mut);\n\t\t\treturn ret;\n\t\t}\n\t\ts->async->inttrig = NULL;\n\t} else {\t \n\t\ts->async->inttrig = usbduxsigma_ao_inttrig;\n\t}\n\n\tmutex_unlock(&devpriv->mut);\n\n\treturn 0;\n}\n\nstatic int usbduxsigma_dio_insn_config(struct comedi_device *dev,\n\t\t\t\t       struct comedi_subdevice *s,\n\t\t\t\t       struct comedi_insn *insn,\n\t\t\t\t       unsigned int *data)\n{\n\tint ret;\n\n\tret = comedi_dio_insn_config(dev, s, insn, data, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn insn->n;\n}\n\nstatic int usbduxsigma_dio_insn_bits(struct comedi_device *dev,\n\t\t\t\t     struct comedi_subdevice *s,\n\t\t\t\t     struct comedi_insn *insn,\n\t\t\t\t     unsigned int *data)\n{\n\tstruct usbduxsigma_private *devpriv = dev->private;\n\tint ret;\n\n\tmutex_lock(&devpriv->mut);\n\n\tcomedi_dio_update_state(s, data);\n\n\t \n\tdevpriv->dux_commands[1] = s->io_bits & 0xff;\n\tdevpriv->dux_commands[4] = s->state & 0xff;\n\tdevpriv->dux_commands[2] = (s->io_bits >> 8) & 0xff;\n\tdevpriv->dux_commands[5] = (s->state >> 8) & 0xff;\n\tdevpriv->dux_commands[3] = (s->io_bits >> 16) & 0xff;\n\tdevpriv->dux_commands[6] = (s->state >> 16) & 0xff;\n\n\tret = usbbuxsigma_send_cmd(dev, USBDUXSIGMA_DIO_BITS_CMD);\n\tif (ret < 0)\n\t\tgoto done;\n\tret = usbduxsigma_receive_cmd(dev, USBDUXSIGMA_DIO_BITS_CMD);\n\tif (ret < 0)\n\t\tgoto done;\n\n\ts->state = devpriv->insn_buf[1] |\n\t\t   (devpriv->insn_buf[2] << 8) |\n\t\t   (devpriv->insn_buf[3] << 16);\n\n\tdata[1] = s->state;\n\tret = insn->n;\n\ndone:\n\tmutex_unlock(&devpriv->mut);\n\n\treturn ret;\n}\n\nstatic void usbduxsigma_pwm_stop(struct comedi_device *dev, int do_unlink)\n{\n\tstruct usbduxsigma_private *devpriv = dev->private;\n\n\tif (do_unlink) {\n\t\tif (devpriv->pwm_urb)\n\t\t\tusb_kill_urb(devpriv->pwm_urb);\n\t}\n\n\tdevpriv->pwm_cmd_running = 0;\n}\n\nstatic int usbduxsigma_pwm_cancel(struct comedi_device *dev,\n\t\t\t\t  struct comedi_subdevice *s)\n{\n\tstruct usbduxsigma_private *devpriv = dev->private;\n\n\t \n\tusbduxsigma_pwm_stop(dev, devpriv->pwm_cmd_running);\n\n\treturn usbbuxsigma_send_cmd(dev, USBDUXSIGMA_PWM_OFF_CMD);\n}\n\nstatic void usbduxsigma_pwm_urb_complete(struct urb *urb)\n{\n\tstruct comedi_device *dev = urb->context;\n\tstruct usbduxsigma_private *devpriv = dev->private;\n\tint ret;\n\n\tswitch (urb->status) {\n\tcase 0:\n\t\t \n\t\tbreak;\n\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\tcase -ECONNABORTED:\n\t\t \n\t\tif (devpriv->pwm_cmd_running)\n\t\t\tusbduxsigma_pwm_stop(dev, 0);\t \n\t\treturn;\n\n\tdefault:\n\t\t \n\t\tif (devpriv->pwm_cmd_running) {\n\t\t\tdev_err(dev->class_dev, \"non-zero urb status (%d)\\n\",\n\t\t\t\turb->status);\n\t\t\tusbduxsigma_pwm_stop(dev, 0);\t \n\t\t}\n\t\treturn;\n\t}\n\n\tif (!devpriv->pwm_cmd_running)\n\t\treturn;\n\n\turb->transfer_buffer_length = devpriv->pwm_buf_sz;\n\turb->dev = comedi_to_usb_dev(dev);\n\turb->status = 0;\n\tret = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (ret < 0) {\n\t\tdev_err(dev->class_dev, \"urb resubmit failed (%d)\\n\", ret);\n\t\tif (ret == -EL2NSYNC)\n\t\t\tdev_err(dev->class_dev,\n\t\t\t\t\"buggy USB host controller or bug in IRQ handler\\n\");\n\t\tusbduxsigma_pwm_stop(dev, 0);\t \n\t}\n}\n\nstatic int usbduxsigma_submit_pwm_urb(struct comedi_device *dev)\n{\n\tstruct usb_device *usb = comedi_to_usb_dev(dev);\n\tstruct usbduxsigma_private *devpriv = dev->private;\n\tstruct urb *urb = devpriv->pwm_urb;\n\n\t \n\tusb_fill_bulk_urb(urb, usb, usb_sndbulkpipe(usb, 4),\n\t\t\t  urb->transfer_buffer, devpriv->pwm_buf_sz,\n\t\t\t  usbduxsigma_pwm_urb_complete, dev);\n\n\treturn usb_submit_urb(urb, GFP_ATOMIC);\n}\n\nstatic int usbduxsigma_pwm_period(struct comedi_device *dev,\n\t\t\t\t  struct comedi_subdevice *s,\n\t\t\t\t  unsigned int period)\n{\n\tstruct usbduxsigma_private *devpriv = dev->private;\n\tint fx2delay;\n\n\tif (period < MIN_PWM_PERIOD)\n\t\treturn -EAGAIN;\n\n\tfx2delay = (period / (6 * 512 * 1000 / 33)) - 6;\n\tif (fx2delay > 255)\n\t\treturn -EAGAIN;\n\n\tdevpriv->pwm_delay = fx2delay;\n\tdevpriv->pwm_period = period;\n\treturn 0;\n}\n\nstatic int usbduxsigma_pwm_start(struct comedi_device *dev,\n\t\t\t\t struct comedi_subdevice *s)\n{\n\tstruct usbduxsigma_private *devpriv = dev->private;\n\tint ret;\n\n\tif (devpriv->pwm_cmd_running)\n\t\treturn 0;\n\n\tdevpriv->dux_commands[1] = devpriv->pwm_delay;\n\tret = usbbuxsigma_send_cmd(dev, USBDUXSIGMA_PWM_ON_CMD);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmemset(devpriv->pwm_urb->transfer_buffer, 0, devpriv->pwm_buf_sz);\n\n\tdevpriv->pwm_cmd_running = 1;\n\tret = usbduxsigma_submit_pwm_urb(dev);\n\tif (ret < 0) {\n\t\tdevpriv->pwm_cmd_running = 0;\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void usbduxsigma_pwm_pattern(struct comedi_device *dev,\n\t\t\t\t    struct comedi_subdevice *s,\n\t\t\t\t    unsigned int chan,\n\t\t\t\t    unsigned int value,\n\t\t\t\t    unsigned int sign)\n{\n\tstruct usbduxsigma_private *devpriv = dev->private;\n\tchar pwm_mask = (1 << chan);\t \n\tchar sgn_mask = (16 << chan);\t \n\tchar *buf = (char *)(devpriv->pwm_urb->transfer_buffer);\n\tint szbuf = devpriv->pwm_buf_sz;\n\tint i;\n\n\tfor (i = 0; i < szbuf; i++) {\n\t\tchar c = *buf;\n\n\t\tc &= ~pwm_mask;\n\t\tif (i < value)\n\t\t\tc |= pwm_mask;\n\t\tif (!sign)\n\t\t\tc &= ~sgn_mask;\n\t\telse\n\t\t\tc |= sgn_mask;\n\t\t*buf++ = c;\n\t}\n}\n\nstatic int usbduxsigma_pwm_write(struct comedi_device *dev,\n\t\t\t\t struct comedi_subdevice *s,\n\t\t\t\t struct comedi_insn *insn,\n\t\t\t\t unsigned int *data)\n{\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\n\t \n\tif (insn->n != 1)\n\t\treturn -EINVAL;\n\n\t \n\tusbduxsigma_pwm_pattern(dev, s, chan, data[0], 0);\n\n\treturn insn->n;\n}\n\nstatic int usbduxsigma_pwm_config(struct comedi_device *dev,\n\t\t\t\t  struct comedi_subdevice *s,\n\t\t\t\t  struct comedi_insn *insn,\n\t\t\t\t  unsigned int *data)\n{\n\tstruct usbduxsigma_private *devpriv = dev->private;\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\n\tswitch (data[0]) {\n\tcase INSN_CONFIG_ARM:\n\t\t \n\t\tif (data[1] != 0)\n\t\t\treturn -EINVAL;\n\t\treturn usbduxsigma_pwm_start(dev, s);\n\tcase INSN_CONFIG_DISARM:\n\t\treturn usbduxsigma_pwm_cancel(dev, s);\n\tcase INSN_CONFIG_GET_PWM_STATUS:\n\t\tdata[1] = devpriv->pwm_cmd_running;\n\t\treturn 0;\n\tcase INSN_CONFIG_PWM_SET_PERIOD:\n\t\treturn usbduxsigma_pwm_period(dev, s, data[1]);\n\tcase INSN_CONFIG_PWM_GET_PERIOD:\n\t\tdata[1] = devpriv->pwm_period;\n\t\treturn 0;\n\tcase INSN_CONFIG_PWM_SET_H_BRIDGE:\n\t\t \n\t\tusbduxsigma_pwm_pattern(dev, s, chan, data[1], (data[2] != 0));\n\t\treturn 0;\n\tcase INSN_CONFIG_PWM_GET_H_BRIDGE:\n\t\t \n\t\treturn -EINVAL;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int usbduxsigma_getstatusinfo(struct comedi_device *dev, int chan)\n{\n\tstruct comedi_subdevice *s = dev->read_subdev;\n\tstruct usbduxsigma_private *devpriv = dev->private;\n\tu8 sysred;\n\tu32 val;\n\tint ret;\n\n\tswitch (chan) {\n\tdefault:\n\tcase 0:\n\t\tsysred = 0;\t\t \n\t\tbreak;\n\tcase 1:\n\t\tsysred = 1;\t\t \n\t\tbreak;\n\tcase 2:\n\t\tsysred = 4;\t\t \n\t\tbreak;\n\tcase 3:\n\t\tsysred = 8;\t\t \n\t\tbreak;\n\tcase 4:\n\t\tsysred = 16;\t\t \n\t\tbreak;\n\tcase 5:\n\t\tsysred =  32;\t\t \n\t\tbreak;\n\t}\n\n\tdevpriv->dux_commands[1] = 0x12;  \n\tdevpriv->dux_commands[2] = 0x80;  \n\tdevpriv->dux_commands[3] = 0x00;  \n\tdevpriv->dux_commands[4] = 0;\n\tdevpriv->dux_commands[5] = 0;\n\tdevpriv->dux_commands[6] = sysred;\n\tret = usbbuxsigma_send_cmd(dev, USBDUXSIGMA_SINGLE_AD_CMD);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = usbduxsigma_receive_cmd(dev, USBDUXSIGMA_SINGLE_AD_CMD);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tval = be32_to_cpu(get_unaligned((__be32 *)(devpriv->insn_buf + 1)));\n\tval &= 0x00ffffff;\t \n\n\treturn (int)comedi_offset_munge(s, val);\n}\n\nstatic int usbduxsigma_firmware_upload(struct comedi_device *dev,\n\t\t\t\t       const u8 *data, size_t size,\n\t\t\t\t       unsigned long context)\n{\n\tstruct usb_device *usb = comedi_to_usb_dev(dev);\n\tu8 *buf;\n\tu8 *tmp;\n\tint ret;\n\n\tif (!data)\n\t\treturn 0;\n\n\tif (size > FIRMWARE_MAX_LEN) {\n\t\tdev_err(dev->class_dev, \"firmware binary too large for FX2\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tbuf = kmemdup(data, size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t \n\ttmp = kmalloc(1, GFP_KERNEL);\n\tif (!tmp) {\n\t\tkfree(buf);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\t*tmp = 1;\t \n\tret = usb_control_msg(usb, usb_sndctrlpipe(usb, 0),\n\t\t\t      USBDUXSUB_FIRMWARE,\n\t\t\t      VENDOR_DIR_OUT,\n\t\t\t      USBDUXSUB_CPUCS, 0x0000,\n\t\t\t      tmp, 1,\n\t\t\t      BULK_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_err(dev->class_dev, \"can not stop firmware\\n\");\n\t\tgoto done;\n\t}\n\n\t \n\tret = usb_control_msg(usb, usb_sndctrlpipe(usb, 0),\n\t\t\t      USBDUXSUB_FIRMWARE,\n\t\t\t      VENDOR_DIR_OUT,\n\t\t\t      0, 0x0000,\n\t\t\t      buf, size,\n\t\t\t      BULK_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_err(dev->class_dev, \"firmware upload failed\\n\");\n\t\tgoto done;\n\t}\n\n\t \n\t*tmp = 0;\t \n\tret = usb_control_msg(usb, usb_sndctrlpipe(usb, 0),\n\t\t\t      USBDUXSUB_FIRMWARE,\n\t\t\t      VENDOR_DIR_OUT,\n\t\t\t      USBDUXSUB_CPUCS, 0x0000,\n\t\t\t      tmp, 1,\n\t\t\t      BULK_TIMEOUT);\n\tif (ret < 0)\n\t\tdev_err(dev->class_dev, \"can not start firmware\\n\");\n\ndone:\n\tkfree(tmp);\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic int usbduxsigma_alloc_usb_buffers(struct comedi_device *dev)\n{\n\tstruct usb_device *usb = comedi_to_usb_dev(dev);\n\tstruct usbduxsigma_private *devpriv = dev->private;\n\tstruct urb *urb;\n\tint i;\n\n\tdevpriv->dux_commands = kzalloc(SIZEOFDUXBUFFER, GFP_KERNEL);\n\tdevpriv->in_buf = kzalloc(SIZEINBUF, GFP_KERNEL);\n\tdevpriv->insn_buf = kzalloc(SIZEINSNBUF, GFP_KERNEL);\n\tdevpriv->ai_urbs = kcalloc(devpriv->n_ai_urbs, sizeof(urb), GFP_KERNEL);\n\tdevpriv->ao_urbs = kcalloc(devpriv->n_ao_urbs, sizeof(urb), GFP_KERNEL);\n\tif (!devpriv->dux_commands || !devpriv->in_buf || !devpriv->insn_buf ||\n\t    !devpriv->ai_urbs || !devpriv->ao_urbs)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < devpriv->n_ai_urbs; i++) {\n\t\t \n\t\turb = usb_alloc_urb(1, GFP_KERNEL);\n\t\tif (!urb)\n\t\t\treturn -ENOMEM;\n\t\tdevpriv->ai_urbs[i] = urb;\n\t\turb->dev = usb;\n\t\t \n\t\t \n\t\turb->context = NULL;\n\t\turb->pipe = usb_rcvisocpipe(usb, 6);\n\t\turb->transfer_flags = URB_ISO_ASAP;\n\t\turb->transfer_buffer = kzalloc(SIZEINBUF, GFP_KERNEL);\n\t\tif (!urb->transfer_buffer)\n\t\t\treturn -ENOMEM;\n\t\turb->complete = usbduxsigma_ai_urb_complete;\n\t\turb->number_of_packets = 1;\n\t\turb->transfer_buffer_length = SIZEINBUF;\n\t\turb->iso_frame_desc[0].offset = 0;\n\t\turb->iso_frame_desc[0].length = SIZEINBUF;\n\t}\n\n\tfor (i = 0; i < devpriv->n_ao_urbs; i++) {\n\t\t \n\t\turb = usb_alloc_urb(1, GFP_KERNEL);\n\t\tif (!urb)\n\t\t\treturn -ENOMEM;\n\t\tdevpriv->ao_urbs[i] = urb;\n\t\turb->dev = usb;\n\t\t \n\t\t \n\t\turb->context = NULL;\n\t\turb->pipe = usb_sndisocpipe(usb, 2);\n\t\turb->transfer_flags = URB_ISO_ASAP;\n\t\turb->transfer_buffer = kzalloc(SIZEOUTBUF, GFP_KERNEL);\n\t\tif (!urb->transfer_buffer)\n\t\t\treturn -ENOMEM;\n\t\turb->complete = usbduxsigma_ao_urb_complete;\n\t\turb->number_of_packets = 1;\n\t\turb->transfer_buffer_length = SIZEOUTBUF;\n\t\turb->iso_frame_desc[0].offset = 0;\n\t\turb->iso_frame_desc[0].length = SIZEOUTBUF;\n\t\turb->interval = 1;\t \n\t}\n\n\tif (devpriv->pwm_buf_sz) {\n\t\turb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!urb)\n\t\t\treturn -ENOMEM;\n\t\tdevpriv->pwm_urb = urb;\n\n\t\turb->transfer_buffer = kzalloc(devpriv->pwm_buf_sz,\n\t\t\t\t\t       GFP_KERNEL);\n\t\tif (!urb->transfer_buffer)\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void usbduxsigma_free_usb_buffers(struct comedi_device *dev)\n{\n\tstruct usbduxsigma_private *devpriv = dev->private;\n\tstruct urb *urb;\n\tint i;\n\n\turb = devpriv->pwm_urb;\n\tif (urb) {\n\t\tkfree(urb->transfer_buffer);\n\t\tusb_free_urb(urb);\n\t}\n\tif (devpriv->ao_urbs) {\n\t\tfor (i = 0; i < devpriv->n_ao_urbs; i++) {\n\t\t\turb = devpriv->ao_urbs[i];\n\t\t\tif (urb) {\n\t\t\t\tkfree(urb->transfer_buffer);\n\t\t\t\tusb_free_urb(urb);\n\t\t\t}\n\t\t}\n\t\tkfree(devpriv->ao_urbs);\n\t}\n\tif (devpriv->ai_urbs) {\n\t\tfor (i = 0; i < devpriv->n_ai_urbs; i++) {\n\t\t\turb = devpriv->ai_urbs[i];\n\t\t\tif (urb) {\n\t\t\t\tkfree(urb->transfer_buffer);\n\t\t\t\tusb_free_urb(urb);\n\t\t\t}\n\t\t}\n\t\tkfree(devpriv->ai_urbs);\n\t}\n\tkfree(devpriv->insn_buf);\n\tkfree(devpriv->in_buf);\n\tkfree(devpriv->dux_commands);\n}\n\nstatic int usbduxsigma_auto_attach(struct comedi_device *dev,\n\t\t\t\t   unsigned long context_unused)\n{\n\tstruct usb_interface *intf = comedi_to_usb_interface(dev);\n\tstruct usb_device *usb = comedi_to_usb_dev(dev);\n\tstruct usbduxsigma_private *devpriv;\n\tstruct comedi_subdevice *s;\n\tint offset;\n\tint ret;\n\n\tdevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\n\tif (!devpriv)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&devpriv->mut);\n\n\tusb_set_intfdata(intf, devpriv);\n\n\tdevpriv->high_speed = (usb->speed == USB_SPEED_HIGH);\n\tif (devpriv->high_speed) {\n\t\tdevpriv->n_ai_urbs = NUMOFINBUFFERSHIGH;\n\t\tdevpriv->n_ao_urbs = NUMOFOUTBUFFERSHIGH;\n\t\tdevpriv->pwm_buf_sz = 512;\n\t} else {\n\t\tdevpriv->n_ai_urbs = NUMOFINBUFFERSFULL;\n\t\tdevpriv->n_ao_urbs = NUMOFOUTBUFFERSFULL;\n\t}\n\n\tret = usbduxsigma_alloc_usb_buffers(dev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = usb_set_interface(usb, intf->altsetting->desc.bInterfaceNumber,\n\t\t\t\t3);\n\tif (ret < 0) {\n\t\tdev_err(dev->class_dev,\n\t\t\t\"could not set alternate setting 3 in high speed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = comedi_load_firmware(dev, &usb->dev, FIRMWARE,\n\t\t\t\t   usbduxsigma_firmware_upload, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = comedi_alloc_subdevices(dev, (devpriv->high_speed) ? 4 : 3);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ts = &dev->subdevices[0];\n\tdev->read_subdev = s;\n\ts->type\t\t= COMEDI_SUBD_AI;\n\ts->subdev_flags\t= SDF_READABLE | SDF_GROUND | SDF_CMD_READ | SDF_LSAMPL;\n\ts->n_chan\t= NUMCHANNELS;\n\ts->len_chanlist\t= NUMCHANNELS;\n\ts->maxdata\t= 0x00ffffff;\n\ts->range_table\t= &usbduxsigma_ai_range;\n\ts->insn_read\t= usbduxsigma_ai_insn_read;\n\ts->do_cmdtest\t= usbduxsigma_ai_cmdtest;\n\ts->do_cmd\t= usbduxsigma_ai_cmd;\n\ts->cancel\t= usbduxsigma_ai_cancel;\n\n\t \n\ts = &dev->subdevices[1];\n\tdev->write_subdev = s;\n\ts->type\t\t= COMEDI_SUBD_AO;\n\ts->subdev_flags\t= SDF_WRITABLE | SDF_GROUND | SDF_CMD_WRITE;\n\ts->n_chan\t= 4;\n\ts->len_chanlist\t= s->n_chan;\n\ts->maxdata\t= 0x00ff;\n\ts->range_table\t= &range_unipolar2_5;\n\ts->insn_write\t= usbduxsigma_ao_insn_write;\n\ts->insn_read\t= usbduxsigma_ao_insn_read;\n\ts->do_cmdtest\t= usbduxsigma_ao_cmdtest;\n\ts->do_cmd\t= usbduxsigma_ao_cmd;\n\ts->cancel\t= usbduxsigma_ao_cancel;\n\n\tret = comedi_alloc_subdev_readback(s);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ts = &dev->subdevices[2];\n\ts->type\t\t= COMEDI_SUBD_DIO;\n\ts->subdev_flags\t= SDF_READABLE | SDF_WRITABLE;\n\ts->n_chan\t= 24;\n\ts->maxdata\t= 1;\n\ts->range_table\t= &range_digital;\n\ts->insn_bits\t= usbduxsigma_dio_insn_bits;\n\ts->insn_config\t= usbduxsigma_dio_insn_config;\n\n\tif (devpriv->high_speed) {\n\t\t \n\t\ts = &dev->subdevices[3];\n\t\ts->type\t\t= COMEDI_SUBD_PWM;\n\t\ts->subdev_flags\t= SDF_WRITABLE | SDF_PWM_HBRIDGE;\n\t\ts->n_chan\t= 8;\n\t\ts->maxdata\t= devpriv->pwm_buf_sz;\n\t\ts->insn_write\t= usbduxsigma_pwm_write;\n\t\ts->insn_config\t= usbduxsigma_pwm_config;\n\n\t\tusbduxsigma_pwm_period(dev, s, PWM_DEFAULT_PERIOD);\n\t}\n\n\toffset = usbduxsigma_getstatusinfo(dev, 0);\n\tif (offset < 0) {\n\t\tdev_err(dev->class_dev,\n\t\t\t\"Communication to USBDUXSIGMA failed! Check firmware and cabling.\\n\");\n\t\treturn offset;\n\t}\n\n\tdev_info(dev->class_dev, \"ADC_zero = %x\\n\", offset);\n\n\treturn 0;\n}\n\nstatic void usbduxsigma_detach(struct comedi_device *dev)\n{\n\tstruct usb_interface *intf = comedi_to_usb_interface(dev);\n\tstruct usbduxsigma_private *devpriv = dev->private;\n\n\tusb_set_intfdata(intf, NULL);\n\n\tif (!devpriv)\n\t\treturn;\n\n\tmutex_lock(&devpriv->mut);\n\n\t \n\tusbduxsigma_ai_stop(dev, 1);\n\tusbduxsigma_ao_stop(dev, 1);\n\tusbduxsigma_pwm_stop(dev, 1);\n\n\tusbduxsigma_free_usb_buffers(dev);\n\n\tmutex_unlock(&devpriv->mut);\n\n\tmutex_destroy(&devpriv->mut);\n}\n\nstatic struct comedi_driver usbduxsigma_driver = {\n\t.driver_name\t= \"usbduxsigma\",\n\t.module\t\t= THIS_MODULE,\n\t.auto_attach\t= usbduxsigma_auto_attach,\n\t.detach\t\t= usbduxsigma_detach,\n};\n\nstatic int usbduxsigma_usb_probe(struct usb_interface *intf,\n\t\t\t\t const struct usb_device_id *id)\n{\n\treturn comedi_usb_auto_config(intf, &usbduxsigma_driver, 0);\n}\n\nstatic const struct usb_device_id usbduxsigma_usb_table[] = {\n\t{ USB_DEVICE(0x13d8, 0x0020) },\n\t{ USB_DEVICE(0x13d8, 0x0021) },\n\t{ USB_DEVICE(0x13d8, 0x0022) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(usb, usbduxsigma_usb_table);\n\nstatic struct usb_driver usbduxsigma_usb_driver = {\n\t.name\t\t= \"usbduxsigma\",\n\t.probe\t\t= usbduxsigma_usb_probe,\n\t.disconnect\t= comedi_usb_auto_unconfig,\n\t.id_table\t= usbduxsigma_usb_table,\n};\nmodule_comedi_usb_driver(usbduxsigma_driver, usbduxsigma_usb_driver);\n\nMODULE_AUTHOR(\"Bernd Porr, mail@berndporr.me.uk\");\nMODULE_DESCRIPTION(\"Stirling/ITL USB-DUX SIGMA -- mail@berndporr.me.uk\");\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(FIRMWARE);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}