{
  "module_name": "cb_pcidas64.c",
  "hash_id": "b624ad602d4f423d9f07e5af6ce99cb318a75221342a1e9437699afc62688690",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/cb_pcidas64.c",
  "human_readable_source": "\n \n\n \n\n \n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/comedi/comedi_pci.h>\n#include <linux/comedi/comedi_8255.h>\n\n#include \"plx9080.h\"\n\n#define TIMER_BASE 25\t\t \n \n#define PRESCALED_TIMER_BASE\t10000\n#define DMA_BUFFER_SIZE\t\t0x1000\n#define DAC_FIFO_SIZE\t\t0x2000\n\n \nstatic const int max_counter_value = 0xffffff;\n\n \n\n \nenum write_only_registers {\n\tINTR_ENABLE_REG = 0x0,\t\t \n\tHW_CONFIG_REG = 0x2,\t\t \n\tDAQ_SYNC_REG = 0xc,\n\tDAQ_ATRIG_LOW_4020_REG = 0xc,\n\tADC_CONTROL0_REG = 0x10,\t \n\tADC_CONTROL1_REG = 0x12,\t \n\tCALIBRATION_REG = 0x14,\n\t \n\tADC_SAMPLE_INTERVAL_LOWER_REG = 0x16,\n\t \n\tADC_SAMPLE_INTERVAL_UPPER_REG = 0x18,\n\t \n\tADC_DELAY_INTERVAL_LOWER_REG = 0x1a,\n\t \n\tADC_DELAY_INTERVAL_UPPER_REG = 0x1c,\n\t \n\tADC_COUNT_LOWER_REG = 0x1e,\n\t \n\tADC_COUNT_UPPER_REG = 0x20,\n\tADC_START_REG = 0x22,\t \n\tADC_CONVERT_REG = 0x24,\t \n\tADC_QUEUE_CLEAR_REG = 0x26,\t \n\tADC_QUEUE_LOAD_REG = 0x28,\t \n\tADC_BUFFER_CLEAR_REG = 0x2a,\n\t \n\tADC_QUEUE_HIGH_REG = 0x2c,\n\tDAC_CONTROL0_REG = 0x50,\t \n\tDAC_CONTROL1_REG = 0x52,\t \n\t \n\tDAC_SAMPLE_INTERVAL_LOWER_REG = 0x54,\n\t \n\tDAC_SAMPLE_INTERVAL_UPPER_REG = 0x56,\n\tDAC_SELECT_REG = 0x60,\n\tDAC_START_REG = 0x64,\n\tDAC_BUFFER_CLEAR_REG = 0x66,\t \n};\n\nstatic inline unsigned int dac_convert_reg(unsigned int channel)\n{\n\treturn 0x70 + (2 * (channel & 0x1));\n}\n\nstatic inline unsigned int dac_lsb_4020_reg(unsigned int channel)\n{\n\treturn 0x70 + (4 * (channel & 0x1));\n}\n\nstatic inline unsigned int dac_msb_4020_reg(unsigned int channel)\n{\n\treturn 0x72 + (4 * (channel & 0x1));\n}\n\nenum read_only_registers {\n\t \n\tHW_STATUS_REG = 0x0,\n\tPIPE1_READ_REG = 0x4,\n\tADC_READ_PNTR_REG = 0x8,\n\tLOWER_XFER_REG = 0x10,\n\tADC_WRITE_PNTR_REG = 0xc,\n\tPREPOST_REG = 0x14,\n};\n\nenum read_write_registers {\n\tI8255_4020_REG = 0x48,\t \n\t \n\tADC_QUEUE_FIFO_REG = 0x100,\n\tADC_FIFO_REG = 0x200,\t \n\t \n\tDAC_FIFO_REG = 0x300,\n};\n\n \nenum dio_counter_registers {\n\tDIO_8255_OFFSET = 0x0,\n\tDO_REG = 0x20,\n\tDI_REG = 0x28,\n\tDIO_DIRECTION_60XX_REG = 0x40,\n\tDIO_DATA_60XX_REG = 0x48,\n};\n\n \n\nenum intr_enable_contents {\n\tADC_INTR_SRC_MASK = 0x3,\t \n\tADC_INTR_QFULL_BITS = 0x0,\t \n\tADC_INTR_EOC_BITS = 0x1,\t \n\tADC_INTR_EOSCAN_BITS = 0x2,\t \n\tADC_INTR_EOSEQ_BITS = 0x3,\t \n\tEN_ADC_INTR_SRC_BIT = 0x4,\t \n\tEN_ADC_DONE_INTR_BIT = 0x8,\t \n\tDAC_INTR_SRC_MASK = 0x30,\n\tDAC_INTR_QEMPTY_BITS = 0x0,\n\tDAC_INTR_HIGH_CHAN_BITS = 0x10,\n\tEN_DAC_INTR_SRC_BIT = 0x40,\t \n\tEN_DAC_DONE_INTR_BIT = 0x80,\n\tEN_ADC_ACTIVE_INTR_BIT = 0x200,\t \n\tEN_ADC_STOP_INTR_BIT = 0x400,\t \n\tEN_DAC_ACTIVE_INTR_BIT = 0x800,\t \n\tEN_DAC_UNDERRUN_BIT = 0x4000,\t \n\tEN_ADC_OVERRUN_BIT = 0x8000,\t \n};\n\nenum hw_config_contents {\n\tMASTER_CLOCK_4020_MASK = 0x3,\t \n\tINTERNAL_CLOCK_4020_BITS = 0x1,\t \n\tBNC_CLOCK_4020_BITS = 0x2,\t \n\tEXT_CLOCK_4020_BITS = 0x3,\t \n\tEXT_QUEUE_BIT = 0x200,\t\t \n\t \n\tSLOW_DAC_BIT = 0x400,\n\t \n\tHW_CONFIG_DUMMY_BITS = 0x2000,\n\t \n\tDMA_CH_SELECT_BIT = 0x8000,\n\tFIFO_SIZE_REG = 0x4,\t\t \n\tDAC_FIFO_SIZE_MASK = 0xff00,\t \n\tDAC_FIFO_BITS = 0xf800,\t\t \n};\n\nenum daq_atrig_low_4020_contents {\n\t \n\tEXT_AGATE_BNC_BIT = 0x8000,\n\t \n\tEXT_STOP_TRIG_BNC_BIT = 0x4000,\n\t \n\tEXT_START_TRIG_BNC_BIT = 0x2000,\n};\n\nenum adc_control0_contents {\n\tADC_GATE_SRC_MASK = 0x3,\t \n\tADC_SOFT_GATE_BITS = 0x1,\t \n\tADC_EXT_GATE_BITS = 0x2,\t \n\tADC_ANALOG_GATE_BITS = 0x3,\t \n\t \n\tADC_GATE_LEVEL_BIT = 0x4,\n\tADC_GATE_POLARITY_BIT = 0x8,\t \n\tADC_START_TRIG_SOFT_BITS = 0x10,\n\tADC_START_TRIG_EXT_BITS = 0x20,\n\tADC_START_TRIG_ANALOG_BITS = 0x30,\n\tADC_START_TRIG_MASK = 0x30,\n\tADC_START_TRIG_FALLING_BIT = 0x40,\t \n\t \n\tADC_EXT_CONV_FALLING_BIT = 0x800,\n\t \n\tADC_SAMPLE_COUNTER_EN_BIT = 0x1000,\n\tADC_DMA_DISABLE_BIT = 0x4000,\t \n\tADC_ENABLE_BIT = 0x8000,\t \n};\n\nenum adc_control1_contents {\n\t \n\tADC_QUEUE_CONFIG_BIT = 0x1,\n\tCONVERT_POLARITY_BIT = 0x10,\n\tEOC_POLARITY_BIT = 0x20,\n\tADC_SW_GATE_BIT = 0x40,\t\t \n\tADC_DITHER_BIT = 0x200,\t\t \n\tRETRIGGER_BIT = 0x800,\n\tADC_LO_CHANNEL_4020_MASK = 0x300,\n\tADC_HI_CHANNEL_4020_MASK = 0xc00,\n\tTWO_CHANNEL_4020_BITS = 0x1000,\t\t \n\tFOUR_CHANNEL_4020_BITS = 0x2000,\t \n\tCHANNEL_MODE_4020_MASK = 0x3000,\n\tADC_MODE_MASK = 0xf000,\n};\n\nstatic inline u16 adc_lo_chan_4020_bits(unsigned int channel)\n{\n\treturn (channel & 0x3) << 8;\n};\n\nstatic inline u16 adc_hi_chan_4020_bits(unsigned int channel)\n{\n\treturn (channel & 0x3) << 10;\n};\n\nstatic inline u16 adc_mode_bits(unsigned int mode)\n{\n\treturn (mode & 0xf) << 12;\n};\n\nenum calibration_contents {\n\tSELECT_8800_BIT = 0x1,\n\tSELECT_8402_64XX_BIT = 0x2,\n\tSELECT_1590_60XX_BIT = 0x2,\n\tCAL_EN_64XX_BIT = 0x40,\t\t \n\tSERIAL_DATA_IN_BIT = 0x80,\n\tSERIAL_CLOCK_BIT = 0x100,\n\tCAL_EN_60XX_BIT = 0x200,\t \n\tCAL_GAIN_BIT = 0x800,\n};\n\n \n\nstatic inline u16 adc_src_bits(unsigned int source)\n{\n\treturn (source & 0xf) << 3;\n};\n\nstatic inline u16 adc_convert_chan_4020_bits(unsigned int channel)\n{\n\treturn (channel & 0x3) << 8;\n};\n\nenum adc_queue_load_contents {\n\tUNIP_BIT = 0x800,\t\t \n\tADC_SE_DIFF_BIT = 0x1000,\t \n\t \n\tADC_COMMON_BIT = 0x2000,\n\tQUEUE_EOSEQ_BIT = 0x4000,\t \n\tQUEUE_EOSCAN_BIT = 0x8000,\t \n};\n\nstatic inline u16 adc_chan_bits(unsigned int channel)\n{\n\treturn channel & 0x3f;\n};\n\nenum dac_control0_contents {\n\tDAC_ENABLE_BIT = 0x8000,\t \n\tDAC_CYCLIC_STOP_BIT = 0x4000,\n\tDAC_WAVEFORM_MODE_BIT = 0x100,\n\tDAC_EXT_UPDATE_FALLING_BIT = 0x80,\n\tDAC_EXT_UPDATE_ENABLE_BIT = 0x40,\n\tWAVEFORM_TRIG_MASK = 0x30,\n\tWAVEFORM_TRIG_DISABLED_BITS = 0x0,\n\tWAVEFORM_TRIG_SOFT_BITS = 0x10,\n\tWAVEFORM_TRIG_EXT_BITS = 0x20,\n\tWAVEFORM_TRIG_ADC1_BITS = 0x30,\n\tWAVEFORM_TRIG_FALLING_BIT = 0x8,\n\tWAVEFORM_GATE_LEVEL_BIT = 0x4,\n\tWAVEFORM_GATE_ENABLE_BIT = 0x2,\n\tWAVEFORM_GATE_SELECT_BIT = 0x1,\n};\n\nenum dac_control1_contents {\n\tDAC_WRITE_POLARITY_BIT = 0x800,\t \n\tDAC1_EXT_REF_BIT = 0x200,\n\tDAC0_EXT_REF_BIT = 0x100,\n\tDAC_OUTPUT_ENABLE_BIT = 0x80,\t \n\tDAC_UPDATE_POLARITY_BIT = 0x40,\t \n\tDAC_SW_GATE_BIT = 0x20,\n\tDAC1_UNIPOLAR_BIT = 0x8,\n\tDAC0_UNIPOLAR_BIT = 0x2,\n};\n\n \nenum hw_status_contents {\n\tDAC_UNDERRUN_BIT = 0x1,\n\tADC_OVERRUN_BIT = 0x2,\n\tDAC_ACTIVE_BIT = 0x4,\n\tADC_ACTIVE_BIT = 0x8,\n\tDAC_INTR_PENDING_BIT = 0x10,\n\tADC_INTR_PENDING_BIT = 0x20,\n\tDAC_DONE_BIT = 0x40,\n\tADC_DONE_BIT = 0x80,\n\tEXT_INTR_PENDING_BIT = 0x100,\n\tADC_STOP_BIT = 0x200,\n};\n\nstatic inline u16 pipe_full_bits(u16 hw_status_bits)\n{\n\treturn (hw_status_bits >> 10) & 0x3;\n};\n\nstatic inline unsigned int dma_chain_flag_bits(u16 prepost_bits)\n{\n\treturn (prepost_bits >> 6) & 0x3;\n}\n\nstatic inline unsigned int adc_upper_read_ptr_code(u16 prepost_bits)\n{\n\treturn (prepost_bits >> 12) & 0x3;\n}\n\nstatic inline unsigned int adc_upper_write_ptr_code(u16 prepost_bits)\n{\n\treturn (prepost_bits >> 14) & 0x3;\n}\n\n \nenum i2c_addresses {\n\tRANGE_CAL_I2C_ADDR = 0x20,\n\tCALDAC0_I2C_ADDR = 0xc,\n\tCALDAC1_I2C_ADDR = 0xd,\n};\n\nenum range_cal_i2c_contents {\n\t \n\tADC_SRC_4020_MASK = 0x70,\n\t \n\tBNC_TRIG_THRESHOLD_0V_BIT = 0x80,\n};\n\nstatic inline u8 adc_src_4020_bits(unsigned int source)\n{\n\treturn (source << 4) & ADC_SRC_4020_MASK;\n};\n\nstatic inline u8 attenuate_bit(unsigned int channel)\n{\n\t \n\treturn 1 << (channel & 0x3);\n};\n\n \nstatic const struct comedi_lrange ai_ranges_64xx = {\n\t8, {\n\t\tBIP_RANGE(10),\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(2.5),\n\t\tBIP_RANGE(1.25),\n\t\tUNI_RANGE(10),\n\t\tUNI_RANGE(5),\n\t\tUNI_RANGE(2.5),\n\t\tUNI_RANGE(1.25)\n\t}\n};\n\nstatic const u8 ai_range_code_64xx[8] = {\n\t0x0, 0x1, 0x2, 0x3,\t \n\t0x8, 0x9, 0xa, 0xb\t \n};\n\n \nstatic const struct comedi_lrange ai_ranges_64_mx = {\n\t7, {\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(2.5),\n\t\tBIP_RANGE(1.25),\n\t\tBIP_RANGE(0.625),\n\t\tUNI_RANGE(5),\n\t\tUNI_RANGE(2.5),\n\t\tUNI_RANGE(1.25)\n\t}\n};\n\nstatic const u8 ai_range_code_64_mx[7] = {\n\t0x0, 0x1, 0x2, 0x3,\t \n\t0x9, 0xa, 0xb\t\t \n};\n\n \nstatic const struct comedi_lrange ai_ranges_60xx = {\n\t4, {\n\t\tBIP_RANGE(10),\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(0.5),\n\t\tBIP_RANGE(0.05)\n\t}\n};\n\nstatic const u8 ai_range_code_60xx[4] = {\n\t0x0, 0x1, 0x4, 0x7\t \n};\n\n \nstatic const struct comedi_lrange ai_ranges_6030 = {\n\t14, {\n\t\tBIP_RANGE(10),\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(2),\n\t\tBIP_RANGE(1),\n\t\tBIP_RANGE(0.5),\n\t\tBIP_RANGE(0.2),\n\t\tBIP_RANGE(0.1),\n\t\tUNI_RANGE(10),\n\t\tUNI_RANGE(5),\n\t\tUNI_RANGE(2),\n\t\tUNI_RANGE(1),\n\t\tUNI_RANGE(0.5),\n\t\tUNI_RANGE(0.2),\n\t\tUNI_RANGE(0.1)\n\t}\n};\n\nstatic const u8 ai_range_code_6030[14] = {\n\t0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6,  \n\t0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf   \n};\n\n \nstatic const struct comedi_lrange ai_ranges_6052 = {\n\t15, {\n\t\tBIP_RANGE(10),\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(2.5),\n\t\tBIP_RANGE(1),\n\t\tBIP_RANGE(0.5),\n\t\tBIP_RANGE(0.25),\n\t\tBIP_RANGE(0.1),\n\t\tBIP_RANGE(0.05),\n\t\tUNI_RANGE(10),\n\t\tUNI_RANGE(5),\n\t\tUNI_RANGE(2),\n\t\tUNI_RANGE(1),\n\t\tUNI_RANGE(0.5),\n\t\tUNI_RANGE(0.2),\n\t\tUNI_RANGE(0.1)\n\t}\n};\n\nstatic const u8 ai_range_code_6052[15] = {\n\t0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7,\t \n\t0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf\t \n};\n\n \nstatic const struct comedi_lrange ai_ranges_4020 = {\n\t2, {\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(1)\n\t}\n};\n\n \nstatic const struct comedi_lrange ao_ranges_64xx = {\n\t4, {\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(10),\n\t\tUNI_RANGE(5),\n\t\tUNI_RANGE(10)\n\t}\n};\n\nstatic const int ao_range_code_64xx[] = {\n\t0x0,\n\t0x1,\n\t0x2,\n\t0x3,\n};\n\nstatic const int ao_range_code_60xx[] = {\n\t0x0,\n};\n\nstatic const struct comedi_lrange ao_ranges_6030 = {\n\t2, {\n\t\tBIP_RANGE(10),\n\t\tUNI_RANGE(10)\n\t}\n};\n\nstatic const int ao_range_code_6030[] = {\n\t0x0,\n\t0x2,\n};\n\nstatic const struct comedi_lrange ao_ranges_4020 = {\n\t2, {\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(10)\n\t}\n};\n\nstatic const int ao_range_code_4020[] = {\n\t0x1,\n\t0x0,\n};\n\nenum register_layout {\n\tLAYOUT_60XX,\n\tLAYOUT_64XX,\n\tLAYOUT_4020,\n};\n\nstruct hw_fifo_info {\n\tunsigned int num_segments;\n\tunsigned int max_segment_length;\n\tunsigned int sample_packing_ratio;\n\tu16 fifo_size_reg_mask;\n};\n\nenum pcidas64_boardid {\n\tBOARD_PCIDAS6402_16,\n\tBOARD_PCIDAS6402_12,\n\tBOARD_PCIDAS64_M1_16,\n\tBOARD_PCIDAS64_M2_16,\n\tBOARD_PCIDAS64_M3_16,\n\tBOARD_PCIDAS6013,\n\tBOARD_PCIDAS6014,\n\tBOARD_PCIDAS6023,\n\tBOARD_PCIDAS6025,\n\tBOARD_PCIDAS6030,\n\tBOARD_PCIDAS6031,\n\tBOARD_PCIDAS6032,\n\tBOARD_PCIDAS6033,\n\tBOARD_PCIDAS6034,\n\tBOARD_PCIDAS6035,\n\tBOARD_PCIDAS6036,\n\tBOARD_PCIDAS6040,\n\tBOARD_PCIDAS6052,\n\tBOARD_PCIDAS6070,\n\tBOARD_PCIDAS6071,\n\tBOARD_PCIDAS4020_12,\n\tBOARD_PCIDAS6402_16_JR,\n\tBOARD_PCIDAS64_M1_16_JR,\n\tBOARD_PCIDAS64_M2_16_JR,\n\tBOARD_PCIDAS64_M3_16_JR,\n\tBOARD_PCIDAS64_M1_14,\n\tBOARD_PCIDAS64_M2_14,\n\tBOARD_PCIDAS64_M3_14,\n};\n\nstruct pcidas64_board {\n\tconst char *name;\n\tint ai_se_chans;\t \n\tint ai_bits;\t\t \n\tint ai_speed;\t\t \n\tconst struct comedi_lrange *ai_range_table;\n\tconst u8 *ai_range_code;\n\tint ao_nchan;\t\t \n\tint ao_bits;\t\t \n\tint ao_scan_speed;\t \n\tconst struct comedi_lrange *ao_range_table;\n\tconst int *ao_range_code;\n\tconst struct hw_fifo_info *const ai_fifo;\n\t \n\tenum register_layout layout;\n\tunsigned has_8255:1;\n};\n\nstatic const struct hw_fifo_info ai_fifo_4020 = {\n\t.num_segments = 2,\n\t.max_segment_length = 0x8000,\n\t.sample_packing_ratio = 2,\n\t.fifo_size_reg_mask = 0x7f,\n};\n\nstatic const struct hw_fifo_info ai_fifo_64xx = {\n\t.num_segments = 4,\n\t.max_segment_length = 0x800,\n\t.sample_packing_ratio = 1,\n\t.fifo_size_reg_mask = 0x3f,\n};\n\nstatic const struct hw_fifo_info ai_fifo_60xx = {\n\t.num_segments = 4,\n\t.max_segment_length = 0x800,\n\t.sample_packing_ratio = 1,\n\t.fifo_size_reg_mask = 0x7f,\n};\n\n \n#define MAX_AI_DMA_RING_COUNT (0x80000 / DMA_BUFFER_SIZE)\n#define MIN_AI_DMA_RING_COUNT (0x10000 / DMA_BUFFER_SIZE)\n#define AO_DMA_RING_COUNT (0x10000 / DMA_BUFFER_SIZE)\nstatic inline unsigned int ai_dma_ring_count(const struct pcidas64_board *board)\n{\n\tif (board->layout == LAYOUT_4020)\n\t\treturn MAX_AI_DMA_RING_COUNT;\n\n\treturn MIN_AI_DMA_RING_COUNT;\n}\n\nstatic const int bytes_in_sample = 2;\n\nstatic const struct pcidas64_board pcidas64_boards[] = {\n\t[BOARD_PCIDAS6402_16] = {\n\t\t.name\t\t= \"pci-das6402/16\",\n\t\t.ai_se_chans\t= 64,\n\t\t.ai_bits\t= 16,\n\t\t.ai_speed\t= 5000,\n\t\t.ao_nchan\t= 2,\n\t\t.ao_bits\t= 16,\n\t\t.ao_scan_speed\t= 10000,\n\t\t.layout\t\t= LAYOUT_64XX,\n\t\t.ai_range_table\t= &ai_ranges_64xx,\n\t\t.ai_range_code\t= ai_range_code_64xx,\n\t\t.ao_range_table\t= &ao_ranges_64xx,\n\t\t.ao_range_code\t= ao_range_code_64xx,\n\t\t.ai_fifo\t= &ai_fifo_64xx,\n\t\t.has_8255\t= 1,\n\t},\n\t[BOARD_PCIDAS6402_12] = {\n\t\t.name\t\t= \"pci-das6402/12\",\t \n\t\t.ai_se_chans\t= 64,\n\t\t.ai_bits\t= 12,\n\t\t.ai_speed\t= 5000,\n\t\t.ao_nchan\t= 2,\n\t\t.ao_bits\t= 12,\n\t\t.ao_scan_speed\t= 10000,\n\t\t.layout\t\t= LAYOUT_64XX,\n\t\t.ai_range_table\t= &ai_ranges_64xx,\n\t\t.ai_range_code\t= ai_range_code_64xx,\n\t\t.ao_range_table\t= &ao_ranges_64xx,\n\t\t.ao_range_code\t= ao_range_code_64xx,\n\t\t.ai_fifo\t= &ai_fifo_64xx,\n\t\t.has_8255\t= 1,\n\t},\n\t[BOARD_PCIDAS64_M1_16] = {\n\t\t.name\t\t= \"pci-das64/m1/16\",\n\t\t.ai_se_chans\t= 64,\n\t\t.ai_bits\t= 16,\n\t\t.ai_speed\t= 1000,\n\t\t.ao_nchan\t= 2,\n\t\t.ao_bits\t= 16,\n\t\t.ao_scan_speed\t= 10000,\n\t\t.layout\t\t= LAYOUT_64XX,\n\t\t.ai_range_table\t= &ai_ranges_64_mx,\n\t\t.ai_range_code\t= ai_range_code_64_mx,\n\t\t.ao_range_table\t= &ao_ranges_64xx,\n\t\t.ao_range_code\t= ao_range_code_64xx,\n\t\t.ai_fifo\t= &ai_fifo_64xx,\n\t\t.has_8255\t= 1,\n\t},\n\t[BOARD_PCIDAS64_M2_16] = {\n\t\t.name = \"pci-das64/m2/16\",\n\t\t.ai_se_chans\t= 64,\n\t\t.ai_bits\t= 16,\n\t\t.ai_speed\t= 500,\n\t\t.ao_nchan\t= 2,\n\t\t.ao_bits\t= 16,\n\t\t.ao_scan_speed\t= 10000,\n\t\t.layout\t\t= LAYOUT_64XX,\n\t\t.ai_range_table\t= &ai_ranges_64_mx,\n\t\t.ai_range_code\t= ai_range_code_64_mx,\n\t\t.ao_range_table\t= &ao_ranges_64xx,\n\t\t.ao_range_code\t= ao_range_code_64xx,\n\t\t.ai_fifo\t= &ai_fifo_64xx,\n\t\t.has_8255\t= 1,\n\t},\n\t[BOARD_PCIDAS64_M3_16] = {\n\t\t.name\t\t= \"pci-das64/m3/16\",\n\t\t.ai_se_chans\t= 64,\n\t\t.ai_bits\t= 16,\n\t\t.ai_speed\t= 333,\n\t\t.ao_nchan\t= 2,\n\t\t.ao_bits\t= 16,\n\t\t.ao_scan_speed\t= 10000,\n\t\t.layout\t\t= LAYOUT_64XX,\n\t\t.ai_range_table\t= &ai_ranges_64_mx,\n\t\t.ai_range_code\t= ai_range_code_64_mx,\n\t\t.ao_range_table\t= &ao_ranges_64xx,\n\t\t.ao_range_code\t= ao_range_code_64xx,\n\t\t.ai_fifo\t= &ai_fifo_64xx,\n\t\t.has_8255\t= 1,\n\t},\n\t[BOARD_PCIDAS6013] = {\n\t\t.name\t\t= \"pci-das6013\",\n\t\t.ai_se_chans\t= 16,\n\t\t.ai_bits\t= 16,\n\t\t.ai_speed\t= 5000,\n\t\t.ao_nchan\t= 0,\n\t\t.ao_bits\t= 16,\n\t\t.layout\t\t= LAYOUT_60XX,\n\t\t.ai_range_table\t= &ai_ranges_60xx,\n\t\t.ai_range_code\t= ai_range_code_60xx,\n\t\t.ao_range_table\t= &range_bipolar10,\n\t\t.ao_range_code\t= ao_range_code_60xx,\n\t\t.ai_fifo\t= &ai_fifo_60xx,\n\t\t.has_8255\t= 0,\n\t},\n\t[BOARD_PCIDAS6014] = {\n\t\t.name\t\t= \"pci-das6014\",\n\t\t.ai_se_chans\t= 16,\n\t\t.ai_bits\t= 16,\n\t\t.ai_speed\t= 5000,\n\t\t.ao_nchan\t= 2,\n\t\t.ao_bits\t= 16,\n\t\t.ao_scan_speed\t= 100000,\n\t\t.layout\t\t= LAYOUT_60XX,\n\t\t.ai_range_table\t= &ai_ranges_60xx,\n\t\t.ai_range_code\t= ai_range_code_60xx,\n\t\t.ao_range_table\t= &range_bipolar10,\n\t\t.ao_range_code\t= ao_range_code_60xx,\n\t\t.ai_fifo\t= &ai_fifo_60xx,\n\t\t.has_8255\t= 0,\n\t},\n\t[BOARD_PCIDAS6023] = {\n\t\t.name\t\t= \"pci-das6023\",\n\t\t.ai_se_chans\t= 16,\n\t\t.ai_bits\t= 12,\n\t\t.ai_speed\t= 5000,\n\t\t.ao_nchan\t= 0,\n\t\t.ao_scan_speed\t= 100000,\n\t\t.layout\t\t= LAYOUT_60XX,\n\t\t.ai_range_table\t= &ai_ranges_60xx,\n\t\t.ai_range_code\t= ai_range_code_60xx,\n\t\t.ao_range_table\t= &range_bipolar10,\n\t\t.ao_range_code\t= ao_range_code_60xx,\n\t\t.ai_fifo\t= &ai_fifo_60xx,\n\t\t.has_8255\t= 1,\n\t},\n\t[BOARD_PCIDAS6025] = {\n\t\t.name\t\t= \"pci-das6025\",\n\t\t.ai_se_chans\t= 16,\n\t\t.ai_bits\t= 12,\n\t\t.ai_speed\t= 5000,\n\t\t.ao_nchan\t= 2,\n\t\t.ao_bits\t= 12,\n\t\t.ao_scan_speed\t= 100000,\n\t\t.layout\t\t= LAYOUT_60XX,\n\t\t.ai_range_table\t= &ai_ranges_60xx,\n\t\t.ai_range_code\t= ai_range_code_60xx,\n\t\t.ao_range_table\t= &range_bipolar10,\n\t\t.ao_range_code\t= ao_range_code_60xx,\n\t\t.ai_fifo\t= &ai_fifo_60xx,\n\t\t.has_8255\t= 1,\n\t},\n\t[BOARD_PCIDAS6030] = {\n\t\t.name\t\t= \"pci-das6030\",\n\t\t.ai_se_chans\t= 16,\n\t\t.ai_bits\t= 16,\n\t\t.ai_speed\t= 10000,\n\t\t.ao_nchan\t= 2,\n\t\t.ao_bits\t= 16,\n\t\t.ao_scan_speed\t= 10000,\n\t\t.layout\t\t= LAYOUT_60XX,\n\t\t.ai_range_table\t= &ai_ranges_6030,\n\t\t.ai_range_code\t= ai_range_code_6030,\n\t\t.ao_range_table\t= &ao_ranges_6030,\n\t\t.ao_range_code\t= ao_range_code_6030,\n\t\t.ai_fifo\t= &ai_fifo_60xx,\n\t\t.has_8255\t= 0,\n\t},\n\t[BOARD_PCIDAS6031] = {\n\t\t.name\t\t= \"pci-das6031\",\n\t\t.ai_se_chans\t= 64,\n\t\t.ai_bits\t= 16,\n\t\t.ai_speed\t= 10000,\n\t\t.ao_nchan\t= 2,\n\t\t.ao_bits\t= 16,\n\t\t.ao_scan_speed\t= 10000,\n\t\t.layout\t\t= LAYOUT_60XX,\n\t\t.ai_range_table\t= &ai_ranges_6030,\n\t\t.ai_range_code\t= ai_range_code_6030,\n\t\t.ao_range_table\t= &ao_ranges_6030,\n\t\t.ao_range_code\t= ao_range_code_6030,\n\t\t.ai_fifo\t= &ai_fifo_60xx,\n\t\t.has_8255\t= 0,\n\t},\n\t[BOARD_PCIDAS6032] = {\n\t\t.name\t\t= \"pci-das6032\",\n\t\t.ai_se_chans\t= 16,\n\t\t.ai_bits\t= 16,\n\t\t.ai_speed\t= 10000,\n\t\t.ao_nchan\t= 0,\n\t\t.layout\t\t= LAYOUT_60XX,\n\t\t.ai_range_table\t= &ai_ranges_6030,\n\t\t.ai_range_code\t= ai_range_code_6030,\n\t\t.ai_fifo\t= &ai_fifo_60xx,\n\t\t.has_8255\t= 0,\n\t},\n\t[BOARD_PCIDAS6033] = {\n\t\t.name\t\t= \"pci-das6033\",\n\t\t.ai_se_chans\t= 64,\n\t\t.ai_bits\t= 16,\n\t\t.ai_speed\t= 10000,\n\t\t.ao_nchan\t= 0,\n\t\t.layout\t\t= LAYOUT_60XX,\n\t\t.ai_range_table\t= &ai_ranges_6030,\n\t\t.ai_range_code\t= ai_range_code_6030,\n\t\t.ai_fifo\t= &ai_fifo_60xx,\n\t\t.has_8255\t= 0,\n\t},\n\t[BOARD_PCIDAS6034] = {\n\t\t.name\t\t= \"pci-das6034\",\n\t\t.ai_se_chans\t= 16,\n\t\t.ai_bits\t= 16,\n\t\t.ai_speed\t= 5000,\n\t\t.ao_nchan\t= 0,\n\t\t.ao_scan_speed\t= 0,\n\t\t.layout\t\t= LAYOUT_60XX,\n\t\t.ai_range_table\t= &ai_ranges_60xx,\n\t\t.ai_range_code\t= ai_range_code_60xx,\n\t\t.ai_fifo\t= &ai_fifo_60xx,\n\t\t.has_8255\t= 0,\n\t},\n\t[BOARD_PCIDAS6035] = {\n\t\t.name\t\t= \"pci-das6035\",\n\t\t.ai_se_chans\t= 16,\n\t\t.ai_bits\t= 16,\n\t\t.ai_speed\t= 5000,\n\t\t.ao_nchan\t= 2,\n\t\t.ao_bits\t= 12,\n\t\t.ao_scan_speed\t= 100000,\n\t\t.layout\t\t= LAYOUT_60XX,\n\t\t.ai_range_table\t= &ai_ranges_60xx,\n\t\t.ai_range_code\t= ai_range_code_60xx,\n\t\t.ao_range_table\t= &range_bipolar10,\n\t\t.ao_range_code\t= ao_range_code_60xx,\n\t\t.ai_fifo\t= &ai_fifo_60xx,\n\t\t.has_8255\t= 0,\n\t},\n\t[BOARD_PCIDAS6036] = {\n\t\t.name\t\t= \"pci-das6036\",\n\t\t.ai_se_chans\t= 16,\n\t\t.ai_bits\t= 16,\n\t\t.ai_speed\t= 5000,\n\t\t.ao_nchan\t= 2,\n\t\t.ao_bits\t= 16,\n\t\t.ao_scan_speed\t= 100000,\n\t\t.layout\t\t= LAYOUT_60XX,\n\t\t.ai_range_table\t= &ai_ranges_60xx,\n\t\t.ai_range_code\t= ai_range_code_60xx,\n\t\t.ao_range_table\t= &range_bipolar10,\n\t\t.ao_range_code\t= ao_range_code_60xx,\n\t\t.ai_fifo\t= &ai_fifo_60xx,\n\t\t.has_8255\t= 0,\n\t},\n\t[BOARD_PCIDAS6040] = {\n\t\t.name\t\t= \"pci-das6040\",\n\t\t.ai_se_chans\t= 16,\n\t\t.ai_bits\t= 12,\n\t\t.ai_speed\t= 2000,\n\t\t.ao_nchan\t= 2,\n\t\t.ao_bits\t= 12,\n\t\t.ao_scan_speed\t= 1000,\n\t\t.layout\t\t= LAYOUT_60XX,\n\t\t.ai_range_table\t= &ai_ranges_6052,\n\t\t.ai_range_code\t= ai_range_code_6052,\n\t\t.ao_range_table\t= &ao_ranges_6030,\n\t\t.ao_range_code\t= ao_range_code_6030,\n\t\t.ai_fifo\t= &ai_fifo_60xx,\n\t\t.has_8255\t= 0,\n\t},\n\t[BOARD_PCIDAS6052] = {\n\t\t.name\t\t= \"pci-das6052\",\n\t\t.ai_se_chans\t= 16,\n\t\t.ai_bits\t= 16,\n\t\t.ai_speed\t= 3333,\n\t\t.ao_nchan\t= 2,\n\t\t.ao_bits\t= 16,\n\t\t.ao_scan_speed\t= 3333,\n\t\t.layout\t\t= LAYOUT_60XX,\n\t\t.ai_range_table\t= &ai_ranges_6052,\n\t\t.ai_range_code\t= ai_range_code_6052,\n\t\t.ao_range_table\t= &ao_ranges_6030,\n\t\t.ao_range_code\t= ao_range_code_6030,\n\t\t.ai_fifo\t= &ai_fifo_60xx,\n\t\t.has_8255\t= 0,\n\t},\n\t[BOARD_PCIDAS6070] = {\n\t\t.name\t\t= \"pci-das6070\",\n\t\t.ai_se_chans\t= 16,\n\t\t.ai_bits\t= 12,\n\t\t.ai_speed\t= 800,\n\t\t.ao_nchan\t= 2,\n\t\t.ao_bits\t= 12,\n\t\t.ao_scan_speed\t= 1000,\n\t\t.layout\t\t= LAYOUT_60XX,\n\t\t.ai_range_table\t= &ai_ranges_6052,\n\t\t.ai_range_code\t= ai_range_code_6052,\n\t\t.ao_range_table\t= &ao_ranges_6030,\n\t\t.ao_range_code\t= ao_range_code_6030,\n\t\t.ai_fifo\t= &ai_fifo_60xx,\n\t\t.has_8255\t= 0,\n\t},\n\t[BOARD_PCIDAS6071] = {\n\t\t.name\t\t= \"pci-das6071\",\n\t\t.ai_se_chans\t= 64,\n\t\t.ai_bits\t= 12,\n\t\t.ai_speed\t= 800,\n\t\t.ao_nchan\t= 2,\n\t\t.ao_bits\t= 12,\n\t\t.ao_scan_speed\t= 1000,\n\t\t.layout\t\t= LAYOUT_60XX,\n\t\t.ai_range_table\t= &ai_ranges_6052,\n\t\t.ai_range_code\t= ai_range_code_6052,\n\t\t.ao_range_table\t= &ao_ranges_6030,\n\t\t.ao_range_code\t= ao_range_code_6030,\n\t\t.ai_fifo\t= &ai_fifo_60xx,\n\t\t.has_8255\t= 0,\n\t},\n\t[BOARD_PCIDAS4020_12] = {\n\t\t.name\t\t= \"pci-das4020/12\",\n\t\t.ai_se_chans\t= 4,\n\t\t.ai_bits\t= 12,\n\t\t.ai_speed\t= 50,\n\t\t.ao_bits\t= 12,\n\t\t.ao_nchan\t= 2,\n\t\t.ao_scan_speed\t= 0,\t \n\t\t.layout\t\t= LAYOUT_4020,\n\t\t.ai_range_table\t= &ai_ranges_4020,\n\t\t.ao_range_table\t= &ao_ranges_4020,\n\t\t.ao_range_code\t= ao_range_code_4020,\n\t\t.ai_fifo\t= &ai_fifo_4020,\n\t\t.has_8255\t= 1,\n\t},\n#if 0\n\t \n\n\t[BOARD_PCIDAS6402_16_JR] = {\n\t\t.name\t\t= \"pci-das6402/16/jr\",\n\t\t.ai_se_chans\t= 64,\n\t\t.ai_bits\t= 16,\n\t\t.ai_speed\t= 5000,\n\t\t.ao_nchan\t= 0,\n\t\t.ao_scan_speed\t= 10000,\n\t\t.layout\t\t= LAYOUT_64XX,\n\t\t.ai_range_table\t= &ai_ranges_64xx,\n\t\t.ai_range_code\t= ai_range_code_64xx,\n\t\t.ai_fifo\t= ai_fifo_64xx,\n\t\t.has_8255\t= 1,\n\t},\n\t[BOARD_PCIDAS64_M1_16_JR] = {\n\t\t.name\t\t= \"pci-das64/m1/16/jr\",\n\t\t.ai_se_chans\t= 64,\n\t\t.ai_bits\t= 16,\n\t\t.ai_speed\t= 1000,\n\t\t.ao_nchan\t= 0,\n\t\t.ao_scan_speed\t= 10000,\n\t\t.layout\t\t= LAYOUT_64XX,\n\t\t.ai_range_table\t= &ai_ranges_64_mx,\n\t\t.ai_range_code\t= ai_range_code_64_mx,\n\t\t.ai_fifo\t= ai_fifo_64xx,\n\t\t.has_8255\t= 1,\n\t},\n\t[BOARD_PCIDAS64_M2_16_JR] = {\n\t\t.name = \"pci-das64/m2/16/jr\",\n\t\t.ai_se_chans\t= 64,\n\t\t.ai_bits\t= 16,\n\t\t.ai_speed\t= 500,\n\t\t.ao_nchan\t= 0,\n\t\t.ao_scan_speed\t= 10000,\n\t\t.layout\t\t= LAYOUT_64XX,\n\t\t.ai_range_table\t= &ai_ranges_64_mx,\n\t\t.ai_range_code\t= ai_range_code_64_mx,\n\t\t.ai_fifo\t= ai_fifo_64xx,\n\t\t.has_8255\t= 1,\n\t},\n\t[BOARD_PCIDAS64_M3_16_JR] = {\n\t\t.name\t\t= \"pci-das64/m3/16/jr\",\n\t\t.ai_se_chans\t= 64,\n\t\t.ai_bits\t= 16,\n\t\t.ai_speed\t= 333,\n\t\t.ao_nchan\t= 0,\n\t\t.ao_scan_speed\t= 10000,\n\t\t.layout\t\t= LAYOUT_64XX,\n\t\t.ai_range_table\t= &ai_ranges_64_mx,\n\t\t.ai_range_code\t= ai_range_code_64_mx,\n\t\t.ai_fifo\t= ai_fifo_64xx,\n\t\t.has_8255\t= 1,\n\t},\n\t[BOARD_PCIDAS64_M1_14] = {\n\t\t.name\t\t= \"pci-das64/m1/14\",\n\t\t.ai_se_chans\t= 64,\n\t\t.ai_bits\t= 14,\n\t\t.ai_speed\t= 1000,\n\t\t.ao_nchan\t= 2,\n\t\t.ao_scan_speed\t= 10000,\n\t\t.layout\t\t= LAYOUT_64XX,\n\t\t.ai_range_table\t= &ai_ranges_64_mx,\n\t\t.ai_range_code\t= ai_range_code_64_mx,\n\t\t.ai_fifo\t= ai_fifo_64xx,\n\t\t.has_8255\t= 1,\n\t},\n\t[BOARD_PCIDAS64_M2_14] = {\n\t\t.name\t\t= \"pci-das64/m2/14\",\n\t\t.ai_se_chans\t= 64,\n\t\t.ai_bits\t= 14,\n\t\t.ai_speed\t= 500,\n\t\t.ao_nchan\t= 2,\n\t\t.ao_scan_speed\t= 10000,\n\t\t.layout\t\t= LAYOUT_64XX,\n\t\t.ai_range_table\t= &ai_ranges_64_mx,\n\t\t.ai_range_code\t= ai_range_code_64_mx,\n\t\t.ai_fifo\t= ai_fifo_64xx,\n\t\t.has_8255\t= 1,\n\t},\n\t[BOARD_PCIDAS64_M3_14] = {\n\t\t.name\t\t= \"pci-das64/m3/14\",\n\t\t.ai_se_chans\t= 64,\n\t\t.ai_bits\t= 14,\n\t\t.ai_speed\t= 333,\n\t\t.ao_nchan\t= 2,\n\t\t.ao_scan_speed\t= 10000,\n\t\t.layout\t\t= LAYOUT_64XX,\n\t\t.ai_range_table\t= &ai_ranges_64_mx,\n\t\t.ai_range_code\t= ai_range_code_64_mx,\n\t\t.ai_fifo\t= ai_fifo_64xx,\n\t\t.has_8255\t= 1,\n\t},\n#endif\n};\n\nstatic inline unsigned short se_diff_bit_6xxx(struct comedi_device *dev,\n\t\t\t\t\t      int use_differential)\n{\n\tconst struct pcidas64_board *board = dev->board_ptr;\n\n\tif ((board->layout == LAYOUT_64XX && !use_differential) ||\n\t    (board->layout == LAYOUT_60XX && use_differential))\n\t\treturn ADC_SE_DIFF_BIT;\n\n\treturn 0;\n}\n\nstruct ext_clock_info {\n\t \n\tunsigned int divisor;\n\t \n\tunsigned int chanspec;\n};\n\n \nstruct pcidas64_private {\n\t \n\tresource_size_t main_phys_iobase;\n\tresource_size_t dio_counter_phys_iobase;\n\t \n\tvoid __iomem *plx9080_iobase;\n\tvoid __iomem *main_iobase;\n\t \n\tu32 local0_iobase;\n\tu32 local1_iobase;\n\t \n\tu16 *ai_buffer[MAX_AI_DMA_RING_COUNT];\n\t \n\tdma_addr_t ai_buffer_bus_addr[MAX_AI_DMA_RING_COUNT];\n\t \n\tstruct plx_dma_desc *ai_dma_desc;\n\t \n\tdma_addr_t ai_dma_desc_bus_addr;\n\t \n\tunsigned int ai_dma_index;\n\t \n\tu16 *ao_buffer[AO_DMA_RING_COUNT];\n\t \n\tdma_addr_t ao_buffer_bus_addr[AO_DMA_RING_COUNT];\n\tstruct plx_dma_desc *ao_dma_desc;\n\tdma_addr_t ao_dma_desc_bus_addr;\n\t \n\tunsigned int ao_dma_index;\n\tunsigned int hw_revision;\t \n\t \n\tunsigned int intr_enable_bits;\n\t \n\tu16 adc_control1_bits;\n\t \n\tu16 fifo_size_bits;\n\t \n\tu16 hw_config_bits;\n\tu16 dac_control1_bits;\n\t \n\tu32 plx_control_bits;\n\t \n\tu32 plx_intcsr_bits;\n\t \n\tint calibration_source;\n\t \n\tu8 i2c_cal_range_bits;\n\t \n\tunsigned int ext_trig_falling;\n\tshort ai_cmd_running;\n\tunsigned int ai_fifo_segment_length;\n\tstruct ext_clock_info ext_clock;\n\tunsigned short ao_bounce_buffer[DAC_FIFO_SIZE];\n};\n\nstatic unsigned int ai_range_bits_6xxx(const struct comedi_device *dev,\n\t\t\t\t       unsigned int range_index)\n{\n\tconst struct pcidas64_board *board = dev->board_ptr;\n\n\treturn board->ai_range_code[range_index] << 8;\n}\n\nstatic unsigned int hw_revision(const struct comedi_device *dev,\n\t\t\t\tu16 hw_status_bits)\n{\n\tconst struct pcidas64_board *board = dev->board_ptr;\n\n\tif (board->layout == LAYOUT_4020)\n\t\treturn (hw_status_bits >> 13) & 0x7;\n\n\treturn (hw_status_bits >> 12) & 0xf;\n}\n\nstatic void set_dac_range_bits(struct comedi_device *dev,\n\t\t\t       u16 *bits, unsigned int channel,\n\t\t\t       unsigned int range)\n{\n\tconst struct pcidas64_board *board = dev->board_ptr;\n\tunsigned int code = board->ao_range_code[range];\n\n\tif (channel > 1)\n\t\tdev_err(dev->class_dev, \"bug! bad channel?\\n\");\n\tif (code & ~0x3)\n\t\tdev_err(dev->class_dev, \"bug! bad range code?\\n\");\n\n\t*bits &= ~(0x3 << (2 * channel));\n\t*bits |= code << (2 * channel);\n};\n\nstatic inline int ao_cmd_is_supported(const struct pcidas64_board *board)\n{\n\treturn board->ao_nchan && board->layout != LAYOUT_4020;\n}\n\nstatic void abort_dma(struct comedi_device *dev, unsigned int channel)\n{\n\tstruct pcidas64_private *devpriv = dev->private;\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&dev->spinlock, flags);\n\n\tplx9080_abort_dma(devpriv->plx9080_iobase, channel);\n\n\tspin_unlock_irqrestore(&dev->spinlock, flags);\n}\n\nstatic void disable_plx_interrupts(struct comedi_device *dev)\n{\n\tstruct pcidas64_private *devpriv = dev->private;\n\n\tdevpriv->plx_intcsr_bits = 0;\n\twritel(devpriv->plx_intcsr_bits,\n\t       devpriv->plx9080_iobase + PLX_REG_INTCSR);\n}\n\nstatic void disable_ai_interrupts(struct comedi_device *dev)\n{\n\tstruct pcidas64_private *devpriv = dev->private;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->spinlock, flags);\n\tdevpriv->intr_enable_bits &=\n\t\t~EN_ADC_INTR_SRC_BIT & ~EN_ADC_DONE_INTR_BIT &\n\t\t~EN_ADC_ACTIVE_INTR_BIT & ~EN_ADC_STOP_INTR_BIT &\n\t\t~EN_ADC_OVERRUN_BIT & ~ADC_INTR_SRC_MASK;\n\twritew(devpriv->intr_enable_bits,\n\t       devpriv->main_iobase + INTR_ENABLE_REG);\n\tspin_unlock_irqrestore(&dev->spinlock, flags);\n}\n\nstatic void enable_ai_interrupts(struct comedi_device *dev,\n\t\t\t\t const struct comedi_cmd *cmd)\n{\n\tconst struct pcidas64_board *board = dev->board_ptr;\n\tstruct pcidas64_private *devpriv = dev->private;\n\tu32 bits;\n\tunsigned long flags;\n\n\tbits = EN_ADC_OVERRUN_BIT | EN_ADC_DONE_INTR_BIT |\n\t       EN_ADC_ACTIVE_INTR_BIT | EN_ADC_STOP_INTR_BIT;\n\t \n\tif (cmd->flags & CMDF_WAKE_EOS) {\n\t\t \n\t\tif (board->layout != LAYOUT_4020)\n\t\t\tbits |= ADC_INTR_EOSCAN_BITS | EN_ADC_INTR_SRC_BIT;\n\t}\n\tspin_lock_irqsave(&dev->spinlock, flags);\n\tdevpriv->intr_enable_bits |= bits;\n\twritew(devpriv->intr_enable_bits,\n\t       devpriv->main_iobase + INTR_ENABLE_REG);\n\tspin_unlock_irqrestore(&dev->spinlock, flags);\n}\n\n \nstatic void init_plx9080(struct comedi_device *dev)\n{\n\tconst struct pcidas64_board *board = dev->board_ptr;\n\tstruct pcidas64_private *devpriv = dev->private;\n\tu32 bits;\n\tvoid __iomem *plx_iobase = devpriv->plx9080_iobase;\n\n\tdevpriv->plx_control_bits =\n\t\treadl(devpriv->plx9080_iobase + PLX_REG_CNTRL);\n\n#ifdef __BIG_ENDIAN\n\tbits = PLX_BIGEND_DMA0 | PLX_BIGEND_DMA1;\n#else\n\tbits = 0;\n#endif\n\twritel(bits, devpriv->plx9080_iobase + PLX_REG_BIGEND);\n\n\tdisable_plx_interrupts(dev);\n\n\tabort_dma(dev, 0);\n\tabort_dma(dev, 1);\n\n\t \n\tbits = 0;\n\t \n\tbits |= PLX_DMAMODE_READYIEN;\n\t \n\tbits |= PLX_DMAMODE_BTERMIEN;\n\t \n\tbits |= PLX_DMAMODE_CHAINEN;\n\t \n\tbits |= PLX_DMAMODE_DONEIEN;\n\t \n\tbits |= PLX_DMAMODE_LACONST;\n\t \n\tbits |= PLX_DMAMODE_INTRPCI;\n\t \n\tbits |= PLX_DMAMODE_DEMAND;\n\t \n\tbits |= PLX_DMAMODE_BURSTEN;\n\t \n\tif (board->layout == LAYOUT_4020)\n\t\tbits |= PLX_DMAMODE_WIDTH_32;\n\telse\t\t\t\t \n\t\tbits |= PLX_DMAMODE_WIDTH_16;\n\twritel(bits, plx_iobase + PLX_REG_DMAMODE1);\n\tif (ao_cmd_is_supported(board))\n\t\twritel(bits, plx_iobase + PLX_REG_DMAMODE0);\n\n\t \n\tdevpriv->plx_intcsr_bits |=\n\t    PLX_INTCSR_LSEABORTEN | PLX_INTCSR_LSEPARITYEN | PLX_INTCSR_PIEN |\n\t    PLX_INTCSR_PLIEN | PLX_INTCSR_PABORTIEN | PLX_INTCSR_LIOEN |\n\t    PLX_INTCSR_DMA0IEN | PLX_INTCSR_DMA1IEN;\n\twritel(devpriv->plx_intcsr_bits,\n\t       devpriv->plx9080_iobase + PLX_REG_INTCSR);\n}\n\nstatic void disable_ai_pacing(struct comedi_device *dev)\n{\n\tstruct pcidas64_private *devpriv = dev->private;\n\tunsigned long flags;\n\n\tdisable_ai_interrupts(dev);\n\n\tspin_lock_irqsave(&dev->spinlock, flags);\n\tdevpriv->adc_control1_bits &= ~ADC_SW_GATE_BIT;\n\twritew(devpriv->adc_control1_bits,\n\t       devpriv->main_iobase + ADC_CONTROL1_REG);\n\tspin_unlock_irqrestore(&dev->spinlock, flags);\n\n\t \n\twritew(ADC_DMA_DISABLE_BIT | ADC_SOFT_GATE_BITS | ADC_GATE_LEVEL_BIT,\n\t       devpriv->main_iobase + ADC_CONTROL0_REG);\n}\n\nstatic int set_ai_fifo_segment_length(struct comedi_device *dev,\n\t\t\t\t      unsigned int num_entries)\n{\n\tconst struct pcidas64_board *board = dev->board_ptr;\n\tstruct pcidas64_private *devpriv = dev->private;\n\tstatic const int increment_size = 0x100;\n\tconst struct hw_fifo_info *const fifo = board->ai_fifo;\n\tunsigned int num_increments;\n\tu16 bits;\n\n\tif (num_entries < increment_size)\n\t\tnum_entries = increment_size;\n\tif (num_entries > fifo->max_segment_length)\n\t\tnum_entries = fifo->max_segment_length;\n\n\t \n\tnum_increments = DIV_ROUND_CLOSEST(num_entries, increment_size);\n\n\tbits = (~(num_increments - 1)) & fifo->fifo_size_reg_mask;\n\tdevpriv->fifo_size_bits &= ~fifo->fifo_size_reg_mask;\n\tdevpriv->fifo_size_bits |= bits;\n\twritew(devpriv->fifo_size_bits,\n\t       devpriv->main_iobase + FIFO_SIZE_REG);\n\n\tdevpriv->ai_fifo_segment_length = num_increments * increment_size;\n\n\treturn devpriv->ai_fifo_segment_length;\n}\n\n \nstatic int set_ai_fifo_size(struct comedi_device *dev, unsigned int num_samples)\n{\n\tconst struct pcidas64_board *board = dev->board_ptr;\n\tunsigned int num_fifo_entries;\n\tint retval;\n\tconst struct hw_fifo_info *const fifo = board->ai_fifo;\n\n\tnum_fifo_entries = num_samples / fifo->sample_packing_ratio;\n\n\tretval = set_ai_fifo_segment_length(dev,\n\t\t\t\t\t    num_fifo_entries /\n\t\t\t\t\t    fifo->num_segments);\n\tif (retval < 0)\n\t\treturn retval;\n\n\treturn retval * fifo->num_segments * fifo->sample_packing_ratio;\n}\n\n \nstatic unsigned int ai_fifo_size(struct comedi_device *dev)\n{\n\tconst struct pcidas64_board *board = dev->board_ptr;\n\tstruct pcidas64_private *devpriv = dev->private;\n\n\treturn devpriv->ai_fifo_segment_length *\n\t       board->ai_fifo->num_segments *\n\t       board->ai_fifo->sample_packing_ratio;\n}\n\nstatic void init_stc_registers(struct comedi_device *dev)\n{\n\tconst struct pcidas64_board *board = dev->board_ptr;\n\tstruct pcidas64_private *devpriv = dev->private;\n\tu16 bits;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->spinlock, flags);\n\n\t \n\tif (1)\n\t\tdevpriv->adc_control1_bits |= ADC_QUEUE_CONFIG_BIT;\n\twritew(devpriv->adc_control1_bits,\n\t       devpriv->main_iobase + ADC_CONTROL1_REG);\n\n\t \n\twritew(0xff, devpriv->main_iobase + ADC_SAMPLE_INTERVAL_UPPER_REG);\n\n\tbits = SLOW_DAC_BIT | DMA_CH_SELECT_BIT;\n\tif (board->layout == LAYOUT_4020)\n\t\tbits |= INTERNAL_CLOCK_4020_BITS;\n\tdevpriv->hw_config_bits |= bits;\n\twritew(devpriv->hw_config_bits,\n\t       devpriv->main_iobase + HW_CONFIG_REG);\n\n\twritew(0, devpriv->main_iobase + DAQ_SYNC_REG);\n\twritew(0, devpriv->main_iobase + CALIBRATION_REG);\n\n\tspin_unlock_irqrestore(&dev->spinlock, flags);\n\n\t \n\tdevpriv->fifo_size_bits |= DAC_FIFO_BITS;\n\tset_ai_fifo_segment_length(dev, board->ai_fifo->max_segment_length);\n\n\tdevpriv->dac_control1_bits = DAC_OUTPUT_ENABLE_BIT;\n\tdevpriv->intr_enable_bits =\n\t\t \n\t\tEN_DAC_DONE_INTR_BIT | EN_DAC_UNDERRUN_BIT;\n\twritew(devpriv->intr_enable_bits,\n\t       devpriv->main_iobase + INTR_ENABLE_REG);\n\n\tdisable_ai_pacing(dev);\n};\n\nstatic int alloc_and_init_dma_members(struct comedi_device *dev)\n{\n\tconst struct pcidas64_board *board = dev->board_ptr;\n\tstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\n\tstruct pcidas64_private *devpriv = dev->private;\n\tint i;\n\n\t \n\tfor (i = 0; i < ai_dma_ring_count(board); i++) {\n\t\tdevpriv->ai_buffer[i] =\n\t\t\tdma_alloc_coherent(&pcidev->dev, DMA_BUFFER_SIZE,\n\t\t\t\t\t   &devpriv->ai_buffer_bus_addr[i],\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!devpriv->ai_buffer[i])\n\t\t\treturn -ENOMEM;\n\t}\n\tfor (i = 0; i < AO_DMA_RING_COUNT; i++) {\n\t\tif (ao_cmd_is_supported(board)) {\n\t\t\tdevpriv->ao_buffer[i] =\n\t\t\t    dma_alloc_coherent(&pcidev->dev,\n\t\t\t\t\t       DMA_BUFFER_SIZE,\n\t\t\t\t\t       &devpriv->ao_buffer_bus_addr[i],\n\t\t\t\t\t       GFP_KERNEL);\n\t\t\tif (!devpriv->ao_buffer[i])\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\t \n\tdevpriv->ai_dma_desc =\n\t\tdma_alloc_coherent(&pcidev->dev, sizeof(struct plx_dma_desc) *\n\t\t\t\t   ai_dma_ring_count(board),\n\t\t\t\t   &devpriv->ai_dma_desc_bus_addr, GFP_KERNEL);\n\tif (!devpriv->ai_dma_desc)\n\t\treturn -ENOMEM;\n\n\tif (ao_cmd_is_supported(board)) {\n\t\tdevpriv->ao_dma_desc =\n\t\t\tdma_alloc_coherent(&pcidev->dev,\n\t\t\t\t\t   sizeof(struct plx_dma_desc) *\n\t\t\t\t\t   AO_DMA_RING_COUNT,\n\t\t\t\t\t   &devpriv->ao_dma_desc_bus_addr,\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!devpriv->ao_dma_desc)\n\t\t\treturn -ENOMEM;\n\t}\n\t \n\tfor (i = 0; i < ai_dma_ring_count(board); i++) {\n\t\tdevpriv->ai_dma_desc[i].pci_start_addr =\n\t\t\tcpu_to_le32(devpriv->ai_buffer_bus_addr[i]);\n\t\tif (board->layout == LAYOUT_4020)\n\t\t\tdevpriv->ai_dma_desc[i].local_start_addr =\n\t\t\t\tcpu_to_le32(devpriv->local1_iobase +\n\t\t\t\t\t    ADC_FIFO_REG);\n\t\telse\n\t\t\tdevpriv->ai_dma_desc[i].local_start_addr =\n\t\t\t\tcpu_to_le32(devpriv->local0_iobase +\n\t\t\t\t\t    ADC_FIFO_REG);\n\t\tdevpriv->ai_dma_desc[i].transfer_size = cpu_to_le32(0);\n\t\tdevpriv->ai_dma_desc[i].next =\n\t\t\tcpu_to_le32((devpriv->ai_dma_desc_bus_addr +\n\t\t\t\t     ((i + 1) % ai_dma_ring_count(board)) *\n\t\t\t\t     sizeof(devpriv->ai_dma_desc[0])) |\n\t\t\t\t    PLX_DMADPR_DESCPCI | PLX_DMADPR_TCINTR |\n\t\t\t\t    PLX_DMADPR_XFERL2P);\n\t}\n\tif (ao_cmd_is_supported(board)) {\n\t\tfor (i = 0; i < AO_DMA_RING_COUNT; i++) {\n\t\t\tdevpriv->ao_dma_desc[i].pci_start_addr =\n\t\t\t\tcpu_to_le32(devpriv->ao_buffer_bus_addr[i]);\n\t\t\tdevpriv->ao_dma_desc[i].local_start_addr =\n\t\t\t\tcpu_to_le32(devpriv->local0_iobase +\n\t\t\t\t\t    DAC_FIFO_REG);\n\t\t\tdevpriv->ao_dma_desc[i].transfer_size = cpu_to_le32(0);\n\t\t\tdevpriv->ao_dma_desc[i].next =\n\t\t\t\tcpu_to_le32((devpriv->ao_dma_desc_bus_addr +\n\t\t\t\t\t     ((i + 1) % (AO_DMA_RING_COUNT)) *\n\t\t\t\t\t     sizeof(devpriv->ao_dma_desc[0])) |\n\t\t\t\t\t    PLX_DMADPR_DESCPCI |\n\t\t\t\t\t    PLX_DMADPR_TCINTR);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void cb_pcidas64_free_dma(struct comedi_device *dev)\n{\n\tconst struct pcidas64_board *board = dev->board_ptr;\n\tstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\n\tstruct pcidas64_private *devpriv = dev->private;\n\tint i;\n\n\tif (!devpriv)\n\t\treturn;\n\n\t \n\tfor (i = 0; i < ai_dma_ring_count(board); i++) {\n\t\tif (devpriv->ai_buffer[i])\n\t\t\tdma_free_coherent(&pcidev->dev,\n\t\t\t\t\t  DMA_BUFFER_SIZE,\n\t\t\t\t\t  devpriv->ai_buffer[i],\n\t\t\t\t\t  devpriv->ai_buffer_bus_addr[i]);\n\t}\n\tfor (i = 0; i < AO_DMA_RING_COUNT; i++) {\n\t\tif (devpriv->ao_buffer[i])\n\t\t\tdma_free_coherent(&pcidev->dev,\n\t\t\t\t\t  DMA_BUFFER_SIZE,\n\t\t\t\t\t  devpriv->ao_buffer[i],\n\t\t\t\t\t  devpriv->ao_buffer_bus_addr[i]);\n\t}\n\t \n\tif (devpriv->ai_dma_desc)\n\t\tdma_free_coherent(&pcidev->dev,\n\t\t\t\t  sizeof(struct plx_dma_desc) *\n\t\t\t\t  ai_dma_ring_count(board),\n\t\t\t\t  devpriv->ai_dma_desc,\n\t\t\t\t  devpriv->ai_dma_desc_bus_addr);\n\tif (devpriv->ao_dma_desc)\n\t\tdma_free_coherent(&pcidev->dev,\n\t\t\t\t  sizeof(struct plx_dma_desc) *\n\t\t\t\t  AO_DMA_RING_COUNT,\n\t\t\t\t  devpriv->ao_dma_desc,\n\t\t\t\t  devpriv->ao_dma_desc_bus_addr);\n}\n\nstatic inline void warn_external_queue(struct comedi_device *dev)\n{\n\tdev_err(dev->class_dev,\n\t\t\"AO command and AI external channel queue cannot be used simultaneously\\n\");\n\tdev_err(dev->class_dev,\n\t\t\"Use internal AI channel queue (channels must be consecutive and use same range/aref)\\n\");\n}\n\n \nstatic const int i2c_high_udelay = 1000;\nstatic const int i2c_low_udelay = 10;\n\n \nstatic void i2c_set_sda(struct comedi_device *dev, int state)\n{\n\tstruct pcidas64_private *devpriv = dev->private;\n\tstatic const int data_bit = PLX_CNTRL_EEWB;\n\tvoid __iomem *plx_control_addr = devpriv->plx9080_iobase +\n\t\t\t\t\t PLX_REG_CNTRL;\n\n\tif (state) {\t\t\t\t \n\t\tdevpriv->plx_control_bits &= ~data_bit;\n\t\twritel(devpriv->plx_control_bits, plx_control_addr);\n\t\tudelay(i2c_high_udelay);\n\t} else {\t\t\t\t \n\t\tdevpriv->plx_control_bits |= data_bit;\n\t\twritel(devpriv->plx_control_bits, plx_control_addr);\n\t\tudelay(i2c_low_udelay);\n\t}\n}\n\n \nstatic void i2c_set_scl(struct comedi_device *dev, int state)\n{\n\tstruct pcidas64_private *devpriv = dev->private;\n\tstatic const int clock_bit = PLX_CNTRL_USERO;\n\tvoid __iomem *plx_control_addr = devpriv->plx9080_iobase +\n\t\t\t\t\t PLX_REG_CNTRL;\n\n\tif (state) {\t\t\t\t \n\t\tdevpriv->plx_control_bits &= ~clock_bit;\n\t\twritel(devpriv->plx_control_bits, plx_control_addr);\n\t\tudelay(i2c_high_udelay);\n\t} else {\t\t\t\t \n\t\tdevpriv->plx_control_bits |= clock_bit;\n\t\twritel(devpriv->plx_control_bits, plx_control_addr);\n\t\tudelay(i2c_low_udelay);\n\t}\n}\n\nstatic void i2c_write_byte(struct comedi_device *dev, u8 byte)\n{\n\tu8 bit;\n\tunsigned int num_bits = 8;\n\n\tfor (bit = 1 << (num_bits - 1); bit; bit >>= 1) {\n\t\ti2c_set_scl(dev, 0);\n\t\tif ((byte & bit))\n\t\t\ti2c_set_sda(dev, 1);\n\t\telse\n\t\t\ti2c_set_sda(dev, 0);\n\t\ti2c_set_scl(dev, 1);\n\t}\n}\n\n \nstatic int i2c_read_ack(struct comedi_device *dev)\n{\n\ti2c_set_scl(dev, 0);\n\ti2c_set_sda(dev, 1);\n\ti2c_set_scl(dev, 1);\n\n\treturn 0;\t\t \n}\n\n \nstatic void i2c_start(struct comedi_device *dev)\n{\n\ti2c_set_scl(dev, 1);\n\ti2c_set_sda(dev, 1);\n\ti2c_set_sda(dev, 0);\n}\n\n \nstatic void i2c_stop(struct comedi_device *dev)\n{\n\ti2c_set_scl(dev, 0);\n\ti2c_set_sda(dev, 0);\n\ti2c_set_scl(dev, 1);\n\ti2c_set_sda(dev, 1);\n}\n\nstatic void i2c_write(struct comedi_device *dev, unsigned int address,\n\t\t      const u8 *data, unsigned int length)\n{\n\tstruct pcidas64_private *devpriv = dev->private;\n\tunsigned int i;\n\tu8 bitstream;\n\tstatic const int read_bit = 0x1;\n\n\t \n\n\t \n\tdevpriv->plx_control_bits &= ~PLX_CNTRL_EECS;\n\n\ti2c_stop(dev);\n\ti2c_start(dev);\n\n\t \n\tbitstream = (address << 1) & ~read_bit;\n\ti2c_write_byte(dev, bitstream);\n\n\t \n\tif (i2c_read_ack(dev) != 0) {\n\t\tdev_err(dev->class_dev, \"failed: no acknowledge\\n\");\n\t\ti2c_stop(dev);\n\t\treturn;\n\t}\n\t \n\tfor (i = 0; i < length; i++) {\n\t\ti2c_write_byte(dev, data[i]);\n\t\tif (i2c_read_ack(dev) != 0) {\n\t\t\tdev_err(dev->class_dev, \"failed: no acknowledge\\n\");\n\t\t\ti2c_stop(dev);\n\t\t\treturn;\n\t\t}\n\t}\n\ti2c_stop(dev);\n}\n\nstatic int cb_pcidas64_ai_eoc(struct comedi_device *dev,\n\t\t\t      struct comedi_subdevice *s,\n\t\t\t      struct comedi_insn *insn,\n\t\t\t      unsigned long context)\n{\n\tconst struct pcidas64_board *board = dev->board_ptr;\n\tstruct pcidas64_private *devpriv = dev->private;\n\tunsigned int status;\n\n\tstatus = readw(devpriv->main_iobase + HW_STATUS_REG);\n\tif (board->layout == LAYOUT_4020) {\n\t\tstatus = readw(devpriv->main_iobase + ADC_WRITE_PNTR_REG);\n\t\tif (status)\n\t\t\treturn 0;\n\t} else {\n\t\tif (pipe_full_bits(status))\n\t\t\treturn 0;\n\t}\n\treturn -EBUSY;\n}\n\nstatic int ai_rinsn(struct comedi_device *dev, struct comedi_subdevice *s,\n\t\t    struct comedi_insn *insn, unsigned int *data)\n{\n\tconst struct pcidas64_board *board = dev->board_ptr;\n\tstruct pcidas64_private *devpriv = dev->private;\n\tunsigned int bits = 0, n;\n\tunsigned int channel, range, aref;\n\tunsigned long flags;\n\tint ret;\n\n\tchannel = CR_CHAN(insn->chanspec);\n\trange = CR_RANGE(insn->chanspec);\n\taref = CR_AREF(insn->chanspec);\n\n\t \n\t \n\tdisable_ai_pacing(dev);\n\n\tspin_lock_irqsave(&dev->spinlock, flags);\n\tif (insn->chanspec & CR_ALT_FILTER)\n\t\tdevpriv->adc_control1_bits |= ADC_DITHER_BIT;\n\telse\n\t\tdevpriv->adc_control1_bits &= ~ADC_DITHER_BIT;\n\twritew(devpriv->adc_control1_bits,\n\t       devpriv->main_iobase + ADC_CONTROL1_REG);\n\tspin_unlock_irqrestore(&dev->spinlock, flags);\n\n\tif (board->layout != LAYOUT_4020) {\n\t\t \n\t\tdevpriv->hw_config_bits &= ~EXT_QUEUE_BIT;\n\t\twritew(devpriv->hw_config_bits,\n\t\t       devpriv->main_iobase + HW_CONFIG_REG);\n\n\t\t \n\t\tif (insn->chanspec & CR_ALT_SOURCE) {\n\t\t\tunsigned int cal_en_bit;\n\n\t\t\tif (board->layout == LAYOUT_60XX)\n\t\t\t\tcal_en_bit = CAL_EN_60XX_BIT;\n\t\t\telse\n\t\t\t\tcal_en_bit = CAL_EN_64XX_BIT;\n\t\t\t \n\t\t\twritew(cal_en_bit |\n\t\t\t       adc_src_bits(devpriv->calibration_source),\n\t\t\t       devpriv->main_iobase + CALIBRATION_REG);\n\t\t} else {\n\t\t\t \n\t\t\twritew(0, devpriv->main_iobase + CALIBRATION_REG);\n\t\t}\n\t\t \n\t\tbits = 0;\n\t\t \n\t\tbits |= ai_range_bits_6xxx(dev, CR_RANGE(insn->chanspec));\n\t\t \n\t\tbits |= se_diff_bit_6xxx(dev, aref == AREF_DIFF);\n\t\tif (aref == AREF_COMMON)\n\t\t\tbits |= ADC_COMMON_BIT;\n\t\tbits |= adc_chan_bits(channel);\n\t\t \n\t\twritew(adc_chan_bits(channel),\n\t\t       devpriv->main_iobase + ADC_QUEUE_HIGH_REG);\n\t\t \n\t\twritew(bits, devpriv->main_iobase + ADC_QUEUE_LOAD_REG);\n\t} else {\n\t\tu8 old_cal_range_bits = devpriv->i2c_cal_range_bits;\n\n\t\tdevpriv->i2c_cal_range_bits &= ~ADC_SRC_4020_MASK;\n\t\tif (insn->chanspec & CR_ALT_SOURCE) {\n\t\t\tdevpriv->i2c_cal_range_bits |=\n\t\t\t\tadc_src_4020_bits(devpriv->calibration_source);\n\t\t} else {\t \n\t\t\tdevpriv->i2c_cal_range_bits |= adc_src_4020_bits(4);\n\t\t}\n\t\t \n\t\tif (range == 0)\n\t\t\tdevpriv->i2c_cal_range_bits |= attenuate_bit(channel);\n\t\telse\n\t\t\tdevpriv->i2c_cal_range_bits &= ~attenuate_bit(channel);\n\t\t \n\t\tif (old_cal_range_bits != devpriv->i2c_cal_range_bits) {\n\t\t\tu8 i2c_data = devpriv->i2c_cal_range_bits;\n\n\t\t\ti2c_write(dev, RANGE_CAL_I2C_ADDR, &i2c_data,\n\t\t\t\t  sizeof(i2c_data));\n\t\t}\n\n\t\t \n\t\twritew(0, devpriv->main_iobase + ADC_SAMPLE_INTERVAL_UPPER_REG);\n\t\twritew(2, devpriv->main_iobase + ADC_SAMPLE_INTERVAL_LOWER_REG);\n\t}\n\n\tfor (n = 0; n < insn->n; n++) {\n\t\t \n\t\twritew(0, devpriv->main_iobase + ADC_BUFFER_CLEAR_REG);\n\n\t\t \n\t\twritew(adc_convert_chan_4020_bits(CR_CHAN(insn->chanspec)),\n\t\t       devpriv->main_iobase + ADC_CONVERT_REG);\n\n\t\t \n\t\tret = comedi_timeout(dev, s, insn, cb_pcidas64_ai_eoc, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (board->layout == LAYOUT_4020)\n\t\t\tdata[n] = readl(dev->mmio + ADC_FIFO_REG) & 0xffff;\n\t\telse\n\t\t\tdata[n] = readw(devpriv->main_iobase + PIPE1_READ_REG);\n\t}\n\n\treturn n;\n}\n\nstatic int ai_config_calibration_source(struct comedi_device *dev,\n\t\t\t\t\tunsigned int *data)\n{\n\tconst struct pcidas64_board *board = dev->board_ptr;\n\tstruct pcidas64_private *devpriv = dev->private;\n\tunsigned int source = data[1];\n\tint num_calibration_sources;\n\n\tif (board->layout == LAYOUT_60XX)\n\t\tnum_calibration_sources = 16;\n\telse\n\t\tnum_calibration_sources = 8;\n\tif (source >= num_calibration_sources) {\n\t\tdev_dbg(dev->class_dev, \"invalid calibration source: %i\\n\",\n\t\t\tsource);\n\t\treturn -EINVAL;\n\t}\n\n\tdevpriv->calibration_source = source;\n\n\treturn 2;\n}\n\nstatic int ai_config_block_size(struct comedi_device *dev, unsigned int *data)\n{\n\tconst struct pcidas64_board *board = dev->board_ptr;\n\tint fifo_size;\n\tconst struct hw_fifo_info *const fifo = board->ai_fifo;\n\tunsigned int block_size, requested_block_size;\n\tint retval;\n\n\trequested_block_size = data[1];\n\n\tif (requested_block_size) {\n\t\tfifo_size = requested_block_size * fifo->num_segments /\n\t\t\t    bytes_in_sample;\n\n\t\tretval = set_ai_fifo_size(dev, fifo_size);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\n\tblock_size = ai_fifo_size(dev) / fifo->num_segments * bytes_in_sample;\n\n\tdata[1] = block_size;\n\n\treturn 2;\n}\n\nstatic int ai_config_master_clock_4020(struct comedi_device *dev,\n\t\t\t\t       unsigned int *data)\n{\n\tstruct pcidas64_private *devpriv = dev->private;\n\tunsigned int divisor = data[4];\n\tint retval = 0;\n\n\tif (divisor < 2) {\n\t\tdivisor = 2;\n\t\tretval = -EAGAIN;\n\t}\n\n\tswitch (data[1]) {\n\tcase COMEDI_EV_SCAN_BEGIN:\n\t\tdevpriv->ext_clock.divisor = divisor;\n\t\tdevpriv->ext_clock.chanspec = data[2];\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tdata[4] = divisor;\n\n\treturn retval ? retval : 5;\n}\n\n \nstatic int ai_config_master_clock(struct comedi_device *dev, unsigned int *data)\n{\n\tconst struct pcidas64_board *board = dev->board_ptr;\n\n\tswitch (board->layout) {\n\tcase LAYOUT_4020:\n\t\treturn ai_config_master_clock_4020(dev, data);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int ai_config_insn(struct comedi_device *dev, struct comedi_subdevice *s,\n\t\t\t  struct comedi_insn *insn, unsigned int *data)\n{\n\tint id = data[0];\n\n\tswitch (id) {\n\tcase INSN_CONFIG_ALT_SOURCE:\n\t\treturn ai_config_calibration_source(dev, data);\n\tcase INSN_CONFIG_BLOCK_SIZE:\n\t\treturn ai_config_block_size(dev, data);\n\tcase INSN_CONFIG_TIMER_1:\n\t\treturn ai_config_master_clock(dev, data);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn -EINVAL;\n}\n\n \nstatic unsigned int get_divisor(unsigned int ns, unsigned int flags)\n{\n\tunsigned int divisor;\n\n\tswitch (flags & CMDF_ROUND_MASK) {\n\tcase CMDF_ROUND_UP:\n\t\tdivisor = DIV_ROUND_UP(ns, TIMER_BASE);\n\t\tbreak;\n\tcase CMDF_ROUND_DOWN:\n\t\tdivisor = ns / TIMER_BASE;\n\t\tbreak;\n\tcase CMDF_ROUND_NEAREST:\n\tdefault:\n\t\tdivisor = DIV_ROUND_CLOSEST(ns, TIMER_BASE);\n\t\tbreak;\n\t}\n\treturn divisor;\n}\n\n \nstatic void check_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd)\n{\n\tconst struct pcidas64_board *board = dev->board_ptr;\n\tunsigned long long convert_divisor = 0;\n\tunsigned int scan_divisor;\n\tstatic const int min_convert_divisor = 3;\n\tstatic const int max_convert_divisor =\n\t\tmax_counter_value + min_convert_divisor;\n\tstatic const int min_scan_divisor_4020 = 2;\n\tunsigned long long max_scan_divisor, min_scan_divisor;\n\n\tif (cmd->convert_src == TRIG_TIMER) {\n\t\tif (board->layout == LAYOUT_4020) {\n\t\t\tcmd->convert_arg = 0;\n\t\t} else {\n\t\t\tconvert_divisor = get_divisor(cmd->convert_arg,\n\t\t\t\t\t\t      cmd->flags);\n\t\t\tif (convert_divisor > max_convert_divisor)\n\t\t\t\tconvert_divisor = max_convert_divisor;\n\t\t\tif (convert_divisor < min_convert_divisor)\n\t\t\t\tconvert_divisor = min_convert_divisor;\n\t\t\tcmd->convert_arg = convert_divisor * TIMER_BASE;\n\t\t}\n\t} else if (cmd->convert_src == TRIG_NOW) {\n\t\tcmd->convert_arg = 0;\n\t}\n\n\tif (cmd->scan_begin_src == TRIG_TIMER) {\n\t\tscan_divisor = get_divisor(cmd->scan_begin_arg, cmd->flags);\n\t\tif (cmd->convert_src == TRIG_TIMER) {\n\t\t\tmin_scan_divisor = convert_divisor * cmd->chanlist_len;\n\t\t\tmax_scan_divisor =\n\t\t\t\t(convert_divisor * cmd->chanlist_len - 1) +\n\t\t\t\tmax_counter_value;\n\t\t} else {\n\t\t\tmin_scan_divisor = min_scan_divisor_4020;\n\t\t\tmax_scan_divisor = max_counter_value + min_scan_divisor;\n\t\t}\n\t\tif (scan_divisor > max_scan_divisor)\n\t\t\tscan_divisor = max_scan_divisor;\n\t\tif (scan_divisor < min_scan_divisor)\n\t\t\tscan_divisor = min_scan_divisor;\n\t\tcmd->scan_begin_arg = scan_divisor * TIMER_BASE;\n\t}\n}\n\nstatic int cb_pcidas64_ai_check_chanlist(struct comedi_device *dev,\n\t\t\t\t\t struct comedi_subdevice *s,\n\t\t\t\t\t struct comedi_cmd *cmd)\n{\n\tconst struct pcidas64_board *board = dev->board_ptr;\n\tunsigned int aref0 = CR_AREF(cmd->chanlist[0]);\n\tint i;\n\n\tfor (i = 1; i < cmd->chanlist_len; i++) {\n\t\tunsigned int aref = CR_AREF(cmd->chanlist[i]);\n\n\t\tif (aref != aref0) {\n\t\t\tdev_dbg(dev->class_dev,\n\t\t\t\t\"all elements in chanlist must use the same analog reference\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (board->layout == LAYOUT_4020) {\n\t\tunsigned int chan0 = CR_CHAN(cmd->chanlist[0]);\n\n\t\tfor (i = 1; i < cmd->chanlist_len; i++) {\n\t\t\tunsigned int chan = CR_CHAN(cmd->chanlist[i]);\n\n\t\t\tif (chan != (chan0 + i)) {\n\t\t\t\tdev_dbg(dev->class_dev,\n\t\t\t\t\t\"chanlist must use consecutive channels\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tif (cmd->chanlist_len == 3) {\n\t\t\tdev_dbg(dev->class_dev,\n\t\t\t\t\"chanlist cannot be 3 channels long, use 1, 2, or 4 channels\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ai_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,\n\t\t      struct comedi_cmd *cmd)\n{\n\tconst struct pcidas64_board *board = dev->board_ptr;\n\tint err = 0;\n\tunsigned int tmp_arg, tmp_arg2;\n\tunsigned int triggers;\n\n\t \n\n\terr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_EXT);\n\n\ttriggers = TRIG_TIMER;\n\tif (board->layout == LAYOUT_4020)\n\t\ttriggers |= TRIG_OTHER;\n\telse\n\t\ttriggers |= TRIG_FOLLOW;\n\terr |= comedi_check_trigger_src(&cmd->scan_begin_src, triggers);\n\n\ttriggers = TRIG_TIMER;\n\tif (board->layout == LAYOUT_4020)\n\t\ttriggers |= TRIG_NOW;\n\telse\n\t\ttriggers |= TRIG_EXT;\n\terr |= comedi_check_trigger_src(&cmd->convert_src, triggers);\n\terr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\n\terr |= comedi_check_trigger_src(&cmd->stop_src,\n\t\t\t\t\tTRIG_COUNT | TRIG_EXT | TRIG_NONE);\n\n\tif (err)\n\t\treturn 1;\n\n\t \n\n\terr |= comedi_check_trigger_is_unique(cmd->start_src);\n\terr |= comedi_check_trigger_is_unique(cmd->scan_begin_src);\n\terr |= comedi_check_trigger_is_unique(cmd->convert_src);\n\terr |= comedi_check_trigger_is_unique(cmd->stop_src);\n\n\t \n\n\tif (cmd->convert_src == TRIG_EXT && cmd->scan_begin_src == TRIG_TIMER)\n\t\terr |= -EINVAL;\n\n\tif (err)\n\t\treturn 2;\n\n\t \n\n\tswitch (cmd->start_src) {\n\tcase TRIG_NOW:\n\t\terr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\n\t\tbreak;\n\tcase TRIG_EXT:\n\t\t \n\t\tbreak;\n\t}\n\n\tif (cmd->convert_src == TRIG_TIMER) {\n\t\tif (board->layout == LAYOUT_4020) {\n\t\t\terr |= comedi_check_trigger_arg_is(&cmd->convert_arg,\n\t\t\t\t\t\t\t   0);\n\t\t} else {\n\t\t\terr |= comedi_check_trigger_arg_min(&cmd->convert_arg,\n\t\t\t\t\t\t\t    board->ai_speed);\n\t\t\t \n\t\t\tif (cmd->scan_begin_src == TRIG_TIMER) {\n\t\t\t\terr |= comedi_check_trigger_arg_min(\n\t\t\t\t\t\t&cmd->scan_begin_arg,\n\t\t\t\t\t\tcmd->convert_arg *\n\t\t\t\t\t\tcmd->chanlist_len);\n\t\t\t}\n\t\t}\n\t}\n\n\terr |= comedi_check_trigger_arg_min(&cmd->chanlist_len, 1);\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\n\t\t\t\t\t   cmd->chanlist_len);\n\n\tswitch (cmd->stop_src) {\n\tcase TRIG_EXT:\n\t\tbreak;\n\tcase TRIG_COUNT:\n\t\terr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\n\t\tbreak;\n\tcase TRIG_NONE:\n\t\terr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (err)\n\t\treturn 3;\n\n\t \n\n\tif (cmd->convert_src == TRIG_TIMER) {\n\t\ttmp_arg = cmd->convert_arg;\n\t\ttmp_arg2 = cmd->scan_begin_arg;\n\t\tcheck_adc_timing(dev, cmd);\n\t\tif (tmp_arg != cmd->convert_arg)\n\t\t\terr++;\n\t\tif (tmp_arg2 != cmd->scan_begin_arg)\n\t\t\terr++;\n\t}\n\n\tif (err)\n\t\treturn 4;\n\n\t \n\tif (cmd->chanlist && cmd->chanlist_len > 0)\n\t\terr |= cb_pcidas64_ai_check_chanlist(dev, s, cmd);\n\n\tif (err)\n\t\treturn 5;\n\n\treturn 0;\n}\n\nstatic int use_hw_sample_counter(struct comedi_cmd *cmd)\n{\n \n\treturn 0;\n\n\tif (cmd->stop_src == TRIG_COUNT && cmd->stop_arg <= max_counter_value)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic void setup_sample_counters(struct comedi_device *dev,\n\t\t\t\t  struct comedi_cmd *cmd)\n{\n\tstruct pcidas64_private *devpriv = dev->private;\n\n\t \n\tif (use_hw_sample_counter(cmd)) {\n\t\twritew(cmd->stop_arg & 0xffff,\n\t\t       devpriv->main_iobase + ADC_COUNT_LOWER_REG);\n\t\twritew((cmd->stop_arg >> 16) & 0xff,\n\t\t       devpriv->main_iobase + ADC_COUNT_UPPER_REG);\n\t} else {\n\t\twritew(1, devpriv->main_iobase + ADC_COUNT_LOWER_REG);\n\t}\n}\n\nstatic inline unsigned int dma_transfer_size(struct comedi_device *dev)\n{\n\tconst struct pcidas64_board *board = dev->board_ptr;\n\tstruct pcidas64_private *devpriv = dev->private;\n\tunsigned int num_samples;\n\n\tnum_samples = devpriv->ai_fifo_segment_length *\n\t\t      board->ai_fifo->sample_packing_ratio;\n\tif (num_samples > DMA_BUFFER_SIZE / sizeof(u16))\n\t\tnum_samples = DMA_BUFFER_SIZE / sizeof(u16);\n\n\treturn num_samples;\n}\n\nstatic u32 ai_convert_counter_6xxx(const struct comedi_device *dev,\n\t\t\t\t   const struct comedi_cmd *cmd)\n{\n\t \n\treturn cmd->convert_arg / TIMER_BASE - 3;\n}\n\nstatic u32 ai_scan_counter_6xxx(struct comedi_device *dev,\n\t\t\t\tstruct comedi_cmd *cmd)\n{\n\tu32 count;\n\n\t \n\tswitch (cmd->scan_begin_src) {\n\tcase TRIG_TIMER:\n\t\tcount = (cmd->scan_begin_arg -\n\t\t\t (cmd->convert_arg * (cmd->chanlist_len - 1))) /\n\t\t\tTIMER_BASE;\n\t\tbreak;\n\tcase TRIG_FOLLOW:\n\t\tcount = cmd->convert_arg / TIMER_BASE;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\treturn count - 3;\n}\n\nstatic u32 ai_convert_counter_4020(struct comedi_device *dev,\n\t\t\t\t   struct comedi_cmd *cmd)\n{\n\tstruct pcidas64_private *devpriv = dev->private;\n\tunsigned int divisor;\n\n\tswitch (cmd->scan_begin_src) {\n\tcase TRIG_TIMER:\n\t\tdivisor = cmd->scan_begin_arg / TIMER_BASE;\n\t\tbreak;\n\tcase TRIG_OTHER:\n\t\tdivisor = devpriv->ext_clock.divisor;\n\t\tbreak;\n\tdefault:\t\t \n\t\tdev_err(dev->class_dev, \"bug! failed to set ai pacing!\\n\");\n\t\tdivisor = 1000;\n\t\tbreak;\n\t}\n\n\t \n\treturn divisor - 2;\n}\n\nstatic void select_master_clock_4020(struct comedi_device *dev,\n\t\t\t\t     const struct comedi_cmd *cmd)\n{\n\tstruct pcidas64_private *devpriv = dev->private;\n\n\t \n\tdevpriv->hw_config_bits &= ~MASTER_CLOCK_4020_MASK;\n\tif (cmd->scan_begin_src == TRIG_OTHER) {\n\t\tint chanspec = devpriv->ext_clock.chanspec;\n\n\t\tif (CR_CHAN(chanspec))\n\t\t\tdevpriv->hw_config_bits |= BNC_CLOCK_4020_BITS;\n\t\telse\n\t\t\tdevpriv->hw_config_bits |= EXT_CLOCK_4020_BITS;\n\t} else {\n\t\tdevpriv->hw_config_bits |= INTERNAL_CLOCK_4020_BITS;\n\t}\n\twritew(devpriv->hw_config_bits,\n\t       devpriv->main_iobase + HW_CONFIG_REG);\n}\n\nstatic void select_master_clock(struct comedi_device *dev,\n\t\t\t\tconst struct comedi_cmd *cmd)\n{\n\tconst struct pcidas64_board *board = dev->board_ptr;\n\n\tswitch (board->layout) {\n\tcase LAYOUT_4020:\n\t\tselect_master_clock_4020(dev, cmd);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic inline void dma_start_sync(struct comedi_device *dev,\n\t\t\t\t  unsigned int channel)\n{\n\tstruct pcidas64_private *devpriv = dev->private;\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&dev->spinlock, flags);\n\twriteb(PLX_DMACSR_ENABLE | PLX_DMACSR_START | PLX_DMACSR_CLEARINTR,\n\t       devpriv->plx9080_iobase + PLX_REG_DMACSR(channel));\n\tspin_unlock_irqrestore(&dev->spinlock, flags);\n}\n\nstatic void set_ai_pacing(struct comedi_device *dev, struct comedi_cmd *cmd)\n{\n\tconst struct pcidas64_board *board = dev->board_ptr;\n\tstruct pcidas64_private *devpriv = dev->private;\n\tu32 convert_counter = 0, scan_counter = 0;\n\n\tcheck_adc_timing(dev, cmd);\n\n\tselect_master_clock(dev, cmd);\n\n\tif (board->layout == LAYOUT_4020) {\n\t\tconvert_counter = ai_convert_counter_4020(dev, cmd);\n\t} else {\n\t\tconvert_counter = ai_convert_counter_6xxx(dev, cmd);\n\t\tscan_counter = ai_scan_counter_6xxx(dev, cmd);\n\t}\n\n\t \n\twritew(convert_counter & 0xffff,\n\t       devpriv->main_iobase + ADC_SAMPLE_INTERVAL_LOWER_REG);\n\t \n\twritew((convert_counter >> 16) & 0xff,\n\t       devpriv->main_iobase + ADC_SAMPLE_INTERVAL_UPPER_REG);\n\t \n\twritew(scan_counter & 0xffff,\n\t       devpriv->main_iobase + ADC_DELAY_INTERVAL_LOWER_REG);\n\t \n\twritew((scan_counter >> 16) & 0xff,\n\t       devpriv->main_iobase + ADC_DELAY_INTERVAL_UPPER_REG);\n}\n\nstatic int use_internal_queue_6xxx(const struct comedi_cmd *cmd)\n{\n\tint i;\n\n\tfor (i = 0; i + 1 < cmd->chanlist_len; i++) {\n\t\tif (CR_CHAN(cmd->chanlist[i + 1]) !=\n\t\t    CR_CHAN(cmd->chanlist[i]) + 1)\n\t\t\treturn 0;\n\t\tif (CR_RANGE(cmd->chanlist[i + 1]) !=\n\t\t    CR_RANGE(cmd->chanlist[i]))\n\t\t\treturn 0;\n\t\tif (CR_AREF(cmd->chanlist[i + 1]) != CR_AREF(cmd->chanlist[i]))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int setup_channel_queue(struct comedi_device *dev,\n\t\t\t       const struct comedi_cmd *cmd)\n{\n\tconst struct pcidas64_board *board = dev->board_ptr;\n\tstruct pcidas64_private *devpriv = dev->private;\n\tunsigned short bits;\n\tint i;\n\n\tif (board->layout != LAYOUT_4020) {\n\t\tif (use_internal_queue_6xxx(cmd)) {\n\t\t\tdevpriv->hw_config_bits &= ~EXT_QUEUE_BIT;\n\t\t\twritew(devpriv->hw_config_bits,\n\t\t\t       devpriv->main_iobase + HW_CONFIG_REG);\n\t\t\tbits = 0;\n\t\t\t \n\t\t\tbits |= adc_chan_bits(CR_CHAN(cmd->chanlist[0]));\n\t\t\t \n\t\t\tbits |= ai_range_bits_6xxx(dev,\n\t\t\t\t\t\t   CR_RANGE(cmd->chanlist[0]));\n\t\t\t \n\t\t\tbits |= se_diff_bit_6xxx(dev,\n\t\t\t\t\t\t CR_AREF(cmd->chanlist[0]) ==\n\t\t\t\t\t\t AREF_DIFF);\n\t\t\tif (CR_AREF(cmd->chanlist[0]) == AREF_COMMON)\n\t\t\t\tbits |= ADC_COMMON_BIT;\n\t\t\t \n\t\t\twritew(adc_chan_bits\n\t\t\t       (CR_CHAN(cmd->chanlist[cmd->chanlist_len - 1])),\n\t\t\t       devpriv->main_iobase + ADC_QUEUE_HIGH_REG);\n\t\t\t \n\t\t\twritew(bits,\n\t\t\t       devpriv->main_iobase + ADC_QUEUE_LOAD_REG);\n\t\t} else {\n\t\t\t \n\t\t\tif (dev->write_subdev && dev->write_subdev->busy) {\n\t\t\t\twarn_external_queue(dev);\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\t\t\tdevpriv->hw_config_bits |= EXT_QUEUE_BIT;\n\t\t\twritew(devpriv->hw_config_bits,\n\t\t\t       devpriv->main_iobase + HW_CONFIG_REG);\n\t\t\t \n\t\t\twritew(0,\n\t\t\t       devpriv->main_iobase + DAC_BUFFER_CLEAR_REG);\n\t\t\t \n\t\t\twritew(0, devpriv->main_iobase + ADC_QUEUE_CLEAR_REG);\n\t\t\t \n\t\t\tfor (i = 0; i < cmd->chanlist_len; i++) {\n\t\t\t\tunsigned int chanspec = cmd->chanlist[i];\n\t\t\t\tint use_differential;\n\n\t\t\t\tbits = 0;\n\t\t\t\t \n\t\t\t\tbits |= adc_chan_bits(CR_CHAN(chanspec));\n\t\t\t\t \n\t\t\t\tbits |= ai_range_bits_6xxx(dev,\n\t\t\t\t\t\t\t   CR_RANGE(chanspec));\n\t\t\t\t \n\t\t\t\tuse_differential = 0;\n\t\t\t\tif (CR_AREF(chanspec) == AREF_DIFF)\n\t\t\t\t\tuse_differential = 1;\n\t\t\t\tbits |= se_diff_bit_6xxx(dev, use_differential);\n\n\t\t\t\tif (CR_AREF(cmd->chanlist[i]) == AREF_COMMON)\n\t\t\t\t\tbits |= ADC_COMMON_BIT;\n\t\t\t\t \n\t\t\t\tif (i == cmd->chanlist_len - 1)\n\t\t\t\t\tbits |= QUEUE_EOSCAN_BIT |\n\t\t\t\t\t\tQUEUE_EOSEQ_BIT;\n\t\t\t\twritew(bits,\n\t\t\t\t       devpriv->main_iobase +\n\t\t\t\t       ADC_QUEUE_FIFO_REG);\n\t\t\t}\n\t\t\t \n\t\t\twritew(0, devpriv->main_iobase + ADC_QUEUE_CLEAR_REG);\n\t\t\t \n\t\t\twritew(0, devpriv->main_iobase + ADC_QUEUE_LOAD_REG);\n\t\t}\n\t} else {\n\t\tunsigned short old_cal_range_bits = devpriv->i2c_cal_range_bits;\n\n\t\tdevpriv->i2c_cal_range_bits &= ~ADC_SRC_4020_MASK;\n\t\t \n\t\tdevpriv->i2c_cal_range_bits |= adc_src_4020_bits(4);\n\t\t \n\t\tfor (i = 0; i < cmd->chanlist_len; i++) {\n\t\t\tunsigned int channel = CR_CHAN(cmd->chanlist[i]);\n\t\t\tunsigned int range = CR_RANGE(cmd->chanlist[i]);\n\n\t\t\tif (range == 0)\n\t\t\t\tdevpriv->i2c_cal_range_bits |=\n\t\t\t\t\tattenuate_bit(channel);\n\t\t\telse\n\t\t\t\tdevpriv->i2c_cal_range_bits &=\n\t\t\t\t\t~attenuate_bit(channel);\n\t\t}\n\t\t \n\t\tif (old_cal_range_bits != devpriv->i2c_cal_range_bits) {\n\t\t\tu8 i2c_data = devpriv->i2c_cal_range_bits;\n\n\t\t\ti2c_write(dev, RANGE_CAL_I2C_ADDR, &i2c_data,\n\t\t\t\t  sizeof(i2c_data));\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic inline void load_first_dma_descriptor(struct comedi_device *dev,\n\t\t\t\t\t     unsigned int dma_channel,\n\t\t\t\t\t     unsigned int descriptor_bits)\n{\n\tstruct pcidas64_private *devpriv = dev->private;\n\n\t \n\tif (dma_channel) {\n\t\twritel(0, devpriv->plx9080_iobase + PLX_REG_DMASIZ1);\n\t\twritel(0, devpriv->plx9080_iobase + PLX_REG_DMAPADR1);\n\t\twritel(0, devpriv->plx9080_iobase + PLX_REG_DMALADR1);\n\t\twritel(descriptor_bits,\n\t\t       devpriv->plx9080_iobase + PLX_REG_DMADPR1);\n\t} else {\n\t\twritel(0, devpriv->plx9080_iobase + PLX_REG_DMASIZ0);\n\t\twritel(0, devpriv->plx9080_iobase + PLX_REG_DMAPADR0);\n\t\twritel(0, devpriv->plx9080_iobase + PLX_REG_DMALADR0);\n\t\twritel(descriptor_bits,\n\t\t       devpriv->plx9080_iobase + PLX_REG_DMADPR0);\n\t}\n}\n\nstatic int ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\n{\n\tconst struct pcidas64_board *board = dev->board_ptr;\n\tstruct pcidas64_private *devpriv = dev->private;\n\tstruct comedi_async *async = s->async;\n\tstruct comedi_cmd *cmd = &async->cmd;\n\tu32 bits;\n\tunsigned int i;\n\tunsigned long flags;\n\tint retval;\n\n\tdisable_ai_pacing(dev);\n\tabort_dma(dev, 1);\n\n\tretval = setup_channel_queue(dev, cmd);\n\tif (retval < 0)\n\t\treturn retval;\n\n\t \n\twritew(0, devpriv->main_iobase + CALIBRATION_REG);\n\n\tset_ai_pacing(dev, cmd);\n\n\tsetup_sample_counters(dev, cmd);\n\n\tenable_ai_interrupts(dev, cmd);\n\n\tspin_lock_irqsave(&dev->spinlock, flags);\n\t \n\tdevpriv->adc_control1_bits |= ADC_SW_GATE_BIT;\n\tdevpriv->adc_control1_bits &= ~ADC_DITHER_BIT;\n\tif (board->layout != LAYOUT_4020) {\n\t\tdevpriv->adc_control1_bits &= ~ADC_MODE_MASK;\n\t\tif (cmd->convert_src == TRIG_EXT)\n\t\t\t \n\t\t\tdevpriv->adc_control1_bits |= adc_mode_bits(13);\n\t\telse\n\t\t\t \n\t\t\tdevpriv->adc_control1_bits |= adc_mode_bits(8);\n\t} else {\n\t\tdevpriv->adc_control1_bits &= ~CHANNEL_MODE_4020_MASK;\n\t\tif (cmd->chanlist_len == 4)\n\t\t\tdevpriv->adc_control1_bits |= FOUR_CHANNEL_4020_BITS;\n\t\telse if (cmd->chanlist_len == 2)\n\t\t\tdevpriv->adc_control1_bits |= TWO_CHANNEL_4020_BITS;\n\t\tdevpriv->adc_control1_bits &= ~ADC_LO_CHANNEL_4020_MASK;\n\t\tdevpriv->adc_control1_bits |=\n\t\t\tadc_lo_chan_4020_bits(CR_CHAN(cmd->chanlist[0]));\n\t\tdevpriv->adc_control1_bits &= ~ADC_HI_CHANNEL_4020_MASK;\n\t\tdevpriv->adc_control1_bits |=\n\t\t\tadc_hi_chan_4020_bits(CR_CHAN(cmd->chanlist\n\t\t\t\t\t\t      [cmd->chanlist_len - 1]));\n\t}\n\twritew(devpriv->adc_control1_bits,\n\t       devpriv->main_iobase + ADC_CONTROL1_REG);\n\tspin_unlock_irqrestore(&dev->spinlock, flags);\n\n\t \n\twritew(0, devpriv->main_iobase + ADC_BUFFER_CLEAR_REG);\n\n\tif ((cmd->flags & CMDF_WAKE_EOS) == 0 ||\n\t    board->layout == LAYOUT_4020) {\n\t\tdevpriv->ai_dma_index = 0;\n\n\t\t \n\t\tfor (i = 0; i < ai_dma_ring_count(board); i++)\n\t\t\tdevpriv->ai_dma_desc[i].transfer_size =\n\t\t\t\tcpu_to_le32(dma_transfer_size(dev) *\n\t\t\t\t\t    sizeof(u16));\n\n\t\t \n\t\tload_first_dma_descriptor(dev, 1,\n\t\t\t\t\t  devpriv->ai_dma_desc_bus_addr |\n\t\t\t\t\t  PLX_DMADPR_DESCPCI |\n\t\t\t\t\t  PLX_DMADPR_TCINTR |\n\t\t\t\t\t  PLX_DMADPR_XFERL2P);\n\n\t\tdma_start_sync(dev, 1);\n\t}\n\n\tif (board->layout == LAYOUT_4020) {\n\t\t \n\t\tbits = 0;\n\t\tif (cmd->start_src == TRIG_EXT && CR_CHAN(cmd->start_arg))\n\t\t\tbits |= EXT_START_TRIG_BNC_BIT;\n\t\tif (cmd->stop_src == TRIG_EXT && CR_CHAN(cmd->stop_arg))\n\t\t\tbits |= EXT_STOP_TRIG_BNC_BIT;\n\t\twritew(bits, devpriv->main_iobase + DAQ_ATRIG_LOW_4020_REG);\n\t}\n\n\tspin_lock_irqsave(&dev->spinlock, flags);\n\n\t \n\tbits = ADC_ENABLE_BIT | ADC_SOFT_GATE_BITS | ADC_GATE_LEVEL_BIT;\n\tif (cmd->flags & CMDF_WAKE_EOS)\n\t\tbits |= ADC_DMA_DISABLE_BIT;\n\t \n\tif (cmd->start_src == TRIG_EXT) {\n\t\tbits |= ADC_START_TRIG_EXT_BITS;\n\t\tif (cmd->start_arg & CR_INVERT)\n\t\t\tbits |= ADC_START_TRIG_FALLING_BIT;\n\t} else if (cmd->start_src == TRIG_NOW) {\n\t\tbits |= ADC_START_TRIG_SOFT_BITS;\n\t}\n\tif (use_hw_sample_counter(cmd))\n\t\tbits |= ADC_SAMPLE_COUNTER_EN_BIT;\n\twritew(bits, devpriv->main_iobase + ADC_CONTROL0_REG);\n\n\tdevpriv->ai_cmd_running = 1;\n\n\tspin_unlock_irqrestore(&dev->spinlock, flags);\n\n\t \n\tif (cmd->start_src == TRIG_NOW)\n\t\twritew(0, devpriv->main_iobase + ADC_START_REG);\n\n\treturn 0;\n}\n\n \nstatic void pio_drain_ai_fifo_16(struct comedi_device *dev)\n{\n\tstruct pcidas64_private *devpriv = dev->private;\n\tstruct comedi_subdevice *s = dev->read_subdev;\n\tunsigned int i;\n\tu16 prepost_bits;\n\tint read_segment, read_index, write_segment, write_index;\n\tint num_samples;\n\n\tdo {\n\t\t \n\t\tread_index = readw(devpriv->main_iobase + ADC_READ_PNTR_REG) &\n\t\t\t     0x7fff;\n\t\twrite_index = readw(devpriv->main_iobase + ADC_WRITE_PNTR_REG) &\n\t\t\t      0x7fff;\n\t\t \n\t\tprepost_bits = readw(devpriv->main_iobase + PREPOST_REG);\n\n\t\t \n\t\tread_segment = adc_upper_read_ptr_code(prepost_bits);\n\t\twrite_segment = adc_upper_write_ptr_code(prepost_bits);\n\n\t\tif (read_segment != write_segment)\n\t\t\tnum_samples =\n\t\t\t\tdevpriv->ai_fifo_segment_length - read_index;\n\t\telse\n\t\t\tnum_samples = write_index - read_index;\n\t\tif (num_samples < 0) {\n\t\t\tdev_err(dev->class_dev,\n\t\t\t\t\"cb_pcidas64: bug! num_samples < 0\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tnum_samples = comedi_nsamples_left(s, num_samples);\n\t\tif (num_samples == 0)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < num_samples; i++) {\n\t\t\tunsigned short val;\n\n\t\t\tval = readw(devpriv->main_iobase + ADC_FIFO_REG);\n\t\t\tcomedi_buf_write_samples(s, &val, 1);\n\t\t}\n\n\t} while (read_segment != write_segment);\n}\n\n \nstatic void pio_drain_ai_fifo_32(struct comedi_device *dev)\n{\n\tstruct pcidas64_private *devpriv = dev->private;\n\tstruct comedi_subdevice *s = dev->read_subdev;\n\tunsigned int nsamples;\n\tunsigned int i;\n\tu32 fifo_data;\n\tint write_code =\n\t\treadw(devpriv->main_iobase + ADC_WRITE_PNTR_REG) & 0x7fff;\n\tint read_code =\n\t\treadw(devpriv->main_iobase + ADC_READ_PNTR_REG) & 0x7fff;\n\n\tnsamples = comedi_nsamples_left(s, 100000);\n\tfor (i = 0; read_code != write_code && i < nsamples;) {\n\t\tunsigned short val;\n\n\t\tfifo_data = readl(dev->mmio + ADC_FIFO_REG);\n\t\tval = fifo_data & 0xffff;\n\t\tcomedi_buf_write_samples(s, &val, 1);\n\t\ti++;\n\t\tif (i < nsamples) {\n\t\t\tval = (fifo_data >> 16) & 0xffff;\n\t\t\tcomedi_buf_write_samples(s, &val, 1);\n\t\t\ti++;\n\t\t}\n\t\tread_code = readw(devpriv->main_iobase + ADC_READ_PNTR_REG) &\n\t\t\t    0x7fff;\n\t}\n}\n\n \nstatic void pio_drain_ai_fifo(struct comedi_device *dev)\n{\n\tconst struct pcidas64_board *board = dev->board_ptr;\n\n\tif (board->layout == LAYOUT_4020)\n\t\tpio_drain_ai_fifo_32(dev);\n\telse\n\t\tpio_drain_ai_fifo_16(dev);\n}\n\nstatic void drain_dma_buffers(struct comedi_device *dev, unsigned int channel)\n{\n\tconst struct pcidas64_board *board = dev->board_ptr;\n\tstruct pcidas64_private *devpriv = dev->private;\n\tstruct comedi_subdevice *s = dev->read_subdev;\n\tu32 next_transfer_addr;\n\tint j;\n\tint num_samples = 0;\n\tvoid __iomem *pci_addr_reg;\n\n\tpci_addr_reg = devpriv->plx9080_iobase + PLX_REG_DMAPADR(channel);\n\n\t \n\tfor (j = 0, next_transfer_addr = readl(pci_addr_reg);\n\t     (next_transfer_addr <\n\t      devpriv->ai_buffer_bus_addr[devpriv->ai_dma_index] ||\n\t      next_transfer_addr >=\n\t      devpriv->ai_buffer_bus_addr[devpriv->ai_dma_index] +\n\t      DMA_BUFFER_SIZE) && j < ai_dma_ring_count(board); j++) {\n\t\t \n\t\tnum_samples = comedi_nsamples_left(s, dma_transfer_size(dev));\n\t\tcomedi_buf_write_samples(s,\n\t\t\t\tdevpriv->ai_buffer[devpriv->ai_dma_index],\n\t\t\t\tnum_samples);\n\t\tdevpriv->ai_dma_index = (devpriv->ai_dma_index + 1) %\n\t\t\t\t\tai_dma_ring_count(board);\n\t}\n\t \n}\n\nstatic void handle_ai_interrupt(struct comedi_device *dev,\n\t\t\t\tunsigned short status,\n\t\t\t\tunsigned int plx_status)\n{\n\tconst struct pcidas64_board *board = dev->board_ptr;\n\tstruct pcidas64_private *devpriv = dev->private;\n\tstruct comedi_subdevice *s = dev->read_subdev;\n\tstruct comedi_async *async = s->async;\n\tstruct comedi_cmd *cmd = &async->cmd;\n\tu8 dma1_status;\n\tunsigned long flags;\n\n\t \n\tif (status & ADC_OVERRUN_BIT) {\n\t\tdev_err(dev->class_dev, \"fifo overrun\\n\");\n\t\tasync->events |= COMEDI_CB_ERROR;\n\t}\n\t \n\tspin_lock_irqsave(&dev->spinlock, flags);\n\tdma1_status = readb(devpriv->plx9080_iobase + PLX_REG_DMACSR1);\n\tif (plx_status & PLX_INTCSR_DMA1IA) {\t \n\t\twriteb((dma1_status & PLX_DMACSR_ENABLE) | PLX_DMACSR_CLEARINTR,\n\t\t       devpriv->plx9080_iobase + PLX_REG_DMACSR1);\n\n\t\tif (dma1_status & PLX_DMACSR_ENABLE)\n\t\t\tdrain_dma_buffers(dev, 1);\n\t}\n\tspin_unlock_irqrestore(&dev->spinlock, flags);\n\n\t \n\tif ((status & ADC_DONE_BIT) ||\n\t    ((cmd->flags & CMDF_WAKE_EOS) &&\n\t     (status & ADC_INTR_PENDING_BIT) &&\n\t     (board->layout != LAYOUT_4020))) {\n\t\tspin_lock_irqsave(&dev->spinlock, flags);\n\t\tif (devpriv->ai_cmd_running) {\n\t\t\tspin_unlock_irqrestore(&dev->spinlock, flags);\n\t\t\tpio_drain_ai_fifo(dev);\n\t\t} else {\n\t\t\tspin_unlock_irqrestore(&dev->spinlock, flags);\n\t\t}\n\t}\n\t \n\tif ((cmd->stop_src == TRIG_COUNT &&\n\t     async->scans_done >= cmd->stop_arg) ||\n\t    (cmd->stop_src == TRIG_EXT && (status & ADC_STOP_BIT)))\n\t\tasync->events |= COMEDI_CB_EOA;\n\n\tcomedi_handle_events(dev, s);\n}\n\nstatic inline unsigned int prev_ao_dma_index(struct comedi_device *dev)\n{\n\tstruct pcidas64_private *devpriv = dev->private;\n\tunsigned int buffer_index;\n\n\tif (devpriv->ao_dma_index == 0)\n\t\tbuffer_index = AO_DMA_RING_COUNT - 1;\n\telse\n\t\tbuffer_index = devpriv->ao_dma_index - 1;\n\treturn buffer_index;\n}\n\nstatic int last_ao_dma_load_completed(struct comedi_device *dev)\n{\n\tstruct pcidas64_private *devpriv = dev->private;\n\tunsigned int buffer_index;\n\tunsigned int transfer_address;\n\tunsigned short dma_status;\n\n\tbuffer_index = prev_ao_dma_index(dev);\n\tdma_status = readb(devpriv->plx9080_iobase + PLX_REG_DMACSR0);\n\tif ((dma_status & PLX_DMACSR_DONE) == 0)\n\t\treturn 0;\n\n\ttransfer_address =\n\t\treadl(devpriv->plx9080_iobase + PLX_REG_DMAPADR0);\n\tif (transfer_address != devpriv->ao_buffer_bus_addr[buffer_index])\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic inline int ao_dma_needs_restart(struct comedi_device *dev,\n\t\t\t\t       unsigned short dma_status)\n{\n\tif ((dma_status & PLX_DMACSR_DONE) == 0 ||\n\t    (dma_status & PLX_DMACSR_ENABLE) == 0)\n\t\treturn 0;\n\tif (last_ao_dma_load_completed(dev))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic void restart_ao_dma(struct comedi_device *dev)\n{\n\tstruct pcidas64_private *devpriv = dev->private;\n\tunsigned int dma_desc_bits;\n\n\tdma_desc_bits = readl(devpriv->plx9080_iobase + PLX_REG_DMADPR0);\n\tdma_desc_bits &= ~PLX_DMADPR_CHAINEND;\n\tload_first_dma_descriptor(dev, 0, dma_desc_bits);\n\n\tdma_start_sync(dev, 0);\n}\n\nstatic unsigned int cb_pcidas64_ao_fill_buffer(struct comedi_device *dev,\n\t\t\t\t\t       struct comedi_subdevice *s,\n\t\t\t\t\t       unsigned short *dest,\n\t\t\t\t\t       unsigned int max_bytes)\n{\n\tunsigned int nsamples = comedi_bytes_to_samples(s, max_bytes);\n\tunsigned int actual_bytes;\n\n\tnsamples = comedi_nsamples_left(s, nsamples);\n\tactual_bytes = comedi_buf_read_samples(s, dest, nsamples);\n\n\treturn comedi_bytes_to_samples(s, actual_bytes);\n}\n\nstatic unsigned int load_ao_dma_buffer(struct comedi_device *dev,\n\t\t\t\t       const struct comedi_cmd *cmd)\n{\n\tstruct pcidas64_private *devpriv = dev->private;\n\tstruct comedi_subdevice *s = dev->write_subdev;\n\tunsigned int buffer_index = devpriv->ao_dma_index;\n\tunsigned int prev_buffer_index = prev_ao_dma_index(dev);\n\tunsigned int nsamples;\n\tunsigned int nbytes;\n\tunsigned int next_bits;\n\n\tnsamples = cb_pcidas64_ao_fill_buffer(dev, s,\n\t\t\t\t\t      devpriv->ao_buffer[buffer_index],\n\t\t\t\t\t      DMA_BUFFER_SIZE);\n\tif (nsamples == 0)\n\t\treturn 0;\n\n\tnbytes = comedi_samples_to_bytes(s, nsamples);\n\tdevpriv->ao_dma_desc[buffer_index].transfer_size = cpu_to_le32(nbytes);\n\t \n\tnext_bits = le32_to_cpu(devpriv->ao_dma_desc[buffer_index].next);\n\tnext_bits |= PLX_DMADPR_CHAINEND;\n\tdevpriv->ao_dma_desc[buffer_index].next = cpu_to_le32(next_bits);\n\t \n\tnext_bits = le32_to_cpu(devpriv->ao_dma_desc[prev_buffer_index].next);\n\tnext_bits &= ~PLX_DMADPR_CHAINEND;\n\tdevpriv->ao_dma_desc[prev_buffer_index].next = cpu_to_le32(next_bits);\n\n\tdevpriv->ao_dma_index = (buffer_index + 1) % AO_DMA_RING_COUNT;\n\n\treturn nbytes;\n}\n\nstatic void load_ao_dma(struct comedi_device *dev, const struct comedi_cmd *cmd)\n{\n\tstruct pcidas64_private *devpriv = dev->private;\n\tunsigned int num_bytes;\n\tunsigned int next_transfer_addr;\n\tvoid __iomem *pci_addr_reg = devpriv->plx9080_iobase + PLX_REG_DMAPADR0;\n\tunsigned int buffer_index;\n\n\tdo {\n\t\tbuffer_index = devpriv->ao_dma_index;\n\t\t \n\t\tnext_transfer_addr = readl(pci_addr_reg);\n\t\tif (next_transfer_addr >=\n\t\t    devpriv->ao_buffer_bus_addr[buffer_index] &&\n\t\t    next_transfer_addr <\n\t\t    devpriv->ao_buffer_bus_addr[buffer_index] +\n\t\t    DMA_BUFFER_SIZE)\n\t\t\treturn;\n\t\tnum_bytes = load_ao_dma_buffer(dev, cmd);\n\t} while (num_bytes >= DMA_BUFFER_SIZE);\n}\n\nstatic void handle_ao_interrupt(struct comedi_device *dev,\n\t\t\t\tunsigned short status, unsigned int plx_status)\n{\n\tstruct pcidas64_private *devpriv = dev->private;\n\tstruct comedi_subdevice *s = dev->write_subdev;\n\tstruct comedi_async *async;\n\tstruct comedi_cmd *cmd;\n\tu8 dma0_status;\n\tunsigned long flags;\n\n\t \n\tif (!s)\n\t\treturn;\n\tasync = s->async;\n\tcmd = &async->cmd;\n\n\t \n\tspin_lock_irqsave(&dev->spinlock, flags);\n\tdma0_status = readb(devpriv->plx9080_iobase + PLX_REG_DMACSR0);\n\tif (plx_status & PLX_INTCSR_DMA0IA) {\t \n\t\tif ((dma0_status & PLX_DMACSR_ENABLE) &&\n\t\t    !(dma0_status & PLX_DMACSR_DONE)) {\n\t\t\twriteb(PLX_DMACSR_ENABLE | PLX_DMACSR_CLEARINTR,\n\t\t\t       devpriv->plx9080_iobase + PLX_REG_DMACSR0);\n\t\t} else {\n\t\t\twriteb(PLX_DMACSR_CLEARINTR,\n\t\t\t       devpriv->plx9080_iobase + PLX_REG_DMACSR0);\n\t\t}\n\t\tspin_unlock_irqrestore(&dev->spinlock, flags);\n\t\tif (dma0_status & PLX_DMACSR_ENABLE) {\n\t\t\tload_ao_dma(dev, cmd);\n\t\t\t \n\t\t\tif (ao_dma_needs_restart(dev, dma0_status))\n\t\t\t\trestart_ao_dma(dev);\n\t\t}\n\t} else {\n\t\tspin_unlock_irqrestore(&dev->spinlock, flags);\n\t}\n\n\tif ((status & DAC_DONE_BIT)) {\n\t\tif ((cmd->stop_src == TRIG_COUNT &&\n\t\t     async->scans_done >= cmd->stop_arg) ||\n\t\t    last_ao_dma_load_completed(dev))\n\t\t\tasync->events |= COMEDI_CB_EOA;\n\t\telse\n\t\t\tasync->events |= COMEDI_CB_ERROR;\n\t}\n\tcomedi_handle_events(dev, s);\n}\n\nstatic irqreturn_t handle_interrupt(int irq, void *d)\n{\n\tstruct comedi_device *dev = d;\n\tstruct pcidas64_private *devpriv = dev->private;\n\tunsigned short status;\n\tu32 plx_status;\n\tu32 plx_bits;\n\n\tplx_status = readl(devpriv->plx9080_iobase + PLX_REG_INTCSR);\n\tstatus = readw(devpriv->main_iobase + HW_STATUS_REG);\n\n\t \n\tif (!dev->attached)\n\t\treturn IRQ_HANDLED;\n\n\thandle_ai_interrupt(dev, status, plx_status);\n\thandle_ao_interrupt(dev, status, plx_status);\n\n\t \n\tif (plx_status & PLX_INTCSR_LDBIA) {\n\t\t \n\t\tplx_bits = readl(devpriv->plx9080_iobase + PLX_REG_L2PDBELL);\n\t\twritel(plx_bits, devpriv->plx9080_iobase + PLX_REG_L2PDBELL);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)\n{\n\tstruct pcidas64_private *devpriv = dev->private;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->spinlock, flags);\n\tif (devpriv->ai_cmd_running == 0) {\n\t\tspin_unlock_irqrestore(&dev->spinlock, flags);\n\t\treturn 0;\n\t}\n\tdevpriv->ai_cmd_running = 0;\n\tspin_unlock_irqrestore(&dev->spinlock, flags);\n\n\tdisable_ai_pacing(dev);\n\n\tabort_dma(dev, 1);\n\n\treturn 0;\n}\n\nstatic int ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,\n\t\t    struct comedi_insn *insn, unsigned int *data)\n{\n\tconst struct pcidas64_board *board = dev->board_ptr;\n\tstruct pcidas64_private *devpriv = dev->private;\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int range = CR_RANGE(insn->chanspec);\n\tunsigned int val = s->readback[chan];\n\tunsigned int i;\n\n\t \n\twritew(0, devpriv->main_iobase + DAC_CONTROL0_REG);\n\n\t \n\tset_dac_range_bits(dev, &devpriv->dac_control1_bits, chan, range);\n\twritew(devpriv->dac_control1_bits,\n\t       devpriv->main_iobase + DAC_CONTROL1_REG);\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\t \n\t\tval = data[i];\n\t\tif (board->layout == LAYOUT_4020) {\n\t\t\twritew(val & 0xff,\n\t\t\t       devpriv->main_iobase + dac_lsb_4020_reg(chan));\n\t\t\twritew((val >> 8) & 0xf,\n\t\t\t       devpriv->main_iobase + dac_msb_4020_reg(chan));\n\t\t} else {\n\t\t\twritew(val,\n\t\t\t       devpriv->main_iobase + dac_convert_reg(chan));\n\t\t}\n\t}\n\n\t \n\ts->readback[chan] = val;\n\n\treturn insn->n;\n}\n\nstatic void set_dac_control0_reg(struct comedi_device *dev,\n\t\t\t\t const struct comedi_cmd *cmd)\n{\n\tstruct pcidas64_private *devpriv = dev->private;\n\tunsigned int bits = DAC_ENABLE_BIT | WAVEFORM_GATE_LEVEL_BIT |\n\t\t\t    WAVEFORM_GATE_ENABLE_BIT | WAVEFORM_GATE_SELECT_BIT;\n\n\tif (cmd->start_src == TRIG_EXT) {\n\t\tbits |= WAVEFORM_TRIG_EXT_BITS;\n\t\tif (cmd->start_arg & CR_INVERT)\n\t\t\tbits |= WAVEFORM_TRIG_FALLING_BIT;\n\t} else {\n\t\tbits |= WAVEFORM_TRIG_SOFT_BITS;\n\t}\n\tif (cmd->scan_begin_src == TRIG_EXT) {\n\t\tbits |= DAC_EXT_UPDATE_ENABLE_BIT;\n\t\tif (cmd->scan_begin_arg & CR_INVERT)\n\t\t\tbits |= DAC_EXT_UPDATE_FALLING_BIT;\n\t}\n\twritew(bits, devpriv->main_iobase + DAC_CONTROL0_REG);\n}\n\nstatic void set_dac_control1_reg(struct comedi_device *dev,\n\t\t\t\t const struct comedi_cmd *cmd)\n{\n\tstruct pcidas64_private *devpriv = dev->private;\n\tint i;\n\n\tfor (i = 0; i < cmd->chanlist_len; i++) {\n\t\tint channel, range;\n\n\t\tchannel = CR_CHAN(cmd->chanlist[i]);\n\t\trange = CR_RANGE(cmd->chanlist[i]);\n\t\tset_dac_range_bits(dev, &devpriv->dac_control1_bits, channel,\n\t\t\t\t   range);\n\t}\n\tdevpriv->dac_control1_bits |= DAC_SW_GATE_BIT;\n\twritew(devpriv->dac_control1_bits,\n\t       devpriv->main_iobase + DAC_CONTROL1_REG);\n}\n\nstatic void set_dac_select_reg(struct comedi_device *dev,\n\t\t\t       const struct comedi_cmd *cmd)\n{\n\tstruct pcidas64_private *devpriv = dev->private;\n\tu16 bits;\n\tunsigned int first_channel, last_channel;\n\n\tfirst_channel = CR_CHAN(cmd->chanlist[0]);\n\tlast_channel = CR_CHAN(cmd->chanlist[cmd->chanlist_len - 1]);\n\tif (last_channel < first_channel)\n\t\tdev_err(dev->class_dev,\n\t\t\t\"bug! last ao channel < first ao channel\\n\");\n\n\tbits = (first_channel & 0x7) | (last_channel & 0x7) << 3;\n\n\twritew(bits, devpriv->main_iobase + DAC_SELECT_REG);\n}\n\nstatic unsigned int get_ao_divisor(unsigned int ns, unsigned int flags)\n{\n\treturn get_divisor(ns, flags) - 2;\n}\n\nstatic void set_dac_interval_regs(struct comedi_device *dev,\n\t\t\t\t  const struct comedi_cmd *cmd)\n{\n\tstruct pcidas64_private *devpriv = dev->private;\n\tunsigned int divisor;\n\n\tif (cmd->scan_begin_src != TRIG_TIMER)\n\t\treturn;\n\n\tdivisor = get_ao_divisor(cmd->scan_begin_arg, cmd->flags);\n\tif (divisor > max_counter_value) {\n\t\tdev_err(dev->class_dev, \"bug! ao divisor too big\\n\");\n\t\tdivisor = max_counter_value;\n\t}\n\twritew(divisor & 0xffff,\n\t       devpriv->main_iobase + DAC_SAMPLE_INTERVAL_LOWER_REG);\n\twritew((divisor >> 16) & 0xff,\n\t       devpriv->main_iobase + DAC_SAMPLE_INTERVAL_UPPER_REG);\n}\n\nstatic int prep_ao_dma(struct comedi_device *dev, const struct comedi_cmd *cmd)\n{\n\tstruct pcidas64_private *devpriv = dev->private;\n\tstruct comedi_subdevice *s = dev->write_subdev;\n\tunsigned int nsamples;\n\tunsigned int nbytes;\n\tint i;\n\n\t \n\twritew(0, devpriv->main_iobase + ADC_QUEUE_CLEAR_REG);\n\twritew(0, devpriv->main_iobase + DAC_BUFFER_CLEAR_REG);\n\n\tnsamples = cb_pcidas64_ao_fill_buffer(dev, s,\n\t\t\t\t\t      devpriv->ao_bounce_buffer,\n\t\t\t\t\t      DAC_FIFO_SIZE);\n\tif (nsamples == 0)\n\t\treturn -1;\n\n\tfor (i = 0; i < nsamples; i++) {\n\t\twritew(devpriv->ao_bounce_buffer[i],\n\t\t       devpriv->main_iobase + DAC_FIFO_REG);\n\t}\n\n\tif (cmd->stop_src == TRIG_COUNT &&\n\t    s->async->scans_done >= cmd->stop_arg)\n\t\treturn 0;\n\n\tnbytes = load_ao_dma_buffer(dev, cmd);\n\tif (nbytes == 0)\n\t\treturn -1;\n\tload_ao_dma(dev, cmd);\n\n\tdma_start_sync(dev, 0);\n\n\treturn 0;\n}\n\nstatic inline int external_ai_queue_in_use(struct comedi_device *dev)\n{\n\tconst struct pcidas64_board *board = dev->board_ptr;\n\n\tif (!dev->read_subdev->busy)\n\t\treturn 0;\n\tif (board->layout == LAYOUT_4020)\n\t\treturn 0;\n\telse if (use_internal_queue_6xxx(&dev->read_subdev->async->cmd))\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic int ao_inttrig(struct comedi_device *dev, struct comedi_subdevice *s,\n\t\t      unsigned int trig_num)\n{\n\tstruct pcidas64_private *devpriv = dev->private;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tint retval;\n\n\tif (trig_num != cmd->start_arg)\n\t\treturn -EINVAL;\n\n\tretval = prep_ao_dma(dev, cmd);\n\tif (retval < 0)\n\t\treturn -EPIPE;\n\n\tset_dac_control0_reg(dev, cmd);\n\n\tif (cmd->start_src == TRIG_INT)\n\t\twritew(0, devpriv->main_iobase + DAC_START_REG);\n\n\ts->async->inttrig = NULL;\n\n\treturn 0;\n}\n\nstatic int ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\n{\n\tstruct pcidas64_private *devpriv = dev->private;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\n\tif (external_ai_queue_in_use(dev)) {\n\t\twarn_external_queue(dev);\n\t\treturn -EBUSY;\n\t}\n\t \n\twritew(0x0, devpriv->main_iobase + DAC_CONTROL0_REG);\n\n\tdevpriv->ao_dma_index = 0;\n\n\tset_dac_select_reg(dev, cmd);\n\tset_dac_interval_regs(dev, cmd);\n\tload_first_dma_descriptor(dev, 0, devpriv->ao_dma_desc_bus_addr |\n\t\t\t\t  PLX_DMADPR_DESCPCI | PLX_DMADPR_TCINTR);\n\n\tset_dac_control1_reg(dev, cmd);\n\ts->async->inttrig = ao_inttrig;\n\n\treturn 0;\n}\n\nstatic int cb_pcidas64_ao_check_chanlist(struct comedi_device *dev,\n\t\t\t\t\t struct comedi_subdevice *s,\n\t\t\t\t\t struct comedi_cmd *cmd)\n{\n\tunsigned int chan0 = CR_CHAN(cmd->chanlist[0]);\n\tint i;\n\n\tfor (i = 1; i < cmd->chanlist_len; i++) {\n\t\tunsigned int chan = CR_CHAN(cmd->chanlist[i]);\n\n\t\tif (chan != (chan0 + i)) {\n\t\t\tdev_dbg(dev->class_dev,\n\t\t\t\t\"chanlist must use consecutive channels\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ao_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s,\n\t\t      struct comedi_cmd *cmd)\n{\n\tconst struct pcidas64_board *board = dev->board_ptr;\n\tint err = 0;\n\tunsigned int tmp_arg;\n\n\t \n\n\terr |= comedi_check_trigger_src(&cmd->start_src, TRIG_INT | TRIG_EXT);\n\terr |= comedi_check_trigger_src(&cmd->scan_begin_src,\n\t\t\t\t\tTRIG_TIMER | TRIG_EXT);\n\terr |= comedi_check_trigger_src(&cmd->convert_src, TRIG_NOW);\n\terr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\n\terr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_NONE);\n\n\tif (err)\n\t\treturn 1;\n\n\t \n\n\terr |= comedi_check_trigger_is_unique(cmd->start_src);\n\terr |= comedi_check_trigger_is_unique(cmd->scan_begin_src);\n\n\t \n\n\tif (cmd->convert_src == TRIG_EXT && cmd->scan_begin_src == TRIG_TIMER)\n\t\terr |= -EINVAL;\n\tif (cmd->stop_src != TRIG_COUNT &&\n\t    cmd->stop_src != TRIG_NONE && cmd->stop_src != TRIG_EXT)\n\t\terr |= -EINVAL;\n\n\tif (err)\n\t\treturn 2;\n\n\t \n\n\terr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\n\n\tif (cmd->scan_begin_src == TRIG_TIMER) {\n\t\terr |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,\n\t\t\t\t\t\t    board->ao_scan_speed);\n\t\tif (get_ao_divisor(cmd->scan_begin_arg, cmd->flags) >\n\t\t    max_counter_value) {\n\t\t\tcmd->scan_begin_arg = (max_counter_value + 2) *\n\t\t\t\t\t      TIMER_BASE;\n\t\t\terr |= -EINVAL;\n\t\t}\n\t}\n\n\terr |= comedi_check_trigger_arg_min(&cmd->chanlist_len, 1);\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\n\t\t\t\t\t   cmd->chanlist_len);\n\n\tif (err)\n\t\treturn 3;\n\n\t \n\n\tif (cmd->scan_begin_src == TRIG_TIMER) {\n\t\ttmp_arg = cmd->scan_begin_arg;\n\t\tcmd->scan_begin_arg = get_divisor(cmd->scan_begin_arg,\n\t\t\t\t\t\t  cmd->flags) * TIMER_BASE;\n\t\tif (tmp_arg != cmd->scan_begin_arg)\n\t\t\terr++;\n\t}\n\n\tif (err)\n\t\treturn 4;\n\n\t \n\tif (cmd->chanlist && cmd->chanlist_len > 0)\n\t\terr |= cb_pcidas64_ao_check_chanlist(dev, s, cmd);\n\n\tif (err)\n\t\treturn 5;\n\n\treturn 0;\n}\n\nstatic int ao_cancel(struct comedi_device *dev, struct comedi_subdevice *s)\n{\n\tstruct pcidas64_private *devpriv = dev->private;\n\n\twritew(0x0, devpriv->main_iobase + DAC_CONTROL0_REG);\n\tabort_dma(dev, 0);\n\treturn 0;\n}\n\nstatic int dio_callback_4020(struct comedi_device *dev,\n\t\t\t     int dir, int port, int data, unsigned long iobase)\n{\n\tstruct pcidas64_private *devpriv = dev->private;\n\n\tif (dir) {\n\t\twritew(data, devpriv->main_iobase + iobase + 2 * port);\n\t\treturn 0;\n\t}\n\treturn readw(devpriv->main_iobase + iobase + 2 * port);\n}\n\nstatic int di_rbits(struct comedi_device *dev, struct comedi_subdevice *s,\n\t\t    struct comedi_insn *insn, unsigned int *data)\n{\n\tunsigned int bits;\n\n\tbits = readb(dev->mmio + DI_REG);\n\tbits &= 0xf;\n\tdata[1] = bits;\n\tdata[0] = 0;\n\n\treturn insn->n;\n}\n\nstatic int do_wbits(struct comedi_device *dev,\n\t\t    struct comedi_subdevice *s,\n\t\t    struct comedi_insn *insn,\n\t\t    unsigned int *data)\n{\n\tif (comedi_dio_update_state(s, data))\n\t\twriteb(s->state, dev->mmio + DO_REG);\n\n\tdata[1] = s->state;\n\n\treturn insn->n;\n}\n\nstatic int dio_60xx_config_insn(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tstruct comedi_insn *insn,\n\t\t\t\tunsigned int *data)\n{\n\tint ret;\n\n\tret = comedi_dio_insn_config(dev, s, insn, data, 0);\n\tif (ret)\n\t\treturn ret;\n\n\twriteb(s->io_bits, dev->mmio + DIO_DIRECTION_60XX_REG);\n\n\treturn insn->n;\n}\n\nstatic int dio_60xx_wbits(struct comedi_device *dev,\n\t\t\t  struct comedi_subdevice *s,\n\t\t\t  struct comedi_insn *insn,\n\t\t\t  unsigned int *data)\n{\n\tif (comedi_dio_update_state(s, data))\n\t\twriteb(s->state, dev->mmio + DIO_DATA_60XX_REG);\n\n\tdata[1] = readb(dev->mmio + DIO_DATA_60XX_REG);\n\n\treturn insn->n;\n}\n\n \n \n\nstatic int caldac_8800_write(struct comedi_device *dev, unsigned int address,\n\t\t\t     u8 value)\n{\n\tstruct pcidas64_private *devpriv = dev->private;\n\tstatic const int num_caldac_channels = 8;\n\tstatic const int bitstream_length = 11;\n\tunsigned int bitstream = ((address & 0x7) << 8) | value;\n\tunsigned int bit, register_bits;\n\tstatic const int caldac_8800_udelay = 1;\n\n\tif (address >= num_caldac_channels) {\n\t\tdev_err(dev->class_dev, \"illegal caldac channel\\n\");\n\t\treturn -1;\n\t}\n\tfor (bit = 1 << (bitstream_length - 1); bit; bit >>= 1) {\n\t\tregister_bits = 0;\n\t\tif (bitstream & bit)\n\t\t\tregister_bits |= SERIAL_DATA_IN_BIT;\n\t\tudelay(caldac_8800_udelay);\n\t\twritew(register_bits, devpriv->main_iobase + CALIBRATION_REG);\n\t\tregister_bits |= SERIAL_CLOCK_BIT;\n\t\tudelay(caldac_8800_udelay);\n\t\twritew(register_bits, devpriv->main_iobase + CALIBRATION_REG);\n\t}\n\tudelay(caldac_8800_udelay);\n\twritew(SELECT_8800_BIT, devpriv->main_iobase + CALIBRATION_REG);\n\tudelay(caldac_8800_udelay);\n\twritew(0, devpriv->main_iobase + CALIBRATION_REG);\n\tudelay(caldac_8800_udelay);\n\treturn 0;\n}\n\n \nstatic int caldac_i2c_write(struct comedi_device *dev,\n\t\t\t    unsigned int caldac_channel, unsigned int value)\n{\n\tu8 serial_bytes[3];\n\tu8 i2c_addr;\n\tenum pointer_bits {\n\t\t \n\t\tOFFSET_0_2 = 0x1,\n\t\tGAIN_0_2 = 0x2,\n\t\tOFFSET_1_3 = 0x4,\n\t\tGAIN_1_3 = 0x8,\n\t};\n\tenum data_bits {\n\t\tNOT_CLEAR_REGISTERS = 0x20,\n\t};\n\n\tswitch (caldac_channel) {\n\tcase 0:\t\t\t\t\t \n\t\ti2c_addr = CALDAC0_I2C_ADDR;\n\t\tserial_bytes[0] = OFFSET_0_2;\n\t\tbreak;\n\tcase 1:\t\t\t\t\t \n\t\ti2c_addr = CALDAC0_I2C_ADDR;\n\t\tserial_bytes[0] = OFFSET_1_3;\n\t\tbreak;\n\tcase 2:\t\t\t\t\t \n\t\ti2c_addr = CALDAC1_I2C_ADDR;\n\t\tserial_bytes[0] = OFFSET_0_2;\n\t\tbreak;\n\tcase 3:\t\t\t\t\t \n\t\ti2c_addr = CALDAC1_I2C_ADDR;\n\t\tserial_bytes[0] = OFFSET_1_3;\n\t\tbreak;\n\tcase 4:\t\t\t\t\t \n\t\ti2c_addr = CALDAC0_I2C_ADDR;\n\t\tserial_bytes[0] = GAIN_0_2;\n\t\tbreak;\n\tcase 5:\t\t\t\t\t \n\t\ti2c_addr = CALDAC0_I2C_ADDR;\n\t\tserial_bytes[0] = GAIN_1_3;\n\t\tbreak;\n\tcase 6:\t\t\t\t\t \n\t\ti2c_addr = CALDAC1_I2C_ADDR;\n\t\tserial_bytes[0] = GAIN_0_2;\n\t\tbreak;\n\tcase 7:\t\t\t\t\t \n\t\ti2c_addr = CALDAC1_I2C_ADDR;\n\t\tserial_bytes[0] = GAIN_1_3;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev->class_dev, \"invalid caldac channel\\n\");\n\t\treturn -1;\n\t}\n\tserial_bytes[1] = NOT_CLEAR_REGISTERS | ((value >> 8) & 0xf);\n\tserial_bytes[2] = value & 0xff;\n\ti2c_write(dev, i2c_addr, serial_bytes, 3);\n\treturn 0;\n}\n\nstatic void caldac_write(struct comedi_device *dev, unsigned int channel,\n\t\t\t unsigned int value)\n{\n\tconst struct pcidas64_board *board = dev->board_ptr;\n\n\tswitch (board->layout) {\n\tcase LAYOUT_60XX:\n\tcase LAYOUT_64XX:\n\t\tcaldac_8800_write(dev, channel, value);\n\t\tbreak;\n\tcase LAYOUT_4020:\n\t\tcaldac_i2c_write(dev, channel, value);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int cb_pcidas64_calib_insn_write(struct comedi_device *dev,\n\t\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\t\tstruct comedi_insn *insn,\n\t\t\t\t\tunsigned int *data)\n{\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\n\t \n\tif (insn->n) {\n\t\tunsigned int val = data[insn->n - 1];\n\n\t\tif (s->readback[chan] != val) {\n\t\t\tcaldac_write(dev, chan, val);\n\t\t\ts->readback[chan] = val;\n\t\t}\n\t}\n\n\treturn insn->n;\n}\n\nstatic void ad8402_write(struct comedi_device *dev, unsigned int channel,\n\t\t\t unsigned int value)\n{\n\tstruct pcidas64_private *devpriv = dev->private;\n\tstatic const int bitstream_length = 10;\n\tunsigned int bit, register_bits;\n\tunsigned int bitstream = ((channel & 0x3) << 8) | (value & 0xff);\n\tstatic const int ad8402_udelay = 1;\n\n\tregister_bits = SELECT_8402_64XX_BIT;\n\tudelay(ad8402_udelay);\n\twritew(register_bits, devpriv->main_iobase + CALIBRATION_REG);\n\n\tfor (bit = 1 << (bitstream_length - 1); bit; bit >>= 1) {\n\t\tif (bitstream & bit)\n\t\t\tregister_bits |= SERIAL_DATA_IN_BIT;\n\t\telse\n\t\t\tregister_bits &= ~SERIAL_DATA_IN_BIT;\n\t\tudelay(ad8402_udelay);\n\t\twritew(register_bits, devpriv->main_iobase + CALIBRATION_REG);\n\t\tudelay(ad8402_udelay);\n\t\twritew(register_bits | SERIAL_CLOCK_BIT,\n\t\t       devpriv->main_iobase + CALIBRATION_REG);\n\t}\n\n\tudelay(ad8402_udelay);\n\twritew(0, devpriv->main_iobase + CALIBRATION_REG);\n}\n\n \nstatic int cb_pcidas64_ad8402_insn_write(struct comedi_device *dev,\n\t\t\t\t\t struct comedi_subdevice *s,\n\t\t\t\t\t struct comedi_insn *insn,\n\t\t\t\t\t unsigned int *data)\n{\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\n\t \n\tif (insn->n) {\n\t\tunsigned int val = data[insn->n - 1];\n\n\t\tif (s->readback[chan] != val) {\n\t\t\tad8402_write(dev, chan, val);\n\t\t\ts->readback[chan] = val;\n\t\t}\n\t}\n\n\treturn insn->n;\n}\n\nstatic u16 read_eeprom(struct comedi_device *dev, u8 address)\n{\n\tstruct pcidas64_private *devpriv = dev->private;\n\tstatic const int bitstream_length = 11;\n\tstatic const int read_command = 0x6;\n\tunsigned int bitstream = (read_command << 8) | address;\n\tunsigned int bit;\n\tvoid __iomem * const plx_control_addr =\n\t\tdevpriv->plx9080_iobase + PLX_REG_CNTRL;\n\tu16 value;\n\tstatic const int value_length = 16;\n\tstatic const int eeprom_udelay = 1;\n\n\tudelay(eeprom_udelay);\n\tdevpriv->plx_control_bits &= ~PLX_CNTRL_EESK & ~PLX_CNTRL_EECS;\n\t \n\tdevpriv->plx_control_bits |= PLX_CNTRL_USERO;\n\twritel(devpriv->plx_control_bits, plx_control_addr);\n\t \n\tudelay(eeprom_udelay);\n\tdevpriv->plx_control_bits |= PLX_CNTRL_EECS;\n\twritel(devpriv->plx_control_bits, plx_control_addr);\n\n\t \n\tfor (bit = 1 << (bitstream_length - 1); bit; bit >>= 1) {\n\t\t \n\t\tudelay(eeprom_udelay);\n\t\tif (bitstream & bit)\n\t\t\tdevpriv->plx_control_bits |= PLX_CNTRL_EEWB;\n\t\telse\n\t\t\tdevpriv->plx_control_bits &= ~PLX_CNTRL_EEWB;\n\t\twritel(devpriv->plx_control_bits, plx_control_addr);\n\t\t \n\t\tudelay(eeprom_udelay);\n\t\tdevpriv->plx_control_bits |= PLX_CNTRL_EESK;\n\t\twritel(devpriv->plx_control_bits, plx_control_addr);\n\t\tudelay(eeprom_udelay);\n\t\tdevpriv->plx_control_bits &= ~PLX_CNTRL_EESK;\n\t\twritel(devpriv->plx_control_bits, plx_control_addr);\n\t}\n\t \n\tvalue = 0;\n\tfor (bit = 1 << (value_length - 1); bit; bit >>= 1) {\n\t\t \n\t\tudelay(eeprom_udelay);\n\t\tdevpriv->plx_control_bits |= PLX_CNTRL_EESK;\n\t\twritel(devpriv->plx_control_bits, plx_control_addr);\n\t\tudelay(eeprom_udelay);\n\t\tdevpriv->plx_control_bits &= ~PLX_CNTRL_EESK;\n\t\twritel(devpriv->plx_control_bits, plx_control_addr);\n\t\tudelay(eeprom_udelay);\n\t\tif (readl(plx_control_addr) & PLX_CNTRL_EERB)\n\t\t\tvalue |= bit;\n\t}\n\n\t \n\tudelay(eeprom_udelay);\n\tdevpriv->plx_control_bits &= ~PLX_CNTRL_EECS;\n\twritel(devpriv->plx_control_bits, plx_control_addr);\n\n\treturn value;\n}\n\nstatic int eeprom_read_insn(struct comedi_device *dev,\n\t\t\t    struct comedi_subdevice *s,\n\t\t\t    struct comedi_insn *insn, unsigned int *data)\n{\n\tunsigned int val;\n\tunsigned int i;\n\n\tif (insn->n) {\n\t\t \n\t\tval = read_eeprom(dev, CR_CHAN(insn->chanspec));\n\t\tfor (i = 0; i < insn->n; i++)\n\t\t\tdata[i] = val;\n\t}\n\n\treturn insn->n;\n}\n\n \nstatic int setup_subdevices(struct comedi_device *dev)\n{\n\tconst struct pcidas64_board *board = dev->board_ptr;\n\tstruct pcidas64_private *devpriv = dev->private;\n\tstruct comedi_subdevice *s;\n\tint i;\n\tint ret;\n\n\tret = comedi_alloc_subdevices(dev, 10);\n\tif (ret)\n\t\treturn ret;\n\n\ts = &dev->subdevices[0];\n\t \n\tdev->read_subdev = s;\n\ts->type = COMEDI_SUBD_AI;\n\ts->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_DITHER | SDF_CMD_READ;\n\tif (board->layout == LAYOUT_60XX)\n\t\ts->subdev_flags |= SDF_COMMON | SDF_DIFF;\n\telse if (board->layout == LAYOUT_64XX)\n\t\ts->subdev_flags |= SDF_DIFF;\n\t \n\ts->n_chan = board->ai_se_chans;\n\ts->len_chanlist = 0x2000;\n\ts->maxdata = (1 << board->ai_bits) - 1;\n\ts->range_table = board->ai_range_table;\n\ts->insn_read = ai_rinsn;\n\ts->insn_config = ai_config_insn;\n\ts->do_cmd = ai_cmd;\n\ts->do_cmdtest = ai_cmdtest;\n\ts->cancel = ai_cancel;\n\tif (board->layout == LAYOUT_4020) {\n\t\tu8 data;\n\t\t \n\t\tdevpriv->i2c_cal_range_bits = adc_src_4020_bits(4);\n\t\t \n\t\tfor (i = 0; i < s->n_chan; i++)\n\t\t\tdevpriv->i2c_cal_range_bits |= attenuate_bit(i);\n\t\tdata = devpriv->i2c_cal_range_bits;\n\t\ti2c_write(dev, RANGE_CAL_I2C_ADDR, &data, sizeof(data));\n\t}\n\n\t \n\ts = &dev->subdevices[1];\n\tif (board->ao_nchan) {\n\t\ts->type = COMEDI_SUBD_AO;\n\t\ts->subdev_flags = SDF_READABLE | SDF_WRITABLE |\n\t\t\t\t  SDF_GROUND | SDF_CMD_WRITE;\n\t\ts->n_chan = board->ao_nchan;\n\t\ts->maxdata = (1 << board->ao_bits) - 1;\n\t\ts->range_table = board->ao_range_table;\n\t\ts->insn_write = ao_winsn;\n\n\t\tret = comedi_alloc_subdev_readback(s);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (ao_cmd_is_supported(board)) {\n\t\t\tdev->write_subdev = s;\n\t\t\ts->do_cmdtest = ao_cmdtest;\n\t\t\ts->do_cmd = ao_cmd;\n\t\t\ts->len_chanlist = board->ao_nchan;\n\t\t\ts->cancel = ao_cancel;\n\t\t}\n\t} else {\n\t\ts->type = COMEDI_SUBD_UNUSED;\n\t}\n\n\t \n\ts = &dev->subdevices[2];\n\tif (board->layout == LAYOUT_64XX) {\n\t\ts->type = COMEDI_SUBD_DI;\n\t\ts->subdev_flags = SDF_READABLE;\n\t\ts->n_chan = 4;\n\t\ts->maxdata = 1;\n\t\ts->range_table = &range_digital;\n\t\ts->insn_bits = di_rbits;\n\t} else {\n\t\ts->type = COMEDI_SUBD_UNUSED;\n\t}\n\n\t \n\tif (board->layout == LAYOUT_64XX) {\n\t\ts = &dev->subdevices[3];\n\t\ts->type = COMEDI_SUBD_DO;\n\t\ts->subdev_flags = SDF_WRITABLE;\n\t\ts->n_chan = 4;\n\t\ts->maxdata = 1;\n\t\ts->range_table = &range_digital;\n\t\ts->insn_bits = do_wbits;\n\t} else {\n\t\ts->type = COMEDI_SUBD_UNUSED;\n\t}\n\n\t \n\ts = &dev->subdevices[4];\n\tif (board->has_8255) {\n\t\tif (board->layout == LAYOUT_4020) {\n\t\t\tret = subdev_8255_init(dev, s, dio_callback_4020,\n\t\t\t\t\t       I8255_4020_REG);\n\t\t} else {\n\t\t\tret = subdev_8255_mm_init(dev, s, NULL,\n\t\t\t\t\t\t  DIO_8255_OFFSET);\n\t\t}\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\ts->type = COMEDI_SUBD_UNUSED;\n\t}\n\n\t \n\ts = &dev->subdevices[5];\n\tif (board->layout == LAYOUT_60XX) {\n\t\ts->type = COMEDI_SUBD_DIO;\n\t\ts->subdev_flags = SDF_WRITABLE | SDF_READABLE;\n\t\ts->n_chan = 8;\n\t\ts->maxdata = 1;\n\t\ts->range_table = &range_digital;\n\t\ts->insn_config = dio_60xx_config_insn;\n\t\ts->insn_bits = dio_60xx_wbits;\n\t} else {\n\t\ts->type = COMEDI_SUBD_UNUSED;\n\t}\n\n\t \n\ts = &dev->subdevices[6];\n\ts->type = COMEDI_SUBD_CALIB;\n\ts->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;\n\ts->n_chan = 8;\n\tif (board->layout == LAYOUT_4020)\n\t\ts->maxdata = 0xfff;\n\telse\n\t\ts->maxdata = 0xff;\n\ts->insn_write = cb_pcidas64_calib_insn_write;\n\n\tret = comedi_alloc_subdev_readback(s);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < s->n_chan; i++) {\n\t\tcaldac_write(dev, i, s->maxdata / 2);\n\t\ts->readback[i] = s->maxdata / 2;\n\t}\n\n\t \n\ts = &dev->subdevices[7];\n\tif (board->layout == LAYOUT_64XX) {\n\t\ts->type = COMEDI_SUBD_CALIB;\n\t\ts->subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;\n\t\ts->n_chan = 2;\n\t\ts->maxdata = 0xff;\n\t\ts->insn_write = cb_pcidas64_ad8402_insn_write;\n\n\t\tret = comedi_alloc_subdev_readback(s);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tfor (i = 0; i < s->n_chan; i++) {\n\t\t\tad8402_write(dev, i, s->maxdata / 2);\n\t\t\ts->readback[i] = s->maxdata / 2;\n\t\t}\n\t} else {\n\t\ts->type = COMEDI_SUBD_UNUSED;\n\t}\n\n\t \n\ts = &dev->subdevices[8];\n\tif (readl(devpriv->plx9080_iobase + PLX_REG_CNTRL) &\n\t    PLX_CNTRL_EEPRESENT) {\n\t\ts->type = COMEDI_SUBD_MEMORY;\n\t\ts->subdev_flags = SDF_READABLE | SDF_INTERNAL;\n\t\ts->n_chan = 128;\n\t\ts->maxdata = 0xffff;\n\t\ts->insn_read = eeprom_read_insn;\n\t} else {\n\t\ts->type = COMEDI_SUBD_UNUSED;\n\t}\n\n\t \n\ts = &dev->subdevices[9];\n\ts->type = COMEDI_SUBD_UNUSED;\n\n\treturn 0;\n}\n\nstatic int auto_attach(struct comedi_device *dev,\n\t\t       unsigned long context)\n{\n\tstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\n\tconst struct pcidas64_board *board = NULL;\n\tstruct pcidas64_private *devpriv;\n\tu32 local_range, local_decode;\n\tint retval;\n\n\tif (context < ARRAY_SIZE(pcidas64_boards))\n\t\tboard = &pcidas64_boards[context];\n\tif (!board)\n\t\treturn -ENODEV;\n\tdev->board_ptr = board;\n\n\tdevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\n\tif (!devpriv)\n\t\treturn -ENOMEM;\n\n\tretval = comedi_pci_enable(dev);\n\tif (retval)\n\t\treturn retval;\n\tpci_set_master(pcidev);\n\n\t \n\tdev->board_name = board->name;\n\n\tdevpriv->main_phys_iobase = pci_resource_start(pcidev, 2);\n\tdevpriv->dio_counter_phys_iobase = pci_resource_start(pcidev, 3);\n\n\tdevpriv->plx9080_iobase = pci_ioremap_bar(pcidev, 0);\n\tdevpriv->main_iobase = pci_ioremap_bar(pcidev, 2);\n\tdev->mmio = pci_ioremap_bar(pcidev, 3);\n\n\tif (!devpriv->plx9080_iobase || !devpriv->main_iobase || !dev->mmio) {\n\t\tdev_warn(dev->class_dev, \"failed to remap io memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tlocal_range = readl(devpriv->plx9080_iobase + PLX_REG_LAS0RR) &\n\t\t      PLX_LASRR_MEM_MASK;\n\tlocal_decode = readl(devpriv->plx9080_iobase + PLX_REG_LAS0BA) &\n\t\t       local_range & PLX_LASBA_MEM_MASK;\n\tdevpriv->local0_iobase = ((u32)devpriv->main_phys_iobase &\n\t\t\t\t  ~local_range) | local_decode;\n\tlocal_range = readl(devpriv->plx9080_iobase + PLX_REG_LAS1RR) &\n\t\t      PLX_LASRR_MEM_MASK;\n\tlocal_decode = readl(devpriv->plx9080_iobase + PLX_REG_LAS1BA) &\n\t\t       local_range & PLX_LASBA_MEM_MASK;\n\tdevpriv->local1_iobase = ((u32)devpriv->dio_counter_phys_iobase &\n\t\t\t\t  ~local_range) | local_decode;\n\n\tretval = alloc_and_init_dma_members(dev);\n\tif (retval < 0)\n\t\treturn retval;\n\n\tdevpriv->hw_revision =\n\t\thw_revision(dev, readw(devpriv->main_iobase + HW_STATUS_REG));\n\tdev_dbg(dev->class_dev, \"stc hardware revision %i\\n\",\n\t\tdevpriv->hw_revision);\n\tinit_plx9080(dev);\n\tinit_stc_registers(dev);\n\n\tretval = request_irq(pcidev->irq, handle_interrupt, IRQF_SHARED,\n\t\t\t     \"cb_pcidas64\", dev);\n\tif (retval) {\n\t\tdev_dbg(dev->class_dev, \"unable to allocate irq %u\\n\",\n\t\t\tpcidev->irq);\n\t\treturn retval;\n\t}\n\tdev->irq = pcidev->irq;\n\tdev_dbg(dev->class_dev, \"irq %u\\n\", dev->irq);\n\n\tretval = setup_subdevices(dev);\n\tif (retval < 0)\n\t\treturn retval;\n\n\treturn 0;\n}\n\nstatic void detach(struct comedi_device *dev)\n{\n\tstruct pcidas64_private *devpriv = dev->private;\n\n\tif (dev->irq)\n\t\tfree_irq(dev->irq, dev);\n\tif (devpriv) {\n\t\tif (devpriv->plx9080_iobase) {\n\t\t\tdisable_plx_interrupts(dev);\n\t\t\tiounmap(devpriv->plx9080_iobase);\n\t\t}\n\t\tif (devpriv->main_iobase)\n\t\t\tiounmap(devpriv->main_iobase);\n\t\tif (dev->mmio)\n\t\t\tiounmap(dev->mmio);\n\t}\n\tcomedi_pci_disable(dev);\n\tcb_pcidas64_free_dma(dev);\n}\n\nstatic struct comedi_driver cb_pcidas64_driver = {\n\t.driver_name\t= \"cb_pcidas64\",\n\t.module\t\t= THIS_MODULE,\n\t.auto_attach\t= auto_attach,\n\t.detach\t\t= detach,\n};\n\nstatic int cb_pcidas64_pci_probe(struct pci_dev *dev,\n\t\t\t\t const struct pci_device_id *id)\n{\n\treturn comedi_pci_auto_config(dev, &cb_pcidas64_driver,\n\t\t\t\t      id->driver_data);\n}\n\nstatic const struct pci_device_id cb_pcidas64_pci_table[] = {\n\t{ PCI_VDEVICE(CB, 0x001d), BOARD_PCIDAS6402_16 },\n\t{ PCI_VDEVICE(CB, 0x001e), BOARD_PCIDAS6402_12 },\n\t{ PCI_VDEVICE(CB, 0x0035), BOARD_PCIDAS64_M1_16 },\n\t{ PCI_VDEVICE(CB, 0x0036), BOARD_PCIDAS64_M2_16 },\n\t{ PCI_VDEVICE(CB, 0x0037), BOARD_PCIDAS64_M3_16 },\n\t{ PCI_VDEVICE(CB, 0x0052), BOARD_PCIDAS4020_12 },\n\t{ PCI_VDEVICE(CB, 0x005d), BOARD_PCIDAS6023 },\n\t{ PCI_VDEVICE(CB, 0x005e), BOARD_PCIDAS6025 },\n\t{ PCI_VDEVICE(CB, 0x005f), BOARD_PCIDAS6030 },\n\t{ PCI_VDEVICE(CB, 0x0060), BOARD_PCIDAS6031 },\n\t{ PCI_VDEVICE(CB, 0x0061), BOARD_PCIDAS6032 },\n\t{ PCI_VDEVICE(CB, 0x0062), BOARD_PCIDAS6033 },\n\t{ PCI_VDEVICE(CB, 0x0063), BOARD_PCIDAS6034 },\n\t{ PCI_VDEVICE(CB, 0x0064), BOARD_PCIDAS6035 },\n\t{ PCI_VDEVICE(CB, 0x0065), BOARD_PCIDAS6040 },\n\t{ PCI_VDEVICE(CB, 0x0066), BOARD_PCIDAS6052 },\n\t{ PCI_VDEVICE(CB, 0x0067), BOARD_PCIDAS6070 },\n\t{ PCI_VDEVICE(CB, 0x0068), BOARD_PCIDAS6071 },\n\t{ PCI_VDEVICE(CB, 0x006f), BOARD_PCIDAS6036 },\n\t{ PCI_VDEVICE(CB, 0x0078), BOARD_PCIDAS6013 },\n\t{ PCI_VDEVICE(CB, 0x0079), BOARD_PCIDAS6014 },\n\t{ 0 }\n};\nMODULE_DEVICE_TABLE(pci, cb_pcidas64_pci_table);\n\nstatic struct pci_driver cb_pcidas64_pci_driver = {\n\t.name\t\t= \"cb_pcidas64\",\n\t.id_table\t= cb_pcidas64_pci_table,\n\t.probe\t\t= cb_pcidas64_pci_probe,\n\t.remove\t\t= comedi_pci_auto_unconfig,\n};\nmodule_comedi_pci_driver(cb_pcidas64_driver, cb_pcidas64_pci_driver);\n\nMODULE_AUTHOR(\"Comedi https://www.comedi.org\");\nMODULE_DESCRIPTION(\"Comedi low-level driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}