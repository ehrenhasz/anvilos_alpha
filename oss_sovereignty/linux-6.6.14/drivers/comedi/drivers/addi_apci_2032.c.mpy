{
  "module_name": "addi_apci_2032.c",
  "hash_id": "4f4eaddbde58a14fbbeb28b83f8d2693e1db2d2e36a78b5bb04ebfed4acded85",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/addi_apci_2032.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/comedi/comedi_pci.h>\n\n#include \"addi_watchdog.h\"\n\n \n#define APCI2032_DO_REG\t\t\t0x00\n#define APCI2032_INT_CTRL_REG\t\t0x04\n#define APCI2032_INT_CTRL_VCC_ENA\tBIT(0)\n#define APCI2032_INT_CTRL_CC_ENA\tBIT(1)\n#define APCI2032_INT_STATUS_REG\t\t0x08\n#define APCI2032_INT_STATUS_VCC\t\tBIT(0)\n#define APCI2032_INT_STATUS_CC\t\tBIT(1)\n#define APCI2032_STATUS_REG\t\t0x0c\n#define APCI2032_STATUS_IRQ\t\tBIT(0)\n#define APCI2032_WDOG_REG\t\t0x10\n\nstruct apci2032_int_private {\n\tspinlock_t spinlock;\t\t \n\tbool active;\t\t\t \n\tunsigned char enabled_isns;\t \n};\n\nstatic int apci2032_do_insn_bits(struct comedi_device *dev,\n\t\t\t\t struct comedi_subdevice *s,\n\t\t\t\t struct comedi_insn *insn,\n\t\t\t\t unsigned int *data)\n{\n\ts->state = inl(dev->iobase + APCI2032_DO_REG);\n\n\tif (comedi_dio_update_state(s, data))\n\t\toutl(s->state, dev->iobase + APCI2032_DO_REG);\n\n\tdata[1] = s->state;\n\n\treturn insn->n;\n}\n\nstatic int apci2032_int_insn_bits(struct comedi_device *dev,\n\t\t\t\t  struct comedi_subdevice *s,\n\t\t\t\t  struct comedi_insn *insn,\n\t\t\t\t  unsigned int *data)\n{\n\tdata[1] = inl(dev->iobase + APCI2032_INT_STATUS_REG) & 3;\n\treturn insn->n;\n}\n\nstatic void apci2032_int_stop(struct comedi_device *dev,\n\t\t\t      struct comedi_subdevice *s)\n{\n\tstruct apci2032_int_private *subpriv = s->private;\n\n\tsubpriv->active = false;\n\tsubpriv->enabled_isns = 0;\n\toutl(0x0, dev->iobase + APCI2032_INT_CTRL_REG);\n}\n\nstatic int apci2032_int_cmdtest(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tstruct comedi_cmd *cmd)\n{\n\tint err = 0;\n\n\t \n\n\terr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW);\n\terr |= comedi_check_trigger_src(&cmd->scan_begin_src, TRIG_EXT);\n\terr |= comedi_check_trigger_src(&cmd->convert_src, TRIG_NOW);\n\terr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\n\terr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\n\n\tif (err)\n\t\treturn 1;\n\n\t \n\terr |= comedi_check_trigger_is_unique(cmd->stop_src);\n\n\t \n\n\tif (err)\n\t\treturn 2;\n\n\t \n\n\terr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);\n\terr |= comedi_check_trigger_arg_is(&cmd->convert_arg, 0);\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\n\t\t\t\t\t   cmd->chanlist_len);\n\tif (cmd->stop_src == TRIG_COUNT)\n\t\terr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\n\telse\t \n\t\terr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\n\n\tif (err)\n\t\treturn 3;\n\n\t \n\n\t \n\n\treturn 0;\n}\n\nstatic int apci2032_int_cmd(struct comedi_device *dev,\n\t\t\t    struct comedi_subdevice *s)\n{\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tstruct apci2032_int_private *subpriv = s->private;\n\tunsigned char enabled_isns;\n\tunsigned int n;\n\tunsigned long flags;\n\n\tenabled_isns = 0;\n\tfor (n = 0; n < cmd->chanlist_len; n++)\n\t\tenabled_isns |= 1 << CR_CHAN(cmd->chanlist[n]);\n\n\tspin_lock_irqsave(&subpriv->spinlock, flags);\n\n\tsubpriv->enabled_isns = enabled_isns;\n\tsubpriv->active = true;\n\toutl(enabled_isns, dev->iobase + APCI2032_INT_CTRL_REG);\n\n\tspin_unlock_irqrestore(&subpriv->spinlock, flags);\n\n\treturn 0;\n}\n\nstatic int apci2032_int_cancel(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s)\n{\n\tstruct apci2032_int_private *subpriv = s->private;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&subpriv->spinlock, flags);\n\tif (subpriv->active)\n\t\tapci2032_int_stop(dev, s);\n\tspin_unlock_irqrestore(&subpriv->spinlock, flags);\n\n\treturn 0;\n}\n\nstatic irqreturn_t apci2032_interrupt(int irq, void *d)\n{\n\tstruct comedi_device *dev = d;\n\tstruct comedi_subdevice *s = dev->read_subdev;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tstruct apci2032_int_private *subpriv;\n\tunsigned int val;\n\n\tif (!dev->attached)\n\t\treturn IRQ_NONE;\n\n\t \n\tval = inl(dev->iobase + APCI2032_STATUS_REG) & APCI2032_STATUS_IRQ;\n\tif (!val)\n\t\treturn IRQ_NONE;\n\n\tsubpriv = s->private;\n\tspin_lock(&subpriv->spinlock);\n\n\tval = inl(dev->iobase + APCI2032_INT_STATUS_REG) & 3;\n\t \n\toutl(~val & 3, dev->iobase + APCI2032_INT_CTRL_REG);\n\t \n\n\tif (subpriv->active && (val & subpriv->enabled_isns) != 0) {\n\t\tunsigned short bits = 0;\n\t\tint i;\n\n\t\t \n\t\tfor (i = 0; i < cmd->chanlist_len; i++) {\n\t\t\tunsigned int chan = CR_CHAN(cmd->chanlist[i]);\n\n\t\t\tif (val & (1 << chan))\n\t\t\t\tbits |= (1 << i);\n\t\t}\n\n\t\tcomedi_buf_write_samples(s, &bits, 1);\n\n\t\tif (cmd->stop_src == TRIG_COUNT &&\n\t\t    s->async->scans_done >= cmd->stop_arg)\n\t\t\ts->async->events |= COMEDI_CB_EOA;\n\t}\n\n\tspin_unlock(&subpriv->spinlock);\n\n\tcomedi_handle_events(dev, s);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int apci2032_reset(struct comedi_device *dev)\n{\n\toutl(0x0, dev->iobase + APCI2032_DO_REG);\n\toutl(0x0, dev->iobase + APCI2032_INT_CTRL_REG);\n\n\taddi_watchdog_reset(dev->iobase + APCI2032_WDOG_REG);\n\n\treturn 0;\n}\n\nstatic int apci2032_auto_attach(struct comedi_device *dev,\n\t\t\t\tunsigned long context_unused)\n{\n\tstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\n\tstruct comedi_subdevice *s;\n\tint ret;\n\n\tret = comedi_pci_enable(dev);\n\tif (ret)\n\t\treturn ret;\n\tdev->iobase = pci_resource_start(pcidev, 1);\n\tapci2032_reset(dev);\n\n\tif (pcidev->irq > 0) {\n\t\tret = request_irq(pcidev->irq, apci2032_interrupt,\n\t\t\t\t  IRQF_SHARED, dev->board_name, dev);\n\t\tif (ret == 0)\n\t\t\tdev->irq = pcidev->irq;\n\t}\n\n\tret = comedi_alloc_subdevices(dev, 3);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ts = &dev->subdevices[0];\n\ts->type\t\t= COMEDI_SUBD_DO;\n\ts->subdev_flags\t= SDF_WRITABLE;\n\ts->n_chan\t= 32;\n\ts->maxdata\t= 1;\n\ts->range_table\t= &range_digital;\n\ts->insn_bits\t= apci2032_do_insn_bits;\n\n\t \n\ts = &dev->subdevices[1];\n\tret = addi_watchdog_init(s, dev->iobase + APCI2032_WDOG_REG);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ts = &dev->subdevices[2];\n\ts->type\t\t= COMEDI_SUBD_DI;\n\ts->subdev_flags\t= SDF_READABLE;\n\ts->n_chan\t= 2;\n\ts->maxdata\t= 1;\n\ts->range_table\t= &range_digital;\n\ts->insn_bits\t= apci2032_int_insn_bits;\n\tif (dev->irq) {\n\t\tstruct apci2032_int_private *subpriv;\n\n\t\tdev->read_subdev = s;\n\t\tsubpriv = kzalloc(sizeof(*subpriv), GFP_KERNEL);\n\t\tif (!subpriv)\n\t\t\treturn -ENOMEM;\n\t\tspin_lock_init(&subpriv->spinlock);\n\t\ts->private\t= subpriv;\n\t\ts->subdev_flags\t= SDF_READABLE | SDF_CMD_READ | SDF_PACKED;\n\t\ts->len_chanlist = 2;\n\t\ts->do_cmdtest\t= apci2032_int_cmdtest;\n\t\ts->do_cmd\t= apci2032_int_cmd;\n\t\ts->cancel\t= apci2032_int_cancel;\n\t}\n\n\treturn 0;\n}\n\nstatic void apci2032_detach(struct comedi_device *dev)\n{\n\tif (dev->iobase)\n\t\tapci2032_reset(dev);\n\tcomedi_pci_detach(dev);\n\tif (dev->read_subdev)\n\t\tkfree(dev->read_subdev->private);\n}\n\nstatic struct comedi_driver apci2032_driver = {\n\t.driver_name\t= \"addi_apci_2032\",\n\t.module\t\t= THIS_MODULE,\n\t.auto_attach\t= apci2032_auto_attach,\n\t.detach\t\t= apci2032_detach,\n};\n\nstatic int apci2032_pci_probe(struct pci_dev *dev,\n\t\t\t      const struct pci_device_id *id)\n{\n\treturn comedi_pci_auto_config(dev, &apci2032_driver, id->driver_data);\n}\n\nstatic const struct pci_device_id apci2032_pci_table[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_ADDIDATA, 0x1004) },\n\t{ 0 }\n};\nMODULE_DEVICE_TABLE(pci, apci2032_pci_table);\n\nstatic struct pci_driver apci2032_pci_driver = {\n\t.name\t\t= \"addi_apci_2032\",\n\t.id_table\t= apci2032_pci_table,\n\t.probe\t\t= apci2032_pci_probe,\n\t.remove\t\t= comedi_pci_auto_unconfig,\n};\nmodule_comedi_pci_driver(apci2032_driver, apci2032_pci_driver);\n\nMODULE_AUTHOR(\"Comedi https://www.comedi.org\");\nMODULE_DESCRIPTION(\"ADDI-DATA APCI-2032, 32 channel DO boards\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}