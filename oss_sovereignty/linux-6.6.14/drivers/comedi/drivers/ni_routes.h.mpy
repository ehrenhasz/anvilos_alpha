{
  "module_name": "ni_routes.h",
  "hash_id": "c70daeba0dbe3ac586b1ce9001c326bcff588716bed27ce15aed4288ab3ee22a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/ni_routes.h",
  "human_readable_source": " \n \n\n#ifndef _COMEDI_DRIVERS_NI_ROUTES_H\n#define _COMEDI_DRIVERS_NI_ROUTES_H\n\n#include <linux/types.h>\n#include <linux/errno.h>\n\n#ifndef NI_ROUTE_VALUE_EXTERNAL_CONVERSION\n#include <linux/bitops.h>\n#endif\n\n#include <linux/comedi.h>\n\n \nstruct ni_route_set {\n\tint dest;\n\tint n_src;\n\tint *src;\n};\n\n \nstruct ni_device_routes {\n\tconst char *device;\n\tint n_route_sets;\n\tstruct ni_route_set *routes;\n};\n\n \nstruct ni_route_tables {\n\tconst struct ni_device_routes *valid_routes;\n\tconst u8 *route_values;\n};\n\n \nint ni_assign_device_routes(const char *device_family,\n\t\t\t    const char *board_name,\n\t\t\t    const char *alt_board_name,\n\t\t\t    struct ni_route_tables *tables);\n\n \nconst struct ni_route_set *\nni_find_route_set(const int destination,\n\t\t  const struct ni_device_routes *valid_routes);\n\n \nbool ni_route_set_has_source(const struct ni_route_set *routes, const int src);\n\n \ns8 ni_route_to_register(const int src, const int dest,\n\t\t\tconst struct ni_route_tables *tables);\n\nstatic inline bool ni_rtsi_route_requires_mux(s8 value)\n{\n\treturn value & BIT(6);\n}\n\n \ns8 ni_lookup_route_register(int src, int dest,\n\t\t\t    const struct ni_route_tables *tables);\n\n \nstatic inline bool route_is_valid(const int src, const int dest,\n\t\t\t\t  const struct ni_route_tables *tables)\n{\n\treturn ni_route_to_register(src, dest, tables) >= 0;\n}\n\n \nbool ni_is_cmd_dest(int dest);\n\nstatic inline bool channel_is_pfi(int channel)\n{\n\treturn NI_PFI(0) <= channel && channel <= NI_PFI(-1);\n}\n\nstatic inline bool channel_is_rtsi(int channel)\n{\n\treturn TRIGGER_LINE(0) <= channel && channel <= TRIGGER_LINE(-1);\n}\n\nstatic inline bool channel_is_ctr(int channel)\n{\n\treturn channel >= NI_COUNTER_NAMES_BASE &&\n\t       channel <= NI_COUNTER_NAMES_MAX;\n}\n\n \nunsigned int ni_count_valid_routes(const struct ni_route_tables *tables);\n\n \nunsigned int ni_get_valid_routes(const struct ni_route_tables *tables,\n\t\t\t\t unsigned int n_pairs,\n\t\t\t\t unsigned int *pair_data);\n\n \nvoid ni_sort_device_routes(struct ni_device_routes *valid_routes);\n\n \nint ni_find_route_source(const u8 src_sel_reg_value, const int dest,\n\t\t\t const struct ni_route_tables *tables);\n\n \nstatic inline bool route_register_is_valid(const u8 src_sel_reg_value,\n\t\t\t\t\t   const int dest,\n\t\t\t\t\t   const struct ni_route_tables *tables)\n{\n\treturn ni_find_route_source(src_sel_reg_value, dest, tables) >= 0;\n}\n\n \nstatic inline s8 ni_get_reg_value_roffs(int src, const int dest,\n\t\t\t\t\tconst struct ni_route_tables *tables,\n\t\t\t\t\tconst int direct_reg_offset)\n{\n\tif (src < NI_NAMES_BASE) {\n\t\tsrc += direct_reg_offset;\n\t\t \n\t\tif (route_register_is_valid(src, dest, tables))\n\t\t\treturn src;\n\t\treturn -1;\n\t}\n\n\t \n\treturn ni_route_to_register(src, dest, tables);\n}\n\nstatic inline int ni_get_reg_value(const int src, const int dest,\n\t\t\t\t   const struct ni_route_tables *tables)\n{\n\treturn ni_get_reg_value_roffs(src, dest, tables, 0);\n}\n\n \nstatic inline\nint ni_check_trigger_arg_roffs(int src, const int dest,\n\t\t\t       const struct ni_route_tables *tables,\n\t\t\t       const int direct_reg_offset)\n{\n\tif (ni_get_reg_value_roffs(src, dest, tables, direct_reg_offset) < 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic inline int ni_check_trigger_arg(const int src, const int dest,\n\t\t\t\t       const struct ni_route_tables *tables)\n{\n\treturn ni_check_trigger_arg_roffs(src, dest, tables, 0);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}