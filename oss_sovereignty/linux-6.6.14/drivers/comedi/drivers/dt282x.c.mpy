{
  "module_name": "dt282x.c",
  "hash_id": "321a4a5e7a9572b0b251022e3a2f85b8834cdec65d2b734301cc1f3be9764775",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/dt282x.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/comedi/comedidev.h>\n#include <linux/comedi/comedi_isadma.h>\n\n \n#define DT2821_ADCSR_REG\t\t0x00\n#define DT2821_ADCSR_ADERR\t\tBIT(15)\n#define DT2821_ADCSR_ADCLK\t\tBIT(9)\n#define DT2821_ADCSR_MUXBUSY\t\tBIT(8)\n#define DT2821_ADCSR_ADDONE\t\tBIT(7)\n#define DT2821_ADCSR_IADDONE\t\tBIT(6)\n#define DT2821_ADCSR_GS(x)\t\t(((x) & 0x3) << 4)\n#define DT2821_ADCSR_CHAN(x)\t\t(((x) & 0xf) << 0)\n#define DT2821_CHANCSR_REG\t\t0x02\n#define DT2821_CHANCSR_LLE\t\tBIT(15)\n#define DT2821_CHANCSR_TO_PRESLA(x)\t(((x) >> 8) & 0xf)\n#define DT2821_CHANCSR_NUMB(x)\t\t((((x) - 1) & 0xf) << 0)\n#define DT2821_ADDAT_REG\t\t0x04\n#define DT2821_DACSR_REG\t\t0x06\n#define DT2821_DACSR_DAERR\t\tBIT(15)\n#define DT2821_DACSR_YSEL(x)\t\t((x) << 9)\n#define DT2821_DACSR_SSEL\t\tBIT(8)\n#define DT2821_DACSR_DACRDY\t\tBIT(7)\n#define DT2821_DACSR_IDARDY\t\tBIT(6)\n#define DT2821_DACSR_DACLK\t\tBIT(5)\n#define DT2821_DACSR_HBOE\t\tBIT(1)\n#define DT2821_DACSR_LBOE\t\tBIT(0)\n#define DT2821_DADAT_REG\t\t0x08\n#define DT2821_DIODAT_REG\t\t0x0a\n#define DT2821_SUPCSR_REG\t\t0x0c\n#define DT2821_SUPCSR_DMAD\t\tBIT(15)\n#define DT2821_SUPCSR_ERRINTEN\t\tBIT(14)\n#define DT2821_SUPCSR_CLRDMADNE\t\tBIT(13)\n#define DT2821_SUPCSR_DDMA\t\tBIT(12)\n#define DT2821_SUPCSR_DS(x)\t\t(((x) & 0x3) << 10)\n#define DT2821_SUPCSR_DS_PIO\t\tDT2821_SUPCSR_DS(0)\n#define DT2821_SUPCSR_DS_AD_CLK\t\tDT2821_SUPCSR_DS(1)\n#define DT2821_SUPCSR_DS_DA_CLK\t\tDT2821_SUPCSR_DS(2)\n#define DT2821_SUPCSR_DS_AD_TRIG\tDT2821_SUPCSR_DS(3)\n#define DT2821_SUPCSR_BUFFB\t\tBIT(9)\n#define DT2821_SUPCSR_SCDN\t\tBIT(8)\n#define DT2821_SUPCSR_DACON\t\tBIT(7)\n#define DT2821_SUPCSR_ADCINIT\t\tBIT(6)\n#define DT2821_SUPCSR_DACINIT\t\tBIT(5)\n#define DT2821_SUPCSR_PRLD\t\tBIT(4)\n#define DT2821_SUPCSR_STRIG\t\tBIT(3)\n#define DT2821_SUPCSR_XTRIG\t\tBIT(2)\n#define DT2821_SUPCSR_XCLK\t\tBIT(1)\n#define DT2821_SUPCSR_BDINIT\t\tBIT(0)\n#define DT2821_TMRCTR_REG\t\t0x0e\n#define DT2821_TMRCTR_PRESCALE(x)\t(((x) & 0xf) << 8)\n#define DT2821_TMRCTR_DIVIDER(x)\t((255 - ((x) & 0xff)) << 0)\n\n \n#define DT2821_OSC_BASE\t\t250\t \n#define DT2821_PRESCALE(x)\tBIT(x)\n#define DT2821_PRESCALE_MAX\t15\n#define DT2821_DIVIDER_MAX\t255\n#define DT2821_OSC_MAX\t\t(DT2821_OSC_BASE *\t\t\t\\\n\t\t\t\t DT2821_PRESCALE(DT2821_PRESCALE_MAX) *\t\\\n\t\t\t\t DT2821_DIVIDER_MAX)\n\nstatic const struct comedi_lrange range_dt282x_ai_lo_bipolar = {\n\t4, {\n\t\tBIP_RANGE(10),\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(2.5),\n\t\tBIP_RANGE(1.25)\n\t}\n};\n\nstatic const struct comedi_lrange range_dt282x_ai_lo_unipolar = {\n\t4, {\n\t\tUNI_RANGE(10),\n\t\tUNI_RANGE(5),\n\t\tUNI_RANGE(2.5),\n\t\tUNI_RANGE(1.25)\n\t}\n};\n\nstatic const struct comedi_lrange range_dt282x_ai_5_bipolar = {\n\t4, {\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(2.5),\n\t\tBIP_RANGE(1.25),\n\t\tBIP_RANGE(0.625)\n\t}\n};\n\nstatic const struct comedi_lrange range_dt282x_ai_5_unipolar = {\n\t4, {\n\t\tUNI_RANGE(5),\n\t\tUNI_RANGE(2.5),\n\t\tUNI_RANGE(1.25),\n\t\tUNI_RANGE(0.625)\n\t}\n};\n\nstatic const struct comedi_lrange range_dt282x_ai_hi_bipolar = {\n\t4, {\n\t\tBIP_RANGE(10),\n\t\tBIP_RANGE(1),\n\t\tBIP_RANGE(0.1),\n\t\tBIP_RANGE(0.02)\n\t}\n};\n\nstatic const struct comedi_lrange range_dt282x_ai_hi_unipolar = {\n\t4, {\n\t\tUNI_RANGE(10),\n\t\tUNI_RANGE(1),\n\t\tUNI_RANGE(0.1),\n\t\tUNI_RANGE(0.02)\n\t}\n};\n\n \nstatic const struct comedi_lrange dt282x_ao_range = {\n\t5, {\n\t\tBIP_RANGE(10),\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(2.5),\n\t\tUNI_RANGE(10),\n\t\tUNI_RANGE(5),\n\t}\n};\n\nstruct dt282x_board {\n\tconst char *name;\n\tunsigned int ai_maxdata;\n\tint adchan_se;\n\tint adchan_di;\n\tint ai_speed;\n\tint ispgl;\n\tint dachan;\n\tunsigned int ao_maxdata;\n};\n\nstatic const struct dt282x_board boardtypes[] = {\n\t{\n\t\t.name\t\t= \"dt2821\",\n\t\t.ai_maxdata\t= 0x0fff,\n\t\t.adchan_se\t= 16,\n\t\t.adchan_di\t= 8,\n\t\t.ai_speed\t= 20000,\n\t\t.dachan\t\t= 2,\n\t\t.ao_maxdata\t= 0x0fff,\n\t}, {\n\t\t.name\t\t= \"dt2821-f\",\n\t\t.ai_maxdata\t= 0x0fff,\n\t\t.adchan_se\t= 16,\n\t\t.adchan_di\t= 8,\n\t\t.ai_speed\t= 6500,\n\t\t.dachan\t\t= 2,\n\t\t.ao_maxdata\t= 0x0fff,\n\t}, {\n\t\t.name\t\t= \"dt2821-g\",\n\t\t.ai_maxdata\t= 0x0fff,\n\t\t.adchan_se\t= 16,\n\t\t.adchan_di\t= 8,\n\t\t.ai_speed\t= 4000,\n\t\t.dachan\t\t= 2,\n\t\t.ao_maxdata\t= 0x0fff,\n\t}, {\n\t\t.name\t\t= \"dt2823\",\n\t\t.ai_maxdata\t= 0xffff,\n\t\t.adchan_di\t= 4,\n\t\t.ai_speed\t= 10000,\n\t\t.dachan\t\t= 2,\n\t\t.ao_maxdata\t= 0xffff,\n\t}, {\n\t\t.name\t\t= \"dt2824-pgh\",\n\t\t.ai_maxdata\t= 0x0fff,\n\t\t.adchan_se\t= 16,\n\t\t.adchan_di\t= 8,\n\t\t.ai_speed\t= 20000,\n\t}, {\n\t\t.name\t\t= \"dt2824-pgl\",\n\t\t.ai_maxdata\t= 0x0fff,\n\t\t.adchan_se\t= 16,\n\t\t.adchan_di\t= 8,\n\t\t.ai_speed\t= 20000,\n\t\t.ispgl\t\t= 1,\n\t}, {\n\t\t.name\t\t= \"dt2825\",\n\t\t.ai_maxdata\t= 0x0fff,\n\t\t.adchan_se\t= 16,\n\t\t.adchan_di\t= 8,\n\t\t.ai_speed\t= 20000,\n\t\t.ispgl\t\t= 1,\n\t\t.dachan\t\t= 2,\n\t\t.ao_maxdata\t= 0x0fff,\n\t}, {\n\t\t.name\t\t= \"dt2827\",\n\t\t.ai_maxdata\t= 0xffff,\n\t\t.adchan_di\t= 4,\n\t\t.ai_speed\t= 10000,\n\t\t.dachan\t\t= 2,\n\t\t.ao_maxdata\t= 0x0fff,\n\t}, {\n\t\t.name\t\t= \"dt2828\",\n\t\t.ai_maxdata\t= 0x0fff,\n\t\t.adchan_se\t= 4,\n\t\t.ai_speed\t= 10000,\n\t\t.dachan\t\t= 2,\n\t\t.ao_maxdata\t= 0x0fff,\n\t}, {\n\t\t.name\t\t= \"dt2829\",\n\t\t.ai_maxdata\t= 0xffff,\n\t\t.adchan_se\t= 8,\n\t\t.ai_speed\t= 33250,\n\t\t.dachan\t\t= 2,\n\t\t.ao_maxdata\t= 0xffff,\n\t}, {\n\t\t.name\t\t= \"dt21-ez\",\n\t\t.ai_maxdata\t= 0x0fff,\n\t\t.adchan_se\t= 16,\n\t\t.adchan_di\t= 8,\n\t\t.ai_speed\t= 10000,\n\t\t.dachan\t\t= 2,\n\t\t.ao_maxdata\t= 0x0fff,\n\t}, {\n\t\t.name\t\t= \"dt23-ez\",\n\t\t.ai_maxdata\t= 0xffff,\n\t\t.adchan_se\t= 16,\n\t\t.adchan_di\t= 8,\n\t\t.ai_speed\t= 10000,\n\t}, {\n\t\t.name\t\t= \"dt24-ez\",\n\t\t.ai_maxdata\t= 0x0fff,\n\t\t.adchan_se\t= 16,\n\t\t.adchan_di\t= 8,\n\t\t.ai_speed\t= 10000,\n\t}, {\n\t\t.name\t\t= \"dt24-ez-pgl\",\n\t\t.ai_maxdata\t= 0x0fff,\n\t\t.adchan_se\t= 16,\n\t\t.adchan_di\t= 8,\n\t\t.ai_speed\t= 10000,\n\t\t.ispgl\t\t= 1,\n\t},\n};\n\nstruct dt282x_private {\n\tstruct comedi_isadma *dma;\n\tunsigned int ad_2scomp:1;\n\tunsigned int divisor;\n\tint dacsr;\t \n\tint adcsr;\n\tint supcsr;\n\tint ntrig;\n\tint nread;\n\tint dma_dir;\n};\n\nstatic int dt282x_prep_ai_dma(struct comedi_device *dev, int dma_index, int n)\n{\n\tstruct dt282x_private *devpriv = dev->private;\n\tstruct comedi_isadma *dma = devpriv->dma;\n\tstruct comedi_isadma_desc *desc = &dma->desc[dma_index];\n\n\tif (!devpriv->ntrig)\n\t\treturn 0;\n\n\tif (n == 0)\n\t\tn = desc->maxsize;\n\tif (n > devpriv->ntrig * 2)\n\t\tn = devpriv->ntrig * 2;\n\tdevpriv->ntrig -= n / 2;\n\n\tdesc->size = n;\n\tcomedi_isadma_set_mode(desc, devpriv->dma_dir);\n\n\tcomedi_isadma_program(desc);\n\n\treturn n;\n}\n\nstatic int dt282x_prep_ao_dma(struct comedi_device *dev, int dma_index, int n)\n{\n\tstruct dt282x_private *devpriv = dev->private;\n\tstruct comedi_isadma *dma = devpriv->dma;\n\tstruct comedi_isadma_desc *desc = &dma->desc[dma_index];\n\n\tdesc->size = n;\n\tcomedi_isadma_set_mode(desc, devpriv->dma_dir);\n\n\tcomedi_isadma_program(desc);\n\n\treturn n;\n}\n\nstatic void dt282x_disable_dma(struct comedi_device *dev)\n{\n\tstruct dt282x_private *devpriv = dev->private;\n\tstruct comedi_isadma *dma = devpriv->dma;\n\tstruct comedi_isadma_desc *desc;\n\tint i;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tdesc = &dma->desc[i];\n\t\tcomedi_isadma_disable(desc->chan);\n\t}\n}\n\nstatic unsigned int dt282x_ns_to_timer(unsigned int *ns, unsigned int flags)\n{\n\tunsigned int prescale, base, divider;\n\n\tfor (prescale = 0; prescale <= DT2821_PRESCALE_MAX; prescale++) {\n\t\tif (prescale == 1)\t \n\t\t\tcontinue;\n\t\tbase = DT2821_OSC_BASE * DT2821_PRESCALE(prescale);\n\t\tswitch (flags & CMDF_ROUND_MASK) {\n\t\tcase CMDF_ROUND_NEAREST:\n\t\tdefault:\n\t\t\tdivider = DIV_ROUND_CLOSEST(*ns, base);\n\t\t\tbreak;\n\t\tcase CMDF_ROUND_DOWN:\n\t\t\tdivider = (*ns) / base;\n\t\t\tbreak;\n\t\tcase CMDF_ROUND_UP:\n\t\t\tdivider = DIV_ROUND_UP(*ns, base);\n\t\t\tbreak;\n\t\t}\n\t\tif (divider <= DT2821_DIVIDER_MAX)\n\t\t\tbreak;\n\t}\n\tif (divider > DT2821_DIVIDER_MAX) {\n\t\tprescale = DT2821_PRESCALE_MAX;\n\t\tdivider = DT2821_DIVIDER_MAX;\n\t\tbase = DT2821_OSC_BASE * DT2821_PRESCALE(prescale);\n\t}\n\t*ns = divider * base;\n\treturn DT2821_TMRCTR_PRESCALE(prescale) |\n\t       DT2821_TMRCTR_DIVIDER(divider);\n}\n\nstatic void dt282x_munge(struct comedi_device *dev,\n\t\t\t struct comedi_subdevice *s,\n\t\t\t unsigned short *buf,\n\t\t\t unsigned int nbytes)\n{\n\tstruct dt282x_private *devpriv = dev->private;\n\tunsigned int val;\n\tint i;\n\n\tif (nbytes % 2)\n\t\tdev_err(dev->class_dev,\n\t\t\t\"bug! odd number of bytes from dma xfer\\n\");\n\n\tfor (i = 0; i < nbytes / 2; i++) {\n\t\tval = buf[i];\n\t\tval &= s->maxdata;\n\t\tif (devpriv->ad_2scomp)\n\t\t\tval = comedi_offset_munge(s, val);\n\n\t\tbuf[i] = val;\n\t}\n}\n\nstatic unsigned int dt282x_ao_setup_dma(struct comedi_device *dev,\n\t\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\t\tint cur_dma)\n{\n\tstruct dt282x_private *devpriv = dev->private;\n\tstruct comedi_isadma *dma = devpriv->dma;\n\tstruct comedi_isadma_desc *desc = &dma->desc[cur_dma];\n\tunsigned int nsamples = comedi_bytes_to_samples(s, desc->maxsize);\n\tunsigned int nbytes;\n\n\tnbytes = comedi_buf_read_samples(s, desc->virt_addr, nsamples);\n\tif (nbytes)\n\t\tdt282x_prep_ao_dma(dev, cur_dma, nbytes);\n\telse\n\t\tdev_err(dev->class_dev, \"AO underrun\\n\");\n\n\treturn nbytes;\n}\n\nstatic void dt282x_ao_dma_interrupt(struct comedi_device *dev,\n\t\t\t\t    struct comedi_subdevice *s)\n{\n\tstruct dt282x_private *devpriv = dev->private;\n\tstruct comedi_isadma *dma = devpriv->dma;\n\tstruct comedi_isadma_desc *desc = &dma->desc[dma->cur_dma];\n\n\toutw(devpriv->supcsr | DT2821_SUPCSR_CLRDMADNE,\n\t     dev->iobase + DT2821_SUPCSR_REG);\n\n\tcomedi_isadma_disable(desc->chan);\n\n\tif (!dt282x_ao_setup_dma(dev, s, dma->cur_dma))\n\t\ts->async->events |= COMEDI_CB_OVERFLOW;\n\n\tdma->cur_dma = 1 - dma->cur_dma;\n}\n\nstatic void dt282x_ai_dma_interrupt(struct comedi_device *dev,\n\t\t\t\t    struct comedi_subdevice *s)\n{\n\tstruct dt282x_private *devpriv = dev->private;\n\tstruct comedi_isadma *dma = devpriv->dma;\n\tstruct comedi_isadma_desc *desc = &dma->desc[dma->cur_dma];\n\tunsigned int nsamples = comedi_bytes_to_samples(s, desc->size);\n\tint ret;\n\n\toutw(devpriv->supcsr | DT2821_SUPCSR_CLRDMADNE,\n\t     dev->iobase + DT2821_SUPCSR_REG);\n\n\tcomedi_isadma_disable(desc->chan);\n\n\tdt282x_munge(dev, s, desc->virt_addr, desc->size);\n\tret = comedi_buf_write_samples(s, desc->virt_addr, nsamples);\n\tif (ret != desc->size)\n\t\treturn;\n\n\tdevpriv->nread -= nsamples;\n\tif (devpriv->nread < 0) {\n\t\tdev_info(dev->class_dev, \"nread off by one\\n\");\n\t\tdevpriv->nread = 0;\n\t}\n\tif (!devpriv->nread) {\n\t\ts->async->events |= COMEDI_CB_EOA;\n\t\treturn;\n\t}\n\n\t \n\tdt282x_prep_ai_dma(dev, dma->cur_dma, 0);\n\n\tdma->cur_dma = 1 - dma->cur_dma;\n}\n\nstatic irqreturn_t dt282x_interrupt(int irq, void *d)\n{\n\tstruct comedi_device *dev = d;\n\tstruct dt282x_private *devpriv = dev->private;\n\tstruct comedi_subdevice *s = dev->read_subdev;\n\tstruct comedi_subdevice *s_ao = dev->write_subdev;\n\tunsigned int supcsr, adcsr, dacsr;\n\tint handled = 0;\n\n\tif (!dev->attached) {\n\t\tdev_err(dev->class_dev, \"spurious interrupt\\n\");\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tadcsr = inw(dev->iobase + DT2821_ADCSR_REG);\n\tdacsr = inw(dev->iobase + DT2821_DACSR_REG);\n\tsupcsr = inw(dev->iobase + DT2821_SUPCSR_REG);\n\tif (supcsr & DT2821_SUPCSR_DMAD) {\n\t\tif (devpriv->dma_dir == COMEDI_ISADMA_READ)\n\t\t\tdt282x_ai_dma_interrupt(dev, s);\n\t\telse\n\t\t\tdt282x_ao_dma_interrupt(dev, s_ao);\n\t\thandled = 1;\n\t}\n\tif (adcsr & DT2821_ADCSR_ADERR) {\n\t\tif (devpriv->nread != 0) {\n\t\t\tdev_err(dev->class_dev, \"A/D error\\n\");\n\t\t\ts->async->events |= COMEDI_CB_ERROR;\n\t\t}\n\t\thandled = 1;\n\t}\n\tif (dacsr & DT2821_DACSR_DAERR) {\n\t\tdev_err(dev->class_dev, \"D/A error\\n\");\n\t\ts_ao->async->events |= COMEDI_CB_ERROR;\n\t\thandled = 1;\n\t}\n\n\tcomedi_handle_events(dev, s);\n\tif (s_ao)\n\t\tcomedi_handle_events(dev, s_ao);\n\n\treturn IRQ_RETVAL(handled);\n}\n\nstatic void dt282x_load_changain(struct comedi_device *dev, int n,\n\t\t\t\t unsigned int *chanlist)\n{\n\tstruct dt282x_private *devpriv = dev->private;\n\tint i;\n\n\toutw(DT2821_CHANCSR_LLE | DT2821_CHANCSR_NUMB(n),\n\t     dev->iobase + DT2821_CHANCSR_REG);\n\tfor (i = 0; i < n; i++) {\n\t\tunsigned int chan = CR_CHAN(chanlist[i]);\n\t\tunsigned int range = CR_RANGE(chanlist[i]);\n\n\t\toutw(devpriv->adcsr |\n\t\t     DT2821_ADCSR_GS(range) |\n\t\t     DT2821_ADCSR_CHAN(chan),\n\t\t     dev->iobase + DT2821_ADCSR_REG);\n\t}\n\toutw(DT2821_CHANCSR_NUMB(n), dev->iobase + DT2821_CHANCSR_REG);\n}\n\nstatic int dt282x_ai_timeout(struct comedi_device *dev,\n\t\t\t     struct comedi_subdevice *s,\n\t\t\t     struct comedi_insn *insn,\n\t\t\t     unsigned long context)\n{\n\tunsigned int status;\n\n\tstatus = inw(dev->iobase + DT2821_ADCSR_REG);\n\tswitch (context) {\n\tcase DT2821_ADCSR_MUXBUSY:\n\t\tif ((status & DT2821_ADCSR_MUXBUSY) == 0)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase DT2821_ADCSR_ADDONE:\n\t\tif (status & DT2821_ADCSR_ADDONE)\n\t\t\treturn 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn -EBUSY;\n}\n\n \nstatic int dt282x_ai_insn_read(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       struct comedi_insn *insn,\n\t\t\t       unsigned int *data)\n{\n\tstruct dt282x_private *devpriv = dev->private;\n\tunsigned int val;\n\tint ret;\n\tint i;\n\n\t \n\tdevpriv->adcsr = DT2821_ADCSR_ADCLK;\n\toutw(devpriv->adcsr, dev->iobase + DT2821_ADCSR_REG);\n\n\tdt282x_load_changain(dev, 1, &insn->chanspec);\n\n\toutw(devpriv->supcsr | DT2821_SUPCSR_PRLD,\n\t     dev->iobase + DT2821_SUPCSR_REG);\n\tret = comedi_timeout(dev, s, insn,\n\t\t\t     dt282x_ai_timeout, DT2821_ADCSR_MUXBUSY);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\toutw(devpriv->supcsr | DT2821_SUPCSR_STRIG,\n\t\t     dev->iobase + DT2821_SUPCSR_REG);\n\n\t\tret = comedi_timeout(dev, s, insn,\n\t\t\t\t     dt282x_ai_timeout, DT2821_ADCSR_ADDONE);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tval = inw(dev->iobase + DT2821_ADDAT_REG);\n\t\tval &= s->maxdata;\n\t\tif (devpriv->ad_2scomp)\n\t\t\tval = comedi_offset_munge(s, val);\n\n\t\tdata[i] = val;\n\t}\n\n\treturn i;\n}\n\nstatic int dt282x_ai_cmdtest(struct comedi_device *dev,\n\t\t\t     struct comedi_subdevice *s,\n\t\t\t     struct comedi_cmd *cmd)\n{\n\tconst struct dt282x_board *board = dev->board_ptr;\n\tstruct dt282x_private *devpriv = dev->private;\n\tint err = 0;\n\tunsigned int arg;\n\n\t \n\n\terr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW);\n\terr |= comedi_check_trigger_src(&cmd->scan_begin_src,\n\t\t\t\t\tTRIG_FOLLOW | TRIG_EXT);\n\terr |= comedi_check_trigger_src(&cmd->convert_src, TRIG_TIMER);\n\terr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\n\terr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\n\n\tif (err)\n\t\treturn 1;\n\n\t \n\n\terr |= comedi_check_trigger_is_unique(cmd->scan_begin_src);\n\terr |= comedi_check_trigger_is_unique(cmd->stop_src);\n\n\t \n\n\tif (err)\n\t\treturn 2;\n\n\t \n\n\terr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);\n\terr |= comedi_check_trigger_arg_max(&cmd->convert_arg, DT2821_OSC_MAX);\n\terr |= comedi_check_trigger_arg_min(&cmd->convert_arg, board->ai_speed);\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\n\t\t\t\t\t   cmd->chanlist_len);\n\n\tif (cmd->stop_src == TRIG_COUNT)\n\t\terr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\n\telse\t \n\t\terr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\n\n\tif (err)\n\t\treturn 3;\n\n\t \n\n\targ = cmd->convert_arg;\n\tdevpriv->divisor = dt282x_ns_to_timer(&arg, cmd->flags);\n\terr |= comedi_check_trigger_arg_is(&cmd->convert_arg, arg);\n\n\tif (err)\n\t\treturn 4;\n\n\treturn 0;\n}\n\nstatic int dt282x_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\n{\n\tstruct dt282x_private *devpriv = dev->private;\n\tstruct comedi_isadma *dma = devpriv->dma;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tint ret;\n\n\tdt282x_disable_dma(dev);\n\n\toutw(devpriv->divisor, dev->iobase + DT2821_TMRCTR_REG);\n\n\tdevpriv->supcsr = DT2821_SUPCSR_ERRINTEN;\n\tif (cmd->scan_begin_src == TRIG_FOLLOW)\n\t\tdevpriv->supcsr = DT2821_SUPCSR_DS_AD_CLK;\n\telse\n\t\tdevpriv->supcsr = DT2821_SUPCSR_DS_AD_TRIG;\n\toutw(devpriv->supcsr |\n\t     DT2821_SUPCSR_CLRDMADNE |\n\t     DT2821_SUPCSR_BUFFB |\n\t     DT2821_SUPCSR_ADCINIT,\n\t     dev->iobase + DT2821_SUPCSR_REG);\n\n\tdevpriv->ntrig = cmd->stop_arg * cmd->scan_end_arg;\n\tdevpriv->nread = devpriv->ntrig;\n\n\tdevpriv->dma_dir = COMEDI_ISADMA_READ;\n\tdma->cur_dma = 0;\n\tdt282x_prep_ai_dma(dev, 0, 0);\n\tif (devpriv->ntrig) {\n\t\tdt282x_prep_ai_dma(dev, 1, 0);\n\t\tdevpriv->supcsr |= DT2821_SUPCSR_DDMA;\n\t\toutw(devpriv->supcsr, dev->iobase + DT2821_SUPCSR_REG);\n\t}\n\n\tdevpriv->adcsr = 0;\n\n\tdt282x_load_changain(dev, cmd->chanlist_len, cmd->chanlist);\n\n\tdevpriv->adcsr = DT2821_ADCSR_ADCLK | DT2821_ADCSR_IADDONE;\n\toutw(devpriv->adcsr, dev->iobase + DT2821_ADCSR_REG);\n\n\toutw(devpriv->supcsr | DT2821_SUPCSR_PRLD,\n\t     dev->iobase + DT2821_SUPCSR_REG);\n\tret = comedi_timeout(dev, s, NULL,\n\t\t\t     dt282x_ai_timeout, DT2821_ADCSR_MUXBUSY);\n\tif (ret)\n\t\treturn ret;\n\n\tif (cmd->scan_begin_src == TRIG_FOLLOW) {\n\t\toutw(devpriv->supcsr | DT2821_SUPCSR_STRIG,\n\t\t     dev->iobase + DT2821_SUPCSR_REG);\n\t} else {\n\t\tdevpriv->supcsr |= DT2821_SUPCSR_XTRIG;\n\t\toutw(devpriv->supcsr, dev->iobase + DT2821_SUPCSR_REG);\n\t}\n\n\treturn 0;\n}\n\nstatic int dt282x_ai_cancel(struct comedi_device *dev,\n\t\t\t    struct comedi_subdevice *s)\n{\n\tstruct dt282x_private *devpriv = dev->private;\n\n\tdt282x_disable_dma(dev);\n\n\tdevpriv->adcsr = 0;\n\toutw(devpriv->adcsr, dev->iobase + DT2821_ADCSR_REG);\n\n\tdevpriv->supcsr = 0;\n\toutw(devpriv->supcsr | DT2821_SUPCSR_ADCINIT,\n\t     dev->iobase + DT2821_SUPCSR_REG);\n\n\treturn 0;\n}\n\nstatic int dt282x_ao_insn_write(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tstruct comedi_insn *insn,\n\t\t\t\tunsigned int *data)\n{\n\tstruct dt282x_private *devpriv = dev->private;\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int range = CR_RANGE(insn->chanspec);\n\tint i;\n\n\tdevpriv->dacsr |= DT2821_DACSR_SSEL | DT2821_DACSR_YSEL(chan);\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\tunsigned int val = data[i];\n\n\t\ts->readback[chan] = val;\n\n\t\tif (comedi_range_is_bipolar(s, range))\n\t\t\tval = comedi_offset_munge(s, val);\n\n\t\toutw(devpriv->dacsr, dev->iobase + DT2821_DACSR_REG);\n\n\t\toutw(val, dev->iobase + DT2821_DADAT_REG);\n\n\t\toutw(devpriv->supcsr | DT2821_SUPCSR_DACON,\n\t\t     dev->iobase + DT2821_SUPCSR_REG);\n\t}\n\n\treturn insn->n;\n}\n\nstatic int dt282x_ao_cmdtest(struct comedi_device *dev,\n\t\t\t     struct comedi_subdevice *s,\n\t\t\t     struct comedi_cmd *cmd)\n{\n\tstruct dt282x_private *devpriv = dev->private;\n\tint err = 0;\n\tunsigned int arg;\n\n\t \n\n\terr |= comedi_check_trigger_src(&cmd->start_src, TRIG_INT);\n\terr |= comedi_check_trigger_src(&cmd->scan_begin_src, TRIG_TIMER);\n\terr |= comedi_check_trigger_src(&cmd->convert_src, TRIG_NOW);\n\terr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\n\terr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\n\n\tif (err)\n\t\treturn 1;\n\n\t \n\n\terr |= comedi_check_trigger_is_unique(cmd->stop_src);\n\n\t \n\n\tif (err)\n\t\treturn 2;\n\n\t \n\n\terr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\n\terr |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg, 5000);\n\terr |= comedi_check_trigger_arg_is(&cmd->convert_arg, 0);\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\n\t\t\t\t\t   cmd->chanlist_len);\n\n\tif (cmd->stop_src == TRIG_COUNT)\n\t\terr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\n\telse\t \n\t\terr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\n\n\tif (err)\n\t\treturn 3;\n\n\t \n\n\targ = cmd->scan_begin_arg;\n\tdevpriv->divisor = dt282x_ns_to_timer(&arg, cmd->flags);\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, arg);\n\n\tif (err)\n\t\treturn 4;\n\n\treturn 0;\n}\n\nstatic int dt282x_ao_inttrig(struct comedi_device *dev,\n\t\t\t     struct comedi_subdevice *s,\n\t\t\t     unsigned int trig_num)\n{\n\tstruct dt282x_private *devpriv = dev->private;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\n\tif (trig_num != cmd->start_src)\n\t\treturn -EINVAL;\n\n\tif (!dt282x_ao_setup_dma(dev, s, 0))\n\t\treturn -EPIPE;\n\n\tif (!dt282x_ao_setup_dma(dev, s, 1))\n\t\treturn -EPIPE;\n\n\toutw(devpriv->supcsr | DT2821_SUPCSR_STRIG,\n\t     dev->iobase + DT2821_SUPCSR_REG);\n\ts->async->inttrig = NULL;\n\n\treturn 1;\n}\n\nstatic int dt282x_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\n{\n\tstruct dt282x_private *devpriv = dev->private;\n\tstruct comedi_isadma *dma = devpriv->dma;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\n\tdt282x_disable_dma(dev);\n\n\tdevpriv->supcsr = DT2821_SUPCSR_ERRINTEN |\n\t\t\t  DT2821_SUPCSR_DS_DA_CLK |\n\t\t\t  DT2821_SUPCSR_DDMA;\n\toutw(devpriv->supcsr |\n\t     DT2821_SUPCSR_CLRDMADNE |\n\t     DT2821_SUPCSR_BUFFB |\n\t     DT2821_SUPCSR_DACINIT,\n\t     dev->iobase + DT2821_SUPCSR_REG);\n\n\tdevpriv->ntrig = cmd->stop_arg * cmd->chanlist_len;\n\tdevpriv->nread = devpriv->ntrig;\n\n\tdevpriv->dma_dir = COMEDI_ISADMA_WRITE;\n\tdma->cur_dma = 0;\n\n\toutw(devpriv->divisor, dev->iobase + DT2821_TMRCTR_REG);\n\n\t \n\tdevpriv->dacsr &= (DT2821_DACSR_LBOE | DT2821_DACSR_HBOE);\n\n\tdevpriv->dacsr |= (DT2821_DACSR_SSEL |\n\t\t\t   DT2821_DACSR_DACLK |\n\t\t\t   DT2821_DACSR_IDARDY);\n\toutw(devpriv->dacsr, dev->iobase + DT2821_DACSR_REG);\n\n\ts->async->inttrig = dt282x_ao_inttrig;\n\n\treturn 0;\n}\n\nstatic int dt282x_ao_cancel(struct comedi_device *dev,\n\t\t\t    struct comedi_subdevice *s)\n{\n\tstruct dt282x_private *devpriv = dev->private;\n\n\tdt282x_disable_dma(dev);\n\n\t \n\tdevpriv->dacsr &= (DT2821_DACSR_LBOE | DT2821_DACSR_HBOE);\n\n\toutw(devpriv->dacsr, dev->iobase + DT2821_DACSR_REG);\n\n\tdevpriv->supcsr = 0;\n\toutw(devpriv->supcsr | DT2821_SUPCSR_DACINIT,\n\t     dev->iobase + DT2821_SUPCSR_REG);\n\n\treturn 0;\n}\n\nstatic int dt282x_dio_insn_bits(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tstruct comedi_insn *insn,\n\t\t\t\tunsigned int *data)\n{\n\tif (comedi_dio_update_state(s, data))\n\t\toutw(s->state, dev->iobase + DT2821_DIODAT_REG);\n\n\tdata[1] = inw(dev->iobase + DT2821_DIODAT_REG);\n\n\treturn insn->n;\n}\n\nstatic int dt282x_dio_insn_config(struct comedi_device *dev,\n\t\t\t\t  struct comedi_subdevice *s,\n\t\t\t\t  struct comedi_insn *insn,\n\t\t\t\t  unsigned int *data)\n{\n\tstruct dt282x_private *devpriv = dev->private;\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int mask;\n\tint ret;\n\n\tif (chan < 8)\n\t\tmask = 0x00ff;\n\telse\n\t\tmask = 0xff00;\n\n\tret = comedi_dio_insn_config(dev, s, insn, data, mask);\n\tif (ret)\n\t\treturn ret;\n\n\tdevpriv->dacsr &= ~(DT2821_DACSR_LBOE | DT2821_DACSR_HBOE);\n\tif (s->io_bits & 0x00ff)\n\t\tdevpriv->dacsr |= DT2821_DACSR_LBOE;\n\tif (s->io_bits & 0xff00)\n\t\tdevpriv->dacsr |= DT2821_DACSR_HBOE;\n\n\toutw(devpriv->dacsr, dev->iobase + DT2821_DACSR_REG);\n\n\treturn insn->n;\n}\n\nstatic const struct comedi_lrange *const ai_range_table[] = {\n\t&range_dt282x_ai_lo_bipolar,\n\t&range_dt282x_ai_lo_unipolar,\n\t&range_dt282x_ai_5_bipolar,\n\t&range_dt282x_ai_5_unipolar\n};\n\nstatic const struct comedi_lrange *const ai_range_pgl_table[] = {\n\t&range_dt282x_ai_hi_bipolar,\n\t&range_dt282x_ai_hi_unipolar\n};\n\nstatic const struct comedi_lrange *opt_ai_range_lkup(int ispgl, int x)\n{\n\tif (ispgl) {\n\t\tif (x < 0 || x >= 2)\n\t\t\tx = 0;\n\t\treturn ai_range_pgl_table[x];\n\t}\n\n\tif (x < 0 || x >= 4)\n\t\tx = 0;\n\treturn ai_range_table[x];\n}\n\nstatic void dt282x_alloc_dma(struct comedi_device *dev,\n\t\t\t     struct comedi_devconfig *it)\n{\n\tstruct dt282x_private *devpriv = dev->private;\n\tunsigned int irq_num = it->options[1];\n\tunsigned int dma_chan[2];\n\n\tif (it->options[2] < it->options[3]) {\n\t\tdma_chan[0] = it->options[2];\n\t\tdma_chan[1] = it->options[3];\n\t} else {\n\t\tdma_chan[0] = it->options[3];\n\t\tdma_chan[1] = it->options[2];\n\t}\n\n\tif (!irq_num || dma_chan[0] == dma_chan[1] ||\n\t    dma_chan[0] < 5 || dma_chan[0] > 7 ||\n\t    dma_chan[1] < 5 || dma_chan[1] > 7)\n\t\treturn;\n\n\tif (request_irq(irq_num, dt282x_interrupt, 0, dev->board_name, dev))\n\t\treturn;\n\n\t \n\tdevpriv->dma = comedi_isadma_alloc(dev, 2, dma_chan[0], dma_chan[1],\n\t\t\t\t\t   PAGE_SIZE, 0);\n\tif (!devpriv->dma)\n\t\tfree_irq(irq_num, dev);\n\telse\n\t\tdev->irq = irq_num;\n}\n\nstatic void dt282x_free_dma(struct comedi_device *dev)\n{\n\tstruct dt282x_private *devpriv = dev->private;\n\n\tif (devpriv)\n\t\tcomedi_isadma_free(devpriv->dma);\n}\n\nstatic int dt282x_initialize(struct comedi_device *dev)\n{\n\t \n\toutw(DT2821_SUPCSR_BDINIT, dev->iobase + DT2821_SUPCSR_REG);\n\tinw(dev->iobase + DT2821_ADCSR_REG);\n\n\t \n\tif (((inw(dev->iobase + DT2821_ADCSR_REG) & 0xfff0) != 0x7c00) ||\n\t    ((inw(dev->iobase + DT2821_CHANCSR_REG) & 0xf0f0) != 0x70f0) ||\n\t    ((inw(dev->iobase + DT2821_DACSR_REG) & 0x7c93) != 0x7c90) ||\n\t    ((inw(dev->iobase + DT2821_SUPCSR_REG) & 0xf8ff) != 0x0000) ||\n\t    ((inw(dev->iobase + DT2821_TMRCTR_REG) & 0xff00) != 0xf000)) {\n\t\tdev_err(dev->class_dev, \"board not found\\n\");\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)\n{\n\tconst struct dt282x_board *board = dev->board_ptr;\n\tstruct dt282x_private *devpriv;\n\tstruct comedi_subdevice *s;\n\tint ret;\n\n\tret = comedi_request_region(dev, it->options[0], 0x10);\n\tif (ret)\n\t\treturn ret;\n\n\tret = dt282x_initialize(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tdevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\n\tif (!devpriv)\n\t\treturn -ENOMEM;\n\n\t \n\tdt282x_alloc_dma(dev, it);\n\n\tret = comedi_alloc_subdevices(dev, 3);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ts = &dev->subdevices[0];\n\ts->type\t\t= COMEDI_SUBD_AI;\n\ts->subdev_flags\t= SDF_READABLE;\n\tif ((it->options[4] && board->adchan_di) || board->adchan_se == 0) {\n\t\ts->subdev_flags\t|= SDF_DIFF;\n\t\ts->n_chan\t= board->adchan_di;\n\t} else {\n\t\ts->subdev_flags\t|= SDF_COMMON;\n\t\ts->n_chan\t= board->adchan_se;\n\t}\n\ts->maxdata\t= board->ai_maxdata;\n\n\ts->range_table = opt_ai_range_lkup(board->ispgl, it->options[8]);\n\tdevpriv->ad_2scomp = it->options[5] ? 1 : 0;\n\n\ts->insn_read\t= dt282x_ai_insn_read;\n\tif (dev->irq) {\n\t\tdev->read_subdev = s;\n\t\ts->subdev_flags\t|= SDF_CMD_READ;\n\t\ts->len_chanlist\t= s->n_chan;\n\t\ts->do_cmdtest\t= dt282x_ai_cmdtest;\n\t\ts->do_cmd\t= dt282x_ai_cmd;\n\t\ts->cancel\t= dt282x_ai_cancel;\n\t}\n\n\t \n\ts = &dev->subdevices[1];\n\tif (board->dachan) {\n\t\ts->type\t\t= COMEDI_SUBD_AO;\n\t\ts->subdev_flags\t= SDF_WRITABLE;\n\t\ts->n_chan\t= board->dachan;\n\t\ts->maxdata\t= board->ao_maxdata;\n\t\t \n\t\ts->range_table\t= &dt282x_ao_range;\n\t\ts->insn_write\t= dt282x_ao_insn_write;\n\t\tif (dev->irq) {\n\t\t\tdev->write_subdev = s;\n\t\t\ts->subdev_flags\t|= SDF_CMD_WRITE;\n\t\t\ts->len_chanlist\t= s->n_chan;\n\t\t\ts->do_cmdtest\t= dt282x_ao_cmdtest;\n\t\t\ts->do_cmd\t= dt282x_ao_cmd;\n\t\t\ts->cancel\t= dt282x_ao_cancel;\n\t\t}\n\n\t\tret = comedi_alloc_subdev_readback(s);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\ts->type\t\t= COMEDI_SUBD_UNUSED;\n\t}\n\n\t \n\ts = &dev->subdevices[2];\n\ts->type\t\t= COMEDI_SUBD_DIO;\n\ts->subdev_flags\t= SDF_READABLE | SDF_WRITABLE;\n\ts->n_chan\t= 16;\n\ts->maxdata\t= 1;\n\ts->range_table\t= &range_digital;\n\ts->insn_bits\t= dt282x_dio_insn_bits;\n\ts->insn_config\t= dt282x_dio_insn_config;\n\n\treturn 0;\n}\n\nstatic void dt282x_detach(struct comedi_device *dev)\n{\n\tdt282x_free_dma(dev);\n\tcomedi_legacy_detach(dev);\n}\n\nstatic struct comedi_driver dt282x_driver = {\n\t.driver_name\t= \"dt282x\",\n\t.module\t\t= THIS_MODULE,\n\t.attach\t\t= dt282x_attach,\n\t.detach\t\t= dt282x_detach,\n\t.board_name\t= &boardtypes[0].name,\n\t.num_names\t= ARRAY_SIZE(boardtypes),\n\t.offset\t\t= sizeof(struct dt282x_board),\n};\nmodule_comedi_driver(dt282x_driver);\n\nMODULE_AUTHOR(\"Comedi https://www.comedi.org\");\nMODULE_DESCRIPTION(\"Comedi driver for Data Translation DT2821 series\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}