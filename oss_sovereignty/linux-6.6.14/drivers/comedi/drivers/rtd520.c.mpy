{
  "module_name": "rtd520.c",
  "hash_id": "125b9d8ae4b50fae0ac94dbb0da5d8b595619c803fa805618201edc6b4f1ea63",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/rtd520.c",
  "human_readable_source": "\n \n\n \n\n \n\n \n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/comedi/comedi_pci.h>\n#include <linux/comedi/comedi_8254.h>\n\n#include \"plx9080.h\"\n\n \n#define LAS0_USER_IO\t\t0x0008\t \n#define LAS0_ADC\t\t0x0010\t \n#define FS_DAC1_NOT_EMPTY\tBIT(0)\t \n#define FS_DAC1_HEMPTY\t\tBIT(1)\t \n#define FS_DAC1_NOT_FULL\tBIT(2)\t \n#define FS_DAC2_NOT_EMPTY\tBIT(4)\t \n#define FS_DAC2_HEMPTY\t\tBIT(5)\t \n#define FS_DAC2_NOT_FULL\tBIT(6)\t \n#define FS_ADC_NOT_EMPTY\tBIT(8)\t \n#define FS_ADC_HEMPTY\t\tBIT(9)\t \n#define FS_ADC_NOT_FULL\t\tBIT(10)\t \n#define FS_DIN_NOT_EMPTY\tBIT(12)\t \n#define FS_DIN_HEMPTY\t\tBIT(13)\t \n#define FS_DIN_NOT_FULL\t\tBIT(14)\t \n#define LAS0_UPDATE_DAC(x)\t(0x0014 + ((x) * 0x4))\t \n#define LAS0_DAC\t\t0x0024\t \n#define LAS0_PACER\t\t0x0028\t \n#define LAS0_TIMER\t\t0x002c\t \n#define LAS0_IT\t\t\t0x0030\t \n#define IRQM_ADC_FIFO_WRITE\tBIT(0)\t \n#define IRQM_CGT_RESET\t\tBIT(1)\t \n#define IRQM_CGT_PAUSE\t\tBIT(3)\t \n#define IRQM_ADC_ABOUT_CNT\tBIT(4)\t \n#define IRQM_ADC_DELAY_CNT\tBIT(5)\t \n#define IRQM_ADC_SAMPLE_CNT\tBIT(6)\t \n#define IRQM_DAC1_UCNT\t\tBIT(7)\t \n#define IRQM_DAC2_UCNT\t\tBIT(8)\t \n#define IRQM_UTC1\t\tBIT(9)\t \n#define IRQM_UTC1_INV\t\tBIT(10)\t \n#define IRQM_UTC2\t\tBIT(11)\t \n#define IRQM_DIGITAL_IT\t\tBIT(12)\t \n#define IRQM_EXTERNAL_IT\tBIT(13)\t \n#define IRQM_ETRIG_RISING\tBIT(14)\t \n#define IRQM_ETRIG_FALLING\tBIT(15)\t \n#define LAS0_CLEAR\t\t0x0034\t \n#define LAS0_OVERRUN\t\t0x0038\t \n#define LAS0_PCLK\t\t0x0040\t \n#define LAS0_BCLK\t\t0x0044\t \n#define LAS0_ADC_SCNT\t\t0x0048\t \n#define LAS0_DAC1_UCNT\t\t0x004c\t \n#define LAS0_DAC2_UCNT\t\t0x0050\t \n#define LAS0_DCNT\t\t0x0054\t \n#define LAS0_ACNT\t\t0x0058\t \n#define LAS0_DAC_CLK\t\t0x005c\t \n#define LAS0_8254_TIMER_BASE\t0x0060\t \n#define LAS0_DIO0\t\t0x0070\t \n#define LAS0_DIO1\t\t0x0074\t \n#define LAS0_DIO0_CTRL\t\t0x0078\t \n#define LAS0_DIO_STATUS\t\t0x007c\t \n#define LAS0_BOARD_RESET\t0x0100\t \n#define LAS0_DMA0_SRC\t\t0x0104\t \n#define LAS0_DMA1_SRC\t\t0x0108\t \n#define LAS0_ADC_CONVERSION\t0x010c\t \n#define LAS0_BURST_START\t0x0110\t \n#define LAS0_PACER_START\t0x0114\t \n#define LAS0_PACER_STOP\t\t0x0118\t \n#define LAS0_ACNT_STOP_ENABLE\t0x011c\t \n#define LAS0_PACER_REPEAT\t0x0120\t \n#define LAS0_DIN_START\t\t0x0124\t \n#define LAS0_DIN_FIFO_CLEAR\t0x0128\t \n#define LAS0_ADC_FIFO_CLEAR\t0x012c\t \n#define LAS0_CGT_WRITE\t\t0x0130\t \n#define LAS0_CGL_WRITE\t\t0x0134\t \n#define LAS0_CG_DATA\t\t0x0138\t \n#define LAS0_CGT_ENABLE\t\t0x013c\t \n#define LAS0_CG_ENABLE\t\t0x0140\t \n#define LAS0_CGT_PAUSE\t\t0x0144\t \n#define LAS0_CGT_RESET\t\t0x0148\t \n#define LAS0_CGT_CLEAR\t\t0x014c\t \n#define LAS0_DAC_CTRL(x)\t(0x0150\t+ ((x) * 0x14))\t \n#define LAS0_DAC_SRC(x)\t\t(0x0154 + ((x) * 0x14))\t \n#define LAS0_DAC_CYCLE(x)\t(0x0158 + ((x) * 0x14))\t \n#define LAS0_DAC_RESET(x)\t(0x015c + ((x) * 0x14))\t \n#define LAS0_DAC_FIFO_CLEAR(x)\t(0x0160 + ((x) * 0x14))\t \n#define LAS0_ADC_SCNT_SRC\t0x0178\t \n#define LAS0_PACER_SELECT\t0x0180\t \n#define LAS0_SBUS0_SRC\t\t0x0184\t \n#define LAS0_SBUS0_ENABLE\t0x0188\t \n#define LAS0_SBUS1_SRC\t\t0x018c\t \n#define LAS0_SBUS1_ENABLE\t0x0190\t \n#define LAS0_SBUS2_SRC\t\t0x0198\t \n#define LAS0_SBUS2_ENABLE\t0x019c\t \n#define LAS0_ETRG_POLARITY\t0x01a4\t \n#define LAS0_EINT_POLARITY\t0x01a8\t \n#define LAS0_8254_CLK_SEL(x)\t(0x01ac + ((x) * 0x8))\t \n#define LAS0_8254_GATE_SEL(x)\t(0x01b0 + ((x) * 0x8))\t \n#define LAS0_UOUT0_SELECT\t0x01c4\t \n#define LAS0_UOUT1_SELECT\t0x01c8\t \n#define LAS0_DMA0_RESET\t\t0x01cc\t \n#define LAS0_DMA1_RESET\t\t0x01d0\t \n\n \n#define LAS1_ADC_FIFO\t\t0x0000\t \n#define LAS1_HDIO_FIFO\t\t0x0004\t \n#define LAS1_DAC_FIFO(x)\t(0x0008 + ((x) * 0x4))\t \n\n \n\n \n#define DMA_CHAIN_COUNT 2\t \n\n \n \n \n#define TRANS_TARGET_PERIOD 10000000\t \n\n \n \n#define RTD_MAX_CHANLIST\t128\t \n\n \n\n#define RTD_CLOCK_RATE\t8000000\t \n#define RTD_CLOCK_BASE\t125\t \n\n \n#define RTD_MAX_SPEED\t1625\t \n \n#define RTD_MAX_SPEED_1\t875\t \n\n#define RTD_MIN_SPEED\t2097151875\t \n \n#define RTD_MIN_SPEED_1\t5000000\t \n\n \n#define DMA_MODE_BITS (\\\n\t\t       PLX_LOCAL_BUS_16_WIDE_BITS \\\n\t\t       | PLX_DMA_EN_READYIN_BIT \\\n\t\t       | PLX_DMA_LOCAL_BURST_EN_BIT \\\n\t\t       | PLX_EN_CHAIN_BIT \\\n\t\t       | PLX_DMA_INTR_PCI_BIT \\\n\t\t       | PLX_LOCAL_ADDR_CONST_BIT \\\n\t\t       | PLX_DEMAND_MODE_BIT)\n\n#define DMA_TRANSFER_BITS (\\\n   PLX_DESC_IN_PCI_BIT \\\n  | PLX_INTR_TERM_COUNT \\\n \t\t| PLX_XFER_LOCAL_TO_PCI)\n\n \n\n \nstatic const struct comedi_lrange rtd_ai_7520_range = {\n\t18, {\n\t\t \n\t\tBIP_RANGE(5.0),\n\t\tBIP_RANGE(5.0 / 2),\n\t\tBIP_RANGE(5.0 / 4),\n\t\tBIP_RANGE(5.0 / 8),\n\t\tBIP_RANGE(5.0 / 16),\n\t\tBIP_RANGE(5.0 / 32),\n\t\t \n\t\tBIP_RANGE(10.0),\n\t\tBIP_RANGE(10.0 / 2),\n\t\tBIP_RANGE(10.0 / 4),\n\t\tBIP_RANGE(10.0 / 8),\n\t\tBIP_RANGE(10.0 / 16),\n\t\tBIP_RANGE(10.0 / 32),\n\t\t \n\t\tUNI_RANGE(10.0),\n\t\tUNI_RANGE(10.0 / 2),\n\t\tUNI_RANGE(10.0 / 4),\n\t\tUNI_RANGE(10.0 / 8),\n\t\tUNI_RANGE(10.0 / 16),\n\t\tUNI_RANGE(10.0 / 32),\n\t}\n};\n\n \nstatic const struct comedi_lrange rtd_ai_4520_range = {\n\t24, {\n\t\t \n\t\tBIP_RANGE(5.0),\n\t\tBIP_RANGE(5.0 / 2),\n\t\tBIP_RANGE(5.0 / 4),\n\t\tBIP_RANGE(5.0 / 8),\n\t\tBIP_RANGE(5.0 / 16),\n\t\tBIP_RANGE(5.0 / 32),\n\t\tBIP_RANGE(5.0 / 64),\n\t\tBIP_RANGE(5.0 / 128),\n\t\t \n\t\tBIP_RANGE(10.0),\n\t\tBIP_RANGE(10.0 / 2),\n\t\tBIP_RANGE(10.0 / 4),\n\t\tBIP_RANGE(10.0 / 8),\n\t\tBIP_RANGE(10.0 / 16),\n\t\tBIP_RANGE(10.0 / 32),\n\t\tBIP_RANGE(10.0 / 64),\n\t\tBIP_RANGE(10.0 / 128),\n\t\t \n\t\tUNI_RANGE(10.0),\n\t\tUNI_RANGE(10.0 / 2),\n\t\tUNI_RANGE(10.0 / 4),\n\t\tUNI_RANGE(10.0 / 8),\n\t\tUNI_RANGE(10.0 / 16),\n\t\tUNI_RANGE(10.0 / 32),\n\t\tUNI_RANGE(10.0 / 64),\n\t\tUNI_RANGE(10.0 / 128),\n\t}\n};\n\n \nstatic const struct comedi_lrange rtd_ao_range = {\n\t4, {\n\t\tUNI_RANGE(5),\n\t\tUNI_RANGE(10),\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(10),\n\t}\n};\n\nenum rtd_boardid {\n\tBOARD_DM7520,\n\tBOARD_PCI4520,\n};\n\nstruct rtd_boardinfo {\n\tconst char *name;\n\tint range_bip10;\t \n\tint range_uni10;\t \n\tconst struct comedi_lrange *ai_range;\n};\n\nstatic const struct rtd_boardinfo rtd520_boards[] = {\n\t[BOARD_DM7520] = {\n\t\t.name\t\t= \"DM7520\",\n\t\t.range_bip10\t= 6,\n\t\t.range_uni10\t= 12,\n\t\t.ai_range\t= &rtd_ai_7520_range,\n\t},\n\t[BOARD_PCI4520] = {\n\t\t.name\t\t= \"PCI4520\",\n\t\t.range_bip10\t= 8,\n\t\t.range_uni10\t= 16,\n\t\t.ai_range\t= &rtd_ai_4520_range,\n\t},\n};\n\nstruct rtd_private {\n\t \n\tvoid __iomem *las1;\n\tvoid __iomem *lcfg;\n\n\tlong ai_count;\t\t \n\tint xfer_count;\t\t \n\tint flags;\t\t \n\tunsigned int fifosz;\n\n\t \n\tunsigned char timer_gate_src[3];\n\tunsigned char timer_clk_src[3];\n};\n\n \n#define SEND_EOS\t0x01\t \n#define DMA0_ACTIVE\t0x02\t \n#define DMA1_ACTIVE\t0x04\t \n\n \nstatic int rtd_ns_to_timer_base(unsigned int *nanosec,\n\t\t\t\tunsigned int flags, int base)\n{\n\tint divider;\n\n\tswitch (flags & CMDF_ROUND_MASK) {\n\tcase CMDF_ROUND_NEAREST:\n\tdefault:\n\t\tdivider = DIV_ROUND_CLOSEST(*nanosec, base);\n\t\tbreak;\n\tcase CMDF_ROUND_DOWN:\n\t\tdivider = (*nanosec) / base;\n\t\tbreak;\n\tcase CMDF_ROUND_UP:\n\t\tdivider = DIV_ROUND_UP(*nanosec, base);\n\t\tbreak;\n\t}\n\tif (divider < 2)\n\t\tdivider = 2;\t \n\n\t \n\n\t*nanosec = base * divider;\n\treturn divider - 1;\t \n}\n\n \nstatic int rtd_ns_to_timer(unsigned int *ns, unsigned int flags)\n{\n\treturn rtd_ns_to_timer_base(ns, flags, RTD_CLOCK_BASE);\n}\n\n \nstatic unsigned short rtd_convert_chan_gain(struct comedi_device *dev,\n\t\t\t\t\t    unsigned int chanspec, int index)\n{\n\tconst struct rtd_boardinfo *board = dev->board_ptr;\n\tunsigned int chan = CR_CHAN(chanspec);\n\tunsigned int range = CR_RANGE(chanspec);\n\tunsigned int aref = CR_AREF(chanspec);\n\tunsigned short r = 0;\n\n\tr |= chan & 0xf;\n\n\t \n\tif (range < board->range_bip10) {\n\t\t \n\t\tr |= 0x000;\n\t\tr |= (range & 0x7) << 4;\n\t} else if (range < board->range_uni10) {\n\t\t \n\t\tr |= 0x100;\n\t\tr |= ((range - board->range_bip10) & 0x7) << 4;\n\t} else {\n\t\t \n\t\tr |= 0x200;\n\t\tr |= ((range - board->range_uni10) & 0x7) << 4;\n\t}\n\n\tswitch (aref) {\n\tcase AREF_GROUND:\t \n\t\tbreak;\n\n\tcase AREF_COMMON:\n\t\tr |= 0x80;\t \n\t\tbreak;\n\n\tcase AREF_DIFF:\n\t\tr |= 0x400;\t \n\t\tbreak;\n\n\tcase AREF_OTHER:\t \n\t\tbreak;\n\t}\n\treturn r;\n}\n\n \nstatic void rtd_load_channelgain_list(struct comedi_device *dev,\n\t\t\t\t      unsigned int n_chan, unsigned int *list)\n{\n\tif (n_chan > 1) {\t \n\t\tint ii;\n\n\t\twritel(0, dev->mmio + LAS0_CGT_CLEAR);\n\t\twritel(1, dev->mmio + LAS0_CGT_ENABLE);\n\t\tfor (ii = 0; ii < n_chan; ii++) {\n\t\t\twritel(rtd_convert_chan_gain(dev, list[ii], ii),\n\t\t\t       dev->mmio + LAS0_CGT_WRITE);\n\t\t}\n\t} else {\t\t \n\t\twritel(0, dev->mmio + LAS0_CGT_ENABLE);\n\t\twritel(rtd_convert_chan_gain(dev, list[0], 0),\n\t\t       dev->mmio + LAS0_CGL_WRITE);\n\t}\n}\n\n \nstatic int rtd520_probe_fifo_depth(struct comedi_device *dev)\n{\n\tunsigned int chanspec = CR_PACK(0, 0, AREF_GROUND);\n\tunsigned int i;\n\tstatic const unsigned int limit = 0x2000;\n\tunsigned int fifo_size = 0;\n\n\twritel(0, dev->mmio + LAS0_ADC_FIFO_CLEAR);\n\trtd_load_channelgain_list(dev, 1, &chanspec);\n\t \n\twritel(0, dev->mmio + LAS0_ADC_CONVERSION);\n\t \n\tfor (i = 0; i < limit; ++i) {\n\t\tunsigned int fifo_status;\n\t\t \n\t\twritew(0, dev->mmio + LAS0_ADC);\n\t\tusleep_range(1, 1000);\n\t\tfifo_status = readl(dev->mmio + LAS0_ADC);\n\t\tif ((fifo_status & FS_ADC_HEMPTY) == 0) {\n\t\t\tfifo_size = 2 * i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == limit) {\n\t\tdev_info(dev->class_dev, \"failed to probe fifo size.\\n\");\n\t\treturn -EIO;\n\t}\n\twritel(0, dev->mmio + LAS0_ADC_FIFO_CLEAR);\n\tif (fifo_size != 0x400 && fifo_size != 0x2000) {\n\t\tdev_info(dev->class_dev,\n\t\t\t \"unexpected fifo size of %i, expected 1024 or 8192.\\n\",\n\t\t\t fifo_size);\n\t\treturn -EIO;\n\t}\n\treturn fifo_size;\n}\n\nstatic int rtd_ai_eoc(struct comedi_device *dev,\n\t\t      struct comedi_subdevice *s,\n\t\t      struct comedi_insn *insn,\n\t\t      unsigned long context)\n{\n\tunsigned int status;\n\n\tstatus = readl(dev->mmio + LAS0_ADC);\n\tif (status & FS_ADC_NOT_EMPTY)\n\t\treturn 0;\n\treturn -EBUSY;\n}\n\nstatic int rtd_ai_rinsn(struct comedi_device *dev,\n\t\t\tstruct comedi_subdevice *s, struct comedi_insn *insn,\n\t\t\tunsigned int *data)\n{\n\tstruct rtd_private *devpriv = dev->private;\n\tunsigned int range = CR_RANGE(insn->chanspec);\n\tint ret;\n\tint n;\n\n\t \n\twritel(0, dev->mmio + LAS0_ADC_FIFO_CLEAR);\n\n\t \n\trtd_load_channelgain_list(dev, 1, &insn->chanspec);\n\n\t \n\twritel(0, dev->mmio + LAS0_ADC_CONVERSION);\n\n\t \n\tfor (n = 0; n < insn->n; n++) {\n\t\tunsigned short d;\n\t\t \n\t\twritew(0, dev->mmio + LAS0_ADC);\n\n\t\tret = comedi_timeout(dev, s, insn, rtd_ai_eoc, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\td = readw(devpriv->las1 + LAS1_ADC_FIFO);\n\t\td >>= 3;\t \n\n\t\t \n\t\tif (comedi_range_is_bipolar(s, range))\n\t\t\td = comedi_offset_munge(s, d);\n\n\t\tdata[n] = d & s->maxdata;\n\t}\n\n\t \n\treturn n;\n}\n\nstatic int ai_read_n(struct comedi_device *dev, struct comedi_subdevice *s,\n\t\t     int count)\n{\n\tstruct rtd_private *devpriv = dev->private;\n\tstruct comedi_async *async = s->async;\n\tstruct comedi_cmd *cmd = &async->cmd;\n\tint ii;\n\n\tfor (ii = 0; ii < count; ii++) {\n\t\tunsigned int range = CR_RANGE(cmd->chanlist[async->cur_chan]);\n\t\tunsigned short d;\n\n\t\tif (devpriv->ai_count == 0) {\t \n\t\t\td = readw(devpriv->las1 + LAS1_ADC_FIFO);\n\t\t\tcontinue;\n\t\t}\n\n\t\td = readw(devpriv->las1 + LAS1_ADC_FIFO);\n\t\td >>= 3;\t \n\n\t\t \n\t\tif (comedi_range_is_bipolar(s, range))\n\t\t\td = comedi_offset_munge(s, d);\n\t\td &= s->maxdata;\n\n\t\tif (!comedi_buf_write_samples(s, &d, 1))\n\t\t\treturn -1;\n\n\t\tif (devpriv->ai_count > 0)\t \n\t\t\tdevpriv->ai_count--;\n\t}\n\treturn 0;\n}\n\nstatic irqreturn_t rtd_interrupt(int irq, void *d)\n{\n\tstruct comedi_device *dev = d;\n\tstruct comedi_subdevice *s = dev->read_subdev;\n\tstruct rtd_private *devpriv = dev->private;\n\tu32 overrun;\n\tu16 status;\n\tu16 fifo_status;\n\n\tif (!dev->attached)\n\t\treturn IRQ_NONE;\n\n\tfifo_status = readl(dev->mmio + LAS0_ADC);\n\t \n\tif (!(fifo_status & FS_ADC_NOT_FULL))\t \n\t\tgoto xfer_abort;\n\n\tstatus = readw(dev->mmio + LAS0_IT);\n\t \n\tif (status == 0)\n\t\treturn IRQ_HANDLED;\n\n\tif (status & IRQM_ADC_ABOUT_CNT) {\t \n\t\t \n\t\tif (!(fifo_status & FS_ADC_HEMPTY)) {\n\t\t\t \n\t\t\tif (ai_read_n(dev, s, devpriv->fifosz / 2) < 0)\n\t\t\t\tgoto xfer_abort;\n\n\t\t\tif (devpriv->ai_count == 0)\n\t\t\t\tgoto xfer_done;\n\t\t} else if (devpriv->xfer_count > 0) {\n\t\t\tif (fifo_status & FS_ADC_NOT_EMPTY) {\n\t\t\t\t \n\t\t\t\tif (ai_read_n(dev, s, devpriv->xfer_count) < 0)\n\t\t\t\t\tgoto xfer_abort;\n\n\t\t\t\tif (devpriv->ai_count == 0)\n\t\t\t\t\tgoto xfer_done;\n\t\t\t}\n\t\t}\n\t}\n\n\toverrun = readl(dev->mmio + LAS0_OVERRUN) & 0xffff;\n\tif (overrun)\n\t\tgoto xfer_abort;\n\n\t \n\twritew(status, dev->mmio + LAS0_CLEAR);\n\treadw(dev->mmio + LAS0_CLEAR);\n\n\tcomedi_handle_events(dev, s);\n\n\treturn IRQ_HANDLED;\n\nxfer_abort:\n\ts->async->events |= COMEDI_CB_ERROR;\n\nxfer_done:\n\ts->async->events |= COMEDI_CB_EOA;\n\n\t \n\tstatus = readw(dev->mmio + LAS0_IT);\n\twritew(status, dev->mmio + LAS0_CLEAR);\n\treadw(dev->mmio + LAS0_CLEAR);\n\n\tfifo_status = readl(dev->mmio + LAS0_ADC);\n\toverrun = readl(dev->mmio + LAS0_OVERRUN) & 0xffff;\n\n\tcomedi_handle_events(dev, s);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int rtd_ai_cmdtest(struct comedi_device *dev,\n\t\t\t  struct comedi_subdevice *s, struct comedi_cmd *cmd)\n{\n\tint err = 0;\n\tunsigned int arg;\n\n\t \n\n\terr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW);\n\terr |= comedi_check_trigger_src(&cmd->scan_begin_src,\n\t\t\t\t\tTRIG_TIMER | TRIG_EXT);\n\terr |= comedi_check_trigger_src(&cmd->convert_src,\n\t\t\t\t\tTRIG_TIMER | TRIG_EXT);\n\terr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\n\terr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\n\n\tif (err)\n\t\treturn 1;\n\n\t \n\n\terr |= comedi_check_trigger_is_unique(cmd->scan_begin_src);\n\terr |= comedi_check_trigger_is_unique(cmd->convert_src);\n\terr |= comedi_check_trigger_is_unique(cmd->stop_src);\n\n\t \n\n\tif (err)\n\t\treturn 2;\n\n\t \n\n\terr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\n\n\tif (cmd->scan_begin_src == TRIG_TIMER) {\n\t\t \n\t\tif (cmd->chanlist_len == 1) {\t \n\t\t\tif (comedi_check_trigger_arg_min(&cmd->scan_begin_arg,\n\t\t\t\t\t\t\t RTD_MAX_SPEED_1)) {\n\t\t\t\trtd_ns_to_timer(&cmd->scan_begin_arg,\n\t\t\t\t\t\tCMDF_ROUND_UP);\n\t\t\t\terr |= -EINVAL;\n\t\t\t}\n\t\t\tif (comedi_check_trigger_arg_max(&cmd->scan_begin_arg,\n\t\t\t\t\t\t\t RTD_MIN_SPEED_1)) {\n\t\t\t\trtd_ns_to_timer(&cmd->scan_begin_arg,\n\t\t\t\t\t\tCMDF_ROUND_DOWN);\n\t\t\t\terr |= -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tif (comedi_check_trigger_arg_min(&cmd->scan_begin_arg,\n\t\t\t\t\t\t\t RTD_MAX_SPEED)) {\n\t\t\t\trtd_ns_to_timer(&cmd->scan_begin_arg,\n\t\t\t\t\t\tCMDF_ROUND_UP);\n\t\t\t\terr |= -EINVAL;\n\t\t\t}\n\t\t\tif (comedi_check_trigger_arg_max(&cmd->scan_begin_arg,\n\t\t\t\t\t\t\t RTD_MIN_SPEED)) {\n\t\t\t\trtd_ns_to_timer(&cmd->scan_begin_arg,\n\t\t\t\t\t\tCMDF_ROUND_DOWN);\n\t\t\t\terr |= -EINVAL;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\t \n\t\t \n\t\terr |= comedi_check_trigger_arg_max(&cmd->scan_begin_arg, 9);\n\t}\n\n\tif (cmd->convert_src == TRIG_TIMER) {\n\t\tif (cmd->chanlist_len == 1) {\t \n\t\t\tif (comedi_check_trigger_arg_min(&cmd->convert_arg,\n\t\t\t\t\t\t\t RTD_MAX_SPEED_1)) {\n\t\t\t\trtd_ns_to_timer(&cmd->convert_arg,\n\t\t\t\t\t\tCMDF_ROUND_UP);\n\t\t\t\terr |= -EINVAL;\n\t\t\t}\n\t\t\tif (comedi_check_trigger_arg_max(&cmd->convert_arg,\n\t\t\t\t\t\t\t RTD_MIN_SPEED_1)) {\n\t\t\t\trtd_ns_to_timer(&cmd->convert_arg,\n\t\t\t\t\t\tCMDF_ROUND_DOWN);\n\t\t\t\terr |= -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tif (comedi_check_trigger_arg_min(&cmd->convert_arg,\n\t\t\t\t\t\t\t RTD_MAX_SPEED)) {\n\t\t\t\trtd_ns_to_timer(&cmd->convert_arg,\n\t\t\t\t\t\tCMDF_ROUND_UP);\n\t\t\t\terr |= -EINVAL;\n\t\t\t}\n\t\t\tif (comedi_check_trigger_arg_max(&cmd->convert_arg,\n\t\t\t\t\t\t\t RTD_MIN_SPEED)) {\n\t\t\t\trtd_ns_to_timer(&cmd->convert_arg,\n\t\t\t\t\t\tCMDF_ROUND_DOWN);\n\t\t\t\terr |= -EINVAL;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\t \n\t\terr |= comedi_check_trigger_arg_max(&cmd->convert_arg, 9);\n\t}\n\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\n\t\t\t\t\t   cmd->chanlist_len);\n\n\tif (cmd->stop_src == TRIG_COUNT)\n\t\terr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\n\telse\t \n\t\terr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\n\n\tif (err)\n\t\treturn 3;\n\n\t \n\n\tif (cmd->scan_begin_src == TRIG_TIMER) {\n\t\targ = cmd->scan_begin_arg;\n\t\trtd_ns_to_timer(&arg, cmd->flags);\n\t\terr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, arg);\n\t}\n\n\tif (cmd->convert_src == TRIG_TIMER) {\n\t\targ = cmd->convert_arg;\n\t\trtd_ns_to_timer(&arg, cmd->flags);\n\t\terr |= comedi_check_trigger_arg_is(&cmd->convert_arg, arg);\n\n\t\tif (cmd->scan_begin_src == TRIG_TIMER) {\n\t\t\targ = cmd->convert_arg * cmd->scan_end_arg;\n\t\t\terr |= comedi_check_trigger_arg_min(\n\t\t\t\t\t&cmd->scan_begin_arg, arg);\n\t\t}\n\t}\n\n\tif (err)\n\t\treturn 4;\n\n\treturn 0;\n}\n\nstatic int rtd_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\n{\n\tstruct rtd_private *devpriv = dev->private;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tint timer;\n\n\t \n\t \n\twritel(0, dev->mmio + LAS0_PACER_STOP);\n\twritel(0, dev->mmio + LAS0_PACER);\t \n\twritel(0, dev->mmio + LAS0_ADC_CONVERSION);\n\twritew(0, dev->mmio + LAS0_IT);\n\twritel(0, dev->mmio + LAS0_ADC_FIFO_CLEAR);\n\twritel(0, dev->mmio + LAS0_OVERRUN);\n\n\t \n\t \n\trtd_load_channelgain_list(dev, cmd->chanlist_len, cmd->chanlist);\n\n\t \n\tif (cmd->chanlist_len > 1) {\n\t\t \n\t\twritel(0, dev->mmio + LAS0_PACER_START);\n\t\t \n\t\twritel(1, dev->mmio + LAS0_BURST_START);\n\t\t \n\t\twritel(2, dev->mmio + LAS0_ADC_CONVERSION);\n\t} else {\t\t \n\t\t \n\t\twritel(0, dev->mmio + LAS0_PACER_START);\n\t\t \n\t\twritel(1, dev->mmio + LAS0_ADC_CONVERSION);\n\t}\n\twritel((devpriv->fifosz / 2 - 1) & 0xffff, dev->mmio + LAS0_ACNT);\n\n\tif (cmd->scan_begin_src == TRIG_TIMER) {\n\t\t \n\t\t \n\t\tif (cmd->flags & CMDF_WAKE_EOS) {\n\t\t\t \n\t\t\tdevpriv->xfer_count = cmd->chanlist_len;\n\t\t\tdevpriv->flags |= SEND_EOS;\n\t\t} else {\n\t\t\t \n\t\t\tdevpriv->xfer_count =\n\t\t\t    (TRANS_TARGET_PERIOD * cmd->chanlist_len) /\n\t\t\t    cmd->scan_begin_arg;\n\t\t\tif (devpriv->xfer_count < cmd->chanlist_len) {\n\t\t\t\t \n\t\t\t\tdevpriv->xfer_count = cmd->chanlist_len;\n\t\t\t} else {\t \n\t\t\t\tdevpriv->xfer_count =\n\t\t\t\t    DIV_ROUND_UP(devpriv->xfer_count,\n\t\t\t\t\t\t cmd->chanlist_len);\n\t\t\t\tdevpriv->xfer_count *= cmd->chanlist_len;\n\t\t\t}\n\t\t\tdevpriv->flags |= SEND_EOS;\n\t\t}\n\t\tif (devpriv->xfer_count >= (devpriv->fifosz / 2)) {\n\t\t\t \n\t\t\tdevpriv->xfer_count = 0;\n\t\t\tdevpriv->flags &= ~SEND_EOS;\n\t\t} else {\n\t\t\t \n\t\t\twritel((devpriv->xfer_count - 1) & 0xffff,\n\t\t\t       dev->mmio + LAS0_ACNT);\n\t\t}\n\t} else {\t\t \n\t\tdevpriv->xfer_count = 0;\n\t\tdevpriv->flags &= ~SEND_EOS;\n\t}\n\t \n\twritel(1, dev->mmio + LAS0_PACER_SELECT);\n\t \n\twritel(1, dev->mmio + LAS0_ACNT_STOP_ENABLE);\n\n\t \n\n\t \n\tswitch (cmd->stop_src) {\n\tcase TRIG_COUNT:\t \n\t\tdevpriv->ai_count = cmd->stop_arg * cmd->chanlist_len;\n\t\tif ((devpriv->xfer_count > 0) &&\n\t\t    (devpriv->xfer_count > devpriv->ai_count)) {\n\t\t\tdevpriv->xfer_count = devpriv->ai_count;\n\t\t}\n\t\tbreak;\n\n\tcase TRIG_NONE:\t \n\t\tdevpriv->ai_count = -1;\t \n\t\tbreak;\n\t}\n\n\t \n\tswitch (cmd->scan_begin_src) {\n\tcase TRIG_TIMER:\t \n\t\ttimer = rtd_ns_to_timer(&cmd->scan_begin_arg,\n\t\t\t\t\tCMDF_ROUND_NEAREST);\n\t\t \n\t\twritel(timer & 0xffffff, dev->mmio + LAS0_PCLK);\n\n\t\tbreak;\n\n\tcase TRIG_EXT:\n\t\t \n\t\twritel(1, dev->mmio + LAS0_PACER_START);\n\t\tbreak;\n\t}\n\n\t \n\tswitch (cmd->convert_src) {\n\tcase TRIG_TIMER:\t \n\t\tif (cmd->chanlist_len > 1) {\n\t\t\t \n\t\t\ttimer = rtd_ns_to_timer(&cmd->convert_arg,\n\t\t\t\t\t\tCMDF_ROUND_NEAREST);\n\t\t\t \n\t\t\twritel(timer & 0x3ff, dev->mmio + LAS0_BCLK);\n\t\t}\n\n\t\tbreak;\n\n\tcase TRIG_EXT:\t\t \n\t\t \n\t\twritel(2, dev->mmio + LAS0_BURST_START);\n\t\tbreak;\n\t}\n\t \n\n\t \n\twritew(~0, dev->mmio + LAS0_CLEAR);\n\treadw(dev->mmio + LAS0_CLEAR);\n\n\t \n\t \n\twritew(IRQM_ADC_ABOUT_CNT, dev->mmio + LAS0_IT);\n\n\t \n\t \n\treadl(dev->mmio + LAS0_PACER);\t \n\treturn 0;\n}\n\nstatic int rtd_ai_cancel(struct comedi_device *dev, struct comedi_subdevice *s)\n{\n\tstruct rtd_private *devpriv = dev->private;\n\n\t \n\twritel(0, dev->mmio + LAS0_PACER_STOP);\n\twritel(0, dev->mmio + LAS0_PACER);\t \n\twritel(0, dev->mmio + LAS0_ADC_CONVERSION);\n\twritew(0, dev->mmio + LAS0_IT);\n\tdevpriv->ai_count = 0;\t \n\twritel(0, dev->mmio + LAS0_ADC_FIFO_CLEAR);\n\treturn 0;\n}\n\nstatic int rtd_ao_eoc(struct comedi_device *dev,\n\t\t      struct comedi_subdevice *s,\n\t\t      struct comedi_insn *insn,\n\t\t      unsigned long context)\n{\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int bit = (chan == 0) ? FS_DAC1_NOT_EMPTY : FS_DAC2_NOT_EMPTY;\n\tunsigned int status;\n\n\tstatus = readl(dev->mmio + LAS0_ADC);\n\tif (status & bit)\n\t\treturn 0;\n\treturn -EBUSY;\n}\n\nstatic int rtd_ao_insn_write(struct comedi_device *dev,\n\t\t\t     struct comedi_subdevice *s,\n\t\t\t     struct comedi_insn *insn,\n\t\t\t     unsigned int *data)\n{\n\tstruct rtd_private *devpriv = dev->private;\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int range = CR_RANGE(insn->chanspec);\n\tint ret;\n\tint i;\n\n\t \n\twritew(range & 7, dev->mmio + LAS0_DAC_CTRL(chan));\n\n\tfor (i = 0; i < insn->n; ++i) {\n\t\tunsigned int val = data[i];\n\n\t\t \n\t\tif (comedi_range_is_bipolar(s, range)) {\n\t\t\tval = comedi_offset_munge(s, val);\n\t\t\tval |= (val & ((s->maxdata + 1) >> 1)) << 1;\n\t\t}\n\n\t\t \n\t\tval <<= 3;\n\n\t\twritew(val, devpriv->las1 + LAS1_DAC_FIFO(chan));\n\t\twritew(0, dev->mmio + LAS0_UPDATE_DAC(chan));\n\n\t\tret = comedi_timeout(dev, s, insn, rtd_ao_eoc, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\ts->readback[chan] = data[i];\n\t}\n\n\treturn insn->n;\n}\n\nstatic int rtd_dio_insn_bits(struct comedi_device *dev,\n\t\t\t     struct comedi_subdevice *s,\n\t\t\t     struct comedi_insn *insn,\n\t\t\t     unsigned int *data)\n{\n\tif (comedi_dio_update_state(s, data))\n\t\twritew(s->state & 0xff, dev->mmio + LAS0_DIO0);\n\n\tdata[1] = readw(dev->mmio + LAS0_DIO0) & 0xff;\n\n\treturn insn->n;\n}\n\nstatic int rtd_dio_insn_config(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       struct comedi_insn *insn,\n\t\t\t       unsigned int *data)\n{\n\tint ret;\n\n\tret = comedi_dio_insn_config(dev, s, insn, data, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\t \n\twritew(0x01, dev->mmio + LAS0_DIO_STATUS);\n\twritew(s->io_bits & 0xff, dev->mmio + LAS0_DIO0_CTRL);\n\n\t \n\twritew(0x00, dev->mmio + LAS0_DIO_STATUS);\n\n\t \n\n\t \n\n\treturn insn->n;\n}\n\nstatic int rtd_counter_insn_config(struct comedi_device *dev,\n\t\t\t\t   struct comedi_subdevice *s,\n\t\t\t\t   struct comedi_insn *insn,\n\t\t\t\t   unsigned int *data)\n{\n\tstruct rtd_private *devpriv = dev->private;\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int max_src;\n\tunsigned int src;\n\n\tswitch (data[0]) {\n\tcase INSN_CONFIG_SET_GATE_SRC:\n\t\t \n\t\tsrc = data[2];\n\t\tmax_src = (chan == 0) ? 3 : 4;\n\t\tif (src > max_src)\n\t\t\treturn -EINVAL;\n\n\t\tdevpriv->timer_gate_src[chan] = src;\n\t\twriteb(src, dev->mmio + LAS0_8254_GATE_SEL(chan));\n\t\tbreak;\n\tcase INSN_CONFIG_GET_GATE_SRC:\n\t\tdata[2] = devpriv->timer_gate_src[chan];\n\t\tbreak;\n\tcase INSN_CONFIG_SET_CLOCK_SRC:\n\t\t \n\t\tsrc = data[1];\n\t\tswitch (chan) {\n\t\tcase 0:\n\t\t\tmax_src = 3;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tmax_src = 5;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tmax_src = 4;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (src > max_src)\n\t\t\treturn -EINVAL;\n\n\t\tdevpriv->timer_clk_src[chan] = src;\n\t\twriteb(src, dev->mmio + LAS0_8254_CLK_SEL(chan));\n\t\tbreak;\n\tcase INSN_CONFIG_GET_CLOCK_SRC:\n\t\tsrc = devpriv->timer_clk_src[chan];\n\t\tdata[1] = devpriv->timer_clk_src[chan];\n\t\tdata[2] = (src == 0) ? RTD_CLOCK_BASE : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn insn->n;\n}\n\nstatic void rtd_reset(struct comedi_device *dev)\n{\n\tstruct rtd_private *devpriv = dev->private;\n\n\twritel(0, dev->mmio + LAS0_BOARD_RESET);\n\tusleep_range(100, 1000);\t \n\twritel(0, devpriv->lcfg + PLX_REG_INTCSR);\n\twritew(0, dev->mmio + LAS0_IT);\n\twritew(~0, dev->mmio + LAS0_CLEAR);\n\treadw(dev->mmio + LAS0_CLEAR);\n}\n\n \nstatic void rtd_init_board(struct comedi_device *dev)\n{\n\trtd_reset(dev);\n\n\twritel(0, dev->mmio + LAS0_OVERRUN);\n\twritel(0, dev->mmio + LAS0_CGT_CLEAR);\n\twritel(0, dev->mmio + LAS0_ADC_FIFO_CLEAR);\n\twritel(0, dev->mmio + LAS0_DAC_RESET(0));\n\twritel(0, dev->mmio + LAS0_DAC_RESET(1));\n\t \n\twritew(0, dev->mmio + LAS0_DIO_STATUS);\n\t \n}\n\n \nstatic void rtd_pci_latency_quirk(struct comedi_device *dev,\n\t\t\t\t  struct pci_dev *pcidev)\n{\n\tunsigned char pci_latency;\n\n\tpci_read_config_byte(pcidev, PCI_LATENCY_TIMER, &pci_latency);\n\tif (pci_latency < 32) {\n\t\tdev_info(dev->class_dev,\n\t\t\t \"PCI latency changed from %d to %d\\n\",\n\t\t\t pci_latency, 32);\n\t\tpci_write_config_byte(pcidev, PCI_LATENCY_TIMER, 32);\n\t}\n}\n\nstatic int rtd_auto_attach(struct comedi_device *dev,\n\t\t\t   unsigned long context)\n{\n\tstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\n\tconst struct rtd_boardinfo *board = NULL;\n\tstruct rtd_private *devpriv;\n\tstruct comedi_subdevice *s;\n\tint ret;\n\n\tif (context < ARRAY_SIZE(rtd520_boards))\n\t\tboard = &rtd520_boards[context];\n\tif (!board)\n\t\treturn -ENODEV;\n\tdev->board_ptr = board;\n\tdev->board_name = board->name;\n\n\tdevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\n\tif (!devpriv)\n\t\treturn -ENOMEM;\n\n\tret = comedi_pci_enable(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tdev->mmio = pci_ioremap_bar(pcidev, 2);\n\tdevpriv->las1 = pci_ioremap_bar(pcidev, 3);\n\tdevpriv->lcfg = pci_ioremap_bar(pcidev, 0);\n\tif (!dev->mmio || !devpriv->las1 || !devpriv->lcfg)\n\t\treturn -ENOMEM;\n\n\trtd_pci_latency_quirk(dev, pcidev);\n\n\tif (pcidev->irq) {\n\t\tret = request_irq(pcidev->irq, rtd_interrupt, IRQF_SHARED,\n\t\t\t\t  dev->board_name, dev);\n\t\tif (ret == 0)\n\t\t\tdev->irq = pcidev->irq;\n\t}\n\n\tret = comedi_alloc_subdevices(dev, 4);\n\tif (ret)\n\t\treturn ret;\n\n\ts = &dev->subdevices[0];\n\t \n\ts->type\t\t= COMEDI_SUBD_AI;\n\ts->subdev_flags\t= SDF_READABLE | SDF_GROUND | SDF_COMMON | SDF_DIFF;\n\ts->n_chan\t= 16;\n\ts->maxdata\t= 0x0fff;\n\ts->range_table\t= board->ai_range;\n\ts->len_chanlist\t= RTD_MAX_CHANLIST;\n\ts->insn_read\t= rtd_ai_rinsn;\n\tif (dev->irq) {\n\t\tdev->read_subdev = s;\n\t\ts->subdev_flags\t|= SDF_CMD_READ;\n\t\ts->do_cmd\t= rtd_ai_cmd;\n\t\ts->do_cmdtest\t= rtd_ai_cmdtest;\n\t\ts->cancel\t= rtd_ai_cancel;\n\t}\n\n\ts = &dev->subdevices[1];\n\t \n\ts->type\t\t= COMEDI_SUBD_AO;\n\ts->subdev_flags\t= SDF_WRITABLE;\n\ts->n_chan\t= 2;\n\ts->maxdata\t= 0x0fff;\n\ts->range_table\t= &rtd_ao_range;\n\ts->insn_write\t= rtd_ao_insn_write;\n\n\tret = comedi_alloc_subdev_readback(s);\n\tif (ret)\n\t\treturn ret;\n\n\ts = &dev->subdevices[2];\n\t \n\ts->type\t\t= COMEDI_SUBD_DIO;\n\ts->subdev_flags\t= SDF_READABLE | SDF_WRITABLE;\n\t \n\ts->n_chan\t= 8;\n\ts->maxdata\t= 1;\n\ts->range_table\t= &range_digital;\n\ts->insn_bits\t= rtd_dio_insn_bits;\n\ts->insn_config\t= rtd_dio_insn_config;\n\n\t \n\ts = &dev->subdevices[3];\n\tdev->pacer = comedi_8254_mm_init(dev->mmio + LAS0_8254_TIMER_BASE,\n\t\t\t\t\t RTD_CLOCK_BASE, I8254_IO8, 2);\n\tif (!dev->pacer)\n\t\treturn -ENOMEM;\n\n\tcomedi_8254_subdevice_init(s, dev->pacer);\n\tdev->pacer->insn_config = rtd_counter_insn_config;\n\n\trtd_init_board(dev);\n\n\tret = rtd520_probe_fifo_depth(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\tdevpriv->fifosz = ret;\n\n\tif (dev->irq)\n\t\twritel(PLX_INTCSR_PIEN | PLX_INTCSR_PLIEN,\n\t\t       devpriv->lcfg + PLX_REG_INTCSR);\n\n\treturn 0;\n}\n\nstatic void rtd_detach(struct comedi_device *dev)\n{\n\tstruct rtd_private *devpriv = dev->private;\n\n\tif (devpriv) {\n\t\t \n\t\tif (dev->mmio && devpriv->lcfg)\n\t\t\trtd_reset(dev);\n\t\tif (dev->irq)\n\t\t\tfree_irq(dev->irq, dev);\n\t\tif (dev->mmio)\n\t\t\tiounmap(dev->mmio);\n\t\tif (devpriv->las1)\n\t\t\tiounmap(devpriv->las1);\n\t\tif (devpriv->lcfg)\n\t\t\tiounmap(devpriv->lcfg);\n\t}\n\tcomedi_pci_disable(dev);\n}\n\nstatic struct comedi_driver rtd520_driver = {\n\t.driver_name\t= \"rtd520\",\n\t.module\t\t= THIS_MODULE,\n\t.auto_attach\t= rtd_auto_attach,\n\t.detach\t\t= rtd_detach,\n};\n\nstatic int rtd520_pci_probe(struct pci_dev *dev,\n\t\t\t    const struct pci_device_id *id)\n{\n\treturn comedi_pci_auto_config(dev, &rtd520_driver, id->driver_data);\n}\n\nstatic const struct pci_device_id rtd520_pci_table[] = {\n\t{ PCI_VDEVICE(RTD, 0x7520), BOARD_DM7520 },\n\t{ PCI_VDEVICE(RTD, 0x4520), BOARD_PCI4520 },\n\t{ 0 }\n};\nMODULE_DEVICE_TABLE(pci, rtd520_pci_table);\n\nstatic struct pci_driver rtd520_pci_driver = {\n\t.name\t\t= \"rtd520\",\n\t.id_table\t= rtd520_pci_table,\n\t.probe\t\t= rtd520_pci_probe,\n\t.remove\t\t= comedi_pci_auto_unconfig,\n};\nmodule_comedi_pci_driver(rtd520_driver, rtd520_pci_driver);\n\nMODULE_AUTHOR(\"Comedi https://www.comedi.org\");\nMODULE_DESCRIPTION(\"Comedi low-level driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}