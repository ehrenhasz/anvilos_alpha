{
  "module_name": "pcmuio.c",
  "hash_id": "6232811efadbda003cf3f962d328ad4dd65567249f6c7f80b14d8f02f7e53a34",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/pcmuio.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/comedi/comedidev.h>\n\n \n#define PCMUIO_PORT_REG(x)\t\t(0x00 + (x))\n#define PCMUIO_INT_PENDING_REG\t\t0x06\n#define PCMUIO_PAGE_LOCK_REG\t\t0x07\n#define PCMUIO_LOCK_PORT(x)\t\t((1 << (x)) & 0x3f)\n#define PCMUIO_PAGE(x)\t\t\t(((x) & 0x3) << 6)\n#define PCMUIO_PAGE_MASK\t\tPCMUIO_PAGE(3)\n#define PCMUIO_PAGE_POL\t\t\t1\n#define PCMUIO_PAGE_ENAB\t\t2\n#define PCMUIO_PAGE_INT_ID\t\t3\n#define PCMUIO_PAGE_REG(x)\t\t(0x08 + (x))\n\n#define PCMUIO_ASIC_IOSIZE\t\t0x10\n#define PCMUIO_MAX_ASICS\t\t2\n\nstruct pcmuio_board {\n\tconst char *name;\n\tconst int num_asics;\n};\n\nstatic const struct pcmuio_board pcmuio_boards[] = {\n\t{\n\t\t.name\t\t= \"pcmuio48\",\n\t\t.num_asics\t= 1,\n\t}, {\n\t\t.name\t\t= \"pcmuio96\",\n\t\t.num_asics\t= 2,\n\t},\n};\n\nstruct pcmuio_asic {\n\tspinlock_t pagelock;\t \n\tspinlock_t spinlock;\t \n\tunsigned int enabled_mask;\n\tunsigned int active:1;\n};\n\nstruct pcmuio_private {\n\tstruct pcmuio_asic asics[PCMUIO_MAX_ASICS];\n\tunsigned int irq2;\n};\n\nstatic inline unsigned long pcmuio_asic_iobase(struct comedi_device *dev,\n\t\t\t\t\t       int asic)\n{\n\treturn dev->iobase + (asic * PCMUIO_ASIC_IOSIZE);\n}\n\nstatic inline int pcmuio_subdevice_to_asic(struct comedi_subdevice *s)\n{\n\t \n\treturn s->index / 2;\n}\n\nstatic inline int pcmuio_subdevice_to_port(struct comedi_subdevice *s)\n{\n\t \n\treturn (s->index % 2) ? 3 : 0;\n}\n\nstatic void pcmuio_write(struct comedi_device *dev, unsigned int val,\n\t\t\t int asic, int page, int port)\n{\n\tstruct pcmuio_private *devpriv = dev->private;\n\tstruct pcmuio_asic *chip = &devpriv->asics[asic];\n\tunsigned long iobase = pcmuio_asic_iobase(dev, asic);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chip->pagelock, flags);\n\tif (page == 0) {\n\t\t \n\t\toutb(val & 0xff, iobase + PCMUIO_PORT_REG(port + 0));\n\t\toutb((val >> 8) & 0xff, iobase + PCMUIO_PORT_REG(port + 1));\n\t\toutb((val >> 16) & 0xff, iobase + PCMUIO_PORT_REG(port + 2));\n\t} else {\n\t\toutb(PCMUIO_PAGE(page), iobase + PCMUIO_PAGE_LOCK_REG);\n\t\toutb(val & 0xff, iobase + PCMUIO_PAGE_REG(0));\n\t\toutb((val >> 8) & 0xff, iobase + PCMUIO_PAGE_REG(1));\n\t\toutb((val >> 16) & 0xff, iobase + PCMUIO_PAGE_REG(2));\n\t}\n\tspin_unlock_irqrestore(&chip->pagelock, flags);\n}\n\nstatic unsigned int pcmuio_read(struct comedi_device *dev,\n\t\t\t\tint asic, int page, int port)\n{\n\tstruct pcmuio_private *devpriv = dev->private;\n\tstruct pcmuio_asic *chip = &devpriv->asics[asic];\n\tunsigned long iobase = pcmuio_asic_iobase(dev, asic);\n\tunsigned long flags;\n\tunsigned int val;\n\n\tspin_lock_irqsave(&chip->pagelock, flags);\n\tif (page == 0) {\n\t\t \n\t\tval = inb(iobase + PCMUIO_PORT_REG(port + 0));\n\t\tval |= (inb(iobase + PCMUIO_PORT_REG(port + 1)) << 8);\n\t\tval |= (inb(iobase + PCMUIO_PORT_REG(port + 2)) << 16);\n\t} else {\n\t\toutb(PCMUIO_PAGE(page), iobase + PCMUIO_PAGE_LOCK_REG);\n\t\tval = inb(iobase + PCMUIO_PAGE_REG(0));\n\t\tval |= (inb(iobase + PCMUIO_PAGE_REG(1)) << 8);\n\t\tval |= (inb(iobase + PCMUIO_PAGE_REG(2)) << 16);\n\t}\n\tspin_unlock_irqrestore(&chip->pagelock, flags);\n\n\treturn val;\n}\n\n \nstatic int pcmuio_dio_insn_bits(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tstruct comedi_insn *insn,\n\t\t\t\tunsigned int *data)\n{\n\tint asic = pcmuio_subdevice_to_asic(s);\n\tint port = pcmuio_subdevice_to_port(s);\n\tunsigned int chanmask = (1 << s->n_chan) - 1;\n\tunsigned int mask;\n\tunsigned int val;\n\n\tmask = comedi_dio_update_state(s, data);\n\tif (mask) {\n\t\t \n\t\tval = ~s->state & chanmask;\n\t\tval &= s->io_bits;\n\t\tpcmuio_write(dev, val, asic, 0, port);\n\t}\n\n\t \n\tval = pcmuio_read(dev, asic, 0, port);\n\n\t \n\tdata[1] = ~val & chanmask;\n\n\treturn insn->n;\n}\n\nstatic int pcmuio_dio_insn_config(struct comedi_device *dev,\n\t\t\t\t  struct comedi_subdevice *s,\n\t\t\t\t  struct comedi_insn *insn,\n\t\t\t\t  unsigned int *data)\n{\n\tint asic = pcmuio_subdevice_to_asic(s);\n\tint port = pcmuio_subdevice_to_port(s);\n\tint ret;\n\n\tret = comedi_dio_insn_config(dev, s, insn, data, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tif (data[0] == INSN_CONFIG_DIO_INPUT)\n\t\tpcmuio_write(dev, s->io_bits, asic, 0, port);\n\n\treturn insn->n;\n}\n\nstatic void pcmuio_reset(struct comedi_device *dev)\n{\n\tconst struct pcmuio_board *board = dev->board_ptr;\n\tint asic;\n\n\tfor (asic = 0; asic < board->num_asics; ++asic) {\n\t\t \n\t\tpcmuio_write(dev, 0, asic, 0, 0);\n\t\tpcmuio_write(dev, 0, asic, 0, 3);\n\n\t\t \n\t\tpcmuio_write(dev, 0, asic, PCMUIO_PAGE_POL, 0);\n\t\tpcmuio_write(dev, 0, asic, PCMUIO_PAGE_ENAB, 0);\n\t\tpcmuio_write(dev, 0, asic, PCMUIO_PAGE_INT_ID, 0);\n\t}\n}\n\n \nstatic void pcmuio_stop_intr(struct comedi_device *dev,\n\t\t\t     struct comedi_subdevice *s)\n{\n\tstruct pcmuio_private *devpriv = dev->private;\n\tint asic = pcmuio_subdevice_to_asic(s);\n\tstruct pcmuio_asic *chip = &devpriv->asics[asic];\n\n\tchip->enabled_mask = 0;\n\tchip->active = 0;\n\ts->async->inttrig = NULL;\n\n\t \n\tpcmuio_write(dev, 0, asic, PCMUIO_PAGE_ENAB, 0);\n}\n\nstatic void pcmuio_handle_intr_subdev(struct comedi_device *dev,\n\t\t\t\t      struct comedi_subdevice *s,\n\t\t\t\t      unsigned int triggered)\n{\n\tstruct pcmuio_private *devpriv = dev->private;\n\tint asic = pcmuio_subdevice_to_asic(s);\n\tstruct pcmuio_asic *chip = &devpriv->asics[asic];\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tunsigned int val = 0;\n\tunsigned long flags;\n\tunsigned int i;\n\n\tspin_lock_irqsave(&chip->spinlock, flags);\n\n\tif (!chip->active)\n\t\tgoto done;\n\n\tif (!(triggered & chip->enabled_mask))\n\t\tgoto done;\n\n\tfor (i = 0; i < cmd->chanlist_len; i++) {\n\t\tunsigned int chan = CR_CHAN(cmd->chanlist[i]);\n\n\t\tif (triggered & (1 << chan))\n\t\t\tval |= (1 << i);\n\t}\n\n\tcomedi_buf_write_samples(s, &val, 1);\n\n\tif (cmd->stop_src == TRIG_COUNT &&\n\t    s->async->scans_done >= cmd->stop_arg)\n\t\ts->async->events |= COMEDI_CB_EOA;\n\ndone:\n\tspin_unlock_irqrestore(&chip->spinlock, flags);\n\n\tcomedi_handle_events(dev, s);\n}\n\nstatic int pcmuio_handle_asic_interrupt(struct comedi_device *dev, int asic)\n{\n\t \n\tstruct comedi_subdevice *s = &dev->subdevices[asic * 2];\n\tunsigned long iobase = pcmuio_asic_iobase(dev, asic);\n\tunsigned int val;\n\n\t \n\tval = inb(iobase + PCMUIO_INT_PENDING_REG) & 0x07;\n\tif (!val)\n\t\treturn 0;\n\n\t \n\tval = pcmuio_read(dev, asic, PCMUIO_PAGE_INT_ID, 0);\n\tpcmuio_write(dev, 0, asic, PCMUIO_PAGE_INT_ID, 0);\n\n\t \n\tpcmuio_handle_intr_subdev(dev, s, val);\n\n\treturn 1;\n}\n\nstatic irqreturn_t pcmuio_interrupt(int irq, void *d)\n{\n\tstruct comedi_device *dev = d;\n\tstruct pcmuio_private *devpriv = dev->private;\n\tint handled = 0;\n\n\tif (irq == dev->irq)\n\t\thandled += pcmuio_handle_asic_interrupt(dev, 0);\n\tif (irq == devpriv->irq2)\n\t\thandled += pcmuio_handle_asic_interrupt(dev, 1);\n\n\treturn handled ? IRQ_HANDLED : IRQ_NONE;\n}\n\n \nstatic void pcmuio_start_intr(struct comedi_device *dev,\n\t\t\t      struct comedi_subdevice *s)\n{\n\tstruct pcmuio_private *devpriv = dev->private;\n\tint asic = pcmuio_subdevice_to_asic(s);\n\tstruct pcmuio_asic *chip = &devpriv->asics[asic];\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tunsigned int bits = 0;\n\tunsigned int pol_bits = 0;\n\tint i;\n\n\tchip->enabled_mask = 0;\n\tchip->active = 1;\n\tif (cmd->chanlist) {\n\t\tfor (i = 0; i < cmd->chanlist_len; i++) {\n\t\t\tunsigned int chanspec = cmd->chanlist[i];\n\t\t\tunsigned int chan = CR_CHAN(chanspec);\n\t\t\tunsigned int range = CR_RANGE(chanspec);\n\t\t\tunsigned int aref = CR_AREF(chanspec);\n\n\t\t\tbits |= (1 << chan);\n\t\t\tpol_bits |= ((aref || range) ? 1 : 0) << chan;\n\t\t}\n\t}\n\tbits &= ((1 << s->n_chan) - 1);\n\tchip->enabled_mask = bits;\n\n\t \n\tpcmuio_write(dev, pol_bits, asic, PCMUIO_PAGE_POL, 0);\n\tpcmuio_write(dev, bits, asic, PCMUIO_PAGE_ENAB, 0);\n}\n\nstatic int pcmuio_cancel(struct comedi_device *dev, struct comedi_subdevice *s)\n{\n\tstruct pcmuio_private *devpriv = dev->private;\n\tint asic = pcmuio_subdevice_to_asic(s);\n\tstruct pcmuio_asic *chip = &devpriv->asics[asic];\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chip->spinlock, flags);\n\tif (chip->active)\n\t\tpcmuio_stop_intr(dev, s);\n\tspin_unlock_irqrestore(&chip->spinlock, flags);\n\n\treturn 0;\n}\n\nstatic int pcmuio_inttrig_start_intr(struct comedi_device *dev,\n\t\t\t\t     struct comedi_subdevice *s,\n\t\t\t\t     unsigned int trig_num)\n{\n\tstruct pcmuio_private *devpriv = dev->private;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tint asic = pcmuio_subdevice_to_asic(s);\n\tstruct pcmuio_asic *chip = &devpriv->asics[asic];\n\tunsigned long flags;\n\n\tif (trig_num != cmd->start_arg)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&chip->spinlock, flags);\n\ts->async->inttrig = NULL;\n\tif (chip->active)\n\t\tpcmuio_start_intr(dev, s);\n\n\tspin_unlock_irqrestore(&chip->spinlock, flags);\n\n\treturn 1;\n}\n\n \nstatic int pcmuio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\n{\n\tstruct pcmuio_private *devpriv = dev->private;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tint asic = pcmuio_subdevice_to_asic(s);\n\tstruct pcmuio_asic *chip = &devpriv->asics[asic];\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chip->spinlock, flags);\n\tchip->active = 1;\n\n\t \n\tif (cmd->start_src == TRIG_INT)\n\t\ts->async->inttrig = pcmuio_inttrig_start_intr;\n\telse\t \n\t\tpcmuio_start_intr(dev, s);\n\n\tspin_unlock_irqrestore(&chip->spinlock, flags);\n\n\treturn 0;\n}\n\nstatic int pcmuio_cmdtest(struct comedi_device *dev,\n\t\t\t  struct comedi_subdevice *s,\n\t\t\t  struct comedi_cmd *cmd)\n{\n\tint err = 0;\n\n\t \n\n\terr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_INT);\n\terr |= comedi_check_trigger_src(&cmd->scan_begin_src, TRIG_EXT);\n\terr |= comedi_check_trigger_src(&cmd->convert_src, TRIG_NOW);\n\terr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\n\terr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\n\n\tif (err)\n\t\treturn 1;\n\n\t \n\n\terr |= comedi_check_trigger_is_unique(cmd->start_src);\n\terr |= comedi_check_trigger_is_unique(cmd->stop_src);\n\n\t \n\n\tif (err)\n\t\treturn 2;\n\n\t \n\n\terr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);\n\terr |= comedi_check_trigger_arg_is(&cmd->convert_arg, 0);\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\n\t\t\t\t\t   cmd->chanlist_len);\n\n\tif (cmd->stop_src == TRIG_COUNT)\n\t\terr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\n\telse\t \n\t\terr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\n\n\tif (err)\n\t\treturn 3;\n\n\t \n\n\t \n\n\treturn 0;\n}\n\nstatic int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)\n{\n\tconst struct pcmuio_board *board = dev->board_ptr;\n\tstruct comedi_subdevice *s;\n\tstruct pcmuio_private *devpriv;\n\tint ret;\n\tint i;\n\n\tret = comedi_request_region(dev, it->options[0],\n\t\t\t\t    board->num_asics * PCMUIO_ASIC_IOSIZE);\n\tif (ret)\n\t\treturn ret;\n\n\tdevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\n\tif (!devpriv)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < PCMUIO_MAX_ASICS; ++i) {\n\t\tstruct pcmuio_asic *chip = &devpriv->asics[i];\n\n\t\tspin_lock_init(&chip->pagelock);\n\t\tspin_lock_init(&chip->spinlock);\n\t}\n\n\tpcmuio_reset(dev);\n\n\tif (it->options[1]) {\n\t\t \n\t\tret = request_irq(it->options[1], pcmuio_interrupt, 0,\n\t\t\t\t  dev->board_name, dev);\n\t\tif (ret == 0)\n\t\t\tdev->irq = it->options[1];\n\t}\n\n\tif (board->num_asics == 2) {\n\t\tif (it->options[2] == dev->irq) {\n\t\t\t \n\t\t\tdevpriv->irq2 = it->options[2];\n\t\t} else if (it->options[2]) {\n\t\t\t \n\t\t\tret = request_irq(it->options[2], pcmuio_interrupt, 0,\n\t\t\t\t\t  dev->board_name, dev);\n\t\t\tif (ret == 0)\n\t\t\t\tdevpriv->irq2 = it->options[2];\n\t\t}\n\t}\n\n\tret = comedi_alloc_subdevices(dev, board->num_asics * 2);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < dev->n_subdevices; ++i) {\n\t\ts = &dev->subdevices[i];\n\t\ts->type\t\t= COMEDI_SUBD_DIO;\n\t\ts->subdev_flags\t= SDF_READABLE | SDF_WRITABLE;\n\t\ts->n_chan\t= 24;\n\t\ts->maxdata\t= 1;\n\t\ts->range_table\t= &range_digital;\n\t\ts->insn_bits\t= pcmuio_dio_insn_bits;\n\t\ts->insn_config\t= pcmuio_dio_insn_config;\n\n\t\t \n\t\tif ((i == 0 && dev->irq) || (i == 2 && devpriv->irq2)) {\n\t\t\t \n\t\t\tdev->read_subdev = s;\n\t\t\ts->subdev_flags\t|= SDF_CMD_READ | SDF_LSAMPL |\n\t\t\t\t\t   SDF_PACKED;\n\t\t\ts->len_chanlist\t= s->n_chan;\n\t\t\ts->cancel\t= pcmuio_cancel;\n\t\t\ts->do_cmd\t= pcmuio_cmd;\n\t\t\ts->do_cmdtest\t= pcmuio_cmdtest;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void pcmuio_detach(struct comedi_device *dev)\n{\n\tstruct pcmuio_private *devpriv = dev->private;\n\n\tif (devpriv) {\n\t\tpcmuio_reset(dev);\n\n\t\t \n\t\tif (devpriv->irq2 && devpriv->irq2 != dev->irq)\n\t\t\tfree_irq(devpriv->irq2, dev);\n\t}\n\tcomedi_legacy_detach(dev);\n}\n\nstatic struct comedi_driver pcmuio_driver = {\n\t.driver_name\t= \"pcmuio\",\n\t.module\t\t= THIS_MODULE,\n\t.attach\t\t= pcmuio_attach,\n\t.detach\t\t= pcmuio_detach,\n\t.board_name\t= &pcmuio_boards[0].name,\n\t.offset\t\t= sizeof(struct pcmuio_board),\n\t.num_names\t= ARRAY_SIZE(pcmuio_boards),\n};\nmodule_comedi_driver(pcmuio_driver);\n\nMODULE_AUTHOR(\"Comedi https://www.comedi.org\");\nMODULE_DESCRIPTION(\"Comedi low-level driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}