{
  "module_name": "ii_pci20kc.c",
  "hash_id": "e3157c8163676da0b2e2cb326c43e7c2323d8ba8ec9e0544c73ade242453e8db",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/ii_pci20kc.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/comedi/comedidev.h>\n\n \n#define II20K_SIZE\t\t\t0x400\n#define II20K_MOD_OFFSET\t\t0x100\n#define II20K_ID_REG\t\t\t0x00\n#define II20K_ID_MOD1_EMPTY\t\tBIT(7)\n#define II20K_ID_MOD2_EMPTY\t\tBIT(6)\n#define II20K_ID_MOD3_EMPTY\t\tBIT(5)\n#define II20K_ID_MASK\t\t\t0x1f\n#define II20K_ID_PCI20001C_1A\t\t0x1b\t \n#define II20K_ID_PCI20001C_2A\t\t0x1d\t \n#define II20K_MOD_STATUS_REG\t\t0x40\n#define II20K_MOD_STATUS_IRQ_MOD1\tBIT(7)\n#define II20K_MOD_STATUS_IRQ_MOD2\tBIT(6)\n#define II20K_MOD_STATUS_IRQ_MOD3\tBIT(5)\n#define II20K_DIO0_REG\t\t\t0x80\n#define II20K_DIO1_REG\t\t\t0x81\n#define II20K_DIR_ENA_REG\t\t0x82\n#define II20K_DIR_DIO3_OUT\t\tBIT(7)\n#define II20K_DIR_DIO2_OUT\t\tBIT(6)\n#define II20K_BUF_DISAB_DIO3\t\tBIT(5)\n#define II20K_BUF_DISAB_DIO2\t\tBIT(4)\n#define II20K_DIR_DIO1_OUT\t\tBIT(3)\n#define II20K_DIR_DIO0_OUT\t\tBIT(2)\n#define II20K_BUF_DISAB_DIO1\t\tBIT(1)\n#define II20K_BUF_DISAB_DIO0\t\tBIT(0)\n#define II20K_CTRL01_REG\t\t0x83\n#define II20K_CTRL01_SET\t\tBIT(7)\n#define II20K_CTRL01_DIO0_IN\t\tBIT(4)\n#define II20K_CTRL01_DIO1_IN\t\tBIT(1)\n#define II20K_DIO2_REG\t\t\t0xc0\n#define II20K_DIO3_REG\t\t\t0xc1\n#define II20K_CTRL23_REG\t\t0xc3\n#define II20K_CTRL23_SET\t\tBIT(7)\n#define II20K_CTRL23_DIO2_IN\t\tBIT(4)\n#define II20K_CTRL23_DIO3_IN\t\tBIT(1)\n\n#define II20K_ID_PCI20006M_1\t\t0xe2\t \n#define II20K_ID_PCI20006M_2\t\t0xe3\t \n#define II20K_AO_STRB_REG(x)\t\t(0x0b + ((x) * 0x08))\n#define II20K_AO_LSB_REG(x)\t\t(0x0d + ((x) * 0x08))\n#define II20K_AO_MSB_REG(x)\t\t(0x0e + ((x) * 0x08))\n#define II20K_AO_STRB_BOTH_REG\t\t0x1b\n\n#define II20K_ID_PCI20341M_1\t\t0x77\t \n#define II20K_AI_STATUS_CMD_REG\t\t0x01\n#define II20K_AI_STATUS_CMD_BUSY\tBIT(7)\n#define II20K_AI_STATUS_CMD_HW_ENA\tBIT(1)\n#define II20K_AI_STATUS_CMD_EXT_START\tBIT(0)\n#define II20K_AI_LSB_REG\t\t0x02\n#define II20K_AI_MSB_REG\t\t0x03\n#define II20K_AI_PACER_RESET_REG\t0x04\n#define II20K_AI_16BIT_DATA_REG\t\t0x06\n#define II20K_AI_CONF_REG\t\t0x10\n#define II20K_AI_CONF_ENA\t\tBIT(2)\n#define II20K_AI_OPT_REG\t\t0x11\n#define II20K_AI_OPT_TRIG_ENA\t\tBIT(5)\n#define II20K_AI_OPT_TRIG_INV\t\tBIT(4)\n#define II20K_AI_OPT_TIMEBASE(x)\t(((x) & 0x3) << 1)\n#define II20K_AI_OPT_BURST_MODE\t\tBIT(0)\n#define II20K_AI_STATUS_REG\t\t0x12\n#define II20K_AI_STATUS_INT\t\tBIT(7)\n#define II20K_AI_STATUS_TRIG\t\tBIT(6)\n#define II20K_AI_STATUS_TRIG_ENA\tBIT(5)\n#define II20K_AI_STATUS_PACER_ERR\tBIT(2)\n#define II20K_AI_STATUS_DATA_ERR\tBIT(1)\n#define II20K_AI_STATUS_SET_TIME_ERR\tBIT(0)\n#define II20K_AI_LAST_CHAN_ADDR_REG\t0x13\n#define II20K_AI_CUR_ADDR_REG\t\t0x14\n#define II20K_AI_SET_TIME_REG\t\t0x15\n#define II20K_AI_DELAY_LSB_REG\t\t0x16\n#define II20K_AI_DELAY_MSB_REG\t\t0x17\n#define II20K_AI_CHAN_ADV_REG\t\t0x18\n#define II20K_AI_CHAN_RESET_REG\t\t0x19\n#define II20K_AI_START_TRIG_REG\t\t0x1a\n#define II20K_AI_COUNT_RESET_REG\t0x1b\n#define II20K_AI_CHANLIST_REG\t\t0x80\n#define II20K_AI_CHANLIST_ONBOARD_ONLY\tBIT(5)\n#define II20K_AI_CHANLIST_GAIN(x)\t(((x) & 0x3) << 3)\n#define II20K_AI_CHANLIST_MUX_ENA\tBIT(2)\n#define II20K_AI_CHANLIST_CHAN(x)\t(((x) & 0x3) << 0)\n#define II20K_AI_CHANLIST_LEN\t\t0x80\n\n \nstatic const struct comedi_lrange ii20k_ao_ranges = {\n\t3, {\n\t\tBIP_RANGE(5),\t \n\t\tUNI_RANGE(10),\t \n\t\tBIP_RANGE(10)\t \n\t}\n};\n\nstatic const struct comedi_lrange ii20k_ai_ranges = {\n\t4, {\n\t\tBIP_RANGE(5),\t\t \n\t\tBIP_RANGE(0.5),\t\t \n\t\tBIP_RANGE(0.05),\t \n\t\tBIP_RANGE(0.025)\t \n\t},\n};\n\nstatic void __iomem *ii20k_module_iobase(struct comedi_device *dev,\n\t\t\t\t\t struct comedi_subdevice *s)\n{\n\treturn dev->mmio + (s->index + 1) * II20K_MOD_OFFSET;\n}\n\nstatic int ii20k_ao_insn_write(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       struct comedi_insn *insn,\n\t\t\t       unsigned int *data)\n{\n\tvoid __iomem *iobase = ii20k_module_iobase(dev, s);\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tint i;\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\tunsigned int val = data[i];\n\n\t\ts->readback[chan] = val;\n\n\t\t \n\t\tval = comedi_offset_munge(s, val);\n\n\t\twriteb(val & 0xff, iobase + II20K_AO_LSB_REG(chan));\n\t\twriteb((val >> 8) & 0xff, iobase + II20K_AO_MSB_REG(chan));\n\t\twriteb(0x00, iobase + II20K_AO_STRB_REG(chan));\n\t}\n\n\treturn insn->n;\n}\n\nstatic int ii20k_ai_eoc(struct comedi_device *dev,\n\t\t\tstruct comedi_subdevice *s,\n\t\t\tstruct comedi_insn *insn,\n\t\t\tunsigned long context)\n{\n\tvoid __iomem *iobase = ii20k_module_iobase(dev, s);\n\tunsigned char status;\n\n\tstatus = readb(iobase + II20K_AI_STATUS_REG);\n\tif ((status & II20K_AI_STATUS_INT) == 0)\n\t\treturn 0;\n\treturn -EBUSY;\n}\n\nstatic void ii20k_ai_setup(struct comedi_device *dev,\n\t\t\t   struct comedi_subdevice *s,\n\t\t\t   unsigned int chanspec)\n{\n\tvoid __iomem *iobase = ii20k_module_iobase(dev, s);\n\tunsigned int chan = CR_CHAN(chanspec);\n\tunsigned int range = CR_RANGE(chanspec);\n\tunsigned char val;\n\n\t \n\twriteb(II20K_AI_CONF_ENA, iobase + II20K_AI_CONF_REG);\n\n\t \n\twriteb(0, iobase + II20K_AI_STATUS_CMD_REG);\n\n\t \n\tval = (range < 3) ? II20K_AI_OPT_TIMEBASE(0) : II20K_AI_OPT_TIMEBASE(2);\n\twriteb(val, iobase + II20K_AI_OPT_REG);\n\n\t \n\tval = (range < 2) ? 0x58 : (range < 3) ? 0x93 : 0x99;\n\twriteb(val, iobase + II20K_AI_SET_TIME_REG);\n\n\t \n\twriteb(1, iobase + II20K_AI_LAST_CHAN_ADDR_REG);\n\n\t \n\tval = II20K_AI_CHANLIST_ONBOARD_ONLY |\n\t      II20K_AI_CHANLIST_MUX_ENA |\n\t      II20K_AI_CHANLIST_GAIN(range) |\n\t      II20K_AI_CHANLIST_CHAN(chan);\n\twriteb(val, iobase + II20K_AI_CHANLIST_REG);\n\n\t \n\twriteb(0, iobase + II20K_AI_COUNT_RESET_REG);\n\n\t \n\twriteb(0, iobase + II20K_AI_CHAN_RESET_REG);\n}\n\nstatic int ii20k_ai_insn_read(struct comedi_device *dev,\n\t\t\t      struct comedi_subdevice *s,\n\t\t\t      struct comedi_insn *insn,\n\t\t\t      unsigned int *data)\n{\n\tvoid __iomem *iobase = ii20k_module_iobase(dev, s);\n\tint ret;\n\tint i;\n\n\tii20k_ai_setup(dev, s, insn->chanspec);\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\tunsigned int val;\n\n\t\t \n\t\treadb(iobase + II20K_AI_PACER_RESET_REG);\n\n\t\tret = comedi_timeout(dev, s, insn, ii20k_ai_eoc, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tval = readb(iobase + II20K_AI_LSB_REG);\n\t\tval |= (readb(iobase + II20K_AI_MSB_REG) << 8);\n\n\t\t \n\t\tdata[i] = comedi_offset_munge(s, val);\n\t}\n\n\treturn insn->n;\n}\n\nstatic void ii20k_dio_config(struct comedi_device *dev,\n\t\t\t     struct comedi_subdevice *s)\n{\n\tunsigned char ctrl01 = 0;\n\tunsigned char ctrl23 = 0;\n\tunsigned char dir_ena = 0;\n\n\t \n\tif (s->io_bits & 0x000000ff) {\n\t\t \n\t\tctrl01 &= ~II20K_CTRL01_DIO0_IN;\n\t\tdir_ena &= ~II20K_BUF_DISAB_DIO0;\n\t\tdir_ena |= II20K_DIR_DIO0_OUT;\n\t} else {\n\t\t \n\t\tctrl01 |= II20K_CTRL01_DIO0_IN;\n\t\tdir_ena &= ~II20K_DIR_DIO0_OUT;\n\t}\n\n\t \n\tif (s->io_bits & 0x0000ff00) {\n\t\t \n\t\tctrl01 &= ~II20K_CTRL01_DIO1_IN;\n\t\tdir_ena &= ~II20K_BUF_DISAB_DIO1;\n\t\tdir_ena |= II20K_DIR_DIO1_OUT;\n\t} else {\n\t\t \n\t\tctrl01 |= II20K_CTRL01_DIO1_IN;\n\t\tdir_ena &= ~II20K_DIR_DIO1_OUT;\n\t}\n\n\t \n\tif (s->io_bits & 0x00ff0000) {\n\t\t \n\t\tctrl23 &= ~II20K_CTRL23_DIO2_IN;\n\t\tdir_ena &= ~II20K_BUF_DISAB_DIO2;\n\t\tdir_ena |= II20K_DIR_DIO2_OUT;\n\t} else {\n\t\t \n\t\tctrl23 |= II20K_CTRL23_DIO2_IN;\n\t\tdir_ena &= ~II20K_DIR_DIO2_OUT;\n\t}\n\n\t \n\tif (s->io_bits & 0xff000000) {\n\t\t \n\t\tctrl23 &= ~II20K_CTRL23_DIO3_IN;\n\t\tdir_ena &= ~II20K_BUF_DISAB_DIO3;\n\t\tdir_ena |= II20K_DIR_DIO3_OUT;\n\t} else {\n\t\t \n\t\tctrl23 |= II20K_CTRL23_DIO3_IN;\n\t\tdir_ena &= ~II20K_DIR_DIO3_OUT;\n\t}\n\n\tctrl23 |= II20K_CTRL01_SET;\n\tctrl23 |= II20K_CTRL23_SET;\n\n\t \n\twriteb(ctrl01, dev->mmio + II20K_CTRL01_REG);\n\twriteb(ctrl23, dev->mmio + II20K_CTRL23_REG);\n\twriteb(dir_ena, dev->mmio + II20K_DIR_ENA_REG);\n}\n\nstatic int ii20k_dio_insn_config(struct comedi_device *dev,\n\t\t\t\t struct comedi_subdevice *s,\n\t\t\t\t struct comedi_insn *insn,\n\t\t\t\t unsigned int *data)\n{\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int mask;\n\tint ret;\n\n\tif (chan < 8)\n\t\tmask = 0x000000ff;\n\telse if (chan < 16)\n\t\tmask = 0x0000ff00;\n\telse if (chan < 24)\n\t\tmask = 0x00ff0000;\n\telse\n\t\tmask = 0xff000000;\n\n\tret = comedi_dio_insn_config(dev, s, insn, data, mask);\n\tif (ret)\n\t\treturn ret;\n\n\tii20k_dio_config(dev, s);\n\n\treturn insn->n;\n}\n\nstatic int ii20k_dio_insn_bits(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       struct comedi_insn *insn,\n\t\t\t       unsigned int *data)\n{\n\tunsigned int mask;\n\n\tmask = comedi_dio_update_state(s, data);\n\tif (mask) {\n\t\tif (mask & 0x000000ff)\n\t\t\twriteb((s->state >> 0) & 0xff,\n\t\t\t       dev->mmio + II20K_DIO0_REG);\n\t\tif (mask & 0x0000ff00)\n\t\t\twriteb((s->state >> 8) & 0xff,\n\t\t\t       dev->mmio + II20K_DIO1_REG);\n\t\tif (mask & 0x00ff0000)\n\t\t\twriteb((s->state >> 16) & 0xff,\n\t\t\t       dev->mmio + II20K_DIO2_REG);\n\t\tif (mask & 0xff000000)\n\t\t\twriteb((s->state >> 24) & 0xff,\n\t\t\t       dev->mmio + II20K_DIO3_REG);\n\t}\n\n\tdata[1] = readb(dev->mmio + II20K_DIO0_REG);\n\tdata[1] |= readb(dev->mmio + II20K_DIO1_REG) << 8;\n\tdata[1] |= readb(dev->mmio + II20K_DIO2_REG) << 16;\n\tdata[1] |= readb(dev->mmio + II20K_DIO3_REG) << 24;\n\n\treturn insn->n;\n}\n\nstatic int ii20k_init_module(struct comedi_device *dev,\n\t\t\t     struct comedi_subdevice *s)\n{\n\tvoid __iomem *iobase = ii20k_module_iobase(dev, s);\n\tunsigned char id;\n\tint ret;\n\n\tid = readb(iobase + II20K_ID_REG);\n\tswitch (id) {\n\tcase II20K_ID_PCI20006M_1:\n\tcase II20K_ID_PCI20006M_2:\n\t\t \n\t\ts->type\t\t= COMEDI_SUBD_AO;\n\t\ts->subdev_flags\t= SDF_WRITABLE;\n\t\ts->n_chan\t= (id == II20K_ID_PCI20006M_2) ? 2 : 1;\n\t\ts->maxdata\t= 0xffff;\n\t\ts->range_table\t= &ii20k_ao_ranges;\n\t\ts->insn_write\t= ii20k_ao_insn_write;\n\n\t\tret = comedi_alloc_subdev_readback(s);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase II20K_ID_PCI20341M_1:\n\t\t \n\t\ts->type\t\t= COMEDI_SUBD_AI;\n\t\ts->subdev_flags\t= SDF_READABLE | SDF_DIFF;\n\t\ts->n_chan\t= 4;\n\t\ts->maxdata\t= 0xffff;\n\t\ts->range_table\t= &ii20k_ai_ranges;\n\t\ts->insn_read\t= ii20k_ai_insn_read;\n\t\tbreak;\n\tdefault:\n\t\ts->type = COMEDI_SUBD_UNUSED;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int ii20k_attach(struct comedi_device *dev,\n\t\t\tstruct comedi_devconfig *it)\n{\n\tstruct comedi_subdevice *s;\n\tunsigned int membase;\n\tunsigned char id;\n\tbool has_dio;\n\tint ret;\n\n\tmembase = it->options[0];\n\tif (!membase || (membase & ~(0x100000 - II20K_SIZE))) {\n\t\tdev_warn(dev->class_dev,\n\t\t\t \"%s: invalid memory address specified\\n\",\n\t\t\t dev->board_name);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!request_mem_region(membase, II20K_SIZE, dev->board_name)) {\n\t\tdev_warn(dev->class_dev, \"%s: I/O mem conflict (%#x,%u)\\n\",\n\t\t\t dev->board_name, membase, II20K_SIZE);\n\t\treturn -EIO;\n\t}\n\tdev->iobase = membase;\t \n\n\tdev->mmio = ioremap(membase, II20K_SIZE);\n\tif (!dev->mmio)\n\t\treturn -ENOMEM;\n\n\tid = readb(dev->mmio + II20K_ID_REG);\n\tswitch (id & II20K_ID_MASK) {\n\tcase II20K_ID_PCI20001C_1A:\n\t\thas_dio = false;\n\t\tbreak;\n\tcase II20K_ID_PCI20001C_2A:\n\t\thas_dio = true;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\tret = comedi_alloc_subdevices(dev, 4);\n\tif (ret)\n\t\treturn ret;\n\n\ts = &dev->subdevices[0];\n\tif (id & II20K_ID_MOD1_EMPTY) {\n\t\ts->type = COMEDI_SUBD_UNUSED;\n\t} else {\n\t\tret = ii20k_init_module(dev, s);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\ts = &dev->subdevices[1];\n\tif (id & II20K_ID_MOD2_EMPTY) {\n\t\ts->type = COMEDI_SUBD_UNUSED;\n\t} else {\n\t\tret = ii20k_init_module(dev, s);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\ts = &dev->subdevices[2];\n\tif (id & II20K_ID_MOD3_EMPTY) {\n\t\ts->type = COMEDI_SUBD_UNUSED;\n\t} else {\n\t\tret = ii20k_init_module(dev, s);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\ts = &dev->subdevices[3];\n\tif (has_dio) {\n\t\ts->type\t\t= COMEDI_SUBD_DIO;\n\t\ts->subdev_flags\t= SDF_READABLE | SDF_WRITABLE;\n\t\ts->n_chan\t= 32;\n\t\ts->maxdata\t= 1;\n\t\ts->range_table\t= &range_digital;\n\t\ts->insn_bits\t= ii20k_dio_insn_bits;\n\t\ts->insn_config\t= ii20k_dio_insn_config;\n\n\t\t \n\t\tii20k_dio_config(dev, s);\n\t} else {\n\t\ts->type = COMEDI_SUBD_UNUSED;\n\t}\n\n\treturn 0;\n}\n\nstatic void ii20k_detach(struct comedi_device *dev)\n{\n\tif (dev->mmio)\n\t\tiounmap(dev->mmio);\n\tif (dev->iobase)\t \n\t\trelease_mem_region(dev->iobase, II20K_SIZE);\n}\n\nstatic struct comedi_driver ii20k_driver = {\n\t.driver_name\t= \"ii_pci20kc\",\n\t.module\t\t= THIS_MODULE,\n\t.attach\t\t= ii20k_attach,\n\t.detach\t\t= ii20k_detach,\n};\nmodule_comedi_driver(ii20k_driver);\n\nMODULE_AUTHOR(\"Comedi https://www.comedi.org\");\nMODULE_DESCRIPTION(\"Comedi driver for Intelligent Instruments PCI-20001C\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}