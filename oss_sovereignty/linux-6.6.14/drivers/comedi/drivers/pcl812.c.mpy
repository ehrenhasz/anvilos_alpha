{
  "module_name": "pcl812.c",
  "hash_id": "a4641b72d0f7b6c63fe23f2417fecd83e4a51d19af73ee9a1f09e7b86ede8df2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/pcl812.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/comedi/comedidev.h>\n#include <linux/comedi/comedi_8254.h>\n#include <linux/comedi/comedi_isadma.h>\n\n \n#define PCL812_TIMER_BASE\t\t\t0x00\n#define PCL812_AI_LSB_REG\t\t\t0x04\n#define PCL812_AI_MSB_REG\t\t\t0x05\n#define PCL812_AI_MSB_DRDY\t\t\tBIT(4)\n#define PCL812_AO_LSB_REG(x)\t\t\t(0x04 + ((x) * 2))\n#define PCL812_AO_MSB_REG(x)\t\t\t(0x05 + ((x) * 2))\n#define PCL812_DI_LSB_REG\t\t\t0x06\n#define PCL812_DI_MSB_REG\t\t\t0x07\n#define PCL812_STATUS_REG\t\t\t0x08\n#define PCL812_STATUS_DRDY\t\t\tBIT(5)\n#define PCL812_RANGE_REG\t\t\t0x09\n#define PCL812_MUX_REG\t\t\t\t0x0a\n#define PCL812_MUX_CHAN(x)\t\t\t((x) << 0)\n#define PCL812_MUX_CS0\t\t\t\tBIT(4)\n#define PCL812_MUX_CS1\t\t\t\tBIT(5)\n#define PCL812_CTRL_REG\t\t\t\t0x0b\n#define PCL812_CTRL_TRIG(x)\t\t\t(((x) & 0x7) << 0)\n#define PCL812_CTRL_DISABLE_TRIG\t\tPCL812_CTRL_TRIG(0)\n#define PCL812_CTRL_SOFT_TRIG\t\t\tPCL812_CTRL_TRIG(1)\n#define PCL812_CTRL_PACER_DMA_TRIG\t\tPCL812_CTRL_TRIG(2)\n#define PCL812_CTRL_PACER_EOC_TRIG\t\tPCL812_CTRL_TRIG(6)\n#define PCL812_SOFTTRIG_REG\t\t\t0x0c\n#define PCL812_DO_LSB_REG\t\t\t0x0d\n#define PCL812_DO_MSB_REG\t\t\t0x0e\n\n#define MAX_CHANLIST_LEN    256\t \n\nstatic const struct comedi_lrange range_pcl812pg_ai = {\n\t5, {\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(2.5),\n\t\tBIP_RANGE(1.25),\n\t\tBIP_RANGE(0.625),\n\t\tBIP_RANGE(0.3125)\n\t}\n};\n\nstatic const struct comedi_lrange range_pcl812pg2_ai = {\n\t5, {\n\t\tBIP_RANGE(10),\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(2.5),\n\t\tBIP_RANGE(1.25),\n\t\tBIP_RANGE(0.625)\n\t}\n};\n\nstatic const struct comedi_lrange range812_bipolar1_25 = {\n\t1, {\n\t\tBIP_RANGE(1.25)\n\t}\n};\n\nstatic const struct comedi_lrange range812_bipolar0_625 = {\n\t1, {\n\t\tBIP_RANGE(0.625)\n\t}\n};\n\nstatic const struct comedi_lrange range812_bipolar0_3125 = {\n\t1, {\n\t\tBIP_RANGE(0.3125)\n\t}\n};\n\nstatic const struct comedi_lrange range_pcl813b_ai = {\n\t4, {\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(2.5),\n\t\tBIP_RANGE(1.25),\n\t\tBIP_RANGE(0.625)\n\t}\n};\n\nstatic const struct comedi_lrange range_pcl813b2_ai = {\n\t4, {\n\t\tUNI_RANGE(10),\n\t\tUNI_RANGE(5),\n\t\tUNI_RANGE(2.5),\n\t\tUNI_RANGE(1.25)\n\t}\n};\n\nstatic const struct comedi_lrange range_iso813_1_ai = {\n\t5, {\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(2.5),\n\t\tBIP_RANGE(1.25),\n\t\tBIP_RANGE(0.625),\n\t\tBIP_RANGE(0.3125)\n\t}\n};\n\nstatic const struct comedi_lrange range_iso813_1_2_ai = {\n\t5, {\n\t\tUNI_RANGE(10),\n\t\tUNI_RANGE(5),\n\t\tUNI_RANGE(2.5),\n\t\tUNI_RANGE(1.25),\n\t\tUNI_RANGE(0.625)\n\t}\n};\n\nstatic const struct comedi_lrange range_iso813_2_ai = {\n\t4, {\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(2.5),\n\t\tBIP_RANGE(1.25),\n\t\tBIP_RANGE(0.625)\n\t}\n};\n\nstatic const struct comedi_lrange range_iso813_2_2_ai = {\n\t4, {\n\t\tUNI_RANGE(10),\n\t\tUNI_RANGE(5),\n\t\tUNI_RANGE(2.5),\n\t\tUNI_RANGE(1.25)\n\t}\n};\n\nstatic const struct comedi_lrange range_acl8113_1_ai = {\n\t4, {\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(2.5),\n\t\tBIP_RANGE(1.25),\n\t\tBIP_RANGE(0.625)\n\t}\n};\n\nstatic const struct comedi_lrange range_acl8113_1_2_ai = {\n\t4, {\n\t\tUNI_RANGE(10),\n\t\tUNI_RANGE(5),\n\t\tUNI_RANGE(2.5),\n\t\tUNI_RANGE(1.25)\n\t}\n};\n\nstatic const struct comedi_lrange range_acl8113_2_ai = {\n\t3, {\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(2.5),\n\t\tBIP_RANGE(1.25)\n\t}\n};\n\nstatic const struct comedi_lrange range_acl8113_2_2_ai = {\n\t3, {\n\t\tUNI_RANGE(10),\n\t\tUNI_RANGE(5),\n\t\tUNI_RANGE(2.5)\n\t}\n};\n\nstatic const struct comedi_lrange range_acl8112dg_ai = {\n\t9, {\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(2.5),\n\t\tBIP_RANGE(1.25),\n\t\tBIP_RANGE(0.625),\n\t\tUNI_RANGE(10),\n\t\tUNI_RANGE(5),\n\t\tUNI_RANGE(2.5),\n\t\tUNI_RANGE(1.25),\n\t\tBIP_RANGE(10)\n\t}\n};\n\nstatic const struct comedi_lrange range_acl8112hg_ai = {\n\t12, {\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(0.5),\n\t\tBIP_RANGE(0.05),\n\t\tBIP_RANGE(0.005),\n\t\tUNI_RANGE(10),\n\t\tUNI_RANGE(1),\n\t\tUNI_RANGE(0.1),\n\t\tUNI_RANGE(0.01),\n\t\tBIP_RANGE(10),\n\t\tBIP_RANGE(1),\n\t\tBIP_RANGE(0.1),\n\t\tBIP_RANGE(0.01)\n\t}\n};\n\nstatic const struct comedi_lrange range_a821pgh_ai = {\n\t4, {\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(0.5),\n\t\tBIP_RANGE(0.05),\n\t\tBIP_RANGE(0.005)\n\t}\n};\n\nenum pcl812_boardtype {\n\tBOARD_PCL812PG\t= 0,\t \n\tBOARD_PCL813B\t= 1,\n\tBOARD_PCL812\t= 2,\n\tBOARD_PCL813\t= 3,\n\tBOARD_ISO813\t= 5,\n\tBOARD_ACL8113\t= 6,\n\tBOARD_ACL8112\t= 7,\t \n\tBOARD_ACL8216\t= 8,\t \n\tBOARD_A821\t= 9,\t \n};\n\nstruct pcl812_board {\n\tconst char *name;\n\tenum pcl812_boardtype board_type;\n\tint n_aichan;\n\tint n_aochan;\n\tunsigned int ai_ns_min;\n\tconst struct comedi_lrange *rangelist_ai;\n\tunsigned int irq_bits;\n\tunsigned int has_dma:1;\n\tunsigned int has_16bit_ai:1;\n\tunsigned int has_mpc508_mux:1;\n\tunsigned int has_dio:1;\n};\n\nstatic const struct pcl812_board boardtypes[] = {\n\t{\n\t\t.name\t\t= \"pcl812\",\n\t\t.board_type\t= BOARD_PCL812,\n\t\t.n_aichan\t= 16,\n\t\t.n_aochan\t= 2,\n\t\t.ai_ns_min\t= 33000,\n\t\t.rangelist_ai\t= &range_bipolar10,\n\t\t.irq_bits\t= 0xdcfc,\n\t\t.has_dma\t= 1,\n\t\t.has_dio\t= 1,\n\t}, {\n\t\t.name\t\t= \"pcl812pg\",\n\t\t.board_type\t= BOARD_PCL812PG,\n\t\t.n_aichan\t= 16,\n\t\t.n_aochan\t= 2,\n\t\t.ai_ns_min\t= 33000,\n\t\t.rangelist_ai\t= &range_pcl812pg_ai,\n\t\t.irq_bits\t= 0xdcfc,\n\t\t.has_dma\t= 1,\n\t\t.has_dio\t= 1,\n\t}, {\n\t\t.name\t\t= \"acl8112pg\",\n\t\t.board_type\t= BOARD_PCL812PG,\n\t\t.n_aichan\t= 16,\n\t\t.n_aochan\t= 2,\n\t\t.ai_ns_min\t= 10000,\n\t\t.rangelist_ai\t= &range_pcl812pg_ai,\n\t\t.irq_bits\t= 0xdcfc,\n\t\t.has_dma\t= 1,\n\t\t.has_dio\t= 1,\n\t}, {\n\t\t.name\t\t= \"acl8112dg\",\n\t\t.board_type\t= BOARD_ACL8112,\n\t\t.n_aichan\t= 16,\t \n\t\t.n_aochan\t= 2,\n\t\t.ai_ns_min\t= 10000,\n\t\t.rangelist_ai\t= &range_acl8112dg_ai,\n\t\t.irq_bits\t= 0xdcfc,\n\t\t.has_dma\t= 1,\n\t\t.has_mpc508_mux\t= 1,\n\t\t.has_dio\t= 1,\n\t}, {\n\t\t.name\t\t= \"acl8112hg\",\n\t\t.board_type\t= BOARD_ACL8112,\n\t\t.n_aichan\t= 16,\t \n\t\t.n_aochan\t= 2,\n\t\t.ai_ns_min\t= 10000,\n\t\t.rangelist_ai\t= &range_acl8112hg_ai,\n\t\t.irq_bits\t= 0xdcfc,\n\t\t.has_dma\t= 1,\n\t\t.has_mpc508_mux\t= 1,\n\t\t.has_dio\t= 1,\n\t}, {\n\t\t.name\t\t= \"a821pgl\",\n\t\t.board_type\t= BOARD_A821,\n\t\t.n_aichan\t= 16,\t \n\t\t.n_aochan\t= 1,\n\t\t.ai_ns_min\t= 10000,\n\t\t.rangelist_ai\t= &range_pcl813b_ai,\n\t\t.irq_bits\t= 0x000c,\n\t\t.has_dio\t= 1,\n\t}, {\n\t\t.name\t\t= \"a821pglnda\",\n\t\t.board_type\t= BOARD_A821,\n\t\t.n_aichan\t= 16,\t \n\t\t.ai_ns_min\t= 10000,\n\t\t.rangelist_ai\t= &range_pcl813b_ai,\n\t\t.irq_bits\t= 0x000c,\n\t}, {\n\t\t.name\t\t= \"a821pgh\",\n\t\t.board_type\t= BOARD_A821,\n\t\t.n_aichan\t= 16,\t \n\t\t.n_aochan\t= 1,\n\t\t.ai_ns_min\t= 10000,\n\t\t.rangelist_ai\t= &range_a821pgh_ai,\n\t\t.irq_bits\t= 0x000c,\n\t\t.has_dio\t= 1,\n\t}, {\n\t\t.name\t\t= \"a822pgl\",\n\t\t.board_type\t= BOARD_ACL8112,\n\t\t.n_aichan\t= 16,\t \n\t\t.n_aochan\t= 2,\n\t\t.ai_ns_min\t= 10000,\n\t\t.rangelist_ai\t= &range_acl8112dg_ai,\n\t\t.irq_bits\t= 0xdcfc,\n\t\t.has_dma\t= 1,\n\t\t.has_dio\t= 1,\n\t}, {\n\t\t.name\t\t= \"a822pgh\",\n\t\t.board_type\t= BOARD_ACL8112,\n\t\t.n_aichan\t= 16,\t \n\t\t.n_aochan\t= 2,\n\t\t.ai_ns_min\t= 10000,\n\t\t.rangelist_ai\t= &range_acl8112hg_ai,\n\t\t.irq_bits\t= 0xdcfc,\n\t\t.has_dma\t= 1,\n\t\t.has_dio\t= 1,\n\t}, {\n\t\t.name\t\t= \"a823pgl\",\n\t\t.board_type\t= BOARD_ACL8112,\n\t\t.n_aichan\t= 16,\t \n\t\t.n_aochan\t= 2,\n\t\t.ai_ns_min\t= 8000,\n\t\t.rangelist_ai\t= &range_acl8112dg_ai,\n\t\t.irq_bits\t= 0xdcfc,\n\t\t.has_dma\t= 1,\n\t\t.has_dio\t= 1,\n\t}, {\n\t\t.name\t\t= \"a823pgh\",\n\t\t.board_type\t= BOARD_ACL8112,\n\t\t.n_aichan\t= 16,\t \n\t\t.n_aochan\t= 2,\n\t\t.ai_ns_min\t= 8000,\n\t\t.rangelist_ai\t= &range_acl8112hg_ai,\n\t\t.irq_bits\t= 0xdcfc,\n\t\t.has_dma\t= 1,\n\t\t.has_dio\t= 1,\n\t}, {\n\t\t.name\t\t= \"pcl813\",\n\t\t.board_type\t= BOARD_PCL813,\n\t\t.n_aichan\t= 32,\n\t\t.rangelist_ai\t= &range_pcl813b_ai,\n\t}, {\n\t\t.name\t\t= \"pcl813b\",\n\t\t.board_type\t= BOARD_PCL813B,\n\t\t.n_aichan\t= 32,\n\t\t.rangelist_ai\t= &range_pcl813b_ai,\n\t}, {\n\t\t.name\t\t= \"acl8113\",\n\t\t.board_type\t= BOARD_ACL8113,\n\t\t.n_aichan\t= 32,\n\t\t.rangelist_ai\t= &range_acl8113_1_ai,\n\t}, {\n\t\t.name\t\t= \"iso813\",\n\t\t.board_type\t= BOARD_ISO813,\n\t\t.n_aichan\t= 32,\n\t\t.rangelist_ai\t= &range_iso813_1_ai,\n\t}, {\n\t\t.name\t\t= \"acl8216\",\n\t\t.board_type\t= BOARD_ACL8216,\n\t\t.n_aichan\t= 16,\t \n\t\t.n_aochan\t= 2,\n\t\t.ai_ns_min\t= 10000,\n\t\t.rangelist_ai\t= &range_pcl813b2_ai,\n\t\t.irq_bits\t= 0xdcfc,\n\t\t.has_dma\t= 1,\n\t\t.has_16bit_ai\t= 1,\n\t\t.has_mpc508_mux\t= 1,\n\t\t.has_dio\t= 1,\n\t}, {\n\t\t.name\t\t= \"a826pg\",\n\t\t.board_type\t= BOARD_ACL8216,\n\t\t.n_aichan\t= 16,\t \n\t\t.n_aochan\t= 2,\n\t\t.ai_ns_min\t= 10000,\n\t\t.rangelist_ai\t= &range_pcl813b2_ai,\n\t\t.irq_bits\t= 0xdcfc,\n\t\t.has_dma\t= 1,\n\t\t.has_16bit_ai\t= 1,\n\t\t.has_dio\t= 1,\n\t},\n};\n\nstruct pcl812_private {\n\tstruct comedi_isadma *dma;\n\tunsigned char range_correction;\t \n\tunsigned int last_ai_chanspec;\n\tunsigned char mode_reg_int;  \n\tunsigned int ai_poll_ptr;  \n\tunsigned int max_812_ai_mode0_rangewait;  \n\tunsigned int use_diff:1;\n\tunsigned int use_mpc508:1;\n\tunsigned int use_ext_trg:1;\n\tunsigned int ai_dma:1;\n\tunsigned int ai_eos:1;\n};\n\nstatic void pcl812_ai_setup_dma(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tunsigned int unread_samples)\n{\n\tstruct pcl812_private *devpriv = dev->private;\n\tstruct comedi_isadma *dma = devpriv->dma;\n\tstruct comedi_isadma_desc *desc = &dma->desc[dma->cur_dma];\n\tunsigned int bytes;\n\tunsigned int max_samples;\n\tunsigned int nsamples;\n\n\tcomedi_isadma_disable(dma->chan);\n\n\t \n\tbytes = devpriv->ai_eos ? comedi_bytes_per_scan(s) : desc->maxsize;\n\tmax_samples = comedi_bytes_to_samples(s, bytes);\n\n\t \n\tnsamples = comedi_nsamples_left(s, max_samples + unread_samples);\n\tif (nsamples > unread_samples) {\n\t\tnsamples -= unread_samples;\n\t\tdesc->size = comedi_samples_to_bytes(s, nsamples);\n\t\tcomedi_isadma_program(desc);\n\t}\n}\n\nstatic void pcl812_ai_set_chan_range(struct comedi_device *dev,\n\t\t\t\t     unsigned int chanspec, char wait)\n{\n\tstruct pcl812_private *devpriv = dev->private;\n\tunsigned int chan = CR_CHAN(chanspec);\n\tunsigned int range = CR_RANGE(chanspec);\n\tunsigned int mux = 0;\n\n\tif (chanspec == devpriv->last_ai_chanspec)\n\t\treturn;\n\n\tdevpriv->last_ai_chanspec = chanspec;\n\n\tif (devpriv->use_mpc508) {\n\t\tif (devpriv->use_diff) {\n\t\t\tmux |= PCL812_MUX_CS0 | PCL812_MUX_CS1;\n\t\t} else {\n\t\t\tif (chan < 8)\n\t\t\t\tmux |= PCL812_MUX_CS0;\n\t\t\telse\n\t\t\t\tmux |= PCL812_MUX_CS1;\n\t\t}\n\t}\n\n\toutb(mux | PCL812_MUX_CHAN(chan), dev->iobase + PCL812_MUX_REG);\n\toutb(range + devpriv->range_correction, dev->iobase + PCL812_RANGE_REG);\n\n\tif (wait)\n\t\t \n\t\tudelay(devpriv->max_812_ai_mode0_rangewait);\n}\n\nstatic void pcl812_ai_clear_eoc(struct comedi_device *dev)\n{\n\t \n\toutb(0, dev->iobase + PCL812_STATUS_REG);\n}\n\nstatic void pcl812_ai_soft_trig(struct comedi_device *dev)\n{\n\t \n\toutb(255, dev->iobase + PCL812_SOFTTRIG_REG);\n}\n\nstatic unsigned int pcl812_ai_get_sample(struct comedi_device *dev,\n\t\t\t\t\t struct comedi_subdevice *s)\n{\n\tunsigned int val;\n\n\tval = inb(dev->iobase + PCL812_AI_MSB_REG) << 8;\n\tval |= inb(dev->iobase + PCL812_AI_LSB_REG);\n\n\treturn val & s->maxdata;\n}\n\nstatic int pcl812_ai_eoc(struct comedi_device *dev,\n\t\t\t struct comedi_subdevice *s,\n\t\t\t struct comedi_insn *insn,\n\t\t\t unsigned long context)\n{\n\tunsigned int status;\n\n\tif (s->maxdata > 0x0fff) {\n\t\tstatus = inb(dev->iobase + PCL812_STATUS_REG);\n\t\tif ((status & PCL812_STATUS_DRDY) == 0)\n\t\t\treturn 0;\n\t} else {\n\t\tstatus = inb(dev->iobase + PCL812_AI_MSB_REG);\n\t\tif ((status & PCL812_AI_MSB_DRDY) == 0)\n\t\t\treturn 0;\n\t}\n\treturn -EBUSY;\n}\n\nstatic int pcl812_ai_cmdtest(struct comedi_device *dev,\n\t\t\t     struct comedi_subdevice *s, struct comedi_cmd *cmd)\n{\n\tconst struct pcl812_board *board = dev->board_ptr;\n\tstruct pcl812_private *devpriv = dev->private;\n\tint err = 0;\n\tunsigned int flags;\n\n\t \n\n\terr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW);\n\terr |= comedi_check_trigger_src(&cmd->scan_begin_src, TRIG_FOLLOW);\n\n\tif (devpriv->use_ext_trg)\n\t\tflags = TRIG_EXT;\n\telse\n\t\tflags = TRIG_TIMER;\n\terr |= comedi_check_trigger_src(&cmd->convert_src, flags);\n\n\terr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\n\terr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\n\n\tif (err)\n\t\treturn 1;\n\n\t \n\n\terr |= comedi_check_trigger_is_unique(cmd->stop_src);\n\n\t \n\n\tif (err)\n\t\treturn 2;\n\n\t \n\n\terr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);\n\n\tif (cmd->convert_src == TRIG_TIMER) {\n\t\terr |= comedi_check_trigger_arg_min(&cmd->convert_arg,\n\t\t\t\t\t\t    board->ai_ns_min);\n\t} else {\t \n\t\terr |= comedi_check_trigger_arg_is(&cmd->convert_arg, 0);\n\t}\n\n\terr |= comedi_check_trigger_arg_min(&cmd->chanlist_len, 1);\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\n\t\t\t\t\t   cmd->chanlist_len);\n\n\tif (cmd->stop_src == TRIG_COUNT)\n\t\terr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\n\telse\t \n\t\terr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\n\n\tif (err)\n\t\treturn 3;\n\n\t \n\n\tif (cmd->convert_src == TRIG_TIMER) {\n\t\tunsigned int arg = cmd->convert_arg;\n\n\t\tcomedi_8254_cascade_ns_to_timer(dev->pacer, &arg, cmd->flags);\n\t\terr |= comedi_check_trigger_arg_is(&cmd->convert_arg, arg);\n\t}\n\n\tif (err)\n\t\treturn 4;\n\n\treturn 0;\n}\n\nstatic int pcl812_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\n{\n\tstruct pcl812_private *devpriv = dev->private;\n\tstruct comedi_isadma *dma = devpriv->dma;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tunsigned int ctrl = 0;\n\tunsigned int i;\n\n\tpcl812_ai_set_chan_range(dev, cmd->chanlist[0], 1);\n\n\tif (dma) {\t \n\t\tdevpriv->ai_dma = 1;\n\t\tfor (i = 1; i < cmd->chanlist_len; i++)\n\t\t\tif (cmd->chanlist[0] != cmd->chanlist[i]) {\n\t\t\t\t \n\t\t\t\tdevpriv->ai_dma = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t} else {\n\t\tdevpriv->ai_dma = 0;\n\t}\n\n\tdevpriv->ai_poll_ptr = 0;\n\n\t \n\tif (cmd->flags & CMDF_WAKE_EOS) {\n\t\tdevpriv->ai_eos = 1;\n\n\t\t \n\t\tif (cmd->chanlist_len == 1)\n\t\t\tdevpriv->ai_dma = 0;\n\t}\n\n\tif (devpriv->ai_dma) {\n\t\t \n\t\tdma->cur_dma = 0;\n\t\tpcl812_ai_setup_dma(dev, s, 0);\n\t}\n\n\tswitch (cmd->convert_src) {\n\tcase TRIG_TIMER:\n\t\tcomedi_8254_update_divisors(dev->pacer);\n\t\tcomedi_8254_pacer_enable(dev->pacer, 1, 2, true);\n\t\tbreak;\n\t}\n\n\tif (devpriv->ai_dma)\n\t\tctrl |= PCL812_CTRL_PACER_DMA_TRIG;\n\telse\n\t\tctrl |= PCL812_CTRL_PACER_EOC_TRIG;\n\toutb(devpriv->mode_reg_int | ctrl, dev->iobase + PCL812_CTRL_REG);\n\n\treturn 0;\n}\n\nstatic bool pcl812_ai_next_chan(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s)\n{\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\n\tif (cmd->stop_src == TRIG_COUNT &&\n\t    s->async->scans_done >= cmd->stop_arg) {\n\t\ts->async->events |= COMEDI_CB_EOA;\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void pcl812_handle_eoc(struct comedi_device *dev,\n\t\t\t      struct comedi_subdevice *s)\n{\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tunsigned int chan = s->async->cur_chan;\n\tunsigned int next_chan;\n\tunsigned short val;\n\n\tif (pcl812_ai_eoc(dev, s, NULL, 0)) {\n\t\tdev_dbg(dev->class_dev, \"A/D cmd IRQ without DRDY!\\n\");\n\t\ts->async->events |= COMEDI_CB_ERROR;\n\t\treturn;\n\t}\n\n\tval = pcl812_ai_get_sample(dev, s);\n\tcomedi_buf_write_samples(s, &val, 1);\n\n\t \n\tnext_chan = s->async->cur_chan;\n\tif (cmd->chanlist[chan] != cmd->chanlist[next_chan])\n\t\tpcl812_ai_set_chan_range(dev, cmd->chanlist[next_chan], 0);\n\n\tpcl812_ai_next_chan(dev, s);\n}\n\nstatic void transfer_from_dma_buf(struct comedi_device *dev,\n\t\t\t\t  struct comedi_subdevice *s,\n\t\t\t\t  unsigned short *ptr,\n\t\t\t\t  unsigned int bufptr, unsigned int len)\n{\n\tunsigned int i;\n\tunsigned short val;\n\n\tfor (i = len; i; i--) {\n\t\tval = ptr[bufptr++];\n\t\tcomedi_buf_write_samples(s, &val, 1);\n\n\t\tif (!pcl812_ai_next_chan(dev, s))\n\t\t\tbreak;\n\t}\n}\n\nstatic void pcl812_handle_dma(struct comedi_device *dev,\n\t\t\t      struct comedi_subdevice *s)\n{\n\tstruct pcl812_private *devpriv = dev->private;\n\tstruct comedi_isadma *dma = devpriv->dma;\n\tstruct comedi_isadma_desc *desc = &dma->desc[dma->cur_dma];\n\tunsigned int nsamples;\n\tint bufptr;\n\n\tnsamples = comedi_bytes_to_samples(s, desc->size) -\n\t\t   devpriv->ai_poll_ptr;\n\tbufptr = devpriv->ai_poll_ptr;\n\tdevpriv->ai_poll_ptr = 0;\n\n\t \n\tdma->cur_dma = 1 - dma->cur_dma;\n\tpcl812_ai_setup_dma(dev, s, nsamples);\n\n\ttransfer_from_dma_buf(dev, s, desc->virt_addr, bufptr, nsamples);\n}\n\nstatic irqreturn_t pcl812_interrupt(int irq, void *d)\n{\n\tstruct comedi_device *dev = d;\n\tstruct comedi_subdevice *s = dev->read_subdev;\n\tstruct pcl812_private *devpriv = dev->private;\n\n\tif (!dev->attached) {\n\t\tpcl812_ai_clear_eoc(dev);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (devpriv->ai_dma)\n\t\tpcl812_handle_dma(dev, s);\n\telse\n\t\tpcl812_handle_eoc(dev, s);\n\n\tpcl812_ai_clear_eoc(dev);\n\n\tcomedi_handle_events(dev, s);\n\treturn IRQ_HANDLED;\n}\n\nstatic int pcl812_ai_poll(struct comedi_device *dev, struct comedi_subdevice *s)\n{\n\tstruct pcl812_private *devpriv = dev->private;\n\tstruct comedi_isadma *dma = devpriv->dma;\n\tstruct comedi_isadma_desc *desc;\n\tunsigned long flags;\n\tunsigned int poll;\n\tint ret;\n\n\t \n\tif (!devpriv->ai_dma)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&dev->spinlock, flags);\n\n\tpoll = comedi_isadma_poll(dma);\n\tpoll = comedi_bytes_to_samples(s, poll);\n\tif (poll > devpriv->ai_poll_ptr) {\n\t\tdesc = &dma->desc[dma->cur_dma];\n\t\ttransfer_from_dma_buf(dev, s, desc->virt_addr,\n\t\t\t\t      devpriv->ai_poll_ptr,\n\t\t\t\t      poll - devpriv->ai_poll_ptr);\n\t\t \n\t\tdevpriv->ai_poll_ptr = poll;\n\n\t\tret = comedi_buf_n_bytes_ready(s);\n\t} else {\n\t\t \n\t\tret = 0;\n\t}\n\n\tspin_unlock_irqrestore(&dev->spinlock, flags);\n\n\treturn ret;\n}\n\nstatic int pcl812_ai_cancel(struct comedi_device *dev,\n\t\t\t    struct comedi_subdevice *s)\n{\n\tstruct pcl812_private *devpriv = dev->private;\n\n\tif (devpriv->ai_dma)\n\t\tcomedi_isadma_disable(devpriv->dma->chan);\n\n\toutb(devpriv->mode_reg_int | PCL812_CTRL_DISABLE_TRIG,\n\t     dev->iobase + PCL812_CTRL_REG);\n\tcomedi_8254_pacer_enable(dev->pacer, 1, 2, false);\n\tpcl812_ai_clear_eoc(dev);\n\treturn 0;\n}\n\nstatic int pcl812_ai_insn_read(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       struct comedi_insn *insn,\n\t\t\t       unsigned int *data)\n{\n\tstruct pcl812_private *devpriv = dev->private;\n\tint ret = 0;\n\tint i;\n\n\toutb(devpriv->mode_reg_int | PCL812_CTRL_SOFT_TRIG,\n\t     dev->iobase + PCL812_CTRL_REG);\n\n\tpcl812_ai_set_chan_range(dev, insn->chanspec, 1);\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\tpcl812_ai_clear_eoc(dev);\n\t\tpcl812_ai_soft_trig(dev);\n\n\t\tret = comedi_timeout(dev, s, insn, pcl812_ai_eoc, 0);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tdata[i] = pcl812_ai_get_sample(dev, s);\n\t}\n\toutb(devpriv->mode_reg_int | PCL812_CTRL_DISABLE_TRIG,\n\t     dev->iobase + PCL812_CTRL_REG);\n\tpcl812_ai_clear_eoc(dev);\n\n\treturn ret ? ret : insn->n;\n}\n\nstatic int pcl812_ao_insn_write(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tstruct comedi_insn *insn,\n\t\t\t\tunsigned int *data)\n{\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int val = s->readback[chan];\n\tint i;\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\tval = data[i];\n\t\toutb(val & 0xff, dev->iobase + PCL812_AO_LSB_REG(chan));\n\t\toutb((val >> 8) & 0x0f, dev->iobase + PCL812_AO_MSB_REG(chan));\n\t}\n\ts->readback[chan] = val;\n\n\treturn insn->n;\n}\n\nstatic int pcl812_di_insn_bits(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       struct comedi_insn *insn,\n\t\t\t       unsigned int *data)\n{\n\tdata[1] = inb(dev->iobase + PCL812_DI_LSB_REG) |\n\t\t  (inb(dev->iobase + PCL812_DI_MSB_REG) << 8);\n\n\treturn insn->n;\n}\n\nstatic int pcl812_do_insn_bits(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       struct comedi_insn *insn,\n\t\t\t       unsigned int *data)\n{\n\tif (comedi_dio_update_state(s, data)) {\n\t\toutb(s->state & 0xff, dev->iobase + PCL812_DO_LSB_REG);\n\t\toutb((s->state >> 8), dev->iobase + PCL812_DO_MSB_REG);\n\t}\n\n\tdata[1] = s->state;\n\n\treturn insn->n;\n}\n\nstatic void pcl812_reset(struct comedi_device *dev)\n{\n\tconst struct pcl812_board *board = dev->board_ptr;\n\tstruct pcl812_private *devpriv = dev->private;\n\tunsigned int chan;\n\n\t \n\toutb(devpriv->mode_reg_int | PCL812_CTRL_DISABLE_TRIG,\n\t     dev->iobase + PCL812_CTRL_REG);\n\tpcl812_ai_clear_eoc(dev);\n\n\t \n\tdevpriv->last_ai_chanspec = CR_PACK(16, 0, 0);\n\tpcl812_ai_set_chan_range(dev, CR_PACK(0, 0, 0), 0);\n\n\t \n\tfor (chan = 0; chan < board->n_aochan; chan++) {\n\t\toutb(0, dev->iobase + PCL812_AO_LSB_REG(chan));\n\t\toutb(0, dev->iobase + PCL812_AO_MSB_REG(chan));\n\t}\n\n\t \n\tif (board->has_dio) {\n\t\toutb(0, dev->iobase + PCL812_DO_MSB_REG);\n\t\toutb(0, dev->iobase + PCL812_DO_LSB_REG);\n\t}\n}\n\nstatic void pcl812_set_ai_range_table(struct comedi_device *dev,\n\t\t\t\t      struct comedi_subdevice *s,\n\t\t\t\t      struct comedi_devconfig *it)\n{\n\tconst struct pcl812_board *board = dev->board_ptr;\n\tstruct pcl812_private *devpriv = dev->private;\n\n\tswitch (board->board_type) {\n\tcase BOARD_PCL812PG:\n\t\tif (it->options[4] == 1)\n\t\t\ts->range_table = &range_pcl812pg2_ai;\n\t\telse\n\t\t\ts->range_table = board->rangelist_ai;\n\t\tbreak;\n\tcase BOARD_PCL812:\n\t\tswitch (it->options[4]) {\n\t\tcase 0:\n\t\t\ts->range_table = &range_bipolar10;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\ts->range_table = &range_bipolar5;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\ts->range_table = &range_bipolar2_5;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\ts->range_table = &range812_bipolar1_25;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\ts->range_table = &range812_bipolar0_625;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\ts->range_table = &range812_bipolar0_3125;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ts->range_table = &range_bipolar10;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase BOARD_PCL813B:\n\t\tif (it->options[1] == 1)\n\t\t\ts->range_table = &range_pcl813b2_ai;\n\t\telse\n\t\t\ts->range_table = board->rangelist_ai;\n\t\tbreak;\n\tcase BOARD_ISO813:\n\t\tswitch (it->options[1]) {\n\t\tcase 0:\n\t\t\ts->range_table = &range_iso813_1_ai;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\ts->range_table = &range_iso813_1_2_ai;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\ts->range_table = &range_iso813_2_ai;\n\t\t\tdevpriv->range_correction = 1;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\ts->range_table = &range_iso813_2_2_ai;\n\t\t\tdevpriv->range_correction = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ts->range_table = &range_iso813_1_ai;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase BOARD_ACL8113:\n\t\tswitch (it->options[1]) {\n\t\tcase 0:\n\t\t\ts->range_table = &range_acl8113_1_ai;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\ts->range_table = &range_acl8113_1_2_ai;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\ts->range_table = &range_acl8113_2_ai;\n\t\t\tdevpriv->range_correction = 1;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\ts->range_table = &range_acl8113_2_2_ai;\n\t\t\tdevpriv->range_correction = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ts->range_table = &range_acl8113_1_ai;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\ts->range_table = board->rangelist_ai;\n\t\tbreak;\n\t}\n}\n\nstatic void pcl812_alloc_dma(struct comedi_device *dev, unsigned int dma_chan)\n{\n\tstruct pcl812_private *devpriv = dev->private;\n\n\t \n\tif (!(dma_chan == 3 || dma_chan == 1))\n\t\treturn;\n\n\t \n\tdevpriv->dma = comedi_isadma_alloc(dev, 2, dma_chan, dma_chan,\n\t\t\t\t\t   PAGE_SIZE * 2, COMEDI_ISADMA_READ);\n}\n\nstatic void pcl812_free_dma(struct comedi_device *dev)\n{\n\tstruct pcl812_private *devpriv = dev->private;\n\n\tif (devpriv)\n\t\tcomedi_isadma_free(devpriv->dma);\n}\n\nstatic int pcl812_attach(struct comedi_device *dev, struct comedi_devconfig *it)\n{\n\tconst struct pcl812_board *board = dev->board_ptr;\n\tstruct pcl812_private *devpriv;\n\tstruct comedi_subdevice *s;\n\tint n_subdevices;\n\tint subdev;\n\tint ret;\n\n\tdevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\n\tif (!devpriv)\n\t\treturn -ENOMEM;\n\n\tret = comedi_request_region(dev, it->options[0], 0x10);\n\tif (ret)\n\t\treturn ret;\n\n\tif (board->irq_bits) {\n\t\tdev->pacer = comedi_8254_init(dev->iobase + PCL812_TIMER_BASE,\n\t\t\t\t\t      I8254_OSC_BASE_2MHZ,\n\t\t\t\t\t      I8254_IO8, 0);\n\t\tif (!dev->pacer)\n\t\t\treturn -ENOMEM;\n\n\t\tif ((1 << it->options[1]) & board->irq_bits) {\n\t\t\tret = request_irq(it->options[1], pcl812_interrupt, 0,\n\t\t\t\t\t  dev->board_name, dev);\n\t\t\tif (ret == 0)\n\t\t\t\tdev->irq = it->options[1];\n\t\t}\n\t}\n\n\t \n\tif (dev->irq && board->has_dma)\n\t\tpcl812_alloc_dma(dev, it->options[2]);\n\n\t \n\tswitch (board->board_type) {\n\tcase BOARD_A821:\n\t\tif (it->options[2] == 1)\n\t\t\tdevpriv->use_diff = 1;\n\t\tbreak;\n\tcase BOARD_ACL8112:\n\tcase BOARD_ACL8216:\n\t\tif (it->options[4] == 1)\n\t\t\tdevpriv->use_diff = 1;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tn_subdevices = 1;\t\t \n\tif (board->n_aochan > 0)\n\t\tn_subdevices++;\n\tif (board->has_dio)\n\t\tn_subdevices += 2;\n\n\tret = comedi_alloc_subdevices(dev, n_subdevices);\n\tif (ret)\n\t\treturn ret;\n\n\tsubdev = 0;\n\n\t \n\ts = &dev->subdevices[subdev];\n\ts->type\t\t= COMEDI_SUBD_AI;\n\ts->subdev_flags\t= SDF_READABLE;\n\tif (devpriv->use_diff) {\n\t\ts->subdev_flags\t|= SDF_DIFF;\n\t\ts->n_chan\t= board->n_aichan / 2;\n\t} else {\n\t\ts->subdev_flags\t|= SDF_GROUND;\n\t\ts->n_chan\t= board->n_aichan;\n\t}\n\ts->maxdata\t= board->has_16bit_ai ? 0xffff : 0x0fff;\n\n\tpcl812_set_ai_range_table(dev, s, it);\n\n\ts->insn_read\t= pcl812_ai_insn_read;\n\n\tif (dev->irq) {\n\t\tdev->read_subdev = s;\n\t\ts->subdev_flags\t|= SDF_CMD_READ;\n\t\ts->len_chanlist\t= MAX_CHANLIST_LEN;\n\t\ts->do_cmdtest\t= pcl812_ai_cmdtest;\n\t\ts->do_cmd\t= pcl812_ai_cmd;\n\t\ts->poll\t\t= pcl812_ai_poll;\n\t\ts->cancel\t= pcl812_ai_cancel;\n\t}\n\n\tdevpriv->use_mpc508 = board->has_mpc508_mux;\n\n\tsubdev++;\n\n\t \n\tif (board->n_aochan > 0) {\n\t\ts = &dev->subdevices[subdev];\n\t\ts->type\t\t= COMEDI_SUBD_AO;\n\t\ts->subdev_flags\t= SDF_WRITABLE | SDF_GROUND;\n\t\ts->n_chan\t= board->n_aochan;\n\t\ts->maxdata\t= 0xfff;\n\t\tswitch (board->board_type) {\n\t\tcase BOARD_A821:\n\t\t\tif (it->options[3] == 1)\n\t\t\t\ts->range_table = &range_unipolar10;\n\t\t\telse\n\t\t\t\ts->range_table = &range_unipolar5;\n\t\t\tbreak;\n\t\tcase BOARD_PCL812:\n\t\tcase BOARD_ACL8112:\n\t\tcase BOARD_PCL812PG:\n\t\tcase BOARD_ACL8216:\n\t\t\tswitch (it->options[5]) {\n\t\t\tcase 1:\n\t\t\t\ts->range_table = &range_unipolar10;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\ts->range_table = &range_unknown;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ts->range_table = &range_unipolar5;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ts->range_table = &range_unipolar5;\n\t\t\tbreak;\n\t\t}\n\t\ts->insn_write\t= pcl812_ao_insn_write;\n\n\t\tret = comedi_alloc_subdev_readback(s);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tsubdev++;\n\t}\n\n\tif (board->has_dio) {\n\t\t \n\t\ts = &dev->subdevices[subdev];\n\t\ts->type\t\t= COMEDI_SUBD_DI;\n\t\ts->subdev_flags\t= SDF_READABLE;\n\t\ts->n_chan\t= 16;\n\t\ts->maxdata\t= 1;\n\t\ts->range_table\t= &range_digital;\n\t\ts->insn_bits\t= pcl812_di_insn_bits;\n\t\tsubdev++;\n\n\t\t \n\t\ts = &dev->subdevices[subdev];\n\t\ts->type\t\t= COMEDI_SUBD_DO;\n\t\ts->subdev_flags\t= SDF_WRITABLE;\n\t\ts->n_chan\t= 16;\n\t\ts->maxdata\t= 1;\n\t\ts->range_table\t= &range_digital;\n\t\ts->insn_bits\t= pcl812_do_insn_bits;\n\t\tsubdev++;\n\t}\n\n\tswitch (board->board_type) {\n\tcase BOARD_ACL8216:\n\tcase BOARD_PCL812PG:\n\tcase BOARD_PCL812:\n\tcase BOARD_ACL8112:\n\t\tdevpriv->max_812_ai_mode0_rangewait = 1;\n\t\tif (it->options[3] > 0)\n\t\t\t\t\t\t \n\t\t\tdevpriv->use_ext_trg = 1;\n\t\tbreak;\n\tcase BOARD_A821:\n\t\tdevpriv->max_812_ai_mode0_rangewait = 1;\n\t\tdevpriv->mode_reg_int = (dev->irq << 4) & 0xf0;\n\t\tbreak;\n\tcase BOARD_PCL813B:\n\tcase BOARD_PCL813:\n\tcase BOARD_ISO813:\n\tcase BOARD_ACL8113:\n\t\t \n\t\tdevpriv->max_812_ai_mode0_rangewait = 5;\n\t\tbreak;\n\t}\n\n\tpcl812_reset(dev);\n\n\treturn 0;\n}\n\nstatic void pcl812_detach(struct comedi_device *dev)\n{\n\tpcl812_free_dma(dev);\n\tcomedi_legacy_detach(dev);\n}\n\nstatic struct comedi_driver pcl812_driver = {\n\t.driver_name\t= \"pcl812\",\n\t.module\t\t= THIS_MODULE,\n\t.attach\t\t= pcl812_attach,\n\t.detach\t\t= pcl812_detach,\n\t.board_name\t= &boardtypes[0].name,\n\t.num_names\t= ARRAY_SIZE(boardtypes),\n\t.offset\t\t= sizeof(struct pcl812_board),\n};\nmodule_comedi_driver(pcl812_driver);\n\nMODULE_AUTHOR(\"Comedi https://www.comedi.org\");\nMODULE_DESCRIPTION(\"Comedi low-level driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}