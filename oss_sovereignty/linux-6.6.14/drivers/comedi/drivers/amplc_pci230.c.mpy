{
  "module_name": "amplc_pci230.c",
  "hash_id": "278aa94542ad47777ebe57e1e65f5360f11e633115a944ad81bfeceaef9c4a5d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/amplc_pci230.c",
  "human_readable_source": "\n \n\n \n\n \n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/comedi/comedi_pci.h>\n#include <linux/comedi/comedi_8255.h>\n#include <linux/comedi/comedi_8254.h>\n\n \n#define PCI_DEVICE_ID_PCI230 0x0000\n#define PCI_DEVICE_ID_PCI260 0x0006\n\n \n#define PCI230_PPI_X_BASE\t0x00\t \n#define PCI230_PPI_X_A\t\t0x00\t \n#define PCI230_PPI_X_B\t\t0x01\t \n#define PCI230_PPI_X_C\t\t0x02\t \n#define PCI230_PPI_X_CMD\t0x03\t \n#define PCI230_Z2_CT_BASE\t0x14\t \n#define PCI230_ZCLK_SCE\t\t0x1A\t \n#define PCI230_ZGAT_SCE\t\t0x1D\t \n#define PCI230_INT_SCE\t\t0x1E\t \n#define PCI230_INT_STAT\t\t0x1E\t \n\n \n#define PCI230_DACCON\t\t0x00\t \n#define PCI230_DACOUT1\t\t0x02\t \n#define PCI230_DACOUT2\t\t0x04\t \n#define PCI230_ADCDATA\t\t0x08\t \n#define PCI230_ADCSWTRIG\t0x08\t \n#define PCI230_ADCCON\t\t0x0A\t \n#define PCI230_ADCEN\t\t0x0C\t \n#define PCI230_ADCG\t\t0x0E\t \n \n#define PCI230P_ADCTRIG\t\t0x10\t \n#define PCI230P_ADCTH\t\t0x12\t \n#define PCI230P_ADCFFTH\t\t0x14\t \n#define PCI230P_ADCFFLEV\t0x16\t \n#define PCI230P_ADCPTSC\t\t0x18\t \n#define PCI230P_ADCHYST\t\t0x1A\t \n#define PCI230P_EXTFUNC\t\t0x1C\t \n#define PCI230P_HWVER\t\t0x1E\t \n \n#define PCI230P2_DACDATA\t0x02\t \n#define PCI230P2_DACSWTRIG\t0x02\t \n#define PCI230P2_DACEN\t\t0x06\t \n\n \n#define PCI230_DAC_OR(x)\t\t(((x) & 0x1) << 0)\n#define PCI230_DAC_OR_UNI\t\tPCI230_DAC_OR(0)  \n#define PCI230_DAC_OR_BIP\t\tPCI230_DAC_OR(1)  \n#define PCI230_DAC_OR_MASK\t\tPCI230_DAC_OR(1)\n \n#define PCI230P2_DAC_FIFO_EN\t\tBIT(8)  \n \n#define PCI230P2_DAC_TRIG(x)\t\t(((x) & 0x7) << 2)\n#define PCI230P2_DAC_TRIG_NONE\t\tPCI230P2_DAC_TRIG(0)  \n#define PCI230P2_DAC_TRIG_SW\t\tPCI230P2_DAC_TRIG(1)  \n#define PCI230P2_DAC_TRIG_EXTP\t\tPCI230P2_DAC_TRIG(2)  \n#define PCI230P2_DAC_TRIG_EXTN\t\tPCI230P2_DAC_TRIG(3)  \n#define PCI230P2_DAC_TRIG_Z2CT0\t\tPCI230P2_DAC_TRIG(4)  \n#define PCI230P2_DAC_TRIG_Z2CT1\t\tPCI230P2_DAC_TRIG(5)  \n#define PCI230P2_DAC_TRIG_Z2CT2\t\tPCI230P2_DAC_TRIG(6)  \n#define PCI230P2_DAC_TRIG_MASK\t\tPCI230P2_DAC_TRIG(7)\n#define PCI230P2_DAC_FIFO_WRAP\t\tBIT(7)  \n#define PCI230P2_DAC_INT_FIFO(x)\t(((x) & 7) << 9)\n#define PCI230P2_DAC_INT_FIFO_EMPTY\tPCI230P2_DAC_INT_FIFO(0)  \n#define PCI230P2_DAC_INT_FIFO_NEMPTY\tPCI230P2_DAC_INT_FIFO(1)  \n#define PCI230P2_DAC_INT_FIFO_NHALF\tPCI230P2_DAC_INT_FIFO(2)  \n#define PCI230P2_DAC_INT_FIFO_HALF\tPCI230P2_DAC_INT_FIFO(3)  \n#define PCI230P2_DAC_INT_FIFO_NFULL\tPCI230P2_DAC_INT_FIFO(4)  \n#define PCI230P2_DAC_INT_FIFO_FULL\tPCI230P2_DAC_INT_FIFO(5)  \n#define PCI230P2_DAC_INT_FIFO_MASK\tPCI230P2_DAC_INT_FIFO(7)\n\n \n#define PCI230_DAC_BUSY\t\t\tBIT(1)  \n \n#define PCI230P2_DAC_FIFO_UNDERRUN_LATCHED\tBIT(5)  \n#define PCI230P2_DAC_FIFO_EMPTY\t\tBIT(13)  \n#define PCI230P2_DAC_FIFO_FULL\t\tBIT(14)  \n#define PCI230P2_DAC_FIFO_HALF\t\tBIT(15)  \n\n \n \n#define PCI230P2_DAC_FIFO_UNDERRUN_CLEAR\tBIT(5)  \n#define PCI230P2_DAC_FIFO_RESET\t\tBIT(12)  \n\n \n#define PCI230P2_DAC_FIFOLEVEL_HALF\t512\n#define PCI230P2_DAC_FIFOLEVEL_FULL\t1024\n \n#define PCI230P2_DAC_FIFOROOM_EMPTY\t\tPCI230P2_DAC_FIFOLEVEL_FULL\n#define PCI230P2_DAC_FIFOROOM_ONETOHALF\t\t\\\n\t(PCI230P2_DAC_FIFOLEVEL_FULL - PCI230P2_DAC_FIFOLEVEL_HALF)\n#define PCI230P2_DAC_FIFOROOM_HALFTOFULL\t1\n#define PCI230P2_DAC_FIFOROOM_FULL\t\t0\n\n \n#define PCI230_ADC_TRIG(x)\t\t(((x) & 0x7) << 0)\n#define PCI230_ADC_TRIG_NONE\t\tPCI230_ADC_TRIG(0)  \n#define PCI230_ADC_TRIG_SW\t\tPCI230_ADC_TRIG(1)  \n#define PCI230_ADC_TRIG_EXTP\t\tPCI230_ADC_TRIG(2)  \n#define PCI230_ADC_TRIG_EXTN\t\tPCI230_ADC_TRIG(3)  \n#define PCI230_ADC_TRIG_Z2CT0\t\tPCI230_ADC_TRIG(4)  \n#define PCI230_ADC_TRIG_Z2CT1\t\tPCI230_ADC_TRIG(5)  \n#define PCI230_ADC_TRIG_Z2CT2\t\tPCI230_ADC_TRIG(6)  \n#define PCI230_ADC_TRIG_MASK\t\tPCI230_ADC_TRIG(7)\n#define PCI230_ADC_IR(x)\t\t(((x) & 0x1) << 3)\n#define PCI230_ADC_IR_UNI\t\tPCI230_ADC_IR(0)  \n#define PCI230_ADC_IR_BIP\t\tPCI230_ADC_IR(1)  \n#define PCI230_ADC_IR_MASK\t\tPCI230_ADC_IR(1)\n#define PCI230_ADC_IM(x)\t\t(((x) & 0x1) << 4)\n#define PCI230_ADC_IM_SE\t\tPCI230_ADC_IM(0)  \n#define PCI230_ADC_IM_DIF\t\tPCI230_ADC_IM(1)  \n#define PCI230_ADC_IM_MASK\t\tPCI230_ADC_IM(1)\n#define PCI230_ADC_FIFO_EN\t\tBIT(8)  \n#define PCI230_ADC_INT_FIFO(x)\t\t(((x) & 0x7) << 9)\n#define PCI230_ADC_INT_FIFO_EMPTY\tPCI230_ADC_INT_FIFO(0)  \n#define PCI230_ADC_INT_FIFO_NEMPTY\tPCI230_ADC_INT_FIFO(1)  \n#define PCI230_ADC_INT_FIFO_NHALF\tPCI230_ADC_INT_FIFO(2)  \n#define PCI230_ADC_INT_FIFO_HALF\tPCI230_ADC_INT_FIFO(3)  \n#define PCI230_ADC_INT_FIFO_NFULL\tPCI230_ADC_INT_FIFO(4)  \n#define PCI230_ADC_INT_FIFO_FULL\tPCI230_ADC_INT_FIFO(5)  \n#define PCI230P_ADC_INT_FIFO_THRESH\tPCI230_ADC_INT_FIFO(7)  \n#define PCI230_ADC_INT_FIFO_MASK\tPCI230_ADC_INT_FIFO(7)\n\n \n#define PCI230_ADC_FIFO_RESET\t\tBIT(12)  \n#define PCI230_ADC_GLOB_RESET\t\tBIT(13)  \n\n \n#define PCI230_ADC_BUSY\t\t\tBIT(15)  \n#define PCI230_ADC_FIFO_EMPTY\t\tBIT(12)  \n#define PCI230_ADC_FIFO_FULL\t\tBIT(13)  \n#define PCI230_ADC_FIFO_HALF\t\tBIT(14)  \n#define PCI230_ADC_FIFO_FULL_LATCHED\tBIT(5)   \n\n \n#define PCI230_ADC_FIFOLEVEL_HALFFULL\t2049\t \n#define PCI230_ADC_FIFOLEVEL_FULL\t4096\t \n\n \n \n#define PCI230P_EXTFUNC_GAT_EXTTRIG\tBIT(0)\n \n \n#define PCI230P2_EXTFUNC_DACFIFO\tBIT(1)\n\n \n#define CLK_CLK\t\t0\t \n#define CLK_10MHZ\t1\t \n#define CLK_1MHZ\t2\t \n#define CLK_100KHZ\t3\t \n#define CLK_10KHZ\t4\t \n#define CLK_1KHZ\t5\t \n#define CLK_OUTNM1\t6\t \n#define CLK_EXT\t\t7\t \n\nstatic unsigned int pci230_clk_config(unsigned int chan, unsigned int src)\n{\n\treturn ((chan & 3) << 3) | (src & 7);\n}\n\n \n#define GAT_VCC\t\t0\t \n#define GAT_GND\t\t1\t \n#define GAT_EXT\t\t2\t \n#define GAT_NOUTNM2\t3\t \n\nstatic unsigned int pci230_gat_config(unsigned int chan, unsigned int src)\n{\n\treturn ((chan & 3) << 3) | (src & 7);\n}\n\n \n\n \n#define PCI230_INT_DISABLE\t\t0\n#define PCI230_INT_PPI_C0\t\tBIT(0)\n#define PCI230_INT_PPI_C3\t\tBIT(1)\n#define PCI230_INT_ADC\t\t\tBIT(2)\n#define PCI230_INT_ZCLK_CT1\t\tBIT(5)\n \n#define PCI230P2_INT_DAC\t\tBIT(4)\n\n \nenum {\n\tRES_Z2CT0 = BIT(0),\t \n\tRES_Z2CT1 = BIT(1),\t \n\tRES_Z2CT2 = BIT(2)\t \n};\n\nenum {\n\tOWNER_AICMD,\t\t \n\tOWNER_AOCMD,\t\t \n\tNUM_OWNERS\t\t \n};\n\n \n\n \n#define COMBINE(old, new, mask)\t(((old) & ~(mask)) | ((new) & (mask)))\n\n \n#define THISCPU\t\tsmp_processor_id()\n\n \n\nstruct pci230_board {\n\tconst char *name;\n\tunsigned short id;\n\tunsigned char ai_bits;\n\tunsigned char ao_bits;\n\tunsigned char min_hwver;  \n\tunsigned int have_dio:1;\n};\n\nstatic const struct pci230_board pci230_boards[] = {\n\t{\n\t\t.name\t\t= \"pci230+\",\n\t\t.id\t\t= PCI_DEVICE_ID_PCI230,\n\t\t.ai_bits\t= 16,\n\t\t.ao_bits\t= 12,\n\t\t.have_dio\t= true,\n\t\t.min_hwver\t= 1,\n\t},\n\t{\n\t\t.name\t\t= \"pci260+\",\n\t\t.id\t\t= PCI_DEVICE_ID_PCI260,\n\t\t.ai_bits\t= 16,\n\t\t.min_hwver\t= 1,\n\t},\n\t{\n\t\t.name\t\t= \"pci230\",\n\t\t.id\t\t= PCI_DEVICE_ID_PCI230,\n\t\t.ai_bits\t= 12,\n\t\t.ao_bits\t= 12,\n\t\t.have_dio\t= true,\n\t},\n\t{\n\t\t.name\t\t= \"pci260\",\n\t\t.id\t\t= PCI_DEVICE_ID_PCI260,\n\t\t.ai_bits\t= 12,\n\t},\n};\n\nstruct pci230_private {\n\tspinlock_t isr_spinlock;\t \n\tspinlock_t res_spinlock;\t \n\tspinlock_t ai_stop_spinlock;\t \n\tspinlock_t ao_stop_spinlock;\t \n\tunsigned long daqio;\t\t \n\tint intr_cpuid;\t\t\t \n\tunsigned short hwver;\t\t \n\tunsigned short adccon;\t\t \n\tunsigned short daccon;\t\t \n\tunsigned short adcfifothresh;\t \n\tunsigned short adcg;\t\t \n\tunsigned char ier;\t\t \n\tunsigned char res_owned[NUM_OWNERS];  \n\tunsigned int intr_running:1;\t \n\tunsigned int ai_bipolar:1;\t \n\tunsigned int ao_bipolar:1;\t \n\tunsigned int ai_cmd_started:1;\t \n\tunsigned int ao_cmd_started:1;\t \n};\n\n \nstatic const unsigned int pci230_timebase[8] = {\n\t[CLK_10MHZ]\t= I8254_OSC_BASE_10MHZ,\n\t[CLK_1MHZ]\t= I8254_OSC_BASE_1MHZ,\n\t[CLK_100KHZ]\t= I8254_OSC_BASE_100KHZ,\n\t[CLK_10KHZ]\t= I8254_OSC_BASE_10KHZ,\n\t[CLK_1KHZ]\t= I8254_OSC_BASE_1KHZ,\n};\n\n \nstatic const struct comedi_lrange pci230_ai_range = {\n\t7, {\n\t\tBIP_RANGE(10),\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(2.5),\n\t\tBIP_RANGE(1.25),\n\t\tUNI_RANGE(10),\n\t\tUNI_RANGE(5),\n\t\tUNI_RANGE(2.5)\n\t}\n};\n\n \nstatic const unsigned char pci230_ai_gain[7] = { 0, 1, 2, 3, 1, 2, 3 };\n\n \nstatic const struct comedi_lrange pci230_ao_range = {\n\t2, {\n\t\tUNI_RANGE(10),\n\t\tBIP_RANGE(10)\n\t}\n};\n\nstatic unsigned short pci230_ai_read(struct comedi_device *dev)\n{\n\tconst struct pci230_board *board = dev->board_ptr;\n\tstruct pci230_private *devpriv = dev->private;\n\tunsigned short data;\n\n\t \n\tdata = inw(devpriv->daqio + PCI230_ADCDATA);\n\t \n\tif (devpriv->ai_bipolar)\n\t\tdata ^= 0x8000;\n\tdata >>= (16 - board->ai_bits);\n\treturn data;\n}\n\nstatic unsigned short pci230_ao_mangle_datum(struct comedi_device *dev,\n\t\t\t\t\t     unsigned short datum)\n{\n\tconst struct pci230_board *board = dev->board_ptr;\n\tstruct pci230_private *devpriv = dev->private;\n\n\t \n\tdatum <<= (16 - board->ao_bits);\n\t \n\tif (devpriv->ao_bipolar)\n\t\tdatum ^= 0x8000;\n\treturn datum;\n}\n\nstatic void pci230_ao_write_nofifo(struct comedi_device *dev,\n\t\t\t\t   unsigned short datum, unsigned int chan)\n{\n\tstruct pci230_private *devpriv = dev->private;\n\n\t \n\toutw(pci230_ao_mangle_datum(dev, datum),\n\t     devpriv->daqio + ((chan == 0) ? PCI230_DACOUT1 : PCI230_DACOUT2));\n}\n\nstatic void pci230_ao_write_fifo(struct comedi_device *dev,\n\t\t\t\t unsigned short datum, unsigned int chan)\n{\n\tstruct pci230_private *devpriv = dev->private;\n\n\t \n\toutw(pci230_ao_mangle_datum(dev, datum),\n\t     devpriv->daqio + PCI230P2_DACDATA);\n}\n\nstatic bool pci230_claim_shared(struct comedi_device *dev,\n\t\t\t\tunsigned char res_mask, unsigned int owner)\n{\n\tstruct pci230_private *devpriv = dev->private;\n\tunsigned int o;\n\tunsigned long irqflags;\n\n\tspin_lock_irqsave(&devpriv->res_spinlock, irqflags);\n\tfor (o = 0; o < NUM_OWNERS; o++) {\n\t\tif (o == owner)\n\t\t\tcontinue;\n\t\tif (devpriv->res_owned[o] & res_mask) {\n\t\t\tspin_unlock_irqrestore(&devpriv->res_spinlock,\n\t\t\t\t\t       irqflags);\n\t\t\treturn false;\n\t\t}\n\t}\n\tdevpriv->res_owned[owner] |= res_mask;\n\tspin_unlock_irqrestore(&devpriv->res_spinlock, irqflags);\n\treturn true;\n}\n\nstatic void pci230_release_shared(struct comedi_device *dev,\n\t\t\t\t  unsigned char res_mask, unsigned int owner)\n{\n\tstruct pci230_private *devpriv = dev->private;\n\tunsigned long irqflags;\n\n\tspin_lock_irqsave(&devpriv->res_spinlock, irqflags);\n\tdevpriv->res_owned[owner] &= ~res_mask;\n\tspin_unlock_irqrestore(&devpriv->res_spinlock, irqflags);\n}\n\nstatic void pci230_release_all_resources(struct comedi_device *dev,\n\t\t\t\t\t unsigned int owner)\n{\n\tpci230_release_shared(dev, (unsigned char)~0, owner);\n}\n\nstatic unsigned int pci230_divide_ns(u64 ns, unsigned int timebase,\n\t\t\t\t     unsigned int flags)\n{\n\tu64 div;\n\tunsigned int rem;\n\n\tdiv = ns;\n\trem = do_div(div, timebase);\n\tswitch (flags & CMDF_ROUND_MASK) {\n\tdefault:\n\tcase CMDF_ROUND_NEAREST:\n\t\tdiv += DIV_ROUND_CLOSEST(rem, timebase);\n\t\tbreak;\n\tcase CMDF_ROUND_DOWN:\n\t\tbreak;\n\tcase CMDF_ROUND_UP:\n\t\tdiv += DIV_ROUND_UP(rem, timebase);\n\t\tbreak;\n\t}\n\treturn div > UINT_MAX ? UINT_MAX : (unsigned int)div;\n}\n\n \nstatic unsigned int pci230_choose_clk_count(u64 ns, unsigned int *count,\n\t\t\t\t\t    unsigned int flags)\n{\n\tunsigned int clk_src, cnt;\n\n\tfor (clk_src = CLK_10MHZ;; clk_src++) {\n\t\tcnt = pci230_divide_ns(ns, pci230_timebase[clk_src], flags);\n\t\tif (cnt <= 65536 || clk_src == CLK_1KHZ)\n\t\t\tbreak;\n\t}\n\t*count = cnt;\n\treturn clk_src;\n}\n\nstatic void pci230_ns_to_single_timer(unsigned int *ns, unsigned int flags)\n{\n\tunsigned int count;\n\tunsigned int clk_src;\n\n\tclk_src = pci230_choose_clk_count(*ns, &count, flags);\n\t*ns = count * pci230_timebase[clk_src];\n}\n\nstatic void pci230_ct_setup_ns_mode(struct comedi_device *dev, unsigned int ct,\n\t\t\t\t    unsigned int mode, u64 ns,\n\t\t\t\t    unsigned int flags)\n{\n\tunsigned int clk_src;\n\tunsigned int count;\n\n\t \n\tcomedi_8254_set_mode(dev->pacer, ct, mode);\n\t \n\tclk_src = pci230_choose_clk_count(ns, &count, flags);\n\t \n\toutb(pci230_clk_config(ct, clk_src), dev->iobase + PCI230_ZCLK_SCE);\n\t \n\tif (count >= 65536)\n\t\tcount = 0;\n\n\tcomedi_8254_write(dev->pacer, ct, count);\n}\n\nstatic void pci230_cancel_ct(struct comedi_device *dev, unsigned int ct)\n{\n\t \n\tcomedi_8254_set_mode(dev->pacer, ct, I8254_MODE1);\n}\n\nstatic int pci230_ai_eoc(struct comedi_device *dev,\n\t\t\t struct comedi_subdevice *s,\n\t\t\t struct comedi_insn *insn,\n\t\t\t unsigned long context)\n{\n\tstruct pci230_private *devpriv = dev->private;\n\tunsigned int status;\n\n\tstatus = inw(devpriv->daqio + PCI230_ADCCON);\n\tif ((status & PCI230_ADC_FIFO_EMPTY) == 0)\n\t\treturn 0;\n\treturn -EBUSY;\n}\n\nstatic int pci230_ai_insn_read(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       struct comedi_insn *insn, unsigned int *data)\n{\n\tstruct pci230_private *devpriv = dev->private;\n\tunsigned int n;\n\tunsigned int chan, range, aref;\n\tunsigned int gainshift;\n\tunsigned short adccon, adcen;\n\tint ret;\n\n\t \n\tchan = CR_CHAN(insn->chanspec);\n\trange = CR_RANGE(insn->chanspec);\n\taref = CR_AREF(insn->chanspec);\n\tif (aref == AREF_DIFF) {\n\t\t \n\t\tif (chan >= s->n_chan / 2) {\n\t\t\tdev_dbg(dev->class_dev,\n\t\t\t\t\"%s: differential channel number out of range 0 to %u\\n\",\n\t\t\t\t__func__, (s->n_chan / 2) - 1);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tadccon = PCI230_ADC_TRIG_Z2CT2 | PCI230_ADC_FIFO_EN;\n\t \n\tcomedi_8254_set_mode(dev->pacer, 2, I8254_MODE0);\n\tdevpriv->ai_bipolar = comedi_range_is_bipolar(s, range);\n\tif (aref == AREF_DIFF) {\n\t\t \n\t\tgainshift = chan * 2;\n\t\tif (devpriv->hwver == 0) {\n\t\t\t \n\t\t\tadcen = 3 << gainshift;\n\t\t} else {\n\t\t\t \n\t\t\tadcen = 1 << gainshift;\n\t\t}\n\t\tadccon |= PCI230_ADC_IM_DIF;\n\t} else {\n\t\t \n\t\tadcen = 1 << chan;\n\t\tgainshift = chan & ~1;\n\t\tadccon |= PCI230_ADC_IM_SE;\n\t}\n\tdevpriv->adcg = (devpriv->adcg & ~(3 << gainshift)) |\n\t\t\t(pci230_ai_gain[range] << gainshift);\n\tif (devpriv->ai_bipolar)\n\t\tadccon |= PCI230_ADC_IR_BIP;\n\telse\n\t\tadccon |= PCI230_ADC_IR_UNI;\n\n\t \n\toutw(adcen, devpriv->daqio + PCI230_ADCEN);\n\n\t \n\toutw(devpriv->adcg, devpriv->daqio + PCI230_ADCG);\n\n\t \n\tdevpriv->adccon = adccon;\n\toutw(adccon | PCI230_ADC_FIFO_RESET, devpriv->daqio + PCI230_ADCCON);\n\n\t \n\tfor (n = 0; n < insn->n; n++) {\n\t\t \n\t\tcomedi_8254_set_mode(dev->pacer, 2, I8254_MODE0);\n\t\tcomedi_8254_set_mode(dev->pacer, 2, I8254_MODE1);\n\n\t\t \n\t\tret = comedi_timeout(dev, s, insn, pci230_ai_eoc, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tdata[n] = pci230_ai_read(dev);\n\t}\n\n\t \n\treturn n;\n}\n\nstatic int pci230_ao_insn_write(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tstruct comedi_insn *insn,\n\t\t\t\tunsigned int *data)\n{\n\tstruct pci230_private *devpriv = dev->private;\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int range = CR_RANGE(insn->chanspec);\n\tunsigned int val = s->readback[chan];\n\tint i;\n\n\t \n\tdevpriv->ao_bipolar = comedi_range_is_bipolar(s, range);\n\toutw(range, devpriv->daqio + PCI230_DACCON);\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\tval = data[i];\n\t\tpci230_ao_write_nofifo(dev, val, chan);\n\t}\n\ts->readback[chan] = val;\n\n\treturn insn->n;\n}\n\nstatic int pci230_ao_check_chanlist(struct comedi_device *dev,\n\t\t\t\t    struct comedi_subdevice *s,\n\t\t\t\t    struct comedi_cmd *cmd)\n{\n\tunsigned int prev_chan = CR_CHAN(cmd->chanlist[0]);\n\tunsigned int range0 = CR_RANGE(cmd->chanlist[0]);\n\tint i;\n\n\tfor (i = 1; i < cmd->chanlist_len; i++) {\n\t\tunsigned int chan = CR_CHAN(cmd->chanlist[i]);\n\t\tunsigned int range = CR_RANGE(cmd->chanlist[i]);\n\n\t\tif (chan < prev_chan) {\n\t\t\tdev_dbg(dev->class_dev,\n\t\t\t\t\"%s: channel numbers must increase\\n\",\n\t\t\t\t__func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (range != range0) {\n\t\t\tdev_dbg(dev->class_dev,\n\t\t\t\t\"%s: channels must have the same range\\n\",\n\t\t\t\t__func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tprev_chan = chan;\n\t}\n\n\treturn 0;\n}\n\nstatic int pci230_ao_cmdtest(struct comedi_device *dev,\n\t\t\t     struct comedi_subdevice *s, struct comedi_cmd *cmd)\n{\n\tconst struct pci230_board *board = dev->board_ptr;\n\tstruct pci230_private *devpriv = dev->private;\n\tint err = 0;\n\tunsigned int tmp;\n\n\t \n\n\terr |= comedi_check_trigger_src(&cmd->start_src, TRIG_INT);\n\n\ttmp = TRIG_TIMER | TRIG_INT;\n\tif (board->min_hwver > 0 && devpriv->hwver >= 2) {\n\t\t \n\t\ttmp |= TRIG_EXT;\n\t}\n\terr |= comedi_check_trigger_src(&cmd->scan_begin_src, tmp);\n\n\terr |= comedi_check_trigger_src(&cmd->convert_src, TRIG_NOW);\n\terr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\n\terr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\n\n\tif (err)\n\t\treturn 1;\n\n\t \n\n\terr |= comedi_check_trigger_is_unique(cmd->scan_begin_src);\n\terr |= comedi_check_trigger_is_unique(cmd->stop_src);\n\n\t \n\n\tif (err)\n\t\treturn 2;\n\n\t \n\n\terr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\n\n#define MAX_SPEED_AO\t8000\t \n \n#define MIN_SPEED_AO\t4294967295u\t \n\n\tswitch (cmd->scan_begin_src) {\n\tcase TRIG_TIMER:\n\t\terr |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,\n\t\t\t\t\t\t    MAX_SPEED_AO);\n\t\terr |= comedi_check_trigger_arg_max(&cmd->scan_begin_arg,\n\t\t\t\t\t\t    MIN_SPEED_AO);\n\t\tbreak;\n\tcase TRIG_EXT:\n\t\t \n\t\t \n\t\tif (cmd->scan_begin_arg & ~CR_FLAGS_MASK) {\n\t\t\tcmd->scan_begin_arg = COMBINE(cmd->scan_begin_arg, 0,\n\t\t\t\t\t\t      ~CR_FLAGS_MASK);\n\t\t\terr |= -EINVAL;\n\t\t}\n\t\t \n\t\tif (cmd->scan_begin_arg & CR_FLAGS_MASK &\n\t\t    ~(CR_EDGE | CR_INVERT)) {\n\t\t\tcmd->scan_begin_arg =\n\t\t\t    COMBINE(cmd->scan_begin_arg, 0,\n\t\t\t\t    CR_FLAGS_MASK & ~(CR_EDGE | CR_INVERT));\n\t\t\terr |= -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\terr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);\n\t\tbreak;\n\t}\n\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\n\t\t\t\t\t   cmd->chanlist_len);\n\n\tif (cmd->stop_src == TRIG_COUNT)\n\t\terr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\n\telse\t \n\t\terr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\n\n\tif (err)\n\t\treturn 3;\n\n\t \n\n\tif (cmd->scan_begin_src == TRIG_TIMER) {\n\t\ttmp = cmd->scan_begin_arg;\n\t\tpci230_ns_to_single_timer(&cmd->scan_begin_arg, cmd->flags);\n\t\tif (tmp != cmd->scan_begin_arg)\n\t\t\terr++;\n\t}\n\n\tif (err)\n\t\treturn 4;\n\n\t \n\tif (cmd->chanlist && cmd->chanlist_len > 0)\n\t\terr |= pci230_ao_check_chanlist(dev, s, cmd);\n\n\tif (err)\n\t\treturn 5;\n\n\treturn 0;\n}\n\nstatic void pci230_ao_stop(struct comedi_device *dev,\n\t\t\t   struct comedi_subdevice *s)\n{\n\tstruct pci230_private *devpriv = dev->private;\n\tunsigned long irqflags;\n\tunsigned char intsrc;\n\tbool started;\n\tstruct comedi_cmd *cmd;\n\n\tspin_lock_irqsave(&devpriv->ao_stop_spinlock, irqflags);\n\tstarted = devpriv->ao_cmd_started;\n\tdevpriv->ao_cmd_started = false;\n\tspin_unlock_irqrestore(&devpriv->ao_stop_spinlock, irqflags);\n\tif (!started)\n\t\treturn;\n\tcmd = &s->async->cmd;\n\tif (cmd->scan_begin_src == TRIG_TIMER) {\n\t\t \n\t\tpci230_cancel_ct(dev, 1);\n\t}\n\t \n\tif (devpriv->hwver < 2) {\n\t\t \n\t\tintsrc = PCI230_INT_ZCLK_CT1;\n\t} else {\n\t\t \n\t\tintsrc = PCI230P2_INT_DAC;\n\t}\n\t \n\tspin_lock_irqsave(&devpriv->isr_spinlock, irqflags);\n\tdevpriv->ier &= ~intsrc;\n\twhile (devpriv->intr_running && devpriv->intr_cpuid != THISCPU) {\n\t\tspin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);\n\t\tspin_lock_irqsave(&devpriv->isr_spinlock, irqflags);\n\t}\n\toutb(devpriv->ier, dev->iobase + PCI230_INT_SCE);\n\tspin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);\n\tif (devpriv->hwver >= 2) {\n\t\t \n\t\tdevpriv->daccon &= PCI230_DAC_OR_MASK;\n\t\toutw(devpriv->daccon | PCI230P2_DAC_FIFO_RESET |\n\t\t     PCI230P2_DAC_FIFO_UNDERRUN_CLEAR,\n\t\t     devpriv->daqio + PCI230_DACCON);\n\t}\n\t \n\tpci230_release_all_resources(dev, OWNER_AOCMD);\n}\n\nstatic void pci230_handle_ao_nofifo(struct comedi_device *dev,\n\t\t\t\t    struct comedi_subdevice *s)\n{\n\tstruct comedi_async *async = s->async;\n\tstruct comedi_cmd *cmd = &async->cmd;\n\tunsigned short data;\n\tint i;\n\n\tif (cmd->stop_src == TRIG_COUNT && async->scans_done >= cmd->stop_arg)\n\t\treturn;\n\n\tfor (i = 0; i < cmd->chanlist_len; i++) {\n\t\tunsigned int chan = CR_CHAN(cmd->chanlist[i]);\n\n\t\tif (!comedi_buf_read_samples(s, &data, 1)) {\n\t\t\tasync->events |= COMEDI_CB_OVERFLOW;\n\t\t\treturn;\n\t\t}\n\t\tpci230_ao_write_nofifo(dev, data, chan);\n\t\ts->readback[chan] = data;\n\t}\n\n\tif (cmd->stop_src == TRIG_COUNT && async->scans_done >= cmd->stop_arg)\n\t\tasync->events |= COMEDI_CB_EOA;\n}\n\n \nstatic bool pci230_handle_ao_fifo(struct comedi_device *dev,\n\t\t\t\t  struct comedi_subdevice *s)\n{\n\tstruct pci230_private *devpriv = dev->private;\n\tstruct comedi_async *async = s->async;\n\tstruct comedi_cmd *cmd = &async->cmd;\n\tunsigned int num_scans = comedi_nscans_left(s, 0);\n\tunsigned int room;\n\tunsigned short dacstat;\n\tunsigned int i, n;\n\tunsigned int events = 0;\n\n\t \n\tdacstat = inw(devpriv->daqio + PCI230_DACCON);\n\n\tif (cmd->stop_src == TRIG_COUNT && num_scans == 0)\n\t\tevents |= COMEDI_CB_EOA;\n\n\tif (events == 0) {\n\t\t \n\t\tif (dacstat & PCI230P2_DAC_FIFO_UNDERRUN_LATCHED) {\n\t\t\tdev_err(dev->class_dev, \"AO FIFO underrun\\n\");\n\t\t\tevents |= COMEDI_CB_OVERFLOW | COMEDI_CB_ERROR;\n\t\t}\n\t\t \n\t\tif (num_scans == 0 &&\n\t\t    (dacstat & PCI230P2_DAC_FIFO_HALF) == 0) {\n\t\t\tdev_err(dev->class_dev, \"AO buffer underrun\\n\");\n\t\t\tevents |= COMEDI_CB_OVERFLOW | COMEDI_CB_ERROR;\n\t\t}\n\t}\n\tif (events == 0) {\n\t\t \n\t\tif (dacstat & PCI230P2_DAC_FIFO_FULL)\n\t\t\troom = PCI230P2_DAC_FIFOROOM_FULL;\n\t\telse if (dacstat & PCI230P2_DAC_FIFO_HALF)\n\t\t\troom = PCI230P2_DAC_FIFOROOM_HALFTOFULL;\n\t\telse if (dacstat & PCI230P2_DAC_FIFO_EMPTY)\n\t\t\troom = PCI230P2_DAC_FIFOROOM_EMPTY;\n\t\telse\n\t\t\troom = PCI230P2_DAC_FIFOROOM_ONETOHALF;\n\t\t \n\t\troom /= cmd->chanlist_len;\n\t\t \n\t\tif (num_scans > room)\n\t\t\tnum_scans = room;\n\t\t \n\t\tfor (n = 0; n < num_scans; n++) {\n\t\t\tfor (i = 0; i < cmd->chanlist_len; i++) {\n\t\t\t\tunsigned int chan = CR_CHAN(cmd->chanlist[i]);\n\t\t\t\tunsigned short datum;\n\n\t\t\t\tcomedi_buf_read_samples(s, &datum, 1);\n\t\t\t\tpci230_ao_write_fifo(dev, datum, chan);\n\t\t\t\ts->readback[chan] = datum;\n\t\t\t}\n\t\t}\n\n\t\tif (cmd->stop_src == TRIG_COUNT &&\n\t\t    async->scans_done >= cmd->stop_arg) {\n\t\t\t \n\t\t\tdevpriv->daccon &= ~PCI230P2_DAC_INT_FIFO_MASK;\n\t\t\tdevpriv->daccon |= PCI230P2_DAC_INT_FIFO_EMPTY;\n\t\t\toutw(devpriv->daccon, devpriv->daqio + PCI230_DACCON);\n\t\t}\n\t\t \n\t\tdacstat = inw(devpriv->daqio + PCI230_DACCON);\n\t\tif (dacstat & PCI230P2_DAC_FIFO_UNDERRUN_LATCHED) {\n\t\t\tdev_err(dev->class_dev, \"AO FIFO underrun\\n\");\n\t\t\tevents |= COMEDI_CB_OVERFLOW | COMEDI_CB_ERROR;\n\t\t}\n\t}\n\tasync->events |= events;\n\treturn !(async->events & COMEDI_CB_CANCEL_MASK);\n}\n\nstatic int pci230_ao_inttrig_scan_begin(struct comedi_device *dev,\n\t\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\t\tunsigned int trig_num)\n{\n\tstruct pci230_private *devpriv = dev->private;\n\tunsigned long irqflags;\n\n\tif (trig_num)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&devpriv->ao_stop_spinlock, irqflags);\n\tif (!devpriv->ao_cmd_started) {\n\t\tspin_unlock_irqrestore(&devpriv->ao_stop_spinlock, irqflags);\n\t\treturn 1;\n\t}\n\t \n\tif (devpriv->hwver < 2) {\n\t\t \n\t\tspin_unlock_irqrestore(&devpriv->ao_stop_spinlock, irqflags);\n\t\tpci230_handle_ao_nofifo(dev, s);\n\t\tcomedi_handle_events(dev, s);\n\t} else {\n\t\t \n\t\t \n\t\tinw(devpriv->daqio + PCI230P2_DACSWTRIG);\n\t\tspin_unlock_irqrestore(&devpriv->ao_stop_spinlock, irqflags);\n\t}\n\t \n\t \n\tudelay(8);\n\treturn 1;\n}\n\nstatic void pci230_ao_start(struct comedi_device *dev,\n\t\t\t    struct comedi_subdevice *s)\n{\n\tstruct pci230_private *devpriv = dev->private;\n\tstruct comedi_async *async = s->async;\n\tstruct comedi_cmd *cmd = &async->cmd;\n\tunsigned long irqflags;\n\n\tdevpriv->ao_cmd_started = true;\n\n\tif (devpriv->hwver >= 2) {\n\t\t \n\t\tunsigned short scantrig;\n\t\tbool run;\n\n\t\t \n\t\trun = pci230_handle_ao_fifo(dev, s);\n\t\tcomedi_handle_events(dev, s);\n\t\tif (!run) {\n\t\t\t \n\t\t\treturn;\n\t\t}\n\t\t \n\t\tswitch (cmd->scan_begin_src) {\n\t\tcase TRIG_TIMER:\n\t\t\tscantrig = PCI230P2_DAC_TRIG_Z2CT1;\n\t\t\tbreak;\n\t\tcase TRIG_EXT:\n\t\t\t \n\t\t\tif ((cmd->scan_begin_arg & CR_INVERT) == 0) {\n\t\t\t\t \n\t\t\t\tscantrig = PCI230P2_DAC_TRIG_EXTP;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tscantrig = PCI230P2_DAC_TRIG_EXTN;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TRIG_INT:\n\t\t\tscantrig = PCI230P2_DAC_TRIG_SW;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tscantrig = PCI230P2_DAC_TRIG_NONE;\n\t\t\tbreak;\n\t\t}\n\t\tdevpriv->daccon =\n\t\t    (devpriv->daccon & ~PCI230P2_DAC_TRIG_MASK) | scantrig;\n\t\toutw(devpriv->daccon, devpriv->daqio + PCI230_DACCON);\n\t}\n\tswitch (cmd->scan_begin_src) {\n\tcase TRIG_TIMER:\n\t\tif (devpriv->hwver < 2) {\n\t\t\t \n\t\t\t \n\t\t\tspin_lock_irqsave(&devpriv->isr_spinlock, irqflags);\n\t\t\tdevpriv->ier |= PCI230_INT_ZCLK_CT1;\n\t\t\toutb(devpriv->ier, dev->iobase + PCI230_INT_SCE);\n\t\t\tspin_unlock_irqrestore(&devpriv->isr_spinlock,\n\t\t\t\t\t       irqflags);\n\t\t}\n\t\t \n\t\toutb(pci230_gat_config(1, GAT_VCC),\n\t\t     dev->iobase + PCI230_ZGAT_SCE);\n\t\tbreak;\n\tcase TRIG_INT:\n\t\tasync->inttrig = pci230_ao_inttrig_scan_begin;\n\t\tbreak;\n\t}\n\tif (devpriv->hwver >= 2) {\n\t\t \n\t\tspin_lock_irqsave(&devpriv->isr_spinlock, irqflags);\n\t\tdevpriv->ier |= PCI230P2_INT_DAC;\n\t\toutb(devpriv->ier, dev->iobase + PCI230_INT_SCE);\n\t\tspin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);\n\t}\n}\n\nstatic int pci230_ao_inttrig_start(struct comedi_device *dev,\n\t\t\t\t   struct comedi_subdevice *s,\n\t\t\t\t   unsigned int trig_num)\n{\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\n\tif (trig_num != cmd->start_src)\n\t\treturn -EINVAL;\n\n\ts->async->inttrig = NULL;\n\tpci230_ao_start(dev, s);\n\n\treturn 1;\n}\n\nstatic int pci230_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\n{\n\tstruct pci230_private *devpriv = dev->private;\n\tunsigned short daccon;\n\tunsigned int range;\n\n\t \n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\n\tif (cmd->scan_begin_src == TRIG_TIMER) {\n\t\t \n\t\tif (!pci230_claim_shared(dev, RES_Z2CT1, OWNER_AOCMD))\n\t\t\treturn -EBUSY;\n\t}\n\n\t \n\trange = CR_RANGE(cmd->chanlist[0]);\n\tdevpriv->ao_bipolar = comedi_range_is_bipolar(s, range);\n\tdaccon = devpriv->ao_bipolar ? PCI230_DAC_OR_BIP : PCI230_DAC_OR_UNI;\n\t \n\tif (devpriv->hwver >= 2) {\n\t\tunsigned short dacen;\n\t\tunsigned int i;\n\n\t\tdacen = 0;\n\t\tfor (i = 0; i < cmd->chanlist_len; i++)\n\t\t\tdacen |= 1 << CR_CHAN(cmd->chanlist[i]);\n\n\t\t \n\t\toutw(dacen, devpriv->daqio + PCI230P2_DACEN);\n\t\t \n\t\tdaccon |= PCI230P2_DAC_FIFO_EN | PCI230P2_DAC_FIFO_RESET |\n\t\t\t  PCI230P2_DAC_FIFO_UNDERRUN_CLEAR |\n\t\t\t  PCI230P2_DAC_TRIG_NONE | PCI230P2_DAC_INT_FIFO_NHALF;\n\t}\n\n\t \n\toutw(daccon, devpriv->daqio + PCI230_DACCON);\n\t \n\tdevpriv->daccon = daccon & ~(PCI230P2_DAC_FIFO_RESET |\n\t\t\t\t     PCI230P2_DAC_FIFO_UNDERRUN_CLEAR);\n\n\tif (cmd->scan_begin_src == TRIG_TIMER) {\n\t\t \n\t\toutb(pci230_gat_config(1, GAT_GND),\n\t\t     dev->iobase + PCI230_ZGAT_SCE);\n\t\tpci230_ct_setup_ns_mode(dev, 1, I8254_MODE3,\n\t\t\t\t\tcmd->scan_begin_arg,\n\t\t\t\t\tcmd->flags);\n\t}\n\n\t \n\ts->async->inttrig = pci230_ao_inttrig_start;\n\n\treturn 0;\n}\n\nstatic int pci230_ao_cancel(struct comedi_device *dev,\n\t\t\t    struct comedi_subdevice *s)\n{\n\tpci230_ao_stop(dev, s);\n\treturn 0;\n}\n\nstatic int pci230_ai_check_scan_period(struct comedi_cmd *cmd)\n{\n\tunsigned int min_scan_period, chanlist_len;\n\tint err = 0;\n\n\tchanlist_len = cmd->chanlist_len;\n\tif (cmd->chanlist_len == 0)\n\t\tchanlist_len = 1;\n\n\tmin_scan_period = chanlist_len * cmd->convert_arg;\n\tif (min_scan_period < chanlist_len ||\n\t    min_scan_period < cmd->convert_arg) {\n\t\t \n\t\tmin_scan_period = UINT_MAX;\n\t\terr++;\n\t}\n\tif (cmd->scan_begin_arg < min_scan_period) {\n\t\tcmd->scan_begin_arg = min_scan_period;\n\t\terr++;\n\t}\n\n\treturn !err;\n}\n\nstatic int pci230_ai_check_chanlist(struct comedi_device *dev,\n\t\t\t\t    struct comedi_subdevice *s,\n\t\t\t\t    struct comedi_cmd *cmd)\n{\n\tstruct pci230_private *devpriv = dev->private;\n\tunsigned int max_diff_chan = (s->n_chan / 2) - 1;\n\tunsigned int prev_chan = 0;\n\tunsigned int prev_range = 0;\n\tunsigned int prev_aref = 0;\n\tbool prev_bipolar = false;\n\tunsigned int subseq_len = 0;\n\tint i;\n\n\tfor (i = 0; i < cmd->chanlist_len; i++) {\n\t\tunsigned int chanspec = cmd->chanlist[i];\n\t\tunsigned int chan = CR_CHAN(chanspec);\n\t\tunsigned int range = CR_RANGE(chanspec);\n\t\tunsigned int aref = CR_AREF(chanspec);\n\t\tbool bipolar = comedi_range_is_bipolar(s, range);\n\n\t\tif (aref == AREF_DIFF && chan >= max_diff_chan) {\n\t\t\tdev_dbg(dev->class_dev,\n\t\t\t\t\"%s: differential channel number out of range 0 to %u\\n\",\n\t\t\t\t__func__, max_diff_chan);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (i > 0) {\n\t\t\t \n\t\t\tif (chan <= prev_chan && subseq_len == 0)\n\t\t\t\tsubseq_len = i;\n\n\t\t\tif (subseq_len > 0 &&\n\t\t\t    cmd->chanlist[i % subseq_len] != chanspec) {\n\t\t\t\tdev_dbg(dev->class_dev,\n\t\t\t\t\t\"%s: channel numbers must increase or sequence must repeat exactly\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (aref != prev_aref) {\n\t\t\t\tdev_dbg(dev->class_dev,\n\t\t\t\t\t\"%s: channel sequence analogue references must be all the same (single-ended or differential)\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (bipolar != prev_bipolar) {\n\t\t\t\tdev_dbg(dev->class_dev,\n\t\t\t\t\t\"%s: channel sequence ranges must be all bipolar or all unipolar\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (aref != AREF_DIFF && range != prev_range &&\n\t\t\t    ((chan ^ prev_chan) & ~1) == 0) {\n\t\t\t\tdev_dbg(dev->class_dev,\n\t\t\t\t\t\"%s: single-ended channel pairs must have the same range\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tprev_chan = chan;\n\t\tprev_range = range;\n\t\tprev_aref = aref;\n\t\tprev_bipolar = bipolar;\n\t}\n\n\tif (subseq_len == 0)\n\t\tsubseq_len = cmd->chanlist_len;\n\n\tif (cmd->chanlist_len % subseq_len) {\n\t\tdev_dbg(dev->class_dev,\n\t\t\t\"%s: sequence must repeat exactly\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (devpriv->hwver > 0 && devpriv->hwver < 4) {\n\t\tif (subseq_len > 1 && CR_CHAN(cmd->chanlist[0])) {\n\t\t\tdev_info(dev->class_dev,\n\t\t\t\t \"amplc_pci230: ai_cmdtest: Buggy PCI230+/260+ h/w version %u requires first channel of multi-channel sequence to be 0 (corrected in h/w version 4)\\n\",\n\t\t\t\t devpriv->hwver);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int pci230_ai_cmdtest(struct comedi_device *dev,\n\t\t\t     struct comedi_subdevice *s, struct comedi_cmd *cmd)\n{\n\tconst struct pci230_board *board = dev->board_ptr;\n\tstruct pci230_private *devpriv = dev->private;\n\tint err = 0;\n\tunsigned int tmp;\n\n\t \n\n\terr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_INT);\n\n\ttmp = TRIG_FOLLOW | TRIG_TIMER | TRIG_INT;\n\tif (board->have_dio || board->min_hwver > 0) {\n\t\t \n\t\ttmp |= TRIG_EXT;\n\t}\n\terr |= comedi_check_trigger_src(&cmd->scan_begin_src, tmp);\n\terr |= comedi_check_trigger_src(&cmd->convert_src,\n\t\t\t\t\tTRIG_TIMER | TRIG_INT | TRIG_EXT);\n\terr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\n\terr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\n\n\tif (err)\n\t\treturn 1;\n\n\t \n\n\terr |= comedi_check_trigger_is_unique(cmd->start_src);\n\terr |= comedi_check_trigger_is_unique(cmd->scan_begin_src);\n\terr |= comedi_check_trigger_is_unique(cmd->convert_src);\n\terr |= comedi_check_trigger_is_unique(cmd->stop_src);\n\n\t \n\n\t \n\tif (cmd->scan_begin_src != TRIG_FOLLOW &&\n\t    cmd->convert_src != TRIG_TIMER)\n\t\terr |= -EINVAL;\n\n\tif (err)\n\t\treturn 2;\n\n\t \n\n\terr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\n\n#define MAX_SPEED_AI_SE\t\t3200\t \n#define MAX_SPEED_AI_DIFF\t8000\t \n#define MAX_SPEED_AI_PLUS\t4000\t \n \n#define MIN_SPEED_AI\t4294967295u\t \n\n\tif (cmd->convert_src == TRIG_TIMER) {\n\t\tunsigned int max_speed_ai;\n\n\t\tif (devpriv->hwver == 0) {\n\t\t\t \n\t\t\tif (cmd->chanlist && cmd->chanlist_len > 0) {\n\t\t\t\t \n\t\t\t\tif (CR_AREF(cmd->chanlist[0]) == AREF_DIFF)\n\t\t\t\t\tmax_speed_ai = MAX_SPEED_AI_DIFF;\n\t\t\t\telse\n\t\t\t\t\tmax_speed_ai = MAX_SPEED_AI_SE;\n\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tmax_speed_ai = MAX_SPEED_AI_SE;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tmax_speed_ai = MAX_SPEED_AI_PLUS;\n\t\t}\n\n\t\terr |= comedi_check_trigger_arg_min(&cmd->convert_arg,\n\t\t\t\t\t\t    max_speed_ai);\n\t\terr |= comedi_check_trigger_arg_max(&cmd->convert_arg,\n\t\t\t\t\t\t    MIN_SPEED_AI);\n\t} else if (cmd->convert_src == TRIG_EXT) {\n\t\t \n\t\tif (cmd->convert_arg & CR_FLAGS_MASK) {\n\t\t\t \n\t\t\tif (cmd->convert_arg & ~CR_FLAGS_MASK) {\n\t\t\t\tcmd->convert_arg = COMBINE(cmd->convert_arg, 0,\n\t\t\t\t\t\t\t   ~CR_FLAGS_MASK);\n\t\t\t\terr |= -EINVAL;\n\t\t\t}\n\t\t\t \n\t\t\tif ((cmd->convert_arg & CR_FLAGS_MASK & ~CR_INVERT) !=\n\t\t\t    CR_EDGE) {\n\t\t\t\t \n\t\t\t\tcmd->convert_arg =\n\t\t\t\t    COMBINE(cmd->start_arg, CR_EDGE | 0,\n\t\t\t\t\t    CR_FLAGS_MASK & ~CR_INVERT);\n\t\t\t\terr |= -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\terr |= comedi_check_trigger_arg_max(&cmd->convert_arg,\n\t\t\t\t\t\t\t    1);\n\t\t}\n\t} else {\n\t\terr |= comedi_check_trigger_arg_is(&cmd->convert_arg, 0);\n\t}\n\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\n\t\t\t\t\t   cmd->chanlist_len);\n\n\tif (cmd->stop_src == TRIG_COUNT)\n\t\terr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\n\telse\t \n\t\terr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\n\n\tif (cmd->scan_begin_src == TRIG_EXT) {\n\t\t \n\t\tif (cmd->scan_begin_arg & ~CR_FLAGS_MASK) {\n\t\t\tcmd->scan_begin_arg = COMBINE(cmd->scan_begin_arg, 0,\n\t\t\t\t\t\t      ~CR_FLAGS_MASK);\n\t\t\terr |= -EINVAL;\n\t\t}\n\t\t \n\t\tif (cmd->scan_begin_arg & CR_FLAGS_MASK & ~CR_EDGE) {\n\t\t\tcmd->scan_begin_arg = COMBINE(cmd->scan_begin_arg, 0,\n\t\t\t\t\t\t      CR_FLAGS_MASK & ~CR_EDGE);\n\t\t\terr |= -EINVAL;\n\t\t}\n\t} else if (cmd->scan_begin_src == TRIG_TIMER) {\n\t\t \n\t\tif (!pci230_ai_check_scan_period(cmd))\n\t\t\terr |= -EINVAL;\n\n\t} else {\n\t\terr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);\n\t}\n\n\tif (err)\n\t\treturn 3;\n\n\t \n\n\tif (cmd->convert_src == TRIG_TIMER) {\n\t\ttmp = cmd->convert_arg;\n\t\tpci230_ns_to_single_timer(&cmd->convert_arg, cmd->flags);\n\t\tif (tmp != cmd->convert_arg)\n\t\t\terr++;\n\t}\n\n\tif (cmd->scan_begin_src == TRIG_TIMER) {\n\t\t \n\t\ttmp = cmd->scan_begin_arg;\n\t\tpci230_ns_to_single_timer(&cmd->scan_begin_arg, cmd->flags);\n\t\tif (!pci230_ai_check_scan_period(cmd)) {\n\t\t\t \n\t\t\tpci230_ns_to_single_timer(&cmd->scan_begin_arg,\n\t\t\t\t\t\t  CMDF_ROUND_UP);\n\t\t\tpci230_ai_check_scan_period(cmd);\n\t\t}\n\t\tif (tmp != cmd->scan_begin_arg)\n\t\t\terr++;\n\t}\n\n\tif (err)\n\t\treturn 4;\n\n\t \n\tif (cmd->chanlist && cmd->chanlist_len > 0)\n\t\terr |= pci230_ai_check_chanlist(dev, s, cmd);\n\n\tif (err)\n\t\treturn 5;\n\n\treturn 0;\n}\n\nstatic void pci230_ai_update_fifo_trigger_level(struct comedi_device *dev,\n\t\t\t\t\t\tstruct comedi_subdevice *s)\n{\n\tstruct pci230_private *devpriv = dev->private;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tunsigned int wake;\n\tunsigned short triglev;\n\tunsigned short adccon;\n\n\tif (cmd->flags & CMDF_WAKE_EOS)\n\t\twake = cmd->scan_end_arg - s->async->cur_chan;\n\telse\n\t\twake = comedi_nsamples_left(s, PCI230_ADC_FIFOLEVEL_HALFFULL);\n\n\tif (wake >= PCI230_ADC_FIFOLEVEL_HALFFULL) {\n\t\ttriglev = PCI230_ADC_INT_FIFO_HALF;\n\t} else if (wake > 1 && devpriv->hwver > 0) {\n\t\t \n\t\tif (devpriv->adcfifothresh != wake) {\n\t\t\tdevpriv->adcfifothresh = wake;\n\t\t\toutw(wake, devpriv->daqio + PCI230P_ADCFFTH);\n\t\t}\n\t\ttriglev = PCI230P_ADC_INT_FIFO_THRESH;\n\t} else {\n\t\ttriglev = PCI230_ADC_INT_FIFO_NEMPTY;\n\t}\n\tadccon = (devpriv->adccon & ~PCI230_ADC_INT_FIFO_MASK) | triglev;\n\tif (adccon != devpriv->adccon) {\n\t\tdevpriv->adccon = adccon;\n\t\toutw(adccon, devpriv->daqio + PCI230_ADCCON);\n\t}\n}\n\nstatic int pci230_ai_inttrig_convert(struct comedi_device *dev,\n\t\t\t\t     struct comedi_subdevice *s,\n\t\t\t\t     unsigned int trig_num)\n{\n\tstruct pci230_private *devpriv = dev->private;\n\tunsigned long irqflags;\n\tunsigned int delayus;\n\n\tif (trig_num)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&devpriv->ai_stop_spinlock, irqflags);\n\tif (!devpriv->ai_cmd_started) {\n\t\tspin_unlock_irqrestore(&devpriv->ai_stop_spinlock, irqflags);\n\t\treturn 1;\n\t}\n\t \n\tcomedi_8254_set_mode(dev->pacer, 2, I8254_MODE0);\n\tcomedi_8254_set_mode(dev->pacer, 2, I8254_MODE1);\n\t \n\tif ((devpriv->adccon & PCI230_ADC_IM_MASK) == PCI230_ADC_IM_DIF &&\n\t    devpriv->hwver == 0) {\n\t\t \n\t\tdelayus = 8;\n\t} else {\n\t\t \n\t\tdelayus = 4;\n\t}\n\tspin_unlock_irqrestore(&devpriv->ai_stop_spinlock, irqflags);\n\tudelay(delayus);\n\treturn 1;\n}\n\nstatic int pci230_ai_inttrig_scan_begin(struct comedi_device *dev,\n\t\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\t\tunsigned int trig_num)\n{\n\tstruct pci230_private *devpriv = dev->private;\n\tunsigned long irqflags;\n\tunsigned char zgat;\n\n\tif (trig_num)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&devpriv->ai_stop_spinlock, irqflags);\n\tif (devpriv->ai_cmd_started) {\n\t\t \n\t\tzgat = pci230_gat_config(0, GAT_GND);\n\t\toutb(zgat, dev->iobase + PCI230_ZGAT_SCE);\n\t\tzgat = pci230_gat_config(0, GAT_VCC);\n\t\toutb(zgat, dev->iobase + PCI230_ZGAT_SCE);\n\t}\n\tspin_unlock_irqrestore(&devpriv->ai_stop_spinlock, irqflags);\n\n\treturn 1;\n}\n\nstatic void pci230_ai_stop(struct comedi_device *dev,\n\t\t\t   struct comedi_subdevice *s)\n{\n\tstruct pci230_private *devpriv = dev->private;\n\tunsigned long irqflags;\n\tstruct comedi_cmd *cmd;\n\tbool started;\n\n\tspin_lock_irqsave(&devpriv->ai_stop_spinlock, irqflags);\n\tstarted = devpriv->ai_cmd_started;\n\tdevpriv->ai_cmd_started = false;\n\tspin_unlock_irqrestore(&devpriv->ai_stop_spinlock, irqflags);\n\tif (!started)\n\t\treturn;\n\tcmd = &s->async->cmd;\n\tif (cmd->convert_src == TRIG_TIMER) {\n\t\t \n\t\tpci230_cancel_ct(dev, 2);\n\t}\n\tif (cmd->scan_begin_src != TRIG_FOLLOW) {\n\t\t \n\t\tpci230_cancel_ct(dev, 0);\n\t}\n\tspin_lock_irqsave(&devpriv->isr_spinlock, irqflags);\n\t \n\tdevpriv->ier &= ~PCI230_INT_ADC;\n\twhile (devpriv->intr_running && devpriv->intr_cpuid != THISCPU) {\n\t\tspin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);\n\t\tspin_lock_irqsave(&devpriv->isr_spinlock, irqflags);\n\t}\n\toutb(devpriv->ier, dev->iobase + PCI230_INT_SCE);\n\tspin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);\n\t \n\tdevpriv->adccon =\n\t    (devpriv->adccon & (PCI230_ADC_IR_MASK | PCI230_ADC_IM_MASK)) |\n\t    PCI230_ADC_TRIG_NONE;\n\toutw(devpriv->adccon | PCI230_ADC_FIFO_RESET,\n\t     devpriv->daqio + PCI230_ADCCON);\n\t \n\tpci230_release_all_resources(dev, OWNER_AICMD);\n}\n\nstatic void pci230_ai_start(struct comedi_device *dev,\n\t\t\t    struct comedi_subdevice *s)\n{\n\tstruct pci230_private *devpriv = dev->private;\n\tunsigned long irqflags;\n\tunsigned short conv;\n\tstruct comedi_async *async = s->async;\n\tstruct comedi_cmd *cmd = &async->cmd;\n\n\tdevpriv->ai_cmd_started = true;\n\n\t \n\tspin_lock_irqsave(&devpriv->isr_spinlock, irqflags);\n\tdevpriv->ier |= PCI230_INT_ADC;\n\toutb(devpriv->ier, dev->iobase + PCI230_INT_SCE);\n\tspin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);\n\n\t \n\tswitch (cmd->convert_src) {\n\tdefault:\n\t\tconv = PCI230_ADC_TRIG_NONE;\n\t\tbreak;\n\tcase TRIG_TIMER:\n\t\t \n\t\tconv = PCI230_ADC_TRIG_Z2CT2;\n\t\tbreak;\n\tcase TRIG_EXT:\n\t\tif (cmd->convert_arg & CR_EDGE) {\n\t\t\tif ((cmd->convert_arg & CR_INVERT) == 0) {\n\t\t\t\t \n\t\t\t\tconv = PCI230_ADC_TRIG_EXTP;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tconv = PCI230_ADC_TRIG_EXTN;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (cmd->convert_arg) {\n\t\t\t\t \n\t\t\t\tconv = PCI230_ADC_TRIG_EXTP;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tconv = PCI230_ADC_TRIG_EXTN;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase TRIG_INT:\n\t\t \n\t\tconv = PCI230_ADC_TRIG_Z2CT2;\n\t\tbreak;\n\t}\n\tdevpriv->adccon = (devpriv->adccon & ~PCI230_ADC_TRIG_MASK) | conv;\n\toutw(devpriv->adccon, devpriv->daqio + PCI230_ADCCON);\n\tif (cmd->convert_src == TRIG_INT)\n\t\tasync->inttrig = pci230_ai_inttrig_convert;\n\n\t \n\tpci230_ai_update_fifo_trigger_level(dev, s);\n\tif (cmd->convert_src == TRIG_TIMER) {\n\t\t \n\t\tunsigned char zgat;\n\n\t\tif (cmd->scan_begin_src != TRIG_FOLLOW) {\n\t\t\t \n\t\t\tzgat = pci230_gat_config(2, GAT_NOUTNM2);\n\t\t} else {\n\t\t\t \n\t\t\tzgat = pci230_gat_config(2, GAT_VCC);\n\t\t}\n\t\toutb(zgat, dev->iobase + PCI230_ZGAT_SCE);\n\t\tif (cmd->scan_begin_src != TRIG_FOLLOW) {\n\t\t\t \n\t\t\tswitch (cmd->scan_begin_src) {\n\t\t\tdefault:\n\t\t\t\tzgat = pci230_gat_config(0, GAT_VCC);\n\t\t\t\tbreak;\n\t\t\tcase TRIG_EXT:\n\t\t\t\t \n\t\t\t\tzgat = pci230_gat_config(0, GAT_EXT);\n\t\t\t\tbreak;\n\t\t\tcase TRIG_TIMER:\n\t\t\t\t \n\t\t\t\tzgat = pci230_gat_config(0, GAT_NOUTNM2);\n\t\t\t\tbreak;\n\t\t\tcase TRIG_INT:\n\t\t\t\t \n\t\t\t\tzgat = pci230_gat_config(0, GAT_VCC);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\toutb(zgat, dev->iobase + PCI230_ZGAT_SCE);\n\t\t\tswitch (cmd->scan_begin_src) {\n\t\t\tcase TRIG_TIMER:\n\t\t\t\t \n\t\t\t\tzgat = pci230_gat_config(1, GAT_VCC);\n\t\t\t\toutb(zgat, dev->iobase + PCI230_ZGAT_SCE);\n\t\t\t\tbreak;\n\t\t\tcase TRIG_INT:\n\t\t\t\tasync->inttrig = pci230_ai_inttrig_scan_begin;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (cmd->convert_src != TRIG_INT) {\n\t\t \n\t\tpci230_release_shared(dev, RES_Z2CT2, OWNER_AICMD);\n\t}\n}\n\nstatic int pci230_ai_inttrig_start(struct comedi_device *dev,\n\t\t\t\t   struct comedi_subdevice *s,\n\t\t\t\t   unsigned int trig_num)\n{\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\n\tif (trig_num != cmd->start_arg)\n\t\treturn -EINVAL;\n\n\ts->async->inttrig = NULL;\n\tpci230_ai_start(dev, s);\n\n\treturn 1;\n}\n\nstatic void pci230_handle_ai(struct comedi_device *dev,\n\t\t\t     struct comedi_subdevice *s)\n{\n\tstruct pci230_private *devpriv = dev->private;\n\tstruct comedi_async *async = s->async;\n\tstruct comedi_cmd *cmd = &async->cmd;\n\tunsigned int status_fifo;\n\tunsigned int i;\n\tunsigned int nsamples;\n\tunsigned int fifoamount;\n\tunsigned short val;\n\n\t \n\tnsamples = comedi_nsamples_left(s, PCI230_ADC_FIFOLEVEL_HALFFULL);\n\tif (nsamples == 0)\n\t\treturn;\n\n\tfifoamount = 0;\n\tfor (i = 0; i < nsamples; i++) {\n\t\tif (fifoamount == 0) {\n\t\t\t \n\t\t\tstatus_fifo = inw(devpriv->daqio + PCI230_ADCCON);\n\t\t\tif (status_fifo & PCI230_ADC_FIFO_FULL_LATCHED) {\n\t\t\t\t \n\t\t\t\tdev_err(dev->class_dev, \"AI FIFO overrun\\n\");\n\t\t\t\tasync->events |= COMEDI_CB_ERROR;\n\t\t\t\tbreak;\n\t\t\t} else if (status_fifo & PCI230_ADC_FIFO_EMPTY) {\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t} else if (status_fifo & PCI230_ADC_FIFO_HALF) {\n\t\t\t\t \n\t\t\t\tfifoamount = PCI230_ADC_FIFOLEVEL_HALFFULL;\n\t\t\t} else if (devpriv->hwver > 0) {\n\t\t\t\t \n\t\t\t\tfifoamount = inw(devpriv->daqio +\n\t\t\t\t\t\t PCI230P_ADCFFLEV);\n\t\t\t\tif (fifoamount == 0)\n\t\t\t\t\tbreak;\t \n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tfifoamount = 1;\n\t\t\t}\n\t\t}\n\n\t\tval = pci230_ai_read(dev);\n\t\tif (!comedi_buf_write_samples(s, &val, 1))\n\t\t\tbreak;\n\n\t\tfifoamount--;\n\n\t\tif (cmd->stop_src == TRIG_COUNT &&\n\t\t    async->scans_done >= cmd->stop_arg) {\n\t\t\tasync->events |= COMEDI_CB_EOA;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (!(async->events & COMEDI_CB_CANCEL_MASK))\n\t\tpci230_ai_update_fifo_trigger_level(dev, s);\n}\n\nstatic int pci230_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\n{\n\tstruct pci230_private *devpriv = dev->private;\n\tunsigned int i, chan, range, diff;\n\tunsigned int res_mask;\n\tunsigned short adccon, adcen;\n\tunsigned char zgat;\n\n\t \n\tstruct comedi_async *async = s->async;\n\tstruct comedi_cmd *cmd = &async->cmd;\n\n\t \n\tres_mask = 0;\n\t \n\tres_mask |= RES_Z2CT2;\n\tif (cmd->scan_begin_src != TRIG_FOLLOW) {\n\t\t \n\t\tres_mask |= RES_Z2CT0;\n\t\tif (cmd->scan_begin_src == TRIG_TIMER) {\n\t\t\t \n\t\t\tres_mask |= RES_Z2CT1;\n\t\t}\n\t}\n\t \n\tif (!pci230_claim_shared(dev, res_mask, OWNER_AICMD))\n\t\treturn -EBUSY;\n\n\t \n\n\tadccon = PCI230_ADC_FIFO_EN;\n\tadcen = 0;\n\n\tif (CR_AREF(cmd->chanlist[0]) == AREF_DIFF) {\n\t\t \n\t\tdiff = 1;\n\t\tadccon |= PCI230_ADC_IM_DIF;\n\t} else {\n\t\t \n\t\tdiff = 0;\n\t\tadccon |= PCI230_ADC_IM_SE;\n\t}\n\n\trange = CR_RANGE(cmd->chanlist[0]);\n\tdevpriv->ai_bipolar = comedi_range_is_bipolar(s, range);\n\tif (devpriv->ai_bipolar)\n\t\tadccon |= PCI230_ADC_IR_BIP;\n\telse\n\t\tadccon |= PCI230_ADC_IR_UNI;\n\n\tfor (i = 0; i < cmd->chanlist_len; i++) {\n\t\tunsigned int gainshift;\n\n\t\tchan = CR_CHAN(cmd->chanlist[i]);\n\t\trange = CR_RANGE(cmd->chanlist[i]);\n\t\tif (diff) {\n\t\t\tgainshift = 2 * chan;\n\t\t\tif (devpriv->hwver == 0) {\n\t\t\t\t \n\t\t\t\tadcen |= 3 << gainshift;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tadcen |= 1 << gainshift;\n\t\t\t}\n\t\t} else {\n\t\t\tgainshift = chan & ~1;\n\t\t\tadcen |= 1 << chan;\n\t\t}\n\t\tdevpriv->adcg = (devpriv->adcg & ~(3 << gainshift)) |\n\t\t\t\t(pci230_ai_gain[range] << gainshift);\n\t}\n\n\t \n\toutw(adcen, devpriv->daqio + PCI230_ADCEN);\n\n\t \n\toutw(devpriv->adcg, devpriv->daqio + PCI230_ADCG);\n\n\t \n\tcomedi_8254_set_mode(dev->pacer, 2, I8254_MODE1);\n\n\t \n\tadccon |= PCI230_ADC_INT_FIFO_FULL | PCI230_ADC_TRIG_Z2CT2;\n\n\t \n\tdevpriv->adccon = adccon;\n\toutw(adccon | PCI230_ADC_FIFO_RESET, devpriv->daqio + PCI230_ADCCON);\n\n\t \n\tusleep_range(25, 100);\n\n\t \n\toutw(adccon | PCI230_ADC_FIFO_RESET, devpriv->daqio + PCI230_ADCCON);\n\n\tif (cmd->convert_src == TRIG_TIMER) {\n\t\t \n\t\tzgat = pci230_gat_config(2, GAT_GND);\n\t\toutb(zgat, dev->iobase + PCI230_ZGAT_SCE);\n\t\t \n\t\tpci230_ct_setup_ns_mode(dev, 2, I8254_MODE3, cmd->convert_arg,\n\t\t\t\t\tcmd->flags);\n\t\tif (cmd->scan_begin_src != TRIG_FOLLOW) {\n\t\t\t \n\t\t\tzgat = pci230_gat_config(0, GAT_VCC);\n\t\t\toutb(zgat, dev->iobase + PCI230_ZGAT_SCE);\n\t\t\tpci230_ct_setup_ns_mode(dev, 0, I8254_MODE1,\n\t\t\t\t\t\t((u64)cmd->convert_arg *\n\t\t\t\t\t\t cmd->scan_end_arg),\n\t\t\t\t\t\tCMDF_ROUND_UP);\n\t\t\tif (cmd->scan_begin_src == TRIG_TIMER) {\n\t\t\t\t \n\t\t\t\tzgat = pci230_gat_config(1, GAT_GND);\n\t\t\t\toutb(zgat, dev->iobase + PCI230_ZGAT_SCE);\n\t\t\t\tpci230_ct_setup_ns_mode(dev, 1, I8254_MODE3,\n\t\t\t\t\t\t\tcmd->scan_begin_arg,\n\t\t\t\t\t\t\tcmd->flags);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (cmd->start_src == TRIG_INT)\n\t\ts->async->inttrig = pci230_ai_inttrig_start;\n\telse\t \n\t\tpci230_ai_start(dev, s);\n\n\treturn 0;\n}\n\nstatic int pci230_ai_cancel(struct comedi_device *dev,\n\t\t\t    struct comedi_subdevice *s)\n{\n\tpci230_ai_stop(dev, s);\n\treturn 0;\n}\n\n \nstatic irqreturn_t pci230_interrupt(int irq, void *d)\n{\n\tunsigned char status_int, valid_status_int, temp_ier;\n\tstruct comedi_device *dev = d;\n\tstruct pci230_private *devpriv = dev->private;\n\tstruct comedi_subdevice *s_ao = dev->write_subdev;\n\tstruct comedi_subdevice *s_ai = dev->read_subdev;\n\tunsigned long irqflags;\n\n\t \n\tstatus_int = inb(dev->iobase + PCI230_INT_STAT);\n\n\tif (status_int == PCI230_INT_DISABLE)\n\t\treturn IRQ_NONE;\n\n\tspin_lock_irqsave(&devpriv->isr_spinlock, irqflags);\n\tvalid_status_int = devpriv->ier & status_int;\n\t \n\ttemp_ier = devpriv->ier & ~status_int;\n\toutb(temp_ier, dev->iobase + PCI230_INT_SCE);\n\tdevpriv->intr_running = true;\n\tdevpriv->intr_cpuid = THISCPU;\n\tspin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);\n\n\t \n\n\tif (valid_status_int & PCI230_INT_ZCLK_CT1)\n\t\tpci230_handle_ao_nofifo(dev, s_ao);\n\n\tif (valid_status_int & PCI230P2_INT_DAC)\n\t\tpci230_handle_ao_fifo(dev, s_ao);\n\n\tif (valid_status_int & PCI230_INT_ADC)\n\t\tpci230_handle_ai(dev, s_ai);\n\n\t \n\tspin_lock_irqsave(&devpriv->isr_spinlock, irqflags);\n\tif (devpriv->ier != temp_ier)\n\t\toutb(devpriv->ier, dev->iobase + PCI230_INT_SCE);\n\tdevpriv->intr_running = false;\n\tspin_unlock_irqrestore(&devpriv->isr_spinlock, irqflags);\n\n\tif (s_ao)\n\t\tcomedi_handle_events(dev, s_ao);\n\tcomedi_handle_events(dev, s_ai);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic bool pci230_match_pci_board(const struct pci230_board *board,\n\t\t\t\t   struct pci_dev *pci_dev)\n{\n\t \n\tif (board->id != pci_dev->device)\n\t\treturn false;\n\tif (board->min_hwver == 0)\n\t\treturn true;\n\t \n\tif (pci_resource_len(pci_dev, 3) < 32)\n\t\treturn false;\t \n\t \n\treturn true;\n}\n\n \nstatic const struct pci230_board *pci230_find_pci_board(struct pci_dev *pci_dev)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(pci230_boards); i++)\n\t\tif (pci230_match_pci_board(&pci230_boards[i], pci_dev))\n\t\t\treturn &pci230_boards[i];\n\treturn NULL;\n}\n\nstatic int pci230_auto_attach(struct comedi_device *dev,\n\t\t\t      unsigned long context_unused)\n{\n\tstruct pci_dev *pci_dev = comedi_to_pci_dev(dev);\n\tconst struct pci230_board *board;\n\tstruct pci230_private *devpriv;\n\tstruct comedi_subdevice *s;\n\tint rc;\n\n\tdev_info(dev->class_dev, \"amplc_pci230: attach pci %s\\n\",\n\t\t pci_name(pci_dev));\n\n\tdevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\n\tif (!devpriv)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&devpriv->isr_spinlock);\n\tspin_lock_init(&devpriv->res_spinlock);\n\tspin_lock_init(&devpriv->ai_stop_spinlock);\n\tspin_lock_init(&devpriv->ao_stop_spinlock);\n\n\tboard = pci230_find_pci_board(pci_dev);\n\tif (!board) {\n\t\tdev_err(dev->class_dev,\n\t\t\t\"amplc_pci230: BUG! cannot determine board type!\\n\");\n\t\treturn -EINVAL;\n\t}\n\tdev->board_ptr = board;\n\tdev->board_name = board->name;\n\n\trc = comedi_pci_enable(dev);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tdev->iobase = pci_resource_start(pci_dev, 2);\n\tdevpriv->daqio = pci_resource_start(pci_dev, 3);\n\tdev_dbg(dev->class_dev,\n\t\t\"%s I/O region 1 0x%04lx I/O region 2 0x%04lx\\n\",\n\t\tdev->board_name, dev->iobase, devpriv->daqio);\n\t \n\tdevpriv->daccon = inw(devpriv->daqio + PCI230_DACCON) &\n\t\t\t  PCI230_DAC_OR_MASK;\n\t \n\tif (pci_resource_len(pci_dev, 3) >= 32) {\n\t\tunsigned short extfunc = 0;\n\n\t\tdevpriv->hwver = inw(devpriv->daqio + PCI230P_HWVER);\n\t\tif (devpriv->hwver < board->min_hwver) {\n\t\t\tdev_err(dev->class_dev,\n\t\t\t\t\"%s - bad hardware version - got %u, need %u\\n\",\n\t\t\t\tdev->board_name, devpriv->hwver,\n\t\t\t\tboard->min_hwver);\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (devpriv->hwver > 0) {\n\t\t\tif (!board->have_dio) {\n\t\t\t\t \n\t\t\t\textfunc |= PCI230P_EXTFUNC_GAT_EXTTRIG;\n\t\t\t}\n\t\t\tif (board->ao_bits && devpriv->hwver >= 2) {\n\t\t\t\t \n\t\t\t\textfunc |= PCI230P2_EXTFUNC_DACFIFO;\n\t\t\t}\n\t\t}\n\t\toutw(extfunc, devpriv->daqio + PCI230P_EXTFUNC);\n\t\tif (extfunc & PCI230P2_EXTFUNC_DACFIFO) {\n\t\t\t \n\t\t\toutw(devpriv->daccon | PCI230P2_DAC_FIFO_EN |\n\t\t\t     PCI230P2_DAC_FIFO_RESET,\n\t\t\t     devpriv->daqio + PCI230_DACCON);\n\t\t\t \n\t\t\toutw(0, devpriv->daqio + PCI230P2_DACEN);\n\t\t\t \n\t\t\toutw(devpriv->daccon, devpriv->daqio + PCI230_DACCON);\n\t\t}\n\t}\n\t \n\toutb(0, dev->iobase + PCI230_INT_SCE);\n\t \n\tdevpriv->adcg = 0;\n\tdevpriv->adccon = PCI230_ADC_TRIG_NONE | PCI230_ADC_IM_SE |\n\t\t\t  PCI230_ADC_IR_BIP;\n\toutw(BIT(0), devpriv->daqio + PCI230_ADCEN);\n\toutw(devpriv->adcg, devpriv->daqio + PCI230_ADCG);\n\toutw(devpriv->adccon | PCI230_ADC_FIFO_RESET,\n\t     devpriv->daqio + PCI230_ADCCON);\n\n\tif (pci_dev->irq) {\n\t\trc = request_irq(pci_dev->irq, pci230_interrupt, IRQF_SHARED,\n\t\t\t\t dev->board_name, dev);\n\t\tif (rc == 0)\n\t\t\tdev->irq = pci_dev->irq;\n\t}\n\n\tdev->pacer = comedi_8254_init(dev->iobase + PCI230_Z2_CT_BASE,\n\t\t\t\t      0, I8254_IO8, 0);\n\tif (!dev->pacer)\n\t\treturn -ENOMEM;\n\n\trc = comedi_alloc_subdevices(dev, 3);\n\tif (rc)\n\t\treturn rc;\n\n\ts = &dev->subdevices[0];\n\t \n\ts->type = COMEDI_SUBD_AI;\n\ts->subdev_flags = SDF_READABLE | SDF_DIFF | SDF_GROUND;\n\ts->n_chan = 16;\n\ts->maxdata = (1 << board->ai_bits) - 1;\n\ts->range_table = &pci230_ai_range;\n\ts->insn_read = pci230_ai_insn_read;\n\ts->len_chanlist = 256;\t \n\tif (dev->irq) {\n\t\tdev->read_subdev = s;\n\t\ts->subdev_flags |= SDF_CMD_READ;\n\t\ts->do_cmd = pci230_ai_cmd;\n\t\ts->do_cmdtest = pci230_ai_cmdtest;\n\t\ts->cancel = pci230_ai_cancel;\n\t}\n\n\ts = &dev->subdevices[1];\n\t \n\tif (board->ao_bits) {\n\t\ts->type = COMEDI_SUBD_AO;\n\t\ts->subdev_flags = SDF_WRITABLE | SDF_GROUND;\n\t\ts->n_chan = 2;\n\t\ts->maxdata = (1 << board->ao_bits) - 1;\n\t\ts->range_table = &pci230_ao_range;\n\t\ts->insn_write = pci230_ao_insn_write;\n\t\ts->len_chanlist = 2;\n\t\tif (dev->irq) {\n\t\t\tdev->write_subdev = s;\n\t\t\ts->subdev_flags |= SDF_CMD_WRITE;\n\t\t\ts->do_cmd = pci230_ao_cmd;\n\t\t\ts->do_cmdtest = pci230_ao_cmdtest;\n\t\t\ts->cancel = pci230_ao_cancel;\n\t\t}\n\n\t\trc = comedi_alloc_subdev_readback(s);\n\t\tif (rc)\n\t\t\treturn rc;\n\t} else {\n\t\ts->type = COMEDI_SUBD_UNUSED;\n\t}\n\n\ts = &dev->subdevices[2];\n\t \n\tif (board->have_dio) {\n\t\trc = subdev_8255_init(dev, s, NULL, PCI230_PPI_X_BASE);\n\t\tif (rc)\n\t\t\treturn rc;\n\t} else {\n\t\ts->type = COMEDI_SUBD_UNUSED;\n\t}\n\n\treturn 0;\n}\n\nstatic struct comedi_driver amplc_pci230_driver = {\n\t.driver_name\t= \"amplc_pci230\",\n\t.module\t\t= THIS_MODULE,\n\t.auto_attach\t= pci230_auto_attach,\n\t.detach\t\t= comedi_pci_detach,\n};\n\nstatic int amplc_pci230_pci_probe(struct pci_dev *dev,\n\t\t\t\t  const struct pci_device_id *id)\n{\n\treturn comedi_pci_auto_config(dev, &amplc_pci230_driver,\n\t\t\t\t      id->driver_data);\n}\n\nstatic const struct pci_device_id amplc_pci230_pci_table[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_PCI230) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMPLICON, PCI_DEVICE_ID_PCI260) },\n\t{ 0 }\n};\nMODULE_DEVICE_TABLE(pci, amplc_pci230_pci_table);\n\nstatic struct pci_driver amplc_pci230_pci_driver = {\n\t.name\t\t= \"amplc_pci230\",\n\t.id_table\t= amplc_pci230_pci_table,\n\t.probe\t\t= amplc_pci230_pci_probe,\n\t.remove\t\t= comedi_pci_auto_unconfig,\n};\nmodule_comedi_pci_driver(amplc_pci230_driver, amplc_pci230_pci_driver);\n\nMODULE_AUTHOR(\"Comedi https://www.comedi.org\");\nMODULE_DESCRIPTION(\"Comedi driver for Amplicon PCI230(+) and PCI260(+)\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}