{
  "module_name": "comedi_bond.c",
  "hash_id": "54acfb331117125a86bd1c3cb686f0f45d44cededd535c05b58a24c93aaa0d9b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/comedi_bond.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/comedi.h>\n#include <linux/comedi/comedilib.h>\n#include <linux/comedi/comedidev.h>\n\nstruct bonded_device {\n\tstruct comedi_device *dev;\n\tunsigned int minor;\n\tunsigned int subdev;\n\tunsigned int nchans;\n};\n\nstruct comedi_bond_private {\n\tchar name[256];\n\tstruct bonded_device **devs;\n\tunsigned int ndevs;\n\tunsigned int nchans;\n};\n\nstatic int bonding_dio_insn_bits(struct comedi_device *dev,\n\t\t\t\t struct comedi_subdevice *s,\n\t\t\t\t struct comedi_insn *insn, unsigned int *data)\n{\n\tstruct comedi_bond_private *devpriv = dev->private;\n\tunsigned int n_left, n_done, base_chan;\n\tunsigned int write_mask, data_bits;\n\tstruct bonded_device **devs;\n\n\twrite_mask = data[0];\n\tdata_bits = data[1];\n\tbase_chan = CR_CHAN(insn->chanspec);\n\t \n\tn_left = devpriv->nchans - base_chan;\n\tif (n_left > 32)\n\t\tn_left = 32;\n\n\tn_done = 0;\n\tdevs = devpriv->devs;\n\tdo {\n\t\tstruct bonded_device *bdev = *devs++;\n\n\t\tif (base_chan < bdev->nchans) {\n\t\t\t \n\t\t\tunsigned int b_chans, b_mask, b_write_mask, b_data_bits;\n\t\t\tint ret;\n\n\t\t\t \n\t\t\tb_chans = bdev->nchans - base_chan;\n\t\t\tif (b_chans > n_left)\n\t\t\t\tb_chans = n_left;\n\t\t\tb_mask = (b_chans < 32) ? ((1 << b_chans) - 1)\n\t\t\t\t\t\t: 0xffffffff;\n\t\t\tb_write_mask = (write_mask >> n_done) & b_mask;\n\t\t\tb_data_bits = (data_bits >> n_done) & b_mask;\n\t\t\t \n\t\t\tret = comedi_dio_bitfield2(bdev->dev, bdev->subdev,\n\t\t\t\t\t\t   b_write_mask, &b_data_bits,\n\t\t\t\t\t\t   base_chan);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\t \n\t\t\tdata[1] &= ~(b_mask << n_done);\n\t\t\tdata[1] |= (b_data_bits & b_mask) << n_done;\n\t\t\t \n\t\t\tbase_chan = 0;\n\t\t\tn_done += b_chans;\n\t\t\tn_left -= b_chans;\n\t\t} else {\n\t\t\t \n\t\t\tbase_chan -= bdev->nchans;\n\t\t}\n\t} while (n_left);\n\n\treturn insn->n;\n}\n\nstatic int bonding_dio_insn_config(struct comedi_device *dev,\n\t\t\t\t   struct comedi_subdevice *s,\n\t\t\t\t   struct comedi_insn *insn, unsigned int *data)\n{\n\tstruct comedi_bond_private *devpriv = dev->private;\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tint ret;\n\tstruct bonded_device *bdev;\n\tstruct bonded_device **devs;\n\n\t \n\tdevs = devpriv->devs;\n\tfor (bdev = *devs++; chan >= bdev->nchans; bdev = *devs++)\n\t\tchan -= bdev->nchans;\n\n\t \n\tswitch (data[0]) {\n\tcase INSN_CONFIG_DIO_OUTPUT:\n\tcase INSN_CONFIG_DIO_INPUT:\n\t\tret = comedi_dio_config(bdev->dev, bdev->subdev, chan, data[0]);\n\t\tbreak;\n\tcase INSN_CONFIG_DIO_QUERY:\n\t\tret = comedi_dio_get_config(bdev->dev, bdev->subdev, chan,\n\t\t\t\t\t    &data[1]);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\tif (ret >= 0)\n\t\tret = insn->n;\n\treturn ret;\n}\n\nstatic int do_dev_config(struct comedi_device *dev, struct comedi_devconfig *it)\n{\n\tstruct comedi_bond_private *devpriv = dev->private;\n\tDECLARE_BITMAP(devs_opened, COMEDI_NUM_BOARD_MINORS);\n\tint i;\n\n\tmemset(&devs_opened, 0, sizeof(devs_opened));\n\tdevpriv->name[0] = 0;\n\t \n\tfor (i = 0; i < COMEDI_NDEVCONFOPTS && (!i || it->options[i]); ++i) {\n\t\tchar file[sizeof(\"/dev/comediXXXXXX\")];\n\t\tint minor = it->options[i];\n\t\tstruct comedi_device *d;\n\t\tint sdev = -1, nchans;\n\t\tstruct bonded_device *bdev;\n\t\tstruct bonded_device **devs;\n\n\t\tif (minor < 0 || minor >= COMEDI_NUM_BOARD_MINORS) {\n\t\t\tdev_err(dev->class_dev,\n\t\t\t\t\"Minor %d is invalid!\\n\", minor);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (minor == dev->minor) {\n\t\t\tdev_err(dev->class_dev,\n\t\t\t\t\"Cannot bond this driver to itself!\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (test_and_set_bit(minor, devs_opened)) {\n\t\t\tdev_err(dev->class_dev,\n\t\t\t\t\"Minor %d specified more than once!\\n\", minor);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tsnprintf(file, sizeof(file), \"/dev/comedi%d\", minor);\n\t\tfile[sizeof(file) - 1] = 0;\n\n\t\td = comedi_open(file);\n\n\t\tif (!d) {\n\t\t\tdev_err(dev->class_dev,\n\t\t\t\t\"Minor %u could not be opened\\n\", minor);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\t \n\t\twhile ((sdev = comedi_find_subdevice_by_type(d, COMEDI_SUBD_DIO,\n\t\t\t\t\t\t\t     sdev + 1)) > -1) {\n\t\t\tnchans = comedi_get_n_channels(d, sdev);\n\t\t\tif (nchans <= 0) {\n\t\t\t\tdev_err(dev->class_dev,\n\t\t\t\t\t\"comedi_get_n_channels() returned %d on minor %u subdev %d!\\n\",\n\t\t\t\t\tnchans, minor, sdev);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbdev = kmalloc(sizeof(*bdev), GFP_KERNEL);\n\t\t\tif (!bdev)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tbdev->dev = d;\n\t\t\tbdev->minor = minor;\n\t\t\tbdev->subdev = sdev;\n\t\t\tbdev->nchans = nchans;\n\t\t\tdevpriv->nchans += nchans;\n\n\t\t\t \n\n\t\t\t \n\t\t\tdevs = krealloc(devpriv->devs,\n\t\t\t\t\t(devpriv->ndevs + 1) * sizeof(*devs),\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!devs) {\n\t\t\t\tdev_err(dev->class_dev,\n\t\t\t\t\t\"Could not allocate memory. Out of memory?\\n\");\n\t\t\t\tkfree(bdev);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tdevpriv->devs = devs;\n\t\t\tdevpriv->devs[devpriv->ndevs++] = bdev;\n\t\t\t{\n\t\t\t\t \n\t\t\t\tchar buf[20];\n\n\t\t\t\tsnprintf(buf, sizeof(buf), \"%u:%u \",\n\t\t\t\t\t bdev->minor, bdev->subdev);\n\t\t\t\tstrlcat(devpriv->name, buf,\n\t\t\t\t\tsizeof(devpriv->name));\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!devpriv->nchans) {\n\t\tdev_err(dev->class_dev, \"No channels found!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int bonding_attach(struct comedi_device *dev,\n\t\t\t  struct comedi_devconfig *it)\n{\n\tstruct comedi_bond_private *devpriv;\n\tstruct comedi_subdevice *s;\n\tint ret;\n\n\tdevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\n\tif (!devpriv)\n\t\treturn -ENOMEM;\n\n\t \n\tret = do_dev_config(dev, it);\n\tif (ret)\n\t\treturn ret;\n\n\tdev->board_name = devpriv->name;\n\n\tret = comedi_alloc_subdevices(dev, 1);\n\tif (ret)\n\t\treturn ret;\n\n\ts = &dev->subdevices[0];\n\ts->type = COMEDI_SUBD_DIO;\n\ts->subdev_flags = SDF_READABLE | SDF_WRITABLE;\n\ts->n_chan = devpriv->nchans;\n\ts->maxdata = 1;\n\ts->range_table = &range_digital;\n\ts->insn_bits = bonding_dio_insn_bits;\n\ts->insn_config = bonding_dio_insn_config;\n\n\tdev_info(dev->class_dev,\n\t\t \"%s: %s attached, %u channels from %u devices\\n\",\n\t\t dev->driver->driver_name, dev->board_name,\n\t\t devpriv->nchans, devpriv->ndevs);\n\n\treturn 0;\n}\n\nstatic void bonding_detach(struct comedi_device *dev)\n{\n\tstruct comedi_bond_private *devpriv = dev->private;\n\n\tif (devpriv && devpriv->devs) {\n\t\tDECLARE_BITMAP(devs_closed, COMEDI_NUM_BOARD_MINORS);\n\n\t\tmemset(&devs_closed, 0, sizeof(devs_closed));\n\t\twhile (devpriv->ndevs--) {\n\t\t\tstruct bonded_device *bdev;\n\n\t\t\tbdev = devpriv->devs[devpriv->ndevs];\n\t\t\tif (!bdev)\n\t\t\t\tcontinue;\n\t\t\tif (!test_and_set_bit(bdev->minor, devs_closed))\n\t\t\t\tcomedi_close(bdev->dev);\n\t\t\tkfree(bdev);\n\t\t}\n\t\tkfree(devpriv->devs);\n\t\tdevpriv->devs = NULL;\n\t}\n}\n\nstatic struct comedi_driver bonding_driver = {\n\t.driver_name\t= \"comedi_bond\",\n\t.module\t\t= THIS_MODULE,\n\t.attach\t\t= bonding_attach,\n\t.detach\t\t= bonding_detach,\n};\nmodule_comedi_driver(bonding_driver);\n\nMODULE_AUTHOR(\"Calin A. Culianu\");\nMODULE_DESCRIPTION(\"comedi_bond: A driver for COMEDI to bond multiple COMEDI devices together as one.\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}