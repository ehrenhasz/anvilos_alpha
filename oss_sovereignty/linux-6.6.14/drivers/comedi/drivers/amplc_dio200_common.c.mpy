{
  "module_name": "amplc_dio200_common.c",
  "hash_id": "17ecd811cd9368ee87855e29ec1649bdcdb5f5c5df277cd71450a5355cf02355",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/amplc_dio200_common.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/comedi/comedidev.h>\n#include <linux/comedi/comedi_8255.h>\t \n#include <linux/comedi/comedi_8254.h>\n\n#include \"amplc_dio200.h\"\n\n \n#define DIO200_IO_SIZE\t\t0x20\n#define DIO200_PCIE_IO_SIZE\t0x4000\n#define DIO200_CLK_SCE(x)\t(0x18 + (x))\t \n#define DIO200_GAT_SCE(x)\t(0x1b + (x))\t \n#define DIO200_INT_SCE\t\t0x1e\t \n \n#define DIO200_ENHANCE\t\t0x20\t \n#define DIO200_VERSION\t\t0x24\t \n#define DIO200_TS_CONFIG\t0x600\t \n#define DIO200_TS_COUNT\t\t0x602\t \n\n \nstatic unsigned char clk_gat_sce(unsigned int which, unsigned int chan,\n\t\t\t\t unsigned int source)\n{\n\treturn (which << 5) | (chan << 3) |\n\t       ((source & 030) << 3) | (source & 007);\n}\n\n \nstatic const unsigned int clock_period[32] = {\n\t[1] = 100,\t\t \n\t[2] = 1000,\t\t \n\t[3] = 10000,\t\t \n\t[4] = 100000,\t\t \n\t[5] = 1000000,\t\t \n\t[11] = 50,\t\t \n\t \n};\n\n \n#define TS_CONFIG_RESET\t\t0x100\t \n#define TS_CONFIG_CLK_SRC_MASK\t0x0FF\t \n#define TS_CONFIG_MAX_CLK_SRC\t2\t \n\n \nstatic const unsigned int ts_clock_period[TS_CONFIG_MAX_CLK_SRC + 1] = {\n\t1,\t\t\t \n\t1000,\t\t\t \n\t1000000,\t\t \n};\n\nstruct dio200_subdev_8255 {\n\tunsigned int ofs;\t\t \n};\n\nstruct dio200_subdev_intr {\n\tspinlock_t spinlock;\t \n\tunsigned int ofs;\n\tunsigned int valid_isns;\n\tunsigned int enabled_isns;\n\tunsigned int active:1;\n};\n\nstatic unsigned char dio200_read8(struct comedi_device *dev,\n\t\t\t\t  unsigned int offset)\n{\n\tconst struct dio200_board *board = dev->board_ptr;\n\n\tif (board->is_pcie)\n\t\toffset <<= 3;\n\n\tif (dev->mmio)\n\t\treturn readb(dev->mmio + offset);\n\treturn inb(dev->iobase + offset);\n}\n\nstatic void dio200_write8(struct comedi_device *dev,\n\t\t\t  unsigned int offset, unsigned char val)\n{\n\tconst struct dio200_board *board = dev->board_ptr;\n\n\tif (board->is_pcie)\n\t\toffset <<= 3;\n\n\tif (dev->mmio)\n\t\twriteb(val, dev->mmio + offset);\n\telse\n\t\toutb(val, dev->iobase + offset);\n}\n\nstatic unsigned int dio200_read32(struct comedi_device *dev,\n\t\t\t\t  unsigned int offset)\n{\n\tconst struct dio200_board *board = dev->board_ptr;\n\n\tif (board->is_pcie)\n\t\toffset <<= 3;\n\n\tif (dev->mmio)\n\t\treturn readl(dev->mmio + offset);\n\treturn inl(dev->iobase + offset);\n}\n\nstatic void dio200_write32(struct comedi_device *dev,\n\t\t\t   unsigned int offset, unsigned int val)\n{\n\tconst struct dio200_board *board = dev->board_ptr;\n\n\tif (board->is_pcie)\n\t\toffset <<= 3;\n\n\tif (dev->mmio)\n\t\twritel(val, dev->mmio + offset);\n\telse\n\t\toutl(val, dev->iobase + offset);\n}\n\nstatic unsigned int dio200_subdev_8254_offset(struct comedi_device *dev,\n\t\t\t\t\t      struct comedi_subdevice *s)\n{\n\tconst struct dio200_board *board = dev->board_ptr;\n\tstruct comedi_8254 *i8254 = s->private;\n\tunsigned int offset;\n\n\t \n\tif (dev->mmio)\n\t\toffset = i8254->mmio - dev->mmio;\n\telse\n\t\toffset = i8254->iobase - dev->iobase;\n\n\t \n\tif (board->is_pcie)\n\t\toffset >>= 3;\n\n\t \n\treturn offset;\n}\n\nstatic int dio200_subdev_intr_insn_bits(struct comedi_device *dev,\n\t\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\t\tstruct comedi_insn *insn,\n\t\t\t\t\tunsigned int *data)\n{\n\tconst struct dio200_board *board = dev->board_ptr;\n\tstruct dio200_subdev_intr *subpriv = s->private;\n\n\tif (board->has_int_sce) {\n\t\t \n\t\tdata[1] = dio200_read8(dev, subpriv->ofs) & subpriv->valid_isns;\n\t} else {\n\t\t \n\t\tdata[0] = 0;\n\t}\n\n\treturn insn->n;\n}\n\nstatic void dio200_stop_intr(struct comedi_device *dev,\n\t\t\t     struct comedi_subdevice *s)\n{\n\tconst struct dio200_board *board = dev->board_ptr;\n\tstruct dio200_subdev_intr *subpriv = s->private;\n\n\tsubpriv->active = false;\n\tsubpriv->enabled_isns = 0;\n\tif (board->has_int_sce)\n\t\tdio200_write8(dev, subpriv->ofs, 0);\n}\n\nstatic void dio200_start_intr(struct comedi_device *dev,\n\t\t\t      struct comedi_subdevice *s)\n{\n\tconst struct dio200_board *board = dev->board_ptr;\n\tstruct dio200_subdev_intr *subpriv = s->private;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tunsigned int n;\n\tunsigned int isn_bits;\n\n\t \n\tisn_bits = 0;\n\tif (cmd->chanlist) {\n\t\tfor (n = 0; n < cmd->chanlist_len; n++)\n\t\t\tisn_bits |= (1U << CR_CHAN(cmd->chanlist[n]));\n\t}\n\tisn_bits &= subpriv->valid_isns;\n\t \n\tsubpriv->enabled_isns = isn_bits;\n\tif (board->has_int_sce)\n\t\tdio200_write8(dev, subpriv->ofs, isn_bits);\n}\n\nstatic int dio200_inttrig_start_intr(struct comedi_device *dev,\n\t\t\t\t     struct comedi_subdevice *s,\n\t\t\t\t     unsigned int trig_num)\n{\n\tstruct dio200_subdev_intr *subpriv = s->private;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tunsigned long flags;\n\n\tif (trig_num != cmd->start_arg)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&subpriv->spinlock, flags);\n\ts->async->inttrig = NULL;\n\tif (subpriv->active)\n\t\tdio200_start_intr(dev, s);\n\n\tspin_unlock_irqrestore(&subpriv->spinlock, flags);\n\n\treturn 1;\n}\n\nstatic void dio200_read_scan_intr(struct comedi_device *dev,\n\t\t\t\t  struct comedi_subdevice *s,\n\t\t\t\t  unsigned int triggered)\n{\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tunsigned short val;\n\tunsigned int n, ch;\n\n\tval = 0;\n\tfor (n = 0; n < cmd->chanlist_len; n++) {\n\t\tch = CR_CHAN(cmd->chanlist[n]);\n\t\tif (triggered & (1U << ch))\n\t\t\tval |= (1U << n);\n\t}\n\n\tcomedi_buf_write_samples(s, &val, 1);\n\n\tif (cmd->stop_src == TRIG_COUNT &&\n\t    s->async->scans_done >= cmd->stop_arg)\n\t\ts->async->events |= COMEDI_CB_EOA;\n}\n\nstatic int dio200_handle_read_intr(struct comedi_device *dev,\n\t\t\t\t   struct comedi_subdevice *s)\n{\n\tconst struct dio200_board *board = dev->board_ptr;\n\tstruct dio200_subdev_intr *subpriv = s->private;\n\tunsigned int triggered;\n\tunsigned int intstat;\n\tunsigned int cur_enabled;\n\tunsigned long flags;\n\n\ttriggered = 0;\n\n\tspin_lock_irqsave(&subpriv->spinlock, flags);\n\tif (board->has_int_sce) {\n\t\t \n\t\tcur_enabled = subpriv->enabled_isns;\n\t\twhile ((intstat = (dio200_read8(dev, subpriv->ofs) &\n\t\t\t\t   subpriv->valid_isns & ~triggered)) != 0) {\n\t\t\ttriggered |= intstat;\n\t\t\tcur_enabled &= ~triggered;\n\t\t\tdio200_write8(dev, subpriv->ofs, cur_enabled);\n\t\t}\n\t} else {\n\t\t \n\t\ttriggered = subpriv->enabled_isns;\n\t}\n\n\tif (triggered) {\n\t\t \n\t\tcur_enabled = subpriv->enabled_isns;\n\t\tif (board->has_int_sce)\n\t\t\tdio200_write8(dev, subpriv->ofs, cur_enabled);\n\n\t\tif (subpriv->active) {\n\t\t\t \n\t\t\tif (triggered & subpriv->enabled_isns) {\n\t\t\t\t \n\t\t\t\tdio200_read_scan_intr(dev, s, triggered);\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&subpriv->spinlock, flags);\n\n\tcomedi_handle_events(dev, s);\n\n\treturn (triggered != 0);\n}\n\nstatic int dio200_subdev_intr_cancel(struct comedi_device *dev,\n\t\t\t\t     struct comedi_subdevice *s)\n{\n\tstruct dio200_subdev_intr *subpriv = s->private;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&subpriv->spinlock, flags);\n\tif (subpriv->active)\n\t\tdio200_stop_intr(dev, s);\n\n\tspin_unlock_irqrestore(&subpriv->spinlock, flags);\n\n\treturn 0;\n}\n\nstatic int dio200_subdev_intr_cmdtest(struct comedi_device *dev,\n\t\t\t\t      struct comedi_subdevice *s,\n\t\t\t\t      struct comedi_cmd *cmd)\n{\n\tint err = 0;\n\n\t \n\n\terr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_INT);\n\terr |= comedi_check_trigger_src(&cmd->scan_begin_src, TRIG_EXT);\n\terr |= comedi_check_trigger_src(&cmd->convert_src, TRIG_NOW);\n\terr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\n\terr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\n\n\tif (err)\n\t\treturn 1;\n\n\t \n\n\terr |= comedi_check_trigger_is_unique(cmd->start_src);\n\terr |= comedi_check_trigger_is_unique(cmd->stop_src);\n\n\t \n\n\tif (err)\n\t\treturn 2;\n\n\t \n\n\terr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);\n\terr |= comedi_check_trigger_arg_is(&cmd->convert_arg, 0);\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\n\t\t\t\t\t   cmd->chanlist_len);\n\n\tif (cmd->stop_src == TRIG_COUNT)\n\t\terr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\n\telse\t \n\t\terr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\n\n\tif (err)\n\t\treturn 3;\n\n\t \n\n\t \n\n\treturn 0;\n}\n\nstatic int dio200_subdev_intr_cmd(struct comedi_device *dev,\n\t\t\t\t  struct comedi_subdevice *s)\n{\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tstruct dio200_subdev_intr *subpriv = s->private;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&subpriv->spinlock, flags);\n\n\tsubpriv->active = true;\n\n\tif (cmd->start_src == TRIG_INT)\n\t\ts->async->inttrig = dio200_inttrig_start_intr;\n\telse\t \n\t\tdio200_start_intr(dev, s);\n\n\tspin_unlock_irqrestore(&subpriv->spinlock, flags);\n\n\treturn 0;\n}\n\nstatic int dio200_subdev_intr_init(struct comedi_device *dev,\n\t\t\t\t   struct comedi_subdevice *s,\n\t\t\t\t   unsigned int offset,\n\t\t\t\t   unsigned int valid_isns)\n{\n\tconst struct dio200_board *board = dev->board_ptr;\n\tstruct dio200_subdev_intr *subpriv;\n\n\tsubpriv = comedi_alloc_spriv(s, sizeof(*subpriv));\n\tif (!subpriv)\n\t\treturn -ENOMEM;\n\n\tsubpriv->ofs = offset;\n\tsubpriv->valid_isns = valid_isns;\n\tspin_lock_init(&subpriv->spinlock);\n\n\tif (board->has_int_sce)\n\t\t \n\t\tdio200_write8(dev, subpriv->ofs, 0);\n\n\ts->type = COMEDI_SUBD_DI;\n\ts->subdev_flags = SDF_READABLE | SDF_CMD_READ | SDF_PACKED;\n\tif (board->has_int_sce) {\n\t\ts->n_chan = DIO200_MAX_ISNS;\n\t\ts->len_chanlist = DIO200_MAX_ISNS;\n\t} else {\n\t\t \n\t\ts->n_chan = 1;\n\t\ts->len_chanlist = 1;\n\t}\n\ts->range_table = &range_digital;\n\ts->maxdata = 1;\n\ts->insn_bits = dio200_subdev_intr_insn_bits;\n\ts->do_cmdtest = dio200_subdev_intr_cmdtest;\n\ts->do_cmd = dio200_subdev_intr_cmd;\n\ts->cancel = dio200_subdev_intr_cancel;\n\n\treturn 0;\n}\n\nstatic irqreturn_t dio200_interrupt(int irq, void *d)\n{\n\tstruct comedi_device *dev = d;\n\tstruct comedi_subdevice *s = dev->read_subdev;\n\tint handled;\n\n\tif (!dev->attached)\n\t\treturn IRQ_NONE;\n\n\thandled = dio200_handle_read_intr(dev, s);\n\n\treturn IRQ_RETVAL(handled);\n}\n\nstatic void dio200_subdev_8254_set_gate_src(struct comedi_device *dev,\n\t\t\t\t\t    struct comedi_subdevice *s,\n\t\t\t\t\t    unsigned int chan,\n\t\t\t\t\t    unsigned int src)\n{\n\tunsigned int offset = dio200_subdev_8254_offset(dev, s);\n\n\tdio200_write8(dev, DIO200_GAT_SCE(offset >> 3),\n\t\t      clk_gat_sce((offset >> 2) & 1, chan, src));\n}\n\nstatic void dio200_subdev_8254_set_clock_src(struct comedi_device *dev,\n\t\t\t\t\t     struct comedi_subdevice *s,\n\t\t\t\t\t     unsigned int chan,\n\t\t\t\t\t     unsigned int src)\n{\n\tunsigned int offset = dio200_subdev_8254_offset(dev, s);\n\n\tdio200_write8(dev, DIO200_CLK_SCE(offset >> 3),\n\t\t      clk_gat_sce((offset >> 2) & 1, chan, src));\n}\n\nstatic int dio200_subdev_8254_config(struct comedi_device *dev,\n\t\t\t\t     struct comedi_subdevice *s,\n\t\t\t\t     struct comedi_insn *insn,\n\t\t\t\t     unsigned int *data)\n{\n\tconst struct dio200_board *board = dev->board_ptr;\n\tstruct comedi_8254 *i8254 = s->private;\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int max_src = board->is_pcie ? 31 : 7;\n\tunsigned int src;\n\n\tif (!board->has_clk_gat_sce)\n\t\treturn -EINVAL;\n\n\tswitch (data[0]) {\n\tcase INSN_CONFIG_SET_GATE_SRC:\n\t\tsrc = data[2];\n\t\tif (src > max_src)\n\t\t\treturn -EINVAL;\n\n\t\tdio200_subdev_8254_set_gate_src(dev, s, chan, src);\n\t\ti8254->gate_src[chan] = src;\n\t\tbreak;\n\tcase INSN_CONFIG_GET_GATE_SRC:\n\t\tdata[2] = i8254->gate_src[chan];\n\t\tbreak;\n\tcase INSN_CONFIG_SET_CLOCK_SRC:\n\t\tsrc = data[1];\n\t\tif (src > max_src)\n\t\t\treturn -EINVAL;\n\n\t\tdio200_subdev_8254_set_clock_src(dev, s, chan, src);\n\t\ti8254->clock_src[chan] = src;\n\t\tbreak;\n\tcase INSN_CONFIG_GET_CLOCK_SRC:\n\t\tdata[1] = i8254->clock_src[chan];\n\t\tdata[2] = clock_period[i8254->clock_src[chan]];\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn insn->n;\n}\n\nstatic int dio200_subdev_8254_init(struct comedi_device *dev,\n\t\t\t\t   struct comedi_subdevice *s,\n\t\t\t\t   unsigned int offset)\n{\n\tconst struct dio200_board *board = dev->board_ptr;\n\tstruct comedi_8254 *i8254;\n\tunsigned int regshift;\n\tint chan;\n\n\t \n\tif (board->is_pcie) {\n\t\toffset <<= 3;\n\t\tregshift = 3;\n\t} else {\n\t\tregshift = 0;\n\t}\n\n\tif (dev->mmio) {\n\t\ti8254 = comedi_8254_mm_init(dev->mmio + offset,\n\t\t\t\t\t    0, I8254_IO8, regshift);\n\t} else {\n\t\ti8254 = comedi_8254_init(dev->iobase + offset,\n\t\t\t\t\t 0, I8254_IO8, regshift);\n\t}\n\tif (!i8254)\n\t\treturn -ENOMEM;\n\n\tcomedi_8254_subdevice_init(s, i8254);\n\n\ti8254->insn_config = dio200_subdev_8254_config;\n\n\t \n\tcomedi_set_spriv_auto_free(s);\n\n\t \n\tif (board->has_clk_gat_sce) {\n\t\tfor (chan = 0; chan < 3; chan++) {\n\t\t\t \n\t\t\tdio200_subdev_8254_set_gate_src(dev, s, chan, 0);\n\t\t\t \n\t\t\tdio200_subdev_8254_set_clock_src(dev, s, chan, 0);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void dio200_subdev_8255_set_dir(struct comedi_device *dev,\n\t\t\t\t       struct comedi_subdevice *s)\n{\n\tstruct dio200_subdev_8255 *subpriv = s->private;\n\tint config;\n\n\tconfig = I8255_CTRL_CW;\n\t \n\tif (!(s->io_bits & 0x0000ff))\n\t\tconfig |= I8255_CTRL_A_IO;\n\tif (!(s->io_bits & 0x00ff00))\n\t\tconfig |= I8255_CTRL_B_IO;\n\tif (!(s->io_bits & 0x0f0000))\n\t\tconfig |= I8255_CTRL_C_LO_IO;\n\tif (!(s->io_bits & 0xf00000))\n\t\tconfig |= I8255_CTRL_C_HI_IO;\n\tdio200_write8(dev, subpriv->ofs + I8255_CTRL_REG, config);\n}\n\nstatic int dio200_subdev_8255_bits(struct comedi_device *dev,\n\t\t\t\t   struct comedi_subdevice *s,\n\t\t\t\t   struct comedi_insn *insn,\n\t\t\t\t   unsigned int *data)\n{\n\tstruct dio200_subdev_8255 *subpriv = s->private;\n\tunsigned int mask;\n\tunsigned int val;\n\n\tmask = comedi_dio_update_state(s, data);\n\tif (mask) {\n\t\tif (mask & 0xff) {\n\t\t\tdio200_write8(dev, subpriv->ofs + I8255_DATA_A_REG,\n\t\t\t\t      s->state & 0xff);\n\t\t}\n\t\tif (mask & 0xff00) {\n\t\t\tdio200_write8(dev, subpriv->ofs + I8255_DATA_B_REG,\n\t\t\t\t      (s->state >> 8) & 0xff);\n\t\t}\n\t\tif (mask & 0xff0000) {\n\t\t\tdio200_write8(dev, subpriv->ofs + I8255_DATA_C_REG,\n\t\t\t\t      (s->state >> 16) & 0xff);\n\t\t}\n\t}\n\n\tval = dio200_read8(dev, subpriv->ofs + I8255_DATA_A_REG);\n\tval |= dio200_read8(dev, subpriv->ofs + I8255_DATA_B_REG) << 8;\n\tval |= dio200_read8(dev, subpriv->ofs + I8255_DATA_C_REG) << 16;\n\n\tdata[1] = val;\n\n\treturn insn->n;\n}\n\nstatic int dio200_subdev_8255_config(struct comedi_device *dev,\n\t\t\t\t     struct comedi_subdevice *s,\n\t\t\t\t     struct comedi_insn *insn,\n\t\t\t\t     unsigned int *data)\n{\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int mask;\n\tint ret;\n\n\tif (chan < 8)\n\t\tmask = 0x0000ff;\n\telse if (chan < 16)\n\t\tmask = 0x00ff00;\n\telse if (chan < 20)\n\t\tmask = 0x0f0000;\n\telse\n\t\tmask = 0xf00000;\n\n\tret = comedi_dio_insn_config(dev, s, insn, data, mask);\n\tif (ret)\n\t\treturn ret;\n\n\tdio200_subdev_8255_set_dir(dev, s);\n\n\treturn insn->n;\n}\n\nstatic int dio200_subdev_8255_init(struct comedi_device *dev,\n\t\t\t\t   struct comedi_subdevice *s,\n\t\t\t\t   unsigned int offset)\n{\n\tstruct dio200_subdev_8255 *subpriv;\n\n\tsubpriv = comedi_alloc_spriv(s, sizeof(*subpriv));\n\tif (!subpriv)\n\t\treturn -ENOMEM;\n\n\tsubpriv->ofs = offset;\n\n\ts->type = COMEDI_SUBD_DIO;\n\ts->subdev_flags = SDF_READABLE | SDF_WRITABLE;\n\ts->n_chan = 24;\n\ts->range_table = &range_digital;\n\ts->maxdata = 1;\n\ts->insn_bits = dio200_subdev_8255_bits;\n\ts->insn_config = dio200_subdev_8255_config;\n\tdio200_subdev_8255_set_dir(dev, s);\n\treturn 0;\n}\n\nstatic int dio200_subdev_timer_read(struct comedi_device *dev,\n\t\t\t\t    struct comedi_subdevice *s,\n\t\t\t\t    struct comedi_insn *insn,\n\t\t\t\t    unsigned int *data)\n{\n\tunsigned int n;\n\n\tfor (n = 0; n < insn->n; n++)\n\t\tdata[n] = dio200_read32(dev, DIO200_TS_COUNT);\n\treturn n;\n}\n\nstatic void dio200_subdev_timer_reset(struct comedi_device *dev,\n\t\t\t\t      struct comedi_subdevice *s)\n{\n\tunsigned int clock;\n\n\tclock = dio200_read32(dev, DIO200_TS_CONFIG) & TS_CONFIG_CLK_SRC_MASK;\n\tdio200_write32(dev, DIO200_TS_CONFIG, clock | TS_CONFIG_RESET);\n\tdio200_write32(dev, DIO200_TS_CONFIG, clock);\n}\n\nstatic void dio200_subdev_timer_get_clock_src(struct comedi_device *dev,\n\t\t\t\t\t      struct comedi_subdevice *s,\n\t\t\t\t\t      unsigned int *src,\n\t\t\t\t\t      unsigned int *period)\n{\n\tunsigned int clk;\n\n\tclk = dio200_read32(dev, DIO200_TS_CONFIG) & TS_CONFIG_CLK_SRC_MASK;\n\t*src = clk;\n\t*period = (clk < ARRAY_SIZE(ts_clock_period)) ?\n\t\t  ts_clock_period[clk] : 0;\n}\n\nstatic int dio200_subdev_timer_set_clock_src(struct comedi_device *dev,\n\t\t\t\t\t     struct comedi_subdevice *s,\n\t\t\t\t\t     unsigned int src)\n{\n\tif (src > TS_CONFIG_MAX_CLK_SRC)\n\t\treturn -EINVAL;\n\tdio200_write32(dev, DIO200_TS_CONFIG, src);\n\treturn 0;\n}\n\nstatic int dio200_subdev_timer_config(struct comedi_device *dev,\n\t\t\t\t      struct comedi_subdevice *s,\n\t\t\t\t      struct comedi_insn *insn,\n\t\t\t\t      unsigned int *data)\n{\n\tint ret = 0;\n\n\tswitch (data[0]) {\n\tcase INSN_CONFIG_RESET:\n\t\tdio200_subdev_timer_reset(dev, s);\n\t\tbreak;\n\tcase INSN_CONFIG_SET_CLOCK_SRC:\n\t\tret = dio200_subdev_timer_set_clock_src(dev, s, data[1]);\n\t\tif (ret < 0)\n\t\t\tret = -EINVAL;\n\t\tbreak;\n\tcase INSN_CONFIG_GET_CLOCK_SRC:\n\t\tdio200_subdev_timer_get_clock_src(dev, s, &data[1], &data[2]);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret < 0 ? ret : insn->n;\n}\n\nvoid amplc_dio200_set_enhance(struct comedi_device *dev, unsigned char val)\n{\n\tdio200_write8(dev, DIO200_ENHANCE, val);\n}\nEXPORT_SYMBOL_GPL(amplc_dio200_set_enhance);\n\nint amplc_dio200_common_attach(struct comedi_device *dev, unsigned int irq,\n\t\t\t       unsigned long req_irq_flags)\n{\n\tconst struct dio200_board *board = dev->board_ptr;\n\tstruct comedi_subdevice *s;\n\tunsigned int n;\n\tint ret;\n\n\tret = comedi_alloc_subdevices(dev, board->n_subdevs);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (n = 0; n < dev->n_subdevices; n++) {\n\t\ts = &dev->subdevices[n];\n\t\tswitch (board->sdtype[n]) {\n\t\tcase sd_8254:\n\t\t\t \n\t\t\tret = dio200_subdev_8254_init(dev, s,\n\t\t\t\t\t\t      board->sdinfo[n]);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tcase sd_8255:\n\t\t\t \n\t\t\tret = dio200_subdev_8255_init(dev, s,\n\t\t\t\t\t\t      board->sdinfo[n]);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tcase sd_intr:\n\t\t\t \n\t\t\tif (irq && !dev->read_subdev) {\n\t\t\t\tret = dio200_subdev_intr_init(dev, s,\n\t\t\t\t\t\t\t      DIO200_INT_SCE,\n\t\t\t\t\t\t\t      board->sdinfo[n]);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn ret;\n\t\t\t\tdev->read_subdev = s;\n\t\t\t} else {\n\t\t\t\ts->type = COMEDI_SUBD_UNUSED;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase sd_timer:\n\t\t\ts->type\t\t= COMEDI_SUBD_TIMER;\n\t\t\ts->subdev_flags\t= SDF_READABLE | SDF_LSAMPL;\n\t\t\ts->n_chan\t= 1;\n\t\t\ts->maxdata\t= 0xffffffff;\n\t\t\ts->insn_read\t= dio200_subdev_timer_read;\n\t\t\ts->insn_config\t= dio200_subdev_timer_config;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ts->type = COMEDI_SUBD_UNUSED;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (irq && dev->read_subdev) {\n\t\tif (request_irq(irq, dio200_interrupt, req_irq_flags,\n\t\t\t\tdev->board_name, dev) >= 0) {\n\t\t\tdev->irq = irq;\n\t\t} else {\n\t\t\tdev_warn(dev->class_dev,\n\t\t\t\t \"warning! irq %u unavailable!\\n\", irq);\n\t\t}\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(amplc_dio200_common_attach);\n\nstatic int __init amplc_dio200_common_init(void)\n{\n\treturn 0;\n}\nmodule_init(amplc_dio200_common_init);\n\nstatic void __exit amplc_dio200_common_exit(void)\n{\n}\nmodule_exit(amplc_dio200_common_exit);\n\nMODULE_AUTHOR(\"Comedi https://www.comedi.org\");\nMODULE_DESCRIPTION(\"Comedi helper for amplc_dio200 and amplc_dio200_pci\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}