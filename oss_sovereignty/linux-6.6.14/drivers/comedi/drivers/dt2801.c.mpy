{
  "module_name": "dt2801.c",
  "hash_id": "9ec81c59a653016b6d0fdd82edc4cc3468041b49fdc2a8dee154acd19778dee6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/dt2801.c",
  "human_readable_source": "\n \n \n\n#include <linux/module.h>\n#include <linux/comedi/comedidev.h>\n#include <linux/delay.h>\n\n#define DT2801_TIMEOUT 1000\n\n \n \n\n#define DT2801_MAX_DMA_SIZE (64 * 1024)\n\n \n \n\n \n#define DT_C_RESET       0x0\n#define DT_C_CLEAR_ERR   0x1\n#define DT_C_READ_ERRREG 0x2\n#define DT_C_SET_CLOCK   0x3\n\n#define DT_C_TEST        0xb\n#define DT_C_STOP        0xf\n\n#define DT_C_SET_DIGIN   0x4\n#define DT_C_SET_DIGOUT  0x5\n#define DT_C_READ_DIG    0x6\n#define DT_C_WRITE_DIG   0x7\n\n#define DT_C_WRITE_DAIM  0x8\n#define DT_C_SET_DA      0x9\n#define DT_C_WRITE_DA    0xa\n\n#define DT_C_READ_ADIM   0xc\n#define DT_C_SET_AD      0xd\n#define DT_C_READ_AD     0xe\n\n \n#define DT_MOD_DMA     BIT(4)\n#define DT_MOD_CONT    BIT(5)\n#define DT_MOD_EXTCLK  BIT(6)\n#define DT_MOD_EXTTRIG BIT(7)\n\n \n#define DT_S_DATA_OUT_READY   BIT(0)\n#define DT_S_DATA_IN_FULL     BIT(1)\n#define DT_S_READY            BIT(2)\n#define DT_S_COMMAND          BIT(3)\n#define DT_S_COMPOSITE_ERROR  BIT(7)\n\n \n#define DT2801_DATA\t\t0\n#define DT2801_STATUS\t\t1\n#define DT2801_CMD\t\t1\n\n#if 0\n \nstatic const struct comedi_lrange range_dt2801_ai_pgh_bipolar = {\n\t4, {\n\t\tBIP_RANGE(10),\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(2.5),\n\t\tBIP_RANGE(1.25)\n\t}\n};\n#endif\nstatic const struct comedi_lrange range_dt2801_ai_pgl_bipolar = {\n\t4, {\n\t\tBIP_RANGE(10),\n\t\tBIP_RANGE(1),\n\t\tBIP_RANGE(0.1),\n\t\tBIP_RANGE(0.02)\n\t}\n};\n\n#if 0\n \nstatic const struct comedi_lrange range_dt2801_ai_pgh_unipolar = {\n\t4, {\n\t\tUNI_RANGE(10),\n\t\tUNI_RANGE(5),\n\t\tUNI_RANGE(2.5),\n\t\tUNI_RANGE(1.25)\n\t}\n};\n#endif\nstatic const struct comedi_lrange range_dt2801_ai_pgl_unipolar = {\n\t4, {\n\t\tUNI_RANGE(10),\n\t\tUNI_RANGE(1),\n\t\tUNI_RANGE(0.1),\n\t\tUNI_RANGE(0.02)\n\t}\n};\n\nstruct dt2801_board {\n\tconst char *name;\n\tint boardcode;\n\tint ad_diff;\n\tint ad_chan;\n\tint adbits;\n\tint adrangetype;\n\tint dabits;\n};\n\n \nstatic const struct dt2801_board boardtypes[] = {\n\t{\n\t .name = \"dt2801\",\n\t .boardcode = 0x09,\n\t .ad_diff = 2,\n\t .ad_chan = 16,\n\t .adbits = 12,\n\t .adrangetype = 0,\n\t .dabits = 12},\n\t{\n\t .name = \"dt2801-a\",\n\t .boardcode = 0x52,\n\t .ad_diff = 2,\n\t .ad_chan = 16,\n\t .adbits = 12,\n\t .adrangetype = 0,\n\t .dabits = 12},\n\t{\n\t .name = \"dt2801/5716a\",\n\t .boardcode = 0x82,\n\t .ad_diff = 1,\n\t .ad_chan = 16,\n\t .adbits = 16,\n\t .adrangetype = 1,\n\t .dabits = 12},\n\t{\n\t .name = \"dt2805\",\n\t .boardcode = 0x12,\n\t .ad_diff = 1,\n\t .ad_chan = 16,\n\t .adbits = 12,\n\t .adrangetype = 0,\n\t .dabits = 12},\n\t{\n\t .name = \"dt2805/5716a\",\n\t .boardcode = 0x92,\n\t .ad_diff = 1,\n\t .ad_chan = 16,\n\t .adbits = 16,\n\t .adrangetype = 1,\n\t .dabits = 12},\n\t{\n\t .name = \"dt2808\",\n\t .boardcode = 0x20,\n\t .ad_diff = 0,\n\t .ad_chan = 16,\n\t .adbits = 12,\n\t .adrangetype = 2,\n\t .dabits = 8},\n\t{\n\t .name = \"dt2818\",\n\t .boardcode = 0xa2,\n\t .ad_diff = 0,\n\t .ad_chan = 4,\n\t .adbits = 12,\n\t .adrangetype = 0,\n\t .dabits = 12},\n\t{\n\t .name = \"dt2809\",\n\t .boardcode = 0xb0,\n\t .ad_diff = 0,\n\t .ad_chan = 8,\n\t .adbits = 12,\n\t .adrangetype = 1,\n\t .dabits = 12},\n};\n\nstruct dt2801_private {\n\tconst struct comedi_lrange *dac_range_types[2];\n};\n\n \n\n \nstatic int dt2801_readdata(struct comedi_device *dev, int *data)\n{\n\tint stat = 0;\n\tint timeout = DT2801_TIMEOUT;\n\n\tdo {\n\t\tstat = inb_p(dev->iobase + DT2801_STATUS);\n\t\tif (stat & (DT_S_COMPOSITE_ERROR | DT_S_READY))\n\t\t\treturn stat;\n\t\tif (stat & DT_S_DATA_OUT_READY) {\n\t\t\t*data = inb_p(dev->iobase + DT2801_DATA);\n\t\t\treturn 0;\n\t\t}\n\t} while (--timeout > 0);\n\n\treturn -ETIME;\n}\n\nstatic int dt2801_readdata2(struct comedi_device *dev, int *data)\n{\n\tint lb = 0;\n\tint hb = 0;\n\tint ret;\n\n\tret = dt2801_readdata(dev, &lb);\n\tif (ret)\n\t\treturn ret;\n\tret = dt2801_readdata(dev, &hb);\n\tif (ret)\n\t\treturn ret;\n\n\t*data = (hb << 8) + lb;\n\treturn 0;\n}\n\nstatic int dt2801_writedata(struct comedi_device *dev, unsigned int data)\n{\n\tint stat = 0;\n\tint timeout = DT2801_TIMEOUT;\n\n\tdo {\n\t\tstat = inb_p(dev->iobase + DT2801_STATUS);\n\n\t\tif (stat & DT_S_COMPOSITE_ERROR)\n\t\t\treturn stat;\n\t\tif (!(stat & DT_S_DATA_IN_FULL)) {\n\t\t\toutb_p(data & 0xff, dev->iobase + DT2801_DATA);\n\t\t\treturn 0;\n\t\t}\n\t} while (--timeout > 0);\n\n\treturn -ETIME;\n}\n\nstatic int dt2801_writedata2(struct comedi_device *dev, unsigned int data)\n{\n\tint ret;\n\n\tret = dt2801_writedata(dev, data & 0xff);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = dt2801_writedata(dev, data >> 8);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int dt2801_wait_for_ready(struct comedi_device *dev)\n{\n\tint timeout = DT2801_TIMEOUT;\n\tint stat;\n\n\tstat = inb_p(dev->iobase + DT2801_STATUS);\n\tif (stat & DT_S_READY)\n\t\treturn 0;\n\tdo {\n\t\tstat = inb_p(dev->iobase + DT2801_STATUS);\n\n\t\tif (stat & DT_S_COMPOSITE_ERROR)\n\t\t\treturn stat;\n\t\tif (stat & DT_S_READY)\n\t\t\treturn 0;\n\t} while (--timeout > 0);\n\n\treturn -ETIME;\n}\n\nstatic void dt2801_writecmd(struct comedi_device *dev, int command)\n{\n\tint stat;\n\n\tdt2801_wait_for_ready(dev);\n\n\tstat = inb_p(dev->iobase + DT2801_STATUS);\n\tif (stat & DT_S_COMPOSITE_ERROR) {\n\t\tdev_dbg(dev->class_dev,\n\t\t\t\"composite-error in %s, ignoring\\n\", __func__);\n\t}\n\tif (!(stat & DT_S_READY))\n\t\tdev_dbg(dev->class_dev, \"!ready in %s, ignoring\\n\", __func__);\n\toutb_p(command, dev->iobase + DT2801_CMD);\n}\n\nstatic int dt2801_reset(struct comedi_device *dev)\n{\n\tint board_code = 0;\n\tunsigned int stat;\n\tint timeout;\n\n\t \n\tinb_p(dev->iobase + DT2801_DATA);\n\tinb_p(dev->iobase + DT2801_DATA);\n\tinb_p(dev->iobase + DT2801_DATA);\n\tinb_p(dev->iobase + DT2801_DATA);\n\n\t \n\toutb_p(DT_C_STOP, dev->iobase + DT2801_CMD);\n\n\t \n\tusleep_range(100, 200);\n\ttimeout = 10000;\n\tdo {\n\t\tstat = inb_p(dev->iobase + DT2801_STATUS);\n\t\tif (stat & DT_S_READY)\n\t\t\tbreak;\n\t} while (timeout--);\n\tif (!timeout)\n\t\tdev_dbg(dev->class_dev, \"timeout 1 status=0x%02x\\n\", stat);\n\n\t \n\n\toutb_p(DT_C_RESET, dev->iobase + DT2801_CMD);\n\t \n\n\tusleep_range(100, 200);\n\ttimeout = 10000;\n\tdo {\n\t\tstat = inb_p(dev->iobase + DT2801_STATUS);\n\t\tif (stat & DT_S_READY)\n\t\t\tbreak;\n\t} while (timeout--);\n\tif (!timeout)\n\t\tdev_dbg(dev->class_dev, \"timeout 2 status=0x%02x\\n\", stat);\n\n\tdt2801_readdata(dev, &board_code);\n\n\treturn board_code;\n}\n\nstatic int probe_number_of_ai_chans(struct comedi_device *dev)\n{\n\tint n_chans;\n\tint stat;\n\tint data;\n\n\tfor (n_chans = 0; n_chans < 16; n_chans++) {\n\t\tdt2801_writecmd(dev, DT_C_READ_ADIM);\n\t\tdt2801_writedata(dev, 0);\n\t\tdt2801_writedata(dev, n_chans);\n\t\tstat = dt2801_readdata2(dev, &data);\n\n\t\tif (stat)\n\t\t\tbreak;\n\t}\n\n\tdt2801_reset(dev);\n\tdt2801_reset(dev);\n\n\treturn n_chans;\n}\n\nstatic const struct comedi_lrange *dac_range_table[] = {\n\t&range_bipolar10,\n\t&range_bipolar5,\n\t&range_bipolar2_5,\n\t&range_unipolar10,\n\t&range_unipolar5\n};\n\nstatic const struct comedi_lrange *dac_range_lkup(int opt)\n{\n\tif (opt < 0 || opt >= 5)\n\t\treturn &range_unknown;\n\treturn dac_range_table[opt];\n}\n\nstatic const struct comedi_lrange *ai_range_lkup(int type, int opt)\n{\n\tswitch (type) {\n\tcase 0:\n\t\treturn (opt) ?\n\t\t    &range_dt2801_ai_pgl_unipolar :\n\t\t    &range_dt2801_ai_pgl_bipolar;\n\tcase 1:\n\t\treturn (opt) ? &range_unipolar10 : &range_bipolar10;\n\tcase 2:\n\t\treturn &range_unipolar5;\n\t}\n\treturn &range_unknown;\n}\n\nstatic int dt2801_error(struct comedi_device *dev, int stat)\n{\n\tif (stat < 0) {\n\t\tif (stat == -ETIME)\n\t\t\tdev_dbg(dev->class_dev, \"timeout\\n\");\n\t\telse\n\t\t\tdev_dbg(dev->class_dev, \"error %d\\n\", stat);\n\t\treturn stat;\n\t}\n\tdev_dbg(dev->class_dev, \"error status 0x%02x, resetting...\\n\", stat);\n\n\tdt2801_reset(dev);\n\tdt2801_reset(dev);\n\n\treturn -EIO;\n}\n\nstatic int dt2801_ai_insn_read(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       struct comedi_insn *insn, unsigned int *data)\n{\n\tint d;\n\tint stat;\n\tint i;\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\tdt2801_writecmd(dev, DT_C_READ_ADIM);\n\t\tdt2801_writedata(dev, CR_RANGE(insn->chanspec));\n\t\tdt2801_writedata(dev, CR_CHAN(insn->chanspec));\n\t\tstat = dt2801_readdata2(dev, &d);\n\n\t\tif (stat != 0)\n\t\t\treturn dt2801_error(dev, stat);\n\n\t\tdata[i] = d;\n\t}\n\n\treturn i;\n}\n\nstatic int dt2801_ao_insn_write(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tstruct comedi_insn *insn,\n\t\t\t\tunsigned int *data)\n{\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\n\tdt2801_writecmd(dev, DT_C_WRITE_DAIM);\n\tdt2801_writedata(dev, chan);\n\tdt2801_writedata2(dev, data[0]);\n\n\ts->readback[chan] = data[0];\n\n\treturn 1;\n}\n\nstatic int dt2801_dio_insn_bits(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tstruct comedi_insn *insn,\n\t\t\t\tunsigned int *data)\n{\n\tint which = (s == &dev->subdevices[3]) ? 1 : 0;\n\tunsigned int val = 0;\n\n\tif (comedi_dio_update_state(s, data)) {\n\t\tdt2801_writecmd(dev, DT_C_WRITE_DIG);\n\t\tdt2801_writedata(dev, which);\n\t\tdt2801_writedata(dev, s->state);\n\t}\n\n\tdt2801_writecmd(dev, DT_C_READ_DIG);\n\tdt2801_writedata(dev, which);\n\tdt2801_readdata(dev, &val);\n\n\tdata[1] = val;\n\n\treturn insn->n;\n}\n\nstatic int dt2801_dio_insn_config(struct comedi_device *dev,\n\t\t\t\t  struct comedi_subdevice *s,\n\t\t\t\t  struct comedi_insn *insn,\n\t\t\t\t  unsigned int *data)\n{\n\tint ret;\n\n\tret = comedi_dio_insn_config(dev, s, insn, data, 0xff);\n\tif (ret)\n\t\treturn ret;\n\n\tdt2801_writecmd(dev, s->io_bits ? DT_C_SET_DIGOUT : DT_C_SET_DIGIN);\n\tdt2801_writedata(dev, (s == &dev->subdevices[3]) ? 1 : 0);\n\n\treturn insn->n;\n}\n\n \nstatic int dt2801_attach(struct comedi_device *dev, struct comedi_devconfig *it)\n{\n\tconst struct dt2801_board *board;\n\tstruct dt2801_private *devpriv;\n\tstruct comedi_subdevice *s;\n\tint board_code, type;\n\tint ret = 0;\n\tint n_ai_chans;\n\n\tret = comedi_request_region(dev, it->options[0], 0x2);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\tboard_code = dt2801_reset(dev);\n\n\t \n\tif (!board_code)\n\t\tboard_code = dt2801_reset(dev);\n\n\tfor (type = 0; type < ARRAY_SIZE(boardtypes); type++) {\n\t\tif (boardtypes[type].boardcode == board_code)\n\t\t\tgoto havetype;\n\t}\n\tdev_dbg(dev->class_dev,\n\t\t\"unrecognized board code=0x%02x, contact author\\n\", board_code);\n\ttype = 0;\n\nhavetype:\n\tdev->board_ptr = boardtypes + type;\n\tboard = dev->board_ptr;\n\n\tn_ai_chans = probe_number_of_ai_chans(dev);\n\n\tret = comedi_alloc_subdevices(dev, 4);\n\tif (ret)\n\t\tgoto out;\n\n\tdevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\n\tif (!devpriv)\n\t\treturn -ENOMEM;\n\n\tdev->board_name = board->name;\n\n\ts = &dev->subdevices[0];\n\t \n\ts->type = COMEDI_SUBD_AI;\n\ts->subdev_flags = SDF_READABLE | SDF_GROUND;\n#if 1\n\ts->n_chan = n_ai_chans;\n#else\n\tif (it->options[2])\n\t\ts->n_chan = board->ad_chan;\n\telse\n\t\ts->n_chan = board->ad_chan / 2;\n#endif\n\ts->maxdata = (1 << board->adbits) - 1;\n\ts->range_table = ai_range_lkup(board->adrangetype, it->options[3]);\n\ts->insn_read = dt2801_ai_insn_read;\n\n\ts = &dev->subdevices[1];\n\t \n\ts->type = COMEDI_SUBD_AO;\n\ts->subdev_flags = SDF_WRITABLE;\n\ts->n_chan = 2;\n\ts->maxdata = (1 << board->dabits) - 1;\n\ts->range_table_list = devpriv->dac_range_types;\n\tdevpriv->dac_range_types[0] = dac_range_lkup(it->options[4]);\n\tdevpriv->dac_range_types[1] = dac_range_lkup(it->options[5]);\n\ts->insn_write = dt2801_ao_insn_write;\n\n\tret = comedi_alloc_subdev_readback(s);\n\tif (ret)\n\t\treturn ret;\n\n\ts = &dev->subdevices[2];\n\t \n\ts->type = COMEDI_SUBD_DIO;\n\ts->subdev_flags = SDF_READABLE | SDF_WRITABLE;\n\ts->n_chan = 8;\n\ts->maxdata = 1;\n\ts->range_table = &range_digital;\n\ts->insn_bits = dt2801_dio_insn_bits;\n\ts->insn_config = dt2801_dio_insn_config;\n\n\ts = &dev->subdevices[3];\n\t \n\ts->type = COMEDI_SUBD_DIO;\n\ts->subdev_flags = SDF_READABLE | SDF_WRITABLE;\n\ts->n_chan = 8;\n\ts->maxdata = 1;\n\ts->range_table = &range_digital;\n\ts->insn_bits = dt2801_dio_insn_bits;\n\ts->insn_config = dt2801_dio_insn_config;\n\n\tret = 0;\nout:\n\treturn ret;\n}\n\nstatic struct comedi_driver dt2801_driver = {\n\t.driver_name\t= \"dt2801\",\n\t.module\t\t= THIS_MODULE,\n\t.attach\t\t= dt2801_attach,\n\t.detach\t\t= comedi_legacy_detach,\n};\nmodule_comedi_driver(dt2801_driver);\n\nMODULE_AUTHOR(\"Comedi https://www.comedi.org\");\nMODULE_DESCRIPTION(\"Comedi low-level driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}