{
  "module_name": "ni_labpc_common.c",
  "hash_id": "e2ba6b3dacb945a0e4fcb8088dc6b50fd8722193d586dea26a17d64e2593c2f3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/ni_labpc_common.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/comedi/comedidev.h>\n#include <linux/comedi/comedi_8255.h>\n#include <linux/comedi/comedi_8254.h>\n\n#include \"ni_labpc.h\"\n#include \"ni_labpc_regs.h\"\n#include \"ni_labpc_isadma.h\"\n\nenum scan_mode {\n\tMODE_SINGLE_CHAN,\n\tMODE_SINGLE_CHAN_INTERVAL,\n\tMODE_MULT_CHAN_UP,\n\tMODE_MULT_CHAN_DOWN,\n};\n\nstatic const struct comedi_lrange range_labpc_plus_ai = {\n\t16, {\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(4),\n\t\tBIP_RANGE(2.5),\n\t\tBIP_RANGE(1),\n\t\tBIP_RANGE(0.5),\n\t\tBIP_RANGE(0.25),\n\t\tBIP_RANGE(0.1),\n\t\tBIP_RANGE(0.05),\n\t\tUNI_RANGE(10),\n\t\tUNI_RANGE(8),\n\t\tUNI_RANGE(5),\n\t\tUNI_RANGE(2),\n\t\tUNI_RANGE(1),\n\t\tUNI_RANGE(0.5),\n\t\tUNI_RANGE(0.2),\n\t\tUNI_RANGE(0.1)\n\t}\n};\n\nstatic const struct comedi_lrange range_labpc_1200_ai = {\n\t14, {\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(2.5),\n\t\tBIP_RANGE(1),\n\t\tBIP_RANGE(0.5),\n\t\tBIP_RANGE(0.25),\n\t\tBIP_RANGE(0.1),\n\t\tBIP_RANGE(0.05),\n\t\tUNI_RANGE(10),\n\t\tUNI_RANGE(5),\n\t\tUNI_RANGE(2),\n\t\tUNI_RANGE(1),\n\t\tUNI_RANGE(0.5),\n\t\tUNI_RANGE(0.2),\n\t\tUNI_RANGE(0.1)\n\t}\n};\n\nstatic const struct comedi_lrange range_labpc_ao = {\n\t2, {\n\t\tBIP_RANGE(5),\n\t\tUNI_RANGE(10)\n\t}\n};\n\n \nstatic unsigned int labpc_inb(struct comedi_device *dev, unsigned long reg)\n{\n\treturn inb(dev->iobase + reg);\n}\n\nstatic void labpc_outb(struct comedi_device *dev,\n\t\t       unsigned int byte, unsigned long reg)\n{\n\toutb(byte, dev->iobase + reg);\n}\n\nstatic unsigned int labpc_readb(struct comedi_device *dev, unsigned long reg)\n{\n\treturn readb(dev->mmio + reg);\n}\n\nstatic void labpc_writeb(struct comedi_device *dev,\n\t\t\t unsigned int byte, unsigned long reg)\n{\n\twriteb(byte, dev->mmio + reg);\n}\n\nstatic int labpc_cancel(struct comedi_device *dev, struct comedi_subdevice *s)\n{\n\tstruct labpc_private *devpriv = dev->private;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->spinlock, flags);\n\tdevpriv->cmd2 &= ~(CMD2_SWTRIG | CMD2_HWTRIG | CMD2_PRETRIG);\n\tdevpriv->write_byte(dev, devpriv->cmd2, CMD2_REG);\n\tspin_unlock_irqrestore(&dev->spinlock, flags);\n\n\tdevpriv->cmd3 = 0;\n\tdevpriv->write_byte(dev, devpriv->cmd3, CMD3_REG);\n\n\treturn 0;\n}\n\nstatic void labpc_ai_set_chan_and_gain(struct comedi_device *dev,\n\t\t\t\t       enum scan_mode mode,\n\t\t\t\t       unsigned int chan,\n\t\t\t\t       unsigned int range,\n\t\t\t\t       unsigned int aref)\n{\n\tconst struct labpc_boardinfo *board = dev->board_ptr;\n\tstruct labpc_private *devpriv = dev->private;\n\n\tif (board->is_labpc1200) {\n\t\t \n\t\trange += (range > 0) + (range > 7);\n\t}\n\n\t \n\tif ((mode == MODE_SINGLE_CHAN || mode == MODE_SINGLE_CHAN_INTERVAL) &&\n\t    aref == AREF_DIFF)\n\t\tchan *= 2;\n\tdevpriv->cmd1 = CMD1_MA(chan);\n\tdevpriv->cmd1 |= CMD1_GAIN(range);\n\n\tdevpriv->write_byte(dev, devpriv->cmd1, CMD1_REG);\n}\n\nstatic void labpc_setup_cmd6_reg(struct comedi_device *dev,\n\t\t\t\t struct comedi_subdevice *s,\n\t\t\t\t enum scan_mode mode,\n\t\t\t\t enum transfer_type xfer,\n\t\t\t\t unsigned int range,\n\t\t\t\t unsigned int aref,\n\t\t\t\t bool ena_intr)\n{\n\tconst struct labpc_boardinfo *board = dev->board_ptr;\n\tstruct labpc_private *devpriv = dev->private;\n\n\tif (!board->is_labpc1200)\n\t\treturn;\n\n\t \n\tif (aref != AREF_GROUND)\n\t\tdevpriv->cmd6 |= CMD6_NRSE;\n\telse\n\t\tdevpriv->cmd6 &= ~CMD6_NRSE;\n\n\t \n\tif (comedi_range_is_unipolar(s, range))\n\t\tdevpriv->cmd6 |= CMD6_ADCUNI;\n\telse\n\t\tdevpriv->cmd6 &= ~CMD6_ADCUNI;\n\n\t \n\tif (xfer == fifo_half_full_transfer)\n\t\tdevpriv->cmd6 |= CMD6_HFINTEN;\n\telse\n\t\tdevpriv->cmd6 &= ~CMD6_HFINTEN;\n\n\t \n\tif (ena_intr)\n\t\tdevpriv->cmd6 |= CMD6_DQINTEN;\n\telse\n\t\tdevpriv->cmd6 &= ~CMD6_DQINTEN;\n\n\t \n\tif (mode == MODE_MULT_CHAN_UP)\n\t\tdevpriv->cmd6 |= CMD6_SCANUP;\n\telse\n\t\tdevpriv->cmd6 &= ~CMD6_SCANUP;\n\n\tdevpriv->write_byte(dev, devpriv->cmd6, CMD6_REG);\n}\n\nstatic unsigned int labpc_read_adc_fifo(struct comedi_device *dev)\n{\n\tstruct labpc_private *devpriv = dev->private;\n\tunsigned int lsb = devpriv->read_byte(dev, ADC_FIFO_REG);\n\tunsigned int msb = devpriv->read_byte(dev, ADC_FIFO_REG);\n\n\treturn (msb << 8) | lsb;\n}\n\nstatic void labpc_clear_adc_fifo(struct comedi_device *dev)\n{\n\tstruct labpc_private *devpriv = dev->private;\n\n\tdevpriv->write_byte(dev, 0x1, ADC_FIFO_CLEAR_REG);\n\tlabpc_read_adc_fifo(dev);\n}\n\nstatic int labpc_ai_eoc(struct comedi_device *dev,\n\t\t\tstruct comedi_subdevice *s,\n\t\t\tstruct comedi_insn *insn,\n\t\t\tunsigned long context)\n{\n\tstruct labpc_private *devpriv = dev->private;\n\n\tdevpriv->stat1 = devpriv->read_byte(dev, STAT1_REG);\n\tif (devpriv->stat1 & STAT1_DAVAIL)\n\t\treturn 0;\n\treturn -EBUSY;\n}\n\nstatic int labpc_ai_insn_read(struct comedi_device *dev,\n\t\t\t      struct comedi_subdevice *s,\n\t\t\t      struct comedi_insn *insn,\n\t\t\t      unsigned int *data)\n{\n\tstruct labpc_private *devpriv = dev->private;\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int range = CR_RANGE(insn->chanspec);\n\tunsigned int aref = CR_AREF(insn->chanspec);\n\tint ret;\n\tint i;\n\n\t \n\tlabpc_cancel(dev, s);\n\n\tlabpc_ai_set_chan_and_gain(dev, MODE_SINGLE_CHAN, chan, range, aref);\n\n\tlabpc_setup_cmd6_reg(dev, s, MODE_SINGLE_CHAN, fifo_not_empty_transfer,\n\t\t\t     range, aref, false);\n\n\t \n\tdevpriv->cmd4 = 0;\n\tdevpriv->cmd4 |= CMD4_ECLKRCV;\n\t \n\tif (aref == AREF_DIFF)\n\t\tdevpriv->cmd4 |= CMD4_SEDIFF;\n\tdevpriv->write_byte(dev, devpriv->cmd4, CMD4_REG);\n\n\t \n\tcomedi_8254_set_mode(devpriv->counter, 0, I8254_MODE2 | I8254_BINARY);\n\n\tlabpc_clear_adc_fifo(dev);\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\t \n\t\tdevpriv->write_byte(dev, 0x1, ADC_START_CONVERT_REG);\n\n\t\tret = comedi_timeout(dev, s, insn, labpc_ai_eoc, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdata[i] = labpc_read_adc_fifo(dev);\n\t}\n\n\treturn insn->n;\n}\n\nstatic bool labpc_use_continuous_mode(const struct comedi_cmd *cmd,\n\t\t\t\t      enum scan_mode mode)\n{\n\tif (mode == MODE_SINGLE_CHAN || cmd->scan_begin_src == TRIG_FOLLOW)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic unsigned int labpc_ai_convert_period(const struct comedi_cmd *cmd,\n\t\t\t\t\t    enum scan_mode mode)\n{\n\tif (cmd->convert_src != TRIG_TIMER)\n\t\treturn 0;\n\n\tif (mode == MODE_SINGLE_CHAN && cmd->scan_begin_src == TRIG_TIMER)\n\t\treturn cmd->scan_begin_arg;\n\n\treturn cmd->convert_arg;\n}\n\nstatic void labpc_set_ai_convert_period(struct comedi_cmd *cmd,\n\t\t\t\t\tenum scan_mode mode, unsigned int ns)\n{\n\tif (cmd->convert_src != TRIG_TIMER)\n\t\treturn;\n\n\tif (mode == MODE_SINGLE_CHAN &&\n\t    cmd->scan_begin_src == TRIG_TIMER) {\n\t\tcmd->scan_begin_arg = ns;\n\t\tif (cmd->convert_arg > cmd->scan_begin_arg)\n\t\t\tcmd->convert_arg = cmd->scan_begin_arg;\n\t} else {\n\t\tcmd->convert_arg = ns;\n\t}\n}\n\nstatic unsigned int labpc_ai_scan_period(const struct comedi_cmd *cmd,\n\t\t\t\t\t enum scan_mode mode)\n{\n\tif (cmd->scan_begin_src != TRIG_TIMER)\n\t\treturn 0;\n\n\tif (mode == MODE_SINGLE_CHAN && cmd->convert_src == TRIG_TIMER)\n\t\treturn 0;\n\n\treturn cmd->scan_begin_arg;\n}\n\nstatic void labpc_set_ai_scan_period(struct comedi_cmd *cmd,\n\t\t\t\t     enum scan_mode mode, unsigned int ns)\n{\n\tif (cmd->scan_begin_src != TRIG_TIMER)\n\t\treturn;\n\n\tif (mode == MODE_SINGLE_CHAN && cmd->convert_src == TRIG_TIMER)\n\t\treturn;\n\n\tcmd->scan_begin_arg = ns;\n}\n\n \nstatic void labpc_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd,\n\t\t\t     enum scan_mode mode)\n{\n\tstruct comedi_8254 *pacer = dev->pacer;\n\tunsigned int convert_period = labpc_ai_convert_period(cmd, mode);\n\tunsigned int scan_period = labpc_ai_scan_period(cmd, mode);\n\tunsigned int base_period;\n\n\t \n\tif (convert_period && scan_period) {\n\t\t \n\t\tpacer->next_div1 = (scan_period - 1) /\n\t\t\t\t   (pacer->osc_base * I8254_MAX_COUNT) + 1;\n\n\t\tcomedi_check_trigger_arg_min(&pacer->next_div1, 2);\n\t\tcomedi_check_trigger_arg_max(&pacer->next_div1,\n\t\t\t\t\t     I8254_MAX_COUNT);\n\n\t\tbase_period = pacer->osc_base * pacer->next_div1;\n\n\t\t \n\t\tswitch (cmd->flags & CMDF_ROUND_MASK) {\n\t\tdefault:\n\t\tcase CMDF_ROUND_NEAREST:\n\t\t\tpacer->next_div = DIV_ROUND_CLOSEST(convert_period,\n\t\t\t\t\t\t\t    base_period);\n\t\t\tpacer->next_div2 = DIV_ROUND_CLOSEST(scan_period,\n\t\t\t\t\t\t\t     base_period);\n\t\t\tbreak;\n\t\tcase CMDF_ROUND_UP:\n\t\t\tpacer->next_div = DIV_ROUND_UP(convert_period,\n\t\t\t\t\t\t       base_period);\n\t\t\tpacer->next_div2 = DIV_ROUND_UP(scan_period,\n\t\t\t\t\t\t\tbase_period);\n\t\t\tbreak;\n\t\tcase CMDF_ROUND_DOWN:\n\t\t\tpacer->next_div = convert_period / base_period;\n\t\t\tpacer->next_div2 = scan_period / base_period;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tcomedi_check_trigger_arg_min(&pacer->next_div, 2);\n\t\tcomedi_check_trigger_arg_max(&pacer->next_div, I8254_MAX_COUNT);\n\t\tcomedi_check_trigger_arg_min(&pacer->next_div2, 2);\n\t\tcomedi_check_trigger_arg_max(&pacer->next_div2,\n\t\t\t\t\t     I8254_MAX_COUNT);\n\n\t\t \n\t\tlabpc_set_ai_convert_period(cmd, mode,\n\t\t\t\t\t    base_period * pacer->next_div);\n\t\tlabpc_set_ai_scan_period(cmd, mode,\n\t\t\t\t\t base_period * pacer->next_div2);\n\t} else if (scan_period) {\n\t\t \n\t\tcomedi_8254_cascade_ns_to_timer(pacer, &scan_period,\n\t\t\t\t\t\tcmd->flags);\n\t\tlabpc_set_ai_scan_period(cmd, mode, scan_period);\n\t} else if (convert_period) {\n\t\t \n\t\tcomedi_8254_cascade_ns_to_timer(pacer, &convert_period,\n\t\t\t\t\t\tcmd->flags);\n\t\t \n\t\tpacer->next_div = pacer->next_div2;\n\t\tlabpc_set_ai_convert_period(cmd, mode, convert_period);\n\t}\n}\n\nstatic enum scan_mode labpc_ai_scan_mode(const struct comedi_cmd *cmd)\n{\n\tunsigned int chan0;\n\tunsigned int chan1;\n\n\tif (cmd->chanlist_len == 1)\n\t\treturn MODE_SINGLE_CHAN;\n\n\t \n\tif (!cmd->chanlist)\n\t\treturn MODE_MULT_CHAN_UP;\n\n\tchan0 = CR_CHAN(cmd->chanlist[0]);\n\tchan1 = CR_CHAN(cmd->chanlist[1]);\n\n\tif (chan0 < chan1)\n\t\treturn MODE_MULT_CHAN_UP;\n\n\tif (chan0 > chan1)\n\t\treturn MODE_MULT_CHAN_DOWN;\n\n\treturn MODE_SINGLE_CHAN_INTERVAL;\n}\n\nstatic int labpc_ai_check_chanlist(struct comedi_device *dev,\n\t\t\t\t   struct comedi_subdevice *s,\n\t\t\t\t   struct comedi_cmd *cmd)\n{\n\tenum scan_mode mode = labpc_ai_scan_mode(cmd);\n\tunsigned int chan0 = CR_CHAN(cmd->chanlist[0]);\n\tunsigned int range0 = CR_RANGE(cmd->chanlist[0]);\n\tunsigned int aref0 = CR_AREF(cmd->chanlist[0]);\n\tint i;\n\n\tfor (i = 0; i < cmd->chanlist_len; i++) {\n\t\tunsigned int chan = CR_CHAN(cmd->chanlist[i]);\n\t\tunsigned int range = CR_RANGE(cmd->chanlist[i]);\n\t\tunsigned int aref = CR_AREF(cmd->chanlist[i]);\n\n\t\tswitch (mode) {\n\t\tcase MODE_SINGLE_CHAN:\n\t\t\tbreak;\n\t\tcase MODE_SINGLE_CHAN_INTERVAL:\n\t\t\tif (chan != chan0) {\n\t\t\t\tdev_dbg(dev->class_dev,\n\t\t\t\t\t\"channel scanning order specified in chanlist is not supported by hardware\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MODE_MULT_CHAN_UP:\n\t\t\tif (chan != i) {\n\t\t\t\tdev_dbg(dev->class_dev,\n\t\t\t\t\t\"channel scanning order specified in chanlist is not supported by hardware\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MODE_MULT_CHAN_DOWN:\n\t\t\tif (chan != (cmd->chanlist_len - i - 1)) {\n\t\t\t\tdev_dbg(dev->class_dev,\n\t\t\t\t\t\"channel scanning order specified in chanlist is not supported by hardware\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (range != range0) {\n\t\t\tdev_dbg(dev->class_dev,\n\t\t\t\t\"entries in chanlist must all have the same range\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (aref != aref0) {\n\t\t\tdev_dbg(dev->class_dev,\n\t\t\t\t\"entries in chanlist must all have the same reference\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int labpc_ai_cmdtest(struct comedi_device *dev,\n\t\t\t    struct comedi_subdevice *s, struct comedi_cmd *cmd)\n{\n\tconst struct labpc_boardinfo *board = dev->board_ptr;\n\tint err = 0;\n\tint tmp, tmp2;\n\tunsigned int stop_mask;\n\tenum scan_mode mode;\n\n\t \n\n\terr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_EXT);\n\terr |= comedi_check_trigger_src(&cmd->scan_begin_src,\n\t\t\t\t\tTRIG_TIMER | TRIG_FOLLOW | TRIG_EXT);\n\terr |= comedi_check_trigger_src(&cmd->convert_src,\n\t\t\t\t\tTRIG_TIMER | TRIG_EXT);\n\terr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\n\n\tstop_mask = TRIG_COUNT | TRIG_NONE;\n\tif (board->is_labpc1200)\n\t\tstop_mask |= TRIG_EXT;\n\terr |= comedi_check_trigger_src(&cmd->stop_src, stop_mask);\n\n\tif (err)\n\t\treturn 1;\n\n\t \n\n\terr |= comedi_check_trigger_is_unique(cmd->start_src);\n\terr |= comedi_check_trigger_is_unique(cmd->scan_begin_src);\n\terr |= comedi_check_trigger_is_unique(cmd->convert_src);\n\terr |= comedi_check_trigger_is_unique(cmd->stop_src);\n\n\t \n\n\t \n\tif (cmd->start_src == TRIG_EXT && cmd->stop_src == TRIG_EXT)\n\t\terr++;\n\n\tif (err)\n\t\treturn 2;\n\n\t \n\n\tswitch (cmd->start_src) {\n\tcase TRIG_NOW:\n\t\terr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\n\t\tbreak;\n\tcase TRIG_EXT:\n\t\t \n\t\tbreak;\n\t}\n\n\tif (!cmd->chanlist_len)\n\t\terr |= -EINVAL;\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\n\t\t\t\t\t   cmd->chanlist_len);\n\n\tif (cmd->convert_src == TRIG_TIMER) {\n\t\terr |= comedi_check_trigger_arg_min(&cmd->convert_arg,\n\t\t\t\t\t\t    board->ai_speed);\n\t}\n\n\t \n\tif (cmd->scan_begin_src == TRIG_TIMER) {\n\t\tif (cmd->convert_src == TRIG_TIMER) {\n\t\t\terr |= comedi_check_trigger_arg_min(\n\t\t\t\t\t&cmd->scan_begin_arg,\n\t\t\t\t\tcmd->convert_arg * cmd->chanlist_len);\n\t\t}\n\t\terr |= comedi_check_trigger_arg_min(\n\t\t\t\t\t&cmd->scan_begin_arg,\n\t\t\t\t\tboard->ai_speed * cmd->chanlist_len);\n\t}\n\n\tswitch (cmd->stop_src) {\n\tcase TRIG_COUNT:\n\t\terr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\n\t\tbreak;\n\tcase TRIG_NONE:\n\t\terr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\n\t\tbreak;\n\t\t \n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (err)\n\t\treturn 3;\n\n\t \n\n\ttmp = cmd->convert_arg;\n\ttmp2 = cmd->scan_begin_arg;\n\tmode = labpc_ai_scan_mode(cmd);\n\tlabpc_adc_timing(dev, cmd, mode);\n\tif (tmp != cmd->convert_arg || tmp2 != cmd->scan_begin_arg)\n\t\terr++;\n\n\tif (err)\n\t\treturn 4;\n\n\t \n\tif (cmd->chanlist && cmd->chanlist_len > 0)\n\t\terr |= labpc_ai_check_chanlist(dev, s, cmd);\n\n\tif (err)\n\t\treturn 5;\n\n\treturn 0;\n}\n\nstatic int labpc_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\n{\n\tconst struct labpc_boardinfo *board = dev->board_ptr;\n\tstruct labpc_private *devpriv = dev->private;\n\tstruct comedi_async *async = s->async;\n\tstruct comedi_cmd *cmd = &async->cmd;\n\tenum scan_mode mode = labpc_ai_scan_mode(cmd);\n\tunsigned int chanspec = (mode == MODE_MULT_CHAN_UP) ?\n\t\t\t\tcmd->chanlist[cmd->chanlist_len - 1] :\n\t\t\t\tcmd->chanlist[0];\n\tunsigned int chan = CR_CHAN(chanspec);\n\tunsigned int range = CR_RANGE(chanspec);\n\tunsigned int aref = CR_AREF(chanspec);\n\tenum transfer_type xfer;\n\tunsigned long flags;\n\n\t \n\tlabpc_cancel(dev, s);\n\n\t \n\tif (cmd->stop_src == TRIG_COUNT)\n\t\tdevpriv->count = cmd->stop_arg * cmd->chanlist_len;\n\n\t \n\tif (cmd->stop_src == TRIG_EXT) {\n\t\t \n\t\tcomedi_8254_load(devpriv->counter, 1,\n\t\t\t\t 3, I8254_MODE0 | I8254_BINARY);\n\t} else\t{\n\t\t \n\t\tcomedi_8254_set_mode(devpriv->counter, 1,\n\t\t\t\t     I8254_MODE0 | I8254_BINARY);\n\t}\n\n\t \n\tif (devpriv->dma &&\n\t    (cmd->flags & (CMDF_WAKE_EOS | CMDF_PRIORITY)) == 0) {\n\t\t \n\t\txfer = isa_dma_transfer;\n\t} else if (board->is_labpc1200 &&\n\t\t   (cmd->flags & CMDF_WAKE_EOS) == 0 &&\n\t\t   (cmd->stop_src != TRIG_COUNT || devpriv->count > 256)) {\n\t\t \n\t\txfer = fifo_half_full_transfer;\n\t} else {\n\t\txfer = fifo_not_empty_transfer;\n\t}\n\tdevpriv->current_transfer = xfer;\n\n\tlabpc_ai_set_chan_and_gain(dev, mode, chan, range, aref);\n\n\tlabpc_setup_cmd6_reg(dev, s, mode, xfer, range, aref,\n\t\t\t     (cmd->stop_src == TRIG_EXT));\n\n\t \n\tif (mode == MODE_MULT_CHAN_UP || mode == MODE_MULT_CHAN_DOWN) {\n\t\tdevpriv->cmd1 |= CMD1_SCANEN;\n\t\t \n\t\tudelay(1);\n\t\tdevpriv->write_byte(dev, devpriv->cmd1, CMD1_REG);\n\t}\n\n\tdevpriv->write_byte(dev, cmd->chanlist_len, INTERVAL_COUNT_REG);\n\t \n\tdevpriv->write_byte(dev, 0x1, INTERVAL_STROBE_REG);\n\n\tif (cmd->convert_src == TRIG_TIMER ||\n\t    cmd->scan_begin_src == TRIG_TIMER) {\n\t\tstruct comedi_8254 *pacer = dev->pacer;\n\t\tstruct comedi_8254 *counter = devpriv->counter;\n\n\t\tcomedi_8254_update_divisors(pacer);\n\n\t\t \n\t\tcomedi_8254_load(pacer, 0, pacer->divisor1,\n\t\t\t\t I8254_MODE3 | I8254_BINARY);\n\n\t\t \n\t\tcomedi_8254_set_mode(counter, 0, I8254_MODE2 | I8254_BINARY);\n\t\tif (labpc_ai_convert_period(cmd, mode))\n\t\t\tcomedi_8254_write(counter, 0, pacer->divisor);\n\n\t\t \n\t\tif (labpc_ai_scan_period(cmd, mode))\n\t\t\tcomedi_8254_load(pacer, 1, pacer->divisor2,\n\t\t\t\t\t I8254_MODE2 | I8254_BINARY);\n\t}\n\n\tlabpc_clear_adc_fifo(dev);\n\n\tif (xfer == isa_dma_transfer)\n\t\tlabpc_setup_dma(dev, s);\n\n\t \n\tdevpriv->cmd3 |= CMD3_ERRINTEN;\n\t \n\tif (xfer == fifo_not_empty_transfer)\n\t\tdevpriv->cmd3 |= CMD3_FIFOINTEN;\n\tdevpriv->write_byte(dev, devpriv->cmd3, CMD3_REG);\n\n\t \n\tdevpriv->cmd4 = 0;\n\tif (cmd->convert_src != TRIG_EXT)\n\t\tdevpriv->cmd4 |= CMD4_ECLKRCV;\n\t \n\tif (!labpc_use_continuous_mode(cmd, mode)) {\n\t\tdevpriv->cmd4 |= CMD4_INTSCAN;\n\t\tif (cmd->scan_begin_src == TRIG_EXT)\n\t\t\tdevpriv->cmd4 |= CMD4_EOIRCV;\n\t}\n\t \n\tif (aref == AREF_DIFF)\n\t\tdevpriv->cmd4 |= CMD4_SEDIFF;\n\tdevpriv->write_byte(dev, devpriv->cmd4, CMD4_REG);\n\n\t \n\n\tspin_lock_irqsave(&dev->spinlock, flags);\n\n\t \n\tdevpriv->cmd2 |= CMD2_TBSEL;\n\n\tdevpriv->cmd2 &= ~(CMD2_SWTRIG | CMD2_HWTRIG | CMD2_PRETRIG);\n\tif (cmd->start_src == TRIG_EXT)\n\t\tdevpriv->cmd2 |= CMD2_HWTRIG;\n\telse\n\t\tdevpriv->cmd2 |= CMD2_SWTRIG;\n\tif (cmd->stop_src == TRIG_EXT)\n\t\tdevpriv->cmd2 |= (CMD2_HWTRIG | CMD2_PRETRIG);\n\n\tdevpriv->write_byte(dev, devpriv->cmd2, CMD2_REG);\n\n\tspin_unlock_irqrestore(&dev->spinlock, flags);\n\n\treturn 0;\n}\n\n \nstatic int labpc_drain_fifo(struct comedi_device *dev)\n{\n\tstruct labpc_private *devpriv = dev->private;\n\tstruct comedi_async *async = dev->read_subdev->async;\n\tstruct comedi_cmd *cmd = &async->cmd;\n\tunsigned short data;\n\tconst int timeout = 10000;\n\tunsigned int i;\n\n\tdevpriv->stat1 = devpriv->read_byte(dev, STAT1_REG);\n\n\tfor (i = 0; (devpriv->stat1 & STAT1_DAVAIL) && i < timeout;\n\t     i++) {\n\t\t \n\t\tif (cmd->stop_src == TRIG_COUNT) {\n\t\t\tif (devpriv->count == 0)\n\t\t\t\tbreak;\n\t\t\tdevpriv->count--;\n\t\t}\n\t\tdata = labpc_read_adc_fifo(dev);\n\t\tcomedi_buf_write_samples(dev->read_subdev, &data, 1);\n\t\tdevpriv->stat1 = devpriv->read_byte(dev, STAT1_REG);\n\t}\n\tif (i == timeout) {\n\t\tdev_err(dev->class_dev, \"ai timeout, fifo never empties\\n\");\n\t\tasync->events |= COMEDI_CB_ERROR;\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void labpc_drain_dregs(struct comedi_device *dev)\n{\n\tstruct labpc_private *devpriv = dev->private;\n\n\tif (devpriv->current_transfer == isa_dma_transfer)\n\t\tlabpc_drain_dma(dev);\n\n\tlabpc_drain_fifo(dev);\n}\n\n \nstatic irqreturn_t labpc_interrupt(int irq, void *d)\n{\n\tstruct comedi_device *dev = d;\n\tconst struct labpc_boardinfo *board = dev->board_ptr;\n\tstruct labpc_private *devpriv = dev->private;\n\tstruct comedi_subdevice *s = dev->read_subdev;\n\tstruct comedi_async *async;\n\tstruct comedi_cmd *cmd;\n\n\tif (!dev->attached) {\n\t\tdev_err(dev->class_dev, \"premature interrupt\\n\");\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tasync = s->async;\n\tcmd = &async->cmd;\n\n\t \n\tdevpriv->stat1 = devpriv->read_byte(dev, STAT1_REG);\n\tif (board->is_labpc1200)\n\t\tdevpriv->stat2 = devpriv->read_byte(dev, STAT2_REG);\n\n\tif ((devpriv->stat1 & (STAT1_GATA0 | STAT1_CNTINT | STAT1_OVERFLOW |\n\t\t\t       STAT1_OVERRUN | STAT1_DAVAIL)) == 0 &&\n\t    (devpriv->stat2 & STAT2_OUTA1) == 0 &&\n\t    (devpriv->stat2 & STAT2_FIFONHF)) {\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (devpriv->stat1 & STAT1_OVERRUN) {\n\t\t \n\t\tdevpriv->write_byte(dev, 0x1, ADC_FIFO_CLEAR_REG);\n\t\tasync->events |= COMEDI_CB_ERROR;\n\t\tcomedi_handle_events(dev, s);\n\t\tdev_err(dev->class_dev, \"overrun\\n\");\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (devpriv->current_transfer == isa_dma_transfer)\n\t\tlabpc_handle_dma_status(dev);\n\telse\n\t\tlabpc_drain_fifo(dev);\n\n\tif (devpriv->stat1 & STAT1_CNTINT) {\n\t\tdev_err(dev->class_dev, \"handled timer interrupt?\\n\");\n\t\t \n\t\tdevpriv->write_byte(dev, 0x1, TIMER_CLEAR_REG);\n\t}\n\n\tif (devpriv->stat1 & STAT1_OVERFLOW) {\n\t\t \n\t\tdevpriv->write_byte(dev, 0x1, ADC_FIFO_CLEAR_REG);\n\t\tasync->events |= COMEDI_CB_ERROR;\n\t\tcomedi_handle_events(dev, s);\n\t\tdev_err(dev->class_dev, \"overflow\\n\");\n\t\treturn IRQ_HANDLED;\n\t}\n\t \n\tif (cmd->stop_src == TRIG_EXT) {\n\t\tif (devpriv->stat2 & STAT2_OUTA1) {\n\t\t\tlabpc_drain_dregs(dev);\n\t\t\tasync->events |= COMEDI_CB_EOA;\n\t\t}\n\t}\n\n\t \n\tif (cmd->stop_src == TRIG_COUNT) {\n\t\tif (devpriv->count == 0)\n\t\t\tasync->events |= COMEDI_CB_EOA;\n\t}\n\n\tcomedi_handle_events(dev, s);\n\treturn IRQ_HANDLED;\n}\n\nstatic void labpc_ao_write(struct comedi_device *dev,\n\t\t\t   struct comedi_subdevice *s,\n\t\t\t   unsigned int chan, unsigned int val)\n{\n\tstruct labpc_private *devpriv = dev->private;\n\n\tdevpriv->write_byte(dev, val & 0xff, DAC_LSB_REG(chan));\n\tdevpriv->write_byte(dev, (val >> 8) & 0xff, DAC_MSB_REG(chan));\n\n\ts->readback[chan] = val;\n}\n\nstatic int labpc_ao_insn_write(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       struct comedi_insn *insn,\n\t\t\t       unsigned int *data)\n{\n\tconst struct labpc_boardinfo *board = dev->board_ptr;\n\tstruct labpc_private *devpriv = dev->private;\n\tunsigned int channel;\n\tunsigned int range;\n\tunsigned int i;\n\tunsigned long flags;\n\n\tchannel = CR_CHAN(insn->chanspec);\n\n\t \n\tspin_lock_irqsave(&dev->spinlock, flags);\n\tdevpriv->cmd2 &= ~CMD2_LDAC(channel);\n\tdevpriv->write_byte(dev, devpriv->cmd2, CMD2_REG);\n\tspin_unlock_irqrestore(&dev->spinlock, flags);\n\n\t \n\tif (board->is_labpc1200) {\n\t\trange = CR_RANGE(insn->chanspec);\n\t\tif (comedi_range_is_unipolar(s, range))\n\t\t\tdevpriv->cmd6 |= CMD6_DACUNI(channel);\n\t\telse\n\t\t\tdevpriv->cmd6 &= ~CMD6_DACUNI(channel);\n\t\t \n\t\tdevpriv->write_byte(dev, devpriv->cmd6, CMD6_REG);\n\t}\n\t \n\tfor (i = 0; i < insn->n; i++)\n\t\tlabpc_ao_write(dev, s, channel, data[i]);\n\n\treturn insn->n;\n}\n\n \nstatic void labpc_serial_out(struct comedi_device *dev, unsigned int value,\n\t\t\t     unsigned int value_width)\n{\n\tstruct labpc_private *devpriv = dev->private;\n\tint i;\n\n\tfor (i = 1; i <= value_width; i++) {\n\t\t \n\t\tdevpriv->cmd5 &= ~CMD5_SCLK;\n\t\t \n\t\tif (value & (1 << (value_width - i)))\n\t\t\tdevpriv->cmd5 |= CMD5_SDATA;\n\t\telse\n\t\t\tdevpriv->cmd5 &= ~CMD5_SDATA;\n\t\tudelay(1);\n\t\tdevpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);\n\t\t \n\t\tdevpriv->cmd5 |= CMD5_SCLK;\n\t\tudelay(1);\n\t\tdevpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);\n\t}\n}\n\n \nstatic unsigned int labpc_serial_in(struct comedi_device *dev)\n{\n\tstruct labpc_private *devpriv = dev->private;\n\tunsigned int value = 0;\n\tint i;\n\tconst int value_width = 8;\t \n\n\tfor (i = 1; i <= value_width; i++) {\n\t\t \n\t\tdevpriv->cmd5 |= CMD5_SCLK;\n\t\tudelay(1);\n\t\tdevpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);\n\t\t \n\t\tdevpriv->cmd5 &= ~CMD5_SCLK;\n\t\tudelay(1);\n\t\tdevpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);\n\t\t \n\t\tudelay(1);\n\t\tdevpriv->stat2 = devpriv->read_byte(dev, STAT2_REG);\n\t\tif (devpriv->stat2 & STAT2_PROMOUT)\n\t\t\tvalue |= 1 << (value_width - i);\n\t}\n\n\treturn value;\n}\n\nstatic unsigned int labpc_eeprom_read(struct comedi_device *dev,\n\t\t\t\t      unsigned int address)\n{\n\tstruct labpc_private *devpriv = dev->private;\n\tunsigned int value;\n\t \n\tconst int read_instruction = 0x3;\n\t \n\tconst int write_length = 8;\n\n\t \n\tdevpriv->cmd5 &= ~CMD5_EEPROMCS;\n\tudelay(1);\n\tdevpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);\n\tdevpriv->cmd5 |= (CMD5_EEPROMCS | CMD5_WRTPRT);\n\tudelay(1);\n\tdevpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);\n\n\t \n\tlabpc_serial_out(dev, read_instruction, write_length);\n\t \n\tlabpc_serial_out(dev, address, write_length);\n\t \n\tvalue = labpc_serial_in(dev);\n\n\t \n\tdevpriv->cmd5 &= ~(CMD5_EEPROMCS | CMD5_WRTPRT);\n\tudelay(1);\n\tdevpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);\n\n\treturn value;\n}\n\nstatic unsigned int labpc_eeprom_read_status(struct comedi_device *dev)\n{\n\tstruct labpc_private *devpriv = dev->private;\n\tunsigned int value;\n\tconst int read_status_instruction = 0x5;\n\tconst int write_length = 8;\t \n\n\t \n\tdevpriv->cmd5 &= ~CMD5_EEPROMCS;\n\tudelay(1);\n\tdevpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);\n\tdevpriv->cmd5 |= (CMD5_EEPROMCS | CMD5_WRTPRT);\n\tudelay(1);\n\tdevpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);\n\n\t \n\tlabpc_serial_out(dev, read_status_instruction, write_length);\n\t \n\tvalue = labpc_serial_in(dev);\n\n\t \n\tdevpriv->cmd5 &= ~(CMD5_EEPROMCS | CMD5_WRTPRT);\n\tudelay(1);\n\tdevpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);\n\n\treturn value;\n}\n\nstatic void labpc_eeprom_write(struct comedi_device *dev,\n\t\t\t       unsigned int address, unsigned int value)\n{\n\tstruct labpc_private *devpriv = dev->private;\n\tconst int write_enable_instruction = 0x6;\n\tconst int write_instruction = 0x2;\n\tconst int write_length = 8;\t \n\n\t \n\tdevpriv->cmd5 &= ~CMD5_EEPROMCS;\n\tudelay(1);\n\tdevpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);\n\tdevpriv->cmd5 |= (CMD5_EEPROMCS | CMD5_WRTPRT);\n\tudelay(1);\n\tdevpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);\n\n\t \n\tlabpc_serial_out(dev, write_enable_instruction, write_length);\n\tdevpriv->cmd5 &= ~CMD5_EEPROMCS;\n\tudelay(1);\n\tdevpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);\n\n\t \n\tdevpriv->cmd5 |= CMD5_EEPROMCS;\n\tudelay(1);\n\tdevpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);\n\tlabpc_serial_out(dev, write_instruction, write_length);\n\t \n\tlabpc_serial_out(dev, address, write_length);\n\t \n\tlabpc_serial_out(dev, value, write_length);\n\tdevpriv->cmd5 &= ~CMD5_EEPROMCS;\n\tudelay(1);\n\tdevpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);\n\n\t \n\tdevpriv->cmd5 &= ~(CMD5_EEPROMCS | CMD5_WRTPRT);\n\tudelay(1);\n\tdevpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);\n}\n\n \nstatic void write_caldac(struct comedi_device *dev, unsigned int channel,\n\t\t\t unsigned int value)\n{\n\tstruct labpc_private *devpriv = dev->private;\n\n\t \n\tdevpriv->cmd5 &= ~(CMD5_CALDACLD | CMD5_EEPROMCS | CMD5_WRTPRT);\n\tudelay(1);\n\tdevpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);\n\n\t \n\tlabpc_serial_out(dev, channel, 4);\n\t \n\tlabpc_serial_out(dev, value, 8);\n\n\t \n\tdevpriv->cmd5 |= CMD5_CALDACLD;\n\tudelay(1);\n\tdevpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);\n\tdevpriv->cmd5 &= ~CMD5_CALDACLD;\n\tudelay(1);\n\tdevpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);\n}\n\nstatic int labpc_calib_insn_write(struct comedi_device *dev,\n\t\t\t\t  struct comedi_subdevice *s,\n\t\t\t\t  struct comedi_insn *insn,\n\t\t\t\t  unsigned int *data)\n{\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\n\t \n\tif (insn->n > 0) {\n\t\tunsigned int val = data[insn->n - 1];\n\n\t\tif (s->readback[chan] != val) {\n\t\t\twrite_caldac(dev, chan, val);\n\t\t\ts->readback[chan] = val;\n\t\t}\n\t}\n\n\treturn insn->n;\n}\n\nstatic int labpc_eeprom_ready(struct comedi_device *dev,\n\t\t\t      struct comedi_subdevice *s,\n\t\t\t      struct comedi_insn *insn,\n\t\t\t      unsigned long context)\n{\n\tunsigned int status;\n\n\t \n\tstatus = labpc_eeprom_read_status(dev);\n\tif ((status & 0x1) == 0)\n\t\treturn 0;\n\treturn -EBUSY;\n}\n\nstatic int labpc_eeprom_insn_write(struct comedi_device *dev,\n\t\t\t\t   struct comedi_subdevice *s,\n\t\t\t\t   struct comedi_insn *insn,\n\t\t\t\t   unsigned int *data)\n{\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tint ret;\n\n\t \n\tif (chan < 16 || chan > 127)\n\t\treturn -EINVAL;\n\n\t \n\tif (insn->n > 0) {\n\t\tunsigned int val = data[insn->n - 1];\n\n\t\tret = comedi_timeout(dev, s, insn, labpc_eeprom_ready, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tlabpc_eeprom_write(dev, chan, val);\n\t\ts->readback[chan] = val;\n\t}\n\n\treturn insn->n;\n}\n\nint labpc_common_attach(struct comedi_device *dev,\n\t\t\tunsigned int irq, unsigned long isr_flags)\n{\n\tconst struct labpc_boardinfo *board = dev->board_ptr;\n\tstruct labpc_private *devpriv;\n\tstruct comedi_subdevice *s;\n\tint ret;\n\tint i;\n\n\tdevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\n\tif (!devpriv)\n\t\treturn -ENOMEM;\n\n\tif (dev->mmio) {\n\t\tdevpriv->read_byte = labpc_readb;\n\t\tdevpriv->write_byte = labpc_writeb;\n\t} else {\n\t\tdevpriv->read_byte = labpc_inb;\n\t\tdevpriv->write_byte = labpc_outb;\n\t}\n\n\t \n\tdevpriv->write_byte(dev, devpriv->cmd1, CMD1_REG);\n\tdevpriv->write_byte(dev, devpriv->cmd2, CMD2_REG);\n\tdevpriv->write_byte(dev, devpriv->cmd3, CMD3_REG);\n\tdevpriv->write_byte(dev, devpriv->cmd4, CMD4_REG);\n\tif (board->is_labpc1200) {\n\t\tdevpriv->write_byte(dev, devpriv->cmd5, CMD5_REG);\n\t\tdevpriv->write_byte(dev, devpriv->cmd6, CMD6_REG);\n\t}\n\n\tif (irq) {\n\t\tret = request_irq(irq, labpc_interrupt, isr_flags,\n\t\t\t\t  dev->board_name, dev);\n\t\tif (ret == 0)\n\t\t\tdev->irq = irq;\n\t}\n\n\tif (dev->mmio) {\n\t\tdev->pacer = comedi_8254_mm_init(dev->mmio + COUNTER_B_BASE_REG,\n\t\t\t\t\t\t I8254_OSC_BASE_2MHZ,\n\t\t\t\t\t\t I8254_IO8, 0);\n\t\tdevpriv->counter = comedi_8254_mm_init(dev->mmio +\n\t\t\t\t\t\t       COUNTER_A_BASE_REG,\n\t\t\t\t\t\t       I8254_OSC_BASE_2MHZ,\n\t\t\t\t\t\t       I8254_IO8, 0);\n\t} else {\n\t\tdev->pacer = comedi_8254_init(dev->iobase + COUNTER_B_BASE_REG,\n\t\t\t\t\t      I8254_OSC_BASE_2MHZ,\n\t\t\t\t\t      I8254_IO8, 0);\n\t\tdevpriv->counter = comedi_8254_init(dev->iobase +\n\t\t\t\t\t\t    COUNTER_A_BASE_REG,\n\t\t\t\t\t\t    I8254_OSC_BASE_2MHZ,\n\t\t\t\t\t\t    I8254_IO8, 0);\n\t}\n\tif (!dev->pacer || !devpriv->counter)\n\t\treturn -ENOMEM;\n\n\tret = comedi_alloc_subdevices(dev, 5);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ts = &dev->subdevices[0];\n\ts->type\t\t= COMEDI_SUBD_AI;\n\ts->subdev_flags\t= SDF_READABLE | SDF_GROUND | SDF_COMMON | SDF_DIFF;\n\ts->n_chan\t= 8;\n\ts->len_chanlist\t= 8;\n\ts->maxdata\t= 0x0fff;\n\ts->range_table\t= board->is_labpc1200 ?\n\t\t\t  &range_labpc_1200_ai : &range_labpc_plus_ai;\n\ts->insn_read\t= labpc_ai_insn_read;\n\tif (dev->irq) {\n\t\tdev->read_subdev = s;\n\t\ts->subdev_flags\t|= SDF_CMD_READ;\n\t\ts->do_cmd\t= labpc_ai_cmd;\n\t\ts->do_cmdtest\t= labpc_ai_cmdtest;\n\t\ts->cancel\t= labpc_cancel;\n\t}\n\n\t \n\ts = &dev->subdevices[1];\n\tif (board->has_ao) {\n\t\ts->type\t\t= COMEDI_SUBD_AO;\n\t\ts->subdev_flags\t= SDF_READABLE | SDF_WRITABLE | SDF_GROUND;\n\t\ts->n_chan\t= 2;\n\t\ts->maxdata\t= 0x0fff;\n\t\ts->range_table\t= &range_labpc_ao;\n\t\ts->insn_write\t= labpc_ao_insn_write;\n\n\t\tret = comedi_alloc_subdev_readback(s);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tfor (i = 0; i < s->n_chan; i++)\n\t\t\tlabpc_ao_write(dev, s, i, s->maxdata / 2);\n\t} else {\n\t\ts->type\t\t= COMEDI_SUBD_UNUSED;\n\t}\n\n\t \n\ts = &dev->subdevices[2];\n\tif (dev->mmio)\n\t\tret = subdev_8255_mm_init(dev, s, NULL, DIO_BASE_REG);\n\telse\n\t\tret = subdev_8255_init(dev, s, NULL, DIO_BASE_REG);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ts = &dev->subdevices[3];\n\tif (board->is_labpc1200) {\n\t\ts->type\t\t= COMEDI_SUBD_CALIB;\n\t\ts->subdev_flags\t= SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;\n\t\ts->n_chan\t= 16;\n\t\ts->maxdata\t= 0xff;\n\t\ts->insn_write\t= labpc_calib_insn_write;\n\n\t\tret = comedi_alloc_subdev_readback(s);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tfor (i = 0; i < s->n_chan; i++) {\n\t\t\twrite_caldac(dev, i, s->maxdata / 2);\n\t\t\ts->readback[i] = s->maxdata / 2;\n\t\t}\n\t} else {\n\t\ts->type\t\t= COMEDI_SUBD_UNUSED;\n\t}\n\n\t \n\ts = &dev->subdevices[4];\n\tif (board->is_labpc1200) {\n\t\ts->type\t\t= COMEDI_SUBD_MEMORY;\n\t\ts->subdev_flags\t= SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;\n\t\ts->n_chan\t= 256;\n\t\ts->maxdata\t= 0xff;\n\t\ts->insn_write\t= labpc_eeprom_insn_write;\n\n\t\tret = comedi_alloc_subdev_readback(s);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tfor (i = 0; i < s->n_chan; i++)\n\t\t\ts->readback[i] = labpc_eeprom_read(dev, i);\n\t} else {\n\t\ts->type\t\t= COMEDI_SUBD_UNUSED;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(labpc_common_attach);\n\nvoid labpc_common_detach(struct comedi_device *dev)\n{\n\tstruct labpc_private *devpriv = dev->private;\n\n\tif (devpriv)\n\t\tkfree(devpriv->counter);\n}\nEXPORT_SYMBOL_GPL(labpc_common_detach);\n\nstatic int __init labpc_common_init(void)\n{\n\treturn 0;\n}\nmodule_init(labpc_common_init);\n\nstatic void __exit labpc_common_exit(void)\n{\n}\nmodule_exit(labpc_common_exit);\n\nMODULE_AUTHOR(\"Comedi https://www.comedi.org\");\nMODULE_DESCRIPTION(\"Comedi helper for ni_labpc, ni_labpc_pci, ni_labpc_cs\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}