{
  "module_name": "mf6x4.c",
  "hash_id": "c778d7a97eea3225dec1b5a15708910b925c4d1cf794eda00ed255707daba4d1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/mf6x4.c",
  "human_readable_source": "\n \n \n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/comedi/comedi_pci.h>\n\n \n#define MF624_GPIOC_REG\t\t0x54\n\n#define MF6X4_GPIOC_EOLC\tBIT(17)\t \n#define MF6X4_GPIOC_LDAC\tBIT(23)\t \n#define MF6X4_GPIOC_DACEN\tBIT(26)\n\n \n#define MF6X4_ADDATA_REG\t0x00\n#define MF6X4_ADCTRL_REG\t0x00\n#define MF6X4_ADCTRL_CHAN(x)\tBIT(chan)\n#define MF6X4_DIN_REG\t\t0x10\n#define MF6X4_DIN_MASK\t\t0xff\n#define MF6X4_DOUT_REG\t\t0x10\n#define MF6X4_ADSTART_REG\t0x20\n#define MF6X4_DAC_REG(x)\t(0x20 + ((x) * 2))\n\n \n#define MF634_GPIOC_REG\t\t0x68\n\nenum mf6x4_boardid {\n\tBOARD_MF634,\n\tBOARD_MF624,\n};\n\nstruct mf6x4_board {\n\tconst char *name;\n\t \n\tunsigned int bar_nums[3];\n};\n\nstatic const struct mf6x4_board mf6x4_boards[] = {\n\t[BOARD_MF634] = {\n\t\t.name           = \"mf634\",\n\t\t.bar_nums\t= {0, 2, 3},\n\t},\n\t[BOARD_MF624] = {\n\t\t.name           = \"mf624\",\n\t\t.bar_nums\t= {0, 2, 4},\n\t},\n};\n\nstruct mf6x4_private {\n\t \n\tvoid __iomem *bar0_mem;\n\tvoid __iomem *bar2_mem;\n\n\t \n\tvoid __iomem *gpioc_reg;\n};\n\nstatic int mf6x4_di_insn_bits(struct comedi_device *dev,\n\t\t\t      struct comedi_subdevice *s,\n\t\t\t      struct comedi_insn *insn,\n\t\t\t      unsigned int *data)\n{\n\tdata[1] = ioread16(dev->mmio + MF6X4_DIN_REG) & MF6X4_DIN_MASK;\n\n\treturn insn->n;\n}\n\nstatic int mf6x4_do_insn_bits(struct comedi_device *dev,\n\t\t\t      struct comedi_subdevice *s,\n\t\t\t      struct comedi_insn *insn,\n\t\t\t      unsigned int *data)\n{\n\tif (comedi_dio_update_state(s, data))\n\t\tiowrite16(s->state, dev->mmio + MF6X4_DOUT_REG);\n\n\tdata[1] = s->state;\n\n\treturn insn->n;\n}\n\nstatic int mf6x4_ai_eoc(struct comedi_device *dev,\n\t\t\tstruct comedi_subdevice *s,\n\t\t\tstruct comedi_insn *insn,\n\t\t\tunsigned long context)\n{\n\tstruct mf6x4_private *devpriv = dev->private;\n\tunsigned int status;\n\n\t \n\tstatus = ioread32(devpriv->gpioc_reg);\n\tif ((status & MF6X4_GPIOC_EOLC) == 0)\n\t\treturn 0;\n\treturn -EBUSY;\n}\n\nstatic int mf6x4_ai_insn_read(struct comedi_device *dev,\n\t\t\t      struct comedi_subdevice *s,\n\t\t\t      struct comedi_insn *insn,\n\t\t\t      unsigned int *data)\n{\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int d;\n\tint ret;\n\tint i;\n\n\t \n\tiowrite16(MF6X4_ADCTRL_CHAN(chan), dev->mmio + MF6X4_ADCTRL_REG);\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\t \n\t\tioread16(dev->mmio + MF6X4_ADSTART_REG);\n\n\t\tret = comedi_timeout(dev, s, insn, mf6x4_ai_eoc, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\td = ioread16(dev->mmio + MF6X4_ADDATA_REG);\n\t\td &= s->maxdata;\n\t\t \n\t\tdata[i] = comedi_offset_munge(s, d);\n\t}\n\n\tiowrite16(0x0, dev->mmio + MF6X4_ADCTRL_REG);\n\n\treturn insn->n;\n}\n\nstatic int mf6x4_ao_insn_write(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       struct comedi_insn *insn,\n\t\t\t       unsigned int *data)\n{\n\tstruct mf6x4_private *devpriv = dev->private;\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int val = s->readback[chan];\n\tunsigned int gpioc;\n\tint i;\n\n\t \n\tgpioc = ioread32(devpriv->gpioc_reg);\n\tiowrite32((gpioc & ~MF6X4_GPIOC_LDAC) | MF6X4_GPIOC_DACEN,\n\t\t  devpriv->gpioc_reg);\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\tval = data[i];\n\t\tiowrite16(val, dev->mmio + MF6X4_DAC_REG(chan));\n\t}\n\ts->readback[chan] = val;\n\n\treturn insn->n;\n}\n\nstatic int mf6x4_auto_attach(struct comedi_device *dev, unsigned long context)\n{\n\tstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\n\tconst struct mf6x4_board *board = NULL;\n\tstruct mf6x4_private *devpriv;\n\tstruct comedi_subdevice *s;\n\tint ret;\n\n\tif (context < ARRAY_SIZE(mf6x4_boards))\n\t\tboard = &mf6x4_boards[context];\n\telse\n\t\treturn -ENODEV;\n\n\tdev->board_ptr = board;\n\tdev->board_name = board->name;\n\n\tret = comedi_pci_enable(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tdevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\n\tif (!devpriv)\n\t\treturn -ENOMEM;\n\n\tdevpriv->bar0_mem = pci_ioremap_bar(pcidev, board->bar_nums[0]);\n\tif (!devpriv->bar0_mem)\n\t\treturn -ENODEV;\n\n\tdev->mmio = pci_ioremap_bar(pcidev, board->bar_nums[1]);\n\tif (!dev->mmio)\n\t\treturn -ENODEV;\n\n\tdevpriv->bar2_mem = pci_ioremap_bar(pcidev, board->bar_nums[2]);\n\tif (!devpriv->bar2_mem)\n\t\treturn -ENODEV;\n\n\tif (board == &mf6x4_boards[BOARD_MF634])\n\t\tdevpriv->gpioc_reg = devpriv->bar2_mem + MF634_GPIOC_REG;\n\telse\n\t\tdevpriv->gpioc_reg = devpriv->bar0_mem + MF624_GPIOC_REG;\n\n\tret = comedi_alloc_subdevices(dev, 4);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ts = &dev->subdevices[0];\n\ts->type\t\t= COMEDI_SUBD_AI;\n\ts->subdev_flags\t= SDF_READABLE | SDF_GROUND;\n\ts->n_chan\t= 8;\n\ts->maxdata\t= 0x3fff;\n\ts->range_table\t= &range_bipolar10;\n\ts->insn_read\t= mf6x4_ai_insn_read;\n\n\t \n\ts = &dev->subdevices[1];\n\ts->type\t\t= COMEDI_SUBD_AO;\n\ts->subdev_flags\t= SDF_WRITABLE;\n\ts->n_chan\t= 8;\n\ts->maxdata\t= 0x3fff;\n\ts->range_table\t= &range_bipolar10;\n\ts->insn_write\t= mf6x4_ao_insn_write;\n\n\tret = comedi_alloc_subdev_readback(s);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ts = &dev->subdevices[2];\n\ts->type\t\t= COMEDI_SUBD_DI;\n\ts->subdev_flags\t= SDF_READABLE;\n\ts->n_chan\t= 8;\n\ts->maxdata\t= 1;\n\ts->range_table\t= &range_digital;\n\ts->insn_bits\t= mf6x4_di_insn_bits;\n\n\t \n\ts = &dev->subdevices[3];\n\ts->type\t\t= COMEDI_SUBD_DO;\n\ts->subdev_flags\t= SDF_WRITABLE;\n\ts->n_chan\t= 8;\n\ts->maxdata\t= 1;\n\ts->range_table\t= &range_digital;\n\ts->insn_bits\t= mf6x4_do_insn_bits;\n\n\treturn 0;\n}\n\nstatic void mf6x4_detach(struct comedi_device *dev)\n{\n\tstruct mf6x4_private *devpriv = dev->private;\n\n\tif (devpriv) {\n\t\tif (devpriv->bar0_mem)\n\t\t\tiounmap(devpriv->bar0_mem);\n\t\tif (devpriv->bar2_mem)\n\t\t\tiounmap(devpriv->bar2_mem);\n\t}\n\tcomedi_pci_detach(dev);\n}\n\nstatic struct comedi_driver mf6x4_driver = {\n\t.driver_name    = \"mf6x4\",\n\t.module         = THIS_MODULE,\n\t.auto_attach    = mf6x4_auto_attach,\n\t.detach         = mf6x4_detach,\n};\n\nstatic int mf6x4_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)\n{\n\treturn comedi_pci_auto_config(dev, &mf6x4_driver, id->driver_data);\n}\n\nstatic const struct pci_device_id mf6x4_pci_table[] = {\n\t{ PCI_VDEVICE(HUMUSOFT, 0x0634), BOARD_MF634 },\n\t{ PCI_VDEVICE(HUMUSOFT, 0x0624), BOARD_MF624 },\n\t{ 0 }\n};\nMODULE_DEVICE_TABLE(pci, mf6x4_pci_table);\n\nstatic struct pci_driver mf6x4_pci_driver = {\n\t.name           = \"mf6x4\",\n\t.id_table       = mf6x4_pci_table,\n\t.probe          = mf6x4_pci_probe,\n\t.remove         = comedi_pci_auto_unconfig,\n};\n\nmodule_comedi_pci_driver(mf6x4_driver, mf6x4_pci_driver);\n\nMODULE_AUTHOR(\"Rostislav Lisovy <lisovy@gmail.com>\");\nMODULE_DESCRIPTION(\"Comedi MF634 and MF624 DAQ cards driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}