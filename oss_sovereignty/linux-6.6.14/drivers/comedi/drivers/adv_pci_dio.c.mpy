{
  "module_name": "adv_pci_dio.c",
  "hash_id": "4299969dce747737f93f8157929681cc0f0704b9edbb62aaee76d4bf65d0dcd7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/adv_pci_dio.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/comedi/comedi_pci.h>\n#include <linux/comedi/comedi_8255.h>\n#include <linux/comedi/comedi_8254.h>\n\n \n\n \n#define PCI173X_INT_EN_REG\t0x0008\t \n#define PCI173X_INT_RF_REG\t0x000c\t \n#define PCI173X_INT_FLAG_REG\t0x0010\t \n#define PCI173X_INT_CLR_REG\t0x0010\t \n\n#define PCI173X_INT_IDI0 0x01   \n#define PCI173X_INT_IDI1 0x02   \n#define PCI173X_INT_DI0  0x04   \n#define PCI173X_INT_DI1  0x08   \n\n \n#define PCI1750_INT_REG\t\t0x20\t \n\n \n#define PCI1753_INT_REG(x)\t(0x10 + (x))  \n#define PCI1753E_INT_REG(x)\t(0x30 + (x))  \n\n \n#define PCI1754_INT_REG(x)\t(0x08 + (x) * 2)  \n\n \n#define PCI1752_CFC_REG\t\t0x12\t \n\n \n#define PCI1761_INT_EN_REG\t0x03\t \n#define PCI1761_INT_RF_REG\t0x04\t \n#define PCI1761_INT_CLR_REG\t0x05\t \n\n \n#define PCI1762_INT_REG\t\t0x06\t \n\n \n#define PCI_DIO_MAX_DI_SUBDEVS\t2\t \n#define PCI_DIO_MAX_DO_SUBDEVS\t2\t \n#define PCI_DIO_MAX_DIO_SUBDEVG\t2\t \n#define PCI_DIO_MAX_IRQ_SUBDEVS\t4\t \n\nenum pci_dio_boardid {\n\tTYPE_PCI1730,\n\tTYPE_PCI1733,\n\tTYPE_PCI1734,\n\tTYPE_PCI1735,\n\tTYPE_PCI1736,\n\tTYPE_PCI1739,\n\tTYPE_PCI1750,\n\tTYPE_PCI1751,\n\tTYPE_PCI1752,\n\tTYPE_PCI1753,\n\tTYPE_PCI1753E,\n\tTYPE_PCI1754,\n\tTYPE_PCI1756,\n\tTYPE_PCI1761,\n\tTYPE_PCI1762\n};\n\nstruct diosubd_data {\n\tint chans;\t\t \n\tunsigned long addr;\t \n};\n\nstruct dio_irq_subd_data {\n\tunsigned short int_en;\t\t \n\tunsigned long addr;\t\t \n};\n\nstruct dio_boardtype {\n\tconst char *name;\t \n\tint nsubdevs;\n\tstruct diosubd_data sdi[PCI_DIO_MAX_DI_SUBDEVS];\n\tstruct diosubd_data sdo[PCI_DIO_MAX_DO_SUBDEVS];\n\tstruct diosubd_data sdio[PCI_DIO_MAX_DIO_SUBDEVG];\n\tstruct dio_irq_subd_data sdirq[PCI_DIO_MAX_IRQ_SUBDEVS];\n\tunsigned long id_reg;\n\tunsigned long timer_regbase;\n\tunsigned int is_16bit:1;\n};\n\nstatic const struct dio_boardtype boardtypes[] = {\n\t[TYPE_PCI1730] = {\n\t\t.name\t\t= \"pci1730\",\n\t\t \n\t\t.nsubdevs\t= 9,\n\t\t.sdi[0]\t\t= { 16, 0x02, },\t \n\t\t.sdi[1]\t\t= { 16, 0x00, },\t \n\t\t.sdo[0]\t\t= { 16, 0x02, },\t \n\t\t.sdo[1]\t\t= { 16, 0x00, },\t \n\t\t.id_reg\t\t= 0x04,\n\t\t.sdirq[0]\t= { PCI173X_INT_DI0,  0x02, },\t \n\t\t.sdirq[1]\t= { PCI173X_INT_DI1,  0x02, },\t \n\t\t.sdirq[2]\t= { PCI173X_INT_IDI0, 0x00, },\t \n\t\t.sdirq[3]\t= { PCI173X_INT_IDI1, 0x00, },\t \n\t},\n\t[TYPE_PCI1733] = {\n\t\t.name\t\t= \"pci1733\",\n\t\t.nsubdevs\t= 2,\n\t\t.sdi[1]\t\t= { 32, 0x00, },\t \n\t\t.id_reg\t\t= 0x04,\n\t},\n\t[TYPE_PCI1734] = {\n\t\t.name\t\t= \"pci1734\",\n\t\t.nsubdevs\t= 2,\n\t\t.sdo[1]\t\t= { 32, 0x00, },\t \n\t\t.id_reg\t\t= 0x04,\n\t},\n\t[TYPE_PCI1735] = {\n\t\t.name\t\t= \"pci1735\",\n\t\t.nsubdevs\t= 4,\n\t\t.sdi[0]\t\t= { 32, 0x00, },\t \n\t\t.sdo[0]\t\t= { 32, 0x00, },\t \n\t\t.id_reg\t\t= 0x08,\n\t\t.timer_regbase\t= 0x04,\n\t},\n\t[TYPE_PCI1736] = {\n\t\t.name\t\t= \"pci1736\",\n\t\t.nsubdevs\t= 3,\n\t\t.sdi[1]\t\t= { 16, 0x00, },\t \n\t\t.sdo[1]\t\t= { 16, 0x00, },\t \n\t\t.id_reg\t\t= 0x04,\n\t},\n\t[TYPE_PCI1739] = {\n\t\t.name\t\t= \"pci1739\",\n\t\t.nsubdevs\t= 3,\n\t\t.sdio[0]\t= { 2, 0x00, },\t\t \n\t\t.id_reg\t\t= 0x08,\n\t},\n\t[TYPE_PCI1750] = {\n\t\t.name\t\t= \"pci1750\",\n\t\t.nsubdevs\t= 2,\n\t\t.sdi[1]\t\t= { 16, 0x00, },\t \n\t\t.sdo[1]\t\t= { 16, 0x00, },\t \n\t},\n\t[TYPE_PCI1751] = {\n\t\t.name\t\t= \"pci1751\",\n\t\t.nsubdevs\t= 3,\n\t\t.sdio[0]\t= { 2, 0x00, },\t\t \n\t\t.timer_regbase\t= 0x18,\n\t},\n\t[TYPE_PCI1752] = {\n\t\t.name\t\t= \"pci1752\",\n\t\t.nsubdevs\t= 3,\n\t\t.sdo[0]\t\t= { 32, 0x00, },\t \n\t\t.sdo[1]\t\t= { 32, 0x04, },\t \n\t\t.id_reg\t\t= 0x10,\n\t\t.is_16bit\t= 1,\n\t},\n\t[TYPE_PCI1753] = {\n\t\t.name\t\t= \"pci1753\",\n\t\t.nsubdevs\t= 4,\n\t\t.sdio[0]\t= { 4, 0x00, },\t\t \n\t},\n\t[TYPE_PCI1753E] = {\n\t\t.name\t\t= \"pci1753e\",\n\t\t.nsubdevs\t= 8,\n\t\t.sdio[0]\t= { 4, 0x00, },\t\t \n\t\t.sdio[1]\t= { 4, 0x20, },\t\t \n\t},\n\t[TYPE_PCI1754] = {\n\t\t.name\t\t= \"pci1754\",\n\t\t.nsubdevs\t= 3,\n\t\t.sdi[0]\t\t= { 32, 0x00, },\t \n\t\t.sdi[1]\t\t= { 32, 0x04, },\t \n\t\t.id_reg\t\t= 0x10,\n\t\t.is_16bit\t= 1,\n\t},\n\t[TYPE_PCI1756] = {\n\t\t.name\t\t= \"pci1756\",\n\t\t.nsubdevs\t= 3,\n\t\t.sdi[1]\t\t= { 32, 0x00, },\t \n\t\t.sdo[1]\t\t= { 32, 0x04, },\t \n\t\t.id_reg\t\t= 0x10,\n\t\t.is_16bit\t= 1,\n\t},\n\t[TYPE_PCI1761] = {\n\t\t.name\t\t= \"pci1761\",\n\t\t.nsubdevs\t= 3,\n\t\t.sdi[1]\t\t= { 8, 0x01 },\t\t \n\t\t.sdo[1]\t\t= { 8, 0x00 },\t\t \n\t\t.id_reg\t\t= 0x02,\n\t},\n\t[TYPE_PCI1762] = {\n\t\t.name\t\t= \"pci1762\",\n\t\t.nsubdevs\t= 3,\n\t\t.sdi[1]\t\t= { 16, 0x02, },\t \n\t\t.sdo[1]\t\t= { 16, 0x00, },\t \n\t\t.id_reg\t\t= 0x04,\n\t\t.is_16bit\t= 1,\n\t},\n};\n\nstruct pci_dio_dev_private_data {\n\tint boardtype;\n\tint irq_subd;\n\tunsigned short int_ctrl;\n\tunsigned short int_rf;\n};\n\nstruct pci_dio_sd_private_data {\n\tspinlock_t subd_slock;\t\t \n\tunsigned long port_offset;\n\tshort int cmd_running;\n};\n\nstatic void process_irq(struct comedi_device *dev, unsigned int subdev,\n\t\t\tunsigned char irqflags)\n{\n\tstruct comedi_subdevice *s = &dev->subdevices[subdev];\n\tstruct pci_dio_sd_private_data *sd_priv = s->private;\n\tunsigned long reg = sd_priv->port_offset;\n\tstruct comedi_async *async_p = s->async;\n\n\tif (async_p) {\n\t\tunsigned short val = inw(dev->iobase + reg);\n\n\t\tspin_lock(&sd_priv->subd_slock);\n\t\tif (sd_priv->cmd_running)\n\t\t\tcomedi_buf_write_samples(s, &val, 1);\n\t\tspin_unlock(&sd_priv->subd_slock);\n\t\tcomedi_handle_events(dev, s);\n\t}\n}\n\nstatic irqreturn_t pci_dio_interrupt(int irq, void *p_device)\n{\n\tstruct comedi_device *dev = p_device;\n\tstruct pci_dio_dev_private_data *dev_private = dev->private;\n\tconst struct dio_boardtype *board = dev->board_ptr;\n\tunsigned long cpu_flags;\n\tunsigned char irqflags;\n\tint i;\n\n\tif (!dev->attached) {\n\t\t \n\t\t \n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\tspin_lock_irqsave(&dev->spinlock, cpu_flags);\n\tirqflags = inb(dev->iobase + PCI173X_INT_FLAG_REG);\n\tif (!(irqflags & 0x0F)) {\n\t\tspin_unlock_irqrestore(&dev->spinlock, cpu_flags);\n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\toutb(irqflags, dev->iobase + PCI173X_INT_CLR_REG);\n\tspin_unlock_irqrestore(&dev->spinlock, cpu_flags);\n\n\t \n\tfor (i = 0; i < PCI_DIO_MAX_IRQ_SUBDEVS; i++) {\n\t\tif (irqflags & board->sdirq[i].int_en)\n\t\t\tprocess_irq(dev, dev_private->irq_subd + i, irqflags);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int pci_dio_asy_cmdtest(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       struct comedi_cmd *cmd)\n{\n\tint err = 0;\n\n\t \n\n\terr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW);\n\terr |= comedi_check_trigger_src(&cmd->scan_begin_src, TRIG_EXT);\n\terr |= comedi_check_trigger_src(&cmd->convert_src, TRIG_FOLLOW);\n\terr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\n\terr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_NONE);\n\n\tif (err)\n\t\treturn 1;\n\n\t \n\t \n\n\t \n\n\terr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\n\t \n\tif (cmd->scan_begin_arg & ~(CR_EDGE | CR_INVERT)) {\n\t\tcmd->scan_begin_arg &= (CR_EDGE | CR_INVERT);\n\t\terr |= -EINVAL;\n\t}\n\terr |= comedi_check_trigger_arg_is(&cmd->convert_arg, 0);\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\n\t\t\t\t\t   cmd->chanlist_len);\n\terr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\n\n\tif (err)\n\t\treturn 3;\n\n\t \n\n\t \n\n\treturn 0;\n}\n\nstatic int pci_dio_asy_cmd(struct comedi_device *dev,\n\t\t\t   struct comedi_subdevice *s)\n{\n\tstruct pci_dio_dev_private_data *dev_private = dev->private;\n\tstruct pci_dio_sd_private_data *sd_priv = s->private;\n\tconst struct dio_boardtype *board = dev->board_ptr;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tunsigned long cpu_flags;\n\tunsigned short int_en;\n\n\tint_en = board->sdirq[s->index - dev_private->irq_subd].int_en;\n\n\tspin_lock_irqsave(&dev->spinlock, cpu_flags);\n\tif (cmd->scan_begin_arg & CR_INVERT)\n\t\tdev_private->int_rf |= int_en;\t \n\telse\n\t\tdev_private->int_rf &= ~int_en;\t \n\toutb(dev_private->int_rf, dev->iobase + PCI173X_INT_RF_REG);\n\tdev_private->int_ctrl |= int_en;\t \n\toutb(dev_private->int_ctrl, dev->iobase + PCI173X_INT_EN_REG);\n\tspin_unlock_irqrestore(&dev->spinlock, cpu_flags);\n\n\tspin_lock_irqsave(&sd_priv->subd_slock, cpu_flags);\n\tsd_priv->cmd_running = 1;\n\tspin_unlock_irqrestore(&sd_priv->subd_slock, cpu_flags);\n\n\treturn 0;\n}\n\nstatic int pci_dio_asy_cancel(struct comedi_device *dev,\n\t\t\t      struct comedi_subdevice *s)\n{\n\tstruct pci_dio_dev_private_data *dev_private = dev->private;\n\tstruct pci_dio_sd_private_data *sd_priv = s->private;\n\tconst struct dio_boardtype *board = dev->board_ptr;\n\tunsigned long cpu_flags;\n\tunsigned short int_en;\n\n\tspin_lock_irqsave(&sd_priv->subd_slock, cpu_flags);\n\tsd_priv->cmd_running = 0;\n\tspin_unlock_irqrestore(&sd_priv->subd_slock, cpu_flags);\n\n\tint_en = board->sdirq[s->index - dev_private->irq_subd].int_en;\n\n\tspin_lock_irqsave(&dev->spinlock, cpu_flags);\n\tdev_private->int_ctrl &= ~int_en;\n\toutb(dev_private->int_ctrl, dev->iobase + PCI173X_INT_EN_REG);\n\tspin_unlock_irqrestore(&dev->spinlock, cpu_flags);\n\n\treturn 0;\n}\n\n \nstatic int pci_dio_insn_bits_dirq_b(struct comedi_device *dev,\n\t\t\t\t    struct comedi_subdevice *s,\n\t\t\t\t    struct comedi_insn *insn,\n\t\t\t\t    unsigned int *data)\n{\n\tstruct pci_dio_sd_private_data *sd_priv = s->private;\n\tunsigned long reg = (unsigned long)sd_priv->port_offset;\n\tunsigned long iobase = dev->iobase + reg;\n\n\tdata[1] = inb(iobase);\n\n\treturn insn->n;\n}\n\nstatic int pci_dio_insn_bits_di_b(struct comedi_device *dev,\n\t\t\t\t  struct comedi_subdevice *s,\n\t\t\t\t  struct comedi_insn *insn,\n\t\t\t\t  unsigned int *data)\n{\n\tunsigned long reg = (unsigned long)s->private;\n\tunsigned long iobase = dev->iobase + reg;\n\n\tdata[1] = inb(iobase);\n\tif (s->n_chan > 8)\n\t\tdata[1] |= (inb(iobase + 1) << 8);\n\tif (s->n_chan > 16)\n\t\tdata[1] |= (inb(iobase + 2) << 16);\n\tif (s->n_chan > 24)\n\t\tdata[1] |= (inb(iobase + 3) << 24);\n\n\treturn insn->n;\n}\n\nstatic int pci_dio_insn_bits_di_w(struct comedi_device *dev,\n\t\t\t\t  struct comedi_subdevice *s,\n\t\t\t\t  struct comedi_insn *insn,\n\t\t\t\t  unsigned int *data)\n{\n\tunsigned long reg = (unsigned long)s->private;\n\tunsigned long iobase = dev->iobase + reg;\n\n\tdata[1] = inw(iobase);\n\tif (s->n_chan > 16)\n\t\tdata[1] |= (inw(iobase + 2) << 16);\n\n\treturn insn->n;\n}\n\nstatic int pci_dio_insn_bits_do_b(struct comedi_device *dev,\n\t\t\t\t  struct comedi_subdevice *s,\n\t\t\t\t  struct comedi_insn *insn,\n\t\t\t\t  unsigned int *data)\n{\n\tunsigned long reg = (unsigned long)s->private;\n\tunsigned long iobase = dev->iobase + reg;\n\n\tif (comedi_dio_update_state(s, data)) {\n\t\toutb(s->state & 0xff, iobase);\n\t\tif (s->n_chan > 8)\n\t\t\toutb((s->state >> 8) & 0xff, iobase + 1);\n\t\tif (s->n_chan > 16)\n\t\t\toutb((s->state >> 16) & 0xff, iobase + 2);\n\t\tif (s->n_chan > 24)\n\t\t\toutb((s->state >> 24) & 0xff, iobase + 3);\n\t}\n\n\tdata[1] = s->state;\n\n\treturn insn->n;\n}\n\nstatic int pci_dio_insn_bits_do_w(struct comedi_device *dev,\n\t\t\t\t  struct comedi_subdevice *s,\n\t\t\t\t  struct comedi_insn *insn,\n\t\t\t\t  unsigned int *data)\n{\n\tunsigned long reg = (unsigned long)s->private;\n\tunsigned long iobase = dev->iobase + reg;\n\n\tif (comedi_dio_update_state(s, data)) {\n\t\toutw(s->state & 0xffff, iobase);\n\t\tif (s->n_chan > 16)\n\t\t\toutw((s->state >> 16) & 0xffff, iobase + 2);\n\t}\n\n\tdata[1] = s->state;\n\n\treturn insn->n;\n}\n\nstatic int pci_dio_reset(struct comedi_device *dev, unsigned long cardtype)\n{\n\tstruct pci_dio_dev_private_data *dev_private = dev->private;\n\t \n\tif (cardtype == TYPE_PCI1752 || cardtype == TYPE_PCI1756)\n\t\toutw(0, dev->iobase + PCI1752_CFC_REG);\n\n\t \n\tswitch (cardtype) {\n\tcase TYPE_PCI1730:\n\tcase TYPE_PCI1733:\n\tcase TYPE_PCI1736:\n\t\tdev_private->int_ctrl = 0x00;\n\t\toutb(dev_private->int_ctrl, dev->iobase + PCI173X_INT_EN_REG);\n\t\t \n\t\toutb(0x0f, dev->iobase + PCI173X_INT_CLR_REG);\n\t\t \n\t\tdev_private->int_rf = 0x00;\n\t\toutb(dev_private->int_rf, dev->iobase + PCI173X_INT_RF_REG);\n\t\tbreak;\n\tcase TYPE_PCI1739:\n\tcase TYPE_PCI1750:\n\tcase TYPE_PCI1751:\n\t\toutb(0x88, dev->iobase + PCI1750_INT_REG);\n\t\tbreak;\n\tcase TYPE_PCI1753:\n\tcase TYPE_PCI1753E:\n\t\toutb(0x88, dev->iobase + PCI1753_INT_REG(0));\n\t\toutb(0x80, dev->iobase + PCI1753_INT_REG(1));\n\t\toutb(0x80, dev->iobase + PCI1753_INT_REG(2));\n\t\toutb(0x80, dev->iobase + PCI1753_INT_REG(3));\n\t\tif (cardtype == TYPE_PCI1753E) {\n\t\t\toutb(0x88, dev->iobase + PCI1753E_INT_REG(0));\n\t\t\toutb(0x80, dev->iobase + PCI1753E_INT_REG(1));\n\t\t\toutb(0x80, dev->iobase + PCI1753E_INT_REG(2));\n\t\t\toutb(0x80, dev->iobase + PCI1753E_INT_REG(3));\n\t\t}\n\t\tbreak;\n\tcase TYPE_PCI1754:\n\tcase TYPE_PCI1756:\n\t\toutw(0x08, dev->iobase + PCI1754_INT_REG(0));\n\t\toutw(0x08, dev->iobase + PCI1754_INT_REG(1));\n\t\tif (cardtype == TYPE_PCI1754) {\n\t\t\toutw(0x08, dev->iobase + PCI1754_INT_REG(2));\n\t\t\toutw(0x08, dev->iobase + PCI1754_INT_REG(3));\n\t\t}\n\t\tbreak;\n\tcase TYPE_PCI1761:\n\t\t \n\t\toutb(0, dev->iobase + PCI1761_INT_EN_REG);\n\t\t \n\t\toutb(0xff, dev->iobase + PCI1761_INT_CLR_REG);\n\t\t \n\t\toutb(0, dev->iobase + PCI1761_INT_RF_REG);\n\t\tbreak;\n\tcase TYPE_PCI1762:\n\t\toutw(0x0101, dev->iobase + PCI1762_INT_REG);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int pci_dio_auto_attach(struct comedi_device *dev,\n\t\t\t       unsigned long context)\n{\n\tstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\n\tconst struct dio_boardtype *board = NULL;\n\tstruct comedi_subdevice *s;\n\tstruct pci_dio_dev_private_data *dev_private;\n\tint ret, subdev, i, j;\n\n\tif (context < ARRAY_SIZE(boardtypes))\n\t\tboard = &boardtypes[context];\n\tif (!board)\n\t\treturn -ENODEV;\n\tdev->board_ptr = board;\n\tdev->board_name = board->name;\n\n\tdev_private = comedi_alloc_devpriv(dev, sizeof(*dev_private));\n\tif (!dev_private)\n\t\treturn -ENOMEM;\n\n\tret = comedi_pci_enable(dev);\n\tif (ret)\n\t\treturn ret;\n\tif (context == TYPE_PCI1736)\n\t\tdev->iobase = pci_resource_start(pcidev, 0);\n\telse\n\t\tdev->iobase = pci_resource_start(pcidev, 2);\n\n\tdev_private->boardtype = context;\n\tpci_dio_reset(dev, context);\n\n\t \n\tif (board->sdirq[0].int_en && pcidev->irq) {\n\t\tret = request_irq(pcidev->irq, pci_dio_interrupt, IRQF_SHARED,\n\t\t\t\t  dev->board_name, dev);\n\t\tif (ret == 0)\n\t\t\tdev->irq = pcidev->irq;\n\t}\n\n\tret = comedi_alloc_subdevices(dev, board->nsubdevs);\n\tif (ret)\n\t\treturn ret;\n\n\tsubdev = 0;\n\tfor (i = 0; i < PCI_DIO_MAX_DI_SUBDEVS; i++) {\n\t\tconst struct diosubd_data *d = &board->sdi[i];\n\n\t\tif (d->chans) {\n\t\t\ts = &dev->subdevices[subdev++];\n\t\t\ts->type\t\t= COMEDI_SUBD_DI;\n\t\t\ts->subdev_flags\t= SDF_READABLE;\n\t\t\ts->n_chan\t= d->chans;\n\t\t\ts->maxdata\t= 1;\n\t\t\ts->range_table\t= &range_digital;\n\t\t\ts->insn_bits\t= board->is_16bit\n\t\t\t\t\t\t? pci_dio_insn_bits_di_w\n\t\t\t\t\t\t: pci_dio_insn_bits_di_b;\n\t\t\ts->private\t= (void *)d->addr;\n\t\t}\n\t}\n\n\tfor (i = 0; i < PCI_DIO_MAX_DO_SUBDEVS; i++) {\n\t\tconst struct diosubd_data *d = &board->sdo[i];\n\n\t\tif (d->chans) {\n\t\t\ts = &dev->subdevices[subdev++];\n\t\t\ts->type\t\t= COMEDI_SUBD_DO;\n\t\t\ts->subdev_flags\t= SDF_WRITABLE;\n\t\t\ts->n_chan\t= d->chans;\n\t\t\ts->maxdata\t= 1;\n\t\t\ts->range_table\t= &range_digital;\n\t\t\ts->insn_bits\t= board->is_16bit\n\t\t\t\t\t\t? pci_dio_insn_bits_do_w\n\t\t\t\t\t\t: pci_dio_insn_bits_do_b;\n\t\t\ts->private\t= (void *)d->addr;\n\n\t\t\t \n\t\t\tif (board->is_16bit) {\n\t\t\t\toutw(0, dev->iobase + d->addr);\n\t\t\t\tif (s->n_chan > 16)\n\t\t\t\t\toutw(0, dev->iobase + d->addr + 2);\n\t\t\t} else {\n\t\t\t\toutb(0, dev->iobase + d->addr);\n\t\t\t\tif (s->n_chan > 8)\n\t\t\t\t\toutb(0, dev->iobase + d->addr + 1);\n\t\t\t\tif (s->n_chan > 16)\n\t\t\t\t\toutb(0, dev->iobase + d->addr + 2);\n\t\t\t\tif (s->n_chan > 24)\n\t\t\t\t\toutb(0, dev->iobase + d->addr + 3);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < PCI_DIO_MAX_DIO_SUBDEVG; i++) {\n\t\tconst struct diosubd_data *d = &board->sdio[i];\n\n\t\tfor (j = 0; j < d->chans; j++) {\n\t\t\ts = &dev->subdevices[subdev++];\n\t\t\tret = subdev_8255_init(dev, s, NULL,\n\t\t\t\t\t       d->addr + j * I8255_SIZE);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (board->id_reg) {\n\t\ts = &dev->subdevices[subdev++];\n\t\ts->type\t\t= COMEDI_SUBD_DI;\n\t\ts->subdev_flags\t= SDF_READABLE | SDF_INTERNAL;\n\t\ts->n_chan\t= 4;\n\t\ts->maxdata\t= 1;\n\t\ts->range_table\t= &range_digital;\n\t\ts->insn_bits\t= board->is_16bit ? pci_dio_insn_bits_di_w\n\t\t\t\t\t\t  : pci_dio_insn_bits_di_b;\n\t\ts->private\t= (void *)board->id_reg;\n\t}\n\n\tif (board->timer_regbase) {\n\t\ts = &dev->subdevices[subdev++];\n\n\t\tdev->pacer = comedi_8254_init(dev->iobase +\n\t\t\t\t\t      board->timer_regbase,\n\t\t\t\t\t      0, I8254_IO8, 0);\n\t\tif (!dev->pacer)\n\t\t\treturn -ENOMEM;\n\n\t\tcomedi_8254_subdevice_init(s, dev->pacer);\n\t}\n\n\tdev_private->irq_subd = subdev;  \n\tfor (i = 0; i < PCI_DIO_MAX_IRQ_SUBDEVS; ++i) {\n\t\tstruct pci_dio_sd_private_data *sd_priv = NULL;\n\t\tconst struct dio_irq_subd_data *d = &board->sdirq[i];\n\n\t\tif (d->int_en) {\n\t\t\ts = &dev->subdevices[subdev++];\n\t\t\ts->type\t\t= COMEDI_SUBD_DI;\n\t\t\ts->subdev_flags\t= SDF_READABLE;\n\t\t\ts->n_chan\t= 1;\n\t\t\ts->maxdata\t= 1;\n\t\t\ts->range_table\t= &range_digital;\n\t\t\ts->insn_bits\t= pci_dio_insn_bits_dirq_b;\n\t\t\tsd_priv = comedi_alloc_spriv(s, sizeof(*sd_priv));\n\t\t\tif (!sd_priv)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tspin_lock_init(&sd_priv->subd_slock);\n\t\t\tsd_priv->port_offset = d->addr;\n\t\t\tsd_priv->cmd_running = 0;\n\n\t\t\tif (dev->irq) {\n\t\t\t\tdev->read_subdev = s;\n\t\t\t\ts->type\t\t= COMEDI_SUBD_DI;\n\t\t\t\ts->subdev_flags\t= SDF_READABLE | SDF_CMD_READ;\n\t\t\t\ts->len_chanlist\t= 1;\n\t\t\t\ts->do_cmdtest\t= pci_dio_asy_cmdtest;\n\t\t\t\ts->do_cmd\t= pci_dio_asy_cmd;\n\t\t\t\ts->cancel\t= pci_dio_asy_cancel;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void pci_dio_detach(struct comedi_device *dev)\n{\n\tstruct pci_dio_dev_private_data *dev_private = dev->private;\n\tint boardtype = dev_private->boardtype;\n\n\tif (dev->iobase)\n\t\tpci_dio_reset(dev, boardtype);\n\tcomedi_pci_detach(dev);\n}\n\nstatic struct comedi_driver adv_pci_dio_driver = {\n\t.driver_name\t= \"adv_pci_dio\",\n\t.module\t\t= THIS_MODULE,\n\t.auto_attach\t= pci_dio_auto_attach,\n\t.detach\t\t= pci_dio_detach,\n};\n\nstatic unsigned long pci_dio_override_cardtype(struct pci_dev *pcidev,\n\t\t\t\t\t       unsigned long cardtype)\n{\n\t \n\tif (cardtype != TYPE_PCI1753)\n\t\treturn cardtype;\n\tif (pci_enable_device(pcidev) < 0)\n\t\treturn cardtype;\n\tif (pci_request_region(pcidev, 2, \"adv_pci_dio\") == 0) {\n\t\t \n\t\tunsigned long reg = pci_resource_start(pcidev, 2) + 53;\n\n\t\toutb(0x05, reg);\n\t\tif ((inb(reg) & 0x07) == 0x02) {\n\t\t\toutb(0x02, reg);\n\t\t\tif ((inb(reg) & 0x07) == 0x05)\n\t\t\t\tcardtype = TYPE_PCI1753E;\n\t\t}\n\t\tpci_release_region(pcidev, 2);\n\t}\n\tpci_disable_device(pcidev);\n\treturn cardtype;\n}\n\nstatic int adv_pci_dio_pci_probe(struct pci_dev *dev,\n\t\t\t\t const struct pci_device_id *id)\n{\n\tunsigned long cardtype;\n\n\tcardtype = pci_dio_override_cardtype(dev, id->driver_data);\n\treturn comedi_pci_auto_config(dev, &adv_pci_dio_driver, cardtype);\n}\n\nstatic const struct pci_device_id adv_pci_dio_pci_table[] = {\n\t{ PCI_VDEVICE(ADVANTECH, 0x1730), TYPE_PCI1730 },\n\t{ PCI_VDEVICE(ADVANTECH, 0x1733), TYPE_PCI1733 },\n\t{ PCI_VDEVICE(ADVANTECH, 0x1734), TYPE_PCI1734 },\n\t{ PCI_VDEVICE(ADVANTECH, 0x1735), TYPE_PCI1735 },\n\t{ PCI_VDEVICE(ADVANTECH, 0x1736), TYPE_PCI1736 },\n\t{ PCI_VDEVICE(ADVANTECH, 0x1739), TYPE_PCI1739 },\n\t{ PCI_VDEVICE(ADVANTECH, 0x1750), TYPE_PCI1750 },\n\t{ PCI_VDEVICE(ADVANTECH, 0x1751), TYPE_PCI1751 },\n\t{ PCI_VDEVICE(ADVANTECH, 0x1752), TYPE_PCI1752 },\n\t{ PCI_VDEVICE(ADVANTECH, 0x1753), TYPE_PCI1753 },\n\t{ PCI_VDEVICE(ADVANTECH, 0x1754), TYPE_PCI1754 },\n\t{ PCI_VDEVICE(ADVANTECH, 0x1756), TYPE_PCI1756 },\n\t{ PCI_VDEVICE(ADVANTECH, 0x1761), TYPE_PCI1761 },\n\t{ PCI_VDEVICE(ADVANTECH, 0x1762), TYPE_PCI1762 },\n\t{ 0 }\n};\nMODULE_DEVICE_TABLE(pci, adv_pci_dio_pci_table);\n\nstatic struct pci_driver adv_pci_dio_pci_driver = {\n\t.name\t\t= \"adv_pci_dio\",\n\t.id_table\t= adv_pci_dio_pci_table,\n\t.probe\t\t= adv_pci_dio_pci_probe,\n\t.remove\t\t= comedi_pci_auto_unconfig,\n};\nmodule_comedi_pci_driver(adv_pci_dio_driver, adv_pci_dio_pci_driver);\n\nMODULE_AUTHOR(\"Comedi https://www.comedi.org\");\nMODULE_DESCRIPTION(\"Comedi driver for Advantech Digital I/O Cards\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}