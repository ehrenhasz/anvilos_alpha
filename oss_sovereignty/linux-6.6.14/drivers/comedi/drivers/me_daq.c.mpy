{
  "module_name": "me_daq.c",
  "hash_id": "03fc6e328580abb7fefd2e0b233df78d00fca244b6ea3a00c8436b372f3d119b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/me_daq.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n#include <linux/comedi/comedi_pci.h>\n\n#include \"plx9052.h\"\n\n#define ME2600_FIRMWARE\t\t\"me2600_firmware.bin\"\n\n#define XILINX_DOWNLOAD_RESET\t0x42\t \n\n \n#define ME_CTRL1_REG\t\t\t0x00\t \n#define   ME_CTRL1_INT_ENA\t\tBIT(15)\n#define   ME_CTRL1_COUNTER_B_IRQ\tBIT(12)\n#define   ME_CTRL1_COUNTER_A_IRQ\tBIT(11)\n#define   ME_CTRL1_CHANLIST_READY_IRQ\tBIT(10)\n#define   ME_CTRL1_EXT_IRQ\t\tBIT(9)\n#define   ME_CTRL1_ADFIFO_HALFFULL_IRQ\tBIT(8)\n#define   ME_CTRL1_SCAN_COUNT_ENA\tBIT(5)\n#define   ME_CTRL1_SIMULTANEOUS_ENA\tBIT(4)\n#define   ME_CTRL1_TRIGGER_FALLING_EDGE\tBIT(3)\n#define   ME_CTRL1_CONTINUOUS_MODE\tBIT(2)\n#define   ME_CTRL1_ADC_MODE(x)\t\t(((x) & 0x3) << 0)\n#define   ME_CTRL1_ADC_MODE_DISABLE\tME_CTRL1_ADC_MODE(0)\n#define   ME_CTRL1_ADC_MODE_SOFT_TRIG\tME_CTRL1_ADC_MODE(1)\n#define   ME_CTRL1_ADC_MODE_SCAN_TRIG\tME_CTRL1_ADC_MODE(2)\n#define   ME_CTRL1_ADC_MODE_EXT_TRIG\tME_CTRL1_ADC_MODE(3)\n#define   ME_CTRL1_ADC_MODE_MASK\tME_CTRL1_ADC_MODE(3)\n#define ME_CTRL2_REG\t\t\t0x02\t \n#define   ME_CTRL2_ADFIFO_ENA\t\tBIT(10)\n#define   ME_CTRL2_CHANLIST_ENA\t\tBIT(9)\n#define   ME_CTRL2_PORT_B_ENA\t\tBIT(7)\n#define   ME_CTRL2_PORT_A_ENA\t\tBIT(6)\n#define   ME_CTRL2_COUNTER_B_ENA\tBIT(4)\n#define   ME_CTRL2_COUNTER_A_ENA\tBIT(3)\n#define   ME_CTRL2_DAC_ENA\t\tBIT(1)\n#define   ME_CTRL2_BUFFERED_DAC\t\tBIT(0)\n#define ME_STATUS_REG\t\t\t0x04\t \n#define   ME_STATUS_COUNTER_B_IRQ\tBIT(12)\n#define   ME_STATUS_COUNTER_A_IRQ\tBIT(11)\n#define   ME_STATUS_CHANLIST_READY_IRQ\tBIT(10)\n#define   ME_STATUS_EXT_IRQ\t\tBIT(9)\n#define   ME_STATUS_ADFIFO_HALFFULL_IRQ\tBIT(8)\n#define   ME_STATUS_ADFIFO_FULL\t\tBIT(4)\n#define   ME_STATUS_ADFIFO_HALFFULL\tBIT(3)\n#define   ME_STATUS_ADFIFO_EMPTY\tBIT(2)\n#define   ME_STATUS_CHANLIST_FULL\tBIT(1)\n#define   ME_STATUS_FST_ACTIVE\t\tBIT(0)\n#define ME_DIO_PORT_A_REG\t\t0x06\t \n#define ME_DIO_PORT_B_REG\t\t0x08\t \n#define ME_TIMER_DATA_REG(x)\t\t(0x0a + ((x) * 2))\t \n#define ME_AI_FIFO_REG\t\t\t0x10\t \n#define   ME_AI_FIFO_CHANLIST_DIFF\tBIT(7)\n#define   ME_AI_FIFO_CHANLIST_UNIPOLAR\tBIT(6)\n#define   ME_AI_FIFO_CHANLIST_GAIN(x)\t(((x) & 0x3) << 4)\n#define   ME_AI_FIFO_CHANLIST_CHAN(x)\t(((x) & 0xf) << 0)\n#define ME_DAC_CTRL_REG\t\t\t0x12\t \n#define   ME_DAC_CTRL_BIPOLAR(x)\tBIT(7 - ((x) & 0x3))\n#define   ME_DAC_CTRL_GAIN(x)\t\tBIT(11 - ((x) & 0x3))\n#define   ME_DAC_CTRL_MASK(x)\t\t(ME_DAC_CTRL_BIPOLAR(x) |\t\\\n\t\t\t\t\t ME_DAC_CTRL_GAIN(x))\n#define ME_AO_DATA_REG(x)\t\t(0x14 + ((x) * 2))\t \n#define ME_COUNTER_ENDDATA_REG(x)\t(0x1c + ((x) * 2))\t \n#define ME_COUNTER_STARTDATA_REG(x)\t(0x20 + ((x) * 2))\t \n#define ME_COUNTER_VALUE_REG(x)\t\t(0x20 + ((x) * 2))\t \n\nstatic const struct comedi_lrange me_ai_range = {\n\t8, {\n\t\tBIP_RANGE(10),\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(2.5),\n\t\tBIP_RANGE(1.25),\n\t\tUNI_RANGE(10),\n\t\tUNI_RANGE(5),\n\t\tUNI_RANGE(2.5),\n\t\tUNI_RANGE(1.25)\n\t}\n};\n\nstatic const struct comedi_lrange me_ao_range = {\n\t3, {\n\t\tBIP_RANGE(10),\n\t\tBIP_RANGE(5),\n\t\tUNI_RANGE(10)\n\t}\n};\n\nenum me_boardid {\n\tBOARD_ME2600,\n\tBOARD_ME2000,\n};\n\nstruct me_board {\n\tconst char *name;\n\tint needs_firmware;\n\tint has_ao;\n};\n\nstatic const struct me_board me_boards[] = {\n\t[BOARD_ME2600] = {\n\t\t.name\t\t= \"me-2600i\",\n\t\t.needs_firmware\t= 1,\n\t\t.has_ao\t\t= 1,\n\t},\n\t[BOARD_ME2000] = {\n\t\t.name\t\t= \"me-2000i\",\n\t},\n};\n\nstruct me_private_data {\n\tvoid __iomem *plx_regbase;\t \n\n\tunsigned short ctrl1;\t\t \n\tunsigned short ctrl2;\t\t \n\tunsigned short dac_ctrl;\t \n};\n\nstatic inline void sleep(unsigned int sec)\n{\n\tschedule_timeout_interruptible(sec * HZ);\n}\n\nstatic int me_dio_insn_config(struct comedi_device *dev,\n\t\t\t      struct comedi_subdevice *s,\n\t\t\t      struct comedi_insn *insn,\n\t\t\t      unsigned int *data)\n{\n\tstruct me_private_data *devpriv = dev->private;\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int mask;\n\tint ret;\n\n\tif (chan < 16)\n\t\tmask = 0x0000ffff;\n\telse\n\t\tmask = 0xffff0000;\n\n\tret = comedi_dio_insn_config(dev, s, insn, data, mask);\n\tif (ret)\n\t\treturn ret;\n\n\tif (s->io_bits & 0x0000ffff)\n\t\tdevpriv->ctrl2 |= ME_CTRL2_PORT_A_ENA;\n\telse\n\t\tdevpriv->ctrl2 &= ~ME_CTRL2_PORT_A_ENA;\n\tif (s->io_bits & 0xffff0000)\n\t\tdevpriv->ctrl2 |= ME_CTRL2_PORT_B_ENA;\n\telse\n\t\tdevpriv->ctrl2 &= ~ME_CTRL2_PORT_B_ENA;\n\n\twritew(devpriv->ctrl2, dev->mmio + ME_CTRL2_REG);\n\n\treturn insn->n;\n}\n\nstatic int me_dio_insn_bits(struct comedi_device *dev,\n\t\t\t    struct comedi_subdevice *s,\n\t\t\t    struct comedi_insn *insn,\n\t\t\t    unsigned int *data)\n{\n\tvoid __iomem *mmio_porta = dev->mmio + ME_DIO_PORT_A_REG;\n\tvoid __iomem *mmio_portb = dev->mmio + ME_DIO_PORT_B_REG;\n\tunsigned int mask;\n\tunsigned int val;\n\n\tmask = comedi_dio_update_state(s, data);\n\tif (mask) {\n\t\tif (mask & 0x0000ffff)\n\t\t\twritew((s->state & 0xffff), mmio_porta);\n\t\tif (mask & 0xffff0000)\n\t\t\twritew(((s->state >> 16) & 0xffff), mmio_portb);\n\t}\n\n\tif (s->io_bits & 0x0000ffff)\n\t\tval = s->state & 0xffff;\n\telse\n\t\tval = readw(mmio_porta);\n\n\tif (s->io_bits & 0xffff0000)\n\t\tval |= (s->state & 0xffff0000);\n\telse\n\t\tval |= (readw(mmio_portb) << 16);\n\n\tdata[1] = val;\n\n\treturn insn->n;\n}\n\nstatic int me_ai_eoc(struct comedi_device *dev,\n\t\t     struct comedi_subdevice *s,\n\t\t     struct comedi_insn *insn,\n\t\t     unsigned long context)\n{\n\tunsigned int status;\n\n\tstatus = readw(dev->mmio + ME_STATUS_REG);\n\tif ((status & ME_STATUS_ADFIFO_EMPTY) == 0)\n\t\treturn 0;\n\treturn -EBUSY;\n}\n\nstatic int me_ai_insn_read(struct comedi_device *dev,\n\t\t\t   struct comedi_subdevice *s,\n\t\t\t   struct comedi_insn *insn,\n\t\t\t   unsigned int *data)\n{\n\tstruct me_private_data *devpriv = dev->private;\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int range = CR_RANGE(insn->chanspec);\n\tunsigned int aref = CR_AREF(insn->chanspec);\n\tunsigned int val;\n\tint ret = 0;\n\tint i;\n\n\t \n\tif (aref & AREF_DIFF) {\n\t\tif (chan > 7 || comedi_range_is_unipolar(s, range))\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\tdevpriv->ctrl2 &= ~(ME_CTRL2_ADFIFO_ENA | ME_CTRL2_CHANLIST_ENA);\n\twritew(devpriv->ctrl2, dev->mmio + ME_CTRL2_REG);\n\n\twritew(0x00, dev->mmio + ME_STATUS_REG);\t \n\n\t \n\tdevpriv->ctrl2 |= (ME_CTRL2_ADFIFO_ENA | ME_CTRL2_CHANLIST_ENA);\n\twritew(devpriv->ctrl2, dev->mmio + ME_CTRL2_REG);\n\n\t \n\tval = ME_AI_FIFO_CHANLIST_CHAN(chan) | ME_AI_FIFO_CHANLIST_GAIN(range);\n\tif (comedi_range_is_unipolar(s, range))\n\t\tval |= ME_AI_FIFO_CHANLIST_UNIPOLAR;\n\tif (aref & AREF_DIFF)\n\t\tval |= ME_AI_FIFO_CHANLIST_DIFF;\n\twritew(val, dev->mmio + ME_AI_FIFO_REG);\n\n\t \n\tdevpriv->ctrl1 |= ME_CTRL1_ADC_MODE_SOFT_TRIG;\n\twritew(devpriv->ctrl1, dev->mmio + ME_CTRL1_REG);\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\t \n\t\treadw(dev->mmio + ME_CTRL1_REG);\n\n\t\t \n\t\tret = comedi_timeout(dev, s, insn, me_ai_eoc, 0);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\t \n\t\tval = readw(dev->mmio + ME_AI_FIFO_REG) & s->maxdata;\n\n\t\t \n\t\tdata[i] = comedi_offset_munge(s, val);\n\t}\n\n\t \n\tdevpriv->ctrl1 &= ~ME_CTRL1_ADC_MODE_MASK;\n\twritew(devpriv->ctrl1, dev->mmio + ME_CTRL1_REG);\n\n\treturn ret ? ret : insn->n;\n}\n\nstatic int me_ao_insn_write(struct comedi_device *dev,\n\t\t\t    struct comedi_subdevice *s,\n\t\t\t    struct comedi_insn *insn,\n\t\t\t    unsigned int *data)\n{\n\tstruct me_private_data *devpriv = dev->private;\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int range = CR_RANGE(insn->chanspec);\n\tunsigned int val = s->readback[chan];\n\tint i;\n\n\t \n\tdevpriv->ctrl2 |= ME_CTRL2_DAC_ENA;\n\twritew(devpriv->ctrl2, dev->mmio + ME_CTRL2_REG);\n\n\t \n\tdevpriv->ctrl2 |= ME_CTRL2_BUFFERED_DAC;\n\twritew(devpriv->ctrl2, dev->mmio + ME_CTRL2_REG);\n\n\t \n\tdevpriv->dac_ctrl &= ~ME_DAC_CTRL_MASK(chan);\n\tif (range == 0)\n\t\tdevpriv->dac_ctrl |= ME_DAC_CTRL_GAIN(chan);\n\tif (comedi_range_is_bipolar(s, range))\n\t\tdevpriv->dac_ctrl |= ME_DAC_CTRL_BIPOLAR(chan);\n\twritew(devpriv->dac_ctrl, dev->mmio + ME_DAC_CTRL_REG);\n\n\t \n\treadw(dev->mmio + ME_DAC_CTRL_REG);\n\n\t \n\tfor (i = 0; i < insn->n; i++) {\n\t\tval = data[i];\n\n\t\twritew(val, dev->mmio + ME_AO_DATA_REG(chan));\n\t}\n\ts->readback[chan] = val;\n\n\t \n\treadw(dev->mmio + ME_CTRL2_REG);\n\n\treturn insn->n;\n}\n\nstatic int me2600_xilinx_download(struct comedi_device *dev,\n\t\t\t\t  const u8 *data, size_t size,\n\t\t\t\t  unsigned long context)\n{\n\tstruct me_private_data *devpriv = dev->private;\n\tunsigned int value;\n\tunsigned int file_length;\n\tunsigned int i;\n\n\t \n\twritel(0x00, devpriv->plx_regbase + PLX9052_INTCSR);\n\n\t \n\tvalue = readw(dev->mmio + XILINX_DOWNLOAD_RESET);\n\n\t \n\tsleep(1);\n\n\t \n\twriteb(0x00, dev->mmio + 0x0);\n\tsleep(1);\n\n\t \n\tif (size < 16)\n\t\treturn -EINVAL;\n\n\tfile_length = (((unsigned int)data[0] & 0xff) << 24) +\n\t    (((unsigned int)data[1] & 0xff) << 16) +\n\t    (((unsigned int)data[2] & 0xff) << 8) +\n\t    ((unsigned int)data[3] & 0xff);\n\n\t \n\tfor (i = 0; i < file_length; i++)\n\t\twriteb((data[16 + i] & 0xff), dev->mmio + 0x0);\n\n\t \n\tfor (i = 0; i < 5; i++)\n\t\twriteb(0x00, dev->mmio + 0x0);\n\n\t \n\tvalue = readl(devpriv->plx_regbase + PLX9052_INTCSR);\n\tif (value & PLX9052_INTCSR_LI2STAT) {\n\t\t \n\t\twritel(0x00, devpriv->plx_regbase + PLX9052_INTCSR);\n\t\tdev_err(dev->class_dev, \"Xilinx download failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tsleep(1);\n\n\t \n\twritel(PLX9052_INTCSR_LI1ENAB |\n\t       PLX9052_INTCSR_LI1POL |\n\t       PLX9052_INTCSR_PCIENAB,\n\t       devpriv->plx_regbase + PLX9052_INTCSR);\n\n\treturn 0;\n}\n\nstatic int me_reset(struct comedi_device *dev)\n{\n\tstruct me_private_data *devpriv = dev->private;\n\n\t \n\twritew(0x00, dev->mmio + ME_CTRL1_REG);\n\twritew(0x00, dev->mmio + ME_CTRL2_REG);\n\twritew(0x00, dev->mmio + ME_STATUS_REG);\t \n\twritew(0x00, dev->mmio + ME_DAC_CTRL_REG);\n\n\t \n\tdevpriv->dac_ctrl = 0;\n\tdevpriv->ctrl1 = 0;\n\tdevpriv->ctrl2 = 0;\n\n\treturn 0;\n}\n\nstatic int me_auto_attach(struct comedi_device *dev,\n\t\t\t  unsigned long context)\n{\n\tstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\n\tconst struct me_board *board = NULL;\n\tstruct me_private_data *devpriv;\n\tstruct comedi_subdevice *s;\n\tint ret;\n\n\tif (context < ARRAY_SIZE(me_boards))\n\t\tboard = &me_boards[context];\n\tif (!board)\n\t\treturn -ENODEV;\n\tdev->board_ptr = board;\n\tdev->board_name = board->name;\n\n\tdevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\n\tif (!devpriv)\n\t\treturn -ENOMEM;\n\n\tret = comedi_pci_enable(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tdevpriv->plx_regbase = pci_ioremap_bar(pcidev, 0);\n\tif (!devpriv->plx_regbase)\n\t\treturn -ENOMEM;\n\n\tdev->mmio = pci_ioremap_bar(pcidev, 2);\n\tif (!dev->mmio)\n\t\treturn -ENOMEM;\n\n\t \n\tif (board->needs_firmware) {\n\t\tret = comedi_load_firmware(dev, &comedi_to_pci_dev(dev)->dev,\n\t\t\t\t\t   ME2600_FIRMWARE,\n\t\t\t\t\t   me2600_xilinx_download, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\tme_reset(dev);\n\n\tret = comedi_alloc_subdevices(dev, 3);\n\tif (ret)\n\t\treturn ret;\n\n\ts = &dev->subdevices[0];\n\ts->type\t\t= COMEDI_SUBD_AI;\n\ts->subdev_flags\t= SDF_READABLE | SDF_COMMON | SDF_DIFF;\n\ts->n_chan\t= 16;\n\ts->maxdata\t= 0x0fff;\n\ts->len_chanlist\t= 16;\n\ts->range_table\t= &me_ai_range;\n\ts->insn_read\t= me_ai_insn_read;\n\n\ts = &dev->subdevices[1];\n\tif (board->has_ao) {\n\t\ts->type\t\t= COMEDI_SUBD_AO;\n\t\ts->subdev_flags\t= SDF_WRITABLE | SDF_COMMON;\n\t\ts->n_chan\t= 4;\n\t\ts->maxdata\t= 0x0fff;\n\t\ts->len_chanlist\t= 4;\n\t\ts->range_table\t= &me_ao_range;\n\t\ts->insn_write\t= me_ao_insn_write;\n\n\t\tret = comedi_alloc_subdev_readback(s);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\ts->type = COMEDI_SUBD_UNUSED;\n\t}\n\n\ts = &dev->subdevices[2];\n\ts->type\t\t= COMEDI_SUBD_DIO;\n\ts->subdev_flags\t= SDF_READABLE | SDF_WRITABLE;\n\ts->n_chan\t= 32;\n\ts->maxdata\t= 1;\n\ts->len_chanlist\t= 32;\n\ts->range_table\t= &range_digital;\n\ts->insn_bits\t= me_dio_insn_bits;\n\ts->insn_config\t= me_dio_insn_config;\n\n\treturn 0;\n}\n\nstatic void me_detach(struct comedi_device *dev)\n{\n\tstruct me_private_data *devpriv = dev->private;\n\n\tif (devpriv) {\n\t\tif (dev->mmio)\n\t\t\tme_reset(dev);\n\t\tif (devpriv->plx_regbase)\n\t\t\tiounmap(devpriv->plx_regbase);\n\t}\n\tcomedi_pci_detach(dev);\n}\n\nstatic struct comedi_driver me_daq_driver = {\n\t.driver_name\t= \"me_daq\",\n\t.module\t\t= THIS_MODULE,\n\t.auto_attach\t= me_auto_attach,\n\t.detach\t\t= me_detach,\n};\n\nstatic int me_daq_pci_probe(struct pci_dev *dev,\n\t\t\t    const struct pci_device_id *id)\n{\n\treturn comedi_pci_auto_config(dev, &me_daq_driver, id->driver_data);\n}\n\nstatic const struct pci_device_id me_daq_pci_table[] = {\n\t{ PCI_VDEVICE(MEILHAUS, 0x2600), BOARD_ME2600 },\n\t{ PCI_VDEVICE(MEILHAUS, 0x2000), BOARD_ME2000 },\n\t{ 0 }\n};\nMODULE_DEVICE_TABLE(pci, me_daq_pci_table);\n\nstatic struct pci_driver me_daq_pci_driver = {\n\t.name\t\t= \"me_daq\",\n\t.id_table\t= me_daq_pci_table,\n\t.probe\t\t= me_daq_pci_probe,\n\t.remove\t\t= comedi_pci_auto_unconfig,\n};\nmodule_comedi_pci_driver(me_daq_driver, me_daq_pci_driver);\n\nMODULE_AUTHOR(\"Comedi https://www.comedi.org\");\nMODULE_DESCRIPTION(\"Comedi low-level driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(ME2600_FIRMWARE);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}