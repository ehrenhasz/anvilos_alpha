{
  "module_name": "cb_das16_cs.c",
  "hash_id": "38996304957cd004c2182ae527a41ca93258dfdaee275f8d12fcbb1ab6f382da",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/cb_das16_cs.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/comedi/comedi_pcmcia.h>\n#include <linux/comedi/comedi_8254.h>\n\n \n#define DAS16CS_AI_DATA_REG\t\t0x00\n#define DAS16CS_AI_MUX_REG\t\t0x02\n#define DAS16CS_AI_MUX_HI_CHAN(x)\t(((x) & 0xf) << 4)\n#define DAS16CS_AI_MUX_LO_CHAN(x)\t(((x) & 0xf) << 0)\n#define DAS16CS_AI_MUX_SINGLE_CHAN(x)\t(DAS16CS_AI_MUX_HI_CHAN(x) |\t\\\n\t\t\t\t\t DAS16CS_AI_MUX_LO_CHAN(x))\n#define DAS16CS_MISC1_REG\t\t0x04\n#define DAS16CS_MISC1_INTE\t\tBIT(15)\t \n#define DAS16CS_MISC1_INT_SRC(x)\t(((x) & 0x7) << 12)  \n#define DAS16CS_MISC1_INT_SRC_NONE\tDAS16CS_MISC1_INT_SRC(0)\n#define DAS16CS_MISC1_INT_SRC_PACER\tDAS16CS_MISC1_INT_SRC(1)\n#define DAS16CS_MISC1_INT_SRC_EXT\tDAS16CS_MISC1_INT_SRC(2)\n#define DAS16CS_MISC1_INT_SRC_FNE\tDAS16CS_MISC1_INT_SRC(3)\n#define DAS16CS_MISC1_INT_SRC_FHF\tDAS16CS_MISC1_INT_SRC(4)\n#define DAS16CS_MISC1_INT_SRC_EOS\tDAS16CS_MISC1_INT_SRC(5)\n#define DAS16CS_MISC1_INT_SRC_MASK\tDAS16CS_MISC1_INT_SRC(7)\n#define DAS16CS_MISC1_OVR\t\tBIT(10)\t \n#define DAS16CS_MISC1_AI_CONV(x)\t(((x) & 0x3) << 8)  \n#define DAS16CS_MISC1_AI_CONV_SW\tDAS16CS_MISC1_AI_CONV(0)\n#define DAS16CS_MISC1_AI_CONV_EXT_NEG\tDAS16CS_MISC1_AI_CONV(1)\n#define DAS16CS_MISC1_AI_CONV_EXT_POS\tDAS16CS_MISC1_AI_CONV(2)\n#define DAS16CS_MISC1_AI_CONV_PACER\tDAS16CS_MISC1_AI_CONV(3)\n#define DAS16CS_MISC1_AI_CONV_MASK\tDAS16CS_MISC1_AI_CONV(3)\n#define DAS16CS_MISC1_EOC\t\tBIT(7)\t \n#define DAS16CS_MISC1_SEDIFF\t\tBIT(5)\t \n#define DAS16CS_MISC1_INTB\t\tBIT(4)\t \n#define DAS16CS_MISC1_MA_MASK\t\t(0xf << 0)  \n#define DAS16CS_MISC1_DAC1CS\t\tBIT(3)\t \n#define DAS16CS_MISC1_DACCLK\t\tBIT(2)\t \n#define DAS16CS_MISC1_DACSD\t\tBIT(1)\t \n#define DAS16CS_MISC1_DAC0CS\t\tBIT(0)\t \n#define DAS16CS_MISC1_DAC_MASK\t\t(0x0f << 0)\n#define DAS16CS_MISC2_REG\t\t0x06\n#define DAS16CS_MISC2_BME\t\tBIT(14)\t \n#define DAS16CS_MISC2_AI_GAIN(x)\t(((x) & 0xf) << 8)  \n#define DAS16CS_MISC2_AI_GAIN_1\t\tDAS16CS_MISC2_AI_GAIN(4)  \n#define DAS16CS_MISC2_AI_GAIN_2\t\tDAS16CS_MISC2_AI_GAIN(0)  \n#define DAS16CS_MISC2_AI_GAIN_4\t\tDAS16CS_MISC2_AI_GAIN(1)  \n#define DAS16CS_MISC2_AI_GAIN_8\t\tDAS16CS_MISC2_AI_GAIN(2)  \n#define DAS16CS_MISC2_AI_GAIN_MASK\tDAS16CS_MISC2_AI_GAIN(0xf)\n#define DAS16CS_MISC2_UDIR\t\tBIT(7)\t \n#define DAS16CS_MISC2_LDIR\t\tBIT(6)\t \n#define DAS16CS_MISC2_TRGPOL\t\tBIT(5)\t \n#define DAS16CS_MISC2_TRGSEL\t\tBIT(4)\t \n#define DAS16CS_MISC2_FFNE\t\tBIT(3)\t \n#define DAS16CS_MISC2_TRGCLR\t\tBIT(3)\t \n#define DAS16CS_MISC2_CLK2\t\tBIT(2)\t \n#define DAS16CS_MISC2_CTR1\t\tBIT(1)\t \n#define DAS16CS_MISC2_TRG0\t\tBIT(0)\t \n#define DAS16CS_TIMER_BASE\t\t0x08\n#define DAS16CS_DIO_REG\t\t\t0x10\n\nstruct das16cs_board {\n\tconst char *name;\n\tint device_id;\n\tunsigned int has_ao:1;\n\tunsigned int has_4dio:1;\n};\n\nstatic const struct das16cs_board das16cs_boards[] = {\n\t{\n\t\t.name\t\t= \"PC-CARD DAS16/16-AO\",\n\t\t.device_id\t= 0x0039,\n\t\t.has_ao\t\t= 1,\n\t\t.has_4dio\t= 1,\n\t}, {\n\t\t.name\t\t= \"PCM-DAS16s/16\",\n\t\t.device_id\t= 0x4009,\n\t}, {\n\t\t.name\t\t= \"PC-CARD DAS16/16\",\n\t\t.device_id\t= 0x0000,\t \n\t},\n};\n\nstruct das16cs_private {\n\tunsigned short misc1;\n\tunsigned short misc2;\n};\n\nstatic const struct comedi_lrange das16cs_ai_range = {\n\t4, {\n\t\tBIP_RANGE(10),\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(2.5),\n\t\tBIP_RANGE(1.25),\n\t}\n};\n\nstatic int das16cs_ai_eoc(struct comedi_device *dev,\n\t\t\t  struct comedi_subdevice *s,\n\t\t\t  struct comedi_insn *insn,\n\t\t\t  unsigned long context)\n{\n\tunsigned int status;\n\n\tstatus = inw(dev->iobase + DAS16CS_MISC1_REG);\n\tif (status & DAS16CS_MISC1_EOC)\n\t\treturn 0;\n\treturn -EBUSY;\n}\n\nstatic int das16cs_ai_insn_read(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tstruct comedi_insn *insn,\n\t\t\t\tunsigned int *data)\n{\n\tstruct das16cs_private *devpriv = dev->private;\n\tint chan = CR_CHAN(insn->chanspec);\n\tint range = CR_RANGE(insn->chanspec);\n\tint aref = CR_AREF(insn->chanspec);\n\tint ret;\n\tint i;\n\n\toutw(DAS16CS_AI_MUX_SINGLE_CHAN(chan),\n\t     dev->iobase + DAS16CS_AI_MUX_REG);\n\n\t \n\tdevpriv->misc1 &= ~(DAS16CS_MISC1_INTE | DAS16CS_MISC1_INT_SRC_MASK |\n\t\t\t      DAS16CS_MISC1_AI_CONV_MASK);\n\tif (aref == AREF_DIFF)\n\t\tdevpriv->misc1 &= ~DAS16CS_MISC1_SEDIFF;\n\telse\n\t\tdevpriv->misc1 |= DAS16CS_MISC1_SEDIFF;\n\toutw(devpriv->misc1, dev->iobase + DAS16CS_MISC1_REG);\n\n\tdevpriv->misc2 &= ~(DAS16CS_MISC2_BME | DAS16CS_MISC2_AI_GAIN_MASK);\n\tswitch (range) {\n\tcase 0:\n\t\tdevpriv->misc2 |= DAS16CS_MISC2_AI_GAIN_1;\n\t\tbreak;\n\tcase 1:\n\t\tdevpriv->misc2 |= DAS16CS_MISC2_AI_GAIN_2;\n\t\tbreak;\n\tcase 2:\n\t\tdevpriv->misc2 |= DAS16CS_MISC2_AI_GAIN_4;\n\t\tbreak;\n\tcase 3:\n\t\tdevpriv->misc2 |= DAS16CS_MISC2_AI_GAIN_8;\n\t\tbreak;\n\t}\n\toutw(devpriv->misc2, dev->iobase + DAS16CS_MISC2_REG);\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\toutw(0, dev->iobase + DAS16CS_AI_DATA_REG);\n\n\t\tret = comedi_timeout(dev, s, insn, das16cs_ai_eoc, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdata[i] = inw(dev->iobase + DAS16CS_AI_DATA_REG);\n\t}\n\n\treturn i;\n}\n\nstatic int das16cs_ao_insn_write(struct comedi_device *dev,\n\t\t\t\t struct comedi_subdevice *s,\n\t\t\t\t struct comedi_insn *insn,\n\t\t\t\t unsigned int *data)\n{\n\tstruct das16cs_private *devpriv = dev->private;\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int val = s->readback[chan];\n\tunsigned short misc1;\n\tint bit;\n\tint i;\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\tval = data[i];\n\n\t\toutw(devpriv->misc1, dev->iobase + DAS16CS_MISC1_REG);\n\t\tudelay(1);\n\n\t\t \n\t\tmisc1 = devpriv->misc1 & ~DAS16CS_MISC1_DAC_MASK;\n\t\tif (chan)\n\t\t\tmisc1 |= DAS16CS_MISC1_DAC0CS;\n\t\telse\n\t\t\tmisc1 |= DAS16CS_MISC1_DAC1CS;\n\n\t\toutw(misc1, dev->iobase + DAS16CS_MISC1_REG);\n\t\tudelay(1);\n\n\t\tfor (bit = 15; bit >= 0; bit--) {\n\t\t\tif ((val >> bit) & 0x1)\n\t\t\t\tmisc1 |= DAS16CS_MISC1_DACSD;\n\t\t\telse\n\t\t\t\tmisc1 &= ~DAS16CS_MISC1_DACSD;\n\t\t\toutw(misc1, dev->iobase + DAS16CS_MISC1_REG);\n\t\t\tudelay(1);\n\t\t\toutw(misc1 | DAS16CS_MISC1_DACCLK,\n\t\t\t     dev->iobase + DAS16CS_MISC1_REG);\n\t\t\tudelay(1);\n\t\t}\n\t\t \n\t\toutw(misc1 | DAS16CS_MISC1_DAC0CS | DAS16CS_MISC1_DAC1CS,\n\t\t     dev->iobase + DAS16CS_MISC1_REG);\n\t}\n\ts->readback[chan] = val;\n\n\treturn insn->n;\n}\n\nstatic int das16cs_dio_insn_bits(struct comedi_device *dev,\n\t\t\t\t struct comedi_subdevice *s,\n\t\t\t\t struct comedi_insn *insn,\n\t\t\t\t unsigned int *data)\n{\n\tif (comedi_dio_update_state(s, data))\n\t\toutw(s->state, dev->iobase + DAS16CS_DIO_REG);\n\n\tdata[1] = inw(dev->iobase + DAS16CS_DIO_REG);\n\n\treturn insn->n;\n}\n\nstatic int das16cs_dio_insn_config(struct comedi_device *dev,\n\t\t\t\t   struct comedi_subdevice *s,\n\t\t\t\t   struct comedi_insn *insn,\n\t\t\t\t   unsigned int *data)\n{\n\tstruct das16cs_private *devpriv = dev->private;\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int mask;\n\tint ret;\n\n\tif (chan < 4)\n\t\tmask = 0x0f;\n\telse\n\t\tmask = 0xf0;\n\n\tret = comedi_dio_insn_config(dev, s, insn, data, mask);\n\tif (ret)\n\t\treturn ret;\n\n\tif (s->io_bits & 0xf0)\n\t\tdevpriv->misc2 |= DAS16CS_MISC2_UDIR;\n\telse\n\t\tdevpriv->misc2 &= ~DAS16CS_MISC2_UDIR;\n\tif (s->io_bits & 0x0f)\n\t\tdevpriv->misc2 |= DAS16CS_MISC2_LDIR;\n\telse\n\t\tdevpriv->misc2 &= ~DAS16CS_MISC2_LDIR;\n\toutw(devpriv->misc2, dev->iobase + DAS16CS_MISC2_REG);\n\n\treturn insn->n;\n}\n\nstatic int das16cs_counter_insn_config(struct comedi_device *dev,\n\t\t\t\t       struct comedi_subdevice *s,\n\t\t\t\t       struct comedi_insn *insn,\n\t\t\t\t       unsigned int *data)\n{\n\tstruct das16cs_private *devpriv = dev->private;\n\n\tswitch (data[0]) {\n\tcase INSN_CONFIG_SET_CLOCK_SRC:\n\t\tswitch (data[1]) {\n\t\tcase 0:\t \n\t\t\tdevpriv->misc2 |= DAS16CS_MISC2_CTR1;\n\t\t\tbreak;\n\t\tcase 1:\t \n\t\t\tdevpriv->misc2 &= ~DAS16CS_MISC2_CTR1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\toutw(devpriv->misc2, dev->iobase + DAS16CS_MISC2_REG);\n\t\tbreak;\n\tcase INSN_CONFIG_GET_CLOCK_SRC:\n\t\tif (devpriv->misc2 & DAS16CS_MISC2_CTR1) {\n\t\t\tdata[1] = 0;\n\t\t\tdata[2] = I8254_OSC_BASE_100KHZ;\n\t\t} else {\n\t\t\tdata[1] = 1;\n\t\t\tdata[2] = 0;\t \n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn insn->n;\n}\n\nstatic const void *das16cs_find_boardinfo(struct comedi_device *dev,\n\t\t\t\t\t  struct pcmcia_device *link)\n{\n\tconst struct das16cs_board *board;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(das16cs_boards); i++) {\n\t\tboard = &das16cs_boards[i];\n\t\tif (board->device_id == link->card_id)\n\t\t\treturn board;\n\t}\n\n\treturn NULL;\n}\n\nstatic int das16cs_auto_attach(struct comedi_device *dev,\n\t\t\t       unsigned long context)\n{\n\tstruct pcmcia_device *link = comedi_to_pcmcia_dev(dev);\n\tconst struct das16cs_board *board;\n\tstruct das16cs_private *devpriv;\n\tstruct comedi_subdevice *s;\n\tint ret;\n\n\tboard = das16cs_find_boardinfo(dev, link);\n\tif (!board)\n\t\treturn -ENODEV;\n\tdev->board_ptr = board;\n\tdev->board_name = board->name;\n\n\tlink->config_flags |= CONF_AUTO_SET_IO | CONF_ENABLE_IRQ;\n\tret = comedi_pcmcia_enable(dev, NULL);\n\tif (ret)\n\t\treturn ret;\n\tdev->iobase = link->resource[0]->start;\n\n\tlink->priv = dev;\n\n\tdevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\n\tif (!devpriv)\n\t\treturn -ENOMEM;\n\n\tdev->pacer = comedi_8254_init(dev->iobase + DAS16CS_TIMER_BASE,\n\t\t\t\t      I8254_OSC_BASE_10MHZ, I8254_IO16, 0);\n\tif (!dev->pacer)\n\t\treturn -ENOMEM;\n\n\tret = comedi_alloc_subdevices(dev, 4);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ts = &dev->subdevices[0];\n\ts->type\t\t= COMEDI_SUBD_AI;\n\ts->subdev_flags\t= SDF_READABLE | SDF_GROUND | SDF_DIFF;\n\ts->n_chan\t= 16;\n\ts->maxdata\t= 0xffff;\n\ts->range_table\t= &das16cs_ai_range;\n\ts->insn_read\t= das16cs_ai_insn_read;\n\n\t \n\ts = &dev->subdevices[1];\n\tif (board->has_ao) {\n\t\ts->type\t\t= COMEDI_SUBD_AO;\n\t\ts->subdev_flags\t= SDF_WRITABLE;\n\t\ts->n_chan\t= 2;\n\t\ts->maxdata\t= 0xffff;\n\t\ts->range_table\t= &range_bipolar10;\n\t\ts->insn_write\t= &das16cs_ao_insn_write;\n\n\t\tret = comedi_alloc_subdev_readback(s);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\ts->type\t\t= COMEDI_SUBD_UNUSED;\n\t}\n\n\t \n\ts = &dev->subdevices[2];\n\ts->type\t\t= COMEDI_SUBD_DIO;\n\ts->subdev_flags\t= SDF_READABLE | SDF_WRITABLE;\n\ts->n_chan\t= board->has_4dio ? 4 : 8;\n\ts->maxdata\t= 1;\n\ts->range_table\t= &range_digital;\n\ts->insn_bits\t= das16cs_dio_insn_bits;\n\ts->insn_config\t= das16cs_dio_insn_config;\n\n\t \n\ts = &dev->subdevices[3];\n\tcomedi_8254_subdevice_init(s, dev->pacer);\n\n\tdev->pacer->insn_config = das16cs_counter_insn_config;\n\n\t \n\tcomedi_8254_set_busy(dev->pacer, 1, true);\n\tcomedi_8254_set_busy(dev->pacer, 2, true);\n\n\treturn 0;\n}\n\nstatic struct comedi_driver driver_das16cs = {\n\t.driver_name\t= \"cb_das16_cs\",\n\t.module\t\t= THIS_MODULE,\n\t.auto_attach\t= das16cs_auto_attach,\n\t.detach\t\t= comedi_pcmcia_disable,\n};\n\nstatic int das16cs_pcmcia_attach(struct pcmcia_device *link)\n{\n\treturn comedi_pcmcia_auto_config(link, &driver_das16cs);\n}\n\nstatic const struct pcmcia_device_id das16cs_id_table[] = {\n\tPCMCIA_DEVICE_MANF_CARD(0x01c5, 0x0039),\n\tPCMCIA_DEVICE_MANF_CARD(0x01c5, 0x4009),\n\tPCMCIA_DEVICE_NULL\n};\nMODULE_DEVICE_TABLE(pcmcia, das16cs_id_table);\n\nstatic struct pcmcia_driver das16cs_driver = {\n\t.name\t\t= \"cb_das16_cs\",\n\t.owner\t\t= THIS_MODULE,\n\t.id_table\t= das16cs_id_table,\n\t.probe\t\t= das16cs_pcmcia_attach,\n\t.remove\t\t= comedi_pcmcia_auto_unconfig,\n};\nmodule_comedi_pcmcia_driver(driver_das16cs, das16cs_driver);\n\nMODULE_AUTHOR(\"David A. Schleef <ds@schleef.org>\");\nMODULE_DESCRIPTION(\"Comedi driver for Computer Boards PC-CARD DAS16/16\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}