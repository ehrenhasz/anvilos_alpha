{
  "module_name": "dmm32at.c",
  "hash_id": "6dd36819ac489b98dc74768d6676706ea71bebda596b2da95c2940ce70450d3d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/dmm32at.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/comedi/comedidev.h>\n#include <linux/comedi/comedi_8255.h>\n\n \n#define DMM32AT_AI_START_CONV_REG\t0x00\n#define DMM32AT_AI_LSB_REG\t\t0x00\n#define DMM32AT_AUX_DOUT_REG\t\t0x01\n#define DMM32AT_AUX_DOUT2\t\tBIT(2)   \n#define DMM32AT_AUX_DOUT1\t\tBIT(1)   \n#define DMM32AT_AUX_DOUT0\t\tBIT(0)   \n#define DMM32AT_AI_MSB_REG\t\t0x01\n#define DMM32AT_AI_LO_CHAN_REG\t\t0x02\n#define DMM32AT_AI_HI_CHAN_REG\t\t0x03\n#define DMM32AT_AUX_DI_REG\t\t0x04\n#define DMM32AT_AUX_DI_DACBUSY\t\tBIT(7)\n#define DMM32AT_AUX_DI_CALBUSY\t\tBIT(6)\n#define DMM32AT_AUX_DI3\t\t\tBIT(3)   \n#define DMM32AT_AUX_DI2\t\t\tBIT(2)   \n#define DMM32AT_AUX_DI1\t\t\tBIT(1)   \n#define DMM32AT_AUX_DI0\t\t\tBIT(0)   \n#define DMM32AT_AO_LSB_REG\t\t0x04\n#define DMM32AT_AO_MSB_REG\t\t0x05\n#define DMM32AT_AO_MSB_DACH(x)\t\t((x) << 6)\n#define DMM32AT_FIFO_DEPTH_REG\t\t0x06\n#define DMM32AT_FIFO_CTRL_REG\t\t0x07\n#define DMM32AT_FIFO_CTRL_FIFOEN\tBIT(3)\n#define DMM32AT_FIFO_CTRL_SCANEN\tBIT(2)\n#define DMM32AT_FIFO_CTRL_FIFORST\tBIT(1)\n#define DMM32AT_FIFO_STATUS_REG\t\t0x07\n#define DMM32AT_FIFO_STATUS_EF\t\tBIT(7)\n#define DMM32AT_FIFO_STATUS_HF\t\tBIT(6)\n#define DMM32AT_FIFO_STATUS_FF\t\tBIT(5)\n#define DMM32AT_FIFO_STATUS_OVF\t\tBIT(4)\n#define DMM32AT_FIFO_STATUS_FIFOEN\tBIT(3)\n#define DMM32AT_FIFO_STATUS_SCANEN\tBIT(2)\n#define DMM32AT_FIFO_STATUS_PAGE_MASK\t(3 << 0)\n#define DMM32AT_CTRL_REG\t\t0x08\n#define DMM32AT_CTRL_RESETA\t\tBIT(5)\n#define DMM32AT_CTRL_RESETD\t\tBIT(4)\n#define DMM32AT_CTRL_INTRST\t\tBIT(3)\n#define DMM32AT_CTRL_PAGE(x)\t\t((x) << 0)\n#define DMM32AT_CTRL_PAGE_8254\t\tDMM32AT_CTRL_PAGE(0)\n#define DMM32AT_CTRL_PAGE_8255\t\tDMM32AT_CTRL_PAGE(1)\n#define DMM32AT_CTRL_PAGE_CALIB\t\tDMM32AT_CTRL_PAGE(3)\n#define DMM32AT_AI_STATUS_REG\t\t0x08\n#define DMM32AT_AI_STATUS_STS\t\tBIT(7)\n#define DMM32AT_AI_STATUS_SD1\t\tBIT(6)\n#define DMM32AT_AI_STATUS_SD0\t\tBIT(5)\n#define DMM32AT_AI_STATUS_ADCH_MASK\t(0x1f << 0)\n#define DMM32AT_INTCLK_REG\t\t0x09\n#define DMM32AT_INTCLK_ADINT\t\tBIT(7)\n#define DMM32AT_INTCLK_DINT\t\tBIT(6)\n#define DMM32AT_INTCLK_TINT\t\tBIT(5)\n#define DMM32AT_INTCLK_CLKEN\t\tBIT(1)   \n#define DMM32AT_INTCLK_CLKSEL\t\tBIT(0)   \n#define DMM32AT_CTRDIO_CFG_REG\t\t0x0a\n#define DMM32AT_CTRDIO_CFG_FREQ12\tBIT(7)   \n#define DMM32AT_CTRDIO_CFG_FREQ0\tBIT(6)   \n#define DMM32AT_CTRDIO_CFG_OUT2EN\tBIT(5)   \n#define DMM32AT_CTRDIO_CFG_OUT0EN\tBIT(4)   \n#define DMM32AT_CTRDIO_CFG_GT0EN\tBIT(2)   \n#define DMM32AT_CTRDIO_CFG_SRC0\t\tBIT(1)   \n#define DMM32AT_CTRDIO_CFG_GT12EN\tBIT(0)   \n#define DMM32AT_AI_CFG_REG\t\t0x0b\n#define DMM32AT_AI_CFG_SCINT(x)\t\t((x) << 4)\n#define DMM32AT_AI_CFG_SCINT_20US\tDMM32AT_AI_CFG_SCINT(0)\n#define DMM32AT_AI_CFG_SCINT_15US\tDMM32AT_AI_CFG_SCINT(1)\n#define DMM32AT_AI_CFG_SCINT_10US\tDMM32AT_AI_CFG_SCINT(2)\n#define DMM32AT_AI_CFG_SCINT_5US\tDMM32AT_AI_CFG_SCINT(3)\n#define DMM32AT_AI_CFG_RANGE\t\tBIT(3)   \n#define DMM32AT_AI_CFG_ADBU\t\tBIT(2)   \n#define DMM32AT_AI_CFG_GAIN(x)\t\t((x) << 0)\n#define DMM32AT_AI_READBACK_REG\t\t0x0b\n#define DMM32AT_AI_READBACK_WAIT\tBIT(7)   \n#define DMM32AT_AI_READBACK_RANGE\tBIT(3)\n#define DMM32AT_AI_READBACK_ADBU\tBIT(2)\n#define DMM32AT_AI_READBACK_GAIN_MASK\t(3 << 0)\n\n#define DMM32AT_CLK1 0x0d\n#define DMM32AT_CLK2 0x0e\n#define DMM32AT_CLKCT 0x0f\n\n#define DMM32AT_8255_IOBASE\t\t0x0c   \n\n \n\n \n#define DMM32AT_RANGE_U10 0x0c\n#define DMM32AT_RANGE_U5 0x0d\n#define DMM32AT_RANGE_B10 0x08\n#define DMM32AT_RANGE_B5 0x00\n\n \n#define DMM32AT_CLKCT1 0x56\t \n#define DMM32AT_CLKCT2 0xb6\t \n\n \nstatic const struct comedi_lrange dmm32at_airanges = {\n\t4, {\n\t\tUNI_RANGE(10),\n\t\tUNI_RANGE(5),\n\t\tBIP_RANGE(10),\n\t\tBIP_RANGE(5)\n\t}\n};\n\n \nstatic const unsigned char dmm32at_rangebits[] = {\n\tDMM32AT_RANGE_U10,\n\tDMM32AT_RANGE_U5,\n\tDMM32AT_RANGE_B10,\n\tDMM32AT_RANGE_B5,\n};\n\n \nstatic const struct comedi_lrange dmm32at_aoranges = {\n\t4, {\n\t\tUNI_RANGE(10),\n\t\tUNI_RANGE(5),\n\t\tBIP_RANGE(10),\n\t\tBIP_RANGE(5)\n\t}\n};\n\nstatic void dmm32at_ai_set_chanspec(struct comedi_device *dev,\n\t\t\t\t    struct comedi_subdevice *s,\n\t\t\t\t    unsigned int chanspec, int nchan)\n{\n\tunsigned int chan = CR_CHAN(chanspec);\n\tunsigned int range = CR_RANGE(chanspec);\n\tunsigned int last_chan = (chan + nchan - 1) % s->n_chan;\n\n\toutb(DMM32AT_FIFO_CTRL_FIFORST, dev->iobase + DMM32AT_FIFO_CTRL_REG);\n\n\tif (nchan > 1)\n\t\toutb(DMM32AT_FIFO_CTRL_SCANEN,\n\t\t     dev->iobase + DMM32AT_FIFO_CTRL_REG);\n\n\toutb(chan, dev->iobase + DMM32AT_AI_LO_CHAN_REG);\n\toutb(last_chan, dev->iobase + DMM32AT_AI_HI_CHAN_REG);\n\toutb(dmm32at_rangebits[range], dev->iobase + DMM32AT_AI_CFG_REG);\n}\n\nstatic unsigned int dmm32at_ai_get_sample(struct comedi_device *dev,\n\t\t\t\t\t  struct comedi_subdevice *s)\n{\n\tunsigned int val;\n\n\tval = inb(dev->iobase + DMM32AT_AI_LSB_REG);\n\tval |= (inb(dev->iobase + DMM32AT_AI_MSB_REG) << 8);\n\n\t \n\treturn comedi_offset_munge(s, val);\n}\n\nstatic int dmm32at_ai_status(struct comedi_device *dev,\n\t\t\t     struct comedi_subdevice *s,\n\t\t\t     struct comedi_insn *insn,\n\t\t\t     unsigned long context)\n{\n\tunsigned char status;\n\n\tstatus = inb(dev->iobase + context);\n\tif ((status & DMM32AT_AI_STATUS_STS) == 0)\n\t\treturn 0;\n\treturn -EBUSY;\n}\n\nstatic int dmm32at_ai_insn_read(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tstruct comedi_insn *insn,\n\t\t\t\tunsigned int *data)\n{\n\tint ret;\n\tint i;\n\n\tdmm32at_ai_set_chanspec(dev, s, insn->chanspec, 1);\n\n\t \n\tret = comedi_timeout(dev, s, insn, dmm32at_ai_status,\n\t\t\t     DMM32AT_AI_READBACK_REG);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\toutb(0xff, dev->iobase + DMM32AT_AI_START_CONV_REG);\n\n\t\tret = comedi_timeout(dev, s, insn, dmm32at_ai_status,\n\t\t\t\t     DMM32AT_AI_STATUS_REG);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdata[i] = dmm32at_ai_get_sample(dev, s);\n\t}\n\n\treturn insn->n;\n}\n\nstatic int dmm32at_ai_check_chanlist(struct comedi_device *dev,\n\t\t\t\t     struct comedi_subdevice *s,\n\t\t\t\t     struct comedi_cmd *cmd)\n{\n\tunsigned int chan0 = CR_CHAN(cmd->chanlist[0]);\n\tunsigned int range0 = CR_RANGE(cmd->chanlist[0]);\n\tint i;\n\n\tfor (i = 1; i < cmd->chanlist_len; i++) {\n\t\tunsigned int chan = CR_CHAN(cmd->chanlist[i]);\n\t\tunsigned int range = CR_RANGE(cmd->chanlist[i]);\n\n\t\tif (chan != (chan0 + i) % s->n_chan) {\n\t\t\tdev_dbg(dev->class_dev,\n\t\t\t\t\"entries in chanlist must be consecutive channels, counting upwards\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (range != range0) {\n\t\t\tdev_dbg(dev->class_dev,\n\t\t\t\t\"entries in chanlist must all have the same gain\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int dmm32at_ai_cmdtest(struct comedi_device *dev,\n\t\t\t      struct comedi_subdevice *s,\n\t\t\t      struct comedi_cmd *cmd)\n{\n\tint err = 0;\n\tunsigned int arg;\n\n\t \n\n\terr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW);\n\terr |= comedi_check_trigger_src(&cmd->scan_begin_src, TRIG_TIMER);\n\terr |= comedi_check_trigger_src(&cmd->convert_src, TRIG_TIMER);\n\terr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\n\terr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\n\n\tif (err)\n\t\treturn 1;\n\n\t \n\n\terr |= comedi_check_trigger_is_unique(cmd->stop_src);\n\n\t \n\n\tif (err)\n\t\treturn 2;\n\n\t \n\n\terr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\n\n\terr |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg, 1000000);\n\terr |= comedi_check_trigger_arg_max(&cmd->scan_begin_arg, 1000000000);\n\n\tif (cmd->convert_arg >= 17500)\n\t\tcmd->convert_arg = 20000;\n\telse if (cmd->convert_arg >= 12500)\n\t\tcmd->convert_arg = 15000;\n\telse if (cmd->convert_arg >= 7500)\n\t\tcmd->convert_arg = 10000;\n\telse\n\t\tcmd->convert_arg = 5000;\n\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\n\t\t\t\t\t   cmd->chanlist_len);\n\n\tif (cmd->stop_src == TRIG_COUNT)\n\t\terr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\n\telse  \n\t\terr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\n\n\tif (err)\n\t\treturn 3;\n\n\t \n\n\targ = cmd->convert_arg * cmd->scan_end_arg;\n\terr |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg, arg);\n\n\tif (err)\n\t\treturn 4;\n\n\t \n\tif (cmd->chanlist && cmd->chanlist_len > 0)\n\t\terr |= dmm32at_ai_check_chanlist(dev, s, cmd);\n\n\tif (err)\n\t\treturn 5;\n\n\treturn 0;\n}\n\nstatic void dmm32at_setaitimer(struct comedi_device *dev, unsigned int nansec)\n{\n\tunsigned char lo1, lo2, hi2;\n\tunsigned short both2;\n\n\t \n\tlo1 = 200;\n\tboth2 = nansec / 20000;\n\thi2 = (both2 & 0xff00) >> 8;\n\tlo2 = both2 & 0x00ff;\n\n\t \n\toutb(0, dev->iobase + DMM32AT_CTRDIO_CFG_REG);\n\n\t \n\toutb(DMM32AT_CTRL_PAGE_8254, dev->iobase + DMM32AT_CTRL_REG);\n\n\t \n\toutb(DMM32AT_CLKCT1, dev->iobase + DMM32AT_CLKCT);\n\toutb(lo1, dev->iobase + DMM32AT_CLK1);\n\n\t \n\toutb(DMM32AT_CLKCT2, dev->iobase + DMM32AT_CLKCT);\n\toutb(lo2, dev->iobase + DMM32AT_CLK2);\n\toutb(hi2, dev->iobase + DMM32AT_CLK2);\n\n\t \n\toutb(DMM32AT_INTCLK_ADINT |\n\t     DMM32AT_INTCLK_CLKEN | DMM32AT_INTCLK_CLKSEL,\n\t     dev->iobase + DMM32AT_INTCLK_REG);\n}\n\nstatic int dmm32at_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\n{\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tint ret;\n\n\tdmm32at_ai_set_chanspec(dev, s, cmd->chanlist[0], cmd->chanlist_len);\n\n\t \n\toutb(DMM32AT_CTRL_INTRST, dev->iobase + DMM32AT_CTRL_REG);\n\n\t \n\tret = comedi_timeout(dev, s, NULL, dmm32at_ai_status,\n\t\t\t     DMM32AT_AI_READBACK_REG);\n\tif (ret)\n\t\treturn ret;\n\n\tif (cmd->stop_src == TRIG_NONE || cmd->stop_arg > 1) {\n\t\t \n\t\tdmm32at_setaitimer(dev, cmd->scan_begin_arg);\n\t} else {\n\t\t \n\t\toutb(DMM32AT_INTCLK_ADINT, dev->iobase + DMM32AT_INTCLK_REG);\n\t\toutb(0xff, dev->iobase + DMM32AT_AI_START_CONV_REG);\n\t}\n\n\treturn 0;\n}\n\nstatic int dmm32at_ai_cancel(struct comedi_device *dev,\n\t\t\t     struct comedi_subdevice *s)\n{\n\t \n\toutb(0x0, dev->iobase + DMM32AT_INTCLK_REG);\n\treturn 0;\n}\n\nstatic irqreturn_t dmm32at_isr(int irq, void *d)\n{\n\tstruct comedi_device *dev = d;\n\tunsigned char intstat;\n\tunsigned short val;\n\tint i;\n\n\tif (!dev->attached) {\n\t\tdev_err(dev->class_dev, \"spurious interrupt\\n\");\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tintstat = inb(dev->iobase + DMM32AT_INTCLK_REG);\n\n\tif (intstat & DMM32AT_INTCLK_ADINT) {\n\t\tstruct comedi_subdevice *s = dev->read_subdev;\n\t\tstruct comedi_cmd *cmd = &s->async->cmd;\n\n\t\tfor (i = 0; i < cmd->chanlist_len; i++) {\n\t\t\tval = dmm32at_ai_get_sample(dev, s);\n\t\t\tcomedi_buf_write_samples(s, &val, 1);\n\t\t}\n\n\t\tif (cmd->stop_src == TRIG_COUNT &&\n\t\t    s->async->scans_done >= cmd->stop_arg)\n\t\t\ts->async->events |= COMEDI_CB_EOA;\n\n\t\tcomedi_handle_events(dev, s);\n\t}\n\n\t \n\toutb(DMM32AT_CTRL_INTRST, dev->iobase + DMM32AT_CTRL_REG);\n\treturn IRQ_HANDLED;\n}\n\nstatic int dmm32at_ao_eoc(struct comedi_device *dev,\n\t\t\t  struct comedi_subdevice *s,\n\t\t\t  struct comedi_insn *insn,\n\t\t\t  unsigned long context)\n{\n\tunsigned char status;\n\n\tstatus = inb(dev->iobase + DMM32AT_AUX_DI_REG);\n\tif ((status & DMM32AT_AUX_DI_DACBUSY) == 0)\n\t\treturn 0;\n\treturn -EBUSY;\n}\n\nstatic int dmm32at_ao_insn_write(struct comedi_device *dev,\n\t\t\t\t struct comedi_subdevice *s,\n\t\t\t\t struct comedi_insn *insn,\n\t\t\t\t unsigned int *data)\n{\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tint i;\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\tunsigned int val = data[i];\n\t\tint ret;\n\n\t\t \n\t\toutb(val & 0xff, dev->iobase + DMM32AT_AO_LSB_REG);\n\t\toutb((val >> 8) | DMM32AT_AO_MSB_DACH(chan),\n\t\t     dev->iobase + DMM32AT_AO_MSB_REG);\n\n\t\t \n\t\tret = comedi_timeout(dev, s, insn, dmm32at_ao_eoc, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tinb(dev->iobase + DMM32AT_AO_MSB_REG);\n\n\t\ts->readback[chan] = val;\n\t}\n\n\treturn insn->n;\n}\n\nstatic int dmm32at_8255_io(struct comedi_device *dev,\n\t\t\t   int dir, int port, int data, unsigned long regbase)\n{\n\t \n\toutb(DMM32AT_CTRL_PAGE_8255, dev->iobase + DMM32AT_CTRL_REG);\n\n\tif (dir) {\n\t\toutb(data, dev->iobase + regbase + port);\n\t\treturn 0;\n\t}\n\treturn inb(dev->iobase + regbase + port);\n}\n\n \nstatic int dmm32at_reset(struct comedi_device *dev)\n{\n\tunsigned char aihi, ailo, fifostat, aistat, intstat, airback;\n\n\t \n\toutb(DMM32AT_CTRL_RESETA, dev->iobase + DMM32AT_CTRL_REG);\n\n\t \n\tusleep_range(1000, 3000);\n\n\t \n\toutb(0x0, dev->iobase + DMM32AT_FIFO_CTRL_REG);\n\n\t \n\toutb(0x0, dev->iobase + DMM32AT_INTCLK_REG);\n\n\t \n\toutb(0x80, dev->iobase + DMM32AT_AI_LO_CHAN_REG);\n\toutb(0xff, dev->iobase + DMM32AT_AI_HI_CHAN_REG);\n\n\t \n\toutb(DMM32AT_RANGE_U10, dev->iobase + DMM32AT_AI_CFG_REG);\n\n\t \n\tusleep_range(100, 200);\n\n\t \n\tailo = inb(dev->iobase + DMM32AT_AI_LO_CHAN_REG);\n\taihi = inb(dev->iobase + DMM32AT_AI_HI_CHAN_REG);\n\tfifostat = inb(dev->iobase + DMM32AT_FIFO_STATUS_REG);\n\taistat = inb(dev->iobase + DMM32AT_AI_STATUS_REG);\n\tintstat = inb(dev->iobase + DMM32AT_INTCLK_REG);\n\tairback = inb(dev->iobase + DMM32AT_AI_READBACK_REG);\n\n\t \n\tif (ailo != 0x00 || aihi != 0x1f ||\n\t    fifostat != DMM32AT_FIFO_STATUS_EF ||\n\t    aistat != (DMM32AT_AI_STATUS_SD1 | DMM32AT_AI_STATUS_SD0) ||\n\t    intstat != 0x00 || airback != 0x0c)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int dmm32at_attach(struct comedi_device *dev,\n\t\t\t  struct comedi_devconfig *it)\n{\n\tstruct comedi_subdevice *s;\n\tint ret;\n\n\tret = comedi_request_region(dev, it->options[0], 0x10);\n\tif (ret)\n\t\treturn ret;\n\n\tret = dmm32at_reset(dev);\n\tif (ret) {\n\t\tdev_err(dev->class_dev, \"board detection failed\\n\");\n\t\treturn ret;\n\t}\n\n\tif (it->options[1]) {\n\t\tret = request_irq(it->options[1], dmm32at_isr, 0,\n\t\t\t\t  dev->board_name, dev);\n\t\tif (ret == 0)\n\t\t\tdev->irq = it->options[1];\n\t}\n\n\tret = comedi_alloc_subdevices(dev, 3);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ts = &dev->subdevices[0];\n\ts->type\t\t= COMEDI_SUBD_AI;\n\ts->subdev_flags\t= SDF_READABLE | SDF_GROUND | SDF_DIFF;\n\ts->n_chan\t= 32;\n\ts->maxdata\t= 0xffff;\n\ts->range_table\t= &dmm32at_airanges;\n\ts->insn_read\t= dmm32at_ai_insn_read;\n\tif (dev->irq) {\n\t\tdev->read_subdev = s;\n\t\ts->subdev_flags\t|= SDF_CMD_READ;\n\t\ts->len_chanlist\t= s->n_chan;\n\t\ts->do_cmd\t= dmm32at_ai_cmd;\n\t\ts->do_cmdtest\t= dmm32at_ai_cmdtest;\n\t\ts->cancel\t= dmm32at_ai_cancel;\n\t}\n\n\t \n\ts = &dev->subdevices[1];\n\ts->type\t\t= COMEDI_SUBD_AO;\n\ts->subdev_flags\t= SDF_WRITABLE;\n\ts->n_chan\t= 4;\n\ts->maxdata\t= 0x0fff;\n\ts->range_table\t= &dmm32at_aoranges;\n\ts->insn_write\t= dmm32at_ao_insn_write;\n\n\tret = comedi_alloc_subdev_readback(s);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ts = &dev->subdevices[2];\n\treturn subdev_8255_init(dev, s, dmm32at_8255_io, DMM32AT_8255_IOBASE);\n}\n\nstatic struct comedi_driver dmm32at_driver = {\n\t.driver_name\t= \"dmm32at\",\n\t.module\t\t= THIS_MODULE,\n\t.attach\t\t= dmm32at_attach,\n\t.detach\t\t= comedi_legacy_detach,\n};\nmodule_comedi_driver(dmm32at_driver);\n\nMODULE_AUTHOR(\"Comedi https://www.comedi.org\");\nMODULE_DESCRIPTION(\"Comedi: Diamond Systems Diamond-MM-32-AT\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}