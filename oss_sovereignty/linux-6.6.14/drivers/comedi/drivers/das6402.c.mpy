{
  "module_name": "das6402.c",
  "hash_id": "6bebed3d445092ee2ca8c0bd7263a97ff694fc80631f35ec0ab2a9ed626a82f4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/das6402.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/comedi/comedidev.h>\n#include <linux/comedi/comedi_8254.h>\n\n \n#define DAS6402_AI_DATA_REG\t\t0x00\n#define DAS6402_AI_MUX_REG\t\t0x02\n#define DAS6402_AI_MUX_LO(x)\t\t(((x) & 0x3f) << 0)\n#define DAS6402_AI_MUX_HI(x)\t\t(((x) & 0x3f) << 8)\n#define DAS6402_DI_DO_REG\t\t0x03\n#define DAS6402_AO_DATA_REG(x)\t\t(0x04 + ((x) * 2))\n#define DAS6402_AO_LSB_REG(x)\t\t(0x04 + ((x) * 2))\n#define DAS6402_AO_MSB_REG(x)\t\t(0x05 + ((x) * 2))\n#define DAS6402_STATUS_REG\t\t0x08\n#define DAS6402_STATUS_FFNE\t\tBIT(0)\n#define DAS6402_STATUS_FHALF\t\tBIT(1)\n#define DAS6402_STATUS_FFULL\t\tBIT(2)\n#define DAS6402_STATUS_XINT\t\tBIT(3)\n#define DAS6402_STATUS_INT\t\tBIT(4)\n#define DAS6402_STATUS_XTRIG\t\tBIT(5)\n#define DAS6402_STATUS_INDGT\t\tBIT(6)\n#define DAS6402_STATUS_10MHZ\t\tBIT(7)\n#define DAS6402_STATUS_W_CLRINT\t\tBIT(0)\n#define DAS6402_STATUS_W_CLRXTR\t\tBIT(1)\n#define DAS6402_STATUS_W_CLRXIN\t\tBIT(2)\n#define DAS6402_STATUS_W_EXTEND\t\tBIT(4)\n#define DAS6402_STATUS_W_ARMED\t\tBIT(5)\n#define DAS6402_STATUS_W_POSTMODE\tBIT(6)\n#define DAS6402_STATUS_W_10MHZ\t\tBIT(7)\n#define DAS6402_CTRL_REG\t\t0x09\n#define DAS6402_CTRL_TRIG(x)\t\t((x) << 0)\n#define DAS6402_CTRL_SOFT_TRIG\t\tDAS6402_CTRL_TRIG(0)\n#define DAS6402_CTRL_EXT_FALL_TRIG\tDAS6402_CTRL_TRIG(1)\n#define DAS6402_CTRL_EXT_RISE_TRIG\tDAS6402_CTRL_TRIG(2)\n#define DAS6402_CTRL_PACER_TRIG\t\tDAS6402_CTRL_TRIG(3)\n#define DAS6402_CTRL_BURSTEN\t\tBIT(2)\n#define DAS6402_CTRL_XINTE\t\tBIT(3)\n#define DAS6402_CTRL_IRQ(x)\t\t((x) << 4)\n#define DAS6402_CTRL_INTE\t\tBIT(7)\n#define DAS6402_TRIG_REG\t\t0x0a\n#define DAS6402_TRIG_TGEN\t\tBIT(0)\n#define DAS6402_TRIG_TGSEL\t\tBIT(1)\n#define DAS6402_TRIG_TGPOL\t\tBIT(2)\n#define DAS6402_TRIG_PRETRIG\t\tBIT(3)\n#define DAS6402_AO_RANGE(_chan, _range)\t((_range) << ((_chan) ? 6 : 4))\n#define DAS6402_AO_RANGE_MASK(_chan)\t(3 << ((_chan) ? 6 : 4))\n#define DAS6402_MODE_REG\t\t0x0b\n#define DAS6402_MODE_RANGE(x)\t\t((x) << 2)\n#define DAS6402_MODE_POLLED\t\tDAS6402_MODE_RANGE(0)\n#define DAS6402_MODE_FIFONEPTY\t\tDAS6402_MODE_RANGE(1)\n#define DAS6402_MODE_FIFOHFULL\t\tDAS6402_MODE_RANGE(2)\n#define DAS6402_MODE_EOB\t\tDAS6402_MODE_RANGE(3)\n#define DAS6402_MODE_ENHANCED\t\tBIT(4)\n#define DAS6402_MODE_SE\t\t\tBIT(5)\n#define DAS6402_MODE_UNI\t\tBIT(6)\n#define DAS6402_MODE_DMA(x)\t\t((x) << 7)\n#define DAS6402_MODE_DMA1\t\tDAS6402_MODE_DMA(0)\n#define DAS6402_MODE_DMA3\t\tDAS6402_MODE_DMA(1)\n#define DAS6402_TIMER_BASE\t\t0x0c\n\nstatic const struct comedi_lrange das6402_ai_ranges = {\n\t8, {\n\t\tBIP_RANGE(10),\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(2.5),\n\t\tBIP_RANGE(1.25),\n\t\tUNI_RANGE(10),\n\t\tUNI_RANGE(5),\n\t\tUNI_RANGE(2.5),\n\t\tUNI_RANGE(1.25)\n\t}\n};\n\n \nstatic const struct comedi_lrange das6402_ao_ranges = {\n\t4, {\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(10),\n\t\tUNI_RANGE(5),\n\t\tUNI_RANGE(10)\n\t}\n};\n\nstruct das6402_boardinfo {\n\tconst char *name;\n\tunsigned int maxdata;\n};\n\nstatic struct das6402_boardinfo das6402_boards[] = {\n\t{\n\t\t.name\t\t= \"das6402-12\",\n\t\t.maxdata\t= 0x0fff,\n\t}, {\n\t\t.name\t\t= \"das6402-16\",\n\t\t.maxdata\t= 0xffff,\n\t},\n};\n\nstruct das6402_private {\n\tunsigned int irq;\n\tunsigned int ao_range;\n};\n\nstatic void das6402_set_mode(struct comedi_device *dev,\n\t\t\t     unsigned int mode)\n{\n\toutb(DAS6402_MODE_ENHANCED | mode, dev->iobase + DAS6402_MODE_REG);\n}\n\nstatic void das6402_set_extended(struct comedi_device *dev,\n\t\t\t\t unsigned int val)\n{\n\toutb(DAS6402_STATUS_W_EXTEND, dev->iobase + DAS6402_STATUS_REG);\n\toutb(DAS6402_STATUS_W_EXTEND | val, dev->iobase + DAS6402_STATUS_REG);\n\toutb(val, dev->iobase + DAS6402_STATUS_REG);\n}\n\nstatic void das6402_clear_all_interrupts(struct comedi_device *dev)\n{\n\toutb(DAS6402_STATUS_W_CLRINT |\n\t     DAS6402_STATUS_W_CLRXTR |\n\t     DAS6402_STATUS_W_CLRXIN, dev->iobase + DAS6402_STATUS_REG);\n}\n\nstatic void das6402_ai_clear_eoc(struct comedi_device *dev)\n{\n\toutb(DAS6402_STATUS_W_CLRINT, dev->iobase + DAS6402_STATUS_REG);\n}\n\nstatic unsigned int das6402_ai_read_sample(struct comedi_device *dev,\n\t\t\t\t\t   struct comedi_subdevice *s)\n{\n\tunsigned int val;\n\n\tval = inw(dev->iobase + DAS6402_AI_DATA_REG);\n\tif (s->maxdata == 0x0fff)\n\t\tval >>= 4;\n\treturn val;\n}\n\nstatic irqreturn_t das6402_interrupt(int irq, void *d)\n{\n\tstruct comedi_device *dev = d;\n\tstruct comedi_subdevice *s = dev->read_subdev;\n\tstruct comedi_async *async = s->async;\n\tstruct comedi_cmd *cmd = &async->cmd;\n\tunsigned int status;\n\n\tstatus = inb(dev->iobase + DAS6402_STATUS_REG);\n\tif ((status & DAS6402_STATUS_INT) == 0)\n\t\treturn IRQ_NONE;\n\n\tif (status & DAS6402_STATUS_FFULL) {\n\t\tasync->events |= COMEDI_CB_OVERFLOW;\n\t} else if (status & DAS6402_STATUS_FFNE) {\n\t\tunsigned short val;\n\n\t\tval = das6402_ai_read_sample(dev, s);\n\t\tcomedi_buf_write_samples(s, &val, 1);\n\n\t\tif (cmd->stop_src == TRIG_COUNT &&\n\t\t    async->scans_done >= cmd->stop_arg)\n\t\t\tasync->events |= COMEDI_CB_EOA;\n\t}\n\n\tdas6402_clear_all_interrupts(dev);\n\n\tcomedi_handle_events(dev, s);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void das6402_ai_set_mode(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tunsigned int chanspec,\n\t\t\t\tunsigned int mode)\n{\n\tunsigned int range = CR_RANGE(chanspec);\n\tunsigned int aref = CR_AREF(chanspec);\n\n\tmode |= DAS6402_MODE_RANGE(range);\n\tif (aref == AREF_GROUND)\n\t\tmode |= DAS6402_MODE_SE;\n\tif (comedi_range_is_unipolar(s, range))\n\t\tmode |= DAS6402_MODE_UNI;\n\n\tdas6402_set_mode(dev, mode);\n}\n\nstatic int das6402_ai_cmd(struct comedi_device *dev,\n\t\t\t  struct comedi_subdevice *s)\n{\n\tstruct das6402_private *devpriv = dev->private;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tunsigned int chan_lo = CR_CHAN(cmd->chanlist[0]);\n\tunsigned int chan_hi = CR_CHAN(cmd->chanlist[cmd->chanlist_len - 1]);\n\n\tdas6402_ai_set_mode(dev, s, cmd->chanlist[0], DAS6402_MODE_FIFONEPTY);\n\n\t \n\toutw(DAS6402_AI_MUX_HI(chan_hi) | DAS6402_AI_MUX_LO(chan_lo),\n\t     dev->iobase + DAS6402_AI_MUX_REG);\n\n\tcomedi_8254_update_divisors(dev->pacer);\n\tcomedi_8254_pacer_enable(dev->pacer, 1, 2, true);\n\n\t \n\toutb(DAS6402_CTRL_INTE |\n\t     DAS6402_CTRL_IRQ(devpriv->irq) |\n\t     DAS6402_CTRL_PACER_TRIG, dev->iobase + DAS6402_CTRL_REG);\n\n\treturn 0;\n}\n\nstatic int das6402_ai_check_chanlist(struct comedi_device *dev,\n\t\t\t\t     struct comedi_subdevice *s,\n\t\t\t\t     struct comedi_cmd *cmd)\n{\n\tunsigned int chan0 = CR_CHAN(cmd->chanlist[0]);\n\tunsigned int range0 = CR_RANGE(cmd->chanlist[0]);\n\tunsigned int aref0 = CR_AREF(cmd->chanlist[0]);\n\tint i;\n\n\tfor (i = 1; i < cmd->chanlist_len; i++) {\n\t\tunsigned int chan = CR_CHAN(cmd->chanlist[i]);\n\t\tunsigned int range = CR_RANGE(cmd->chanlist[i]);\n\t\tunsigned int aref = CR_AREF(cmd->chanlist[i]);\n\n\t\tif (chan != chan0 + i) {\n\t\t\tdev_dbg(dev->class_dev,\n\t\t\t\t\"chanlist must be consecutive\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (range != range0) {\n\t\t\tdev_dbg(dev->class_dev,\n\t\t\t\t\"chanlist must have the same range\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (aref != aref0) {\n\t\t\tdev_dbg(dev->class_dev,\n\t\t\t\t\"chanlist must have the same reference\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (aref0 == AREF_DIFF && chan > (s->n_chan / 2)) {\n\t\t\tdev_dbg(dev->class_dev,\n\t\t\t\t\"chanlist differential channel too large\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int das6402_ai_cmdtest(struct comedi_device *dev,\n\t\t\t      struct comedi_subdevice *s,\n\t\t\t      struct comedi_cmd *cmd)\n{\n\tint err = 0;\n\tunsigned int arg;\n\n\t \n\n\terr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW);\n\terr |= comedi_check_trigger_src(&cmd->scan_begin_src, TRIG_FOLLOW);\n\terr |= comedi_check_trigger_src(&cmd->convert_src, TRIG_TIMER);\n\terr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\n\terr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\n\n\tif (err)\n\t\treturn 1;\n\n\t \n\n\terr |= comedi_check_trigger_is_unique(cmd->stop_src);\n\n\t \n\n\tif (err)\n\t\treturn 2;\n\n\t \n\n\terr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);\n\terr |= comedi_check_trigger_arg_min(&cmd->convert_arg, 10000);\n\terr |= comedi_check_trigger_arg_min(&cmd->chanlist_len, 1);\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\n\t\t\t\t\t   cmd->chanlist_len);\n\n\tif (cmd->stop_src == TRIG_COUNT)\n\t\terr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\n\telse\t \n\t\terr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\n\n\tif (err)\n\t\treturn 3;\n\n\t \n\n\targ = cmd->convert_arg;\n\tcomedi_8254_cascade_ns_to_timer(dev->pacer, &arg, cmd->flags);\n\terr |= comedi_check_trigger_arg_is(&cmd->convert_arg, arg);\n\n\tif (err)\n\t\treturn 4;\n\n\t \n\tif (cmd->chanlist && cmd->chanlist_len > 0)\n\t\terr |= das6402_ai_check_chanlist(dev, s, cmd);\n\n\tif (err)\n\t\treturn 5;\n\n\treturn 0;\n}\n\nstatic int das6402_ai_cancel(struct comedi_device *dev,\n\t\t\t     struct comedi_subdevice *s)\n{\n\toutb(DAS6402_CTRL_SOFT_TRIG, dev->iobase + DAS6402_CTRL_REG);\n\n\treturn 0;\n}\n\nstatic void das6402_ai_soft_trig(struct comedi_device *dev)\n{\n\toutw(0, dev->iobase + DAS6402_AI_DATA_REG);\n}\n\nstatic int das6402_ai_eoc(struct comedi_device *dev,\n\t\t\t  struct comedi_subdevice *s,\n\t\t\t  struct comedi_insn *insn,\n\t\t\t  unsigned long context)\n{\n\tunsigned int status;\n\n\tstatus = inb(dev->iobase + DAS6402_STATUS_REG);\n\tif (status & DAS6402_STATUS_FFNE)\n\t\treturn 0;\n\treturn -EBUSY;\n}\n\nstatic int das6402_ai_insn_read(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tstruct comedi_insn *insn,\n\t\t\t\tunsigned int *data)\n{\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int aref = CR_AREF(insn->chanspec);\n\tint ret;\n\tint i;\n\n\tif (aref == AREF_DIFF && chan > (s->n_chan / 2))\n\t\treturn -EINVAL;\n\n\t \n\toutb(DAS6402_CTRL_SOFT_TRIG, dev->iobase + DAS6402_CTRL_REG);\n\n\tdas6402_ai_set_mode(dev, s, insn->chanspec, DAS6402_MODE_POLLED);\n\n\t \n\toutw(DAS6402_AI_MUX_HI(chan) | DAS6402_AI_MUX_LO(chan),\n\t     dev->iobase + DAS6402_AI_MUX_REG);\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\tdas6402_ai_clear_eoc(dev);\n\t\tdas6402_ai_soft_trig(dev);\n\n\t\tret = comedi_timeout(dev, s, insn, das6402_ai_eoc, 0);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tdata[i] = das6402_ai_read_sample(dev, s);\n\t}\n\n\tdas6402_ai_clear_eoc(dev);\n\n\treturn insn->n;\n}\n\nstatic int das6402_ao_insn_write(struct comedi_device *dev,\n\t\t\t\t struct comedi_subdevice *s,\n\t\t\t\t struct comedi_insn *insn,\n\t\t\t\t unsigned int *data)\n{\n\tstruct das6402_private *devpriv = dev->private;\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int range = CR_RANGE(insn->chanspec);\n\tunsigned int val;\n\tint i;\n\n\t \n\tval = devpriv->ao_range;\n\tval &= ~DAS6402_AO_RANGE_MASK(chan);\n\tval |= DAS6402_AO_RANGE(chan, range);\n\tif (val != devpriv->ao_range) {\n\t\tdevpriv->ao_range = val;\n\t\toutb(val, dev->iobase + DAS6402_TRIG_REG);\n\t}\n\n\t \n\tfor (i = 0; i < insn->n; i++) {\n\t\tval = data[i];\n\n\t\ts->readback[chan] = val;\n\n\t\tif (s->maxdata == 0x0fff) {\n\t\t\t \n\t\t\tval <<= 4;\n\t\t\toutw(val, dev->iobase + DAS6402_AO_DATA_REG(chan));\n\t\t} else {\n\t\t\t \n\t\t\toutb(val & 0xff,\n\t\t\t     dev->iobase + DAS6402_AO_LSB_REG(chan));\n\t\t\toutb((val >> 8) & 0xff,\n\t\t\t     dev->iobase + DAS6402_AO_LSB_REG(chan));\n\t\t}\n\t}\n\n\treturn insn->n;\n}\n\nstatic int das6402_ao_insn_read(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tstruct comedi_insn *insn,\n\t\t\t\tunsigned int *data)\n{\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\n\t \n\tinw(dev->iobase + DAS6402_AO_LSB_REG(chan));\n\n\treturn comedi_readback_insn_read(dev, s, insn, data);\n}\n\nstatic int das6402_di_insn_bits(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tstruct comedi_insn *insn,\n\t\t\t\tunsigned int *data)\n{\n\tdata[1] = inb(dev->iobase + DAS6402_DI_DO_REG);\n\n\treturn insn->n;\n}\n\nstatic int das6402_do_insn_bits(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tstruct comedi_insn *insn,\n\t\t\t\tunsigned int *data)\n{\n\tif (comedi_dio_update_state(s, data))\n\t\toutb(s->state, dev->iobase + DAS6402_DI_DO_REG);\n\n\tdata[1] = s->state;\n\n\treturn insn->n;\n}\n\nstatic void das6402_reset(struct comedi_device *dev)\n{\n\tstruct das6402_private *devpriv = dev->private;\n\n\t \n\toutb(DAS6402_MODE_ENHANCED, dev->iobase + DAS6402_MODE_REG);\n\n\t \n\tdas6402_set_extended(dev, DAS6402_STATUS_W_10MHZ);\n\n\t \n\toutb(DAS6402_CTRL_SOFT_TRIG, dev->iobase + DAS6402_CTRL_REG);\n\n\t \n\tdas6402_set_mode(dev, DAS6402_MODE_RANGE(0) |\n\t\t\t      DAS6402_MODE_POLLED |\n\t\t\t      DAS6402_MODE_SE |\n\t\t\t      DAS6402_MODE_UNI);\n\n\t \n\toutw(DAS6402_AI_MUX_HI(0) | DAS6402_AI_MUX_LO(0),\n\t     dev->iobase + DAS6402_AI_MUX_REG);\n\n\t \n\tdevpriv->ao_range = DAS6402_AO_RANGE(0, 2) | DAS6402_AO_RANGE(1, 2);\n\toutb(devpriv->ao_range, dev->iobase + DAS6402_TRIG_REG);\n\n\t \n\toutw(0, dev->iobase + DAS6402_AO_DATA_REG(0));\n\toutw(0, dev->iobase + DAS6402_AO_DATA_REG(0));\n\tinw(dev->iobase + DAS6402_AO_LSB_REG(0));\n\n\t \n\toutb(0, dev->iobase + DAS6402_DI_DO_REG);\n\n\tdas6402_clear_all_interrupts(dev);\n}\n\nstatic int das6402_attach(struct comedi_device *dev,\n\t\t\t  struct comedi_devconfig *it)\n{\n\tconst struct das6402_boardinfo *board = dev->board_ptr;\n\tstruct das6402_private *devpriv;\n\tstruct comedi_subdevice *s;\n\tint ret;\n\n\tdevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\n\tif (!devpriv)\n\t\treturn -ENOMEM;\n\n\tret = comedi_request_region(dev, it->options[0], 0x10);\n\tif (ret)\n\t\treturn ret;\n\n\tdas6402_reset(dev);\n\n\t \n\tif ((1 << it->options[1]) & 0x8cec) {\n\t\tret = request_irq(it->options[1], das6402_interrupt, 0,\n\t\t\t\t  dev->board_name, dev);\n\t\tif (ret == 0) {\n\t\t\tdev->irq = it->options[1];\n\n\t\t\tswitch (dev->irq) {\n\t\t\tcase 10:\n\t\t\t\tdevpriv->irq = 4;\n\t\t\t\tbreak;\n\t\t\tcase 11:\n\t\t\t\tdevpriv->irq = 1;\n\t\t\t\tbreak;\n\t\t\tcase 15:\n\t\t\t\tdevpriv->irq = 6;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdevpriv->irq = dev->irq;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tdev->pacer = comedi_8254_init(dev->iobase + DAS6402_TIMER_BASE,\n\t\t\t\t      I8254_OSC_BASE_10MHZ, I8254_IO8, 0);\n\tif (!dev->pacer)\n\t\treturn -ENOMEM;\n\n\tret = comedi_alloc_subdevices(dev, 4);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ts = &dev->subdevices[0];\n\ts->type\t\t= COMEDI_SUBD_AI;\n\ts->subdev_flags\t= SDF_READABLE | SDF_GROUND | SDF_DIFF;\n\ts->n_chan\t= 64;\n\ts->maxdata\t= board->maxdata;\n\ts->range_table\t= &das6402_ai_ranges;\n\ts->insn_read\t= das6402_ai_insn_read;\n\tif (dev->irq) {\n\t\tdev->read_subdev = s;\n\t\ts->subdev_flags\t|= SDF_CMD_READ;\n\t\ts->len_chanlist\t= s->n_chan;\n\t\ts->do_cmdtest\t= das6402_ai_cmdtest;\n\t\ts->do_cmd\t= das6402_ai_cmd;\n\t\ts->cancel\t= das6402_ai_cancel;\n\t}\n\n\t \n\ts = &dev->subdevices[1];\n\ts->type\t\t= COMEDI_SUBD_AO;\n\ts->subdev_flags\t= SDF_WRITABLE;\n\ts->n_chan\t= 2;\n\ts->maxdata\t= board->maxdata;\n\ts->range_table\t= &das6402_ao_ranges;\n\ts->insn_write\t= das6402_ao_insn_write;\n\ts->insn_read\t= das6402_ao_insn_read;\n\n\tret = comedi_alloc_subdev_readback(s);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ts = &dev->subdevices[2];\n\ts->type\t\t= COMEDI_SUBD_DI;\n\ts->subdev_flags\t= SDF_READABLE;\n\ts->n_chan\t= 8;\n\ts->maxdata\t= 1;\n\ts->range_table\t= &range_digital;\n\ts->insn_bits\t= das6402_di_insn_bits;\n\n\t \n\ts = &dev->subdevices[3];\n\ts->type\t\t= COMEDI_SUBD_DO;\n\ts->subdev_flags\t= SDF_WRITABLE;\n\ts->n_chan\t= 8;\n\ts->maxdata\t= 1;\n\ts->range_table\t= &range_digital;\n\ts->insn_bits\t= das6402_do_insn_bits;\n\n\treturn 0;\n}\n\nstatic struct comedi_driver das6402_driver = {\n\t.driver_name\t= \"das6402\",\n\t.module\t\t= THIS_MODULE,\n\t.attach\t\t= das6402_attach,\n\t.detach\t\t= comedi_legacy_detach,\n\t.board_name\t= &das6402_boards[0].name,\n\t.num_names\t= ARRAY_SIZE(das6402_boards),\n\t.offset\t\t= sizeof(struct das6402_boardinfo),\n};\nmodule_comedi_driver(das6402_driver)\n\nMODULE_AUTHOR(\"H Hartley Sweeten <hsweeten@visionengravers.com>\");\nMODULE_DESCRIPTION(\"Comedi driver for DAS6402 compatible boards\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}