{
  "module_name": "quatech_daqp_cs.c",
  "hash_id": "8ae6f3c1d22296f562cbe4b16679b9e9f792532e24276ae244909bad52893331",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/quatech_daqp_cs.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/comedi/comedi_pcmcia.h>\n\n \n#define DAQP_AI_FIFO_REG\t\t0x00\n\n#define DAQP_SCANLIST_REG\t\t0x01\n#define DAQP_SCANLIST_DIFFERENTIAL\tBIT(14)\n#define DAQP_SCANLIST_GAIN(x)\t\t(((x) & 0x3) << 12)\n#define DAQP_SCANLIST_CHANNEL(x)\t(((x) & 0xf) << 8)\n#define DAQP_SCANLIST_START\t\tBIT(7)\n#define DAQP_SCANLIST_EXT_GAIN(x)\t(((x) & 0x3) << 4)\n#define DAQP_SCANLIST_EXT_CHANNEL(x)\t(((x) & 0xf) << 0)\n\n#define DAQP_CTRL_REG\t\t\t0x02\n#define DAQP_CTRL_PACER_CLK(x)\t\t(((x) & 0x3) << 6)\n#define DAQP_CTRL_PACER_CLK_EXT\t\tDAQP_CTRL_PACER_CLK(0)\n#define DAQP_CTRL_PACER_CLK_5MHZ\tDAQP_CTRL_PACER_CLK(1)\n#define DAQP_CTRL_PACER_CLK_1MHZ\tDAQP_CTRL_PACER_CLK(2)\n#define DAQP_CTRL_PACER_CLK_100KHZ\tDAQP_CTRL_PACER_CLK(3)\n#define DAQP_CTRL_EXPANSION\t\tBIT(5)\n#define DAQP_CTRL_EOS_INT_ENA\t\tBIT(4)\n#define DAQP_CTRL_FIFO_INT_ENA\t\tBIT(3)\n#define DAQP_CTRL_TRIG_MODE\t\tBIT(2)\t \n#define DAQP_CTRL_TRIG_SRC\t\tBIT(1)\t \n#define DAQP_CTRL_TRIG_EDGE\t\tBIT(0)\t \n\n#define DAQP_STATUS_REG\t\t\t0x02\n#define DAQP_STATUS_IDLE\t\tBIT(7)\n#define DAQP_STATUS_RUNNING\t\tBIT(6)\n#define DAQP_STATUS_DATA_LOST\t\tBIT(5)\n#define DAQP_STATUS_END_OF_SCAN\t\tBIT(4)\n#define DAQP_STATUS_FIFO_THRESHOLD\tBIT(3)\n#define DAQP_STATUS_FIFO_FULL\t\tBIT(2)\n#define DAQP_STATUS_FIFO_NEARFULL\tBIT(1)\n#define DAQP_STATUS_FIFO_EMPTY\t\tBIT(0)\n \n#define DAQP_STATUS_EVENTS\t\t(DAQP_STATUS_DATA_LOST |\t\\\n\t\t\t\t\t DAQP_STATUS_END_OF_SCAN |\t\\\n\t\t\t\t\t DAQP_STATUS_FIFO_THRESHOLD)\n\n#define DAQP_DI_REG\t\t\t0x03\n#define DAQP_DO_REG\t\t\t0x03\n\n#define DAQP_PACER_LOW_REG\t\t0x04\n#define DAQP_PACER_MID_REG\t\t0x05\n#define DAQP_PACER_HIGH_REG\t\t0x06\n\n#define DAQP_CMD_REG\t\t\t0x07\n \n#define DAQP_CMD_ARM\t\t\tBIT(7)\t \n#define DAQP_CMD_RSTF\t\t\tBIT(6)\t \n#define DAQP_CMD_RSTQ\t\t\tBIT(5)\t \n#define DAQP_CMD_STOP\t\t\tBIT(4)\t \n#define DAQP_CMD_LATCH\t\t\tBIT(3)\t \n#define DAQP_CMD_SCANRATE(x)\t\t(((x) & 0x3) << 1)\n#define DAQP_CMD_SCANRATE_100KHZ\tDAQP_CMD_SCANRATE(0)\n#define DAQP_CMD_SCANRATE_50KHZ\t\tDAQP_CMD_SCANRATE(1)\n#define DAQP_CMD_SCANRATE_25KHZ\t\tDAQP_CMD_SCANRATE(2)\n#define DAQP_CMD_FIFO_DATA\t\tBIT(0)\n\n#define DAQP_AO_REG\t\t\t0x08\t \n\n#define DAQP_TIMER_REG\t\t\t0x0a\t \n\n#define DAQP_AUX_REG\t\t\t0x0f\n \n#define DAQP_AUX_EXT_ANALOG_TRIG\tBIT(7)\n#define DAQP_AUX_PRETRIG\t\tBIT(6)\n#define DAQP_AUX_TIMER_INT_ENA\t\tBIT(5)\n#define DAQP_AUX_TIMER_MODE(x)\t\t(((x) & 0x3) << 3)\n#define DAQP_AUX_TIMER_MODE_RELOAD\tDAQP_AUX_TIMER_MODE(0)\n#define DAQP_AUX_TIMER_MODE_PAUSE\tDAQP_AUX_TIMER_MODE(1)\n#define DAQP_AUX_TIMER_MODE_GO\t\tDAQP_AUX_TIMER_MODE(2)\n#define DAQP_AUX_TIMER_MODE_EXT\t\tDAQP_AUX_TIMER_MODE(3)\n#define DAQP_AUX_TIMER_CLK_SRC_EXT\tBIT(2)\n#define DAQP_AUX_DA_UPDATE(x)\t\t(((x) & 0x3) << 0)\n#define DAQP_AUX_DA_UPDATE_DIRECT\tDAQP_AUX_DA_UPDATE(0)\n#define DAQP_AUX_DA_UPDATE_OVERFLOW\tDAQP_AUX_DA_UPDATE(1)\n#define DAQP_AUX_DA_UPDATE_EXTERNAL\tDAQP_AUX_DA_UPDATE(2)\n#define DAQP_AUX_DA_UPDATE_PACER\tDAQP_AUX_DA_UPDATE(3)\n \n#define DAQP_AUX_RUNNING\t\tBIT(7)\n#define DAQP_AUX_TRIGGERED\t\tBIT(6)\n#define DAQP_AUX_DA_BUFFER\t\tBIT(5)\n#define DAQP_AUX_TIMER_OVERFLOW\t\tBIT(4)\n#define DAQP_AUX_CONVERSION\t\tBIT(3)\n#define DAQP_AUX_DATA_LOST\t\tBIT(2)\n#define DAQP_AUX_FIFO_NEARFULL\t\tBIT(1)\n#define DAQP_AUX_FIFO_EMPTY\t\tBIT(0)\n\n#define DAQP_FIFO_SIZE\t\t\t4096\n\n#define DAQP_MAX_TIMER_SPEED\t\t10000\t \n\nstruct daqp_private {\n\tunsigned int pacer_div;\n\tint stop;\n};\n\nstatic const struct comedi_lrange range_daqp_ai = {\n\t4, {\n\t\tBIP_RANGE(10),\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(2.5),\n\t\tBIP_RANGE(1.25)\n\t}\n};\n\nstatic int daqp_clear_events(struct comedi_device *dev, int loops)\n{\n\tunsigned int status;\n\n\t \n\twhile (--loops) {\n\t\tstatus = inb(dev->iobase + DAQP_STATUS_REG);\n\t\tif ((status & DAQP_STATUS_EVENTS) == 0)\n\t\t\treturn 0;\n\t}\n\tdev_err(dev->class_dev, \"couldn't clear events in status register\\n\");\n\treturn -EBUSY;\n}\n\nstatic int daqp_ai_cancel(struct comedi_device *dev,\n\t\t\t  struct comedi_subdevice *s)\n{\n\tstruct daqp_private *devpriv = dev->private;\n\n\tif (devpriv->stop)\n\t\treturn -EIO;\n\n\t \n\toutb(DAQP_CMD_STOP, dev->iobase + DAQP_CMD_REG);\n\toutb(0, dev->iobase + DAQP_CTRL_REG);\n\tinb(dev->iobase + DAQP_STATUS_REG);\n\n\treturn 0;\n}\n\nstatic unsigned int daqp_ai_get_sample(struct comedi_device *dev,\n\t\t\t\t       struct comedi_subdevice *s)\n{\n\tunsigned int val;\n\n\t \n\tval = inb(dev->iobase + DAQP_AI_FIFO_REG);\n\tval |= inb(dev->iobase + DAQP_AI_FIFO_REG) << 8;\n\treturn comedi_offset_munge(s, val);\n}\n\nstatic irqreturn_t daqp_interrupt(int irq, void *dev_id)\n{\n\tstruct comedi_device *dev = dev_id;\n\tstruct comedi_subdevice *s = dev->read_subdev;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tint loop_limit = 10000;\n\tint status;\n\n\tif (!dev->attached)\n\t\treturn IRQ_NONE;\n\n\tstatus = inb(dev->iobase + DAQP_STATUS_REG);\n\tif (!(status & DAQP_STATUS_EVENTS))\n\t\treturn IRQ_NONE;\n\n\twhile (!(status & DAQP_STATUS_FIFO_EMPTY)) {\n\t\tunsigned short data;\n\n\t\tif (status & DAQP_STATUS_DATA_LOST) {\n\t\t\ts->async->events |= COMEDI_CB_OVERFLOW;\n\t\t\tdev_warn(dev->class_dev, \"data lost\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tdata = daqp_ai_get_sample(dev, s);\n\t\tcomedi_buf_write_samples(s, &data, 1);\n\n\t\tif (cmd->stop_src == TRIG_COUNT &&\n\t\t    s->async->scans_done >= cmd->stop_arg) {\n\t\t\ts->async->events |= COMEDI_CB_EOA;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((loop_limit--) <= 0)\n\t\t\tbreak;\n\n\t\tstatus = inb(dev->iobase + DAQP_STATUS_REG);\n\t}\n\n\tif (loop_limit <= 0) {\n\t\tdev_warn(dev->class_dev,\n\t\t\t \"loop_limit reached in %s()\\n\", __func__);\n\t\ts->async->events |= COMEDI_CB_ERROR;\n\t}\n\n\tcomedi_handle_events(dev, s);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void daqp_ai_set_one_scanlist_entry(struct comedi_device *dev,\n\t\t\t\t\t   unsigned int chanspec,\n\t\t\t\t\t   int start)\n{\n\tunsigned int chan = CR_CHAN(chanspec);\n\tunsigned int range = CR_RANGE(chanspec);\n\tunsigned int aref = CR_AREF(chanspec);\n\tunsigned int val;\n\n\tval = DAQP_SCANLIST_CHANNEL(chan) | DAQP_SCANLIST_GAIN(range);\n\n\tif (aref == AREF_DIFF)\n\t\tval |= DAQP_SCANLIST_DIFFERENTIAL;\n\n\tif (start)\n\t\tval |= DAQP_SCANLIST_START;\n\n\toutb(val & 0xff, dev->iobase + DAQP_SCANLIST_REG);\n\toutb((val >> 8) & 0xff, dev->iobase + DAQP_SCANLIST_REG);\n}\n\nstatic int daqp_ai_eos(struct comedi_device *dev,\n\t\t       struct comedi_subdevice *s,\n\t\t       struct comedi_insn *insn,\n\t\t       unsigned long context)\n{\n\tunsigned int status;\n\n\tstatus = inb(dev->iobase + DAQP_AUX_REG);\n\tif (status & DAQP_AUX_CONVERSION)\n\t\treturn 0;\n\treturn -EBUSY;\n}\n\nstatic int daqp_ai_insn_read(struct comedi_device *dev,\n\t\t\t     struct comedi_subdevice *s,\n\t\t\t     struct comedi_insn *insn,\n\t\t\t     unsigned int *data)\n{\n\tstruct daqp_private *devpriv = dev->private;\n\tint ret = 0;\n\tint i;\n\n\tif (devpriv->stop)\n\t\treturn -EIO;\n\n\toutb(0, dev->iobase + DAQP_AUX_REG);\n\n\t \n\toutb(DAQP_CMD_RSTQ, dev->iobase + DAQP_CMD_REG);\n\n\t \n\tdaqp_ai_set_one_scanlist_entry(dev, insn->chanspec, 1);\n\n\t \n\toutb(DAQP_CMD_RSTF, dev->iobase + DAQP_CMD_REG);\n\n\t \n\toutb(DAQP_CTRL_PACER_CLK_100KHZ, dev->iobase + DAQP_CTRL_REG);\n\n\tret = daqp_clear_events(dev, 10000);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\t \n\t\toutb(DAQP_CMD_ARM | DAQP_CMD_FIFO_DATA,\n\t\t     dev->iobase + DAQP_CMD_REG);\n\n\t\tret = comedi_timeout(dev, s, insn, daqp_ai_eos, 0);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\t \n\t\tinb(dev->iobase + DAQP_STATUS_REG);\n\n\t\tdata[i] = daqp_ai_get_sample(dev, s);\n\t}\n\n\t \n\toutb(DAQP_CMD_STOP, dev->iobase + DAQP_CMD_REG);\n\tinb(dev->iobase + DAQP_STATUS_REG);\n\n\treturn ret ? ret : insn->n;\n}\n\n \n\nstatic int daqp_ns_to_timer(unsigned int *ns, unsigned int flags)\n{\n\tint timer;\n\n\ttimer = *ns / 200;\n\t*ns = timer * 200;\n\n\treturn timer;\n}\n\nstatic void daqp_set_pacer(struct comedi_device *dev, unsigned int val)\n{\n\toutb(val & 0xff, dev->iobase + DAQP_PACER_LOW_REG);\n\toutb((val >> 8) & 0xff, dev->iobase + DAQP_PACER_MID_REG);\n\toutb((val >> 16) & 0xff, dev->iobase + DAQP_PACER_HIGH_REG);\n}\n\nstatic int daqp_ai_cmdtest(struct comedi_device *dev,\n\t\t\t   struct comedi_subdevice *s,\n\t\t\t   struct comedi_cmd *cmd)\n{\n\tstruct daqp_private *devpriv = dev->private;\n\tint err = 0;\n\tunsigned int arg;\n\n\t \n\n\terr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW);\n\terr |= comedi_check_trigger_src(&cmd->scan_begin_src,\n\t\t\t\t\tTRIG_TIMER | TRIG_FOLLOW);\n\terr |= comedi_check_trigger_src(&cmd->convert_src,\n\t\t\t\t\tTRIG_TIMER | TRIG_NOW);\n\terr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\n\terr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\n\n\tif (err)\n\t\treturn 1;\n\n\t \n\n\terr |= comedi_check_trigger_is_unique(cmd->scan_begin_src);\n\terr |= comedi_check_trigger_is_unique(cmd->convert_src);\n\terr |= comedi_check_trigger_is_unique(cmd->stop_src);\n\n\t \n\n\t \n\tif (cmd->scan_begin_src != TRIG_TIMER && cmd->convert_src != TRIG_TIMER)\n\t\terr |= -EINVAL;\n\n\tif (err)\n\t\treturn 2;\n\n\t \n\n\terr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\n\n\terr |= comedi_check_trigger_arg_min(&cmd->chanlist_len, 1);\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\n\t\t\t\t\t   cmd->chanlist_len);\n\n\tif (cmd->scan_begin_src == TRIG_TIMER)\n\t\terr |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,\n\t\t\t\t\t\t    DAQP_MAX_TIMER_SPEED);\n\n\tif (cmd->convert_src == TRIG_TIMER) {\n\t\terr |= comedi_check_trigger_arg_min(&cmd->convert_arg,\n\t\t\t\t\t\t    DAQP_MAX_TIMER_SPEED);\n\n\t\tif (cmd->scan_begin_src == TRIG_TIMER) {\n\t\t\t \n\t\t\targ = cmd->convert_arg * cmd->scan_end_arg;\n\t\t\terr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg,\n\t\t\t\t\t\t\t   arg);\n\t\t}\n\t}\n\n\tif (cmd->stop_src == TRIG_COUNT)\n\t\terr |= comedi_check_trigger_arg_max(&cmd->stop_arg, 0x00ffffff);\n\telse\t \n\t\terr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\n\n\tif (err)\n\t\treturn 3;\n\n\t \n\n\tif (cmd->convert_src == TRIG_TIMER) {\n\t\targ = cmd->convert_arg;\n\t\tdevpriv->pacer_div = daqp_ns_to_timer(&arg, cmd->flags);\n\t\terr |= comedi_check_trigger_arg_is(&cmd->convert_arg, arg);\n\t} else if (cmd->scan_begin_src == TRIG_TIMER) {\n\t\targ = cmd->scan_begin_arg;\n\t\tdevpriv->pacer_div = daqp_ns_to_timer(&arg, cmd->flags);\n\t\terr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, arg);\n\t}\n\n\tif (err)\n\t\treturn 4;\n\n\treturn 0;\n}\n\nstatic int daqp_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\n{\n\tstruct daqp_private *devpriv = dev->private;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tint scanlist_start_on_every_entry;\n\tint threshold;\n\tint ret;\n\tint i;\n\n\tif (devpriv->stop)\n\t\treturn -EIO;\n\n\toutb(0, dev->iobase + DAQP_AUX_REG);\n\n\t \n\toutb(DAQP_CMD_RSTQ, dev->iobase + DAQP_CMD_REG);\n\n\t \n\tdaqp_set_pacer(dev, devpriv->pacer_div);\n\n\tif (cmd->convert_src == TRIG_TIMER)\n\t\tscanlist_start_on_every_entry = 1;\n\telse\n\t\tscanlist_start_on_every_entry = 0;\n\n\t \n\tfor (i = 0; i < cmd->chanlist_len; i++) {\n\t\tint start = (i == 0 || scanlist_start_on_every_entry);\n\n\t\tdaqp_ai_set_one_scanlist_entry(dev, cmd->chanlist[i], start);\n\t}\n\n\t \n\n\t \n\n\tif (cmd->stop_src == TRIG_COUNT) {\n\t\tunsigned long long nsamples;\n\t\tunsigned long long nbytes;\n\n\t\tnsamples = (unsigned long long)cmd->stop_arg *\n\t\t\t   cmd->scan_end_arg;\n\t\tnbytes = nsamples * comedi_bytes_per_sample(s);\n\t\twhile (nbytes > DAQP_FIFO_SIZE * 3 / 4)\n\t\t\tnbytes /= 2;\n\t\tthreshold = nbytes;\n\t} else {\n\t\tthreshold = DAQP_FIFO_SIZE / 2;\n\t}\n\n\t \n\n\toutb(DAQP_CMD_RSTF, dev->iobase + DAQP_CMD_REG);\n\n\t \n\n\toutb(0x00, dev->iobase + DAQP_AI_FIFO_REG);\n\toutb(0x00, dev->iobase + DAQP_AI_FIFO_REG);\n\n\toutb((DAQP_FIFO_SIZE - threshold) & 0xff,\n\t     dev->iobase + DAQP_AI_FIFO_REG);\n\toutb((DAQP_FIFO_SIZE - threshold) >> 8, dev->iobase + DAQP_AI_FIFO_REG);\n\n\t \n\toutb(DAQP_CTRL_TRIG_MODE | DAQP_CTRL_PACER_CLK_5MHZ |\n\t     DAQP_CTRL_FIFO_INT_ENA, dev->iobase + DAQP_CTRL_REG);\n\n\tret = daqp_clear_events(dev, 100);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\toutb(DAQP_CMD_ARM | DAQP_CMD_FIFO_DATA, dev->iobase + DAQP_CMD_REG);\n\n\treturn 0;\n}\n\nstatic int daqp_ao_empty(struct comedi_device *dev,\n\t\t\t struct comedi_subdevice *s,\n\t\t\t struct comedi_insn *insn,\n\t\t\t unsigned long context)\n{\n\tunsigned int status;\n\n\tstatus = inb(dev->iobase + DAQP_AUX_REG);\n\tif ((status & DAQP_AUX_DA_BUFFER) == 0)\n\t\treturn 0;\n\treturn -EBUSY;\n}\n\nstatic int daqp_ao_insn_write(struct comedi_device *dev,\n\t\t\t      struct comedi_subdevice *s,\n\t\t\t      struct comedi_insn *insn,\n\t\t\t      unsigned int *data)\n{\n\tstruct daqp_private *devpriv = dev->private;\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tint i;\n\n\tif (devpriv->stop)\n\t\treturn -EIO;\n\n\t \n\toutb(0, dev->iobase + DAQP_AUX_REG);\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\tunsigned int val = data[i];\n\t\tint ret;\n\n\t\t \n\t\tret = comedi_timeout(dev, s, insn, daqp_ao_empty, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\toutw((chan << 12) | comedi_offset_munge(s, val),\n\t\t     dev->iobase + DAQP_AO_REG);\n\n\t\ts->readback[chan] = val;\n\t}\n\n\treturn insn->n;\n}\n\nstatic int daqp_di_insn_bits(struct comedi_device *dev,\n\t\t\t     struct comedi_subdevice *s,\n\t\t\t     struct comedi_insn *insn,\n\t\t\t     unsigned int *data)\n{\n\tstruct daqp_private *devpriv = dev->private;\n\n\tif (devpriv->stop)\n\t\treturn -EIO;\n\n\tdata[0] = inb(dev->iobase + DAQP_DI_REG);\n\n\treturn insn->n;\n}\n\nstatic int daqp_do_insn_bits(struct comedi_device *dev,\n\t\t\t     struct comedi_subdevice *s,\n\t\t\t     struct comedi_insn *insn,\n\t\t\t     unsigned int *data)\n{\n\tstruct daqp_private *devpriv = dev->private;\n\n\tif (devpriv->stop)\n\t\treturn -EIO;\n\n\tif (comedi_dio_update_state(s, data))\n\t\toutb(s->state, dev->iobase + DAQP_DO_REG);\n\n\tdata[1] = s->state;\n\n\treturn insn->n;\n}\n\nstatic int daqp_auto_attach(struct comedi_device *dev,\n\t\t\t    unsigned long context)\n{\n\tstruct pcmcia_device *link = comedi_to_pcmcia_dev(dev);\n\tstruct daqp_private *devpriv;\n\tstruct comedi_subdevice *s;\n\tint ret;\n\n\tdevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\n\tif (!devpriv)\n\t\treturn -ENOMEM;\n\n\tlink->config_flags |= CONF_AUTO_SET_IO | CONF_ENABLE_IRQ;\n\tret = comedi_pcmcia_enable(dev, NULL);\n\tif (ret)\n\t\treturn ret;\n\tdev->iobase = link->resource[0]->start;\n\n\tlink->priv = dev;\n\tret = pcmcia_request_irq(link, daqp_interrupt);\n\tif (ret == 0)\n\t\tdev->irq = link->irq;\n\n\tret = comedi_alloc_subdevices(dev, 4);\n\tif (ret)\n\t\treturn ret;\n\n\ts = &dev->subdevices[0];\n\ts->type\t\t= COMEDI_SUBD_AI;\n\ts->subdev_flags\t= SDF_READABLE | SDF_GROUND | SDF_DIFF;\n\ts->n_chan\t= 8;\n\ts->maxdata\t= 0xffff;\n\ts->range_table\t= &range_daqp_ai;\n\ts->insn_read\t= daqp_ai_insn_read;\n\tif (dev->irq) {\n\t\tdev->read_subdev = s;\n\t\ts->subdev_flags\t|= SDF_CMD_READ;\n\t\ts->len_chanlist\t= 2048;\n\t\ts->do_cmdtest\t= daqp_ai_cmdtest;\n\t\ts->do_cmd\t= daqp_ai_cmd;\n\t\ts->cancel\t= daqp_ai_cancel;\n\t}\n\n\ts = &dev->subdevices[1];\n\ts->type\t\t= COMEDI_SUBD_AO;\n\ts->subdev_flags\t= SDF_WRITABLE;\n\ts->n_chan\t= 2;\n\ts->maxdata\t= 0x0fff;\n\ts->range_table\t= &range_bipolar5;\n\ts->insn_write\t= daqp_ao_insn_write;\n\n\tret = comedi_alloc_subdev_readback(s);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ts = &dev->subdevices[2];\n\ts->type\t\t= COMEDI_SUBD_DI;\n\ts->subdev_flags\t= SDF_READABLE;\n\ts->n_chan\t= 4;\n\ts->maxdata\t= 1;\n\ts->insn_bits\t= daqp_di_insn_bits;\n\n\t \n\ts = &dev->subdevices[3];\n\ts->type\t\t= COMEDI_SUBD_DO;\n\ts->subdev_flags\t= SDF_WRITABLE;\n\ts->n_chan\t= 4;\n\ts->maxdata\t= 1;\n\ts->insn_bits\t= daqp_do_insn_bits;\n\n\treturn 0;\n}\n\nstatic struct comedi_driver driver_daqp = {\n\t.driver_name\t= \"quatech_daqp_cs\",\n\t.module\t\t= THIS_MODULE,\n\t.auto_attach\t= daqp_auto_attach,\n\t.detach\t\t= comedi_pcmcia_disable,\n};\n\nstatic int daqp_cs_suspend(struct pcmcia_device *link)\n{\n\tstruct comedi_device *dev = link->priv;\n\tstruct daqp_private *devpriv = dev ? dev->private : NULL;\n\n\t \n\tif (devpriv)\n\t\tdevpriv->stop = 1;\n\n\treturn 0;\n}\n\nstatic int daqp_cs_resume(struct pcmcia_device *link)\n{\n\tstruct comedi_device *dev = link->priv;\n\tstruct daqp_private *devpriv = dev ? dev->private : NULL;\n\n\tif (devpriv)\n\t\tdevpriv->stop = 0;\n\n\treturn 0;\n}\n\nstatic int daqp_cs_attach(struct pcmcia_device *link)\n{\n\treturn comedi_pcmcia_auto_config(link, &driver_daqp);\n}\n\nstatic const struct pcmcia_device_id daqp_cs_id_table[] = {\n\tPCMCIA_DEVICE_MANF_CARD(0x0137, 0x0027),\n\tPCMCIA_DEVICE_NULL\n};\nMODULE_DEVICE_TABLE(pcmcia, daqp_cs_id_table);\n\nstatic struct pcmcia_driver daqp_cs_driver = {\n\t.name\t\t= \"quatech_daqp_cs\",\n\t.owner\t\t= THIS_MODULE,\n\t.id_table\t= daqp_cs_id_table,\n\t.probe\t\t= daqp_cs_attach,\n\t.remove\t\t= comedi_pcmcia_auto_unconfig,\n\t.suspend\t= daqp_cs_suspend,\n\t.resume\t\t= daqp_cs_resume,\n};\nmodule_comedi_pcmcia_driver(driver_daqp, daqp_cs_driver);\n\nMODULE_DESCRIPTION(\"Comedi driver for Quatech DAQP PCMCIA data capture cards\");\nMODULE_AUTHOR(\"Brent Baccala <baccala@freesoft.org>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}