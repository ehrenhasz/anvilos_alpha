{
  "module_name": "mite.c",
  "hash_id": "fee14b9330c9f9394f8f72d71a485b55940c20dbd2ad2dca5f4d552753263b84",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/mite.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/log2.h>\n#include <linux/comedi/comedi_pci.h>\n\n#include \"mite.h\"\n\n \n#define MITE_UNKNOWN_DMA_BURST_REG\t0x28\n#define UNKNOWN_DMA_BURST_ENABLE_BITS\t0x600\n\n#define MITE_PCI_CONFIG_OFFSET\t0x300\n#define MITE_CSIGR\t\t0x460\t\t\t \n#define CSIGR_TO_IOWINS(x)\t(((x) >> 29) & 0x7)\n#define CSIGR_TO_WINS(x)\t(((x) >> 24) & 0x1f)\n#define CSIGR_TO_WPDEP(x)\t(((x) >> 20) & 0x7)\n#define CSIGR_TO_DMAC(x)\t(((x) >> 16) & 0xf)\n#define CSIGR_TO_IMODE(x)\t(((x) >> 12) & 0x3)\t \n#define CSIGR_TO_MMODE(x)\t(((x) >> 8) & 0x3)\t \n#define CSIGR_TO_TYPE(x)\t(((x) >> 4) & 0xf)\t \n#define CSIGR_TO_VER(x)\t\t(((x) >> 0) & 0xf)\n\n#define MITE_CHAN(x)\t\t(0x500 + 0x100 * (x))\n#define MITE_CHOR(x)\t\t(0x00 + MITE_CHAN(x))\t \n#define CHOR_DMARESET\t\tBIT(31)\n#define CHOR_SET_SEND_TC\tBIT(11)\n#define CHOR_CLR_SEND_TC\tBIT(10)\n#define CHOR_SET_LPAUSE\t\tBIT(9)\n#define CHOR_CLR_LPAUSE\t\tBIT(8)\n#define CHOR_CLRDONE\t\tBIT(7)\n#define CHOR_CLRRB\t\tBIT(6)\n#define CHOR_CLRLC\t\tBIT(5)\n#define CHOR_FRESET\t\tBIT(4)\n#define CHOR_ABORT\t\tBIT(3)\t \n#define CHOR_STOP\t\tBIT(2)\t \n#define CHOR_CONT\t\tBIT(1)\n#define CHOR_START\t\tBIT(0)\n#define MITE_CHCR(x)\t\t(0x04 + MITE_CHAN(x))\t \n#define CHCR_SET_DMA_IE\t\tBIT(31)\n#define CHCR_CLR_DMA_IE\t\tBIT(30)\n#define CHCR_SET_LINKP_IE\tBIT(29)\n#define CHCR_CLR_LINKP_IE\tBIT(28)\n#define CHCR_SET_SAR_IE\t\tBIT(27)\n#define CHCR_CLR_SAR_IE\t\tBIT(26)\n#define CHCR_SET_DONE_IE\tBIT(25)\n#define CHCR_CLR_DONE_IE\tBIT(24)\n#define CHCR_SET_MRDY_IE\tBIT(23)\n#define CHCR_CLR_MRDY_IE\tBIT(22)\n#define CHCR_SET_DRDY_IE\tBIT(21)\n#define CHCR_CLR_DRDY_IE\tBIT(20)\n#define CHCR_SET_LC_IE\t\tBIT(19)\n#define CHCR_CLR_LC_IE\t\tBIT(18)\n#define CHCR_SET_CONT_RB_IE\tBIT(17)\n#define CHCR_CLR_CONT_RB_IE\tBIT(16)\n#define CHCR_FIFO(x)\t\t(((x) & 0x1) << 15)\n#define CHCR_FIFODIS\t\tCHCR_FIFO(1)\n#define CHCR_FIFO_ON\t\tCHCR_FIFO(0)\n#define CHCR_BURST(x)\t\t(((x) & 0x1) << 14)\n#define CHCR_BURSTEN\t\tCHCR_BURST(1)\n#define CHCR_NO_BURSTEN\t\tCHCR_BURST(0)\n#define CHCR_BYTE_SWAP_DEVICE\tBIT(6)\n#define CHCR_BYTE_SWAP_MEMORY\tBIT(4)\n#define CHCR_DIR(x)\t\t(((x) & 0x1) << 3)\n#define CHCR_DEV_TO_MEM\t\tCHCR_DIR(1)\n#define CHCR_MEM_TO_DEV\t\tCHCR_DIR(0)\n#define CHCR_MODE(x)\t\t(((x) & 0x7) << 0)\n#define CHCR_NORMAL\t\tCHCR_MODE(0)\n#define CHCR_CONTINUE\t\tCHCR_MODE(1)\n#define CHCR_RINGBUFF\t\tCHCR_MODE(2)\n#define CHCR_LINKSHORT\t\tCHCR_MODE(4)\n#define CHCR_LINKLONG\t\tCHCR_MODE(5)\n#define MITE_TCR(x)\t\t(0x08 + MITE_CHAN(x))\t \n#define MITE_MCR(x)\t\t(0x0c + MITE_CHAN(x))\t \n#define MITE_MAR(x)\t\t(0x10 + MITE_CHAN(x))\t \n#define MITE_DCR(x)\t\t(0x14 + MITE_CHAN(x))\t \n#define DCR_NORMAL\t\tBIT(29)\n#define MITE_DAR(x)\t\t(0x18 + MITE_CHAN(x))\t \n#define MITE_LKCR(x)\t\t(0x1c + MITE_CHAN(x))\t \n#define MITE_LKAR(x)\t\t(0x20 + MITE_CHAN(x))\t \n#define MITE_LLKAR(x)\t\t(0x24 + MITE_CHAN(x))\t \n#define MITE_BAR(x)\t\t(0x28 + MITE_CHAN(x))\t \n#define MITE_BCR(x)\t\t(0x2c + MITE_CHAN(x))\t \n#define MITE_SAR(x)\t\t(0x30 + MITE_CHAN(x))\t \n#define MITE_WSCR(x)\t\t(0x34 + MITE_CHAN(x))\t \n#define MITE_WSER(x)\t\t(0x38 + MITE_CHAN(x))\t \n#define MITE_CHSR(x)\t\t(0x3c + MITE_CHAN(x))\t \n#define CHSR_INT\t\tBIT(31)\n#define CHSR_LPAUSES\t\tBIT(29)\n#define CHSR_SARS\t\tBIT(27)\n#define CHSR_DONE\t\tBIT(25)\n#define CHSR_MRDY\t\tBIT(23)\n#define CHSR_DRDY\t\tBIT(21)\n#define CHSR_LINKC\t\tBIT(19)\n#define CHSR_CONTS_RB\t\tBIT(17)\n#define CHSR_ERROR\t\tBIT(15)\n#define CHSR_SABORT\t\tBIT(14)\n#define CHSR_HABORT\t\tBIT(13)\n#define CHSR_STOPS\t\tBIT(12)\n#define CHSR_OPERR(x)\t\t(((x) & 0x3) << 10)\n#define CHSR_OPERR_MASK\t\tCHSR_OPERR(3)\n#define CHSR_OPERR_NOERROR\tCHSR_OPERR(0)\n#define CHSR_OPERR_FIFOERROR\tCHSR_OPERR(1)\n#define CHSR_OPERR_LINKERROR\tCHSR_OPERR(1)\t \n#define CHSR_XFERR\t\tBIT(9)\n#define CHSR_END\t\tBIT(8)\n#define CHSR_DRQ1\t\tBIT(7)\n#define CHSR_DRQ0\t\tBIT(6)\n#define CHSR_LERR(x)\t\t(((x) & 0x3) << 4)\n#define CHSR_LERR_MASK\t\tCHSR_LERR(3)\n#define CHSR_LBERR\t\tCHSR_LERR(1)\n#define CHSR_LRERR\t\tCHSR_LERR(2)\n#define CHSR_LOERR\t\tCHSR_LERR(3)\n#define CHSR_MERR(x)\t\t(((x) & 0x3) << 2)\n#define CHSR_MERR_MASK\t\tCHSR_MERR(3)\n#define CHSR_MBERR\t\tCHSR_MERR(1)\n#define CHSR_MRERR\t\tCHSR_MERR(2)\n#define CHSR_MOERR\t\tCHSR_MERR(3)\n#define CHSR_DERR(x)\t\t(((x) & 0x3) << 0)\n#define CHSR_DERR_MASK\t\tCHSR_DERR(3)\n#define CHSR_DBERR\t\tCHSR_DERR(1)\n#define CHSR_DRERR\t\tCHSR_DERR(2)\n#define CHSR_DOERR\t\tCHSR_DERR(3)\n#define MITE_FCR(x)\t\t(0x40 + MITE_CHAN(x))\t \n\n \n#define CR_RL(x)\t\t(((x) & 0x7) << 21)\n#define CR_REQS(x)\t\t(((x) & 0x7) << 16)\n#define CR_REQS_MASK\t\tCR_REQS(7)\n#define CR_ASEQ(x)\t\t(((x) & 0x3) << 10)\n#define CR_ASEQDONT\t\tCR_ASEQ(0)\n#define CR_ASEQUP\t\tCR_ASEQ(1)\n#define CR_ASEQDOWN\t\tCR_ASEQ(2)\n#define CR_ASEQ_MASK\t\tCR_ASEQ(3)\n#define CR_PSIZE(x)\t\t(((x) & 0x3) << 8)\n#define CR_PSIZE8\t\tCR_PSIZE(1)\n#define CR_PSIZE16\t\tCR_PSIZE(2)\n#define CR_PSIZE32\t\tCR_PSIZE(3)\n#define CR_PORT(x)\t\t(((x) & 0x3) << 6)\n#define CR_PORTCPU\t\tCR_PORT(0)\n#define CR_PORTIO\t\tCR_PORT(1)\n#define CR_PORTVXI\t\tCR_PORT(2)\n#define CR_PORTMXI\t\tCR_PORT(3)\n#define CR_AMDEVICE\t\tBIT(0)\n\nstatic unsigned int MITE_IODWBSR_1_WSIZE_bits(unsigned int size)\n{\n\treturn (ilog2(size) - 1) & 0x1f;\n}\n\nstatic unsigned int mite_retry_limit(unsigned int retry_limit)\n{\n\tunsigned int value = 0;\n\n\tif (retry_limit)\n\t\tvalue = 1 + ilog2(retry_limit);\n\tif (value > 0x7)\n\t\tvalue = 0x7;\n\treturn CR_RL(value);\n}\n\nstatic unsigned int mite_drq_reqs(unsigned int drq_line)\n{\n\t \n\treturn CR_REQS((drq_line & 0x3) | 0x4);\n}\n\nstatic unsigned int mite_fifo_size(struct mite *mite, unsigned int channel)\n{\n\tunsigned int fcr_bits = readl(mite->mmio + MITE_FCR(channel));\n\tunsigned int empty_count = (fcr_bits >> 16) & 0xff;\n\tunsigned int full_count = fcr_bits & 0xff;\n\n\treturn empty_count + full_count;\n}\n\nstatic u32 mite_device_bytes_transferred(struct mite_channel *mite_chan)\n{\n\tstruct mite *mite = mite_chan->mite;\n\n\treturn readl(mite->mmio + MITE_DAR(mite_chan->channel));\n}\n\n \nu32 mite_bytes_in_transit(struct mite_channel *mite_chan)\n{\n\tstruct mite *mite = mite_chan->mite;\n\n\treturn readl(mite->mmio + MITE_FCR(mite_chan->channel)) & 0xff;\n}\nEXPORT_SYMBOL_GPL(mite_bytes_in_transit);\n\n \nstatic u32 mite_bytes_written_to_memory_lb(struct mite_channel *mite_chan)\n{\n\tu32 device_byte_count;\n\n\tdevice_byte_count = mite_device_bytes_transferred(mite_chan);\n\treturn device_byte_count - mite_bytes_in_transit(mite_chan);\n}\n\n \nstatic u32 mite_bytes_written_to_memory_ub(struct mite_channel *mite_chan)\n{\n\tu32 in_transit_count;\n\n\tin_transit_count = mite_bytes_in_transit(mite_chan);\n\treturn mite_device_bytes_transferred(mite_chan) - in_transit_count;\n}\n\n \nstatic u32 mite_bytes_read_from_memory_lb(struct mite_channel *mite_chan)\n{\n\tu32 device_byte_count;\n\n\tdevice_byte_count = mite_device_bytes_transferred(mite_chan);\n\treturn device_byte_count + mite_bytes_in_transit(mite_chan);\n}\n\n \nstatic u32 mite_bytes_read_from_memory_ub(struct mite_channel *mite_chan)\n{\n\tu32 in_transit_count;\n\n\tin_transit_count = mite_bytes_in_transit(mite_chan);\n\treturn mite_device_bytes_transferred(mite_chan) + in_transit_count;\n}\n\nstatic void mite_sync_input_dma(struct mite_channel *mite_chan,\n\t\t\t\tstruct comedi_subdevice *s)\n{\n\tstruct comedi_async *async = s->async;\n\tint count;\n\tunsigned int nbytes, old_alloc_count;\n\n\told_alloc_count = async->buf_write_alloc_count;\n\t \n\tcomedi_buf_write_alloc(s, async->prealloc_bufsz);\n\n\tnbytes = mite_bytes_written_to_memory_lb(mite_chan);\n\tif ((int)(mite_bytes_written_to_memory_ub(mite_chan) -\n\t\t  old_alloc_count) > 0) {\n\t\tdev_warn(s->device->class_dev,\n\t\t\t \"mite: DMA overwrite of free area\\n\");\n\t\tasync->events |= COMEDI_CB_OVERFLOW;\n\t\treturn;\n\t}\n\n\tcount = nbytes - async->buf_write_count;\n\t \n\tif (count > 0) {\n\t\tcomedi_buf_write_free(s, count);\n\t\tcomedi_inc_scan_progress(s, count);\n\t\tasync->events |= COMEDI_CB_BLOCK;\n\t}\n}\n\nstatic void mite_sync_output_dma(struct mite_channel *mite_chan,\n\t\t\t\t struct comedi_subdevice *s)\n{\n\tstruct comedi_async *async = s->async;\n\tstruct comedi_cmd *cmd = &async->cmd;\n\tu32 stop_count = cmd->stop_arg * comedi_bytes_per_scan(s);\n\tunsigned int old_alloc_count = async->buf_read_alloc_count;\n\tu32 nbytes_ub, nbytes_lb;\n\tint count;\n\tbool finite_regen = (cmd->stop_src == TRIG_NONE && stop_count != 0);\n\n\t \n\tcomedi_buf_read_alloc(s, async->prealloc_bufsz);\n\tnbytes_lb = mite_bytes_read_from_memory_lb(mite_chan);\n\tif (cmd->stop_src == TRIG_COUNT && (int)(nbytes_lb - stop_count) > 0)\n\t\tnbytes_lb = stop_count;\n\tnbytes_ub = mite_bytes_read_from_memory_ub(mite_chan);\n\tif (cmd->stop_src == TRIG_COUNT && (int)(nbytes_ub - stop_count) > 0)\n\t\tnbytes_ub = stop_count;\n\n\tif ((!finite_regen || stop_count > old_alloc_count) &&\n\t    ((int)(nbytes_ub - old_alloc_count) > 0)) {\n\t\tdev_warn(s->device->class_dev, \"mite: DMA underrun\\n\");\n\t\tasync->events |= COMEDI_CB_OVERFLOW;\n\t\treturn;\n\t}\n\n\tif (finite_regen) {\n\t\t \n\t\treturn;\n\t}\n\n\tcount = nbytes_lb - async->buf_read_count;\n\tif (count > 0) {\n\t\tcomedi_buf_read_free(s, count);\n\t\tasync->events |= COMEDI_CB_BLOCK;\n\t}\n}\n\n \nvoid mite_sync_dma(struct mite_channel *mite_chan, struct comedi_subdevice *s)\n{\n\tif (mite_chan->dir == COMEDI_INPUT)\n\t\tmite_sync_input_dma(mite_chan, s);\n\telse\n\t\tmite_sync_output_dma(mite_chan, s);\n}\nEXPORT_SYMBOL_GPL(mite_sync_dma);\n\nstatic unsigned int mite_get_status(struct mite_channel *mite_chan)\n{\n\tstruct mite *mite = mite_chan->mite;\n\tunsigned int status;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mite->lock, flags);\n\tstatus = readl(mite->mmio + MITE_CHSR(mite_chan->channel));\n\tif (status & CHSR_DONE) {\n\t\tmite_chan->done = 1;\n\t\twritel(CHOR_CLRDONE,\n\t\t       mite->mmio + MITE_CHOR(mite_chan->channel));\n\t}\n\tspin_unlock_irqrestore(&mite->lock, flags);\n\treturn status;\n}\n\n \nvoid mite_ack_linkc(struct mite_channel *mite_chan,\n\t\t    struct comedi_subdevice *s,\n\t\t    bool sync)\n{\n\tstruct mite *mite = mite_chan->mite;\n\tunsigned int status;\n\n\tstatus = mite_get_status(mite_chan);\n\tif (status & CHSR_LINKC) {\n\t\twritel(CHOR_CLRLC, mite->mmio + MITE_CHOR(mite_chan->channel));\n\t\tsync = true;\n\t}\n\tif (sync)\n\t\tmite_sync_dma(mite_chan, s);\n\n\tif (status & CHSR_XFERR) {\n\t\tdev_err(s->device->class_dev,\n\t\t\t\"mite: transfer error %08x\\n\", status);\n\t\ts->async->events |= COMEDI_CB_ERROR;\n\t}\n}\nEXPORT_SYMBOL_GPL(mite_ack_linkc);\n\n \nint mite_done(struct mite_channel *mite_chan)\n{\n\tstruct mite *mite = mite_chan->mite;\n\tunsigned long flags;\n\tint done;\n\n\tmite_get_status(mite_chan);\n\tspin_lock_irqsave(&mite->lock, flags);\n\tdone = mite_chan->done;\n\tspin_unlock_irqrestore(&mite->lock, flags);\n\treturn done;\n}\nEXPORT_SYMBOL_GPL(mite_done);\n\nstatic void mite_dma_reset(struct mite_channel *mite_chan)\n{\n\twritel(CHOR_DMARESET | CHOR_FRESET,\n\t       mite_chan->mite->mmio + MITE_CHOR(mite_chan->channel));\n}\n\n \nvoid mite_dma_arm(struct mite_channel *mite_chan)\n{\n\tstruct mite *mite = mite_chan->mite;\n\tunsigned long flags;\n\n\t \n\tsmp_mb();\n\tspin_lock_irqsave(&mite->lock, flags);\n\tmite_chan->done = 0;\n\t \n\twritel(CHOR_START, mite->mmio + MITE_CHOR(mite_chan->channel));\n\tspin_unlock_irqrestore(&mite->lock, flags);\n}\nEXPORT_SYMBOL_GPL(mite_dma_arm);\n\n \nvoid mite_dma_disarm(struct mite_channel *mite_chan)\n{\n\tstruct mite *mite = mite_chan->mite;\n\n\t \n\twritel(CHOR_ABORT, mite->mmio + MITE_CHOR(mite_chan->channel));\n}\nEXPORT_SYMBOL_GPL(mite_dma_disarm);\n\n \nvoid mite_prep_dma(struct mite_channel *mite_chan,\n\t\t   unsigned int num_device_bits, unsigned int num_memory_bits)\n{\n\tstruct mite *mite = mite_chan->mite;\n\tunsigned int chcr, mcr, dcr, lkcr;\n\n\tmite_dma_reset(mite_chan);\n\n\t \n\tchcr = CHCR_SET_DMA_IE | CHCR_LINKSHORT | CHCR_SET_DONE_IE |\n\t    CHCR_BURSTEN;\n\t \n\tchcr |= CHCR_SET_LC_IE;\n\tif (num_memory_bits == 32 && num_device_bits == 16) {\n\t\t \n\t\tchcr |= CHCR_BYTE_SWAP_DEVICE | CHCR_BYTE_SWAP_MEMORY;\n\t}\n\tif (mite_chan->dir == COMEDI_INPUT)\n\t\tchcr |= CHCR_DEV_TO_MEM;\n\n\twritel(chcr, mite->mmio + MITE_CHCR(mite_chan->channel));\n\n\t \n\tmcr = mite_retry_limit(64) | CR_ASEQUP;\n\tswitch (num_memory_bits) {\n\tcase 8:\n\t\tmcr |= CR_PSIZE8;\n\t\tbreak;\n\tcase 16:\n\t\tmcr |= CR_PSIZE16;\n\t\tbreak;\n\tcase 32:\n\t\tmcr |= CR_PSIZE32;\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"bug! invalid mem bit width for dma transfer\\n\");\n\t\tbreak;\n\t}\n\twritel(mcr, mite->mmio + MITE_MCR(mite_chan->channel));\n\n\t \n\tdcr = mite_retry_limit(64) | CR_ASEQUP;\n\tdcr |= CR_PORTIO | CR_AMDEVICE | mite_drq_reqs(mite_chan->channel);\n\tswitch (num_device_bits) {\n\tcase 8:\n\t\tdcr |= CR_PSIZE8;\n\t\tbreak;\n\tcase 16:\n\t\tdcr |= CR_PSIZE16;\n\t\tbreak;\n\tcase 32:\n\t\tdcr |= CR_PSIZE32;\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"bug! invalid dev bit width for dma transfer\\n\");\n\t\tbreak;\n\t}\n\twritel(dcr, mite->mmio + MITE_DCR(mite_chan->channel));\n\n\t \n\twritel(0, mite->mmio + MITE_DAR(mite_chan->channel));\n\n\t \n\tlkcr = mite_retry_limit(64) | CR_ASEQUP | CR_PSIZE32;\n\twritel(lkcr, mite->mmio + MITE_LKCR(mite_chan->channel));\n\n\t \n\twritel(mite_chan->ring->dma_addr,\n\t       mite->mmio + MITE_LKAR(mite_chan->channel));\n}\nEXPORT_SYMBOL_GPL(mite_prep_dma);\n\n \nstruct mite_channel *mite_request_channel_in_range(struct mite *mite,\n\t\t\t\t\t\t   struct mite_ring *ring,\n\t\t\t\t\t\t   unsigned int min_channel,\n\t\t\t\t\t\t   unsigned int max_channel)\n{\n\tstruct mite_channel *mite_chan = NULL;\n\tunsigned long flags;\n\tint i;\n\n\t \n\tspin_lock_irqsave(&mite->lock, flags);\n\tfor (i = min_channel; i <= max_channel; ++i) {\n\t\tmite_chan = &mite->channels[i];\n\t\tif (!mite_chan->ring) {\n\t\t\tmite_chan->ring = ring;\n\t\t\tbreak;\n\t\t}\n\t\tmite_chan = NULL;\n\t}\n\tspin_unlock_irqrestore(&mite->lock, flags);\n\treturn mite_chan;\n}\nEXPORT_SYMBOL_GPL(mite_request_channel_in_range);\n\n \nstruct mite_channel *mite_request_channel(struct mite *mite,\n\t\t\t\t\t  struct mite_ring *ring)\n{\n\treturn mite_request_channel_in_range(mite, ring, 0,\n\t\t\t\t\t     mite->num_channels - 1);\n}\nEXPORT_SYMBOL_GPL(mite_request_channel);\n\n \nvoid mite_release_channel(struct mite_channel *mite_chan)\n{\n\tstruct mite *mite = mite_chan->mite;\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&mite->lock, flags);\n\tif (mite_chan->ring) {\n\t\tmite_dma_disarm(mite_chan);\n\t\tmite_dma_reset(mite_chan);\n\t\t \n\t\twritel(CHCR_CLR_DMA_IE | CHCR_CLR_LINKP_IE |\n\t\t       CHCR_CLR_SAR_IE | CHCR_CLR_DONE_IE |\n\t\t       CHCR_CLR_MRDY_IE | CHCR_CLR_DRDY_IE |\n\t\t       CHCR_CLR_LC_IE | CHCR_CLR_CONT_RB_IE,\n\t\t       mite->mmio + MITE_CHCR(mite_chan->channel));\n\t\tmite_chan->ring = NULL;\n\t}\n\tspin_unlock_irqrestore(&mite->lock, flags);\n}\nEXPORT_SYMBOL_GPL(mite_release_channel);\n\n \nint mite_init_ring_descriptors(struct mite_ring *ring,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       unsigned int nbytes)\n{\n\tstruct comedi_async *async = s->async;\n\tstruct mite_dma_desc *desc = NULL;\n\tunsigned int n_full_links = nbytes >> PAGE_SHIFT;\n\tunsigned int remainder = nbytes % PAGE_SIZE;\n\tint i;\n\n\tdev_dbg(s->device->class_dev,\n\t\t\"mite: init ring buffer to %u bytes\\n\", nbytes);\n\n\tif ((n_full_links + (remainder > 0 ? 1 : 0)) > ring->n_links) {\n\t\tdev_err(s->device->class_dev,\n\t\t\t\"mite: ring buffer too small for requested init\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tfor (i = 0; i < n_full_links; ++i) {\n\t\tdesc = &ring->descs[i];\n\t\tdesc->count = cpu_to_le32(PAGE_SIZE);\n\t\tdesc->addr = cpu_to_le32(async->buf_map->page_list[i].dma_addr);\n\t\tdesc->next = cpu_to_le32(ring->dma_addr +\n\t\t\t\t\t (i + 1) * sizeof(*desc));\n\t}\n\n\t \n\tif (remainder > 0) {\n\t\tdesc = &ring->descs[i];\n\t\t \n\t\tdesc->count = cpu_to_le32(remainder);\n\t\tdesc->addr = cpu_to_le32(async->buf_map->page_list[i].dma_addr);\n\t}\n\n\t \n\tdesc->next = cpu_to_le32(ring->dma_addr);\n\n\t \n\tsmp_wmb();\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mite_init_ring_descriptors);\n\nstatic void mite_free_dma_descs(struct mite_ring *ring)\n{\n\tstruct mite_dma_desc *descs = ring->descs;\n\n\tif (descs) {\n\t\tdma_free_coherent(ring->hw_dev,\n\t\t\t\t  ring->n_links * sizeof(*descs),\n\t\t\t\t  descs, ring->dma_addr);\n\t\tring->descs = NULL;\n\t\tring->dma_addr = 0;\n\t\tring->n_links = 0;\n\t}\n}\n\n \nint mite_buf_change(struct mite_ring *ring, struct comedi_subdevice *s)\n{\n\tstruct comedi_async *async = s->async;\n\tstruct mite_dma_desc *descs;\n\tunsigned int n_links;\n\n\tmite_free_dma_descs(ring);\n\n\tif (async->prealloc_bufsz == 0)\n\t\treturn 0;\n\n\tn_links = async->prealloc_bufsz >> PAGE_SHIFT;\n\n\tdescs = dma_alloc_coherent(ring->hw_dev,\n\t\t\t\t   n_links * sizeof(*descs),\n\t\t\t\t   &ring->dma_addr, GFP_KERNEL);\n\tif (!descs) {\n\t\tdev_err(s->device->class_dev,\n\t\t\t\"mite: ring buffer allocation failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tring->descs = descs;\n\tring->n_links = n_links;\n\n\treturn mite_init_ring_descriptors(ring, s, n_links << PAGE_SHIFT);\n}\nEXPORT_SYMBOL_GPL(mite_buf_change);\n\n \nstruct mite_ring *mite_alloc_ring(struct mite *mite)\n{\n\tstruct mite_ring *ring;\n\n\tring = kmalloc(sizeof(*ring), GFP_KERNEL);\n\tif (!ring)\n\t\treturn NULL;\n\tring->hw_dev = get_device(&mite->pcidev->dev);\n\tif (!ring->hw_dev) {\n\t\tkfree(ring);\n\t\treturn NULL;\n\t}\n\tring->n_links = 0;\n\tring->descs = NULL;\n\tring->dma_addr = 0;\n\treturn ring;\n}\nEXPORT_SYMBOL_GPL(mite_alloc_ring);\n\n \nvoid mite_free_ring(struct mite_ring *ring)\n{\n\tif (ring) {\n\t\tmite_free_dma_descs(ring);\n\t\tput_device(ring->hw_dev);\n\t\tkfree(ring);\n\t}\n}\nEXPORT_SYMBOL_GPL(mite_free_ring);\n\nstatic int mite_setup(struct comedi_device *dev, struct mite *mite,\n\t\t      bool use_win1)\n{\n\tresource_size_t daq_phys_addr;\n\tunsigned long length;\n\tint i;\n\tu32 csigr_bits;\n\tunsigned int unknown_dma_burst_bits;\n\tunsigned int wpdep;\n\n\tpci_set_master(mite->pcidev);\n\n\tmite->mmio = pci_ioremap_bar(mite->pcidev, 0);\n\tif (!mite->mmio)\n\t\treturn -ENOMEM;\n\n\tdev->mmio = pci_ioremap_bar(mite->pcidev, 1);\n\tif (!dev->mmio)\n\t\treturn -ENOMEM;\n\tdaq_phys_addr = pci_resource_start(mite->pcidev, 1);\n\tlength = pci_resource_len(mite->pcidev, 1);\n\n\tif (use_win1) {\n\t\twritel(0, mite->mmio + MITE_IODWBSR);\n\t\tdev_dbg(dev->class_dev,\n\t\t\t\"mite: using I/O Window Base Size register 1\\n\");\n\t\twritel(daq_phys_addr | WENAB |\n\t\t       MITE_IODWBSR_1_WSIZE_bits(length),\n\t\t       mite->mmio + MITE_IODWBSR_1);\n\t\twritel(0, mite->mmio + MITE_IODWCR_1);\n\t} else {\n\t\twritel(daq_phys_addr | WENAB, mite->mmio + MITE_IODWBSR);\n\t}\n\t \n\tunknown_dma_burst_bits = readl(mite->mmio + MITE_UNKNOWN_DMA_BURST_REG);\n\tunknown_dma_burst_bits |= UNKNOWN_DMA_BURST_ENABLE_BITS;\n\twritel(unknown_dma_burst_bits, mite->mmio + MITE_UNKNOWN_DMA_BURST_REG);\n\n\tcsigr_bits = readl(mite->mmio + MITE_CSIGR);\n\tmite->num_channels = CSIGR_TO_DMAC(csigr_bits);\n\tif (mite->num_channels > MAX_MITE_DMA_CHANNELS) {\n\t\tdev_warn(dev->class_dev,\n\t\t\t \"mite: bug? chip claims to have %i dma channels. Setting to %i.\\n\",\n\t\t\t mite->num_channels, MAX_MITE_DMA_CHANNELS);\n\t\tmite->num_channels = MAX_MITE_DMA_CHANNELS;\n\t}\n\n\t \n\twpdep = CSIGR_TO_WPDEP(csigr_bits);\n\tif (wpdep)\n\t\twpdep = BIT(wpdep);\n\n\tdev_dbg(dev->class_dev,\n\t\t\"mite: version = %i, type = %i, mite mode = %i, interface mode = %i\\n\",\n\t\tCSIGR_TO_VER(csigr_bits), CSIGR_TO_TYPE(csigr_bits),\n\t\tCSIGR_TO_MMODE(csigr_bits), CSIGR_TO_IMODE(csigr_bits));\n\tdev_dbg(dev->class_dev,\n\t\t\"mite: num channels = %i, write post fifo depth = %i, wins = %i, iowins = %i\\n\",\n\t\tCSIGR_TO_DMAC(csigr_bits), wpdep,\n\t\tCSIGR_TO_WINS(csigr_bits), CSIGR_TO_IOWINS(csigr_bits));\n\n\tfor (i = 0; i < mite->num_channels; i++) {\n\t\twritel(CHOR_DMARESET, mite->mmio + MITE_CHOR(i));\n\t\t \n\t\twritel(CHCR_CLR_DMA_IE | CHCR_CLR_LINKP_IE | CHCR_CLR_SAR_IE |\n\t\t       CHCR_CLR_DONE_IE | CHCR_CLR_MRDY_IE | CHCR_CLR_DRDY_IE |\n\t\t       CHCR_CLR_LC_IE | CHCR_CLR_CONT_RB_IE,\n\t\t       mite->mmio + MITE_CHCR(i));\n\t}\n\tmite->fifo_size = mite_fifo_size(mite, 0);\n\tdev_dbg(dev->class_dev, \"mite: fifo size is %i.\\n\", mite->fifo_size);\n\treturn 0;\n}\n\n \nstruct mite *mite_attach(struct comedi_device *dev, bool use_win1)\n{\n\tstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\n\tstruct mite *mite;\n\tunsigned int i;\n\tint ret;\n\n\tmite = kzalloc(sizeof(*mite), GFP_KERNEL);\n\tif (!mite)\n\t\treturn NULL;\n\n\tspin_lock_init(&mite->lock);\n\tmite->pcidev = pcidev;\n\tfor (i = 0; i < MAX_MITE_DMA_CHANNELS; ++i) {\n\t\tmite->channels[i].mite = mite;\n\t\tmite->channels[i].channel = i;\n\t\tmite->channels[i].done = 1;\n\t}\n\n\tret = mite_setup(dev, mite, use_win1);\n\tif (ret) {\n\t\tif (mite->mmio)\n\t\t\tiounmap(mite->mmio);\n\t\tkfree(mite);\n\t\treturn NULL;\n\t}\n\n\treturn mite;\n}\nEXPORT_SYMBOL_GPL(mite_attach);\n\n \nvoid mite_detach(struct mite *mite)\n{\n\tif (!mite)\n\t\treturn;\n\n\tif (mite->mmio)\n\t\tiounmap(mite->mmio);\n\n\tkfree(mite);\n}\nEXPORT_SYMBOL_GPL(mite_detach);\n\nstatic int __init mite_module_init(void)\n{\n\treturn 0;\n}\nmodule_init(mite_module_init);\n\nstatic void __exit mite_module_exit(void)\n{\n}\nmodule_exit(mite_module_exit);\n\nMODULE_AUTHOR(\"Comedi https://www.comedi.org\");\nMODULE_DESCRIPTION(\"Comedi helper for NI Mite PCI interface chip\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}