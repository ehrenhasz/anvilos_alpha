{
  "module_name": "ni_tio.c",
  "hash_id": "e61e0f1cd203c63574513aba160352cf6185e31aa53b505ebd40fbf136a9fd0f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/ni_tio.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include \"ni_tio_internal.h\"\n\n \n#define NI_M_TIMEBASE_1_CLK\t\t0x0\t \n#define NI_M_PFI_CLK(x)\t\t\t(((x) < 10) ? (1 + (x)) : (0xb + (x)))\n#define NI_M_RTSI_CLK(x)\t\t(((x) == 7) ? 0x1b : (0xb + (x)))\n#define NI_M_TIMEBASE_2_CLK\t\t0x12\t \n#define NI_M_NEXT_TC_CLK\t\t0x13\n#define NI_M_NEXT_GATE_CLK\t\t0x14\t \n#define NI_M_PXI_STAR_TRIGGER_CLK\t0x14\t \n#define NI_M_PXI10_CLK\t\t\t0x1d\n#define NI_M_TIMEBASE_3_CLK\t\t0x1e\t \n#define NI_M_ANALOG_TRIGGER_OUT_CLK\t0x1e\t \n#define NI_M_LOGIC_LOW_CLK\t\t0x1f\n#define NI_M_MAX_PFI_CHAN\t\t15\n#define NI_M_MAX_RTSI_CHAN\t\t7\n\n \n#define NI_660X_TIMEBASE_1_CLK\t\t0x0\t \n#define NI_660X_SRC_PIN_I_CLK\t\t0x1\n#define NI_660X_SRC_PIN_CLK(x)\t\t(0x2 + (x))\n#define NI_660X_NEXT_GATE_CLK\t\t0xa\n#define NI_660X_RTSI_CLK(x)\t\t(0xb + (x))\n#define NI_660X_TIMEBASE_2_CLK\t\t0x12\t \n#define NI_660X_NEXT_TC_CLK\t\t0x13\n#define NI_660X_TIMEBASE_3_CLK\t\t0x1e\t \n#define NI_660X_LOGIC_LOW_CLK\t\t0x1f\n#define NI_660X_MAX_SRC_PIN\t\t7\n#define NI_660X_MAX_RTSI_CHAN\t\t6\n\n \n#define NI_M_TIMESTAMP_MUX_GATE_SEL\t0x0\n#define NI_M_PFI_GATE_SEL(x)\t\t(((x) < 10) ? (1 + (x)) : (0xb + (x)))\n#define NI_M_RTSI_GATE_SEL(x)\t\t(((x) == 7) ? 0x1b : (0xb + (x)))\n#define NI_M_AI_START2_GATE_SEL\t\t0x12\n#define NI_M_PXI_STAR_TRIGGER_GATE_SEL\t0x13\n#define NI_M_NEXT_OUT_GATE_SEL\t\t0x14\n#define NI_M_AI_START1_GATE_SEL\t\t0x1c\n#define NI_M_NEXT_SRC_GATE_SEL\t\t0x1d\n#define NI_M_ANALOG_TRIG_OUT_GATE_SEL\t0x1e\n#define NI_M_LOGIC_LOW_GATE_SEL\t\t0x1f\n\n \n#define NI_660X_SRC_PIN_I_GATE_SEL\t0x0\n#define NI_660X_GATE_PIN_I_GATE_SEL\t0x1\n#define NI_660X_PIN_GATE_SEL(x)\t\t(0x2 + (x))\n#define NI_660X_NEXT_SRC_GATE_SEL\t0xa\n#define NI_660X_RTSI_GATE_SEL(x)\t(0xb + (x))\n#define NI_660X_NEXT_OUT_GATE_SEL\t0x14\n#define NI_660X_LOGIC_LOW_GATE_SEL\t0x1f\n#define NI_660X_MAX_GATE_PIN\t\t7\n\n \n#define NI_660X_SRC_PIN_I_GATE2_SEL\t0x0\n#define NI_660X_UD_PIN_I_GATE2_SEL\t0x1\n#define NI_660X_UD_PIN_GATE2_SEL(x)\t(0x2 + (x))\n#define NI_660X_NEXT_SRC_GATE2_SEL\t0xa\n#define NI_660X_RTSI_GATE2_SEL(x)\t(0xb + (x))\n#define NI_660X_NEXT_OUT_GATE2_SEL\t0x14\n#define NI_660X_SELECTED_GATE2_SEL\t0x1e\n#define NI_660X_LOGIC_LOW_GATE2_SEL\t0x1f\n#define NI_660X_MAX_UP_DOWN_PIN\t\t7\n\nstatic inline unsigned int GI_PRESCALE_X2(enum ni_gpct_variant variant)\n{\n\tswitch (variant) {\n\tcase ni_gpct_variant_e_series:\n\tdefault:\n\t\treturn 0;\n\tcase ni_gpct_variant_m_series:\n\t\treturn GI_M_PRESCALE_X2;\n\tcase ni_gpct_variant_660x:\n\t\treturn GI_660X_PRESCALE_X2;\n\t}\n}\n\nstatic inline unsigned int GI_PRESCALE_X8(enum ni_gpct_variant variant)\n{\n\tswitch (variant) {\n\tcase ni_gpct_variant_e_series:\n\tdefault:\n\t\treturn 0;\n\tcase ni_gpct_variant_m_series:\n\t\treturn GI_M_PRESCALE_X8;\n\tcase ni_gpct_variant_660x:\n\t\treturn GI_660X_PRESCALE_X8;\n\t}\n}\n\nstatic bool ni_tio_has_gate2_registers(const struct ni_gpct_device *counter_dev)\n{\n\tswitch (counter_dev->variant) {\n\tcase ni_gpct_variant_e_series:\n\tdefault:\n\t\treturn false;\n\tcase ni_gpct_variant_m_series:\n\tcase ni_gpct_variant_660x:\n\t\treturn true;\n\t}\n}\n\n \nvoid ni_tio_write(struct ni_gpct *counter, unsigned int value,\n\t\t  enum ni_gpct_register reg)\n{\n\tif (reg < NITIO_NUM_REGS)\n\t\tcounter->counter_dev->write(counter, value, reg);\n}\nEXPORT_SYMBOL_GPL(ni_tio_write);\n\n \nunsigned int ni_tio_read(struct ni_gpct *counter, enum ni_gpct_register reg)\n{\n\tif (reg < NITIO_NUM_REGS)\n\t\treturn counter->counter_dev->read(counter, reg);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ni_tio_read);\n\nstatic void ni_tio_reset_count_and_disarm(struct ni_gpct *counter)\n{\n\tunsigned int cidx = counter->counter_index;\n\n\tni_tio_write(counter, GI_RESET(cidx), NITIO_RESET_REG(cidx));\n}\n\nstatic int ni_tio_clock_period_ps(const struct ni_gpct *counter,\n\t\t\t\t  unsigned int generic_clock_source,\n\t\t\t\t  u64 *period_ps)\n{\n\tu64 clock_period_ps;\n\n\tswitch (generic_clock_source & NI_GPCT_CLOCK_SRC_SELECT_MASK) {\n\tcase NI_GPCT_TIMEBASE_1_CLOCK_SRC_BITS:\n\t\tclock_period_ps = 50000;\n\t\tbreak;\n\tcase NI_GPCT_TIMEBASE_2_CLOCK_SRC_BITS:\n\t\tclock_period_ps = 10000000;\n\t\tbreak;\n\tcase NI_GPCT_TIMEBASE_3_CLOCK_SRC_BITS:\n\t\tclock_period_ps = 12500;\n\t\tbreak;\n\tcase NI_GPCT_PXI10_CLOCK_SRC_BITS:\n\t\tclock_period_ps = 100000;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\t*period_ps = counter->clock_period_ps;\n\t\treturn 0;\n\t}\n\n\tswitch (generic_clock_source & NI_GPCT_PRESCALE_MODE_CLOCK_SRC_MASK) {\n\tcase NI_GPCT_NO_PRESCALE_CLOCK_SRC_BITS:\n\t\tbreak;\n\tcase NI_GPCT_PRESCALE_X2_CLOCK_SRC_BITS:\n\t\tclock_period_ps *= 2;\n\t\tbreak;\n\tcase NI_GPCT_PRESCALE_X8_CLOCK_SRC_BITS:\n\t\tclock_period_ps *= 8;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\t*period_ps = clock_period_ps;\n\treturn 0;\n}\n\nstatic void ni_tio_set_bits_transient(struct ni_gpct *counter,\n\t\t\t\t      enum ni_gpct_register reg,\n\t\t\t\t      unsigned int mask, unsigned int value,\n\t\t\t\t      unsigned int transient)\n{\n\tstruct ni_gpct_device *counter_dev = counter->counter_dev;\n\tunsigned int chip = counter->chip_index;\n\tunsigned long flags;\n\n\tif (reg < NITIO_NUM_REGS && chip < counter_dev->num_chips) {\n\t\tunsigned int *regs = counter_dev->regs[chip];\n\n\t\tspin_lock_irqsave(&counter_dev->regs_lock, flags);\n\t\tregs[reg] &= ~mask;\n\t\tregs[reg] |= (value & mask);\n\t\tni_tio_write(counter, regs[reg] | transient, reg);\n\t\tspin_unlock_irqrestore(&counter_dev->regs_lock, flags);\n\t}\n}\n\n \nvoid ni_tio_set_bits(struct ni_gpct *counter, enum ni_gpct_register reg,\n\t\t     unsigned int mask, unsigned int value)\n{\n\tni_tio_set_bits_transient(counter, reg, mask, value, 0x0);\n}\nEXPORT_SYMBOL_GPL(ni_tio_set_bits);\n\n \nunsigned int ni_tio_get_soft_copy(const struct ni_gpct *counter,\n\t\t\t\t  enum ni_gpct_register reg)\n{\n\tstruct ni_gpct_device *counter_dev = counter->counter_dev;\n\tunsigned int chip = counter->chip_index;\n\tunsigned int value = 0;\n\tunsigned long flags;\n\n\tif (reg < NITIO_NUM_REGS && chip < counter_dev->num_chips) {\n\t\tspin_lock_irqsave(&counter_dev->regs_lock, flags);\n\t\tvalue = counter_dev->regs[chip][reg];\n\t\tspin_unlock_irqrestore(&counter_dev->regs_lock, flags);\n\t}\n\treturn value;\n}\nEXPORT_SYMBOL_GPL(ni_tio_get_soft_copy);\n\nstatic unsigned int ni_tio_clock_src_modifiers(const struct ni_gpct *counter)\n{\n\tstruct ni_gpct_device *counter_dev = counter->counter_dev;\n\tunsigned int cidx = counter->counter_index;\n\tunsigned int counting_mode_bits =\n\t\tni_tio_get_soft_copy(counter, NITIO_CNT_MODE_REG(cidx));\n\tunsigned int bits = 0;\n\n\tif (ni_tio_get_soft_copy(counter, NITIO_INPUT_SEL_REG(cidx)) &\n\t    GI_SRC_POL_INVERT)\n\t\tbits |= NI_GPCT_INVERT_CLOCK_SRC_BIT;\n\tif (counting_mode_bits & GI_PRESCALE_X2(counter_dev->variant))\n\t\tbits |= NI_GPCT_PRESCALE_X2_CLOCK_SRC_BITS;\n\tif (counting_mode_bits & GI_PRESCALE_X8(counter_dev->variant))\n\t\tbits |= NI_GPCT_PRESCALE_X8_CLOCK_SRC_BITS;\n\treturn bits;\n}\n\nstatic int ni_m_series_clock_src_select(const struct ni_gpct *counter,\n\t\t\t\t\tunsigned int *clk_src)\n{\n\tstruct ni_gpct_device *counter_dev = counter->counter_dev;\n\tunsigned int cidx = counter->counter_index;\n\tunsigned int chip = counter->chip_index;\n\tunsigned int second_gate_reg = NITIO_GATE2_REG(cidx);\n\tunsigned int clock_source = 0;\n\tunsigned int src;\n\tunsigned int i;\n\n\tsrc = GI_BITS_TO_SRC(ni_tio_get_soft_copy(counter,\n\t\t\t\t\t\t  NITIO_INPUT_SEL_REG(cidx)));\n\n\tswitch (src) {\n\tcase NI_M_TIMEBASE_1_CLK:\n\t\tclock_source = NI_GPCT_TIMEBASE_1_CLOCK_SRC_BITS;\n\t\tbreak;\n\tcase NI_M_TIMEBASE_2_CLK:\n\t\tclock_source = NI_GPCT_TIMEBASE_2_CLOCK_SRC_BITS;\n\t\tbreak;\n\tcase NI_M_TIMEBASE_3_CLK:\n\t\tif (counter_dev->regs[chip][second_gate_reg] & GI_SRC_SUBSEL)\n\t\t\tclock_source =\n\t\t\t    NI_GPCT_ANALOG_TRIGGER_OUT_CLOCK_SRC_BITS;\n\t\telse\n\t\t\tclock_source = NI_GPCT_TIMEBASE_3_CLOCK_SRC_BITS;\n\t\tbreak;\n\tcase NI_M_LOGIC_LOW_CLK:\n\t\tclock_source = NI_GPCT_LOGIC_LOW_CLOCK_SRC_BITS;\n\t\tbreak;\n\tcase NI_M_NEXT_GATE_CLK:\n\t\tif (counter_dev->regs[chip][second_gate_reg] & GI_SRC_SUBSEL)\n\t\t\tclock_source = NI_GPCT_PXI_STAR_TRIGGER_CLOCK_SRC_BITS;\n\t\telse\n\t\t\tclock_source = NI_GPCT_NEXT_GATE_CLOCK_SRC_BITS;\n\t\tbreak;\n\tcase NI_M_PXI10_CLK:\n\t\tclock_source = NI_GPCT_PXI10_CLOCK_SRC_BITS;\n\t\tbreak;\n\tcase NI_M_NEXT_TC_CLK:\n\t\tclock_source = NI_GPCT_NEXT_TC_CLOCK_SRC_BITS;\n\t\tbreak;\n\tdefault:\n\t\tfor (i = 0; i <= NI_M_MAX_RTSI_CHAN; ++i) {\n\t\t\tif (src == NI_M_RTSI_CLK(i)) {\n\t\t\t\tclock_source = NI_GPCT_RTSI_CLOCK_SRC_BITS(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i <= NI_M_MAX_RTSI_CHAN)\n\t\t\tbreak;\n\t\tfor (i = 0; i <= NI_M_MAX_PFI_CHAN; ++i) {\n\t\t\tif (src == NI_M_PFI_CLK(i)) {\n\t\t\t\tclock_source = NI_GPCT_PFI_CLOCK_SRC_BITS(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i <= NI_M_MAX_PFI_CHAN)\n\t\t\tbreak;\n\t\treturn -EINVAL;\n\t}\n\tclock_source |= ni_tio_clock_src_modifiers(counter);\n\t*clk_src = clock_source;\n\treturn 0;\n}\n\nstatic int ni_660x_clock_src_select(const struct ni_gpct *counter,\n\t\t\t\t    unsigned int *clk_src)\n{\n\tunsigned int clock_source = 0;\n\tunsigned int cidx = counter->counter_index;\n\tunsigned int src;\n\tunsigned int i;\n\n\tsrc = GI_BITS_TO_SRC(ni_tio_get_soft_copy(counter,\n\t\t\t\t\t\t  NITIO_INPUT_SEL_REG(cidx)));\n\n\tswitch (src) {\n\tcase NI_660X_TIMEBASE_1_CLK:\n\t\tclock_source = NI_GPCT_TIMEBASE_1_CLOCK_SRC_BITS;\n\t\tbreak;\n\tcase NI_660X_TIMEBASE_2_CLK:\n\t\tclock_source = NI_GPCT_TIMEBASE_2_CLOCK_SRC_BITS;\n\t\tbreak;\n\tcase NI_660X_TIMEBASE_3_CLK:\n\t\tclock_source = NI_GPCT_TIMEBASE_3_CLOCK_SRC_BITS;\n\t\tbreak;\n\tcase NI_660X_LOGIC_LOW_CLK:\n\t\tclock_source = NI_GPCT_LOGIC_LOW_CLOCK_SRC_BITS;\n\t\tbreak;\n\tcase NI_660X_SRC_PIN_I_CLK:\n\t\tclock_source = NI_GPCT_SOURCE_PIN_i_CLOCK_SRC_BITS;\n\t\tbreak;\n\tcase NI_660X_NEXT_GATE_CLK:\n\t\tclock_source = NI_GPCT_NEXT_GATE_CLOCK_SRC_BITS;\n\t\tbreak;\n\tcase NI_660X_NEXT_TC_CLK:\n\t\tclock_source = NI_GPCT_NEXT_TC_CLOCK_SRC_BITS;\n\t\tbreak;\n\tdefault:\n\t\tfor (i = 0; i <= NI_660X_MAX_RTSI_CHAN; ++i) {\n\t\t\tif (src == NI_660X_RTSI_CLK(i)) {\n\t\t\t\tclock_source = NI_GPCT_RTSI_CLOCK_SRC_BITS(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i <= NI_660X_MAX_RTSI_CHAN)\n\t\t\tbreak;\n\t\tfor (i = 0; i <= NI_660X_MAX_SRC_PIN; ++i) {\n\t\t\tif (src == NI_660X_SRC_PIN_CLK(i)) {\n\t\t\t\tclock_source =\n\t\t\t\t    NI_GPCT_SOURCE_PIN_CLOCK_SRC_BITS(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i <= NI_660X_MAX_SRC_PIN)\n\t\t\tbreak;\n\t\treturn -EINVAL;\n\t}\n\tclock_source |= ni_tio_clock_src_modifiers(counter);\n\t*clk_src = clock_source;\n\treturn 0;\n}\n\nstatic int ni_tio_generic_clock_src_select(const struct ni_gpct *counter,\n\t\t\t\t\t   unsigned int *clk_src)\n{\n\tswitch (counter->counter_dev->variant) {\n\tcase ni_gpct_variant_e_series:\n\tcase ni_gpct_variant_m_series:\n\tdefault:\n\t\treturn ni_m_series_clock_src_select(counter, clk_src);\n\tcase ni_gpct_variant_660x:\n\t\treturn ni_660x_clock_src_select(counter, clk_src);\n\t}\n}\n\nstatic void ni_tio_set_sync_mode(struct ni_gpct *counter)\n{\n\tstruct ni_gpct_device *counter_dev = counter->counter_dev;\n\tunsigned int cidx = counter->counter_index;\n\tstatic const u64 min_normal_sync_period_ps = 25000;\n\tunsigned int mask = 0;\n\tunsigned int bits = 0;\n\tunsigned int reg;\n\tunsigned int mode;\n\tunsigned int clk_src = 0;\n\tu64 ps = 0;\n\tint ret;\n\tbool force_alt_sync;\n\n\t \n\tswitch (counter_dev->variant) {\n\tcase ni_gpct_variant_e_series:\n\tdefault:\n\t\treturn;\n\tcase ni_gpct_variant_m_series:\n\t\tmask = GI_M_ALT_SYNC;\n\t\tbreak;\n\tcase ni_gpct_variant_660x:\n\t\tmask = GI_660X_ALT_SYNC;\n\t\tbreak;\n\t}\n\n\treg = NITIO_CNT_MODE_REG(cidx);\n\tmode = ni_tio_get_soft_copy(counter, reg);\n\tswitch (mode & GI_CNT_MODE_MASK) {\n\tcase GI_CNT_MODE_QUADX1:\n\tcase GI_CNT_MODE_QUADX2:\n\tcase GI_CNT_MODE_QUADX4:\n\tcase GI_CNT_MODE_SYNC_SRC:\n\t\tforce_alt_sync = true;\n\t\tbreak;\n\tdefault:\n\t\tforce_alt_sync = false;\n\t\tbreak;\n\t}\n\n\tret = ni_tio_generic_clock_src_select(counter, &clk_src);\n\tif (ret)\n\t\treturn;\n\tret = ni_tio_clock_period_ps(counter, clk_src, &ps);\n\tif (ret)\n\t\treturn;\n\t \n\tif (force_alt_sync || (ps && ps < min_normal_sync_period_ps))\n\t\tbits = mask;\n\n\tni_tio_set_bits(counter, reg, mask, bits);\n}\n\nstatic int ni_tio_set_counter_mode(struct ni_gpct *counter, unsigned int mode)\n{\n\tstruct ni_gpct_device *counter_dev = counter->counter_dev;\n\tunsigned int cidx = counter->counter_index;\n\tunsigned int mode_reg_mask;\n\tunsigned int mode_reg_values;\n\tunsigned int input_select_bits = 0;\n\t \n\tstatic const unsigned int mode_reg_direct_mask =\n\t    NI_GPCT_GATE_ON_BOTH_EDGES_BIT | NI_GPCT_EDGE_GATE_MODE_MASK |\n\t    NI_GPCT_STOP_MODE_MASK | NI_GPCT_OUTPUT_MODE_MASK |\n\t    NI_GPCT_HARDWARE_DISARM_MASK | NI_GPCT_LOADING_ON_TC_BIT |\n\t    NI_GPCT_LOADING_ON_GATE_BIT | NI_GPCT_LOAD_B_SELECT_BIT;\n\n\tmode_reg_mask = mode_reg_direct_mask | GI_RELOAD_SRC_SWITCHING;\n\tmode_reg_values = mode & mode_reg_direct_mask;\n\tswitch (mode & NI_GPCT_RELOAD_SOURCE_MASK) {\n\tcase NI_GPCT_RELOAD_SOURCE_FIXED_BITS:\n\t\tbreak;\n\tcase NI_GPCT_RELOAD_SOURCE_SWITCHING_BITS:\n\t\tmode_reg_values |= GI_RELOAD_SRC_SWITCHING;\n\t\tbreak;\n\tcase NI_GPCT_RELOAD_SOURCE_GATE_SELECT_BITS:\n\t\tinput_select_bits |= GI_GATE_SEL_LOAD_SRC;\n\t\tmode_reg_mask |= GI_GATING_MODE_MASK;\n\t\tmode_reg_values |= GI_LEVEL_GATING;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tni_tio_set_bits(counter, NITIO_MODE_REG(cidx),\n\t\t\tmode_reg_mask, mode_reg_values);\n\n\tif (ni_tio_counting_mode_registers_present(counter_dev)) {\n\t\tunsigned int bits = 0;\n\n\t\tbits |= GI_CNT_MODE(mode >> NI_GPCT_COUNTING_MODE_SHIFT);\n\t\tbits |= GI_INDEX_PHASE((mode >> NI_GPCT_INDEX_PHASE_BITSHIFT));\n\t\tif (mode & NI_GPCT_INDEX_ENABLE_BIT)\n\t\t\tbits |= GI_INDEX_MODE;\n\t\tni_tio_set_bits(counter, NITIO_CNT_MODE_REG(cidx),\n\t\t\t\tGI_CNT_MODE_MASK | GI_INDEX_PHASE_MASK |\n\t\t\t\tGI_INDEX_MODE, bits);\n\t\tni_tio_set_sync_mode(counter);\n\t}\n\n\tni_tio_set_bits(counter, NITIO_CMD_REG(cidx), GI_CNT_DIR_MASK,\n\t\t\tGI_CNT_DIR(mode >> NI_GPCT_COUNTING_DIRECTION_SHIFT));\n\n\tif (mode & NI_GPCT_OR_GATE_BIT)\n\t\tinput_select_bits |= GI_OR_GATE;\n\tif (mode & NI_GPCT_INVERT_OUTPUT_BIT)\n\t\tinput_select_bits |= GI_OUTPUT_POL_INVERT;\n\tni_tio_set_bits(counter, NITIO_INPUT_SEL_REG(cidx),\n\t\t\tGI_GATE_SEL_LOAD_SRC | GI_OR_GATE |\n\t\t\tGI_OUTPUT_POL_INVERT, input_select_bits);\n\n\treturn 0;\n}\n\nint ni_tio_arm(struct ni_gpct *counter, bool arm, unsigned int start_trigger)\n{\n\tstruct ni_gpct_device *counter_dev = counter->counter_dev;\n\tunsigned int cidx = counter->counter_index;\n\tunsigned int transient_bits = 0;\n\n\tif (arm) {\n\t\tunsigned int mask = 0;\n\t\tunsigned int bits = 0;\n\n\t\t \n\t\tswitch (counter_dev->variant) {\n\t\tcase ni_gpct_variant_e_series:\n\t\tdefault:\n\t\t\tbreak;\n\t\tcase ni_gpct_variant_m_series:\n\t\t\tmask = GI_M_HW_ARM_SEL_MASK;\n\t\t\tbreak;\n\t\tcase ni_gpct_variant_660x:\n\t\t\tmask = GI_660X_HW_ARM_SEL_MASK;\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (start_trigger) {\n\t\tcase NI_GPCT_ARM_IMMEDIATE:\n\t\t\ttransient_bits |= GI_ARM;\n\t\t\tbreak;\n\t\tcase NI_GPCT_ARM_PAIRED_IMMEDIATE:\n\t\t\ttransient_bits |= GI_ARM | GI_ARM_COPY;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tif (mask && (start_trigger & NI_GPCT_ARM_UNKNOWN)) {\n\t\t\t\tbits |= GI_HW_ARM_ENA |\n\t\t\t\t\t(GI_HW_ARM_SEL(start_trigger) & mask);\n\t\t\t} else {\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (mask)\n\t\t\tni_tio_set_bits(counter, NITIO_CNT_MODE_REG(cidx),\n\t\t\t\t\tGI_HW_ARM_ENA | mask, bits);\n\t} else {\n\t\ttransient_bits |= GI_DISARM;\n\t}\n\tni_tio_set_bits_transient(counter, NITIO_CMD_REG(cidx),\n\t\t\t\t  0, 0, transient_bits);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ni_tio_arm);\n\nstatic int ni_660x_clk_src(unsigned int clock_source, unsigned int *bits)\n{\n\tunsigned int clk_src = clock_source & NI_GPCT_CLOCK_SRC_SELECT_MASK;\n\tunsigned int ni_660x_clock;\n\tunsigned int i;\n\n\tswitch (clk_src) {\n\tcase NI_GPCT_TIMEBASE_1_CLOCK_SRC_BITS:\n\t\tni_660x_clock = NI_660X_TIMEBASE_1_CLK;\n\t\tbreak;\n\tcase NI_GPCT_TIMEBASE_2_CLOCK_SRC_BITS:\n\t\tni_660x_clock = NI_660X_TIMEBASE_2_CLK;\n\t\tbreak;\n\tcase NI_GPCT_TIMEBASE_3_CLOCK_SRC_BITS:\n\t\tni_660x_clock = NI_660X_TIMEBASE_3_CLK;\n\t\tbreak;\n\tcase NI_GPCT_LOGIC_LOW_CLOCK_SRC_BITS:\n\t\tni_660x_clock = NI_660X_LOGIC_LOW_CLK;\n\t\tbreak;\n\tcase NI_GPCT_SOURCE_PIN_i_CLOCK_SRC_BITS:\n\t\tni_660x_clock = NI_660X_SRC_PIN_I_CLK;\n\t\tbreak;\n\tcase NI_GPCT_NEXT_GATE_CLOCK_SRC_BITS:\n\t\tni_660x_clock = NI_660X_NEXT_GATE_CLK;\n\t\tbreak;\n\tcase NI_GPCT_NEXT_TC_CLOCK_SRC_BITS:\n\t\tni_660x_clock = NI_660X_NEXT_TC_CLK;\n\t\tbreak;\n\tdefault:\n\t\tfor (i = 0; i <= NI_660X_MAX_RTSI_CHAN; ++i) {\n\t\t\tif (clk_src == NI_GPCT_RTSI_CLOCK_SRC_BITS(i)) {\n\t\t\t\tni_660x_clock = NI_660X_RTSI_CLK(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i <= NI_660X_MAX_RTSI_CHAN)\n\t\t\tbreak;\n\t\tfor (i = 0; i <= NI_660X_MAX_SRC_PIN; ++i) {\n\t\t\tif (clk_src == NI_GPCT_SOURCE_PIN_CLOCK_SRC_BITS(i)) {\n\t\t\t\tni_660x_clock = NI_660X_SRC_PIN_CLK(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i <= NI_660X_MAX_SRC_PIN)\n\t\t\tbreak;\n\t\treturn -EINVAL;\n\t}\n\t*bits = GI_SRC_SEL(ni_660x_clock);\n\treturn 0;\n}\n\nstatic int ni_m_clk_src(unsigned int clock_source, unsigned int *bits)\n{\n\tunsigned int clk_src = clock_source & NI_GPCT_CLOCK_SRC_SELECT_MASK;\n\tunsigned int ni_m_series_clock;\n\tunsigned int i;\n\n\tswitch (clk_src) {\n\tcase NI_GPCT_TIMEBASE_1_CLOCK_SRC_BITS:\n\t\tni_m_series_clock = NI_M_TIMEBASE_1_CLK;\n\t\tbreak;\n\tcase NI_GPCT_TIMEBASE_2_CLOCK_SRC_BITS:\n\t\tni_m_series_clock = NI_M_TIMEBASE_2_CLK;\n\t\tbreak;\n\tcase NI_GPCT_TIMEBASE_3_CLOCK_SRC_BITS:\n\t\tni_m_series_clock = NI_M_TIMEBASE_3_CLK;\n\t\tbreak;\n\tcase NI_GPCT_LOGIC_LOW_CLOCK_SRC_BITS:\n\t\tni_m_series_clock = NI_M_LOGIC_LOW_CLK;\n\t\tbreak;\n\tcase NI_GPCT_NEXT_GATE_CLOCK_SRC_BITS:\n\t\tni_m_series_clock = NI_M_NEXT_GATE_CLK;\n\t\tbreak;\n\tcase NI_GPCT_NEXT_TC_CLOCK_SRC_BITS:\n\t\tni_m_series_clock = NI_M_NEXT_TC_CLK;\n\t\tbreak;\n\tcase NI_GPCT_PXI10_CLOCK_SRC_BITS:\n\t\tni_m_series_clock = NI_M_PXI10_CLK;\n\t\tbreak;\n\tcase NI_GPCT_PXI_STAR_TRIGGER_CLOCK_SRC_BITS:\n\t\tni_m_series_clock = NI_M_PXI_STAR_TRIGGER_CLK;\n\t\tbreak;\n\tcase NI_GPCT_ANALOG_TRIGGER_OUT_CLOCK_SRC_BITS:\n\t\tni_m_series_clock = NI_M_ANALOG_TRIGGER_OUT_CLK;\n\t\tbreak;\n\tdefault:\n\t\tfor (i = 0; i <= NI_M_MAX_RTSI_CHAN; ++i) {\n\t\t\tif (clk_src == NI_GPCT_RTSI_CLOCK_SRC_BITS(i)) {\n\t\t\t\tni_m_series_clock = NI_M_RTSI_CLK(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i <= NI_M_MAX_RTSI_CHAN)\n\t\t\tbreak;\n\t\tfor (i = 0; i <= NI_M_MAX_PFI_CHAN; ++i) {\n\t\t\tif (clk_src == NI_GPCT_PFI_CLOCK_SRC_BITS(i)) {\n\t\t\t\tni_m_series_clock = NI_M_PFI_CLK(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i <= NI_M_MAX_PFI_CHAN)\n\t\t\tbreak;\n\t\treturn -EINVAL;\n\t}\n\t*bits = GI_SRC_SEL(ni_m_series_clock);\n\treturn 0;\n};\n\nstatic void ni_tio_set_source_subselect(struct ni_gpct *counter,\n\t\t\t\t\tunsigned int clock_source)\n{\n\tstruct ni_gpct_device *counter_dev = counter->counter_dev;\n\tunsigned int cidx = counter->counter_index;\n\tunsigned int chip = counter->chip_index;\n\tunsigned int second_gate_reg = NITIO_GATE2_REG(cidx);\n\n\tif (counter_dev->variant != ni_gpct_variant_m_series)\n\t\treturn;\n\tswitch (clock_source & NI_GPCT_CLOCK_SRC_SELECT_MASK) {\n\t\t \n\tcase NI_GPCT_NEXT_GATE_CLOCK_SRC_BITS:\n\tcase NI_GPCT_TIMEBASE_3_CLOCK_SRC_BITS:\n\t\tcounter_dev->regs[chip][second_gate_reg] &= ~GI_SRC_SUBSEL;\n\t\tbreak;\n\t\t \n\tcase NI_GPCT_ANALOG_TRIGGER_OUT_CLOCK_SRC_BITS:\n\tcase NI_GPCT_PXI_STAR_TRIGGER_CLOCK_SRC_BITS:\n\t\tcounter_dev->regs[chip][second_gate_reg] |= GI_SRC_SUBSEL;\n\t\tbreak;\n\t\t \n\tdefault:\n\t\treturn;\n\t}\n\tni_tio_write(counter, counter_dev->regs[chip][second_gate_reg],\n\t\t     second_gate_reg);\n}\n\nstatic int ni_tio_set_clock_src(struct ni_gpct *counter,\n\t\t\t\tunsigned int clock_source,\n\t\t\t\tunsigned int period_ns)\n{\n\tstruct ni_gpct_device *counter_dev = counter->counter_dev;\n\tunsigned int cidx = counter->counter_index;\n\tunsigned int bits = 0;\n\tint ret;\n\n\tswitch (counter_dev->variant) {\n\tcase ni_gpct_variant_660x:\n\t\tret = ni_660x_clk_src(clock_source, &bits);\n\t\tbreak;\n\tcase ni_gpct_variant_e_series:\n\tcase ni_gpct_variant_m_series:\n\tdefault:\n\t\tret = ni_m_clk_src(clock_source, &bits);\n\t\tbreak;\n\t}\n\tif (ret) {\n\t\tstruct comedi_device *dev = counter_dev->dev;\n\n\t\tdev_err(dev->class_dev, \"invalid clock source 0x%x\\n\",\n\t\t\tclock_source);\n\t\treturn ret;\n\t}\n\n\tif (clock_source & NI_GPCT_INVERT_CLOCK_SRC_BIT)\n\t\tbits |= GI_SRC_POL_INVERT;\n\tni_tio_set_bits(counter, NITIO_INPUT_SEL_REG(cidx),\n\t\t\tGI_SRC_SEL_MASK | GI_SRC_POL_INVERT, bits);\n\tni_tio_set_source_subselect(counter, clock_source);\n\n\tif (ni_tio_counting_mode_registers_present(counter_dev)) {\n\t\tbits = 0;\n\t\tswitch (clock_source & NI_GPCT_PRESCALE_MODE_CLOCK_SRC_MASK) {\n\t\tcase NI_GPCT_NO_PRESCALE_CLOCK_SRC_BITS:\n\t\t\tbreak;\n\t\tcase NI_GPCT_PRESCALE_X2_CLOCK_SRC_BITS:\n\t\t\tbits |= GI_PRESCALE_X2(counter_dev->variant);\n\t\t\tbreak;\n\t\tcase NI_GPCT_PRESCALE_X8_CLOCK_SRC_BITS:\n\t\t\tbits |= GI_PRESCALE_X8(counter_dev->variant);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tni_tio_set_bits(counter, NITIO_CNT_MODE_REG(cidx),\n\t\t\t\tGI_PRESCALE_X2(counter_dev->variant) |\n\t\t\t\tGI_PRESCALE_X8(counter_dev->variant), bits);\n\t}\n\tcounter->clock_period_ps = period_ns * 1000;\n\tni_tio_set_sync_mode(counter);\n\treturn 0;\n}\n\nstatic int ni_tio_get_clock_src(struct ni_gpct *counter,\n\t\t\t\tunsigned int *clock_source,\n\t\t\t\tunsigned int *period_ns)\n{\n\tu64 temp64 = 0;\n\tint ret;\n\n\tret = ni_tio_generic_clock_src_select(counter, clock_source);\n\tif (ret)\n\t\treturn ret;\n\tret = ni_tio_clock_period_ps(counter, *clock_source, &temp64);\n\tif (ret)\n\t\treturn ret;\n\tdo_div(temp64, 1000);\t \n\t*period_ns = temp64;\n\treturn 0;\n}\n\nstatic inline void ni_tio_set_gate_raw(struct ni_gpct *counter,\n\t\t\t\t       unsigned int gate_source)\n{\n\tni_tio_set_bits(counter, NITIO_INPUT_SEL_REG(counter->counter_index),\n\t\t\tGI_GATE_SEL_MASK, GI_GATE_SEL(gate_source));\n}\n\nstatic inline void ni_tio_set_gate2_raw(struct ni_gpct *counter,\n\t\t\t\t\tunsigned int gate_source)\n{\n\tni_tio_set_bits(counter, NITIO_GATE2_REG(counter->counter_index),\n\t\t\tGI_GATE2_SEL_MASK, GI_GATE2_SEL(gate_source));\n}\n\n \nstatic inline void ni_tio_set_gate_mode(struct ni_gpct *counter,\n\t\t\t\t\tunsigned int src)\n{\n\tunsigned int mode_bits = 0;\n\n\tif (CR_CHAN(src) & NI_GPCT_DISABLED_GATE_SELECT) {\n\t\t \n\t\tmode_bits = GI_GATING_DISABLED;\n\t} else {\n\t\tif (src & CR_INVERT)\n\t\t\tmode_bits |= GI_GATE_POL_INVERT;\n\t\tif (src & CR_EDGE)\n\t\t\tmode_bits |= GI_RISING_EDGE_GATING;\n\t\telse\n\t\t\tmode_bits |= GI_LEVEL_GATING;\n\t}\n\tni_tio_set_bits(counter, NITIO_MODE_REG(counter->counter_index),\n\t\t\tGI_GATE_POL_INVERT | GI_GATING_MODE_MASK,\n\t\t\tmode_bits);\n}\n\n \nstatic inline void ni_tio_set_gate2_mode(struct ni_gpct *counter,\n\t\t\t\t\t unsigned int src)\n{\n\t \n\tunsigned int mode_bits = GI_GATE2_MODE;\n\n\tif (CR_CHAN(src) & NI_GPCT_DISABLED_GATE_SELECT)\n\t\t \n\t\tmode_bits = GI_GATING_DISABLED;\n\tif (src & CR_INVERT)\n\t\tmode_bits |= GI_GATE2_POL_INVERT;\n\n\tni_tio_set_bits(counter, NITIO_GATE2_REG(counter->counter_index),\n\t\t\tGI_GATE2_POL_INVERT | GI_GATE2_MODE, mode_bits);\n}\n\nstatic int ni_660x_set_gate(struct ni_gpct *counter, unsigned int gate_source)\n{\n\tunsigned int chan = CR_CHAN(gate_source);\n\tunsigned int gate_sel;\n\tunsigned int i;\n\n\tswitch (chan) {\n\tcase NI_GPCT_NEXT_SOURCE_GATE_SELECT:\n\t\tgate_sel = NI_660X_NEXT_SRC_GATE_SEL;\n\t\tbreak;\n\tcase NI_GPCT_NEXT_OUT_GATE_SELECT:\n\tcase NI_GPCT_LOGIC_LOW_GATE_SELECT:\n\tcase NI_GPCT_SOURCE_PIN_i_GATE_SELECT:\n\tcase NI_GPCT_GATE_PIN_i_GATE_SELECT:\n\t\tgate_sel = chan & 0x1f;\n\t\tbreak;\n\tdefault:\n\t\tfor (i = 0; i <= NI_660X_MAX_RTSI_CHAN; ++i) {\n\t\t\tif (chan == NI_GPCT_RTSI_GATE_SELECT(i)) {\n\t\t\t\tgate_sel = chan & 0x1f;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i <= NI_660X_MAX_RTSI_CHAN)\n\t\t\tbreak;\n\t\tfor (i = 0; i <= NI_660X_MAX_GATE_PIN; ++i) {\n\t\t\tif (chan == NI_GPCT_GATE_PIN_GATE_SELECT(i)) {\n\t\t\t\tgate_sel = chan & 0x1f;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i <= NI_660X_MAX_GATE_PIN)\n\t\t\tbreak;\n\t\treturn -EINVAL;\n\t}\n\tni_tio_set_gate_raw(counter, gate_sel);\n\treturn 0;\n}\n\nstatic int ni_m_set_gate(struct ni_gpct *counter, unsigned int gate_source)\n{\n\tunsigned int chan = CR_CHAN(gate_source);\n\tunsigned int gate_sel;\n\tunsigned int i;\n\n\tswitch (chan) {\n\tcase NI_GPCT_TIMESTAMP_MUX_GATE_SELECT:\n\tcase NI_GPCT_AI_START2_GATE_SELECT:\n\tcase NI_GPCT_PXI_STAR_TRIGGER_GATE_SELECT:\n\tcase NI_GPCT_NEXT_OUT_GATE_SELECT:\n\tcase NI_GPCT_AI_START1_GATE_SELECT:\n\tcase NI_GPCT_NEXT_SOURCE_GATE_SELECT:\n\tcase NI_GPCT_ANALOG_TRIGGER_OUT_GATE_SELECT:\n\tcase NI_GPCT_LOGIC_LOW_GATE_SELECT:\n\t\tgate_sel = chan & 0x1f;\n\t\tbreak;\n\tdefault:\n\t\tfor (i = 0; i <= NI_M_MAX_RTSI_CHAN; ++i) {\n\t\t\tif (chan == NI_GPCT_RTSI_GATE_SELECT(i)) {\n\t\t\t\tgate_sel = chan & 0x1f;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i <= NI_M_MAX_RTSI_CHAN)\n\t\t\tbreak;\n\t\tfor (i = 0; i <= NI_M_MAX_PFI_CHAN; ++i) {\n\t\t\tif (chan == NI_GPCT_PFI_GATE_SELECT(i)) {\n\t\t\t\tgate_sel = chan & 0x1f;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i <= NI_M_MAX_PFI_CHAN)\n\t\t\tbreak;\n\t\treturn -EINVAL;\n\t}\n\tni_tio_set_gate_raw(counter, gate_sel);\n\treturn 0;\n}\n\nstatic int ni_660x_set_gate2(struct ni_gpct *counter, unsigned int gate_source)\n{\n\tunsigned int chan = CR_CHAN(gate_source);\n\tunsigned int gate2_sel;\n\tunsigned int i;\n\n\tswitch (chan) {\n\tcase NI_GPCT_SOURCE_PIN_i_GATE_SELECT:\n\tcase NI_GPCT_UP_DOWN_PIN_i_GATE_SELECT:\n\tcase NI_GPCT_SELECTED_GATE_GATE_SELECT:\n\tcase NI_GPCT_NEXT_OUT_GATE_SELECT:\n\tcase NI_GPCT_LOGIC_LOW_GATE_SELECT:\n\t\tgate2_sel = chan & 0x1f;\n\t\tbreak;\n\tcase NI_GPCT_NEXT_SOURCE_GATE_SELECT:\n\t\tgate2_sel = NI_660X_NEXT_SRC_GATE2_SEL;\n\t\tbreak;\n\tdefault:\n\t\tfor (i = 0; i <= NI_660X_MAX_RTSI_CHAN; ++i) {\n\t\t\tif (chan == NI_GPCT_RTSI_GATE_SELECT(i)) {\n\t\t\t\tgate2_sel = chan & 0x1f;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i <= NI_660X_MAX_RTSI_CHAN)\n\t\t\tbreak;\n\t\tfor (i = 0; i <= NI_660X_MAX_UP_DOWN_PIN; ++i) {\n\t\t\tif (chan == NI_GPCT_UP_DOWN_PIN_GATE_SELECT(i)) {\n\t\t\t\tgate2_sel = chan & 0x1f;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i <= NI_660X_MAX_UP_DOWN_PIN)\n\t\t\tbreak;\n\t\treturn -EINVAL;\n\t}\n\tni_tio_set_gate2_raw(counter, gate2_sel);\n\treturn 0;\n}\n\nstatic int ni_m_set_gate2(struct ni_gpct *counter, unsigned int gate_source)\n{\n\t \n\tni_tio_set_gate2_raw(counter, gate_source);\n\treturn 0;\n}\n\nint ni_tio_set_gate_src_raw(struct ni_gpct *counter,\n\t\t\t    unsigned int gate, unsigned int src)\n{\n\tstruct ni_gpct_device *counter_dev = counter->counter_dev;\n\n\tswitch (gate) {\n\tcase 0:\n\t\t \n\t\tni_tio_set_gate_mode(counter, NI_GPCT_DISABLED_GATE_SELECT);\n\t\t \n\t\tni_tio_set_gate_raw(counter, src);\n\t\t \n\t\tni_tio_set_gate_mode(counter, src);\n\t\tbreak;\n\tcase 1:\n\t\tif (!ni_tio_has_gate2_registers(counter_dev))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tni_tio_set_gate2_mode(counter, NI_GPCT_DISABLED_GATE_SELECT);\n\t\t \n\t\tni_tio_set_gate2_raw(counter, src);\n\t\t \n\t\tni_tio_set_gate2_mode(counter, src);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ni_tio_set_gate_src_raw);\n\nint ni_tio_set_gate_src(struct ni_gpct *counter,\n\t\t\tunsigned int gate, unsigned int src)\n{\n\tstruct ni_gpct_device *counter_dev = counter->counter_dev;\n\t \n\tint chan = CR_CHAN(src) & (~NI_GPCT_DISABLED_GATE_SELECT);\n\tint ret;\n\n\tswitch (gate) {\n\tcase 0:\n\t\t \n\t\tni_tio_set_gate_mode(counter, NI_GPCT_DISABLED_GATE_SELECT);\n\t\t \n\t\tswitch (counter_dev->variant) {\n\t\tcase ni_gpct_variant_e_series:\n\t\tcase ni_gpct_variant_m_series:\n\t\t\tret = ni_m_set_gate(counter, chan);\n\t\t\tbreak;\n\t\tcase ni_gpct_variant_660x:\n\t\t\tret = ni_660x_set_gate(counter, chan);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t \n\t\tni_tio_set_gate_mode(counter, src);\n\t\tbreak;\n\tcase 1:\n\t\tif (!ni_tio_has_gate2_registers(counter_dev))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tni_tio_set_gate2_mode(counter, NI_GPCT_DISABLED_GATE_SELECT);\n\t\t \n\t\tswitch (counter_dev->variant) {\n\t\tcase ni_gpct_variant_m_series:\n\t\t\tret = ni_m_set_gate2(counter, chan);\n\t\t\tbreak;\n\t\tcase ni_gpct_variant_660x:\n\t\t\tret = ni_660x_set_gate2(counter, chan);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t \n\t\tni_tio_set_gate2_mode(counter, src);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ni_tio_set_gate_src);\n\nstatic int ni_tio_set_other_src(struct ni_gpct *counter, unsigned int index,\n\t\t\t\tunsigned int source)\n{\n\tstruct ni_gpct_device *counter_dev = counter->counter_dev;\n\tunsigned int cidx = counter->counter_index;\n\tunsigned int chip = counter->chip_index;\n\tunsigned int abz_reg, shift, mask;\n\n\tif (counter_dev->variant != ni_gpct_variant_m_series)\n\t\treturn -EINVAL;\n\n\tabz_reg = NITIO_ABZ_REG(cidx);\n\n\t \n\tif (index == NI_GPCT_SOURCE_ENCODER_A ||\n\t    (index >= NI_CtrA(0) && index <= NI_CtrA(-1))) {\n\t\tshift = 10;\n\t} else if (index == NI_GPCT_SOURCE_ENCODER_B ||\n\t    (index >= NI_CtrB(0) && index <= NI_CtrB(-1))) {\n\t\tshift = 5;\n\t} else if (index == NI_GPCT_SOURCE_ENCODER_Z ||\n\t    (index >= NI_CtrZ(0) && index <= NI_CtrZ(-1))) {\n\t\tshift = 0;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tmask = 0x1f << shift;\n\tif (source > 0x1f)\n\t\tsource = 0x1f;\t \n\n\tcounter_dev->regs[chip][abz_reg] &= ~mask;\n\tcounter_dev->regs[chip][abz_reg] |= (source << shift) & mask;\n\tni_tio_write(counter, counter_dev->regs[chip][abz_reg], abz_reg);\n\treturn 0;\n}\n\nstatic int ni_tio_get_other_src(struct ni_gpct *counter, unsigned int index,\n\t\t\t\tunsigned int *source)\n{\n\tstruct ni_gpct_device *counter_dev = counter->counter_dev;\n\tunsigned int cidx = counter->counter_index;\n\tunsigned int abz_reg, shift, mask;\n\n\tif (counter_dev->variant != ni_gpct_variant_m_series)\n\t\t \n\t\treturn -EINVAL;\n\n\tabz_reg = NITIO_ABZ_REG(cidx);\n\n\t \n\tif (index == NI_GPCT_SOURCE_ENCODER_A ||\n\t    (index >= NI_CtrA(0) && index <= NI_CtrA(-1))) {\n\t\tshift = 10;\n\t} else if (index == NI_GPCT_SOURCE_ENCODER_B ||\n\t    (index >= NI_CtrB(0) && index <= NI_CtrB(-1))) {\n\t\tshift = 5;\n\t} else if (index == NI_GPCT_SOURCE_ENCODER_Z ||\n\t    (index >= NI_CtrZ(0) && index <= NI_CtrZ(-1))) {\n\t\tshift = 0;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tmask = 0x1f;\n\n\t*source = (ni_tio_get_soft_copy(counter, abz_reg) >> shift) & mask;\n\treturn 0;\n}\n\nstatic int ni_660x_gate_to_generic_gate(unsigned int gate, unsigned int *src)\n{\n\tunsigned int source;\n\tunsigned int i;\n\n\tswitch (gate) {\n\tcase NI_660X_SRC_PIN_I_GATE_SEL:\n\t\tsource = NI_GPCT_SOURCE_PIN_i_GATE_SELECT;\n\t\tbreak;\n\tcase NI_660X_GATE_PIN_I_GATE_SEL:\n\t\tsource = NI_GPCT_GATE_PIN_i_GATE_SELECT;\n\t\tbreak;\n\tcase NI_660X_NEXT_SRC_GATE_SEL:\n\t\tsource = NI_GPCT_NEXT_SOURCE_GATE_SELECT;\n\t\tbreak;\n\tcase NI_660X_NEXT_OUT_GATE_SEL:\n\t\tsource = NI_GPCT_NEXT_OUT_GATE_SELECT;\n\t\tbreak;\n\tcase NI_660X_LOGIC_LOW_GATE_SEL:\n\t\tsource = NI_GPCT_LOGIC_LOW_GATE_SELECT;\n\t\tbreak;\n\tdefault:\n\t\tfor (i = 0; i <= NI_660X_MAX_RTSI_CHAN; ++i) {\n\t\t\tif (gate == NI_660X_RTSI_GATE_SEL(i)) {\n\t\t\t\tsource = NI_GPCT_RTSI_GATE_SELECT(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i <= NI_660X_MAX_RTSI_CHAN)\n\t\t\tbreak;\n\t\tfor (i = 0; i <= NI_660X_MAX_GATE_PIN; ++i) {\n\t\t\tif (gate == NI_660X_PIN_GATE_SEL(i)) {\n\t\t\t\tsource = NI_GPCT_GATE_PIN_GATE_SELECT(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i <= NI_660X_MAX_GATE_PIN)\n\t\t\tbreak;\n\t\treturn -EINVAL;\n\t}\n\t*src = source;\n\treturn 0;\n}\n\nstatic int ni_m_gate_to_generic_gate(unsigned int gate, unsigned int *src)\n{\n\tunsigned int source;\n\tunsigned int i;\n\n\tswitch (gate) {\n\tcase NI_M_TIMESTAMP_MUX_GATE_SEL:\n\t\tsource = NI_GPCT_TIMESTAMP_MUX_GATE_SELECT;\n\t\tbreak;\n\tcase NI_M_AI_START2_GATE_SEL:\n\t\tsource = NI_GPCT_AI_START2_GATE_SELECT;\n\t\tbreak;\n\tcase NI_M_PXI_STAR_TRIGGER_GATE_SEL:\n\t\tsource = NI_GPCT_PXI_STAR_TRIGGER_GATE_SELECT;\n\t\tbreak;\n\tcase NI_M_NEXT_OUT_GATE_SEL:\n\t\tsource = NI_GPCT_NEXT_OUT_GATE_SELECT;\n\t\tbreak;\n\tcase NI_M_AI_START1_GATE_SEL:\n\t\tsource = NI_GPCT_AI_START1_GATE_SELECT;\n\t\tbreak;\n\tcase NI_M_NEXT_SRC_GATE_SEL:\n\t\tsource = NI_GPCT_NEXT_SOURCE_GATE_SELECT;\n\t\tbreak;\n\tcase NI_M_ANALOG_TRIG_OUT_GATE_SEL:\n\t\tsource = NI_GPCT_ANALOG_TRIGGER_OUT_GATE_SELECT;\n\t\tbreak;\n\tcase NI_M_LOGIC_LOW_GATE_SEL:\n\t\tsource = NI_GPCT_LOGIC_LOW_GATE_SELECT;\n\t\tbreak;\n\tdefault:\n\t\tfor (i = 0; i <= NI_M_MAX_RTSI_CHAN; ++i) {\n\t\t\tif (gate == NI_M_RTSI_GATE_SEL(i)) {\n\t\t\t\tsource = NI_GPCT_RTSI_GATE_SELECT(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i <= NI_M_MAX_RTSI_CHAN)\n\t\t\tbreak;\n\t\tfor (i = 0; i <= NI_M_MAX_PFI_CHAN; ++i) {\n\t\t\tif (gate == NI_M_PFI_GATE_SEL(i)) {\n\t\t\t\tsource = NI_GPCT_PFI_GATE_SELECT(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i <= NI_M_MAX_PFI_CHAN)\n\t\t\tbreak;\n\t\treturn -EINVAL;\n\t}\n\t*src = source;\n\treturn 0;\n}\n\nstatic int ni_660x_gate2_to_generic_gate(unsigned int gate, unsigned int *src)\n{\n\tunsigned int source;\n\tunsigned int i;\n\n\tswitch (gate) {\n\tcase NI_660X_SRC_PIN_I_GATE2_SEL:\n\t\tsource = NI_GPCT_SOURCE_PIN_i_GATE_SELECT;\n\t\tbreak;\n\tcase NI_660X_UD_PIN_I_GATE2_SEL:\n\t\tsource = NI_GPCT_UP_DOWN_PIN_i_GATE_SELECT;\n\t\tbreak;\n\tcase NI_660X_NEXT_SRC_GATE2_SEL:\n\t\tsource = NI_GPCT_NEXT_SOURCE_GATE_SELECT;\n\t\tbreak;\n\tcase NI_660X_NEXT_OUT_GATE2_SEL:\n\t\tsource = NI_GPCT_NEXT_OUT_GATE_SELECT;\n\t\tbreak;\n\tcase NI_660X_SELECTED_GATE2_SEL:\n\t\tsource = NI_GPCT_SELECTED_GATE_GATE_SELECT;\n\t\tbreak;\n\tcase NI_660X_LOGIC_LOW_GATE2_SEL:\n\t\tsource = NI_GPCT_LOGIC_LOW_GATE_SELECT;\n\t\tbreak;\n\tdefault:\n\t\tfor (i = 0; i <= NI_660X_MAX_RTSI_CHAN; ++i) {\n\t\t\tif (gate == NI_660X_RTSI_GATE2_SEL(i)) {\n\t\t\t\tsource = NI_GPCT_RTSI_GATE_SELECT(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i <= NI_660X_MAX_RTSI_CHAN)\n\t\t\tbreak;\n\t\tfor (i = 0; i <= NI_660X_MAX_UP_DOWN_PIN; ++i) {\n\t\t\tif (gate == NI_660X_UD_PIN_GATE2_SEL(i)) {\n\t\t\t\tsource = NI_GPCT_UP_DOWN_PIN_GATE_SELECT(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i <= NI_660X_MAX_UP_DOWN_PIN)\n\t\t\tbreak;\n\t\treturn -EINVAL;\n\t}\n\t*src = source;\n\treturn 0;\n}\n\nstatic int ni_m_gate2_to_generic_gate(unsigned int gate, unsigned int *src)\n{\n\t \n\t*src = gate;\n\treturn 0;\n}\n\nstatic inline unsigned int ni_tio_get_gate_mode(struct ni_gpct *counter)\n{\n\tunsigned int mode = ni_tio_get_soft_copy(counter,\n\t\t\t\tNITIO_MODE_REG(counter->counter_index));\n\tunsigned int ret = 0;\n\n\tif ((mode & GI_GATING_MODE_MASK) == GI_GATING_DISABLED)\n\t\tret |= NI_GPCT_DISABLED_GATE_SELECT;\n\tif (mode & GI_GATE_POL_INVERT)\n\t\tret |= CR_INVERT;\n\tif ((mode & GI_GATING_MODE_MASK) != GI_LEVEL_GATING)\n\t\tret |= CR_EDGE;\n\n\treturn ret;\n}\n\nstatic inline unsigned int ni_tio_get_gate2_mode(struct ni_gpct *counter)\n{\n\tunsigned int mode = ni_tio_get_soft_copy(counter,\n\t\t\t\tNITIO_GATE2_REG(counter->counter_index));\n\tunsigned int ret = 0;\n\n\tif (!(mode & GI_GATE2_MODE))\n\t\tret |= NI_GPCT_DISABLED_GATE_SELECT;\n\tif (mode & GI_GATE2_POL_INVERT)\n\t\tret |= CR_INVERT;\n\n\treturn ret;\n}\n\nstatic inline unsigned int ni_tio_get_gate_val(struct ni_gpct *counter)\n{\n\treturn GI_BITS_TO_GATE(ni_tio_get_soft_copy(counter,\n\t\tNITIO_INPUT_SEL_REG(counter->counter_index)));\n}\n\nstatic inline unsigned int ni_tio_get_gate2_val(struct ni_gpct *counter)\n{\n\treturn GI_BITS_TO_GATE2(ni_tio_get_soft_copy(counter,\n\t\tNITIO_GATE2_REG(counter->counter_index)));\n}\n\nstatic int ni_tio_get_gate_src(struct ni_gpct *counter, unsigned int gate_index,\n\t\t\t       unsigned int *gate_source)\n{\n\tunsigned int gate;\n\tint ret;\n\n\tswitch (gate_index) {\n\tcase 0:\n\t\tgate = ni_tio_get_gate_val(counter);\n\t\tswitch (counter->counter_dev->variant) {\n\t\tcase ni_gpct_variant_e_series:\n\t\tcase ni_gpct_variant_m_series:\n\t\tdefault:\n\t\t\tret = ni_m_gate_to_generic_gate(gate, gate_source);\n\t\t\tbreak;\n\t\tcase ni_gpct_variant_660x:\n\t\t\tret = ni_660x_gate_to_generic_gate(gate, gate_source);\n\t\t\tbreak;\n\t\t}\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t*gate_source |= ni_tio_get_gate_mode(counter);\n\t\tbreak;\n\tcase 1:\n\t\tgate = ni_tio_get_gate2_val(counter);\n\t\tswitch (counter->counter_dev->variant) {\n\t\tcase ni_gpct_variant_e_series:\n\t\tcase ni_gpct_variant_m_series:\n\t\tdefault:\n\t\t\tret = ni_m_gate2_to_generic_gate(gate, gate_source);\n\t\t\tbreak;\n\t\tcase ni_gpct_variant_660x:\n\t\t\tret = ni_660x_gate2_to_generic_gate(gate, gate_source);\n\t\t\tbreak;\n\t\t}\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t*gate_source |= ni_tio_get_gate2_mode(counter);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int ni_tio_get_gate_src_raw(struct ni_gpct *counter,\n\t\t\t\t   unsigned int gate_index,\n\t\t\t\t   unsigned int *gate_source)\n{\n\tswitch (gate_index) {\n\tcase 0:\n\t\t*gate_source = ni_tio_get_gate_mode(counter)\n\t\t\t     | ni_tio_get_gate_val(counter);\n\t\tbreak;\n\tcase 1:\n\t\t*gate_source = ni_tio_get_gate2_mode(counter)\n\t\t\t     | ni_tio_get_gate2_val(counter);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nint ni_tio_insn_config(struct comedi_device *dev,\n\t\t       struct comedi_subdevice *s,\n\t\t       struct comedi_insn *insn,\n\t\t       unsigned int *data)\n{\n\tstruct ni_gpct *counter = s->private;\n\tunsigned int cidx = counter->counter_index;\n\tunsigned int status;\n\tint ret = 0;\n\n\tswitch (data[0]) {\n\tcase INSN_CONFIG_SET_COUNTER_MODE:\n\t\tret = ni_tio_set_counter_mode(counter, data[1]);\n\t\tbreak;\n\tcase INSN_CONFIG_ARM:\n\t\tret = ni_tio_arm(counter, true, data[1]);\n\t\tbreak;\n\tcase INSN_CONFIG_DISARM:\n\t\tret = ni_tio_arm(counter, false, 0);\n\t\tbreak;\n\tcase INSN_CONFIG_GET_COUNTER_STATUS:\n\t\tdata[1] = 0;\n\t\tstatus = ni_tio_read(counter, NITIO_SHARED_STATUS_REG(cidx));\n\t\tif (status & GI_ARMED(cidx)) {\n\t\t\tdata[1] |= COMEDI_COUNTER_ARMED;\n\t\t\tif (status & GI_COUNTING(cidx))\n\t\t\t\tdata[1] |= COMEDI_COUNTER_COUNTING;\n\t\t}\n\t\tdata[2] = COMEDI_COUNTER_ARMED | COMEDI_COUNTER_COUNTING;\n\t\tbreak;\n\tcase INSN_CONFIG_SET_CLOCK_SRC:\n\t\tret = ni_tio_set_clock_src(counter, data[1], data[2]);\n\t\tbreak;\n\tcase INSN_CONFIG_GET_CLOCK_SRC:\n\t\tret = ni_tio_get_clock_src(counter, &data[1], &data[2]);\n\t\tbreak;\n\tcase INSN_CONFIG_SET_GATE_SRC:\n\t\tret = ni_tio_set_gate_src(counter, data[1], data[2]);\n\t\tbreak;\n\tcase INSN_CONFIG_GET_GATE_SRC:\n\t\tret = ni_tio_get_gate_src(counter, data[1], &data[2]);\n\t\tbreak;\n\tcase INSN_CONFIG_SET_OTHER_SRC:\n\t\tret = ni_tio_set_other_src(counter, data[1], data[2]);\n\t\tbreak;\n\tcase INSN_CONFIG_RESET:\n\t\tni_tio_reset_count_and_disarm(counter);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn ret ? ret : insn->n;\n}\nEXPORT_SYMBOL_GPL(ni_tio_insn_config);\n\n \nint ni_tio_get_routing(struct ni_gpct_device *counter_dev, unsigned int dest)\n{\n\t \n\tint ctr_index = (dest - NI_COUNTER_NAMES_BASE) % NI_MAX_COUNTERS;\n\tstruct ni_gpct *counter = &counter_dev->counters[ctr_index];\n\tint ret = 1;\n\tunsigned int reg;\n\n\tif (dest >= NI_CtrA(0) && dest <= NI_CtrZ(-1)) {\n\t\tret = ni_tio_get_other_src(counter, dest, &reg);\n\t} else if (dest >= NI_CtrGate(0) && dest <= NI_CtrGate(-1)) {\n\t\tret = ni_tio_get_gate_src_raw(counter, 0, &reg);\n\t} else if (dest >= NI_CtrAux(0) && dest <= NI_CtrAux(-1)) {\n\t\tret = ni_tio_get_gate_src_raw(counter, 1, &reg);\n\t \n\t}\n\n\tif (ret)\n\t\treturn -EINVAL;\n\n\treturn reg;\n}\nEXPORT_SYMBOL_GPL(ni_tio_get_routing);\n\n \nint ni_tio_set_routing(struct ni_gpct_device *counter_dev, unsigned int dest,\n\t\t       unsigned int reg)\n{\n\t \n\tint ctr_index = (dest - NI_COUNTER_NAMES_BASE) % NI_MAX_COUNTERS;\n\tstruct ni_gpct *counter = &counter_dev->counters[ctr_index];\n\tint ret;\n\n\tif (dest >= NI_CtrA(0) && dest <= NI_CtrZ(-1)) {\n\t\tret = ni_tio_set_other_src(counter, dest, reg);\n\t} else if (dest >= NI_CtrGate(0) && dest <= NI_CtrGate(-1)) {\n\t\tret = ni_tio_set_gate_src_raw(counter, 0, reg);\n\t} else if (dest >= NI_CtrAux(0) && dest <= NI_CtrAux(-1)) {\n\t\tret = ni_tio_set_gate_src_raw(counter, 1, reg);\n\t \n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(ni_tio_set_routing);\n\n \nint ni_tio_unset_routing(struct ni_gpct_device *counter_dev, unsigned int dest)\n{\n\tif (dest >= NI_GATES_NAMES_BASE && dest <= NI_GATES_NAMES_MAX)\n\t\t \n\t\treturn ni_tio_set_routing(counter_dev, dest,\n\t\t\t\t\t  NI_GPCT_DISABLED_GATE_SELECT);\n\t \n\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL_GPL(ni_tio_unset_routing);\n\nstatic unsigned int ni_tio_read_sw_save_reg(struct comedi_device *dev,\n\t\t\t\t\t    struct comedi_subdevice *s)\n{\n\tstruct ni_gpct *counter = s->private;\n\tunsigned int cidx = counter->counter_index;\n\tunsigned int val;\n\n\tni_tio_set_bits(counter, NITIO_CMD_REG(cidx), GI_SAVE_TRACE, 0);\n\tni_tio_set_bits(counter, NITIO_CMD_REG(cidx),\n\t\t\tGI_SAVE_TRACE, GI_SAVE_TRACE);\n\n\t \n\tval = ni_tio_read(counter, NITIO_SW_SAVE_REG(cidx));\n\tif (val != ni_tio_read(counter, NITIO_SW_SAVE_REG(cidx)))\n\t\tval = ni_tio_read(counter, NITIO_SW_SAVE_REG(cidx));\n\n\treturn val;\n}\n\nint ni_tio_insn_read(struct comedi_device *dev,\n\t\t     struct comedi_subdevice *s,\n\t\t     struct comedi_insn *insn,\n\t\t     unsigned int *data)\n{\n\tstruct ni_gpct *counter = s->private;\n\tstruct ni_gpct_device *counter_dev = counter->counter_dev;\n\tunsigned int channel = CR_CHAN(insn->chanspec);\n\tunsigned int cidx = counter->counter_index;\n\tunsigned int chip = counter->chip_index;\n\tint i;\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\tswitch (channel) {\n\t\tcase 0:\n\t\t\tdata[i] = ni_tio_read_sw_save_reg(dev, s);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tdata[i] =\n\t\t\t    counter_dev->regs[chip][NITIO_LOADA_REG(cidx)];\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdata[i] =\n\t\t\t    counter_dev->regs[chip][NITIO_LOADB_REG(cidx)];\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn insn->n;\n}\nEXPORT_SYMBOL_GPL(ni_tio_insn_read);\n\nstatic unsigned int ni_tio_next_load_register(struct ni_gpct *counter)\n{\n\tunsigned int cidx = counter->counter_index;\n\tunsigned int bits = ni_tio_read(counter, NITIO_SHARED_STATUS_REG(cidx));\n\n\treturn (bits & GI_NEXT_LOAD_SRC(cidx))\n\t\t\t? NITIO_LOADB_REG(cidx)\n\t\t\t: NITIO_LOADA_REG(cidx);\n}\n\nint ni_tio_insn_write(struct comedi_device *dev,\n\t\t      struct comedi_subdevice *s,\n\t\t      struct comedi_insn *insn,\n\t\t      unsigned int *data)\n{\n\tstruct ni_gpct *counter = s->private;\n\tstruct ni_gpct_device *counter_dev = counter->counter_dev;\n\tunsigned int channel = CR_CHAN(insn->chanspec);\n\tunsigned int cidx = counter->counter_index;\n\tunsigned int chip = counter->chip_index;\n\tunsigned int load_reg;\n\tunsigned int load_val;\n\n\tif (insn->n < 1)\n\t\treturn 0;\n\tload_val = data[insn->n - 1];\n\tswitch (channel) {\n\tcase 0:\n\t\t \n\n\t\t \n\t\tload_reg = ni_tio_next_load_register(counter);\n\t\tni_tio_write(counter, load_val, load_reg);\n\t\tni_tio_set_bits_transient(counter, NITIO_CMD_REG(cidx),\n\t\t\t\t\t  0, 0, GI_LOAD);\n\t\t \n\t\tni_tio_write(counter, counter_dev->regs[chip][load_reg],\n\t\t\t     load_reg);\n\t\tbreak;\n\tcase 1:\n\t\tcounter_dev->regs[chip][NITIO_LOADA_REG(cidx)] = load_val;\n\t\tni_tio_write(counter, load_val, NITIO_LOADA_REG(cidx));\n\t\tbreak;\n\tcase 2:\n\t\tcounter_dev->regs[chip][NITIO_LOADB_REG(cidx)] = load_val;\n\t\tni_tio_write(counter, load_val, NITIO_LOADB_REG(cidx));\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn insn->n;\n}\nEXPORT_SYMBOL_GPL(ni_tio_insn_write);\n\nvoid ni_tio_init_counter(struct ni_gpct *counter)\n{\n\tstruct ni_gpct_device *counter_dev = counter->counter_dev;\n\tunsigned int cidx = counter->counter_index;\n\tunsigned int chip = counter->chip_index;\n\n\tni_tio_reset_count_and_disarm(counter);\n\n\t \n\tcounter_dev->regs[chip][NITIO_AUTO_INC_REG(cidx)] = 0x0;\n\tni_tio_write(counter, 0x0, NITIO_AUTO_INC_REG(cidx));\n\n\tni_tio_set_bits(counter, NITIO_CMD_REG(cidx),\n\t\t\t~0, GI_SYNC_GATE);\n\n\tni_tio_set_bits(counter, NITIO_MODE_REG(cidx), ~0, 0);\n\n\tcounter_dev->regs[chip][NITIO_LOADA_REG(cidx)] = 0x0;\n\tni_tio_write(counter, 0x0, NITIO_LOADA_REG(cidx));\n\n\tcounter_dev->regs[chip][NITIO_LOADB_REG(cidx)] = 0x0;\n\tni_tio_write(counter, 0x0, NITIO_LOADB_REG(cidx));\n\n\tni_tio_set_bits(counter, NITIO_INPUT_SEL_REG(cidx), ~0, 0);\n\n\tif (ni_tio_counting_mode_registers_present(counter_dev))\n\t\tni_tio_set_bits(counter, NITIO_CNT_MODE_REG(cidx), ~0, 0);\n\n\tif (ni_tio_has_gate2_registers(counter_dev)) {\n\t\tcounter_dev->regs[chip][NITIO_GATE2_REG(cidx)] = 0x0;\n\t\tni_tio_write(counter, 0x0, NITIO_GATE2_REG(cidx));\n\t}\n\n\tni_tio_set_bits(counter, NITIO_DMA_CFG_REG(cidx), ~0, 0x0);\n\n\tni_tio_set_bits(counter, NITIO_INT_ENA_REG(cidx), ~0, 0x0);\n}\nEXPORT_SYMBOL_GPL(ni_tio_init_counter);\n\nstruct ni_gpct_device *\nni_gpct_device_construct(struct comedi_device *dev,\n\t\t\t void (*write)(struct ni_gpct *counter,\n\t\t\t\t       unsigned int value,\n\t\t\t\t       enum ni_gpct_register reg),\n\t\t\t unsigned int (*read)(struct ni_gpct *counter,\n\t\t\t\t\t      enum ni_gpct_register reg),\n\t\t\t enum ni_gpct_variant variant,\n\t\t\t unsigned int num_counters,\n\t\t\t unsigned int counters_per_chip,\n\t\t\t const struct ni_route_tables *routing_tables)\n{\n\tstruct ni_gpct_device *counter_dev;\n\tstruct ni_gpct *counter;\n\tunsigned int i;\n\n\tif (num_counters == 0 || counters_per_chip == 0)\n\t\treturn NULL;\n\n\tcounter_dev = kzalloc(sizeof(*counter_dev), GFP_KERNEL);\n\tif (!counter_dev)\n\t\treturn NULL;\n\n\tcounter_dev->dev = dev;\n\tcounter_dev->write = write;\n\tcounter_dev->read = read;\n\tcounter_dev->variant = variant;\n\tcounter_dev->routing_tables = routing_tables;\n\n\tspin_lock_init(&counter_dev->regs_lock);\n\n\tcounter_dev->num_counters = num_counters;\n\tcounter_dev->num_chips = DIV_ROUND_UP(num_counters, counters_per_chip);\n\n\tcounter_dev->counters = kcalloc(num_counters, sizeof(*counter),\n\t\t\t\t\tGFP_KERNEL);\n\tcounter_dev->regs = kcalloc(counter_dev->num_chips,\n\t\t\t\t    sizeof(*counter_dev->regs), GFP_KERNEL);\n\tif (!counter_dev->regs || !counter_dev->counters) {\n\t\tkfree(counter_dev->regs);\n\t\tkfree(counter_dev->counters);\n\t\tkfree(counter_dev);\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < num_counters; ++i) {\n\t\tcounter = &counter_dev->counters[i];\n\t\tcounter->counter_dev = counter_dev;\n\t\tcounter->chip_index = i / counters_per_chip;\n\t\tcounter->counter_index = i % counters_per_chip;\n\t\tspin_lock_init(&counter->lock);\n\t}\n\n\treturn counter_dev;\n}\nEXPORT_SYMBOL_GPL(ni_gpct_device_construct);\n\nvoid ni_gpct_device_destroy(struct ni_gpct_device *counter_dev)\n{\n\tif (!counter_dev)\n\t\treturn;\n\tkfree(counter_dev->regs);\n\tkfree(counter_dev->counters);\n\tkfree(counter_dev);\n}\nEXPORT_SYMBOL_GPL(ni_gpct_device_destroy);\n\nstatic int __init ni_tio_init_module(void)\n{\n\treturn 0;\n}\nmodule_init(ni_tio_init_module);\n\nstatic void __exit ni_tio_cleanup_module(void)\n{\n}\nmodule_exit(ni_tio_cleanup_module);\n\nMODULE_AUTHOR(\"Comedi <comedi@comedi.org>\");\nMODULE_DESCRIPTION(\"Comedi support for NI general-purpose counters\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}