{
  "module_name": "gsc_hpdi.c",
  "hash_id": "c78d43edeec0a060ce753bc24ef8fab6ea799dcecb1a9a5a1d35f2171f9a385b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/gsc_hpdi.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/comedi/comedi_pci.h>\n\n#include \"plx9080.h\"\n\n \n#define FIRMWARE_REV_REG\t\t\t0x00\n#define FEATURES_REG_PRESENT_BIT\t\tBIT(15)\n#define BOARD_CONTROL_REG\t\t\t0x04\n#define BOARD_RESET_BIT\t\t\t\tBIT(0)\n#define TX_FIFO_RESET_BIT\t\t\tBIT(1)\n#define RX_FIFO_RESET_BIT\t\t\tBIT(2)\n#define TX_ENABLE_BIT\t\t\t\tBIT(4)\n#define RX_ENABLE_BIT\t\t\t\tBIT(5)\n#define DEMAND_DMA_DIRECTION_TX_BIT\t\tBIT(6)   \n#define LINE_VALID_ON_STATUS_VALID_BIT\t\tBIT(7)\n#define START_TX_BIT\t\t\t\tBIT(8)\n#define CABLE_THROTTLE_ENABLE_BIT\t\tBIT(9)\n#define TEST_MODE_ENABLE_BIT\t\t\tBIT(31)\n#define BOARD_STATUS_REG\t\t\t0x08\n#define COMMAND_LINE_STATUS_MASK\t\t(0x7f << 0)\n#define TX_IN_PROGRESS_BIT\t\t\tBIT(7)\n#define TX_NOT_EMPTY_BIT\t\t\tBIT(8)\n#define TX_NOT_ALMOST_EMPTY_BIT\t\t\tBIT(9)\n#define TX_NOT_ALMOST_FULL_BIT\t\t\tBIT(10)\n#define TX_NOT_FULL_BIT\t\t\t\tBIT(11)\n#define RX_NOT_EMPTY_BIT\t\t\tBIT(12)\n#define RX_NOT_ALMOST_EMPTY_BIT\t\t\tBIT(13)\n#define RX_NOT_ALMOST_FULL_BIT\t\t\tBIT(14)\n#define RX_NOT_FULL_BIT\t\t\t\tBIT(15)\n#define BOARD_JUMPER0_INSTALLED_BIT\t\tBIT(16)\n#define BOARD_JUMPER1_INSTALLED_BIT\t\tBIT(17)\n#define TX_OVERRUN_BIT\t\t\t\tBIT(21)\n#define RX_UNDERRUN_BIT\t\t\t\tBIT(22)\n#define RX_OVERRUN_BIT\t\t\t\tBIT(23)\n#define TX_PROG_ALMOST_REG\t\t\t0x0c\n#define RX_PROG_ALMOST_REG\t\t\t0x10\n#define ALMOST_EMPTY_BITS(x)\t\t\t(((x) & 0xffff) << 0)\n#define ALMOST_FULL_BITS(x)\t\t\t(((x) & 0xff) << 16)\n#define FEATURES_REG\t\t\t\t0x14\n#define FIFO_SIZE_PRESENT_BIT\t\t\tBIT(0)\n#define FIFO_WORDS_PRESENT_BIT\t\t\tBIT(1)\n#define LEVEL_EDGE_INTERRUPTS_PRESENT_BIT\tBIT(2)\n#define GPIO_SUPPORTED_BIT\t\t\tBIT(3)\n#define PLX_DMA_CH1_SUPPORTED_BIT\t\tBIT(4)\n#define OVERRUN_UNDERRUN_SUPPORTED_BIT\t\tBIT(5)\n#define FIFO_REG\t\t\t\t0x18\n#define TX_STATUS_COUNT_REG\t\t\t0x1c\n#define TX_LINE_VALID_COUNT_REG\t\t\t0x20,\n#define TX_LINE_INVALID_COUNT_REG\t\t0x24\n#define RX_STATUS_COUNT_REG\t\t\t0x28\n#define RX_LINE_COUNT_REG\t\t\t0x2c\n#define INTERRUPT_CONTROL_REG\t\t\t0x30\n#define FRAME_VALID_START_INTR\t\t\tBIT(0)\n#define FRAME_VALID_END_INTR\t\t\tBIT(1)\n#define TX_FIFO_EMPTY_INTR\t\t\tBIT(8)\n#define TX_FIFO_ALMOST_EMPTY_INTR\t\tBIT(9)\n#define TX_FIFO_ALMOST_FULL_INTR\t\tBIT(10)\n#define TX_FIFO_FULL_INTR\t\t\tBIT(11)\n#define RX_EMPTY_INTR\t\t\t\tBIT(12)\n#define RX_ALMOST_EMPTY_INTR\t\t\tBIT(13)\n#define RX_ALMOST_FULL_INTR\t\t\tBIT(14)\n#define RX_FULL_INTR\t\t\t\tBIT(15)\n#define INTERRUPT_STATUS_REG\t\t\t0x34\n#define TX_CLOCK_DIVIDER_REG\t\t\t0x38\n#define TX_FIFO_SIZE_REG\t\t\t0x40\n#define RX_FIFO_SIZE_REG\t\t\t0x44\n#define FIFO_SIZE_MASK\t\t\t\t(0xfffff << 0)\n#define TX_FIFO_WORDS_REG\t\t\t0x48\n#define RX_FIFO_WORDS_REG\t\t\t0x4c\n#define INTERRUPT_EDGE_LEVEL_REG\t\t0x50\n#define INTERRUPT_POLARITY_REG\t\t\t0x54\n\n#define TIMER_BASE\t\t\t\t50\t \n#define DMA_BUFFER_SIZE\t\t\t\t0x10000\n#define NUM_DMA_BUFFERS\t\t\t\t4\n#define NUM_DMA_DESCRIPTORS\t\t\t256\n\nstruct hpdi_private {\n\tvoid __iomem *plx9080_mmio;\n\tu32 *dio_buffer[NUM_DMA_BUFFERS];\t \n\t \n\tdma_addr_t dio_buffer_phys_addr[NUM_DMA_BUFFERS];\n\t \n\tstruct plx_dma_desc *dma_desc;\n\t \n\tdma_addr_t dma_desc_phys_addr;\n\tunsigned int num_dma_descriptors;\n\t \n\tu32 *desc_dio_buffer[NUM_DMA_DESCRIPTORS];\n\t \n\tunsigned int dma_desc_index;\n\tunsigned int tx_fifo_size;\n\tunsigned int rx_fifo_size;\n\tunsigned long dio_count;\n\t \n\tunsigned int block_size;\n};\n\nstatic void gsc_hpdi_drain_dma(struct comedi_device *dev, unsigned int channel)\n{\n\tstruct hpdi_private *devpriv = dev->private;\n\tstruct comedi_subdevice *s = dev->read_subdev;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tunsigned int idx;\n\tunsigned int start;\n\tunsigned int desc;\n\tunsigned int size;\n\tunsigned int next;\n\n\tnext = readl(devpriv->plx9080_mmio + PLX_REG_DMAPADR(channel));\n\n\tidx = devpriv->dma_desc_index;\n\tstart = le32_to_cpu(devpriv->dma_desc[idx].pci_start_addr);\n\t \n\tfor (desc = 0; (next < start || next >= start + devpriv->block_size) &&\n\t     desc < devpriv->num_dma_descriptors; desc++) {\n\t\t \n\t\tsize = devpriv->block_size / sizeof(u32);\n\t\tif (cmd->stop_src == TRIG_COUNT) {\n\t\t\tif (size > devpriv->dio_count)\n\t\t\t\tsize = devpriv->dio_count;\n\t\t\tdevpriv->dio_count -= size;\n\t\t}\n\t\tcomedi_buf_write_samples(s, devpriv->desc_dio_buffer[idx],\n\t\t\t\t\t size);\n\t\tidx++;\n\t\tidx %= devpriv->num_dma_descriptors;\n\t\tstart = le32_to_cpu(devpriv->dma_desc[idx].pci_start_addr);\n\n\t\tdevpriv->dma_desc_index = idx;\n\t}\n\t \n}\n\nstatic irqreturn_t gsc_hpdi_interrupt(int irq, void *d)\n{\n\tstruct comedi_device *dev = d;\n\tstruct hpdi_private *devpriv = dev->private;\n\tstruct comedi_subdevice *s = dev->read_subdev;\n\tstruct comedi_async *async = s->async;\n\tu32 hpdi_intr_status, hpdi_board_status;\n\tu32 plx_status;\n\tu32 plx_bits;\n\tu8 dma0_status, dma1_status;\n\tunsigned long flags;\n\n\tif (!dev->attached)\n\t\treturn IRQ_NONE;\n\n\tplx_status = readl(devpriv->plx9080_mmio + PLX_REG_INTCSR);\n\tif ((plx_status &\n\t     (PLX_INTCSR_DMA0IA | PLX_INTCSR_DMA1IA | PLX_INTCSR_PLIA)) == 0)\n\t\treturn IRQ_NONE;\n\n\thpdi_intr_status = readl(dev->mmio + INTERRUPT_STATUS_REG);\n\thpdi_board_status = readl(dev->mmio + BOARD_STATUS_REG);\n\n\tif (hpdi_intr_status)\n\t\twritel(hpdi_intr_status, dev->mmio + INTERRUPT_STATUS_REG);\n\n\t \n\tspin_lock_irqsave(&dev->spinlock, flags);\n\tdma0_status = readb(devpriv->plx9080_mmio + PLX_REG_DMACSR0);\n\tif (plx_status & PLX_INTCSR_DMA0IA) {\n\t\t \n\t\twriteb((dma0_status & PLX_DMACSR_ENABLE) | PLX_DMACSR_CLEARINTR,\n\t\t       devpriv->plx9080_mmio + PLX_REG_DMACSR0);\n\n\t\tif (dma0_status & PLX_DMACSR_ENABLE)\n\t\t\tgsc_hpdi_drain_dma(dev, 0);\n\t}\n\tspin_unlock_irqrestore(&dev->spinlock, flags);\n\n\t \n\tspin_lock_irqsave(&dev->spinlock, flags);\n\tdma1_status = readb(devpriv->plx9080_mmio + PLX_REG_DMACSR1);\n\tif (plx_status & PLX_INTCSR_DMA1IA) {\n\t\t   \n\t\twriteb((dma1_status & PLX_DMACSR_ENABLE) | PLX_DMACSR_CLEARINTR,\n\t\t       devpriv->plx9080_mmio + PLX_REG_DMACSR1);\n\t}\n\tspin_unlock_irqrestore(&dev->spinlock, flags);\n\n\t \n\tif (plx_status & PLX_INTCSR_LDBIA) {\n\t\t \n\t\tplx_bits = readl(devpriv->plx9080_mmio + PLX_REG_L2PDBELL);\n\t\twritel(plx_bits, devpriv->plx9080_mmio + PLX_REG_L2PDBELL);\n\t}\n\n\tif (hpdi_board_status & RX_OVERRUN_BIT) {\n\t\tdev_err(dev->class_dev, \"rx fifo overrun\\n\");\n\t\tasync->events |= COMEDI_CB_ERROR;\n\t}\n\n\tif (hpdi_board_status & RX_UNDERRUN_BIT) {\n\t\tdev_err(dev->class_dev, \"rx fifo underrun\\n\");\n\t\tasync->events |= COMEDI_CB_ERROR;\n\t}\n\n\tif (devpriv->dio_count == 0)\n\t\tasync->events |= COMEDI_CB_EOA;\n\n\tcomedi_handle_events(dev, s);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void gsc_hpdi_abort_dma(struct comedi_device *dev, unsigned int channel)\n{\n\tstruct hpdi_private *devpriv = dev->private;\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&dev->spinlock, flags);\n\n\tplx9080_abort_dma(devpriv->plx9080_mmio, channel);\n\n\tspin_unlock_irqrestore(&dev->spinlock, flags);\n}\n\nstatic int gsc_hpdi_cancel(struct comedi_device *dev,\n\t\t\t   struct comedi_subdevice *s)\n{\n\twritel(0, dev->mmio + BOARD_CONTROL_REG);\n\twritel(0, dev->mmio + INTERRUPT_CONTROL_REG);\n\n\tgsc_hpdi_abort_dma(dev, 0);\n\n\treturn 0;\n}\n\nstatic int gsc_hpdi_cmd(struct comedi_device *dev,\n\t\t\tstruct comedi_subdevice *s)\n{\n\tstruct hpdi_private *devpriv = dev->private;\n\tstruct comedi_async *async = s->async;\n\tstruct comedi_cmd *cmd = &async->cmd;\n\tunsigned long flags;\n\tu32 bits;\n\n\tif (s->io_bits)\n\t\treturn -EINVAL;\n\n\twritel(RX_FIFO_RESET_BIT, dev->mmio + BOARD_CONTROL_REG);\n\n\tgsc_hpdi_abort_dma(dev, 0);\n\n\tdevpriv->dma_desc_index = 0;\n\n\t \n\twritel(0, devpriv->plx9080_mmio + PLX_REG_DMASIZ0);\n\twritel(0, devpriv->plx9080_mmio + PLX_REG_DMAPADR0);\n\twritel(0, devpriv->plx9080_mmio + PLX_REG_DMALADR0);\n\n\t \n\tbits = devpriv->dma_desc_phys_addr | PLX_DMADPR_DESCPCI |\n\t       PLX_DMADPR_TCINTR | PLX_DMADPR_XFERL2P;\n\twritel(bits, devpriv->plx9080_mmio + PLX_REG_DMADPR0);\n\n\t \n\tspin_lock_irqsave(&dev->spinlock, flags);\n\twriteb(PLX_DMACSR_ENABLE | PLX_DMACSR_START | PLX_DMACSR_CLEARINTR,\n\t       devpriv->plx9080_mmio + PLX_REG_DMACSR0);\n\tspin_unlock_irqrestore(&dev->spinlock, flags);\n\n\tif (cmd->stop_src == TRIG_COUNT)\n\t\tdevpriv->dio_count = cmd->stop_arg;\n\telse\n\t\tdevpriv->dio_count = 1;\n\n\t \n\twritel(RX_UNDERRUN_BIT | RX_OVERRUN_BIT, dev->mmio + BOARD_STATUS_REG);\n\n\t \n\twritel(RX_FULL_INTR, dev->mmio + INTERRUPT_CONTROL_REG);\n\n\twritel(RX_ENABLE_BIT, dev->mmio + BOARD_CONTROL_REG);\n\n\treturn 0;\n}\n\nstatic int gsc_hpdi_check_chanlist(struct comedi_device *dev,\n\t\t\t\t   struct comedi_subdevice *s,\n\t\t\t\t   struct comedi_cmd *cmd)\n{\n\tint i;\n\n\tfor (i = 0; i < cmd->chanlist_len; i++) {\n\t\tunsigned int chan = CR_CHAN(cmd->chanlist[i]);\n\n\t\tif (chan != i) {\n\t\t\tdev_dbg(dev->class_dev,\n\t\t\t\t\"chanlist must be ch 0 to 31 in order\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int gsc_hpdi_cmd_test(struct comedi_device *dev,\n\t\t\t     struct comedi_subdevice *s,\n\t\t\t     struct comedi_cmd *cmd)\n{\n\tint err = 0;\n\n\tif (s->io_bits)\n\t\treturn -EINVAL;\n\n\t \n\n\terr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW);\n\terr |= comedi_check_trigger_src(&cmd->scan_begin_src, TRIG_EXT);\n\terr |= comedi_check_trigger_src(&cmd->convert_src, TRIG_NOW);\n\terr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\n\terr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\n\n\tif (err)\n\t\treturn 1;\n\n\t \n\n\terr |= comedi_check_trigger_is_unique(cmd->stop_src);\n\n\t \n\n\tif (err)\n\t\treturn 2;\n\n\t \n\n\terr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\n\n\tif (!cmd->chanlist_len || !cmd->chanlist) {\n\t\tcmd->chanlist_len = 32;\n\t\terr |= -EINVAL;\n\t}\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\n\t\t\t\t\t   cmd->chanlist_len);\n\n\tif (cmd->stop_src == TRIG_COUNT)\n\t\terr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\n\telse\t \n\t\terr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\n\n\tif (err)\n\t\treturn 3;\n\n\t \n\n\t \n\n\tif (cmd->chanlist && cmd->chanlist_len > 0)\n\t\terr |= gsc_hpdi_check_chanlist(dev, s, cmd);\n\n\tif (err)\n\t\treturn 5;\n\n\treturn 0;\n}\n\n \nstatic int gsc_hpdi_setup_dma_descriptors(struct comedi_device *dev,\n\t\t\t\t\t  unsigned int len)\n{\n\tstruct hpdi_private *devpriv = dev->private;\n\tdma_addr_t phys_addr = devpriv->dma_desc_phys_addr;\n\tu32 next_bits = PLX_DMADPR_DESCPCI | PLX_DMADPR_TCINTR |\n\t\t\tPLX_DMADPR_XFERL2P;\n\tunsigned int offset = 0;\n\tunsigned int idx = 0;\n\tunsigned int i;\n\n\tif (len > DMA_BUFFER_SIZE)\n\t\tlen = DMA_BUFFER_SIZE;\n\tlen -= len % sizeof(u32);\n\tif (len == 0)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < NUM_DMA_DESCRIPTORS && idx < NUM_DMA_BUFFERS; i++) {\n\t\tdevpriv->dma_desc[i].pci_start_addr =\n\t\t    cpu_to_le32(devpriv->dio_buffer_phys_addr[idx] + offset);\n\t\tdevpriv->dma_desc[i].local_start_addr = cpu_to_le32(FIFO_REG);\n\t\tdevpriv->dma_desc[i].transfer_size = cpu_to_le32(len);\n\t\tdevpriv->dma_desc[i].next = cpu_to_le32((phys_addr +\n\t\t\t(i + 1) * sizeof(devpriv->dma_desc[0])) | next_bits);\n\n\t\tdevpriv->desc_dio_buffer[i] = devpriv->dio_buffer[idx] +\n\t\t\t\t\t      (offset / sizeof(u32));\n\n\t\toffset += len;\n\t\tif (len + offset > DMA_BUFFER_SIZE) {\n\t\t\toffset = 0;\n\t\t\tidx++;\n\t\t}\n\t}\n\tdevpriv->num_dma_descriptors = i;\n\t \n\tdevpriv->dma_desc[i - 1].next = cpu_to_le32(phys_addr | next_bits);\n\n\tdevpriv->block_size = len;\n\n\treturn len;\n}\n\nstatic int gsc_hpdi_dio_insn_config(struct comedi_device *dev,\n\t\t\t\t    struct comedi_subdevice *s,\n\t\t\t\t    struct comedi_insn *insn,\n\t\t\t\t    unsigned int *data)\n{\n\tint ret;\n\n\tswitch (data[0]) {\n\tcase INSN_CONFIG_BLOCK_SIZE:\n\t\tret = gsc_hpdi_setup_dma_descriptors(dev, data[1]);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdata[1] = ret;\n\t\tbreak;\n\tdefault:\n\t\tret = comedi_dio_insn_config(dev, s, insn, data, 0xffffffff);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\t}\n\n\treturn insn->n;\n}\n\nstatic void gsc_hpdi_free_dma(struct comedi_device *dev)\n{\n\tstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\n\tstruct hpdi_private *devpriv = dev->private;\n\tint i;\n\n\tif (!devpriv)\n\t\treturn;\n\n\t \n\tfor (i = 0; i < NUM_DMA_BUFFERS; i++) {\n\t\tif (devpriv->dio_buffer[i])\n\t\t\tdma_free_coherent(&pcidev->dev,\n\t\t\t\t\t  DMA_BUFFER_SIZE,\n\t\t\t\t\t  devpriv->dio_buffer[i],\n\t\t\t\t\t  devpriv->dio_buffer_phys_addr[i]);\n\t}\n\t \n\tif (devpriv->dma_desc)\n\t\tdma_free_coherent(&pcidev->dev,\n\t\t\t\t  sizeof(struct plx_dma_desc) *\n\t\t\t\t  NUM_DMA_DESCRIPTORS,\n\t\t\t\t  devpriv->dma_desc,\n\t\t\t\t  devpriv->dma_desc_phys_addr);\n}\n\nstatic int gsc_hpdi_init(struct comedi_device *dev)\n{\n\tstruct hpdi_private *devpriv = dev->private;\n\tu32 plx_intcsr_bits;\n\n\t \n\twritel(BOARD_RESET_BIT, dev->mmio + BOARD_CONTROL_REG);\n\tusleep_range(10, 1000);\n\n\twritel(ALMOST_EMPTY_BITS(32) | ALMOST_FULL_BITS(32),\n\t       dev->mmio + RX_PROG_ALMOST_REG);\n\twritel(ALMOST_EMPTY_BITS(32) | ALMOST_FULL_BITS(32),\n\t       dev->mmio + TX_PROG_ALMOST_REG);\n\n\tdevpriv->tx_fifo_size = readl(dev->mmio + TX_FIFO_SIZE_REG) &\n\t\t\t\tFIFO_SIZE_MASK;\n\tdevpriv->rx_fifo_size = readl(dev->mmio + RX_FIFO_SIZE_REG) &\n\t\t\t\tFIFO_SIZE_MASK;\n\n\twritel(0, dev->mmio + INTERRUPT_CONTROL_REG);\n\n\t \n\tplx_intcsr_bits =\n\t    PLX_INTCSR_LSEABORTEN | PLX_INTCSR_LSEPARITYEN | PLX_INTCSR_PIEN |\n\t    PLX_INTCSR_PLIEN | PLX_INTCSR_PABORTIEN | PLX_INTCSR_LIOEN |\n\t    PLX_INTCSR_DMA0IEN;\n\twritel(plx_intcsr_bits, devpriv->plx9080_mmio + PLX_REG_INTCSR);\n\n\treturn 0;\n}\n\nstatic void gsc_hpdi_init_plx9080(struct comedi_device *dev)\n{\n\tstruct hpdi_private *devpriv = dev->private;\n\tu32 bits;\n\tvoid __iomem *plx_iobase = devpriv->plx9080_mmio;\n\n#ifdef __BIG_ENDIAN\n\tbits = PLX_BIGEND_DMA0 | PLX_BIGEND_DMA1;\n#else\n\tbits = 0;\n#endif\n\twritel(bits, devpriv->plx9080_mmio + PLX_REG_BIGEND);\n\n\twritel(0, devpriv->plx9080_mmio + PLX_REG_INTCSR);\n\n\tgsc_hpdi_abort_dma(dev, 0);\n\tgsc_hpdi_abort_dma(dev, 1);\n\n\t \n\tbits = 0;\n\t \n\tbits |= PLX_DMAMODE_READYIEN;\n\t \n\tbits |= PLX_DMAMODE_CHAINEN;\n\t \n\tbits |= PLX_DMAMODE_DONEIEN;\n\t \n\tbits |= PLX_DMAMODE_LACONST;\n\t \n\tbits |= PLX_DMAMODE_INTRPCI;\n\t \n\tbits |= PLX_DMAMODE_DEMAND;\n\t \n\tbits |= PLX_DMAMODE_BURSTEN;\n\tbits |= PLX_DMAMODE_WIDTH_32;\n\twritel(bits, plx_iobase + PLX_REG_DMAMODE0);\n}\n\nstatic int gsc_hpdi_auto_attach(struct comedi_device *dev,\n\t\t\t\tunsigned long context_unused)\n{\n\tstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\n\tstruct hpdi_private *devpriv;\n\tstruct comedi_subdevice *s;\n\tint i;\n\tint retval;\n\n\tdev->board_name = \"pci-hpdi32\";\n\n\tdevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\n\tif (!devpriv)\n\t\treturn -ENOMEM;\n\n\tretval = comedi_pci_enable(dev);\n\tif (retval)\n\t\treturn retval;\n\tpci_set_master(pcidev);\n\n\tdevpriv->plx9080_mmio = pci_ioremap_bar(pcidev, 0);\n\tdev->mmio = pci_ioremap_bar(pcidev, 2);\n\tif (!devpriv->plx9080_mmio || !dev->mmio) {\n\t\tdev_warn(dev->class_dev, \"failed to remap io memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tgsc_hpdi_init_plx9080(dev);\n\n\t \n\tif (request_irq(pcidev->irq, gsc_hpdi_interrupt, IRQF_SHARED,\n\t\t\tdev->board_name, dev)) {\n\t\tdev_warn(dev->class_dev,\n\t\t\t \"unable to allocate irq %u\\n\", pcidev->irq);\n\t\treturn -EINVAL;\n\t}\n\tdev->irq = pcidev->irq;\n\n\tdev_dbg(dev->class_dev, \" irq %u\\n\", dev->irq);\n\n\t \n\tfor (i = 0; i < NUM_DMA_BUFFERS; i++) {\n\t\tdevpriv->dio_buffer[i] =\n\t\t    dma_alloc_coherent(&pcidev->dev, DMA_BUFFER_SIZE,\n\t\t\t\t       &devpriv->dio_buffer_phys_addr[i],\n\t\t\t\t       GFP_KERNEL);\n\t\tif (!devpriv->dio_buffer[i]) {\n\t\t\tdev_warn(dev->class_dev,\n\t\t\t\t \"failed to allocate DMA buffer\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\t \n\tdevpriv->dma_desc = dma_alloc_coherent(&pcidev->dev,\n\t\t\t\t\t       sizeof(struct plx_dma_desc) *\n\t\t\t\t\t       NUM_DMA_DESCRIPTORS,\n\t\t\t\t\t       &devpriv->dma_desc_phys_addr,\n\t\t\t\t\t       GFP_KERNEL);\n\tif (!devpriv->dma_desc) {\n\t\tdev_warn(dev->class_dev,\n\t\t\t \"failed to allocate DMA descriptors\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tif (devpriv->dma_desc_phys_addr & 0xf) {\n\t\tdev_warn(dev->class_dev,\n\t\t\t \" dma descriptors not quad-word aligned (bug)\\n\");\n\t\treturn -EIO;\n\t}\n\n\tretval = gsc_hpdi_setup_dma_descriptors(dev, 0x1000);\n\tif (retval < 0)\n\t\treturn retval;\n\n\tretval = comedi_alloc_subdevices(dev, 1);\n\tif (retval)\n\t\treturn retval;\n\n\t \n\ts = &dev->subdevices[0];\n\tdev->read_subdev = s;\n\ts->type\t\t= COMEDI_SUBD_DIO;\n\ts->subdev_flags\t= SDF_READABLE | SDF_WRITABLE | SDF_LSAMPL |\n\t\t\t  SDF_CMD_READ;\n\ts->n_chan\t= 32;\n\ts->len_chanlist\t= 32;\n\ts->maxdata\t= 1;\n\ts->range_table\t= &range_digital;\n\ts->insn_config\t= gsc_hpdi_dio_insn_config;\n\ts->do_cmd\t= gsc_hpdi_cmd;\n\ts->do_cmdtest\t= gsc_hpdi_cmd_test;\n\ts->cancel\t= gsc_hpdi_cancel;\n\n\treturn gsc_hpdi_init(dev);\n}\n\nstatic void gsc_hpdi_detach(struct comedi_device *dev)\n{\n\tstruct hpdi_private *devpriv = dev->private;\n\n\tif (dev->irq)\n\t\tfree_irq(dev->irq, dev);\n\tif (devpriv) {\n\t\tif (devpriv->plx9080_mmio) {\n\t\t\twritel(0, devpriv->plx9080_mmio + PLX_REG_INTCSR);\n\t\t\tiounmap(devpriv->plx9080_mmio);\n\t\t}\n\t\tif (dev->mmio)\n\t\t\tiounmap(dev->mmio);\n\t}\n\tcomedi_pci_disable(dev);\n\tgsc_hpdi_free_dma(dev);\n}\n\nstatic struct comedi_driver gsc_hpdi_driver = {\n\t.driver_name\t= \"gsc_hpdi\",\n\t.module\t\t= THIS_MODULE,\n\t.auto_attach\t= gsc_hpdi_auto_attach,\n\t.detach\t\t= gsc_hpdi_detach,\n};\n\nstatic int gsc_hpdi_pci_probe(struct pci_dev *dev,\n\t\t\t      const struct pci_device_id *id)\n{\n\treturn comedi_pci_auto_config(dev, &gsc_hpdi_driver, id->driver_data);\n}\n\nstatic const struct pci_device_id gsc_hpdi_pci_table[] = {\n\t{ PCI_DEVICE_SUB(PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9080,\n\t\t\t PCI_VENDOR_ID_PLX, 0x2400) },\n\t{ 0 }\n};\nMODULE_DEVICE_TABLE(pci, gsc_hpdi_pci_table);\n\nstatic struct pci_driver gsc_hpdi_pci_driver = {\n\t.name\t\t= \"gsc_hpdi\",\n\t.id_table\t= gsc_hpdi_pci_table,\n\t.probe\t\t= gsc_hpdi_pci_probe,\n\t.remove\t\t= comedi_pci_auto_unconfig,\n};\nmodule_comedi_pci_driver(gsc_hpdi_driver, gsc_hpdi_pci_driver);\n\nMODULE_AUTHOR(\"Comedi https://www.comedi.org\");\nMODULE_DESCRIPTION(\"Comedi driver for General Standards PCI-HPDI32/PMC-HPDI32\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}