{
  "module_name": "usbdux.c",
  "hash_id": "c9799f0c3265415455cd9600e20ae6045e1ba526fab8ae7204e2ad16d3195664",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/usbdux.c",
  "human_readable_source": "\n \n\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/input.h>\n#include <linux/fcntl.h>\n#include <linux/compiler.h>\n#include <linux/comedi/comedi_usb.h>\n\n \n#define USBDUX_FIRMWARE\t\t\"usbdux_firmware.bin\"\n#define USBDUX_FIRMWARE_MAX_LEN\t0x2000\n#define USBDUX_FIRMWARE_CMD\t0xa0\n#define VENDOR_DIR_IN\t\t0xc0\n#define VENDOR_DIR_OUT\t\t0x40\n#define USBDUX_CPU_CS\t\t0xe600\n\n \n#define USBDUX_CMD_MULT_AI\t0\n#define USBDUX_CMD_AO\t\t1\n#define USBDUX_CMD_DIO_CFG\t2\n#define USBDUX_CMD_DIO_BITS\t3\n#define USBDUX_CMD_SINGLE_AI\t4\n#define USBDUX_CMD_TIMER_RD\t5\n#define USBDUX_CMD_TIMER_WR\t6\n#define USBDUX_CMD_PWM_ON\t7\n#define USBDUX_CMD_PWM_OFF\t8\n\n \n#define BULK_TIMEOUT\t\t1000\n\n \n#define MIN_PWM_PERIOD\t\t((long)(1E9 / 300))\n\n \n#define PWM_DEFAULT_PERIOD\t((long)(1E9 / 100))\n\n \n#define SIZEADIN\t\t((sizeof(u16)))\n\n \n#define SIZEINBUF\t\t(8 * SIZEADIN)\n\n \n#define SIZEINSNBUF\t\t16\n\n \n#define SIZEDAOUT\t\t((sizeof(u8) + sizeof(u16)))\n\n \n#define SIZEOUTBUF\t\t(8 * SIZEDAOUT)\n\n \n#define SIZEOFDUXBUFFER\t\t(8 * SIZEDAOUT + 2)\n\n \n#define NUMOFINBUFFERSFULL\t5\n\n \n#define NUMOFOUTBUFFERSFULL\t5\n\n \n \n#define NUMOFINBUFFERSHIGH\t10\n\n \n \n#define NUMOFOUTBUFFERSHIGH\t10\n\n \n#define RETRIES\t\t\t10\n\nstatic const struct comedi_lrange range_usbdux_ai_range = {\n\t4, {\n\t\tBIP_RANGE(4.096),\n\t\tBIP_RANGE(4.096 / 2),\n\t\tUNI_RANGE(4.096),\n\t\tUNI_RANGE(4.096 / 2)\n\t}\n};\n\nstatic const struct comedi_lrange range_usbdux_ao_range = {\n\t2, {\n\t\tBIP_RANGE(4.096),\n\t\tUNI_RANGE(4.096)\n\t}\n};\n\nstruct usbdux_private {\n\t \n\tint n_ai_urbs;\n\t \n\tint n_ao_urbs;\n\t \n\tstruct urb **ai_urbs;\n\tstruct urb **ao_urbs;\n\t \n\tstruct urb *pwm_urb;\n\t \n\tunsigned int pwm_period;\n\t \n\tu8 pwm_delay;\n\t \n\tint pwm_buf_sz;\n\t \n\t__le16 *in_buf;\n\t \n\t__le16 *insn_buf;\n\n\tunsigned int high_speed:1;\n\tunsigned int ai_cmd_running:1;\n\tunsigned int ao_cmd_running:1;\n\tunsigned int pwm_cmd_running:1;\n\n\t \n\tunsigned int ai_timer;\n\tunsigned int ao_timer;\n\t \n\tunsigned int ai_counter;\n\tunsigned int ao_counter;\n\t \n\tunsigned int ai_interval;\n\t \n\tu8 *dux_commands;\n\tstruct mutex mut;\n};\n\nstatic void usbdux_unlink_urbs(struct urb **urbs, int num_urbs)\n{\n\tint i;\n\n\tfor (i = 0; i < num_urbs; i++)\n\t\tusb_kill_urb(urbs[i]);\n}\n\nstatic void usbdux_ai_stop(struct comedi_device *dev, int do_unlink)\n{\n\tstruct usbdux_private *devpriv = dev->private;\n\n\tif (do_unlink && devpriv->ai_urbs)\n\t\tusbdux_unlink_urbs(devpriv->ai_urbs, devpriv->n_ai_urbs);\n\n\tdevpriv->ai_cmd_running = 0;\n}\n\nstatic int usbdux_ai_cancel(struct comedi_device *dev,\n\t\t\t    struct comedi_subdevice *s)\n{\n\tstruct usbdux_private *devpriv = dev->private;\n\n\t \n\tmutex_lock(&devpriv->mut);\n\t \n\tusbdux_ai_stop(dev, devpriv->ai_cmd_running);\n\tmutex_unlock(&devpriv->mut);\n\n\treturn 0;\n}\n\nstatic void usbduxsub_ai_handle_urb(struct comedi_device *dev,\n\t\t\t\t    struct comedi_subdevice *s,\n\t\t\t\t    struct urb *urb)\n{\n\tstruct usbdux_private *devpriv = dev->private;\n\tstruct comedi_async *async = s->async;\n\tstruct comedi_cmd *cmd = &async->cmd;\n\tint ret;\n\tint i;\n\n\tdevpriv->ai_counter--;\n\tif (devpriv->ai_counter == 0) {\n\t\tdevpriv->ai_counter = devpriv->ai_timer;\n\n\t\t \n\t\tfor (i = 0; i < cmd->chanlist_len; i++) {\n\t\t\tunsigned int range = CR_RANGE(cmd->chanlist[i]);\n\t\t\tu16 val = le16_to_cpu(devpriv->in_buf[i]);\n\n\t\t\t \n\t\t\tif (comedi_range_is_bipolar(s, range))\n\t\t\t\tval = comedi_offset_munge(s, val);\n\n\t\t\t \n\t\t\tif (!comedi_buf_write_samples(s, &val, 1))\n\t\t\t\treturn;\n\t\t}\n\n\t\tif (cmd->stop_src == TRIG_COUNT &&\n\t\t    async->scans_done >= cmd->stop_arg)\n\t\t\tasync->events |= COMEDI_CB_EOA;\n\t}\n\n\t \n\tif (!(async->events & COMEDI_CB_CANCEL_MASK)) {\n\t\turb->dev = comedi_to_usb_dev(dev);\n\t\tret = usb_submit_urb(urb, GFP_ATOMIC);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev->class_dev,\n\t\t\t\t\"urb resubmit failed in int-context! err=%d\\n\",\n\t\t\t\tret);\n\t\t\tif (ret == -EL2NSYNC)\n\t\t\t\tdev_err(dev->class_dev,\n\t\t\t\t\t\"buggy USB host controller or bug in IRQ handler!\\n\");\n\t\t\tasync->events |= COMEDI_CB_ERROR;\n\t\t}\n\t}\n}\n\nstatic void usbduxsub_ai_isoc_irq(struct urb *urb)\n{\n\tstruct comedi_device *dev = urb->context;\n\tstruct comedi_subdevice *s = dev->read_subdev;\n\tstruct comedi_async *async = s->async;\n\tstruct usbdux_private *devpriv = dev->private;\n\n\t \n\tif (!devpriv->ai_cmd_running)\n\t\treturn;\n\n\tswitch (urb->status) {\n\tcase 0:\n\t\t \n\t\tmemcpy(devpriv->in_buf, urb->transfer_buffer, SIZEINBUF);\n\t\tusbduxsub_ai_handle_urb(dev, s, urb);\n\t\tbreak;\n\n\tcase -EILSEQ:\n\t\t \n\t\tdev_dbg(dev->class_dev, \"CRC error in ISO IN stream\\n\");\n\t\tusbduxsub_ai_handle_urb(dev, s, urb);\n\t\tbreak;\n\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\tcase -ECONNABORTED:\n\t\t \n\t\tasync->events |= COMEDI_CB_ERROR;\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tdev_err(dev->class_dev,\n\t\t\t\"Non-zero urb status received in ai intr context: %d\\n\",\n\t\t\turb->status);\n\t\tasync->events |= COMEDI_CB_ERROR;\n\t\tbreak;\n\t}\n\n\t \n\tif (async->events & COMEDI_CB_CANCEL_MASK)\n\t\tusbdux_ai_stop(dev, 0);\n\n\tcomedi_event(dev, s);\n}\n\nstatic void usbdux_ao_stop(struct comedi_device *dev, int do_unlink)\n{\n\tstruct usbdux_private *devpriv = dev->private;\n\n\tif (do_unlink && devpriv->ao_urbs)\n\t\tusbdux_unlink_urbs(devpriv->ao_urbs, devpriv->n_ao_urbs);\n\n\tdevpriv->ao_cmd_running = 0;\n}\n\nstatic int usbdux_ao_cancel(struct comedi_device *dev,\n\t\t\t    struct comedi_subdevice *s)\n{\n\tstruct usbdux_private *devpriv = dev->private;\n\n\t \n\tmutex_lock(&devpriv->mut);\n\t \n\tusbdux_ao_stop(dev, devpriv->ao_cmd_running);\n\tmutex_unlock(&devpriv->mut);\n\n\treturn 0;\n}\n\nstatic void usbduxsub_ao_handle_urb(struct comedi_device *dev,\n\t\t\t\t    struct comedi_subdevice *s,\n\t\t\t\t    struct urb *urb)\n{\n\tstruct usbdux_private *devpriv = dev->private;\n\tstruct comedi_async *async = s->async;\n\tstruct comedi_cmd *cmd = &async->cmd;\n\tu8 *datap;\n\tint ret;\n\tint i;\n\n\tdevpriv->ao_counter--;\n\tif (devpriv->ao_counter == 0) {\n\t\tdevpriv->ao_counter = devpriv->ao_timer;\n\n\t\tif (cmd->stop_src == TRIG_COUNT &&\n\t\t    async->scans_done >= cmd->stop_arg) {\n\t\t\tasync->events |= COMEDI_CB_EOA;\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tdatap = urb->transfer_buffer;\n\t\t*datap++ = cmd->chanlist_len;\n\t\tfor (i = 0; i < cmd->chanlist_len; i++) {\n\t\t\tunsigned int chan = CR_CHAN(cmd->chanlist[i]);\n\t\t\tunsigned short val;\n\n\t\t\tif (!comedi_buf_read_samples(s, &val, 1)) {\n\t\t\t\tdev_err(dev->class_dev, \"buffer underflow\\n\");\n\t\t\t\tasync->events |= COMEDI_CB_OVERFLOW;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t \n\t\t\t*datap++ = val & 0xff;\n\t\t\t*datap++ = (val >> 8) & 0xff;\n\t\t\t*datap++ = chan << 6;\n\t\t\ts->readback[chan] = val;\n\t\t}\n\t}\n\n\t \n\tif (!(async->events & COMEDI_CB_CANCEL_MASK)) {\n\t\turb->transfer_buffer_length = SIZEOUTBUF;\n\t\turb->dev = comedi_to_usb_dev(dev);\n\t\turb->status = 0;\n\t\tif (devpriv->high_speed)\n\t\t\turb->interval = 8;\t \n\t\telse\n\t\t\turb->interval = 1;\t \n\t\turb->number_of_packets = 1;\n\t\turb->iso_frame_desc[0].offset = 0;\n\t\turb->iso_frame_desc[0].length = SIZEOUTBUF;\n\t\turb->iso_frame_desc[0].status = 0;\n\t\tret = usb_submit_urb(urb, GFP_ATOMIC);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev->class_dev,\n\t\t\t\t\"ao urb resubm failed in int-cont. ret=%d\",\n\t\t\t\tret);\n\t\t\tif (ret == -EL2NSYNC)\n\t\t\t\tdev_err(dev->class_dev,\n\t\t\t\t\t\"buggy USB host controller or bug in IRQ handling!\\n\");\n\t\t\tasync->events |= COMEDI_CB_ERROR;\n\t\t}\n\t}\n}\n\nstatic void usbduxsub_ao_isoc_irq(struct urb *urb)\n{\n\tstruct comedi_device *dev = urb->context;\n\tstruct comedi_subdevice *s = dev->write_subdev;\n\tstruct comedi_async *async = s->async;\n\tstruct usbdux_private *devpriv = dev->private;\n\n\t \n\tif (!devpriv->ao_cmd_running)\n\t\treturn;\n\n\tswitch (urb->status) {\n\tcase 0:\n\t\tusbduxsub_ao_handle_urb(dev, s, urb);\n\t\tbreak;\n\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\tcase -ECONNABORTED:\n\t\t \n\t\tasync->events |= COMEDI_CB_ERROR;\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tdev_err(dev->class_dev,\n\t\t\t\"Non-zero urb status received in ao intr context: %d\\n\",\n\t\t\turb->status);\n\t\tasync->events |= COMEDI_CB_ERROR;\n\t\tbreak;\n\t}\n\n\t \n\tif (async->events & COMEDI_CB_CANCEL_MASK)\n\t\tusbdux_ao_stop(dev, 0);\n\n\tcomedi_event(dev, s);\n}\n\nstatic int usbdux_submit_urbs(struct comedi_device *dev,\n\t\t\t      struct urb **urbs, int num_urbs,\n\t\t\t      int input_urb)\n{\n\tstruct usb_device *usb = comedi_to_usb_dev(dev);\n\tstruct usbdux_private *devpriv = dev->private;\n\tstruct urb *urb;\n\tint ret;\n\tint i;\n\n\t \n\tfor (i = 0; i < num_urbs; i++) {\n\t\turb = urbs[i];\n\n\t\t \n\t\tif (input_urb)\n\t\t\turb->interval = devpriv->ai_interval;\n\t\turb->context = dev;\n\t\turb->dev = usb;\n\t\turb->status = 0;\n\t\turb->transfer_flags = URB_ISO_ASAP;\n\n\t\tret = usb_submit_urb(urb, GFP_ATOMIC);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int usbdux_ai_cmdtest(struct comedi_device *dev,\n\t\t\t     struct comedi_subdevice *s, struct comedi_cmd *cmd)\n{\n\tstruct usbdux_private *devpriv = dev->private;\n\tint err = 0;\n\n\t \n\n\terr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_INT);\n\terr |= comedi_check_trigger_src(&cmd->scan_begin_src, TRIG_TIMER);\n\terr |= comedi_check_trigger_src(&cmd->convert_src, TRIG_NOW);\n\terr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\n\terr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\n\n\tif (err)\n\t\treturn 1;\n\n\t \n\n\terr |= comedi_check_trigger_is_unique(cmd->start_src);\n\terr |= comedi_check_trigger_is_unique(cmd->stop_src);\n\n\t \n\n\tif (err)\n\t\treturn 2;\n\n\t \n\n\terr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\n\n\tif (cmd->scan_begin_src == TRIG_FOLLOW)\t \n\t\terr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);\n\n\tif (cmd->scan_begin_src == TRIG_TIMER) {\n\t\t \n\t\tunsigned int arg = 1000000;\n\t\tunsigned int min_arg = arg;\n\n\t\tif (devpriv->high_speed) {\n\t\t\t \n\t\t\tint i = 1;\n\n\t\t\t \n\t\t\twhile (i < cmd->chanlist_len)\n\t\t\t\ti = i * 2;\n\n\t\t\targ /= 8;\n\t\t\tmin_arg = arg * i;\n\t\t}\n\t\terr |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,\n\t\t\t\t\t\t    min_arg);\n\t\t \n\t\targ = (cmd->scan_begin_arg / arg) * arg;\n\t\terr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, arg);\n\t}\n\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\n\t\t\t\t\t   cmd->chanlist_len);\n\n\tif (cmd->stop_src == TRIG_COUNT)\n\t\terr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\n\telse\t \n\t\terr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\n\n\tif (err)\n\t\treturn 3;\n\n\treturn 0;\n}\n\n \nstatic u8 create_adc_command(unsigned int chan, unsigned int range)\n{\n\tu8 p = (range <= 1);\n\tu8 r = ((range % 2) == 0);\n\n\treturn (chan << 4) | ((p == 1) << 2) | ((r == 1) << 3);\n}\n\nstatic int send_dux_commands(struct comedi_device *dev, unsigned int cmd_type)\n{\n\tstruct usb_device *usb = comedi_to_usb_dev(dev);\n\tstruct usbdux_private *devpriv = dev->private;\n\tint nsent;\n\n\tdevpriv->dux_commands[0] = cmd_type;\n\n\treturn usb_bulk_msg(usb, usb_sndbulkpipe(usb, 1),\n\t\t\t    devpriv->dux_commands, SIZEOFDUXBUFFER,\n\t\t\t    &nsent, BULK_TIMEOUT);\n}\n\nstatic int receive_dux_commands(struct comedi_device *dev, unsigned int command)\n{\n\tstruct usb_device *usb = comedi_to_usb_dev(dev);\n\tstruct usbdux_private *devpriv = dev->private;\n\tint ret;\n\tint nrec;\n\tint i;\n\n\tfor (i = 0; i < RETRIES; i++) {\n\t\tret = usb_bulk_msg(usb, usb_rcvbulkpipe(usb, 8),\n\t\t\t\t   devpriv->insn_buf, SIZEINSNBUF,\n\t\t\t\t   &nrec, BULK_TIMEOUT);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (le16_to_cpu(devpriv->insn_buf[0]) == command)\n\t\t\treturn ret;\n\t}\n\t \n\treturn -EFAULT;\n}\n\nstatic int usbdux_ai_inttrig(struct comedi_device *dev,\n\t\t\t     struct comedi_subdevice *s,\n\t\t\t     unsigned int trig_num)\n{\n\tstruct usbdux_private *devpriv = dev->private;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tint ret;\n\n\tif (trig_num != cmd->start_arg)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&devpriv->mut);\n\n\tif (!devpriv->ai_cmd_running) {\n\t\tdevpriv->ai_cmd_running = 1;\n\t\tret = usbdux_submit_urbs(dev, devpriv->ai_urbs,\n\t\t\t\t\t devpriv->n_ai_urbs, 1);\n\t\tif (ret < 0) {\n\t\t\tdevpriv->ai_cmd_running = 0;\n\t\t\tgoto ai_trig_exit;\n\t\t}\n\t\ts->async->inttrig = NULL;\n\t} else {\n\t\tret = -EBUSY;\n\t}\n\nai_trig_exit:\n\tmutex_unlock(&devpriv->mut);\n\treturn ret;\n}\n\nstatic int usbdux_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\n{\n\tstruct usbdux_private *devpriv = dev->private;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tint len = cmd->chanlist_len;\n\tint ret = -EBUSY;\n\tint i;\n\n\t \n\tmutex_lock(&devpriv->mut);\n\n\tif (devpriv->ai_cmd_running)\n\t\tgoto ai_cmd_exit;\n\n\tdevpriv->dux_commands[1] = len;\n\tfor (i = 0; i < len; ++i) {\n\t\tunsigned int chan = CR_CHAN(cmd->chanlist[i]);\n\t\tunsigned int range = CR_RANGE(cmd->chanlist[i]);\n\n\t\tdevpriv->dux_commands[i + 2] = create_adc_command(chan, range);\n\t}\n\n\tret = send_dux_commands(dev, USBDUX_CMD_MULT_AI);\n\tif (ret < 0)\n\t\tgoto ai_cmd_exit;\n\n\tif (devpriv->high_speed) {\n\t\t \n\t\tdevpriv->ai_interval = 1;\n\t\t \n\t\twhile (devpriv->ai_interval < len)\n\t\t\tdevpriv->ai_interval *= 2;\n\n\t\tdevpriv->ai_timer = cmd->scan_begin_arg /\n\t\t\t\t    (125000 * devpriv->ai_interval);\n\t} else {\n\t\t \n\t\tdevpriv->ai_interval = 1;\n\t\tdevpriv->ai_timer = cmd->scan_begin_arg / 1000000;\n\t}\n\tif (devpriv->ai_timer < 1) {\n\t\tret = -EINVAL;\n\t\tgoto ai_cmd_exit;\n\t}\n\n\tdevpriv->ai_counter = devpriv->ai_timer;\n\n\tif (cmd->start_src == TRIG_NOW) {\n\t\t \n\t\tdevpriv->ai_cmd_running = 1;\n\t\tret = usbdux_submit_urbs(dev, devpriv->ai_urbs,\n\t\t\t\t\t devpriv->n_ai_urbs, 1);\n\t\tif (ret < 0) {\n\t\t\tdevpriv->ai_cmd_running = 0;\n\t\t\t \n\t\t\tgoto ai_cmd_exit;\n\t\t}\n\t\ts->async->inttrig = NULL;\n\t} else {\n\t\t \n\t\t \n\t\t \n\t\ts->async->inttrig = usbdux_ai_inttrig;\n\t}\n\nai_cmd_exit:\n\tmutex_unlock(&devpriv->mut);\n\n\treturn ret;\n}\n\n \nstatic int usbdux_ai_insn_read(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       struct comedi_insn *insn,\n\t\t\t       unsigned int *data)\n{\n\tstruct usbdux_private *devpriv = dev->private;\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int range = CR_RANGE(insn->chanspec);\n\tunsigned int val;\n\tint ret = -EBUSY;\n\tint i;\n\n\tmutex_lock(&devpriv->mut);\n\n\tif (devpriv->ai_cmd_running)\n\t\tgoto ai_read_exit;\n\n\t \n\tdevpriv->dux_commands[1] = create_adc_command(chan, range);\n\n\t \n\tret = send_dux_commands(dev, USBDUX_CMD_SINGLE_AI);\n\tif (ret < 0)\n\t\tgoto ai_read_exit;\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\tret = receive_dux_commands(dev, USBDUX_CMD_SINGLE_AI);\n\t\tif (ret < 0)\n\t\t\tgoto ai_read_exit;\n\n\t\tval = le16_to_cpu(devpriv->insn_buf[1]);\n\n\t\t \n\t\tif (comedi_range_is_bipolar(s, range))\n\t\t\tval = comedi_offset_munge(s, val);\n\n\t\tdata[i] = val;\n\t}\n\nai_read_exit:\n\tmutex_unlock(&devpriv->mut);\n\n\treturn ret ? ret : insn->n;\n}\n\nstatic int usbdux_ao_insn_read(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       struct comedi_insn *insn,\n\t\t\t       unsigned int *data)\n{\n\tstruct usbdux_private *devpriv = dev->private;\n\tint ret;\n\n\tmutex_lock(&devpriv->mut);\n\tret = comedi_readback_insn_read(dev, s, insn, data);\n\tmutex_unlock(&devpriv->mut);\n\n\treturn ret;\n}\n\nstatic int usbdux_ao_insn_write(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tstruct comedi_insn *insn,\n\t\t\t\tunsigned int *data)\n{\n\tstruct usbdux_private *devpriv = dev->private;\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\t__le16 *p = (__le16 *)&devpriv->dux_commands[2];\n\tint ret = -EBUSY;\n\tint i;\n\n\tmutex_lock(&devpriv->mut);\n\n\tif (devpriv->ao_cmd_running)\n\t\tgoto ao_write_exit;\n\n\t \n\tdevpriv->dux_commands[1] = 1;\n\t \n\tdevpriv->dux_commands[4] = chan << 6;\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\tunsigned int val = data[i];\n\n\t\t \n\t\t*p = cpu_to_le16(val);\n\n\t\tret = send_dux_commands(dev, USBDUX_CMD_AO);\n\t\tif (ret < 0)\n\t\t\tgoto ao_write_exit;\n\n\t\ts->readback[chan] = val;\n\t}\n\nao_write_exit:\n\tmutex_unlock(&devpriv->mut);\n\n\treturn ret ? ret : insn->n;\n}\n\nstatic int usbdux_ao_inttrig(struct comedi_device *dev,\n\t\t\t     struct comedi_subdevice *s,\n\t\t\t     unsigned int trig_num)\n{\n\tstruct usbdux_private *devpriv = dev->private;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tint ret;\n\n\tif (trig_num != cmd->start_arg)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&devpriv->mut);\n\n\tif (!devpriv->ao_cmd_running) {\n\t\tdevpriv->ao_cmd_running = 1;\n\t\tret = usbdux_submit_urbs(dev, devpriv->ao_urbs,\n\t\t\t\t\t devpriv->n_ao_urbs, 0);\n\t\tif (ret < 0) {\n\t\t\tdevpriv->ao_cmd_running = 0;\n\t\t\tgoto ao_trig_exit;\n\t\t}\n\t\ts->async->inttrig = NULL;\n\t} else {\n\t\tret = -EBUSY;\n\t}\n\nao_trig_exit:\n\tmutex_unlock(&devpriv->mut);\n\treturn ret;\n}\n\nstatic int usbdux_ao_cmdtest(struct comedi_device *dev,\n\t\t\t     struct comedi_subdevice *s, struct comedi_cmd *cmd)\n{\n\tint err = 0;\n\tunsigned int flags;\n\n\t \n\n\terr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_INT);\n\n\tif (0) {\t\t \n\t\t \n\t\tflags = TRIG_FOLLOW;\n\t} else {\n\t\t \n\t\tflags = TRIG_TIMER;\n\t}\n\terr |= comedi_check_trigger_src(&cmd->scan_begin_src, flags);\n\n\tif (0) {\t\t \n\t\t \n\t\tflags = TRIG_TIMER;\n\t} else {\n\t\t \n\t\tflags = TRIG_NOW;\n\t}\n\terr |= comedi_check_trigger_src(&cmd->convert_src, flags);\n\n\terr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\n\terr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\n\n\tif (err)\n\t\treturn 1;\n\n\t \n\n\terr |= comedi_check_trigger_is_unique(cmd->start_src);\n\terr |= comedi_check_trigger_is_unique(cmd->stop_src);\n\n\t \n\n\tif (err)\n\t\treturn 2;\n\n\t \n\n\terr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\n\n\tif (cmd->scan_begin_src == TRIG_FOLLOW)\t \n\t\terr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);\n\n\tif (cmd->scan_begin_src == TRIG_TIMER) {\n\t\terr |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,\n\t\t\t\t\t\t    1000000);\n\t}\n\n\t \n\tif (cmd->convert_src == TRIG_TIMER)\n\t\terr |= comedi_check_trigger_arg_min(&cmd->convert_arg, 125000);\n\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\n\t\t\t\t\t   cmd->chanlist_len);\n\n\tif (cmd->stop_src == TRIG_COUNT)\n\t\terr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\n\telse\t \n\t\terr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\n\n\tif (err)\n\t\treturn 3;\n\n\treturn 0;\n}\n\nstatic int usbdux_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\n{\n\tstruct usbdux_private *devpriv = dev->private;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tint ret = -EBUSY;\n\n\tmutex_lock(&devpriv->mut);\n\n\tif (devpriv->ao_cmd_running)\n\t\tgoto ao_cmd_exit;\n\n\t \n\t \n\tif (0) {\t\t \n\t\t \n\t\t \n\t\tdevpriv->ao_timer = cmd->convert_arg / 125000;\n\t} else {\n\t\t \n\t\t \n\t\tdevpriv->ao_timer = cmd->scan_begin_arg / 1000000;\n\t\tif (devpriv->ao_timer < 1) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto ao_cmd_exit;\n\t\t}\n\t}\n\n\tdevpriv->ao_counter = devpriv->ao_timer;\n\n\tif (cmd->start_src == TRIG_NOW) {\n\t\t \n\t\tdevpriv->ao_cmd_running = 1;\n\t\tret = usbdux_submit_urbs(dev, devpriv->ao_urbs,\n\t\t\t\t\t devpriv->n_ao_urbs, 0);\n\t\tif (ret < 0) {\n\t\t\tdevpriv->ao_cmd_running = 0;\n\t\t\t \n\t\t\tgoto ao_cmd_exit;\n\t\t}\n\t\ts->async->inttrig = NULL;\n\t} else {\n\t\t \n\t\t \n\t\t \n\t\ts->async->inttrig = usbdux_ao_inttrig;\n\t}\n\nao_cmd_exit:\n\tmutex_unlock(&devpriv->mut);\n\n\treturn ret;\n}\n\nstatic int usbdux_dio_insn_config(struct comedi_device *dev,\n\t\t\t\t  struct comedi_subdevice *s,\n\t\t\t\t  struct comedi_insn *insn,\n\t\t\t\t  unsigned int *data)\n{\n\tint ret;\n\n\tret = comedi_dio_insn_config(dev, s, insn, data, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn insn->n;\n}\n\nstatic int usbdux_dio_insn_bits(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tstruct comedi_insn *insn,\n\t\t\t\tunsigned int *data)\n{\n\tstruct usbdux_private *devpriv = dev->private;\n\tint ret;\n\n\tmutex_lock(&devpriv->mut);\n\n\tcomedi_dio_update_state(s, data);\n\n\t \n\tdevpriv->dux_commands[1] = s->io_bits;\n\tdevpriv->dux_commands[2] = s->state;\n\n\t \n\tret = send_dux_commands(dev, USBDUX_CMD_DIO_BITS);\n\tif (ret < 0)\n\t\tgoto dio_exit;\n\tret = receive_dux_commands(dev, USBDUX_CMD_DIO_BITS);\n\tif (ret < 0)\n\t\tgoto dio_exit;\n\n\tdata[1] = le16_to_cpu(devpriv->insn_buf[1]);\n\ndio_exit:\n\tmutex_unlock(&devpriv->mut);\n\n\treturn ret ? ret : insn->n;\n}\n\nstatic int usbdux_counter_read(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       struct comedi_insn *insn,\n\t\t\t       unsigned int *data)\n{\n\tstruct usbdux_private *devpriv = dev->private;\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tint ret = 0;\n\tint i;\n\n\tmutex_lock(&devpriv->mut);\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\tret = send_dux_commands(dev, USBDUX_CMD_TIMER_RD);\n\t\tif (ret < 0)\n\t\t\tgoto counter_read_exit;\n\t\tret = receive_dux_commands(dev, USBDUX_CMD_TIMER_RD);\n\t\tif (ret < 0)\n\t\t\tgoto counter_read_exit;\n\n\t\tdata[i] = le16_to_cpu(devpriv->insn_buf[chan + 1]);\n\t}\n\ncounter_read_exit:\n\tmutex_unlock(&devpriv->mut);\n\n\treturn ret ? ret : insn->n;\n}\n\nstatic int usbdux_counter_write(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tstruct comedi_insn *insn,\n\t\t\t\tunsigned int *data)\n{\n\tstruct usbdux_private *devpriv = dev->private;\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\t__le16 *p = (__le16 *)&devpriv->dux_commands[2];\n\tint ret = 0;\n\tint i;\n\n\tmutex_lock(&devpriv->mut);\n\n\tdevpriv->dux_commands[1] = chan;\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\t*p = cpu_to_le16(data[i]);\n\n\t\tret = send_dux_commands(dev, USBDUX_CMD_TIMER_WR);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\n\tmutex_unlock(&devpriv->mut);\n\n\treturn ret ? ret : insn->n;\n}\n\nstatic int usbdux_counter_config(struct comedi_device *dev,\n\t\t\t\t struct comedi_subdevice *s,\n\t\t\t\t struct comedi_insn *insn, unsigned int *data)\n{\n\t \n\treturn 2;\n}\n\nstatic void usbduxsub_unlink_pwm_urbs(struct comedi_device *dev)\n{\n\tstruct usbdux_private *devpriv = dev->private;\n\n\tusb_kill_urb(devpriv->pwm_urb);\n}\n\nstatic void usbdux_pwm_stop(struct comedi_device *dev, int do_unlink)\n{\n\tstruct usbdux_private *devpriv = dev->private;\n\n\tif (do_unlink)\n\t\tusbduxsub_unlink_pwm_urbs(dev);\n\n\tdevpriv->pwm_cmd_running = 0;\n}\n\nstatic int usbdux_pwm_cancel(struct comedi_device *dev,\n\t\t\t     struct comedi_subdevice *s)\n{\n\tstruct usbdux_private *devpriv = dev->private;\n\tint ret;\n\n\tmutex_lock(&devpriv->mut);\n\t \n\tusbdux_pwm_stop(dev, devpriv->pwm_cmd_running);\n\tret = send_dux_commands(dev, USBDUX_CMD_PWM_OFF);\n\tmutex_unlock(&devpriv->mut);\n\n\treturn ret;\n}\n\nstatic void usbduxsub_pwm_irq(struct urb *urb)\n{\n\tstruct comedi_device *dev = urb->context;\n\tstruct usbdux_private *devpriv = dev->private;\n\tint ret;\n\n\tswitch (urb->status) {\n\tcase 0:\n\t\t \n\t\tbreak;\n\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\tcase -ECONNABORTED:\n\t\t \n\t\tif (devpriv->pwm_cmd_running)\n\t\t\tusbdux_pwm_stop(dev, 0);\n\n\t\treturn;\n\n\tdefault:\n\t\t \n\t\tif (devpriv->pwm_cmd_running) {\n\t\t\tdev_err(dev->class_dev,\n\t\t\t\t\"Non-zero urb status received in pwm intr context: %d\\n\",\n\t\t\t\turb->status);\n\t\t\tusbdux_pwm_stop(dev, 0);\n\t\t}\n\t\treturn;\n\t}\n\n\t \n\tif (!devpriv->pwm_cmd_running)\n\t\treturn;\n\n\turb->transfer_buffer_length = devpriv->pwm_buf_sz;\n\turb->dev = comedi_to_usb_dev(dev);\n\turb->status = 0;\n\tif (devpriv->pwm_cmd_running) {\n\t\tret = usb_submit_urb(urb, GFP_ATOMIC);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev->class_dev,\n\t\t\t\t\"pwm urb resubm failed in int-cont. ret=%d\",\n\t\t\t\tret);\n\t\t\tif (ret == -EL2NSYNC)\n\t\t\t\tdev_err(dev->class_dev,\n\t\t\t\t\t\"buggy USB host controller or bug in IRQ handling!\\n\");\n\n\t\t\t \n\t\t\tusbdux_pwm_stop(dev, 0);\n\t\t}\n\t}\n}\n\nstatic int usbduxsub_submit_pwm_urbs(struct comedi_device *dev)\n{\n\tstruct usb_device *usb = comedi_to_usb_dev(dev);\n\tstruct usbdux_private *devpriv = dev->private;\n\tstruct urb *urb = devpriv->pwm_urb;\n\n\t \n\tusb_fill_bulk_urb(urb, usb, usb_sndbulkpipe(usb, 4),\n\t\t\t  urb->transfer_buffer,\n\t\t\t  devpriv->pwm_buf_sz,\n\t\t\t  usbduxsub_pwm_irq,\n\t\t\t  dev);\n\n\treturn usb_submit_urb(urb, GFP_ATOMIC);\n}\n\nstatic int usbdux_pwm_period(struct comedi_device *dev,\n\t\t\t     struct comedi_subdevice *s,\n\t\t\t     unsigned int period)\n{\n\tstruct usbdux_private *devpriv = dev->private;\n\tint fx2delay;\n\n\tif (period < MIN_PWM_PERIOD)\n\t\treturn -EAGAIN;\n\n\tfx2delay = (period / (6 * 512 * 1000 / 33)) - 6;\n\tif (fx2delay > 255)\n\t\treturn -EAGAIN;\n\n\tdevpriv->pwm_delay = fx2delay;\n\tdevpriv->pwm_period = period;\n\n\treturn 0;\n}\n\nstatic int usbdux_pwm_start(struct comedi_device *dev,\n\t\t\t    struct comedi_subdevice *s)\n{\n\tstruct usbdux_private *devpriv = dev->private;\n\tint ret = 0;\n\n\tmutex_lock(&devpriv->mut);\n\n\tif (devpriv->pwm_cmd_running)\n\t\tgoto pwm_start_exit;\n\n\tdevpriv->dux_commands[1] = devpriv->pwm_delay;\n\tret = send_dux_commands(dev, USBDUX_CMD_PWM_ON);\n\tif (ret < 0)\n\t\tgoto pwm_start_exit;\n\n\t \n\tmemset(devpriv->pwm_urb->transfer_buffer, 0, devpriv->pwm_buf_sz);\n\n\tdevpriv->pwm_cmd_running = 1;\n\tret = usbduxsub_submit_pwm_urbs(dev);\n\tif (ret < 0)\n\t\tdevpriv->pwm_cmd_running = 0;\n\npwm_start_exit:\n\tmutex_unlock(&devpriv->mut);\n\n\treturn ret;\n}\n\nstatic void usbdux_pwm_pattern(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       unsigned int chan,\n\t\t\t       unsigned int value,\n\t\t\t       unsigned int sign)\n{\n\tstruct usbdux_private *devpriv = dev->private;\n\tchar pwm_mask = (1 << chan);\t \n\tchar sgn_mask = (16 << chan);\t \n\tchar *buf = (char *)(devpriv->pwm_urb->transfer_buffer);\n\tint szbuf = devpriv->pwm_buf_sz;\n\tint i;\n\n\tfor (i = 0; i < szbuf; i++) {\n\t\tchar c = *buf;\n\n\t\tc &= ~pwm_mask;\n\t\tif (i < value)\n\t\t\tc |= pwm_mask;\n\t\tif (!sign)\n\t\t\tc &= ~sgn_mask;\n\t\telse\n\t\t\tc |= sgn_mask;\n\t\t*buf++ = c;\n\t}\n}\n\nstatic int usbdux_pwm_write(struct comedi_device *dev,\n\t\t\t    struct comedi_subdevice *s,\n\t\t\t    struct comedi_insn *insn,\n\t\t\t    unsigned int *data)\n{\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\n\t \n\tif (insn->n != 1)\n\t\treturn -EINVAL;\n\n\t \n\tusbdux_pwm_pattern(dev, s, chan, data[0], 0);\n\n\treturn insn->n;\n}\n\nstatic int usbdux_pwm_config(struct comedi_device *dev,\n\t\t\t     struct comedi_subdevice *s,\n\t\t\t     struct comedi_insn *insn,\n\t\t\t     unsigned int *data)\n{\n\tstruct usbdux_private *devpriv = dev->private;\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\n\tswitch (data[0]) {\n\tcase INSN_CONFIG_ARM:\n\t\t \n\t\tif (data[1] != 0)\n\t\t\treturn -EINVAL;\n\t\treturn usbdux_pwm_start(dev, s);\n\tcase INSN_CONFIG_DISARM:\n\t\treturn usbdux_pwm_cancel(dev, s);\n\tcase INSN_CONFIG_GET_PWM_STATUS:\n\t\tdata[1] = devpriv->pwm_cmd_running;\n\t\treturn 0;\n\tcase INSN_CONFIG_PWM_SET_PERIOD:\n\t\treturn usbdux_pwm_period(dev, s, data[1]);\n\tcase INSN_CONFIG_PWM_GET_PERIOD:\n\t\tdata[1] = devpriv->pwm_period;\n\t\treturn 0;\n\tcase INSN_CONFIG_PWM_SET_H_BRIDGE:\n\t\t \n\t\tusbdux_pwm_pattern(dev, s, chan, data[1], (data[2] != 0));\n\t\treturn 0;\n\tcase INSN_CONFIG_PWM_GET_H_BRIDGE:\n\t\t \n\t\treturn -EINVAL;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int usbdux_firmware_upload(struct comedi_device *dev,\n\t\t\t\t  const u8 *data, size_t size,\n\t\t\t\t  unsigned long context)\n{\n\tstruct usb_device *usb = comedi_to_usb_dev(dev);\n\tu8 *buf;\n\tu8 *tmp;\n\tint ret;\n\n\tif (!data)\n\t\treturn 0;\n\n\tif (size > USBDUX_FIRMWARE_MAX_LEN) {\n\t\tdev_err(dev->class_dev,\n\t\t\t\"usbdux firmware binary it too large for FX2.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tbuf = kmemdup(data, size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t \n\ttmp = kmalloc(1, GFP_KERNEL);\n\tif (!tmp) {\n\t\tkfree(buf);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\t*tmp = 1;\t \n\tret = usb_control_msg(usb, usb_sndctrlpipe(usb, 0),\n\t\t\t      USBDUX_FIRMWARE_CMD,\n\t\t\t      VENDOR_DIR_OUT,\n\t\t\t      USBDUX_CPU_CS, 0x0000,\n\t\t\t      tmp, 1,\n\t\t\t      BULK_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_err(dev->class_dev, \"can not stop firmware\\n\");\n\t\tgoto done;\n\t}\n\n\t \n\tret = usb_control_msg(usb, usb_sndctrlpipe(usb, 0),\n\t\t\t      USBDUX_FIRMWARE_CMD,\n\t\t\t      VENDOR_DIR_OUT,\n\t\t\t      0, 0x0000,\n\t\t\t      buf, size,\n\t\t\t      BULK_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_err(dev->class_dev, \"firmware upload failed\\n\");\n\t\tgoto done;\n\t}\n\n\t \n\t*tmp = 0;\t \n\tret = usb_control_msg(usb, usb_sndctrlpipe(usb, 0),\n\t\t\t      USBDUX_FIRMWARE_CMD,\n\t\t\t      VENDOR_DIR_OUT,\n\t\t\t      USBDUX_CPU_CS, 0x0000,\n\t\t\t      tmp, 1,\n\t\t\t      BULK_TIMEOUT);\n\tif (ret < 0)\n\t\tdev_err(dev->class_dev, \"can not start firmware\\n\");\n\ndone:\n\tkfree(tmp);\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic int usbdux_alloc_usb_buffers(struct comedi_device *dev)\n{\n\tstruct usb_device *usb = comedi_to_usb_dev(dev);\n\tstruct usbdux_private *devpriv = dev->private;\n\tstruct urb *urb;\n\tint i;\n\n\tdevpriv->dux_commands = kzalloc(SIZEOFDUXBUFFER, GFP_KERNEL);\n\tdevpriv->in_buf = kzalloc(SIZEINBUF, GFP_KERNEL);\n\tdevpriv->insn_buf = kzalloc(SIZEINSNBUF, GFP_KERNEL);\n\tdevpriv->ai_urbs = kcalloc(devpriv->n_ai_urbs, sizeof(void *),\n\t\t\t\t   GFP_KERNEL);\n\tdevpriv->ao_urbs = kcalloc(devpriv->n_ao_urbs, sizeof(void *),\n\t\t\t\t   GFP_KERNEL);\n\tif (!devpriv->dux_commands || !devpriv->in_buf || !devpriv->insn_buf ||\n\t    !devpriv->ai_urbs || !devpriv->ao_urbs)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < devpriv->n_ai_urbs; i++) {\n\t\t \n\t\turb = usb_alloc_urb(1, GFP_KERNEL);\n\t\tif (!urb)\n\t\t\treturn -ENOMEM;\n\t\tdevpriv->ai_urbs[i] = urb;\n\n\t\turb->dev = usb;\n\t\turb->context = dev;\n\t\turb->pipe = usb_rcvisocpipe(usb, 6);\n\t\turb->transfer_flags = URB_ISO_ASAP;\n\t\turb->transfer_buffer = kzalloc(SIZEINBUF, GFP_KERNEL);\n\t\tif (!urb->transfer_buffer)\n\t\t\treturn -ENOMEM;\n\n\t\turb->complete = usbduxsub_ai_isoc_irq;\n\t\turb->number_of_packets = 1;\n\t\turb->transfer_buffer_length = SIZEINBUF;\n\t\turb->iso_frame_desc[0].offset = 0;\n\t\turb->iso_frame_desc[0].length = SIZEINBUF;\n\t}\n\n\tfor (i = 0; i < devpriv->n_ao_urbs; i++) {\n\t\t \n\t\turb = usb_alloc_urb(1, GFP_KERNEL);\n\t\tif (!urb)\n\t\t\treturn -ENOMEM;\n\t\tdevpriv->ao_urbs[i] = urb;\n\n\t\turb->dev = usb;\n\t\turb->context = dev;\n\t\turb->pipe = usb_sndisocpipe(usb, 2);\n\t\turb->transfer_flags = URB_ISO_ASAP;\n\t\turb->transfer_buffer = kzalloc(SIZEOUTBUF, GFP_KERNEL);\n\t\tif (!urb->transfer_buffer)\n\t\t\treturn -ENOMEM;\n\n\t\turb->complete = usbduxsub_ao_isoc_irq;\n\t\turb->number_of_packets = 1;\n\t\turb->transfer_buffer_length = SIZEOUTBUF;\n\t\turb->iso_frame_desc[0].offset = 0;\n\t\turb->iso_frame_desc[0].length = SIZEOUTBUF;\n\t\tif (devpriv->high_speed)\n\t\t\turb->interval = 8;\t \n\t\telse\n\t\t\turb->interval = 1;\t \n\t}\n\n\t \n\tif (devpriv->pwm_buf_sz) {\n\t\turb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!urb)\n\t\t\treturn -ENOMEM;\n\t\tdevpriv->pwm_urb = urb;\n\n\t\t \n\t\turb->transfer_buffer = kzalloc(devpriv->pwm_buf_sz,\n\t\t\t\t\t       GFP_KERNEL);\n\t\tif (!urb->transfer_buffer)\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void usbdux_free_usb_buffers(struct comedi_device *dev)\n{\n\tstruct usbdux_private *devpriv = dev->private;\n\tstruct urb *urb;\n\tint i;\n\n\turb = devpriv->pwm_urb;\n\tif (urb) {\n\t\tkfree(urb->transfer_buffer);\n\t\tusb_free_urb(urb);\n\t}\n\tif (devpriv->ao_urbs) {\n\t\tfor (i = 0; i < devpriv->n_ao_urbs; i++) {\n\t\t\turb = devpriv->ao_urbs[i];\n\t\t\tif (urb) {\n\t\t\t\tkfree(urb->transfer_buffer);\n\t\t\t\tusb_free_urb(urb);\n\t\t\t}\n\t\t}\n\t\tkfree(devpriv->ao_urbs);\n\t}\n\tif (devpriv->ai_urbs) {\n\t\tfor (i = 0; i < devpriv->n_ai_urbs; i++) {\n\t\t\turb = devpriv->ai_urbs[i];\n\t\t\tif (urb) {\n\t\t\t\tkfree(urb->transfer_buffer);\n\t\t\t\tusb_free_urb(urb);\n\t\t\t}\n\t\t}\n\t\tkfree(devpriv->ai_urbs);\n\t}\n\tkfree(devpriv->insn_buf);\n\tkfree(devpriv->in_buf);\n\tkfree(devpriv->dux_commands);\n}\n\nstatic int usbdux_auto_attach(struct comedi_device *dev,\n\t\t\t      unsigned long context_unused)\n{\n\tstruct usb_interface *intf = comedi_to_usb_interface(dev);\n\tstruct usb_device *usb = comedi_to_usb_dev(dev);\n\tstruct usbdux_private *devpriv;\n\tstruct comedi_subdevice *s;\n\tint ret;\n\n\tdevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\n\tif (!devpriv)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&devpriv->mut);\n\n\tusb_set_intfdata(intf, devpriv);\n\n\tdevpriv->high_speed = (usb->speed == USB_SPEED_HIGH);\n\tif (devpriv->high_speed) {\n\t\tdevpriv->n_ai_urbs = NUMOFINBUFFERSHIGH;\n\t\tdevpriv->n_ao_urbs = NUMOFOUTBUFFERSHIGH;\n\t\tdevpriv->pwm_buf_sz = 512;\n\t} else {\n\t\tdevpriv->n_ai_urbs = NUMOFINBUFFERSFULL;\n\t\tdevpriv->n_ao_urbs = NUMOFOUTBUFFERSFULL;\n\t}\n\n\tret = usbdux_alloc_usb_buffers(dev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = usb_set_interface(usb, intf->altsetting->desc.bInterfaceNumber,\n\t\t\t\t3);\n\tif (ret < 0) {\n\t\tdev_err(dev->class_dev,\n\t\t\t\"could not set alternate setting 3 in high speed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = comedi_load_firmware(dev, &usb->dev, USBDUX_FIRMWARE,\n\t\t\t\t   usbdux_firmware_upload, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = comedi_alloc_subdevices(dev, (devpriv->high_speed) ? 5 : 4);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ts = &dev->subdevices[0];\n\tdev->read_subdev = s;\n\ts->type\t\t= COMEDI_SUBD_AI;\n\ts->subdev_flags\t= SDF_READABLE | SDF_GROUND | SDF_CMD_READ;\n\ts->n_chan\t= 8;\n\ts->maxdata\t= 0x0fff;\n\ts->len_chanlist\t= 8;\n\ts->range_table\t= &range_usbdux_ai_range;\n\ts->insn_read\t= usbdux_ai_insn_read;\n\ts->do_cmdtest\t= usbdux_ai_cmdtest;\n\ts->do_cmd\t= usbdux_ai_cmd;\n\ts->cancel\t= usbdux_ai_cancel;\n\n\t \n\ts = &dev->subdevices[1];\n\tdev->write_subdev = s;\n\ts->type\t\t= COMEDI_SUBD_AO;\n\ts->subdev_flags\t= SDF_WRITABLE | SDF_GROUND | SDF_CMD_WRITE;\n\ts->n_chan\t= 4;\n\ts->maxdata\t= 0x0fff;\n\ts->len_chanlist\t= s->n_chan;\n\ts->range_table\t= &range_usbdux_ao_range;\n\ts->do_cmdtest\t= usbdux_ao_cmdtest;\n\ts->do_cmd\t= usbdux_ao_cmd;\n\ts->cancel\t= usbdux_ao_cancel;\n\ts->insn_read\t= usbdux_ao_insn_read;\n\ts->insn_write\t= usbdux_ao_insn_write;\n\n\tret = comedi_alloc_subdev_readback(s);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ts = &dev->subdevices[2];\n\ts->type\t\t= COMEDI_SUBD_DIO;\n\ts->subdev_flags\t= SDF_READABLE | SDF_WRITABLE;\n\ts->n_chan\t= 8;\n\ts->maxdata\t= 1;\n\ts->range_table\t= &range_digital;\n\ts->insn_bits\t= usbdux_dio_insn_bits;\n\ts->insn_config\t= usbdux_dio_insn_config;\n\n\t \n\ts = &dev->subdevices[3];\n\ts->type\t\t= COMEDI_SUBD_COUNTER;\n\ts->subdev_flags\t= SDF_WRITABLE | SDF_READABLE;\n\ts->n_chan\t= 4;\n\ts->maxdata\t= 0xffff;\n\ts->insn_read\t= usbdux_counter_read;\n\ts->insn_write\t= usbdux_counter_write;\n\ts->insn_config\t= usbdux_counter_config;\n\n\tif (devpriv->high_speed) {\n\t\t \n\t\ts = &dev->subdevices[4];\n\t\ts->type\t\t= COMEDI_SUBD_PWM;\n\t\ts->subdev_flags\t= SDF_WRITABLE | SDF_PWM_HBRIDGE;\n\t\ts->n_chan\t= 8;\n\t\ts->maxdata\t= devpriv->pwm_buf_sz;\n\t\ts->insn_write\t= usbdux_pwm_write;\n\t\ts->insn_config\t= usbdux_pwm_config;\n\n\t\tusbdux_pwm_period(dev, s, PWM_DEFAULT_PERIOD);\n\t}\n\n\treturn 0;\n}\n\nstatic void usbdux_detach(struct comedi_device *dev)\n{\n\tstruct usb_interface *intf = comedi_to_usb_interface(dev);\n\tstruct usbdux_private *devpriv = dev->private;\n\n\tusb_set_intfdata(intf, NULL);\n\n\tif (!devpriv)\n\t\treturn;\n\n\tmutex_lock(&devpriv->mut);\n\n\t \n\tusbdux_pwm_stop(dev, 1);\n\tusbdux_ao_stop(dev, 1);\n\tusbdux_ai_stop(dev, 1);\n\n\tusbdux_free_usb_buffers(dev);\n\n\tmutex_unlock(&devpriv->mut);\n\n\tmutex_destroy(&devpriv->mut);\n}\n\nstatic struct comedi_driver usbdux_driver = {\n\t.driver_name\t= \"usbdux\",\n\t.module\t\t= THIS_MODULE,\n\t.auto_attach\t= usbdux_auto_attach,\n\t.detach\t\t= usbdux_detach,\n};\n\nstatic int usbdux_usb_probe(struct usb_interface *intf,\n\t\t\t    const struct usb_device_id *id)\n{\n\treturn comedi_usb_auto_config(intf, &usbdux_driver, 0);\n}\n\nstatic const struct usb_device_id usbdux_usb_table[] = {\n\t{ USB_DEVICE(0x13d8, 0x0001) },\n\t{ USB_DEVICE(0x13d8, 0x0002) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(usb, usbdux_usb_table);\n\nstatic struct usb_driver usbdux_usb_driver = {\n\t.name\t\t= \"usbdux\",\n\t.probe\t\t= usbdux_usb_probe,\n\t.disconnect\t= comedi_usb_auto_unconfig,\n\t.id_table\t= usbdux_usb_table,\n};\nmodule_comedi_usb_driver(usbdux_driver, usbdux_usb_driver);\n\nMODULE_AUTHOR(\"Bernd Porr, BerndPorr@f2s.com\");\nMODULE_DESCRIPTION(\"Stirling/ITL USB-DUX -- Bernd.Porr@f2s.com\");\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(USBDUX_FIRMWARE);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}