{
  "module_name": "ni_tiocmd.c",
  "hash_id": "ee373947f4cd5ca2bdd7007fd5e5f3b6f055813e6aff0826479e7b225e3930da",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/ni_tiocmd.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include \"ni_tio_internal.h\"\n#include \"mite.h\"\n#include \"ni_routes.h\"\n\nstatic void ni_tio_configure_dma(struct ni_gpct *counter,\n\t\t\t\t bool enable, bool read)\n{\n\tstruct ni_gpct_device *counter_dev = counter->counter_dev;\n\tunsigned int cidx = counter->counter_index;\n\tunsigned int mask;\n\tunsigned int bits;\n\n\tmask = GI_READ_ACKS_IRQ | GI_WRITE_ACKS_IRQ;\n\tbits = 0;\n\n\tif (enable) {\n\t\tif (read)\n\t\t\tbits |= GI_READ_ACKS_IRQ;\n\t\telse\n\t\t\tbits |= GI_WRITE_ACKS_IRQ;\n\t}\n\tni_tio_set_bits(counter, NITIO_INPUT_SEL_REG(cidx), mask, bits);\n\n\tswitch (counter_dev->variant) {\n\tcase ni_gpct_variant_e_series:\n\t\tbreak;\n\tcase ni_gpct_variant_m_series:\n\tcase ni_gpct_variant_660x:\n\t\tmask = GI_DMA_ENABLE | GI_DMA_INT_ENA | GI_DMA_WRITE;\n\t\tbits = 0;\n\n\t\tif (enable)\n\t\t\tbits |= GI_DMA_ENABLE | GI_DMA_INT_ENA;\n\t\tif (!read)\n\t\t\tbits |= GI_DMA_WRITE;\n\t\tni_tio_set_bits(counter, NITIO_DMA_CFG_REG(cidx), mask, bits);\n\t\tbreak;\n\t}\n}\n\nstatic int ni_tio_input_inttrig(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tunsigned int trig_num)\n{\n\tstruct ni_gpct *counter = s->private;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tif (trig_num != cmd->start_arg)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&counter->lock, flags);\n\tif (counter->mite_chan)\n\t\tmite_dma_arm(counter->mite_chan);\n\telse\n\t\tret = -EIO;\n\tspin_unlock_irqrestore(&counter->lock, flags);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = ni_tio_arm(counter, true, NI_GPCT_ARM_IMMEDIATE);\n\ts->async->inttrig = NULL;\n\n\treturn ret;\n}\n\nstatic int ni_tio_input_cmd(struct comedi_subdevice *s)\n{\n\tstruct ni_gpct *counter = s->private;\n\tstruct ni_gpct_device *counter_dev = counter->counter_dev;\n\tconst struct ni_route_tables *routing_tables =\n\t\tcounter_dev->routing_tables;\n\tunsigned int cidx = counter->counter_index;\n\tstruct comedi_async *async = s->async;\n\tstruct comedi_cmd *cmd = &async->cmd;\n\tint ret = 0;\n\n\t \n\tcomedi_buf_write_alloc(s, async->prealloc_bufsz);\n\tcounter->mite_chan->dir = COMEDI_INPUT;\n\tswitch (counter_dev->variant) {\n\tcase ni_gpct_variant_m_series:\n\tcase ni_gpct_variant_660x:\n\t\tmite_prep_dma(counter->mite_chan, 32, 32);\n\t\tbreak;\n\tcase ni_gpct_variant_e_series:\n\t\tmite_prep_dma(counter->mite_chan, 16, 32);\n\t\tbreak;\n\t}\n\tni_tio_set_bits(counter, NITIO_CMD_REG(cidx), GI_SAVE_TRACE, 0);\n\tni_tio_configure_dma(counter, true, true);\n\n\tif (cmd->start_src == TRIG_INT) {\n\t\tasync->inttrig = &ni_tio_input_inttrig;\n\t} else {\t \n\t\tasync->inttrig = NULL;\n\t\tmite_dma_arm(counter->mite_chan);\n\n\t\tif (cmd->start_src == TRIG_NOW)\n\t\t\tret = ni_tio_arm(counter, true, NI_GPCT_ARM_IMMEDIATE);\n\t\telse if (cmd->start_src == TRIG_EXT) {\n\t\t\tint reg = CR_CHAN(cmd->start_arg);\n\n\t\t\tif (reg >= NI_NAMES_BASE) {\n\t\t\t\t \n\t\t\t\treg = ni_get_reg_value(reg,\n\t\t\t\t\t\t       NI_CtrArmStartTrigger(cidx),\n\t\t\t\t\t\t       routing_tables);\n\t\t\t\t \n\t\t\t\treg |= NI_GPCT_HW_ARM;\n\t\t\t}\n\t\t\tret = ni_tio_arm(counter, true, reg);\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int ni_tio_output_cmd(struct comedi_subdevice *s)\n{\n\tstruct ni_gpct *counter = s->private;\n\n\tdev_err(counter->counter_dev->dev->class_dev,\n\t\t\"output commands not yet implemented.\\n\");\n\treturn -ENOTSUPP;\n}\n\nstatic int ni_tio_cmd_setup(struct comedi_subdevice *s)\n{\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tstruct ni_gpct *counter = s->private;\n\tunsigned int cidx = counter->counter_index;\n\tconst struct ni_route_tables *routing_tables =\n\t\tcounter->counter_dev->routing_tables;\n\tint set_gate_source = 0;\n\tunsigned int gate_source;\n\tint retval = 0;\n\n\tif (cmd->scan_begin_src == TRIG_EXT) {\n\t\tset_gate_source = 1;\n\t\tgate_source = cmd->scan_begin_arg;\n\t} else if (cmd->convert_src == TRIG_EXT) {\n\t\tset_gate_source = 1;\n\t\tgate_source = cmd->convert_arg;\n\t}\n\tif (set_gate_source) {\n\t\tif (CR_CHAN(gate_source) >= NI_NAMES_BASE) {\n\t\t\t \n\t\t\tint reg = ni_get_reg_value(CR_CHAN(gate_source),\n\t\t\t\t\t\t   NI_CtrGate(cidx),\n\t\t\t\t\t\t   routing_tables);\n\t\t\tif (reg < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tretval = ni_tio_set_gate_src_raw(counter, 0, reg);\n\t\t} else {\n\t\t\t \n\t\t\tretval = ni_tio_set_gate_src(counter, 0, gate_source);\n\t\t}\n\t}\n\tif (cmd->flags & CMDF_WAKE_EOS) {\n\t\tni_tio_set_bits(counter, NITIO_INT_ENA_REG(cidx),\n\t\t\t\tGI_GATE_INTERRUPT_ENABLE(cidx),\n\t\t\t\tGI_GATE_INTERRUPT_ENABLE(cidx));\n\t}\n\treturn retval;\n}\n\nint ni_tio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\n{\n\tstruct ni_gpct *counter = s->private;\n\tstruct comedi_async *async = s->async;\n\tstruct comedi_cmd *cmd = &async->cmd;\n\tint retval = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&counter->lock, flags);\n\tif (!counter->mite_chan) {\n\t\tdev_err(counter->counter_dev->dev->class_dev,\n\t\t\t\"commands only supported with DMA.  \");\n\t\tdev_err(counter->counter_dev->dev->class_dev,\n\t\t\t\"Interrupt-driven commands not yet implemented.\\n\");\n\t\tretval = -EIO;\n\t} else {\n\t\tretval = ni_tio_cmd_setup(s);\n\t\tif (retval == 0) {\n\t\t\tif (cmd->flags & CMDF_WRITE)\n\t\t\t\tretval = ni_tio_output_cmd(s);\n\t\t\telse\n\t\t\t\tretval = ni_tio_input_cmd(s);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&counter->lock, flags);\n\treturn retval;\n}\nEXPORT_SYMBOL_GPL(ni_tio_cmd);\n\nint ni_tio_cmdtest(struct comedi_device *dev,\n\t\t   struct comedi_subdevice *s,\n\t\t   struct comedi_cmd *cmd)\n{\n\tstruct ni_gpct *counter = s->private;\n\tunsigned int cidx = counter->counter_index;\n\tconst struct ni_route_tables *routing_tables =\n\t\tcounter->counter_dev->routing_tables;\n\tint err = 0;\n\tunsigned int sources;\n\n\t \n\n\tsources = TRIG_NOW | TRIG_INT | TRIG_OTHER;\n\tif (ni_tio_counting_mode_registers_present(counter->counter_dev))\n\t\tsources |= TRIG_EXT;\n\terr |= comedi_check_trigger_src(&cmd->start_src, sources);\n\n\terr |= comedi_check_trigger_src(&cmd->scan_begin_src,\n\t\t\t\t\tTRIG_FOLLOW | TRIG_EXT | TRIG_OTHER);\n\terr |= comedi_check_trigger_src(&cmd->convert_src,\n\t\t\t\t\tTRIG_NOW | TRIG_EXT | TRIG_OTHER);\n\terr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\n\terr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_NONE);\n\n\tif (err)\n\t\treturn 1;\n\n\t \n\n\terr |= comedi_check_trigger_is_unique(cmd->start_src);\n\terr |= comedi_check_trigger_is_unique(cmd->scan_begin_src);\n\terr |= comedi_check_trigger_is_unique(cmd->convert_src);\n\n\t \n\n\tif (cmd->convert_src != TRIG_NOW && cmd->scan_begin_src != TRIG_FOLLOW)\n\t\terr |= -EINVAL;\n\n\tif (err)\n\t\treturn 2;\n\n\t \n\n\tswitch (cmd->start_src) {\n\tcase TRIG_NOW:\n\tcase TRIG_INT:\n\tcase TRIG_OTHER:\n\t\terr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\n\t\tbreak;\n\tcase TRIG_EXT:\n\t\t \n\t\t \n\t\tbreak;\n\t}\n\n\t \n\tif (cmd->scan_begin_src != TRIG_EXT)\n\t\terr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);\n\telse\n\t\terr |= ni_check_trigger_arg(CR_CHAN(cmd->scan_begin_arg),\n\t\t\t\t\t    NI_CtrGate(cidx), routing_tables);\n\n\tif (cmd->convert_src != TRIG_EXT)\n\t\terr |= comedi_check_trigger_arg_is(&cmd->convert_arg, 0);\n\telse\n\t\terr |= ni_check_trigger_arg(CR_CHAN(cmd->convert_arg),\n\t\t\t\t\t    NI_CtrGate(cidx), routing_tables);\n\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\n\t\t\t\t\t   cmd->chanlist_len);\n\terr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\n\n\tif (err)\n\t\treturn 3;\n\n\t \n\n\t \n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ni_tio_cmdtest);\n\nint ni_tio_cancel(struct ni_gpct *counter)\n{\n\tunsigned int cidx = counter->counter_index;\n\tunsigned long flags;\n\n\tni_tio_arm(counter, false, 0);\n\tspin_lock_irqsave(&counter->lock, flags);\n\tif (counter->mite_chan)\n\t\tmite_dma_disarm(counter->mite_chan);\n\tspin_unlock_irqrestore(&counter->lock, flags);\n\tni_tio_configure_dma(counter, false, false);\n\n\tni_tio_set_bits(counter, NITIO_INT_ENA_REG(cidx),\n\t\t\tGI_GATE_INTERRUPT_ENABLE(cidx), 0x0);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ni_tio_cancel);\n\nstatic int should_ack_gate(struct ni_gpct *counter)\n{\n\tunsigned long flags;\n\tint retval = 0;\n\n\tswitch (counter->counter_dev->variant) {\n\tcase ni_gpct_variant_m_series:\n\tcase ni_gpct_variant_660x:\n\t\t \n\t\treturn 1;\n\tcase ni_gpct_variant_e_series:\n\t\t \n\t\tspin_lock_irqsave(&counter->lock, flags);\n\t\t{\n\t\t\tif (!counter->mite_chan ||\n\t\t\t    counter->mite_chan->dir != COMEDI_INPUT ||\n\t\t\t    (mite_done(counter->mite_chan))) {\n\t\t\t\tretval = 1;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&counter->lock, flags);\n\t\tbreak;\n\t}\n\treturn retval;\n}\n\nstatic void ni_tio_acknowledge_and_confirm(struct ni_gpct *counter,\n\t\t\t\t\t   int *gate_error,\n\t\t\t\t\t   int *tc_error,\n\t\t\t\t\t   int *perm_stale_data)\n{\n\tunsigned int cidx = counter->counter_index;\n\tconst unsigned short gxx_status = ni_tio_read(counter,\n\t\t\t\t\t\tNITIO_SHARED_STATUS_REG(cidx));\n\tconst unsigned short gi_status = ni_tio_read(counter,\n\t\t\t\t\t\tNITIO_STATUS_REG(cidx));\n\tunsigned int ack = 0;\n\n\tif (gate_error)\n\t\t*gate_error = 0;\n\tif (tc_error)\n\t\t*tc_error = 0;\n\tif (perm_stale_data)\n\t\t*perm_stale_data = 0;\n\n\tif (gxx_status & GI_GATE_ERROR(cidx)) {\n\t\tack |= GI_GATE_ERROR_CONFIRM(cidx);\n\t\tif (gate_error) {\n\t\t\t \n\t\t\tif (counter->counter_dev->variant !=\n\t\t\t    ni_gpct_variant_660x)\n\t\t\t\t*gate_error = 1;\n\t\t}\n\t}\n\tif (gxx_status & GI_TC_ERROR(cidx)) {\n\t\tack |= GI_TC_ERROR_CONFIRM(cidx);\n\t\tif (tc_error)\n\t\t\t*tc_error = 1;\n\t}\n\tif (gi_status & GI_TC)\n\t\tack |= GI_TC_INTERRUPT_ACK;\n\tif (gi_status & GI_GATE_INTERRUPT) {\n\t\tif (should_ack_gate(counter))\n\t\t\tack |= GI_GATE_INTERRUPT_ACK;\n\t}\n\tif (ack)\n\t\tni_tio_write(counter, ack, NITIO_INT_ACK_REG(cidx));\n\tif (ni_tio_get_soft_copy(counter, NITIO_MODE_REG(cidx)) &\n\t    GI_LOADING_ON_GATE) {\n\t\tif (ni_tio_read(counter, NITIO_STATUS2_REG(cidx)) &\n\t\t    GI_PERMANENT_STALE(cidx)) {\n\t\t\tdev_info(counter->counter_dev->dev->class_dev,\n\t\t\t\t \"%s: Gi_Permanent_Stale_Data detected.\\n\",\n\t\t\t\t __func__);\n\t\t\tif (perm_stale_data)\n\t\t\t\t*perm_stale_data = 1;\n\t\t}\n\t}\n}\n\nvoid ni_tio_acknowledge(struct ni_gpct *counter)\n{\n\tni_tio_acknowledge_and_confirm(counter, NULL, NULL, NULL);\n}\nEXPORT_SYMBOL_GPL(ni_tio_acknowledge);\n\nvoid ni_tio_handle_interrupt(struct ni_gpct *counter,\n\t\t\t     struct comedi_subdevice *s)\n{\n\tunsigned int cidx = counter->counter_index;\n\tunsigned long flags;\n\tint gate_error;\n\tint tc_error;\n\tint perm_stale_data;\n\n\tni_tio_acknowledge_and_confirm(counter, &gate_error, &tc_error,\n\t\t\t\t       &perm_stale_data);\n\tif (gate_error) {\n\t\tdev_notice(counter->counter_dev->dev->class_dev,\n\t\t\t   \"%s: Gi_Gate_Error detected.\\n\", __func__);\n\t\ts->async->events |= COMEDI_CB_OVERFLOW;\n\t}\n\tif (perm_stale_data)\n\t\ts->async->events |= COMEDI_CB_ERROR;\n\tswitch (counter->counter_dev->variant) {\n\tcase ni_gpct_variant_m_series:\n\tcase ni_gpct_variant_660x:\n\t\tif (ni_tio_read(counter, NITIO_DMA_STATUS_REG(cidx)) &\n\t\t    GI_DRQ_ERROR) {\n\t\t\tdev_notice(counter->counter_dev->dev->class_dev,\n\t\t\t\t   \"%s: Gi_DRQ_Error detected.\\n\", __func__);\n\t\t\ts->async->events |= COMEDI_CB_OVERFLOW;\n\t\t}\n\t\tbreak;\n\tcase ni_gpct_variant_e_series:\n\t\tbreak;\n\t}\n\tspin_lock_irqsave(&counter->lock, flags);\n\tif (counter->mite_chan)\n\t\tmite_ack_linkc(counter->mite_chan, s, true);\n\tspin_unlock_irqrestore(&counter->lock, flags);\n}\nEXPORT_SYMBOL_GPL(ni_tio_handle_interrupt);\n\nvoid ni_tio_set_mite_channel(struct ni_gpct *counter,\n\t\t\t     struct mite_channel *mite_chan)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&counter->lock, flags);\n\tcounter->mite_chan = mite_chan;\n\tspin_unlock_irqrestore(&counter->lock, flags);\n}\nEXPORT_SYMBOL_GPL(ni_tio_set_mite_channel);\n\nstatic int __init ni_tiocmd_init_module(void)\n{\n\treturn 0;\n}\nmodule_init(ni_tiocmd_init_module);\n\nstatic void __exit ni_tiocmd_cleanup_module(void)\n{\n}\nmodule_exit(ni_tiocmd_cleanup_module);\n\nMODULE_AUTHOR(\"Comedi <comedi@comedi.org>\");\nMODULE_DESCRIPTION(\"Comedi command support for NI general-purpose counters\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}