{
  "module_name": "jr3_pci.c",
  "hash_id": "d132b0bfd6da1c2dfb3a973cbb29767433edac338e522e8b2508295bfe3a2248",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/jr3_pci.c",
  "human_readable_source": "\n \n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/ctype.h>\n#include <linux/jiffies.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n#include <linux/comedi/comedi_pci.h>\n\n#include \"jr3_pci.h\"\n\n#define PCI_VENDOR_ID_JR3 0x1762\n\nenum jr3_pci_boardid {\n\tBOARD_JR3_1,\n\tBOARD_JR3_2,\n\tBOARD_JR3_3,\n\tBOARD_JR3_4,\n};\n\nstruct jr3_pci_board {\n\tconst char *name;\n\tint n_subdevs;\n};\n\nstatic const struct jr3_pci_board jr3_pci_boards[] = {\n\t[BOARD_JR3_1] = {\n\t\t.name\t\t= \"jr3_pci_1\",\n\t\t.n_subdevs\t= 1,\n\t},\n\t[BOARD_JR3_2] = {\n\t\t.name\t\t= \"jr3_pci_2\",\n\t\t.n_subdevs\t= 2,\n\t},\n\t[BOARD_JR3_3] = {\n\t\t.name\t\t= \"jr3_pci_3\",\n\t\t.n_subdevs\t= 3,\n\t},\n\t[BOARD_JR3_4] = {\n\t\t.name\t\t= \"jr3_pci_4\",\n\t\t.n_subdevs\t= 4,\n\t},\n};\n\nstruct jr3_pci_transform {\n\tstruct {\n\t\tu16 link_type;\n\t\ts16 link_amount;\n\t} link[8];\n};\n\nstruct jr3_pci_poll_delay {\n\tint min;\n\tint max;\n};\n\nstruct jr3_pci_dev_private {\n\tstruct timer_list timer;\n\tstruct comedi_device *dev;\n};\n\nunion jr3_pci_single_range {\n\tstruct comedi_lrange l;\n\tchar _reserved[offsetof(struct comedi_lrange, range[1])];\n};\n\nenum jr3_pci_poll_state {\n\tstate_jr3_poll,\n\tstate_jr3_init_wait_for_offset,\n\tstate_jr3_init_transform_complete,\n\tstate_jr3_init_set_full_scale_complete,\n\tstate_jr3_init_use_offset_complete,\n\tstate_jr3_done\n};\n\nstruct jr3_pci_subdev_private {\n\tstruct jr3_sensor __iomem *sensor;\n\tunsigned long next_time_min;\n\tenum jr3_pci_poll_state state;\n\tint serial_no;\n\tint model_no;\n\tunion jr3_pci_single_range range[9];\n\tconst struct comedi_lrange *range_table_list[8 * 7 + 2];\n\tunsigned int maxdata_list[8 * 7 + 2];\n\tu16 errors;\n\tint retries;\n};\n\nstatic struct jr3_pci_poll_delay poll_delay_min_max(int min, int max)\n{\n\tstruct jr3_pci_poll_delay result;\n\n\tresult.min = min;\n\tresult.max = max;\n\treturn result;\n}\n\nstatic int is_complete(struct jr3_sensor __iomem *sensor)\n{\n\treturn get_s16(&sensor->command_word0) == 0;\n}\n\nstatic void set_transforms(struct jr3_sensor __iomem *sensor,\n\t\t\t   const struct jr3_pci_transform *transf, short num)\n{\n\tint i;\n\n\tnum &= 0x000f;\t\t \n\tfor (i = 0; i < 8; i++) {\n\t\tset_u16(&sensor->transforms[num].link[i].link_type,\n\t\t\ttransf->link[i].link_type);\n\t\tudelay(1);\n\t\tset_s16(&sensor->transforms[num].link[i].link_amount,\n\t\t\ttransf->link[i].link_amount);\n\t\tudelay(1);\n\t\tif (transf->link[i].link_type == end_x_form)\n\t\t\tbreak;\n\t}\n}\n\nstatic void use_transform(struct jr3_sensor __iomem *sensor,\n\t\t\t  short transf_num)\n{\n\tset_s16(&sensor->command_word0, 0x0500 + (transf_num & 0x000f));\n}\n\nstatic void use_offset(struct jr3_sensor __iomem *sensor, short offset_num)\n{\n\tset_s16(&sensor->command_word0, 0x0600 + (offset_num & 0x000f));\n}\n\nstatic void set_offset(struct jr3_sensor __iomem *sensor)\n{\n\tset_s16(&sensor->command_word0, 0x0700);\n}\n\nstruct six_axis_t {\n\ts16 fx;\n\ts16 fy;\n\ts16 fz;\n\ts16 mx;\n\ts16 my;\n\ts16 mz;\n};\n\nstatic void set_full_scales(struct jr3_sensor __iomem *sensor,\n\t\t\t    struct six_axis_t full_scale)\n{\n\tset_s16(&sensor->full_scale.fx, full_scale.fx);\n\tset_s16(&sensor->full_scale.fy, full_scale.fy);\n\tset_s16(&sensor->full_scale.fz, full_scale.fz);\n\tset_s16(&sensor->full_scale.mx, full_scale.mx);\n\tset_s16(&sensor->full_scale.my, full_scale.my);\n\tset_s16(&sensor->full_scale.mz, full_scale.mz);\n\tset_s16(&sensor->command_word0, 0x0a00);\n}\n\nstatic struct six_axis_t get_max_full_scales(struct jr3_sensor __iomem *sensor)\n{\n\tstruct six_axis_t result;\n\n\tresult.fx = get_s16(&sensor->max_full_scale.fx);\n\tresult.fy = get_s16(&sensor->max_full_scale.fy);\n\tresult.fz = get_s16(&sensor->max_full_scale.fz);\n\tresult.mx = get_s16(&sensor->max_full_scale.mx);\n\tresult.my = get_s16(&sensor->max_full_scale.my);\n\tresult.mz = get_s16(&sensor->max_full_scale.mz);\n\treturn result;\n}\n\nstatic unsigned int jr3_pci_ai_read_chan(struct comedi_device *dev,\n\t\t\t\t\t struct comedi_subdevice *s,\n\t\t\t\t\t unsigned int chan)\n{\n\tstruct jr3_pci_subdev_private *spriv = s->private;\n\tunsigned int val = 0;\n\n\tif (spriv->state != state_jr3_done)\n\t\treturn 0;\n\n\tif (chan < 56) {\n\t\tunsigned int axis = chan % 8;\n\t\tunsigned int filter = chan / 8;\n\n\t\tswitch (axis) {\n\t\tcase 0:\n\t\t\tval = get_s16(&spriv->sensor->filter[filter].fx);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tval = get_s16(&spriv->sensor->filter[filter].fy);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tval = get_s16(&spriv->sensor->filter[filter].fz);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tval = get_s16(&spriv->sensor->filter[filter].mx);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tval = get_s16(&spriv->sensor->filter[filter].my);\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tval = get_s16(&spriv->sensor->filter[filter].mz);\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tval = get_s16(&spriv->sensor->filter[filter].v1);\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tval = get_s16(&spriv->sensor->filter[filter].v2);\n\t\t\tbreak;\n\t\t}\n\t\tval += 0x4000;\n\t} else if (chan == 56) {\n\t\tval = get_u16(&spriv->sensor->model_no);\n\t} else if (chan == 57) {\n\t\tval = get_u16(&spriv->sensor->serial_no);\n\t}\n\n\treturn val;\n}\n\nstatic int jr3_pci_ai_insn_read(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tstruct comedi_insn *insn,\n\t\t\t\tunsigned int *data)\n{\n\tstruct jr3_pci_subdev_private *spriv = s->private;\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tu16 errors;\n\tint i;\n\n\terrors = get_u16(&spriv->sensor->errors);\n\tif (spriv->state != state_jr3_done ||\n\t    (errors & (watch_dog | watch_dog2 | sensor_change))) {\n\t\t \n\t\tif (spriv->state == state_jr3_done) {\n\t\t\t \n\t\t\tspriv->state = state_jr3_poll;\n\t\t}\n\t\treturn -EAGAIN;\n\t}\n\n\tfor (i = 0; i < insn->n; i++)\n\t\tdata[i] = jr3_pci_ai_read_chan(dev, s, chan);\n\n\treturn insn->n;\n}\n\nstatic int jr3_pci_open(struct comedi_device *dev)\n{\n\tstruct jr3_pci_subdev_private *spriv;\n\tstruct comedi_subdevice *s;\n\tint i;\n\n\tfor (i = 0; i < dev->n_subdevices; i++) {\n\t\ts = &dev->subdevices[i];\n\t\tspriv = s->private;\n\t\tdev_dbg(dev->class_dev, \"serial[%d]: %d\\n\", s->index,\n\t\t\tspriv->serial_no);\n\t}\n\treturn 0;\n}\n\nstatic int read_idm_word(const u8 *data, size_t size, int *pos,\n\t\t\t unsigned int *val)\n{\n\tint result = 0;\n\tint value;\n\n\tif (pos && val) {\n\t\t \n\t\tfor (; *pos < size && !isxdigit(data[*pos]); (*pos)++)\n\t\t\t;\n\t\t \n\t\t*val = 0;\n\t\tfor (; *pos < size; (*pos)++) {\n\t\t\tvalue = hex_to_bin(data[*pos]);\n\t\t\tif (value >= 0) {\n\t\t\t\tresult = 1;\n\t\t\t\t*val = (*val << 4) + value;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\nstatic int jr3_check_firmware(struct comedi_device *dev,\n\t\t\t      const u8 *data, size_t size)\n{\n\tint more = 1;\n\tint pos = 0;\n\n\t \n\twhile (more) {\n\t\tunsigned int count = 0;\n\t\tunsigned int addr = 0;\n\n\t\tmore = more && read_idm_word(data, size, &pos, &count);\n\t\tif (more && count == 0xffff)\n\t\t\treturn 0;\n\n\t\tmore = more && read_idm_word(data, size, &pos, &addr);\n\t\twhile (more && count > 0) {\n\t\t\tunsigned int dummy = 0;\n\n\t\t\tmore = more && read_idm_word(data, size, &pos, &dummy);\n\t\t\tcount--;\n\t\t}\n\t}\n\n\treturn -ENODATA;\n}\n\nstatic void jr3_write_firmware(struct comedi_device *dev,\n\t\t\t       int subdev, const u8 *data, size_t size)\n{\n\tstruct jr3_block __iomem *block = dev->mmio;\n\tu32 __iomem *lo;\n\tu32 __iomem *hi;\n\tint more = 1;\n\tint pos = 0;\n\n\twhile (more) {\n\t\tunsigned int count = 0;\n\t\tunsigned int addr = 0;\n\n\t\tmore = more && read_idm_word(data, size, &pos, &count);\n\t\tif (more && count == 0xffff)\n\t\t\treturn;\n\n\t\tmore = more && read_idm_word(data, size, &pos, &addr);\n\n\t\tdev_dbg(dev->class_dev, \"Loading#%d %4.4x bytes at %4.4x\\n\",\n\t\t\tsubdev, count, addr);\n\n\t\twhile (more && count > 0) {\n\t\t\tif (addr & 0x4000) {\n\t\t\t\t \n\t\t\t\tunsigned int data1 = 0;\n\n\t\t\t\tmore = more &&\n\t\t\t\t       read_idm_word(data, size, &pos, &data1);\n\t\t\t\tcount--;\n\t\t\t\t \n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tunsigned int data1 = 0;\n\t\t\t\tunsigned int data2 = 0;\n\n\t\t\t\tlo = &block[subdev].program_lo[addr];\n\t\t\t\thi = &block[subdev].program_hi[addr];\n\n\t\t\t\tmore = more &&\n\t\t\t\t       read_idm_word(data, size, &pos, &data1);\n\t\t\t\tmore = more &&\n\t\t\t\t       read_idm_word(data, size, &pos, &data2);\n\t\t\t\tcount -= 2;\n\t\t\t\tif (more) {\n\t\t\t\t\tset_u16(lo, data1);\n\t\t\t\t\tudelay(1);\n\t\t\t\t\tset_u16(hi, data2);\n\t\t\t\t\tudelay(1);\n\t\t\t\t}\n\t\t\t}\n\t\t\taddr++;\n\t\t}\n\t}\n}\n\nstatic int jr3_download_firmware(struct comedi_device *dev,\n\t\t\t\t const u8 *data, size_t size,\n\t\t\t\t unsigned long context)\n{\n\tint subdev;\n\tint ret;\n\n\t \n\tret = jr3_check_firmware(dev, data, size);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor (subdev = 0; subdev < dev->n_subdevices; subdev++)\n\t\tjr3_write_firmware(dev, subdev, data, size);\n\n\treturn 0;\n}\n\nstatic struct jr3_pci_poll_delay\njr3_pci_poll_subdevice(struct comedi_subdevice *s)\n{\n\tstruct jr3_pci_subdev_private *spriv = s->private;\n\tstruct jr3_pci_poll_delay result = poll_delay_min_max(1000, 2000);\n\tstruct jr3_sensor __iomem *sensor;\n\tu16 model_no;\n\tu16 serial_no;\n\tint errors;\n\tint i;\n\n\tsensor = spriv->sensor;\n\terrors = get_u16(&sensor->errors);\n\n\tif (errors != spriv->errors)\n\t\tspriv->errors = errors;\n\n\t \n\tif (errors & (watch_dog | watch_dog2 | sensor_change))\n\t\tspriv->state = state_jr3_poll;\n\n\tswitch (spriv->state) {\n\tcase state_jr3_poll:\n\t\tmodel_no = get_u16(&sensor->model_no);\n\t\tserial_no = get_u16(&sensor->serial_no);\n\n\t\tif ((errors & (watch_dog | watch_dog2)) ||\n\t\t    model_no == 0 || serial_no == 0) {\n\t\t\t \n\t\t} else {\n\t\t\tspriv->retries = 0;\n\t\t\tspriv->state = state_jr3_init_wait_for_offset;\n\t\t}\n\t\tbreak;\n\tcase state_jr3_init_wait_for_offset:\n\t\tspriv->retries++;\n\t\tif (spriv->retries < 10) {\n\t\t\t \n\t\t} else {\n\t\t\tstruct jr3_pci_transform transf;\n\n\t\t\tspriv->model_no = get_u16(&sensor->model_no);\n\t\t\tspriv->serial_no = get_u16(&sensor->serial_no);\n\n\t\t\t \n\t\t\tfor (i = 0; i < ARRAY_SIZE(transf.link); i++) {\n\t\t\t\ttransf.link[i].link_type = (enum link_types)0;\n\t\t\t\ttransf.link[i].link_amount = 0;\n\t\t\t}\n\n\t\t\tset_transforms(sensor, &transf, 0);\n\t\t\tuse_transform(sensor, 0);\n\t\t\tspriv->state = state_jr3_init_transform_complete;\n\t\t\t \n\t\t\tresult = poll_delay_min_max(20, 100);\n\t\t}\n\t\tbreak;\n\tcase state_jr3_init_transform_complete:\n\t\tif (!is_complete(sensor)) {\n\t\t\tresult = poll_delay_min_max(20, 100);\n\t\t} else {\n\t\t\t \n\t\t\tstruct six_axis_t max_full_scale;\n\n\t\t\tmax_full_scale = get_max_full_scales(sensor);\n\t\t\tset_full_scales(sensor, max_full_scale);\n\n\t\t\tspriv->state = state_jr3_init_set_full_scale_complete;\n\t\t\t \n\t\t\tresult = poll_delay_min_max(20, 100);\n\t\t}\n\t\tbreak;\n\tcase state_jr3_init_set_full_scale_complete:\n\t\tif (!is_complete(sensor)) {\n\t\t\tresult = poll_delay_min_max(20, 100);\n\t\t} else {\n\t\t\tstruct force_array __iomem *fs = &sensor->full_scale;\n\t\t\tunion jr3_pci_single_range *r = spriv->range;\n\n\t\t\t \n\t\t\tr[0].l.range[0].min = -get_s16(&fs->fx) * 1000;\n\t\t\tr[0].l.range[0].max = get_s16(&fs->fx) * 1000;\n\t\t\tr[1].l.range[0].min = -get_s16(&fs->fy) * 1000;\n\t\t\tr[1].l.range[0].max = get_s16(&fs->fy) * 1000;\n\t\t\tr[2].l.range[0].min = -get_s16(&fs->fz) * 1000;\n\t\t\tr[2].l.range[0].max = get_s16(&fs->fz) * 1000;\n\t\t\tr[3].l.range[0].min = -get_s16(&fs->mx) * 100;\n\t\t\tr[3].l.range[0].max = get_s16(&fs->mx) * 100;\n\t\t\tr[4].l.range[0].min = -get_s16(&fs->my) * 100;\n\t\t\tr[4].l.range[0].max = get_s16(&fs->my) * 100;\n\t\t\tr[5].l.range[0].min = -get_s16(&fs->mz) * 100;\n\t\t\t \n\t\t\tr[5].l.range[0].max = get_s16(&fs->mz) * 100;\n\t\t\tr[6].l.range[0].min = -get_s16(&fs->v1) * 100;\n\t\t\tr[6].l.range[0].max = get_s16(&fs->v1) * 100;\n\t\t\tr[7].l.range[0].min = -get_s16(&fs->v2) * 100;\n\t\t\tr[7].l.range[0].max = get_s16(&fs->v2) * 100;\n\t\t\tr[8].l.range[0].min = 0;\n\t\t\tr[8].l.range[0].max = 65535;\n\n\t\t\tuse_offset(sensor, 0);\n\t\t\tspriv->state = state_jr3_init_use_offset_complete;\n\t\t\t \n\t\t\tresult = poll_delay_min_max(40, 100);\n\t\t}\n\t\tbreak;\n\tcase state_jr3_init_use_offset_complete:\n\t\tif (!is_complete(sensor)) {\n\t\t\tresult = poll_delay_min_max(20, 100);\n\t\t} else {\n\t\t\tset_s16(&sensor->offsets.fx, 0);\n\t\t\tset_s16(&sensor->offsets.fy, 0);\n\t\t\tset_s16(&sensor->offsets.fz, 0);\n\t\t\tset_s16(&sensor->offsets.mx, 0);\n\t\t\tset_s16(&sensor->offsets.my, 0);\n\t\t\tset_s16(&sensor->offsets.mz, 0);\n\n\t\t\tset_offset(sensor);\n\n\t\t\tspriv->state = state_jr3_done;\n\t\t}\n\t\tbreak;\n\tcase state_jr3_done:\n\t\tresult = poll_delay_min_max(10000, 20000);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn result;\n}\n\nstatic void jr3_pci_poll_dev(struct timer_list *t)\n{\n\tstruct jr3_pci_dev_private *devpriv = from_timer(devpriv, t, timer);\n\tstruct comedi_device *dev = devpriv->dev;\n\tstruct jr3_pci_subdev_private *spriv;\n\tstruct comedi_subdevice *s;\n\tunsigned long flags;\n\tunsigned long now;\n\tint delay;\n\tint i;\n\n\tspin_lock_irqsave(&dev->spinlock, flags);\n\tdelay = 1000;\n\tnow = jiffies;\n\n\t \n\tfor (i = 0; i < dev->n_subdevices; i++) {\n\t\ts = &dev->subdevices[i];\n\t\tspriv = s->private;\n\n\t\tif (time_after_eq(now, spriv->next_time_min)) {\n\t\t\tstruct jr3_pci_poll_delay sub_delay;\n\n\t\t\tsub_delay = jr3_pci_poll_subdevice(s);\n\n\t\t\tspriv->next_time_min = jiffies +\n\t\t\t\t\t       msecs_to_jiffies(sub_delay.min);\n\n\t\t\tif (sub_delay.max && sub_delay.max < delay)\n\t\t\t\t \n\t\t\t\tdelay = sub_delay.max;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&dev->spinlock, flags);\n\n\tdevpriv->timer.expires = jiffies + msecs_to_jiffies(delay);\n\tadd_timer(&devpriv->timer);\n}\n\nstatic struct jr3_pci_subdev_private *\njr3_pci_alloc_spriv(struct comedi_device *dev, struct comedi_subdevice *s)\n{\n\tstruct jr3_block __iomem *block = dev->mmio;\n\tstruct jr3_pci_subdev_private *spriv;\n\tint j;\n\tint k;\n\n\tspriv = comedi_alloc_spriv(s, sizeof(*spriv));\n\tif (!spriv)\n\t\treturn NULL;\n\n\tspriv->sensor = &block[s->index].sensor;\n\n\tfor (j = 0; j < 8; j++) {\n\t\tspriv->range[j].l.length = 1;\n\t\tspriv->range[j].l.range[0].min = -1000000;\n\t\tspriv->range[j].l.range[0].max = 1000000;\n\n\t\tfor (k = 0; k < 7; k++) {\n\t\t\tspriv->range_table_list[j + k * 8] = &spriv->range[j].l;\n\t\t\tspriv->maxdata_list[j + k * 8] = 0x7fff;\n\t\t}\n\t}\n\tspriv->range[8].l.length = 1;\n\tspriv->range[8].l.range[0].min = 0;\n\tspriv->range[8].l.range[0].max = 65535;\n\n\tspriv->range_table_list[56] = &spriv->range[8].l;\n\tspriv->range_table_list[57] = &spriv->range[8].l;\n\tspriv->maxdata_list[56] = 0xffff;\n\tspriv->maxdata_list[57] = 0xffff;\n\n\treturn spriv;\n}\n\nstatic void jr3_pci_show_copyright(struct comedi_device *dev)\n{\n\tstruct jr3_block __iomem *block = dev->mmio;\n\tstruct jr3_sensor __iomem *sensor0 = &block[0].sensor;\n\tchar copy[ARRAY_SIZE(sensor0->copyright) + 1];\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(sensor0->copyright); i++)\n\t\tcopy[i] = (char)(get_u16(&sensor0->copyright[i]) >> 8);\n\tcopy[i] = '\\0';\n\tdev_dbg(dev->class_dev, \"Firmware copyright: %s\\n\", copy);\n}\n\nstatic int jr3_pci_auto_attach(struct comedi_device *dev,\n\t\t\t       unsigned long context)\n{\n\tstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\n\tstatic const struct jr3_pci_board *board;\n\tstruct jr3_pci_dev_private *devpriv;\n\tstruct jr3_pci_subdev_private *spriv;\n\tstruct jr3_block __iomem *block;\n\tstruct comedi_subdevice *s;\n\tint ret;\n\tint i;\n\n\tBUILD_BUG_ON(sizeof(struct jr3_block) != 0x80000);\n\n\tif (context < ARRAY_SIZE(jr3_pci_boards))\n\t\tboard = &jr3_pci_boards[context];\n\tif (!board)\n\t\treturn -ENODEV;\n\tdev->board_ptr = board;\n\tdev->board_name = board->name;\n\n\tdevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\n\tif (!devpriv)\n\t\treturn -ENOMEM;\n\n\tret = comedi_pci_enable(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (pci_resource_len(pcidev, 0) < board->n_subdevs * sizeof(*block))\n\t\treturn -ENXIO;\n\n\tdev->mmio = pci_ioremap_bar(pcidev, 0);\n\tif (!dev->mmio)\n\t\treturn -ENOMEM;\n\n\tblock = dev->mmio;\n\n\tret = comedi_alloc_subdevices(dev, board->n_subdevs);\n\tif (ret)\n\t\treturn ret;\n\n\tdev->open = jr3_pci_open;\n\tfor (i = 0; i < dev->n_subdevices; i++) {\n\t\ts = &dev->subdevices[i];\n\t\ts->type\t\t= COMEDI_SUBD_AI;\n\t\ts->subdev_flags\t= SDF_READABLE | SDF_GROUND;\n\t\ts->n_chan\t= 8 * 7 + 2;\n\t\ts->insn_read\t= jr3_pci_ai_insn_read;\n\n\t\tspriv = jr3_pci_alloc_spriv(dev, s);\n\t\tif (!spriv)\n\t\t\treturn -ENOMEM;\n\n\t\t \n\t\ts->range_table_list\t= spriv->range_table_list;\n\t\ts->maxdata_list\t\t= spriv->maxdata_list;\n\t}\n\n\t \n\tfor (i = 0; i < dev->n_subdevices; i++)\n\t\twritel(0, &block[i].reset);\n\n\tret = comedi_load_firmware(dev, &comedi_to_pci_dev(dev)->dev,\n\t\t\t\t   \"comedi/jr3pci.idm\",\n\t\t\t\t   jr3_download_firmware, 0);\n\tdev_dbg(dev->class_dev, \"Firmware load %d\\n\", ret);\n\tif (ret < 0)\n\t\treturn ret;\n\t \n\n\t \n\tmsleep_interruptible(25);\n\tjr3_pci_show_copyright(dev);\n\n\t \n\tfor (i = 0; i < dev->n_subdevices; i++) {\n\t\ts = &dev->subdevices[i];\n\t\tspriv = s->private;\n\n\t\tspriv->next_time_min = jiffies + msecs_to_jiffies(500);\n\t}\n\n\tdevpriv->dev = dev;\n\ttimer_setup(&devpriv->timer, jr3_pci_poll_dev, 0);\n\tdevpriv->timer.expires = jiffies + msecs_to_jiffies(1000);\n\tadd_timer(&devpriv->timer);\n\n\treturn 0;\n}\n\nstatic void jr3_pci_detach(struct comedi_device *dev)\n{\n\tstruct jr3_pci_dev_private *devpriv = dev->private;\n\n\tif (devpriv)\n\t\tdel_timer_sync(&devpriv->timer);\n\n\tcomedi_pci_detach(dev);\n}\n\nstatic struct comedi_driver jr3_pci_driver = {\n\t.driver_name\t= \"jr3_pci\",\n\t.module\t\t= THIS_MODULE,\n\t.auto_attach\t= jr3_pci_auto_attach,\n\t.detach\t\t= jr3_pci_detach,\n};\n\nstatic int jr3_pci_pci_probe(struct pci_dev *dev,\n\t\t\t     const struct pci_device_id *id)\n{\n\treturn comedi_pci_auto_config(dev, &jr3_pci_driver, id->driver_data);\n}\n\nstatic const struct pci_device_id jr3_pci_pci_table[] = {\n\t{ PCI_VDEVICE(JR3, 0x1111), BOARD_JR3_1 },\n\t{ PCI_VDEVICE(JR3, 0x3111), BOARD_JR3_1 },\n\t{ PCI_VDEVICE(JR3, 0x3112), BOARD_JR3_2 },\n\t{ PCI_VDEVICE(JR3, 0x3113), BOARD_JR3_3 },\n\t{ PCI_VDEVICE(JR3, 0x3114), BOARD_JR3_4 },\n\t{ 0 }\n};\nMODULE_DEVICE_TABLE(pci, jr3_pci_pci_table);\n\nstatic struct pci_driver jr3_pci_pci_driver = {\n\t.name\t\t= \"jr3_pci\",\n\t.id_table\t= jr3_pci_pci_table,\n\t.probe\t\t= jr3_pci_pci_probe,\n\t.remove\t\t= comedi_pci_auto_unconfig,\n};\nmodule_comedi_pci_driver(jr3_pci_driver, jr3_pci_pci_driver);\n\nMODULE_AUTHOR(\"Comedi https://www.comedi.org\");\nMODULE_DESCRIPTION(\"Comedi driver for JR3/PCI force sensor board\");\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(\"comedi/jr3pci.idm\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}