{
  "module_name": "pcmmio.c",
  "hash_id": "8931d16ed1cf0074bd951201882219df2c5ccf05ace6194c8add0602f9566d5c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/pcmmio.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/comedi/comedidev.h>\n\n \n#define PCMMIO_AI_LSB_REG\t\t\t0x00\n#define PCMMIO_AI_MSB_REG\t\t\t0x01\n#define PCMMIO_AI_CMD_REG\t\t\t0x02\n#define PCMMIO_AI_CMD_SE\t\t\tBIT(7)\n#define PCMMIO_AI_CMD_ODD_CHAN\t\t\tBIT(6)\n#define PCMMIO_AI_CMD_CHAN_SEL(x)\t\t(((x) & 0x3) << 4)\n#define PCMMIO_AI_CMD_RANGE(x)\t\t\t(((x) & 0x3) << 2)\n#define PCMMIO_RESOURCE_REG\t\t\t0x02\n#define PCMMIO_RESOURCE_IRQ(x)\t\t\t(((x) & 0xf) << 0)\n#define PCMMIO_AI_STATUS_REG\t\t\t0x03\n#define PCMMIO_AI_STATUS_DATA_READY\t\tBIT(7)\n#define PCMMIO_AI_STATUS_DATA_DMA_PEND\t\tBIT(6)\n#define PCMMIO_AI_STATUS_CMD_DMA_PEND\t\tBIT(5)\n#define PCMMIO_AI_STATUS_IRQ_PEND\t\tBIT(4)\n#define PCMMIO_AI_STATUS_DATA_DRQ_ENA\t\tBIT(2)\n#define PCMMIO_AI_STATUS_REG_SEL\t\tBIT(3)\n#define PCMMIO_AI_STATUS_CMD_DRQ_ENA\t\tBIT(1)\n#define PCMMIO_AI_STATUS_IRQ_ENA\t\tBIT(0)\n#define PCMMIO_AI_RES_ENA_REG\t\t\t0x03\n#define PCMMIO_AI_RES_ENA_CMD_REG_ACCESS\t(0 << 3)\n#define PCMMIO_AI_RES_ENA_AI_RES_ACCESS\t\tBIT(3)\n#define PCMMIO_AI_RES_ENA_DIO_RES_ACCESS\tBIT(4)\n#define PCMMIO_AI_2ND_ADC_OFFSET\t\t0x04\n\n#define PCMMIO_AO_LSB_REG\t\t\t0x08\n#define PCMMIO_AO_LSB_SPAN(x)\t\t\t(((x) & 0xf) << 0)\n#define PCMMIO_AO_MSB_REG\t\t\t0x09\n#define PCMMIO_AO_CMD_REG\t\t\t0x0a\n#define PCMMIO_AO_CMD_WR_SPAN\t\t\t(0x2 << 4)\n#define PCMMIO_AO_CMD_WR_CODE\t\t\t(0x3 << 4)\n#define PCMMIO_AO_CMD_UPDATE\t\t\t(0x4 << 4)\n#define PCMMIO_AO_CMD_UPDATE_ALL\t\t(0x5 << 4)\n#define PCMMIO_AO_CMD_WR_SPAN_UPDATE\t\t(0x6 << 4)\n#define PCMMIO_AO_CMD_WR_CODE_UPDATE\t\t(0x7 << 4)\n#define PCMMIO_AO_CMD_WR_SPAN_UPDATE_ALL\t(0x8 << 4)\n#define PCMMIO_AO_CMD_WR_CODE_UPDATE_ALL\t(0x9 << 4)\n#define PCMMIO_AO_CMD_RD_B1_SPAN\t\t(0xa << 4)\n#define PCMMIO_AO_CMD_RD_B1_CODE\t\t(0xb << 4)\n#define PCMMIO_AO_CMD_RD_B2_SPAN\t\t(0xc << 4)\n#define PCMMIO_AO_CMD_RD_B2_CODE\t\t(0xd << 4)\n#define PCMMIO_AO_CMD_NOP\t\t\t(0xf << 4)\n#define PCMMIO_AO_CMD_CHAN_SEL(x)\t\t(((x) & 0x03) << 1)\n#define PCMMIO_AO_CMD_CHAN_SEL_ALL\t\t(0x0f << 0)\n#define PCMMIO_AO_STATUS_REG\t\t\t0x0b\n#define PCMMIO_AO_STATUS_DATA_READY\t\tBIT(7)\n#define PCMMIO_AO_STATUS_DATA_DMA_PEND\t\tBIT(6)\n#define PCMMIO_AO_STATUS_CMD_DMA_PEND\t\tBIT(5)\n#define PCMMIO_AO_STATUS_IRQ_PEND\t\tBIT(4)\n#define PCMMIO_AO_STATUS_DATA_DRQ_ENA\t\tBIT(2)\n#define PCMMIO_AO_STATUS_REG_SEL\t\tBIT(3)\n#define PCMMIO_AO_STATUS_CMD_DRQ_ENA\t\tBIT(1)\n#define PCMMIO_AO_STATUS_IRQ_ENA\t\tBIT(0)\n#define PCMMIO_AO_RESOURCE_ENA_REG\t\t0x0b\n#define PCMMIO_AO_2ND_DAC_OFFSET\t\t0x04\n\n \n#define PCMMIO_PORT_REG(x)\t\t\t(0x10 + (x))\n#define PCMMIO_INT_PENDING_REG\t\t\t0x16\n#define PCMMIO_PAGE_LOCK_REG\t\t\t0x17\n#define PCMMIO_LOCK_PORT(x)\t\t\t((1 << (x)) & 0x3f)\n#define PCMMIO_PAGE(x)\t\t\t\t(((x) & 0x3) << 6)\n#define PCMMIO_PAGE_MASK\t\t\tPCMUIO_PAGE(3)\n#define PCMMIO_PAGE_POL\t\t\t\t1\n#define PCMMIO_PAGE_ENAB\t\t\t2\n#define PCMMIO_PAGE_INT_ID\t\t\t3\n#define PCMMIO_PAGE_REG(x)\t\t\t(0x18 + (x))\n\nstatic const struct comedi_lrange pcmmio_ai_ranges = {\n\t4, {\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(10),\n\t\tUNI_RANGE(5),\n\t\tUNI_RANGE(10)\n\t}\n};\n\nstatic const struct comedi_lrange pcmmio_ao_ranges = {\n\t6, {\n\t\tUNI_RANGE(5),\n\t\tUNI_RANGE(10),\n\t\tBIP_RANGE(5),\n\t\tBIP_RANGE(10),\n\t\tBIP_RANGE(2.5),\n\t\tRANGE(-2.5, 7.5)\n\t}\n};\n\nstruct pcmmio_private {\n\tspinlock_t pagelock;\t \n\tspinlock_t spinlock;\t \n\tunsigned int enabled_mask;\n\tunsigned int active:1;\n};\n\nstatic void pcmmio_dio_write(struct comedi_device *dev, unsigned int val,\n\t\t\t     int page, int port)\n{\n\tstruct pcmmio_private *devpriv = dev->private;\n\tunsigned long iobase = dev->iobase;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&devpriv->pagelock, flags);\n\tif (page == 0) {\n\t\t \n\t\toutb(val & 0xff, iobase + PCMMIO_PORT_REG(port + 0));\n\t\toutb((val >> 8) & 0xff, iobase + PCMMIO_PORT_REG(port + 1));\n\t\toutb((val >> 16) & 0xff, iobase + PCMMIO_PORT_REG(port + 2));\n\t} else {\n\t\toutb(PCMMIO_PAGE(page), iobase + PCMMIO_PAGE_LOCK_REG);\n\t\toutb(val & 0xff, iobase + PCMMIO_PAGE_REG(0));\n\t\toutb((val >> 8) & 0xff, iobase + PCMMIO_PAGE_REG(1));\n\t\toutb((val >> 16) & 0xff, iobase + PCMMIO_PAGE_REG(2));\n\t}\n\tspin_unlock_irqrestore(&devpriv->pagelock, flags);\n}\n\nstatic unsigned int pcmmio_dio_read(struct comedi_device *dev,\n\t\t\t\t    int page, int port)\n{\n\tstruct pcmmio_private *devpriv = dev->private;\n\tunsigned long iobase = dev->iobase;\n\tunsigned long flags;\n\tunsigned int val;\n\n\tspin_lock_irqsave(&devpriv->pagelock, flags);\n\tif (page == 0) {\n\t\t \n\t\tval = inb(iobase + PCMMIO_PORT_REG(port + 0));\n\t\tval |= (inb(iobase + PCMMIO_PORT_REG(port + 1)) << 8);\n\t\tval |= (inb(iobase + PCMMIO_PORT_REG(port + 2)) << 16);\n\t} else {\n\t\toutb(PCMMIO_PAGE(page), iobase + PCMMIO_PAGE_LOCK_REG);\n\t\tval = inb(iobase + PCMMIO_PAGE_REG(0));\n\t\tval |= (inb(iobase + PCMMIO_PAGE_REG(1)) << 8);\n\t\tval |= (inb(iobase + PCMMIO_PAGE_REG(2)) << 16);\n\t}\n\tspin_unlock_irqrestore(&devpriv->pagelock, flags);\n\n\treturn val;\n}\n\n \nstatic int pcmmio_dio_insn_bits(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tstruct comedi_insn *insn,\n\t\t\t\tunsigned int *data)\n{\n\t \n\tint port = s->index == 2 ? 0 : 3;\n\tunsigned int chanmask = (1 << s->n_chan) - 1;\n\tunsigned int mask;\n\tunsigned int val;\n\n\tmask = comedi_dio_update_state(s, data);\n\tif (mask) {\n\t\t \n\t\tval = ~s->state & chanmask;\n\t\tval &= s->io_bits;\n\t\tpcmmio_dio_write(dev, val, 0, port);\n\t}\n\n\t \n\tval = pcmmio_dio_read(dev, 0, port);\n\n\t \n\tdata[1] = ~val & chanmask;\n\n\treturn insn->n;\n}\n\nstatic int pcmmio_dio_insn_config(struct comedi_device *dev,\n\t\t\t\t  struct comedi_subdevice *s,\n\t\t\t\t  struct comedi_insn *insn,\n\t\t\t\t  unsigned int *data)\n{\n\t \n\tint port = s->index == 2 ? 0 : 3;\n\tint ret;\n\n\tret = comedi_dio_insn_config(dev, s, insn, data, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tif (data[0] == INSN_CONFIG_DIO_INPUT)\n\t\tpcmmio_dio_write(dev, s->io_bits, 0, port);\n\n\treturn insn->n;\n}\n\nstatic void pcmmio_reset(struct comedi_device *dev)\n{\n\t \n\tpcmmio_dio_write(dev, 0, 0, 0);\n\tpcmmio_dio_write(dev, 0, 0, 3);\n\n\t \n\tpcmmio_dio_write(dev, 0, PCMMIO_PAGE_POL, 0);\n\tpcmmio_dio_write(dev, 0, PCMMIO_PAGE_ENAB, 0);\n\tpcmmio_dio_write(dev, 0, PCMMIO_PAGE_INT_ID, 0);\n}\n\n \nstatic void pcmmio_stop_intr(struct comedi_device *dev,\n\t\t\t     struct comedi_subdevice *s)\n{\n\tstruct pcmmio_private *devpriv = dev->private;\n\n\tdevpriv->enabled_mask = 0;\n\tdevpriv->active = 0;\n\ts->async->inttrig = NULL;\n\n\t \n\tpcmmio_dio_write(dev, 0, PCMMIO_PAGE_ENAB, 0);\n}\n\nstatic void pcmmio_handle_dio_intr(struct comedi_device *dev,\n\t\t\t\t   struct comedi_subdevice *s,\n\t\t\t\t   unsigned int triggered)\n{\n\tstruct pcmmio_private *devpriv = dev->private;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tunsigned int val = 0;\n\tunsigned long flags;\n\tint i;\n\n\tspin_lock_irqsave(&devpriv->spinlock, flags);\n\n\tif (!devpriv->active)\n\t\tgoto done;\n\n\tif (!(triggered & devpriv->enabled_mask))\n\t\tgoto done;\n\n\tfor (i = 0; i < cmd->chanlist_len; i++) {\n\t\tunsigned int chan = CR_CHAN(cmd->chanlist[i]);\n\n\t\tif (triggered & (1 << chan))\n\t\t\tval |= (1 << i);\n\t}\n\n\tcomedi_buf_write_samples(s, &val, 1);\n\n\tif (cmd->stop_src == TRIG_COUNT &&\n\t    s->async->scans_done >= cmd->stop_arg)\n\t\ts->async->events |= COMEDI_CB_EOA;\n\ndone:\n\tspin_unlock_irqrestore(&devpriv->spinlock, flags);\n\n\tcomedi_handle_events(dev, s);\n}\n\nstatic irqreturn_t interrupt_pcmmio(int irq, void *d)\n{\n\tstruct comedi_device *dev = d;\n\tstruct comedi_subdevice *s = dev->read_subdev;\n\tunsigned int triggered;\n\tunsigned char int_pend;\n\n\t \n\tint_pend = inb(dev->iobase + PCMMIO_INT_PENDING_REG) & 0x07;\n\tif (!int_pend)\n\t\treturn IRQ_NONE;\n\n\t \n\ttriggered = pcmmio_dio_read(dev, PCMMIO_PAGE_INT_ID, 0);\n\tpcmmio_dio_write(dev, 0, PCMMIO_PAGE_INT_ID, 0);\n\n\tpcmmio_handle_dio_intr(dev, s, triggered);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void pcmmio_start_intr(struct comedi_device *dev,\n\t\t\t      struct comedi_subdevice *s)\n{\n\tstruct pcmmio_private *devpriv = dev->private;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tunsigned int bits = 0;\n\tunsigned int pol_bits = 0;\n\tint i;\n\n\tdevpriv->enabled_mask = 0;\n\tdevpriv->active = 1;\n\tif (cmd->chanlist) {\n\t\tfor (i = 0; i < cmd->chanlist_len; i++) {\n\t\t\tunsigned int chanspec = cmd->chanlist[i];\n\t\t\tunsigned int chan = CR_CHAN(chanspec);\n\t\t\tunsigned int range = CR_RANGE(chanspec);\n\t\t\tunsigned int aref = CR_AREF(chanspec);\n\n\t\t\tbits |= (1 << chan);\n\t\t\tpol_bits |= (((aref || range) ? 1 : 0) << chan);\n\t\t}\n\t}\n\tbits &= ((1 << s->n_chan) - 1);\n\tdevpriv->enabled_mask = bits;\n\n\t \n\tpcmmio_dio_write(dev, pol_bits, PCMMIO_PAGE_POL, 0);\n\tpcmmio_dio_write(dev, bits, PCMMIO_PAGE_ENAB, 0);\n}\n\nstatic int pcmmio_cancel(struct comedi_device *dev, struct comedi_subdevice *s)\n{\n\tstruct pcmmio_private *devpriv = dev->private;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&devpriv->spinlock, flags);\n\tif (devpriv->active)\n\t\tpcmmio_stop_intr(dev, s);\n\tspin_unlock_irqrestore(&devpriv->spinlock, flags);\n\n\treturn 0;\n}\n\nstatic int pcmmio_inttrig_start_intr(struct comedi_device *dev,\n\t\t\t\t     struct comedi_subdevice *s,\n\t\t\t\t     unsigned int trig_num)\n{\n\tstruct pcmmio_private *devpriv = dev->private;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tunsigned long flags;\n\n\tif (trig_num != cmd->start_arg)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&devpriv->spinlock, flags);\n\ts->async->inttrig = NULL;\n\tif (devpriv->active)\n\t\tpcmmio_start_intr(dev, s);\n\tspin_unlock_irqrestore(&devpriv->spinlock, flags);\n\n\treturn 1;\n}\n\n \nstatic int pcmmio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\n{\n\tstruct pcmmio_private *devpriv = dev->private;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&devpriv->spinlock, flags);\n\tdevpriv->active = 1;\n\n\t \n\tif (cmd->start_src == TRIG_INT)\n\t\ts->async->inttrig = pcmmio_inttrig_start_intr;\n\telse\t \n\t\tpcmmio_start_intr(dev, s);\n\n\tspin_unlock_irqrestore(&devpriv->spinlock, flags);\n\n\treturn 0;\n}\n\nstatic int pcmmio_cmdtest(struct comedi_device *dev,\n\t\t\t  struct comedi_subdevice *s,\n\t\t\t  struct comedi_cmd *cmd)\n{\n\tint err = 0;\n\n\t \n\n\terr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_INT);\n\terr |= comedi_check_trigger_src(&cmd->scan_begin_src, TRIG_EXT);\n\terr |= comedi_check_trigger_src(&cmd->convert_src, TRIG_NOW);\n\terr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\n\terr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\n\n\tif (err)\n\t\treturn 1;\n\n\t \n\n\terr |= comedi_check_trigger_is_unique(cmd->start_src);\n\terr |= comedi_check_trigger_is_unique(cmd->stop_src);\n\n\t \n\n\tif (err)\n\t\treturn 2;\n\n\t \n\n\terr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);\n\terr |= comedi_check_trigger_arg_is(&cmd->convert_arg, 0);\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\n\t\t\t\t\t   cmd->chanlist_len);\n\n\tif (cmd->stop_src == TRIG_COUNT)\n\t\terr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\n\telse\t \n\t\terr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\n\n\tif (err)\n\t\treturn 3;\n\n\t \n\n\t \n\n\treturn 0;\n}\n\nstatic int pcmmio_ai_eoc(struct comedi_device *dev,\n\t\t\t struct comedi_subdevice *s,\n\t\t\t struct comedi_insn *insn,\n\t\t\t unsigned long context)\n{\n\tunsigned char status;\n\n\tstatus = inb(dev->iobase + PCMMIO_AI_STATUS_REG);\n\tif (status & PCMMIO_AI_STATUS_DATA_READY)\n\t\treturn 0;\n\treturn -EBUSY;\n}\n\nstatic int pcmmio_ai_insn_read(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       struct comedi_insn *insn,\n\t\t\t       unsigned int *data)\n{\n\tunsigned long iobase = dev->iobase;\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int range = CR_RANGE(insn->chanspec);\n\tunsigned int aref = CR_AREF(insn->chanspec);\n\tunsigned char cmd = 0;\n\tunsigned int val;\n\tint ret;\n\tint i;\n\n\t \n\n\tif (chan > 7) {\n\t\tchan -= 8;\n\t\tiobase += PCMMIO_AI_2ND_ADC_OFFSET;\n\t}\n\n\tif (aref == AREF_GROUND)\n\t\tcmd |= PCMMIO_AI_CMD_SE;\n\tif (chan % 2)\n\t\tcmd |= PCMMIO_AI_CMD_ODD_CHAN;\n\tcmd |= PCMMIO_AI_CMD_CHAN_SEL(chan / 2);\n\tcmd |= PCMMIO_AI_CMD_RANGE(range);\n\n\toutb(cmd, iobase + PCMMIO_AI_CMD_REG);\n\n\tret = comedi_timeout(dev, s, insn, pcmmio_ai_eoc, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tval = inb(iobase + PCMMIO_AI_LSB_REG);\n\tval |= inb(iobase + PCMMIO_AI_MSB_REG) << 8;\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\toutb(cmd, iobase + PCMMIO_AI_CMD_REG);\n\n\t\tret = comedi_timeout(dev, s, insn, pcmmio_ai_eoc, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tval = inb(iobase + PCMMIO_AI_LSB_REG);\n\t\tval |= inb(iobase + PCMMIO_AI_MSB_REG) << 8;\n\n\t\t \n\t\tif (comedi_range_is_bipolar(s, range))\n\t\t\tval = comedi_offset_munge(s, val);\n\n\t\tdata[i] = val;\n\t}\n\n\treturn insn->n;\n}\n\nstatic int pcmmio_ao_eoc(struct comedi_device *dev,\n\t\t\t struct comedi_subdevice *s,\n\t\t\t struct comedi_insn *insn,\n\t\t\t unsigned long context)\n{\n\tunsigned char status;\n\n\tstatus = inb(dev->iobase + PCMMIO_AO_STATUS_REG);\n\tif (status & PCMMIO_AO_STATUS_DATA_READY)\n\t\treturn 0;\n\treturn -EBUSY;\n}\n\nstatic int pcmmio_ao_insn_write(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tstruct comedi_insn *insn,\n\t\t\t\tunsigned int *data)\n{\n\tunsigned long iobase = dev->iobase;\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int range = CR_RANGE(insn->chanspec);\n\tunsigned char cmd = 0;\n\tint ret;\n\tint i;\n\n\t \n\n\tif (chan > 3) {\n\t\tcmd |= PCMMIO_AO_CMD_CHAN_SEL(chan - 4);\n\t\tiobase += PCMMIO_AO_2ND_DAC_OFFSET;\n\t} else {\n\t\tcmd |= PCMMIO_AO_CMD_CHAN_SEL(chan);\n\t}\n\n\t \n\toutb(PCMMIO_AO_LSB_SPAN(range), iobase + PCMMIO_AO_LSB_REG);\n\toutb(0, iobase + PCMMIO_AO_MSB_REG);\n\toutb(cmd | PCMMIO_AO_CMD_WR_SPAN_UPDATE, iobase + PCMMIO_AO_CMD_REG);\n\n\tret = comedi_timeout(dev, s, insn, pcmmio_ao_eoc, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\tunsigned int val = data[i];\n\n\t\t \n\t\toutb(val & 0xff, iobase + PCMMIO_AO_LSB_REG);\n\t\toutb((val >> 8) & 0xff, iobase + PCMMIO_AO_MSB_REG);\n\t\toutb(cmd | PCMMIO_AO_CMD_WR_CODE_UPDATE,\n\t\t     iobase + PCMMIO_AO_CMD_REG);\n\n\t\tret = comedi_timeout(dev, s, insn, pcmmio_ao_eoc, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\ts->readback[chan] = val;\n\t}\n\n\treturn insn->n;\n}\n\nstatic int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)\n{\n\tstruct pcmmio_private *devpriv;\n\tstruct comedi_subdevice *s;\n\tint ret;\n\n\tret = comedi_request_region(dev, it->options[0], 32);\n\tif (ret)\n\t\treturn ret;\n\n\tdevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\n\tif (!devpriv)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&devpriv->pagelock);\n\tspin_lock_init(&devpriv->spinlock);\n\n\tpcmmio_reset(dev);\n\n\tif (it->options[1]) {\n\t\tret = request_irq(it->options[1], interrupt_pcmmio, 0,\n\t\t\t\t  dev->board_name, dev);\n\t\tif (ret == 0) {\n\t\t\tdev->irq = it->options[1];\n\n\t\t\t \n\t\t\toutb(PCMMIO_AI_RES_ENA_DIO_RES_ACCESS,\n\t\t\t     dev->iobase + PCMMIO_AI_RES_ENA_REG);\n\t\t\toutb(PCMMIO_RESOURCE_IRQ(dev->irq),\n\t\t\t     dev->iobase + PCMMIO_RESOURCE_REG);\n\t\t}\n\t}\n\n\tret = comedi_alloc_subdevices(dev, 4);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ts = &dev->subdevices[0];\n\ts->type\t\t= COMEDI_SUBD_AI;\n\ts->subdev_flags\t= SDF_READABLE | SDF_GROUND | SDF_DIFF;\n\ts->n_chan\t= 16;\n\ts->maxdata\t= 0xffff;\n\ts->range_table\t= &pcmmio_ai_ranges;\n\ts->insn_read\t= pcmmio_ai_insn_read;\n\n\t \n\toutb(PCMMIO_AI_RES_ENA_CMD_REG_ACCESS,\n\t     dev->iobase + PCMMIO_AI_RES_ENA_REG);\n\toutb(PCMMIO_AI_RES_ENA_CMD_REG_ACCESS,\n\t     dev->iobase + PCMMIO_AI_RES_ENA_REG + PCMMIO_AI_2ND_ADC_OFFSET);\n\n\t \n\ts = &dev->subdevices[1];\n\ts->type\t\t= COMEDI_SUBD_AO;\n\ts->subdev_flags\t= SDF_READABLE;\n\ts->n_chan\t= 8;\n\ts->maxdata\t= 0xffff;\n\ts->range_table\t= &pcmmio_ao_ranges;\n\ts->insn_write\t= pcmmio_ao_insn_write;\n\n\tret = comedi_alloc_subdev_readback(s);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\toutb(0, dev->iobase + PCMMIO_AO_RESOURCE_ENA_REG);\n\toutb(0, dev->iobase + PCMMIO_AO_2ND_DAC_OFFSET +\n\t\tPCMMIO_AO_RESOURCE_ENA_REG);\n\n\t \n\ts = &dev->subdevices[2];\n\ts->type\t\t= COMEDI_SUBD_DIO;\n\ts->subdev_flags\t= SDF_READABLE | SDF_WRITABLE;\n\ts->n_chan\t= 24;\n\ts->maxdata\t= 1;\n\ts->len_chanlist\t= 1;\n\ts->range_table\t= &range_digital;\n\ts->insn_bits\t= pcmmio_dio_insn_bits;\n\ts->insn_config\t= pcmmio_dio_insn_config;\n\tif (dev->irq) {\n\t\tdev->read_subdev = s;\n\t\ts->subdev_flags\t|= SDF_CMD_READ | SDF_LSAMPL | SDF_PACKED;\n\t\ts->len_chanlist\t= s->n_chan;\n\t\ts->cancel\t= pcmmio_cancel;\n\t\ts->do_cmd\t= pcmmio_cmd;\n\t\ts->do_cmdtest\t= pcmmio_cmdtest;\n\t}\n\n\t \n\ts = &dev->subdevices[3];\n\ts->type\t\t= COMEDI_SUBD_DIO;\n\ts->subdev_flags\t= SDF_READABLE | SDF_WRITABLE;\n\ts->n_chan\t= 24;\n\ts->maxdata\t= 1;\n\ts->range_table\t= &range_digital;\n\ts->insn_bits\t= pcmmio_dio_insn_bits;\n\ts->insn_config\t= pcmmio_dio_insn_config;\n\n\treturn 0;\n}\n\nstatic struct comedi_driver pcmmio_driver = {\n\t.driver_name\t= \"pcmmio\",\n\t.module\t\t= THIS_MODULE,\n\t.attach\t\t= pcmmio_attach,\n\t.detach\t\t= comedi_legacy_detach,\n};\nmodule_comedi_driver(pcmmio_driver);\n\nMODULE_AUTHOR(\"Comedi https://www.comedi.org\");\nMODULE_DESCRIPTION(\"Comedi driver for Winsystems PCM-MIO PC/104 board\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}