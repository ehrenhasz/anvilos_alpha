{
  "module_name": "ni_6527.c",
  "hash_id": "81886028b20aae53b70c3354cbed34e3e12350afc46d1b243a249f647a2d7fe4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/ni_6527.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/comedi/comedi_pci.h>\n\n \n#define NI6527_DI_REG(x)\t\t(0x00 + (x))\n#define NI6527_DO_REG(x)\t\t(0x03 + (x))\n#define NI6527_ID_REG\t\t\t0x06\n#define NI6527_CLR_REG\t\t\t0x07\n#define NI6527_CLR_EDGE\t\t\tBIT(3)\n#define NI6527_CLR_OVERFLOW\t\tBIT(2)\n#define NI6527_CLR_FILT\t\t\tBIT(1)\n#define NI6527_CLR_INTERVAL\t\tBIT(0)\n#define NI6527_CLR_IRQS\t\t\t(NI6527_CLR_EDGE | NI6527_CLR_OVERFLOW)\n#define NI6527_CLR_RESET_FILT\t\t(NI6527_CLR_FILT | NI6527_CLR_INTERVAL)\n#define NI6527_FILT_INTERVAL_REG(x)\t(0x08 + (x))\n#define NI6527_FILT_ENA_REG(x)\t\t(0x0c + (x))\n#define NI6527_STATUS_REG\t\t0x14\n#define NI6527_STATUS_IRQ\t\tBIT(2)\n#define NI6527_STATUS_OVERFLOW\t\tBIT(1)\n#define NI6527_STATUS_EDGE\t\tBIT(0)\n#define NI6527_CTRL_REG\t\t\t0x15\n#define NI6527_CTRL_FALLING\t\tBIT(4)\n#define NI6527_CTRL_RISING\t\tBIT(3)\n#define NI6527_CTRL_IRQ\t\t\tBIT(2)\n#define NI6527_CTRL_OVERFLOW\t\tBIT(1)\n#define NI6527_CTRL_EDGE\t\tBIT(0)\n#define NI6527_CTRL_DISABLE_IRQS\t0\n#define NI6527_CTRL_ENABLE_IRQS\t\t(NI6527_CTRL_FALLING | \\\n\t\t\t\t\t NI6527_CTRL_RISING | \\\n\t\t\t\t\t NI6527_CTRL_IRQ | NI6527_CTRL_EDGE)\n#define NI6527_RISING_EDGE_REG(x)\t(0x18 + (x))\n#define NI6527_FALLING_EDGE_REG(x)\t(0x20 + (x))\n\nenum ni6527_boardid {\n\tBOARD_PCI6527,\n\tBOARD_PXI6527,\n};\n\nstruct ni6527_board {\n\tconst char *name;\n};\n\nstatic const struct ni6527_board ni6527_boards[] = {\n\t[BOARD_PCI6527] = {\n\t\t.name\t\t= \"pci-6527\",\n\t},\n\t[BOARD_PXI6527] = {\n\t\t.name\t\t= \"pxi-6527\",\n\t},\n};\n\nstruct ni6527_private {\n\tunsigned int filter_interval;\n\tunsigned int filter_enable;\n};\n\nstatic void ni6527_set_filter_interval(struct comedi_device *dev,\n\t\t\t\t       unsigned int val)\n{\n\tstruct ni6527_private *devpriv = dev->private;\n\n\tif (val != devpriv->filter_interval) {\n\t\twriteb(val & 0xff, dev->mmio + NI6527_FILT_INTERVAL_REG(0));\n\t\twriteb((val >> 8) & 0xff,\n\t\t       dev->mmio + NI6527_FILT_INTERVAL_REG(1));\n\t\twriteb((val >> 16) & 0x0f,\n\t\t       dev->mmio + NI6527_FILT_INTERVAL_REG(2));\n\n\t\twriteb(NI6527_CLR_INTERVAL, dev->mmio + NI6527_CLR_REG);\n\n\t\tdevpriv->filter_interval = val;\n\t}\n}\n\nstatic void ni6527_set_filter_enable(struct comedi_device *dev,\n\t\t\t\t     unsigned int val)\n{\n\twriteb(val & 0xff, dev->mmio + NI6527_FILT_ENA_REG(0));\n\twriteb((val >> 8) & 0xff, dev->mmio + NI6527_FILT_ENA_REG(1));\n\twriteb((val >> 16) & 0xff, dev->mmio + NI6527_FILT_ENA_REG(2));\n}\n\nstatic int ni6527_di_insn_config(struct comedi_device *dev,\n\t\t\t\t struct comedi_subdevice *s,\n\t\t\t\t struct comedi_insn *insn,\n\t\t\t\t unsigned int *data)\n{\n\tstruct ni6527_private *devpriv = dev->private;\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int interval;\n\n\tswitch (data[0]) {\n\tcase INSN_CONFIG_FILTER:\n\t\t \n\t\tinterval = (data[1] + 100) / 200;\n\t\tdata[1] = interval * 200;\n\n\t\tif (interval) {\n\t\t\tni6527_set_filter_interval(dev, interval);\n\t\t\tdevpriv->filter_enable |= 1 << chan;\n\t\t} else {\n\t\t\tdevpriv->filter_enable &= ~(1 << chan);\n\t\t}\n\t\tni6527_set_filter_enable(dev, devpriv->filter_enable);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn insn->n;\n}\n\nstatic int ni6527_di_insn_bits(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       struct comedi_insn *insn,\n\t\t\t       unsigned int *data)\n{\n\tunsigned int val;\n\n\tval = readb(dev->mmio + NI6527_DI_REG(0));\n\tval |= (readb(dev->mmio + NI6527_DI_REG(1)) << 8);\n\tval |= (readb(dev->mmio + NI6527_DI_REG(2)) << 16);\n\n\tdata[1] = val;\n\n\treturn insn->n;\n}\n\nstatic int ni6527_do_insn_bits(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       struct comedi_insn *insn,\n\t\t\t       unsigned int *data)\n{\n\tunsigned int mask;\n\n\tmask = comedi_dio_update_state(s, data);\n\tif (mask) {\n\t\t \n\t\tunsigned int val = s->state ^ 0xffffff;\n\n\t\tif (mask & 0x0000ff)\n\t\t\twriteb(val & 0xff, dev->mmio + NI6527_DO_REG(0));\n\t\tif (mask & 0x00ff00)\n\t\t\twriteb((val >> 8) & 0xff,\n\t\t\t       dev->mmio + NI6527_DO_REG(1));\n\t\tif (mask & 0xff0000)\n\t\t\twriteb((val >> 16) & 0xff,\n\t\t\t       dev->mmio + NI6527_DO_REG(2));\n\t}\n\n\tdata[1] = s->state;\n\n\treturn insn->n;\n}\n\nstatic irqreturn_t ni6527_interrupt(int irq, void *d)\n{\n\tstruct comedi_device *dev = d;\n\tstruct comedi_subdevice *s = dev->read_subdev;\n\tunsigned int status;\n\n\tstatus = readb(dev->mmio + NI6527_STATUS_REG);\n\tif (!(status & NI6527_STATUS_IRQ))\n\t\treturn IRQ_NONE;\n\n\tif (status & NI6527_STATUS_EDGE) {\n\t\tunsigned short val = 0;\n\n\t\tcomedi_buf_write_samples(s, &val, 1);\n\t\tcomedi_handle_events(dev, s);\n\t}\n\n\twriteb(NI6527_CLR_IRQS, dev->mmio + NI6527_CLR_REG);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ni6527_intr_cmdtest(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       struct comedi_cmd *cmd)\n{\n\tint err = 0;\n\n\t \n\n\terr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW);\n\terr |= comedi_check_trigger_src(&cmd->scan_begin_src, TRIG_OTHER);\n\terr |= comedi_check_trigger_src(&cmd->convert_src, TRIG_FOLLOW);\n\terr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\n\terr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT);\n\n\tif (err)\n\t\treturn 1;\n\n\t \n\t \n\n\t \n\n\terr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);\n\terr |= comedi_check_trigger_arg_is(&cmd->convert_arg, 0);\n\terr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\n\t\t\t\t\t   cmd->chanlist_len);\n\terr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\n\n\tif (err)\n\t\treturn 3;\n\n\t \n\n\t \n\n\treturn 0;\n}\n\nstatic int ni6527_intr_cmd(struct comedi_device *dev,\n\t\t\t   struct comedi_subdevice *s)\n{\n\twriteb(NI6527_CLR_IRQS, dev->mmio + NI6527_CLR_REG);\n\twriteb(NI6527_CTRL_ENABLE_IRQS, dev->mmio + NI6527_CTRL_REG);\n\n\treturn 0;\n}\n\nstatic int ni6527_intr_cancel(struct comedi_device *dev,\n\t\t\t      struct comedi_subdevice *s)\n{\n\twriteb(NI6527_CTRL_DISABLE_IRQS, dev->mmio + NI6527_CTRL_REG);\n\n\treturn 0;\n}\n\nstatic int ni6527_intr_insn_bits(struct comedi_device *dev,\n\t\t\t\t struct comedi_subdevice *s,\n\t\t\t\t struct comedi_insn *insn, unsigned int *data)\n{\n\tdata[1] = 0;\n\treturn insn->n;\n}\n\nstatic void ni6527_set_edge_detection(struct comedi_device *dev,\n\t\t\t\t      unsigned int mask,\n\t\t\t\t      unsigned int rising,\n\t\t\t\t      unsigned int falling)\n{\n\tunsigned int i;\n\n\trising &= mask;\n\tfalling &= mask;\n\tfor (i = 0; i < 2; i++) {\n\t\tif (mask & 0xff) {\n\t\t\tif (~mask & 0xff) {\n\t\t\t\t \n\t\t\t\trising |= readb(dev->mmio +\n\t\t\t\t\t\tNI6527_RISING_EDGE_REG(i)) &\n\t\t\t\t\t  (~mask & 0xff);\n\t\t\t\t \n\t\t\t\tfalling |= readb(dev->mmio +\n\t\t\t\t\t\t NI6527_FALLING_EDGE_REG(i)) &\n\t\t\t\t\t   (~mask & 0xff);\n\t\t\t}\n\t\t\t \n\t\t\twriteb(rising & 0xff,\n\t\t\t       dev->mmio + NI6527_RISING_EDGE_REG(i));\n\t\t\t \n\t\t\twriteb(falling & 0xff,\n\t\t\t       dev->mmio + NI6527_FALLING_EDGE_REG(i));\n\t\t}\n\t\trising >>= 8;\n\t\tfalling >>= 8;\n\t\tmask >>= 8;\n\t}\n}\n\nstatic int ni6527_intr_insn_config(struct comedi_device *dev,\n\t\t\t\t   struct comedi_subdevice *s,\n\t\t\t\t   struct comedi_insn *insn,\n\t\t\t\t   unsigned int *data)\n{\n\tunsigned int mask = 0xffffffff;\n\tunsigned int rising, falling, shift;\n\n\tswitch (data[0]) {\n\tcase INSN_CONFIG_CHANGE_NOTIFY:\n\t\t \n\t\tif (insn->n != 3)\n\t\t\treturn -EINVAL;\n\t\trising = data[1];\n\t\tfalling = data[2];\n\t\tni6527_set_edge_detection(dev, mask, rising, falling);\n\t\tbreak;\n\tcase INSN_CONFIG_DIGITAL_TRIG:\n\t\t \n\t\tif (data[1] != 0)\n\t\t\treturn -EINVAL;\n\t\t \n\t\tswitch (data[2]) {\n\t\tcase COMEDI_DIGITAL_TRIG_DISABLE:\n\t\t\trising = 0;\n\t\t\tfalling = 0;\n\t\t\tbreak;\n\t\tcase COMEDI_DIGITAL_TRIG_ENABLE_EDGES:\n\t\t\t \n\t\t\tshift = data[3];\n\t\t\tif (shift >= 32) {\n\t\t\t\tmask = 0;\n\t\t\t\trising = 0;\n\t\t\t\tfalling = 0;\n\t\t\t} else {\n\t\t\t\tmask <<= shift;\n\t\t\t\trising = data[4] << shift;\n\t\t\t\tfalling = data[5] << shift;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tni6527_set_edge_detection(dev, mask, rising, falling);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn insn->n;\n}\n\nstatic void ni6527_reset(struct comedi_device *dev)\n{\n\t \n\tni6527_set_filter_enable(dev, 0);\n\n\t \n\tni6527_set_edge_detection(dev, 0xffffffff, 0, 0);\n\n\twriteb(NI6527_CLR_IRQS | NI6527_CLR_RESET_FILT,\n\t       dev->mmio + NI6527_CLR_REG);\n\twriteb(NI6527_CTRL_DISABLE_IRQS, dev->mmio + NI6527_CTRL_REG);\n}\n\nstatic int ni6527_auto_attach(struct comedi_device *dev,\n\t\t\t      unsigned long context)\n{\n\tstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\n\tconst struct ni6527_board *board = NULL;\n\tstruct ni6527_private *devpriv;\n\tstruct comedi_subdevice *s;\n\tint ret;\n\n\tif (context < ARRAY_SIZE(ni6527_boards))\n\t\tboard = &ni6527_boards[context];\n\tif (!board)\n\t\treturn -ENODEV;\n\tdev->board_ptr = board;\n\tdev->board_name = board->name;\n\n\tdevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\n\tif (!devpriv)\n\t\treturn -ENOMEM;\n\n\tret = comedi_pci_enable(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tdev->mmio = pci_ioremap_bar(pcidev, 1);\n\tif (!dev->mmio)\n\t\treturn -ENOMEM;\n\n\t \n\tif (readb(dev->mmio + NI6527_ID_REG) != 0x27)\n\t\treturn -ENODEV;\n\n\tni6527_reset(dev);\n\n\tret = request_irq(pcidev->irq, ni6527_interrupt, IRQF_SHARED,\n\t\t\t  dev->board_name, dev);\n\tif (ret == 0)\n\t\tdev->irq = pcidev->irq;\n\n\tret = comedi_alloc_subdevices(dev, 3);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ts = &dev->subdevices[0];\n\ts->type\t\t= COMEDI_SUBD_DI;\n\ts->subdev_flags\t= SDF_READABLE;\n\ts->n_chan\t= 24;\n\ts->maxdata\t= 1;\n\ts->range_table\t= &range_digital;\n\ts->insn_config\t= ni6527_di_insn_config;\n\ts->insn_bits\t= ni6527_di_insn_bits;\n\n\t \n\ts = &dev->subdevices[1];\n\ts->type\t\t= COMEDI_SUBD_DO;\n\ts->subdev_flags\t= SDF_WRITABLE;\n\ts->n_chan\t= 24;\n\ts->maxdata\t= 1;\n\ts->range_table\t= &range_digital;\n\ts->insn_bits\t= ni6527_do_insn_bits;\n\n\t \n\ts = &dev->subdevices[2];\n\tif (dev->irq) {\n\t\tdev->read_subdev = s;\n\t\ts->type\t\t= COMEDI_SUBD_DI;\n\t\ts->subdev_flags\t= SDF_READABLE | SDF_CMD_READ;\n\t\ts->n_chan\t= 1;\n\t\ts->maxdata\t= 1;\n\t\ts->range_table\t= &range_digital;\n\t\ts->insn_config\t= ni6527_intr_insn_config;\n\t\ts->insn_bits\t= ni6527_intr_insn_bits;\n\t\ts->len_chanlist\t= 1;\n\t\ts->do_cmdtest\t= ni6527_intr_cmdtest;\n\t\ts->do_cmd\t= ni6527_intr_cmd;\n\t\ts->cancel\t= ni6527_intr_cancel;\n\t} else {\n\t\ts->type = COMEDI_SUBD_UNUSED;\n\t}\n\n\treturn 0;\n}\n\nstatic void ni6527_detach(struct comedi_device *dev)\n{\n\tif (dev->mmio)\n\t\tni6527_reset(dev);\n\tcomedi_pci_detach(dev);\n}\n\nstatic struct comedi_driver ni6527_driver = {\n\t.driver_name\t= \"ni_6527\",\n\t.module\t\t= THIS_MODULE,\n\t.auto_attach\t= ni6527_auto_attach,\n\t.detach\t\t= ni6527_detach,\n};\n\nstatic int ni6527_pci_probe(struct pci_dev *dev,\n\t\t\t    const struct pci_device_id *id)\n{\n\treturn comedi_pci_auto_config(dev, &ni6527_driver, id->driver_data);\n}\n\nstatic const struct pci_device_id ni6527_pci_table[] = {\n\t{ PCI_VDEVICE(NI, 0x2b10), BOARD_PXI6527 },\n\t{ PCI_VDEVICE(NI, 0x2b20), BOARD_PCI6527 },\n\t{ 0 }\n};\nMODULE_DEVICE_TABLE(pci, ni6527_pci_table);\n\nstatic struct pci_driver ni6527_pci_driver = {\n\t.name\t\t= \"ni_6527\",\n\t.id_table\t= ni6527_pci_table,\n\t.probe\t\t= ni6527_pci_probe,\n\t.remove\t\t= comedi_pci_auto_unconfig,\n};\nmodule_comedi_pci_driver(ni6527_driver, ni6527_pci_driver);\n\nMODULE_AUTHOR(\"Comedi https://www.comedi.org\");\nMODULE_DESCRIPTION(\"Comedi driver for National Instruments PCI-6527\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}