{
  "module_name": "me4000.c",
  "hash_id": "81cb6cfe2ced637543ce63ae1e1c94ef8fc78f37e17934741cd884fb880855d1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/drivers/me4000.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/comedi/comedi_pci.h>\n#include <linux/comedi/comedi_8254.h>\n\n#include \"plx9052.h\"\n\n#define ME4000_FIRMWARE\t\t\"me4000_firmware.bin\"\n\n \n#define ME4000_AO_CHAN(x)\t\t\t((x) * 0x18)\n\n#define ME4000_AO_CTRL_REG(x)\t\t\t(0x00 + ME4000_AO_CHAN(x))\n#define ME4000_AO_CTRL_MODE_0\t\t\tBIT(0)\n#define ME4000_AO_CTRL_MODE_1\t\t\tBIT(1)\n#define ME4000_AO_CTRL_STOP\t\t\tBIT(2)\n#define ME4000_AO_CTRL_ENABLE_FIFO\t\tBIT(3)\n#define ME4000_AO_CTRL_ENABLE_EX_TRIG\t\tBIT(4)\n#define ME4000_AO_CTRL_EX_TRIG_EDGE\t\tBIT(5)\n#define ME4000_AO_CTRL_IMMEDIATE_STOP\t\tBIT(7)\n#define ME4000_AO_CTRL_ENABLE_DO\t\tBIT(8)\n#define ME4000_AO_CTRL_ENABLE_IRQ\t\tBIT(9)\n#define ME4000_AO_CTRL_RESET_IRQ\t\tBIT(10)\n#define ME4000_AO_STATUS_REG(x)\t\t\t(0x04 + ME4000_AO_CHAN(x))\n#define ME4000_AO_STATUS_FSM\t\t\tBIT(0)\n#define ME4000_AO_STATUS_FF\t\t\tBIT(1)\n#define ME4000_AO_STATUS_HF\t\t\tBIT(2)\n#define ME4000_AO_STATUS_EF\t\t\tBIT(3)\n#define ME4000_AO_FIFO_REG(x)\t\t\t(0x08 + ME4000_AO_CHAN(x))\n#define ME4000_AO_SINGLE_REG(x)\t\t\t(0x0c + ME4000_AO_CHAN(x))\n#define ME4000_AO_TIMER_REG(x)\t\t\t(0x10 + ME4000_AO_CHAN(x))\n#define ME4000_AI_CTRL_REG\t\t\t0x74\n#define ME4000_AI_STATUS_REG\t\t\t0x74\n#define ME4000_AI_CTRL_MODE_0\t\t\tBIT(0)\n#define ME4000_AI_CTRL_MODE_1\t\t\tBIT(1)\n#define ME4000_AI_CTRL_MODE_2\t\t\tBIT(2)\n#define ME4000_AI_CTRL_SAMPLE_HOLD\t\tBIT(3)\n#define ME4000_AI_CTRL_IMMEDIATE_STOP\t\tBIT(4)\n#define ME4000_AI_CTRL_STOP\t\t\tBIT(5)\n#define ME4000_AI_CTRL_CHANNEL_FIFO\t\tBIT(6)\n#define ME4000_AI_CTRL_DATA_FIFO\t\tBIT(7)\n#define ME4000_AI_CTRL_FULLSCALE\t\tBIT(8)\n#define ME4000_AI_CTRL_OFFSET\t\t\tBIT(9)\n#define ME4000_AI_CTRL_EX_TRIG_ANALOG\t\tBIT(10)\n#define ME4000_AI_CTRL_EX_TRIG\t\t\tBIT(11)\n#define ME4000_AI_CTRL_EX_TRIG_FALLING\t\tBIT(12)\n#define ME4000_AI_CTRL_EX_IRQ\t\t\tBIT(13)\n#define ME4000_AI_CTRL_EX_IRQ_RESET\t\tBIT(14)\n#define ME4000_AI_CTRL_LE_IRQ\t\t\tBIT(15)\n#define ME4000_AI_CTRL_LE_IRQ_RESET\t\tBIT(16)\n#define ME4000_AI_CTRL_HF_IRQ\t\t\tBIT(17)\n#define ME4000_AI_CTRL_HF_IRQ_RESET\t\tBIT(18)\n#define ME4000_AI_CTRL_SC_IRQ\t\t\tBIT(19)\n#define ME4000_AI_CTRL_SC_IRQ_RESET\t\tBIT(20)\n#define ME4000_AI_CTRL_SC_RELOAD\t\tBIT(21)\n#define ME4000_AI_STATUS_EF_CHANNEL\t\tBIT(22)\n#define ME4000_AI_STATUS_HF_CHANNEL\t\tBIT(23)\n#define ME4000_AI_STATUS_FF_CHANNEL\t\tBIT(24)\n#define ME4000_AI_STATUS_EF_DATA\t\tBIT(25)\n#define ME4000_AI_STATUS_HF_DATA\t\tBIT(26)\n#define ME4000_AI_STATUS_FF_DATA\t\tBIT(27)\n#define ME4000_AI_STATUS_LE\t\t\tBIT(28)\n#define ME4000_AI_STATUS_FSM\t\t\tBIT(29)\n#define ME4000_AI_CTRL_EX_TRIG_BOTH\t\tBIT(31)\n#define ME4000_AI_CHANNEL_LIST_REG\t\t0x78\n#define ME4000_AI_LIST_INPUT_DIFFERENTIAL\tBIT(5)\n#define ME4000_AI_LIST_RANGE(x)\t\t\t((3 - ((x) & 3)) << 6)\n#define ME4000_AI_LIST_LAST_ENTRY\t\tBIT(8)\n#define ME4000_AI_DATA_REG\t\t\t0x7c\n#define ME4000_AI_CHAN_TIMER_REG\t\t0x80\n#define ME4000_AI_CHAN_PRE_TIMER_REG\t\t0x84\n#define ME4000_AI_SCAN_TIMER_LOW_REG\t\t0x88\n#define ME4000_AI_SCAN_TIMER_HIGH_REG\t\t0x8c\n#define ME4000_AI_SCAN_PRE_TIMER_LOW_REG\t0x90\n#define ME4000_AI_SCAN_PRE_TIMER_HIGH_REG\t0x94\n#define ME4000_AI_START_REG\t\t\t0x98\n#define ME4000_IRQ_STATUS_REG\t\t\t0x9c\n#define ME4000_IRQ_STATUS_EX\t\t\tBIT(0)\n#define ME4000_IRQ_STATUS_LE\t\t\tBIT(1)\n#define ME4000_IRQ_STATUS_AI_HF\t\t\tBIT(2)\n#define ME4000_IRQ_STATUS_AO_0_HF\t\tBIT(3)\n#define ME4000_IRQ_STATUS_AO_1_HF\t\tBIT(4)\n#define ME4000_IRQ_STATUS_AO_2_HF\t\tBIT(5)\n#define ME4000_IRQ_STATUS_AO_3_HF\t\tBIT(6)\n#define ME4000_IRQ_STATUS_SC\t\t\tBIT(7)\n#define ME4000_DIO_PORT_0_REG\t\t\t0xa0\n#define ME4000_DIO_PORT_1_REG\t\t\t0xa4\n#define ME4000_DIO_PORT_2_REG\t\t\t0xa8\n#define ME4000_DIO_PORT_3_REG\t\t\t0xac\n#define ME4000_DIO_DIR_REG\t\t\t0xb0\n#define ME4000_AO_LOADSETREG_XX\t\t\t0xb4\n#define ME4000_DIO_CTRL_REG\t\t\t0xb8\n#define ME4000_DIO_CTRL_MODE_0\t\t\tBIT(0)\n#define ME4000_DIO_CTRL_MODE_1\t\t\tBIT(1)\n#define ME4000_DIO_CTRL_MODE_2\t\t\tBIT(2)\n#define ME4000_DIO_CTRL_MODE_3\t\t\tBIT(3)\n#define ME4000_DIO_CTRL_MODE_4\t\t\tBIT(4)\n#define ME4000_DIO_CTRL_MODE_5\t\t\tBIT(5)\n#define ME4000_DIO_CTRL_MODE_6\t\t\tBIT(6)\n#define ME4000_DIO_CTRL_MODE_7\t\t\tBIT(7)\n#define ME4000_DIO_CTRL_FUNCTION_0\t\tBIT(8)\n#define ME4000_DIO_CTRL_FUNCTION_1\t\tBIT(9)\n#define ME4000_DIO_CTRL_FIFO_HIGH_0\t\tBIT(10)\n#define ME4000_DIO_CTRL_FIFO_HIGH_1\t\tBIT(11)\n#define ME4000_DIO_CTRL_FIFO_HIGH_2\t\tBIT(12)\n#define ME4000_DIO_CTRL_FIFO_HIGH_3\t\tBIT(13)\n#define ME4000_AO_DEMUX_ADJUST_REG\t\t0xbc\n#define ME4000_AO_DEMUX_ADJUST_VALUE\t\t0x4c\n#define ME4000_AI_SAMPLE_COUNTER_REG\t\t0xc0\n\n#define ME4000_AI_FIFO_COUNT\t\t\t2048\n\n#define ME4000_AI_MIN_TICKS\t\t\t66\n#define ME4000_AI_MIN_SAMPLE_TIME\t\t2000\n\n#define ME4000_AI_CHANNEL_LIST_COUNT\t\t1024\n\nstruct me4000_private {\n\tunsigned long plx_regbase;\n\tunsigned int ai_ctrl_mode;\n\tunsigned int ai_init_ticks;\n\tunsigned int ai_scan_ticks;\n\tunsigned int ai_chan_ticks;\n};\n\nenum me4000_boardid {\n\tBOARD_ME4650,\n\tBOARD_ME4660,\n\tBOARD_ME4660I,\n\tBOARD_ME4660S,\n\tBOARD_ME4660IS,\n\tBOARD_ME4670,\n\tBOARD_ME4670I,\n\tBOARD_ME4670S,\n\tBOARD_ME4670IS,\n\tBOARD_ME4680,\n\tBOARD_ME4680I,\n\tBOARD_ME4680S,\n\tBOARD_ME4680IS,\n};\n\nstruct me4000_board {\n\tconst char *name;\n\tint ai_nchan;\n\tunsigned int can_do_diff_ai:1;\n\tunsigned int can_do_sh_ai:1;\t \n\tunsigned int ex_trig_analog:1;\n\tunsigned int has_ao:1;\n\tunsigned int has_ao_fifo:1;\n\tunsigned int has_counter:1;\n};\n\nstatic const struct me4000_board me4000_boards[] = {\n\t[BOARD_ME4650] = {\n\t\t.name\t\t= \"ME-4650\",\n\t\t.ai_nchan\t= 16,\n\t},\n\t[BOARD_ME4660] = {\n\t\t.name\t\t= \"ME-4660\",\n\t\t.ai_nchan\t= 32,\n\t\t.can_do_diff_ai\t= 1,\n\t\t.has_counter\t= 1,\n\t},\n\t[BOARD_ME4660I] = {\n\t\t.name\t\t= \"ME-4660i\",\n\t\t.ai_nchan\t= 32,\n\t\t.can_do_diff_ai\t= 1,\n\t\t.has_counter\t= 1,\n\t},\n\t[BOARD_ME4660S] = {\n\t\t.name\t\t= \"ME-4660s\",\n\t\t.ai_nchan\t= 32,\n\t\t.can_do_diff_ai\t= 1,\n\t\t.can_do_sh_ai\t= 1,\n\t\t.has_counter\t= 1,\n\t},\n\t[BOARD_ME4660IS] = {\n\t\t.name\t\t= \"ME-4660is\",\n\t\t.ai_nchan\t= 32,\n\t\t.can_do_diff_ai\t= 1,\n\t\t.can_do_sh_ai\t= 1,\n\t\t.has_counter\t= 1,\n\t},\n\t[BOARD_ME4670] = {\n\t\t.name\t\t= \"ME-4670\",\n\t\t.ai_nchan\t= 32,\n\t\t.can_do_diff_ai\t= 1,\n\t\t.ex_trig_analog\t= 1,\n\t\t.has_ao\t\t= 1,\n\t\t.has_counter\t= 1,\n\t},\n\t[BOARD_ME4670I] = {\n\t\t.name\t\t= \"ME-4670i\",\n\t\t.ai_nchan\t= 32,\n\t\t.can_do_diff_ai\t= 1,\n\t\t.ex_trig_analog\t= 1,\n\t\t.has_ao\t\t= 1,\n\t\t.has_counter\t= 1,\n\t},\n\t[BOARD_ME4670S] = {\n\t\t.name\t\t= \"ME-4670s\",\n\t\t.ai_nchan\t= 32,\n\t\t.can_do_diff_ai\t= 1,\n\t\t.can_do_sh_ai\t= 1,\n\t\t.ex_trig_analog\t= 1,\n\t\t.has_ao\t\t= 1,\n\t\t.has_counter\t= 1,\n\t},\n\t[BOARD_ME4670IS] = {\n\t\t.name\t\t= \"ME-4670is\",\n\t\t.ai_nchan\t= 32,\n\t\t.can_do_diff_ai\t= 1,\n\t\t.can_do_sh_ai\t= 1,\n\t\t.ex_trig_analog\t= 1,\n\t\t.has_ao\t\t= 1,\n\t\t.has_counter\t= 1,\n\t},\n\t[BOARD_ME4680] = {\n\t\t.name\t\t= \"ME-4680\",\n\t\t.ai_nchan\t= 32,\n\t\t.can_do_diff_ai\t= 1,\n\t\t.ex_trig_analog\t= 1,\n\t\t.has_ao\t\t= 1,\n\t\t.has_ao_fifo\t= 1,\n\t\t.has_counter\t= 1,\n\t},\n\t[BOARD_ME4680I] = {\n\t\t.name\t\t= \"ME-4680i\",\n\t\t.ai_nchan\t= 32,\n\t\t.can_do_diff_ai\t= 1,\n\t\t.ex_trig_analog\t= 1,\n\t\t.has_ao\t\t= 1,\n\t\t.has_ao_fifo\t= 1,\n\t\t.has_counter\t= 1,\n\t},\n\t[BOARD_ME4680S] = {\n\t\t.name\t\t= \"ME-4680s\",\n\t\t.ai_nchan\t= 32,\n\t\t.can_do_diff_ai\t= 1,\n\t\t.can_do_sh_ai\t= 1,\n\t\t.ex_trig_analog\t= 1,\n\t\t.has_ao\t\t= 1,\n\t\t.has_ao_fifo\t= 1,\n\t\t.has_counter\t= 1,\n\t},\n\t[BOARD_ME4680IS] = {\n\t\t.name\t\t= \"ME-4680is\",\n\t\t.ai_nchan\t= 32,\n\t\t.can_do_diff_ai\t= 1,\n\t\t.can_do_sh_ai\t= 1,\n\t\t.ex_trig_analog\t= 1,\n\t\t.has_ao\t\t= 1,\n\t\t.has_ao_fifo\t= 1,\n\t\t.has_counter\t= 1,\n\t},\n};\n\n \nstatic const struct comedi_lrange me4000_ai_range = {\n\t4, {\n\t\tUNI_RANGE(2.5),\n\t\tUNI_RANGE(10),\n\t\tBIP_RANGE(2.5),\n\t\tBIP_RANGE(10)\n\t}\n};\n\nstatic int me4000_xilinx_download(struct comedi_device *dev,\n\t\t\t\t  const u8 *data, size_t size,\n\t\t\t\t  unsigned long context)\n{\n\tstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\n\tstruct me4000_private *devpriv = dev->private;\n\tunsigned long xilinx_iobase = pci_resource_start(pcidev, 5);\n\tunsigned int file_length;\n\tunsigned int val;\n\tunsigned int i;\n\n\tif (!xilinx_iobase)\n\t\treturn -ENODEV;\n\n\t \n\toutl(PLX9052_INTCSR_LI2POL, devpriv->plx_regbase + PLX9052_INTCSR);\n\n\t \n\tval = inl(devpriv->plx_regbase + PLX9052_CNTRL);\n\tval |= PLX9052_CNTRL_UIO2_DATA;\n\toutl(val, devpriv->plx_regbase + PLX9052_CNTRL);\n\n\t \n\tinb(xilinx_iobase + 0xC8);\n\n\t \n\tusleep_range(20, 1000);\n\tval = inl(devpriv->plx_regbase + PLX9052_INTCSR);\n\tif (!(val & PLX9052_INTCSR_LI2STAT)) {\n\t\tdev_err(dev->class_dev, \"Can't init Xilinx\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tval = inl(devpriv->plx_regbase + PLX9052_CNTRL);\n\tval &= ~PLX9052_CNTRL_UIO2_DATA;\n\toutl(val, devpriv->plx_regbase + PLX9052_CNTRL);\n\n\t \n\tfile_length = (((unsigned int)data[0] & 0xff) << 24) +\n\t\t      (((unsigned int)data[1] & 0xff) << 16) +\n\t\t      (((unsigned int)data[2] & 0xff) << 8) +\n\t\t      ((unsigned int)data[3] & 0xff);\n\tusleep_range(10, 1000);\n\n\tfor (i = 0; i < file_length; i++) {\n\t\toutb(data[16 + i], xilinx_iobase);\n\t\tusleep_range(10, 1000);\n\n\t\t \n\t\tval = inl(devpriv->plx_regbase + PLX9052_CNTRL);\n\t\tif (val & PLX9052_CNTRL_UIO1_DATA) {\n\t\t\tdev_err(dev->class_dev,\n\t\t\t\t\"Xilinx is still busy (i = %d)\\n\", i);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\t \n\tval = inl(devpriv->plx_regbase + PLX9052_CNTRL);\n\tif (!(val & PLX9052_CNTRL_UIO0_DATA)) {\n\t\tdev_err(dev->class_dev, \"DONE flag is not set\\n\");\n\t\tdev_err(dev->class_dev, \"Download not successful\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tval = inl(devpriv->plx_regbase + PLX9052_CNTRL);\n\tval |= PLX9052_CNTRL_UIO2_DATA;\n\toutl(val, devpriv->plx_regbase + PLX9052_CNTRL);\n\n\treturn 0;\n}\n\nstatic void me4000_ai_reset(struct comedi_device *dev)\n{\n\tunsigned int ctrl;\n\n\t \n\tctrl = inl(dev->iobase + ME4000_AI_CTRL_REG);\n\tctrl |= ME4000_AI_CTRL_STOP | ME4000_AI_CTRL_IMMEDIATE_STOP;\n\toutl(ctrl, dev->iobase + ME4000_AI_CTRL_REG);\n\n\t \n\toutl(0x0, dev->iobase + ME4000_AI_CTRL_REG);\n}\n\nstatic void me4000_reset(struct comedi_device *dev)\n{\n\tstruct me4000_private *devpriv = dev->private;\n\tunsigned int val;\n\tint chan;\n\n\t \n\toutl(0, devpriv->plx_regbase + PLX9052_INTCSR);\n\n\t \n\tval = inl(devpriv->plx_regbase + PLX9052_CNTRL);\n\tval |= PLX9052_CNTRL_PCI_RESET;\n\toutl(val, devpriv->plx_regbase + PLX9052_CNTRL);\n\tval &= ~PLX9052_CNTRL_PCI_RESET;\n\toutl(val, devpriv->plx_regbase + PLX9052_CNTRL);\n\n\t \n\tfor (chan = 0; chan < 4; chan++)\n\t\toutl(0x8000, dev->iobase + ME4000_AO_SINGLE_REG(chan));\n\n\tme4000_ai_reset(dev);\n\n\t \n\tval = ME4000_AO_CTRL_IMMEDIATE_STOP | ME4000_AO_CTRL_STOP;\n\tfor (chan = 0; chan < 4; chan++)\n\t\toutl(val, dev->iobase + ME4000_AO_CTRL_REG(chan));\n\n\t \n\toutl(ME4000_AO_DEMUX_ADJUST_VALUE,\n\t     dev->iobase + ME4000_AO_DEMUX_ADJUST_REG);\n\n\t \n\tif (!(inl(dev->iobase + ME4000_DIO_DIR_REG) & 0x1))\n\t\toutl(0x1, dev->iobase + ME4000_DIO_CTRL_REG);\n}\n\nstatic unsigned int me4000_ai_get_sample(struct comedi_device *dev,\n\t\t\t\t\t struct comedi_subdevice *s)\n{\n\tunsigned int val;\n\n\t \n\tval = inl(dev->iobase + ME4000_AI_DATA_REG);\n\treturn comedi_offset_munge(s, val);\n}\n\nstatic int me4000_ai_eoc(struct comedi_device *dev,\n\t\t\t struct comedi_subdevice *s,\n\t\t\t struct comedi_insn *insn,\n\t\t\t unsigned long context)\n{\n\tunsigned int status;\n\n\tstatus = inl(dev->iobase + ME4000_AI_STATUS_REG);\n\tif (status & ME4000_AI_STATUS_EF_DATA)\n\t\treturn 0;\n\treturn -EBUSY;\n}\n\nstatic int me4000_ai_insn_read(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       struct comedi_insn *insn,\n\t\t\t       unsigned int *data)\n{\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int range = CR_RANGE(insn->chanspec);\n\tunsigned int aref = CR_AREF(insn->chanspec);\n\tunsigned int entry;\n\tint ret = 0;\n\tint i;\n\n\tentry = chan | ME4000_AI_LIST_RANGE(range);\n\tif (aref == AREF_DIFF) {\n\t\tif (!(s->subdev_flags & SDF_DIFF)) {\n\t\t\tdev_err(dev->class_dev,\n\t\t\t\t\"Differential inputs are not available\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!comedi_range_is_bipolar(s, range)) {\n\t\t\tdev_err(dev->class_dev,\n\t\t\t\t\"Range must be bipolar when aref = diff\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (chan >= (s->n_chan / 2)) {\n\t\t\tdev_err(dev->class_dev,\n\t\t\t\t\"Analog input is not available\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tentry |= ME4000_AI_LIST_INPUT_DIFFERENTIAL;\n\t}\n\n\tentry |= ME4000_AI_LIST_LAST_ENTRY;\n\n\t \n\toutl(ME4000_AI_CTRL_CHANNEL_FIFO | ME4000_AI_CTRL_DATA_FIFO,\n\t     dev->iobase + ME4000_AI_CTRL_REG);\n\n\t \n\toutl(entry, dev->iobase + ME4000_AI_CHANNEL_LIST_REG);\n\n\t \n\toutl(ME4000_AI_MIN_TICKS, dev->iobase + ME4000_AI_CHAN_TIMER_REG);\n\toutl(ME4000_AI_MIN_TICKS, dev->iobase + ME4000_AI_CHAN_PRE_TIMER_REG);\n\n\tfor (i = 0; i < insn->n; i++) {\n\t\tunsigned int val;\n\n\t\t \n\t\tinl(dev->iobase + ME4000_AI_START_REG);\n\n\t\tret = comedi_timeout(dev, s, insn, me4000_ai_eoc, 0);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tval = me4000_ai_get_sample(dev, s);\n\t\tdata[i] = comedi_offset_munge(s, val);\n\t}\n\n\tme4000_ai_reset(dev);\n\n\treturn ret ? ret : insn->n;\n}\n\nstatic int me4000_ai_cancel(struct comedi_device *dev,\n\t\t\t    struct comedi_subdevice *s)\n{\n\tme4000_ai_reset(dev);\n\n\treturn 0;\n}\n\nstatic int me4000_ai_check_chanlist(struct comedi_device *dev,\n\t\t\t\t    struct comedi_subdevice *s,\n\t\t\t\t    struct comedi_cmd *cmd)\n{\n\tunsigned int aref0 = CR_AREF(cmd->chanlist[0]);\n\tint i;\n\n\tfor (i = 0; i < cmd->chanlist_len; i++) {\n\t\tunsigned int chan = CR_CHAN(cmd->chanlist[i]);\n\t\tunsigned int range = CR_RANGE(cmd->chanlist[i]);\n\t\tunsigned int aref = CR_AREF(cmd->chanlist[i]);\n\n\t\tif (aref != aref0) {\n\t\t\tdev_dbg(dev->class_dev,\n\t\t\t\t\"Mode is not equal for all entries\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (aref == AREF_DIFF) {\n\t\t\tif (!(s->subdev_flags & SDF_DIFF)) {\n\t\t\t\tdev_err(dev->class_dev,\n\t\t\t\t\t\"Differential inputs are not available\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (chan >= (s->n_chan / 2)) {\n\t\t\t\tdev_dbg(dev->class_dev,\n\t\t\t\t\t\"Channel number to high\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (!comedi_range_is_bipolar(s, range)) {\n\t\t\t\tdev_dbg(dev->class_dev,\n\t\t\t\t\t\"Bipolar is not selected in differential mode\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void me4000_ai_round_cmd_args(struct comedi_device *dev,\n\t\t\t\t     struct comedi_subdevice *s,\n\t\t\t\t     struct comedi_cmd *cmd)\n{\n\tstruct me4000_private *devpriv = dev->private;\n\tint rest;\n\n\tdevpriv->ai_init_ticks = 0;\n\tdevpriv->ai_scan_ticks = 0;\n\tdevpriv->ai_chan_ticks = 0;\n\n\tif (cmd->start_arg) {\n\t\tdevpriv->ai_init_ticks = (cmd->start_arg * 33) / 1000;\n\t\trest = (cmd->start_arg * 33) % 1000;\n\n\t\tif ((cmd->flags & CMDF_ROUND_MASK) == CMDF_ROUND_NEAREST) {\n\t\t\tif (rest > 33)\n\t\t\t\tdevpriv->ai_init_ticks++;\n\t\t} else if ((cmd->flags & CMDF_ROUND_MASK) == CMDF_ROUND_UP) {\n\t\t\tif (rest)\n\t\t\t\tdevpriv->ai_init_ticks++;\n\t\t}\n\t}\n\n\tif (cmd->scan_begin_arg) {\n\t\tdevpriv->ai_scan_ticks = (cmd->scan_begin_arg * 33) / 1000;\n\t\trest = (cmd->scan_begin_arg * 33) % 1000;\n\n\t\tif ((cmd->flags & CMDF_ROUND_MASK) == CMDF_ROUND_NEAREST) {\n\t\t\tif (rest > 33)\n\t\t\t\tdevpriv->ai_scan_ticks++;\n\t\t} else if ((cmd->flags & CMDF_ROUND_MASK) == CMDF_ROUND_UP) {\n\t\t\tif (rest)\n\t\t\t\tdevpriv->ai_scan_ticks++;\n\t\t}\n\t}\n\n\tif (cmd->convert_arg) {\n\t\tdevpriv->ai_chan_ticks = (cmd->convert_arg * 33) / 1000;\n\t\trest = (cmd->convert_arg * 33) % 1000;\n\n\t\tif ((cmd->flags & CMDF_ROUND_MASK) == CMDF_ROUND_NEAREST) {\n\t\t\tif (rest > 33)\n\t\t\t\tdevpriv->ai_chan_ticks++;\n\t\t} else if ((cmd->flags & CMDF_ROUND_MASK) == CMDF_ROUND_UP) {\n\t\t\tif (rest)\n\t\t\t\tdevpriv->ai_chan_ticks++;\n\t\t}\n\t}\n}\n\nstatic void me4000_ai_write_chanlist(struct comedi_device *dev,\n\t\t\t\t     struct comedi_subdevice *s,\n\t\t\t\t     struct comedi_cmd *cmd)\n{\n\tint i;\n\n\tfor (i = 0; i < cmd->chanlist_len; i++) {\n\t\tunsigned int chan = CR_CHAN(cmd->chanlist[i]);\n\t\tunsigned int range = CR_RANGE(cmd->chanlist[i]);\n\t\tunsigned int aref = CR_AREF(cmd->chanlist[i]);\n\t\tunsigned int entry;\n\n\t\tentry = chan | ME4000_AI_LIST_RANGE(range);\n\n\t\tif (aref == AREF_DIFF)\n\t\t\tentry |= ME4000_AI_LIST_INPUT_DIFFERENTIAL;\n\n\t\tif (i == (cmd->chanlist_len - 1))\n\t\t\tentry |= ME4000_AI_LIST_LAST_ENTRY;\n\n\t\toutl(entry, dev->iobase + ME4000_AI_CHANNEL_LIST_REG);\n\t}\n}\n\nstatic int me4000_ai_do_cmd(struct comedi_device *dev,\n\t\t\t    struct comedi_subdevice *s)\n{\n\tstruct me4000_private *devpriv = dev->private;\n\tstruct comedi_cmd *cmd = &s->async->cmd;\n\tunsigned int ctrl;\n\n\t \n\toutl(devpriv->ai_init_ticks - 1,\n\t     dev->iobase + ME4000_AI_SCAN_PRE_TIMER_LOW_REG);\n\toutl(0x0, dev->iobase + ME4000_AI_SCAN_PRE_TIMER_HIGH_REG);\n\n\tif (devpriv->ai_scan_ticks) {\n\t\toutl(devpriv->ai_scan_ticks - 1,\n\t\t     dev->iobase + ME4000_AI_SCAN_TIMER_LOW_REG);\n\t\toutl(0x0, dev->iobase + ME4000_AI_SCAN_TIMER_HIGH_REG);\n\t}\n\n\toutl(devpriv->ai_chan_ticks - 1,\n\t     dev->iobase + ME4000_AI_CHAN_PRE_TIMER_REG);\n\toutl(devpriv->ai_chan_ticks - 1,\n\t     dev->iobase + ME4000_AI_CHAN_TIMER_REG);\n\n\t \n\tctrl = devpriv->ai_ctrl_mode |\n\t       ME4000_AI_CTRL_CHANNEL_FIFO |\n\t       ME4000_AI_CTRL_DATA_FIFO;\n\n\t \n\tif (cmd->stop_src == TRIG_COUNT) {\n\t\toutl(cmd->chanlist_len * cmd->stop_arg,\n\t\t     dev->iobase + ME4000_AI_SAMPLE_COUNTER_REG);\n\t\tctrl |= ME4000_AI_CTRL_SC_IRQ;\n\t} else if (cmd->stop_src == TRIG_NONE &&\n\t\t   cmd->scan_end_src == TRIG_COUNT) {\n\t\toutl(cmd->scan_end_arg,\n\t\t     dev->iobase + ME4000_AI_SAMPLE_COUNTER_REG);\n\t\tctrl |= ME4000_AI_CTRL_SC_IRQ;\n\t}\n\tctrl |= ME4000_AI_CTRL_HF_IRQ;\n\n\t \n\toutl(ctrl, dev->iobase + ME4000_AI_CTRL_REG);\n\n\t \n\tme4000_ai_write_chanlist(dev, s, cmd);\n\n\t \n\tinl(dev->iobase + ME4000_AI_START_REG);\n\n\treturn 0;\n}\n\nstatic int me4000_ai_do_cmd_test(struct comedi_device *dev,\n\t\t\t\t struct comedi_subdevice *s,\n\t\t\t\t struct comedi_cmd *cmd)\n{\n\tstruct me4000_private *devpriv = dev->private;\n\tint err = 0;\n\n\t \n\n\terr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_EXT);\n\terr |= comedi_check_trigger_src(&cmd->scan_begin_src,\n\t\t\t\t\tTRIG_FOLLOW | TRIG_TIMER | TRIG_EXT);\n\terr |= comedi_check_trigger_src(&cmd->convert_src,\n\t\t\t\t\tTRIG_TIMER | TRIG_EXT);\n\terr |= comedi_check_trigger_src(&cmd->scan_end_src,\n\t\t\t\t\tTRIG_NONE | TRIG_COUNT);\n\terr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_NONE | TRIG_COUNT);\n\n\tif (err)\n\t\treturn 1;\n\n\t \n\n\terr |= comedi_check_trigger_is_unique(cmd->start_src);\n\terr |= comedi_check_trigger_is_unique(cmd->scan_begin_src);\n\terr |= comedi_check_trigger_is_unique(cmd->convert_src);\n\terr |= comedi_check_trigger_is_unique(cmd->scan_end_src);\n\terr |= comedi_check_trigger_is_unique(cmd->stop_src);\n\n\t \n\n\tif (cmd->start_src == TRIG_NOW &&\n\t    cmd->scan_begin_src == TRIG_TIMER &&\n\t    cmd->convert_src == TRIG_TIMER) {\n\t\tdevpriv->ai_ctrl_mode = ME4000_AI_CTRL_MODE_0;\n\t} else if (cmd->start_src == TRIG_NOW &&\n\t\t   cmd->scan_begin_src == TRIG_FOLLOW &&\n\t\t   cmd->convert_src == TRIG_TIMER) {\n\t\tdevpriv->ai_ctrl_mode = ME4000_AI_CTRL_MODE_0;\n\t} else if (cmd->start_src == TRIG_EXT &&\n\t\t   cmd->scan_begin_src == TRIG_TIMER &&\n\t\t   cmd->convert_src == TRIG_TIMER) {\n\t\tdevpriv->ai_ctrl_mode = ME4000_AI_CTRL_MODE_1;\n\t} else if (cmd->start_src == TRIG_EXT &&\n\t\t   cmd->scan_begin_src == TRIG_FOLLOW &&\n\t\t   cmd->convert_src == TRIG_TIMER) {\n\t\tdevpriv->ai_ctrl_mode = ME4000_AI_CTRL_MODE_1;\n\t} else if (cmd->start_src == TRIG_EXT &&\n\t\t   cmd->scan_begin_src == TRIG_EXT &&\n\t\t   cmd->convert_src == TRIG_TIMER) {\n\t\tdevpriv->ai_ctrl_mode = ME4000_AI_CTRL_MODE_2;\n\t} else if (cmd->start_src == TRIG_EXT &&\n\t\t   cmd->scan_begin_src == TRIG_EXT &&\n\t\t   cmd->convert_src == TRIG_EXT) {\n\t\tdevpriv->ai_ctrl_mode = ME4000_AI_CTRL_MODE_0 |\n\t\t\t\t\tME4000_AI_CTRL_MODE_1;\n\t} else {\n\t\terr |= -EINVAL;\n\t}\n\n\tif (err)\n\t\treturn 2;\n\n\t \n\n\terr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\n\n\tif (cmd->chanlist_len < 1) {\n\t\tcmd->chanlist_len = 1;\n\t\terr |= -EINVAL;\n\t}\n\n\t \n\tme4000_ai_round_cmd_args(dev, s, cmd);\n\n\tif (devpriv->ai_init_ticks < 66) {\n\t\tcmd->start_arg = 2000;\n\t\terr |= -EINVAL;\n\t}\n\tif (devpriv->ai_scan_ticks && devpriv->ai_scan_ticks < 67) {\n\t\tcmd->scan_begin_arg = 2031;\n\t\terr |= -EINVAL;\n\t}\n\tif (devpriv->ai_chan_ticks < 66) {\n\t\tcmd->convert_arg = 2000;\n\t\terr |= -EINVAL;\n\t}\n\n\tif (cmd->stop_src == TRIG_COUNT)\n\t\terr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\n\telse\t \n\t\terr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\n\n\tif (err)\n\t\treturn 3;\n\n\t \n\tif (cmd->start_src == TRIG_NOW &&\n\t    cmd->scan_begin_src == TRIG_TIMER &&\n\t    cmd->convert_src == TRIG_TIMER) {\n\t\t \n\t\tif (devpriv->ai_init_ticks < ME4000_AI_MIN_TICKS) {\n\t\t\tdev_err(dev->class_dev, \"Invalid start arg\\n\");\n\t\t\tcmd->start_arg = 2000;\t \n\t\t\terr++;\n\t\t}\n\t\tif (devpriv->ai_chan_ticks < ME4000_AI_MIN_TICKS) {\n\t\t\tdev_err(dev->class_dev, \"Invalid convert arg\\n\");\n\t\t\tcmd->convert_arg = 2000;\t \n\t\t\terr++;\n\t\t}\n\t\tif (devpriv->ai_scan_ticks <=\n\t\t    cmd->chanlist_len * devpriv->ai_chan_ticks) {\n\t\t\tdev_err(dev->class_dev, \"Invalid scan end arg\\n\");\n\n\t\t\t \n\t\t\tcmd->scan_end_arg = 2000 * cmd->chanlist_len + 31;\n\t\t\terr++;\n\t\t}\n\t} else if (cmd->start_src == TRIG_NOW &&\n\t\t   cmd->scan_begin_src == TRIG_FOLLOW &&\n\t\t   cmd->convert_src == TRIG_TIMER) {\n\t\t \n\t\tif (devpriv->ai_init_ticks < ME4000_AI_MIN_TICKS) {\n\t\t\tdev_err(dev->class_dev, \"Invalid start arg\\n\");\n\t\t\tcmd->start_arg = 2000;\t \n\t\t\terr++;\n\t\t}\n\t\tif (devpriv->ai_chan_ticks < ME4000_AI_MIN_TICKS) {\n\t\t\tdev_err(dev->class_dev, \"Invalid convert arg\\n\");\n\t\t\tcmd->convert_arg = 2000;\t \n\t\t\terr++;\n\t\t}\n\t} else if (cmd->start_src == TRIG_EXT &&\n\t\t   cmd->scan_begin_src == TRIG_TIMER &&\n\t\t   cmd->convert_src == TRIG_TIMER) {\n\t\t \n\t\tif (devpriv->ai_init_ticks < ME4000_AI_MIN_TICKS) {\n\t\t\tdev_err(dev->class_dev, \"Invalid start arg\\n\");\n\t\t\tcmd->start_arg = 2000;\t \n\t\t\terr++;\n\t\t}\n\t\tif (devpriv->ai_chan_ticks < ME4000_AI_MIN_TICKS) {\n\t\t\tdev_err(dev->class_dev, \"Invalid convert arg\\n\");\n\t\t\tcmd->convert_arg = 2000;\t \n\t\t\terr++;\n\t\t}\n\t\tif (devpriv->ai_scan_ticks <=\n\t\t    cmd->chanlist_len * devpriv->ai_chan_ticks) {\n\t\t\tdev_err(dev->class_dev, \"Invalid scan end arg\\n\");\n\n\t\t\t \n\t\t\tcmd->scan_end_arg = 2000 * cmd->chanlist_len + 31;\n\t\t\terr++;\n\t\t}\n\t} else if (cmd->start_src == TRIG_EXT &&\n\t\t   cmd->scan_begin_src == TRIG_FOLLOW &&\n\t\t   cmd->convert_src == TRIG_TIMER) {\n\t\t \n\t\tif (devpriv->ai_init_ticks < ME4000_AI_MIN_TICKS) {\n\t\t\tdev_err(dev->class_dev, \"Invalid start arg\\n\");\n\t\t\tcmd->start_arg = 2000;\t \n\t\t\terr++;\n\t\t}\n\t\tif (devpriv->ai_chan_ticks < ME4000_AI_MIN_TICKS) {\n\t\t\tdev_err(dev->class_dev, \"Invalid convert arg\\n\");\n\t\t\tcmd->convert_arg = 2000;\t \n\t\t\terr++;\n\t\t}\n\t} else if (cmd->start_src == TRIG_EXT &&\n\t\t   cmd->scan_begin_src == TRIG_EXT &&\n\t\t   cmd->convert_src == TRIG_TIMER) {\n\t\t \n\t\tif (devpriv->ai_init_ticks < ME4000_AI_MIN_TICKS) {\n\t\t\tdev_err(dev->class_dev, \"Invalid start arg\\n\");\n\t\t\tcmd->start_arg = 2000;\t \n\t\t\terr++;\n\t\t}\n\t\tif (devpriv->ai_chan_ticks < ME4000_AI_MIN_TICKS) {\n\t\t\tdev_err(dev->class_dev, \"Invalid convert arg\\n\");\n\t\t\tcmd->convert_arg = 2000;\t \n\t\t\terr++;\n\t\t}\n\t} else if (cmd->start_src == TRIG_EXT &&\n\t\t   cmd->scan_begin_src == TRIG_EXT &&\n\t\t   cmd->convert_src == TRIG_EXT) {\n\t\t \n\t\tif (devpriv->ai_init_ticks < ME4000_AI_MIN_TICKS) {\n\t\t\tdev_err(dev->class_dev, \"Invalid start arg\\n\");\n\t\t\tcmd->start_arg = 2000;\t \n\t\t\terr++;\n\t\t}\n\t}\n\tif (cmd->scan_end_src == TRIG_COUNT) {\n\t\tif (cmd->scan_end_arg == 0) {\n\t\t\tdev_err(dev->class_dev, \"Invalid scan end arg\\n\");\n\t\t\tcmd->scan_end_arg = 1;\n\t\t\terr++;\n\t\t}\n\t}\n\n\tif (err)\n\t\treturn 4;\n\n\t \n\tif (cmd->chanlist && cmd->chanlist_len > 0)\n\t\terr |= me4000_ai_check_chanlist(dev, s, cmd);\n\n\tif (err)\n\t\treturn 5;\n\n\treturn 0;\n}\n\nstatic irqreturn_t me4000_ai_isr(int irq, void *dev_id)\n{\n\tunsigned int tmp;\n\tstruct comedi_device *dev = dev_id;\n\tstruct comedi_subdevice *s = dev->read_subdev;\n\tint i;\n\tint c = 0;\n\tunsigned short lval;\n\n\tif (!dev->attached)\n\t\treturn IRQ_NONE;\n\n\tif (inl(dev->iobase + ME4000_IRQ_STATUS_REG) &\n\t    ME4000_IRQ_STATUS_AI_HF) {\n\t\t \n\t\ttmp = inl(dev->iobase + ME4000_AI_STATUS_REG);\n\n\t\tif (!(tmp & ME4000_AI_STATUS_FF_DATA) &&\n\t\t    !(tmp & ME4000_AI_STATUS_HF_DATA) &&\n\t\t    (tmp & ME4000_AI_STATUS_EF_DATA)) {\n\t\t\tdev_err(dev->class_dev, \"FIFO overflow\\n\");\n\t\t\ts->async->events |= COMEDI_CB_ERROR;\n\t\t\tc = ME4000_AI_FIFO_COUNT;\n\t\t} else if ((tmp & ME4000_AI_STATUS_FF_DATA) &&\n\t\t\t   !(tmp & ME4000_AI_STATUS_HF_DATA) &&\n\t\t\t   (tmp & ME4000_AI_STATUS_EF_DATA)) {\n\t\t\tc = ME4000_AI_FIFO_COUNT / 2;\n\t\t} else {\n\t\t\tdev_err(dev->class_dev, \"Undefined FIFO state\\n\");\n\t\t\ts->async->events |= COMEDI_CB_ERROR;\n\t\t\tc = 0;\n\t\t}\n\n\t\tfor (i = 0; i < c; i++) {\n\t\t\tlval = me4000_ai_get_sample(dev, s);\n\t\t\tif (!comedi_buf_write_samples(s, &lval, 1))\n\t\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\ttmp |= ME4000_AI_CTRL_HF_IRQ_RESET;\n\t\toutl(tmp, dev->iobase + ME4000_AI_CTRL_REG);\n\t\ttmp &= ~ME4000_AI_CTRL_HF_IRQ_RESET;\n\t\toutl(tmp, dev->iobase + ME4000_AI_CTRL_REG);\n\t}\n\n\tif (inl(dev->iobase + ME4000_IRQ_STATUS_REG) &\n\t    ME4000_IRQ_STATUS_SC) {\n\t\t \n\t\ts->async->events |= COMEDI_CB_EOA;\n\n\t\t \n\t\twhile (inl(dev->iobase + ME4000_AI_STATUS_REG) &\n\t\t       ME4000_AI_STATUS_EF_DATA) {\n\t\t\tlval = me4000_ai_get_sample(dev, s);\n\t\t\tif (!comedi_buf_write_samples(s, &lval, 1))\n\t\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\ttmp = inl(dev->iobase + ME4000_AI_CTRL_REG);\n\t\ttmp |= ME4000_AI_CTRL_SC_IRQ_RESET;\n\t\toutl(tmp, dev->iobase + ME4000_AI_CTRL_REG);\n\t\ttmp &= ~ME4000_AI_CTRL_SC_IRQ_RESET;\n\t\toutl(tmp, dev->iobase + ME4000_AI_CTRL_REG);\n\t}\n\n\tcomedi_handle_events(dev, s);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int me4000_ao_insn_write(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tstruct comedi_insn *insn,\n\t\t\t\tunsigned int *data)\n{\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int tmp;\n\n\t \n\ttmp = inl(dev->iobase + ME4000_AO_CTRL_REG(chan));\n\ttmp |= ME4000_AO_CTRL_IMMEDIATE_STOP;\n\toutl(tmp, dev->iobase + ME4000_AO_CTRL_REG(chan));\n\n\t \n\toutl(0x0, dev->iobase + ME4000_AO_CTRL_REG(chan));\n\n\t \n\toutl(data[0], dev->iobase + ME4000_AO_SINGLE_REG(chan));\n\n\t \n\ts->readback[chan] = data[0];\n\n\treturn 1;\n}\n\nstatic int me4000_dio_insn_bits(struct comedi_device *dev,\n\t\t\t\tstruct comedi_subdevice *s,\n\t\t\t\tstruct comedi_insn *insn,\n\t\t\t\tunsigned int *data)\n{\n\tif (comedi_dio_update_state(s, data)) {\n\t\toutl((s->state >> 0) & 0xFF,\n\t\t     dev->iobase + ME4000_DIO_PORT_0_REG);\n\t\toutl((s->state >> 8) & 0xFF,\n\t\t     dev->iobase + ME4000_DIO_PORT_1_REG);\n\t\toutl((s->state >> 16) & 0xFF,\n\t\t     dev->iobase + ME4000_DIO_PORT_2_REG);\n\t\toutl((s->state >> 24) & 0xFF,\n\t\t     dev->iobase + ME4000_DIO_PORT_3_REG);\n\t}\n\n\tdata[1] = ((inl(dev->iobase + ME4000_DIO_PORT_0_REG) & 0xFF) << 0) |\n\t\t  ((inl(dev->iobase + ME4000_DIO_PORT_1_REG) & 0xFF) << 8) |\n\t\t  ((inl(dev->iobase + ME4000_DIO_PORT_2_REG) & 0xFF) << 16) |\n\t\t  ((inl(dev->iobase + ME4000_DIO_PORT_3_REG) & 0xFF) << 24);\n\n\treturn insn->n;\n}\n\nstatic int me4000_dio_insn_config(struct comedi_device *dev,\n\t\t\t\t  struct comedi_subdevice *s,\n\t\t\t\t  struct comedi_insn *insn,\n\t\t\t\t  unsigned int *data)\n{\n\tunsigned int chan = CR_CHAN(insn->chanspec);\n\tunsigned int mask;\n\tunsigned int tmp;\n\tint ret;\n\n\tif (chan < 8)\n\t\tmask = 0x000000ff;\n\telse if (chan < 16)\n\t\tmask = 0x0000ff00;\n\telse if (chan < 24)\n\t\tmask = 0x00ff0000;\n\telse\n\t\tmask = 0xff000000;\n\n\tret = comedi_dio_insn_config(dev, s, insn, data, mask);\n\tif (ret)\n\t\treturn ret;\n\n\ttmp = inl(dev->iobase + ME4000_DIO_CTRL_REG);\n\ttmp &= ~(ME4000_DIO_CTRL_MODE_0 | ME4000_DIO_CTRL_MODE_1 |\n\t\t ME4000_DIO_CTRL_MODE_2 | ME4000_DIO_CTRL_MODE_3 |\n\t\t ME4000_DIO_CTRL_MODE_4 | ME4000_DIO_CTRL_MODE_5 |\n\t\t ME4000_DIO_CTRL_MODE_6 | ME4000_DIO_CTRL_MODE_7);\n\tif (s->io_bits & 0x000000ff)\n\t\ttmp |= ME4000_DIO_CTRL_MODE_0;\n\tif (s->io_bits & 0x0000ff00)\n\t\ttmp |= ME4000_DIO_CTRL_MODE_2;\n\tif (s->io_bits & 0x00ff0000)\n\t\ttmp |= ME4000_DIO_CTRL_MODE_4;\n\tif (s->io_bits & 0xff000000)\n\t\ttmp |= ME4000_DIO_CTRL_MODE_6;\n\n\t \n\tif (inl(dev->iobase + ME4000_DIO_DIR_REG)) {\n\t\ts->io_bits |= 0x000000ff;\n\t\ts->io_bits &= ~0x0000ff00;\n\t\ttmp |= ME4000_DIO_CTRL_MODE_0;\n\t\ttmp &= ~(ME4000_DIO_CTRL_MODE_2 | ME4000_DIO_CTRL_MODE_3);\n\t}\n\n\toutl(tmp, dev->iobase + ME4000_DIO_CTRL_REG);\n\n\treturn insn->n;\n}\n\nstatic int me4000_auto_attach(struct comedi_device *dev,\n\t\t\t      unsigned long context)\n{\n\tstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\n\tconst struct me4000_board *board = NULL;\n\tstruct me4000_private *devpriv;\n\tstruct comedi_subdevice *s;\n\tint result;\n\n\tif (context < ARRAY_SIZE(me4000_boards))\n\t\tboard = &me4000_boards[context];\n\tif (!board)\n\t\treturn -ENODEV;\n\tdev->board_ptr = board;\n\tdev->board_name = board->name;\n\n\tdevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\n\tif (!devpriv)\n\t\treturn -ENOMEM;\n\n\tresult = comedi_pci_enable(dev);\n\tif (result)\n\t\treturn result;\n\n\tdevpriv->plx_regbase = pci_resource_start(pcidev, 1);\n\tdev->iobase = pci_resource_start(pcidev, 2);\n\tif (!devpriv->plx_regbase || !dev->iobase)\n\t\treturn -ENODEV;\n\n\tresult = comedi_load_firmware(dev, &pcidev->dev, ME4000_FIRMWARE,\n\t\t\t\t      me4000_xilinx_download, 0);\n\tif (result < 0)\n\t\treturn result;\n\n\tme4000_reset(dev);\n\n\tif (pcidev->irq > 0) {\n\t\tresult = request_irq(pcidev->irq, me4000_ai_isr, IRQF_SHARED,\n\t\t\t\t     dev->board_name, dev);\n\t\tif (result == 0) {\n\t\t\tdev->irq = pcidev->irq;\n\n\t\t\t \n\t\t\toutl(PLX9052_INTCSR_LI1ENAB | PLX9052_INTCSR_LI1POL |\n\t\t\t     PLX9052_INTCSR_PCIENAB,\n\t\t\t     devpriv->plx_regbase + PLX9052_INTCSR);\n\t\t}\n\t}\n\n\tresult = comedi_alloc_subdevices(dev, 4);\n\tif (result)\n\t\treturn result;\n\n\t \n\ts = &dev->subdevices[0];\n\ts->type\t\t= COMEDI_SUBD_AI;\n\ts->subdev_flags\t= SDF_READABLE | SDF_COMMON | SDF_GROUND;\n\tif (board->can_do_diff_ai)\n\t\ts->subdev_flags\t|= SDF_DIFF;\n\ts->n_chan\t= board->ai_nchan;\n\ts->maxdata\t= 0xffff;\n\ts->len_chanlist\t= ME4000_AI_CHANNEL_LIST_COUNT;\n\ts->range_table\t= &me4000_ai_range;\n\ts->insn_read\t= me4000_ai_insn_read;\n\n\tif (dev->irq) {\n\t\tdev->read_subdev = s;\n\t\ts->subdev_flags\t|= SDF_CMD_READ;\n\t\ts->cancel\t= me4000_ai_cancel;\n\t\ts->do_cmdtest\t= me4000_ai_do_cmd_test;\n\t\ts->do_cmd\t= me4000_ai_do_cmd;\n\t}\n\n\t \n\ts = &dev->subdevices[1];\n\tif (board->has_ao) {\n\t\ts->type\t\t= COMEDI_SUBD_AO;\n\t\ts->subdev_flags\t= SDF_WRITABLE | SDF_COMMON | SDF_GROUND;\n\t\ts->n_chan\t= 4;\n\t\ts->maxdata\t= 0xffff;\n\t\ts->range_table\t= &range_bipolar10;\n\t\ts->insn_write\t= me4000_ao_insn_write;\n\n\t\tresult = comedi_alloc_subdev_readback(s);\n\t\tif (result)\n\t\t\treturn result;\n\t} else {\n\t\ts->type\t\t= COMEDI_SUBD_UNUSED;\n\t}\n\n\t \n\ts = &dev->subdevices[2];\n\ts->type\t\t= COMEDI_SUBD_DIO;\n\ts->subdev_flags\t= SDF_READABLE | SDF_WRITABLE;\n\ts->n_chan\t= 32;\n\ts->maxdata\t= 1;\n\ts->range_table\t= &range_digital;\n\ts->insn_bits\t= me4000_dio_insn_bits;\n\ts->insn_config\t= me4000_dio_insn_config;\n\n\t \n\tif (!inl(dev->iobase + ME4000_DIO_DIR_REG)) {\n\t\ts->io_bits |= 0xFF;\n\t\toutl(ME4000_DIO_CTRL_MODE_0,\n\t\t     dev->iobase + ME4000_DIO_DIR_REG);\n\t}\n\n\t \n\ts = &dev->subdevices[3];\n\tif (board->has_counter) {\n\t\tunsigned long timer_base = pci_resource_start(pcidev, 3);\n\n\t\tif (!timer_base)\n\t\t\treturn -ENODEV;\n\n\t\tdev->pacer = comedi_8254_init(timer_base, 0, I8254_IO8, 0);\n\t\tif (!dev->pacer)\n\t\t\treturn -ENOMEM;\n\n\t\tcomedi_8254_subdevice_init(s, dev->pacer);\n\t} else {\n\t\ts->type = COMEDI_SUBD_UNUSED;\n\t}\n\n\treturn 0;\n}\n\nstatic void me4000_detach(struct comedi_device *dev)\n{\n\tif (dev->irq) {\n\t\tstruct me4000_private *devpriv = dev->private;\n\n\t\t \n\t\toutl(0, devpriv->plx_regbase + PLX9052_INTCSR);\n\t}\n\tcomedi_pci_detach(dev);\n}\n\nstatic struct comedi_driver me4000_driver = {\n\t.driver_name\t= \"me4000\",\n\t.module\t\t= THIS_MODULE,\n\t.auto_attach\t= me4000_auto_attach,\n\t.detach\t\t= me4000_detach,\n};\n\nstatic int me4000_pci_probe(struct pci_dev *dev,\n\t\t\t    const struct pci_device_id *id)\n{\n\treturn comedi_pci_auto_config(dev, &me4000_driver, id->driver_data);\n}\n\nstatic const struct pci_device_id me4000_pci_table[] = {\n\t{ PCI_VDEVICE(MEILHAUS, 0x4650), BOARD_ME4650 },\n\t{ PCI_VDEVICE(MEILHAUS, 0x4660), BOARD_ME4660 },\n\t{ PCI_VDEVICE(MEILHAUS, 0x4661), BOARD_ME4660I },\n\t{ PCI_VDEVICE(MEILHAUS, 0x4662), BOARD_ME4660S },\n\t{ PCI_VDEVICE(MEILHAUS, 0x4663), BOARD_ME4660IS },\n\t{ PCI_VDEVICE(MEILHAUS, 0x4670), BOARD_ME4670 },\n\t{ PCI_VDEVICE(MEILHAUS, 0x4671), BOARD_ME4670I },\n\t{ PCI_VDEVICE(MEILHAUS, 0x4672), BOARD_ME4670S },\n\t{ PCI_VDEVICE(MEILHAUS, 0x4673), BOARD_ME4670IS },\n\t{ PCI_VDEVICE(MEILHAUS, 0x4680), BOARD_ME4680 },\n\t{ PCI_VDEVICE(MEILHAUS, 0x4681), BOARD_ME4680I },\n\t{ PCI_VDEVICE(MEILHAUS, 0x4682), BOARD_ME4680S },\n\t{ PCI_VDEVICE(MEILHAUS, 0x4683), BOARD_ME4680IS },\n\t{ 0 }\n};\nMODULE_DEVICE_TABLE(pci, me4000_pci_table);\n\nstatic struct pci_driver me4000_pci_driver = {\n\t.name\t\t= \"me4000\",\n\t.id_table\t= me4000_pci_table,\n\t.probe\t\t= me4000_pci_probe,\n\t.remove\t\t= comedi_pci_auto_unconfig,\n};\nmodule_comedi_pci_driver(me4000_driver, me4000_pci_driver);\n\nMODULE_AUTHOR(\"Comedi https://www.comedi.org\");\nMODULE_DESCRIPTION(\"Comedi driver for Meilhaus ME-4000 series boards\");\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(ME4000_FIRMWARE);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}