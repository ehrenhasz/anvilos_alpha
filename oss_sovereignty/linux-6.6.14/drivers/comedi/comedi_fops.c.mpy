{
  "module_name": "comedi_fops.c",
  "hash_id": "1e719df79f34163a3b5a5c2d444ac5fa3525283d7ec43899b1a8c4f7577808ee",
  "original_prompt": "Ingested from linux-6.6.14/drivers/comedi/comedi_fops.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/fcntl.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/device.h>\n#include <linux/fs.h>\n#include <linux/comedi/comedidev.h>\n#include <linux/cdev.h>\n\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n\n#include \"comedi_internal.h\"\n\n \n#define COMEDI_SRF_RT\t\tBIT(1)\n#define COMEDI_SRF_ERROR\tBIT(2)\n#define COMEDI_SRF_RUNNING\tBIT(27)\n#define COMEDI_SRF_FREE_SPRIV\tBIT(31)\n\n#define COMEDI_SRF_BUSY_MASK\t(COMEDI_SRF_ERROR | COMEDI_SRF_RUNNING)\n\n \nstruct comedi_file {\n\tstruct comedi_device *dev;\n\tstruct comedi_subdevice *read_subdev;\n\tstruct comedi_subdevice *write_subdev;\n\tunsigned int last_detach_count;\n\tunsigned int last_attached:1;\n};\n\n#define COMEDI_NUM_MINORS 0x100\n#define COMEDI_NUM_SUBDEVICE_MINORS\t\\\n\t(COMEDI_NUM_MINORS - COMEDI_NUM_BOARD_MINORS)\n\nstatic unsigned short comedi_num_legacy_minors;\nmodule_param(comedi_num_legacy_minors, ushort, 0444);\nMODULE_PARM_DESC(comedi_num_legacy_minors,\n\t\t \"number of comedi minor devices to reserve for non-auto-configured devices (default 0)\"\n\t\t);\n\nunsigned int comedi_default_buf_size_kb = CONFIG_COMEDI_DEFAULT_BUF_SIZE_KB;\nmodule_param(comedi_default_buf_size_kb, uint, 0644);\nMODULE_PARM_DESC(comedi_default_buf_size_kb,\n\t\t \"default asynchronous buffer size in KiB (default \"\n\t\t __MODULE_STRING(CONFIG_COMEDI_DEFAULT_BUF_SIZE_KB) \")\");\n\nunsigned int comedi_default_buf_maxsize_kb =\n\tCONFIG_COMEDI_DEFAULT_BUF_MAXSIZE_KB;\nmodule_param(comedi_default_buf_maxsize_kb, uint, 0644);\nMODULE_PARM_DESC(comedi_default_buf_maxsize_kb,\n\t\t \"default maximum size of asynchronous buffer in KiB (default \"\n\t\t __MODULE_STRING(CONFIG_COMEDI_DEFAULT_BUF_MAXSIZE_KB) \")\");\n\nstatic DEFINE_MUTEX(comedi_board_minor_table_lock);\nstatic struct comedi_device\n*comedi_board_minor_table[COMEDI_NUM_BOARD_MINORS];\n\nstatic DEFINE_MUTEX(comedi_subdevice_minor_table_lock);\n \nstatic struct comedi_subdevice\n*comedi_subdevice_minor_table[COMEDI_NUM_SUBDEVICE_MINORS];\n\nstatic struct cdev comedi_cdev;\n\nstatic void comedi_device_init(struct comedi_device *dev)\n{\n\tkref_init(&dev->refcount);\n\tspin_lock_init(&dev->spinlock);\n\tmutex_init(&dev->mutex);\n\tinit_rwsem(&dev->attach_lock);\n\tdev->minor = -1;\n}\n\nstatic void comedi_dev_kref_release(struct kref *kref)\n{\n\tstruct comedi_device *dev =\n\t\tcontainer_of(kref, struct comedi_device, refcount);\n\n\tmutex_destroy(&dev->mutex);\n\tput_device(dev->class_dev);\n\tkfree(dev);\n}\n\n \nint comedi_dev_put(struct comedi_device *dev)\n{\n\tif (dev)\n\t\treturn kref_put(&dev->refcount, comedi_dev_kref_release);\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(comedi_dev_put);\n\nstatic struct comedi_device *comedi_dev_get(struct comedi_device *dev)\n{\n\tif (dev)\n\t\tkref_get(&dev->refcount);\n\treturn dev;\n}\n\nstatic void comedi_device_cleanup(struct comedi_device *dev)\n{\n\tstruct module *driver_module = NULL;\n\n\tif (!dev)\n\t\treturn;\n\tmutex_lock(&dev->mutex);\n\tif (dev->attached)\n\t\tdriver_module = dev->driver->module;\n\tcomedi_device_detach(dev);\n\tif (driver_module && dev->use_count)\n\t\tmodule_put(driver_module);\n\tmutex_unlock(&dev->mutex);\n}\n\nstatic bool comedi_clear_board_dev(struct comedi_device *dev)\n{\n\tunsigned int i = dev->minor;\n\tbool cleared = false;\n\n\tlockdep_assert_held(&dev->mutex);\n\tmutex_lock(&comedi_board_minor_table_lock);\n\tif (dev == comedi_board_minor_table[i]) {\n\t\tcomedi_board_minor_table[i] = NULL;\n\t\tcleared = true;\n\t}\n\tmutex_unlock(&comedi_board_minor_table_lock);\n\treturn cleared;\n}\n\nstatic struct comedi_device *comedi_clear_board_minor(unsigned int minor)\n{\n\tstruct comedi_device *dev;\n\n\tmutex_lock(&comedi_board_minor_table_lock);\n\tdev = comedi_board_minor_table[minor];\n\tcomedi_board_minor_table[minor] = NULL;\n\tmutex_unlock(&comedi_board_minor_table_lock);\n\treturn dev;\n}\n\nstatic struct comedi_subdevice *\ncomedi_subdevice_from_minor(const struct comedi_device *dev, unsigned int minor)\n{\n\tstruct comedi_subdevice *s;\n\tunsigned int i = minor - COMEDI_NUM_BOARD_MINORS;\n\n\tmutex_lock(&comedi_subdevice_minor_table_lock);\n\ts = comedi_subdevice_minor_table[i];\n\tif (s && s->device != dev)\n\t\ts = NULL;\n\tmutex_unlock(&comedi_subdevice_minor_table_lock);\n\treturn s;\n}\n\nstatic struct comedi_device *comedi_dev_get_from_board_minor(unsigned int minor)\n{\n\tstruct comedi_device *dev;\n\n\tmutex_lock(&comedi_board_minor_table_lock);\n\tdev = comedi_dev_get(comedi_board_minor_table[minor]);\n\tmutex_unlock(&comedi_board_minor_table_lock);\n\treturn dev;\n}\n\nstatic struct comedi_device *\ncomedi_dev_get_from_subdevice_minor(unsigned int minor)\n{\n\tstruct comedi_device *dev;\n\tstruct comedi_subdevice *s;\n\tunsigned int i = minor - COMEDI_NUM_BOARD_MINORS;\n\n\tmutex_lock(&comedi_subdevice_minor_table_lock);\n\ts = comedi_subdevice_minor_table[i];\n\tdev = comedi_dev_get(s ? s->device : NULL);\n\tmutex_unlock(&comedi_subdevice_minor_table_lock);\n\treturn dev;\n}\n\n \nstruct comedi_device *comedi_dev_get_from_minor(unsigned int minor)\n{\n\tif (minor < COMEDI_NUM_BOARD_MINORS)\n\t\treturn comedi_dev_get_from_board_minor(minor);\n\n\treturn comedi_dev_get_from_subdevice_minor(minor);\n}\nEXPORT_SYMBOL_GPL(comedi_dev_get_from_minor);\n\nstatic struct comedi_subdevice *\ncomedi_read_subdevice(const struct comedi_device *dev, unsigned int minor)\n{\n\tstruct comedi_subdevice *s;\n\n\tlockdep_assert_held(&dev->mutex);\n\tif (minor >= COMEDI_NUM_BOARD_MINORS) {\n\t\ts = comedi_subdevice_from_minor(dev, minor);\n\t\tif (!s || (s->subdev_flags & SDF_CMD_READ))\n\t\t\treturn s;\n\t}\n\treturn dev->read_subdev;\n}\n\nstatic struct comedi_subdevice *\ncomedi_write_subdevice(const struct comedi_device *dev, unsigned int minor)\n{\n\tstruct comedi_subdevice *s;\n\n\tlockdep_assert_held(&dev->mutex);\n\tif (minor >= COMEDI_NUM_BOARD_MINORS) {\n\t\ts = comedi_subdevice_from_minor(dev, minor);\n\t\tif (!s || (s->subdev_flags & SDF_CMD_WRITE))\n\t\t\treturn s;\n\t}\n\treturn dev->write_subdev;\n}\n\nstatic void comedi_file_reset(struct file *file)\n{\n\tstruct comedi_file *cfp = file->private_data;\n\tstruct comedi_device *dev = cfp->dev;\n\tstruct comedi_subdevice *s, *read_s, *write_s;\n\tunsigned int minor = iminor(file_inode(file));\n\n\tread_s = dev->read_subdev;\n\twrite_s = dev->write_subdev;\n\tif (minor >= COMEDI_NUM_BOARD_MINORS) {\n\t\ts = comedi_subdevice_from_minor(dev, minor);\n\t\tif (!s || s->subdev_flags & SDF_CMD_READ)\n\t\t\tread_s = s;\n\t\tif (!s || s->subdev_flags & SDF_CMD_WRITE)\n\t\t\twrite_s = s;\n\t}\n\tcfp->last_attached = dev->attached;\n\tcfp->last_detach_count = dev->detach_count;\n\tWRITE_ONCE(cfp->read_subdev, read_s);\n\tWRITE_ONCE(cfp->write_subdev, write_s);\n}\n\nstatic void comedi_file_check(struct file *file)\n{\n\tstruct comedi_file *cfp = file->private_data;\n\tstruct comedi_device *dev = cfp->dev;\n\n\tif (cfp->last_attached != dev->attached ||\n\t    cfp->last_detach_count != dev->detach_count)\n\t\tcomedi_file_reset(file);\n}\n\nstatic struct comedi_subdevice *comedi_file_read_subdevice(struct file *file)\n{\n\tstruct comedi_file *cfp = file->private_data;\n\n\tcomedi_file_check(file);\n\treturn READ_ONCE(cfp->read_subdev);\n}\n\nstatic struct comedi_subdevice *comedi_file_write_subdevice(struct file *file)\n{\n\tstruct comedi_file *cfp = file->private_data;\n\n\tcomedi_file_check(file);\n\treturn READ_ONCE(cfp->write_subdev);\n}\n\nstatic int resize_async_buffer(struct comedi_device *dev,\n\t\t\t       struct comedi_subdevice *s,\n\t\t\t       unsigned int new_size)\n{\n\tstruct comedi_async *async = s->async;\n\tint retval;\n\n\tlockdep_assert_held(&dev->mutex);\n\n\tif (new_size > async->max_bufsize)\n\t\treturn -EPERM;\n\n\tif (s->busy) {\n\t\tdev_dbg(dev->class_dev,\n\t\t\t\"subdevice is busy, cannot resize buffer\\n\");\n\t\treturn -EBUSY;\n\t}\n\tif (comedi_buf_is_mmapped(s)) {\n\t\tdev_dbg(dev->class_dev,\n\t\t\t\"subdevice is mmapped, cannot resize buffer\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tnew_size = (new_size + PAGE_SIZE - 1) & PAGE_MASK;\n\n\tretval = comedi_buf_alloc(dev, s, new_size);\n\tif (retval < 0)\n\t\treturn retval;\n\n\tif (s->buf_change) {\n\t\tretval = s->buf_change(dev, s);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\n\tdev_dbg(dev->class_dev, \"subd %d buffer resized to %i bytes\\n\",\n\t\ts->index, async->prealloc_bufsz);\n\treturn 0;\n}\n\n \n\nstatic ssize_t max_read_buffer_kb_show(struct device *csdev,\n\t\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tunsigned int minor = MINOR(csdev->devt);\n\tstruct comedi_device *dev;\n\tstruct comedi_subdevice *s;\n\tunsigned int size = 0;\n\n\tdev = comedi_dev_get_from_minor(minor);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&dev->mutex);\n\ts = comedi_read_subdevice(dev, minor);\n\tif (s && (s->subdev_flags & SDF_CMD_READ) && s->async)\n\t\tsize = s->async->max_bufsize / 1024;\n\tmutex_unlock(&dev->mutex);\n\n\tcomedi_dev_put(dev);\n\treturn sysfs_emit(buf, \"%u\\n\", size);\n}\n\nstatic ssize_t max_read_buffer_kb_store(struct device *csdev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tunsigned int minor = MINOR(csdev->devt);\n\tstruct comedi_device *dev;\n\tstruct comedi_subdevice *s;\n\tunsigned int size;\n\tint err;\n\n\terr = kstrtouint(buf, 10, &size);\n\tif (err)\n\t\treturn err;\n\tif (size > (UINT_MAX / 1024))\n\t\treturn -EINVAL;\n\tsize *= 1024;\n\n\tdev = comedi_dev_get_from_minor(minor);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&dev->mutex);\n\ts = comedi_read_subdevice(dev, minor);\n\tif (s && (s->subdev_flags & SDF_CMD_READ) && s->async)\n\t\ts->async->max_bufsize = size;\n\telse\n\t\terr = -EINVAL;\n\tmutex_unlock(&dev->mutex);\n\n\tcomedi_dev_put(dev);\n\treturn err ? err : count;\n}\nstatic DEVICE_ATTR_RW(max_read_buffer_kb);\n\nstatic ssize_t read_buffer_kb_show(struct device *csdev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tunsigned int minor = MINOR(csdev->devt);\n\tstruct comedi_device *dev;\n\tstruct comedi_subdevice *s;\n\tunsigned int size = 0;\n\n\tdev = comedi_dev_get_from_minor(minor);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&dev->mutex);\n\ts = comedi_read_subdevice(dev, minor);\n\tif (s && (s->subdev_flags & SDF_CMD_READ) && s->async)\n\t\tsize = s->async->prealloc_bufsz / 1024;\n\tmutex_unlock(&dev->mutex);\n\n\tcomedi_dev_put(dev);\n\treturn sysfs_emit(buf, \"%u\\n\", size);\n}\n\nstatic ssize_t read_buffer_kb_store(struct device *csdev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tunsigned int minor = MINOR(csdev->devt);\n\tstruct comedi_device *dev;\n\tstruct comedi_subdevice *s;\n\tunsigned int size;\n\tint err;\n\n\terr = kstrtouint(buf, 10, &size);\n\tif (err)\n\t\treturn err;\n\tif (size > (UINT_MAX / 1024))\n\t\treturn -EINVAL;\n\tsize *= 1024;\n\n\tdev = comedi_dev_get_from_minor(minor);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&dev->mutex);\n\ts = comedi_read_subdevice(dev, minor);\n\tif (s && (s->subdev_flags & SDF_CMD_READ) && s->async)\n\t\terr = resize_async_buffer(dev, s, size);\n\telse\n\t\terr = -EINVAL;\n\tmutex_unlock(&dev->mutex);\n\n\tcomedi_dev_put(dev);\n\treturn err ? err : count;\n}\nstatic DEVICE_ATTR_RW(read_buffer_kb);\n\nstatic ssize_t max_write_buffer_kb_show(struct device *csdev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tunsigned int minor = MINOR(csdev->devt);\n\tstruct comedi_device *dev;\n\tstruct comedi_subdevice *s;\n\tunsigned int size = 0;\n\n\tdev = comedi_dev_get_from_minor(minor);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&dev->mutex);\n\ts = comedi_write_subdevice(dev, minor);\n\tif (s && (s->subdev_flags & SDF_CMD_WRITE) && s->async)\n\t\tsize = s->async->max_bufsize / 1024;\n\tmutex_unlock(&dev->mutex);\n\n\tcomedi_dev_put(dev);\n\treturn sysfs_emit(buf, \"%u\\n\", size);\n}\n\nstatic ssize_t max_write_buffer_kb_store(struct device *csdev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t const char *buf, size_t count)\n{\n\tunsigned int minor = MINOR(csdev->devt);\n\tstruct comedi_device *dev;\n\tstruct comedi_subdevice *s;\n\tunsigned int size;\n\tint err;\n\n\terr = kstrtouint(buf, 10, &size);\n\tif (err)\n\t\treturn err;\n\tif (size > (UINT_MAX / 1024))\n\t\treturn -EINVAL;\n\tsize *= 1024;\n\n\tdev = comedi_dev_get_from_minor(minor);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&dev->mutex);\n\ts = comedi_write_subdevice(dev, minor);\n\tif (s && (s->subdev_flags & SDF_CMD_WRITE) && s->async)\n\t\ts->async->max_bufsize = size;\n\telse\n\t\terr = -EINVAL;\n\tmutex_unlock(&dev->mutex);\n\n\tcomedi_dev_put(dev);\n\treturn err ? err : count;\n}\nstatic DEVICE_ATTR_RW(max_write_buffer_kb);\n\nstatic ssize_t write_buffer_kb_show(struct device *csdev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tunsigned int minor = MINOR(csdev->devt);\n\tstruct comedi_device *dev;\n\tstruct comedi_subdevice *s;\n\tunsigned int size = 0;\n\n\tdev = comedi_dev_get_from_minor(minor);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&dev->mutex);\n\ts = comedi_write_subdevice(dev, minor);\n\tif (s && (s->subdev_flags & SDF_CMD_WRITE) && s->async)\n\t\tsize = s->async->prealloc_bufsz / 1024;\n\tmutex_unlock(&dev->mutex);\n\n\tcomedi_dev_put(dev);\n\treturn sysfs_emit(buf, \"%u\\n\", size);\n}\n\nstatic ssize_t write_buffer_kb_store(struct device *csdev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tunsigned int minor = MINOR(csdev->devt);\n\tstruct comedi_device *dev;\n\tstruct comedi_subdevice *s;\n\tunsigned int size;\n\tint err;\n\n\terr = kstrtouint(buf, 10, &size);\n\tif (err)\n\t\treturn err;\n\tif (size > (UINT_MAX / 1024))\n\t\treturn -EINVAL;\n\tsize *= 1024;\n\n\tdev = comedi_dev_get_from_minor(minor);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&dev->mutex);\n\ts = comedi_write_subdevice(dev, minor);\n\tif (s && (s->subdev_flags & SDF_CMD_WRITE) && s->async)\n\t\terr = resize_async_buffer(dev, s, size);\n\telse\n\t\terr = -EINVAL;\n\tmutex_unlock(&dev->mutex);\n\n\tcomedi_dev_put(dev);\n\treturn err ? err : count;\n}\nstatic DEVICE_ATTR_RW(write_buffer_kb);\n\nstatic struct attribute *comedi_dev_attrs[] = {\n\t&dev_attr_max_read_buffer_kb.attr,\n\t&dev_attr_read_buffer_kb.attr,\n\t&dev_attr_max_write_buffer_kb.attr,\n\t&dev_attr_write_buffer_kb.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(comedi_dev);\n\nstatic const struct class comedi_class = {\n\t.name = \"comedi\",\n\t.dev_groups = comedi_dev_groups,\n};\n\nstatic void comedi_free_board_dev(struct comedi_device *dev)\n{\n\tif (dev) {\n\t\tcomedi_device_cleanup(dev);\n\t\tif (dev->class_dev) {\n\t\t\tdevice_destroy(&comedi_class,\n\t\t\t\t       MKDEV(COMEDI_MAJOR, dev->minor));\n\t\t}\n\t\tcomedi_dev_put(dev);\n\t}\n}\n\nstatic void __comedi_clear_subdevice_runflags(struct comedi_subdevice *s,\n\t\t\t\t\t      unsigned int bits)\n{\n\ts->runflags &= ~bits;\n}\n\nstatic void __comedi_set_subdevice_runflags(struct comedi_subdevice *s,\n\t\t\t\t\t    unsigned int bits)\n{\n\ts->runflags |= bits;\n}\n\nstatic void comedi_update_subdevice_runflags(struct comedi_subdevice *s,\n\t\t\t\t\t     unsigned int mask,\n\t\t\t\t\t     unsigned int bits)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&s->spin_lock, flags);\n\t__comedi_clear_subdevice_runflags(s, mask);\n\t__comedi_set_subdevice_runflags(s, bits & mask);\n\tspin_unlock_irqrestore(&s->spin_lock, flags);\n}\n\nstatic unsigned int __comedi_get_subdevice_runflags(struct comedi_subdevice *s)\n{\n\treturn s->runflags;\n}\n\nstatic unsigned int comedi_get_subdevice_runflags(struct comedi_subdevice *s)\n{\n\tunsigned long flags;\n\tunsigned int runflags;\n\n\tspin_lock_irqsave(&s->spin_lock, flags);\n\trunflags = __comedi_get_subdevice_runflags(s);\n\tspin_unlock_irqrestore(&s->spin_lock, flags);\n\treturn runflags;\n}\n\nstatic bool comedi_is_runflags_running(unsigned int runflags)\n{\n\treturn runflags & COMEDI_SRF_RUNNING;\n}\n\nstatic bool comedi_is_runflags_in_error(unsigned int runflags)\n{\n\treturn runflags & COMEDI_SRF_ERROR;\n}\n\n \nbool comedi_is_subdevice_running(struct comedi_subdevice *s)\n{\n\tunsigned int runflags = comedi_get_subdevice_runflags(s);\n\n\treturn comedi_is_runflags_running(runflags);\n}\nEXPORT_SYMBOL_GPL(comedi_is_subdevice_running);\n\nstatic bool __comedi_is_subdevice_running(struct comedi_subdevice *s)\n{\n\tunsigned int runflags = __comedi_get_subdevice_runflags(s);\n\n\treturn comedi_is_runflags_running(runflags);\n}\n\nbool comedi_can_auto_free_spriv(struct comedi_subdevice *s)\n{\n\tunsigned int runflags = __comedi_get_subdevice_runflags(s);\n\n\treturn runflags & COMEDI_SRF_FREE_SPRIV;\n}\n\n \nvoid comedi_set_spriv_auto_free(struct comedi_subdevice *s)\n{\n\t__comedi_set_subdevice_runflags(s, COMEDI_SRF_FREE_SPRIV);\n}\nEXPORT_SYMBOL_GPL(comedi_set_spriv_auto_free);\n\n \nvoid *comedi_alloc_spriv(struct comedi_subdevice *s, size_t size)\n{\n\ts->private = kzalloc(size, GFP_KERNEL);\n\tif (s->private)\n\t\tcomedi_set_spriv_auto_free(s);\n\treturn s->private;\n}\nEXPORT_SYMBOL_GPL(comedi_alloc_spriv);\n\n \nstatic void do_become_nonbusy(struct comedi_device *dev,\n\t\t\t      struct comedi_subdevice *s)\n{\n\tstruct comedi_async *async = s->async;\n\n\tlockdep_assert_held(&dev->mutex);\n\tcomedi_update_subdevice_runflags(s, COMEDI_SRF_RUNNING, 0);\n\tif (async) {\n\t\tcomedi_buf_reset(s);\n\t\tasync->inttrig = NULL;\n\t\tkfree(async->cmd.chanlist);\n\t\tasync->cmd.chanlist = NULL;\n\t\ts->busy = NULL;\n\t\twake_up_interruptible_all(&async->wait_head);\n\t} else {\n\t\tdev_err(dev->class_dev,\n\t\t\t\"BUG: (?) %s called with async=NULL\\n\", __func__);\n\t\ts->busy = NULL;\n\t}\n}\n\nstatic int do_cancel(struct comedi_device *dev, struct comedi_subdevice *s)\n{\n\tint ret = 0;\n\n\tlockdep_assert_held(&dev->mutex);\n\tif (comedi_is_subdevice_running(s) && s->cancel)\n\t\tret = s->cancel(dev, s);\n\n\tdo_become_nonbusy(dev, s);\n\n\treturn ret;\n}\n\nvoid comedi_device_cancel_all(struct comedi_device *dev)\n{\n\tstruct comedi_subdevice *s;\n\tint i;\n\n\tlockdep_assert_held(&dev->mutex);\n\tif (!dev->attached)\n\t\treturn;\n\n\tfor (i = 0; i < dev->n_subdevices; i++) {\n\t\ts = &dev->subdevices[i];\n\t\tif (s->async)\n\t\t\tdo_cancel(dev, s);\n\t}\n}\n\nstatic int is_device_busy(struct comedi_device *dev)\n{\n\tstruct comedi_subdevice *s;\n\tint i;\n\n\tlockdep_assert_held(&dev->mutex);\n\tif (!dev->attached)\n\t\treturn 0;\n\n\tfor (i = 0; i < dev->n_subdevices; i++) {\n\t\ts = &dev->subdevices[i];\n\t\tif (s->busy)\n\t\t\treturn 1;\n\t\tif (s->async && comedi_buf_is_mmapped(s))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int do_devconfig_ioctl(struct comedi_device *dev,\n\t\t\t      struct comedi_devconfig __user *arg)\n{\n\tstruct comedi_devconfig it;\n\n\tlockdep_assert_held(&dev->mutex);\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!arg) {\n\t\tif (is_device_busy(dev))\n\t\t\treturn -EBUSY;\n\t\tif (dev->attached) {\n\t\t\tstruct module *driver_module = dev->driver->module;\n\n\t\t\tcomedi_device_detach(dev);\n\t\t\tmodule_put(driver_module);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (copy_from_user(&it, arg, sizeof(it)))\n\t\treturn -EFAULT;\n\n\tit.board_name[COMEDI_NAMELEN - 1] = 0;\n\n\tif (it.options[COMEDI_DEVCONF_AUX_DATA_LENGTH]) {\n\t\tdev_warn(dev->class_dev,\n\t\t\t \"comedi_config --init_data is deprecated\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (dev->minor >= comedi_num_legacy_minors)\n\t\t \n\t\treturn -EBUSY;\n\n\t \n\treturn comedi_device_attach(dev, &it);\n}\n\n \nstatic int do_bufconfig_ioctl(struct comedi_device *dev,\n\t\t\t      struct comedi_bufconfig __user *arg)\n{\n\tstruct comedi_bufconfig bc;\n\tstruct comedi_async *async;\n\tstruct comedi_subdevice *s;\n\tint retval = 0;\n\n\tlockdep_assert_held(&dev->mutex);\n\tif (copy_from_user(&bc, arg, sizeof(bc)))\n\t\treturn -EFAULT;\n\n\tif (bc.subdevice >= dev->n_subdevices)\n\t\treturn -EINVAL;\n\n\ts = &dev->subdevices[bc.subdevice];\n\tasync = s->async;\n\n\tif (!async) {\n\t\tdev_dbg(dev->class_dev,\n\t\t\t\"subdevice does not have async capability\\n\");\n\t\tbc.size = 0;\n\t\tbc.maximum_size = 0;\n\t\tgoto copyback;\n\t}\n\n\tif (bc.maximum_size) {\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tasync->max_bufsize = bc.maximum_size;\n\t}\n\n\tif (bc.size) {\n\t\tretval = resize_async_buffer(dev, s, bc.size);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\n\tbc.size = async->prealloc_bufsz;\n\tbc.maximum_size = async->max_bufsize;\n\ncopyback:\n\tif (copy_to_user(arg, &bc, sizeof(bc)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n \nstatic int do_devinfo_ioctl(struct comedi_device *dev,\n\t\t\t    struct comedi_devinfo __user *arg,\n\t\t\t    struct file *file)\n{\n\tstruct comedi_subdevice *s;\n\tstruct comedi_devinfo devinfo;\n\n\tlockdep_assert_held(&dev->mutex);\n\tmemset(&devinfo, 0, sizeof(devinfo));\n\n\t \n\tdevinfo.version_code = COMEDI_VERSION_CODE;\n\tdevinfo.n_subdevs = dev->n_subdevices;\n\tstrscpy(devinfo.driver_name, dev->driver->driver_name, COMEDI_NAMELEN);\n\tstrscpy(devinfo.board_name, dev->board_name, COMEDI_NAMELEN);\n\n\ts = comedi_file_read_subdevice(file);\n\tif (s)\n\t\tdevinfo.read_subdevice = s->index;\n\telse\n\t\tdevinfo.read_subdevice = -1;\n\n\ts = comedi_file_write_subdevice(file);\n\tif (s)\n\t\tdevinfo.write_subdevice = s->index;\n\telse\n\t\tdevinfo.write_subdevice = -1;\n\n\tif (copy_to_user(arg, &devinfo, sizeof(devinfo)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n \nstatic int do_subdinfo_ioctl(struct comedi_device *dev,\n\t\t\t     struct comedi_subdinfo __user *arg, void *file)\n{\n\tint ret, i;\n\tstruct comedi_subdinfo *tmp, *us;\n\tstruct comedi_subdevice *s;\n\n\tlockdep_assert_held(&dev->mutex);\n\ttmp = kcalloc(dev->n_subdevices, sizeof(*tmp), GFP_KERNEL);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = 0; i < dev->n_subdevices; i++) {\n\t\ts = &dev->subdevices[i];\n\t\tus = tmp + i;\n\n\t\tus->type = s->type;\n\t\tus->n_chan = s->n_chan;\n\t\tus->subd_flags = s->subdev_flags;\n\t\tif (comedi_is_subdevice_running(s))\n\t\t\tus->subd_flags |= SDF_RUNNING;\n#define TIMER_nanosec 5\t\t \n\t\tus->timer_type = TIMER_nanosec;\n\t\tus->len_chanlist = s->len_chanlist;\n\t\tus->maxdata = s->maxdata;\n\t\tif (s->range_table) {\n\t\t\tus->range_type =\n\t\t\t    (i << 24) | (0 << 16) | (s->range_table->length);\n\t\t} else {\n\t\t\tus->range_type = 0;\t \n\t\t}\n\n\t\tif (s->busy)\n\t\t\tus->subd_flags |= SDF_BUSY;\n\t\tif (s->busy == file)\n\t\t\tus->subd_flags |= SDF_BUSY_OWNER;\n\t\tif (s->lock)\n\t\t\tus->subd_flags |= SDF_LOCKED;\n\t\tif (s->lock == file)\n\t\t\tus->subd_flags |= SDF_LOCK_OWNER;\n\t\tif (!s->maxdata && s->maxdata_list)\n\t\t\tus->subd_flags |= SDF_MAXDATA;\n\t\tif (s->range_table_list)\n\t\t\tus->subd_flags |= SDF_RANGETYPE;\n\t\tif (s->do_cmd)\n\t\t\tus->subd_flags |= SDF_CMD;\n\n\t\tif (s->insn_bits != &insn_inval)\n\t\t\tus->insn_bits_support = COMEDI_SUPPORTED;\n\t\telse\n\t\t\tus->insn_bits_support = COMEDI_UNSUPPORTED;\n\t}\n\n\tret = copy_to_user(arg, tmp, dev->n_subdevices * sizeof(*tmp));\n\n\tkfree(tmp);\n\n\treturn ret ? -EFAULT : 0;\n}\n\n \nstatic int do_chaninfo_ioctl(struct comedi_device *dev,\n\t\t\t     struct comedi_chaninfo *it)\n{\n\tstruct comedi_subdevice *s;\n\n\tlockdep_assert_held(&dev->mutex);\n\n\tif (it->subdev >= dev->n_subdevices)\n\t\treturn -EINVAL;\n\ts = &dev->subdevices[it->subdev];\n\n\tif (it->maxdata_list) {\n\t\tif (s->maxdata || !s->maxdata_list)\n\t\t\treturn -EINVAL;\n\t\tif (copy_to_user(it->maxdata_list, s->maxdata_list,\n\t\t\t\t s->n_chan * sizeof(unsigned int)))\n\t\t\treturn -EFAULT;\n\t}\n\n\tif (it->flaglist)\n\t\treturn -EINVAL;\t \n\n\tif (it->rangelist) {\n\t\tint i;\n\n\t\tif (!s->range_table_list)\n\t\t\treturn -EINVAL;\n\t\tfor (i = 0; i < s->n_chan; i++) {\n\t\t\tint x;\n\n\t\t\tx = (dev->minor << 28) | (it->subdev << 24) | (i << 16) |\n\t\t\t    (s->range_table_list[i]->length);\n\t\t\tif (put_user(x, it->rangelist + i))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int do_bufinfo_ioctl(struct comedi_device *dev,\n\t\t\t    struct comedi_bufinfo __user *arg, void *file)\n{\n\tstruct comedi_bufinfo bi;\n\tstruct comedi_subdevice *s;\n\tstruct comedi_async *async;\n\tunsigned int runflags;\n\tint retval = 0;\n\tbool become_nonbusy = false;\n\n\tlockdep_assert_held(&dev->mutex);\n\tif (copy_from_user(&bi, arg, sizeof(bi)))\n\t\treturn -EFAULT;\n\n\tif (bi.subdevice >= dev->n_subdevices)\n\t\treturn -EINVAL;\n\n\ts = &dev->subdevices[bi.subdevice];\n\n\tasync = s->async;\n\n\tif (!async || s->busy != file)\n\t\treturn -EINVAL;\n\n\trunflags = comedi_get_subdevice_runflags(s);\n\tif (!(async->cmd.flags & CMDF_WRITE)) {\n\t\t \n\t\tif (bi.bytes_read) {\n\t\t\tcomedi_buf_read_alloc(s, bi.bytes_read);\n\t\t\tbi.bytes_read = comedi_buf_read_free(s, bi.bytes_read);\n\t\t}\n\t\t \n\t\tif (comedi_buf_read_n_available(s) == 0 &&\n\t\t    !comedi_is_runflags_running(runflags) &&\n\t\t    (bi.bytes_read == 0 ||\n\t\t     !comedi_is_runflags_in_error(runflags))) {\n\t\t\tbecome_nonbusy = true;\n\t\t\tif (comedi_is_runflags_in_error(runflags))\n\t\t\t\tretval = -EPIPE;\n\t\t}\n\t\tbi.bytes_written = 0;\n\t} else {\n\t\t \n\t\tif (!comedi_is_runflags_running(runflags)) {\n\t\t\tbi.bytes_written = 0;\n\t\t\tbecome_nonbusy = true;\n\t\t\tif (comedi_is_runflags_in_error(runflags))\n\t\t\t\tretval = -EPIPE;\n\t\t} else if (bi.bytes_written) {\n\t\t\tcomedi_buf_write_alloc(s, bi.bytes_written);\n\t\t\tbi.bytes_written =\n\t\t\t    comedi_buf_write_free(s, bi.bytes_written);\n\t\t}\n\t\tbi.bytes_read = 0;\n\t}\n\n\tbi.buf_write_count = async->buf_write_count;\n\tbi.buf_write_ptr = async->buf_write_ptr;\n\tbi.buf_read_count = async->buf_read_count;\n\tbi.buf_read_ptr = async->buf_read_ptr;\n\n\tif (become_nonbusy)\n\t\tdo_become_nonbusy(dev, s);\n\n\tif (retval)\n\t\treturn retval;\n\n\tif (copy_to_user(arg, &bi, sizeof(bi)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int check_insn_config_length(struct comedi_insn *insn,\n\t\t\t\t    unsigned int *data)\n{\n\tif (insn->n < 1)\n\t\treturn -EINVAL;\n\n\tswitch (data[0]) {\n\tcase INSN_CONFIG_DIO_OUTPUT:\n\tcase INSN_CONFIG_DIO_INPUT:\n\tcase INSN_CONFIG_DISARM:\n\tcase INSN_CONFIG_RESET:\n\t\tif (insn->n == 1)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase INSN_CONFIG_ARM:\n\tcase INSN_CONFIG_DIO_QUERY:\n\tcase INSN_CONFIG_BLOCK_SIZE:\n\tcase INSN_CONFIG_FILTER:\n\tcase INSN_CONFIG_SERIAL_CLOCK:\n\tcase INSN_CONFIG_BIDIRECTIONAL_DATA:\n\tcase INSN_CONFIG_ALT_SOURCE:\n\tcase INSN_CONFIG_SET_COUNTER_MODE:\n\tcase INSN_CONFIG_8254_READ_STATUS:\n\tcase INSN_CONFIG_SET_ROUTING:\n\tcase INSN_CONFIG_GET_ROUTING:\n\tcase INSN_CONFIG_GET_PWM_STATUS:\n\tcase INSN_CONFIG_PWM_SET_PERIOD:\n\tcase INSN_CONFIG_PWM_GET_PERIOD:\n\t\tif (insn->n == 2)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase INSN_CONFIG_SET_GATE_SRC:\n\tcase INSN_CONFIG_GET_GATE_SRC:\n\tcase INSN_CONFIG_SET_CLOCK_SRC:\n\tcase INSN_CONFIG_GET_CLOCK_SRC:\n\tcase INSN_CONFIG_SET_OTHER_SRC:\n\tcase INSN_CONFIG_GET_COUNTER_STATUS:\n\tcase INSN_CONFIG_GET_PWM_OUTPUT:\n\tcase INSN_CONFIG_PWM_SET_H_BRIDGE:\n\tcase INSN_CONFIG_PWM_GET_H_BRIDGE:\n\tcase INSN_CONFIG_GET_HARDWARE_BUFFER_SIZE:\n\t\tif (insn->n == 3)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase INSN_CONFIG_PWM_OUTPUT:\n\tcase INSN_CONFIG_ANALOG_TRIG:\n\tcase INSN_CONFIG_TIMER_1:\n\t\tif (insn->n == 5)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase INSN_CONFIG_DIGITAL_TRIG:\n\t\tif (insn->n == 6)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase INSN_CONFIG_GET_CMD_TIMING_CONSTRAINTS:\n\t\tif (insn->n >= 4)\n\t\t\treturn 0;\n\t\tbreak;\n\t\t \n\tdefault:\n\t\tpr_warn(\"No check for data length of config insn id %i is implemented\\n\",\n\t\t\tdata[0]);\n\t\tpr_warn(\"Add a check to %s in %s\\n\", __func__, __FILE__);\n\t\tpr_warn(\"Assuming n=%i is correct\\n\", insn->n);\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int check_insn_device_config_length(struct comedi_insn *insn,\n\t\t\t\t\t   unsigned int *data)\n{\n\tif (insn->n < 1)\n\t\treturn -EINVAL;\n\n\tswitch (data[0]) {\n\tcase INSN_DEVICE_CONFIG_TEST_ROUTE:\n\tcase INSN_DEVICE_CONFIG_CONNECT_ROUTE:\n\tcase INSN_DEVICE_CONFIG_DISCONNECT_ROUTE:\n\t\tif (insn->n == 3)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase INSN_DEVICE_CONFIG_GET_ROUTES:\n\t\t \n\t\tif (insn->n >= 2)\n\t\t\treturn 0;\n\t\tbreak;\n\t}\n\treturn -EINVAL;\n}\n\n \nstatic int get_valid_routes(struct comedi_device *dev, unsigned int *data)\n{\n\tlockdep_assert_held(&dev->mutex);\n\tdata[1] = dev->get_valid_routes(dev, data[1], data + 2);\n\treturn 0;\n}\n\nstatic int parse_insn(struct comedi_device *dev, struct comedi_insn *insn,\n\t\t      unsigned int *data, void *file)\n{\n\tstruct comedi_subdevice *s;\n\tint ret = 0;\n\tint i;\n\n\tlockdep_assert_held(&dev->mutex);\n\tif (insn->insn & INSN_MASK_SPECIAL) {\n\t\t \n\n\t\tswitch (insn->insn) {\n\t\tcase INSN_GTOD:\n\t\t\t{\n\t\t\t\tstruct timespec64 tv;\n\n\t\t\t\tif (insn->n != 2) {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tktime_get_real_ts64(&tv);\n\t\t\t\t \n\t\t\t\tdata[0] = (unsigned int)tv.tv_sec;\n\t\t\t\tdata[1] = tv.tv_nsec / NSEC_PER_USEC;\n\t\t\t\tret = 2;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase INSN_WAIT:\n\t\t\tif (insn->n != 1 || data[0] >= 100000) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tudelay(data[0] / 1000);\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\tcase INSN_INTTRIG:\n\t\t\tif (insn->n != 1) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (insn->subdev >= dev->n_subdevices) {\n\t\t\t\tdev_dbg(dev->class_dev,\n\t\t\t\t\t\"%d not usable subdevice\\n\",\n\t\t\t\t\tinsn->subdev);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ts = &dev->subdevices[insn->subdev];\n\t\t\tif (!s->async) {\n\t\t\t\tdev_dbg(dev->class_dev, \"no async\\n\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!s->async->inttrig) {\n\t\t\t\tdev_dbg(dev->class_dev, \"no inttrig\\n\");\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret = s->async->inttrig(dev, s, data[0]);\n\t\t\tif (ret >= 0)\n\t\t\t\tret = 1;\n\t\t\tbreak;\n\t\tcase INSN_DEVICE_CONFIG:\n\t\t\tret = check_insn_device_config_length(insn, data);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\tif (data[0] == INSN_DEVICE_CONFIG_GET_ROUTES) {\n\t\t\t\t \n\t\t\t\tdata[1] = (insn->n - 2) / 2;\n\t\t\t\tret = get_valid_routes(dev, data);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tret = dev->insn_device_config(dev, insn, data);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_dbg(dev->class_dev, \"invalid insn\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t \n\t\tunsigned int maxdata;\n\n\t\tif (insn->subdev >= dev->n_subdevices) {\n\t\t\tdev_dbg(dev->class_dev, \"subdevice %d out of range\\n\",\n\t\t\t\tinsn->subdev);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\ts = &dev->subdevices[insn->subdev];\n\n\t\tif (s->type == COMEDI_SUBD_UNUSED) {\n\t\t\tdev_dbg(dev->class_dev, \"%d not usable subdevice\\n\",\n\t\t\t\tinsn->subdev);\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (s->lock && s->lock != file) {\n\t\t\tdev_dbg(dev->class_dev, \"device locked\\n\");\n\t\t\tret = -EACCES;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = comedi_check_chanlist(s, 1, &insn->chanspec);\n\t\tif (ret < 0) {\n\t\t\tret = -EINVAL;\n\t\t\tdev_dbg(dev->class_dev, \"bad chanspec\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (s->busy) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\ts->busy = parse_insn;\n\t\tswitch (insn->insn) {\n\t\tcase INSN_READ:\n\t\t\tret = s->insn_read(dev, s, insn, data);\n\t\t\tif (ret == -ETIMEDOUT) {\n\t\t\t\tdev_dbg(dev->class_dev,\n\t\t\t\t\t\"subdevice %d read instruction timed out\\n\",\n\t\t\t\t\ts->index);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase INSN_WRITE:\n\t\t\tmaxdata = s->maxdata_list\n\t\t\t    ? s->maxdata_list[CR_CHAN(insn->chanspec)]\n\t\t\t    : s->maxdata;\n\t\t\tfor (i = 0; i < insn->n; ++i) {\n\t\t\t\tif (data[i] > maxdata) {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tdev_dbg(dev->class_dev,\n\t\t\t\t\t\t\"bad data value(s)\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ret == 0) {\n\t\t\t\tret = s->insn_write(dev, s, insn, data);\n\t\t\t\tif (ret == -ETIMEDOUT) {\n\t\t\t\t\tdev_dbg(dev->class_dev,\n\t\t\t\t\t\t\"subdevice %d write instruction timed out\\n\",\n\t\t\t\t\t\ts->index);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase INSN_BITS:\n\t\t\tif (insn->n != 2) {\n\t\t\t\tret = -EINVAL;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tunsigned int orig_mask = data[0];\n\t\t\t\tunsigned int shift = 0;\n\n\t\t\t\tif (s->n_chan <= 32) {\n\t\t\t\t\tshift = CR_CHAN(insn->chanspec);\n\t\t\t\t\tif (shift > 0) {\n\t\t\t\t\t\tinsn->chanspec = 0;\n\t\t\t\t\t\tdata[0] <<= shift;\n\t\t\t\t\t\tdata[1] <<= shift;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tret = s->insn_bits(dev, s, insn, data);\n\t\t\t\tdata[0] = orig_mask;\n\t\t\t\tif (shift > 0)\n\t\t\t\t\tdata[1] >>= shift;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase INSN_CONFIG:\n\t\t\tret = check_insn_config_length(insn, data);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tret = s->insn_config(dev, s, insn, data);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\ts->busy = NULL;\n\t}\n\nout:\n\treturn ret;\n}\n\n \n \n#define MIN_SAMPLES 16\n#define MAX_SAMPLES 65536\nstatic int do_insnlist_ioctl(struct comedi_device *dev,\n\t\t\t     struct comedi_insn *insns,\n\t\t\t     unsigned int n_insns,\n\t\t\t     void *file)\n{\n\tunsigned int *data = NULL;\n\tunsigned int max_n_data_required = MIN_SAMPLES;\n\tint i = 0;\n\tint ret = 0;\n\n\tlockdep_assert_held(&dev->mutex);\n\n\t \n\tfor (i = 0; i < n_insns; ++i) {\n\t\tif (insns[i].n > MAX_SAMPLES) {\n\t\t\tdev_dbg(dev->class_dev,\n\t\t\t\t\"number of samples too large\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\t\tmax_n_data_required = max(max_n_data_required, insns[i].n);\n\t}\n\n\t \n\tdata = kmalloc_array(max_n_data_required, sizeof(unsigned int),\n\t\t\t     GFP_KERNEL);\n\tif (!data) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tfor (i = 0; i < n_insns; ++i) {\n\t\tif (insns[i].insn & INSN_MASK_WRITE) {\n\t\t\tif (copy_from_user(data, insns[i].data,\n\t\t\t\t\t   insns[i].n * sizeof(unsigned int))) {\n\t\t\t\tdev_dbg(dev->class_dev,\n\t\t\t\t\t\"copy_from_user failed\\n\");\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tret = parse_insn(dev, insns + i, data, file);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tif (insns[i].insn & INSN_MASK_READ) {\n\t\t\tif (copy_to_user(insns[i].data, data,\n\t\t\t\t\t insns[i].n * sizeof(unsigned int))) {\n\t\t\t\tdev_dbg(dev->class_dev,\n\t\t\t\t\t\"copy_to_user failed\\n\");\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tif (need_resched())\n\t\t\tschedule();\n\t}\n\nerror:\n\tkfree(data);\n\n\tif (ret < 0)\n\t\treturn ret;\n\treturn i;\n}\n\n \nstatic int do_insn_ioctl(struct comedi_device *dev,\n\t\t\t struct comedi_insn *insn, void *file)\n{\n\tunsigned int *data = NULL;\n\tunsigned int n_data = MIN_SAMPLES;\n\tint ret = 0;\n\n\tlockdep_assert_held(&dev->mutex);\n\n\tn_data = max(n_data, insn->n);\n\n\t \n\tif (insn->n > MAX_SAMPLES) {\n\t\tinsn->n = MAX_SAMPLES;\n\t\tn_data = MAX_SAMPLES;\n\t}\n\n\tdata = kmalloc_array(n_data, sizeof(unsigned int), GFP_KERNEL);\n\tif (!data) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tif (insn->insn & INSN_MASK_WRITE) {\n\t\tif (copy_from_user(data,\n\t\t\t\t   insn->data,\n\t\t\t\t   insn->n * sizeof(unsigned int))) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto error;\n\t\t}\n\t}\n\tret = parse_insn(dev, insn, data, file);\n\tif (ret < 0)\n\t\tgoto error;\n\tif (insn->insn & INSN_MASK_READ) {\n\t\tif (copy_to_user(insn->data,\n\t\t\t\t data,\n\t\t\t\t insn->n * sizeof(unsigned int))) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto error;\n\t\t}\n\t}\n\tret = insn->n;\n\nerror:\n\tkfree(data);\n\n\treturn ret;\n}\n\nstatic int __comedi_get_user_cmd(struct comedi_device *dev,\n\t\t\t\t struct comedi_cmd *cmd)\n{\n\tstruct comedi_subdevice *s;\n\n\tlockdep_assert_held(&dev->mutex);\n\tif (cmd->subdev >= dev->n_subdevices) {\n\t\tdev_dbg(dev->class_dev, \"%d no such subdevice\\n\", cmd->subdev);\n\t\treturn -ENODEV;\n\t}\n\n\ts = &dev->subdevices[cmd->subdev];\n\n\tif (s->type == COMEDI_SUBD_UNUSED) {\n\t\tdev_dbg(dev->class_dev, \"%d not valid subdevice\\n\",\n\t\t\tcmd->subdev);\n\t\treturn -EIO;\n\t}\n\n\tif (!s->do_cmd || !s->do_cmdtest || !s->async) {\n\t\tdev_dbg(dev->class_dev,\n\t\t\t\"subdevice %d does not support commands\\n\",\n\t\t\tcmd->subdev);\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (cmd->chanlist_len > s->len_chanlist) {\n\t\tdev_dbg(dev->class_dev, \"channel/gain list too long %d > %d\\n\",\n\t\t\tcmd->chanlist_len, s->len_chanlist);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (s->subdev_flags & (SDF_CMD_READ | SDF_CMD_WRITE)) {\n\tcase SDF_CMD_READ:\n\t\tcmd->flags &= ~CMDF_WRITE;\n\t\tbreak;\n\tcase SDF_CMD_WRITE:\n\t\tcmd->flags |= CMDF_WRITE;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int __comedi_get_user_chanlist(struct comedi_device *dev,\n\t\t\t\t      struct comedi_subdevice *s,\n\t\t\t\t      unsigned int __user *user_chanlist,\n\t\t\t\t      struct comedi_cmd *cmd)\n{\n\tunsigned int *chanlist;\n\tint ret;\n\n\tlockdep_assert_held(&dev->mutex);\n\tcmd->chanlist = NULL;\n\tchanlist = memdup_user(user_chanlist,\n\t\t\t       cmd->chanlist_len * sizeof(unsigned int));\n\tif (IS_ERR(chanlist))\n\t\treturn PTR_ERR(chanlist);\n\n\t \n\tret = comedi_check_chanlist(s, cmd->chanlist_len, chanlist);\n\tif (ret < 0) {\n\t\tkfree(chanlist);\n\t\treturn ret;\n\t}\n\n\tcmd->chanlist = chanlist;\n\n\treturn 0;\n}\n\n \nstatic int do_cmd_ioctl(struct comedi_device *dev,\n\t\t\tstruct comedi_cmd *cmd, bool *copy, void *file)\n{\n\tstruct comedi_subdevice *s;\n\tstruct comedi_async *async;\n\tunsigned int __user *user_chanlist;\n\tint ret;\n\n\tlockdep_assert_held(&dev->mutex);\n\n\t \n\tret = __comedi_get_user_cmd(dev, cmd);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tuser_chanlist = (unsigned int __user *)cmd->chanlist;\n\n\ts = &dev->subdevices[cmd->subdev];\n\tasync = s->async;\n\n\t \n\tif (s->lock && s->lock != file) {\n\t\tdev_dbg(dev->class_dev, \"subdevice locked\\n\");\n\t\treturn -EACCES;\n\t}\n\n\t \n\tif (s->busy) {\n\t\tdev_dbg(dev->class_dev, \"subdevice busy\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tif (cmd->chanlist_len < 1) {\n\t\tdev_dbg(dev->class_dev, \"channel/gain list too short %u < 1\\n\",\n\t\t\tcmd->chanlist_len);\n\t\treturn -EINVAL;\n\t}\n\n\tasync->cmd = *cmd;\n\tasync->cmd.data = NULL;\n\n\t \n\tret = __comedi_get_user_chanlist(dev, s, user_chanlist, &async->cmd);\n\tif (ret)\n\t\tgoto cleanup;\n\n\tret = s->do_cmdtest(dev, s, &async->cmd);\n\n\tif (async->cmd.flags & CMDF_BOGUS || ret) {\n\t\tdev_dbg(dev->class_dev, \"test returned %d\\n\", ret);\n\t\t*cmd = async->cmd;\n\t\t \n\t\tcmd->chanlist = (unsigned int __force *)user_chanlist;\n\t\tcmd->data = NULL;\n\t\t*copy = true;\n\t\tret = -EAGAIN;\n\t\tgoto cleanup;\n\t}\n\n\tif (!async->prealloc_bufsz) {\n\t\tret = -ENOMEM;\n\t\tdev_dbg(dev->class_dev, \"no buffer (?)\\n\");\n\t\tgoto cleanup;\n\t}\n\n\tcomedi_buf_reset(s);\n\n\tasync->cb_mask = COMEDI_CB_BLOCK | COMEDI_CB_CANCEL_MASK;\n\tif (async->cmd.flags & CMDF_WAKE_EOS)\n\t\tasync->cb_mask |= COMEDI_CB_EOS;\n\n\tcomedi_update_subdevice_runflags(s, COMEDI_SRF_BUSY_MASK,\n\t\t\t\t\t COMEDI_SRF_RUNNING);\n\n\t \n\ts->busy = file;\n\tret = s->do_cmd(dev, s);\n\tif (ret == 0)\n\t\treturn 0;\n\ncleanup:\n\tdo_become_nonbusy(dev, s);\n\n\treturn ret;\n}\n\n \nstatic int do_cmdtest_ioctl(struct comedi_device *dev,\n\t\t\t    struct comedi_cmd *cmd, bool *copy, void *file)\n{\n\tstruct comedi_subdevice *s;\n\tunsigned int __user *user_chanlist;\n\tint ret;\n\n\tlockdep_assert_held(&dev->mutex);\n\n\t \n\tret = __comedi_get_user_cmd(dev, cmd);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tuser_chanlist = (unsigned int __user *)cmd->chanlist;\n\n\ts = &dev->subdevices[cmd->subdev];\n\n\t \n\tif (user_chanlist) {\n\t\t \n\t\tret = __comedi_get_user_chanlist(dev, s, user_chanlist, cmd);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = s->do_cmdtest(dev, s, cmd);\n\n\tkfree(cmd->chanlist);\t \n\n\t \n\tcmd->chanlist = (unsigned int __force *)user_chanlist;\n\t*copy = true;\n\n\treturn ret;\n}\n\n \nstatic int do_lock_ioctl(struct comedi_device *dev, unsigned long arg,\n\t\t\t void *file)\n{\n\tint ret = 0;\n\tunsigned long flags;\n\tstruct comedi_subdevice *s;\n\n\tlockdep_assert_held(&dev->mutex);\n\tif (arg >= dev->n_subdevices)\n\t\treturn -EINVAL;\n\ts = &dev->subdevices[arg];\n\n\tspin_lock_irqsave(&s->spin_lock, flags);\n\tif (s->busy || s->lock)\n\t\tret = -EBUSY;\n\telse\n\t\ts->lock = file;\n\tspin_unlock_irqrestore(&s->spin_lock, flags);\n\n\treturn ret;\n}\n\n \nstatic int do_unlock_ioctl(struct comedi_device *dev, unsigned long arg,\n\t\t\t   void *file)\n{\n\tstruct comedi_subdevice *s;\n\n\tlockdep_assert_held(&dev->mutex);\n\tif (arg >= dev->n_subdevices)\n\t\treturn -EINVAL;\n\ts = &dev->subdevices[arg];\n\n\tif (s->busy)\n\t\treturn -EBUSY;\n\n\tif (s->lock && s->lock != file)\n\t\treturn -EACCES;\n\n\tif (s->lock == file)\n\t\ts->lock = NULL;\n\n\treturn 0;\n}\n\n \nstatic int do_cancel_ioctl(struct comedi_device *dev, unsigned long arg,\n\t\t\t   void *file)\n{\n\tstruct comedi_subdevice *s;\n\n\tlockdep_assert_held(&dev->mutex);\n\tif (arg >= dev->n_subdevices)\n\t\treturn -EINVAL;\n\ts = &dev->subdevices[arg];\n\tif (!s->async)\n\t\treturn -EINVAL;\n\n\tif (!s->busy)\n\t\treturn 0;\n\n\tif (s->busy != file)\n\t\treturn -EBUSY;\n\n\treturn do_cancel(dev, s);\n}\n\n \nstatic int do_poll_ioctl(struct comedi_device *dev, unsigned long arg,\n\t\t\t void *file)\n{\n\tstruct comedi_subdevice *s;\n\n\tlockdep_assert_held(&dev->mutex);\n\tif (arg >= dev->n_subdevices)\n\t\treturn -EINVAL;\n\ts = &dev->subdevices[arg];\n\n\tif (!s->busy)\n\t\treturn 0;\n\n\tif (s->busy != file)\n\t\treturn -EBUSY;\n\n\tif (s->poll)\n\t\treturn s->poll(dev, s);\n\n\treturn -EINVAL;\n}\n\n \nstatic int do_setrsubd_ioctl(struct comedi_device *dev, unsigned long arg,\n\t\t\t     struct file *file)\n{\n\tstruct comedi_file *cfp = file->private_data;\n\tstruct comedi_subdevice *s_old, *s_new;\n\n\tlockdep_assert_held(&dev->mutex);\n\tif (arg >= dev->n_subdevices)\n\t\treturn -EINVAL;\n\n\ts_new = &dev->subdevices[arg];\n\ts_old = comedi_file_read_subdevice(file);\n\tif (s_old == s_new)\n\t\treturn 0;\t \n\n\tif (!(s_new->subdev_flags & SDF_CMD_READ))\n\t\treturn -EINVAL;\n\n\t \n\tif (s_old && s_old->busy == file && s_old->async &&\n\t    !(s_old->async->cmd.flags & CMDF_WRITE))\n\t\treturn -EBUSY;\n\n\tWRITE_ONCE(cfp->read_subdev, s_new);\n\treturn 0;\n}\n\n \nstatic int do_setwsubd_ioctl(struct comedi_device *dev, unsigned long arg,\n\t\t\t     struct file *file)\n{\n\tstruct comedi_file *cfp = file->private_data;\n\tstruct comedi_subdevice *s_old, *s_new;\n\n\tlockdep_assert_held(&dev->mutex);\n\tif (arg >= dev->n_subdevices)\n\t\treturn -EINVAL;\n\n\ts_new = &dev->subdevices[arg];\n\ts_old = comedi_file_write_subdevice(file);\n\tif (s_old == s_new)\n\t\treturn 0;\t \n\n\tif (!(s_new->subdev_flags & SDF_CMD_WRITE))\n\t\treturn -EINVAL;\n\n\t \n\tif (s_old && s_old->busy == file && s_old->async &&\n\t    (s_old->async->cmd.flags & CMDF_WRITE))\n\t\treturn -EBUSY;\n\n\tWRITE_ONCE(cfp->write_subdev, s_new);\n\treturn 0;\n}\n\nstatic long comedi_unlocked_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t  unsigned long arg)\n{\n\tunsigned int minor = iminor(file_inode(file));\n\tstruct comedi_file *cfp = file->private_data;\n\tstruct comedi_device *dev = cfp->dev;\n\tint rc;\n\n\tmutex_lock(&dev->mutex);\n\n\t \n\tif (cmd == COMEDI_DEVCONFIG) {\n\t\tif (minor >= COMEDI_NUM_BOARD_MINORS) {\n\t\t\t \n\t\t\trc = -ENOTTY;\n\t\t\tgoto done;\n\t\t}\n\t\trc = do_devconfig_ioctl(dev,\n\t\t\t\t\t(struct comedi_devconfig __user *)arg);\n\t\tif (rc == 0) {\n\t\t\tif (arg == 0 &&\n\t\t\t    dev->minor >= comedi_num_legacy_minors) {\n\t\t\t\t \n\t\t\t\tif (comedi_clear_board_dev(dev)) {\n\t\t\t\t\tmutex_unlock(&dev->mutex);\n\t\t\t\t\tcomedi_free_board_dev(dev);\n\t\t\t\t\treturn rc;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\n\tif (!dev->attached) {\n\t\tdev_dbg(dev->class_dev, \"no driver attached\\n\");\n\t\trc = -ENODEV;\n\t\tgoto done;\n\t}\n\n\tswitch (cmd) {\n\tcase COMEDI_BUFCONFIG:\n\t\trc = do_bufconfig_ioctl(dev,\n\t\t\t\t\t(struct comedi_bufconfig __user *)arg);\n\t\tbreak;\n\tcase COMEDI_DEVINFO:\n\t\trc = do_devinfo_ioctl(dev, (struct comedi_devinfo __user *)arg,\n\t\t\t\t      file);\n\t\tbreak;\n\tcase COMEDI_SUBDINFO:\n\t\trc = do_subdinfo_ioctl(dev,\n\t\t\t\t       (struct comedi_subdinfo __user *)arg,\n\t\t\t\t       file);\n\t\tbreak;\n\tcase COMEDI_CHANINFO: {\n\t\tstruct comedi_chaninfo it;\n\n\t\tif (copy_from_user(&it, (void __user *)arg, sizeof(it)))\n\t\t\trc = -EFAULT;\n\t\telse\n\t\t\trc = do_chaninfo_ioctl(dev, &it);\n\t\tbreak;\n\t}\n\tcase COMEDI_RANGEINFO: {\n\t\tstruct comedi_rangeinfo it;\n\n\t\tif (copy_from_user(&it, (void __user *)arg, sizeof(it)))\n\t\t\trc = -EFAULT;\n\t\telse\n\t\t\trc = do_rangeinfo_ioctl(dev, &it);\n\t\tbreak;\n\t}\n\tcase COMEDI_BUFINFO:\n\t\trc = do_bufinfo_ioctl(dev,\n\t\t\t\t      (struct comedi_bufinfo __user *)arg,\n\t\t\t\t      file);\n\t\tbreak;\n\tcase COMEDI_LOCK:\n\t\trc = do_lock_ioctl(dev, arg, file);\n\t\tbreak;\n\tcase COMEDI_UNLOCK:\n\t\trc = do_unlock_ioctl(dev, arg, file);\n\t\tbreak;\n\tcase COMEDI_CANCEL:\n\t\trc = do_cancel_ioctl(dev, arg, file);\n\t\tbreak;\n\tcase COMEDI_CMD: {\n\t\tstruct comedi_cmd cmd;\n\t\tbool copy = false;\n\n\t\tif (copy_from_user(&cmd, (void __user *)arg, sizeof(cmd))) {\n\t\t\trc = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\trc = do_cmd_ioctl(dev, &cmd, &copy, file);\n\t\tif (copy && copy_to_user((void __user *)arg, &cmd, sizeof(cmd)))\n\t\t\trc = -EFAULT;\n\t\tbreak;\n\t}\n\tcase COMEDI_CMDTEST: {\n\t\tstruct comedi_cmd cmd;\n\t\tbool copy = false;\n\n\t\tif (copy_from_user(&cmd, (void __user *)arg, sizeof(cmd))) {\n\t\t\trc = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\trc = do_cmdtest_ioctl(dev, &cmd, &copy, file);\n\t\tif (copy && copy_to_user((void __user *)arg, &cmd, sizeof(cmd)))\n\t\t\trc = -EFAULT;\n\t\tbreak;\n\t}\n\tcase COMEDI_INSNLIST: {\n\t\tstruct comedi_insnlist insnlist;\n\t\tstruct comedi_insn *insns = NULL;\n\n\t\tif (copy_from_user(&insnlist, (void __user *)arg,\n\t\t\t\t   sizeof(insnlist))) {\n\t\t\trc = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tinsns = kcalloc(insnlist.n_insns, sizeof(*insns), GFP_KERNEL);\n\t\tif (!insns) {\n\t\t\trc = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\tif (copy_from_user(insns, insnlist.insns,\n\t\t\t\t   sizeof(*insns) * insnlist.n_insns)) {\n\t\t\trc = -EFAULT;\n\t\t\tkfree(insns);\n\t\t\tbreak;\n\t\t}\n\t\trc = do_insnlist_ioctl(dev, insns, insnlist.n_insns, file);\n\t\tkfree(insns);\n\t\tbreak;\n\t}\n\tcase COMEDI_INSN: {\n\t\tstruct comedi_insn insn;\n\n\t\tif (copy_from_user(&insn, (void __user *)arg, sizeof(insn)))\n\t\t\trc = -EFAULT;\n\t\telse\n\t\t\trc = do_insn_ioctl(dev, &insn, file);\n\t\tbreak;\n\t}\n\tcase COMEDI_POLL:\n\t\trc = do_poll_ioctl(dev, arg, file);\n\t\tbreak;\n\tcase COMEDI_SETRSUBD:\n\t\trc = do_setrsubd_ioctl(dev, arg, file);\n\t\tbreak;\n\tcase COMEDI_SETWSUBD:\n\t\trc = do_setwsubd_ioctl(dev, arg, file);\n\t\tbreak;\n\tdefault:\n\t\trc = -ENOTTY;\n\t\tbreak;\n\t}\n\ndone:\n\tmutex_unlock(&dev->mutex);\n\treturn rc;\n}\n\nstatic void comedi_vm_open(struct vm_area_struct *area)\n{\n\tstruct comedi_buf_map *bm;\n\n\tbm = area->vm_private_data;\n\tcomedi_buf_map_get(bm);\n}\n\nstatic void comedi_vm_close(struct vm_area_struct *area)\n{\n\tstruct comedi_buf_map *bm;\n\n\tbm = area->vm_private_data;\n\tcomedi_buf_map_put(bm);\n}\n\nstatic int comedi_vm_access(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t    void *buf, int len, int write)\n{\n\tstruct comedi_buf_map *bm = vma->vm_private_data;\n\tunsigned long offset =\n\t    addr - vma->vm_start + (vma->vm_pgoff << PAGE_SHIFT);\n\n\tif (len < 0)\n\t\treturn -EINVAL;\n\tif (len > vma->vm_end - addr)\n\t\tlen = vma->vm_end - addr;\n\treturn comedi_buf_map_access(bm, offset, buf, len, write);\n}\n\nstatic const struct vm_operations_struct comedi_vm_ops = {\n\t.open = comedi_vm_open,\n\t.close = comedi_vm_close,\n\t.access = comedi_vm_access,\n};\n\nstatic int comedi_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct comedi_file *cfp = file->private_data;\n\tstruct comedi_device *dev = cfp->dev;\n\tstruct comedi_subdevice *s;\n\tstruct comedi_async *async;\n\tstruct comedi_buf_map *bm = NULL;\n\tstruct comedi_buf_page *buf;\n\tunsigned long start = vma->vm_start;\n\tunsigned long size;\n\tint n_pages;\n\tint i;\n\tint retval = 0;\n\n\t \n\tif (!down_read_trylock(&dev->attach_lock))\n\t\treturn -EAGAIN;\n\n\tif (!dev->attached) {\n\t\tdev_dbg(dev->class_dev, \"no driver attached\\n\");\n\t\tretval = -ENODEV;\n\t\tgoto done;\n\t}\n\n\tif (vma->vm_flags & VM_WRITE)\n\t\ts = comedi_file_write_subdevice(file);\n\telse\n\t\ts = comedi_file_read_subdevice(file);\n\tif (!s) {\n\t\tretval = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tasync = s->async;\n\tif (!async) {\n\t\tretval = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tif (vma->vm_pgoff != 0) {\n\t\tdev_dbg(dev->class_dev, \"mmap() offset must be 0.\\n\");\n\t\tretval = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tsize = vma->vm_end - vma->vm_start;\n\tif (size > async->prealloc_bufsz) {\n\t\tretval = -EFAULT;\n\t\tgoto done;\n\t}\n\tif (offset_in_page(size)) {\n\t\tretval = -EFAULT;\n\t\tgoto done;\n\t}\n\n\tn_pages = vma_pages(vma);\n\n\t \n\tbm = comedi_buf_map_from_subdev_get(s);\n\tif (!bm || n_pages > bm->n_pages) {\n\t\tretval = -EINVAL;\n\t\tgoto done;\n\t}\n\tif (bm->dma_dir != DMA_NONE) {\n\t\t \n\t\tbuf = &bm->page_list[0];\n\t\tretval = dma_mmap_coherent(bm->dma_hw_dev, vma, buf->virt_addr,\n\t\t\t\t\t   buf->dma_addr, n_pages * PAGE_SIZE);\n\t} else {\n\t\tfor (i = 0; i < n_pages; ++i) {\n\t\t\tunsigned long pfn;\n\n\t\t\tbuf = &bm->page_list[i];\n\t\t\tpfn = page_to_pfn(virt_to_page(buf->virt_addr));\n\t\t\tretval = remap_pfn_range(vma, start, pfn, PAGE_SIZE,\n\t\t\t\t\t\t PAGE_SHARED);\n\t\t\tif (retval)\n\t\t\t\tbreak;\n\n\t\t\tstart += PAGE_SIZE;\n\t\t}\n\t}\n\n\tif (retval == 0) {\n\t\tvma->vm_ops = &comedi_vm_ops;\n\t\tvma->vm_private_data = bm;\n\n\t\tvma->vm_ops->open(vma);\n\t}\n\ndone:\n\tup_read(&dev->attach_lock);\n\tcomedi_buf_map_put(bm);\t \n\treturn retval;\n}\n\nstatic __poll_t comedi_poll(struct file *file, poll_table *wait)\n{\n\t__poll_t mask = 0;\n\tstruct comedi_file *cfp = file->private_data;\n\tstruct comedi_device *dev = cfp->dev;\n\tstruct comedi_subdevice *s, *s_read;\n\n\tdown_read(&dev->attach_lock);\n\n\tif (!dev->attached) {\n\t\tdev_dbg(dev->class_dev, \"no driver attached\\n\");\n\t\tgoto done;\n\t}\n\n\ts = comedi_file_read_subdevice(file);\n\ts_read = s;\n\tif (s && s->async) {\n\t\tpoll_wait(file, &s->async->wait_head, wait);\n\t\tif (s->busy != file || !comedi_is_subdevice_running(s) ||\n\t\t    (s->async->cmd.flags & CMDF_WRITE) ||\n\t\t    comedi_buf_read_n_available(s) > 0)\n\t\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\t}\n\n\ts = comedi_file_write_subdevice(file);\n\tif (s && s->async) {\n\t\tunsigned int bps = comedi_bytes_per_sample(s);\n\n\t\tif (s != s_read)\n\t\t\tpoll_wait(file, &s->async->wait_head, wait);\n\t\tif (s->busy != file || !comedi_is_subdevice_running(s) ||\n\t\t    !(s->async->cmd.flags & CMDF_WRITE) ||\n\t\t    comedi_buf_write_n_available(s) >= bps)\n\t\t\tmask |= EPOLLOUT | EPOLLWRNORM;\n\t}\n\ndone:\n\tup_read(&dev->attach_lock);\n\treturn mask;\n}\n\nstatic ssize_t comedi_write(struct file *file, const char __user *buf,\n\t\t\t    size_t nbytes, loff_t *offset)\n{\n\tstruct comedi_subdevice *s;\n\tstruct comedi_async *async;\n\tunsigned int n, m;\n\tssize_t count = 0;\n\tint retval = 0;\n\tDECLARE_WAITQUEUE(wait, current);\n\tstruct comedi_file *cfp = file->private_data;\n\tstruct comedi_device *dev = cfp->dev;\n\tbool become_nonbusy = false;\n\tbool attach_locked;\n\tunsigned int old_detach_count;\n\n\t \n\tdown_read(&dev->attach_lock);\n\tattach_locked = true;\n\told_detach_count = dev->detach_count;\n\n\tif (!dev->attached) {\n\t\tdev_dbg(dev->class_dev, \"no driver attached\\n\");\n\t\tretval = -ENODEV;\n\t\tgoto out;\n\t}\n\n\ts = comedi_file_write_subdevice(file);\n\tif (!s || !s->async) {\n\t\tretval = -EIO;\n\t\tgoto out;\n\t}\n\n\tasync = s->async;\n\tif (s->busy != file || !(async->cmd.flags & CMDF_WRITE)) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tadd_wait_queue(&async->wait_head, &wait);\n\twhile (count == 0 && !retval) {\n\t\tunsigned int runflags;\n\t\tunsigned int wp, n1, n2;\n\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t\trunflags = comedi_get_subdevice_runflags(s);\n\t\tif (!comedi_is_runflags_running(runflags)) {\n\t\t\tif (comedi_is_runflags_in_error(runflags))\n\t\t\t\tretval = -EPIPE;\n\t\t\tif (retval || nbytes)\n\t\t\t\tbecome_nonbusy = true;\n\t\t\tbreak;\n\t\t}\n\t\tif (nbytes == 0)\n\t\t\tbreak;\n\n\t\t \n\t\tcomedi_buf_write_alloc(s, async->prealloc_bufsz);\n\t\tm = comedi_buf_write_n_allocated(s);\n\t\tn = min_t(size_t, m, nbytes);\n\n\t\tif (n == 0) {\n\t\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\t\tretval = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tschedule();\n\t\t\tif (signal_pending(current)) {\n\t\t\t\tretval = -ERESTARTSYS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (s->busy != file ||\n\t\t\t    !(async->cmd.flags & CMDF_WRITE)) {\n\t\t\t\tretval = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_current_state(TASK_RUNNING);\n\t\twp = async->buf_write_ptr;\n\t\tn1 = min(n, async->prealloc_bufsz - wp);\n\t\tn2 = n - n1;\n\t\tm = copy_from_user(async->prealloc_buf + wp, buf, n1);\n\t\tif (m)\n\t\t\tm += n2;\n\t\telse if (n2)\n\t\t\tm = copy_from_user(async->prealloc_buf, buf + n1, n2);\n\t\tif (m) {\n\t\t\tn -= m;\n\t\t\tretval = -EFAULT;\n\t\t}\n\t\tcomedi_buf_write_free(s, n);\n\n\t\tcount += n;\n\t\tnbytes -= n;\n\n\t\tbuf += n;\n\t}\n\tremove_wait_queue(&async->wait_head, &wait);\n\tset_current_state(TASK_RUNNING);\n\tif (become_nonbusy && count == 0) {\n\t\tstruct comedi_subdevice *new_s;\n\n\t\t \n\t\tup_read(&dev->attach_lock);\n\t\tattach_locked = false;\n\t\tmutex_lock(&dev->mutex);\n\t\t \n\t\tnew_s = comedi_file_write_subdevice(file);\n\t\tif (dev->attached && old_detach_count == dev->detach_count &&\n\t\t    s == new_s && new_s->async == async && s->busy == file &&\n\t\t    (async->cmd.flags & CMDF_WRITE) &&\n\t\t    !comedi_is_subdevice_running(s))\n\t\t\tdo_become_nonbusy(dev, s);\n\t\tmutex_unlock(&dev->mutex);\n\t}\nout:\n\tif (attach_locked)\n\t\tup_read(&dev->attach_lock);\n\n\treturn count ? count : retval;\n}\n\nstatic ssize_t comedi_read(struct file *file, char __user *buf, size_t nbytes,\n\t\t\t   loff_t *offset)\n{\n\tstruct comedi_subdevice *s;\n\tstruct comedi_async *async;\n\tunsigned int n, m;\n\tssize_t count = 0;\n\tint retval = 0;\n\tDECLARE_WAITQUEUE(wait, current);\n\tstruct comedi_file *cfp = file->private_data;\n\tstruct comedi_device *dev = cfp->dev;\n\tunsigned int old_detach_count;\n\tbool become_nonbusy = false;\n\tbool attach_locked;\n\n\t \n\tdown_read(&dev->attach_lock);\n\tattach_locked = true;\n\told_detach_count = dev->detach_count;\n\n\tif (!dev->attached) {\n\t\tdev_dbg(dev->class_dev, \"no driver attached\\n\");\n\t\tretval = -ENODEV;\n\t\tgoto out;\n\t}\n\n\ts = comedi_file_read_subdevice(file);\n\tif (!s || !s->async) {\n\t\tretval = -EIO;\n\t\tgoto out;\n\t}\n\n\tasync = s->async;\n\tif (s->busy != file || (async->cmd.flags & CMDF_WRITE)) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tadd_wait_queue(&async->wait_head, &wait);\n\twhile (count == 0 && !retval) {\n\t\tunsigned int rp, n1, n2;\n\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t\tm = comedi_buf_read_n_available(s);\n\t\tn = min_t(size_t, m, nbytes);\n\n\t\tif (n == 0) {\n\t\t\tunsigned int runflags =\n\t\t\t\t     comedi_get_subdevice_runflags(s);\n\n\t\t\tif (!comedi_is_runflags_running(runflags)) {\n\t\t\t\tif (comedi_is_runflags_in_error(runflags))\n\t\t\t\t\tretval = -EPIPE;\n\t\t\t\tif (retval || nbytes)\n\t\t\t\t\tbecome_nonbusy = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (nbytes == 0)\n\t\t\t\tbreak;\n\t\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\t\tretval = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tschedule();\n\t\t\tif (signal_pending(current)) {\n\t\t\t\tretval = -ERESTARTSYS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (s->busy != file ||\n\t\t\t    (async->cmd.flags & CMDF_WRITE)) {\n\t\t\t\tretval = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_current_state(TASK_RUNNING);\n\t\trp = async->buf_read_ptr;\n\t\tn1 = min(n, async->prealloc_bufsz - rp);\n\t\tn2 = n - n1;\n\t\tm = copy_to_user(buf, async->prealloc_buf + rp, n1);\n\t\tif (m)\n\t\t\tm += n2;\n\t\telse if (n2)\n\t\t\tm = copy_to_user(buf + n1, async->prealloc_buf, n2);\n\t\tif (m) {\n\t\t\tn -= m;\n\t\t\tretval = -EFAULT;\n\t\t}\n\n\t\tcomedi_buf_read_alloc(s, n);\n\t\tcomedi_buf_read_free(s, n);\n\n\t\tcount += n;\n\t\tnbytes -= n;\n\n\t\tbuf += n;\n\t}\n\tremove_wait_queue(&async->wait_head, &wait);\n\tset_current_state(TASK_RUNNING);\n\tif (become_nonbusy && count == 0) {\n\t\tstruct comedi_subdevice *new_s;\n\n\t\t \n\t\tup_read(&dev->attach_lock);\n\t\tattach_locked = false;\n\t\tmutex_lock(&dev->mutex);\n\t\t \n\t\tnew_s = comedi_file_read_subdevice(file);\n\t\tif (dev->attached && old_detach_count == dev->detach_count &&\n\t\t    s == new_s && new_s->async == async && s->busy == file &&\n\t\t    !(async->cmd.flags & CMDF_WRITE) &&\n\t\t    !comedi_is_subdevice_running(s) &&\n\t\t    comedi_buf_read_n_available(s) == 0)\n\t\t\tdo_become_nonbusy(dev, s);\n\t\tmutex_unlock(&dev->mutex);\n\t}\nout:\n\tif (attach_locked)\n\t\tup_read(&dev->attach_lock);\n\n\treturn count ? count : retval;\n}\n\nstatic int comedi_open(struct inode *inode, struct file *file)\n{\n\tconst unsigned int minor = iminor(inode);\n\tstruct comedi_file *cfp;\n\tstruct comedi_device *dev = comedi_dev_get_from_minor(minor);\n\tint rc;\n\n\tif (!dev) {\n\t\tpr_debug(\"invalid minor number\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tcfp = kzalloc(sizeof(*cfp), GFP_KERNEL);\n\tif (!cfp) {\n\t\tcomedi_dev_put(dev);\n\t\treturn -ENOMEM;\n\t}\n\n\tcfp->dev = dev;\n\n\tmutex_lock(&dev->mutex);\n\tif (!dev->attached && !capable(CAP_SYS_ADMIN)) {\n\t\tdev_dbg(dev->class_dev, \"not attached and not CAP_SYS_ADMIN\\n\");\n\t\trc = -ENODEV;\n\t\tgoto out;\n\t}\n\tif (dev->attached && dev->use_count == 0) {\n\t\tif (!try_module_get(dev->driver->module)) {\n\t\t\trc = -ENXIO;\n\t\t\tgoto out;\n\t\t}\n\t\tif (dev->open) {\n\t\t\trc = dev->open(dev);\n\t\t\tif (rc < 0) {\n\t\t\t\tmodule_put(dev->driver->module);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tdev->use_count++;\n\tfile->private_data = cfp;\n\tcomedi_file_reset(file);\n\trc = 0;\n\nout:\n\tmutex_unlock(&dev->mutex);\n\tif (rc) {\n\t\tcomedi_dev_put(dev);\n\t\tkfree(cfp);\n\t}\n\treturn rc;\n}\n\nstatic int comedi_fasync(int fd, struct file *file, int on)\n{\n\tstruct comedi_file *cfp = file->private_data;\n\tstruct comedi_device *dev = cfp->dev;\n\n\treturn fasync_helper(fd, file, on, &dev->async_queue);\n}\n\nstatic int comedi_close(struct inode *inode, struct file *file)\n{\n\tstruct comedi_file *cfp = file->private_data;\n\tstruct comedi_device *dev = cfp->dev;\n\tstruct comedi_subdevice *s = NULL;\n\tint i;\n\n\tmutex_lock(&dev->mutex);\n\n\tif (dev->subdevices) {\n\t\tfor (i = 0; i < dev->n_subdevices; i++) {\n\t\t\ts = &dev->subdevices[i];\n\n\t\t\tif (s->busy == file)\n\t\t\t\tdo_cancel(dev, s);\n\t\t\tif (s->lock == file)\n\t\t\t\ts->lock = NULL;\n\t\t}\n\t}\n\tif (dev->attached && dev->use_count == 1) {\n\t\tif (dev->close)\n\t\t\tdev->close(dev);\n\t\tmodule_put(dev->driver->module);\n\t}\n\n\tdev->use_count--;\n\n\tmutex_unlock(&dev->mutex);\n\tcomedi_dev_put(dev);\n\tkfree(cfp);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_COMPAT\n\n#define COMEDI32_CHANINFO _IOR(CIO, 3, struct comedi32_chaninfo_struct)\n#define COMEDI32_RANGEINFO _IOR(CIO, 8, struct comedi32_rangeinfo_struct)\n \n#define COMEDI32_CMD _IOR(CIO, 9, struct comedi32_cmd_struct)\n \n#define COMEDI32_CMDTEST _IOR(CIO, 10, struct comedi32_cmd_struct)\n#define COMEDI32_INSNLIST _IOR(CIO, 11, struct comedi32_insnlist_struct)\n#define COMEDI32_INSN _IOR(CIO, 12, struct comedi32_insn_struct)\n\nstruct comedi32_chaninfo_struct {\n\tunsigned int subdev;\n\tcompat_uptr_t maxdata_list;\t \n\tcompat_uptr_t flaglist;\t \n\tcompat_uptr_t rangelist;\t \n\tunsigned int unused[4];\n};\n\nstruct comedi32_rangeinfo_struct {\n\tunsigned int range_type;\n\tcompat_uptr_t range_ptr;\t \n};\n\nstruct comedi32_cmd_struct {\n\tunsigned int subdev;\n\tunsigned int flags;\n\tunsigned int start_src;\n\tunsigned int start_arg;\n\tunsigned int scan_begin_src;\n\tunsigned int scan_begin_arg;\n\tunsigned int convert_src;\n\tunsigned int convert_arg;\n\tunsigned int scan_end_src;\n\tunsigned int scan_end_arg;\n\tunsigned int stop_src;\n\tunsigned int stop_arg;\n\tcompat_uptr_t chanlist;\t \n\tunsigned int chanlist_len;\n\tcompat_uptr_t data;\t \n\tunsigned int data_len;\n};\n\nstruct comedi32_insn_struct {\n\tunsigned int insn;\n\tunsigned int n;\n\tcompat_uptr_t data;\t \n\tunsigned int subdev;\n\tunsigned int chanspec;\n\tunsigned int unused[3];\n};\n\nstruct comedi32_insnlist_struct {\n\tunsigned int n_insns;\n\tcompat_uptr_t insns;\t \n};\n\n \nstatic int compat_chaninfo(struct file *file, unsigned long arg)\n{\n\tstruct comedi_file *cfp = file->private_data;\n\tstruct comedi_device *dev = cfp->dev;\n\tstruct comedi32_chaninfo_struct chaninfo32;\n\tstruct comedi_chaninfo chaninfo;\n\tint err;\n\n\tif (copy_from_user(&chaninfo32, compat_ptr(arg), sizeof(chaninfo32)))\n\t\treturn -EFAULT;\n\n\tmemset(&chaninfo, 0, sizeof(chaninfo));\n\tchaninfo.subdev = chaninfo32.subdev;\n\tchaninfo.maxdata_list = compat_ptr(chaninfo32.maxdata_list);\n\tchaninfo.flaglist = compat_ptr(chaninfo32.flaglist);\n\tchaninfo.rangelist = compat_ptr(chaninfo32.rangelist);\n\n\tmutex_lock(&dev->mutex);\n\terr = do_chaninfo_ioctl(dev, &chaninfo);\n\tmutex_unlock(&dev->mutex);\n\treturn err;\n}\n\n \nstatic int compat_rangeinfo(struct file *file, unsigned long arg)\n{\n\tstruct comedi_file *cfp = file->private_data;\n\tstruct comedi_device *dev = cfp->dev;\n\tstruct comedi32_rangeinfo_struct rangeinfo32;\n\tstruct comedi_rangeinfo rangeinfo;\n\tint err;\n\n\tif (copy_from_user(&rangeinfo32, compat_ptr(arg), sizeof(rangeinfo32)))\n\t\treturn -EFAULT;\n\tmemset(&rangeinfo, 0, sizeof(rangeinfo));\n\trangeinfo.range_type = rangeinfo32.range_type;\n\trangeinfo.range_ptr = compat_ptr(rangeinfo32.range_ptr);\n\n\tmutex_lock(&dev->mutex);\n\terr = do_rangeinfo_ioctl(dev, &rangeinfo);\n\tmutex_unlock(&dev->mutex);\n\treturn err;\n}\n\n \nstatic int get_compat_cmd(struct comedi_cmd *cmd,\n\t\t\t  struct comedi32_cmd_struct __user *cmd32)\n{\n\tstruct comedi32_cmd_struct v32;\n\n\tif (copy_from_user(&v32, cmd32, sizeof(v32)))\n\t\treturn -EFAULT;\n\n\tcmd->subdev = v32.subdev;\n\tcmd->flags = v32.flags;\n\tcmd->start_src = v32.start_src;\n\tcmd->start_arg = v32.start_arg;\n\tcmd->scan_begin_src = v32.scan_begin_src;\n\tcmd->scan_begin_arg = v32.scan_begin_arg;\n\tcmd->convert_src = v32.convert_src;\n\tcmd->convert_arg = v32.convert_arg;\n\tcmd->scan_end_src = v32.scan_end_src;\n\tcmd->scan_end_arg = v32.scan_end_arg;\n\tcmd->stop_src = v32.stop_src;\n\tcmd->stop_arg = v32.stop_arg;\n\tcmd->chanlist = (unsigned int __force *)compat_ptr(v32.chanlist);\n\tcmd->chanlist_len = v32.chanlist_len;\n\tcmd->data = compat_ptr(v32.data);\n\tcmd->data_len = v32.data_len;\n\treturn 0;\n}\n\n \nstatic int put_compat_cmd(struct comedi32_cmd_struct __user *cmd32,\n\t\t\t  struct comedi_cmd *cmd)\n{\n\tstruct comedi32_cmd_struct v32;\n\n\tmemset(&v32, 0, sizeof(v32));\n\tv32.subdev = cmd->subdev;\n\tv32.flags = cmd->flags;\n\tv32.start_src = cmd->start_src;\n\tv32.start_arg = cmd->start_arg;\n\tv32.scan_begin_src = cmd->scan_begin_src;\n\tv32.scan_begin_arg = cmd->scan_begin_arg;\n\tv32.convert_src = cmd->convert_src;\n\tv32.convert_arg = cmd->convert_arg;\n\tv32.scan_end_src = cmd->scan_end_src;\n\tv32.scan_end_arg = cmd->scan_end_arg;\n\tv32.stop_src = cmd->stop_src;\n\tv32.stop_arg = cmd->stop_arg;\n\t \n\tv32.chanlist = ptr_to_compat((unsigned int __user *)cmd->chanlist);\n\tv32.chanlist_len = cmd->chanlist_len;\n\tv32.data = ptr_to_compat(cmd->data);\n\tv32.data_len = cmd->data_len;\n\tif (copy_to_user(cmd32, &v32, sizeof(v32)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n \nstatic int compat_cmd(struct file *file, unsigned long arg)\n{\n\tstruct comedi_file *cfp = file->private_data;\n\tstruct comedi_device *dev = cfp->dev;\n\tstruct comedi_cmd cmd;\n\tbool copy = false;\n\tint rc, err;\n\n\trc = get_compat_cmd(&cmd, compat_ptr(arg));\n\tif (rc)\n\t\treturn rc;\n\n\tmutex_lock(&dev->mutex);\n\trc = do_cmd_ioctl(dev, &cmd, &copy, file);\n\tmutex_unlock(&dev->mutex);\n\tif (copy) {\n\t\t \n\t\terr = put_compat_cmd(compat_ptr(arg), &cmd);\n\t\tif (err)\n\t\t\trc = err;\n\t}\n\treturn rc;\n}\n\n \nstatic int compat_cmdtest(struct file *file, unsigned long arg)\n{\n\tstruct comedi_file *cfp = file->private_data;\n\tstruct comedi_device *dev = cfp->dev;\n\tstruct comedi_cmd cmd;\n\tbool copy = false;\n\tint rc, err;\n\n\trc = get_compat_cmd(&cmd, compat_ptr(arg));\n\tif (rc)\n\t\treturn rc;\n\n\tmutex_lock(&dev->mutex);\n\trc = do_cmdtest_ioctl(dev, &cmd, &copy, file);\n\tmutex_unlock(&dev->mutex);\n\tif (copy) {\n\t\terr = put_compat_cmd(compat_ptr(arg), &cmd);\n\t\tif (err)\n\t\t\trc = err;\n\t}\n\treturn rc;\n}\n\n \nstatic int get_compat_insn(struct comedi_insn *insn,\n\t\t\t   struct comedi32_insn_struct __user *insn32)\n{\n\tstruct comedi32_insn_struct v32;\n\n\t \n\tif (copy_from_user(&v32, insn32, sizeof(v32)))\n\t\treturn -EFAULT;\n\tmemset(insn, 0, sizeof(*insn));\n\tinsn->insn = v32.insn;\n\tinsn->n = v32.n;\n\tinsn->data = compat_ptr(v32.data);\n\tinsn->subdev = v32.subdev;\n\tinsn->chanspec = v32.chanspec;\n\treturn 0;\n}\n\n \nstatic int compat_insnlist(struct file *file, unsigned long arg)\n{\n\tstruct comedi_file *cfp = file->private_data;\n\tstruct comedi_device *dev = cfp->dev;\n\tstruct comedi32_insnlist_struct insnlist32;\n\tstruct comedi32_insn_struct __user *insn32;\n\tstruct comedi_insn *insns;\n\tunsigned int n;\n\tint rc;\n\n\tif (copy_from_user(&insnlist32, compat_ptr(arg), sizeof(insnlist32)))\n\t\treturn -EFAULT;\n\n\tinsns = kcalloc(insnlist32.n_insns, sizeof(*insns), GFP_KERNEL);\n\tif (!insns)\n\t\treturn -ENOMEM;\n\n\t \n\tinsn32 = compat_ptr(insnlist32.insns);\n\tfor (n = 0; n < insnlist32.n_insns; n++) {\n\t\trc = get_compat_insn(insns + n, insn32 + n);\n\t\tif (rc) {\n\t\t\tkfree(insns);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\tmutex_lock(&dev->mutex);\n\trc = do_insnlist_ioctl(dev, insns, insnlist32.n_insns, file);\n\tmutex_unlock(&dev->mutex);\n\tkfree(insns);\n\treturn rc;\n}\n\n \nstatic int compat_insn(struct file *file, unsigned long arg)\n{\n\tstruct comedi_file *cfp = file->private_data;\n\tstruct comedi_device *dev = cfp->dev;\n\tstruct comedi_insn insn;\n\tint rc;\n\n\trc = get_compat_insn(&insn, (void __user *)arg);\n\tif (rc)\n\t\treturn rc;\n\n\tmutex_lock(&dev->mutex);\n\trc = do_insn_ioctl(dev, &insn, file);\n\tmutex_unlock(&dev->mutex);\n\treturn rc;\n}\n\n \nstatic long comedi_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tint rc;\n\n\tswitch (cmd) {\n\tcase COMEDI_DEVCONFIG:\n\tcase COMEDI_DEVINFO:\n\tcase COMEDI_SUBDINFO:\n\tcase COMEDI_BUFCONFIG:\n\tcase COMEDI_BUFINFO:\n\t\t \n\t\targ = (unsigned long)compat_ptr(arg);\n\t\trc = comedi_unlocked_ioctl(file, cmd, arg);\n\t\tbreak;\n\tcase COMEDI_LOCK:\n\tcase COMEDI_UNLOCK:\n\tcase COMEDI_CANCEL:\n\tcase COMEDI_POLL:\n\tcase COMEDI_SETRSUBD:\n\tcase COMEDI_SETWSUBD:\n\t\t \n\t\trc = comedi_unlocked_ioctl(file, cmd, arg);\n\t\tbreak;\n\tcase COMEDI32_CHANINFO:\n\t\trc = compat_chaninfo(file, arg);\n\t\tbreak;\n\tcase COMEDI32_RANGEINFO:\n\t\trc = compat_rangeinfo(file, arg);\n\t\tbreak;\n\tcase COMEDI32_CMD:\n\t\trc = compat_cmd(file, arg);\n\t\tbreak;\n\tcase COMEDI32_CMDTEST:\n\t\trc = compat_cmdtest(file, arg);\n\t\tbreak;\n\tcase COMEDI32_INSNLIST:\n\t\trc = compat_insnlist(file, arg);\n\t\tbreak;\n\tcase COMEDI32_INSN:\n\t\trc = compat_insn(file, arg);\n\t\tbreak;\n\tdefault:\n\t\trc = -ENOIOCTLCMD;\n\t\tbreak;\n\t}\n\treturn rc;\n}\n#else\n#define comedi_compat_ioctl NULL\n#endif\n\nstatic const struct file_operations comedi_fops = {\n\t.owner = THIS_MODULE,\n\t.unlocked_ioctl = comedi_unlocked_ioctl,\n\t.compat_ioctl = comedi_compat_ioctl,\n\t.open = comedi_open,\n\t.release = comedi_close,\n\t.read = comedi_read,\n\t.write = comedi_write,\n\t.mmap = comedi_mmap,\n\t.poll = comedi_poll,\n\t.fasync = comedi_fasync,\n\t.llseek = noop_llseek,\n};\n\n \nvoid comedi_event(struct comedi_device *dev, struct comedi_subdevice *s)\n{\n\tstruct comedi_async *async = s->async;\n\tunsigned int events;\n\tint si_code = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&s->spin_lock, flags);\n\n\tevents = async->events;\n\tasync->events = 0;\n\tif (!__comedi_is_subdevice_running(s)) {\n\t\tspin_unlock_irqrestore(&s->spin_lock, flags);\n\t\treturn;\n\t}\n\n\tif (events & COMEDI_CB_CANCEL_MASK)\n\t\t__comedi_clear_subdevice_runflags(s, COMEDI_SRF_RUNNING);\n\n\t \n\tif (events & COMEDI_CB_ERROR_MASK)\n\t\t__comedi_set_subdevice_runflags(s, COMEDI_SRF_ERROR);\n\n\tif (async->cb_mask & events) {\n\t\twake_up_interruptible(&async->wait_head);\n\t\tsi_code = async->cmd.flags & CMDF_WRITE ? POLL_OUT : POLL_IN;\n\t}\n\n\tspin_unlock_irqrestore(&s->spin_lock, flags);\n\n\tif (si_code)\n\t\tkill_fasync(&dev->async_queue, SIGIO, si_code);\n}\nEXPORT_SYMBOL_GPL(comedi_event);\n\n \nstruct comedi_device *comedi_alloc_board_minor(struct device *hardware_device)\n{\n\tstruct comedi_device *dev;\n\tstruct device *csdev;\n\tunsigned int i;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\tcomedi_device_init(dev);\n\tcomedi_set_hw_dev(dev, hardware_device);\n\tmutex_lock(&dev->mutex);\n\tmutex_lock(&comedi_board_minor_table_lock);\n\tfor (i = hardware_device ? comedi_num_legacy_minors : 0;\n\t     i < COMEDI_NUM_BOARD_MINORS; ++i) {\n\t\tif (!comedi_board_minor_table[i]) {\n\t\t\tcomedi_board_minor_table[i] = dev;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&comedi_board_minor_table_lock);\n\tif (i == COMEDI_NUM_BOARD_MINORS) {\n\t\tmutex_unlock(&dev->mutex);\n\t\tcomedi_device_cleanup(dev);\n\t\tcomedi_dev_put(dev);\n\t\tdev_err(hardware_device,\n\t\t\t\"ran out of minor numbers for board device files\\n\");\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\tdev->minor = i;\n\tcsdev = device_create(&comedi_class, hardware_device,\n\t\t\t      MKDEV(COMEDI_MAJOR, i), NULL, \"comedi%i\", i);\n\tif (!IS_ERR(csdev))\n\t\tdev->class_dev = get_device(csdev);\n\n\t \n\treturn dev;\n}\n\nvoid comedi_release_hardware_device(struct device *hardware_device)\n{\n\tint minor;\n\tstruct comedi_device *dev;\n\n\tfor (minor = comedi_num_legacy_minors; minor < COMEDI_NUM_BOARD_MINORS;\n\t     minor++) {\n\t\tmutex_lock(&comedi_board_minor_table_lock);\n\t\tdev = comedi_board_minor_table[minor];\n\t\tif (dev && dev->hw_dev == hardware_device) {\n\t\t\tcomedi_board_minor_table[minor] = NULL;\n\t\t\tmutex_unlock(&comedi_board_minor_table_lock);\n\t\t\tcomedi_free_board_dev(dev);\n\t\t\tbreak;\n\t\t}\n\t\tmutex_unlock(&comedi_board_minor_table_lock);\n\t}\n}\n\nint comedi_alloc_subdevice_minor(struct comedi_subdevice *s)\n{\n\tstruct comedi_device *dev = s->device;\n\tstruct device *csdev;\n\tunsigned int i;\n\n\tmutex_lock(&comedi_subdevice_minor_table_lock);\n\tfor (i = 0; i < COMEDI_NUM_SUBDEVICE_MINORS; ++i) {\n\t\tif (!comedi_subdevice_minor_table[i]) {\n\t\t\tcomedi_subdevice_minor_table[i] = s;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&comedi_subdevice_minor_table_lock);\n\tif (i == COMEDI_NUM_SUBDEVICE_MINORS) {\n\t\tdev_err(dev->class_dev,\n\t\t\t\"ran out of minor numbers for subdevice files\\n\");\n\t\treturn -EBUSY;\n\t}\n\ti += COMEDI_NUM_BOARD_MINORS;\n\ts->minor = i;\n\tcsdev = device_create(&comedi_class, dev->class_dev,\n\t\t\t      MKDEV(COMEDI_MAJOR, i), NULL, \"comedi%i_subd%i\",\n\t\t\t      dev->minor, s->index);\n\tif (!IS_ERR(csdev))\n\t\ts->class_dev = csdev;\n\n\treturn 0;\n}\n\nvoid comedi_free_subdevice_minor(struct comedi_subdevice *s)\n{\n\tunsigned int i;\n\n\tif (!s)\n\t\treturn;\n\tif (s->minor < COMEDI_NUM_BOARD_MINORS ||\n\t    s->minor >= COMEDI_NUM_MINORS)\n\t\treturn;\n\n\ti = s->minor - COMEDI_NUM_BOARD_MINORS;\n\tmutex_lock(&comedi_subdevice_minor_table_lock);\n\tif (s == comedi_subdevice_minor_table[i])\n\t\tcomedi_subdevice_minor_table[i] = NULL;\n\tmutex_unlock(&comedi_subdevice_minor_table_lock);\n\tif (s->class_dev) {\n\t\tdevice_destroy(&comedi_class, MKDEV(COMEDI_MAJOR, s->minor));\n\t\ts->class_dev = NULL;\n\t}\n}\n\nstatic void comedi_cleanup_board_minors(void)\n{\n\tstruct comedi_device *dev;\n\tunsigned int i;\n\n\tfor (i = 0; i < COMEDI_NUM_BOARD_MINORS; i++) {\n\t\tdev = comedi_clear_board_minor(i);\n\t\tcomedi_free_board_dev(dev);\n\t}\n}\n\nstatic int __init comedi_init(void)\n{\n\tint i;\n\tint retval;\n\n\tpr_info(\"version \" COMEDI_RELEASE \" - http://www.comedi.org\\n\");\n\n\tif (comedi_num_legacy_minors > COMEDI_NUM_BOARD_MINORS) {\n\t\tpr_err(\"invalid value for module parameter \\\"comedi_num_legacy_minors\\\".  Valid values are 0 through %i.\\n\",\n\t\t       COMEDI_NUM_BOARD_MINORS);\n\t\treturn -EINVAL;\n\t}\n\n\tretval = register_chrdev_region(MKDEV(COMEDI_MAJOR, 0),\n\t\t\t\t\tCOMEDI_NUM_MINORS, \"comedi\");\n\tif (retval)\n\t\treturn retval;\n\n\tcdev_init(&comedi_cdev, &comedi_fops);\n\tcomedi_cdev.owner = THIS_MODULE;\n\n\tretval = kobject_set_name(&comedi_cdev.kobj, \"comedi\");\n\tif (retval)\n\t\tgoto out_unregister_chrdev_region;\n\n\tretval = cdev_add(&comedi_cdev, MKDEV(COMEDI_MAJOR, 0),\n\t\t\t  COMEDI_NUM_MINORS);\n\tif (retval)\n\t\tgoto out_unregister_chrdev_region;\n\n\tretval = class_register(&comedi_class);\n\tif (retval) {\n\t\tpr_err(\"failed to create class\\n\");\n\t\tgoto out_cdev_del;\n\t}\n\n\t \n\tfor (i = 0; i < comedi_num_legacy_minors; i++) {\n\t\tstruct comedi_device *dev;\n\n\t\tdev = comedi_alloc_board_minor(NULL);\n\t\tif (IS_ERR(dev)) {\n\t\t\tretval = PTR_ERR(dev);\n\t\t\tgoto out_cleanup_board_minors;\n\t\t}\n\t\t \n\t\tlockdep_assert_held(&dev->mutex);\n\t\tmutex_unlock(&dev->mutex);\n\t}\n\n\t \n\tcomedi_proc_init();\n\n\treturn 0;\n\nout_cleanup_board_minors:\n\tcomedi_cleanup_board_minors();\n\tclass_unregister(&comedi_class);\nout_cdev_del:\n\tcdev_del(&comedi_cdev);\nout_unregister_chrdev_region:\n\tunregister_chrdev_region(MKDEV(COMEDI_MAJOR, 0), COMEDI_NUM_MINORS);\n\treturn retval;\n}\nmodule_init(comedi_init);\n\nstatic void __exit comedi_cleanup(void)\n{\n\tcomedi_cleanup_board_minors();\n\tclass_unregister(&comedi_class);\n\tcdev_del(&comedi_cdev);\n\tunregister_chrdev_region(MKDEV(COMEDI_MAJOR, 0), COMEDI_NUM_MINORS);\n\n\tcomedi_proc_cleanup();\n}\nmodule_exit(comedi_cleanup);\n\nMODULE_AUTHOR(\"https://www.comedi.org\");\nMODULE_DESCRIPTION(\"Comedi core module\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}