{
  "module_name": "pn533.c",
  "hash_id": "9ced971f8b86c624f35fafc7165f3240816bc13c44ddf785212544519dae65d5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nfc/pn533/pn533.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/nfc.h>\n#include <linux/netdevice.h>\n#include <net/nfc/nfc.h>\n#include \"pn533.h\"\n\n#define VERSION \"0.3\"\n\n \n#define PN533_LISTEN_TIME 2\n \n#define PN533_POLL_INTERVAL 10\n\n \n\n \nstruct pn533_fw_version {\n\tu8 ic;\n\tu8 ver;\n\tu8 rev;\n\tu8 support;\n};\n\n \n#define PN533_CFGITEM_RF_FIELD    0x01\n#define PN533_CFGITEM_TIMING      0x02\n#define PN533_CFGITEM_MAX_RETRIES 0x05\n#define PN533_CFGITEM_PASORI      0x82\n\n#define PN533_CFGITEM_RF_FIELD_AUTO_RFCA 0x2\n#define PN533_CFGITEM_RF_FIELD_ON        0x1\n#define PN533_CFGITEM_RF_FIELD_OFF       0x0\n\n#define PN533_CONFIG_TIMING_102 0xb\n#define PN533_CONFIG_TIMING_204 0xc\n#define PN533_CONFIG_TIMING_409 0xd\n#define PN533_CONFIG_TIMING_819 0xe\n\n#define PN533_CONFIG_MAX_RETRIES_NO_RETRY 0x00\n#define PN533_CONFIG_MAX_RETRIES_ENDLESS 0xFF\n\nstruct pn533_config_max_retries {\n\tu8 mx_rty_atr;\n\tu8 mx_rty_psl;\n\tu8 mx_rty_passive_act;\n} __packed;\n\nstruct pn533_config_timing {\n\tu8 rfu;\n\tu8 atr_res_timeout;\n\tu8 dep_timeout;\n} __packed;\n\n \n\n \n#define PN533_FELICA_OPC_SENSF_REQ 0\n#define PN533_FELICA_OPC_SENSF_RES 1\n \n#define PN533_FELICA_SENSF_SC_ALL 0xFFFF\n#define PN533_FELICA_SENSF_RC_NO_SYSTEM_CODE 0\n#define PN533_FELICA_SENSF_RC_SYSTEM_CODE 1\n#define PN533_FELICA_SENSF_RC_ADVANCED_PROTOCOL 2\n\n \n#define PN533_TYPE_B_AFI_ALL_FAMILIES 0\n#define PN533_TYPE_B_POLL_METHOD_TIMESLOT 0\n#define PN533_TYPE_B_POLL_METHOD_PROBABILISTIC 1\n\nunion pn533_cmd_poll_initdata {\n\tstruct {\n\t\tu8 afi;\n\t\tu8 polling_method;\n\t} __packed type_b;\n\tstruct {\n\t\tu8 opcode;\n\t\t__be16 sc;\n\t\tu8 rc;\n\t\tu8 tsn;\n\t} __packed felica;\n};\n\nstruct pn533_poll_modulations {\n\tstruct {\n\t\tu8 maxtg;\n\t\tu8 brty;\n\t\tunion pn533_cmd_poll_initdata initiator_data;\n\t} __packed data;\n\tu8 len;\n};\n\nstatic const struct pn533_poll_modulations poll_mod[] = {\n\t[PN533_POLL_MOD_106KBPS_A] = {\n\t\t.data = {\n\t\t\t.maxtg = 1,\n\t\t\t.brty = 0,\n\t\t},\n\t\t.len = 2,\n\t},\n\t[PN533_POLL_MOD_212KBPS_FELICA] = {\n\t\t.data = {\n\t\t\t.maxtg = 1,\n\t\t\t.brty = 1,\n\t\t\t.initiator_data.felica = {\n\t\t\t\t.opcode = PN533_FELICA_OPC_SENSF_REQ,\n\t\t\t\t.sc = PN533_FELICA_SENSF_SC_ALL,\n\t\t\t\t.rc = PN533_FELICA_SENSF_RC_SYSTEM_CODE,\n\t\t\t\t.tsn = 0x03,\n\t\t\t},\n\t\t},\n\t\t.len = 7,\n\t},\n\t[PN533_POLL_MOD_424KBPS_FELICA] = {\n\t\t.data = {\n\t\t\t.maxtg = 1,\n\t\t\t.brty = 2,\n\t\t\t.initiator_data.felica = {\n\t\t\t\t.opcode = PN533_FELICA_OPC_SENSF_REQ,\n\t\t\t\t.sc = PN533_FELICA_SENSF_SC_ALL,\n\t\t\t\t.rc = PN533_FELICA_SENSF_RC_SYSTEM_CODE,\n\t\t\t\t.tsn = 0x03,\n\t\t\t},\n\t\t },\n\t\t.len = 7,\n\t},\n\t[PN533_POLL_MOD_106KBPS_JEWEL] = {\n\t\t.data = {\n\t\t\t.maxtg = 1,\n\t\t\t.brty = 4,\n\t\t},\n\t\t.len = 2,\n\t},\n\t[PN533_POLL_MOD_847KBPS_B] = {\n\t\t.data = {\n\t\t\t.maxtg = 1,\n\t\t\t.brty = 8,\n\t\t\t.initiator_data.type_b = {\n\t\t\t\t.afi = PN533_TYPE_B_AFI_ALL_FAMILIES,\n\t\t\t\t.polling_method =\n\t\t\t\t\tPN533_TYPE_B_POLL_METHOD_TIMESLOT,\n\t\t\t},\n\t\t},\n\t\t.len = 3,\n\t},\n\t[PN533_LISTEN_MOD] = {\n\t\t.len = 0,\n\t},\n};\n\n \n\nstruct pn533_cmd_activate_response {\n\tu8 status;\n\tu8 nfcid3t[10];\n\tu8 didt;\n\tu8 bst;\n\tu8 brt;\n\tu8 to;\n\tu8 ppt;\n\t \n\tu8 gt[];\n} __packed;\n\nstruct pn533_cmd_jump_dep_response {\n\tu8 status;\n\tu8 tg;\n\tu8 nfcid3t[10];\n\tu8 didt;\n\tu8 bst;\n\tu8 brt;\n\tu8 to;\n\tu8 ppt;\n\t \n\tu8 gt[];\n} __packed;\n\nstruct pn532_autopoll_resp {\n\tu8 type;\n\tu8 ln;\n\tu8 tg;\n\tu8 tgdata[];\n};\n\n \n#define PN532_AUTOPOLL_POLLNR_INFINITE\t0xff\n#define PN532_AUTOPOLL_PERIOD\t\t0x03  \n\n#define PN532_AUTOPOLL_TYPE_GENERIC_106\t\t0x00\n#define PN532_AUTOPOLL_TYPE_GENERIC_212\t\t0x01\n#define PN532_AUTOPOLL_TYPE_GENERIC_424\t\t0x02\n#define PN532_AUTOPOLL_TYPE_JEWEL\t\t0x04\n#define PN532_AUTOPOLL_TYPE_MIFARE\t\t0x10\n#define PN532_AUTOPOLL_TYPE_FELICA212\t\t0x11\n#define PN532_AUTOPOLL_TYPE_FELICA424\t\t0x12\n#define PN532_AUTOPOLL_TYPE_ISOA\t\t0x20\n#define PN532_AUTOPOLL_TYPE_ISOB\t\t0x23\n#define PN532_AUTOPOLL_TYPE_DEP_PASSIVE_106\t0x40\n#define PN532_AUTOPOLL_TYPE_DEP_PASSIVE_212\t0x41\n#define PN532_AUTOPOLL_TYPE_DEP_PASSIVE_424\t0x42\n#define PN532_AUTOPOLL_TYPE_DEP_ACTIVE_106\t0x80\n#define PN532_AUTOPOLL_TYPE_DEP_ACTIVE_212\t0x81\n#define PN532_AUTOPOLL_TYPE_DEP_ACTIVE_424\t0x82\n\n \n#define PN533_INIT_TARGET_PASSIVE 0x1\n#define PN533_INIT_TARGET_DEP 0x2\n\n#define PN533_INIT_TARGET_RESP_FRAME_MASK 0x3\n#define PN533_INIT_TARGET_RESP_ACTIVE     0x1\n#define PN533_INIT_TARGET_RESP_DEP        0x4\n\n \nstatic inline u8 pn533_ext_checksum(u16 value)\n{\n\treturn ~(u8)(((value & 0xFF00) >> 8) + (u8)(value & 0xFF)) + 1;\n}\n\n \nstatic inline u8 pn533_std_checksum(u8 value)\n{\n\treturn ~value + 1;\n}\n\n \nstatic u8 pn533_std_data_checksum(u8 *data, int datalen)\n{\n\tu8 sum = 0;\n\tint i;\n\n\tfor (i = 0; i < datalen; i++)\n\t\tsum += data[i];\n\n\treturn pn533_std_checksum(sum);\n}\n\nstatic void pn533_std_tx_frame_init(void *_frame, u8 cmd_code)\n{\n\tstruct pn533_std_frame *frame = _frame;\n\n\tframe->preamble = 0;\n\tframe->start_frame = cpu_to_be16(PN533_STD_FRAME_SOF);\n\tPN533_STD_FRAME_IDENTIFIER(frame) = PN533_STD_FRAME_DIR_OUT;\n\tPN533_FRAME_CMD(frame) = cmd_code;\n\tframe->datalen = 2;\n}\n\nstatic void pn533_std_tx_frame_finish(void *_frame)\n{\n\tstruct pn533_std_frame *frame = _frame;\n\n\tframe->datalen_checksum = pn533_std_checksum(frame->datalen);\n\n\tPN533_STD_FRAME_CHECKSUM(frame) =\n\t\tpn533_std_data_checksum(frame->data, frame->datalen);\n\n\tPN533_STD_FRAME_POSTAMBLE(frame) = 0;\n}\n\nstatic void pn533_std_tx_update_payload_len(void *_frame, int len)\n{\n\tstruct pn533_std_frame *frame = _frame;\n\n\tframe->datalen += len;\n}\n\nstatic bool pn533_std_rx_frame_is_valid(void *_frame, struct pn533 *dev)\n{\n\tu8 checksum;\n\tstruct pn533_std_frame *stdf = _frame;\n\n\tif (stdf->start_frame != cpu_to_be16(PN533_STD_FRAME_SOF))\n\t\treturn false;\n\n\tif (likely(!PN533_STD_IS_EXTENDED(stdf))) {\n\t\t \n\t\tdev->ops->rx_header_len = PN533_STD_FRAME_HEADER_LEN;\n\n\t\tchecksum = pn533_std_checksum(stdf->datalen);\n\t\tif (checksum != stdf->datalen_checksum)\n\t\t\treturn false;\n\n\t\tchecksum = pn533_std_data_checksum(stdf->data, stdf->datalen);\n\t\tif (checksum != PN533_STD_FRAME_CHECKSUM(stdf))\n\t\t\treturn false;\n\t} else {\n\t\t \n\t\tstruct pn533_ext_frame *eif = _frame;\n\n\t\tdev->ops->rx_header_len = PN533_EXT_FRAME_HEADER_LEN;\n\n\t\tchecksum = pn533_ext_checksum(be16_to_cpu(eif->datalen));\n\t\tif (checksum != eif->datalen_checksum)\n\t\t\treturn false;\n\n\t\t \n\t\tchecksum = pn533_std_data_checksum(eif->data,\n\t\t\t\t\t\t   be16_to_cpu(eif->datalen));\n\t\tif (checksum != PN533_EXT_FRAME_CHECKSUM(eif))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nbool pn533_rx_frame_is_ack(void *_frame)\n{\n\tstruct pn533_std_frame *frame = _frame;\n\n\tif (frame->start_frame != cpu_to_be16(PN533_STD_FRAME_SOF))\n\t\treturn false;\n\n\tif (frame->datalen != 0 || frame->datalen_checksum != 0xFF)\n\t\treturn false;\n\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(pn533_rx_frame_is_ack);\n\nstatic inline int pn533_std_rx_frame_size(void *frame)\n{\n\tstruct pn533_std_frame *f = frame;\n\n\t \n\tif (PN533_STD_IS_EXTENDED(f)) {\n\t\tstruct pn533_ext_frame *eif = frame;\n\n\t\treturn sizeof(struct pn533_ext_frame)\n\t\t\t+ be16_to_cpu(eif->datalen) + PN533_STD_FRAME_TAIL_LEN;\n\t}\n\n\treturn sizeof(struct pn533_std_frame) + f->datalen +\n\t       PN533_STD_FRAME_TAIL_LEN;\n}\n\nstatic u8 pn533_std_get_cmd_code(void *frame)\n{\n\tstruct pn533_std_frame *f = frame;\n\tstruct pn533_ext_frame *eif = frame;\n\n\tif (PN533_STD_IS_EXTENDED(f))\n\t\treturn PN533_FRAME_CMD(eif);\n\telse\n\t\treturn PN533_FRAME_CMD(f);\n}\n\nbool pn533_rx_frame_is_cmd_response(struct pn533 *dev, void *frame)\n{\n\treturn (dev->ops->get_cmd_code(frame) ==\n\t\t\t\tPN533_CMD_RESPONSE(dev->cmd->code));\n}\nEXPORT_SYMBOL_GPL(pn533_rx_frame_is_cmd_response);\n\n\nstatic struct pn533_frame_ops pn533_std_frame_ops = {\n\t.tx_frame_init = pn533_std_tx_frame_init,\n\t.tx_frame_finish = pn533_std_tx_frame_finish,\n\t.tx_update_payload_len = pn533_std_tx_update_payload_len,\n\t.tx_header_len = PN533_STD_FRAME_HEADER_LEN,\n\t.tx_tail_len = PN533_STD_FRAME_TAIL_LEN,\n\n\t.rx_is_frame_valid = pn533_std_rx_frame_is_valid,\n\t.rx_frame_size = pn533_std_rx_frame_size,\n\t.rx_header_len = PN533_STD_FRAME_HEADER_LEN,\n\t.rx_tail_len = PN533_STD_FRAME_TAIL_LEN,\n\n\t.max_payload_len =  PN533_STD_FRAME_MAX_PAYLOAD_LEN,\n\t.get_cmd_code = pn533_std_get_cmd_code,\n};\n\nstatic void pn533_build_cmd_frame(struct pn533 *dev, u8 cmd_code,\n\t\t\t\t  struct sk_buff *skb)\n{\n\t \n\tint payload_len = skb->len;\n\tstruct pn533_frame_ops *ops = dev->ops;\n\n\n\tskb_push(skb, ops->tx_header_len);\n\tskb_put(skb, ops->tx_tail_len);\n\n\tops->tx_frame_init(skb->data, cmd_code);\n\tops->tx_update_payload_len(skb->data, payload_len);\n\tops->tx_frame_finish(skb->data);\n}\n\nstatic int pn533_send_async_complete(struct pn533 *dev)\n{\n\tstruct pn533_cmd *cmd = dev->cmd;\n\tstruct sk_buff *resp;\n\tint status, rc = 0;\n\n\tif (!cmd) {\n\t\tdev_dbg(dev->dev, \"%s: cmd not set\\n\", __func__);\n\t\tgoto done;\n\t}\n\n\tdev_kfree_skb(cmd->req);\n\n\tstatus = cmd->status;\n\tresp = cmd->resp;\n\n\tif (status < 0) {\n\t\trc = cmd->complete_cb(dev, cmd->complete_cb_context,\n\t\t\t\t      ERR_PTR(status));\n\t\tdev_kfree_skb(resp);\n\t\tgoto done;\n\t}\n\n\t \n\tif (!resp)\n\t\tresp = ERR_PTR(-EINTR);\n\n\tif (!IS_ERR(resp)) {\n\t\tskb_pull(resp, dev->ops->rx_header_len);\n\t\tskb_trim(resp, resp->len - dev->ops->rx_tail_len);\n\t}\n\n\trc = cmd->complete_cb(dev, cmd->complete_cb_context, resp);\n\ndone:\n\tkfree(cmd);\n\tdev->cmd = NULL;\n\treturn rc;\n}\n\nstatic int __pn533_send_async(struct pn533 *dev, u8 cmd_code,\n\t\t\t      struct sk_buff *req,\n\t\t\t      pn533_send_async_complete_t complete_cb,\n\t\t\t      void *complete_cb_context)\n{\n\tstruct pn533_cmd *cmd;\n\tint rc = 0;\n\n\tdev_dbg(dev->dev, \"Sending command 0x%x\\n\", cmd_code);\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tcmd->code = cmd_code;\n\tcmd->req = req;\n\tcmd->complete_cb = complete_cb;\n\tcmd->complete_cb_context = complete_cb_context;\n\n\tpn533_build_cmd_frame(dev, cmd_code, req);\n\n\tmutex_lock(&dev->cmd_lock);\n\n\tif (!dev->cmd_pending) {\n\t\tdev->cmd = cmd;\n\t\trc = dev->phy_ops->send_frame(dev, req);\n\t\tif (rc) {\n\t\t\tdev->cmd = NULL;\n\t\t\tgoto error;\n\t\t}\n\n\t\tdev->cmd_pending = 1;\n\t\tgoto unlock;\n\t}\n\n\tdev_dbg(dev->dev, \"%s Queueing command 0x%x\\n\",\n\t\t__func__, cmd_code);\n\n\tINIT_LIST_HEAD(&cmd->queue);\n\tlist_add_tail(&cmd->queue, &dev->cmd_queue);\n\n\tgoto unlock;\n\nerror:\n\tkfree(cmd);\nunlock:\n\tmutex_unlock(&dev->cmd_lock);\n\treturn rc;\n}\n\nstatic int pn533_send_data_async(struct pn533 *dev, u8 cmd_code,\n\t\t\t\t struct sk_buff *req,\n\t\t\t\t pn533_send_async_complete_t complete_cb,\n\t\t\t\t void *complete_cb_context)\n{\n\treturn __pn533_send_async(dev, cmd_code, req, complete_cb,\n\t\t\t\tcomplete_cb_context);\n}\n\nstatic int pn533_send_cmd_async(struct pn533 *dev, u8 cmd_code,\n\t\t\t\tstruct sk_buff *req,\n\t\t\t\tpn533_send_async_complete_t complete_cb,\n\t\t\t\tvoid *complete_cb_context)\n{\n\treturn __pn533_send_async(dev, cmd_code, req, complete_cb,\n\t\t\t\tcomplete_cb_context);\n}\n\n \nstatic int pn533_send_cmd_direct_async(struct pn533 *dev, u8 cmd_code,\n\t\t\t\t       struct sk_buff *req,\n\t\t\t\t       pn533_send_async_complete_t complete_cb,\n\t\t\t\t       void *complete_cb_context)\n{\n\tstruct pn533_cmd *cmd;\n\tint rc;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tcmd->code = cmd_code;\n\tcmd->req = req;\n\tcmd->complete_cb = complete_cb;\n\tcmd->complete_cb_context = complete_cb_context;\n\n\tpn533_build_cmd_frame(dev, cmd_code, req);\n\n\tdev->cmd = cmd;\n\trc = dev->phy_ops->send_frame(dev, req);\n\tif (rc < 0) {\n\t\tdev->cmd = NULL;\n\t\tkfree(cmd);\n\t}\n\n\treturn rc;\n}\n\nstatic void pn533_wq_cmd_complete(struct work_struct *work)\n{\n\tstruct pn533 *dev = container_of(work, struct pn533, cmd_complete_work);\n\tint rc;\n\n\trc = pn533_send_async_complete(dev);\n\tif (rc != -EINPROGRESS)\n\t\tqueue_work(dev->wq, &dev->cmd_work);\n}\n\nstatic void pn533_wq_cmd(struct work_struct *work)\n{\n\tstruct pn533 *dev = container_of(work, struct pn533, cmd_work);\n\tstruct pn533_cmd *cmd;\n\tint rc;\n\n\tmutex_lock(&dev->cmd_lock);\n\n\tif (list_empty(&dev->cmd_queue)) {\n\t\tdev->cmd_pending = 0;\n\t\tmutex_unlock(&dev->cmd_lock);\n\t\treturn;\n\t}\n\n\tcmd = list_first_entry(&dev->cmd_queue, struct pn533_cmd, queue);\n\n\tlist_del(&cmd->queue);\n\n\tmutex_unlock(&dev->cmd_lock);\n\n\tdev->cmd = cmd;\n\trc = dev->phy_ops->send_frame(dev, cmd->req);\n\tif (rc < 0) {\n\t\tdev->cmd = NULL;\n\t\tdev_kfree_skb(cmd->req);\n\t\tkfree(cmd);\n\t\treturn;\n\t}\n\n}\n\nstruct pn533_sync_cmd_response {\n\tstruct sk_buff *resp;\n\tstruct completion done;\n};\n\nstatic int pn533_send_sync_complete(struct pn533 *dev, void *_arg,\n\t\t\t\t    struct sk_buff *resp)\n{\n\tstruct pn533_sync_cmd_response *arg = _arg;\n\n\targ->resp = resp;\n\tcomplete(&arg->done);\n\n\treturn 0;\n}\n\n \nstatic struct sk_buff *pn533_send_cmd_sync(struct pn533 *dev, u8 cmd_code,\n\t\t\t\t\t       struct sk_buff *req)\n{\n\tint rc;\n\tstruct pn533_sync_cmd_response arg;\n\n\tinit_completion(&arg.done);\n\n\trc = pn533_send_cmd_async(dev, cmd_code, req,\n\t\t\t\t  pn533_send_sync_complete, &arg);\n\tif (rc) {\n\t\tdev_kfree_skb(req);\n\t\treturn ERR_PTR(rc);\n\t}\n\n\twait_for_completion(&arg.done);\n\n\treturn arg.resp;\n}\n\nstatic struct sk_buff *pn533_alloc_skb(struct pn533 *dev, unsigned int size)\n{\n\tstruct sk_buff *skb;\n\n\tskb = alloc_skb(dev->ops->tx_header_len +\n\t\t\tsize +\n\t\t\tdev->ops->tx_tail_len, GFP_KERNEL);\n\n\tif (skb)\n\t\tskb_reserve(skb, dev->ops->tx_header_len);\n\n\treturn skb;\n}\n\nstruct pn533_target_type_a {\n\t__be16 sens_res;\n\tu8 sel_res;\n\tu8 nfcid_len;\n\tu8 nfcid_data[];\n} __packed;\n\n\n#define PN533_TYPE_A_SENS_RES_NFCID1(x) ((u8)((be16_to_cpu(x) & 0x00C0) >> 6))\n#define PN533_TYPE_A_SENS_RES_SSD(x) ((u8)((be16_to_cpu(x) & 0x001F) >> 0))\n#define PN533_TYPE_A_SENS_RES_PLATCONF(x) ((u8)((be16_to_cpu(x) & 0x0F00) >> 8))\n\n#define PN533_TYPE_A_SENS_RES_SSD_JEWEL 0x00\n#define PN533_TYPE_A_SENS_RES_PLATCONF_JEWEL 0x0C\n\n#define PN533_TYPE_A_SEL_PROT(x) (((x) & 0x60) >> 5)\n#define PN533_TYPE_A_SEL_CASCADE(x) (((x) & 0x04) >> 2)\n\n#define PN533_TYPE_A_SEL_PROT_MIFARE 0\n#define PN533_TYPE_A_SEL_PROT_ISO14443 1\n#define PN533_TYPE_A_SEL_PROT_DEP 2\n#define PN533_TYPE_A_SEL_PROT_ISO14443_DEP 3\n\nstatic bool pn533_target_type_a_is_valid(struct pn533_target_type_a *type_a,\n\t\t\t\t\t\t\tint target_data_len)\n{\n\tu8 ssd;\n\tu8 platconf;\n\n\tif (target_data_len < sizeof(struct pn533_target_type_a))\n\t\treturn false;\n\n\t \n\n\t \n\tssd = PN533_TYPE_A_SENS_RES_SSD(type_a->sens_res);\n\tplatconf = PN533_TYPE_A_SENS_RES_PLATCONF(type_a->sens_res);\n\n\tif ((ssd == PN533_TYPE_A_SENS_RES_SSD_JEWEL &&\n\t     platconf != PN533_TYPE_A_SENS_RES_PLATCONF_JEWEL) ||\n\t    (ssd != PN533_TYPE_A_SENS_RES_SSD_JEWEL &&\n\t     platconf == PN533_TYPE_A_SENS_RES_PLATCONF_JEWEL))\n\t\treturn false;\n\n\t \n\tif (PN533_TYPE_A_SEL_CASCADE(type_a->sel_res) != 0)\n\t\treturn false;\n\n\tif (type_a->nfcid_len > NFC_NFCID1_MAXSIZE)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int pn533_target_found_type_a(struct nfc_target *nfc_tgt, u8 *tgt_data,\n\t\t\t\t\t\t\tint tgt_data_len)\n{\n\tstruct pn533_target_type_a *tgt_type_a;\n\n\ttgt_type_a = (struct pn533_target_type_a *)tgt_data;\n\n\tif (!pn533_target_type_a_is_valid(tgt_type_a, tgt_data_len))\n\t\treturn -EPROTO;\n\n\tswitch (PN533_TYPE_A_SEL_PROT(tgt_type_a->sel_res)) {\n\tcase PN533_TYPE_A_SEL_PROT_MIFARE:\n\t\tnfc_tgt->supported_protocols = NFC_PROTO_MIFARE_MASK;\n\t\tbreak;\n\tcase PN533_TYPE_A_SEL_PROT_ISO14443:\n\t\tnfc_tgt->supported_protocols = NFC_PROTO_ISO14443_MASK;\n\t\tbreak;\n\tcase PN533_TYPE_A_SEL_PROT_DEP:\n\t\tnfc_tgt->supported_protocols = NFC_PROTO_NFC_DEP_MASK;\n\t\tbreak;\n\tcase PN533_TYPE_A_SEL_PROT_ISO14443_DEP:\n\t\tnfc_tgt->supported_protocols = NFC_PROTO_ISO14443_MASK |\n\t\t\t\t\t\t\tNFC_PROTO_NFC_DEP_MASK;\n\t\tbreak;\n\t}\n\n\tnfc_tgt->sens_res = be16_to_cpu(tgt_type_a->sens_res);\n\tnfc_tgt->sel_res = tgt_type_a->sel_res;\n\tnfc_tgt->nfcid1_len = tgt_type_a->nfcid_len;\n\tmemcpy(nfc_tgt->nfcid1, tgt_type_a->nfcid_data, nfc_tgt->nfcid1_len);\n\n\treturn 0;\n}\n\nstruct pn533_target_felica {\n\tu8 pol_res;\n\tu8 opcode;\n\tu8 nfcid2[NFC_NFCID2_MAXSIZE];\n\tu8 pad[8];\n\t \n\tu8 syst_code[];\n} __packed;\n\n#define PN533_FELICA_SENSF_NFCID2_DEP_B1 0x01\n#define PN533_FELICA_SENSF_NFCID2_DEP_B2 0xFE\n\nstatic bool pn533_target_felica_is_valid(struct pn533_target_felica *felica,\n\t\t\t\t\t\t\tint target_data_len)\n{\n\tif (target_data_len < sizeof(struct pn533_target_felica))\n\t\treturn false;\n\n\tif (felica->opcode != PN533_FELICA_OPC_SENSF_RES)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int pn533_target_found_felica(struct nfc_target *nfc_tgt, u8 *tgt_data,\n\t\t\t\t\t\t\tint tgt_data_len)\n{\n\tstruct pn533_target_felica *tgt_felica;\n\n\ttgt_felica = (struct pn533_target_felica *)tgt_data;\n\n\tif (!pn533_target_felica_is_valid(tgt_felica, tgt_data_len))\n\t\treturn -EPROTO;\n\n\tif ((tgt_felica->nfcid2[0] == PN533_FELICA_SENSF_NFCID2_DEP_B1) &&\n\t    (tgt_felica->nfcid2[1] == PN533_FELICA_SENSF_NFCID2_DEP_B2))\n\t\tnfc_tgt->supported_protocols = NFC_PROTO_NFC_DEP_MASK;\n\telse\n\t\tnfc_tgt->supported_protocols = NFC_PROTO_FELICA_MASK;\n\n\tmemcpy(nfc_tgt->sensf_res, &tgt_felica->opcode, 9);\n\tnfc_tgt->sensf_res_len = 9;\n\n\tmemcpy(nfc_tgt->nfcid2, tgt_felica->nfcid2, NFC_NFCID2_MAXSIZE);\n\tnfc_tgt->nfcid2_len = NFC_NFCID2_MAXSIZE;\n\n\treturn 0;\n}\n\nstruct pn533_target_jewel {\n\t__be16 sens_res;\n\tu8 jewelid[4];\n} __packed;\n\nstatic bool pn533_target_jewel_is_valid(struct pn533_target_jewel *jewel,\n\t\t\t\t\t\t\tint target_data_len)\n{\n\tu8 ssd;\n\tu8 platconf;\n\n\tif (target_data_len < sizeof(struct pn533_target_jewel))\n\t\treturn false;\n\n\t \n\tssd = PN533_TYPE_A_SENS_RES_SSD(jewel->sens_res);\n\tplatconf = PN533_TYPE_A_SENS_RES_PLATCONF(jewel->sens_res);\n\n\tif ((ssd == PN533_TYPE_A_SENS_RES_SSD_JEWEL &&\n\t     platconf != PN533_TYPE_A_SENS_RES_PLATCONF_JEWEL) ||\n\t    (ssd != PN533_TYPE_A_SENS_RES_SSD_JEWEL &&\n\t     platconf == PN533_TYPE_A_SENS_RES_PLATCONF_JEWEL))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int pn533_target_found_jewel(struct nfc_target *nfc_tgt, u8 *tgt_data,\n\t\t\t\t\t\t\tint tgt_data_len)\n{\n\tstruct pn533_target_jewel *tgt_jewel;\n\n\ttgt_jewel = (struct pn533_target_jewel *)tgt_data;\n\n\tif (!pn533_target_jewel_is_valid(tgt_jewel, tgt_data_len))\n\t\treturn -EPROTO;\n\n\tnfc_tgt->supported_protocols = NFC_PROTO_JEWEL_MASK;\n\tnfc_tgt->sens_res = be16_to_cpu(tgt_jewel->sens_res);\n\tnfc_tgt->nfcid1_len = 4;\n\tmemcpy(nfc_tgt->nfcid1, tgt_jewel->jewelid, nfc_tgt->nfcid1_len);\n\n\treturn 0;\n}\n\nstruct pn533_type_b_prot_info {\n\tu8 bitrate;\n\tu8 fsci_type;\n\tu8 fwi_adc_fo;\n} __packed;\n\n#define PN533_TYPE_B_PROT_FCSI(x) (((x) & 0xF0) >> 4)\n#define PN533_TYPE_B_PROT_TYPE(x) (((x) & 0x0F) >> 0)\n#define PN533_TYPE_B_PROT_TYPE_RFU_MASK 0x8\n\nstruct pn533_type_b_sens_res {\n\tu8 opcode;\n\tu8 nfcid[4];\n\tu8 appdata[4];\n\tstruct pn533_type_b_prot_info prot_info;\n} __packed;\n\n#define PN533_TYPE_B_OPC_SENSB_RES 0x50\n\nstruct pn533_target_type_b {\n\tstruct pn533_type_b_sens_res sensb_res;\n\tu8 attrib_res_len;\n\tu8 attrib_res[];\n} __packed;\n\nstatic bool pn533_target_type_b_is_valid(struct pn533_target_type_b *type_b,\n\t\t\t\t\t\t\tint target_data_len)\n{\n\tif (target_data_len < sizeof(struct pn533_target_type_b))\n\t\treturn false;\n\n\tif (type_b->sensb_res.opcode != PN533_TYPE_B_OPC_SENSB_RES)\n\t\treturn false;\n\n\tif (PN533_TYPE_B_PROT_TYPE(type_b->sensb_res.prot_info.fsci_type) &\n\t\t\t\t\t\tPN533_TYPE_B_PROT_TYPE_RFU_MASK)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int pn533_target_found_type_b(struct nfc_target *nfc_tgt, u8 *tgt_data,\n\t\t\t\t\t\t\tint tgt_data_len)\n{\n\tstruct pn533_target_type_b *tgt_type_b;\n\n\ttgt_type_b = (struct pn533_target_type_b *)tgt_data;\n\n\tif (!pn533_target_type_b_is_valid(tgt_type_b, tgt_data_len))\n\t\treturn -EPROTO;\n\n\tnfc_tgt->supported_protocols = NFC_PROTO_ISO14443_B_MASK;\n\n\treturn 0;\n}\n\nstatic void pn533_poll_reset_mod_list(struct pn533 *dev);\nstatic int pn533_target_found(struct pn533 *dev, u8 tg, u8 *tgdata,\n\t\t\t      int tgdata_len)\n{\n\tstruct nfc_target nfc_tgt;\n\tint rc;\n\n\tdev_dbg(dev->dev, \"%s: modulation=%d\\n\",\n\t\t__func__, dev->poll_mod_curr);\n\n\tif (tg != 1)\n\t\treturn -EPROTO;\n\n\tmemset(&nfc_tgt, 0, sizeof(struct nfc_target));\n\n\tswitch (dev->poll_mod_curr) {\n\tcase PN533_POLL_MOD_106KBPS_A:\n\t\trc = pn533_target_found_type_a(&nfc_tgt, tgdata, tgdata_len);\n\t\tbreak;\n\tcase PN533_POLL_MOD_212KBPS_FELICA:\n\tcase PN533_POLL_MOD_424KBPS_FELICA:\n\t\trc = pn533_target_found_felica(&nfc_tgt, tgdata, tgdata_len);\n\t\tbreak;\n\tcase PN533_POLL_MOD_106KBPS_JEWEL:\n\t\trc = pn533_target_found_jewel(&nfc_tgt, tgdata, tgdata_len);\n\t\tbreak;\n\tcase PN533_POLL_MOD_847KBPS_B:\n\t\trc = pn533_target_found_type_b(&nfc_tgt, tgdata, tgdata_len);\n\t\tbreak;\n\tdefault:\n\t\tnfc_err(dev->dev,\n\t\t\t\"Unknown current poll modulation\\n\");\n\t\treturn -EPROTO;\n\t}\n\n\tif (rc)\n\t\treturn rc;\n\n\tif (!(nfc_tgt.supported_protocols & dev->poll_protocols)) {\n\t\tdev_dbg(dev->dev,\n\t\t\t\"The Tg found doesn't have the desired protocol\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\tdev_dbg(dev->dev,\n\t\t\"Target found - supported protocols: 0x%x\\n\",\n\t\tnfc_tgt.supported_protocols);\n\n\tdev->tgt_available_prots = nfc_tgt.supported_protocols;\n\n\tpn533_poll_reset_mod_list(dev);\n\tnfc_targets_found(dev->nfc_dev, &nfc_tgt, 1);\n\n\treturn 0;\n}\n\nstatic inline void pn533_poll_next_mod(struct pn533 *dev)\n{\n\tdev->poll_mod_curr = (dev->poll_mod_curr + 1) % dev->poll_mod_count;\n}\n\nstatic void pn533_poll_reset_mod_list(struct pn533 *dev)\n{\n\tdev->poll_mod_count = 0;\n}\n\nstatic void pn533_poll_add_mod(struct pn533 *dev, u8 mod_index)\n{\n\tdev->poll_mod_active[dev->poll_mod_count] =\n\t\t(struct pn533_poll_modulations *)&poll_mod[mod_index];\n\tdev->poll_mod_count++;\n}\n\nstatic void pn533_poll_create_mod_list(struct pn533 *dev,\n\t\t\t\t       u32 im_protocols, u32 tm_protocols)\n{\n\tpn533_poll_reset_mod_list(dev);\n\n\tif ((im_protocols & NFC_PROTO_MIFARE_MASK) ||\n\t    (im_protocols & NFC_PROTO_ISO14443_MASK) ||\n\t    (im_protocols & NFC_PROTO_NFC_DEP_MASK))\n\t\tpn533_poll_add_mod(dev, PN533_POLL_MOD_106KBPS_A);\n\n\tif (im_protocols & NFC_PROTO_FELICA_MASK ||\n\t    im_protocols & NFC_PROTO_NFC_DEP_MASK) {\n\t\tpn533_poll_add_mod(dev, PN533_POLL_MOD_212KBPS_FELICA);\n\t\tpn533_poll_add_mod(dev, PN533_POLL_MOD_424KBPS_FELICA);\n\t}\n\n\tif (im_protocols & NFC_PROTO_JEWEL_MASK)\n\t\tpn533_poll_add_mod(dev, PN533_POLL_MOD_106KBPS_JEWEL);\n\n\tif (im_protocols & NFC_PROTO_ISO14443_B_MASK)\n\t\tpn533_poll_add_mod(dev, PN533_POLL_MOD_847KBPS_B);\n\n\tif (tm_protocols)\n\t\tpn533_poll_add_mod(dev, PN533_LISTEN_MOD);\n}\n\nstatic int pn533_start_poll_complete(struct pn533 *dev, struct sk_buff *resp)\n{\n\tu8 nbtg, tg, *tgdata;\n\tint rc, tgdata_len;\n\n\t \n\tif (dev->poll_protocols & NFC_PROTO_NFC_DEP_MASK)\n\t\tdev->poll_dep = 1;\n\n\tnbtg = resp->data[0];\n\ttg = resp->data[1];\n\ttgdata = &resp->data[2];\n\ttgdata_len = resp->len - 2;   \n\n\tif (nbtg) {\n\t\trc = pn533_target_found(dev, tg, tgdata, tgdata_len);\n\n\t\t \n\t\tif (rc == 0)\n\t\t\treturn 0;\n\t}\n\n\treturn -EAGAIN;\n}\n\nstatic struct sk_buff *pn533_alloc_poll_tg_frame(struct pn533 *dev)\n{\n\tstruct sk_buff *skb;\n\tu8 *felica, *nfcid3;\n\n\tu8 *gbytes = dev->gb;\n\tsize_t gbytes_len = dev->gb_len;\n\n\tu8 felica_params[18] = {0x1, 0xfe,  \n\t\t\t\t0x0, 0x0, 0x0, 0x0, 0x0, 0x0,  \n\t\t\t\t0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n\t\t\t\t0xff, 0xff};  \n\n\tu8 mifare_params[6] = {0x1, 0x1,  \n\t\t\t       0x0, 0x0, 0x0,\n\t\t\t       0x40};  \n\n\tunsigned int skb_len = 36 +  \n\t\t\t       gbytes_len +\n\t\t\t       1;   \n\n\tskb = pn533_alloc_skb(dev, skb_len);\n\tif (!skb)\n\t\treturn NULL;\n\n\t \n\tskb_put_u8(skb, PN533_INIT_TARGET_DEP);\n\n\t \n\tskb_put_data(skb, mifare_params, 6);\n\n\t \n\tfelica = skb_put_data(skb, felica_params, 18);\n\tget_random_bytes(felica + 2, 6);\n\n\t \n\tnfcid3 = skb_put_zero(skb, 10);\n\tmemcpy(nfcid3, felica, 8);\n\n\t \n\tskb_put_u8(skb, gbytes_len);\n\n\tskb_put_data(skb, gbytes, gbytes_len);\n\n\t \n\tskb_put_u8(skb, 0);\n\n\treturn skb;\n}\n\nstatic void pn533_wq_tm_mi_recv(struct work_struct *work);\nstatic struct sk_buff *pn533_build_response(struct pn533 *dev);\n\nstatic int pn533_tm_get_data_complete(struct pn533 *dev, void *arg,\n\t\t\t\t      struct sk_buff *resp)\n{\n\tstruct sk_buff *skb;\n\tu8 status, ret, mi;\n\tint rc;\n\n\tif (IS_ERR(resp)) {\n\t\tskb_queue_purge(&dev->resp_q);\n\t\treturn PTR_ERR(resp);\n\t}\n\n\tstatus = resp->data[0];\n\n\tret = status & PN533_CMD_RET_MASK;\n\tmi = status & PN533_CMD_MI_MASK;\n\n\tskb_pull(resp, sizeof(status));\n\n\tif (ret != PN533_CMD_RET_SUCCESS) {\n\t\trc = -EIO;\n\t\tgoto error;\n\t}\n\n\tskb_queue_tail(&dev->resp_q, resp);\n\n\tif (mi) {\n\t\tqueue_work(dev->wq, &dev->mi_tm_rx_work);\n\t\treturn -EINPROGRESS;\n\t}\n\n\tskb = pn533_build_response(dev);\n\tif (!skb) {\n\t\trc = -EIO;\n\t\tgoto error;\n\t}\n\n\treturn nfc_tm_data_received(dev->nfc_dev, skb);\n\nerror:\n\tnfc_tm_deactivated(dev->nfc_dev);\n\tdev->tgt_mode = 0;\n\tskb_queue_purge(&dev->resp_q);\n\tdev_kfree_skb(resp);\n\n\treturn rc;\n}\n\nstatic void pn533_wq_tm_mi_recv(struct work_struct *work)\n{\n\tstruct pn533 *dev = container_of(work, struct pn533, mi_tm_rx_work);\n\tstruct sk_buff *skb;\n\tint rc;\n\n\tskb = pn533_alloc_skb(dev, 0);\n\tif (!skb)\n\t\treturn;\n\n\trc = pn533_send_cmd_direct_async(dev,\n\t\t\t\t\tPN533_CMD_TG_GET_DATA,\n\t\t\t\t\tskb,\n\t\t\t\t\tpn533_tm_get_data_complete,\n\t\t\t\t\tNULL);\n\n\tif (rc < 0)\n\t\tdev_kfree_skb(skb);\n}\n\nstatic int pn533_tm_send_complete(struct pn533 *dev, void *arg,\n\t\t\t\t  struct sk_buff *resp);\nstatic void pn533_wq_tm_mi_send(struct work_struct *work)\n{\n\tstruct pn533 *dev = container_of(work, struct pn533, mi_tm_tx_work);\n\tstruct sk_buff *skb;\n\tint rc;\n\n\t \n\tskb = skb_dequeue(&dev->fragment_skb);\n\tif (skb == NULL) {\t \n\t\t \n\t\tskb_queue_head_init(&dev->fragment_skb);\n\t\tgoto error;\n\t}\n\n\t \n\tif (skb_queue_len(&dev->fragment_skb) == 0) {\n\t\trc = pn533_send_cmd_direct_async(dev, PN533_CMD_TG_SET_DATA,\n\t\t\t\t\tskb, pn533_tm_send_complete, NULL);\n\t} else\n\t\trc = pn533_send_cmd_direct_async(dev,\n\t\t\t\t\tPN533_CMD_TG_SET_META_DATA,\n\t\t\t\t\tskb, pn533_tm_send_complete, NULL);\n\n\tif (rc == 0)  \n\t\treturn;\n\n\tdev_err(dev->dev,\n\t\t\"Error %d when trying to perform set meta data_exchange\", rc);\n\n\tdev_kfree_skb(skb);\n\nerror:\n\tdev->phy_ops->send_ack(dev, GFP_KERNEL);\n\tqueue_work(dev->wq, &dev->cmd_work);\n}\n\nstatic void pn533_wq_tg_get_data(struct work_struct *work)\n{\n\tstruct pn533 *dev = container_of(work, struct pn533, tg_work);\n\tstruct sk_buff *skb;\n\tint rc;\n\n\tskb = pn533_alloc_skb(dev, 0);\n\tif (!skb)\n\t\treturn;\n\n\trc = pn533_send_data_async(dev, PN533_CMD_TG_GET_DATA, skb,\n\t\t\t\t   pn533_tm_get_data_complete, NULL);\n\n\tif (rc < 0)\n\t\tdev_kfree_skb(skb);\n}\n\n#define ATR_REQ_GB_OFFSET 17\nstatic int pn533_init_target_complete(struct pn533 *dev, struct sk_buff *resp)\n{\n\tu8 mode, *cmd, comm_mode = NFC_COMM_PASSIVE, *gb;\n\tsize_t gb_len;\n\tint rc;\n\n\tif (resp->len < ATR_REQ_GB_OFFSET + 1)\n\t\treturn -EINVAL;\n\n\tmode = resp->data[0];\n\tcmd = &resp->data[1];\n\n\tdev_dbg(dev->dev, \"Target mode 0x%x len %d\\n\",\n\t\tmode, resp->len);\n\n\tif ((mode & PN533_INIT_TARGET_RESP_FRAME_MASK) ==\n\t    PN533_INIT_TARGET_RESP_ACTIVE)\n\t\tcomm_mode = NFC_COMM_ACTIVE;\n\n\tif ((mode & PN533_INIT_TARGET_RESP_DEP) == 0)   \n\t\treturn -EOPNOTSUPP;\n\n\tgb = cmd + ATR_REQ_GB_OFFSET;\n\tgb_len = resp->len - (ATR_REQ_GB_OFFSET + 1);\n\n\trc = nfc_tm_activated(dev->nfc_dev, NFC_PROTO_NFC_DEP_MASK,\n\t\t\t      comm_mode, gb, gb_len);\n\tif (rc < 0) {\n\t\tnfc_err(dev->dev,\n\t\t\t\"Error when signaling target activation\\n\");\n\t\treturn rc;\n\t}\n\n\tdev->tgt_mode = 1;\n\tqueue_work(dev->wq, &dev->tg_work);\n\n\treturn 0;\n}\n\nstatic void pn533_listen_mode_timer(struct timer_list *t)\n{\n\tstruct pn533 *dev = from_timer(dev, t, listen_timer);\n\n\tdev->cancel_listen = 1;\n\n\tpn533_poll_next_mod(dev);\n\n\tqueue_delayed_work(dev->wq, &dev->poll_work,\n\t\t\t   msecs_to_jiffies(PN533_POLL_INTERVAL));\n}\n\nstatic int pn533_rf_complete(struct pn533 *dev, void *arg,\n\t\t\t     struct sk_buff *resp)\n{\n\tint rc = 0;\n\n\tif (IS_ERR(resp)) {\n\t\trc = PTR_ERR(resp);\n\n\t\tnfc_err(dev->dev, \"RF setting error %d\\n\", rc);\n\n\t\treturn rc;\n\t}\n\n\tqueue_delayed_work(dev->wq, &dev->poll_work,\n\t\t\t   msecs_to_jiffies(PN533_POLL_INTERVAL));\n\n\tdev_kfree_skb(resp);\n\treturn rc;\n}\n\nstatic void pn533_wq_rf(struct work_struct *work)\n{\n\tstruct pn533 *dev = container_of(work, struct pn533, rf_work);\n\tstruct sk_buff *skb;\n\tint rc;\n\n\tskb = pn533_alloc_skb(dev, 2);\n\tif (!skb)\n\t\treturn;\n\n\tskb_put_u8(skb, PN533_CFGITEM_RF_FIELD);\n\tskb_put_u8(skb, PN533_CFGITEM_RF_FIELD_AUTO_RFCA);\n\n\trc = pn533_send_cmd_async(dev, PN533_CMD_RF_CONFIGURATION, skb,\n\t\t\t\t  pn533_rf_complete, NULL);\n\tif (rc < 0) {\n\t\tdev_kfree_skb(skb);\n\t\tnfc_err(dev->dev, \"RF setting error %d\\n\", rc);\n\t}\n}\n\nstatic int pn533_poll_dep_complete(struct pn533 *dev, void *arg,\n\t\t\t\t   struct sk_buff *resp)\n{\n\tstruct pn533_cmd_jump_dep_response *rsp;\n\tstruct nfc_target nfc_target;\n\tu8 target_gt_len;\n\tint rc;\n\n\tif (IS_ERR(resp))\n\t\treturn PTR_ERR(resp);\n\n\tmemset(&nfc_target, 0, sizeof(struct nfc_target));\n\n\trsp = (struct pn533_cmd_jump_dep_response *)resp->data;\n\n\trc = rsp->status & PN533_CMD_RET_MASK;\n\tif (rc != PN533_CMD_RET_SUCCESS) {\n\t\t \n\t\tqueue_work(dev->wq, &dev->rf_work);\n\n\t\tdev_kfree_skb(resp);\n\t\treturn 0;\n\t}\n\n\tdev_dbg(dev->dev, \"Creating new target\");\n\n\tnfc_target.supported_protocols = NFC_PROTO_NFC_DEP_MASK;\n\tnfc_target.nfcid1_len = 10;\n\tmemcpy(nfc_target.nfcid1, rsp->nfcid3t, nfc_target.nfcid1_len);\n\trc = nfc_targets_found(dev->nfc_dev, &nfc_target, 1);\n\tif (rc)\n\t\tgoto error;\n\n\tdev->tgt_available_prots = 0;\n\tdev->tgt_active_prot = NFC_PROTO_NFC_DEP;\n\n\t \n\ttarget_gt_len = resp->len - 17;\n\trc = nfc_set_remote_general_bytes(dev->nfc_dev,\n\t\t\t\t\t  rsp->gt, target_gt_len);\n\tif (!rc) {\n\t\trc = nfc_dep_link_is_up(dev->nfc_dev,\n\t\t\t\t\tdev->nfc_dev->targets[0].idx,\n\t\t\t\t\t0, NFC_RF_INITIATOR);\n\n\t\tif (!rc)\n\t\t\tpn533_poll_reset_mod_list(dev);\n\t}\nerror:\n\tdev_kfree_skb(resp);\n\treturn rc;\n}\n\n#define PASSIVE_DATA_LEN 5\nstatic int pn533_poll_dep(struct nfc_dev *nfc_dev)\n{\n\tstruct pn533 *dev = nfc_get_drvdata(nfc_dev);\n\tstruct sk_buff *skb;\n\tint rc, skb_len;\n\tu8 *next, nfcid3[NFC_NFCID3_MAXSIZE];\n\tu8 passive_data[PASSIVE_DATA_LEN] = {0x00, 0xff, 0xff, 0x00, 0x3};\n\n\tif (!dev->gb) {\n\t\tdev->gb = nfc_get_local_general_bytes(nfc_dev, &dev->gb_len);\n\n\t\tif (!dev->gb || !dev->gb_len) {\n\t\t\tdev->poll_dep = 0;\n\t\t\tqueue_work(dev->wq, &dev->rf_work);\n\t\t}\n\t}\n\n\tskb_len = 3 + dev->gb_len;  \n\tskb_len += PASSIVE_DATA_LEN;\n\n\t \n\tskb_len += NFC_NFCID3_MAXSIZE;\n\tnfcid3[0] = 0x1;\n\tnfcid3[1] = 0xfe;\n\tget_random_bytes(nfcid3 + 2, 6);\n\n\tskb = pn533_alloc_skb(dev, skb_len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_put_u8(skb, 0x01);   \n\tskb_put_u8(skb, 0x02);   \n\n\tnext = skb_put(skb, 1);   \n\t*next = 0;\n\n\t \n\tskb_put_data(skb, passive_data, PASSIVE_DATA_LEN);\n\t*next |= 1;\n\n\t \n\tskb_put_data(skb, nfcid3, NFC_NFCID3_MAXSIZE);\n\t*next |= 2;\n\n\tskb_put_data(skb, dev->gb, dev->gb_len);\n\t*next |= 4;  \n\n\trc = pn533_send_cmd_async(dev, PN533_CMD_IN_JUMP_FOR_DEP, skb,\n\t\t\t\t  pn533_poll_dep_complete, NULL);\n\n\tif (rc < 0)\n\t\tdev_kfree_skb(skb);\n\n\treturn rc;\n}\n\nstatic int pn533_autopoll_complete(struct pn533 *dev, void *arg,\n\t\t\t       struct sk_buff *resp)\n{\n\tstruct pn532_autopoll_resp *apr;\n\tstruct nfc_target nfc_tgt;\n\tu8 nbtg;\n\tint rc;\n\n\tif (IS_ERR(resp)) {\n\t\trc = PTR_ERR(resp);\n\n\t\tnfc_err(dev->dev, \"%s  autopoll complete error %d\\n\",\n\t\t\t__func__, rc);\n\n\t\tif (rc == -ENOENT) {\n\t\t\tif (dev->poll_mod_count != 0)\n\t\t\t\treturn rc;\n\t\t\tgoto stop_poll;\n\t\t} else if (rc < 0) {\n\t\t\tnfc_err(dev->dev,\n\t\t\t\t\"Error %d when running autopoll\\n\", rc);\n\t\t\tgoto stop_poll;\n\t\t}\n\t}\n\n\tnbtg = resp->data[0];\n\tif ((nbtg > 2) || (nbtg <= 0))\n\t\treturn -EAGAIN;\n\n\tapr = (struct pn532_autopoll_resp *)&resp->data[1];\n\twhile (nbtg--) {\n\t\tmemset(&nfc_tgt, 0, sizeof(struct nfc_target));\n\t\tswitch (apr->type) {\n\t\tcase PN532_AUTOPOLL_TYPE_ISOA:\n\t\t\tdev_dbg(dev->dev, \"ISOA\\n\");\n\t\t\trc = pn533_target_found_type_a(&nfc_tgt, apr->tgdata,\n\t\t\t\t\t\t       apr->ln - 1);\n\t\t\tbreak;\n\t\tcase PN532_AUTOPOLL_TYPE_FELICA212:\n\t\tcase PN532_AUTOPOLL_TYPE_FELICA424:\n\t\t\tdev_dbg(dev->dev, \"FELICA\\n\");\n\t\t\trc = pn533_target_found_felica(&nfc_tgt, apr->tgdata,\n\t\t\t\t\t\t       apr->ln - 1);\n\t\t\tbreak;\n\t\tcase PN532_AUTOPOLL_TYPE_JEWEL:\n\t\t\tdev_dbg(dev->dev, \"JEWEL\\n\");\n\t\t\trc = pn533_target_found_jewel(&nfc_tgt, apr->tgdata,\n\t\t\t\t\t\t      apr->ln - 1);\n\t\t\tbreak;\n\t\tcase PN532_AUTOPOLL_TYPE_ISOB:\n\t\t\tdev_dbg(dev->dev, \"ISOB\\n\");\n\t\t\trc = pn533_target_found_type_b(&nfc_tgt, apr->tgdata,\n\t\t\t\t\t\t       apr->ln - 1);\n\t\t\tbreak;\n\t\tcase PN532_AUTOPOLL_TYPE_MIFARE:\n\t\t\tdev_dbg(dev->dev, \"Mifare\\n\");\n\t\t\trc = pn533_target_found_type_a(&nfc_tgt, apr->tgdata,\n\t\t\t\t\t\t       apr->ln - 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnfc_err(dev->dev,\n\t\t\t\t    \"Unknown current poll modulation\\n\");\n\t\t\trc = -EPROTO;\n\t\t}\n\n\t\tif (rc)\n\t\t\tgoto done;\n\n\t\tif (!(nfc_tgt.supported_protocols & dev->poll_protocols)) {\n\t\t\tnfc_err(dev->dev,\n\t\t\t\t    \"The Tg found doesn't have the desired protocol\\n\");\n\t\t\trc = -EAGAIN;\n\t\t\tgoto done;\n\t\t}\n\n\t\tdev->tgt_available_prots = nfc_tgt.supported_protocols;\n\t\tapr = (struct pn532_autopoll_resp *)\n\t\t\t(apr->tgdata + (apr->ln - 1));\n\t}\n\n\tpn533_poll_reset_mod_list(dev);\n\tnfc_targets_found(dev->nfc_dev, &nfc_tgt, 1);\n\ndone:\n\tdev_kfree_skb(resp);\n\treturn rc;\n\nstop_poll:\n\tnfc_err(dev->dev, \"autopoll operation has been stopped\\n\");\n\n\tpn533_poll_reset_mod_list(dev);\n\tdev->poll_protocols = 0;\n\treturn rc;\n}\n\nstatic int pn533_poll_complete(struct pn533 *dev, void *arg,\n\t\t\t       struct sk_buff *resp)\n{\n\tstruct pn533_poll_modulations *cur_mod;\n\tint rc;\n\n\tif (IS_ERR(resp)) {\n\t\trc = PTR_ERR(resp);\n\n\t\tnfc_err(dev->dev, \"%s  Poll complete error %d\\n\",\n\t\t\t__func__, rc);\n\n\t\tif (rc == -ENOENT) {\n\t\t\tif (dev->poll_mod_count != 0)\n\t\t\t\treturn rc;\n\t\t\tgoto stop_poll;\n\t\t} else if (rc < 0) {\n\t\t\tnfc_err(dev->dev,\n\t\t\t\t\"Error %d when running poll\\n\", rc);\n\t\t\tgoto stop_poll;\n\t\t}\n\t}\n\n\tcur_mod = dev->poll_mod_active[dev->poll_mod_curr];\n\n\tif (cur_mod->len == 0) {  \n\t\tdel_timer(&dev->listen_timer);\n\t\trc = pn533_init_target_complete(dev, resp);\n\t\tgoto done;\n\t}\n\n\t \n\trc = pn533_start_poll_complete(dev, resp);\n\tif (!rc)\n\t\tgoto done;\n\n\tif (!dev->poll_mod_count) {\n\t\tdev_dbg(dev->dev, \"Polling has been stopped\\n\");\n\t\tgoto done;\n\t}\n\n\tpn533_poll_next_mod(dev);\n\t \n\tqueue_work(dev->wq, &dev->rf_work);\n\ndone:\n\tdev_kfree_skb(resp);\n\treturn rc;\n\nstop_poll:\n\tnfc_err(dev->dev, \"Polling operation has been stopped\\n\");\n\n\tpn533_poll_reset_mod_list(dev);\n\tdev->poll_protocols = 0;\n\treturn rc;\n}\n\nstatic struct sk_buff *pn533_alloc_poll_in_frame(struct pn533 *dev,\n\t\t\t\t\tstruct pn533_poll_modulations *mod)\n{\n\tstruct sk_buff *skb;\n\n\tskb = pn533_alloc_skb(dev, mod->len);\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_put_data(skb, &mod->data, mod->len);\n\n\treturn skb;\n}\n\nstatic int pn533_send_poll_frame(struct pn533 *dev)\n{\n\tstruct pn533_poll_modulations *mod;\n\tstruct sk_buff *skb;\n\tint rc;\n\tu8 cmd_code;\n\n\tmod = dev->poll_mod_active[dev->poll_mod_curr];\n\n\tdev_dbg(dev->dev, \"%s mod len %d\\n\",\n\t\t__func__, mod->len);\n\n\tif ((dev->poll_protocols & NFC_PROTO_NFC_DEP_MASK) && dev->poll_dep)  {\n\t\tdev->poll_dep = 0;\n\t\treturn pn533_poll_dep(dev->nfc_dev);\n\t}\n\n\tif (mod->len == 0) {   \n\t\tcmd_code = PN533_CMD_TG_INIT_AS_TARGET;\n\t\tskb = pn533_alloc_poll_tg_frame(dev);\n\t} else {   \n\t\tcmd_code =  PN533_CMD_IN_LIST_PASSIVE_TARGET;\n\t\tskb = pn533_alloc_poll_in_frame(dev, mod);\n\t}\n\n\tif (!skb) {\n\t\tnfc_err(dev->dev, \"Failed to allocate skb\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\trc = pn533_send_cmd_async(dev, cmd_code, skb, pn533_poll_complete,\n\t\t\t\t  NULL);\n\tif (rc < 0) {\n\t\tdev_kfree_skb(skb);\n\t\tnfc_err(dev->dev, \"Polling loop error %d\\n\", rc);\n\t}\n\n\treturn rc;\n}\n\nstatic void pn533_wq_poll(struct work_struct *work)\n{\n\tstruct pn533 *dev = container_of(work, struct pn533, poll_work.work);\n\tstruct pn533_poll_modulations *cur_mod;\n\tint rc;\n\n\tcur_mod = dev->poll_mod_active[dev->poll_mod_curr];\n\n\tdev_dbg(dev->dev,\n\t\t\"%s cancel_listen %d modulation len %d\\n\",\n\t\t__func__, dev->cancel_listen, cur_mod->len);\n\n\tif (dev->cancel_listen == 1) {\n\t\tdev->cancel_listen = 0;\n\t\tdev->phy_ops->abort_cmd(dev, GFP_ATOMIC);\n\t}\n\n\trc = pn533_send_poll_frame(dev);\n\tif (rc)\n\t\treturn;\n\n\tif (cur_mod->len == 0 && dev->poll_mod_count > 1)\n\t\tmod_timer(&dev->listen_timer, jiffies + PN533_LISTEN_TIME * HZ);\n}\n\nstatic int pn533_start_poll(struct nfc_dev *nfc_dev,\n\t\t\t    u32 im_protocols, u32 tm_protocols)\n{\n\tstruct pn533 *dev = nfc_get_drvdata(nfc_dev);\n\tstruct pn533_poll_modulations *cur_mod;\n\tstruct sk_buff *skb;\n\tu8 rand_mod;\n\tint rc;\n\n\tdev_dbg(dev->dev,\n\t\t\"%s: im protocols 0x%x tm protocols 0x%x\\n\",\n\t\t__func__, im_protocols, tm_protocols);\n\n\tif (dev->tgt_active_prot) {\n\t\tnfc_err(dev->dev,\n\t\t\t\"Cannot poll with a target already activated\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (dev->tgt_mode) {\n\t\tnfc_err(dev->dev,\n\t\t\t\"Cannot poll while already being activated\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (tm_protocols) {\n\t\tdev->gb = nfc_get_local_general_bytes(nfc_dev, &dev->gb_len);\n\t\tif (dev->gb == NULL)\n\t\t\ttm_protocols = 0;\n\t}\n\n\tdev->poll_protocols = im_protocols;\n\tdev->listen_protocols = tm_protocols;\n\tif (dev->device_type == PN533_DEVICE_PN532_AUTOPOLL) {\n\t\tskb = pn533_alloc_skb(dev, 4 + 6);\n\t\tif (!skb)\n\t\t\treturn -ENOMEM;\n\n\t\t*((u8 *)skb_put(skb, sizeof(u8))) =\n\t\t\tPN532_AUTOPOLL_POLLNR_INFINITE;\n\t\t*((u8 *)skb_put(skb, sizeof(u8))) = PN532_AUTOPOLL_PERIOD;\n\n\t\tif ((im_protocols & NFC_PROTO_MIFARE_MASK) &&\n\t\t\t\t(im_protocols & NFC_PROTO_ISO14443_MASK) &&\n\t\t\t\t(im_protocols & NFC_PROTO_NFC_DEP_MASK))\n\t\t\t*((u8 *)skb_put(skb, sizeof(u8))) =\n\t\t\t\tPN532_AUTOPOLL_TYPE_GENERIC_106;\n\t\telse {\n\t\t\tif (im_protocols & NFC_PROTO_MIFARE_MASK)\n\t\t\t\t*((u8 *)skb_put(skb, sizeof(u8))) =\n\t\t\t\t\tPN532_AUTOPOLL_TYPE_MIFARE;\n\n\t\t\tif (im_protocols & NFC_PROTO_ISO14443_MASK)\n\t\t\t\t*((u8 *)skb_put(skb, sizeof(u8))) =\n\t\t\t\t\tPN532_AUTOPOLL_TYPE_ISOA;\n\n\t\t\tif (im_protocols & NFC_PROTO_NFC_DEP_MASK) {\n\t\t\t\t*((u8 *)skb_put(skb, sizeof(u8))) =\n\t\t\t\t\tPN532_AUTOPOLL_TYPE_DEP_PASSIVE_106;\n\t\t\t\t*((u8 *)skb_put(skb, sizeof(u8))) =\n\t\t\t\t\tPN532_AUTOPOLL_TYPE_DEP_PASSIVE_212;\n\t\t\t\t*((u8 *)skb_put(skb, sizeof(u8))) =\n\t\t\t\t\tPN532_AUTOPOLL_TYPE_DEP_PASSIVE_424;\n\t\t\t}\n\t\t}\n\n\t\tif (im_protocols & NFC_PROTO_FELICA_MASK ||\n\t\t\t\tim_protocols & NFC_PROTO_NFC_DEP_MASK) {\n\t\t\t*((u8 *)skb_put(skb, sizeof(u8))) =\n\t\t\t\tPN532_AUTOPOLL_TYPE_FELICA212;\n\t\t\t*((u8 *)skb_put(skb, sizeof(u8))) =\n\t\t\t\tPN532_AUTOPOLL_TYPE_FELICA424;\n\t\t}\n\n\t\tif (im_protocols & NFC_PROTO_JEWEL_MASK)\n\t\t\t*((u8 *)skb_put(skb, sizeof(u8))) =\n\t\t\t\tPN532_AUTOPOLL_TYPE_JEWEL;\n\n\t\tif (im_protocols & NFC_PROTO_ISO14443_B_MASK)\n\t\t\t*((u8 *)skb_put(skb, sizeof(u8))) =\n\t\t\t\tPN532_AUTOPOLL_TYPE_ISOB;\n\n\t\tif (tm_protocols)\n\t\t\t*((u8 *)skb_put(skb, sizeof(u8))) =\n\t\t\t\tPN532_AUTOPOLL_TYPE_DEP_ACTIVE_106;\n\n\t\trc = pn533_send_cmd_async(dev, PN533_CMD_IN_AUTOPOLL, skb,\n\t\t\t\tpn533_autopoll_complete, NULL);\n\n\t\tif (rc < 0)\n\t\t\tdev_kfree_skb(skb);\n\t\telse\n\t\t\tdev->poll_mod_count++;\n\n\t\treturn rc;\n\t}\n\n\tpn533_poll_create_mod_list(dev, im_protocols, tm_protocols);\n\n\t \n\tget_random_bytes(&rand_mod, sizeof(rand_mod));\n\trand_mod %= dev->poll_mod_count;\n\tdev->poll_mod_curr = rand_mod;\n\n\tcur_mod = dev->poll_mod_active[dev->poll_mod_curr];\n\n\trc = pn533_send_poll_frame(dev);\n\n\t \n\tif (!rc && cur_mod->len == 0 && dev->poll_mod_count > 1)\n\t\tmod_timer(&dev->listen_timer, jiffies + PN533_LISTEN_TIME * HZ);\n\n\treturn rc;\n}\n\nstatic void pn533_stop_poll(struct nfc_dev *nfc_dev)\n{\n\tstruct pn533 *dev = nfc_get_drvdata(nfc_dev);\n\n\tdel_timer(&dev->listen_timer);\n\n\tif (!dev->poll_mod_count) {\n\t\tdev_dbg(dev->dev,\n\t\t\t\"Polling operation was not running\\n\");\n\t\treturn;\n\t}\n\n\tdev->phy_ops->abort_cmd(dev, GFP_KERNEL);\n\tflush_delayed_work(&dev->poll_work);\n\tpn533_poll_reset_mod_list(dev);\n}\n\nstatic int pn533_activate_target_nfcdep(struct pn533 *dev)\n{\n\tstruct pn533_cmd_activate_response *rsp;\n\tu16 gt_len;\n\tint rc;\n\tstruct sk_buff *skb;\n\tstruct sk_buff *resp;\n\n\tskb = pn533_alloc_skb(dev, sizeof(u8) * 2);  \n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_put_u8(skb, 1);  \n\tskb_put_u8(skb, 0);  \n\n\tresp = pn533_send_cmd_sync(dev, PN533_CMD_IN_ATR, skb);\n\tif (IS_ERR(resp))\n\t\treturn PTR_ERR(resp);\n\n\trsp = (struct pn533_cmd_activate_response *)resp->data;\n\trc = rsp->status & PN533_CMD_RET_MASK;\n\tif (rc != PN533_CMD_RET_SUCCESS) {\n\t\tnfc_err(dev->dev,\n\t\t\t\"Target activation failed (error 0x%x)\\n\", rc);\n\t\tdev_kfree_skb(resp);\n\t\treturn -EIO;\n\t}\n\n\t \n\tgt_len = resp->len - 16;\n\trc = nfc_set_remote_general_bytes(dev->nfc_dev, rsp->gt, gt_len);\n\n\tdev_kfree_skb(resp);\n\treturn rc;\n}\n\nstatic int pn533_activate_target(struct nfc_dev *nfc_dev,\n\t\t\t\t struct nfc_target *target, u32 protocol)\n{\n\tstruct pn533 *dev = nfc_get_drvdata(nfc_dev);\n\tint rc;\n\n\tdev_dbg(dev->dev, \"%s: protocol=%u\\n\", __func__, protocol);\n\n\tif (dev->poll_mod_count) {\n\t\tnfc_err(dev->dev,\n\t\t\t\"Cannot activate while polling\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (dev->tgt_active_prot) {\n\t\tnfc_err(dev->dev,\n\t\t\t\"There is already an active target\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (!dev->tgt_available_prots) {\n\t\tnfc_err(dev->dev,\n\t\t\t\"There is no available target to activate\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!(dev->tgt_available_prots & (1 << protocol))) {\n\t\tnfc_err(dev->dev,\n\t\t\t\"Target doesn't support requested proto %u\\n\",\n\t\t\tprotocol);\n\t\treturn -EINVAL;\n\t}\n\n\tif (protocol == NFC_PROTO_NFC_DEP) {\n\t\trc = pn533_activate_target_nfcdep(dev);\n\t\tif (rc) {\n\t\t\tnfc_err(dev->dev,\n\t\t\t\t\"Activating target with DEP failed %d\\n\", rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\tdev->tgt_active_prot = protocol;\n\tdev->tgt_available_prots = 0;\n\n\treturn 0;\n}\n\nstatic int pn533_deactivate_target_complete(struct pn533 *dev, void *arg,\n\t\t\t     struct sk_buff *resp)\n{\n\tint rc = 0;\n\n\tif (IS_ERR(resp)) {\n\t\trc = PTR_ERR(resp);\n\n\t\tnfc_err(dev->dev, \"Target release error %d\\n\", rc);\n\n\t\treturn rc;\n\t}\n\n\trc = resp->data[0] & PN533_CMD_RET_MASK;\n\tif (rc != PN533_CMD_RET_SUCCESS)\n\t\tnfc_err(dev->dev,\n\t\t\t\"Error 0x%x when releasing the target\\n\", rc);\n\n\tdev_kfree_skb(resp);\n\treturn rc;\n}\n\nstatic void pn533_deactivate_target(struct nfc_dev *nfc_dev,\n\t\t\t\t    struct nfc_target *target, u8 mode)\n{\n\tstruct pn533 *dev = nfc_get_drvdata(nfc_dev);\n\tstruct sk_buff *skb;\n\tint rc;\n\n\tif (!dev->tgt_active_prot) {\n\t\tnfc_err(dev->dev, \"There is no active target\\n\");\n\t\treturn;\n\t}\n\n\tdev->tgt_active_prot = 0;\n\tskb_queue_purge(&dev->resp_q);\n\n\tskb = pn533_alloc_skb(dev, sizeof(u8));\n\tif (!skb)\n\t\treturn;\n\n\tskb_put_u8(skb, 1);  \n\n\trc = pn533_send_cmd_async(dev, PN533_CMD_IN_RELEASE, skb,\n\t\t\t\t  pn533_deactivate_target_complete, NULL);\n\tif (rc < 0) {\n\t\tdev_kfree_skb(skb);\n\t\tnfc_err(dev->dev, \"Target release error %d\\n\", rc);\n\t}\n}\n\n\nstatic int pn533_in_dep_link_up_complete(struct pn533 *dev, void *arg,\n\t\t\t\t\t struct sk_buff *resp)\n{\n\tstruct pn533_cmd_jump_dep_response *rsp;\n\tu8 target_gt_len;\n\tint rc;\n\tu8 active = *(u8 *)arg;\n\n\tkfree(arg);\n\n\tif (IS_ERR(resp))\n\t\treturn PTR_ERR(resp);\n\n\tif (dev->tgt_available_prots &&\n\t    !(dev->tgt_available_prots & (1 << NFC_PROTO_NFC_DEP))) {\n\t\tnfc_err(dev->dev,\n\t\t\t\"The target does not support DEP\\n\");\n\t\trc =  -EINVAL;\n\t\tgoto error;\n\t}\n\n\trsp = (struct pn533_cmd_jump_dep_response *)resp->data;\n\n\trc = rsp->status & PN533_CMD_RET_MASK;\n\tif (rc != PN533_CMD_RET_SUCCESS) {\n\t\tnfc_err(dev->dev,\n\t\t\t\"Bringing DEP link up failed (error 0x%x)\\n\", rc);\n\t\tgoto error;\n\t}\n\n\tif (!dev->tgt_available_prots) {\n\t\tstruct nfc_target nfc_target;\n\n\t\tdev_dbg(dev->dev, \"Creating new target\\n\");\n\n\t\tmemset(&nfc_target, 0, sizeof(struct nfc_target));\n\n\t\tnfc_target.supported_protocols = NFC_PROTO_NFC_DEP_MASK;\n\t\tnfc_target.nfcid1_len = 10;\n\t\tmemcpy(nfc_target.nfcid1, rsp->nfcid3t, nfc_target.nfcid1_len);\n\t\trc = nfc_targets_found(dev->nfc_dev, &nfc_target, 1);\n\t\tif (rc)\n\t\t\tgoto error;\n\n\t\tdev->tgt_available_prots = 0;\n\t}\n\n\tdev->tgt_active_prot = NFC_PROTO_NFC_DEP;\n\n\t \n\ttarget_gt_len = resp->len - 17;\n\trc = nfc_set_remote_general_bytes(dev->nfc_dev,\n\t\t\t\t\t  rsp->gt, target_gt_len);\n\tif (rc == 0)\n\t\trc = nfc_dep_link_is_up(dev->nfc_dev,\n\t\t\t\t\tdev->nfc_dev->targets[0].idx,\n\t\t\t\t\t!active, NFC_RF_INITIATOR);\n\nerror:\n\tdev_kfree_skb(resp);\n\treturn rc;\n}\n\nstatic int pn533_rf_field(struct nfc_dev *nfc_dev, u8 rf);\nstatic int pn533_dep_link_up(struct nfc_dev *nfc_dev, struct nfc_target *target,\n\t\t\t     u8 comm_mode, u8 *gb, size_t gb_len)\n{\n\tstruct pn533 *dev = nfc_get_drvdata(nfc_dev);\n\tstruct sk_buff *skb;\n\tint rc, skb_len;\n\tu8 *next, *arg, nfcid3[NFC_NFCID3_MAXSIZE];\n\tu8 passive_data[PASSIVE_DATA_LEN] = {0x00, 0xff, 0xff, 0x00, 0x3};\n\n\tif (dev->poll_mod_count) {\n\t\tnfc_err(dev->dev,\n\t\t\t\"Cannot bring the DEP link up while polling\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (dev->tgt_active_prot) {\n\t\tnfc_err(dev->dev,\n\t\t\t\"There is already an active target\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tskb_len = 3 + gb_len;  \n\tskb_len += PASSIVE_DATA_LEN;\n\n\t \n\tskb_len += NFC_NFCID3_MAXSIZE;\n\tif (target && !target->nfcid2_len) {\n\t\tnfcid3[0] = 0x1;\n\t\tnfcid3[1] = 0xfe;\n\t\tget_random_bytes(nfcid3 + 2, 6);\n\t}\n\n\tskb = pn533_alloc_skb(dev, skb_len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_put_u8(skb, !comm_mode);   \n\tskb_put_u8(skb, 0x02);   \n\n\tnext = skb_put(skb, 1);   \n\t*next = 0;\n\n\t \n\tskb_put_data(skb, passive_data, PASSIVE_DATA_LEN);\n\t*next |= 1;\n\n\t \n\tif (target && target->nfcid2_len)\n\t\tmemcpy(skb_put(skb, NFC_NFCID3_MAXSIZE), target->nfcid2,\n\t\t       target->nfcid2_len);\n\telse\n\t\tskb_put_data(skb, nfcid3, NFC_NFCID3_MAXSIZE);\n\t*next |= 2;\n\n\tif (gb != NULL && gb_len > 0) {\n\t\tskb_put_data(skb, gb, gb_len);\n\t\t*next |= 4;  \n\t} else {\n\t\t*next = 0;\n\t}\n\n\targ = kmalloc(sizeof(*arg), GFP_KERNEL);\n\tif (!arg) {\n\t\tdev_kfree_skb(skb);\n\t\treturn -ENOMEM;\n\t}\n\n\t*arg = !comm_mode;\n\n\tpn533_rf_field(dev->nfc_dev, 0);\n\n\trc = pn533_send_cmd_async(dev, PN533_CMD_IN_JUMP_FOR_DEP, skb,\n\t\t\t\t  pn533_in_dep_link_up_complete, arg);\n\n\tif (rc < 0) {\n\t\tdev_kfree_skb(skb);\n\t\tkfree(arg);\n\t}\n\n\treturn rc;\n}\n\nstatic int pn533_dep_link_down(struct nfc_dev *nfc_dev)\n{\n\tstruct pn533 *dev = nfc_get_drvdata(nfc_dev);\n\n\tpn533_poll_reset_mod_list(dev);\n\n\tif (dev->tgt_mode || dev->tgt_active_prot)\n\t\tdev->phy_ops->abort_cmd(dev, GFP_KERNEL);\n\n\tdev->tgt_active_prot = 0;\n\tdev->tgt_mode = 0;\n\n\tskb_queue_purge(&dev->resp_q);\n\n\treturn 0;\n}\n\nstruct pn533_data_exchange_arg {\n\tdata_exchange_cb_t cb;\n\tvoid *cb_context;\n};\n\nstatic struct sk_buff *pn533_build_response(struct pn533 *dev)\n{\n\tstruct sk_buff *skb, *tmp, *t;\n\tunsigned int skb_len = 0, tmp_len = 0;\n\n\tif (skb_queue_empty(&dev->resp_q))\n\t\treturn NULL;\n\n\tif (skb_queue_len(&dev->resp_q) == 1) {\n\t\tskb = skb_dequeue(&dev->resp_q);\n\t\tgoto out;\n\t}\n\n\tskb_queue_walk_safe(&dev->resp_q, tmp, t)\n\t\tskb_len += tmp->len;\n\n\tdev_dbg(dev->dev, \"%s total length %d\\n\",\n\t\t__func__, skb_len);\n\n\tskb = alloc_skb(skb_len, GFP_KERNEL);\n\tif (skb == NULL)\n\t\tgoto out;\n\n\tskb_put(skb, skb_len);\n\n\tskb_queue_walk_safe(&dev->resp_q, tmp, t) {\n\t\tmemcpy(skb->data + tmp_len, tmp->data, tmp->len);\n\t\ttmp_len += tmp->len;\n\t}\n\nout:\n\tskb_queue_purge(&dev->resp_q);\n\n\treturn skb;\n}\n\nstatic int pn533_data_exchange_complete(struct pn533 *dev, void *_arg,\n\t\t\t\t\tstruct sk_buff *resp)\n{\n\tstruct pn533_data_exchange_arg *arg = _arg;\n\tstruct sk_buff *skb;\n\tint rc = 0;\n\tu8 status, ret, mi;\n\n\tif (IS_ERR(resp)) {\n\t\trc = PTR_ERR(resp);\n\t\tgoto _error;\n\t}\n\n\tstatus = resp->data[0];\n\tret = status & PN533_CMD_RET_MASK;\n\tmi = status & PN533_CMD_MI_MASK;\n\n\tskb_pull(resp, sizeof(status));\n\n\tif (ret != PN533_CMD_RET_SUCCESS) {\n\t\tnfc_err(dev->dev,\n\t\t\t\"Exchanging data failed (error 0x%x)\\n\", ret);\n\t\trc = -EIO;\n\t\tgoto error;\n\t}\n\n\tskb_queue_tail(&dev->resp_q, resp);\n\n\tif (mi) {\n\t\tdev->cmd_complete_mi_arg = arg;\n\t\tqueue_work(dev->wq, &dev->mi_rx_work);\n\t\treturn -EINPROGRESS;\n\t}\n\n\t \n\tif (skb_queue_len(&dev->fragment_skb) > 0) {\n\t\tdev->cmd_complete_dep_arg = arg;\n\t\tqueue_work(dev->wq, &dev->mi_tx_work);\n\n\t\treturn -EINPROGRESS;\n\t}\n\n\tskb = pn533_build_response(dev);\n\tif (!skb) {\n\t\trc = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\targ->cb(arg->cb_context, skb, 0);\n\tkfree(arg);\n\treturn 0;\n\nerror:\n\tdev_kfree_skb(resp);\n_error:\n\tskb_queue_purge(&dev->resp_q);\n\targ->cb(arg->cb_context, NULL, rc);\n\tkfree(arg);\n\treturn rc;\n}\n\n \nvoid pn533_recv_frame(struct pn533 *dev, struct sk_buff *skb, int status)\n{\n\tif (!dev->cmd)\n\t\tgoto sched_wq;\n\n\tdev->cmd->status = status;\n\n\tif (status != 0) {\n\t\tdev_dbg(dev->dev, \"%s: Error received: %d\\n\", __func__, status);\n\t\tgoto sched_wq;\n\t}\n\n\tif (skb == NULL) {\n\t\tdev_err(dev->dev, \"NULL Frame -> link is dead\\n\");\n\t\tgoto sched_wq;\n\t}\n\n\tif (pn533_rx_frame_is_ack(skb->data)) {\n\t\tdev_dbg(dev->dev, \"%s: Received ACK frame\\n\", __func__);\n\t\tdev_kfree_skb(skb);\n\t\treturn;\n\t}\n\n\tprint_hex_dump_debug(\"PN533 RX: \", DUMP_PREFIX_NONE, 16, 1, skb->data,\n\t\t\t     dev->ops->rx_frame_size(skb->data), false);\n\n\tif (!dev->ops->rx_is_frame_valid(skb->data, dev)) {\n\t\tnfc_err(dev->dev, \"Received an invalid frame\\n\");\n\t\tdev->cmd->status = -EIO;\n\t} else if (!pn533_rx_frame_is_cmd_response(dev, skb->data)) {\n\t\tnfc_err(dev->dev, \"It it not the response to the last command\\n\");\n\t\tdev->cmd->status = -EIO;\n\t}\n\n\tdev->cmd->resp = skb;\n\nsched_wq:\n\tqueue_work(dev->wq, &dev->cmd_complete_work);\n}\nEXPORT_SYMBOL(pn533_recv_frame);\n\n \nstatic int pn533_fill_fragment_skbs(struct pn533 *dev, struct sk_buff *skb)\n{\n\tstruct sk_buff *frag;\n\tint  frag_size;\n\n\tdo {\n\t\t \n\t\tif (skb->len > PN533_CMD_DATAFRAME_MAXLEN)\n\t\t\tfrag_size = PN533_CMD_DATAFRAME_MAXLEN;\n\t\telse\n\t\t\tfrag_size = skb->len;\n\n\t\t \n\t\tfrag = pn533_alloc_skb(dev, frag_size);\n\t\tif (!frag) {\n\t\t\tskb_queue_purge(&dev->fragment_skb);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (!dev->tgt_mode) {\n\t\t\t \n\t\t\tskb_reserve(frag, 1);\n\n\t\t\t \n\t\t\tif (frag_size  == PN533_CMD_DATAFRAME_MAXLEN)\n\t\t\t\t*(u8 *)skb_push(frag, sizeof(u8)) =\n\t\t\t\t\t\t(PN533_CMD_MI_MASK | 1);\n\t\t\telse\n\t\t\t\t*(u8 *)skb_push(frag, sizeof(u8)) =  1;  \n\t\t}\n\n\t\tskb_put_data(frag, skb->data, frag_size);\n\n\t\t \n\t\tskb_pull(skb, frag_size);\n\n\t\t \n\t\tskb_queue_tail(&dev->fragment_skb, frag);\n\n\t} while (skb->len > 0);\n\n\tdev_kfree_skb(skb);\n\n\treturn skb_queue_len(&dev->fragment_skb);\n}\n\nstatic int pn533_transceive(struct nfc_dev *nfc_dev,\n\t\t\t    struct nfc_target *target, struct sk_buff *skb,\n\t\t\t    data_exchange_cb_t cb, void *cb_context)\n{\n\tstruct pn533 *dev = nfc_get_drvdata(nfc_dev);\n\tstruct pn533_data_exchange_arg *arg = NULL;\n\tint rc;\n\n\tif (!dev->tgt_active_prot) {\n\t\tnfc_err(dev->dev,\n\t\t\t\"Can't exchange data if there is no active target\\n\");\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\n\targ = kmalloc(sizeof(*arg), GFP_KERNEL);\n\tif (!arg) {\n\t\trc = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\targ->cb = cb;\n\targ->cb_context = cb_context;\n\n\tswitch (dev->device_type) {\n\tcase PN533_DEVICE_PASORI:\n\t\tif (dev->tgt_active_prot == NFC_PROTO_FELICA) {\n\t\t\trc = pn533_send_data_async(dev, PN533_CMD_IN_COMM_THRU,\n\t\t\t\t\t\t   skb,\n\t\t\t\t\t\t   pn533_data_exchange_complete,\n\t\t\t\t\t\t   arg);\n\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\t \n\t\tif (skb->len > PN533_CMD_DATAEXCH_DATA_MAXLEN) {\n\t\t\trc = pn533_fill_fragment_skbs(dev, skb);\n\t\t\tif (rc < 0)\n\t\t\t\tgoto error;\n\n\t\t\tskb = skb_dequeue(&dev->fragment_skb);\n\t\t\tif (!skb) {\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t} else {\n\t\t\t*(u8 *)skb_push(skb, sizeof(u8)) =  1;  \n\t\t}\n\n\t\trc = pn533_send_data_async(dev, PN533_CMD_IN_DATA_EXCHANGE,\n\t\t\t\t\t   skb, pn533_data_exchange_complete,\n\t\t\t\t\t   arg);\n\n\t\tbreak;\n\t}\n\n\tif (rc < 0)  \n\t\tgoto error;\n\n\treturn 0;\n\nerror:\n\tkfree(arg);\n\tdev_kfree_skb(skb);\n\treturn rc;\n}\n\nstatic int pn533_tm_send_complete(struct pn533 *dev, void *arg,\n\t\t\t\t  struct sk_buff *resp)\n{\n\tu8 status;\n\n\tif (IS_ERR(resp))\n\t\treturn PTR_ERR(resp);\n\n\tstatus = resp->data[0];\n\n\t \n\tif (skb_queue_len(&dev->fragment_skb) > 0) {\n\t\tqueue_work(dev->wq, &dev->mi_tm_tx_work);\n\t\treturn -EINPROGRESS;\n\t}\n\tdev_kfree_skb(resp);\n\n\tif (status != 0) {\n\t\tnfc_tm_deactivated(dev->nfc_dev);\n\n\t\tdev->tgt_mode = 0;\n\n\t\treturn 0;\n\t}\n\n\tqueue_work(dev->wq, &dev->tg_work);\n\n\treturn 0;\n}\n\nstatic int pn533_tm_send(struct nfc_dev *nfc_dev, struct sk_buff *skb)\n{\n\tstruct pn533 *dev = nfc_get_drvdata(nfc_dev);\n\tint rc;\n\n\t \n\tif (skb->len > PN533_CMD_DATAEXCH_DATA_MAXLEN) {\n\t\trc = pn533_fill_fragment_skbs(dev, skb);\n\t\tif (rc < 0)\n\t\t\tgoto error;\n\n\t\t \n\t\tskb = skb_dequeue(&dev->fragment_skb);\n\t\tif (!skb) {\n\t\t\trc = -EIO;\n\t\t\tgoto error;\n\t\t}\n\n\t\trc = pn533_send_data_async(dev, PN533_CMD_TG_SET_META_DATA, skb,\n\t\t\t\t\t\tpn533_tm_send_complete, NULL);\n\t} else {\n\t\t \n\t\trc = pn533_send_data_async(dev, PN533_CMD_TG_SET_DATA, skb,\n\t\t\t\t\t\tpn533_tm_send_complete, NULL);\n\t}\n\nerror:\n\tif (rc < 0) {\n\t\tdev_kfree_skb(skb);\n\t\tskb_queue_purge(&dev->fragment_skb);\n\t}\n\n\treturn rc;\n}\n\nstatic void pn533_wq_mi_recv(struct work_struct *work)\n{\n\tstruct pn533 *dev = container_of(work, struct pn533, mi_rx_work);\n\tstruct sk_buff *skb;\n\tint rc;\n\n\tskb = pn533_alloc_skb(dev, PN533_CMD_DATAEXCH_HEAD_LEN);\n\tif (!skb)\n\t\tgoto error;\n\n\tswitch (dev->device_type) {\n\tcase PN533_DEVICE_PASORI:\n\t\tif (dev->tgt_active_prot == NFC_PROTO_FELICA) {\n\t\t\trc = pn533_send_cmd_direct_async(dev,\n\t\t\t\t\t\tPN533_CMD_IN_COMM_THRU,\n\t\t\t\t\t\tskb,\n\t\t\t\t\t\tpn533_data_exchange_complete,\n\t\t\t\t\t\t dev->cmd_complete_mi_arg);\n\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tskb_put_u8(skb, 1);  \n\n\t\trc = pn533_send_cmd_direct_async(dev,\n\t\t\t\t\t\t PN533_CMD_IN_DATA_EXCHANGE,\n\t\t\t\t\t\t skb,\n\t\t\t\t\t\t pn533_data_exchange_complete,\n\t\t\t\t\t\t dev->cmd_complete_mi_arg);\n\n\t\tbreak;\n\t}\n\n\tif (rc == 0)  \n\t\treturn;\n\n\tnfc_err(dev->dev,\n\t\t\"Error %d when trying to perform data_exchange\\n\", rc);\n\n\tdev_kfree_skb(skb);\n\tkfree(dev->cmd_complete_mi_arg);\n\nerror:\n\tdev->phy_ops->send_ack(dev, GFP_KERNEL);\n\tqueue_work(dev->wq, &dev->cmd_work);\n}\n\nstatic void pn533_wq_mi_send(struct work_struct *work)\n{\n\tstruct pn533 *dev = container_of(work, struct pn533, mi_tx_work);\n\tstruct sk_buff *skb;\n\tint rc;\n\n\t \n\tskb = skb_dequeue(&dev->fragment_skb);\n\n\tif (skb == NULL) {\t \n\t\t \n\t\tskb_queue_head_init(&dev->fragment_skb);\n\t\tgoto error;\n\t}\n\n\tswitch (dev->device_type) {\n\tcase PN533_DEVICE_PASORI:\n\t\tif (dev->tgt_active_prot != NFC_PROTO_FELICA) {\n\t\t\trc = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\trc = pn533_send_cmd_direct_async(dev, PN533_CMD_IN_COMM_THRU,\n\t\t\t\t\t\t skb,\n\t\t\t\t\t\t pn533_data_exchange_complete,\n\t\t\t\t\t\t dev->cmd_complete_dep_arg);\n\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\trc = pn533_send_cmd_direct_async(dev,\n\t\t\t\t\t\t PN533_CMD_IN_DATA_EXCHANGE,\n\t\t\t\t\t\t skb,\n\t\t\t\t\t\t pn533_data_exchange_complete,\n\t\t\t\t\t\t dev->cmd_complete_dep_arg);\n\n\t\tbreak;\n\t}\n\n\tif (rc == 0)  \n\t\treturn;\n\n\tnfc_err(dev->dev,\n\t\t\"Error %d when trying to perform data_exchange\\n\", rc);\n\n\tdev_kfree_skb(skb);\n\tkfree(dev->cmd_complete_dep_arg);\n\nerror:\n\tdev->phy_ops->send_ack(dev, GFP_KERNEL);\n\tqueue_work(dev->wq, &dev->cmd_work);\n}\n\nstatic int pn533_set_configuration(struct pn533 *dev, u8 cfgitem, u8 *cfgdata,\n\t\t\t\t\t\t\t\tu8 cfgdata_len)\n{\n\tstruct sk_buff *skb;\n\tstruct sk_buff *resp;\n\tint skb_len;\n\n\tskb_len = sizeof(cfgitem) + cfgdata_len;  \n\n\tskb = pn533_alloc_skb(dev, skb_len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_put_u8(skb, cfgitem);\n\tskb_put_data(skb, cfgdata, cfgdata_len);\n\n\tresp = pn533_send_cmd_sync(dev, PN533_CMD_RF_CONFIGURATION, skb);\n\tif (IS_ERR(resp))\n\t\treturn PTR_ERR(resp);\n\n\tdev_kfree_skb(resp);\n\treturn 0;\n}\n\nstatic int pn533_get_firmware_version(struct pn533 *dev,\n\t\t\t\t      struct pn533_fw_version *fv)\n{\n\tstruct sk_buff *skb;\n\tstruct sk_buff *resp;\n\n\tskb = pn533_alloc_skb(dev, 0);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tresp = pn533_send_cmd_sync(dev, PN533_CMD_GET_FIRMWARE_VERSION, skb);\n\tif (IS_ERR(resp))\n\t\treturn PTR_ERR(resp);\n\n\tfv->ic = resp->data[0];\n\tfv->ver = resp->data[1];\n\tfv->rev = resp->data[2];\n\tfv->support = resp->data[3];\n\n\tdev_kfree_skb(resp);\n\treturn 0;\n}\n\nstatic int pn533_pasori_fw_reset(struct pn533 *dev)\n{\n\tstruct sk_buff *skb;\n\tstruct sk_buff *resp;\n\n\tskb = pn533_alloc_skb(dev, sizeof(u8));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_put_u8(skb, 0x1);\n\n\tresp = pn533_send_cmd_sync(dev, 0x18, skb);\n\tif (IS_ERR(resp))\n\t\treturn PTR_ERR(resp);\n\n\tdev_kfree_skb(resp);\n\n\treturn 0;\n}\n\nstatic int pn533_rf_field(struct nfc_dev *nfc_dev, u8 rf)\n{\n\tstruct pn533 *dev = nfc_get_drvdata(nfc_dev);\n\tu8 rf_field = !!rf;\n\tint rc;\n\n\trf_field |= PN533_CFGITEM_RF_FIELD_AUTO_RFCA;\n\n\trc = pn533_set_configuration(dev, PN533_CFGITEM_RF_FIELD,\n\t\t\t\t     (u8 *)&rf_field, 1);\n\tif (rc) {\n\t\tnfc_err(dev->dev, \"Error on setting RF field\\n\");\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic int pn532_sam_configuration(struct nfc_dev *nfc_dev)\n{\n\tstruct pn533 *dev = nfc_get_drvdata(nfc_dev);\n\tstruct sk_buff *skb;\n\tstruct sk_buff *resp;\n\n\tskb = pn533_alloc_skb(dev, 1);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_put_u8(skb, 0x01);\n\n\tresp = pn533_send_cmd_sync(dev, PN533_CMD_SAM_CONFIGURATION, skb);\n\tif (IS_ERR(resp))\n\t\treturn PTR_ERR(resp);\n\n\tdev_kfree_skb(resp);\n\treturn 0;\n}\n\nstatic int pn533_dev_up(struct nfc_dev *nfc_dev)\n{\n\tstruct pn533 *dev = nfc_get_drvdata(nfc_dev);\n\tint rc;\n\n\tif (dev->phy_ops->dev_up) {\n\t\trc = dev->phy_ops->dev_up(dev);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tif ((dev->device_type == PN533_DEVICE_PN532) ||\n\t\t(dev->device_type == PN533_DEVICE_PN532_AUTOPOLL)) {\n\t\trc = pn532_sam_configuration(nfc_dev);\n\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn pn533_rf_field(nfc_dev, 1);\n}\n\nstatic int pn533_dev_down(struct nfc_dev *nfc_dev)\n{\n\tstruct pn533 *dev = nfc_get_drvdata(nfc_dev);\n\tint ret;\n\n\tret = pn533_rf_field(nfc_dev, 0);\n\tif (dev->phy_ops->dev_down && !ret)\n\t\tret = dev->phy_ops->dev_down(dev);\n\n\treturn ret;\n}\n\nstatic const struct nfc_ops pn533_nfc_ops = {\n\t.dev_up = pn533_dev_up,\n\t.dev_down = pn533_dev_down,\n\t.dep_link_up = pn533_dep_link_up,\n\t.dep_link_down = pn533_dep_link_down,\n\t.start_poll = pn533_start_poll,\n\t.stop_poll = pn533_stop_poll,\n\t.activate_target = pn533_activate_target,\n\t.deactivate_target = pn533_deactivate_target,\n\t.im_transceive = pn533_transceive,\n\t.tm_send = pn533_tm_send,\n};\n\nstatic int pn533_setup(struct pn533 *dev)\n{\n\tstruct pn533_config_max_retries max_retries;\n\tstruct pn533_config_timing timing;\n\tu8 pasori_cfg[3] = {0x08, 0x01, 0x08};\n\tint rc;\n\n\tswitch (dev->device_type) {\n\tcase PN533_DEVICE_STD:\n\tcase PN533_DEVICE_PASORI:\n\tcase PN533_DEVICE_ACR122U:\n\tcase PN533_DEVICE_PN532:\n\tcase PN533_DEVICE_PN532_AUTOPOLL:\n\t\tmax_retries.mx_rty_atr = 0x2;\n\t\tmax_retries.mx_rty_psl = 0x1;\n\t\tmax_retries.mx_rty_passive_act =\n\t\t\tPN533_CONFIG_MAX_RETRIES_NO_RETRY;\n\n\t\ttiming.rfu = PN533_CONFIG_TIMING_102;\n\t\ttiming.atr_res_timeout = PN533_CONFIG_TIMING_102;\n\t\ttiming.dep_timeout = PN533_CONFIG_TIMING_204;\n\n\t\tbreak;\n\n\tdefault:\n\t\tnfc_err(dev->dev, \"Unknown device type %d\\n\",\n\t\t\tdev->device_type);\n\t\treturn -EINVAL;\n\t}\n\n\trc = pn533_set_configuration(dev, PN533_CFGITEM_MAX_RETRIES,\n\t\t\t\t     (u8 *)&max_retries, sizeof(max_retries));\n\tif (rc) {\n\t\tnfc_err(dev->dev,\n\t\t\t\"Error on setting MAX_RETRIES config\\n\");\n\t\treturn rc;\n\t}\n\n\n\trc = pn533_set_configuration(dev, PN533_CFGITEM_TIMING,\n\t\t\t\t     (u8 *)&timing, sizeof(timing));\n\tif (rc) {\n\t\tnfc_err(dev->dev, \"Error on setting RF timings\\n\");\n\t\treturn rc;\n\t}\n\n\tswitch (dev->device_type) {\n\tcase PN533_DEVICE_STD:\n\tcase PN533_DEVICE_PN532:\n\tcase PN533_DEVICE_PN532_AUTOPOLL:\n\t\tbreak;\n\n\tcase PN533_DEVICE_PASORI:\n\t\tpn533_pasori_fw_reset(dev);\n\n\t\trc = pn533_set_configuration(dev, PN533_CFGITEM_PASORI,\n\t\t\t\t\t     pasori_cfg, 3);\n\t\tif (rc) {\n\t\t\tnfc_err(dev->dev,\n\t\t\t\t\"Error while settings PASORI config\\n\");\n\t\t\treturn rc;\n\t\t}\n\n\t\tpn533_pasori_fw_reset(dev);\n\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nint pn533_finalize_setup(struct pn533 *dev)\n{\n\n\tstruct pn533_fw_version fw_ver;\n\tint rc;\n\n\tmemset(&fw_ver, 0, sizeof(fw_ver));\n\n\trc = pn533_get_firmware_version(dev, &fw_ver);\n\tif (rc) {\n\t\tnfc_err(dev->dev, \"Unable to get FW version\\n\");\n\t\treturn rc;\n\t}\n\n\tnfc_info(dev->dev, \"NXP PN5%02X firmware ver %d.%d now attached\\n\",\n\t\tfw_ver.ic, fw_ver.ver, fw_ver.rev);\n\n\trc = pn533_setup(dev);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(pn533_finalize_setup);\n\nstruct pn533 *pn53x_common_init(u32 device_type,\n\t\t\t\tenum pn533_protocol_type protocol_type,\n\t\t\t\tvoid *phy,\n\t\t\t\tconst struct pn533_phy_ops *phy_ops,\n\t\t\t\tstruct pn533_frame_ops *fops,\n\t\t\t\tstruct device *dev)\n{\n\tstruct pn533 *priv;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpriv->phy = phy;\n\tpriv->phy_ops = phy_ops;\n\tpriv->dev = dev;\n\tif (fops != NULL)\n\t\tpriv->ops = fops;\n\telse\n\t\tpriv->ops = &pn533_std_frame_ops;\n\n\tpriv->protocol_type = protocol_type;\n\tpriv->device_type = device_type;\n\n\tmutex_init(&priv->cmd_lock);\n\n\tINIT_WORK(&priv->cmd_work, pn533_wq_cmd);\n\tINIT_WORK(&priv->cmd_complete_work, pn533_wq_cmd_complete);\n\tINIT_WORK(&priv->mi_rx_work, pn533_wq_mi_recv);\n\tINIT_WORK(&priv->mi_tx_work, pn533_wq_mi_send);\n\tINIT_WORK(&priv->tg_work, pn533_wq_tg_get_data);\n\tINIT_WORK(&priv->mi_tm_rx_work, pn533_wq_tm_mi_recv);\n\tINIT_WORK(&priv->mi_tm_tx_work, pn533_wq_tm_mi_send);\n\tINIT_DELAYED_WORK(&priv->poll_work, pn533_wq_poll);\n\tINIT_WORK(&priv->rf_work, pn533_wq_rf);\n\tpriv->wq = alloc_ordered_workqueue(\"pn533\", 0);\n\tif (priv->wq == NULL)\n\t\tgoto error;\n\n\ttimer_setup(&priv->listen_timer, pn533_listen_mode_timer, 0);\n\n\tskb_queue_head_init(&priv->resp_q);\n\tskb_queue_head_init(&priv->fragment_skb);\n\n\tINIT_LIST_HEAD(&priv->cmd_queue);\n\treturn priv;\n\nerror:\n\tkfree(priv);\n\treturn ERR_PTR(-ENOMEM);\n}\nEXPORT_SYMBOL_GPL(pn53x_common_init);\n\nvoid pn53x_common_clean(struct pn533 *priv)\n{\n\tstruct pn533_cmd *cmd, *n;\n\n\t \n\ttimer_shutdown_sync(&priv->listen_timer);\n\n\tflush_delayed_work(&priv->poll_work);\n\tdestroy_workqueue(priv->wq);\n\n\tskb_queue_purge(&priv->resp_q);\n\n\tlist_for_each_entry_safe(cmd, n, &priv->cmd_queue, queue) {\n\t\tlist_del(&cmd->queue);\n\t\tkfree(cmd);\n\t}\n\n\tkfree(priv);\n}\nEXPORT_SYMBOL_GPL(pn53x_common_clean);\n\nint pn532_i2c_nfc_alloc(struct pn533 *priv, u32 protocols,\n\t\t\tstruct device *parent)\n{\n\tpriv->nfc_dev = nfc_allocate_device(&pn533_nfc_ops, protocols,\n\t\t\t\t\t   priv->ops->tx_header_len +\n\t\t\t\t\t   PN533_CMD_DATAEXCH_HEAD_LEN,\n\t\t\t\t\t   priv->ops->tx_tail_len);\n\tif (!priv->nfc_dev)\n\t\treturn -ENOMEM;\n\n\tnfc_set_parent_dev(priv->nfc_dev, parent);\n\tnfc_set_drvdata(priv->nfc_dev, priv);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(pn532_i2c_nfc_alloc);\n\nint pn53x_register_nfc(struct pn533 *priv, u32 protocols,\n\t\t\tstruct device *parent)\n{\n\tint rc;\n\n\trc = pn532_i2c_nfc_alloc(priv, protocols, parent);\n\tif (rc)\n\t\treturn rc;\n\n\trc = nfc_register_device(priv->nfc_dev);\n\tif (rc)\n\t\tnfc_free_device(priv->nfc_dev);\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(pn53x_register_nfc);\n\nvoid pn53x_unregister_nfc(struct pn533 *priv)\n{\n\tnfc_unregister_device(priv->nfc_dev);\n\tnfc_free_device(priv->nfc_dev);\n}\nEXPORT_SYMBOL_GPL(pn53x_unregister_nfc);\n\nMODULE_AUTHOR(\"Lauro Ramos Venancio <lauro.venancio@openbossa.org>\");\nMODULE_AUTHOR(\"Aloisio Almeida Jr <aloisio.almeida@openbossa.org>\");\nMODULE_AUTHOR(\"Waldemar Rymarkiewicz <waldemar.rymarkiewicz@tieto.com>\");\nMODULE_DESCRIPTION(\"PN533 driver ver \" VERSION);\nMODULE_VERSION(VERSION);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}