{
  "module_name": "i2c.c",
  "hash_id": "10fad8af7da0c4be39206ae7ac508c365984ea9899357665621a2f6ec0eb390e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nfc/pn533/i2c.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/nfc.h>\n#include <linux/netdevice.h>\n#include <linux/interrupt.h>\n#include <net/nfc/nfc.h>\n#include \"pn533.h\"\n\n#define VERSION \"0.1\"\n\n#define PN533_I2C_DRIVER_NAME \"pn533_i2c\"\n\nstruct pn533_i2c_phy {\n\tstruct i2c_client *i2c_dev;\n\tstruct pn533 *priv;\n\n\tbool aborted;\n\n\tint hard_fault;\t\t \n};\n\nstatic int pn533_i2c_send_ack(struct pn533 *dev, gfp_t flags)\n{\n\tstruct pn533_i2c_phy *phy = dev->phy;\n\tstruct i2c_client *client = phy->i2c_dev;\n\tstatic const u8 ack[6] = {0x00, 0x00, 0xff, 0x00, 0xff, 0x00};\n\t \n\n\treturn i2c_master_send(client, ack, 6);\n}\n\nstatic int pn533_i2c_send_frame(struct pn533 *dev,\n\t\t\t\tstruct sk_buff *out)\n{\n\tstruct pn533_i2c_phy *phy = dev->phy;\n\tstruct i2c_client *client = phy->i2c_dev;\n\tint rc;\n\n\tif (phy->hard_fault != 0)\n\t\treturn phy->hard_fault;\n\n\tif (phy->priv == NULL)\n\t\tphy->priv = dev;\n\n\tphy->aborted = false;\n\n\tprint_hex_dump_debug(\"PN533_i2c TX: \", DUMP_PREFIX_NONE, 16, 1,\n\t\t\t     out->data, out->len, false);\n\n\trc = i2c_master_send(client, out->data, out->len);\n\n\tif (rc == -EREMOTEIO) {  \n\t\tusleep_range(6000, 10000);\n\t\trc = i2c_master_send(client, out->data, out->len);\n\t}\n\n\tif (rc >= 0) {\n\t\tif (rc != out->len)\n\t\t\trc = -EREMOTEIO;\n\t\telse\n\t\t\trc = 0;\n\t}\n\n\treturn rc;\n}\n\nstatic void pn533_i2c_abort_cmd(struct pn533 *dev, gfp_t flags)\n{\n\tstruct pn533_i2c_phy *phy = dev->phy;\n\n\tphy->aborted = true;\n\n\t \n\tpn533_i2c_send_ack(dev, flags);\n\n\t \n\tpn533_recv_frame(phy->priv, NULL, -ENOENT);\n}\n\nstatic int pn533_i2c_read(struct pn533_i2c_phy *phy, struct sk_buff **skb)\n{\n\tstruct i2c_client *client = phy->i2c_dev;\n\tint len = PN533_EXT_FRAME_HEADER_LEN +\n\t\t  PN533_STD_FRAME_MAX_PAYLOAD_LEN +\n\t\t  PN533_STD_FRAME_TAIL_LEN + 1;\n\tint r;\n\n\t*skb = alloc_skb(len, GFP_KERNEL);\n\tif (*skb == NULL)\n\t\treturn -ENOMEM;\n\n\tr = i2c_master_recv(client, skb_put(*skb, len), len);\n\tif (r != len) {\n\t\tnfc_err(&client->dev, \"cannot read. r=%d len=%d\\n\", r, len);\n\t\tkfree_skb(*skb);\n\t\treturn -EREMOTEIO;\n\t}\n\n\tif (!((*skb)->data[0] & 0x01)) {\n\t\tnfc_err(&client->dev, \"READY flag not set\");\n\t\tkfree_skb(*skb);\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tskb_pull(*skb, 1);\n\t \n\tskb_trim(*skb, phy->priv->ops->rx_frame_size((*skb)->data));\n\n\treturn 0;\n}\n\nstatic irqreturn_t pn533_i2c_irq_thread_fn(int irq, void *data)\n{\n\tstruct pn533_i2c_phy *phy = data;\n\tstruct sk_buff *skb = NULL;\n\tint r;\n\n\tif (!phy || irq != phy->i2c_dev->irq) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (phy->hard_fault != 0)\n\t\treturn IRQ_HANDLED;\n\n\tr = pn533_i2c_read(phy, &skb);\n\tif (r == -EREMOTEIO) {\n\t\tphy->hard_fault = r;\n\n\t\tpn533_recv_frame(phy->priv, NULL, -EREMOTEIO);\n\n\t\treturn IRQ_HANDLED;\n\t} else if ((r == -ENOMEM) || (r == -EBADMSG) || (r == -EBUSY)) {\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (!phy->aborted)\n\t\tpn533_recv_frame(phy->priv, skb, 0);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct pn533_phy_ops i2c_phy_ops = {\n\t.send_frame = pn533_i2c_send_frame,\n\t.send_ack = pn533_i2c_send_ack,\n\t.abort_cmd = pn533_i2c_abort_cmd,\n};\n\n\nstatic int pn533_i2c_probe(struct i2c_client *client)\n{\n\tstruct pn533_i2c_phy *phy;\n\tstruct pn533 *priv;\n\tint r = 0;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\n\t\tnfc_err(&client->dev, \"Need I2C_FUNC_I2C\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tphy = devm_kzalloc(&client->dev, sizeof(struct pn533_i2c_phy),\n\t\t\t   GFP_KERNEL);\n\tif (!phy)\n\t\treturn -ENOMEM;\n\n\tphy->i2c_dev = client;\n\ti2c_set_clientdata(client, phy);\n\n\tpriv = pn53x_common_init(PN533_DEVICE_PN532,\n\t\t\t\tPN533_PROTO_REQ_ACK_RESP,\n\t\t\t\tphy, &i2c_phy_ops, NULL,\n\t\t\t\t&phy->i2c_dev->dev);\n\n\tif (IS_ERR(priv))\n\t\treturn PTR_ERR(priv);\n\n\tphy->priv = priv;\n\tr = pn532_i2c_nfc_alloc(priv, PN533_NO_TYPE_B_PROTOCOLS, &client->dev);\n\tif (r)\n\t\tgoto nfc_alloc_err;\n\n\tr = request_threaded_irq(client->irq, NULL, pn533_i2c_irq_thread_fn,\n\t\t\t\tIRQF_TRIGGER_FALLING |\n\t\t\t\tIRQF_SHARED | IRQF_ONESHOT,\n\t\t\t\tPN533_I2C_DRIVER_NAME, phy);\n\tif (r < 0) {\n\t\tnfc_err(&client->dev, \"Unable to register IRQ handler\\n\");\n\t\tgoto irq_rqst_err;\n\t}\n\n\tr = pn533_finalize_setup(priv);\n\tif (r)\n\t\tgoto fn_setup_err;\n\n\tr = nfc_register_device(priv->nfc_dev);\n\tif (r)\n\t\tgoto fn_setup_err;\n\n\treturn r;\n\nfn_setup_err:\n\tfree_irq(client->irq, phy);\n\nirq_rqst_err:\n\tnfc_free_device(priv->nfc_dev);\n\nnfc_alloc_err:\n\tpn53x_common_clean(phy->priv);\n\n\treturn r;\n}\n\nstatic void pn533_i2c_remove(struct i2c_client *client)\n{\n\tstruct pn533_i2c_phy *phy = i2c_get_clientdata(client);\n\n\tfree_irq(client->irq, phy);\n\n\tpn53x_unregister_nfc(phy->priv);\n\tpn53x_common_clean(phy->priv);\n}\n\nstatic const struct of_device_id of_pn533_i2c_match[] __maybe_unused = {\n\t{ .compatible = \"nxp,pn532\", },\n\t \n\t{ .compatible = \"nxp,pn533-i2c\", },\n\t{ .compatible = \"nxp,pn532-i2c\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, of_pn533_i2c_match);\n\nstatic const struct i2c_device_id pn533_i2c_id_table[] = {\n\t{ PN533_I2C_DRIVER_NAME, 0 },\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, pn533_i2c_id_table);\n\nstatic struct i2c_driver pn533_i2c_driver = {\n\t.driver = {\n\t\t   .name = PN533_I2C_DRIVER_NAME,\n\t\t   .of_match_table = of_match_ptr(of_pn533_i2c_match),\n\t\t  },\n\t.probe = pn533_i2c_probe,\n\t.id_table = pn533_i2c_id_table,\n\t.remove = pn533_i2c_remove,\n};\n\nmodule_i2c_driver(pn533_i2c_driver);\n\nMODULE_AUTHOR(\"Michael Thalmeier <michael.thalmeier@hale.at>\");\nMODULE_DESCRIPTION(\"PN533 I2C driver ver \" VERSION);\nMODULE_VERSION(VERSION);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}