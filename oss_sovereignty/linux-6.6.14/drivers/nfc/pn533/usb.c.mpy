{
  "module_name": "usb.c",
  "hash_id": "4468e0f6a6548e55d98fe517cffd5d0ed00fc23b282c56e3de0b531085656208",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nfc/pn533/usb.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/usb.h>\n#include <linux/nfc.h>\n#include <linux/netdevice.h>\n#include <net/nfc/nfc.h>\n#include \"pn533.h\"\n\n#define VERSION \"0.1\"\n\n#define PN533_VENDOR_ID 0x4CC\n#define PN533_PRODUCT_ID 0x2533\n\n#define SCM_VENDOR_ID 0x4E6\n#define SCL3711_PRODUCT_ID 0x5591\n\n#define SONY_VENDOR_ID         0x054c\n#define PASORI_PRODUCT_ID      0x02e1\n\n#define ACS_VENDOR_ID 0x072f\n#define ACR122U_PRODUCT_ID 0x2200\n\nstatic const struct usb_device_id pn533_usb_table[] = {\n\t{ USB_DEVICE(PN533_VENDOR_ID, PN533_PRODUCT_ID),\n\t  .driver_info = PN533_DEVICE_STD },\n\t{ USB_DEVICE(SCM_VENDOR_ID, SCL3711_PRODUCT_ID),\n\t  .driver_info = PN533_DEVICE_STD },\n\t{ USB_DEVICE(SONY_VENDOR_ID, PASORI_PRODUCT_ID),\n\t  .driver_info = PN533_DEVICE_PASORI },\n\t{ USB_DEVICE(ACS_VENDOR_ID, ACR122U_PRODUCT_ID),\n\t  .driver_info = PN533_DEVICE_ACR122U },\n\t{ }\n};\nMODULE_DEVICE_TABLE(usb, pn533_usb_table);\n\nstruct pn533_usb_phy {\n\tstruct usb_device *udev;\n\tstruct usb_interface *interface;\n\n\tstruct urb *out_urb;\n\tstruct urb *in_urb;\n\n\tstruct urb *ack_urb;\n\tu8 *ack_buffer;\n\n\tstruct pn533 *priv;\n};\n\nstatic void pn533_recv_response(struct urb *urb)\n{\n\tstruct pn533_usb_phy *phy = urb->context;\n\tstruct sk_buff *skb = NULL;\n\n\tif (!urb->status) {\n\t\tskb = alloc_skb(urb->actual_length, GFP_ATOMIC);\n\t\tif (!skb) {\n\t\t\tnfc_err(&phy->udev->dev, \"failed to alloc memory\\n\");\n\t\t} else {\n\t\t\tskb_put_data(skb, urb->transfer_buffer,\n\t\t\t\t     urb->actual_length);\n\t\t}\n\t}\n\n\tpn533_recv_frame(phy->priv, skb, urb->status);\n}\n\nstatic int pn533_submit_urb_for_response(struct pn533_usb_phy *phy, gfp_t flags)\n{\n\tphy->in_urb->complete = pn533_recv_response;\n\n\treturn usb_submit_urb(phy->in_urb, flags);\n}\n\nstatic void pn533_recv_ack(struct urb *urb)\n{\n\tstruct pn533_usb_phy *phy = urb->context;\n\tstruct pn533 *priv = phy->priv;\n\tstruct pn533_cmd *cmd = priv->cmd;\n\tstruct pn533_std_frame *in_frame;\n\tint rc;\n\n\tcmd->status = urb->status;\n\n\tswitch (urb->status) {\n\tcase 0:\n\t\tbreak;  \n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\t\tdev_dbg(&phy->udev->dev,\n\t\t\t\"The urb has been stopped (status %d)\\n\",\n\t\t\turb->status);\n\t\tgoto sched_wq;\n\tcase -ESHUTDOWN:\n\tdefault:\n\t\tnfc_err(&phy->udev->dev,\n\t\t\t\"Urb failure (status %d)\\n\", urb->status);\n\t\tgoto sched_wq;\n\t}\n\n\tin_frame = phy->in_urb->transfer_buffer;\n\n\tif (!pn533_rx_frame_is_ack(in_frame)) {\n\t\tnfc_err(&phy->udev->dev, \"Received an invalid ack\\n\");\n\t\tcmd->status = -EIO;\n\t\tgoto sched_wq;\n\t}\n\n\trc = pn533_submit_urb_for_response(phy, GFP_ATOMIC);\n\tif (rc) {\n\t\tnfc_err(&phy->udev->dev,\n\t\t\t\"usb_submit_urb failed with result %d\\n\", rc);\n\t\tcmd->status = rc;\n\t\tgoto sched_wq;\n\t}\n\n\treturn;\n\nsched_wq:\n\tqueue_work(priv->wq, &priv->cmd_complete_work);\n}\n\nstatic int pn533_submit_urb_for_ack(struct pn533_usb_phy *phy, gfp_t flags)\n{\n\tphy->in_urb->complete = pn533_recv_ack;\n\n\treturn usb_submit_urb(phy->in_urb, flags);\n}\n\nstatic int pn533_usb_send_ack(struct pn533 *dev, gfp_t flags)\n{\n\tstruct pn533_usb_phy *phy = dev->phy;\n\tstatic const u8 ack[6] = {0x00, 0x00, 0xff, 0x00, 0xff, 0x00};\n\t \n\n\tif (!phy->ack_buffer) {\n\t\tphy->ack_buffer = kmemdup(ack, sizeof(ack), flags);\n\t\tif (!phy->ack_buffer)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tphy->ack_urb->transfer_buffer = phy->ack_buffer;\n\tphy->ack_urb->transfer_buffer_length = sizeof(ack);\n\treturn usb_submit_urb(phy->ack_urb, flags);\n}\n\nstruct pn533_out_arg {\n\tstruct pn533_usb_phy *phy;\n\tstruct completion done;\n};\n\nstatic int pn533_usb_send_frame(struct pn533 *dev,\n\t\t\t\tstruct sk_buff *out)\n{\n\tstruct pn533_usb_phy *phy = dev->phy;\n\tstruct pn533_out_arg arg;\n\tvoid *cntx;\n\tint rc;\n\n\tif (phy->priv == NULL)\n\t\tphy->priv = dev;\n\n\tphy->out_urb->transfer_buffer = out->data;\n\tphy->out_urb->transfer_buffer_length = out->len;\n\n\tprint_hex_dump_debug(\"PN533 TX: \", DUMP_PREFIX_NONE, 16, 1,\n\t\t\t     out->data, out->len, false);\n\n\targ.phy = phy;\n\tinit_completion(&arg.done);\n\tcntx = phy->out_urb->context;\n\tphy->out_urb->context = &arg;\n\n\trc = usb_submit_urb(phy->out_urb, GFP_KERNEL);\n\tif (rc)\n\t\treturn rc;\n\n\twait_for_completion(&arg.done);\n\tphy->out_urb->context = cntx;\n\n\tif (dev->protocol_type == PN533_PROTO_REQ_RESP) {\n\t\t \n\t\trc = pn533_submit_urb_for_response(phy, GFP_KERNEL);\n\t\tif (rc)\n\t\t\tgoto error;\n\t} else if (dev->protocol_type == PN533_PROTO_REQ_ACK_RESP) {\n\t\t \n\t\trc = pn533_submit_urb_for_ack(phy, GFP_KERNEL);\n\t\tif (rc)\n\t\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\tusb_unlink_urb(phy->out_urb);\n\treturn rc;\n}\n\nstatic void pn533_usb_abort_cmd(struct pn533 *dev, gfp_t flags)\n{\n\tstruct pn533_usb_phy *phy = dev->phy;\n\n\t \n\tif (dev->device_type == PN533_DEVICE_ACR122U)\n\t\treturn;\n\n\t \n\tpn533_usb_send_ack(dev, flags);\n\n\t \n\tusb_kill_urb(phy->in_urb);\n}\n\n \n\n \n#define PN533_ACR122_TX_FRAME_HEADER_LEN (sizeof(struct pn533_acr122_tx_frame) \\\n\t\t\t\t\t  + 2)\n#define PN533_ACR122_TX_FRAME_TAIL_LEN 0\n#define PN533_ACR122_RX_FRAME_HEADER_LEN (sizeof(struct pn533_acr122_rx_frame) \\\n\t\t\t\t\t  + 2)\n#define PN533_ACR122_RX_FRAME_TAIL_LEN 2\n#define PN533_ACR122_FRAME_MAX_PAYLOAD_LEN PN533_STD_FRAME_MAX_PAYLOAD_LEN\n\n \n#define PN533_ACR122_PC_TO_RDR_ICCPOWERON 0x62\n#define PN533_ACR122_PC_TO_RDR_ESCAPE 0x6B\n\n#define PN533_ACR122_RDR_TO_PC_ESCAPE 0x83\n\n\nstruct pn533_acr122_ccid_hdr {\n\tu8 type;\n\tu32 datalen;\n\tu8 slot;\n\tu8 seq;\n\n\t \n\tu8 params[3];\n\tu8 data[];  \n} __packed;\n\nstruct pn533_acr122_apdu_hdr {\n\tu8 class;\n\tu8 ins;\n\tu8 p1;\n\tu8 p2;\n} __packed;\n\nstruct pn533_acr122_tx_frame {\n\tstruct pn533_acr122_ccid_hdr ccid;\n\tstruct pn533_acr122_apdu_hdr apdu;\n\tu8 datalen;\n\tu8 data[];  \n} __packed;\n\nstruct pn533_acr122_rx_frame {\n\tstruct pn533_acr122_ccid_hdr ccid;\n\tu8 data[];  \n} __packed;\n\nstatic void pn533_acr122_tx_frame_init(void *_frame, u8 cmd_code)\n{\n\tstruct pn533_acr122_tx_frame *frame = _frame;\n\n\tframe->ccid.type = PN533_ACR122_PC_TO_RDR_ESCAPE;\n\t \n\tframe->ccid.datalen = sizeof(frame->apdu) + 1;\n\tframe->ccid.slot = 0;\n\tframe->ccid.seq = 0;\n\tframe->ccid.params[0] = 0;\n\tframe->ccid.params[1] = 0;\n\tframe->ccid.params[2] = 0;\n\n\tframe->data[0] = PN533_STD_FRAME_DIR_OUT;\n\tframe->data[1] = cmd_code;\n\tframe->datalen = 2;   \n\n\tframe->apdu.class = 0xFF;\n\tframe->apdu.ins = 0;\n\tframe->apdu.p1 = 0;\n\tframe->apdu.p2 = 0;\n}\n\nstatic void pn533_acr122_tx_frame_finish(void *_frame)\n{\n\tstruct pn533_acr122_tx_frame *frame = _frame;\n\n\tframe->ccid.datalen += frame->datalen;\n}\n\nstatic void pn533_acr122_tx_update_payload_len(void *_frame, int len)\n{\n\tstruct pn533_acr122_tx_frame *frame = _frame;\n\n\tframe->datalen += len;\n}\n\nstatic bool pn533_acr122_is_rx_frame_valid(void *_frame, struct pn533 *dev)\n{\n\tstruct pn533_acr122_rx_frame *frame = _frame;\n\n\tif (frame->ccid.type != 0x83)\n\t\treturn false;\n\n\tif (!frame->ccid.datalen)\n\t\treturn false;\n\n\tif (frame->data[frame->ccid.datalen - 2] == 0x63)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int pn533_acr122_rx_frame_size(void *frame)\n{\n\tstruct pn533_acr122_rx_frame *f = frame;\n\n\t \n\treturn sizeof(struct pn533_acr122_rx_frame) + f->ccid.datalen;\n}\n\nstatic u8 pn533_acr122_get_cmd_code(void *frame)\n{\n\tstruct pn533_acr122_rx_frame *f = frame;\n\n\treturn PN533_FRAME_CMD(f);\n}\n\nstatic struct pn533_frame_ops pn533_acr122_frame_ops = {\n\t.tx_frame_init = pn533_acr122_tx_frame_init,\n\t.tx_frame_finish = pn533_acr122_tx_frame_finish,\n\t.tx_update_payload_len = pn533_acr122_tx_update_payload_len,\n\t.tx_header_len = PN533_ACR122_TX_FRAME_HEADER_LEN,\n\t.tx_tail_len = PN533_ACR122_TX_FRAME_TAIL_LEN,\n\n\t.rx_is_frame_valid = pn533_acr122_is_rx_frame_valid,\n\t.rx_header_len = PN533_ACR122_RX_FRAME_HEADER_LEN,\n\t.rx_tail_len = PN533_ACR122_RX_FRAME_TAIL_LEN,\n\t.rx_frame_size = pn533_acr122_rx_frame_size,\n\n\t.max_payload_len = PN533_ACR122_FRAME_MAX_PAYLOAD_LEN,\n\t.get_cmd_code = pn533_acr122_get_cmd_code,\n};\n\nstruct pn533_acr122_poweron_rdr_arg {\n\tint rc;\n\tstruct completion done;\n};\n\nstatic void pn533_acr122_poweron_rdr_resp(struct urb *urb)\n{\n\tstruct pn533_acr122_poweron_rdr_arg *arg = urb->context;\n\n\tprint_hex_dump_debug(\"ACR122 RX: \", DUMP_PREFIX_NONE, 16, 1,\n\t\t       urb->transfer_buffer, urb->transfer_buffer_length,\n\t\t       false);\n\n\targ->rc = urb->status;\n\tcomplete(&arg->done);\n}\n\nstatic int pn533_acr122_poweron_rdr(struct pn533_usb_phy *phy)\n{\n\t \n\tu8 cmd[10] = {PN533_ACR122_PC_TO_RDR_ICCPOWERON,\n\t\t      0, 0, 0, 0, 0, 0, 3, 0, 0};\n\tchar *buffer;\n\tint transferred;\n\tint rc;\n\tvoid *cntx;\n\tstruct pn533_acr122_poweron_rdr_arg arg;\n\n\tbuffer = kmemdup(cmd, sizeof(cmd), GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tinit_completion(&arg.done);\n\tcntx = phy->in_urb->context;   \n\n\tphy->in_urb->complete = pn533_acr122_poweron_rdr_resp;\n\tphy->in_urb->context = &arg;\n\n\tprint_hex_dump_debug(\"ACR122 TX: \", DUMP_PREFIX_NONE, 16, 1,\n\t\t       cmd, sizeof(cmd), false);\n\n\trc = usb_bulk_msg(phy->udev, phy->out_urb->pipe, buffer, sizeof(cmd),\n\t\t\t  &transferred, 5000);\n\tkfree(buffer);\n\tif (rc || (transferred != sizeof(cmd))) {\n\t\tnfc_err(&phy->udev->dev,\n\t\t\t\"Reader power on cmd error %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\trc =  usb_submit_urb(phy->in_urb, GFP_KERNEL);\n\tif (rc) {\n\t\tnfc_err(&phy->udev->dev,\n\t\t\t\"Can't submit reader poweron cmd response %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\twait_for_completion(&arg.done);\n\tphy->in_urb->context = cntx;  \n\n\treturn arg.rc;\n}\n\nstatic void pn533_out_complete(struct urb *urb)\n{\n\tstruct pn533_out_arg *arg = urb->context;\n\tstruct pn533_usb_phy *phy = arg->phy;\n\n\tswitch (urb->status) {\n\tcase 0:\n\t\tbreak;  \n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\t\tdev_dbg(&phy->udev->dev,\n\t\t\t\"The urb has been stopped (status %d)\\n\",\n\t\t\turb->status);\n\t\tbreak;\n\tcase -ESHUTDOWN:\n\tdefault:\n\t\tnfc_err(&phy->udev->dev,\n\t\t\t\"Urb failure (status %d)\\n\",\n\t\t\turb->status);\n\t}\n\n\tcomplete(&arg->done);\n}\n\nstatic void pn533_ack_complete(struct urb *urb)\n{\n\tstruct pn533_usb_phy *phy = urb->context;\n\n\tswitch (urb->status) {\n\tcase 0:\n\t\tbreak;  \n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\t\tdev_dbg(&phy->udev->dev,\n\t\t\t\"The urb has been stopped (status %d)\\n\",\n\t\t\turb->status);\n\t\tbreak;\n\tcase -ESHUTDOWN:\n\tdefault:\n\t\tnfc_err(&phy->udev->dev,\n\t\t\t\"Urb failure (status %d)\\n\",\n\t\t\turb->status);\n\t}\n}\n\nstatic const struct pn533_phy_ops usb_phy_ops = {\n\t.send_frame = pn533_usb_send_frame,\n\t.send_ack = pn533_usb_send_ack,\n\t.abort_cmd = pn533_usb_abort_cmd,\n};\n\nstatic int pn533_usb_probe(struct usb_interface *interface,\n\t\t\tconst struct usb_device_id *id)\n{\n\tstruct pn533 *priv;\n\tstruct pn533_usb_phy *phy;\n\tstruct usb_host_interface *iface_desc;\n\tstruct usb_endpoint_descriptor *endpoint;\n\tint in_endpoint = 0;\n\tint out_endpoint = 0;\n\tint rc = -ENOMEM;\n\tint i;\n\tu32 protocols;\n\tenum pn533_protocol_type protocol_type = PN533_PROTO_REQ_ACK_RESP;\n\tstruct pn533_frame_ops *fops = NULL;\n\tunsigned char *in_buf;\n\tint in_buf_len = PN533_EXT_FRAME_HEADER_LEN +\n\t\t\t PN533_STD_FRAME_MAX_PAYLOAD_LEN +\n\t\t\t PN533_STD_FRAME_TAIL_LEN;\n\n\tphy = devm_kzalloc(&interface->dev, sizeof(*phy), GFP_KERNEL);\n\tif (!phy)\n\t\treturn -ENOMEM;\n\n\tin_buf = kzalloc(in_buf_len, GFP_KERNEL);\n\tif (!in_buf)\n\t\treturn -ENOMEM;\n\n\tphy->udev = usb_get_dev(interface_to_usbdev(interface));\n\tphy->interface = interface;\n\n\tiface_desc = interface->cur_altsetting;\n\tfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\n\t\tendpoint = &iface_desc->endpoint[i].desc;\n\n\t\tif (!in_endpoint && usb_endpoint_is_bulk_in(endpoint))\n\t\t\tin_endpoint = endpoint->bEndpointAddress;\n\n\t\tif (!out_endpoint && usb_endpoint_is_bulk_out(endpoint))\n\t\t\tout_endpoint = endpoint->bEndpointAddress;\n\t}\n\n\tif (!in_endpoint || !out_endpoint) {\n\t\tnfc_err(&interface->dev,\n\t\t\t\"Could not find bulk-in or bulk-out endpoint\\n\");\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tphy->in_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tphy->out_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tphy->ack_urb = usb_alloc_urb(0, GFP_KERNEL);\n\n\tif (!phy->in_urb || !phy->out_urb || !phy->ack_urb)\n\t\tgoto error;\n\n\tusb_fill_bulk_urb(phy->in_urb, phy->udev,\n\t\t\t  usb_rcvbulkpipe(phy->udev, in_endpoint),\n\t\t\t  in_buf, in_buf_len, NULL, phy);\n\n\tusb_fill_bulk_urb(phy->out_urb, phy->udev,\n\t\t\t  usb_sndbulkpipe(phy->udev, out_endpoint),\n\t\t\t  NULL, 0, pn533_out_complete, phy);\n\tusb_fill_bulk_urb(phy->ack_urb, phy->udev,\n\t\t\t  usb_sndbulkpipe(phy->udev, out_endpoint),\n\t\t\t  NULL, 0, pn533_ack_complete, phy);\n\n\tswitch (id->driver_info) {\n\tcase PN533_DEVICE_STD:\n\t\tprotocols = PN533_ALL_PROTOCOLS;\n\t\tbreak;\n\n\tcase PN533_DEVICE_PASORI:\n\t\tprotocols = PN533_NO_TYPE_B_PROTOCOLS;\n\t\tbreak;\n\n\tcase PN533_DEVICE_ACR122U:\n\t\tprotocols = PN533_NO_TYPE_B_PROTOCOLS;\n\t\tfops = &pn533_acr122_frame_ops;\n\t\tprotocol_type = PN533_PROTO_REQ_RESP;\n\n\t\trc = pn533_acr122_poweron_rdr(phy);\n\t\tif (rc < 0) {\n\t\t\tnfc_err(&interface->dev,\n\t\t\t\t\"Couldn't poweron the reader (error %d)\\n\", rc);\n\t\t\tgoto error;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tnfc_err(&interface->dev, \"Unknown device type %lu\\n\",\n\t\t\tid->driver_info);\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tpriv = pn53x_common_init(id->driver_info, protocol_type,\n\t\t\t\t\tphy, &usb_phy_ops, fops,\n\t\t\t\t\t&phy->udev->dev);\n\n\tif (IS_ERR(priv)) {\n\t\trc = PTR_ERR(priv);\n\t\tgoto error;\n\t}\n\n\tphy->priv = priv;\n\n\trc = pn533_finalize_setup(priv);\n\tif (rc)\n\t\tgoto err_clean;\n\n\tusb_set_intfdata(interface, phy);\n\trc = pn53x_register_nfc(priv, protocols, &interface->dev);\n\tif (rc)\n\t\tgoto err_clean;\n\n\treturn 0;\n\nerr_clean:\n\tpn53x_common_clean(priv);\nerror:\n\tusb_kill_urb(phy->in_urb);\n\tusb_kill_urb(phy->out_urb);\n\tusb_kill_urb(phy->ack_urb);\n\n\tusb_free_urb(phy->in_urb);\n\tusb_free_urb(phy->out_urb);\n\tusb_free_urb(phy->ack_urb);\n\tusb_put_dev(phy->udev);\n\tkfree(in_buf);\n\tkfree(phy->ack_buffer);\n\n\treturn rc;\n}\n\nstatic void pn533_usb_disconnect(struct usb_interface *interface)\n{\n\tstruct pn533_usb_phy *phy = usb_get_intfdata(interface);\n\n\tif (!phy)\n\t\treturn;\n\n\tpn53x_unregister_nfc(phy->priv);\n\tpn53x_common_clean(phy->priv);\n\n\tusb_set_intfdata(interface, NULL);\n\n\tusb_kill_urb(phy->in_urb);\n\tusb_kill_urb(phy->out_urb);\n\tusb_kill_urb(phy->ack_urb);\n\n\tkfree(phy->in_urb->transfer_buffer);\n\tusb_free_urb(phy->in_urb);\n\tusb_free_urb(phy->out_urb);\n\tusb_free_urb(phy->ack_urb);\n\tkfree(phy->ack_buffer);\n\n\tnfc_info(&interface->dev, \"NXP PN533 NFC device disconnected\\n\");\n}\n\nstatic struct usb_driver pn533_usb_driver = {\n\t.name =\t\t\"pn533_usb\",\n\t.probe =\tpn533_usb_probe,\n\t.disconnect =\tpn533_usb_disconnect,\n\t.id_table =\tpn533_usb_table,\n};\n\nmodule_usb_driver(pn533_usb_driver);\n\nMODULE_AUTHOR(\"Lauro Ramos Venancio <lauro.venancio@openbossa.org>\");\nMODULE_AUTHOR(\"Aloisio Almeida Jr <aloisio.almeida@openbossa.org>\");\nMODULE_AUTHOR(\"Waldemar Rymarkiewicz <waldemar.rymarkiewicz@tieto.com>\");\nMODULE_DESCRIPTION(\"PN533 USB driver ver \" VERSION);\nMODULE_VERSION(VERSION);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}