{
  "module_name": "pn533.h",
  "hash_id": "33c7f9b45d83cfa54cb0176b84c4c62fefc0b5f9612521082f1a82301bf5a0d3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nfc/pn533/pn533.h",
  "human_readable_source": " \n \n\n#define PN533_DEVICE_STD\t\t0x1\n#define PN533_DEVICE_PASORI\t\t0x2\n#define PN533_DEVICE_ACR122U\t\t0x3\n#define PN533_DEVICE_PN532\t\t0x4\n#define PN533_DEVICE_PN532_AUTOPOLL\t0x5\n\n#define PN533_ALL_PROTOCOLS (NFC_PROTO_JEWEL_MASK | NFC_PROTO_MIFARE_MASK |\\\n\t\t\t     NFC_PROTO_FELICA_MASK | NFC_PROTO_ISO14443_MASK |\\\n\t\t\t     NFC_PROTO_NFC_DEP_MASK |\\\n\t\t\t     NFC_PROTO_ISO14443_B_MASK)\n\n#define PN533_NO_TYPE_B_PROTOCOLS (NFC_PROTO_JEWEL_MASK | \\\n\t\t\t\t   NFC_PROTO_MIFARE_MASK | \\\n\t\t\t\t   NFC_PROTO_FELICA_MASK | \\\n\t\t\t\t   NFC_PROTO_ISO14443_MASK | \\\n\t\t\t\t   NFC_PROTO_NFC_DEP_MASK)\n\n \n#define PN533_STD_FRAME_HEADER_LEN (sizeof(struct pn533_std_frame) \\\n\t\t\t\t\t+ 2)  \n#define PN533_STD_FRAME_TAIL_LEN 2  \n\n#define PN533_EXT_FRAME_HEADER_LEN (sizeof(struct pn533_ext_frame) \\\n\t\t\t\t\t+ 2)  \n\n#define PN533_CMD_DATAEXCH_HEAD_LEN 1\n#define PN533_CMD_DATAEXCH_DATA_MAXLEN\t262\n#define PN533_CMD_DATAFRAME_MAXLEN\t240\t \n\n \n#define PN533_STD_FRAME_MAX_PAYLOAD_LEN 263\n\n\n \n#define PN533_STD_FRAME_ACK_SIZE 6\n \n#define PN533_STD_ERROR_FRAME_SIZE 8\n#define PN533_STD_FRAME_CHECKSUM(f) (f->data[f->datalen])\n#define PN533_STD_FRAME_POSTAMBLE(f) (f->data[f->datalen + 1])\n \n#define PN533_STD_IS_EXTENDED(hdr) ((hdr)->datalen == 0xFF \\\n\t\t\t\t\t&& (hdr)->datalen_checksum == 0xFF)\n#define PN533_EXT_FRAME_CHECKSUM(f) (f->data[be16_to_cpu(f->datalen)])\n\n \n#define PN533_STD_FRAME_SOF 0x00FF\n\n \n#define PN533_STD_FRAME_IDENTIFIER(f) (f->data[0])  \n#define PN533_STD_FRAME_DIR_OUT 0xD4\n#define PN533_STD_FRAME_DIR_IN 0xD5\n\n \n#define PN533_FRAME_CMD(f) (f->data[1])\n\n#define PN533_CMD_GET_FIRMWARE_VERSION 0x02\n#define PN533_CMD_SAM_CONFIGURATION 0x14\n#define PN533_CMD_RF_CONFIGURATION 0x32\n#define PN533_CMD_IN_DATA_EXCHANGE 0x40\n#define PN533_CMD_IN_COMM_THRU     0x42\n#define PN533_CMD_IN_LIST_PASSIVE_TARGET 0x4A\n#define PN533_CMD_IN_ATR 0x50\n#define PN533_CMD_IN_RELEASE 0x52\n#define PN533_CMD_IN_JUMP_FOR_DEP 0x56\n#define PN533_CMD_IN_AUTOPOLL 0x60\n\n#define PN533_CMD_TG_INIT_AS_TARGET 0x8c\n#define PN533_CMD_TG_GET_DATA 0x86\n#define PN533_CMD_TG_SET_DATA 0x8e\n#define PN533_CMD_TG_SET_META_DATA 0x94\n#define PN533_CMD_UNDEF 0xff\n\n#define PN533_CMD_RESPONSE(cmd) (cmd + 1)\n\n \n#define PN533_CMD_RET_MASK 0x3F\n#define PN533_CMD_MI_MASK 0x40\n#define PN533_CMD_RET_SUCCESS 0x00\n\n#define PN533_FRAME_DATALEN_ACK 0x00\n#define PN533_FRAME_DATALEN_ERROR 0x01\n#define PN533_FRAME_DATALEN_EXTENDED 0xFF\n\nenum  pn533_protocol_type {\n\tPN533_PROTO_REQ_ACK_RESP = 0,\n\tPN533_PROTO_REQ_RESP\n};\n\n \nenum {\n\tPN533_POLL_MOD_106KBPS_A,\n\tPN533_POLL_MOD_212KBPS_FELICA,\n\tPN533_POLL_MOD_424KBPS_FELICA,\n\tPN533_POLL_MOD_106KBPS_JEWEL,\n\tPN533_POLL_MOD_847KBPS_B,\n\tPN533_LISTEN_MOD,\n\n\t__PN533_POLL_MOD_AFTER_LAST,\n};\n#define PN533_POLL_MOD_MAX (__PN533_POLL_MOD_AFTER_LAST - 1)\n\nstruct pn533_std_frame {\n\tu8 preamble;\n\t__be16 start_frame;\n\tu8 datalen;\n\tu8 datalen_checksum;\n\tu8 data[];\n} __packed;\n\nstruct pn533_ext_frame {\t \n\tu8 preamble;\n\t__be16 start_frame;\n\t__be16 eif_flag;\t \n\t__be16 datalen;\n\tu8 datalen_checksum;\n\tu8 data[];\n} __packed;\n\nstruct pn533 {\n\tstruct nfc_dev *nfc_dev;\n\tu32 device_type;\n\tenum pn533_protocol_type protocol_type;\n\n\tstruct sk_buff_head resp_q;\n\tstruct sk_buff_head fragment_skb;\n\n\tstruct workqueue_struct\t*wq;\n\tstruct work_struct cmd_work;\n\tstruct work_struct cmd_complete_work;\n\tstruct delayed_work poll_work;\n\tstruct work_struct mi_rx_work;\n\tstruct work_struct mi_tx_work;\n\tstruct work_struct mi_tm_rx_work;\n\tstruct work_struct mi_tm_tx_work;\n\tstruct work_struct tg_work;\n\tstruct work_struct rf_work;\n\n\tstruct list_head cmd_queue;\n\tstruct pn533_cmd *cmd;\n\tu8 cmd_pending;\n\tstruct mutex cmd_lock;   \n\n\tvoid *cmd_complete_mi_arg;\n\tvoid *cmd_complete_dep_arg;\n\n\tstruct pn533_poll_modulations *poll_mod_active[PN533_POLL_MOD_MAX + 1];\n\tu8 poll_mod_count;\n\tu8 poll_mod_curr;\n\tu8 poll_dep;\n\tu32 poll_protocols;\n\tu32 listen_protocols;\n\tstruct timer_list listen_timer;\n\tint cancel_listen;\n\n\tu8 *gb;\n\tsize_t gb_len;\n\n\tu8 tgt_available_prots;\n\tu8 tgt_active_prot;\n\tu8 tgt_mode;\n\n\tstruct pn533_frame_ops *ops;\n\n\tstruct device *dev;\n\tvoid *phy;\n\tconst struct pn533_phy_ops *phy_ops;\n};\n\ntypedef int (*pn533_send_async_complete_t) (struct pn533 *dev, void *arg,\n\t\t\t\t\tstruct sk_buff *resp);\n\nstruct pn533_cmd {\n\tstruct list_head queue;\n\tu8 code;\n\tint status;\n\tstruct sk_buff *req;\n\tstruct sk_buff *resp;\n\tpn533_send_async_complete_t  complete_cb;\n\tvoid *complete_cb_context;\n};\n\n\nstruct pn533_frame_ops {\n\tvoid (*tx_frame_init)(void *frame, u8 cmd_code);\n\tvoid (*tx_frame_finish)(void *frame);\n\tvoid (*tx_update_payload_len)(void *frame, int len);\n\tint tx_header_len;\n\tint tx_tail_len;\n\n\tbool (*rx_is_frame_valid)(void *frame, struct pn533 *dev);\n\tbool (*rx_frame_is_ack)(void *frame);\n\tint (*rx_frame_size)(void *frame);\n\tint rx_header_len;\n\tint rx_tail_len;\n\n\tint max_payload_len;\n\tu8 (*get_cmd_code)(void *frame);\n};\n\n\nstruct pn533_phy_ops {\n\tint (*send_frame)(struct pn533 *priv,\n\t\t\t  struct sk_buff *out);\n\tint (*send_ack)(struct pn533 *dev, gfp_t flags);\n\tvoid (*abort_cmd)(struct pn533 *priv, gfp_t flags);\n\t \n\tint (*dev_up)(struct pn533 *priv);\n\tint (*dev_down)(struct pn533 *priv);\n};\n\n\nstruct pn533 *pn53x_common_init(u32 device_type,\n\t\t\t\tenum pn533_protocol_type protocol_type,\n\t\t\t\tvoid *phy,\n\t\t\t\tconst struct pn533_phy_ops *phy_ops,\n\t\t\t\tstruct pn533_frame_ops *fops,\n\t\t\t\tstruct device *dev);\n\nint pn533_finalize_setup(struct pn533 *dev);\nvoid pn53x_common_clean(struct pn533 *priv);\nvoid pn533_recv_frame(struct pn533 *dev, struct sk_buff *skb, int status);\nint pn532_i2c_nfc_alloc(struct pn533 *priv, u32 protocols,\n\t\t\tstruct device *parent);\nint pn53x_register_nfc(struct pn533 *priv, u32 protocols,\n\t\t\tstruct device *parent);\nvoid pn53x_unregister_nfc(struct pn533 *priv);\n\nbool pn533_rx_frame_is_cmd_response(struct pn533 *dev, void *frame);\nbool pn533_rx_frame_is_ack(void *_frame);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}