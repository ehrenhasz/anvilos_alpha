{
  "module_name": "uart.c",
  "hash_id": "17eec7396ad65c032d6002bc73b7b1abfb54e81c790cb98e38adbbf432bb050a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nfc/pn533/uart.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/nfc.h>\n#include <linux/netdevice.h>\n#include <linux/of.h>\n#include <linux/serdev.h>\n#include \"pn533.h\"\n\n#define PN532_UART_SKB_BUFF_LEN\t(PN533_CMD_DATAEXCH_DATA_MAXLEN * 2)\n\nenum send_wakeup {\n\tPN532_SEND_NO_WAKEUP = 0,\n\tPN532_SEND_WAKEUP,\n\tPN532_SEND_LAST_WAKEUP,\n};\n\n\nstruct pn532_uart_phy {\n\tstruct serdev_device *serdev;\n\tstruct sk_buff *recv_skb;\n\tstruct pn533 *priv;\n\t \n\tenum send_wakeup send_wakeup;\n\tstruct timer_list cmd_timeout;\n\tstruct sk_buff *cur_out_buf;\n};\n\nstatic int pn532_uart_send_frame(struct pn533 *dev,\n\t\t\t\tstruct sk_buff *out)\n{\n\t \n\tstatic const u8 wakeup[] = {\n\t\t0x55, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n\tstruct pn532_uart_phy *pn532 = dev->phy;\n\tint err;\n\n\tprint_hex_dump_debug(\"PN532_uart TX: \", DUMP_PREFIX_NONE, 16, 1,\n\t\t\t     out->data, out->len, false);\n\n\tpn532->cur_out_buf = out;\n\tif (pn532->send_wakeup) {\n\t\terr = serdev_device_write(pn532->serdev,\n\t\t\t\twakeup, sizeof(wakeup),\n\t\t\t\tMAX_SCHEDULE_TIMEOUT);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (pn532->send_wakeup == PN532_SEND_LAST_WAKEUP)\n\t\tpn532->send_wakeup = PN532_SEND_NO_WAKEUP;\n\n\terr = serdev_device_write(pn532->serdev, out->data, out->len,\n\t\t\tMAX_SCHEDULE_TIMEOUT);\n\tif (err < 0)\n\t\treturn err;\n\n\tmod_timer(&pn532->cmd_timeout, HZ / 40 + jiffies);\n\treturn 0;\n}\n\nstatic int pn532_uart_send_ack(struct pn533 *dev, gfp_t flags)\n{\n\t \n\tstatic const u8 ack[PN533_STD_FRAME_ACK_SIZE] = {\n\t\t\t0x00, 0x00, 0xff, 0x00, 0xff, 0x00};\n\tstruct pn532_uart_phy *pn532 = dev->phy;\n\tint err;\n\n\terr = serdev_device_write(pn532->serdev, ack, sizeof(ack),\n\t\t\tMAX_SCHEDULE_TIMEOUT);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic void pn532_uart_abort_cmd(struct pn533 *dev, gfp_t flags)\n{\n\t \n\tpn532_uart_send_ack(dev, flags);\n\t \n\tpn533_recv_frame(dev, NULL, -ENOENT);\n}\n\nstatic int pn532_dev_up(struct pn533 *dev)\n{\n\tstruct pn532_uart_phy *pn532 = dev->phy;\n\tint ret = 0;\n\n\tret = serdev_device_open(pn532->serdev);\n\tif (ret)\n\t\treturn ret;\n\n\tpn532->send_wakeup = PN532_SEND_LAST_WAKEUP;\n\treturn ret;\n}\n\nstatic int pn532_dev_down(struct pn533 *dev)\n{\n\tstruct pn532_uart_phy *pn532 = dev->phy;\n\n\tserdev_device_close(pn532->serdev);\n\tpn532->send_wakeup = PN532_SEND_WAKEUP;\n\n\treturn 0;\n}\n\nstatic const struct pn533_phy_ops uart_phy_ops = {\n\t.send_frame = pn532_uart_send_frame,\n\t.send_ack = pn532_uart_send_ack,\n\t.abort_cmd = pn532_uart_abort_cmd,\n\t.dev_up = pn532_dev_up,\n\t.dev_down = pn532_dev_down,\n};\n\nstatic void pn532_cmd_timeout(struct timer_list *t)\n{\n\tstruct pn532_uart_phy *dev = from_timer(dev, t, cmd_timeout);\n\n\tpn532_uart_send_frame(dev->priv, dev->cur_out_buf);\n}\n\n \nstatic int pn532_uart_rx_is_frame(struct sk_buff *skb)\n{\n\tstruct pn533_std_frame *std;\n\tstruct pn533_ext_frame *ext;\n\tu16 frame_len;\n\tint i;\n\n\tfor (i = 0; i + PN533_STD_FRAME_ACK_SIZE <= skb->len; i++) {\n\t\tstd = (struct pn533_std_frame *)&skb->data[i];\n\t\t \n\t\tif (std->start_frame != cpu_to_be16(PN533_STD_FRAME_SOF))\n\t\t\tcontinue;\n\n\t\t \n\t\tswitch (std->datalen) {\n\t\tcase PN533_FRAME_DATALEN_ACK:\n\t\t\tif (std->datalen_checksum == 0xff) {\n\t\t\t\tskb_pull(skb, i);\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase PN533_FRAME_DATALEN_ERROR:\n\t\t\tif ((std->datalen_checksum == 0xff) &&\n\t\t\t\t\t(skb->len >=\n\t\t\t\t\t PN533_STD_ERROR_FRAME_SIZE)) {\n\t\t\t\tskb_pull(skb, i);\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase PN533_FRAME_DATALEN_EXTENDED:\n\t\t\text = (struct pn533_ext_frame *)&skb->data[i];\n\t\t\tframe_len = be16_to_cpu(ext->datalen);\n\t\t\tif (skb->len >= frame_len +\n\t\t\t\t\tsizeof(struct pn533_ext_frame) +\n\t\t\t\t\t2  ) {\n\t\t\t\tskb_pull(skb, i);\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tbreak;\n\t\tdefault:  \n\t\t\tframe_len = std->datalen;\n\t\t\tif (skb->len >= frame_len +\n\t\t\t\t\tsizeof(struct pn533_std_frame) +\n\t\t\t\t\t2  ) {\n\t\t\t\tskb_pull(skb, i);\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int pn532_receive_buf(struct serdev_device *serdev,\n\t\tconst unsigned char *data, size_t count)\n{\n\tstruct pn532_uart_phy *dev = serdev_device_get_drvdata(serdev);\n\tsize_t i;\n\n\tdel_timer(&dev->cmd_timeout);\n\tfor (i = 0; i < count; i++) {\n\t\tskb_put_u8(dev->recv_skb, *data++);\n\t\tif (!pn532_uart_rx_is_frame(dev->recv_skb))\n\t\t\tcontinue;\n\n\t\tpn533_recv_frame(dev->priv, dev->recv_skb, 0);\n\t\tdev->recv_skb = alloc_skb(PN532_UART_SKB_BUFF_LEN, GFP_KERNEL);\n\t\tif (!dev->recv_skb)\n\t\t\treturn 0;\n\t}\n\n\treturn i;\n}\n\nstatic const struct serdev_device_ops pn532_serdev_ops = {\n\t.receive_buf = pn532_receive_buf,\n\t.write_wakeup = serdev_device_write_wakeup,\n};\n\nstatic const struct of_device_id pn532_uart_of_match[] = {\n\t{ .compatible = \"nxp,pn532\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, pn532_uart_of_match);\n\nstatic int pn532_uart_probe(struct serdev_device *serdev)\n{\n\tstruct pn532_uart_phy *pn532;\n\tstruct pn533 *priv;\n\tint err;\n\n\terr = -ENOMEM;\n\tpn532 = kzalloc(sizeof(*pn532), GFP_KERNEL);\n\tif (!pn532)\n\t\tgoto err_exit;\n\n\tpn532->recv_skb = alloc_skb(PN532_UART_SKB_BUFF_LEN, GFP_KERNEL);\n\tif (!pn532->recv_skb)\n\t\tgoto err_free;\n\n\tpn532->serdev = serdev;\n\tserdev_device_set_drvdata(serdev, pn532);\n\tserdev_device_set_client_ops(serdev, &pn532_serdev_ops);\n\terr = serdev_device_open(serdev);\n\tif (err) {\n\t\tdev_err(&serdev->dev, \"Unable to open device\\n\");\n\t\tgoto err_skb;\n\t}\n\n\terr = serdev_device_set_baudrate(serdev, 115200);\n\tif (err != 115200) {\n\t\terr = -EINVAL;\n\t\tgoto err_serdev;\n\t}\n\n\tserdev_device_set_flow_control(serdev, false);\n\tpn532->send_wakeup = PN532_SEND_WAKEUP;\n\ttimer_setup(&pn532->cmd_timeout, pn532_cmd_timeout, 0);\n\tpriv = pn53x_common_init(PN533_DEVICE_PN532_AUTOPOLL,\n\t\t\t\t     PN533_PROTO_REQ_ACK_RESP,\n\t\t\t\t     pn532, &uart_phy_ops, NULL,\n\t\t\t\t     &pn532->serdev->dev);\n\tif (IS_ERR(priv)) {\n\t\terr = PTR_ERR(priv);\n\t\tgoto err_serdev;\n\t}\n\n\tpn532->priv = priv;\n\terr = pn533_finalize_setup(pn532->priv);\n\tif (err)\n\t\tgoto err_clean;\n\n\tserdev_device_close(serdev);\n\terr = pn53x_register_nfc(priv, PN533_NO_TYPE_B_PROTOCOLS, &serdev->dev);\n\tif (err) {\n\t\tpn53x_common_clean(pn532->priv);\n\t\tgoto err_skb;\n\t}\n\n\treturn err;\n\nerr_clean:\n\tpn53x_common_clean(pn532->priv);\nerr_serdev:\n\tserdev_device_close(serdev);\nerr_skb:\n\tkfree_skb(pn532->recv_skb);\nerr_free:\n\tkfree(pn532);\nerr_exit:\n\treturn err;\n}\n\nstatic void pn532_uart_remove(struct serdev_device *serdev)\n{\n\tstruct pn532_uart_phy *pn532 = serdev_device_get_drvdata(serdev);\n\n\tpn53x_unregister_nfc(pn532->priv);\n\tserdev_device_close(serdev);\n\tpn53x_common_clean(pn532->priv);\n\ttimer_shutdown_sync(&pn532->cmd_timeout);\n\tkfree_skb(pn532->recv_skb);\n\tkfree(pn532);\n}\n\nstatic struct serdev_device_driver pn532_uart_driver = {\n\t.probe = pn532_uart_probe,\n\t.remove = pn532_uart_remove,\n\t.driver = {\n\t\t.name = \"pn532_uart\",\n\t\t.of_match_table = pn532_uart_of_match,\n\t},\n};\n\nmodule_serdev_device_driver(pn532_uart_driver);\n\nMODULE_AUTHOR(\"Lars P\u00f6schel <poeschel@lemonage.de>\");\nMODULE_DESCRIPTION(\"PN532 UART driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}