{
  "module_name": "virtual_ncidev.c",
  "hash_id": "fa56e5dbdacda653aa8ac51b13d2575b577dfeed69dc68eaa7c430aa635b57a5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nfc/virtual_ncidev.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/miscdevice.h>\n#include <linux/mutex.h>\n#include <linux/wait.h>\n#include <net/nfc/nci_core.h>\n\n#define IOCTL_GET_NCIDEV_IDX    0\n#define VIRTUAL_NFC_PROTOCOLS\t(NFC_PROTO_JEWEL_MASK | \\\n\t\t\t\t NFC_PROTO_MIFARE_MASK | \\\n\t\t\t\t NFC_PROTO_FELICA_MASK | \\\n\t\t\t\t NFC_PROTO_ISO14443_MASK | \\\n\t\t\t\t NFC_PROTO_ISO14443_B_MASK | \\\n\t\t\t\t NFC_PROTO_ISO15693_MASK)\n\nstruct virtual_nci_dev {\n\tstruct nci_dev *ndev;\n\tstruct mutex mtx;\n\tstruct sk_buff *send_buff;\n\tstruct wait_queue_head wq;\n\tbool running;\n};\n\nstatic int virtual_nci_open(struct nci_dev *ndev)\n{\n\tstruct virtual_nci_dev *vdev = nci_get_drvdata(ndev);\n\n\tvdev->running = true;\n\treturn 0;\n}\n\nstatic int virtual_nci_close(struct nci_dev *ndev)\n{\n\tstruct virtual_nci_dev *vdev = nci_get_drvdata(ndev);\n\n\tmutex_lock(&vdev->mtx);\n\tkfree_skb(vdev->send_buff);\n\tvdev->send_buff = NULL;\n\tvdev->running = false;\n\tmutex_unlock(&vdev->mtx);\n\n\treturn 0;\n}\n\nstatic int virtual_nci_send(struct nci_dev *ndev, struct sk_buff *skb)\n{\n\tstruct virtual_nci_dev *vdev = nci_get_drvdata(ndev);\n\n\tmutex_lock(&vdev->mtx);\n\tif (vdev->send_buff || !vdev->running) {\n\t\tmutex_unlock(&vdev->mtx);\n\t\tkfree_skb(skb);\n\t\treturn -1;\n\t}\n\tvdev->send_buff = skb_copy(skb, GFP_KERNEL);\n\tif (!vdev->send_buff) {\n\t\tmutex_unlock(&vdev->mtx);\n\t\tkfree_skb(skb);\n\t\treturn -1;\n\t}\n\tmutex_unlock(&vdev->mtx);\n\twake_up_interruptible(&vdev->wq);\n\tconsume_skb(skb);\n\n\treturn 0;\n}\n\nstatic const struct nci_ops virtual_nci_ops = {\n\t.open = virtual_nci_open,\n\t.close = virtual_nci_close,\n\t.send = virtual_nci_send\n};\n\nstatic ssize_t virtual_ncidev_read(struct file *file, char __user *buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct virtual_nci_dev *vdev = file->private_data;\n\tsize_t actual_len;\n\n\tmutex_lock(&vdev->mtx);\n\twhile (!vdev->send_buff) {\n\t\tmutex_unlock(&vdev->mtx);\n\t\tif (wait_event_interruptible(vdev->wq, vdev->send_buff))\n\t\t\treturn -EFAULT;\n\t\tmutex_lock(&vdev->mtx);\n\t}\n\n\tactual_len = min_t(size_t, count, vdev->send_buff->len);\n\n\tif (copy_to_user(buf, vdev->send_buff->data, actual_len)) {\n\t\tmutex_unlock(&vdev->mtx);\n\t\treturn -EFAULT;\n\t}\n\n\tskb_pull(vdev->send_buff, actual_len);\n\tif (vdev->send_buff->len == 0) {\n\t\tconsume_skb(vdev->send_buff);\n\t\tvdev->send_buff = NULL;\n\t}\n\tmutex_unlock(&vdev->mtx);\n\n\treturn actual_len;\n}\n\nstatic ssize_t virtual_ncidev_write(struct file *file,\n\t\t\t\t    const char __user *buf,\n\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct virtual_nci_dev *vdev = file->private_data;\n\tstruct sk_buff *skb;\n\n\tskb = alloc_skb(count, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(skb_put(skb, count), buf, count)) {\n\t\tkfree_skb(skb);\n\t\treturn -EFAULT;\n\t}\n\n\tnci_recv_frame(vdev->ndev, skb);\n\treturn count;\n}\n\nstatic int virtual_ncidev_open(struct inode *inode, struct file *file)\n{\n\tint ret = 0;\n\tstruct virtual_nci_dev *vdev;\n\n\tvdev = kzalloc(sizeof(*vdev), GFP_KERNEL);\n\tif (!vdev)\n\t\treturn -ENOMEM;\n\tvdev->ndev = nci_allocate_device(&virtual_nci_ops,\n\t\tVIRTUAL_NFC_PROTOCOLS, 0, 0);\n\tif (!vdev->ndev) {\n\t\tkfree(vdev);\n\t\treturn -ENOMEM;\n\t}\n\n\tmutex_init(&vdev->mtx);\n\tinit_waitqueue_head(&vdev->wq);\n\tfile->private_data = vdev;\n\tnci_set_drvdata(vdev->ndev, vdev);\n\n\tret = nci_register_device(vdev->ndev);\n\tif (ret < 0) {\n\t\tnci_free_device(vdev->ndev);\n\t\tmutex_destroy(&vdev->mtx);\n\t\tkfree(vdev);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int virtual_ncidev_close(struct inode *inode, struct file *file)\n{\n\tstruct virtual_nci_dev *vdev = file->private_data;\n\n\tnci_unregister_device(vdev->ndev);\n\tnci_free_device(vdev->ndev);\n\tmutex_destroy(&vdev->mtx);\n\tkfree(vdev);\n\n\treturn 0;\n}\n\nstatic long virtual_ncidev_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t unsigned long arg)\n{\n\tstruct virtual_nci_dev *vdev = file->private_data;\n\tconst struct nfc_dev *nfc_dev = vdev->ndev->nfc_dev;\n\tvoid __user *p = (void __user *)arg;\n\n\tif (cmd != IOCTL_GET_NCIDEV_IDX)\n\t\treturn -ENOTTY;\n\n\tif (copy_to_user(p, &nfc_dev->idx, sizeof(nfc_dev->idx)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic const struct file_operations virtual_ncidev_fops = {\n\t.owner = THIS_MODULE,\n\t.read = virtual_ncidev_read,\n\t.write = virtual_ncidev_write,\n\t.open = virtual_ncidev_open,\n\t.release = virtual_ncidev_close,\n\t.unlocked_ioctl = virtual_ncidev_ioctl\n};\n\nstatic struct miscdevice miscdev = {\n\t.minor = MISC_DYNAMIC_MINOR,\n\t.name = \"virtual_nci\",\n\t.fops = &virtual_ncidev_fops,\n\t.mode = 0600,\n};\n\nmodule_misc_device(miscdev);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Virtual NCI device simulation driver\");\nMODULE_AUTHOR(\"Bongsu Jeon <bongsu.jeon@samsung.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}