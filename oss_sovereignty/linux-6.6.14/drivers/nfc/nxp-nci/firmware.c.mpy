{
  "module_name": "firmware.c",
  "hash_id": "25c5e4d2b42b134c1b965613849c8243d830814489896c96a5bdfa56daea146d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nfc/nxp-nci/firmware.c",
  "human_readable_source": "\n \n\n#include <linux/completion.h>\n#include <linux/firmware.h>\n#include <linux/nfc.h>\n#include <asm/unaligned.h>\n\n#include \"nxp-nci.h\"\n\n \n#define NXP_NCI_FW_ANSWER_TIMEOUT\tmsecs_to_jiffies(30000)\n\n#define NXP_NCI_FW_CMD_RESET\t\t0xF0\n#define NXP_NCI_FW_CMD_GETVERSION\t0xF1\n#define NXP_NCI_FW_CMD_CHECKINTEGRITY\t0xE0\n#define NXP_NCI_FW_CMD_WRITE\t\t0xC0\n#define NXP_NCI_FW_CMD_READ\t\t0xA2\n#define NXP_NCI_FW_CMD_GETSESSIONSTATE\t0xF2\n#define NXP_NCI_FW_CMD_LOG\t\t0xA7\n#define NXP_NCI_FW_CMD_FORCE\t\t0xD0\n#define NXP_NCI_FW_CMD_GET_DIE_ID\t0xF4\n\n#define NXP_NCI_FW_CHUNK_FLAG\t0x0400\n\n#define NXP_NCI_FW_RESULT_OK\t\t\t\t0x00\n#define NXP_NCI_FW_RESULT_INVALID_ADDR\t\t\t0x01\n#define NXP_NCI_FW_RESULT_GENERIC_ERROR\t\t\t0x02\n#define NXP_NCI_FW_RESULT_UNKNOWN_CMD\t\t\t0x0B\n#define NXP_NCI_FW_RESULT_ABORTED_CMD\t\t\t0x0C\n#define NXP_NCI_FW_RESULT_PLL_ERROR\t\t\t0x0D\n#define NXP_NCI_FW_RESULT_ADDR_RANGE_OFL_ERROR\t\t0x1E\n#define NXP_NCI_FW_RESULT_BUFFER_OFL_ERROR\t\t0x1F\n#define NXP_NCI_FW_RESULT_MEM_BSY\t\t\t0x20\n#define NXP_NCI_FW_RESULT_SIGNATURE_ERROR\t\t0x21\n#define NXP_NCI_FW_RESULT_FIRMWARE_VERSION_ERROR\t0x24\n#define NXP_NCI_FW_RESULT_PROTOCOL_ERROR\t\t0x28\n#define NXP_NCI_FW_RESULT_SFWU_DEGRADED\t\t\t0x2A\n#define NXP_NCI_FW_RESULT_PH_STATUS_FIRST_CHUNK\t\t0x2D\n#define NXP_NCI_FW_RESULT_PH_STATUS_NEXT_CHUNK\t\t0x2E\n#define NXP_NCI_FW_RESULT_PH_STATUS_INTERNAL_ERROR_5\t0xC5\n\nvoid nxp_nci_fw_work_complete(struct nxp_nci_info *info, int result)\n{\n\tstruct nxp_nci_fw_info *fw_info = &info->fw_info;\n\tint r;\n\n\tif (info->phy_ops->set_mode) {\n\t\tr = info->phy_ops->set_mode(info->phy_id, NXP_NCI_MODE_COLD);\n\t\tif (r < 0 && result == 0)\n\t\t\tresult = -r;\n\t}\n\n\tinfo->mode = NXP_NCI_MODE_COLD;\n\n\tif (fw_info->fw) {\n\t\trelease_firmware(fw_info->fw);\n\t\tfw_info->fw = NULL;\n\t}\n\n\tnfc_fw_download_done(info->ndev->nfc_dev, fw_info->name, (u32) -result);\n}\n\n \nstatic u16 nxp_nci_fw_crc(u8 const *buffer, size_t len)\n{\n\tu16 crc = 0xffff;\n\n\twhile (len--) {\n\t\tcrc = ((crc >> 8) | (crc << 8)) ^ *buffer++;\n\t\tcrc ^= (crc & 0xff) >> 4;\n\t\tcrc ^= (crc & 0xff) << 12;\n\t\tcrc ^= (crc & 0xff) << 5;\n\t}\n\n\treturn crc;\n}\n\nstatic int nxp_nci_fw_send_chunk(struct nxp_nci_info *info)\n{\n\tstruct nxp_nci_fw_info *fw_info = &info->fw_info;\n\tu16 header, crc;\n\tstruct sk_buff *skb;\n\tsize_t chunk_len;\n\tsize_t remaining_len;\n\tint r;\n\n\tskb = nci_skb_alloc(info->ndev, info->max_payload, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tchunk_len = info->max_payload - NXP_NCI_FW_HDR_LEN - NXP_NCI_FW_CRC_LEN;\n\tremaining_len = fw_info->frame_size - fw_info->written;\n\n\tif (remaining_len > chunk_len) {\n\t\theader = NXP_NCI_FW_CHUNK_FLAG;\n\t} else {\n\t\tchunk_len = remaining_len;\n\t\theader = 0x0000;\n\t}\n\n\theader |= chunk_len & NXP_NCI_FW_FRAME_LEN_MASK;\n\tput_unaligned_be16(header, skb_put(skb, NXP_NCI_FW_HDR_LEN));\n\n\tskb_put_data(skb, fw_info->data + fw_info->written, chunk_len);\n\n\tcrc = nxp_nci_fw_crc(skb->data, chunk_len + NXP_NCI_FW_HDR_LEN);\n\tput_unaligned_be16(crc, skb_put(skb, NXP_NCI_FW_CRC_LEN));\n\n\tr = info->phy_ops->write(info->phy_id, skb);\n\tif (r >= 0)\n\t\tr = chunk_len;\n\n\tkfree_skb(skb);\n\n\treturn r;\n}\n\nstatic int nxp_nci_fw_send(struct nxp_nci_info *info)\n{\n\tstruct nxp_nci_fw_info *fw_info = &info->fw_info;\n\tlong completion_rc;\n\tint r;\n\n\treinit_completion(&fw_info->cmd_completion);\n\n\tif (fw_info->written == 0) {\n\t\tfw_info->frame_size = get_unaligned_be16(fw_info->data) &\n\t\t\t\t      NXP_NCI_FW_FRAME_LEN_MASK;\n\t\tfw_info->data += NXP_NCI_FW_HDR_LEN;\n\t\tfw_info->size -= NXP_NCI_FW_HDR_LEN;\n\t}\n\n\tif (fw_info->frame_size > fw_info->size)\n\t\treturn -EMSGSIZE;\n\n\tr = nxp_nci_fw_send_chunk(info);\n\tif (r < 0)\n\t\treturn r;\n\n\tfw_info->written += r;\n\n\tif (*fw_info->data == NXP_NCI_FW_CMD_RESET) {\n\t\tfw_info->cmd_result = 0;\n\t\tif (fw_info->fw)\n\t\t\tschedule_work(&fw_info->work);\n\t} else {\n\t\tcompletion_rc = wait_for_completion_interruptible_timeout(\n\t\t\t&fw_info->cmd_completion, NXP_NCI_FW_ANSWER_TIMEOUT);\n\t\tif (completion_rc == 0)\n\t\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nvoid nxp_nci_fw_work(struct work_struct *work)\n{\n\tstruct nxp_nci_info *info;\n\tstruct nxp_nci_fw_info *fw_info;\n\tint r;\n\n\tfw_info = container_of(work, struct nxp_nci_fw_info, work);\n\tinfo = container_of(fw_info, struct nxp_nci_info, fw_info);\n\n\tmutex_lock(&info->info_lock);\n\n\tr = fw_info->cmd_result;\n\tif (r < 0)\n\t\tgoto exit_work;\n\n\tif (fw_info->written == fw_info->frame_size) {\n\t\tfw_info->data += fw_info->frame_size;\n\t\tfw_info->size -= fw_info->frame_size;\n\t\tfw_info->written = 0;\n\t}\n\n\tif (fw_info->size > 0)\n\t\tr = nxp_nci_fw_send(info);\n\nexit_work:\n\tif (r < 0 || fw_info->size == 0)\n\t\tnxp_nci_fw_work_complete(info, r);\n\tmutex_unlock(&info->info_lock);\n}\n\nint nxp_nci_fw_download(struct nci_dev *ndev, const char *firmware_name)\n{\n\tstruct nxp_nci_info *info = nci_get_drvdata(ndev);\n\tstruct nxp_nci_fw_info *fw_info = &info->fw_info;\n\tint r;\n\n\tmutex_lock(&info->info_lock);\n\n\tif (!info->phy_ops->set_mode || !info->phy_ops->write) {\n\t\tr = -ENOTSUPP;\n\t\tgoto fw_download_exit;\n\t}\n\n\tif (!firmware_name || firmware_name[0] == '\\0') {\n\t\tr = -EINVAL;\n\t\tgoto fw_download_exit;\n\t}\n\n\tstrcpy(fw_info->name, firmware_name);\n\n\tr = request_firmware(&fw_info->fw, firmware_name,\n\t\t\t     ndev->nfc_dev->dev.parent);\n\tif (r < 0)\n\t\tgoto fw_download_exit;\n\n\tr = info->phy_ops->set_mode(info->phy_id, NXP_NCI_MODE_FW);\n\tif (r < 0) {\n\t\trelease_firmware(fw_info->fw);\n\t\tgoto fw_download_exit;\n\t}\n\n\tinfo->mode = NXP_NCI_MODE_FW;\n\n\tfw_info->data = fw_info->fw->data;\n\tfw_info->size = fw_info->fw->size;\n\tfw_info->written = 0;\n\tfw_info->frame_size = 0;\n\tfw_info->cmd_result = 0;\n\n\tschedule_work(&fw_info->work);\n\nfw_download_exit:\n\tmutex_unlock(&info->info_lock);\n\treturn r;\n}\n\nstatic int nxp_nci_fw_read_status(u8 stat)\n{\n\tswitch (stat) {\n\tcase NXP_NCI_FW_RESULT_OK:\n\t\treturn 0;\n\tcase NXP_NCI_FW_RESULT_INVALID_ADDR:\n\t\treturn -EINVAL;\n\tcase NXP_NCI_FW_RESULT_UNKNOWN_CMD:\n\t\treturn -EINVAL;\n\tcase NXP_NCI_FW_RESULT_ABORTED_CMD:\n\t\treturn -EMSGSIZE;\n\tcase NXP_NCI_FW_RESULT_ADDR_RANGE_OFL_ERROR:\n\t\treturn -EADDRNOTAVAIL;\n\tcase NXP_NCI_FW_RESULT_BUFFER_OFL_ERROR:\n\t\treturn -ENOBUFS;\n\tcase NXP_NCI_FW_RESULT_MEM_BSY:\n\t\treturn -ENOKEY;\n\tcase NXP_NCI_FW_RESULT_SIGNATURE_ERROR:\n\t\treturn -EKEYREJECTED;\n\tcase NXP_NCI_FW_RESULT_FIRMWARE_VERSION_ERROR:\n\t\treturn -EALREADY;\n\tcase NXP_NCI_FW_RESULT_PROTOCOL_ERROR:\n\t\treturn -EPROTO;\n\tcase NXP_NCI_FW_RESULT_SFWU_DEGRADED:\n\t\treturn -EHWPOISON;\n\tcase NXP_NCI_FW_RESULT_PH_STATUS_FIRST_CHUNK:\n\t\treturn 0;\n\tcase NXP_NCI_FW_RESULT_PH_STATUS_NEXT_CHUNK:\n\t\treturn 0;\n\tcase NXP_NCI_FW_RESULT_PH_STATUS_INTERNAL_ERROR_5:\n\t\treturn -EINVAL;\n\tdefault:\n\t\treturn -EIO;\n\t}\n}\n\nstatic u16 nxp_nci_fw_check_crc(struct sk_buff *skb)\n{\n\tu16 crc, frame_crc;\n\tsize_t len = skb->len - NXP_NCI_FW_CRC_LEN;\n\n\tcrc = nxp_nci_fw_crc(skb->data, len);\n\tframe_crc = get_unaligned_be16(skb->data + len);\n\n\treturn (crc ^ frame_crc);\n}\n\nvoid nxp_nci_fw_recv_frame(struct nci_dev *ndev, struct sk_buff *skb)\n{\n\tstruct nxp_nci_info *info = nci_get_drvdata(ndev);\n\tstruct nxp_nci_fw_info *fw_info = &info->fw_info;\n\n\tcomplete(&fw_info->cmd_completion);\n\n\tif (skb) {\n\t\tif (nxp_nci_fw_check_crc(skb) != 0x00)\n\t\t\tfw_info->cmd_result = -EBADMSG;\n\t\telse\n\t\t\tfw_info->cmd_result = nxp_nci_fw_read_status(*(u8 *)skb_pull(skb, NXP_NCI_FW_HDR_LEN));\n\t\tkfree_skb(skb);\n\t} else {\n\t\tfw_info->cmd_result = -EIO;\n\t}\n\n\tif (fw_info->fw)\n\t\tschedule_work(&fw_info->work);\n}\nEXPORT_SYMBOL(nxp_nci_fw_recv_frame);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}