{
  "module_name": "i2c.c",
  "hash_id": "5401bca196df98ac352ec8abcd5d0ac26affe40d30234c62f549a16d48b3c7e0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nfc/nxp-nci/i2c.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/nfc.h>\n#include <linux/gpio/consumer.h>\n#include <asm/unaligned.h>\n\n#include <net/nfc/nfc.h>\n\n#include \"nxp-nci.h\"\n\n#define NXP_NCI_I2C_DRIVER_NAME\t\"nxp-nci_i2c\"\n\n#define NXP_NCI_I2C_MAX_PAYLOAD\t32\n\nstruct nxp_nci_i2c_phy {\n\tstruct i2c_client *i2c_dev;\n\tstruct nci_dev *ndev;\n\n\tstruct gpio_desc *gpiod_en;\n\tstruct gpio_desc *gpiod_fw;\n\n\tint hard_fault;  \n};\n\nstatic int nxp_nci_i2c_set_mode(void *phy_id,\n\t\t\t\t    enum nxp_nci_mode mode)\n{\n\tstruct nxp_nci_i2c_phy *phy = (struct nxp_nci_i2c_phy *) phy_id;\n\n\tgpiod_set_value(phy->gpiod_fw, (mode == NXP_NCI_MODE_FW) ? 1 : 0);\n\tgpiod_set_value(phy->gpiod_en, (mode != NXP_NCI_MODE_COLD) ? 1 : 0);\n\tusleep_range(10000, 15000);\n\n\tif (mode == NXP_NCI_MODE_COLD)\n\t\tphy->hard_fault = 0;\n\n\treturn 0;\n}\n\nstatic int nxp_nci_i2c_write(void *phy_id, struct sk_buff *skb)\n{\n\tint r;\n\tstruct nxp_nci_i2c_phy *phy = phy_id;\n\tstruct i2c_client *client = phy->i2c_dev;\n\n\tif (phy->hard_fault != 0)\n\t\treturn phy->hard_fault;\n\n\tr = i2c_master_send(client, skb->data, skb->len);\n\tif (r < 0) {\n\t\t \n\t\tmsleep(110);\n\t\tr = i2c_master_send(client, skb->data, skb->len);\n\t}\n\n\tif (r < 0) {\n\t\tnfc_err(&client->dev, \"Error %d on I2C send\\n\", r);\n\t} else if (r != skb->len) {\n\t\tnfc_err(&client->dev,\n\t\t\t\"Invalid length sent: %u (expected %u)\\n\",\n\t\t\tr, skb->len);\n\t\tr = -EREMOTEIO;\n\t} else {\n\t\t \n\t\tr = 0;\n\t}\n\n\treturn r;\n}\n\nstatic const struct nxp_nci_phy_ops i2c_phy_ops = {\n\t.set_mode = nxp_nci_i2c_set_mode,\n\t.write = nxp_nci_i2c_write,\n};\n\nstatic int nxp_nci_i2c_fw_read(struct nxp_nci_i2c_phy *phy,\n\t\t\t       struct sk_buff **skb)\n{\n\tstruct i2c_client *client = phy->i2c_dev;\n\tsize_t frame_len;\n\t__be16 header;\n\tint r;\n\n\tr = i2c_master_recv(client, (u8 *) &header, NXP_NCI_FW_HDR_LEN);\n\tif (r < 0) {\n\t\tgoto fw_read_exit;\n\t} else if (r != NXP_NCI_FW_HDR_LEN) {\n\t\tnfc_err(&client->dev, \"Incorrect header length: %u\\n\", r);\n\t\tr = -EBADMSG;\n\t\tgoto fw_read_exit;\n\t}\n\n\tframe_len = (be16_to_cpu(header) & NXP_NCI_FW_FRAME_LEN_MASK) +\n\t\t    NXP_NCI_FW_CRC_LEN;\n\n\t*skb = alloc_skb(NXP_NCI_FW_HDR_LEN + frame_len, GFP_KERNEL);\n\tif (*skb == NULL) {\n\t\tr = -ENOMEM;\n\t\tgoto fw_read_exit;\n\t}\n\n\tskb_put_data(*skb, &header, NXP_NCI_FW_HDR_LEN);\n\n\tr = i2c_master_recv(client, skb_put(*skb, frame_len), frame_len);\n\tif (r < 0) {\n\t\tgoto fw_read_exit_free_skb;\n\t} else if (r != frame_len) {\n\t\tnfc_err(&client->dev,\n\t\t\t\"Invalid frame length: %u (expected %zu)\\n\",\n\t\t\tr, frame_len);\n\t\tr = -EBADMSG;\n\t\tgoto fw_read_exit_free_skb;\n\t}\n\n\treturn 0;\n\nfw_read_exit_free_skb:\n\tkfree_skb(*skb);\nfw_read_exit:\n\treturn r;\n}\n\nstatic int nxp_nci_i2c_nci_read(struct nxp_nci_i2c_phy *phy,\n\t\t\t\tstruct sk_buff **skb)\n{\n\tstruct nci_ctrl_hdr header;  \n\tstruct i2c_client *client = phy->i2c_dev;\n\tint r;\n\n\tr = i2c_master_recv(client, (u8 *) &header, NCI_CTRL_HDR_SIZE);\n\tif (r < 0) {\n\t\tgoto nci_read_exit;\n\t} else if (r != NCI_CTRL_HDR_SIZE) {\n\t\tnfc_err(&client->dev, \"Incorrect header length: %u\\n\", r);\n\t\tr = -EBADMSG;\n\t\tgoto nci_read_exit;\n\t}\n\n\t*skb = alloc_skb(NCI_CTRL_HDR_SIZE + header.plen, GFP_KERNEL);\n\tif (*skb == NULL) {\n\t\tr = -ENOMEM;\n\t\tgoto nci_read_exit;\n\t}\n\n\tskb_put_data(*skb, (void *)&header, NCI_CTRL_HDR_SIZE);\n\n\tif (!header.plen)\n\t\treturn 0;\n\n\tr = i2c_master_recv(client, skb_put(*skb, header.plen), header.plen);\n\tif (r < 0) {\n\t\tgoto nci_read_exit_free_skb;\n\t} else if (r != header.plen) {\n\t\tnfc_err(&client->dev,\n\t\t\t\"Invalid frame payload length: %u (expected %u)\\n\",\n\t\t\tr, header.plen);\n\t\tr = -EBADMSG;\n\t\tgoto nci_read_exit_free_skb;\n\t}\n\n\treturn 0;\n\nnci_read_exit_free_skb:\n\tkfree_skb(*skb);\nnci_read_exit:\n\treturn r;\n}\n\nstatic irqreturn_t nxp_nci_i2c_irq_thread_fn(int irq, void *phy_id)\n{\n\tstruct nxp_nci_i2c_phy *phy = phy_id;\n\tstruct i2c_client *client;\n\tstruct nxp_nci_info *info;\n\n\tstruct sk_buff *skb = NULL;\n\tint r = 0;\n\n\tif (!phy || !phy->ndev)\n\t\tgoto exit_irq_none;\n\n\tclient = phy->i2c_dev;\n\n\tif (!client || irq != client->irq)\n\t\tgoto exit_irq_none;\n\n\tinfo = nci_get_drvdata(phy->ndev);\n\n\tif (!info)\n\t\tgoto exit_irq_none;\n\n\tmutex_lock(&info->info_lock);\n\n\tif (phy->hard_fault != 0)\n\t\tgoto exit_irq_handled;\n\n\tswitch (info->mode) {\n\tcase NXP_NCI_MODE_NCI:\n\t\tr = nxp_nci_i2c_nci_read(phy, &skb);\n\t\tbreak;\n\tcase NXP_NCI_MODE_FW:\n\t\tr = nxp_nci_i2c_fw_read(phy, &skb);\n\t\tbreak;\n\tcase NXP_NCI_MODE_COLD:\n\t\tr = -EREMOTEIO;\n\t\tbreak;\n\t}\n\n\tif (r == -EREMOTEIO) {\n\t\tphy->hard_fault = r;\n\t\tif (info->mode == NXP_NCI_MODE_FW)\n\t\t\tnxp_nci_fw_recv_frame(phy->ndev, NULL);\n\t}\n\tif (r < 0) {\n\t\tnfc_err(&client->dev, \"Read failed with error %d\\n\", r);\n\t\tgoto exit_irq_handled;\n\t}\n\n\tswitch (info->mode) {\n\tcase NXP_NCI_MODE_NCI:\n\t\tnci_recv_frame(phy->ndev, skb);\n\t\tbreak;\n\tcase NXP_NCI_MODE_FW:\n\t\tnxp_nci_fw_recv_frame(phy->ndev, skb);\n\t\tbreak;\n\tcase NXP_NCI_MODE_COLD:\n\t\tbreak;\n\t}\n\nexit_irq_handled:\n\tmutex_unlock(&info->info_lock);\n\treturn IRQ_HANDLED;\nexit_irq_none:\n\tWARN_ON_ONCE(1);\n\treturn IRQ_NONE;\n}\n\nstatic const struct acpi_gpio_params firmware_gpios = { 1, 0, false };\nstatic const struct acpi_gpio_params enable_gpios = { 2, 0, false };\n\nstatic const struct acpi_gpio_mapping acpi_nxp_nci_gpios[] = {\n\t{ \"enable-gpios\", &enable_gpios, 1 },\n\t{ \"firmware-gpios\", &firmware_gpios, 1 },\n\t{ }\n};\n\nstatic int nxp_nci_i2c_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct nxp_nci_i2c_phy *phy;\n\tint r;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\n\t\tnfc_err(&client->dev, \"Need I2C_FUNC_I2C\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tphy = devm_kzalloc(&client->dev, sizeof(struct nxp_nci_i2c_phy),\n\t\t\t   GFP_KERNEL);\n\tif (!phy)\n\t\treturn -ENOMEM;\n\n\tphy->i2c_dev = client;\n\ti2c_set_clientdata(client, phy);\n\n\tr = devm_acpi_dev_add_driver_gpios(dev, acpi_nxp_nci_gpios);\n\tif (r)\n\t\tdev_dbg(dev, \"Unable to add GPIO mapping table\\n\");\n\n\tphy->gpiod_en = devm_gpiod_get(dev, \"enable\", GPIOD_OUT_LOW);\n\tif (IS_ERR(phy->gpiod_en)) {\n\t\tnfc_err(dev, \"Failed to get EN gpio\\n\");\n\t\treturn PTR_ERR(phy->gpiod_en);\n\t}\n\n\tphy->gpiod_fw = devm_gpiod_get_optional(dev, \"firmware\", GPIOD_OUT_LOW);\n\tif (IS_ERR(phy->gpiod_fw)) {\n\t\tnfc_err(dev, \"Failed to get FW gpio\\n\");\n\t\treturn PTR_ERR(phy->gpiod_fw);\n\t}\n\n\tr = nxp_nci_probe(phy, &client->dev, &i2c_phy_ops,\n\t\t\t  NXP_NCI_I2C_MAX_PAYLOAD, &phy->ndev);\n\tif (r < 0)\n\t\treturn r;\n\n\tr = request_threaded_irq(client->irq, NULL,\n\t\t\t\t nxp_nci_i2c_irq_thread_fn,\n\t\t\t\t IRQF_TRIGGER_RISING | IRQF_ONESHOT,\n\t\t\t\t NXP_NCI_I2C_DRIVER_NAME, phy);\n\tif (r < 0)\n\t\tnfc_err(&client->dev, \"Unable to register IRQ handler\\n\");\n\n\treturn r;\n}\n\nstatic void nxp_nci_i2c_remove(struct i2c_client *client)\n{\n\tstruct nxp_nci_i2c_phy *phy = i2c_get_clientdata(client);\n\n\tnxp_nci_remove(phy->ndev);\n\tfree_irq(client->irq, phy);\n}\n\nstatic const struct i2c_device_id nxp_nci_i2c_id_table[] = {\n\t{\"nxp-nci_i2c\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, nxp_nci_i2c_id_table);\n\nstatic const struct of_device_id of_nxp_nci_i2c_match[] = {\n\t{ .compatible = \"nxp,nxp-nci-i2c\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, of_nxp_nci_i2c_match);\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id acpi_id[] = {\n\t{ \"NXP1001\" },\n\t{ \"NXP1002\" },\n\t{ \"NXP7471\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, acpi_id);\n#endif\n\nstatic struct i2c_driver nxp_nci_i2c_driver = {\n\t.driver = {\n\t\t   .name = NXP_NCI_I2C_DRIVER_NAME,\n\t\t   .acpi_match_table = ACPI_PTR(acpi_id),\n\t\t   .of_match_table = of_nxp_nci_i2c_match,\n\t\t  },\n\t.probe = nxp_nci_i2c_probe,\n\t.id_table = nxp_nci_i2c_id_table,\n\t.remove = nxp_nci_i2c_remove,\n};\n\nmodule_i2c_driver(nxp_nci_i2c_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"I2C driver for NXP NCI NFC controllers\");\nMODULE_AUTHOR(\"Cl\u00e9ment Perrochaud <clement.perrochaud@nxp.com>\");\nMODULE_AUTHOR(\"Oleg Zhurakivskyy <oleg.zhurakivskyy@intel.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}