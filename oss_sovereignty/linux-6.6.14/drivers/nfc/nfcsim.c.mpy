{
  "module_name": "nfcsim.c",
  "hash_id": "eb649c19c9bb368ed2fc156508df5dcac7cade79ab8df596348c0c6a05d373ce",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nfc/nfcsim.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/debugfs.h>\n#include <linux/nfc.h>\n#include <net/nfc/nfc.h>\n#include <net/nfc/digital.h>\n\n#define NFCSIM_ERR(d, fmt, args...) nfc_err(&d->nfc_digital_dev->nfc_dev->dev, \\\n\t\t\t\t\t    \"%s: \" fmt, __func__, ## args)\n\n#define NFCSIM_DBG(d, fmt, args...) dev_dbg(&d->nfc_digital_dev->nfc_dev->dev, \\\n\t\t\t\t\t    \"%s: \" fmt, __func__, ## args)\n\n#define NFCSIM_VERSION \"0.2\"\n\n#define NFCSIM_MODE_NONE\t0\n#define NFCSIM_MODE_INITIATOR\t1\n#define NFCSIM_MODE_TARGET\t2\n\n#define NFCSIM_CAPABILITIES (NFC_DIGITAL_DRV_CAPS_IN_CRC   | \\\n\t\t\t     NFC_DIGITAL_DRV_CAPS_TG_CRC)\n\nstruct nfcsim {\n\tstruct nfc_digital_dev *nfc_digital_dev;\n\n\tstruct work_struct recv_work;\n\tstruct delayed_work send_work;\n\n\tstruct nfcsim_link *link_in;\n\tstruct nfcsim_link *link_out;\n\n\tbool up;\n\tu8 mode;\n\tu8 rf_tech;\n\n\tu16 recv_timeout;\n\n\tnfc_digital_cmd_complete_t cb;\n\tvoid *arg;\n\n\tu8 dropframe;\n};\n\nstruct nfcsim_link {\n\tstruct mutex lock;\n\n\tu8 rf_tech;\n\tu8 mode;\n\n\tu8 shutdown;\n\n\tstruct sk_buff *skb;\n\twait_queue_head_t recv_wait;\n\tu8 cond;\n};\n\nstatic struct nfcsim_link *nfcsim_link_new(void)\n{\n\tstruct nfcsim_link *link;\n\n\tlink = kzalloc(sizeof(struct nfcsim_link), GFP_KERNEL);\n\tif (!link)\n\t\treturn NULL;\n\n\tmutex_init(&link->lock);\n\tinit_waitqueue_head(&link->recv_wait);\n\n\treturn link;\n}\n\nstatic void nfcsim_link_free(struct nfcsim_link *link)\n{\n\tdev_kfree_skb(link->skb);\n\tkfree(link);\n}\n\nstatic void nfcsim_link_recv_wake(struct nfcsim_link *link)\n{\n\tlink->cond = 1;\n\twake_up_interruptible(&link->recv_wait);\n}\n\nstatic void nfcsim_link_set_skb(struct nfcsim_link *link, struct sk_buff *skb,\n\t\t\t\tu8 rf_tech, u8 mode)\n{\n\tmutex_lock(&link->lock);\n\n\tdev_kfree_skb(link->skb);\n\tlink->skb = skb;\n\tlink->rf_tech = rf_tech;\n\tlink->mode = mode;\n\n\tmutex_unlock(&link->lock);\n}\n\nstatic void nfcsim_link_recv_cancel(struct nfcsim_link *link)\n{\n\tmutex_lock(&link->lock);\n\n\tlink->mode = NFCSIM_MODE_NONE;\n\n\tmutex_unlock(&link->lock);\n\n\tnfcsim_link_recv_wake(link);\n}\n\nstatic void nfcsim_link_shutdown(struct nfcsim_link *link)\n{\n\tmutex_lock(&link->lock);\n\n\tlink->shutdown = 1;\n\tlink->mode = NFCSIM_MODE_NONE;\n\n\tmutex_unlock(&link->lock);\n\n\tnfcsim_link_recv_wake(link);\n}\n\nstatic struct sk_buff *nfcsim_link_recv_skb(struct nfcsim_link *link,\n\t\t\t\t\t    int timeout, u8 rf_tech, u8 mode)\n{\n\tint rc;\n\tstruct sk_buff *skb;\n\n\trc = wait_event_interruptible_timeout(link->recv_wait,\n\t\t\t\t\t      link->cond,\n\t\t\t\t\t      msecs_to_jiffies(timeout));\n\n\tmutex_lock(&link->lock);\n\n\tskb = link->skb;\n\tlink->skb = NULL;\n\n\tif (!rc) {\n\t\trc = -ETIMEDOUT;\n\t\tgoto done;\n\t}\n\n\tif (!skb || link->rf_tech != rf_tech || link->mode == mode) {\n\t\trc = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tif (link->shutdown) {\n\t\trc = -ENODEV;\n\t\tgoto done;\n\t}\n\ndone:\n\tmutex_unlock(&link->lock);\n\n\tif (rc < 0) {\n\t\tdev_kfree_skb(skb);\n\t\tskb = ERR_PTR(rc);\n\t}\n\n\tlink->cond = 0;\n\n\treturn skb;\n}\n\nstatic void nfcsim_send_wq(struct work_struct *work)\n{\n\tstruct nfcsim *dev = container_of(work, struct nfcsim, send_work.work);\n\n\t \n\tnfcsim_link_recv_wake(dev->link_out);\n}\n\nstatic void nfcsim_recv_wq(struct work_struct *work)\n{\n\tstruct nfcsim *dev = container_of(work, struct nfcsim, recv_work);\n\tstruct sk_buff *skb;\n\n\tskb = nfcsim_link_recv_skb(dev->link_in, dev->recv_timeout,\n\t\t\t\t   dev->rf_tech, dev->mode);\n\n\tif (!dev->up) {\n\t\tNFCSIM_ERR(dev, \"Device is down\\n\");\n\n\t\tif (!IS_ERR(skb))\n\t\t\tdev_kfree_skb(skb);\n\t\treturn;\n\t}\n\n\tdev->cb(dev->nfc_digital_dev, dev->arg, skb);\n}\n\nstatic int nfcsim_send(struct nfc_digital_dev *ddev, struct sk_buff *skb,\n\t\t       u16 timeout, nfc_digital_cmd_complete_t cb, void *arg)\n{\n\tstruct nfcsim *dev = nfc_digital_get_drvdata(ddev);\n\tu8 delay;\n\n\tif (!dev->up) {\n\t\tNFCSIM_ERR(dev, \"Device is down\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdev->recv_timeout = timeout;\n\tdev->cb = cb;\n\tdev->arg = arg;\n\n\tschedule_work(&dev->recv_work);\n\n\tif (dev->dropframe) {\n\t\tNFCSIM_DBG(dev, \"dropping frame (out of %d)\\n\", dev->dropframe);\n\t\tdev_kfree_skb(skb);\n\t\tdev->dropframe--;\n\n\t\treturn 0;\n\t}\n\n\tif (skb) {\n\t\tnfcsim_link_set_skb(dev->link_out, skb, dev->rf_tech,\n\t\t\t\t    dev->mode);\n\n\t\t \n\t\tget_random_bytes(&delay, 1);\n\t\tdelay = 3 + (delay & 0x07);\n\n\t\tschedule_delayed_work(&dev->send_work, msecs_to_jiffies(delay));\n\t}\n\n\treturn 0;\n}\n\nstatic void nfcsim_abort_cmd(struct nfc_digital_dev *ddev)\n{\n\tconst struct nfcsim *dev = nfc_digital_get_drvdata(ddev);\n\n\tnfcsim_link_recv_cancel(dev->link_in);\n}\n\nstatic int nfcsim_switch_rf(struct nfc_digital_dev *ddev, bool on)\n{\n\tstruct nfcsim *dev = nfc_digital_get_drvdata(ddev);\n\n\tdev->up = on;\n\n\treturn 0;\n}\n\nstatic int nfcsim_in_configure_hw(struct nfc_digital_dev *ddev,\n\t\t\t\t\t  int type, int param)\n{\n\tstruct nfcsim *dev = nfc_digital_get_drvdata(ddev);\n\n\tswitch (type) {\n\tcase NFC_DIGITAL_CONFIG_RF_TECH:\n\t\tdev->up = true;\n\t\tdev->mode = NFCSIM_MODE_INITIATOR;\n\t\tdev->rf_tech = param;\n\t\tbreak;\n\n\tcase NFC_DIGITAL_CONFIG_FRAMING:\n\t\tbreak;\n\n\tdefault:\n\t\tNFCSIM_ERR(dev, \"Invalid configuration type: %d\\n\", type);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int nfcsim_in_send_cmd(struct nfc_digital_dev *ddev,\n\t\t\t       struct sk_buff *skb, u16 timeout,\n\t\t\t       nfc_digital_cmd_complete_t cb, void *arg)\n{\n\treturn nfcsim_send(ddev, skb, timeout, cb, arg);\n}\n\nstatic int nfcsim_tg_configure_hw(struct nfc_digital_dev *ddev,\n\t\t\t\t\t  int type, int param)\n{\n\tstruct nfcsim *dev = nfc_digital_get_drvdata(ddev);\n\n\tswitch (type) {\n\tcase NFC_DIGITAL_CONFIG_RF_TECH:\n\t\tdev->up = true;\n\t\tdev->mode = NFCSIM_MODE_TARGET;\n\t\tdev->rf_tech = param;\n\t\tbreak;\n\n\tcase NFC_DIGITAL_CONFIG_FRAMING:\n\t\tbreak;\n\n\tdefault:\n\t\tNFCSIM_ERR(dev, \"Invalid configuration type: %d\\n\", type);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int nfcsim_tg_send_cmd(struct nfc_digital_dev *ddev,\n\t\t\t       struct sk_buff *skb, u16 timeout,\n\t\t\t       nfc_digital_cmd_complete_t cb, void *arg)\n{\n\treturn nfcsim_send(ddev, skb, timeout, cb, arg);\n}\n\nstatic int nfcsim_tg_listen(struct nfc_digital_dev *ddev, u16 timeout,\n\t\t\t    nfc_digital_cmd_complete_t cb, void *arg)\n{\n\treturn nfcsim_send(ddev, NULL, timeout, cb, arg);\n}\n\nstatic const struct nfc_digital_ops nfcsim_digital_ops = {\n\t.in_configure_hw = nfcsim_in_configure_hw,\n\t.in_send_cmd = nfcsim_in_send_cmd,\n\n\t.tg_listen = nfcsim_tg_listen,\n\t.tg_configure_hw = nfcsim_tg_configure_hw,\n\t.tg_send_cmd = nfcsim_tg_send_cmd,\n\n\t.abort_cmd = nfcsim_abort_cmd,\n\t.switch_rf = nfcsim_switch_rf,\n};\n\nstatic struct dentry *nfcsim_debugfs_root;\n\nstatic void nfcsim_debugfs_init(void)\n{\n\tnfcsim_debugfs_root = debugfs_create_dir(\"nfcsim\", NULL);\n}\n\nstatic void nfcsim_debugfs_remove(void)\n{\n\tdebugfs_remove_recursive(nfcsim_debugfs_root);\n}\n\nstatic void nfcsim_debugfs_init_dev(struct nfcsim *dev)\n{\n\tstruct dentry *dev_dir;\n\tchar devname[5];  \n\tu32 idx;\n\tint n;\n\n\tif (!nfcsim_debugfs_root) {\n\t\tNFCSIM_ERR(dev, \"nfcsim debugfs not initialized\\n\");\n\t\treturn;\n\t}\n\n\tidx = dev->nfc_digital_dev->nfc_dev->idx;\n\tn = snprintf(devname, sizeof(devname), \"nfc%d\", idx);\n\tif (n >= sizeof(devname)) {\n\t\tNFCSIM_ERR(dev, \"Could not compute dev name for dev %d\\n\", idx);\n\t\treturn;\n\t}\n\n\tdev_dir = debugfs_create_dir(devname, nfcsim_debugfs_root);\n\n\tdebugfs_create_u8(\"dropframe\", 0664, dev_dir, &dev->dropframe);\n}\n\nstatic struct nfcsim *nfcsim_device_new(struct nfcsim_link *link_in,\n\t\t\t\t\tstruct nfcsim_link *link_out)\n{\n\tstruct nfcsim *dev;\n\tint rc;\n\n\tdev = kzalloc(sizeof(struct nfcsim), GFP_KERNEL);\n\tif (!dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_DELAYED_WORK(&dev->send_work, nfcsim_send_wq);\n\tINIT_WORK(&dev->recv_work, nfcsim_recv_wq);\n\n\tdev->nfc_digital_dev =\n\t\t\tnfc_digital_allocate_device(&nfcsim_digital_ops,\n\t\t\t\t\t\t    NFC_PROTO_NFC_DEP_MASK,\n\t\t\t\t\t\t    NFCSIM_CAPABILITIES,\n\t\t\t\t\t\t    0, 0);\n\tif (!dev->nfc_digital_dev) {\n\t\tkfree(dev);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tnfc_digital_set_drvdata(dev->nfc_digital_dev, dev);\n\n\tdev->link_in = link_in;\n\tdev->link_out = link_out;\n\n\trc = nfc_digital_register_device(dev->nfc_digital_dev);\n\tif (rc) {\n\t\tpr_err(\"Could not register digital device (%d)\\n\", rc);\n\t\tnfc_digital_free_device(dev->nfc_digital_dev);\n\t\tkfree(dev);\n\n\t\treturn ERR_PTR(rc);\n\t}\n\n\tnfcsim_debugfs_init_dev(dev);\n\n\treturn dev;\n}\n\nstatic void nfcsim_device_free(struct nfcsim *dev)\n{\n\tnfc_digital_unregister_device(dev->nfc_digital_dev);\n\n\tdev->up = false;\n\n\tnfcsim_link_shutdown(dev->link_in);\n\n\tcancel_delayed_work_sync(&dev->send_work);\n\tcancel_work_sync(&dev->recv_work);\n\n\tnfc_digital_free_device(dev->nfc_digital_dev);\n\n\tkfree(dev);\n}\n\nstatic struct nfcsim *dev0;\nstatic struct nfcsim *dev1;\n\nstatic int __init nfcsim_init(void)\n{\n\tstruct nfcsim_link *link0, *link1;\n\tint rc;\n\n\tlink0 = nfcsim_link_new();\n\tlink1 = nfcsim_link_new();\n\tif (!link0 || !link1) {\n\t\trc = -ENOMEM;\n\t\tgoto exit_err;\n\t}\n\n\tnfcsim_debugfs_init();\n\n\tdev0 = nfcsim_device_new(link0, link1);\n\tif (IS_ERR(dev0)) {\n\t\trc = PTR_ERR(dev0);\n\t\tgoto exit_err;\n\t}\n\n\tdev1 = nfcsim_device_new(link1, link0);\n\tif (IS_ERR(dev1)) {\n\t\tnfcsim_device_free(dev0);\n\n\t\trc = PTR_ERR(dev1);\n\t\tgoto exit_err;\n\t}\n\n\tpr_info(\"nfcsim \" NFCSIM_VERSION \" initialized\\n\");\n\n\treturn 0;\n\nexit_err:\n\tpr_err(\"Failed to initialize nfcsim driver (%d)\\n\", rc);\n\n\tif (link0)\n\t\tnfcsim_link_free(link0);\n\tif (link1)\n\t\tnfcsim_link_free(link1);\n\n\treturn rc;\n}\n\nstatic void __exit nfcsim_exit(void)\n{\n\tstruct nfcsim_link *link0, *link1;\n\n\tlink0 = dev0->link_in;\n\tlink1 = dev0->link_out;\n\n\tnfcsim_device_free(dev0);\n\tnfcsim_device_free(dev1);\n\n\tnfcsim_link_free(link0);\n\tnfcsim_link_free(link1);\n\n\tnfcsim_debugfs_remove();\n}\n\nmodule_init(nfcsim_init);\nmodule_exit(nfcsim_exit);\n\nMODULE_DESCRIPTION(\"NFCSim driver ver \" NFCSIM_VERSION);\nMODULE_VERSION(NFCSIM_VERSION);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}