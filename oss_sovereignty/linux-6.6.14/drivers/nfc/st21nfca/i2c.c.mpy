{
  "module_name": "i2c.c",
  "hash_id": "f41f3893fca142cc71912d7751b30558fcdf09f2904c6fea7ef3601f77dfb334",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nfc/st21nfca/i2c.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/crc-ccitt.h>\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/gpio/consumer.h>\n#include <linux/of_irq.h>\n#include <linux/of_gpio.h>\n#include <linux/acpi.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/nfc.h>\n#include <linux/firmware.h>\n\n#include <net/nfc/hci.h>\n#include <net/nfc/llc.h>\n#include <net/nfc/nfc.h>\n\n#include \"st21nfca.h\"\n\n \n#define ST21NFCA_SOF_EOF\t\t0x7e\n#define ST21NFCA_BYTE_STUFFING_MASK\t0x20\n#define ST21NFCA_ESCAPE_BYTE_STUFFING\t0x7d\n\n \n#define ST21NFCA_FRAME_HEADROOM\t\t\t2\n\n \n#define ST21NFCA_FRAME_TAILROOM 3\n#define IS_START_OF_FRAME(buf) (buf[0] == ST21NFCA_SOF_EOF && \\\n\t\t\t\tbuf[1] == 0)\n\n#define ST21NFCA_HCI_DRIVER_NAME \"st21nfca_hci\"\n#define ST21NFCA_HCI_I2C_DRIVER_NAME \"st21nfca_hci_i2c\"\n\nstruct st21nfca_i2c_phy {\n\tstruct i2c_client *i2c_dev;\n\tstruct nfc_hci_dev *hdev;\n\n\tstruct gpio_desc *gpiod_ena;\n\tstruct st21nfca_se_status se_status;\n\n\tstruct sk_buff *pending_skb;\n\tint current_read_len;\n\t \n\tint crc_trials;\n\n\tint powered;\n\tint run_mode;\n\n\t \n\tint hard_fault;\n\tstruct mutex phy_lock;\n};\n\nstatic const u8 len_seq[] = { 16, 24, 12, 29 };\nstatic const u16 wait_tab[] = { 2, 3, 5, 15, 20, 40};\n\n#define I2C_DUMP_SKB(info, skb)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tpr_debug(\"%s:\\n\", info);\t\t\t\t\\\n\tprint_hex_dump(KERN_DEBUG, \"i2c: \", DUMP_PREFIX_OFFSET,\t\\\n\t\t       16, 1, (skb)->data, (skb)->len, 0);\t\\\n} while (0)\n\n \nstatic int st21nfca_hci_platform_init(struct st21nfca_i2c_phy *phy)\n{\n\tu16 wait_reboot[] = { 50, 300, 1000 };\n\tchar reboot_cmd[] = { 0x7E, 0x66, 0x48, 0xF6, 0x7E };\n\tu8 tmp[ST21NFCA_HCI_LLC_MAX_SIZE];\n\tint i, r = -1;\n\n\tfor (i = 0; i < ARRAY_SIZE(wait_reboot) && r < 0; i++) {\n\t\tr = i2c_master_send(phy->i2c_dev, reboot_cmd,\n\t\t\t\t    sizeof(reboot_cmd));\n\t\tif (r < 0)\n\t\t\tmsleep(wait_reboot[i]);\n\t}\n\tif (r < 0)\n\t\treturn r;\n\n\t \n\tmsleep(20);\n\tr = -1;\n\tfor (i = 0; i < ARRAY_SIZE(wait_reboot) && r < 0; i++) {\n\t\tr = i2c_master_recv(phy->i2c_dev, tmp,\n\t\t\t\t    ST21NFCA_HCI_LLC_MAX_SIZE);\n\t\tif (r < 0)\n\t\t\tmsleep(wait_reboot[i]);\n\t}\n\tif (r < 0)\n\t\treturn r;\n\n\tfor (i = 0; i < ST21NFCA_HCI_LLC_MAX_SIZE &&\n\t\ttmp[i] == ST21NFCA_SOF_EOF; i++)\n\t\t;\n\n\tif (r != ST21NFCA_HCI_LLC_MAX_SIZE)\n\t\treturn -ENODEV;\n\n\tusleep_range(1000, 1500);\n\treturn 0;\n}\n\nstatic int st21nfca_hci_i2c_enable(void *phy_id)\n{\n\tstruct st21nfca_i2c_phy *phy = phy_id;\n\n\tgpiod_set_value(phy->gpiod_ena, 1);\n\tphy->powered = 1;\n\tphy->run_mode = ST21NFCA_HCI_MODE;\n\n\tusleep_range(10000, 15000);\n\n\treturn 0;\n}\n\nstatic void st21nfca_hci_i2c_disable(void *phy_id)\n{\n\tstruct st21nfca_i2c_phy *phy = phy_id;\n\n\tgpiod_set_value(phy->gpiod_ena, 0);\n\n\tphy->powered = 0;\n}\n\nstatic void st21nfca_hci_add_len_crc(struct sk_buff *skb)\n{\n\tu16 crc;\n\tu8 tmp;\n\n\t*(u8 *)skb_push(skb, 1) = 0;\n\n\tcrc = crc_ccitt(0xffff, skb->data, skb->len);\n\tcrc = ~crc;\n\n\ttmp = crc & 0x00ff;\n\tskb_put_u8(skb, tmp);\n\n\ttmp = (crc >> 8) & 0x00ff;\n\tskb_put_u8(skb, tmp);\n}\n\nstatic void st21nfca_hci_remove_len_crc(struct sk_buff *skb)\n{\n\tskb_pull(skb, ST21NFCA_FRAME_HEADROOM);\n\tskb_trim(skb, skb->len - ST21NFCA_FRAME_TAILROOM);\n}\n\n \nstatic int st21nfca_hci_i2c_write(void *phy_id, struct sk_buff *skb)\n{\n\tint r = -1, i, j;\n\tstruct st21nfca_i2c_phy *phy = phy_id;\n\tstruct i2c_client *client = phy->i2c_dev;\n\tu8 tmp[ST21NFCA_HCI_LLC_MAX_SIZE * 2];\n\n\tI2C_DUMP_SKB(\"st21nfca_hci_i2c_write\", skb);\n\n\tif (phy->hard_fault != 0)\n\t\treturn phy->hard_fault;\n\n\t \n\tst21nfca_hci_add_len_crc(skb);\n\n\t \n\tskb_put_u8(skb, ST21NFCA_SOF_EOF);\n\t \n\t*(u8 *)skb_push(skb, 1) = ST21NFCA_SOF_EOF;\n\n\t \n\ttmp[0] = skb->data[0];\n\tfor (i = 1, j = 1; i < skb->len - 1; i++, j++) {\n\t\tif (skb->data[i] == ST21NFCA_SOF_EOF\n\t\t    || skb->data[i] == ST21NFCA_ESCAPE_BYTE_STUFFING) {\n\t\t\ttmp[j] = ST21NFCA_ESCAPE_BYTE_STUFFING;\n\t\t\tj++;\n\t\t\ttmp[j] = skb->data[i] ^ ST21NFCA_BYTE_STUFFING_MASK;\n\t\t} else {\n\t\t\ttmp[j] = skb->data[i];\n\t\t}\n\t}\n\ttmp[j] = skb->data[i];\n\tj++;\n\n\t \n\tmutex_lock(&phy->phy_lock);\n\tfor (i = 0; i < ARRAY_SIZE(wait_tab) && r < 0; i++) {\n\t\tr = i2c_master_send(client, tmp, j);\n\t\tif (r < 0)\n\t\t\tmsleep(wait_tab[i]);\n\t}\n\tmutex_unlock(&phy->phy_lock);\n\n\tif (r >= 0) {\n\t\tif (r != j)\n\t\t\tr = -EREMOTEIO;\n\t\telse\n\t\t\tr = 0;\n\t}\n\n\tst21nfca_hci_remove_len_crc(skb);\n\n\treturn r;\n}\n\nstatic int get_frame_size(u8 *buf, int buflen)\n{\n\tint len = 0;\n\n\tif (buf[len + 1] == ST21NFCA_SOF_EOF)\n\t\treturn 0;\n\n\tfor (len = 1; len < buflen && buf[len] != ST21NFCA_SOF_EOF; len++)\n\t\t;\n\n\treturn len;\n}\n\nstatic int check_crc(u8 *buf, int buflen)\n{\n\tu16 crc;\n\n\tcrc = crc_ccitt(0xffff, buf, buflen - 2);\n\tcrc = ~crc;\n\n\tif (buf[buflen - 2] != (crc & 0xff) || buf[buflen - 1] != (crc >> 8)) {\n\t\tpr_err(ST21NFCA_HCI_DRIVER_NAME\n\t\t       \": CRC error 0x%x != 0x%x 0x%x\\n\", crc, buf[buflen - 1],\n\t\t       buf[buflen - 2]);\n\n\t\tpr_info(DRIVER_DESC \": %s : BAD CRC\\n\", __func__);\n\t\tprint_hex_dump(KERN_DEBUG, \"crc: \", DUMP_PREFIX_NONE,\n\t\t\t       16, 2, buf, buflen, false);\n\t\treturn -EPERM;\n\t}\n\treturn 0;\n}\n\n \nstatic int st21nfca_hci_i2c_repack(struct sk_buff *skb)\n{\n\tint i, j, r, size;\n\n\tif (skb->len < 1 || (skb->len > 1 && skb->data[1] != 0))\n\t\treturn -EBADMSG;\n\n\tsize = get_frame_size(skb->data, skb->len);\n\tif (size > 0) {\n\t\tskb_trim(skb, size);\n\t\t \n\t\tfor (i = 1, j = 0; i < skb->len; i++) {\n\t\t\tif (skb->data[i + j] ==\n\t\t\t\t\t(u8) ST21NFCA_ESCAPE_BYTE_STUFFING) {\n\t\t\t\tskb->data[i] = skb->data[i + j + 1]\n\t\t\t\t\t\t| ST21NFCA_BYTE_STUFFING_MASK;\n\t\t\t\ti++;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tskb->data[i] = skb->data[i + j];\n\t\t}\n\t\t \n\t\tskb_trim(skb, i - j);\n\t\t \n\t\tskb_pull(skb, 1);\n\n\t\tr = check_crc(skb->data, skb->len);\n\t\tif (r != 0)\n\t\t\treturn -EBADMSG;\n\n\t\t \n\t\tskb_pull(skb, 1);\n\t\t \n\t\tskb_trim(skb, skb->len - 2);\n\t\treturn skb->len;\n\t}\n\treturn 0;\n}\n\n \nstatic int st21nfca_hci_i2c_read(struct st21nfca_i2c_phy *phy,\n\t\t\t\t struct sk_buff *skb)\n{\n\tint r, i;\n\tu8 len;\n\tu8 buf[ST21NFCA_HCI_LLC_MAX_PAYLOAD];\n\tstruct i2c_client *client = phy->i2c_dev;\n\n\tif (phy->current_read_len < ARRAY_SIZE(len_seq)) {\n\t\tlen = len_seq[phy->current_read_len];\n\n\t\t \n\t\tr = 0;\n\t\tmutex_lock(&phy->phy_lock);\n\t\tfor (i = 0; i < ARRAY_SIZE(wait_tab) && r <= 0; i++) {\n\t\t\tr = i2c_master_recv(client, buf, len);\n\t\t\tif (r < 0)\n\t\t\t\tmsleep(wait_tab[i]);\n\t\t}\n\t\tmutex_unlock(&phy->phy_lock);\n\n\t\tif (r != len) {\n\t\t\tphy->current_read_len = 0;\n\t\t\treturn -EREMOTEIO;\n\t\t}\n\n\t\t \n\t\tif (!phy->current_read_len && !IS_START_OF_FRAME(buf)) {\n\t\t\tskb_trim(skb, 0);\n\t\t\tphy->current_read_len = 0;\n\t\t\treturn -EIO;\n\t\t} else if (phy->current_read_len && IS_START_OF_FRAME(buf)) {\n\t\t\t \n\t\t\tskb_trim(skb, 0);\n\t\t\tphy->current_read_len = 0;\n\t\t}\n\n\t\tskb_put_data(skb, buf, len);\n\n\t\tif (skb->data[skb->len - 1] == ST21NFCA_SOF_EOF) {\n\t\t\tphy->current_read_len = 0;\n\t\t\treturn st21nfca_hci_i2c_repack(skb);\n\t\t}\n\t\tphy->current_read_len++;\n\t\treturn -EAGAIN;\n\t}\n\treturn -EIO;\n}\n\n \nstatic irqreturn_t st21nfca_hci_irq_thread_fn(int irq, void *phy_id)\n{\n\tstruct st21nfca_i2c_phy *phy = phy_id;\n\n\tint r;\n\n\tif (!phy || irq != phy->i2c_dev->irq) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (phy->hard_fault != 0)\n\t\treturn IRQ_HANDLED;\n\n\tr = st21nfca_hci_i2c_read(phy, phy->pending_skb);\n\tif (r == -EREMOTEIO) {\n\t\tphy->hard_fault = r;\n\n\t\tnfc_hci_recv_frame(phy->hdev, NULL);\n\n\t\treturn IRQ_HANDLED;\n\t} else if (r == -EAGAIN || r == -EIO) {\n\t\treturn IRQ_HANDLED;\n\t} else if (r == -EBADMSG && phy->crc_trials < ARRAY_SIZE(wait_tab)) {\n\t\t \n\t\tmsleep(wait_tab[phy->crc_trials]);\n\t\tphy->crc_trials++;\n\t\tphy->current_read_len = 0;\n\t\tkfree_skb(phy->pending_skb);\n\t} else if (r > 0) {\n\t\t \n\t\tnfc_hci_recv_frame(phy->hdev, phy->pending_skb);\n\t\tphy->crc_trials = 0;\n\t} else {\n\t\tkfree_skb(phy->pending_skb);\n\t}\n\n\tphy->pending_skb = alloc_skb(ST21NFCA_HCI_LLC_MAX_SIZE * 2, GFP_KERNEL);\n\tif (phy->pending_skb == NULL) {\n\t\tphy->hard_fault = -ENOMEM;\n\t\tnfc_hci_recv_frame(phy->hdev, NULL);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct nfc_phy_ops i2c_phy_ops = {\n\t.write = st21nfca_hci_i2c_write,\n\t.enable = st21nfca_hci_i2c_enable,\n\t.disable = st21nfca_hci_i2c_disable,\n};\n\nstatic const struct acpi_gpio_params enable_gpios = { 1, 0, false };\n\nstatic const struct acpi_gpio_mapping acpi_st21nfca_gpios[] = {\n\t{ \"enable-gpios\", &enable_gpios, 1 },\n\t{},\n};\n\nstatic int st21nfca_hci_i2c_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct st21nfca_i2c_phy *phy;\n\tint r;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\n\t\tnfc_err(&client->dev, \"Need I2C_FUNC_I2C\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tphy = devm_kzalloc(&client->dev, sizeof(struct st21nfca_i2c_phy),\n\t\t\t   GFP_KERNEL);\n\tif (!phy)\n\t\treturn -ENOMEM;\n\n\tphy->i2c_dev = client;\n\tphy->pending_skb = alloc_skb(ST21NFCA_HCI_LLC_MAX_SIZE * 2, GFP_KERNEL);\n\tif (phy->pending_skb == NULL)\n\t\treturn -ENOMEM;\n\n\tphy->current_read_len = 0;\n\tphy->crc_trials = 0;\n\tmutex_init(&phy->phy_lock);\n\ti2c_set_clientdata(client, phy);\n\n\tr = devm_acpi_dev_add_driver_gpios(dev, acpi_st21nfca_gpios);\n\tif (r)\n\t\tdev_dbg(dev, \"Unable to add GPIO mapping table\\n\");\n\n\t \n\tphy->gpiod_ena = devm_gpiod_get(dev, \"enable\", GPIOD_OUT_LOW);\n\tif (IS_ERR(phy->gpiod_ena)) {\n\t\tnfc_err(dev, \"Unable to get ENABLE GPIO\\n\");\n\t\tr = PTR_ERR(phy->gpiod_ena);\n\t\tgoto out_free;\n\t}\n\n\tphy->se_status.is_ese_present =\n\t\t\tdevice_property_read_bool(&client->dev, \"ese-present\");\n\tphy->se_status.is_uicc_present =\n\t\t\tdevice_property_read_bool(&client->dev, \"uicc-present\");\n\n\tr = st21nfca_hci_platform_init(phy);\n\tif (r < 0) {\n\t\tnfc_err(&client->dev, \"Unable to reboot st21nfca\\n\");\n\t\tgoto out_free;\n\t}\n\n\tr = devm_request_threaded_irq(&client->dev, client->irq, NULL,\n\t\t\t\tst21nfca_hci_irq_thread_fn,\n\t\t\t\tIRQF_ONESHOT,\n\t\t\t\tST21NFCA_HCI_DRIVER_NAME, phy);\n\tif (r < 0) {\n\t\tnfc_err(&client->dev, \"Unable to register IRQ handler\\n\");\n\t\tgoto out_free;\n\t}\n\n\tr = st21nfca_hci_probe(phy, &i2c_phy_ops, LLC_SHDLC_NAME,\n\t\t\t       ST21NFCA_FRAME_HEADROOM,\n\t\t\t       ST21NFCA_FRAME_TAILROOM,\n\t\t\t       ST21NFCA_HCI_LLC_MAX_PAYLOAD,\n\t\t\t       &phy->hdev,\n\t\t\t       &phy->se_status);\n\tif (r)\n\t\tgoto out_free;\n\n\treturn 0;\n\nout_free:\n\tkfree_skb(phy->pending_skb);\n\treturn r;\n}\n\nstatic void st21nfca_hci_i2c_remove(struct i2c_client *client)\n{\n\tstruct st21nfca_i2c_phy *phy = i2c_get_clientdata(client);\n\n\tst21nfca_hci_remove(phy->hdev);\n\n\tif (phy->powered)\n\t\tst21nfca_hci_i2c_disable(phy);\n\tkfree_skb(phy->pending_skb);\n}\n\nstatic const struct i2c_device_id st21nfca_hci_i2c_id_table[] = {\n\t{ST21NFCA_HCI_DRIVER_NAME, 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, st21nfca_hci_i2c_id_table);\n\nstatic const struct acpi_device_id st21nfca_hci_i2c_acpi_match[] __maybe_unused = {\n\t{\"SMO2100\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(acpi, st21nfca_hci_i2c_acpi_match);\n\nstatic const struct of_device_id of_st21nfca_i2c_match[] __maybe_unused = {\n\t{ .compatible = \"st,st21nfca-i2c\", },\n\t{ .compatible = \"st,st21nfca_i2c\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, of_st21nfca_i2c_match);\n\nstatic struct i2c_driver st21nfca_hci_i2c_driver = {\n\t.driver = {\n\t\t.name = ST21NFCA_HCI_I2C_DRIVER_NAME,\n\t\t.of_match_table = of_match_ptr(of_st21nfca_i2c_match),\n\t\t.acpi_match_table = ACPI_PTR(st21nfca_hci_i2c_acpi_match),\n\t},\n\t.probe = st21nfca_hci_i2c_probe,\n\t.id_table = st21nfca_hci_i2c_id_table,\n\t.remove = st21nfca_hci_i2c_remove,\n};\nmodule_i2c_driver(st21nfca_hci_i2c_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(DRIVER_DESC);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}