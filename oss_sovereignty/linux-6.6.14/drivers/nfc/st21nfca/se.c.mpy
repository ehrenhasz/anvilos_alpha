{
  "module_name": "se.c",
  "hash_id": "448c685aa37d61f909a733906d4170e39125acff069aee7a34321223e4347b4c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nfc/st21nfca/se.c",
  "human_readable_source": "\n \n\n#include <net/nfc/hci.h>\n\n#include \"st21nfca.h\"\n\n#define ST21NFCA_EVT_UICC_ACTIVATE\t\t0x10\n#define ST21NFCA_EVT_UICC_DEACTIVATE\t\t0x13\n#define ST21NFCA_EVT_SE_HARD_RESET\t\t0x20\n#define ST21NFCA_EVT_SE_SOFT_RESET\t\t0x11\n#define ST21NFCA_EVT_SE_END_OF_APDU_TRANSFER\t0x21\n#define ST21NFCA_EVT_SE_ACTIVATE\t\t0x22\n#define ST21NFCA_EVT_SE_DEACTIVATE\t\t0x23\n\n#define ST21NFCA_EVT_TRANSMIT_DATA\t\t0x10\n#define ST21NFCA_EVT_WTX_REQUEST\t\t0x11\n\n#define ST21NFCA_EVT_CONNECTIVITY\t\t0x10\n#define ST21NFCA_EVT_TRANSACTION\t\t0x12\n\n#define ST21NFCA_SE_TO_HOT_PLUG\t\t\t1000\n \n#define ST21NFCA_SE_COUNT_PIPE_UICC\t\t0x01\n \n#define ST21NFCA_SE_COUNT_PIPE_EMBEDDED\t0x02\n\n#define ST21NFCA_SE_MODE_OFF\t\t\t0x00\n#define ST21NFCA_SE_MODE_ON\t\t\t\t0x01\n\n#define ST21NFCA_PARAM_ATR\t\t\t\t0x01\n#define ST21NFCA_ATR_DEFAULT_BWI\t\t0x04\n\n \n#define ST21NFCA_BWI_TO_TIMEOUT(x)\t\t((1 << x) * 200)\n#define ST21NFCA_ATR_GET_Y_FROM_TD(x)\t(x >> 4)\n\n \n#define ST21NFCA_ATR_TA_PRESENT(x) (x & 0x01)\n \n#define ST21NFCA_ATR_TB_PRESENT(x) (x & 0x02)\n\nstatic u8 st21nfca_se_get_bwi(struct nfc_hci_dev *hdev)\n{\n\tint i;\n\tu8 td;\n\tstruct st21nfca_hci_info *info = nfc_hci_get_clientdata(hdev);\n\n\t \n\tfor (i = 1; i < ST21NFCA_ESE_MAX_LENGTH; i++) {\n\t\ttd = ST21NFCA_ATR_GET_Y_FROM_TD(info->se_info.atr[i]);\n\t\tif (ST21NFCA_ATR_TA_PRESENT(td))\n\t\t\ti++;\n\t\tif (ST21NFCA_ATR_TB_PRESENT(td)) {\n\t\t\ti++;\n\t\t\treturn info->se_info.atr[i] >> 4;\n\t\t}\n\t}\n\treturn ST21NFCA_ATR_DEFAULT_BWI;\n}\n\nstatic void st21nfca_se_get_atr(struct nfc_hci_dev *hdev)\n{\n\tint r;\n\tstruct sk_buff *skb;\n\tstruct st21nfca_hci_info *info = nfc_hci_get_clientdata(hdev);\n\n\tr = nfc_hci_get_param(hdev, ST21NFCA_APDU_READER_GATE,\n\t\t\tST21NFCA_PARAM_ATR, &skb);\n\tif (r < 0)\n\t\treturn;\n\n\tif (skb->len <= ST21NFCA_ESE_MAX_LENGTH) {\n\t\tmemcpy(info->se_info.atr, skb->data, skb->len);\n\t\tinfo->se_info.wt_timeout =\n\t\t\tST21NFCA_BWI_TO_TIMEOUT(st21nfca_se_get_bwi(hdev));\n\t}\n\tkfree_skb(skb);\n}\n\nstatic int st21nfca_hci_control_se(struct nfc_hci_dev *hdev, u32 se_idx,\n\t\t\t\tu8 state)\n{\n\tstruct st21nfca_hci_info *info = nfc_hci_get_clientdata(hdev);\n\tint r, i;\n\tstruct sk_buff *sk_host_list;\n\tu8 se_event, host_id;\n\n\tswitch (se_idx) {\n\tcase NFC_HCI_UICC_HOST_ID:\n\t\tse_event = (state == ST21NFCA_SE_MODE_ON ?\n\t\t\t\t\tST21NFCA_EVT_UICC_ACTIVATE :\n\t\t\t\t\tST21NFCA_EVT_UICC_DEACTIVATE);\n\n\t\tinfo->se_info.count_pipes = 0;\n\t\tinfo->se_info.expected_pipes = ST21NFCA_SE_COUNT_PIPE_UICC;\n\t\tbreak;\n\tcase ST21NFCA_ESE_HOST_ID:\n\t\tse_event = (state == ST21NFCA_SE_MODE_ON ?\n\t\t\t\t\tST21NFCA_EVT_SE_ACTIVATE :\n\t\t\t\t\tST21NFCA_EVT_SE_DEACTIVATE);\n\n\t\tinfo->se_info.count_pipes = 0;\n\t\tinfo->se_info.expected_pipes = ST21NFCA_SE_COUNT_PIPE_EMBEDDED;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\treinit_completion(&info->se_info.req_completion);\n\tr = nfc_hci_send_event(hdev, ST21NFCA_DEVICE_MGNT_GATE, se_event,\n\t\t\t       NULL, 0);\n\tif (r < 0)\n\t\treturn r;\n\n\tmod_timer(&info->se_info.se_active_timer, jiffies +\n\t\tmsecs_to_jiffies(ST21NFCA_SE_TO_HOT_PLUG));\n\tinfo->se_info.se_active = true;\n\n\t \n\twait_for_completion_interruptible(&info->se_info.req_completion);\n\n\tr = nfc_hci_get_param(hdev, NFC_HCI_ADMIN_GATE,\n\t\t\tNFC_HCI_ADMIN_HOST_LIST,\n\t\t\t&sk_host_list);\n\tif (r < 0)\n\t\treturn r;\n\n\tfor (i = 0; i < sk_host_list->len &&\n\t\tsk_host_list->data[i] != se_idx; i++)\n\t\t;\n\thost_id = sk_host_list->data[i];\n\tkfree_skb(sk_host_list);\n\n\tif (state == ST21NFCA_SE_MODE_ON && host_id == se_idx)\n\t\treturn se_idx;\n\telse if (state == ST21NFCA_SE_MODE_OFF && host_id != se_idx)\n\t\treturn se_idx;\n\n\treturn -1;\n}\n\nint st21nfca_hci_discover_se(struct nfc_hci_dev *hdev)\n{\n\tstruct st21nfca_hci_info *info = nfc_hci_get_clientdata(hdev);\n\tint se_count = 0;\n\n\tif (test_bit(ST21NFCA_FACTORY_MODE, &hdev->quirks))\n\t\treturn 0;\n\n\tif (info->se_status->is_uicc_present) {\n\t\tnfc_add_se(hdev->ndev, NFC_HCI_UICC_HOST_ID, NFC_SE_UICC);\n\t\tse_count++;\n\t}\n\n\tif (info->se_status->is_ese_present) {\n\t\tnfc_add_se(hdev->ndev, ST21NFCA_ESE_HOST_ID, NFC_SE_EMBEDDED);\n\t\tse_count++;\n\t}\n\n\treturn !se_count;\n}\nEXPORT_SYMBOL(st21nfca_hci_discover_se);\n\nint st21nfca_hci_enable_se(struct nfc_hci_dev *hdev, u32 se_idx)\n{\n\tint r;\n\n\t \n\tr = st21nfca_hci_control_se(hdev, se_idx, ST21NFCA_SE_MODE_ON);\n\tif (r == ST21NFCA_ESE_HOST_ID) {\n\t\tst21nfca_se_get_atr(hdev);\n\t\tr = nfc_hci_send_event(hdev, ST21NFCA_APDU_READER_GATE,\n\t\t\t\tST21NFCA_EVT_SE_SOFT_RESET, NULL, 0);\n\t\tif (r < 0)\n\t\t\treturn r;\n\t} else if (r < 0) {\n\t\t \n\t\tnfc_remove_se(hdev->ndev, se_idx);\n\t\treturn r;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(st21nfca_hci_enable_se);\n\nint st21nfca_hci_disable_se(struct nfc_hci_dev *hdev, u32 se_idx)\n{\n\tint r;\n\n\t \n\tr = st21nfca_hci_control_se(hdev, se_idx, ST21NFCA_SE_MODE_OFF);\n\tif (r < 0)\n\t\treturn r;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(st21nfca_hci_disable_se);\n\nint st21nfca_hci_se_io(struct nfc_hci_dev *hdev, u32 se_idx,\n\t\t\tu8 *apdu, size_t apdu_length,\n\t\t\tse_io_cb_t cb, void *cb_context)\n{\n\tstruct st21nfca_hci_info *info = nfc_hci_get_clientdata(hdev);\n\n\tpr_debug(\"se_io %x\\n\", se_idx);\n\n\tswitch (se_idx) {\n\tcase ST21NFCA_ESE_HOST_ID:\n\t\tinfo->se_info.cb = cb;\n\t\tinfo->se_info.cb_context = cb_context;\n\t\tmod_timer(&info->se_info.bwi_timer, jiffies +\n\t\t\t  msecs_to_jiffies(info->se_info.wt_timeout));\n\t\tinfo->se_info.bwi_active = true;\n\t\treturn nfc_hci_send_event(hdev, ST21NFCA_APDU_READER_GATE,\n\t\t\t\t\tST21NFCA_EVT_TRANSMIT_DATA,\n\t\t\t\t\tapdu, apdu_length);\n\tdefault:\n\t\t \n\t\tkfree(cb_context);\n\t\treturn -ENODEV;\n\t}\n}\nEXPORT_SYMBOL(st21nfca_hci_se_io);\n\nstatic void st21nfca_se_wt_work(struct work_struct *work)\n{\n\t \n\t \n\tu8 param = 0x01;\n\tstruct st21nfca_hci_info *info = container_of(work,\n\t\t\t\t\t\tstruct st21nfca_hci_info,\n\t\t\t\t\t\tse_info.timeout_work);\n\n\tinfo->se_info.bwi_active = false;\n\n\tif (!info->se_info.xch_error) {\n\t\tinfo->se_info.xch_error = true;\n\t\tnfc_hci_send_event(info->hdev, ST21NFCA_APDU_READER_GATE,\n\t\t\t\tST21NFCA_EVT_SE_SOFT_RESET, NULL, 0);\n\t} else {\n\t\tinfo->se_info.xch_error = false;\n\t\tnfc_hci_send_event(info->hdev, ST21NFCA_DEVICE_MGNT_GATE,\n\t\t\t\tST21NFCA_EVT_SE_HARD_RESET, &param, 1);\n\t}\n\tinfo->se_info.cb(info->se_info.cb_context, NULL, 0, -ETIME);\n}\n\nstatic void st21nfca_se_wt_timeout(struct timer_list *t)\n{\n\tstruct st21nfca_hci_info *info = from_timer(info, t, se_info.bwi_timer);\n\n\tschedule_work(&info->se_info.timeout_work);\n}\n\nstatic void st21nfca_se_activation_timeout(struct timer_list *t)\n{\n\tstruct st21nfca_hci_info *info = from_timer(info, t,\n\t\t\t\t\t\t    se_info.se_active_timer);\n\n\tinfo->se_info.se_active = false;\n\n\tcomplete(&info->se_info.req_completion);\n}\n\n \nint st21nfca_connectivity_event_received(struct nfc_hci_dev *hdev, u8 host,\n\t\t\t\tu8 event, struct sk_buff *skb)\n{\n\tint r = 0;\n\tstruct device *dev = &hdev->ndev->dev;\n\tstruct nfc_evt_transaction *transaction;\n\tu32 aid_len;\n\tu8 params_len;\n\n\tpr_debug(\"connectivity gate event: %x\\n\", event);\n\n\tswitch (event) {\n\tcase ST21NFCA_EVT_CONNECTIVITY:\n\t\tr = nfc_se_connectivity(hdev->ndev, host);\n\tbreak;\n\tcase ST21NFCA_EVT_TRANSACTION:\n\t\t \n\t\tif (skb->len < 2 || skb->data[0] != NFC_EVT_TRANSACTION_AID_TAG)\n\t\t\treturn -EPROTO;\n\n\t\taid_len = skb->data[1];\n\n\t\tif (skb->len < aid_len + 4 || aid_len > sizeof(transaction->aid))\n\t\t\treturn -EPROTO;\n\n\t\tparams_len = skb->data[aid_len + 3];\n\n\t\t \n\t\tif ((skb->data[aid_len + 2] != NFC_EVT_TRANSACTION_PARAMS_TAG) ||\n\t\t    (skb->len < aid_len + 4 + params_len))\n\t\t\treturn -EPROTO;\n\n\t\ttransaction = devm_kzalloc(dev, sizeof(*transaction) + params_len, GFP_KERNEL);\n\t\tif (!transaction)\n\t\t\treturn -ENOMEM;\n\n\t\ttransaction->aid_len = aid_len;\n\t\ttransaction->params_len = params_len;\n\n\t\tmemcpy(transaction->aid, &skb->data[2], aid_len);\n\t\tmemcpy(transaction->params, &skb->data[aid_len + 4], params_len);\n\n\t\tr = nfc_se_transaction(hdev->ndev, host, transaction);\n\tbreak;\n\tdefault:\n\t\tnfc_err(&hdev->ndev->dev, \"Unexpected event on connectivity gate\\n\");\n\t\treturn 1;\n\t}\n\tkfree_skb(skb);\n\treturn r;\n}\nEXPORT_SYMBOL(st21nfca_connectivity_event_received);\n\nint st21nfca_apdu_reader_event_received(struct nfc_hci_dev *hdev,\n\t\t\t\t\tu8 event, struct sk_buff *skb)\n{\n\tint r = 0;\n\tstruct st21nfca_hci_info *info = nfc_hci_get_clientdata(hdev);\n\n\tpr_debug(\"apdu reader gate event: %x\\n\", event);\n\n\tswitch (event) {\n\tcase ST21NFCA_EVT_TRANSMIT_DATA:\n\t\tdel_timer_sync(&info->se_info.bwi_timer);\n\t\tcancel_work_sync(&info->se_info.timeout_work);\n\t\tinfo->se_info.bwi_active = false;\n\t\tr = nfc_hci_send_event(hdev, ST21NFCA_DEVICE_MGNT_GATE,\n\t\t\t\tST21NFCA_EVT_SE_END_OF_APDU_TRANSFER, NULL, 0);\n\t\tif (r < 0)\n\t\t\tgoto exit;\n\n\t\tinfo->se_info.cb(info->se_info.cb_context,\n\t\t\tskb->data, skb->len, 0);\n\t\tbreak;\n\tcase ST21NFCA_EVT_WTX_REQUEST:\n\t\tmod_timer(&info->se_info.bwi_timer, jiffies +\n\t\t\t\tmsecs_to_jiffies(info->se_info.wt_timeout));\n\t\tbreak;\n\tdefault:\n\t\tnfc_err(&hdev->ndev->dev, \"Unexpected event on apdu reader gate\\n\");\n\t\treturn 1;\n\t}\n\nexit:\n\tkfree_skb(skb);\n\treturn r;\n}\nEXPORT_SYMBOL(st21nfca_apdu_reader_event_received);\n\nvoid st21nfca_se_init(struct nfc_hci_dev *hdev)\n{\n\tstruct st21nfca_hci_info *info = nfc_hci_get_clientdata(hdev);\n\n\tinit_completion(&info->se_info.req_completion);\n\tINIT_WORK(&info->se_info.timeout_work, st21nfca_se_wt_work);\n\t \n\ttimer_setup(&info->se_info.bwi_timer, st21nfca_se_wt_timeout, 0);\n\tinfo->se_info.bwi_active = false;\n\n\ttimer_setup(&info->se_info.se_active_timer,\n\t\t    st21nfca_se_activation_timeout, 0);\n\tinfo->se_info.se_active = false;\n\n\tinfo->se_info.count_pipes = 0;\n\tinfo->se_info.expected_pipes = 0;\n\n\tinfo->se_info.xch_error = false;\n\n\tinfo->se_info.wt_timeout =\n\t\t\tST21NFCA_BWI_TO_TIMEOUT(ST21NFCA_ATR_DEFAULT_BWI);\n}\nEXPORT_SYMBOL(st21nfca_se_init);\n\nvoid st21nfca_se_deinit(struct nfc_hci_dev *hdev)\n{\n\tstruct st21nfca_hci_info *info = nfc_hci_get_clientdata(hdev);\n\n\tif (info->se_info.bwi_active)\n\t\tdel_timer_sync(&info->se_info.bwi_timer);\n\tif (info->se_info.se_active)\n\t\tdel_timer_sync(&info->se_info.se_active_timer);\n\n\tcancel_work_sync(&info->se_info.timeout_work);\n\tinfo->se_info.bwi_active = false;\n\tinfo->se_info.se_active = false;\n}\nEXPORT_SYMBOL(st21nfca_se_deinit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}