{
  "module_name": "mei_phy.c",
  "hash_id": "863c2c5914569a55ad6ffdb4b08e76b95d45eab64e5a4e60d68edf692785f2c4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nfc/mei_phy.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/nfc.h>\n\n#include \"mei_phy.h\"\n\nstruct mei_nfc_hdr {\n\tu8 cmd;\n\tu8 status;\n\tu16 req_id;\n\tu32 reserved;\n\tu16 data_size;\n} __packed;\n\nstruct mei_nfc_cmd {\n\tstruct mei_nfc_hdr hdr;\n\tu8 sub_command;\n\tu8 data[];\n} __packed;\n\nstruct mei_nfc_reply {\n\tstruct mei_nfc_hdr hdr;\n\tu8 sub_command;\n\tu8 reply_status;\n\tu8 data[];\n} __packed;\n\nstruct mei_nfc_if_version {\n\tu8 radio_version_sw[3];\n\tu8 reserved[3];\n\tu8 radio_version_hw[3];\n\tu8 i2c_addr;\n\tu8 fw_ivn;\n\tu8 vendor_id;\n\tu8 radio_type;\n} __packed;\n\nstruct mei_nfc_connect {\n\tu8 fw_ivn;\n\tu8 vendor_id;\n} __packed;\n\nstruct mei_nfc_connect_resp {\n\tu8 fw_ivn;\n\tu8 vendor_id;\n\tu16 me_major;\n\tu16 me_minor;\n\tu16 me_hotfix;\n\tu16 me_build;\n} __packed;\n\n\n#define MEI_NFC_CMD_MAINTENANCE 0x00\n#define MEI_NFC_CMD_HCI_SEND 0x01\n#define MEI_NFC_CMD_HCI_RECV 0x02\n\n#define MEI_NFC_SUBCMD_CONNECT    0x00\n#define MEI_NFC_SUBCMD_IF_VERSION 0x01\n\n#define MEI_NFC_MAX_READ (MEI_NFC_HEADER_SIZE + MEI_NFC_MAX_HCI_PAYLOAD)\n\n#define MEI_DUMP_SKB_IN(info, skb)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tpr_debug(\"%s:\\n\", info);\t\t\t\t\\\n\tprint_hex_dump_debug(\"mei in : \", DUMP_PREFIX_OFFSET,\t\\\n\t\t\t16, 1, (skb)->data, (skb)->len, false);\t\\\n} while (0)\n\n#define MEI_DUMP_SKB_OUT(info, skb)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tpr_debug(\"%s:\\n\", info);\t\t\t\t\\\n\tprint_hex_dump_debug(\"mei out: \", DUMP_PREFIX_OFFSET,\t\\\n\t\t\t16, 1, (skb)->data, (skb)->len, false);\t\\\n} while (0)\n\n#define MEI_DUMP_NFC_HDR(info, _hdr)                                \\\ndo {                                                                \\\n\tpr_debug(\"%s:\\n\", info);                                    \\\n\tpr_debug(\"cmd=%02d status=%d req_id=%d rsvd=%d size=%d\\n\",  \\\n\t\t (_hdr)->cmd, (_hdr)->status, (_hdr)->req_id,       \\\n\t\t (_hdr)->reserved, (_hdr)->data_size);              \\\n} while (0)\n\nstatic int mei_nfc_if_version(struct nfc_mei_phy *phy)\n{\n\n\tstruct mei_nfc_cmd cmd;\n\tstruct mei_nfc_reply *reply = NULL;\n\tstruct mei_nfc_if_version *version;\n\tsize_t if_version_length;\n\tint bytes_recv, r;\n\n\tmemset(&cmd, 0, sizeof(struct mei_nfc_cmd));\n\tcmd.hdr.cmd = MEI_NFC_CMD_MAINTENANCE;\n\tcmd.hdr.data_size = 1;\n\tcmd.sub_command = MEI_NFC_SUBCMD_IF_VERSION;\n\n\tMEI_DUMP_NFC_HDR(\"version\", &cmd.hdr);\n\tr = mei_cldev_send(phy->cldev, (u8 *)&cmd, sizeof(struct mei_nfc_cmd));\n\tif (r < 0) {\n\t\tpr_err(\"Could not send IF version cmd\\n\");\n\t\treturn r;\n\t}\n\n\t \n\tif_version_length = sizeof(struct mei_nfc_reply) +\n\t\tsizeof(struct mei_nfc_if_version);\n\n\treply = kzalloc(if_version_length, GFP_KERNEL);\n\tif (!reply)\n\t\treturn -ENOMEM;\n\n\tbytes_recv = mei_cldev_recv(phy->cldev, (u8 *)reply, if_version_length);\n\tif (bytes_recv < 0 || bytes_recv < if_version_length) {\n\t\tpr_err(\"Could not read IF version\\n\");\n\t\tr = -EIO;\n\t\tgoto err;\n\t}\n\n\tversion = (struct mei_nfc_if_version *)reply->data;\n\n\tphy->fw_ivn = version->fw_ivn;\n\tphy->vendor_id = version->vendor_id;\n\tphy->radio_type = version->radio_type;\n\nerr:\n\tkfree(reply);\n\treturn r;\n}\n\nstatic int mei_nfc_connect(struct nfc_mei_phy *phy)\n{\n\tstruct mei_nfc_cmd *cmd, *reply;\n\tstruct mei_nfc_connect *connect;\n\tstruct mei_nfc_connect_resp *connect_resp;\n\tsize_t connect_length, connect_resp_length;\n\tint bytes_recv, r;\n\n\tconnect_length = sizeof(struct mei_nfc_cmd) +\n\t\t\tsizeof(struct mei_nfc_connect);\n\n\tconnect_resp_length = sizeof(struct mei_nfc_cmd) +\n\t\t\tsizeof(struct mei_nfc_connect_resp);\n\n\tcmd = kzalloc(connect_length, GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\tconnect = (struct mei_nfc_connect *)cmd->data;\n\n\treply = kzalloc(connect_resp_length, GFP_KERNEL);\n\tif (!reply) {\n\t\tkfree(cmd);\n\t\treturn -ENOMEM;\n\t}\n\n\tconnect_resp = (struct mei_nfc_connect_resp *)reply->data;\n\n\tcmd->hdr.cmd = MEI_NFC_CMD_MAINTENANCE;\n\tcmd->hdr.data_size = 3;\n\tcmd->sub_command = MEI_NFC_SUBCMD_CONNECT;\n\tconnect->fw_ivn = phy->fw_ivn;\n\tconnect->vendor_id = phy->vendor_id;\n\n\tMEI_DUMP_NFC_HDR(\"connect request\", &cmd->hdr);\n\tr = mei_cldev_send(phy->cldev, (u8 *)cmd, connect_length);\n\tif (r < 0) {\n\t\tpr_err(\"Could not send connect cmd %d\\n\", r);\n\t\tgoto err;\n\t}\n\n\tbytes_recv = mei_cldev_recv(phy->cldev, (u8 *)reply,\n\t\t\t\t    connect_resp_length);\n\tif (bytes_recv < 0) {\n\t\tr = bytes_recv;\n\t\tpr_err(\"Could not read connect response %d\\n\", r);\n\t\tgoto err;\n\t}\n\n\tMEI_DUMP_NFC_HDR(\"connect reply\", &reply->hdr);\n\n\tpr_info(\"IVN 0x%x Vendor ID 0x%x\\n\",\n\t\t connect_resp->fw_ivn, connect_resp->vendor_id);\n\n\tpr_info(\"ME FW %d.%d.%d.%d\\n\",\n\t\tconnect_resp->me_major, connect_resp->me_minor,\n\t\tconnect_resp->me_hotfix, connect_resp->me_build);\n\n\tr = 0;\n\nerr:\n\tkfree(reply);\n\tkfree(cmd);\n\n\treturn r;\n}\n\nstatic int mei_nfc_send(struct nfc_mei_phy *phy, const u8 *buf, size_t length)\n{\n\tstruct mei_nfc_hdr *hdr;\n\tu8 *mei_buf;\n\tint err;\n\n\terr = -ENOMEM;\n\tmei_buf = kzalloc(length + MEI_NFC_HEADER_SIZE, GFP_KERNEL);\n\tif (!mei_buf)\n\t\tgoto out;\n\n\thdr = (struct mei_nfc_hdr *)mei_buf;\n\thdr->cmd = MEI_NFC_CMD_HCI_SEND;\n\thdr->status = 0;\n\thdr->req_id = phy->req_id;\n\thdr->reserved = 0;\n\thdr->data_size = length;\n\n\tMEI_DUMP_NFC_HDR(\"send\", hdr);\n\n\tmemcpy(mei_buf + MEI_NFC_HEADER_SIZE, buf, length);\n\terr = mei_cldev_send(phy->cldev, mei_buf, length + MEI_NFC_HEADER_SIZE);\n\tif (err < 0)\n\t\tgoto out;\n\n\tif (!wait_event_interruptible_timeout(phy->send_wq,\n\t\t\t\tphy->recv_req_id == phy->req_id, HZ)) {\n\t\tpr_err(\"NFC MEI command timeout\\n\");\n\t\terr = -ETIME;\n\t} else {\n\t\tphy->req_id++;\n\t}\nout:\n\tkfree(mei_buf);\n\treturn err;\n}\n\n \nstatic int nfc_mei_phy_write(void *phy_id, struct sk_buff *skb)\n{\n\tstruct nfc_mei_phy *phy = phy_id;\n\tint r;\n\n\tMEI_DUMP_SKB_OUT(\"mei frame sent\", skb);\n\n\tr = mei_nfc_send(phy, skb->data, skb->len);\n\tif (r > 0)\n\t\tr = 0;\n\n\treturn r;\n}\n\nstatic int mei_nfc_recv(struct nfc_mei_phy *phy, u8 *buf, size_t length)\n{\n\tstruct mei_nfc_hdr *hdr;\n\tint received_length;\n\n\treceived_length = mei_cldev_recv(phy->cldev, buf, length);\n\tif (received_length < 0)\n\t\treturn received_length;\n\n\thdr = (struct mei_nfc_hdr *) buf;\n\n\tMEI_DUMP_NFC_HDR(\"receive\", hdr);\n\tif (hdr->cmd == MEI_NFC_CMD_HCI_SEND) {\n\t\tphy->recv_req_id = hdr->req_id;\n\t\twake_up(&phy->send_wq);\n\n\t\treturn 0;\n\t}\n\n\treturn received_length;\n}\n\n\nstatic void nfc_mei_rx_cb(struct mei_cl_device *cldev)\n{\n\tstruct nfc_mei_phy *phy = mei_cldev_get_drvdata(cldev);\n\tstruct sk_buff *skb;\n\tint reply_size;\n\n\tif (!phy)\n\t\treturn;\n\n\tif (phy->hard_fault != 0)\n\t\treturn;\n\n\tskb = alloc_skb(MEI_NFC_MAX_READ, GFP_KERNEL);\n\tif (!skb)\n\t\treturn;\n\n\treply_size = mei_nfc_recv(phy, skb->data, MEI_NFC_MAX_READ);\n\tif (reply_size < MEI_NFC_HEADER_SIZE) {\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\tskb_put(skb, reply_size);\n\tskb_pull(skb, MEI_NFC_HEADER_SIZE);\n\n\tMEI_DUMP_SKB_IN(\"mei frame read\", skb);\n\n\tnfc_hci_recv_frame(phy->hdev, skb);\n}\n\nstatic int nfc_mei_phy_enable(void *phy_id)\n{\n\tint r;\n\tstruct nfc_mei_phy *phy = phy_id;\n\n\tif (phy->powered == 1)\n\t\treturn 0;\n\n\tr = mei_cldev_enable(phy->cldev);\n\tif (r < 0) {\n\t\tpr_err(\"Could not enable device %d\\n\", r);\n\t\treturn r;\n\t}\n\n\tr = mei_nfc_if_version(phy);\n\tif (r < 0) {\n\t\tpr_err(\"Could not enable device %d\\n\", r);\n\t\tgoto err;\n\t}\n\n\tr = mei_nfc_connect(phy);\n\tif (r < 0) {\n\t\tpr_err(\"Could not connect to device %d\\n\", r);\n\t\tgoto err;\n\t}\n\n\tr = mei_cldev_register_rx_cb(phy->cldev, nfc_mei_rx_cb);\n\tif (r) {\n\t\tpr_err(\"Event cb registration failed %d\\n\", r);\n\t\tgoto err;\n\t}\n\n\tphy->powered = 1;\n\n\treturn 0;\n\nerr:\n\tphy->powered = 0;\n\tmei_cldev_disable(phy->cldev);\n\treturn r;\n}\n\nstatic void nfc_mei_phy_disable(void *phy_id)\n{\n\tstruct nfc_mei_phy *phy = phy_id;\n\n\tmei_cldev_disable(phy->cldev);\n\n\tphy->powered = 0;\n}\n\nconst struct nfc_phy_ops mei_phy_ops = {\n\t.write = nfc_mei_phy_write,\n\t.enable = nfc_mei_phy_enable,\n\t.disable = nfc_mei_phy_disable,\n};\nEXPORT_SYMBOL_GPL(mei_phy_ops);\n\nstruct nfc_mei_phy *nfc_mei_phy_alloc(struct mei_cl_device *cldev)\n{\n\tstruct nfc_mei_phy *phy;\n\n\tphy = kzalloc(sizeof(struct nfc_mei_phy), GFP_KERNEL);\n\tif (!phy)\n\t\treturn NULL;\n\n\tphy->cldev = cldev;\n\tinit_waitqueue_head(&phy->send_wq);\n\tmei_cldev_set_drvdata(cldev, phy);\n\n\treturn phy;\n}\nEXPORT_SYMBOL_GPL(nfc_mei_phy_alloc);\n\nvoid nfc_mei_phy_free(struct nfc_mei_phy *phy)\n{\n\tmei_cldev_disable(phy->cldev);\n\tkfree(phy);\n}\nEXPORT_SYMBOL_GPL(nfc_mei_phy_free);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"mei bus NFC device interface\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}