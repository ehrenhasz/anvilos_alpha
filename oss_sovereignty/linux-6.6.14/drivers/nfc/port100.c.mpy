{
  "module_name": "port100.c",
  "hash_id": "b49aab2773c69e74c2a865985a9f0386f1a57619d32eb55855a882ea04c1f02e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nfc/port100.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/usb.h>\n#include <net/nfc/digital.h>\n\n#define VERSION \"0.1\"\n\n#define SONY_VENDOR_ID\t\t0x054c\n#define RCS380S_PRODUCT_ID\t0x06c1\n#define RCS380P_PRODUCT_ID\t0x06c3\n\n#define PORT100_PROTOCOLS (NFC_PROTO_JEWEL_MASK    | \\\n\t\t\t   NFC_PROTO_MIFARE_MASK   | \\\n\t\t\t   NFC_PROTO_FELICA_MASK   | \\\n\t\t\t   NFC_PROTO_NFC_DEP_MASK  | \\\n\t\t\t   NFC_PROTO_ISO14443_MASK | \\\n\t\t\t   NFC_PROTO_ISO14443_B_MASK)\n\n#define PORT100_CAPABILITIES (NFC_DIGITAL_DRV_CAPS_IN_CRC | \\\n\t\t\t      NFC_DIGITAL_DRV_CAPS_TG_CRC)\n\n \n#define PORT100_FRAME_HEADER_LEN (sizeof(struct port100_frame) \\\n\t\t\t\t  + 2)  \n#define PORT100_FRAME_TAIL_LEN 2  \n\n#define PORT100_COMM_RF_HEAD_MAX_LEN (sizeof(struct port100_tg_comm_rf_cmd))\n\n \n#define PORT100_FRAME_MAX_PAYLOAD_LEN 1001\n\n#define PORT100_FRAME_ACK_SIZE 6  \nstatic u8 ack_frame[PORT100_FRAME_ACK_SIZE] = {\n\t0x00, 0x00, 0xff, 0x00, 0xff, 0x00\n};\n\n#define PORT100_FRAME_CHECKSUM(f) (f->data[le16_to_cpu(f->datalen)])\n#define PORT100_FRAME_POSTAMBLE(f) (f->data[le16_to_cpu(f->datalen) + 1])\n\n \n#define PORT100_FRAME_SOF\t0x00FF\n#define PORT100_FRAME_EXT\t0xFFFF\n#define PORT100_FRAME_ACK\t0x00FF\n\n \n#define PORT100_FRAME_DIRECTION(f) (f->data[0])  \n#define PORT100_FRAME_DIR_OUT 0xD6\n#define PORT100_FRAME_DIR_IN  0xD7\n\n \n#define PORT100_FRAME_CMD(f) (f->data[1])  \n\n#define PORT100_CMD_GET_FIRMWARE_VERSION 0x20\n#define PORT100_CMD_GET_COMMAND_TYPE     0x28\n#define PORT100_CMD_SET_COMMAND_TYPE     0x2A\n\n#define PORT100_CMD_IN_SET_RF       0x00\n#define PORT100_CMD_IN_SET_PROTOCOL 0x02\n#define PORT100_CMD_IN_COMM_RF      0x04\n\n#define PORT100_CMD_TG_SET_RF       0x40\n#define PORT100_CMD_TG_SET_PROTOCOL 0x42\n#define PORT100_CMD_TG_SET_RF_OFF   0x46\n#define PORT100_CMD_TG_COMM_RF      0x48\n\n#define PORT100_CMD_SWITCH_RF       0x06\n\n#define PORT100_CMD_RESPONSE(cmd) (cmd + 1)\n\n#define PORT100_CMD_TYPE_IS_SUPPORTED(mask, cmd_type) \\\n\t((mask) & (0x01 << (cmd_type)))\n#define PORT100_CMD_TYPE_0\t0\n#define PORT100_CMD_TYPE_1\t1\n\n#define PORT100_CMD_STATUS_OK      0x00\n#define PORT100_CMD_STATUS_TIMEOUT 0x80\n\n#define PORT100_MDAA_TGT_HAS_BEEN_ACTIVATED_MASK 0x01\n#define PORT100_MDAA_TGT_WAS_ACTIVATED_MASK      0x02\n\nstruct port100;\n\ntypedef void (*port100_send_async_complete_t)(struct port100 *dev, void *arg,\n\t\t\t\t\t      struct sk_buff *resp);\n\n \nstruct port100_in_rf_setting {\n\tu8 in_send_set_number;\n\tu8 in_send_comm_type;\n\tu8 in_recv_set_number;\n\tu8 in_recv_comm_type;\n} __packed;\n\n#define PORT100_COMM_TYPE_IN_212F 0x01\n#define PORT100_COMM_TYPE_IN_424F 0x02\n#define PORT100_COMM_TYPE_IN_106A 0x03\n#define PORT100_COMM_TYPE_IN_106B 0x07\n\nstatic const struct port100_in_rf_setting in_rf_settings[] = {\n\t[NFC_DIGITAL_RF_TECH_212F] = {\n\t\t.in_send_set_number = 1,\n\t\t.in_send_comm_type  = PORT100_COMM_TYPE_IN_212F,\n\t\t.in_recv_set_number = 15,\n\t\t.in_recv_comm_type  = PORT100_COMM_TYPE_IN_212F,\n\t},\n\t[NFC_DIGITAL_RF_TECH_424F] = {\n\t\t.in_send_set_number = 1,\n\t\t.in_send_comm_type  = PORT100_COMM_TYPE_IN_424F,\n\t\t.in_recv_set_number = 15,\n\t\t.in_recv_comm_type  = PORT100_COMM_TYPE_IN_424F,\n\t},\n\t[NFC_DIGITAL_RF_TECH_106A] = {\n\t\t.in_send_set_number = 2,\n\t\t.in_send_comm_type  = PORT100_COMM_TYPE_IN_106A,\n\t\t.in_recv_set_number = 15,\n\t\t.in_recv_comm_type  = PORT100_COMM_TYPE_IN_106A,\n\t},\n\t[NFC_DIGITAL_RF_TECH_106B] = {\n\t\t.in_send_set_number = 3,\n\t\t.in_send_comm_type  = PORT100_COMM_TYPE_IN_106B,\n\t\t.in_recv_set_number = 15,\n\t\t.in_recv_comm_type  = PORT100_COMM_TYPE_IN_106B,\n\t},\n\t \n\t[NFC_DIGITAL_RF_TECH_LAST] = { 0 },\n};\n\n \nstruct port100_tg_rf_setting {\n\tu8 tg_set_number;\n\tu8 tg_comm_type;\n} __packed;\n\n#define PORT100_COMM_TYPE_TG_106A 0x0B\n#define PORT100_COMM_TYPE_TG_212F 0x0C\n#define PORT100_COMM_TYPE_TG_424F 0x0D\n\nstatic const struct port100_tg_rf_setting tg_rf_settings[] = {\n\t[NFC_DIGITAL_RF_TECH_106A] = {\n\t\t.tg_set_number = 8,\n\t\t.tg_comm_type = PORT100_COMM_TYPE_TG_106A,\n\t},\n\t[NFC_DIGITAL_RF_TECH_212F] = {\n\t\t.tg_set_number = 8,\n\t\t.tg_comm_type = PORT100_COMM_TYPE_TG_212F,\n\t},\n\t[NFC_DIGITAL_RF_TECH_424F] = {\n\t\t.tg_set_number = 8,\n\t\t.tg_comm_type = PORT100_COMM_TYPE_TG_424F,\n\t},\n\t \n\t[NFC_DIGITAL_RF_TECH_LAST] = { 0 },\n\n};\n\n#define PORT100_IN_PROT_INITIAL_GUARD_TIME      0x00\n#define PORT100_IN_PROT_ADD_CRC                 0x01\n#define PORT100_IN_PROT_CHECK_CRC               0x02\n#define PORT100_IN_PROT_MULTI_CARD              0x03\n#define PORT100_IN_PROT_ADD_PARITY              0x04\n#define PORT100_IN_PROT_CHECK_PARITY            0x05\n#define PORT100_IN_PROT_BITWISE_AC_RECV_MODE    0x06\n#define PORT100_IN_PROT_VALID_BIT_NUMBER        0x07\n#define PORT100_IN_PROT_CRYPTO1                 0x08\n#define PORT100_IN_PROT_ADD_SOF                 0x09\n#define PORT100_IN_PROT_CHECK_SOF               0x0A\n#define PORT100_IN_PROT_ADD_EOF                 0x0B\n#define PORT100_IN_PROT_CHECK_EOF               0x0C\n#define PORT100_IN_PROT_DEAF_TIME               0x0E\n#define PORT100_IN_PROT_CRM                     0x0F\n#define PORT100_IN_PROT_CRM_MIN_LEN             0x10\n#define PORT100_IN_PROT_T1_TAG_FRAME            0x11\n#define PORT100_IN_PROT_RFCA                    0x12\n#define PORT100_IN_PROT_GUARD_TIME_AT_INITIATOR 0x13\n#define PORT100_IN_PROT_END                     0x14\n\n#define PORT100_IN_MAX_NUM_PROTOCOLS            19\n\n#define PORT100_TG_PROT_TU           0x00\n#define PORT100_TG_PROT_RF_OFF       0x01\n#define PORT100_TG_PROT_CRM          0x02\n#define PORT100_TG_PROT_END          0x03\n\n#define PORT100_TG_MAX_NUM_PROTOCOLS 3\n\nstruct port100_protocol {\n\tu8 number;\n\tu8 value;\n} __packed;\n\nstatic const struct port100_protocol\nin_protocols[][PORT100_IN_MAX_NUM_PROTOCOLS + 1] = {\n\t[NFC_DIGITAL_FRAMING_NFCA_SHORT] = {\n\t\t{ PORT100_IN_PROT_INITIAL_GUARD_TIME,      6 },\n\t\t{ PORT100_IN_PROT_ADD_CRC,                 0 },\n\t\t{ PORT100_IN_PROT_CHECK_CRC,               0 },\n\t\t{ PORT100_IN_PROT_MULTI_CARD,              0 },\n\t\t{ PORT100_IN_PROT_ADD_PARITY,              0 },\n\t\t{ PORT100_IN_PROT_CHECK_PARITY,            1 },\n\t\t{ PORT100_IN_PROT_BITWISE_AC_RECV_MODE,    0 },\n\t\t{ PORT100_IN_PROT_VALID_BIT_NUMBER,        7 },\n\t\t{ PORT100_IN_PROT_CRYPTO1,                 0 },\n\t\t{ PORT100_IN_PROT_ADD_SOF,                 0 },\n\t\t{ PORT100_IN_PROT_CHECK_SOF,               0 },\n\t\t{ PORT100_IN_PROT_ADD_EOF,                 0 },\n\t\t{ PORT100_IN_PROT_CHECK_EOF,               0 },\n\t\t{ PORT100_IN_PROT_DEAF_TIME,               4 },\n\t\t{ PORT100_IN_PROT_CRM,                     0 },\n\t\t{ PORT100_IN_PROT_CRM_MIN_LEN,             0 },\n\t\t{ PORT100_IN_PROT_T1_TAG_FRAME,            0 },\n\t\t{ PORT100_IN_PROT_RFCA,                    0 },\n\t\t{ PORT100_IN_PROT_GUARD_TIME_AT_INITIATOR, 6 },\n\t\t{ PORT100_IN_PROT_END,                     0 },\n\t},\n\t[NFC_DIGITAL_FRAMING_NFCA_STANDARD] = {\n\t\t{ PORT100_IN_PROT_INITIAL_GUARD_TIME,      6 },\n\t\t{ PORT100_IN_PROT_ADD_CRC,                 0 },\n\t\t{ PORT100_IN_PROT_CHECK_CRC,               0 },\n\t\t{ PORT100_IN_PROT_MULTI_CARD,              0 },\n\t\t{ PORT100_IN_PROT_ADD_PARITY,              1 },\n\t\t{ PORT100_IN_PROT_CHECK_PARITY,            1 },\n\t\t{ PORT100_IN_PROT_BITWISE_AC_RECV_MODE,    0 },\n\t\t{ PORT100_IN_PROT_VALID_BIT_NUMBER,        8 },\n\t\t{ PORT100_IN_PROT_CRYPTO1,                 0 },\n\t\t{ PORT100_IN_PROT_ADD_SOF,                 0 },\n\t\t{ PORT100_IN_PROT_CHECK_SOF,               0 },\n\t\t{ PORT100_IN_PROT_ADD_EOF,                 0 },\n\t\t{ PORT100_IN_PROT_CHECK_EOF,               0 },\n\t\t{ PORT100_IN_PROT_DEAF_TIME,               4 },\n\t\t{ PORT100_IN_PROT_CRM,                     0 },\n\t\t{ PORT100_IN_PROT_CRM_MIN_LEN,             0 },\n\t\t{ PORT100_IN_PROT_T1_TAG_FRAME,            0 },\n\t\t{ PORT100_IN_PROT_RFCA,                    0 },\n\t\t{ PORT100_IN_PROT_GUARD_TIME_AT_INITIATOR, 6 },\n\t\t{ PORT100_IN_PROT_END,                     0 },\n\t},\n\t[NFC_DIGITAL_FRAMING_NFCA_STANDARD_WITH_CRC_A] = {\n\t\t{ PORT100_IN_PROT_INITIAL_GUARD_TIME,      6 },\n\t\t{ PORT100_IN_PROT_ADD_CRC,                 1 },\n\t\t{ PORT100_IN_PROT_CHECK_CRC,               1 },\n\t\t{ PORT100_IN_PROT_MULTI_CARD,              0 },\n\t\t{ PORT100_IN_PROT_ADD_PARITY,              1 },\n\t\t{ PORT100_IN_PROT_CHECK_PARITY,            1 },\n\t\t{ PORT100_IN_PROT_BITWISE_AC_RECV_MODE,    0 },\n\t\t{ PORT100_IN_PROT_VALID_BIT_NUMBER,        8 },\n\t\t{ PORT100_IN_PROT_CRYPTO1,                 0 },\n\t\t{ PORT100_IN_PROT_ADD_SOF,                 0 },\n\t\t{ PORT100_IN_PROT_CHECK_SOF,               0 },\n\t\t{ PORT100_IN_PROT_ADD_EOF,                 0 },\n\t\t{ PORT100_IN_PROT_CHECK_EOF,               0 },\n\t\t{ PORT100_IN_PROT_DEAF_TIME,               4 },\n\t\t{ PORT100_IN_PROT_CRM,                     0 },\n\t\t{ PORT100_IN_PROT_CRM_MIN_LEN,             0 },\n\t\t{ PORT100_IN_PROT_T1_TAG_FRAME,            0 },\n\t\t{ PORT100_IN_PROT_RFCA,                    0 },\n\t\t{ PORT100_IN_PROT_GUARD_TIME_AT_INITIATOR, 6 },\n\t\t{ PORT100_IN_PROT_END,                     0 },\n\t},\n\t[NFC_DIGITAL_FRAMING_NFCA_T1T] = {\n\t\t \n\t\t{ PORT100_IN_PROT_ADD_CRC,          2 },\n\t\t{ PORT100_IN_PROT_CHECK_CRC,        2 },\n\t\t{ PORT100_IN_PROT_VALID_BIT_NUMBER, 8 },\n\t\t{ PORT100_IN_PROT_T1_TAG_FRAME,     2 },\n\t\t{ PORT100_IN_PROT_END,              0 },\n\t},\n\t[NFC_DIGITAL_FRAMING_NFCA_T2T] = {\n\t\t \n\t\t{ PORT100_IN_PROT_ADD_CRC,   1 },\n\t\t{ PORT100_IN_PROT_CHECK_CRC, 0 },\n\t\t{ PORT100_IN_PROT_END,       0 },\n\t},\n\t[NFC_DIGITAL_FRAMING_NFCA_T4T] = {\n\t\t \n\t\t{ PORT100_IN_PROT_END,       0 },\n\t},\n\t[NFC_DIGITAL_FRAMING_NFCA_NFC_DEP] = {\n\t\t \n\t\t{ PORT100_IN_PROT_END, 0 },\n\t},\n\t[NFC_DIGITAL_FRAMING_NFCF] = {\n\t\t{ PORT100_IN_PROT_INITIAL_GUARD_TIME,     18 },\n\t\t{ PORT100_IN_PROT_ADD_CRC,                 1 },\n\t\t{ PORT100_IN_PROT_CHECK_CRC,               1 },\n\t\t{ PORT100_IN_PROT_MULTI_CARD,              0 },\n\t\t{ PORT100_IN_PROT_ADD_PARITY,              0 },\n\t\t{ PORT100_IN_PROT_CHECK_PARITY,            0 },\n\t\t{ PORT100_IN_PROT_BITWISE_AC_RECV_MODE,    0 },\n\t\t{ PORT100_IN_PROT_VALID_BIT_NUMBER,        8 },\n\t\t{ PORT100_IN_PROT_CRYPTO1,                 0 },\n\t\t{ PORT100_IN_PROT_ADD_SOF,                 0 },\n\t\t{ PORT100_IN_PROT_CHECK_SOF,               0 },\n\t\t{ PORT100_IN_PROT_ADD_EOF,                 0 },\n\t\t{ PORT100_IN_PROT_CHECK_EOF,               0 },\n\t\t{ PORT100_IN_PROT_DEAF_TIME,               4 },\n\t\t{ PORT100_IN_PROT_CRM,                     0 },\n\t\t{ PORT100_IN_PROT_CRM_MIN_LEN,             0 },\n\t\t{ PORT100_IN_PROT_T1_TAG_FRAME,            0 },\n\t\t{ PORT100_IN_PROT_RFCA,                    0 },\n\t\t{ PORT100_IN_PROT_GUARD_TIME_AT_INITIATOR, 6 },\n\t\t{ PORT100_IN_PROT_END,                     0 },\n\t},\n\t[NFC_DIGITAL_FRAMING_NFCF_T3T] = {\n\t\t \n\t\t{ PORT100_IN_PROT_END, 0 },\n\t},\n\t[NFC_DIGITAL_FRAMING_NFCF_NFC_DEP] = {\n\t\t \n\t\t{ PORT100_IN_PROT_INITIAL_GUARD_TIME,     18 },\n\t\t{ PORT100_IN_PROT_ADD_CRC,                 1 },\n\t\t{ PORT100_IN_PROT_CHECK_CRC,               1 },\n\t\t{ PORT100_IN_PROT_MULTI_CARD,              0 },\n\t\t{ PORT100_IN_PROT_ADD_PARITY,              0 },\n\t\t{ PORT100_IN_PROT_CHECK_PARITY,            0 },\n\t\t{ PORT100_IN_PROT_BITWISE_AC_RECV_MODE,    0 },\n\t\t{ PORT100_IN_PROT_VALID_BIT_NUMBER,        8 },\n\t\t{ PORT100_IN_PROT_CRYPTO1,                 0 },\n\t\t{ PORT100_IN_PROT_ADD_SOF,                 0 },\n\t\t{ PORT100_IN_PROT_CHECK_SOF,               0 },\n\t\t{ PORT100_IN_PROT_ADD_EOF,                 0 },\n\t\t{ PORT100_IN_PROT_CHECK_EOF,               0 },\n\t\t{ PORT100_IN_PROT_DEAF_TIME,               4 },\n\t\t{ PORT100_IN_PROT_CRM,                     0 },\n\t\t{ PORT100_IN_PROT_CRM_MIN_LEN,             0 },\n\t\t{ PORT100_IN_PROT_T1_TAG_FRAME,            0 },\n\t\t{ PORT100_IN_PROT_RFCA,                    0 },\n\t\t{ PORT100_IN_PROT_GUARD_TIME_AT_INITIATOR, 6 },\n\t\t{ PORT100_IN_PROT_END,                     0 },\n\t},\n\t[NFC_DIGITAL_FRAMING_NFC_DEP_ACTIVATED] = {\n\t\t{ PORT100_IN_PROT_END, 0 },\n\t},\n\t[NFC_DIGITAL_FRAMING_NFCB] = {\n\t\t{ PORT100_IN_PROT_INITIAL_GUARD_TIME,     20 },\n\t\t{ PORT100_IN_PROT_ADD_CRC,                 1 },\n\t\t{ PORT100_IN_PROT_CHECK_CRC,               1 },\n\t\t{ PORT100_IN_PROT_MULTI_CARD,              0 },\n\t\t{ PORT100_IN_PROT_ADD_PARITY,              0 },\n\t\t{ PORT100_IN_PROT_CHECK_PARITY,            0 },\n\t\t{ PORT100_IN_PROT_BITWISE_AC_RECV_MODE,    0 },\n\t\t{ PORT100_IN_PROT_VALID_BIT_NUMBER,        8 },\n\t\t{ PORT100_IN_PROT_CRYPTO1,                 0 },\n\t\t{ PORT100_IN_PROT_ADD_SOF,                 1 },\n\t\t{ PORT100_IN_PROT_CHECK_SOF,               1 },\n\t\t{ PORT100_IN_PROT_ADD_EOF,                 1 },\n\t\t{ PORT100_IN_PROT_CHECK_EOF,               1 },\n\t\t{ PORT100_IN_PROT_DEAF_TIME,               4 },\n\t\t{ PORT100_IN_PROT_CRM,                     0 },\n\t\t{ PORT100_IN_PROT_CRM_MIN_LEN,             0 },\n\t\t{ PORT100_IN_PROT_T1_TAG_FRAME,            0 },\n\t\t{ PORT100_IN_PROT_RFCA,                    0 },\n\t\t{ PORT100_IN_PROT_GUARD_TIME_AT_INITIATOR, 6 },\n\t\t{ PORT100_IN_PROT_END,                     0 },\n\t},\n\t[NFC_DIGITAL_FRAMING_NFCB_T4T] = {\n\t\t \n\t\t{ PORT100_IN_PROT_END,                     0 },\n\t},\n\t \n\t[NFC_DIGITAL_FRAMING_LAST] = {\n\t\t{ PORT100_IN_PROT_END, 0 },\n\t},\n};\n\nstatic const struct port100_protocol\ntg_protocols[][PORT100_TG_MAX_NUM_PROTOCOLS + 1] = {\n\t[NFC_DIGITAL_FRAMING_NFCA_SHORT] = {\n\t\t{ PORT100_TG_PROT_END, 0 },\n\t},\n\t[NFC_DIGITAL_FRAMING_NFCA_STANDARD] = {\n\t\t{ PORT100_TG_PROT_END, 0 },\n\t},\n\t[NFC_DIGITAL_FRAMING_NFCA_STANDARD_WITH_CRC_A] = {\n\t\t{ PORT100_TG_PROT_END, 0 },\n\t},\n\t[NFC_DIGITAL_FRAMING_NFCA_T1T] = {\n\t\t{ PORT100_TG_PROT_END, 0 },\n\t},\n\t[NFC_DIGITAL_FRAMING_NFCA_T2T] = {\n\t\t{ PORT100_TG_PROT_END, 0 },\n\t},\n\t[NFC_DIGITAL_FRAMING_NFCA_NFC_DEP] = {\n\t\t{ PORT100_TG_PROT_TU,     1 },\n\t\t{ PORT100_TG_PROT_RF_OFF, 0 },\n\t\t{ PORT100_TG_PROT_CRM,    7 },\n\t\t{ PORT100_TG_PROT_END,    0 },\n\t},\n\t[NFC_DIGITAL_FRAMING_NFCF] = {\n\t\t{ PORT100_TG_PROT_END, 0 },\n\t},\n\t[NFC_DIGITAL_FRAMING_NFCF_T3T] = {\n\t\t{ PORT100_TG_PROT_END, 0 },\n\t},\n\t[NFC_DIGITAL_FRAMING_NFCF_NFC_DEP] = {\n\t\t{ PORT100_TG_PROT_TU,     1 },\n\t\t{ PORT100_TG_PROT_RF_OFF, 0 },\n\t\t{ PORT100_TG_PROT_CRM,    7 },\n\t\t{ PORT100_TG_PROT_END,    0 },\n\t},\n\t[NFC_DIGITAL_FRAMING_NFC_DEP_ACTIVATED] = {\n\t\t{ PORT100_TG_PROT_RF_OFF, 1 },\n\t\t{ PORT100_TG_PROT_END,    0 },\n\t},\n\t \n\t[NFC_DIGITAL_FRAMING_LAST] = {\n\t\t{ PORT100_TG_PROT_END,    0 },\n\t},\n};\n\nstruct port100 {\n\tstruct nfc_digital_dev *nfc_digital_dev;\n\n\tint skb_headroom;\n\tint skb_tailroom;\n\n\tstruct usb_device *udev;\n\tstruct usb_interface *interface;\n\n\tstruct urb *out_urb;\n\tstruct urb *in_urb;\n\n\t \n\tstruct mutex out_urb_lock;\n\n\tstruct work_struct cmd_complete_work;\n\n\tu8 cmd_type;\n\n\t \n\tstruct port100_cmd *cmd;\n\n\tbool cmd_cancel;\n\tstruct completion cmd_cancel_done;\n};\n\nstruct port100_cmd {\n\tu8 code;\n\tint status;\n\tstruct sk_buff *req;\n\tstruct sk_buff *resp;\n\tint resp_len;\n\tport100_send_async_complete_t  complete_cb;\n\tvoid *complete_cb_context;\n};\n\nstruct port100_frame {\n\tu8 preamble;\n\t__be16 start_frame;\n\t__be16 extended_frame;\n\t__le16 datalen;\n\tu8 datalen_checksum;\n\tu8 data[];\n} __packed;\n\nstruct port100_ack_frame {\n\tu8 preamble;\n\t__be16 start_frame;\n\t__be16 ack_frame;\n\tu8 postambule;\n} __packed;\n\nstruct port100_cb_arg {\n\tnfc_digital_cmd_complete_t complete_cb;\n\tvoid *complete_arg;\n\tu8 mdaa;\n};\n\nstruct port100_tg_comm_rf_cmd {\n\t__le16 guard_time;\n\t__le16 send_timeout;\n\tu8 mdaa;\n\tu8 nfca_param[6];\n\tu8 nfcf_param[18];\n\tu8 mf_halted;\n\tu8 arae_flag;\n\t__le16 recv_timeout;\n\tu8 data[];\n} __packed;\n\nstruct port100_tg_comm_rf_res {\n\tu8 comm_type;\n\tu8 ar_status;\n\tu8 target_activated;\n\t__le32 status;\n\tu8 data[];\n} __packed;\n\n \nstatic inline u8 port100_checksum(u16 value)\n{\n\treturn ~(((u8 *)&value)[0] + ((u8 *)&value)[1]) + 1;\n}\n\n \nstatic u8 port100_data_checksum(const u8 *data, int datalen)\n{\n\tu8 sum = 0;\n\tint i;\n\n\tfor (i = 0; i < datalen; i++)\n\t\tsum += data[i];\n\n\treturn port100_checksum(sum);\n}\n\nstatic void port100_tx_frame_init(void *_frame, u8 cmd_code)\n{\n\tstruct port100_frame *frame = _frame;\n\n\tframe->preamble = 0;\n\tframe->start_frame = cpu_to_be16(PORT100_FRAME_SOF);\n\tframe->extended_frame = cpu_to_be16(PORT100_FRAME_EXT);\n\tPORT100_FRAME_DIRECTION(frame) = PORT100_FRAME_DIR_OUT;\n\tPORT100_FRAME_CMD(frame) = cmd_code;\n\tframe->datalen = cpu_to_le16(2);\n}\n\nstatic void port100_tx_frame_finish(void *_frame)\n{\n\tstruct port100_frame *frame = _frame;\n\n\tframe->datalen_checksum = port100_checksum(le16_to_cpu(frame->datalen));\n\n\tPORT100_FRAME_CHECKSUM(frame) =\n\t\tport100_data_checksum(frame->data, le16_to_cpu(frame->datalen));\n\n\tPORT100_FRAME_POSTAMBLE(frame) = 0;\n}\n\nstatic void port100_tx_update_payload_len(void *_frame, int len)\n{\n\tstruct port100_frame *frame = _frame;\n\n\tle16_add_cpu(&frame->datalen, len);\n}\n\nstatic bool port100_rx_frame_is_valid(const void *_frame)\n{\n\tu8 checksum;\n\tconst struct port100_frame *frame = _frame;\n\n\tif (frame->start_frame != cpu_to_be16(PORT100_FRAME_SOF) ||\n\t    frame->extended_frame != cpu_to_be16(PORT100_FRAME_EXT))\n\t\treturn false;\n\n\tchecksum = port100_checksum(le16_to_cpu(frame->datalen));\n\tif (checksum != frame->datalen_checksum)\n\t\treturn false;\n\n\tchecksum = port100_data_checksum(frame->data,\n\t\t\t\t\t le16_to_cpu(frame->datalen));\n\tif (checksum != PORT100_FRAME_CHECKSUM(frame))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool port100_rx_frame_is_ack(const struct port100_ack_frame *frame)\n{\n\treturn (frame->start_frame == cpu_to_be16(PORT100_FRAME_SOF) &&\n\t\tframe->ack_frame == cpu_to_be16(PORT100_FRAME_ACK));\n}\n\nstatic inline int port100_rx_frame_size(const void *frame)\n{\n\tconst struct port100_frame *f = frame;\n\n\treturn sizeof(struct port100_frame) + le16_to_cpu(f->datalen) +\n\t       PORT100_FRAME_TAIL_LEN;\n}\n\nstatic bool port100_rx_frame_is_cmd_response(const struct port100 *dev,\n\t\t\t\t\t     const void *frame)\n{\n\tconst struct port100_frame *f = frame;\n\n\treturn (PORT100_FRAME_CMD(f) == PORT100_CMD_RESPONSE(dev->cmd->code));\n}\n\nstatic void port100_recv_response(struct urb *urb)\n{\n\tstruct port100 *dev = urb->context;\n\tstruct port100_cmd *cmd = dev->cmd;\n\tu8 *in_frame;\n\n\tcmd->status = urb->status;\n\n\tswitch (urb->status) {\n\tcase 0:\n\t\tbreak;  \n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\t\tnfc_dbg(&dev->interface->dev,\n\t\t\t\"The urb has been canceled (status %d)\\n\", urb->status);\n\t\tgoto sched_wq;\n\tcase -ESHUTDOWN:\n\tdefault:\n\t\tnfc_err(&dev->interface->dev, \"Urb failure (status %d)\\n\",\n\t\t\turb->status);\n\t\tgoto sched_wq;\n\t}\n\n\tin_frame = dev->in_urb->transfer_buffer;\n\n\tif (!port100_rx_frame_is_valid(in_frame)) {\n\t\tnfc_err(&dev->interface->dev, \"Received an invalid frame\\n\");\n\t\tcmd->status = -EIO;\n\t\tgoto sched_wq;\n\t}\n\n\tprint_hex_dump_debug(\"PORT100 RX: \", DUMP_PREFIX_NONE, 16, 1, in_frame,\n\t\t\t     port100_rx_frame_size(in_frame), false);\n\n\tif (!port100_rx_frame_is_cmd_response(dev, in_frame)) {\n\t\tnfc_err(&dev->interface->dev,\n\t\t\t\"It's not the response to the last command\\n\");\n\t\tcmd->status = -EIO;\n\t\tgoto sched_wq;\n\t}\n\nsched_wq:\n\tschedule_work(&dev->cmd_complete_work);\n}\n\nstatic int port100_submit_urb_for_response(const struct port100 *dev,\n\t\t\t\t\t   gfp_t flags)\n{\n\tdev->in_urb->complete = port100_recv_response;\n\n\treturn usb_submit_urb(dev->in_urb, flags);\n}\n\nstatic void port100_recv_ack(struct urb *urb)\n{\n\tstruct port100 *dev = urb->context;\n\tstruct port100_cmd *cmd = dev->cmd;\n\tconst struct port100_ack_frame *in_frame;\n\tint rc;\n\n\tcmd->status = urb->status;\n\n\tswitch (urb->status) {\n\tcase 0:\n\t\tbreak;  \n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\t\tnfc_dbg(&dev->interface->dev,\n\t\t\t\"The urb has been stopped (status %d)\\n\", urb->status);\n\t\tgoto sched_wq;\n\tcase -ESHUTDOWN:\n\tdefault:\n\t\tnfc_err(&dev->interface->dev, \"Urb failure (status %d)\\n\",\n\t\t\turb->status);\n\t\tgoto sched_wq;\n\t}\n\n\tin_frame = dev->in_urb->transfer_buffer;\n\n\tif (!port100_rx_frame_is_ack(in_frame)) {\n\t\tnfc_err(&dev->interface->dev, \"Received an invalid ack\\n\");\n\t\tcmd->status = -EIO;\n\t\tgoto sched_wq;\n\t}\n\n\trc = port100_submit_urb_for_response(dev, GFP_ATOMIC);\n\tif (rc) {\n\t\tnfc_err(&dev->interface->dev,\n\t\t\t\"usb_submit_urb failed with result %d\\n\", rc);\n\t\tcmd->status = rc;\n\t\tgoto sched_wq;\n\t}\n\n\treturn;\n\nsched_wq:\n\tschedule_work(&dev->cmd_complete_work);\n}\n\nstatic int port100_submit_urb_for_ack(const struct port100 *dev, gfp_t flags)\n{\n\tdev->in_urb->complete = port100_recv_ack;\n\n\treturn usb_submit_urb(dev->in_urb, flags);\n}\n\nstatic int port100_send_ack(struct port100 *dev)\n{\n\tint rc = 0;\n\n\tmutex_lock(&dev->out_urb_lock);\n\n\t \n\tif (!dev->cmd_cancel) {\n\t\treinit_completion(&dev->cmd_cancel_done);\n\n\t\tusb_kill_urb(dev->out_urb);\n\n\t\tdev->out_urb->transfer_buffer = ack_frame;\n\t\tdev->out_urb->transfer_buffer_length = sizeof(ack_frame);\n\t\trc = usb_submit_urb(dev->out_urb, GFP_KERNEL);\n\n\t\t \n\t\tdev->cmd_cancel = !rc;\n\t}\n\n\tmutex_unlock(&dev->out_urb_lock);\n\n\tif (!rc)\n\t\twait_for_completion(&dev->cmd_cancel_done);\n\n\treturn rc;\n}\n\nstatic int port100_send_frame_async(struct port100 *dev,\n\t\t\t\t    const struct sk_buff *out,\n\t\t\t\t    const struct sk_buff *in, int in_len)\n{\n\tint rc;\n\n\tmutex_lock(&dev->out_urb_lock);\n\n\t \n\tif (dev->cmd_cancel) {\n\t\trc = -EAGAIN;\n\t\tgoto exit;\n\t}\n\n\tdev->out_urb->transfer_buffer = out->data;\n\tdev->out_urb->transfer_buffer_length = out->len;\n\n\tdev->in_urb->transfer_buffer = in->data;\n\tdev->in_urb->transfer_buffer_length = in_len;\n\n\tprint_hex_dump_debug(\"PORT100 TX: \", DUMP_PREFIX_NONE, 16, 1,\n\t\t\t     out->data, out->len, false);\n\n\trc = usb_submit_urb(dev->out_urb, GFP_KERNEL);\n\tif (rc)\n\t\tgoto exit;\n\n\trc = port100_submit_urb_for_ack(dev, GFP_KERNEL);\n\tif (rc)\n\t\tusb_kill_urb(dev->out_urb);\n\nexit:\n\tmutex_unlock(&dev->out_urb_lock);\n\n\treturn rc;\n}\n\nstatic void port100_build_cmd_frame(struct port100 *dev, u8 cmd_code,\n\t\t\t\t    struct sk_buff *skb)\n{\n\t \n\tint payload_len = skb->len;\n\n\tskb_push(skb, PORT100_FRAME_HEADER_LEN);\n\tskb_put(skb, PORT100_FRAME_TAIL_LEN);\n\n\tport100_tx_frame_init(skb->data, cmd_code);\n\tport100_tx_update_payload_len(skb->data, payload_len);\n\tport100_tx_frame_finish(skb->data);\n}\n\nstatic void port100_send_async_complete(struct port100 *dev)\n{\n\tstruct port100_cmd *cmd = dev->cmd;\n\tint status = cmd->status;\n\n\tstruct sk_buff *req = cmd->req;\n\tstruct sk_buff *resp = cmd->resp;\n\n\tdev_kfree_skb(req);\n\n\tdev->cmd = NULL;\n\n\tif (status < 0) {\n\t\tcmd->complete_cb(dev, cmd->complete_cb_context,\n\t\t\t\t ERR_PTR(status));\n\t\tdev_kfree_skb(resp);\n\t\tgoto done;\n\t}\n\n\tskb_put(resp, port100_rx_frame_size(resp->data));\n\tskb_pull(resp, PORT100_FRAME_HEADER_LEN);\n\tskb_trim(resp, resp->len - PORT100_FRAME_TAIL_LEN);\n\n\tcmd->complete_cb(dev, cmd->complete_cb_context, resp);\n\ndone:\n\tkfree(cmd);\n}\n\nstatic int port100_send_cmd_async(struct port100 *dev, u8 cmd_code,\n\t\t\t\tstruct sk_buff *req,\n\t\t\t\tport100_send_async_complete_t complete_cb,\n\t\t\t\tvoid *complete_cb_context)\n{\n\tstruct port100_cmd *cmd;\n\tstruct sk_buff *resp;\n\tint rc;\n\tint  resp_len = PORT100_FRAME_HEADER_LEN +\n\t\t\tPORT100_FRAME_MAX_PAYLOAD_LEN +\n\t\t\tPORT100_FRAME_TAIL_LEN;\n\n\tif (dev->cmd) {\n\t\tnfc_err(&dev->interface->dev,\n\t\t\t\"A command is still in process\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tresp = alloc_skb(resp_len, GFP_KERNEL);\n\tif (!resp)\n\t\treturn -ENOMEM;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd) {\n\t\tdev_kfree_skb(resp);\n\t\treturn -ENOMEM;\n\t}\n\n\tcmd->code = cmd_code;\n\tcmd->req = req;\n\tcmd->resp = resp;\n\tcmd->resp_len = resp_len;\n\tcmd->complete_cb = complete_cb;\n\tcmd->complete_cb_context = complete_cb_context;\n\n\tport100_build_cmd_frame(dev, cmd_code, req);\n\n\tdev->cmd = cmd;\n\n\trc = port100_send_frame_async(dev, req, resp, resp_len);\n\tif (rc) {\n\t\tkfree(cmd);\n\t\tdev_kfree_skb(resp);\n\t\tdev->cmd = NULL;\n\t}\n\n\treturn rc;\n}\n\nstruct port100_sync_cmd_response {\n\tstruct sk_buff *resp;\n\tstruct completion done;\n};\n\nstatic void port100_wq_cmd_complete(struct work_struct *work)\n{\n\tstruct port100 *dev = container_of(work, struct port100,\n\t\t\t\t\t   cmd_complete_work);\n\n\tport100_send_async_complete(dev);\n}\n\nstatic void port100_send_sync_complete(struct port100 *dev, void *_arg,\n\t\t\t\t      struct sk_buff *resp)\n{\n\tstruct port100_sync_cmd_response *arg = _arg;\n\n\targ->resp = resp;\n\tcomplete(&arg->done);\n}\n\nstatic struct sk_buff *port100_send_cmd_sync(struct port100 *dev, u8 cmd_code,\n\t\t\t\t\t     struct sk_buff *req)\n{\n\tint rc;\n\tstruct port100_sync_cmd_response arg;\n\n\tinit_completion(&arg.done);\n\n\trc = port100_send_cmd_async(dev, cmd_code, req,\n\t\t\t\t    port100_send_sync_complete, &arg);\n\tif (rc) {\n\t\tdev_kfree_skb(req);\n\t\treturn ERR_PTR(rc);\n\t}\n\n\twait_for_completion(&arg.done);\n\n\treturn arg.resp;\n}\n\nstatic void port100_send_complete(struct urb *urb)\n{\n\tstruct port100 *dev = urb->context;\n\n\tif (dev->cmd_cancel) {\n\t\tcomplete_all(&dev->cmd_cancel_done);\n\t\tdev->cmd_cancel = false;\n\t}\n\n\tswitch (urb->status) {\n\tcase 0:\n\t\tbreak;  \n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\t\tnfc_dbg(&dev->interface->dev,\n\t\t\t\"The urb has been stopped (status %d)\\n\", urb->status);\n\t\tbreak;\n\tcase -ESHUTDOWN:\n\tdefault:\n\t\tnfc_err(&dev->interface->dev, \"Urb failure (status %d)\\n\",\n\t\t\turb->status);\n\t}\n}\n\nstatic void port100_abort_cmd(struct nfc_digital_dev *ddev)\n{\n\tstruct port100 *dev = nfc_digital_get_drvdata(ddev);\n\n\t \n\tport100_send_ack(dev);\n\n\t \n\tusb_kill_urb(dev->in_urb);\n}\n\nstatic struct sk_buff *port100_alloc_skb(const struct port100 *dev, unsigned int size)\n{\n\tstruct sk_buff *skb;\n\n\tskb = alloc_skb(dev->skb_headroom + dev->skb_tailroom + size,\n\t\t\tGFP_KERNEL);\n\tif (skb)\n\t\tskb_reserve(skb, dev->skb_headroom);\n\n\treturn skb;\n}\n\nstatic int port100_set_command_type(struct port100 *dev, u8 command_type)\n{\n\tstruct sk_buff *skb;\n\tstruct sk_buff *resp;\n\tint rc;\n\n\tskb = port100_alloc_skb(dev, 1);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_put_u8(skb, command_type);\n\n\tresp = port100_send_cmd_sync(dev, PORT100_CMD_SET_COMMAND_TYPE, skb);\n\tif (IS_ERR(resp))\n\t\treturn PTR_ERR(resp);\n\n\trc = resp->data[0];\n\n\tdev_kfree_skb(resp);\n\n\treturn rc;\n}\n\nstatic u64 port100_get_command_type_mask(struct port100 *dev)\n{\n\tstruct sk_buff *skb;\n\tstruct sk_buff *resp;\n\tu64 mask;\n\n\tskb = port100_alloc_skb(dev, 0);\n\tif (!skb)\n\t\treturn 0;\n\n\tresp = port100_send_cmd_sync(dev, PORT100_CMD_GET_COMMAND_TYPE, skb);\n\tif (IS_ERR(resp))\n\t\treturn 0;\n\n\tif (resp->len < 8)\n\t\tmask = 0;\n\telse\n\t\tmask = be64_to_cpu(*(__be64 *)resp->data);\n\n\tdev_kfree_skb(resp);\n\n\treturn mask;\n}\n\nstatic u16 port100_get_firmware_version(struct port100 *dev)\n{\n\tstruct sk_buff *skb;\n\tstruct sk_buff *resp;\n\tu16 fw_ver;\n\n\tskb = port100_alloc_skb(dev, 0);\n\tif (!skb)\n\t\treturn 0;\n\n\tresp = port100_send_cmd_sync(dev, PORT100_CMD_GET_FIRMWARE_VERSION,\n\t\t\t\t     skb);\n\tif (IS_ERR(resp))\n\t\treturn 0;\n\n\tfw_ver = le16_to_cpu(*(__le16 *)resp->data);\n\n\tdev_kfree_skb(resp);\n\n\treturn fw_ver;\n}\n\nstatic int port100_switch_rf(struct nfc_digital_dev *ddev, bool on)\n{\n\tstruct port100 *dev = nfc_digital_get_drvdata(ddev);\n\tstruct sk_buff *skb, *resp;\n\n\tskb = port100_alloc_skb(dev, 1);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_put_u8(skb, on ? 1 : 0);\n\n\t \n\tif (!on)\n\t\tport100_abort_cmd(ddev);\n\n\tresp = port100_send_cmd_sync(dev, PORT100_CMD_SWITCH_RF, skb);\n\n\tif (IS_ERR(resp))\n\t\treturn PTR_ERR(resp);\n\n\tdev_kfree_skb(resp);\n\n\treturn 0;\n}\n\nstatic int port100_in_set_rf(struct nfc_digital_dev *ddev, u8 rf)\n{\n\tstruct port100 *dev = nfc_digital_get_drvdata(ddev);\n\tstruct sk_buff *skb;\n\tstruct sk_buff *resp;\n\tint rc;\n\n\tif (rf >= NFC_DIGITAL_RF_TECH_LAST)\n\t\treturn -EINVAL;\n\n\tskb = port100_alloc_skb(dev, sizeof(struct port100_in_rf_setting));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_put_data(skb, &in_rf_settings[rf],\n\t\t     sizeof(struct port100_in_rf_setting));\n\n\tresp = port100_send_cmd_sync(dev, PORT100_CMD_IN_SET_RF, skb);\n\n\tif (IS_ERR(resp))\n\t\treturn PTR_ERR(resp);\n\n\trc = resp->data[0];\n\n\tdev_kfree_skb(resp);\n\n\treturn rc;\n}\n\nstatic int port100_in_set_framing(struct nfc_digital_dev *ddev, int param)\n{\n\tstruct port100 *dev = nfc_digital_get_drvdata(ddev);\n\tconst struct port100_protocol *protocols;\n\tstruct sk_buff *skb;\n\tstruct sk_buff *resp;\n\tint num_protocols;\n\tsize_t size;\n\tint rc;\n\n\tif (param >= NFC_DIGITAL_FRAMING_LAST)\n\t\treturn -EINVAL;\n\n\tprotocols = in_protocols[param];\n\n\tnum_protocols = 0;\n\twhile (protocols[num_protocols].number != PORT100_IN_PROT_END)\n\t\tnum_protocols++;\n\n\tif (!num_protocols)\n\t\treturn 0;\n\n\tsize = sizeof(struct port100_protocol) * num_protocols;\n\n\tskb = port100_alloc_skb(dev, size);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_put_data(skb, protocols, size);\n\n\tresp = port100_send_cmd_sync(dev, PORT100_CMD_IN_SET_PROTOCOL, skb);\n\n\tif (IS_ERR(resp))\n\t\treturn PTR_ERR(resp);\n\n\trc = resp->data[0];\n\n\tdev_kfree_skb(resp);\n\n\treturn rc;\n}\n\nstatic int port100_in_configure_hw(struct nfc_digital_dev *ddev, int type,\n\t\t\t\t   int param)\n{\n\tif (type == NFC_DIGITAL_CONFIG_RF_TECH)\n\t\treturn port100_in_set_rf(ddev, param);\n\n\tif (type == NFC_DIGITAL_CONFIG_FRAMING)\n\t\treturn port100_in_set_framing(ddev, param);\n\n\treturn -EINVAL;\n}\n\nstatic void port100_in_comm_rf_complete(struct port100 *dev, void *arg,\n\t\t\t\t       struct sk_buff *resp)\n{\n\tconst struct port100_cb_arg *cb_arg = arg;\n\tnfc_digital_cmd_complete_t cb = cb_arg->complete_cb;\n\tu32 status;\n\tint rc;\n\n\tif (IS_ERR(resp)) {\n\t\trc =  PTR_ERR(resp);\n\t\tgoto exit;\n\t}\n\n\tif (resp->len < 4) {\n\t\tnfc_err(&dev->interface->dev,\n\t\t\t\"Invalid packet length received\\n\");\n\t\trc = -EIO;\n\t\tgoto error;\n\t}\n\n\tstatus = le32_to_cpu(*(__le32 *)resp->data);\n\n\tskb_pull(resp, sizeof(u32));\n\n\tif (status == PORT100_CMD_STATUS_TIMEOUT) {\n\t\trc = -ETIMEDOUT;\n\t\tgoto error;\n\t}\n\n\tif (status != PORT100_CMD_STATUS_OK) {\n\t\tnfc_err(&dev->interface->dev,\n\t\t\t\"in_comm_rf failed with status 0x%08x\\n\", status);\n\t\trc = -EIO;\n\t\tgoto error;\n\t}\n\n\t \n\tskb_pull(resp, 1);\n\n\tgoto exit;\n\nerror:\n\tkfree_skb(resp);\n\tresp = ERR_PTR(rc);\n\nexit:\n\tcb(dev->nfc_digital_dev, cb_arg->complete_arg, resp);\n\n\tkfree(cb_arg);\n}\n\nstatic int port100_in_send_cmd(struct nfc_digital_dev *ddev,\n\t\t\t       struct sk_buff *skb, u16 _timeout,\n\t\t\t       nfc_digital_cmd_complete_t cb, void *arg)\n{\n\tstruct port100 *dev = nfc_digital_get_drvdata(ddev);\n\tstruct port100_cb_arg *cb_arg;\n\t__le16 timeout;\n\n\tcb_arg = kzalloc(sizeof(struct port100_cb_arg), GFP_KERNEL);\n\tif (!cb_arg)\n\t\treturn -ENOMEM;\n\n\tcb_arg->complete_cb = cb;\n\tcb_arg->complete_arg = arg;\n\n\ttimeout = cpu_to_le16(_timeout * 10);\n\n\tmemcpy(skb_push(skb, sizeof(__le16)), &timeout, sizeof(__le16));\n\n\treturn port100_send_cmd_async(dev, PORT100_CMD_IN_COMM_RF, skb,\n\t\t\t\t      port100_in_comm_rf_complete, cb_arg);\n}\n\nstatic int port100_tg_set_rf(struct nfc_digital_dev *ddev, u8 rf)\n{\n\tstruct port100 *dev = nfc_digital_get_drvdata(ddev);\n\tstruct sk_buff *skb;\n\tstruct sk_buff *resp;\n\tint rc;\n\n\tif (rf >= NFC_DIGITAL_RF_TECH_LAST)\n\t\treturn -EINVAL;\n\n\tskb = port100_alloc_skb(dev, sizeof(struct port100_tg_rf_setting));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_put_data(skb, &tg_rf_settings[rf],\n\t\t     sizeof(struct port100_tg_rf_setting));\n\n\tresp = port100_send_cmd_sync(dev, PORT100_CMD_TG_SET_RF, skb);\n\n\tif (IS_ERR(resp))\n\t\treturn PTR_ERR(resp);\n\n\trc = resp->data[0];\n\n\tdev_kfree_skb(resp);\n\n\treturn rc;\n}\n\nstatic int port100_tg_set_framing(struct nfc_digital_dev *ddev, int param)\n{\n\tstruct port100 *dev = nfc_digital_get_drvdata(ddev);\n\tconst struct port100_protocol *protocols;\n\tstruct sk_buff *skb;\n\tstruct sk_buff *resp;\n\tint rc;\n\tint num_protocols;\n\tsize_t size;\n\n\tif (param >= NFC_DIGITAL_FRAMING_LAST)\n\t\treturn -EINVAL;\n\n\tprotocols = tg_protocols[param];\n\n\tnum_protocols = 0;\n\twhile (protocols[num_protocols].number != PORT100_TG_PROT_END)\n\t\tnum_protocols++;\n\n\tif (!num_protocols)\n\t\treturn 0;\n\n\tsize = sizeof(struct port100_protocol) * num_protocols;\n\n\tskb = port100_alloc_skb(dev, size);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_put_data(skb, protocols, size);\n\n\tresp = port100_send_cmd_sync(dev, PORT100_CMD_TG_SET_PROTOCOL, skb);\n\n\tif (IS_ERR(resp))\n\t\treturn PTR_ERR(resp);\n\n\trc = resp->data[0];\n\n\tdev_kfree_skb(resp);\n\n\treturn rc;\n}\n\nstatic int port100_tg_configure_hw(struct nfc_digital_dev *ddev, int type,\n\t\t\t\t   int param)\n{\n\tif (type == NFC_DIGITAL_CONFIG_RF_TECH)\n\t\treturn port100_tg_set_rf(ddev, param);\n\n\tif (type == NFC_DIGITAL_CONFIG_FRAMING)\n\t\treturn port100_tg_set_framing(ddev, param);\n\n\treturn -EINVAL;\n}\n\nstatic bool port100_tg_target_activated(struct port100 *dev, u8 tgt_activated)\n{\n\tu8 mask;\n\n\tswitch (dev->cmd_type) {\n\tcase PORT100_CMD_TYPE_0:\n\t\tmask = PORT100_MDAA_TGT_HAS_BEEN_ACTIVATED_MASK;\n\t\tbreak;\n\tcase PORT100_CMD_TYPE_1:\n\t\tmask = PORT100_MDAA_TGT_HAS_BEEN_ACTIVATED_MASK |\n\t\t       PORT100_MDAA_TGT_WAS_ACTIVATED_MASK;\n\t\tbreak;\n\tdefault:\n\t\tnfc_err(&dev->interface->dev, \"Unknown command type\\n\");\n\t\treturn false;\n\t}\n\n\treturn ((tgt_activated & mask) == mask);\n}\n\nstatic void port100_tg_comm_rf_complete(struct port100 *dev, void *arg,\n\t\t\t\t\tstruct sk_buff *resp)\n{\n\tu32 status;\n\tconst struct port100_cb_arg *cb_arg = arg;\n\tnfc_digital_cmd_complete_t cb = cb_arg->complete_cb;\n\tstruct port100_tg_comm_rf_res *hdr;\n\n\tif (IS_ERR(resp))\n\t\tgoto exit;\n\n\thdr = (struct port100_tg_comm_rf_res *)resp->data;\n\n\tstatus = le32_to_cpu(hdr->status);\n\n\tif (cb_arg->mdaa &&\n\t    !port100_tg_target_activated(dev, hdr->target_activated)) {\n\t\tkfree_skb(resp);\n\t\tresp = ERR_PTR(-ETIMEDOUT);\n\n\t\tgoto exit;\n\t}\n\n\tskb_pull(resp, sizeof(struct port100_tg_comm_rf_res));\n\n\tif (status != PORT100_CMD_STATUS_OK) {\n\t\tkfree_skb(resp);\n\n\t\tif (status == PORT100_CMD_STATUS_TIMEOUT)\n\t\t\tresp = ERR_PTR(-ETIMEDOUT);\n\t\telse\n\t\t\tresp = ERR_PTR(-EIO);\n\t}\n\nexit:\n\tcb(dev->nfc_digital_dev, cb_arg->complete_arg, resp);\n\n\tkfree(cb_arg);\n}\n\nstatic int port100_tg_send_cmd(struct nfc_digital_dev *ddev,\n\t\t\t       struct sk_buff *skb, u16 timeout,\n\t\t\t       nfc_digital_cmd_complete_t cb, void *arg)\n{\n\tstruct port100 *dev = nfc_digital_get_drvdata(ddev);\n\tstruct port100_tg_comm_rf_cmd *hdr;\n\tstruct port100_cb_arg *cb_arg;\n\n\tcb_arg = kzalloc(sizeof(struct port100_cb_arg), GFP_KERNEL);\n\tif (!cb_arg)\n\t\treturn -ENOMEM;\n\n\tcb_arg->complete_cb = cb;\n\tcb_arg->complete_arg = arg;\n\n\tskb_push(skb, sizeof(struct port100_tg_comm_rf_cmd));\n\n\thdr = (struct port100_tg_comm_rf_cmd *)skb->data;\n\n\tmemset(hdr, 0, sizeof(struct port100_tg_comm_rf_cmd));\n\thdr->guard_time = cpu_to_le16(500);\n\thdr->send_timeout = cpu_to_le16(0xFFFF);\n\thdr->recv_timeout = cpu_to_le16(timeout);\n\n\treturn port100_send_cmd_async(dev, PORT100_CMD_TG_COMM_RF, skb,\n\t\t\t\t      port100_tg_comm_rf_complete, cb_arg);\n}\n\nstatic int port100_listen_mdaa(struct nfc_digital_dev *ddev,\n\t\t\t       struct digital_tg_mdaa_params *params,\n\t\t\t       u16 timeout,\n\t\t\t       nfc_digital_cmd_complete_t cb, void *arg)\n{\n\tstruct port100 *dev = nfc_digital_get_drvdata(ddev);\n\tstruct port100_tg_comm_rf_cmd *hdr;\n\tstruct port100_cb_arg *cb_arg;\n\tstruct sk_buff *skb;\n\tint rc;\n\n\trc = port100_tg_configure_hw(ddev, NFC_DIGITAL_CONFIG_RF_TECH,\n\t\t\t\t     NFC_DIGITAL_RF_TECH_106A);\n\tif (rc)\n\t\treturn rc;\n\n\trc = port100_tg_configure_hw(ddev, NFC_DIGITAL_CONFIG_FRAMING,\n\t\t\t\t     NFC_DIGITAL_FRAMING_NFCA_NFC_DEP);\n\tif (rc)\n\t\treturn rc;\n\n\tcb_arg = kzalloc(sizeof(struct port100_cb_arg), GFP_KERNEL);\n\tif (!cb_arg)\n\t\treturn -ENOMEM;\n\n\tcb_arg->complete_cb = cb;\n\tcb_arg->complete_arg = arg;\n\tcb_arg->mdaa = 1;\n\n\tskb = port100_alloc_skb(dev, 0);\n\tif (!skb) {\n\t\tkfree(cb_arg);\n\t\treturn -ENOMEM;\n\t}\n\n\tskb_push(skb, sizeof(struct port100_tg_comm_rf_cmd));\n\thdr = (struct port100_tg_comm_rf_cmd *)skb->data;\n\n\tmemset(hdr, 0, sizeof(struct port100_tg_comm_rf_cmd));\n\n\thdr->guard_time = 0;\n\thdr->send_timeout = cpu_to_le16(0xFFFF);\n\thdr->mdaa = 1;\n\thdr->nfca_param[0] = (params->sens_res >> 8) & 0xFF;\n\thdr->nfca_param[1] = params->sens_res & 0xFF;\n\tmemcpy(hdr->nfca_param + 2, params->nfcid1, 3);\n\thdr->nfca_param[5] = params->sel_res;\n\tmemcpy(hdr->nfcf_param, params->nfcid2, 8);\n\thdr->nfcf_param[16] = (params->sc >> 8) & 0xFF;\n\thdr->nfcf_param[17] = params->sc & 0xFF;\n\thdr->recv_timeout = cpu_to_le16(timeout);\n\n\treturn port100_send_cmd_async(dev, PORT100_CMD_TG_COMM_RF, skb,\n\t\t\t\t      port100_tg_comm_rf_complete, cb_arg);\n}\n\nstatic int port100_listen(struct nfc_digital_dev *ddev, u16 timeout,\n\t\t\t  nfc_digital_cmd_complete_t cb, void *arg)\n{\n\tconst struct port100 *dev = nfc_digital_get_drvdata(ddev);\n\tstruct sk_buff *skb;\n\n\tskb = port100_alloc_skb(dev, 0);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\treturn port100_tg_send_cmd(ddev, skb, timeout, cb, arg);\n}\n\nstatic const struct nfc_digital_ops port100_digital_ops = {\n\t.in_configure_hw = port100_in_configure_hw,\n\t.in_send_cmd = port100_in_send_cmd,\n\n\t.tg_listen_mdaa = port100_listen_mdaa,\n\t.tg_listen = port100_listen,\n\t.tg_configure_hw = port100_tg_configure_hw,\n\t.tg_send_cmd = port100_tg_send_cmd,\n\n\t.switch_rf = port100_switch_rf,\n\t.abort_cmd = port100_abort_cmd,\n};\n\nstatic const struct usb_device_id port100_table[] = {\n\t{ USB_DEVICE(SONY_VENDOR_ID, RCS380S_PRODUCT_ID), },\n\t{ USB_DEVICE(SONY_VENDOR_ID, RCS380P_PRODUCT_ID), },\n\t{ }\n};\nMODULE_DEVICE_TABLE(usb, port100_table);\n\nstatic int port100_probe(struct usb_interface *interface,\n\t\t\t const struct usb_device_id *id)\n{\n\tstruct port100 *dev;\n\tint rc;\n\tstruct usb_host_interface *iface_desc;\n\tstruct usb_endpoint_descriptor *endpoint;\n\tint in_endpoint;\n\tint out_endpoint;\n\tu16 fw_version;\n\tu64 cmd_type_mask;\n\tint i;\n\n\tdev = devm_kzalloc(&interface->dev, sizeof(struct port100), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&dev->out_urb_lock);\n\tdev->udev = usb_get_dev(interface_to_usbdev(interface));\n\tdev->interface = interface;\n\tusb_set_intfdata(interface, dev);\n\n\tin_endpoint = out_endpoint = 0;\n\tiface_desc = interface->cur_altsetting;\n\tfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\n\t\tendpoint = &iface_desc->endpoint[i].desc;\n\n\t\tif (!in_endpoint && usb_endpoint_is_bulk_in(endpoint))\n\t\t\tin_endpoint = endpoint->bEndpointAddress;\n\n\t\tif (!out_endpoint && usb_endpoint_is_bulk_out(endpoint))\n\t\t\tout_endpoint = endpoint->bEndpointAddress;\n\t}\n\n\tif (!in_endpoint || !out_endpoint) {\n\t\tnfc_err(&interface->dev,\n\t\t\t\"Could not find bulk-in or bulk-out endpoint\\n\");\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tdev->in_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tdev->out_urb = usb_alloc_urb(0, GFP_KERNEL);\n\n\tif (!dev->in_urb || !dev->out_urb) {\n\t\tnfc_err(&interface->dev, \"Could not allocate USB URBs\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tusb_fill_bulk_urb(dev->in_urb, dev->udev,\n\t\t\t  usb_rcvbulkpipe(dev->udev, in_endpoint),\n\t\t\t  NULL, 0, NULL, dev);\n\tusb_fill_bulk_urb(dev->out_urb, dev->udev,\n\t\t\t  usb_sndbulkpipe(dev->udev, out_endpoint),\n\t\t\t  NULL, 0, port100_send_complete, dev);\n\tdev->out_urb->transfer_flags = URB_ZERO_PACKET;\n\n\tdev->skb_headroom = PORT100_FRAME_HEADER_LEN +\n\t\t\t    PORT100_COMM_RF_HEAD_MAX_LEN;\n\tdev->skb_tailroom = PORT100_FRAME_TAIL_LEN;\n\n\tinit_completion(&dev->cmd_cancel_done);\n\tINIT_WORK(&dev->cmd_complete_work, port100_wq_cmd_complete);\n\n\t \n\tcmd_type_mask = port100_get_command_type_mask(dev);\n\tif (!cmd_type_mask) {\n\t\tnfc_err(&interface->dev,\n\t\t\t\"Could not get supported command types\\n\");\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tif (PORT100_CMD_TYPE_IS_SUPPORTED(cmd_type_mask, PORT100_CMD_TYPE_1))\n\t\tdev->cmd_type = PORT100_CMD_TYPE_1;\n\telse\n\t\tdev->cmd_type = PORT100_CMD_TYPE_0;\n\n\trc = port100_set_command_type(dev, dev->cmd_type);\n\tif (rc) {\n\t\tnfc_err(&interface->dev,\n\t\t\t\"The device does not support command type %u\\n\",\n\t\t\tdev->cmd_type);\n\t\tgoto error;\n\t}\n\n\tfw_version = port100_get_firmware_version(dev);\n\tif (!fw_version)\n\t\tnfc_err(&interface->dev,\n\t\t\t\"Could not get device firmware version\\n\");\n\n\tnfc_info(&interface->dev,\n\t\t \"Sony NFC Port-100 Series attached (firmware v%x.%02x)\\n\",\n\t\t (fw_version & 0xFF00) >> 8, fw_version & 0xFF);\n\n\tdev->nfc_digital_dev = nfc_digital_allocate_device(&port100_digital_ops,\n\t\t\t\t\t\t\t   PORT100_PROTOCOLS,\n\t\t\t\t\t\t\t   PORT100_CAPABILITIES,\n\t\t\t\t\t\t\t   dev->skb_headroom,\n\t\t\t\t\t\t\t   dev->skb_tailroom);\n\tif (!dev->nfc_digital_dev) {\n\t\tnfc_err(&interface->dev,\n\t\t\t\"Could not allocate nfc_digital_dev\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tnfc_digital_set_parent_dev(dev->nfc_digital_dev, &interface->dev);\n\tnfc_digital_set_drvdata(dev->nfc_digital_dev, dev);\n\n\trc = nfc_digital_register_device(dev->nfc_digital_dev);\n\tif (rc) {\n\t\tnfc_err(&interface->dev,\n\t\t\t\"Could not register digital device\\n\");\n\t\tgoto free_nfc_dev;\n\t}\n\n\treturn 0;\n\nfree_nfc_dev:\n\tnfc_digital_free_device(dev->nfc_digital_dev);\n\nerror:\n\tusb_kill_urb(dev->in_urb);\n\tusb_free_urb(dev->in_urb);\n\tusb_kill_urb(dev->out_urb);\n\tusb_free_urb(dev->out_urb);\n\tusb_put_dev(dev->udev);\n\n\treturn rc;\n}\n\nstatic void port100_disconnect(struct usb_interface *interface)\n{\n\tstruct port100 *dev;\n\n\tdev = usb_get_intfdata(interface);\n\tusb_set_intfdata(interface, NULL);\n\n\tnfc_digital_unregister_device(dev->nfc_digital_dev);\n\tnfc_digital_free_device(dev->nfc_digital_dev);\n\n\tusb_kill_urb(dev->in_urb);\n\tusb_kill_urb(dev->out_urb);\n\n\tusb_free_urb(dev->in_urb);\n\tusb_free_urb(dev->out_urb);\n\tusb_put_dev(dev->udev);\n\n\tkfree(dev->cmd);\n\n\tnfc_info(&interface->dev, \"Sony Port-100 NFC device disconnected\\n\");\n}\n\nstatic struct usb_driver port100_driver = {\n\t.name =\t\t\"port100\",\n\t.probe =\tport100_probe,\n\t.disconnect =\tport100_disconnect,\n\t.id_table =\tport100_table,\n};\n\nmodule_usb_driver(port100_driver);\n\nMODULE_DESCRIPTION(\"NFC Port-100 series usb driver ver \" VERSION);\nMODULE_VERSION(VERSION);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}