{
  "module_name": "fdp.c",
  "hash_id": "95175faa2b7e9b1ee73f5e9be2dd40e04132f76749c030f45ffd8fcc197e0265",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nfc/fdp/fdp.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/nfc.h>\n#include <linux/i2c.h>\n#include <linux/delay.h>\n#include <linux/firmware.h>\n#include <net/nfc/nci_core.h>\n\n#include \"fdp.h\"\n\n#define FDP_OTP_PATCH_NAME\t\t\t\"otp.bin\"\n#define FDP_RAM_PATCH_NAME\t\t\t\"ram.bin\"\n#define FDP_FW_HEADER_SIZE\t\t\t576\n#define FDP_FW_UPDATE_SLEEP\t\t\t1000\n\n#define NCI_GET_VERSION_TIMEOUT\t\t\t8000\n#define NCI_PATCH_REQUEST_TIMEOUT\t\t8000\n#define FDP_PATCH_CONN_DEST\t\t\t0xC2\n#define FDP_PATCH_CONN_PARAM_TYPE\t\t0xA0\n\n#define NCI_PATCH_TYPE_RAM\t\t\t0x00\n#define NCI_PATCH_TYPE_OTP\t\t\t0x01\n#define NCI_PATCH_TYPE_EOT\t\t\t0xFF\n\n#define NCI_PARAM_ID_FW_RAM_VERSION\t\t0xA0\n#define NCI_PARAM_ID_FW_OTP_VERSION\t\t0xA1\n#define NCI_PARAM_ID_OTP_LIMITED_VERSION\t0xC5\n#define NCI_PARAM_ID_KEY_INDEX_ID\t\t0xC6\n\n#define NCI_GID_PROP\t\t\t\t0x0F\n#define NCI_OP_PROP_PATCH_OID\t\t\t0x08\n#define NCI_OP_PROP_SET_PDATA_OID\t\t0x23\n\nstruct fdp_nci_info {\n\tconst struct nfc_phy_ops *phy_ops;\n\tstruct fdp_i2c_phy *phy;\n\tstruct nci_dev *ndev;\n\n\tconst struct firmware *otp_patch;\n\tconst struct firmware *ram_patch;\n\tu32 otp_patch_version;\n\tu32 ram_patch_version;\n\n\tu32 otp_version;\n\tu32 ram_version;\n\tu32 limited_otp_version;\n\tu8 key_index;\n\n\tconst u8 *fw_vsc_cfg;\n\tu8 clock_type;\n\tu32 clock_freq;\n\n\tatomic_t data_pkt_counter;\n\tvoid (*data_pkt_counter_cb)(struct nci_dev *ndev);\n\tu8 setup_patch_sent;\n\tu8 setup_patch_ntf;\n\tu8 setup_patch_status;\n\tu8 setup_reset_ntf;\n\twait_queue_head_t setup_wq;\n};\n\nstatic const u8 nci_core_get_config_otp_ram_version[5] = {\n\t0x04,\n\tNCI_PARAM_ID_FW_RAM_VERSION,\n\tNCI_PARAM_ID_FW_OTP_VERSION,\n\tNCI_PARAM_ID_OTP_LIMITED_VERSION,\n\tNCI_PARAM_ID_KEY_INDEX_ID\n};\n\nstruct nci_core_get_config_rsp {\n\tu8 status;\n\tu8 count;\n\tu8 data[];\n};\n\nstatic int fdp_nci_create_conn(struct nci_dev *ndev)\n{\n\tstruct fdp_nci_info *info = nci_get_drvdata(ndev);\n\tstruct core_conn_create_dest_spec_params param;\n\tint r;\n\n\t \n\tparam.type = FDP_PATCH_CONN_PARAM_TYPE;\n\tparam.length = 0x00;\n\n\tr = nci_core_conn_create(info->ndev, FDP_PATCH_CONN_DEST, 1,\n\t\t\t\t sizeof(param), &param);\n\tif (r)\n\t\treturn r;\n\n\treturn nci_get_conn_info_by_dest_type_params(ndev,\n\t\t\t\t\t\t     FDP_PATCH_CONN_DEST, NULL);\n}\n\nstatic inline int fdp_nci_get_versions(struct nci_dev *ndev)\n{\n\treturn nci_core_cmd(ndev, NCI_OP_CORE_GET_CONFIG_CMD,\n\t\t\t    sizeof(nci_core_get_config_otp_ram_version),\n\t\t\t    (__u8 *) &nci_core_get_config_otp_ram_version);\n}\n\nstatic inline int fdp_nci_patch_cmd(struct nci_dev *ndev, u8 type)\n{\n\treturn nci_prop_cmd(ndev, NCI_OP_PROP_PATCH_OID, sizeof(type), &type);\n}\n\nstatic inline int fdp_nci_set_production_data(struct nci_dev *ndev, u8 len,\n\t\t\t\t\t      const char *data)\n{\n\treturn nci_prop_cmd(ndev, NCI_OP_PROP_SET_PDATA_OID, len, data);\n}\n\nstatic int fdp_nci_set_clock(struct nci_dev *ndev, u8 clock_type,\n\t\t\t     u32 clock_freq)\n{\n\tu32 fc = 13560;\n\tu32 nd, num, delta;\n\tchar data[9];\n\n\tnd = (24 * fc) / clock_freq;\n\tdelta = 24 * fc - nd * clock_freq;\n\tnum = (32768 * delta) / clock_freq;\n\n\tdata[0] = 0x00;\n\tdata[1] = 0x00;\n\tdata[2] = 0x00;\n\n\tdata[3] = 0x10;\n\tdata[4] = 0x04;\n\tdata[5] = num & 0xFF;\n\tdata[6] = (num >> 8) & 0xff;\n\tdata[7] = nd;\n\tdata[8] = clock_type;\n\n\treturn fdp_nci_set_production_data(ndev, 9, data);\n}\n\nstatic void fdp_nci_send_patch_cb(struct nci_dev *ndev)\n{\n\tstruct fdp_nci_info *info = nci_get_drvdata(ndev);\n\n\tinfo->setup_patch_sent = 1;\n\twake_up(&info->setup_wq);\n}\n\n \nstatic void fdp_nci_set_data_pkt_counter(struct nci_dev *ndev,\n\t\t\t\t  void (*cb)(struct nci_dev *ndev), int count)\n{\n\tstruct fdp_nci_info *info = nci_get_drvdata(ndev);\n\tstruct device *dev = &info->phy->i2c_dev->dev;\n\n\tdev_dbg(dev, \"NCI data pkt counter %d\\n\", count);\n\tatomic_set(&info->data_pkt_counter, count);\n\tinfo->data_pkt_counter_cb = cb;\n}\n\n \nstatic int fdp_nci_send_patch(struct nci_dev *ndev, u8 conn_id, u8 type)\n{\n\tstruct fdp_nci_info *info = nci_get_drvdata(ndev);\n\tconst struct firmware *fw;\n\tstruct sk_buff *skb;\n\tunsigned long len;\n\tint max_size, payload_size;\n\tint rc = 0;\n\n\tif ((type == NCI_PATCH_TYPE_OTP && !info->otp_patch) ||\n\t    (type == NCI_PATCH_TYPE_RAM && !info->ram_patch))\n\t\treturn -EINVAL;\n\n\tif (type == NCI_PATCH_TYPE_OTP)\n\t\tfw = info->otp_patch;\n\telse\n\t\tfw = info->ram_patch;\n\n\tmax_size = nci_conn_max_data_pkt_payload_size(ndev, conn_id);\n\tif (max_size <= 0)\n\t\treturn -EINVAL;\n\n\tlen = fw->size;\n\n\tfdp_nci_set_data_pkt_counter(ndev, fdp_nci_send_patch_cb,\n\t\t\t\t     DIV_ROUND_UP(fw->size, max_size));\n\n\twhile (len) {\n\n\t\tpayload_size = min_t(unsigned long, max_size, len);\n\n\t\tskb = nci_skb_alloc(ndev, (NCI_CTRL_HDR_SIZE + payload_size),\n\t\t\t\t    GFP_KERNEL);\n\t\tif (!skb) {\n\t\t\tfdp_nci_set_data_pkt_counter(ndev, NULL, 0);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\n\t\tskb_reserve(skb, NCI_CTRL_HDR_SIZE);\n\n\t\tskb_put_data(skb, fw->data + (fw->size - len), payload_size);\n\n\t\trc = nci_send_data(ndev, conn_id, skb);\n\n\t\tif (rc) {\n\t\t\tfdp_nci_set_data_pkt_counter(ndev, NULL, 0);\n\t\t\treturn rc;\n\t\t}\n\n\t\tlen -= payload_size;\n\t}\n\n\treturn rc;\n}\n\nstatic int fdp_nci_open(struct nci_dev *ndev)\n{\n\tconst struct fdp_nci_info *info = nci_get_drvdata(ndev);\n\n\treturn info->phy_ops->enable(info->phy);\n}\n\nstatic int fdp_nci_close(struct nci_dev *ndev)\n{\n\treturn 0;\n}\n\nstatic int fdp_nci_send(struct nci_dev *ndev, struct sk_buff *skb)\n{\n\tstruct fdp_nci_info *info = nci_get_drvdata(ndev);\n\tint ret;\n\n\tif (atomic_dec_and_test(&info->data_pkt_counter))\n\t\tinfo->data_pkt_counter_cb(ndev);\n\n\tret = info->phy_ops->write(info->phy, skb);\n\tif (ret < 0) {\n\t\tkfree_skb(skb);\n\t\treturn ret;\n\t}\n\n\tconsume_skb(skb);\n\treturn 0;\n}\n\nstatic int fdp_nci_request_firmware(struct nci_dev *ndev)\n{\n\tstruct fdp_nci_info *info = nci_get_drvdata(ndev);\n\tstruct device *dev = &info->phy->i2c_dev->dev;\n\tconst u8 *data;\n\tint r;\n\n\tr = request_firmware(&info->ram_patch, FDP_RAM_PATCH_NAME, dev);\n\tif (r < 0) {\n\t\tnfc_err(dev, \"RAM patch request error\\n\");\n\t\treturn r;\n\t}\n\n\tdata = info->ram_patch->data;\n\tinfo->ram_patch_version =\n\t\tdata[FDP_FW_HEADER_SIZE] |\n\t\t(data[FDP_FW_HEADER_SIZE + 1] << 8) |\n\t\t(data[FDP_FW_HEADER_SIZE + 2] << 16) |\n\t\t(data[FDP_FW_HEADER_SIZE + 3] << 24);\n\n\tdev_dbg(dev, \"RAM patch version: %d, size: %zu\\n\",\n\t\t  info->ram_patch_version, info->ram_patch->size);\n\n\n\tr = request_firmware(&info->otp_patch, FDP_OTP_PATCH_NAME, dev);\n\tif (r < 0) {\n\t\tnfc_err(dev, \"OTP patch request error\\n\");\n\t\treturn 0;\n\t}\n\n\tdata = (u8 *) info->otp_patch->data;\n\tinfo->otp_patch_version =\n\t\tdata[FDP_FW_HEADER_SIZE] |\n\t\t(data[FDP_FW_HEADER_SIZE + 1] << 8) |\n\t\t(data[FDP_FW_HEADER_SIZE+2] << 16) |\n\t\t(data[FDP_FW_HEADER_SIZE+3] << 24);\n\n\tdev_dbg(dev, \"OTP patch version: %d, size: %zu\\n\",\n\t\t info->otp_patch_version, info->otp_patch->size);\n\treturn 0;\n}\n\nstatic void fdp_nci_release_firmware(struct nci_dev *ndev)\n{\n\tstruct fdp_nci_info *info = nci_get_drvdata(ndev);\n\n\tif (info->otp_patch) {\n\t\trelease_firmware(info->otp_patch);\n\t\tinfo->otp_patch = NULL;\n\t}\n\n\tif (info->ram_patch) {\n\t\trelease_firmware(info->ram_patch);\n\t\tinfo->ram_patch = NULL;\n\t}\n}\n\nstatic int fdp_nci_patch_otp(struct nci_dev *ndev)\n{\n\tstruct fdp_nci_info *info = nci_get_drvdata(ndev);\n\tstruct device *dev = &info->phy->i2c_dev->dev;\n\tint conn_id;\n\tint r = 0;\n\n\tif (info->otp_version >= info->otp_patch_version)\n\t\treturn r;\n\n\tinfo->setup_patch_sent = 0;\n\tinfo->setup_reset_ntf = 0;\n\tinfo->setup_patch_ntf = 0;\n\n\t \n\tr = fdp_nci_patch_cmd(ndev, NCI_PATCH_TYPE_OTP);\n\tif (r)\n\t\treturn r;\n\n\t \n\tconn_id = fdp_nci_create_conn(ndev);\n\tif (conn_id < 0)\n\t\treturn conn_id;\n\n\t \n\tr = fdp_nci_send_patch(ndev, conn_id, NCI_PATCH_TYPE_OTP);\n\tif (r)\n\t\treturn r;\n\n\t \n\twait_event_interruptible(info->setup_wq,\n\t\t\t\t info->setup_patch_sent == 1);\n\n\t \n\tmsleep(FDP_FW_UPDATE_SLEEP);\n\n\t \n\tr = nci_core_conn_close(info->ndev, conn_id);\n\tif (r)\n\t\treturn r;\n\n\t \n\tif (fdp_nci_patch_cmd(ndev, NCI_PATCH_TYPE_EOT)) {\n\t\tnfc_err(dev, \"OTP patch error 0x%x\\n\", r);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\twait_event_interruptible(info->setup_wq, info->setup_patch_ntf);\n\n\t \n\tr = info->setup_patch_status;\n\tif (r) {\n\t\tnfc_err(dev, \"OTP patch error 0x%x\\n\", r);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\twait_event_interruptible(info->setup_wq, info->setup_reset_ntf);\n\n\treturn r;\n}\n\nstatic int fdp_nci_patch_ram(struct nci_dev *ndev)\n{\n\tstruct fdp_nci_info *info = nci_get_drvdata(ndev);\n\tstruct device *dev = &info->phy->i2c_dev->dev;\n\tint conn_id;\n\tint r = 0;\n\n\tif (info->ram_version >= info->ram_patch_version)\n\t\treturn r;\n\n\tinfo->setup_patch_sent = 0;\n\tinfo->setup_reset_ntf = 0;\n\tinfo->setup_patch_ntf = 0;\n\n\t \n\tr = fdp_nci_patch_cmd(ndev, NCI_PATCH_TYPE_RAM);\n\tif (r)\n\t\treturn r;\n\n\t \n\tconn_id = fdp_nci_create_conn(ndev);\n\tif (conn_id < 0)\n\t\treturn conn_id;\n\n\t \n\tr = fdp_nci_send_patch(ndev, conn_id, NCI_PATCH_TYPE_RAM);\n\tif (r)\n\t\treturn r;\n\n\t \n\twait_event_interruptible(info->setup_wq,\n\t\t\t\t info->setup_patch_sent == 1);\n\n\t \n\tmsleep(FDP_FW_UPDATE_SLEEP);\n\n\t \n\tr = nci_core_conn_close(info->ndev, conn_id);\n\tif (r)\n\t\treturn r;\n\n\t \n\tif (fdp_nci_patch_cmd(ndev, NCI_PATCH_TYPE_EOT)) {\n\t\tnfc_err(dev, \"RAM patch error 0x%x\\n\", r);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\twait_event_interruptible(info->setup_wq, info->setup_patch_ntf);\n\n\t \n\tr = info->setup_patch_status;\n\tif (r) {\n\t\tnfc_err(dev, \"RAM patch error 0x%x\\n\", r);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\twait_event_interruptible(info->setup_wq, info->setup_reset_ntf);\n\n\treturn r;\n}\n\nstatic int fdp_nci_setup(struct nci_dev *ndev)\n{\n\t \n\tstruct fdp_nci_info *info = nci_get_drvdata(ndev);\n\tstruct device *dev = &info->phy->i2c_dev->dev;\n\tint r;\n\tu8 patched = 0;\n\n\tr = nci_core_init(ndev);\n\tif (r)\n\t\tgoto error;\n\n\t \n\tr = fdp_nci_get_versions(ndev);\n\tif (r)\n\t\tgoto error;\n\n\t \n\tr = fdp_nci_request_firmware(ndev);\n\tif (r)\n\t\tgoto error;\n\n\t \n\tif (info->otp_version < info->otp_patch_version) {\n\t\tr = fdp_nci_patch_otp(ndev);\n\t\tif (r)\n\t\t\tgoto error;\n\t\tpatched = 1;\n\t}\n\n\t \n\tif (info->ram_version < info->ram_patch_version) {\n\t\tr = fdp_nci_patch_ram(ndev);\n\t\tif (r)\n\t\t\tgoto error;\n\t\tpatched = 1;\n\t}\n\n\t \n\tfdp_nci_release_firmware(ndev);\n\n\t \n\tif (patched) {\n\t\tr = nci_core_init(ndev);\n\t\tif (r)\n\t\t\tgoto error;\n\n\t\tr = fdp_nci_get_versions(ndev);\n\t\tif (r)\n\t\t\tgoto error;\n\n\t\tif (info->otp_version != info->otp_patch_version ||\n\t\t    info->ram_version != info->ram_patch_version) {\n\t\t\tnfc_err(dev, \"Firmware update failed\");\n\t\t\tr = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t \n\treturn nci_core_reset(ndev);\n\nerror:\n\tfdp_nci_release_firmware(ndev);\n\tnfc_err(dev, \"Setup error %d\\n\", r);\n\treturn r;\n}\n\nstatic int fdp_nci_post_setup(struct nci_dev *ndev)\n{\n\tstruct fdp_nci_info *info = nci_get_drvdata(ndev);\n\tstruct device *dev = &info->phy->i2c_dev->dev;\n\tint r;\n\n\t \n\tif (info->fw_vsc_cfg && info->fw_vsc_cfg[0]) {\n\n\t\t \n\t\tr = fdp_nci_set_production_data(ndev, info->fw_vsc_cfg[3],\n\t\t\t\t\t\t&info->fw_vsc_cfg[4]);\n\t\tif (r) {\n\t\t\tnfc_err(dev, \"Vendor specific config set error %d\\n\",\n\t\t\t\tr);\n\t\t\treturn r;\n\t\t}\n\t}\n\n\t \n\tr = fdp_nci_set_clock(ndev, info->clock_type, info->clock_freq);\n\tif (r) {\n\t\tnfc_err(dev, \"Clock set error %d\\n\", r);\n\t\treturn r;\n\t}\n\n\t \n\tr = nci_core_reset(ndev);\n\tif (r)\n\t\treturn r;\n\n\t \n\treturn nci_core_init(ndev);\n}\n\nstatic int fdp_nci_core_reset_ntf_packet(struct nci_dev *ndev,\n\t\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct fdp_nci_info *info = nci_get_drvdata(ndev);\n\n\tinfo->setup_reset_ntf = 1;\n\twake_up(&info->setup_wq);\n\n\treturn 0;\n}\n\nstatic int fdp_nci_prop_patch_ntf_packet(struct nci_dev *ndev,\n\t\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct fdp_nci_info *info = nci_get_drvdata(ndev);\n\n\tinfo->setup_patch_ntf = 1;\n\tinfo->setup_patch_status = skb->data[0];\n\twake_up(&info->setup_wq);\n\n\treturn 0;\n}\n\nstatic int fdp_nci_prop_patch_rsp_packet(struct nci_dev *ndev,\n\t\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct fdp_nci_info *info = nci_get_drvdata(ndev);\n\tstruct device *dev = &info->phy->i2c_dev->dev;\n\tu8 status = skb->data[0];\n\n\tdev_dbg(dev, \"%s: status 0x%x\\n\", __func__, status);\n\tnci_req_complete(ndev, status);\n\n\treturn 0;\n}\n\nstatic int fdp_nci_prop_set_production_data_rsp_packet(struct nci_dev *ndev,\n\t\t\t\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct fdp_nci_info *info = nci_get_drvdata(ndev);\n\tstruct device *dev = &info->phy->i2c_dev->dev;\n\tu8 status = skb->data[0];\n\n\tdev_dbg(dev, \"%s: status 0x%x\\n\", __func__, status);\n\tnci_req_complete(ndev, status);\n\n\treturn 0;\n}\n\nstatic int fdp_nci_core_get_config_rsp_packet(struct nci_dev *ndev,\n\t\t\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct fdp_nci_info *info = nci_get_drvdata(ndev);\n\tstruct device *dev = &info->phy->i2c_dev->dev;\n\tconst struct nci_core_get_config_rsp *rsp = (void *) skb->data;\n\tunsigned int i;\n\tconst u8 *p;\n\n\tif (rsp->status == NCI_STATUS_OK) {\n\n\t\tp = rsp->data;\n\t\tfor (i = 0; i < 4; i++) {\n\n\t\t\tswitch (*p++) {\n\t\t\tcase NCI_PARAM_ID_FW_RAM_VERSION:\n\t\t\t\tp++;\n\t\t\t\tinfo->ram_version = le32_to_cpup((__le32 *) p);\n\t\t\t\tp += 4;\n\t\t\t\tbreak;\n\t\t\tcase NCI_PARAM_ID_FW_OTP_VERSION:\n\t\t\t\tp++;\n\t\t\t\tinfo->otp_version = le32_to_cpup((__le32 *) p);\n\t\t\t\tp += 4;\n\t\t\t\tbreak;\n\t\t\tcase NCI_PARAM_ID_OTP_LIMITED_VERSION:\n\t\t\t\tp++;\n\t\t\t\tinfo->otp_version = le32_to_cpup((__le32 *) p);\n\t\t\t\tp += 4;\n\t\t\t\tbreak;\n\t\t\tcase NCI_PARAM_ID_KEY_INDEX_ID:\n\t\t\t\tp++;\n\t\t\t\tinfo->key_index = *p++;\n\t\t\t}\n\t\t}\n\t}\n\n\tdev_dbg(dev, \"OTP version %d\\n\", info->otp_version);\n\tdev_dbg(dev, \"RAM version %d\\n\", info->ram_version);\n\tdev_dbg(dev, \"key index %d\\n\", info->key_index);\n\tdev_dbg(dev, \"%s: status 0x%x\\n\", __func__, rsp->status);\n\n\tnci_req_complete(ndev, rsp->status);\n\n\treturn 0;\n}\n\nstatic const struct nci_driver_ops fdp_core_ops[] = {\n\t{\n\t\t.opcode = NCI_OP_CORE_GET_CONFIG_RSP,\n\t\t.rsp = fdp_nci_core_get_config_rsp_packet,\n\t},\n\t{\n\t\t.opcode = NCI_OP_CORE_RESET_NTF,\n\t\t.ntf = fdp_nci_core_reset_ntf_packet,\n\t},\n};\n\nstatic const struct nci_driver_ops fdp_prop_ops[] = {\n\t{\n\t\t.opcode = nci_opcode_pack(NCI_GID_PROP, NCI_OP_PROP_PATCH_OID),\n\t\t.rsp = fdp_nci_prop_patch_rsp_packet,\n\t\t.ntf = fdp_nci_prop_patch_ntf_packet,\n\t},\n\t{\n\t\t.opcode = nci_opcode_pack(NCI_GID_PROP,\n\t\t\t\t\t  NCI_OP_PROP_SET_PDATA_OID),\n\t\t.rsp = fdp_nci_prop_set_production_data_rsp_packet,\n\t},\n};\n\nstatic const struct nci_ops nci_ops = {\n\t.open = fdp_nci_open,\n\t.close = fdp_nci_close,\n\t.send = fdp_nci_send,\n\t.setup = fdp_nci_setup,\n\t.post_setup = fdp_nci_post_setup,\n\t.prop_ops = fdp_prop_ops,\n\t.n_prop_ops = ARRAY_SIZE(fdp_prop_ops),\n\t.core_ops = fdp_core_ops,\n\t.n_core_ops = ARRAY_SIZE(fdp_core_ops),\n};\n\nint fdp_nci_probe(struct fdp_i2c_phy *phy, const struct nfc_phy_ops *phy_ops,\n\t\t\tstruct nci_dev **ndevp, int tx_headroom,\n\t\t\tint tx_tailroom, u8 clock_type, u32 clock_freq,\n\t\t\tconst u8 *fw_vsc_cfg)\n{\n\tstruct device *dev = &phy->i2c_dev->dev;\n\tstruct fdp_nci_info *info;\n\tstruct nci_dev *ndev;\n\tu32 protocols;\n\tint r;\n\n\tinfo = devm_kzalloc(dev, sizeof(struct fdp_nci_info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinfo->phy = phy;\n\tinfo->phy_ops = phy_ops;\n\tinfo->clock_type = clock_type;\n\tinfo->clock_freq = clock_freq;\n\tinfo->fw_vsc_cfg = fw_vsc_cfg;\n\n\tinit_waitqueue_head(&info->setup_wq);\n\n\tprotocols = NFC_PROTO_JEWEL_MASK |\n\t\t    NFC_PROTO_MIFARE_MASK |\n\t\t    NFC_PROTO_FELICA_MASK |\n\t\t    NFC_PROTO_ISO14443_MASK |\n\t\t    NFC_PROTO_ISO14443_B_MASK |\n\t\t    NFC_PROTO_NFC_DEP_MASK |\n\t\t    NFC_PROTO_ISO15693_MASK;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(fdp_prop_ops) > NCI_MAX_PROPRIETARY_CMD);\n\tndev = nci_allocate_device(&nci_ops, protocols, tx_headroom,\n\t\t\t\t   tx_tailroom);\n\tif (!ndev) {\n\t\tnfc_err(dev, \"Cannot allocate nfc ndev\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tr = nci_register_device(ndev);\n\tif (r)\n\t\tgoto err_regdev;\n\n\t*ndevp = ndev;\n\tinfo->ndev = ndev;\n\n\tnci_set_drvdata(ndev, info);\n\n\treturn 0;\n\nerr_regdev:\n\tnci_free_device(ndev);\n\treturn r;\n}\nEXPORT_SYMBOL(fdp_nci_probe);\n\nvoid fdp_nci_remove(struct nci_dev *ndev)\n{\n\tnci_unregister_device(ndev);\n\tnci_free_device(ndev);\n}\nEXPORT_SYMBOL(fdp_nci_remove);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"NFC NCI driver for Intel Fields Peak NFC controller\");\nMODULE_AUTHOR(\"Robert Dolca <robert.dolca@intel.com>\");\n\nMODULE_FIRMWARE(FDP_OTP_PATCH_NAME);\nMODULE_FIRMWARE(FDP_RAM_PATCH_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}