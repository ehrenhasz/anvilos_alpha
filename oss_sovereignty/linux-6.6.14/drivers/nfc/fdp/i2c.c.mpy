{
  "module_name": "i2c.c",
  "hash_id": "568cd1b5fc1bcf5bff4aa78607db62669ee228836cb2a1f94af065a41c743a54",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nfc/fdp/i2c.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/acpi.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/nfc.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <net/nfc/nfc.h>\n#include <net/nfc/nci_core.h>\n\n#include \"fdp.h\"\n\n#define FDP_I2C_DRIVER_NAME\t\"fdp_nci_i2c\"\n\n#define FDP_DP_CLOCK_TYPE_NAME\t\"clock-type\"\n#define FDP_DP_CLOCK_FREQ_NAME\t\"clock-freq\"\n#define FDP_DP_FW_VSC_CFG_NAME\t\"fw-vsc-cfg\"\n\n#define FDP_FRAME_HEADROOM\t2\n#define FDP_FRAME_TAILROOM\t1\n\n#define FDP_NCI_I2C_MIN_PAYLOAD\t5\n#define FDP_NCI_I2C_MAX_PAYLOAD\t261\n\n#define FDP_POWER_OFF\t\t0\n#define FDP_POWER_ON\t\t1\n\n#define fdp_nci_i2c_dump_skb(dev, prefix, skb)\t\t\t\t\\\n\tprint_hex_dump(KERN_DEBUG, prefix\": \", DUMP_PREFIX_OFFSET,\t\\\n\t\t       16, 1, (skb)->data, (skb)->len, 0)\n\nstatic void fdp_nci_i2c_reset(const struct fdp_i2c_phy *phy)\n{\n\t \n\tgpiod_set_value_cansleep(phy->power_gpio, FDP_POWER_OFF);\n\tusleep_range(1000, 4000);\n\tgpiod_set_value_cansleep(phy->power_gpio, FDP_POWER_ON);\n\tusleep_range(10000, 14000);\n}\n\nstatic int fdp_nci_i2c_enable(void *phy_id)\n{\n\tconst struct fdp_i2c_phy *phy = phy_id;\n\n\tfdp_nci_i2c_reset(phy);\n\n\treturn 0;\n}\n\nstatic void fdp_nci_i2c_disable(void *phy_id)\n{\n\tconst struct fdp_i2c_phy *phy = phy_id;\n\n\tfdp_nci_i2c_reset(phy);\n}\n\nstatic void fdp_nci_i2c_add_len_lrc(struct sk_buff *skb)\n{\n\tu8 lrc = 0;\n\tu16 len, i;\n\n\t \n\tlen = skb->len;\n\t*(u8 *)skb_push(skb, 1) = len & 0xff;\n\t*(u8 *)skb_push(skb, 1) = len >> 8;\n\n\t \n\tfor (i = 0; i < len + 2; i++)\n\t\tlrc ^= skb->data[i];\n\n\tskb_put_u8(skb, lrc);\n}\n\nstatic void fdp_nci_i2c_remove_len_lrc(struct sk_buff *skb)\n{\n\tskb_pull(skb, FDP_FRAME_HEADROOM);\n\tskb_trim(skb, skb->len - FDP_FRAME_TAILROOM);\n}\n\nstatic int fdp_nci_i2c_write(void *phy_id, struct sk_buff *skb)\n{\n\tstruct fdp_i2c_phy *phy = phy_id;\n\tstruct i2c_client *client = phy->i2c_dev;\n\tint r;\n\n\tif (phy->hard_fault != 0)\n\t\treturn phy->hard_fault;\n\n\tfdp_nci_i2c_add_len_lrc(skb);\n\tfdp_nci_i2c_dump_skb(&client->dev, \"fdp_wr\", skb);\n\n\tr = i2c_master_send(client, skb->data, skb->len);\n\tif (r == -EREMOTEIO) {   \n\t\tusleep_range(1000, 4000);\n\t\tr = i2c_master_send(client, skb->data, skb->len);\n\t}\n\n\tif (r < 0 || r != skb->len)\n\t\tdev_dbg(&client->dev, \"%s: error err=%d len=%d\\n\",\n\t\t\t__func__, r, skb->len);\n\n\tif (r >= 0) {\n\t\tif (r != skb->len) {\n\t\t\tphy->hard_fault = r;\n\t\t\tr = -EREMOTEIO;\n\t\t} else {\n\t\t\tr = 0;\n\t\t}\n\t}\n\n\tfdp_nci_i2c_remove_len_lrc(skb);\n\n\treturn r;\n}\n\nstatic const struct nfc_phy_ops i2c_phy_ops = {\n\t.write = fdp_nci_i2c_write,\n\t.enable = fdp_nci_i2c_enable,\n\t.disable = fdp_nci_i2c_disable,\n};\n\nstatic int fdp_nci_i2c_read(struct fdp_i2c_phy *phy, struct sk_buff **skb)\n{\n\tint r, len;\n\tu8 tmp[FDP_NCI_I2C_MAX_PAYLOAD], lrc, k;\n\tu16 i;\n\tstruct i2c_client *client = phy->i2c_dev;\n\n\t*skb = NULL;\n\n\t \n\tfor (k = 0; k < 2; k++) {\n\n\t\tlen = phy->next_read_size;\n\n\t\tr = i2c_master_recv(client, tmp, len);\n\t\tif (r != len) {\n\t\t\tdev_dbg(&client->dev, \"%s: i2c recv err: %d\\n\",\n\t\t\t\t__func__, r);\n\t\t\tgoto flush;\n\t\t}\n\n\t\t \n\t\tfor (lrc = i = 0; i < r; i++)\n\t\t\tlrc ^= tmp[i];\n\n\t\t \n\t\tif (lrc) {\n\t\t\tdev_dbg(&client->dev, \"%s: corrupted packet\\n\",\n\t\t\t\t__func__);\n\t\t\tphy->next_read_size = 5;\n\t\t\tgoto flush;\n\t\t}\n\n\t\t \n\t\tif (tmp[0] == 0 && tmp[1] == 0) {\n\t\t\tphy->next_read_size = (tmp[2] << 8) + tmp[3] + 3;\n\t\t} else {\n\t\t\tphy->next_read_size = FDP_NCI_I2C_MIN_PAYLOAD;\n\n\t\t\t*skb = alloc_skb(len, GFP_KERNEL);\n\t\t\tif (*skb == NULL) {\n\t\t\t\tr = -ENOMEM;\n\t\t\t\tgoto flush;\n\t\t\t}\n\n\t\t\tskb_put_data(*skb, tmp, len);\n\t\t\tfdp_nci_i2c_dump_skb(&client->dev, \"fdp_rd\", *skb);\n\n\t\t\tfdp_nci_i2c_remove_len_lrc(*skb);\n\t\t}\n\t}\n\n\treturn 0;\n\nflush:\n\t \n\tif (i2c_master_recv(client, tmp, sizeof(tmp)) < 0)\n\t\tr = -EREMOTEIO;\n\n\treturn r;\n}\n\nstatic irqreturn_t fdp_nci_i2c_irq_thread_fn(int irq, void *phy_id)\n{\n\tstruct fdp_i2c_phy *phy = phy_id;\n\tstruct sk_buff *skb;\n\tint r;\n\n\tif (!phy || irq != phy->i2c_dev->irq) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn IRQ_NONE;\n\t}\n\n\tr = fdp_nci_i2c_read(phy, &skb);\n\n\tif (r == -EREMOTEIO || r == -ENOMEM || r == -EBADMSG)\n\t\treturn IRQ_HANDLED;\n\n\tif (skb != NULL)\n\t\tnci_recv_frame(phy->ndev, skb);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void fdp_nci_i2c_read_device_properties(struct device *dev,\n\t\t\t\t\t       u8 *clock_type, u32 *clock_freq,\n\t\t\t\t\t       u8 **fw_vsc_cfg)\n{\n\tint r;\n\tu8 len;\n\n\tr = device_property_read_u8(dev, FDP_DP_CLOCK_TYPE_NAME, clock_type);\n\tif (r) {\n\t\tdev_dbg(dev, \"Using default clock type\");\n\t\t*clock_type = 0;\n\t}\n\n\tr = device_property_read_u32(dev, FDP_DP_CLOCK_FREQ_NAME, clock_freq);\n\tif (r) {\n\t\tdev_dbg(dev, \"Using default clock frequency\\n\");\n\t\t*clock_freq = 26000;\n\t}\n\n\tif (device_property_present(dev, FDP_DP_FW_VSC_CFG_NAME)) {\n\t\tr = device_property_read_u8(dev, FDP_DP_FW_VSC_CFG_NAME,\n\t\t\t\t\t    &len);\n\n\t\tif (r || len <= 0)\n\t\t\tgoto vsc_read_err;\n\n\t\t \n\t\tlen++;\n\n\t\t*fw_vsc_cfg = devm_kmalloc_array(dev,\n\t\t\t\t\t   len, sizeof(**fw_vsc_cfg),\n\t\t\t\t\t   GFP_KERNEL);\n\n\t\tif (!*fw_vsc_cfg)\n\t\t\tgoto alloc_err;\n\n\t\tr = device_property_read_u8_array(dev, FDP_DP_FW_VSC_CFG_NAME,\n\t\t\t\t\t\t  *fw_vsc_cfg, len);\n\n\t\tif (r) {\n\t\t\tdevm_kfree(dev, *fw_vsc_cfg);\n\t\t\tgoto vsc_read_err;\n\t\t}\n\t} else {\nvsc_read_err:\n\t\tdev_dbg(dev, \"FW vendor specific commands not present\\n\");\n\t\t*fw_vsc_cfg = NULL;\n\t}\n\nalloc_err:\n\tdev_dbg(dev, \"Clock type: %d, clock frequency: %d, VSC: %s\",\n\t\t*clock_type, *clock_freq, *fw_vsc_cfg != NULL ? \"yes\" : \"no\");\n}\n\nstatic const struct acpi_gpio_params power_gpios = { 0, 0, false };\n\nstatic const struct acpi_gpio_mapping acpi_fdp_gpios[] = {\n\t{ \"power-gpios\", &power_gpios, 1 },\n\t{},\n};\n\nstatic int fdp_nci_i2c_probe(struct i2c_client *client)\n{\n\tstruct fdp_i2c_phy *phy;\n\tstruct device *dev = &client->dev;\n\tu8 *fw_vsc_cfg;\n\tu8 clock_type;\n\tu32 clock_freq;\n\tint r = 0;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\n\t\tnfc_err(dev, \"No I2C_FUNC_I2C support\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (client->irq <= 0) {\n\t\tnfc_err(dev, \"IRQ not present\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tphy = devm_kzalloc(dev, sizeof(struct fdp_i2c_phy), GFP_KERNEL);\n\tif (!phy)\n\t\treturn -ENOMEM;\n\n\tphy->i2c_dev = client;\n\tphy->next_read_size = FDP_NCI_I2C_MIN_PAYLOAD;\n\ti2c_set_clientdata(client, phy);\n\n\tr = devm_request_threaded_irq(dev, client->irq,\n\t\t\t\t      NULL, fdp_nci_i2c_irq_thread_fn,\n\t\t\t\t      IRQF_TRIGGER_RISING | IRQF_ONESHOT,\n\t\t\t\t      FDP_I2C_DRIVER_NAME, phy);\n\n\tif (r < 0) {\n\t\tnfc_err(&client->dev, \"Unable to register IRQ handler\\n\");\n\t\treturn r;\n\t}\n\n\tr = devm_acpi_dev_add_driver_gpios(dev, acpi_fdp_gpios);\n\tif (r)\n\t\tdev_dbg(dev, \"Unable to add GPIO mapping table\\n\");\n\n\t \n\tphy->power_gpio = devm_gpiod_get(dev, \"power\", GPIOD_OUT_LOW);\n\tif (IS_ERR(phy->power_gpio)) {\n\t\tnfc_err(dev, \"Power GPIO request failed\\n\");\n\t\treturn PTR_ERR(phy->power_gpio);\n\t}\n\n\t \n\tfdp_nci_i2c_read_device_properties(dev, &clock_type, &clock_freq,\n\t\t\t\t\t   &fw_vsc_cfg);\n\n\t \n\tr = fdp_nci_probe(phy, &i2c_phy_ops, &phy->ndev,\n\t\t\t  FDP_FRAME_HEADROOM, FDP_FRAME_TAILROOM,\n\t\t\t  clock_type, clock_freq, fw_vsc_cfg);\n\tif (r < 0) {\n\t\tnfc_err(dev, \"NCI probing error\\n\");\n\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\nstatic void fdp_nci_i2c_remove(struct i2c_client *client)\n{\n\tstruct fdp_i2c_phy *phy = i2c_get_clientdata(client);\n\n\tfdp_nci_remove(phy->ndev);\n\tfdp_nci_i2c_disable(phy);\n}\n\nstatic const struct acpi_device_id fdp_nci_i2c_acpi_match[] = {\n\t{\"INT339A\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(acpi, fdp_nci_i2c_acpi_match);\n\nstatic struct i2c_driver fdp_nci_i2c_driver = {\n\t.driver = {\n\t\t   .name = FDP_I2C_DRIVER_NAME,\n\t\t   .acpi_match_table = fdp_nci_i2c_acpi_match,\n\t\t  },\n\t.probe = fdp_nci_i2c_probe,\n\t.remove = fdp_nci_i2c_remove,\n};\nmodule_i2c_driver(fdp_nci_i2c_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"I2C driver for Intel Fields Peak NFC controller\");\nMODULE_AUTHOR(\"Robert Dolca <robert.dolca@intel.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}