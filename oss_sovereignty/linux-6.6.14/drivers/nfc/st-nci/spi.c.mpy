{
  "module_name": "spi.c",
  "hash_id": "9cd13e91351aab4cb87b89fdb3ecd37a1c1db4447f808449d44055c7386ab7b1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nfc/st-nci/spi.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/spi/spi.h>\n#include <linux/gpio/consumer.h>\n#include <linux/acpi.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/nfc.h>\n#include <linux/of.h>\n#include <net/nfc/nci.h>\n\n#include \"st-nci.h\"\n\n#define DRIVER_DESC \"NCI NFC driver for ST_NCI\"\n\n \n#define ST_NCI_FRAME_HEADROOM\t1\n#define ST_NCI_FRAME_TAILROOM\t0\n\n#define ST_NCI_SPI_MIN_SIZE 4    \n#define ST_NCI_SPI_MAX_SIZE 250  \n\n#define ST_NCI_DRIVER_NAME \"st_nci\"\n#define ST_NCI_SPI_DRIVER_NAME \"st_nci_spi\"\n\nstruct st_nci_spi_phy {\n\tstruct spi_device *spi_dev;\n\tstruct llt_ndlc *ndlc;\n\n\tbool irq_active;\n\n\tstruct gpio_desc *gpiod_reset;\n\n\tstruct st_nci_se_status se_status;\n};\n\nstatic int st_nci_spi_enable(void *phy_id)\n{\n\tstruct st_nci_spi_phy *phy = phy_id;\n\n\tgpiod_set_value(phy->gpiod_reset, 0);\n\tusleep_range(10000, 15000);\n\tgpiod_set_value(phy->gpiod_reset, 1);\n\tusleep_range(80000, 85000);\n\n\tif (phy->ndlc->powered == 0 && phy->irq_active == 0) {\n\t\tenable_irq(phy->spi_dev->irq);\n\t\tphy->irq_active = true;\n\t}\n\n\treturn 0;\n}\n\nstatic void st_nci_spi_disable(void *phy_id)\n{\n\tstruct st_nci_spi_phy *phy = phy_id;\n\n\tdisable_irq_nosync(phy->spi_dev->irq);\n\tphy->irq_active = false;\n}\n\n \nstatic int st_nci_spi_write(void *phy_id, struct sk_buff *skb)\n{\n\tint r;\n\tstruct st_nci_spi_phy *phy = phy_id;\n\tstruct spi_device *dev = phy->spi_dev;\n\tstruct sk_buff *skb_rx;\n\tu8 buf[ST_NCI_SPI_MAX_SIZE + NCI_DATA_HDR_SIZE +\n\t       ST_NCI_FRAME_HEADROOM + ST_NCI_FRAME_TAILROOM];\n\tstruct spi_transfer spi_xfer = {\n\t\t.tx_buf = skb->data,\n\t\t.rx_buf = buf,\n\t\t.len = skb->len,\n\t};\n\n\tif (phy->ndlc->hard_fault != 0)\n\t\treturn phy->ndlc->hard_fault;\n\n\tr = spi_sync_transfer(dev, &spi_xfer, 1);\n\t \n\tif (!r) {\n\t\tskb_rx = alloc_skb(skb->len, GFP_KERNEL);\n\t\tif (!skb_rx)\n\t\t\treturn -ENOMEM;\n\n\t\tskb_put(skb_rx, skb->len);\n\t\tmemcpy(skb_rx->data, buf, skb->len);\n\t\tndlc_recv(phy->ndlc, skb_rx);\n\t}\n\n\treturn r;\n}\n\n \nstatic int st_nci_spi_read(struct st_nci_spi_phy *phy,\n\t\t\tstruct sk_buff **skb)\n{\n\tint r;\n\tu8 len;\n\tu8 buf[ST_NCI_SPI_MAX_SIZE];\n\tstruct spi_device *dev = phy->spi_dev;\n\tstruct spi_transfer spi_xfer = {\n\t\t.rx_buf = buf,\n\t\t.len = ST_NCI_SPI_MIN_SIZE,\n\t};\n\n\tr = spi_sync_transfer(dev, &spi_xfer, 1);\n\tif (r < 0)\n\t\treturn -EREMOTEIO;\n\n\tlen = be16_to_cpu(*(__be16 *) (buf + 2));\n\tif (len > ST_NCI_SPI_MAX_SIZE) {\n\t\tnfc_err(&dev->dev, \"invalid frame len\\n\");\n\t\tphy->ndlc->hard_fault = 1;\n\t\treturn -EBADMSG;\n\t}\n\n\t*skb = alloc_skb(ST_NCI_SPI_MIN_SIZE + len, GFP_KERNEL);\n\tif (*skb == NULL)\n\t\treturn -ENOMEM;\n\n\tskb_reserve(*skb, ST_NCI_SPI_MIN_SIZE);\n\tskb_put(*skb, ST_NCI_SPI_MIN_SIZE);\n\tmemcpy((*skb)->data, buf, ST_NCI_SPI_MIN_SIZE);\n\n\tif (!len)\n\t\treturn 0;\n\n\tspi_xfer.len = len;\n\tr = spi_sync_transfer(dev, &spi_xfer, 1);\n\tif (r < 0) {\n\t\tkfree_skb(*skb);\n\t\treturn -EREMOTEIO;\n\t}\n\n\tskb_put(*skb, len);\n\tmemcpy((*skb)->data + ST_NCI_SPI_MIN_SIZE, buf, len);\n\n\treturn 0;\n}\n\n \nstatic irqreturn_t st_nci_irq_thread_fn(int irq, void *phy_id)\n{\n\tstruct st_nci_spi_phy *phy = phy_id;\n\tstruct sk_buff *skb = NULL;\n\tint r;\n\n\tif (!phy || !phy->ndlc || irq != phy->spi_dev->irq) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (phy->ndlc->hard_fault)\n\t\treturn IRQ_HANDLED;\n\n\tif (!phy->ndlc->powered) {\n\t\tst_nci_spi_disable(phy);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tr = st_nci_spi_read(phy, &skb);\n\tif (r == -EREMOTEIO || r == -ENOMEM || r == -EBADMSG)\n\t\treturn IRQ_HANDLED;\n\n\tndlc_recv(phy->ndlc, skb);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct nfc_phy_ops spi_phy_ops = {\n\t.write = st_nci_spi_write,\n\t.enable = st_nci_spi_enable,\n\t.disable = st_nci_spi_disable,\n};\n\nstatic const struct acpi_gpio_params reset_gpios = { 1, 0, false };\n\nstatic const struct acpi_gpio_mapping acpi_st_nci_gpios[] = {\n\t{ \"reset-gpios\", &reset_gpios, 1 },\n\t{},\n};\n\nstatic int st_nci_spi_probe(struct spi_device *dev)\n{\n\tstruct st_nci_spi_phy *phy;\n\tint r;\n\n\t \n\tif (!dev) {\n\t\tpr_debug(\"%s: dev is NULL. Device is not accessible.\\n\",\n\t\t\t__func__);\n\t\treturn -ENODEV;\n\t}\n\n\tphy = devm_kzalloc(&dev->dev, sizeof(struct st_nci_spi_phy),\n\t\t\t   GFP_KERNEL);\n\tif (!phy)\n\t\treturn -ENOMEM;\n\n\tphy->spi_dev = dev;\n\n\tspi_set_drvdata(dev, phy);\n\n\tr = devm_acpi_dev_add_driver_gpios(&dev->dev, acpi_st_nci_gpios);\n\tif (r)\n\t\tdev_dbg(&dev->dev, \"Unable to add GPIO mapping table\\n\");\n\n\t \n\tphy->gpiod_reset = devm_gpiod_get(&dev->dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(phy->gpiod_reset)) {\n\t\tnfc_err(&dev->dev, \"Unable to get RESET GPIO\\n\");\n\t\treturn PTR_ERR(phy->gpiod_reset);\n\t}\n\n\tphy->se_status.is_ese_present =\n\t\t\tdevice_property_read_bool(&dev->dev, \"ese-present\");\n\tphy->se_status.is_uicc_present =\n\t\t\tdevice_property_read_bool(&dev->dev, \"uicc-present\");\n\n\tr = ndlc_probe(phy, &spi_phy_ops, &dev->dev,\n\t\t\tST_NCI_FRAME_HEADROOM, ST_NCI_FRAME_TAILROOM,\n\t\t\t&phy->ndlc, &phy->se_status);\n\tif (r < 0) {\n\t\tnfc_err(&dev->dev, \"Unable to register ndlc layer\\n\");\n\t\treturn r;\n\t}\n\n\tphy->irq_active = true;\n\tr = devm_request_threaded_irq(&dev->dev, dev->irq, NULL,\n\t\t\t\tst_nci_irq_thread_fn,\n\t\t\t\tIRQF_ONESHOT,\n\t\t\t\tST_NCI_SPI_DRIVER_NAME, phy);\n\tif (r < 0)\n\t\tnfc_err(&dev->dev, \"Unable to register IRQ handler\\n\");\n\n\treturn r;\n}\n\nstatic void st_nci_spi_remove(struct spi_device *dev)\n{\n\tstruct st_nci_spi_phy *phy = spi_get_drvdata(dev);\n\n\tndlc_remove(phy->ndlc);\n}\n\nstatic struct spi_device_id st_nci_spi_id_table[] = {\n\t{ST_NCI_SPI_DRIVER_NAME, 0},\n\t{\"st21nfcb-spi\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, st_nci_spi_id_table);\n\nstatic const struct acpi_device_id st_nci_spi_acpi_match[] __maybe_unused = {\n\t{\"SMO2101\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(acpi, st_nci_spi_acpi_match);\n\nstatic const struct of_device_id of_st_nci_spi_match[] __maybe_unused = {\n\t{ .compatible = \"st,st21nfcb-spi\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, of_st_nci_spi_match);\n\nstatic struct spi_driver st_nci_spi_driver = {\n\t.driver = {\n\t\t.name = ST_NCI_SPI_DRIVER_NAME,\n\t\t.of_match_table = of_match_ptr(of_st_nci_spi_match),\n\t\t.acpi_match_table = ACPI_PTR(st_nci_spi_acpi_match),\n\t},\n\t.probe = st_nci_spi_probe,\n\t.id_table = st_nci_spi_id_table,\n\t.remove = st_nci_spi_remove,\n};\nmodule_spi_driver(st_nci_spi_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(DRIVER_DESC);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}