{
  "module_name": "ndlc.c",
  "hash_id": "59a524e28ad8b20f9ba62802a635aef712300f1d4f3b59e528ed9b889490167e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nfc/st-nci/ndlc.c",
  "human_readable_source": "\n \n\n#include <linux/sched.h>\n#include <net/nfc/nci_core.h>\n\n#include \"st-nci.h\"\n\n#define NDLC_TIMER_T1\t\t100\n#define NDLC_TIMER_T1_WAIT\t400\n#define NDLC_TIMER_T2\t\t1200\n\n#define PCB_TYPE_DATAFRAME\t\t0x80\n#define PCB_TYPE_SUPERVISOR\t\t0xc0\n#define PCB_TYPE_MASK\t\t\tPCB_TYPE_SUPERVISOR\n\n#define PCB_SYNC_ACK\t\t\t0x20\n#define PCB_SYNC_NACK\t\t\t0x10\n#define PCB_SYNC_WAIT\t\t\t0x30\n#define PCB_SYNC_NOINFO\t\t\t0x00\n#define PCB_SYNC_MASK\t\t\tPCB_SYNC_WAIT\n\n#define PCB_DATAFRAME_RETRANSMIT_YES\t0x00\n#define PCB_DATAFRAME_RETRANSMIT_NO\t0x04\n#define PCB_DATAFRAME_RETRANSMIT_MASK\tPCB_DATAFRAME_RETRANSMIT_NO\n\n#define PCB_SUPERVISOR_RETRANSMIT_YES\t0x00\n#define PCB_SUPERVISOR_RETRANSMIT_NO\t0x02\n#define PCB_SUPERVISOR_RETRANSMIT_MASK\tPCB_SUPERVISOR_RETRANSMIT_NO\n\n#define PCB_FRAME_CRC_INFO_PRESENT\t0x08\n#define PCB_FRAME_CRC_INFO_NOTPRESENT\t0x00\n#define PCB_FRAME_CRC_INFO_MASK\t\tPCB_FRAME_CRC_INFO_PRESENT\n\n#define NDLC_DUMP_SKB(info, skb)                                 \\\ndo {                                                             \\\n\tpr_debug(\"%s:\\n\", info);                                 \\\n\tprint_hex_dump(KERN_DEBUG, \"ndlc: \", DUMP_PREFIX_OFFSET, \\\n\t\t\t16, 1, skb->data, skb->len, 0);          \\\n} while (0)\n\nint ndlc_open(struct llt_ndlc *ndlc)\n{\n\t \n\tndlc->ops->enable(ndlc->phy_id);\n\tndlc->powered = 1;\n\treturn 0;\n}\nEXPORT_SYMBOL(ndlc_open);\n\nvoid ndlc_close(struct llt_ndlc *ndlc)\n{\n\tstruct nci_mode_set_cmd cmd;\n\n\tcmd.cmd_type = ST_NCI_SET_NFC_MODE;\n\tcmd.mode = 0;\n\n\t \n\tndlc->ops->enable(ndlc->phy_id);\n\n\tnci_prop_cmd(ndlc->ndev, ST_NCI_CORE_PROP,\n\t\t     sizeof(struct nci_mode_set_cmd), (__u8 *)&cmd);\n\n\tndlc->powered = 0;\n\tndlc->ops->disable(ndlc->phy_id);\n}\nEXPORT_SYMBOL(ndlc_close);\n\nint ndlc_send(struct llt_ndlc *ndlc, struct sk_buff *skb)\n{\n\t \n\tu8 pcb = PCB_TYPE_DATAFRAME | PCB_DATAFRAME_RETRANSMIT_NO |\n\t\tPCB_FRAME_CRC_INFO_NOTPRESENT;\n\n\t*(u8 *)skb_push(skb, 1) = pcb;\n\tskb_queue_tail(&ndlc->send_q, skb);\n\n\tschedule_work(&ndlc->sm_work);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ndlc_send);\n\nstatic void llt_ndlc_send_queue(struct llt_ndlc *ndlc)\n{\n\tstruct sk_buff *skb;\n\tint r;\n\tunsigned long time_sent;\n\n\tif (ndlc->send_q.qlen)\n\t\tpr_debug(\"sendQlen=%d unackQlen=%d\\n\",\n\t\t\t ndlc->send_q.qlen, ndlc->ack_pending_q.qlen);\n\n\twhile (ndlc->send_q.qlen) {\n\t\tskb = skb_dequeue(&ndlc->send_q);\n\t\tNDLC_DUMP_SKB(\"ndlc frame written\", skb);\n\t\tr = ndlc->ops->write(ndlc->phy_id, skb);\n\t\tif (r < 0) {\n\t\t\tndlc->hard_fault = r;\n\t\t\tbreak;\n\t\t}\n\t\ttime_sent = jiffies;\n\t\t*(unsigned long *)skb->cb = time_sent;\n\n\t\tskb_queue_tail(&ndlc->ack_pending_q, skb);\n\n\t\t \n\t\tndlc->t1_active = true;\n\t\tmod_timer(&ndlc->t1_timer, time_sent +\n\t\t\tmsecs_to_jiffies(NDLC_TIMER_T1));\n\t\t \n\t\tndlc->t2_active = true;\n\t\tmod_timer(&ndlc->t2_timer, time_sent +\n\t\t\tmsecs_to_jiffies(NDLC_TIMER_T2));\n\t}\n}\n\nstatic void llt_ndlc_requeue_data_pending(struct llt_ndlc *ndlc)\n{\n\tstruct sk_buff *skb;\n\tu8 pcb;\n\n\twhile ((skb = skb_dequeue_tail(&ndlc->ack_pending_q))) {\n\t\tpcb = skb->data[0];\n\t\tswitch (pcb & PCB_TYPE_MASK) {\n\t\tcase PCB_TYPE_SUPERVISOR:\n\t\t\tskb->data[0] = (pcb & ~PCB_SUPERVISOR_RETRANSMIT_MASK) |\n\t\t\t\tPCB_SUPERVISOR_RETRANSMIT_YES;\n\t\t\tbreak;\n\t\tcase PCB_TYPE_DATAFRAME:\n\t\t\tskb->data[0] = (pcb & ~PCB_DATAFRAME_RETRANSMIT_MASK) |\n\t\t\t\tPCB_DATAFRAME_RETRANSMIT_YES;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"UNKNOWN Packet Control Byte=%d\\n\", pcb);\n\t\t\tkfree_skb(skb);\n\t\t\tcontinue;\n\t\t}\n\t\tskb_queue_head(&ndlc->send_q, skb);\n\t}\n}\n\nstatic void llt_ndlc_rcv_queue(struct llt_ndlc *ndlc)\n{\n\tstruct sk_buff *skb;\n\tu8 pcb;\n\tunsigned long time_sent;\n\n\tif (ndlc->rcv_q.qlen)\n\t\tpr_debug(\"rcvQlen=%d\\n\", ndlc->rcv_q.qlen);\n\n\twhile ((skb = skb_dequeue(&ndlc->rcv_q)) != NULL) {\n\t\tpcb = skb->data[0];\n\t\tskb_pull(skb, 1);\n\t\tif ((pcb & PCB_TYPE_MASK) == PCB_TYPE_SUPERVISOR) {\n\t\t\tswitch (pcb & PCB_SYNC_MASK) {\n\t\t\tcase PCB_SYNC_ACK:\n\t\t\t\tskb = skb_dequeue(&ndlc->ack_pending_q);\n\t\t\t\tkfree_skb(skb);\n\t\t\t\tdel_timer_sync(&ndlc->t1_timer);\n\t\t\t\tdel_timer_sync(&ndlc->t2_timer);\n\t\t\t\tndlc->t2_active = false;\n\t\t\t\tndlc->t1_active = false;\n\t\t\t\tbreak;\n\t\t\tcase PCB_SYNC_NACK:\n\t\t\t\tllt_ndlc_requeue_data_pending(ndlc);\n\t\t\t\tllt_ndlc_send_queue(ndlc);\n\t\t\t\t \n\t\t\t\ttime_sent = jiffies;\n\t\t\t\tndlc->t1_active = true;\n\t\t\t\tmod_timer(&ndlc->t1_timer, time_sent +\n\t\t\t\t\tmsecs_to_jiffies(NDLC_TIMER_T1));\n\t\t\t\tbreak;\n\t\t\tcase PCB_SYNC_WAIT:\n\t\t\t\ttime_sent = jiffies;\n\t\t\t\tndlc->t1_active = true;\n\t\t\t\tmod_timer(&ndlc->t1_timer, time_sent +\n\t\t\t\t\t  msecs_to_jiffies(NDLC_TIMER_T1_WAIT));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tkfree_skb(skb);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if ((pcb & PCB_TYPE_MASK) == PCB_TYPE_DATAFRAME) {\n\t\t\tnci_recv_frame(ndlc->ndev, skb);\n\t\t} else {\n\t\t\tkfree_skb(skb);\n\t\t}\n\t}\n}\n\nstatic void llt_ndlc_sm_work(struct work_struct *work)\n{\n\tstruct llt_ndlc *ndlc = container_of(work, struct llt_ndlc, sm_work);\n\n\tllt_ndlc_send_queue(ndlc);\n\tllt_ndlc_rcv_queue(ndlc);\n\n\tif (ndlc->t1_active && timer_pending(&ndlc->t1_timer) == 0) {\n\t\tpr_debug\n\t\t    (\"Handle T1(recv SUPERVISOR) elapsed (T1 now inactive)\\n\");\n\t\tndlc->t1_active = false;\n\n\t\tllt_ndlc_requeue_data_pending(ndlc);\n\t\tllt_ndlc_send_queue(ndlc);\n\t}\n\n\tif (ndlc->t2_active && timer_pending(&ndlc->t2_timer) == 0) {\n\t\tpr_debug(\"Handle T2(recv DATA) elapsed (T2 now inactive)\\n\");\n\t\tndlc->t2_active = false;\n\t\tndlc->t1_active = false;\n\t\tdel_timer_sync(&ndlc->t1_timer);\n\t\tdel_timer_sync(&ndlc->t2_timer);\n\t\tndlc_close(ndlc);\n\t\tndlc->hard_fault = -EREMOTEIO;\n\t}\n}\n\nvoid ndlc_recv(struct llt_ndlc *ndlc, struct sk_buff *skb)\n{\n\tif (skb == NULL) {\n\t\tpr_err(\"NULL Frame -> link is dead\\n\");\n\t\tndlc->hard_fault = -EREMOTEIO;\n\t\tndlc_close(ndlc);\n\t} else {\n\t\tNDLC_DUMP_SKB(\"incoming frame\", skb);\n\t\tskb_queue_tail(&ndlc->rcv_q, skb);\n\t}\n\n\tschedule_work(&ndlc->sm_work);\n}\nEXPORT_SYMBOL(ndlc_recv);\n\nstatic void ndlc_t1_timeout(struct timer_list *t)\n{\n\tstruct llt_ndlc *ndlc = from_timer(ndlc, t, t1_timer);\n\n\tschedule_work(&ndlc->sm_work);\n}\n\nstatic void ndlc_t2_timeout(struct timer_list *t)\n{\n\tstruct llt_ndlc *ndlc = from_timer(ndlc, t, t2_timer);\n\n\tschedule_work(&ndlc->sm_work);\n}\n\nint ndlc_probe(void *phy_id, const struct nfc_phy_ops *phy_ops,\n\t       struct device *dev, int phy_headroom, int phy_tailroom,\n\t       struct llt_ndlc **ndlc_id, struct st_nci_se_status *se_status)\n{\n\tstruct llt_ndlc *ndlc;\n\n\tndlc = devm_kzalloc(dev, sizeof(struct llt_ndlc), GFP_KERNEL);\n\tif (!ndlc)\n\t\treturn -ENOMEM;\n\n\tndlc->ops = phy_ops;\n\tndlc->phy_id = phy_id;\n\tndlc->dev = dev;\n\tndlc->powered = 0;\n\n\t*ndlc_id = ndlc;\n\n\t \n\ttimer_setup(&ndlc->t1_timer, ndlc_t1_timeout, 0);\n\ttimer_setup(&ndlc->t2_timer, ndlc_t2_timeout, 0);\n\n\tskb_queue_head_init(&ndlc->rcv_q);\n\tskb_queue_head_init(&ndlc->send_q);\n\tskb_queue_head_init(&ndlc->ack_pending_q);\n\n\tINIT_WORK(&ndlc->sm_work, llt_ndlc_sm_work);\n\n\treturn st_nci_probe(ndlc, phy_headroom, phy_tailroom, se_status);\n}\nEXPORT_SYMBOL(ndlc_probe);\n\nvoid ndlc_remove(struct llt_ndlc *ndlc)\n{\n\t \n\tdel_timer_sync(&ndlc->t1_timer);\n\tdel_timer_sync(&ndlc->t2_timer);\n\tndlc->t2_active = false;\n\tndlc->t1_active = false;\n\t \n\tcancel_work_sync(&ndlc->sm_work);\n\n\tst_nci_remove(ndlc->ndev);\n\n\tskb_queue_purge(&ndlc->rcv_q);\n\tskb_queue_purge(&ndlc->send_q);\n}\nEXPORT_SYMBOL(ndlc_remove);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}