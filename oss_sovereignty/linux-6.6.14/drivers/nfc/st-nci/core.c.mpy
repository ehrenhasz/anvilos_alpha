{
  "module_name": "core.c",
  "hash_id": "48fc2b809dac36b12bdafbc1b34ca50243e77bba6d776a192d6b63d1b4676bed",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nfc/st-nci/core.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/nfc.h>\n#include <net/nfc/nci.h>\n#include <net/nfc/nci_core.h>\n\n#include \"st-nci.h\"\n\n#define DRIVER_DESC \"NCI NFC driver for ST_NCI\"\n\n#define ST_NCI1_X_PROPRIETARY_ISO15693 0x83\n\nstatic int st_nci_init(struct nci_dev *ndev)\n{\n\tstruct nci_mode_set_cmd cmd;\n\n\tcmd.cmd_type = ST_NCI_SET_NFC_MODE;\n\tcmd.mode = 1;\n\n\treturn nci_prop_cmd(ndev, ST_NCI_CORE_PROP,\n\t\t\tsizeof(struct nci_mode_set_cmd), (__u8 *)&cmd);\n}\n\nstatic int st_nci_open(struct nci_dev *ndev)\n{\n\tstruct st_nci_info *info = nci_get_drvdata(ndev);\n\tint r;\n\n\tif (test_and_set_bit(ST_NCI_RUNNING, &info->flags))\n\t\treturn 0;\n\n\tr = ndlc_open(info->ndlc);\n\tif (r)\n\t\tclear_bit(ST_NCI_RUNNING, &info->flags);\n\n\treturn r;\n}\n\nstatic int st_nci_close(struct nci_dev *ndev)\n{\n\tstruct st_nci_info *info = nci_get_drvdata(ndev);\n\n\tif (!test_bit(ST_NCI_RUNNING, &info->flags))\n\t\treturn 0;\n\n\tndlc_close(info->ndlc);\n\n\tclear_bit(ST_NCI_RUNNING, &info->flags);\n\n\treturn 0;\n}\n\nstatic int st_nci_send(struct nci_dev *ndev, struct sk_buff *skb)\n{\n\tstruct st_nci_info *info = nci_get_drvdata(ndev);\n\n\tskb->dev = (void *)ndev;\n\n\tif (!test_bit(ST_NCI_RUNNING, &info->flags))\n\t\treturn -EBUSY;\n\n\treturn ndlc_send(info->ndlc, skb);\n}\n\nstatic __u32 st_nci_get_rfprotocol(struct nci_dev *ndev,\n\t\t\t\t\t __u8 rf_protocol)\n{\n\treturn rf_protocol == ST_NCI1_X_PROPRIETARY_ISO15693 ?\n\t\tNFC_PROTO_ISO15693_MASK : 0;\n}\n\nstatic int st_nci_prop_rsp_packet(struct nci_dev *ndev,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\t__u8 status = skb->data[0];\n\n\tnci_req_complete(ndev, status);\n\treturn 0;\n}\n\nstatic const struct nci_driver_ops st_nci_prop_ops[] = {\n\t{\n\t\t.opcode = nci_opcode_pack(NCI_GID_PROPRIETARY,\n\t\t\t\t\t  ST_NCI_CORE_PROP),\n\t\t.rsp = st_nci_prop_rsp_packet,\n\t},\n};\n\nstatic const struct nci_ops st_nci_ops = {\n\t.init = st_nci_init,\n\t.open = st_nci_open,\n\t.close = st_nci_close,\n\t.send = st_nci_send,\n\t.get_rfprotocol = st_nci_get_rfprotocol,\n\t.discover_se = st_nci_discover_se,\n\t.enable_se = st_nci_enable_se,\n\t.disable_se = st_nci_disable_se,\n\t.se_io = st_nci_se_io,\n\t.hci_load_session = st_nci_hci_load_session,\n\t.hci_event_received = st_nci_hci_event_received,\n\t.hci_cmd_received = st_nci_hci_cmd_received,\n\t.prop_ops = st_nci_prop_ops,\n\t.n_prop_ops = ARRAY_SIZE(st_nci_prop_ops),\n};\n\nint st_nci_probe(struct llt_ndlc *ndlc, int phy_headroom,\n\t\t int phy_tailroom, struct st_nci_se_status *se_status)\n{\n\tstruct st_nci_info *info;\n\tint r;\n\tu32 protocols;\n\n\tinfo = devm_kzalloc(ndlc->dev,\n\t\t\tsizeof(struct st_nci_info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tprotocols = NFC_PROTO_JEWEL_MASK\n\t\t| NFC_PROTO_MIFARE_MASK\n\t\t| NFC_PROTO_FELICA_MASK\n\t\t| NFC_PROTO_ISO14443_MASK\n\t\t| NFC_PROTO_ISO14443_B_MASK\n\t\t| NFC_PROTO_ISO15693_MASK\n\t\t| NFC_PROTO_NFC_DEP_MASK;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(st_nci_prop_ops) > NCI_MAX_PROPRIETARY_CMD);\n\tndlc->ndev = nci_allocate_device(&st_nci_ops, protocols,\n\t\t\t\t\tphy_headroom, phy_tailroom);\n\tif (!ndlc->ndev) {\n\t\tpr_err(\"Cannot allocate nfc ndev\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tinfo->ndlc = ndlc;\n\n\tnci_set_drvdata(ndlc->ndev, info);\n\n\tr = st_nci_vendor_cmds_init(ndlc->ndev);\n\tif (r) {\n\t\tpr_err(\"Cannot register proprietary vendor cmds\\n\");\n\t\tgoto err_reg_dev;\n\t}\n\n\tr = nci_register_device(ndlc->ndev);\n\tif (r) {\n\t\tpr_err(\"Cannot register nfc device to nci core\\n\");\n\t\tgoto err_reg_dev;\n\t}\n\n\treturn st_nci_se_init(ndlc->ndev, se_status);\n\nerr_reg_dev:\n\tnci_free_device(ndlc->ndev);\n\treturn r;\n}\nEXPORT_SYMBOL_GPL(st_nci_probe);\n\nvoid st_nci_remove(struct nci_dev *ndev)\n{\n\tstruct st_nci_info *info = nci_get_drvdata(ndev);\n\n\tndlc_close(info->ndlc);\n\n\tnci_unregister_device(ndev);\n\tnci_free_device(ndev);\n}\nEXPORT_SYMBOL_GPL(st_nci_remove);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(DRIVER_DESC);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}