{
  "module_name": "se.c",
  "hash_id": "6eee44cf2ff274e6af744d94b34afa801160d2d8b4eb64eb672ff88f56ac4a18",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nfc/st-nci/se.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/nfc.h>\n#include <linux/delay.h>\n#include <net/nfc/nci.h>\n#include <net/nfc/nci_core.h>\n\n#include \"st-nci.h\"\n\nstruct st_nci_pipe_info {\n\tu8 pipe_state;\n\tu8 src_host_id;\n\tu8 src_gate_id;\n\tu8 dst_host_id;\n\tu8 dst_gate_id;\n} __packed;\n\n \n#define ST_NCI_HOST_CONTROLLER_ID     0x00\n#define ST_NCI_TERMINAL_HOST_ID       0x01\n#define ST_NCI_UICC_HOST_ID           0x02\n#define ST_NCI_ESE_HOST_ID            0xc0\n\n \n#define ST_NCI_APDU_READER_GATE       0xf0\n#define ST_NCI_CONNECTIVITY_GATE      0x41\n\n \n#define ST_NCI_DEVICE_MGNT_PIPE               0x02\n\n \n#define ST_NCI_SE_COUNT_PIPE_UICC             0x01\n \n#define ST_NCI_SE_COUNT_PIPE_EMBEDDED         0x02\n\n#define ST_NCI_SE_TO_HOT_PLUG\t\t\t1000  \n#define ST_NCI_SE_TO_PIPES\t\t\t2000\n\n#define ST_NCI_EVT_HOT_PLUG_IS_INHIBITED(x)   (x->data[0] & 0x80)\n\n#define NCI_HCI_APDU_PARAM_ATR                     0x01\n#define NCI_HCI_ADMIN_PARAM_SESSION_IDENTITY       0x01\n#define NCI_HCI_ADMIN_PARAM_WHITELIST              0x03\n#define NCI_HCI_ADMIN_PARAM_HOST_LIST              0x04\n\n#define ST_NCI_EVT_SE_HARD_RESET\t\t0x20\n#define ST_NCI_EVT_TRANSMIT_DATA\t\t0x10\n#define ST_NCI_EVT_WTX_REQUEST\t\t\t0x11\n#define ST_NCI_EVT_SE_SOFT_RESET\t\t0x11\n#define ST_NCI_EVT_SE_END_OF_APDU_TRANSFER\t0x21\n#define ST_NCI_EVT_HOT_PLUG\t\t\t0x03\n\n#define ST_NCI_SE_MODE_OFF                    0x00\n#define ST_NCI_SE_MODE_ON                     0x01\n\n#define ST_NCI_EVT_CONNECTIVITY       0x10\n#define ST_NCI_EVT_TRANSACTION        0x12\n\n#define ST_NCI_DM_GETINFO             0x13\n#define ST_NCI_DM_GETINFO_PIPE_LIST   0x02\n#define ST_NCI_DM_GETINFO_PIPE_INFO   0x01\n#define ST_NCI_DM_PIPE_CREATED        0x02\n#define ST_NCI_DM_PIPE_OPEN           0x04\n#define ST_NCI_DM_RF_ACTIVE           0x80\n#define ST_NCI_DM_DISCONNECT          0x30\n\n#define ST_NCI_DM_IS_PIPE_OPEN(p) \\\n\t((p & 0x0f) == (ST_NCI_DM_PIPE_CREATED | ST_NCI_DM_PIPE_OPEN))\n\n#define ST_NCI_ATR_DEFAULT_BWI        0x04\n\n \n#define ST_NCI_BWI_TO_TIMEOUT(x)      ((1 << x) * 200)\n#define ST_NCI_ATR_GET_Y_FROM_TD(x)   (x >> 4)\n\n \n#define ST_NCI_ATR_TA_PRESENT(x) (x & 0x01)\n \n#define ST_NCI_ATR_TB_PRESENT(x) (x & 0x02)\n\n#define ST_NCI_NUM_DEVICES           256\n\nstatic DECLARE_BITMAP(dev_mask, ST_NCI_NUM_DEVICES);\n\n \nstatic struct nci_hci_gate st_nci_gates[] = {\n\t{NCI_HCI_ADMIN_GATE, NCI_HCI_ADMIN_PIPE,\n\t\t\t\t\tST_NCI_HOST_CONTROLLER_ID},\n\t{NCI_HCI_LINK_MGMT_GATE, NCI_HCI_LINK_MGMT_PIPE,\n\t\t\t\t\tST_NCI_HOST_CONTROLLER_ID},\n\t{ST_NCI_DEVICE_MGNT_GATE, ST_NCI_DEVICE_MGNT_PIPE,\n\t\t\t\t\tST_NCI_HOST_CONTROLLER_ID},\n\n\t{NCI_HCI_IDENTITY_MGMT_GATE, NCI_HCI_INVALID_PIPE,\n\t\t\t\t\tST_NCI_HOST_CONTROLLER_ID},\n\n\t \n\t{ST_NCI_CONNECTIVITY_GATE, NCI_HCI_DO_NOT_OPEN_PIPE,\n\t\t\t\t\tST_NCI_HOST_CONTROLLER_ID},\n\t{ST_NCI_APDU_READER_GATE, NCI_HCI_DO_NOT_OPEN_PIPE,\n\t\t\t\t\tST_NCI_HOST_CONTROLLER_ID},\n};\n\nstatic u8 st_nci_se_get_bwi(struct nci_dev *ndev)\n{\n\tint i;\n\tu8 td;\n\tstruct st_nci_info *info = nci_get_drvdata(ndev);\n\n\t \n\tfor (i = 1; i < ST_NCI_ESE_MAX_LENGTH; i++) {\n\t\ttd = ST_NCI_ATR_GET_Y_FROM_TD(info->se_info.atr[i]);\n\t\tif (ST_NCI_ATR_TA_PRESENT(td))\n\t\t\ti++;\n\t\tif (ST_NCI_ATR_TB_PRESENT(td)) {\n\t\t\ti++;\n\t\t\treturn info->se_info.atr[i] >> 4;\n\t\t}\n\t}\n\treturn ST_NCI_ATR_DEFAULT_BWI;\n}\n\nstatic void st_nci_se_get_atr(struct nci_dev *ndev)\n{\n\tstruct st_nci_info *info = nci_get_drvdata(ndev);\n\tint r;\n\tstruct sk_buff *skb;\n\n\tr = nci_hci_get_param(ndev, ST_NCI_APDU_READER_GATE,\n\t\t\t\tNCI_HCI_APDU_PARAM_ATR, &skb);\n\tif (r < 0)\n\t\treturn;\n\n\tif (skb->len <= ST_NCI_ESE_MAX_LENGTH) {\n\t\tmemcpy(info->se_info.atr, skb->data, skb->len);\n\n\t\tinfo->se_info.wt_timeout =\n\t\t\tST_NCI_BWI_TO_TIMEOUT(st_nci_se_get_bwi(ndev));\n\t}\n\tkfree_skb(skb);\n}\n\nint st_nci_hci_load_session(struct nci_dev *ndev)\n{\n\tint i, j, r;\n\tstruct sk_buff *skb_pipe_list, *skb_pipe_info;\n\tstruct st_nci_pipe_info *dm_pipe_info;\n\tu8 pipe_list[] = { ST_NCI_DM_GETINFO_PIPE_LIST,\n\t\t\tST_NCI_TERMINAL_HOST_ID};\n\tu8 pipe_info[] = { ST_NCI_DM_GETINFO_PIPE_INFO,\n\t\t\tST_NCI_TERMINAL_HOST_ID, 0};\n\n\t \n\tr = nci_hci_connect_gate(ndev, ST_NCI_HOST_CONTROLLER_ID,\n\t\t\t\tST_NCI_DEVICE_MGNT_GATE,\n\t\t\t\tST_NCI_DEVICE_MGNT_PIPE);\n\tif (r < 0)\n\t\treturn r;\n\n\t \n\tr = nci_hci_send_cmd(ndev, ST_NCI_DEVICE_MGNT_GATE,\n\t\t\tST_NCI_DM_GETINFO, pipe_list, sizeof(pipe_list),\n\t\t\t&skb_pipe_list);\n\tif (r < 0)\n\t\treturn r;\n\n\t \n\tfor (i = 0; i < skb_pipe_list->len; i++) {\n\t\tpipe_info[2] = skb_pipe_list->data[i];\n\t\tr = nci_hci_send_cmd(ndev, ST_NCI_DEVICE_MGNT_GATE,\n\t\t\t\t\tST_NCI_DM_GETINFO, pipe_info,\n\t\t\t\t\tsizeof(pipe_info), &skb_pipe_info);\n\n\t\tif (r)\n\t\t\tcontinue;\n\n\t\t \n\t\tdm_pipe_info = (struct st_nci_pipe_info *)skb_pipe_info->data;\n\t\tif (dm_pipe_info->dst_gate_id == ST_NCI_APDU_READER_GATE &&\n\t\t    dm_pipe_info->src_host_id == ST_NCI_UICC_HOST_ID) {\n\t\t\tpr_err(\"Unexpected apdu_reader pipe on host %x\\n\",\n\t\t\t       dm_pipe_info->src_host_id);\n\t\t\tkfree_skb(skb_pipe_info);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (j = 3; (j < ARRAY_SIZE(st_nci_gates)) &&\n\t\t     (st_nci_gates[j].gate != dm_pipe_info->dst_gate_id); j++)\n\t\t\t;\n\n\t\tif (j < ARRAY_SIZE(st_nci_gates) &&\n\t\t    st_nci_gates[j].gate == dm_pipe_info->dst_gate_id &&\n\t\t    ST_NCI_DM_IS_PIPE_OPEN(dm_pipe_info->pipe_state)) {\n\t\t\tndev->hci_dev->init_data.gates[j].pipe = pipe_info[2];\n\n\t\t\tndev->hci_dev->gate2pipe[st_nci_gates[j].gate] =\n\t\t\t\t\t\tpipe_info[2];\n\t\t\tndev->hci_dev->pipes[pipe_info[2]].gate =\n\t\t\t\t\t\tst_nci_gates[j].gate;\n\t\t\tndev->hci_dev->pipes[pipe_info[2]].host =\n\t\t\t\t\t\tdm_pipe_info->src_host_id;\n\t\t}\n\t\tkfree_skb(skb_pipe_info);\n\t}\n\n\t \n\tr = nci_hci_connect_gate(ndev, ST_NCI_HOST_CONTROLLER_ID,\n\t\t\t\t NCI_HCI_LINK_MGMT_GATE,\n\t\t\t\t NCI_HCI_LINK_MGMT_PIPE);\n\n\tkfree_skb(skb_pipe_list);\n\treturn r;\n}\nEXPORT_SYMBOL_GPL(st_nci_hci_load_session);\n\nstatic void st_nci_hci_admin_event_received(struct nci_dev *ndev,\n\t\t\t\t\t      u8 event, struct sk_buff *skb)\n{\n\tstruct st_nci_info *info = nci_get_drvdata(ndev);\n\n\tswitch (event) {\n\tcase ST_NCI_EVT_HOT_PLUG:\n\t\tif (info->se_info.se_active) {\n\t\t\tif (!ST_NCI_EVT_HOT_PLUG_IS_INHIBITED(skb)) {\n\t\t\t\tdel_timer_sync(&info->se_info.se_active_timer);\n\t\t\t\tinfo->se_info.se_active = false;\n\t\t\t\tcomplete(&info->se_info.req_completion);\n\t\t\t} else {\n\t\t\t\tmod_timer(&info->se_info.se_active_timer,\n\t\t\t\t      jiffies +\n\t\t\t\t      msecs_to_jiffies(ST_NCI_SE_TO_PIPES));\n\t\t\t}\n\t\t}\n\tbreak;\n\tdefault:\n\t\tnfc_err(&ndev->nfc_dev->dev, \"Unexpected event on admin gate\\n\");\n\t}\n}\n\nstatic int st_nci_hci_apdu_reader_event_received(struct nci_dev *ndev,\n\t\t\t\t\t\t   u8 event,\n\t\t\t\t\t\t   struct sk_buff *skb)\n{\n\tstruct st_nci_info *info = nci_get_drvdata(ndev);\n\n\tpr_debug(\"apdu reader gate event: %x\\n\", event);\n\n\tswitch (event) {\n\tcase ST_NCI_EVT_TRANSMIT_DATA:\n\t\tdel_timer_sync(&info->se_info.bwi_timer);\n\t\tinfo->se_info.bwi_active = false;\n\t\tinfo->se_info.cb(info->se_info.cb_context,\n\t\t\t\t skb->data, skb->len, 0);\n\tbreak;\n\tcase ST_NCI_EVT_WTX_REQUEST:\n\t\tmod_timer(&info->se_info.bwi_timer, jiffies +\n\t\t\t  msecs_to_jiffies(info->se_info.wt_timeout));\n\tbreak;\n\tdefault:\n\t\tnfc_err(&ndev->nfc_dev->dev, \"Unexpected event on apdu reader gate\\n\");\n\t\treturn 1;\n\t}\n\n\tkfree_skb(skb);\n\treturn 0;\n}\n\n \nstatic int st_nci_hci_connectivity_event_received(struct nci_dev *ndev,\n\t\t\t\t\t\tu8 host, u8 event,\n\t\t\t\t\t\tstruct sk_buff *skb)\n{\n\tint r = 0;\n\tstruct device *dev = &ndev->nfc_dev->dev;\n\tstruct nfc_evt_transaction *transaction;\n\tu32 aid_len;\n\tu8 params_len;\n\n\tpr_debug(\"connectivity gate event: %x\\n\", event);\n\n\tswitch (event) {\n\tcase ST_NCI_EVT_CONNECTIVITY:\n\t\tr = nfc_se_connectivity(ndev->nfc_dev, host);\n\tbreak;\n\tcase ST_NCI_EVT_TRANSACTION:\n\t\t \n\t\tif (skb->len < 2 || skb->data[0] != NFC_EVT_TRANSACTION_AID_TAG)\n\t\t\treturn -EPROTO;\n\n\t\taid_len = skb->data[1];\n\n\t\tif (skb->len < aid_len + 4 ||\n\t\t    aid_len > sizeof(transaction->aid))\n\t\t\treturn -EPROTO;\n\n\t\tparams_len = skb->data[aid_len + 3];\n\n\t\t \n\t\tif (skb->data[aid_len + 2] != NFC_EVT_TRANSACTION_PARAMS_TAG ||\n\t\t    skb->len < aid_len + 4 + params_len)\n\t\t\treturn -EPROTO;\n\n\t\ttransaction = devm_kzalloc(dev, sizeof(*transaction) +\n\t\t\t\t\t   params_len, GFP_KERNEL);\n\t\tif (!transaction)\n\t\t\treturn -ENOMEM;\n\n\t\ttransaction->aid_len = aid_len;\n\t\ttransaction->params_len = params_len;\n\n\t\tmemcpy(transaction->aid, &skb->data[2], aid_len);\n\t\tmemcpy(transaction->params, &skb->data[aid_len + 4],\n\t\t       params_len);\n\n\t\tr = nfc_se_transaction(ndev->nfc_dev, host, transaction);\n\t\tbreak;\n\tdefault:\n\t\tnfc_err(&ndev->nfc_dev->dev, \"Unexpected event on connectivity gate\\n\");\n\t\treturn 1;\n\t}\n\tkfree_skb(skb);\n\treturn r;\n}\n\nvoid st_nci_hci_event_received(struct nci_dev *ndev, u8 pipe,\n\t\t\t\t u8 event, struct sk_buff *skb)\n{\n\tu8 gate = ndev->hci_dev->pipes[pipe].gate;\n\tu8 host = ndev->hci_dev->pipes[pipe].host;\n\n\tswitch (gate) {\n\tcase NCI_HCI_ADMIN_GATE:\n\t\tst_nci_hci_admin_event_received(ndev, event, skb);\n\tbreak;\n\tcase ST_NCI_APDU_READER_GATE:\n\t\tst_nci_hci_apdu_reader_event_received(ndev, event, skb);\n\tbreak;\n\tcase ST_NCI_CONNECTIVITY_GATE:\n\t\tst_nci_hci_connectivity_event_received(ndev, host, event, skb);\n\tbreak;\n\t}\n}\nEXPORT_SYMBOL_GPL(st_nci_hci_event_received);\n\nvoid st_nci_hci_cmd_received(struct nci_dev *ndev, u8 pipe, u8 cmd,\n\t\t\t       struct sk_buff *skb)\n{\n\tstruct st_nci_info *info = nci_get_drvdata(ndev);\n\tu8 gate = ndev->hci_dev->pipes[pipe].gate;\n\n\tpr_debug(\"cmd: %x\\n\", cmd);\n\n\tswitch (cmd) {\n\tcase NCI_HCI_ANY_OPEN_PIPE:\n\t\tif (gate != ST_NCI_APDU_READER_GATE &&\n\t\t    ndev->hci_dev->pipes[pipe].host != ST_NCI_UICC_HOST_ID)\n\t\t\tndev->hci_dev->count_pipes++;\n\n\t\tif (ndev->hci_dev->count_pipes ==\n\t\t    ndev->hci_dev->expected_pipes) {\n\t\t\tdel_timer_sync(&info->se_info.se_active_timer);\n\t\t\tinfo->se_info.se_active = false;\n\t\t\tndev->hci_dev->count_pipes = 0;\n\t\t\tcomplete(&info->se_info.req_completion);\n\t\t}\n\tbreak;\n\t}\n}\nEXPORT_SYMBOL_GPL(st_nci_hci_cmd_received);\n\nstatic int st_nci_control_se(struct nci_dev *ndev, u8 se_idx,\n\t\t\t     u8 state)\n{\n\tstruct st_nci_info *info = nci_get_drvdata(ndev);\n\tint r, i;\n\tstruct sk_buff *sk_host_list;\n\tu8 host_id;\n\n\tswitch (se_idx) {\n\tcase ST_NCI_UICC_HOST_ID:\n\t\tndev->hci_dev->count_pipes = 0;\n\t\tndev->hci_dev->expected_pipes = ST_NCI_SE_COUNT_PIPE_UICC;\n\t\tbreak;\n\tcase ST_NCI_ESE_HOST_ID:\n\t\tndev->hci_dev->count_pipes = 0;\n\t\tndev->hci_dev->expected_pipes = ST_NCI_SE_COUNT_PIPE_EMBEDDED;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\treinit_completion(&info->se_info.req_completion);\n\tr = nci_nfcee_mode_set(ndev, se_idx, state);\n\tif (r != NCI_STATUS_OK)\n\t\treturn r;\n\n\tmod_timer(&info->se_info.se_active_timer, jiffies +\n\t\tmsecs_to_jiffies(ST_NCI_SE_TO_HOT_PLUG));\n\tinfo->se_info.se_active = true;\n\n\t \n\twait_for_completion_interruptible(&info->se_info.req_completion);\n\n\t \n\tif (info->se_info.se_status->is_ese_present &&\n\t    info->se_info.se_status->is_uicc_present)\n\t\tusleep_range(15000, 20000);\n\n\tr = nci_hci_get_param(ndev, NCI_HCI_ADMIN_GATE,\n\t\t\tNCI_HCI_ADMIN_PARAM_HOST_LIST, &sk_host_list);\n\tif (r != NCI_HCI_ANY_OK)\n\t\treturn r;\n\n\tfor (i = 0; i < sk_host_list->len &&\n\t\tsk_host_list->data[i] != se_idx; i++)\n\t\t;\n\thost_id = sk_host_list->data[i];\n\tkfree_skb(sk_host_list);\n\tif (state == ST_NCI_SE_MODE_ON && host_id == se_idx)\n\t\treturn se_idx;\n\telse if (state == ST_NCI_SE_MODE_OFF && host_id != se_idx)\n\t\treturn se_idx;\n\n\treturn -1;\n}\n\nint st_nci_disable_se(struct nci_dev *ndev, u32 se_idx)\n{\n\tint r;\n\n\t \n\tr = st_nci_control_se(ndev, se_idx, ST_NCI_SE_MODE_OFF);\n\tif (r < 0) {\n\t\t \n\t\tif (se_idx == NFC_SE_EMBEDDED) {\n\t\t\tr = nci_hci_send_event(ndev, ST_NCI_APDU_READER_GATE,\n\t\t\t\t\tST_NCI_EVT_SE_END_OF_APDU_TRANSFER,\n\t\t\t\t\tNULL, 0);\n\t\t}\n\t\treturn r;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(st_nci_disable_se);\n\nint st_nci_enable_se(struct nci_dev *ndev, u32 se_idx)\n{\n\tint r;\n\n\t \n\tr = st_nci_control_se(ndev, se_idx, ST_NCI_SE_MODE_ON);\n\tif (r == ST_NCI_ESE_HOST_ID) {\n\t\tst_nci_se_get_atr(ndev);\n\t\tr = nci_hci_send_event(ndev, ST_NCI_APDU_READER_GATE,\n\t\t\t\tST_NCI_EVT_SE_SOFT_RESET, NULL, 0);\n\t}\n\n\tif (r < 0) {\n\t\t \n\t\tnfc_remove_se(ndev->nfc_dev, se_idx);\n\t\treturn r;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(st_nci_enable_se);\n\nstatic int st_nci_hci_network_init(struct nci_dev *ndev)\n{\n\tstruct st_nci_info *info = nci_get_drvdata(ndev);\n\tstruct core_conn_create_dest_spec_params *dest_params;\n\tstruct dest_spec_params spec_params;\n\tstruct nci_conn_info    *conn_info;\n\tint r, dev_num;\n\n\tdest_params =\n\t\tkzalloc(sizeof(struct core_conn_create_dest_spec_params) +\n\t\t\tsizeof(struct dest_spec_params), GFP_KERNEL);\n\tif (dest_params == NULL)\n\t\treturn -ENOMEM;\n\n\tdest_params->type = NCI_DESTINATION_SPECIFIC_PARAM_NFCEE_TYPE;\n\tdest_params->length = sizeof(struct dest_spec_params);\n\tspec_params.id = ndev->hci_dev->nfcee_id;\n\tspec_params.protocol = NCI_NFCEE_INTERFACE_HCI_ACCESS;\n\tmemcpy(dest_params->value, &spec_params,\n\t       sizeof(struct dest_spec_params));\n\tr = nci_core_conn_create(ndev, NCI_DESTINATION_NFCEE, 1,\n\t\t\t\t sizeof(struct core_conn_create_dest_spec_params) +\n\t\t\t\t sizeof(struct dest_spec_params),\n\t\t\t\t dest_params);\n\tif (r != NCI_STATUS_OK)\n\t\tgoto free_dest_params;\n\n\tconn_info = ndev->hci_dev->conn_info;\n\tif (!conn_info)\n\t\tgoto free_dest_params;\n\n\tndev->hci_dev->init_data.gate_count = ARRAY_SIZE(st_nci_gates);\n\tmemcpy(ndev->hci_dev->init_data.gates, st_nci_gates,\n\t       sizeof(st_nci_gates));\n\n\t \n\tdev_num = find_first_zero_bit(dev_mask, ST_NCI_NUM_DEVICES);\n\tif (dev_num >= ST_NCI_NUM_DEVICES) {\n\t\tr = -ENODEV;\n\t\tgoto free_dest_params;\n\t}\n\n\tscnprintf(ndev->hci_dev->init_data.session_id,\n\t\t  sizeof(ndev->hci_dev->init_data.session_id),\n\t\t  \"%s%2x\", \"ST21BH\", dev_num);\n\n\tr = nci_hci_dev_session_init(ndev);\n\tif (r != NCI_HCI_ANY_OK)\n\t\tgoto free_dest_params;\n\n\t \n\tif (test_bit(ST_NCI_FACTORY_MODE, &info->flags))\n\t\tr = nci_nfcee_mode_set(ndev,\n\t\t\t\t       ndev->hci_dev->conn_info->dest_params->id,\n\t\t\t\t       NCI_NFCEE_DISABLE);\n\telse\n\t\tr = nci_nfcee_mode_set(ndev,\n\t\t\t\t       ndev->hci_dev->conn_info->dest_params->id,\n\t\t\t\t       NCI_NFCEE_ENABLE);\n\nfree_dest_params:\n\tkfree(dest_params);\n\treturn r;\n}\n\nint st_nci_discover_se(struct nci_dev *ndev)\n{\n\tu8 white_list[2];\n\tint r, wl_size = 0;\n\tint se_count = 0;\n\tstruct st_nci_info *info = nci_get_drvdata(ndev);\n\n\tr = st_nci_hci_network_init(ndev);\n\tif (r != 0)\n\t\treturn r;\n\n\tif (test_bit(ST_NCI_FACTORY_MODE, &info->flags))\n\t\treturn 0;\n\n\tif (info->se_info.se_status->is_uicc_present)\n\t\twhite_list[wl_size++] = ST_NCI_UICC_HOST_ID;\n\tif (info->se_info.se_status->is_ese_present)\n\t\twhite_list[wl_size++] = ST_NCI_ESE_HOST_ID;\n\n\tif (wl_size) {\n\t\tr = nci_hci_set_param(ndev, NCI_HCI_ADMIN_GATE,\n\t\t\t\t      NCI_HCI_ADMIN_PARAM_WHITELIST,\n\t\t\t\t      white_list, wl_size);\n\t\tif (r != NCI_HCI_ANY_OK)\n\t\t\treturn r;\n\t}\n\n\tif (info->se_info.se_status->is_uicc_present) {\n\t\tnfc_add_se(ndev->nfc_dev, ST_NCI_UICC_HOST_ID, NFC_SE_UICC);\n\t\tse_count++;\n\t}\n\n\tif (info->se_info.se_status->is_ese_present) {\n\t\tnfc_add_se(ndev->nfc_dev, ST_NCI_ESE_HOST_ID, NFC_SE_EMBEDDED);\n\t\tse_count++;\n\t}\n\n\treturn !se_count;\n}\nEXPORT_SYMBOL_GPL(st_nci_discover_se);\n\nint st_nci_se_io(struct nci_dev *ndev, u32 se_idx,\n\t\t       u8 *apdu, size_t apdu_length,\n\t\t       se_io_cb_t cb, void *cb_context)\n{\n\tstruct st_nci_info *info = nci_get_drvdata(ndev);\n\n\tswitch (se_idx) {\n\tcase ST_NCI_ESE_HOST_ID:\n\t\tinfo->se_info.cb = cb;\n\t\tinfo->se_info.cb_context = cb_context;\n\t\tmod_timer(&info->se_info.bwi_timer, jiffies +\n\t\t\t  msecs_to_jiffies(info->se_info.wt_timeout));\n\t\tinfo->se_info.bwi_active = true;\n\t\treturn nci_hci_send_event(ndev, ST_NCI_APDU_READER_GATE,\n\t\t\t\t\tST_NCI_EVT_TRANSMIT_DATA, apdu,\n\t\t\t\t\tapdu_length);\n\tdefault:\n\t\t \n\t\tkfree(cb_context);\n\t\treturn -ENODEV;\n\t}\n}\nEXPORT_SYMBOL(st_nci_se_io);\n\nstatic void st_nci_se_wt_timeout(struct timer_list *t)\n{\n\t \n\t \n\tu8 param = 0x01;\n\tstruct st_nci_info *info = from_timer(info, t, se_info.bwi_timer);\n\n\tinfo->se_info.bwi_active = false;\n\n\tif (!info->se_info.xch_error) {\n\t\tinfo->se_info.xch_error = true;\n\t\tnci_hci_send_event(info->ndlc->ndev, ST_NCI_APDU_READER_GATE,\n\t\t\t\tST_NCI_EVT_SE_SOFT_RESET, NULL, 0);\n\t} else {\n\t\tinfo->se_info.xch_error = false;\n\t\tnci_hci_send_event(info->ndlc->ndev, ST_NCI_DEVICE_MGNT_GATE,\n\t\t\t\tST_NCI_EVT_SE_HARD_RESET, &param, 1);\n\t}\n\tinfo->se_info.cb(info->se_info.cb_context, NULL, 0, -ETIME);\n}\n\nstatic void st_nci_se_activation_timeout(struct timer_list *t)\n{\n\tstruct st_nci_info *info = from_timer(info, t,\n\t\t\t\t\t      se_info.se_active_timer);\n\n\tinfo->se_info.se_active = false;\n\n\tcomplete(&info->se_info.req_completion);\n}\n\nint st_nci_se_init(struct nci_dev *ndev, struct st_nci_se_status *se_status)\n{\n\tstruct st_nci_info *info = nci_get_drvdata(ndev);\n\n\tinit_completion(&info->se_info.req_completion);\n\t \n\ttimer_setup(&info->se_info.bwi_timer, st_nci_se_wt_timeout, 0);\n\tinfo->se_info.bwi_active = false;\n\n\ttimer_setup(&info->se_info.se_active_timer,\n\t\t    st_nci_se_activation_timeout, 0);\n\tinfo->se_info.se_active = false;\n\n\tinfo->se_info.xch_error = false;\n\n\tinfo->se_info.wt_timeout =\n\t\tST_NCI_BWI_TO_TIMEOUT(ST_NCI_ATR_DEFAULT_BWI);\n\n\tinfo->se_info.se_status = se_status;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(st_nci_se_init);\n\nvoid st_nci_se_deinit(struct nci_dev *ndev)\n{\n\tstruct st_nci_info *info = nci_get_drvdata(ndev);\n\n\tif (info->se_info.bwi_active)\n\t\tdel_timer_sync(&info->se_info.bwi_timer);\n\tif (info->se_info.se_active)\n\t\tdel_timer_sync(&info->se_info.se_active_timer);\n\n\tinfo->se_info.se_active = false;\n\tinfo->se_info.bwi_active = false;\n}\nEXPORT_SYMBOL(st_nci_se_deinit);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}