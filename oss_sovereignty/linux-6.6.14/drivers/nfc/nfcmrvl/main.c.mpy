{
  "module_name": "main.c",
  "hash_id": "0fa6d8af6403d6b12f8e3992a534e0cbbb4e0ab5242c455322656b2c4f43e0a7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nfc/nfcmrvl/main.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/gpio.h>\n#include <linux/delay.h>\n#include <linux/of_gpio.h>\n#include <linux/nfc.h>\n#include <net/nfc/nci.h>\n#include <net/nfc/nci_core.h>\n#include \"nfcmrvl.h\"\n\nstatic int nfcmrvl_nci_open(struct nci_dev *ndev)\n{\n\tstruct nfcmrvl_private *priv = nci_get_drvdata(ndev);\n\tint err;\n\n\tif (test_and_set_bit(NFCMRVL_NCI_RUNNING, &priv->flags))\n\t\treturn 0;\n\n\t \n\tclear_bit(NFCMRVL_PHY_ERROR, &priv->flags);\n\n\terr = priv->if_ops->nci_open(priv);\n\n\tif (err)\n\t\tclear_bit(NFCMRVL_NCI_RUNNING, &priv->flags);\n\n\treturn err;\n}\n\nstatic int nfcmrvl_nci_close(struct nci_dev *ndev)\n{\n\tstruct nfcmrvl_private *priv = nci_get_drvdata(ndev);\n\n\tif (!test_and_clear_bit(NFCMRVL_NCI_RUNNING, &priv->flags))\n\t\treturn 0;\n\n\tpriv->if_ops->nci_close(priv);\n\n\treturn 0;\n}\n\nstatic int nfcmrvl_nci_send(struct nci_dev *ndev, struct sk_buff *skb)\n{\n\tstruct nfcmrvl_private *priv = nci_get_drvdata(ndev);\n\n\tnfc_info(priv->dev, \"send entry, len %d\\n\", skb->len);\n\n\tskb->dev = (void *)ndev;\n\n\tif (priv->config.hci_muxed) {\n\t\tunsigned char *hdr;\n\t\tunsigned char len = skb->len;\n\n\t\thdr = skb_push(skb, NFCMRVL_HCI_EVENT_HEADER_SIZE);\n\t\thdr[0] = NFCMRVL_HCI_COMMAND_CODE;\n\t\thdr[1] = NFCMRVL_HCI_OGF;\n\t\thdr[2] = NFCMRVL_HCI_OCF;\n\t\thdr[3] = len;\n\t}\n\n\treturn priv->if_ops->nci_send(priv, skb);\n}\n\nstatic int nfcmrvl_nci_setup(struct nci_dev *ndev)\n{\n\t__u8 val = 1;\n\n\tnci_set_config(ndev, NFCMRVL_PB_BAIL_OUT, 1, &val);\n\treturn 0;\n}\n\nstatic int nfcmrvl_nci_fw_download(struct nci_dev *ndev,\n\t\t\t\t   const char *firmware_name)\n{\n\treturn nfcmrvl_fw_dnld_start(ndev, firmware_name);\n}\n\nstatic const struct nci_ops nfcmrvl_nci_ops = {\n\t.open = nfcmrvl_nci_open,\n\t.close = nfcmrvl_nci_close,\n\t.send = nfcmrvl_nci_send,\n\t.setup = nfcmrvl_nci_setup,\n\t.fw_download = nfcmrvl_nci_fw_download,\n};\n\nstruct nfcmrvl_private *nfcmrvl_nci_register_dev(enum nfcmrvl_phy phy,\n\t\t\t\tvoid *drv_data,\n\t\t\t\tconst struct nfcmrvl_if_ops *ops,\n\t\t\t\tstruct device *dev,\n\t\t\t\tconst struct nfcmrvl_platform_data *pdata)\n{\n\tstruct nfcmrvl_private *priv;\n\tint rc;\n\tint headroom;\n\tint tailroom;\n\tu32 protocols;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpriv->drv_data = drv_data;\n\tpriv->if_ops = ops;\n\tpriv->dev = dev;\n\tpriv->phy = phy;\n\n\tmemcpy(&priv->config, pdata, sizeof(*pdata));\n\n\tif (gpio_is_valid(priv->config.reset_n_io)) {\n\t\trc = gpio_request_one(priv->config.reset_n_io,\n\t\t\t\t      GPIOF_OUT_INIT_LOW,\n\t\t\t\t      \"nfcmrvl_reset_n\");\n\t\tif (rc < 0) {\n\t\t\tpriv->config.reset_n_io = -EINVAL;\n\t\t\tnfc_err(dev, \"failed to request reset_n io\\n\");\n\t\t}\n\t}\n\n\tif (phy == NFCMRVL_PHY_SPI) {\n\t\theadroom = NCI_SPI_HDR_LEN;\n\t\ttailroom = 1;\n\t} else\n\t\theadroom = tailroom = 0;\n\n\tif (priv->config.hci_muxed)\n\t\theadroom += NFCMRVL_HCI_EVENT_HEADER_SIZE;\n\n\tprotocols = NFC_PROTO_JEWEL_MASK\n\t\t| NFC_PROTO_MIFARE_MASK\n\t\t| NFC_PROTO_FELICA_MASK\n\t\t| NFC_PROTO_ISO14443_MASK\n\t\t| NFC_PROTO_ISO14443_B_MASK\n\t\t| NFC_PROTO_ISO15693_MASK\n\t\t| NFC_PROTO_NFC_DEP_MASK;\n\n\tpriv->ndev = nci_allocate_device(&nfcmrvl_nci_ops, protocols,\n\t\t\t\t\t headroom, tailroom);\n\tif (!priv->ndev) {\n\t\tnfc_err(dev, \"nci_allocate_device failed\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto error_free_gpio;\n\t}\n\n\trc = nfcmrvl_fw_dnld_init(priv);\n\tif (rc) {\n\t\tnfc_err(dev, \"failed to initialize FW download %d\\n\", rc);\n\t\tgoto error_free_dev;\n\t}\n\n\tnci_set_drvdata(priv->ndev, priv);\n\n\trc = nci_register_device(priv->ndev);\n\tif (rc) {\n\t\tnfc_err(dev, \"nci_register_device failed %d\\n\", rc);\n\t\tgoto error_fw_dnld_deinit;\n\t}\n\n\t \n\tnfcmrvl_chip_halt(priv);\n\n\tnfc_info(dev, \"registered with nci successfully\\n\");\n\treturn priv;\n\nerror_fw_dnld_deinit:\n\tnfcmrvl_fw_dnld_deinit(priv);\nerror_free_dev:\n\tnci_free_device(priv->ndev);\nerror_free_gpio:\n\tif (gpio_is_valid(priv->config.reset_n_io))\n\t\tgpio_free(priv->config.reset_n_io);\n\tkfree(priv);\n\treturn ERR_PTR(rc);\n}\nEXPORT_SYMBOL_GPL(nfcmrvl_nci_register_dev);\n\nvoid nfcmrvl_nci_unregister_dev(struct nfcmrvl_private *priv)\n{\n\tstruct nci_dev *ndev = priv->ndev;\n\n\tnci_unregister_device(ndev);\n\tif (priv->ndev->nfc_dev->fw_download_in_progress)\n\t\tnfcmrvl_fw_dnld_abort(priv);\n\n\tnfcmrvl_fw_dnld_deinit(priv);\n\n\tif (gpio_is_valid(priv->config.reset_n_io))\n\t\tgpio_free(priv->config.reset_n_io);\n\n\tnci_free_device(ndev);\n\tkfree(priv);\n}\nEXPORT_SYMBOL_GPL(nfcmrvl_nci_unregister_dev);\n\nint nfcmrvl_nci_recv_frame(struct nfcmrvl_private *priv, struct sk_buff *skb)\n{\n\tif (priv->config.hci_muxed) {\n\t\tif (skb->data[0] == NFCMRVL_HCI_EVENT_CODE &&\n\t\t    skb->data[1] == NFCMRVL_HCI_NFC_EVENT_CODE) {\n\t\t\t \n\t\t\tskb_pull(skb, NFCMRVL_HCI_EVENT_HEADER_SIZE);\n\t\t} else {\n\t\t\t \n\t\t\tkfree_skb(skb);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (priv->ndev->nfc_dev->fw_download_in_progress) {\n\t\tnfcmrvl_fw_dnld_recv_frame(priv, skb);\n\t\treturn 0;\n\t}\n\n\tif (test_bit(NFCMRVL_NCI_RUNNING, &priv->flags))\n\t\tnci_recv_frame(priv->ndev, skb);\n\telse {\n\t\t \n\t\tkfree_skb(skb);\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nfcmrvl_nci_recv_frame);\n\nvoid nfcmrvl_chip_reset(struct nfcmrvl_private *priv)\n{\n\t \n\tclear_bit(NFCMRVL_PHY_ERROR, &priv->flags);\n\n\tif (gpio_is_valid(priv->config.reset_n_io)) {\n\t\tnfc_info(priv->dev, \"reset the chip\\n\");\n\t\tgpio_set_value(priv->config.reset_n_io, 0);\n\t\tusleep_range(5000, 10000);\n\t\tgpio_set_value(priv->config.reset_n_io, 1);\n\t} else\n\t\tnfc_info(priv->dev, \"no reset available on this interface\\n\");\n}\n\nvoid nfcmrvl_chip_halt(struct nfcmrvl_private *priv)\n{\n\tif (gpio_is_valid(priv->config.reset_n_io))\n\t\tgpio_set_value(priv->config.reset_n_io, 0);\n}\n\nint nfcmrvl_parse_dt(struct device_node *node,\n\t\t     struct nfcmrvl_platform_data *pdata)\n{\n\tint reset_n_io;\n\n\treset_n_io = of_get_named_gpio(node, \"reset-n-io\", 0);\n\tif (reset_n_io < 0) {\n\t\tpr_info(\"no reset-n-io config\\n\");\n\t} else if (!gpio_is_valid(reset_n_io)) {\n\t\tpr_err(\"invalid reset-n-io GPIO\\n\");\n\t\treturn reset_n_io;\n\t}\n\tpdata->reset_n_io = reset_n_io;\n\tpdata->hci_muxed = of_property_read_bool(node, \"hci-muxed\");\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nfcmrvl_parse_dt);\n\nMODULE_AUTHOR(\"Marvell International Ltd.\");\nMODULE_DESCRIPTION(\"Marvell NFC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}