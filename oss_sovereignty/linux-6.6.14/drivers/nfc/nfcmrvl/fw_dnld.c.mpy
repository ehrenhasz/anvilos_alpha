{
  "module_name": "fw_dnld.c",
  "hash_id": "eff3bb157aa93e777a37bcdb425d4ce9a1ac7041adad5ce03bfb7ee848c43819",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nfc/nfcmrvl/fw_dnld.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <asm/unaligned.h>\n#include <linux/firmware.h>\n#include <linux/nfc.h>\n#include <net/nfc/nci.h>\n#include <net/nfc/nci_core.h>\n#include \"nfcmrvl.h\"\n\n#define FW_DNLD_TIMEOUT\t\t\t15000\n\n#define NCI_OP_PROPRIETARY_BOOT_CMD\tnci_opcode_pack(NCI_GID_PROPRIETARY, \\\n\t\t\t\t\t\t\tNCI_OP_PROP_BOOT_CMD)\n\n \n\nenum {\n\tSTATE_RESET = 0,\n\tSTATE_INIT,\n\tSTATE_SET_REF_CLOCK,\n\tSTATE_SET_HI_CONFIG,\n\tSTATE_OPEN_LC,\n\tSTATE_FW_DNLD,\n\tSTATE_CLOSE_LC,\n\tSTATE_BOOT\n};\n\nenum {\n\tSUBSTATE_WAIT_COMMAND = 0,\n\tSUBSTATE_WAIT_ACK_CREDIT,\n\tSUBSTATE_WAIT_NACK_CREDIT,\n\tSUBSTATE_WAIT_DATA_CREDIT,\n};\n\n \n\nstatic const uint8_t nci_pattern_core_reset_ntf[] = {\n\t0x60, 0x00, 0x02, 0xA0, 0x01\n};\n\nstatic const uint8_t nci_pattern_core_init_rsp[] = {\n\t0x40, 0x01, 0x11\n};\n\nstatic const uint8_t nci_pattern_core_set_config_rsp[] = {\n\t0x40, 0x02, 0x02, 0x00, 0x00\n};\n\nstatic const uint8_t nci_pattern_core_conn_create_rsp[] = {\n\t0x40, 0x04, 0x04, 0x00\n};\n\nstatic const uint8_t nci_pattern_core_conn_close_rsp[] = {\n\t0x40, 0x05, 0x01, 0x00\n};\n\nstatic const uint8_t nci_pattern_core_conn_credits_ntf[] = {\n\t0x60, 0x06, 0x03, 0x01, NCI_CORE_LC_CONNID_PROP_FW_DL, 0x01\n};\n\nstatic const uint8_t nci_pattern_proprietary_boot_rsp[] = {\n\t0x4F, 0x3A, 0x01, 0x00\n};\n\nstatic struct sk_buff *alloc_lc_skb(struct nfcmrvl_private *priv, uint8_t plen)\n{\n\tstruct sk_buff *skb;\n\tstruct nci_data_hdr *hdr;\n\n\tskb = nci_skb_alloc(priv->ndev, (NCI_DATA_HDR_SIZE + plen), GFP_KERNEL);\n\tif (!skb)\n\t\treturn NULL;\n\n\thdr = skb_put(skb, NCI_DATA_HDR_SIZE);\n\thdr->conn_id = NCI_CORE_LC_CONNID_PROP_FW_DL;\n\thdr->rfu = 0;\n\thdr->plen = plen;\n\n\tnci_mt_set((__u8 *)hdr, NCI_MT_DATA_PKT);\n\tnci_pbf_set((__u8 *)hdr, NCI_PBF_LAST);\n\n\treturn skb;\n}\n\nstatic void fw_dnld_over(struct nfcmrvl_private *priv, u32 error)\n{\n\tif (priv->fw_dnld.fw) {\n\t\trelease_firmware(priv->fw_dnld.fw);\n\t\tpriv->fw_dnld.fw = NULL;\n\t\tpriv->fw_dnld.header = NULL;\n\t\tpriv->fw_dnld.binary_config = NULL;\n\t}\n\n\tatomic_set(&priv->ndev->cmd_cnt, 0);\n\n\tif (timer_pending(&priv->ndev->cmd_timer))\n\t\tdel_timer_sync(&priv->ndev->cmd_timer);\n\n\tif (timer_pending(&priv->fw_dnld.timer))\n\t\tdel_timer_sync(&priv->fw_dnld.timer);\n\n\tnfc_info(priv->dev, \"FW loading over (%d)]\\n\", error);\n\n\tif (error != 0) {\n\t\t \n\t\tnfcmrvl_chip_halt(priv);\n\t}\n\n\tnfc_fw_download_done(priv->ndev->nfc_dev, priv->fw_dnld.name, error);\n}\n\nstatic void fw_dnld_timeout(struct timer_list *t)\n{\n\tstruct nfcmrvl_private *priv = from_timer(priv, t, fw_dnld.timer);\n\n\tnfc_err(priv->dev, \"FW loading timeout\");\n\tpriv->fw_dnld.state = STATE_RESET;\n\tfw_dnld_over(priv, -ETIMEDOUT);\n}\n\nstatic int process_state_reset(struct nfcmrvl_private *priv,\n\t\t\t       const struct sk_buff *skb)\n{\n\tif (sizeof(nci_pattern_core_reset_ntf) != skb->len ||\n\t    memcmp(skb->data, nci_pattern_core_reset_ntf,\n\t\t   sizeof(nci_pattern_core_reset_ntf)))\n\t\treturn -EINVAL;\n\n\tnfc_info(priv->dev, \"BootROM reset, start fw download\\n\");\n\n\t \n\tpriv->fw_dnld.state = STATE_INIT;\n\tnci_send_cmd(priv->ndev, NCI_OP_CORE_INIT_CMD, 0, NULL);\n\n\treturn 0;\n}\n\nstatic int process_state_init(struct nfcmrvl_private *priv,\n\t\t\t      const struct sk_buff *skb)\n{\n\tstruct nci_core_set_config_cmd cmd;\n\n\tif (sizeof(nci_pattern_core_init_rsp) >= skb->len ||\n\t    memcmp(skb->data, nci_pattern_core_init_rsp,\n\t\t   sizeof(nci_pattern_core_init_rsp)))\n\t\treturn -EINVAL;\n\n\tcmd.num_params = 1;\n\tcmd.param.id = NFCMRVL_PROP_REF_CLOCK;\n\tcmd.param.len = 4;\n\tmemcpy(cmd.param.val, &priv->fw_dnld.header->ref_clock, 4);\n\n\tnci_send_cmd(priv->ndev, NCI_OP_CORE_SET_CONFIG_CMD, 3 + cmd.param.len,\n\t\t     &cmd);\n\n\tpriv->fw_dnld.state = STATE_SET_REF_CLOCK;\n\treturn 0;\n}\n\nstatic void create_lc(struct nfcmrvl_private *priv)\n{\n\tuint8_t param[2] = { NCI_CORE_LC_PROP_FW_DL, 0x0 };\n\n\tpriv->fw_dnld.state = STATE_OPEN_LC;\n\tnci_send_cmd(priv->ndev, NCI_OP_CORE_CONN_CREATE_CMD, 2, param);\n}\n\nstatic int process_state_set_ref_clock(struct nfcmrvl_private *priv,\n\t\t\t\t       const struct sk_buff *skb)\n{\n\tstruct nci_core_set_config_cmd cmd;\n\n\tif (sizeof(nci_pattern_core_set_config_rsp) != skb->len ||\n\t    memcmp(skb->data, nci_pattern_core_set_config_rsp, skb->len))\n\t\treturn -EINVAL;\n\n\tcmd.num_params = 1;\n\tcmd.param.id = NFCMRVL_PROP_SET_HI_CONFIG;\n\n\tswitch (priv->phy) {\n\tcase NFCMRVL_PHY_UART:\n\t\tcmd.param.len = 5;\n\t\tmemcpy(cmd.param.val,\n\t\t       &priv->fw_dnld.binary_config->uart.baudrate,\n\t\t       4);\n\t\tcmd.param.val[4] =\n\t\t\tpriv->fw_dnld.binary_config->uart.flow_control;\n\t\tbreak;\n\tcase NFCMRVL_PHY_I2C:\n\t\tcmd.param.len = 5;\n\t\tmemcpy(cmd.param.val,\n\t\t       &priv->fw_dnld.binary_config->i2c.clk,\n\t\t       4);\n\t\tcmd.param.val[4] = 0;\n\t\tbreak;\n\tcase NFCMRVL_PHY_SPI:\n\t\tcmd.param.len = 5;\n\t\tmemcpy(cmd.param.val,\n\t\t       &priv->fw_dnld.binary_config->spi.clk,\n\t\t       4);\n\t\tcmd.param.val[4] = 0;\n\t\tbreak;\n\tdefault:\n\t\tcreate_lc(priv);\n\t\treturn 0;\n\t}\n\n\tpriv->fw_dnld.state = STATE_SET_HI_CONFIG;\n\tnci_send_cmd(priv->ndev, NCI_OP_CORE_SET_CONFIG_CMD, 3 + cmd.param.len,\n\t\t     &cmd);\n\treturn 0;\n}\n\nstatic int process_state_set_hi_config(struct nfcmrvl_private *priv,\n\t\t\t\t       const struct sk_buff *skb)\n{\n\tif (sizeof(nci_pattern_core_set_config_rsp) != skb->len ||\n\t    memcmp(skb->data, nci_pattern_core_set_config_rsp, skb->len))\n\t\treturn -EINVAL;\n\n\tcreate_lc(priv);\n\treturn 0;\n}\n\nstatic int process_state_open_lc(struct nfcmrvl_private *priv,\n\t\t\t\t const struct sk_buff *skb)\n{\n\tif (sizeof(nci_pattern_core_conn_create_rsp) >= skb->len ||\n\t    memcmp(skb->data, nci_pattern_core_conn_create_rsp,\n\t\t   sizeof(nci_pattern_core_conn_create_rsp)))\n\t\treturn -EINVAL;\n\n\tpriv->fw_dnld.state = STATE_FW_DNLD;\n\tpriv->fw_dnld.substate = SUBSTATE_WAIT_COMMAND;\n\tpriv->fw_dnld.offset = priv->fw_dnld.binary_config->offset;\n\treturn 0;\n}\n\nstatic int process_state_fw_dnld(struct nfcmrvl_private *priv,\n\t\t\t\t struct sk_buff *skb)\n{\n\tuint16_t len;\n\tuint16_t comp_len;\n\tstruct sk_buff *out_skb;\n\n\tswitch (priv->fw_dnld.substate) {\n\tcase SUBSTATE_WAIT_COMMAND:\n\t\t \n\n\t\t \n\t\tskb_pull(skb, 3);\n\t\tif (skb->data[0] != HELPER_CMD_PACKET_FORMAT || skb->len != 5) {\n\t\t\tnfc_err(priv->dev, \"bad command\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tskb_pull(skb, 1);\n\t\tlen = get_unaligned_le16(skb->data);\n\t\tskb_pull(skb, 2);\n\t\tcomp_len = get_unaligned_le16(skb->data);\n\t\tmemcpy(&comp_len, skb->data, 2);\n\t\tskb_pull(skb, 2);\n\t\tif (((~len) & 0xFFFF) != comp_len) {\n\t\t\tnfc_err(priv->dev, \"bad len complement: %x %x %x\",\n\t\t\t\tlen, comp_len, (~len & 0xFFFF));\n\t\t\tout_skb = alloc_lc_skb(priv, 1);\n\t\t\tif (!out_skb)\n\t\t\t\treturn -ENOMEM;\n\t\t\tskb_put_u8(out_skb, 0xBF);\n\t\t\tnci_send_frame(priv->ndev, out_skb);\n\t\t\tpriv->fw_dnld.substate = SUBSTATE_WAIT_NACK_CREDIT;\n\t\t\treturn 0;\n\t\t}\n\t\tpriv->fw_dnld.chunk_len = len;\n\t\tout_skb = alloc_lc_skb(priv, 1);\n\t\tif (!out_skb)\n\t\t\treturn -ENOMEM;\n\t\tskb_put_u8(out_skb, HELPER_ACK_PACKET_FORMAT);\n\t\tnci_send_frame(priv->ndev, out_skb);\n\t\tpriv->fw_dnld.substate = SUBSTATE_WAIT_ACK_CREDIT;\n\t\tbreak;\n\n\tcase SUBSTATE_WAIT_ACK_CREDIT:\n\t\tif (sizeof(nci_pattern_core_conn_credits_ntf) != skb->len ||\n\t\t    memcmp(nci_pattern_core_conn_credits_ntf, skb->data,\n\t\t\t   skb->len)) {\n\t\t\tnfc_err(priv->dev, \"bad packet: waiting for credit\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (priv->fw_dnld.chunk_len == 0) {\n\t\t\t \n\t\t\tuint8_t conn_id = NCI_CORE_LC_CONNID_PROP_FW_DL;\n\n\t\t\tpriv->fw_dnld.state = STATE_CLOSE_LC;\n\t\t\tnci_send_cmd(priv->ndev, NCI_OP_CORE_CONN_CLOSE_CMD,\n\t\t\t\t     1, &conn_id);\n\t\t} else {\n\t\t\tout_skb = alloc_lc_skb(priv, priv->fw_dnld.chunk_len);\n\t\t\tif (!out_skb)\n\t\t\t\treturn -ENOMEM;\n\t\t\tskb_put_data(out_skb,\n\t\t\t\t     ((uint8_t *)priv->fw_dnld.fw->data) + priv->fw_dnld.offset,\n\t\t\t\t     priv->fw_dnld.chunk_len);\n\t\t\tnci_send_frame(priv->ndev, out_skb);\n\t\t\tpriv->fw_dnld.substate = SUBSTATE_WAIT_DATA_CREDIT;\n\t\t}\n\t\tbreak;\n\n\tcase SUBSTATE_WAIT_DATA_CREDIT:\n\t\tif (sizeof(nci_pattern_core_conn_credits_ntf) != skb->len ||\n\t\t    memcmp(nci_pattern_core_conn_credits_ntf, skb->data,\n\t\t\t    skb->len)) {\n\t\t\tnfc_err(priv->dev, \"bad packet: waiting for credit\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpriv->fw_dnld.offset += priv->fw_dnld.chunk_len;\n\t\tpriv->fw_dnld.chunk_len = 0;\n\t\tpriv->fw_dnld.substate = SUBSTATE_WAIT_COMMAND;\n\t\tbreak;\n\n\tcase SUBSTATE_WAIT_NACK_CREDIT:\n\t\tif (sizeof(nci_pattern_core_conn_credits_ntf) != skb->len ||\n\t\t    memcmp(nci_pattern_core_conn_credits_ntf, skb->data,\n\t\t\t    skb->len)) {\n\t\t\tnfc_err(priv->dev, \"bad packet: waiting for credit\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpriv->fw_dnld.substate = SUBSTATE_WAIT_COMMAND;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int process_state_close_lc(struct nfcmrvl_private *priv,\n\t\t\t\t  const struct sk_buff *skb)\n{\n\tif (sizeof(nci_pattern_core_conn_close_rsp) != skb->len ||\n\t    memcmp(skb->data, nci_pattern_core_conn_close_rsp, skb->len))\n\t\treturn -EINVAL;\n\n\tpriv->fw_dnld.state = STATE_BOOT;\n\tnci_send_cmd(priv->ndev, NCI_OP_PROPRIETARY_BOOT_CMD, 0, NULL);\n\treturn 0;\n}\n\nstatic int process_state_boot(struct nfcmrvl_private *priv,\n\t\t\t      const struct sk_buff *skb)\n{\n\tif (sizeof(nci_pattern_proprietary_boot_rsp) != skb->len ||\n\t    memcmp(skb->data, nci_pattern_proprietary_boot_rsp, skb->len))\n\t\treturn -EINVAL;\n\n\t \n\tpriv->if_ops->nci_update_config(priv,\n\t\t\t\t\t&priv->fw_dnld.binary_config->config);\n\n\tif (priv->fw_dnld.binary_config == &priv->fw_dnld.header->helper) {\n\t\t \n\t\tpriv->fw_dnld.state = STATE_RESET;\n\t\tpriv->fw_dnld.binary_config = &priv->fw_dnld.header->firmware;\n\t\tnfc_info(priv->dev, \"FW loading: helper loaded\");\n\t} else {\n\t\tnfc_info(priv->dev, \"FW loading: firmware loaded\");\n\t\tfw_dnld_over(priv, 0);\n\t}\n\treturn 0;\n}\n\nstatic void fw_dnld_rx_work(struct work_struct *work)\n{\n\tint ret;\n\tstruct sk_buff *skb;\n\tstruct nfcmrvl_fw_dnld *fw_dnld = container_of(work,\n\t\t\t\t\t\t       struct nfcmrvl_fw_dnld,\n\t\t\t\t\t\t       rx_work);\n\tstruct nfcmrvl_private *priv = container_of(fw_dnld,\n\t\t\t\t\t\t    struct nfcmrvl_private,\n\t\t\t\t\t\t    fw_dnld);\n\n\twhile ((skb = skb_dequeue(&fw_dnld->rx_q))) {\n\t\tnfc_send_to_raw_sock(priv->ndev->nfc_dev, skb,\n\t\t\t\t     RAW_PAYLOAD_NCI, NFC_DIRECTION_RX);\n\t\tswitch (fw_dnld->state) {\n\t\tcase STATE_RESET:\n\t\t\tret = process_state_reset(priv, skb);\n\t\t\tbreak;\n\t\tcase STATE_INIT:\n\t\t\tret = process_state_init(priv, skb);\n\t\t\tbreak;\n\t\tcase STATE_SET_REF_CLOCK:\n\t\t\tret = process_state_set_ref_clock(priv, skb);\n\t\t\tbreak;\n\t\tcase STATE_SET_HI_CONFIG:\n\t\t\tret = process_state_set_hi_config(priv, skb);\n\t\t\tbreak;\n\t\tcase STATE_OPEN_LC:\n\t\t\tret = process_state_open_lc(priv, skb);\n\t\t\tbreak;\n\t\tcase STATE_FW_DNLD:\n\t\t\tret = process_state_fw_dnld(priv, skb);\n\t\t\tbreak;\n\t\tcase STATE_CLOSE_LC:\n\t\t\tret = process_state_close_lc(priv, skb);\n\t\t\tbreak;\n\t\tcase STATE_BOOT:\n\t\t\tret = process_state_boot(priv, skb);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EFAULT;\n\t\t}\n\n\t\tkfree_skb(skb);\n\n\t\tif (ret != 0) {\n\t\t\tnfc_err(priv->dev, \"FW loading error\");\n\t\t\tfw_dnld_over(priv, ret);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint nfcmrvl_fw_dnld_init(struct nfcmrvl_private *priv)\n{\n\tchar name[32];\n\n\tINIT_WORK(&priv->fw_dnld.rx_work, fw_dnld_rx_work);\n\tsnprintf(name, sizeof(name), \"%s_nfcmrvl_fw_dnld_rx_wq\",\n\t\t dev_name(&priv->ndev->nfc_dev->dev));\n\tpriv->fw_dnld.rx_wq = create_singlethread_workqueue(name);\n\tif (!priv->fw_dnld.rx_wq)\n\t\treturn -ENOMEM;\n\tskb_queue_head_init(&priv->fw_dnld.rx_q);\n\treturn 0;\n}\n\nvoid nfcmrvl_fw_dnld_deinit(struct nfcmrvl_private *priv)\n{\n\tdestroy_workqueue(priv->fw_dnld.rx_wq);\n}\n\nvoid nfcmrvl_fw_dnld_recv_frame(struct nfcmrvl_private *priv,\n\t\t\t\tstruct sk_buff *skb)\n{\n\t \n\tif (timer_pending(&priv->ndev->cmd_timer))\n\t\tdel_timer_sync(&priv->ndev->cmd_timer);\n\n\t \n\tatomic_set(&priv->ndev->cmd_cnt, 1);\n\n\t \n\tskb_queue_tail(&priv->fw_dnld.rx_q, skb);\n\tqueue_work(priv->fw_dnld.rx_wq, &priv->fw_dnld.rx_work);\n}\n\nvoid nfcmrvl_fw_dnld_abort(struct nfcmrvl_private *priv)\n{\n\tfw_dnld_over(priv, -EHOSTDOWN);\n}\n\nint nfcmrvl_fw_dnld_start(struct nci_dev *ndev, const char *firmware_name)\n{\n\tstruct nfcmrvl_private *priv = nci_get_drvdata(ndev);\n\tstruct nfcmrvl_fw_dnld *fw_dnld = &priv->fw_dnld;\n\tint res;\n\n\tif (!priv->support_fw_dnld)\n\t\treturn -ENOTSUPP;\n\n\tif (!firmware_name || !firmware_name[0])\n\t\treturn -EINVAL;\n\n\tstrcpy(fw_dnld->name, firmware_name);\n\n\t \n\n\t \n\tres = request_firmware(&fw_dnld->fw, firmware_name,\n\t\t\t       &ndev->nfc_dev->dev);\n\tif (res < 0) {\n\t\tnfc_err(priv->dev, \"failed to retrieve FW %s\", firmware_name);\n\t\treturn -ENOENT;\n\t}\n\n\tfw_dnld->header = (const struct nfcmrvl_fw *) priv->fw_dnld.fw->data;\n\n\tif (fw_dnld->header->magic != NFCMRVL_FW_MAGIC ||\n\t    fw_dnld->header->phy != priv->phy) {\n\t\tnfc_err(priv->dev, \"bad firmware binary %s magic=0x%x phy=%d\",\n\t\t\tfirmware_name, fw_dnld->header->magic,\n\t\t\tfw_dnld->header->phy);\n\t\trelease_firmware(fw_dnld->fw);\n\t\tfw_dnld->header = NULL;\n\t\treturn -EINVAL;\n\t}\n\n\tif (fw_dnld->header->helper.offset != 0) {\n\t\tnfc_info(priv->dev, \"loading helper\");\n\t\tfw_dnld->binary_config = &fw_dnld->header->helper;\n\t} else {\n\t\tnfc_info(priv->dev, \"loading firmware\");\n\t\tfw_dnld->binary_config = &fw_dnld->header->firmware;\n\t}\n\n\t \n\ttimer_setup(&priv->fw_dnld.timer, fw_dnld_timeout, 0);\n\tmod_timer(&priv->fw_dnld.timer,\n\t\t  jiffies + msecs_to_jiffies(FW_DNLD_TIMEOUT));\n\n\t \n\tpriv->if_ops->nci_update_config(priv,\n\t\t\t\t\t&fw_dnld->header->bootrom.config);\n\n\t \n\tatomic_set(&priv->ndev->cmd_cnt, 1);\n\n\t \n\tpriv->fw_dnld.state = STATE_RESET;\n\tnfcmrvl_chip_reset(priv);\n\n\t \n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}