{
  "module_name": "i2c.c",
  "hash_id": "6b59827c81fd5040f702072a3b2a37f1d20dceb7ab8a04506263d9f7468a5b15",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nfc/nfcmrvl/i2c.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/i2c.h>\n#include <linux/nfc.h>\n#include <linux/delay.h>\n#include <linux/of_irq.h>\n#include <net/nfc/nci.h>\n#include <net/nfc/nci_core.h>\n#include \"nfcmrvl.h\"\n\nstruct nfcmrvl_i2c_drv_data {\n\tunsigned long flags;\n\tstruct device *dev;\n\tstruct i2c_client *i2c;\n\tstruct nfcmrvl_private *priv;\n};\n\nstatic int nfcmrvl_i2c_read(struct nfcmrvl_i2c_drv_data *drv_data,\n\t\t\t    struct sk_buff **skb)\n{\n\tint ret;\n\tstruct nci_ctrl_hdr nci_hdr;\n\n\t \n\tret = i2c_master_recv(drv_data->i2c, (u8 *)&nci_hdr, NCI_CTRL_HDR_SIZE);\n\tif (ret != NCI_CTRL_HDR_SIZE) {\n\t\tnfc_err(&drv_data->i2c->dev, \"cannot read NCI header\\n\");\n\t\treturn -EBADMSG;\n\t}\n\n\t*skb = nci_skb_alloc(drv_data->priv->ndev,\n\t\t\t     nci_hdr.plen + NCI_CTRL_HDR_SIZE, GFP_KERNEL);\n\tif (!*skb)\n\t\treturn -ENOMEM;\n\n\t \n\tskb_put_data(*skb, &nci_hdr, NCI_CTRL_HDR_SIZE);\n\n\tif (nci_hdr.plen) {\n\t\t \n\t\tret = i2c_master_recv(drv_data->i2c,\n\t\t\t\t      skb_put(*skb, nci_hdr.plen),\n\t\t\t\t      nci_hdr.plen);\n\n\t\tif (ret != nci_hdr.plen) {\n\t\t\tnfc_err(&drv_data->i2c->dev,\n\t\t\t\t\"Invalid frame payload length: %u (expected %u)\\n\",\n\t\t\t\tret, nci_hdr.plen);\n\t\t\tkfree_skb(*skb);\n\t\t\treturn -EBADMSG;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic irqreturn_t nfcmrvl_i2c_int_irq_thread_fn(int irq, void *drv_data_ptr)\n{\n\tstruct nfcmrvl_i2c_drv_data *drv_data = drv_data_ptr;\n\tstruct sk_buff *skb = NULL;\n\tint ret;\n\n\tif (!drv_data->priv)\n\t\treturn IRQ_HANDLED;\n\n\tif (test_bit(NFCMRVL_PHY_ERROR, &drv_data->priv->flags))\n\t\treturn IRQ_HANDLED;\n\n\tret = nfcmrvl_i2c_read(drv_data, &skb);\n\n\tswitch (ret) {\n\tcase -EREMOTEIO:\n\t\tset_bit(NFCMRVL_PHY_ERROR, &drv_data->priv->flags);\n\t\tbreak;\n\tcase -ENOMEM:\n\tcase -EBADMSG:\n\t\tnfc_err(&drv_data->i2c->dev, \"read failed %d\\n\", ret);\n\t\tbreak;\n\tdefault:\n\t\tif (nfcmrvl_nci_recv_frame(drv_data->priv, skb) < 0)\n\t\t\tnfc_err(&drv_data->i2c->dev, \"corrupted RX packet\\n\");\n\t\tbreak;\n\t}\n\treturn IRQ_HANDLED;\n}\n\nstatic int nfcmrvl_i2c_nci_open(struct nfcmrvl_private *priv)\n{\n\tstruct nfcmrvl_i2c_drv_data *drv_data = priv->drv_data;\n\n\tif (!drv_data)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic int nfcmrvl_i2c_nci_close(struct nfcmrvl_private *priv)\n{\n\treturn 0;\n}\n\nstatic int nfcmrvl_i2c_nci_send(struct nfcmrvl_private *priv,\n\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct nfcmrvl_i2c_drv_data *drv_data = priv->drv_data;\n\tint ret;\n\n\tif (test_bit(NFCMRVL_PHY_ERROR, &priv->flags)) {\n\t\tkfree_skb(skb);\n\t\treturn -EREMOTEIO;\n\t}\n\n\tret = i2c_master_send(drv_data->i2c, skb->data, skb->len);\n\n\t \n\tif (ret == -EREMOTEIO) {\n\t\tnfc_info(drv_data->dev, \"chip may sleep, retry\\n\");\n\t\tusleep_range(6000, 10000);\n\t\tret = i2c_master_send(drv_data->i2c, skb->data, skb->len);\n\t}\n\n\tif (ret >= 0) {\n\t\tif (ret != skb->len) {\n\t\t\tnfc_err(drv_data->dev,\n\t\t\t\t\"Invalid length sent: %u (expected %u)\\n\",\n\t\t\t\tret, skb->len);\n\t\t\tret = -EREMOTEIO;\n\t\t} else\n\t\t\tret = 0;\n\t}\n\n\tif (ret) {\n\t\tkfree_skb(skb);\n\t\treturn ret;\n\t}\n\n\tconsume_skb(skb);\n\treturn 0;\n}\n\nstatic void nfcmrvl_i2c_nci_update_config(struct nfcmrvl_private *priv,\n\t\t\t\t\t  const void *param)\n{\n}\n\nstatic const struct nfcmrvl_if_ops i2c_ops = {\n\t.nci_open = nfcmrvl_i2c_nci_open,\n\t.nci_close = nfcmrvl_i2c_nci_close,\n\t.nci_send = nfcmrvl_i2c_nci_send,\n\t.nci_update_config = nfcmrvl_i2c_nci_update_config,\n};\n\nstatic int nfcmrvl_i2c_parse_dt(struct device_node *node,\n\t\t\t\tstruct nfcmrvl_platform_data *pdata)\n{\n\tint ret;\n\n\tret = nfcmrvl_parse_dt(node, pdata);\n\tif (ret < 0) {\n\t\tpr_err(\"Failed to get generic entries\\n\");\n\t\treturn ret;\n\t}\n\n\tif (of_property_read_bool(node, \"i2c-int-falling\"))\n\t\tpdata->irq_polarity = IRQF_TRIGGER_FALLING;\n\telse\n\t\tpdata->irq_polarity = IRQF_TRIGGER_RISING;\n\n\tret = irq_of_parse_and_map(node, 0);\n\tif (!ret) {\n\t\tpr_err(\"Unable to get irq\\n\");\n\t\treturn -EINVAL;\n\t}\n\tpdata->irq = ret;\n\n\treturn 0;\n}\n\nstatic int nfcmrvl_i2c_probe(struct i2c_client *client)\n{\n\tconst struct nfcmrvl_platform_data *pdata;\n\tstruct nfcmrvl_i2c_drv_data *drv_data;\n\tstruct nfcmrvl_platform_data config;\n\tint ret;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\n\t\tnfc_err(&client->dev, \"Need I2C_FUNC_I2C\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdrv_data = devm_kzalloc(&client->dev, sizeof(*drv_data), GFP_KERNEL);\n\tif (!drv_data)\n\t\treturn -ENOMEM;\n\n\tdrv_data->i2c = client;\n\tdrv_data->dev = &client->dev;\n\tdrv_data->priv = NULL;\n\n\ti2c_set_clientdata(client, drv_data);\n\n\tpdata = client->dev.platform_data;\n\n\tif (!pdata && client->dev.of_node)\n\t\tif (nfcmrvl_i2c_parse_dt(client->dev.of_node, &config) == 0)\n\t\t\tpdata = &config;\n\n\tif (!pdata)\n\t\treturn -EINVAL;\n\n\t \n\tret = devm_request_threaded_irq(&drv_data->i2c->dev, pdata->irq,\n\t\t\t\t\tNULL, nfcmrvl_i2c_int_irq_thread_fn,\n\t\t\t\t\tpdata->irq_polarity | IRQF_ONESHOT,\n\t\t\t\t\t\"nfcmrvl_i2c_int\", drv_data);\n\tif (ret < 0) {\n\t\tnfc_err(&drv_data->i2c->dev,\n\t\t\t\"Unable to register IRQ handler\\n\");\n\t\treturn ret;\n\t}\n\n\tdrv_data->priv = nfcmrvl_nci_register_dev(NFCMRVL_PHY_I2C,\n\t\t\t\t\t\t  drv_data, &i2c_ops,\n\t\t\t\t\t\t  &drv_data->i2c->dev, pdata);\n\n\tif (IS_ERR(drv_data->priv))\n\t\treturn PTR_ERR(drv_data->priv);\n\n\tdrv_data->priv->support_fw_dnld = true;\n\n\treturn 0;\n}\n\nstatic void nfcmrvl_i2c_remove(struct i2c_client *client)\n{\n\tstruct nfcmrvl_i2c_drv_data *drv_data = i2c_get_clientdata(client);\n\n\tnfcmrvl_nci_unregister_dev(drv_data->priv);\n}\n\n\nstatic const struct of_device_id of_nfcmrvl_i2c_match[] __maybe_unused = {\n\t{ .compatible = \"marvell,nfc-i2c\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, of_nfcmrvl_i2c_match);\n\nstatic const struct i2c_device_id nfcmrvl_i2c_id_table[] = {\n\t{ \"nfcmrvl_i2c\", 0 },\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, nfcmrvl_i2c_id_table);\n\nstatic struct i2c_driver nfcmrvl_i2c_driver = {\n\t.probe = nfcmrvl_i2c_probe,\n\t.id_table = nfcmrvl_i2c_id_table,\n\t.remove = nfcmrvl_i2c_remove,\n\t.driver = {\n\t\t.name\t\t= \"nfcmrvl_i2c\",\n\t\t.of_match_table\t= of_match_ptr(of_nfcmrvl_i2c_match),\n\t},\n};\n\nmodule_i2c_driver(nfcmrvl_i2c_driver);\n\nMODULE_AUTHOR(\"Marvell International Ltd.\");\nMODULE_DESCRIPTION(\"Marvell NFC-over-I2C driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}