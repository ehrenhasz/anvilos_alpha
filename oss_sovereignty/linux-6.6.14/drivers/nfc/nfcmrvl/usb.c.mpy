{
  "module_name": "usb.c",
  "hash_id": "dd0a9281407ca3eca62907ad58201fe1eefc864f840c648fb81d409a94d34571",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nfc/nfcmrvl/usb.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/usb.h>\n#include <linux/nfc.h>\n#include <net/nfc/nci.h>\n#include <net/nfc/nci_core.h>\n#include \"nfcmrvl.h\"\n\nstatic struct usb_device_id nfcmrvl_table[] = {\n\t{ USB_DEVICE_AND_INTERFACE_INFO(0x1286, 0x2046,\n\t\t\t\t\tUSB_CLASS_VENDOR_SPEC, 4, 1) },\n\t{ }\t \n};\n\nMODULE_DEVICE_TABLE(usb, nfcmrvl_table);\n\n#define NFCMRVL_USB_BULK_RUNNING\t1\n#define NFCMRVL_USB_SUSPENDING\t\t2\n\nstruct nfcmrvl_usb_drv_data {\n\tstruct usb_device *udev;\n\tstruct usb_interface *intf;\n\tunsigned long flags;\n\tstruct work_struct waker;\n\tstruct usb_anchor tx_anchor;\n\tstruct usb_anchor bulk_anchor;\n\tstruct usb_anchor deferred;\n\tint tx_in_flight;\n\t \n\tspinlock_t txlock;\n\tstruct usb_endpoint_descriptor *bulk_tx_ep;\n\tstruct usb_endpoint_descriptor *bulk_rx_ep;\n\tint suspend_count;\n\tstruct nfcmrvl_private *priv;\n};\n\nstatic int nfcmrvl_inc_tx(struct nfcmrvl_usb_drv_data *drv_data)\n{\n\tunsigned long flags;\n\tint rv;\n\n\tspin_lock_irqsave(&drv_data->txlock, flags);\n\trv = test_bit(NFCMRVL_USB_SUSPENDING, &drv_data->flags);\n\tif (!rv)\n\t\tdrv_data->tx_in_flight++;\n\tspin_unlock_irqrestore(&drv_data->txlock, flags);\n\n\treturn rv;\n}\n\nstatic void nfcmrvl_bulk_complete(struct urb *urb)\n{\n\tstruct nfcmrvl_usb_drv_data *drv_data = urb->context;\n\tint err;\n\n\tdev_dbg(&drv_data->udev->dev, \"urb %p status %d count %d\\n\",\n\t\turb, urb->status, urb->actual_length);\n\n\tif (!test_bit(NFCMRVL_NCI_RUNNING, &drv_data->flags))\n\t\treturn;\n\n\tif (!urb->status) {\n\t\tstruct sk_buff *skb;\n\n\t\tskb = nci_skb_alloc(drv_data->priv->ndev, urb->actual_length,\n\t\t\t\t    GFP_ATOMIC);\n\t\tif (!skb) {\n\t\t\tnfc_err(&drv_data->udev->dev, \"failed to alloc mem\\n\");\n\t\t} else {\n\t\t\tskb_put_data(skb, urb->transfer_buffer,\n\t\t\t\t     urb->actual_length);\n\t\t\tif (nfcmrvl_nci_recv_frame(drv_data->priv, skb) < 0)\n\t\t\t\tnfc_err(&drv_data->udev->dev,\n\t\t\t\t\t\"corrupted Rx packet\\n\");\n\t\t}\n\t}\n\n\tif (!test_bit(NFCMRVL_USB_BULK_RUNNING, &drv_data->flags))\n\t\treturn;\n\n\tusb_anchor_urb(urb, &drv_data->bulk_anchor);\n\tusb_mark_last_busy(drv_data->udev);\n\n\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (err) {\n\t\t \n\t\tif (err != -EPERM && err != -ENODEV)\n\t\t\tnfc_err(&drv_data->udev->dev,\n\t\t\t\t\"urb %p failed to resubmit (%d)\\n\", urb, -err);\n\t\tusb_unanchor_urb(urb);\n\t}\n}\n\nstatic int\nnfcmrvl_submit_bulk_urb(struct nfcmrvl_usb_drv_data *drv_data, gfp_t mem_flags)\n{\n\tstruct urb *urb;\n\tunsigned char *buf;\n\tunsigned int pipe;\n\tint err, size = NFCMRVL_NCI_MAX_EVENT_SIZE;\n\n\tif (!drv_data->bulk_rx_ep)\n\t\treturn -ENODEV;\n\n\turb = usb_alloc_urb(0, mem_flags);\n\tif (!urb)\n\t\treturn -ENOMEM;\n\n\tbuf = kmalloc(size, mem_flags);\n\tif (!buf) {\n\t\tusb_free_urb(urb);\n\t\treturn -ENOMEM;\n\t}\n\n\tpipe = usb_rcvbulkpipe(drv_data->udev,\n\t\t\t       drv_data->bulk_rx_ep->bEndpointAddress);\n\n\tusb_fill_bulk_urb(urb, drv_data->udev, pipe, buf, size,\n\t\t\t  nfcmrvl_bulk_complete, drv_data);\n\n\turb->transfer_flags |= URB_FREE_BUFFER;\n\n\tusb_mark_last_busy(drv_data->udev);\n\tusb_anchor_urb(urb, &drv_data->bulk_anchor);\n\n\terr = usb_submit_urb(urb, mem_flags);\n\tif (err) {\n\t\tif (err != -EPERM && err != -ENODEV)\n\t\t\tnfc_err(&drv_data->udev->dev,\n\t\t\t\t\"urb %p submission failed (%d)\\n\", urb, -err);\n\t\tusb_unanchor_urb(urb);\n\t}\n\n\tusb_free_urb(urb);\n\n\treturn err;\n}\n\nstatic void nfcmrvl_tx_complete(struct urb *urb)\n{\n\tstruct sk_buff *skb = urb->context;\n\tstruct nci_dev *ndev = (struct nci_dev *)skb->dev;\n\tstruct nfcmrvl_private *priv = nci_get_drvdata(ndev);\n\tstruct nfcmrvl_usb_drv_data *drv_data = priv->drv_data;\n\tunsigned long flags;\n\n\tnfc_info(priv->dev, \"urb %p status %d count %d\\n\",\n\t\t urb, urb->status, urb->actual_length);\n\n\tspin_lock_irqsave(&drv_data->txlock, flags);\n\tdrv_data->tx_in_flight--;\n\tspin_unlock_irqrestore(&drv_data->txlock, flags);\n\n\tkfree(urb->setup_packet);\n\tkfree_skb(skb);\n}\n\nstatic int nfcmrvl_usb_nci_open(struct nfcmrvl_private *priv)\n{\n\tstruct nfcmrvl_usb_drv_data *drv_data = priv->drv_data;\n\tint err;\n\n\terr = usb_autopm_get_interface(drv_data->intf);\n\tif (err)\n\t\treturn err;\n\n\tdrv_data->intf->needs_remote_wakeup = 1;\n\n\terr = nfcmrvl_submit_bulk_urb(drv_data, GFP_KERNEL);\n\tif (err)\n\t\tgoto failed;\n\n\tset_bit(NFCMRVL_USB_BULK_RUNNING, &drv_data->flags);\n\tnfcmrvl_submit_bulk_urb(drv_data, GFP_KERNEL);\n\n\tusb_autopm_put_interface(drv_data->intf);\n\treturn 0;\n\nfailed:\n\tusb_autopm_put_interface(drv_data->intf);\n\treturn err;\n}\n\nstatic void nfcmrvl_usb_stop_traffic(struct nfcmrvl_usb_drv_data *drv_data)\n{\n\tusb_kill_anchored_urbs(&drv_data->bulk_anchor);\n}\n\nstatic int nfcmrvl_usb_nci_close(struct nfcmrvl_private *priv)\n{\n\tstruct nfcmrvl_usb_drv_data *drv_data = priv->drv_data;\n\tint err;\n\n\tcancel_work_sync(&drv_data->waker);\n\n\tclear_bit(NFCMRVL_USB_BULK_RUNNING, &drv_data->flags);\n\n\tnfcmrvl_usb_stop_traffic(drv_data);\n\tusb_kill_anchored_urbs(&drv_data->tx_anchor);\n\terr = usb_autopm_get_interface(drv_data->intf);\n\tif (err)\n\t\tgoto failed;\n\n\tdrv_data->intf->needs_remote_wakeup = 0;\n\tusb_autopm_put_interface(drv_data->intf);\n\nfailed:\n\tusb_scuttle_anchored_urbs(&drv_data->deferred);\n\treturn 0;\n}\n\nstatic int nfcmrvl_usb_nci_send(struct nfcmrvl_private *priv,\n\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct nfcmrvl_usb_drv_data *drv_data = priv->drv_data;\n\tstruct urb *urb;\n\tunsigned int pipe;\n\tint err;\n\n\tif (!drv_data->bulk_tx_ep)\n\t\treturn -ENODEV;\n\n\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!urb)\n\t\treturn -ENOMEM;\n\n\tpipe = usb_sndbulkpipe(drv_data->udev,\n\t\t\t\tdrv_data->bulk_tx_ep->bEndpointAddress);\n\n\tusb_fill_bulk_urb(urb, drv_data->udev, pipe, skb->data, skb->len,\n\t\t\t  nfcmrvl_tx_complete, skb);\n\n\terr = nfcmrvl_inc_tx(drv_data);\n\tif (err) {\n\t\tusb_anchor_urb(urb, &drv_data->deferred);\n\t\tschedule_work(&drv_data->waker);\n\t\terr = 0;\n\t\tgoto done;\n\t}\n\n\tusb_anchor_urb(urb, &drv_data->tx_anchor);\n\n\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (err) {\n\t\tif (err != -EPERM && err != -ENODEV)\n\t\t\tnfc_err(&drv_data->udev->dev,\n\t\t\t\t\"urb %p submission failed (%d)\\n\", urb, -err);\n\t\tkfree(urb->setup_packet);\n\t\tusb_unanchor_urb(urb);\n\t} else {\n\t\tusb_mark_last_busy(drv_data->udev);\n\t}\n\ndone:\n\tusb_free_urb(urb);\n\treturn err;\n}\n\nstatic const struct nfcmrvl_if_ops usb_ops = {\n\t.nci_open = nfcmrvl_usb_nci_open,\n\t.nci_close = nfcmrvl_usb_nci_close,\n\t.nci_send = nfcmrvl_usb_nci_send,\n};\n\nstatic void nfcmrvl_waker(struct work_struct *work)\n{\n\tstruct nfcmrvl_usb_drv_data *drv_data =\n\t\t\tcontainer_of(work, struct nfcmrvl_usb_drv_data, waker);\n\tint err;\n\n\terr = usb_autopm_get_interface(drv_data->intf);\n\tif (err)\n\t\treturn;\n\n\tusb_autopm_put_interface(drv_data->intf);\n}\n\nstatic int nfcmrvl_probe(struct usb_interface *intf,\n\t\t\t const struct usb_device_id *id)\n{\n\tstruct nfcmrvl_usb_drv_data *drv_data;\n\tstruct nfcmrvl_private *priv;\n\tint i;\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tstruct nfcmrvl_platform_data config;\n\n\t \n\tmemset(&config, 0, sizeof(config));\n\tconfig.reset_n_io = -EINVAL;\n\n\tnfc_info(&udev->dev, \"intf %p id %p\\n\", intf, id);\n\n\tdrv_data = devm_kzalloc(&intf->dev, sizeof(*drv_data), GFP_KERNEL);\n\tif (!drv_data)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < intf->cur_altsetting->desc.bNumEndpoints; i++) {\n\t\tstruct usb_endpoint_descriptor *ep_desc;\n\n\t\tep_desc = &intf->cur_altsetting->endpoint[i].desc;\n\n\t\tif (!drv_data->bulk_tx_ep &&\n\t\t    usb_endpoint_is_bulk_out(ep_desc)) {\n\t\t\tdrv_data->bulk_tx_ep = ep_desc;\n\t\t} else if (!drv_data->bulk_rx_ep &&\n\t\t\t   usb_endpoint_is_bulk_in(ep_desc)) {\n\t\t\tdrv_data->bulk_rx_ep = ep_desc;\n\t\t}\n\t}\n\n\tif (!drv_data->bulk_tx_ep || !drv_data->bulk_rx_ep)\n\t\treturn -ENODEV;\n\n\tdrv_data->udev = udev;\n\tdrv_data->intf = intf;\n\n\tINIT_WORK(&drv_data->waker, nfcmrvl_waker);\n\tspin_lock_init(&drv_data->txlock);\n\n\tinit_usb_anchor(&drv_data->tx_anchor);\n\tinit_usb_anchor(&drv_data->bulk_anchor);\n\tinit_usb_anchor(&drv_data->deferred);\n\n\tpriv = nfcmrvl_nci_register_dev(NFCMRVL_PHY_USB, drv_data, &usb_ops,\n\t\t\t\t\t&intf->dev, &config);\n\tif (IS_ERR(priv))\n\t\treturn PTR_ERR(priv);\n\n\tdrv_data->priv = priv;\n\tdrv_data->priv->support_fw_dnld = false;\n\n\tusb_set_intfdata(intf, drv_data);\n\n\treturn 0;\n}\n\nstatic void nfcmrvl_disconnect(struct usb_interface *intf)\n{\n\tstruct nfcmrvl_usb_drv_data *drv_data = usb_get_intfdata(intf);\n\n\tif (!drv_data)\n\t\treturn;\n\n\tnfc_info(&drv_data->udev->dev, \"intf %p\\n\", intf);\n\n\tnfcmrvl_nci_unregister_dev(drv_data->priv);\n\n\tusb_set_intfdata(drv_data->intf, NULL);\n}\n\n#ifdef CONFIG_PM\nstatic int nfcmrvl_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\tstruct nfcmrvl_usb_drv_data *drv_data = usb_get_intfdata(intf);\n\n\tnfc_info(&drv_data->udev->dev, \"intf %p\\n\", intf);\n\n\tif (drv_data->suspend_count++)\n\t\treturn 0;\n\n\tspin_lock_irq(&drv_data->txlock);\n\tif (!(PMSG_IS_AUTO(message) && drv_data->tx_in_flight)) {\n\t\tset_bit(NFCMRVL_USB_SUSPENDING, &drv_data->flags);\n\t\tspin_unlock_irq(&drv_data->txlock);\n\t} else {\n\t\tspin_unlock_irq(&drv_data->txlock);\n\t\tdrv_data->suspend_count--;\n\t\treturn -EBUSY;\n\t}\n\n\tnfcmrvl_usb_stop_traffic(drv_data);\n\tusb_kill_anchored_urbs(&drv_data->tx_anchor);\n\n\treturn 0;\n}\n\nstatic void nfcmrvl_play_deferred(struct nfcmrvl_usb_drv_data *drv_data)\n{\n\tstruct urb *urb;\n\tint err;\n\n\twhile ((urb = usb_get_from_anchor(&drv_data->deferred))) {\n\t\tusb_anchor_urb(urb, &drv_data->tx_anchor);\n\n\t\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\t\tif (err) {\n\t\t\tkfree(urb->setup_packet);\n\t\t\tusb_unanchor_urb(urb);\n\t\t\tusb_free_urb(urb);\n\t\t\tbreak;\n\t\t}\n\n\t\tdrv_data->tx_in_flight++;\n\t\tusb_free_urb(urb);\n\t}\n\n\t \n\twhile ((urb = usb_get_from_anchor(&drv_data->deferred))) {\n\t\tkfree(urb->setup_packet);\n\t\tusb_free_urb(urb);\n\t}\n}\n\nstatic int nfcmrvl_resume(struct usb_interface *intf)\n{\n\tstruct nfcmrvl_usb_drv_data *drv_data = usb_get_intfdata(intf);\n\tint err = 0;\n\n\tnfc_info(&drv_data->udev->dev, \"intf %p\\n\", intf);\n\n\tif (--drv_data->suspend_count)\n\t\treturn 0;\n\n\tif (!test_bit(NFCMRVL_NCI_RUNNING, &drv_data->flags))\n\t\tgoto done;\n\n\tif (test_bit(NFCMRVL_USB_BULK_RUNNING, &drv_data->flags)) {\n\t\terr = nfcmrvl_submit_bulk_urb(drv_data, GFP_NOIO);\n\t\tif (err) {\n\t\t\tclear_bit(NFCMRVL_USB_BULK_RUNNING, &drv_data->flags);\n\t\t\tgoto failed;\n\t\t}\n\n\t\tnfcmrvl_submit_bulk_urb(drv_data, GFP_NOIO);\n\t}\n\n\tspin_lock_irq(&drv_data->txlock);\n\tnfcmrvl_play_deferred(drv_data);\n\tclear_bit(NFCMRVL_USB_SUSPENDING, &drv_data->flags);\n\tspin_unlock_irq(&drv_data->txlock);\n\n\treturn 0;\n\nfailed:\n\tusb_scuttle_anchored_urbs(&drv_data->deferred);\ndone:\n\tspin_lock_irq(&drv_data->txlock);\n\tclear_bit(NFCMRVL_USB_SUSPENDING, &drv_data->flags);\n\tspin_unlock_irq(&drv_data->txlock);\n\n\treturn err;\n}\n#endif\n\nstatic struct usb_driver nfcmrvl_usb_driver = {\n\t.name\t\t= \"nfcmrvl\",\n\t.probe\t\t= nfcmrvl_probe,\n\t.disconnect\t= nfcmrvl_disconnect,\n#ifdef CONFIG_PM\n\t.suspend\t= nfcmrvl_suspend,\n\t.resume\t\t= nfcmrvl_resume,\n\t.reset_resume\t= nfcmrvl_resume,\n#endif\n\t.id_table\t= nfcmrvl_table,\n\t.supports_autosuspend = 1,\n\t.disable_hub_initiated_lpm = 1,\n\t.soft_unbind = 1,\n};\nmodule_usb_driver(nfcmrvl_usb_driver);\n\nMODULE_AUTHOR(\"Marvell International Ltd.\");\nMODULE_DESCRIPTION(\"Marvell NFC-over-USB driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}