{
  "module_name": "uart.c",
  "hash_id": "eb81e4aaf3793e71c0be7f3f0dce615b791063921b54775236c687c32ae320b4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nfc/nfcmrvl/uart.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/of_gpio.h>\n#include <net/nfc/nci.h>\n#include <net/nfc/nci_core.h>\n#include \"nfcmrvl.h\"\n\nstatic unsigned int hci_muxed;\nstatic unsigned int flow_control;\nstatic unsigned int break_control;\nstatic int reset_n_io = -EINVAL;\n\n \n\nstatic int nfcmrvl_uart_nci_open(struct nfcmrvl_private *priv)\n{\n\treturn 0;\n}\n\nstatic int nfcmrvl_uart_nci_close(struct nfcmrvl_private *priv)\n{\n\treturn 0;\n}\n\nstatic int nfcmrvl_uart_nci_send(struct nfcmrvl_private *priv,\n\t\t\t\t struct sk_buff *skb)\n{\n\tstruct nci_uart *nu = priv->drv_data;\n\n\treturn nu->ops.send(nu, skb);\n}\n\nstatic void nfcmrvl_uart_nci_update_config(struct nfcmrvl_private *priv,\n\t\t\t\t\t   const void *param)\n{\n\tstruct nci_uart *nu = priv->drv_data;\n\tconst struct nfcmrvl_fw_uart_config *config = param;\n\n\tnci_uart_set_config(nu, le32_to_cpu(config->baudrate),\n\t\t\t    config->flow_control);\n}\n\nstatic const struct nfcmrvl_if_ops uart_ops = {\n\t.nci_open = nfcmrvl_uart_nci_open,\n\t.nci_close = nfcmrvl_uart_nci_close,\n\t.nci_send = nfcmrvl_uart_nci_send,\n\t.nci_update_config = nfcmrvl_uart_nci_update_config\n};\n\nstatic int nfcmrvl_uart_parse_dt(struct device_node *node,\n\t\t\t\t struct nfcmrvl_platform_data *pdata)\n{\n\tstruct device_node *matched_node;\n\tint ret;\n\n\tmatched_node = of_get_compatible_child(node, \"marvell,nfc-uart\");\n\tif (!matched_node) {\n\t\tmatched_node = of_get_compatible_child(node, \"mrvl,nfc-uart\");\n\t\tif (!matched_node)\n\t\t\treturn -ENODEV;\n\t}\n\n\tret = nfcmrvl_parse_dt(matched_node, pdata);\n\tif (ret < 0) {\n\t\tpr_err(\"Failed to get generic entries\\n\");\n\t\tof_node_put(matched_node);\n\t\treturn ret;\n\t}\n\n\tpdata->flow_control = of_property_read_bool(matched_node, \"flow-control\");\n\tpdata->break_control = of_property_read_bool(matched_node, \"break-control\");\n\n\tof_node_put(matched_node);\n\n\treturn 0;\n}\n\n \n\nstatic int nfcmrvl_nci_uart_open(struct nci_uart *nu)\n{\n\tstruct nfcmrvl_private *priv;\n\tstruct nfcmrvl_platform_data config;\n\tconst struct nfcmrvl_platform_data *pdata = NULL;\n\tstruct device *dev = nu->tty->dev;\n\n\t \n\n\tif (dev && dev->parent && dev->parent->of_node)\n\t\tif (nfcmrvl_uart_parse_dt(dev->parent->of_node, &config) == 0)\n\t\t\tpdata = &config;\n\n\tif (!pdata) {\n\t\tpr_info(\"No platform data / DT -> fallback to module params\\n\");\n\t\tconfig.hci_muxed = hci_muxed;\n\t\tconfig.reset_n_io = reset_n_io;\n\t\tconfig.flow_control = flow_control;\n\t\tconfig.break_control = break_control;\n\t\tpdata = &config;\n\t}\n\n\tpriv = nfcmrvl_nci_register_dev(NFCMRVL_PHY_UART, nu, &uart_ops,\n\t\t\t\t\tdev, pdata);\n\tif (IS_ERR(priv))\n\t\treturn PTR_ERR(priv);\n\n\tpriv->support_fw_dnld = true;\n\n\tnu->drv_data = priv;\n\tnu->ndev = priv->ndev;\n\n\treturn 0;\n}\n\nstatic void nfcmrvl_nci_uart_close(struct nci_uart *nu)\n{\n\tnfcmrvl_nci_unregister_dev((struct nfcmrvl_private *)nu->drv_data);\n}\n\nstatic int nfcmrvl_nci_uart_recv(struct nci_uart *nu, struct sk_buff *skb)\n{\n\treturn nfcmrvl_nci_recv_frame((struct nfcmrvl_private *)nu->drv_data,\n\t\t\t\t      skb);\n}\n\nstatic void nfcmrvl_nci_uart_tx_start(struct nci_uart *nu)\n{\n\tstruct nfcmrvl_private *priv = (struct nfcmrvl_private *)nu->drv_data;\n\n\tif (priv->ndev->nfc_dev->fw_download_in_progress)\n\t\treturn;\n\n\t \n\tif (priv->config.break_control && nu->tty->ops->break_ctl) {\n\t\tnu->tty->ops->break_ctl(nu->tty, 0);\n\t\tusleep_range(3000, 5000);\n\t}\n}\n\nstatic void nfcmrvl_nci_uart_tx_done(struct nci_uart *nu)\n{\n\tstruct nfcmrvl_private *priv = (struct nfcmrvl_private *)nu->drv_data;\n\n\tif (priv->ndev->nfc_dev->fw_download_in_progress)\n\t\treturn;\n\n\t \n\tif (priv->config.break_control && nu->tty->ops->break_ctl) {\n\t\tnu->tty->ops->break_ctl(nu->tty, -1);\n\t\tusleep_range(1000, 3000);\n\t}\n}\n\nstatic struct nci_uart nfcmrvl_nci_uart = {\n\t.owner  = THIS_MODULE,\n\t.name   = \"nfcmrvl_uart\",\n\t.driver = NCI_UART_DRIVER_MARVELL,\n\t.ops\t= {\n\t\t.open\t\t= nfcmrvl_nci_uart_open,\n\t\t.close\t\t= nfcmrvl_nci_uart_close,\n\t\t.recv\t\t= nfcmrvl_nci_uart_recv,\n\t\t.tx_start\t= nfcmrvl_nci_uart_tx_start,\n\t\t.tx_done\t= nfcmrvl_nci_uart_tx_done,\n\t}\n};\nmodule_driver(nfcmrvl_nci_uart, nci_uart_register, nci_uart_unregister);\n\nMODULE_AUTHOR(\"Marvell International Ltd.\");\nMODULE_DESCRIPTION(\"Marvell NFC-over-UART\");\nMODULE_LICENSE(\"GPL v2\");\n\nmodule_param(flow_control, uint, 0);\nMODULE_PARM_DESC(flow_control, \"Tell if UART needs flow control at init.\");\n\nmodule_param(break_control, uint, 0);\nMODULE_PARM_DESC(break_control, \"Tell if UART driver must drive break signal.\");\n\nmodule_param(hci_muxed, uint, 0);\nMODULE_PARM_DESC(hci_muxed, \"Tell if transport is muxed in HCI one.\");\n\nmodule_param(reset_n_io, int, 0);\nMODULE_PARM_DESC(reset_n_io, \"GPIO that is wired to RESET_N signal.\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}