{
  "module_name": "spi.c",
  "hash_id": "85a25fbe04592843ff10bbbfb0b79561358cc1ac6e1be7c7186eaa46bfef3c36",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nfc/nfcmrvl/spi.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/nfc.h>\n#include <linux/of_irq.h>\n#include <net/nfc/nci.h>\n#include <net/nfc/nci_core.h>\n#include <linux/spi/spi.h>\n#include \"nfcmrvl.h\"\n\n#define SPI_WAIT_HANDSHAKE\t1\n\nstruct nfcmrvl_spi_drv_data {\n\tunsigned long flags;\n\tstruct spi_device *spi;\n\tstruct nci_spi *nci_spi;\n\tstruct completion handshake_completion;\n\tstruct nfcmrvl_private *priv;\n};\n\nstatic irqreturn_t nfcmrvl_spi_int_irq_thread_fn(int irq, void *drv_data_ptr)\n{\n\tstruct nfcmrvl_spi_drv_data *drv_data = drv_data_ptr;\n\tstruct sk_buff *skb;\n\n\t \n\tif (test_and_clear_bit(SPI_WAIT_HANDSHAKE, &drv_data->flags)) {\n\t\tcomplete(&drv_data->handshake_completion);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\t \n\n\tskb = nci_spi_read(drv_data->nci_spi);\n\tif (!skb) {\n\t\tnfc_err(&drv_data->spi->dev, \"failed to read spi packet\");\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (nfcmrvl_nci_recv_frame(drv_data->priv, skb) < 0)\n\t\tnfc_err(&drv_data->spi->dev, \"corrupted RX packet\");\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int nfcmrvl_spi_nci_open(struct nfcmrvl_private *priv)\n{\n\treturn 0;\n}\n\nstatic int nfcmrvl_spi_nci_close(struct nfcmrvl_private *priv)\n{\n\treturn 0;\n}\n\nstatic int nfcmrvl_spi_nci_send(struct nfcmrvl_private *priv,\n\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct nfcmrvl_spi_drv_data *drv_data = priv->drv_data;\n\tint err;\n\n\t \n\treinit_completion(&drv_data->handshake_completion);\n\tset_bit(SPI_WAIT_HANDSHAKE, &drv_data->flags);\n\n\t \n\tskb_put(skb, 1);\n\n\t \n\terr = nci_spi_send(drv_data->nci_spi, &drv_data->handshake_completion,\n\t\t\t   skb);\n\tif (err)\n\t\tnfc_err(priv->dev, \"spi_send failed %d\", err);\n\n\treturn err;\n}\n\nstatic void nfcmrvl_spi_nci_update_config(struct nfcmrvl_private *priv,\n\t\t\t\t\t  const void *param)\n{\n\tstruct nfcmrvl_spi_drv_data *drv_data = priv->drv_data;\n\tconst struct nfcmrvl_fw_spi_config *config = param;\n\n\tdrv_data->nci_spi->xfer_speed_hz = config->clk;\n}\n\nstatic const struct nfcmrvl_if_ops spi_ops = {\n\t.nci_open = nfcmrvl_spi_nci_open,\n\t.nci_close = nfcmrvl_spi_nci_close,\n\t.nci_send = nfcmrvl_spi_nci_send,\n\t.nci_update_config = nfcmrvl_spi_nci_update_config,\n};\n\nstatic int nfcmrvl_spi_parse_dt(struct device_node *node,\n\t\t\t\tstruct nfcmrvl_platform_data *pdata)\n{\n\tint ret;\n\n\tret = nfcmrvl_parse_dt(node, pdata);\n\tif (ret < 0) {\n\t\tpr_err(\"Failed to get generic entries\\n\");\n\t\treturn ret;\n\t}\n\n\tret = irq_of_parse_and_map(node, 0);\n\tif (!ret) {\n\t\tpr_err(\"Unable to get irq\\n\");\n\t\treturn -EINVAL;\n\t}\n\tpdata->irq = ret;\n\n\treturn 0;\n}\n\nstatic int nfcmrvl_spi_probe(struct spi_device *spi)\n{\n\tconst struct nfcmrvl_platform_data *pdata;\n\tstruct nfcmrvl_platform_data config;\n\tstruct nfcmrvl_spi_drv_data *drv_data;\n\tint ret = 0;\n\n\tdrv_data = devm_kzalloc(&spi->dev, sizeof(*drv_data), GFP_KERNEL);\n\tif (!drv_data)\n\t\treturn -ENOMEM;\n\n\tdrv_data->spi = spi;\n\tdrv_data->priv = NULL;\n\tspi_set_drvdata(spi, drv_data);\n\n\tpdata = spi->dev.platform_data;\n\n\tif (!pdata && spi->dev.of_node)\n\t\tif (nfcmrvl_spi_parse_dt(spi->dev.of_node, &config) == 0)\n\t\t\tpdata = &config;\n\n\tif (!pdata)\n\t\treturn -EINVAL;\n\n\tret = devm_request_threaded_irq(&drv_data->spi->dev, pdata->irq,\n\t\t\t\t\tNULL, nfcmrvl_spi_int_irq_thread_fn,\n\t\t\t\t\tIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\n\t\t\t\t\t\"nfcmrvl_spi_int\", drv_data);\n\tif (ret < 0) {\n\t\tnfc_err(&drv_data->spi->dev, \"Unable to register IRQ handler\");\n\t\treturn -ENODEV;\n\t}\n\n\tdrv_data->priv = nfcmrvl_nci_register_dev(NFCMRVL_PHY_SPI,\n\t\t\t\t\t\t  drv_data, &spi_ops,\n\t\t\t\t\t\t  &drv_data->spi->dev,\n\t\t\t\t\t\t  pdata);\n\tif (IS_ERR(drv_data->priv))\n\t\treturn PTR_ERR(drv_data->priv);\n\n\tdrv_data->priv->support_fw_dnld = true;\n\n\tdrv_data->nci_spi = nci_spi_allocate_spi(drv_data->spi, 0, 10,\n\t\t\t\t\t\t drv_data->priv->ndev);\n\n\t \n\tinit_completion(&drv_data->handshake_completion);\n\treturn 0;\n}\n\nstatic void nfcmrvl_spi_remove(struct spi_device *spi)\n{\n\tstruct nfcmrvl_spi_drv_data *drv_data = spi_get_drvdata(spi);\n\n\tnfcmrvl_nci_unregister_dev(drv_data->priv);\n}\n\nstatic const struct of_device_id of_nfcmrvl_spi_match[] __maybe_unused = {\n\t{ .compatible = \"marvell,nfc-spi\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, of_nfcmrvl_spi_match);\n\nstatic const struct spi_device_id nfcmrvl_spi_id_table[] = {\n\t{ \"nfcmrvl_spi\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(spi, nfcmrvl_spi_id_table);\n\nstatic struct spi_driver nfcmrvl_spi_driver = {\n\t.probe\t\t= nfcmrvl_spi_probe,\n\t.remove\t\t= nfcmrvl_spi_remove,\n\t.id_table\t= nfcmrvl_spi_id_table,\n\t.driver\t\t= {\n\t\t.name\t\t= \"nfcmrvl_spi\",\n\t\t.owner\t\t= THIS_MODULE,\n\t\t.of_match_table\t= of_match_ptr(of_nfcmrvl_spi_match),\n\t},\n};\n\nmodule_spi_driver(nfcmrvl_spi_driver);\n\nMODULE_AUTHOR(\"Marvell International Ltd.\");\nMODULE_DESCRIPTION(\"Marvell NFC-over-SPI driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}