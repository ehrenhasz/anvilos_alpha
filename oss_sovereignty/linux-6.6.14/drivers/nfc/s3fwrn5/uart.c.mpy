{
  "module_name": "uart.c",
  "hash_id": "a3f840726cb2698fb771ba97500ec414d0c64da95bf5dcb22bff52478ba8949e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nfc/s3fwrn5/uart.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/nfc.h>\n#include <linux/netdevice.h>\n#include <linux/of.h>\n#include <linux/serdev.h>\n#include <linux/gpio.h>\n#include <linux/of_gpio.h>\n\n#include \"phy_common.h\"\n\n#define S3FWRN82_NCI_HEADER 3\n#define S3FWRN82_NCI_IDX 2\n#define NCI_SKB_BUFF_LEN 258\n\nstruct s3fwrn82_uart_phy {\n\tstruct phy_common common;\n\tstruct serdev_device *ser_dev;\n\tstruct sk_buff *recv_skb;\n};\n\nstatic int s3fwrn82_uart_write(void *phy_id, struct sk_buff *out)\n{\n\tstruct s3fwrn82_uart_phy *phy = phy_id;\n\tint err;\n\n\terr = serdev_device_write(phy->ser_dev,\n\t\t\t\t  out->data, out->len,\n\t\t\t\t  MAX_SCHEDULE_TIMEOUT);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic const struct s3fwrn5_phy_ops uart_phy_ops = {\n\t.set_wake = s3fwrn5_phy_set_wake,\n\t.set_mode = s3fwrn5_phy_set_mode,\n\t.get_mode = s3fwrn5_phy_get_mode,\n\t.write = s3fwrn82_uart_write,\n};\n\nstatic int s3fwrn82_uart_read(struct serdev_device *serdev,\n\t\t\t      const unsigned char *data,\n\t\t\t      size_t count)\n{\n\tstruct s3fwrn82_uart_phy *phy = serdev_device_get_drvdata(serdev);\n\tsize_t i;\n\n\tfor (i = 0; i < count; i++) {\n\t\tskb_put_u8(phy->recv_skb, *data++);\n\n\t\tif (phy->recv_skb->len < S3FWRN82_NCI_HEADER)\n\t\t\tcontinue;\n\n\t\tif ((phy->recv_skb->len - S3FWRN82_NCI_HEADER)\n\t\t\t\t< phy->recv_skb->data[S3FWRN82_NCI_IDX])\n\t\t\tcontinue;\n\n\t\ts3fwrn5_recv_frame(phy->common.ndev, phy->recv_skb,\n\t\t\t\t   phy->common.mode);\n\t\tphy->recv_skb = alloc_skb(NCI_SKB_BUFF_LEN, GFP_KERNEL);\n\t\tif (!phy->recv_skb)\n\t\t\treturn 0;\n\t}\n\n\treturn i;\n}\n\nstatic const struct serdev_device_ops s3fwrn82_serdev_ops = {\n\t.receive_buf = s3fwrn82_uart_read,\n\t.write_wakeup = serdev_device_write_wakeup,\n};\n\nstatic const struct of_device_id s3fwrn82_uart_of_match[] = {\n\t{ .compatible = \"samsung,s3fwrn82\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, s3fwrn82_uart_of_match);\n\nstatic int s3fwrn82_uart_parse_dt(struct serdev_device *serdev)\n{\n\tstruct s3fwrn82_uart_phy *phy = serdev_device_get_drvdata(serdev);\n\tstruct device_node *np = serdev->dev.of_node;\n\n\tif (!np)\n\t\treturn -ENODEV;\n\n\tphy->common.gpio_en = of_get_named_gpio(np, \"en-gpios\", 0);\n\tif (!gpio_is_valid(phy->common.gpio_en))\n\t\treturn -ENODEV;\n\n\tphy->common.gpio_fw_wake = of_get_named_gpio(np, \"wake-gpios\", 0);\n\tif (!gpio_is_valid(phy->common.gpio_fw_wake))\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic int s3fwrn82_uart_probe(struct serdev_device *serdev)\n{\n\tstruct s3fwrn82_uart_phy *phy;\n\tint ret = -ENOMEM;\n\n\tphy = devm_kzalloc(&serdev->dev, sizeof(*phy), GFP_KERNEL);\n\tif (!phy)\n\t\tgoto err_exit;\n\n\tphy->recv_skb = alloc_skb(NCI_SKB_BUFF_LEN, GFP_KERNEL);\n\tif (!phy->recv_skb)\n\t\tgoto err_exit;\n\n\tmutex_init(&phy->common.mutex);\n\tphy->common.mode = S3FWRN5_MODE_COLD;\n\n\tphy->ser_dev = serdev;\n\tserdev_device_set_drvdata(serdev, phy);\n\tserdev_device_set_client_ops(serdev, &s3fwrn82_serdev_ops);\n\tret = serdev_device_open(serdev);\n\tif (ret) {\n\t\tdev_err(&serdev->dev, \"Unable to open device\\n\");\n\t\tgoto err_skb;\n\t}\n\n\tret = serdev_device_set_baudrate(serdev, 115200);\n\tif (ret != 115200) {\n\t\tret = -EINVAL;\n\t\tgoto err_serdev;\n\t}\n\n\tserdev_device_set_flow_control(serdev, false);\n\n\tret = s3fwrn82_uart_parse_dt(serdev);\n\tif (ret < 0)\n\t\tgoto err_serdev;\n\n\tret = devm_gpio_request_one(&phy->ser_dev->dev, phy->common.gpio_en,\n\t\t\t\t    GPIOF_OUT_INIT_HIGH, \"s3fwrn82_en\");\n\tif (ret < 0)\n\t\tgoto err_serdev;\n\n\tret = devm_gpio_request_one(&phy->ser_dev->dev,\n\t\t\t\t    phy->common.gpio_fw_wake,\n\t\t\t\t    GPIOF_OUT_INIT_LOW, \"s3fwrn82_fw_wake\");\n\tif (ret < 0)\n\t\tgoto err_serdev;\n\n\tret = s3fwrn5_probe(&phy->common.ndev, phy, &phy->ser_dev->dev,\n\t\t\t    &uart_phy_ops);\n\tif (ret < 0)\n\t\tgoto err_serdev;\n\n\treturn ret;\n\nerr_serdev:\n\tserdev_device_close(serdev);\nerr_skb:\n\tkfree_skb(phy->recv_skb);\nerr_exit:\n\treturn ret;\n}\n\nstatic void s3fwrn82_uart_remove(struct serdev_device *serdev)\n{\n\tstruct s3fwrn82_uart_phy *phy = serdev_device_get_drvdata(serdev);\n\n\ts3fwrn5_remove(phy->common.ndev);\n\tserdev_device_close(serdev);\n\tkfree_skb(phy->recv_skb);\n}\n\nstatic struct serdev_device_driver s3fwrn82_uart_driver = {\n\t.probe = s3fwrn82_uart_probe,\n\t.remove = s3fwrn82_uart_remove,\n\t.driver = {\n\t\t.name = \"s3fwrn82_uart\",\n\t\t.of_match_table = s3fwrn82_uart_of_match,\n\t},\n};\n\nmodule_serdev_device_driver(s3fwrn82_uart_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"UART driver for Samsung NFC\");\nMODULE_AUTHOR(\"Bongsu Jeon <bongsu.jeon@samsung.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}