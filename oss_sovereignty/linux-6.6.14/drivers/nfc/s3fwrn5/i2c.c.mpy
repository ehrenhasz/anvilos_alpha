{
  "module_name": "i2c.c",
  "hash_id": "8b74c53de91e37653a43952acab91be536d9e2efa565604d68bc396fbb9f4fe0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nfc/s3fwrn5/i2c.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/i2c.h>\n#include <linux/gpio.h>\n#include <linux/delay.h>\n#include <linux/of_gpio.h>\n#include <linux/of_irq.h>\n#include <linux/module.h>\n\n#include <net/nfc/nfc.h>\n\n#include \"phy_common.h\"\n\n#define S3FWRN5_I2C_DRIVER_NAME \"s3fwrn5_i2c\"\n\nstruct s3fwrn5_i2c_phy {\n\tstruct phy_common common;\n\tstruct i2c_client *i2c_dev;\n\tstruct clk *clk;\n\n\tunsigned int irq_skip:1;\n};\n\nstatic void s3fwrn5_i2c_set_mode(void *phy_id, enum s3fwrn5_mode mode)\n{\n\tstruct s3fwrn5_i2c_phy *phy = phy_id;\n\n\tmutex_lock(&phy->common.mutex);\n\n\tif (s3fwrn5_phy_power_ctrl(&phy->common, mode) == false)\n\t\tgoto out;\n\n\tphy->irq_skip = true;\n\nout:\n\tmutex_unlock(&phy->common.mutex);\n}\n\nstatic int s3fwrn5_i2c_write(void *phy_id, struct sk_buff *skb)\n{\n\tstruct s3fwrn5_i2c_phy *phy = phy_id;\n\tint ret;\n\n\tmutex_lock(&phy->common.mutex);\n\n\tphy->irq_skip = false;\n\n\tret = i2c_master_send(phy->i2c_dev, skb->data, skb->len);\n\tif (ret == -EREMOTEIO) {\n\t\t \n\t\tusleep_range(110000, 120000);\n\t\tret  = i2c_master_send(phy->i2c_dev, skb->data, skb->len);\n\t}\n\n\tmutex_unlock(&phy->common.mutex);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret != skb->len)\n\t\treturn -EREMOTEIO;\n\n\treturn 0;\n}\n\nstatic const struct s3fwrn5_phy_ops i2c_phy_ops = {\n\t.set_wake = s3fwrn5_phy_set_wake,\n\t.set_mode = s3fwrn5_i2c_set_mode,\n\t.get_mode = s3fwrn5_phy_get_mode,\n\t.write = s3fwrn5_i2c_write,\n};\n\nstatic int s3fwrn5_i2c_read(struct s3fwrn5_i2c_phy *phy)\n{\n\tstruct sk_buff *skb;\n\tsize_t hdr_size;\n\tsize_t data_len;\n\tchar hdr[4];\n\tint ret;\n\n\thdr_size = (phy->common.mode == S3FWRN5_MODE_NCI) ?\n\t\tNCI_CTRL_HDR_SIZE : S3FWRN5_FW_HDR_SIZE;\n\tret = i2c_master_recv(phy->i2c_dev, hdr, hdr_size);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret < hdr_size)\n\t\treturn -EBADMSG;\n\n\tdata_len = (phy->common.mode == S3FWRN5_MODE_NCI) ?\n\t\t((struct nci_ctrl_hdr *)hdr)->plen :\n\t\t((struct s3fwrn5_fw_header *)hdr)->len;\n\n\tskb = alloc_skb(hdr_size + data_len, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_put_data(skb, hdr, hdr_size);\n\n\tif (data_len == 0)\n\t\tgoto out;\n\n\tret = i2c_master_recv(phy->i2c_dev, skb_put(skb, data_len), data_len);\n\tif (ret != data_len) {\n\t\tkfree_skb(skb);\n\t\treturn -EBADMSG;\n\t}\n\nout:\n\treturn s3fwrn5_recv_frame(phy->common.ndev, skb, phy->common.mode);\n}\n\nstatic irqreturn_t s3fwrn5_i2c_irq_thread_fn(int irq, void *phy_id)\n{\n\tstruct s3fwrn5_i2c_phy *phy = phy_id;\n\n\tif (!phy || !phy->common.ndev) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn IRQ_NONE;\n\t}\n\n\tmutex_lock(&phy->common.mutex);\n\n\tif (phy->irq_skip)\n\t\tgoto out;\n\n\tswitch (phy->common.mode) {\n\tcase S3FWRN5_MODE_NCI:\n\tcase S3FWRN5_MODE_FW:\n\t\ts3fwrn5_i2c_read(phy);\n\t\tbreak;\n\tcase S3FWRN5_MODE_COLD:\n\t\tbreak;\n\t}\n\nout:\n\tmutex_unlock(&phy->common.mutex);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int s3fwrn5_i2c_parse_dt(struct i2c_client *client)\n{\n\tstruct s3fwrn5_i2c_phy *phy = i2c_get_clientdata(client);\n\tstruct device_node *np = client->dev.of_node;\n\n\tif (!np)\n\t\treturn -ENODEV;\n\n\tphy->common.gpio_en = of_get_named_gpio(np, \"en-gpios\", 0);\n\tif (!gpio_is_valid(phy->common.gpio_en)) {\n\t\t \n\t\tphy->common.gpio_en = of_get_named_gpio(np,\n\t\t\t\t\t\t\t\"s3fwrn5,en-gpios\",\n\t\t\t\t\t\t\t0);\n\t\tif (!gpio_is_valid(phy->common.gpio_en))\n\t\t\treturn -ENODEV;\n\t}\n\n\tphy->common.gpio_fw_wake = of_get_named_gpio(np, \"wake-gpios\", 0);\n\tif (!gpio_is_valid(phy->common.gpio_fw_wake)) {\n\t\t \n\t\tphy->common.gpio_fw_wake = of_get_named_gpio(np,\n\t\t\t\t\t\t\t     \"s3fwrn5,fw-gpios\",\n\t\t\t\t\t\t\t     0);\n\t\tif (!gpio_is_valid(phy->common.gpio_fw_wake))\n\t\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int s3fwrn5_i2c_probe(struct i2c_client *client)\n{\n\tstruct s3fwrn5_i2c_phy *phy;\n\tint ret;\n\n\tphy = devm_kzalloc(&client->dev, sizeof(*phy), GFP_KERNEL);\n\tif (!phy)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&phy->common.mutex);\n\tphy->common.mode = S3FWRN5_MODE_COLD;\n\tphy->irq_skip = true;\n\n\tphy->i2c_dev = client;\n\ti2c_set_clientdata(client, phy);\n\n\tret = s3fwrn5_i2c_parse_dt(client);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = devm_gpio_request_one(&phy->i2c_dev->dev, phy->common.gpio_en,\n\t\t\t\t    GPIOF_OUT_INIT_HIGH, \"s3fwrn5_en\");\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = devm_gpio_request_one(&phy->i2c_dev->dev,\n\t\t\t\t    phy->common.gpio_fw_wake,\n\t\t\t\t    GPIOF_OUT_INIT_LOW, \"s3fwrn5_fw_wake\");\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tphy->clk = devm_clk_get_optional_enabled(&client->dev, NULL);\n\tif (IS_ERR(phy->clk))\n\t\treturn dev_err_probe(&client->dev, PTR_ERR(phy->clk),\n\t\t\t\t     \"failed to get clock\\n\");\n\n\tret = s3fwrn5_probe(&phy->common.ndev, phy, &phy->i2c_dev->dev,\n\t\t\t    &i2c_phy_ops);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = devm_request_threaded_irq(&client->dev, phy->i2c_dev->irq, NULL,\n\t\ts3fwrn5_i2c_irq_thread_fn, IRQF_ONESHOT,\n\t\tS3FWRN5_I2C_DRIVER_NAME, phy);\n\tif (ret)\n\t\tgoto s3fwrn5_remove;\n\n\treturn 0;\n\ns3fwrn5_remove:\n\ts3fwrn5_remove(phy->common.ndev);\n\treturn ret;\n}\n\nstatic void s3fwrn5_i2c_remove(struct i2c_client *client)\n{\n\tstruct s3fwrn5_i2c_phy *phy = i2c_get_clientdata(client);\n\n\ts3fwrn5_remove(phy->common.ndev);\n}\n\nstatic const struct i2c_device_id s3fwrn5_i2c_id_table[] = {\n\t{S3FWRN5_I2C_DRIVER_NAME, 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, s3fwrn5_i2c_id_table);\n\nstatic const struct of_device_id of_s3fwrn5_i2c_match[] __maybe_unused = {\n\t{ .compatible = \"samsung,s3fwrn5-i2c\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, of_s3fwrn5_i2c_match);\n\nstatic struct i2c_driver s3fwrn5_i2c_driver = {\n\t.driver = {\n\t\t.name = S3FWRN5_I2C_DRIVER_NAME,\n\t\t.of_match_table = of_match_ptr(of_s3fwrn5_i2c_match),\n\t},\n\t.probe = s3fwrn5_i2c_probe,\n\t.remove = s3fwrn5_i2c_remove,\n\t.id_table = s3fwrn5_i2c_id_table,\n};\n\nmodule_i2c_driver(s3fwrn5_i2c_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"I2C driver for Samsung S3FWRN5\");\nMODULE_AUTHOR(\"Robert Baldyga <r.baldyga@samsung.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}