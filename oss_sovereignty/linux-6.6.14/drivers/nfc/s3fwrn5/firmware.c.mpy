{
  "module_name": "firmware.c",
  "hash_id": "d0d5fdcfb2752f70c620cef7614c42783d5cabd13b1f3da9c267bd0a471c2abb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nfc/s3fwrn5/firmware.c",
  "human_readable_source": "\n \n\n#include <linux/completion.h>\n#include <linux/firmware.h>\n#include <crypto/hash.h>\n#include <crypto/sha1.h>\n\n#include \"s3fwrn5.h\"\n#include \"firmware.h\"\n\nstruct s3fwrn5_fw_version {\n\t__u8 major;\n\t__u8 build1;\n\t__u8 build2;\n\t__u8 target;\n};\n\nstatic int s3fwrn5_fw_send_msg(struct s3fwrn5_fw_info *fw_info,\n\tstruct sk_buff *msg, struct sk_buff **rsp)\n{\n\tstruct s3fwrn5_info *info =\n\t\tcontainer_of(fw_info, struct s3fwrn5_info, fw_info);\n\tlong ret;\n\n\treinit_completion(&fw_info->completion);\n\n\tret = s3fwrn5_write(info, msg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = wait_for_completion_interruptible_timeout(\n\t\t&fw_info->completion, msecs_to_jiffies(1000));\n\tif (ret < 0)\n\t\treturn ret;\n\telse if (ret == 0)\n\t\treturn -ENXIO;\n\n\tif (!fw_info->rsp)\n\t\treturn -EINVAL;\n\n\t*rsp = fw_info->rsp;\n\tfw_info->rsp = NULL;\n\n\treturn 0;\n}\n\nstatic int s3fwrn5_fw_prep_msg(struct s3fwrn5_fw_info *fw_info,\n\tstruct sk_buff **msg, u8 type, u8 code, const void *data, u16 len)\n{\n\tstruct s3fwrn5_fw_header hdr;\n\tstruct sk_buff *skb;\n\n\thdr.type = type | fw_info->parity;\n\tfw_info->parity ^= 0x80;\n\thdr.code = code;\n\thdr.len = len;\n\n\tskb = alloc_skb(S3FWRN5_FW_HDR_SIZE + len, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_put_data(skb, &hdr, S3FWRN5_FW_HDR_SIZE);\n\tif (len)\n\t\tskb_put_data(skb, data, len);\n\n\t*msg = skb;\n\n\treturn 0;\n}\n\nstatic int s3fwrn5_fw_get_bootinfo(struct s3fwrn5_fw_info *fw_info,\n\tstruct s3fwrn5_fw_cmd_get_bootinfo_rsp *bootinfo)\n{\n\tstruct sk_buff *msg, *rsp = NULL;\n\tstruct s3fwrn5_fw_header *hdr;\n\tint ret;\n\n\t \n\n\tret = s3fwrn5_fw_prep_msg(fw_info, &msg, S3FWRN5_FW_MSG_CMD,\n\t\tS3FWRN5_FW_CMD_GET_BOOTINFO, NULL, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = s3fwrn5_fw_send_msg(fw_info, msg, &rsp);\n\tkfree_skb(msg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\thdr = (struct s3fwrn5_fw_header *) rsp->data;\n\tif (hdr->code != S3FWRN5_FW_RET_SUCCESS) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmemcpy(bootinfo, rsp->data + S3FWRN5_FW_HDR_SIZE, 10);\n\nout:\n\tkfree_skb(rsp);\n\treturn ret;\n}\n\nstatic int s3fwrn5_fw_enter_update_mode(struct s3fwrn5_fw_info *fw_info,\n\tconst void *hash_data, u16 hash_size,\n\tconst void *sig_data, u16 sig_size)\n{\n\tstruct s3fwrn5_fw_cmd_enter_updatemode args;\n\tstruct sk_buff *msg, *rsp = NULL;\n\tstruct s3fwrn5_fw_header *hdr;\n\tint ret;\n\n\t \n\n\targs.hashcode_size = hash_size;\n\targs.signature_size = sig_size;\n\n\tret = s3fwrn5_fw_prep_msg(fw_info, &msg, S3FWRN5_FW_MSG_CMD,\n\t\tS3FWRN5_FW_CMD_ENTER_UPDATE_MODE, &args, sizeof(args));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = s3fwrn5_fw_send_msg(fw_info, msg, &rsp);\n\tkfree_skb(msg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\thdr = (struct s3fwrn5_fw_header *) rsp->data;\n\tif (hdr->code != S3FWRN5_FW_RET_SUCCESS) {\n\t\tret = -EPROTO;\n\t\tgoto out;\n\t}\n\n\tkfree_skb(rsp);\n\n\t \n\n\tret = s3fwrn5_fw_prep_msg(fw_info, &msg, S3FWRN5_FW_MSG_DATA, 0,\n\t\thash_data, hash_size);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = s3fwrn5_fw_send_msg(fw_info, msg, &rsp);\n\tkfree_skb(msg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\thdr = (struct s3fwrn5_fw_header *) rsp->data;\n\tif (hdr->code != S3FWRN5_FW_RET_SUCCESS) {\n\t\tret = -EPROTO;\n\t\tgoto out;\n\t}\n\n\tkfree_skb(rsp);\n\n\t \n\n\tret = s3fwrn5_fw_prep_msg(fw_info, &msg, S3FWRN5_FW_MSG_DATA, 0,\n\t\tsig_data, sig_size);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = s3fwrn5_fw_send_msg(fw_info, msg, &rsp);\n\tkfree_skb(msg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\thdr = (struct s3fwrn5_fw_header *) rsp->data;\n\tif (hdr->code != S3FWRN5_FW_RET_SUCCESS)\n\t\tret = -EPROTO;\n\nout:\n\tkfree_skb(rsp);\n\treturn ret;\n}\n\nstatic int s3fwrn5_fw_update_sector(struct s3fwrn5_fw_info *fw_info,\n\tu32 base_addr, const void *data)\n{\n\tstruct s3fwrn5_fw_cmd_update_sector args;\n\tstruct sk_buff *msg, *rsp = NULL;\n\tstruct s3fwrn5_fw_header *hdr;\n\tint ret, i;\n\n\t \n\n\targs.base_address = base_addr;\n\n\tret = s3fwrn5_fw_prep_msg(fw_info, &msg, S3FWRN5_FW_MSG_CMD,\n\t\tS3FWRN5_FW_CMD_UPDATE_SECTOR, &args, sizeof(args));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = s3fwrn5_fw_send_msg(fw_info, msg, &rsp);\n\tkfree_skb(msg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\thdr = (struct s3fwrn5_fw_header *) rsp->data;\n\tif (hdr->code != S3FWRN5_FW_RET_SUCCESS) {\n\t\tret = -EPROTO;\n\t\tgoto err;\n\t}\n\n\tkfree_skb(rsp);\n\n\t \n\n\tfor (i = 0; i < 16; ++i) {\n\t\tret = s3fwrn5_fw_prep_msg(fw_info, &msg,\n\t\t\tS3FWRN5_FW_MSG_DATA, 0, data+256*i, 256);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tret = s3fwrn5_fw_send_msg(fw_info, msg, &rsp);\n\t\tkfree_skb(msg);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\thdr = (struct s3fwrn5_fw_header *) rsp->data;\n\t\tif (hdr->code != S3FWRN5_FW_RET_SUCCESS) {\n\t\t\tret = -EPROTO;\n\t\t\tgoto err;\n\t\t}\n\n\t\tkfree_skb(rsp);\n\t}\n\n\treturn ret;\n\nerr:\n\tkfree_skb(rsp);\n\treturn ret;\n}\n\nstatic int s3fwrn5_fw_complete_update_mode(struct s3fwrn5_fw_info *fw_info)\n{\n\tstruct sk_buff *msg, *rsp = NULL;\n\tstruct s3fwrn5_fw_header *hdr;\n\tint ret;\n\n\t \n\n\tret = s3fwrn5_fw_prep_msg(fw_info, &msg, S3FWRN5_FW_MSG_CMD,\n\t\tS3FWRN5_FW_CMD_COMPLETE_UPDATE_MODE, NULL, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = s3fwrn5_fw_send_msg(fw_info, msg, &rsp);\n\tkfree_skb(msg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\thdr = (struct s3fwrn5_fw_header *) rsp->data;\n\tif (hdr->code != S3FWRN5_FW_RET_SUCCESS)\n\t\tret = -EPROTO;\n\n\tkfree_skb(rsp);\n\n\treturn ret;\n}\n\n \n\n#define S3FWRN5_FW_IMAGE_HEADER_SIZE 44\n\nint s3fwrn5_fw_request_firmware(struct s3fwrn5_fw_info *fw_info)\n{\n\tstruct s3fwrn5_fw_image *fw = &fw_info->fw;\n\tu32 sig_off;\n\tu32 image_off;\n\tu32 custom_sig_off;\n\tint ret;\n\n\tret = request_firmware(&fw->fw, fw_info->fw_name,\n\t\t&fw_info->ndev->nfc_dev->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (fw->fw->size < S3FWRN5_FW_IMAGE_HEADER_SIZE) {\n\t\trelease_firmware(fw->fw);\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(fw->date, fw->fw->data + 0x00, 12);\n\tfw->date[12] = '\\0';\n\n\tmemcpy(&fw->version, fw->fw->data + 0x10, 4);\n\n\tmemcpy(&sig_off, fw->fw->data + 0x14, 4);\n\tfw->sig = fw->fw->data + sig_off;\n\tmemcpy(&fw->sig_size, fw->fw->data + 0x18, 4);\n\n\tmemcpy(&image_off, fw->fw->data + 0x1C, 4);\n\tfw->image = fw->fw->data + image_off;\n\tmemcpy(&fw->image_sectors, fw->fw->data + 0x20, 4);\n\n\tmemcpy(&custom_sig_off, fw->fw->data + 0x24, 4);\n\tfw->custom_sig = fw->fw->data + custom_sig_off;\n\tmemcpy(&fw->custom_sig_size, fw->fw->data + 0x28, 4);\n\n\treturn 0;\n}\n\nstatic void s3fwrn5_fw_release_firmware(struct s3fwrn5_fw_info *fw_info)\n{\n\trelease_firmware(fw_info->fw.fw);\n}\n\nstatic int s3fwrn5_fw_get_base_addr(\n\tstruct s3fwrn5_fw_cmd_get_bootinfo_rsp *bootinfo, u32 *base_addr)\n{\n\tint i;\n\tstatic const struct {\n\t\tu8 version[4];\n\t\tu32 base_addr;\n\t} match[] = {\n\t\t{{0x05, 0x00, 0x00, 0x00}, 0x00005000},\n\t\t{{0x05, 0x00, 0x00, 0x01}, 0x00003000},\n\t\t{{0x05, 0x00, 0x00, 0x02}, 0x00003000},\n\t\t{{0x05, 0x00, 0x00, 0x03}, 0x00003000},\n\t\t{{0x05, 0x00, 0x00, 0x05}, 0x00003000}\n\t};\n\n\tfor (i = 0; i < ARRAY_SIZE(match); ++i)\n\t\tif (bootinfo->hw_version[0] == match[i].version[0] &&\n\t\t\tbootinfo->hw_version[1] == match[i].version[1] &&\n\t\t\tbootinfo->hw_version[3] == match[i].version[3]) {\n\t\t\t*base_addr = match[i].base_addr;\n\t\t\treturn 0;\n\t\t}\n\n\treturn -EINVAL;\n}\n\nstatic inline bool\ns3fwrn5_fw_is_custom(const struct s3fwrn5_fw_cmd_get_bootinfo_rsp *bootinfo)\n{\n\treturn !!bootinfo->hw_version[2];\n}\n\nint s3fwrn5_fw_setup(struct s3fwrn5_fw_info *fw_info)\n{\n\tstruct device *dev = &fw_info->ndev->nfc_dev->dev;\n\tstruct s3fwrn5_fw_cmd_get_bootinfo_rsp bootinfo;\n\tint ret;\n\n\t \n\n\tret = s3fwrn5_fw_get_bootinfo(fw_info, &bootinfo);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to get bootinfo, ret=%02x\\n\", ret);\n\t\tgoto err;\n\t}\n\n\t \n\n\tret = s3fwrn5_fw_get_base_addr(&bootinfo, &fw_info->base_addr);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Unknown hardware version\\n\");\n\t\tgoto err;\n\t}\n\n\tfw_info->sector_size = bootinfo.sector_size;\n\n\tfw_info->sig_size = s3fwrn5_fw_is_custom(&bootinfo) ?\n\t\tfw_info->fw.custom_sig_size : fw_info->fw.sig_size;\n\tfw_info->sig = s3fwrn5_fw_is_custom(&bootinfo) ?\n\t\tfw_info->fw.custom_sig : fw_info->fw.sig;\n\n\treturn 0;\n\nerr:\n\ts3fwrn5_fw_release_firmware(fw_info);\n\treturn ret;\n}\n\nbool s3fwrn5_fw_check_version(const struct s3fwrn5_fw_info *fw_info, u32 version)\n{\n\tstruct s3fwrn5_fw_version *new = (void *) &fw_info->fw.version;\n\tstruct s3fwrn5_fw_version *old = (void *) &version;\n\n\tif (new->major > old->major)\n\t\treturn true;\n\tif (new->build1 > old->build1)\n\t\treturn true;\n\tif (new->build2 > old->build2)\n\t\treturn true;\n\n\treturn false;\n}\n\nint s3fwrn5_fw_download(struct s3fwrn5_fw_info *fw_info)\n{\n\tstruct device *dev = &fw_info->ndev->nfc_dev->dev;\n\tstruct s3fwrn5_fw_image *fw = &fw_info->fw;\n\tu8 hash_data[SHA1_DIGEST_SIZE];\n\tstruct crypto_shash *tfm;\n\tu32 image_size, off;\n\tint ret;\n\n\timage_size = fw_info->sector_size * fw->image_sectors;\n\n\t \n\n\ttfm = crypto_alloc_shash(\"sha1\", 0, 0);\n\tif (IS_ERR(tfm)) {\n\t\tdev_err(dev, \"Cannot allocate shash (code=%pe)\\n\", tfm);\n\t\treturn PTR_ERR(tfm);\n\t}\n\n\tret = crypto_shash_tfm_digest(tfm, fw->image, image_size, hash_data);\n\n\tcrypto_free_shash(tfm);\n\tif (ret) {\n\t\tdev_err(dev, \"Cannot compute hash (code=%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\n\tdev_info(dev, \"Firmware update: %s\\n\", fw_info->fw_name);\n\n\tret = s3fwrn5_fw_enter_update_mode(fw_info, hash_data,\n\t\tSHA1_DIGEST_SIZE, fw_info->sig, fw_info->sig_size);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Unable to enter update mode\\n\");\n\t\treturn ret;\n\t}\n\n\tfor (off = 0; off < image_size; off += fw_info->sector_size) {\n\t\tret = s3fwrn5_fw_update_sector(fw_info,\n\t\t\tfw_info->base_addr + off, fw->image + off);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Firmware update error (code=%d)\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = s3fwrn5_fw_complete_update_mode(fw_info);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Unable to complete update mode\\n\");\n\t\treturn ret;\n\t}\n\n\tdev_info(dev, \"Firmware update: success\\n\");\n\n\treturn ret;\n}\n\nvoid s3fwrn5_fw_init(struct s3fwrn5_fw_info *fw_info, const char *fw_name)\n{\n\tfw_info->parity = 0x00;\n\tfw_info->rsp = NULL;\n\tfw_info->fw.fw = NULL;\n\tstrcpy(fw_info->fw_name, fw_name);\n\tinit_completion(&fw_info->completion);\n}\n\nvoid s3fwrn5_fw_cleanup(struct s3fwrn5_fw_info *fw_info)\n{\n\ts3fwrn5_fw_release_firmware(fw_info);\n}\n\nint s3fwrn5_fw_recv_frame(struct nci_dev *ndev, struct sk_buff *skb)\n{\n\tstruct s3fwrn5_info *info = nci_get_drvdata(ndev);\n\tstruct s3fwrn5_fw_info *fw_info = &info->fw_info;\n\n\tif (WARN_ON(fw_info->rsp)) {\n\t\tkfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\n\tfw_info->rsp = skb;\n\n\tcomplete(&fw_info->completion);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}