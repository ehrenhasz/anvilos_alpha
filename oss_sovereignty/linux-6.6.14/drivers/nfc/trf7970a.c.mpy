{
  "module_name": "trf7970a.c",
  "hash_id": "b85bfc6176b26c1bedadfe03261a1633d3443d8c253d0cd249192eb10afd8e6e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nfc/trf7970a.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/netdevice.h>\n#include <linux/interrupt.h>\n#include <linux/pm_runtime.h>\n#include <linux/nfc.h>\n#include <linux/skbuff.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/of.h>\n#include <linux/spi/spi.h>\n#include <linux/regulator/consumer.h>\n\n#include <net/nfc/nfc.h>\n#include <net/nfc/digital.h>\n\n \n\n#define TRF7970A_SUPPORTED_PROTOCOLS \\\n\t\t(NFC_PROTO_MIFARE_MASK | NFC_PROTO_ISO14443_MASK |\t\\\n\t\t NFC_PROTO_ISO14443_B_MASK | NFC_PROTO_FELICA_MASK | \\\n\t\t NFC_PROTO_ISO15693_MASK | NFC_PROTO_NFC_DEP_MASK)\n\n#define TRF7970A_AUTOSUSPEND_DELAY\t\t30000\t \n#define TRF7970A_13MHZ_CLOCK_FREQUENCY\t\t13560000\n#define TRF7970A_27MHZ_CLOCK_FREQUENCY\t\t27120000\n\n#define TRF7970A_RX_SKB_ALLOC_SIZE\t\t256\n\n#define TRF7970A_FIFO_SIZE\t\t\t127\n\n \n#define TRF7970A_TX_MAX\t\t\t\t(4096 - 1)\n\n#define TRF7970A_WAIT_FOR_TX_IRQ\t\t20\n#define TRF7970A_WAIT_FOR_RX_DATA_TIMEOUT\t20\n#define TRF7970A_WAIT_FOR_FIFO_DRAIN_TIMEOUT\t20\n#define TRF7970A_WAIT_TO_ISSUE_ISO15693_EOF\t40\n\n \n#define TRF7970A_GUARD_TIME_NFCA\t\t5000\n#define TRF7970A_GUARD_TIME_NFCB\t\t5000\n#define TRF7970A_GUARD_TIME_NFCF\t\t20000\n#define TRF7970A_GUARD_TIME_15693\t\t1000\n\n \n \n#define TRF7970A_QUIRK_IRQ_STATUS_READ\t\tBIT(0)\n#define TRF7970A_QUIRK_EN2_MUST_STAY_LOW\tBIT(1)\n\n \n#define TRF7970A_CMD_IDLE\t\t\t0x00\n#define TRF7970A_CMD_SOFT_INIT\t\t\t0x03\n#define TRF7970A_CMD_RF_COLLISION\t\t0x04\n#define TRF7970A_CMD_RF_COLLISION_RESPONSE_N\t0x05\n#define TRF7970A_CMD_RF_COLLISION_RESPONSE_0\t0x06\n#define TRF7970A_CMD_FIFO_RESET\t\t\t0x0f\n#define TRF7970A_CMD_TRANSMIT_NO_CRC\t\t0x10\n#define TRF7970A_CMD_TRANSMIT\t\t\t0x11\n#define TRF7970A_CMD_DELAY_TRANSMIT_NO_CRC\t0x12\n#define TRF7970A_CMD_DELAY_TRANSMIT\t\t0x13\n#define TRF7970A_CMD_EOF\t\t\t0x14\n#define TRF7970A_CMD_CLOSE_SLOT\t\t\t0x15\n#define TRF7970A_CMD_BLOCK_RX\t\t\t0x16\n#define TRF7970A_CMD_ENABLE_RX\t\t\t0x17\n#define TRF7970A_CMD_TEST_INT_RF\t\t0x18\n#define TRF7970A_CMD_TEST_EXT_RF\t\t0x19\n#define TRF7970A_CMD_RX_GAIN_ADJUST\t\t0x1a\n\n \n#define TRF7970A_CMD_BIT_CTRL\t\t\tBIT(7)\n#define TRF7970A_CMD_BIT_RW\t\t\tBIT(6)\n#define TRF7970A_CMD_BIT_CONTINUOUS\t\tBIT(5)\n#define TRF7970A_CMD_BIT_OPCODE(opcode)\t\t((opcode) & 0x1f)\n\n \n#define TRF7970A_CHIP_STATUS_CTRL\t\t0x00\n#define TRF7970A_ISO_CTRL\t\t\t0x01\n#define TRF7970A_ISO14443B_TX_OPTIONS\t\t0x02\n#define TRF7970A_ISO14443A_HIGH_BITRATE_OPTIONS\t0x03\n#define TRF7970A_TX_TIMER_SETTING_H_BYTE\t0x04\n#define TRF7970A_TX_TIMER_SETTING_L_BYTE\t0x05\n#define TRF7970A_TX_PULSE_LENGTH_CTRL\t\t0x06\n#define TRF7970A_RX_NO_RESPONSE_WAIT\t\t0x07\n#define TRF7970A_RX_WAIT_TIME\t\t\t0x08\n#define TRF7970A_MODULATOR_SYS_CLK_CTRL\t\t0x09\n#define TRF7970A_RX_SPECIAL_SETTINGS\t\t0x0a\n#define TRF7970A_REG_IO_CTRL\t\t\t0x0b\n#define TRF7970A_IRQ_STATUS\t\t\t0x0c\n#define TRF7970A_COLLISION_IRQ_MASK\t\t0x0d\n#define TRF7970A_COLLISION_POSITION\t\t0x0e\n#define TRF7970A_RSSI_OSC_STATUS\t\t0x0f\n#define TRF7970A_SPECIAL_FCN_REG1\t\t0x10\n#define TRF7970A_SPECIAL_FCN_REG2\t\t0x11\n#define TRF7970A_RAM1\t\t\t\t0x12\n#define TRF7970A_RAM2\t\t\t\t0x13\n#define TRF7970A_ADJUTABLE_FIFO_IRQ_LEVELS\t0x14\n#define TRF7970A_NFC_LOW_FIELD_LEVEL\t\t0x16\n#define TRF7970A_NFCID1\t\t\t\t0x17\n#define TRF7970A_NFC_TARGET_LEVEL\t\t0x18\n#define TRF79070A_NFC_TARGET_PROTOCOL\t\t0x19\n#define TRF7970A_TEST_REGISTER1\t\t\t0x1a\n#define TRF7970A_TEST_REGISTER2\t\t\t0x1b\n#define TRF7970A_FIFO_STATUS\t\t\t0x1c\n#define TRF7970A_TX_LENGTH_BYTE1\t\t0x1d\n#define TRF7970A_TX_LENGTH_BYTE2\t\t0x1e\n#define TRF7970A_FIFO_IO_REGISTER\t\t0x1f\n\n \n#define TRF7970A_CHIP_STATUS_VRS5_3\t\tBIT(0)\n#define TRF7970A_CHIP_STATUS_REC_ON\t\tBIT(1)\n#define TRF7970A_CHIP_STATUS_AGC_ON\t\tBIT(2)\n#define TRF7970A_CHIP_STATUS_PM_ON\t\tBIT(3)\n#define TRF7970A_CHIP_STATUS_RF_PWR\t\tBIT(4)\n#define TRF7970A_CHIP_STATUS_RF_ON\t\tBIT(5)\n#define TRF7970A_CHIP_STATUS_DIRECT\t\tBIT(6)\n#define TRF7970A_CHIP_STATUS_STBY\t\tBIT(7)\n\n \n#define TRF7970A_ISO_CTRL_15693_SGL_1OF4_662\t0x00\n#define TRF7970A_ISO_CTRL_15693_SGL_1OF256_662\t0x01\n#define TRF7970A_ISO_CTRL_15693_SGL_1OF4_2648\t0x02\n#define TRF7970A_ISO_CTRL_15693_SGL_1OF256_2648\t0x03\n#define TRF7970A_ISO_CTRL_15693_DBL_1OF4_667a\t0x04\n#define TRF7970A_ISO_CTRL_15693_DBL_1OF256_667\t0x05\n#define TRF7970A_ISO_CTRL_15693_DBL_1OF4_2669\t0x06\n#define TRF7970A_ISO_CTRL_15693_DBL_1OF256_2669\t0x07\n#define TRF7970A_ISO_CTRL_14443A_106\t\t0x08\n#define TRF7970A_ISO_CTRL_14443A_212\t\t0x09\n#define TRF7970A_ISO_CTRL_14443A_424\t\t0x0a\n#define TRF7970A_ISO_CTRL_14443A_848\t\t0x0b\n#define TRF7970A_ISO_CTRL_14443B_106\t\t0x0c\n#define TRF7970A_ISO_CTRL_14443B_212\t\t0x0d\n#define TRF7970A_ISO_CTRL_14443B_424\t\t0x0e\n#define TRF7970A_ISO_CTRL_14443B_848\t\t0x0f\n#define TRF7970A_ISO_CTRL_FELICA_212\t\t0x1a\n#define TRF7970A_ISO_CTRL_FELICA_424\t\t0x1b\n#define TRF7970A_ISO_CTRL_NFC_NFCA_106\t\t0x01\n#define TRF7970A_ISO_CTRL_NFC_NFCF_212\t\t0x02\n#define TRF7970A_ISO_CTRL_NFC_NFCF_424\t\t0x03\n#define TRF7970A_ISO_CTRL_NFC_CE_14443A\t\t0x00\n#define TRF7970A_ISO_CTRL_NFC_CE_14443B\t\t0x01\n#define TRF7970A_ISO_CTRL_NFC_CE\t\tBIT(2)\n#define TRF7970A_ISO_CTRL_NFC_ACTIVE\t\tBIT(3)\n#define TRF7970A_ISO_CTRL_NFC_INITIATOR\t\tBIT(4)\n#define TRF7970A_ISO_CTRL_NFC_NFC_CE_MODE\tBIT(5)\n#define TRF7970A_ISO_CTRL_RFID\t\t\tBIT(5)\n#define TRF7970A_ISO_CTRL_DIR_MODE\t\tBIT(6)\n#define TRF7970A_ISO_CTRL_RX_CRC_N\t\tBIT(7)\t \n\n#define TRF7970A_ISO_CTRL_RFID_SPEED_MASK\t0x1f\n\n \n#define TRF7970A_MODULATOR_DEPTH(n)\t\t((n) & 0x7)\n#define TRF7970A_MODULATOR_DEPTH_ASK10\t\t(TRF7970A_MODULATOR_DEPTH(0))\n#define TRF7970A_MODULATOR_DEPTH_OOK\t\t(TRF7970A_MODULATOR_DEPTH(1))\n#define TRF7970A_MODULATOR_DEPTH_ASK7\t\t(TRF7970A_MODULATOR_DEPTH(2))\n#define TRF7970A_MODULATOR_DEPTH_ASK8_5\t\t(TRF7970A_MODULATOR_DEPTH(3))\n#define TRF7970A_MODULATOR_DEPTH_ASK13\t\t(TRF7970A_MODULATOR_DEPTH(4))\n#define TRF7970A_MODULATOR_DEPTH_ASK16\t\t(TRF7970A_MODULATOR_DEPTH(5))\n#define TRF7970A_MODULATOR_DEPTH_ASK22\t\t(TRF7970A_MODULATOR_DEPTH(6))\n#define TRF7970A_MODULATOR_DEPTH_ASK30\t\t(TRF7970A_MODULATOR_DEPTH(7))\n#define TRF7970A_MODULATOR_EN_ANA\t\tBIT(3)\n#define TRF7970A_MODULATOR_CLK(n)\t\t(((n) & 0x3) << 4)\n#define TRF7970A_MODULATOR_CLK_DISABLED\t\t(TRF7970A_MODULATOR_CLK(0))\n#define TRF7970A_MODULATOR_CLK_3_6\t\t(TRF7970A_MODULATOR_CLK(1))\n#define TRF7970A_MODULATOR_CLK_6_13\t\t(TRF7970A_MODULATOR_CLK(2))\n#define TRF7970A_MODULATOR_CLK_13_27\t\t(TRF7970A_MODULATOR_CLK(3))\n#define TRF7970A_MODULATOR_EN_OOK\t\tBIT(6)\n#define TRF7970A_MODULATOR_27MHZ\t\tBIT(7)\n\n#define TRF7970A_RX_SPECIAL_SETTINGS_NO_LIM\tBIT(0)\n#define TRF7970A_RX_SPECIAL_SETTINGS_AGCR\tBIT(1)\n#define TRF7970A_RX_SPECIAL_SETTINGS_GD_0DB\t(0x0 << 2)\n#define TRF7970A_RX_SPECIAL_SETTINGS_GD_5DB\t(0x1 << 2)\n#define TRF7970A_RX_SPECIAL_SETTINGS_GD_10DB\t(0x2 << 2)\n#define TRF7970A_RX_SPECIAL_SETTINGS_GD_15DB\t(0x3 << 2)\n#define TRF7970A_RX_SPECIAL_SETTINGS_HBT\tBIT(4)\n#define TRF7970A_RX_SPECIAL_SETTINGS_M848\tBIT(5)\n#define TRF7970A_RX_SPECIAL_SETTINGS_C424\tBIT(6)\n#define TRF7970A_RX_SPECIAL_SETTINGS_C212\tBIT(7)\n\n#define TRF7970A_REG_IO_CTRL_VRS(v)\t\t((v) & 0x07)\n#define TRF7970A_REG_IO_CTRL_IO_LOW\t\tBIT(5)\n#define TRF7970A_REG_IO_CTRL_EN_EXT_PA\t\tBIT(6)\n#define TRF7970A_REG_IO_CTRL_AUTO_REG\t\tBIT(7)\n\n \n#define TRF7970A_IRQ_STATUS_NORESP\t\tBIT(0)\t \n#define TRF7970A_IRQ_STATUS_NFC_COL_ERROR\tBIT(0)\n#define TRF7970A_IRQ_STATUS_COL\t\t\tBIT(1)\n#define TRF7970A_IRQ_STATUS_FRAMING_EOF_ERROR\tBIT(2)\n#define TRF7970A_IRQ_STATUS_NFC_RF\t\tBIT(2)\n#define TRF7970A_IRQ_STATUS_PARITY_ERROR\tBIT(3)\n#define TRF7970A_IRQ_STATUS_NFC_SDD\t\tBIT(3)\n#define TRF7970A_IRQ_STATUS_CRC_ERROR\t\tBIT(4)\n#define TRF7970A_IRQ_STATUS_NFC_PROTO_ERROR\tBIT(4)\n#define TRF7970A_IRQ_STATUS_FIFO\t\tBIT(5)\n#define TRF7970A_IRQ_STATUS_SRX\t\t\tBIT(6)\n#define TRF7970A_IRQ_STATUS_TX\t\t\tBIT(7)\n\n#define TRF7970A_IRQ_STATUS_ERROR\t\t\t\t\\\n\t\t(TRF7970A_IRQ_STATUS_COL |\t\t\t\\\n\t\t TRF7970A_IRQ_STATUS_FRAMING_EOF_ERROR |\t\\\n\t\t TRF7970A_IRQ_STATUS_PARITY_ERROR |\t\t\\\n\t\t TRF7970A_IRQ_STATUS_CRC_ERROR)\n\n#define TRF7970A_RSSI_OSC_STATUS_RSSI_MASK\t(BIT(2) | BIT(1) | BIT(0))\n#define TRF7970A_RSSI_OSC_STATUS_RSSI_X_MASK\t(BIT(5) | BIT(4) | BIT(3))\n#define TRF7970A_RSSI_OSC_STATUS_RSSI_OSC_OK\tBIT(6)\n\n#define TRF7970A_SPECIAL_FCN_REG1_COL_7_6\t\tBIT(0)\n#define TRF7970A_SPECIAL_FCN_REG1_14_ANTICOLL\t\tBIT(1)\n#define TRF7970A_SPECIAL_FCN_REG1_4_BIT_RX\t\tBIT(2)\n#define TRF7970A_SPECIAL_FCN_REG1_SP_DIR_MODE\t\tBIT(3)\n#define TRF7970A_SPECIAL_FCN_REG1_NEXT_SLOT_37US\tBIT(4)\n#define TRF7970A_SPECIAL_FCN_REG1_PAR43\t\t\tBIT(5)\n\n#define TRF7970A_ADJUTABLE_FIFO_IRQ_LEVELS_WLH_124\t(0x0 << 2)\n#define TRF7970A_ADJUTABLE_FIFO_IRQ_LEVELS_WLH_120\t(0x1 << 2)\n#define TRF7970A_ADJUTABLE_FIFO_IRQ_LEVELS_WLH_112\t(0x2 << 2)\n#define TRF7970A_ADJUTABLE_FIFO_IRQ_LEVELS_WLH_96\t(0x3 << 2)\n#define TRF7970A_ADJUTABLE_FIFO_IRQ_LEVELS_WLL_4\t0x0\n#define TRF7970A_ADJUTABLE_FIFO_IRQ_LEVELS_WLL_8\t0x1\n#define TRF7970A_ADJUTABLE_FIFO_IRQ_LEVELS_WLL_16\t0x2\n#define TRF7970A_ADJUTABLE_FIFO_IRQ_LEVELS_WLL_32\t0x3\n\n#define TRF7970A_NFC_LOW_FIELD_LEVEL_RFDET(v)\t((v) & 0x07)\n#define TRF7970A_NFC_LOW_FIELD_LEVEL_CLEX_DIS\tBIT(7)\n\n#define TRF7970A_NFC_TARGET_LEVEL_RFDET(v)\t((v) & 0x07)\n#define TRF7970A_NFC_TARGET_LEVEL_HI_RF\t\tBIT(3)\n#define TRF7970A_NFC_TARGET_LEVEL_SDD_EN\tBIT(5)\n#define TRF7970A_NFC_TARGET_LEVEL_LD_S_4BYTES\t(0x0 << 6)\n#define TRF7970A_NFC_TARGET_LEVEL_LD_S_7BYTES\t(0x1 << 6)\n#define TRF7970A_NFC_TARGET_LEVEL_LD_S_10BYTES\t(0x2 << 6)\n\n#define TRF79070A_NFC_TARGET_PROTOCOL_NFCBR_106\t\tBIT(0)\n#define TRF79070A_NFC_TARGET_PROTOCOL_NFCBR_212\t\tBIT(1)\n#define TRF79070A_NFC_TARGET_PROTOCOL_NFCBR_424\t\t(BIT(0) | BIT(1))\n#define TRF79070A_NFC_TARGET_PROTOCOL_PAS_14443B\tBIT(2)\n#define TRF79070A_NFC_TARGET_PROTOCOL_PAS_106\t\tBIT(3)\n#define TRF79070A_NFC_TARGET_PROTOCOL_FELICA\t\tBIT(4)\n#define TRF79070A_NFC_TARGET_PROTOCOL_RF_L\t\tBIT(6)\n#define TRF79070A_NFC_TARGET_PROTOCOL_RF_H\t\tBIT(7)\n\n#define TRF79070A_NFC_TARGET_PROTOCOL_106A\t\t\\\n\t (TRF79070A_NFC_TARGET_PROTOCOL_RF_H |\t\t\\\n\t  TRF79070A_NFC_TARGET_PROTOCOL_RF_L |\t\t\\\n\t  TRF79070A_NFC_TARGET_PROTOCOL_PAS_106 |\t\\\n\t  TRF79070A_NFC_TARGET_PROTOCOL_NFCBR_106)\n\n#define TRF79070A_NFC_TARGET_PROTOCOL_106B\t\t\\\n\t (TRF79070A_NFC_TARGET_PROTOCOL_RF_H |\t\t\\\n\t  TRF79070A_NFC_TARGET_PROTOCOL_RF_L |\t\t\\\n\t  TRF79070A_NFC_TARGET_PROTOCOL_PAS_14443B |\t\\\n\t  TRF79070A_NFC_TARGET_PROTOCOL_NFCBR_106)\n\n#define TRF79070A_NFC_TARGET_PROTOCOL_212F\t\t\\\n\t (TRF79070A_NFC_TARGET_PROTOCOL_RF_H |\t\t\\\n\t  TRF79070A_NFC_TARGET_PROTOCOL_RF_L |\t\t\\\n\t  TRF79070A_NFC_TARGET_PROTOCOL_FELICA |\t\\\n\t  TRF79070A_NFC_TARGET_PROTOCOL_NFCBR_212)\n\n#define TRF79070A_NFC_TARGET_PROTOCOL_424F\t\t\\\n\t (TRF79070A_NFC_TARGET_PROTOCOL_RF_H |\t\t\\\n\t  TRF79070A_NFC_TARGET_PROTOCOL_RF_L |\t\t\\\n\t  TRF79070A_NFC_TARGET_PROTOCOL_FELICA |\t\\\n\t  TRF79070A_NFC_TARGET_PROTOCOL_NFCBR_424)\n\n#define TRF7970A_FIFO_STATUS_OVERFLOW\t\tBIT(7)\n\n \n#define NFC_T2T_CMD_READ\t\t\t0x30\n\n \n#define ISO15693_CMD_INVENTORY\t\t\t0x01\n#define ISO15693_CMD_READ_SINGLE_BLOCK\t\t0x20\n#define ISO15693_CMD_WRITE_SINGLE_BLOCK\t\t0x21\n#define ISO15693_CMD_LOCK_BLOCK\t\t\t0x22\n#define ISO15693_CMD_READ_MULTIPLE_BLOCK\t0x23\n#define ISO15693_CMD_WRITE_MULTIPLE_BLOCK\t0x24\n#define ISO15693_CMD_SELECT\t\t\t0x25\n#define ISO15693_CMD_RESET_TO_READY\t\t0x26\n#define ISO15693_CMD_WRITE_AFI\t\t\t0x27\n#define ISO15693_CMD_LOCK_AFI\t\t\t0x28\n#define ISO15693_CMD_WRITE_DSFID\t\t0x29\n#define ISO15693_CMD_LOCK_DSFID\t\t\t0x2a\n#define ISO15693_CMD_GET_SYSTEM_INFO\t\t0x2b\n#define ISO15693_CMD_GET_MULTIPLE_BLOCK_SECURITY_STATUS\t0x2c\n\n \n#define ISO15693_REQ_FLAG_SUB_CARRIER\t\tBIT(0)\n#define ISO15693_REQ_FLAG_DATA_RATE\t\tBIT(1)\n#define ISO15693_REQ_FLAG_INVENTORY\t\tBIT(2)\n#define ISO15693_REQ_FLAG_PROTOCOL_EXT\t\tBIT(3)\n#define ISO15693_REQ_FLAG_SELECT\t\tBIT(4)\n#define ISO15693_REQ_FLAG_AFI\t\t\tBIT(4)\n#define ISO15693_REQ_FLAG_ADDRESS\t\tBIT(5)\n#define ISO15693_REQ_FLAG_NB_SLOTS\t\tBIT(5)\n#define ISO15693_REQ_FLAG_OPTION\t\tBIT(6)\n\n#define ISO15693_REQ_FLAG_SPEED_MASK \\\n\t\t(ISO15693_REQ_FLAG_SUB_CARRIER | ISO15693_REQ_FLAG_DATA_RATE)\n\nenum trf7970a_state {\n\tTRF7970A_ST_PWR_OFF,\n\tTRF7970A_ST_RF_OFF,\n\tTRF7970A_ST_IDLE,\n\tTRF7970A_ST_IDLE_RX_BLOCKED,\n\tTRF7970A_ST_WAIT_FOR_TX_FIFO,\n\tTRF7970A_ST_WAIT_FOR_RX_DATA,\n\tTRF7970A_ST_WAIT_FOR_RX_DATA_CONT,\n\tTRF7970A_ST_WAIT_TO_ISSUE_EOF,\n\tTRF7970A_ST_LISTENING,\n\tTRF7970A_ST_LISTENING_MD,\n\tTRF7970A_ST_MAX\n};\n\nstruct trf7970a {\n\tenum trf7970a_state\t\tstate;\n\tstruct device\t\t\t*dev;\n\tstruct spi_device\t\t*spi;\n\tstruct regulator\t\t*regulator;\n\tstruct nfc_digital_dev\t\t*ddev;\n\tu32\t\t\t\tquirks;\n\tbool\t\t\t\tis_initiator;\n\tbool\t\t\t\taborting;\n\tstruct sk_buff\t\t\t*tx_skb;\n\tstruct sk_buff\t\t\t*rx_skb;\n\tnfc_digital_cmd_complete_t\tcb;\n\tvoid\t\t\t\t*cb_arg;\n\tu8\t\t\t\tchip_status_ctrl;\n\tu8\t\t\t\tiso_ctrl;\n\tu8\t\t\t\tiso_ctrl_tech;\n\tu8\t\t\t\tmodulator_sys_clk_ctrl;\n\tu8\t\t\t\tspecial_fcn_reg1;\n\tu8\t\t\t\tio_ctrl;\n\tunsigned int\t\t\tguard_time;\n\tint\t\t\t\ttechnology;\n\tint\t\t\t\tframing;\n\tu8\t\t\t\tmd_rf_tech;\n\tu8\t\t\t\ttx_cmd;\n\tbool\t\t\t\tissue_eof;\n\tstruct gpio_desc\t\t*en_gpiod;\n\tstruct gpio_desc\t\t*en2_gpiod;\n\tstruct mutex\t\t\tlock;\n\tunsigned int\t\t\ttimeout;\n\tbool\t\t\t\tignore_timeout;\n\tstruct delayed_work\t\ttimeout_work;\n};\n\nstatic int trf7970a_cmd(struct trf7970a *trf, u8 opcode)\n{\n\tu8 cmd = TRF7970A_CMD_BIT_CTRL | TRF7970A_CMD_BIT_OPCODE(opcode);\n\tint ret;\n\n\tdev_dbg(trf->dev, \"cmd: 0x%x\\n\", cmd);\n\n\tret = spi_write(trf->spi, &cmd, 1);\n\tif (ret)\n\t\tdev_err(trf->dev, \"%s - cmd: 0x%x, ret: %d\\n\", __func__, cmd,\n\t\t\tret);\n\treturn ret;\n}\n\nstatic int trf7970a_read(struct trf7970a *trf, u8 reg, u8 *val)\n{\n\tu8 addr = TRF7970A_CMD_BIT_RW | reg;\n\tint ret;\n\n\tret = spi_write_then_read(trf->spi, &addr, 1, val, 1);\n\tif (ret)\n\t\tdev_err(trf->dev, \"%s - addr: 0x%x, ret: %d\\n\", __func__, addr,\n\t\t\tret);\n\n\tdev_dbg(trf->dev, \"read(0x%x): 0x%x\\n\", addr, *val);\n\n\treturn ret;\n}\n\nstatic int trf7970a_read_cont(struct trf7970a *trf, u8 reg, u8 *buf,\n\t\t\t      size_t len)\n{\n\tu8 addr = reg | TRF7970A_CMD_BIT_RW | TRF7970A_CMD_BIT_CONTINUOUS;\n\tstruct spi_transfer t[2];\n\tstruct spi_message m;\n\tint ret;\n\n\tdev_dbg(trf->dev, \"read_cont(0x%x, %zd)\\n\", addr, len);\n\n\tspi_message_init(&m);\n\n\tmemset(&t, 0, sizeof(t));\n\n\tt[0].tx_buf = &addr;\n\tt[0].len = sizeof(addr);\n\tspi_message_add_tail(&t[0], &m);\n\n\tt[1].rx_buf = buf;\n\tt[1].len = len;\n\tspi_message_add_tail(&t[1], &m);\n\n\tret = spi_sync(trf->spi, &m);\n\tif (ret)\n\t\tdev_err(trf->dev, \"%s - addr: 0x%x, ret: %d\\n\", __func__, addr,\n\t\t\tret);\n\treturn ret;\n}\n\nstatic int trf7970a_write(struct trf7970a *trf, u8 reg, u8 val)\n{\n\tu8 buf[2] = { reg, val };\n\tint ret;\n\n\tdev_dbg(trf->dev, \"write(0x%x): 0x%x\\n\", reg, val);\n\n\tret = spi_write(trf->spi, buf, 2);\n\tif (ret)\n\t\tdev_err(trf->dev, \"%s - write: 0x%x 0x%x, ret: %d\\n\", __func__,\n\t\t\tbuf[0], buf[1], ret);\n\n\treturn ret;\n}\n\nstatic int trf7970a_read_irqstatus(struct trf7970a *trf, u8 *status)\n{\n\tint ret;\n\tu8 buf[2];\n\tu8 addr;\n\n\taddr = TRF7970A_IRQ_STATUS | TRF7970A_CMD_BIT_RW;\n\n\tif (trf->quirks & TRF7970A_QUIRK_IRQ_STATUS_READ) {\n\t\taddr |= TRF7970A_CMD_BIT_CONTINUOUS;\n\t\tret = spi_write_then_read(trf->spi, &addr, 1, buf, 2);\n\t} else {\n\t\tret = spi_write_then_read(trf->spi, &addr, 1, buf, 1);\n\t}\n\n\tif (ret)\n\t\tdev_err(trf->dev, \"%s - irqstatus: Status read failed: %d\\n\",\n\t\t\t__func__, ret);\n\telse\n\t\t*status = buf[0];\n\n\treturn ret;\n}\n\nstatic int trf7970a_read_target_proto(struct trf7970a *trf, u8 *target_proto)\n{\n\tint ret;\n\tu8 buf[2];\n\tu8 addr;\n\n\taddr = TRF79070A_NFC_TARGET_PROTOCOL | TRF7970A_CMD_BIT_RW |\n\t       TRF7970A_CMD_BIT_CONTINUOUS;\n\n\tret = spi_write_then_read(trf->spi, &addr, 1, buf, 2);\n\tif (ret)\n\t\tdev_err(trf->dev, \"%s - target_proto: Read failed: %d\\n\",\n\t\t\t__func__, ret);\n\telse\n\t\t*target_proto = buf[0];\n\n\treturn ret;\n}\n\nstatic int trf7970a_mode_detect(struct trf7970a *trf, u8 *rf_tech)\n{\n\tint ret;\n\tu8 target_proto, tech;\n\n\tret = trf7970a_read_target_proto(trf, &target_proto);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (target_proto) {\n\tcase TRF79070A_NFC_TARGET_PROTOCOL_106A:\n\t\ttech = NFC_DIGITAL_RF_TECH_106A;\n\t\tbreak;\n\tcase TRF79070A_NFC_TARGET_PROTOCOL_106B:\n\t\ttech = NFC_DIGITAL_RF_TECH_106B;\n\t\tbreak;\n\tcase TRF79070A_NFC_TARGET_PROTOCOL_212F:\n\t\ttech = NFC_DIGITAL_RF_TECH_212F;\n\t\tbreak;\n\tcase TRF79070A_NFC_TARGET_PROTOCOL_424F:\n\t\ttech = NFC_DIGITAL_RF_TECH_424F;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(trf->dev, \"%s - mode_detect: target_proto: 0x%x\\n\",\n\t\t\t__func__, target_proto);\n\t\treturn -EIO;\n\t}\n\n\t*rf_tech = tech;\n\n\treturn ret;\n}\n\nstatic void trf7970a_send_upstream(struct trf7970a *trf)\n{\n\tdev_kfree_skb_any(trf->tx_skb);\n\ttrf->tx_skb = NULL;\n\n\tif (trf->rx_skb && !IS_ERR(trf->rx_skb) && !trf->aborting)\n\t\tprint_hex_dump_debug(\"trf7970a rx data: \", DUMP_PREFIX_NONE,\n\t\t\t\t     16, 1, trf->rx_skb->data, trf->rx_skb->len,\n\t\t\t\t     false);\n\n\ttrf->state = TRF7970A_ST_IDLE;\n\n\tif (trf->aborting) {\n\t\tdev_dbg(trf->dev, \"Abort process complete\\n\");\n\n\t\tif (!IS_ERR(trf->rx_skb)) {\n\t\t\tkfree_skb(trf->rx_skb);\n\t\t\ttrf->rx_skb = ERR_PTR(-ECANCELED);\n\t\t}\n\n\t\ttrf->aborting = false;\n\t}\n\n\ttrf->cb(trf->ddev, trf->cb_arg, trf->rx_skb);\n\n\ttrf->rx_skb = NULL;\n}\n\nstatic void trf7970a_send_err_upstream(struct trf7970a *trf, int errno)\n{\n\tdev_dbg(trf->dev, \"Error - state: %d, errno: %d\\n\", trf->state, errno);\n\n\tcancel_delayed_work(&trf->timeout_work);\n\n\tkfree_skb(trf->rx_skb);\n\ttrf->rx_skb = ERR_PTR(errno);\n\n\ttrf7970a_send_upstream(trf);\n}\n\nstatic int trf7970a_transmit(struct trf7970a *trf, struct sk_buff *skb,\n\t\t\t     unsigned int len, const u8 *prefix,\n\t\t\t     unsigned int prefix_len)\n{\n\tstruct spi_transfer t[2];\n\tstruct spi_message m;\n\tunsigned int timeout;\n\tint ret;\n\n\tprint_hex_dump_debug(\"trf7970a tx data: \", DUMP_PREFIX_NONE,\n\t\t\t     16, 1, skb->data, len, false);\n\n\tspi_message_init(&m);\n\n\tmemset(&t, 0, sizeof(t));\n\n\tt[0].tx_buf = prefix;\n\tt[0].len = prefix_len;\n\tspi_message_add_tail(&t[0], &m);\n\n\tt[1].tx_buf = skb->data;\n\tt[1].len = len;\n\tspi_message_add_tail(&t[1], &m);\n\n\tret = spi_sync(trf->spi, &m);\n\tif (ret) {\n\t\tdev_err(trf->dev, \"%s - Can't send tx data: %d\\n\", __func__,\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tskb_pull(skb, len);\n\n\tif (skb->len > 0) {\n\t\ttrf->state = TRF7970A_ST_WAIT_FOR_TX_FIFO;\n\t\ttimeout = TRF7970A_WAIT_FOR_FIFO_DRAIN_TIMEOUT;\n\t} else {\n\t\tif (trf->issue_eof) {\n\t\t\ttrf->state = TRF7970A_ST_WAIT_TO_ISSUE_EOF;\n\t\t\ttimeout = TRF7970A_WAIT_TO_ISSUE_ISO15693_EOF;\n\t\t} else {\n\t\t\ttrf->state = TRF7970A_ST_WAIT_FOR_RX_DATA;\n\n\t\t\tif (!trf->timeout)\n\t\t\t\ttimeout = TRF7970A_WAIT_FOR_TX_IRQ;\n\t\t\telse\n\t\t\t\ttimeout = trf->timeout;\n\t\t}\n\t}\n\n\tdev_dbg(trf->dev, \"Setting timeout for %d ms, state: %d\\n\", timeout,\n\t\ttrf->state);\n\n\tschedule_delayed_work(&trf->timeout_work, msecs_to_jiffies(timeout));\n\n\treturn 0;\n}\n\nstatic void trf7970a_fill_fifo(struct trf7970a *trf)\n{\n\tstruct sk_buff *skb = trf->tx_skb;\n\tunsigned int len;\n\tint ret;\n\tu8 fifo_bytes;\n\tu8 prefix;\n\n\tret = trf7970a_read(trf, TRF7970A_FIFO_STATUS, &fifo_bytes);\n\tif (ret) {\n\t\ttrf7970a_send_err_upstream(trf, ret);\n\t\treturn;\n\t}\n\n\tdev_dbg(trf->dev, \"Filling FIFO - fifo_bytes: 0x%x\\n\", fifo_bytes);\n\n\tfifo_bytes &= ~TRF7970A_FIFO_STATUS_OVERFLOW;\n\n\t \n\tlen = TRF7970A_FIFO_SIZE - fifo_bytes;\n\tif (!len) {\n\t\tschedule_delayed_work(&trf->timeout_work,\n\t\t\tmsecs_to_jiffies(TRF7970A_WAIT_FOR_FIFO_DRAIN_TIMEOUT));\n\t\treturn;\n\t}\n\n\tlen = min(skb->len, len);\n\n\tprefix = TRF7970A_CMD_BIT_CONTINUOUS | TRF7970A_FIFO_IO_REGISTER;\n\n\tret = trf7970a_transmit(trf, skb, len, &prefix, sizeof(prefix));\n\tif (ret)\n\t\ttrf7970a_send_err_upstream(trf, ret);\n}\n\nstatic void trf7970a_drain_fifo(struct trf7970a *trf, u8 status)\n{\n\tstruct sk_buff *skb = trf->rx_skb;\n\tint ret;\n\tu8 fifo_bytes;\n\n\tif (status & TRF7970A_IRQ_STATUS_ERROR) {\n\t\ttrf7970a_send_err_upstream(trf, -EIO);\n\t\treturn;\n\t}\n\n\tret = trf7970a_read(trf, TRF7970A_FIFO_STATUS, &fifo_bytes);\n\tif (ret) {\n\t\ttrf7970a_send_err_upstream(trf, ret);\n\t\treturn;\n\t}\n\n\tdev_dbg(trf->dev, \"Draining FIFO - fifo_bytes: 0x%x\\n\", fifo_bytes);\n\n\tfifo_bytes &= ~TRF7970A_FIFO_STATUS_OVERFLOW;\n\n\tif (!fifo_bytes)\n\t\tgoto no_rx_data;\n\n\tif (fifo_bytes > skb_tailroom(skb)) {\n\t\tskb = skb_copy_expand(skb, skb_headroom(skb),\n\t\t\t\t      max_t(int, fifo_bytes,\n\t\t\t\t\t    TRF7970A_RX_SKB_ALLOC_SIZE),\n\t\t\t\t      GFP_KERNEL);\n\t\tif (!skb) {\n\t\t\ttrf7970a_send_err_upstream(trf, -ENOMEM);\n\t\t\treturn;\n\t\t}\n\n\t\tkfree_skb(trf->rx_skb);\n\t\ttrf->rx_skb = skb;\n\t}\n\n\tret = trf7970a_read_cont(trf, TRF7970A_FIFO_IO_REGISTER,\n\t\t\t\t skb_put(skb, fifo_bytes), fifo_bytes);\n\tif (ret) {\n\t\ttrf7970a_send_err_upstream(trf, ret);\n\t\treturn;\n\t}\n\n\t \n\tif ((trf->framing == NFC_DIGITAL_FRAMING_NFCA_T2T) && (skb->len == 1) &&\n\t    (trf->special_fcn_reg1 == TRF7970A_SPECIAL_FCN_REG1_4_BIT_RX)) {\n\t\tskb->data[0] >>= 4;\n\t\tstatus = TRF7970A_IRQ_STATUS_SRX;\n\t} else {\n\t\ttrf->state = TRF7970A_ST_WAIT_FOR_RX_DATA_CONT;\n\n\t\tret = trf7970a_read(trf, TRF7970A_FIFO_STATUS, &fifo_bytes);\n\t\tif (ret) {\n\t\t\ttrf7970a_send_err_upstream(trf, ret);\n\t\t\treturn;\n\t\t}\n\n\t\tfifo_bytes &= ~TRF7970A_FIFO_STATUS_OVERFLOW;\n\n\t\t \n\t\tif (fifo_bytes)\n\t\t\tstatus = 0;\n\t}\n\nno_rx_data:\n\tif (status == TRF7970A_IRQ_STATUS_SRX) {\t \n\t\ttrf7970a_send_upstream(trf);\n\t\treturn;\n\t}\n\n\tdev_dbg(trf->dev, \"Setting timeout for %d ms\\n\",\n\t\tTRF7970A_WAIT_FOR_RX_DATA_TIMEOUT);\n\n\tschedule_delayed_work(&trf->timeout_work,\n\t\t\t   msecs_to_jiffies(TRF7970A_WAIT_FOR_RX_DATA_TIMEOUT));\n}\n\nstatic irqreturn_t trf7970a_irq(int irq, void *dev_id)\n{\n\tstruct trf7970a *trf = dev_id;\n\tint ret;\n\tu8 status, fifo_bytes, iso_ctrl;\n\n\tmutex_lock(&trf->lock);\n\n\tif (trf->state == TRF7970A_ST_RF_OFF) {\n\t\tmutex_unlock(&trf->lock);\n\t\treturn IRQ_NONE;\n\t}\n\n\tret = trf7970a_read_irqstatus(trf, &status);\n\tif (ret) {\n\t\tmutex_unlock(&trf->lock);\n\t\treturn IRQ_NONE;\n\t}\n\n\tdev_dbg(trf->dev, \"IRQ - state: %d, status: 0x%x\\n\", trf->state,\n\t\tstatus);\n\n\tif (!status) {\n\t\tmutex_unlock(&trf->lock);\n\t\treturn IRQ_NONE;\n\t}\n\n\tswitch (trf->state) {\n\tcase TRF7970A_ST_IDLE:\n\tcase TRF7970A_ST_IDLE_RX_BLOCKED:\n\t\t \n\t\tif (trf->is_initiator && (status & TRF7970A_IRQ_STATUS_ERROR)) {\n\t\t\ttrf7970a_cmd(trf, TRF7970A_CMD_BLOCK_RX);\n\t\t\ttrf->state = TRF7970A_ST_IDLE_RX_BLOCKED;\n\t\t}\n\n\t\ttrf7970a_cmd(trf, TRF7970A_CMD_FIFO_RESET);\n\t\tbreak;\n\tcase TRF7970A_ST_WAIT_FOR_TX_FIFO:\n\t\tif (status & TRF7970A_IRQ_STATUS_TX) {\n\t\t\ttrf->ignore_timeout =\n\t\t\t    !cancel_delayed_work(&trf->timeout_work);\n\t\t\ttrf7970a_fill_fifo(trf);\n\t\t} else {\n\t\t\ttrf7970a_send_err_upstream(trf, -EIO);\n\t\t}\n\t\tbreak;\n\tcase TRF7970A_ST_WAIT_FOR_RX_DATA:\n\tcase TRF7970A_ST_WAIT_FOR_RX_DATA_CONT:\n\t\tif (status & TRF7970A_IRQ_STATUS_SRX) {\n\t\t\ttrf->ignore_timeout =\n\t\t\t    !cancel_delayed_work(&trf->timeout_work);\n\t\t\ttrf7970a_drain_fifo(trf, status);\n\t\t} else if (status & TRF7970A_IRQ_STATUS_FIFO) {\n\t\t\tret = trf7970a_read(trf, TRF7970A_FIFO_STATUS,\n\t\t\t\t\t    &fifo_bytes);\n\n\t\t\tfifo_bytes &= ~TRF7970A_FIFO_STATUS_OVERFLOW;\n\n\t\t\tif (ret)\n\t\t\t\ttrf7970a_send_err_upstream(trf, ret);\n\t\t\telse if (!fifo_bytes)\n\t\t\t\ttrf7970a_cmd(trf, TRF7970A_CMD_FIFO_RESET);\n\t\t} else if ((status == TRF7970A_IRQ_STATUS_TX) ||\n\t\t\t   (!trf->is_initiator &&\n\t\t\t    (status == (TRF7970A_IRQ_STATUS_TX |\n\t\t\t\t\tTRF7970A_IRQ_STATUS_NFC_RF)))) {\n\t\t\ttrf7970a_cmd(trf, TRF7970A_CMD_FIFO_RESET);\n\n\t\t\tif (!trf->timeout) {\n\t\t\t\ttrf->ignore_timeout =\n\t\t\t\t    !cancel_delayed_work(&trf->timeout_work);\n\t\t\t\ttrf->rx_skb = ERR_PTR(0);\n\t\t\t\ttrf7970a_send_upstream(trf);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (trf->is_initiator)\n\t\t\t\tbreak;\n\n\t\t\tiso_ctrl = trf->iso_ctrl;\n\n\t\t\tswitch (trf->framing) {\n\t\t\tcase NFC_DIGITAL_FRAMING_NFCA_STANDARD:\n\t\t\t\ttrf->tx_cmd = TRF7970A_CMD_TRANSMIT_NO_CRC;\n\t\t\t\tiso_ctrl |= TRF7970A_ISO_CTRL_RX_CRC_N;\n\t\t\t\ttrf->iso_ctrl = 0xff;  \n\t\t\t\tbreak;\n\t\t\tcase NFC_DIGITAL_FRAMING_NFCA_STANDARD_WITH_CRC_A:\n\t\t\t\ttrf->tx_cmd = TRF7970A_CMD_TRANSMIT;\n\t\t\t\tiso_ctrl &= ~TRF7970A_ISO_CTRL_RX_CRC_N;\n\t\t\t\ttrf->iso_ctrl = 0xff;  \n\t\t\t\tbreak;\n\t\t\tcase NFC_DIGITAL_FRAMING_NFCA_ANTICOL_COMPLETE:\n\t\t\t\tret = trf7970a_write(trf,\n\t\t\t\t\t TRF7970A_SPECIAL_FCN_REG1,\n\t\t\t\t\t TRF7970A_SPECIAL_FCN_REG1_14_ANTICOLL);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto err_unlock_exit;\n\n\t\t\t\ttrf->special_fcn_reg1 =\n\t\t\t\t    TRF7970A_SPECIAL_FCN_REG1_14_ANTICOLL;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (iso_ctrl != trf->iso_ctrl) {\n\t\t\t\tret = trf7970a_write(trf, TRF7970A_ISO_CTRL,\n\t\t\t\t\t\t     iso_ctrl);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto err_unlock_exit;\n\n\t\t\t\ttrf->iso_ctrl = iso_ctrl;\n\t\t\t}\n\t\t} else {\n\t\t\ttrf7970a_send_err_upstream(trf, -EIO);\n\t\t}\n\t\tbreak;\n\tcase TRF7970A_ST_WAIT_TO_ISSUE_EOF:\n\t\tif (status != TRF7970A_IRQ_STATUS_TX)\n\t\t\ttrf7970a_send_err_upstream(trf, -EIO);\n\t\tbreak;\n\tcase TRF7970A_ST_LISTENING:\n\t\tif (status & TRF7970A_IRQ_STATUS_SRX) {\n\t\t\ttrf->ignore_timeout =\n\t\t\t    !cancel_delayed_work(&trf->timeout_work);\n\t\t\ttrf7970a_drain_fifo(trf, status);\n\t\t} else if (!(status & TRF7970A_IRQ_STATUS_NFC_RF)) {\n\t\t\ttrf7970a_send_err_upstream(trf, -EIO);\n\t\t}\n\t\tbreak;\n\tcase TRF7970A_ST_LISTENING_MD:\n\t\tif (status & TRF7970A_IRQ_STATUS_SRX) {\n\t\t\ttrf->ignore_timeout =\n\t\t\t    !cancel_delayed_work(&trf->timeout_work);\n\n\t\t\tret = trf7970a_mode_detect(trf, &trf->md_rf_tech);\n\t\t\tif (ret) {\n\t\t\t\ttrf7970a_send_err_upstream(trf, ret);\n\t\t\t} else {\n\t\t\t\ttrf->state = TRF7970A_ST_LISTENING;\n\t\t\t\ttrf7970a_drain_fifo(trf, status);\n\t\t\t}\n\t\t} else if (!(status & TRF7970A_IRQ_STATUS_NFC_RF)) {\n\t\t\ttrf7970a_send_err_upstream(trf, -EIO);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(trf->dev, \"%s - Driver in invalid state: %d\\n\",\n\t\t\t__func__, trf->state);\n\t}\n\nerr_unlock_exit:\n\tmutex_unlock(&trf->lock);\n\treturn IRQ_HANDLED;\n}\n\nstatic void trf7970a_issue_eof(struct trf7970a *trf)\n{\n\tint ret;\n\n\tdev_dbg(trf->dev, \"Issuing EOF\\n\");\n\n\tret = trf7970a_cmd(trf, TRF7970A_CMD_FIFO_RESET);\n\tif (ret)\n\t\ttrf7970a_send_err_upstream(trf, ret);\n\n\tret = trf7970a_cmd(trf, TRF7970A_CMD_EOF);\n\tif (ret)\n\t\ttrf7970a_send_err_upstream(trf, ret);\n\n\ttrf->state = TRF7970A_ST_WAIT_FOR_RX_DATA;\n\n\tdev_dbg(trf->dev, \"Setting timeout for %d ms, state: %d\\n\",\n\t\ttrf->timeout, trf->state);\n\n\tschedule_delayed_work(&trf->timeout_work,\n\t\t\t      msecs_to_jiffies(trf->timeout));\n}\n\nstatic void trf7970a_timeout_work_handler(struct work_struct *work)\n{\n\tstruct trf7970a *trf = container_of(work, struct trf7970a,\n\t\t\t\t\t    timeout_work.work);\n\n\tdev_dbg(trf->dev, \"Timeout - state: %d, ignore_timeout: %d\\n\",\n\t\ttrf->state, trf->ignore_timeout);\n\n\tmutex_lock(&trf->lock);\n\n\tif (trf->ignore_timeout)\n\t\ttrf->ignore_timeout = false;\n\telse if (trf->state == TRF7970A_ST_WAIT_FOR_RX_DATA_CONT)\n\t\ttrf7970a_drain_fifo(trf, TRF7970A_IRQ_STATUS_SRX);\n\telse if (trf->state == TRF7970A_ST_WAIT_TO_ISSUE_EOF)\n\t\ttrf7970a_issue_eof(trf);\n\telse\n\t\ttrf7970a_send_err_upstream(trf, -ETIMEDOUT);\n\n\tmutex_unlock(&trf->lock);\n}\n\nstatic int trf7970a_init(struct trf7970a *trf)\n{\n\tint ret;\n\n\tdev_dbg(trf->dev, \"Initializing device - state: %d\\n\", trf->state);\n\n\tret = trf7970a_cmd(trf, TRF7970A_CMD_SOFT_INIT);\n\tif (ret)\n\t\tgoto err_out;\n\n\tret = trf7970a_cmd(trf, TRF7970A_CMD_IDLE);\n\tif (ret)\n\t\tgoto err_out;\n\n\tret = trf7970a_write(trf, TRF7970A_REG_IO_CTRL,\n\t\t\t     trf->io_ctrl | TRF7970A_REG_IO_CTRL_VRS(0x1));\n\tif (ret)\n\t\tgoto err_out;\n\n\tret = trf7970a_write(trf, TRF7970A_NFC_TARGET_LEVEL, 0);\n\tif (ret)\n\t\tgoto err_out;\n\n\tusleep_range(1000, 2000);\n\n\ttrf->chip_status_ctrl &= ~TRF7970A_CHIP_STATUS_RF_ON;\n\n\tret = trf7970a_write(trf, TRF7970A_MODULATOR_SYS_CLK_CTRL,\n\t\t\t     trf->modulator_sys_clk_ctrl);\n\tif (ret)\n\t\tgoto err_out;\n\n\tret = trf7970a_write(trf, TRF7970A_ADJUTABLE_FIFO_IRQ_LEVELS,\n\t\t\t     TRF7970A_ADJUTABLE_FIFO_IRQ_LEVELS_WLH_96 |\n\t\t\t     TRF7970A_ADJUTABLE_FIFO_IRQ_LEVELS_WLL_32);\n\tif (ret)\n\t\tgoto err_out;\n\n\tret = trf7970a_write(trf, TRF7970A_SPECIAL_FCN_REG1, 0);\n\tif (ret)\n\t\tgoto err_out;\n\n\ttrf->special_fcn_reg1 = 0;\n\n\ttrf->iso_ctrl = 0xff;\n\treturn 0;\n\nerr_out:\n\tdev_dbg(trf->dev, \"Couldn't init device: %d\\n\", ret);\n\treturn ret;\n}\n\nstatic void trf7970a_switch_rf_off(struct trf7970a *trf)\n{\n\tif ((trf->state == TRF7970A_ST_PWR_OFF) ||\n\t    (trf->state == TRF7970A_ST_RF_OFF))\n\t\treturn;\n\n\tdev_dbg(trf->dev, \"Switching rf off\\n\");\n\n\ttrf->chip_status_ctrl &= ~TRF7970A_CHIP_STATUS_RF_ON;\n\n\ttrf7970a_write(trf, TRF7970A_CHIP_STATUS_CTRL, trf->chip_status_ctrl);\n\n\ttrf->aborting = false;\n\ttrf->state = TRF7970A_ST_RF_OFF;\n\n\tpm_runtime_mark_last_busy(trf->dev);\n\tpm_runtime_put_autosuspend(trf->dev);\n}\n\nstatic int trf7970a_switch_rf_on(struct trf7970a *trf)\n{\n\tint ret;\n\n\tdev_dbg(trf->dev, \"Switching rf on\\n\");\n\n\tpm_runtime_get_sync(trf->dev);\n\n\tif (trf->state != TRF7970A_ST_RF_OFF) {\t \n\t\tdev_err(trf->dev, \"%s - Incorrect state: %d\\n\", __func__,\n\t\t\ttrf->state);\n\t\treturn -EINVAL;\n\t}\n\n\tret = trf7970a_init(trf);\n\tif (ret) {\n\t\tdev_err(trf->dev, \"%s - Can't initialize: %d\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\ttrf->state = TRF7970A_ST_IDLE;\n\n\treturn 0;\n}\n\nstatic int trf7970a_switch_rf(struct nfc_digital_dev *ddev, bool on)\n{\n\tstruct trf7970a *trf = nfc_digital_get_drvdata(ddev);\n\tint ret = 0;\n\n\tdev_dbg(trf->dev, \"Switching RF - state: %d, on: %d\\n\", trf->state, on);\n\n\tmutex_lock(&trf->lock);\n\n\tif (on) {\n\t\tswitch (trf->state) {\n\t\tcase TRF7970A_ST_PWR_OFF:\n\t\tcase TRF7970A_ST_RF_OFF:\n\t\t\tret = trf7970a_switch_rf_on(trf);\n\t\t\tbreak;\n\t\tcase TRF7970A_ST_IDLE:\n\t\tcase TRF7970A_ST_IDLE_RX_BLOCKED:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(trf->dev, \"%s - Invalid request: %d %d\\n\",\n\t\t\t\t__func__, trf->state, on);\n\t\t\ttrf7970a_switch_rf_off(trf);\n\t\t\tret = -EINVAL;\n\t\t}\n\t} else {\n\t\tswitch (trf->state) {\n\t\tcase TRF7970A_ST_PWR_OFF:\n\t\tcase TRF7970A_ST_RF_OFF:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(trf->dev, \"%s - Invalid request: %d %d\\n\",\n\t\t\t\t__func__, trf->state, on);\n\t\t\tret = -EINVAL;\n\t\t\tfallthrough;\n\t\tcase TRF7970A_ST_IDLE:\n\t\tcase TRF7970A_ST_IDLE_RX_BLOCKED:\n\t\tcase TRF7970A_ST_WAIT_FOR_RX_DATA:\n\t\tcase TRF7970A_ST_WAIT_FOR_RX_DATA_CONT:\n\t\t\ttrf7970a_switch_rf_off(trf);\n\t\t}\n\t}\n\n\tmutex_unlock(&trf->lock);\n\treturn ret;\n}\n\nstatic int trf7970a_in_config_rf_tech(struct trf7970a *trf, int tech)\n{\n\tint ret = 0;\n\n\tdev_dbg(trf->dev, \"rf technology: %d\\n\", tech);\n\n\tswitch (tech) {\n\tcase NFC_DIGITAL_RF_TECH_106A:\n\t\ttrf->iso_ctrl_tech = TRF7970A_ISO_CTRL_14443A_106;\n\t\ttrf->modulator_sys_clk_ctrl =\n\t\t    (trf->modulator_sys_clk_ctrl & 0xf8) |\n\t\t    TRF7970A_MODULATOR_DEPTH_OOK;\n\t\ttrf->guard_time = TRF7970A_GUARD_TIME_NFCA;\n\t\tbreak;\n\tcase NFC_DIGITAL_RF_TECH_106B:\n\t\ttrf->iso_ctrl_tech = TRF7970A_ISO_CTRL_14443B_106;\n\t\ttrf->modulator_sys_clk_ctrl =\n\t\t    (trf->modulator_sys_clk_ctrl & 0xf8) |\n\t\t    TRF7970A_MODULATOR_DEPTH_ASK10;\n\t\ttrf->guard_time = TRF7970A_GUARD_TIME_NFCB;\n\t\tbreak;\n\tcase NFC_DIGITAL_RF_TECH_212F:\n\t\ttrf->iso_ctrl_tech = TRF7970A_ISO_CTRL_FELICA_212;\n\t\ttrf->modulator_sys_clk_ctrl =\n\t\t    (trf->modulator_sys_clk_ctrl & 0xf8) |\n\t\t    TRF7970A_MODULATOR_DEPTH_ASK10;\n\t\ttrf->guard_time = TRF7970A_GUARD_TIME_NFCF;\n\t\tbreak;\n\tcase NFC_DIGITAL_RF_TECH_424F:\n\t\ttrf->iso_ctrl_tech = TRF7970A_ISO_CTRL_FELICA_424;\n\t\ttrf->modulator_sys_clk_ctrl =\n\t\t    (trf->modulator_sys_clk_ctrl & 0xf8) |\n\t\t    TRF7970A_MODULATOR_DEPTH_ASK10;\n\t\ttrf->guard_time = TRF7970A_GUARD_TIME_NFCF;\n\t\tbreak;\n\tcase NFC_DIGITAL_RF_TECH_ISO15693:\n\t\ttrf->iso_ctrl_tech = TRF7970A_ISO_CTRL_15693_SGL_1OF4_2648;\n\t\ttrf->modulator_sys_clk_ctrl =\n\t\t    (trf->modulator_sys_clk_ctrl & 0xf8) |\n\t\t    TRF7970A_MODULATOR_DEPTH_OOK;\n\t\ttrf->guard_time = TRF7970A_GUARD_TIME_15693;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(trf->dev, \"Unsupported rf technology: %d\\n\", tech);\n\t\treturn -EINVAL;\n\t}\n\n\ttrf->technology = tech;\n\n\t \n\tif (trf->iso_ctrl == 0xff)\n\t\tret = trf7970a_write(trf, TRF7970A_NFC_TARGET_LEVEL, 0);\n\n\treturn ret;\n}\n\nstatic int trf7970a_is_rf_field(struct trf7970a *trf, bool *is_rf_field)\n{\n\tint ret;\n\tu8 rssi;\n\n\tret = trf7970a_write(trf, TRF7970A_CHIP_STATUS_CTRL,\n\t\t\t     trf->chip_status_ctrl |\n\t\t\t     TRF7970A_CHIP_STATUS_REC_ON);\n\tif (ret)\n\t\treturn ret;\n\n\tret = trf7970a_cmd(trf, TRF7970A_CMD_TEST_EXT_RF);\n\tif (ret)\n\t\treturn ret;\n\n\tusleep_range(50, 60);\n\n\tret = trf7970a_read(trf, TRF7970A_RSSI_OSC_STATUS, &rssi);\n\tif (ret)\n\t\treturn ret;\n\n\tret = trf7970a_write(trf, TRF7970A_CHIP_STATUS_CTRL,\n\t\t\t     trf->chip_status_ctrl);\n\tif (ret)\n\t\treturn ret;\n\n\tif (rssi & TRF7970A_RSSI_OSC_STATUS_RSSI_MASK)\n\t\t*is_rf_field = true;\n\telse\n\t\t*is_rf_field = false;\n\n\treturn 0;\n}\n\nstatic int trf7970a_in_config_framing(struct trf7970a *trf, int framing)\n{\n\tu8 iso_ctrl = trf->iso_ctrl_tech;\n\tbool is_rf_field = false;\n\tint ret;\n\n\tdev_dbg(trf->dev, \"framing: %d\\n\", framing);\n\n\tswitch (framing) {\n\tcase NFC_DIGITAL_FRAMING_NFCA_SHORT:\n\tcase NFC_DIGITAL_FRAMING_NFCA_STANDARD:\n\t\ttrf->tx_cmd = TRF7970A_CMD_TRANSMIT_NO_CRC;\n\t\tiso_ctrl |= TRF7970A_ISO_CTRL_RX_CRC_N;\n\t\tbreak;\n\tcase NFC_DIGITAL_FRAMING_NFCA_STANDARD_WITH_CRC_A:\n\tcase NFC_DIGITAL_FRAMING_NFCA_T4T:\n\tcase NFC_DIGITAL_FRAMING_NFCB:\n\tcase NFC_DIGITAL_FRAMING_NFCB_T4T:\n\tcase NFC_DIGITAL_FRAMING_NFCF:\n\tcase NFC_DIGITAL_FRAMING_NFCF_T3T:\n\tcase NFC_DIGITAL_FRAMING_ISO15693_INVENTORY:\n\tcase NFC_DIGITAL_FRAMING_ISO15693_T5T:\n\tcase NFC_DIGITAL_FRAMING_NFCA_NFC_DEP:\n\tcase NFC_DIGITAL_FRAMING_NFCF_NFC_DEP:\n\t\ttrf->tx_cmd = TRF7970A_CMD_TRANSMIT;\n\t\tiso_ctrl &= ~TRF7970A_ISO_CTRL_RX_CRC_N;\n\t\tbreak;\n\tcase NFC_DIGITAL_FRAMING_NFCA_T2T:\n\t\ttrf->tx_cmd = TRF7970A_CMD_TRANSMIT;\n\t\tiso_ctrl |= TRF7970A_ISO_CTRL_RX_CRC_N;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(trf->dev, \"Unsupported Framing: %d\\n\", framing);\n\t\treturn -EINVAL;\n\t}\n\n\ttrf->framing = framing;\n\n\tif (!(trf->chip_status_ctrl & TRF7970A_CHIP_STATUS_RF_ON)) {\n\t\tret = trf7970a_is_rf_field(trf, &is_rf_field);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (is_rf_field)\n\t\t\treturn -EBUSY;\n\t}\n\n\tif (iso_ctrl != trf->iso_ctrl) {\n\t\tret = trf7970a_write(trf, TRF7970A_ISO_CTRL, iso_ctrl);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\ttrf->iso_ctrl = iso_ctrl;\n\n\t\tret = trf7970a_write(trf, TRF7970A_MODULATOR_SYS_CLK_CTRL,\n\t\t\t\t     trf->modulator_sys_clk_ctrl);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (!(trf->chip_status_ctrl & TRF7970A_CHIP_STATUS_RF_ON)) {\n\t\tret = trf7970a_write(trf, TRF7970A_CHIP_STATUS_CTRL,\n\t\t\t\t     trf->chip_status_ctrl |\n\t\t\t\t     TRF7970A_CHIP_STATUS_RF_ON);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\ttrf->chip_status_ctrl |= TRF7970A_CHIP_STATUS_RF_ON;\n\n\t\tusleep_range(trf->guard_time, trf->guard_time + 1000);\n\t}\n\n\treturn 0;\n}\n\nstatic int trf7970a_in_configure_hw(struct nfc_digital_dev *ddev, int type,\n\t\t\t\t    int param)\n{\n\tstruct trf7970a *trf = nfc_digital_get_drvdata(ddev);\n\tint ret;\n\n\tdev_dbg(trf->dev, \"Configure hw - type: %d, param: %d\\n\", type, param);\n\n\tmutex_lock(&trf->lock);\n\n\ttrf->is_initiator = true;\n\n\tif ((trf->state == TRF7970A_ST_PWR_OFF) ||\n\t    (trf->state == TRF7970A_ST_RF_OFF)) {\n\t\tret = trf7970a_switch_rf_on(trf);\n\t\tif (ret)\n\t\t\tgoto err_unlock;\n\t}\n\n\tswitch (type) {\n\tcase NFC_DIGITAL_CONFIG_RF_TECH:\n\t\tret = trf7970a_in_config_rf_tech(trf, param);\n\t\tbreak;\n\tcase NFC_DIGITAL_CONFIG_FRAMING:\n\t\tret = trf7970a_in_config_framing(trf, param);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(trf->dev, \"Unknown type: %d\\n\", type);\n\t\tret = -EINVAL;\n\t}\n\nerr_unlock:\n\tmutex_unlock(&trf->lock);\n\treturn ret;\n}\n\nstatic int trf7970a_is_iso15693_write_or_lock(u8 cmd)\n{\n\tswitch (cmd) {\n\tcase ISO15693_CMD_WRITE_SINGLE_BLOCK:\n\tcase ISO15693_CMD_LOCK_BLOCK:\n\tcase ISO15693_CMD_WRITE_MULTIPLE_BLOCK:\n\tcase ISO15693_CMD_WRITE_AFI:\n\tcase ISO15693_CMD_LOCK_AFI:\n\tcase ISO15693_CMD_WRITE_DSFID:\n\tcase ISO15693_CMD_LOCK_DSFID:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int trf7970a_per_cmd_config(struct trf7970a *trf,\n\t\t\t\t   const struct sk_buff *skb)\n{\n\tconst u8 *req = skb->data;\n\tu8 special_fcn_reg1, iso_ctrl;\n\tint ret;\n\n\ttrf->issue_eof = false;\n\n\t \n\tif ((trf->technology == NFC_DIGITAL_RF_TECH_106A) &&\n\t    (trf->framing == NFC_DIGITAL_FRAMING_NFCA_T2T)) {\n\t\tif (req[0] == NFC_T2T_CMD_READ)\n\t\t\tspecial_fcn_reg1 = 0;\n\t\telse\n\t\t\tspecial_fcn_reg1 = TRF7970A_SPECIAL_FCN_REG1_4_BIT_RX;\n\n\t\tif (special_fcn_reg1 != trf->special_fcn_reg1) {\n\t\t\tret = trf7970a_write(trf, TRF7970A_SPECIAL_FCN_REG1,\n\t\t\t\t\t     special_fcn_reg1);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\ttrf->special_fcn_reg1 = special_fcn_reg1;\n\t\t}\n\t} else if (trf->technology == NFC_DIGITAL_RF_TECH_ISO15693) {\n\t\tiso_ctrl = trf->iso_ctrl & ~TRF7970A_ISO_CTRL_RFID_SPEED_MASK;\n\n\t\tswitch (req[0] & ISO15693_REQ_FLAG_SPEED_MASK) {\n\t\tcase 0x00:\n\t\t\tiso_ctrl |= TRF7970A_ISO_CTRL_15693_SGL_1OF4_662;\n\t\t\tbreak;\n\t\tcase ISO15693_REQ_FLAG_SUB_CARRIER:\n\t\t\tiso_ctrl |= TRF7970A_ISO_CTRL_15693_DBL_1OF4_667a;\n\t\t\tbreak;\n\t\tcase ISO15693_REQ_FLAG_DATA_RATE:\n\t\t\tiso_ctrl |= TRF7970A_ISO_CTRL_15693_SGL_1OF4_2648;\n\t\t\tbreak;\n\t\tcase (ISO15693_REQ_FLAG_SUB_CARRIER |\n\t\t      ISO15693_REQ_FLAG_DATA_RATE):\n\t\t\tiso_ctrl |= TRF7970A_ISO_CTRL_15693_DBL_1OF4_2669;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (iso_ctrl != trf->iso_ctrl) {\n\t\t\tret = trf7970a_write(trf, TRF7970A_ISO_CTRL, iso_ctrl);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\ttrf->iso_ctrl = iso_ctrl;\n\t\t}\n\n\t\tif ((trf->framing == NFC_DIGITAL_FRAMING_ISO15693_T5T) &&\n\t\t    trf7970a_is_iso15693_write_or_lock(req[1]) &&\n\t\t    (req[0] & ISO15693_REQ_FLAG_OPTION))\n\t\t\ttrf->issue_eof = true;\n\t}\n\n\treturn 0;\n}\n\nstatic int trf7970a_send_cmd(struct nfc_digital_dev *ddev,\n\t\t\t     struct sk_buff *skb, u16 timeout,\n\t\t\t     nfc_digital_cmd_complete_t cb, void *arg)\n{\n\tstruct trf7970a *trf = nfc_digital_get_drvdata(ddev);\n\tu8 prefix[5];\n\tunsigned int len;\n\tint ret;\n\tu8 status;\n\n\tdev_dbg(trf->dev, \"New request - state: %d, timeout: %d ms, len: %d\\n\",\n\t\ttrf->state, timeout, skb->len);\n\n\tif (skb->len > TRF7970A_TX_MAX)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&trf->lock);\n\n\tif ((trf->state != TRF7970A_ST_IDLE) &&\n\t    (trf->state != TRF7970A_ST_IDLE_RX_BLOCKED)) {\n\t\tdev_err(trf->dev, \"%s - Bogus state: %d\\n\", __func__,\n\t\t\ttrf->state);\n\t\tret = -EIO;\n\t\tgoto out_err;\n\t}\n\n\tif (trf->aborting) {\n\t\tdev_dbg(trf->dev, \"Abort process complete\\n\");\n\t\ttrf->aborting = false;\n\t\tret = -ECANCELED;\n\t\tgoto out_err;\n\t}\n\n\tif (timeout) {\n\t\ttrf->rx_skb = nfc_alloc_recv_skb(TRF7970A_RX_SKB_ALLOC_SIZE,\n\t\t\t\t\t\t GFP_KERNEL);\n\t\tif (!trf->rx_skb) {\n\t\t\tdev_dbg(trf->dev, \"Can't alloc rx_skb\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\tif (trf->state == TRF7970A_ST_IDLE_RX_BLOCKED) {\n\t\tret = trf7970a_cmd(trf, TRF7970A_CMD_ENABLE_RX);\n\t\tif (ret)\n\t\t\tgoto out_err;\n\n\t\ttrf->state = TRF7970A_ST_IDLE;\n\t}\n\n\tif (trf->is_initiator) {\n\t\tret = trf7970a_per_cmd_config(trf, skb);\n\t\tif (ret)\n\t\t\tgoto out_err;\n\t}\n\n\ttrf->ddev = ddev;\n\ttrf->tx_skb = skb;\n\ttrf->cb = cb;\n\ttrf->cb_arg = arg;\n\ttrf->timeout = timeout;\n\ttrf->ignore_timeout = false;\n\n\tlen = skb->len;\n\n\t \n\tprefix[0] = TRF7970A_CMD_BIT_CTRL |\n\t    TRF7970A_CMD_BIT_OPCODE(TRF7970A_CMD_FIFO_RESET);\n\tprefix[1] = TRF7970A_CMD_BIT_CTRL |\n\t    TRF7970A_CMD_BIT_OPCODE(trf->tx_cmd);\n\tprefix[2] = TRF7970A_CMD_BIT_CONTINUOUS | TRF7970A_TX_LENGTH_BYTE1;\n\n\tif (trf->framing == NFC_DIGITAL_FRAMING_NFCA_SHORT) {\n\t\tprefix[3] = 0x00;\n\t\tprefix[4] = 0x0f;\t \n\t} else {\n\t\tprefix[3] = (len & 0xf00) >> 4;\n\t\tprefix[3] |= ((len & 0xf0) >> 4);\n\t\tprefix[4] = ((len & 0x0f) << 4);\n\t}\n\n\tlen = min_t(int, skb->len, TRF7970A_FIFO_SIZE);\n\n\t \n\tret = trf7970a_read_irqstatus(trf, &status);\n\tif (ret)\n\t\tgoto out_err;\n\n\tret = trf7970a_transmit(trf, skb, len, prefix, sizeof(prefix));\n\tif (ret) {\n\t\tkfree_skb(trf->rx_skb);\n\t\ttrf->rx_skb = NULL;\n\t}\n\nout_err:\n\tmutex_unlock(&trf->lock);\n\treturn ret;\n}\n\nstatic int trf7970a_tg_config_rf_tech(struct trf7970a *trf, int tech)\n{\n\tint ret = 0;\n\n\tdev_dbg(trf->dev, \"rf technology: %d\\n\", tech);\n\n\tswitch (tech) {\n\tcase NFC_DIGITAL_RF_TECH_106A:\n\t\ttrf->iso_ctrl_tech = TRF7970A_ISO_CTRL_NFC_NFC_CE_MODE |\n\t\t    TRF7970A_ISO_CTRL_NFC_CE | TRF7970A_ISO_CTRL_NFC_CE_14443A;\n\t\ttrf->modulator_sys_clk_ctrl =\n\t\t    (trf->modulator_sys_clk_ctrl & 0xf8) |\n\t\t    TRF7970A_MODULATOR_DEPTH_OOK;\n\t\tbreak;\n\tcase NFC_DIGITAL_RF_TECH_212F:\n\t\ttrf->iso_ctrl_tech = TRF7970A_ISO_CTRL_NFC_NFC_CE_MODE |\n\t\t    TRF7970A_ISO_CTRL_NFC_NFCF_212;\n\t\ttrf->modulator_sys_clk_ctrl =\n\t\t    (trf->modulator_sys_clk_ctrl & 0xf8) |\n\t\t    TRF7970A_MODULATOR_DEPTH_ASK10;\n\t\tbreak;\n\tcase NFC_DIGITAL_RF_TECH_424F:\n\t\ttrf->iso_ctrl_tech = TRF7970A_ISO_CTRL_NFC_NFC_CE_MODE |\n\t\t    TRF7970A_ISO_CTRL_NFC_NFCF_424;\n\t\ttrf->modulator_sys_clk_ctrl =\n\t\t    (trf->modulator_sys_clk_ctrl & 0xf8) |\n\t\t    TRF7970A_MODULATOR_DEPTH_ASK10;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(trf->dev, \"Unsupported rf technology: %d\\n\", tech);\n\t\treturn -EINVAL;\n\t}\n\n\ttrf->technology = tech;\n\n\t \n\tif ((trf->framing == NFC_DIGITAL_FRAMING_NFC_DEP_ACTIVATED) &&\n\t    (trf->iso_ctrl_tech != trf->iso_ctrl)) {\n\t\tret = trf7970a_write(trf, TRF7970A_ISO_CTRL,\n\t\t\t\t     trf->iso_ctrl_tech);\n\n\t\ttrf->iso_ctrl = trf->iso_ctrl_tech;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int trf7970a_tg_config_framing(struct trf7970a *trf, int framing)\n{\n\tu8 iso_ctrl = trf->iso_ctrl_tech;\n\tint ret;\n\n\tdev_dbg(trf->dev, \"framing: %d\\n\", framing);\n\n\tswitch (framing) {\n\tcase NFC_DIGITAL_FRAMING_NFCA_NFC_DEP:\n\t\ttrf->tx_cmd = TRF7970A_CMD_TRANSMIT_NO_CRC;\n\t\tiso_ctrl |= TRF7970A_ISO_CTRL_RX_CRC_N;\n\t\tbreak;\n\tcase NFC_DIGITAL_FRAMING_NFCA_STANDARD:\n\tcase NFC_DIGITAL_FRAMING_NFCA_STANDARD_WITH_CRC_A:\n\tcase NFC_DIGITAL_FRAMING_NFCA_ANTICOL_COMPLETE:\n\t\t \n\t\tiso_ctrl = trf->iso_ctrl;  \n\t\tbreak;\n\tcase NFC_DIGITAL_FRAMING_NFCF_NFC_DEP:\n\t\ttrf->tx_cmd = TRF7970A_CMD_TRANSMIT;\n\t\tiso_ctrl &= ~TRF7970A_ISO_CTRL_RX_CRC_N;\n\t\tbreak;\n\tcase NFC_DIGITAL_FRAMING_NFC_DEP_ACTIVATED:\n\t\ttrf->tx_cmd = TRF7970A_CMD_TRANSMIT;\n\t\tiso_ctrl &= ~TRF7970A_ISO_CTRL_RX_CRC_N;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(trf->dev, \"Unsupported Framing: %d\\n\", framing);\n\t\treturn -EINVAL;\n\t}\n\n\ttrf->framing = framing;\n\n\tif (iso_ctrl != trf->iso_ctrl) {\n\t\tret = trf7970a_write(trf, TRF7970A_ISO_CTRL, iso_ctrl);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\ttrf->iso_ctrl = iso_ctrl;\n\n\t\tret = trf7970a_write(trf, TRF7970A_MODULATOR_SYS_CLK_CTRL,\n\t\t\t\t     trf->modulator_sys_clk_ctrl);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (!(trf->chip_status_ctrl & TRF7970A_CHIP_STATUS_RF_ON)) {\n\t\tret = trf7970a_write(trf, TRF7970A_CHIP_STATUS_CTRL,\n\t\t\t\t     trf->chip_status_ctrl |\n\t\t\t\t     TRF7970A_CHIP_STATUS_RF_ON);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\ttrf->chip_status_ctrl |= TRF7970A_CHIP_STATUS_RF_ON;\n\t}\n\n\treturn 0;\n}\n\nstatic int trf7970a_tg_configure_hw(struct nfc_digital_dev *ddev, int type,\n\t\t\t\t    int param)\n{\n\tstruct trf7970a *trf = nfc_digital_get_drvdata(ddev);\n\tint ret;\n\n\tdev_dbg(trf->dev, \"Configure hw - type: %d, param: %d\\n\", type, param);\n\n\tmutex_lock(&trf->lock);\n\n\ttrf->is_initiator = false;\n\n\tif ((trf->state == TRF7970A_ST_PWR_OFF) ||\n\t    (trf->state == TRF7970A_ST_RF_OFF)) {\n\t\tret = trf7970a_switch_rf_on(trf);\n\t\tif (ret)\n\t\t\tgoto err_unlock;\n\t}\n\n\tswitch (type) {\n\tcase NFC_DIGITAL_CONFIG_RF_TECH:\n\t\tret = trf7970a_tg_config_rf_tech(trf, param);\n\t\tbreak;\n\tcase NFC_DIGITAL_CONFIG_FRAMING:\n\t\tret = trf7970a_tg_config_framing(trf, param);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(trf->dev, \"Unknown type: %d\\n\", type);\n\t\tret = -EINVAL;\n\t}\n\nerr_unlock:\n\tmutex_unlock(&trf->lock);\n\treturn ret;\n}\n\nstatic int _trf7970a_tg_listen(struct nfc_digital_dev *ddev, u16 timeout,\n\t\t\t       nfc_digital_cmd_complete_t cb, void *arg,\n\t\t\t       bool mode_detect)\n{\n\tstruct trf7970a *trf = nfc_digital_get_drvdata(ddev);\n\tint ret;\n\n\tmutex_lock(&trf->lock);\n\n\tif ((trf->state != TRF7970A_ST_IDLE) &&\n\t    (trf->state != TRF7970A_ST_IDLE_RX_BLOCKED)) {\n\t\tdev_err(trf->dev, \"%s - Bogus state: %d\\n\", __func__,\n\t\t\ttrf->state);\n\t\tret = -EIO;\n\t\tgoto out_err;\n\t}\n\n\tif (trf->aborting) {\n\t\tdev_dbg(trf->dev, \"Abort process complete\\n\");\n\t\ttrf->aborting = false;\n\t\tret = -ECANCELED;\n\t\tgoto out_err;\n\t}\n\n\ttrf->rx_skb = nfc_alloc_recv_skb(TRF7970A_RX_SKB_ALLOC_SIZE,\n\t\t\t\t\t GFP_KERNEL);\n\tif (!trf->rx_skb) {\n\t\tdev_dbg(trf->dev, \"Can't alloc rx_skb\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\tret = trf7970a_write(trf, TRF7970A_RX_SPECIAL_SETTINGS,\n\t\t\t     TRF7970A_RX_SPECIAL_SETTINGS_HBT |\n\t\t\t     TRF7970A_RX_SPECIAL_SETTINGS_M848 |\n\t\t\t     TRF7970A_RX_SPECIAL_SETTINGS_C424 |\n\t\t\t     TRF7970A_RX_SPECIAL_SETTINGS_C212);\n\tif (ret)\n\t\tgoto out_err;\n\n\tret = trf7970a_write(trf, TRF7970A_REG_IO_CTRL,\n\t\t\t     trf->io_ctrl | TRF7970A_REG_IO_CTRL_VRS(0x1));\n\tif (ret)\n\t\tgoto out_err;\n\n\tret = trf7970a_write(trf, TRF7970A_NFC_LOW_FIELD_LEVEL,\n\t\t\t     TRF7970A_NFC_LOW_FIELD_LEVEL_RFDET(0x3));\n\tif (ret)\n\t\tgoto out_err;\n\n\tret = trf7970a_write(trf, TRF7970A_NFC_TARGET_LEVEL,\n\t\t\t     TRF7970A_NFC_TARGET_LEVEL_RFDET(0x7));\n\tif (ret)\n\t\tgoto out_err;\n\n\ttrf->ddev = ddev;\n\ttrf->cb = cb;\n\ttrf->cb_arg = arg;\n\ttrf->timeout = timeout;\n\ttrf->ignore_timeout = false;\n\n\tret = trf7970a_cmd(trf, TRF7970A_CMD_ENABLE_RX);\n\tif (ret)\n\t\tgoto out_err;\n\n\ttrf->state = mode_detect ? TRF7970A_ST_LISTENING_MD :\n\t\t\t\t   TRF7970A_ST_LISTENING;\n\n\tschedule_delayed_work(&trf->timeout_work, msecs_to_jiffies(timeout));\n\nout_err:\n\tmutex_unlock(&trf->lock);\n\treturn ret;\n}\n\nstatic int trf7970a_tg_listen(struct nfc_digital_dev *ddev, u16 timeout,\n\t\t\t      nfc_digital_cmd_complete_t cb, void *arg)\n{\n\tconst struct trf7970a *trf = nfc_digital_get_drvdata(ddev);\n\n\tdev_dbg(trf->dev, \"Listen - state: %d, timeout: %d ms\\n\",\n\t\ttrf->state, timeout);\n\n\treturn _trf7970a_tg_listen(ddev, timeout, cb, arg, false);\n}\n\nstatic int trf7970a_tg_listen_md(struct nfc_digital_dev *ddev,\n\t\t\t\t u16 timeout, nfc_digital_cmd_complete_t cb,\n\t\t\t\t void *arg)\n{\n\tconst struct trf7970a *trf = nfc_digital_get_drvdata(ddev);\n\tint ret;\n\n\tdev_dbg(trf->dev, \"Listen MD - state: %d, timeout: %d ms\\n\",\n\t\ttrf->state, timeout);\n\n\tret = trf7970a_tg_configure_hw(ddev, NFC_DIGITAL_CONFIG_RF_TECH,\n\t\t\t\t       NFC_DIGITAL_RF_TECH_106A);\n\tif (ret)\n\t\treturn ret;\n\n\tret = trf7970a_tg_configure_hw(ddev, NFC_DIGITAL_CONFIG_FRAMING,\n\t\t\t\t       NFC_DIGITAL_FRAMING_NFCA_NFC_DEP);\n\tif (ret)\n\t\treturn ret;\n\n\treturn _trf7970a_tg_listen(ddev, timeout, cb, arg, true);\n}\n\nstatic int trf7970a_tg_get_rf_tech(struct nfc_digital_dev *ddev, u8 *rf_tech)\n{\n\tconst struct trf7970a *trf = nfc_digital_get_drvdata(ddev);\n\n\tdev_dbg(trf->dev, \"Get RF Tech - state: %d, rf_tech: %d\\n\",\n\t\ttrf->state, trf->md_rf_tech);\n\n\t*rf_tech = trf->md_rf_tech;\n\n\treturn 0;\n}\n\nstatic void trf7970a_abort_cmd(struct nfc_digital_dev *ddev)\n{\n\tstruct trf7970a *trf = nfc_digital_get_drvdata(ddev);\n\n\tdev_dbg(trf->dev, \"Abort process initiated\\n\");\n\n\tmutex_lock(&trf->lock);\n\n\tswitch (trf->state) {\n\tcase TRF7970A_ST_WAIT_FOR_TX_FIFO:\n\tcase TRF7970A_ST_WAIT_FOR_RX_DATA:\n\tcase TRF7970A_ST_WAIT_FOR_RX_DATA_CONT:\n\tcase TRF7970A_ST_WAIT_TO_ISSUE_EOF:\n\t\ttrf->aborting = true;\n\t\tbreak;\n\tcase TRF7970A_ST_LISTENING:\n\t\ttrf->ignore_timeout = !cancel_delayed_work(&trf->timeout_work);\n\t\ttrf7970a_send_err_upstream(trf, -ECANCELED);\n\t\tdev_dbg(trf->dev, \"Abort process complete\\n\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&trf->lock);\n}\n\nstatic const struct nfc_digital_ops trf7970a_nfc_ops = {\n\t.in_configure_hw\t= trf7970a_in_configure_hw,\n\t.in_send_cmd\t\t= trf7970a_send_cmd,\n\t.tg_configure_hw\t= trf7970a_tg_configure_hw,\n\t.tg_send_cmd\t\t= trf7970a_send_cmd,\n\t.tg_listen\t\t= trf7970a_tg_listen,\n\t.tg_listen_md\t\t= trf7970a_tg_listen_md,\n\t.tg_get_rf_tech\t\t= trf7970a_tg_get_rf_tech,\n\t.switch_rf\t\t= trf7970a_switch_rf,\n\t.abort_cmd\t\t= trf7970a_abort_cmd,\n};\n\nstatic int trf7970a_power_up(struct trf7970a *trf)\n{\n\tint ret;\n\n\tdev_dbg(trf->dev, \"Powering up - state: %d\\n\", trf->state);\n\n\tif (trf->state != TRF7970A_ST_PWR_OFF)\n\t\treturn 0;\n\n\tret = regulator_enable(trf->regulator);\n\tif (ret) {\n\t\tdev_err(trf->dev, \"%s - Can't enable VIN: %d\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\tusleep_range(5000, 6000);\n\n\tif (trf->en2_gpiod &&\n\t    !(trf->quirks & TRF7970A_QUIRK_EN2_MUST_STAY_LOW)) {\n\t\tgpiod_set_value_cansleep(trf->en2_gpiod, 1);\n\t\tusleep_range(1000, 2000);\n\t}\n\n\tgpiod_set_value_cansleep(trf->en_gpiod, 1);\n\n\tusleep_range(20000, 21000);\n\n\ttrf->state = TRF7970A_ST_RF_OFF;\n\n\treturn 0;\n}\n\nstatic int trf7970a_power_down(struct trf7970a *trf)\n{\n\tint ret;\n\n\tdev_dbg(trf->dev, \"Powering down - state: %d\\n\", trf->state);\n\n\tif (trf->state == TRF7970A_ST_PWR_OFF)\n\t\treturn 0;\n\n\tif (trf->state != TRF7970A_ST_RF_OFF) {\n\t\tdev_dbg(trf->dev, \"Can't power down - not RF_OFF state (%d)\\n\",\n\t\t\ttrf->state);\n\t\treturn -EBUSY;\n\t}\n\n\tgpiod_set_value_cansleep(trf->en_gpiod, 0);\n\n\tif (trf->en2_gpiod && !(trf->quirks & TRF7970A_QUIRK_EN2_MUST_STAY_LOW))\n\t\tgpiod_set_value_cansleep(trf->en2_gpiod, 0);\n\n\tret = regulator_disable(trf->regulator);\n\tif (ret)\n\t\tdev_err(trf->dev, \"%s - Can't disable VIN: %d\\n\", __func__,\n\t\t\tret);\n\n\ttrf->state = TRF7970A_ST_PWR_OFF;\n\n\treturn ret;\n}\n\nstatic int trf7970a_startup(struct trf7970a *trf)\n{\n\tint ret;\n\n\tret = trf7970a_power_up(trf);\n\tif (ret)\n\t\treturn ret;\n\n\tpm_runtime_set_active(trf->dev);\n\tpm_runtime_enable(trf->dev);\n\tpm_runtime_mark_last_busy(trf->dev);\n\n\treturn 0;\n}\n\nstatic void trf7970a_shutdown(struct trf7970a *trf)\n{\n\tswitch (trf->state) {\n\tcase TRF7970A_ST_WAIT_FOR_TX_FIFO:\n\tcase TRF7970A_ST_WAIT_FOR_RX_DATA:\n\tcase TRF7970A_ST_WAIT_FOR_RX_DATA_CONT:\n\tcase TRF7970A_ST_WAIT_TO_ISSUE_EOF:\n\tcase TRF7970A_ST_LISTENING:\n\t\ttrf7970a_send_err_upstream(trf, -ECANCELED);\n\t\tfallthrough;\n\tcase TRF7970A_ST_IDLE:\n\tcase TRF7970A_ST_IDLE_RX_BLOCKED:\n\t\ttrf7970a_switch_rf_off(trf);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tpm_runtime_disable(trf->dev);\n\tpm_runtime_set_suspended(trf->dev);\n\n\ttrf7970a_power_down(trf);\n}\n\nstatic int trf7970a_get_autosuspend_delay(const struct device_node *np)\n{\n\tint autosuspend_delay, ret;\n\n\tret = of_property_read_u32(np, \"autosuspend-delay\", &autosuspend_delay);\n\tif (ret)\n\t\tautosuspend_delay = TRF7970A_AUTOSUSPEND_DELAY;\n\n\treturn autosuspend_delay;\n}\n\nstatic int trf7970a_probe(struct spi_device *spi)\n{\n\tconst struct device_node *np = spi->dev.of_node;\n\tstruct trf7970a *trf;\n\tint uvolts, autosuspend_delay, ret;\n\tu32 clk_freq = TRF7970A_13MHZ_CLOCK_FREQUENCY;\n\n\tif (!np) {\n\t\tdev_err(&spi->dev, \"No Device Tree entry\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttrf = devm_kzalloc(&spi->dev, sizeof(*trf), GFP_KERNEL);\n\tif (!trf)\n\t\treturn -ENOMEM;\n\n\ttrf->state = TRF7970A_ST_PWR_OFF;\n\ttrf->dev = &spi->dev;\n\ttrf->spi = spi;\n\n\tspi->mode = SPI_MODE_1;\n\tspi->bits_per_word = 8;\n\n\tret = spi_setup(spi);\n\tif (ret < 0) {\n\t\tdev_err(trf->dev, \"Can't set up SPI Communication\\n\");\n\t\treturn ret;\n\t}\n\n\tif (of_property_read_bool(np, \"irq-status-read-quirk\"))\n\t\ttrf->quirks |= TRF7970A_QUIRK_IRQ_STATUS_READ;\n\n\t \n\ttrf->en_gpiod = devm_gpiod_get_index(trf->dev, \"ti,enable\", 0,\n\t\t\t\t\t     GPIOD_OUT_LOW);\n\tif (IS_ERR(trf->en_gpiod)) {\n\t\tdev_err(trf->dev, \"No EN GPIO property\\n\");\n\t\treturn PTR_ERR(trf->en_gpiod);\n\t}\n\n\ttrf->en2_gpiod = devm_gpiod_get_index_optional(trf->dev, \"ti,enable\", 1,\n\t\t\t\t\t\t       GPIOD_OUT_LOW);\n\tif (!trf->en2_gpiod) {\n\t\tdev_info(trf->dev, \"No EN2 GPIO property\\n\");\n\t} else if (IS_ERR(trf->en2_gpiod)) {\n\t\tdev_err(trf->dev, \"Error getting EN2 GPIO property: %ld\\n\",\n\t\t\tPTR_ERR(trf->en2_gpiod));\n\t\treturn PTR_ERR(trf->en2_gpiod);\n\t} else if (of_property_read_bool(np, \"en2-rf-quirk\")) {\n\t\ttrf->quirks |= TRF7970A_QUIRK_EN2_MUST_STAY_LOW;\n\t}\n\n\tof_property_read_u32(np, \"clock-frequency\", &clk_freq);\n\tif ((clk_freq != TRF7970A_27MHZ_CLOCK_FREQUENCY) &&\n\t    (clk_freq != TRF7970A_13MHZ_CLOCK_FREQUENCY)) {\n\t\tdev_err(trf->dev,\n\t\t\t\"clock-frequency (%u Hz) unsupported\\n\", clk_freq);\n\t\treturn -EINVAL;\n\t}\n\n\tif (clk_freq == TRF7970A_27MHZ_CLOCK_FREQUENCY) {\n\t\ttrf->modulator_sys_clk_ctrl = TRF7970A_MODULATOR_27MHZ;\n\t\tdev_dbg(trf->dev, \"trf7970a configured for 27MHz crystal\\n\");\n\t} else {\n\t\ttrf->modulator_sys_clk_ctrl = 0;\n\t}\n\n\tret = devm_request_threaded_irq(trf->dev, spi->irq, NULL,\n\t\t\t\t\ttrf7970a_irq,\n\t\t\t\t\tIRQF_TRIGGER_RISING | IRQF_ONESHOT,\n\t\t\t\t\t\"trf7970a\", trf);\n\tif (ret) {\n\t\tdev_err(trf->dev, \"Can't request IRQ#%d: %d\\n\", spi->irq, ret);\n\t\treturn ret;\n\t}\n\n\tmutex_init(&trf->lock);\n\tINIT_DELAYED_WORK(&trf->timeout_work, trf7970a_timeout_work_handler);\n\n\ttrf->regulator = devm_regulator_get(&spi->dev, \"vin\");\n\tif (IS_ERR(trf->regulator)) {\n\t\tret = PTR_ERR(trf->regulator);\n\t\tdev_err(trf->dev, \"Can't get VIN regulator: %d\\n\", ret);\n\t\tgoto err_destroy_lock;\n\t}\n\n\tret = regulator_enable(trf->regulator);\n\tif (ret) {\n\t\tdev_err(trf->dev, \"Can't enable VIN: %d\\n\", ret);\n\t\tgoto err_destroy_lock;\n\t}\n\n\tuvolts = regulator_get_voltage(trf->regulator);\n\tif (uvolts > 4000000)\n\t\ttrf->chip_status_ctrl = TRF7970A_CHIP_STATUS_VRS5_3;\n\n\ttrf->regulator = devm_regulator_get(&spi->dev, \"vdd-io\");\n\tif (IS_ERR(trf->regulator)) {\n\t\tret = PTR_ERR(trf->regulator);\n\t\tdev_err(trf->dev, \"Can't get VDD_IO regulator: %d\\n\", ret);\n\t\tgoto err_destroy_lock;\n\t}\n\n\tret = regulator_enable(trf->regulator);\n\tif (ret) {\n\t\tdev_err(trf->dev, \"Can't enable VDD_IO: %d\\n\", ret);\n\t\tgoto err_destroy_lock;\n\t}\n\n\tif (regulator_get_voltage(trf->regulator) == 1800000) {\n\t\ttrf->io_ctrl = TRF7970A_REG_IO_CTRL_IO_LOW;\n\t\tdev_dbg(trf->dev, \"trf7970a config vdd_io to 1.8V\\n\");\n\t}\n\n\ttrf->ddev = nfc_digital_allocate_device(&trf7970a_nfc_ops,\n\t\t\t\t\t\tTRF7970A_SUPPORTED_PROTOCOLS,\n\t\t\t\t\t\tNFC_DIGITAL_DRV_CAPS_IN_CRC |\n\t\t\t\t\t\tNFC_DIGITAL_DRV_CAPS_TG_CRC, 0,\n\t\t\t\t\t\t0);\n\tif (!trf->ddev) {\n\t\tdev_err(trf->dev, \"Can't allocate NFC digital device\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_disable_regulator;\n\t}\n\n\tnfc_digital_set_parent_dev(trf->ddev, trf->dev);\n\tnfc_digital_set_drvdata(trf->ddev, trf);\n\tspi_set_drvdata(spi, trf);\n\n\tautosuspend_delay = trf7970a_get_autosuspend_delay(np);\n\n\tpm_runtime_set_autosuspend_delay(trf->dev, autosuspend_delay);\n\tpm_runtime_use_autosuspend(trf->dev);\n\n\tret = trf7970a_startup(trf);\n\tif (ret)\n\t\tgoto err_free_ddev;\n\n\tret = nfc_digital_register_device(trf->ddev);\n\tif (ret) {\n\t\tdev_err(trf->dev, \"Can't register NFC digital device: %d\\n\",\n\t\t\tret);\n\t\tgoto err_shutdown;\n\t}\n\n\treturn 0;\n\nerr_shutdown:\n\ttrf7970a_shutdown(trf);\nerr_free_ddev:\n\tnfc_digital_free_device(trf->ddev);\nerr_disable_regulator:\n\tregulator_disable(trf->regulator);\nerr_destroy_lock:\n\tmutex_destroy(&trf->lock);\n\treturn ret;\n}\n\nstatic void trf7970a_remove(struct spi_device *spi)\n{\n\tstruct trf7970a *trf = spi_get_drvdata(spi);\n\n\tmutex_lock(&trf->lock);\n\n\ttrf7970a_shutdown(trf);\n\n\tmutex_unlock(&trf->lock);\n\n\tnfc_digital_unregister_device(trf->ddev);\n\tnfc_digital_free_device(trf->ddev);\n\n\tregulator_disable(trf->regulator);\n\n\tmutex_destroy(&trf->lock);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int trf7970a_suspend(struct device *dev)\n{\n\tstruct spi_device *spi = to_spi_device(dev);\n\tstruct trf7970a *trf = spi_get_drvdata(spi);\n\n\tmutex_lock(&trf->lock);\n\n\ttrf7970a_shutdown(trf);\n\n\tmutex_unlock(&trf->lock);\n\n\treturn 0;\n}\n\nstatic int trf7970a_resume(struct device *dev)\n{\n\tstruct spi_device *spi = to_spi_device(dev);\n\tstruct trf7970a *trf = spi_get_drvdata(spi);\n\tint ret;\n\n\tmutex_lock(&trf->lock);\n\n\tret = trf7970a_startup(trf);\n\n\tmutex_unlock(&trf->lock);\n\n\treturn ret;\n}\n#endif\n\n#ifdef CONFIG_PM\nstatic int trf7970a_pm_runtime_suspend(struct device *dev)\n{\n\tstruct spi_device *spi = to_spi_device(dev);\n\tstruct trf7970a *trf = spi_get_drvdata(spi);\n\tint ret;\n\n\tmutex_lock(&trf->lock);\n\n\tret = trf7970a_power_down(trf);\n\n\tmutex_unlock(&trf->lock);\n\n\treturn ret;\n}\n\nstatic int trf7970a_pm_runtime_resume(struct device *dev)\n{\n\tstruct spi_device *spi = to_spi_device(dev);\n\tstruct trf7970a *trf = spi_get_drvdata(spi);\n\tint ret;\n\n\tret = trf7970a_power_up(trf);\n\tif (!ret)\n\t\tpm_runtime_mark_last_busy(dev);\n\n\treturn ret;\n}\n#endif\n\nstatic const struct dev_pm_ops trf7970a_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(trf7970a_suspend, trf7970a_resume)\n\tSET_RUNTIME_PM_OPS(trf7970a_pm_runtime_suspend,\n\t\t\t   trf7970a_pm_runtime_resume, NULL)\n};\n\nstatic const struct of_device_id trf7970a_of_match[] __maybe_unused = {\n\t{.compatible = \"ti,trf7970a\",},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, trf7970a_of_match);\n\nstatic const struct spi_device_id trf7970a_id_table[] = {\n\t{\"trf7970a\", 0},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(spi, trf7970a_id_table);\n\nstatic struct spi_driver trf7970a_spi_driver = {\n\t.probe\t\t= trf7970a_probe,\n\t.remove\t\t= trf7970a_remove,\n\t.id_table\t= trf7970a_id_table,\n\t.driver\t= {\n\t\t.name\t\t= \"trf7970a\",\n\t\t.of_match_table\t= of_match_ptr(trf7970a_of_match),\n\t\t.pm\t\t= &trf7970a_pm_ops,\n\t},\n};\n\nmodule_spi_driver(trf7970a_spi_driver);\n\nMODULE_AUTHOR(\"Mark A. Greer <mgreer@animalcreek.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"TI trf7970a RFID/NFC Transceiver Driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}