{
  "module_name": "spi.c",
  "hash_id": "b30a536d39d9e9dc906944da48721f56522345a628fd4a54105f05d27d347b83",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nfc/st95hf/spi.c",
  "human_readable_source": "\n \n\n#include \"spi.h\"\n\n \nint st95hf_spi_send(struct st95hf_spi_context *spicontext,\n\t\t    unsigned char *buffertx,\n\t\t    int datalen,\n\t\t    enum req_type reqtype)\n{\n\tstruct spi_message m;\n\tint result = 0;\n\tstruct spi_device *spidev = spicontext->spidev;\n\tstruct spi_transfer tx_transfer = {\n\t\t.tx_buf = buffertx,\n\t\t.len = datalen,\n\t};\n\n\tmutex_lock(&spicontext->spi_lock);\n\n\tif (reqtype == SYNC) {\n\t\tspicontext->req_issync = true;\n\t\treinit_completion(&spicontext->done);\n\t} else {\n\t\tspicontext->req_issync = false;\n\t}\n\n\tspi_message_init(&m);\n\tspi_message_add_tail(&tx_transfer, &m);\n\n\tresult = spi_sync(spidev, &m);\n\tif (result) {\n\t\tdev_err(&spidev->dev, \"error: sending cmd to st95hf using SPI = %d\\n\",\n\t\t\tresult);\n\t\tmutex_unlock(&spicontext->spi_lock);\n\t\treturn result;\n\t}\n\n\t \n\tif (reqtype == ASYNC) {\n\t\tmutex_unlock(&spicontext->spi_lock);\n\t\treturn 0;\n\t}\n\n\tresult = wait_for_completion_timeout(&spicontext->done,\n\t\t\t\t\t     msecs_to_jiffies(1000));\n\t \n\tif (!result) {\n\t\tdev_err(&spidev->dev, \"error: response not ready timeout\\n\");\n\t\tresult = -ETIMEDOUT;\n\t} else {\n\t\tresult = 0;\n\t}\n\n\tmutex_unlock(&spicontext->spi_lock);\n\n\treturn result;\n}\nEXPORT_SYMBOL_GPL(st95hf_spi_send);\n\n \nint st95hf_spi_recv_response(struct st95hf_spi_context *spicontext,\n\t\t\t     unsigned char *receivebuff)\n{\n\tint len = 0;\n\tstruct spi_transfer tx_takedata;\n\tstruct spi_message m;\n\tstruct spi_device *spidev = spicontext->spidev;\n\tunsigned char readdata_cmd = ST95HF_COMMAND_RECEIVE;\n\tstruct spi_transfer t[2] = {\n\t\t{.tx_buf = &readdata_cmd, .len = 1,},\n\t\t{.rx_buf = receivebuff, .len = 2, .cs_change = 1,},\n\t};\n\n\tint ret = 0;\n\n\tmemset(&tx_takedata, 0x0, sizeof(struct spi_transfer));\n\n\tmutex_lock(&spicontext->spi_lock);\n\n\t \n\tspi_message_init(&m);\n\tspi_message_add_tail(&t[0], &m);\n\tspi_message_add_tail(&t[1], &m);\n\n\tret = spi_sync(spidev, &m);\n\tif (ret) {\n\t\tdev_err(&spidev->dev, \"spi_recv_resp, data length error = %d\\n\",\n\t\t\tret);\n\t\tmutex_unlock(&spicontext->spi_lock);\n\t\treturn ret;\n\t}\n\n\t \n\tlen = 2;\n\n\t \n\tif (receivebuff[0] & 0x60)\n\t\tlen += (((receivebuff[0] & 0x60) >> 5) << 8) | receivebuff[1];\n\telse\n\t\tlen += receivebuff[1];\n\n\t \n\ttx_takedata.rx_buf = &receivebuff[2];\n\ttx_takedata.len = len - 2;\n\n\tspi_message_init(&m);\n\tspi_message_add_tail(&tx_takedata, &m);\n\n\tret = spi_sync(spidev, &m);\n\n\tmutex_unlock(&spicontext->spi_lock);\n\tif (ret) {\n\t\tdev_err(&spidev->dev, \"spi_recv_resp, data read error = %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\treturn len;\n}\nEXPORT_SYMBOL_GPL(st95hf_spi_recv_response);\n\nint st95hf_spi_recv_echo_res(struct st95hf_spi_context *spicontext,\n\t\t\t     unsigned char *receivebuff)\n{\n\tunsigned char readdata_cmd = ST95HF_COMMAND_RECEIVE;\n\tstruct spi_transfer t[2] = {\n\t\t{.tx_buf = &readdata_cmd, .len = 1,},\n\t\t{.rx_buf = receivebuff, .len = 1,},\n\t};\n\tstruct spi_message m;\n\tstruct spi_device *spidev = spicontext->spidev;\n\tint ret = 0;\n\n\tmutex_lock(&spicontext->spi_lock);\n\n\tspi_message_init(&m);\n\tspi_message_add_tail(&t[0], &m);\n\tspi_message_add_tail(&t[1], &m);\n\tret = spi_sync(spidev, &m);\n\n\tmutex_unlock(&spicontext->spi_lock);\n\n\tif (ret)\n\t\tdev_err(&spidev->dev, \"recv_echo_res, data read error = %d\\n\",\n\t\t\tret);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(st95hf_spi_recv_echo_res);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}