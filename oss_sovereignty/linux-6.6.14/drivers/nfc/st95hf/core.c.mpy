{
  "module_name": "core.c",
  "hash_id": "21c31dd76b8b115549920b023913ad6ec26a9b5f210f65c408fdfffc34a65005",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nfc/st95hf/core.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/gpio.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/nfc.h>\n#include <linux/of_gpio.h>\n#include <linux/of.h>\n#include <linux/property.h>\n#include <linux/regulator/consumer.h>\n#include <linux/wait.h>\n#include <net/nfc/digital.h>\n#include <net/nfc/nfc.h>\n\n#include \"spi.h\"\n\n \n#define ST95HF_SUPPORTED_PROT\t\t(NFC_PROTO_ISO14443_MASK | \\\n\t\t\t\t\tNFC_PROTO_ISO14443_B_MASK | \\\n\t\t\t\t\tNFC_PROTO_ISO15693_MASK)\n \n#define ST95HF_CAPABILITIES\t\tNFC_DIGITAL_DRV_CAPS_IN_CRC\n\n \n \n#define ECHO_CMD\t\t\t0x55\n#define WRITE_REGISTER_CMD\t\t0x9\n#define PROTOCOL_SELECT_CMD\t\t0x2\n#define SEND_RECEIVE_CMD\t\t0x4\n\n \n#define ISO15693_PROTOCOL_CODE\t\t0x1\n#define ISO14443A_PROTOCOL_CODE\t\t0x2\n#define ISO14443B_PROTOCOL_CODE\t\t0x3\n\n \n#define ST95HF_HEADROOM_LEN\t\t3\n\n \n#define ST95HF_TAILROOM_LEN\t\t1\n\n \n#define MAX_RESPONSE_BUFFER_SIZE\t280\n#define ECHORESPONSE\t\t\t0x55\n#define ST95HF_ERR_MASK\t\t\t0xF\n#define ST95HF_TIMEOUT_ERROR\t\t0x87\n#define ST95HF_NFCA_CRC_ERR_MASK\t0x20\n#define ST95HF_NFCB_CRC_ERR_MASK\t0x01\n\n \n#define TRFLAG_NFCA_SHORT_FRAME\t\t0x07\n#define TRFLAG_NFCA_STD_FRAME\t\t0x08\n#define TRFLAG_NFCA_STD_FRAME_CRC\t0x28\n\n \n#define HIGH\t\t\t\t1\n#define LOW\t\t\t\t0\n#define ISO14443A_RATS_REQ\t\t0xE0\n#define RATS_TB1_PRESENT_MASK\t\t0x20\n#define RATS_TA1_PRESENT_MASK\t\t0x10\n#define TB1_FWI_MASK\t\t\t0xF0\n#define WTX_REQ_FROM_TAG\t\t0xF2\n\n#define MAX_CMD_LEN\t\t\t0x7\n\n#define MAX_CMD_PARAMS\t\t\t4\nstruct cmd {\n\tint cmd_len;\n\tunsigned char cmd_id;\n\tunsigned char no_cmd_params;\n\tunsigned char cmd_params[MAX_CMD_PARAMS];\n\tenum req_type req;\n};\n\nstruct param_list {\n\tint param_offset;\n\tint new_param_val;\n};\n\n \nenum st95hf_cmd_list {\n\tCMD_ECHO,\n\tCMD_ISO14443A_CONFIG,\n\tCMD_ISO14443A_DEMOGAIN,\n\tCMD_ISO14443B_DEMOGAIN,\n\tCMD_ISO14443A_PROTOCOL_SELECT,\n\tCMD_ISO14443B_PROTOCOL_SELECT,\n\tCMD_WTX_RESPONSE,\n\tCMD_FIELD_OFF,\n\tCMD_ISO15693_PROTOCOL_SELECT,\n};\n\nstatic const struct cmd cmd_array[] = {\n\t[CMD_ECHO] = {\n\t\t.cmd_len = 0x2,\n\t\t.cmd_id = ECHO_CMD,\n\t\t.no_cmd_params = 0,\n\t\t.req = SYNC,\n\t},\n\t[CMD_ISO14443A_CONFIG] = {\n\t\t.cmd_len = 0x7,\n\t\t.cmd_id = WRITE_REGISTER_CMD,\n\t\t.no_cmd_params = 0x4,\n\t\t.cmd_params = {0x3A, 0x00, 0x5A, 0x04},\n\t\t.req = SYNC,\n\t},\n\t[CMD_ISO14443A_DEMOGAIN] = {\n\t\t.cmd_len = 0x7,\n\t\t.cmd_id = WRITE_REGISTER_CMD,\n\t\t.no_cmd_params = 0x4,\n\t\t.cmd_params = {0x68, 0x01, 0x01, 0xDF},\n\t\t.req = SYNC,\n\t},\n\t[CMD_ISO14443B_DEMOGAIN] = {\n\t\t.cmd_len = 0x7,\n\t\t.cmd_id = WRITE_REGISTER_CMD,\n\t\t.no_cmd_params = 0x4,\n\t\t.cmd_params = {0x68, 0x01, 0x01, 0x51},\n\t\t.req = SYNC,\n\t},\n\t[CMD_ISO14443A_PROTOCOL_SELECT] = {\n\t\t.cmd_len = 0x7,\n\t\t.cmd_id = PROTOCOL_SELECT_CMD,\n\t\t.no_cmd_params = 0x4,\n\t\t.cmd_params = {ISO14443A_PROTOCOL_CODE, 0x00, 0x01, 0xA0},\n\t\t.req = SYNC,\n\t},\n\t[CMD_ISO14443B_PROTOCOL_SELECT] = {\n\t\t.cmd_len = 0x7,\n\t\t.cmd_id = PROTOCOL_SELECT_CMD,\n\t\t.no_cmd_params = 0x4,\n\t\t.cmd_params = {ISO14443B_PROTOCOL_CODE, 0x01, 0x03, 0xFF},\n\t\t.req = SYNC,\n\t},\n\t[CMD_WTX_RESPONSE] = {\n\t\t.cmd_len = 0x6,\n\t\t.cmd_id = SEND_RECEIVE_CMD,\n\t\t.no_cmd_params = 0x3,\n\t\t.cmd_params = {0xF2, 0x00, TRFLAG_NFCA_STD_FRAME_CRC},\n\t\t.req = ASYNC,\n\t},\n\t[CMD_FIELD_OFF] = {\n\t\t.cmd_len = 0x5,\n\t\t.cmd_id = PROTOCOL_SELECT_CMD,\n\t\t.no_cmd_params = 0x2,\n\t\t.cmd_params = {0x0, 0x0},\n\t\t.req = SYNC,\n\t},\n\t[CMD_ISO15693_PROTOCOL_SELECT] = {\n\t\t.cmd_len = 0x5,\n\t\t.cmd_id = PROTOCOL_SELECT_CMD,\n\t\t.no_cmd_params = 0x2,\n\t\t.cmd_params = {ISO15693_PROTOCOL_CODE, 0x0D},\n\t\t.req = SYNC,\n\t},\n};\n\n \nstruct st95_digital_cmd_complete_arg {\n\tstruct sk_buff *skb_resp;\n\tnfc_digital_cmd_complete_t complete_cb;\n\tvoid *cb_usrarg;\n\tbool rats;\n};\n\n \nstruct st95hf_context {\n\tstruct st95hf_spi_context spicontext;\n\tstruct nfc_digital_dev *ddev;\n\tstruct nfc_dev *nfcdev;\n\tunsigned int enable_gpio;\n\tstruct st95_digital_cmd_complete_arg complete_cb_arg;\n\tstruct regulator *st95hf_supply;\n\tunsigned char sendrcv_trflag;\n\tstruct semaphore exchange_lock;\n\tstruct mutex rm_lock;\n\tbool nfcdev_free;\n\tu8 current_protocol;\n\tu8 current_rf_tech;\n\tint fwi;\n};\n\n \nstatic int st95hf_send_recv_cmd(struct st95hf_context *st95context,\n\t\t\t\tenum st95hf_cmd_list cmd,\n\t\t\t\tint no_modif,\n\t\t\t\tstruct param_list *list_array,\n\t\t\t\tbool recv_res)\n{\n\tunsigned char spi_cmd_buffer[MAX_CMD_LEN];\n\tint i, ret;\n\tstruct device *dev = &st95context->spicontext.spidev->dev;\n\n\tif (cmd_array[cmd].cmd_len > MAX_CMD_LEN)\n\t\treturn -EINVAL;\n\tif (cmd_array[cmd].no_cmd_params < no_modif)\n\t\treturn -EINVAL;\n\tif (no_modif && !list_array)\n\t\treturn -EINVAL;\n\n\tspi_cmd_buffer[0] = ST95HF_COMMAND_SEND;\n\tspi_cmd_buffer[1] = cmd_array[cmd].cmd_id;\n\tspi_cmd_buffer[2] = cmd_array[cmd].no_cmd_params;\n\n\tmemcpy(&spi_cmd_buffer[3], cmd_array[cmd].cmd_params,\n\t       spi_cmd_buffer[2]);\n\n\tfor (i = 0; i < no_modif; i++) {\n\t\tif (list_array[i].param_offset >= cmd_array[cmd].no_cmd_params)\n\t\t\treturn -EINVAL;\n\t\tspi_cmd_buffer[3 + list_array[i].param_offset] =\n\t\t\t\t\t\tlist_array[i].new_param_val;\n\t}\n\n\tret = st95hf_spi_send(&st95context->spicontext,\n\t\t\t      spi_cmd_buffer,\n\t\t\t      cmd_array[cmd].cmd_len,\n\t\t\t      cmd_array[cmd].req);\n\tif (ret) {\n\t\tdev_err(dev, \"st95hf_spi_send failed with error %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (cmd_array[cmd].req == SYNC && recv_res) {\n\t\tunsigned char st95hf_response_arr[2];\n\n\t\tret = st95hf_spi_recv_response(&st95context->spicontext,\n\t\t\t\t\t       st95hf_response_arr);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"spi error from st95hf_spi_recv_response(), err = 0x%x\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (st95hf_response_arr[0]) {\n\t\t\tdev_err(dev, \"st95hf error from st95hf_spi_recv_response(), err = 0x%x\\n\",\n\t\t\t\tst95hf_response_arr[0]);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int st95hf_echo_command(struct st95hf_context *st95context)\n{\n\tint result = 0;\n\tunsigned char echo_response;\n\n\tresult = st95hf_send_recv_cmd(st95context, CMD_ECHO, 0, NULL, false);\n\tif (result)\n\t\treturn result;\n\n\t \n\tresult = st95hf_spi_recv_echo_res(&st95context->spicontext,\n\t\t\t\t\t  &echo_response);\n\tif (result) {\n\t\tdev_err(&st95context->spicontext.spidev->dev,\n\t\t\t\"err: echo response receive error = 0x%x\\n\", result);\n\t\treturn result;\n\t}\n\n\tif (echo_response == ECHORESPONSE)\n\t\treturn 0;\n\n\tdev_err(&st95context->spicontext.spidev->dev, \"err: echo res is 0x%x\\n\",\n\t\techo_response);\n\n\treturn -EIO;\n}\n\nstatic int secondary_configuration_type4a(struct st95hf_context *stcontext)\n{\n\tint result = 0;\n\tstruct device *dev = &stcontext->nfcdev->dev;\n\n\t \n\tresult = st95hf_send_recv_cmd(stcontext,\n\t\t\t\t      CMD_ISO14443A_CONFIG,\n\t\t\t\t      0,\n\t\t\t\t      NULL,\n\t\t\t\t      true);\n\tif (result) {\n\t\tdev_err(dev, \"type a config cmd, err = 0x%x\\n\", result);\n\t\treturn result;\n\t}\n\n\t \n\tresult = st95hf_send_recv_cmd(stcontext,\n\t\t\t\t      CMD_ISO14443A_DEMOGAIN,\n\t\t\t\t      0,\n\t\t\t\t      NULL,\n\t\t\t\t      true);\n\tif (result)\n\t\tdev_err(dev, \"type a demogain cmd, err = 0x%x\\n\", result);\n\n\treturn result;\n}\n\nstatic int secondary_configuration_type4b(struct st95hf_context *stcontext)\n{\n\tint result = 0;\n\tstruct device *dev = &stcontext->nfcdev->dev;\n\n\tresult = st95hf_send_recv_cmd(stcontext,\n\t\t\t\t      CMD_ISO14443B_DEMOGAIN,\n\t\t\t\t      0,\n\t\t\t\t      NULL,\n\t\t\t\t      true);\n\tif (result)\n\t\tdev_err(dev, \"type b demogain cmd, err = 0x%x\\n\", result);\n\n\treturn result;\n}\n\nstatic int st95hf_select_protocol(struct st95hf_context *stcontext, int type)\n{\n\tint result = 0;\n\tstruct device *dev;\n\n\tdev = &stcontext->nfcdev->dev;\n\n\tswitch (type) {\n\tcase NFC_DIGITAL_RF_TECH_106A:\n\t\tstcontext->current_rf_tech = NFC_DIGITAL_RF_TECH_106A;\n\t\tresult = st95hf_send_recv_cmd(stcontext,\n\t\t\t\t\t      CMD_ISO14443A_PROTOCOL_SELECT,\n\t\t\t\t\t      0,\n\t\t\t\t\t      NULL,\n\t\t\t\t\t      true);\n\t\tif (result) {\n\t\t\tdev_err(dev, \"protocol sel, err = 0x%x\\n\",\n\t\t\t\tresult);\n\t\t\treturn result;\n\t\t}\n\n\t\t \n\t\tresult = secondary_configuration_type4a(stcontext);\n\t\tif (result) {\n\t\t\tdev_err(dev, \"type a secondary config, err = 0x%x\\n\",\n\t\t\t\tresult);\n\t\t\treturn result;\n\t\t}\n\t\tbreak;\n\tcase NFC_DIGITAL_RF_TECH_106B:\n\t\tstcontext->current_rf_tech = NFC_DIGITAL_RF_TECH_106B;\n\t\tresult = st95hf_send_recv_cmd(stcontext,\n\t\t\t\t\t      CMD_ISO14443B_PROTOCOL_SELECT,\n\t\t\t\t\t      0,\n\t\t\t\t\t      NULL,\n\t\t\t\t\t      true);\n\t\tif (result) {\n\t\t\tdev_err(dev, \"protocol sel send, err = 0x%x\\n\",\n\t\t\t\tresult);\n\t\t\treturn result;\n\t\t}\n\n\t\t \n\t\tusleep_range(50000, 60000);\n\n\t\t \n\t\tresult = secondary_configuration_type4b(stcontext);\n\t\tif (result) {\n\t\t\tdev_err(dev, \"type b secondary config, err = 0x%x\\n\",\n\t\t\t\tresult);\n\t\t\treturn result;\n\t\t}\n\t\tbreak;\n\tcase NFC_DIGITAL_RF_TECH_ISO15693:\n\t\tstcontext->current_rf_tech = NFC_DIGITAL_RF_TECH_ISO15693;\n\t\tresult = st95hf_send_recv_cmd(stcontext,\n\t\t\t\t\t      CMD_ISO15693_PROTOCOL_SELECT,\n\t\t\t\t\t      0,\n\t\t\t\t\t      NULL,\n\t\t\t\t\t      true);\n\t\tif (result) {\n\t\t\tdev_err(dev, \"protocol sel send, err = 0x%x\\n\",\n\t\t\t\tresult);\n\t\t\treturn result;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void st95hf_send_st95enable_negativepulse(struct st95hf_context *st95con)\n{\n\t \n\tgpio_set_value(st95con->enable_gpio, HIGH);\n\n\t \n\tusleep_range(1000, 2000);\n\n\t \n\tgpio_set_value(st95con->enable_gpio, LOW);\n\n\t \n\tusleep_range(1000, 2000);\n\n\t \n\tgpio_set_value(st95con->enable_gpio, HIGH);\n}\n\n \nstatic int st95hf_send_spi_reset_sequence(struct st95hf_context *st95context)\n{\n\tint result = 0;\n\tunsigned char reset_cmd = ST95HF_COMMAND_RESET;\n\n\tresult = st95hf_spi_send(&st95context->spicontext,\n\t\t\t\t &reset_cmd,\n\t\t\t\t ST95HF_RESET_CMD_LEN,\n\t\t\t\t ASYNC);\n\tif (result) {\n\t\tdev_err(&st95context->spicontext.spidev->dev,\n\t\t\t\"spi reset sequence cmd error = %d\", result);\n\t\treturn result;\n\t}\n\n\t \n\tusleep_range(3000, 4000);\n\n\t \n\tst95hf_send_st95enable_negativepulse(st95context);\n\n\t \n\tusleep_range(10000, 20000);\n\n\treturn result;\n}\n\nstatic int st95hf_por_sequence(struct st95hf_context *st95context)\n{\n\tint nth_attempt = 1;\n\tint result;\n\n\tst95hf_send_st95enable_negativepulse(st95context);\n\n\tusleep_range(5000, 6000);\n\tdo {\n\t\t \n\t\tresult = st95hf_echo_command(st95context);\n\n\t\tdev_dbg(&st95context->spicontext.spidev->dev,\n\t\t\t\"response from echo function = 0x%x, attempt = %d\\n\",\n\t\t\tresult, nth_attempt);\n\n\t\tif (!result)\n\t\t\treturn 0;\n\n\t\t \n\t\tif (nth_attempt == 2)\n\t\t\tst95hf_send_st95enable_negativepulse(st95context);\n\t\telse\n\t\t\tst95hf_send_spi_reset_sequence(st95context);\n\n\t\t \n\t\tusleep_range(50000, 51000);\n\t} while (nth_attempt++ < 3);\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int iso14443_config_fdt(struct st95hf_context *st95context, int wtxm)\n{\n\tint result = 0;\n\tstruct device *dev = &st95context->spicontext.spidev->dev;\n\tstruct nfc_digital_dev *nfcddev = st95context->ddev;\n\tunsigned char pp_typeb;\n\tstruct param_list new_params[2];\n\n\tpp_typeb = cmd_array[CMD_ISO14443B_PROTOCOL_SELECT].cmd_params[2];\n\n\tif (nfcddev->curr_protocol == NFC_PROTO_ISO14443 &&\n\t    st95context->fwi < 4)\n\t\tst95context->fwi = 4;\n\n\tnew_params[0].param_offset = 2;\n\tif (nfcddev->curr_protocol == NFC_PROTO_ISO14443)\n\t\tnew_params[0].new_param_val = st95context->fwi;\n\telse if (nfcddev->curr_protocol == NFC_PROTO_ISO14443_B)\n\t\tnew_params[0].new_param_val = pp_typeb;\n\n\tnew_params[1].param_offset = 3;\n\tnew_params[1].new_param_val = wtxm;\n\n\tswitch (nfcddev->curr_protocol) {\n\tcase NFC_PROTO_ISO14443:\n\t\tresult = st95hf_send_recv_cmd(st95context,\n\t\t\t\t\t      CMD_ISO14443A_PROTOCOL_SELECT,\n\t\t\t\t\t      2,\n\t\t\t\t\t      new_params,\n\t\t\t\t\t      true);\n\t\tif (result) {\n\t\t\tdev_err(dev, \"WTX type a sel proto, err = 0x%x\\n\",\n\t\t\t\tresult);\n\t\t\treturn result;\n\t\t}\n\n\t\t \n\t\tresult = secondary_configuration_type4a(st95context);\n\t\tif (result) {\n\t\t\tdev_err(dev, \"WTX type a second. config, err = 0x%x\\n\",\n\t\t\t\tresult);\n\t\t\treturn result;\n\t\t}\n\t\tbreak;\n\tcase NFC_PROTO_ISO14443_B:\n\t\tresult = st95hf_send_recv_cmd(st95context,\n\t\t\t\t\t      CMD_ISO14443B_PROTOCOL_SELECT,\n\t\t\t\t\t      2,\n\t\t\t\t\t      new_params,\n\t\t\t\t\t      true);\n\t\tif (result) {\n\t\t\tdev_err(dev, \"WTX type b sel proto, err = 0x%x\\n\",\n\t\t\t\tresult);\n\t\t\treturn result;\n\t\t}\n\n\t\t \n\t\tresult = secondary_configuration_type4b(st95context);\n\t\tif (result) {\n\t\t\tdev_err(dev, \"WTX type b second. config, err = 0x%x\\n\",\n\t\t\t\tresult);\n\t\t\treturn result;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int st95hf_handle_wtx(struct st95hf_context *stcontext,\n\t\t\t     bool new_wtx,\n\t\t\t     int wtx_val)\n{\n\tint result = 0;\n\tunsigned char val_mm = 0;\n\tstruct param_list new_params[1];\n\tstruct nfc_digital_dev *nfcddev = stcontext->ddev;\n\tstruct device *dev = &stcontext->nfcdev->dev;\n\n\tif (new_wtx) {\n\t\tresult = iso14443_config_fdt(stcontext, wtx_val & 0x3f);\n\t\tif (result) {\n\t\t\tdev_err(dev, \"Config. setting error on WTX req, err = 0x%x\\n\",\n\t\t\t\tresult);\n\t\t\treturn result;\n\t\t}\n\n\t\t \n\t\tnew_params[0].param_offset = 1;\n\t\tnew_params[0].new_param_val = wtx_val;\n\n\t\tresult = st95hf_send_recv_cmd(stcontext,\n\t\t\t\t\t      CMD_WTX_RESPONSE,\n\t\t\t\t\t      1,\n\t\t\t\t\t      new_params,\n\t\t\t\t\t      false);\n\t\tif (result)\n\t\t\tdev_err(dev, \"WTX response send, err = 0x%x\\n\", result);\n\t\treturn result;\n\t}\n\n\t \n\tif (nfcddev->curr_protocol == NFC_PROTO_ISO14443)\n\t\tval_mm = cmd_array[CMD_ISO14443A_PROTOCOL_SELECT].cmd_params[3];\n\telse if (nfcddev->curr_protocol == NFC_PROTO_ISO14443_B)\n\t\tval_mm = cmd_array[CMD_ISO14443B_PROTOCOL_SELECT].cmd_params[3];\n\n\tresult = iso14443_config_fdt(stcontext, val_mm);\n\tif (result)\n\t\tdev_err(dev, \"Default config. setting error after WTX processing, err = 0x%x\\n\",\n\t\t\tresult);\n\n\treturn result;\n}\n\nstatic int st95hf_error_handling(struct st95hf_context *stcontext,\n\t\t\t\t struct sk_buff *skb_resp,\n\t\t\t\t int res_len)\n{\n\tint result = 0;\n\tunsigned char error_byte;\n\tstruct device *dev = &stcontext->nfcdev->dev;\n\n\t \n\tif (skb_resp->data[0] & ST95HF_ERR_MASK) {\n\t\tif (skb_resp->data[0] == ST95HF_TIMEOUT_ERROR)\n\t\t\tresult = -ETIMEDOUT;\n\t\telse\n\t\t\tresult = -EIO;\n\t\treturn result;\n\t}\n\n\t \n\tswitch (stcontext->current_rf_tech) {\n\tcase NFC_DIGITAL_RF_TECH_106A:\n\t\tif (stcontext->sendrcv_trflag == TRFLAG_NFCA_STD_FRAME_CRC) {\n\t\t\terror_byte = skb_resp->data[res_len - 3];\n\t\t\tif (error_byte & ST95HF_NFCA_CRC_ERR_MASK) {\n\t\t\t\t \n\t\t\t\tdev_err(dev, \"CRC error, byte received = 0x%x\\n\",\n\t\t\t\t\terror_byte);\n\t\t\t\tresult = -EIO;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase NFC_DIGITAL_RF_TECH_106B:\n\tcase NFC_DIGITAL_RF_TECH_ISO15693:\n\t\terror_byte = skb_resp->data[res_len - 1];\n\t\tif (error_byte & ST95HF_NFCB_CRC_ERR_MASK) {\n\t\t\t \n\t\t\tdev_err(dev, \"CRC error, byte received = 0x%x\\n\",\n\t\t\t\terror_byte);\n\t\t\tresult = -EIO;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn result;\n}\n\nstatic int st95hf_response_handler(struct st95hf_context *stcontext,\n\t\t\t\t   struct sk_buff *skb_resp,\n\t\t\t\t   int res_len)\n{\n\tint result = 0;\n\tint skb_len;\n\tunsigned char val_mm;\n\tstruct nfc_digital_dev *nfcddev = stcontext->ddev;\n\tstruct device *dev = &stcontext->nfcdev->dev;\n\tstruct st95_digital_cmd_complete_arg *cb_arg;\n\n\tcb_arg = &stcontext->complete_cb_arg;\n\n\t \n\tskb_put(skb_resp, res_len);\n\n\t \n\tskb_pull(skb_resp, 2);\n\n\tskb_len = skb_resp->len;\n\n\t \n\tif (nfcddev->curr_protocol == NFC_PROTO_ISO14443 && cb_arg->rats &&\n\t    (skb_resp->data[1] & RATS_TB1_PRESENT_MASK)) {\n\t\tif (skb_resp->data[1] & RATS_TA1_PRESENT_MASK)\n\t\t\tstcontext->fwi =\n\t\t\t\t(skb_resp->data[3] & TB1_FWI_MASK) >> 4;\n\t\telse\n\t\t\tstcontext->fwi =\n\t\t\t\t(skb_resp->data[2] & TB1_FWI_MASK) >> 4;\n\n\t\tval_mm = cmd_array[CMD_ISO14443A_PROTOCOL_SELECT].cmd_params[3];\n\n\t\tresult = iso14443_config_fdt(stcontext, val_mm);\n\t\tif (result) {\n\t\t\tdev_err(dev, \"error in config_fdt to handle fwi of ATS, error=%d\\n\",\n\t\t\t\tresult);\n\t\t\treturn result;\n\t\t}\n\t}\n\tcb_arg->rats = false;\n\n\t \n\tswitch (stcontext->current_rf_tech) {\n\tcase NFC_DIGITAL_RF_TECH_106A:\n\t\tif (stcontext->sendrcv_trflag == TRFLAG_NFCA_STD_FRAME_CRC)\n\t\t\tskb_trim(skb_resp, (skb_len - 5));\n\t\telse\n\t\t\tskb_trim(skb_resp, (skb_len - 3));\n\t\tbreak;\n\tcase NFC_DIGITAL_RF_TECH_106B:\n\tcase NFC_DIGITAL_RF_TECH_ISO15693:\n\t\tskb_trim(skb_resp, (skb_len - 3));\n\t\tbreak;\n\t}\n\n\treturn result;\n}\n\nstatic irqreturn_t st95hf_irq_handler(int irq, void  *st95hfcontext)\n{\n\tstruct st95hf_context *stcontext  =\n\t\t(struct st95hf_context *)st95hfcontext;\n\n\tif (stcontext->spicontext.req_issync) {\n\t\tcomplete(&stcontext->spicontext.done);\n\t\tstcontext->spicontext.req_issync = false;\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic irqreturn_t st95hf_irq_thread_handler(int irq, void  *st95hfcontext)\n{\n\tint result = 0;\n\tint res_len;\n\tstatic bool wtx;\n\tstruct device *spidevice;\n\tstruct sk_buff *skb_resp;\n\tstruct st95hf_context *stcontext  =\n\t\t(struct st95hf_context *)st95hfcontext;\n\tstruct st95_digital_cmd_complete_arg *cb_arg;\n\n\tspidevice = &stcontext->spicontext.spidev->dev;\n\n\t \n\tif (!down_trylock(&stcontext->exchange_lock)) {\n\t\tup(&stcontext->exchange_lock);\n\t\tWARN(1, \"unknown context in ST95HF ISR\");\n\t\treturn IRQ_NONE;\n\t}\n\n\tcb_arg = &stcontext->complete_cb_arg;\n\tskb_resp = cb_arg->skb_resp;\n\n\tmutex_lock(&stcontext->rm_lock);\n\tres_len = st95hf_spi_recv_response(&stcontext->spicontext,\n\t\t\t\t\t   skb_resp->data);\n\tif (res_len < 0) {\n\t\tdev_err(spidevice, \"TISR spi response err = 0x%x\\n\", res_len);\n\t\tresult = res_len;\n\t\tgoto end;\n\t}\n\n\t \n\tif (stcontext->nfcdev_free) {\n\t\tresult = -ENODEV;\n\t\tgoto end;\n\t}\n\n\tif (skb_resp->data[2] == WTX_REQ_FROM_TAG) {\n\t\t \n\t\tresult = st95hf_handle_wtx(stcontext, true, skb_resp->data[3]);\n\t\tif (result)\n\t\t\tgoto end;\n\n\t\twtx = true;\n\t\tmutex_unlock(&stcontext->rm_lock);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tresult = st95hf_error_handling(stcontext, skb_resp, res_len);\n\tif (result)\n\t\tgoto end;\n\n\tresult = st95hf_response_handler(stcontext, skb_resp, res_len);\n\tif (result)\n\t\tgoto end;\n\n\t \n\tif (wtx) {\n\t\twtx = false;\n\t\tresult = st95hf_handle_wtx(stcontext, false, 0);\n\t\tif (result)\n\t\t\tgoto end;\n\t}\n\n\t \n\tcb_arg->complete_cb(stcontext->ddev, cb_arg->cb_usrarg, skb_resp);\n\n\t \n\tup(&stcontext->exchange_lock);\n\tmutex_unlock(&stcontext->rm_lock);\n\n\treturn IRQ_HANDLED;\n\nend:\n\tkfree_skb(skb_resp);\n\twtx = false;\n\tcb_arg->rats = false;\n\tskb_resp = ERR_PTR(result);\n\t \n\tcb_arg->complete_cb(stcontext->ddev, cb_arg->cb_usrarg, skb_resp);\n\t \n\tup(&stcontext->exchange_lock);\n\tmutex_unlock(&stcontext->rm_lock);\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int st95hf_in_configure_hw(struct nfc_digital_dev *ddev,\n\t\t\t\t  int type,\n\t\t\t\t  int param)\n{\n\tstruct st95hf_context *stcontext = nfc_digital_get_drvdata(ddev);\n\n\tif (type == NFC_DIGITAL_CONFIG_RF_TECH)\n\t\treturn st95hf_select_protocol(stcontext, param);\n\n\tif (type == NFC_DIGITAL_CONFIG_FRAMING) {\n\t\tswitch (param) {\n\t\tcase NFC_DIGITAL_FRAMING_NFCA_SHORT:\n\t\t\tstcontext->sendrcv_trflag = TRFLAG_NFCA_SHORT_FRAME;\n\t\t\tbreak;\n\t\tcase NFC_DIGITAL_FRAMING_NFCA_STANDARD:\n\t\t\tstcontext->sendrcv_trflag = TRFLAG_NFCA_STD_FRAME;\n\t\t\tbreak;\n\t\tcase NFC_DIGITAL_FRAMING_NFCA_T4T:\n\t\tcase NFC_DIGITAL_FRAMING_NFCA_NFC_DEP:\n\t\tcase NFC_DIGITAL_FRAMING_NFCA_STANDARD_WITH_CRC_A:\n\t\t\tstcontext->sendrcv_trflag = TRFLAG_NFCA_STD_FRAME_CRC;\n\t\t\tbreak;\n\t\tcase NFC_DIGITAL_FRAMING_NFCB:\n\t\tcase NFC_DIGITAL_FRAMING_ISO15693_INVENTORY:\n\t\tcase NFC_DIGITAL_FRAMING_ISO15693_T5T:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int rf_off(struct st95hf_context *stcontext)\n{\n\tint rc;\n\tstruct device *dev;\n\n\tdev = &stcontext->nfcdev->dev;\n\n\trc = st95hf_send_recv_cmd(stcontext, CMD_FIELD_OFF, 0, NULL, true);\n\tif (rc)\n\t\tdev_err(dev, \"protocol sel send field off, err = 0x%x\\n\", rc);\n\n\treturn rc;\n}\n\nstatic int st95hf_in_send_cmd(struct nfc_digital_dev *ddev,\n\t\t\t      struct sk_buff *skb,\n\t\t\t      u16 timeout,\n\t\t\t      nfc_digital_cmd_complete_t cb,\n\t\t\t      void *arg)\n{\n\tstruct st95hf_context *stcontext = nfc_digital_get_drvdata(ddev);\n\tint rc;\n\tstruct sk_buff *skb_resp;\n\tint len_data_to_tag = 0;\n\n\tskb_resp = nfc_alloc_recv_skb(MAX_RESPONSE_BUFFER_SIZE, GFP_KERNEL);\n\tif (!skb_resp)\n\t\treturn -ENOMEM;\n\n\tswitch (stcontext->current_rf_tech) {\n\tcase NFC_DIGITAL_RF_TECH_106A:\n\t\tlen_data_to_tag = skb->len + 1;\n\t\tskb_put_u8(skb, stcontext->sendrcv_trflag);\n\t\tbreak;\n\tcase NFC_DIGITAL_RF_TECH_106B:\n\tcase NFC_DIGITAL_RF_TECH_ISO15693:\n\t\tlen_data_to_tag = skb->len;\n\t\tbreak;\n\tdefault:\n\t\trc = -EINVAL;\n\t\tgoto free_skb_resp;\n\t}\n\n\tskb_push(skb, 3);\n\tskb->data[0] = ST95HF_COMMAND_SEND;\n\tskb->data[1] = SEND_RECEIVE_CMD;\n\tskb->data[2] = len_data_to_tag;\n\n\tstcontext->complete_cb_arg.skb_resp = skb_resp;\n\tstcontext->complete_cb_arg.cb_usrarg = arg;\n\tstcontext->complete_cb_arg.complete_cb = cb;\n\n\tif ((skb->data[3] == ISO14443A_RATS_REQ) &&\n\t    ddev->curr_protocol == NFC_PROTO_ISO14443)\n\t\tstcontext->complete_cb_arg.rats = true;\n\n\t \n\trc = down_killable(&stcontext->exchange_lock);\n\tif (rc) {\n\t\tWARN(1, \"Semaphore is not found up in st95hf_in_send_cmd\\n\");\n\t\tgoto free_skb_resp;\n\t}\n\n\trc = st95hf_spi_send(&stcontext->spicontext, skb->data,\n\t\t\t     skb->len,\n\t\t\t     ASYNC);\n\tif (rc) {\n\t\tdev_err(&stcontext->nfcdev->dev,\n\t\t\t\"Error %d trying to perform data_exchange\", rc);\n\t\t \n\t\tup(&stcontext->exchange_lock);\n\t\tgoto free_skb_resp;\n\t}\n\n\tkfree_skb(skb);\n\n\treturn rc;\n\nfree_skb_resp:\n\tkfree_skb(skb_resp);\n\treturn rc;\n}\n\n \nstatic int st95hf_tg_configure_hw(struct nfc_digital_dev *ddev,\n\t\t\t\t  int type,\n\t\t\t\t  int param)\n{\n\treturn 0;\n}\n\nstatic int st95hf_tg_send_cmd(struct nfc_digital_dev *ddev,\n\t\t\t      struct sk_buff *skb,\n\t\t\t      u16 timeout,\n\t\t\t      nfc_digital_cmd_complete_t cb,\n\t\t\t      void *arg)\n{\n\treturn 0;\n}\n\nstatic int st95hf_tg_listen(struct nfc_digital_dev *ddev,\n\t\t\t    u16 timeout,\n\t\t\t    nfc_digital_cmd_complete_t cb,\n\t\t\t    void *arg)\n{\n\treturn 0;\n}\n\nstatic int st95hf_tg_get_rf_tech(struct nfc_digital_dev *ddev, u8 *rf_tech)\n{\n\treturn 0;\n}\n\nstatic int st95hf_switch_rf(struct nfc_digital_dev *ddev, bool on)\n{\n\tu8 rf_tech;\n\tstruct st95hf_context *stcontext = nfc_digital_get_drvdata(ddev);\n\n\trf_tech = ddev->curr_rf_tech;\n\n\tif (on)\n\t\t \n\t\treturn st95hf_select_protocol(stcontext, rf_tech);\n\n\t \n\treturn rf_off(stcontext);\n}\n\n \nstatic void st95hf_abort_cmd(struct nfc_digital_dev *ddev)\n{\n}\n\nstatic const struct nfc_digital_ops st95hf_nfc_digital_ops = {\n\t.in_configure_hw = st95hf_in_configure_hw,\n\t.in_send_cmd = st95hf_in_send_cmd,\n\n\t.tg_listen = st95hf_tg_listen,\n\t.tg_configure_hw = st95hf_tg_configure_hw,\n\t.tg_send_cmd = st95hf_tg_send_cmd,\n\t.tg_get_rf_tech = st95hf_tg_get_rf_tech,\n\n\t.switch_rf = st95hf_switch_rf,\n\t.abort_cmd = st95hf_abort_cmd,\n};\n\nstatic const struct spi_device_id st95hf_id[] = {\n\t{ \"st95hf\", 0 },\n\t{}\n};\nMODULE_DEVICE_TABLE(spi, st95hf_id);\n\nstatic const struct of_device_id st95hf_spi_of_match[] __maybe_unused = {\n\t{ .compatible = \"st,st95hf\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, st95hf_spi_of_match);\n\nstatic int st95hf_probe(struct spi_device *nfc_spi_dev)\n{\n\tint ret;\n\n\tstruct st95hf_context *st95context;\n\tstruct st95hf_spi_context *spicontext;\n\n\tnfc_info(&nfc_spi_dev->dev, \"ST95HF driver probe called.\\n\");\n\n\tst95context = devm_kzalloc(&nfc_spi_dev->dev,\n\t\t\t\t   sizeof(struct st95hf_context),\n\t\t\t\t   GFP_KERNEL);\n\tif (!st95context)\n\t\treturn -ENOMEM;\n\n\tspicontext = &st95context->spicontext;\n\n\tspicontext->spidev = nfc_spi_dev;\n\n\tst95context->fwi =\n\t\tcmd_array[CMD_ISO14443A_PROTOCOL_SELECT].cmd_params[2];\n\n\tif (device_property_present(&nfc_spi_dev->dev, \"st95hfvin\")) {\n\t\tst95context->st95hf_supply =\n\t\t\tdevm_regulator_get(&nfc_spi_dev->dev,\n\t\t\t\t\t   \"st95hfvin\");\n\t\tif (IS_ERR(st95context->st95hf_supply)) {\n\t\t\tdev_err(&nfc_spi_dev->dev, \"failed to acquire regulator\\n\");\n\t\t\treturn PTR_ERR(st95context->st95hf_supply);\n\t\t}\n\n\t\tret = regulator_enable(st95context->st95hf_supply);\n\t\tif (ret) {\n\t\t\tdev_err(&nfc_spi_dev->dev, \"failed to enable regulator\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tinit_completion(&spicontext->done);\n\tmutex_init(&spicontext->spi_lock);\n\n\t \n\tdev_set_drvdata(&nfc_spi_dev->dev, spicontext);\n\n\tst95context->enable_gpio =\n\t\tof_get_named_gpio(nfc_spi_dev->dev.of_node,\n\t\t\t\t  \"enable-gpio\",\n\t\t\t\t  0);\n\tif (!gpio_is_valid(st95context->enable_gpio)) {\n\t\tdev_err(&nfc_spi_dev->dev, \"No valid enable gpio\\n\");\n\t\tret = st95context->enable_gpio;\n\t\tgoto err_disable_regulator;\n\t}\n\n\tret = devm_gpio_request_one(&nfc_spi_dev->dev, st95context->enable_gpio,\n\t\t\t\t    GPIOF_DIR_OUT | GPIOF_INIT_HIGH,\n\t\t\t\t    \"enable_gpio\");\n\tif (ret)\n\t\tgoto err_disable_regulator;\n\n\tif (nfc_spi_dev->irq > 0) {\n\t\tif (devm_request_threaded_irq(&nfc_spi_dev->dev,\n\t\t\t\t\t      nfc_spi_dev->irq,\n\t\t\t\t\t      st95hf_irq_handler,\n\t\t\t\t\t      st95hf_irq_thread_handler,\n\t\t\t\t\t      IRQF_TRIGGER_FALLING,\n\t\t\t\t\t      \"st95hf\",\n\t\t\t\t\t      (void *)st95context) < 0) {\n\t\t\tdev_err(&nfc_spi_dev->dev, \"err: irq request for st95hf is failed\\n\");\n\t\t\tret =  -EINVAL;\n\t\t\tgoto err_disable_regulator;\n\t\t}\n\t} else {\n\t\tdev_err(&nfc_spi_dev->dev, \"not a valid IRQ associated with ST95HF\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_disable_regulator;\n\t}\n\n\t \n\tret = st95hf_send_spi_reset_sequence(st95context);\n\tif (ret) {\n\t\tdev_err(&nfc_spi_dev->dev, \"err: spi_reset_sequence failed\\n\");\n\t\tgoto err_disable_regulator;\n\t}\n\n\t \n\tret = st95hf_por_sequence(st95context);\n\tif (ret) {\n\t\tdev_err(&nfc_spi_dev->dev, \"err: por seq failed for st95hf\\n\");\n\t\tgoto err_disable_regulator;\n\t}\n\n\t \n\tst95context->ddev = nfc_digital_allocate_device(&st95hf_nfc_digital_ops,\n\t\t\t\t\t\t\tST95HF_SUPPORTED_PROT,\n\t\t\t\t\t\t\tST95HF_CAPABILITIES,\n\t\t\t\t\t\t\tST95HF_HEADROOM_LEN,\n\t\t\t\t\t\t\tST95HF_TAILROOM_LEN);\n\tif (!st95context->ddev) {\n\t\tret = -ENOMEM;\n\t\tgoto err_disable_regulator;\n\t}\n\n\tst95context->nfcdev = st95context->ddev->nfc_dev;\n\tnfc_digital_set_parent_dev(st95context->ddev, &nfc_spi_dev->dev);\n\n\tret =  nfc_digital_register_device(st95context->ddev);\n\tif (ret) {\n\t\tdev_err(&st95context->nfcdev->dev, \"st95hf registration failed\\n\");\n\t\tgoto err_free_digital_device;\n\t}\n\n\t \n\tnfc_digital_set_drvdata(st95context->ddev, st95context);\n\n\tsema_init(&st95context->exchange_lock, 1);\n\tmutex_init(&st95context->rm_lock);\n\n\treturn ret;\n\nerr_free_digital_device:\n\tnfc_digital_free_device(st95context->ddev);\nerr_disable_regulator:\n\tif (st95context->st95hf_supply)\n\t\tregulator_disable(st95context->st95hf_supply);\n\n\treturn ret;\n}\n\nstatic void st95hf_remove(struct spi_device *nfc_spi_dev)\n{\n\tint result = 0;\n\tunsigned char reset_cmd = ST95HF_COMMAND_RESET;\n\tstruct st95hf_spi_context *spictx = dev_get_drvdata(&nfc_spi_dev->dev);\n\n\tstruct st95hf_context *stcontext = container_of(spictx,\n\t\t\t\t\t\t\tstruct st95hf_context,\n\t\t\t\t\t\t\tspicontext);\n\n\tmutex_lock(&stcontext->rm_lock);\n\n\tnfc_digital_unregister_device(stcontext->ddev);\n\tnfc_digital_free_device(stcontext->ddev);\n\tstcontext->nfcdev_free = true;\n\n\tmutex_unlock(&stcontext->rm_lock);\n\n\t \n\tresult = down_killable(&stcontext->exchange_lock);\n\tif (result == -EINTR)\n\t\tdev_err(&spictx->spidev->dev, \"sleep for semaphore interrupted by signal\\n\");\n\n\t \n\tresult = st95hf_spi_send(&stcontext->spicontext,\n\t\t\t\t &reset_cmd,\n\t\t\t\t ST95HF_RESET_CMD_LEN,\n\t\t\t\t ASYNC);\n\tif (result)\n\t\tdev_err(&spictx->spidev->dev,\n\t\t\t\"ST95HF reset failed in remove() err = %d\\n\", result);\n\n\t \n\tusleep_range(3000, 4000);\n\n\t \n\tif (stcontext->st95hf_supply)\n\t\tregulator_disable(stcontext->st95hf_supply);\n}\n\n \nstatic struct spi_driver st95hf_driver = {\n\t.driver = {\n\t\t.name = \"st95hf\",\n\t\t.owner = THIS_MODULE,\n\t\t.of_match_table = of_match_ptr(st95hf_spi_of_match),\n\t},\n\t.id_table = st95hf_id,\n\t.probe = st95hf_probe,\n\t.remove = st95hf_remove,\n};\n\nmodule_spi_driver(st95hf_driver);\n\nMODULE_AUTHOR(\"Shikha Singh <shikha.singh@st.com>\");\nMODULE_DESCRIPTION(\"ST NFC Transceiver ST95HF driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}