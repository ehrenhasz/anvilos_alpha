{
  "module_name": "microread.c",
  "hash_id": "058ea0d7914ef480521b153f63fead1b0f68747b71bb67d747ab6fa9a6b360dd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nfc/microread/microread.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/crc-ccitt.h>\n\n#include <linux/nfc.h>\n#include <net/nfc/nfc.h>\n#include <net/nfc/hci.h>\n\n#include \"microread.h\"\n\n \n \n#define MICROREAD_GATE_ID_ADM NFC_HCI_ADMIN_GATE\n#define MICROREAD_GATE_ID_MGT 0x01\n#define MICROREAD_GATE_ID_OS 0x02\n#define MICROREAD_GATE_ID_TESTRF 0x03\n#define MICROREAD_GATE_ID_LOOPBACK NFC_HCI_LOOPBACK_GATE\n#define MICROREAD_GATE_ID_IDT NFC_HCI_ID_MGMT_GATE\n#define MICROREAD_GATE_ID_LMS NFC_HCI_LINK_MGMT_GATE\n\n \n#define MICROREAD_GATE_ID_MREAD_GEN 0x10\n#define MICROREAD_GATE_ID_MREAD_ISO_B NFC_HCI_RF_READER_B_GATE\n#define MICROREAD_GATE_ID_MREAD_NFC_T1 0x12\n#define MICROREAD_GATE_ID_MREAD_ISO_A NFC_HCI_RF_READER_A_GATE\n#define MICROREAD_GATE_ID_MREAD_NFC_T3 0x14\n#define MICROREAD_GATE_ID_MREAD_ISO_15_3 0x15\n#define MICROREAD_GATE_ID_MREAD_ISO_15_2 0x16\n#define MICROREAD_GATE_ID_MREAD_ISO_B_3 0x17\n#define MICROREAD_GATE_ID_MREAD_BPRIME 0x18\n#define MICROREAD_GATE_ID_MREAD_ISO_A_3 0x19\n\n \n#define MICROREAD_GATE_ID_MCARD_GEN 0x20\n#define MICROREAD_GATE_ID_MCARD_ISO_B 0x21\n#define MICROREAD_GATE_ID_MCARD_BPRIME 0x22\n#define MICROREAD_GATE_ID_MCARD_ISO_A 0x23\n#define MICROREAD_GATE_ID_MCARD_NFC_T3 0x24\n#define MICROREAD_GATE_ID_MCARD_ISO_15_3 0x25\n#define MICROREAD_GATE_ID_MCARD_ISO_15_2 0x26\n#define MICROREAD_GATE_ID_MCARD_ISO_B_2 0x27\n#define MICROREAD_GATE_ID_MCARD_ISO_CUSTOM 0x28\n#define MICROREAD_GATE_ID_SECURE_ELEMENT 0x2F\n\n \n#define MICROREAD_GATE_ID_P2P_GEN 0x30\n#define MICROREAD_GATE_ID_P2P_TARGET 0x31\n#define MICROREAD_PAR_P2P_TARGET_MODE 0x01\n#define MICROREAD_PAR_P2P_TARGET_GT 0x04\n#define MICROREAD_GATE_ID_P2P_INITIATOR 0x32\n#define MICROREAD_PAR_P2P_INITIATOR_GI 0x01\n#define MICROREAD_PAR_P2P_INITIATOR_GT 0x03\n\n \n#define MICROREAD_PIPE_ID_LMS 0x00\n#define MICROREAD_PIPE_ID_ADMIN 0x01\n#define MICROREAD_PIPE_ID_MGT 0x02\n#define MICROREAD_PIPE_ID_OS 0x03\n#define MICROREAD_PIPE_ID_HDS_LOOPBACK 0x04\n#define MICROREAD_PIPE_ID_HDS_IDT 0x05\n#define MICROREAD_PIPE_ID_HDS_MCARD_ISO_B 0x08\n#define MICROREAD_PIPE_ID_HDS_MCARD_ISO_BPRIME 0x09\n#define MICROREAD_PIPE_ID_HDS_MCARD_ISO_A 0x0A\n#define MICROREAD_PIPE_ID_HDS_MCARD_ISO_15_3 0x0B\n#define MICROREAD_PIPE_ID_HDS_MCARD_ISO_15_2 0x0C\n#define MICROREAD_PIPE_ID_HDS_MCARD_NFC_T3 0x0D\n#define MICROREAD_PIPE_ID_HDS_MCARD_ISO_B_2 0x0E\n#define MICROREAD_PIPE_ID_HDS_MCARD_CUSTOM 0x0F\n#define MICROREAD_PIPE_ID_HDS_MREAD_ISO_B 0x10\n#define MICROREAD_PIPE_ID_HDS_MREAD_NFC_T1 0x11\n#define MICROREAD_PIPE_ID_HDS_MREAD_ISO_A 0x12\n#define MICROREAD_PIPE_ID_HDS_MREAD_ISO_15_3 0x13\n#define MICROREAD_PIPE_ID_HDS_MREAD_ISO_15_2 0x14\n#define MICROREAD_PIPE_ID_HDS_MREAD_NFC_T3 0x15\n#define MICROREAD_PIPE_ID_HDS_MREAD_ISO_B_3 0x16\n#define MICROREAD_PIPE_ID_HDS_MREAD_BPRIME 0x17\n#define MICROREAD_PIPE_ID_HDS_MREAD_ISO_A_3 0x18\n#define MICROREAD_PIPE_ID_HDS_MREAD_GEN 0x1B\n#define MICROREAD_PIPE_ID_HDS_STACKED_ELEMENT 0x1C\n#define MICROREAD_PIPE_ID_HDS_INSTANCES 0x1D\n#define MICROREAD_PIPE_ID_HDS_TESTRF 0x1E\n#define MICROREAD_PIPE_ID_HDS_P2P_TARGET 0x1F\n#define MICROREAD_PIPE_ID_HDS_P2P_INITIATOR 0x20\n\n \n#define MICROREAD_EVT_MREAD_DISCOVERY_OCCURED NFC_HCI_EVT_TARGET_DISCOVERED\n#define MICROREAD_EVT_MREAD_CARD_FOUND 0x3D\n#define MICROREAD_EMCF_A_ATQA 0\n#define MICROREAD_EMCF_A_SAK 2\n#define MICROREAD_EMCF_A_LEN 3\n#define MICROREAD_EMCF_A_UID 4\n#define MICROREAD_EMCF_A3_ATQA 0\n#define MICROREAD_EMCF_A3_SAK 2\n#define MICROREAD_EMCF_A3_LEN 3\n#define MICROREAD_EMCF_A3_UID 4\n#define MICROREAD_EMCF_B_UID 0\n#define MICROREAD_EMCF_T1_ATQA 0\n#define MICROREAD_EMCF_T1_UID 4\n#define MICROREAD_EMCF_T3_UID 0\n#define MICROREAD_EVT_MREAD_DISCOVERY_START NFC_HCI_EVT_READER_REQUESTED\n#define MICROREAD_EVT_MREAD_DISCOVERY_START_SOME 0x3E\n#define MICROREAD_EVT_MREAD_DISCOVERY_STOP NFC_HCI_EVT_END_OPERATION\n#define MICROREAD_EVT_MREAD_SIM_REQUESTS 0x3F\n#define MICROREAD_EVT_MCARD_EXCHANGE NFC_HCI_EVT_TARGET_DISCOVERED\n#define MICROREAD_EVT_P2P_INITIATOR_EXCHANGE_TO_RF 0x20\n#define MICROREAD_EVT_P2P_INITIATOR_EXCHANGE_FROM_RF 0x21\n#define MICROREAD_EVT_MCARD_FIELD_ON 0x11\n#define MICROREAD_EVT_P2P_TARGET_ACTIVATED 0x13\n#define MICROREAD_EVT_P2P_TARGET_DEACTIVATED 0x12\n#define MICROREAD_EVT_MCARD_FIELD_OFF 0x14\n\n \n#define MICROREAD_CMD_MREAD_EXCHANGE 0x10\n#define MICROREAD_CMD_MREAD_SUBSCRIBE 0x3F\n\n \n#define MICROREAD_ELT_ID_HDS NFC_HCI_TERMINAL_HOST_ID\n#define MICROREAD_ELT_ID_SIM NFC_HCI_UICC_HOST_ID\n#define MICROREAD_ELT_ID_SE1 0x03\n#define MICROREAD_ELT_ID_SE2 0x04\n#define MICROREAD_ELT_ID_SE3 0x05\n\nstatic const struct nfc_hci_gate microread_gates[] = {\n\t{MICROREAD_GATE_ID_ADM, MICROREAD_PIPE_ID_ADMIN},\n\t{MICROREAD_GATE_ID_LOOPBACK, MICROREAD_PIPE_ID_HDS_LOOPBACK},\n\t{MICROREAD_GATE_ID_IDT, MICROREAD_PIPE_ID_HDS_IDT},\n\t{MICROREAD_GATE_ID_LMS, MICROREAD_PIPE_ID_LMS},\n\t{MICROREAD_GATE_ID_MREAD_ISO_B, MICROREAD_PIPE_ID_HDS_MREAD_ISO_B},\n\t{MICROREAD_GATE_ID_MREAD_ISO_A, MICROREAD_PIPE_ID_HDS_MREAD_ISO_A},\n\t{MICROREAD_GATE_ID_MREAD_ISO_A_3, MICROREAD_PIPE_ID_HDS_MREAD_ISO_A_3},\n\t{MICROREAD_GATE_ID_MGT, MICROREAD_PIPE_ID_MGT},\n\t{MICROREAD_GATE_ID_OS, MICROREAD_PIPE_ID_OS},\n\t{MICROREAD_GATE_ID_MREAD_NFC_T1, MICROREAD_PIPE_ID_HDS_MREAD_NFC_T1},\n\t{MICROREAD_GATE_ID_MREAD_NFC_T3, MICROREAD_PIPE_ID_HDS_MREAD_NFC_T3},\n\t{MICROREAD_GATE_ID_P2P_TARGET, MICROREAD_PIPE_ID_HDS_P2P_TARGET},\n\t{MICROREAD_GATE_ID_P2P_INITIATOR, MICROREAD_PIPE_ID_HDS_P2P_INITIATOR}\n};\n\n \n#define MICROREAD_CMDS_HEADROOM\t2\n#define MICROREAD_CMD_TAILROOM\t2\n\nstruct microread_info {\n\tconst struct nfc_phy_ops *phy_ops;\n\tvoid *phy_id;\n\n\tstruct nfc_hci_dev *hdev;\n\n\tint async_cb_type;\n\tdata_exchange_cb_t async_cb;\n\tvoid *async_cb_context;\n};\n\nstatic int microread_open(struct nfc_hci_dev *hdev)\n{\n\tstruct microread_info *info = nfc_hci_get_clientdata(hdev);\n\n\treturn info->phy_ops->enable(info->phy_id);\n}\n\nstatic void microread_close(struct nfc_hci_dev *hdev)\n{\n\tstruct microread_info *info = nfc_hci_get_clientdata(hdev);\n\n\tinfo->phy_ops->disable(info->phy_id);\n}\n\nstatic int microread_hci_ready(struct nfc_hci_dev *hdev)\n{\n\tint r;\n\tu8 param[4];\n\n\tparam[0] = 0x03;\n\tr = nfc_hci_send_cmd(hdev, MICROREAD_GATE_ID_MREAD_ISO_A,\n\t\t\t     MICROREAD_CMD_MREAD_SUBSCRIBE, param, 1, NULL);\n\tif (r)\n\t\treturn r;\n\n\tr = nfc_hci_send_cmd(hdev, MICROREAD_GATE_ID_MREAD_ISO_A_3,\n\t\t\t     MICROREAD_CMD_MREAD_SUBSCRIBE, NULL, 0, NULL);\n\tif (r)\n\t\treturn r;\n\n\tparam[0] = 0x00;\n\tparam[1] = 0x03;\n\tparam[2] = 0x00;\n\tr = nfc_hci_send_cmd(hdev, MICROREAD_GATE_ID_MREAD_ISO_B,\n\t\t\t     MICROREAD_CMD_MREAD_SUBSCRIBE, param, 3, NULL);\n\tif (r)\n\t\treturn r;\n\n\tr = nfc_hci_send_cmd(hdev, MICROREAD_GATE_ID_MREAD_NFC_T1,\n\t\t\t     MICROREAD_CMD_MREAD_SUBSCRIBE, NULL, 0, NULL);\n\tif (r)\n\t\treturn r;\n\n\tparam[0] = 0xFF;\n\tparam[1] = 0xFF;\n\tparam[2] = 0x00;\n\tparam[3] = 0x00;\n\tr = nfc_hci_send_cmd(hdev, MICROREAD_GATE_ID_MREAD_NFC_T3,\n\t\t\t     MICROREAD_CMD_MREAD_SUBSCRIBE, param, 4, NULL);\n\n\treturn r;\n}\n\nstatic int microread_xmit(struct nfc_hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct microread_info *info = nfc_hci_get_clientdata(hdev);\n\n\treturn info->phy_ops->write(info->phy_id, skb);\n}\n\nstatic int microread_start_poll(struct nfc_hci_dev *hdev,\n\t\t\t\tu32 im_protocols, u32 tm_protocols)\n{\n\tint r;\n\n\tu8 param[2];\n\tu8 mode;\n\n\tparam[0] = 0x00;\n\tparam[1] = 0x00;\n\n\tif (im_protocols & NFC_PROTO_ISO14443_MASK)\n\t\tparam[0] |= (1 << 2);\n\n\tif (im_protocols & NFC_PROTO_ISO14443_B_MASK)\n\t\tparam[0] |= 1;\n\n\tif (im_protocols & NFC_PROTO_MIFARE_MASK)\n\t\tparam[1] |= 1;\n\n\tif (im_protocols & NFC_PROTO_JEWEL_MASK)\n\t\tparam[0] |= (1 << 1);\n\n\tif (im_protocols & NFC_PROTO_FELICA_MASK)\n\t\tparam[0] |= (1 << 5);\n\n\tif (im_protocols & NFC_PROTO_NFC_DEP_MASK)\n\t\tparam[1] |= (1 << 1);\n\n\tif ((im_protocols | tm_protocols) & NFC_PROTO_NFC_DEP_MASK) {\n\t\thdev->gb = nfc_get_local_general_bytes(hdev->ndev,\n\t\t\t\t\t\t       &hdev->gb_len);\n\t\tif (hdev->gb == NULL || hdev->gb_len == 0) {\n\t\t\tim_protocols &= ~NFC_PROTO_NFC_DEP_MASK;\n\t\t\ttm_protocols &= ~NFC_PROTO_NFC_DEP_MASK;\n\t\t}\n\t}\n\n\tr = nfc_hci_send_event(hdev, MICROREAD_GATE_ID_MREAD_ISO_A,\n\t\t\t       MICROREAD_EVT_MREAD_DISCOVERY_STOP, NULL, 0);\n\tif (r)\n\t\treturn r;\n\n\tmode = 0xff;\n\tr = nfc_hci_set_param(hdev, MICROREAD_GATE_ID_P2P_TARGET,\n\t\t\t      MICROREAD_PAR_P2P_TARGET_MODE, &mode, 1);\n\tif (r)\n\t\treturn r;\n\n\tif (im_protocols & NFC_PROTO_NFC_DEP_MASK) {\n\t\tr = nfc_hci_set_param(hdev, MICROREAD_GATE_ID_P2P_INITIATOR,\n\t\t\t\t      MICROREAD_PAR_P2P_INITIATOR_GI,\n\t\t\t\t      hdev->gb, hdev->gb_len);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tif (tm_protocols & NFC_PROTO_NFC_DEP_MASK) {\n\t\tr = nfc_hci_set_param(hdev, MICROREAD_GATE_ID_P2P_TARGET,\n\t\t\t\t      MICROREAD_PAR_P2P_TARGET_GT,\n\t\t\t\t      hdev->gb, hdev->gb_len);\n\t\tif (r)\n\t\t\treturn r;\n\n\t\tmode = 0x02;\n\t\tr = nfc_hci_set_param(hdev, MICROREAD_GATE_ID_P2P_TARGET,\n\t\t\t\t      MICROREAD_PAR_P2P_TARGET_MODE, &mode, 1);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\treturn nfc_hci_send_event(hdev, MICROREAD_GATE_ID_MREAD_ISO_A,\n\t\t\t\t  MICROREAD_EVT_MREAD_DISCOVERY_START_SOME,\n\t\t\t\t  param, 2);\n}\n\nstatic int microread_dep_link_up(struct nfc_hci_dev *hdev,\n\t\t\t\tstruct nfc_target *target, u8 comm_mode,\n\t\t\t\tu8 *gb, size_t gb_len)\n{\n\tstruct sk_buff *rgb_skb = NULL;\n\tint r;\n\n\tr = nfc_hci_get_param(hdev, target->hci_reader_gate,\n\t\t\t      MICROREAD_PAR_P2P_INITIATOR_GT, &rgb_skb);\n\tif (r < 0)\n\t\treturn r;\n\n\tif (rgb_skb->len == 0 || rgb_skb->len > NFC_GB_MAXSIZE) {\n\t\tr = -EPROTO;\n\t\tgoto exit;\n\t}\n\n\tr = nfc_set_remote_general_bytes(hdev->ndev, rgb_skb->data,\n\t\t\t\t\t rgb_skb->len);\n\tif (r == 0)\n\t\tr = nfc_dep_link_is_up(hdev->ndev, target->idx, comm_mode,\n\t\t\t\t       NFC_RF_INITIATOR);\nexit:\n\tkfree_skb(rgb_skb);\n\n\treturn r;\n}\n\nstatic int microread_dep_link_down(struct nfc_hci_dev *hdev)\n{\n\treturn nfc_hci_send_event(hdev, MICROREAD_GATE_ID_P2P_INITIATOR,\n\t\t\t\t  MICROREAD_EVT_MREAD_DISCOVERY_STOP, NULL, 0);\n}\n\nstatic int microread_target_from_gate(struct nfc_hci_dev *hdev, u8 gate,\n\t\t\t\t      struct nfc_target *target)\n{\n\tswitch (gate) {\n\tcase MICROREAD_GATE_ID_P2P_INITIATOR:\n\t\ttarget->supported_protocols = NFC_PROTO_NFC_DEP_MASK;\n\t\tbreak;\n\tdefault:\n\t\treturn -EPROTO;\n\t}\n\n\treturn 0;\n}\n\nstatic int microread_complete_target_discovered(struct nfc_hci_dev *hdev,\n\t\t\t\t\t\tu8 gate,\n\t\t\t\t\t\tstruct nfc_target *target)\n{\n\treturn 0;\n}\n\n#define MICROREAD_CB_TYPE_READER_ALL 1\n\nstatic void microread_im_transceive_cb(void *context, struct sk_buff *skb,\n\t\t\t\t       int err)\n{\n\tconst struct microread_info *info = context;\n\n\tswitch (info->async_cb_type) {\n\tcase MICROREAD_CB_TYPE_READER_ALL:\n\t\tif (err == 0) {\n\t\t\tif (skb->len == 0) {\n\t\t\t\tkfree_skb(skb);\n\t\t\t\tinfo->async_cb(info->async_cb_context, NULL,\n\t\t\t\t\t       -EPROTO);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (skb->data[skb->len - 1] != 0) {\n\t\t\t\terr = nfc_hci_result_to_errno(\n\t\t\t\t\t\t       skb->data[skb->len - 1]);\n\t\t\t\tkfree_skb(skb);\n\t\t\t\tinfo->async_cb(info->async_cb_context, NULL,\n\t\t\t\t\t       err);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tskb_trim(skb, skb->len - 1);\t \n\t\t}\n\t\tinfo->async_cb(info->async_cb_context, skb, err);\n\t\tbreak;\n\tdefault:\n\t\tif (err == 0)\n\t\t\tkfree_skb(skb);\n\t\tbreak;\n\t}\n}\n\n \nstatic int microread_im_transceive(struct nfc_hci_dev *hdev,\n\t\t\t\t   struct nfc_target *target,\n\t\t\t\t   struct sk_buff *skb, data_exchange_cb_t cb,\n\t\t\t\t   void *cb_context)\n{\n\tstruct microread_info *info = nfc_hci_get_clientdata(hdev);\n\tu8 control_bits;\n\tu16 crc;\n\n\tpr_info(\"data exchange to gate 0x%x\\n\", target->hci_reader_gate);\n\n\tif (target->hci_reader_gate == MICROREAD_GATE_ID_P2P_INITIATOR) {\n\t\t*(u8 *)skb_push(skb, 1) = 0;\n\n\t\treturn nfc_hci_send_event(hdev, target->hci_reader_gate,\n\t\t\t\t     MICROREAD_EVT_P2P_INITIATOR_EXCHANGE_TO_RF,\n\t\t\t\t     skb->data, skb->len);\n\t}\n\n\tswitch (target->hci_reader_gate) {\n\tcase MICROREAD_GATE_ID_MREAD_ISO_A:\n\t\tcontrol_bits = 0xCB;\n\t\tbreak;\n\tcase MICROREAD_GATE_ID_MREAD_ISO_A_3:\n\t\tcontrol_bits = 0xCB;\n\t\tbreak;\n\tcase MICROREAD_GATE_ID_MREAD_ISO_B:\n\t\tcontrol_bits = 0xCB;\n\t\tbreak;\n\tcase MICROREAD_GATE_ID_MREAD_NFC_T1:\n\t\tcontrol_bits = 0x1B;\n\n\t\tcrc = crc_ccitt(0xffff, skb->data, skb->len);\n\t\tcrc = ~crc;\n\t\tskb_put_u8(skb, crc & 0xff);\n\t\tskb_put_u8(skb, crc >> 8);\n\t\tbreak;\n\tcase MICROREAD_GATE_ID_MREAD_NFC_T3:\n\t\tcontrol_bits = 0xDB;\n\t\tbreak;\n\tdefault:\n\t\tpr_info(\"Abort im_transceive to invalid gate 0x%x\\n\",\n\t\t\ttarget->hci_reader_gate);\n\t\treturn 1;\n\t}\n\n\t*(u8 *)skb_push(skb, 1) = control_bits;\n\n\tinfo->async_cb_type = MICROREAD_CB_TYPE_READER_ALL;\n\tinfo->async_cb = cb;\n\tinfo->async_cb_context = cb_context;\n\n\treturn nfc_hci_send_cmd_async(hdev, target->hci_reader_gate,\n\t\t\t\t      MICROREAD_CMD_MREAD_EXCHANGE,\n\t\t\t\t      skb->data, skb->len,\n\t\t\t\t      microread_im_transceive_cb, info);\n}\n\nstatic int microread_tm_send(struct nfc_hci_dev *hdev, struct sk_buff *skb)\n{\n\tint r;\n\n\tr = nfc_hci_send_event(hdev, MICROREAD_GATE_ID_P2P_TARGET,\n\t\t\t       MICROREAD_EVT_MCARD_EXCHANGE,\n\t\t\t       skb->data, skb->len);\n\n\tkfree_skb(skb);\n\n\treturn r;\n}\n\nstatic void microread_target_discovered(struct nfc_hci_dev *hdev, u8 gate,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct nfc_target *targets;\n\tint r = 0;\n\n\tpr_info(\"target discovered to gate 0x%x\\n\", gate);\n\n\ttargets = kzalloc(sizeof(struct nfc_target), GFP_KERNEL);\n\tif (targets == NULL) {\n\t\tr = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\ttargets->hci_reader_gate = gate;\n\n\tswitch (gate) {\n\tcase MICROREAD_GATE_ID_MREAD_ISO_A:\n\t\ttargets->supported_protocols =\n\t\t      nfc_hci_sak_to_protocol(skb->data[MICROREAD_EMCF_A_SAK]);\n\t\ttargets->sens_res =\n\t\t\t be16_to_cpu(*(u16 *)&skb->data[MICROREAD_EMCF_A_ATQA]);\n\t\ttargets->sel_res = skb->data[MICROREAD_EMCF_A_SAK];\n\t\ttargets->nfcid1_len = skb->data[MICROREAD_EMCF_A_LEN];\n\t\tif (targets->nfcid1_len > sizeof(targets->nfcid1)) {\n\t\t\tr = -EINVAL;\n\t\t\tgoto exit_free;\n\t\t}\n\t\tmemcpy(targets->nfcid1, &skb->data[MICROREAD_EMCF_A_UID],\n\t\t       targets->nfcid1_len);\n\t\tbreak;\n\tcase MICROREAD_GATE_ID_MREAD_ISO_A_3:\n\t\ttargets->supported_protocols =\n\t\t      nfc_hci_sak_to_protocol(skb->data[MICROREAD_EMCF_A3_SAK]);\n\t\ttargets->sens_res =\n\t\t\t be16_to_cpu(*(u16 *)&skb->data[MICROREAD_EMCF_A3_ATQA]);\n\t\ttargets->sel_res = skb->data[MICROREAD_EMCF_A3_SAK];\n\t\ttargets->nfcid1_len = skb->data[MICROREAD_EMCF_A3_LEN];\n\t\tif (targets->nfcid1_len > sizeof(targets->nfcid1)) {\n\t\t\tr = -EINVAL;\n\t\t\tgoto exit_free;\n\t\t}\n\t\tmemcpy(targets->nfcid1, &skb->data[MICROREAD_EMCF_A3_UID],\n\t\t       targets->nfcid1_len);\n\t\tbreak;\n\tcase MICROREAD_GATE_ID_MREAD_ISO_B:\n\t\ttargets->supported_protocols = NFC_PROTO_ISO14443_B_MASK;\n\t\tmemcpy(targets->nfcid1, &skb->data[MICROREAD_EMCF_B_UID], 4);\n\t\ttargets->nfcid1_len = 4;\n\t\tbreak;\n\tcase MICROREAD_GATE_ID_MREAD_NFC_T1:\n\t\ttargets->supported_protocols = NFC_PROTO_JEWEL_MASK;\n\t\ttargets->sens_res =\n\t\t\tle16_to_cpu(*(u16 *)&skb->data[MICROREAD_EMCF_T1_ATQA]);\n\t\tmemcpy(targets->nfcid1, &skb->data[MICROREAD_EMCF_T1_UID], 4);\n\t\ttargets->nfcid1_len = 4;\n\t\tbreak;\n\tcase MICROREAD_GATE_ID_MREAD_NFC_T3:\n\t\ttargets->supported_protocols = NFC_PROTO_FELICA_MASK;\n\t\tmemcpy(targets->nfcid1, &skb->data[MICROREAD_EMCF_T3_UID], 8);\n\t\ttargets->nfcid1_len = 8;\n\t\tbreak;\n\tdefault:\n\t\tpr_info(\"discard target discovered to gate 0x%x\\n\", gate);\n\t\tgoto exit_free;\n\t}\n\n\tr = nfc_targets_found(hdev->ndev, targets, 1);\n\nexit_free:\n\tkfree(targets);\n\nexit:\n\tkfree_skb(skb);\n\n\tif (r)\n\t\tpr_err(\"Failed to handle discovered target err=%d\\n\", r);\n}\n\nstatic int microread_event_received(struct nfc_hci_dev *hdev, u8 pipe,\n\t\t\t\t     u8 event, struct sk_buff *skb)\n{\n\tint r;\n\tu8 gate = hdev->pipes[pipe].gate;\n\tu8 mode;\n\n\tpr_info(\"Microread received event 0x%x to gate 0x%x\\n\", event, gate);\n\n\tswitch (event) {\n\tcase MICROREAD_EVT_MREAD_CARD_FOUND:\n\t\tmicroread_target_discovered(hdev, gate, skb);\n\t\treturn 0;\n\n\tcase MICROREAD_EVT_P2P_INITIATOR_EXCHANGE_FROM_RF:\n\t\tif (skb->len < 1) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn -EPROTO;\n\t\t}\n\n\t\tif (skb->data[skb->len - 1]) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tskb_trim(skb, skb->len - 1);\n\n\t\tr = nfc_tm_data_received(hdev->ndev, skb);\n\t\tbreak;\n\n\tcase MICROREAD_EVT_MCARD_FIELD_ON:\n\tcase MICROREAD_EVT_MCARD_FIELD_OFF:\n\t\tkfree_skb(skb);\n\t\treturn 0;\n\n\tcase MICROREAD_EVT_P2P_TARGET_ACTIVATED:\n\t\tr = nfc_tm_activated(hdev->ndev, NFC_PROTO_NFC_DEP_MASK,\n\t\t\t\t     NFC_COMM_PASSIVE, skb->data,\n\t\t\t\t     skb->len);\n\n\t\tkfree_skb(skb);\n\t\tbreak;\n\n\tcase MICROREAD_EVT_MCARD_EXCHANGE:\n\t\tif (skb->len < 1) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn -EPROTO;\n\t\t}\n\n\t\tif (skb->data[skb->len-1]) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tskb_trim(skb, skb->len - 1);\n\n\t\tr = nfc_tm_data_received(hdev->ndev, skb);\n\t\tbreak;\n\n\tcase MICROREAD_EVT_P2P_TARGET_DEACTIVATED:\n\t\tkfree_skb(skb);\n\n\t\tmode = 0xff;\n\t\tr = nfc_hci_set_param(hdev, MICROREAD_GATE_ID_P2P_TARGET,\n\t\t\t\t      MICROREAD_PAR_P2P_TARGET_MODE, &mode, 1);\n\t\tif (r)\n\t\t\tbreak;\n\n\t\tr = nfc_hci_send_event(hdev, gate,\n\t\t\t\t       MICROREAD_EVT_MREAD_DISCOVERY_STOP, NULL,\n\t\t\t\t       0);\n\t\tbreak;\n\n\tdefault:\n\t\treturn 1;\n\t}\n\n\treturn r;\n}\n\nstatic const struct nfc_hci_ops microread_hci_ops = {\n\t.open = microread_open,\n\t.close = microread_close,\n\t.hci_ready = microread_hci_ready,\n\t.xmit = microread_xmit,\n\t.start_poll = microread_start_poll,\n\t.dep_link_up = microread_dep_link_up,\n\t.dep_link_down = microread_dep_link_down,\n\t.target_from_gate = microread_target_from_gate,\n\t.complete_target_discovered = microread_complete_target_discovered,\n\t.im_transceive = microread_im_transceive,\n\t.tm_send = microread_tm_send,\n\t.check_presence = NULL,\n\t.event_received = microread_event_received,\n};\n\nint microread_probe(void *phy_id, const struct nfc_phy_ops *phy_ops,\n\t\t    const char *llc_name, int phy_headroom, int phy_tailroom,\n\t\t    int phy_payload, struct nfc_hci_dev **hdev)\n{\n\tstruct microread_info *info;\n\tunsigned long quirks = 0;\n\tu32 protocols;\n\tstruct nfc_hci_init_data init_data;\n\tint r;\n\n\tinfo = kzalloc(sizeof(struct microread_info), GFP_KERNEL);\n\tif (!info) {\n\t\tr = -ENOMEM;\n\t\tgoto err_info_alloc;\n\t}\n\n\tinfo->phy_ops = phy_ops;\n\tinfo->phy_id = phy_id;\n\n\tinit_data.gate_count = ARRAY_SIZE(microread_gates);\n\tmemcpy(init_data.gates, microread_gates, sizeof(microread_gates));\n\n\tstrcpy(init_data.session_id, \"MICROREA\");\n\n\tset_bit(NFC_HCI_QUIRK_SHORT_CLEAR, &quirks);\n\n\tprotocols = NFC_PROTO_JEWEL_MASK |\n\t\t    NFC_PROTO_MIFARE_MASK |\n\t\t    NFC_PROTO_FELICA_MASK |\n\t\t    NFC_PROTO_ISO14443_MASK |\n\t\t    NFC_PROTO_ISO14443_B_MASK |\n\t\t    NFC_PROTO_NFC_DEP_MASK;\n\n\tinfo->hdev = nfc_hci_allocate_device(&microread_hci_ops, &init_data,\n\t\t\t\t\t     quirks, protocols, llc_name,\n\t\t\t\t\t     phy_headroom +\n\t\t\t\t\t     MICROREAD_CMDS_HEADROOM,\n\t\t\t\t\t     phy_tailroom +\n\t\t\t\t\t     MICROREAD_CMD_TAILROOM,\n\t\t\t\t\t     phy_payload);\n\tif (!info->hdev) {\n\t\tpr_err(\"Cannot allocate nfc hdev\\n\");\n\t\tr = -ENOMEM;\n\t\tgoto err_alloc_hdev;\n\t}\n\n\tnfc_hci_set_clientdata(info->hdev, info);\n\n\tr = nfc_hci_register_device(info->hdev);\n\tif (r)\n\t\tgoto err_regdev;\n\n\t*hdev = info->hdev;\n\n\treturn 0;\n\nerr_regdev:\n\tnfc_hci_free_device(info->hdev);\n\nerr_alloc_hdev:\n\tkfree(info);\n\nerr_info_alloc:\n\treturn r;\n}\nEXPORT_SYMBOL(microread_probe);\n\nvoid microread_remove(struct nfc_hci_dev *hdev)\n{\n\tstruct microread_info *info = nfc_hci_get_clientdata(hdev);\n\n\tnfc_hci_unregister_device(hdev);\n\tnfc_hci_free_device(hdev);\n\tkfree(info);\n}\nEXPORT_SYMBOL(microread_remove);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(DRIVER_DESC);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}