{
  "module_name": "i2c.c",
  "hash_id": "d857b6e633b7282d550a2ac0b117fe342a7747e864e41adb6d765018ee960c8f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nfc/microread/i2c.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/gpio.h>\n\n#include <linux/nfc.h>\n#include <net/nfc/hci.h>\n#include <net/nfc/llc.h>\n\n#include \"microread.h\"\n\n#define MICROREAD_I2C_DRIVER_NAME \"microread\"\n\n#define MICROREAD_I2C_FRAME_HEADROOM 1\n#define MICROREAD_I2C_FRAME_TAILROOM 1\n\n \n#define MICROREAD_I2C_LLC_LEN\t\t1\n#define MICROREAD_I2C_LLC_CRC\t\t1\n#define MICROREAD_I2C_LLC_LEN_CRC\t(MICROREAD_I2C_LLC_LEN + \\\n\t\t\t\t\tMICROREAD_I2C_LLC_CRC)\n#define MICROREAD_I2C_LLC_MIN_SIZE\t(1 + MICROREAD_I2C_LLC_LEN_CRC)\n#define MICROREAD_I2C_LLC_MAX_PAYLOAD\t29\n#define MICROREAD_I2C_LLC_MAX_SIZE\t(MICROREAD_I2C_LLC_LEN_CRC + 1 + \\\n\t\t\t\t\tMICROREAD_I2C_LLC_MAX_PAYLOAD)\n\nstruct microread_i2c_phy {\n\tstruct i2c_client *i2c_dev;\n\tstruct nfc_hci_dev *hdev;\n\n\tint hard_fault;\t\t \n};\n\n#define I2C_DUMP_SKB(info, skb)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tpr_debug(\"%s:\\n\", info);\t\t\t\t\\\n\tprint_hex_dump(KERN_DEBUG, \"i2c: \", DUMP_PREFIX_OFFSET,\t\\\n\t\t       16, 1, (skb)->data, (skb)->len, 0);\t\\\n} while (0)\n\nstatic void microread_i2c_add_len_crc(struct sk_buff *skb)\n{\n\tint i;\n\tu8 crc = 0;\n\tint len;\n\n\tlen = skb->len;\n\t*(u8 *)skb_push(skb, 1) = len;\n\n\tfor (i = 0; i < skb->len; i++)\n\t\tcrc = crc ^ skb->data[i];\n\n\tskb_put_u8(skb, crc);\n}\n\nstatic void microread_i2c_remove_len_crc(struct sk_buff *skb)\n{\n\tskb_pull(skb, MICROREAD_I2C_FRAME_HEADROOM);\n\tskb_trim(skb, MICROREAD_I2C_FRAME_TAILROOM);\n}\n\nstatic int check_crc(const struct sk_buff *skb)\n{\n\tint i;\n\tu8 crc = 0;\n\n\tfor (i = 0; i < skb->len - 1; i++)\n\t\tcrc = crc ^ skb->data[i];\n\n\tif (crc != skb->data[skb->len-1]) {\n\t\tpr_err(\"CRC error 0x%x != 0x%x\\n\", crc, skb->data[skb->len-1]);\n\t\tpr_info(\"%s: BAD CRC\\n\", __func__);\n\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}\n\nstatic int microread_i2c_enable(void *phy_id)\n{\n\treturn 0;\n}\n\nstatic void microread_i2c_disable(void *phy_id)\n{\n\treturn;\n}\n\nstatic int microread_i2c_write(void *phy_id, struct sk_buff *skb)\n{\n\tint r;\n\tstruct microread_i2c_phy *phy = phy_id;\n\tstruct i2c_client *client = phy->i2c_dev;\n\n\tif (phy->hard_fault != 0)\n\t\treturn phy->hard_fault;\n\n\tusleep_range(3000, 6000);\n\n\tmicroread_i2c_add_len_crc(skb);\n\n\tI2C_DUMP_SKB(\"i2c frame written\", skb);\n\n\tr = i2c_master_send(client, skb->data, skb->len);\n\n\tif (r == -EREMOTEIO) {\t \n\t\tusleep_range(6000, 10000);\n\t\tr = i2c_master_send(client, skb->data, skb->len);\n\t}\n\n\tif (r >= 0) {\n\t\tif (r != skb->len)\n\t\t\tr = -EREMOTEIO;\n\t\telse\n\t\t\tr = 0;\n\t}\n\n\tmicroread_i2c_remove_len_crc(skb);\n\n\treturn r;\n}\n\n\nstatic int microread_i2c_read(struct microread_i2c_phy *phy,\n\t\t\t      struct sk_buff **skb)\n{\n\tint r;\n\tu8 len;\n\tu8 tmp[MICROREAD_I2C_LLC_MAX_SIZE - 1];\n\tstruct i2c_client *client = phy->i2c_dev;\n\n\tr = i2c_master_recv(client, &len, 1);\n\tif (r != 1) {\n\t\tnfc_err(&client->dev, \"cannot read len byte\\n\");\n\t\treturn -EREMOTEIO;\n\t}\n\n\tif ((len < MICROREAD_I2C_LLC_MIN_SIZE) ||\n\t    (len > MICROREAD_I2C_LLC_MAX_SIZE)) {\n\t\tnfc_err(&client->dev, \"invalid len byte\\n\");\n\t\tr = -EBADMSG;\n\t\tgoto flush;\n\t}\n\n\t*skb = alloc_skb(1 + len, GFP_KERNEL);\n\tif (*skb == NULL) {\n\t\tr = -ENOMEM;\n\t\tgoto flush;\n\t}\n\n\tskb_put_u8(*skb, len);\n\n\tr = i2c_master_recv(client, skb_put(*skb, len), len);\n\tif (r != len) {\n\t\tkfree_skb(*skb);\n\t\treturn -EREMOTEIO;\n\t}\n\n\tI2C_DUMP_SKB(\"cc frame read\", *skb);\n\n\tr = check_crc(*skb);\n\tif (r != 0) {\n\t\tkfree_skb(*skb);\n\t\tr = -EBADMSG;\n\t\tgoto flush;\n\t}\n\n\tskb_pull(*skb, 1);\n\tskb_trim(*skb, (*skb)->len - MICROREAD_I2C_FRAME_TAILROOM);\n\n\tusleep_range(3000, 6000);\n\n\treturn 0;\n\nflush:\n\tif (i2c_master_recv(client, tmp, sizeof(tmp)) < 0)\n\t\tr = -EREMOTEIO;\n\n\tusleep_range(3000, 6000);\n\n\treturn r;\n}\n\nstatic irqreturn_t microread_i2c_irq_thread_fn(int irq, void *phy_id)\n{\n\tstruct microread_i2c_phy *phy = phy_id;\n\tstruct sk_buff *skb = NULL;\n\tint r;\n\n\tif (!phy || irq != phy->i2c_dev->irq) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (phy->hard_fault != 0)\n\t\treturn IRQ_HANDLED;\n\n\tr = microread_i2c_read(phy, &skb);\n\tif (r == -EREMOTEIO) {\n\t\tphy->hard_fault = r;\n\n\t\tnfc_hci_recv_frame(phy->hdev, NULL);\n\n\t\treturn IRQ_HANDLED;\n\t} else if ((r == -ENOMEM) || (r == -EBADMSG)) {\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tnfc_hci_recv_frame(phy->hdev, skb);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct nfc_phy_ops i2c_phy_ops = {\n\t.write = microread_i2c_write,\n\t.enable = microread_i2c_enable,\n\t.disable = microread_i2c_disable,\n};\n\nstatic int microread_i2c_probe(struct i2c_client *client)\n{\n\tstruct microread_i2c_phy *phy;\n\tint r;\n\n\tphy = devm_kzalloc(&client->dev, sizeof(struct microread_i2c_phy),\n\t\t\t   GFP_KERNEL);\n\tif (!phy)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, phy);\n\tphy->i2c_dev = client;\n\n\tr = request_threaded_irq(client->irq, NULL, microread_i2c_irq_thread_fn,\n\t\t\t\t IRQF_TRIGGER_RISING | IRQF_ONESHOT,\n\t\t\t\t MICROREAD_I2C_DRIVER_NAME, phy);\n\tif (r) {\n\t\tnfc_err(&client->dev, \"Unable to register IRQ handler\\n\");\n\t\treturn r;\n\t}\n\n\tr = microread_probe(phy, &i2c_phy_ops, LLC_SHDLC_NAME,\n\t\t\t    MICROREAD_I2C_FRAME_HEADROOM,\n\t\t\t    MICROREAD_I2C_FRAME_TAILROOM,\n\t\t\t    MICROREAD_I2C_LLC_MAX_PAYLOAD, &phy->hdev);\n\tif (r < 0)\n\t\tgoto err_irq;\n\n\treturn 0;\n\nerr_irq:\n\tfree_irq(client->irq, phy);\n\n\treturn r;\n}\n\nstatic void microread_i2c_remove(struct i2c_client *client)\n{\n\tstruct microread_i2c_phy *phy = i2c_get_clientdata(client);\n\n\tmicroread_remove(phy->hdev);\n\n\tfree_irq(client->irq, phy);\n}\n\nstatic const struct i2c_device_id microread_i2c_id[] = {\n\t{ MICROREAD_I2C_DRIVER_NAME, 0},\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, microread_i2c_id);\n\nstatic struct i2c_driver microread_i2c_driver = {\n\t.driver = {\n\t\t.name = MICROREAD_I2C_DRIVER_NAME,\n\t},\n\t.probe\t\t= microread_i2c_probe,\n\t.remove\t\t= microread_i2c_remove,\n\t.id_table\t= microread_i2c_id,\n};\n\nmodule_i2c_driver(microread_i2c_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(DRIVER_DESC);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}