{
  "module_name": "pn544.c",
  "hash_id": "1fb8979ba3a13f908fca0df46fda4f199922ae42d95d7fcc6654a888a4531986",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nfc/pn544/pn544.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#include <linux/nfc.h>\n#include <net/nfc/hci.h>\n\n#include \"pn544.h\"\n\n \n#define PN544_HCI_RESETVEN_TIME\t\t30\n\nenum pn544_state {\n\tPN544_ST_COLD,\n\tPN544_ST_FW_READY,\n\tPN544_ST_READY,\n};\n\n#define FULL_VERSION_LEN 11\n\n \n#define PN544_WRITE\t\t0x3f\n#define PN544_TEST_SWP\t\t0x21\n\n \n\n \n#define PN544_RF_READER_A_AUTO_ACTIVATION\t\t\t0x10\n#define PN544_RF_READER_A_CMD_CONTINUE_ACTIVATION\t\t0x12\n#define PN544_MIFARE_CMD\t\t\t\t\t0x21\n\n \n#define PN544_RF_READER_CMD_PRESENCE_CHECK\t0x30\n#define PN544_RF_READER_CMD_ACTIVATE_NEXT\t0x32\n\n \n#define PN544_ID_MGMT_FULL_VERSION_SW\t\t0x10\n\n#define PN544_RF_READER_ISO15693_GATE\t\t0x12\n\n#define PN544_RF_READER_F_GATE\t\t\t0x14\n#define PN544_FELICA_ID\t\t\t\t0x04\n#define PN544_FELICA_RAW\t\t\t0x20\n\n#define PN544_RF_READER_JEWEL_GATE\t\t0x15\n#define PN544_JEWEL_RAW_CMD\t\t\t0x23\n\n#define PN544_RF_READER_NFCIP1_INITIATOR_GATE\t0x30\n#define PN544_RF_READER_NFCIP1_TARGET_GATE\t0x31\n\n#define PN544_SYS_MGMT_GATE\t\t\t0x90\n#define PN544_SYS_MGMT_INFO_NOTIFICATION\t0x02\n\n#define PN544_POLLING_LOOP_MGMT_GATE\t\t0x94\n#define PN544_DEP_MODE\t\t\t\t0x01\n#define PN544_DEP_ATR_REQ\t\t\t0x02\n#define PN544_DEP_ATR_RES\t\t\t0x03\n#define PN544_DEP_MERGE\t\t\t\t0x0D\n#define PN544_PL_RDPHASES\t\t\t0x06\n#define PN544_PL_EMULATION\t\t\t0x07\n#define PN544_PL_NFCT_DEACTIVATED\t\t0x09\n\n#define PN544_SWP_MGMT_GATE\t\t\t0xA0\n#define PN544_SWP_DEFAULT_MODE\t\t\t0x01\n\n#define PN544_NFC_WI_MGMT_GATE\t\t\t0xA1\n#define PN544_NFC_ESE_DEFAULT_MODE\t\t0x01\n\n#define PN544_HCI_EVT_SND_DATA\t\t\t0x01\n#define PN544_HCI_EVT_ACTIVATED\t\t\t0x02\n#define PN544_HCI_EVT_DEACTIVATED\t\t0x03\n#define PN544_HCI_EVT_RCV_DATA\t\t\t0x04\n#define PN544_HCI_EVT_CONTINUE_MI\t\t0x05\n#define PN544_HCI_EVT_SWITCH_MODE\t\t0x03\n\n#define PN544_HCI_CMD_ATTREQUEST\t\t0x12\n#define PN544_HCI_CMD_CONTINUE_ACTIVATION\t0x13\n\nstatic const struct nfc_hci_gate pn544_gates[] = {\n\t{NFC_HCI_ADMIN_GATE, NFC_HCI_INVALID_PIPE},\n\t{NFC_HCI_LOOPBACK_GATE, NFC_HCI_INVALID_PIPE},\n\t{NFC_HCI_ID_MGMT_GATE, NFC_HCI_INVALID_PIPE},\n\t{NFC_HCI_LINK_MGMT_GATE, NFC_HCI_INVALID_PIPE},\n\t{NFC_HCI_RF_READER_B_GATE, NFC_HCI_INVALID_PIPE},\n\t{NFC_HCI_RF_READER_A_GATE, NFC_HCI_INVALID_PIPE},\n\t{PN544_SYS_MGMT_GATE, NFC_HCI_INVALID_PIPE},\n\t{PN544_SWP_MGMT_GATE, NFC_HCI_INVALID_PIPE},\n\t{PN544_POLLING_LOOP_MGMT_GATE, NFC_HCI_INVALID_PIPE},\n\t{PN544_NFC_WI_MGMT_GATE, NFC_HCI_INVALID_PIPE},\n\t{PN544_RF_READER_F_GATE, NFC_HCI_INVALID_PIPE},\n\t{PN544_RF_READER_JEWEL_GATE, NFC_HCI_INVALID_PIPE},\n\t{PN544_RF_READER_ISO15693_GATE, NFC_HCI_INVALID_PIPE},\n\t{PN544_RF_READER_NFCIP1_INITIATOR_GATE, NFC_HCI_INVALID_PIPE},\n\t{PN544_RF_READER_NFCIP1_TARGET_GATE, NFC_HCI_INVALID_PIPE}\n};\n\n \n#define PN544_CMDS_HEADROOM\t2\n\nstruct pn544_hci_info {\n\tconst struct nfc_phy_ops *phy_ops;\n\tvoid *phy_id;\n\n\tstruct nfc_hci_dev *hdev;\n\n\tenum pn544_state state;\n\n\tstruct mutex info_lock;\n\n\tint async_cb_type;\n\tdata_exchange_cb_t async_cb;\n\tvoid *async_cb_context;\n\n\tfw_download_t fw_download;\n};\n\nstatic int pn544_hci_open(struct nfc_hci_dev *hdev)\n{\n\tstruct pn544_hci_info *info = nfc_hci_get_clientdata(hdev);\n\tint r = 0;\n\n\tmutex_lock(&info->info_lock);\n\n\tif (info->state != PN544_ST_COLD) {\n\t\tr = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tr = info->phy_ops->enable(info->phy_id);\n\n\tif (r == 0)\n\t\tinfo->state = PN544_ST_READY;\n\nout:\n\tmutex_unlock(&info->info_lock);\n\treturn r;\n}\n\nstatic void pn544_hci_close(struct nfc_hci_dev *hdev)\n{\n\tstruct pn544_hci_info *info = nfc_hci_get_clientdata(hdev);\n\n\tmutex_lock(&info->info_lock);\n\n\tif (info->state == PN544_ST_COLD)\n\t\tgoto out;\n\n\tinfo->phy_ops->disable(info->phy_id);\n\n\tinfo->state = PN544_ST_COLD;\n\nout:\n\tmutex_unlock(&info->info_lock);\n}\n\nstatic int pn544_hci_ready(struct nfc_hci_dev *hdev)\n{\n\tstruct sk_buff *skb;\n\tstatic struct hw_config {\n\t\tu8 adr[2];\n\t\tu8 value;\n\t} hw_config[] = {\n\t\t{{0x9f, 0x9a}, 0x00},\n\n\t\t{{0x98, 0x10}, 0xbc},\n\n\t\t{{0x9e, 0x71}, 0x00},\n\n\t\t{{0x98, 0x09}, 0x00},\n\n\t\t{{0x9e, 0xb4}, 0x00},\n\n\t\t{{0x9c, 0x01}, 0x08},\n\n\t\t{{0x9e, 0xaa}, 0x01},\n\n\t\t{{0x9b, 0xd1}, 0x17},\n\t\t{{0x9b, 0xd2}, 0x58},\n\t\t{{0x9b, 0xd3}, 0x10},\n\t\t{{0x9b, 0xd4}, 0x47},\n\t\t{{0x9b, 0xd5}, 0x0c},\n\t\t{{0x9b, 0xd6}, 0x37},\n\t\t{{0x9b, 0xdd}, 0x33},\n\n\t\t{{0x9b, 0x84}, 0x00},\n\t\t{{0x99, 0x81}, 0x79},\n\t\t{{0x99, 0x31}, 0x79},\n\n\t\t{{0x98, 0x00}, 0x3f},\n\n\t\t{{0x9f, 0x09}, 0x02},\n\n\t\t{{0x9f, 0x0a}, 0x05},\n\n\t\t{{0x9e, 0xd1}, 0xa1},\n\t\t{{0x99, 0x23}, 0x01},\n\n\t\t{{0x9e, 0x74}, 0x00},\n\t\t{{0x9e, 0x90}, 0x00},\n\t\t{{0x9f, 0x28}, 0x10},\n\n\t\t{{0x9f, 0x35}, 0x04},\n\n\t\t{{0x9f, 0x36}, 0x11},\n\n\t\t{{0x9c, 0x31}, 0x00},\n\n\t\t{{0x9c, 0x32}, 0x00},\n\n\t\t{{0x9c, 0x19}, 0x0a},\n\n\t\t{{0x9c, 0x1a}, 0x0a},\n\n\t\t{{0x9c, 0x0c}, 0x00},\n\n\t\t{{0x9c, 0x0d}, 0x00},\n\n\t\t{{0x9c, 0x12}, 0x00},\n\n\t\t{{0x9c, 0x13}, 0x00},\n\n\t\t{{0x98, 0xa2}, 0x09},\n\n\t\t{{0x98, 0x93}, 0x00},\n\n\t\t{{0x98, 0x7d}, 0x08},\n\t\t{{0x98, 0x7e}, 0x00},\n\t\t{{0x9f, 0xc8}, 0x00},\n\t};\n\tstruct hw_config *p = hw_config;\n\tint count = ARRAY_SIZE(hw_config);\n\tstruct sk_buff *res_skb;\n\tu8 param[4];\n\tint r;\n\n\tparam[0] = 0;\n\twhile (count--) {\n\t\tparam[1] = p->adr[0];\n\t\tparam[2] = p->adr[1];\n\t\tparam[3] = p->value;\n\n\t\tr = nfc_hci_send_cmd(hdev, PN544_SYS_MGMT_GATE, PN544_WRITE,\n\t\t\t\t     param, 4, &res_skb);\n\t\tif (r < 0)\n\t\t\treturn r;\n\n\t\tif (res_skb->len != 1) {\n\t\t\tkfree_skb(res_skb);\n\t\t\treturn -EPROTO;\n\t\t}\n\n\t\tif (res_skb->data[0] != p->value) {\n\t\t\tkfree_skb(res_skb);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tkfree_skb(res_skb);\n\n\t\tp++;\n\t}\n\n\tparam[0] = NFC_HCI_UICC_HOST_ID;\n\tr = nfc_hci_set_param(hdev, NFC_HCI_ADMIN_GATE,\n\t\t\t      NFC_HCI_ADMIN_WHITELIST, param, 1);\n\tif (r < 0)\n\t\treturn r;\n\n\tparam[0] = 0x3d;\n\tr = nfc_hci_set_param(hdev, PN544_SYS_MGMT_GATE,\n\t\t\t      PN544_SYS_MGMT_INFO_NOTIFICATION, param, 1);\n\tif (r < 0)\n\t\treturn r;\n\n\tparam[0] = 0x0;\n\tr = nfc_hci_set_param(hdev, NFC_HCI_RF_READER_A_GATE,\n\t\t\t      PN544_RF_READER_A_AUTO_ACTIVATION, param, 1);\n\tif (r < 0)\n\t\treturn r;\n\n\tr = nfc_hci_send_event(hdev, NFC_HCI_RF_READER_A_GATE,\n\t\t\t       NFC_HCI_EVT_END_OPERATION, NULL, 0);\n\tif (r < 0)\n\t\treturn r;\n\n\tparam[0] = 0x1;\n\tr = nfc_hci_set_param(hdev, PN544_POLLING_LOOP_MGMT_GATE,\n\t\t\t      PN544_PL_NFCT_DEACTIVATED, param, 1);\n\tif (r < 0)\n\t\treturn r;\n\n\tparam[0] = 0x0;\n\tr = nfc_hci_set_param(hdev, PN544_POLLING_LOOP_MGMT_GATE,\n\t\t\t      PN544_PL_RDPHASES, param, 1);\n\tif (r < 0)\n\t\treturn r;\n\n\tr = nfc_hci_get_param(hdev, NFC_HCI_ID_MGMT_GATE,\n\t\t\t      PN544_ID_MGMT_FULL_VERSION_SW, &skb);\n\tif (r < 0)\n\t\treturn r;\n\n\tif (skb->len != FULL_VERSION_LEN) {\n\t\tkfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\n\tprint_hex_dump(KERN_DEBUG, \"FULL VERSION SOFTWARE INFO: \",\n\t\t       DUMP_PREFIX_NONE, 16, 1,\n\t\t       skb->data, FULL_VERSION_LEN, false);\n\n\tkfree_skb(skb);\n\n\treturn 0;\n}\n\nstatic int pn544_hci_xmit(struct nfc_hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct pn544_hci_info *info = nfc_hci_get_clientdata(hdev);\n\n\treturn info->phy_ops->write(info->phy_id, skb);\n}\n\nstatic int pn544_hci_start_poll(struct nfc_hci_dev *hdev,\n\t\t\t\tu32 im_protocols, u32 tm_protocols)\n{\n\tu8 phases = 0;\n\tint r;\n\tu8 duration[2];\n\tu8 activated;\n\tu8 i_mode = 0x3f;  \n\tu8 t_mode = 0x0f;\n\tu8 t_merge = 0x01;  \n\n\tpr_info(DRIVER_DESC \": %s protocols 0x%x 0x%x\\n\",\n\t\t__func__, im_protocols, tm_protocols);\n\n\tr = nfc_hci_send_event(hdev, NFC_HCI_RF_READER_A_GATE,\n\t\t\t       NFC_HCI_EVT_END_OPERATION, NULL, 0);\n\tif (r < 0)\n\t\treturn r;\n\n\tduration[0] = 0x18;\n\tduration[1] = 0x6a;\n\tr = nfc_hci_set_param(hdev, PN544_POLLING_LOOP_MGMT_GATE,\n\t\t\t      PN544_PL_EMULATION, duration, 2);\n\tif (r < 0)\n\t\treturn r;\n\n\tactivated = 0;\n\tr = nfc_hci_set_param(hdev, PN544_POLLING_LOOP_MGMT_GATE,\n\t\t\t      PN544_PL_NFCT_DEACTIVATED, &activated, 1);\n\tif (r < 0)\n\t\treturn r;\n\n\tif (im_protocols & (NFC_PROTO_ISO14443_MASK | NFC_PROTO_MIFARE_MASK |\n\t\t\t NFC_PROTO_JEWEL_MASK))\n\t\tphases |= 1;\t\t \n\tif (im_protocols & NFC_PROTO_FELICA_MASK) {\n\t\tphases |= (1 << 2);\t \n\t\tphases |= (1 << 3);\t \n\t}\n\n\tphases |= (1 << 5);\t\t \n\n\tr = nfc_hci_set_param(hdev, PN544_POLLING_LOOP_MGMT_GATE,\n\t\t\t      PN544_PL_RDPHASES, &phases, 1);\n\tif (r < 0)\n\t\treturn r;\n\n\tif ((im_protocols | tm_protocols) & NFC_PROTO_NFC_DEP_MASK) {\n\t\thdev->gb = nfc_get_local_general_bytes(hdev->ndev,\n\t\t\t\t\t\t\t&hdev->gb_len);\n\t\tpr_debug(\"generate local bytes %p\\n\", hdev->gb);\n\t\tif (hdev->gb == NULL || hdev->gb_len == 0) {\n\t\t\tim_protocols &= ~NFC_PROTO_NFC_DEP_MASK;\n\t\t\ttm_protocols &= ~NFC_PROTO_NFC_DEP_MASK;\n\t\t}\n\t}\n\n\tif (im_protocols & NFC_PROTO_NFC_DEP_MASK) {\n\t\tr = nfc_hci_send_event(hdev,\n\t\t\t\tPN544_RF_READER_NFCIP1_INITIATOR_GATE,\n\t\t\t\tNFC_HCI_EVT_END_OPERATION, NULL, 0);\n\t\tif (r < 0)\n\t\t\treturn r;\n\n\t\tr = nfc_hci_set_param(hdev,\n\t\t\t\tPN544_RF_READER_NFCIP1_INITIATOR_GATE,\n\t\t\t\tPN544_DEP_MODE, &i_mode, 1);\n\t\tif (r < 0)\n\t\t\treturn r;\n\n\t\tr = nfc_hci_set_param(hdev,\n\t\t\t\tPN544_RF_READER_NFCIP1_INITIATOR_GATE,\n\t\t\t\tPN544_DEP_ATR_REQ, hdev->gb, hdev->gb_len);\n\t\tif (r < 0)\n\t\t\treturn r;\n\n\t\tr = nfc_hci_send_event(hdev,\n\t\t\t\tPN544_RF_READER_NFCIP1_INITIATOR_GATE,\n\t\t\t\tNFC_HCI_EVT_READER_REQUESTED, NULL, 0);\n\t\tif (r < 0)\n\t\t\tnfc_hci_send_event(hdev,\n\t\t\t\t\tPN544_RF_READER_NFCIP1_INITIATOR_GATE,\n\t\t\t\t\tNFC_HCI_EVT_END_OPERATION, NULL, 0);\n\t}\n\n\tif (tm_protocols & NFC_PROTO_NFC_DEP_MASK) {\n\t\tr = nfc_hci_set_param(hdev, PN544_RF_READER_NFCIP1_TARGET_GATE,\n\t\t\t\tPN544_DEP_MODE, &t_mode, 1);\n\t\tif (r < 0)\n\t\t\treturn r;\n\n\t\tr = nfc_hci_set_param(hdev, PN544_RF_READER_NFCIP1_TARGET_GATE,\n\t\t\t\tPN544_DEP_ATR_RES, hdev->gb, hdev->gb_len);\n\t\tif (r < 0)\n\t\t\treturn r;\n\n\t\tr = nfc_hci_set_param(hdev, PN544_RF_READER_NFCIP1_TARGET_GATE,\n\t\t\t\tPN544_DEP_MERGE, &t_merge, 1);\n\t\tif (r < 0)\n\t\t\treturn r;\n\t}\n\n\tr = nfc_hci_send_event(hdev, NFC_HCI_RF_READER_A_GATE,\n\t\t\t       NFC_HCI_EVT_READER_REQUESTED, NULL, 0);\n\tif (r < 0)\n\t\tnfc_hci_send_event(hdev, NFC_HCI_RF_READER_A_GATE,\n\t\t\t\t   NFC_HCI_EVT_END_OPERATION, NULL, 0);\n\n\treturn r;\n}\n\nstatic int pn544_hci_dep_link_up(struct nfc_hci_dev *hdev,\n\t\t\t\tstruct nfc_target *target, u8 comm_mode,\n\t\t\t\tu8 *gb, size_t gb_len)\n{\n\tstruct sk_buff *rgb_skb = NULL;\n\tint r;\n\n\tr = nfc_hci_get_param(hdev, target->hci_reader_gate,\n\t\t\t\tPN544_DEP_ATR_RES, &rgb_skb);\n\tif (r < 0)\n\t\treturn r;\n\n\tif (rgb_skb->len == 0 || rgb_skb->len > NFC_GB_MAXSIZE) {\n\t\tr = -EPROTO;\n\t\tgoto exit;\n\t}\n\tprint_hex_dump(KERN_DEBUG, \"remote gb: \", DUMP_PREFIX_OFFSET,\n\t\t\t16, 1, rgb_skb->data, rgb_skb->len, true);\n\n\tr = nfc_set_remote_general_bytes(hdev->ndev, rgb_skb->data,\n\t\t\t\t\t\trgb_skb->len);\n\n\tif (r == 0)\n\t\tr = nfc_dep_link_is_up(hdev->ndev, target->idx, comm_mode,\n\t\t\t\t\tNFC_RF_INITIATOR);\nexit:\n\tkfree_skb(rgb_skb);\n\treturn r;\n}\n\nstatic int pn544_hci_dep_link_down(struct nfc_hci_dev *hdev)\n{\n\n\treturn nfc_hci_send_event(hdev, PN544_RF_READER_NFCIP1_INITIATOR_GATE,\n\t\t\t\t\tNFC_HCI_EVT_END_OPERATION, NULL, 0);\n}\n\nstatic int pn544_hci_target_from_gate(struct nfc_hci_dev *hdev, u8 gate,\n\t\t\t\t      struct nfc_target *target)\n{\n\tswitch (gate) {\n\tcase PN544_RF_READER_F_GATE:\n\t\ttarget->supported_protocols = NFC_PROTO_FELICA_MASK;\n\t\tbreak;\n\tcase PN544_RF_READER_JEWEL_GATE:\n\t\ttarget->supported_protocols = NFC_PROTO_JEWEL_MASK;\n\t\ttarget->sens_res = 0x0c00;\n\t\tbreak;\n\tcase PN544_RF_READER_NFCIP1_INITIATOR_GATE:\n\t\ttarget->supported_protocols = NFC_PROTO_NFC_DEP_MASK;\n\t\tbreak;\n\tdefault:\n\t\treturn -EPROTO;\n\t}\n\n\treturn 0;\n}\n\nstatic int pn544_hci_complete_target_discovered(struct nfc_hci_dev *hdev,\n\t\t\t\t\t\tu8 gate,\n\t\t\t\t\t\tstruct nfc_target *target)\n{\n\tstruct sk_buff *uid_skb;\n\tint r = 0;\n\n\tif (gate == PN544_RF_READER_NFCIP1_INITIATOR_GATE)\n\t\treturn r;\n\n\tif (target->supported_protocols & NFC_PROTO_NFC_DEP_MASK) {\n\t\tr = nfc_hci_send_cmd(hdev,\n\t\t\tPN544_RF_READER_NFCIP1_INITIATOR_GATE,\n\t\t\tPN544_HCI_CMD_CONTINUE_ACTIVATION, NULL, 0, NULL);\n\t\tif (r < 0)\n\t\t\treturn r;\n\n\t\ttarget->hci_reader_gate = PN544_RF_READER_NFCIP1_INITIATOR_GATE;\n\t} else if (target->supported_protocols & NFC_PROTO_MIFARE_MASK) {\n\t\tif (target->nfcid1_len != 4 && target->nfcid1_len != 7 &&\n\t\t    target->nfcid1_len != 10)\n\t\t\treturn -EPROTO;\n\n\t\tr = nfc_hci_send_cmd(hdev, NFC_HCI_RF_READER_A_GATE,\n\t\t\t\t     PN544_RF_READER_CMD_ACTIVATE_NEXT,\n\t\t\t\t     target->nfcid1, target->nfcid1_len, NULL);\n\t} else if (target->supported_protocols & NFC_PROTO_FELICA_MASK) {\n\t\tr = nfc_hci_get_param(hdev, PN544_RF_READER_F_GATE,\n\t\t\t\t      PN544_FELICA_ID, &uid_skb);\n\t\tif (r < 0)\n\t\t\treturn r;\n\n\t\tif (uid_skb->len != 8) {\n\t\t\tkfree_skb(uid_skb);\n\t\t\treturn -EPROTO;\n\t\t}\n\n\t\t \n\t\tif ((uid_skb->data[0] == 0x01) && (uid_skb->data[1] == 0xfe)) {\n\t\t\tkfree_skb(uid_skb);\n\t\t\tr = nfc_hci_send_cmd(hdev,\n\t\t\t\t\tPN544_RF_READER_NFCIP1_INITIATOR_GATE,\n\t\t\t\t\tPN544_HCI_CMD_CONTINUE_ACTIVATION,\n\t\t\t\t\tNULL, 0, NULL);\n\t\t\tif (r < 0)\n\t\t\t\treturn r;\n\n\t\t\ttarget->supported_protocols = NFC_PROTO_NFC_DEP_MASK;\n\t\t\ttarget->hci_reader_gate =\n\t\t\t\tPN544_RF_READER_NFCIP1_INITIATOR_GATE;\n\t\t} else {\n\t\t\tr = nfc_hci_send_cmd(hdev, PN544_RF_READER_F_GATE,\n\t\t\t\t\t     PN544_RF_READER_CMD_ACTIVATE_NEXT,\n\t\t\t\t\t     uid_skb->data, uid_skb->len, NULL);\n\t\t\tkfree_skb(uid_skb);\n\t\t}\n\t} else if (target->supported_protocols & NFC_PROTO_ISO14443_MASK) {\n\t\t \n\t\tif (target->sens_res == 0x4403)\t \n\t\t\tr = nfc_hci_send_cmd(hdev, NFC_HCI_RF_READER_A_GATE,\n\t\t\t      PN544_RF_READER_A_CMD_CONTINUE_ACTIVATION,\n\t\t\t      NULL, 0, NULL);\n\t}\n\n\treturn r;\n}\n\n#define PN544_CB_TYPE_READER_F 1\n\nstatic void pn544_hci_data_exchange_cb(void *context, struct sk_buff *skb,\n\t\t\t\t       int err)\n{\n\tstruct pn544_hci_info *info = context;\n\n\tswitch (info->async_cb_type) {\n\tcase PN544_CB_TYPE_READER_F:\n\t\tif (err == 0)\n\t\t\tskb_pull(skb, 1);\n\t\tinfo->async_cb(info->async_cb_context, skb, err);\n\t\tbreak;\n\tdefault:\n\t\tif (err == 0)\n\t\t\tkfree_skb(skb);\n\t\tbreak;\n\t}\n}\n\n#define MIFARE_CMD_AUTH_KEY_A\t0x60\n#define MIFARE_CMD_AUTH_KEY_B\t0x61\n#define MIFARE_CMD_HEADER\t2\n#define MIFARE_UID_LEN\t\t4\n#define MIFARE_KEY_LEN\t\t6\n#define MIFARE_CMD_LEN\t\t12\n \nstatic int pn544_hci_im_transceive(struct nfc_hci_dev *hdev,\n\t\t\t\t   struct nfc_target *target,\n\t\t\t\t   struct sk_buff *skb, data_exchange_cb_t cb,\n\t\t\t\t   void *cb_context)\n{\n\tstruct pn544_hci_info *info = nfc_hci_get_clientdata(hdev);\n\n\tpr_info(DRIVER_DESC \": %s for gate=%d\\n\", __func__,\n\t\ttarget->hci_reader_gate);\n\n\tswitch (target->hci_reader_gate) {\n\tcase NFC_HCI_RF_READER_A_GATE:\n\t\tif (target->supported_protocols & NFC_PROTO_MIFARE_MASK) {\n\t\t\t \n\t\t\tif (skb->len == MIFARE_CMD_LEN &&\n\t\t\t    (skb->data[0] == MIFARE_CMD_AUTH_KEY_A ||\n\t\t\t     skb->data[0] == MIFARE_CMD_AUTH_KEY_B)) {\n\t\t\t\tu8 uid[MIFARE_UID_LEN];\n\t\t\t\tu8 *data = skb->data + MIFARE_CMD_HEADER;\n\n\t\t\t\tmemcpy(uid, data + MIFARE_KEY_LEN,\n\t\t\t\t       MIFARE_UID_LEN);\n\t\t\t\tmemmove(data + MIFARE_UID_LEN, data,\n\t\t\t\t\tMIFARE_KEY_LEN);\n\t\t\t\tmemcpy(data, uid, MIFARE_UID_LEN);\n\t\t\t}\n\n\t\t\treturn nfc_hci_send_cmd_async(hdev,\n\t\t\t\t\t\t      target->hci_reader_gate,\n\t\t\t\t\t\t      PN544_MIFARE_CMD,\n\t\t\t\t\t\t      skb->data, skb->len,\n\t\t\t\t\t\t      cb, cb_context);\n\t\t} else\n\t\t\treturn 1;\n\tcase PN544_RF_READER_F_GATE:\n\t\t*(u8 *)skb_push(skb, 1) = 0;\n\t\t*(u8 *)skb_push(skb, 1) = 0;\n\n\t\tinfo->async_cb_type = PN544_CB_TYPE_READER_F;\n\t\tinfo->async_cb = cb;\n\t\tinfo->async_cb_context = cb_context;\n\n\t\treturn nfc_hci_send_cmd_async(hdev, target->hci_reader_gate,\n\t\t\t\t\t      PN544_FELICA_RAW, skb->data,\n\t\t\t\t\t      skb->len,\n\t\t\t\t\t      pn544_hci_data_exchange_cb, info);\n\tcase PN544_RF_READER_JEWEL_GATE:\n\t\treturn nfc_hci_send_cmd_async(hdev, target->hci_reader_gate,\n\t\t\t\t\t      PN544_JEWEL_RAW_CMD, skb->data,\n\t\t\t\t\t      skb->len, cb, cb_context);\n\tcase PN544_RF_READER_NFCIP1_INITIATOR_GATE:\n\t\t*(u8 *)skb_push(skb, 1) = 0;\n\n\t\treturn nfc_hci_send_event(hdev, target->hci_reader_gate,\n\t\t\t\t\tPN544_HCI_EVT_SND_DATA, skb->data,\n\t\t\t\t\tskb->len);\n\tdefault:\n\t\treturn 1;\n\t}\n}\n\nstatic int pn544_hci_tm_send(struct nfc_hci_dev *hdev, struct sk_buff *skb)\n{\n\tint r;\n\n\t \n\t*(u8 *)skb_push(skb, 1) = 0;\n\n\tr = nfc_hci_send_event(hdev, PN544_RF_READER_NFCIP1_TARGET_GATE,\n\t\t\t       PN544_HCI_EVT_SND_DATA, skb->data, skb->len);\n\n\tkfree_skb(skb);\n\n\treturn r;\n}\n\nstatic int pn544_hci_check_presence(struct nfc_hci_dev *hdev,\n\t\t\t\t   struct nfc_target *target)\n{\n\tpr_debug(\"supported protocol %d\\n\", target->supported_protocols);\n\tif (target->supported_protocols & (NFC_PROTO_ISO14443_MASK |\n\t\t\t\t\tNFC_PROTO_ISO14443_B_MASK)) {\n\t\treturn nfc_hci_send_cmd(hdev, target->hci_reader_gate,\n\t\t\t\t\tPN544_RF_READER_CMD_PRESENCE_CHECK,\n\t\t\t\t\tNULL, 0, NULL);\n\t} else if (target->supported_protocols & NFC_PROTO_MIFARE_MASK) {\n\t\tif (target->nfcid1_len != 4 && target->nfcid1_len != 7 &&\n\t\t    target->nfcid1_len != 10)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\treturn nfc_hci_send_cmd(hdev, NFC_HCI_RF_READER_A_GATE,\n\t\t\t\t     PN544_RF_READER_CMD_ACTIVATE_NEXT,\n\t\t\t\t     target->nfcid1, target->nfcid1_len, NULL);\n\t} else if (target->supported_protocols & (NFC_PROTO_JEWEL_MASK |\n\t\t\t\t\t\tNFC_PROTO_FELICA_MASK)) {\n\t\treturn -EOPNOTSUPP;\n\t} else if (target->supported_protocols & NFC_PROTO_NFC_DEP_MASK) {\n\t\treturn nfc_hci_send_cmd(hdev, target->hci_reader_gate,\n\t\t\t\t\tPN544_HCI_CMD_ATTREQUEST,\n\t\t\t\t\tNULL, 0, NULL);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int pn544_hci_event_received(struct nfc_hci_dev *hdev, u8 pipe, u8 event,\n\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct sk_buff *rgb_skb = NULL;\n\tu8 gate = hdev->pipes[pipe].gate;\n\tint r;\n\n\tpr_debug(\"hci event %d\\n\", event);\n\tswitch (event) {\n\tcase PN544_HCI_EVT_ACTIVATED:\n\t\tif (gate == PN544_RF_READER_NFCIP1_INITIATOR_GATE) {\n\t\t\tr = nfc_hci_target_discovered(hdev, gate);\n\t\t} else if (gate == PN544_RF_READER_NFCIP1_TARGET_GATE) {\n\t\t\tr = nfc_hci_get_param(hdev, gate, PN544_DEP_ATR_REQ,\n\t\t\t\t\t      &rgb_skb);\n\t\t\tif (r < 0)\n\t\t\t\tgoto exit;\n\n\t\t\tr = nfc_tm_activated(hdev->ndev, NFC_PROTO_NFC_DEP_MASK,\n\t\t\t\t\t     NFC_COMM_PASSIVE, rgb_skb->data,\n\t\t\t\t\t     rgb_skb->len);\n\n\t\t\tkfree_skb(rgb_skb);\n\t\t} else {\n\t\t\tr = -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase PN544_HCI_EVT_DEACTIVATED:\n\t\tr = nfc_hci_send_event(hdev, gate, NFC_HCI_EVT_END_OPERATION,\n\t\t\t\t       NULL, 0);\n\t\tbreak;\n\tcase PN544_HCI_EVT_RCV_DATA:\n\t\tif (skb->len < 2) {\n\t\t\tr = -EPROTO;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (skb->data[0] != 0) {\n\t\t\tpr_debug(\"data0 %d\\n\", skb->data[0]);\n\t\t\tr = -EPROTO;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tskb_pull(skb, 2);\n\t\treturn nfc_tm_data_received(hdev->ndev, skb);\n\tdefault:\n\t\treturn 1;\n\t}\n\nexit:\n\tkfree_skb(skb);\n\n\treturn r;\n}\n\nstatic int pn544_hci_fw_download(struct nfc_hci_dev *hdev,\n\t\t\t\t const char *firmware_name)\n{\n\tstruct pn544_hci_info *info = nfc_hci_get_clientdata(hdev);\n\n\tif (info->fw_download == NULL)\n\t\treturn -ENOTSUPP;\n\n\treturn info->fw_download(info->phy_id, firmware_name, hdev->sw_romlib);\n}\n\nstatic int pn544_hci_discover_se(struct nfc_hci_dev *hdev)\n{\n\tu32 se_idx = 0;\n\tu8 ese_mode = 0x01;  \n\tstruct sk_buff *res_skb;\n\tint r;\n\n\tr = nfc_hci_send_cmd(hdev, PN544_SYS_MGMT_GATE, PN544_TEST_SWP,\n\t\t\t     NULL, 0, &res_skb);\n\n\tif (r == 0) {\n\t\tif (res_skb->len == 2 && res_skb->data[0] == 0x00)\n\t\t\tnfc_add_se(hdev->ndev, se_idx++, NFC_SE_UICC);\n\n\t\tkfree_skb(res_skb);\n\t}\n\n\tr = nfc_hci_send_event(hdev, PN544_NFC_WI_MGMT_GATE,\n\t\t\t\tPN544_HCI_EVT_SWITCH_MODE,\n\t\t\t\t&ese_mode, 1);\n\tif (r == 0)\n\t\tnfc_add_se(hdev->ndev, se_idx++, NFC_SE_EMBEDDED);\n\n\treturn !se_idx;\n}\n\n#define PN544_SE_MODE_OFF\t0x00\n#define PN544_SE_MODE_ON\t0x01\nstatic int pn544_hci_enable_se(struct nfc_hci_dev *hdev, u32 se_idx)\n{\n\tconst struct nfc_se *se;\n\tu8 enable = PN544_SE_MODE_ON;\n\tstatic struct uicc_gatelist {\n\t\tu8 head;\n\t\tu8 adr[2];\n\t\tu8 value;\n\t} uicc_gatelist[] = {\n\t\t{0x00, {0x9e, 0xd9}, 0x23},\n\t\t{0x00, {0x9e, 0xda}, 0x21},\n\t\t{0x00, {0x9e, 0xdb}, 0x22},\n\t\t{0x00, {0x9e, 0xdc}, 0x24},\n\t};\n\tstruct uicc_gatelist *p = uicc_gatelist;\n\tint count = ARRAY_SIZE(uicc_gatelist);\n\tstruct sk_buff *res_skb;\n\tint r;\n\n\tse = nfc_find_se(hdev->ndev, se_idx);\n\n\tswitch (se->type) {\n\tcase NFC_SE_UICC:\n\t\twhile (count--) {\n\t\t\tr = nfc_hci_send_cmd(hdev, PN544_SYS_MGMT_GATE,\n\t\t\t\t\tPN544_WRITE, (u8 *)p, 4, &res_skb);\n\t\t\tif (r < 0)\n\t\t\t\treturn r;\n\n\t\t\tif (res_skb->len != 1) {\n\t\t\t\tkfree_skb(res_skb);\n\t\t\t\treturn -EPROTO;\n\t\t\t}\n\n\t\t\tif (res_skb->data[0] != p->value) {\n\t\t\t\tkfree_skb(res_skb);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\n\t\t\tkfree_skb(res_skb);\n\n\t\t\tp++;\n\t\t}\n\n\t\treturn nfc_hci_set_param(hdev, PN544_SWP_MGMT_GATE,\n\t\t\t      PN544_SWP_DEFAULT_MODE, &enable, 1);\n\tcase NFC_SE_EMBEDDED:\n\t\treturn nfc_hci_set_param(hdev, PN544_NFC_WI_MGMT_GATE,\n\t\t\t      PN544_NFC_ESE_DEFAULT_MODE, &enable, 1);\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int pn544_hci_disable_se(struct nfc_hci_dev *hdev, u32 se_idx)\n{\n\tconst struct nfc_se *se;\n\tu8 disable = PN544_SE_MODE_OFF;\n\n\tse = nfc_find_se(hdev->ndev, se_idx);\n\n\tswitch (se->type) {\n\tcase NFC_SE_UICC:\n\t\treturn nfc_hci_set_param(hdev, PN544_SWP_MGMT_GATE,\n\t\t\t      PN544_SWP_DEFAULT_MODE, &disable, 1);\n\tcase NFC_SE_EMBEDDED:\n\t\treturn nfc_hci_set_param(hdev, PN544_NFC_WI_MGMT_GATE,\n\t\t\t      PN544_NFC_ESE_DEFAULT_MODE, &disable, 1);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct nfc_hci_ops pn544_hci_ops = {\n\t.open = pn544_hci_open,\n\t.close = pn544_hci_close,\n\t.hci_ready = pn544_hci_ready,\n\t.xmit = pn544_hci_xmit,\n\t.start_poll = pn544_hci_start_poll,\n\t.dep_link_up = pn544_hci_dep_link_up,\n\t.dep_link_down = pn544_hci_dep_link_down,\n\t.target_from_gate = pn544_hci_target_from_gate,\n\t.complete_target_discovered = pn544_hci_complete_target_discovered,\n\t.im_transceive = pn544_hci_im_transceive,\n\t.tm_send = pn544_hci_tm_send,\n\t.check_presence = pn544_hci_check_presence,\n\t.event_received = pn544_hci_event_received,\n\t.fw_download = pn544_hci_fw_download,\n\t.discover_se = pn544_hci_discover_se,\n\t.enable_se = pn544_hci_enable_se,\n\t.disable_se = pn544_hci_disable_se,\n};\n\nint pn544_hci_probe(void *phy_id, const struct nfc_phy_ops *phy_ops,\n\t\t    char *llc_name, int phy_headroom, int phy_tailroom,\n\t\t    int phy_payload, fw_download_t fw_download,\n\t\t    struct nfc_hci_dev **hdev)\n{\n\tstruct pn544_hci_info *info;\n\tu32 protocols;\n\tstruct nfc_hci_init_data init_data;\n\tint r;\n\n\tinfo = kzalloc(sizeof(struct pn544_hci_info), GFP_KERNEL);\n\tif (!info) {\n\t\tr = -ENOMEM;\n\t\tgoto err_info_alloc;\n\t}\n\n\tinfo->phy_ops = phy_ops;\n\tinfo->phy_id = phy_id;\n\tinfo->fw_download = fw_download;\n\tinfo->state = PN544_ST_COLD;\n\tmutex_init(&info->info_lock);\n\n\tinit_data.gate_count = ARRAY_SIZE(pn544_gates);\n\n\tmemcpy(init_data.gates, pn544_gates, sizeof(pn544_gates));\n\n\t \n\tstrcpy(init_data.session_id, \"ID544HCI\");\n\n\tprotocols = NFC_PROTO_JEWEL_MASK |\n\t\t    NFC_PROTO_MIFARE_MASK |\n\t\t    NFC_PROTO_FELICA_MASK |\n\t\t    NFC_PROTO_ISO14443_MASK |\n\t\t    NFC_PROTO_ISO14443_B_MASK |\n\t\t    NFC_PROTO_NFC_DEP_MASK;\n\n\tinfo->hdev = nfc_hci_allocate_device(&pn544_hci_ops, &init_data, 0,\n\t\t\t\t\t     protocols, llc_name,\n\t\t\t\t\t     phy_headroom + PN544_CMDS_HEADROOM,\n\t\t\t\t\t     phy_tailroom, phy_payload);\n\tif (!info->hdev) {\n\t\tpr_err(\"Cannot allocate nfc hdev\\n\");\n\t\tr = -ENOMEM;\n\t\tgoto err_alloc_hdev;\n\t}\n\n\tnfc_hci_set_clientdata(info->hdev, info);\n\n\tr = nfc_hci_register_device(info->hdev);\n\tif (r)\n\t\tgoto err_regdev;\n\n\t*hdev = info->hdev;\n\n\treturn 0;\n\nerr_regdev:\n\tnfc_hci_free_device(info->hdev);\n\nerr_alloc_hdev:\n\tkfree(info);\n\nerr_info_alloc:\n\treturn r;\n}\nEXPORT_SYMBOL(pn544_hci_probe);\n\nvoid pn544_hci_remove(struct nfc_hci_dev *hdev)\n{\n\tstruct pn544_hci_info *info = nfc_hci_get_clientdata(hdev);\n\n\tnfc_hci_unregister_device(hdev);\n\tnfc_hci_free_device(hdev);\n\tkfree(info);\n}\nEXPORT_SYMBOL(pn544_hci_remove);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(DRIVER_DESC);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}