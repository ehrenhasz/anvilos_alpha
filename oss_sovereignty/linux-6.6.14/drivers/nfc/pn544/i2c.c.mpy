{
  "module_name": "i2c.c",
  "hash_id": "b98a7ef36c3092c0765b90d2e634ba49b93e1b7d5d82df872b3c932d192be3b8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/nfc/pn544/i2c.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/crc-ccitt.h>\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/acpi.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/nfc.h>\n#include <linux/firmware.h>\n#include <linux/gpio/consumer.h>\n\n#include <asm/unaligned.h>\n\n#include <net/nfc/hci.h>\n#include <net/nfc/llc.h>\n#include <net/nfc/nfc.h>\n\n#include \"pn544.h\"\n\n#define PN544_I2C_FRAME_HEADROOM 1\n#define PN544_I2C_FRAME_TAILROOM 2\n\n \n#define PN544_GPIO_NAME_IRQ \"pn544_irq\"\n#define PN544_GPIO_NAME_FW  \"pn544_fw\"\n#define PN544_GPIO_NAME_EN  \"pn544_en\"\n\n \n#define PN544_HCI_I2C_LLC_LEN\t\t1\n#define PN544_HCI_I2C_LLC_CRC\t\t2\n#define PN544_HCI_I2C_LLC_LEN_CRC\t(PN544_HCI_I2C_LLC_LEN + \\\n\t\t\t\t\t PN544_HCI_I2C_LLC_CRC)\n#define PN544_HCI_I2C_LLC_MIN_SIZE\t(1 + PN544_HCI_I2C_LLC_LEN_CRC)\n#define PN544_HCI_I2C_LLC_MAX_PAYLOAD\t29\n#define PN544_HCI_I2C_LLC_MAX_SIZE\t(PN544_HCI_I2C_LLC_LEN_CRC + 1 + \\\n\t\t\t\t\t PN544_HCI_I2C_LLC_MAX_PAYLOAD)\n\nstatic const struct i2c_device_id pn544_hci_i2c_id_table[] = {\n\t{\"pn544\", 0},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(i2c, pn544_hci_i2c_id_table);\n\nstatic const struct acpi_device_id pn544_hci_i2c_acpi_match[] __maybe_unused = {\n\t{\"NXP5440\", 0},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(acpi, pn544_hci_i2c_acpi_match);\n\n#define PN544_HCI_I2C_DRIVER_NAME \"pn544_hci_i2c\"\n\n \n#define PN544_HW_VARIANT_C2 0xa\n#define PN544_HW_VARIANT_C3 0xb\n\n#define PN544_FW_CMD_RESET 0x01\n#define PN544_FW_CMD_WRITE 0x08\n#define PN544_FW_CMD_CHECK 0x06\n#define PN544_FW_CMD_SECURE_WRITE 0x0C\n#define PN544_FW_CMD_SECURE_CHUNK_WRITE 0x0D\n\nstruct pn544_i2c_fw_frame_write {\n\tu8 cmd;\n\tu16 be_length;\n\tu8 be_dest_addr[3];\n\tu16 be_datalen;\n\tu8 data[];\n} __packed;\n\nstruct pn544_i2c_fw_frame_check {\n\tu8 cmd;\n\tu16 be_length;\n\tu8 be_start_addr[3];\n\tu16 be_datalen;\n\tu16 be_crc;\n} __packed;\n\nstruct pn544_i2c_fw_frame_response {\n\tu8 status;\n\tu16 be_length;\n} __packed;\n\nstruct pn544_i2c_fw_blob {\n\tu32 be_size;\n\tu32 be_destaddr;\n\tu8 data[];\n};\n\nstruct pn544_i2c_fw_secure_frame {\n\tu8 cmd;\n\tu16 be_datalen;\n\tu8 data[];\n} __packed;\n\nstruct pn544_i2c_fw_secure_blob {\n\tu64 header;\n\tu8 data[];\n};\n\n#define PN544_FW_CMD_RESULT_TIMEOUT 0x01\n#define PN544_FW_CMD_RESULT_BAD_CRC 0x02\n#define PN544_FW_CMD_RESULT_ACCESS_DENIED 0x08\n#define PN544_FW_CMD_RESULT_PROTOCOL_ERROR 0x0B\n#define PN544_FW_CMD_RESULT_INVALID_PARAMETER 0x11\n#define PN544_FW_CMD_RESULT_UNSUPPORTED_COMMAND 0x13\n#define PN544_FW_CMD_RESULT_INVALID_LENGTH 0x18\n#define PN544_FW_CMD_RESULT_CRYPTOGRAPHIC_ERROR 0x19\n#define PN544_FW_CMD_RESULT_VERSION_CONDITIONS_ERROR 0x1D\n#define PN544_FW_CMD_RESULT_MEMORY_ERROR 0x20\n#define PN544_FW_CMD_RESULT_CHUNK_OK 0x21\n#define PN544_FW_CMD_RESULT_WRITE_FAILED 0x74\n#define PN544_FW_CMD_RESULT_COMMAND_REJECTED 0xE0\n#define PN544_FW_CMD_RESULT_CHUNK_ERROR 0xE6\n\n#define MIN(X, Y) ((X) < (Y) ? (X) : (Y))\n\n#define PN544_FW_WRITE_BUFFER_MAX_LEN 0x9f7\n#define PN544_FW_I2C_MAX_PAYLOAD PN544_HCI_I2C_LLC_MAX_SIZE\n#define PN544_FW_I2C_WRITE_FRAME_HEADER_LEN 8\n#define PN544_FW_I2C_WRITE_DATA_MAX_LEN MIN((PN544_FW_I2C_MAX_PAYLOAD -\\\n\t\t\t\t\t PN544_FW_I2C_WRITE_FRAME_HEADER_LEN),\\\n\t\t\t\t\t PN544_FW_WRITE_BUFFER_MAX_LEN)\n#define PN544_FW_SECURE_CHUNK_WRITE_HEADER_LEN 3\n#define PN544_FW_SECURE_CHUNK_WRITE_DATA_MAX_LEN (PN544_FW_I2C_MAX_PAYLOAD -\\\n\t\t\tPN544_FW_SECURE_CHUNK_WRITE_HEADER_LEN)\n#define PN544_FW_SECURE_FRAME_HEADER_LEN 3\n#define PN544_FW_SECURE_BLOB_HEADER_LEN 8\n\n#define FW_WORK_STATE_IDLE 1\n#define FW_WORK_STATE_START 2\n#define FW_WORK_STATE_WAIT_WRITE_ANSWER 3\n#define FW_WORK_STATE_WAIT_CHECK_ANSWER 4\n#define FW_WORK_STATE_WAIT_SECURE_WRITE_ANSWER 5\n\nstruct pn544_i2c_phy {\n\tstruct i2c_client *i2c_dev;\n\tstruct nfc_hci_dev *hdev;\n\n\tstruct gpio_desc *gpiod_en;\n\tstruct gpio_desc *gpiod_fw;\n\n\tunsigned int en_polarity;\n\n\tu8 hw_variant;\n\n\tstruct work_struct fw_work;\n\tint fw_work_state;\n\tchar firmware_name[NFC_FIRMWARE_NAME_MAXSIZE + 1];\n\tconst struct firmware *fw;\n\tu32 fw_blob_dest_addr;\n\tsize_t fw_blob_size;\n\tconst u8 *fw_blob_data;\n\tsize_t fw_written;\n\tsize_t fw_size;\n\n\tint fw_cmd_result;\n\n\tint powered;\n\tint run_mode;\n\n\tint hard_fault;\t\t \n};\n\n#define I2C_DUMP_SKB(info, skb)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tpr_debug(\"%s:\\n\", info);\t\t\t\t\\\n\tprint_hex_dump(KERN_DEBUG, \"i2c: \", DUMP_PREFIX_OFFSET,\t\\\n\t\t       16, 1, (skb)->data, (skb)->len, 0);\t\\\n} while (0)\n\nstatic void pn544_hci_i2c_platform_init(struct pn544_i2c_phy *phy)\n{\n\tint polarity, retry, ret;\n\tstatic const char rset_cmd[] = { 0x05, 0xF9, 0x04, 0x00, 0xC3, 0xE5 };\n\tint count = sizeof(rset_cmd);\n\n\tnfc_info(&phy->i2c_dev->dev, \"Detecting nfc_en polarity\\n\");\n\n\t \n\tgpiod_set_value_cansleep(phy->gpiod_fw, 0);\n\n\tfor (polarity = 0; polarity < 2; polarity++) {\n\t\tphy->en_polarity = polarity;\n\t\tretry = 3;\n\t\twhile (retry--) {\n\t\t\t \n\t\t\tgpiod_set_value_cansleep(phy->gpiod_en, !phy->en_polarity);\n\t\t\tusleep_range(10000, 15000);\n\n\t\t\t \n\t\t\tgpiod_set_value_cansleep(phy->gpiod_en, phy->en_polarity);\n\t\t\tusleep_range(10000, 15000);\n\n\t\t\t \n\t\t\tdev_dbg(&phy->i2c_dev->dev, \"Sending reset cmd\\n\");\n\t\t\tret = i2c_master_send(phy->i2c_dev, rset_cmd, count);\n\t\t\tif (ret == count) {\n\t\t\t\tnfc_info(&phy->i2c_dev->dev,\n\t\t\t\t\t \"nfc_en polarity : active %s\\n\",\n\t\t\t\t\t (polarity == 0 ? \"low\" : \"high\"));\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tnfc_err(&phy->i2c_dev->dev,\n\t\t\"Could not detect nfc_en polarity, fallback to active high\\n\");\n\nout:\n\tgpiod_set_value_cansleep(phy->gpiod_en, !phy->en_polarity);\n\tusleep_range(10000, 15000);\n}\n\nstatic void pn544_hci_i2c_enable_mode(struct pn544_i2c_phy *phy, int run_mode)\n{\n\tgpiod_set_value_cansleep(phy->gpiod_fw, run_mode == PN544_FW_MODE ? 1 : 0);\n\tgpiod_set_value_cansleep(phy->gpiod_en, phy->en_polarity);\n\tusleep_range(10000, 15000);\n\n\tphy->run_mode = run_mode;\n}\n\nstatic int pn544_hci_i2c_enable(void *phy_id)\n{\n\tstruct pn544_i2c_phy *phy = phy_id;\n\n\tpn544_hci_i2c_enable_mode(phy, PN544_HCI_MODE);\n\n\tphy->powered = 1;\n\n\treturn 0;\n}\n\nstatic void pn544_hci_i2c_disable(void *phy_id)\n{\n\tstruct pn544_i2c_phy *phy = phy_id;\n\n\tgpiod_set_value_cansleep(phy->gpiod_fw, 0);\n\tgpiod_set_value_cansleep(phy->gpiod_en, !phy->en_polarity);\n\tusleep_range(10000, 15000);\n\n\tgpiod_set_value_cansleep(phy->gpiod_en, phy->en_polarity);\n\tusleep_range(10000, 15000);\n\n\tgpiod_set_value_cansleep(phy->gpiod_en, !phy->en_polarity);\n\tusleep_range(10000, 15000);\n\n\tphy->powered = 0;\n}\n\nstatic void pn544_hci_i2c_add_len_crc(struct sk_buff *skb)\n{\n\tu16 crc;\n\tint len;\n\n\tlen = skb->len + 2;\n\t*(u8 *)skb_push(skb, 1) = len;\n\n\tcrc = crc_ccitt(0xffff, skb->data, skb->len);\n\tcrc = ~crc;\n\tskb_put_u8(skb, crc & 0xff);\n\tskb_put_u8(skb, crc >> 8);\n}\n\nstatic void pn544_hci_i2c_remove_len_crc(struct sk_buff *skb)\n{\n\tskb_pull(skb, PN544_I2C_FRAME_HEADROOM);\n\tskb_trim(skb, PN544_I2C_FRAME_TAILROOM);\n}\n\n \nstatic int pn544_hci_i2c_write(void *phy_id, struct sk_buff *skb)\n{\n\tint r;\n\tstruct pn544_i2c_phy *phy = phy_id;\n\tstruct i2c_client *client = phy->i2c_dev;\n\n\tif (phy->hard_fault != 0)\n\t\treturn phy->hard_fault;\n\n\tusleep_range(3000, 6000);\n\n\tpn544_hci_i2c_add_len_crc(skb);\n\n\tI2C_DUMP_SKB(\"i2c frame written\", skb);\n\n\tr = i2c_master_send(client, skb->data, skb->len);\n\n\tif (r == -EREMOTEIO) {\t \n\t\tusleep_range(6000, 10000);\n\t\tr = i2c_master_send(client, skb->data, skb->len);\n\t}\n\n\tif (r >= 0) {\n\t\tif (r != skb->len)\n\t\t\tr = -EREMOTEIO;\n\t\telse\n\t\t\tr = 0;\n\t}\n\n\tpn544_hci_i2c_remove_len_crc(skb);\n\n\treturn r;\n}\n\nstatic int check_crc(u8 *buf, int buflen)\n{\n\tint len;\n\tu16 crc;\n\n\tlen = buf[0] + 1;\n\tcrc = crc_ccitt(0xffff, buf, len - 2);\n\tcrc = ~crc;\n\n\tif (buf[len - 2] != (crc & 0xff) || buf[len - 1] != (crc >> 8)) {\n\t\tpr_err(\"CRC error 0x%x != 0x%x 0x%x\\n\",\n\t\t       crc, buf[len - 1], buf[len - 2]);\n\t\tpr_info(\"%s: BAD CRC\\n\", __func__);\n\t\tprint_hex_dump(KERN_DEBUG, \"crc: \", DUMP_PREFIX_NONE,\n\t\t\t       16, 2, buf, buflen, false);\n\t\treturn -EPERM;\n\t}\n\treturn 0;\n}\n\n \nstatic int pn544_hci_i2c_read(struct pn544_i2c_phy *phy, struct sk_buff **skb)\n{\n\tint r;\n\tu8 len;\n\tu8 tmp[PN544_HCI_I2C_LLC_MAX_SIZE - 1];\n\tstruct i2c_client *client = phy->i2c_dev;\n\n\tr = i2c_master_recv(client, &len, 1);\n\tif (r != 1) {\n\t\tnfc_err(&client->dev, \"cannot read len byte\\n\");\n\t\treturn -EREMOTEIO;\n\t}\n\n\tif ((len < (PN544_HCI_I2C_LLC_MIN_SIZE - 1)) ||\n\t    (len > (PN544_HCI_I2C_LLC_MAX_SIZE - 1))) {\n\t\tnfc_err(&client->dev, \"invalid len byte\\n\");\n\t\tr = -EBADMSG;\n\t\tgoto flush;\n\t}\n\n\t*skb = alloc_skb(1 + len, GFP_KERNEL);\n\tif (*skb == NULL) {\n\t\tr = -ENOMEM;\n\t\tgoto flush;\n\t}\n\n\tskb_put_u8(*skb, len);\n\n\tr = i2c_master_recv(client, skb_put(*skb, len), len);\n\tif (r != len) {\n\t\tkfree_skb(*skb);\n\t\treturn -EREMOTEIO;\n\t}\n\n\tI2C_DUMP_SKB(\"i2c frame read\", *skb);\n\n\tr = check_crc((*skb)->data, (*skb)->len);\n\tif (r != 0) {\n\t\tkfree_skb(*skb);\n\t\tr = -EBADMSG;\n\t\tgoto flush;\n\t}\n\n\tskb_pull(*skb, 1);\n\tskb_trim(*skb, (*skb)->len - 2);\n\n\tusleep_range(3000, 6000);\n\n\treturn 0;\n\nflush:\n\tif (i2c_master_recv(client, tmp, sizeof(tmp)) < 0)\n\t\tr = -EREMOTEIO;\n\n\tusleep_range(3000, 6000);\n\n\treturn r;\n}\n\nstatic int pn544_hci_i2c_fw_read_status(struct pn544_i2c_phy *phy)\n{\n\tint r;\n\tstruct pn544_i2c_fw_frame_response response;\n\tstruct i2c_client *client = phy->i2c_dev;\n\n\tr = i2c_master_recv(client, (char *) &response, sizeof(response));\n\tif (r != sizeof(response)) {\n\t\tnfc_err(&client->dev, \"cannot read fw status\\n\");\n\t\treturn -EIO;\n\t}\n\n\tusleep_range(3000, 6000);\n\n\tswitch (response.status) {\n\tcase 0:\n\t\treturn 0;\n\tcase PN544_FW_CMD_RESULT_CHUNK_OK:\n\t\treturn response.status;\n\tcase PN544_FW_CMD_RESULT_TIMEOUT:\n\t\treturn -ETIMEDOUT;\n\tcase PN544_FW_CMD_RESULT_BAD_CRC:\n\t\treturn -ENODATA;\n\tcase PN544_FW_CMD_RESULT_ACCESS_DENIED:\n\t\treturn -EACCES;\n\tcase PN544_FW_CMD_RESULT_PROTOCOL_ERROR:\n\t\treturn -EPROTO;\n\tcase PN544_FW_CMD_RESULT_INVALID_PARAMETER:\n\t\treturn -EINVAL;\n\tcase PN544_FW_CMD_RESULT_UNSUPPORTED_COMMAND:\n\t\treturn -ENOTSUPP;\n\tcase PN544_FW_CMD_RESULT_INVALID_LENGTH:\n\t\treturn -EBADMSG;\n\tcase PN544_FW_CMD_RESULT_CRYPTOGRAPHIC_ERROR:\n\t\treturn -ENOKEY;\n\tcase PN544_FW_CMD_RESULT_VERSION_CONDITIONS_ERROR:\n\t\treturn -EINVAL;\n\tcase PN544_FW_CMD_RESULT_MEMORY_ERROR:\n\t\treturn -ENOMEM;\n\tcase PN544_FW_CMD_RESULT_COMMAND_REJECTED:\n\t\treturn -EACCES;\n\tcase PN544_FW_CMD_RESULT_WRITE_FAILED:\n\tcase PN544_FW_CMD_RESULT_CHUNK_ERROR:\n\t\treturn -EIO;\n\tdefault:\n\t\treturn -EIO;\n\t}\n}\n\n \nstatic irqreturn_t pn544_hci_i2c_irq_thread_fn(int irq, void *phy_id)\n{\n\tstruct pn544_i2c_phy *phy = phy_id;\n\tstruct i2c_client *client;\n\tstruct sk_buff *skb = NULL;\n\tint r;\n\n\tif (!phy || irq != phy->i2c_dev->irq) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn IRQ_NONE;\n\t}\n\n\tclient = phy->i2c_dev;\n\tdev_dbg(&client->dev, \"IRQ\\n\");\n\n\tif (phy->hard_fault != 0)\n\t\treturn IRQ_HANDLED;\n\n\tif (phy->run_mode == PN544_FW_MODE) {\n\t\tphy->fw_cmd_result = pn544_hci_i2c_fw_read_status(phy);\n\t\tschedule_work(&phy->fw_work);\n\t} else {\n\t\tr = pn544_hci_i2c_read(phy, &skb);\n\t\tif (r == -EREMOTEIO) {\n\t\t\tphy->hard_fault = r;\n\n\t\t\tnfc_hci_recv_frame(phy->hdev, NULL);\n\n\t\t\treturn IRQ_HANDLED;\n\t\t} else if ((r == -ENOMEM) || (r == -EBADMSG)) {\n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\n\t\tnfc_hci_recv_frame(phy->hdev, skb);\n\t}\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct nfc_phy_ops i2c_phy_ops = {\n\t.write = pn544_hci_i2c_write,\n\t.enable = pn544_hci_i2c_enable,\n\t.disable = pn544_hci_i2c_disable,\n};\n\nstatic int pn544_hci_i2c_fw_download(void *phy_id, const char *firmware_name,\n\t\t\t\t\tu8 hw_variant)\n{\n\tstruct pn544_i2c_phy *phy = phy_id;\n\n\tpr_info(\"Starting Firmware Download (%s)\\n\", firmware_name);\n\n\tstrcpy(phy->firmware_name, firmware_name);\n\n\tphy->hw_variant = hw_variant;\n\tphy->fw_work_state = FW_WORK_STATE_START;\n\n\tschedule_work(&phy->fw_work);\n\n\treturn 0;\n}\n\nstatic void pn544_hci_i2c_fw_work_complete(struct pn544_i2c_phy *phy,\n\t\t\t\t\t   int result)\n{\n\tpr_info(\"Firmware Download Complete, result=%d\\n\", result);\n\n\tpn544_hci_i2c_disable(phy);\n\n\tphy->fw_work_state = FW_WORK_STATE_IDLE;\n\n\tif (phy->fw) {\n\t\trelease_firmware(phy->fw);\n\t\tphy->fw = NULL;\n\t}\n\n\tnfc_fw_download_done(phy->hdev->ndev, phy->firmware_name, (u32) -result);\n}\n\nstatic int pn544_hci_i2c_fw_write_cmd(struct i2c_client *client, u32 dest_addr,\n\t\t\t\t      const u8 *data, u16 datalen)\n{\n\tu8 frame[PN544_FW_I2C_MAX_PAYLOAD];\n\tstruct pn544_i2c_fw_frame_write *framep;\n\tu16 params_len;\n\tint framelen;\n\tint r;\n\n\tif (datalen > PN544_FW_I2C_WRITE_DATA_MAX_LEN)\n\t\tdatalen = PN544_FW_I2C_WRITE_DATA_MAX_LEN;\n\n\tframep = (struct pn544_i2c_fw_frame_write *) frame;\n\n\tparams_len = sizeof(framep->be_dest_addr) +\n\t\t     sizeof(framep->be_datalen) + datalen;\n\tframelen = params_len + sizeof(framep->cmd) +\n\t\t\t     sizeof(framep->be_length);\n\n\tframep->cmd = PN544_FW_CMD_WRITE;\n\n\tput_unaligned_be16(params_len, &framep->be_length);\n\n\tframep->be_dest_addr[0] = (dest_addr & 0xff0000) >> 16;\n\tframep->be_dest_addr[1] = (dest_addr & 0xff00) >> 8;\n\tframep->be_dest_addr[2] = dest_addr & 0xff;\n\n\tput_unaligned_be16(datalen, &framep->be_datalen);\n\n\tmemcpy(framep->data, data, datalen);\n\n\tr = i2c_master_send(client, frame, framelen);\n\n\tif (r == framelen)\n\t\treturn datalen;\n\telse if (r < 0)\n\t\treturn r;\n\telse\n\t\treturn -EIO;\n}\n\nstatic int pn544_hci_i2c_fw_check_cmd(struct i2c_client *client, u32 start_addr,\n\t\t\t\t      const u8 *data, u16 datalen)\n{\n\tstruct pn544_i2c_fw_frame_check frame;\n\tint r;\n\tu16 crc;\n\n\t \n\tcrc = crc_ccitt(0xffff, data, datalen);\n\n\tframe.cmd = PN544_FW_CMD_CHECK;\n\n\tput_unaligned_be16(sizeof(frame.be_start_addr) +\n\t\t\t   sizeof(frame.be_datalen) + sizeof(frame.be_crc),\n\t\t\t   &frame.be_length);\n\n\t \n\tframe.be_start_addr[0] = (start_addr & 0xff0000) >> 16;\n\tframe.be_start_addr[1] = (start_addr & 0xff00) >> 8;\n\tframe.be_start_addr[2] = start_addr & 0xff;\n\n\tput_unaligned_be16(datalen, &frame.be_datalen);\n\n\t \n\tput_unaligned_be16(crc, &frame.be_crc);\n\n\tr = i2c_master_send(client, (const char *) &frame, sizeof(frame));\n\n\tif (r == sizeof(frame))\n\t\treturn 0;\n\telse if (r < 0)\n\t\treturn r;\n\telse\n\t\treturn -EIO;\n}\n\nstatic int pn544_hci_i2c_fw_write_chunk(struct pn544_i2c_phy *phy)\n{\n\tint r;\n\n\tr = pn544_hci_i2c_fw_write_cmd(phy->i2c_dev,\n\t\t\t\t       phy->fw_blob_dest_addr + phy->fw_written,\n\t\t\t\t       phy->fw_blob_data + phy->fw_written,\n\t\t\t\t       phy->fw_blob_size - phy->fw_written);\n\tif (r < 0)\n\t\treturn r;\n\n\tphy->fw_written += r;\n\tphy->fw_work_state = FW_WORK_STATE_WAIT_WRITE_ANSWER;\n\n\treturn 0;\n}\n\nstatic int pn544_hci_i2c_fw_secure_write_frame_cmd(struct pn544_i2c_phy *phy,\n\t\t\t\t\tconst u8 *data, u16 datalen)\n{\n\tu8 buf[PN544_FW_I2C_MAX_PAYLOAD];\n\tstruct pn544_i2c_fw_secure_frame *chunk;\n\tint chunklen;\n\tint r;\n\n\tif (datalen > PN544_FW_SECURE_CHUNK_WRITE_DATA_MAX_LEN)\n\t\tdatalen = PN544_FW_SECURE_CHUNK_WRITE_DATA_MAX_LEN;\n\n\tchunk = (struct pn544_i2c_fw_secure_frame *) buf;\n\n\tchunk->cmd = PN544_FW_CMD_SECURE_CHUNK_WRITE;\n\n\tput_unaligned_be16(datalen, &chunk->be_datalen);\n\n\tmemcpy(chunk->data, data, datalen);\n\n\tchunklen = sizeof(chunk->cmd) + sizeof(chunk->be_datalen) + datalen;\n\n\tr = i2c_master_send(phy->i2c_dev, buf, chunklen);\n\n\tif (r == chunklen)\n\t\treturn datalen;\n\telse if (r < 0)\n\t\treturn r;\n\telse\n\t\treturn -EIO;\n\n}\n\nstatic int pn544_hci_i2c_fw_secure_write_frame(struct pn544_i2c_phy *phy)\n{\n\tstruct pn544_i2c_fw_secure_frame *framep;\n\tint r;\n\n\tframep = (struct pn544_i2c_fw_secure_frame *) phy->fw_blob_data;\n\tif (phy->fw_written == 0)\n\t\tphy->fw_blob_size = get_unaligned_be16(&framep->be_datalen)\n\t\t\t\t+ PN544_FW_SECURE_FRAME_HEADER_LEN;\n\n\t \n\tif (phy->fw_blob_size > PN544_FW_I2C_MAX_PAYLOAD &&\n\t\t\tframep->cmd != PN544_FW_CMD_SECURE_WRITE)\n\t\treturn -EINVAL;\n\n\t \n\tif (phy->fw_blob_size < PN544_FW_I2C_MAX_PAYLOAD) {\n\t\tr = i2c_master_send(phy->i2c_dev,\n\t\t\t(const char *) phy->fw_blob_data, phy->fw_blob_size);\n\n\t\tif (r == phy->fw_blob_size)\n\t\t\tgoto exit;\n\t\telse if (r < 0)\n\t\t\treturn r;\n\t\telse\n\t\t\treturn -EIO;\n\t}\n\n\tr = pn544_hci_i2c_fw_secure_write_frame_cmd(phy,\n\t\t\t\t       phy->fw_blob_data + phy->fw_written,\n\t\t\t\t       phy->fw_blob_size - phy->fw_written);\n\tif (r < 0)\n\t\treturn r;\n\nexit:\n\tphy->fw_written += r;\n\tphy->fw_work_state = FW_WORK_STATE_WAIT_SECURE_WRITE_ANSWER;\n\n\t \n\tif (framep->cmd == PN544_FW_CMD_RESET) {\n\t\tpn544_hci_i2c_enable_mode(phy, PN544_FW_MODE);\n\t\tphy->fw_cmd_result = 0;\n\t\tschedule_work(&phy->fw_work);\n\t}\n\n\treturn 0;\n}\n\nstatic void pn544_hci_i2c_fw_work(struct work_struct *work)\n{\n\tstruct pn544_i2c_phy *phy = container_of(work, struct pn544_i2c_phy,\n\t\t\t\t\t\tfw_work);\n\tint r;\n\tstruct pn544_i2c_fw_blob *blob;\n\tstruct pn544_i2c_fw_secure_blob *secure_blob;\n\n\tswitch (phy->fw_work_state) {\n\tcase FW_WORK_STATE_START:\n\t\tpn544_hci_i2c_enable_mode(phy, PN544_FW_MODE);\n\n\t\tr = request_firmware(&phy->fw, phy->firmware_name,\n\t\t\t\t     &phy->i2c_dev->dev);\n\t\tif (r < 0)\n\t\t\tgoto exit_state_start;\n\n\t\tphy->fw_written = 0;\n\n\t\tswitch (phy->hw_variant) {\n\t\tcase PN544_HW_VARIANT_C2:\n\t\t\tblob = (struct pn544_i2c_fw_blob *) phy->fw->data;\n\t\t\tphy->fw_blob_size = get_unaligned_be32(&blob->be_size);\n\t\t\tphy->fw_blob_dest_addr = get_unaligned_be32(\n\t\t\t\t\t\t\t&blob->be_destaddr);\n\t\t\tphy->fw_blob_data = blob->data;\n\n\t\t\tr = pn544_hci_i2c_fw_write_chunk(phy);\n\t\t\tbreak;\n\t\tcase PN544_HW_VARIANT_C3:\n\t\t\tsecure_blob = (struct pn544_i2c_fw_secure_blob *)\n\t\t\t\t\t\t\t\tphy->fw->data;\n\t\t\tphy->fw_blob_data = secure_blob->data;\n\t\t\tphy->fw_size = phy->fw->size;\n\t\t\tr = pn544_hci_i2c_fw_secure_write_frame(phy);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr = -ENOTSUPP;\n\t\t\tbreak;\n\t\t}\n\nexit_state_start:\n\t\tif (r < 0)\n\t\t\tpn544_hci_i2c_fw_work_complete(phy, r);\n\t\tbreak;\n\n\tcase FW_WORK_STATE_WAIT_WRITE_ANSWER:\n\t\tr = phy->fw_cmd_result;\n\t\tif (r < 0)\n\t\t\tgoto exit_state_wait_write_answer;\n\n\t\tif (phy->fw_written == phy->fw_blob_size) {\n\t\t\tr = pn544_hci_i2c_fw_check_cmd(phy->i2c_dev,\n\t\t\t\t\t\t       phy->fw_blob_dest_addr,\n\t\t\t\t\t\t       phy->fw_blob_data,\n\t\t\t\t\t\t       phy->fw_blob_size);\n\t\t\tif (r < 0)\n\t\t\t\tgoto exit_state_wait_write_answer;\n\t\t\tphy->fw_work_state = FW_WORK_STATE_WAIT_CHECK_ANSWER;\n\t\t\tbreak;\n\t\t}\n\n\t\tr = pn544_hci_i2c_fw_write_chunk(phy);\n\nexit_state_wait_write_answer:\n\t\tif (r < 0)\n\t\t\tpn544_hci_i2c_fw_work_complete(phy, r);\n\t\tbreak;\n\n\tcase FW_WORK_STATE_WAIT_CHECK_ANSWER:\n\t\tr = phy->fw_cmd_result;\n\t\tif (r < 0)\n\t\t\tgoto exit_state_wait_check_answer;\n\n\t\tblob = (struct pn544_i2c_fw_blob *) (phy->fw_blob_data +\n\t\t       phy->fw_blob_size);\n\t\tphy->fw_blob_size = get_unaligned_be32(&blob->be_size);\n\t\tif (phy->fw_blob_size != 0) {\n\t\t\tphy->fw_blob_dest_addr =\n\t\t\t\t\tget_unaligned_be32(&blob->be_destaddr);\n\t\t\tphy->fw_blob_data = blob->data;\n\n\t\t\tphy->fw_written = 0;\n\t\t\tr = pn544_hci_i2c_fw_write_chunk(phy);\n\t\t}\n\nexit_state_wait_check_answer:\n\t\tif (r < 0 || phy->fw_blob_size == 0)\n\t\t\tpn544_hci_i2c_fw_work_complete(phy, r);\n\t\tbreak;\n\n\tcase FW_WORK_STATE_WAIT_SECURE_WRITE_ANSWER:\n\t\tr = phy->fw_cmd_result;\n\t\tif (r < 0)\n\t\t\tgoto exit_state_wait_secure_write_answer;\n\n\t\tif (r == PN544_FW_CMD_RESULT_CHUNK_OK) {\n\t\t\tr = pn544_hci_i2c_fw_secure_write_frame(phy);\n\t\t\tgoto exit_state_wait_secure_write_answer;\n\t\t}\n\n\t\tif (phy->fw_written == phy->fw_blob_size) {\n\t\t\tsecure_blob = (struct pn544_i2c_fw_secure_blob *)\n\t\t\t\t(phy->fw_blob_data + phy->fw_blob_size);\n\t\t\tphy->fw_size -= phy->fw_blob_size +\n\t\t\t\tPN544_FW_SECURE_BLOB_HEADER_LEN;\n\t\t\tif (phy->fw_size >= PN544_FW_SECURE_BLOB_HEADER_LEN\n\t\t\t\t\t+ PN544_FW_SECURE_FRAME_HEADER_LEN) {\n\t\t\t\tphy->fw_blob_data = secure_blob->data;\n\n\t\t\t\tphy->fw_written = 0;\n\t\t\t\tr = pn544_hci_i2c_fw_secure_write_frame(phy);\n\t\t\t}\n\t\t}\n\nexit_state_wait_secure_write_answer:\n\t\tif (r < 0 || phy->fw_size == 0)\n\t\t\tpn544_hci_i2c_fw_work_complete(phy, r);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic const struct acpi_gpio_params enable_gpios = { 1, 0, false };\nstatic const struct acpi_gpio_params firmware_gpios = { 2, 0, false };\n\nstatic const struct acpi_gpio_mapping acpi_pn544_gpios[] = {\n\t{ \"enable-gpios\", &enable_gpios, 1 },\n\t{ \"firmware-gpios\", &firmware_gpios, 1 },\n\t{ },\n};\n\nstatic int pn544_hci_i2c_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct pn544_i2c_phy *phy;\n\tint r = 0;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\n\t\tnfc_err(&client->dev, \"Need I2C_FUNC_I2C\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tphy = devm_kzalloc(&client->dev, sizeof(struct pn544_i2c_phy),\n\t\t\t   GFP_KERNEL);\n\tif (!phy)\n\t\treturn -ENOMEM;\n\n\tINIT_WORK(&phy->fw_work, pn544_hci_i2c_fw_work);\n\tphy->fw_work_state = FW_WORK_STATE_IDLE;\n\n\tphy->i2c_dev = client;\n\ti2c_set_clientdata(client, phy);\n\n\tr = devm_acpi_dev_add_driver_gpios(dev, acpi_pn544_gpios);\n\tif (r)\n\t\tdev_dbg(dev, \"Unable to add GPIO mapping table\\n\");\n\n\t \n\tphy->gpiod_en = devm_gpiod_get(dev, \"enable\", GPIOD_OUT_LOW);\n\tif (IS_ERR(phy->gpiod_en)) {\n\t\tnfc_err(dev, \"Unable to get EN GPIO\\n\");\n\t\treturn PTR_ERR(phy->gpiod_en);\n\t}\n\n\t \n\tphy->gpiod_fw = devm_gpiod_get(dev, \"firmware\", GPIOD_OUT_LOW);\n\tif (IS_ERR(phy->gpiod_fw)) {\n\t\tnfc_err(dev, \"Unable to get FW GPIO\\n\");\n\t\treturn PTR_ERR(phy->gpiod_fw);\n\t}\n\n\tpn544_hci_i2c_platform_init(phy);\n\n\tr = devm_request_threaded_irq(&client->dev, client->irq, NULL,\n\t\t\t\t      pn544_hci_i2c_irq_thread_fn,\n\t\t\t\t      IRQF_TRIGGER_RISING | IRQF_ONESHOT,\n\t\t\t\t      PN544_HCI_I2C_DRIVER_NAME, phy);\n\tif (r < 0) {\n\t\tnfc_err(&client->dev, \"Unable to register IRQ handler\\n\");\n\t\treturn r;\n\t}\n\n\tr = pn544_hci_probe(phy, &i2c_phy_ops, LLC_SHDLC_NAME,\n\t\t\t    PN544_I2C_FRAME_HEADROOM, PN544_I2C_FRAME_TAILROOM,\n\t\t\t    PN544_HCI_I2C_LLC_MAX_PAYLOAD,\n\t\t\t    pn544_hci_i2c_fw_download, &phy->hdev);\n\tif (r < 0)\n\t\treturn r;\n\n\treturn 0;\n}\n\nstatic void pn544_hci_i2c_remove(struct i2c_client *client)\n{\n\tstruct pn544_i2c_phy *phy = i2c_get_clientdata(client);\n\n\tcancel_work_sync(&phy->fw_work);\n\tif (phy->fw_work_state != FW_WORK_STATE_IDLE)\n\t\tpn544_hci_i2c_fw_work_complete(phy, -ENODEV);\n\n\tpn544_hci_remove(phy->hdev);\n\n\tif (phy->powered)\n\t\tpn544_hci_i2c_disable(phy);\n}\n\nstatic const struct of_device_id of_pn544_i2c_match[] __maybe_unused = {\n\t{ .compatible = \"nxp,pn544-i2c\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, of_pn544_i2c_match);\n\nstatic struct i2c_driver pn544_hci_i2c_driver = {\n\t.driver = {\n\t\t   .name = PN544_HCI_I2C_DRIVER_NAME,\n\t\t   .of_match_table = of_match_ptr(of_pn544_i2c_match),\n\t\t   .acpi_match_table = ACPI_PTR(pn544_hci_i2c_acpi_match),\n\t\t  },\n\t.probe = pn544_hci_i2c_probe,\n\t.id_table = pn544_hci_i2c_id_table,\n\t.remove = pn544_hci_i2c_remove,\n};\n\nmodule_i2c_driver(pn544_hci_i2c_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(DRIVER_DESC);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}