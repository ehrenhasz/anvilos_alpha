{
  "module_name": "ti-ecap-capture.c",
  "hash_id": "aa0009a957b5a5133012f44d6f2826b8e72493619fe6f7023613dd298d44564c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/counter/ti-ecap-capture.c",
  "human_readable_source": "\n \n\n#include <linux/atomic.h>\n#include <linux/clk.h>\n#include <linux/counter.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/mutex.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n\n#define ECAP_DRV_NAME \"ecap\"\n\n \n#define ECAP_CEVT1\t\t0\n#define ECAP_CEVT2\t\t1\n#define ECAP_CEVT3\t\t2\n#define ECAP_CEVT4\t\t3\n#define ECAP_CNTOVF\t\t4\n\n#define ECAP_CEVT_LAST\t\tECAP_CEVT4\n#define ECAP_NB_CEVT\t\t(ECAP_CEVT_LAST + 1)\n\n#define ECAP_EVT_LAST\t\tECAP_CNTOVF\n#define ECAP_NB_EVT\t\t(ECAP_EVT_LAST + 1)\n\n \n#define ECAP_TSCNT_REG\t\t\t0x00\n\n#define ECAP_CAP_REG(i)\t\t(((i) << 2) + 0x08)\n\n#define ECAP_ECCTL_REG\t\t\t0x28\n#define ECAP_CAPPOL_BIT(i)\t\tBIT((i) << 1)\n#define ECAP_EV_MODE_MASK\t\tGENMASK(7, 0)\n#define ECAP_CAPLDEN_BIT\t\tBIT(8)\n#define ECAP_CONT_ONESHT_BIT\t\tBIT(16)\n#define ECAP_STOPVALUE_MASK\t\tGENMASK(18, 17)\n#define ECAP_TSCNTSTP_BIT\t\tBIT(20)\n#define ECAP_SYNCO_DIS_MASK\t\tGENMASK(23, 22)\n#define ECAP_CAP_APWM_BIT\t\tBIT(25)\n#define ECAP_ECCTL_EN_MASK\t\t(ECAP_CAPLDEN_BIT | ECAP_TSCNTSTP_BIT)\n#define ECAP_ECCTL_CFG_MASK\t\t(ECAP_SYNCO_DIS_MASK | ECAP_STOPVALUE_MASK\t\\\n\t\t\t\t\t| ECAP_ECCTL_EN_MASK | ECAP_CAP_APWM_BIT\t\\\n\t\t\t\t\t| ECAP_CONT_ONESHT_BIT)\n\n#define ECAP_ECINT_EN_FLG_REG\t\t0x2c\n#define ECAP_EVT_EN_MASK\t\tGENMASK(ECAP_NB_EVT, ECAP_NB_CEVT)\n#define ECAP_EVT_FLG_BIT(i)\t\tBIT((i) + 17)\n\n#define ECAP_ECINT_CLR_FRC_REG\t0x30\n#define ECAP_INT_CLR_BIT\t\tBIT(0)\n#define ECAP_EVT_CLR_BIT(i)\t\tBIT((i) + 1)\n#define ECAP_EVT_CLR_MASK\t\tGENMASK(ECAP_NB_EVT, 0)\n\n#define ECAP_PID_REG\t\t\t0x5c\n\n \n#define ECAP_CLOCK_SIG 0\n#define ECAP_INPUT_SIG 1\n\nstatic const struct regmap_config ecap_cnt_regmap_config = {\n\t.reg_bits = 32,\n\t.reg_stride = 4,\n\t.val_bits = 32,\n\t.max_register = ECAP_PID_REG,\n};\n\n \nstruct ecap_cnt_dev {\n\tbool enabled;\n\tstruct mutex lock;\n\tstruct clk *clk;\n\tstruct regmap *regmap;\n\tatomic_t nb_ovf;\n\tstruct {\n\t\tu8 ev_mode;\n\t\tu32 time_cntr;\n\t} pm_ctx;\n};\n\nstatic u8 ecap_cnt_capture_get_evmode(struct counter_device *counter)\n{\n\tstruct ecap_cnt_dev *ecap_dev = counter_priv(counter);\n\tunsigned int regval;\n\n\tpm_runtime_get_sync(counter->parent);\n\tregmap_read(ecap_dev->regmap, ECAP_ECCTL_REG, &regval);\n\tpm_runtime_put_sync(counter->parent);\n\n\treturn regval;\n}\n\nstatic void ecap_cnt_capture_set_evmode(struct counter_device *counter, u8 ev_mode)\n{\n\tstruct ecap_cnt_dev *ecap_dev = counter_priv(counter);\n\n\tpm_runtime_get_sync(counter->parent);\n\tregmap_update_bits(ecap_dev->regmap, ECAP_ECCTL_REG, ECAP_EV_MODE_MASK, ev_mode);\n\tpm_runtime_put_sync(counter->parent);\n}\n\nstatic void ecap_cnt_capture_enable(struct counter_device *counter)\n{\n\tstruct ecap_cnt_dev *ecap_dev = counter_priv(counter);\n\n\tpm_runtime_get_sync(counter->parent);\n\n\t \n\tregmap_update_bits(ecap_dev->regmap, ECAP_ECINT_EN_FLG_REG,\n\t\t\t   ECAP_EVT_EN_MASK, ECAP_EVT_EN_MASK);\n\n\t \n\tregmap_update_bits(ecap_dev->regmap, ECAP_ECCTL_REG, ECAP_ECCTL_CFG_MASK,\n\t\t\t   ECAP_SYNCO_DIS_MASK | ECAP_STOPVALUE_MASK | ECAP_ECCTL_EN_MASK);\n}\n\nstatic void ecap_cnt_capture_disable(struct counter_device *counter)\n{\n\tstruct ecap_cnt_dev *ecap_dev = counter_priv(counter);\n\n\t \n\tregmap_update_bits(ecap_dev->regmap, ECAP_ECCTL_REG, ECAP_ECCTL_EN_MASK, 0);\n\n\t \n\tregmap_update_bits(ecap_dev->regmap, ECAP_ECINT_EN_FLG_REG, ECAP_EVT_EN_MASK, 0);\n\n\tpm_runtime_put_sync(counter->parent);\n}\n\nstatic u32 ecap_cnt_count_get_val(struct counter_device *counter, unsigned int reg)\n{\n\tstruct ecap_cnt_dev *ecap_dev = counter_priv(counter);\n\tunsigned int regval;\n\n\tpm_runtime_get_sync(counter->parent);\n\tregmap_read(ecap_dev->regmap, reg, &regval);\n\tpm_runtime_put_sync(counter->parent);\n\n\treturn regval;\n}\n\nstatic void ecap_cnt_count_set_val(struct counter_device *counter, unsigned int reg, u32 val)\n{\n\tstruct ecap_cnt_dev *ecap_dev = counter_priv(counter);\n\n\tpm_runtime_get_sync(counter->parent);\n\tregmap_write(ecap_dev->regmap, reg, val);\n\tpm_runtime_put_sync(counter->parent);\n}\n\nstatic int ecap_cnt_count_read(struct counter_device *counter,\n\t\t\t       struct counter_count *count, u64 *val)\n{\n\t*val = ecap_cnt_count_get_val(counter, ECAP_TSCNT_REG);\n\n\treturn 0;\n}\n\nstatic int ecap_cnt_count_write(struct counter_device *counter,\n\t\t\t\tstruct counter_count *count, u64 val)\n{\n\tif (val > U32_MAX)\n\t\treturn -ERANGE;\n\n\tecap_cnt_count_set_val(counter, ECAP_TSCNT_REG, val);\n\n\treturn 0;\n}\n\nstatic int ecap_cnt_function_read(struct counter_device *counter,\n\t\t\t\t  struct counter_count *count,\n\t\t\t\t  enum counter_function *function)\n{\n\t*function = COUNTER_FUNCTION_INCREASE;\n\n\treturn 0;\n}\n\nstatic int ecap_cnt_action_read(struct counter_device *counter,\n\t\t\t\tstruct counter_count *count,\n\t\t\t\tstruct counter_synapse *synapse,\n\t\t\t\tenum counter_synapse_action *action)\n{\n\t*action = (synapse->signal->id == ECAP_CLOCK_SIG) ?\n\t\t   COUNTER_SYNAPSE_ACTION_RISING_EDGE :\n\t\t   COUNTER_SYNAPSE_ACTION_NONE;\n\n\treturn 0;\n}\n\nstatic int ecap_cnt_watch_validate(struct counter_device *counter,\n\t\t\t\t   const struct counter_watch *watch)\n{\n\tif (watch->channel > ECAP_CEVT_LAST)\n\t\treturn -EINVAL;\n\n\tswitch (watch->event) {\n\tcase COUNTER_EVENT_CAPTURE:\n\tcase COUNTER_EVENT_OVERFLOW:\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ecap_cnt_clk_get_freq(struct counter_device *counter,\n\t\t\t\t struct counter_signal *signal, u64 *freq)\n{\n\tstruct ecap_cnt_dev *ecap_dev = counter_priv(counter);\n\n\t*freq = clk_get_rate(ecap_dev->clk);\n\n\treturn 0;\n}\n\nstatic int ecap_cnt_pol_read(struct counter_device *counter,\n\t\t\t     struct counter_signal *signal,\n\t\t\t     size_t idx, enum counter_signal_polarity *pol)\n{\n\tstruct ecap_cnt_dev *ecap_dev = counter_priv(counter);\n\tint bitval;\n\n\tpm_runtime_get_sync(counter->parent);\n\tbitval = regmap_test_bits(ecap_dev->regmap, ECAP_ECCTL_REG, ECAP_CAPPOL_BIT(idx));\n\tpm_runtime_put_sync(counter->parent);\n\n\t*pol = bitval ? COUNTER_SIGNAL_POLARITY_NEGATIVE : COUNTER_SIGNAL_POLARITY_POSITIVE;\n\n\treturn 0;\n}\n\nstatic int ecap_cnt_pol_write(struct counter_device *counter,\n\t\t\t      struct counter_signal *signal,\n\t\t\t      size_t idx, enum counter_signal_polarity pol)\n{\n\tstruct ecap_cnt_dev *ecap_dev = counter_priv(counter);\n\n\tpm_runtime_get_sync(counter->parent);\n\tif (pol == COUNTER_SIGNAL_POLARITY_NEGATIVE)\n\t\tregmap_set_bits(ecap_dev->regmap, ECAP_ECCTL_REG, ECAP_CAPPOL_BIT(idx));\n\telse\n\t\tregmap_clear_bits(ecap_dev->regmap, ECAP_ECCTL_REG, ECAP_CAPPOL_BIT(idx));\n\tpm_runtime_put_sync(counter->parent);\n\n\treturn 0;\n}\n\nstatic int ecap_cnt_cap_read(struct counter_device *counter,\n\t\t\t     struct counter_count *count,\n\t\t\t     size_t idx, u64 *cap)\n{\n\t*cap = ecap_cnt_count_get_val(counter, ECAP_CAP_REG(idx));\n\n\treturn 0;\n}\n\nstatic int ecap_cnt_cap_write(struct counter_device *counter,\n\t\t\t      struct counter_count *count,\n\t\t\t      size_t idx, u64 cap)\n{\n\tif (cap > U32_MAX)\n\t\treturn -ERANGE;\n\n\tecap_cnt_count_set_val(counter, ECAP_CAP_REG(idx), cap);\n\n\treturn 0;\n}\n\nstatic int ecap_cnt_nb_ovf_read(struct counter_device *counter,\n\t\t\t\tstruct counter_count *count, u64 *val)\n{\n\tstruct ecap_cnt_dev *ecap_dev = counter_priv(counter);\n\n\t*val = atomic_read(&ecap_dev->nb_ovf);\n\n\treturn 0;\n}\n\nstatic int ecap_cnt_nb_ovf_write(struct counter_device *counter,\n\t\t\t\t struct counter_count *count, u64 val)\n{\n\tstruct ecap_cnt_dev *ecap_dev = counter_priv(counter);\n\n\tif (val > U32_MAX)\n\t\treturn -ERANGE;\n\n\tatomic_set(&ecap_dev->nb_ovf, val);\n\n\treturn 0;\n}\n\nstatic int ecap_cnt_ceiling_read(struct counter_device *counter,\n\t\t\t\t struct counter_count *count, u64 *val)\n{\n\t*val = U32_MAX;\n\n\treturn 0;\n}\n\nstatic int ecap_cnt_enable_read(struct counter_device *counter,\n\t\t\t\tstruct counter_count *count, u8 *enable)\n{\n\tstruct ecap_cnt_dev *ecap_dev = counter_priv(counter);\n\n\t*enable = ecap_dev->enabled;\n\n\treturn 0;\n}\n\nstatic int ecap_cnt_enable_write(struct counter_device *counter,\n\t\t\t\t struct counter_count *count, u8 enable)\n{\n\tstruct ecap_cnt_dev *ecap_dev = counter_priv(counter);\n\n\tmutex_lock(&ecap_dev->lock);\n\n\tif (enable == ecap_dev->enabled)\n\t\tgoto out;\n\n\tif (enable)\n\t\tecap_cnt_capture_enable(counter);\n\telse\n\t\tecap_cnt_capture_disable(counter);\n\tecap_dev->enabled = enable;\n\nout:\n\tmutex_unlock(&ecap_dev->lock);\n\n\treturn 0;\n}\n\nstatic const struct counter_ops ecap_cnt_ops = {\n\t.count_read = ecap_cnt_count_read,\n\t.count_write = ecap_cnt_count_write,\n\t.function_read = ecap_cnt_function_read,\n\t.action_read = ecap_cnt_action_read,\n\t.watch_validate = ecap_cnt_watch_validate,\n};\n\nstatic const enum counter_function ecap_cnt_functions[] = {\n\tCOUNTER_FUNCTION_INCREASE,\n};\n\nstatic const enum counter_synapse_action ecap_cnt_clock_actions[] = {\n\tCOUNTER_SYNAPSE_ACTION_RISING_EDGE,\n};\n\nstatic const enum counter_synapse_action ecap_cnt_input_actions[] = {\n\tCOUNTER_SYNAPSE_ACTION_NONE,\n};\n\nstatic struct counter_comp ecap_cnt_clock_ext[] = {\n\tCOUNTER_COMP_SIGNAL_U64(\"frequency\", ecap_cnt_clk_get_freq, NULL),\n};\n\nstatic const enum counter_signal_polarity ecap_cnt_pol_avail[] = {\n\tCOUNTER_SIGNAL_POLARITY_POSITIVE,\n\tCOUNTER_SIGNAL_POLARITY_NEGATIVE,\n};\n\nstatic DEFINE_COUNTER_AVAILABLE(ecap_cnt_pol_available, ecap_cnt_pol_avail);\nstatic DEFINE_COUNTER_ARRAY_POLARITY(ecap_cnt_pol_array, ecap_cnt_pol_available, ECAP_NB_CEVT);\n\nstatic struct counter_comp ecap_cnt_signal_ext[] = {\n\tCOUNTER_COMP_ARRAY_POLARITY(ecap_cnt_pol_read, ecap_cnt_pol_write, ecap_cnt_pol_array),\n};\n\nstatic struct counter_signal ecap_cnt_signals[] = {\n\t{\n\t\t.id = ECAP_CLOCK_SIG,\n\t\t.name = \"Clock Signal\",\n\t\t.ext = ecap_cnt_clock_ext,\n\t\t.num_ext = ARRAY_SIZE(ecap_cnt_clock_ext),\n\t},\n\t{\n\t\t.id = ECAP_INPUT_SIG,\n\t\t.name = \"Input Signal\",\n\t\t.ext = ecap_cnt_signal_ext,\n\t\t.num_ext = ARRAY_SIZE(ecap_cnt_signal_ext),\n\t},\n};\n\nstatic struct counter_synapse ecap_cnt_synapses[] = {\n\t{\n\t\t.actions_list = ecap_cnt_clock_actions,\n\t\t.num_actions = ARRAY_SIZE(ecap_cnt_clock_actions),\n\t\t.signal = &ecap_cnt_signals[ECAP_CLOCK_SIG],\n\t},\n\t{\n\t\t.actions_list = ecap_cnt_input_actions,\n\t\t.num_actions = ARRAY_SIZE(ecap_cnt_input_actions),\n\t\t.signal = &ecap_cnt_signals[ECAP_INPUT_SIG],\n\t},\n};\n\nstatic DEFINE_COUNTER_ARRAY_CAPTURE(ecap_cnt_cap_array, ECAP_NB_CEVT);\n\nstatic struct counter_comp ecap_cnt_count_ext[] = {\n\tCOUNTER_COMP_ARRAY_CAPTURE(ecap_cnt_cap_read, ecap_cnt_cap_write, ecap_cnt_cap_array),\n\tCOUNTER_COMP_COUNT_U64(\"num_overflows\", ecap_cnt_nb_ovf_read, ecap_cnt_nb_ovf_write),\n\tCOUNTER_COMP_CEILING(ecap_cnt_ceiling_read, NULL),\n\tCOUNTER_COMP_ENABLE(ecap_cnt_enable_read, ecap_cnt_enable_write),\n};\n\nstatic struct counter_count ecap_cnt_counts[] = {\n\t{\n\t\t.name = \"Timestamp Counter\",\n\t\t.functions_list = ecap_cnt_functions,\n\t\t.num_functions = ARRAY_SIZE(ecap_cnt_functions),\n\t\t.synapses = ecap_cnt_synapses,\n\t\t.num_synapses = ARRAY_SIZE(ecap_cnt_synapses),\n\t\t.ext = ecap_cnt_count_ext,\n\t\t.num_ext = ARRAY_SIZE(ecap_cnt_count_ext),\n\t},\n};\n\nstatic irqreturn_t ecap_cnt_isr(int irq, void *dev_id)\n{\n\tstruct counter_device *counter_dev = dev_id;\n\tstruct ecap_cnt_dev *ecap_dev = counter_priv(counter_dev);\n\tunsigned int clr = 0;\n\tunsigned int flg;\n\tint i;\n\n\tregmap_read(ecap_dev->regmap, ECAP_ECINT_EN_FLG_REG, &flg);\n\n\t \n\tfor (i = 0 ; i < ECAP_NB_CEVT ; i++) {\n\t\tif (flg & ECAP_EVT_FLG_BIT(i)) {\n\t\t\tcounter_push_event(counter_dev, COUNTER_EVENT_CAPTURE, i);\n\t\t\tclr |= ECAP_EVT_CLR_BIT(i);\n\t\t}\n\t}\n\n\t \n\tif (flg & ECAP_EVT_FLG_BIT(ECAP_CNTOVF)) {\n\t\tatomic_inc(&ecap_dev->nb_ovf);\n\t\tfor (i = 0 ; i < ECAP_NB_CEVT ; i++)\n\t\t\tcounter_push_event(counter_dev, COUNTER_EVENT_OVERFLOW, i);\n\t\tclr |= ECAP_EVT_CLR_BIT(ECAP_CNTOVF);\n\t}\n\n\tclr |= ECAP_INT_CLR_BIT;\n\tregmap_update_bits(ecap_dev->regmap, ECAP_ECINT_CLR_FRC_REG, ECAP_EVT_CLR_MASK, clr);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void ecap_cnt_pm_disable(void *dev)\n{\n\tpm_runtime_disable(dev);\n}\n\nstatic int ecap_cnt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct ecap_cnt_dev *ecap_dev;\n\tstruct counter_device *counter_dev;\n\tvoid __iomem *mmio_base;\n\tunsigned long clk_rate;\n\tint ret;\n\n\tcounter_dev = devm_counter_alloc(dev, sizeof(*ecap_dev));\n\tif (!counter_dev)\n\t\treturn -ENOMEM;\n\n\tcounter_dev->name = ECAP_DRV_NAME;\n\tcounter_dev->parent = dev;\n\tcounter_dev->ops = &ecap_cnt_ops;\n\tcounter_dev->signals = ecap_cnt_signals;\n\tcounter_dev->num_signals = ARRAY_SIZE(ecap_cnt_signals);\n\tcounter_dev->counts = ecap_cnt_counts;\n\tcounter_dev->num_counts = ARRAY_SIZE(ecap_cnt_counts);\n\n\tecap_dev = counter_priv(counter_dev);\n\n\tmutex_init(&ecap_dev->lock);\n\n\tecap_dev->clk = devm_clk_get_enabled(dev, \"fck\");\n\tif (IS_ERR(ecap_dev->clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(ecap_dev->clk), \"failed to get clock\\n\");\n\n\tclk_rate = clk_get_rate(ecap_dev->clk);\n\tif (!clk_rate) {\n\t\tdev_err(dev, \"failed to get clock rate\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmmio_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(mmio_base))\n\t\treturn PTR_ERR(mmio_base);\n\n\tecap_dev->regmap = devm_regmap_init_mmio(dev, mmio_base, &ecap_cnt_regmap_config);\n\tif (IS_ERR(ecap_dev->regmap))\n\t\treturn dev_err_probe(dev, PTR_ERR(ecap_dev->regmap), \"failed to init regmap\\n\");\n\n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\treturn dev_err_probe(dev, ret, \"failed to get irq\\n\");\n\n\tret = devm_request_irq(dev, ret, ecap_cnt_isr, 0, pdev->name, counter_dev);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"failed to request irq\\n\");\n\n\tplatform_set_drvdata(pdev, counter_dev);\n\n\tpm_runtime_enable(dev);\n\n\t \n\tret = devm_add_action_or_reset(dev, ecap_cnt_pm_disable, dev);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"failed to add pm disable action\\n\");\n\n\tret = devm_counter_add(dev, counter_dev);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"failed to add counter\\n\");\n\n\treturn 0;\n}\n\nstatic int ecap_cnt_remove(struct platform_device *pdev)\n{\n\tstruct counter_device *counter_dev = platform_get_drvdata(pdev);\n\tstruct ecap_cnt_dev *ecap_dev = counter_priv(counter_dev);\n\n\tif (ecap_dev->enabled)\n\t\tecap_cnt_capture_disable(counter_dev);\n\n\treturn 0;\n}\n\nstatic int ecap_cnt_suspend(struct device *dev)\n{\n\tstruct counter_device *counter_dev = dev_get_drvdata(dev);\n\tstruct ecap_cnt_dev *ecap_dev = counter_priv(counter_dev);\n\n\t \n\tif (ecap_dev->enabled) {\n\t\t \n\t\tecap_cnt_capture_disable(counter_dev);\n\t\tecap_dev->pm_ctx.time_cntr = ecap_cnt_count_get_val(counter_dev, ECAP_TSCNT_REG);\n\t}\n\n\tecap_dev->pm_ctx.ev_mode = ecap_cnt_capture_get_evmode(counter_dev);\n\n\tclk_disable(ecap_dev->clk);\n\n\treturn 0;\n}\n\nstatic int ecap_cnt_resume(struct device *dev)\n{\n\tstruct counter_device *counter_dev = dev_get_drvdata(dev);\n\tstruct ecap_cnt_dev *ecap_dev = counter_priv(counter_dev);\n\n\tclk_enable(ecap_dev->clk);\n\n\tecap_cnt_capture_set_evmode(counter_dev, ecap_dev->pm_ctx.ev_mode);\n\n\t \n\tif (ecap_dev->enabled) {\n\t\tecap_cnt_count_set_val(counter_dev, ECAP_TSCNT_REG, ecap_dev->pm_ctx.time_cntr);\n\t\tecap_cnt_capture_enable(counter_dev);\n\t}\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(ecap_cnt_pm_ops, ecap_cnt_suspend, ecap_cnt_resume);\n\nstatic const struct of_device_id ecap_cnt_of_match[] = {\n\t{ .compatible\t= \"ti,am62-ecap-capture\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ecap_cnt_of_match);\n\nstatic struct platform_driver ecap_cnt_driver = {\n\t.probe = ecap_cnt_probe,\n\t.remove = ecap_cnt_remove,\n\t.driver = {\n\t\t.name = \"ecap-capture\",\n\t\t.of_match_table = ecap_cnt_of_match,\n\t\t.pm = pm_sleep_ptr(&ecap_cnt_pm_ops),\n\t},\n};\nmodule_platform_driver(ecap_cnt_driver);\n\nMODULE_DESCRIPTION(\"ECAP Capture driver\");\nMODULE_AUTHOR(\"Julien Panis <jpanis@baylibre.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(COUNTER);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}