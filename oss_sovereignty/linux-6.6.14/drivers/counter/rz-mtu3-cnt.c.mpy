{
  "module_name": "rz-mtu3-cnt.c",
  "hash_id": "136e3d5ea61da176e96cce28dc099971948554bc6bff9dfe31d19514f50fdc43",
  "original_prompt": "Ingested from linux-6.6.14/drivers/counter/rz-mtu3-cnt.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/counter.h>\n#include <linux/mfd/rz-mtu3.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/types.h>\n\n \n\n#define RZ_MTU3_TSR_TCFD\tBIT(7)  \n\n#define RZ_MTU3_TMDR1_PH_CNT_MODE_1\t(4)  \n#define RZ_MTU3_TMDR1_PH_CNT_MODE_2\t(5)  \n#define RZ_MTU3_TMDR1_PH_CNT_MODE_3\t(6)  \n#define RZ_MTU3_TMDR1_PH_CNT_MODE_4\t(7)  \n#define RZ_MTU3_TMDR1_PH_CNT_MODE_5\t(9)  \n#define RZ_MTU3_TMDR1_PH_CNT_MODE_MASK\t(0xf)\n\n \n#define RZ_MTU3_TMDR3_LWA\t(0)\n\n \n#define RZ_MTU3_TMDR3_PHCKSEL\t(1)\n\n#define RZ_MTU3_16_BIT_MTU1_CH\t(0)\n#define RZ_MTU3_16_BIT_MTU2_CH\t(1)\n#define RZ_MTU3_32_BIT_CH\t(2)\n\n#define RZ_MTU3_TIOR_NO_OUTPUT\t(0)  \n#define RZ_MTU3_TIOR_IC_BOTH\t(10)  \n\n#define SIGNAL_A_ID\t(0)\n#define SIGNAL_B_ID\t(1)\n#define SIGNAL_C_ID\t(2)\n#define SIGNAL_D_ID\t(3)\n\n#define RZ_MTU3_MAX_HW_CNTR_CHANNELS\t(2)\n#define RZ_MTU3_MAX_LOGICAL_CNTR_CHANNELS\t(3)\n\n \nstruct rz_mtu3_cnt {\n\tstruct clk *clk;\n\tstruct mutex lock;\n\tstruct rz_mtu3_channel *ch;\n\tbool count_is_enabled[RZ_MTU3_MAX_LOGICAL_CNTR_CHANNELS];\n\tunion {\n\t\tu16 mtu_16bit_max[RZ_MTU3_MAX_HW_CNTR_CHANNELS];\n\t\tu32 mtu_32bit_max;\n\t};\n};\n\nstatic const enum counter_function rz_mtu3_count_functions[] = {\n\tCOUNTER_FUNCTION_QUADRATURE_X4,\n\tCOUNTER_FUNCTION_PULSE_DIRECTION,\n\tCOUNTER_FUNCTION_QUADRATURE_X2_B,\n};\n\nstatic inline size_t rz_mtu3_get_hw_ch(const size_t id)\n{\n\treturn (id == RZ_MTU3_32_BIT_CH) ? 0 : id;\n}\n\nstatic inline struct rz_mtu3_channel *rz_mtu3_get_ch(struct counter_device *counter, int id)\n{\n\tstruct rz_mtu3_cnt *const priv = counter_priv(counter);\n\tconst size_t ch_id = rz_mtu3_get_hw_ch(id);\n\n\treturn &priv->ch[ch_id];\n}\n\nstatic bool rz_mtu3_is_counter_invalid(struct counter_device *counter, int id)\n{\n\tstruct rz_mtu3_cnt *const priv = counter_priv(counter);\n\tunsigned long tmdr;\n\n\tpm_runtime_get_sync(priv->ch->dev);\n\ttmdr = rz_mtu3_shared_reg_read(priv->ch, RZ_MTU3_TMDR3);\n\tpm_runtime_put(priv->ch->dev);\n\n\tif (id == RZ_MTU3_32_BIT_CH && test_bit(RZ_MTU3_TMDR3_LWA, &tmdr))\n\t\treturn false;\n\n\tif (id != RZ_MTU3_32_BIT_CH && !test_bit(RZ_MTU3_TMDR3_LWA, &tmdr))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int rz_mtu3_lock_if_counter_is_valid(struct counter_device *counter,\n\t\t\t\t\t    struct rz_mtu3_channel *const ch,\n\t\t\t\t\t    struct rz_mtu3_cnt *const priv,\n\t\t\t\t\t    int id)\n{\n\tmutex_lock(&priv->lock);\n\n\tif (ch->is_busy && !priv->count_is_enabled[id]) {\n\t\tmutex_unlock(&priv->lock);\n\t\treturn -EINVAL;\n\t}\n\n\tif (rz_mtu3_is_counter_invalid(counter, id)) {\n\t\tmutex_unlock(&priv->lock);\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nstatic int rz_mtu3_lock_if_count_is_enabled(struct rz_mtu3_channel *const ch,\n\t\t\t\t\t    struct rz_mtu3_cnt *const priv,\n\t\t\t\t\t    int id)\n{\n\tmutex_lock(&priv->lock);\n\n\tif (ch->is_busy && !priv->count_is_enabled[id]) {\n\t\tmutex_unlock(&priv->lock);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int rz_mtu3_count_read(struct counter_device *counter,\n\t\t\t      struct counter_count *count, u64 *val)\n{\n\tstruct rz_mtu3_channel *const ch = rz_mtu3_get_ch(counter, count->id);\n\tstruct rz_mtu3_cnt *const priv = counter_priv(counter);\n\tint ret;\n\n\tret = rz_mtu3_lock_if_counter_is_valid(counter, ch, priv, count->id);\n\tif (ret)\n\t\treturn ret;\n\n\tpm_runtime_get_sync(ch->dev);\n\tif (count->id == RZ_MTU3_32_BIT_CH)\n\t\t*val = rz_mtu3_32bit_ch_read(ch, RZ_MTU3_TCNTLW);\n\telse\n\t\t*val = rz_mtu3_16bit_ch_read(ch, RZ_MTU3_TCNT);\n\tpm_runtime_put(ch->dev);\n\tmutex_unlock(&priv->lock);\n\n\treturn 0;\n}\n\nstatic int rz_mtu3_count_write(struct counter_device *counter,\n\t\t\t       struct counter_count *count, const u64 val)\n{\n\tstruct rz_mtu3_channel *const ch = rz_mtu3_get_ch(counter, count->id);\n\tstruct rz_mtu3_cnt *const priv = counter_priv(counter);\n\tint ret;\n\n\tret = rz_mtu3_lock_if_counter_is_valid(counter, ch, priv, count->id);\n\tif (ret)\n\t\treturn ret;\n\n\tpm_runtime_get_sync(ch->dev);\n\tif (count->id == RZ_MTU3_32_BIT_CH)\n\t\trz_mtu3_32bit_ch_write(ch, RZ_MTU3_TCNTLW, val);\n\telse\n\t\trz_mtu3_16bit_ch_write(ch, RZ_MTU3_TCNT, val);\n\tpm_runtime_put(ch->dev);\n\tmutex_unlock(&priv->lock);\n\n\treturn 0;\n}\n\nstatic int rz_mtu3_count_function_read_helper(struct rz_mtu3_channel *const ch,\n\t\t\t\t\t      struct rz_mtu3_cnt *const priv,\n\t\t\t\t\t      enum counter_function *function)\n{\n\tu8 timer_mode;\n\n\tpm_runtime_get_sync(ch->dev);\n\ttimer_mode = rz_mtu3_8bit_ch_read(ch, RZ_MTU3_TMDR1);\n\tpm_runtime_put(ch->dev);\n\n\tswitch (timer_mode & RZ_MTU3_TMDR1_PH_CNT_MODE_MASK) {\n\tcase RZ_MTU3_TMDR1_PH_CNT_MODE_1:\n\t\t*function = COUNTER_FUNCTION_QUADRATURE_X4;\n\t\treturn 0;\n\tcase RZ_MTU3_TMDR1_PH_CNT_MODE_2:\n\t\t*function = COUNTER_FUNCTION_PULSE_DIRECTION;\n\t\treturn 0;\n\tcase RZ_MTU3_TMDR1_PH_CNT_MODE_4:\n\t\t*function = COUNTER_FUNCTION_QUADRATURE_X2_B;\n\t\treturn 0;\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int rz_mtu3_count_function_read(struct counter_device *counter,\n\t\t\t\t       struct counter_count *count,\n\t\t\t\t       enum counter_function *function)\n{\n\tstruct rz_mtu3_channel *const ch = rz_mtu3_get_ch(counter, count->id);\n\tstruct rz_mtu3_cnt *const priv = counter_priv(counter);\n\tint ret;\n\n\tret = rz_mtu3_lock_if_count_is_enabled(ch, priv, count->id);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rz_mtu3_count_function_read_helper(ch, priv, function);\n\tmutex_unlock(&priv->lock);\n\n\treturn ret;\n}\n\nstatic int rz_mtu3_count_function_write(struct counter_device *counter,\n\t\t\t\t\tstruct counter_count *count,\n\t\t\t\t\tenum counter_function function)\n{\n\tstruct rz_mtu3_channel *const ch = rz_mtu3_get_ch(counter, count->id);\n\tstruct rz_mtu3_cnt *const priv = counter_priv(counter);\n\tu8 timer_mode;\n\tint ret;\n\n\tret = rz_mtu3_lock_if_count_is_enabled(ch, priv, count->id);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (function) {\n\tcase COUNTER_FUNCTION_QUADRATURE_X4:\n\t\ttimer_mode = RZ_MTU3_TMDR1_PH_CNT_MODE_1;\n\t\tbreak;\n\tcase COUNTER_FUNCTION_PULSE_DIRECTION:\n\t\ttimer_mode = RZ_MTU3_TMDR1_PH_CNT_MODE_2;\n\t\tbreak;\n\tcase COUNTER_FUNCTION_QUADRATURE_X2_B:\n\t\ttimer_mode = RZ_MTU3_TMDR1_PH_CNT_MODE_4;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tmutex_unlock(&priv->lock);\n\t\treturn -EINVAL;\n\t}\n\n\tpm_runtime_get_sync(ch->dev);\n\trz_mtu3_8bit_ch_write(ch, RZ_MTU3_TMDR1, timer_mode);\n\tpm_runtime_put(ch->dev);\n\tmutex_unlock(&priv->lock);\n\n\treturn 0;\n}\n\nstatic int rz_mtu3_count_direction_read(struct counter_device *counter,\n\t\t\t\t\tstruct counter_count *count,\n\t\t\t\t\tenum counter_count_direction *direction)\n{\n\tstruct rz_mtu3_channel *const ch = rz_mtu3_get_ch(counter, count->id);\n\tstruct rz_mtu3_cnt *const priv = counter_priv(counter);\n\tint ret;\n\tu8 tsr;\n\n\tret = rz_mtu3_lock_if_count_is_enabled(ch, priv, count->id);\n\tif (ret)\n\t\treturn ret;\n\n\tpm_runtime_get_sync(ch->dev);\n\ttsr = rz_mtu3_8bit_ch_read(ch, RZ_MTU3_TSR);\n\tpm_runtime_put(ch->dev);\n\n\t*direction = (tsr & RZ_MTU3_TSR_TCFD) ?\n\t\tCOUNTER_COUNT_DIRECTION_FORWARD : COUNTER_COUNT_DIRECTION_BACKWARD;\n\tmutex_unlock(&priv->lock);\n\n\treturn 0;\n}\n\nstatic int rz_mtu3_count_ceiling_read(struct counter_device *counter,\n\t\t\t\t      struct counter_count *count,\n\t\t\t\t      u64 *ceiling)\n{\n\tstruct rz_mtu3_channel *const ch = rz_mtu3_get_ch(counter, count->id);\n\tstruct rz_mtu3_cnt *const priv = counter_priv(counter);\n\tconst size_t ch_id = rz_mtu3_get_hw_ch(count->id);\n\tint ret;\n\n\tret = rz_mtu3_lock_if_counter_is_valid(counter, ch, priv, count->id);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (count->id) {\n\tcase RZ_MTU3_16_BIT_MTU1_CH:\n\tcase RZ_MTU3_16_BIT_MTU2_CH:\n\t\t*ceiling = priv->mtu_16bit_max[ch_id];\n\t\tbreak;\n\tcase RZ_MTU3_32_BIT_CH:\n\t\t*ceiling = priv->mtu_32bit_max;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tmutex_unlock(&priv->lock);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_unlock(&priv->lock);\n\treturn 0;\n}\n\nstatic int rz_mtu3_count_ceiling_write(struct counter_device *counter,\n\t\t\t\t       struct counter_count *count,\n\t\t\t\t       u64 ceiling)\n{\n\tstruct rz_mtu3_channel *const ch = rz_mtu3_get_ch(counter, count->id);\n\tstruct rz_mtu3_cnt *const priv = counter_priv(counter);\n\tconst size_t ch_id = rz_mtu3_get_hw_ch(count->id);\n\tint ret;\n\n\tret = rz_mtu3_lock_if_counter_is_valid(counter, ch, priv, count->id);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (count->id) {\n\tcase RZ_MTU3_16_BIT_MTU1_CH:\n\tcase RZ_MTU3_16_BIT_MTU2_CH:\n\t\tif (ceiling > U16_MAX) {\n\t\t\tmutex_unlock(&priv->lock);\n\t\t\treturn -ERANGE;\n\t\t}\n\t\tpriv->mtu_16bit_max[ch_id] = ceiling;\n\t\tbreak;\n\tcase RZ_MTU3_32_BIT_CH:\n\t\tif (ceiling > U32_MAX) {\n\t\t\tmutex_unlock(&priv->lock);\n\t\t\treturn -ERANGE;\n\t\t}\n\t\tpriv->mtu_32bit_max = ceiling;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tmutex_unlock(&priv->lock);\n\t\treturn -EINVAL;\n\t}\n\n\tpm_runtime_get_sync(ch->dev);\n\tif (count->id == RZ_MTU3_32_BIT_CH)\n\t\trz_mtu3_32bit_ch_write(ch, RZ_MTU3_TGRALW, ceiling);\n\telse\n\t\trz_mtu3_16bit_ch_write(ch, RZ_MTU3_TGRA, ceiling);\n\n\trz_mtu3_8bit_ch_write(ch, RZ_MTU3_TCR, RZ_MTU3_TCR_CCLR_TGRA);\n\tpm_runtime_put(ch->dev);\n\tmutex_unlock(&priv->lock);\n\n\treturn 0;\n}\n\nstatic void rz_mtu3_32bit_cnt_setting(struct counter_device *counter)\n{\n\tstruct rz_mtu3_channel *const ch1 = rz_mtu3_get_ch(counter, 0);\n\tstruct rz_mtu3_channel *const ch2 = rz_mtu3_get_ch(counter, 1);\n\n\t \n\trz_mtu3_8bit_ch_write(ch1, RZ_MTU3_TMDR1, RZ_MTU3_TMDR1_PH_CNT_MODE_1);\n\n\trz_mtu3_8bit_ch_write(ch1, RZ_MTU3_TCR, RZ_MTU3_TCR_CCLR_TGRA);\n\trz_mtu3_8bit_ch_write(ch1, RZ_MTU3_TIOR, RZ_MTU3_TIOR_IC_BOTH);\n\n\trz_mtu3_enable(ch1);\n\trz_mtu3_enable(ch2);\n}\n\nstatic void rz_mtu3_16bit_cnt_setting(struct counter_device *counter, int id)\n{\n\tstruct rz_mtu3_channel *const ch = rz_mtu3_get_ch(counter, id);\n\n\t \n\trz_mtu3_8bit_ch_write(ch, RZ_MTU3_TMDR1, RZ_MTU3_TMDR1_PH_CNT_MODE_1);\n\n\trz_mtu3_8bit_ch_write(ch, RZ_MTU3_TCR, RZ_MTU3_TCR_CCLR_TGRA);\n\trz_mtu3_8bit_ch_write(ch, RZ_MTU3_TIOR, RZ_MTU3_TIOR_NO_OUTPUT);\n\trz_mtu3_enable(ch);\n}\n\nstatic int rz_mtu3_initialize_counter(struct counter_device *counter, int id)\n{\n\tstruct rz_mtu3_channel *const ch = rz_mtu3_get_ch(counter, id);\n\tstruct rz_mtu3_channel *const ch1 = rz_mtu3_get_ch(counter, 0);\n\tstruct rz_mtu3_channel *const ch2 = rz_mtu3_get_ch(counter, 1);\n\n\tswitch (id) {\n\tcase RZ_MTU3_16_BIT_MTU1_CH:\n\tcase RZ_MTU3_16_BIT_MTU2_CH:\n\t\tif (!rz_mtu3_request_channel(ch))\n\t\t\treturn -EBUSY;\n\n\t\trz_mtu3_16bit_cnt_setting(counter, id);\n\t\treturn 0;\n\tcase RZ_MTU3_32_BIT_CH:\n\t\t \n\t\tif (!rz_mtu3_request_channel(ch1))\n\t\t\treturn -EBUSY;\n\n\t\tif (!rz_mtu3_request_channel(ch2)) {\n\t\t\trz_mtu3_release_channel(ch1);\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\trz_mtu3_32bit_cnt_setting(counter);\n\t\treturn 0;\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n}\n\nstatic void rz_mtu3_terminate_counter(struct counter_device *counter, int id)\n{\n\tstruct rz_mtu3_channel *const ch = rz_mtu3_get_ch(counter, id);\n\tstruct rz_mtu3_channel *const ch1 = rz_mtu3_get_ch(counter, 0);\n\tstruct rz_mtu3_channel *const ch2 = rz_mtu3_get_ch(counter, 1);\n\n\tif (id == RZ_MTU3_32_BIT_CH) {\n\t\trz_mtu3_release_channel(ch2);\n\t\trz_mtu3_release_channel(ch1);\n\t\trz_mtu3_disable(ch2);\n\t\trz_mtu3_disable(ch1);\n\t} else {\n\t\trz_mtu3_release_channel(ch);\n\t\trz_mtu3_disable(ch);\n\t}\n}\n\nstatic int rz_mtu3_count_enable_read(struct counter_device *counter,\n\t\t\t\t     struct counter_count *count, u8 *enable)\n{\n\tstruct rz_mtu3_channel *const ch = rz_mtu3_get_ch(counter, count->id);\n\tstruct rz_mtu3_channel *const ch1 = rz_mtu3_get_ch(counter, 0);\n\tstruct rz_mtu3_channel *const ch2 = rz_mtu3_get_ch(counter, 1);\n\tstruct rz_mtu3_cnt *const priv = counter_priv(counter);\n\tint ret;\n\n\tret = rz_mtu3_lock_if_count_is_enabled(ch, priv, count->id);\n\tif (ret)\n\t\treturn ret;\n\n\tif (count->id == RZ_MTU3_32_BIT_CH)\n\t\t*enable = rz_mtu3_is_enabled(ch1) && rz_mtu3_is_enabled(ch2);\n\telse\n\t\t*enable = rz_mtu3_is_enabled(ch);\n\n\tmutex_unlock(&priv->lock);\n\n\treturn 0;\n}\n\nstatic int rz_mtu3_count_enable_write(struct counter_device *counter,\n\t\t\t\t      struct counter_count *count, u8 enable)\n{\n\tstruct rz_mtu3_channel *const ch = rz_mtu3_get_ch(counter, count->id);\n\tstruct rz_mtu3_cnt *const priv = counter_priv(counter);\n\tint ret = 0;\n\n\tif (enable) {\n\t\tmutex_lock(&priv->lock);\n\t\tpm_runtime_get_sync(ch->dev);\n\t\tret = rz_mtu3_initialize_counter(counter, count->id);\n\t\tif (ret == 0)\n\t\t\tpriv->count_is_enabled[count->id] = true;\n\t\tmutex_unlock(&priv->lock);\n\t} else {\n\t\tmutex_lock(&priv->lock);\n\t\trz_mtu3_terminate_counter(counter, count->id);\n\t\tpriv->count_is_enabled[count->id] = false;\n\t\tpm_runtime_put(ch->dev);\n\t\tmutex_unlock(&priv->lock);\n\t}\n\n\treturn ret;\n}\n\nstatic int rz_mtu3_lock_if_ch0_is_enabled(struct rz_mtu3_cnt *const priv)\n{\n\tmutex_lock(&priv->lock);\n\tif (priv->ch->is_busy && !(priv->count_is_enabled[RZ_MTU3_16_BIT_MTU1_CH] ||\n\t\t\t\t   priv->count_is_enabled[RZ_MTU3_32_BIT_CH])) {\n\t\tmutex_unlock(&priv->lock);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int rz_mtu3_cascade_counts_enable_get(struct counter_device *counter,\n\t\t\t\t\t     u8 *cascade_enable)\n{\n\tstruct rz_mtu3_cnt *const priv = counter_priv(counter);\n\tunsigned long tmdr;\n\tint ret;\n\n\tret = rz_mtu3_lock_if_ch0_is_enabled(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tpm_runtime_get_sync(priv->ch->dev);\n\ttmdr = rz_mtu3_shared_reg_read(priv->ch, RZ_MTU3_TMDR3);\n\tpm_runtime_put(priv->ch->dev);\n\t*cascade_enable = test_bit(RZ_MTU3_TMDR3_LWA, &tmdr);\n\tmutex_unlock(&priv->lock);\n\n\treturn 0;\n}\n\nstatic int rz_mtu3_cascade_counts_enable_set(struct counter_device *counter,\n\t\t\t\t\t     u8 cascade_enable)\n{\n\tstruct rz_mtu3_cnt *const priv = counter_priv(counter);\n\tint ret;\n\n\tret = rz_mtu3_lock_if_ch0_is_enabled(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tpm_runtime_get_sync(priv->ch->dev);\n\trz_mtu3_shared_reg_update_bit(priv->ch, RZ_MTU3_TMDR3,\n\t\t\t\t      RZ_MTU3_TMDR3_LWA, cascade_enable);\n\tpm_runtime_put(priv->ch->dev);\n\tmutex_unlock(&priv->lock);\n\n\treturn 0;\n}\n\nstatic int rz_mtu3_ext_input_phase_clock_select_get(struct counter_device *counter,\n\t\t\t\t\t\t    u32 *ext_input_phase_clock_select)\n{\n\tstruct rz_mtu3_cnt *const priv = counter_priv(counter);\n\tunsigned long tmdr;\n\tint ret;\n\n\tret = rz_mtu3_lock_if_ch0_is_enabled(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tpm_runtime_get_sync(priv->ch->dev);\n\ttmdr = rz_mtu3_shared_reg_read(priv->ch, RZ_MTU3_TMDR3);\n\tpm_runtime_put(priv->ch->dev);\n\t*ext_input_phase_clock_select = test_bit(RZ_MTU3_TMDR3_PHCKSEL, &tmdr);\n\tmutex_unlock(&priv->lock);\n\n\treturn 0;\n}\n\nstatic int rz_mtu3_ext_input_phase_clock_select_set(struct counter_device *counter,\n\t\t\t\t\t\t    u32 ext_input_phase_clock_select)\n{\n\tstruct rz_mtu3_cnt *const priv = counter_priv(counter);\n\tint ret;\n\n\tret = rz_mtu3_lock_if_ch0_is_enabled(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tpm_runtime_get_sync(priv->ch->dev);\n\trz_mtu3_shared_reg_update_bit(priv->ch, RZ_MTU3_TMDR3,\n\t\t\t\t      RZ_MTU3_TMDR3_PHCKSEL,\n\t\t\t\t      ext_input_phase_clock_select);\n\tpm_runtime_put(priv->ch->dev);\n\tmutex_unlock(&priv->lock);\n\n\treturn 0;\n}\n\nstatic struct counter_comp rz_mtu3_count_ext[] = {\n\tCOUNTER_COMP_DIRECTION(rz_mtu3_count_direction_read),\n\tCOUNTER_COMP_ENABLE(rz_mtu3_count_enable_read,\n\t\t\t    rz_mtu3_count_enable_write),\n\tCOUNTER_COMP_CEILING(rz_mtu3_count_ceiling_read,\n\t\t\t     rz_mtu3_count_ceiling_write),\n};\n\nstatic const enum counter_synapse_action rz_mtu3_synapse_actions[] = {\n\tCOUNTER_SYNAPSE_ACTION_BOTH_EDGES,\n\tCOUNTER_SYNAPSE_ACTION_RISING_EDGE,\n\tCOUNTER_SYNAPSE_ACTION_NONE,\n};\n\nstatic int rz_mtu3_action_read(struct counter_device *counter,\n\t\t\t       struct counter_count *count,\n\t\t\t       struct counter_synapse *synapse,\n\t\t\t       enum counter_synapse_action *action)\n{\n\tconst bool is_signal_ab = (synapse->signal->id == SIGNAL_A_ID) ||\n\t\t\t\t  (synapse->signal->id == SIGNAL_B_ID);\n\tstruct rz_mtu3_channel *const ch = rz_mtu3_get_ch(counter, count->id);\n\tstruct rz_mtu3_cnt *const priv = counter_priv(counter);\n\tenum counter_function function;\n\tbool mtclkc_mtclkd;\n\tunsigned long tmdr;\n\tint ret;\n\n\tret = rz_mtu3_lock_if_count_is_enabled(ch, priv, count->id);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rz_mtu3_count_function_read_helper(ch, priv, &function);\n\tif (ret) {\n\t\tmutex_unlock(&priv->lock);\n\t\treturn ret;\n\t}\n\n\t \n\t*action = COUNTER_SYNAPSE_ACTION_NONE;\n\n\tif (count->id != RZ_MTU3_16_BIT_MTU1_CH) {\n\t\ttmdr = rz_mtu3_shared_reg_read(priv->ch, RZ_MTU3_TMDR3);\n\t\tmtclkc_mtclkd = test_bit(RZ_MTU3_TMDR3_PHCKSEL, &tmdr);\n\t\tif ((mtclkc_mtclkd && is_signal_ab) ||\n\t\t    (!mtclkc_mtclkd && !is_signal_ab)) {\n\t\t\tmutex_unlock(&priv->lock);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tswitch (function) {\n\tcase COUNTER_FUNCTION_PULSE_DIRECTION:\n\t\t \n\t\tif (synapse->signal->id == SIGNAL_A_ID ||\n\t\t    synapse->signal->id == SIGNAL_C_ID)\n\t\t\t*action = COUNTER_SYNAPSE_ACTION_RISING_EDGE;\n\t\tbreak;\n\tcase COUNTER_FUNCTION_QUADRATURE_X2_B:\n\t\t \n\t\tif (synapse->signal->id == SIGNAL_B_ID ||\n\t\t    synapse->signal->id == SIGNAL_D_ID)\n\t\t\t*action = COUNTER_SYNAPSE_ACTION_BOTH_EDGES;\n\t\tbreak;\n\tcase COUNTER_FUNCTION_QUADRATURE_X4:\n\t\t \n\t\t*action = COUNTER_SYNAPSE_ACTION_BOTH_EDGES;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tmutex_unlock(&priv->lock);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_unlock(&priv->lock);\n\n\treturn 0;\n}\n\nstatic const struct counter_ops rz_mtu3_cnt_ops = {\n\t.count_read = rz_mtu3_count_read,\n\t.count_write = rz_mtu3_count_write,\n\t.function_read = rz_mtu3_count_function_read,\n\t.function_write = rz_mtu3_count_function_write,\n\t.action_read = rz_mtu3_action_read,\n};\n\n#define RZ_MTU3_PHASE_SIGNAL(_id, _name) {\t\t\\\n\t.id = (_id),\t\t\t\t\\\n\t.name = (_name),\t\t\t\\\n}\n\nstatic struct counter_signal rz_mtu3_signals[] = {\n\tRZ_MTU3_PHASE_SIGNAL(SIGNAL_A_ID, \"MTU1 MTCLKA\"),\n\tRZ_MTU3_PHASE_SIGNAL(SIGNAL_B_ID, \"MTU1 MTCLKB\"),\n\tRZ_MTU3_PHASE_SIGNAL(SIGNAL_C_ID, \"MTU2 MTCLKC\"),\n\tRZ_MTU3_PHASE_SIGNAL(SIGNAL_D_ID, \"MTU2 MTCLKD\"),\n};\n\nstatic struct counter_synapse rz_mtu3_mtu1_count_synapses[] = {\n\t{\n\t\t.actions_list = rz_mtu3_synapse_actions,\n\t\t.num_actions = ARRAY_SIZE(rz_mtu3_synapse_actions),\n\t\t.signal = rz_mtu3_signals,\n\t},\n\t{\n\t\t.actions_list = rz_mtu3_synapse_actions,\n\t\t.num_actions = ARRAY_SIZE(rz_mtu3_synapse_actions),\n\t\t.signal = rz_mtu3_signals + 1,\n\t}\n};\n\nstatic struct counter_synapse rz_mtu3_mtu2_count_synapses[] = {\n\t{\n\t\t.actions_list = rz_mtu3_synapse_actions,\n\t\t.num_actions = ARRAY_SIZE(rz_mtu3_synapse_actions),\n\t\t.signal = rz_mtu3_signals,\n\t},\n\t{\n\t\t.actions_list = rz_mtu3_synapse_actions,\n\t\t.num_actions = ARRAY_SIZE(rz_mtu3_synapse_actions),\n\t\t.signal = rz_mtu3_signals + 1,\n\t},\n\t{\n\t\t.actions_list = rz_mtu3_synapse_actions,\n\t\t.num_actions = ARRAY_SIZE(rz_mtu3_synapse_actions),\n\t\t.signal = rz_mtu3_signals + 2,\n\t},\n\t{\n\t\t.actions_list = rz_mtu3_synapse_actions,\n\t\t.num_actions = ARRAY_SIZE(rz_mtu3_synapse_actions),\n\t\t.signal = rz_mtu3_signals + 3,\n\t}\n};\n\nstatic struct counter_count rz_mtu3_counts[] = {\n\t{\n\t\t.id = RZ_MTU3_16_BIT_MTU1_CH,\n\t\t.name = \"Channel 1 Count\",\n\t\t.functions_list = rz_mtu3_count_functions,\n\t\t.num_functions = ARRAY_SIZE(rz_mtu3_count_functions),\n\t\t.synapses = rz_mtu3_mtu1_count_synapses,\n\t\t.num_synapses = ARRAY_SIZE(rz_mtu3_mtu1_count_synapses),\n\t\t.ext = rz_mtu3_count_ext,\n\t\t.num_ext = ARRAY_SIZE(rz_mtu3_count_ext),\n\t},\n\t{\n\t\t.id = RZ_MTU3_16_BIT_MTU2_CH,\n\t\t.name = \"Channel 2 Count\",\n\t\t.functions_list = rz_mtu3_count_functions,\n\t\t.num_functions = ARRAY_SIZE(rz_mtu3_count_functions),\n\t\t.synapses = rz_mtu3_mtu2_count_synapses,\n\t\t.num_synapses = ARRAY_SIZE(rz_mtu3_mtu2_count_synapses),\n\t\t.ext = rz_mtu3_count_ext,\n\t\t.num_ext = ARRAY_SIZE(rz_mtu3_count_ext),\n\t},\n\t{\n\t\t.id = RZ_MTU3_32_BIT_CH,\n\t\t.name = \"Channel 1 and 2 (cascaded) Count\",\n\t\t.functions_list = rz_mtu3_count_functions,\n\t\t.num_functions = ARRAY_SIZE(rz_mtu3_count_functions),\n\t\t.synapses = rz_mtu3_mtu2_count_synapses,\n\t\t.num_synapses = ARRAY_SIZE(rz_mtu3_mtu2_count_synapses),\n\t\t.ext = rz_mtu3_count_ext,\n\t\t.num_ext = ARRAY_SIZE(rz_mtu3_count_ext),\n\t}\n};\n\nstatic const char *const rz_mtu3_ext_input_phase_clock_select[] = {\n\t\"MTCLKA-MTCLKB\",\n\t\"MTCLKC-MTCLKD\",\n};\n\nstatic DEFINE_COUNTER_ENUM(rz_mtu3_ext_input_phase_clock_select_enum,\n\t\t\t   rz_mtu3_ext_input_phase_clock_select);\n\nstatic struct counter_comp rz_mtu3_device_ext[] = {\n\tCOUNTER_COMP_DEVICE_BOOL(\"cascade_counts_enable\",\n\t\t\t\t rz_mtu3_cascade_counts_enable_get,\n\t\t\t\t rz_mtu3_cascade_counts_enable_set),\n\tCOUNTER_COMP_DEVICE_ENUM(\"external_input_phase_clock_select\",\n\t\t\t\t rz_mtu3_ext_input_phase_clock_select_get,\n\t\t\t\t rz_mtu3_ext_input_phase_clock_select_set,\n\t\t\t\t rz_mtu3_ext_input_phase_clock_select_enum),\n};\n\nstatic int rz_mtu3_cnt_pm_runtime_suspend(struct device *dev)\n{\n\tstruct clk *const clk = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(clk);\n\n\treturn 0;\n}\n\nstatic int rz_mtu3_cnt_pm_runtime_resume(struct device *dev)\n{\n\tstruct clk *const clk = dev_get_drvdata(dev);\n\n\tclk_prepare_enable(clk);\n\n\treturn 0;\n}\n\nstatic DEFINE_RUNTIME_DEV_PM_OPS(rz_mtu3_cnt_pm_ops,\n\t\t\t\t rz_mtu3_cnt_pm_runtime_suspend,\n\t\t\t\t rz_mtu3_cnt_pm_runtime_resume, NULL);\n\nstatic void rz_mtu3_cnt_pm_disable(void *data)\n{\n\tstruct device *dev = data;\n\n\tpm_runtime_disable(dev);\n\tpm_runtime_set_suspended(dev);\n}\n\nstatic int rz_mtu3_cnt_probe(struct platform_device *pdev)\n{\n\tstruct rz_mtu3 *ddata = dev_get_drvdata(pdev->dev.parent);\n\tstruct device *dev = &pdev->dev;\n\tstruct counter_device *counter;\n\tstruct rz_mtu3_channel *ch;\n\tstruct rz_mtu3_cnt *priv;\n\tunsigned int i;\n\tint ret;\n\n\tcounter = devm_counter_alloc(dev, sizeof(*priv));\n\tif (!counter)\n\t\treturn -ENOMEM;\n\n\tpriv = counter_priv(counter);\n\tpriv->clk = ddata->clk;\n\tpriv->mtu_32bit_max = U32_MAX;\n\tpriv->ch = &ddata->channels[RZ_MTU3_CHAN_1];\n\tch = &priv->ch[0];\n\tfor (i = 0; i < RZ_MTU3_MAX_HW_CNTR_CHANNELS; i++) {\n\t\tch->dev = dev;\n\t\tpriv->mtu_16bit_max[i] = U16_MAX;\n\t\tch++;\n\t}\n\n\tmutex_init(&priv->lock);\n\tplatform_set_drvdata(pdev, priv->clk);\n\tclk_prepare_enable(priv->clk);\n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\tret = devm_add_action_or_reset(&pdev->dev, rz_mtu3_cnt_pm_disable, dev);\n\tif (ret < 0)\n\t\tgoto disable_clock;\n\n\tcounter->name = dev_name(dev);\n\tcounter->parent = dev;\n\tcounter->ops = &rz_mtu3_cnt_ops;\n\tcounter->counts = rz_mtu3_counts;\n\tcounter->num_counts = ARRAY_SIZE(rz_mtu3_counts);\n\tcounter->signals = rz_mtu3_signals;\n\tcounter->num_signals = ARRAY_SIZE(rz_mtu3_signals);\n\tcounter->ext = rz_mtu3_device_ext;\n\tcounter->num_ext = ARRAY_SIZE(rz_mtu3_device_ext);\n\n\t \n\tret = devm_counter_add(dev, counter);\n\tif (ret < 0) {\n\t\tdev_err_probe(dev, ret, \"Failed to add counter\\n\");\n\t\tgoto disable_clock;\n\t}\n\n\treturn 0;\n\ndisable_clock:\n\tclk_disable_unprepare(priv->clk);\n\n\treturn ret;\n}\n\nstatic struct platform_driver rz_mtu3_cnt_driver = {\n\t.probe = rz_mtu3_cnt_probe,\n\t.driver = {\n\t\t.name = \"rz-mtu3-counter\",\n\t\t.pm = pm_ptr(&rz_mtu3_cnt_pm_ops),\n\t},\n};\nmodule_platform_driver(rz_mtu3_cnt_driver);\n\nMODULE_AUTHOR(\"Biju Das <biju.das.jz@bp.renesas.com>\");\nMODULE_ALIAS(\"platform:rz-mtu3-counter\");\nMODULE_DESCRIPTION(\"Renesas RZ/G2L MTU3a counter driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(COUNTER);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}