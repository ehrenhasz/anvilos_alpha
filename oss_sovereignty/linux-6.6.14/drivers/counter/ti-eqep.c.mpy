{
  "module_name": "ti-eqep.c",
  "hash_id": "f70b246ffa68ddada6ab9db6c3f302bc67a73a34cd9cb2df78bece6b7c07872c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/counter/ti-eqep.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/counter.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/types.h>\n\n \n#define QPOSCNT\t\t0x0\n#define QPOSINIT\t0x4\n#define QPOSMAX\t\t0x8\n#define QPOSCMP\t\t0xc\n#define QPOSILAT\t0x10\n#define QPOSSLAT\t0x14\n#define QPOSLAT\t\t0x18\n#define QUTMR\t\t0x1c\n#define QUPRD\t\t0x20\n\n \n#define QWDTMR\t\t0x0\t \n#define QWDPRD\t\t0x2\t \n#define QDECCTL\t\t0x4\t \n#define QEPCTL\t\t0x6\t \n#define QCAPCTL\t\t0x8\t \n#define QPOSCTL\t\t0xa\t \n#define QEINT\t\t0xc\t \n#define QFLG\t\t0xe\t \n#define QCLR\t\t0x10\t \n#define QFRC\t\t0x12\t \n#define QEPSTS\t\t0x14\t \n#define QCTMR\t\t0x16\t \n#define QCPRD\t\t0x18\t \n#define QCTMRLAT\t0x1a\t \n#define QCPRDLAT\t0x1c\t \n\n#define QDECCTL_QSRC_SHIFT\t14\n#define QDECCTL_QSRC\t\tGENMASK(15, 14)\n#define QDECCTL_SOEN\t\tBIT(13)\n#define QDECCTL_SPSEL\t\tBIT(12)\n#define QDECCTL_XCR\t\tBIT(11)\n#define QDECCTL_SWAP\t\tBIT(10)\n#define QDECCTL_IGATE\t\tBIT(9)\n#define QDECCTL_QAP\t\tBIT(8)\n#define QDECCTL_QBP\t\tBIT(7)\n#define QDECCTL_QIP\t\tBIT(6)\n#define QDECCTL_QSP\t\tBIT(5)\n\n#define QEPCTL_FREE_SOFT\tGENMASK(15, 14)\n#define QEPCTL_PCRM\t\tGENMASK(13, 12)\n#define QEPCTL_SEI\t\tGENMASK(11, 10)\n#define QEPCTL_IEI\t\tGENMASK(9, 8)\n#define QEPCTL_SWI\t\tBIT(7)\n#define QEPCTL_SEL\t\tBIT(6)\n#define QEPCTL_IEL\t\tGENMASK(5, 4)\n#define QEPCTL_PHEN\t\tBIT(3)\n#define QEPCTL_QCLM\t\tBIT(2)\n#define QEPCTL_UTE\t\tBIT(1)\n#define QEPCTL_WDE\t\tBIT(0)\n\n \nenum {\n\tTI_EQEP_SIGNAL_QEPA,\t \n\tTI_EQEP_SIGNAL_QEPB,\t \n};\n\n \nenum ti_eqep_count_func {\n\tTI_EQEP_COUNT_FUNC_QUAD_COUNT,\n\tTI_EQEP_COUNT_FUNC_DIR_COUNT,\n\tTI_EQEP_COUNT_FUNC_UP_COUNT,\n\tTI_EQEP_COUNT_FUNC_DOWN_COUNT,\n};\n\nstruct ti_eqep_cnt {\n\tstruct counter_device counter;\n\tstruct regmap *regmap32;\n\tstruct regmap *regmap16;\n};\n\nstatic struct ti_eqep_cnt *ti_eqep_count_from_counter(struct counter_device *counter)\n{\n\treturn counter_priv(counter);\n}\n\nstatic int ti_eqep_count_read(struct counter_device *counter,\n\t\t\t      struct counter_count *count, u64 *val)\n{\n\tstruct ti_eqep_cnt *priv = ti_eqep_count_from_counter(counter);\n\tu32 cnt;\n\n\tregmap_read(priv->regmap32, QPOSCNT, &cnt);\n\t*val = cnt;\n\n\treturn 0;\n}\n\nstatic int ti_eqep_count_write(struct counter_device *counter,\n\t\t\t       struct counter_count *count, u64 val)\n{\n\tstruct ti_eqep_cnt *priv = ti_eqep_count_from_counter(counter);\n\tu32 max;\n\n\tregmap_read(priv->regmap32, QPOSMAX, &max);\n\tif (val > max)\n\t\treturn -EINVAL;\n\n\treturn regmap_write(priv->regmap32, QPOSCNT, val);\n}\n\nstatic int ti_eqep_function_read(struct counter_device *counter,\n\t\t\t\t struct counter_count *count,\n\t\t\t\t enum counter_function *function)\n{\n\tstruct ti_eqep_cnt *priv = ti_eqep_count_from_counter(counter);\n\tu32 qdecctl;\n\n\tregmap_read(priv->regmap16, QDECCTL, &qdecctl);\n\n\tswitch ((qdecctl & QDECCTL_QSRC) >> QDECCTL_QSRC_SHIFT) {\n\tcase TI_EQEP_COUNT_FUNC_QUAD_COUNT:\n\t\t*function = COUNTER_FUNCTION_QUADRATURE_X4;\n\t\tbreak;\n\tcase TI_EQEP_COUNT_FUNC_DIR_COUNT:\n\t\t*function = COUNTER_FUNCTION_PULSE_DIRECTION;\n\t\tbreak;\n\tcase TI_EQEP_COUNT_FUNC_UP_COUNT:\n\t\t*function = COUNTER_FUNCTION_INCREASE;\n\t\tbreak;\n\tcase TI_EQEP_COUNT_FUNC_DOWN_COUNT:\n\t\t*function = COUNTER_FUNCTION_DECREASE;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int ti_eqep_function_write(struct counter_device *counter,\n\t\t\t\t  struct counter_count *count,\n\t\t\t\t  enum counter_function function)\n{\n\tstruct ti_eqep_cnt *priv = ti_eqep_count_from_counter(counter);\n\tenum ti_eqep_count_func qsrc;\n\n\tswitch (function) {\n\tcase COUNTER_FUNCTION_QUADRATURE_X4:\n\t\tqsrc = TI_EQEP_COUNT_FUNC_QUAD_COUNT;\n\t\tbreak;\n\tcase COUNTER_FUNCTION_PULSE_DIRECTION:\n\t\tqsrc = TI_EQEP_COUNT_FUNC_DIR_COUNT;\n\t\tbreak;\n\tcase COUNTER_FUNCTION_INCREASE:\n\t\tqsrc = TI_EQEP_COUNT_FUNC_UP_COUNT;\n\t\tbreak;\n\tcase COUNTER_FUNCTION_DECREASE:\n\t\tqsrc = TI_EQEP_COUNT_FUNC_DOWN_COUNT;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\treturn regmap_write_bits(priv->regmap16, QDECCTL, QDECCTL_QSRC,\n\t\t\t\t qsrc << QDECCTL_QSRC_SHIFT);\n}\n\nstatic int ti_eqep_action_read(struct counter_device *counter,\n\t\t\t       struct counter_count *count,\n\t\t\t       struct counter_synapse *synapse,\n\t\t\t       enum counter_synapse_action *action)\n{\n\tstruct ti_eqep_cnt *priv = ti_eqep_count_from_counter(counter);\n\tenum counter_function function;\n\tu32 qdecctl;\n\tint err;\n\n\terr = ti_eqep_function_read(counter, count, &function);\n\tif (err)\n\t\treturn err;\n\n\tswitch (function) {\n\tcase COUNTER_FUNCTION_QUADRATURE_X4:\n\t\t \n\t\t*action = COUNTER_SYNAPSE_ACTION_BOTH_EDGES;\n\t\treturn 0;\n\tcase COUNTER_FUNCTION_PULSE_DIRECTION:\n\t\t \n\t\tswitch (synapse->signal->id) {\n\t\tcase TI_EQEP_SIGNAL_QEPA:\n\t\t\t*action = COUNTER_SYNAPSE_ACTION_RISING_EDGE;\n\t\t\treturn 0;\n\t\tcase TI_EQEP_SIGNAL_QEPB:\n\t\t\t*action = COUNTER_SYNAPSE_ACTION_NONE;\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\t \n\t\t\treturn -EINVAL;\n\t\t}\n\tcase COUNTER_FUNCTION_INCREASE:\n\tcase COUNTER_FUNCTION_DECREASE:\n\t\t \n\t\tswitch (synapse->signal->id) {\n\t\tcase TI_EQEP_SIGNAL_QEPA:\n\t\t\terr = regmap_read(priv->regmap16, QDECCTL, &qdecctl);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tif (qdecctl & QDECCTL_XCR)\n\t\t\t\t*action = COUNTER_SYNAPSE_ACTION_BOTH_EDGES;\n\t\t\telse\n\t\t\t\t*action = COUNTER_SYNAPSE_ACTION_RISING_EDGE;\n\t\t\treturn 0;\n\t\tcase TI_EQEP_SIGNAL_QEPB:\n\t\t\t*action = COUNTER_SYNAPSE_ACTION_NONE;\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\t \n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct counter_ops ti_eqep_counter_ops = {\n\t.count_read\t= ti_eqep_count_read,\n\t.count_write\t= ti_eqep_count_write,\n\t.function_read\t= ti_eqep_function_read,\n\t.function_write\t= ti_eqep_function_write,\n\t.action_read\t= ti_eqep_action_read,\n};\n\nstatic int ti_eqep_position_ceiling_read(struct counter_device *counter,\n\t\t\t\t\t struct counter_count *count,\n\t\t\t\t\t u64 *ceiling)\n{\n\tstruct ti_eqep_cnt *priv = ti_eqep_count_from_counter(counter);\n\tu32 qposmax;\n\n\tregmap_read(priv->regmap32, QPOSMAX, &qposmax);\n\n\t*ceiling = qposmax;\n\n\treturn 0;\n}\n\nstatic int ti_eqep_position_ceiling_write(struct counter_device *counter,\n\t\t\t\t\t  struct counter_count *count,\n\t\t\t\t\t  u64 ceiling)\n{\n\tstruct ti_eqep_cnt *priv = ti_eqep_count_from_counter(counter);\n\n\tif (ceiling != (u32)ceiling)\n\t\treturn -ERANGE;\n\n\tregmap_write(priv->regmap32, QPOSMAX, ceiling);\n\n\treturn 0;\n}\n\nstatic int ti_eqep_position_enable_read(struct counter_device *counter,\n\t\t\t\t\tstruct counter_count *count, u8 *enable)\n{\n\tstruct ti_eqep_cnt *priv = ti_eqep_count_from_counter(counter);\n\tu32 qepctl;\n\n\tregmap_read(priv->regmap16, QEPCTL, &qepctl);\n\n\t*enable = !!(qepctl & QEPCTL_PHEN);\n\n\treturn 0;\n}\n\nstatic int ti_eqep_position_enable_write(struct counter_device *counter,\n\t\t\t\t\t struct counter_count *count, u8 enable)\n{\n\tstruct ti_eqep_cnt *priv = ti_eqep_count_from_counter(counter);\n\n\tregmap_write_bits(priv->regmap16, QEPCTL, QEPCTL_PHEN, enable ? -1 : 0);\n\n\treturn 0;\n}\n\nstatic struct counter_comp ti_eqep_position_ext[] = {\n\tCOUNTER_COMP_CEILING(ti_eqep_position_ceiling_read,\n\t\t\t     ti_eqep_position_ceiling_write),\n\tCOUNTER_COMP_ENABLE(ti_eqep_position_enable_read,\n\t\t\t    ti_eqep_position_enable_write),\n};\n\nstatic struct counter_signal ti_eqep_signals[] = {\n\t[TI_EQEP_SIGNAL_QEPA] = {\n\t\t.id = TI_EQEP_SIGNAL_QEPA,\n\t\t.name = \"QEPA\"\n\t},\n\t[TI_EQEP_SIGNAL_QEPB] = {\n\t\t.id = TI_EQEP_SIGNAL_QEPB,\n\t\t.name = \"QEPB\"\n\t},\n};\n\nstatic const enum counter_function ti_eqep_position_functions[] = {\n\tCOUNTER_FUNCTION_QUADRATURE_X4,\n\tCOUNTER_FUNCTION_PULSE_DIRECTION,\n\tCOUNTER_FUNCTION_INCREASE,\n\tCOUNTER_FUNCTION_DECREASE,\n};\n\nstatic const enum counter_synapse_action ti_eqep_position_synapse_actions[] = {\n\tCOUNTER_SYNAPSE_ACTION_BOTH_EDGES,\n\tCOUNTER_SYNAPSE_ACTION_RISING_EDGE,\n\tCOUNTER_SYNAPSE_ACTION_NONE,\n};\n\nstatic struct counter_synapse ti_eqep_position_synapses[] = {\n\t{\n\t\t.actions_list\t= ti_eqep_position_synapse_actions,\n\t\t.num_actions\t= ARRAY_SIZE(ti_eqep_position_synapse_actions),\n\t\t.signal\t\t= &ti_eqep_signals[TI_EQEP_SIGNAL_QEPA],\n\t},\n\t{\n\t\t.actions_list\t= ti_eqep_position_synapse_actions,\n\t\t.num_actions\t= ARRAY_SIZE(ti_eqep_position_synapse_actions),\n\t\t.signal\t\t= &ti_eqep_signals[TI_EQEP_SIGNAL_QEPB],\n\t},\n};\n\nstatic struct counter_count ti_eqep_counts[] = {\n\t{\n\t\t.id\t\t= 0,\n\t\t.name\t\t= \"QPOSCNT\",\n\t\t.functions_list\t= ti_eqep_position_functions,\n\t\t.num_functions\t= ARRAY_SIZE(ti_eqep_position_functions),\n\t\t.synapses\t= ti_eqep_position_synapses,\n\t\t.num_synapses\t= ARRAY_SIZE(ti_eqep_position_synapses),\n\t\t.ext\t\t= ti_eqep_position_ext,\n\t\t.num_ext\t= ARRAY_SIZE(ti_eqep_position_ext),\n\t},\n};\n\nstatic const struct regmap_config ti_eqep_regmap32_config = {\n\t.name = \"32-bit\",\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n\t.max_register = QUPRD,\n};\n\nstatic const struct regmap_config ti_eqep_regmap16_config = {\n\t.name = \"16-bit\",\n\t.reg_bits = 16,\n\t.val_bits = 16,\n\t.reg_stride = 2,\n\t.max_register = QCPRDLAT,\n};\n\nstatic int ti_eqep_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct counter_device *counter;\n\tstruct ti_eqep_cnt *priv;\n\tvoid __iomem *base;\n\tint err;\n\n\tcounter = devm_counter_alloc(dev, sizeof(*priv));\n\tif (!counter)\n\t\treturn -ENOMEM;\n\tpriv = counter_priv(counter);\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tpriv->regmap32 = devm_regmap_init_mmio(dev, base,\n\t\t\t\t\t       &ti_eqep_regmap32_config);\n\tif (IS_ERR(priv->regmap32))\n\t\treturn PTR_ERR(priv->regmap32);\n\n\tpriv->regmap16 = devm_regmap_init_mmio(dev, base + 0x24,\n\t\t\t\t\t       &ti_eqep_regmap16_config);\n\tif (IS_ERR(priv->regmap16))\n\t\treturn PTR_ERR(priv->regmap16);\n\n\tcounter->name = dev_name(dev);\n\tcounter->parent = dev;\n\tcounter->ops = &ti_eqep_counter_ops;\n\tcounter->counts = ti_eqep_counts;\n\tcounter->num_counts = ARRAY_SIZE(ti_eqep_counts);\n\tcounter->signals = ti_eqep_signals;\n\tcounter->num_signals = ARRAY_SIZE(ti_eqep_signals);\n\n\tplatform_set_drvdata(pdev, counter);\n\n\t \n\tpm_runtime_enable(dev);\n\tpm_runtime_get_sync(dev);\n\n\terr = counter_add(counter);\n\tif (err < 0) {\n\t\tpm_runtime_put_sync(dev);\n\t\tpm_runtime_disable(dev);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int ti_eqep_remove(struct platform_device *pdev)\n{\n\tstruct counter_device *counter = platform_get_drvdata(pdev);\n\tstruct device *dev = &pdev->dev;\n\n\tcounter_unregister(counter);\n\tpm_runtime_put_sync(dev);\n\tpm_runtime_disable(dev);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id ti_eqep_of_match[] = {\n\t{ .compatible = \"ti,am3352-eqep\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, ti_eqep_of_match);\n\nstatic struct platform_driver ti_eqep_driver = {\n\t.probe = ti_eqep_probe,\n\t.remove = ti_eqep_remove,\n\t.driver = {\n\t\t.name = \"ti-eqep-cnt\",\n\t\t.of_match_table = ti_eqep_of_match,\n\t},\n};\nmodule_platform_driver(ti_eqep_driver);\n\nMODULE_AUTHOR(\"David Lechner <david@lechnology.com>\");\nMODULE_DESCRIPTION(\"TI eQEP counter driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_IMPORT_NS(COUNTER);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}