{
  "module_name": "i8254.c",
  "hash_id": "90a67395af9f8eaded89836276d1c9bfd14625ac7d44ac516a0d3fd945270330",
  "original_prompt": "Ingested from linux-6.6.14/drivers/counter/i8254.c",
  "human_readable_source": "\n \n#include <linux/bitfield.h>\n#include <linux/bits.h>\n#include <linux/counter.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/i8254.h>\n#include <linux/limits.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/regmap.h>\n\n#include <asm/unaligned.h>\n\n#define I8254_COUNTER_REG(_counter) (_counter)\n#define I8254_CONTROL_REG 0x3\n\n#define I8254_SC GENMASK(7, 6)\n#define I8254_RW GENMASK(5, 4)\n#define I8254_M GENMASK(3, 1)\n#define I8254_CONTROL(_sc, _rw, _m) \\\n\t(u8_encode_bits(_sc, I8254_SC) | u8_encode_bits(_rw, I8254_RW) | \\\n\t u8_encode_bits(_m, I8254_M))\n\n#define I8254_RW_TWO_BYTE 0x3\n#define I8254_MODE_INTERRUPT_ON_TERMINAL_COUNT 0\n#define I8254_MODE_HARDWARE_RETRIGGERABLE_ONESHOT 1\n#define I8254_MODE_RATE_GENERATOR 2\n#define I8254_MODE_SQUARE_WAVE_MODE 3\n#define I8254_MODE_SOFTWARE_TRIGGERED_STROBE 4\n#define I8254_MODE_HARDWARE_TRIGGERED_STROBE 5\n\n#define I8254_COUNTER_LATCH(_counter) I8254_CONTROL(_counter, 0x0, 0x0)\n#define I8254_PROGRAM_COUNTER(_counter, _mode) I8254_CONTROL(_counter, I8254_RW_TWO_BYTE, _mode)\n\n#define I8254_NUM_COUNTERS 3\n\n \nstruct i8254 {\n\tstruct mutex lock;\n\tu16 preset[I8254_NUM_COUNTERS];\n\tu8 out_mode[I8254_NUM_COUNTERS];\n\tstruct regmap *map;\n};\n\nstatic int i8254_count_read(struct counter_device *const counter, struct counter_count *const count,\n\t\t\t    u64 *const val)\n{\n\tstruct i8254 *const priv = counter_priv(counter);\n\tint ret;\n\tu8 value[2];\n\n\tmutex_lock(&priv->lock);\n\n\tret = regmap_write(priv->map, I8254_CONTROL_REG, I8254_COUNTER_LATCH(count->id));\n\tif (ret) {\n\t\tmutex_unlock(&priv->lock);\n\t\treturn ret;\n\t}\n\tret = regmap_noinc_read(priv->map, I8254_COUNTER_REG(count->id), value, sizeof(value));\n\tif (ret) {\n\t\tmutex_unlock(&priv->lock);\n\t\treturn ret;\n\t}\n\n\tmutex_unlock(&priv->lock);\n\n\t*val = get_unaligned_le16(value);\n\n\treturn ret;\n}\n\nstatic int i8254_function_read(struct counter_device *const counter,\n\t\t\t       struct counter_count *const count,\n\t\t\t       enum counter_function *const function)\n{\n\t*function = COUNTER_FUNCTION_DECREASE;\n\treturn 0;\n}\n\n#define I8254_SYNAPSES_PER_COUNT 2\n#define I8254_SIGNAL_ID_CLK 0\n#define I8254_SIGNAL_ID_GATE 1\n\nstatic int i8254_action_read(struct counter_device *const counter,\n\t\t\t     struct counter_count *const count,\n\t\t\t     struct counter_synapse *const synapse,\n\t\t\t     enum counter_synapse_action *const action)\n{\n\tstruct i8254 *const priv = counter_priv(counter);\n\n\tswitch (synapse->signal->id % I8254_SYNAPSES_PER_COUNT) {\n\tcase I8254_SIGNAL_ID_CLK:\n\t\t*action = COUNTER_SYNAPSE_ACTION_FALLING_EDGE;\n\t\treturn 0;\n\tcase I8254_SIGNAL_ID_GATE:\n\t\tswitch (priv->out_mode[count->id]) {\n\t\tcase I8254_MODE_HARDWARE_RETRIGGERABLE_ONESHOT:\n\t\tcase I8254_MODE_RATE_GENERATOR:\n\t\tcase I8254_MODE_SQUARE_WAVE_MODE:\n\t\tcase I8254_MODE_HARDWARE_TRIGGERED_STROBE:\n\t\t\t*action = COUNTER_SYNAPSE_ACTION_RISING_EDGE;\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\t*action = COUNTER_SYNAPSE_ACTION_NONE;\n\t\t\treturn 0;\n\t\t}\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int i8254_count_ceiling_read(struct counter_device *const counter,\n\t\t\t\t    struct counter_count *const count, u64 *const ceiling)\n{\n\tstruct i8254 *const priv = counter_priv(counter);\n\n\tmutex_lock(&priv->lock);\n\n\tswitch (priv->out_mode[count->id]) {\n\tcase I8254_MODE_RATE_GENERATOR:\n\t\t \n\t\t*ceiling = (priv->preset[count->id] == 0) ? U16_MAX : priv->preset[count->id];\n\t\tbreak;\n\tcase I8254_MODE_SQUARE_WAVE_MODE:\n\t\tif (priv->preset[count->id] % 2)\n\t\t\t*ceiling = priv->preset[count->id] - 1;\n\t\telse if (priv->preset[count->id] == 0)\n\t\t\t \n\t\t\t*ceiling = U16_MAX - 1;\n\t\telse\n\t\t\t*ceiling = priv->preset[count->id];\n\t\tbreak;\n\tdefault:\n\t\t*ceiling = U16_MAX;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&priv->lock);\n\n\treturn 0;\n}\n\nstatic int i8254_count_mode_read(struct counter_device *const counter,\n\t\t\t\t struct counter_count *const count,\n\t\t\t\t enum counter_count_mode *const count_mode)\n{\n\tconst struct i8254 *const priv = counter_priv(counter);\n\n\tswitch (priv->out_mode[count->id]) {\n\tcase I8254_MODE_INTERRUPT_ON_TERMINAL_COUNT:\n\t\t*count_mode = COUNTER_COUNT_MODE_INTERRUPT_ON_TERMINAL_COUNT;\n\t\treturn 0;\n\tcase I8254_MODE_HARDWARE_RETRIGGERABLE_ONESHOT:\n\t\t*count_mode = COUNTER_COUNT_MODE_HARDWARE_RETRIGGERABLE_ONESHOT;\n\t\treturn 0;\n\tcase I8254_MODE_RATE_GENERATOR:\n\t\t*count_mode = COUNTER_COUNT_MODE_RATE_GENERATOR;\n\t\treturn 0;\n\tcase I8254_MODE_SQUARE_WAVE_MODE:\n\t\t*count_mode = COUNTER_COUNT_MODE_SQUARE_WAVE_MODE;\n\t\treturn 0;\n\tcase I8254_MODE_SOFTWARE_TRIGGERED_STROBE:\n\t\t*count_mode = COUNTER_COUNT_MODE_SOFTWARE_TRIGGERED_STROBE;\n\t\treturn 0;\n\tcase I8254_MODE_HARDWARE_TRIGGERED_STROBE:\n\t\t*count_mode = COUNTER_COUNT_MODE_HARDWARE_TRIGGERED_STROBE;\n\t\treturn 0;\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int i8254_count_mode_write(struct counter_device *const counter,\n\t\t\t\t  struct counter_count *const count,\n\t\t\t\t  const enum counter_count_mode count_mode)\n{\n\tstruct i8254 *const priv = counter_priv(counter);\n\tu8 out_mode;\n\tint ret;\n\n\tswitch (count_mode) {\n\tcase COUNTER_COUNT_MODE_INTERRUPT_ON_TERMINAL_COUNT:\n\t\tout_mode = I8254_MODE_INTERRUPT_ON_TERMINAL_COUNT;\n\t\tbreak;\n\tcase COUNTER_COUNT_MODE_HARDWARE_RETRIGGERABLE_ONESHOT:\n\t\tout_mode = I8254_MODE_HARDWARE_RETRIGGERABLE_ONESHOT;\n\t\tbreak;\n\tcase COUNTER_COUNT_MODE_RATE_GENERATOR:\n\t\tout_mode = I8254_MODE_RATE_GENERATOR;\n\t\tbreak;\n\tcase COUNTER_COUNT_MODE_SQUARE_WAVE_MODE:\n\t\tout_mode = I8254_MODE_SQUARE_WAVE_MODE;\n\t\tbreak;\n\tcase COUNTER_COUNT_MODE_SOFTWARE_TRIGGERED_STROBE:\n\t\tout_mode = I8254_MODE_SOFTWARE_TRIGGERED_STROBE;\n\t\tbreak;\n\tcase COUNTER_COUNT_MODE_HARDWARE_TRIGGERED_STROBE:\n\t\tout_mode = I8254_MODE_HARDWARE_TRIGGERED_STROBE;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&priv->lock);\n\n\t \n\tpriv->preset[count->id] = 0;\n\tpriv->out_mode[count->id] = out_mode;\n\tret = regmap_write(priv->map, I8254_CONTROL_REG,\n\t\t\t   I8254_PROGRAM_COUNTER(count->id, out_mode));\n\n\tmutex_unlock(&priv->lock);\n\n\treturn ret;\n}\n\nstatic int i8254_count_floor_read(struct counter_device *const counter,\n\t\t\t\t  struct counter_count *const count, u64 *const floor)\n{\n\tstruct i8254 *const priv = counter_priv(counter);\n\n\tmutex_lock(&priv->lock);\n\n\tswitch (priv->out_mode[count->id]) {\n\tcase I8254_MODE_RATE_GENERATOR:\n\t\t \n\t\t*floor = (priv->preset[count->id] == 0) ? 0 : 1;\n\t\tbreak;\n\tcase I8254_MODE_SQUARE_WAVE_MODE:\n\t\t \n\t\t*floor = (priv->preset[count->id] % 2 || priv->preset[count->id] == 0) ? 0 : 2;\n\t\tbreak;\n\tdefault:\n\t\t*floor = 0;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&priv->lock);\n\n\treturn 0;\n}\n\nstatic int i8254_count_preset_read(struct counter_device *const counter,\n\t\t\t\t   struct counter_count *const count, u64 *const preset)\n{\n\tconst struct i8254 *const priv = counter_priv(counter);\n\n\t*preset = priv->preset[count->id];\n\n\treturn 0;\n}\n\nstatic int i8254_count_preset_write(struct counter_device *const counter,\n\t\t\t\t    struct counter_count *const count, const u64 preset)\n{\n\tstruct i8254 *const priv = counter_priv(counter);\n\tint ret;\n\tu8 value[2];\n\n\tif (preset > U16_MAX)\n\t\treturn -ERANGE;\n\n\tmutex_lock(&priv->lock);\n\n\tif (priv->out_mode[count->id] == I8254_MODE_RATE_GENERATOR ||\n\t    priv->out_mode[count->id] == I8254_MODE_SQUARE_WAVE_MODE) {\n\t\tif (preset == 1) {\n\t\t\tmutex_unlock(&priv->lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tpriv->preset[count->id] = preset;\n\n\tput_unaligned_le16(preset, value);\n\tret = regmap_noinc_write(priv->map, I8254_COUNTER_REG(count->id), value, 2);\n\n\tmutex_unlock(&priv->lock);\n\n\treturn ret;\n}\n\nstatic int i8254_init_hw(struct regmap *const map)\n{\n\tunsigned long i;\n\tint ret;\n\n\tfor (i = 0; i < I8254_NUM_COUNTERS; i++) {\n\t\t \n\t\tret = regmap_write(map, I8254_CONTROL_REG,\n\t\t\t\t   I8254_PROGRAM_COUNTER(i, I8254_MODE_INTERRUPT_ON_TERMINAL_COUNT));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct counter_ops i8254_ops = {\n\t.count_read = i8254_count_read,\n\t.function_read = i8254_function_read,\n\t.action_read = i8254_action_read,\n};\n\n#define I8254_SIGNAL(_id, _name) {\t\t\\\n\t.id = (_id),\t\t\t\t\\\n\t.name = (_name),\t\t\t\\\n}\n\nstatic struct counter_signal i8254_signals[] = {\n\tI8254_SIGNAL(0, \"CLK 0\"), I8254_SIGNAL(1, \"GATE 0\"),\n\tI8254_SIGNAL(2, \"CLK 1\"), I8254_SIGNAL(3, \"GATE 1\"),\n\tI8254_SIGNAL(4, \"CLK 2\"), I8254_SIGNAL(5, \"GATE 2\"),\n};\n\nstatic const enum counter_synapse_action i8254_clk_actions[] = {\n\tCOUNTER_SYNAPSE_ACTION_FALLING_EDGE,\n};\nstatic const enum counter_synapse_action i8254_gate_actions[] = {\n\tCOUNTER_SYNAPSE_ACTION_NONE,\n\tCOUNTER_SYNAPSE_ACTION_RISING_EDGE,\n};\n\n#define I8254_SYNAPSES_BASE(_id) ((_id) * I8254_SYNAPSES_PER_COUNT)\n#define I8254_SYNAPSE_CLK(_id) {\t\t\t\t\t\\\n\t.actions_list\t= i8254_clk_actions,\t\t\t\t\\\n\t.num_actions\t= ARRAY_SIZE(i8254_clk_actions),\t\t\\\n\t.signal\t\t= &i8254_signals[I8254_SYNAPSES_BASE(_id) + 0],\t\\\n}\n#define I8254_SYNAPSE_GATE(_id) {\t\t\t\t\t\\\n\t.actions_list\t= i8254_gate_actions,\t\t\t\t\\\n\t.num_actions\t= ARRAY_SIZE(i8254_gate_actions),\t\t\\\n\t.signal\t\t= &i8254_signals[I8254_SYNAPSES_BASE(_id) + 1],\t\\\n}\n\nstatic struct counter_synapse i8254_synapses[] = {\n\tI8254_SYNAPSE_CLK(0), I8254_SYNAPSE_GATE(0),\n\tI8254_SYNAPSE_CLK(1), I8254_SYNAPSE_GATE(1),\n\tI8254_SYNAPSE_CLK(2), I8254_SYNAPSE_GATE(2),\n};\n\nstatic const enum counter_function i8254_functions_list[] = {\n\tCOUNTER_FUNCTION_DECREASE,\n};\n\nstatic const enum counter_count_mode i8254_count_modes[] = {\n\tCOUNTER_COUNT_MODE_INTERRUPT_ON_TERMINAL_COUNT,\n\tCOUNTER_COUNT_MODE_HARDWARE_RETRIGGERABLE_ONESHOT,\n\tCOUNTER_COUNT_MODE_RATE_GENERATOR,\n\tCOUNTER_COUNT_MODE_SQUARE_WAVE_MODE,\n\tCOUNTER_COUNT_MODE_SOFTWARE_TRIGGERED_STROBE,\n\tCOUNTER_COUNT_MODE_HARDWARE_TRIGGERED_STROBE,\n};\n\nstatic DEFINE_COUNTER_AVAILABLE(i8254_count_modes_available, i8254_count_modes);\n\nstatic struct counter_comp i8254_count_ext[] = {\n\tCOUNTER_COMP_CEILING(i8254_count_ceiling_read, NULL),\n\tCOUNTER_COMP_COUNT_MODE(i8254_count_mode_read, i8254_count_mode_write,\n\t\t\t\ti8254_count_modes_available),\n\tCOUNTER_COMP_FLOOR(i8254_count_floor_read, NULL),\n\tCOUNTER_COMP_PRESET(i8254_count_preset_read, i8254_count_preset_write),\n};\n\n#define I8254_COUNT(_id, _name) {\t\t\t\t\\\n\t.id = (_id),\t\t\t\t\t\t\\\n\t.name = (_name),\t\t\t\t\t\\\n\t.functions_list = i8254_functions_list,\t\t\t\\\n\t.num_functions = ARRAY_SIZE(i8254_functions_list),\t\\\n\t.synapses = &i8254_synapses[I8254_SYNAPSES_BASE(_id)],\t\\\n\t.num_synapses =\tI8254_SYNAPSES_PER_COUNT,\t\t\\\n\t.ext = i8254_count_ext,\t\t\t\t\t\\\n\t.num_ext = ARRAY_SIZE(i8254_count_ext)\t\t\t\\\n}\n\nstatic struct counter_count i8254_counts[I8254_NUM_COUNTERS] = {\n\tI8254_COUNT(0, \"Counter 0\"), I8254_COUNT(1, \"Counter 1\"), I8254_COUNT(2, \"Counter 2\"),\n};\n\n \nint devm_i8254_regmap_register(struct device *const dev,\n\t\t\t       const struct i8254_regmap_config *const config)\n{\n\tstruct counter_device *counter;\n\tstruct i8254 *priv;\n\tint err;\n\n\tif (!config->parent)\n\t\treturn -EINVAL;\n\n\tif (!config->map)\n\t\treturn -EINVAL;\n\n\tcounter = devm_counter_alloc(dev, sizeof(*priv));\n\tif (!counter)\n\t\treturn -ENOMEM;\n\tpriv = counter_priv(counter);\n\tpriv->map = config->map;\n\n\tcounter->name = dev_name(config->parent);\n\tcounter->parent = config->parent;\n\tcounter->ops = &i8254_ops;\n\tcounter->counts = i8254_counts;\n\tcounter->num_counts = ARRAY_SIZE(i8254_counts);\n\tcounter->signals = i8254_signals;\n\tcounter->num_signals = ARRAY_SIZE(i8254_signals);\n\n\tmutex_init(&priv->lock);\n\n\terr = i8254_init_hw(priv->map);\n\tif (err)\n\t\treturn err;\n\n\terr = devm_counter_add(dev, counter);\n\tif (err < 0)\n\t\treturn dev_err_probe(dev, err, \"Failed to add counter\\n\");\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(devm_i8254_regmap_register, I8254);\n\nMODULE_AUTHOR(\"William Breathitt Gray\");\nMODULE_DESCRIPTION(\"Intel 8254 Programmable Interval Timer\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(COUNTER);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}