{
  "module_name": "microchip-tcb-capture.c",
  "hash_id": "1add666f867377eb71643ce9140289a9b225430feb7526c07fd8d2e952a724b1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/counter/microchip-tcb-capture.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/counter.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <soc/at91/atmel_tcb.h>\n\n#define ATMEL_TC_CMR_MASK\t(ATMEL_TC_LDRA_RISING | ATMEL_TC_LDRB_FALLING | \\\n\t\t\t\t ATMEL_TC_ETRGEDG_RISING | ATMEL_TC_LDBDIS | \\\n\t\t\t\t ATMEL_TC_LDBSTOP)\n\n#define ATMEL_TC_QDEN\t\t\tBIT(8)\n#define ATMEL_TC_POSEN\t\t\tBIT(9)\n\nstruct mchp_tc_data {\n\tconst struct atmel_tcb_config *tc_cfg;\n\tstruct regmap *regmap;\n\tint qdec_mode;\n\tint num_channels;\n\tint channel[2];\n};\n\nstatic const enum counter_function mchp_tc_count_functions[] = {\n\tCOUNTER_FUNCTION_INCREASE,\n\tCOUNTER_FUNCTION_QUADRATURE_X4,\n};\n\nstatic const enum counter_synapse_action mchp_tc_synapse_actions[] = {\n\tCOUNTER_SYNAPSE_ACTION_NONE,\n\tCOUNTER_SYNAPSE_ACTION_RISING_EDGE,\n\tCOUNTER_SYNAPSE_ACTION_FALLING_EDGE,\n\tCOUNTER_SYNAPSE_ACTION_BOTH_EDGES,\n};\n\nstatic struct counter_signal mchp_tc_count_signals[] = {\n\t{\n\t\t.id = 0,\n\t\t.name = \"Channel A\",\n\t},\n\t{\n\t\t.id = 1,\n\t\t.name = \"Channel B\",\n\t}\n};\n\nstatic struct counter_synapse mchp_tc_count_synapses[] = {\n\t{\n\t\t.actions_list = mchp_tc_synapse_actions,\n\t\t.num_actions = ARRAY_SIZE(mchp_tc_synapse_actions),\n\t\t.signal = &mchp_tc_count_signals[0]\n\t},\n\t{\n\t\t.actions_list = mchp_tc_synapse_actions,\n\t\t.num_actions = ARRAY_SIZE(mchp_tc_synapse_actions),\n\t\t.signal = &mchp_tc_count_signals[1]\n\t}\n};\n\nstatic int mchp_tc_count_function_read(struct counter_device *counter,\n\t\t\t\t       struct counter_count *count,\n\t\t\t\t       enum counter_function *function)\n{\n\tstruct mchp_tc_data *const priv = counter_priv(counter);\n\n\tif (priv->qdec_mode)\n\t\t*function = COUNTER_FUNCTION_QUADRATURE_X4;\n\telse\n\t\t*function = COUNTER_FUNCTION_INCREASE;\n\n\treturn 0;\n}\n\nstatic int mchp_tc_count_function_write(struct counter_device *counter,\n\t\t\t\t\tstruct counter_count *count,\n\t\t\t\t\tenum counter_function function)\n{\n\tstruct mchp_tc_data *const priv = counter_priv(counter);\n\tu32 bmr, cmr;\n\n\tregmap_read(priv->regmap, ATMEL_TC_BMR, &bmr);\n\tregmap_read(priv->regmap, ATMEL_TC_REG(priv->channel[0], CMR), &cmr);\n\n\t \n\tcmr &= ~ATMEL_TC_WAVE;\n\n\tswitch (function) {\n\tcase COUNTER_FUNCTION_INCREASE:\n\t\tpriv->qdec_mode = 0;\n\t\t \n\t\tbmr &= ~(ATMEL_TC_QDEN | ATMEL_TC_POSEN);\n\t\tif (!priv->tc_cfg->has_gclk)\n\t\t\tcmr |= ATMEL_TC_TIMER_CLOCK2;\n\t\telse\n\t\t\tcmr |= ATMEL_TC_TIMER_CLOCK1;\n\t\t \n\t\tcmr |=  ATMEL_TC_CMR_MASK;\n\t\tcmr &= ~(ATMEL_TC_ABETRG | ATMEL_TC_XC0);\n\t\tbreak;\n\tcase COUNTER_FUNCTION_QUADRATURE_X4:\n\t\tif (!priv->tc_cfg->has_qdec)\n\t\t\treturn -EINVAL;\n\t\t \n\t\tif (priv->num_channels < 2 || priv->channel[0] != 0 ||\n\t\t    priv->channel[1] != 1) {\n\t\t\tpr_err(\"Invalid channels number or id for quadrature mode\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpriv->qdec_mode = 1;\n\t\tbmr |= ATMEL_TC_QDEN | ATMEL_TC_POSEN;\n\t\tcmr |= ATMEL_TC_ETRGEDG_RISING | ATMEL_TC_ABETRG | ATMEL_TC_XC0;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\tregmap_write(priv->regmap, ATMEL_TC_BMR, bmr);\n\tregmap_write(priv->regmap, ATMEL_TC_REG(priv->channel[0], CMR), cmr);\n\n\t \n\tregmap_write(priv->regmap, ATMEL_TC_REG(priv->channel[0], CCR),\n\t\t     ATMEL_TC_CLKEN | ATMEL_TC_SWTRG);\n\n\tif (priv->qdec_mode) {\n\t\tregmap_write(priv->regmap,\n\t\t\t     ATMEL_TC_REG(priv->channel[1], CMR), cmr);\n\t\tregmap_write(priv->regmap,\n\t\t\t     ATMEL_TC_REG(priv->channel[1], CCR),\n\t\t\t     ATMEL_TC_CLKEN | ATMEL_TC_SWTRG);\n\t}\n\n\treturn 0;\n}\n\nstatic int mchp_tc_count_signal_read(struct counter_device *counter,\n\t\t\t\t     struct counter_signal *signal,\n\t\t\t\t     enum counter_signal_level *lvl)\n{\n\tstruct mchp_tc_data *const priv = counter_priv(counter);\n\tbool sigstatus;\n\tu32 sr;\n\n\tregmap_read(priv->regmap, ATMEL_TC_REG(priv->channel[0], SR), &sr);\n\n\tif (signal->id == 1)\n\t\tsigstatus = (sr & ATMEL_TC_MTIOB);\n\telse\n\t\tsigstatus = (sr & ATMEL_TC_MTIOA);\n\n\t*lvl = sigstatus ? COUNTER_SIGNAL_LEVEL_HIGH : COUNTER_SIGNAL_LEVEL_LOW;\n\n\treturn 0;\n}\n\nstatic int mchp_tc_count_action_read(struct counter_device *counter,\n\t\t\t\t     struct counter_count *count,\n\t\t\t\t     struct counter_synapse *synapse,\n\t\t\t\t     enum counter_synapse_action *action)\n{\n\tstruct mchp_tc_data *const priv = counter_priv(counter);\n\tu32 cmr;\n\n\tif (priv->qdec_mode) {\n\t\t*action = COUNTER_SYNAPSE_ACTION_BOTH_EDGES;\n\t\treturn 0;\n\t}\n\n\t \n\tif (synapse->signal->id != 0) {\n\t\t*action = COUNTER_SYNAPSE_ACTION_NONE;\n\t\treturn 0;\n\t}\n\n\tregmap_read(priv->regmap, ATMEL_TC_REG(priv->channel[0], CMR), &cmr);\n\n\tswitch (cmr & ATMEL_TC_ETRGEDG) {\n\tdefault:\n\t\t*action = COUNTER_SYNAPSE_ACTION_NONE;\n\t\tbreak;\n\tcase ATMEL_TC_ETRGEDG_RISING:\n\t\t*action = COUNTER_SYNAPSE_ACTION_RISING_EDGE;\n\t\tbreak;\n\tcase ATMEL_TC_ETRGEDG_FALLING:\n\t\t*action = COUNTER_SYNAPSE_ACTION_FALLING_EDGE;\n\t\tbreak;\n\tcase ATMEL_TC_ETRGEDG_BOTH:\n\t\t*action = COUNTER_SYNAPSE_ACTION_BOTH_EDGES;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int mchp_tc_count_action_write(struct counter_device *counter,\n\t\t\t\t      struct counter_count *count,\n\t\t\t\t      struct counter_synapse *synapse,\n\t\t\t\t      enum counter_synapse_action action)\n{\n\tstruct mchp_tc_data *const priv = counter_priv(counter);\n\tu32 edge = ATMEL_TC_ETRGEDG_NONE;\n\n\t \n\tif (priv->qdec_mode || synapse->signal->id != 0)\n\t\treturn -EINVAL;\n\n\tswitch (action) {\n\tcase COUNTER_SYNAPSE_ACTION_NONE:\n\t\tedge = ATMEL_TC_ETRGEDG_NONE;\n\t\tbreak;\n\tcase COUNTER_SYNAPSE_ACTION_RISING_EDGE:\n\t\tedge = ATMEL_TC_ETRGEDG_RISING;\n\t\tbreak;\n\tcase COUNTER_SYNAPSE_ACTION_FALLING_EDGE:\n\t\tedge = ATMEL_TC_ETRGEDG_FALLING;\n\t\tbreak;\n\tcase COUNTER_SYNAPSE_ACTION_BOTH_EDGES:\n\t\tedge = ATMEL_TC_ETRGEDG_BOTH;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\treturn regmap_write_bits(priv->regmap,\n\t\t\t\tATMEL_TC_REG(priv->channel[0], CMR),\n\t\t\t\tATMEL_TC_ETRGEDG, edge);\n}\n\nstatic int mchp_tc_count_read(struct counter_device *counter,\n\t\t\t      struct counter_count *count, u64 *val)\n{\n\tstruct mchp_tc_data *const priv = counter_priv(counter);\n\tu32 cnt;\n\n\tregmap_read(priv->regmap, ATMEL_TC_REG(priv->channel[0], CV), &cnt);\n\t*val = cnt;\n\n\treturn 0;\n}\n\nstatic struct counter_count mchp_tc_counts[] = {\n\t{\n\t\t.id = 0,\n\t\t.name = \"Timer Counter\",\n\t\t.functions_list = mchp_tc_count_functions,\n\t\t.num_functions = ARRAY_SIZE(mchp_tc_count_functions),\n\t\t.synapses = mchp_tc_count_synapses,\n\t\t.num_synapses = ARRAY_SIZE(mchp_tc_count_synapses),\n\t},\n};\n\nstatic const struct counter_ops mchp_tc_ops = {\n\t.signal_read    = mchp_tc_count_signal_read,\n\t.count_read     = mchp_tc_count_read,\n\t.function_read  = mchp_tc_count_function_read,\n\t.function_write = mchp_tc_count_function_write,\n\t.action_read    = mchp_tc_count_action_read,\n\t.action_write   = mchp_tc_count_action_write\n};\n\nstatic const struct atmel_tcb_config tcb_rm9200_config = {\n\t\t.counter_width = 16,\n};\n\nstatic const struct atmel_tcb_config tcb_sam9x5_config = {\n\t\t.counter_width = 32,\n};\n\nstatic const struct atmel_tcb_config tcb_sama5d2_config = {\n\t\t.counter_width = 32,\n\t\t.has_gclk = true,\n\t\t.has_qdec = true,\n};\n\nstatic const struct atmel_tcb_config tcb_sama5d3_config = {\n\t\t.counter_width = 32,\n\t\t.has_qdec = true,\n};\n\nstatic const struct of_device_id atmel_tc_of_match[] = {\n\t{ .compatible = \"atmel,at91rm9200-tcb\", .data = &tcb_rm9200_config, },\n\t{ .compatible = \"atmel,at91sam9x5-tcb\", .data = &tcb_sam9x5_config, },\n\t{ .compatible = \"atmel,sama5d2-tcb\", .data = &tcb_sama5d2_config, },\n\t{ .compatible = \"atmel,sama5d3-tcb\", .data = &tcb_sama5d3_config, },\n\t{   }\n};\n\nstatic void mchp_tc_clk_remove(void *ptr)\n{\n\tclk_disable_unprepare((struct clk *)ptr);\n}\n\nstatic int mchp_tc_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tconst struct atmel_tcb_config *tcb_config;\n\tconst struct of_device_id *match;\n\tstruct counter_device *counter;\n\tstruct mchp_tc_data *priv;\n\tchar clk_name[7];\n\tstruct regmap *regmap;\n\tstruct clk *clk[3];\n\tint channel;\n\tint ret, i;\n\n\tcounter = devm_counter_alloc(&pdev->dev, sizeof(*priv));\n\tif (!counter)\n\t\treturn -ENOMEM;\n\tpriv = counter_priv(counter);\n\n\tmatch = of_match_node(atmel_tc_of_match, np->parent);\n\ttcb_config = match->data;\n\tif (!tcb_config) {\n\t\tdev_err(&pdev->dev, \"No matching parent node found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tregmap = syscon_node_to_regmap(np->parent);\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\t \n\tpriv->num_channels = of_property_count_u32_elems(np, \"reg\");\n\tif (priv->num_channels < 0) {\n\t\tdev_err(&pdev->dev, \"Invalid or missing channel\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor (i = 0; i < priv->num_channels; i++) {\n\t\tret = of_property_read_u32_index(np, \"reg\", i, &channel);\n\t\tif (ret < 0 || channel > 2)\n\t\t\treturn -ENODEV;\n\n\t\tpriv->channel[i] = channel;\n\n\t\tsnprintf(clk_name, sizeof(clk_name), \"t%d_clk\", channel);\n\n\t\tclk[i] = of_clk_get_by_name(np->parent, clk_name);\n\t\tif (IS_ERR(clk[i])) {\n\t\t\t \n\t\t\tclk[i] = of_clk_get_by_name(np->parent, \"t0_clk\");\n\t\t\tif (IS_ERR(clk[i]))\n\t\t\t\treturn PTR_ERR(clk[i]);\n\t\t}\n\n\t\tret = clk_prepare_enable(clk[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = devm_add_action_or_reset(&pdev->dev,\n\t\t\t\t\t       mchp_tc_clk_remove,\n\t\t\t\t\t       clk[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdev_dbg(&pdev->dev,\n\t\t\t\"Initialized capture mode on channel %d\\n\",\n\t\t\tchannel);\n\t}\n\n\tpriv->tc_cfg = tcb_config;\n\tpriv->regmap = regmap;\n\tcounter->name = dev_name(&pdev->dev);\n\tcounter->parent = &pdev->dev;\n\tcounter->ops = &mchp_tc_ops;\n\tcounter->num_counts = ARRAY_SIZE(mchp_tc_counts);\n\tcounter->counts = mchp_tc_counts;\n\tcounter->num_signals = ARRAY_SIZE(mchp_tc_count_signals);\n\tcounter->signals = mchp_tc_count_signals;\n\n\tret = devm_counter_add(&pdev->dev, counter);\n\tif (ret < 0)\n\t\treturn dev_err_probe(&pdev->dev, ret, \"Failed to add counter\\n\");\n\n\treturn 0;\n}\n\nstatic const struct of_device_id mchp_tc_dt_ids[] = {\n\t{ .compatible = \"microchip,tcb-capture\", },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, mchp_tc_dt_ids);\n\nstatic struct platform_driver mchp_tc_driver = {\n\t.probe = mchp_tc_probe,\n\t.driver = {\n\t\t.name = \"microchip-tcb-capture\",\n\t\t.of_match_table = mchp_tc_dt_ids,\n\t},\n};\nmodule_platform_driver(mchp_tc_driver);\n\nMODULE_AUTHOR(\"Kamel Bouhara <kamel.bouhara@bootlin.com>\");\nMODULE_DESCRIPTION(\"Microchip TCB Capture driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_IMPORT_NS(COUNTER);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}