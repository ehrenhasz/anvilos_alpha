{
  "module_name": "stm32-timer-cnt.c",
  "hash_id": "bdfbc4513cf69174e2d26c4fc86293b4c50c3278c29bf4400d03dde726003a7e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/counter/stm32-timer-cnt.c",
  "human_readable_source": "\n \n#include <linux/counter.h>\n#include <linux/mfd/stm32-timers.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/types.h>\n\n#define TIM_CCMR_CCXS\t(BIT(8) | BIT(0))\n#define TIM_CCMR_MASK\t(TIM_CCMR_CC1S | TIM_CCMR_CC2S | \\\n\t\t\t TIM_CCMR_IC1F | TIM_CCMR_IC2F)\n#define TIM_CCER_MASK\t(TIM_CCER_CC1P | TIM_CCER_CC1NP | \\\n\t\t\t TIM_CCER_CC2P | TIM_CCER_CC2NP)\n\nstruct stm32_timer_regs {\n\tu32 cr1;\n\tu32 cnt;\n\tu32 smcr;\n\tu32 arr;\n};\n\nstruct stm32_timer_cnt {\n\tstruct regmap *regmap;\n\tstruct clk *clk;\n\tu32 max_arr;\n\tbool enabled;\n\tstruct stm32_timer_regs bak;\n};\n\nstatic const enum counter_function stm32_count_functions[] = {\n\tCOUNTER_FUNCTION_INCREASE,\n\tCOUNTER_FUNCTION_QUADRATURE_X2_A,\n\tCOUNTER_FUNCTION_QUADRATURE_X2_B,\n\tCOUNTER_FUNCTION_QUADRATURE_X4,\n};\n\nstatic int stm32_count_read(struct counter_device *counter,\n\t\t\t    struct counter_count *count, u64 *val)\n{\n\tstruct stm32_timer_cnt *const priv = counter_priv(counter);\n\tu32 cnt;\n\n\tregmap_read(priv->regmap, TIM_CNT, &cnt);\n\t*val = cnt;\n\n\treturn 0;\n}\n\nstatic int stm32_count_write(struct counter_device *counter,\n\t\t\t     struct counter_count *count, const u64 val)\n{\n\tstruct stm32_timer_cnt *const priv = counter_priv(counter);\n\tu32 ceiling;\n\n\tregmap_read(priv->regmap, TIM_ARR, &ceiling);\n\tif (val > ceiling)\n\t\treturn -EINVAL;\n\n\treturn regmap_write(priv->regmap, TIM_CNT, val);\n}\n\nstatic int stm32_count_function_read(struct counter_device *counter,\n\t\t\t\t     struct counter_count *count,\n\t\t\t\t     enum counter_function *function)\n{\n\tstruct stm32_timer_cnt *const priv = counter_priv(counter);\n\tu32 smcr;\n\n\tregmap_read(priv->regmap, TIM_SMCR, &smcr);\n\n\tswitch (smcr & TIM_SMCR_SMS) {\n\tcase TIM_SMCR_SMS_SLAVE_MODE_DISABLED:\n\t\t*function = COUNTER_FUNCTION_INCREASE;\n\t\treturn 0;\n\tcase TIM_SMCR_SMS_ENCODER_MODE_1:\n\t\t*function = COUNTER_FUNCTION_QUADRATURE_X2_A;\n\t\treturn 0;\n\tcase TIM_SMCR_SMS_ENCODER_MODE_2:\n\t\t*function = COUNTER_FUNCTION_QUADRATURE_X2_B;\n\t\treturn 0;\n\tcase TIM_SMCR_SMS_ENCODER_MODE_3:\n\t\t*function = COUNTER_FUNCTION_QUADRATURE_X4;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int stm32_count_function_write(struct counter_device *counter,\n\t\t\t\t      struct counter_count *count,\n\t\t\t\t      enum counter_function function)\n{\n\tstruct stm32_timer_cnt *const priv = counter_priv(counter);\n\tu32 cr1, sms;\n\n\tswitch (function) {\n\tcase COUNTER_FUNCTION_INCREASE:\n\t\tsms = TIM_SMCR_SMS_SLAVE_MODE_DISABLED;\n\t\tbreak;\n\tcase COUNTER_FUNCTION_QUADRATURE_X2_A:\n\t\tsms = TIM_SMCR_SMS_ENCODER_MODE_1;\n\t\tbreak;\n\tcase COUNTER_FUNCTION_QUADRATURE_X2_B:\n\t\tsms = TIM_SMCR_SMS_ENCODER_MODE_2;\n\t\tbreak;\n\tcase COUNTER_FUNCTION_QUADRATURE_X4:\n\t\tsms = TIM_SMCR_SMS_ENCODER_MODE_3;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tregmap_read(priv->regmap, TIM_CR1, &cr1);\n\n\tregmap_update_bits(priv->regmap, TIM_CR1, TIM_CR1_CEN, 0);\n\n\tregmap_update_bits(priv->regmap, TIM_SMCR, TIM_SMCR_SMS, sms);\n\n\t \n\tregmap_update_bits(priv->regmap, TIM_EGR, TIM_EGR_UG, TIM_EGR_UG);\n\n\t \n\tregmap_update_bits(priv->regmap, TIM_CR1, TIM_CR1_CEN, cr1);\n\n\treturn 0;\n}\n\nstatic int stm32_count_direction_read(struct counter_device *counter,\n\t\t\t\t      struct counter_count *count,\n\t\t\t\t      enum counter_count_direction *direction)\n{\n\tstruct stm32_timer_cnt *const priv = counter_priv(counter);\n\tu32 cr1;\n\n\tregmap_read(priv->regmap, TIM_CR1, &cr1);\n\t*direction = (cr1 & TIM_CR1_DIR) ? COUNTER_COUNT_DIRECTION_BACKWARD :\n\t\tCOUNTER_COUNT_DIRECTION_FORWARD;\n\n\treturn 0;\n}\n\nstatic int stm32_count_ceiling_read(struct counter_device *counter,\n\t\t\t\t    struct counter_count *count, u64 *ceiling)\n{\n\tstruct stm32_timer_cnt *const priv = counter_priv(counter);\n\tu32 arr;\n\n\tregmap_read(priv->regmap, TIM_ARR, &arr);\n\n\t*ceiling = arr;\n\n\treturn 0;\n}\n\nstatic int stm32_count_ceiling_write(struct counter_device *counter,\n\t\t\t\t     struct counter_count *count, u64 ceiling)\n{\n\tstruct stm32_timer_cnt *const priv = counter_priv(counter);\n\n\tif (ceiling > priv->max_arr)\n\t\treturn -ERANGE;\n\n\t \n\tregmap_update_bits(priv->regmap, TIM_CR1, TIM_CR1_ARPE, 0);\n\tregmap_write(priv->regmap, TIM_ARR, ceiling);\n\n\treturn 0;\n}\n\nstatic int stm32_count_enable_read(struct counter_device *counter,\n\t\t\t\t   struct counter_count *count, u8 *enable)\n{\n\tstruct stm32_timer_cnt *const priv = counter_priv(counter);\n\tu32 cr1;\n\n\tregmap_read(priv->regmap, TIM_CR1, &cr1);\n\n\t*enable = cr1 & TIM_CR1_CEN;\n\n\treturn 0;\n}\n\nstatic int stm32_count_enable_write(struct counter_device *counter,\n\t\t\t\t    struct counter_count *count, u8 enable)\n{\n\tstruct stm32_timer_cnt *const priv = counter_priv(counter);\n\tu32 cr1;\n\n\tif (enable) {\n\t\tregmap_read(priv->regmap, TIM_CR1, &cr1);\n\t\tif (!(cr1 & TIM_CR1_CEN))\n\t\t\tclk_enable(priv->clk);\n\n\t\tregmap_update_bits(priv->regmap, TIM_CR1, TIM_CR1_CEN,\n\t\t\t\t   TIM_CR1_CEN);\n\t} else {\n\t\tregmap_read(priv->regmap, TIM_CR1, &cr1);\n\t\tregmap_update_bits(priv->regmap, TIM_CR1, TIM_CR1_CEN, 0);\n\t\tif (cr1 & TIM_CR1_CEN)\n\t\t\tclk_disable(priv->clk);\n\t}\n\n\t \n\tpriv->enabled = enable;\n\n\treturn 0;\n}\n\nstatic struct counter_comp stm32_count_ext[] = {\n\tCOUNTER_COMP_DIRECTION(stm32_count_direction_read),\n\tCOUNTER_COMP_ENABLE(stm32_count_enable_read, stm32_count_enable_write),\n\tCOUNTER_COMP_CEILING(stm32_count_ceiling_read,\n\t\t\t     stm32_count_ceiling_write),\n};\n\nstatic const enum counter_synapse_action stm32_synapse_actions[] = {\n\tCOUNTER_SYNAPSE_ACTION_NONE,\n\tCOUNTER_SYNAPSE_ACTION_BOTH_EDGES\n};\n\nstatic int stm32_action_read(struct counter_device *counter,\n\t\t\t     struct counter_count *count,\n\t\t\t     struct counter_synapse *synapse,\n\t\t\t     enum counter_synapse_action *action)\n{\n\tenum counter_function function;\n\tint err;\n\n\terr = stm32_count_function_read(counter, count, &function);\n\tif (err)\n\t\treturn err;\n\n\tswitch (function) {\n\tcase COUNTER_FUNCTION_INCREASE:\n\t\t \n\t\t*action = COUNTER_SYNAPSE_ACTION_NONE;\n\t\treturn 0;\n\tcase COUNTER_FUNCTION_QUADRATURE_X2_A:\n\t\t \n\t\tif (synapse->signal->id == count->synapses[0].signal->id)\n\t\t\t*action = COUNTER_SYNAPSE_ACTION_BOTH_EDGES;\n\t\telse\n\t\t\t*action = COUNTER_SYNAPSE_ACTION_NONE;\n\t\treturn 0;\n\tcase COUNTER_FUNCTION_QUADRATURE_X2_B:\n\t\t \n\t\tif (synapse->signal->id == count->synapses[1].signal->id)\n\t\t\t*action = COUNTER_SYNAPSE_ACTION_BOTH_EDGES;\n\t\telse\n\t\t\t*action = COUNTER_SYNAPSE_ACTION_NONE;\n\t\treturn 0;\n\tcase COUNTER_FUNCTION_QUADRATURE_X4:\n\t\t \n\t\t*action = COUNTER_SYNAPSE_ACTION_BOTH_EDGES;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct counter_ops stm32_timer_cnt_ops = {\n\t.count_read = stm32_count_read,\n\t.count_write = stm32_count_write,\n\t.function_read = stm32_count_function_read,\n\t.function_write = stm32_count_function_write,\n\t.action_read = stm32_action_read,\n};\n\nstatic struct counter_signal stm32_signals[] = {\n\t{\n\t\t.id = 0,\n\t\t.name = \"Channel 1 Quadrature A\"\n\t},\n\t{\n\t\t.id = 1,\n\t\t.name = \"Channel 1 Quadrature B\"\n\t}\n};\n\nstatic struct counter_synapse stm32_count_synapses[] = {\n\t{\n\t\t.actions_list = stm32_synapse_actions,\n\t\t.num_actions = ARRAY_SIZE(stm32_synapse_actions),\n\t\t.signal = &stm32_signals[0]\n\t},\n\t{\n\t\t.actions_list = stm32_synapse_actions,\n\t\t.num_actions = ARRAY_SIZE(stm32_synapse_actions),\n\t\t.signal = &stm32_signals[1]\n\t}\n};\n\nstatic struct counter_count stm32_counts = {\n\t.id = 0,\n\t.name = \"Channel 1 Count\",\n\t.functions_list = stm32_count_functions,\n\t.num_functions = ARRAY_SIZE(stm32_count_functions),\n\t.synapses = stm32_count_synapses,\n\t.num_synapses = ARRAY_SIZE(stm32_count_synapses),\n\t.ext = stm32_count_ext,\n\t.num_ext = ARRAY_SIZE(stm32_count_ext)\n};\n\nstatic int stm32_timer_cnt_probe(struct platform_device *pdev)\n{\n\tstruct stm32_timers *ddata = dev_get_drvdata(pdev->dev.parent);\n\tstruct device *dev = &pdev->dev;\n\tstruct stm32_timer_cnt *priv;\n\tstruct counter_device *counter;\n\tint ret;\n\n\tif (IS_ERR_OR_NULL(ddata))\n\t\treturn -EINVAL;\n\n\tcounter = devm_counter_alloc(dev, sizeof(*priv));\n\tif (!counter)\n\t\treturn -ENOMEM;\n\n\tpriv = counter_priv(counter);\n\n\tpriv->regmap = ddata->regmap;\n\tpriv->clk = ddata->clk;\n\tpriv->max_arr = ddata->max_arr;\n\n\tcounter->name = dev_name(dev);\n\tcounter->parent = dev;\n\tcounter->ops = &stm32_timer_cnt_ops;\n\tcounter->counts = &stm32_counts;\n\tcounter->num_counts = 1;\n\tcounter->signals = stm32_signals;\n\tcounter->num_signals = ARRAY_SIZE(stm32_signals);\n\n\tplatform_set_drvdata(pdev, priv);\n\n\t \n\tregmap_write(priv->regmap, TIM_TISEL, 0x0);\n\n\t \n\tret = devm_counter_add(dev, counter);\n\tif (ret < 0)\n\t\tdev_err_probe(dev, ret, \"Failed to add counter\\n\");\n\n\treturn ret;\n}\n\nstatic int __maybe_unused stm32_timer_cnt_suspend(struct device *dev)\n{\n\tstruct stm32_timer_cnt *priv = dev_get_drvdata(dev);\n\n\t \n\tif (priv->enabled) {\n\t\t \n\t\tregmap_read(priv->regmap, TIM_SMCR, &priv->bak.smcr);\n\t\tregmap_read(priv->regmap, TIM_ARR, &priv->bak.arr);\n\t\tregmap_read(priv->regmap, TIM_CNT, &priv->bak.cnt);\n\t\tregmap_read(priv->regmap, TIM_CR1, &priv->bak.cr1);\n\n\t\t \n\t\tregmap_update_bits(priv->regmap, TIM_CR1, TIM_CR1_CEN, 0);\n\t\tclk_disable(priv->clk);\n\t}\n\n\treturn pinctrl_pm_select_sleep_state(dev);\n}\n\nstatic int __maybe_unused stm32_timer_cnt_resume(struct device *dev)\n{\n\tstruct stm32_timer_cnt *priv = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = pinctrl_pm_select_default_state(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (priv->enabled) {\n\t\tclk_enable(priv->clk);\n\n\t\t \n\t\tregmap_write(priv->regmap, TIM_SMCR, priv->bak.smcr);\n\t\tregmap_write(priv->regmap, TIM_ARR, priv->bak.arr);\n\t\tregmap_write(priv->regmap, TIM_CNT, priv->bak.cnt);\n\n\t\t \n\t\tregmap_write(priv->regmap, TIM_CR1, priv->bak.cr1);\n\t}\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(stm32_timer_cnt_pm_ops, stm32_timer_cnt_suspend,\n\t\t\t stm32_timer_cnt_resume);\n\nstatic const struct of_device_id stm32_timer_cnt_of_match[] = {\n\t{ .compatible = \"st,stm32-timer-counter\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, stm32_timer_cnt_of_match);\n\nstatic struct platform_driver stm32_timer_cnt_driver = {\n\t.probe = stm32_timer_cnt_probe,\n\t.driver = {\n\t\t.name = \"stm32-timer-counter\",\n\t\t.of_match_table = stm32_timer_cnt_of_match,\n\t\t.pm = &stm32_timer_cnt_pm_ops,\n\t},\n};\nmodule_platform_driver(stm32_timer_cnt_driver);\n\nMODULE_AUTHOR(\"Benjamin Gaignard <benjamin.gaignard@st.com>\");\nMODULE_ALIAS(\"platform:stm32-timer-counter\");\nMODULE_DESCRIPTION(\"STMicroelectronics STM32 TIMER counter driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_IMPORT_NS(COUNTER);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}