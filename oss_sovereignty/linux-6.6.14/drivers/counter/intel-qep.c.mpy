{
  "module_name": "intel-qep.c",
  "hash_id": "74170663d8945ae1238562d79cb4f021e9eccd0745f4b8b738bd12ab24c1136e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/counter/intel-qep.c",
  "human_readable_source": "\n \n#include <linux/counter.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/pci.h>\n#include <linux/pm_runtime.h>\n\n#define INTEL_QEPCON\t\t\t0x00\n#define INTEL_QEPFLT\t\t\t0x04\n#define INTEL_QEPCOUNT\t\t\t0x08\n#define INTEL_QEPMAX\t\t\t0x0c\n#define INTEL_QEPWDT\t\t\t0x10\n#define INTEL_QEPCAPDIV\t\t\t0x14\n#define INTEL_QEPCNTR\t\t\t0x18\n#define INTEL_QEPCAPBUF\t\t\t0x1c\n#define INTEL_QEPINT_STAT\t\t0x20\n#define INTEL_QEPINT_MASK\t\t0x24\n\n \n#define INTEL_QEPCON_EN\t\t\tBIT(0)\n#define INTEL_QEPCON_FLT_EN\t\tBIT(1)\n#define INTEL_QEPCON_EDGE_A\t\tBIT(2)\n#define INTEL_QEPCON_EDGE_B\t\tBIT(3)\n#define INTEL_QEPCON_EDGE_INDX\t\tBIT(4)\n#define INTEL_QEPCON_SWPAB\t\tBIT(5)\n#define INTEL_QEPCON_OP_MODE\t\tBIT(6)\n#define INTEL_QEPCON_PH_ERR\t\tBIT(7)\n#define INTEL_QEPCON_COUNT_RST_MODE\tBIT(8)\n#define INTEL_QEPCON_INDX_GATING_MASK\tGENMASK(10, 9)\n#define INTEL_QEPCON_INDX_GATING(n)\t(((n) & 3) << 9)\n#define INTEL_QEPCON_INDX_PAL_PBL\tINTEL_QEPCON_INDX_GATING(0)\n#define INTEL_QEPCON_INDX_PAL_PBH\tINTEL_QEPCON_INDX_GATING(1)\n#define INTEL_QEPCON_INDX_PAH_PBL\tINTEL_QEPCON_INDX_GATING(2)\n#define INTEL_QEPCON_INDX_PAH_PBH\tINTEL_QEPCON_INDX_GATING(3)\n#define INTEL_QEPCON_CAP_MODE\t\tBIT(11)\n#define INTEL_QEPCON_FIFO_THRE_MASK\tGENMASK(14, 12)\n#define INTEL_QEPCON_FIFO_THRE(n)\t((((n) - 1) & 7) << 12)\n#define INTEL_QEPCON_FIFO_EMPTY\t\tBIT(15)\n\n \n#define INTEL_QEPFLT_MAX_COUNT(n)\t((n) & 0x1fffff)\n\n \n#define INTEL_QEPINT_FIFOCRIT\t\tBIT(5)\n#define INTEL_QEPINT_FIFOENTRY\t\tBIT(4)\n#define INTEL_QEPINT_QEPDIR\t\tBIT(3)\n#define INTEL_QEPINT_QEPRST_UP\t\tBIT(2)\n#define INTEL_QEPINT_QEPRST_DOWN\tBIT(1)\n#define INTEL_QEPINT_WDT\t\tBIT(0)\n\n#define INTEL_QEPINT_MASK_ALL\t\tGENMASK(5, 0)\n\n#define INTEL_QEP_CLK_PERIOD_NS\t\t10\n\nstruct intel_qep {\n\tstruct mutex lock;\n\tstruct device *dev;\n\tvoid __iomem *regs;\n\tbool enabled;\n\t \n\tu32 qepcon;\n\tu32 qepflt;\n\tu32 qepmax;\n};\n\nstatic inline u32 intel_qep_readl(struct intel_qep *qep, u32 offset)\n{\n\treturn readl(qep->regs + offset);\n}\n\nstatic inline void intel_qep_writel(struct intel_qep *qep,\n\t\t\t\t    u32 offset, u32 value)\n{\n\twritel(value, qep->regs + offset);\n}\n\nstatic void intel_qep_init(struct intel_qep *qep)\n{\n\tu32 reg;\n\n\treg = intel_qep_readl(qep, INTEL_QEPCON);\n\treg &= ~INTEL_QEPCON_EN;\n\tintel_qep_writel(qep, INTEL_QEPCON, reg);\n\tqep->enabled = false;\n\t \n\treg = intel_qep_readl(qep, INTEL_QEPCON);\n\n\treg &= ~(INTEL_QEPCON_OP_MODE | INTEL_QEPCON_FLT_EN);\n\treg |= INTEL_QEPCON_EDGE_A | INTEL_QEPCON_EDGE_B |\n\t       INTEL_QEPCON_EDGE_INDX | INTEL_QEPCON_COUNT_RST_MODE;\n\tintel_qep_writel(qep, INTEL_QEPCON, reg);\n\tintel_qep_writel(qep, INTEL_QEPINT_MASK, INTEL_QEPINT_MASK_ALL);\n}\n\nstatic int intel_qep_count_read(struct counter_device *counter,\n\t\t\t\tstruct counter_count *count, u64 *val)\n{\n\tstruct intel_qep *const qep = counter_priv(counter);\n\n\tpm_runtime_get_sync(qep->dev);\n\t*val = intel_qep_readl(qep, INTEL_QEPCOUNT);\n\tpm_runtime_put(qep->dev);\n\n\treturn 0;\n}\n\nstatic const enum counter_function intel_qep_count_functions[] = {\n\tCOUNTER_FUNCTION_QUADRATURE_X4,\n};\n\nstatic int intel_qep_function_read(struct counter_device *counter,\n\t\t\t\t   struct counter_count *count,\n\t\t\t\t   enum counter_function *function)\n{\n\t*function = COUNTER_FUNCTION_QUADRATURE_X4;\n\n\treturn 0;\n}\n\nstatic const enum counter_synapse_action intel_qep_synapse_actions[] = {\n\tCOUNTER_SYNAPSE_ACTION_BOTH_EDGES,\n};\n\nstatic int intel_qep_action_read(struct counter_device *counter,\n\t\t\t\t struct counter_count *count,\n\t\t\t\t struct counter_synapse *synapse,\n\t\t\t\t enum counter_synapse_action *action)\n{\n\t*action = COUNTER_SYNAPSE_ACTION_BOTH_EDGES;\n\treturn 0;\n}\n\nstatic const struct counter_ops intel_qep_counter_ops = {\n\t.count_read = intel_qep_count_read,\n\t.function_read = intel_qep_function_read,\n\t.action_read = intel_qep_action_read,\n};\n\n#define INTEL_QEP_SIGNAL(_id, _name) {\t\t\t\t\\\n\t.id = (_id),\t\t\t\t\t\t\\\n\t.name = (_name),\t\t\t\t\t\\\n}\n\nstatic struct counter_signal intel_qep_signals[] = {\n\tINTEL_QEP_SIGNAL(0, \"Phase A\"),\n\tINTEL_QEP_SIGNAL(1, \"Phase B\"),\n\tINTEL_QEP_SIGNAL(2, \"Index\"),\n};\n\n#define INTEL_QEP_SYNAPSE(_signal_id) {\t\t\t\t\\\n\t.actions_list = intel_qep_synapse_actions,\t\t\\\n\t.num_actions = ARRAY_SIZE(intel_qep_synapse_actions),\t\\\n\t.signal = &intel_qep_signals[(_signal_id)],\t\t\\\n}\n\nstatic struct counter_synapse intel_qep_count_synapses[] = {\n\tINTEL_QEP_SYNAPSE(0),\n\tINTEL_QEP_SYNAPSE(1),\n\tINTEL_QEP_SYNAPSE(2),\n};\n\nstatic int intel_qep_ceiling_read(struct counter_device *counter,\n\t\t\t\t  struct counter_count *count, u64 *ceiling)\n{\n\tstruct intel_qep *qep = counter_priv(counter);\n\n\tpm_runtime_get_sync(qep->dev);\n\t*ceiling = intel_qep_readl(qep, INTEL_QEPMAX);\n\tpm_runtime_put(qep->dev);\n\n\treturn 0;\n}\n\nstatic int intel_qep_ceiling_write(struct counter_device *counter,\n\t\t\t\t   struct counter_count *count, u64 max)\n{\n\tstruct intel_qep *qep = counter_priv(counter);\n\tint ret = 0;\n\n\t \n\tif (max != (u32)max)\n\t\treturn -ERANGE;\n\n\tmutex_lock(&qep->lock);\n\tif (qep->enabled) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tpm_runtime_get_sync(qep->dev);\n\tintel_qep_writel(qep, INTEL_QEPMAX, max);\n\tpm_runtime_put(qep->dev);\n\nout:\n\tmutex_unlock(&qep->lock);\n\treturn ret;\n}\n\nstatic int intel_qep_enable_read(struct counter_device *counter,\n\t\t\t\t struct counter_count *count, u8 *enable)\n{\n\tstruct intel_qep *qep = counter_priv(counter);\n\n\t*enable = qep->enabled;\n\n\treturn 0;\n}\n\nstatic int intel_qep_enable_write(struct counter_device *counter,\n\t\t\t\t  struct counter_count *count, u8 val)\n{\n\tstruct intel_qep *qep = counter_priv(counter);\n\tu32 reg;\n\tbool changed;\n\n\tmutex_lock(&qep->lock);\n\tchanged = val ^ qep->enabled;\n\tif (!changed)\n\t\tgoto out;\n\n\tpm_runtime_get_sync(qep->dev);\n\treg = intel_qep_readl(qep, INTEL_QEPCON);\n\tif (val) {\n\t\t \n\t\treg |= INTEL_QEPCON_EN;\n\t\tpm_runtime_get_noresume(qep->dev);\n\t} else {\n\t\t \n\t\tpm_runtime_put_noidle(qep->dev);\n\t\treg &= ~INTEL_QEPCON_EN;\n\t}\n\tintel_qep_writel(qep, INTEL_QEPCON, reg);\n\tpm_runtime_put(qep->dev);\n\tqep->enabled = val;\n\nout:\n\tmutex_unlock(&qep->lock);\n\treturn 0;\n}\n\nstatic int intel_qep_spike_filter_ns_read(struct counter_device *counter,\n\t\t\t\t\t  struct counter_count *count,\n\t\t\t\t\t  u64 *length)\n{\n\tstruct intel_qep *qep = counter_priv(counter);\n\tu32 reg;\n\n\tpm_runtime_get_sync(qep->dev);\n\treg = intel_qep_readl(qep, INTEL_QEPCON);\n\tif (!(reg & INTEL_QEPCON_FLT_EN)) {\n\t\tpm_runtime_put(qep->dev);\n\t\treturn 0;\n\t}\n\treg = INTEL_QEPFLT_MAX_COUNT(intel_qep_readl(qep, INTEL_QEPFLT));\n\tpm_runtime_put(qep->dev);\n\n\t*length = (reg + 2) * INTEL_QEP_CLK_PERIOD_NS;\n\n\treturn 0;\n}\n\nstatic int intel_qep_spike_filter_ns_write(struct counter_device *counter,\n\t\t\t\t\t   struct counter_count *count,\n\t\t\t\t\t   u64 length)\n{\n\tstruct intel_qep *qep = counter_priv(counter);\n\tu32 reg;\n\tbool enable;\n\tint ret = 0;\n\n\t \n\tdo_div(length, INTEL_QEP_CLK_PERIOD_NS);\n\tif (length == 0) {\n\t\tenable = false;\n\t\tlength = 0;\n\t} else if (length >= 2) {\n\t\tenable = true;\n\t\tlength -= 2;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tif (length > INTEL_QEPFLT_MAX_COUNT(length))\n\t\treturn -ERANGE;\n\n\tmutex_lock(&qep->lock);\n\tif (qep->enabled) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tpm_runtime_get_sync(qep->dev);\n\treg = intel_qep_readl(qep, INTEL_QEPCON);\n\tif (enable)\n\t\treg |= INTEL_QEPCON_FLT_EN;\n\telse\n\t\treg &= ~INTEL_QEPCON_FLT_EN;\n\tintel_qep_writel(qep, INTEL_QEPFLT, length);\n\tintel_qep_writel(qep, INTEL_QEPCON, reg);\n\tpm_runtime_put(qep->dev);\n\nout:\n\tmutex_unlock(&qep->lock);\n\treturn ret;\n}\n\nstatic int intel_qep_preset_enable_read(struct counter_device *counter,\n\t\t\t\t\tstruct counter_count *count,\n\t\t\t\t\tu8 *preset_enable)\n{\n\tstruct intel_qep *qep = counter_priv(counter);\n\tu32 reg;\n\n\tpm_runtime_get_sync(qep->dev);\n\treg = intel_qep_readl(qep, INTEL_QEPCON);\n\tpm_runtime_put(qep->dev);\n\n\t*preset_enable = !(reg & INTEL_QEPCON_COUNT_RST_MODE);\n\n\treturn 0;\n}\n\nstatic int intel_qep_preset_enable_write(struct counter_device *counter,\n\t\t\t\t\t struct counter_count *count, u8 val)\n{\n\tstruct intel_qep *qep = counter_priv(counter);\n\tu32 reg;\n\tint ret = 0;\n\n\tmutex_lock(&qep->lock);\n\tif (qep->enabled) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tpm_runtime_get_sync(qep->dev);\n\treg = intel_qep_readl(qep, INTEL_QEPCON);\n\tif (val)\n\t\treg &= ~INTEL_QEPCON_COUNT_RST_MODE;\n\telse\n\t\treg |= INTEL_QEPCON_COUNT_RST_MODE;\n\n\tintel_qep_writel(qep, INTEL_QEPCON, reg);\n\tpm_runtime_put(qep->dev);\n\nout:\n\tmutex_unlock(&qep->lock);\n\n\treturn ret;\n}\n\nstatic struct counter_comp intel_qep_count_ext[] = {\n\tCOUNTER_COMP_ENABLE(intel_qep_enable_read, intel_qep_enable_write),\n\tCOUNTER_COMP_CEILING(intel_qep_ceiling_read, intel_qep_ceiling_write),\n\tCOUNTER_COMP_PRESET_ENABLE(intel_qep_preset_enable_read,\n\t\t\t\t   intel_qep_preset_enable_write),\n\tCOUNTER_COMP_COUNT_U64(\"spike_filter_ns\",\n\t\t\t       intel_qep_spike_filter_ns_read,\n\t\t\t       intel_qep_spike_filter_ns_write),\n};\n\nstatic struct counter_count intel_qep_counter_count[] = {\n\t{\n\t\t.id = 0,\n\t\t.name = \"Channel 1 Count\",\n\t\t.functions_list = intel_qep_count_functions,\n\t\t.num_functions = ARRAY_SIZE(intel_qep_count_functions),\n\t\t.synapses = intel_qep_count_synapses,\n\t\t.num_synapses = ARRAY_SIZE(intel_qep_count_synapses),\n\t\t.ext = intel_qep_count_ext,\n\t\t.num_ext = ARRAY_SIZE(intel_qep_count_ext),\n\t},\n};\n\nstatic int intel_qep_probe(struct pci_dev *pci, const struct pci_device_id *id)\n{\n\tstruct counter_device *counter;\n\tstruct intel_qep *qep;\n\tstruct device *dev = &pci->dev;\n\tvoid __iomem *regs;\n\tint ret;\n\n\tcounter = devm_counter_alloc(dev, sizeof(*qep));\n\tif (!counter)\n\t\treturn -ENOMEM;\n\tqep = counter_priv(counter);\n\n\tret = pcim_enable_device(pci);\n\tif (ret)\n\t\treturn ret;\n\n\tpci_set_master(pci);\n\n\tret = pcim_iomap_regions(pci, BIT(0), pci_name(pci));\n\tif (ret)\n\t\treturn ret;\n\n\tregs = pcim_iomap_table(pci)[0];\n\tif (!regs)\n\t\treturn -ENOMEM;\n\n\tqep->dev = dev;\n\tqep->regs = regs;\n\tmutex_init(&qep->lock);\n\n\tintel_qep_init(qep);\n\tpci_set_drvdata(pci, qep);\n\n\tcounter->name = pci_name(pci);\n\tcounter->parent = dev;\n\tcounter->ops = &intel_qep_counter_ops;\n\tcounter->counts = intel_qep_counter_count;\n\tcounter->num_counts = ARRAY_SIZE(intel_qep_counter_count);\n\tcounter->signals = intel_qep_signals;\n\tcounter->num_signals = ARRAY_SIZE(intel_qep_signals);\n\tqep->enabled = false;\n\n\tpm_runtime_put(dev);\n\tpm_runtime_allow(dev);\n\n\tret = devm_counter_add(&pci->dev, counter);\n\tif (ret < 0)\n\t\treturn dev_err_probe(&pci->dev, ret, \"Failed to add counter\\n\");\n\n\treturn 0;\n}\n\nstatic void intel_qep_remove(struct pci_dev *pci)\n{\n\tstruct intel_qep *qep = pci_get_drvdata(pci);\n\tstruct device *dev = &pci->dev;\n\n\tpm_runtime_forbid(dev);\n\tif (!qep->enabled)\n\t\tpm_runtime_get(dev);\n\n\tintel_qep_writel(qep, INTEL_QEPCON, 0);\n}\n\nstatic int __maybe_unused intel_qep_suspend(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct intel_qep *qep = pci_get_drvdata(pdev);\n\n\tqep->qepcon = intel_qep_readl(qep, INTEL_QEPCON);\n\tqep->qepflt = intel_qep_readl(qep, INTEL_QEPFLT);\n\tqep->qepmax = intel_qep_readl(qep, INTEL_QEPMAX);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused intel_qep_resume(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct intel_qep *qep = pci_get_drvdata(pdev);\n\n\t \n\tintel_qep_writel(qep, INTEL_QEPCON, 0);\n\tintel_qep_readl(qep, INTEL_QEPCON);\n\n\tintel_qep_writel(qep, INTEL_QEPFLT, qep->qepflt);\n\tintel_qep_writel(qep, INTEL_QEPMAX, qep->qepmax);\n\tintel_qep_writel(qep, INTEL_QEPINT_MASK, INTEL_QEPINT_MASK_ALL);\n\n\t \n\tintel_qep_writel(qep, INTEL_QEPCON, qep->qepcon & ~INTEL_QEPCON_EN);\n\tintel_qep_readl(qep, INTEL_QEPCON);\n\n\t \n\tintel_qep_writel(qep, INTEL_QEPCON, qep->qepcon);\n\n\treturn 0;\n}\n\nstatic UNIVERSAL_DEV_PM_OPS(intel_qep_pm_ops,\n\t\t\t    intel_qep_suspend, intel_qep_resume, NULL);\n\nstatic const struct pci_device_id intel_qep_id_table[] = {\n\t \n\t{ PCI_VDEVICE(INTEL, 0x4bc3), },\n\t{ PCI_VDEVICE(INTEL, 0x4b81), },\n\t{ PCI_VDEVICE(INTEL, 0x4b82), },\n\t{ PCI_VDEVICE(INTEL, 0x4b83), },\n\t{  }  \n};\nMODULE_DEVICE_TABLE(pci, intel_qep_id_table);\n\nstatic struct pci_driver intel_qep_driver = {\n\t.name = \"intel-qep\",\n\t.id_table = intel_qep_id_table,\n\t.probe = intel_qep_probe,\n\t.remove = intel_qep_remove,\n\t.driver = {\n\t\t.pm = &intel_qep_pm_ops,\n\t}\n};\n\nmodule_pci_driver(intel_qep_driver);\n\nMODULE_AUTHOR(\"Felipe Balbi (Intel)\");\nMODULE_AUTHOR(\"Jarkko Nikula <jarkko.nikula@linux.intel.com>\");\nMODULE_AUTHOR(\"Raymond Tan <raymond.tan@intel.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Intel Quadrature Encoder Peripheral driver\");\nMODULE_IMPORT_NS(COUNTER);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}