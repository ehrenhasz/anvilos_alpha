{
  "module_name": "104-quad-8.c",
  "hash_id": "9174cd82e00b13c3ffadab3a078a872d2afc5cbfb6a1c8f339e72f511ca8c54c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/counter/104-quad-8.c",
  "human_readable_source": "\n \n#include <linux/bitfield.h>\n#include <linux/bits.h>\n#include <linux/counter.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/interrupt.h>\n#include <linux/isa.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/regmap.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n\n#include <asm/unaligned.h>\n\n#define QUAD8_EXTENT 32\n\nstatic unsigned int base[max_num_isa_dev(QUAD8_EXTENT)];\nstatic unsigned int num_quad8;\nmodule_param_hw_array(base, uint, ioport, &num_quad8, 0);\nMODULE_PARM_DESC(base, \"ACCES 104-QUAD-8 base addresses\");\n\nstatic unsigned int irq[max_num_isa_dev(QUAD8_EXTENT)];\nstatic unsigned int num_irq;\nmodule_param_hw_array(irq, uint, irq, &num_irq, 0);\nMODULE_PARM_DESC(irq, \"ACCES 104-QUAD-8 interrupt line numbers\");\n\n#define QUAD8_NUM_COUNTERS 8\n\n#define QUAD8_DATA(_channel) ((_channel) * 2)\n#define QUAD8_CONTROL(_channel) (QUAD8_DATA(_channel) + 1)\n#define QUAD8_INTERRUPT_STATUS 0x10\n#define QUAD8_CHANNEL_OPERATION 0x11\n#define QUAD8_INDEX_INTERRUPT 0x12\n#define QUAD8_INDEX_INPUT_LEVELS 0x16\n#define QUAD8_CABLE_STATUS 0x17\n\n \nstruct quad8 {\n\tspinlock_t lock;\n\tu8 cmr[QUAD8_NUM_COUNTERS];\n\tu8 ior[QUAD8_NUM_COUNTERS];\n\tu8 idr[QUAD8_NUM_COUNTERS];\n\tunsigned int fck_prescaler[QUAD8_NUM_COUNTERS];\n\tunsigned int preset[QUAD8_NUM_COUNTERS];\n\tunsigned int cable_fault_enable;\n\tstruct regmap *map;\n};\n\nstatic const struct regmap_range quad8_wr_ranges[] = {\n\tregmap_reg_range(0x0, 0xF), regmap_reg_range(0x11, 0x12), regmap_reg_range(0x17, 0x17),\n};\nstatic const struct regmap_range quad8_rd_ranges[] = {\n\tregmap_reg_range(0x0, 0x12), regmap_reg_range(0x16, 0x18),\n};\nstatic const struct regmap_access_table quad8_wr_table = {\n\t.yes_ranges = quad8_wr_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(quad8_wr_ranges),\n};\nstatic const struct regmap_access_table quad8_rd_table = {\n\t.yes_ranges = quad8_rd_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(quad8_rd_ranges),\n};\nstatic const struct regmap_config quad8_regmap_config = {\n\t.reg_bits = 8,\n\t.reg_stride = 1,\n\t.val_bits = 8,\n\t.io_port = true,\n\t.wr_table = &quad8_wr_table,\n\t.rd_table = &quad8_rd_table,\n};\n\n \n#define FLAG_E BIT(4)\n \n#define FLAG_UD BIT(5)\n \n#define UP 0x1\n\n#define REGISTER_SELECTION GENMASK(6, 5)\n\n \n#define SELECT_RLD u8_encode_bits(0x0, REGISTER_SELECTION)\n \n#define SELECT_CMR u8_encode_bits(0x1, REGISTER_SELECTION)\n \n#define SELECT_IOR u8_encode_bits(0x2, REGISTER_SELECTION)\n \n#define SELECT_IDR u8_encode_bits(0x3, REGISTER_SELECTION)\n\n \n#define RESETS GENMASK(2, 1)\n#define LOADS GENMASK(4, 3)\n \n#define RESET_BP BIT(0)\n \n#define RESET_BT_CT_CPT_S_IDX u8_encode_bits(0x2, RESETS)\n \n#define RESET_E u8_encode_bits(0x3, RESETS)\n \n#define TRANSFER_PR_TO_CNTR u8_encode_bits(0x1, LOADS)\n \n#define TRANSFER_CNTR_TO_OL u8_encode_bits(0x2, LOADS)\n \n#define TRANSFER_PR0_TO_PSC u8_encode_bits(0x3, LOADS)\n\n \n#define COUNT_ENCODING BIT(0)\n#define COUNT_MODE GENMASK(2, 1)\n#define QUADRATURE_MODE GENMASK(4, 3)\n \n#define BINARY u8_encode_bits(0x0, COUNT_ENCODING)\n \n#define NORMAL_COUNT 0x0\n \n#define RANGE_LIMIT 0x1\n \n#define NON_RECYCLE_COUNT 0x2\n \n#define MODULO_N 0x3\n \n#define NON_QUADRATURE 0x0\n \n#define QUADRATURE_X1 0x1\n \n#define QUADRATURE_X2 0x2\n \n#define QUADRATURE_X4 0x3\n\n \n#define AB_GATE BIT(0)\n#define LOAD_PIN BIT(1)\n#define FLG_PINS GENMASK(4, 3)\n \n#define DISABLE_AB u8_encode_bits(0x0, AB_GATE)\n \n#define LOAD_CNTR 0x0\n \n#define FLG1_CARRY_FLG2_BORROW 0x0\n \n#define FLG1_COMPARE_FLG2_BORROW 0x1\n \n#define FLG1_CARRYBORROW_FLG2_UD 0x2\n \n#define FLG1_INDX_FLG2_E 0x3\n\n \n#define INDEX_MODE BIT(0)\n#define INDEX_POLARITY BIT(1)\n \n#define DISABLE_INDEX_MODE 0x0\n \n#define ENABLE_INDEX_MODE 0x1\n \n#define NEGATIVE_INDEX_POLARITY 0x0\n \n#define POSITIVE_INDEX_POLARITY 0x1\n\n \n#define COUNTERS_OPERATION BIT(0)\n#define INTERRUPT_FUNCTION BIT(2)\n \n#define ENABLE_COUNTERS u8_encode_bits(0x0, COUNTERS_OPERATION)\n \n#define RESET_COUNTERS u8_encode_bits(0x1, COUNTERS_OPERATION)\n \n#define DISABLE_INTERRUPT_FUNCTION u8_encode_bits(0x0, INTERRUPT_FUNCTION)\n \n#define ENABLE_INTERRUPT_FUNCTION u8_encode_bits(0x1, INTERRUPT_FUNCTION)\n \n#define CLEAR_PENDING_INTERRUPTS (ENABLE_COUNTERS | ENABLE_INTERRUPT_FUNCTION)\n\n \n#define LS7267_CNTR_MAX GENMASK(23, 0)\n\nstatic __always_inline int quad8_control_register_update(struct regmap *const map, u8 *const buf,\n\t\t\t\t\t\t\t const size_t channel, const u8 val,\n\t\t\t\t\t\t\t const u8 field)\n{\n\tu8p_replace_bits(&buf[channel], val, field);\n\treturn regmap_write(map, QUAD8_CONTROL(channel), buf[channel]);\n}\n\nstatic int quad8_signal_read(struct counter_device *counter,\n\t\t\t     struct counter_signal *signal,\n\t\t\t     enum counter_signal_level *level)\n{\n\tconst struct quad8 *const priv = counter_priv(counter);\n\tint ret;\n\n\t \n\tif (signal->id < 16)\n\t\treturn -EINVAL;\n\n\tret = regmap_test_bits(priv->map, QUAD8_INDEX_INPUT_LEVELS, BIT(signal->id - 16));\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*level = (ret) ? COUNTER_SIGNAL_LEVEL_HIGH : COUNTER_SIGNAL_LEVEL_LOW;\n\n\treturn 0;\n}\n\nstatic int quad8_count_read(struct counter_device *counter,\n\t\t\t    struct counter_count *count, u64 *val)\n{\n\tstruct quad8 *const priv = counter_priv(counter);\n\tunsigned long irqflags;\n\tu8 value[3];\n\tint ret;\n\n\tspin_lock_irqsave(&priv->lock, irqflags);\n\n\tret = regmap_write(priv->map, QUAD8_CONTROL(count->id),\n\t\t\t   SELECT_RLD | RESET_BP | TRANSFER_CNTR_TO_OL);\n\tif (ret)\n\t\tgoto exit_unlock;\n\tret = regmap_noinc_read(priv->map, QUAD8_DATA(count->id), value, sizeof(value));\n\nexit_unlock:\n\tspin_unlock_irqrestore(&priv->lock, irqflags);\n\n\t*val = get_unaligned_le24(value);\n\n\treturn ret;\n}\n\nstatic int quad8_preset_register_set(struct quad8 *const priv, const size_t id,\n\t\t\t\t     const unsigned long preset)\n{\n\tu8 value[3];\n\tint ret;\n\n\tput_unaligned_le24(preset, value);\n\n\tret = regmap_write(priv->map, QUAD8_CONTROL(id), SELECT_RLD | RESET_BP);\n\tif (ret)\n\t\treturn ret;\n\treturn regmap_noinc_write(priv->map, QUAD8_DATA(id), value, sizeof(value));\n}\n\nstatic int quad8_flag_register_reset(struct quad8 *const priv, const size_t id)\n{\n\tint ret;\n\n\tret = regmap_write(priv->map, QUAD8_CONTROL(id), SELECT_RLD | RESET_BT_CT_CPT_S_IDX);\n\tif (ret)\n\t\treturn ret;\n\treturn regmap_write(priv->map, QUAD8_CONTROL(id), SELECT_RLD | RESET_E);\n}\n\nstatic int quad8_count_write(struct counter_device *counter,\n\t\t\t     struct counter_count *count, u64 val)\n{\n\tstruct quad8 *const priv = counter_priv(counter);\n\tunsigned long irqflags;\n\tint ret;\n\n\tif (val > LS7267_CNTR_MAX)\n\t\treturn -ERANGE;\n\n\tspin_lock_irqsave(&priv->lock, irqflags);\n\n\t \n\tret = quad8_preset_register_set(priv, count->id, val);\n\tif (ret)\n\t\tgoto exit_unlock;\n\tret = regmap_write(priv->map, QUAD8_CONTROL(count->id), SELECT_RLD | TRANSFER_PR_TO_CNTR);\n\tif (ret)\n\t\tgoto exit_unlock;\n\n\tret = quad8_flag_register_reset(priv, count->id);\n\tif (ret)\n\t\tgoto exit_unlock;\n\n\t \n\tret = quad8_preset_register_set(priv, count->id, priv->preset[count->id]);\n\nexit_unlock:\n\tspin_unlock_irqrestore(&priv->lock, irqflags);\n\n\treturn ret;\n}\n\nstatic const enum counter_function quad8_count_functions_list[] = {\n\tCOUNTER_FUNCTION_PULSE_DIRECTION,\n\tCOUNTER_FUNCTION_QUADRATURE_X1_A,\n\tCOUNTER_FUNCTION_QUADRATURE_X2_A,\n\tCOUNTER_FUNCTION_QUADRATURE_X4,\n};\n\nstatic int quad8_function_get(const struct quad8 *const priv, const size_t id,\n\t\t\t      enum counter_function *const function)\n{\n\tswitch (u8_get_bits(priv->cmr[id], QUADRATURE_MODE)) {\n\tcase NON_QUADRATURE:\n\t\t*function = COUNTER_FUNCTION_PULSE_DIRECTION;\n\t\treturn 0;\n\tcase QUADRATURE_X1:\n\t\t*function = COUNTER_FUNCTION_QUADRATURE_X1_A;\n\t\treturn 0;\n\tcase QUADRATURE_X2:\n\t\t*function = COUNTER_FUNCTION_QUADRATURE_X2_A;\n\t\treturn 0;\n\tcase QUADRATURE_X4:\n\t\t*function = COUNTER_FUNCTION_QUADRATURE_X4;\n\t\treturn 0;\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int quad8_function_read(struct counter_device *counter,\n\t\t\t       struct counter_count *count,\n\t\t\t       enum counter_function *function)\n{\n\tstruct quad8 *const priv = counter_priv(counter);\n\tunsigned long irqflags;\n\tint retval;\n\n\tspin_lock_irqsave(&priv->lock, irqflags);\n\n\tretval = quad8_function_get(priv, count->id, function);\n\n\tspin_unlock_irqrestore(&priv->lock, irqflags);\n\n\treturn retval;\n}\n\nstatic int quad8_function_write(struct counter_device *counter,\n\t\t\t\tstruct counter_count *count,\n\t\t\t\tenum counter_function function)\n{\n\tstruct quad8 *const priv = counter_priv(counter);\n\tconst int id = count->id;\n\tunsigned long irqflags;\n\tunsigned int mode_cfg;\n\tbool synchronous_mode;\n\tint ret;\n\n\tswitch (function) {\n\tcase COUNTER_FUNCTION_PULSE_DIRECTION:\n\t\tmode_cfg = NON_QUADRATURE;\n\t\tbreak;\n\tcase COUNTER_FUNCTION_QUADRATURE_X1_A:\n\t\tmode_cfg = QUADRATURE_X1;\n\t\tbreak;\n\tcase COUNTER_FUNCTION_QUADRATURE_X2_A:\n\t\tmode_cfg = QUADRATURE_X2;\n\t\tbreak;\n\tcase COUNTER_FUNCTION_QUADRATURE_X4:\n\t\tmode_cfg = QUADRATURE_X4;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(&priv->lock, irqflags);\n\n\t \n\tsynchronous_mode = u8_get_bits(priv->idr[id], INDEX_MODE) == ENABLE_INDEX_MODE;\n\tif (synchronous_mode && mode_cfg == NON_QUADRATURE) {\n\t\tret = quad8_control_register_update(priv->map, priv->idr, id, DISABLE_INDEX_MODE,\n\t\t\t\t\t\t    INDEX_MODE);\n\t\tif (ret)\n\t\t\tgoto exit_unlock;\n\t}\n\n\tret = quad8_control_register_update(priv->map, priv->cmr, id, mode_cfg, QUADRATURE_MODE);\n\nexit_unlock:\n\tspin_unlock_irqrestore(&priv->lock, irqflags);\n\n\treturn ret;\n}\n\nstatic int quad8_direction_read(struct counter_device *counter,\n\t\t\t\tstruct counter_count *count,\n\t\t\t\tenum counter_count_direction *direction)\n{\n\tconst struct quad8 *const priv = counter_priv(counter);\n\tunsigned int flag;\n\tint ret;\n\n\tret = regmap_read(priv->map, QUAD8_CONTROL(count->id), &flag);\n\tif (ret)\n\t\treturn ret;\n\t*direction = (u8_get_bits(flag, FLAG_UD) == UP) ? COUNTER_COUNT_DIRECTION_FORWARD :\n\t\tCOUNTER_COUNT_DIRECTION_BACKWARD;\n\n\treturn 0;\n}\n\nstatic const enum counter_synapse_action quad8_index_actions_list[] = {\n\tCOUNTER_SYNAPSE_ACTION_NONE,\n\tCOUNTER_SYNAPSE_ACTION_RISING_EDGE,\n};\n\nstatic const enum counter_synapse_action quad8_synapse_actions_list[] = {\n\tCOUNTER_SYNAPSE_ACTION_NONE,\n\tCOUNTER_SYNAPSE_ACTION_RISING_EDGE,\n\tCOUNTER_SYNAPSE_ACTION_FALLING_EDGE,\n\tCOUNTER_SYNAPSE_ACTION_BOTH_EDGES,\n};\n\nstatic int quad8_action_read(struct counter_device *counter,\n\t\t\t     struct counter_count *count,\n\t\t\t     struct counter_synapse *synapse,\n\t\t\t     enum counter_synapse_action *action)\n{\n\tstruct quad8 *const priv = counter_priv(counter);\n\tunsigned long irqflags;\n\tint err;\n\tenum counter_function function;\n\tconst size_t signal_a_id = count->synapses[0].signal->id;\n\tenum counter_count_direction direction;\n\n\t \n\t*action = COUNTER_SYNAPSE_ACTION_NONE;\n\n\t \n\tif (synapse->signal->id >= 16) {\n\t\tif (u8_get_bits(priv->ior[count->id], LOAD_PIN) == LOAD_CNTR)\n\t\t\t*action = COUNTER_SYNAPSE_ACTION_RISING_EDGE;\n\t\treturn 0;\n\t}\n\n\tspin_lock_irqsave(&priv->lock, irqflags);\n\n\t \n\terr = quad8_function_get(priv, count->id, &function);\n\tif (err) {\n\t\tspin_unlock_irqrestore(&priv->lock, irqflags);\n\t\treturn err;\n\t}\n\terr = quad8_direction_read(counter, count, &direction);\n\tif (err) {\n\t\tspin_unlock_irqrestore(&priv->lock, irqflags);\n\t\treturn err;\n\t}\n\n\tspin_unlock_irqrestore(&priv->lock, irqflags);\n\n\t \n\tswitch (function) {\n\tcase COUNTER_FUNCTION_PULSE_DIRECTION:\n\t\tif (synapse->signal->id == signal_a_id)\n\t\t\t*action = COUNTER_SYNAPSE_ACTION_RISING_EDGE;\n\t\treturn 0;\n\tcase COUNTER_FUNCTION_QUADRATURE_X1_A:\n\t\tif (synapse->signal->id == signal_a_id) {\n\t\t\tif (direction == COUNTER_COUNT_DIRECTION_FORWARD)\n\t\t\t\t*action = COUNTER_SYNAPSE_ACTION_RISING_EDGE;\n\t\t\telse\n\t\t\t\t*action = COUNTER_SYNAPSE_ACTION_FALLING_EDGE;\n\t\t}\n\t\treturn 0;\n\tcase COUNTER_FUNCTION_QUADRATURE_X2_A:\n\t\tif (synapse->signal->id == signal_a_id)\n\t\t\t*action = COUNTER_SYNAPSE_ACTION_BOTH_EDGES;\n\t\treturn 0;\n\tcase COUNTER_FUNCTION_QUADRATURE_X4:\n\t\t*action = COUNTER_SYNAPSE_ACTION_BOTH_EDGES;\n\t\treturn 0;\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int quad8_events_configure(struct counter_device *counter)\n{\n\tstruct quad8 *const priv = counter_priv(counter);\n\tunsigned long irq_enabled = 0;\n\tunsigned long irqflags;\n\tstruct counter_event_node *event_node;\n\tu8 flg_pins;\n\tint ret;\n\n\tspin_lock_irqsave(&priv->lock, irqflags);\n\n\tlist_for_each_entry(event_node, &counter->events_list, l) {\n\t\tswitch (event_node->event) {\n\t\tcase COUNTER_EVENT_OVERFLOW:\n\t\t\tflg_pins = FLG1_CARRY_FLG2_BORROW;\n\t\t\tbreak;\n\t\tcase COUNTER_EVENT_THRESHOLD:\n\t\t\tflg_pins = FLG1_COMPARE_FLG2_BORROW;\n\t\t\tbreak;\n\t\tcase COUNTER_EVENT_OVERFLOW_UNDERFLOW:\n\t\t\tflg_pins = FLG1_CARRYBORROW_FLG2_UD;\n\t\t\tbreak;\n\t\tcase COUNTER_EVENT_INDEX:\n\t\t\tflg_pins = FLG1_INDX_FLG2_E;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tret = -EINVAL;\n\t\t\tgoto exit_unlock;\n\t\t}\n\n\t\t \n\t\tirq_enabled |= BIT(event_node->channel);\n\n\t\t \n\t\tif (flg_pins == u8_get_bits(priv->ior[event_node->channel], FLG_PINS))\n\t\t\tcontinue;\n\n\t\t \n\t\tret = quad8_control_register_update(priv->map, priv->ior, event_node->channel,\n\t\t\t\t\t\t    flg_pins, FLG_PINS);\n\t\tif (ret)\n\t\t\tgoto exit_unlock;\n\t}\n\n\tret = regmap_write(priv->map, QUAD8_INDEX_INTERRUPT, irq_enabled);\n\nexit_unlock:\n\tspin_unlock_irqrestore(&priv->lock, irqflags);\n\n\treturn ret;\n}\n\nstatic int quad8_watch_validate(struct counter_device *counter,\n\t\t\t\tconst struct counter_watch *watch)\n{\n\tstruct counter_event_node *event_node;\n\n\tif (watch->channel > QUAD8_NUM_COUNTERS - 1)\n\t\treturn -EINVAL;\n\n\tswitch (watch->event) {\n\tcase COUNTER_EVENT_OVERFLOW:\n\tcase COUNTER_EVENT_THRESHOLD:\n\tcase COUNTER_EVENT_OVERFLOW_UNDERFLOW:\n\tcase COUNTER_EVENT_INDEX:\n\t\tlist_for_each_entry(event_node, &counter->next_events_list, l)\n\t\t\tif (watch->channel == event_node->channel &&\n\t\t\t\twatch->event != event_node->event)\n\t\t\t\treturn -EINVAL;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct counter_ops quad8_ops = {\n\t.signal_read = quad8_signal_read,\n\t.count_read = quad8_count_read,\n\t.count_write = quad8_count_write,\n\t.function_read = quad8_function_read,\n\t.function_write = quad8_function_write,\n\t.action_read = quad8_action_read,\n\t.events_configure = quad8_events_configure,\n\t.watch_validate = quad8_watch_validate,\n};\n\nstatic const char *const quad8_index_polarity_modes[] = {\n\t\"negative\",\n\t\"positive\"\n};\n\nstatic int quad8_index_polarity_get(struct counter_device *counter,\n\t\t\t\t    struct counter_signal *signal,\n\t\t\t\t    u32 *index_polarity)\n{\n\tconst struct quad8 *const priv = counter_priv(counter);\n\tconst size_t channel_id = signal->id - 16;\n\n\t*index_polarity = u8_get_bits(priv->idr[channel_id], INDEX_POLARITY);\n\n\treturn 0;\n}\n\nstatic int quad8_index_polarity_set(struct counter_device *counter,\n\t\t\t\t    struct counter_signal *signal,\n\t\t\t\t    u32 index_polarity)\n{\n\tstruct quad8 *const priv = counter_priv(counter);\n\tconst size_t channel_id = signal->id - 16;\n\tunsigned long irqflags;\n\tint ret;\n\n\tspin_lock_irqsave(&priv->lock, irqflags);\n\n\tret = quad8_control_register_update(priv->map, priv->idr, channel_id, index_polarity,\n\t\t\t\t\t    INDEX_POLARITY);\n\n\tspin_unlock_irqrestore(&priv->lock, irqflags);\n\n\treturn ret;\n}\n\nstatic int quad8_polarity_read(struct counter_device *counter,\n\t\t\t       struct counter_signal *signal,\n\t\t\t       enum counter_signal_polarity *polarity)\n{\n\tint err;\n\tu32 index_polarity;\n\n\terr = quad8_index_polarity_get(counter, signal, &index_polarity);\n\tif (err)\n\t\treturn err;\n\n\t*polarity = (index_polarity == POSITIVE_INDEX_POLARITY) ? COUNTER_SIGNAL_POLARITY_POSITIVE :\n\t\tCOUNTER_SIGNAL_POLARITY_NEGATIVE;\n\n\treturn 0;\n}\n\nstatic int quad8_polarity_write(struct counter_device *counter,\n\t\t\t\tstruct counter_signal *signal,\n\t\t\t\tenum counter_signal_polarity polarity)\n{\n\tconst u32 pol = (polarity == COUNTER_SIGNAL_POLARITY_POSITIVE) ? POSITIVE_INDEX_POLARITY :\n\t\t\t\t\t\t\t\t\t NEGATIVE_INDEX_POLARITY;\n\n\treturn quad8_index_polarity_set(counter, signal, pol);\n}\n\nstatic const char *const quad8_synchronous_modes[] = {\n\t\"non-synchronous\",\n\t\"synchronous\"\n};\n\nstatic int quad8_synchronous_mode_get(struct counter_device *counter,\n\t\t\t\t      struct counter_signal *signal,\n\t\t\t\t      u32 *synchronous_mode)\n{\n\tconst struct quad8 *const priv = counter_priv(counter);\n\tconst size_t channel_id = signal->id - 16;\n\n\t*synchronous_mode = u8_get_bits(priv->idr[channel_id], INDEX_MODE);\n\n\treturn 0;\n}\n\nstatic int quad8_synchronous_mode_set(struct counter_device *counter,\n\t\t\t\t      struct counter_signal *signal,\n\t\t\t\t      u32 synchronous_mode)\n{\n\tstruct quad8 *const priv = counter_priv(counter);\n\tconst size_t channel_id = signal->id - 16;\n\tu8 quadrature_mode;\n\tunsigned long irqflags;\n\tint ret;\n\n\tspin_lock_irqsave(&priv->lock, irqflags);\n\n\t \n\tquadrature_mode = u8_get_bits(priv->idr[channel_id], QUADRATURE_MODE);\n\tif (synchronous_mode && quadrature_mode == NON_QUADRATURE) {\n\t\tret = -EINVAL;\n\t\tgoto exit_unlock;\n\t}\n\n\tret = quad8_control_register_update(priv->map, priv->idr, channel_id, synchronous_mode,\n\t\t\t\t\t    INDEX_MODE);\n\nexit_unlock:\n\tspin_unlock_irqrestore(&priv->lock, irqflags);\n\n\treturn ret;\n}\n\nstatic int quad8_count_floor_read(struct counter_device *counter,\n\t\t\t\t  struct counter_count *count, u64 *floor)\n{\n\t \n\t*floor = 0;\n\n\treturn 0;\n}\n\nstatic int quad8_count_mode_read(struct counter_device *counter,\n\t\t\t\t struct counter_count *count,\n\t\t\t\t enum counter_count_mode *cnt_mode)\n{\n\tconst struct quad8 *const priv = counter_priv(counter);\n\n\tswitch (u8_get_bits(priv->cmr[count->id], COUNT_MODE)) {\n\tcase NORMAL_COUNT:\n\t\t*cnt_mode = COUNTER_COUNT_MODE_NORMAL;\n\t\tbreak;\n\tcase RANGE_LIMIT:\n\t\t*cnt_mode = COUNTER_COUNT_MODE_RANGE_LIMIT;\n\t\tbreak;\n\tcase NON_RECYCLE_COUNT:\n\t\t*cnt_mode = COUNTER_COUNT_MODE_NON_RECYCLE;\n\t\tbreak;\n\tcase MODULO_N:\n\t\t*cnt_mode = COUNTER_COUNT_MODE_MODULO_N;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int quad8_count_mode_write(struct counter_device *counter,\n\t\t\t\t  struct counter_count *count,\n\t\t\t\t  enum counter_count_mode cnt_mode)\n{\n\tstruct quad8 *const priv = counter_priv(counter);\n\tunsigned int count_mode;\n\tunsigned long irqflags;\n\tint ret;\n\n\tswitch (cnt_mode) {\n\tcase COUNTER_COUNT_MODE_NORMAL:\n\t\tcount_mode = NORMAL_COUNT;\n\t\tbreak;\n\tcase COUNTER_COUNT_MODE_RANGE_LIMIT:\n\t\tcount_mode = RANGE_LIMIT;\n\t\tbreak;\n\tcase COUNTER_COUNT_MODE_NON_RECYCLE:\n\t\tcount_mode = NON_RECYCLE_COUNT;\n\t\tbreak;\n\tcase COUNTER_COUNT_MODE_MODULO_N:\n\t\tcount_mode = MODULO_N;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(&priv->lock, irqflags);\n\n\tret = quad8_control_register_update(priv->map, priv->cmr, count->id, count_mode,\n\t\t\t\t\t    COUNT_MODE);\n\n\tspin_unlock_irqrestore(&priv->lock, irqflags);\n\n\treturn ret;\n}\n\nstatic int quad8_count_enable_read(struct counter_device *counter,\n\t\t\t\t   struct counter_count *count, u8 *enable)\n{\n\tconst struct quad8 *const priv = counter_priv(counter);\n\n\t*enable = u8_get_bits(priv->ior[count->id], AB_GATE);\n\n\treturn 0;\n}\n\nstatic int quad8_count_enable_write(struct counter_device *counter,\n\t\t\t\t    struct counter_count *count, u8 enable)\n{\n\tstruct quad8 *const priv = counter_priv(counter);\n\tunsigned long irqflags;\n\tint ret;\n\n\tspin_lock_irqsave(&priv->lock, irqflags);\n\n\tret = quad8_control_register_update(priv->map, priv->ior, count->id, enable, AB_GATE);\n\n\tspin_unlock_irqrestore(&priv->lock, irqflags);\n\n\treturn ret;\n}\n\nstatic const char *const quad8_noise_error_states[] = {\n\t\"No excessive noise is present at the count inputs\",\n\t\"Excessive noise is present at the count inputs\"\n};\n\nstatic int quad8_error_noise_get(struct counter_device *counter,\n\t\t\t\t struct counter_count *count, u32 *noise_error)\n{\n\tconst struct quad8 *const priv = counter_priv(counter);\n\tunsigned int flag;\n\tint ret;\n\n\tret = regmap_read(priv->map, QUAD8_CONTROL(count->id), &flag);\n\tif (ret)\n\t\treturn ret;\n\t*noise_error = u8_get_bits(flag, FLAG_E);\n\n\treturn 0;\n}\n\nstatic int quad8_count_preset_read(struct counter_device *counter,\n\t\t\t\t   struct counter_count *count, u64 *preset)\n{\n\tconst struct quad8 *const priv = counter_priv(counter);\n\n\t*preset = priv->preset[count->id];\n\n\treturn 0;\n}\n\nstatic int quad8_count_preset_write(struct counter_device *counter,\n\t\t\t\t    struct counter_count *count, u64 preset)\n{\n\tstruct quad8 *const priv = counter_priv(counter);\n\tunsigned long irqflags;\n\tint ret;\n\n\tif (preset > LS7267_CNTR_MAX)\n\t\treturn -ERANGE;\n\n\tspin_lock_irqsave(&priv->lock, irqflags);\n\n\tpriv->preset[count->id] = preset;\n\tret = quad8_preset_register_set(priv, count->id, preset);\n\n\tspin_unlock_irqrestore(&priv->lock, irqflags);\n\n\treturn ret;\n}\n\nstatic int quad8_count_ceiling_read(struct counter_device *counter,\n\t\t\t\t    struct counter_count *count, u64 *ceiling)\n{\n\tstruct quad8 *const priv = counter_priv(counter);\n\tunsigned long irqflags;\n\n\tspin_lock_irqsave(&priv->lock, irqflags);\n\n\t \n\tswitch (u8_get_bits(priv->cmr[count->id], COUNT_MODE)) {\n\tcase RANGE_LIMIT:\n\tcase MODULO_N:\n\t\t*ceiling = priv->preset[count->id];\n\t\tbreak;\n\tdefault:\n\t\t*ceiling = LS7267_CNTR_MAX;\n\t\tbreak;\n\t}\n\n\tspin_unlock_irqrestore(&priv->lock, irqflags);\n\n\treturn 0;\n}\n\nstatic int quad8_count_ceiling_write(struct counter_device *counter,\n\t\t\t\t     struct counter_count *count, u64 ceiling)\n{\n\tstruct quad8 *const priv = counter_priv(counter);\n\tunsigned long irqflags;\n\tint ret;\n\n\tif (ceiling > LS7267_CNTR_MAX)\n\t\treturn -ERANGE;\n\n\tspin_lock_irqsave(&priv->lock, irqflags);\n\n\t \n\tswitch (u8_get_bits(priv->cmr[count->id], COUNT_MODE)) {\n\tcase RANGE_LIMIT:\n\tcase MODULO_N:\n\t\tpriv->preset[count->id] = ceiling;\n\t\tret = quad8_preset_register_set(priv, count->id, ceiling);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tspin_unlock_irqrestore(&priv->lock, irqflags);\n\n\treturn ret;\n}\n\nstatic int quad8_count_preset_enable_read(struct counter_device *counter,\n\t\t\t\t\t  struct counter_count *count,\n\t\t\t\t\t  u8 *preset_enable)\n{\n\tconst struct quad8 *const priv = counter_priv(counter);\n\n\t \n\t*preset_enable = !u8_get_bits(priv->ior[count->id], LOAD_PIN);\n\n\treturn 0;\n}\n\nstatic int quad8_count_preset_enable_write(struct counter_device *counter,\n\t\t\t\t\t   struct counter_count *count,\n\t\t\t\t\t   u8 preset_enable)\n{\n\tstruct quad8 *const priv = counter_priv(counter);\n\tunsigned long irqflags;\n\tint ret;\n\n\tspin_lock_irqsave(&priv->lock, irqflags);\n\n\t \n\tret = quad8_control_register_update(priv->map, priv->ior, count->id, !preset_enable,\n\t\t\t\t\t    LOAD_PIN);\n\n\tspin_unlock_irqrestore(&priv->lock, irqflags);\n\n\treturn ret;\n}\n\nstatic int quad8_signal_cable_fault_read(struct counter_device *counter,\n\t\t\t\t\t struct counter_signal *signal,\n\t\t\t\t\t u8 *cable_fault)\n{\n\tstruct quad8 *const priv = counter_priv(counter);\n\tconst size_t channel_id = signal->id / 2;\n\tunsigned long irqflags;\n\tbool disabled;\n\tint ret;\n\n\tspin_lock_irqsave(&priv->lock, irqflags);\n\n\tdisabled = !(priv->cable_fault_enable & BIT(channel_id));\n\n\tif (disabled) {\n\t\tspin_unlock_irqrestore(&priv->lock, irqflags);\n\t\treturn -EINVAL;\n\t}\n\n\tret = regmap_test_bits(priv->map, QUAD8_CABLE_STATUS, BIT(channel_id));\n\tif (ret < 0) {\n\t\tspin_unlock_irqrestore(&priv->lock, irqflags);\n\t\treturn ret;\n\t}\n\n\tspin_unlock_irqrestore(&priv->lock, irqflags);\n\n\t \n\t*cable_fault = !ret;\n\n\treturn 0;\n}\n\nstatic int quad8_signal_cable_fault_enable_read(struct counter_device *counter,\n\t\t\t\t\t\tstruct counter_signal *signal,\n\t\t\t\t\t\tu8 *enable)\n{\n\tconst struct quad8 *const priv = counter_priv(counter);\n\tconst size_t channel_id = signal->id / 2;\n\n\t*enable = !!(priv->cable_fault_enable & BIT(channel_id));\n\n\treturn 0;\n}\n\nstatic int quad8_signal_cable_fault_enable_write(struct counter_device *counter,\n\t\t\t\t\t\t struct counter_signal *signal,\n\t\t\t\t\t\t u8 enable)\n{\n\tstruct quad8 *const priv = counter_priv(counter);\n\tconst size_t channel_id = signal->id / 2;\n\tunsigned long irqflags;\n\tunsigned int cable_fault_enable;\n\tint ret;\n\n\tspin_lock_irqsave(&priv->lock, irqflags);\n\n\tif (enable)\n\t\tpriv->cable_fault_enable |= BIT(channel_id);\n\telse\n\t\tpriv->cable_fault_enable &= ~BIT(channel_id);\n\n\t \n\tcable_fault_enable = ~priv->cable_fault_enable;\n\n\tret = regmap_write(priv->map, QUAD8_CABLE_STATUS, cable_fault_enable);\n\n\tspin_unlock_irqrestore(&priv->lock, irqflags);\n\n\treturn ret;\n}\n\nstatic int quad8_signal_fck_prescaler_read(struct counter_device *counter,\n\t\t\t\t\t   struct counter_signal *signal,\n\t\t\t\t\t   u8 *prescaler)\n{\n\tconst struct quad8 *const priv = counter_priv(counter);\n\n\t*prescaler = priv->fck_prescaler[signal->id / 2];\n\n\treturn 0;\n}\n\nstatic int quad8_filter_clock_prescaler_set(struct quad8 *const priv, const size_t id,\n\t\t\t\t\t    const u8 prescaler)\n{\n\tint ret;\n\n\tret = regmap_write(priv->map, QUAD8_CONTROL(id), SELECT_RLD | RESET_BP);\n\tif (ret)\n\t\treturn ret;\n\tret = regmap_write(priv->map, QUAD8_DATA(id), prescaler);\n\tif (ret)\n\t\treturn ret;\n\treturn regmap_write(priv->map, QUAD8_CONTROL(id), SELECT_RLD | TRANSFER_PR0_TO_PSC);\n}\n\nstatic int quad8_signal_fck_prescaler_write(struct counter_device *counter,\n\t\t\t\t\t    struct counter_signal *signal,\n\t\t\t\t\t    u8 prescaler)\n{\n\tstruct quad8 *const priv = counter_priv(counter);\n\tconst size_t channel_id = signal->id / 2;\n\tunsigned long irqflags;\n\tint ret;\n\n\tspin_lock_irqsave(&priv->lock, irqflags);\n\n\tpriv->fck_prescaler[channel_id] = prescaler;\n\tret = quad8_filter_clock_prescaler_set(priv, channel_id, prescaler);\n\n\tspin_unlock_irqrestore(&priv->lock, irqflags);\n\n\treturn ret;\n}\n\nstatic struct counter_comp quad8_signal_ext[] = {\n\tCOUNTER_COMP_SIGNAL_BOOL(\"cable_fault\", quad8_signal_cable_fault_read,\n\t\t\t\t NULL),\n\tCOUNTER_COMP_SIGNAL_BOOL(\"cable_fault_enable\",\n\t\t\t\t quad8_signal_cable_fault_enable_read,\n\t\t\t\t quad8_signal_cable_fault_enable_write),\n\tCOUNTER_COMP_SIGNAL_U8(\"filter_clock_prescaler\",\n\t\t\t       quad8_signal_fck_prescaler_read,\n\t\t\t       quad8_signal_fck_prescaler_write)\n};\n\nstatic const enum counter_signal_polarity quad8_polarities[] = {\n\tCOUNTER_SIGNAL_POLARITY_POSITIVE,\n\tCOUNTER_SIGNAL_POLARITY_NEGATIVE,\n};\n\nstatic DEFINE_COUNTER_AVAILABLE(quad8_polarity_available, quad8_polarities);\n\nstatic DEFINE_COUNTER_ENUM(quad8_index_pol_enum, quad8_index_polarity_modes);\nstatic DEFINE_COUNTER_ENUM(quad8_synch_mode_enum, quad8_synchronous_modes);\n\nstatic struct counter_comp quad8_index_ext[] = {\n\tCOUNTER_COMP_SIGNAL_ENUM(\"index_polarity\", quad8_index_polarity_get,\n\t\t\t\t quad8_index_polarity_set,\n\t\t\t\t quad8_index_pol_enum),\n\tCOUNTER_COMP_POLARITY(quad8_polarity_read, quad8_polarity_write,\n\t\t\t      quad8_polarity_available),\n\tCOUNTER_COMP_SIGNAL_ENUM(\"synchronous_mode\", quad8_synchronous_mode_get,\n\t\t\t\t quad8_synchronous_mode_set,\n\t\t\t\t quad8_synch_mode_enum),\n};\n\n#define QUAD8_QUAD_SIGNAL(_id, _name) {\t\t\\\n\t.id = (_id),\t\t\t\t\\\n\t.name = (_name),\t\t\t\\\n\t.ext = quad8_signal_ext,\t\t\\\n\t.num_ext = ARRAY_SIZE(quad8_signal_ext)\t\\\n}\n\n#define\tQUAD8_INDEX_SIGNAL(_id, _name) {\t\\\n\t.id = (_id),\t\t\t\t\\\n\t.name = (_name),\t\t\t\\\n\t.ext = quad8_index_ext,\t\t\t\\\n\t.num_ext = ARRAY_SIZE(quad8_index_ext)\t\\\n}\n\nstatic struct counter_signal quad8_signals[] = {\n\tQUAD8_QUAD_SIGNAL(0, \"Channel 1 Quadrature A\"),\n\tQUAD8_QUAD_SIGNAL(1, \"Channel 1 Quadrature B\"),\n\tQUAD8_QUAD_SIGNAL(2, \"Channel 2 Quadrature A\"),\n\tQUAD8_QUAD_SIGNAL(3, \"Channel 2 Quadrature B\"),\n\tQUAD8_QUAD_SIGNAL(4, \"Channel 3 Quadrature A\"),\n\tQUAD8_QUAD_SIGNAL(5, \"Channel 3 Quadrature B\"),\n\tQUAD8_QUAD_SIGNAL(6, \"Channel 4 Quadrature A\"),\n\tQUAD8_QUAD_SIGNAL(7, \"Channel 4 Quadrature B\"),\n\tQUAD8_QUAD_SIGNAL(8, \"Channel 5 Quadrature A\"),\n\tQUAD8_QUAD_SIGNAL(9, \"Channel 5 Quadrature B\"),\n\tQUAD8_QUAD_SIGNAL(10, \"Channel 6 Quadrature A\"),\n\tQUAD8_QUAD_SIGNAL(11, \"Channel 6 Quadrature B\"),\n\tQUAD8_QUAD_SIGNAL(12, \"Channel 7 Quadrature A\"),\n\tQUAD8_QUAD_SIGNAL(13, \"Channel 7 Quadrature B\"),\n\tQUAD8_QUAD_SIGNAL(14, \"Channel 8 Quadrature A\"),\n\tQUAD8_QUAD_SIGNAL(15, \"Channel 8 Quadrature B\"),\n\tQUAD8_INDEX_SIGNAL(16, \"Channel 1 Index\"),\n\tQUAD8_INDEX_SIGNAL(17, \"Channel 2 Index\"),\n\tQUAD8_INDEX_SIGNAL(18, \"Channel 3 Index\"),\n\tQUAD8_INDEX_SIGNAL(19, \"Channel 4 Index\"),\n\tQUAD8_INDEX_SIGNAL(20, \"Channel 5 Index\"),\n\tQUAD8_INDEX_SIGNAL(21, \"Channel 6 Index\"),\n\tQUAD8_INDEX_SIGNAL(22, \"Channel 7 Index\"),\n\tQUAD8_INDEX_SIGNAL(23, \"Channel 8 Index\")\n};\n\n#define QUAD8_COUNT_SYNAPSES(_id) {\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.actions_list = quad8_synapse_actions_list,\t\t\\\n\t\t.num_actions = ARRAY_SIZE(quad8_synapse_actions_list),\t\\\n\t\t.signal = quad8_signals + 2 * (_id)\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.actions_list = quad8_synapse_actions_list,\t\t\\\n\t\t.num_actions = ARRAY_SIZE(quad8_synapse_actions_list),\t\\\n\t\t.signal = quad8_signals + 2 * (_id) + 1\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.actions_list = quad8_index_actions_list,\t\t\\\n\t\t.num_actions = ARRAY_SIZE(quad8_index_actions_list),\t\\\n\t\t.signal = quad8_signals + 2 * (_id) + 16\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n}\n\nstatic struct counter_synapse quad8_count_synapses[][3] = {\n\tQUAD8_COUNT_SYNAPSES(0), QUAD8_COUNT_SYNAPSES(1),\n\tQUAD8_COUNT_SYNAPSES(2), QUAD8_COUNT_SYNAPSES(3),\n\tQUAD8_COUNT_SYNAPSES(4), QUAD8_COUNT_SYNAPSES(5),\n\tQUAD8_COUNT_SYNAPSES(6), QUAD8_COUNT_SYNAPSES(7)\n};\n\nstatic const enum counter_count_mode quad8_cnt_modes[] = {\n\tCOUNTER_COUNT_MODE_NORMAL,\n\tCOUNTER_COUNT_MODE_RANGE_LIMIT,\n\tCOUNTER_COUNT_MODE_NON_RECYCLE,\n\tCOUNTER_COUNT_MODE_MODULO_N,\n};\n\nstatic DEFINE_COUNTER_AVAILABLE(quad8_count_mode_available, quad8_cnt_modes);\n\nstatic DEFINE_COUNTER_ENUM(quad8_error_noise_enum, quad8_noise_error_states);\n\nstatic struct counter_comp quad8_count_ext[] = {\n\tCOUNTER_COMP_CEILING(quad8_count_ceiling_read,\n\t\t\t     quad8_count_ceiling_write),\n\tCOUNTER_COMP_FLOOR(quad8_count_floor_read, NULL),\n\tCOUNTER_COMP_COUNT_MODE(quad8_count_mode_read, quad8_count_mode_write,\n\t\t\t\tquad8_count_mode_available),\n\tCOUNTER_COMP_DIRECTION(quad8_direction_read),\n\tCOUNTER_COMP_ENABLE(quad8_count_enable_read, quad8_count_enable_write),\n\tCOUNTER_COMP_COUNT_ENUM(\"error_noise\", quad8_error_noise_get, NULL,\n\t\t\t\tquad8_error_noise_enum),\n\tCOUNTER_COMP_PRESET(quad8_count_preset_read, quad8_count_preset_write),\n\tCOUNTER_COMP_PRESET_ENABLE(quad8_count_preset_enable_read,\n\t\t\t\t   quad8_count_preset_enable_write),\n};\n\n#define QUAD8_COUNT(_id, _cntname) {\t\t\t\t\t\\\n\t.id = (_id),\t\t\t\t\t\t\t\\\n\t.name = (_cntname),\t\t\t\t\t\t\\\n\t.functions_list = quad8_count_functions_list,\t\t\t\\\n\t.num_functions = ARRAY_SIZE(quad8_count_functions_list),\t\\\n\t.synapses = quad8_count_synapses[(_id)],\t\t\t\\\n\t.num_synapses =\t2,\t\t\t\t\t\t\\\n\t.ext = quad8_count_ext,\t\t\t\t\t\t\\\n\t.num_ext = ARRAY_SIZE(quad8_count_ext)\t\t\t\t\\\n}\n\nstatic struct counter_count quad8_counts[] = {\n\tQUAD8_COUNT(0, \"Channel 1 Count\"),\n\tQUAD8_COUNT(1, \"Channel 2 Count\"),\n\tQUAD8_COUNT(2, \"Channel 3 Count\"),\n\tQUAD8_COUNT(3, \"Channel 4 Count\"),\n\tQUAD8_COUNT(4, \"Channel 5 Count\"),\n\tQUAD8_COUNT(5, \"Channel 6 Count\"),\n\tQUAD8_COUNT(6, \"Channel 7 Count\"),\n\tQUAD8_COUNT(7, \"Channel 8 Count\")\n};\n\nstatic irqreturn_t quad8_irq_handler(int irq, void *private)\n{\n\tstruct counter_device *counter = private;\n\tstruct quad8 *const priv = counter_priv(counter);\n\tunsigned int status;\n\tunsigned long irq_status;\n\tunsigned long channel;\n\tunsigned int flg_pins;\n\tu8 event;\n\tint ret;\n\n\tret = regmap_read(priv->map, QUAD8_INTERRUPT_STATUS, &status);\n\tif (ret)\n\t\treturn ret;\n\tif (!status)\n\t\treturn IRQ_NONE;\n\n\tirq_status = status;\n\tfor_each_set_bit(channel, &irq_status, QUAD8_NUM_COUNTERS) {\n\t\tflg_pins = u8_get_bits(priv->ior[channel], FLG_PINS);\n\t\tswitch (flg_pins) {\n\t\tcase FLG1_CARRY_FLG2_BORROW:\n\t\t\tevent = COUNTER_EVENT_OVERFLOW;\n\t\t\t\tbreak;\n\t\tcase FLG1_COMPARE_FLG2_BORROW:\n\t\t\tevent = COUNTER_EVENT_THRESHOLD;\n\t\t\t\tbreak;\n\t\tcase FLG1_CARRYBORROW_FLG2_UD:\n\t\t\tevent = COUNTER_EVENT_OVERFLOW_UNDERFLOW;\n\t\t\t\tbreak;\n\t\tcase FLG1_INDX_FLG2_E:\n\t\t\tevent = COUNTER_EVENT_INDEX;\n\t\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tWARN_ONCE(true, \"invalid interrupt trigger function %u configured for channel %lu\\n\",\n\t\t\t\t  flg_pins, channel);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcounter_push_event(counter, event, channel);\n\t}\n\n\tret = regmap_write(priv->map, QUAD8_CHANNEL_OPERATION, CLEAR_PENDING_INTERRUPTS);\n\tif (ret)\n\t\treturn ret;\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int quad8_init_counter(struct quad8 *const priv, const size_t channel)\n{\n\tint ret;\n\n\tret = quad8_filter_clock_prescaler_set(priv, channel, 0);\n\tif (ret)\n\t\treturn ret;\n\tret = quad8_preset_register_set(priv, channel, 0);\n\tif (ret)\n\t\treturn ret;\n\tret = quad8_flag_register_reset(priv, channel);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tpriv->cmr[channel] = SELECT_CMR | BINARY | u8_encode_bits(NORMAL_COUNT, COUNT_MODE) |\n\t\t\t     u8_encode_bits(NON_QUADRATURE, QUADRATURE_MODE);\n\tret = regmap_write(priv->map, QUAD8_CONTROL(channel), priv->cmr[channel]);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tpriv->ior[channel] = SELECT_IOR | DISABLE_AB | u8_encode_bits(LOAD_CNTR, LOAD_PIN) |\n\t\t\t     u8_encode_bits(FLG1_CARRY_FLG2_BORROW, FLG_PINS);\n\tret = regmap_write(priv->map, QUAD8_CONTROL(channel), priv->ior[channel]);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tpriv->idr[channel] = SELECT_IDR | u8_encode_bits(DISABLE_INDEX_MODE, INDEX_MODE) |\n\t\t\t     u8_encode_bits(NEGATIVE_INDEX_POLARITY, INDEX_POLARITY);\n\treturn regmap_write(priv->map, QUAD8_CONTROL(channel), priv->idr[channel]);\n}\n\nstatic int quad8_probe(struct device *dev, unsigned int id)\n{\n\tstruct counter_device *counter;\n\tstruct quad8 *priv;\n\tvoid __iomem *regs;\n\tunsigned long i;\n\tint ret;\n\n\tif (!devm_request_region(dev, base[id], QUAD8_EXTENT, dev_name(dev))) {\n\t\tdev_err(dev, \"Unable to lock port addresses (0x%X-0x%X)\\n\",\n\t\t\tbase[id], base[id] + QUAD8_EXTENT);\n\t\treturn -EBUSY;\n\t}\n\n\tcounter = devm_counter_alloc(dev, sizeof(*priv));\n\tif (!counter)\n\t\treturn -ENOMEM;\n\tpriv = counter_priv(counter);\n\n\tregs = devm_ioport_map(dev, base[id], QUAD8_EXTENT);\n\tif (!regs)\n\t\treturn -ENOMEM;\n\n\tpriv->map = devm_regmap_init_mmio(dev, regs, &quad8_regmap_config);\n\tif (IS_ERR(priv->map))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->map),\n\t\t\t\t     \"Unable to initialize register map\\n\");\n\n\t \n\tcounter->name = dev_name(dev);\n\tcounter->parent = dev;\n\tcounter->ops = &quad8_ops;\n\tcounter->counts = quad8_counts;\n\tcounter->num_counts = ARRAY_SIZE(quad8_counts);\n\tcounter->signals = quad8_signals;\n\tcounter->num_signals = ARRAY_SIZE(quad8_signals);\n\n\tspin_lock_init(&priv->lock);\n\n\t \n\tret = regmap_write(priv->map, QUAD8_INDEX_INTERRUPT, 0x00);\n\tif (ret)\n\t\treturn ret;\n\t \n\tret = regmap_write(priv->map, QUAD8_CHANNEL_OPERATION,\n\t\t\t   RESET_COUNTERS | DISABLE_INTERRUPT_FUNCTION);\n\tif (ret)\n\t\treturn ret;\n\t \n\tfor (i = 0; i < QUAD8_NUM_COUNTERS; i++) {\n\t\tret = quad8_init_counter(priv, i);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\t \n\tret = regmap_write(priv->map, QUAD8_CABLE_STATUS, GENMASK(7, 0));\n\tif (ret)\n\t\treturn ret;\n\t \n\tret = regmap_write(priv->map, QUAD8_CHANNEL_OPERATION,\n\t\t\t   ENABLE_COUNTERS | ENABLE_INTERRUPT_FUNCTION);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_request_irq(&counter->dev, irq[id], quad8_irq_handler,\n\t\t\t       IRQF_SHARED, counter->name, counter);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_counter_add(dev, counter);\n\tif (ret < 0)\n\t\treturn dev_err_probe(dev, ret, \"Failed to add counter\\n\");\n\n\treturn 0;\n}\n\nstatic struct isa_driver quad8_driver = {\n\t.probe = quad8_probe,\n\t.driver = {\n\t\t.name = \"104-quad-8\"\n\t}\n};\n\nmodule_isa_driver_with_irq(quad8_driver, num_quad8, num_irq);\n\nMODULE_AUTHOR(\"William Breathitt Gray <vilhelm.gray@gmail.com>\");\nMODULE_DESCRIPTION(\"ACCES 104-QUAD-8 driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_IMPORT_NS(COUNTER);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}