{
  "module_name": "interrupt-cnt.c",
  "hash_id": "f086979bba7c9237d8d71b57b140bb871ef07a68098145ca4d117fad1bb96393",
  "original_prompt": "Ingested from linux-6.6.14/drivers/counter/interrupt-cnt.c",
  "human_readable_source": "\n \n\n#include <linux/counter.h>\n#include <linux/gpio/consumer.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/types.h>\n\n#define INTERRUPT_CNT_NAME \"interrupt-cnt\"\n\nstruct interrupt_cnt_priv {\n\tatomic_t count;\n\tstruct gpio_desc *gpio;\n\tint irq;\n\tbool enabled;\n\tstruct counter_signal signals;\n\tstruct counter_synapse synapses;\n\tstruct counter_count cnts;\n};\n\nstatic irqreturn_t interrupt_cnt_isr(int irq, void *dev_id)\n{\n\tstruct counter_device *counter = dev_id;\n\tstruct interrupt_cnt_priv *priv = counter_priv(counter);\n\n\tatomic_inc(&priv->count);\n\n\tcounter_push_event(counter, COUNTER_EVENT_CHANGE_OF_STATE, 0);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int interrupt_cnt_enable_read(struct counter_device *counter,\n\t\t\t\t     struct counter_count *count, u8 *enable)\n{\n\tstruct interrupt_cnt_priv *priv = counter_priv(counter);\n\n\t*enable = priv->enabled;\n\n\treturn 0;\n}\n\nstatic int interrupt_cnt_enable_write(struct counter_device *counter,\n\t\t\t\t      struct counter_count *count, u8 enable)\n{\n\tstruct interrupt_cnt_priv *priv = counter_priv(counter);\n\n\tif (priv->enabled == enable)\n\t\treturn 0;\n\n\tif (enable) {\n\t\tpriv->enabled = true;\n\t\tenable_irq(priv->irq);\n\t} else {\n\t\tdisable_irq(priv->irq);\n\t\tpriv->enabled = false;\n\t}\n\n\treturn 0;\n}\n\nstatic struct counter_comp interrupt_cnt_ext[] = {\n\tCOUNTER_COMP_ENABLE(interrupt_cnt_enable_read,\n\t\t\t    interrupt_cnt_enable_write),\n};\n\nstatic const enum counter_synapse_action interrupt_cnt_synapse_actions[] = {\n\tCOUNTER_SYNAPSE_ACTION_RISING_EDGE,\n};\n\nstatic int interrupt_cnt_action_read(struct counter_device *counter,\n\t\t\t\t     struct counter_count *count,\n\t\t\t\t     struct counter_synapse *synapse,\n\t\t\t\t     enum counter_synapse_action *action)\n{\n\t*action = COUNTER_SYNAPSE_ACTION_RISING_EDGE;\n\n\treturn 0;\n}\n\nstatic int interrupt_cnt_read(struct counter_device *counter,\n\t\t\t      struct counter_count *count, u64 *val)\n{\n\tstruct interrupt_cnt_priv *priv = counter_priv(counter);\n\n\t*val = atomic_read(&priv->count);\n\n\treturn 0;\n}\n\nstatic int interrupt_cnt_write(struct counter_device *counter,\n\t\t\t       struct counter_count *count, const u64 val)\n{\n\tstruct interrupt_cnt_priv *priv = counter_priv(counter);\n\n\tif (val != (typeof(priv->count.counter))val)\n\t\treturn -ERANGE;\n\n\tatomic_set(&priv->count, val);\n\n\treturn 0;\n}\n\nstatic const enum counter_function interrupt_cnt_functions[] = {\n\tCOUNTER_FUNCTION_INCREASE,\n};\n\nstatic int interrupt_cnt_function_read(struct counter_device *counter,\n\t\t\t\t       struct counter_count *count,\n\t\t\t\t       enum counter_function *function)\n{\n\t*function = COUNTER_FUNCTION_INCREASE;\n\n\treturn 0;\n}\n\nstatic int interrupt_cnt_signal_read(struct counter_device *counter,\n\t\t\t\t     struct counter_signal *signal,\n\t\t\t\t     enum counter_signal_level *level)\n{\n\tstruct interrupt_cnt_priv *priv = counter_priv(counter);\n\tint ret;\n\n\tif (!priv->gpio)\n\t\treturn -EINVAL;\n\n\tret = gpiod_get_value(priv->gpio);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*level = ret ? COUNTER_SIGNAL_LEVEL_HIGH : COUNTER_SIGNAL_LEVEL_LOW;\n\n\treturn 0;\n}\n\nstatic int interrupt_cnt_watch_validate(struct counter_device *counter,\n\t\t\t\t\tconst struct counter_watch *watch)\n{\n\tif (watch->channel != 0 ||\n\t    watch->event != COUNTER_EVENT_CHANGE_OF_STATE)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic const struct counter_ops interrupt_cnt_ops = {\n\t.action_read = interrupt_cnt_action_read,\n\t.count_read = interrupt_cnt_read,\n\t.count_write = interrupt_cnt_write,\n\t.function_read = interrupt_cnt_function_read,\n\t.signal_read  = interrupt_cnt_signal_read,\n\t.watch_validate  = interrupt_cnt_watch_validate,\n};\n\nstatic int interrupt_cnt_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct counter_device *counter;\n\tstruct interrupt_cnt_priv *priv;\n\tint ret;\n\n\tcounter = devm_counter_alloc(dev, sizeof(*priv));\n\tif (!counter)\n\t\treturn -ENOMEM;\n\tpriv = counter_priv(counter);\n\n\tpriv->irq = platform_get_irq_optional(pdev,  0);\n\tif (priv->irq == -ENXIO)\n\t\tpriv->irq = 0;\n\telse if (priv->irq < 0)\n\t\treturn dev_err_probe(dev, priv->irq, \"failed to get IRQ\\n\");\n\n\tpriv->gpio = devm_gpiod_get_optional(dev, NULL, GPIOD_IN);\n\tif (IS_ERR(priv->gpio))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->gpio), \"failed to get GPIO\\n\");\n\n\tif (!priv->irq && !priv->gpio) {\n\t\tdev_err(dev, \"IRQ and GPIO are not found. At least one source should be provided\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!priv->irq) {\n\t\tint irq = gpiod_to_irq(priv->gpio);\n\n\t\tif (irq < 0)\n\t\t\treturn dev_err_probe(dev, irq, \"failed to get IRQ from GPIO\\n\");\n\n\t\tpriv->irq = irq;\n\t}\n\n\tpriv->signals.name = devm_kasprintf(dev, GFP_KERNEL, \"IRQ %d\",\n\t\t\t\t\t    priv->irq);\n\tif (!priv->signals.name)\n\t\treturn -ENOMEM;\n\n\tcounter->signals = &priv->signals;\n\tcounter->num_signals = 1;\n\n\tpriv->synapses.actions_list = interrupt_cnt_synapse_actions;\n\tpriv->synapses.num_actions = ARRAY_SIZE(interrupt_cnt_synapse_actions);\n\tpriv->synapses.signal = &priv->signals;\n\n\tpriv->cnts.name = \"Channel 0 Count\";\n\tpriv->cnts.functions_list = interrupt_cnt_functions;\n\tpriv->cnts.num_functions = ARRAY_SIZE(interrupt_cnt_functions);\n\tpriv->cnts.synapses = &priv->synapses;\n\tpriv->cnts.num_synapses = 1;\n\tpriv->cnts.ext = interrupt_cnt_ext;\n\tpriv->cnts.num_ext = ARRAY_SIZE(interrupt_cnt_ext);\n\n\tcounter->name = dev_name(dev);\n\tcounter->parent = dev;\n\tcounter->ops = &interrupt_cnt_ops;\n\tcounter->counts = &priv->cnts;\n\tcounter->num_counts = 1;\n\n\tirq_set_status_flags(priv->irq, IRQ_NOAUTOEN);\n\tret = devm_request_irq(dev, priv->irq, interrupt_cnt_isr,\n\t\t\t       IRQF_TRIGGER_RISING | IRQF_NO_THREAD,\n\t\t\t       dev_name(dev), counter);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_counter_add(dev, counter);\n\tif (ret < 0)\n\t\treturn dev_err_probe(dev, ret, \"Failed to add counter\\n\");\n\n\treturn 0;\n}\n\nstatic const struct of_device_id interrupt_cnt_of_match[] = {\n\t{ .compatible = \"interrupt-counter\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, interrupt_cnt_of_match);\n\nstatic struct platform_driver interrupt_cnt_driver = {\n\t.probe = interrupt_cnt_probe,\n\t.driver = {\n\t\t.name = INTERRUPT_CNT_NAME,\n\t\t.of_match_table = interrupt_cnt_of_match,\n\t},\n};\nmodule_platform_driver(interrupt_cnt_driver);\n\nMODULE_ALIAS(\"platform:interrupt-counter\");\nMODULE_AUTHOR(\"Oleksij Rempel <o.rempel@pengutronix.de>\");\nMODULE_DESCRIPTION(\"Interrupt counter driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_IMPORT_NS(COUNTER);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}