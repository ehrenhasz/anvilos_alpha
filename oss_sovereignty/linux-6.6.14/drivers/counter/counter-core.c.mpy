{
  "module_name": "counter-core.c",
  "hash_id": "a4a2659dfcb85ba13c760cb2c21579e3ea551048d8f6b4161e8f070f9f6330ed",
  "original_prompt": "Ingested from linux-6.6.14/drivers/counter/counter-core.c",
  "human_readable_source": "\n \n#include <linux/cdev.h>\n#include <linux/counter.h>\n#include <linux/device.h>\n#include <linux/device/bus.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/kdev_t.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/wait.h>\n\n#include \"counter-chrdev.h\"\n#include \"counter-sysfs.h\"\n\n#define COUNTER_NAME\t\"counter\"\n\n \nstatic DEFINE_IDA(counter_ida);\n\nstruct counter_device_allochelper {\n\tstruct counter_device counter;\n\n\t \n\tunsigned long privdata[] ____cacheline_aligned;\n};\n\nstatic void counter_device_release(struct device *dev)\n{\n\tstruct counter_device *const counter =\n\t\tcontainer_of(dev, struct counter_device, dev);\n\n\tcounter_chrdev_remove(counter);\n\tida_free(&counter_ida, dev->id);\n\n\tkfree(container_of(counter, struct counter_device_allochelper, counter));\n}\n\nstatic struct device_type counter_device_type = {\n\t.name = \"counter_device\",\n\t.release = counter_device_release,\n};\n\nstatic struct bus_type counter_bus_type = {\n\t.name = \"counter\",\n\t.dev_name = \"counter\",\n};\n\nstatic dev_t counter_devt;\n\n \nvoid *counter_priv(const struct counter_device *const counter)\n{\n\tstruct counter_device_allochelper *ch =\n\t\tcontainer_of(counter, struct counter_device_allochelper, counter);\n\n\treturn &ch->privdata;\n}\nEXPORT_SYMBOL_NS_GPL(counter_priv, COUNTER);\n\n \nstruct counter_device *counter_alloc(size_t sizeof_priv)\n{\n\tstruct counter_device_allochelper *ch;\n\tstruct counter_device *counter;\n\tstruct device *dev;\n\tint err;\n\n\tch = kzalloc(sizeof(*ch) + sizeof_priv, GFP_KERNEL);\n\tif (!ch)\n\t\treturn NULL;\n\n\tcounter = &ch->counter;\n\tdev = &counter->dev;\n\n\t \n\terr = ida_alloc(&counter_ida, GFP_KERNEL);\n\tif (err < 0)\n\t\tgoto err_ida_alloc;\n\tdev->id = err;\n\n\tmutex_init(&counter->ops_exist_lock);\n\tdev->type = &counter_device_type;\n\tdev->bus = &counter_bus_type;\n\tdev->devt = MKDEV(MAJOR(counter_devt), dev->id);\n\n\terr = counter_chrdev_add(counter);\n\tif (err < 0)\n\t\tgoto err_chrdev_add;\n\n\tdevice_initialize(dev);\n\n\terr = dev_set_name(dev, COUNTER_NAME \"%d\", dev->id);\n\tif (err)\n\t\tgoto err_dev_set_name;\n\n\treturn counter;\n\nerr_dev_set_name:\n\n\tcounter_chrdev_remove(counter);\nerr_chrdev_add:\n\n\tida_free(&counter_ida, dev->id);\nerr_ida_alloc:\n\n\tkfree(ch);\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_NS_GPL(counter_alloc, COUNTER);\n\nvoid counter_put(struct counter_device *counter)\n{\n\tput_device(&counter->dev);\n}\nEXPORT_SYMBOL_NS_GPL(counter_put, COUNTER);\n\n \nint counter_add(struct counter_device *counter)\n{\n\tint err;\n\tstruct device *dev = &counter->dev;\n\n\tif (counter->parent) {\n\t\tdev->parent = counter->parent;\n\t\tdev->of_node = counter->parent->of_node;\n\t}\n\n\terr = counter_sysfs_add(counter);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\treturn cdev_device_add(&counter->chrdev, dev);\n}\nEXPORT_SYMBOL_NS_GPL(counter_add, COUNTER);\n\n \nvoid counter_unregister(struct counter_device *const counter)\n{\n\tif (!counter)\n\t\treturn;\n\n\tcdev_device_del(&counter->chrdev, &counter->dev);\n\n\tmutex_lock(&counter->ops_exist_lock);\n\n\tcounter->ops = NULL;\n\twake_up(&counter->events_wait);\n\n\tmutex_unlock(&counter->ops_exist_lock);\n}\nEXPORT_SYMBOL_NS_GPL(counter_unregister, COUNTER);\n\nstatic void devm_counter_release(void *counter)\n{\n\tcounter_unregister(counter);\n}\n\nstatic void devm_counter_put(void *counter)\n{\n\tcounter_put(counter);\n}\n\n \nstruct counter_device *devm_counter_alloc(struct device *dev, size_t sizeof_priv)\n{\n\tstruct counter_device *counter;\n\tint err;\n\n\tcounter = counter_alloc(sizeof_priv);\n\tif (!counter)\n\t\treturn NULL;\n\n\terr = devm_add_action_or_reset(dev, devm_counter_put, counter);\n\tif (err < 0)\n\t\treturn NULL;\n\n\treturn counter;\n}\nEXPORT_SYMBOL_NS_GPL(devm_counter_alloc, COUNTER);\n\n \nint devm_counter_add(struct device *dev,\n\t\t     struct counter_device *const counter)\n{\n\tint err;\n\n\terr = counter_add(counter);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn devm_add_action_or_reset(dev, devm_counter_release, counter);\n}\nEXPORT_SYMBOL_NS_GPL(devm_counter_add, COUNTER);\n\n#define COUNTER_DEV_MAX 256\n\nstatic int __init counter_init(void)\n{\n\tint err;\n\n\terr = bus_register(&counter_bus_type);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = alloc_chrdev_region(&counter_devt, 0, COUNTER_DEV_MAX,\n\t\t\t\t  COUNTER_NAME);\n\tif (err < 0)\n\t\tgoto err_unregister_bus;\n\n\treturn 0;\n\nerr_unregister_bus:\n\tbus_unregister(&counter_bus_type);\n\treturn err;\n}\n\nstatic void __exit counter_exit(void)\n{\n\tunregister_chrdev_region(counter_devt, COUNTER_DEV_MAX);\n\tbus_unregister(&counter_bus_type);\n}\n\nsubsys_initcall(counter_init);\nmodule_exit(counter_exit);\n\nMODULE_AUTHOR(\"William Breathitt Gray <vilhelm.gray@gmail.com>\");\nMODULE_DESCRIPTION(\"Generic Counter interface\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}