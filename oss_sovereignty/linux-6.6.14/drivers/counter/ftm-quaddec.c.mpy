{
  "module_name": "ftm-quaddec.c",
  "hash_id": "2df97d1c367e56d53ea047536104fd3657b0735a7ebdedbff027c2f96768b1b5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/counter/ftm-quaddec.c",
  "human_readable_source": "\n \n\n#include <linux/fsl/ftm.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/mutex.h>\n#include <linux/counter.h>\n#include <linux/bitfield.h>\n#include <linux/types.h>\n\n#define FTM_FIELD_UPDATE(ftm, offset, mask, val)\t\t\t\\\n\t({\t\t\t\t\t\t\t\t\\\n\t\tuint32_t flags;\t\t\t\t\t\t\\\n\t\tftm_read(ftm, offset, &flags);\t\t\t\t\\\n\t\tflags &= ~mask;\t\t\t\t\t\t\\\n\t\tflags |= FIELD_PREP(mask, val);\t\t\t\t\\\n\t\tftm_write(ftm, offset, flags);\t\t\t\t\\\n\t})\n\nstruct ftm_quaddec {\n\tstruct platform_device *pdev;\n\tvoid __iomem *ftm_base;\n\tbool big_endian;\n\tstruct mutex ftm_quaddec_mutex;\n};\n\nstatic void ftm_read(struct ftm_quaddec *ftm, uint32_t offset, uint32_t *data)\n{\n\tif (ftm->big_endian)\n\t\t*data = ioread32be(ftm->ftm_base + offset);\n\telse\n\t\t*data = ioread32(ftm->ftm_base + offset);\n}\n\nstatic void ftm_write(struct ftm_quaddec *ftm, uint32_t offset, uint32_t data)\n{\n\tif (ftm->big_endian)\n\t\tiowrite32be(data, ftm->ftm_base + offset);\n\telse\n\t\tiowrite32(data, ftm->ftm_base + offset);\n}\n\n \nstatic void ftm_clear_write_protection(struct ftm_quaddec *ftm)\n{\n\tuint32_t flag;\n\n\t \n\tftm_read(ftm, FTM_FMS, &flag);\n\n\tif (flag & FTM_FMS_WPEN)\n\t\tFTM_FIELD_UPDATE(ftm, FTM_MODE, FTM_MODE_WPDIS, 1);\n}\n\nstatic void ftm_set_write_protection(struct ftm_quaddec *ftm)\n{\n\tFTM_FIELD_UPDATE(ftm, FTM_FMS, FTM_FMS_WPEN, 1);\n}\n\nstatic void ftm_reset_counter(struct ftm_quaddec *ftm)\n{\n\t \n\tftm_write(ftm, FTM_CNT, 0x0);\n}\n\nstatic void ftm_quaddec_init(struct ftm_quaddec *ftm)\n{\n\tftm_clear_write_protection(ftm);\n\n\t \n\tftm_write(ftm, FTM_MODE, FTM_MODE_FTMEN);\n\tftm_write(ftm, FTM_CNTIN, 0x0000);\n\tftm_write(ftm, FTM_MOD, 0xffff);\n\tftm_write(ftm, FTM_CNT, 0x0);\n\t \n\tftm_write(ftm, FTM_SC, FTM_SC_PS_1);\n\n\t \n\tftm_write(ftm, FTM_QDCTRL, FTM_QDCTRL_QUADEN);\n\n\t \n\tftm_write(ftm, FTM_POL, 0x0);\n\tftm_write(ftm, FTM_FLTCTRL, 0x0);\n\tftm_write(ftm, FTM_SYNCONF, 0x0);\n\tftm_write(ftm, FTM_SYNC, 0xffff);\n\n\t \n\tftm_set_write_protection(ftm);\n}\n\nstatic void ftm_quaddec_disable(void *ftm)\n{\n\tstruct ftm_quaddec *ftm_qua = ftm;\n\n\tftm_clear_write_protection(ftm_qua);\n\tftm_write(ftm_qua, FTM_MODE, 0);\n\tftm_write(ftm_qua, FTM_QDCTRL, 0);\n\t \n\tftm_set_write_protection(ftm_qua);\n}\n\nstatic int ftm_quaddec_get_prescaler(struct counter_device *counter,\n\t\t\t\t     struct counter_count *count, u32 *cnt_mode)\n{\n\tstruct ftm_quaddec *ftm = counter_priv(counter);\n\tuint32_t scflags;\n\n\tftm_read(ftm, FTM_SC, &scflags);\n\n\t*cnt_mode = FIELD_GET(FTM_SC_PS_MASK, scflags);\n\n\treturn 0;\n}\n\nstatic int ftm_quaddec_set_prescaler(struct counter_device *counter,\n\t\t\t\t     struct counter_count *count, u32 cnt_mode)\n{\n\tstruct ftm_quaddec *ftm = counter_priv(counter);\n\n\tmutex_lock(&ftm->ftm_quaddec_mutex);\n\n\tftm_clear_write_protection(ftm);\n\tFTM_FIELD_UPDATE(ftm, FTM_SC, FTM_SC_PS_MASK, cnt_mode);\n\tftm_set_write_protection(ftm);\n\n\t \n\tftm_reset_counter(ftm);\n\n\tmutex_unlock(&ftm->ftm_quaddec_mutex);\n\treturn 0;\n}\n\nstatic const char * const ftm_quaddec_prescaler[] = {\n\t\"1\", \"2\", \"4\", \"8\", \"16\", \"32\", \"64\", \"128\"\n};\n\nstatic const enum counter_synapse_action ftm_quaddec_synapse_actions[] = {\n\tCOUNTER_SYNAPSE_ACTION_BOTH_EDGES\n};\n\nstatic const enum counter_function ftm_quaddec_count_functions[] = {\n\tCOUNTER_FUNCTION_QUADRATURE_X4\n};\n\nstatic int ftm_quaddec_count_read(struct counter_device *counter,\n\t\t\t\t  struct counter_count *count,\n\t\t\t\t  u64 *val)\n{\n\tstruct ftm_quaddec *const ftm = counter_priv(counter);\n\tuint32_t cntval;\n\n\tftm_read(ftm, FTM_CNT, &cntval);\n\n\t*val = cntval;\n\n\treturn 0;\n}\n\nstatic int ftm_quaddec_count_write(struct counter_device *counter,\n\t\t\t\t   struct counter_count *count,\n\t\t\t\t   const u64 val)\n{\n\tstruct ftm_quaddec *const ftm = counter_priv(counter);\n\n\tif (val != 0) {\n\t\tdev_warn(&ftm->pdev->dev, \"Can only accept '0' as new counter value\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tftm_reset_counter(ftm);\n\n\treturn 0;\n}\n\nstatic int ftm_quaddec_count_function_read(struct counter_device *counter,\n\t\t\t\t\t   struct counter_count *count,\n\t\t\t\t\t   enum counter_function *function)\n{\n\t*function = COUNTER_FUNCTION_QUADRATURE_X4;\n\n\treturn 0;\n}\n\nstatic int ftm_quaddec_action_read(struct counter_device *counter,\n\t\t\t\t   struct counter_count *count,\n\t\t\t\t   struct counter_synapse *synapse,\n\t\t\t\t   enum counter_synapse_action *action)\n{\n\t*action = COUNTER_SYNAPSE_ACTION_BOTH_EDGES;\n\n\treturn 0;\n}\n\nstatic const struct counter_ops ftm_quaddec_cnt_ops = {\n\t.count_read = ftm_quaddec_count_read,\n\t.count_write = ftm_quaddec_count_write,\n\t.function_read = ftm_quaddec_count_function_read,\n\t.action_read = ftm_quaddec_action_read,\n};\n\nstatic struct counter_signal ftm_quaddec_signals[] = {\n\t{\n\t\t.id = 0,\n\t\t.name = \"Channel 1 Phase A\"\n\t},\n\t{\n\t\t.id = 1,\n\t\t.name = \"Channel 1 Phase B\"\n\t}\n};\n\nstatic struct counter_synapse ftm_quaddec_count_synapses[] = {\n\t{\n\t\t.actions_list = ftm_quaddec_synapse_actions,\n\t\t.num_actions = ARRAY_SIZE(ftm_quaddec_synapse_actions),\n\t\t.signal = &ftm_quaddec_signals[0]\n\t},\n\t{\n\t\t.actions_list = ftm_quaddec_synapse_actions,\n\t\t.num_actions = ARRAY_SIZE(ftm_quaddec_synapse_actions),\n\t\t.signal = &ftm_quaddec_signals[1]\n\t}\n};\n\nstatic DEFINE_COUNTER_ENUM(ftm_quaddec_prescaler_enum, ftm_quaddec_prescaler);\n\nstatic struct counter_comp ftm_quaddec_count_ext[] = {\n\tCOUNTER_COMP_COUNT_ENUM(\"prescaler\", ftm_quaddec_get_prescaler,\n\t\t\t\tftm_quaddec_set_prescaler,\n\t\t\t\tftm_quaddec_prescaler_enum),\n};\n\nstatic struct counter_count ftm_quaddec_counts = {\n\t.id = 0,\n\t.name = \"Channel 1 Count\",\n\t.functions_list = ftm_quaddec_count_functions,\n\t.num_functions = ARRAY_SIZE(ftm_quaddec_count_functions),\n\t.synapses = ftm_quaddec_count_synapses,\n\t.num_synapses = ARRAY_SIZE(ftm_quaddec_count_synapses),\n\t.ext = ftm_quaddec_count_ext,\n\t.num_ext = ARRAY_SIZE(ftm_quaddec_count_ext)\n};\n\nstatic int ftm_quaddec_probe(struct platform_device *pdev)\n{\n\tstruct counter_device *counter;\n\tstruct ftm_quaddec *ftm;\n\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct resource *io;\n\tint ret;\n\n\tcounter = devm_counter_alloc(&pdev->dev, sizeof(*ftm));\n\tif (!counter)\n\t\treturn -ENOMEM;\n\tftm = counter_priv(counter);\n\n\tio = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!io) {\n\t\tdev_err(&pdev->dev, \"Failed to get memory region\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tftm->pdev = pdev;\n\tftm->big_endian = of_property_read_bool(node, \"big-endian\");\n\tftm->ftm_base = devm_ioremap(&pdev->dev, io->start, resource_size(io));\n\n\tif (!ftm->ftm_base) {\n\t\tdev_err(&pdev->dev, \"Failed to map memory region\\n\");\n\t\treturn -EINVAL;\n\t}\n\tcounter->name = dev_name(&pdev->dev);\n\tcounter->parent = &pdev->dev;\n\tcounter->ops = &ftm_quaddec_cnt_ops;\n\tcounter->counts = &ftm_quaddec_counts;\n\tcounter->num_counts = 1;\n\tcounter->signals = ftm_quaddec_signals;\n\tcounter->num_signals = ARRAY_SIZE(ftm_quaddec_signals);\n\n\tmutex_init(&ftm->ftm_quaddec_mutex);\n\n\tftm_quaddec_init(ftm);\n\n\tret = devm_add_action_or_reset(&pdev->dev, ftm_quaddec_disable, ftm);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_counter_add(&pdev->dev, counter);\n\tif (ret)\n\t\treturn dev_err_probe(&pdev->dev, ret, \"Failed to add counter\\n\");\n\n\treturn 0;\n}\n\nstatic const struct of_device_id ftm_quaddec_match[] = {\n\t{ .compatible = \"fsl,ftm-quaddec\" },\n\t{},\n};\n\nstatic struct platform_driver ftm_quaddec_driver = {\n\t.driver = {\n\t\t.name = \"ftm-quaddec\",\n\t\t.of_match_table = ftm_quaddec_match,\n\t},\n\t.probe = ftm_quaddec_probe,\n};\n\nmodule_platform_driver(ftm_quaddec_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Kjeld Flarup <kfa@deif.com>\");\nMODULE_AUTHOR(\"Patrick Havelange <patrick.havelange@essensium.com>\");\nMODULE_IMPORT_NS(COUNTER);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}