{
  "module_name": "stm32-lptimer-cnt.c",
  "hash_id": "a29d5c4442a8711a44b9f5dfb875971b9dafa98d3d786ee8c352d4369ccdbfdc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/counter/stm32-lptimer-cnt.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/counter.h>\n#include <linux/mfd/stm32-lptimer.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/types.h>\n\nstruct stm32_lptim_cnt {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tstruct clk *clk;\n\tu32 ceiling;\n\tu32 polarity;\n\tu32 quadrature_mode;\n\tbool enabled;\n};\n\nstatic int stm32_lptim_is_enabled(struct stm32_lptim_cnt *priv)\n{\n\tu32 val;\n\tint ret;\n\n\tret = regmap_read(priv->regmap, STM32_LPTIM_CR, &val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn FIELD_GET(STM32_LPTIM_ENABLE, val);\n}\n\nstatic int stm32_lptim_set_enable_state(struct stm32_lptim_cnt *priv,\n\t\t\t\t\tint enable)\n{\n\tint ret;\n\tu32 val;\n\n\tval = FIELD_PREP(STM32_LPTIM_ENABLE, enable);\n\tret = regmap_write(priv->regmap, STM32_LPTIM_CR, val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!enable) {\n\t\tclk_disable(priv->clk);\n\t\tpriv->enabled = false;\n\t\treturn 0;\n\t}\n\n\t \n\tret = regmap_write(priv->regmap, STM32_LPTIM_ARR, priv->ceiling);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(priv->regmap, STM32_LPTIM_CMP, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_read_poll_timeout(priv->regmap, STM32_LPTIM_ISR, val,\n\t\t\t\t       (val & STM32_LPTIM_CMPOK_ARROK) == STM32_LPTIM_CMPOK_ARROK,\n\t\t\t\t       100, 1000);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(priv->regmap, STM32_LPTIM_ICR,\n\t\t\t   STM32_LPTIM_CMPOKCF_ARROKCF);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_enable(priv->clk);\n\tif (ret) {\n\t\tregmap_write(priv->regmap, STM32_LPTIM_CR, 0);\n\t\treturn ret;\n\t}\n\tpriv->enabled = true;\n\n\t \n\treturn regmap_update_bits(priv->regmap, STM32_LPTIM_CR,\n\t\t\t\t  STM32_LPTIM_CNTSTRT, STM32_LPTIM_CNTSTRT);\n}\n\nstatic int stm32_lptim_setup(struct stm32_lptim_cnt *priv, int enable)\n{\n\tu32 mask = STM32_LPTIM_ENC | STM32_LPTIM_COUNTMODE |\n\t\t   STM32_LPTIM_CKPOL | STM32_LPTIM_PRESC;\n\tu32 val;\n\n\t \n\tif (priv->quadrature_mode)\n\t\tval = enable ? STM32_LPTIM_ENC : 0;\n\telse\n\t\tval = enable ? STM32_LPTIM_COUNTMODE : 0;\n\tval |= FIELD_PREP(STM32_LPTIM_CKPOL, enable ? priv->polarity : 0);\n\n\treturn regmap_update_bits(priv->regmap, STM32_LPTIM_CFGR, mask, val);\n}\n\n \nstatic const enum counter_function stm32_lptim_cnt_functions[] = {\n\tCOUNTER_FUNCTION_INCREASE,\n\tCOUNTER_FUNCTION_QUADRATURE_X4,\n};\n\nstatic const enum counter_synapse_action stm32_lptim_cnt_synapse_actions[] = {\n\tCOUNTER_SYNAPSE_ACTION_RISING_EDGE,\n\tCOUNTER_SYNAPSE_ACTION_FALLING_EDGE,\n\tCOUNTER_SYNAPSE_ACTION_BOTH_EDGES,\n\tCOUNTER_SYNAPSE_ACTION_NONE,\n};\n\nstatic int stm32_lptim_cnt_read(struct counter_device *counter,\n\t\t\t\tstruct counter_count *count, u64 *val)\n{\n\tstruct stm32_lptim_cnt *const priv = counter_priv(counter);\n\tu32 cnt;\n\tint ret;\n\n\tret = regmap_read(priv->regmap, STM32_LPTIM_CNT, &cnt);\n\tif (ret)\n\t\treturn ret;\n\n\t*val = cnt;\n\n\treturn 0;\n}\n\nstatic int stm32_lptim_cnt_function_read(struct counter_device *counter,\n\t\t\t\t\t struct counter_count *count,\n\t\t\t\t\t enum counter_function *function)\n{\n\tstruct stm32_lptim_cnt *const priv = counter_priv(counter);\n\n\tif (!priv->quadrature_mode) {\n\t\t*function = COUNTER_FUNCTION_INCREASE;\n\t\treturn 0;\n\t}\n\n\tif (priv->polarity == STM32_LPTIM_CKPOL_BOTH_EDGES) {\n\t\t*function = COUNTER_FUNCTION_QUADRATURE_X4;\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int stm32_lptim_cnt_function_write(struct counter_device *counter,\n\t\t\t\t\t  struct counter_count *count,\n\t\t\t\t\t  enum counter_function function)\n{\n\tstruct stm32_lptim_cnt *const priv = counter_priv(counter);\n\n\tif (stm32_lptim_is_enabled(priv))\n\t\treturn -EBUSY;\n\n\tswitch (function) {\n\tcase COUNTER_FUNCTION_INCREASE:\n\t\tpriv->quadrature_mode = 0;\n\t\treturn 0;\n\tcase COUNTER_FUNCTION_QUADRATURE_X4:\n\t\tpriv->quadrature_mode = 1;\n\t\tpriv->polarity = STM32_LPTIM_CKPOL_BOTH_EDGES;\n\t\treturn 0;\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int stm32_lptim_cnt_enable_read(struct counter_device *counter,\n\t\t\t\t       struct counter_count *count,\n\t\t\t\t       u8 *enable)\n{\n\tstruct stm32_lptim_cnt *const priv = counter_priv(counter);\n\tint ret;\n\n\tret = stm32_lptim_is_enabled(priv);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*enable = ret;\n\n\treturn 0;\n}\n\nstatic int stm32_lptim_cnt_enable_write(struct counter_device *counter,\n\t\t\t\t\tstruct counter_count *count,\n\t\t\t\t\tu8 enable)\n{\n\tstruct stm32_lptim_cnt *const priv = counter_priv(counter);\n\tint ret;\n\n\t \n\tret = stm32_lptim_is_enabled(priv);\n\tif ((ret < 0) || (!ret && !enable))\n\t\treturn ret;\n\tif (enable && ret)\n\t\treturn -EBUSY;\n\n\tret = stm32_lptim_setup(priv, enable);\n\tif (ret)\n\t\treturn ret;\n\n\tret = stm32_lptim_set_enable_state(priv, enable);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int stm32_lptim_cnt_ceiling_read(struct counter_device *counter,\n\t\t\t\t\tstruct counter_count *count,\n\t\t\t\t\tu64 *ceiling)\n{\n\tstruct stm32_lptim_cnt *const priv = counter_priv(counter);\n\n\t*ceiling = priv->ceiling;\n\n\treturn 0;\n}\n\nstatic int stm32_lptim_cnt_ceiling_write(struct counter_device *counter,\n\t\t\t\t\t struct counter_count *count,\n\t\t\t\t\t u64 ceiling)\n{\n\tstruct stm32_lptim_cnt *const priv = counter_priv(counter);\n\n\tif (stm32_lptim_is_enabled(priv))\n\t\treturn -EBUSY;\n\n\tif (ceiling > STM32_LPTIM_MAX_ARR)\n\t\treturn -ERANGE;\n\n\tpriv->ceiling = ceiling;\n\n\treturn 0;\n}\n\nstatic struct counter_comp stm32_lptim_cnt_ext[] = {\n\tCOUNTER_COMP_ENABLE(stm32_lptim_cnt_enable_read,\n\t\t\t    stm32_lptim_cnt_enable_write),\n\tCOUNTER_COMP_CEILING(stm32_lptim_cnt_ceiling_read,\n\t\t\t     stm32_lptim_cnt_ceiling_write),\n};\n\nstatic int stm32_lptim_cnt_action_read(struct counter_device *counter,\n\t\t\t\t       struct counter_count *count,\n\t\t\t\t       struct counter_synapse *synapse,\n\t\t\t\t       enum counter_synapse_action *action)\n{\n\tstruct stm32_lptim_cnt *const priv = counter_priv(counter);\n\tenum counter_function function;\n\tint err;\n\n\terr = stm32_lptim_cnt_function_read(counter, count, &function);\n\tif (err)\n\t\treturn err;\n\n\tswitch (function) {\n\tcase COUNTER_FUNCTION_INCREASE:\n\t\t \n\t\tif (synapse->signal->id != count->synapses[0].signal->id) {\n\t\t\t*action = COUNTER_SYNAPSE_ACTION_NONE;\n\t\t\treturn 0;\n\t\t}\n\n\t\tswitch (priv->polarity) {\n\t\tcase STM32_LPTIM_CKPOL_RISING_EDGE:\n\t\t\t*action = COUNTER_SYNAPSE_ACTION_RISING_EDGE;\n\t\t\treturn 0;\n\t\tcase STM32_LPTIM_CKPOL_FALLING_EDGE:\n\t\t\t*action = COUNTER_SYNAPSE_ACTION_FALLING_EDGE;\n\t\t\treturn 0;\n\t\tcase STM32_LPTIM_CKPOL_BOTH_EDGES:\n\t\t\t*action = COUNTER_SYNAPSE_ACTION_BOTH_EDGES;\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\t \n\t\t\treturn -EINVAL;\n\t\t}\n\tcase COUNTER_FUNCTION_QUADRATURE_X4:\n\t\t*action = COUNTER_SYNAPSE_ACTION_BOTH_EDGES;\n\t\treturn 0;\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int stm32_lptim_cnt_action_write(struct counter_device *counter,\n\t\t\t\t\tstruct counter_count *count,\n\t\t\t\t\tstruct counter_synapse *synapse,\n\t\t\t\t\tenum counter_synapse_action action)\n{\n\tstruct stm32_lptim_cnt *const priv = counter_priv(counter);\n\tenum counter_function function;\n\tint err;\n\n\tif (stm32_lptim_is_enabled(priv))\n\t\treturn -EBUSY;\n\n\terr = stm32_lptim_cnt_function_read(counter, count, &function);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (function != COUNTER_FUNCTION_INCREASE\n\t    || synapse->signal->id != count->synapses[0].signal->id)\n\t\treturn -EINVAL;\n\n\tswitch (action) {\n\tcase COUNTER_SYNAPSE_ACTION_RISING_EDGE:\n\t\tpriv->polarity = STM32_LPTIM_CKPOL_RISING_EDGE;\n\t\treturn 0;\n\tcase COUNTER_SYNAPSE_ACTION_FALLING_EDGE:\n\t\tpriv->polarity = STM32_LPTIM_CKPOL_FALLING_EDGE;\n\t\treturn 0;\n\tcase COUNTER_SYNAPSE_ACTION_BOTH_EDGES:\n\t\tpriv->polarity = STM32_LPTIM_CKPOL_BOTH_EDGES;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct counter_ops stm32_lptim_cnt_ops = {\n\t.count_read = stm32_lptim_cnt_read,\n\t.function_read = stm32_lptim_cnt_function_read,\n\t.function_write = stm32_lptim_cnt_function_write,\n\t.action_read = stm32_lptim_cnt_action_read,\n\t.action_write = stm32_lptim_cnt_action_write,\n};\n\nstatic struct counter_signal stm32_lptim_cnt_signals[] = {\n\t{\n\t\t.id = 0,\n\t\t.name = \"Channel 1 Quadrature A\"\n\t},\n\t{\n\t\t.id = 1,\n\t\t.name = \"Channel 1 Quadrature B\"\n\t}\n};\n\nstatic struct counter_synapse stm32_lptim_cnt_synapses[] = {\n\t{\n\t\t.actions_list = stm32_lptim_cnt_synapse_actions,\n\t\t.num_actions = ARRAY_SIZE(stm32_lptim_cnt_synapse_actions),\n\t\t.signal = &stm32_lptim_cnt_signals[0]\n\t},\n\t{\n\t\t.actions_list = stm32_lptim_cnt_synapse_actions,\n\t\t.num_actions = ARRAY_SIZE(stm32_lptim_cnt_synapse_actions),\n\t\t.signal = &stm32_lptim_cnt_signals[1]\n\t}\n};\n\n \nstatic struct counter_count stm32_lptim_enc_counts = {\n\t.id = 0,\n\t.name = \"LPTimer Count\",\n\t.functions_list = stm32_lptim_cnt_functions,\n\t.num_functions = ARRAY_SIZE(stm32_lptim_cnt_functions),\n\t.synapses = stm32_lptim_cnt_synapses,\n\t.num_synapses = ARRAY_SIZE(stm32_lptim_cnt_synapses),\n\t.ext = stm32_lptim_cnt_ext,\n\t.num_ext = ARRAY_SIZE(stm32_lptim_cnt_ext)\n};\n\n \nstatic struct counter_count stm32_lptim_in1_counts = {\n\t.id = 0,\n\t.name = \"LPTimer Count\",\n\t.functions_list = stm32_lptim_cnt_functions,\n\t.num_functions = 1,\n\t.synapses = stm32_lptim_cnt_synapses,\n\t.num_synapses = 1,\n\t.ext = stm32_lptim_cnt_ext,\n\t.num_ext = ARRAY_SIZE(stm32_lptim_cnt_ext)\n};\n\nstatic int stm32_lptim_cnt_probe(struct platform_device *pdev)\n{\n\tstruct stm32_lptimer *ddata = dev_get_drvdata(pdev->dev.parent);\n\tstruct counter_device *counter;\n\tstruct stm32_lptim_cnt *priv;\n\tint ret;\n\n\tif (IS_ERR_OR_NULL(ddata))\n\t\treturn -EINVAL;\n\n\tcounter = devm_counter_alloc(&pdev->dev, sizeof(*priv));\n\tif (!counter)\n\t\treturn -ENOMEM;\n\tpriv = counter_priv(counter);\n\n\tpriv->dev = &pdev->dev;\n\tpriv->regmap = ddata->regmap;\n\tpriv->clk = ddata->clk;\n\tpriv->ceiling = STM32_LPTIM_MAX_ARR;\n\n\t \n\tcounter->name = dev_name(&pdev->dev);\n\tcounter->parent = &pdev->dev;\n\tcounter->ops = &stm32_lptim_cnt_ops;\n\tif (ddata->has_encoder) {\n\t\tcounter->counts = &stm32_lptim_enc_counts;\n\t\tcounter->num_signals = ARRAY_SIZE(stm32_lptim_cnt_signals);\n\t} else {\n\t\tcounter->counts = &stm32_lptim_in1_counts;\n\t\tcounter->num_signals = 1;\n\t}\n\tcounter->num_counts = 1;\n\tcounter->signals = stm32_lptim_cnt_signals;\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tret = devm_counter_add(&pdev->dev, counter);\n\tif (ret < 0)\n\t\treturn dev_err_probe(&pdev->dev, ret, \"Failed to add counter\\n\");\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int stm32_lptim_cnt_suspend(struct device *dev)\n{\n\tstruct stm32_lptim_cnt *priv = dev_get_drvdata(dev);\n\tint ret;\n\n\t \n\tif (priv->enabled) {\n\t\tret = stm32_lptim_setup(priv, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = stm32_lptim_set_enable_state(priv, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tpriv->enabled = true;\n\t}\n\n\treturn pinctrl_pm_select_sleep_state(dev);\n}\n\nstatic int stm32_lptim_cnt_resume(struct device *dev)\n{\n\tstruct stm32_lptim_cnt *priv = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = pinctrl_pm_select_default_state(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (priv->enabled) {\n\t\tpriv->enabled = false;\n\t\tret = stm32_lptim_setup(priv, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = stm32_lptim_set_enable_state(priv, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(stm32_lptim_cnt_pm_ops, stm32_lptim_cnt_suspend,\n\t\t\t stm32_lptim_cnt_resume);\n\nstatic const struct of_device_id stm32_lptim_cnt_of_match[] = {\n\t{ .compatible = \"st,stm32-lptimer-counter\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, stm32_lptim_cnt_of_match);\n\nstatic struct platform_driver stm32_lptim_cnt_driver = {\n\t.probe = stm32_lptim_cnt_probe,\n\t.driver = {\n\t\t.name = \"stm32-lptimer-counter\",\n\t\t.of_match_table = stm32_lptim_cnt_of_match,\n\t\t.pm = &stm32_lptim_cnt_pm_ops,\n\t},\n};\nmodule_platform_driver(stm32_lptim_cnt_driver);\n\nMODULE_AUTHOR(\"Fabrice Gasnier <fabrice.gasnier@st.com>\");\nMODULE_ALIAS(\"platform:stm32-lptimer-counter\");\nMODULE_DESCRIPTION(\"STMicroelectronics STM32 LPTIM counter driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_IMPORT_NS(COUNTER);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}