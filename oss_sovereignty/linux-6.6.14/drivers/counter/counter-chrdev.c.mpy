{
  "module_name": "counter-chrdev.c",
  "hash_id": "113cc2016db284324a4267378fbe32d64c7ba43feb1eed89c45404fcd0f63983",
  "original_prompt": "Ingested from linux-6.6.14/drivers/counter/counter-chrdev.c",
  "human_readable_source": "\n \n#include <linux/cdev.h>\n#include <linux/counter.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n#include <linux/kfifo.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/timekeeping.h>\n#include <linux/types.h>\n#include <linux/uaccess.h>\n#include <linux/wait.h>\n\n#include \"counter-chrdev.h\"\n\nstruct counter_comp_node {\n\tstruct list_head l;\n\tstruct counter_component component;\n\tstruct counter_comp comp;\n\tvoid *parent;\n};\n\n#define counter_comp_read_is_equal(a, b) \\\n\t(a.action_read == b.action_read || \\\n\ta.device_u8_read == b.device_u8_read || \\\n\ta.count_u8_read == b.count_u8_read || \\\n\ta.signal_u8_read == b.signal_u8_read || \\\n\ta.device_u32_read == b.device_u32_read || \\\n\ta.count_u32_read == b.count_u32_read || \\\n\ta.signal_u32_read == b.signal_u32_read || \\\n\ta.device_u64_read == b.device_u64_read || \\\n\ta.count_u64_read == b.count_u64_read || \\\n\ta.signal_u64_read == b.signal_u64_read || \\\n\ta.signal_array_u32_read == b.signal_array_u32_read || \\\n\ta.device_array_u64_read == b.device_array_u64_read || \\\n\ta.count_array_u64_read == b.count_array_u64_read || \\\n\ta.signal_array_u64_read == b.signal_array_u64_read)\n\n#define counter_comp_read_is_set(comp) \\\n\t(comp.action_read || \\\n\tcomp.device_u8_read || \\\n\tcomp.count_u8_read || \\\n\tcomp.signal_u8_read || \\\n\tcomp.device_u32_read || \\\n\tcomp.count_u32_read || \\\n\tcomp.signal_u32_read || \\\n\tcomp.device_u64_read || \\\n\tcomp.count_u64_read || \\\n\tcomp.signal_u64_read || \\\n\tcomp.signal_array_u32_read || \\\n\tcomp.device_array_u64_read || \\\n\tcomp.count_array_u64_read || \\\n\tcomp.signal_array_u64_read)\n\nstatic ssize_t counter_chrdev_read(struct file *filp, char __user *buf,\n\t\t\t\t   size_t len, loff_t *f_ps)\n{\n\tstruct counter_device *const counter = filp->private_data;\n\tint err;\n\tunsigned int copied;\n\n\tif (!counter->ops)\n\t\treturn -ENODEV;\n\n\tif (len < sizeof(struct counter_event))\n\t\treturn -EINVAL;\n\n\tdo {\n\t\tif (kfifo_is_empty(&counter->events)) {\n\t\t\tif (filp->f_flags & O_NONBLOCK)\n\t\t\t\treturn -EAGAIN;\n\n\t\t\terr = wait_event_interruptible(counter->events_wait,\n\t\t\t\t\t!kfifo_is_empty(&counter->events) ||\n\t\t\t\t\t!counter->ops);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t\tif (!counter->ops)\n\t\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tif (mutex_lock_interruptible(&counter->events_out_lock))\n\t\t\treturn -ERESTARTSYS;\n\t\terr = kfifo_to_user(&counter->events, buf, len, &copied);\n\t\tmutex_unlock(&counter->events_out_lock);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t} while (!copied);\n\n\treturn copied;\n}\n\nstatic __poll_t counter_chrdev_poll(struct file *filp,\n\t\t\t\t    struct poll_table_struct *pollt)\n{\n\tstruct counter_device *const counter = filp->private_data;\n\t__poll_t events = 0;\n\n\tif (!counter->ops)\n\t\treturn events;\n\n\tpoll_wait(filp, &counter->events_wait, pollt);\n\n\tif (!kfifo_is_empty(&counter->events))\n\t\tevents = EPOLLIN | EPOLLRDNORM;\n\n\treturn events;\n}\n\nstatic void counter_events_list_free(struct list_head *const events_list)\n{\n\tstruct counter_event_node *p, *n;\n\tstruct counter_comp_node *q, *o;\n\n\tlist_for_each_entry_safe(p, n, events_list, l) {\n\t\t \n\t\tlist_for_each_entry_safe(q, o, &p->comp_list, l) {\n\t\t\tlist_del(&q->l);\n\t\t\tkfree(q);\n\t\t}\n\n\t\t \n\t\tlist_del(&p->l);\n\t\tkfree(p);\n\t}\n}\n\nstatic int counter_set_event_node(struct counter_device *const counter,\n\t\t\t\t  struct counter_watch *const watch,\n\t\t\t\t  const struct counter_comp_node *const cfg)\n{\n\tstruct counter_event_node *event_node;\n\tint err = 0;\n\tstruct counter_comp_node *comp_node;\n\n\t \n\tlist_for_each_entry(event_node, &counter->next_events_list, l)\n\t\tif (event_node->event == watch->event &&\n\t\t    event_node->channel == watch->channel)\n\t\t\tbreak;\n\n\t \n\tif (&event_node->l == &counter->next_events_list) {\n\t\t \n\t\tevent_node = kmalloc(sizeof(*event_node), GFP_KERNEL);\n\t\tif (!event_node)\n\t\t\treturn -ENOMEM;\n\n\t\t \n\t\tevent_node->event = watch->event;\n\t\tevent_node->channel = watch->channel;\n\t\tINIT_LIST_HEAD(&event_node->comp_list);\n\t\tlist_add(&event_node->l, &counter->next_events_list);\n\t}\n\n\t \n\tlist_for_each_entry(comp_node, &event_node->comp_list, l)\n\t\tif (comp_node->parent == cfg->parent &&\n\t\t    counter_comp_read_is_equal(comp_node->comp, cfg->comp)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto exit_free_event_node;\n\t\t}\n\n\t \n\tcomp_node = kmalloc(sizeof(*comp_node), GFP_KERNEL);\n\tif (!comp_node) {\n\t\terr = -ENOMEM;\n\t\tgoto exit_free_event_node;\n\t}\n\t*comp_node = *cfg;\n\n\t \n\tlist_add_tail(&comp_node->l, &event_node->comp_list);\n\nexit_free_event_node:\n\t \n\tif (list_empty(&event_node->comp_list)) {\n\t\tlist_del(&event_node->l);\n\t\tkfree(event_node);\n\t}\n\n\treturn err;\n}\n\nstatic int counter_enable_events(struct counter_device *const counter)\n{\n\tunsigned long flags;\n\tint err = 0;\n\n\tmutex_lock(&counter->n_events_list_lock);\n\tspin_lock_irqsave(&counter->events_list_lock, flags);\n\n\tcounter_events_list_free(&counter->events_list);\n\tlist_replace_init(&counter->next_events_list,\n\t\t\t  &counter->events_list);\n\n\tif (counter->ops->events_configure)\n\t\terr = counter->ops->events_configure(counter);\n\n\tspin_unlock_irqrestore(&counter->events_list_lock, flags);\n\tmutex_unlock(&counter->n_events_list_lock);\n\n\treturn err;\n}\n\nstatic int counter_disable_events(struct counter_device *const counter)\n{\n\tunsigned long flags;\n\tint err = 0;\n\n\tspin_lock_irqsave(&counter->events_list_lock, flags);\n\n\tcounter_events_list_free(&counter->events_list);\n\n\tif (counter->ops->events_configure)\n\t\terr = counter->ops->events_configure(counter);\n\n\tspin_unlock_irqrestore(&counter->events_list_lock, flags);\n\n\tmutex_lock(&counter->n_events_list_lock);\n\n\tcounter_events_list_free(&counter->next_events_list);\n\n\tmutex_unlock(&counter->n_events_list_lock);\n\n\treturn err;\n}\n\nstatic int counter_get_ext(const struct counter_comp *const ext,\n\t\t\t   const size_t num_ext, const size_t component_id,\n\t\t\t   size_t *const ext_idx, size_t *const id)\n{\n\tstruct counter_array *element;\n\n\t*id = 0;\n\tfor (*ext_idx = 0; *ext_idx < num_ext; (*ext_idx)++) {\n\t\tif (*id == component_id)\n\t\t\treturn 0;\n\n\t\tif (ext[*ext_idx].type == COUNTER_COMP_ARRAY) {\n\t\t\telement = ext[*ext_idx].priv;\n\n\t\t\tif (component_id - *id < element->length)\n\t\t\t\treturn 0;\n\n\t\t\t*id += element->length;\n\t\t} else\n\t\t\t(*id)++;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int counter_add_watch(struct counter_device *const counter,\n\t\t\t     const unsigned long arg)\n{\n\tvoid __user *const uwatch = (void __user *)arg;\n\tstruct counter_watch watch;\n\tstruct counter_comp_node comp_node = {};\n\tsize_t parent, id;\n\tstruct counter_comp *ext;\n\tsize_t num_ext;\n\tsize_t ext_idx, ext_id;\n\tint err = 0;\n\n\tif (copy_from_user(&watch, uwatch, sizeof(watch)))\n\t\treturn -EFAULT;\n\n\tif (watch.component.type == COUNTER_COMPONENT_NONE)\n\t\tgoto no_component;\n\n\tparent = watch.component.parent;\n\n\t \n\tswitch (watch.component.scope) {\n\tcase COUNTER_SCOPE_DEVICE:\n\t\text = counter->ext;\n\t\tnum_ext = counter->num_ext;\n\t\tbreak;\n\tcase COUNTER_SCOPE_SIGNAL:\n\t\tif (parent >= counter->num_signals)\n\t\t\treturn -EINVAL;\n\t\tparent = array_index_nospec(parent, counter->num_signals);\n\n\t\tcomp_node.parent = counter->signals + parent;\n\n\t\text = counter->signals[parent].ext;\n\t\tnum_ext = counter->signals[parent].num_ext;\n\t\tbreak;\n\tcase COUNTER_SCOPE_COUNT:\n\t\tif (parent >= counter->num_counts)\n\t\t\treturn -EINVAL;\n\t\tparent = array_index_nospec(parent, counter->num_counts);\n\n\t\tcomp_node.parent = counter->counts + parent;\n\n\t\text = counter->counts[parent].ext;\n\t\tnum_ext = counter->counts[parent].num_ext;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tid = watch.component.id;\n\n\t \n\tswitch (watch.component.type) {\n\tcase COUNTER_COMPONENT_SIGNAL:\n\t\tif (watch.component.scope != COUNTER_SCOPE_SIGNAL)\n\t\t\treturn -EINVAL;\n\n\t\tcomp_node.comp.type = COUNTER_COMP_SIGNAL_LEVEL;\n\t\tcomp_node.comp.signal_u32_read = counter->ops->signal_read;\n\t\tbreak;\n\tcase COUNTER_COMPONENT_COUNT:\n\t\tif (watch.component.scope != COUNTER_SCOPE_COUNT)\n\t\t\treturn -EINVAL;\n\n\t\tcomp_node.comp.type = COUNTER_COMP_U64;\n\t\tcomp_node.comp.count_u64_read = counter->ops->count_read;\n\t\tbreak;\n\tcase COUNTER_COMPONENT_FUNCTION:\n\t\tif (watch.component.scope != COUNTER_SCOPE_COUNT)\n\t\t\treturn -EINVAL;\n\n\t\tcomp_node.comp.type = COUNTER_COMP_FUNCTION;\n\t\tcomp_node.comp.count_u32_read = counter->ops->function_read;\n\t\tbreak;\n\tcase COUNTER_COMPONENT_SYNAPSE_ACTION:\n\t\tif (watch.component.scope != COUNTER_SCOPE_COUNT)\n\t\t\treturn -EINVAL;\n\t\tif (id >= counter->counts[parent].num_synapses)\n\t\t\treturn -EINVAL;\n\t\tid = array_index_nospec(id, counter->counts[parent].num_synapses);\n\n\t\tcomp_node.comp.type = COUNTER_COMP_SYNAPSE_ACTION;\n\t\tcomp_node.comp.action_read = counter->ops->action_read;\n\t\tcomp_node.comp.priv = counter->counts[parent].synapses + id;\n\t\tbreak;\n\tcase COUNTER_COMPONENT_EXTENSION:\n\t\terr = counter_get_ext(ext, num_ext, id, &ext_idx, &ext_id);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tcomp_node.comp = ext[ext_idx];\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (!counter_comp_read_is_set(comp_node.comp))\n\t\treturn -EOPNOTSUPP;\n\nno_component:\n\tmutex_lock(&counter->n_events_list_lock);\n\n\tif (counter->ops->watch_validate) {\n\t\terr = counter->ops->watch_validate(counter, &watch);\n\t\tif (err < 0)\n\t\t\tgoto err_exit;\n\t}\n\n\tcomp_node.component = watch.component;\n\n\terr = counter_set_event_node(counter, &watch, &comp_node);\n\nerr_exit:\n\tmutex_unlock(&counter->n_events_list_lock);\n\n\treturn err;\n}\n\nstatic long counter_chrdev_ioctl(struct file *filp, unsigned int cmd,\n\t\t\t\t unsigned long arg)\n{\n\tstruct counter_device *const counter = filp->private_data;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&counter->ops_exist_lock);\n\n\tif (!counter->ops)\n\t\tgoto out_unlock;\n\n\tswitch (cmd) {\n\tcase COUNTER_ADD_WATCH_IOCTL:\n\t\tret = counter_add_watch(counter, arg);\n\t\tbreak;\n\tcase COUNTER_ENABLE_EVENTS_IOCTL:\n\t\tret = counter_enable_events(counter);\n\t\tbreak;\n\tcase COUNTER_DISABLE_EVENTS_IOCTL:\n\t\tret = counter_disable_events(counter);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOIOCTLCMD;\n\t\tbreak;\n\t}\n\nout_unlock:\n\tmutex_unlock(&counter->ops_exist_lock);\n\n\treturn ret;\n}\n\nstatic int counter_chrdev_open(struct inode *inode, struct file *filp)\n{\n\tstruct counter_device *const counter = container_of(inode->i_cdev,\n\t\t\t\t\t\t\t    typeof(*counter),\n\t\t\t\t\t\t\t    chrdev);\n\n\tget_device(&counter->dev);\n\tfilp->private_data = counter;\n\n\treturn nonseekable_open(inode, filp);\n}\n\nstatic int counter_chrdev_release(struct inode *inode, struct file *filp)\n{\n\tstruct counter_device *const counter = filp->private_data;\n\tint ret = 0;\n\n\tmutex_lock(&counter->ops_exist_lock);\n\n\tif (!counter->ops) {\n\t\t \n\t\tcounter_events_list_free(&counter->events_list);\n\t\tcounter_events_list_free(&counter->next_events_list);\n\t\tret = -ENODEV;\n\t\tgoto out_unlock;\n\t}\n\n\tret = counter_disable_events(counter);\n\tif (ret < 0) {\n\t\tmutex_unlock(&counter->ops_exist_lock);\n\t\treturn ret;\n\t}\n\nout_unlock:\n\tmutex_unlock(&counter->ops_exist_lock);\n\n\tput_device(&counter->dev);\n\n\treturn ret;\n}\n\nstatic const struct file_operations counter_fops = {\n\t.owner = THIS_MODULE,\n\t.llseek = no_llseek,\n\t.read = counter_chrdev_read,\n\t.poll = counter_chrdev_poll,\n\t.unlocked_ioctl = counter_chrdev_ioctl,\n\t.open = counter_chrdev_open,\n\t.release = counter_chrdev_release,\n};\n\nint counter_chrdev_add(struct counter_device *const counter)\n{\n\t \n\tINIT_LIST_HEAD(&counter->events_list);\n\tINIT_LIST_HEAD(&counter->next_events_list);\n\tspin_lock_init(&counter->events_list_lock);\n\tmutex_init(&counter->n_events_list_lock);\n\tinit_waitqueue_head(&counter->events_wait);\n\tspin_lock_init(&counter->events_in_lock);\n\tmutex_init(&counter->events_out_lock);\n\n\t \n\tcdev_init(&counter->chrdev, &counter_fops);\n\n\t \n\treturn kfifo_alloc(&counter->events, 64, GFP_KERNEL);\n}\n\nvoid counter_chrdev_remove(struct counter_device *const counter)\n{\n\tkfifo_free(&counter->events);\n}\n\nstatic int counter_get_array_data(struct counter_device *const counter,\n\t\t\t\t  const enum counter_scope scope,\n\t\t\t\t  void *const parent,\n\t\t\t\t  const struct counter_comp *const comp,\n\t\t\t\t  const size_t idx, u64 *const value)\n{\n\tconst struct counter_array *const element = comp->priv;\n\tu32 value_u32 = 0;\n\tint ret;\n\n\tswitch (element->type) {\n\tcase COUNTER_COMP_SIGNAL_POLARITY:\n\t\tif (scope != COUNTER_SCOPE_SIGNAL)\n\t\t\treturn -EINVAL;\n\t\tret = comp->signal_array_u32_read(counter, parent, idx,\n\t\t\t\t\t\t  &value_u32);\n\t\t*value = value_u32;\n\t\treturn ret;\n\tcase COUNTER_COMP_U64:\n\t\tswitch (scope) {\n\t\tcase COUNTER_SCOPE_DEVICE:\n\t\t\treturn comp->device_array_u64_read(counter, idx, value);\n\t\tcase COUNTER_SCOPE_SIGNAL:\n\t\t\treturn comp->signal_array_u64_read(counter, parent, idx,\n\t\t\t\t\t\t\t   value);\n\t\tcase COUNTER_SCOPE_COUNT:\n\t\t\treturn comp->count_array_u64_read(counter, parent, idx,\n\t\t\t\t\t\t\t  value);\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int counter_get_data(struct counter_device *const counter,\n\t\t\t    const struct counter_comp_node *const comp_node,\n\t\t\t    u64 *const value)\n{\n\tconst struct counter_comp *const comp = &comp_node->comp;\n\tconst enum counter_scope scope = comp_node->component.scope;\n\tconst size_t id = comp_node->component.id;\n\tstruct counter_signal *const signal = comp_node->parent;\n\tstruct counter_count *const count = comp_node->parent;\n\tu8 value_u8 = 0;\n\tu32 value_u32 = 0;\n\tconst struct counter_comp *ext;\n\tsize_t num_ext;\n\tsize_t ext_idx, ext_id;\n\tint ret;\n\n\tif (comp_node->component.type == COUNTER_COMPONENT_NONE)\n\t\treturn 0;\n\n\tswitch (comp->type) {\n\tcase COUNTER_COMP_U8:\n\tcase COUNTER_COMP_BOOL:\n\t\tswitch (scope) {\n\t\tcase COUNTER_SCOPE_DEVICE:\n\t\t\tret = comp->device_u8_read(counter, &value_u8);\n\t\t\tbreak;\n\t\tcase COUNTER_SCOPE_SIGNAL:\n\t\t\tret = comp->signal_u8_read(counter, signal, &value_u8);\n\t\t\tbreak;\n\t\tcase COUNTER_SCOPE_COUNT:\n\t\t\tret = comp->count_u8_read(counter, count, &value_u8);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*value = value_u8;\n\t\treturn ret;\n\tcase COUNTER_COMP_SIGNAL_LEVEL:\n\tcase COUNTER_COMP_FUNCTION:\n\tcase COUNTER_COMP_ENUM:\n\tcase COUNTER_COMP_COUNT_DIRECTION:\n\tcase COUNTER_COMP_COUNT_MODE:\n\tcase COUNTER_COMP_SIGNAL_POLARITY:\n\t\tswitch (scope) {\n\t\tcase COUNTER_SCOPE_DEVICE:\n\t\t\tret = comp->device_u32_read(counter, &value_u32);\n\t\t\tbreak;\n\t\tcase COUNTER_SCOPE_SIGNAL:\n\t\t\tret = comp->signal_u32_read(counter, signal,\n\t\t\t\t\t\t    &value_u32);\n\t\t\tbreak;\n\t\tcase COUNTER_SCOPE_COUNT:\n\t\t\tret = comp->count_u32_read(counter, count, &value_u32);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*value = value_u32;\n\t\treturn ret;\n\tcase COUNTER_COMP_U64:\n\t\tswitch (scope) {\n\t\tcase COUNTER_SCOPE_DEVICE:\n\t\t\treturn comp->device_u64_read(counter, value);\n\t\tcase COUNTER_SCOPE_SIGNAL:\n\t\t\treturn comp->signal_u64_read(counter, signal, value);\n\t\tcase COUNTER_SCOPE_COUNT:\n\t\t\treturn comp->count_u64_read(counter, count, value);\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase COUNTER_COMP_SYNAPSE_ACTION:\n\t\tret = comp->action_read(counter, count, comp->priv, &value_u32);\n\t\t*value = value_u32;\n\t\treturn ret;\n\tcase COUNTER_COMP_ARRAY:\n\t\tswitch (scope) {\n\t\tcase COUNTER_SCOPE_DEVICE:\n\t\t\text = counter->ext;\n\t\t\tnum_ext = counter->num_ext;\n\t\t\tbreak;\n\t\tcase COUNTER_SCOPE_SIGNAL:\n\t\t\text = signal->ext;\n\t\t\tnum_ext = signal->num_ext;\n\t\t\tbreak;\n\t\tcase COUNTER_SCOPE_COUNT:\n\t\t\text = count->ext;\n\t\t\tnum_ext = count->num_ext;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tret = counter_get_ext(ext, num_ext, id, &ext_idx, &ext_id);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\treturn counter_get_array_data(counter, scope, comp_node->parent,\n\t\t\t\t\t      comp, id - ext_id, value);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n \nvoid counter_push_event(struct counter_device *const counter, const u8 event,\n\t\t\tconst u8 channel)\n{\n\tstruct counter_event ev;\n\tunsigned int copied = 0;\n\tunsigned long flags;\n\tstruct counter_event_node *event_node;\n\tstruct counter_comp_node *comp_node;\n\n\tev.timestamp = ktime_get_ns();\n\tev.watch.event = event;\n\tev.watch.channel = channel;\n\n\t \n\tspin_lock_irqsave(&counter->events_list_lock, flags);\n\n\t \n\tlist_for_each_entry(event_node, &counter->events_list, l)\n\t\tif (event_node->event == event &&\n\t\t    event_node->channel == channel)\n\t\t\tbreak;\n\n\t \n\tif (&event_node->l == &counter->events_list)\n\t\tgoto exit_early;\n\n\t \n\tlist_for_each_entry(comp_node, &event_node->comp_list, l) {\n\t\tev.watch.component = comp_node->component;\n\t\tev.status = -counter_get_data(counter, comp_node, &ev.value);\n\n\t\tcopied += kfifo_in_spinlocked_noirqsave(&counter->events, &ev,\n\t\t\t\t\t\t\t1, &counter->events_in_lock);\n\t}\n\nexit_early:\n\tspin_unlock_irqrestore(&counter->events_list_lock, flags);\n\n\tif (copied)\n\t\twake_up_poll(&counter->events_wait, EPOLLIN);\n}\nEXPORT_SYMBOL_NS_GPL(counter_push_event, COUNTER);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}