{
  "module_name": "counter-sysfs.c",
  "hash_id": "dda27f38d216a13645ea54a695ecef32f0b156978b7c3a463c09a8b8ba2f5692",
  "original_prompt": "Ingested from linux-6.6.14/drivers/counter/counter-sysfs.c",
  "human_readable_source": "\n \n#include <linux/counter.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/gfp.h>\n#include <linux/kernel.h>\n#include <linux/kfifo.h>\n#include <linux/kstrtox.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/sysfs.h>\n#include <linux/types.h>\n\n#include \"counter-sysfs.h\"\n\nstatic inline struct counter_device *counter_from_dev(struct device *dev)\n{\n\treturn container_of(dev, struct counter_device, dev);\n}\n\n \nstruct counter_attribute {\n\tstruct device_attribute dev_attr;\n\tstruct list_head l;\n\n\tstruct counter_comp comp;\n\tenum counter_scope scope;\n\tvoid *parent;\n};\n\n#define to_counter_attribute(_dev_attr) \\\n\tcontainer_of(_dev_attr, struct counter_attribute, dev_attr)\n\n \nstruct counter_attribute_group {\n\tconst char *name;\n\tstruct list_head attr_list;\n\tsize_t num_attr;\n};\n\nstatic const char *const counter_function_str[] = {\n\t[COUNTER_FUNCTION_INCREASE] = \"increase\",\n\t[COUNTER_FUNCTION_DECREASE] = \"decrease\",\n\t[COUNTER_FUNCTION_PULSE_DIRECTION] = \"pulse-direction\",\n\t[COUNTER_FUNCTION_QUADRATURE_X1_A] = \"quadrature x1 a\",\n\t[COUNTER_FUNCTION_QUADRATURE_X1_B] = \"quadrature x1 b\",\n\t[COUNTER_FUNCTION_QUADRATURE_X2_A] = \"quadrature x2 a\",\n\t[COUNTER_FUNCTION_QUADRATURE_X2_B] = \"quadrature x2 b\",\n\t[COUNTER_FUNCTION_QUADRATURE_X4] = \"quadrature x4\"\n};\n\nstatic const char *const counter_signal_value_str[] = {\n\t[COUNTER_SIGNAL_LEVEL_LOW] = \"low\",\n\t[COUNTER_SIGNAL_LEVEL_HIGH] = \"high\"\n};\n\nstatic const char *const counter_synapse_action_str[] = {\n\t[COUNTER_SYNAPSE_ACTION_NONE] = \"none\",\n\t[COUNTER_SYNAPSE_ACTION_RISING_EDGE] = \"rising edge\",\n\t[COUNTER_SYNAPSE_ACTION_FALLING_EDGE] = \"falling edge\",\n\t[COUNTER_SYNAPSE_ACTION_BOTH_EDGES] = \"both edges\"\n};\n\nstatic const char *const counter_count_direction_str[] = {\n\t[COUNTER_COUNT_DIRECTION_FORWARD] = \"forward\",\n\t[COUNTER_COUNT_DIRECTION_BACKWARD] = \"backward\"\n};\n\nstatic const char *const counter_count_mode_str[] = {\n\t[COUNTER_COUNT_MODE_NORMAL] = \"normal\",\n\t[COUNTER_COUNT_MODE_RANGE_LIMIT] = \"range limit\",\n\t[COUNTER_COUNT_MODE_NON_RECYCLE] = \"non-recycle\",\n\t[COUNTER_COUNT_MODE_MODULO_N] = \"modulo-n\",\n\t[COUNTER_COUNT_MODE_INTERRUPT_ON_TERMINAL_COUNT] = \"interrupt on terminal count\",\n\t[COUNTER_COUNT_MODE_HARDWARE_RETRIGGERABLE_ONESHOT] = \"hardware retriggerable one-shot\",\n\t[COUNTER_COUNT_MODE_RATE_GENERATOR] = \"rate generator\",\n\t[COUNTER_COUNT_MODE_SQUARE_WAVE_MODE] = \"square wave mode\",\n\t[COUNTER_COUNT_MODE_SOFTWARE_TRIGGERED_STROBE] = \"software triggered strobe\",\n\t[COUNTER_COUNT_MODE_HARDWARE_TRIGGERED_STROBE] = \"hardware triggered strobe\",\n};\n\nstatic const char *const counter_signal_polarity_str[] = {\n\t[COUNTER_SIGNAL_POLARITY_POSITIVE] = \"positive\",\n\t[COUNTER_SIGNAL_POLARITY_NEGATIVE] = \"negative\"\n};\n\nstatic ssize_t counter_comp_u8_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tconst struct counter_attribute *const a = to_counter_attribute(attr);\n\tstruct counter_device *const counter = counter_from_dev(dev);\n\tint err;\n\tu8 data = 0;\n\n\tswitch (a->scope) {\n\tcase COUNTER_SCOPE_DEVICE:\n\t\terr = a->comp.device_u8_read(counter, &data);\n\t\tbreak;\n\tcase COUNTER_SCOPE_SIGNAL:\n\t\terr = a->comp.signal_u8_read(counter, a->parent, &data);\n\t\tbreak;\n\tcase COUNTER_SCOPE_COUNT:\n\t\terr = a->comp.count_u8_read(counter, a->parent, &data);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (err < 0)\n\t\treturn err;\n\n\tif (a->comp.type == COUNTER_COMP_BOOL)\n\t\t \n\t\tdata = !!data;\n\n\treturn sysfs_emit(buf, \"%u\\n\", (unsigned int)data);\n}\n\nstatic ssize_t counter_comp_u8_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t len)\n{\n\tconst struct counter_attribute *const a = to_counter_attribute(attr);\n\tstruct counter_device *const counter = counter_from_dev(dev);\n\tint err;\n\tbool bool_data = 0;\n\tu8 data = 0;\n\n\tif (a->comp.type == COUNTER_COMP_BOOL) {\n\t\terr = kstrtobool(buf, &bool_data);\n\t\tdata = bool_data;\n\t} else\n\t\terr = kstrtou8(buf, 0, &data);\n\tif (err < 0)\n\t\treturn err;\n\n\tswitch (a->scope) {\n\tcase COUNTER_SCOPE_DEVICE:\n\t\terr = a->comp.device_u8_write(counter, data);\n\t\tbreak;\n\tcase COUNTER_SCOPE_SIGNAL:\n\t\terr = a->comp.signal_u8_write(counter, a->parent, data);\n\t\tbreak;\n\tcase COUNTER_SCOPE_COUNT:\n\t\terr = a->comp.count_u8_write(counter, a->parent, data);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (err < 0)\n\t\treturn err;\n\n\treturn len;\n}\n\nstatic ssize_t counter_comp_u32_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tconst struct counter_attribute *const a = to_counter_attribute(attr);\n\tstruct counter_device *const counter = counter_from_dev(dev);\n\tconst struct counter_available *const avail = a->comp.priv;\n\tint err;\n\tu32 data = 0;\n\n\tswitch (a->scope) {\n\tcase COUNTER_SCOPE_DEVICE:\n\t\terr = a->comp.device_u32_read(counter, &data);\n\t\tbreak;\n\tcase COUNTER_SCOPE_SIGNAL:\n\t\terr = a->comp.signal_u32_read(counter, a->parent, &data);\n\t\tbreak;\n\tcase COUNTER_SCOPE_COUNT:\n\t\tif (a->comp.type == COUNTER_COMP_SYNAPSE_ACTION)\n\t\t\terr = a->comp.action_read(counter, a->parent,\n\t\t\t\t\t\t  a->comp.priv, &data);\n\t\telse\n\t\t\terr = a->comp.count_u32_read(counter, a->parent, &data);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (err < 0)\n\t\treturn err;\n\n\tswitch (a->comp.type) {\n\tcase COUNTER_COMP_FUNCTION:\n\t\treturn sysfs_emit(buf, \"%s\\n\", counter_function_str[data]);\n\tcase COUNTER_COMP_SIGNAL_LEVEL:\n\t\treturn sysfs_emit(buf, \"%s\\n\", counter_signal_value_str[data]);\n\tcase COUNTER_COMP_SYNAPSE_ACTION:\n\t\treturn sysfs_emit(buf, \"%s\\n\", counter_synapse_action_str[data]);\n\tcase COUNTER_COMP_ENUM:\n\t\treturn sysfs_emit(buf, \"%s\\n\", avail->strs[data]);\n\tcase COUNTER_COMP_COUNT_DIRECTION:\n\t\treturn sysfs_emit(buf, \"%s\\n\", counter_count_direction_str[data]);\n\tcase COUNTER_COMP_COUNT_MODE:\n\t\treturn sysfs_emit(buf, \"%s\\n\", counter_count_mode_str[data]);\n\tcase COUNTER_COMP_SIGNAL_POLARITY:\n\t\treturn sysfs_emit(buf, \"%s\\n\", counter_signal_polarity_str[data]);\n\tdefault:\n\t\treturn sysfs_emit(buf, \"%u\\n\", (unsigned int)data);\n\t}\n}\n\nstatic int counter_find_enum(u32 *const enum_item, const u32 *const enums,\n\t\t\t     const size_t num_enums, const char *const buf,\n\t\t\t     const char *const string_array[])\n{\n\tsize_t index;\n\n\tfor (index = 0; index < num_enums; index++) {\n\t\t*enum_item = enums[index];\n\t\tif (sysfs_streq(buf, string_array[*enum_item]))\n\t\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic ssize_t counter_comp_u32_store(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      const char *buf, size_t len)\n{\n\tconst struct counter_attribute *const a = to_counter_attribute(attr);\n\tstruct counter_device *const counter = counter_from_dev(dev);\n\tstruct counter_count *const count = a->parent;\n\tstruct counter_synapse *const synapse = a->comp.priv;\n\tconst struct counter_available *const avail = a->comp.priv;\n\tint err;\n\tu32 data = 0;\n\n\tswitch (a->comp.type) {\n\tcase COUNTER_COMP_FUNCTION:\n\t\terr = counter_find_enum(&data, count->functions_list,\n\t\t\t\t\tcount->num_functions, buf,\n\t\t\t\t\tcounter_function_str);\n\t\tbreak;\n\tcase COUNTER_COMP_SYNAPSE_ACTION:\n\t\terr = counter_find_enum(&data, synapse->actions_list,\n\t\t\t\t\tsynapse->num_actions, buf,\n\t\t\t\t\tcounter_synapse_action_str);\n\t\tbreak;\n\tcase COUNTER_COMP_ENUM:\n\t\terr = __sysfs_match_string(avail->strs, avail->num_items, buf);\n\t\tdata = err;\n\t\tbreak;\n\tcase COUNTER_COMP_COUNT_MODE:\n\t\terr = counter_find_enum(&data, avail->enums, avail->num_items,\n\t\t\t\t\tbuf, counter_count_mode_str);\n\t\tbreak;\n\tcase COUNTER_COMP_SIGNAL_POLARITY:\n\t\terr = counter_find_enum(&data, avail->enums, avail->num_items,\n\t\t\t\t\tbuf, counter_signal_polarity_str);\n\t\tbreak;\n\tdefault:\n\t\terr = kstrtou32(buf, 0, &data);\n\t\tbreak;\n\t}\n\tif (err < 0)\n\t\treturn err;\n\n\tswitch (a->scope) {\n\tcase COUNTER_SCOPE_DEVICE:\n\t\terr = a->comp.device_u32_write(counter, data);\n\t\tbreak;\n\tcase COUNTER_SCOPE_SIGNAL:\n\t\terr = a->comp.signal_u32_write(counter, a->parent, data);\n\t\tbreak;\n\tcase COUNTER_SCOPE_COUNT:\n\t\tif (a->comp.type == COUNTER_COMP_SYNAPSE_ACTION)\n\t\t\terr = a->comp.action_write(counter, count, synapse,\n\t\t\t\t\t\t   data);\n\t\telse\n\t\t\terr = a->comp.count_u32_write(counter, count, data);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (err < 0)\n\t\treturn err;\n\n\treturn len;\n}\n\nstatic ssize_t counter_comp_u64_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tconst struct counter_attribute *const a = to_counter_attribute(attr);\n\tstruct counter_device *const counter = counter_from_dev(dev);\n\tint err;\n\tu64 data = 0;\n\n\tswitch (a->scope) {\n\tcase COUNTER_SCOPE_DEVICE:\n\t\terr = a->comp.device_u64_read(counter, &data);\n\t\tbreak;\n\tcase COUNTER_SCOPE_SIGNAL:\n\t\terr = a->comp.signal_u64_read(counter, a->parent, &data);\n\t\tbreak;\n\tcase COUNTER_SCOPE_COUNT:\n\t\terr = a->comp.count_u64_read(counter, a->parent, &data);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (err < 0)\n\t\treturn err;\n\n\treturn sysfs_emit(buf, \"%llu\\n\", (unsigned long long)data);\n}\n\nstatic ssize_t counter_comp_u64_store(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      const char *buf, size_t len)\n{\n\tconst struct counter_attribute *const a = to_counter_attribute(attr);\n\tstruct counter_device *const counter = counter_from_dev(dev);\n\tint err;\n\tu64 data = 0;\n\n\terr = kstrtou64(buf, 0, &data);\n\tif (err < 0)\n\t\treturn err;\n\n\tswitch (a->scope) {\n\tcase COUNTER_SCOPE_DEVICE:\n\t\terr = a->comp.device_u64_write(counter, data);\n\t\tbreak;\n\tcase COUNTER_SCOPE_SIGNAL:\n\t\terr = a->comp.signal_u64_write(counter, a->parent, data);\n\t\tbreak;\n\tcase COUNTER_SCOPE_COUNT:\n\t\terr = a->comp.count_u64_write(counter, a->parent, data);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (err < 0)\n\t\treturn err;\n\n\treturn len;\n}\n\nstatic ssize_t counter_comp_array_u32_show(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   char *buf)\n{\n\tconst struct counter_attribute *const a = to_counter_attribute(attr);\n\tstruct counter_device *const counter = counter_from_dev(dev);\n\tconst struct counter_array *const element = a->comp.priv;\n\tint err;\n\tu32 data = 0;\n\n\tif (a->scope != COUNTER_SCOPE_SIGNAL ||\n\t    element->type != COUNTER_COMP_SIGNAL_POLARITY)\n\t\treturn -EINVAL;\n\n\terr = a->comp.signal_array_u32_read(counter, a->parent, element->idx,\n\t\t\t\t\t    &data);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn sysfs_emit(buf, \"%s\\n\", counter_signal_polarity_str[data]);\n}\n\nstatic ssize_t counter_comp_array_u32_store(struct device *dev,\n\t\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t\t    const char *buf, size_t len)\n{\n\tconst struct counter_attribute *const a = to_counter_attribute(attr);\n\tstruct counter_device *const counter = counter_from_dev(dev);\n\tconst struct counter_array *const element = a->comp.priv;\n\tint err;\n\tu32 data = 0;\n\n\tif (element->type != COUNTER_COMP_SIGNAL_POLARITY ||\n\t    a->scope != COUNTER_SCOPE_SIGNAL)\n\t\treturn -EINVAL;\n\n\terr = counter_find_enum(&data, element->avail->enums,\n\t\t\t\telement->avail->num_items, buf,\n\t\t\t\tcounter_signal_polarity_str);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = a->comp.signal_array_u32_write(counter, a->parent, element->idx,\n\t\t\t\t\t     data);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn len;\n}\n\nstatic ssize_t counter_comp_array_u64_show(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   char *buf)\n{\n\tconst struct counter_attribute *const a = to_counter_attribute(attr);\n\tstruct counter_device *const counter = counter_from_dev(dev);\n\tconst struct counter_array *const element = a->comp.priv;\n\tint err;\n\tu64 data = 0;\n\n\tswitch (a->scope) {\n\tcase COUNTER_SCOPE_DEVICE:\n\t\terr = a->comp.device_array_u64_read(counter, element->idx,\n\t\t\t\t\t\t    &data);\n\t\tbreak;\n\tcase COUNTER_SCOPE_SIGNAL:\n\t\terr = a->comp.signal_array_u64_read(counter, a->parent,\n\t\t\t\t\t\t    element->idx, &data);\n\t\tbreak;\n\tcase COUNTER_SCOPE_COUNT:\n\t\terr = a->comp.count_array_u64_read(counter, a->parent,\n\t\t\t\t\t\t   element->idx, &data);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (err < 0)\n\t\treturn err;\n\n\treturn sysfs_emit(buf, \"%llu\\n\", (unsigned long long)data);\n}\n\nstatic ssize_t counter_comp_array_u64_store(struct device *dev,\n\t\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t\t    const char *buf, size_t len)\n{\n\tconst struct counter_attribute *const a = to_counter_attribute(attr);\n\tstruct counter_device *const counter = counter_from_dev(dev);\n\tconst struct counter_array *const element = a->comp.priv;\n\tint err;\n\tu64 data = 0;\n\n\terr = kstrtou64(buf, 0, &data);\n\tif (err < 0)\n\t\treturn err;\n\n\tswitch (a->scope) {\n\tcase COUNTER_SCOPE_DEVICE:\n\t\terr = a->comp.device_array_u64_write(counter, element->idx,\n\t\t\t\t\t\t     data);\n\t\tbreak;\n\tcase COUNTER_SCOPE_SIGNAL:\n\t\terr = a->comp.signal_array_u64_write(counter, a->parent,\n\t\t\t\t\t\t     element->idx, data);\n\t\tbreak;\n\tcase COUNTER_SCOPE_COUNT:\n\t\terr = a->comp.count_array_u64_write(counter, a->parent,\n\t\t\t\t\t\t    element->idx, data);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (err < 0)\n\t\treturn err;\n\n\treturn len;\n}\n\nstatic ssize_t enums_available_show(const u32 *const enums,\n\t\t\t\t    const size_t num_enums,\n\t\t\t\t    const char *const strs[], char *buf)\n{\n\tsize_t len = 0;\n\tsize_t index;\n\n\tfor (index = 0; index < num_enums; index++)\n\t\tlen += sysfs_emit_at(buf, len, \"%s\\n\", strs[enums[index]]);\n\n\treturn len;\n}\n\nstatic ssize_t strs_available_show(const struct counter_available *const avail,\n\t\t\t\t   char *buf)\n{\n\tsize_t len = 0;\n\tsize_t index;\n\n\tfor (index = 0; index < avail->num_items; index++)\n\t\tlen += sysfs_emit_at(buf, len, \"%s\\n\", avail->strs[index]);\n\n\treturn len;\n}\n\nstatic ssize_t counter_comp_available_show(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   char *buf)\n{\n\tconst struct counter_attribute *const a = to_counter_attribute(attr);\n\tconst struct counter_count *const count = a->parent;\n\tconst struct counter_synapse *const synapse = a->comp.priv;\n\tconst struct counter_available *const avail = a->comp.priv;\n\n\tswitch (a->comp.type) {\n\tcase COUNTER_COMP_FUNCTION:\n\t\treturn enums_available_show(count->functions_list,\n\t\t\t\t\t    count->num_functions,\n\t\t\t\t\t    counter_function_str, buf);\n\tcase COUNTER_COMP_SYNAPSE_ACTION:\n\t\treturn enums_available_show(synapse->actions_list,\n\t\t\t\t\t    synapse->num_actions,\n\t\t\t\t\t    counter_synapse_action_str, buf);\n\tcase COUNTER_COMP_ENUM:\n\t\treturn strs_available_show(avail, buf);\n\tcase COUNTER_COMP_COUNT_MODE:\n\t\treturn enums_available_show(avail->enums, avail->num_items,\n\t\t\t\t\t    counter_count_mode_str, buf);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int counter_avail_attr_create(struct device *const dev,\n\tstruct counter_attribute_group *const group,\n\tconst struct counter_comp *const comp, void *const parent)\n{\n\tstruct counter_attribute *counter_attr;\n\tstruct device_attribute *dev_attr;\n\n\tcounter_attr = devm_kzalloc(dev, sizeof(*counter_attr), GFP_KERNEL);\n\tif (!counter_attr)\n\t\treturn -ENOMEM;\n\n\t \n\tcounter_attr->comp.type = comp->type;\n\tcounter_attr->comp.priv = comp->priv;\n\tcounter_attr->parent = parent;\n\n\t \n\tdev_attr = &counter_attr->dev_attr;\n\tsysfs_attr_init(&dev_attr->attr);\n\n\t \n\tdev_attr->attr.name = devm_kasprintf(dev, GFP_KERNEL, \"%s_available\",\n\t\t\t\t\t     comp->name);\n\tif (!dev_attr->attr.name)\n\t\treturn -ENOMEM;\n\tdev_attr->attr.mode = 0444;\n\tdev_attr->show = counter_comp_available_show;\n\n\t \n\tlist_add(&counter_attr->l, &group->attr_list);\n\tgroup->num_attr++;\n\n\treturn 0;\n}\n\nstatic int counter_attr_create(struct device *const dev,\n\t\t\t       struct counter_attribute_group *const group,\n\t\t\t       const struct counter_comp *const comp,\n\t\t\t       const enum counter_scope scope,\n\t\t\t       void *const parent)\n{\n\tconst struct counter_array *const array = comp->priv;\n\tstruct counter_attribute *counter_attr;\n\tstruct device_attribute *dev_attr;\n\n\tcounter_attr = devm_kzalloc(dev, sizeof(*counter_attr), GFP_KERNEL);\n\tif (!counter_attr)\n\t\treturn -ENOMEM;\n\n\t \n\tcounter_attr->comp = *comp;\n\tcounter_attr->scope = scope;\n\tcounter_attr->parent = parent;\n\n\t \n\tdev_attr = &counter_attr->dev_attr;\n\tsysfs_attr_init(&dev_attr->attr);\n\tdev_attr->attr.name = comp->name;\n\tswitch (comp->type) {\n\tcase COUNTER_COMP_U8:\n\tcase COUNTER_COMP_BOOL:\n\t\tif (comp->device_u8_read) {\n\t\t\tdev_attr->attr.mode |= 0444;\n\t\t\tdev_attr->show = counter_comp_u8_show;\n\t\t}\n\t\tif (comp->device_u8_write) {\n\t\t\tdev_attr->attr.mode |= 0200;\n\t\t\tdev_attr->store = counter_comp_u8_store;\n\t\t}\n\t\tbreak;\n\tcase COUNTER_COMP_SIGNAL_LEVEL:\n\tcase COUNTER_COMP_FUNCTION:\n\tcase COUNTER_COMP_SYNAPSE_ACTION:\n\tcase COUNTER_COMP_ENUM:\n\tcase COUNTER_COMP_COUNT_DIRECTION:\n\tcase COUNTER_COMP_COUNT_MODE:\n\tcase COUNTER_COMP_SIGNAL_POLARITY:\n\t\tif (comp->device_u32_read) {\n\t\t\tdev_attr->attr.mode |= 0444;\n\t\t\tdev_attr->show = counter_comp_u32_show;\n\t\t}\n\t\tif (comp->device_u32_write) {\n\t\t\tdev_attr->attr.mode |= 0200;\n\t\t\tdev_attr->store = counter_comp_u32_store;\n\t\t}\n\t\tbreak;\n\tcase COUNTER_COMP_U64:\n\t\tif (comp->device_u64_read) {\n\t\t\tdev_attr->attr.mode |= 0444;\n\t\t\tdev_attr->show = counter_comp_u64_show;\n\t\t}\n\t\tif (comp->device_u64_write) {\n\t\t\tdev_attr->attr.mode |= 0200;\n\t\t\tdev_attr->store = counter_comp_u64_store;\n\t\t}\n\t\tbreak;\n\tcase COUNTER_COMP_ARRAY:\n\t\tswitch (array->type) {\n\t\tcase COUNTER_COMP_SIGNAL_POLARITY:\n\t\t\tif (comp->signal_array_u32_read) {\n\t\t\t\tdev_attr->attr.mode |= 0444;\n\t\t\t\tdev_attr->show = counter_comp_array_u32_show;\n\t\t\t}\n\t\t\tif (comp->signal_array_u32_write) {\n\t\t\t\tdev_attr->attr.mode |= 0200;\n\t\t\t\tdev_attr->store = counter_comp_array_u32_store;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase COUNTER_COMP_U64:\n\t\t\tif (comp->device_array_u64_read) {\n\t\t\t\tdev_attr->attr.mode |= 0444;\n\t\t\t\tdev_attr->show = counter_comp_array_u64_show;\n\t\t\t}\n\t\t\tif (comp->device_array_u64_write) {\n\t\t\t\tdev_attr->attr.mode |= 0200;\n\t\t\t\tdev_attr->store = counter_comp_array_u64_store;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tlist_add(&counter_attr->l, &group->attr_list);\n\tgroup->num_attr++;\n\n\t \n\tswitch (comp->type) {\n\tcase COUNTER_COMP_FUNCTION:\n\tcase COUNTER_COMP_SYNAPSE_ACTION:\n\tcase COUNTER_COMP_ENUM:\n\tcase COUNTER_COMP_COUNT_MODE:\n\t\treturn counter_avail_attr_create(dev, group, comp, parent);\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic ssize_t counter_comp_name_show(struct device *dev,\n\t\t\t\t      struct device_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"%s\\n\", to_counter_attribute(attr)->comp.name);\n}\n\nstatic int counter_name_attr_create(struct device *const dev,\n\t\t\t\t    struct counter_attribute_group *const group,\n\t\t\t\t    const char *const name)\n{\n\tstruct counter_attribute *counter_attr;\n\n\tcounter_attr = devm_kzalloc(dev, sizeof(*counter_attr), GFP_KERNEL);\n\tif (!counter_attr)\n\t\treturn -ENOMEM;\n\n\t \n\tcounter_attr->comp.name = name;\n\n\t \n\tsysfs_attr_init(&counter_attr->dev_attr.attr);\n\tcounter_attr->dev_attr.attr.name = \"name\";\n\tcounter_attr->dev_attr.attr.mode = 0444;\n\tcounter_attr->dev_attr.show = counter_comp_name_show;\n\n\t \n\tlist_add(&counter_attr->l, &group->attr_list);\n\tgroup->num_attr++;\n\n\treturn 0;\n}\n\nstatic ssize_t counter_comp_id_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tconst size_t id = (size_t)to_counter_attribute(attr)->comp.priv;\n\n\treturn sysfs_emit(buf, \"%zu\\n\", id);\n}\n\nstatic int counter_comp_id_attr_create(struct device *const dev,\n\t\t\t\t       struct counter_attribute_group *const group,\n\t\t\t\t       const char *name, const size_t id)\n{\n\tstruct counter_attribute *counter_attr;\n\n\t \n\tcounter_attr = devm_kzalloc(dev, sizeof(*counter_attr), GFP_KERNEL);\n\tif (!counter_attr)\n\t\treturn -ENOMEM;\n\n\t \n\tname = devm_kasprintf(dev, GFP_KERNEL, \"%s_component_id\", name);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\t \n\tcounter_attr->comp.priv = (void *)id;\n\n\t \n\tsysfs_attr_init(&counter_attr->dev_attr.attr);\n\tcounter_attr->dev_attr.attr.name = name;\n\tcounter_attr->dev_attr.attr.mode = 0444;\n\tcounter_attr->dev_attr.show = counter_comp_id_show;\n\n\t \n\tlist_add(&counter_attr->l, &group->attr_list);\n\tgroup->num_attr++;\n\n\treturn 0;\n}\n\nstatic int counter_ext_attrs_create(struct device *const dev,\n\t\t\t\t    struct counter_attribute_group *const group,\n\t\t\t\t    const struct counter_comp *const ext,\n\t\t\t\t    const enum counter_scope scope,\n\t\t\t\t    void *const parent, const size_t id)\n{\n\tint err;\n\n\t \n\terr = counter_attr_create(dev, group, ext, scope, parent);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\treturn counter_comp_id_attr_create(dev, group, ext->name, id);\n}\n\nstatic int counter_array_attrs_create(struct device *const dev,\n\t\t\t\t      struct counter_attribute_group *const group,\n\t\t\t\t      const struct counter_comp *const comp,\n\t\t\t\t      const enum counter_scope scope,\n\t\t\t\t      void *const parent, const size_t id)\n{\n\tconst struct counter_array *const array = comp->priv;\n\tstruct counter_comp ext = *comp;\n\tstruct counter_array *element;\n\tsize_t idx;\n\tint err;\n\n\t \n\tfor (idx = 0; idx < array->length; idx++) {\n\t\t \n\t\text.name = devm_kasprintf(dev, GFP_KERNEL, \"%s%zu\", comp->name,\n\t\t\t\t\t  idx);\n\t\tif (!ext.name)\n\t\t\treturn -ENOMEM;\n\n\t\t \n\t\telement = devm_kzalloc(dev, sizeof(*element), GFP_KERNEL);\n\t\tif (!element)\n\t\t\treturn -ENOMEM;\n\t\telement->type = array->type;\n\t\telement->avail = array->avail;\n\t\telement->idx = idx;\n\t\text.priv = element;\n\n\t\t \n\t\terr = counter_ext_attrs_create(dev, group, &ext, scope, parent,\n\t\t\t\t\t       id + idx);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int counter_sysfs_exts_add(struct device *const dev,\n\t\t\t\t  struct counter_attribute_group *const group,\n\t\t\t\t  const struct counter_comp *const exts,\n\t\t\t\t  const size_t num_ext,\n\t\t\t\t  const enum counter_scope scope,\n\t\t\t\t  void *const parent)\n{\n\tsize_t i;\n\tconst struct counter_comp *ext;\n\tint err;\n\tsize_t id = 0;\n\tconst struct counter_array *array;\n\n\t \n\tfor (i = 0; i < num_ext; i++) {\n\t\text = &exts[i];\n\t\tif (ext->type == COUNTER_COMP_ARRAY) {\n\t\t\terr = counter_array_attrs_create(dev, group, ext, scope,\n\t\t\t\t\t\t\t parent, id);\n\t\t\tarray = ext->priv;\n\t\t\tid += array->length;\n\t\t} else {\n\t\t\terr = counter_ext_attrs_create(dev, group, ext, scope,\n\t\t\t\t\t\t       parent, id);\n\t\t\tid++;\n\t\t}\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic struct counter_comp counter_signal_comp = {\n\t.type = COUNTER_COMP_SIGNAL_LEVEL,\n\t.name = \"signal\",\n};\n\nstatic int counter_signal_attrs_create(struct counter_device *const counter,\n\tstruct counter_attribute_group *const cattr_group,\n\tstruct counter_signal *const signal)\n{\n\tconst enum counter_scope scope = COUNTER_SCOPE_SIGNAL;\n\tstruct device *const dev = &counter->dev;\n\tint err;\n\tstruct counter_comp comp;\n\n\t \n\tcomp = counter_signal_comp;\n\tcomp.signal_u32_read = counter->ops->signal_read;\n\terr = counter_attr_create(dev, cattr_group, &comp, scope, signal);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = counter_name_attr_create(dev, cattr_group, signal->name);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\treturn counter_sysfs_exts_add(dev, cattr_group, signal->ext,\n\t\t\t\t      signal->num_ext, scope, signal);\n}\n\nstatic int counter_sysfs_signals_add(struct counter_device *const counter,\n\tstruct counter_attribute_group *const groups)\n{\n\tsize_t i;\n\tint err;\n\n\t \n\tfor (i = 0; i < counter->num_signals; i++) {\n\t\t \n\t\tgroups[i].name = devm_kasprintf(&counter->dev, GFP_KERNEL,\n\t\t\t\t\t\t\"signal%zu\", i);\n\t\tif (!groups[i].name)\n\t\t\treturn -ENOMEM;\n\n\t\t \n\t\terr = counter_signal_attrs_create(counter, groups + i,\n\t\t\t\t\t\t  counter->signals + i);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int counter_sysfs_synapses_add(struct counter_device *const counter,\n\tstruct counter_attribute_group *const group,\n\tstruct counter_count *const count)\n{\n\tsize_t i;\n\n\t \n\tfor (i = 0; i < count->num_synapses; i++) {\n\t\tstruct device *const dev = &counter->dev;\n\t\tstruct counter_synapse *synapse;\n\t\tsize_t id;\n\t\tstruct counter_comp comp;\n\t\tint err;\n\n\t\tsynapse = count->synapses + i;\n\n\t\t \n\t\tid = synapse->signal - counter->signals;\n\t\tcomp.name = devm_kasprintf(dev, GFP_KERNEL, \"signal%zu_action\",\n\t\t\t\t\t   id);\n\t\tif (!comp.name)\n\t\t\treturn -ENOMEM;\n\n\t\t \n\t\tcomp.type = COUNTER_COMP_SYNAPSE_ACTION;\n\t\tcomp.action_read = counter->ops->action_read;\n\t\tcomp.action_write = counter->ops->action_write;\n\t\tcomp.priv = synapse;\n\t\terr = counter_attr_create(dev, group, &comp,\n\t\t\t\t\t  COUNTER_SCOPE_COUNT, count);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t \n\t\terr = counter_comp_id_attr_create(dev, group, comp.name, i);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic struct counter_comp counter_count_comp =\n\tCOUNTER_COMP_COUNT_U64(\"count\", NULL, NULL);\n\nstatic struct counter_comp counter_function_comp = {\n\t.type = COUNTER_COMP_FUNCTION,\n\t.name = \"function\",\n};\n\nstatic int counter_count_attrs_create(struct counter_device *const counter,\n\tstruct counter_attribute_group *const cattr_group,\n\tstruct counter_count *const count)\n{\n\tconst enum counter_scope scope = COUNTER_SCOPE_COUNT;\n\tstruct device *const dev = &counter->dev;\n\tint err;\n\tstruct counter_comp comp;\n\n\t \n\tcomp = counter_count_comp;\n\tcomp.count_u64_read = counter->ops->count_read;\n\tcomp.count_u64_write = counter->ops->count_write;\n\terr = counter_attr_create(dev, cattr_group, &comp, scope, count);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = counter_name_attr_create(dev, cattr_group, count->name);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tcomp = counter_function_comp;\n\tcomp.count_u32_read = counter->ops->function_read;\n\tcomp.count_u32_write = counter->ops->function_write;\n\terr = counter_attr_create(dev, cattr_group, &comp, scope, count);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\treturn counter_sysfs_exts_add(dev, cattr_group, count->ext,\n\t\t\t\t      count->num_ext, scope, count);\n}\n\nstatic int counter_sysfs_counts_add(struct counter_device *const counter,\n\tstruct counter_attribute_group *const groups)\n{\n\tsize_t i;\n\tstruct counter_count *count;\n\tint err;\n\n\t \n\tfor (i = 0; i < counter->num_counts; i++) {\n\t\tcount = counter->counts + i;\n\n\t\t \n\t\tgroups[i].name = devm_kasprintf(&counter->dev, GFP_KERNEL,\n\t\t\t\t\t\t\"count%zu\", i);\n\t\tif (!groups[i].name)\n\t\t\treturn -ENOMEM;\n\n\t\t \n\t\terr = counter_sysfs_synapses_add(counter, groups + i, count);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t \n\t\terr = counter_count_attrs_create(counter, groups + i, count);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int counter_num_signals_read(struct counter_device *counter, u8 *val)\n{\n\t*val = counter->num_signals;\n\treturn 0;\n}\n\nstatic int counter_num_counts_read(struct counter_device *counter, u8 *val)\n{\n\t*val = counter->num_counts;\n\treturn 0;\n}\n\nstatic int counter_events_queue_size_read(struct counter_device *counter,\n\t\t\t\t\t  u64 *val)\n{\n\t*val = kfifo_size(&counter->events);\n\treturn 0;\n}\n\nstatic int counter_events_queue_size_write(struct counter_device *counter,\n\t\t\t\t\t   u64 val)\n{\n\tDECLARE_KFIFO_PTR(events, struct counter_event);\n\tint err;\n\tunsigned long flags;\n\n\t \n\terr = kfifo_alloc(&events, val, GFP_KERNEL);\n\tif (err)\n\t\treturn err;\n\n\t \n\tmutex_lock(&counter->events_out_lock);\n\tspin_lock_irqsave(&counter->events_in_lock, flags);\n\tkfifo_free(&counter->events);\n\tcounter->events.kfifo = events.kfifo;\n\tspin_unlock_irqrestore(&counter->events_in_lock, flags);\n\tmutex_unlock(&counter->events_out_lock);\n\n\treturn 0;\n}\n\nstatic struct counter_comp counter_num_signals_comp =\n\tCOUNTER_COMP_DEVICE_U8(\"num_signals\", counter_num_signals_read, NULL);\n\nstatic struct counter_comp counter_num_counts_comp =\n\tCOUNTER_COMP_DEVICE_U8(\"num_counts\", counter_num_counts_read, NULL);\n\nstatic struct counter_comp counter_events_queue_size_comp =\n\tCOUNTER_COMP_DEVICE_U64(\"events_queue_size\",\n\t\t\t\tcounter_events_queue_size_read,\n\t\t\t\tcounter_events_queue_size_write);\n\nstatic int counter_sysfs_attr_add(struct counter_device *const counter,\n\t\t\t\t  struct counter_attribute_group *cattr_group)\n{\n\tconst enum counter_scope scope = COUNTER_SCOPE_DEVICE;\n\tstruct device *const dev = &counter->dev;\n\tint err;\n\n\t \n\terr = counter_sysfs_signals_add(counter, cattr_group);\n\tif (err < 0)\n\t\treturn err;\n\tcattr_group += counter->num_signals;\n\n\t \n\terr = counter_sysfs_counts_add(counter, cattr_group);\n\tif (err < 0)\n\t\treturn err;\n\tcattr_group += counter->num_counts;\n\n\t \n\terr = counter_name_attr_create(dev, cattr_group, counter->name);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = counter_attr_create(dev, cattr_group, &counter_num_signals_comp,\n\t\t\t\t  scope, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = counter_attr_create(dev, cattr_group, &counter_num_counts_comp,\n\t\t\t\t  scope, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = counter_attr_create(dev, cattr_group,\n\t\t\t\t  &counter_events_queue_size_comp, scope, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\treturn counter_sysfs_exts_add(dev, cattr_group, counter->ext,\n\t\t\t\t      counter->num_ext, scope, NULL);\n\n\treturn 0;\n}\n\n \nint counter_sysfs_add(struct counter_device *const counter)\n{\n\tstruct device *const dev = &counter->dev;\n\tconst size_t num_groups = counter->num_signals + counter->num_counts + 1;\n\tstruct counter_attribute_group *cattr_groups;\n\tsize_t i, j;\n\tint err;\n\tstruct attribute_group *groups;\n\tstruct counter_attribute *p;\n\n\t \n\tcattr_groups = devm_kcalloc(dev, num_groups, sizeof(*cattr_groups),\n\t\t\t\t    GFP_KERNEL);\n\tif (!cattr_groups)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = 0; i < num_groups; i++)\n\t\tINIT_LIST_HEAD(&cattr_groups[i].attr_list);\n\n\t \n\terr = counter_sysfs_attr_add(counter, cattr_groups);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tdev->groups = devm_kcalloc(dev, num_groups + 1, sizeof(*dev->groups),\n\t\t\t\t   GFP_KERNEL);\n\tif (!dev->groups)\n\t\treturn -ENOMEM;\n\n\t \n\tgroups = devm_kcalloc(dev, num_groups, sizeof(*groups), GFP_KERNEL);\n\tif (!groups)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = 0; i < num_groups; i++) {\n\t\tgroups[i].name = cattr_groups[i].name;\n\n\t\t \n\t\tgroups[i].attrs = devm_kcalloc(dev,\n\t\t\t\t\t       cattr_groups[i].num_attr + 1,\n\t\t\t\t\t       sizeof(*groups[i].attrs),\n\t\t\t\t\t       GFP_KERNEL);\n\t\tif (!groups[i].attrs)\n\t\t\treturn -ENOMEM;\n\n\t\t \n\t\tj = 0;\n\t\tlist_for_each_entry(p, &cattr_groups[i].attr_list, l)\n\t\t\tgroups[i].attrs[j++] = &p->dev_attr.attr;\n\n\t\t \n\t\tdev->groups[i] = &groups[i];\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}