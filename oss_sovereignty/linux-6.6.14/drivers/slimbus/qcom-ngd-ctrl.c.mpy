{
  "module_name": "qcom-ngd-ctrl.c",
  "hash_id": "b189b8fb9463de6b0e87e981654077c012a178a29b8906f42167584a30598cf9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/slimbus/qcom-ngd-ctrl.c",
  "human_readable_source": "\n\n\n\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmaengine.h>\n#include <linux/slimbus.h>\n#include <linux/delay.h>\n#include <linux/pm_runtime.h>\n#include <linux/mutex.h>\n#include <linux/notifier.h>\n#include <linux/remoteproc/qcom_rproc.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/soc/qcom/qmi.h>\n#include <linux/soc/qcom/pdr.h>\n#include <net/sock.h>\n#include \"slimbus.h\"\n\n \n#define\tNGD_CFG\t\t\t0x0\n#define\tNGD_CFG_ENABLE\t\tBIT(0)\n#define\tNGD_CFG_RX_MSGQ_EN\tBIT(1)\n#define\tNGD_CFG_TX_MSGQ_EN\tBIT(2)\n#define\tNGD_STATUS\t\t0x4\n#define NGD_LADDR\t\tBIT(1)\n#define\tNGD_RX_MSGQ_CFG\t\t0x8\n#define\tNGD_INT_EN\t\t0x10\n#define\tNGD_INT_RECFG_DONE\tBIT(24)\n#define\tNGD_INT_TX_NACKED_2\tBIT(25)\n#define\tNGD_INT_MSG_BUF_CONTE\tBIT(26)\n#define\tNGD_INT_MSG_TX_INVAL\tBIT(27)\n#define\tNGD_INT_IE_VE_CHG\tBIT(28)\n#define\tNGD_INT_DEV_ERR\t\tBIT(29)\n#define\tNGD_INT_RX_MSG_RCVD\tBIT(30)\n#define\tNGD_INT_TX_MSG_SENT\tBIT(31)\n#define\tNGD_INT_STAT\t\t0x14\n#define\tNGD_INT_CLR\t\t0x18\n#define DEF_NGD_INT_MASK (NGD_INT_TX_NACKED_2 | NGD_INT_MSG_BUF_CONTE | \\\n\t\t\t\tNGD_INT_MSG_TX_INVAL | NGD_INT_IE_VE_CHG | \\\n\t\t\t\tNGD_INT_DEV_ERR | NGD_INT_TX_MSG_SENT | \\\n\t\t\t\tNGD_INT_RX_MSG_RCVD)\n\n \n#define SLIMBUS_QMI_SVC_ID\t0x0301\n#define SLIMBUS_QMI_SVC_V1\t1\n#define SLIMBUS_QMI_INS_ID\t0\n#define SLIMBUS_QMI_SELECT_INSTANCE_REQ_V01\t0x0020\n#define SLIMBUS_QMI_SELECT_INSTANCE_RESP_V01\t0x0020\n#define SLIMBUS_QMI_POWER_REQ_V01\t\t0x0021\n#define SLIMBUS_QMI_POWER_RESP_V01\t\t0x0021\n#define SLIMBUS_QMI_CHECK_FRAMER_STATUS_REQ\t0x0022\n#define SLIMBUS_QMI_CHECK_FRAMER_STATUS_RESP\t0x0022\n#define SLIMBUS_QMI_POWER_REQ_MAX_MSG_LEN\t14\n#define SLIMBUS_QMI_POWER_RESP_MAX_MSG_LEN\t7\n#define SLIMBUS_QMI_SELECT_INSTANCE_REQ_MAX_MSG_LEN\t14\n#define SLIMBUS_QMI_SELECT_INSTANCE_RESP_MAX_MSG_LEN\t7\n#define SLIMBUS_QMI_CHECK_FRAMER_STAT_RESP_MAX_MSG_LEN\t7\n \n#define SLIMBUS_QMI_RESP_TOUT\t1000\n\n \n#define SLIM_USR_MC_GENERIC_ACK\t0x25\n#define SLIM_USR_MC_MASTER_CAPABILITY\t0x0\n#define SLIM_USR_MC_REPORT_SATELLITE\t0x1\n#define SLIM_USR_MC_ADDR_QUERY\t\t0xD\n#define SLIM_USR_MC_ADDR_REPLY\t\t0xE\n#define SLIM_USR_MC_DEFINE_CHAN\t\t0x20\n#define SLIM_USR_MC_DEF_ACT_CHAN\t0x21\n#define SLIM_USR_MC_CHAN_CTRL\t\t0x23\n#define SLIM_USR_MC_RECONFIG_NOW\t0x24\n#define SLIM_USR_MC_REQ_BW\t\t0x28\n#define SLIM_USR_MC_CONNECT_SRC\t\t0x2C\n#define SLIM_USR_MC_CONNECT_SINK\t0x2D\n#define SLIM_USR_MC_DISCONNECT_PORT\t0x2E\n#define SLIM_USR_MC_REPEAT_CHANGE_VALUE\t0x0\n\n#define QCOM_SLIM_NGD_AUTOSUSPEND\tMSEC_PER_SEC\n#define SLIM_RX_MSGQ_TIMEOUT_VAL\t0x10000\n\n#define SLIM_LA_MGR\t0xFF\n#define SLIM_ROOT_FREQ\t24576000\n#define LADDR_RETRY\t5\n\n \n#define SLIM_MSGQ_BUF_LEN\t40\n#define QCOM_SLIM_NGD_DESC_NUM\t32\n\n#define SLIM_MSG_ASM_FIRST_WORD(l, mt, mc, dt, ad) \\\n\t\t((l) | ((mt) << 5) | ((mc) << 8) | ((dt) << 15) | ((ad) << 16))\n\n#define INIT_MX_RETRIES 10\n#define DEF_RETRY_MS\t10\n#define SAT_MAGIC_LSB\t0xD9\n#define SAT_MAGIC_MSB\t0xC5\n#define SAT_MSG_VER\t0x1\n#define SAT_MSG_PROT\t0x1\n#define to_ngd(d)\tcontainer_of(d, struct qcom_slim_ngd, dev)\n\nstruct ngd_reg_offset_data {\n\tu32 offset, size;\n};\n\nstatic const struct ngd_reg_offset_data ngd_v1_5_offset_info = {\n\t.offset = 0x1000,\n\t.size = 0x1000,\n};\n\nenum qcom_slim_ngd_state {\n\tQCOM_SLIM_NGD_CTRL_AWAKE,\n\tQCOM_SLIM_NGD_CTRL_IDLE,\n\tQCOM_SLIM_NGD_CTRL_ASLEEP,\n\tQCOM_SLIM_NGD_CTRL_DOWN,\n};\n\nstruct qcom_slim_ngd_qmi {\n\tstruct qmi_handle qmi;\n\tstruct sockaddr_qrtr svc_info;\n\tstruct qmi_handle svc_event_hdl;\n\tstruct qmi_response_type_v01 resp;\n\tstruct qmi_handle *handle;\n\tstruct completion qmi_comp;\n};\n\nstruct qcom_slim_ngd_ctrl;\nstruct qcom_slim_ngd;\n\nstruct qcom_slim_ngd_dma_desc {\n\tstruct dma_async_tx_descriptor *desc;\n\tstruct qcom_slim_ngd_ctrl *ctrl;\n\tstruct completion *comp;\n\tdma_cookie_t cookie;\n\tdma_addr_t phys;\n\tvoid *base;\n};\n\nstruct qcom_slim_ngd {\n\tstruct platform_device *pdev;\n\tvoid __iomem *base;\n\tint id;\n};\n\nstruct qcom_slim_ngd_ctrl {\n\tstruct slim_framer framer;\n\tstruct slim_controller ctrl;\n\tstruct qcom_slim_ngd_qmi qmi;\n\tstruct qcom_slim_ngd *ngd;\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tstruct dma_chan *dma_rx_channel;\n\tstruct dma_chan\t*dma_tx_channel;\n\tstruct qcom_slim_ngd_dma_desc rx_desc[QCOM_SLIM_NGD_DESC_NUM];\n\tstruct qcom_slim_ngd_dma_desc txdesc[QCOM_SLIM_NGD_DESC_NUM];\n\tstruct completion reconf;\n\tstruct work_struct m_work;\n\tstruct work_struct ngd_up_work;\n\tstruct workqueue_struct *mwq;\n\tstruct completion qmi_up;\n\tspinlock_t tx_buf_lock;\n\tstruct mutex tx_lock;\n\tstruct mutex ssr_lock;\n\tstruct notifier_block nb;\n\tvoid *notifier;\n\tstruct pdr_handle *pdr;\n\tenum qcom_slim_ngd_state state;\n\tdma_addr_t rx_phys_base;\n\tdma_addr_t tx_phys_base;\n\tvoid *rx_base;\n\tvoid *tx_base;\n\tint tx_tail;\n\tint tx_head;\n\tu32 ver;\n};\n\nenum slimbus_mode_enum_type_v01 {\n\t \n\tSLIMBUS_MODE_ENUM_TYPE_MIN_ENUM_VAL_V01 = INT_MIN,\n\tSLIMBUS_MODE_SATELLITE_V01 = 1,\n\tSLIMBUS_MODE_MASTER_V01 = 2,\n\tSLIMBUS_MODE_ENUM_TYPE_MAX_ENUM_VAL_V01 = INT_MAX,\n};\n\nenum slimbus_pm_enum_type_v01 {\n\t \n\tSLIMBUS_PM_ENUM_TYPE_MIN_ENUM_VAL_V01 = INT_MIN,\n\tSLIMBUS_PM_INACTIVE_V01 = 1,\n\tSLIMBUS_PM_ACTIVE_V01 = 2,\n\tSLIMBUS_PM_ENUM_TYPE_MAX_ENUM_VAL_V01 = INT_MAX,\n};\n\nenum slimbus_resp_enum_type_v01 {\n\tSLIMBUS_RESP_ENUM_TYPE_MIN_VAL_V01 = INT_MIN,\n\tSLIMBUS_RESP_SYNCHRONOUS_V01 = 1,\n\tSLIMBUS_RESP_ENUM_TYPE_MAX_VAL_V01 = INT_MAX,\n};\n\nstruct slimbus_select_inst_req_msg_v01 {\n\tuint32_t instance;\n\tuint8_t mode_valid;\n\tenum slimbus_mode_enum_type_v01 mode;\n};\n\nstruct slimbus_select_inst_resp_msg_v01 {\n\tstruct qmi_response_type_v01 resp;\n};\n\nstruct slimbus_power_req_msg_v01 {\n\tenum slimbus_pm_enum_type_v01 pm_req;\n\tuint8_t resp_type_valid;\n\tenum slimbus_resp_enum_type_v01 resp_type;\n};\n\nstruct slimbus_power_resp_msg_v01 {\n\tstruct qmi_response_type_v01 resp;\n};\n\nstatic struct qmi_elem_info slimbus_select_inst_req_msg_v01_ei[] = {\n\t{\n\t\t.data_type  = QMI_UNSIGNED_4_BYTE,\n\t\t.elem_len   = 1,\n\t\t.elem_size  = sizeof(uint32_t),\n\t\t.array_type = NO_ARRAY,\n\t\t.tlv_type   = 0x01,\n\t\t.offset     = offsetof(struct slimbus_select_inst_req_msg_v01,\n\t\t\t\t       instance),\n\t\t.ei_array   = NULL,\n\t},\n\t{\n\t\t.data_type  = QMI_OPT_FLAG,\n\t\t.elem_len   = 1,\n\t\t.elem_size  = sizeof(uint8_t),\n\t\t.array_type = NO_ARRAY,\n\t\t.tlv_type   = 0x10,\n\t\t.offset     = offsetof(struct slimbus_select_inst_req_msg_v01,\n\t\t\t\t       mode_valid),\n\t\t.ei_array   = NULL,\n\t},\n\t{\n\t\t.data_type  = QMI_UNSIGNED_4_BYTE,\n\t\t.elem_len   = 1,\n\t\t.elem_size  = sizeof(enum slimbus_mode_enum_type_v01),\n\t\t.array_type = NO_ARRAY,\n\t\t.tlv_type   = 0x10,\n\t\t.offset     = offsetof(struct slimbus_select_inst_req_msg_v01,\n\t\t\t\t       mode),\n\t\t.ei_array   = NULL,\n\t},\n\t{\n\t\t.data_type  = QMI_EOTI,\n\t\t.elem_len   = 0,\n\t\t.elem_size  = 0,\n\t\t.array_type = NO_ARRAY,\n\t\t.tlv_type   = 0x00,\n\t\t.offset     = 0,\n\t\t.ei_array   = NULL,\n\t},\n};\n\nstatic struct qmi_elem_info slimbus_select_inst_resp_msg_v01_ei[] = {\n\t{\n\t\t.data_type  = QMI_STRUCT,\n\t\t.elem_len   = 1,\n\t\t.elem_size  = sizeof(struct qmi_response_type_v01),\n\t\t.array_type = NO_ARRAY,\n\t\t.tlv_type   = 0x02,\n\t\t.offset     = offsetof(struct slimbus_select_inst_resp_msg_v01,\n\t\t\t\t       resp),\n\t\t.ei_array   = qmi_response_type_v01_ei,\n\t},\n\t{\n\t\t.data_type  = QMI_EOTI,\n\t\t.elem_len   = 0,\n\t\t.elem_size  = 0,\n\t\t.array_type = NO_ARRAY,\n\t\t.tlv_type   = 0x00,\n\t\t.offset     = 0,\n\t\t.ei_array   = NULL,\n\t},\n};\n\nstatic struct qmi_elem_info slimbus_power_req_msg_v01_ei[] = {\n\t{\n\t\t.data_type  = QMI_UNSIGNED_4_BYTE,\n\t\t.elem_len   = 1,\n\t\t.elem_size  = sizeof(enum slimbus_pm_enum_type_v01),\n\t\t.array_type = NO_ARRAY,\n\t\t.tlv_type   = 0x01,\n\t\t.offset     = offsetof(struct slimbus_power_req_msg_v01,\n\t\t\t\t       pm_req),\n\t\t.ei_array   = NULL,\n\t},\n\t{\n\t\t.data_type  = QMI_OPT_FLAG,\n\t\t.elem_len   = 1,\n\t\t.elem_size  = sizeof(uint8_t),\n\t\t.array_type = NO_ARRAY,\n\t\t.tlv_type   = 0x10,\n\t\t.offset     = offsetof(struct slimbus_power_req_msg_v01,\n\t\t\t\t       resp_type_valid),\n\t},\n\t{\n\t\t.data_type  = QMI_SIGNED_4_BYTE_ENUM,\n\t\t.elem_len   = 1,\n\t\t.elem_size  = sizeof(enum slimbus_resp_enum_type_v01),\n\t\t.array_type = NO_ARRAY,\n\t\t.tlv_type   = 0x10,\n\t\t.offset     = offsetof(struct slimbus_power_req_msg_v01,\n\t\t\t\t       resp_type),\n\t},\n\t{\n\t\t.data_type  = QMI_EOTI,\n\t\t.elem_len   = 0,\n\t\t.elem_size  = 0,\n\t\t.array_type = NO_ARRAY,\n\t\t.tlv_type   = 0x00,\n\t\t.offset     = 0,\n\t\t.ei_array   = NULL,\n\t},\n};\n\nstatic struct qmi_elem_info slimbus_power_resp_msg_v01_ei[] = {\n\t{\n\t\t.data_type  = QMI_STRUCT,\n\t\t.elem_len   = 1,\n\t\t.elem_size  = sizeof(struct qmi_response_type_v01),\n\t\t.array_type = NO_ARRAY,\n\t\t.tlv_type   = 0x02,\n\t\t.offset     = offsetof(struct slimbus_power_resp_msg_v01, resp),\n\t\t.ei_array   = qmi_response_type_v01_ei,\n\t},\n\t{\n\t\t.data_type  = QMI_EOTI,\n\t\t.elem_len   = 0,\n\t\t.elem_size  = 0,\n\t\t.array_type = NO_ARRAY,\n\t\t.tlv_type   = 0x00,\n\t\t.offset     = 0,\n\t\t.ei_array   = NULL,\n\t},\n};\n\nstatic int qcom_slim_qmi_send_select_inst_req(struct qcom_slim_ngd_ctrl *ctrl,\n\t\t\t\tstruct slimbus_select_inst_req_msg_v01 *req)\n{\n\tstruct slimbus_select_inst_resp_msg_v01 resp = { { 0, 0 } };\n\tstruct qmi_txn txn;\n\tint rc;\n\n\trc = qmi_txn_init(ctrl->qmi.handle, &txn,\n\t\t\t\tslimbus_select_inst_resp_msg_v01_ei, &resp);\n\tif (rc < 0) {\n\t\tdev_err(ctrl->dev, \"QMI TXN init fail: %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\trc = qmi_send_request(ctrl->qmi.handle, NULL, &txn,\n\t\t\t\tSLIMBUS_QMI_SELECT_INSTANCE_REQ_V01,\n\t\t\t\tSLIMBUS_QMI_SELECT_INSTANCE_REQ_MAX_MSG_LEN,\n\t\t\t\tslimbus_select_inst_req_msg_v01_ei, req);\n\tif (rc < 0) {\n\t\tdev_err(ctrl->dev, \"QMI send req fail %d\\n\", rc);\n\t\tqmi_txn_cancel(&txn);\n\t\treturn rc;\n\t}\n\n\trc = qmi_txn_wait(&txn, SLIMBUS_QMI_RESP_TOUT);\n\tif (rc < 0) {\n\t\tdev_err(ctrl->dev, \"QMI TXN wait fail: %d\\n\", rc);\n\t\treturn rc;\n\t}\n\t \n\tif (resp.resp.result != QMI_RESULT_SUCCESS_V01) {\n\t\tdev_err(ctrl->dev, \"QMI request failed 0x%x\\n\",\n\t\t\tresp.resp.result);\n\t\treturn -EREMOTEIO;\n\t}\n\n\treturn 0;\n}\n\nstatic void qcom_slim_qmi_power_resp_cb(struct qmi_handle *handle,\n\t\t\t\t\tstruct sockaddr_qrtr *sq,\n\t\t\t\t\tstruct qmi_txn *txn, const void *data)\n{\n\tstruct slimbus_power_resp_msg_v01 *resp;\n\n\tresp = (struct slimbus_power_resp_msg_v01 *)data;\n\tif (resp->resp.result != QMI_RESULT_SUCCESS_V01)\n\t\tpr_err(\"QMI power request failed 0x%x\\n\",\n\t\t\t\tresp->resp.result);\n\n\tcomplete(&txn->completion);\n}\n\nstatic int qcom_slim_qmi_send_power_request(struct qcom_slim_ngd_ctrl *ctrl,\n\t\t\t\t\tstruct slimbus_power_req_msg_v01 *req)\n{\n\tstruct slimbus_power_resp_msg_v01 resp = { { 0, 0 } };\n\tstruct qmi_txn txn;\n\tint rc;\n\n\trc = qmi_txn_init(ctrl->qmi.handle, &txn,\n\t\t\t\tslimbus_power_resp_msg_v01_ei, &resp);\n\n\trc = qmi_send_request(ctrl->qmi.handle, NULL, &txn,\n\t\t\t\tSLIMBUS_QMI_POWER_REQ_V01,\n\t\t\t\tSLIMBUS_QMI_POWER_REQ_MAX_MSG_LEN,\n\t\t\t\tslimbus_power_req_msg_v01_ei, req);\n\tif (rc < 0) {\n\t\tdev_err(ctrl->dev, \"QMI send req fail %d\\n\", rc);\n\t\tqmi_txn_cancel(&txn);\n\t\treturn rc;\n\t}\n\n\trc = qmi_txn_wait(&txn, SLIMBUS_QMI_RESP_TOUT);\n\tif (rc < 0) {\n\t\tdev_err(ctrl->dev, \"QMI TXN wait fail: %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\t \n\tif (resp.resp.result != QMI_RESULT_SUCCESS_V01) {\n\t\tdev_err(ctrl->dev, \"QMI request failed 0x%x\\n\",\n\t\t\tresp.resp.result);\n\t\treturn -EREMOTEIO;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct qmi_msg_handler qcom_slim_qmi_msg_handlers[] = {\n\t{\n\t\t.type = QMI_RESPONSE,\n\t\t.msg_id = SLIMBUS_QMI_POWER_RESP_V01,\n\t\t.ei = slimbus_power_resp_msg_v01_ei,\n\t\t.decoded_size = sizeof(struct slimbus_power_resp_msg_v01),\n\t\t.fn = qcom_slim_qmi_power_resp_cb,\n\t},\n\t{}\n};\n\nstatic int qcom_slim_qmi_init(struct qcom_slim_ngd_ctrl *ctrl,\n\t\t\t      bool apps_is_master)\n{\n\tstruct slimbus_select_inst_req_msg_v01 req;\n\tstruct qmi_handle *handle;\n\tint rc;\n\n\thandle = devm_kzalloc(ctrl->dev, sizeof(*handle), GFP_KERNEL);\n\tif (!handle)\n\t\treturn -ENOMEM;\n\n\trc = qmi_handle_init(handle, SLIMBUS_QMI_POWER_REQ_MAX_MSG_LEN,\n\t\t\t\tNULL, qcom_slim_qmi_msg_handlers);\n\tif (rc < 0) {\n\t\tdev_err(ctrl->dev, \"QMI client init failed: %d\\n\", rc);\n\t\tgoto qmi_handle_init_failed;\n\t}\n\n\trc = kernel_connect(handle->sock,\n\t\t\t\t(struct sockaddr *)&ctrl->qmi.svc_info,\n\t\t\t\tsizeof(ctrl->qmi.svc_info), 0);\n\tif (rc < 0) {\n\t\tdev_err(ctrl->dev, \"Remote Service connect failed: %d\\n\", rc);\n\t\tgoto qmi_connect_to_service_failed;\n\t}\n\n\t \n\treq.instance = (ctrl->ngd->id >> 1);\n\treq.mode_valid = 1;\n\n\t \n\tif (apps_is_master)\n\t\treq.mode = SLIMBUS_MODE_SATELLITE_V01;\n\telse\n\t\treq.mode = SLIMBUS_MODE_MASTER_V01;\n\n\tctrl->qmi.handle = handle;\n\n\trc = qcom_slim_qmi_send_select_inst_req(ctrl, &req);\n\tif (rc) {\n\t\tdev_err(ctrl->dev, \"failed to select h/w instance\\n\");\n\t\tgoto qmi_select_instance_failed;\n\t}\n\n\treturn 0;\n\nqmi_select_instance_failed:\n\tctrl->qmi.handle = NULL;\nqmi_connect_to_service_failed:\n\tqmi_handle_release(handle);\nqmi_handle_init_failed:\n\tdevm_kfree(ctrl->dev, handle);\n\treturn rc;\n}\n\nstatic void qcom_slim_qmi_exit(struct qcom_slim_ngd_ctrl *ctrl)\n{\n\tif (!ctrl->qmi.handle)\n\t\treturn;\n\n\tqmi_handle_release(ctrl->qmi.handle);\n\tdevm_kfree(ctrl->dev, ctrl->qmi.handle);\n\tctrl->qmi.handle = NULL;\n}\n\nstatic int qcom_slim_qmi_power_request(struct qcom_slim_ngd_ctrl *ctrl,\n\t\t\t\t       bool active)\n{\n\tstruct slimbus_power_req_msg_v01 req;\n\n\tif (active)\n\t\treq.pm_req = SLIMBUS_PM_ACTIVE_V01;\n\telse\n\t\treq.pm_req = SLIMBUS_PM_INACTIVE_V01;\n\n\treq.resp_type_valid = 0;\n\n\treturn qcom_slim_qmi_send_power_request(ctrl, &req);\n}\n\nstatic u32 *qcom_slim_ngd_tx_msg_get(struct qcom_slim_ngd_ctrl *ctrl, int len,\n\t\t\t\t     struct completion *comp)\n{\n\tstruct qcom_slim_ngd_dma_desc *desc;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctrl->tx_buf_lock, flags);\n\n\tif ((ctrl->tx_tail + 1) % QCOM_SLIM_NGD_DESC_NUM == ctrl->tx_head) {\n\t\tspin_unlock_irqrestore(&ctrl->tx_buf_lock, flags);\n\t\treturn NULL;\n\t}\n\tdesc  = &ctrl->txdesc[ctrl->tx_tail];\n\tdesc->base = ctrl->tx_base + ctrl->tx_tail * SLIM_MSGQ_BUF_LEN;\n\tdesc->comp = comp;\n\tctrl->tx_tail = (ctrl->tx_tail + 1) % QCOM_SLIM_NGD_DESC_NUM;\n\n\tspin_unlock_irqrestore(&ctrl->tx_buf_lock, flags);\n\n\treturn desc->base;\n}\n\nstatic void qcom_slim_ngd_tx_msg_dma_cb(void *args)\n{\n\tstruct qcom_slim_ngd_dma_desc *desc = args;\n\tstruct qcom_slim_ngd_ctrl *ctrl = desc->ctrl;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctrl->tx_buf_lock, flags);\n\n\tif (desc->comp) {\n\t\tcomplete(desc->comp);\n\t\tdesc->comp = NULL;\n\t}\n\n\tctrl->tx_head = (ctrl->tx_head + 1) % QCOM_SLIM_NGD_DESC_NUM;\n\tspin_unlock_irqrestore(&ctrl->tx_buf_lock, flags);\n}\n\nstatic int qcom_slim_ngd_tx_msg_post(struct qcom_slim_ngd_ctrl *ctrl,\n\t\t\t\t     void *buf, int len)\n{\n\tstruct qcom_slim_ngd_dma_desc *desc;\n\tunsigned long flags;\n\tint index, offset;\n\n\tspin_lock_irqsave(&ctrl->tx_buf_lock, flags);\n\toffset = buf - ctrl->tx_base;\n\tindex = offset/SLIM_MSGQ_BUF_LEN;\n\n\tdesc = &ctrl->txdesc[index];\n\tdesc->phys = ctrl->tx_phys_base + offset;\n\tdesc->base = ctrl->tx_base + offset;\n\tdesc->ctrl = ctrl;\n\tlen = (len + 3) & 0xfc;\n\n\tdesc->desc = dmaengine_prep_slave_single(ctrl->dma_tx_channel,\n\t\t\t\t\t\tdesc->phys, len,\n\t\t\t\t\t\tDMA_MEM_TO_DEV,\n\t\t\t\t\t\tDMA_PREP_INTERRUPT);\n\tif (!desc->desc) {\n\t\tdev_err(ctrl->dev, \"unable to prepare channel\\n\");\n\t\tspin_unlock_irqrestore(&ctrl->tx_buf_lock, flags);\n\t\treturn -EINVAL;\n\t}\n\n\tdesc->desc->callback = qcom_slim_ngd_tx_msg_dma_cb;\n\tdesc->desc->callback_param = desc;\n\tdesc->desc->cookie = dmaengine_submit(desc->desc);\n\tdma_async_issue_pending(ctrl->dma_tx_channel);\n\tspin_unlock_irqrestore(&ctrl->tx_buf_lock, flags);\n\n\treturn 0;\n}\n\nstatic void qcom_slim_ngd_rx(struct qcom_slim_ngd_ctrl *ctrl, u8 *buf)\n{\n\tu8 mc, mt, len;\n\n\tmt = SLIM_HEADER_GET_MT(buf[0]);\n\tlen = SLIM_HEADER_GET_RL(buf[0]);\n\tmc = SLIM_HEADER_GET_MC(buf[1]);\n\n\tif (mc == SLIM_USR_MC_MASTER_CAPABILITY &&\n\t\tmt == SLIM_MSG_MT_SRC_REFERRED_USER)\n\t\tqueue_work(ctrl->mwq, &ctrl->m_work);\n\n\tif (mc == SLIM_MSG_MC_REPLY_INFORMATION ||\n\t    mc == SLIM_MSG_MC_REPLY_VALUE || (mc == SLIM_USR_MC_ADDR_REPLY &&\n\t    mt == SLIM_MSG_MT_SRC_REFERRED_USER) ||\n\t\t(mc == SLIM_USR_MC_GENERIC_ACK &&\n\t\t mt == SLIM_MSG_MT_SRC_REFERRED_USER)) {\n\t\tslim_msg_response(&ctrl->ctrl, &buf[4], buf[3], len - 4);\n\t\tpm_runtime_mark_last_busy(ctrl->ctrl.dev);\n\t}\n}\n\nstatic void qcom_slim_ngd_rx_msgq_cb(void *args)\n{\n\tstruct qcom_slim_ngd_dma_desc *desc = args;\n\tstruct qcom_slim_ngd_ctrl *ctrl = desc->ctrl;\n\n\tqcom_slim_ngd_rx(ctrl, (u8 *)desc->base);\n\t \n\tdesc->desc = dmaengine_prep_slave_single(ctrl->dma_rx_channel,\n\t\t\t\t\tdesc->phys, SLIM_MSGQ_BUF_LEN,\n\t\t\t\t\tDMA_DEV_TO_MEM,\n\t\t\t\t\tDMA_PREP_INTERRUPT);\n\tif (!desc->desc) {\n\t\tdev_err(ctrl->dev, \"Unable to prepare rx channel\\n\");\n\t\treturn;\n\t}\n\n\tdesc->desc->callback = qcom_slim_ngd_rx_msgq_cb;\n\tdesc->desc->callback_param = desc;\n\tdesc->desc->cookie = dmaengine_submit(desc->desc);\n\tdma_async_issue_pending(ctrl->dma_rx_channel);\n}\n\nstatic int qcom_slim_ngd_post_rx_msgq(struct qcom_slim_ngd_ctrl *ctrl)\n{\n\tstruct qcom_slim_ngd_dma_desc *desc;\n\tint i;\n\n\tfor (i = 0; i < QCOM_SLIM_NGD_DESC_NUM; i++) {\n\t\tdesc = &ctrl->rx_desc[i];\n\t\tdesc->phys = ctrl->rx_phys_base + i * SLIM_MSGQ_BUF_LEN;\n\t\tdesc->ctrl = ctrl;\n\t\tdesc->base = ctrl->rx_base + i * SLIM_MSGQ_BUF_LEN;\n\t\tdesc->desc = dmaengine_prep_slave_single(ctrl->dma_rx_channel,\n\t\t\t\t\t\tdesc->phys, SLIM_MSGQ_BUF_LEN,\n\t\t\t\t\t\tDMA_DEV_TO_MEM,\n\t\t\t\t\t\tDMA_PREP_INTERRUPT);\n\t\tif (!desc->desc) {\n\t\t\tdev_err(ctrl->dev, \"Unable to prepare rx channel\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tdesc->desc->callback = qcom_slim_ngd_rx_msgq_cb;\n\t\tdesc->desc->callback_param = desc;\n\t\tdesc->desc->cookie = dmaengine_submit(desc->desc);\n\t}\n\tdma_async_issue_pending(ctrl->dma_rx_channel);\n\n\treturn 0;\n}\n\nstatic int qcom_slim_ngd_init_rx_msgq(struct qcom_slim_ngd_ctrl *ctrl)\n{\n\tstruct device *dev = ctrl->dev;\n\tint ret, size;\n\n\tctrl->dma_rx_channel = dma_request_chan(dev, \"rx\");\n\tif (IS_ERR(ctrl->dma_rx_channel)) {\n\t\tdev_err(dev, \"Failed to request RX dma channel\");\n\t\tret = PTR_ERR(ctrl->dma_rx_channel);\n\t\tctrl->dma_rx_channel = NULL;\n\t\treturn ret;\n\t}\n\n\tsize = QCOM_SLIM_NGD_DESC_NUM * SLIM_MSGQ_BUF_LEN;\n\tctrl->rx_base = dma_alloc_coherent(dev, size, &ctrl->rx_phys_base,\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!ctrl->rx_base) {\n\t\tret = -ENOMEM;\n\t\tgoto rel_rx;\n\t}\n\n\tret = qcom_slim_ngd_post_rx_msgq(ctrl);\n\tif (ret) {\n\t\tdev_err(dev, \"post_rx_msgq() failed 0x%x\\n\", ret);\n\t\tgoto rx_post_err;\n\t}\n\n\treturn 0;\n\nrx_post_err:\n\tdma_free_coherent(dev, size, ctrl->rx_base, ctrl->rx_phys_base);\nrel_rx:\n\tdma_release_channel(ctrl->dma_rx_channel);\n\treturn ret;\n}\n\nstatic int qcom_slim_ngd_init_tx_msgq(struct qcom_slim_ngd_ctrl *ctrl)\n{\n\tstruct device *dev = ctrl->dev;\n\tunsigned long flags;\n\tint ret = 0;\n\tint size;\n\n\tctrl->dma_tx_channel = dma_request_chan(dev, \"tx\");\n\tif (IS_ERR(ctrl->dma_tx_channel)) {\n\t\tdev_err(dev, \"Failed to request TX dma channel\");\n\t\tret = PTR_ERR(ctrl->dma_tx_channel);\n\t\tctrl->dma_tx_channel = NULL;\n\t\treturn ret;\n\t}\n\n\tsize = ((QCOM_SLIM_NGD_DESC_NUM + 1) * SLIM_MSGQ_BUF_LEN);\n\tctrl->tx_base = dma_alloc_coherent(dev, size, &ctrl->tx_phys_base,\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!ctrl->tx_base) {\n\t\tret = -EINVAL;\n\t\tgoto rel_tx;\n\t}\n\n\tspin_lock_irqsave(&ctrl->tx_buf_lock, flags);\n\tctrl->tx_tail = 0;\n\tctrl->tx_head = 0;\n\tspin_unlock_irqrestore(&ctrl->tx_buf_lock, flags);\n\n\treturn 0;\nrel_tx:\n\tdma_release_channel(ctrl->dma_tx_channel);\n\treturn ret;\n}\n\nstatic int qcom_slim_ngd_init_dma(struct qcom_slim_ngd_ctrl *ctrl)\n{\n\tint ret = 0;\n\n\tret = qcom_slim_ngd_init_rx_msgq(ctrl);\n\tif (ret) {\n\t\tdev_err(ctrl->dev, \"rx dma init failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = qcom_slim_ngd_init_tx_msgq(ctrl);\n\tif (ret)\n\t\tdev_err(ctrl->dev, \"tx dma init failed\\n\");\n\n\treturn ret;\n}\n\nstatic irqreturn_t qcom_slim_ngd_interrupt(int irq, void *d)\n{\n\tstruct qcom_slim_ngd_ctrl *ctrl = d;\n\tvoid __iomem *base = ctrl->ngd->base;\n\tu32 stat;\n\n\tif (pm_runtime_suspended(ctrl->ctrl.dev)) {\n\t\tdev_warn_once(ctrl->dev, \"Interrupt received while suspended\\n\");\n\t\treturn IRQ_NONE;\n\t}\n\n\tstat = readl(base + NGD_INT_STAT);\n\n\tif ((stat & NGD_INT_MSG_BUF_CONTE) ||\n\t\t(stat & NGD_INT_MSG_TX_INVAL) || (stat & NGD_INT_DEV_ERR) ||\n\t\t(stat & NGD_INT_TX_NACKED_2)) {\n\t\tdev_err(ctrl->dev, \"Error Interrupt received 0x%x\\n\", stat);\n\t}\n\n\twritel(stat, base + NGD_INT_CLR);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int qcom_slim_ngd_xfer_msg(struct slim_controller *sctrl,\n\t\t\t\t  struct slim_msg_txn *txn)\n{\n\tstruct qcom_slim_ngd_ctrl *ctrl = dev_get_drvdata(sctrl->dev);\n\tDECLARE_COMPLETION_ONSTACK(tx_sent);\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tint ret, timeout, i;\n\tu8 wbuf[SLIM_MSGQ_BUF_LEN];\n\tu8 rbuf[SLIM_MSGQ_BUF_LEN];\n\tu32 *pbuf;\n\tu8 *puc;\n\tu8 la = txn->la;\n\tbool usr_msg = false;\n\n\tif (txn->mt == SLIM_MSG_MT_CORE &&\n\t\t(txn->mc >= SLIM_MSG_MC_BEGIN_RECONFIGURATION &&\n\t\t txn->mc <= SLIM_MSG_MC_RECONFIGURE_NOW))\n\t\treturn 0;\n\n\tif (txn->dt == SLIM_MSG_DEST_ENUMADDR)\n\t\treturn -EPROTONOSUPPORT;\n\n\tif (txn->msg->num_bytes > SLIM_MSGQ_BUF_LEN ||\n\t\t\ttxn->rl > SLIM_MSGQ_BUF_LEN) {\n\t\tdev_err(ctrl->dev, \"msg exceeds HW limit\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpbuf = qcom_slim_ngd_tx_msg_get(ctrl, txn->rl, &tx_sent);\n\tif (!pbuf) {\n\t\tdev_err(ctrl->dev, \"Message buffer unavailable\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (txn->mt == SLIM_MSG_MT_CORE &&\n\t\t(txn->mc == SLIM_MSG_MC_CONNECT_SOURCE ||\n\t\ttxn->mc == SLIM_MSG_MC_CONNECT_SINK ||\n\t\ttxn->mc == SLIM_MSG_MC_DISCONNECT_PORT)) {\n\t\ttxn->mt = SLIM_MSG_MT_DEST_REFERRED_USER;\n\t\tswitch (txn->mc) {\n\t\tcase SLIM_MSG_MC_CONNECT_SOURCE:\n\t\t\ttxn->mc = SLIM_USR_MC_CONNECT_SRC;\n\t\t\tbreak;\n\t\tcase SLIM_MSG_MC_CONNECT_SINK:\n\t\t\ttxn->mc = SLIM_USR_MC_CONNECT_SINK;\n\t\t\tbreak;\n\t\tcase SLIM_MSG_MC_DISCONNECT_PORT:\n\t\t\ttxn->mc = SLIM_USR_MC_DISCONNECT_PORT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tusr_msg = true;\n\t\ti = 0;\n\t\twbuf[i++] = txn->la;\n\t\tla = SLIM_LA_MGR;\n\t\twbuf[i++] = txn->msg->wbuf[0];\n\t\tif (txn->mc != SLIM_USR_MC_DISCONNECT_PORT)\n\t\t\twbuf[i++] = txn->msg->wbuf[1];\n\n\t\ttxn->comp = &done;\n\t\tret = slim_alloc_txn_tid(sctrl, txn);\n\t\tif (ret) {\n\t\t\tdev_err(ctrl->dev, \"Unable to allocate TID\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\twbuf[i++] = txn->tid;\n\n\t\ttxn->msg->num_bytes = i;\n\t\ttxn->msg->wbuf = wbuf;\n\t\ttxn->msg->rbuf = rbuf;\n\t\ttxn->rl = txn->msg->num_bytes + 4;\n\t}\n\n\t \n\ttxn->rl--;\n\tpuc = (u8 *)pbuf;\n\t*pbuf = 0;\n\tif (txn->dt == SLIM_MSG_DEST_LOGICALADDR) {\n\t\t*pbuf = SLIM_MSG_ASM_FIRST_WORD(txn->rl, txn->mt, txn->mc, 0,\n\t\t\t\tla);\n\t\tpuc += 3;\n\t} else {\n\t\t*pbuf = SLIM_MSG_ASM_FIRST_WORD(txn->rl, txn->mt, txn->mc, 1,\n\t\t\t\tla);\n\t\tpuc += 2;\n\t}\n\n\tif (slim_tid_txn(txn->mt, txn->mc))\n\t\t*(puc++) = txn->tid;\n\n\tif (slim_ec_txn(txn->mt, txn->mc)) {\n\t\t*(puc++) = (txn->ec & 0xFF);\n\t\t*(puc++) = (txn->ec >> 8) & 0xFF;\n\t}\n\n\tif (txn->msg && txn->msg->wbuf)\n\t\tmemcpy(puc, txn->msg->wbuf, txn->msg->num_bytes);\n\n\tmutex_lock(&ctrl->tx_lock);\n\tret = qcom_slim_ngd_tx_msg_post(ctrl, pbuf, txn->rl);\n\tif (ret) {\n\t\tmutex_unlock(&ctrl->tx_lock);\n\t\treturn ret;\n\t}\n\n\ttimeout = wait_for_completion_timeout(&tx_sent, HZ);\n\tif (!timeout) {\n\t\tdev_err(sctrl->dev, \"TX timed out:MC:0x%x,mt:0x%x\", txn->mc,\n\t\t\t\t\ttxn->mt);\n\t\tmutex_unlock(&ctrl->tx_lock);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tif (usr_msg) {\n\t\ttimeout = wait_for_completion_timeout(&done, HZ);\n\t\tif (!timeout) {\n\t\t\tdev_err(sctrl->dev, \"TX timed out:MC:0x%x,mt:0x%x\",\n\t\t\t\ttxn->mc, txn->mt);\n\t\t\tmutex_unlock(&ctrl->tx_lock);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t}\n\n\tmutex_unlock(&ctrl->tx_lock);\n\treturn 0;\n}\n\nstatic int qcom_slim_ngd_xfer_msg_sync(struct slim_controller *ctrl,\n\t\t\t\t       struct slim_msg_txn *txn)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tint ret, timeout;\n\n\tret = pm_runtime_get_sync(ctrl->dev);\n\tif (ret < 0)\n\t\tgoto pm_put;\n\n\ttxn->comp = &done;\n\n\tret = qcom_slim_ngd_xfer_msg(ctrl, txn);\n\tif (ret)\n\t\tgoto pm_put;\n\n\ttimeout = wait_for_completion_timeout(&done, HZ);\n\tif (!timeout) {\n\t\tdev_err(ctrl->dev, \"TX timed out:MC:0x%x,mt:0x%x\", txn->mc,\n\t\t\t\ttxn->mt);\n\t\tret = -ETIMEDOUT;\n\t\tgoto pm_put;\n\t}\n\treturn 0;\n\npm_put:\n\tpm_runtime_put(ctrl->dev);\n\n\treturn ret;\n}\n\nstatic int qcom_slim_calc_coef(struct slim_stream_runtime *rt, int *exp)\n{\n\tstruct slim_controller *ctrl = rt->dev->ctrl;\n\tint coef;\n\n\tif (rt->ratem * ctrl->a_framer->superfreq < rt->rate)\n\t\trt->ratem++;\n\n\tcoef = rt->ratem;\n\t*exp = 0;\n\n\t \n\twhile (1) {\n\t\twhile ((coef & 0x1) != 0x1) {\n\t\t\tcoef >>= 1;\n\t\t\t*exp = *exp + 1;\n\t\t}\n\n\t\tif (coef <= 3)\n\t\t\tbreak;\n\n\t\tcoef++;\n\t}\n\n\t \n\tif (coef == 1) {\n\t\tif (*exp > 9)\n\t\t\treturn -EIO;\n\t\tcoef = 0;\n\t} else {\n\t\tif (*exp > 8)\n\t\t\treturn -EIO;\n\t\tcoef = 1;\n\t}\n\n\treturn coef;\n}\n\nstatic int qcom_slim_ngd_enable_stream(struct slim_stream_runtime *rt)\n{\n\tstruct slim_device *sdev = rt->dev;\n\tstruct slim_controller *ctrl = sdev->ctrl;\n\tstruct slim_val_inf msg =  {0};\n\tu8 wbuf[SLIM_MSGQ_BUF_LEN];\n\tu8 rbuf[SLIM_MSGQ_BUF_LEN];\n\tstruct slim_msg_txn txn = {0,};\n\tint i, ret;\n\n\ttxn.mt = SLIM_MSG_MT_DEST_REFERRED_USER;\n\ttxn.dt = SLIM_MSG_DEST_LOGICALADDR;\n\ttxn.la = SLIM_LA_MGR;\n\ttxn.ec = 0;\n\ttxn.msg = &msg;\n\ttxn.msg->num_bytes = 0;\n\ttxn.msg->wbuf = wbuf;\n\ttxn.msg->rbuf = rbuf;\n\n\tfor (i = 0; i < rt->num_ports; i++) {\n\t\tstruct slim_port *port = &rt->ports[i];\n\n\t\tif (txn.msg->num_bytes == 0) {\n\t\t\tint exp = 0, coef = 0;\n\n\t\t\twbuf[txn.msg->num_bytes++] = sdev->laddr;\n\t\t\twbuf[txn.msg->num_bytes] = rt->bps >> 2 |\n\t\t\t\t\t\t   (port->ch.aux_fmt << 6);\n\n\t\t\t \n\t\t\tcoef = qcom_slim_calc_coef(rt, &exp);\n\t\t\tif (coef < 0) {\n\t\t\t\tdev_err(&sdev->dev,\n\t\t\t\t\"%s: error calculating coef %d\\n\", __func__,\n\t\t\t\t\t\t\t\t\tcoef);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\n\t\t\tif (coef)\n\t\t\t\twbuf[txn.msg->num_bytes] |= BIT(5);\n\n\t\t\ttxn.msg->num_bytes++;\n\t\t\twbuf[txn.msg->num_bytes++] = exp << 4 | rt->prot;\n\n\t\t\tif (rt->prot == SLIM_PROTO_ISO)\n\t\t\t\twbuf[txn.msg->num_bytes++] =\n\t\t\t\t\t\tport->ch.prrate |\n\t\t\t\t\t\tSLIM_CHANNEL_CONTENT_FL;\n\t\t\telse\n\t\t\t\twbuf[txn.msg->num_bytes++] =  port->ch.prrate;\n\n\t\t\tret = slim_alloc_txn_tid(ctrl, &txn);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(&sdev->dev, \"Fail to allocate TID\\n\");\n\t\t\t\treturn -ENXIO;\n\t\t\t}\n\t\t\twbuf[txn.msg->num_bytes++] = txn.tid;\n\t\t}\n\t\twbuf[txn.msg->num_bytes++] = port->ch.id;\n\t}\n\n\ttxn.mc = SLIM_USR_MC_DEF_ACT_CHAN;\n\ttxn.rl = txn.msg->num_bytes + 4;\n\tret = qcom_slim_ngd_xfer_msg_sync(ctrl, &txn);\n\tif (ret) {\n\t\tslim_free_txn_tid(ctrl, &txn);\n\t\tdev_err(&sdev->dev, \"TX timed out:MC:0x%x,mt:0x%x\", txn.mc,\n\t\t\t\ttxn.mt);\n\t\treturn ret;\n\t}\n\n\ttxn.mc = SLIM_USR_MC_RECONFIG_NOW;\n\ttxn.msg->num_bytes = 2;\n\twbuf[1] = sdev->laddr;\n\ttxn.rl = txn.msg->num_bytes + 4;\n\n\tret = slim_alloc_txn_tid(ctrl, &txn);\n\tif (ret) {\n\t\tdev_err(ctrl->dev, \"Fail to allocate TID\\n\");\n\t\treturn ret;\n\t}\n\n\twbuf[0] = txn.tid;\n\tret = qcom_slim_ngd_xfer_msg_sync(ctrl, &txn);\n\tif (ret) {\n\t\tslim_free_txn_tid(ctrl, &txn);\n\t\tdev_err(&sdev->dev, \"TX timed out:MC:0x%x,mt:0x%x\", txn.mc,\n\t\t\t\ttxn.mt);\n\t}\n\n\treturn ret;\n}\n\nstatic int qcom_slim_ngd_get_laddr(struct slim_controller *ctrl,\n\t\t\t\t   struct slim_eaddr *ea, u8 *laddr)\n{\n\tstruct slim_val_inf msg =  {0};\n\tu8 failed_ea[6] = {0, 0, 0, 0, 0, 0};\n\tstruct slim_msg_txn txn;\n\tu8 wbuf[10] = {0};\n\tu8 rbuf[10] = {0};\n\tint ret;\n\n\ttxn.mt = SLIM_MSG_MT_DEST_REFERRED_USER;\n\ttxn.dt = SLIM_MSG_DEST_LOGICALADDR;\n\ttxn.la = SLIM_LA_MGR;\n\ttxn.ec = 0;\n\n\ttxn.mc = SLIM_USR_MC_ADDR_QUERY;\n\ttxn.rl = 11;\n\ttxn.msg = &msg;\n\ttxn.msg->num_bytes = 7;\n\ttxn.msg->wbuf = wbuf;\n\ttxn.msg->rbuf = rbuf;\n\n\tret = slim_alloc_txn_tid(ctrl, &txn);\n\tif (ret < 0)\n\t\treturn ret;\n\n\twbuf[0] = (u8)txn.tid;\n\tmemcpy(&wbuf[1], ea, sizeof(*ea));\n\n\tret = qcom_slim_ngd_xfer_msg_sync(ctrl, &txn);\n\tif (ret) {\n\t\tslim_free_txn_tid(ctrl, &txn);\n\t\treturn ret;\n\t}\n\n\tif (!memcmp(rbuf, failed_ea, 6))\n\t\treturn -ENXIO;\n\n\t*laddr = rbuf[6];\n\n\treturn ret;\n}\n\nstatic int qcom_slim_ngd_exit_dma(struct qcom_slim_ngd_ctrl *ctrl)\n{\n\tif (ctrl->dma_rx_channel) {\n\t\tdmaengine_terminate_sync(ctrl->dma_rx_channel);\n\t\tdma_release_channel(ctrl->dma_rx_channel);\n\t}\n\n\tif (ctrl->dma_tx_channel) {\n\t\tdmaengine_terminate_sync(ctrl->dma_tx_channel);\n\t\tdma_release_channel(ctrl->dma_tx_channel);\n\t}\n\n\tctrl->dma_tx_channel = ctrl->dma_rx_channel = NULL;\n\n\treturn 0;\n}\n\nstatic void qcom_slim_ngd_setup(struct qcom_slim_ngd_ctrl *ctrl)\n{\n\tu32 cfg = readl_relaxed(ctrl->ngd->base);\n\n\tif (ctrl->state == QCOM_SLIM_NGD_CTRL_DOWN ||\n\t\tctrl->state == QCOM_SLIM_NGD_CTRL_ASLEEP)\n\t\tqcom_slim_ngd_init_dma(ctrl);\n\n\t \n\tcfg |= NGD_CFG_RX_MSGQ_EN;\n\tcfg |= NGD_CFG_TX_MSGQ_EN;\n\n\t \n\tif (!(cfg & NGD_CFG_ENABLE))\n\t\tcfg |= NGD_CFG_ENABLE;\n\n\twritel_relaxed(cfg, ctrl->ngd->base);\n}\n\nstatic int qcom_slim_ngd_power_up(struct qcom_slim_ngd_ctrl *ctrl)\n{\n\tenum qcom_slim_ngd_state cur_state = ctrl->state;\n\tstruct qcom_slim_ngd *ngd = ctrl->ngd;\n\tu32 laddr, rx_msgq;\n\tint timeout, ret = 0;\n\n\tif (ctrl->state == QCOM_SLIM_NGD_CTRL_DOWN) {\n\t\ttimeout = wait_for_completion_timeout(&ctrl->qmi.qmi_comp, HZ);\n\t\tif (!timeout)\n\t\t\treturn -EREMOTEIO;\n\t}\n\n\tif (ctrl->state == QCOM_SLIM_NGD_CTRL_ASLEEP ||\n\t\tctrl->state == QCOM_SLIM_NGD_CTRL_DOWN) {\n\t\tret = qcom_slim_qmi_power_request(ctrl, true);\n\t\tif (ret) {\n\t\t\tdev_err(ctrl->dev, \"SLIM QMI power request failed:%d\\n\",\n\t\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tctrl->ver = readl_relaxed(ctrl->base);\n\t \n\tctrl->ver >>= 16;\n\n\tladdr = readl_relaxed(ngd->base + NGD_STATUS);\n\tif (laddr & NGD_LADDR) {\n\t\t \n\t\tif (cur_state == QCOM_SLIM_NGD_CTRL_AWAKE) {\n\t\t\tdev_info(ctrl->dev, \"Subsys restart: ADSP active framer\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tqcom_slim_ngd_setup(ctrl);\n\t\treturn 0;\n\t}\n\n\t \n\treinit_completion(&ctrl->reconf);\n\n\twritel_relaxed(DEF_NGD_INT_MASK, ngd->base + NGD_INT_EN);\n\trx_msgq = readl_relaxed(ngd->base + NGD_RX_MSGQ_CFG);\n\n\twritel_relaxed(rx_msgq|SLIM_RX_MSGQ_TIMEOUT_VAL,\n\t\t\t\tngd->base + NGD_RX_MSGQ_CFG);\n\tqcom_slim_ngd_setup(ctrl);\n\n\ttimeout = wait_for_completion_timeout(&ctrl->reconf, HZ);\n\tif (!timeout) {\n\t\tdev_err(ctrl->dev, \"capability exchange timed-out\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic void qcom_slim_ngd_notify_slaves(struct qcom_slim_ngd_ctrl *ctrl)\n{\n\tstruct slim_device *sbdev;\n\tstruct device_node *node;\n\n\tfor_each_child_of_node(ctrl->ngd->pdev->dev.of_node, node) {\n\t\tsbdev = of_slim_get_device(&ctrl->ctrl, node);\n\t\tif (!sbdev)\n\t\t\tcontinue;\n\n\t\tif (slim_get_logical_addr(sbdev))\n\t\t\tdev_err(ctrl->dev, \"Failed to get logical address\\n\");\n\t}\n}\n\nstatic void qcom_slim_ngd_master_worker(struct work_struct *work)\n{\n\tstruct qcom_slim_ngd_ctrl *ctrl;\n\tstruct slim_msg_txn txn;\n\tstruct slim_val_inf msg = {0};\n\tint retries = 0;\n\tu8 wbuf[8];\n\tint ret = 0;\n\n\tctrl = container_of(work, struct qcom_slim_ngd_ctrl, m_work);\n\ttxn.dt = SLIM_MSG_DEST_LOGICALADDR;\n\ttxn.ec = 0;\n\ttxn.mc = SLIM_USR_MC_REPORT_SATELLITE;\n\ttxn.mt = SLIM_MSG_MT_SRC_REFERRED_USER;\n\ttxn.la = SLIM_LA_MGR;\n\twbuf[0] = SAT_MAGIC_LSB;\n\twbuf[1] = SAT_MAGIC_MSB;\n\twbuf[2] = SAT_MSG_VER;\n\twbuf[3] = SAT_MSG_PROT;\n\ttxn.msg = &msg;\n\ttxn.msg->wbuf = wbuf;\n\ttxn.msg->num_bytes = 4;\n\ttxn.rl = 8;\n\n\tdev_info(ctrl->dev, \"SLIM SAT: Rcvd master capability\\n\");\n\ncapability_retry:\n\tret = qcom_slim_ngd_xfer_msg(&ctrl->ctrl, &txn);\n\tif (!ret) {\n\t\tif (ctrl->state >= QCOM_SLIM_NGD_CTRL_ASLEEP)\n\t\t\tcomplete(&ctrl->reconf);\n\t\telse\n\t\t\tdev_err(ctrl->dev, \"unexpected state:%d\\n\",\n\t\t\t\t\t\tctrl->state);\n\n\t\tif (ctrl->state == QCOM_SLIM_NGD_CTRL_DOWN)\n\t\t\tqcom_slim_ngd_notify_slaves(ctrl);\n\n\t} else if (ret == -EIO) {\n\t\tdev_err(ctrl->dev, \"capability message NACKed, retrying\\n\");\n\t\tif (retries < INIT_MX_RETRIES) {\n\t\t\tmsleep(DEF_RETRY_MS);\n\t\t\tretries++;\n\t\t\tgoto capability_retry;\n\t\t}\n\t} else {\n\t\tdev_err(ctrl->dev, \"SLIM: capability TX failed:%d\\n\", ret);\n\t}\n}\n\nstatic int qcom_slim_ngd_update_device_status(struct device *dev, void *null)\n{\n\tslim_report_absent(to_slim_device(dev));\n\n\treturn 0;\n}\n\nstatic int qcom_slim_ngd_runtime_resume(struct device *dev)\n{\n\tstruct qcom_slim_ngd_ctrl *ctrl = dev_get_drvdata(dev);\n\tint ret = 0;\n\n\tif (!ctrl->qmi.handle)\n\t\treturn 0;\n\n\tif (ctrl->state >= QCOM_SLIM_NGD_CTRL_ASLEEP)\n\t\tret = qcom_slim_ngd_power_up(ctrl);\n\tif (ret) {\n\t\t \n\t\tif (ctrl->state != QCOM_SLIM_NGD_CTRL_DOWN)\n\t\t\tctrl->state = QCOM_SLIM_NGD_CTRL_ASLEEP;\n\t\telse\n\t\t\tdev_err(ctrl->dev, \"HW wakeup attempt during SSR\\n\");\n\t} else {\n\t\tctrl->state = QCOM_SLIM_NGD_CTRL_AWAKE;\n\t}\n\n\treturn 0;\n}\n\nstatic int qcom_slim_ngd_enable(struct qcom_slim_ngd_ctrl *ctrl, bool enable)\n{\n\tif (enable) {\n\t\tint ret = qcom_slim_qmi_init(ctrl, false);\n\n\t\tif (ret) {\n\t\t\tdev_err(ctrl->dev, \"qmi init fail, ret:%d, state:%d\\n\",\n\t\t\t\tret, ctrl->state);\n\t\t\treturn ret;\n\t\t}\n\t\t \n\t\tcomplete(&ctrl->qmi.qmi_comp);\n\t\tif (!pm_runtime_enabled(ctrl->ctrl.dev) ||\n\t\t\t !pm_runtime_suspended(ctrl->ctrl.dev))\n\t\t\tqcom_slim_ngd_runtime_resume(ctrl->ctrl.dev);\n\t\telse\n\t\t\tpm_runtime_resume(ctrl->ctrl.dev);\n\n\t\tpm_runtime_mark_last_busy(ctrl->ctrl.dev);\n\t\tpm_runtime_put(ctrl->ctrl.dev);\n\n\t\tret = slim_register_controller(&ctrl->ctrl);\n\t\tif (ret) {\n\t\t\tdev_err(ctrl->dev, \"error adding slim controller\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tdev_info(ctrl->dev, \"SLIM controller Registered\\n\");\n\t} else {\n\t\tqcom_slim_qmi_exit(ctrl);\n\t\tslim_unregister_controller(&ctrl->ctrl);\n\t}\n\n\treturn 0;\n}\n\nstatic int qcom_slim_ngd_qmi_new_server(struct qmi_handle *hdl,\n\t\t\t\t\tstruct qmi_service *service)\n{\n\tstruct qcom_slim_ngd_qmi *qmi =\n\t\tcontainer_of(hdl, struct qcom_slim_ngd_qmi, svc_event_hdl);\n\tstruct qcom_slim_ngd_ctrl *ctrl =\n\t\tcontainer_of(qmi, struct qcom_slim_ngd_ctrl, qmi);\n\n\tqmi->svc_info.sq_family = AF_QIPCRTR;\n\tqmi->svc_info.sq_node = service->node;\n\tqmi->svc_info.sq_port = service->port;\n\n\tcomplete(&ctrl->qmi_up);\n\n\treturn 0;\n}\n\nstatic void qcom_slim_ngd_qmi_del_server(struct qmi_handle *hdl,\n\t\t\t\t\t struct qmi_service *service)\n{\n\tstruct qcom_slim_ngd_qmi *qmi =\n\t\tcontainer_of(hdl, struct qcom_slim_ngd_qmi, svc_event_hdl);\n\tstruct qcom_slim_ngd_ctrl *ctrl =\n\t\tcontainer_of(qmi, struct qcom_slim_ngd_ctrl, qmi);\n\n\treinit_completion(&ctrl->qmi_up);\n\tqmi->svc_info.sq_node = 0;\n\tqmi->svc_info.sq_port = 0;\n}\n\nstatic const struct qmi_ops qcom_slim_ngd_qmi_svc_event_ops = {\n\t.new_server = qcom_slim_ngd_qmi_new_server,\n\t.del_server = qcom_slim_ngd_qmi_del_server,\n};\n\nstatic int qcom_slim_ngd_qmi_svc_event_init(struct qcom_slim_ngd_ctrl *ctrl)\n{\n\tstruct qcom_slim_ngd_qmi *qmi = &ctrl->qmi;\n\tint ret;\n\n\tret = qmi_handle_init(&qmi->svc_event_hdl, 0,\n\t\t\t\t&qcom_slim_ngd_qmi_svc_event_ops, NULL);\n\tif (ret < 0) {\n\t\tdev_err(ctrl->dev, \"qmi_handle_init failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = qmi_add_lookup(&qmi->svc_event_hdl, SLIMBUS_QMI_SVC_ID,\n\t\t\tSLIMBUS_QMI_SVC_V1, SLIMBUS_QMI_INS_ID);\n\tif (ret < 0) {\n\t\tdev_err(ctrl->dev, \"qmi_add_lookup failed: %d\\n\", ret);\n\t\tqmi_handle_release(&qmi->svc_event_hdl);\n\t}\n\treturn ret;\n}\n\nstatic void qcom_slim_ngd_qmi_svc_event_deinit(struct qcom_slim_ngd_qmi *qmi)\n{\n\tqmi_handle_release(&qmi->svc_event_hdl);\n}\n\nstatic struct platform_driver qcom_slim_ngd_driver;\n#define QCOM_SLIM_NGD_DRV_NAME\t\"qcom,slim-ngd\"\n\nstatic const struct of_device_id qcom_slim_ngd_dt_match[] = {\n\t{\n\t\t.compatible = \"qcom,slim-ngd-v1.5.0\",\n\t\t.data = &ngd_v1_5_offset_info,\n\t},{\n\t\t.compatible = \"qcom,slim-ngd-v2.1.0\",\n\t\t.data = &ngd_v1_5_offset_info,\n\t},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(of, qcom_slim_ngd_dt_match);\n\nstatic void qcom_slim_ngd_down(struct qcom_slim_ngd_ctrl *ctrl)\n{\n\tmutex_lock(&ctrl->ssr_lock);\n\tdevice_for_each_child(ctrl->ctrl.dev, NULL,\n\t\t\t      qcom_slim_ngd_update_device_status);\n\tqcom_slim_ngd_enable(ctrl, false);\n\tmutex_unlock(&ctrl->ssr_lock);\n}\n\nstatic void qcom_slim_ngd_up_worker(struct work_struct *work)\n{\n\tstruct qcom_slim_ngd_ctrl *ctrl;\n\n\tctrl = container_of(work, struct qcom_slim_ngd_ctrl, ngd_up_work);\n\n\t \n\twait_for_completion_interruptible(&ctrl->qmi_up);\n\n\tmutex_lock(&ctrl->ssr_lock);\n\tqcom_slim_ngd_enable(ctrl, true);\n\tmutex_unlock(&ctrl->ssr_lock);\n}\n\nstatic int qcom_slim_ngd_ssr_pdr_notify(struct qcom_slim_ngd_ctrl *ctrl,\n\t\t\t\t\tunsigned long action)\n{\n\tswitch (action) {\n\tcase QCOM_SSR_BEFORE_SHUTDOWN:\n\tcase SERVREG_SERVICE_STATE_DOWN:\n\t\t \n\t\tmutex_lock(&ctrl->tx_lock);\n\t\tif (ctrl->state != QCOM_SLIM_NGD_CTRL_DOWN) {\n\t\t\tpm_runtime_get_noresume(ctrl->ctrl.dev);\n\t\t\tctrl->state = QCOM_SLIM_NGD_CTRL_DOWN;\n\t\t\tqcom_slim_ngd_down(ctrl);\n\t\t\tqcom_slim_ngd_exit_dma(ctrl);\n\t\t}\n\t\tmutex_unlock(&ctrl->tx_lock);\n\t\tbreak;\n\tcase QCOM_SSR_AFTER_POWERUP:\n\tcase SERVREG_SERVICE_STATE_UP:\n\t\tschedule_work(&ctrl->ngd_up_work);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_OK;\n}\n\nstatic int qcom_slim_ngd_ssr_notify(struct notifier_block *nb,\n\t\t\t\t    unsigned long action,\n\t\t\t\t    void *data)\n{\n\tstruct qcom_slim_ngd_ctrl *ctrl = container_of(nb,\n\t\t\t\t\t       struct qcom_slim_ngd_ctrl, nb);\n\n\treturn qcom_slim_ngd_ssr_pdr_notify(ctrl, action);\n}\n\nstatic void slim_pd_status(int state, char *svc_path, void *priv)\n{\n\tstruct qcom_slim_ngd_ctrl *ctrl = (struct qcom_slim_ngd_ctrl *)priv;\n\n\tqcom_slim_ngd_ssr_pdr_notify(ctrl, state);\n}\nstatic int of_qcom_slim_ngd_register(struct device *parent,\n\t\t\t\t     struct qcom_slim_ngd_ctrl *ctrl)\n{\n\tconst struct ngd_reg_offset_data *data;\n\tstruct qcom_slim_ngd *ngd;\n\tconst struct of_device_id *match;\n\tstruct device_node *node;\n\tu32 id;\n\tint ret;\n\n\tmatch = of_match_node(qcom_slim_ngd_dt_match, parent->of_node);\n\tdata = match->data;\n\tfor_each_available_child_of_node(parent->of_node, node) {\n\t\tif (of_property_read_u32(node, \"reg\", &id))\n\t\t\tcontinue;\n\n\t\tngd = kzalloc(sizeof(*ngd), GFP_KERNEL);\n\t\tif (!ngd) {\n\t\t\tof_node_put(node);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tngd->pdev = platform_device_alloc(QCOM_SLIM_NGD_DRV_NAME, id);\n\t\tif (!ngd->pdev) {\n\t\t\tkfree(ngd);\n\t\t\tof_node_put(node);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tngd->id = id;\n\t\tngd->pdev->dev.parent = parent;\n\n\t\tret = driver_set_override(&ngd->pdev->dev,\n\t\t\t\t\t  &ngd->pdev->driver_override,\n\t\t\t\t\t  QCOM_SLIM_NGD_DRV_NAME,\n\t\t\t\t\t  strlen(QCOM_SLIM_NGD_DRV_NAME));\n\t\tif (ret) {\n\t\t\tplatform_device_put(ngd->pdev);\n\t\t\tkfree(ngd);\n\t\t\tof_node_put(node);\n\t\t\treturn ret;\n\t\t}\n\t\tngd->pdev->dev.of_node = node;\n\t\tctrl->ngd = ngd;\n\n\t\tret = platform_device_add(ngd->pdev);\n\t\tif (ret) {\n\t\t\tplatform_device_put(ngd->pdev);\n\t\t\tkfree(ngd);\n\t\t\tof_node_put(node);\n\t\t\treturn ret;\n\t\t}\n\t\tngd->base = ctrl->base + ngd->id * data->offset +\n\t\t\t\t\t(ngd->id - 1) * data->size;\n\n\t\treturn 0;\n\t}\n\n\treturn -ENODEV;\n}\n\nstatic int qcom_slim_ngd_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct qcom_slim_ngd_ctrl *ctrl = dev_get_drvdata(dev->parent);\n\tint ret;\n\n\tctrl->ctrl.dev = dev;\n\n\tplatform_set_drvdata(pdev, ctrl);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_set_autosuspend_delay(dev, QCOM_SLIM_NGD_AUTOSUSPEND);\n\tpm_runtime_set_suspended(dev);\n\tpm_runtime_enable(dev);\n\tpm_runtime_get_noresume(dev);\n\tret = qcom_slim_ngd_qmi_svc_event_init(ctrl);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"QMI service registration failed:%d\", ret);\n\t\treturn ret;\n\t}\n\n\tINIT_WORK(&ctrl->m_work, qcom_slim_ngd_master_worker);\n\tINIT_WORK(&ctrl->ngd_up_work, qcom_slim_ngd_up_worker);\n\tctrl->mwq = create_singlethread_workqueue(\"ngd_master\");\n\tif (!ctrl->mwq) {\n\t\tdev_err(&pdev->dev, \"Failed to start master worker\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto wq_err;\n\t}\n\n\treturn 0;\nwq_err:\n\tqcom_slim_ngd_qmi_svc_event_deinit(&ctrl->qmi);\n\tif (ctrl->mwq)\n\t\tdestroy_workqueue(ctrl->mwq);\n\n\treturn ret;\n}\n\nstatic int qcom_slim_ngd_ctrl_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct qcom_slim_ngd_ctrl *ctrl;\n\tint ret;\n\tstruct pdr_service *pds;\n\n\tctrl = devm_kzalloc(dev, sizeof(*ctrl), GFP_KERNEL);\n\tif (!ctrl)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, ctrl);\n\n\tctrl->base = devm_platform_get_and_ioremap_resource(pdev, 0, NULL);\n\tif (IS_ERR(ctrl->base))\n\t\treturn PTR_ERR(ctrl->base);\n\n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = devm_request_irq(dev, ret, qcom_slim_ngd_interrupt,\n\t\t\t       IRQF_TRIGGER_HIGH, \"slim-ngd\", ctrl);\n\tif (ret)\n\t\treturn dev_err_probe(&pdev->dev, ret, \"request IRQ failed\\n\");\n\n\tctrl->nb.notifier_call = qcom_slim_ngd_ssr_notify;\n\tctrl->notifier = qcom_register_ssr_notifier(\"lpass\", &ctrl->nb);\n\tif (IS_ERR(ctrl->notifier))\n\t\treturn PTR_ERR(ctrl->notifier);\n\n\tctrl->dev = dev;\n\tctrl->framer.rootfreq = SLIM_ROOT_FREQ >> 3;\n\tctrl->framer.superfreq =\n\t\tctrl->framer.rootfreq / SLIM_CL_PER_SUPERFRAME_DIV8;\n\n\tctrl->ctrl.a_framer = &ctrl->framer;\n\tctrl->ctrl.clkgear = SLIM_MAX_CLK_GEAR;\n\tctrl->ctrl.get_laddr = qcom_slim_ngd_get_laddr;\n\tctrl->ctrl.enable_stream = qcom_slim_ngd_enable_stream;\n\tctrl->ctrl.xfer_msg = qcom_slim_ngd_xfer_msg;\n\tctrl->ctrl.wakeup = NULL;\n\tctrl->state = QCOM_SLIM_NGD_CTRL_DOWN;\n\n\tmutex_init(&ctrl->tx_lock);\n\tmutex_init(&ctrl->ssr_lock);\n\tspin_lock_init(&ctrl->tx_buf_lock);\n\tinit_completion(&ctrl->reconf);\n\tinit_completion(&ctrl->qmi.qmi_comp);\n\tinit_completion(&ctrl->qmi_up);\n\n\tctrl->pdr = pdr_handle_alloc(slim_pd_status, ctrl);\n\tif (IS_ERR(ctrl->pdr)) {\n\t\tret = dev_err_probe(dev, PTR_ERR(ctrl->pdr),\n\t\t\t\t    \"Failed to init PDR handle\\n\");\n\t\tgoto err_pdr_alloc;\n\t}\n\n\tpds = pdr_add_lookup(ctrl->pdr, \"avs/audio\", \"msm/adsp/audio_pd\");\n\tif (IS_ERR(pds) && PTR_ERR(pds) != -EALREADY) {\n\t\tret = dev_err_probe(dev, PTR_ERR(pds), \"pdr add lookup failed\\n\");\n\t\tgoto err_pdr_lookup;\n\t}\n\n\tplatform_driver_register(&qcom_slim_ngd_driver);\n\treturn of_qcom_slim_ngd_register(dev, ctrl);\n\nerr_pdr_alloc:\n\tqcom_unregister_ssr_notifier(ctrl->notifier, &ctrl->nb);\n\nerr_pdr_lookup:\n\tpdr_handle_release(ctrl->pdr);\n\n\treturn ret;\n}\n\nstatic int qcom_slim_ngd_ctrl_remove(struct platform_device *pdev)\n{\n\tplatform_driver_unregister(&qcom_slim_ngd_driver);\n\n\treturn 0;\n}\n\nstatic int qcom_slim_ngd_remove(struct platform_device *pdev)\n{\n\tstruct qcom_slim_ngd_ctrl *ctrl = platform_get_drvdata(pdev);\n\n\tpm_runtime_disable(&pdev->dev);\n\tpdr_handle_release(ctrl->pdr);\n\tqcom_unregister_ssr_notifier(ctrl->notifier, &ctrl->nb);\n\tqcom_slim_ngd_enable(ctrl, false);\n\tqcom_slim_ngd_exit_dma(ctrl);\n\tqcom_slim_ngd_qmi_svc_event_deinit(&ctrl->qmi);\n\tif (ctrl->mwq)\n\t\tdestroy_workqueue(ctrl->mwq);\n\n\tkfree(ctrl->ngd);\n\tctrl->ngd = NULL;\n\treturn 0;\n}\n\nstatic int __maybe_unused qcom_slim_ngd_runtime_idle(struct device *dev)\n{\n\tstruct qcom_slim_ngd_ctrl *ctrl = dev_get_drvdata(dev);\n\n\tif (ctrl->state == QCOM_SLIM_NGD_CTRL_AWAKE)\n\t\tctrl->state = QCOM_SLIM_NGD_CTRL_IDLE;\n\tpm_request_autosuspend(dev);\n\treturn -EAGAIN;\n}\n\nstatic int __maybe_unused qcom_slim_ngd_runtime_suspend(struct device *dev)\n{\n\tstruct qcom_slim_ngd_ctrl *ctrl = dev_get_drvdata(dev);\n\tint ret = 0;\n\n\tqcom_slim_ngd_exit_dma(ctrl);\n\tif (!ctrl->qmi.handle)\n\t\treturn 0;\n\n\tret = qcom_slim_qmi_power_request(ctrl, false);\n\tif (ret && ret != -EBUSY)\n\t\tdev_info(ctrl->dev, \"slim resource not idle:%d\\n\", ret);\n\tif (!ret || ret == -ETIMEDOUT)\n\t\tctrl->state = QCOM_SLIM_NGD_CTRL_ASLEEP;\n\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops qcom_slim_ngd_dev_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n\tSET_RUNTIME_PM_OPS(\n\t\tqcom_slim_ngd_runtime_suspend,\n\t\tqcom_slim_ngd_runtime_resume,\n\t\tqcom_slim_ngd_runtime_idle\n\t)\n};\n\nstatic struct platform_driver qcom_slim_ngd_ctrl_driver = {\n\t.probe = qcom_slim_ngd_ctrl_probe,\n\t.remove = qcom_slim_ngd_ctrl_remove,\n\t.driver\t= {\n\t\t.name = \"qcom,slim-ngd-ctrl\",\n\t\t.of_match_table = qcom_slim_ngd_dt_match,\n\t},\n};\n\nstatic struct platform_driver qcom_slim_ngd_driver = {\n\t.probe = qcom_slim_ngd_probe,\n\t.remove = qcom_slim_ngd_remove,\n\t.driver\t= {\n\t\t.name = QCOM_SLIM_NGD_DRV_NAME,\n\t\t.pm = &qcom_slim_ngd_dev_pm_ops,\n\t},\n};\n\nmodule_platform_driver(qcom_slim_ngd_ctrl_driver);\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Qualcomm SLIMBus NGD controller\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}