{
  "module_name": "qcom-ctrl.c",
  "hash_id": "d9836d2f8f3de20f5ad801260c0f86e72e1718e0fafc0015ede60eaf43a5c67c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/slimbus/qcom-ctrl.c",
  "human_readable_source": "\n \n\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/delay.h>\n#include <linux/clk.h>\n#include <linux/of.h>\n#include <linux/pm_runtime.h>\n#include \"slimbus.h\"\n\n \n#define\tMGR_CFG\t\t0x200\n#define\tMGR_STATUS\t0x204\n#define\tMGR_INT_EN\t0x210\n#define\tMGR_INT_STAT\t0x214\n#define\tMGR_INT_CLR\t0x218\n#define\tMGR_TX_MSG\t0x230\n#define\tMGR_RX_MSG\t0x270\n#define\tMGR_IE_STAT\t0x2F0\n#define\tMGR_VE_STAT\t0x300\n#define\tMGR_CFG_ENABLE\t1\n\n \n#define\tFRM_CFG\t\t0x400\n#define\tFRM_STAT\t0x404\n#define\tFRM_INT_EN\t0x410\n#define\tFRM_INT_STAT\t0x414\n#define\tFRM_INT_CLR\t0x418\n#define\tFRM_WAKEUP\t0x41C\n#define\tFRM_CLKCTL_DONE\t0x420\n#define\tFRM_IE_STAT\t0x430\n#define\tFRM_VE_STAT\t0x440\n\n \n#define\tINTF_CFG\t0x600\n#define\tINTF_STAT\t0x604\n#define\tINTF_INT_EN\t0x610\n#define\tINTF_INT_STAT\t0x614\n#define\tINTF_INT_CLR\t0x618\n#define\tINTF_IE_STAT\t0x630\n#define\tINTF_VE_STAT\t0x640\n\n \n#define\tMGR_INT_TX_NACKED_2\tBIT(25)\n#define\tMGR_INT_MSG_BUF_CONTE\tBIT(26)\n#define\tMGR_INT_RX_MSG_RCVD\tBIT(30)\n#define\tMGR_INT_TX_MSG_SENT\tBIT(31)\n\n \n#define\tFRM_ACTIVE\t1\n#define\tCLK_GEAR\t7\n#define\tROOT_FREQ\t11\n#define\tREF_CLK_GEAR\t15\n#define\tINTR_WAKE\t19\n\n#define SLIM_MSG_ASM_FIRST_WORD(l, mt, mc, dt, ad) \\\n\t\t((l) | ((mt) << 5) | ((mc) << 8) | ((dt) << 15) | ((ad) << 16))\n\n#define SLIM_ROOT_FREQ 24576000\n#define QCOM_SLIM_AUTOSUSPEND 1000\n\n \n#define SLIM_MSGQ_BUF_LEN\t40\n#define QCOM_TX_MSGS 2\n#define QCOM_RX_MSGS\t8\n#define QCOM_BUF_ALLOC_RETRIES\t10\n\n#define CFG_PORT(r, v) ((v) ? CFG_PORT_V2(r) : CFG_PORT_V1(r))\n\n \n#define CFG_PORT_V2(r) ((r ## _V2))\n#define\tCOMP_CFG_V2\t\t4\n#define\tCOMP_TRUST_CFG_V2\t0x3000\n\n \n#define CFG_PORT_V1(r) ((r ## _V1))\n#define\tCOMP_CFG_V1\t\t0\n#define\tCOMP_TRUST_CFG_V1\t0x14\n\n \n#define EE_MGR_RSC_GRP\t(1 << 10)\n#define EE_NGD_2\t(2 << 6)\n#define EE_NGD_1\t0\n\nstruct slim_ctrl_buf {\n\tvoid\t\t*base;\n\tspinlock_t\tlock;\n\tint\t\thead;\n\tint\t\ttail;\n\tint\t\tsl_sz;\n\tint\t\tn;\n};\n\nstruct qcom_slim_ctrl {\n\tstruct slim_controller  ctrl;\n\tstruct slim_framer\tframer;\n\tstruct device\t\t*dev;\n\tvoid __iomem\t\t*base;\n\tvoid __iomem\t\t*slew_reg;\n\n\tstruct slim_ctrl_buf\trx;\n\tstruct slim_ctrl_buf\ttx;\n\n\tstruct completion\t**wr_comp;\n\tint\t\t\tirq;\n\tstruct workqueue_struct *rxwq;\n\tstruct work_struct\twd;\n\tstruct clk\t\t*rclk;\n\tstruct clk\t\t*hclk;\n};\n\nstatic void qcom_slim_queue_tx(struct qcom_slim_ctrl *ctrl, void *buf,\n\t\t\t       u8 len, u32 tx_reg)\n{\n\tint count = (len + 3) >> 2;\n\n\t__iowrite32_copy(ctrl->base + tx_reg, buf, count);\n\n\t \n\tmb();\n}\n\nstatic void *slim_alloc_rxbuf(struct qcom_slim_ctrl *ctrl)\n{\n\tunsigned long flags;\n\tint idx;\n\n\tspin_lock_irqsave(&ctrl->rx.lock, flags);\n\tif ((ctrl->rx.tail + 1) % ctrl->rx.n == ctrl->rx.head) {\n\t\tspin_unlock_irqrestore(&ctrl->rx.lock, flags);\n\t\tdev_err(ctrl->dev, \"RX QUEUE full!\");\n\t\treturn NULL;\n\t}\n\tidx = ctrl->rx.tail;\n\tctrl->rx.tail = (ctrl->rx.tail + 1) % ctrl->rx.n;\n\tspin_unlock_irqrestore(&ctrl->rx.lock, flags);\n\n\treturn ctrl->rx.base + (idx * ctrl->rx.sl_sz);\n}\n\nstatic void slim_ack_txn(struct qcom_slim_ctrl *ctrl, int err)\n{\n\tstruct completion *comp;\n\tunsigned long flags;\n\tint idx;\n\n\tspin_lock_irqsave(&ctrl->tx.lock, flags);\n\tidx = ctrl->tx.head;\n\tctrl->tx.head = (ctrl->tx.head + 1) % ctrl->tx.n;\n\tspin_unlock_irqrestore(&ctrl->tx.lock, flags);\n\n\tcomp = ctrl->wr_comp[idx];\n\tctrl->wr_comp[idx] = NULL;\n\n\tcomplete(comp);\n}\n\nstatic irqreturn_t qcom_slim_handle_tx_irq(struct qcom_slim_ctrl *ctrl,\n\t\t\t\t\t   u32 stat)\n{\n\tint err = 0;\n\n\tif (stat & MGR_INT_TX_MSG_SENT)\n\t\twritel_relaxed(MGR_INT_TX_MSG_SENT,\n\t\t\t       ctrl->base + MGR_INT_CLR);\n\n\tif (stat & MGR_INT_TX_NACKED_2) {\n\t\tu32 mgr_stat = readl_relaxed(ctrl->base + MGR_STATUS);\n\t\tu32 mgr_ie_stat = readl_relaxed(ctrl->base + MGR_IE_STAT);\n\t\tu32 frm_stat = readl_relaxed(ctrl->base + FRM_STAT);\n\t\tu32 frm_cfg = readl_relaxed(ctrl->base + FRM_CFG);\n\t\tu32 frm_intr_stat = readl_relaxed(ctrl->base + FRM_INT_STAT);\n\t\tu32 frm_ie_stat = readl_relaxed(ctrl->base + FRM_IE_STAT);\n\t\tu32 intf_stat = readl_relaxed(ctrl->base + INTF_STAT);\n\t\tu32 intf_intr_stat = readl_relaxed(ctrl->base + INTF_INT_STAT);\n\t\tu32 intf_ie_stat = readl_relaxed(ctrl->base + INTF_IE_STAT);\n\n\t\twritel_relaxed(MGR_INT_TX_NACKED_2, ctrl->base + MGR_INT_CLR);\n\n\t\tdev_err(ctrl->dev, \"TX Nack MGR:int:0x%x, stat:0x%x\\n\",\n\t\t\tstat, mgr_stat);\n\t\tdev_err(ctrl->dev, \"TX Nack MGR:ie:0x%x\\n\", mgr_ie_stat);\n\t\tdev_err(ctrl->dev, \"TX Nack FRM:int:0x%x, stat:0x%x\\n\",\n\t\t\tfrm_intr_stat, frm_stat);\n\t\tdev_err(ctrl->dev, \"TX Nack FRM:cfg:0x%x, ie:0x%x\\n\",\n\t\t\tfrm_cfg, frm_ie_stat);\n\t\tdev_err(ctrl->dev, \"TX Nack INTF:intr:0x%x, stat:0x%x\\n\",\n\t\t\tintf_intr_stat, intf_stat);\n\t\tdev_err(ctrl->dev, \"TX Nack INTF:ie:0x%x\\n\",\n\t\t\tintf_ie_stat);\n\t\terr = -ENOTCONN;\n\t}\n\n\tslim_ack_txn(ctrl, err);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t qcom_slim_handle_rx_irq(struct qcom_slim_ctrl *ctrl,\n\t\t\t\t\t   u32 stat)\n{\n\tu32 *rx_buf, pkt[10];\n\tbool q_rx = false;\n\tu8 mc, mt, len;\n\n\tpkt[0] = readl_relaxed(ctrl->base + MGR_RX_MSG);\n\tmt = SLIM_HEADER_GET_MT(pkt[0]);\n\tlen = SLIM_HEADER_GET_RL(pkt[0]);\n\tmc = SLIM_HEADER_GET_MC(pkt[0]>>8);\n\n\t \n\tif (mt == SLIM_MSG_MT_CORE && mc == SLIM_MSG_MC_REPORT_PRESENT) {\n\t\trx_buf = (u32 *)slim_alloc_rxbuf(ctrl);\n\t\tif (!rx_buf) {\n\t\t\tdev_err(ctrl->dev, \"dropping RX:0x%x due to RX full\\n\",\n\t\t\t\t\tpkt[0]);\n\t\t\tgoto rx_ret_irq;\n\t\t}\n\t\trx_buf[0] = pkt[0];\n\n\t} else {\n\t\trx_buf = pkt;\n\t}\n\n\t__ioread32_copy(rx_buf + 1, ctrl->base + MGR_RX_MSG + 4,\n\t\t\tDIV_ROUND_UP(len, 4));\n\n\tswitch (mc) {\n\n\tcase SLIM_MSG_MC_REPORT_PRESENT:\n\t\tq_rx = true;\n\t\tbreak;\n\tcase SLIM_MSG_MC_REPLY_INFORMATION:\n\tcase SLIM_MSG_MC_REPLY_VALUE:\n\t\tslim_msg_response(&ctrl->ctrl, (u8 *)(rx_buf + 1),\n\t\t\t\t  (u8)(*rx_buf >> 24), (len - 4));\n\t\tbreak;\n\tdefault:\n\t\tdev_err(ctrl->dev, \"unsupported MC,%x MT:%x\\n\",\n\t\t\tmc, mt);\n\t\tbreak;\n\t}\nrx_ret_irq:\n\twritel(MGR_INT_RX_MSG_RCVD, ctrl->base +\n\t\t       MGR_INT_CLR);\n\tif (q_rx)\n\t\tqueue_work(ctrl->rxwq, &ctrl->wd);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t qcom_slim_interrupt(int irq, void *d)\n{\n\tstruct qcom_slim_ctrl *ctrl = d;\n\tu32 stat = readl_relaxed(ctrl->base + MGR_INT_STAT);\n\tint ret = IRQ_NONE;\n\n\tif (stat & MGR_INT_TX_MSG_SENT || stat & MGR_INT_TX_NACKED_2)\n\t\tret = qcom_slim_handle_tx_irq(ctrl, stat);\n\n\tif (stat & MGR_INT_RX_MSG_RCVD)\n\t\tret = qcom_slim_handle_rx_irq(ctrl, stat);\n\n\treturn ret;\n}\n\nstatic int qcom_clk_pause_wakeup(struct slim_controller *sctrl)\n{\n\tstruct qcom_slim_ctrl *ctrl = dev_get_drvdata(sctrl->dev);\n\n\tclk_prepare_enable(ctrl->hclk);\n\tclk_prepare_enable(ctrl->rclk);\n\tenable_irq(ctrl->irq);\n\n\twritel_relaxed(1, ctrl->base + FRM_WAKEUP);\n\t \n\tmb();\n\t \n\tusleep_range(1250, 2500);\n\treturn 0;\n}\n\nstatic void *slim_alloc_txbuf(struct qcom_slim_ctrl *ctrl,\n\t\t\t      struct slim_msg_txn *txn,\n\t\t\t      struct completion *done)\n{\n\tunsigned long flags;\n\tint idx;\n\n\tspin_lock_irqsave(&ctrl->tx.lock, flags);\n\tif (((ctrl->tx.head + 1) % ctrl->tx.n) == ctrl->tx.tail) {\n\t\tspin_unlock_irqrestore(&ctrl->tx.lock, flags);\n\t\tdev_err(ctrl->dev, \"controller TX buf unavailable\");\n\t\treturn NULL;\n\t}\n\tidx = ctrl->tx.tail;\n\tctrl->wr_comp[idx] = done;\n\tctrl->tx.tail = (ctrl->tx.tail + 1) % ctrl->tx.n;\n\n\tspin_unlock_irqrestore(&ctrl->tx.lock, flags);\n\n\treturn ctrl->tx.base + (idx * ctrl->tx.sl_sz);\n}\n\n\nstatic int qcom_xfer_msg(struct slim_controller *sctrl,\n\t\t\t struct slim_msg_txn *txn)\n{\n\tstruct qcom_slim_ctrl *ctrl = dev_get_drvdata(sctrl->dev);\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tvoid *pbuf = slim_alloc_txbuf(ctrl, txn, &done);\n\tunsigned long ms = txn->rl + HZ;\n\tu8 *puc;\n\tint ret = 0, timeout, retries = QCOM_BUF_ALLOC_RETRIES;\n\tu8 la = txn->la;\n\tu32 *head;\n\t \n\ttxn->rl--;\n\n\t \n\tif (!pbuf) {\n\t\twhile (retries--) {\n\t\t\tusleep_range(10000, 15000);\n\t\t\tpbuf = slim_alloc_txbuf(ctrl, txn, &done);\n\t\t\tif (pbuf)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (retries < 0 && !pbuf)\n\t\treturn -ENOMEM;\n\n\tpuc = (u8 *)pbuf;\n\thead = (u32 *)pbuf;\n\n\tif (txn->dt == SLIM_MSG_DEST_LOGICALADDR) {\n\t\t*head = SLIM_MSG_ASM_FIRST_WORD(txn->rl, txn->mt,\n\t\t\t\t\t\ttxn->mc, 0, la);\n\t\tpuc += 3;\n\t} else {\n\t\t*head = SLIM_MSG_ASM_FIRST_WORD(txn->rl, txn->mt,\n\t\t\t\t\t\ttxn->mc, 1, la);\n\t\tpuc += 2;\n\t}\n\n\tif (slim_tid_txn(txn->mt, txn->mc))\n\t\t*(puc++) = txn->tid;\n\n\tif (slim_ec_txn(txn->mt, txn->mc)) {\n\t\t*(puc++) = (txn->ec & 0xFF);\n\t\t*(puc++) = (txn->ec >> 8) & 0xFF;\n\t}\n\n\tif (txn->msg && txn->msg->wbuf)\n\t\tmemcpy(puc, txn->msg->wbuf, txn->msg->num_bytes);\n\n\tqcom_slim_queue_tx(ctrl, head, txn->rl, MGR_TX_MSG);\n\ttimeout = wait_for_completion_timeout(&done, msecs_to_jiffies(ms));\n\n\tif (!timeout) {\n\t\tdev_err(ctrl->dev, \"TX timed out:MC:0x%x,mt:0x%x\", txn->mc,\n\t\t\t\t\ttxn->mt);\n\t\tret = -ETIMEDOUT;\n\t}\n\n\treturn ret;\n\n}\n\nstatic int qcom_set_laddr(struct slim_controller *sctrl,\n\t\t\t\tstruct slim_eaddr *ead, u8 laddr)\n{\n\tstruct qcom_slim_ctrl *ctrl = dev_get_drvdata(sctrl->dev);\n\tstruct {\n\t\t__be16 manf_id;\n\t\t__be16 prod_code;\n\t\tu8 dev_index;\n\t\tu8 instance;\n\t\tu8 laddr;\n\t} __packed p;\n\tstruct slim_val_inf msg = {0};\n\tDEFINE_SLIM_EDEST_TXN(txn, SLIM_MSG_MC_ASSIGN_LOGICAL_ADDRESS,\n\t\t\t      10, laddr, &msg);\n\tint ret;\n\n\tp.manf_id = cpu_to_be16(ead->manf_id);\n\tp.prod_code = cpu_to_be16(ead->prod_code);\n\tp.dev_index = ead->dev_index;\n\tp.instance = ead->instance;\n\tp.laddr = laddr;\n\n\tmsg.wbuf = (void *)&p;\n\tmsg.num_bytes = 7;\n\tret = slim_do_transfer(&ctrl->ctrl, &txn);\n\n\tif (ret)\n\t\tdev_err(ctrl->dev, \"set LA:0x%x failed:ret:%d\\n\",\n\t\t\t\t  laddr, ret);\n\treturn ret;\n}\n\nstatic int slim_get_current_rxbuf(struct qcom_slim_ctrl *ctrl, void *buf)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctrl->rx.lock, flags);\n\tif (ctrl->rx.tail == ctrl->rx.head) {\n\t\tspin_unlock_irqrestore(&ctrl->rx.lock, flags);\n\t\treturn -ENODATA;\n\t}\n\tmemcpy(buf, ctrl->rx.base + (ctrl->rx.head * ctrl->rx.sl_sz),\n\t\t\t\tctrl->rx.sl_sz);\n\n\tctrl->rx.head = (ctrl->rx.head + 1) % ctrl->rx.n;\n\tspin_unlock_irqrestore(&ctrl->rx.lock, flags);\n\n\treturn 0;\n}\n\nstatic void qcom_slim_rxwq(struct work_struct *work)\n{\n\tu8 buf[SLIM_MSGQ_BUF_LEN];\n\tu8 mc, mt;\n\tint ret;\n\tstruct qcom_slim_ctrl *ctrl = container_of(work, struct qcom_slim_ctrl,\n\t\t\t\t\t\t wd);\n\n\twhile ((slim_get_current_rxbuf(ctrl, buf)) != -ENODATA) {\n\t\tmt = SLIM_HEADER_GET_MT(buf[0]);\n\t\tmc = SLIM_HEADER_GET_MC(buf[1]);\n\t\tif (mt == SLIM_MSG_MT_CORE &&\n\t\t\tmc == SLIM_MSG_MC_REPORT_PRESENT) {\n\t\t\tstruct slim_eaddr ea;\n\t\t\tu8 laddr;\n\n\t\t\tea.manf_id = be16_to_cpup((__be16 *)&buf[2]);\n\t\t\tea.prod_code = be16_to_cpup((__be16 *)&buf[4]);\n\t\t\tea.dev_index = buf[6];\n\t\t\tea.instance = buf[7];\n\n\t\t\tret = slim_device_report_present(&ctrl->ctrl, &ea,\n\t\t\t\t\t\t\t &laddr);\n\t\t\tif (ret < 0)\n\t\t\t\tdev_err(ctrl->dev, \"assign laddr failed:%d\\n\",\n\t\t\t\t\tret);\n\t\t} else {\n\t\t\tdev_err(ctrl->dev, \"unexpected message:mc:%x, mt:%x\\n\",\n\t\t\t\tmc, mt);\n\t\t}\n\t}\n}\n\nstatic void qcom_slim_prg_slew(struct platform_device *pdev,\n\t\t\t\tstruct qcom_slim_ctrl *ctrl)\n{\n\tif (!ctrl->slew_reg) {\n\t\t \n\t\tctrl->slew_reg = devm_platform_ioremap_resource_byname(pdev, \"slew\");\n\t\tif (IS_ERR(ctrl->slew_reg))\n\t\t\treturn;\n\t}\n\n\twritel_relaxed(1, ctrl->slew_reg);\n\t \n\twmb();\n}\n\nstatic int qcom_slim_probe(struct platform_device *pdev)\n{\n\tstruct qcom_slim_ctrl *ctrl;\n\tstruct slim_controller *sctrl;\n\tint ret, ver;\n\n\tctrl = devm_kzalloc(&pdev->dev, sizeof(*ctrl), GFP_KERNEL);\n\tif (!ctrl)\n\t\treturn -ENOMEM;\n\n\tctrl->hclk = devm_clk_get(&pdev->dev, \"iface\");\n\tif (IS_ERR(ctrl->hclk))\n\t\treturn PTR_ERR(ctrl->hclk);\n\n\tctrl->rclk = devm_clk_get(&pdev->dev, \"core\");\n\tif (IS_ERR(ctrl->rclk))\n\t\treturn PTR_ERR(ctrl->rclk);\n\n\tret = clk_set_rate(ctrl->rclk, SLIM_ROOT_FREQ);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"ref-clock set-rate failed:%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tctrl->irq = platform_get_irq(pdev, 0);\n\tif (ctrl->irq < 0)\n\t\treturn ctrl->irq;\n\n\tsctrl = &ctrl->ctrl;\n\tsctrl->dev = &pdev->dev;\n\tctrl->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, ctrl);\n\tdev_set_drvdata(ctrl->dev, ctrl);\n\n\tctrl->base = devm_platform_ioremap_resource_byname(pdev, \"ctrl\");\n\tif (IS_ERR(ctrl->base))\n\t\treturn PTR_ERR(ctrl->base);\n\n\tsctrl->set_laddr = qcom_set_laddr;\n\tsctrl->xfer_msg = qcom_xfer_msg;\n\tsctrl->wakeup =  qcom_clk_pause_wakeup;\n\tctrl->tx.n = QCOM_TX_MSGS;\n\tctrl->tx.sl_sz = SLIM_MSGQ_BUF_LEN;\n\tctrl->rx.n = QCOM_RX_MSGS;\n\tctrl->rx.sl_sz = SLIM_MSGQ_BUF_LEN;\n\tctrl->wr_comp = kcalloc(QCOM_TX_MSGS, sizeof(struct completion *),\n\t\t\t\tGFP_KERNEL);\n\tif (!ctrl->wr_comp)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&ctrl->rx.lock);\n\tspin_lock_init(&ctrl->tx.lock);\n\tINIT_WORK(&ctrl->wd, qcom_slim_rxwq);\n\tctrl->rxwq = create_singlethread_workqueue(\"qcom_slim_rx\");\n\tif (!ctrl->rxwq) {\n\t\tdev_err(ctrl->dev, \"Failed to start Rx WQ\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tctrl->framer.rootfreq = SLIM_ROOT_FREQ / 8;\n\tctrl->framer.superfreq =\n\t\tctrl->framer.rootfreq / SLIM_CL_PER_SUPERFRAME_DIV8;\n\tsctrl->a_framer = &ctrl->framer;\n\tsctrl->clkgear = SLIM_MAX_CLK_GEAR;\n\n\tqcom_slim_prg_slew(pdev, ctrl);\n\n\tret = devm_request_irq(&pdev->dev, ctrl->irq, qcom_slim_interrupt,\n\t\t\t\tIRQF_TRIGGER_HIGH, \"qcom_slim_irq\", ctrl);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"request IRQ failed\\n\");\n\t\tgoto err_request_irq_failed;\n\t}\n\n\tret = clk_prepare_enable(ctrl->hclk);\n\tif (ret)\n\t\tgoto err_hclk_enable_failed;\n\n\tret = clk_prepare_enable(ctrl->rclk);\n\tif (ret)\n\t\tgoto err_rclk_enable_failed;\n\n\tctrl->tx.base = devm_kcalloc(&pdev->dev, ctrl->tx.n, ctrl->tx.sl_sz,\n\t\t\t\t     GFP_KERNEL);\n\tif (!ctrl->tx.base) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tctrl->rx.base = devm_kcalloc(&pdev->dev,ctrl->rx.n, ctrl->rx.sl_sz,\n\t\t\t\t     GFP_KERNEL);\n\tif (!ctrl->rx.base) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t \n\tret = slim_register_controller(&ctrl->ctrl);\n\tif (ret) {\n\t\tdev_err(ctrl->dev, \"error adding controller\\n\");\n\t\tgoto err;\n\t}\n\n\tver = readl_relaxed(ctrl->base);\n\t \n\tver >>= 16;\n\t \n\twritel(1, ctrl->base + CFG_PORT(COMP_CFG, ver));\n\twritel((EE_MGR_RSC_GRP | EE_NGD_2 | EE_NGD_1),\n\t\t\t\tctrl->base + CFG_PORT(COMP_TRUST_CFG, ver));\n\n\twritel((MGR_INT_TX_NACKED_2 |\n\t\t\tMGR_INT_MSG_BUF_CONTE | MGR_INT_RX_MSG_RCVD |\n\t\t\tMGR_INT_TX_MSG_SENT), ctrl->base + MGR_INT_EN);\n\twritel(1, ctrl->base + MGR_CFG);\n\t \n\twritel((1 << INTR_WAKE) | (0xA << REF_CLK_GEAR) |\n\t\t(0xA << CLK_GEAR) | (1 << ROOT_FREQ) | (1 << FRM_ACTIVE) | 1,\n\t\tctrl->base + FRM_CFG);\n\twritel(MGR_CFG_ENABLE, ctrl->base + MGR_CFG);\n\twritel(1, ctrl->base + INTF_CFG);\n\twritel(1, ctrl->base + CFG_PORT(COMP_CFG, ver));\n\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\tpm_runtime_set_autosuspend_delay(&pdev->dev, QCOM_SLIM_AUTOSUSPEND);\n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_mark_last_busy(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\n\tdev_dbg(ctrl->dev, \"QCOM SB controller is up:ver:0x%x!\\n\", ver);\n\treturn 0;\n\nerr:\n\tclk_disable_unprepare(ctrl->rclk);\nerr_rclk_enable_failed:\n\tclk_disable_unprepare(ctrl->hclk);\nerr_hclk_enable_failed:\nerr_request_irq_failed:\n\tdestroy_workqueue(ctrl->rxwq);\n\treturn ret;\n}\n\nstatic int qcom_slim_remove(struct platform_device *pdev)\n{\n\tstruct qcom_slim_ctrl *ctrl = platform_get_drvdata(pdev);\n\n\tpm_runtime_disable(&pdev->dev);\n\tslim_unregister_controller(&ctrl->ctrl);\n\tclk_disable_unprepare(ctrl->rclk);\n\tclk_disable_unprepare(ctrl->hclk);\n\tdestroy_workqueue(ctrl->rxwq);\n\treturn 0;\n}\n\n \n#ifdef CONFIG_PM\nstatic int qcom_slim_runtime_suspend(struct device *device)\n{\n\tstruct qcom_slim_ctrl *ctrl = dev_get_drvdata(device);\n\tint ret;\n\n\tdev_dbg(device, \"pm_runtime: suspending...\\n\");\n\tret = slim_ctrl_clk_pause(&ctrl->ctrl, false, SLIM_CLK_UNSPECIFIED);\n\tif (ret) {\n\t\tdev_err(device, \"clk pause not entered:%d\", ret);\n\t} else {\n\t\tdisable_irq(ctrl->irq);\n\t\tclk_disable_unprepare(ctrl->hclk);\n\t\tclk_disable_unprepare(ctrl->rclk);\n\t}\n\treturn ret;\n}\n\nstatic int qcom_slim_runtime_resume(struct device *device)\n{\n\tstruct qcom_slim_ctrl *ctrl = dev_get_drvdata(device);\n\tint ret = 0;\n\n\tdev_dbg(device, \"pm_runtime: resuming...\\n\");\n\tret = slim_ctrl_clk_pause(&ctrl->ctrl, true, 0);\n\tif (ret)\n\t\tdev_err(device, \"clk pause not exited:%d\", ret);\n\treturn ret;\n}\n#endif\n\n#ifdef CONFIG_PM_SLEEP\nstatic int qcom_slim_suspend(struct device *dev)\n{\n\tint ret = 0;\n\n\tif (!pm_runtime_enabled(dev) ||\n\t\t(!pm_runtime_suspended(dev))) {\n\t\tdev_dbg(dev, \"system suspend\");\n\t\tret = qcom_slim_runtime_suspend(dev);\n\t}\n\n\treturn ret;\n}\n\nstatic int qcom_slim_resume(struct device *dev)\n{\n\tif (!pm_runtime_enabled(dev) || !pm_runtime_suspended(dev)) {\n\t\tint ret;\n\n\t\tdev_dbg(dev, \"system resume\");\n\t\tret = qcom_slim_runtime_resume(dev);\n\t\tif (!ret) {\n\t\t\tpm_runtime_mark_last_busy(dev);\n\t\t\tpm_request_autosuspend(dev);\n\t\t}\n\t\treturn ret;\n\n\t}\n\treturn 0;\n}\n#endif  \n\nstatic const struct dev_pm_ops qcom_slim_dev_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(qcom_slim_suspend, qcom_slim_resume)\n\tSET_RUNTIME_PM_OPS(\n\t\t\t   qcom_slim_runtime_suspend,\n\t\t\t   qcom_slim_runtime_resume,\n\t\t\t   NULL\n\t)\n};\n\nstatic const struct of_device_id qcom_slim_dt_match[] = {\n\t{ .compatible = \"qcom,slim\", },\n\t{}\n};\n\nstatic struct platform_driver qcom_slim_driver = {\n\t.probe = qcom_slim_probe,\n\t.remove = qcom_slim_remove,\n\t.driver\t= {\n\t\t.name = \"qcom_slim_ctrl\",\n\t\t.of_match_table = qcom_slim_dt_match,\n\t\t.pm = &qcom_slim_dev_pm_ops,\n\t},\n};\nmodule_platform_driver(qcom_slim_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Qualcomm SLIMbus Controller\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}