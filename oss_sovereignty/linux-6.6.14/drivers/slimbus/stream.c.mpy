{
  "module_name": "stream.c",
  "hash_id": "9aa8ba6a8ff278ccd87c8247dac4c8c5cc47fd7e14d4e72cad24a8f022b8299a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/slimbus/stream.c",
  "human_readable_source": "\n\n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/slimbus.h>\n#include <uapi/sound/asound.h>\n#include \"slimbus.h\"\n\n \nstatic const struct segdist_code {\n\tint ratem;\n\tint seg_interval;\n\tint segdist_code;\n\tu32 seg_offset_mask;\n\n} segdist_codes[] = {\n\t{1,\t1536,\t0x200,\t 0xdff},\n\t{2,\t768,\t0x100,\t 0xcff},\n\t{4,\t384,\t0x080,\t 0xc7f},\n\t{8,\t192,\t0x040,\t 0xc3f},\n\t{16,\t96,\t0x020,\t 0xc1f},\n\t{32,\t48,\t0x010,\t 0xc0f},\n\t{64,\t24,\t0x008,\t 0xc07},\n\t{128,\t12,\t0x004,\t 0xc03},\n\t{256,\t6,\t0x002,\t 0xc01},\n\t{512,\t3,\t0x001,\t 0xc00},\n\t{3,\t512,\t0xe00,\t 0x1ff},\n\t{6,\t256,\t0xd00,\t 0x0ff},\n\t{12,\t128,\t0xc80,\t 0x07f},\n\t{24,\t64,\t0xc40,\t 0x03f},\n\t{48,\t32,\t0xc20,\t 0x01f},\n\t{96,\t16,\t0xc10,\t 0x00f},\n\t{192,\t8,\t0xc08,\t 0x007},\n\t{364,\t4,\t0xc04,\t 0x003},\n\t{768,\t2,\t0xc02,\t 0x001},\n};\n\n \nstatic const int slim_presence_rate_table[] = {\n\t0,  \n\t12000,\n\t24000,\n\t48000,\n\t96000,\n\t192000,\n\t384000,\n\t768000,\n\t0,  \n\t11025,\n\t22050,\n\t44100,\n\t88200,\n\t176400,\n\t352800,\n\t705600,\n\t4000,\n\t8000,\n\t16000,\n\t32000,\n\t64000,\n\t128000,\n\t256000,\n\t512000,\n};\n\n \nstruct slim_stream_runtime *slim_stream_allocate(struct slim_device *dev,\n\t\t\t\t\t\t const char *name)\n{\n\tstruct slim_stream_runtime *rt;\n\n\trt = kzalloc(sizeof(*rt), GFP_KERNEL);\n\tif (!rt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trt->name = kasprintf(GFP_KERNEL, \"slim-%s\", name);\n\tif (!rt->name) {\n\t\tkfree(rt);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\trt->dev = dev;\n\tspin_lock(&dev->stream_list_lock);\n\tlist_add_tail(&rt->node, &dev->stream_list);\n\tspin_unlock(&dev->stream_list_lock);\n\n\treturn rt;\n}\nEXPORT_SYMBOL_GPL(slim_stream_allocate);\n\nstatic int slim_connect_port_channel(struct slim_stream_runtime *stream,\n\t\t\t\t     struct slim_port *port)\n{\n\tstruct slim_device *sdev = stream->dev;\n\tu8 wbuf[2];\n\tstruct slim_val_inf msg = {0, 2, NULL, wbuf, NULL};\n\tu8 mc = SLIM_MSG_MC_CONNECT_SOURCE;\n\tDEFINE_SLIM_LDEST_TXN(txn, mc, 6, stream->dev->laddr, &msg);\n\n\tif (port->direction == SLIM_PORT_SINK)\n\t\ttxn.mc = SLIM_MSG_MC_CONNECT_SINK;\n\n\twbuf[0] = port->id;\n\twbuf[1] = port->ch.id;\n\tport->ch.state = SLIM_CH_STATE_ASSOCIATED;\n\tport->state = SLIM_PORT_UNCONFIGURED;\n\n\treturn slim_do_transfer(sdev->ctrl, &txn);\n}\n\nstatic int slim_disconnect_port(struct slim_stream_runtime *stream,\n\t\t\t\tstruct slim_port *port)\n{\n\tstruct slim_device *sdev = stream->dev;\n\tu8 wbuf[1];\n\tstruct slim_val_inf msg = {0, 1, NULL, wbuf, NULL};\n\tu8 mc = SLIM_MSG_MC_DISCONNECT_PORT;\n\tDEFINE_SLIM_LDEST_TXN(txn, mc, 5, stream->dev->laddr, &msg);\n\n\twbuf[0] = port->id;\n\tport->ch.state = SLIM_CH_STATE_DISCONNECTED;\n\tport->state = SLIM_PORT_DISCONNECTED;\n\n\treturn slim_do_transfer(sdev->ctrl, &txn);\n}\n\nstatic int slim_deactivate_remove_channel(struct slim_stream_runtime *stream,\n\t\t\t\t\t  struct slim_port *port)\n{\n\tstruct slim_device *sdev = stream->dev;\n\tu8 wbuf[1];\n\tstruct slim_val_inf msg = {0, 1, NULL, wbuf, NULL};\n\tu8 mc = SLIM_MSG_MC_NEXT_DEACTIVATE_CHANNEL;\n\tDEFINE_SLIM_LDEST_TXN(txn, mc, 5, stream->dev->laddr, &msg);\n\tint ret;\n\n\twbuf[0] = port->ch.id;\n\tret = slim_do_transfer(sdev->ctrl, &txn);\n\tif (ret)\n\t\treturn ret;\n\n\ttxn.mc = SLIM_MSG_MC_NEXT_REMOVE_CHANNEL;\n\tport->ch.state = SLIM_CH_STATE_REMOVED;\n\n\treturn slim_do_transfer(sdev->ctrl, &txn);\n}\n\nstatic int slim_get_prate_code(int rate)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(slim_presence_rate_table); i++) {\n\t\tif (rate == slim_presence_rate_table[i])\n\t\t\treturn i;\n\t}\n\n\treturn -EINVAL;\n}\n\n \nint slim_stream_prepare(struct slim_stream_runtime *rt,\n\t\t\tstruct slim_stream_config *cfg)\n{\n\tstruct slim_controller *ctrl = rt->dev->ctrl;\n\tstruct slim_port *port;\n\tint num_ports, i, port_id, prrate;\n\n\tif (rt->ports) {\n\t\tdev_err(&rt->dev->dev, \"Stream already Prepared\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tnum_ports = hweight32(cfg->port_mask);\n\trt->ports = kcalloc(num_ports, sizeof(*port), GFP_KERNEL);\n\tif (!rt->ports)\n\t\treturn -ENOMEM;\n\n\trt->num_ports = num_ports;\n\trt->rate = cfg->rate;\n\trt->bps = cfg->bps;\n\trt->direction = cfg->direction;\n\n\tprrate = slim_get_prate_code(cfg->rate);\n\tif (prrate < 0) {\n\t\tdev_err(&rt->dev->dev, \"Cannot get presence rate for rate %d Hz\\n\",\n\t\t\tcfg->rate);\n\t\treturn prrate;\n\t}\n\n\tif (cfg->rate % ctrl->a_framer->superfreq) {\n\t\t \n\t\tif (cfg->direction == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\trt->prot = SLIM_PROTO_PUSH;\n\t\telse\n\t\t\trt->prot = SLIM_PROTO_PULL;\n\t} else {\n\t\trt->prot = SLIM_PROTO_ISO;\n\t}\n\n\trt->ratem = cfg->rate/ctrl->a_framer->superfreq;\n\n\ti = 0;\n\tfor_each_set_bit(port_id, &cfg->port_mask, SLIM_DEVICE_MAX_PORTS) {\n\t\tport = &rt->ports[i];\n\t\tport->state = SLIM_PORT_DISCONNECTED;\n\t\tport->id = port_id;\n\t\tport->ch.prrate = prrate;\n\t\tport->ch.id = cfg->chs[i];\n\t\tport->ch.data_fmt = SLIM_CH_DATA_FMT_NOT_DEFINED;\n\t\tport->ch.aux_fmt = SLIM_CH_AUX_FMT_NOT_APPLICABLE;\n\t\tport->ch.state = SLIM_CH_STATE_ALLOCATED;\n\n\t\tif (cfg->direction == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\tport->direction = SLIM_PORT_SINK;\n\t\telse\n\t\t\tport->direction = SLIM_PORT_SOURCE;\n\n\t\tslim_connect_port_channel(rt, port);\n\t\ti++;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(slim_stream_prepare);\n\nstatic int slim_define_channel_content(struct slim_stream_runtime *stream,\n\t\t\t\t       struct slim_port *port)\n{\n\tstruct slim_device *sdev = stream->dev;\n\tu8 wbuf[4];\n\tstruct slim_val_inf msg = {0, 4, NULL, wbuf, NULL};\n\tu8 mc = SLIM_MSG_MC_NEXT_DEFINE_CONTENT;\n\tDEFINE_SLIM_LDEST_TXN(txn, mc, 8, stream->dev->laddr, &msg);\n\n\twbuf[0] = port->ch.id;\n\twbuf[1] = port->ch.prrate;\n\n\t \n\tif (stream->prot != SLIM_PROTO_ISO)\n\t\twbuf[1] |= SLIM_CHANNEL_CONTENT_FL;\n\n\twbuf[2] = port->ch.data_fmt | (port->ch.aux_fmt << 4);\n\twbuf[3] = stream->bps/SLIM_SLOT_LEN_BITS;\n\tport->ch.state = SLIM_CH_STATE_CONTENT_DEFINED;\n\n\treturn slim_do_transfer(sdev->ctrl, &txn);\n}\n\nstatic int slim_get_segdist_code(int ratem)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(segdist_codes); i++) {\n\t\tif (segdist_codes[i].ratem == ratem)\n\t\t\treturn segdist_codes[i].segdist_code;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int slim_define_channel(struct slim_stream_runtime *stream,\n\t\t\t\t       struct slim_port *port)\n{\n\tstruct slim_device *sdev = stream->dev;\n\tu8 wbuf[4];\n\tstruct slim_val_inf msg = {0, 4, NULL, wbuf, NULL};\n\tu8 mc = SLIM_MSG_MC_NEXT_DEFINE_CHANNEL;\n\tDEFINE_SLIM_LDEST_TXN(txn, mc, 8, stream->dev->laddr, &msg);\n\n\tport->ch.seg_dist = slim_get_segdist_code(stream->ratem);\n\n\twbuf[0] = port->ch.id;\n\twbuf[1] = port->ch.seg_dist & 0xFF;\n\twbuf[2] = (stream->prot << 4) | ((port->ch.seg_dist & 0xF00) >> 8);\n\tif (stream->prot == SLIM_PROTO_ISO)\n\t\twbuf[3] = stream->bps/SLIM_SLOT_LEN_BITS;\n\telse\n\t\twbuf[3] = stream->bps/SLIM_SLOT_LEN_BITS + 1;\n\n\tport->ch.state = SLIM_CH_STATE_DEFINED;\n\n\treturn slim_do_transfer(sdev->ctrl, &txn);\n}\n\nstatic int slim_activate_channel(struct slim_stream_runtime *stream,\n\t\t\t\t struct slim_port *port)\n{\n\tstruct slim_device *sdev = stream->dev;\n\tu8 wbuf[1];\n\tstruct slim_val_inf msg = {0, 1, NULL, wbuf, NULL};\n\tu8 mc = SLIM_MSG_MC_NEXT_ACTIVATE_CHANNEL;\n\tDEFINE_SLIM_LDEST_TXN(txn, mc, 5, stream->dev->laddr, &msg);\n\n\ttxn.msg->num_bytes = 1;\n\ttxn.msg->wbuf = wbuf;\n\twbuf[0] = port->ch.id;\n\tport->ch.state = SLIM_CH_STATE_ACTIVE;\n\n\treturn slim_do_transfer(sdev->ctrl, &txn);\n}\n\n \nint slim_stream_enable(struct slim_stream_runtime *stream)\n{\n\tDEFINE_SLIM_BCAST_TXN(txn, SLIM_MSG_MC_BEGIN_RECONFIGURATION,\n\t\t\t\t3, SLIM_LA_MANAGER, NULL);\n\tstruct slim_controller *ctrl = stream->dev->ctrl;\n\tint ret, i;\n\n\tif (ctrl->enable_stream) {\n\t\tret = ctrl->enable_stream(stream);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tfor (i = 0; i < stream->num_ports; i++)\n\t\t\tstream->ports[i].ch.state = SLIM_CH_STATE_ACTIVE;\n\n\t\treturn ret;\n\t}\n\n\tret = slim_do_transfer(ctrl, &txn);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor (i = 0; i < stream->num_ports; i++) {\n\t\tstruct slim_port *port = &stream->ports[i];\n\n\t\tslim_define_channel(stream, port);\n\t\tslim_define_channel_content(stream, port);\n\t}\n\n\tfor (i = 0; i < stream->num_ports; i++) {\n\t\tstruct slim_port *port = &stream->ports[i];\n\n\t\tslim_activate_channel(stream, port);\n\t\tport->state = SLIM_PORT_CONFIGURED;\n\t}\n\ttxn.mc = SLIM_MSG_MC_RECONFIGURE_NOW;\n\n\treturn slim_do_transfer(ctrl, &txn);\n}\nEXPORT_SYMBOL_GPL(slim_stream_enable);\n\n \nint slim_stream_disable(struct slim_stream_runtime *stream)\n{\n\tDEFINE_SLIM_BCAST_TXN(txn, SLIM_MSG_MC_BEGIN_RECONFIGURATION,\n\t\t\t\t3, SLIM_LA_MANAGER, NULL);\n\tstruct slim_controller *ctrl = stream->dev->ctrl;\n\tint ret, i;\n\n\tif (!stream->ports || !stream->num_ports)\n\t\treturn -EINVAL;\n\n\tif (ctrl->disable_stream)\n\t\tctrl->disable_stream(stream);\n\n\tret = slim_do_transfer(ctrl, &txn);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < stream->num_ports; i++)\n\t\tslim_deactivate_remove_channel(stream, &stream->ports[i]);\n\n\ttxn.mc = SLIM_MSG_MC_RECONFIGURE_NOW;\n\n\treturn slim_do_transfer(ctrl, &txn);\n}\nEXPORT_SYMBOL_GPL(slim_stream_disable);\n\n \nint slim_stream_unprepare(struct slim_stream_runtime *stream)\n{\n\tint i;\n\n\tif (!stream->ports || !stream->num_ports)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < stream->num_ports; i++)\n\t\tslim_disconnect_port(stream, &stream->ports[i]);\n\n\tkfree(stream->ports);\n\tstream->ports = NULL;\n\tstream->num_ports = 0;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(slim_stream_unprepare);\n\n \nint slim_stream_free(struct slim_stream_runtime *stream)\n{\n\tstruct slim_device *sdev = stream->dev;\n\n\tspin_lock(&sdev->stream_list_lock);\n\tlist_del(&stream->node);\n\tspin_unlock(&sdev->stream_list_lock);\n\n\tkfree(stream->name);\n\tkfree(stream);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(slim_stream_free);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}