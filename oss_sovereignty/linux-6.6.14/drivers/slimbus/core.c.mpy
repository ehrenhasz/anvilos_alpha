{
  "module_name": "core.c",
  "hash_id": "515921156f8c269b9b1d6b041f821ee81ad941c25311d97d0ba9d0117737d0da",
  "original_prompt": "Ingested from linux-6.6.14/drivers/slimbus/core.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/idr.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/slimbus.h>\n#include \"slimbus.h\"\n\nstatic DEFINE_IDA(ctrl_ida);\n\nstatic const struct slim_device_id *slim_match(const struct slim_device_id *id,\n\t\t\t\t\t       const struct slim_device *sbdev)\n{\n\twhile (id->manf_id != 0 || id->prod_code != 0) {\n\t\tif (id->manf_id == sbdev->e_addr.manf_id &&\n\t\t    id->prod_code == sbdev->e_addr.prod_code &&\n\t\t    id->dev_index == sbdev->e_addr.dev_index &&\n\t\t    id->instance == sbdev->e_addr.instance)\n\t\t\treturn id;\n\t\tid++;\n\t}\n\treturn NULL;\n}\n\nstatic int slim_device_match(struct device *dev, struct device_driver *drv)\n{\n\tstruct slim_device *sbdev = to_slim_device(dev);\n\tstruct slim_driver *sbdrv = to_slim_driver(drv);\n\n\t \n\tif (of_driver_match_device(dev, drv))\n\t\treturn 1;\n\n\treturn !!slim_match(sbdrv->id_table, sbdev);\n}\n\nstatic void slim_device_update_status(struct slim_device *sbdev,\n\t\t\t\t      enum slim_device_status status)\n{\n\tstruct slim_driver *sbdrv;\n\n\tif (sbdev->status == status)\n\t\treturn;\n\n\tsbdev->status = status;\n\tif (!sbdev->dev.driver)\n\t\treturn;\n\n\tsbdrv = to_slim_driver(sbdev->dev.driver);\n\tif (sbdrv->device_status)\n\t\tsbdrv->device_status(sbdev, sbdev->status);\n}\n\nstatic int slim_device_probe(struct device *dev)\n{\n\tstruct slim_device\t*sbdev = to_slim_device(dev);\n\tstruct slim_driver\t*sbdrv = to_slim_driver(dev->driver);\n\tint ret;\n\n\tret = sbdrv->probe(sbdev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = slim_get_logical_addr(sbdev);\n\tif (!ret) {\n\t\tslim_device_update_status(sbdev, SLIM_DEVICE_STATUS_UP);\n\t} else {\n\t\tdev_err(&sbdev->dev, \"Failed to get logical address\\n\");\n\t\tret = -EPROBE_DEFER;\n\t}\n\n\treturn ret;\n}\n\nstatic void slim_device_remove(struct device *dev)\n{\n\tstruct slim_device *sbdev = to_slim_device(dev);\n\tstruct slim_driver *sbdrv;\n\n\tif (dev->driver) {\n\t\tsbdrv = to_slim_driver(dev->driver);\n\t\tif (sbdrv->remove)\n\t\t\tsbdrv->remove(sbdev);\n\t}\n}\n\nstatic int slim_device_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tconst struct slim_device *sbdev = to_slim_device(dev);\n\n\treturn add_uevent_var(env, \"MODALIAS=slim:%s\", dev_name(&sbdev->dev));\n}\n\nstruct bus_type slimbus_bus = {\n\t.name\t\t= \"slimbus\",\n\t.match\t\t= slim_device_match,\n\t.probe\t\t= slim_device_probe,\n\t.remove\t\t= slim_device_remove,\n\t.uevent\t\t= slim_device_uevent,\n};\nEXPORT_SYMBOL_GPL(slimbus_bus);\n\n \nint __slim_driver_register(struct slim_driver *drv, struct module *owner)\n{\n\t \n\tif (!(drv->driver.of_match_table || drv->id_table) || !drv->probe)\n\t\treturn -EINVAL;\n\n\tdrv->driver.bus = &slimbus_bus;\n\tdrv->driver.owner = owner;\n\n\treturn driver_register(&drv->driver);\n}\nEXPORT_SYMBOL_GPL(__slim_driver_register);\n\n \nvoid slim_driver_unregister(struct slim_driver *drv)\n{\n\tdriver_unregister(&drv->driver);\n}\nEXPORT_SYMBOL_GPL(slim_driver_unregister);\n\nstatic void slim_dev_release(struct device *dev)\n{\n\tstruct slim_device *sbdev = to_slim_device(dev);\n\n\tkfree(sbdev);\n}\n\nstatic int slim_add_device(struct slim_controller *ctrl,\n\t\t\t   struct slim_device *sbdev,\n\t\t\t   struct device_node *node)\n{\n\tsbdev->dev.bus = &slimbus_bus;\n\tsbdev->dev.parent = ctrl->dev;\n\tsbdev->dev.release = slim_dev_release;\n\tsbdev->dev.driver = NULL;\n\tsbdev->ctrl = ctrl;\n\tINIT_LIST_HEAD(&sbdev->stream_list);\n\tspin_lock_init(&sbdev->stream_list_lock);\n\tsbdev->dev.of_node = of_node_get(node);\n\tsbdev->dev.fwnode = of_fwnode_handle(node);\n\n\tdev_set_name(&sbdev->dev, \"%x:%x:%x:%x\",\n\t\t\t\t  sbdev->e_addr.manf_id,\n\t\t\t\t  sbdev->e_addr.prod_code,\n\t\t\t\t  sbdev->e_addr.dev_index,\n\t\t\t\t  sbdev->e_addr.instance);\n\n\treturn device_register(&sbdev->dev);\n}\n\nstatic struct slim_device *slim_alloc_device(struct slim_controller *ctrl,\n\t\t\t\t\t     struct slim_eaddr *eaddr,\n\t\t\t\t\t     struct device_node *node)\n{\n\tstruct slim_device *sbdev;\n\tint ret;\n\n\tsbdev = kzalloc(sizeof(*sbdev), GFP_KERNEL);\n\tif (!sbdev)\n\t\treturn NULL;\n\n\tsbdev->e_addr = *eaddr;\n\tret = slim_add_device(ctrl, sbdev, node);\n\tif (ret) {\n\t\tput_device(&sbdev->dev);\n\t\treturn NULL;\n\t}\n\n\treturn sbdev;\n}\n\nstatic void of_register_slim_devices(struct slim_controller *ctrl)\n{\n\tstruct device *dev = ctrl->dev;\n\tstruct device_node *node;\n\n\tif (!ctrl->dev->of_node)\n\t\treturn;\n\n\tfor_each_child_of_node(ctrl->dev->of_node, node) {\n\t\tstruct slim_device *sbdev;\n\t\tstruct slim_eaddr e_addr;\n\t\tconst char *compat = NULL;\n\t\tint reg[2], ret;\n\t\tint manf_id, prod_code;\n\n\t\tcompat = of_get_property(node, \"compatible\", NULL);\n\t\tif (!compat)\n\t\t\tcontinue;\n\n\t\tret = sscanf(compat, \"slim%x,%x\", &manf_id, &prod_code);\n\t\tif (ret != 2) {\n\t\t\tdev_err(dev, \"Manf ID & Product code not found %s\\n\",\n\t\t\t\tcompat);\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = of_property_read_u32_array(node, \"reg\", reg, 2);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Device and Instance id not found:%d\\n\",\n\t\t\t\tret);\n\t\t\tcontinue;\n\t\t}\n\n\t\te_addr.dev_index = reg[0];\n\t\te_addr.instance = reg[1];\n\t\te_addr.manf_id = manf_id;\n\t\te_addr.prod_code = prod_code;\n\n\t\tsbdev = slim_alloc_device(ctrl, &e_addr, node);\n\t\tif (!sbdev)\n\t\t\tcontinue;\n\t}\n}\n\n \nint slim_register_controller(struct slim_controller *ctrl)\n{\n\tint id;\n\n\tid = ida_alloc(&ctrl_ida, GFP_KERNEL);\n\tif (id < 0)\n\t\treturn id;\n\n\tctrl->id = id;\n\n\tif (!ctrl->min_cg)\n\t\tctrl->min_cg = SLIM_MIN_CLK_GEAR;\n\tif (!ctrl->max_cg)\n\t\tctrl->max_cg = SLIM_MAX_CLK_GEAR;\n\n\tida_init(&ctrl->laddr_ida);\n\tidr_init(&ctrl->tid_idr);\n\tmutex_init(&ctrl->lock);\n\tmutex_init(&ctrl->sched.m_reconf);\n\tinit_completion(&ctrl->sched.pause_comp);\n\tspin_lock_init(&ctrl->txn_lock);\n\n\tdev_dbg(ctrl->dev, \"Bus [%s] registered:dev:%p\\n\",\n\t\tctrl->name, ctrl->dev);\n\n\tof_register_slim_devices(ctrl);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(slim_register_controller);\n\n \nstatic void slim_remove_device(struct slim_device *sbdev)\n{\n\tof_node_put(sbdev->dev.of_node);\n\tdevice_unregister(&sbdev->dev);\n}\n\nstatic int slim_ctrl_remove_device(struct device *dev, void *null)\n{\n\tslim_remove_device(to_slim_device(dev));\n\treturn 0;\n}\n\n \nint slim_unregister_controller(struct slim_controller *ctrl)\n{\n\t \n\tdevice_for_each_child(ctrl->dev, NULL, slim_ctrl_remove_device);\n\tida_free(&ctrl_ida, ctrl->id);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(slim_unregister_controller);\n\n \nvoid slim_report_absent(struct slim_device *sbdev)\n{\n\tstruct slim_controller *ctrl = sbdev->ctrl;\n\n\tif (!ctrl)\n\t\treturn;\n\n\t \n\tmutex_lock(&ctrl->lock);\n\tsbdev->is_laddr_valid = false;\n\tmutex_unlock(&ctrl->lock);\n\tif (!ctrl->get_laddr)\n\t\tida_free(&ctrl->laddr_ida, sbdev->laddr);\n\tslim_device_update_status(sbdev, SLIM_DEVICE_STATUS_DOWN);\n}\nEXPORT_SYMBOL_GPL(slim_report_absent);\n\nstatic bool slim_eaddr_equal(struct slim_eaddr *a, struct slim_eaddr *b)\n{\n\treturn (a->manf_id == b->manf_id &&\n\t\ta->prod_code == b->prod_code &&\n\t\ta->dev_index == b->dev_index &&\n\t\ta->instance == b->instance);\n}\n\nstatic int slim_match_dev(struct device *dev, void *data)\n{\n\tstruct slim_eaddr *e_addr = data;\n\tstruct slim_device *sbdev = to_slim_device(dev);\n\n\treturn slim_eaddr_equal(&sbdev->e_addr, e_addr);\n}\n\nstatic struct slim_device *find_slim_device(struct slim_controller *ctrl,\n\t\t\t\t\t    struct slim_eaddr *eaddr)\n{\n\tstruct slim_device *sbdev;\n\tstruct device *dev;\n\n\tdev = device_find_child(ctrl->dev, eaddr, slim_match_dev);\n\tif (dev) {\n\t\tsbdev = to_slim_device(dev);\n\t\treturn sbdev;\n\t}\n\n\treturn NULL;\n}\n\n \nstruct slim_device *slim_get_device(struct slim_controller *ctrl,\n\t\t\t\t    struct slim_eaddr *e_addr)\n{\n\tstruct slim_device *sbdev;\n\n\tsbdev = find_slim_device(ctrl, e_addr);\n\tif (!sbdev) {\n\t\tsbdev = slim_alloc_device(ctrl, e_addr, NULL);\n\t\tif (!sbdev)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treturn sbdev;\n}\nEXPORT_SYMBOL_GPL(slim_get_device);\n\nstatic int of_slim_match_dev(struct device *dev, void *data)\n{\n\tstruct device_node *np = data;\n\tstruct slim_device *sbdev = to_slim_device(dev);\n\n\treturn (sbdev->dev.of_node == np);\n}\n\nstatic struct slim_device *of_find_slim_device(struct slim_controller *ctrl,\n\t\t\t\t\t       struct device_node *np)\n{\n\tstruct slim_device *sbdev;\n\tstruct device *dev;\n\n\tdev = device_find_child(ctrl->dev, np, of_slim_match_dev);\n\tif (dev) {\n\t\tsbdev = to_slim_device(dev);\n\t\treturn sbdev;\n\t}\n\n\treturn NULL;\n}\n\n \nstruct slim_device *of_slim_get_device(struct slim_controller *ctrl,\n\t\t\t\t       struct device_node *np)\n{\n\treturn of_find_slim_device(ctrl, np);\n}\nEXPORT_SYMBOL_GPL(of_slim_get_device);\n\nstatic int slim_device_alloc_laddr(struct slim_device *sbdev,\n\t\t\t\t   bool report_present)\n{\n\tstruct slim_controller *ctrl = sbdev->ctrl;\n\tu8 laddr;\n\tint ret;\n\n\tmutex_lock(&ctrl->lock);\n\tif (ctrl->get_laddr) {\n\t\tret = ctrl->get_laddr(ctrl, &sbdev->e_addr, &laddr);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t} else if (report_present) {\n\t\tret = ida_simple_get(&ctrl->laddr_ida,\n\t\t\t\t     0, SLIM_LA_MANAGER - 1, GFP_KERNEL);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\n\t\tladdr = ret;\n\t} else {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (ctrl->set_laddr) {\n\t\tret = ctrl->set_laddr(ctrl, &sbdev->e_addr, laddr);\n\t\tif (ret) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tsbdev->laddr = laddr;\n\tsbdev->is_laddr_valid = true;\n\tmutex_unlock(&ctrl->lock);\n\n\tslim_device_update_status(sbdev, SLIM_DEVICE_STATUS_UP);\n\n\tdev_dbg(ctrl->dev, \"setting slimbus l-addr:%x, ea:%x,%x,%x,%x\\n\",\n\t\tladdr, sbdev->e_addr.manf_id, sbdev->e_addr.prod_code,\n\t\tsbdev->e_addr.dev_index, sbdev->e_addr.instance);\n\n\treturn 0;\n\nerr:\n\tmutex_unlock(&ctrl->lock);\n\treturn ret;\n\n}\n\n \nint slim_device_report_present(struct slim_controller *ctrl,\n\t\t\t       struct slim_eaddr *e_addr, u8 *laddr)\n{\n\tstruct slim_device *sbdev;\n\tint ret;\n\n\tret = pm_runtime_get_sync(ctrl->dev);\n\n\tif (ctrl->sched.clk_state != SLIM_CLK_ACTIVE) {\n\t\tdev_err(ctrl->dev, \"slim ctrl not active,state:%d, ret:%d\\n\",\n\t\t\t\t    ctrl->sched.clk_state, ret);\n\t\tgoto slimbus_not_active;\n\t}\n\n\tsbdev = slim_get_device(ctrl, e_addr);\n\tif (IS_ERR(sbdev))\n\t\treturn -ENODEV;\n\n\tif (sbdev->is_laddr_valid) {\n\t\t*laddr = sbdev->laddr;\n\t\treturn 0;\n\t}\n\n\tret = slim_device_alloc_laddr(sbdev, true);\n\nslimbus_not_active:\n\tpm_runtime_mark_last_busy(ctrl->dev);\n\tpm_runtime_put_autosuspend(ctrl->dev);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(slim_device_report_present);\n\n \nint slim_get_logical_addr(struct slim_device *sbdev)\n{\n\tif (!sbdev->is_laddr_valid)\n\t\treturn slim_device_alloc_laddr(sbdev, false);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(slim_get_logical_addr);\n\nstatic void __exit slimbus_exit(void)\n{\n\tbus_unregister(&slimbus_bus);\n}\nmodule_exit(slimbus_exit);\n\nstatic int __init slimbus_init(void)\n{\n\treturn bus_register(&slimbus_bus);\n}\npostcore_initcall(slimbus_init);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"SLIMbus core\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}