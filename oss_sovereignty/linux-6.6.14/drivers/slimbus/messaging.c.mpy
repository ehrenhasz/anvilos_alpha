{
  "module_name": "messaging.c",
  "hash_id": "fd0e9ce5f3eb0dfb4fccba13fba1dd853ab95924e609613e4e09c396d19302ab",
  "original_prompt": "Ingested from linux-6.6.14/drivers/slimbus/messaging.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/pm_runtime.h>\n#include \"slimbus.h\"\n\n \nvoid slim_msg_response(struct slim_controller *ctrl, u8 *reply, u8 tid, u8 len)\n{\n\tstruct slim_msg_txn *txn;\n\tstruct slim_val_inf *msg;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctrl->txn_lock, flags);\n\ttxn = idr_find(&ctrl->tid_idr, tid);\n\tspin_unlock_irqrestore(&ctrl->txn_lock, flags);\n\n\tif (txn == NULL)\n\t\treturn;\n\n\tmsg = txn->msg;\n\tif (msg == NULL || msg->rbuf == NULL) {\n\t\tdev_err(ctrl->dev, \"Got response to invalid TID:%d, len:%d\\n\",\n\t\t\t\ttid, len);\n\t\treturn;\n\t}\n\n\tslim_free_txn_tid(ctrl, txn);\n\tmemcpy(msg->rbuf, reply, len);\n\tif (txn->comp)\n\t\tcomplete(txn->comp);\n\n\t \n\tpm_runtime_mark_last_busy(ctrl->dev);\n\tpm_runtime_put_autosuspend(ctrl->dev);\n}\nEXPORT_SYMBOL_GPL(slim_msg_response);\n\n \nint slim_alloc_txn_tid(struct slim_controller *ctrl, struct slim_msg_txn *txn)\n{\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&ctrl->txn_lock, flags);\n\tret = idr_alloc_cyclic(&ctrl->tid_idr, txn, 1,\n\t\t\t\tSLIM_MAX_TIDS, GFP_ATOMIC);\n\tif (ret < 0) {\n\t\tspin_unlock_irqrestore(&ctrl->txn_lock, flags);\n\t\treturn ret;\n\t}\n\ttxn->tid = ret;\n\tspin_unlock_irqrestore(&ctrl->txn_lock, flags);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(slim_alloc_txn_tid);\n\n \nvoid slim_free_txn_tid(struct slim_controller *ctrl, struct slim_msg_txn *txn)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctrl->txn_lock, flags);\n\tidr_remove(&ctrl->tid_idr, txn->tid);\n\tspin_unlock_irqrestore(&ctrl->txn_lock, flags);\n}\nEXPORT_SYMBOL_GPL(slim_free_txn_tid);\n\n \nint slim_do_transfer(struct slim_controller *ctrl, struct slim_msg_txn *txn)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tbool need_tid = false, clk_pause_msg = false;\n\tint ret, timeout;\n\n\t \n\tif (ctrl->sched.clk_state == SLIM_CLK_ENTERING_PAUSE &&\n\t\t(txn->mt == SLIM_MSG_MT_CORE &&\n\t\t txn->mc >= SLIM_MSG_MC_BEGIN_RECONFIGURATION &&\n\t\t txn->mc <= SLIM_MSG_MC_RECONFIGURE_NOW))\n\t\tclk_pause_msg = true;\n\n\tif (!clk_pause_msg) {\n\t\tret = pm_runtime_get_sync(ctrl->dev);\n\t\tif (ctrl->sched.clk_state != SLIM_CLK_ACTIVE) {\n\t\t\tdev_err(ctrl->dev, \"ctrl wrong state:%d, ret:%d\\n\",\n\t\t\t\tctrl->sched.clk_state, ret);\n\t\t\tgoto slim_xfer_err;\n\t\t}\n\t}\n\t \n\ttxn->tid = 0;\n\tneed_tid = slim_tid_txn(txn->mt, txn->mc);\n\n\tif (need_tid) {\n\t\tret = slim_alloc_txn_tid(ctrl, txn);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (!txn->msg->comp)\n\t\t\ttxn->comp = &done;\n\t\telse\n\t\t\ttxn->comp = txn->comp;\n\t}\n\n\tret = ctrl->xfer_msg(ctrl, txn);\n\n\tif (!ret && need_tid && !txn->msg->comp) {\n\t\tunsigned long ms = txn->rl + HZ;\n\n\t\ttimeout = wait_for_completion_timeout(txn->comp,\n\t\t\t\t\t\t      msecs_to_jiffies(ms));\n\t\tif (!timeout) {\n\t\t\tret = -ETIMEDOUT;\n\t\t\tslim_free_txn_tid(ctrl, txn);\n\t\t}\n\t}\n\n\tif (ret)\n\t\tdev_err(ctrl->dev, \"Tx:MT:0x%x, MC:0x%x, LA:0x%x failed:%d\\n\",\n\t\t\ttxn->mt, txn->mc, txn->la, ret);\n\nslim_xfer_err:\n\tif (!clk_pause_msg && (txn->tid == 0  || ret == -ETIMEDOUT)) {\n\t\t \n\t\tpm_runtime_mark_last_busy(ctrl->dev);\n\t\tpm_runtime_put_autosuspend(ctrl->dev);\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(slim_do_transfer);\n\nstatic int slim_val_inf_sanity(struct slim_controller *ctrl,\n\t\t\t       struct slim_val_inf *msg, u8 mc)\n{\n\tif (!msg || msg->num_bytes > 16 ||\n\t    (msg->start_offset + msg->num_bytes) > 0xC00)\n\t\tgoto reterr;\n\tswitch (mc) {\n\tcase SLIM_MSG_MC_REQUEST_VALUE:\n\tcase SLIM_MSG_MC_REQUEST_INFORMATION:\n\t\tif (msg->rbuf != NULL)\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase SLIM_MSG_MC_CHANGE_VALUE:\n\tcase SLIM_MSG_MC_CLEAR_INFORMATION:\n\t\tif (msg->wbuf != NULL)\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase SLIM_MSG_MC_REQUEST_CHANGE_VALUE:\n\tcase SLIM_MSG_MC_REQUEST_CLEAR_INFORMATION:\n\t\tif (msg->rbuf != NULL && msg->wbuf != NULL)\n\t\t\treturn 0;\n\t\tbreak;\n\t}\nreterr:\n\tif (msg)\n\t\tdev_err(ctrl->dev, \"Sanity check failed:msg:offset:0x%x, mc:%d\\n\",\n\t\t\tmsg->start_offset, mc);\n\treturn -EINVAL;\n}\n\nstatic u16 slim_slicesize(int code)\n{\n\tstatic const u8 sizetocode[16] = {\n\t\t0, 1, 2, 3, 3, 4, 4, 5, 5, 5, 5, 6, 6, 6, 6, 7\n\t};\n\n\tcode = clamp(code, 1, (int)ARRAY_SIZE(sizetocode));\n\n\treturn sizetocode[code - 1];\n}\n\n \nint slim_xfer_msg(struct slim_device *sbdev, struct slim_val_inf *msg,\n\t\t  u8 mc)\n{\n\tDEFINE_SLIM_LDEST_TXN(txn_stack, mc, 6, sbdev->laddr, msg);\n\tstruct slim_msg_txn *txn = &txn_stack;\n\tstruct slim_controller *ctrl = sbdev->ctrl;\n\tint ret;\n\tu16 sl;\n\n\tif (!ctrl)\n\t\treturn -EINVAL;\n\n\tret = slim_val_inf_sanity(ctrl, msg, mc);\n\tif (ret)\n\t\treturn ret;\n\n\tsl = slim_slicesize(msg->num_bytes);\n\n\tdev_dbg(ctrl->dev, \"SB xfer msg:os:%x, len:%d, MC:%x, sl:%x\\n\",\n\t\tmsg->start_offset, msg->num_bytes, mc, sl);\n\n\ttxn->ec = ((sl | (1 << 3)) | ((msg->start_offset & 0xFFF) << 4));\n\n\tswitch (mc) {\n\tcase SLIM_MSG_MC_REQUEST_CHANGE_VALUE:\n\tcase SLIM_MSG_MC_CHANGE_VALUE:\n\tcase SLIM_MSG_MC_REQUEST_CLEAR_INFORMATION:\n\tcase SLIM_MSG_MC_CLEAR_INFORMATION:\n\t\ttxn->rl += msg->num_bytes;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (slim_tid_txn(txn->mt, txn->mc))\n\t\ttxn->rl++;\n\n\treturn slim_do_transfer(ctrl, txn);\n}\nEXPORT_SYMBOL_GPL(slim_xfer_msg);\n\nstatic void slim_fill_msg(struct slim_val_inf *msg, u32 addr,\n\t\t\t size_t count, u8 *rbuf, u8 *wbuf)\n{\n\tmsg->start_offset = addr;\n\tmsg->num_bytes = count;\n\tmsg->rbuf = rbuf;\n\tmsg->wbuf = wbuf;\n\tmsg->comp = NULL;\n}\n\n \nint slim_read(struct slim_device *sdev, u32 addr, size_t count, u8 *val)\n{\n\tstruct slim_val_inf msg;\n\n\tslim_fill_msg(&msg, addr, count, val, NULL);\n\n\treturn slim_xfer_msg(sdev, &msg, SLIM_MSG_MC_REQUEST_VALUE);\n}\nEXPORT_SYMBOL_GPL(slim_read);\n\n \nint slim_readb(struct slim_device *sdev, u32 addr)\n{\n\tint ret;\n\tu8 buf;\n\n\tret = slim_read(sdev, addr, 1, &buf);\n\tif (ret < 0)\n\t\treturn ret;\n\telse\n\t\treturn buf;\n}\nEXPORT_SYMBOL_GPL(slim_readb);\n\n \nint slim_write(struct slim_device *sdev, u32 addr, size_t count, u8 *val)\n{\n\tstruct slim_val_inf msg;\n\n\tslim_fill_msg(&msg, addr, count,  NULL, val);\n\n\treturn slim_xfer_msg(sdev, &msg, SLIM_MSG_MC_CHANGE_VALUE);\n}\nEXPORT_SYMBOL_GPL(slim_write);\n\n \nint slim_writeb(struct slim_device *sdev, u32 addr, u8 value)\n{\n\treturn slim_write(sdev, addr, 1, &value);\n}\nEXPORT_SYMBOL_GPL(slim_writeb);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}