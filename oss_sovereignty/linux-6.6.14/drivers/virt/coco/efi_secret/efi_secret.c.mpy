{
  "module_name": "efi_secret.c",
  "hash_id": "83daf9e01c3473103e977166e6127a42f88a1b9cdbeb7e321ca44da4375b021f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/virt/coco/efi_secret/efi_secret.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/platform_device.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/security.h>\n#include <linux/efi.h>\n#include <linux/cacheflush.h>\n\n#define EFI_SECRET_NUM_FILES 64\n\nstruct efi_secret {\n\tstruct dentry *secrets_dir;\n\tstruct dentry *fs_dir;\n\tstruct dentry *fs_files[EFI_SECRET_NUM_FILES];\n\tvoid __iomem *secret_data;\n\tu64 secret_data_len;\n};\n\n \n\n \nstruct secret_header {\n\tefi_guid_t guid;\n\tu32 len;\n} __attribute((packed));\n\n \nstruct secret_entry {\n\tefi_guid_t guid;\n\tu32 len;\n\tu8 data[];\n} __attribute((packed));\n\nstatic size_t secret_entry_data_len(struct secret_entry *e)\n{\n\treturn e->len - sizeof(*e);\n}\n\nstatic struct efi_secret the_efi_secret;\n\nstatic inline struct efi_secret *efi_secret_get(void)\n{\n\treturn &the_efi_secret;\n}\n\nstatic int efi_secret_bin_file_show(struct seq_file *file, void *data)\n{\n\tstruct secret_entry *e = file->private;\n\n\tif (e)\n\t\tseq_write(file, e->data, secret_entry_data_len(e));\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(efi_secret_bin_file);\n\n \nstatic void wipe_memory(void *addr, size_t size)\n{\n\tmemzero_explicit(addr, size);\n#ifdef CONFIG_X86\n\tclflush_cache_range(addr, size);\n#endif\n}\n\nstatic int efi_secret_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct efi_secret *s = efi_secret_get();\n\tstruct inode *inode = d_inode(dentry);\n\tstruct secret_entry *e = (struct secret_entry *)inode->i_private;\n\tint i;\n\n\tif (e) {\n\t\t \n\t\twipe_memory(e->data, secret_entry_data_len(e));\n\t\te->guid = NULL_GUID;\n\t}\n\n\tinode->i_private = NULL;\n\n\tfor (i = 0; i < EFI_SECRET_NUM_FILES; i++)\n\t\tif (s->fs_files[i] == dentry)\n\t\t\ts->fs_files[i] = NULL;\n\n\t \n\tinode_unlock(dir);\n\tsecurityfs_remove(dentry);\n\tinode_lock(dir);\n\n\treturn 0;\n}\n\nstatic const struct inode_operations efi_secret_dir_inode_operations = {\n\t.lookup         = simple_lookup,\n\t.unlink         = efi_secret_unlink,\n};\n\nstatic int efi_secret_map_area(struct platform_device *dev)\n{\n\tint ret;\n\tstruct efi_secret *s = efi_secret_get();\n\tstruct linux_efi_coco_secret_area *secret_area;\n\n\tif (efi.coco_secret == EFI_INVALID_TABLE_ADDR) {\n\t\tdev_err(&dev->dev, \"Secret area address is not available\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsecret_area = memremap(efi.coco_secret, sizeof(*secret_area), MEMREMAP_WB);\n\tif (secret_area == NULL) {\n\t\tdev_err(&dev->dev, \"Could not map secret area EFI config entry\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tif (!secret_area->base_pa || secret_area->size < sizeof(struct secret_header)) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"Invalid secret area memory location (base_pa=0x%llx size=0x%llx)\\n\",\n\t\t\tsecret_area->base_pa, secret_area->size);\n\t\tret = -EINVAL;\n\t\tgoto unmap;\n\t}\n\n\ts->secret_data = ioremap_encrypted(secret_area->base_pa, secret_area->size);\n\tif (s->secret_data == NULL) {\n\t\tdev_err(&dev->dev, \"Could not map secret area\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto unmap;\n\t}\n\n\ts->secret_data_len = secret_area->size;\n\tret = 0;\n\nunmap:\n\tmemunmap(secret_area);\n\treturn ret;\n}\n\nstatic void efi_secret_securityfs_teardown(struct platform_device *dev)\n{\n\tstruct efi_secret *s = efi_secret_get();\n\tint i;\n\n\tfor (i = (EFI_SECRET_NUM_FILES - 1); i >= 0; i--) {\n\t\tsecurityfs_remove(s->fs_files[i]);\n\t\ts->fs_files[i] = NULL;\n\t}\n\n\tsecurityfs_remove(s->fs_dir);\n\ts->fs_dir = NULL;\n\n\tsecurityfs_remove(s->secrets_dir);\n\ts->secrets_dir = NULL;\n\n\tdev_dbg(&dev->dev, \"Removed securityfs entries\\n\");\n}\n\nstatic int efi_secret_securityfs_setup(struct platform_device *dev)\n{\n\tstruct efi_secret *s = efi_secret_get();\n\tint ret = 0, i = 0, bytes_left;\n\tunsigned char *ptr;\n\tstruct secret_header *h;\n\tstruct secret_entry *e;\n\tstruct dentry *dent;\n\tchar guid_str[EFI_VARIABLE_GUID_LEN + 1];\n\n\tptr = (void __force *)s->secret_data;\n\th = (struct secret_header *)ptr;\n\tif (efi_guidcmp(h->guid, EFI_SECRET_TABLE_HEADER_GUID)) {\n\t\t \n\t\tdev_dbg(&dev->dev, \"EFI secret area does not start with correct GUID\\n\");\n\t\treturn -ENODEV;\n\t}\n\tif (h->len < sizeof(*h)) {\n\t\tdev_err(&dev->dev, \"EFI secret area reported length is too small\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (h->len > s->secret_data_len) {\n\t\tdev_err(&dev->dev, \"EFI secret area reported length is too big\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ts->secrets_dir = NULL;\n\ts->fs_dir = NULL;\n\tmemset(s->fs_files, 0, sizeof(s->fs_files));\n\n\tdent = securityfs_create_dir(\"secrets\", NULL);\n\tif (IS_ERR(dent)) {\n\t\tdev_err(&dev->dev, \"Error creating secrets securityfs directory entry err=%ld\\n\",\n\t\t\tPTR_ERR(dent));\n\t\treturn PTR_ERR(dent);\n\t}\n\ts->secrets_dir = dent;\n\n\tdent = securityfs_create_dir(\"coco\", s->secrets_dir);\n\tif (IS_ERR(dent)) {\n\t\tdev_err(&dev->dev, \"Error creating coco securityfs directory entry err=%ld\\n\",\n\t\t\tPTR_ERR(dent));\n\t\treturn PTR_ERR(dent);\n\t}\n\td_inode(dent)->i_op = &efi_secret_dir_inode_operations;\n\ts->fs_dir = dent;\n\n\tbytes_left = h->len - sizeof(*h);\n\tptr += sizeof(*h);\n\twhile (bytes_left >= (int)sizeof(*e) && i < EFI_SECRET_NUM_FILES) {\n\t\te = (struct secret_entry *)ptr;\n\t\tif (e->len < sizeof(*e) || e->len > (unsigned int)bytes_left) {\n\t\t\tdev_err(&dev->dev, \"EFI secret area is corrupted\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_cleanup;\n\t\t}\n\n\t\t \n\t\tif (efi_guidcmp(e->guid, NULL_GUID)) {\n\t\t\tefi_guid_to_str(&e->guid, guid_str);\n\n\t\t\tdent = securityfs_create_file(guid_str, 0440, s->fs_dir, (void *)e,\n\t\t\t\t\t\t      &efi_secret_bin_file_fops);\n\t\t\tif (IS_ERR(dent)) {\n\t\t\t\tdev_err(&dev->dev, \"Error creating efi_secret securityfs entry\\n\");\n\t\t\t\tret = PTR_ERR(dent);\n\t\t\t\tgoto err_cleanup;\n\t\t\t}\n\n\t\t\ts->fs_files[i++] = dent;\n\t\t}\n\t\tptr += e->len;\n\t\tbytes_left -= e->len;\n\t}\n\n\tdev_info(&dev->dev, \"Created %d entries in securityfs secrets/coco\\n\", i);\n\treturn 0;\n\nerr_cleanup:\n\tefi_secret_securityfs_teardown(dev);\n\treturn ret;\n}\n\nstatic void efi_secret_unmap_area(void)\n{\n\tstruct efi_secret *s = efi_secret_get();\n\n\tif (s->secret_data) {\n\t\tiounmap(s->secret_data);\n\t\ts->secret_data = NULL;\n\t\ts->secret_data_len = 0;\n\t}\n}\n\nstatic int efi_secret_probe(struct platform_device *dev)\n{\n\tint ret;\n\n\tret = efi_secret_map_area(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = efi_secret_securityfs_setup(dev);\n\tif (ret)\n\t\tgoto err_unmap;\n\n\treturn ret;\n\nerr_unmap:\n\tefi_secret_unmap_area();\n\treturn ret;\n}\n\nstatic int efi_secret_remove(struct platform_device *dev)\n{\n\tefi_secret_securityfs_teardown(dev);\n\tefi_secret_unmap_area();\n\treturn 0;\n}\n\nstatic struct platform_driver efi_secret_driver = {\n\t.probe = efi_secret_probe,\n\t.remove = efi_secret_remove,\n\t.driver = {\n\t\t.name = \"efi_secret\",\n\t},\n};\n\nmodule_platform_driver(efi_secret_driver);\n\nMODULE_DESCRIPTION(\"Confidential computing EFI secret area access\");\nMODULE_AUTHOR(\"IBM\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:efi_secret\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}