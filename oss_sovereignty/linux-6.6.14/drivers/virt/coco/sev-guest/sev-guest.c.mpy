{
  "module_name": "sev-guest.c",
  "hash_id": "75cf6b868578c5176e0994822e9073d80124570858d44beaa561cfac29f8f2f2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/virt/coco/sev-guest/sev-guest.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/io.h>\n#include <linux/platform_device.h>\n#include <linux/miscdevice.h>\n#include <linux/set_memory.h>\n#include <linux/fs.h>\n#include <crypto/aead.h>\n#include <linux/scatterlist.h>\n#include <linux/psp-sev.h>\n#include <uapi/linux/sev-guest.h>\n#include <uapi/linux/psp-sev.h>\n\n#include <asm/svm.h>\n#include <asm/sev.h>\n\n#include \"sev-guest.h\"\n\n#define DEVICE_NAME\t\"sev-guest\"\n#define AAD_LEN\t\t48\n#define MSG_HDR_VER\t1\n\n#define SNP_REQ_MAX_RETRY_DURATION\t(60*HZ)\n#define SNP_REQ_RETRY_DELAY\t\t(2*HZ)\n\nstruct snp_guest_crypto {\n\tstruct crypto_aead *tfm;\n\tu8 *iv, *authtag;\n\tint iv_len, a_len;\n};\n\nstruct snp_guest_dev {\n\tstruct device *dev;\n\tstruct miscdevice misc;\n\n\tvoid *certs_data;\n\tstruct snp_guest_crypto *crypto;\n\t \n\tstruct snp_guest_msg *request, *response;\n\n\t \n\tstruct snp_guest_msg secret_request, secret_response;\n\n\tstruct snp_secrets_page_layout *layout;\n\tstruct snp_req_data input;\n\tunion {\n\t\tstruct snp_report_req report;\n\t\tstruct snp_derived_key_req derived_key;\n\t\tstruct snp_ext_report_req ext_report;\n\t} req;\n\tu32 *os_area_msg_seqno;\n\tu8 *vmpck;\n};\n\nstatic u32 vmpck_id;\nmodule_param(vmpck_id, uint, 0444);\nMODULE_PARM_DESC(vmpck_id, \"The VMPCK ID to use when communicating with the PSP.\");\n\n \nstatic DEFINE_MUTEX(snp_cmd_mutex);\n\nstatic bool is_vmpck_empty(struct snp_guest_dev *snp_dev)\n{\n\tchar zero_key[VMPCK_KEY_LEN] = {0};\n\n\tif (snp_dev->vmpck)\n\t\treturn !memcmp(snp_dev->vmpck, zero_key, VMPCK_KEY_LEN);\n\n\treturn true;\n}\n\n \nstatic void snp_disable_vmpck(struct snp_guest_dev *snp_dev)\n{\n\tdev_alert(snp_dev->dev, \"Disabling vmpck_id %d to prevent IV reuse.\\n\",\n\t\t  vmpck_id);\n\tmemzero_explicit(snp_dev->vmpck, VMPCK_KEY_LEN);\n\tsnp_dev->vmpck = NULL;\n}\n\nstatic inline u64 __snp_get_msg_seqno(struct snp_guest_dev *snp_dev)\n{\n\tu64 count;\n\n\tlockdep_assert_held(&snp_cmd_mutex);\n\n\t \n\tcount = *snp_dev->os_area_msg_seqno;\n\n\treturn count + 1;\n}\n\n \nstatic u64 snp_get_msg_seqno(struct snp_guest_dev *snp_dev)\n{\n\tu64 count = __snp_get_msg_seqno(snp_dev);\n\n\t \n\tif (count >= UINT_MAX) {\n\t\tdev_err(snp_dev->dev, \"request message sequence counter overflow\\n\");\n\t\treturn 0;\n\t}\n\n\treturn count;\n}\n\nstatic void snp_inc_msg_seqno(struct snp_guest_dev *snp_dev)\n{\n\t \n\t*snp_dev->os_area_msg_seqno += 2;\n}\n\nstatic inline struct snp_guest_dev *to_snp_dev(struct file *file)\n{\n\tstruct miscdevice *dev = file->private_data;\n\n\treturn container_of(dev, struct snp_guest_dev, misc);\n}\n\nstatic struct snp_guest_crypto *init_crypto(struct snp_guest_dev *snp_dev, u8 *key, size_t keylen)\n{\n\tstruct snp_guest_crypto *crypto;\n\n\tcrypto = kzalloc(sizeof(*crypto), GFP_KERNEL_ACCOUNT);\n\tif (!crypto)\n\t\treturn NULL;\n\n\tcrypto->tfm = crypto_alloc_aead(\"gcm(aes)\", 0, 0);\n\tif (IS_ERR(crypto->tfm))\n\t\tgoto e_free;\n\n\tif (crypto_aead_setkey(crypto->tfm, key, keylen))\n\t\tgoto e_free_crypto;\n\n\tcrypto->iv_len = crypto_aead_ivsize(crypto->tfm);\n\tcrypto->iv = kmalloc(crypto->iv_len, GFP_KERNEL_ACCOUNT);\n\tif (!crypto->iv)\n\t\tgoto e_free_crypto;\n\n\tif (crypto_aead_authsize(crypto->tfm) > MAX_AUTHTAG_LEN) {\n\t\tif (crypto_aead_setauthsize(crypto->tfm, MAX_AUTHTAG_LEN)) {\n\t\t\tdev_err(snp_dev->dev, \"failed to set authsize to %d\\n\", MAX_AUTHTAG_LEN);\n\t\t\tgoto e_free_iv;\n\t\t}\n\t}\n\n\tcrypto->a_len = crypto_aead_authsize(crypto->tfm);\n\tcrypto->authtag = kmalloc(crypto->a_len, GFP_KERNEL_ACCOUNT);\n\tif (!crypto->authtag)\n\t\tgoto e_free_iv;\n\n\treturn crypto;\n\ne_free_iv:\n\tkfree(crypto->iv);\ne_free_crypto:\n\tcrypto_free_aead(crypto->tfm);\ne_free:\n\tkfree(crypto);\n\n\treturn NULL;\n}\n\nstatic void deinit_crypto(struct snp_guest_crypto *crypto)\n{\n\tcrypto_free_aead(crypto->tfm);\n\tkfree(crypto->iv);\n\tkfree(crypto->authtag);\n\tkfree(crypto);\n}\n\nstatic int enc_dec_message(struct snp_guest_crypto *crypto, struct snp_guest_msg *msg,\n\t\t\t   u8 *src_buf, u8 *dst_buf, size_t len, bool enc)\n{\n\tstruct snp_guest_msg_hdr *hdr = &msg->hdr;\n\tstruct scatterlist src[3], dst[3];\n\tDECLARE_CRYPTO_WAIT(wait);\n\tstruct aead_request *req;\n\tint ret;\n\n\treq = aead_request_alloc(crypto->tfm, GFP_KERNEL);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\t \n\tsg_init_table(src, 3);\n\tsg_set_buf(&src[0], &hdr->algo, AAD_LEN);\n\tsg_set_buf(&src[1], src_buf, hdr->msg_sz);\n\tsg_set_buf(&src[2], hdr->authtag, crypto->a_len);\n\n\tsg_init_table(dst, 3);\n\tsg_set_buf(&dst[0], &hdr->algo, AAD_LEN);\n\tsg_set_buf(&dst[1], dst_buf, hdr->msg_sz);\n\tsg_set_buf(&dst[2], hdr->authtag, crypto->a_len);\n\n\taead_request_set_ad(req, AAD_LEN);\n\taead_request_set_tfm(req, crypto->tfm);\n\taead_request_set_callback(req, 0, crypto_req_done, &wait);\n\n\taead_request_set_crypt(req, src, dst, len, crypto->iv);\n\tret = crypto_wait_req(enc ? crypto_aead_encrypt(req) : crypto_aead_decrypt(req), &wait);\n\n\taead_request_free(req);\n\treturn ret;\n}\n\nstatic int __enc_payload(struct snp_guest_dev *snp_dev, struct snp_guest_msg *msg,\n\t\t\t void *plaintext, size_t len)\n{\n\tstruct snp_guest_crypto *crypto = snp_dev->crypto;\n\tstruct snp_guest_msg_hdr *hdr = &msg->hdr;\n\n\tmemset(crypto->iv, 0, crypto->iv_len);\n\tmemcpy(crypto->iv, &hdr->msg_seqno, sizeof(hdr->msg_seqno));\n\n\treturn enc_dec_message(crypto, msg, plaintext, msg->payload, len, true);\n}\n\nstatic int dec_payload(struct snp_guest_dev *snp_dev, struct snp_guest_msg *msg,\n\t\t       void *plaintext, size_t len)\n{\n\tstruct snp_guest_crypto *crypto = snp_dev->crypto;\n\tstruct snp_guest_msg_hdr *hdr = &msg->hdr;\n\n\t \n\tmemset(crypto->iv, 0, crypto->iv_len);\n\tmemcpy(crypto->iv, &hdr->msg_seqno, sizeof(hdr->msg_seqno));\n\n\treturn enc_dec_message(crypto, msg, msg->payload, plaintext, len, false);\n}\n\nstatic int verify_and_dec_payload(struct snp_guest_dev *snp_dev, void *payload, u32 sz)\n{\n\tstruct snp_guest_crypto *crypto = snp_dev->crypto;\n\tstruct snp_guest_msg *resp = &snp_dev->secret_response;\n\tstruct snp_guest_msg *req = &snp_dev->secret_request;\n\tstruct snp_guest_msg_hdr *req_hdr = &req->hdr;\n\tstruct snp_guest_msg_hdr *resp_hdr = &resp->hdr;\n\n\tdev_dbg(snp_dev->dev, \"response [seqno %lld type %d version %d sz %d]\\n\",\n\t\tresp_hdr->msg_seqno, resp_hdr->msg_type, resp_hdr->msg_version, resp_hdr->msg_sz);\n\n\t \n\tmemcpy(resp, snp_dev->response, sizeof(*resp));\n\n\t \n\tif (unlikely(resp_hdr->msg_seqno != (req_hdr->msg_seqno + 1)))\n\t\treturn -EBADMSG;\n\n\t \n\tif (resp_hdr->msg_type != (req_hdr->msg_type + 1) ||\n\t    resp_hdr->msg_version != req_hdr->msg_version)\n\t\treturn -EBADMSG;\n\n\t \n\tif (unlikely((resp_hdr->msg_sz + crypto->a_len) > sz))\n\t\treturn -EBADMSG;\n\n\t \n\treturn dec_payload(snp_dev, resp, payload, resp_hdr->msg_sz + crypto->a_len);\n}\n\nstatic int enc_payload(struct snp_guest_dev *snp_dev, u64 seqno, int version, u8 type,\n\t\t\tvoid *payload, size_t sz)\n{\n\tstruct snp_guest_msg *req = &snp_dev->secret_request;\n\tstruct snp_guest_msg_hdr *hdr = &req->hdr;\n\n\tmemset(req, 0, sizeof(*req));\n\n\thdr->algo = SNP_AEAD_AES_256_GCM;\n\thdr->hdr_version = MSG_HDR_VER;\n\thdr->hdr_sz = sizeof(*hdr);\n\thdr->msg_type = type;\n\thdr->msg_version = version;\n\thdr->msg_seqno = seqno;\n\thdr->msg_vmpck = vmpck_id;\n\thdr->msg_sz = sz;\n\n\t \n\tif (!hdr->msg_seqno)\n\t\treturn -ENOSR;\n\n\tdev_dbg(snp_dev->dev, \"request [seqno %lld type %d version %d sz %d]\\n\",\n\t\thdr->msg_seqno, hdr->msg_type, hdr->msg_version, hdr->msg_sz);\n\n\treturn __enc_payload(snp_dev, req, payload, sz);\n}\n\nstatic int __handle_guest_request(struct snp_guest_dev *snp_dev, u64 exit_code,\n\t\t\t\t  struct snp_guest_request_ioctl *rio)\n{\n\tunsigned long req_start = jiffies;\n\tunsigned int override_npages = 0;\n\tu64 override_err = 0;\n\tint rc;\n\nretry_request:\n\t \n\trc = snp_issue_guest_request(exit_code, &snp_dev->input, rio);\n\tswitch (rc) {\n\tcase -ENOSPC:\n\t\t \n\t\toverride_npages = snp_dev->input.data_npages;\n\t\texit_code\t= SVM_VMGEXIT_GUEST_REQUEST;\n\n\t\t \n\t\toverride_err = SNP_GUEST_VMM_ERR(SNP_GUEST_VMM_ERR_INVALID_LEN);\n\n\t\t \n\t\tgoto retry_request;\n\n\t \n\tcase -EAGAIN:\n\t\tif (jiffies - req_start > SNP_REQ_MAX_RETRY_DURATION) {\n\t\t\trc = -ETIMEDOUT;\n\t\t\tbreak;\n\t\t}\n\t\tschedule_timeout_killable(SNP_REQ_RETRY_DELAY);\n\t\tgoto retry_request;\n\t}\n\n\t \n\tsnp_inc_msg_seqno(snp_dev);\n\n\tif (override_err) {\n\t\trio->exitinfo2 = override_err;\n\n\t\t \n\t\tif (!rc && override_err == SNP_GUEST_VMM_ERR(SNP_GUEST_VMM_ERR_INVALID_LEN))\n\t\t\trc = -EIO;\n\t}\n\n\tif (override_npages)\n\t\tsnp_dev->input.data_npages = override_npages;\n\n\treturn rc;\n}\n\nstatic int handle_guest_request(struct snp_guest_dev *snp_dev, u64 exit_code,\n\t\t\t\tstruct snp_guest_request_ioctl *rio, u8 type,\n\t\t\t\tvoid *req_buf, size_t req_sz, void *resp_buf,\n\t\t\t\tu32 resp_sz)\n{\n\tu64 seqno;\n\tint rc;\n\n\t \n\tseqno = snp_get_msg_seqno(snp_dev);\n\tif (!seqno)\n\t\treturn -EIO;\n\n\t \n\tmemset(snp_dev->response, 0, sizeof(struct snp_guest_msg));\n\n\t \n\trc = enc_payload(snp_dev, seqno, rio->msg_version, type, req_buf, req_sz);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tmemcpy(snp_dev->request, &snp_dev->secret_request,\n\t       sizeof(snp_dev->secret_request));\n\n\trc = __handle_guest_request(snp_dev, exit_code, rio);\n\tif (rc) {\n\t\tif (rc == -EIO &&\n\t\t    rio->exitinfo2 == SNP_GUEST_VMM_ERR(SNP_GUEST_VMM_ERR_INVALID_LEN))\n\t\t\treturn rc;\n\n\t\tdev_alert(snp_dev->dev,\n\t\t\t  \"Detected error from ASP request. rc: %d, exitinfo2: 0x%llx\\n\",\n\t\t\t  rc, rio->exitinfo2);\n\n\t\tsnp_disable_vmpck(snp_dev);\n\t\treturn rc;\n\t}\n\n\trc = verify_and_dec_payload(snp_dev, resp_buf, resp_sz);\n\tif (rc) {\n\t\tdev_alert(snp_dev->dev, \"Detected unexpected decode failure from ASP. rc: %d\\n\", rc);\n\t\tsnp_disable_vmpck(snp_dev);\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic int get_report(struct snp_guest_dev *snp_dev, struct snp_guest_request_ioctl *arg)\n{\n\tstruct snp_guest_crypto *crypto = snp_dev->crypto;\n\tstruct snp_report_req *req = &snp_dev->req.report;\n\tstruct snp_report_resp *resp;\n\tint rc, resp_len;\n\n\tlockdep_assert_held(&snp_cmd_mutex);\n\n\tif (!arg->req_data || !arg->resp_data)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(req, (void __user *)arg->req_data, sizeof(*req)))\n\t\treturn -EFAULT;\n\n\t \n\tresp_len = sizeof(resp->data) + crypto->a_len;\n\tresp = kzalloc(resp_len, GFP_KERNEL_ACCOUNT);\n\tif (!resp)\n\t\treturn -ENOMEM;\n\n\trc = handle_guest_request(snp_dev, SVM_VMGEXIT_GUEST_REQUEST, arg,\n\t\t\t\t  SNP_MSG_REPORT_REQ, req, sizeof(*req), resp->data,\n\t\t\t\t  resp_len);\n\tif (rc)\n\t\tgoto e_free;\n\n\tif (copy_to_user((void __user *)arg->resp_data, resp, sizeof(*resp)))\n\t\trc = -EFAULT;\n\ne_free:\n\tkfree(resp);\n\treturn rc;\n}\n\nstatic int get_derived_key(struct snp_guest_dev *snp_dev, struct snp_guest_request_ioctl *arg)\n{\n\tstruct snp_derived_key_req *req = &snp_dev->req.derived_key;\n\tstruct snp_guest_crypto *crypto = snp_dev->crypto;\n\tstruct snp_derived_key_resp resp = {0};\n\tint rc, resp_len;\n\t \n\tu8 buf[64 + 16];\n\n\tlockdep_assert_held(&snp_cmd_mutex);\n\n\tif (!arg->req_data || !arg->resp_data)\n\t\treturn -EINVAL;\n\n\t \n\tresp_len = sizeof(resp.data) + crypto->a_len;\n\tif (sizeof(buf) < resp_len)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(req, (void __user *)arg->req_data, sizeof(*req)))\n\t\treturn -EFAULT;\n\n\trc = handle_guest_request(snp_dev, SVM_VMGEXIT_GUEST_REQUEST, arg,\n\t\t\t\t  SNP_MSG_KEY_REQ, req, sizeof(*req), buf, resp_len);\n\tif (rc)\n\t\treturn rc;\n\n\tmemcpy(resp.data, buf, sizeof(resp.data));\n\tif (copy_to_user((void __user *)arg->resp_data, &resp, sizeof(resp)))\n\t\trc = -EFAULT;\n\n\t \n\tmemzero_explicit(buf, sizeof(buf));\n\tmemzero_explicit(&resp, sizeof(resp));\n\treturn rc;\n}\n\nstatic int get_ext_report(struct snp_guest_dev *snp_dev, struct snp_guest_request_ioctl *arg)\n{\n\tstruct snp_ext_report_req *req = &snp_dev->req.ext_report;\n\tstruct snp_guest_crypto *crypto = snp_dev->crypto;\n\tstruct snp_report_resp *resp;\n\tint ret, npages = 0, resp_len;\n\n\tlockdep_assert_held(&snp_cmd_mutex);\n\n\tif (!arg->req_data || !arg->resp_data)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(req, (void __user *)arg->req_data, sizeof(*req)))\n\t\treturn -EFAULT;\n\n\t \n\tif (!req->certs_len || !req->certs_address)\n\t\tgoto cmd;\n\n\tif (req->certs_len > SEV_FW_BLOB_MAX_SIZE ||\n\t    !IS_ALIGNED(req->certs_len, PAGE_SIZE))\n\t\treturn -EINVAL;\n\n\tif (!access_ok((const void __user *)req->certs_address, req->certs_len))\n\t\treturn -EFAULT;\n\n\t \n\tmemset(snp_dev->certs_data, 0, req->certs_len);\n\tnpages = req->certs_len >> PAGE_SHIFT;\ncmd:\n\t \n\tresp_len = sizeof(resp->data) + crypto->a_len;\n\tresp = kzalloc(resp_len, GFP_KERNEL_ACCOUNT);\n\tif (!resp)\n\t\treturn -ENOMEM;\n\n\tsnp_dev->input.data_npages = npages;\n\tret = handle_guest_request(snp_dev, SVM_VMGEXIT_EXT_GUEST_REQUEST, arg,\n\t\t\t\t   SNP_MSG_REPORT_REQ, &req->data,\n\t\t\t\t   sizeof(req->data), resp->data, resp_len);\n\n\t \n\tif (arg->vmm_error == SNP_GUEST_VMM_ERR_INVALID_LEN) {\n\t\treq->certs_len = snp_dev->input.data_npages << PAGE_SHIFT;\n\n\t\tif (copy_to_user((void __user *)arg->req_data, req, sizeof(*req)))\n\t\t\tret = -EFAULT;\n\t}\n\n\tif (ret)\n\t\tgoto e_free;\n\n\tif (npages &&\n\t    copy_to_user((void __user *)req->certs_address, snp_dev->certs_data,\n\t\t\t req->certs_len)) {\n\t\tret = -EFAULT;\n\t\tgoto e_free;\n\t}\n\n\tif (copy_to_user((void __user *)arg->resp_data, resp, sizeof(*resp)))\n\t\tret = -EFAULT;\n\ne_free:\n\tkfree(resp);\n\treturn ret;\n}\n\nstatic long snp_guest_ioctl(struct file *file, unsigned int ioctl, unsigned long arg)\n{\n\tstruct snp_guest_dev *snp_dev = to_snp_dev(file);\n\tvoid __user *argp = (void __user *)arg;\n\tstruct snp_guest_request_ioctl input;\n\tint ret = -ENOTTY;\n\n\tif (copy_from_user(&input, argp, sizeof(input)))\n\t\treturn -EFAULT;\n\n\tinput.exitinfo2 = 0xff;\n\n\t \n\tif (!input.msg_version)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&snp_cmd_mutex);\n\n\t \n\tif (is_vmpck_empty(snp_dev)) {\n\t\tdev_err_ratelimited(snp_dev->dev, \"VMPCK is disabled\\n\");\n\t\tmutex_unlock(&snp_cmd_mutex);\n\t\treturn -ENOTTY;\n\t}\n\n\tswitch (ioctl) {\n\tcase SNP_GET_REPORT:\n\t\tret = get_report(snp_dev, &input);\n\t\tbreak;\n\tcase SNP_GET_DERIVED_KEY:\n\t\tret = get_derived_key(snp_dev, &input);\n\t\tbreak;\n\tcase SNP_GET_EXT_REPORT:\n\t\tret = get_ext_report(snp_dev, &input);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&snp_cmd_mutex);\n\n\tif (input.exitinfo2 && copy_to_user(argp, &input, sizeof(input)))\n\t\treturn -EFAULT;\n\n\treturn ret;\n}\n\nstatic void free_shared_pages(void *buf, size_t sz)\n{\n\tunsigned int npages = PAGE_ALIGN(sz) >> PAGE_SHIFT;\n\tint ret;\n\n\tif (!buf)\n\t\treturn;\n\n\tret = set_memory_encrypted((unsigned long)buf, npages);\n\tif (ret) {\n\t\tWARN_ONCE(ret, \"failed to restore encryption mask (leak it)\\n\");\n\t\treturn;\n\t}\n\n\t__free_pages(virt_to_page(buf), get_order(sz));\n}\n\nstatic void *alloc_shared_pages(struct device *dev, size_t sz)\n{\n\tunsigned int npages = PAGE_ALIGN(sz) >> PAGE_SHIFT;\n\tstruct page *page;\n\tint ret;\n\n\tpage = alloc_pages(GFP_KERNEL_ACCOUNT, get_order(sz));\n\tif (!page)\n\t\treturn NULL;\n\n\tret = set_memory_decrypted((unsigned long)page_address(page), npages);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to mark page shared, ret=%d\\n\", ret);\n\t\t__free_pages(page, get_order(sz));\n\t\treturn NULL;\n\t}\n\n\treturn page_address(page);\n}\n\nstatic const struct file_operations snp_guest_fops = {\n\t.owner\t= THIS_MODULE,\n\t.unlocked_ioctl = snp_guest_ioctl,\n};\n\nstatic u8 *get_vmpck(int id, struct snp_secrets_page_layout *layout, u32 **seqno)\n{\n\tu8 *key = NULL;\n\n\tswitch (id) {\n\tcase 0:\n\t\t*seqno = &layout->os_area.msg_seqno_0;\n\t\tkey = layout->vmpck0;\n\t\tbreak;\n\tcase 1:\n\t\t*seqno = &layout->os_area.msg_seqno_1;\n\t\tkey = layout->vmpck1;\n\t\tbreak;\n\tcase 2:\n\t\t*seqno = &layout->os_area.msg_seqno_2;\n\t\tkey = layout->vmpck2;\n\t\tbreak;\n\tcase 3:\n\t\t*seqno = &layout->os_area.msg_seqno_3;\n\t\tkey = layout->vmpck3;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn key;\n}\n\nstatic int __init sev_guest_probe(struct platform_device *pdev)\n{\n\tstruct snp_secrets_page_layout *layout;\n\tstruct sev_guest_platform_data *data;\n\tstruct device *dev = &pdev->dev;\n\tstruct snp_guest_dev *snp_dev;\n\tstruct miscdevice *misc;\n\tvoid __iomem *mapping;\n\tint ret;\n\n\tif (!cc_platform_has(CC_ATTR_GUEST_SEV_SNP))\n\t\treturn -ENODEV;\n\n\tif (!dev->platform_data)\n\t\treturn -ENODEV;\n\n\tdata = (struct sev_guest_platform_data *)dev->platform_data;\n\tmapping = ioremap_encrypted(data->secrets_gpa, PAGE_SIZE);\n\tif (!mapping)\n\t\treturn -ENODEV;\n\n\tlayout = (__force void *)mapping;\n\n\tret = -ENOMEM;\n\tsnp_dev = devm_kzalloc(&pdev->dev, sizeof(struct snp_guest_dev), GFP_KERNEL);\n\tif (!snp_dev)\n\t\tgoto e_unmap;\n\n\tret = -EINVAL;\n\tsnp_dev->vmpck = get_vmpck(vmpck_id, layout, &snp_dev->os_area_msg_seqno);\n\tif (!snp_dev->vmpck) {\n\t\tdev_err(dev, \"invalid vmpck id %d\\n\", vmpck_id);\n\t\tgoto e_unmap;\n\t}\n\n\t \n\tif (is_vmpck_empty(snp_dev)) {\n\t\tdev_err(dev, \"vmpck id %d is null\\n\", vmpck_id);\n\t\tgoto e_unmap;\n\t}\n\n\tplatform_set_drvdata(pdev, snp_dev);\n\tsnp_dev->dev = dev;\n\tsnp_dev->layout = layout;\n\n\t \n\tsnp_dev->request = alloc_shared_pages(dev, sizeof(struct snp_guest_msg));\n\tif (!snp_dev->request)\n\t\tgoto e_unmap;\n\n\tsnp_dev->response = alloc_shared_pages(dev, sizeof(struct snp_guest_msg));\n\tif (!snp_dev->response)\n\t\tgoto e_free_request;\n\n\tsnp_dev->certs_data = alloc_shared_pages(dev, SEV_FW_BLOB_MAX_SIZE);\n\tif (!snp_dev->certs_data)\n\t\tgoto e_free_response;\n\n\tret = -EIO;\n\tsnp_dev->crypto = init_crypto(snp_dev, snp_dev->vmpck, VMPCK_KEY_LEN);\n\tif (!snp_dev->crypto)\n\t\tgoto e_free_cert_data;\n\n\tmisc = &snp_dev->misc;\n\tmisc->minor = MISC_DYNAMIC_MINOR;\n\tmisc->name = DEVICE_NAME;\n\tmisc->fops = &snp_guest_fops;\n\n\t \n\tsnp_dev->input.req_gpa = __pa(snp_dev->request);\n\tsnp_dev->input.resp_gpa = __pa(snp_dev->response);\n\tsnp_dev->input.data_gpa = __pa(snp_dev->certs_data);\n\n\tret =  misc_register(misc);\n\tif (ret)\n\t\tgoto e_free_cert_data;\n\n\tdev_info(dev, \"Initialized SEV guest driver (using vmpck_id %d)\\n\", vmpck_id);\n\treturn 0;\n\ne_free_cert_data:\n\tfree_shared_pages(snp_dev->certs_data, SEV_FW_BLOB_MAX_SIZE);\ne_free_response:\n\tfree_shared_pages(snp_dev->response, sizeof(struct snp_guest_msg));\ne_free_request:\n\tfree_shared_pages(snp_dev->request, sizeof(struct snp_guest_msg));\ne_unmap:\n\tiounmap(mapping);\n\treturn ret;\n}\n\nstatic int __exit sev_guest_remove(struct platform_device *pdev)\n{\n\tstruct snp_guest_dev *snp_dev = platform_get_drvdata(pdev);\n\n\tfree_shared_pages(snp_dev->certs_data, SEV_FW_BLOB_MAX_SIZE);\n\tfree_shared_pages(snp_dev->response, sizeof(struct snp_guest_msg));\n\tfree_shared_pages(snp_dev->request, sizeof(struct snp_guest_msg));\n\tdeinit_crypto(snp_dev->crypto);\n\tmisc_deregister(&snp_dev->misc);\n\n\treturn 0;\n}\n\n \nstatic struct platform_driver sev_guest_driver = {\n\t.remove\t\t= __exit_p(sev_guest_remove),\n\t.driver\t\t= {\n\t\t.name = \"sev-guest\",\n\t},\n};\n\nmodule_platform_driver_probe(sev_guest_driver, sev_guest_probe);\n\nMODULE_AUTHOR(\"Brijesh Singh <brijesh.singh@amd.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(\"1.0.0\");\nMODULE_DESCRIPTION(\"AMD SEV Guest Driver\");\nMODULE_ALIAS(\"platform:sev-guest\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}