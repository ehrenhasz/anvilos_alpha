{
  "module_name": "irqfd.c",
  "hash_id": "7f270c3156e5dbdf022182257162c9b2e17a421ce1ded4ae82e2662bce42681f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/virt/acrn/irqfd.c",
  "human_readable_source": "\n \n\n#include <linux/eventfd.h>\n#include <linux/file.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\n#include \"acrn_drv.h\"\n\nstatic LIST_HEAD(acrn_irqfd_clients);\n\n \nstruct hsm_irqfd {\n\tstruct acrn_vm\t\t*vm;\n\twait_queue_entry_t\twait;\n\tstruct work_struct\tshutdown;\n\tstruct eventfd_ctx\t*eventfd;\n\tstruct list_head\tlist;\n\tpoll_table\t\tpt;\n\tstruct acrn_msi_entry\tmsi;\n};\n\nstatic void acrn_irqfd_inject(struct hsm_irqfd *irqfd)\n{\n\tstruct acrn_vm *vm = irqfd->vm;\n\n\tacrn_msi_inject(vm, irqfd->msi.msi_addr,\n\t\t\tirqfd->msi.msi_data);\n}\n\nstatic void hsm_irqfd_shutdown(struct hsm_irqfd *irqfd)\n{\n\tu64 cnt;\n\n\tlockdep_assert_held(&irqfd->vm->irqfds_lock);\n\n\t \n\tlist_del_init(&irqfd->list);\n\teventfd_ctx_remove_wait_queue(irqfd->eventfd, &irqfd->wait, &cnt);\n\teventfd_ctx_put(irqfd->eventfd);\n\tkfree(irqfd);\n}\n\nstatic void hsm_irqfd_shutdown_work(struct work_struct *work)\n{\n\tstruct hsm_irqfd *irqfd;\n\tstruct acrn_vm *vm;\n\n\tirqfd = container_of(work, struct hsm_irqfd, shutdown);\n\tvm = irqfd->vm;\n\tmutex_lock(&vm->irqfds_lock);\n\tif (!list_empty(&irqfd->list))\n\t\thsm_irqfd_shutdown(irqfd);\n\tmutex_unlock(&vm->irqfds_lock);\n}\n\n \nstatic int hsm_irqfd_wakeup(wait_queue_entry_t *wait, unsigned int mode,\n\t\t\t    int sync, void *key)\n{\n\tunsigned long poll_bits = (unsigned long)key;\n\tstruct hsm_irqfd *irqfd;\n\tstruct acrn_vm *vm;\n\n\tirqfd = container_of(wait, struct hsm_irqfd, wait);\n\tvm = irqfd->vm;\n\tif (poll_bits & POLLIN)\n\t\t \n\t\tacrn_irqfd_inject(irqfd);\n\n\tif (poll_bits & POLLHUP)\n\t\t \n\t\tqueue_work(vm->irqfd_wq, &irqfd->shutdown);\n\n\treturn 0;\n}\n\nstatic void hsm_irqfd_poll_func(struct file *file, wait_queue_head_t *wqh,\n\t\t\t\tpoll_table *pt)\n{\n\tstruct hsm_irqfd *irqfd;\n\n\tirqfd = container_of(pt, struct hsm_irqfd, pt);\n\tadd_wait_queue(wqh, &irqfd->wait);\n}\n\n \nstatic int acrn_irqfd_assign(struct acrn_vm *vm, struct acrn_irqfd *args)\n{\n\tstruct eventfd_ctx *eventfd = NULL;\n\tstruct hsm_irqfd *irqfd, *tmp;\n\t__poll_t events;\n\tstruct fd f;\n\tint ret = 0;\n\n\tirqfd = kzalloc(sizeof(*irqfd), GFP_KERNEL);\n\tif (!irqfd)\n\t\treturn -ENOMEM;\n\n\tirqfd->vm = vm;\n\tmemcpy(&irqfd->msi, &args->msi, sizeof(args->msi));\n\tINIT_LIST_HEAD(&irqfd->list);\n\tINIT_WORK(&irqfd->shutdown, hsm_irqfd_shutdown_work);\n\n\tf = fdget(args->fd);\n\tif (!f.file) {\n\t\tret = -EBADF;\n\t\tgoto out;\n\t}\n\n\teventfd = eventfd_ctx_fileget(f.file);\n\tif (IS_ERR(eventfd)) {\n\t\tret = PTR_ERR(eventfd);\n\t\tgoto fail;\n\t}\n\n\tirqfd->eventfd = eventfd;\n\n\t \n\tinit_waitqueue_func_entry(&irqfd->wait, hsm_irqfd_wakeup);\n\tinit_poll_funcptr(&irqfd->pt, hsm_irqfd_poll_func);\n\n\tmutex_lock(&vm->irqfds_lock);\n\tlist_for_each_entry(tmp, &vm->irqfds, list) {\n\t\tif (irqfd->eventfd != tmp->eventfd)\n\t\t\tcontinue;\n\t\tret = -EBUSY;\n\t\tmutex_unlock(&vm->irqfds_lock);\n\t\tgoto fail;\n\t}\n\tlist_add_tail(&irqfd->list, &vm->irqfds);\n\tmutex_unlock(&vm->irqfds_lock);\n\n\t \n\tevents = vfs_poll(f.file, &irqfd->pt);\n\n\tif (events & EPOLLIN)\n\t\tacrn_irqfd_inject(irqfd);\n\n\tfdput(f);\n\treturn 0;\nfail:\n\tif (eventfd && !IS_ERR(eventfd))\n\t\teventfd_ctx_put(eventfd);\n\n\tfdput(f);\nout:\n\tkfree(irqfd);\n\treturn ret;\n}\n\nstatic int acrn_irqfd_deassign(struct acrn_vm *vm,\n\t\t\t       struct acrn_irqfd *args)\n{\n\tstruct hsm_irqfd *irqfd, *tmp;\n\tstruct eventfd_ctx *eventfd;\n\n\teventfd = eventfd_ctx_fdget(args->fd);\n\tif (IS_ERR(eventfd))\n\t\treturn PTR_ERR(eventfd);\n\n\tmutex_lock(&vm->irqfds_lock);\n\tlist_for_each_entry_safe(irqfd, tmp, &vm->irqfds, list) {\n\t\tif (irqfd->eventfd == eventfd) {\n\t\t\thsm_irqfd_shutdown(irqfd);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&vm->irqfds_lock);\n\teventfd_ctx_put(eventfd);\n\n\treturn 0;\n}\n\nint acrn_irqfd_config(struct acrn_vm *vm, struct acrn_irqfd *args)\n{\n\tint ret;\n\n\tif (args->flags & ACRN_IRQFD_FLAG_DEASSIGN)\n\t\tret = acrn_irqfd_deassign(vm, args);\n\telse\n\t\tret = acrn_irqfd_assign(vm, args);\n\n\treturn ret;\n}\n\nint acrn_irqfd_init(struct acrn_vm *vm)\n{\n\tINIT_LIST_HEAD(&vm->irqfds);\n\tmutex_init(&vm->irqfds_lock);\n\tvm->irqfd_wq = alloc_workqueue(\"acrn_irqfd-%u\", 0, 0, vm->vmid);\n\tif (!vm->irqfd_wq)\n\t\treturn -ENOMEM;\n\n\tdev_dbg(acrn_dev.this_device, \"VM %u irqfd init.\\n\", vm->vmid);\n\treturn 0;\n}\n\nvoid acrn_irqfd_deinit(struct acrn_vm *vm)\n{\n\tstruct hsm_irqfd *irqfd, *next;\n\n\tdev_dbg(acrn_dev.this_device, \"VM %u irqfd deinit.\\n\", vm->vmid);\n\tdestroy_workqueue(vm->irqfd_wq);\n\tmutex_lock(&vm->irqfds_lock);\n\tlist_for_each_entry_safe(irqfd, next, &vm->irqfds, list)\n\t\thsm_irqfd_shutdown(irqfd);\n\tmutex_unlock(&vm->irqfds_lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}