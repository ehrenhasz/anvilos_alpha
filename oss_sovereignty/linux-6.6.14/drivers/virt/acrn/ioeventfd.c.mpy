{
  "module_name": "ioeventfd.c",
  "hash_id": "eaaa821dfe7ff76b45b2045d374f1b6d364502063b0b210dee71fac66d23f65d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/virt/acrn/ioeventfd.c",
  "human_readable_source": "\n \n\n#include <linux/eventfd.h>\n#include <linux/slab.h>\n\n#include \"acrn_drv.h\"\n\n \nstruct hsm_ioeventfd {\n\tstruct list_head\tlist;\n\tstruct eventfd_ctx\t*eventfd;\n\tu64\t\t\taddr;\n\tu64\t\t\tdata;\n\tint\t\t\tlength;\n\tint\t\t\ttype;\n\tbool\t\t\twildcard;\n};\n\nstatic inline int ioreq_type_from_flags(int flags)\n{\n\treturn flags & ACRN_IOEVENTFD_FLAG_PIO ?\n\t\t       ACRN_IOREQ_TYPE_PORTIO : ACRN_IOREQ_TYPE_MMIO;\n}\n\nstatic void acrn_ioeventfd_shutdown(struct acrn_vm *vm, struct hsm_ioeventfd *p)\n{\n\tlockdep_assert_held(&vm->ioeventfds_lock);\n\n\teventfd_ctx_put(p->eventfd);\n\tlist_del(&p->list);\n\tkfree(p);\n}\n\nstatic bool hsm_ioeventfd_is_conflict(struct acrn_vm *vm,\n\t\t\t\t      struct hsm_ioeventfd *ioeventfd)\n{\n\tstruct hsm_ioeventfd *p;\n\n\tlockdep_assert_held(&vm->ioeventfds_lock);\n\n\t \n\tlist_for_each_entry(p, &vm->ioeventfds, list)\n\t\tif (p->eventfd == ioeventfd->eventfd &&\n\t\t    p->addr == ioeventfd->addr &&\n\t\t    p->type == ioeventfd->type &&\n\t\t    (p->wildcard || ioeventfd->wildcard ||\n\t\t\tp->data == ioeventfd->data))\n\t\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic int acrn_ioeventfd_assign(struct acrn_vm *vm,\n\t\t\t\t struct acrn_ioeventfd *args)\n{\n\tstruct eventfd_ctx *eventfd;\n\tstruct hsm_ioeventfd *p;\n\tint ret;\n\n\t \n\tif (args->addr + args->len < args->addr)\n\t\treturn -EINVAL;\n\n\t \n\tif (!(args->len == 1 || args->len == 2 ||\n\t      args->len == 4 || args->len == 8))\n\t\treturn -EINVAL;\n\n\teventfd = eventfd_ctx_fdget(args->fd);\n\tif (IS_ERR(eventfd))\n\t\treturn PTR_ERR(eventfd);\n\n\tp = kzalloc(sizeof(*p), GFP_KERNEL);\n\tif (!p) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tINIT_LIST_HEAD(&p->list);\n\tp->addr = args->addr;\n\tp->length = args->len;\n\tp->eventfd = eventfd;\n\tp->type = ioreq_type_from_flags(args->flags);\n\n\t \n\tif (args->flags & ACRN_IOEVENTFD_FLAG_DATAMATCH)\n\t\tp->data = args->data;\n\telse\n\t\tp->wildcard = true;\n\n\tmutex_lock(&vm->ioeventfds_lock);\n\n\tif (hsm_ioeventfd_is_conflict(vm, p)) {\n\t\tret = -EEXIST;\n\t\tgoto unlock_fail;\n\t}\n\n\t \n\tret = acrn_ioreq_range_add(vm->ioeventfd_client, p->type,\n\t\t\t\t   p->addr, p->addr + p->length - 1);\n\tif (ret < 0)\n\t\tgoto unlock_fail;\n\n\tlist_add_tail(&p->list, &vm->ioeventfds);\n\tmutex_unlock(&vm->ioeventfds_lock);\n\n\treturn 0;\n\nunlock_fail:\n\tmutex_unlock(&vm->ioeventfds_lock);\n\tkfree(p);\nfail:\n\teventfd_ctx_put(eventfd);\n\treturn ret;\n}\n\nstatic int acrn_ioeventfd_deassign(struct acrn_vm *vm,\n\t\t\t\t   struct acrn_ioeventfd *args)\n{\n\tstruct hsm_ioeventfd *p;\n\tstruct eventfd_ctx *eventfd;\n\n\teventfd = eventfd_ctx_fdget(args->fd);\n\tif (IS_ERR(eventfd))\n\t\treturn PTR_ERR(eventfd);\n\n\tmutex_lock(&vm->ioeventfds_lock);\n\tlist_for_each_entry(p, &vm->ioeventfds, list) {\n\t\tif (p->eventfd != eventfd)\n\t\t\tcontinue;\n\n\t\tacrn_ioreq_range_del(vm->ioeventfd_client, p->type,\n\t\t\t\t     p->addr, p->addr + p->length - 1);\n\t\tacrn_ioeventfd_shutdown(vm, p);\n\t\tbreak;\n\t}\n\tmutex_unlock(&vm->ioeventfds_lock);\n\n\teventfd_ctx_put(eventfd);\n\treturn 0;\n}\n\nstatic struct hsm_ioeventfd *hsm_ioeventfd_match(struct acrn_vm *vm, u64 addr,\n\t\t\t\t\t\t u64 data, int len, int type)\n{\n\tstruct hsm_ioeventfd *p = NULL;\n\n\tlockdep_assert_held(&vm->ioeventfds_lock);\n\n\tlist_for_each_entry(p, &vm->ioeventfds, list) {\n\t\tif (p->type == type && p->addr == addr && p->length >= len &&\n\t\t    (p->wildcard || p->data == data))\n\t\t\treturn p;\n\t}\n\n\treturn NULL;\n}\n\nstatic int acrn_ioeventfd_handler(struct acrn_ioreq_client *client,\n\t\t\t\t  struct acrn_io_request *req)\n{\n\tstruct hsm_ioeventfd *p;\n\tu64 addr, val;\n\tint size;\n\n\tif (req->type == ACRN_IOREQ_TYPE_MMIO) {\n\t\t \n\t\tif (req->reqs.mmio_request.direction == ACRN_IOREQ_DIR_READ) {\n\t\t\t \n\t\t\treq->reqs.mmio_request.value = 0;\n\t\t\treturn 0;\n\t\t}\n\t\taddr = req->reqs.mmio_request.address;\n\t\tsize = req->reqs.mmio_request.size;\n\t\tval = req->reqs.mmio_request.value;\n\t} else {\n\t\tif (req->reqs.pio_request.direction == ACRN_IOREQ_DIR_READ) {\n\t\t\t \n\t\t\treq->reqs.pio_request.value = 0;\n\t\t\treturn 0;\n\t\t}\n\t\taddr = req->reqs.pio_request.address;\n\t\tsize = req->reqs.pio_request.size;\n\t\tval = req->reqs.pio_request.value;\n\t}\n\n\tmutex_lock(&client->vm->ioeventfds_lock);\n\tp = hsm_ioeventfd_match(client->vm, addr, val, size, req->type);\n\tif (p)\n\t\teventfd_signal(p->eventfd, 1);\n\tmutex_unlock(&client->vm->ioeventfds_lock);\n\n\treturn 0;\n}\n\nint acrn_ioeventfd_config(struct acrn_vm *vm, struct acrn_ioeventfd *args)\n{\n\tint ret;\n\n\tif (args->flags & ACRN_IOEVENTFD_FLAG_DEASSIGN)\n\t\tret = acrn_ioeventfd_deassign(vm, args);\n\telse\n\t\tret = acrn_ioeventfd_assign(vm, args);\n\n\treturn ret;\n}\n\nint acrn_ioeventfd_init(struct acrn_vm *vm)\n{\n\tchar name[ACRN_NAME_LEN];\n\n\tmutex_init(&vm->ioeventfds_lock);\n\tINIT_LIST_HEAD(&vm->ioeventfds);\n\tsnprintf(name, sizeof(name), \"ioeventfd-%u\", vm->vmid);\n\tvm->ioeventfd_client = acrn_ioreq_client_create(vm,\n\t\t\t\t\t\t\tacrn_ioeventfd_handler,\n\t\t\t\t\t\t\tNULL, false, name);\n\tif (!vm->ioeventfd_client) {\n\t\tdev_err(acrn_dev.this_device, \"Failed to create ioeventfd ioreq client!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(acrn_dev.this_device, \"VM %u ioeventfd init.\\n\", vm->vmid);\n\treturn 0;\n}\n\nvoid acrn_ioeventfd_deinit(struct acrn_vm *vm)\n{\n\tstruct hsm_ioeventfd *p, *next;\n\n\tdev_dbg(acrn_dev.this_device, \"VM %u ioeventfd deinit.\\n\", vm->vmid);\n\tacrn_ioreq_client_destroy(vm->ioeventfd_client);\n\tmutex_lock(&vm->ioeventfds_lock);\n\tlist_for_each_entry_safe(p, next, &vm->ioeventfds, list)\n\t\tacrn_ioeventfd_shutdown(vm, p);\n\tmutex_unlock(&vm->ioeventfds_lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}