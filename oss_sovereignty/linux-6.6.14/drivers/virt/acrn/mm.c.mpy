{
  "module_name": "mm.c",
  "hash_id": "70c919f5603a87cb969762e8531cbfb67af51e87e30bf80b87108c9924eb54ff",
  "original_prompt": "Ingested from linux-6.6.14/drivers/virt/acrn/mm.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n\n#include \"acrn_drv.h\"\n\nstatic int modify_region(struct acrn_vm *vm, struct vm_memory_region_op *region)\n{\n\tstruct vm_memory_region_batch *regions;\n\tint ret;\n\n\tregions = kzalloc(sizeof(*regions), GFP_KERNEL);\n\tif (!regions)\n\t\treturn -ENOMEM;\n\n\tregions->vmid = vm->vmid;\n\tregions->regions_num = 1;\n\tregions->regions_gpa = virt_to_phys(region);\n\n\tret = hcall_set_memory_regions(virt_to_phys(regions));\n\tif (ret < 0)\n\t\tdev_dbg(acrn_dev.this_device,\n\t\t\t\"Failed to set memory region for VM[%u]!\\n\", vm->vmid);\n\n\tkfree(regions);\n\treturn ret;\n}\n\n \nint acrn_mm_region_add(struct acrn_vm *vm, u64 user_gpa, u64 service_gpa,\n\t\t       u64 size, u32 mem_type, u32 mem_access_right)\n{\n\tstruct vm_memory_region_op *region;\n\tint ret = 0;\n\n\tregion = kzalloc(sizeof(*region), GFP_KERNEL);\n\tif (!region)\n\t\treturn -ENOMEM;\n\n\tregion->type = ACRN_MEM_REGION_ADD;\n\tregion->user_vm_pa = user_gpa;\n\tregion->service_vm_pa = service_gpa;\n\tregion->size = size;\n\tregion->attr = ((mem_type & ACRN_MEM_TYPE_MASK) |\n\t\t\t(mem_access_right & ACRN_MEM_ACCESS_RIGHT_MASK));\n\tret = modify_region(vm, region);\n\n\tdev_dbg(acrn_dev.this_device,\n\t\t\"%s: user-GPA[%pK] service-GPA[%pK] size[0x%llx].\\n\",\n\t\t__func__, (void *)user_gpa, (void *)service_gpa, size);\n\tkfree(region);\n\treturn ret;\n}\n\n \nint acrn_mm_region_del(struct acrn_vm *vm, u64 user_gpa, u64 size)\n{\n\tstruct vm_memory_region_op *region;\n\tint ret = 0;\n\n\tregion = kzalloc(sizeof(*region), GFP_KERNEL);\n\tif (!region)\n\t\treturn -ENOMEM;\n\n\tregion->type = ACRN_MEM_REGION_DEL;\n\tregion->user_vm_pa = user_gpa;\n\tregion->service_vm_pa = 0UL;\n\tregion->size = size;\n\tregion->attr = 0U;\n\n\tret = modify_region(vm, region);\n\n\tdev_dbg(acrn_dev.this_device, \"%s: user-GPA[%pK] size[0x%llx].\\n\",\n\t\t__func__, (void *)user_gpa, size);\n\tkfree(region);\n\treturn ret;\n}\n\nint acrn_vm_memseg_map(struct acrn_vm *vm, struct acrn_vm_memmap *memmap)\n{\n\tint ret;\n\n\tif (memmap->type == ACRN_MEMMAP_RAM)\n\t\treturn acrn_vm_ram_map(vm, memmap);\n\n\tif (memmap->type != ACRN_MEMMAP_MMIO) {\n\t\tdev_dbg(acrn_dev.this_device,\n\t\t\t\"Invalid memmap type: %u\\n\", memmap->type);\n\t\treturn -EINVAL;\n\t}\n\n\tret = acrn_mm_region_add(vm, memmap->user_vm_pa,\n\t\t\t\t memmap->service_vm_pa, memmap->len,\n\t\t\t\t ACRN_MEM_TYPE_UC, memmap->attr);\n\tif (ret < 0)\n\t\tdev_dbg(acrn_dev.this_device,\n\t\t\t\"Add memory region failed, VM[%u]!\\n\", vm->vmid);\n\n\treturn ret;\n}\n\nint acrn_vm_memseg_unmap(struct acrn_vm *vm, struct acrn_vm_memmap *memmap)\n{\n\tint ret;\n\n\tif (memmap->type != ACRN_MEMMAP_MMIO) {\n\t\tdev_dbg(acrn_dev.this_device,\n\t\t\t\"Invalid memmap type: %u\\n\", memmap->type);\n\t\treturn -EINVAL;\n\t}\n\n\tret = acrn_mm_region_del(vm, memmap->user_vm_pa, memmap->len);\n\tif (ret < 0)\n\t\tdev_dbg(acrn_dev.this_device,\n\t\t\t\"Del memory region failed, VM[%u]!\\n\", vm->vmid);\n\n\treturn ret;\n}\n\n \nint acrn_vm_ram_map(struct acrn_vm *vm, struct acrn_vm_memmap *memmap)\n{\n\tstruct vm_memory_region_batch *regions_info;\n\tint nr_pages, i = 0, order, nr_regions = 0;\n\tstruct vm_memory_mapping *region_mapping;\n\tstruct vm_memory_region_op *vm_region;\n\tstruct page **pages = NULL, *page;\n\tvoid *remap_vaddr;\n\tint ret, pinned;\n\tu64 user_vm_pa;\n\tunsigned long pfn;\n\tstruct vm_area_struct *vma;\n\n\tif (!vm || !memmap)\n\t\treturn -EINVAL;\n\n\tmmap_read_lock(current->mm);\n\tvma = vma_lookup(current->mm, memmap->vma_base);\n\tif (vma && ((vma->vm_flags & VM_PFNMAP) != 0)) {\n\t\tif ((memmap->vma_base + memmap->len) > vma->vm_end) {\n\t\t\tmmap_read_unlock(current->mm);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = follow_pfn(vma, memmap->vma_base, &pfn);\n\t\tmmap_read_unlock(current->mm);\n\t\tif (ret < 0) {\n\t\t\tdev_dbg(acrn_dev.this_device,\n\t\t\t\t\"Failed to lookup PFN at VMA:%pK.\\n\", (void *)memmap->vma_base);\n\t\t\treturn ret;\n\t\t}\n\n\t\treturn acrn_mm_region_add(vm, memmap->user_vm_pa,\n\t\t\t PFN_PHYS(pfn), memmap->len,\n\t\t\t ACRN_MEM_TYPE_WB, memmap->attr);\n\t}\n\tmmap_read_unlock(current->mm);\n\n\t \n\tnr_pages = memmap->len >> PAGE_SHIFT;\n\tpages = vzalloc(array_size(nr_pages, sizeof(*pages)));\n\tif (!pages)\n\t\treturn -ENOMEM;\n\n\t \n\tpinned = pin_user_pages_fast(memmap->vma_base,\n\t\t\t\t     nr_pages, FOLL_WRITE | FOLL_LONGTERM,\n\t\t\t\t     pages);\n\tif (pinned < 0) {\n\t\tret = pinned;\n\t\tgoto free_pages;\n\t} else if (pinned != nr_pages) {\n\t\tret = -EFAULT;\n\t\tgoto put_pages;\n\t}\n\n\t \n\tremap_vaddr = vmap(pages, nr_pages, VM_MAP, PAGE_KERNEL);\n\tif (!remap_vaddr) {\n\t\tret = -ENOMEM;\n\t\tgoto put_pages;\n\t}\n\n\t \n\tmutex_lock(&vm->regions_mapping_lock);\n\tregion_mapping = &vm->regions_mapping[vm->regions_mapping_count];\n\tif (vm->regions_mapping_count < ACRN_MEM_MAPPING_MAX) {\n\t\tregion_mapping->pages = pages;\n\t\tregion_mapping->npages = nr_pages;\n\t\tregion_mapping->size = memmap->len;\n\t\tregion_mapping->service_vm_va = remap_vaddr;\n\t\tregion_mapping->user_vm_pa = memmap->user_vm_pa;\n\t\tvm->regions_mapping_count++;\n\t} else {\n\t\tdev_warn(acrn_dev.this_device,\n\t\t\t\"Run out of memory mapping slots!\\n\");\n\t\tret = -ENOMEM;\n\t\tmutex_unlock(&vm->regions_mapping_lock);\n\t\tgoto unmap_no_count;\n\t}\n\tmutex_unlock(&vm->regions_mapping_lock);\n\n\t \n\twhile (i < nr_pages) {\n\t\tpage = pages[i];\n\t\tVM_BUG_ON_PAGE(PageTail(page), page);\n\t\torder = compound_order(page);\n\t\tnr_regions++;\n\t\ti += 1 << order;\n\t}\n\n\t \n\tregions_info = kzalloc(struct_size(regions_info, regions_op,\n\t\t\t\t\t   nr_regions), GFP_KERNEL);\n\tif (!regions_info) {\n\t\tret = -ENOMEM;\n\t\tgoto unmap_kernel_map;\n\t}\n\n\t \n\tvm_region = regions_info->regions_op;\n\tregions_info->vmid = vm->vmid;\n\tregions_info->regions_num = nr_regions;\n\tregions_info->regions_gpa = virt_to_phys(vm_region);\n\tuser_vm_pa = memmap->user_vm_pa;\n\ti = 0;\n\twhile (i < nr_pages) {\n\t\tu32 region_size;\n\n\t\tpage = pages[i];\n\t\tVM_BUG_ON_PAGE(PageTail(page), page);\n\t\torder = compound_order(page);\n\t\tregion_size = PAGE_SIZE << order;\n\t\tvm_region->type = ACRN_MEM_REGION_ADD;\n\t\tvm_region->user_vm_pa = user_vm_pa;\n\t\tvm_region->service_vm_pa = page_to_phys(page);\n\t\tvm_region->size = region_size;\n\t\tvm_region->attr = (ACRN_MEM_TYPE_WB & ACRN_MEM_TYPE_MASK) |\n\t\t\t\t  (memmap->attr & ACRN_MEM_ACCESS_RIGHT_MASK);\n\n\t\tvm_region++;\n\t\tuser_vm_pa += region_size;\n\t\ti += 1 << order;\n\t}\n\n\t \n\tret = hcall_set_memory_regions(virt_to_phys(regions_info));\n\tif (ret < 0) {\n\t\tdev_dbg(acrn_dev.this_device,\n\t\t\t\"Failed to set regions, VM[%u]!\\n\", vm->vmid);\n\t\tgoto unset_region;\n\t}\n\tkfree(regions_info);\n\n\tdev_dbg(acrn_dev.this_device,\n\t\t\"%s: VM[%u] service-GVA[%pK] user-GPA[%pK] size[0x%llx]\\n\",\n\t\t__func__, vm->vmid,\n\t\tremap_vaddr, (void *)memmap->user_vm_pa, memmap->len);\n\treturn ret;\n\nunset_region:\n\tkfree(regions_info);\nunmap_kernel_map:\n\tmutex_lock(&vm->regions_mapping_lock);\n\tvm->regions_mapping_count--;\n\tmutex_unlock(&vm->regions_mapping_lock);\nunmap_no_count:\n\tvunmap(remap_vaddr);\nput_pages:\n\tfor (i = 0; i < pinned; i++)\n\t\tunpin_user_page(pages[i]);\nfree_pages:\n\tvfree(pages);\n\treturn ret;\n}\n\n \nvoid acrn_vm_all_ram_unmap(struct acrn_vm *vm)\n{\n\tstruct vm_memory_mapping *region_mapping;\n\tint i, j;\n\n\tmutex_lock(&vm->regions_mapping_lock);\n\tfor (i = 0; i < vm->regions_mapping_count; i++) {\n\t\tregion_mapping = &vm->regions_mapping[i];\n\t\tvunmap(region_mapping->service_vm_va);\n\t\tfor (j = 0; j < region_mapping->npages; j++)\n\t\t\tunpin_user_page(region_mapping->pages[j]);\n\t\tvfree(region_mapping->pages);\n\t}\n\tmutex_unlock(&vm->regions_mapping_lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}