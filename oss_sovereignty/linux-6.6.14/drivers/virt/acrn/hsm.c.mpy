{
  "module_name": "hsm.c",
  "hash_id": "bb25bfe8e7b9f704eb25e0711742cfb7b02fea61861b87171271cb1abd04779d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/virt/acrn/hsm.c",
  "human_readable_source": "\n \n\n#include <linux/cpu.h>\n#include <linux/io.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include <asm/acrn.h>\n#include <asm/hypervisor.h>\n\n#include \"acrn_drv.h\"\n\n \nstatic int acrn_dev_open(struct inode *inode, struct file *filp)\n{\n\tstruct acrn_vm *vm;\n\n\tvm = kzalloc(sizeof(*vm), GFP_KERNEL);\n\tif (!vm)\n\t\treturn -ENOMEM;\n\n\tvm->vmid = ACRN_INVALID_VMID;\n\tfilp->private_data = vm;\n\treturn 0;\n}\n\nstatic int pmcmd_ioctl(u64 cmd, void __user *uptr)\n{\n\tstruct acrn_pstate_data *px_data;\n\tstruct acrn_cstate_data *cx_data;\n\tu64 *pm_info;\n\tint ret = 0;\n\n\tswitch (cmd & PMCMD_TYPE_MASK) {\n\tcase ACRN_PMCMD_GET_PX_CNT:\n\tcase ACRN_PMCMD_GET_CX_CNT:\n\t\tpm_info = kmalloc(sizeof(u64), GFP_KERNEL);\n\t\tif (!pm_info)\n\t\t\treturn -ENOMEM;\n\n\t\tret = hcall_get_cpu_state(cmd, virt_to_phys(pm_info));\n\t\tif (ret < 0) {\n\t\t\tkfree(pm_info);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_to_user(uptr, pm_info, sizeof(u64)))\n\t\t\tret = -EFAULT;\n\t\tkfree(pm_info);\n\t\tbreak;\n\tcase ACRN_PMCMD_GET_PX_DATA:\n\t\tpx_data = kmalloc(sizeof(*px_data), GFP_KERNEL);\n\t\tif (!px_data)\n\t\t\treturn -ENOMEM;\n\n\t\tret = hcall_get_cpu_state(cmd, virt_to_phys(px_data));\n\t\tif (ret < 0) {\n\t\t\tkfree(px_data);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_to_user(uptr, px_data, sizeof(*px_data)))\n\t\t\tret = -EFAULT;\n\t\tkfree(px_data);\n\t\tbreak;\n\tcase ACRN_PMCMD_GET_CX_DATA:\n\t\tcx_data = kmalloc(sizeof(*cx_data), GFP_KERNEL);\n\t\tif (!cx_data)\n\t\t\treturn -ENOMEM;\n\n\t\tret = hcall_get_cpu_state(cmd, virt_to_phys(cx_data));\n\t\tif (ret < 0) {\n\t\t\tkfree(cx_data);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_to_user(uptr, cx_data, sizeof(*cx_data)))\n\t\t\tret = -EFAULT;\n\t\tkfree(cx_data);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n \nstatic long acrn_dev_ioctl(struct file *filp, unsigned int cmd,\n\t\t\t   unsigned long ioctl_param)\n{\n\tstruct acrn_vm *vm = filp->private_data;\n\tstruct acrn_vm_creation *vm_param;\n\tstruct acrn_vcpu_regs *cpu_regs;\n\tstruct acrn_ioreq_notify notify;\n\tstruct acrn_ptdev_irq *irq_info;\n\tstruct acrn_ioeventfd ioeventfd;\n\tstruct acrn_vm_memmap memmap;\n\tstruct acrn_mmiodev *mmiodev;\n\tstruct acrn_msi_entry *msi;\n\tstruct acrn_pcidev *pcidev;\n\tstruct acrn_irqfd irqfd;\n\tstruct acrn_vdev *vdev;\n\tstruct page *page;\n\tu64 cstate_cmd;\n\tint i, ret = 0;\n\n\tif (vm->vmid == ACRN_INVALID_VMID && cmd != ACRN_IOCTL_CREATE_VM) {\n\t\tdev_dbg(acrn_dev.this_device,\n\t\t\t\"ioctl 0x%x: Invalid VM state!\\n\", cmd);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (cmd) {\n\tcase ACRN_IOCTL_CREATE_VM:\n\t\tvm_param = memdup_user((void __user *)ioctl_param,\n\t\t\t\t       sizeof(struct acrn_vm_creation));\n\t\tif (IS_ERR(vm_param))\n\t\t\treturn PTR_ERR(vm_param);\n\n\t\tif ((vm_param->reserved0 | vm_param->reserved1) != 0) {\n\t\t\tkfree(vm_param);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tvm = acrn_vm_create(vm, vm_param);\n\t\tif (!vm) {\n\t\t\tret = -EINVAL;\n\t\t\tkfree(vm_param);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_to_user((void __user *)ioctl_param, vm_param,\n\t\t\t\t sizeof(struct acrn_vm_creation))) {\n\t\t\tacrn_vm_destroy(vm);\n\t\t\tret = -EFAULT;\n\t\t}\n\n\t\tkfree(vm_param);\n\t\tbreak;\n\tcase ACRN_IOCTL_START_VM:\n\t\tret = hcall_start_vm(vm->vmid);\n\t\tif (ret < 0)\n\t\t\tdev_dbg(acrn_dev.this_device,\n\t\t\t\t\"Failed to start VM %u!\\n\", vm->vmid);\n\t\tbreak;\n\tcase ACRN_IOCTL_PAUSE_VM:\n\t\tret = hcall_pause_vm(vm->vmid);\n\t\tif (ret < 0)\n\t\t\tdev_dbg(acrn_dev.this_device,\n\t\t\t\t\"Failed to pause VM %u!\\n\", vm->vmid);\n\t\tbreak;\n\tcase ACRN_IOCTL_RESET_VM:\n\t\tret = hcall_reset_vm(vm->vmid);\n\t\tif (ret < 0)\n\t\t\tdev_dbg(acrn_dev.this_device,\n\t\t\t\t\"Failed to restart VM %u!\\n\", vm->vmid);\n\t\tbreak;\n\tcase ACRN_IOCTL_DESTROY_VM:\n\t\tret = acrn_vm_destroy(vm);\n\t\tbreak;\n\tcase ACRN_IOCTL_SET_VCPU_REGS:\n\t\tcpu_regs = memdup_user((void __user *)ioctl_param,\n\t\t\t\t       sizeof(struct acrn_vcpu_regs));\n\t\tif (IS_ERR(cpu_regs))\n\t\t\treturn PTR_ERR(cpu_regs);\n\n\t\tfor (i = 0; i < ARRAY_SIZE(cpu_regs->reserved); i++)\n\t\t\tif (cpu_regs->reserved[i]) {\n\t\t\t\tkfree(cpu_regs);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\tfor (i = 0; i < ARRAY_SIZE(cpu_regs->vcpu_regs.reserved_32); i++)\n\t\t\tif (cpu_regs->vcpu_regs.reserved_32[i]) {\n\t\t\t\tkfree(cpu_regs);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\tfor (i = 0; i < ARRAY_SIZE(cpu_regs->vcpu_regs.reserved_64); i++)\n\t\t\tif (cpu_regs->vcpu_regs.reserved_64[i]) {\n\t\t\t\tkfree(cpu_regs);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\tfor (i = 0; i < ARRAY_SIZE(cpu_regs->vcpu_regs.gdt.reserved); i++)\n\t\t\tif (cpu_regs->vcpu_regs.gdt.reserved[i] |\n\t\t\t    cpu_regs->vcpu_regs.idt.reserved[i]) {\n\t\t\t\tkfree(cpu_regs);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\tret = hcall_set_vcpu_regs(vm->vmid, virt_to_phys(cpu_regs));\n\t\tif (ret < 0)\n\t\t\tdev_dbg(acrn_dev.this_device,\n\t\t\t\t\"Failed to set regs state of VM%u!\\n\",\n\t\t\t\tvm->vmid);\n\t\tkfree(cpu_regs);\n\t\tbreak;\n\tcase ACRN_IOCTL_SET_MEMSEG:\n\t\tif (copy_from_user(&memmap, (void __user *)ioctl_param,\n\t\t\t\t   sizeof(memmap)))\n\t\t\treturn -EFAULT;\n\n\t\tret = acrn_vm_memseg_map(vm, &memmap);\n\t\tbreak;\n\tcase ACRN_IOCTL_UNSET_MEMSEG:\n\t\tif (copy_from_user(&memmap, (void __user *)ioctl_param,\n\t\t\t\t   sizeof(memmap)))\n\t\t\treturn -EFAULT;\n\n\t\tret = acrn_vm_memseg_unmap(vm, &memmap);\n\t\tbreak;\n\tcase ACRN_IOCTL_ASSIGN_MMIODEV:\n\t\tmmiodev = memdup_user((void __user *)ioctl_param,\n\t\t\t\t      sizeof(struct acrn_mmiodev));\n\t\tif (IS_ERR(mmiodev))\n\t\t\treturn PTR_ERR(mmiodev);\n\n\t\tret = hcall_assign_mmiodev(vm->vmid, virt_to_phys(mmiodev));\n\t\tif (ret < 0)\n\t\t\tdev_dbg(acrn_dev.this_device,\n\t\t\t\t\"Failed to assign MMIO device!\\n\");\n\t\tkfree(mmiodev);\n\t\tbreak;\n\tcase ACRN_IOCTL_DEASSIGN_MMIODEV:\n\t\tmmiodev = memdup_user((void __user *)ioctl_param,\n\t\t\t\t      sizeof(struct acrn_mmiodev));\n\t\tif (IS_ERR(mmiodev))\n\t\t\treturn PTR_ERR(mmiodev);\n\n\t\tret = hcall_deassign_mmiodev(vm->vmid, virt_to_phys(mmiodev));\n\t\tif (ret < 0)\n\t\t\tdev_dbg(acrn_dev.this_device,\n\t\t\t\t\"Failed to deassign MMIO device!\\n\");\n\t\tkfree(mmiodev);\n\t\tbreak;\n\tcase ACRN_IOCTL_ASSIGN_PCIDEV:\n\t\tpcidev = memdup_user((void __user *)ioctl_param,\n\t\t\t\t     sizeof(struct acrn_pcidev));\n\t\tif (IS_ERR(pcidev))\n\t\t\treturn PTR_ERR(pcidev);\n\n\t\tret = hcall_assign_pcidev(vm->vmid, virt_to_phys(pcidev));\n\t\tif (ret < 0)\n\t\t\tdev_dbg(acrn_dev.this_device,\n\t\t\t\t\"Failed to assign pci device!\\n\");\n\t\tkfree(pcidev);\n\t\tbreak;\n\tcase ACRN_IOCTL_DEASSIGN_PCIDEV:\n\t\tpcidev = memdup_user((void __user *)ioctl_param,\n\t\t\t\t     sizeof(struct acrn_pcidev));\n\t\tif (IS_ERR(pcidev))\n\t\t\treturn PTR_ERR(pcidev);\n\n\t\tret = hcall_deassign_pcidev(vm->vmid, virt_to_phys(pcidev));\n\t\tif (ret < 0)\n\t\t\tdev_dbg(acrn_dev.this_device,\n\t\t\t\t\"Failed to deassign pci device!\\n\");\n\t\tkfree(pcidev);\n\t\tbreak;\n\tcase ACRN_IOCTL_CREATE_VDEV:\n\t\tvdev = memdup_user((void __user *)ioctl_param,\n\t\t\t\t   sizeof(struct acrn_vdev));\n\t\tif (IS_ERR(vdev))\n\t\t\treturn PTR_ERR(vdev);\n\n\t\tret = hcall_create_vdev(vm->vmid, virt_to_phys(vdev));\n\t\tif (ret < 0)\n\t\t\tdev_dbg(acrn_dev.this_device,\n\t\t\t\t\"Failed to create virtual device!\\n\");\n\t\tkfree(vdev);\n\t\tbreak;\n\tcase ACRN_IOCTL_DESTROY_VDEV:\n\t\tvdev = memdup_user((void __user *)ioctl_param,\n\t\t\t\t   sizeof(struct acrn_vdev));\n\t\tif (IS_ERR(vdev))\n\t\t\treturn PTR_ERR(vdev);\n\t\tret = hcall_destroy_vdev(vm->vmid, virt_to_phys(vdev));\n\t\tif (ret < 0)\n\t\t\tdev_dbg(acrn_dev.this_device,\n\t\t\t\t\"Failed to destroy virtual device!\\n\");\n\t\tkfree(vdev);\n\t\tbreak;\n\tcase ACRN_IOCTL_SET_PTDEV_INTR:\n\t\tirq_info = memdup_user((void __user *)ioctl_param,\n\t\t\t\t       sizeof(struct acrn_ptdev_irq));\n\t\tif (IS_ERR(irq_info))\n\t\t\treturn PTR_ERR(irq_info);\n\n\t\tret = hcall_set_ptdev_intr(vm->vmid, virt_to_phys(irq_info));\n\t\tif (ret < 0)\n\t\t\tdev_dbg(acrn_dev.this_device,\n\t\t\t\t\"Failed to configure intr for ptdev!\\n\");\n\t\tkfree(irq_info);\n\t\tbreak;\n\tcase ACRN_IOCTL_RESET_PTDEV_INTR:\n\t\tirq_info = memdup_user((void __user *)ioctl_param,\n\t\t\t\t       sizeof(struct acrn_ptdev_irq));\n\t\tif (IS_ERR(irq_info))\n\t\t\treturn PTR_ERR(irq_info);\n\n\t\tret = hcall_reset_ptdev_intr(vm->vmid, virt_to_phys(irq_info));\n\t\tif (ret < 0)\n\t\t\tdev_dbg(acrn_dev.this_device,\n\t\t\t\t\"Failed to reset intr for ptdev!\\n\");\n\t\tkfree(irq_info);\n\t\tbreak;\n\tcase ACRN_IOCTL_SET_IRQLINE:\n\t\tret = hcall_set_irqline(vm->vmid, ioctl_param);\n\t\tif (ret < 0)\n\t\t\tdev_dbg(acrn_dev.this_device,\n\t\t\t\t\"Failed to set interrupt line!\\n\");\n\t\tbreak;\n\tcase ACRN_IOCTL_INJECT_MSI:\n\t\tmsi = memdup_user((void __user *)ioctl_param,\n\t\t\t\t  sizeof(struct acrn_msi_entry));\n\t\tif (IS_ERR(msi))\n\t\t\treturn PTR_ERR(msi);\n\n\t\tret = hcall_inject_msi(vm->vmid, virt_to_phys(msi));\n\t\tif (ret < 0)\n\t\t\tdev_dbg(acrn_dev.this_device,\n\t\t\t\t\"Failed to inject MSI!\\n\");\n\t\tkfree(msi);\n\t\tbreak;\n\tcase ACRN_IOCTL_VM_INTR_MONITOR:\n\t\tret = pin_user_pages_fast(ioctl_param, 1,\n\t\t\t\t\t  FOLL_WRITE | FOLL_LONGTERM, &page);\n\t\tif (unlikely(ret != 1)) {\n\t\t\tdev_dbg(acrn_dev.this_device,\n\t\t\t\t\"Failed to pin intr hdr buffer!\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tret = hcall_vm_intr_monitor(vm->vmid, page_to_phys(page));\n\t\tif (ret < 0) {\n\t\t\tunpin_user_page(page);\n\t\t\tdev_dbg(acrn_dev.this_device,\n\t\t\t\t\"Failed to monitor intr data!\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tif (vm->monitor_page)\n\t\t\tunpin_user_page(vm->monitor_page);\n\t\tvm->monitor_page = page;\n\t\tbreak;\n\tcase ACRN_IOCTL_CREATE_IOREQ_CLIENT:\n\t\tif (vm->default_client)\n\t\t\treturn -EEXIST;\n\t\tif (!acrn_ioreq_client_create(vm, NULL, NULL, true, \"acrndm\"))\n\t\t\tret = -EINVAL;\n\t\tbreak;\n\tcase ACRN_IOCTL_DESTROY_IOREQ_CLIENT:\n\t\tif (vm->default_client)\n\t\t\tacrn_ioreq_client_destroy(vm->default_client);\n\t\tbreak;\n\tcase ACRN_IOCTL_ATTACH_IOREQ_CLIENT:\n\t\tif (vm->default_client)\n\t\t\tret = acrn_ioreq_client_wait(vm->default_client);\n\t\telse\n\t\t\tret = -ENODEV;\n\t\tbreak;\n\tcase ACRN_IOCTL_NOTIFY_REQUEST_FINISH:\n\t\tif (copy_from_user(&notify, (void __user *)ioctl_param,\n\t\t\t\t   sizeof(struct acrn_ioreq_notify)))\n\t\t\treturn -EFAULT;\n\n\t\tif (notify.reserved != 0)\n\t\t\treturn -EINVAL;\n\n\t\tret = acrn_ioreq_request_default_complete(vm, notify.vcpu);\n\t\tbreak;\n\tcase ACRN_IOCTL_CLEAR_VM_IOREQ:\n\t\tacrn_ioreq_request_clear(vm);\n\t\tbreak;\n\tcase ACRN_IOCTL_PM_GET_CPU_STATE:\n\t\tif (copy_from_user(&cstate_cmd, (void __user *)ioctl_param,\n\t\t\t\t   sizeof(cstate_cmd)))\n\t\t\treturn -EFAULT;\n\n\t\tret = pmcmd_ioctl(cstate_cmd, (void __user *)ioctl_param);\n\t\tbreak;\n\tcase ACRN_IOCTL_IOEVENTFD:\n\t\tif (copy_from_user(&ioeventfd, (void __user *)ioctl_param,\n\t\t\t\t   sizeof(ioeventfd)))\n\t\t\treturn -EFAULT;\n\n\t\tif (ioeventfd.reserved != 0)\n\t\t\treturn -EINVAL;\n\n\t\tret = acrn_ioeventfd_config(vm, &ioeventfd);\n\t\tbreak;\n\tcase ACRN_IOCTL_IRQFD:\n\t\tif (copy_from_user(&irqfd, (void __user *)ioctl_param,\n\t\t\t\t   sizeof(irqfd)))\n\t\t\treturn -EFAULT;\n\t\tret = acrn_irqfd_config(vm, &irqfd);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(acrn_dev.this_device, \"Unknown IOCTL 0x%x!\\n\", cmd);\n\t\tret = -ENOTTY;\n\t}\n\n\treturn ret;\n}\n\nstatic int acrn_dev_release(struct inode *inode, struct file *filp)\n{\n\tstruct acrn_vm *vm = filp->private_data;\n\n\tacrn_vm_destroy(vm);\n\tkfree(vm);\n\treturn 0;\n}\n\nstatic ssize_t remove_cpu_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tu64 cpu, lapicid;\n\tint ret;\n\n\tif (kstrtoull(buf, 0, &cpu) < 0)\n\t\treturn -EINVAL;\n\n\tif (cpu >= num_possible_cpus() || cpu == 0 || !cpu_is_hotpluggable(cpu))\n\t\treturn -EINVAL;\n\n\tif (cpu_online(cpu))\n\t\tremove_cpu(cpu);\n\n\tlapicid = cpu_data(cpu).apicid;\n\tdev_dbg(dev, \"Try to remove cpu %lld with lapicid %lld\\n\", cpu, lapicid);\n\tret = hcall_sos_remove_cpu(lapicid);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to remove cpu %lld!\\n\", cpu);\n\t\tgoto fail_remove;\n\t}\n\n\treturn count;\n\nfail_remove:\n\tadd_cpu(cpu);\n\treturn ret;\n}\nstatic DEVICE_ATTR_WO(remove_cpu);\n\nstatic umode_t acrn_attr_visible(struct kobject *kobj, struct attribute *a, int n)\n{\n       if (a == &dev_attr_remove_cpu.attr)\n               return IS_ENABLED(CONFIG_HOTPLUG_CPU) ? a->mode : 0;\n\n       return a->mode;\n}\n\nstatic struct attribute *acrn_attrs[] = {\n\t&dev_attr_remove_cpu.attr,\n\tNULL\n};\n\nstatic struct attribute_group acrn_attr_group = {\n\t.attrs = acrn_attrs,\n\t.is_visible = acrn_attr_visible,\n};\n\nstatic const struct attribute_group *acrn_attr_groups[] = {\n\t&acrn_attr_group,\n\tNULL\n};\n\nstatic const struct file_operations acrn_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= acrn_dev_open,\n\t.release\t= acrn_dev_release,\n\t.unlocked_ioctl = acrn_dev_ioctl,\n};\n\nstruct miscdevice acrn_dev = {\n\t.minor\t= MISC_DYNAMIC_MINOR,\n\t.name\t= \"acrn_hsm\",\n\t.fops\t= &acrn_fops,\n\t.groups\t= acrn_attr_groups,\n};\n\nstatic int __init hsm_init(void)\n{\n\tint ret;\n\n\tif (x86_hyper_type != X86_HYPER_ACRN)\n\t\treturn -ENODEV;\n\n\tif (!(cpuid_eax(ACRN_CPUID_FEATURES) & ACRN_FEATURE_PRIVILEGED_VM))\n\t\treturn -EPERM;\n\n\tret = misc_register(&acrn_dev);\n\tif (ret) {\n\t\tpr_err(\"Create misc dev failed!\\n\");\n\t\treturn ret;\n\t}\n\n\tret = acrn_ioreq_intr_setup();\n\tif (ret) {\n\t\tpr_err(\"Setup I/O request handler failed!\\n\");\n\t\tmisc_deregister(&acrn_dev);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic void __exit hsm_exit(void)\n{\n\tacrn_ioreq_intr_remove();\n\tmisc_deregister(&acrn_dev);\n}\nmodule_init(hsm_init);\nmodule_exit(hsm_exit);\n\nMODULE_AUTHOR(\"Intel Corporation\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"ACRN Hypervisor Service Module (HSM)\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}