{
  "module_name": "vmgenid.c",
  "hash_id": "3ab5abf62ef217311a1b3014281c7e7b610c955589944951145c55106f03c7ef",
  "original_prompt": "Ingested from linux-6.6.14/drivers/virt/vmgenid.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/acpi.h>\n#include <linux/random.h>\n\nACPI_MODULE_NAME(\"vmgenid\");\n\nenum { VMGENID_SIZE = 16 };\n\nstruct vmgenid_state {\n\tu8 *next_id;\n\tu8 this_id[VMGENID_SIZE];\n};\n\nstatic int vmgenid_add(struct acpi_device *device)\n{\n\tstruct acpi_buffer parsed = { ACPI_ALLOCATE_BUFFER };\n\tstruct vmgenid_state *state;\n\tunion acpi_object *obj;\n\tphys_addr_t phys_addr;\n\tacpi_status status;\n\tint ret = 0;\n\n\tstate = devm_kmalloc(&device->dev, sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn -ENOMEM;\n\n\tstatus = acpi_evaluate_object(device->handle, \"ADDR\", NULL, &parsed);\n\tif (ACPI_FAILURE(status)) {\n\t\tACPI_EXCEPTION((AE_INFO, status, \"Evaluating ADDR\"));\n\t\treturn -ENODEV;\n\t}\n\tobj = parsed.pointer;\n\tif (!obj || obj->type != ACPI_TYPE_PACKAGE || obj->package.count != 2 ||\n\t    obj->package.elements[0].type != ACPI_TYPE_INTEGER ||\n\t    obj->package.elements[1].type != ACPI_TYPE_INTEGER) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tphys_addr = (obj->package.elements[0].integer.value << 0) |\n\t\t    (obj->package.elements[1].integer.value << 32);\n\tstate->next_id = devm_memremap(&device->dev, phys_addr, VMGENID_SIZE, MEMREMAP_WB);\n\tif (IS_ERR(state->next_id)) {\n\t\tret = PTR_ERR(state->next_id);\n\t\tgoto out;\n\t}\n\n\tmemcpy(state->this_id, state->next_id, sizeof(state->this_id));\n\tadd_device_randomness(state->this_id, sizeof(state->this_id));\n\n\tdevice->driver_data = state;\n\nout:\n\tACPI_FREE(parsed.pointer);\n\treturn ret;\n}\n\nstatic void vmgenid_notify(struct acpi_device *device, u32 event)\n{\n\tstruct vmgenid_state *state = acpi_driver_data(device);\n\tu8 old_id[VMGENID_SIZE];\n\n\tmemcpy(old_id, state->this_id, sizeof(old_id));\n\tmemcpy(state->this_id, state->next_id, sizeof(state->this_id));\n\tif (!memcmp(old_id, state->this_id, sizeof(old_id)))\n\t\treturn;\n\tadd_vmfork_randomness(state->this_id, sizeof(state->this_id));\n}\n\nstatic const struct acpi_device_id vmgenid_ids[] = {\n\t{ \"VMGENCTR\", 0 },\n\t{ \"VM_GEN_COUNTER\", 0 },\n\t{ }\n};\n\nstatic struct acpi_driver vmgenid_driver = {\n\t.name = \"vmgenid\",\n\t.ids = vmgenid_ids,\n\t.owner = THIS_MODULE,\n\t.ops = {\n\t\t.add = vmgenid_add,\n\t\t.notify = vmgenid_notify\n\t}\n};\n\nmodule_acpi_driver(vmgenid_driver);\n\nMODULE_DEVICE_TABLE(acpi, vmgenid_ids);\nMODULE_DESCRIPTION(\"Virtual Machine Generation ID\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Jason A. Donenfeld <Jason@zx2c4.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}