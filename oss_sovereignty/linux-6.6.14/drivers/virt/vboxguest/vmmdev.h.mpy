{
  "module_name": "vmmdev.h",
  "hash_id": "495978181342c27da868f57bb7ab7129e7962d9150f75da8b04aa7de288c7274",
  "original_prompt": "Ingested from linux-6.6.14/drivers/virt/vboxguest/vmmdev.h",
  "human_readable_source": " \n \n\n#ifndef __VBOX_VMMDEV_H__\n#define __VBOX_VMMDEV_H__\n\n#include <asm/bitsperlong.h>\n#include <linux/sizes.h>\n#include <linux/types.h>\n#include <linux/vbox_vmmdev_types.h>\n\n \n#define VMMDEV_PORT_OFF_REQUEST                             0\n\n \nstruct vmmdev_memory {\n\t \n\tu32 size;\n\t \n\tu32 version;\n\n\tunion {\n\t\tstruct {\n\t\t\t \n\t\t\tu8 have_events;\n\t\t\t \n\t\t\tu8 padding[3];\n\t\t} V1_04;\n\n\t\tstruct {\n\t\t\t \n\t\t\tu32 host_events;\n\t\t\t \n\t\t\tu32 guest_event_mask;\n\t\t} V1_03;\n\t} V;\n\n\t \n};\nVMMDEV_ASSERT_SIZE(vmmdev_memory, 8 + 8);\n\n \n#define VMMDEV_MEMORY_VERSION   (1)\n\n \n#define VMMDEV_EVENT_MOUSE_CAPABILITIES_CHANGED             BIT(0)\n \n#define VMMDEV_EVENT_HGCM                                   BIT(1)\n \n#define VMMDEV_EVENT_DISPLAY_CHANGE_REQUEST                 BIT(2)\n \n#define VMMDEV_EVENT_JUDGE_CREDENTIALS                      BIT(3)\n \n#define VMMDEV_EVENT_RESTORED                               BIT(4)\n \n#define VMMDEV_EVENT_SEAMLESS_MODE_CHANGE_REQUEST           BIT(5)\n \n#define VMMDEV_EVENT_BALLOON_CHANGE_REQUEST                 BIT(6)\n \n#define VMMDEV_EVENT_STATISTICS_INTERVAL_CHANGE_REQUEST     BIT(7)\n \n#define VMMDEV_EVENT_VRDP                                   BIT(8)\n \n#define VMMDEV_EVENT_MOUSE_POSITION_CHANGED                 BIT(9)\n \n#define VMMDEV_EVENT_CPU_HOTPLUG                            BIT(10)\n \n#define VMMDEV_EVENT_VALID_EVENT_MASK                       0x000007ffU\n\n \n#define VMMDEV_VERSION                      0x00010004\n#define VMMDEV_VERSION_MAJOR                (VMMDEV_VERSION >> 16)\n#define VMMDEV_VERSION_MINOR                (VMMDEV_VERSION & 0xffff)\n\n \n#define VMMDEV_MAX_VMMDEVREQ_SIZE           1048576\n\n \n#define VMMDEV_REQUEST_HEADER_VERSION       0x10001\n\n \nstruct vmmdev_request_header {\n\t \n\tu32 size;\n\t \n\tu32 version;\n\t \n\tenum vmmdev_request_type request_type;\n\t \n\ts32 rc;\n\t \n\tu32 reserved1;\n\t \n\tu32 requestor;\n};\nVMMDEV_ASSERT_SIZE(vmmdev_request_header, 24);\n\n \nstruct vmmdev_mouse_status {\n\t \n\tstruct vmmdev_request_header header;\n\t \n\tu32 mouse_features;\n\t \n\ts32 pointer_pos_x;\n\t \n\ts32 pointer_pos_y;\n};\nVMMDEV_ASSERT_SIZE(vmmdev_mouse_status, 24 + 12);\n\n \n#define VMMDEV_MOUSE_GUEST_CAN_ABSOLUTE                     BIT(0)\n \n#define VMMDEV_MOUSE_HOST_WANTS_ABSOLUTE                    BIT(1)\n \n#define VMMDEV_MOUSE_GUEST_NEEDS_HOST_CURSOR                BIT(2)\n \n#define VMMDEV_MOUSE_HOST_CANNOT_HWPOINTER                  BIT(3)\n \n#define VMMDEV_MOUSE_NEW_PROTOCOL                           BIT(4)\n \n#define VMMDEV_MOUSE_HOST_RECHECKS_NEEDS_HOST_CURSOR        BIT(5)\n \n#define VMMDEV_MOUSE_HOST_HAS_ABS_DEV                       BIT(6)\n\n \n#define VMMDEV_MOUSE_RANGE_MIN 0\n \n#define VMMDEV_MOUSE_RANGE_MAX 0xFFFF\n\n \nstruct vmmdev_host_version {\n\t \n\tstruct vmmdev_request_header header;\n\t \n\tu16 major;\n\t \n\tu16 minor;\n\t \n\tu32 build;\n\t \n\tu32 revision;\n\t \n\tu32 features;\n};\nVMMDEV_ASSERT_SIZE(vmmdev_host_version, 24 + 16);\n\n \n#define VMMDEV_HVF_HGCM_PHYS_PAGE_LIST  BIT(0)\n\n \nstruct vmmdev_mask {\n\t \n\tstruct vmmdev_request_header header;\n\t \n\tu32 or_mask;\n\t \n\tu32 not_mask;\n};\nVMMDEV_ASSERT_SIZE(vmmdev_mask, 24 + 8);\n\n \n#define VMMDEV_GUEST_SUPPORTS_SEAMLESS                      BIT(0)\n \n#define VMMDEV_GUEST_SUPPORTS_GUEST_HOST_WINDOW_MAPPING     BIT(1)\n \n#define VMMDEV_GUEST_SUPPORTS_GRAPHICS                      BIT(2)\n \n#define VMMDEV_GUEST_CAPABILITIES_MASK                      0x00000007U\n\n \nstruct vmmdev_hypervisorinfo {\n\t \n\tstruct vmmdev_request_header header;\n\t \n\tu32 hypervisor_start;\n\t \n\tu32 hypervisor_size;\n};\nVMMDEV_ASSERT_SIZE(vmmdev_hypervisorinfo, 24 + 8);\n\n \nstruct vmmdev_events {\n\t \n\tstruct vmmdev_request_header header;\n\t \n\tu32 events;\n};\nVMMDEV_ASSERT_SIZE(vmmdev_events, 24 + 4);\n\n#define VMMDEV_OSTYPE_LINUX26\t\t0x53000\n#define VMMDEV_OSTYPE_X64\t\tBIT(8)\n\n \nstruct vmmdev_guest_info {\n\t \n\tstruct vmmdev_request_header header;\n\t \n\tu32 interface_version;\n\t \n\tu32 os_type;\n};\nVMMDEV_ASSERT_SIZE(vmmdev_guest_info, 24 + 8);\n\n#define VMMDEV_GUEST_INFO2_ADDITIONS_FEATURES_REQUESTOR_INFO\tBIT(0)\n\n \nstruct vmmdev_guest_info2 {\n\t \n\tstruct vmmdev_request_header header;\n\t \n\tu16 additions_major;\n\t \n\tu16 additions_minor;\n\t \n\tu32 additions_build;\n\t \n\tu32 additions_revision;\n\t \n\tu32 additions_features;\n\t \n\tchar name[128];\n};\nVMMDEV_ASSERT_SIZE(vmmdev_guest_info2, 24 + 144);\n\nenum vmmdev_guest_facility_type {\n\tVBOXGUEST_FACILITY_TYPE_UNKNOWN          = 0,\n\tVBOXGUEST_FACILITY_TYPE_VBOXGUEST_DRIVER = 20,\n\t \n\tVBOXGUEST_FACILITY_TYPE_AUTO_LOGON       = 90,\n\tVBOXGUEST_FACILITY_TYPE_VBOX_SERVICE     = 100,\n\t \n\tVBOXGUEST_FACILITY_TYPE_VBOX_TRAY_CLIENT = 101,\n\tVBOXGUEST_FACILITY_TYPE_SEAMLESS         = 1000,\n\tVBOXGUEST_FACILITY_TYPE_GRAPHICS         = 1100,\n\tVBOXGUEST_FACILITY_TYPE_ALL              = 0x7ffffffe,\n\t \n\tVBOXGUEST_FACILITY_TYPE_SIZEHACK         = 0x7fffffff\n};\n\nenum vmmdev_guest_facility_status {\n\tVBOXGUEST_FACILITY_STATUS_INACTIVE    = 0,\n\tVBOXGUEST_FACILITY_STATUS_PAUSED      = 1,\n\tVBOXGUEST_FACILITY_STATUS_PRE_INIT    = 20,\n\tVBOXGUEST_FACILITY_STATUS_INIT        = 30,\n\tVBOXGUEST_FACILITY_STATUS_ACTIVE      = 50,\n\tVBOXGUEST_FACILITY_STATUS_TERMINATING = 100,\n\tVBOXGUEST_FACILITY_STATUS_TERMINATED  = 101,\n\tVBOXGUEST_FACILITY_STATUS_FAILED      = 800,\n\tVBOXGUEST_FACILITY_STATUS_UNKNOWN     = 999,\n\t \n\tVBOXGUEST_FACILITY_STATUS_SIZEHACK    = 0x7fffffff\n};\n\n \nstruct vmmdev_guest_status {\n\t \n\tstruct vmmdev_request_header header;\n\t \n\tenum vmmdev_guest_facility_type facility;\n\t \n\tenum vmmdev_guest_facility_status status;\n\t \n\tu32 flags;\n};\nVMMDEV_ASSERT_SIZE(vmmdev_guest_status, 24 + 12);\n\n#define VMMDEV_MEMORY_BALLOON_CHUNK_SIZE             (1048576)\n#define VMMDEV_MEMORY_BALLOON_CHUNK_PAGES            (1048576 / 4096)\n\n \nstruct vmmdev_memballoon_info {\n\t \n\tstruct vmmdev_request_header header;\n\t \n\tu32 balloon_chunks;\n\t \n\tu32 phys_mem_chunks;\n\t \n\tu32 event_ack;\n};\nVMMDEV_ASSERT_SIZE(vmmdev_memballoon_info, 24 + 12);\n\n \nstruct vmmdev_memballoon_change {\n\t \n\tstruct vmmdev_request_header header;\n\t \n\tu32 pages;\n\t \n\tu32 inflate;\n\t \n\tu64 phys_page[VMMDEV_MEMORY_BALLOON_CHUNK_PAGES];\n};\n\n \nstruct vmmdev_write_core_dump {\n\t \n\tstruct vmmdev_request_header header;\n\t \n\tu32 flags;\n};\nVMMDEV_ASSERT_SIZE(vmmdev_write_core_dump, 24 + 4);\n\n \nstruct vmmdev_heartbeat {\n\t \n\tstruct vmmdev_request_header header;\n\t \n\tu64 interval_ns;\n\t \n\tu8 enabled;\n\t \n\tu8 padding[3];\n} __packed;\nVMMDEV_ASSERT_SIZE(vmmdev_heartbeat, 24 + 12);\n\n#define VMMDEV_HGCM_REQ_DONE      BIT(0)\n#define VMMDEV_HGCM_REQ_CANCELLED BIT(1)\n\n \nstruct vmmdev_hgcmreq_header {\n\t \n\tstruct vmmdev_request_header header;\n\n\t \n\tu32 flags;\n\n\t \n\ts32 result;\n};\nVMMDEV_ASSERT_SIZE(vmmdev_hgcmreq_header, 24 + 8);\n\n \nstruct vmmdev_hgcm_connect {\n\t \n\tstruct vmmdev_hgcmreq_header header;\n\n\t \n\tstruct vmmdev_hgcm_service_location loc;\n\n\t \n\tu32 client_id;\n};\nVMMDEV_ASSERT_SIZE(vmmdev_hgcm_connect, 32 + 132 + 4);\n\n \nstruct vmmdev_hgcm_disconnect {\n\t \n\tstruct vmmdev_hgcmreq_header header;\n\n\t \n\tu32 client_id;\n};\nVMMDEV_ASSERT_SIZE(vmmdev_hgcm_disconnect, 32 + 4);\n\n#define VMMDEV_HGCM_MAX_PARMS 32\n\n \nstruct vmmdev_hgcm_call {\n\t \n\tstruct vmmdev_hgcmreq_header header;\n\n\t \n\tu32 client_id;\n\t \n\tu32 function;\n\t \n\tu32 parm_count;\n\t \n};\nVMMDEV_ASSERT_SIZE(vmmdev_hgcm_call, 32 + 12);\n\n \nstruct vmmdev_hgcm_cancel2 {\n\t \n\tstruct vmmdev_request_header header;\n\t \n\tu32 phys_req_to_cancel;\n};\nVMMDEV_ASSERT_SIZE(vmmdev_hgcm_cancel2, 24 + 4);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}