{
  "module_name": "vboxguest_linux.c",
  "hash_id": "bd9e9c5150a67813ca7ae8578cf01bc9b8f1f28272155164ae0db478bf182ee3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/virt/vboxguest/vboxguest_linux.c",
  "human_readable_source": " \n \n\n#include <linux/cred.h>\n#include <linux/input.h>\n#include <linux/kernel.h>\n#include <linux/miscdevice.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/poll.h>\n#include <linux/vbox_utils.h>\n#include \"vboxguest_core.h\"\n\n \n#define DEVICE_NAME\t\t\"vboxguest\"\n \n#define DEVICE_NAME_USER\t\"vboxuser\"\n \n#define VBOX_VENDORID\t\t0x80ee\n \n#define VMMDEV_DEVICEID\t\t0xcafe\n\n \nstatic DEFINE_MUTEX(vbg_gdev_mutex);\n \nstatic struct vbg_dev *vbg_gdev;\n\nstatic u32 vbg_misc_device_requestor(struct inode *inode)\n{\n\tu32 requestor = VMMDEV_REQUESTOR_USERMODE |\n\t\t\tVMMDEV_REQUESTOR_CON_DONT_KNOW |\n\t\t\tVMMDEV_REQUESTOR_TRUST_NOT_GIVEN;\n\n\tif (from_kuid(current_user_ns(), current_uid()) == 0)\n\t\trequestor |= VMMDEV_REQUESTOR_USR_ROOT;\n\telse\n\t\trequestor |= VMMDEV_REQUESTOR_USR_USER;\n\n\tif (in_egroup_p(inode->i_gid))\n\t\trequestor |= VMMDEV_REQUESTOR_GRP_VBOX;\n\n\treturn requestor;\n}\n\nstatic int vbg_misc_device_open(struct inode *inode, struct file *filp)\n{\n\tstruct vbg_session *session;\n\tstruct vbg_dev *gdev;\n\n\t \n\tgdev = container_of(filp->private_data, struct vbg_dev, misc_device);\n\n\tsession = vbg_core_open_session(gdev, vbg_misc_device_requestor(inode));\n\tif (IS_ERR(session))\n\t\treturn PTR_ERR(session);\n\n\tfilp->private_data = session;\n\treturn 0;\n}\n\nstatic int vbg_misc_device_user_open(struct inode *inode, struct file *filp)\n{\n\tstruct vbg_session *session;\n\tstruct vbg_dev *gdev;\n\n\t \n\tgdev = container_of(filp->private_data, struct vbg_dev,\n\t\t\t    misc_device_user);\n\n\tsession = vbg_core_open_session(gdev, vbg_misc_device_requestor(inode) |\n\t\t\t\t\t      VMMDEV_REQUESTOR_USER_DEVICE);\n\tif (IS_ERR(session))\n\t\treturn PTR_ERR(session);\n\n\tfilp->private_data = session;\n\treturn 0;\n}\n\n \nstatic int vbg_misc_device_close(struct inode *inode, struct file *filp)\n{\n\tvbg_core_close_session(filp->private_data);\n\tfilp->private_data = NULL;\n\treturn 0;\n}\n\n \nstatic long vbg_misc_device_ioctl(struct file *filp, unsigned int req,\n\t\t\t\t  unsigned long arg)\n{\n\tstruct vbg_session *session = filp->private_data;\n\tsize_t returned_size, size;\n\tstruct vbg_ioctl_hdr hdr;\n\tbool is_vmmdev_req;\n\tint ret = 0;\n\tvoid *buf;\n\n\tif (copy_from_user(&hdr, (void *)arg, sizeof(hdr)))\n\t\treturn -EFAULT;\n\n\tif (hdr.version != VBG_IOCTL_HDR_VERSION)\n\t\treturn -EINVAL;\n\n\tif (hdr.size_in < sizeof(hdr) ||\n\t    (hdr.size_out && hdr.size_out < sizeof(hdr)))\n\t\treturn -EINVAL;\n\n\tsize = max(hdr.size_in, hdr.size_out);\n\tif (_IOC_SIZE(req) && _IOC_SIZE(req) != size)\n\t\treturn -EINVAL;\n\tif (size > SZ_16M)\n\t\treturn -E2BIG;\n\n\t \n\tis_vmmdev_req = (req & ~IOCSIZE_MASK) == VBG_IOCTL_VMMDEV_REQUEST(0) ||\n\t\t\t req == VBG_IOCTL_VMMDEV_REQUEST_BIG ||\n\t\t\t req == VBG_IOCTL_VMMDEV_REQUEST_BIG_ALT;\n\n\tif (is_vmmdev_req)\n\t\tbuf = vbg_req_alloc(size, VBG_IOCTL_HDR_TYPE_DEFAULT,\n\t\t\t\t    session->requestor);\n\telse\n\t\tbuf = kmalloc(size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t*((struct vbg_ioctl_hdr *)buf) = hdr;\n\tif (copy_from_user(buf + sizeof(hdr), (void *)arg + sizeof(hdr),\n\t\t\t   hdr.size_in - sizeof(hdr))) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\tif (hdr.size_in < size)\n\t\tmemset(buf + hdr.size_in, 0, size -  hdr.size_in);\n\n\tret = vbg_core_ioctl(session, req, buf);\n\tif (ret)\n\t\tgoto out;\n\n\treturned_size = ((struct vbg_ioctl_hdr *)buf)->size_out;\n\tif (returned_size > size) {\n\t\tvbg_debug(\"%s: too much output data %zu > %zu\\n\",\n\t\t\t  __func__, returned_size, size);\n\t\treturned_size = size;\n\t}\n\tif (copy_to_user((void *)arg, buf, returned_size) != 0)\n\t\tret = -EFAULT;\n\nout:\n\tif (is_vmmdev_req)\n\t\tvbg_req_free(buf, size);\n\telse\n\t\tkfree(buf);\n\n\treturn ret;\n}\n\n \nstatic const struct file_operations vbg_misc_device_fops = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.open\t\t\t= vbg_misc_device_open,\n\t.release\t\t= vbg_misc_device_close,\n\t.unlocked_ioctl\t\t= vbg_misc_device_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t\t= vbg_misc_device_ioctl,\n#endif\n};\nstatic const struct file_operations vbg_misc_device_user_fops = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.open\t\t\t= vbg_misc_device_user_open,\n\t.release\t\t= vbg_misc_device_close,\n\t.unlocked_ioctl\t\t= vbg_misc_device_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t\t= vbg_misc_device_ioctl,\n#endif\n};\n\n \nstatic int vbg_input_open(struct input_dev *input)\n{\n\tstruct vbg_dev *gdev = input_get_drvdata(input);\n\tu32 feat = VMMDEV_MOUSE_GUEST_CAN_ABSOLUTE | VMMDEV_MOUSE_NEW_PROTOCOL;\n\n\treturn vbg_core_set_mouse_status(gdev, feat);\n}\n\n \nstatic void vbg_input_close(struct input_dev *input)\n{\n\tstruct vbg_dev *gdev = input_get_drvdata(input);\n\n\tvbg_core_set_mouse_status(gdev, 0);\n}\n\n \nstatic int vbg_create_input_device(struct vbg_dev *gdev)\n{\n\tstruct input_dev *input;\n\n\tinput = devm_input_allocate_device(gdev->dev);\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\tinput->id.bustype = BUS_PCI;\n\tinput->id.vendor = VBOX_VENDORID;\n\tinput->id.product = VMMDEV_DEVICEID;\n\tinput->open = vbg_input_open;\n\tinput->close = vbg_input_close;\n\tinput->dev.parent = gdev->dev;\n\tinput->name = \"VirtualBox mouse integration\";\n\n\tinput_set_abs_params(input, ABS_X, VMMDEV_MOUSE_RANGE_MIN,\n\t\t\t     VMMDEV_MOUSE_RANGE_MAX, 0, 0);\n\tinput_set_abs_params(input, ABS_Y, VMMDEV_MOUSE_RANGE_MIN,\n\t\t\t     VMMDEV_MOUSE_RANGE_MAX, 0, 0);\n\tinput_set_capability(input, EV_KEY, BTN_MOUSE);\n\tinput_set_drvdata(input, gdev);\n\n\tgdev->input = input;\n\n\treturn input_register_device(gdev->input);\n}\n\nstatic ssize_t host_version_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct vbg_dev *gdev = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%s\\n\", gdev->host_version);\n}\n\nstatic ssize_t host_features_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct vbg_dev *gdev = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%#x\\n\", gdev->host_features);\n}\n\nstatic DEVICE_ATTR_RO(host_version);\nstatic DEVICE_ATTR_RO(host_features);\n\nstatic struct attribute *vbg_pci_attrs[] = {\n\t&dev_attr_host_version.attr,\n\t&dev_attr_host_features.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(vbg_pci);\n\n \nstatic int vbg_pci_probe(struct pci_dev *pci, const struct pci_device_id *id)\n{\n\tstruct device *dev = &pci->dev;\n\tresource_size_t io, io_len, mmio, mmio_len;\n\tstruct vmmdev_memory *vmmdev;\n\tstruct vbg_dev *gdev;\n\tint ret;\n\n\tgdev = devm_kzalloc(dev, sizeof(*gdev), GFP_KERNEL);\n\tif (!gdev)\n\t\treturn -ENOMEM;\n\n\tret = pci_enable_device(pci);\n\tif (ret != 0) {\n\t\tvbg_err(\"vboxguest: Error enabling device: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = -ENODEV;\n\n\tio = pci_resource_start(pci, 0);\n\tio_len = pci_resource_len(pci, 0);\n\tif (!io || !io_len) {\n\t\tvbg_err(\"vboxguest: Error IO-port resource (0) is missing\\n\");\n\t\tgoto err_disable_pcidev;\n\t}\n\tif (devm_request_region(dev, io, io_len, DEVICE_NAME) == NULL) {\n\t\tvbg_err(\"vboxguest: Error could not claim IO resource\\n\");\n\t\tret = -EBUSY;\n\t\tgoto err_disable_pcidev;\n\t}\n\n\tmmio = pci_resource_start(pci, 1);\n\tmmio_len = pci_resource_len(pci, 1);\n\tif (!mmio || !mmio_len) {\n\t\tvbg_err(\"vboxguest: Error MMIO resource (1) is missing\\n\");\n\t\tgoto err_disable_pcidev;\n\t}\n\n\tif (devm_request_mem_region(dev, mmio, mmio_len, DEVICE_NAME) == NULL) {\n\t\tvbg_err(\"vboxguest: Error could not claim MMIO resource\\n\");\n\t\tret = -EBUSY;\n\t\tgoto err_disable_pcidev;\n\t}\n\n\tvmmdev = devm_ioremap(dev, mmio, mmio_len);\n\tif (!vmmdev) {\n\t\tvbg_err(\"vboxguest: Error ioremap failed; MMIO addr=%pap size=%pap\\n\",\n\t\t\t&mmio, &mmio_len);\n\t\tgoto err_disable_pcidev;\n\t}\n\n\t \n\tif (vmmdev->version != VMMDEV_MEMORY_VERSION ||\n\t    vmmdev->size < 32 || vmmdev->size > mmio_len) {\n\t\tvbg_err(\"vboxguest: Bogus VMMDev memory; version=%08x (expected %08x) size=%d (expected <= %d)\\n\",\n\t\t\tvmmdev->version, VMMDEV_MEMORY_VERSION,\n\t\t\tvmmdev->size, (int)mmio_len);\n\t\tgoto err_disable_pcidev;\n\t}\n\n\tgdev->io_port = io;\n\tgdev->mmio = vmmdev;\n\tgdev->dev = dev;\n\tgdev->misc_device.minor = MISC_DYNAMIC_MINOR;\n\tgdev->misc_device.name = DEVICE_NAME;\n\tgdev->misc_device.fops = &vbg_misc_device_fops;\n\tgdev->misc_device_user.minor = MISC_DYNAMIC_MINOR;\n\tgdev->misc_device_user.name = DEVICE_NAME_USER;\n\tgdev->misc_device_user.fops = &vbg_misc_device_user_fops;\n\n\tret = vbg_core_init(gdev, VMMDEV_EVENT_MOUSE_POSITION_CHANGED);\n\tif (ret)\n\t\tgoto err_disable_pcidev;\n\n\tret = vbg_create_input_device(gdev);\n\tif (ret) {\n\t\tvbg_err(\"vboxguest: Error creating input device: %d\\n\", ret);\n\t\tgoto err_vbg_core_exit;\n\t}\n\n\tret = request_irq(pci->irq, vbg_core_isr, IRQF_SHARED, DEVICE_NAME,\n\t\t\t  gdev);\n\tif (ret) {\n\t\tvbg_err(\"vboxguest: Error requesting irq: %d\\n\", ret);\n\t\tgoto err_vbg_core_exit;\n\t}\n\n\tret = misc_register(&gdev->misc_device);\n\tif (ret) {\n\t\tvbg_err(\"vboxguest: Error misc_register %s failed: %d\\n\",\n\t\t\tDEVICE_NAME, ret);\n\t\tgoto err_free_irq;\n\t}\n\n\tret = misc_register(&gdev->misc_device_user);\n\tif (ret) {\n\t\tvbg_err(\"vboxguest: Error misc_register %s failed: %d\\n\",\n\t\t\tDEVICE_NAME_USER, ret);\n\t\tgoto err_unregister_misc_device;\n\t}\n\n\tmutex_lock(&vbg_gdev_mutex);\n\tif (!vbg_gdev)\n\t\tvbg_gdev = gdev;\n\telse\n\t\tret = -EBUSY;\n\tmutex_unlock(&vbg_gdev_mutex);\n\n\tif (ret) {\n\t\tvbg_err(\"vboxguest: Error more then 1 vbox guest pci device\\n\");\n\t\tgoto err_unregister_misc_device_user;\n\t}\n\n\tpci_set_drvdata(pci, gdev);\n\n\treturn 0;\n\nerr_unregister_misc_device_user:\n\tmisc_deregister(&gdev->misc_device_user);\nerr_unregister_misc_device:\n\tmisc_deregister(&gdev->misc_device);\nerr_free_irq:\n\tfree_irq(pci->irq, gdev);\nerr_vbg_core_exit:\n\tvbg_core_exit(gdev);\nerr_disable_pcidev:\n\tpci_disable_device(pci);\n\n\treturn ret;\n}\n\nstatic void vbg_pci_remove(struct pci_dev *pci)\n{\n\tstruct vbg_dev *gdev = pci_get_drvdata(pci);\n\n\tmutex_lock(&vbg_gdev_mutex);\n\tvbg_gdev = NULL;\n\tmutex_unlock(&vbg_gdev_mutex);\n\n\tfree_irq(pci->irq, gdev);\n\tmisc_deregister(&gdev->misc_device_user);\n\tmisc_deregister(&gdev->misc_device);\n\tvbg_core_exit(gdev);\n\tpci_disable_device(pci);\n}\n\nstruct vbg_dev *vbg_get_gdev(void)\n{\n\tmutex_lock(&vbg_gdev_mutex);\n\n\t \n\tif (vbg_gdev)\n\t\treturn vbg_gdev;\n\n\tmutex_unlock(&vbg_gdev_mutex);\n\treturn ERR_PTR(-ENODEV);\n}\nEXPORT_SYMBOL(vbg_get_gdev);\n\nvoid vbg_put_gdev(struct vbg_dev *gdev)\n{\n\tWARN_ON(gdev != vbg_gdev);\n\tmutex_unlock(&vbg_gdev_mutex);\n}\nEXPORT_SYMBOL(vbg_put_gdev);\n\n \nvoid vbg_linux_mouse_event(struct vbg_dev *gdev)\n{\n\tint rc;\n\n\t \n\tgdev->mouse_status_req->mouse_features = 0;\n\tgdev->mouse_status_req->pointer_pos_x = 0;\n\tgdev->mouse_status_req->pointer_pos_y = 0;\n\trc = vbg_req_perform(gdev, gdev->mouse_status_req);\n\tif (rc >= 0) {\n\t\tinput_report_abs(gdev->input, ABS_X,\n\t\t\t\t gdev->mouse_status_req->pointer_pos_x);\n\t\tinput_report_abs(gdev->input, ABS_Y,\n\t\t\t\t gdev->mouse_status_req->pointer_pos_y);\n\t\tinput_sync(gdev->input);\n\t}\n}\n\nstatic const struct pci_device_id vbg_pci_ids[] = {\n\t{ .vendor = VBOX_VENDORID, .device = VMMDEV_DEVICEID },\n\t{}\n};\nMODULE_DEVICE_TABLE(pci,  vbg_pci_ids);\n\nstatic struct pci_driver vbg_pci_driver = {\n\t.name\t\t= DEVICE_NAME,\n\t.dev_groups\t= vbg_pci_groups,\n\t.id_table\t= vbg_pci_ids,\n\t.probe\t\t= vbg_pci_probe,\n\t.remove\t\t= vbg_pci_remove,\n};\n\nmodule_pci_driver(vbg_pci_driver);\n\nMODULE_AUTHOR(\"Oracle Corporation\");\nMODULE_DESCRIPTION(\"Oracle VM VirtualBox Guest Additions for Linux Module\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}