{
  "module_name": "ne_pci_dev.h",
  "hash_id": "f917dc60f1b31f4c4d8f36296c137b2a73dcf6ca5577b09902e519cf4a330b85",
  "original_prompt": "Ingested from linux-6.6.14/drivers/virt/nitro_enclaves/ne_pci_dev.h",
  "human_readable_source": " \n \n\n#ifndef _NE_PCI_DEV_H_\n#define _NE_PCI_DEV_H_\n\n#include <linux/atomic.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/pci.h>\n#include <linux/pci_ids.h>\n#include <linux/wait.h>\n\n \n\n \n#define PCI_DEVICE_ID_NE\t(0xe4c1)\n \n#define PCI_BAR_NE\t\t(0x03)\n\n \n\n \n#define NE_ENABLE\t\t(0x0000)\n#define NE_ENABLE_OFF\t\t(0x00)\n#define NE_ENABLE_ON\t\t(0x01)\n\n \n#define NE_VERSION\t\t(0x0002)\n#define NE_VERSION_MAX\t\t(0x0001)\n\n \n#define NE_COMMAND\t\t(0x0004)\n\n \n#define NE_EVTCNT\t\t(0x000c)\n#define NE_EVTCNT_REPLY_SHIFT\t(0)\n#define NE_EVTCNT_REPLY_MASK\t(0x0000ffff)\n#define NE_EVTCNT_REPLY(cnt)\t(((cnt) & NE_EVTCNT_REPLY_MASK) >> \\\n\t\t\t\tNE_EVTCNT_REPLY_SHIFT)\n#define NE_EVTCNT_EVENT_SHIFT\t(16)\n#define NE_EVTCNT_EVENT_MASK\t(0xffff0000)\n#define NE_EVTCNT_EVENT(cnt)\t(((cnt) & NE_EVTCNT_EVENT_MASK) >> \\\n\t\t\t\tNE_EVTCNT_EVENT_SHIFT)\n\n \n#define NE_SEND_DATA\t\t(0x0010)\n\n \n#define NE_RECV_DATA\t\t(0x0100)\n\n \n\n \n#define NE_SEND_DATA_SIZE\t(240)\n\n \n#define NE_RECV_DATA_SIZE\t(240)\n\n \n\n \n#define NE_VEC_REPLY\t\t(0)\n\n \n#define NE_VEC_EVENT\t\t(1)\n\n \nenum ne_pci_dev_cmd_type {\n\tINVALID_CMD\t\t= 0,\n\tENCLAVE_START\t\t= 1,\n\tENCLAVE_GET_SLOT\t= 2,\n\tENCLAVE_STOP\t\t= 3,\n\tSLOT_ALLOC\t\t= 4,\n\tSLOT_FREE\t\t= 5,\n\tSLOT_ADD_MEM\t\t= 6,\n\tSLOT_ADD_VCPU\t\t= 7,\n\tSLOT_COUNT\t\t= 8,\n\tNEXT_SLOT\t\t= 9,\n\tSLOT_INFO\t\t= 10,\n\tSLOT_ADD_BULK_VCPUS\t= 11,\n\tMAX_CMD,\n};\n\n \n\n \nstruct enclave_start_req {\n\tu64\tslot_uid;\n\tu64\tenclave_cid;\n\tu64\tflags;\n};\n\n \nstruct enclave_get_slot_req {\n\tu64\tenclave_cid;\n};\n\n \nstruct enclave_stop_req {\n\tu64\tslot_uid;\n};\n\n \nstruct slot_alloc_req {\n\tu8\tunused;\n};\n\n \nstruct slot_free_req {\n\tu64\tslot_uid;\n};\n\n \n \nstruct slot_add_mem_req {\n\tu64\tslot_uid;\n\tu64\tpaddr;\n\tu64\tsize;\n};\n\n \nstruct slot_add_vcpu_req {\n\tu64\tslot_uid;\n\tu32\tvcpu_id;\n\tu8\tpadding[4];\n};\n\n \nstruct slot_count_req {\n\tu8\tunused;\n};\n\n \nstruct next_slot_req {\n\tu64\tslot_uid;\n};\n\n \nstruct slot_info_req {\n\tu64\tslot_uid;\n};\n\n \nstruct slot_add_bulk_vcpus_req {\n\tu64\tslot_uid;\n\tu64\tnr_vcpus;\n};\n\n \nstruct ne_pci_dev_cmd_reply {\n\ts32\trc;\n\tu8\tpadding0[4];\n\tu64\tslot_uid;\n\tu64\tenclave_cid;\n\tu64\tslot_count;\n\tu64\tmem_regions;\n\tu64\tmem_size;\n\tu64\tnr_vcpus;\n\tu64\tflags;\n\tu16\tstate;\n\tu8\tpadding1[6];\n};\n\n \nstruct ne_pci_dev {\n\tatomic_t\t\tcmd_reply_avail;\n\twait_queue_head_t\tcmd_reply_wait_q;\n\tstruct list_head\tenclaves_list;\n\tstruct mutex\t\tenclaves_list_mutex;\n\tstruct workqueue_struct\t*event_wq;\n\tvoid __iomem\t\t*iomem_base;\n\tstruct work_struct\tnotify_work;\n\tstruct mutex\t\tpci_dev_mutex;\n\tstruct pci_dev\t\t*pdev;\n};\n\n \nint ne_do_request(struct pci_dev *pdev, enum ne_pci_dev_cmd_type cmd_type,\n\t\t  void *cmd_request, size_t cmd_request_size,\n\t\t  struct ne_pci_dev_cmd_reply *cmd_reply,\n\t\t  size_t cmd_reply_size);\n\n \nextern struct pci_driver ne_pci_driver;\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}