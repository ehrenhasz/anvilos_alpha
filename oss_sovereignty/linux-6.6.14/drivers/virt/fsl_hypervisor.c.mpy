{
  "module_name": "fsl_hypervisor.c",
  "hash_id": "1b9c8870dfbb1ebf25064a3b53278cbf35d855113e3856a6bd5ed0d6a8270d21",
  "original_prompt": "Ingested from linux-6.6.14/drivers/virt/fsl_hypervisor.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/err.h>\n#include <linux/fs.h>\n#include <linux/miscdevice.h>\n#include <linux/mm.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/reboot.h>\n#include <linux/uaccess.h>\n#include <linux/notifier.h>\n#include <linux/interrupt.h>\n\n#include <linux/io.h>\n#include <asm/fsl_hcalls.h>\n\n#include <linux/fsl_hypervisor.h>\n\nstatic BLOCKING_NOTIFIER_HEAD(failover_subscribers);\n\n \nstatic long ioctl_restart(struct fsl_hv_ioctl_restart __user *p)\n{\n\tstruct fsl_hv_ioctl_restart param;\n\n\t \n\tif (copy_from_user(&param, p, sizeof(struct fsl_hv_ioctl_restart)))\n\t\treturn -EFAULT;\n\n\tparam.ret = fh_partition_restart(param.partition);\n\n\tif (copy_to_user(&p->ret, &param.ret, sizeof(__u32)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n \nstatic long ioctl_status(struct fsl_hv_ioctl_status __user *p)\n{\n\tstruct fsl_hv_ioctl_status param;\n\tu32 status;\n\n\t \n\tif (copy_from_user(&param, p, sizeof(struct fsl_hv_ioctl_status)))\n\t\treturn -EFAULT;\n\n\tparam.ret = fh_partition_get_status(param.partition, &status);\n\tif (!param.ret)\n\t\tparam.status = status;\n\n\tif (copy_to_user(p, &param, sizeof(struct fsl_hv_ioctl_status)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n \nstatic long ioctl_start(struct fsl_hv_ioctl_start __user *p)\n{\n\tstruct fsl_hv_ioctl_start param;\n\n\t \n\tif (copy_from_user(&param, p, sizeof(struct fsl_hv_ioctl_start)))\n\t\treturn -EFAULT;\n\n\tparam.ret = fh_partition_start(param.partition, param.entry_point,\n\t\t\t\t       param.load);\n\n\tif (copy_to_user(&p->ret, &param.ret, sizeof(__u32)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n \nstatic long ioctl_stop(struct fsl_hv_ioctl_stop __user *p)\n{\n\tstruct fsl_hv_ioctl_stop param;\n\n\t \n\tif (copy_from_user(&param, p, sizeof(struct fsl_hv_ioctl_stop)))\n\t\treturn -EFAULT;\n\n\tparam.ret = fh_partition_stop(param.partition);\n\n\tif (copy_to_user(&p->ret, &param.ret, sizeof(__u32)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n \nstatic long ioctl_memcpy(struct fsl_hv_ioctl_memcpy __user *p)\n{\n\tstruct fsl_hv_ioctl_memcpy param;\n\n\tstruct page **pages = NULL;\n\tvoid *sg_list_unaligned = NULL;\n\tstruct fh_sg_list *sg_list = NULL;\n\n\tunsigned int num_pages;\n\tunsigned long lb_offset;  \n\n\tunsigned int i;\n\tlong ret = 0;\n\tint num_pinned = 0;  \n\tphys_addr_t remote_paddr;  \n\tuint32_t count;  \n\n\t \n\tif (copy_from_user(&param, p, sizeof(struct fsl_hv_ioctl_memcpy)))\n\t\treturn -EFAULT;\n\n\t \n\tif ((param.source == -1) == (param.target == -1))\n\t\treturn -EINVAL;\n\n\t \n\tlb_offset = param.local_vaddr & (PAGE_SIZE - 1);\n\tif (param.count == 0 ||\n\t    param.count > U64_MAX - lb_offset - PAGE_SIZE + 1)\n\t\treturn -EINVAL;\n\tnum_pages = (param.count + lb_offset + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\n\t \n\n\t \n\tpages = kcalloc(num_pages, sizeof(struct page *), GFP_KERNEL);\n\tif (!pages) {\n\t\tpr_debug(\"fsl-hv: could not allocate page list\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tsg_list_unaligned = kmalloc(num_pages * sizeof(struct fh_sg_list) +\n\t\tsizeof(struct fh_sg_list) - 1, GFP_KERNEL);\n\tif (!sg_list_unaligned) {\n\t\tpr_debug(\"fsl-hv: could not allocate S/G list\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto free_pages;\n\t}\n\tsg_list = PTR_ALIGN(sg_list_unaligned, sizeof(struct fh_sg_list));\n\n\t \n\tnum_pinned = get_user_pages_fast(param.local_vaddr - lb_offset,\n\t\tnum_pages, param.source != -1 ? FOLL_WRITE : 0, pages);\n\n\tif (num_pinned != num_pages) {\n\t\tpr_debug(\"fsl-hv: could not lock source buffer\\n\");\n\t\tret = (num_pinned < 0) ? num_pinned : -EFAULT;\n\t\tgoto exit;\n\t}\n\n\t \n\tif (param.source == -1) {\n\t\tsg_list[0].source = page_to_phys(pages[0]) + lb_offset;\n\t\tsg_list[0].target = param.remote_paddr;\n\t} else {\n\t\tsg_list[0].source = param.remote_paddr;\n\t\tsg_list[0].target = page_to_phys(pages[0]) + lb_offset;\n\t}\n\tsg_list[0].size = min_t(uint64_t, param.count, PAGE_SIZE - lb_offset);\n\n\tremote_paddr = param.remote_paddr + sg_list[0].size;\n\tcount = param.count - sg_list[0].size;\n\n\tfor (i = 1; i < num_pages; i++) {\n\t\tif (param.source == -1) {\n\t\t\t \n\t\t\tsg_list[i].source = page_to_phys(pages[i]);\n\t\t\tsg_list[i].target = remote_paddr;\n\t\t} else {\n\t\t\t \n\t\t\tsg_list[i].source = remote_paddr;\n\t\t\tsg_list[i].target = page_to_phys(pages[i]);\n\t\t}\n\t\tsg_list[i].size = min_t(uint64_t, count, PAGE_SIZE);\n\n\t\tremote_paddr += sg_list[i].size;\n\t\tcount -= sg_list[i].size;\n\t}\n\n\tparam.ret = fh_partition_memcpy(param.source, param.target,\n\t\tvirt_to_phys(sg_list), num_pages);\n\nexit:\n\tif (pages && (num_pinned > 0)) {\n\t\tfor (i = 0; i < num_pinned; i++)\n\t\t\tput_page(pages[i]);\n\t}\n\n\tkfree(sg_list_unaligned);\nfree_pages:\n\tkfree(pages);\n\n\tif (!ret)\n\t\tif (copy_to_user(&p->ret, &param.ret, sizeof(__u32)))\n\t\t\treturn -EFAULT;\n\n\treturn ret;\n}\n\n \nstatic long ioctl_doorbell(struct fsl_hv_ioctl_doorbell __user *p)\n{\n\tstruct fsl_hv_ioctl_doorbell param;\n\n\t \n\tif (copy_from_user(&param, p, sizeof(struct fsl_hv_ioctl_doorbell)))\n\t\treturn -EFAULT;\n\n\tparam.ret = ev_doorbell_send(param.doorbell);\n\n\tif (copy_to_user(&p->ret, &param.ret, sizeof(__u32)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic long ioctl_dtprop(struct fsl_hv_ioctl_prop __user *p, int set)\n{\n\tstruct fsl_hv_ioctl_prop param;\n\tchar __user *upath, *upropname;\n\tvoid __user *upropval;\n\tchar *path, *propname;\n\tvoid *propval;\n\tint ret = 0;\n\n\t \n\tif (copy_from_user(&param, p, sizeof(struct fsl_hv_ioctl_prop)))\n\t\treturn -EFAULT;\n\n\tupath = (char __user *)(uintptr_t)param.path;\n\tupropname = (char __user *)(uintptr_t)param.propname;\n\tupropval = (void __user *)(uintptr_t)param.propval;\n\n\tpath = strndup_user(upath, FH_DTPROP_MAX_PATHLEN);\n\tif (IS_ERR(path))\n\t\treturn PTR_ERR(path);\n\n\tpropname = strndup_user(upropname, FH_DTPROP_MAX_PATHLEN);\n\tif (IS_ERR(propname)) {\n\t\tret = PTR_ERR(propname);\n\t\tgoto err_free_path;\n\t}\n\n\tif (param.proplen > FH_DTPROP_MAX_PROPLEN) {\n\t\tret = -EINVAL;\n\t\tgoto err_free_propname;\n\t}\n\n\tpropval = kmalloc(param.proplen, GFP_KERNEL);\n\tif (!propval) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_propname;\n\t}\n\n\tif (set) {\n\t\tif (copy_from_user(propval, upropval, param.proplen)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto err_free_propval;\n\t\t}\n\n\t\tparam.ret = fh_partition_set_dtprop(param.handle,\n\t\t\t\t\t\t    virt_to_phys(path),\n\t\t\t\t\t\t    virt_to_phys(propname),\n\t\t\t\t\t\t    virt_to_phys(propval),\n\t\t\t\t\t\t    param.proplen);\n\t} else {\n\t\tparam.ret = fh_partition_get_dtprop(param.handle,\n\t\t\t\t\t\t    virt_to_phys(path),\n\t\t\t\t\t\t    virt_to_phys(propname),\n\t\t\t\t\t\t    virt_to_phys(propval),\n\t\t\t\t\t\t    &param.proplen);\n\n\t\tif (param.ret == 0) {\n\t\t\tif (copy_to_user(upropval, propval, param.proplen) ||\n\t\t\t    put_user(param.proplen, &p->proplen)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto err_free_propval;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (put_user(param.ret, &p->ret))\n\t\tret = -EFAULT;\n\nerr_free_propval:\n\tkfree(propval);\nerr_free_propname:\n\tkfree(propname);\nerr_free_path:\n\tkfree(path);\n\n\treturn ret;\n}\n\n \nstatic long fsl_hv_ioctl(struct file *file, unsigned int cmd,\n\t\t\t unsigned long argaddr)\n{\n\tvoid __user *arg = (void __user *)argaddr;\n\tlong ret;\n\n\tswitch (cmd) {\n\tcase FSL_HV_IOCTL_PARTITION_RESTART:\n\t\tret = ioctl_restart(arg);\n\t\tbreak;\n\tcase FSL_HV_IOCTL_PARTITION_GET_STATUS:\n\t\tret = ioctl_status(arg);\n\t\tbreak;\n\tcase FSL_HV_IOCTL_PARTITION_START:\n\t\tret = ioctl_start(arg);\n\t\tbreak;\n\tcase FSL_HV_IOCTL_PARTITION_STOP:\n\t\tret = ioctl_stop(arg);\n\t\tbreak;\n\tcase FSL_HV_IOCTL_MEMCPY:\n\t\tret = ioctl_memcpy(arg);\n\t\tbreak;\n\tcase FSL_HV_IOCTL_DOORBELL:\n\t\tret = ioctl_doorbell(arg);\n\t\tbreak;\n\tcase FSL_HV_IOCTL_GETPROP:\n\t\tret = ioctl_dtprop(arg, 0);\n\t\tbreak;\n\tcase FSL_HV_IOCTL_SETPROP:\n\t\tret = ioctl_dtprop(arg, 1);\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"fsl-hv: bad ioctl dir=%u type=%u cmd=%u size=%u\\n\",\n\t\t\t _IOC_DIR(cmd), _IOC_TYPE(cmd), _IOC_NR(cmd),\n\t\t\t _IOC_SIZE(cmd));\n\t\treturn -ENOTTY;\n\t}\n\n\treturn ret;\n}\n\n \nstatic struct list_head db_list;\n\n \nstatic DEFINE_SPINLOCK(db_list_lock);\n\n \n#define QSIZE\t16\n\n \n#define nextp(x) (((x) + 1) & (QSIZE - 1))\n\n \nstruct doorbell_queue {\n\tstruct list_head list;\n\tspinlock_t lock;\n\twait_queue_head_t wait;\n\tunsigned int head;\n\tunsigned int tail;\n\tuint32_t q[QSIZE];\n};\n\n \nstruct list_head isr_list;\n\n \nstruct doorbell_isr {\n\tstruct list_head list;\n\tunsigned int irq;\n\tuint32_t doorbell;\t \n\tuint32_t partition;\t \n};\n\n \nstatic void fsl_hv_queue_doorbell(uint32_t doorbell)\n{\n\tstruct doorbell_queue *dbq;\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&db_list_lock, flags);\n\n\tlist_for_each_entry(dbq, &db_list, list) {\n\t\tif (dbq->head != nextp(dbq->tail)) {\n\t\t\tdbq->q[dbq->tail] = doorbell;\n\t\t\t \n\t\t\tsmp_wmb();\n\t\t\tdbq->tail = nextp(dbq->tail);\n\t\t\twake_up_interruptible(&dbq->wait);\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&db_list_lock, flags);\n}\n\n \nstatic irqreturn_t fsl_hv_isr(int irq, void *data)\n{\n\tfsl_hv_queue_doorbell((uintptr_t) data);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t fsl_hv_state_change_thread(int irq, void *data)\n{\n\tstruct doorbell_isr *dbisr = data;\n\n\tblocking_notifier_call_chain(&failover_subscribers, dbisr->partition,\n\t\t\t\t     NULL);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t fsl_hv_state_change_isr(int irq, void *data)\n{\n\tunsigned int status;\n\tstruct doorbell_isr *dbisr = data;\n\tint ret;\n\n\t \n\tfsl_hv_queue_doorbell(dbisr->doorbell);\n\n\t \n\tret = fh_partition_get_status(dbisr->partition, &status);\n\tif (!ret && (status == FH_PARTITION_STOPPED))\n\t\treturn IRQ_WAKE_THREAD;\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic __poll_t fsl_hv_poll(struct file *filp, struct poll_table_struct *p)\n{\n\tstruct doorbell_queue *dbq = filp->private_data;\n\tunsigned long flags;\n\t__poll_t mask;\n\n\tspin_lock_irqsave(&dbq->lock, flags);\n\n\tpoll_wait(filp, &dbq->wait, p);\n\tmask = (dbq->head == dbq->tail) ? 0 : (EPOLLIN | EPOLLRDNORM);\n\n\tspin_unlock_irqrestore(&dbq->lock, flags);\n\n\treturn mask;\n}\n\n \nstatic ssize_t fsl_hv_read(struct file *filp, char __user *buf, size_t len,\n\t\t\t   loff_t *off)\n{\n\tstruct doorbell_queue *dbq = filp->private_data;\n\tuint32_t __user *p = (uint32_t __user *) buf;  \n\tunsigned long flags;\n\tssize_t count = 0;\n\n\t \n\twhile (len >= sizeof(uint32_t)) {\n\t\tuint32_t dbell;\t \n\n\t\tspin_lock_irqsave(&dbq->lock, flags);\n\n\t\t \n\t\tif (dbq->head == dbq->tail) {\n\t\t\tspin_unlock_irqrestore(&dbq->lock, flags);\n\t\t\tif (count)\n\t\t\t\tbreak;\n\t\t\tif (filp->f_flags & O_NONBLOCK)\n\t\t\t\treturn -EAGAIN;\n\t\t\tif (wait_event_interruptible(dbq->wait,\n\t\t\t\t\t\t     dbq->head != dbq->tail))\n\t\t\t\treturn -ERESTARTSYS;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tsmp_rmb();\n\n\t\t \n\t\tdbell = dbq->q[dbq->head];\n\t\tdbq->head = nextp(dbq->head);\n\n\t\tspin_unlock_irqrestore(&dbq->lock, flags);\n\n\t\tif (put_user(dbell, p))\n\t\t\treturn -EFAULT;\n\t\tp++;\n\t\tcount += sizeof(uint32_t);\n\t\tlen -= sizeof(uint32_t);\n\t}\n\n\treturn count;\n}\n\n \nstatic int fsl_hv_open(struct inode *inode, struct file *filp)\n{\n\tstruct doorbell_queue *dbq;\n\tunsigned long flags;\n\n\tdbq = kzalloc(sizeof(struct doorbell_queue), GFP_KERNEL);\n\tif (!dbq) {\n\t\tpr_err(\"fsl-hv: out of memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock_init(&dbq->lock);\n\tinit_waitqueue_head(&dbq->wait);\n\n\tspin_lock_irqsave(&db_list_lock, flags);\n\tlist_add(&dbq->list, &db_list);\n\tspin_unlock_irqrestore(&db_list_lock, flags);\n\n\tfilp->private_data = dbq;\n\n\treturn 0;\n}\n\n \nstatic int fsl_hv_close(struct inode *inode, struct file *filp)\n{\n\tstruct doorbell_queue *dbq = filp->private_data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&db_list_lock, flags);\n\tlist_del(&dbq->list);\n\tspin_unlock_irqrestore(&db_list_lock, flags);\n\n\tkfree(dbq);\n\n\treturn 0;\n}\n\nstatic const struct file_operations fsl_hv_fops = {\n\t.owner = THIS_MODULE,\n\t.open = fsl_hv_open,\n\t.release = fsl_hv_close,\n\t.poll = fsl_hv_poll,\n\t.read = fsl_hv_read,\n\t.unlocked_ioctl = fsl_hv_ioctl,\n\t.compat_ioctl = compat_ptr_ioctl,\n};\n\nstatic struct miscdevice fsl_hv_misc_dev = {\n\tMISC_DYNAMIC_MINOR,\n\t\"fsl-hv\",\n\t&fsl_hv_fops\n};\n\nstatic irqreturn_t fsl_hv_shutdown_isr(int irq, void *data)\n{\n\torderly_poweroff(false);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int get_parent_handle(struct device_node *np)\n{\n\tstruct device_node *parent;\n\tconst uint32_t *prop;\n\tuint32_t handle;\n\tint len;\n\n\tparent = of_get_parent(np);\n\tif (!parent)\n\t\t \n\t\treturn -ENODEV;\n\n\t \n\tprop = of_get_property(parent, \"hv-handle\", &len);\n\tif (!prop)\n\t\tprop = of_get_property(parent, \"reg\", &len);\n\n\tif (!prop || (len != sizeof(uint32_t))) {\n\t\t \n\t\tof_node_put(parent);\n\t\treturn -ENODEV;\n\t}\n\n\thandle = be32_to_cpup(prop);\n\tof_node_put(parent);\n\n\treturn handle;\n}\n\n \nint fsl_hv_failover_register(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_register(&failover_subscribers, nb);\n}\nEXPORT_SYMBOL(fsl_hv_failover_register);\n\n \nint fsl_hv_failover_unregister(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&failover_subscribers, nb);\n}\nEXPORT_SYMBOL(fsl_hv_failover_unregister);\n\n \nstatic int has_fsl_hypervisor(void)\n{\n\tstruct device_node *node;\n\tint ret;\n\n\tnode = of_find_node_by_path(\"/hypervisor\");\n\tif (!node)\n\t\treturn 0;\n\n\tret = of_property_present(node, \"fsl,hv-version\");\n\n\tof_node_put(node);\n\n\treturn ret;\n}\n\n \nstatic int __init fsl_hypervisor_init(void)\n{\n\tstruct device_node *np;\n\tstruct doorbell_isr *dbisr, *n;\n\tint ret;\n\n\tpr_info(\"Freescale hypervisor management driver\\n\");\n\n\tif (!has_fsl_hypervisor()) {\n\t\tpr_info(\"fsl-hv: no hypervisor found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = misc_register(&fsl_hv_misc_dev);\n\tif (ret) {\n\t\tpr_err(\"fsl-hv: cannot register device\\n\");\n\t\treturn ret;\n\t}\n\n\tINIT_LIST_HEAD(&db_list);\n\tINIT_LIST_HEAD(&isr_list);\n\n\tfor_each_compatible_node(np, NULL, \"epapr,hv-receive-doorbell\") {\n\t\tunsigned int irq;\n\t\tconst uint32_t *handle;\n\n\t\thandle = of_get_property(np, \"interrupts\", NULL);\n\t\tirq = irq_of_parse_and_map(np, 0);\n\t\tif (!handle || !irq) {\n\t\t\tpr_err(\"fsl-hv: no 'interrupts' property in %pOF node\\n\",\n\t\t\t\tnp);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdbisr = kzalloc(sizeof(*dbisr), GFP_KERNEL);\n\t\tif (!dbisr)\n\t\t\tgoto out_of_memory;\n\n\t\tdbisr->irq = irq;\n\t\tdbisr->doorbell = be32_to_cpup(handle);\n\n\t\tif (of_device_is_compatible(np, \"fsl,hv-shutdown-doorbell\")) {\n\t\t\t \n\t\t\tret = request_irq(irq, fsl_hv_shutdown_isr, 0,\n\t\t\t\t\t  np->name, NULL);\n\t\t} else if (of_device_is_compatible(np,\n\t\t\t\"fsl,hv-state-change-doorbell\")) {\n\t\t\t \n\t\t\tdbisr->partition = ret = get_parent_handle(np);\n\t\t\tif (ret < 0) {\n\t\t\t\tpr_err(\"fsl-hv: node %pOF has missing or \"\n\t\t\t\t       \"malformed parent\\n\", np);\n\t\t\t\tkfree(dbisr);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tret = request_threaded_irq(irq, fsl_hv_state_change_isr,\n\t\t\t\t\t\t   fsl_hv_state_change_thread,\n\t\t\t\t\t\t   0, np->name, dbisr);\n\t\t} else\n\t\t\tret = request_irq(irq, fsl_hv_isr, 0, np->name, dbisr);\n\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"fsl-hv: could not request irq %u for node %pOF\\n\",\n\t\t\t       irq, np);\n\t\t\tkfree(dbisr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlist_add(&dbisr->list, &isr_list);\n\n\t\tpr_info(\"fsl-hv: registered handler for doorbell %u\\n\",\n\t\t\tdbisr->doorbell);\n\t}\n\n\treturn 0;\n\nout_of_memory:\n\tlist_for_each_entry_safe(dbisr, n, &isr_list, list) {\n\t\tfree_irq(dbisr->irq, dbisr);\n\t\tlist_del(&dbisr->list);\n\t\tkfree(dbisr);\n\t}\n\n\tmisc_deregister(&fsl_hv_misc_dev);\n\n\treturn -ENOMEM;\n}\n\n \nstatic void __exit fsl_hypervisor_exit(void)\n{\n\tstruct doorbell_isr *dbisr, *n;\n\n\tlist_for_each_entry_safe(dbisr, n, &isr_list, list) {\n\t\tfree_irq(dbisr->irq, dbisr);\n\t\tlist_del(&dbisr->list);\n\t\tkfree(dbisr);\n\t}\n\n\tmisc_deregister(&fsl_hv_misc_dev);\n}\n\nmodule_init(fsl_hypervisor_init);\nmodule_exit(fsl_hypervisor_exit);\n\nMODULE_AUTHOR(\"Timur Tabi <timur@freescale.com>\");\nMODULE_DESCRIPTION(\"Freescale hypervisor management driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}