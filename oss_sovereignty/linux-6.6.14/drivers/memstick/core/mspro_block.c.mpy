{
  "module_name": "mspro_block.c",
  "hash_id": "ad96a8182e0e2b7dac64f37a5152fb580fe716fc81efadf66b6a9407c1a5ac08",
  "original_prompt": "Ingested from linux-6.6.14/drivers/memstick/core/mspro_block.c",
  "human_readable_source": "\n \n\n#include <linux/blk-mq.h>\n#include <linux/idr.h>\n#include <linux/hdreg.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/memstick.h>\n#include <linux/module.h>\n\n#define DRIVER_NAME \"mspro_block\"\n\nstatic int major;\nmodule_param(major, int, 0644);\n\n#define MSPRO_BLOCK_MAX_SEGS  32\n#define MSPRO_BLOCK_MAX_PAGES ((2 << 16) - 1)\n\n#define MSPRO_BLOCK_SIGNATURE        0xa5c3\n#define MSPRO_BLOCK_MAX_ATTRIBUTES   41\n\n#define MSPRO_BLOCK_PART_SHIFT 3\n\nenum {\n\tMSPRO_BLOCK_ID_SYSINFO         = 0x10,\n\tMSPRO_BLOCK_ID_MODELNAME       = 0x15,\n\tMSPRO_BLOCK_ID_MBR             = 0x20,\n\tMSPRO_BLOCK_ID_PBR16           = 0x21,\n\tMSPRO_BLOCK_ID_PBR32           = 0x22,\n\tMSPRO_BLOCK_ID_SPECFILEVALUES1 = 0x25,\n\tMSPRO_BLOCK_ID_SPECFILEVALUES2 = 0x26,\n\tMSPRO_BLOCK_ID_DEVINFO         = 0x30\n};\n\nstruct mspro_sys_attr {\n\tsize_t                  size;\n\tvoid                    *data;\n\tunsigned char           id;\n\tchar                    name[32];\n\tstruct device_attribute dev_attr;\n};\n\nstruct mspro_attr_entry {\n\t__be32 address;\n\t__be32 size;\n\tunsigned char id;\n\tunsigned char reserved[3];\n} __attribute__((packed));\n\nstruct mspro_attribute {\n\t__be16 signature;\n\tunsigned short          version;\n\tunsigned char           count;\n\tunsigned char           reserved[11];\n\tstruct mspro_attr_entry entries[];\n} __attribute__((packed));\n\nstruct mspro_sys_info {\n\tunsigned char  class;\n\tunsigned char  reserved0;\n\t__be16 block_size;\n\t__be16 block_count;\n\t__be16 user_block_count;\n\t__be16 page_size;\n\tunsigned char  reserved1[2];\n\tunsigned char  assembly_date[8];\n\t__be32 serial_number;\n\tunsigned char  assembly_maker_code;\n\tunsigned char  assembly_model_code[3];\n\t__be16 memory_maker_code;\n\t__be16 memory_model_code;\n\tunsigned char  reserved2[4];\n\tunsigned char  vcc;\n\tunsigned char  vpp;\n\t__be16 controller_number;\n\t__be16 controller_function;\n\t__be16 start_sector;\n\t__be16 unit_size;\n\tunsigned char  ms_sub_class;\n\tunsigned char  reserved3[4];\n\tunsigned char  interface_type;\n\t__be16 controller_code;\n\tunsigned char  format_type;\n\tunsigned char  reserved4;\n\tunsigned char  device_type;\n\tunsigned char  reserved5[7];\n\tunsigned char  mspro_id[16];\n\tunsigned char  reserved6[16];\n} __attribute__((packed));\n\nstruct mspro_mbr {\n\tunsigned char boot_partition;\n\tunsigned char start_head;\n\tunsigned char start_sector;\n\tunsigned char start_cylinder;\n\tunsigned char partition_type;\n\tunsigned char end_head;\n\tunsigned char end_sector;\n\tunsigned char end_cylinder;\n\tunsigned int  start_sectors;\n\tunsigned int  sectors_per_partition;\n} __attribute__((packed));\n\nstruct mspro_specfile {\n\tchar           name[8];\n\tchar           ext[3];\n\tunsigned char  attr;\n\tunsigned char  reserved[10];\n\tunsigned short time;\n\tunsigned short date;\n\tunsigned short cluster;\n\tunsigned int   size;\n} __attribute__((packed));\n\nstruct mspro_devinfo {\n\t__be16 cylinders;\n\t__be16 heads;\n\t__be16 bytes_per_track;\n\t__be16 bytes_per_sector;\n\t__be16 sectors_per_track;\n\tunsigned char  reserved[6];\n} __attribute__((packed));\n\nstruct mspro_block_data {\n\tstruct memstick_dev   *card;\n\tunsigned int          caps;\n\tstruct gendisk        *disk;\n\tstruct request_queue  *queue;\n\tstruct request        *block_req;\n\tstruct blk_mq_tag_set tag_set;\n\tspinlock_t            q_lock;\n\n\tunsigned short        page_size;\n\tunsigned short        cylinders;\n\tunsigned short        heads;\n\tunsigned short        sectors_per_track;\n\n\tunsigned char         system;\n\tunsigned char         read_only:1,\n\t\t\t      eject:1,\n\t\t\t      data_dir:1,\n\t\t\t      active:1;\n\tunsigned char         transfer_cmd;\n\n\tint                   (*mrq_handler)(struct memstick_dev *card,\n\t\t\t\t\t     struct memstick_request **mrq);\n\n\n\t \n\tvoid                  (*setup_transfer)(struct memstick_dev *card,\n\t\t\t\t\t\tu64 offset, size_t length);\n\n\tstruct attribute_group attr_group;\n\n\tstruct scatterlist    req_sg[MSPRO_BLOCK_MAX_SEGS];\n\tunsigned int          seg_count;\n\tunsigned int          current_seg;\n\tunsigned int          current_page;\n};\n\nstatic DEFINE_IDR(mspro_block_disk_idr);\nstatic DEFINE_MUTEX(mspro_block_disk_lock);\n\nstatic int mspro_block_complete_req(struct memstick_dev *card, int error);\n\n \n\nstatic void mspro_block_bd_free_disk(struct gendisk *disk)\n{\n\tstruct mspro_block_data *msb = disk->private_data;\n\tint disk_id = MINOR(disk_devt(disk)) >> MSPRO_BLOCK_PART_SHIFT;\n\n\tmutex_lock(&mspro_block_disk_lock);\n\tidr_remove(&mspro_block_disk_idr, disk_id);\n\tmutex_unlock(&mspro_block_disk_lock);\n\n\tkfree(msb);\n}\n\nstatic int mspro_block_bd_getgeo(struct block_device *bdev,\n\t\t\t\t struct hd_geometry *geo)\n{\n\tstruct mspro_block_data *msb = bdev->bd_disk->private_data;\n\n\tgeo->heads = msb->heads;\n\tgeo->sectors = msb->sectors_per_track;\n\tgeo->cylinders = msb->cylinders;\n\n\treturn 0;\n}\n\nstatic const struct block_device_operations ms_block_bdops = {\n\t.owner\t\t= THIS_MODULE,\n\t.getgeo\t\t= mspro_block_bd_getgeo,\n\t.free_disk\t= mspro_block_bd_free_disk,\n};\n\n \n\nstatic struct mspro_sys_attr *mspro_from_sysfs_attr(struct attribute *attr)\n{\n\tstruct device_attribute *dev_attr\n\t\t= container_of(attr, struct device_attribute, attr);\n\treturn container_of(dev_attr, struct mspro_sys_attr, dev_attr);\n}\n\nstatic const char *mspro_block_attr_name(unsigned char tag)\n{\n\tswitch (tag) {\n\tcase MSPRO_BLOCK_ID_SYSINFO:\n\t\treturn \"attr_sysinfo\";\n\tcase MSPRO_BLOCK_ID_MODELNAME:\n\t\treturn \"attr_modelname\";\n\tcase MSPRO_BLOCK_ID_MBR:\n\t\treturn \"attr_mbr\";\n\tcase MSPRO_BLOCK_ID_PBR16:\n\t\treturn \"attr_pbr16\";\n\tcase MSPRO_BLOCK_ID_PBR32:\n\t\treturn \"attr_pbr32\";\n\tcase MSPRO_BLOCK_ID_SPECFILEVALUES1:\n\t\treturn \"attr_specfilevalues1\";\n\tcase MSPRO_BLOCK_ID_SPECFILEVALUES2:\n\t\treturn \"attr_specfilevalues2\";\n\tcase MSPRO_BLOCK_ID_DEVINFO:\n\t\treturn \"attr_devinfo\";\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\ntypedef ssize_t (*sysfs_show_t)(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *buffer);\n\nstatic ssize_t mspro_block_attr_show_default(struct device *dev,\n\t\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t\t     char *buffer)\n{\n\tstruct mspro_sys_attr *s_attr = container_of(attr,\n\t\t\t\t\t\t     struct mspro_sys_attr,\n\t\t\t\t\t\t     dev_attr);\n\n\tssize_t cnt, rc = 0;\n\n\tfor (cnt = 0; cnt < s_attr->size; cnt++) {\n\t\tif (cnt && !(cnt % 16)) {\n\t\t\tif (PAGE_SIZE - rc)\n\t\t\t\tbuffer[rc++] = '\\n';\n\t\t}\n\n\t\trc += sysfs_emit_at(buffer, rc, \"%02x \",\n\t\t\t\t    ((unsigned char *)s_attr->data)[cnt]);\n\t}\n\treturn rc;\n}\n\nstatic ssize_t mspro_block_attr_show_sysinfo(struct device *dev,\n\t\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t\t     char *buffer)\n{\n\tstruct mspro_sys_attr *x_attr = container_of(attr,\n\t\t\t\t\t\t     struct mspro_sys_attr,\n\t\t\t\t\t\t     dev_attr);\n\tstruct mspro_sys_info *x_sys = x_attr->data;\n\tssize_t rc = 0;\n\tint date_tz = 0, date_tz_f = 0;\n\n\tif (x_sys->assembly_date[0] > 0x80U) {\n\t\tdate_tz = (~x_sys->assembly_date[0]) + 1;\n\t\tdate_tz_f = date_tz & 3;\n\t\tdate_tz >>= 2;\n\t\tdate_tz = -date_tz;\n\t\tdate_tz_f *= 15;\n\t} else if (x_sys->assembly_date[0] < 0x80U) {\n\t\tdate_tz = x_sys->assembly_date[0];\n\t\tdate_tz_f = date_tz & 3;\n\t\tdate_tz >>= 2;\n\t\tdate_tz_f *= 15;\n\t}\n\n\trc += sysfs_emit_at(buffer, rc, \"class: %x\\n\", x_sys->class);\n\trc += sysfs_emit_at(buffer, rc, \"block size: %x\\n\", be16_to_cpu(x_sys->block_size));\n\trc += sysfs_emit_at(buffer, rc, \"block count: %x\\n\", be16_to_cpu(x_sys->block_count));\n\trc += sysfs_emit_at(buffer, rc, \"user block count: %x\\n\",\n\t\t\t    be16_to_cpu(x_sys->user_block_count));\n\trc += sysfs_emit_at(buffer, rc, \"page size: %x\\n\", be16_to_cpu(x_sys->page_size));\n\trc += sysfs_emit_at(buffer, rc, \"assembly date: GMT%+d:%d %04u-%02u-%02u %02u:%02u:%02u\\n\",\n\t\t\t    date_tz, date_tz_f,\n\t\t\t    be16_to_cpup((__be16 *)&x_sys->assembly_date[1]),\n\t\t\t    x_sys->assembly_date[3], x_sys->assembly_date[4],\n\t\t\t    x_sys->assembly_date[5], x_sys->assembly_date[6],\n\t\t\t    x_sys->assembly_date[7]);\n\trc += sysfs_emit_at(buffer, rc, \"serial number: %x\\n\", be32_to_cpu(x_sys->serial_number));\n\trc += sysfs_emit_at(buffer, rc, \"assembly maker code: %x\\n\", x_sys->assembly_maker_code);\n\trc += sysfs_emit_at(buffer, rc, \"assembly model code: %02x%02x%02x\\n\",\n\t\t\t    x_sys->assembly_model_code[0],\n\t\t\t    x_sys->assembly_model_code[1],\n\t\t\t    x_sys->assembly_model_code[2]);\n\trc += sysfs_emit_at(buffer, rc, \"memory maker code: %x\\n\",\n\t\t\t    be16_to_cpu(x_sys->memory_maker_code));\n\trc += sysfs_emit_at(buffer, rc, \"memory model code: %x\\n\",\n\t\t\t    be16_to_cpu(x_sys->memory_model_code));\n\trc += sysfs_emit_at(buffer, rc, \"vcc: %x\\n\", x_sys->vcc);\n\trc += sysfs_emit_at(buffer, rc, \"vpp: %x\\n\", x_sys->vpp);\n\trc += sysfs_emit_at(buffer, rc, \"controller number: %x\\n\",\n\t\t\t    be16_to_cpu(x_sys->controller_number));\n\trc += sysfs_emit_at(buffer, rc, \"controller function: %x\\n\",\n\t\t\t    be16_to_cpu(x_sys->controller_function));\n\trc += sysfs_emit_at(buffer, rc, \"start sector: %x\\n\", be16_to_cpu(x_sys->start_sector));\n\trc += sysfs_emit_at(buffer, rc, \"unit size: %x\\n\", be16_to_cpu(x_sys->unit_size));\n\trc += sysfs_emit_at(buffer, rc, \"sub class: %x\\n\", x_sys->ms_sub_class);\n\trc += sysfs_emit_at(buffer, rc, \"interface type: %x\\n\", x_sys->interface_type);\n\trc += sysfs_emit_at(buffer, rc, \"controller code: %x\\n\",\n\t\t\t    be16_to_cpu(x_sys->controller_code));\n\trc += sysfs_emit_at(buffer, rc, \"format type: %x\\n\", x_sys->format_type);\n\trc += sysfs_emit_at(buffer, rc, \"device type: %x\\n\", x_sys->device_type);\n\trc += sysfs_emit_at(buffer, rc, \"mspro id: %s\\n\", x_sys->mspro_id);\n\treturn rc;\n}\n\nstatic ssize_t mspro_block_attr_show_modelname(struct device *dev,\n\t\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t\t       char *buffer)\n{\n\tstruct mspro_sys_attr *s_attr = container_of(attr,\n\t\t\t\t\t\t     struct mspro_sys_attr,\n\t\t\t\t\t\t     dev_attr);\n\n\treturn sysfs_emit(buffer, \"%s\", (char *)s_attr->data);\n}\n\nstatic ssize_t mspro_block_attr_show_mbr(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *buffer)\n{\n\tstruct mspro_sys_attr *x_attr = container_of(attr,\n\t\t\t\t\t\t     struct mspro_sys_attr,\n\t\t\t\t\t\t     dev_attr);\n\tstruct mspro_mbr *x_mbr = x_attr->data;\n\tssize_t rc = 0;\n\n\trc += sysfs_emit_at(buffer, rc, \"boot partition: %x\\n\", x_mbr->boot_partition);\n\trc += sysfs_emit_at(buffer, rc, \"start head: %x\\n\", x_mbr->start_head);\n\trc += sysfs_emit_at(buffer, rc, \"start sector: %x\\n\", x_mbr->start_sector);\n\trc += sysfs_emit_at(buffer, rc, \"start cylinder: %x\\n\", x_mbr->start_cylinder);\n\trc += sysfs_emit_at(buffer, rc, \"partition type: %x\\n\", x_mbr->partition_type);\n\trc += sysfs_emit_at(buffer, rc, \"end head: %x\\n\", x_mbr->end_head);\n\trc += sysfs_emit_at(buffer, rc, \"end sector: %x\\n\", x_mbr->end_sector);\n\trc += sysfs_emit_at(buffer, rc, \"end cylinder: %x\\n\", x_mbr->end_cylinder);\n\trc += sysfs_emit_at(buffer, rc, \"start sectors: %x\\n\", x_mbr->start_sectors);\n\trc += sysfs_emit_at(buffer, rc, \"sectors per partition: %x\\n\",\n\t\t\t    x_mbr->sectors_per_partition);\n\treturn rc;\n}\n\nstatic ssize_t mspro_block_attr_show_specfile(struct device *dev,\n\t\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t\t      char *buffer)\n{\n\tstruct mspro_sys_attr *x_attr = container_of(attr,\n\t\t\t\t\t\t     struct mspro_sys_attr,\n\t\t\t\t\t\t     dev_attr);\n\tstruct mspro_specfile *x_spfile = x_attr->data;\n\tchar name[9], ext[4];\n\tssize_t rc = 0;\n\n\tmemcpy(name, x_spfile->name, 8);\n\tname[8] = 0;\n\tmemcpy(ext, x_spfile->ext, 3);\n\text[3] = 0;\n\n\trc += sysfs_emit_at(buffer, rc, \"name: %s\\n\", name);\n\trc += sysfs_emit_at(buffer, rc, \"ext: %s\\n\", ext);\n\trc += sysfs_emit_at(buffer, rc, \"attribute: %x\\n\", x_spfile->attr);\n\trc += sysfs_emit_at(buffer, rc, \"time: %d:%d:%d\\n\",\n\t\t\t    x_spfile->time >> 11,\n\t\t\t    (x_spfile->time >> 5) & 0x3f,\n\t\t\t    (x_spfile->time & 0x1f) * 2);\n\trc += sysfs_emit_at(buffer, rc, \"date: %d-%d-%d\\n\",\n\t\t\t    (x_spfile->date >> 9) + 1980,\n\t\t\t    (x_spfile->date >> 5) & 0xf,\n\t\t\t    x_spfile->date & 0x1f);\n\trc += sysfs_emit_at(buffer, rc, \"start cluster: %x\\n\", x_spfile->cluster);\n\trc += sysfs_emit_at(buffer, rc, \"size: %x\\n\", x_spfile->size);\n\treturn rc;\n}\n\nstatic ssize_t mspro_block_attr_show_devinfo(struct device *dev,\n\t\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t\t     char *buffer)\n{\n\tstruct mspro_sys_attr *x_attr = container_of(attr,\n\t\t\t\t\t\t     struct mspro_sys_attr,\n\t\t\t\t\t\t     dev_attr);\n\tstruct mspro_devinfo *x_devinfo = x_attr->data;\n\tssize_t rc = 0;\n\n\trc += sysfs_emit_at(buffer, rc, \"cylinders: %x\\n\", be16_to_cpu(x_devinfo->cylinders));\n\trc += sysfs_emit_at(buffer, rc, \"heads: %x\\n\", be16_to_cpu(x_devinfo->heads));\n\trc += sysfs_emit_at(buffer, rc, \"bytes per track: %x\\n\",\n\t\t\t    be16_to_cpu(x_devinfo->bytes_per_track));\n\trc += sysfs_emit_at(buffer, rc, \"bytes per sector: %x\\n\",\n\t\t\t    be16_to_cpu(x_devinfo->bytes_per_sector));\n\trc += sysfs_emit_at(buffer, rc, \"sectors per track: %x\\n\",\n\t\t\t    be16_to_cpu(x_devinfo->sectors_per_track));\n\treturn rc;\n}\n\nstatic sysfs_show_t mspro_block_attr_show(unsigned char tag)\n{\n\tswitch (tag) {\n\tcase MSPRO_BLOCK_ID_SYSINFO:\n\t\treturn mspro_block_attr_show_sysinfo;\n\tcase MSPRO_BLOCK_ID_MODELNAME:\n\t\treturn mspro_block_attr_show_modelname;\n\tcase MSPRO_BLOCK_ID_MBR:\n\t\treturn mspro_block_attr_show_mbr;\n\tcase MSPRO_BLOCK_ID_SPECFILEVALUES1:\n\tcase MSPRO_BLOCK_ID_SPECFILEVALUES2:\n\t\treturn mspro_block_attr_show_specfile;\n\tcase MSPRO_BLOCK_ID_DEVINFO:\n\t\treturn mspro_block_attr_show_devinfo;\n\tdefault:\n\t\treturn mspro_block_attr_show_default;\n\t}\n}\n\n \n\n \n\nstatic int h_mspro_block_req_init(struct memstick_dev *card,\n\t\t\t\t  struct memstick_request **mrq)\n{\n\tstruct mspro_block_data *msb = memstick_get_drvdata(card);\n\n\t*mrq = &card->current_mrq;\n\tcard->next_request = msb->mrq_handler;\n\treturn 0;\n}\n\nstatic int h_mspro_block_default(struct memstick_dev *card,\n\t\t\t\t struct memstick_request **mrq)\n{\n\treturn mspro_block_complete_req(card, (*mrq)->error);\n}\n\nstatic int h_mspro_block_default_bad(struct memstick_dev *card,\n\t\t\t\t     struct memstick_request **mrq)\n{\n\treturn -ENXIO;\n}\n\nstatic int h_mspro_block_get_ro(struct memstick_dev *card,\n\t\t\t\tstruct memstick_request **mrq)\n{\n\tstruct mspro_block_data *msb = memstick_get_drvdata(card);\n\n\tif (!(*mrq)->error) {\n\t\tif ((*mrq)->data[offsetof(struct ms_status_register, status0)]\n\t\t    & MEMSTICK_STATUS0_WP)\n\t\t\tmsb->read_only = 1;\n\t\telse\n\t\t\tmsb->read_only = 0;\n\t}\n\n\treturn mspro_block_complete_req(card, (*mrq)->error);\n}\n\nstatic int h_mspro_block_wait_for_ced(struct memstick_dev *card,\n\t\t\t\t      struct memstick_request **mrq)\n{\n\tdev_dbg(&card->dev, \"wait for ced: value %x\\n\", (*mrq)->data[0]);\n\n\tif (!(*mrq)->error) {\n\t\tif ((*mrq)->data[0] & (MEMSTICK_INT_CMDNAK | MEMSTICK_INT_ERR))\n\t\t\t(*mrq)->error = -EFAULT;\n\t\telse if (!((*mrq)->data[0] & MEMSTICK_INT_CED))\n\t\t\treturn 0;\n\t}\n\n\treturn mspro_block_complete_req(card, (*mrq)->error);\n}\n\nstatic int h_mspro_block_transfer_data(struct memstick_dev *card,\n\t\t\t\t       struct memstick_request **mrq)\n{\n\tstruct mspro_block_data *msb = memstick_get_drvdata(card);\n\tunsigned char t_val = 0;\n\tstruct scatterlist t_sg = { 0 };\n\tsize_t t_offset;\n\n\tif ((*mrq)->error)\n\t\treturn mspro_block_complete_req(card, (*mrq)->error);\n\n\tswitch ((*mrq)->tpc) {\n\tcase MS_TPC_WRITE_REG:\n\t\tmemstick_init_req(*mrq, MS_TPC_SET_CMD, &msb->transfer_cmd, 1);\n\t\t(*mrq)->need_card_int = 1;\n\t\treturn 0;\n\tcase MS_TPC_SET_CMD:\n\t\tt_val = (*mrq)->int_reg;\n\t\tmemstick_init_req(*mrq, MS_TPC_GET_INT, NULL, 1);\n\t\tif (msb->caps & MEMSTICK_CAP_AUTO_GET_INT)\n\t\t\tgoto has_int_reg;\n\t\treturn 0;\n\tcase MS_TPC_GET_INT:\n\t\tt_val = (*mrq)->data[0];\nhas_int_reg:\n\t\tif (t_val & (MEMSTICK_INT_CMDNAK | MEMSTICK_INT_ERR)) {\n\t\t\tt_val = MSPRO_CMD_STOP;\n\t\t\tmemstick_init_req(*mrq, MS_TPC_SET_CMD, &t_val, 1);\n\t\t\tcard->next_request = h_mspro_block_default;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (msb->current_page\n\t\t    == (msb->req_sg[msb->current_seg].length\n\t\t\t/ msb->page_size)) {\n\t\t\tmsb->current_page = 0;\n\t\t\tmsb->current_seg++;\n\n\t\t\tif (msb->current_seg == msb->seg_count) {\n\t\t\t\tif (t_val & MEMSTICK_INT_CED) {\n\t\t\t\t\treturn mspro_block_complete_req(card,\n\t\t\t\t\t\t\t\t\t0);\n\t\t\t\t} else {\n\t\t\t\t\tcard->next_request\n\t\t\t\t\t\t= h_mspro_block_wait_for_ced;\n\t\t\t\t\tmemstick_init_req(*mrq, MS_TPC_GET_INT,\n\t\t\t\t\t\t\t  NULL, 1);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!(t_val & MEMSTICK_INT_BREQ)) {\n\t\t\tmemstick_init_req(*mrq, MS_TPC_GET_INT, NULL, 1);\n\t\t\treturn 0;\n\t\t}\n\n\t\tt_offset = msb->req_sg[msb->current_seg].offset;\n\t\tt_offset += msb->current_page * msb->page_size;\n\n\t\tsg_set_page(&t_sg,\n\t\t\t    nth_page(sg_page(&(msb->req_sg[msb->current_seg])),\n\t\t\t\t     t_offset >> PAGE_SHIFT),\n\t\t\t    msb->page_size, offset_in_page(t_offset));\n\n\t\tmemstick_init_req_sg(*mrq, msb->data_dir == READ\n\t\t\t\t\t   ? MS_TPC_READ_LONG_DATA\n\t\t\t\t\t   : MS_TPC_WRITE_LONG_DATA,\n\t\t\t\t     &t_sg);\n\t\t(*mrq)->need_card_int = 1;\n\t\treturn 0;\n\tcase MS_TPC_READ_LONG_DATA:\n\tcase MS_TPC_WRITE_LONG_DATA:\n\t\tmsb->current_page++;\n\t\tif (msb->caps & MEMSTICK_CAP_AUTO_GET_INT) {\n\t\t\tt_val = (*mrq)->int_reg;\n\t\t\tgoto has_int_reg;\n\t\t} else {\n\t\t\tmemstick_init_req(*mrq, MS_TPC_GET_INT, NULL, 1);\n\t\t\treturn 0;\n\t\t}\n\n\tdefault:\n\t\tBUG();\n\t}\n}\n\n \n\n \nstatic void h_mspro_block_setup_cmd(struct memstick_dev *card, u64 offset,\n\t\t\t\t    size_t length)\n{\n\tstruct mspro_block_data *msb = memstick_get_drvdata(card);\n\tstruct mspro_param_register param = {\n\t\t.system = msb->system,\n\t\t.data_count = cpu_to_be16((uint16_t)(length / msb->page_size)),\n\t\t \n\t\t.data_address = 0,\n\t\t.tpc_param = 0\n\t};\n\n\tdo_div(offset, msb->page_size);\n\tparam.data_address = cpu_to_be32((uint32_t)offset);\n\n\tcard->next_request = h_mspro_block_req_init;\n\tmsb->mrq_handler = h_mspro_block_transfer_data;\n\tmemstick_init_req(&card->current_mrq, MS_TPC_WRITE_REG,\n\t\t\t  &param, sizeof(param));\n}\n\n \n\nstatic int mspro_block_issue_req(struct memstick_dev *card)\n{\n\tstruct mspro_block_data *msb = memstick_get_drvdata(card);\n\tu64 t_off;\n\tunsigned int count;\n\n\twhile (true) {\n\t\tmsb->current_page = 0;\n\t\tmsb->current_seg = 0;\n\t\tmsb->seg_count = blk_rq_map_sg(msb->block_req->q,\n\t\t\t\t\t       msb->block_req,\n\t\t\t\t\t       msb->req_sg);\n\n\t\tif (!msb->seg_count) {\n\t\t\tunsigned int bytes = blk_rq_cur_bytes(msb->block_req);\n\t\t\tbool chunk;\n\n\t\t\tchunk = blk_update_request(msb->block_req,\n\t\t\t\t\t\t\tBLK_STS_RESOURCE,\n\t\t\t\t\t\t\tbytes);\n\t\t\tif (chunk)\n\t\t\t\tcontinue;\n\t\t\t__blk_mq_end_request(msb->block_req,\n\t\t\t\t\t\tBLK_STS_RESOURCE);\n\t\t\tmsb->block_req = NULL;\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\tt_off = blk_rq_pos(msb->block_req);\n\t\tt_off <<= 9;\n\t\tcount = blk_rq_bytes(msb->block_req);\n\n\t\tmsb->setup_transfer(card, t_off, count);\n\n\t\tmsb->data_dir = rq_data_dir(msb->block_req);\n\t\tmsb->transfer_cmd = msb->data_dir == READ\n\t\t\t\t    ? MSPRO_CMD_READ_DATA\n\t\t\t\t    : MSPRO_CMD_WRITE_DATA;\n\n\t\tmemstick_new_req(card->host);\n\t\treturn 0;\n\t}\n}\n\nstatic int mspro_block_complete_req(struct memstick_dev *card, int error)\n{\n\tstruct mspro_block_data *msb = memstick_get_drvdata(card);\n\tint cnt;\n\tbool chunk;\n\tunsigned int t_len = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&msb->q_lock, flags);\n\tdev_dbg(&card->dev, \"complete %d, %d\\n\", msb->block_req ? 1 : 0,\n\t\terror);\n\n\tif (msb->block_req) {\n\t\t \n\t\tif (error == -EAGAIN)\n\t\t\terror = 0;\n\n\t\tif (error || (card->current_mrq.tpc == MSPRO_CMD_STOP)) {\n\t\t\tif (msb->data_dir == READ) {\n\t\t\t\tfor (cnt = 0; cnt < msb->current_seg; cnt++) {\n\t\t\t\t\tt_len += msb->req_sg[cnt].length\n\t\t\t\t\t\t / msb->page_size;\n\n\t\t\t\t\tif (msb->current_page)\n\t\t\t\t\t\tt_len += msb->current_page - 1;\n\n\t\t\t\t\tt_len *= msb->page_size;\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n\t\t\tt_len = blk_rq_bytes(msb->block_req);\n\n\t\tdev_dbg(&card->dev, \"transferred %x (%d)\\n\", t_len, error);\n\n\t\tif (error && !t_len)\n\t\t\tt_len = blk_rq_cur_bytes(msb->block_req);\n\n\t\tchunk = blk_update_request(msb->block_req,\n\t\t\t\terrno_to_blk_status(error), t_len);\n\t\tif (chunk) {\n\t\t\terror = mspro_block_issue_req(card);\n\t\t\tif (!error)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\t__blk_mq_end_request(msb->block_req,\n\t\t\t\t\t\terrno_to_blk_status(error));\n\t\t\tmsb->block_req = NULL;\n\t\t}\n\t} else {\n\t\tif (!error)\n\t\t\terror = -EAGAIN;\n\t}\n\n\tcard->next_request = h_mspro_block_default_bad;\n\tcomplete_all(&card->mrq_complete);\nout:\n\tspin_unlock_irqrestore(&msb->q_lock, flags);\n\treturn error;\n}\n\nstatic void mspro_block_stop(struct memstick_dev *card)\n{\n\tstruct mspro_block_data *msb = memstick_get_drvdata(card);\n\tint rc = 0;\n\tunsigned long flags;\n\n\twhile (1) {\n\t\tspin_lock_irqsave(&msb->q_lock, flags);\n\t\tif (!msb->block_req) {\n\t\t\tblk_mq_stop_hw_queues(msb->queue);\n\t\t\trc = 1;\n\t\t}\n\t\tspin_unlock_irqrestore(&msb->q_lock, flags);\n\n\t\tif (rc)\n\t\t\tbreak;\n\n\t\twait_for_completion(&card->mrq_complete);\n\t}\n}\n\nstatic void mspro_block_start(struct memstick_dev *card)\n{\n\tstruct mspro_block_data *msb = memstick_get_drvdata(card);\n\n\tblk_mq_start_hw_queues(msb->queue);\n}\n\nstatic blk_status_t mspro_queue_rq(struct blk_mq_hw_ctx *hctx,\n\t\t\t\t   const struct blk_mq_queue_data *bd)\n{\n\tstruct memstick_dev *card = hctx->queue->queuedata;\n\tstruct mspro_block_data *msb = memstick_get_drvdata(card);\n\n\tspin_lock_irq(&msb->q_lock);\n\n\tif (msb->block_req) {\n\t\tspin_unlock_irq(&msb->q_lock);\n\t\treturn BLK_STS_DEV_RESOURCE;\n\t}\n\n\tif (msb->eject) {\n\t\tspin_unlock_irq(&msb->q_lock);\n\t\tblk_mq_start_request(bd->rq);\n\t\treturn BLK_STS_IOERR;\n\t}\n\n\tmsb->block_req = bd->rq;\n\tblk_mq_start_request(bd->rq);\n\n\tif (mspro_block_issue_req(card))\n\t\tmsb->block_req = NULL;\n\n\tspin_unlock_irq(&msb->q_lock);\n\treturn BLK_STS_OK;\n}\n\n \n\nstatic int mspro_block_wait_for_ced(struct memstick_dev *card)\n{\n\tstruct mspro_block_data *msb = memstick_get_drvdata(card);\n\n\tcard->next_request = h_mspro_block_req_init;\n\tmsb->mrq_handler = h_mspro_block_wait_for_ced;\n\tmemstick_init_req(&card->current_mrq, MS_TPC_GET_INT, NULL, 1);\n\tmemstick_new_req(card->host);\n\twait_for_completion(&card->mrq_complete);\n\treturn card->current_mrq.error;\n}\n\nstatic int mspro_block_set_interface(struct memstick_dev *card,\n\t\t\t\t     unsigned char sys_reg)\n{\n\tstruct memstick_host *host = card->host;\n\tstruct mspro_block_data *msb = memstick_get_drvdata(card);\n\tstruct mspro_param_register param = {\n\t\t.system = sys_reg,\n\t\t.data_count = 0,\n\t\t.data_address = 0,\n\t\t.tpc_param = 0\n\t};\n\n\tcard->next_request = h_mspro_block_req_init;\n\tmsb->mrq_handler = h_mspro_block_default;\n\tmemstick_init_req(&card->current_mrq, MS_TPC_WRITE_REG, &param,\n\t\t\t  sizeof(param));\n\tmemstick_new_req(host);\n\twait_for_completion(&card->mrq_complete);\n\treturn card->current_mrq.error;\n}\n\nstatic int mspro_block_switch_interface(struct memstick_dev *card)\n{\n\tstruct memstick_host *host = card->host;\n\tstruct mspro_block_data *msb = memstick_get_drvdata(card);\n\tint rc = 0;\n\ntry_again:\n\tif (msb->caps & MEMSTICK_CAP_PAR4)\n\t\trc = mspro_block_set_interface(card, MEMSTICK_SYS_PAR4);\n\telse\n\t\treturn 0;\n\n\tif (rc) {\n\t\tprintk(KERN_WARNING\n\t\t       \"%s: could not switch to 4-bit mode, error %d\\n\",\n\t\t       dev_name(&card->dev), rc);\n\t\treturn 0;\n\t}\n\n\tmsb->system = MEMSTICK_SYS_PAR4;\n\thost->set_param(host, MEMSTICK_INTERFACE, MEMSTICK_PAR4);\n\tprintk(KERN_INFO \"%s: switching to 4-bit parallel mode\\n\",\n\t       dev_name(&card->dev));\n\n\tif (msb->caps & MEMSTICK_CAP_PAR8) {\n\t\trc = mspro_block_set_interface(card, MEMSTICK_SYS_PAR8);\n\n\t\tif (!rc) {\n\t\t\tmsb->system = MEMSTICK_SYS_PAR8;\n\t\t\thost->set_param(host, MEMSTICK_INTERFACE,\n\t\t\t\t\tMEMSTICK_PAR8);\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"%s: switching to 8-bit parallel mode\\n\",\n\t\t\t       dev_name(&card->dev));\n\t\t} else\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"%s: could not switch to 8-bit mode, error %d\\n\",\n\t\t\t       dev_name(&card->dev), rc);\n\t}\n\n\tcard->next_request = h_mspro_block_req_init;\n\tmsb->mrq_handler = h_mspro_block_default;\n\tmemstick_init_req(&card->current_mrq, MS_TPC_GET_INT, NULL, 1);\n\tmemstick_new_req(card->host);\n\twait_for_completion(&card->mrq_complete);\n\trc = card->current_mrq.error;\n\n\tif (rc) {\n\t\tprintk(KERN_WARNING\n\t\t       \"%s: interface error, trying to fall back to serial\\n\",\n\t\t       dev_name(&card->dev));\n\t\tmsb->system = MEMSTICK_SYS_SERIAL;\n\t\thost->set_param(host, MEMSTICK_POWER, MEMSTICK_POWER_OFF);\n\t\tmsleep(10);\n\t\thost->set_param(host, MEMSTICK_POWER, MEMSTICK_POWER_ON);\n\t\thost->set_param(host, MEMSTICK_INTERFACE, MEMSTICK_SERIAL);\n\n\t\trc = memstick_set_rw_addr(card);\n\t\tif (!rc)\n\t\t\trc = mspro_block_set_interface(card, msb->system);\n\n\t\tif (!rc) {\n\t\t\tmsleep(150);\n\t\t\trc = mspro_block_wait_for_ced(card);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tif (msb->caps & MEMSTICK_CAP_PAR8) {\n\t\t\t\tmsb->caps &= ~MEMSTICK_CAP_PAR8;\n\t\t\t\tgoto try_again;\n\t\t\t}\n\t\t}\n\t}\n\treturn rc;\n}\n\n \nstatic int mspro_block_read_attributes(struct memstick_dev *card)\n{\n\tstruct mspro_block_data *msb = memstick_get_drvdata(card);\n\tstruct mspro_attribute *attr = NULL;\n\tstruct mspro_sys_attr *s_attr = NULL;\n\tunsigned char *buffer = NULL;\n\tint cnt, rc, attr_count;\n\t \n\tunsigned int addr, attr_offset = 0, attr_len = msb->page_size;\n\n\tattr = kmalloc(msb->page_size, GFP_KERNEL);\n\tif (!attr)\n\t\treturn -ENOMEM;\n\n\tsg_init_one(&msb->req_sg[0], attr, msb->page_size);\n\tmsb->seg_count = 1;\n\tmsb->current_seg = 0;\n\tmsb->current_page = 0;\n\tmsb->data_dir = READ;\n\tmsb->transfer_cmd = MSPRO_CMD_READ_ATRB;\n\n\tmsb->setup_transfer(card, attr_offset, attr_len);\n\n\tmemstick_new_req(card->host);\n\twait_for_completion(&card->mrq_complete);\n\tif (card->current_mrq.error) {\n\t\trc = card->current_mrq.error;\n\t\tgoto out_free_attr;\n\t}\n\n\tif (be16_to_cpu(attr->signature) != MSPRO_BLOCK_SIGNATURE) {\n\t\tprintk(KERN_ERR \"%s: unrecognized device signature %x\\n\",\n\t\t       dev_name(&card->dev), be16_to_cpu(attr->signature));\n\t\trc = -ENODEV;\n\t\tgoto out_free_attr;\n\t}\n\n\tif (attr->count > MSPRO_BLOCK_MAX_ATTRIBUTES) {\n\t\tprintk(KERN_WARNING \"%s: way too many attribute entries\\n\",\n\t\t       dev_name(&card->dev));\n\t\tattr_count = MSPRO_BLOCK_MAX_ATTRIBUTES;\n\t} else\n\t\tattr_count = attr->count;\n\n\tmsb->attr_group.attrs = kcalloc(attr_count + 1,\n\t\t\t\t\tsizeof(*msb->attr_group.attrs),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!msb->attr_group.attrs) {\n\t\trc = -ENOMEM;\n\t\tgoto out_free_attr;\n\t}\n\tmsb->attr_group.name = \"media_attributes\";\n\n\tbuffer = kmemdup(attr, attr_len, GFP_KERNEL);\n\tif (!buffer) {\n\t\trc = -ENOMEM;\n\t\tgoto out_free_attr;\n\t}\n\n\tfor (cnt = 0; cnt < attr_count; ++cnt) {\n\t\ts_attr = kzalloc(sizeof(struct mspro_sys_attr), GFP_KERNEL);\n\t\tif (!s_attr) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out_free_buffer;\n\t\t}\n\n\t\tmsb->attr_group.attrs[cnt] = &s_attr->dev_attr.attr;\n\t\taddr = be32_to_cpu(attr->entries[cnt].address);\n\t\ts_attr->size = be32_to_cpu(attr->entries[cnt].size);\n\t\tdev_dbg(&card->dev, \"adding attribute %d: id %x, address %x, \"\n\t\t\t\"size %zx\\n\", cnt, attr->entries[cnt].id, addr,\n\t\t\ts_attr->size);\n\t\ts_attr->id = attr->entries[cnt].id;\n\t\tif (mspro_block_attr_name(s_attr->id))\n\t\t\tsnprintf(s_attr->name, sizeof(s_attr->name), \"%s\",\n\t\t\t\t mspro_block_attr_name(attr->entries[cnt].id));\n\t\telse\n\t\t\tsnprintf(s_attr->name, sizeof(s_attr->name),\n\t\t\t\t \"attr_x%02x\", attr->entries[cnt].id);\n\n\t\tsysfs_attr_init(&s_attr->dev_attr.attr);\n\t\ts_attr->dev_attr.attr.name = s_attr->name;\n\t\ts_attr->dev_attr.attr.mode = S_IRUGO;\n\t\ts_attr->dev_attr.show = mspro_block_attr_show(s_attr->id);\n\n\t\tif (!s_attr->size)\n\t\t\tcontinue;\n\n\t\ts_attr->data = kmalloc(s_attr->size, GFP_KERNEL);\n\t\tif (!s_attr->data) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out_free_buffer;\n\t\t}\n\n\t\tif (((addr / msb->page_size) == (attr_offset / msb->page_size))\n\t\t    && (((addr + s_attr->size - 1) / msb->page_size)\n\t\t\t== (attr_offset / msb->page_size))) {\n\t\t\tmemcpy(s_attr->data, buffer + addr % msb->page_size,\n\t\t\t       s_attr->size);\n\t\t\tcontinue;\n\t\t}\n\n\t\tattr_offset = (addr / msb->page_size) * msb->page_size;\n\n\t\tif ((attr_offset + attr_len) < (addr + s_attr->size)) {\n\t\t\tkfree(buffer);\n\t\t\tattr_len = (((addr + s_attr->size) / msb->page_size)\n\t\t\t\t    + 1 ) * msb->page_size - attr_offset;\n\t\t\tbuffer = kmalloc(attr_len, GFP_KERNEL);\n\t\t\tif (!buffer) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto out_free_attr;\n\t\t\t}\n\t\t}\n\n\t\tsg_init_one(&msb->req_sg[0], buffer, attr_len);\n\t\tmsb->seg_count = 1;\n\t\tmsb->current_seg = 0;\n\t\tmsb->current_page = 0;\n\t\tmsb->data_dir = READ;\n\t\tmsb->transfer_cmd = MSPRO_CMD_READ_ATRB;\n\n\t\tdev_dbg(&card->dev, \"reading attribute range %x, %x\\n\",\n\t\t\tattr_offset, attr_len);\n\n\t\tmsb->setup_transfer(card, attr_offset, attr_len);\n\t\tmemstick_new_req(card->host);\n\t\twait_for_completion(&card->mrq_complete);\n\t\tif (card->current_mrq.error) {\n\t\t\trc = card->current_mrq.error;\n\t\t\tgoto out_free_buffer;\n\t\t}\n\n\t\tmemcpy(s_attr->data, buffer + addr % msb->page_size,\n\t\t       s_attr->size);\n\t}\n\n\trc = 0;\nout_free_buffer:\n\tkfree(buffer);\nout_free_attr:\n\tkfree(attr);\n\treturn rc;\n}\n\nstatic int mspro_block_init_card(struct memstick_dev *card)\n{\n\tstruct mspro_block_data *msb = memstick_get_drvdata(card);\n\tstruct memstick_host *host = card->host;\n\tint rc = 0;\n\n\tmsb->system = MEMSTICK_SYS_SERIAL;\n\tmsb->setup_transfer = h_mspro_block_setup_cmd;\n\n\tcard->reg_addr.r_offset = offsetof(struct mspro_register, status);\n\tcard->reg_addr.r_length = sizeof(struct ms_status_register);\n\tcard->reg_addr.w_offset = offsetof(struct mspro_register, param);\n\tcard->reg_addr.w_length = sizeof(struct mspro_param_register);\n\n\tif (memstick_set_rw_addr(card))\n\t\treturn -EIO;\n\n\tmsb->caps = host->caps;\n\n\tmsleep(150);\n\trc = mspro_block_wait_for_ced(card);\n\tif (rc)\n\t\treturn rc;\n\n\trc = mspro_block_switch_interface(card);\n\tif (rc)\n\t\treturn rc;\n\n\tdev_dbg(&card->dev, \"card activated\\n\");\n\tif (msb->system != MEMSTICK_SYS_SERIAL)\n\t\tmsb->caps |= MEMSTICK_CAP_AUTO_GET_INT;\n\n\tcard->next_request = h_mspro_block_req_init;\n\tmsb->mrq_handler = h_mspro_block_get_ro;\n\tmemstick_init_req(&card->current_mrq, MS_TPC_READ_REG, NULL,\n\t\t\t  sizeof(struct ms_status_register));\n\tmemstick_new_req(card->host);\n\twait_for_completion(&card->mrq_complete);\n\tif (card->current_mrq.error)\n\t\treturn card->current_mrq.error;\n\n\tdev_dbg(&card->dev, \"card r/w status %d\\n\", msb->read_only ? 0 : 1);\n\n\tmsb->page_size = 512;\n\trc = mspro_block_read_attributes(card);\n\tif (rc)\n\t\treturn rc;\n\n\tdev_dbg(&card->dev, \"attributes loaded\\n\");\n\treturn 0;\n\n}\n\nstatic const struct blk_mq_ops mspro_mq_ops = {\n\t.queue_rq\t= mspro_queue_rq,\n};\n\nstatic int mspro_block_init_disk(struct memstick_dev *card)\n{\n\tstruct mspro_block_data *msb = memstick_get_drvdata(card);\n\tstruct mspro_devinfo *dev_info = NULL;\n\tstruct mspro_sys_info *sys_info = NULL;\n\tstruct mspro_sys_attr *s_attr = NULL;\n\tint rc, disk_id;\n\tunsigned long capacity;\n\n\tfor (rc = 0; msb->attr_group.attrs[rc]; ++rc) {\n\t\ts_attr = mspro_from_sysfs_attr(msb->attr_group.attrs[rc]);\n\n\t\tif (s_attr->id == MSPRO_BLOCK_ID_DEVINFO)\n\t\t\tdev_info = s_attr->data;\n\t\telse if (s_attr->id == MSPRO_BLOCK_ID_SYSINFO)\n\t\t\tsys_info = s_attr->data;\n\t}\n\n\tif (!dev_info || !sys_info)\n\t\treturn -ENODEV;\n\n\tmsb->cylinders = be16_to_cpu(dev_info->cylinders);\n\tmsb->heads = be16_to_cpu(dev_info->heads);\n\tmsb->sectors_per_track = be16_to_cpu(dev_info->sectors_per_track);\n\n\tmsb->page_size = be16_to_cpu(sys_info->unit_size);\n\n\tmutex_lock(&mspro_block_disk_lock);\n\tdisk_id = idr_alloc(&mspro_block_disk_idr, card, 0, 256, GFP_KERNEL);\n\tmutex_unlock(&mspro_block_disk_lock);\n\tif (disk_id < 0)\n\t\treturn disk_id;\n\n\trc = blk_mq_alloc_sq_tag_set(&msb->tag_set, &mspro_mq_ops, 2,\n\t\t\t\t     BLK_MQ_F_SHOULD_MERGE);\n\tif (rc)\n\t\tgoto out_release_id;\n\n\tmsb->disk = blk_mq_alloc_disk(&msb->tag_set, card);\n\tif (IS_ERR(msb->disk)) {\n\t\trc = PTR_ERR(msb->disk);\n\t\tgoto out_free_tag_set;\n\t}\n\tmsb->queue = msb->disk->queue;\n\n\tblk_queue_max_hw_sectors(msb->queue, MSPRO_BLOCK_MAX_PAGES);\n\tblk_queue_max_segments(msb->queue, MSPRO_BLOCK_MAX_SEGS);\n\tblk_queue_max_segment_size(msb->queue,\n\t\t\t\t   MSPRO_BLOCK_MAX_PAGES * msb->page_size);\n\n\tmsb->disk->major = major;\n\tmsb->disk->first_minor = disk_id << MSPRO_BLOCK_PART_SHIFT;\n\tmsb->disk->minors = 1 << MSPRO_BLOCK_PART_SHIFT;\n\tmsb->disk->fops = &ms_block_bdops;\n\tmsb->disk->private_data = msb;\n\n\tsprintf(msb->disk->disk_name, \"mspblk%d\", disk_id);\n\n\tblk_queue_logical_block_size(msb->queue, msb->page_size);\n\n\tcapacity = be16_to_cpu(sys_info->user_block_count);\n\tcapacity *= be16_to_cpu(sys_info->block_size);\n\tcapacity *= msb->page_size >> 9;\n\tset_capacity(msb->disk, capacity);\n\tdev_dbg(&card->dev, \"capacity set %ld\\n\", capacity);\n\n\tif (msb->read_only)\n\t\tset_disk_ro(msb->disk, true);\n\n\trc = device_add_disk(&card->dev, msb->disk, NULL);\n\tif (rc)\n\t\tgoto out_cleanup_disk;\n\tmsb->active = 1;\n\treturn 0;\n\nout_cleanup_disk:\n\tput_disk(msb->disk);\nout_free_tag_set:\n\tblk_mq_free_tag_set(&msb->tag_set);\nout_release_id:\n\tmutex_lock(&mspro_block_disk_lock);\n\tidr_remove(&mspro_block_disk_idr, disk_id);\n\tmutex_unlock(&mspro_block_disk_lock);\n\treturn rc;\n}\n\nstatic void mspro_block_data_clear(struct mspro_block_data *msb)\n{\n\tint cnt;\n\tstruct mspro_sys_attr *s_attr;\n\n\tif (msb->attr_group.attrs) {\n\t\tfor (cnt = 0; msb->attr_group.attrs[cnt]; ++cnt) {\n\t\t\ts_attr = mspro_from_sysfs_attr(msb->attr_group\n\t\t\t\t\t\t\t   .attrs[cnt]);\n\t\t\tkfree(s_attr->data);\n\t\t\tkfree(s_attr);\n\t\t}\n\t\tkfree(msb->attr_group.attrs);\n\t}\n\n\tmsb->card = NULL;\n}\n\nstatic int mspro_block_check_card(struct memstick_dev *card)\n{\n\tstruct mspro_block_data *msb = memstick_get_drvdata(card);\n\n\treturn (msb->active == 1);\n}\n\nstatic int mspro_block_probe(struct memstick_dev *card)\n{\n\tstruct mspro_block_data *msb;\n\tint rc = 0;\n\n\tmsb = kzalloc(sizeof(struct mspro_block_data), GFP_KERNEL);\n\tif (!msb)\n\t\treturn -ENOMEM;\n\tmemstick_set_drvdata(card, msb);\n\tmsb->card = card;\n\tspin_lock_init(&msb->q_lock);\n\n\trc = mspro_block_init_card(card);\n\n\tif (rc)\n\t\tgoto out_free;\n\n\trc = sysfs_create_group(&card->dev.kobj, &msb->attr_group);\n\tif (rc)\n\t\tgoto out_free;\n\n\trc = mspro_block_init_disk(card);\n\tif (!rc) {\n\t\tcard->check = mspro_block_check_card;\n\t\tcard->stop = mspro_block_stop;\n\t\tcard->start = mspro_block_start;\n\t\treturn 0;\n\t}\n\n\tsysfs_remove_group(&card->dev.kobj, &msb->attr_group);\nout_free:\n\tmemstick_set_drvdata(card, NULL);\n\tmspro_block_data_clear(msb);\n\tkfree(msb);\n\treturn rc;\n}\n\nstatic void mspro_block_remove(struct memstick_dev *card)\n{\n\tstruct mspro_block_data *msb = memstick_get_drvdata(card);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&msb->q_lock, flags);\n\tmsb->eject = 1;\n\tspin_unlock_irqrestore(&msb->q_lock, flags);\n\tblk_mq_start_hw_queues(msb->queue);\n\n\tdel_gendisk(msb->disk);\n\tdev_dbg(&card->dev, \"mspro block remove\\n\");\n\n\tblk_mq_free_tag_set(&msb->tag_set);\n\tmsb->queue = NULL;\n\n\tsysfs_remove_group(&card->dev.kobj, &msb->attr_group);\n\n\tmutex_lock(&mspro_block_disk_lock);\n\tmspro_block_data_clear(msb);\n\tmutex_unlock(&mspro_block_disk_lock);\n\n\tput_disk(msb->disk);\n\tmemstick_set_drvdata(card, NULL);\n}\n\n#ifdef CONFIG_PM\n\nstatic int mspro_block_suspend(struct memstick_dev *card, pm_message_t state)\n{\n\tstruct mspro_block_data *msb = memstick_get_drvdata(card);\n\tunsigned long flags;\n\n\tblk_mq_stop_hw_queues(msb->queue);\n\n\tspin_lock_irqsave(&msb->q_lock, flags);\n\tmsb->active = 0;\n\tspin_unlock_irqrestore(&msb->q_lock, flags);\n\n\treturn 0;\n}\n\nstatic int mspro_block_resume(struct memstick_dev *card)\n{\n\tstruct mspro_block_data *msb = memstick_get_drvdata(card);\n\tint rc = 0;\n\n#ifdef CONFIG_MEMSTICK_UNSAFE_RESUME\n\n\tstruct mspro_block_data *new_msb;\n\tstruct memstick_host *host = card->host;\n\tstruct mspro_sys_attr *s_attr, *r_attr;\n\tunsigned char cnt;\n\n\tmutex_lock(&host->lock);\n\tnew_msb = kzalloc(sizeof(struct mspro_block_data), GFP_KERNEL);\n\tif (!new_msb) {\n\t\trc = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\tnew_msb->card = card;\n\tmemstick_set_drvdata(card, new_msb);\n\trc = mspro_block_init_card(card);\n\tif (rc)\n\t\tgoto out_free;\n\n\tfor (cnt = 0; new_msb->attr_group.attrs[cnt]\n\t\t      && msb->attr_group.attrs[cnt]; ++cnt) {\n\t\ts_attr = mspro_from_sysfs_attr(new_msb->attr_group.attrs[cnt]);\n\t\tr_attr = mspro_from_sysfs_attr(msb->attr_group.attrs[cnt]);\n\n\t\tif (s_attr->id == MSPRO_BLOCK_ID_SYSINFO\n\t\t    && r_attr->id == s_attr->id) {\n\t\t\tif (memcmp(s_attr->data, r_attr->data, s_attr->size))\n\t\t\t\tbreak;\n\n\t\t\tmsb->active = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\nout_free:\n\tmemstick_set_drvdata(card, msb);\n\tmspro_block_data_clear(new_msb);\n\tkfree(new_msb);\nout_unlock:\n\tmutex_unlock(&host->lock);\n\n#endif  \n\n\tblk_mq_start_hw_queues(msb->queue);\n\treturn rc;\n}\n\n#else\n\n#define mspro_block_suspend NULL\n#define mspro_block_resume NULL\n\n#endif  \n\nstatic struct memstick_device_id mspro_block_id_tbl[] = {\n\t{MEMSTICK_MATCH_ALL, MEMSTICK_TYPE_PRO, MEMSTICK_CATEGORY_STORAGE_DUO,\n\t MEMSTICK_CLASS_DUO},\n\t{}\n};\n\n\nstatic struct memstick_driver mspro_block_driver = {\n\t.driver = {\n\t\t.name  = DRIVER_NAME,\n\t\t.owner = THIS_MODULE\n\t},\n\t.id_table = mspro_block_id_tbl,\n\t.probe    = mspro_block_probe,\n\t.remove   = mspro_block_remove,\n\t.suspend  = mspro_block_suspend,\n\t.resume   = mspro_block_resume\n};\n\nstatic int __init mspro_block_init(void)\n{\n\tint rc = -ENOMEM;\n\n\trc = register_blkdev(major, DRIVER_NAME);\n\tif (rc < 0) {\n\t\tprintk(KERN_ERR DRIVER_NAME \": failed to register \"\n\t\t       \"major %d, error %d\\n\", major, rc);\n\t\treturn rc;\n\t}\n\tif (!major)\n\t\tmajor = rc;\n\n\trc = memstick_register_driver(&mspro_block_driver);\n\tif (rc)\n\t\tunregister_blkdev(major, DRIVER_NAME);\n\treturn rc;\n}\n\nstatic void __exit mspro_block_exit(void)\n{\n\tmemstick_unregister_driver(&mspro_block_driver);\n\tunregister_blkdev(major, DRIVER_NAME);\n\tidr_destroy(&mspro_block_disk_idr);\n}\n\nmodule_init(mspro_block_init);\nmodule_exit(mspro_block_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Alex Dubov\");\nMODULE_DESCRIPTION(\"Sony MemoryStickPro block device driver\");\nMODULE_DEVICE_TABLE(memstick, mspro_block_id_tbl);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}