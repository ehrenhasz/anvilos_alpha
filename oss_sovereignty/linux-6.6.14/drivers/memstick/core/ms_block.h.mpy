{
  "module_name": "ms_block.h",
  "hash_id": "f73f802229bd1db11d58909316c9d4172443566455d8c953687d487aceedde1d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/memstick/core/ms_block.h",
  "human_readable_source": " \n \n\n#ifndef MS_BLOCK_NEW_H\n#define MS_BLOCK_NEW_H\n\n#define MS_BLOCK_MAX_SEGS      32\n#define MS_BLOCK_MAX_PAGES     ((2 << 16) - 1)\n\n#define MS_BLOCK_MAX_BOOT_ADDR 0x000c\n#define MS_BLOCK_BOOT_ID       0x0001\n#define MS_BLOCK_INVALID       0xffff\n#define MS_MAX_ZONES           16\n#define MS_BLOCKS_IN_ZONE      512\n\n#define MS_BLOCK_MAP_LINE_SZ   16\n#define MS_BLOCK_PART_SHIFT    3\n\n\n#define MEMSTICK_UNCORR_ERROR (MEMSTICK_STATUS1_UCFG | \\\n\t\tMEMSTICK_STATUS1_UCEX | MEMSTICK_STATUS1_UCDT)\n\n#define MEMSTICK_CORR_ERROR (MEMSTICK_STATUS1_FGER | MEMSTICK_STATUS1_EXER | \\\n\tMEMSTICK_STATUS1_DTER)\n\n#define MEMSTICK_INT_ERROR (MEMSTICK_INT_CMDNAK | MEMSTICK_INT_ERR)\n\n#define MEMSTICK_OVERWRITE_FLAG_NORMAL \\\n\t(MEMSTICK_OVERWRITE_PGST1 | \\\n\tMEMSTICK_OVERWRITE_PGST0  | \\\n\tMEMSTICK_OVERWRITE_BKST)\n\n#define MEMSTICK_OV_PG_NORMAL \\\n\t(MEMSTICK_OVERWRITE_PGST1 | MEMSTICK_OVERWRITE_PGST0)\n\n#define MEMSTICK_MANAGEMENT_FLAG_NORMAL \\\n\t(MEMSTICK_MANAGEMENT_SYSFLG |  \\\n\tMEMSTICK_MANAGEMENT_SCMS1   |  \\\n\tMEMSTICK_MANAGEMENT_SCMS0)     \\\n\nstruct ms_boot_header {\n\tunsigned short block_id;\n\tunsigned short format_reserved;\n\tunsigned char  reserved0[184];\n\tunsigned char  data_entry;\n\tunsigned char  reserved1[179];\n} __packed;\n\n\nstruct ms_system_item {\n\tunsigned int  start_addr;\n\tunsigned int  data_size;\n\tunsigned char data_type_id;\n\tunsigned char reserved[3];\n} __packed;\n\nstruct ms_system_entry {\n\tstruct ms_system_item disabled_block;\n\tstruct ms_system_item cis_idi;\n\tunsigned char         reserved[24];\n} __packed;\n\nstruct ms_boot_attr_info {\n\tunsigned char      memorystick_class;\n\tunsigned char      format_unique_value1;\n\tunsigned short     block_size;\n\tunsigned short     number_of_blocks;\n\tunsigned short     number_of_effective_blocks;\n\tunsigned short     page_size;\n\tunsigned char      extra_data_size;\n\tunsigned char      format_unique_value2;\n\tunsigned char      assembly_time[8];\n\tunsigned char      format_unique_value3;\n\tunsigned char      serial_number[3];\n\tunsigned char      assembly_manufacturer_code;\n\tunsigned char      assembly_model_code[3];\n\tunsigned short     memory_manufacturer_code;\n\tunsigned short     memory_device_code;\n\tunsigned short     implemented_capacity;\n\tunsigned char      format_unique_value4[2];\n\tunsigned char      vcc;\n\tunsigned char      vpp;\n\tunsigned short     controller_number;\n\tunsigned short     controller_function;\n\tunsigned char      reserved0[9];\n\tunsigned char      transfer_supporting;\n\tunsigned short     format_unique_value5;\n\tunsigned char      format_type;\n\tunsigned char      memorystick_application;\n\tunsigned char      device_type;\n\tunsigned char      reserved1[22];\n\tunsigned char      format_uniqure_value6[2];\n\tunsigned char      reserved2[15];\n} __packed;\n\nstruct ms_cis_idi {\n\tunsigned short general_config;\n\tunsigned short logical_cylinders;\n\tunsigned short reserved0;\n\tunsigned short logical_heads;\n\tunsigned short track_size;\n\tunsigned short page_size;\n\tunsigned short pages_per_track;\n\tunsigned short msw;\n\tunsigned short lsw;\n\tunsigned short reserved1;\n\tunsigned char  serial_number[20];\n\tunsigned short buffer_type;\n\tunsigned short buffer_size_increments;\n\tunsigned short long_command_ecc;\n\tunsigned char  firmware_version[28];\n\tunsigned char  model_name[18];\n\tunsigned short reserved2[5];\n\tunsigned short pio_mode_number;\n\tunsigned short dma_mode_number;\n\tunsigned short field_validity;\n\tunsigned short current_logical_cylinders;\n\tunsigned short current_logical_heads;\n\tunsigned short current_pages_per_track;\n\tunsigned int   current_page_capacity;\n\tunsigned short mutiple_page_setting;\n\tunsigned int   addressable_pages;\n\tunsigned short single_word_dma;\n\tunsigned short multi_word_dma;\n\tunsigned char  reserved3[128];\n} __packed;\n\n\nstruct ms_boot_page {\n\tstruct ms_boot_header    header;\n\tstruct ms_system_entry   entry;\n\tstruct ms_boot_attr_info attr;\n} __packed;\n\nstruct msb_data {\n\tstruct memstick_dev\t\t*card;\n\tstruct gendisk\t\t\t*disk;\n\tstruct request_queue\t\t*queue;\n\tspinlock_t\t\t\tq_lock;\n\tstruct blk_mq_tag_set\t\ttag_set;\n\tstruct hd_geometry\t\tgeometry;\n\tstruct attribute_group\t\tattr_group;\n\tstruct request\t\t\t*req;\n\tint\t\t\t\tcaps;\n\tint\t\t\t\tdisk_id;\n\n\t \n\tstruct workqueue_struct\t\t*io_queue;\n\tbool\t\t\t\tio_queue_stopped;\n\tstruct work_struct\t\tio_work;\n\tbool\t\t\t\tcard_dead;\n\n\t \n\tstruct ms_boot_page\t\t*boot_page;\n\tu16\t\t\t\tboot_block_locations[2];\n\tint\t\t\t\tboot_block_count;\n\n\tbool\t\t\t\tread_only;\n\tunsigned short\t\t\tpage_size;\n\tint\t\t\t\tblock_size;\n\tint\t\t\t\tpages_in_block;\n\tint\t\t\t\tzone_count;\n\tint\t\t\t\tblock_count;\n\tint\t\t\t\tlogical_block_count;\n\n\t \n\tunsigned long\t\t\t*used_blocks_bitmap;\n\tunsigned long\t\t\t*erased_blocks_bitmap;\n\tu16\t\t\t\t*lba_to_pba_table;\n\tint\t\t\t\tfree_block_count[MS_MAX_ZONES];\n\tbool\t\t\t\tftl_initialized;\n\n\t \n\tunsigned char\t\t\t*cache;\n\tunsigned long\t\t\tvalid_cache_bitmap;\n\tint\t\t\t\tcache_block_lba;\n\tbool\t\t\t\tneed_flush_cache;\n\tstruct timer_list\t\tcache_flush_timer;\n\n\t \n\tunsigned char\t\t\t*block_buffer;\n\tstruct scatterlist\t\tprealloc_sg[MS_BLOCK_MAX_SEGS+1];\n\n\n\t \n\tstruct ms_register_addr\t\treg_addr;\n\tbool\t\t\t\taddr_valid;\n\n\tu8\t\t\t\tcommand_value;\n\tbool\t\t\t\tcommand_need_oob;\n\tstruct scatterlist\t\t*current_sg;\n\tint\t\t\t\tcurrent_sg_offset;\n\n\tstruct ms_register\t\tregs;\n\tint\t\t\t\tcurrent_page;\n\n\tint\t\t\t\tstate;\n\tint\t\t\t\texit_error;\n\tbool\t\t\t\tint_polling;\n\tunsigned long\t\t\tint_timeout;\n\n};\n\nenum msb_readpage_states {\n\tMSB_RP_SEND_BLOCK_ADDRESS = 0,\n\tMSB_RP_SEND_READ_COMMAND,\n\n\tMSB_RP_SEND_INT_REQ,\n\tMSB_RP_RECEIVE_INT_REQ_RESULT,\n\n\tMSB_RP_SEND_READ_STATUS_REG,\n\tMSB_RP_RECEIVE_STATUS_REG,\n\n\tMSB_RP_SEND_OOB_READ,\n\tMSB_RP_RECEIVE_OOB_READ,\n\n\tMSB_RP_SEND_READ_DATA,\n\tMSB_RP_RECEIVE_READ_DATA,\n};\n\nenum msb_write_block_states {\n\tMSB_WB_SEND_WRITE_PARAMS = 0,\n\tMSB_WB_SEND_WRITE_OOB,\n\tMSB_WB_SEND_WRITE_COMMAND,\n\n\tMSB_WB_SEND_INT_REQ,\n\tMSB_WB_RECEIVE_INT_REQ,\n\n\tMSB_WB_SEND_WRITE_DATA,\n\tMSB_WB_RECEIVE_WRITE_CONFIRMATION,\n};\n\nenum msb_send_command_states {\n\tMSB_SC_SEND_WRITE_PARAMS,\n\tMSB_SC_SEND_WRITE_OOB,\n\tMSB_SC_SEND_COMMAND,\n\n\tMSB_SC_SEND_INT_REQ,\n\tMSB_SC_RECEIVE_INT_REQ,\n\n};\n\nenum msb_reset_states {\n\tMSB_RS_SEND,\n\tMSB_RS_CONFIRM,\n};\n\nenum msb_par_switch_states {\n\tMSB_PS_SEND_SWITCH_COMMAND,\n\tMSB_PS_SWICH_HOST,\n\tMSB_PS_CONFIRM,\n};\n\nstruct chs_entry {\n\tunsigned long size;\n\tunsigned char sec;\n\tunsigned short cyl;\n\tunsigned char head;\n};\n\nstatic int msb_reset(struct msb_data *msb, bool full);\n\nstatic int h_msb_default_bad(struct memstick_dev *card,\n\t\t\t\t\t\tstruct memstick_request **mrq);\n\n#define __dbg(level, format, ...) \\\n\tdo { \\\n\t\tif (debug >= level) \\\n\t\t\tpr_err(format \"\\n\", ## __VA_ARGS__); \\\n\t} while (0)\n\n\n#define dbg(format, ...)\t\t__dbg(1, format, ## __VA_ARGS__)\n#define dbg_verbose(format, ...)\t__dbg(2, format, ## __VA_ARGS__)\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}