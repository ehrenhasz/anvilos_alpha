{
  "module_name": "ms_block.c",
  "hash_id": "e36403372f5f5d6ed9faab83c514680d5ad3020782cdb025ad47c20489ee2742",
  "original_prompt": "Ingested from linux-6.6.14/drivers/memstick/core/ms_block.c",
  "human_readable_source": "\n \n#define DRIVER_NAME \"ms_block\"\n#define pr_fmt(fmt) DRIVER_NAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/blk-mq.h>\n#include <linux/memstick.h>\n#include <linux/idr.h>\n#include <linux/hdreg.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/bitmap.h>\n#include <linux/scatterlist.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include \"ms_block.h\"\n\nstatic int debug;\nstatic int cache_flush_timeout = 1000;\nstatic bool verify_writes;\n\n \nstatic size_t msb_sg_copy(struct scatterlist *sg_from,\n\tstruct scatterlist *sg_to, int to_nents, size_t offset, size_t len)\n{\n\tsize_t copied = 0;\n\n\twhile (offset > 0) {\n\t\tif (offset >= sg_from->length) {\n\t\t\tif (sg_is_last(sg_from))\n\t\t\t\treturn 0;\n\n\t\t\toffset -= sg_from->length;\n\t\t\tsg_from = sg_next(sg_from);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcopied = min(len, sg_from->length - offset);\n\t\tsg_set_page(sg_to, sg_page(sg_from),\n\t\t\tcopied, sg_from->offset + offset);\n\n\t\tlen -= copied;\n\t\toffset = 0;\n\n\t\tif (sg_is_last(sg_from) || !len)\n\t\t\tgoto out;\n\n\t\tsg_to = sg_next(sg_to);\n\t\tto_nents--;\n\t\tsg_from = sg_next(sg_from);\n\t}\n\n\twhile (len > sg_from->length && to_nents--) {\n\t\tlen -= sg_from->length;\n\t\tcopied += sg_from->length;\n\n\t\tsg_set_page(sg_to, sg_page(sg_from),\n\t\t\t\tsg_from->length, sg_from->offset);\n\n\t\tif (sg_is_last(sg_from) || !len)\n\t\t\tgoto out;\n\n\t\tsg_from = sg_next(sg_from);\n\t\tsg_to = sg_next(sg_to);\n\t}\n\n\tif (len && to_nents) {\n\t\tsg_set_page(sg_to, sg_page(sg_from), len, sg_from->offset);\n\t\tcopied += len;\n\t}\nout:\n\tsg_mark_end(sg_to);\n\treturn copied;\n}\n\n \nstatic int msb_sg_compare_to_buffer(struct scatterlist *sg,\n\t\t\t\t\tsize_t offset, u8 *buffer, size_t len)\n{\n\tint retval = 0, cmplen;\n\tstruct sg_mapping_iter miter;\n\n\tsg_miter_start(&miter, sg, sg_nents(sg),\n\t\t\t\t\tSG_MITER_ATOMIC | SG_MITER_FROM_SG);\n\n\twhile (sg_miter_next(&miter) && len > 0) {\n\t\tif (offset >= miter.length) {\n\t\t\toffset -= miter.length;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcmplen = min(miter.length - offset, len);\n\t\tretval = memcmp(miter.addr + offset, buffer, cmplen) ? -1 : 0;\n\t\tif (retval)\n\t\t\tbreak;\n\n\t\tbuffer += cmplen;\n\t\tlen -= cmplen;\n\t\toffset = 0;\n\t}\n\n\tif (!retval && len)\n\t\tretval = -1;\n\n\tsg_miter_stop(&miter);\n\treturn retval;\n}\n\n\n \nstatic int msb_get_zone_from_lba(int lba)\n{\n\tif (lba < 494)\n\t\treturn 0;\n\treturn ((lba - 494) / 496) + 1;\n}\n\n \nstatic int msb_get_zone_from_pba(int pba)\n{\n\treturn pba / MS_BLOCKS_IN_ZONE;\n}\n\n \nstatic int msb_validate_used_block_bitmap(struct msb_data *msb)\n{\n\tint total_free_blocks = 0;\n\tint i;\n\n\tif (!debug)\n\t\treturn 0;\n\n\tfor (i = 0; i < msb->zone_count; i++)\n\t\ttotal_free_blocks += msb->free_block_count[i];\n\n\tif (msb->block_count - bitmap_weight(msb->used_blocks_bitmap,\n\t\t\t\t\tmsb->block_count) == total_free_blocks)\n\t\treturn 0;\n\n\tpr_err(\"BUG: free block counts don't match the bitmap\");\n\tmsb->read_only = true;\n\treturn -EINVAL;\n}\n\n \nstatic void msb_mark_block_used(struct msb_data *msb, int pba)\n{\n\tint zone = msb_get_zone_from_pba(pba);\n\n\tif (test_bit(pba, msb->used_blocks_bitmap)) {\n\t\tpr_err(\n\t\t\"BUG: attempt to mark already used pba %d as used\", pba);\n\t\tmsb->read_only = true;\n\t\treturn;\n\t}\n\n\tif (msb_validate_used_block_bitmap(msb))\n\t\treturn;\n\n\t \n\t__set_bit(pba, msb->used_blocks_bitmap);\n\tmsb->free_block_count[zone]--;\n}\n\n \nstatic void msb_mark_block_unused(struct msb_data *msb, int pba)\n{\n\tint zone = msb_get_zone_from_pba(pba);\n\n\tif (!test_bit(pba, msb->used_blocks_bitmap)) {\n\t\tpr_err(\"BUG: attempt to mark already unused pba %d as unused\" , pba);\n\t\tmsb->read_only = true;\n\t\treturn;\n\t}\n\n\tif (msb_validate_used_block_bitmap(msb))\n\t\treturn;\n\n\t \n\t__clear_bit(pba, msb->used_blocks_bitmap);\n\tmsb->free_block_count[zone]++;\n}\n\n \nstatic void msb_invalidate_reg_window(struct msb_data *msb)\n{\n\tmsb->reg_addr.w_offset = offsetof(struct ms_register, id);\n\tmsb->reg_addr.w_length = sizeof(struct ms_id_register);\n\tmsb->reg_addr.r_offset = offsetof(struct ms_register, id);\n\tmsb->reg_addr.r_length = sizeof(struct ms_id_register);\n\tmsb->addr_valid = false;\n}\n\n \nstatic int msb_run_state_machine(struct msb_data *msb, int   (*state_func)\n\t\t(struct memstick_dev *card, struct memstick_request **req))\n{\n\tstruct memstick_dev *card = msb->card;\n\n\tWARN_ON(msb->state != -1);\n\tmsb->int_polling = false;\n\tmsb->state = 0;\n\tmsb->exit_error = 0;\n\n\tmemset(&card->current_mrq, 0, sizeof(card->current_mrq));\n\n\tcard->next_request = state_func;\n\tmemstick_new_req(card->host);\n\twait_for_completion(&card->mrq_complete);\n\n\tWARN_ON(msb->state != -1);\n\treturn msb->exit_error;\n}\n\n \nstatic int msb_exit_state_machine(struct msb_data *msb, int error)\n{\n\tWARN_ON(msb->state == -1);\n\n\tmsb->state = -1;\n\tmsb->exit_error = error;\n\tmsb->card->next_request = h_msb_default_bad;\n\n\t \n\tif (error)\n\t\tmsb_invalidate_reg_window(msb);\n\n\tcomplete(&msb->card->mrq_complete);\n\treturn -ENXIO;\n}\n\n \nstatic int msb_read_int_reg(struct msb_data *msb, long timeout)\n{\n\tstruct memstick_request *mrq = &msb->card->current_mrq;\n\n\tWARN_ON(msb->state == -1);\n\n\tif (!msb->int_polling) {\n\t\tmsb->int_timeout = jiffies +\n\t\t\tmsecs_to_jiffies(timeout == -1 ? 500 : timeout);\n\t\tmsb->int_polling = true;\n\t} else if (time_after(jiffies, msb->int_timeout)) {\n\t\tmrq->data[0] = MEMSTICK_INT_CMDNAK;\n\t\treturn 0;\n\t}\n\n\tif ((msb->caps & MEMSTICK_CAP_AUTO_GET_INT) &&\n\t\t\t\tmrq->need_card_int && !mrq->error) {\n\t\tmrq->data[0] = mrq->int_reg;\n\t\tmrq->need_card_int = false;\n\t\treturn 0;\n\t} else {\n\t\tmemstick_init_req(mrq, MS_TPC_GET_INT, NULL, 1);\n\t\treturn 1;\n\t}\n}\n\n \nstatic int msb_read_regs(struct msb_data *msb, int offset, int len)\n{\n\tstruct memstick_request *req = &msb->card->current_mrq;\n\n\tif (msb->reg_addr.r_offset != offset ||\n\t    msb->reg_addr.r_length != len || !msb->addr_valid) {\n\n\t\tmsb->reg_addr.r_offset = offset;\n\t\tmsb->reg_addr.r_length = len;\n\t\tmsb->addr_valid = true;\n\n\t\tmemstick_init_req(req, MS_TPC_SET_RW_REG_ADRS,\n\t\t\t&msb->reg_addr, sizeof(msb->reg_addr));\n\t\treturn 0;\n\t}\n\n\tmemstick_init_req(req, MS_TPC_READ_REG, NULL, len);\n\treturn 1;\n}\n\n \nstatic int msb_write_regs(struct msb_data *msb, int offset, int len, void *buf)\n{\n\tstruct memstick_request *req = &msb->card->current_mrq;\n\n\tif (msb->reg_addr.w_offset != offset ||\n\t\tmsb->reg_addr.w_length != len  || !msb->addr_valid) {\n\n\t\tmsb->reg_addr.w_offset = offset;\n\t\tmsb->reg_addr.w_length = len;\n\t\tmsb->addr_valid = true;\n\n\t\tmemstick_init_req(req, MS_TPC_SET_RW_REG_ADRS,\n\t\t\t&msb->reg_addr, sizeof(msb->reg_addr));\n\t\treturn 0;\n\t}\n\n\tmemstick_init_req(req, MS_TPC_WRITE_REG, buf, len);\n\treturn 1;\n}\n\n \nstatic int h_msb_default_bad(struct memstick_dev *card,\n\t\t\t\t\t\tstruct memstick_request **mrq)\n{\n\treturn -ENXIO;\n}\n\n \nstatic int h_msb_read_page(struct memstick_dev *card,\n\t\t\t\t\tstruct memstick_request **out_mrq)\n{\n\tstruct msb_data *msb = memstick_get_drvdata(card);\n\tstruct memstick_request *mrq = *out_mrq = &card->current_mrq;\n\tstruct scatterlist sg[2];\n\tu8 command, intreg;\n\n\tif (mrq->error) {\n\t\tdbg(\"read_page, unknown error\");\n\t\treturn msb_exit_state_machine(msb, mrq->error);\n\t}\nagain:\n\tswitch (msb->state) {\n\tcase MSB_RP_SEND_BLOCK_ADDRESS:\n\t\t \n\t\tif (!msb_write_regs(msb,\n\t\t\toffsetof(struct ms_register, param),\n\t\t\tsizeof(struct ms_param_register),\n\t\t\t(unsigned char *)&msb->regs.param))\n\t\t\treturn 0;\n\n\t\tmsb->state = MSB_RP_SEND_READ_COMMAND;\n\t\treturn 0;\n\n\tcase MSB_RP_SEND_READ_COMMAND:\n\t\tcommand = MS_CMD_BLOCK_READ;\n\t\tmemstick_init_req(mrq, MS_TPC_SET_CMD, &command, 1);\n\t\tmsb->state = MSB_RP_SEND_INT_REQ;\n\t\treturn 0;\n\n\tcase MSB_RP_SEND_INT_REQ:\n\t\tmsb->state = MSB_RP_RECEIVE_INT_REQ_RESULT;\n\t\t \n\t\tif (msb_read_int_reg(msb, -1))\n\t\t\treturn 0;\n\t\tfallthrough;\n\n\tcase MSB_RP_RECEIVE_INT_REQ_RESULT:\n\t\tintreg = mrq->data[0];\n\t\tmsb->regs.status.interrupt = intreg;\n\n\t\tif (intreg & MEMSTICK_INT_CMDNAK)\n\t\t\treturn msb_exit_state_machine(msb, -EIO);\n\n\t\tif (!(intreg & MEMSTICK_INT_CED)) {\n\t\t\tmsb->state = MSB_RP_SEND_INT_REQ;\n\t\t\tgoto again;\n\t\t}\n\n\t\tmsb->int_polling = false;\n\t\tmsb->state = (intreg & MEMSTICK_INT_ERR) ?\n\t\t\tMSB_RP_SEND_READ_STATUS_REG : MSB_RP_SEND_OOB_READ;\n\t\tgoto again;\n\n\tcase MSB_RP_SEND_READ_STATUS_REG:\n\t\t  \n\t\tif (!msb_read_regs(msb,\n\t\t\toffsetof(struct ms_register, status),\n\t\t\tsizeof(struct ms_status_register)))\n\t\t\treturn 0;\n\n\t\tmsb->state = MSB_RP_RECEIVE_STATUS_REG;\n\t\treturn 0;\n\n\tcase MSB_RP_RECEIVE_STATUS_REG:\n\t\tmsb->regs.status = *(struct ms_status_register *)mrq->data;\n\t\tmsb->state = MSB_RP_SEND_OOB_READ;\n\t\tfallthrough;\n\n\tcase MSB_RP_SEND_OOB_READ:\n\t\tif (!msb_read_regs(msb,\n\t\t\toffsetof(struct ms_register, extra_data),\n\t\t\tsizeof(struct ms_extra_data_register)))\n\t\t\treturn 0;\n\n\t\tmsb->state = MSB_RP_RECEIVE_OOB_READ;\n\t\treturn 0;\n\n\tcase MSB_RP_RECEIVE_OOB_READ:\n\t\tmsb->regs.extra_data =\n\t\t\t*(struct ms_extra_data_register *) mrq->data;\n\t\tmsb->state = MSB_RP_SEND_READ_DATA;\n\t\tfallthrough;\n\n\tcase MSB_RP_SEND_READ_DATA:\n\t\t \n\t\tif (msb->regs.param.cp == MEMSTICK_CP_EXTRA) {\n\t\t\tmsb->state = MSB_RP_RECEIVE_READ_DATA;\n\t\t\tgoto again;\n\t\t}\n\n\t\tsg_init_table(sg, ARRAY_SIZE(sg));\n\t\tmsb_sg_copy(msb->current_sg, sg, ARRAY_SIZE(sg),\n\t\t\tmsb->current_sg_offset,\n\t\t\tmsb->page_size);\n\n\t\tmemstick_init_req_sg(mrq, MS_TPC_READ_LONG_DATA, sg);\n\t\tmsb->state = MSB_RP_RECEIVE_READ_DATA;\n\t\treturn 0;\n\n\tcase MSB_RP_RECEIVE_READ_DATA:\n\t\tif (!(msb->regs.status.interrupt & MEMSTICK_INT_ERR)) {\n\t\t\tmsb->current_sg_offset += msb->page_size;\n\t\t\treturn msb_exit_state_machine(msb, 0);\n\t\t}\n\n\t\tif (msb->regs.status.status1 & MEMSTICK_UNCORR_ERROR) {\n\t\t\tdbg(\"read_page: uncorrectable error\");\n\t\t\treturn msb_exit_state_machine(msb, -EBADMSG);\n\t\t}\n\n\t\tif (msb->regs.status.status1 & MEMSTICK_CORR_ERROR) {\n\t\t\tdbg(\"read_page: correctable error\");\n\t\t\tmsb->current_sg_offset += msb->page_size;\n\t\t\treturn msb_exit_state_machine(msb, -EUCLEAN);\n\t\t} else {\n\t\t\tdbg(\"read_page: INT error, but no status error bits\");\n\t\t\treturn msb_exit_state_machine(msb, -EIO);\n\t\t}\n\t}\n\n\tBUG();\n}\n\n \nstatic int h_msb_write_block(struct memstick_dev *card,\n\t\t\t\t\tstruct memstick_request **out_mrq)\n{\n\tstruct msb_data *msb = memstick_get_drvdata(card);\n\tstruct memstick_request *mrq = *out_mrq = &card->current_mrq;\n\tstruct scatterlist sg[2];\n\tu8 intreg, command;\n\n\tif (mrq->error)\n\t\treturn msb_exit_state_machine(msb, mrq->error);\n\nagain:\n\tswitch (msb->state) {\n\n\t \n\n\tcase MSB_WB_SEND_WRITE_PARAMS:\n\t\tif (!msb_write_regs(msb,\n\t\t\toffsetof(struct ms_register, param),\n\t\t\tsizeof(struct ms_param_register),\n\t\t\t&msb->regs.param))\n\t\t\treturn 0;\n\n\t\tmsb->state = MSB_WB_SEND_WRITE_OOB;\n\t\treturn 0;\n\n\tcase MSB_WB_SEND_WRITE_OOB:\n\t\tif (!msb_write_regs(msb,\n\t\t\toffsetof(struct ms_register, extra_data),\n\t\t\tsizeof(struct ms_extra_data_register),\n\t\t\t&msb->regs.extra_data))\n\t\t\treturn 0;\n\t\tmsb->state = MSB_WB_SEND_WRITE_COMMAND;\n\t\treturn 0;\n\n\n\tcase MSB_WB_SEND_WRITE_COMMAND:\n\t\tcommand = MS_CMD_BLOCK_WRITE;\n\t\tmemstick_init_req(mrq, MS_TPC_SET_CMD, &command, 1);\n\t\tmsb->state = MSB_WB_SEND_INT_REQ;\n\t\treturn 0;\n\n\tcase MSB_WB_SEND_INT_REQ:\n\t\tmsb->state = MSB_WB_RECEIVE_INT_REQ;\n\t\tif (msb_read_int_reg(msb, -1))\n\t\t\treturn 0;\n\t\tfallthrough;\n\n\tcase MSB_WB_RECEIVE_INT_REQ:\n\t\tintreg = mrq->data[0];\n\t\tmsb->regs.status.interrupt = intreg;\n\n\t\t \n\t\tif (intreg & (MEMSTICK_INT_CMDNAK))\n\t\t\treturn msb_exit_state_machine(msb, -EIO);\n\n\t\tif (intreg & MEMSTICK_INT_ERR)\n\t\t\treturn msb_exit_state_machine(msb, -EBADMSG);\n\n\n\t\t \n\t\tif (msb->current_page == msb->pages_in_block) {\n\t\t\tif (intreg & MEMSTICK_INT_CED)\n\t\t\t\treturn msb_exit_state_machine(msb, 0);\n\t\t\tmsb->state = MSB_WB_SEND_INT_REQ;\n\t\t\tgoto again;\n\n\t\t}\n\n\t\t \n\t\tif (!(intreg & MEMSTICK_INT_BREQ)) {\n\t\t\tmsb->state = MSB_WB_SEND_INT_REQ;\n\t\t\tgoto again;\n\t\t}\n\n\t\tmsb->int_polling = false;\n\t\tmsb->state = MSB_WB_SEND_WRITE_DATA;\n\t\tfallthrough;\n\n\tcase MSB_WB_SEND_WRITE_DATA:\n\t\tsg_init_table(sg, ARRAY_SIZE(sg));\n\n\t\tif (msb_sg_copy(msb->current_sg, sg, ARRAY_SIZE(sg),\n\t\t\tmsb->current_sg_offset,\n\t\t\tmsb->page_size) < msb->page_size)\n\t\t\treturn msb_exit_state_machine(msb, -EIO);\n\n\t\tmemstick_init_req_sg(mrq, MS_TPC_WRITE_LONG_DATA, sg);\n\t\tmrq->need_card_int = 1;\n\t\tmsb->state = MSB_WB_RECEIVE_WRITE_CONFIRMATION;\n\t\treturn 0;\n\n\tcase MSB_WB_RECEIVE_WRITE_CONFIRMATION:\n\t\tmsb->current_page++;\n\t\tmsb->current_sg_offset += msb->page_size;\n\t\tmsb->state = MSB_WB_SEND_INT_REQ;\n\t\tgoto again;\n\tdefault:\n\t\tBUG();\n\t}\n\n\treturn 0;\n}\n\n \nstatic int h_msb_send_command(struct memstick_dev *card,\n\t\t\t\t\tstruct memstick_request **out_mrq)\n{\n\tstruct msb_data *msb = memstick_get_drvdata(card);\n\tstruct memstick_request *mrq = *out_mrq = &card->current_mrq;\n\tu8 intreg;\n\n\tif (mrq->error) {\n\t\tdbg(\"send_command: unknown error\");\n\t\treturn msb_exit_state_machine(msb, mrq->error);\n\t}\nagain:\n\tswitch (msb->state) {\n\n\t \n\tcase MSB_SC_SEND_WRITE_PARAMS:  \n\t\tif (!msb_write_regs(msb,\n\t\t\toffsetof(struct ms_register, param),\n\t\t\tsizeof(struct ms_param_register),\n\t\t\t&msb->regs.param))\n\t\t\treturn 0;\n\t\tmsb->state = MSB_SC_SEND_WRITE_OOB;\n\t\treturn 0;\n\n\tcase MSB_SC_SEND_WRITE_OOB:\n\t\tif (!msb->command_need_oob) {\n\t\t\tmsb->state = MSB_SC_SEND_COMMAND;\n\t\t\tgoto again;\n\t\t}\n\n\t\tif (!msb_write_regs(msb,\n\t\t\toffsetof(struct ms_register, extra_data),\n\t\t\tsizeof(struct ms_extra_data_register),\n\t\t\t&msb->regs.extra_data))\n\t\t\treturn 0;\n\n\t\tmsb->state = MSB_SC_SEND_COMMAND;\n\t\treturn 0;\n\n\tcase MSB_SC_SEND_COMMAND:\n\t\tmemstick_init_req(mrq, MS_TPC_SET_CMD, &msb->command_value, 1);\n\t\tmsb->state = MSB_SC_SEND_INT_REQ;\n\t\treturn 0;\n\n\tcase MSB_SC_SEND_INT_REQ:\n\t\tmsb->state = MSB_SC_RECEIVE_INT_REQ;\n\t\tif (msb_read_int_reg(msb, -1))\n\t\t\treturn 0;\n\t\tfallthrough;\n\n\tcase MSB_SC_RECEIVE_INT_REQ:\n\t\tintreg = mrq->data[0];\n\n\t\tif (intreg & MEMSTICK_INT_CMDNAK)\n\t\t\treturn msb_exit_state_machine(msb, -EIO);\n\t\tif (intreg & MEMSTICK_INT_ERR)\n\t\t\treturn msb_exit_state_machine(msb, -EBADMSG);\n\n\t\tif (!(intreg & MEMSTICK_INT_CED)) {\n\t\t\tmsb->state = MSB_SC_SEND_INT_REQ;\n\t\t\tgoto again;\n\t\t}\n\n\t\treturn msb_exit_state_machine(msb, 0);\n\t}\n\n\tBUG();\n}\n\n \nstatic int h_msb_reset(struct memstick_dev *card,\n\t\t\t\t\tstruct memstick_request **out_mrq)\n{\n\tu8 command = MS_CMD_RESET;\n\tstruct msb_data *msb = memstick_get_drvdata(card);\n\tstruct memstick_request *mrq = *out_mrq = &card->current_mrq;\n\n\tif (mrq->error)\n\t\treturn msb_exit_state_machine(msb, mrq->error);\n\n\tswitch (msb->state) {\n\tcase MSB_RS_SEND:\n\t\tmemstick_init_req(mrq, MS_TPC_SET_CMD, &command, 1);\n\t\tmrq->need_card_int = 0;\n\t\tmsb->state = MSB_RS_CONFIRM;\n\t\treturn 0;\n\tcase MSB_RS_CONFIRM:\n\t\treturn msb_exit_state_machine(msb, 0);\n\t}\n\tBUG();\n}\n\n \nstatic int h_msb_parallel_switch(struct memstick_dev *card,\n\t\t\t\t\tstruct memstick_request **out_mrq)\n{\n\tstruct msb_data *msb = memstick_get_drvdata(card);\n\tstruct memstick_request *mrq = *out_mrq = &card->current_mrq;\n\tstruct memstick_host *host = card->host;\n\n\tif (mrq->error) {\n\t\tdbg(\"parallel_switch: error\");\n\t\tmsb->regs.param.system &= ~MEMSTICK_SYS_PAM;\n\t\treturn msb_exit_state_machine(msb, mrq->error);\n\t}\n\n\tswitch (msb->state) {\n\tcase MSB_PS_SEND_SWITCH_COMMAND:\n\t\t \n\t\tmsb->regs.param.system |= MEMSTICK_SYS_PAM;\n\n\t\tif (!msb_write_regs(msb,\n\t\t\toffsetof(struct ms_register, param),\n\t\t\t1,\n\t\t\t(unsigned char *)&msb->regs.param))\n\t\t\treturn 0;\n\n\t\tmsb->state = MSB_PS_SWICH_HOST;\n\t\treturn 0;\n\n\tcase MSB_PS_SWICH_HOST:\n\t\t  \n\t\thost->set_param(host, MEMSTICK_INTERFACE, MEMSTICK_PAR4);\n\t\tmemstick_init_req(mrq, MS_TPC_GET_INT, NULL, 1);\n\t\tmsb->state = MSB_PS_CONFIRM;\n\t\treturn 0;\n\n\tcase MSB_PS_CONFIRM:\n\t\treturn msb_exit_state_machine(msb, 0);\n\t}\n\n\tBUG();\n}\n\nstatic int msb_switch_to_parallel(struct msb_data *msb);\n\n \nstatic int msb_reset(struct msb_data *msb, bool full)\n{\n\n\tbool was_parallel = msb->regs.param.system & MEMSTICK_SYS_PAM;\n\tstruct memstick_dev *card = msb->card;\n\tstruct memstick_host *host = card->host;\n\tint error;\n\n\t \n\tmsb->regs.param.system = MEMSTICK_SYS_BAMD;\n\n\tif (full) {\n\t\terror =  host->set_param(host,\n\t\t\t\t\tMEMSTICK_POWER, MEMSTICK_POWER_OFF);\n\t\tif (error)\n\t\t\tgoto out_error;\n\n\t\tmsb_invalidate_reg_window(msb);\n\n\t\terror = host->set_param(host,\n\t\t\t\t\tMEMSTICK_POWER, MEMSTICK_POWER_ON);\n\t\tif (error)\n\t\t\tgoto out_error;\n\n\t\terror = host->set_param(host,\n\t\t\t\t\tMEMSTICK_INTERFACE, MEMSTICK_SERIAL);\n\t\tif (error) {\nout_error:\n\t\t\tdbg(\"Failed to reset the host controller\");\n\t\t\tmsb->read_only = true;\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\terror = msb_run_state_machine(msb, h_msb_reset);\n\tif (error) {\n\t\tdbg(\"Failed to reset the card\");\n\t\tmsb->read_only = true;\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (was_parallel)\n\t\tmsb_switch_to_parallel(msb);\n\treturn 0;\n}\n\n \nstatic int msb_switch_to_parallel(struct msb_data *msb)\n{\n\tint error;\n\n\terror = msb_run_state_machine(msb, h_msb_parallel_switch);\n\tif (error) {\n\t\tpr_err(\"Switch to parallel failed\");\n\t\tmsb->regs.param.system &= ~MEMSTICK_SYS_PAM;\n\t\tmsb_reset(msb, true);\n\t\treturn -EFAULT;\n\t}\n\n\tmsb->caps |= MEMSTICK_CAP_AUTO_GET_INT;\n\treturn 0;\n}\n\n \nstatic int msb_set_overwrite_flag(struct msb_data *msb,\n\t\t\t\t\t\tu16 pba, u8 page, u8 flag)\n{\n\tif (msb->read_only)\n\t\treturn -EROFS;\n\n\tmsb->regs.param.block_address = cpu_to_be16(pba);\n\tmsb->regs.param.page_address = page;\n\tmsb->regs.param.cp = MEMSTICK_CP_OVERWRITE;\n\tmsb->regs.extra_data.overwrite_flag = flag;\n\tmsb->command_value = MS_CMD_BLOCK_WRITE;\n\tmsb->command_need_oob = true;\n\n\tdbg_verbose(\"changing overwrite flag to %02x for sector %d, page %d\",\n\t\t\t\t\t\t\tflag, pba, page);\n\treturn msb_run_state_machine(msb, h_msb_send_command);\n}\n\nstatic int msb_mark_bad(struct msb_data *msb, int pba)\n{\n\tpr_notice(\"marking pba %d as bad\", pba);\n\tmsb_reset(msb, true);\n\treturn msb_set_overwrite_flag(\n\t\t\tmsb, pba, 0, 0xFF & ~MEMSTICK_OVERWRITE_BKST);\n}\n\nstatic int msb_mark_page_bad(struct msb_data *msb, int pba, int page)\n{\n\tdbg(\"marking page %d of pba %d as bad\", page, pba);\n\tmsb_reset(msb, true);\n\treturn msb_set_overwrite_flag(msb,\n\t\tpba, page, ~MEMSTICK_OVERWRITE_PGST0);\n}\n\n \nstatic int msb_erase_block(struct msb_data *msb, u16 pba)\n{\n\tint error, try;\n\n\tif (msb->read_only)\n\t\treturn -EROFS;\n\n\tdbg_verbose(\"erasing pba %d\", pba);\n\n\tfor (try = 1; try < 3; try++) {\n\t\tmsb->regs.param.block_address = cpu_to_be16(pba);\n\t\tmsb->regs.param.page_address = 0;\n\t\tmsb->regs.param.cp = MEMSTICK_CP_BLOCK;\n\t\tmsb->command_value = MS_CMD_BLOCK_ERASE;\n\t\tmsb->command_need_oob = false;\n\n\n\t\terror = msb_run_state_machine(msb, h_msb_send_command);\n\t\tif (!error || msb_reset(msb, true))\n\t\t\tbreak;\n\t}\n\n\tif (error) {\n\t\tpr_err(\"erase failed, marking pba %d as bad\", pba);\n\t\tmsb_mark_bad(msb, pba);\n\t}\n\n\tdbg_verbose(\"erase success, marking pba %d as unused\", pba);\n\tmsb_mark_block_unused(msb, pba);\n\t__set_bit(pba, msb->erased_blocks_bitmap);\n\treturn error;\n}\n\n \nstatic int msb_read_page(struct msb_data *msb,\n\tu16 pba, u8 page, struct ms_extra_data_register *extra,\n\t\t\t\t\tstruct scatterlist *sg,  int offset)\n{\n\tint try, error;\n\n\tif (pba == MS_BLOCK_INVALID) {\n\t\tunsigned long flags;\n\t\tstruct sg_mapping_iter miter;\n\t\tsize_t len = msb->page_size;\n\n\t\tdbg_verbose(\"read unmapped sector. returning 0xFF\");\n\n\t\tlocal_irq_save(flags);\n\t\tsg_miter_start(&miter, sg, sg_nents(sg),\n\t\t\t\tSG_MITER_ATOMIC | SG_MITER_TO_SG);\n\n\t\twhile (sg_miter_next(&miter) && len > 0) {\n\n\t\t\tint chunklen;\n\n\t\t\tif (offset && offset >= miter.length) {\n\t\t\t\toffset -= miter.length;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tchunklen = min(miter.length - offset, len);\n\t\t\tmemset(miter.addr + offset, 0xFF, chunklen);\n\t\t\tlen -= chunklen;\n\t\t\toffset = 0;\n\t\t}\n\n\t\tsg_miter_stop(&miter);\n\t\tlocal_irq_restore(flags);\n\n\t\tif (offset)\n\t\t\treturn -EFAULT;\n\n\t\tif (extra)\n\t\t\tmemset(extra, 0xFF, sizeof(*extra));\n\t\treturn 0;\n\t}\n\n\tif (pba >= msb->block_count) {\n\t\tpr_err(\"BUG: attempt to read beyond the end of the card at pba %d\", pba);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (try = 1; try < 3; try++) {\n\t\tmsb->regs.param.block_address = cpu_to_be16(pba);\n\t\tmsb->regs.param.page_address = page;\n\t\tmsb->regs.param.cp = MEMSTICK_CP_PAGE;\n\n\t\tmsb->current_sg = sg;\n\t\tmsb->current_sg_offset = offset;\n\t\terror = msb_run_state_machine(msb, h_msb_read_page);\n\n\n\t\tif (error == -EUCLEAN) {\n\t\t\tpr_notice(\"correctable error on pba %d, page %d\",\n\t\t\t\tpba, page);\n\t\t\terror = 0;\n\t\t}\n\n\t\tif (!error && extra)\n\t\t\t*extra = msb->regs.extra_data;\n\n\t\tif (!error || msb_reset(msb, true))\n\t\t\tbreak;\n\n\t}\n\n\t \n\tif (error == -EBADMSG) {\n\t\tpr_err(\"uncorrectable error on read of pba %d, page %d\",\n\t\t\tpba, page);\n\n\t\tif (msb->regs.extra_data.overwrite_flag &\n\t\t\t\t\tMEMSTICK_OVERWRITE_PGST0)\n\t\t\tmsb_mark_page_bad(msb, pba, page);\n\t\treturn -EBADMSG;\n\t}\n\n\tif (error)\n\t\tpr_err(\"read of pba %d, page %d failed with error %d\",\n\t\t\tpba, page, error);\n\treturn error;\n}\n\n \nstatic int msb_read_oob(struct msb_data *msb, u16 pba, u16 page,\n\tstruct ms_extra_data_register *extra)\n{\n\tint error;\n\n\tBUG_ON(!extra);\n\tmsb->regs.param.block_address = cpu_to_be16(pba);\n\tmsb->regs.param.page_address = page;\n\tmsb->regs.param.cp = MEMSTICK_CP_EXTRA;\n\n\tif (pba > msb->block_count) {\n\t\tpr_err(\"BUG: attempt to read beyond the end of card at pba %d\", pba);\n\t\treturn -EINVAL;\n\t}\n\n\terror = msb_run_state_machine(msb, h_msb_read_page);\n\t*extra = msb->regs.extra_data;\n\n\tif (error == -EUCLEAN) {\n\t\tpr_notice(\"correctable error on pba %d, page %d\",\n\t\t\tpba, page);\n\t\treturn 0;\n\t}\n\n\treturn error;\n}\n\n \nstatic int msb_verify_block(struct msb_data *msb, u16 pba,\n\t\t\t\tstruct scatterlist *orig_sg,  int offset)\n{\n\tstruct scatterlist sg;\n\tint page = 0, error;\n\n\tsg_init_one(&sg, msb->block_buffer, msb->block_size);\n\n\twhile (page < msb->pages_in_block) {\n\n\t\terror = msb_read_page(msb, pba, page,\n\t\t\t\tNULL, &sg, page * msb->page_size);\n\t\tif (error)\n\t\t\treturn error;\n\t\tpage++;\n\t}\n\n\tif (msb_sg_compare_to_buffer(orig_sg, offset,\n\t\t\t\tmsb->block_buffer, msb->block_size))\n\t\treturn -EIO;\n\treturn 0;\n}\n\n \nstatic int msb_write_block(struct msb_data *msb,\n\t\t\tu16 pba, u32 lba, struct scatterlist *sg, int offset)\n{\n\tint error, current_try = 1;\n\n\tBUG_ON(sg->length < msb->page_size);\n\n\tif (msb->read_only)\n\t\treturn -EROFS;\n\n\tif (pba == MS_BLOCK_INVALID) {\n\t\tpr_err(\n\t\t\t\"BUG: write: attempt to write MS_BLOCK_INVALID block\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (pba >= msb->block_count || lba >= msb->logical_block_count) {\n\t\tpr_err(\n\t\t\"BUG: write: attempt to write beyond the end of device\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (msb_get_zone_from_lba(lba) != msb_get_zone_from_pba(pba)) {\n\t\tpr_err(\"BUG: write: lba zone mismatch\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (pba == msb->boot_block_locations[0] ||\n\t\tpba == msb->boot_block_locations[1]) {\n\t\tpr_err(\"BUG: write: attempt to write to boot blocks!\");\n\t\treturn -EINVAL;\n\t}\n\n\twhile (1) {\n\n\t\tif (msb->read_only)\n\t\t\treturn -EROFS;\n\n\t\tmsb->regs.param.cp = MEMSTICK_CP_BLOCK;\n\t\tmsb->regs.param.page_address = 0;\n\t\tmsb->regs.param.block_address = cpu_to_be16(pba);\n\n\t\tmsb->regs.extra_data.management_flag = 0xFF;\n\t\tmsb->regs.extra_data.overwrite_flag = 0xF8;\n\t\tmsb->regs.extra_data.logical_address = cpu_to_be16(lba);\n\n\t\tmsb->current_sg = sg;\n\t\tmsb->current_sg_offset = offset;\n\t\tmsb->current_page = 0;\n\n\t\terror = msb_run_state_machine(msb, h_msb_write_block);\n\n\t\t \n\t\tif (!error && (verify_writes ||\n\t\t\t\t!test_bit(pba, msb->erased_blocks_bitmap)))\n\t\t\terror = msb_verify_block(msb, pba, sg, offset);\n\n\t\tif (!error)\n\t\t\tbreak;\n\n\t\tif (current_try > 1 || msb_reset(msb, true))\n\t\t\tbreak;\n\n\t\tpr_err(\"write failed, trying to erase the pba %d\", pba);\n\t\terror = msb_erase_block(msb, pba);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tcurrent_try++;\n\t}\n\treturn error;\n}\n\n \nstatic u16 msb_get_free_block(struct msb_data *msb, int zone)\n{\n\tu16 pos;\n\tint pba = zone * MS_BLOCKS_IN_ZONE;\n\tint i;\n\n\tget_random_bytes(&pos, sizeof(pos));\n\n\tif (!msb->free_block_count[zone]) {\n\t\tpr_err(\"NO free blocks in the zone %d, to use for a write, (media is WORN out) switching to RO mode\", zone);\n\t\tmsb->read_only = true;\n\t\treturn MS_BLOCK_INVALID;\n\t}\n\n\tpos %= msb->free_block_count[zone];\n\n\tdbg_verbose(\"have %d choices for a free block, selected randomly: %d\",\n\t\tmsb->free_block_count[zone], pos);\n\n\tpba = find_next_zero_bit(msb->used_blocks_bitmap,\n\t\t\t\t\t\t\tmsb->block_count, pba);\n\tfor (i = 0; i < pos; ++i)\n\t\tpba = find_next_zero_bit(msb->used_blocks_bitmap,\n\t\t\t\t\t\tmsb->block_count, pba + 1);\n\n\tdbg_verbose(\"result of the free blocks scan: pba %d\", pba);\n\n\tif (pba == msb->block_count || (msb_get_zone_from_pba(pba)) != zone) {\n\t\tpr_err(\"BUG: can't get a free block\");\n\t\tmsb->read_only = true;\n\t\treturn MS_BLOCK_INVALID;\n\t}\n\n\tmsb_mark_block_used(msb, pba);\n\treturn pba;\n}\n\nstatic int msb_update_block(struct msb_data *msb, u16 lba,\n\tstruct scatterlist *sg, int offset)\n{\n\tu16 pba, new_pba;\n\tint error, try;\n\n\tpba = msb->lba_to_pba_table[lba];\n\tdbg_verbose(\"start of a block update at lba  %d, pba %d\", lba, pba);\n\n\tif (pba != MS_BLOCK_INVALID) {\n\t\tdbg_verbose(\"setting the update flag on the block\");\n\t\tmsb_set_overwrite_flag(msb, pba, 0,\n\t\t\t\t0xFF & ~MEMSTICK_OVERWRITE_UDST);\n\t}\n\n\tfor (try = 0; try < 3; try++) {\n\t\tnew_pba = msb_get_free_block(msb,\n\t\t\tmsb_get_zone_from_lba(lba));\n\n\t\tif (new_pba == MS_BLOCK_INVALID) {\n\t\t\terror = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\tdbg_verbose(\"block update: writing updated block to the pba %d\",\n\t\t\t\t\t\t\t\tnew_pba);\n\t\terror = msb_write_block(msb, new_pba, lba, sg, offset);\n\t\tif (error == -EBADMSG) {\n\t\t\tmsb_mark_bad(msb, new_pba);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\tdbg_verbose(\"block update: erasing the old block\");\n\t\tmsb_erase_block(msb, pba);\n\t\tmsb->lba_to_pba_table[lba] = new_pba;\n\t\treturn 0;\n\t}\nout:\n\tif (error) {\n\t\tpr_err(\"block update error after %d tries,  switching to r/o mode\", try);\n\t\tmsb->read_only = true;\n\t}\n\treturn error;\n}\n\n \nstatic void msb_fix_boot_page_endianness(struct ms_boot_page *p)\n{\n\tp->header.block_id = be16_to_cpu(p->header.block_id);\n\tp->header.format_reserved = be16_to_cpu(p->header.format_reserved);\n\tp->entry.disabled_block.start_addr\n\t\t= be32_to_cpu(p->entry.disabled_block.start_addr);\n\tp->entry.disabled_block.data_size\n\t\t= be32_to_cpu(p->entry.disabled_block.data_size);\n\tp->entry.cis_idi.start_addr\n\t\t= be32_to_cpu(p->entry.cis_idi.start_addr);\n\tp->entry.cis_idi.data_size\n\t\t= be32_to_cpu(p->entry.cis_idi.data_size);\n\tp->attr.block_size = be16_to_cpu(p->attr.block_size);\n\tp->attr.number_of_blocks = be16_to_cpu(p->attr.number_of_blocks);\n\tp->attr.number_of_effective_blocks\n\t\t= be16_to_cpu(p->attr.number_of_effective_blocks);\n\tp->attr.page_size = be16_to_cpu(p->attr.page_size);\n\tp->attr.memory_manufacturer_code\n\t\t= be16_to_cpu(p->attr.memory_manufacturer_code);\n\tp->attr.memory_device_code = be16_to_cpu(p->attr.memory_device_code);\n\tp->attr.implemented_capacity\n\t\t= be16_to_cpu(p->attr.implemented_capacity);\n\tp->attr.controller_number = be16_to_cpu(p->attr.controller_number);\n\tp->attr.controller_function = be16_to_cpu(p->attr.controller_function);\n}\n\nstatic int msb_read_boot_blocks(struct msb_data *msb)\n{\n\tint pba = 0;\n\tstruct scatterlist sg;\n\tstruct ms_extra_data_register extra;\n\tstruct ms_boot_page *page;\n\n\tmsb->boot_block_locations[0] = MS_BLOCK_INVALID;\n\tmsb->boot_block_locations[1] = MS_BLOCK_INVALID;\n\tmsb->boot_block_count = 0;\n\n\tdbg_verbose(\"Start of a scan for the boot blocks\");\n\n\tif (!msb->boot_page) {\n\t\tpage = kmalloc_array(2, sizeof(struct ms_boot_page),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\n\t\tmsb->boot_page = page;\n\t} else\n\t\tpage = msb->boot_page;\n\n\tmsb->block_count = MS_BLOCK_MAX_BOOT_ADDR;\n\n\tfor (pba = 0; pba < MS_BLOCK_MAX_BOOT_ADDR; pba++) {\n\n\t\tsg_init_one(&sg, page, sizeof(*page));\n\t\tif (msb_read_page(msb, pba, 0, &extra, &sg, 0)) {\n\t\t\tdbg(\"boot scan: can't read pba %d\", pba);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (extra.management_flag & MEMSTICK_MANAGEMENT_SYSFLG) {\n\t\t\tdbg(\"management flag doesn't indicate boot block %d\",\n\t\t\t\t\t\t\t\t\tpba);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (be16_to_cpu(page->header.block_id) != MS_BLOCK_BOOT_ID) {\n\t\t\tdbg(\"the pba at %d doesn't contain boot block ID\", pba);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmsb_fix_boot_page_endianness(page);\n\t\tmsb->boot_block_locations[msb->boot_block_count] = pba;\n\n\t\tpage++;\n\t\tmsb->boot_block_count++;\n\n\t\tif (msb->boot_block_count == 2)\n\t\t\tbreak;\n\t}\n\n\tif (!msb->boot_block_count) {\n\t\tpr_err(\"media doesn't contain master page, aborting\");\n\t\treturn -EIO;\n\t}\n\n\tdbg_verbose(\"End of scan for boot blocks\");\n\treturn 0;\n}\n\nstatic int msb_read_bad_block_table(struct msb_data *msb, int block_nr)\n{\n\tstruct ms_boot_page *boot_block;\n\tstruct scatterlist sg;\n\tu16 *buffer = NULL;\n\tint offset = 0;\n\tint i, error = 0;\n\tint data_size, data_offset, page, page_offset, size_to_read;\n\tu16 pba;\n\n\tBUG_ON(block_nr > 1);\n\tboot_block = &msb->boot_page[block_nr];\n\tpba = msb->boot_block_locations[block_nr];\n\n\tif (msb->boot_block_locations[block_nr] == MS_BLOCK_INVALID)\n\t\treturn -EINVAL;\n\n\tdata_size = boot_block->entry.disabled_block.data_size;\n\tdata_offset = sizeof(struct ms_boot_page) +\n\t\t\tboot_block->entry.disabled_block.start_addr;\n\tif (!data_size)\n\t\treturn 0;\n\n\tpage = data_offset / msb->page_size;\n\tpage_offset = data_offset % msb->page_size;\n\tsize_to_read =\n\t\tDIV_ROUND_UP(data_size + page_offset, msb->page_size) *\n\t\t\tmsb->page_size;\n\n\tdbg(\"reading bad block of boot block at pba %d, offset %d len %d\",\n\t\tpba, data_offset, data_size);\n\n\tbuffer = kzalloc(size_to_read, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\t \n\tsg_init_one(&sg, buffer, size_to_read);\n\n\twhile (offset < size_to_read) {\n\t\terror = msb_read_page(msb, pba, page, NULL, &sg, offset);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\tpage++;\n\t\toffset += msb->page_size;\n\n\t\tif (page == msb->pages_in_block) {\n\t\t\tpr_err(\n\t\t\t\"bad block table extends beyond the boot block\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tfor (i = page_offset; i < data_size / sizeof(u16); i++) {\n\n\t\tu16 bad_block = be16_to_cpu(buffer[i]);\n\n\t\tif (bad_block >= msb->block_count) {\n\t\t\tdbg(\"bad block table contains invalid block %d\",\n\t\t\t\t\t\t\t\tbad_block);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (test_bit(bad_block, msb->used_blocks_bitmap))  {\n\t\t\tdbg(\"duplicate bad block %d in the table\",\n\t\t\t\tbad_block);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdbg(\"block %d is marked as factory bad\", bad_block);\n\t\tmsb_mark_block_used(msb, bad_block);\n\t}\nout:\n\tkfree(buffer);\n\treturn error;\n}\n\nstatic int msb_ftl_initialize(struct msb_data *msb)\n{\n\tint i;\n\n\tif (msb->ftl_initialized)\n\t\treturn 0;\n\n\tmsb->zone_count = msb->block_count / MS_BLOCKS_IN_ZONE;\n\tmsb->logical_block_count = msb->zone_count * 496 - 2;\n\n\tmsb->used_blocks_bitmap = bitmap_zalloc(msb->block_count, GFP_KERNEL);\n\tmsb->erased_blocks_bitmap = bitmap_zalloc(msb->block_count, GFP_KERNEL);\n\tmsb->lba_to_pba_table =\n\t\tkmalloc_array(msb->logical_block_count, sizeof(u16),\n\t\t\t      GFP_KERNEL);\n\n\tif (!msb->used_blocks_bitmap || !msb->lba_to_pba_table ||\n\t\t\t\t\t\t!msb->erased_blocks_bitmap) {\n\t\tbitmap_free(msb->used_blocks_bitmap);\n\t\tbitmap_free(msb->erased_blocks_bitmap);\n\t\tkfree(msb->lba_to_pba_table);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < msb->zone_count; i++)\n\t\tmsb->free_block_count[i] = MS_BLOCKS_IN_ZONE;\n\n\tmemset(msb->lba_to_pba_table, MS_BLOCK_INVALID,\n\t\t\tmsb->logical_block_count * sizeof(u16));\n\n\tdbg(\"initial FTL tables created. Zone count = %d, Logical block count = %d\",\n\t\tmsb->zone_count, msb->logical_block_count);\n\n\tmsb->ftl_initialized = true;\n\treturn 0;\n}\n\nstatic int msb_ftl_scan(struct msb_data *msb)\n{\n\tu16 pba, lba, other_block;\n\tu8 overwrite_flag, management_flag, other_overwrite_flag;\n\tint error;\n\tstruct ms_extra_data_register extra;\n\tu8 *overwrite_flags = kzalloc(msb->block_count, GFP_KERNEL);\n\n\tif (!overwrite_flags)\n\t\treturn -ENOMEM;\n\n\tdbg(\"Start of media scanning\");\n\tfor (pba = 0; pba < msb->block_count; pba++) {\n\n\t\tif (pba == msb->boot_block_locations[0] ||\n\t\t\tpba == msb->boot_block_locations[1]) {\n\t\t\tdbg_verbose(\"pba %05d -> [boot block]\", pba);\n\t\t\tmsb_mark_block_used(msb, pba);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (test_bit(pba, msb->used_blocks_bitmap)) {\n\t\t\tdbg_verbose(\"pba %05d -> [factory bad]\", pba);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmemset(&extra, 0, sizeof(extra));\n\t\terror = msb_read_oob(msb, pba, 0, &extra);\n\n\t\t \n\t\tif (error == -EBADMSG) {\n\t\t\tpr_notice(\n\t\t\t\"oob of pba %d damaged, will try to erase it\", pba);\n\t\t\tmsb_mark_block_used(msb, pba);\n\t\t\tmsb_erase_block(msb, pba);\n\t\t\tcontinue;\n\t\t} else if (error) {\n\t\t\tpr_err(\"unknown error %d on read of oob of pba %d - aborting\",\n\t\t\t\terror, pba);\n\n\t\t\tkfree(overwrite_flags);\n\t\t\treturn error;\n\t\t}\n\n\t\tlba = be16_to_cpu(extra.logical_address);\n\t\tmanagement_flag = extra.management_flag;\n\t\toverwrite_flag = extra.overwrite_flag;\n\t\toverwrite_flags[pba] = overwrite_flag;\n\n\t\t \n\t\tif (!(overwrite_flag & MEMSTICK_OVERWRITE_BKST)) {\n\t\t\tdbg(\"pba %05d -> [BAD]\", pba);\n\t\t\tmsb_mark_block_used(msb, pba);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif ((management_flag & MEMSTICK_MANAGEMENT_FLAG_NORMAL) !=\n\t\t\tMEMSTICK_MANAGEMENT_FLAG_NORMAL) {\n\t\t\tdbg(\"pba %05d -> [reserved management flag %02x]\",\n\t\t\t\t\t\t\tpba, management_flag);\n\t\t\tmsb_mark_block_used(msb, pba);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (!(management_flag & MEMSTICK_MANAGEMENT_ATFLG)) {\n\t\t\tdbg(\"pba %05d -> [temp table] - will erase\", pba);\n\n\t\t\tmsb_mark_block_used(msb, pba);\n\t\t\tmsb_erase_block(msb, pba);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (lba == MS_BLOCK_INVALID) {\n\t\t\tdbg_verbose(\"pba %05d -> [free]\", pba);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmsb_mark_block_used(msb, pba);\n\n\t\t \n\t\tif (msb_get_zone_from_lba(lba) != msb_get_zone_from_pba(pba)) {\n\t\t\tpr_notice(\"pba %05d -> [bad lba %05d] - will erase\",\n\t\t\t\t\t\t\t\tpba, lba);\n\t\t\tmsb_erase_block(msb, pba);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (msb->lba_to_pba_table[lba] == MS_BLOCK_INVALID) {\n\t\t\tdbg_verbose(\"pba %05d -> [lba %05d]\", pba, lba);\n\t\t\tmsb->lba_to_pba_table[lba] = pba;\n\t\t\tcontinue;\n\t\t}\n\n\t\tother_block = msb->lba_to_pba_table[lba];\n\t\tother_overwrite_flag = overwrite_flags[other_block];\n\n\t\tpr_notice(\"Collision between pba %d and pba %d\",\n\t\t\tpba, other_block);\n\n\t\tif (!(overwrite_flag & MEMSTICK_OVERWRITE_UDST)) {\n\t\t\tpr_notice(\"pba %d is marked as stable, use it\", pba);\n\t\t\tmsb_erase_block(msb, other_block);\n\t\t\tmsb->lba_to_pba_table[lba] = pba;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!(other_overwrite_flag & MEMSTICK_OVERWRITE_UDST)) {\n\t\t\tpr_notice(\"pba %d is marked as stable, use it\",\n\t\t\t\t\t\t\t\tother_block);\n\t\t\tmsb_erase_block(msb, pba);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpr_notice(\"collision between blocks %d and %d, without stable flag set on both, erasing pba %d\",\n\t\t\t\tpba, other_block, other_block);\n\n\t\tmsb_erase_block(msb, other_block);\n\t\tmsb->lba_to_pba_table[lba] = pba;\n\t}\n\n\tdbg(\"End of media scanning\");\n\tkfree(overwrite_flags);\n\treturn 0;\n}\n\nstatic void msb_cache_flush_timer(struct timer_list *t)\n{\n\tstruct msb_data *msb = from_timer(msb, t, cache_flush_timer);\n\n\tmsb->need_flush_cache = true;\n\tqueue_work(msb->io_queue, &msb->io_work);\n}\n\n\nstatic void msb_cache_discard(struct msb_data *msb)\n{\n\tif (msb->cache_block_lba == MS_BLOCK_INVALID)\n\t\treturn;\n\n\tdel_timer_sync(&msb->cache_flush_timer);\n\n\tdbg_verbose(\"Discarding the write cache\");\n\tmsb->cache_block_lba = MS_BLOCK_INVALID;\n\tbitmap_zero(&msb->valid_cache_bitmap, msb->pages_in_block);\n}\n\nstatic int msb_cache_init(struct msb_data *msb)\n{\n\ttimer_setup(&msb->cache_flush_timer, msb_cache_flush_timer, 0);\n\n\tif (!msb->cache)\n\t\tmsb->cache = kzalloc(msb->block_size, GFP_KERNEL);\n\tif (!msb->cache)\n\t\treturn -ENOMEM;\n\n\tmsb_cache_discard(msb);\n\treturn 0;\n}\n\nstatic int msb_cache_flush(struct msb_data *msb)\n{\n\tstruct scatterlist sg;\n\tstruct ms_extra_data_register extra;\n\tint page, offset, error;\n\tu16 pba, lba;\n\n\tif (msb->read_only)\n\t\treturn -EROFS;\n\n\tif (msb->cache_block_lba == MS_BLOCK_INVALID)\n\t\treturn 0;\n\n\tlba = msb->cache_block_lba;\n\tpba = msb->lba_to_pba_table[lba];\n\n\tdbg_verbose(\"Flushing the write cache of pba %d (LBA %d)\",\n\t\t\t\t\t\tpba, msb->cache_block_lba);\n\n\tsg_init_one(&sg, msb->cache , msb->block_size);\n\n\t \n\tfor (page = 0; page < msb->pages_in_block; page++) {\n\n\t\tif (test_bit(page, &msb->valid_cache_bitmap))\n\t\t\tcontinue;\n\n\t\toffset = page * msb->page_size;\n\n\t\tdbg_verbose(\"reading non-present sector %d of cache block %d\",\n\t\t\tpage, lba);\n\t\terror = msb_read_page(msb, pba, page, &extra, &sg, offset);\n\n\t\t \n\t\tif (error == -EBADMSG) {\n\t\t\tpr_err(\"read error on sector %d, contents probably damaged\", page);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif ((extra.overwrite_flag & MEMSTICK_OV_PG_NORMAL) !=\n\t\t\t\t\t\t\tMEMSTICK_OV_PG_NORMAL) {\n\t\t\tdbg(\"page %d is marked as bad\", page);\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_bit(page, &msb->valid_cache_bitmap);\n\t}\n\n\t \n\terror = msb_update_block(msb, msb->cache_block_lba, &sg, 0);\n\tpba = msb->lba_to_pba_table[msb->cache_block_lba];\n\n\t \n\tif (!error) {\n\t\tfor (page = 0; page < msb->pages_in_block; page++) {\n\n\t\t\tif (test_bit(page, &msb->valid_cache_bitmap))\n\t\t\t\tcontinue;\n\n\t\t\tdbg(\"marking page %d as containing damaged data\",\n\t\t\t\tpage);\n\t\t\tmsb_set_overwrite_flag(msb,\n\t\t\t\tpba , page, 0xFF & ~MEMSTICK_OV_PG_NORMAL);\n\t\t}\n\t}\n\n\tmsb_cache_discard(msb);\n\treturn error;\n}\n\nstatic int msb_cache_write(struct msb_data *msb, int lba,\n\tint page, bool add_to_cache_only, struct scatterlist *sg, int offset)\n{\n\tint error;\n\tstruct scatterlist sg_tmp[10];\n\n\tif (msb->read_only)\n\t\treturn -EROFS;\n\n\tif (msb->cache_block_lba == MS_BLOCK_INVALID ||\n\t\t\t\t\t\tlba != msb->cache_block_lba)\n\t\tif (add_to_cache_only)\n\t\t\treturn 0;\n\n\t \n\tif (msb->cache_block_lba != MS_BLOCK_INVALID &&\n\t\t\t\t\t\tlba != msb->cache_block_lba) {\n\t\tdbg_verbose(\"first flush the cache\");\n\t\terror = msb_cache_flush(msb);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tif (msb->cache_block_lba  == MS_BLOCK_INVALID) {\n\t\tmsb->cache_block_lba  = lba;\n\t\tmod_timer(&msb->cache_flush_timer,\n\t\t\tjiffies + msecs_to_jiffies(cache_flush_timeout));\n\t}\n\n\tdbg_verbose(\"Write of LBA %d page %d to cache \", lba, page);\n\n\tsg_init_table(sg_tmp, ARRAY_SIZE(sg_tmp));\n\tmsb_sg_copy(sg, sg_tmp, ARRAY_SIZE(sg_tmp), offset, msb->page_size);\n\n\tsg_copy_to_buffer(sg_tmp, sg_nents(sg_tmp),\n\t\tmsb->cache + page * msb->page_size, msb->page_size);\n\n\tset_bit(page, &msb->valid_cache_bitmap);\n\treturn 0;\n}\n\nstatic int msb_cache_read(struct msb_data *msb, int lba,\n\t\t\t\tint page, struct scatterlist *sg, int offset)\n{\n\tint pba = msb->lba_to_pba_table[lba];\n\tstruct scatterlist sg_tmp[10];\n\tint error = 0;\n\n\tif (lba == msb->cache_block_lba &&\n\t\t\ttest_bit(page, &msb->valid_cache_bitmap)) {\n\n\t\tdbg_verbose(\"Read of LBA %d (pba %d) sector %d from cache\",\n\t\t\t\t\t\t\tlba, pba, page);\n\n\t\tsg_init_table(sg_tmp, ARRAY_SIZE(sg_tmp));\n\t\tmsb_sg_copy(sg, sg_tmp, ARRAY_SIZE(sg_tmp),\n\t\t\toffset, msb->page_size);\n\t\tsg_copy_from_buffer(sg_tmp, sg_nents(sg_tmp),\n\t\t\tmsb->cache + msb->page_size * page,\n\t\t\t\t\t\t\tmsb->page_size);\n\t} else {\n\t\tdbg_verbose(\"Read of LBA %d (pba %d) sector %d from device\",\n\t\t\t\t\t\t\tlba, pba, page);\n\n\t\terror = msb_read_page(msb, pba, page, NULL, sg, offset);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tmsb_cache_write(msb, lba, page, true, sg, offset);\n\t}\n\treturn error;\n}\n\n \n\nstatic const struct chs_entry chs_table[] = {\n \n\t{ 4,    16,    247,       2  },\n\t{ 8,    16,    495,       2  },\n\t{ 16,   16,    495,       4  },\n\t{ 32,   16,    991,       4  },\n\t{ 64,   16,    991,       8  },\n\t{128,   16,    991,       16 },\n\t{ 0 }\n};\n\n \nstatic int msb_init_card(struct memstick_dev *card)\n{\n\tstruct msb_data *msb = memstick_get_drvdata(card);\n\tstruct memstick_host *host = card->host;\n\tstruct ms_boot_page *boot_block;\n\tint error = 0, i, raw_size_in_megs;\n\n\tmsb->caps = 0;\n\n\tif (card->id.class >= MEMSTICK_CLASS_ROM &&\n\t\t\t\tcard->id.class <= MEMSTICK_CLASS_ROM)\n\t\tmsb->read_only = true;\n\n\tmsb->state = -1;\n\terror = msb_reset(msb, false);\n\tif (error)\n\t\treturn error;\n\n\t \n\tif (host->caps & MEMSTICK_CAP_PAR4)\n\t\tmsb_switch_to_parallel(msb);\n\n\tmsb->page_size = sizeof(struct ms_boot_page);\n\n\t \n\terror = msb_read_boot_blocks(msb);\n\tif (error)\n\t\treturn -EIO;\n\n\tboot_block = &msb->boot_page[0];\n\n\t \n\tmsb->block_count = boot_block->attr.number_of_blocks;\n\tmsb->page_size = boot_block->attr.page_size;\n\n\tmsb->pages_in_block = boot_block->attr.block_size * 2;\n\tmsb->block_size = msb->page_size * msb->pages_in_block;\n\n\tif ((size_t)msb->page_size > PAGE_SIZE) {\n\t\t \n\t\tdbg(\"device page %d size isn't supported\", msb->page_size);\n\t\treturn -EINVAL;\n\t}\n\n\tmsb->block_buffer = kzalloc(msb->block_size, GFP_KERNEL);\n\tif (!msb->block_buffer)\n\t\treturn -ENOMEM;\n\n\traw_size_in_megs = (msb->block_size * msb->block_count) >> 20;\n\n\tfor (i = 0; chs_table[i].size; i++) {\n\n\t\tif (chs_table[i].size != raw_size_in_megs)\n\t\t\tcontinue;\n\n\t\tmsb->geometry.cylinders = chs_table[i].cyl;\n\t\tmsb->geometry.heads = chs_table[i].head;\n\t\tmsb->geometry.sectors = chs_table[i].sec;\n\t\tbreak;\n\t}\n\n\tif (boot_block->attr.transfer_supporting == 1)\n\t\tmsb->caps |= MEMSTICK_CAP_PAR4;\n\n\tif (boot_block->attr.device_type & 0x03)\n\t\tmsb->read_only = true;\n\n\tdbg(\"Total block count = %d\", msb->block_count);\n\tdbg(\"Each block consists of %d pages\", msb->pages_in_block);\n\tdbg(\"Page size = %d bytes\", msb->page_size);\n\tdbg(\"Parallel mode supported: %d\", !!(msb->caps & MEMSTICK_CAP_PAR4));\n\tdbg(\"Read only: %d\", msb->read_only);\n\n#if 0\n\t \n\tif (host->caps & msb->caps & MEMSTICK_CAP_PAR4)\n\t\tmsb_switch_to_parallel(msb);\n#endif\n\n\terror = msb_cache_init(msb);\n\tif (error)\n\t\treturn error;\n\n\terror = msb_ftl_initialize(msb);\n\tif (error)\n\t\treturn error;\n\n\n\t \n\terror = msb_read_bad_block_table(msb, 0);\n\n\tif (error && error != -ENOMEM) {\n\t\tdbg(\"failed to read bad block table from primary boot block, trying from backup\");\n\t\terror = msb_read_bad_block_table(msb, 1);\n\t}\n\n\tif (error)\n\t\treturn error;\n\n\t \n\terror = msb_ftl_scan(msb);\n\tif (error) {\n\t\tpr_err(\"Scan of media failed\");\n\t\treturn error;\n\t}\n\n\treturn 0;\n\n}\n\nstatic int msb_do_write_request(struct msb_data *msb, int lba,\n\tint page, struct scatterlist *sg, size_t len, int *sucessfuly_written)\n{\n\tint error = 0;\n\toff_t offset = 0;\n\t*sucessfuly_written = 0;\n\n\twhile (offset < len) {\n\t\tif (page == 0 && len - offset >= msb->block_size) {\n\n\t\t\tif (msb->cache_block_lba == lba)\n\t\t\t\tmsb_cache_discard(msb);\n\n\t\t\tdbg_verbose(\"Writing whole lba %d\", lba);\n\t\t\terror = msb_update_block(msb, lba, sg, offset);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\toffset += msb->block_size;\n\t\t\t*sucessfuly_written += msb->block_size;\n\t\t\tlba++;\n\t\t\tcontinue;\n\t\t}\n\n\t\terror = msb_cache_write(msb, lba, page, false, sg, offset);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\toffset += msb->page_size;\n\t\t*sucessfuly_written += msb->page_size;\n\n\t\tpage++;\n\t\tif (page == msb->pages_in_block) {\n\t\t\tpage = 0;\n\t\t\tlba++;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int msb_do_read_request(struct msb_data *msb, int lba,\n\t\tint page, struct scatterlist *sg, int len, int *sucessfuly_read)\n{\n\tint error = 0;\n\tint offset = 0;\n\t*sucessfuly_read = 0;\n\n\twhile (offset < len) {\n\n\t\terror = msb_cache_read(msb, lba, page, sg, offset);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\toffset += msb->page_size;\n\t\t*sucessfuly_read += msb->page_size;\n\n\t\tpage++;\n\t\tif (page == msb->pages_in_block) {\n\t\t\tpage = 0;\n\t\t\tlba++;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void msb_io_work(struct work_struct *work)\n{\n\tstruct msb_data *msb = container_of(work, struct msb_data, io_work);\n\tint page, error, len;\n\tsector_t lba;\n\tstruct scatterlist *sg = msb->prealloc_sg;\n\tstruct request *req;\n\n\tdbg_verbose(\"IO: work started\");\n\n\twhile (1) {\n\t\tspin_lock_irq(&msb->q_lock);\n\n\t\tif (msb->need_flush_cache) {\n\t\t\tmsb->need_flush_cache = false;\n\t\t\tspin_unlock_irq(&msb->q_lock);\n\t\t\tmsb_cache_flush(msb);\n\t\t\tcontinue;\n\t\t}\n\n\t\treq = msb->req;\n\t\tif (!req) {\n\t\t\tdbg_verbose(\"IO: no more requests exiting\");\n\t\t\tspin_unlock_irq(&msb->q_lock);\n\t\t\treturn;\n\t\t}\n\n\t\tspin_unlock_irq(&msb->q_lock);\n\n\t\t \n\t\tdbg_verbose(\"IO: processing new request\");\n\t\tblk_rq_map_sg(msb->queue, req, sg);\n\n\t\tlba = blk_rq_pos(req);\n\n\t\tsector_div(lba, msb->page_size / 512);\n\t\tpage = sector_div(lba, msb->pages_in_block);\n\n\t\tif (rq_data_dir(msb->req) == READ)\n\t\t\terror = msb_do_read_request(msb, lba, page, sg,\n\t\t\t\tblk_rq_bytes(req), &len);\n\t\telse\n\t\t\terror = msb_do_write_request(msb, lba, page, sg,\n\t\t\t\tblk_rq_bytes(req), &len);\n\n\t\tif (len && !blk_update_request(req, BLK_STS_OK, len)) {\n\t\t\t__blk_mq_end_request(req, BLK_STS_OK);\n\t\t\tspin_lock_irq(&msb->q_lock);\n\t\t\tmsb->req = NULL;\n\t\t\tspin_unlock_irq(&msb->q_lock);\n\t\t}\n\n\t\tif (error && msb->req) {\n\t\t\tblk_status_t ret = errno_to_blk_status(error);\n\n\t\t\tdbg_verbose(\"IO: ending one sector of the request with error\");\n\t\t\tblk_mq_end_request(req, ret);\n\t\t\tspin_lock_irq(&msb->q_lock);\n\t\t\tmsb->req = NULL;\n\t\t\tspin_unlock_irq(&msb->q_lock);\n\t\t}\n\n\t\tif (msb->req)\n\t\t\tdbg_verbose(\"IO: request still pending\");\n\t}\n}\n\nstatic DEFINE_IDR(msb_disk_idr);  \nstatic DEFINE_MUTEX(msb_disk_lock);  \n\nstatic void msb_data_clear(struct msb_data *msb)\n{\n\tkfree(msb->boot_page);\n\tbitmap_free(msb->used_blocks_bitmap);\n\tbitmap_free(msb->erased_blocks_bitmap);\n\tkfree(msb->lba_to_pba_table);\n\tkfree(msb->cache);\n\tmsb->card = NULL;\n}\n\nstatic int msb_bd_getgeo(struct block_device *bdev,\n\t\t\t\t struct hd_geometry *geo)\n{\n\tstruct msb_data *msb = bdev->bd_disk->private_data;\n\t*geo = msb->geometry;\n\treturn 0;\n}\n\nstatic void msb_bd_free_disk(struct gendisk *disk)\n{\n\tstruct msb_data *msb = disk->private_data;\n\n\tmutex_lock(&msb_disk_lock);\n\tidr_remove(&msb_disk_idr, msb->disk_id);\n\tmutex_unlock(&msb_disk_lock);\n\n\tkfree(msb);\n}\n\nstatic blk_status_t msb_queue_rq(struct blk_mq_hw_ctx *hctx,\n\t\t\t\t const struct blk_mq_queue_data *bd)\n{\n\tstruct memstick_dev *card = hctx->queue->queuedata;\n\tstruct msb_data *msb = memstick_get_drvdata(card);\n\tstruct request *req = bd->rq;\n\n\tdbg_verbose(\"Submit request\");\n\n\tspin_lock_irq(&msb->q_lock);\n\n\tif (msb->card_dead) {\n\t\tdbg(\"Refusing requests on removed card\");\n\n\t\tWARN_ON(!msb->io_queue_stopped);\n\n\t\tspin_unlock_irq(&msb->q_lock);\n\t\tblk_mq_start_request(req);\n\t\treturn BLK_STS_IOERR;\n\t}\n\n\tif (msb->req) {\n\t\tspin_unlock_irq(&msb->q_lock);\n\t\treturn BLK_STS_DEV_RESOURCE;\n\t}\n\n\tblk_mq_start_request(req);\n\tmsb->req = req;\n\n\tif (!msb->io_queue_stopped)\n\t\tqueue_work(msb->io_queue, &msb->io_work);\n\n\tspin_unlock_irq(&msb->q_lock);\n\treturn BLK_STS_OK;\n}\n\nstatic int msb_check_card(struct memstick_dev *card)\n{\n\tstruct msb_data *msb = memstick_get_drvdata(card);\n\n\treturn (msb->card_dead == 0);\n}\n\nstatic void msb_stop(struct memstick_dev *card)\n{\n\tstruct msb_data *msb = memstick_get_drvdata(card);\n\tunsigned long flags;\n\n\tdbg(\"Stopping all msblock IO\");\n\n\tblk_mq_stop_hw_queues(msb->queue);\n\tspin_lock_irqsave(&msb->q_lock, flags);\n\tmsb->io_queue_stopped = true;\n\tspin_unlock_irqrestore(&msb->q_lock, flags);\n\n\tdel_timer_sync(&msb->cache_flush_timer);\n\tflush_workqueue(msb->io_queue);\n\n\tspin_lock_irqsave(&msb->q_lock, flags);\n\tif (msb->req) {\n\t\tblk_mq_requeue_request(msb->req, false);\n\t\tmsb->req = NULL;\n\t}\n\tspin_unlock_irqrestore(&msb->q_lock, flags);\n}\n\nstatic void msb_start(struct memstick_dev *card)\n{\n\tstruct msb_data *msb = memstick_get_drvdata(card);\n\tunsigned long flags;\n\n\tdbg(\"Resuming IO from msblock\");\n\n\tmsb_invalidate_reg_window(msb);\n\n\tspin_lock_irqsave(&msb->q_lock, flags);\n\tif (!msb->io_queue_stopped || msb->card_dead) {\n\t\tspin_unlock_irqrestore(&msb->q_lock, flags);\n\t\treturn;\n\t}\n\tspin_unlock_irqrestore(&msb->q_lock, flags);\n\n\t \n\tmsb->need_flush_cache = true;\n\tmsb->io_queue_stopped = false;\n\n\tblk_mq_start_hw_queues(msb->queue);\n\n\tqueue_work(msb->io_queue, &msb->io_work);\n\n}\n\nstatic const struct block_device_operations msb_bdops = {\n\t.owner\t\t= THIS_MODULE,\n\t.getgeo\t\t= msb_bd_getgeo,\n\t.free_disk\t= msb_bd_free_disk, \n};\n\nstatic const struct blk_mq_ops msb_mq_ops = {\n\t.queue_rq\t= msb_queue_rq,\n};\n\n \nstatic int msb_init_disk(struct memstick_dev *card)\n{\n\tstruct msb_data *msb = memstick_get_drvdata(card);\n\tint rc;\n\tunsigned long capacity;\n\n\tmutex_lock(&msb_disk_lock);\n\tmsb->disk_id = idr_alloc(&msb_disk_idr, card, 0, 256, GFP_KERNEL);\n\tmutex_unlock(&msb_disk_lock);\n\n\tif (msb->disk_id  < 0)\n\t\treturn msb->disk_id;\n\n\trc = blk_mq_alloc_sq_tag_set(&msb->tag_set, &msb_mq_ops, 2,\n\t\t\t\t     BLK_MQ_F_SHOULD_MERGE);\n\tif (rc)\n\t\tgoto out_release_id;\n\n\tmsb->disk = blk_mq_alloc_disk(&msb->tag_set, card);\n\tif (IS_ERR(msb->disk)) {\n\t\trc = PTR_ERR(msb->disk);\n\t\tgoto out_free_tag_set;\n\t}\n\tmsb->queue = msb->disk->queue;\n\n\tblk_queue_max_hw_sectors(msb->queue, MS_BLOCK_MAX_PAGES);\n\tblk_queue_max_segments(msb->queue, MS_BLOCK_MAX_SEGS);\n\tblk_queue_max_segment_size(msb->queue,\n\t\t\t\t   MS_BLOCK_MAX_PAGES * msb->page_size);\n\tblk_queue_logical_block_size(msb->queue, msb->page_size);\n\n\tsprintf(msb->disk->disk_name, \"msblk%d\", msb->disk_id);\n\tmsb->disk->fops = &msb_bdops;\n\tmsb->disk->private_data = msb;\n\n\tcapacity = msb->pages_in_block * msb->logical_block_count;\n\tcapacity *= (msb->page_size / 512);\n\tset_capacity(msb->disk, capacity);\n\tdbg(\"Set total disk size to %lu sectors\", capacity);\n\n\tmsb->io_queue = alloc_ordered_workqueue(\"ms_block\", WQ_MEM_RECLAIM);\n\tif (!msb->io_queue) {\n\t\trc = -ENOMEM;\n\t\tgoto out_cleanup_disk;\n\t}\n\n\tINIT_WORK(&msb->io_work, msb_io_work);\n\tsg_init_table(msb->prealloc_sg, MS_BLOCK_MAX_SEGS+1);\n\n\tif (msb->read_only)\n\t\tset_disk_ro(msb->disk, 1);\n\n\tmsb_start(card);\n\trc = device_add_disk(&card->dev, msb->disk, NULL);\n\tif (rc)\n\t\tgoto out_destroy_workqueue;\n\tdbg(\"Disk added\");\n\treturn 0;\n\nout_destroy_workqueue:\n\tdestroy_workqueue(msb->io_queue);\nout_cleanup_disk:\n\tput_disk(msb->disk);\nout_free_tag_set:\n\tblk_mq_free_tag_set(&msb->tag_set);\nout_release_id:\n\tmutex_lock(&msb_disk_lock);\n\tidr_remove(&msb_disk_idr, msb->disk_id);\n\tmutex_unlock(&msb_disk_lock);\n\treturn rc;\n}\n\nstatic int msb_probe(struct memstick_dev *card)\n{\n\tstruct msb_data *msb;\n\tint rc = 0;\n\n\tmsb = kzalloc(sizeof(struct msb_data), GFP_KERNEL);\n\tif (!msb)\n\t\treturn -ENOMEM;\n\tmemstick_set_drvdata(card, msb);\n\tmsb->card = card;\n\tspin_lock_init(&msb->q_lock);\n\n\trc = msb_init_card(card);\n\tif (rc)\n\t\tgoto out_free;\n\n\trc = msb_init_disk(card);\n\tif (!rc) {\n\t\tcard->check = msb_check_card;\n\t\tcard->stop = msb_stop;\n\t\tcard->start = msb_start;\n\t\treturn 0;\n\t}\nout_free:\n\tmemstick_set_drvdata(card, NULL);\n\tmsb_data_clear(msb);\n\tkfree(msb);\n\treturn rc;\n}\n\nstatic void msb_remove(struct memstick_dev *card)\n{\n\tstruct msb_data *msb = memstick_get_drvdata(card);\n\tunsigned long flags;\n\n\tif (!msb->io_queue_stopped)\n\t\tmsb_stop(card);\n\n\tdbg(\"Removing the disk device\");\n\n\t \n\tspin_lock_irqsave(&msb->q_lock, flags);\n\tmsb->card_dead = true;\n\tspin_unlock_irqrestore(&msb->q_lock, flags);\n\tblk_mq_start_hw_queues(msb->queue);\n\n\t \n\tdel_gendisk(msb->disk);\n\tblk_mq_free_tag_set(&msb->tag_set);\n\tmsb->queue = NULL;\n\n\tmutex_lock(&msb_disk_lock);\n\tmsb_data_clear(msb);\n\tmutex_unlock(&msb_disk_lock);\n\n\tput_disk(msb->disk);\n\tmemstick_set_drvdata(card, NULL);\n}\n\n#ifdef CONFIG_PM\n\nstatic int msb_suspend(struct memstick_dev *card, pm_message_t state)\n{\n\tmsb_stop(card);\n\treturn 0;\n}\n\nstatic int msb_resume(struct memstick_dev *card)\n{\n\tstruct msb_data *msb = memstick_get_drvdata(card);\n\tstruct msb_data *new_msb = NULL;\n\tbool card_dead = true;\n\n#ifndef CONFIG_MEMSTICK_UNSAFE_RESUME\n\tmsb->card_dead = true;\n\treturn 0;\n#endif\n\tmutex_lock(&card->host->lock);\n\n\tnew_msb = kzalloc(sizeof(struct msb_data), GFP_KERNEL);\n\tif (!new_msb)\n\t\tgoto out;\n\n\tnew_msb->card = card;\n\tmemstick_set_drvdata(card, new_msb);\n\tspin_lock_init(&new_msb->q_lock);\n\tsg_init_table(msb->prealloc_sg, MS_BLOCK_MAX_SEGS+1);\n\n\tif (msb_init_card(card))\n\t\tgoto out;\n\n\tif (msb->block_size != new_msb->block_size)\n\t\tgoto out;\n\n\tif (memcmp(msb->boot_page, new_msb->boot_page,\n\t\t\t\t\tsizeof(struct ms_boot_page)))\n\t\tgoto out;\n\n\tif (msb->logical_block_count != new_msb->logical_block_count ||\n\t\tmemcmp(msb->lba_to_pba_table, new_msb->lba_to_pba_table,\n\t\t\t\t\t\tmsb->logical_block_count))\n\t\tgoto out;\n\n\tif (msb->block_count != new_msb->block_count ||\n\t    !bitmap_equal(msb->used_blocks_bitmap, new_msb->used_blocks_bitmap,\n\t\t\t\t\t\t\tmsb->block_count))\n\t\tgoto out;\n\n\tcard_dead = false;\nout:\n\tif (card_dead)\n\t\tdbg(\"Card was removed/replaced during suspend\");\n\n\tmsb->card_dead = card_dead;\n\tmemstick_set_drvdata(card, msb);\n\n\tif (new_msb) {\n\t\tmsb_data_clear(new_msb);\n\t\tkfree(new_msb);\n\t}\n\n\tmsb_start(card);\n\tmutex_unlock(&card->host->lock);\n\treturn 0;\n}\n#else\n\n#define msb_suspend NULL\n#define msb_resume NULL\n\n#endif  \n\nstatic struct memstick_device_id msb_id_tbl[] = {\n\t{MEMSTICK_MATCH_ALL, MEMSTICK_TYPE_LEGACY, MEMSTICK_CATEGORY_STORAGE,\n\t MEMSTICK_CLASS_FLASH},\n\n\t{MEMSTICK_MATCH_ALL, MEMSTICK_TYPE_LEGACY, MEMSTICK_CATEGORY_STORAGE,\n\t MEMSTICK_CLASS_ROM},\n\n\t{MEMSTICK_MATCH_ALL, MEMSTICK_TYPE_LEGACY, MEMSTICK_CATEGORY_STORAGE,\n\t MEMSTICK_CLASS_RO},\n\n\t{MEMSTICK_MATCH_ALL, MEMSTICK_TYPE_LEGACY, MEMSTICK_CATEGORY_STORAGE,\n\t MEMSTICK_CLASS_WP},\n\n\t{MEMSTICK_MATCH_ALL, MEMSTICK_TYPE_DUO, MEMSTICK_CATEGORY_STORAGE_DUO,\n\t MEMSTICK_CLASS_DUO},\n\t{}\n};\nMODULE_DEVICE_TABLE(memstick, msb_id_tbl);\n\n\nstatic struct memstick_driver msb_driver = {\n\t.driver = {\n\t\t.name  = DRIVER_NAME,\n\t\t.owner = THIS_MODULE\n\t},\n\t.id_table = msb_id_tbl,\n\t.probe    = msb_probe,\n\t.remove   = msb_remove,\n\t.suspend  = msb_suspend,\n\t.resume   = msb_resume\n};\n\nstatic int __init msb_init(void)\n{\n\tint rc = memstick_register_driver(&msb_driver);\n\n\tif (rc)\n\t\tpr_err(\"failed to register memstick driver (error %d)\\n\", rc);\n\n\treturn rc;\n}\n\nstatic void __exit msb_exit(void)\n{\n\tmemstick_unregister_driver(&msb_driver);\n\tidr_destroy(&msb_disk_idr);\n}\n\nmodule_init(msb_init);\nmodule_exit(msb_exit);\n\nmodule_param(cache_flush_timeout, int, S_IRUGO);\nMODULE_PARM_DESC(cache_flush_timeout,\n\t\t\t\t\"Cache flush timeout in msec (1000 default)\");\nmodule_param(debug, int, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(debug, \"Debug level (0-2)\");\n\nmodule_param(verify_writes, bool, S_IRUGO);\nMODULE_PARM_DESC(verify_writes, \"Read back and check all data that is written\");\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Maxim Levitsky\");\nMODULE_DESCRIPTION(\"Sony MemoryStick block device driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}