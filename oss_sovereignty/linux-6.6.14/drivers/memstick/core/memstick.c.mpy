{
  "module_name": "memstick.c",
  "hash_id": "842ab2b6374603caf605e49cc52772ebe3883f80448d0a6453a96c46165db0a1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/memstick/core/memstick.c",
  "human_readable_source": "\n \n\n#include <linux/memstick.h>\n#include <linux/idr.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n\n#define DRIVER_NAME \"memstick\"\n\nstatic unsigned int cmd_retries = 3;\nmodule_param(cmd_retries, uint, 0644);\n\nstatic struct workqueue_struct *workqueue;\nstatic DEFINE_IDR(memstick_host_idr);\nstatic DEFINE_SPINLOCK(memstick_host_lock);\n\nstatic int memstick_dev_match(struct memstick_dev *card,\n\t\t\t      struct memstick_device_id *id)\n{\n\tif (id->match_flags & MEMSTICK_MATCH_ALL) {\n\t\tif ((id->type == card->id.type)\n\t\t    && (id->category == card->id.category)\n\t\t    && (id->class == card->id.class))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int memstick_bus_match(struct device *dev, struct device_driver *drv)\n{\n\tstruct memstick_dev *card = container_of(dev, struct memstick_dev,\n\t\t\t\t\t\t dev);\n\tstruct memstick_driver *ms_drv = container_of(drv,\n\t\t\t\t\t\t      struct memstick_driver,\n\t\t\t\t\t\t      driver);\n\tstruct memstick_device_id *ids = ms_drv->id_table;\n\n\tif (ids) {\n\t\twhile (ids->match_flags) {\n\t\t\tif (memstick_dev_match(card, ids))\n\t\t\t\treturn 1;\n\t\t\t++ids;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int memstick_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tconst struct memstick_dev *card = container_of_const(dev, struct memstick_dev,\n\t\t\t\t\t\t\t     dev);\n\n\tif (add_uevent_var(env, \"MEMSTICK_TYPE=%02X\", card->id.type))\n\t\treturn -ENOMEM;\n\n\tif (add_uevent_var(env, \"MEMSTICK_CATEGORY=%02X\", card->id.category))\n\t\treturn -ENOMEM;\n\n\tif (add_uevent_var(env, \"MEMSTICK_CLASS=%02X\", card->id.class))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int memstick_device_probe(struct device *dev)\n{\n\tstruct memstick_dev *card = container_of(dev, struct memstick_dev,\n\t\t\t\t\t\t dev);\n\tstruct memstick_driver *drv = container_of(dev->driver,\n\t\t\t\t\t\t   struct memstick_driver,\n\t\t\t\t\t\t   driver);\n\tint rc = -ENODEV;\n\n\tif (dev->driver && drv->probe) {\n\t\trc = drv->probe(card);\n\t\tif (!rc)\n\t\t\tget_device(dev);\n\t}\n\treturn rc;\n}\n\nstatic void memstick_device_remove(struct device *dev)\n{\n\tstruct memstick_dev *card = container_of(dev, struct memstick_dev,\n\t\t\t\t\t\t  dev);\n\tstruct memstick_driver *drv = container_of(dev->driver,\n\t\t\t\t\t\t   struct memstick_driver,\n\t\t\t\t\t\t   driver);\n\n\tif (dev->driver && drv->remove) {\n\t\tdrv->remove(card);\n\t\tcard->dev.driver = NULL;\n\t}\n\n\tput_device(dev);\n}\n\n#ifdef CONFIG_PM\n\nstatic int memstick_device_suspend(struct device *dev, pm_message_t state)\n{\n\tstruct memstick_dev *card = container_of(dev, struct memstick_dev,\n\t\t\t\t\t\t  dev);\n\tstruct memstick_driver *drv = container_of(dev->driver,\n\t\t\t\t\t\t   struct memstick_driver,\n\t\t\t\t\t\t   driver);\n\n\tif (dev->driver && drv->suspend)\n\t\treturn drv->suspend(card, state);\n\treturn 0;\n}\n\nstatic int memstick_device_resume(struct device *dev)\n{\n\tstruct memstick_dev *card = container_of(dev, struct memstick_dev,\n\t\t\t\t\t\t  dev);\n\tstruct memstick_driver *drv = container_of(dev->driver,\n\t\t\t\t\t\t   struct memstick_driver,\n\t\t\t\t\t\t   driver);\n\n\tif (dev->driver && drv->resume)\n\t\treturn drv->resume(card);\n\treturn 0;\n}\n\n#else\n\n#define memstick_device_suspend NULL\n#define memstick_device_resume NULL\n\n#endif  \n\n#define MEMSTICK_ATTR(name, format)                                           \\\nstatic ssize_t name##_show(struct device *dev, struct device_attribute *attr, \\\n\t\t\t    char *buf)                                        \\\n{                                                                             \\\n\tstruct memstick_dev *card = container_of(dev, struct memstick_dev,    \\\n\t\t\t\t\t\t dev);                        \\\n\treturn sprintf(buf, format, card->id.name);                           \\\n}                                                                             \\\nstatic DEVICE_ATTR_RO(name);\n\nMEMSTICK_ATTR(type, \"%02X\");\nMEMSTICK_ATTR(category, \"%02X\");\nMEMSTICK_ATTR(class, \"%02X\");\n\nstatic struct attribute *memstick_dev_attrs[] = {\n\t&dev_attr_type.attr,\n\t&dev_attr_category.attr,\n\t&dev_attr_class.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(memstick_dev);\n\nstatic struct bus_type memstick_bus_type = {\n\t.name           = \"memstick\",\n\t.dev_groups\t= memstick_dev_groups,\n\t.match          = memstick_bus_match,\n\t.uevent         = memstick_uevent,\n\t.probe          = memstick_device_probe,\n\t.remove         = memstick_device_remove,\n\t.suspend        = memstick_device_suspend,\n\t.resume         = memstick_device_resume\n};\n\nstatic void memstick_free(struct device *dev)\n{\n\tstruct memstick_host *host = container_of(dev, struct memstick_host,\n\t\t\t\t\t\t  dev);\n\tkfree(host);\n}\n\nstatic struct class memstick_host_class = {\n\t.name        = \"memstick_host\",\n\t.dev_release = memstick_free\n};\n\nstatic void memstick_free_card(struct device *dev)\n{\n\tstruct memstick_dev *card = container_of(dev, struct memstick_dev,\n\t\t\t\t\t\t dev);\n\tkfree(card);\n}\n\nstatic int memstick_dummy_check(struct memstick_dev *card)\n{\n\treturn 0;\n}\n\n \nvoid memstick_detect_change(struct memstick_host *host)\n{\n\tqueue_work(workqueue, &host->media_checker);\n}\nEXPORT_SYMBOL(memstick_detect_change);\n\n \nint memstick_next_req(struct memstick_host *host, struct memstick_request **mrq)\n{\n\tint rc = -ENXIO;\n\n\tif ((*mrq) && (*mrq)->error && host->retries) {\n\t\t(*mrq)->error = rc;\n\t\thost->retries--;\n\t\treturn 0;\n\t}\n\n\tif (host->card && host->card->next_request)\n\t\trc = host->card->next_request(host->card, mrq);\n\n\tif (!rc)\n\t\thost->retries = cmd_retries > 1 ? cmd_retries - 1 : 1;\n\telse\n\t\t*mrq = NULL;\n\n\treturn rc;\n}\nEXPORT_SYMBOL(memstick_next_req);\n\n \nvoid memstick_new_req(struct memstick_host *host)\n{\n\tif (host->card) {\n\t\thost->retries = cmd_retries;\n\t\treinit_completion(&host->card->mrq_complete);\n\t\thost->request(host);\n\t}\n}\nEXPORT_SYMBOL(memstick_new_req);\n\n \nvoid memstick_init_req_sg(struct memstick_request *mrq, unsigned char tpc,\n\t\t\t  const struct scatterlist *sg)\n{\n\tmrq->tpc = tpc;\n\tif (tpc & 8)\n\t\tmrq->data_dir = WRITE;\n\telse\n\t\tmrq->data_dir = READ;\n\n\tmrq->sg = *sg;\n\tmrq->long_data = 1;\n\n\tif (tpc == MS_TPC_SET_CMD || tpc == MS_TPC_EX_SET_CMD)\n\t\tmrq->need_card_int = 1;\n\telse\n\t\tmrq->need_card_int = 0;\n}\nEXPORT_SYMBOL(memstick_init_req_sg);\n\n \nvoid memstick_init_req(struct memstick_request *mrq, unsigned char tpc,\n\t\t       const void *buf, size_t length)\n{\n\tmrq->tpc = tpc;\n\tif (tpc & 8)\n\t\tmrq->data_dir = WRITE;\n\telse\n\t\tmrq->data_dir = READ;\n\n\tmrq->data_len = length > sizeof(mrq->data) ? sizeof(mrq->data) : length;\n\tif (mrq->data_dir == WRITE)\n\t\tmemcpy(mrq->data, buf, mrq->data_len);\n\n\tmrq->long_data = 0;\n\n\tif (tpc == MS_TPC_SET_CMD || tpc == MS_TPC_EX_SET_CMD)\n\t\tmrq->need_card_int = 1;\n\telse\n\t\tmrq->need_card_int = 0;\n}\nEXPORT_SYMBOL(memstick_init_req);\n\n \n\nstatic int h_memstick_read_dev_id(struct memstick_dev *card,\n\t\t\t\t  struct memstick_request **mrq)\n{\n\tstruct ms_id_register id_reg;\n\n\tif (!(*mrq)) {\n\t\tmemstick_init_req(&card->current_mrq, MS_TPC_READ_REG, &id_reg,\n\t\t\t\t  sizeof(struct ms_id_register));\n\t\t*mrq = &card->current_mrq;\n\t\treturn 0;\n\t}\n\tif (!(*mrq)->error) {\n\t\tmemcpy(&id_reg, (*mrq)->data, sizeof(id_reg));\n\t\tcard->id.match_flags = MEMSTICK_MATCH_ALL;\n\t\tcard->id.type = id_reg.type;\n\t\tcard->id.category = id_reg.category;\n\t\tcard->id.class = id_reg.class;\n\t\tdev_dbg(&card->dev, \"if_mode = %02x\\n\", id_reg.if_mode);\n\t}\n\tcomplete(&card->mrq_complete);\n\treturn -EAGAIN;\n}\n\nstatic int h_memstick_set_rw_addr(struct memstick_dev *card,\n\t\t\t\t  struct memstick_request **mrq)\n{\n\tif (!(*mrq)) {\n\t\tmemstick_init_req(&card->current_mrq, MS_TPC_SET_RW_REG_ADRS,\n\t\t\t\t  (char *)&card->reg_addr,\n\t\t\t\t  sizeof(card->reg_addr));\n\t\t*mrq = &card->current_mrq;\n\t\treturn 0;\n\t} else {\n\t\tcomplete(&card->mrq_complete);\n\t\treturn -EAGAIN;\n\t}\n}\n\n \nint memstick_set_rw_addr(struct memstick_dev *card)\n{\n\tcard->next_request = h_memstick_set_rw_addr;\n\tmemstick_new_req(card->host);\n\twait_for_completion(&card->mrq_complete);\n\n\treturn card->current_mrq.error;\n}\nEXPORT_SYMBOL(memstick_set_rw_addr);\n\nstatic struct memstick_dev *memstick_alloc_card(struct memstick_host *host)\n{\n\tstruct memstick_dev *card = kzalloc(sizeof(struct memstick_dev),\n\t\t\t\t\t    GFP_KERNEL);\n\tstruct memstick_dev *old_card = host->card;\n\tstruct ms_id_register id_reg;\n\n\tif (card) {\n\t\tcard->host = host;\n\t\tdev_set_name(&card->dev, \"%s\", dev_name(&host->dev));\n\t\tcard->dev.parent = &host->dev;\n\t\tcard->dev.bus = &memstick_bus_type;\n\t\tcard->dev.release = memstick_free_card;\n\t\tcard->check = memstick_dummy_check;\n\n\t\tcard->reg_addr.r_offset = offsetof(struct ms_register, id);\n\t\tcard->reg_addr.r_length = sizeof(id_reg);\n\t\tcard->reg_addr.w_offset = offsetof(struct ms_register, id);\n\t\tcard->reg_addr.w_length = sizeof(id_reg);\n\n\t\tinit_completion(&card->mrq_complete);\n\n\t\thost->card = card;\n\t\tif (memstick_set_rw_addr(card))\n\t\t\tgoto err_out;\n\n\t\tcard->next_request = h_memstick_read_dev_id;\n\t\tmemstick_new_req(host);\n\t\twait_for_completion(&card->mrq_complete);\n\n\t\tif (card->current_mrq.error)\n\t\t\tgoto err_out;\n\t}\n\thost->card = old_card;\n\treturn card;\nerr_out:\n\thost->card = old_card;\n\tkfree_const(card->dev.kobj.name);\n\tkfree(card);\n\treturn NULL;\n}\n\nstatic int memstick_power_on(struct memstick_host *host)\n{\n\tint rc = host->set_param(host, MEMSTICK_POWER, MEMSTICK_POWER_ON);\n\n\tif (!rc)\n\t\trc = host->set_param(host, MEMSTICK_INTERFACE, MEMSTICK_SERIAL);\n\n\treturn rc;\n}\n\nstatic void memstick_check(struct work_struct *work)\n{\n\tstruct memstick_host *host = container_of(work, struct memstick_host,\n\t\t\t\t\t\t  media_checker);\n\tstruct memstick_dev *card;\n\n\tdev_dbg(&host->dev, \"memstick_check started\\n\");\n\tpm_runtime_get_noresume(host->dev.parent);\n\tmutex_lock(&host->lock);\n\tif (!host->card) {\n\t\tif (memstick_power_on(host))\n\t\t\tgoto out_power_off;\n\t} else if (host->card->stop)\n\t\thost->card->stop(host->card);\n\n\tif (host->removing)\n\t\tgoto out_power_off;\n\n\tcard = memstick_alloc_card(host);\n\n\tif (!card) {\n\t\tif (host->card) {\n\t\t\tdevice_unregister(&host->card->dev);\n\t\t\thost->card = NULL;\n\t\t}\n\t} else {\n\t\tdev_dbg(&host->dev, \"new card %02x, %02x, %02x\\n\",\n\t\t\tcard->id.type, card->id.category, card->id.class);\n\t\tif (host->card) {\n\t\t\tif (memstick_set_rw_addr(host->card)\n\t\t\t    || !memstick_dev_match(host->card, &card->id)\n\t\t\t    || !(host->card->check(host->card))) {\n\t\t\t\tdevice_unregister(&host->card->dev);\n\t\t\t\thost->card = NULL;\n\t\t\t} else if (host->card->start)\n\t\t\t\thost->card->start(host->card);\n\t\t}\n\n\t\tif (!host->card) {\n\t\t\thost->card = card;\n\t\t\tif (device_register(&card->dev)) {\n\t\t\t\tput_device(&card->dev);\n\t\t\t\thost->card = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tkfree_const(card->dev.kobj.name);\n\t\t\tkfree(card);\n\t\t}\n\t}\n\nout_power_off:\n\tif (!host->card)\n\t\thost->set_param(host, MEMSTICK_POWER, MEMSTICK_POWER_OFF);\n\n\tmutex_unlock(&host->lock);\n\tpm_runtime_put(host->dev.parent);\n\tdev_dbg(&host->dev, \"memstick_check finished\\n\");\n}\n\n \nstruct memstick_host *memstick_alloc_host(unsigned int extra,\n\t\t\t\t\t  struct device *dev)\n{\n\tstruct memstick_host *host;\n\n\thost = kzalloc(sizeof(struct memstick_host) + extra, GFP_KERNEL);\n\tif (host) {\n\t\tmutex_init(&host->lock);\n\t\tINIT_WORK(&host->media_checker, memstick_check);\n\t\thost->dev.class = &memstick_host_class;\n\t\thost->dev.parent = dev;\n\t\tdevice_initialize(&host->dev);\n\t}\n\treturn host;\n}\nEXPORT_SYMBOL(memstick_alloc_host);\n\n \nint memstick_add_host(struct memstick_host *host)\n{\n\tint rc;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock(&memstick_host_lock);\n\n\trc = idr_alloc(&memstick_host_idr, host, 0, 0, GFP_NOWAIT);\n\tif (rc >= 0)\n\t\thost->id = rc;\n\n\tspin_unlock(&memstick_host_lock);\n\tidr_preload_end();\n\tif (rc < 0)\n\t\treturn rc;\n\n\tdev_set_name(&host->dev, \"memstick%u\", host->id);\n\n\trc = device_add(&host->dev);\n\tif (rc) {\n\t\tspin_lock(&memstick_host_lock);\n\t\tidr_remove(&memstick_host_idr, host->id);\n\t\tspin_unlock(&memstick_host_lock);\n\t\treturn rc;\n\t}\n\n\thost->set_param(host, MEMSTICK_POWER, MEMSTICK_POWER_OFF);\n\tmemstick_detect_change(host);\n\treturn 0;\n}\nEXPORT_SYMBOL(memstick_add_host);\n\n \nvoid memstick_remove_host(struct memstick_host *host)\n{\n\thost->removing = 1;\n\tflush_workqueue(workqueue);\n\tmutex_lock(&host->lock);\n\tif (host->card)\n\t\tdevice_unregister(&host->card->dev);\n\thost->card = NULL;\n\thost->set_param(host, MEMSTICK_POWER, MEMSTICK_POWER_OFF);\n\tmutex_unlock(&host->lock);\n\n\tspin_lock(&memstick_host_lock);\n\tidr_remove(&memstick_host_idr, host->id);\n\tspin_unlock(&memstick_host_lock);\n\tdevice_del(&host->dev);\n}\nEXPORT_SYMBOL(memstick_remove_host);\n\n \nvoid memstick_free_host(struct memstick_host *host)\n{\n\tmutex_destroy(&host->lock);\n\tput_device(&host->dev);\n}\nEXPORT_SYMBOL(memstick_free_host);\n\n \nvoid memstick_suspend_host(struct memstick_host *host)\n{\n\tmutex_lock(&host->lock);\n\thost->set_param(host, MEMSTICK_POWER, MEMSTICK_POWER_OFF);\n\tmutex_unlock(&host->lock);\n}\nEXPORT_SYMBOL(memstick_suspend_host);\n\n \nvoid memstick_resume_host(struct memstick_host *host)\n{\n\tint rc = 0;\n\n\tmutex_lock(&host->lock);\n\tif (host->card)\n\t\trc = memstick_power_on(host);\n\tmutex_unlock(&host->lock);\n\n\tif (!rc)\n\t\tmemstick_detect_change(host);\n}\nEXPORT_SYMBOL(memstick_resume_host);\n\nint memstick_register_driver(struct memstick_driver *drv)\n{\n\tdrv->driver.bus = &memstick_bus_type;\n\n\treturn driver_register(&drv->driver);\n}\nEXPORT_SYMBOL(memstick_register_driver);\n\nvoid memstick_unregister_driver(struct memstick_driver *drv)\n{\n\tdriver_unregister(&drv->driver);\n}\nEXPORT_SYMBOL(memstick_unregister_driver);\n\n\nstatic int __init memstick_init(void)\n{\n\tint rc;\n\n\tworkqueue = create_freezable_workqueue(\"kmemstick\");\n\tif (!workqueue)\n\t\treturn -ENOMEM;\n\n\trc = bus_register(&memstick_bus_type);\n\tif (rc)\n\t\tgoto error_destroy_workqueue;\n\n\trc = class_register(&memstick_host_class);\n\tif (rc)\n\t\tgoto error_bus_unregister;\n\n\treturn 0;\n\nerror_bus_unregister:\n\tbus_unregister(&memstick_bus_type);\nerror_destroy_workqueue:\n\tdestroy_workqueue(workqueue);\n\n\treturn rc;\n}\n\nstatic void __exit memstick_exit(void)\n{\n\tclass_unregister(&memstick_host_class);\n\tbus_unregister(&memstick_bus_type);\n\tdestroy_workqueue(workqueue);\n\tidr_destroy(&memstick_host_idr);\n}\n\nmodule_init(memstick_init);\nmodule_exit(memstick_exit);\n\nMODULE_AUTHOR(\"Alex Dubov\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Sony MemoryStick core driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}