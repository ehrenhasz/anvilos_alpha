{
  "module_name": "tifm_ms.c",
  "hash_id": "4006fa83cc5bdf72a7b59bdf5ecfaf787820d23c31931d20da59a2c615db549a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/memstick/host/tifm_ms.c",
  "human_readable_source": "\n \n\n#include <linux/tifm.h>\n#include <linux/memstick.h>\n#include <linux/highmem.h>\n#include <linux/scatterlist.h>\n#include <linux/log2.h>\n#include <linux/module.h>\n#include <asm/io.h>\n\n#define DRIVER_NAME \"tifm_ms\"\n\nstatic bool no_dma;\nmodule_param(no_dma, bool, 0644);\n\n \n\n#define TIFM_MS_STAT_DRQ     0x04000\n#define TIFM_MS_STAT_MSINT   0x02000\n#define TIFM_MS_STAT_RDY     0x01000\n#define TIFM_MS_STAT_CRC     0x00200\n#define TIFM_MS_STAT_TOE     0x00100\n#define TIFM_MS_STAT_EMP     0x00020\n#define TIFM_MS_STAT_FUL     0x00010\n#define TIFM_MS_STAT_CED     0x00008\n#define TIFM_MS_STAT_ERR     0x00004\n#define TIFM_MS_STAT_BRQ     0x00002\n#define TIFM_MS_STAT_CNK     0x00001\n\n#define TIFM_MS_SYS_DMA      0x10000\n#define TIFM_MS_SYS_RESET    0x08000\n#define TIFM_MS_SYS_SRAC     0x04000\n#define TIFM_MS_SYS_INTEN    0x02000\n#define TIFM_MS_SYS_NOCRC    0x01000\n#define TIFM_MS_SYS_INTCLR   0x00800\n#define TIFM_MS_SYS_MSIEN    0x00400\n#define TIFM_MS_SYS_FCLR     0x00200\n#define TIFM_MS_SYS_FDIR     0x00100\n#define TIFM_MS_SYS_DAM      0x00080\n#define TIFM_MS_SYS_DRM      0x00040\n#define TIFM_MS_SYS_DRQSL    0x00020\n#define TIFM_MS_SYS_REI      0x00010\n#define TIFM_MS_SYS_REO      0x00008\n#define TIFM_MS_SYS_BSY_MASK 0x00007\n\n#define TIFM_MS_SYS_FIFO     (TIFM_MS_SYS_INTEN | TIFM_MS_SYS_MSIEN \\\n\t\t\t      | TIFM_MS_SYS_FCLR | TIFM_MS_SYS_BSY_MASK)\n\n \nenum {\n\tCMD_READY  = 0x01,\n\tFIFO_READY = 0x02,\n\tCARD_INT   = 0x04\n};\n\nstruct tifm_ms {\n\tstruct tifm_dev         *dev;\n\tstruct timer_list       timer;\n\tstruct memstick_request *req;\n\tstruct tasklet_struct   notify;\n\tunsigned int            mode_mask;\n\tunsigned int            block_pos;\n\tunsigned long           timeout_jiffies;\n\tunsigned char           eject:1,\n\t\t\t\tuse_dma:1;\n\tunsigned char           cmd_flags;\n\tunsigned char           io_pos;\n\tunsigned int            io_word;\n};\n\nstatic unsigned int tifm_ms_read_data(struct tifm_ms *host,\n\t\t\t\t      unsigned char *buf, unsigned int length)\n{\n\tstruct tifm_dev *sock = host->dev;\n\tunsigned int off = 0;\n\n\twhile (host->io_pos && length) {\n\t\tbuf[off++] = host->io_word & 0xff;\n\t\thost->io_word >>= 8;\n\t\tlength--;\n\t\thost->io_pos--;\n\t}\n\n\tif (!length)\n\t\treturn off;\n\n\twhile (!(TIFM_MS_STAT_EMP & readl(sock->addr + SOCK_MS_STATUS))) {\n\t\tif (length < 4)\n\t\t\tbreak;\n\t\t*(unsigned int *)(buf + off) = __raw_readl(sock->addr\n\t\t\t\t\t\t\t   + SOCK_MS_DATA);\n\t\tlength -= 4;\n\t\toff += 4;\n\t}\n\n\tif (length\n\t    && !(TIFM_MS_STAT_EMP & readl(sock->addr + SOCK_MS_STATUS))) {\n\t\thost->io_word = readl(sock->addr + SOCK_MS_DATA);\n\t\tfor (host->io_pos = 4; host->io_pos; --host->io_pos) {\n\t\t\tbuf[off++] = host->io_word & 0xff;\n\t\t\thost->io_word >>= 8;\n\t\t\tlength--;\n\t\t\tif (!length)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn off;\n}\n\nstatic unsigned int tifm_ms_write_data(struct tifm_ms *host,\n\t\t\t\t       unsigned char *buf, unsigned int length)\n{\n\tstruct tifm_dev *sock = host->dev;\n\tunsigned int off = 0;\n\n\tif (host->io_pos) {\n\t\twhile (host->io_pos < 4 && length) {\n\t\t\thost->io_word |=  buf[off++] << (host->io_pos * 8);\n\t\t\thost->io_pos++;\n\t\t\tlength--;\n\t\t}\n\t}\n\n\tif (host->io_pos == 4\n\t    && !(TIFM_MS_STAT_FUL & readl(sock->addr + SOCK_MS_STATUS))) {\n\t\twritel(TIFM_MS_SYS_FDIR | readl(sock->addr + SOCK_MS_SYSTEM),\n\t\t       sock->addr + SOCK_MS_SYSTEM);\n\t\twritel(host->io_word, sock->addr + SOCK_MS_DATA);\n\t\thost->io_pos = 0;\n\t\thost->io_word = 0;\n\t} else if (host->io_pos) {\n\t\treturn off;\n\t}\n\n\tif (!length)\n\t\treturn off;\n\n\twhile (!(TIFM_MS_STAT_FUL & readl(sock->addr + SOCK_MS_STATUS))) {\n\t\tif (length < 4)\n\t\t\tbreak;\n\t\twritel(TIFM_MS_SYS_FDIR | readl(sock->addr + SOCK_MS_SYSTEM),\n\t\t       sock->addr + SOCK_MS_SYSTEM);\n\t\t__raw_writel(*(unsigned int *)(buf + off),\n\t\t\t     sock->addr + SOCK_MS_DATA);\n\t\tlength -= 4;\n\t\toff += 4;\n\t}\n\n\tswitch (length) {\n\tcase 3:\n\t\thost->io_word |= buf[off + 2] << 16;\n\t\thost->io_pos++;\n\t\tfallthrough;\n\tcase 2:\n\t\thost->io_word |= buf[off + 1] << 8;\n\t\thost->io_pos++;\n\t\tfallthrough;\n\tcase 1:\n\t\thost->io_word |= buf[off];\n\t\thost->io_pos++;\n\t}\n\n\toff += host->io_pos;\n\n\treturn off;\n}\n\nstatic unsigned int tifm_ms_transfer_data(struct tifm_ms *host)\n{\n\tstruct tifm_dev *sock = host->dev;\n\tunsigned int length;\n\tunsigned int off;\n\tunsigned int t_size, p_cnt;\n\tunsigned char *buf;\n\tstruct page *pg;\n\tunsigned long flags = 0;\n\n\tif (host->req->long_data) {\n\t\tlength = host->req->sg.length - host->block_pos;\n\t\toff = host->req->sg.offset + host->block_pos;\n\t} else {\n\t\tlength = host->req->data_len - host->block_pos;\n\t\toff = 0;\n\t}\n\tdev_dbg(&sock->dev, \"fifo data transfer, %d, %d\\n\", length,\n\t\thost->block_pos);\n\n\twhile (length) {\n\t\tunsigned int p_off;\n\n\t\tif (host->req->long_data) {\n\t\t\tpg = nth_page(sg_page(&host->req->sg),\n\t\t\t\t      off >> PAGE_SHIFT);\n\t\t\tp_off = offset_in_page(off);\n\t\t\tp_cnt = PAGE_SIZE - p_off;\n\t\t\tp_cnt = min(p_cnt, length);\n\n\t\t\tlocal_irq_save(flags);\n\t\t\tbuf = kmap_atomic(pg) + p_off;\n\t\t} else {\n\t\t\tbuf = host->req->data + host->block_pos;\n\t\t\tp_cnt = host->req->data_len - host->block_pos;\n\t\t}\n\n\t\tt_size = host->req->data_dir == WRITE\n\t\t\t ? tifm_ms_write_data(host, buf, p_cnt)\n\t\t\t : tifm_ms_read_data(host, buf, p_cnt);\n\n\t\tif (host->req->long_data) {\n\t\t\tkunmap_atomic(buf - p_off);\n\t\t\tlocal_irq_restore(flags);\n\t\t}\n\n\t\tif (!t_size)\n\t\t\tbreak;\n\t\thost->block_pos += t_size;\n\t\tlength -= t_size;\n\t\toff += t_size;\n\t}\n\n\tdev_dbg(&sock->dev, \"fifo data transfer, %d remaining\\n\", length);\n\tif (!length && (host->req->data_dir == WRITE)) {\n\t\tif (host->io_pos) {\n\t\t\twritel(TIFM_MS_SYS_FDIR\n\t\t\t       | readl(sock->addr + SOCK_MS_SYSTEM),\n\t\t\t       sock->addr + SOCK_MS_SYSTEM);\n\t\t\twritel(host->io_word, sock->addr + SOCK_MS_DATA);\n\t\t}\n\t\twritel(TIFM_MS_SYS_FDIR\n\t\t       | readl(sock->addr + SOCK_MS_SYSTEM),\n\t\t       sock->addr + SOCK_MS_SYSTEM);\n\t\twritel(0, sock->addr + SOCK_MS_DATA);\n\t} else {\n\t\treadl(sock->addr + SOCK_MS_DATA);\n\t}\n\n\treturn length;\n}\n\nstatic int tifm_ms_issue_cmd(struct tifm_ms *host)\n{\n\tstruct tifm_dev *sock = host->dev;\n\tunsigned int data_len, cmd, sys_param;\n\n\thost->cmd_flags = 0;\n\thost->block_pos = 0;\n\thost->io_pos = 0;\n\thost->io_word = 0;\n\thost->cmd_flags = 0;\n\n\thost->use_dma = !no_dma;\n\n\tif (host->req->long_data) {\n\t\tdata_len = host->req->sg.length;\n\t\tif (!is_power_of_2(data_len))\n\t\t\thost->use_dma = 0;\n\t} else {\n\t\tdata_len = host->req->data_len;\n\t\thost->use_dma = 0;\n\t}\n\n\twritel(TIFM_FIFO_INT_SETALL,\n\t       sock->addr + SOCK_DMA_FIFO_INT_ENABLE_CLEAR);\n\twritel(TIFM_FIFO_ENABLE,\n\t       sock->addr + SOCK_FIFO_CONTROL);\n\n\tif (host->use_dma) {\n\t\tif (1 != tifm_map_sg(sock, &host->req->sg, 1,\n\t\t\t\t     host->req->data_dir == READ\n\t\t\t\t     ? DMA_FROM_DEVICE\n\t\t\t\t     : DMA_TO_DEVICE)) {\n\t\t\thost->req->error = -ENOMEM;\n\t\t\treturn host->req->error;\n\t\t}\n\t\tdata_len = sg_dma_len(&host->req->sg);\n\n\t\twritel(ilog2(data_len) - 2,\n\t\t       sock->addr + SOCK_FIFO_PAGE_SIZE);\n\t\twritel(TIFM_FIFO_INTMASK,\n\t\t       sock->addr + SOCK_DMA_FIFO_INT_ENABLE_SET);\n\t\tsys_param = TIFM_DMA_EN | (1 << 8);\n\t\tif (host->req->data_dir == WRITE)\n\t\t\tsys_param |= TIFM_DMA_TX;\n\n\t\twritel(TIFM_FIFO_INTMASK,\n\t\t       sock->addr + SOCK_DMA_FIFO_INT_ENABLE_SET);\n\n\t\twritel(sg_dma_address(&host->req->sg),\n\t\t       sock->addr + SOCK_DMA_ADDRESS);\n\t\twritel(sys_param, sock->addr + SOCK_DMA_CONTROL);\n\t} else {\n\t\twritel(host->mode_mask | TIFM_MS_SYS_FIFO,\n\t\t       sock->addr + SOCK_MS_SYSTEM);\n\n\t\twritel(TIFM_FIFO_MORE,\n\t\t       sock->addr + SOCK_DMA_FIFO_INT_ENABLE_SET);\n\t}\n\n\tmod_timer(&host->timer, jiffies + host->timeout_jiffies);\n\twritel(TIFM_CTRL_LED | readl(sock->addr + SOCK_CONTROL),\n\t       sock->addr + SOCK_CONTROL);\n\thost->req->error = 0;\n\n\tsys_param = readl(sock->addr + SOCK_MS_SYSTEM);\n\tsys_param |= TIFM_MS_SYS_INTCLR;\n\n\tif (host->use_dma)\n\t\tsys_param |= TIFM_MS_SYS_DMA;\n\telse\n\t\tsys_param &= ~TIFM_MS_SYS_DMA;\n\n\twritel(sys_param, sock->addr + SOCK_MS_SYSTEM);\n\n\tcmd = (host->req->tpc & 0xf) << 12;\n\tcmd |= data_len;\n\twritel(cmd, sock->addr + SOCK_MS_COMMAND);\n\n\tdev_dbg(&sock->dev, \"executing TPC %x, %x\\n\", cmd, sys_param);\n\treturn 0;\n}\n\nstatic void tifm_ms_complete_cmd(struct tifm_ms *host)\n{\n\tstruct tifm_dev *sock = host->dev;\n\tstruct memstick_host *msh = tifm_get_drvdata(sock);\n\tint rc;\n\n\tdel_timer(&host->timer);\n\n\thost->req->int_reg = readl(sock->addr + SOCK_MS_STATUS) & 0xff;\n\thost->req->int_reg = (host->req->int_reg & 1)\n\t\t\t     | ((host->req->int_reg << 4) & 0xe0);\n\n\twritel(TIFM_FIFO_INT_SETALL,\n\t       sock->addr + SOCK_DMA_FIFO_INT_ENABLE_CLEAR);\n\twritel(TIFM_DMA_RESET, sock->addr + SOCK_DMA_CONTROL);\n\n\tif (host->use_dma) {\n\t\ttifm_unmap_sg(sock, &host->req->sg, 1,\n\t\t\t      host->req->data_dir == READ\n\t\t\t      ? DMA_FROM_DEVICE\n\t\t\t      : DMA_TO_DEVICE);\n\t}\n\n\twritel((~TIFM_CTRL_LED) & readl(sock->addr + SOCK_CONTROL),\n\t       sock->addr + SOCK_CONTROL);\n\n\tdev_dbg(&sock->dev, \"TPC complete\\n\");\n\tdo {\n\t\trc = memstick_next_req(msh, &host->req);\n\t} while (!rc && tifm_ms_issue_cmd(host));\n}\n\nstatic int tifm_ms_check_status(struct tifm_ms *host)\n{\n\tif (!host->req->error) {\n\t\tif (!(host->cmd_flags & CMD_READY))\n\t\t\treturn 1;\n\t\tif (!(host->cmd_flags & FIFO_READY))\n\t\t\treturn 1;\n\t\tif (host->req->need_card_int\n\t\t    && !(host->cmd_flags & CARD_INT))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nstatic void tifm_ms_data_event(struct tifm_dev *sock)\n{\n\tstruct tifm_ms *host;\n\tunsigned int fifo_status = 0, host_status = 0;\n\tint rc = 1;\n\n\tspin_lock(&sock->lock);\n\thost = memstick_priv((struct memstick_host *)tifm_get_drvdata(sock));\n\tfifo_status = readl(sock->addr + SOCK_DMA_FIFO_STATUS);\n\thost_status = readl(sock->addr + SOCK_MS_STATUS);\n\tdev_dbg(&sock->dev,\n\t\t\"data event: fifo_status %x, host_status %x, flags %x\\n\",\n\t\tfifo_status, host_status, host->cmd_flags);\n\n\tif (host->req) {\n\t\tif (host->use_dma && (fifo_status & 1)) {\n\t\t\thost->cmd_flags |= FIFO_READY;\n\t\t\trc = tifm_ms_check_status(host);\n\t\t}\n\t\tif (!host->use_dma && (fifo_status & TIFM_FIFO_MORE)) {\n\t\t\tif (!tifm_ms_transfer_data(host)) {\n\t\t\t\thost->cmd_flags |= FIFO_READY;\n\t\t\t\trc = tifm_ms_check_status(host);\n\t\t\t}\n\t\t}\n\t}\n\n\twritel(fifo_status, sock->addr + SOCK_DMA_FIFO_STATUS);\n\tif (!rc)\n\t\ttifm_ms_complete_cmd(host);\n\n\tspin_unlock(&sock->lock);\n}\n\n\n \nstatic void tifm_ms_card_event(struct tifm_dev *sock)\n{\n\tstruct tifm_ms *host;\n\tunsigned int host_status = 0;\n\tint rc = 1;\n\n\tspin_lock(&sock->lock);\n\thost = memstick_priv((struct memstick_host *)tifm_get_drvdata(sock));\n\thost_status = readl(sock->addr + SOCK_MS_STATUS);\n\tdev_dbg(&sock->dev, \"host event: host_status %x, flags %x\\n\",\n\t\thost_status, host->cmd_flags);\n\n\tif (host->req) {\n\t\tif (host_status & TIFM_MS_STAT_TOE)\n\t\t\thost->req->error = -ETIME;\n\t\telse if (host_status & TIFM_MS_STAT_CRC)\n\t\t\thost->req->error = -EILSEQ;\n\n\t\tif (host_status & TIFM_MS_STAT_RDY)\n\t\t\thost->cmd_flags |= CMD_READY;\n\n\t\tif (host_status & TIFM_MS_STAT_MSINT)\n\t\t\thost->cmd_flags |= CARD_INT;\n\n\t\trc = tifm_ms_check_status(host);\n\n\t}\n\n\twritel(TIFM_MS_SYS_INTCLR | readl(sock->addr + SOCK_MS_SYSTEM),\n\t       sock->addr + SOCK_MS_SYSTEM);\n\n\tif (!rc)\n\t\ttifm_ms_complete_cmd(host);\n\n\tspin_unlock(&sock->lock);\n\treturn;\n}\n\nstatic void tifm_ms_req_tasklet(unsigned long data)\n{\n\tstruct memstick_host *msh = (struct memstick_host *)data;\n\tstruct tifm_ms *host = memstick_priv(msh);\n\tstruct tifm_dev *sock = host->dev;\n\tunsigned long flags;\n\tint rc;\n\n\tspin_lock_irqsave(&sock->lock, flags);\n\tif (!host->req) {\n\t\tif (host->eject) {\n\t\t\tdo {\n\t\t\t\trc = memstick_next_req(msh, &host->req);\n\t\t\t\tif (!rc)\n\t\t\t\t\thost->req->error = -ETIME;\n\t\t\t} while (!rc);\n\t\t\tspin_unlock_irqrestore(&sock->lock, flags);\n\t\t\treturn;\n\t\t}\n\n\t\tdo {\n\t\t\trc = memstick_next_req(msh, &host->req);\n\t\t} while (!rc && tifm_ms_issue_cmd(host));\n\t}\n\tspin_unlock_irqrestore(&sock->lock, flags);\n}\n\nstatic void tifm_ms_dummy_submit(struct memstick_host *msh)\n{\n\treturn;\n}\n\nstatic void tifm_ms_submit_req(struct memstick_host *msh)\n{\n\tstruct tifm_ms *host = memstick_priv(msh);\n\n\ttasklet_schedule(&host->notify);\n}\n\nstatic int tifm_ms_set_param(struct memstick_host *msh,\n\t\t\t     enum memstick_param param,\n\t\t\t     int value)\n{\n\tstruct tifm_ms *host = memstick_priv(msh);\n\tstruct tifm_dev *sock = host->dev;\n\n\tswitch (param) {\n\tcase MEMSTICK_POWER:\n\t\t \n\t\tif (value == MEMSTICK_POWER_ON) {\n\t\t\thost->mode_mask = TIFM_MS_SYS_SRAC | TIFM_MS_SYS_REI;\n\t\t\twritel(TIFM_MS_SYS_RESET, sock->addr + SOCK_MS_SYSTEM);\n\t\t\twritel(TIFM_MS_SYS_FCLR | TIFM_MS_SYS_INTCLR,\n\t\t\t       sock->addr + SOCK_MS_SYSTEM);\n\t\t\twritel(0xffffffff, sock->addr + SOCK_MS_STATUS);\n\t\t} else if (value == MEMSTICK_POWER_OFF) {\n\t\t\twritel(TIFM_MS_SYS_FCLR | TIFM_MS_SYS_INTCLR,\n\t\t\t       sock->addr + SOCK_MS_SYSTEM);\n\t\t\twritel(0xffffffff, sock->addr + SOCK_MS_STATUS);\n\t\t} else\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase MEMSTICK_INTERFACE:\n\t\tif (value == MEMSTICK_SERIAL) {\n\t\t\thost->mode_mask = TIFM_MS_SYS_SRAC | TIFM_MS_SYS_REI;\n\t\t\twritel((~TIFM_CTRL_FAST_CLK)\n\t\t\t       & readl(sock->addr + SOCK_CONTROL),\n\t\t\t       sock->addr + SOCK_CONTROL);\n\t\t} else if (value == MEMSTICK_PAR4) {\n\t\t\thost->mode_mask = 0;\n\t\t\twritel(TIFM_CTRL_FAST_CLK\n\t\t\t       | readl(sock->addr + SOCK_CONTROL),\n\t\t\t       sock->addr + SOCK_CONTROL);\n\t\t} else\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void tifm_ms_abort(struct timer_list *t)\n{\n\tstruct tifm_ms *host = from_timer(host, t, timer);\n\n\tdev_dbg(&host->dev->dev, \"status %x\\n\",\n\t\treadl(host->dev->addr + SOCK_MS_STATUS));\n\tprintk(KERN_ERR\n\t       \"%s : card failed to respond for a long period of time \"\n\t       \"(%x, %x)\\n\",\n\t       dev_name(&host->dev->dev), host->req ? host->req->tpc : 0,\n\t       host->cmd_flags);\n\n\ttifm_eject(host->dev);\n}\n\nstatic int tifm_ms_probe(struct tifm_dev *sock)\n{\n\tstruct memstick_host *msh;\n\tstruct tifm_ms *host;\n\tint rc = -EIO;\n\n\tif (!(TIFM_SOCK_STATE_OCCUPIED\n\t      & readl(sock->addr + SOCK_PRESENT_STATE))) {\n\t\tprintk(KERN_WARNING \"%s : card gone, unexpectedly\\n\",\n\t\t       dev_name(&sock->dev));\n\t\treturn rc;\n\t}\n\n\tmsh = memstick_alloc_host(sizeof(struct tifm_ms), &sock->dev);\n\tif (!msh)\n\t\treturn -ENOMEM;\n\n\thost = memstick_priv(msh);\n\ttifm_set_drvdata(sock, msh);\n\thost->dev = sock;\n\thost->timeout_jiffies = msecs_to_jiffies(1000);\n\n\ttimer_setup(&host->timer, tifm_ms_abort, 0);\n\ttasklet_init(&host->notify, tifm_ms_req_tasklet, (unsigned long)msh);\n\n\tmsh->request = tifm_ms_submit_req;\n\tmsh->set_param = tifm_ms_set_param;\n\tsock->card_event = tifm_ms_card_event;\n\tsock->data_event = tifm_ms_data_event;\n\tif (tifm_has_ms_pif(sock))\n\t\tmsh->caps |= MEMSTICK_CAP_PAR4;\n\n\trc = memstick_add_host(msh);\n\tif (!rc)\n\t\treturn 0;\n\n\tmemstick_free_host(msh);\n\treturn rc;\n}\n\nstatic void tifm_ms_remove(struct tifm_dev *sock)\n{\n\tstruct memstick_host *msh = tifm_get_drvdata(sock);\n\tstruct tifm_ms *host = memstick_priv(msh);\n\tint rc = 0;\n\tunsigned long flags;\n\n\tmsh->request = tifm_ms_dummy_submit;\n\ttasklet_kill(&host->notify);\n\tspin_lock_irqsave(&sock->lock, flags);\n\thost->eject = 1;\n\tif (host->req) {\n\t\tdel_timer(&host->timer);\n\t\twritel(TIFM_FIFO_INT_SETALL,\n\t\t       sock->addr + SOCK_DMA_FIFO_INT_ENABLE_CLEAR);\n\t\twritel(TIFM_DMA_RESET, sock->addr + SOCK_DMA_CONTROL);\n\t\tif (host->use_dma)\n\t\t\ttifm_unmap_sg(sock, &host->req->sg, 1,\n\t\t\t\t      host->req->data_dir == READ\n\t\t\t\t      ? DMA_TO_DEVICE\n\t\t\t\t      : DMA_FROM_DEVICE);\n\t\thost->req->error = -ETIME;\n\n\t\tdo {\n\t\t\trc = memstick_next_req(msh, &host->req);\n\t\t\tif (!rc)\n\t\t\t\thost->req->error = -ETIME;\n\t\t} while (!rc);\n\t}\n\tspin_unlock_irqrestore(&sock->lock, flags);\n\n\tmemstick_remove_host(msh);\n\tmemstick_free_host(msh);\n}\n\n#ifdef CONFIG_PM\n\nstatic int tifm_ms_suspend(struct tifm_dev *sock, pm_message_t state)\n{\n\tstruct memstick_host *msh = tifm_get_drvdata(sock);\n\n\tmemstick_suspend_host(msh);\n\treturn 0;\n}\n\nstatic int tifm_ms_resume(struct tifm_dev *sock)\n{\n\tstruct memstick_host *msh = tifm_get_drvdata(sock);\n\n\tmemstick_resume_host(msh);\n\treturn 0;\n}\n\n#else\n\n#define tifm_ms_suspend NULL\n#define tifm_ms_resume NULL\n\n#endif  \n\nstatic struct tifm_device_id tifm_ms_id_tbl[] = {\n\t{ TIFM_TYPE_MS }, { 0 }\n};\n\nstatic struct tifm_driver tifm_ms_driver = {\n\t.driver = {\n\t\t.name  = DRIVER_NAME,\n\t\t.owner = THIS_MODULE\n\t},\n\t.id_table = tifm_ms_id_tbl,\n\t.probe    = tifm_ms_probe,\n\t.remove   = tifm_ms_remove,\n\t.suspend  = tifm_ms_suspend,\n\t.resume   = tifm_ms_resume\n};\n\nstatic int __init tifm_ms_init(void)\n{\n\treturn tifm_register_driver(&tifm_ms_driver);\n}\n\nstatic void __exit tifm_ms_exit(void)\n{\n\ttifm_unregister_driver(&tifm_ms_driver);\n}\n\nMODULE_AUTHOR(\"Alex Dubov\");\nMODULE_DESCRIPTION(\"TI FlashMedia MemoryStick driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(tifm, tifm_ms_id_tbl);\n\nmodule_init(tifm_ms_init);\nmodule_exit(tifm_ms_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}