{
  "module_name": "jmb38x_ms.c",
  "hash_id": "5c950d77a88a924049d60d4e6e19a0bb2cd3284d2b0abceda9a93aeee9783ac2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/memstick/host/jmb38x_ms.c",
  "human_readable_source": "\n \n\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/dma-mapping.h>\n#include <linux/delay.h>\n#include <linux/highmem.h>\n#include <linux/memstick.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#define DRIVER_NAME \"jmb38x_ms\"\n\nstatic bool no_dma;\nmodule_param(no_dma, bool, 0644);\n\nenum {\n\tDMA_ADDRESS       = 0x00,\n\tBLOCK             = 0x04,\n\tDMA_CONTROL       = 0x08,\n\tTPC_P0            = 0x0c,\n\tTPC_P1            = 0x10,\n\tTPC               = 0x14,\n\tHOST_CONTROL      = 0x18,\n\tDATA              = 0x1c,\n\tSTATUS            = 0x20,\n\tINT_STATUS        = 0x24,\n\tINT_STATUS_ENABLE = 0x28,\n\tINT_SIGNAL_ENABLE = 0x2c,\n\tTIMER             = 0x30,\n\tTIMER_CONTROL     = 0x34,\n\tPAD_OUTPUT_ENABLE = 0x38,\n\tPAD_PU_PD         = 0x3c,\n\tCLOCK_DELAY       = 0x40,\n\tADMA_ADDRESS      = 0x44,\n\tCLOCK_CONTROL     = 0x48,\n\tLED_CONTROL       = 0x4c,\n\tVERSION           = 0x50\n};\n\nstruct jmb38x_ms_host {\n\tstruct jmb38x_ms        *chip;\n\tvoid __iomem            *addr;\n\tspinlock_t              lock;\n\tstruct tasklet_struct   notify;\n\tint                     id;\n\tchar                    host_id[32];\n\tint                     irq;\n\tunsigned int            block_pos;\n\tunsigned long           timeout_jiffies;\n\tstruct timer_list       timer;\n\tstruct memstick_host\t*msh;\n\tstruct memstick_request *req;\n\tunsigned char           cmd_flags;\n\tunsigned char           io_pos;\n\tunsigned char           ifmode;\n\tunsigned int            io_word[2];\n};\n\nstruct jmb38x_ms {\n\tstruct pci_dev        *pdev;\n\tint                   host_cnt;\n\tstruct memstick_host  *hosts[];\n};\n\n#define BLOCK_COUNT_MASK       0xffff0000\n#define BLOCK_SIZE_MASK        0x00000fff\n\n#define DMA_CONTROL_ENABLE     0x00000001\n\n#define TPC_DATA_SEL           0x00008000\n#define TPC_DIR                0x00004000\n#define TPC_WAIT_INT           0x00002000\n#define TPC_GET_INT            0x00000800\n#define TPC_CODE_SZ_MASK       0x00000700\n#define TPC_DATA_SZ_MASK       0x00000007\n\n#define HOST_CONTROL_TDELAY_EN 0x00040000\n#define HOST_CONTROL_HW_OC_P   0x00010000\n#define HOST_CONTROL_RESET_REQ 0x00008000\n#define HOST_CONTROL_REI       0x00004000\n#define HOST_CONTROL_LED       0x00000400\n#define HOST_CONTROL_FAST_CLK  0x00000200\n#define HOST_CONTROL_RESET     0x00000100\n#define HOST_CONTROL_POWER_EN  0x00000080\n#define HOST_CONTROL_CLOCK_EN  0x00000040\n#define HOST_CONTROL_REO       0x00000008\n#define HOST_CONTROL_IF_SHIFT  4\n\n#define HOST_CONTROL_IF_SERIAL 0x0\n#define HOST_CONTROL_IF_PAR4   0x1\n#define HOST_CONTROL_IF_PAR8   0x3\n\n#define STATUS_BUSY             0x00080000\n#define STATUS_MS_DAT7          0x00040000\n#define STATUS_MS_DAT6          0x00020000\n#define STATUS_MS_DAT5          0x00010000\n#define STATUS_MS_DAT4          0x00008000\n#define STATUS_MS_DAT3          0x00004000\n#define STATUS_MS_DAT2          0x00002000\n#define STATUS_MS_DAT1          0x00001000\n#define STATUS_MS_DAT0          0x00000800\n#define STATUS_HAS_MEDIA        0x00000400\n#define STATUS_FIFO_EMPTY       0x00000200\n#define STATUS_FIFO_FULL        0x00000100\n#define STATUS_MS_CED           0x00000080\n#define STATUS_MS_ERR           0x00000040\n#define STATUS_MS_BRQ           0x00000020\n#define STATUS_MS_CNK           0x00000001\n\n#define INT_STATUS_TPC_ERR      0x00080000\n#define INT_STATUS_CRC_ERR      0x00040000\n#define INT_STATUS_TIMER_TO     0x00020000\n#define INT_STATUS_HSK_TO       0x00010000\n#define INT_STATUS_ANY_ERR      0x00008000\n#define INT_STATUS_FIFO_WRDY    0x00000080\n#define INT_STATUS_FIFO_RRDY    0x00000040\n#define INT_STATUS_MEDIA_OUT    0x00000010\n#define INT_STATUS_MEDIA_IN     0x00000008\n#define INT_STATUS_DMA_BOUNDARY 0x00000004\n#define INT_STATUS_EOTRAN       0x00000002\n#define INT_STATUS_EOTPC        0x00000001\n\n#define INT_STATUS_ALL          0x000f801f\n\n#define PAD_OUTPUT_ENABLE_MS  0x0F3F\n\n#define PAD_PU_PD_OFF         0x7FFF0000\n#define PAD_PU_PD_ON_MS_SOCK0 0x5f8f0000\n#define PAD_PU_PD_ON_MS_SOCK1 0x0f0f0000\n\n#define CLOCK_CONTROL_BY_MMIO 0x00000008\n#define CLOCK_CONTROL_40MHZ   0x00000001\n#define CLOCK_CONTROL_50MHZ   0x00000002\n#define CLOCK_CONTROL_60MHZ   0x00000010\n#define CLOCK_CONTROL_62_5MHZ 0x00000004\n#define CLOCK_CONTROL_OFF     0x00000000\n\n#define PCI_CTL_CLOCK_DLY_ADDR   0x000000b0\n\nenum {\n\tCMD_READY    = 0x01,\n\tFIFO_READY   = 0x02,\n\tREG_DATA     = 0x04,\n\tDMA_DATA     = 0x08\n};\n\nstatic unsigned int jmb38x_ms_read_data(struct jmb38x_ms_host *host,\n\t\t\t\t\tunsigned char *buf, unsigned int length)\n{\n\tunsigned int off = 0;\n\n\twhile (host->io_pos && length) {\n\t\tbuf[off++] = host->io_word[0] & 0xff;\n\t\thost->io_word[0] >>= 8;\n\t\tlength--;\n\t\thost->io_pos--;\n\t}\n\n\tif (!length)\n\t\treturn off;\n\n\twhile (!(STATUS_FIFO_EMPTY & readl(host->addr + STATUS))) {\n\t\tif (length < 4)\n\t\t\tbreak;\n\t\t*(unsigned int *)(buf + off) = __raw_readl(host->addr + DATA);\n\t\tlength -= 4;\n\t\toff += 4;\n\t}\n\n\tif (length\n\t    && !(STATUS_FIFO_EMPTY & readl(host->addr + STATUS))) {\n\t\thost->io_word[0] = readl(host->addr + DATA);\n\t\tfor (host->io_pos = 4; host->io_pos; --host->io_pos) {\n\t\t\tbuf[off++] = host->io_word[0] & 0xff;\n\t\t\thost->io_word[0] >>= 8;\n\t\t\tlength--;\n\t\t\tif (!length)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn off;\n}\n\nstatic unsigned int jmb38x_ms_read_reg_data(struct jmb38x_ms_host *host,\n\t\t\t\t\t    unsigned char *buf,\n\t\t\t\t\t    unsigned int length)\n{\n\tunsigned int off = 0;\n\n\twhile (host->io_pos > 4 && length) {\n\t\tbuf[off++] = host->io_word[0] & 0xff;\n\t\thost->io_word[0] >>= 8;\n\t\tlength--;\n\t\thost->io_pos--;\n\t}\n\n\tif (!length)\n\t\treturn off;\n\n\twhile (host->io_pos && length) {\n\t\tbuf[off++] = host->io_word[1] & 0xff;\n\t\thost->io_word[1] >>= 8;\n\t\tlength--;\n\t\thost->io_pos--;\n\t}\n\n\treturn off;\n}\n\nstatic unsigned int jmb38x_ms_write_data(struct jmb38x_ms_host *host,\n\t\t\t\t\t unsigned char *buf,\n\t\t\t\t\t unsigned int length)\n{\n\tunsigned int off = 0;\n\n\tif (host->io_pos) {\n\t\twhile (host->io_pos < 4 && length) {\n\t\t\thost->io_word[0] |=  buf[off++] << (host->io_pos * 8);\n\t\t\thost->io_pos++;\n\t\t\tlength--;\n\t\t}\n\t}\n\n\tif (host->io_pos == 4\n\t    && !(STATUS_FIFO_FULL & readl(host->addr + STATUS))) {\n\t\twritel(host->io_word[0], host->addr + DATA);\n\t\thost->io_pos = 0;\n\t\thost->io_word[0] = 0;\n\t} else if (host->io_pos) {\n\t\treturn off;\n\t}\n\n\tif (!length)\n\t\treturn off;\n\n\twhile (!(STATUS_FIFO_FULL & readl(host->addr + STATUS))) {\n\t\tif (length < 4)\n\t\t\tbreak;\n\n\t\t__raw_writel(*(unsigned int *)(buf + off),\n\t\t\t     host->addr + DATA);\n\t\tlength -= 4;\n\t\toff += 4;\n\t}\n\n\tswitch (length) {\n\tcase 3:\n\t\thost->io_word[0] |= buf[off + 2] << 16;\n\t\thost->io_pos++;\n\t\tfallthrough;\n\tcase 2:\n\t\thost->io_word[0] |= buf[off + 1] << 8;\n\t\thost->io_pos++;\n\t\tfallthrough;\n\tcase 1:\n\t\thost->io_word[0] |= buf[off];\n\t\thost->io_pos++;\n\t}\n\n\toff += host->io_pos;\n\n\treturn off;\n}\n\nstatic unsigned int jmb38x_ms_write_reg_data(struct jmb38x_ms_host *host,\n\t\t\t\t\t     unsigned char *buf,\n\t\t\t\t\t     unsigned int length)\n{\n\tunsigned int off = 0;\n\n\twhile (host->io_pos < 4 && length) {\n\t\thost->io_word[0] &= ~(0xff << (host->io_pos * 8));\n\t\thost->io_word[0] |=  buf[off++] << (host->io_pos * 8);\n\t\thost->io_pos++;\n\t\tlength--;\n\t}\n\n\tif (!length)\n\t\treturn off;\n\n\twhile (host->io_pos < 8 && length) {\n\t\thost->io_word[1] &= ~(0xff << (host->io_pos * 8));\n\t\thost->io_word[1] |=  buf[off++] << (host->io_pos * 8);\n\t\thost->io_pos++;\n\t\tlength--;\n\t}\n\n\treturn off;\n}\n\nstatic int jmb38x_ms_transfer_data(struct jmb38x_ms_host *host)\n{\n\tunsigned int length;\n\tunsigned int off;\n\tunsigned int t_size, p_cnt;\n\tunsigned char *buf;\n\tstruct page *pg;\n\tunsigned long flags = 0;\n\n\tif (host->req->long_data) {\n\t\tlength = host->req->sg.length - host->block_pos;\n\t\toff = host->req->sg.offset + host->block_pos;\n\t} else {\n\t\tlength = host->req->data_len - host->block_pos;\n\t\toff = 0;\n\t}\n\n\twhile (length) {\n\t\tunsigned int p_off;\n\n\t\tif (host->req->long_data) {\n\t\t\tpg = nth_page(sg_page(&host->req->sg),\n\t\t\t\t      off >> PAGE_SHIFT);\n\t\t\tp_off = offset_in_page(off);\n\t\t\tp_cnt = PAGE_SIZE - p_off;\n\t\t\tp_cnt = min(p_cnt, length);\n\n\t\t\tlocal_irq_save(flags);\n\t\t\tbuf = kmap_atomic(pg) + p_off;\n\t\t} else {\n\t\t\tbuf = host->req->data + host->block_pos;\n\t\t\tp_cnt = host->req->data_len - host->block_pos;\n\t\t}\n\n\t\tif (host->req->data_dir == WRITE)\n\t\t\tt_size = !(host->cmd_flags & REG_DATA)\n\t\t\t\t ? jmb38x_ms_write_data(host, buf, p_cnt)\n\t\t\t\t : jmb38x_ms_write_reg_data(host, buf, p_cnt);\n\t\telse\n\t\t\tt_size = !(host->cmd_flags & REG_DATA)\n\t\t\t\t ? jmb38x_ms_read_data(host, buf, p_cnt)\n\t\t\t\t : jmb38x_ms_read_reg_data(host, buf, p_cnt);\n\n\t\tif (host->req->long_data) {\n\t\t\tkunmap_atomic(buf - p_off);\n\t\t\tlocal_irq_restore(flags);\n\t\t}\n\n\t\tif (!t_size)\n\t\t\tbreak;\n\t\thost->block_pos += t_size;\n\t\tlength -= t_size;\n\t\toff += t_size;\n\t}\n\n\tif (!length && host->req->data_dir == WRITE) {\n\t\tif (host->cmd_flags & REG_DATA) {\n\t\t\twritel(host->io_word[0], host->addr + TPC_P0);\n\t\t\twritel(host->io_word[1], host->addr + TPC_P1);\n\t\t} else if (host->io_pos) {\n\t\t\twritel(host->io_word[0], host->addr + DATA);\n\t\t}\n\t}\n\n\treturn length;\n}\n\nstatic int jmb38x_ms_issue_cmd(struct memstick_host *msh)\n{\n\tstruct jmb38x_ms_host *host = memstick_priv(msh);\n\tunsigned int data_len, cmd, t_val;\n\n\tif (!(STATUS_HAS_MEDIA & readl(host->addr + STATUS))) {\n\t\tdev_dbg(&msh->dev, \"no media status\\n\");\n\t\thost->req->error = -ETIME;\n\t\treturn host->req->error;\n\t}\n\n\tdev_dbg(&msh->dev, \"control %08x\\n\", readl(host->addr + HOST_CONTROL));\n\tdev_dbg(&msh->dev, \"status %08x\\n\", readl(host->addr + INT_STATUS));\n\tdev_dbg(&msh->dev, \"hstatus %08x\\n\", readl(host->addr + STATUS));\n\n\thost->cmd_flags = 0;\n\thost->block_pos = 0;\n\thost->io_pos = 0;\n\thost->io_word[0] = 0;\n\thost->io_word[1] = 0;\n\n\tcmd = host->req->tpc << 16;\n\tcmd |= TPC_DATA_SEL;\n\n\tif (host->req->data_dir == READ)\n\t\tcmd |= TPC_DIR;\n\n\tif (host->req->need_card_int) {\n\t\tif (host->ifmode == MEMSTICK_SERIAL)\n\t\t\tcmd |= TPC_GET_INT;\n\t\telse\n\t\t\tcmd |= TPC_WAIT_INT;\n\t}\n\n\tif (!no_dma)\n\t\thost->cmd_flags |= DMA_DATA;\n\n\tif (host->req->long_data) {\n\t\tdata_len = host->req->sg.length;\n\t} else {\n\t\tdata_len = host->req->data_len;\n\t\thost->cmd_flags &= ~DMA_DATA;\n\t}\n\n\tif (data_len <= 8) {\n\t\tcmd &= ~(TPC_DATA_SEL | 0xf);\n\t\thost->cmd_flags |= REG_DATA;\n\t\tcmd |= data_len & 0xf;\n\t\thost->cmd_flags &= ~DMA_DATA;\n\t}\n\n\tif (host->cmd_flags & DMA_DATA) {\n\t\tif (1 != dma_map_sg(&host->chip->pdev->dev, &host->req->sg, 1,\n\t\t\t\t    host->req->data_dir == READ\n\t\t\t\t    ? DMA_FROM_DEVICE\n\t\t\t\t    : DMA_TO_DEVICE)) {\n\t\t\thost->req->error = -ENOMEM;\n\t\t\treturn host->req->error;\n\t\t}\n\t\tdata_len = sg_dma_len(&host->req->sg);\n\t\twritel(sg_dma_address(&host->req->sg),\n\t\t       host->addr + DMA_ADDRESS);\n\t\twritel(((1 << 16) & BLOCK_COUNT_MASK)\n\t\t       | (data_len & BLOCK_SIZE_MASK),\n\t\t       host->addr + BLOCK);\n\t\twritel(DMA_CONTROL_ENABLE, host->addr + DMA_CONTROL);\n\t} else if (!(host->cmd_flags & REG_DATA)) {\n\t\twritel(((1 << 16) & BLOCK_COUNT_MASK)\n\t\t       | (data_len & BLOCK_SIZE_MASK),\n\t\t       host->addr + BLOCK);\n\t\tt_val = readl(host->addr + INT_STATUS_ENABLE);\n\t\tt_val |= host->req->data_dir == READ\n\t\t\t ? INT_STATUS_FIFO_RRDY\n\t\t\t : INT_STATUS_FIFO_WRDY;\n\n\t\twritel(t_val, host->addr + INT_STATUS_ENABLE);\n\t\twritel(t_val, host->addr + INT_SIGNAL_ENABLE);\n\t} else {\n\t\tcmd &= ~(TPC_DATA_SEL | 0xf);\n\t\thost->cmd_flags |= REG_DATA;\n\t\tcmd |= data_len & 0xf;\n\n\t\tif (host->req->data_dir == WRITE) {\n\t\t\tjmb38x_ms_transfer_data(host);\n\t\t\twritel(host->io_word[0], host->addr + TPC_P0);\n\t\t\twritel(host->io_word[1], host->addr + TPC_P1);\n\t\t}\n\t}\n\n\tmod_timer(&host->timer, jiffies + host->timeout_jiffies);\n\twritel(HOST_CONTROL_LED | readl(host->addr + HOST_CONTROL),\n\t       host->addr + HOST_CONTROL);\n\thost->req->error = 0;\n\n\twritel(cmd, host->addr + TPC);\n\tdev_dbg(&msh->dev, \"executing TPC %08x, len %x\\n\", cmd, data_len);\n\n\treturn 0;\n}\n\nstatic void jmb38x_ms_complete_cmd(struct memstick_host *msh, int last)\n{\n\tstruct jmb38x_ms_host *host = memstick_priv(msh);\n\tunsigned int t_val = 0;\n\tint rc;\n\n\tdel_timer(&host->timer);\n\n\tdev_dbg(&msh->dev, \"c control %08x\\n\",\n\t\treadl(host->addr + HOST_CONTROL));\n\tdev_dbg(&msh->dev, \"c status %08x\\n\",\n\t\treadl(host->addr + INT_STATUS));\n\tdev_dbg(&msh->dev, \"c hstatus %08x\\n\", readl(host->addr + STATUS));\n\n\thost->req->int_reg = readl(host->addr + STATUS) & 0xff;\n\n\twritel(0, host->addr + BLOCK);\n\twritel(0, host->addr + DMA_CONTROL);\n\n\tif (host->cmd_flags & DMA_DATA) {\n\t\tdma_unmap_sg(&host->chip->pdev->dev, &host->req->sg, 1,\n\t\t\t     host->req->data_dir == READ\n\t\t\t     ? DMA_FROM_DEVICE : DMA_TO_DEVICE);\n\t} else {\n\t\tt_val = readl(host->addr + INT_STATUS_ENABLE);\n\t\tif (host->req->data_dir == READ)\n\t\t\tt_val &= ~INT_STATUS_FIFO_RRDY;\n\t\telse\n\t\t\tt_val &= ~INT_STATUS_FIFO_WRDY;\n\n\t\twritel(t_val, host->addr + INT_STATUS_ENABLE);\n\t\twritel(t_val, host->addr + INT_SIGNAL_ENABLE);\n\t}\n\n\twritel((~HOST_CONTROL_LED) & readl(host->addr + HOST_CONTROL),\n\t       host->addr + HOST_CONTROL);\n\n\tif (!last) {\n\t\tdo {\n\t\t\trc = memstick_next_req(msh, &host->req);\n\t\t} while (!rc && jmb38x_ms_issue_cmd(msh));\n\t} else {\n\t\tdo {\n\t\t\trc = memstick_next_req(msh, &host->req);\n\t\t\tif (!rc)\n\t\t\t\thost->req->error = -ETIME;\n\t\t} while (!rc);\n\t}\n}\n\nstatic irqreturn_t jmb38x_ms_isr(int irq, void *dev_id)\n{\n\tstruct memstick_host *msh = dev_id;\n\tstruct jmb38x_ms_host *host = memstick_priv(msh);\n\tunsigned int irq_status;\n\n\tspin_lock(&host->lock);\n\tirq_status = readl(host->addr + INT_STATUS);\n\tdev_dbg(&host->chip->pdev->dev, \"irq_status = %08x\\n\", irq_status);\n\tif (irq_status == 0 || irq_status == (~0)) {\n\t\tspin_unlock(&host->lock);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (host->req) {\n\t\tif (irq_status & INT_STATUS_ANY_ERR) {\n\t\t\tif (irq_status & INT_STATUS_CRC_ERR)\n\t\t\t\thost->req->error = -EILSEQ;\n\t\t\telse if (irq_status & INT_STATUS_TPC_ERR) {\n\t\t\t\tdev_dbg(&host->chip->pdev->dev, \"TPC_ERR\\n\");\n\t\t\t\tjmb38x_ms_complete_cmd(msh, 0);\n\t\t\t} else\n\t\t\t\thost->req->error = -ETIME;\n\t\t} else {\n\t\t\tif (host->cmd_flags & DMA_DATA) {\n\t\t\t\tif (irq_status & INT_STATUS_EOTRAN)\n\t\t\t\t\thost->cmd_flags |= FIFO_READY;\n\t\t\t} else {\n\t\t\t\tif (irq_status & (INT_STATUS_FIFO_RRDY\n\t\t\t\t\t\t  | INT_STATUS_FIFO_WRDY))\n\t\t\t\t\tjmb38x_ms_transfer_data(host);\n\n\t\t\t\tif (irq_status & INT_STATUS_EOTRAN) {\n\t\t\t\t\tjmb38x_ms_transfer_data(host);\n\t\t\t\t\thost->cmd_flags |= FIFO_READY;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (irq_status & INT_STATUS_EOTPC) {\n\t\t\t\thost->cmd_flags |= CMD_READY;\n\t\t\t\tif (host->cmd_flags & REG_DATA) {\n\t\t\t\t\tif (host->req->data_dir == READ) {\n\t\t\t\t\t\thost->io_word[0]\n\t\t\t\t\t\t\t= readl(host->addr\n\t\t\t\t\t\t\t\t+ TPC_P0);\n\t\t\t\t\t\thost->io_word[1]\n\t\t\t\t\t\t\t= readl(host->addr\n\t\t\t\t\t\t\t\t+ TPC_P1);\n\t\t\t\t\t\thost->io_pos = 8;\n\n\t\t\t\t\t\tjmb38x_ms_transfer_data(host);\n\t\t\t\t\t}\n\t\t\t\t\thost->cmd_flags |= FIFO_READY;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (irq_status & (INT_STATUS_MEDIA_IN | INT_STATUS_MEDIA_OUT)) {\n\t\tdev_dbg(&host->chip->pdev->dev, \"media changed\\n\");\n\t\tmemstick_detect_change(msh);\n\t}\n\n\twritel(irq_status, host->addr + INT_STATUS);\n\n\tif (host->req\n\t    && (((host->cmd_flags & CMD_READY)\n\t\t && (host->cmd_flags & FIFO_READY))\n\t\t|| host->req->error))\n\t\tjmb38x_ms_complete_cmd(msh, 0);\n\n\tspin_unlock(&host->lock);\n\treturn IRQ_HANDLED;\n}\n\nstatic void jmb38x_ms_abort(struct timer_list *t)\n{\n\tstruct jmb38x_ms_host *host = from_timer(host, t, timer);\n\tstruct memstick_host *msh = host->msh;\n\tunsigned long flags;\n\n\tdev_dbg(&host->chip->pdev->dev, \"abort\\n\");\n\tspin_lock_irqsave(&host->lock, flags);\n\tif (host->req) {\n\t\thost->req->error = -ETIME;\n\t\tjmb38x_ms_complete_cmd(msh, 0);\n\t}\n\tspin_unlock_irqrestore(&host->lock, flags);\n}\n\nstatic void jmb38x_ms_req_tasklet(unsigned long data)\n{\n\tstruct memstick_host *msh = (struct memstick_host *)data;\n\tstruct jmb38x_ms_host *host = memstick_priv(msh);\n\tunsigned long flags;\n\tint rc;\n\n\tspin_lock_irqsave(&host->lock, flags);\n\tif (!host->req) {\n\t\tdo {\n\t\t\trc = memstick_next_req(msh, &host->req);\n\t\t\tdev_dbg(&host->chip->pdev->dev, \"tasklet req %d\\n\", rc);\n\t\t} while (!rc && jmb38x_ms_issue_cmd(msh));\n\t}\n\tspin_unlock_irqrestore(&host->lock, flags);\n}\n\nstatic void jmb38x_ms_dummy_submit(struct memstick_host *msh)\n{\n\treturn;\n}\n\nstatic void jmb38x_ms_submit_req(struct memstick_host *msh)\n{\n\tstruct jmb38x_ms_host *host = memstick_priv(msh);\n\n\ttasklet_schedule(&host->notify);\n}\n\nstatic int jmb38x_ms_reset(struct jmb38x_ms_host *host)\n{\n\tint cnt;\n\n\twritel(HOST_CONTROL_RESET_REQ | HOST_CONTROL_CLOCK_EN\n\t       | readl(host->addr + HOST_CONTROL),\n\t       host->addr + HOST_CONTROL);\n\n\tfor (cnt = 0; cnt < 20; ++cnt) {\n\t\tif (!(HOST_CONTROL_RESET_REQ\n\t\t      & readl(host->addr + HOST_CONTROL)))\n\t\t\tgoto reset_next;\n\n\t\tndelay(20);\n\t}\n\tdev_dbg(&host->chip->pdev->dev, \"reset_req timeout\\n\");\n\nreset_next:\n\twritel(HOST_CONTROL_RESET | HOST_CONTROL_CLOCK_EN\n\t       | readl(host->addr + HOST_CONTROL),\n\t       host->addr + HOST_CONTROL);\n\n\tfor (cnt = 0; cnt < 20; ++cnt) {\n\t\tif (!(HOST_CONTROL_RESET\n\t\t      & readl(host->addr + HOST_CONTROL)))\n\t\t\tgoto reset_ok;\n\n\t\tndelay(20);\n\t}\n\tdev_dbg(&host->chip->pdev->dev, \"reset timeout\\n\");\n\treturn -EIO;\n\nreset_ok:\n\twritel(INT_STATUS_ALL, host->addr + INT_SIGNAL_ENABLE);\n\twritel(INT_STATUS_ALL, host->addr + INT_STATUS_ENABLE);\n\treturn 0;\n}\n\nstatic int jmb38x_ms_set_param(struct memstick_host *msh,\n\t\t\t       enum memstick_param param,\n\t\t\t       int value)\n{\n\tstruct jmb38x_ms_host *host = memstick_priv(msh);\n\tunsigned int host_ctl = readl(host->addr + HOST_CONTROL);\n\tunsigned int clock_ctl = CLOCK_CONTROL_BY_MMIO, clock_delay = 0;\n\tint rc = 0;\n\n\tswitch (param) {\n\tcase MEMSTICK_POWER:\n\t\tif (value == MEMSTICK_POWER_ON) {\n\t\t\trc = jmb38x_ms_reset(host);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\thost_ctl = 7;\n\t\t\thost_ctl |= HOST_CONTROL_POWER_EN\n\t\t\t\t | HOST_CONTROL_CLOCK_EN;\n\t\t\twritel(host_ctl, host->addr + HOST_CONTROL);\n\n\t\t\twritel(host->id ? PAD_PU_PD_ON_MS_SOCK1\n\t\t\t\t\t: PAD_PU_PD_ON_MS_SOCK0,\n\t\t\t       host->addr + PAD_PU_PD);\n\n\t\t\twritel(PAD_OUTPUT_ENABLE_MS,\n\t\t\t       host->addr + PAD_OUTPUT_ENABLE);\n\n\t\t\tmsleep(10);\n\t\t\tdev_dbg(&host->chip->pdev->dev, \"power on\\n\");\n\t\t} else if (value == MEMSTICK_POWER_OFF) {\n\t\t\thost_ctl &= ~(HOST_CONTROL_POWER_EN\n\t\t\t\t      | HOST_CONTROL_CLOCK_EN);\n\t\t\twritel(host_ctl, host->addr +  HOST_CONTROL);\n\t\t\twritel(0, host->addr + PAD_OUTPUT_ENABLE);\n\t\t\twritel(PAD_PU_PD_OFF, host->addr + PAD_PU_PD);\n\t\t\tdev_dbg(&host->chip->pdev->dev, \"power off\\n\");\n\t\t} else\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase MEMSTICK_INTERFACE:\n\t\tdev_dbg(&host->chip->pdev->dev,\n\t\t\t\"Set Host Interface Mode to %d\\n\", value);\n\t\thost_ctl &= ~(HOST_CONTROL_FAST_CLK | HOST_CONTROL_REI |\n\t\t\t      HOST_CONTROL_REO);\n\t\thost_ctl |= HOST_CONTROL_TDELAY_EN | HOST_CONTROL_HW_OC_P;\n\t\thost_ctl &= ~(3 << HOST_CONTROL_IF_SHIFT);\n\n\t\tif (value == MEMSTICK_SERIAL) {\n\t\t\thost_ctl |= HOST_CONTROL_IF_SERIAL\n\t\t\t\t    << HOST_CONTROL_IF_SHIFT;\n\t\t\thost_ctl |= HOST_CONTROL_REI;\n\t\t\tclock_ctl |= CLOCK_CONTROL_40MHZ;\n\t\t\tclock_delay = 0;\n\t\t} else if (value == MEMSTICK_PAR4) {\n\t\t\thost_ctl |= HOST_CONTROL_FAST_CLK;\n\t\t\thost_ctl |= HOST_CONTROL_IF_PAR4\n\t\t\t\t    << HOST_CONTROL_IF_SHIFT;\n\t\t\thost_ctl |= HOST_CONTROL_REO;\n\t\t\tclock_ctl |= CLOCK_CONTROL_40MHZ;\n\t\t\tclock_delay = 4;\n\t\t} else if (value == MEMSTICK_PAR8) {\n\t\t\thost_ctl |= HOST_CONTROL_FAST_CLK;\n\t\t\thost_ctl |= HOST_CONTROL_IF_PAR8\n\t\t\t\t    << HOST_CONTROL_IF_SHIFT;\n\t\t\tclock_ctl |= CLOCK_CONTROL_50MHZ;\n\t\t\tclock_delay = 0;\n\t\t} else\n\t\t\treturn -EINVAL;\n\n\t\twritel(host_ctl, host->addr + HOST_CONTROL);\n\t\twritel(CLOCK_CONTROL_OFF, host->addr + CLOCK_CONTROL);\n\t\twritel(clock_ctl, host->addr + CLOCK_CONTROL);\n\t\tpci_write_config_byte(host->chip->pdev,\n\t\t\t\t      PCI_CTL_CLOCK_DLY_ADDR + 1,\n\t\t\t\t      clock_delay);\n\t\thost->ifmode = value;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n#define PCI_PMOS0_CONTROL\t\t0xae\n#define  PMOS0_ENABLE\t\t\t0x01\n#define  PMOS0_OVERCURRENT_LEVEL_2_4V\t0x06\n#define  PMOS0_EN_OVERCURRENT_DEBOUNCE\t0x40\n#define  PMOS0_SW_LED_POLARITY_ENABLE\t0x80\n#define  PMOS0_ACTIVE_BITS (PMOS0_ENABLE | PMOS0_EN_OVERCURRENT_DEBOUNCE | \\\n\t\t\t    PMOS0_OVERCURRENT_LEVEL_2_4V)\n#define PCI_PMOS1_CONTROL\t\t0xbd\n#define  PMOS1_ACTIVE_BITS\t\t0x4a\n#define PCI_CLOCK_CTL\t\t\t0xb9\n\nstatic int jmb38x_ms_pmos(struct pci_dev *pdev, int flag)\n{\n\tunsigned char val;\n\n\tpci_read_config_byte(pdev, PCI_PMOS0_CONTROL, &val);\n\tif (flag)\n\t\tval |= PMOS0_ACTIVE_BITS;\n\telse\n\t\tval &= ~PMOS0_ACTIVE_BITS;\n\tpci_write_config_byte(pdev, PCI_PMOS0_CONTROL, val);\n\tdev_dbg(&pdev->dev, \"JMB38x: set PMOS0 val 0x%x\\n\", val);\n\n\tif (pci_resource_flags(pdev, 1)) {\n\t\tpci_read_config_byte(pdev, PCI_PMOS1_CONTROL, &val);\n\t\tif (flag)\n\t\t\tval |= PMOS1_ACTIVE_BITS;\n\t\telse\n\t\t\tval &= ~PMOS1_ACTIVE_BITS;\n\t\tpci_write_config_byte(pdev, PCI_PMOS1_CONTROL, val);\n\t\tdev_dbg(&pdev->dev, \"JMB38x: set PMOS1 val 0x%x\\n\", val);\n\t}\n\n\tpci_read_config_byte(pdev, PCI_CLOCK_CTL, &val);\n\tpci_write_config_byte(pdev, PCI_CLOCK_CTL, val & ~0x0f);\n\tpci_write_config_byte(pdev, PCI_CLOCK_CTL, val | 0x01);\n\tdev_dbg(&pdev->dev, \"Clock Control by PCI config is disabled!\\n\");\n\n        return 0;\n}\n\nstatic int __maybe_unused jmb38x_ms_suspend(struct device *dev)\n{\n\tstruct jmb38x_ms *jm = dev_get_drvdata(dev);\n\n\tint cnt;\n\n\tfor (cnt = 0; cnt < jm->host_cnt; ++cnt) {\n\t\tif (!jm->hosts[cnt])\n\t\t\tbreak;\n\t\tmemstick_suspend_host(jm->hosts[cnt]);\n\t}\n\n\tdevice_wakeup_disable(dev);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused jmb38x_ms_resume(struct device *dev)\n{\n\tstruct jmb38x_ms *jm = dev_get_drvdata(dev);\n\tint rc;\n\n\tjmb38x_ms_pmos(to_pci_dev(dev), 1);\n\n\tfor (rc = 0; rc < jm->host_cnt; ++rc) {\n\t\tif (!jm->hosts[rc])\n\t\t\tbreak;\n\t\tmemstick_resume_host(jm->hosts[rc]);\n\t\tmemstick_detect_change(jm->hosts[rc]);\n\t}\n\n\treturn 0;\n}\n\nstatic int jmb38x_ms_count_slots(struct pci_dev *pdev)\n{\n\tint cnt, rc = 0;\n\n\tfor (cnt = 0; cnt < PCI_STD_NUM_BARS; ++cnt) {\n\t\tif (!(IORESOURCE_MEM & pci_resource_flags(pdev, cnt)))\n\t\t\tbreak;\n\n\t\tif (256 != pci_resource_len(pdev, cnt))\n\t\t\tbreak;\n\n\t\t++rc;\n\t}\n\treturn rc;\n}\n\nstatic struct memstick_host *jmb38x_ms_alloc_host(struct jmb38x_ms *jm, int cnt)\n{\n\tstruct memstick_host *msh;\n\tstruct jmb38x_ms_host *host;\n\n\tmsh = memstick_alloc_host(sizeof(struct jmb38x_ms_host),\n\t\t\t\t  &jm->pdev->dev);\n\tif (!msh)\n\t\treturn NULL;\n\n\thost = memstick_priv(msh);\n\thost->msh = msh;\n\thost->chip = jm;\n\thost->addr = ioremap(pci_resource_start(jm->pdev, cnt),\n\t\t\t     pci_resource_len(jm->pdev, cnt));\n\tif (!host->addr)\n\t\tgoto err_out_free;\n\n\tspin_lock_init(&host->lock);\n\thost->id = cnt;\n\tsnprintf(host->host_id, sizeof(host->host_id), DRIVER_NAME \":slot%d\",\n\t\t host->id);\n\thost->irq = jm->pdev->irq;\n\thost->timeout_jiffies = msecs_to_jiffies(1000);\n\n\ttasklet_init(&host->notify, jmb38x_ms_req_tasklet, (unsigned long)msh);\n\tmsh->request = jmb38x_ms_submit_req;\n\tmsh->set_param = jmb38x_ms_set_param;\n\n\tmsh->caps = MEMSTICK_CAP_PAR4 | MEMSTICK_CAP_PAR8;\n\n\ttimer_setup(&host->timer, jmb38x_ms_abort, 0);\n\n\tif (!request_irq(host->irq, jmb38x_ms_isr, IRQF_SHARED, host->host_id,\n\t\t\t msh))\n\t\treturn msh;\n\n\tiounmap(host->addr);\nerr_out_free:\n\tmemstick_free_host(msh);\n\treturn NULL;\n}\n\nstatic void jmb38x_ms_free_host(struct memstick_host *msh)\n{\n\tstruct jmb38x_ms_host *host = memstick_priv(msh);\n\n\tfree_irq(host->irq, msh);\n\tiounmap(host->addr);\n\tmemstick_free_host(msh);\n}\n\nstatic int jmb38x_ms_probe(struct pci_dev *pdev,\n\t\t\t   const struct pci_device_id *dev_id)\n{\n\tstruct jmb38x_ms *jm;\n\tint pci_dev_busy = 0;\n\tint rc, cnt;\n\n\trc = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));\n\tif (rc)\n\t\treturn rc;\n\n\trc = pci_enable_device(pdev);\n\tif (rc)\n\t\treturn rc;\n\n\tpci_set_master(pdev);\n\n\trc = pci_request_regions(pdev, DRIVER_NAME);\n\tif (rc) {\n\t\tpci_dev_busy = 1;\n\t\tgoto err_out;\n\t}\n\n\tjmb38x_ms_pmos(pdev, 1);\n\n\tcnt = jmb38x_ms_count_slots(pdev);\n\tif (!cnt) {\n\t\trc = -ENODEV;\n\t\tpci_dev_busy = 1;\n\t\tgoto err_out_int;\n\t}\n\n\tjm = kzalloc(struct_size(jm, hosts, cnt), GFP_KERNEL);\n\tif (!jm) {\n\t\trc = -ENOMEM;\n\t\tgoto err_out_int;\n\t}\n\n\tjm->pdev = pdev;\n\tjm->host_cnt = cnt;\n\tpci_set_drvdata(pdev, jm);\n\n\tfor (cnt = 0; cnt < jm->host_cnt; ++cnt) {\n\t\tjm->hosts[cnt] = jmb38x_ms_alloc_host(jm, cnt);\n\t\tif (!jm->hosts[cnt])\n\t\t\tbreak;\n\n\t\trc = memstick_add_host(jm->hosts[cnt]);\n\n\t\tif (rc) {\n\t\t\tjmb38x_ms_free_host(jm->hosts[cnt]);\n\t\t\tjm->hosts[cnt] = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (cnt)\n\t\treturn 0;\n\n\trc = -ENODEV;\n\n\tpci_set_drvdata(pdev, NULL);\n\tkfree(jm);\nerr_out_int:\n\tpci_release_regions(pdev);\nerr_out:\n\tif (!pci_dev_busy)\n\t\tpci_disable_device(pdev);\n\treturn rc;\n}\n\nstatic void jmb38x_ms_remove(struct pci_dev *dev)\n{\n\tstruct jmb38x_ms *jm = pci_get_drvdata(dev);\n\tstruct jmb38x_ms_host *host;\n\tint cnt;\n\tunsigned long flags;\n\n\tfor (cnt = 0; cnt < jm->host_cnt; ++cnt) {\n\t\tif (!jm->hosts[cnt])\n\t\t\tbreak;\n\n\t\thost = memstick_priv(jm->hosts[cnt]);\n\n\t\tjm->hosts[cnt]->request = jmb38x_ms_dummy_submit;\n\t\ttasklet_kill(&host->notify);\n\t\twritel(0, host->addr + INT_SIGNAL_ENABLE);\n\t\twritel(0, host->addr + INT_STATUS_ENABLE);\n\t\tdev_dbg(&jm->pdev->dev, \"interrupts off\\n\");\n\t\tspin_lock_irqsave(&host->lock, flags);\n\t\tif (host->req) {\n\t\t\thost->req->error = -ETIME;\n\t\t\tjmb38x_ms_complete_cmd(jm->hosts[cnt], 1);\n\t\t}\n\t\tspin_unlock_irqrestore(&host->lock, flags);\n\n\t\tmemstick_remove_host(jm->hosts[cnt]);\n\t\tdev_dbg(&jm->pdev->dev, \"host removed\\n\");\n\n\t\tjmb38x_ms_free_host(jm->hosts[cnt]);\n\t}\n\n\tjmb38x_ms_pmos(dev, 0);\n\n\tpci_set_drvdata(dev, NULL);\n\tpci_release_regions(dev);\n\tpci_disable_device(dev);\n\tkfree(jm);\n}\n\nstatic struct pci_device_id jmb38x_ms_id_tbl [] = {\n\t{ PCI_VDEVICE(JMICRON, PCI_DEVICE_ID_JMICRON_JMB38X_MS) },\n\t{ PCI_VDEVICE(JMICRON, PCI_DEVICE_ID_JMICRON_JMB385_MS) },\n\t{ PCI_VDEVICE(JMICRON, PCI_DEVICE_ID_JMICRON_JMB390_MS) },\n\t{ }\n};\n\nstatic SIMPLE_DEV_PM_OPS(jmb38x_ms_pm_ops, jmb38x_ms_suspend, jmb38x_ms_resume);\n\nstatic struct pci_driver jmb38x_ms_driver = {\n\t.name = DRIVER_NAME,\n\t.id_table = jmb38x_ms_id_tbl,\n\t.probe = jmb38x_ms_probe,\n\t.remove = jmb38x_ms_remove,\n\t.driver.pm = &jmb38x_ms_pm_ops,\n};\n\nmodule_pci_driver(jmb38x_ms_driver);\n\nMODULE_AUTHOR(\"Alex Dubov\");\nMODULE_DESCRIPTION(\"JMicron jmb38x MemoryStick driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(pci, jmb38x_ms_id_tbl);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}