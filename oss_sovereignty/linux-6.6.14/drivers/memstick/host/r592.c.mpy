{
  "module_name": "r592.c",
  "hash_id": "79dce505482d7ec82a5d8d3255ba003aef5cd578a07e47654146baa10dfd6491",
  "original_prompt": "Ingested from linux-6.6.14/drivers/memstick/host/r592.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/jiffies.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/pci_ids.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <asm/byteorder.h>\n#include <linux/swab.h>\n#include \"r592.h\"\n\nstatic bool r592_enable_dma = 1;\nstatic int debug;\n\nstatic const char *tpc_names[] = {\n\t\"MS_TPC_READ_MG_STATUS\",\n\t\"MS_TPC_READ_LONG_DATA\",\n\t\"MS_TPC_READ_SHORT_DATA\",\n\t\"MS_TPC_READ_REG\",\n\t\"MS_TPC_READ_QUAD_DATA\",\n\t\"INVALID\",\n\t\"MS_TPC_GET_INT\",\n\t\"MS_TPC_SET_RW_REG_ADRS\",\n\t\"MS_TPC_EX_SET_CMD\",\n\t\"MS_TPC_WRITE_QUAD_DATA\",\n\t\"MS_TPC_WRITE_REG\",\n\t\"MS_TPC_WRITE_SHORT_DATA\",\n\t\"MS_TPC_WRITE_LONG_DATA\",\n\t\"MS_TPC_SET_CMD\",\n};\n\n \nstatic __maybe_unused const char *memstick_debug_get_tpc_name(int tpc)\n{\n\treturn tpc_names[tpc-1];\n}\n\n \nstatic inline u32 r592_read_reg(struct r592_device *dev, int address)\n{\n\tu32 value = readl(dev->mmio + address);\n\tdbg_reg(\"reg #%02d == 0x%08x\", address, value);\n\treturn value;\n}\n\n \nstatic inline void r592_write_reg(struct r592_device *dev,\n\t\t\t\t\t\t\tint address, u32 value)\n{\n\tdbg_reg(\"reg #%02d <- 0x%08x\", address, value);\n\twritel(value, dev->mmio + address);\n}\n\n \nstatic inline u32 r592_read_reg_raw_be(struct r592_device *dev, int address)\n{\n\tu32 value = __raw_readl(dev->mmio + address);\n\tdbg_reg(\"reg #%02d == 0x%08x\", address, value);\n\treturn be32_to_cpu(value);\n}\n\n \nstatic inline void r592_write_reg_raw_be(struct r592_device *dev,\n\t\t\t\t\t\t\tint address, u32 value)\n{\n\tdbg_reg(\"reg #%02d <- 0x%08x\", address, value);\n\t__raw_writel(cpu_to_be32(value), dev->mmio + address);\n}\n\n \nstatic inline void r592_set_reg_mask(struct r592_device *dev,\n\t\t\t\t\t\t\tint address, u32 mask)\n{\n\tu32 reg = readl(dev->mmio + address);\n\tdbg_reg(\"reg #%02d |= 0x%08x (old =0x%08x)\", address, mask, reg);\n\twritel(reg | mask , dev->mmio + address);\n}\n\n \nstatic inline void r592_clear_reg_mask(struct r592_device *dev,\n\t\t\t\t\t\tint address, u32 mask)\n{\n\tu32 reg = readl(dev->mmio + address);\n\tdbg_reg(\"reg #%02d &= 0x%08x (old = 0x%08x, mask = 0x%08x)\",\n\t\t\t\t\t\taddress, ~mask, reg, mask);\n\twritel(reg & ~mask, dev->mmio + address);\n}\n\n\n \nstatic int r592_wait_status(struct r592_device *dev, u32 mask, u32 wanted_mask)\n{\n\tunsigned long timeout = jiffies + msecs_to_jiffies(1000);\n\tu32 reg = r592_read_reg(dev, R592_STATUS);\n\n\tif ((reg & mask) == wanted_mask)\n\t\treturn 0;\n\n\twhile (time_before(jiffies, timeout)) {\n\n\t\treg = r592_read_reg(dev, R592_STATUS);\n\n\t\tif ((reg & mask) == wanted_mask)\n\t\t\treturn 0;\n\n\t\tif (reg & (R592_STATUS_SEND_ERR | R592_STATUS_RECV_ERR))\n\t\t\treturn -EIO;\n\n\t\tcpu_relax();\n\t}\n\treturn -ETIME;\n}\n\n\n \nstatic int r592_enable_device(struct r592_device *dev, bool enable)\n{\n\tdbg(\"%sabling the device\", enable ? \"en\" : \"dis\");\n\n\tif (enable) {\n\n\t\t \n\t\tr592_write_reg(dev, R592_POWER, R592_POWER_0 | R592_POWER_1);\n\n\t\t \n\t\tr592_set_reg_mask(dev, R592_IO, R592_IO_RESET);\n\n\t\tmsleep(100);\n\t} else\n\t\t \n\t\tr592_write_reg(dev, R592_POWER, 0);\n\n\treturn 0;\n}\n\n \nstatic int r592_set_mode(struct r592_device *dev, bool parallel_mode)\n{\n\tif (!parallel_mode) {\n\t\tdbg(\"switching to serial mode\");\n\n\t\t \n\t\tr592_write_reg(dev, R592_IO_MODE, R592_IO_MODE_SERIAL);\n\n\t\tr592_clear_reg_mask(dev, R592_POWER, R592_POWER_20);\n\n\t} else {\n\t\tdbg(\"switching to parallel mode\");\n\n\t\t \n\t\tr592_set_reg_mask(dev, R592_POWER, R592_POWER_20);\n\n\t\tr592_clear_reg_mask(dev, R592_IO,\n\t\t\tR592_IO_SERIAL1 | R592_IO_SERIAL2);\n\n\t\t \n\t\tr592_write_reg(dev, R592_IO_MODE, R592_IO_MODE_PARALLEL);\n\t}\n\n\tdev->parallel_mode = parallel_mode;\n\treturn 0;\n}\n\n \nstatic void r592_host_reset(struct r592_device *dev)\n{\n\tr592_set_reg_mask(dev, R592_IO, R592_IO_RESET);\n\tmsleep(100);\n\tr592_set_mode(dev, dev->parallel_mode);\n}\n\n#ifdef CONFIG_PM_SLEEP\n \nstatic void r592_clear_interrupts(struct r592_device *dev)\n{\n\t \n\tr592_clear_reg_mask(dev, R592_REG_MSC, IRQ_ALL_ACK_MASK);\n\tr592_clear_reg_mask(dev, R592_REG_MSC, IRQ_ALL_EN_MASK);\n}\n#endif\n\n \nstatic int r592_test_io_error(struct r592_device *dev)\n{\n\tif (!(r592_read_reg(dev, R592_STATUS) &\n\t\t(R592_STATUS_SEND_ERR | R592_STATUS_RECV_ERR)))\n\t\treturn 0;\n\n\treturn -EIO;\n}\n\n \nstatic int r592_test_fifo_empty(struct r592_device *dev)\n{\n\tif (r592_read_reg(dev, R592_REG_MSC) & R592_REG_MSC_FIFO_EMPTY)\n\t\treturn 0;\n\n\tdbg(\"FIFO not ready, trying to reset the device\");\n\tr592_host_reset(dev);\n\n\tif (r592_read_reg(dev, R592_REG_MSC) & R592_REG_MSC_FIFO_EMPTY)\n\t\treturn 0;\n\n\tmessage(\"FIFO still not ready, giving up\");\n\treturn -EIO;\n}\n\n \nstatic void r592_start_dma(struct r592_device *dev, bool is_write)\n{\n\tunsigned long flags;\n\tu32 reg;\n\tspin_lock_irqsave(&dev->irq_lock, flags);\n\n\t \n\tr592_clear_reg_mask(dev, R592_REG_MSC, DMA_IRQ_ACK_MASK);\n\tr592_set_reg_mask(dev, R592_REG_MSC, DMA_IRQ_EN_MASK);\n\n\t \n\tr592_write_reg(dev, R592_FIFO_DMA, sg_dma_address(&dev->req->sg));\n\n\t \n\treg = r592_read_reg(dev, R592_FIFO_DMA_SETTINGS);\n\treg |= R592_FIFO_DMA_SETTINGS_EN;\n\n\tif (!is_write)\n\t\treg |= R592_FIFO_DMA_SETTINGS_DIR;\n\telse\n\t\treg &= ~R592_FIFO_DMA_SETTINGS_DIR;\n\tr592_write_reg(dev, R592_FIFO_DMA_SETTINGS, reg);\n\n\tspin_unlock_irqrestore(&dev->irq_lock, flags);\n}\n\n \nstatic void r592_stop_dma(struct r592_device *dev, int error)\n{\n\tr592_clear_reg_mask(dev, R592_FIFO_DMA_SETTINGS,\n\t\tR592_FIFO_DMA_SETTINGS_EN);\n\n\t \n\tr592_write_reg(dev, R592_FIFO_DMA,\n\t\t\tdev->dummy_dma_page_physical_address);\n\n\tr592_clear_reg_mask(dev, R592_REG_MSC, DMA_IRQ_EN_MASK);\n\tr592_clear_reg_mask(dev, R592_REG_MSC, DMA_IRQ_ACK_MASK);\n\tdev->dma_error = error;\n}\n\n \nstatic void r592_check_dma(struct r592_device *dev)\n{\n\tdev->dma_capable = r592_enable_dma &&\n\t\t(r592_read_reg(dev, R592_FIFO_DMA_SETTINGS) &\n\t\t\tR592_FIFO_DMA_SETTINGS_CAP);\n}\n\n \nstatic int r592_transfer_fifo_dma(struct r592_device *dev)\n{\n\tint len, sg_count;\n\tbool is_write;\n\n\tif (!dev->dma_capable || !dev->req->long_data)\n\t\treturn -EINVAL;\n\n\tlen = dev->req->sg.length;\n\tis_write = dev->req->data_dir == WRITE;\n\n\tif (len != R592_LFIFO_SIZE)\n\t\treturn -EINVAL;\n\n\tdbg_verbose(\"doing dma transfer\");\n\n\tdev->dma_error = 0;\n\treinit_completion(&dev->dma_done);\n\n\t \n\tsg_count = dma_map_sg(&dev->pci_dev->dev, &dev->req->sg, 1, is_write ?\n\t\t\t      DMA_TO_DEVICE : DMA_FROM_DEVICE);\n\n\tif (sg_count != 1 || sg_dma_len(&dev->req->sg) < R592_LFIFO_SIZE) {\n\t\tmessage(\"problem in dma_map_sg\");\n\t\treturn -EIO;\n\t}\n\n\tr592_start_dma(dev, is_write);\n\n\t \n\tif (!wait_for_completion_timeout(\n\t\t\t&dev->dma_done, msecs_to_jiffies(1000))) {\n\t\tmessage(\"DMA timeout\");\n\t\tr592_stop_dma(dev, -ETIMEDOUT);\n\t}\n\n\tdma_unmap_sg(&dev->pci_dev->dev, &dev->req->sg, 1, is_write ?\n\t\t     DMA_TO_DEVICE : DMA_FROM_DEVICE);\n\n\treturn dev->dma_error;\n}\n\n \nstatic void r592_write_fifo_pio(struct r592_device *dev,\n\t\t\t\t\tunsigned char *buffer, int len)\n{\n\t \n\tif (!kfifo_is_empty(&dev->pio_fifo)) {\n\n\t\tu8 tmp[4] = {0};\n\t\tint copy_len = kfifo_in(&dev->pio_fifo, buffer, len);\n\n\t\tif (!kfifo_is_full(&dev->pio_fifo))\n\t\t\treturn;\n\t\tlen -= copy_len;\n\t\tbuffer += copy_len;\n\n\t\tcopy_len = kfifo_out(&dev->pio_fifo, tmp, 4);\n\t\tWARN_ON(copy_len != 4);\n\t\tr592_write_reg_raw_be(dev, R592_FIFO_PIO, *(u32 *)tmp);\n\t}\n\n\tWARN_ON(!kfifo_is_empty(&dev->pio_fifo));\n\n\t \n\twhile (len >= 4) {\n\t\tr592_write_reg_raw_be(dev, R592_FIFO_PIO, *(u32 *)buffer);\n\t\tbuffer += 4;\n\t\tlen -= 4;\n\t}\n\n\t \n\tif (len)\n\t\tkfifo_in(&dev->pio_fifo, buffer, len);\n}\n\n \nstatic void r592_flush_fifo_write(struct r592_device *dev)\n{\n\tint ret;\n\tu8 buffer[4] = { 0 };\n\n\tif (kfifo_is_empty(&dev->pio_fifo))\n\t\treturn;\n\n\tret = kfifo_out(&dev->pio_fifo, buffer, 4);\n\t \n\t(void)ret;\n\tr592_write_reg_raw_be(dev, R592_FIFO_PIO, *(u32 *)buffer);\n}\n\n \nstatic void r592_read_fifo_pio(struct r592_device *dev,\n\t\t\t\t\t\tunsigned char *buffer, int len)\n{\n\tu8 tmp[4];\n\n\t \n\tif (!kfifo_is_empty(&dev->pio_fifo)) {\n\t\tint bytes_copied =\n\t\t\tkfifo_out(&dev->pio_fifo, buffer, min(4, len));\n\t\tbuffer += bytes_copied;\n\t\tlen -= bytes_copied;\n\n\t\tif (!kfifo_is_empty(&dev->pio_fifo))\n\t\t\treturn;\n\t}\n\n\t \n\twhile (len >= 4) {\n\t\t*(u32 *)buffer = r592_read_reg_raw_be(dev, R592_FIFO_PIO);\n\t\tbuffer += 4;\n\t\tlen -= 4;\n\t}\n\n\tif (len) {\n\t\t*(u32 *)tmp = r592_read_reg_raw_be(dev, R592_FIFO_PIO);\n\t\tkfifo_in(&dev->pio_fifo, tmp, 4);\n\t\tlen -= kfifo_out(&dev->pio_fifo, buffer, len);\n\t}\n\n\tWARN_ON(len);\n\treturn;\n}\n\n \nstatic int r592_transfer_fifo_pio(struct r592_device *dev)\n{\n\tunsigned long flags;\n\n\tbool is_write = dev->req->tpc >= MS_TPC_SET_RW_REG_ADRS;\n\tstruct sg_mapping_iter miter;\n\n\tkfifo_reset(&dev->pio_fifo);\n\n\tif (!dev->req->long_data) {\n\t\tif (is_write) {\n\t\t\tr592_write_fifo_pio(dev, dev->req->data,\n\t\t\t\t\t\t\tdev->req->data_len);\n\t\t\tr592_flush_fifo_write(dev);\n\t\t} else\n\t\t\tr592_read_fifo_pio(dev, dev->req->data,\n\t\t\t\t\t\t\tdev->req->data_len);\n\t\treturn 0;\n\t}\n\n\tlocal_irq_save(flags);\n\tsg_miter_start(&miter, &dev->req->sg, 1, SG_MITER_ATOMIC |\n\t\t(is_write ? SG_MITER_FROM_SG : SG_MITER_TO_SG));\n\n\t \n\twhile (sg_miter_next(&miter))\n\t\tif (is_write)\n\t\t\tr592_write_fifo_pio(dev, miter.addr, miter.length);\n\t\telse\n\t\t\tr592_read_fifo_pio(dev, miter.addr, miter.length);\n\n\n\t \n\tif (is_write)\n\t\tr592_flush_fifo_write(dev);\n\n\tsg_miter_stop(&miter);\n\tlocal_irq_restore(flags);\n\treturn 0;\n}\n\n \nstatic void r592_execute_tpc(struct r592_device *dev)\n{\n\tbool is_write;\n\tint len, error;\n\tu32 status, reg;\n\n\tif (!dev->req) {\n\t\tmessage(\"BUG: tpc execution without request!\");\n\t\treturn;\n\t}\n\n\tis_write = dev->req->tpc >= MS_TPC_SET_RW_REG_ADRS;\n\tlen = dev->req->long_data ?\n\t\tdev->req->sg.length : dev->req->data_len;\n\n\t \n\tif (len > R592_LFIFO_SIZE) {\n\t\tmessage(\"IO: hardware doesn't support TPCs longer that 512\");\n\t\terror = -ENOSYS;\n\t\tgoto out;\n\t}\n\n\tif (!(r592_read_reg(dev, R592_REG_MSC) & R592_REG_MSC_PRSNT)) {\n\t\tdbg(\"IO: refusing to send TPC because card is absent\");\n\t\terror = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tdbg(\"IO: executing %s LEN=%d\",\n\t\t\tmemstick_debug_get_tpc_name(dev->req->tpc), len);\n\n\t \n\tif (is_write)\n\t\tr592_set_reg_mask(dev, R592_IO, R592_IO_DIRECTION);\n\telse\n\t\tr592_clear_reg_mask(dev, R592_IO, R592_IO_DIRECTION);\n\n\n\terror = r592_test_fifo_empty(dev);\n\tif (error)\n\t\tgoto out;\n\n\t \n\tif (is_write) {\n\t\terror = r592_transfer_fifo_dma(dev);\n\t\tif (error == -EINVAL)\n\t\t\terror = r592_transfer_fifo_pio(dev);\n\t}\n\n\tif (error)\n\t\tgoto out;\n\n\t \n\treg = (len << R592_TPC_EXEC_LEN_SHIFT) |\n\t\t(dev->req->tpc << R592_TPC_EXEC_TPC_SHIFT) |\n\t\t\tR592_TPC_EXEC_BIG_FIFO;\n\n\tr592_write_reg(dev, R592_TPC_EXEC, reg);\n\n\t \n\tstatus = R592_STATUS_RDY;\n\tif (dev->req->need_card_int)\n\t\tstatus |= R592_STATUS_CED;\n\n\terror = r592_wait_status(dev, status, status);\n\tif (error) {\n\t\tmessage(\"card didn't respond\");\n\t\tgoto out;\n\t}\n\n\t \n\terror = r592_test_io_error(dev);\n\tif (error) {\n\t\tdbg(\"IO error\");\n\t\tgoto out;\n\t}\n\n\t \n\tif (!is_write) {\n\t\terror = r592_transfer_fifo_dma(dev);\n\t\tif (error == -EINVAL)\n\t\t\terror = r592_transfer_fifo_pio(dev);\n\t}\n\n\t \n\tif (dev->parallel_mode && dev->req->need_card_int) {\n\n\t\tdev->req->int_reg = 0;\n\t\tstatus = r592_read_reg(dev, R592_STATUS);\n\n\t\tif (status & R592_STATUS_P_CMDNACK)\n\t\t\tdev->req->int_reg |= MEMSTICK_INT_CMDNAK;\n\t\tif (status & R592_STATUS_P_BREQ)\n\t\t\tdev->req->int_reg |= MEMSTICK_INT_BREQ;\n\t\tif (status & R592_STATUS_P_INTERR)\n\t\t\tdev->req->int_reg |= MEMSTICK_INT_ERR;\n\t\tif (status & R592_STATUS_P_CED)\n\t\t\tdev->req->int_reg |= MEMSTICK_INT_CED;\n\t}\n\n\tif (error)\n\t\tdbg(\"FIFO read error\");\nout:\n\tdev->req->error = error;\n\tr592_clear_reg_mask(dev, R592_REG_MSC, R592_REG_MSC_LED);\n\treturn;\n}\n\n \nstatic int r592_process_thread(void *data)\n{\n\tint error;\n\tstruct r592_device *dev = (struct r592_device *)data;\n\tunsigned long flags;\n\n\twhile (!kthread_should_stop()) {\n\t\tspin_lock_irqsave(&dev->io_thread_lock, flags);\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\terror = memstick_next_req(dev->host, &dev->req);\n\t\tspin_unlock_irqrestore(&dev->io_thread_lock, flags);\n\n\t\tif (error) {\n\t\t\tif (error == -ENXIO || error == -EAGAIN) {\n\t\t\t\tdbg_verbose(\"IO: done IO, sleeping\");\n\t\t\t} else {\n\t\t\t\tdbg(\"IO: unknown error from \"\n\t\t\t\t\t\"memstick_next_req %d\", error);\n\t\t\t}\n\n\t\t\tif (kthread_should_stop())\n\t\t\t\tset_current_state(TASK_RUNNING);\n\n\t\t\tschedule();\n\t\t} else {\n\t\t\tset_current_state(TASK_RUNNING);\n\t\t\tr592_execute_tpc(dev);\n\t\t}\n\t}\n\treturn 0;\n}\n\n \n \nstatic void r592_update_card_detect(struct r592_device *dev)\n{\n\tu32 reg = r592_read_reg(dev, R592_REG_MSC);\n\tbool card_detected = reg & R592_REG_MSC_PRSNT;\n\n\tdbg(\"update card detect. card state: %s\", card_detected ?\n\t\t\"present\" : \"absent\");\n\n\treg &= ~((R592_REG_MSC_IRQ_REMOVE | R592_REG_MSC_IRQ_INSERT) << 16);\n\n\tif (card_detected)\n\t\treg |= (R592_REG_MSC_IRQ_REMOVE << 16);\n\telse\n\t\treg |= (R592_REG_MSC_IRQ_INSERT << 16);\n\n\tr592_write_reg(dev, R592_REG_MSC, reg);\n}\n\n \nstatic void r592_detect_timer(struct timer_list *t)\n{\n\tstruct r592_device *dev = from_timer(dev, t, detect_timer);\n\tr592_update_card_detect(dev);\n\tmemstick_detect_change(dev->host);\n}\n\n \nstatic irqreturn_t r592_irq(int irq, void *data)\n{\n\tstruct r592_device *dev = (struct r592_device *)data;\n\tirqreturn_t ret = IRQ_NONE;\n\tu32 reg;\n\tu16 irq_enable, irq_status;\n\tunsigned long flags;\n\tint error;\n\n\tspin_lock_irqsave(&dev->irq_lock, flags);\n\n\treg = r592_read_reg(dev, R592_REG_MSC);\n\tirq_enable = reg >> 16;\n\tirq_status = reg & 0xFFFF;\n\n\t \n\treg &= ~irq_status;\n\tr592_write_reg(dev, R592_REG_MSC, reg);\n\n\t \n\tirq_status &= (irq_enable);\n\n\t \n\tif (irq_status & (R592_REG_MSC_IRQ_INSERT | R592_REG_MSC_IRQ_REMOVE)) {\n\n\t\tbool card_was_added = irq_status & R592_REG_MSC_IRQ_INSERT;\n\t\tret = IRQ_HANDLED;\n\n\t\tmessage(\"IRQ: card %s\", card_was_added ? \"added\" : \"removed\");\n\n\t\tmod_timer(&dev->detect_timer,\n\t\t\tjiffies + msecs_to_jiffies(card_was_added ? 500 : 50));\n\t}\n\n\tif (irq_status &\n\t\t(R592_REG_MSC_FIFO_DMA_DONE | R592_REG_MSC_FIFO_DMA_ERR)) {\n\t\tret = IRQ_HANDLED;\n\n\t\tif (irq_status & R592_REG_MSC_FIFO_DMA_ERR) {\n\t\t\tmessage(\"IRQ: DMA error\");\n\t\t\terror = -EIO;\n\t\t} else {\n\t\t\tdbg_verbose(\"IRQ: dma done\");\n\t\t\terror = 0;\n\t\t}\n\n\t\tr592_stop_dma(dev, error);\n\t\tcomplete(&dev->dma_done);\n\t}\n\n\tspin_unlock_irqrestore(&dev->irq_lock, flags);\n\treturn ret;\n}\n\n \nstatic int r592_set_param(struct memstick_host *host,\n\t\t\tenum memstick_param param, int value)\n{\n\tstruct r592_device *dev = memstick_priv(host);\n\n\tswitch (param) {\n\tcase MEMSTICK_POWER:\n\t\tswitch (value) {\n\t\tcase MEMSTICK_POWER_ON:\n\t\t\treturn r592_enable_device(dev, true);\n\t\tcase MEMSTICK_POWER_OFF:\n\t\t\treturn r592_enable_device(dev, false);\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase MEMSTICK_INTERFACE:\n\t\tswitch (value) {\n\t\tcase MEMSTICK_SERIAL:\n\t\t\treturn r592_set_mode(dev, 0);\n\t\tcase MEMSTICK_PAR4:\n\t\t\treturn r592_set_mode(dev, 1);\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n \nstatic void r592_submit_req(struct memstick_host *host)\n{\n\tstruct r592_device *dev = memstick_priv(host);\n\tunsigned long flags;\n\n\tif (dev->req)\n\t\treturn;\n\n\tspin_lock_irqsave(&dev->io_thread_lock, flags);\n\tif (wake_up_process(dev->io_thread))\n\t\tdbg_verbose(\"IO thread woken to process requests\");\n\tspin_unlock_irqrestore(&dev->io_thread_lock, flags);\n}\n\nstatic const struct pci_device_id r592_pci_id_tbl[] = {\n\n\t{ PCI_VDEVICE(RICOH, 0x0592), },\n\t{ },\n};\n\n \nstatic int r592_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tint error = -ENOMEM;\n\tstruct memstick_host *host;\n\tstruct r592_device *dev;\n\n\t \n\thost = memstick_alloc_host(sizeof(struct r592_device), &pdev->dev);\n\tif (!host)\n\t\tgoto error1;\n\n\tdev = memstick_priv(host);\n\tdev->host = host;\n\tdev->pci_dev = pdev;\n\tpci_set_drvdata(pdev, dev);\n\n\t \n\terror = pci_enable_device(pdev);\n\tif (error)\n\t\tgoto error2;\n\n\tpci_set_master(pdev);\n\terror = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));\n\tif (error)\n\t\tgoto error3;\n\n\terror = pci_request_regions(pdev, DRV_NAME);\n\tif (error)\n\t\tgoto error3;\n\n\tdev->mmio = pci_ioremap_bar(pdev, 0);\n\tif (!dev->mmio) {\n\t\terror = -ENOMEM;\n\t\tgoto error4;\n\t}\n\n\tdev->irq = pdev->irq;\n\tspin_lock_init(&dev->irq_lock);\n\tspin_lock_init(&dev->io_thread_lock);\n\tinit_completion(&dev->dma_done);\n\tINIT_KFIFO(dev->pio_fifo);\n\ttimer_setup(&dev->detect_timer, r592_detect_timer, 0);\n\n\t \n\thost->caps = MEMSTICK_CAP_PAR4;\n\thost->request = r592_submit_req;\n\thost->set_param = r592_set_param;\n\tr592_check_dma(dev);\n\n\tdev->io_thread = kthread_run(r592_process_thread, dev, \"r592_io\");\n\tif (IS_ERR(dev->io_thread)) {\n\t\terror = PTR_ERR(dev->io_thread);\n\t\tgoto error5;\n\t}\n\n\t \n\tdev->dummy_dma_page = dma_alloc_coherent(&pdev->dev, PAGE_SIZE,\n\t\t&dev->dummy_dma_page_physical_address, GFP_KERNEL);\n\tr592_stop_dma(dev , 0);\n\n\terror = request_irq(dev->irq, &r592_irq, IRQF_SHARED,\n\t\t\t  DRV_NAME, dev);\n\tif (error)\n\t\tgoto error6;\n\n\tr592_update_card_detect(dev);\n\terror = memstick_add_host(host);\n\tif (error)\n\t\tgoto error7;\n\n\tmessage(\"driver successfully loaded\");\n\treturn 0;\nerror7:\n\tfree_irq(dev->irq, dev);\nerror6:\n\tif (dev->dummy_dma_page)\n\t\tdma_free_coherent(&pdev->dev, PAGE_SIZE, dev->dummy_dma_page,\n\t\t\tdev->dummy_dma_page_physical_address);\n\n\tkthread_stop(dev->io_thread);\nerror5:\n\tiounmap(dev->mmio);\nerror4:\n\tpci_release_regions(pdev);\nerror3:\n\tpci_disable_device(pdev);\nerror2:\n\tmemstick_free_host(host);\nerror1:\n\treturn error;\n}\n\nstatic void r592_remove(struct pci_dev *pdev)\n{\n\tint error = 0;\n\tstruct r592_device *dev = pci_get_drvdata(pdev);\n\n\t \n\tkthread_stop(dev->io_thread);\n\tdel_timer_sync(&dev->detect_timer);\n\tr592_enable_device(dev, false);\n\n\twhile (!error && dev->req) {\n\t\tdev->req->error = -ETIME;\n\t\terror = memstick_next_req(dev->host, &dev->req);\n\t}\n\tmemstick_remove_host(dev->host);\n\n\tif (dev->dummy_dma_page)\n\t\tdma_free_coherent(&pdev->dev, PAGE_SIZE, dev->dummy_dma_page,\n\t\t\tdev->dummy_dma_page_physical_address);\n\n\tfree_irq(dev->irq, dev);\n\tiounmap(dev->mmio);\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n\tmemstick_free_host(dev->host);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int r592_suspend(struct device *core_dev)\n{\n\tstruct r592_device *dev = dev_get_drvdata(core_dev);\n\n\tr592_clear_interrupts(dev);\n\tmemstick_suspend_host(dev->host);\n\tdel_timer_sync(&dev->detect_timer);\n\treturn 0;\n}\n\nstatic int r592_resume(struct device *core_dev)\n{\n\tstruct r592_device *dev = dev_get_drvdata(core_dev);\n\n\tr592_clear_interrupts(dev);\n\tr592_enable_device(dev, false);\n\tmemstick_resume_host(dev->host);\n\tr592_update_card_detect(dev);\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(r592_pm_ops, r592_suspend, r592_resume);\n\nMODULE_DEVICE_TABLE(pci, r592_pci_id_tbl);\n\nstatic struct pci_driver r592_pci_driver = {\n\t.name\t\t= DRV_NAME,\n\t.id_table\t= r592_pci_id_tbl,\n\t.probe\t\t= r592_probe,\n\t.remove\t\t= r592_remove,\n\t.driver.pm\t= &r592_pm_ops,\n};\n\nmodule_pci_driver(r592_pci_driver);\n\nmodule_param_named(enable_dma, r592_enable_dma, bool, S_IRUGO);\nMODULE_PARM_DESC(enable_dma, \"Enable usage of the DMA (default)\");\nmodule_param(debug, int, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(debug, \"Debug level (0-3)\");\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Maxim Levitsky <maximlevitsky@gmail.com>\");\nMODULE_DESCRIPTION(\"Ricoh R5C592 Memstick/Memstick PRO card reader driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}