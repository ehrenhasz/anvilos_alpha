{
  "module_name": "rtsx_usb_ms.c",
  "hash_id": "0e6eb5b52c417a2848395e8704a5e9c9fd6c16b51d526754c3aea92cdda0d107",
  "original_prompt": "Ingested from linux-6.6.14/drivers/memstick/host/rtsx_usb_ms.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/delay.h>\n#include <linux/platform_device.h>\n#include <linux/workqueue.h>\n#include <linux/memstick.h>\n#include <linux/kthread.h>\n#include <linux/rtsx_usb.h>\n#include <linux/pm_runtime.h>\n#include <linux/mutex.h>\n#include <linux/sched.h>\n#include <linux/completion.h>\n#include <asm/unaligned.h>\n\nstruct rtsx_usb_ms {\n\tstruct platform_device\t*pdev;\n\tstruct rtsx_ucr\t*ucr;\n\tstruct memstick_host\t*msh;\n\tstruct memstick_request\t*req;\n\n\tstruct mutex\t\thost_mutex;\n\tstruct work_struct\thandle_req;\n\tstruct delayed_work\tpoll_card;\n\n\tu8\t\t\tssc_depth;\n\tunsigned int\t\tclock;\n\tint\t\t\tpower_mode;\n\tunsigned char           ifmode;\n\tbool\t\t\teject;\n\tbool\t\t\tsystem_suspending;\n};\n\nstatic inline struct device *ms_dev(struct rtsx_usb_ms *host)\n{\n\treturn &(host->pdev->dev);\n}\n\nstatic inline void ms_clear_error(struct rtsx_usb_ms *host)\n{\n\tstruct rtsx_ucr *ucr = host->ucr;\n\trtsx_usb_ep0_write_register(ucr, CARD_STOP,\n\t\t\t\t  MS_STOP | MS_CLR_ERR,\n\t\t\t\t  MS_STOP | MS_CLR_ERR);\n\n\trtsx_usb_clear_dma_err(ucr);\n\trtsx_usb_clear_fsm_err(ucr);\n}\n\n#ifdef DEBUG\n\nstatic void ms_print_debug_regs(struct rtsx_usb_ms *host)\n{\n\tstruct rtsx_ucr *ucr = host->ucr;\n\tu16 i;\n\tu8 *ptr;\n\n\t \n\trtsx_usb_init_cmd(ucr);\n\n\t \n\tfor (i = 0xFD40; i <= 0xFD44; i++)\n\t\trtsx_usb_add_cmd(ucr, READ_REG_CMD, i, 0, 0);\n\n\t \n\tfor (i = 0xFD51; i <= 0xFD56; i++)\n\t\trtsx_usb_add_cmd(ucr, READ_REG_CMD, i, 0, 0);\n\n\t \n\tfor (i = 0xFD60; i <= 0xFD65; i++)\n\t\trtsx_usb_add_cmd(ucr, READ_REG_CMD, i, 0, 0);\n\n\t \n\trtsx_usb_add_cmd(ucr, READ_REG_CMD, CARD_DATA_SOURCE, 0, 0);\n\trtsx_usb_add_cmd(ucr, READ_REG_CMD, CARD_SELECT, 0, 0);\n\trtsx_usb_add_cmd(ucr, READ_REG_CMD, CARD_CLK_EN, 0, 0);\n\trtsx_usb_add_cmd(ucr, READ_REG_CMD, CARD_PWR_CTL, 0, 0);\n\n\trtsx_usb_send_cmd(ucr, MODE_CR, 100);\n\trtsx_usb_get_rsp(ucr, 21, 100);\n\n\tptr = ucr->rsp_buf;\n\tfor (i = 0xFD40; i <= 0xFD44; i++)\n\t\tdev_dbg(ms_dev(host), \"0x%04X: 0x%02x\\n\", i, *(ptr++));\n\tfor (i = 0xFD51; i <= 0xFD56; i++)\n\t\tdev_dbg(ms_dev(host), \"0x%04X: 0x%02x\\n\", i, *(ptr++));\n\tfor (i = 0xFD60; i <= 0xFD65; i++)\n\t\tdev_dbg(ms_dev(host), \"0x%04X: 0x%02x\\n\", i, *(ptr++));\n\n\tdev_dbg(ms_dev(host), \"0x%04X: 0x%02x\\n\", CARD_DATA_SOURCE, *(ptr++));\n\tdev_dbg(ms_dev(host), \"0x%04X: 0x%02x\\n\", CARD_SELECT, *(ptr++));\n\tdev_dbg(ms_dev(host), \"0x%04X: 0x%02x\\n\", CARD_CLK_EN, *(ptr++));\n\tdev_dbg(ms_dev(host), \"0x%04X: 0x%02x\\n\", CARD_PWR_CTL, *(ptr++));\n}\n\n#else\n\nstatic void ms_print_debug_regs(struct rtsx_usb_ms *host)\n{\n}\n\n#endif\n\nstatic int ms_pull_ctl_disable_lqfp48(struct rtsx_ucr *ucr)\n{\n\trtsx_usb_init_cmd(ucr);\n\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL1, 0xFF, 0x55);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL2, 0xFF, 0x55);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL3, 0xFF, 0x95);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL4, 0xFF, 0x55);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL5, 0xFF, 0x55);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL6, 0xFF, 0xA5);\n\n\treturn rtsx_usb_send_cmd(ucr, MODE_C, 100);\n}\n\nstatic int ms_pull_ctl_disable_qfn24(struct rtsx_ucr *ucr)\n{\n\trtsx_usb_init_cmd(ucr);\n\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL1, 0xFF, 0x65);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL2, 0xFF, 0x55);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL3, 0xFF, 0x95);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL4, 0xFF, 0x55);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL5, 0xFF, 0x56);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL6, 0xFF, 0x59);\n\n\treturn rtsx_usb_send_cmd(ucr, MODE_C, 100);\n}\n\nstatic int ms_pull_ctl_enable_lqfp48(struct rtsx_ucr *ucr)\n{\n\trtsx_usb_init_cmd(ucr);\n\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL1, 0xFF, 0x55);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL2, 0xFF, 0x55);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL3, 0xFF, 0x95);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL4, 0xFF, 0x55);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL5, 0xFF, 0x55);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL6, 0xFF, 0xA5);\n\n\treturn rtsx_usb_send_cmd(ucr, MODE_C, 100);\n}\n\nstatic int ms_pull_ctl_enable_qfn24(struct rtsx_ucr *ucr)\n{\n\trtsx_usb_init_cmd(ucr);\n\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL1, 0xFF, 0x65);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL2, 0xFF, 0x55);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL3, 0xFF, 0x95);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL4, 0xFF, 0x55);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL5, 0xFF, 0x55);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL6, 0xFF, 0x59);\n\n\treturn rtsx_usb_send_cmd(ucr, MODE_C, 100);\n}\n\nstatic int ms_power_on(struct rtsx_usb_ms *host)\n{\n\tstruct rtsx_ucr *ucr = host->ucr;\n\tint err;\n\n\tdev_dbg(ms_dev(host), \"%s\\n\", __func__);\n\n\trtsx_usb_init_cmd(ucr);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_SELECT, 0x07, MS_MOD_SEL);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_SHARE_MODE,\n\t\t\tCARD_SHARE_MASK, CARD_SHARE_MS);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_CLK_EN,\n\t\t\tMS_CLK_EN, MS_CLK_EN);\n\terr = rtsx_usb_send_cmd(ucr, MODE_C, 100);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (CHECK_PKG(ucr, LQFP48))\n\t\terr = ms_pull_ctl_enable_lqfp48(ucr);\n\telse\n\t\terr = ms_pull_ctl_enable_qfn24(ucr);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = rtsx_usb_write_register(ucr, CARD_PWR_CTL,\n\t\t\tPOWER_MASK, PARTIAL_POWER_ON);\n\tif (err)\n\t\treturn err;\n\n\tusleep_range(800, 1000);\n\n\trtsx_usb_init_cmd(ucr);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PWR_CTL,\n\t\t\tPOWER_MASK, POWER_ON);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_OE,\n\t\t\tMS_OUTPUT_EN, MS_OUTPUT_EN);\n\n\treturn rtsx_usb_send_cmd(ucr, MODE_C, 100);\n}\n\nstatic int ms_power_off(struct rtsx_usb_ms *host)\n{\n\tstruct rtsx_ucr *ucr = host->ucr;\n\tint err;\n\n\tdev_dbg(ms_dev(host), \"%s\\n\", __func__);\n\n\trtsx_usb_init_cmd(ucr);\n\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_CLK_EN, MS_CLK_EN, 0);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_OE, MS_OUTPUT_EN, 0);\n\n\terr = rtsx_usb_send_cmd(ucr, MODE_C, 100);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (CHECK_PKG(ucr, LQFP48))\n\t\treturn ms_pull_ctl_disable_lqfp48(ucr);\n\n\treturn ms_pull_ctl_disable_qfn24(ucr);\n}\n\nstatic int ms_transfer_data(struct rtsx_usb_ms *host, unsigned char data_dir,\n\t\tu8 tpc, u8 cfg, struct scatterlist *sg)\n{\n\tstruct rtsx_ucr *ucr = host->ucr;\n\tint err;\n\tunsigned int length = sg->length;\n\tu16 sec_cnt = (u16)(length / 512);\n\tu8 trans_mode, dma_dir, flag;\n\tunsigned int pipe;\n\tstruct memstick_dev *card = host->msh->card;\n\n\tdev_dbg(ms_dev(host), \"%s: tpc = 0x%02x, data_dir = %s, length = %d\\n\",\n\t\t\t__func__, tpc, (data_dir == READ) ? \"READ\" : \"WRITE\",\n\t\t\tlength);\n\n\tif (data_dir == READ) {\n\t\tflag = MODE_CDIR;\n\t\tdma_dir = DMA_DIR_FROM_CARD;\n\t\tif (card->id.type != MEMSTICK_TYPE_PRO)\n\t\t\ttrans_mode = MS_TM_NORMAL_READ;\n\t\telse\n\t\t\ttrans_mode = MS_TM_AUTO_READ;\n\t\tpipe = usb_rcvbulkpipe(ucr->pusb_dev, EP_BULK_IN);\n\t} else {\n\t\tflag = MODE_CDOR;\n\t\tdma_dir = DMA_DIR_TO_CARD;\n\t\tif (card->id.type != MEMSTICK_TYPE_PRO)\n\t\t\ttrans_mode = MS_TM_NORMAL_WRITE;\n\t\telse\n\t\t\ttrans_mode = MS_TM_AUTO_WRITE;\n\t\tpipe = usb_sndbulkpipe(ucr->pusb_dev, EP_BULK_OUT);\n\t}\n\n\trtsx_usb_init_cmd(ucr);\n\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, MS_TPC, 0xFF, tpc);\n\tif (card->id.type == MEMSTICK_TYPE_PRO) {\n\t\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, MS_SECTOR_CNT_H,\n\t\t\t\t0xFF, (u8)(sec_cnt >> 8));\n\t\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, MS_SECTOR_CNT_L,\n\t\t\t\t0xFF, (u8)sec_cnt);\n\t}\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, MS_TRANS_CFG, 0xFF, cfg);\n\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, MC_DMA_TC3,\n\t\t\t0xFF, (u8)(length >> 24));\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, MC_DMA_TC2,\n\t\t\t0xFF, (u8)(length >> 16));\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, MC_DMA_TC1,\n\t\t\t0xFF, (u8)(length >> 8));\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, MC_DMA_TC0, 0xFF,\n\t\t\t(u8)length);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, MC_DMA_CTL,\n\t\t\t0x03 | DMA_PACK_SIZE_MASK, dma_dir | DMA_EN | DMA_512);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_DATA_SOURCE,\n\t\t\t0x01, RING_BUFFER);\n\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, MS_TRANSFER,\n\t\t\t0xFF, MS_TRANSFER_START | trans_mode);\n\trtsx_usb_add_cmd(ucr, CHECK_REG_CMD, MS_TRANSFER,\n\t\t\tMS_TRANSFER_END, MS_TRANSFER_END);\n\n\terr = rtsx_usb_send_cmd(ucr, flag | STAGE_MS_STATUS, 100);\n\tif (err)\n\t\treturn err;\n\n\terr = rtsx_usb_transfer_data(ucr, pipe, sg, length,\n\t\t\t1, NULL, 10000);\n\tif (err)\n\t\tgoto err_out;\n\n\terr = rtsx_usb_get_rsp(ucr, 3, 15000);\n\tif (err)\n\t\tgoto err_out;\n\n\tif (ucr->rsp_buf[0] & MS_TRANSFER_ERR ||\n\t    ucr->rsp_buf[1] & (MS_CRC16_ERR | MS_RDY_TIMEOUT)) {\n\t\terr = -EIO;\n\t\tgoto err_out;\n\t}\n\treturn 0;\nerr_out:\n\tms_clear_error(host);\n\treturn err;\n}\n\nstatic int ms_write_bytes(struct rtsx_usb_ms *host, u8 tpc,\n\t\tu8 cfg, u8 cnt, u8 *data, u8 *int_reg)\n{\n\tstruct rtsx_ucr *ucr = host->ucr;\n\tint err, i;\n\n\tdev_dbg(ms_dev(host), \"%s: tpc = 0x%02x\\n\", __func__, tpc);\n\n\trtsx_usb_init_cmd(ucr);\n\n\tfor (i = 0; i < cnt; i++)\n\t\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD,\n\t\t\t\tPPBUF_BASE2 + i, 0xFF, data[i]);\n\n\tif (cnt % 2)\n\t\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD,\n\t\t\t\tPPBUF_BASE2 + i, 0xFF, 0xFF);\n\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, MS_TPC, 0xFF, tpc);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, MS_BYTE_CNT, 0xFF, cnt);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, MS_TRANS_CFG, 0xFF, cfg);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_DATA_SOURCE,\n\t\t\t0x01, PINGPONG_BUFFER);\n\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, MS_TRANSFER,\n\t\t\t0xFF, MS_TRANSFER_START | MS_TM_WRITE_BYTES);\n\trtsx_usb_add_cmd(ucr, CHECK_REG_CMD, MS_TRANSFER,\n\t\t\tMS_TRANSFER_END, MS_TRANSFER_END);\n\trtsx_usb_add_cmd(ucr, READ_REG_CMD, MS_TRANS_CFG, 0, 0);\n\n\terr = rtsx_usb_send_cmd(ucr, MODE_CR, 100);\n\tif (err)\n\t\treturn err;\n\n\terr = rtsx_usb_get_rsp(ucr, 2, 5000);\n\tif (err || (ucr->rsp_buf[0] & MS_TRANSFER_ERR)) {\n\t\tu8 val;\n\n\t\trtsx_usb_ep0_read_register(ucr, MS_TRANS_CFG, &val);\n\t\tdev_dbg(ms_dev(host), \"MS_TRANS_CFG: 0x%02x\\n\", val);\n\n\t\tif (int_reg)\n\t\t\t*int_reg = val & 0x0F;\n\n\t\tms_print_debug_regs(host);\n\n\t\tms_clear_error(host);\n\n\t\tif (!(tpc & 0x08)) {\n\t\t\tif (val & MS_CRC16_ERR)\n\t\t\t\treturn -EIO;\n\t\t} else {\n\t\t\tif (!(val & 0x80)) {\n\t\t\t\tif (val & (MS_INT_ERR | MS_INT_CMDNK))\n\t\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tif (int_reg)\n\t\t*int_reg = ucr->rsp_buf[1] & 0x0F;\n\n\treturn 0;\n}\n\nstatic int ms_read_bytes(struct rtsx_usb_ms *host, u8 tpc,\n\t\tu8 cfg, u8 cnt, u8 *data, u8 *int_reg)\n{\n\tstruct rtsx_ucr *ucr = host->ucr;\n\tint err, i;\n\tu8 *ptr;\n\n\tdev_dbg(ms_dev(host), \"%s: tpc = 0x%02x\\n\", __func__, tpc);\n\n\trtsx_usb_init_cmd(ucr);\n\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, MS_TPC, 0xFF, tpc);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, MS_BYTE_CNT, 0xFF, cnt);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, MS_TRANS_CFG, 0xFF, cfg);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_DATA_SOURCE,\n\t\t\t0x01, PINGPONG_BUFFER);\n\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, MS_TRANSFER,\n\t\t\t0xFF, MS_TRANSFER_START | MS_TM_READ_BYTES);\n\trtsx_usb_add_cmd(ucr, CHECK_REG_CMD, MS_TRANSFER,\n\t\t\tMS_TRANSFER_END, MS_TRANSFER_END);\n\tfor (i = 0; i < cnt - 1; i++)\n\t\trtsx_usb_add_cmd(ucr, READ_REG_CMD, PPBUF_BASE2 + i, 0, 0);\n\tif (cnt % 2)\n\t\trtsx_usb_add_cmd(ucr, READ_REG_CMD, PPBUF_BASE2 + cnt, 0, 0);\n\telse\n\t\trtsx_usb_add_cmd(ucr, READ_REG_CMD,\n\t\t\t\tPPBUF_BASE2 + cnt - 1, 0, 0);\n\n\trtsx_usb_add_cmd(ucr, READ_REG_CMD, MS_TRANS_CFG, 0, 0);\n\n\terr = rtsx_usb_send_cmd(ucr, MODE_CR, 100);\n\tif (err)\n\t\treturn err;\n\n\terr = rtsx_usb_get_rsp(ucr, cnt + 2, 5000);\n\tif (err || (ucr->rsp_buf[0] & MS_TRANSFER_ERR)) {\n\t\tu8 val;\n\n\t\trtsx_usb_ep0_read_register(ucr, MS_TRANS_CFG, &val);\n\t\tdev_dbg(ms_dev(host), \"MS_TRANS_CFG: 0x%02x\\n\", val);\n\n\t\tif (int_reg && (host->ifmode != MEMSTICK_SERIAL))\n\t\t\t*int_reg = val & 0x0F;\n\n\t\tms_print_debug_regs(host);\n\n\t\tms_clear_error(host);\n\n\t\tif (!(tpc & 0x08)) {\n\t\t\tif (val & MS_CRC16_ERR)\n\t\t\t\treturn -EIO;\n\t\t} else {\n\t\t\tif (!(val & 0x80)) {\n\t\t\t\tif (val & (MS_INT_ERR | MS_INT_CMDNK))\n\t\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tptr = ucr->rsp_buf + 1;\n\tfor (i = 0; i < cnt; i++)\n\t\tdata[i] = *ptr++;\n\n\n\tif (int_reg && (host->ifmode != MEMSTICK_SERIAL))\n\t\t*int_reg = *ptr & 0x0F;\n\n\treturn 0;\n}\n\nstatic int rtsx_usb_ms_issue_cmd(struct rtsx_usb_ms *host)\n{\n\tstruct memstick_request *req = host->req;\n\tint err = 0;\n\tu8 cfg = 0, int_reg;\n\n\tdev_dbg(ms_dev(host), \"%s\\n\", __func__);\n\n\tif (req->need_card_int) {\n\t\tif (host->ifmode != MEMSTICK_SERIAL)\n\t\t\tcfg = WAIT_INT;\n\t}\n\n\tif (req->long_data) {\n\t\terr = ms_transfer_data(host, req->data_dir,\n\t\t\t\treq->tpc, cfg, &(req->sg));\n\t} else {\n\t\tif (req->data_dir == READ)\n\t\t\terr = ms_read_bytes(host, req->tpc, cfg,\n\t\t\t\t\treq->data_len, req->data, &int_reg);\n\t\telse\n\t\t\terr = ms_write_bytes(host, req->tpc, cfg,\n\t\t\t\t\treq->data_len, req->data, &int_reg);\n\t}\n\tif (err < 0)\n\t\treturn err;\n\n\tif (req->need_card_int) {\n\t\tif (host->ifmode == MEMSTICK_SERIAL) {\n\t\t\terr = ms_read_bytes(host, MS_TPC_GET_INT,\n\t\t\t\t\tNO_WAIT_INT, 1, &req->int_reg, NULL);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t} else {\n\n\t\t\tif (int_reg & MS_INT_CMDNK)\n\t\t\t\treq->int_reg |= MEMSTICK_INT_CMDNAK;\n\t\t\tif (int_reg & MS_INT_BREQ)\n\t\t\t\treq->int_reg |= MEMSTICK_INT_BREQ;\n\t\t\tif (int_reg & MS_INT_ERR)\n\t\t\t\treq->int_reg |= MEMSTICK_INT_ERR;\n\t\t\tif (int_reg & MS_INT_CED)\n\t\t\t\treq->int_reg |= MEMSTICK_INT_CED;\n\t\t}\n\t\tdev_dbg(ms_dev(host), \"int_reg: 0x%02x\\n\", req->int_reg);\n\t}\n\n\treturn 0;\n}\n\nstatic void rtsx_usb_ms_handle_req(struct work_struct *work)\n{\n\tstruct rtsx_usb_ms *host = container_of(work,\n\t\t\tstruct rtsx_usb_ms, handle_req);\n\tstruct rtsx_ucr *ucr = host->ucr;\n\tstruct memstick_host *msh = host->msh;\n\tint rc;\n\n\tif (!host->req) {\n\t\tpm_runtime_get_sync(ms_dev(host));\n\t\tdo {\n\t\t\trc = memstick_next_req(msh, &host->req);\n\t\t\tdev_dbg(ms_dev(host), \"next req %d\\n\", rc);\n\n\t\t\tif (!rc) {\n\t\t\t\tmutex_lock(&ucr->dev_mutex);\n\n\t\t\t\tif (rtsx_usb_card_exclusive_check(ucr,\n\t\t\t\t\t\t\tRTSX_USB_MS_CARD))\n\t\t\t\t\thost->req->error = -EIO;\n\t\t\t\telse\n\t\t\t\t\thost->req->error =\n\t\t\t\t\t\trtsx_usb_ms_issue_cmd(host);\n\n\t\t\t\tmutex_unlock(&ucr->dev_mutex);\n\n\t\t\t\tdev_dbg(ms_dev(host), \"req result %d\\n\",\n\t\t\t\t\t\thost->req->error);\n\t\t\t}\n\t\t} while (!rc);\n\t\tpm_runtime_put_sync(ms_dev(host));\n\t}\n\n}\n\nstatic void rtsx_usb_ms_request(struct memstick_host *msh)\n{\n\tstruct rtsx_usb_ms *host = memstick_priv(msh);\n\n\tdev_dbg(ms_dev(host), \"--> %s\\n\", __func__);\n\n\tif (!host->eject)\n\t\tschedule_work(&host->handle_req);\n}\n\nstatic int rtsx_usb_ms_set_param(struct memstick_host *msh,\n\t\tenum memstick_param param, int value)\n{\n\tstruct rtsx_usb_ms *host = memstick_priv(msh);\n\tstruct rtsx_ucr *ucr = host->ucr;\n\tunsigned int clock = 0;\n\tu8 ssc_depth = 0;\n\tint err;\n\n\tdev_dbg(ms_dev(host), \"%s: param = %d, value = %d\\n\",\n\t\t\t__func__, param, value);\n\n\tpm_runtime_get_sync(ms_dev(host));\n\tmutex_lock(&ucr->dev_mutex);\n\n\terr = rtsx_usb_card_exclusive_check(ucr, RTSX_USB_MS_CARD);\n\tif (err)\n\t\tgoto out;\n\n\tswitch (param) {\n\tcase MEMSTICK_POWER:\n\t\tif (value == host->power_mode)\n\t\t\tbreak;\n\n\t\tif (value == MEMSTICK_POWER_ON) {\n\t\t\tpm_runtime_get_noresume(ms_dev(host));\n\t\t\terr = ms_power_on(host);\n\t\t\tif (err)\n\t\t\t\tpm_runtime_put_noidle(ms_dev(host));\n\t\t} else if (value == MEMSTICK_POWER_OFF) {\n\t\t\terr = ms_power_off(host);\n\t\t\tif (!err)\n\t\t\t\tpm_runtime_put_noidle(ms_dev(host));\n\t\t} else\n\t\t\terr = -EINVAL;\n\t\tif (!err)\n\t\t\thost->power_mode = value;\n\t\tbreak;\n\n\tcase MEMSTICK_INTERFACE:\n\t\tif (value == MEMSTICK_SERIAL) {\n\t\t\tclock = 19000000;\n\t\t\tssc_depth = SSC_DEPTH_512K;\n\t\t\terr = rtsx_usb_write_register(ucr, MS_CFG, 0x5A,\n\t\t\t\t       MS_BUS_WIDTH_1 | PUSH_TIME_DEFAULT);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t} else if (value == MEMSTICK_PAR4) {\n\t\t\tclock = 39000000;\n\t\t\tssc_depth = SSC_DEPTH_1M;\n\n\t\t\terr = rtsx_usb_write_register(ucr, MS_CFG, 0x5A,\n\t\t\t\t\tMS_BUS_WIDTH_4 | PUSH_TIME_ODD |\n\t\t\t\t\tMS_NO_CHECK_INT);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\terr = rtsx_usb_switch_clock(ucr, clock,\n\t\t\t\tssc_depth, false, true, false);\n\t\tif (err < 0) {\n\t\t\tdev_dbg(ms_dev(host), \"switch clock failed\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\thost->ssc_depth = ssc_depth;\n\t\thost->clock = clock;\n\t\thost->ifmode = value;\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\nout:\n\tmutex_unlock(&ucr->dev_mutex);\n\tpm_runtime_put_sync(ms_dev(host));\n\n\t \n\tif (param == MEMSTICK_POWER && value == MEMSTICK_POWER_ON) {\n\t\tusleep_range(10000, 12000);\n\n\t\tif (!host->eject)\n\t\t\tschedule_delayed_work(&host->poll_card, 100);\n\t}\n\n\tdev_dbg(ms_dev(host), \"%s: return = %d\\n\", __func__, err);\n\treturn err;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int rtsx_usb_ms_suspend(struct device *dev)\n{\n\tstruct rtsx_usb_ms *host = dev_get_drvdata(dev);\n\tstruct memstick_host *msh = host->msh;\n\n\t \n\n\thost->system_suspending = true;\n\tmemstick_suspend_host(msh);\n\n\treturn 0;\n}\n\nstatic int rtsx_usb_ms_resume(struct device *dev)\n{\n\tstruct rtsx_usb_ms *host = dev_get_drvdata(dev);\n\tstruct memstick_host *msh = host->msh;\n\n\tmemstick_resume_host(msh);\n\thost->system_suspending = false;\n\n\treturn 0;\n}\n#endif  \n\n#ifdef CONFIG_PM\nstatic int rtsx_usb_ms_runtime_suspend(struct device *dev)\n{\n\tstruct rtsx_usb_ms *host = dev_get_drvdata(dev);\n\n\tif (host->system_suspending)\n\t\treturn 0;\n\n\tif (host->msh->card || host->power_mode != MEMSTICK_POWER_OFF)\n\t\treturn -EAGAIN;\n\n\treturn 0;\n}\n\nstatic int rtsx_usb_ms_runtime_resume(struct device *dev)\n{\n\tstruct rtsx_usb_ms *host = dev_get_drvdata(dev);\n\n\n\tif (host->system_suspending)\n\t\treturn 0;\n\n\tmemstick_detect_change(host->msh);\n\n\treturn 0;\n}\n#endif  \n\nstatic const struct dev_pm_ops rtsx_usb_ms_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(rtsx_usb_ms_suspend, rtsx_usb_ms_resume)\n\tSET_RUNTIME_PM_OPS(rtsx_usb_ms_runtime_suspend, rtsx_usb_ms_runtime_resume, NULL)\n};\n\n\nstatic void rtsx_usb_ms_poll_card(struct work_struct *work)\n{\n\tstruct rtsx_usb_ms *host = container_of(work, struct rtsx_usb_ms,\n\t\t\tpoll_card.work);\n\tstruct rtsx_ucr *ucr = host->ucr;\n\tint err;\n\tu8 val;\n\n\tif (host->eject || host->power_mode != MEMSTICK_POWER_ON)\n\t\treturn;\n\n\tpm_runtime_get_sync(ms_dev(host));\n\tmutex_lock(&ucr->dev_mutex);\n\n\t \n\terr = rtsx_usb_read_register(ucr, CARD_INT_PEND, &val);\n\tif (err) {\n\t\tmutex_unlock(&ucr->dev_mutex);\n\t\tgoto poll_again;\n\t}\n\n\t \n\trtsx_usb_write_register(ucr, CARD_INT_PEND,\n\t\t\tXD_INT | MS_INT | SD_INT,\n\t\t\tXD_INT | MS_INT | SD_INT);\n\n\tmutex_unlock(&ucr->dev_mutex);\n\n\tif (val & MS_INT) {\n\t\tdev_dbg(ms_dev(host), \"MS slot change detected\\n\");\n\t\tmemstick_detect_change(host->msh);\n\t}\n\npoll_again:\n\tpm_runtime_put_sync(ms_dev(host));\n\n\tif (!host->eject && host->power_mode == MEMSTICK_POWER_ON)\n\t\tschedule_delayed_work(&host->poll_card, 100);\n}\n\nstatic int rtsx_usb_ms_drv_probe(struct platform_device *pdev)\n{\n\tstruct memstick_host *msh;\n\tstruct rtsx_usb_ms *host;\n\tstruct rtsx_ucr *ucr;\n\tint err;\n\n\tucr = usb_get_intfdata(to_usb_interface(pdev->dev.parent));\n\tif (!ucr)\n\t\treturn -ENXIO;\n\n\tdev_dbg(&(pdev->dev),\n\t\t\t\"Realtek USB Memstick controller found\\n\");\n\n\tmsh = memstick_alloc_host(sizeof(*host), &pdev->dev);\n\tif (!msh)\n\t\treturn -ENOMEM;\n\n\thost = memstick_priv(msh);\n\thost->ucr = ucr;\n\thost->msh = msh;\n\thost->pdev = pdev;\n\thost->power_mode = MEMSTICK_POWER_OFF;\n\tplatform_set_drvdata(pdev, host);\n\n\tmutex_init(&host->host_mutex);\n\tINIT_WORK(&host->handle_req, rtsx_usb_ms_handle_req);\n\n\tINIT_DELAYED_WORK(&host->poll_card, rtsx_usb_ms_poll_card);\n\n\tmsh->request = rtsx_usb_ms_request;\n\tmsh->set_param = rtsx_usb_ms_set_param;\n\tmsh->caps = MEMSTICK_CAP_PAR4;\n\n\tpm_runtime_get_noresume(ms_dev(host));\n\tpm_runtime_set_active(ms_dev(host));\n\tpm_runtime_enable(ms_dev(host));\n\n\terr = memstick_add_host(msh);\n\tif (err)\n\t\tgoto err_out;\n\n\tpm_runtime_put(ms_dev(host));\n\n\treturn 0;\nerr_out:\n\tpm_runtime_disable(ms_dev(host));\n\tpm_runtime_put_noidle(ms_dev(host));\n\tmemstick_free_host(msh);\n\treturn err;\n}\n\nstatic int rtsx_usb_ms_drv_remove(struct platform_device *pdev)\n{\n\tstruct rtsx_usb_ms *host = platform_get_drvdata(pdev);\n\tstruct memstick_host *msh = host->msh;\n\tint err;\n\n\thost->eject = true;\n\tcancel_work_sync(&host->handle_req);\n\n\tmutex_lock(&host->host_mutex);\n\tif (host->req) {\n\t\tdev_dbg(ms_dev(host),\n\t\t\t\"%s: Controller removed during transfer\\n\",\n\t\t\tdev_name(&msh->dev));\n\t\thost->req->error = -ENOMEDIUM;\n\t\tdo {\n\t\t\terr = memstick_next_req(msh, &host->req);\n\t\t\tif (!err)\n\t\t\t\thost->req->error = -ENOMEDIUM;\n\t\t} while (!err);\n\t}\n\tmutex_unlock(&host->host_mutex);\n\n\t \n\tif (pm_runtime_active(ms_dev(host)))\n\t\tpm_runtime_put(ms_dev(host));\n\n\tpm_runtime_disable(ms_dev(host));\n\tmemstick_remove_host(msh);\n\tdev_dbg(ms_dev(host),\n\t\t\": Realtek USB Memstick controller has been removed\\n\");\n\tmemstick_free_host(msh);\n\tplatform_set_drvdata(pdev, NULL);\n\n\treturn 0;\n}\n\nstatic struct platform_device_id rtsx_usb_ms_ids[] = {\n\t{\n\t\t.name = \"rtsx_usb_ms\",\n\t}, {\n\t\t \n\t}\n};\nMODULE_DEVICE_TABLE(platform, rtsx_usb_ms_ids);\n\nstatic struct platform_driver rtsx_usb_ms_driver = {\n\t.probe\t\t= rtsx_usb_ms_drv_probe,\n\t.remove\t\t= rtsx_usb_ms_drv_remove,\n\t.id_table       = rtsx_usb_ms_ids,\n\t.driver\t\t= {\n\t\t.name\t= \"rtsx_usb_ms\",\n\t\t.pm\t= &rtsx_usb_ms_pm_ops,\n\t},\n};\nmodule_platform_driver(rtsx_usb_ms_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Roger Tseng <rogerable@realtek.com>\");\nMODULE_DESCRIPTION(\"Realtek USB Memstick Card Host Driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}