{
  "module_name": "rtsx_pci_ms.c",
  "hash_id": "629285a3e24bf845672b3eb14845c68c4680647520a602aab477805a2370b9e1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/memstick/host/rtsx_pci_ms.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/delay.h>\n#include <linux/platform_device.h>\n#include <linux/memstick.h>\n#include <linux/rtsx_pci.h>\n#include <asm/unaligned.h>\n\nstruct realtek_pci_ms {\n\tstruct platform_device\t*pdev;\n\tstruct rtsx_pcr\t\t*pcr;\n\tstruct memstick_host\t*msh;\n\tstruct memstick_request\t*req;\n\n\tstruct mutex\t\thost_mutex;\n\tstruct work_struct\thandle_req;\n\n\tu8\t\t\tssc_depth;\n\tunsigned int\t\tclock;\n\tunsigned char           ifmode;\n\tbool\t\t\teject;\n};\n\nstatic inline struct device *ms_dev(struct realtek_pci_ms *host)\n{\n\treturn &(host->pdev->dev);\n}\n\nstatic inline void ms_clear_error(struct realtek_pci_ms *host)\n{\n\trtsx_pci_write_register(host->pcr, CARD_STOP,\n\t\t\tMS_STOP | MS_CLR_ERR, MS_STOP | MS_CLR_ERR);\n}\n\n#ifdef DEBUG\n\nstatic void ms_print_debug_regs(struct realtek_pci_ms *host)\n{\n\tstruct rtsx_pcr *pcr = host->pcr;\n\tu16 i;\n\tu8 *ptr;\n\n\t \n\trtsx_pci_init_cmd(pcr);\n\tfor (i = 0xFD40; i <= 0xFD44; i++)\n\t\trtsx_pci_add_cmd(pcr, READ_REG_CMD, i, 0, 0);\n\tfor (i = 0xFD52; i <= 0xFD69; i++)\n\t\trtsx_pci_add_cmd(pcr, READ_REG_CMD, i, 0, 0);\n\trtsx_pci_send_cmd(pcr, 100);\n\n\tptr = rtsx_pci_get_cmd_data(pcr);\n\tfor (i = 0xFD40; i <= 0xFD44; i++)\n\t\tdev_dbg(ms_dev(host), \"0x%04X: 0x%02x\\n\", i, *(ptr++));\n\tfor (i = 0xFD52; i <= 0xFD69; i++)\n\t\tdev_dbg(ms_dev(host), \"0x%04X: 0x%02x\\n\", i, *(ptr++));\n}\n\n#else\n\n#define ms_print_debug_regs(host)\n\n#endif\n\nstatic int ms_power_on(struct realtek_pci_ms *host)\n{\n\tstruct rtsx_pcr *pcr = host->pcr;\n\tint err;\n\n\trtsx_pci_init_cmd(pcr);\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, CARD_SELECT, 0x07, MS_MOD_SEL);\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, CARD_SHARE_MODE,\n\t\t\tCARD_SHARE_MASK, CARD_SHARE_48_MS);\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, CARD_CLK_EN,\n\t\t\tMS_CLK_EN, MS_CLK_EN);\n\terr = rtsx_pci_send_cmd(pcr, 100);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = rtsx_pci_card_pull_ctl_enable(pcr, RTSX_MS_CARD);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = rtsx_pci_card_power_on(pcr, RTSX_MS_CARD);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tmsleep(150);\n\n\terr = rtsx_pci_write_register(pcr, CARD_OE,\n\t\t\tMS_OUTPUT_EN, MS_OUTPUT_EN);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int ms_power_off(struct realtek_pci_ms *host)\n{\n\tstruct rtsx_pcr *pcr = host->pcr;\n\tint err;\n\n\trtsx_pci_init_cmd(pcr);\n\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, CARD_CLK_EN, MS_CLK_EN, 0);\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, CARD_OE, MS_OUTPUT_EN, 0);\n\n\terr = rtsx_pci_send_cmd(pcr, 100);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = rtsx_pci_card_power_off(pcr, RTSX_MS_CARD);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn rtsx_pci_card_pull_ctl_disable(pcr, RTSX_MS_CARD);\n}\n\nstatic int ms_transfer_data(struct realtek_pci_ms *host, unsigned char data_dir,\n\t\tu8 tpc, u8 cfg, struct scatterlist *sg)\n{\n\tstruct rtsx_pcr *pcr = host->pcr;\n\tint err;\n\tunsigned int length = sg->length;\n\tu16 sec_cnt = (u16)(length / 512);\n\tu8 val, trans_mode, dma_dir;\n\tstruct memstick_dev *card = host->msh->card;\n\tbool pro_card = card->id.type == MEMSTICK_TYPE_PRO;\n\n\tdev_dbg(ms_dev(host), \"%s: tpc = 0x%02x, data_dir = %s, length = %d\\n\",\n\t\t\t__func__, tpc, (data_dir == READ) ? \"READ\" : \"WRITE\",\n\t\t\tlength);\n\n\tif (data_dir == READ) {\n\t\tdma_dir = DMA_DIR_FROM_CARD;\n\t\ttrans_mode = pro_card ? MS_TM_AUTO_READ : MS_TM_NORMAL_READ;\n\t} else {\n\t\tdma_dir = DMA_DIR_TO_CARD;\n\t\ttrans_mode = pro_card ? MS_TM_AUTO_WRITE : MS_TM_NORMAL_WRITE;\n\t}\n\n\trtsx_pci_init_cmd(pcr);\n\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, MS_TPC, 0xFF, tpc);\n\tif (pro_card) {\n\t\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, MS_SECTOR_CNT_H,\n\t\t\t\t0xFF, (u8)(sec_cnt >> 8));\n\t\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, MS_SECTOR_CNT_L,\n\t\t\t\t0xFF, (u8)sec_cnt);\n\t}\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, MS_TRANS_CFG, 0xFF, cfg);\n\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, IRQSTAT0,\n\t\t\tDMA_DONE_INT, DMA_DONE_INT);\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, DMATC3, 0xFF, (u8)(length >> 24));\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, DMATC2, 0xFF, (u8)(length >> 16));\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, DMATC1, 0xFF, (u8)(length >> 8));\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, DMATC0, 0xFF, (u8)length);\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, DMACTL,\n\t\t\t0x03 | DMA_PACK_SIZE_MASK, dma_dir | DMA_EN | DMA_512);\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, CARD_DATA_SOURCE,\n\t\t\t0x01, RING_BUFFER);\n\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, MS_TRANSFER,\n\t\t\t0xFF, MS_TRANSFER_START | trans_mode);\n\trtsx_pci_add_cmd(pcr, CHECK_REG_CMD, MS_TRANSFER,\n\t\t\tMS_TRANSFER_END, MS_TRANSFER_END);\n\n\trtsx_pci_send_cmd_no_wait(pcr);\n\n\terr = rtsx_pci_transfer_data(pcr, sg, 1, data_dir == READ, 10000);\n\tif (err < 0) {\n\t\tms_clear_error(host);\n\t\treturn err;\n\t}\n\n\trtsx_pci_read_register(pcr, MS_TRANS_CFG, &val);\n\tif (pro_card) {\n\t\tif (val & (MS_INT_CMDNK | MS_INT_ERR |\n\t\t\t\tMS_CRC16_ERR | MS_RDY_TIMEOUT))\n\t\t\treturn -EIO;\n\t} else {\n\t\tif (val & (MS_CRC16_ERR | MS_RDY_TIMEOUT))\n\t\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int ms_write_bytes(struct realtek_pci_ms *host, u8 tpc,\n\t\tu8 cfg, u8 cnt, u8 *data, u8 *int_reg)\n{\n\tstruct rtsx_pcr *pcr = host->pcr;\n\tint err, i;\n\n\tdev_dbg(ms_dev(host), \"%s: tpc = 0x%02x\\n\", __func__, tpc);\n\n\tif (!data)\n\t\treturn -EINVAL;\n\n\trtsx_pci_init_cmd(pcr);\n\n\tfor (i = 0; i < cnt; i++)\n\t\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD,\n\t\t\t\tPPBUF_BASE2 + i, 0xFF, data[i]);\n\tif (cnt % 2)\n\t\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD,\n\t\t\t\tPPBUF_BASE2 + i, 0xFF, 0xFF);\n\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, MS_TPC, 0xFF, tpc);\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, MS_BYTE_CNT, 0xFF, cnt);\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, MS_TRANS_CFG, 0xFF, cfg);\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, CARD_DATA_SOURCE,\n\t\t\t0x01, PINGPONG_BUFFER);\n\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, MS_TRANSFER,\n\t\t\t0xFF, MS_TRANSFER_START | MS_TM_WRITE_BYTES);\n\trtsx_pci_add_cmd(pcr, CHECK_REG_CMD, MS_TRANSFER,\n\t\t\tMS_TRANSFER_END, MS_TRANSFER_END);\n\tif (int_reg)\n\t\trtsx_pci_add_cmd(pcr, READ_REG_CMD, MS_TRANS_CFG, 0, 0);\n\n\terr = rtsx_pci_send_cmd(pcr, 5000);\n\tif (err < 0) {\n\t\tu8 val;\n\n\t\trtsx_pci_read_register(pcr, MS_TRANS_CFG, &val);\n\t\tdev_dbg(ms_dev(host), \"MS_TRANS_CFG: 0x%02x\\n\", val);\n\n\t\tif (int_reg)\n\t\t\t*int_reg = val & 0x0F;\n\n\t\tms_print_debug_regs(host);\n\n\t\tms_clear_error(host);\n\n\t\tif (!(tpc & 0x08)) {\n\t\t\tif (val & MS_CRC16_ERR)\n\t\t\t\treturn -EIO;\n\t\t} else {\n\t\t\tif (!(val & 0x80)) {\n\t\t\t\tif (val & (MS_INT_ERR | MS_INT_CMDNK))\n\t\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tif (int_reg) {\n\t\tu8 *ptr = rtsx_pci_get_cmd_data(pcr) + 1;\n\t\t*int_reg = *ptr & 0x0F;\n\t}\n\n\treturn 0;\n}\n\nstatic int ms_read_bytes(struct realtek_pci_ms *host, u8 tpc,\n\t\tu8 cfg, u8 cnt, u8 *data, u8 *int_reg)\n{\n\tstruct rtsx_pcr *pcr = host->pcr;\n\tint err, i;\n\tu8 *ptr;\n\n\tdev_dbg(ms_dev(host), \"%s: tpc = 0x%02x\\n\", __func__, tpc);\n\n\tif (!data)\n\t\treturn -EINVAL;\n\n\trtsx_pci_init_cmd(pcr);\n\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, MS_TPC, 0xFF, tpc);\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, MS_BYTE_CNT, 0xFF, cnt);\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, MS_TRANS_CFG, 0xFF, cfg);\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, CARD_DATA_SOURCE,\n\t\t\t0x01, PINGPONG_BUFFER);\n\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, MS_TRANSFER,\n\t\t\t0xFF, MS_TRANSFER_START | MS_TM_READ_BYTES);\n\trtsx_pci_add_cmd(pcr, CHECK_REG_CMD, MS_TRANSFER,\n\t\t\tMS_TRANSFER_END, MS_TRANSFER_END);\n\tfor (i = 0; i < cnt - 1; i++)\n\t\trtsx_pci_add_cmd(pcr, READ_REG_CMD, PPBUF_BASE2 + i, 0, 0);\n\tif (cnt % 2)\n\t\trtsx_pci_add_cmd(pcr, READ_REG_CMD, PPBUF_BASE2 + cnt, 0, 0);\n\telse\n\t\trtsx_pci_add_cmd(pcr, READ_REG_CMD,\n\t\t\t\tPPBUF_BASE2 + cnt - 1, 0, 0);\n\tif (int_reg)\n\t\trtsx_pci_add_cmd(pcr, READ_REG_CMD, MS_TRANS_CFG, 0, 0);\n\n\terr = rtsx_pci_send_cmd(pcr, 5000);\n\tif (err < 0) {\n\t\tu8 val;\n\n\t\trtsx_pci_read_register(pcr, MS_TRANS_CFG, &val);\n\t\tdev_dbg(ms_dev(host), \"MS_TRANS_CFG: 0x%02x\\n\", val);\n\n\t\tif (int_reg)\n\t\t\t*int_reg = val & 0x0F;\n\n\t\tms_print_debug_regs(host);\n\n\t\tms_clear_error(host);\n\n\t\tif (!(tpc & 0x08)) {\n\t\t\tif (val & MS_CRC16_ERR)\n\t\t\t\treturn -EIO;\n\t\t} else {\n\t\t\tif (!(val & 0x80)) {\n\t\t\t\tif (val & (MS_INT_ERR | MS_INT_CMDNK))\n\t\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tptr = rtsx_pci_get_cmd_data(pcr) + 1;\n\tfor (i = 0; i < cnt; i++)\n\t\tdata[i] = *ptr++;\n\n\tif (int_reg)\n\t\t*int_reg = *ptr & 0x0F;\n\n\treturn 0;\n}\n\nstatic int rtsx_pci_ms_issue_cmd(struct realtek_pci_ms *host)\n{\n\tstruct memstick_request *req = host->req;\n\tint err = 0;\n\tu8 cfg = 0, int_reg;\n\n\tdev_dbg(ms_dev(host), \"%s\\n\", __func__);\n\n\tif (req->need_card_int) {\n\t\tif (host->ifmode != MEMSTICK_SERIAL)\n\t\t\tcfg = WAIT_INT;\n\t}\n\n\tif (req->long_data) {\n\t\terr = ms_transfer_data(host, req->data_dir,\n\t\t\t\treq->tpc, cfg, &(req->sg));\n\t} else {\n\t\tif (req->data_dir == READ) {\n\t\t\terr = ms_read_bytes(host, req->tpc, cfg,\n\t\t\t\t\treq->data_len, req->data, &int_reg);\n\t\t} else {\n\t\t\terr = ms_write_bytes(host, req->tpc, cfg,\n\t\t\t\t\treq->data_len, req->data, &int_reg);\n\t\t}\n\t}\n\tif (err < 0)\n\t\treturn err;\n\n\tif (req->need_card_int && (host->ifmode == MEMSTICK_SERIAL)) {\n\t\terr = ms_read_bytes(host, MS_TPC_GET_INT,\n\t\t\t\tNO_WAIT_INT, 1, &int_reg, NULL);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (req->need_card_int) {\n\t\tdev_dbg(ms_dev(host), \"int_reg: 0x%02x\\n\", int_reg);\n\n\t\tif (int_reg & MS_INT_CMDNK)\n\t\t\treq->int_reg |= MEMSTICK_INT_CMDNAK;\n\t\tif (int_reg & MS_INT_BREQ)\n\t\t\treq->int_reg |= MEMSTICK_INT_BREQ;\n\t\tif (int_reg & MS_INT_ERR)\n\t\t\treq->int_reg |= MEMSTICK_INT_ERR;\n\t\tif (int_reg & MS_INT_CED)\n\t\t\treq->int_reg |= MEMSTICK_INT_CED;\n\t}\n\n\treturn 0;\n}\n\nstatic void rtsx_pci_ms_handle_req(struct work_struct *work)\n{\n\tstruct realtek_pci_ms *host = container_of(work,\n\t\t\tstruct realtek_pci_ms, handle_req);\n\tstruct rtsx_pcr *pcr = host->pcr;\n\tstruct memstick_host *msh = host->msh;\n\tint rc;\n\n\tmutex_lock(&pcr->pcr_mutex);\n\n\trtsx_pci_start_run(pcr);\n\n\trtsx_pci_switch_clock(host->pcr, host->clock, host->ssc_depth,\n\t\t\tfalse, true, false);\n\trtsx_pci_write_register(pcr, CARD_SELECT, 0x07, MS_MOD_SEL);\n\trtsx_pci_write_register(pcr, CARD_SHARE_MODE,\n\t\t\tCARD_SHARE_MASK, CARD_SHARE_48_MS);\n\n\tif (!host->req) {\n\t\tdo {\n\t\t\trc = memstick_next_req(msh, &host->req);\n\t\t\tdev_dbg(ms_dev(host), \"next req %d\\n\", rc);\n\n\t\t\tif (!rc)\n\t\t\t\thost->req->error = rtsx_pci_ms_issue_cmd(host);\n\t\t} while (!rc);\n\t}\n\n\tmutex_unlock(&pcr->pcr_mutex);\n}\n\nstatic void rtsx_pci_ms_request(struct memstick_host *msh)\n{\n\tstruct realtek_pci_ms *host = memstick_priv(msh);\n\n\tdev_dbg(ms_dev(host), \"--> %s\\n\", __func__);\n\n\tif (rtsx_pci_card_exclusive_check(host->pcr, RTSX_MS_CARD))\n\t\treturn;\n\n\tschedule_work(&host->handle_req);\n}\n\nstatic int rtsx_pci_ms_set_param(struct memstick_host *msh,\n\t\tenum memstick_param param, int value)\n{\n\tstruct realtek_pci_ms *host = memstick_priv(msh);\n\tstruct rtsx_pcr *pcr = host->pcr;\n\tunsigned int clock = 0;\n\tu8 ssc_depth = 0;\n\tint err;\n\n\tdev_dbg(ms_dev(host), \"%s: param = %d, value = %d\\n\",\n\t\t\t__func__, param, value);\n\n\terr = rtsx_pci_card_exclusive_check(host->pcr, RTSX_MS_CARD);\n\tif (err)\n\t\treturn err;\n\n\tswitch (param) {\n\tcase MEMSTICK_POWER:\n\t\tif (value == MEMSTICK_POWER_ON)\n\t\t\terr = ms_power_on(host);\n\t\telse if (value == MEMSTICK_POWER_OFF)\n\t\t\terr = ms_power_off(host);\n\t\telse\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\tcase MEMSTICK_INTERFACE:\n\t\tif (value == MEMSTICK_SERIAL) {\n\t\t\tclock = 19000000;\n\t\t\tssc_depth = RTSX_SSC_DEPTH_500K;\n\n\t\t\terr = rtsx_pci_write_register(pcr, MS_CFG, 0x58,\n\t\t\t\t\tMS_BUS_WIDTH_1 | PUSH_TIME_DEFAULT);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t} else if (value == MEMSTICK_PAR4) {\n\t\t\tclock = 39000000;\n\t\t\tssc_depth = RTSX_SSC_DEPTH_1M;\n\n\t\t\terr = rtsx_pci_write_register(pcr, MS_CFG,\n\t\t\t\t\t0x58, MS_BUS_WIDTH_4 | PUSH_TIME_ODD);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\terr = rtsx_pci_switch_clock(pcr, clock,\n\t\t\t\tssc_depth, false, true, false);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\thost->ssc_depth = ssc_depth;\n\t\thost->clock = clock;\n\t\thost->ifmode = value;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\n\nstatic int rtsx_pci_ms_suspend(struct platform_device *pdev, pm_message_t state)\n{\n\tstruct realtek_pci_ms *host = platform_get_drvdata(pdev);\n\tstruct memstick_host *msh = host->msh;\n\n\tdev_dbg(ms_dev(host), \"--> %s\\n\", __func__);\n\n\tmemstick_suspend_host(msh);\n\treturn 0;\n}\n\nstatic int rtsx_pci_ms_resume(struct platform_device *pdev)\n{\n\tstruct realtek_pci_ms *host = platform_get_drvdata(pdev);\n\tstruct memstick_host *msh = host->msh;\n\n\tdev_dbg(ms_dev(host), \"--> %s\\n\", __func__);\n\n\tmemstick_resume_host(msh);\n\treturn 0;\n}\n\n#else  \n\n#define rtsx_pci_ms_suspend NULL\n#define rtsx_pci_ms_resume NULL\n\n#endif  \n\nstatic void rtsx_pci_ms_card_event(struct platform_device *pdev)\n{\n\tstruct realtek_pci_ms *host = platform_get_drvdata(pdev);\n\n\tmemstick_detect_change(host->msh);\n}\n\nstatic int rtsx_pci_ms_drv_probe(struct platform_device *pdev)\n{\n\tstruct memstick_host *msh;\n\tstruct realtek_pci_ms *host;\n\tstruct rtsx_pcr *pcr;\n\tstruct pcr_handle *handle = pdev->dev.platform_data;\n\tint rc;\n\n\tif (!handle)\n\t\treturn -ENXIO;\n\n\tpcr = handle->pcr;\n\tif (!pcr)\n\t\treturn -ENXIO;\n\n\tdev_dbg(&(pdev->dev),\n\t\t\t\": Realtek PCI-E Memstick controller found\\n\");\n\n\tmsh = memstick_alloc_host(sizeof(*host), &pdev->dev);\n\tif (!msh)\n\t\treturn -ENOMEM;\n\n\thost = memstick_priv(msh);\n\thost->pcr = pcr;\n\thost->msh = msh;\n\thost->pdev = pdev;\n\tplatform_set_drvdata(pdev, host);\n\tpcr->slots[RTSX_MS_CARD].p_dev = pdev;\n\tpcr->slots[RTSX_MS_CARD].card_event = rtsx_pci_ms_card_event;\n\n\tmutex_init(&host->host_mutex);\n\n\tINIT_WORK(&host->handle_req, rtsx_pci_ms_handle_req);\n\tmsh->request = rtsx_pci_ms_request;\n\tmsh->set_param = rtsx_pci_ms_set_param;\n\tmsh->caps = MEMSTICK_CAP_PAR4;\n\n\trc = memstick_add_host(msh);\n\tif (rc) {\n\t\tmemstick_free_host(msh);\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic int rtsx_pci_ms_drv_remove(struct platform_device *pdev)\n{\n\tstruct realtek_pci_ms *host = platform_get_drvdata(pdev);\n\tstruct rtsx_pcr *pcr;\n\tstruct memstick_host *msh;\n\tint rc;\n\n\tif (!host)\n\t\treturn 0;\n\n\tpcr = host->pcr;\n\tpcr->slots[RTSX_MS_CARD].p_dev = NULL;\n\tpcr->slots[RTSX_MS_CARD].card_event = NULL;\n\tmsh = host->msh;\n\thost->eject = true;\n\tcancel_work_sync(&host->handle_req);\n\n\tmutex_lock(&host->host_mutex);\n\tif (host->req) {\n\t\tdev_dbg(&(pdev->dev),\n\t\t\t\"%s: Controller removed during transfer\\n\",\n\t\t\tdev_name(&msh->dev));\n\n\t\trtsx_pci_complete_unfinished_transfer(pcr);\n\n\t\thost->req->error = -ENOMEDIUM;\n\t\tdo {\n\t\t\trc = memstick_next_req(msh, &host->req);\n\t\t\tif (!rc)\n\t\t\t\thost->req->error = -ENOMEDIUM;\n\t\t} while (!rc);\n\t}\n\tmutex_unlock(&host->host_mutex);\n\n\tmemstick_remove_host(msh);\n\tmemstick_free_host(msh);\n\n\tdev_dbg(&(pdev->dev),\n\t\t\": Realtek PCI-E Memstick controller has been removed\\n\");\n\n\treturn 0;\n}\n\nstatic struct platform_device_id rtsx_pci_ms_ids[] = {\n\t{\n\t\t.name = DRV_NAME_RTSX_PCI_MS,\n\t}, {\n\t\t \n\t}\n};\nMODULE_DEVICE_TABLE(platform, rtsx_pci_ms_ids);\n\nstatic struct platform_driver rtsx_pci_ms_driver = {\n\t.probe\t\t= rtsx_pci_ms_drv_probe,\n\t.remove\t\t= rtsx_pci_ms_drv_remove,\n\t.id_table       = rtsx_pci_ms_ids,\n\t.suspend\t= rtsx_pci_ms_suspend,\n\t.resume\t\t= rtsx_pci_ms_resume,\n\t.driver\t\t= {\n\t\t.name\t= DRV_NAME_RTSX_PCI_MS,\n\t},\n};\nmodule_platform_driver(rtsx_pci_ms_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Wei WANG <wei_wang@realsil.com.cn>\");\nMODULE_DESCRIPTION(\"Realtek PCI-E Memstick Card Host Driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}