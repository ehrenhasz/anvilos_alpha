{
  "module_name": "da903x.c",
  "hash_id": "78486b64452d20c1f7f4a21f570fa280e445c20c064ac0c0c8443c0d4b1a9a1d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/da903x.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/i2c.h>\n#include <linux/mfd/da903x.h>\n#include <linux/slab.h>\n\n#define DA9030_CHIP_ID\t\t0x00\n#define DA9030_EVENT_A\t\t0x01\n#define DA9030_EVENT_B\t\t0x02\n#define DA9030_EVENT_C\t\t0x03\n#define DA9030_STATUS\t\t0x04\n#define DA9030_IRQ_MASK_A\t0x05\n#define DA9030_IRQ_MASK_B\t0x06\n#define DA9030_IRQ_MASK_C\t0x07\n#define DA9030_SYS_CTRL_A\t0x08\n#define DA9030_SYS_CTRL_B\t0x09\n#define DA9030_FAULT_LOG\t0x0a\n\n#define DA9034_CHIP_ID\t\t0x00\n#define DA9034_EVENT_A\t\t0x01\n#define DA9034_EVENT_B\t\t0x02\n#define DA9034_EVENT_C\t\t0x03\n#define DA9034_EVENT_D\t\t0x04\n#define DA9034_STATUS_A\t\t0x05\n#define DA9034_STATUS_B\t\t0x06\n#define DA9034_IRQ_MASK_A\t0x07\n#define DA9034_IRQ_MASK_B\t0x08\n#define DA9034_IRQ_MASK_C\t0x09\n#define DA9034_IRQ_MASK_D\t0x0a\n#define DA9034_SYS_CTRL_A\t0x0b\n#define DA9034_SYS_CTRL_B\t0x0c\n#define DA9034_FAULT_LOG\t0x0d\n\nstruct da903x_chip;\n\nstruct da903x_chip_ops {\n\tint\t(*init_chip)(struct da903x_chip *);\n\tint\t(*unmask_events)(struct da903x_chip *, unsigned int events);\n\tint\t(*mask_events)(struct da903x_chip *, unsigned int events);\n\tint\t(*read_events)(struct da903x_chip *, unsigned int *events);\n\tint\t(*read_status)(struct da903x_chip *, unsigned int *status);\n};\n\nstruct da903x_chip {\n\tstruct i2c_client\t*client;\n\tstruct device\t\t*dev;\n\tconst struct da903x_chip_ops *ops;\n\n\tint\t\t\ttype;\n\tuint32_t\t\tevents_mask;\n\n\tstruct mutex\t\tlock;\n\tstruct work_struct\tirq_work;\n\n\tstruct blocking_notifier_head notifier_list;\n};\n\nstatic inline int __da903x_read(struct i2c_client *client,\n\t\t\t\tint reg, uint8_t *val)\n{\n\tint ret;\n\n\tret = i2c_smbus_read_byte_data(client, reg);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"failed reading at 0x%02x\\n\", reg);\n\t\treturn ret;\n\t}\n\n\t*val = (uint8_t)ret;\n\treturn 0;\n}\n\nstatic inline int __da903x_reads(struct i2c_client *client, int reg,\n\t\t\t\t int len, uint8_t *val)\n{\n\tint ret;\n\n\tret = i2c_smbus_read_i2c_block_data(client, reg, len, val);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"failed reading from 0x%02x\\n\", reg);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic inline int __da903x_write(struct i2c_client *client,\n\t\t\t\t int reg, uint8_t val)\n{\n\tint ret;\n\n\tret = i2c_smbus_write_byte_data(client, reg, val);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"failed writing 0x%02x to 0x%02x\\n\",\n\t\t\t\tval, reg);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic inline int __da903x_writes(struct i2c_client *client, int reg,\n\t\t\t\t  int len, uint8_t *val)\n{\n\tint ret;\n\n\tret = i2c_smbus_write_i2c_block_data(client, reg, len, val);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"failed writings to 0x%02x\\n\", reg);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nint da903x_register_notifier(struct device *dev, struct notifier_block *nb,\n\t\t\t\tunsigned int events)\n{\n\tstruct da903x_chip *chip = dev_get_drvdata(dev);\n\n\tchip->ops->unmask_events(chip, events);\n\treturn blocking_notifier_chain_register(&chip->notifier_list, nb);\n}\nEXPORT_SYMBOL_GPL(da903x_register_notifier);\n\nint da903x_unregister_notifier(struct device *dev, struct notifier_block *nb,\n\t\t\t\tunsigned int events)\n{\n\tstruct da903x_chip *chip = dev_get_drvdata(dev);\n\n\tchip->ops->mask_events(chip, events);\n\treturn blocking_notifier_chain_unregister(&chip->notifier_list, nb);\n}\nEXPORT_SYMBOL_GPL(da903x_unregister_notifier);\n\nint da903x_write(struct device *dev, int reg, uint8_t val)\n{\n\treturn __da903x_write(to_i2c_client(dev), reg, val);\n}\nEXPORT_SYMBOL_GPL(da903x_write);\n\nint da903x_writes(struct device *dev, int reg, int len, uint8_t *val)\n{\n\treturn __da903x_writes(to_i2c_client(dev), reg, len, val);\n}\nEXPORT_SYMBOL_GPL(da903x_writes);\n\nint da903x_read(struct device *dev, int reg, uint8_t *val)\n{\n\treturn __da903x_read(to_i2c_client(dev), reg, val);\n}\nEXPORT_SYMBOL_GPL(da903x_read);\n\nint da903x_reads(struct device *dev, int reg, int len, uint8_t *val)\n{\n\treturn __da903x_reads(to_i2c_client(dev), reg, len, val);\n}\nEXPORT_SYMBOL_GPL(da903x_reads);\n\nint da903x_set_bits(struct device *dev, int reg, uint8_t bit_mask)\n{\n\tstruct da903x_chip *chip = dev_get_drvdata(dev);\n\tuint8_t reg_val;\n\tint ret = 0;\n\n\tmutex_lock(&chip->lock);\n\n\tret = __da903x_read(chip->client, reg, &reg_val);\n\tif (ret)\n\t\tgoto out;\n\n\tif ((reg_val & bit_mask) != bit_mask) {\n\t\treg_val |= bit_mask;\n\t\tret = __da903x_write(chip->client, reg, reg_val);\n\t}\nout:\n\tmutex_unlock(&chip->lock);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(da903x_set_bits);\n\nint da903x_clr_bits(struct device *dev, int reg, uint8_t bit_mask)\n{\n\tstruct da903x_chip *chip = dev_get_drvdata(dev);\n\tuint8_t reg_val;\n\tint ret = 0;\n\n\tmutex_lock(&chip->lock);\n\n\tret = __da903x_read(chip->client, reg, &reg_val);\n\tif (ret)\n\t\tgoto out;\n\n\tif (reg_val & bit_mask) {\n\t\treg_val &= ~bit_mask;\n\t\tret = __da903x_write(chip->client, reg, reg_val);\n\t}\nout:\n\tmutex_unlock(&chip->lock);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(da903x_clr_bits);\n\nint da903x_update(struct device *dev, int reg, uint8_t val, uint8_t mask)\n{\n\tstruct da903x_chip *chip = dev_get_drvdata(dev);\n\tuint8_t reg_val;\n\tint ret = 0;\n\n\tmutex_lock(&chip->lock);\n\n\tret = __da903x_read(chip->client, reg, &reg_val);\n\tif (ret)\n\t\tgoto out;\n\n\tif ((reg_val & mask) != val) {\n\t\treg_val = (reg_val & ~mask) | val;\n\t\tret = __da903x_write(chip->client, reg, reg_val);\n\t}\nout:\n\tmutex_unlock(&chip->lock);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(da903x_update);\n\nint da903x_query_status(struct device *dev, unsigned int sbits)\n{\n\tstruct da903x_chip *chip = dev_get_drvdata(dev);\n\tunsigned int status = 0;\n\n\tchip->ops->read_status(chip, &status);\n\treturn ((status & sbits) == sbits);\n}\nEXPORT_SYMBOL(da903x_query_status);\n\nstatic int da9030_init_chip(struct da903x_chip *chip)\n{\n\tuint8_t chip_id;\n\tint err;\n\n\terr = __da903x_read(chip->client, DA9030_CHIP_ID, &chip_id);\n\tif (err)\n\t\treturn err;\n\n\terr = __da903x_write(chip->client, DA9030_SYS_CTRL_A, 0xE8);\n\tif (err)\n\t\treturn err;\n\n\tdev_info(chip->dev, \"DA9030 (CHIP ID: 0x%02x) detected\\n\", chip_id);\n\treturn 0;\n}\n\nstatic int da9030_unmask_events(struct da903x_chip *chip, unsigned int events)\n{\n\tuint8_t v[3];\n\n\tchip->events_mask &= ~events;\n\n\tv[0] = (chip->events_mask & 0xff);\n\tv[1] = (chip->events_mask >> 8) & 0xff;\n\tv[2] = (chip->events_mask >> 16) & 0xff;\n\n\treturn __da903x_writes(chip->client, DA9030_IRQ_MASK_A, 3, v);\n}\n\nstatic int da9030_mask_events(struct da903x_chip *chip, unsigned int events)\n{\n\tuint8_t v[3];\n\n\tchip->events_mask |= events;\n\n\tv[0] = (chip->events_mask & 0xff);\n\tv[1] = (chip->events_mask >> 8) & 0xff;\n\tv[2] = (chip->events_mask >> 16) & 0xff;\n\n\treturn __da903x_writes(chip->client, DA9030_IRQ_MASK_A, 3, v);\n}\n\nstatic int da9030_read_events(struct da903x_chip *chip, unsigned int *events)\n{\n\tuint8_t v[3] = {0, 0, 0};\n\tint ret;\n\n\tret = __da903x_reads(chip->client, DA9030_EVENT_A, 3, v);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*events = (v[2] << 16) | (v[1] << 8) | v[0];\n\treturn 0;\n}\n\nstatic int da9030_read_status(struct da903x_chip *chip, unsigned int *status)\n{\n\treturn __da903x_read(chip->client, DA9030_STATUS, (uint8_t *)status);\n}\n\nstatic int da9034_init_chip(struct da903x_chip *chip)\n{\n\tuint8_t chip_id;\n\tint err;\n\n\terr = __da903x_read(chip->client, DA9034_CHIP_ID, &chip_id);\n\tif (err)\n\t\treturn err;\n\n\terr = __da903x_write(chip->client, DA9034_SYS_CTRL_A, 0xE8);\n\tif (err)\n\t\treturn err;\n\n\t \n\t__da903x_write(chip->client, 0x10, 0x07);\n\t__da903x_write(chip->client, 0x11, 0xff);\n\t__da903x_write(chip->client, 0x12, 0xff);\n\n\t \n\t__da903x_write(chip->client, DA9034_SYS_CTRL_B, 0x20);\n\t__da903x_write(chip->client, DA9034_SYS_CTRL_A, 0x60);\n\n\t \n\t__da903x_write(chip->client, 0x90, 0x01);\n\t__da903x_write(chip->client, 0xB0, 0x08);\n\n\t \n\t__da903x_write(chip->client, 0x20, 0x00);\n\n\tdev_info(chip->dev, \"DA9034 (CHIP ID: 0x%02x) detected\\n\", chip_id);\n\treturn 0;\n}\n\nstatic int da9034_unmask_events(struct da903x_chip *chip, unsigned int events)\n{\n\tuint8_t v[4];\n\n\tchip->events_mask &= ~events;\n\n\tv[0] = (chip->events_mask & 0xff);\n\tv[1] = (chip->events_mask >> 8) & 0xff;\n\tv[2] = (chip->events_mask >> 16) & 0xff;\n\tv[3] = (chip->events_mask >> 24) & 0xff;\n\n\treturn __da903x_writes(chip->client, DA9034_IRQ_MASK_A, 4, v);\n}\n\nstatic int da9034_mask_events(struct da903x_chip *chip, unsigned int events)\n{\n\tuint8_t v[4];\n\n\tchip->events_mask |= events;\n\n\tv[0] = (chip->events_mask & 0xff);\n\tv[1] = (chip->events_mask >> 8) & 0xff;\n\tv[2] = (chip->events_mask >> 16) & 0xff;\n\tv[3] = (chip->events_mask >> 24) & 0xff;\n\n\treturn __da903x_writes(chip->client, DA9034_IRQ_MASK_A, 4, v);\n}\n\nstatic int da9034_read_events(struct da903x_chip *chip, unsigned int *events)\n{\n\tuint8_t v[4] = {0, 0, 0, 0};\n\tint ret;\n\n\tret = __da903x_reads(chip->client, DA9034_EVENT_A, 4, v);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*events = (v[3] << 24) | (v[2] << 16) | (v[1] << 8) | v[0];\n\treturn 0;\n}\n\nstatic int da9034_read_status(struct da903x_chip *chip, unsigned int *status)\n{\n\tuint8_t v[2] = {0, 0};\n\tint ret = 0;\n\n\tret = __da903x_reads(chip->client, DA9034_STATUS_A, 2, v);\n\tif (ret)\n\t\treturn ret;\n\n\t*status = (v[1] << 8) | v[0];\n\treturn 0;\n}\n\nstatic void da903x_irq_work(struct work_struct *work)\n{\n\tstruct da903x_chip *chip =\n\t\tcontainer_of(work, struct da903x_chip, irq_work);\n\tunsigned int events = 0;\n\n\twhile (1) {\n\t\tif (chip->ops->read_events(chip, &events))\n\t\t\tbreak;\n\n\t\tevents &= ~chip->events_mask;\n\t\tif (events == 0)\n\t\t\tbreak;\n\n\t\tblocking_notifier_call_chain(\n\t\t\t\t&chip->notifier_list, events, NULL);\n\t}\n\tenable_irq(chip->client->irq);\n}\n\nstatic irqreturn_t da903x_irq_handler(int irq, void *data)\n{\n\tstruct da903x_chip *chip = data;\n\n\tdisable_irq_nosync(irq);\n\t(void)schedule_work(&chip->irq_work);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct da903x_chip_ops da903x_ops[] = {\n\t[0] = {\n\t\t.init_chip\t= da9030_init_chip,\n\t\t.unmask_events\t= da9030_unmask_events,\n\t\t.mask_events\t= da9030_mask_events,\n\t\t.read_events\t= da9030_read_events,\n\t\t.read_status\t= da9030_read_status,\n\t},\n\t[1] = {\n\t\t.init_chip\t= da9034_init_chip,\n\t\t.unmask_events\t= da9034_unmask_events,\n\t\t.mask_events\t= da9034_mask_events,\n\t\t.read_events\t= da9034_read_events,\n\t\t.read_status\t= da9034_read_status,\n\t}\n};\n\nstatic const struct i2c_device_id da903x_id_table[] = {\n\t{ \"da9030\", 0 },\n\t{ \"da9034\", 1 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(i2c, da903x_id_table);\n\nstatic int __remove_subdev(struct device *dev, void *unused)\n{\n\tplatform_device_unregister(to_platform_device(dev));\n\treturn 0;\n}\n\nstatic int da903x_remove_subdevs(struct da903x_chip *chip)\n{\n\treturn device_for_each_child(chip->dev, NULL, __remove_subdev);\n}\n\nstatic int da903x_add_subdevs(struct da903x_chip *chip,\n\t\t\t\t\tstruct da903x_platform_data *pdata)\n{\n\tstruct da903x_subdev_info *subdev;\n\tstruct platform_device *pdev;\n\tint i, ret = 0;\n\n\tfor (i = 0; i < pdata->num_subdevs; i++) {\n\t\tsubdev = &pdata->subdevs[i];\n\n\t\tpdev = platform_device_alloc(subdev->name, subdev->id);\n\t\tif (!pdev) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tpdev->dev.parent = chip->dev;\n\t\tpdev->dev.platform_data = subdev->platform_data;\n\n\t\tret = platform_device_add(pdev);\n\t\tif (ret) {\n\t\t\tplatform_device_put(pdev);\n\t\t\tgoto failed;\n\t\t}\n\t}\n\treturn 0;\n\nfailed:\n\tda903x_remove_subdevs(chip);\n\treturn ret;\n}\n\nstatic int da903x_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct da903x_platform_data *pdata = dev_get_platdata(&client->dev);\n\tstruct da903x_chip *chip;\n\tunsigned int tmp;\n\tint ret;\n\n\tchip = devm_kzalloc(&client->dev, sizeof(struct da903x_chip),\n\t\t\t\tGFP_KERNEL);\n\tif (chip == NULL)\n\t\treturn -ENOMEM;\n\n\tchip->client = client;\n\tchip->dev = &client->dev;\n\tchip->ops = &da903x_ops[id->driver_data];\n\n\tmutex_init(&chip->lock);\n\tINIT_WORK(&chip->irq_work, da903x_irq_work);\n\tBLOCKING_INIT_NOTIFIER_HEAD(&chip->notifier_list);\n\n\ti2c_set_clientdata(client, chip);\n\n\tret = chip->ops->init_chip(chip);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tchip->events_mask = 0xffffffff;\n\tchip->ops->mask_events(chip, chip->events_mask);\n\tchip->ops->read_events(chip, &tmp);\n\n\tret = devm_request_irq(&client->dev, client->irq, da903x_irq_handler,\n\t\t\tIRQF_TRIGGER_FALLING,\n\t\t\t\"da903x\", chip);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"failed to request irq %d\\n\",\n\t\t\t\tclient->irq);\n\t\treturn ret;\n\t}\n\n\treturn da903x_add_subdevs(chip, pdata);\n}\n\nstatic void da903x_remove(struct i2c_client *client)\n{\n\tstruct da903x_chip *chip = i2c_get_clientdata(client);\n\n\tda903x_remove_subdevs(chip);\n}\n\nstatic struct i2c_driver da903x_driver = {\n\t.driver\t= {\n\t\t.name\t= \"da903x\",\n\t},\n\t.probe\t\t= da903x_probe,\n\t.remove\t\t= da903x_remove,\n\t.id_table\t= da903x_id_table,\n};\n\nstatic int __init da903x_init(void)\n{\n\treturn i2c_add_driver(&da903x_driver);\n}\nsubsys_initcall(da903x_init);\n\nstatic void __exit da903x_exit(void)\n{\n\ti2c_del_driver(&da903x_driver);\n}\nmodule_exit(da903x_exit);\n\nMODULE_DESCRIPTION(\"PMIC Driver for Dialog Semiconductor DA9034\");\nMODULE_AUTHOR(\"Eric Miao <eric.miao@marvell.com>\");\nMODULE_AUTHOR(\"Mike Rapoport <mike@compulab.co.il>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}