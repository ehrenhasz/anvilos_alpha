{
  "module_name": "max77843.c",
  "hash_id": "293a0076b8653370b77729554bc64481695d2d375f8eb09140713deee97536a1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/max77843.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/max77693-common.h>\n#include <linux/mfd/max77843-private.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n\nstatic const struct mfd_cell max77843_devs[] = {\n\t{\n\t\t.name = \"max77843-muic\",\n\t\t.of_compatible = \"maxim,max77843-muic\",\n\t}, {\n\t\t.name = \"max77843-regulator\",\n\t\t.of_compatible = \"maxim,max77843-regulator\",\n\t}, {\n\t\t.name = \"max77843-charger\",\n\t\t.of_compatible = \"maxim,max77843-charger\"\n\t}, {\n\t\t.name = \"max77843-fuelgauge\",\n\t\t.of_compatible = \"maxim,max77843-fuelgauge\",\n\t}, {\n\t\t.name = \"max77843-haptic\",\n\t\t.of_compatible = \"maxim,max77843-haptic\",\n\t},\n};\n\nstatic const struct regmap_config max77843_charger_regmap_config = {\n\t.reg_bits\t= 8,\n\t.val_bits\t= 8,\n\t.max_register\t= MAX77843_CHG_REG_END,\n};\n\nstatic const struct regmap_config max77843_regmap_config = {\n\t.reg_bits\t= 8,\n\t.val_bits\t= 8,\n\t.max_register\t= MAX77843_SYS_REG_END,\n};\n\nstatic const struct regmap_irq max77843_irqs[] = {\n\t \n\t{ .reg_offset = 0, .mask = MAX77843_SYS_IRQ_SYSUVLO_INT, },\n\t{ .reg_offset = 0, .mask = MAX77843_SYS_IRQ_SYSOVLO_INT, },\n\t{ .reg_offset = 0, .mask = MAX77843_SYS_IRQ_TSHDN_INT, },\n\t{ .reg_offset = 0, .mask = MAX77843_SYS_IRQ_TM_INT, },\n};\n\nstatic const struct regmap_irq_chip max77843_irq_chip = {\n\t.name\t\t= \"max77843\",\n\t.status_base\t= MAX77843_SYS_REG_SYSINTSRC,\n\t.mask_base\t= MAX77843_SYS_REG_SYSINTMASK,\n\t.num_regs\t= 1,\n\t.irqs\t\t= max77843_irqs,\n\t.num_irqs\t= ARRAY_SIZE(max77843_irqs),\n};\n\n \nstatic int max77843_chg_init(struct max77693_dev *max77843)\n{\n\tint ret;\n\n\tmax77843->i2c_chg = i2c_new_dummy_device(max77843->i2c->adapter, I2C_ADDR_CHG);\n\tif (IS_ERR(max77843->i2c_chg)) {\n\t\tdev_err(&max77843->i2c->dev,\n\t\t\t\t\"Cannot allocate I2C device for Charger\\n\");\n\t\treturn PTR_ERR(max77843->i2c_chg);\n\t}\n\ti2c_set_clientdata(max77843->i2c_chg, max77843);\n\n\tmax77843->regmap_chg = devm_regmap_init_i2c(max77843->i2c_chg,\n\t\t\t&max77843_charger_regmap_config);\n\tif (IS_ERR(max77843->regmap_chg)) {\n\t\tret = PTR_ERR(max77843->regmap_chg);\n\t\tgoto err_chg_i2c;\n\t}\n\n\treturn 0;\n\nerr_chg_i2c:\n\ti2c_unregister_device(max77843->i2c_chg);\n\n\treturn ret;\n}\n\nstatic int max77843_probe(struct i2c_client *i2c)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(i2c);\n\tstruct max77693_dev *max77843;\n\tunsigned int reg_data;\n\tint ret;\n\n\tmax77843 = devm_kzalloc(&i2c->dev, sizeof(*max77843), GFP_KERNEL);\n\tif (!max77843)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(i2c, max77843);\n\tmax77843->dev = &i2c->dev;\n\tmax77843->i2c = i2c;\n\tmax77843->irq = i2c->irq;\n\tmax77843->type = id->driver_data;\n\n\tmax77843->regmap = devm_regmap_init_i2c(i2c,\n\t\t\t&max77843_regmap_config);\n\tif (IS_ERR(max77843->regmap)) {\n\t\tdev_err(&i2c->dev, \"Failed to allocate topsys register map\\n\");\n\t\treturn PTR_ERR(max77843->regmap);\n\t}\n\n\tret = regmap_add_irq_chip(max77843->regmap, max77843->irq,\n\t\t\tIRQF_TRIGGER_LOW | IRQF_ONESHOT | IRQF_SHARED,\n\t\t\t0, &max77843_irq_chip, &max77843->irq_data_topsys);\n\tif (ret) {\n\t\tdev_err(&i2c->dev, \"Failed to add TOPSYS IRQ chip\\n\");\n\t\treturn ret;\n\t}\n\n\tret = regmap_read(max77843->regmap,\n\t\t\tMAX77843_SYS_REG_PMICID, &reg_data);\n\tif (ret < 0) {\n\t\tdev_err(&i2c->dev, \"Failed to read PMIC ID\\n\");\n\t\tgoto err_pmic_id;\n\t}\n\tdev_info(&i2c->dev, \"device ID: 0x%x\\n\", reg_data);\n\n\tret = max77843_chg_init(max77843);\n\tif (ret) {\n\t\tdev_err(&i2c->dev, \"Failed to init Charger\\n\");\n\t\tgoto err_pmic_id;\n\t}\n\n\tret = regmap_update_bits(max77843->regmap,\n\t\t\t\t MAX77843_SYS_REG_INTSRCMASK,\n\t\t\t\t MAX77843_INTSRC_MASK_MASK,\n\t\t\t\t (unsigned int)~MAX77843_INTSRC_MASK_MASK);\n\tif (ret < 0) {\n\t\tdev_err(&i2c->dev, \"Failed to unmask interrupt source\\n\");\n\t\tgoto err_pmic_id;\n\t}\n\n\tret = mfd_add_devices(max77843->dev, -1, max77843_devs,\n\t\t\t      ARRAY_SIZE(max77843_devs), NULL, 0, NULL);\n\tif (ret < 0) {\n\t\tdev_err(&i2c->dev, \"Failed to add mfd device\\n\");\n\t\tgoto err_pmic_id;\n\t}\n\n\tdevice_init_wakeup(max77843->dev, true);\n\n\treturn 0;\n\nerr_pmic_id:\n\tregmap_del_irq_chip(max77843->irq, max77843->irq_data_topsys);\n\n\treturn ret;\n}\n\nstatic const struct of_device_id max77843_dt_match[] = {\n\t{ .compatible = \"maxim,max77843\", },\n\t{ },\n};\n\nstatic const struct i2c_device_id max77843_id[] = {\n\t{ \"max77843\", TYPE_MAX77843, },\n\t{ },\n};\n\nstatic int __maybe_unused max77843_suspend(struct device *dev)\n{\n\tstruct i2c_client *i2c = to_i2c_client(dev);\n\tstruct max77693_dev *max77843 = i2c_get_clientdata(i2c);\n\n\tdisable_irq(max77843->irq);\n\tif (device_may_wakeup(dev))\n\t\tenable_irq_wake(max77843->irq);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused max77843_resume(struct device *dev)\n{\n\tstruct i2c_client *i2c = to_i2c_client(dev);\n\tstruct max77693_dev *max77843 = i2c_get_clientdata(i2c);\n\n\tif (device_may_wakeup(dev))\n\t\tdisable_irq_wake(max77843->irq);\n\tenable_irq(max77843->irq);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(max77843_pm, max77843_suspend, max77843_resume);\n\nstatic struct i2c_driver max77843_i2c_driver = {\n\t.driver\t= {\n\t\t.name = \"max77843\",\n\t\t.pm = &max77843_pm,\n\t\t.of_match_table = max77843_dt_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe = max77843_probe,\n\t.id_table = max77843_id,\n};\n\nstatic int __init max77843_i2c_init(void)\n{\n\treturn i2c_add_driver(&max77843_i2c_driver);\n}\nsubsys_initcall(max77843_i2c_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}