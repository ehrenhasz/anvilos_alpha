{
  "module_name": "ssbi.c",
  "hash_id": "683a7c6d6dbbef481082a44f3858ea98fc2be538247ed24a24320b76560d65f8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/ssbi.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"%s: \" fmt, __func__\n\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/ssbi.h>\n\n \n#define SSBI2_CMD\t\t\t0x0008\n#define SSBI2_RD\t\t\t0x0010\n#define SSBI2_STATUS\t\t\t0x0014\n#define SSBI2_MODE2\t\t\t0x001C\n\n \n#define SSBI_CMD_RDWRN\t\t\t(1 << 24)\n\n \n#define SSBI_STATUS_RD_READY\t\t(1 << 2)\n#define SSBI_STATUS_READY\t\t(1 << 1)\n#define SSBI_STATUS_MCHN_BUSY\t\t(1 << 0)\n\n \n#define SSBI_MODE2_REG_ADDR_15_8_SHFT\t0x04\n#define SSBI_MODE2_REG_ADDR_15_8_MASK\t(0x7f << SSBI_MODE2_REG_ADDR_15_8_SHFT)\n\n#define SET_SSBI_MODE2_REG_ADDR_15_8(MD, AD) \\\n\t(((MD) & 0x0F) | ((((AD) >> 8) << SSBI_MODE2_REG_ADDR_15_8_SHFT) & \\\n\tSSBI_MODE2_REG_ADDR_15_8_MASK))\n\n \n#define SSBI_PA_CMD\t\t\t0x0000\n#define SSBI_PA_RD_STATUS\t\t0x0004\n\n \n#define SSBI_PA_CMD_RDWRN\t\t(1 << 24)\n#define SSBI_PA_CMD_ADDR_MASK\t\t0x7fff  \n\n \n#define SSBI_PA_RD_STATUS_TRANS_DONE\t(1 << 27)\n#define SSBI_PA_RD_STATUS_TRANS_DENIED\t(1 << 26)\n\n#define SSBI_TIMEOUT_US\t\t\t100\n\nenum ssbi_controller_type {\n\tMSM_SBI_CTRL_SSBI = 0,\n\tMSM_SBI_CTRL_SSBI2,\n\tMSM_SBI_CTRL_PMIC_ARBITER,\n};\n\nstruct ssbi {\n\tstruct device\t\t*slave;\n\tvoid __iomem\t\t*base;\n\tspinlock_t\t\tlock;\n\tenum ssbi_controller_type controller_type;\n\tint (*read)(struct ssbi *, u16 addr, u8 *buf, int len);\n\tint (*write)(struct ssbi *, u16 addr, const u8 *buf, int len);\n};\n\nstatic inline u32 ssbi_readl(struct ssbi *ssbi, u32 reg)\n{\n\treturn readl(ssbi->base + reg);\n}\n\nstatic inline void ssbi_writel(struct ssbi *ssbi, u32 val, u32 reg)\n{\n\twritel(val, ssbi->base + reg);\n}\n\n \nstatic int ssbi_wait_mask(struct ssbi *ssbi, u32 set_mask, u32 clr_mask)\n{\n\tu32 timeout = SSBI_TIMEOUT_US;\n\tu32 val;\n\n\twhile (timeout--) {\n\t\tval = ssbi_readl(ssbi, SSBI2_STATUS);\n\t\tif (((val & set_mask) == set_mask) && ((val & clr_mask) == 0))\n\t\t\treturn 0;\n\t\tudelay(1);\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int\nssbi_read_bytes(struct ssbi *ssbi, u16 addr, u8 *buf, int len)\n{\n\tu32 cmd = SSBI_CMD_RDWRN | ((addr & 0xff) << 16);\n\tint ret = 0;\n\n\tif (ssbi->controller_type == MSM_SBI_CTRL_SSBI2) {\n\t\tu32 mode2 = ssbi_readl(ssbi, SSBI2_MODE2);\n\t\tmode2 = SET_SSBI_MODE2_REG_ADDR_15_8(mode2, addr);\n\t\tssbi_writel(ssbi, mode2, SSBI2_MODE2);\n\t}\n\n\twhile (len) {\n\t\tret = ssbi_wait_mask(ssbi, SSBI_STATUS_READY, 0);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tssbi_writel(ssbi, cmd, SSBI2_CMD);\n\t\tret = ssbi_wait_mask(ssbi, SSBI_STATUS_RD_READY, 0);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\t*buf++ = ssbi_readl(ssbi, SSBI2_RD) & 0xff;\n\t\tlen--;\n\t}\n\nerr:\n\treturn ret;\n}\n\nstatic int\nssbi_write_bytes(struct ssbi *ssbi, u16 addr, const u8 *buf, int len)\n{\n\tint ret = 0;\n\n\tif (ssbi->controller_type == MSM_SBI_CTRL_SSBI2) {\n\t\tu32 mode2 = ssbi_readl(ssbi, SSBI2_MODE2);\n\t\tmode2 = SET_SSBI_MODE2_REG_ADDR_15_8(mode2, addr);\n\t\tssbi_writel(ssbi, mode2, SSBI2_MODE2);\n\t}\n\n\twhile (len) {\n\t\tret = ssbi_wait_mask(ssbi, SSBI_STATUS_READY, 0);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tssbi_writel(ssbi, ((addr & 0xff) << 16) | *buf, SSBI2_CMD);\n\t\tret = ssbi_wait_mask(ssbi, 0, SSBI_STATUS_MCHN_BUSY);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tbuf++;\n\t\tlen--;\n\t}\n\nerr:\n\treturn ret;\n}\n\n \nstatic inline int\nssbi_pa_transfer(struct ssbi *ssbi, u32 cmd, u8 *data)\n{\n\tu32 timeout = SSBI_TIMEOUT_US;\n\tu32 rd_status = 0;\n\n\tssbi_writel(ssbi, cmd, SSBI_PA_CMD);\n\n\twhile (timeout--) {\n\t\trd_status = ssbi_readl(ssbi, SSBI_PA_RD_STATUS);\n\n\t\tif (rd_status & SSBI_PA_RD_STATUS_TRANS_DENIED)\n\t\t\treturn -EPERM;\n\n\t\tif (rd_status & SSBI_PA_RD_STATUS_TRANS_DONE) {\n\t\t\tif (data)\n\t\t\t\t*data = rd_status & 0xff;\n\t\t\treturn 0;\n\t\t}\n\t\tudelay(1);\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int\nssbi_pa_read_bytes(struct ssbi *ssbi, u16 addr, u8 *buf, int len)\n{\n\tu32 cmd;\n\tint ret = 0;\n\n\tcmd = SSBI_PA_CMD_RDWRN | (addr & SSBI_PA_CMD_ADDR_MASK) << 8;\n\n\twhile (len) {\n\t\tret = ssbi_pa_transfer(ssbi, cmd, buf);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tbuf++;\n\t\tlen--;\n\t}\n\nerr:\n\treturn ret;\n}\n\nstatic int\nssbi_pa_write_bytes(struct ssbi *ssbi, u16 addr, const u8 *buf, int len)\n{\n\tu32 cmd;\n\tint ret = 0;\n\n\twhile (len) {\n\t\tcmd = (addr & SSBI_PA_CMD_ADDR_MASK) << 8 | *buf;\n\t\tret = ssbi_pa_transfer(ssbi, cmd, NULL);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tbuf++;\n\t\tlen--;\n\t}\n\nerr:\n\treturn ret;\n}\n\nint ssbi_read(struct device *dev, u16 addr, u8 *buf, int len)\n{\n\tstruct ssbi *ssbi = dev_get_drvdata(dev);\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&ssbi->lock, flags);\n\tret = ssbi->read(ssbi, addr, buf, len);\n\tspin_unlock_irqrestore(&ssbi->lock, flags);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(ssbi_read);\n\nint ssbi_write(struct device *dev, u16 addr, const u8 *buf, int len)\n{\n\tstruct ssbi *ssbi = dev_get_drvdata(dev);\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&ssbi->lock, flags);\n\tret = ssbi->write(ssbi, addr, buf, len);\n\tspin_unlock_irqrestore(&ssbi->lock, flags);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(ssbi_write);\n\nstatic int ssbi_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct ssbi *ssbi;\n\tconst char *type;\n\n\tssbi = devm_kzalloc(&pdev->dev, sizeof(*ssbi), GFP_KERNEL);\n\tif (!ssbi)\n\t\treturn -ENOMEM;\n\n\tssbi->base = devm_platform_get_and_ioremap_resource(pdev, 0, NULL);\n\tif (IS_ERR(ssbi->base))\n\t\treturn PTR_ERR(ssbi->base);\n\n\tplatform_set_drvdata(pdev, ssbi);\n\n\ttype = of_get_property(np, \"qcom,controller-type\", NULL);\n\tif (type == NULL) {\n\t\tdev_err(&pdev->dev, \"Missing qcom,controller-type property\\n\");\n\t\treturn -EINVAL;\n\t}\n\tdev_info(&pdev->dev, \"SSBI controller type: '%s'\\n\", type);\n\tif (strcmp(type, \"ssbi\") == 0)\n\t\tssbi->controller_type = MSM_SBI_CTRL_SSBI;\n\telse if (strcmp(type, \"ssbi2\") == 0)\n\t\tssbi->controller_type = MSM_SBI_CTRL_SSBI2;\n\telse if (strcmp(type, \"pmic-arbiter\") == 0)\n\t\tssbi->controller_type = MSM_SBI_CTRL_PMIC_ARBITER;\n\telse {\n\t\tdev_err(&pdev->dev, \"Unknown qcom,controller-type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (ssbi->controller_type == MSM_SBI_CTRL_PMIC_ARBITER) {\n\t\tssbi->read = ssbi_pa_read_bytes;\n\t\tssbi->write = ssbi_pa_write_bytes;\n\t} else {\n\t\tssbi->read = ssbi_read_bytes;\n\t\tssbi->write = ssbi_write_bytes;\n\t}\n\n\tspin_lock_init(&ssbi->lock);\n\n\treturn devm_of_platform_populate(&pdev->dev);\n}\n\nstatic const struct of_device_id ssbi_match_table[] = {\n\t{ .compatible = \"qcom,ssbi\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, ssbi_match_table);\n\nstatic struct platform_driver ssbi_driver = {\n\t.probe\t\t= ssbi_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"ssbi\",\n\t\t.of_match_table = ssbi_match_table,\n\t},\n};\nmodule_platform_driver(ssbi_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_VERSION(\"1.0\");\nMODULE_ALIAS(\"platform:ssbi\");\nMODULE_AUTHOR(\"Dima Zavin <dima@android.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}