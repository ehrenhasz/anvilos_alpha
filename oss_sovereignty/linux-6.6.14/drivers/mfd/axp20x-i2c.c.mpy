{
  "module_name": "axp20x-i2c.c",
  "hash_id": "1e75b224d4077a3c85c930eba1803eeac09b0be39c61ae971ae83fe57dc5922f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/axp20x-i2c.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/mfd/axp20x.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\nstatic int axp20x_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct axp20x_dev *axp20x;\n\tint ret;\n\n\taxp20x = devm_kzalloc(&i2c->dev, sizeof(*axp20x), GFP_KERNEL);\n\tif (!axp20x)\n\t\treturn -ENOMEM;\n\n\taxp20x->dev = &i2c->dev;\n\taxp20x->irq = i2c->irq;\n\tdev_set_drvdata(axp20x->dev, axp20x);\n\n\tret = axp20x_match_device(axp20x);\n\tif (ret)\n\t\treturn ret;\n\n\taxp20x->regmap = devm_regmap_init_i2c(i2c, axp20x->regmap_cfg);\n\tif (IS_ERR(axp20x->regmap)) {\n\t\tret = PTR_ERR(axp20x->regmap);\n\t\tdev_err(&i2c->dev, \"regmap init failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn axp20x_device_probe(axp20x);\n}\n\nstatic void axp20x_i2c_remove(struct i2c_client *i2c)\n{\n\tstruct axp20x_dev *axp20x = i2c_get_clientdata(i2c);\n\n\taxp20x_device_remove(axp20x);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id axp20x_i2c_of_match[] = {\n\t{ .compatible = \"x-powers,axp152\", .data = (void *)AXP152_ID },\n\t{ .compatible = \"x-powers,axp192\", .data = (void *)AXP192_ID },\n\t{ .compatible = \"x-powers,axp202\", .data = (void *)AXP202_ID },\n\t{ .compatible = \"x-powers,axp209\", .data = (void *)AXP209_ID },\n\t{ .compatible = \"x-powers,axp221\", .data = (void *)AXP221_ID },\n\t{ .compatible = \"x-powers,axp223\", .data = (void *)AXP223_ID },\n\t{ .compatible = \"x-powers,axp313a\", .data = (void *)AXP313A_ID },\n\t{ .compatible = \"x-powers,axp803\", .data = (void *)AXP803_ID },\n\t{ .compatible = \"x-powers,axp806\", .data = (void *)AXP806_ID },\n\t{ .compatible = \"x-powers,axp15060\", .data = (void *)AXP15060_ID },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, axp20x_i2c_of_match);\n#endif\n\nstatic const struct i2c_device_id axp20x_i2c_id[] = {\n\t{ \"axp152\", 0 },\n\t{ \"axp192\", 0 },\n\t{ \"axp202\", 0 },\n\t{ \"axp209\", 0 },\n\t{ \"axp221\", 0 },\n\t{ \"axp223\", 0 },\n\t{ \"axp313a\", 0 },\n\t{ \"axp803\", 0 },\n\t{ \"axp806\", 0 },\n\t{ \"axp15060\", 0 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(i2c, axp20x_i2c_id);\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id axp20x_i2c_acpi_match[] = {\n\t{\n\t\t.id = \"INT33F4\",\n\t\t.driver_data = AXP288_ID,\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(acpi, axp20x_i2c_acpi_match);\n#endif\n\nstatic struct i2c_driver axp20x_i2c_driver = {\n\t.driver = {\n\t\t.name\t= \"axp20x-i2c\",\n\t\t.of_match_table\t= of_match_ptr(axp20x_i2c_of_match),\n\t\t.acpi_match_table = ACPI_PTR(axp20x_i2c_acpi_match),\n\t},\n\t.probe\t\t= axp20x_i2c_probe,\n\t.remove\t\t= axp20x_i2c_remove,\n\t.id_table\t= axp20x_i2c_id,\n};\n\nmodule_i2c_driver(axp20x_i2c_driver);\n\nMODULE_DESCRIPTION(\"PMIC MFD I2C driver for AXP20X\");\nMODULE_AUTHOR(\"Carlo Caione <carlo@caione.org>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}