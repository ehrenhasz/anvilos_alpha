{
  "module_name": "tps6586x.c",
  "hash_id": "1e471b24940947582da77955c4a19958d68739d0352c16886a546f55b3e63071",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/tps6586x.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/of.h>\n\n#include <linux/mfd/core.h>\n#include <linux/mfd/tps6586x.h>\n\n#define TPS6586X_SUPPLYENE\t0x14\n#define EXITSLREQ_BIT\t\tBIT(1)\n#define SLEEP_MODE_BIT\t\tBIT(3)\n\n \n#define TPS6586X_INT_ACK1\t0xb5\n#define TPS6586X_INT_ACK2\t0xb6\n#define TPS6586X_INT_ACK3\t0xb7\n#define TPS6586X_INT_ACK4\t0xb8\n\n \n#define TPS6586X_INT_MASK1\t0xb0\n#define TPS6586X_INT_MASK2\t0xb1\n#define TPS6586X_INT_MASK3\t0xb2\n#define TPS6586X_INT_MASK4\t0xb3\n#define TPS6586X_INT_MASK5\t0xb4\n\n \n#define TPS6586X_VERSIONCRC\t0xcd\n\n \n#define TPS6586X_MAX_REGISTER\tTPS6586X_VERSIONCRC\n\nstruct tps6586x_irq_data {\n\tu8\tmask_reg;\n\tu8\tmask_mask;\n};\n\n#define TPS6586X_IRQ(_reg, _mask)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\\\n\t\t.mask_reg = (_reg) - TPS6586X_INT_MASK1,\t\\\n\t\t.mask_mask = (_mask),\t\t\t\t\\\n\t}\n\nstatic const struct tps6586x_irq_data tps6586x_irqs[] = {\n\t[TPS6586X_INT_PLDO_0]\t= TPS6586X_IRQ(TPS6586X_INT_MASK1, 1 << 0),\n\t[TPS6586X_INT_PLDO_1]\t= TPS6586X_IRQ(TPS6586X_INT_MASK1, 1 << 1),\n\t[TPS6586X_INT_PLDO_2]\t= TPS6586X_IRQ(TPS6586X_INT_MASK1, 1 << 2),\n\t[TPS6586X_INT_PLDO_3]\t= TPS6586X_IRQ(TPS6586X_INT_MASK1, 1 << 3),\n\t[TPS6586X_INT_PLDO_4]\t= TPS6586X_IRQ(TPS6586X_INT_MASK1, 1 << 4),\n\t[TPS6586X_INT_PLDO_5]\t= TPS6586X_IRQ(TPS6586X_INT_MASK1, 1 << 5),\n\t[TPS6586X_INT_PLDO_6]\t= TPS6586X_IRQ(TPS6586X_INT_MASK1, 1 << 6),\n\t[TPS6586X_INT_PLDO_7]\t= TPS6586X_IRQ(TPS6586X_INT_MASK1, 1 << 7),\n\t[TPS6586X_INT_COMP_DET]\t= TPS6586X_IRQ(TPS6586X_INT_MASK4, 1 << 0),\n\t[TPS6586X_INT_ADC]\t= TPS6586X_IRQ(TPS6586X_INT_MASK2, 1 << 1),\n\t[TPS6586X_INT_PLDO_8]\t= TPS6586X_IRQ(TPS6586X_INT_MASK2, 1 << 2),\n\t[TPS6586X_INT_PLDO_9]\t= TPS6586X_IRQ(TPS6586X_INT_MASK2, 1 << 3),\n\t[TPS6586X_INT_PSM_0]\t= TPS6586X_IRQ(TPS6586X_INT_MASK2, 1 << 4),\n\t[TPS6586X_INT_PSM_1]\t= TPS6586X_IRQ(TPS6586X_INT_MASK2, 1 << 5),\n\t[TPS6586X_INT_PSM_2]\t= TPS6586X_IRQ(TPS6586X_INT_MASK2, 1 << 6),\n\t[TPS6586X_INT_PSM_3]\t= TPS6586X_IRQ(TPS6586X_INT_MASK2, 1 << 7),\n\t[TPS6586X_INT_RTC_ALM1]\t= TPS6586X_IRQ(TPS6586X_INT_MASK5, 1 << 4),\n\t[TPS6586X_INT_ACUSB_OVP] = TPS6586X_IRQ(TPS6586X_INT_MASK5, 0x03),\n\t[TPS6586X_INT_USB_DET]\t= TPS6586X_IRQ(TPS6586X_INT_MASK5, 1 << 2),\n\t[TPS6586X_INT_AC_DET]\t= TPS6586X_IRQ(TPS6586X_INT_MASK5, 1 << 3),\n\t[TPS6586X_INT_BAT_DET]\t= TPS6586X_IRQ(TPS6586X_INT_MASK3, 1 << 0),\n\t[TPS6586X_INT_CHG_STAT]\t= TPS6586X_IRQ(TPS6586X_INT_MASK4, 0xfc),\n\t[TPS6586X_INT_CHG_TEMP]\t= TPS6586X_IRQ(TPS6586X_INT_MASK3, 0x06),\n\t[TPS6586X_INT_PP]\t= TPS6586X_IRQ(TPS6586X_INT_MASK3, 0xf0),\n\t[TPS6586X_INT_RESUME]\t= TPS6586X_IRQ(TPS6586X_INT_MASK5, 1 << 5),\n\t[TPS6586X_INT_LOW_SYS]\t= TPS6586X_IRQ(TPS6586X_INT_MASK5, 1 << 6),\n\t[TPS6586X_INT_RTC_ALM2] = TPS6586X_IRQ(TPS6586X_INT_MASK4, 1 << 1),\n};\n\nstatic const struct resource tps6586x_rtc_resources[] = {\n\t{\n\t\t.start  = TPS6586X_INT_RTC_ALM1,\n\t\t.end\t= TPS6586X_INT_RTC_ALM1,\n\t\t.flags\t= IORESOURCE_IRQ,\n\t},\n};\n\nstatic const struct mfd_cell tps6586x_cell[] = {\n\t{\n\t\t.name = \"tps6586x-gpio\",\n\t},\n\t{\n\t\t.name = \"tps6586x-regulator\",\n\t},\n\t{\n\t\t.name = \"tps6586x-rtc\",\n\t\t.num_resources = ARRAY_SIZE(tps6586x_rtc_resources),\n\t\t.resources = &tps6586x_rtc_resources[0],\n\t},\n\t{\n\t\t.name = \"tps6586x-onkey\",\n\t},\n};\n\nstruct tps6586x {\n\tstruct device\t\t*dev;\n\tstruct i2c_client\t*client;\n\tstruct regmap\t\t*regmap;\n\tint\t\t\tversion;\n\n\tint\t\t\tirq;\n\tstruct irq_chip\t\tirq_chip;\n\tstruct mutex\t\tirq_lock;\n\tint\t\t\tirq_base;\n\tu32\t\t\tirq_en;\n\tu8\t\t\tmask_reg[5];\n\tstruct irq_domain\t*irq_domain;\n};\n\nstatic inline struct tps6586x *dev_to_tps6586x(struct device *dev)\n{\n\treturn i2c_get_clientdata(to_i2c_client(dev));\n}\n\nint tps6586x_write(struct device *dev, int reg, uint8_t val)\n{\n\tstruct tps6586x *tps6586x = dev_to_tps6586x(dev);\n\n\treturn regmap_write(tps6586x->regmap, reg, val);\n}\nEXPORT_SYMBOL_GPL(tps6586x_write);\n\nint tps6586x_writes(struct device *dev, int reg, int len, uint8_t *val)\n{\n\tstruct tps6586x *tps6586x = dev_to_tps6586x(dev);\n\n\treturn regmap_bulk_write(tps6586x->regmap, reg, val, len);\n}\nEXPORT_SYMBOL_GPL(tps6586x_writes);\n\nint tps6586x_read(struct device *dev, int reg, uint8_t *val)\n{\n\tstruct tps6586x *tps6586x = dev_to_tps6586x(dev);\n\tunsigned int rval;\n\tint ret;\n\n\tret = regmap_read(tps6586x->regmap, reg, &rval);\n\tif (!ret)\n\t\t*val = rval;\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(tps6586x_read);\n\nint tps6586x_reads(struct device *dev, int reg, int len, uint8_t *val)\n{\n\tstruct tps6586x *tps6586x = dev_to_tps6586x(dev);\n\n\treturn regmap_bulk_read(tps6586x->regmap, reg, val, len);\n}\nEXPORT_SYMBOL_GPL(tps6586x_reads);\n\nint tps6586x_set_bits(struct device *dev, int reg, uint8_t bit_mask)\n{\n\tstruct tps6586x *tps6586x = dev_to_tps6586x(dev);\n\n\treturn regmap_update_bits(tps6586x->regmap, reg, bit_mask, bit_mask);\n}\nEXPORT_SYMBOL_GPL(tps6586x_set_bits);\n\nint tps6586x_clr_bits(struct device *dev, int reg, uint8_t bit_mask)\n{\n\tstruct tps6586x *tps6586x = dev_to_tps6586x(dev);\n\n\treturn regmap_update_bits(tps6586x->regmap, reg, bit_mask, 0);\n}\nEXPORT_SYMBOL_GPL(tps6586x_clr_bits);\n\nint tps6586x_update(struct device *dev, int reg, uint8_t val, uint8_t mask)\n{\n\tstruct tps6586x *tps6586x = dev_to_tps6586x(dev);\n\n\treturn regmap_update_bits(tps6586x->regmap, reg, mask, val);\n}\nEXPORT_SYMBOL_GPL(tps6586x_update);\n\nint tps6586x_irq_get_virq(struct device *dev, int irq)\n{\n\tstruct tps6586x *tps6586x = dev_to_tps6586x(dev);\n\n\treturn irq_create_mapping(tps6586x->irq_domain, irq);\n}\nEXPORT_SYMBOL_GPL(tps6586x_irq_get_virq);\n\nint tps6586x_get_version(struct device *dev)\n{\n\tstruct tps6586x *tps6586x = dev_get_drvdata(dev);\n\n\treturn tps6586x->version;\n}\nEXPORT_SYMBOL_GPL(tps6586x_get_version);\n\nstatic int __remove_subdev(struct device *dev, void *unused)\n{\n\tplatform_device_unregister(to_platform_device(dev));\n\treturn 0;\n}\n\nstatic int tps6586x_remove_subdevs(struct tps6586x *tps6586x)\n{\n\treturn device_for_each_child(tps6586x->dev, NULL, __remove_subdev);\n}\n\nstatic void tps6586x_irq_lock(struct irq_data *data)\n{\n\tstruct tps6586x *tps6586x = irq_data_get_irq_chip_data(data);\n\n\tmutex_lock(&tps6586x->irq_lock);\n}\n\nstatic void tps6586x_irq_enable(struct irq_data *irq_data)\n{\n\tstruct tps6586x *tps6586x = irq_data_get_irq_chip_data(irq_data);\n\tunsigned int __irq = irq_data->hwirq;\n\tconst struct tps6586x_irq_data *data = &tps6586x_irqs[__irq];\n\n\ttps6586x->mask_reg[data->mask_reg] &= ~data->mask_mask;\n\ttps6586x->irq_en |= (1 << __irq);\n}\n\nstatic void tps6586x_irq_disable(struct irq_data *irq_data)\n{\n\tstruct tps6586x *tps6586x = irq_data_get_irq_chip_data(irq_data);\n\n\tunsigned int __irq = irq_data->hwirq;\n\tconst struct tps6586x_irq_data *data = &tps6586x_irqs[__irq];\n\n\ttps6586x->mask_reg[data->mask_reg] |= data->mask_mask;\n\ttps6586x->irq_en &= ~(1 << __irq);\n}\n\nstatic void tps6586x_irq_sync_unlock(struct irq_data *data)\n{\n\tstruct tps6586x *tps6586x = irq_data_get_irq_chip_data(data);\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(tps6586x->mask_reg); i++) {\n\t\tint ret;\n\t\tret = tps6586x_write(tps6586x->dev,\n\t\t\t\t\t    TPS6586X_INT_MASK1 + i,\n\t\t\t\t\t    tps6586x->mask_reg[i]);\n\t\tWARN_ON(ret);\n\t}\n\n\tmutex_unlock(&tps6586x->irq_lock);\n}\n\nstatic int tps6586x_irq_set_wake(struct irq_data *irq_data, unsigned int on)\n{\n\tstruct tps6586x *tps6586x = irq_data_get_irq_chip_data(irq_data);\n\treturn irq_set_irq_wake(tps6586x->irq, on);\n}\n\nstatic struct irq_chip tps6586x_irq_chip = {\n\t.name = \"tps6586x\",\n\t.irq_bus_lock = tps6586x_irq_lock,\n\t.irq_bus_sync_unlock = tps6586x_irq_sync_unlock,\n\t.irq_disable = tps6586x_irq_disable,\n\t.irq_enable = tps6586x_irq_enable,\n\t.irq_set_wake = pm_sleep_ptr(tps6586x_irq_set_wake),\n};\n\nstatic int tps6586x_irq_map(struct irq_domain *h, unsigned int virq,\n\t\t\t\tirq_hw_number_t hw)\n{\n\tstruct tps6586x *tps6586x = h->host_data;\n\n\tirq_set_chip_data(virq, tps6586x);\n\tirq_set_chip_and_handler(virq, &tps6586x_irq_chip, handle_simple_irq);\n\tirq_set_nested_thread(virq, 1);\n\tirq_set_noprobe(virq);\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops tps6586x_domain_ops = {\n\t.map    = tps6586x_irq_map,\n\t.xlate  = irq_domain_xlate_twocell,\n};\n\nstatic irqreturn_t tps6586x_irq(int irq, void *data)\n{\n\tstruct tps6586x *tps6586x = data;\n\tuint32_t acks;\n\t__le32 val;\n\tint ret = 0;\n\n\tret = tps6586x_reads(tps6586x->dev, TPS6586X_INT_ACK1,\n\t\t\t     sizeof(acks), (uint8_t *)&val);\n\n\tif (ret < 0) {\n\t\tdev_err(tps6586x->dev, \"failed to read interrupt status\\n\");\n\t\treturn IRQ_NONE;\n\t}\n\n\tacks = le32_to_cpu(val);\n\n\twhile (acks) {\n\t\tint i = __ffs(acks);\n\n\t\tif (tps6586x->irq_en & (1 << i))\n\t\t\thandle_nested_irq(\n\t\t\t\tirq_find_mapping(tps6586x->irq_domain, i));\n\n\t\tacks &= ~(1 << i);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int tps6586x_irq_init(struct tps6586x *tps6586x, int irq,\n\t\t\t\t       int irq_base)\n{\n\tint i, ret;\n\tu8 tmp[4];\n\tint new_irq_base;\n\tint irq_num = ARRAY_SIZE(tps6586x_irqs);\n\n\ttps6586x->irq = irq;\n\n\tmutex_init(&tps6586x->irq_lock);\n\tfor (i = 0; i < 5; i++) {\n\t\ttps6586x->mask_reg[i] = 0xff;\n\t\ttps6586x_write(tps6586x->dev, TPS6586X_INT_MASK1 + i, 0xff);\n\t}\n\n\ttps6586x_reads(tps6586x->dev, TPS6586X_INT_ACK1, sizeof(tmp), tmp);\n\n\tif  (irq_base > 0) {\n\t\tnew_irq_base = irq_alloc_descs(irq_base, 0, irq_num, -1);\n\t\tif (new_irq_base < 0) {\n\t\t\tdev_err(tps6586x->dev,\n\t\t\t\t\"Failed to alloc IRQs: %d\\n\", new_irq_base);\n\t\t\treturn new_irq_base;\n\t\t}\n\t} else {\n\t\tnew_irq_base = 0;\n\t}\n\n\ttps6586x->irq_domain = irq_domain_add_simple(tps6586x->dev->of_node,\n\t\t\t\tirq_num, new_irq_base, &tps6586x_domain_ops,\n\t\t\t\ttps6586x);\n\tif (!tps6586x->irq_domain) {\n\t\tdev_err(tps6586x->dev, \"Failed to create IRQ domain\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tret = request_threaded_irq(irq, NULL, tps6586x_irq, IRQF_ONESHOT,\n\t\t\t\t   \"tps6586x\", tps6586x);\n\n\tif (!ret)\n\t\tdevice_init_wakeup(tps6586x->dev, 1);\n\n\treturn ret;\n}\n\nstatic int tps6586x_add_subdevs(struct tps6586x *tps6586x,\n\t\t\t\t\t  struct tps6586x_platform_data *pdata)\n{\n\tstruct tps6586x_subdev_info *subdev;\n\tstruct platform_device *pdev;\n\tint i, ret = 0;\n\n\tfor (i = 0; i < pdata->num_subdevs; i++) {\n\t\tsubdev = &pdata->subdevs[i];\n\n\t\tpdev = platform_device_alloc(subdev->name, subdev->id);\n\t\tif (!pdev) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tpdev->dev.parent = tps6586x->dev;\n\t\tpdev->dev.platform_data = subdev->platform_data;\n\t\tpdev->dev.of_node = subdev->of_node;\n\n\t\tret = platform_device_add(pdev);\n\t\tif (ret) {\n\t\t\tplatform_device_put(pdev);\n\t\t\tgoto failed;\n\t\t}\n\t}\n\treturn 0;\n\nfailed:\n\ttps6586x_remove_subdevs(tps6586x);\n\treturn ret;\n}\n\n#ifdef CONFIG_OF\nstatic struct tps6586x_platform_data *tps6586x_parse_dt(struct i2c_client *client)\n{\n\tstruct device_node *np = client->dev.of_node;\n\tstruct tps6586x_platform_data *pdata;\n\n\tpdata = devm_kzalloc(&client->dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn NULL;\n\n\tpdata->num_subdevs = 0;\n\tpdata->subdevs = NULL;\n\tpdata->gpio_base = -1;\n\tpdata->irq_base = -1;\n\tpdata->pm_off = of_property_read_bool(np, \"ti,system-power-controller\");\n\n\treturn pdata;\n}\n\nstatic const struct of_device_id tps6586x_of_match[] = {\n\t{ .compatible = \"ti,tps6586x\", },\n\t{ },\n};\n#else\nstatic struct tps6586x_platform_data *tps6586x_parse_dt(struct i2c_client *client)\n{\n\treturn NULL;\n}\n#endif\n\nstatic bool is_volatile_reg(struct device *dev, unsigned int reg)\n{\n\t \n\tif ((reg >= TPS6586X_INT_MASK1) && (reg <= TPS6586X_INT_MASK5))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic const struct regmap_config tps6586x_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = TPS6586X_MAX_REGISTER,\n\t.volatile_reg = is_volatile_reg,\n\t.cache_type = REGCACHE_RBTREE,\n};\n\nstatic struct device *tps6586x_dev;\nstatic void tps6586x_power_off(void)\n{\n\tif (tps6586x_clr_bits(tps6586x_dev, TPS6586X_SUPPLYENE, EXITSLREQ_BIT))\n\t\treturn;\n\n\ttps6586x_set_bits(tps6586x_dev, TPS6586X_SUPPLYENE, SLEEP_MODE_BIT);\n}\n\nstatic void tps6586x_print_version(struct i2c_client *client, int version)\n{\n\tconst char *name;\n\n\tswitch (version) {\n\tcase TPS658621A:\n\t\tname = \"TPS658621A\";\n\t\tbreak;\n\tcase TPS658621CD:\n\t\tname = \"TPS658621C/D\";\n\t\tbreak;\n\tcase TPS658623:\n\t\tname = \"TPS658623\";\n\t\tbreak;\n\tcase TPS658640:\n\tcase TPS658640v2:\n\t\tname = \"TPS658640\";\n\t\tbreak;\n\tcase TPS658643:\n\t\tname = \"TPS658643\";\n\t\tbreak;\n\tdefault:\n\t\tname = \"TPS6586X\";\n\t\tbreak;\n\t}\n\n\tdev_info(&client->dev, \"Found %s, VERSIONCRC is %02x\\n\", name, version);\n}\n\nstatic int tps6586x_i2c_probe(struct i2c_client *client)\n{\n\tstruct tps6586x_platform_data *pdata = dev_get_platdata(&client->dev);\n\tstruct tps6586x *tps6586x;\n\tint ret;\n\tint version;\n\n\tif (!pdata && client->dev.of_node)\n\t\tpdata = tps6586x_parse_dt(client);\n\n\tif (!pdata) {\n\t\tdev_err(&client->dev, \"tps6586x requires platform data\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tversion = i2c_smbus_read_byte_data(client, TPS6586X_VERSIONCRC);\n\tif (version < 0) {\n\t\tdev_err(&client->dev, \"Chip ID read failed: %d\\n\", version);\n\t\treturn -EIO;\n\t}\n\n\ttps6586x = devm_kzalloc(&client->dev, sizeof(*tps6586x), GFP_KERNEL);\n\tif (!tps6586x)\n\t\treturn -ENOMEM;\n\n\ttps6586x->version = version;\n\ttps6586x_print_version(client, tps6586x->version);\n\n\ttps6586x->client = client;\n\ttps6586x->dev = &client->dev;\n\ti2c_set_clientdata(client, tps6586x);\n\n\ttps6586x->regmap = devm_regmap_init_i2c(client,\n\t\t\t\t\t&tps6586x_regmap_config);\n\tif (IS_ERR(tps6586x->regmap)) {\n\t\tret = PTR_ERR(tps6586x->regmap);\n\t\tdev_err(&client->dev, \"regmap init failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\n\tif (client->irq) {\n\t\tret = tps6586x_irq_init(tps6586x, client->irq,\n\t\t\t\t\tpdata->irq_base);\n\t\tif (ret) {\n\t\t\tdev_err(&client->dev, \"IRQ init failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = mfd_add_devices(tps6586x->dev, -1,\n\t\t\t      tps6586x_cell, ARRAY_SIZE(tps6586x_cell),\n\t\t\t      NULL, 0, tps6586x->irq_domain);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"mfd_add_devices failed: %d\\n\", ret);\n\t\tgoto err_mfd_add;\n\t}\n\n\tret = tps6586x_add_subdevs(tps6586x, pdata);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"add devices failed: %d\\n\", ret);\n\t\tgoto err_add_devs;\n\t}\n\n\tif (pdata->pm_off && !pm_power_off) {\n\t\ttps6586x_dev = &client->dev;\n\t\tpm_power_off = tps6586x_power_off;\n\t}\n\n\treturn 0;\n\nerr_add_devs:\n\tmfd_remove_devices(tps6586x->dev);\nerr_mfd_add:\n\tif (client->irq)\n\t\tfree_irq(client->irq, tps6586x);\n\treturn ret;\n}\n\nstatic void tps6586x_i2c_remove(struct i2c_client *client)\n{\n\tstruct tps6586x *tps6586x = i2c_get_clientdata(client);\n\n\ttps6586x_remove_subdevs(tps6586x);\n\tmfd_remove_devices(tps6586x->dev);\n\tif (client->irq)\n\t\tfree_irq(client->irq, tps6586x);\n}\n\nstatic int __maybe_unused tps6586x_i2c_suspend(struct device *dev)\n{\n\tstruct tps6586x *tps6586x = dev_get_drvdata(dev);\n\n\tif (tps6586x->client->irq)\n\t\tdisable_irq(tps6586x->client->irq);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused tps6586x_i2c_resume(struct device *dev)\n{\n\tstruct tps6586x *tps6586x = dev_get_drvdata(dev);\n\n\tif (tps6586x->client->irq)\n\t\tenable_irq(tps6586x->client->irq);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(tps6586x_pm_ops, tps6586x_i2c_suspend,\n\t\t\t tps6586x_i2c_resume);\n\nstatic const struct i2c_device_id tps6586x_id_table[] = {\n\t{ \"tps6586x\", 0 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(i2c, tps6586x_id_table);\n\nstatic struct i2c_driver tps6586x_driver = {\n\t.driver\t= {\n\t\t.name\t= \"tps6586x\",\n\t\t.of_match_table = of_match_ptr(tps6586x_of_match),\n\t\t.pm\t= &tps6586x_pm_ops,\n\t},\n\t.probe\t\t= tps6586x_i2c_probe,\n\t.remove\t\t= tps6586x_i2c_remove,\n\t.id_table\t= tps6586x_id_table,\n};\n\nstatic int __init tps6586x_init(void)\n{\n\treturn i2c_add_driver(&tps6586x_driver);\n}\nsubsys_initcall(tps6586x_init);\n\nstatic void __exit tps6586x_exit(void)\n{\n\ti2c_del_driver(&tps6586x_driver);\n}\nmodule_exit(tps6586x_exit);\n\nMODULE_DESCRIPTION(\"TPS6586X core driver\");\nMODULE_AUTHOR(\"Mike Rapoport <mike@compulab.co.il>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}