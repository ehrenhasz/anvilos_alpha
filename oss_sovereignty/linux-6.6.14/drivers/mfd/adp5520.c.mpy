{
  "module_name": "adp5520.c",
  "hash_id": "a432ad0e1629d17fa4746197a3c94023af8f716255fd5b148f53b96e7d3da90a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/adp5520.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n\n#include <linux/mfd/adp5520.h>\n\nstruct adp5520_chip {\n\tstruct i2c_client *client;\n\tstruct device *dev;\n\tstruct mutex lock;\n\tstruct blocking_notifier_head notifier_list;\n\tint irq;\n\tunsigned long id;\n\tuint8_t mode;\n};\n\nstatic int __adp5520_read(struct i2c_client *client,\n\t\t\t\tint reg, uint8_t *val)\n{\n\tint ret;\n\n\tret = i2c_smbus_read_byte_data(client, reg);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"failed reading at 0x%02x\\n\", reg);\n\t\treturn ret;\n\t}\n\n\t*val = (uint8_t)ret;\n\treturn 0;\n}\n\nstatic int __adp5520_write(struct i2c_client *client,\n\t\t\t\t int reg, uint8_t val)\n{\n\tint ret;\n\n\tret = i2c_smbus_write_byte_data(client, reg, val);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"failed writing 0x%02x to 0x%02x\\n\",\n\t\t\t\tval, reg);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int __adp5520_ack_bits(struct i2c_client *client, int reg,\n\t\t\t      uint8_t bit_mask)\n{\n\tstruct adp5520_chip *chip = i2c_get_clientdata(client);\n\tuint8_t reg_val;\n\tint ret;\n\n\tmutex_lock(&chip->lock);\n\n\tret = __adp5520_read(client, reg, &reg_val);\n\n\tif (!ret) {\n\t\treg_val |= bit_mask;\n\t\tret = __adp5520_write(client, reg, reg_val);\n\t}\n\n\tmutex_unlock(&chip->lock);\n\treturn ret;\n}\n\nint adp5520_write(struct device *dev, int reg, uint8_t val)\n{\n\treturn __adp5520_write(to_i2c_client(dev), reg, val);\n}\nEXPORT_SYMBOL_GPL(adp5520_write);\n\nint adp5520_read(struct device *dev, int reg, uint8_t *val)\n{\n\treturn __adp5520_read(to_i2c_client(dev), reg, val);\n}\nEXPORT_SYMBOL_GPL(adp5520_read);\n\nint adp5520_set_bits(struct device *dev, int reg, uint8_t bit_mask)\n{\n\tstruct adp5520_chip *chip = dev_get_drvdata(dev);\n\tuint8_t reg_val;\n\tint ret;\n\n\tmutex_lock(&chip->lock);\n\n\tret = __adp5520_read(chip->client, reg, &reg_val);\n\n\tif (!ret && ((reg_val & bit_mask) != bit_mask)) {\n\t\treg_val |= bit_mask;\n\t\tret = __adp5520_write(chip->client, reg, reg_val);\n\t}\n\n\tmutex_unlock(&chip->lock);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(adp5520_set_bits);\n\nint adp5520_clr_bits(struct device *dev, int reg, uint8_t bit_mask)\n{\n\tstruct adp5520_chip *chip = dev_get_drvdata(dev);\n\tuint8_t reg_val;\n\tint ret;\n\n\tmutex_lock(&chip->lock);\n\n\tret = __adp5520_read(chip->client, reg, &reg_val);\n\n\tif (!ret && (reg_val & bit_mask)) {\n\t\treg_val &= ~bit_mask;\n\t\tret = __adp5520_write(chip->client, reg, reg_val);\n\t}\n\n\tmutex_unlock(&chip->lock);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(adp5520_clr_bits);\n\nint adp5520_register_notifier(struct device *dev, struct notifier_block *nb,\n\t\t\t\tunsigned int events)\n{\n\tstruct adp5520_chip *chip = dev_get_drvdata(dev);\n\n\tif (chip->irq) {\n\t\tadp5520_set_bits(chip->dev, ADP5520_INTERRUPT_ENABLE,\n\t\t\tevents & (ADP5520_KP_IEN | ADP5520_KR_IEN |\n\t\t\tADP5520_OVP_IEN | ADP5520_CMPR_IEN));\n\n\t\treturn blocking_notifier_chain_register(&chip->notifier_list,\n\t\t\t nb);\n\t}\n\n\treturn -ENODEV;\n}\nEXPORT_SYMBOL_GPL(adp5520_register_notifier);\n\nint adp5520_unregister_notifier(struct device *dev, struct notifier_block *nb,\n\t\t\t\tunsigned int events)\n{\n\tstruct adp5520_chip *chip = dev_get_drvdata(dev);\n\n\tadp5520_clr_bits(chip->dev, ADP5520_INTERRUPT_ENABLE,\n\t\tevents & (ADP5520_KP_IEN | ADP5520_KR_IEN |\n\t\tADP5520_OVP_IEN | ADP5520_CMPR_IEN));\n\n\treturn blocking_notifier_chain_unregister(&chip->notifier_list, nb);\n}\nEXPORT_SYMBOL_GPL(adp5520_unregister_notifier);\n\nstatic irqreturn_t adp5520_irq_thread(int irq, void *data)\n{\n\tstruct adp5520_chip *chip = data;\n\tunsigned int events;\n\tuint8_t reg_val;\n\tint ret;\n\n\tret = __adp5520_read(chip->client, ADP5520_MODE_STATUS, &reg_val);\n\tif (ret)\n\t\tgoto out;\n\n\tevents =  reg_val & (ADP5520_OVP_INT | ADP5520_CMPR_INT |\n\t\tADP5520_GPI_INT | ADP5520_KR_INT | ADP5520_KP_INT);\n\n\tblocking_notifier_call_chain(&chip->notifier_list, events, NULL);\n\t \n\t__adp5520_ack_bits(chip->client, ADP5520_MODE_STATUS, events);\n\nout:\n\treturn IRQ_HANDLED;\n}\n\nstatic int __remove_subdev(struct device *dev, void *unused)\n{\n\tplatform_device_unregister(to_platform_device(dev));\n\treturn 0;\n}\n\nstatic int adp5520_remove_subdevs(struct adp5520_chip *chip)\n{\n\treturn device_for_each_child(chip->dev, NULL, __remove_subdev);\n}\n\nstatic int adp5520_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct adp5520_platform_data *pdata = dev_get_platdata(&client->dev);\n\tstruct platform_device *pdev;\n\tstruct adp5520_chip *chip;\n\tint ret;\n\n\tif (!i2c_check_functionality(client->adapter,\n\t\t\t\t\tI2C_FUNC_SMBUS_BYTE_DATA)) {\n\t\tdev_err(&client->dev, \"SMBUS Word Data not Supported\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (pdata == NULL) {\n\t\tdev_err(&client->dev, \"missing platform data\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tchip = devm_kzalloc(&client->dev, sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, chip);\n\tchip->client = client;\n\n\tchip->dev = &client->dev;\n\tchip->irq = client->irq;\n\tchip->id = id->driver_data;\n\tmutex_init(&chip->lock);\n\n\tif (chip->irq) {\n\t\tBLOCKING_INIT_NOTIFIER_HEAD(&chip->notifier_list);\n\n\t\tret = request_threaded_irq(chip->irq, NULL, adp5520_irq_thread,\n\t\t\t\tIRQF_TRIGGER_LOW | IRQF_ONESHOT,\n\t\t\t\t\"adp5520\", chip);\n\t\tif (ret) {\n\t\t\tdev_err(&client->dev, \"failed to request irq %d\\n\",\n\t\t\t\t\tchip->irq);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = adp5520_write(chip->dev, ADP5520_MODE_STATUS, ADP5520_nSTNBY);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"failed to write\\n\");\n\t\tgoto out_free_irq;\n\t}\n\n\tif (pdata->keys) {\n\t\tpdev = platform_device_register_data(chip->dev, \"adp5520-keys\",\n\t\t\t\tchip->id, pdata->keys, sizeof(*pdata->keys));\n\t\tif (IS_ERR(pdev)) {\n\t\t\tret = PTR_ERR(pdev);\n\t\t\tgoto out_remove_subdevs;\n\t\t}\n\t}\n\n\tif (pdata->gpio) {\n\t\tpdev = platform_device_register_data(chip->dev, \"adp5520-gpio\",\n\t\t\t\tchip->id, pdata->gpio, sizeof(*pdata->gpio));\n\t\tif (IS_ERR(pdev)) {\n\t\t\tret = PTR_ERR(pdev);\n\t\t\tgoto out_remove_subdevs;\n\t\t}\n\t}\n\n\tif (pdata->leds) {\n\t\tpdev = platform_device_register_data(chip->dev, \"adp5520-led\",\n\t\t\t\tchip->id, pdata->leds, sizeof(*pdata->leds));\n\t\tif (IS_ERR(pdev)) {\n\t\t\tret = PTR_ERR(pdev);\n\t\t\tgoto out_remove_subdevs;\n\t\t}\n\t}\n\n\tif (pdata->backlight) {\n\t\tpdev = platform_device_register_data(chip->dev,\n\t\t\t\t\t\t\"adp5520-backlight\",\n\t\t\t\t\t\tchip->id,\n\t\t\t\t\t\tpdata->backlight,\n\t\t\t\t\t\tsizeof(*pdata->backlight));\n\t\tif (IS_ERR(pdev)) {\n\t\t\tret = PTR_ERR(pdev);\n\t\t\tgoto out_remove_subdevs;\n\t\t}\n\t}\n\n\treturn 0;\n\nout_remove_subdevs:\n\tadp5520_remove_subdevs(chip);\n\nout_free_irq:\n\tif (chip->irq)\n\t\tfree_irq(chip->irq, chip);\n\n\treturn ret;\n}\n\nstatic int adp5520_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct adp5520_chip *chip = dev_get_drvdata(&client->dev);\n\n\tadp5520_read(chip->dev, ADP5520_MODE_STATUS, &chip->mode);\n\t \n\tchip->mode &= ADP5520_BL_EN | ADP5520_DIM_EN | ADP5520_nSTNBY;\n\tadp5520_write(chip->dev, ADP5520_MODE_STATUS, 0);\n\treturn 0;\n}\n\nstatic int adp5520_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct adp5520_chip *chip = dev_get_drvdata(&client->dev);\n\n\tadp5520_write(chip->dev, ADP5520_MODE_STATUS, chip->mode);\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(adp5520_pm, adp5520_suspend, adp5520_resume);\n\nstatic const struct i2c_device_id adp5520_id[] = {\n\t{ \"pmic-adp5520\", ID_ADP5520 },\n\t{ \"pmic-adp5501\", ID_ADP5501 },\n\t{ }\n};\n\nstatic struct i2c_driver adp5520_driver = {\n\t.driver = {\n\t\t.name\t\t\t= \"adp5520\",\n\t\t.pm\t\t\t= pm_sleep_ptr(&adp5520_pm),\n\t\t.suppress_bind_attrs\t= true,\n\t},\n\t.probe\t\t= adp5520_probe,\n\t.id_table\t= adp5520_id,\n};\nbuiltin_i2c_driver(adp5520_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}