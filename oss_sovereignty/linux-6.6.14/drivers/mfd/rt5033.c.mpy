{
  "module_name": "rt5033.c",
  "hash_id": "5bcfbcb178b51ec45c2e344145d5d814033193a20052faf2af8060344951a68d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/rt5033.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/rt5033.h>\n#include <linux/mfd/rt5033-private.h>\n\nstatic const struct regmap_irq rt5033_irqs[] = {\n\t{ .mask = RT5033_PMIC_IRQ_BUCKOCP, },\n\t{ .mask = RT5033_PMIC_IRQ_BUCKLV, },\n\t{ .mask = RT5033_PMIC_IRQ_SAFELDOLV, },\n\t{ .mask = RT5033_PMIC_IRQ_LDOLV, },\n\t{ .mask = RT5033_PMIC_IRQ_OT, },\n\t{ .mask = RT5033_PMIC_IRQ_VDDA_UV, },\n};\n\nstatic const struct regmap_irq_chip rt5033_irq_chip = {\n\t.name\t\t= \"rt5033\",\n\t.status_base\t= RT5033_REG_PMIC_IRQ_STAT,\n\t.unmask_base\t= RT5033_REG_PMIC_IRQ_CTRL,\n\t.num_regs\t= 1,\n\t.irqs\t\t= rt5033_irqs,\n\t.num_irqs\t= ARRAY_SIZE(rt5033_irqs),\n};\n\nstatic const struct mfd_cell rt5033_devs[] = {\n\t{ .name = \"rt5033-regulator\", },\n\t{\n\t\t.name = \"rt5033-charger\",\n\t\t.of_compatible = \"richtek,rt5033-charger\",\n\t}, {\n\t\t.name = \"rt5033-led\",\n\t\t.of_compatible = \"richtek,rt5033-led\",\n\t},\n};\n\nstatic const struct regmap_config rt5033_regmap_config = {\n\t.reg_bits\t= 8,\n\t.val_bits\t= 8,\n\t.max_register\t= RT5033_REG_END,\n};\n\nstatic int rt5033_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct rt5033_dev *rt5033;\n\tunsigned int dev_id, chip_rev;\n\tint ret;\n\n\trt5033 = devm_kzalloc(&i2c->dev, sizeof(*rt5033), GFP_KERNEL);\n\tif (!rt5033)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(i2c, rt5033);\n\trt5033->dev = &i2c->dev;\n\trt5033->irq = i2c->irq;\n\trt5033->wakeup = true;\n\n\trt5033->regmap = devm_regmap_init_i2c(i2c, &rt5033_regmap_config);\n\tif (IS_ERR(rt5033->regmap)) {\n\t\tdev_err(&i2c->dev, \"Failed to allocate register map.\\n\");\n\t\treturn PTR_ERR(rt5033->regmap);\n\t}\n\n\tret = regmap_read(rt5033->regmap, RT5033_REG_DEVICE_ID, &dev_id);\n\tif (ret) {\n\t\tdev_err(&i2c->dev, \"Device not found\\n\");\n\t\treturn -ENODEV;\n\t}\n\tchip_rev = dev_id & RT5033_CHIP_REV_MASK;\n\tdev_info(&i2c->dev, \"Device found (rev. %d)\\n\", chip_rev);\n\n\tret = regmap_add_irq_chip(rt5033->regmap, rt5033->irq,\n\t\t\tIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\n\t\t\t0, &rt5033_irq_chip, &rt5033->irq_data);\n\tif (ret) {\n\t\tdev_err(&i2c->dev, \"Failed to request IRQ %d: %d\\n\",\n\t\t\t\t\t\t\trt5033->irq, ret);\n\t\treturn ret;\n\t}\n\n\tret = devm_mfd_add_devices(rt5033->dev, -1, rt5033_devs,\n\t\t\t\t   ARRAY_SIZE(rt5033_devs), NULL, 0,\n\t\t\t\t   regmap_irq_get_domain(rt5033->irq_data));\n\tif (ret < 0) {\n\t\tdev_err(&i2c->dev, \"Failed to add RT5033 child devices.\\n\");\n\t\treturn ret;\n\t}\n\n\tdevice_init_wakeup(rt5033->dev, rt5033->wakeup);\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id rt5033_i2c_id[] = {\n\t{ \"rt5033\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, rt5033_i2c_id);\n\nstatic const struct of_device_id rt5033_dt_match[] = {\n\t{ .compatible = \"richtek,rt5033\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, rt5033_dt_match);\n\nstatic struct i2c_driver rt5033_driver = {\n\t.driver = {\n\t\t.name = \"rt5033\",\n\t\t.of_match_table = rt5033_dt_match,\n\t},\n\t.probe = rt5033_i2c_probe,\n\t.id_table = rt5033_i2c_id,\n};\nmodule_i2c_driver(rt5033_driver);\n\nMODULE_DESCRIPTION(\"Richtek RT5033 multi-function core driver\");\nMODULE_AUTHOR(\"Beomho Seo <beomho.seo@samsung.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}