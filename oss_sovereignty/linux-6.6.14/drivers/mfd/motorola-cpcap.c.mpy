{
  "module_name": "motorola-cpcap.c",
  "hash_id": "4c6c498003dd099e2520f6f205bf5b00955519210eba150fcf241bd42f67b927",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/motorola-cpcap.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of_device.h>\n#include <linux/regmap.h>\n#include <linux/sysfs.h>\n\n#include <linux/mfd/core.h>\n#include <linux/mfd/motorola-cpcap.h>\n#include <linux/spi/spi.h>\n\n#define CPCAP_NR_IRQ_REG_BANKS\t6\n#define CPCAP_NR_IRQ_CHIPS\t3\n#define CPCAP_REGISTER_SIZE\t4\n#define CPCAP_REGISTER_BITS\t16\n\nstruct cpcap_ddata {\n\tstruct spi_device *spi;\n\tstruct regmap_irq *irqs;\n\tstruct regmap_irq_chip_data *irqdata[CPCAP_NR_IRQ_CHIPS];\n\tconst struct regmap_config *regmap_conf;\n\tstruct regmap *regmap;\n};\n\nstatic int cpcap_sense_irq(struct regmap *regmap, int irq)\n{\n\tint regnum = irq / CPCAP_REGISTER_BITS;\n\tint mask = BIT(irq % CPCAP_REGISTER_BITS);\n\tint reg = CPCAP_REG_INTS1 + (regnum * CPCAP_REGISTER_SIZE);\n\tint err, val;\n\n\tif (reg < CPCAP_REG_INTS1 || reg > CPCAP_REG_INTS4)\n\t\treturn -EINVAL;\n\n\terr = regmap_read(regmap, reg, &val);\n\tif (err)\n\t\treturn err;\n\n\treturn !!(val & mask);\n}\n\nint cpcap_sense_virq(struct regmap *regmap, int virq)\n{\n\tstruct regmap_irq_chip_data *d = irq_get_chip_data(virq);\n\tint irq_base = regmap_irq_chip_get_base(d);\n\n\treturn cpcap_sense_irq(regmap, virq - irq_base);\n}\nEXPORT_SYMBOL_GPL(cpcap_sense_virq);\n\nstatic int cpcap_check_revision(struct cpcap_ddata *cpcap)\n{\n\tu16 vendor, rev;\n\tint ret;\n\n\tret = cpcap_get_vendor(&cpcap->spi->dev, cpcap->regmap, &vendor);\n\tif (ret)\n\t\treturn ret;\n\n\tret = cpcap_get_revision(&cpcap->spi->dev, cpcap->regmap, &rev);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_info(&cpcap->spi->dev, \"CPCAP vendor: %s rev: %i.%i (%x)\\n\",\n\t\t vendor == CPCAP_VENDOR_ST ? \"ST\" : \"TI\",\n\t\t CPCAP_REVISION_MAJOR(rev), CPCAP_REVISION_MINOR(rev),\n\t\t rev);\n\n\tif (rev < CPCAP_REVISION_2_1) {\n\t\tdev_info(&cpcap->spi->dev,\n\t\t\t \"Please add old CPCAP revision support as needed\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\n \nstatic struct regmap_irq_chip cpcap_irq_chip[CPCAP_NR_IRQ_CHIPS] = {\n\t{\n\t\t.name = \"cpcap-m2\",\n\t\t.num_regs = 1,\n\t\t.status_base = CPCAP_REG_MI1,\n\t\t.ack_base = CPCAP_REG_MI1,\n\t\t.mask_base = CPCAP_REG_MIM1,\n\t\t.use_ack = true,\n\t\t.clear_ack = true,\n\t},\n\t{\n\t\t.name = \"cpcap-m2\",\n\t\t.num_regs = 1,\n\t\t.status_base = CPCAP_REG_MI2,\n\t\t.ack_base = CPCAP_REG_MI2,\n\t\t.mask_base = CPCAP_REG_MIM2,\n\t\t.use_ack = true,\n\t\t.clear_ack = true,\n\t},\n\t{\n\t\t.name = \"cpcap1-4\",\n\t\t.num_regs = 4,\n\t\t.status_base = CPCAP_REG_INT1,\n\t\t.ack_base = CPCAP_REG_INT1,\n\t\t.mask_base = CPCAP_REG_INTM1,\n\t\t.use_ack = true,\n\t\t.clear_ack = true,\n\t},\n};\n\nstatic void cpcap_init_one_regmap_irq(struct cpcap_ddata *cpcap,\n\t\t\t\t      struct regmap_irq *rirq,\n\t\t\t\t      int irq_base, int irq)\n{\n\tunsigned int reg_offset;\n\tunsigned int bit, mask;\n\n\treg_offset = irq - irq_base;\n\treg_offset /= cpcap->regmap_conf->val_bits;\n\treg_offset *= cpcap->regmap_conf->reg_stride;\n\n\tbit = irq % cpcap->regmap_conf->val_bits;\n\tmask = (1 << bit);\n\n\trirq->reg_offset = reg_offset;\n\trirq->mask = mask;\n}\n\nstatic int cpcap_init_irq_chip(struct cpcap_ddata *cpcap, int irq_chip,\n\t\t\t       int irq_start, int nr_irqs)\n{\n\tstruct regmap_irq_chip *chip = &cpcap_irq_chip[irq_chip];\n\tint i, ret;\n\n\tfor (i = irq_start; i < irq_start + nr_irqs; i++) {\n\t\tstruct regmap_irq *rirq = &cpcap->irqs[i];\n\n\t\tcpcap_init_one_regmap_irq(cpcap, rirq, irq_start, i);\n\t}\n\tchip->irqs = &cpcap->irqs[irq_start];\n\tchip->num_irqs = nr_irqs;\n\tchip->irq_drv_data = cpcap;\n\n\tret = devm_regmap_add_irq_chip(&cpcap->spi->dev, cpcap->regmap,\n\t\t\t\t       cpcap->spi->irq,\n\t\t\t\t       irq_get_trigger_type(cpcap->spi->irq) |\n\t\t\t\t       IRQF_SHARED, -1,\n\t\t\t\t       chip, &cpcap->irqdata[irq_chip]);\n\tif (ret) {\n\t\tdev_err(&cpcap->spi->dev, \"could not add irq chip %i: %i\\n\",\n\t\t\tirq_chip, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int cpcap_init_irq(struct cpcap_ddata *cpcap)\n{\n\tint ret;\n\n\tcpcap->irqs = devm_kzalloc(&cpcap->spi->dev,\n\t\t\t\t   array3_size(sizeof(*cpcap->irqs),\n\t\t\t\t\t       CPCAP_NR_IRQ_REG_BANKS,\n\t\t\t\t\t       cpcap->regmap_conf->val_bits),\n\t\t\t\t   GFP_KERNEL);\n\tif (!cpcap->irqs)\n\t\treturn -ENOMEM;\n\n\tret = cpcap_init_irq_chip(cpcap, 0, 0, 16);\n\tif (ret)\n\t\treturn ret;\n\n\tret = cpcap_init_irq_chip(cpcap, 1, 16, 16);\n\tif (ret)\n\t\treturn ret;\n\n\tret = cpcap_init_irq_chip(cpcap, 2, 32, 64);\n\tif (ret)\n\t\treturn ret;\n\n\tenable_irq_wake(cpcap->spi->irq);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id cpcap_of_match[] = {\n\t{ .compatible = \"motorola,cpcap\", },\n\t{ .compatible = \"st,6556002\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, cpcap_of_match);\n\nstatic const struct spi_device_id cpcap_spi_ids[] = {\n\t{ .name = \"cpcap\", },\n\t{ .name = \"6556002\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(spi, cpcap_spi_ids);\n\nstatic const struct regmap_config cpcap_regmap_config = {\n\t.reg_bits = 16,\n\t.reg_stride = 4,\n\t.pad_bits = 0,\n\t.val_bits = 16,\n\t.write_flag_mask = 0x8000,\n\t.max_register = CPCAP_REG_ST_TEST2,\n\t.cache_type = REGCACHE_NONE,\n\t.reg_format_endian = REGMAP_ENDIAN_LITTLE,\n\t.val_format_endian = REGMAP_ENDIAN_LITTLE,\n};\n\nstatic int cpcap_suspend(struct device *dev)\n{\n\tstruct spi_device *spi = to_spi_device(dev);\n\n\tdisable_irq(spi->irq);\n\n\treturn 0;\n}\n\nstatic int cpcap_resume(struct device *dev)\n{\n\tstruct spi_device *spi = to_spi_device(dev);\n\n\tenable_irq(spi->irq);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(cpcap_pm, cpcap_suspend, cpcap_resume);\n\nstatic const struct mfd_cell cpcap_mfd_devices[] = {\n\t{\n\t\t.name          = \"cpcap_adc\",\n\t\t.of_compatible = \"motorola,mapphone-cpcap-adc\",\n\t}, {\n\t\t.name          = \"cpcap_battery\",\n\t\t.of_compatible = \"motorola,cpcap-battery\",\n\t}, {\n\t\t.name          = \"cpcap-charger\",\n\t\t.of_compatible = \"motorola,mapphone-cpcap-charger\",\n\t}, {\n\t\t.name          = \"cpcap-regulator\",\n\t\t.of_compatible = \"motorola,mapphone-cpcap-regulator\",\n\t}, {\n\t\t.name          = \"cpcap-rtc\",\n\t\t.of_compatible = \"motorola,cpcap-rtc\",\n\t}, {\n\t\t.name          = \"cpcap-pwrbutton\",\n\t\t.of_compatible = \"motorola,cpcap-pwrbutton\",\n\t}, {\n\t\t.name          = \"cpcap-usb-phy\",\n\t\t.of_compatible = \"motorola,mapphone-cpcap-usb-phy\",\n\t}, {\n\t\t.name          = \"cpcap-led\",\n\t\t.id            = 0,\n\t\t.of_compatible = \"motorola,cpcap-led-red\",\n\t}, {\n\t\t.name          = \"cpcap-led\",\n\t\t.id            = 1,\n\t\t.of_compatible = \"motorola,cpcap-led-green\",\n\t}, {\n\t\t.name          = \"cpcap-led\",\n\t\t.id            = 2,\n\t\t.of_compatible = \"motorola,cpcap-led-blue\",\n\t}, {\n\t\t.name          = \"cpcap-led\",\n\t\t.id            = 3,\n\t\t.of_compatible = \"motorola,cpcap-led-adl\",\n\t}, {\n\t\t.name          = \"cpcap-led\",\n\t\t.id            = 4,\n\t\t.of_compatible = \"motorola,cpcap-led-cp\",\n\t}, {\n\t\t.name          = \"cpcap-codec\",\n\t}\n};\n\nstatic int cpcap_probe(struct spi_device *spi)\n{\n\tconst struct of_device_id *match;\n\tstruct cpcap_ddata *cpcap;\n\tint ret;\n\n\tmatch = of_match_device(cpcap_of_match, &spi->dev);\n\tif (!match)\n\t\treturn -ENODEV;\n\n\tcpcap = devm_kzalloc(&spi->dev, sizeof(*cpcap), GFP_KERNEL);\n\tif (!cpcap)\n\t\treturn -ENOMEM;\n\n\tcpcap->spi = spi;\n\tspi_set_drvdata(spi, cpcap);\n\n\tspi->bits_per_word = 16;\n\tspi->mode = SPI_MODE_0 | SPI_CS_HIGH;\n\n\tret = spi_setup(spi);\n\tif (ret)\n\t\treturn ret;\n\n\tcpcap->regmap_conf = &cpcap_regmap_config;\n\tcpcap->regmap = devm_regmap_init_spi(spi, &cpcap_regmap_config);\n\tif (IS_ERR(cpcap->regmap)) {\n\t\tret = PTR_ERR(cpcap->regmap);\n\t\tdev_err(&cpcap->spi->dev, \"Failed to initialize regmap: %d\\n\",\n\t\t\tret);\n\n\t\treturn ret;\n\t}\n\n\tret = cpcap_check_revision(cpcap);\n\tif (ret) {\n\t\tdev_err(&cpcap->spi->dev, \"Failed to detect CPCAP: %i\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = cpcap_init_irq(cpcap);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tspi->dev.coherent_dma_mask = 0;\n\tspi->dev.dma_mask = &spi->dev.coherent_dma_mask;\n\n\treturn devm_mfd_add_devices(&spi->dev, 0, cpcap_mfd_devices,\n\t\t\t\t    ARRAY_SIZE(cpcap_mfd_devices), NULL, 0, NULL);\n}\n\nstatic struct spi_driver cpcap_driver = {\n\t.driver = {\n\t\t.name = \"cpcap-core\",\n\t\t.of_match_table = cpcap_of_match,\n\t\t.pm = pm_sleep_ptr(&cpcap_pm),\n\t},\n\t.probe = cpcap_probe,\n\t.id_table = cpcap_spi_ids,\n};\nmodule_spi_driver(cpcap_driver);\n\nMODULE_ALIAS(\"platform:cpcap\");\nMODULE_DESCRIPTION(\"CPCAP driver\");\nMODULE_AUTHOR(\"Tony Lindgren <tony@atomide.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}