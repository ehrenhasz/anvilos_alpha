{
  "module_name": "sprd-sc27xx-spi.c",
  "hash_id": "2c684c9ae1a7868d98274a08e71f43110ae04000c8eb41f1c5e7fee9fa6e2a0d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/sprd-sc27xx-spi.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/sc27xx-pmic.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/regmap.h>\n#include <linux/spi/spi.h>\n#include <uapi/linux/usb/charger.h>\n\n#define SPRD_PMIC_INT_MASK_STATUS\t0x0\n#define SPRD_PMIC_INT_RAW_STATUS\t0x4\n#define SPRD_PMIC_INT_EN\t\t0x8\n\n#define SPRD_SC2730_IRQ_BASE\t\t0x80\n#define SPRD_SC2730_IRQ_NUMS\t\t10\n#define SPRD_SC2730_CHG_DET\t\t0x1b9c\n#define SPRD_SC2731_IRQ_BASE\t\t0x140\n#define SPRD_SC2731_IRQ_NUMS\t\t16\n#define SPRD_SC2731_CHG_DET\t\t0xedc\n\n \n#define SPRD_PMIC_CHG_DET_DELAY_US\t200000\n#define SPRD_PMIC_CHG_DET_TIMEOUT\t2000000\n#define SPRD_PMIC_CHG_DET_DONE\t\tBIT(11)\n#define SPRD_PMIC_SDP_TYPE\t\tBIT(7)\n#define SPRD_PMIC_DCP_TYPE\t\tBIT(6)\n#define SPRD_PMIC_CDP_TYPE\t\tBIT(5)\n#define SPRD_PMIC_CHG_TYPE_MASK\t\tGENMASK(7, 5)\n\nstruct sprd_pmic {\n\tstruct regmap *regmap;\n\tstruct device *dev;\n\tstruct regmap_irq *irqs;\n\tstruct regmap_irq_chip irq_chip;\n\tstruct regmap_irq_chip_data *irq_data;\n\tconst struct sprd_pmic_data *pdata;\n\tint irq;\n};\n\nstruct sprd_pmic_data {\n\tu32 irq_base;\n\tu32 num_irqs;\n\tu32 charger_det;\n};\n\n \nstatic const struct sprd_pmic_data sc2730_data = {\n\t.irq_base = SPRD_SC2730_IRQ_BASE,\n\t.num_irqs = SPRD_SC2730_IRQ_NUMS,\n\t.charger_det = SPRD_SC2730_CHG_DET,\n};\n\nstatic const struct sprd_pmic_data sc2731_data = {\n\t.irq_base = SPRD_SC2731_IRQ_BASE,\n\t.num_irqs = SPRD_SC2731_IRQ_NUMS,\n\t.charger_det = SPRD_SC2731_CHG_DET,\n};\n\nenum usb_charger_type sprd_pmic_detect_charger_type(struct device *dev)\n{\n\tstruct spi_device *spi = to_spi_device(dev);\n\tstruct sprd_pmic *ddata = spi_get_drvdata(spi);\n\tconst struct sprd_pmic_data *pdata = ddata->pdata;\n\tenum usb_charger_type type;\n\tu32 val;\n\tint ret;\n\n\tret = regmap_read_poll_timeout(ddata->regmap, pdata->charger_det, val,\n\t\t\t\t       (val & SPRD_PMIC_CHG_DET_DONE),\n\t\t\t\t       SPRD_PMIC_CHG_DET_DELAY_US,\n\t\t\t\t       SPRD_PMIC_CHG_DET_TIMEOUT);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"failed to detect charger type\\n\");\n\t\treturn UNKNOWN_TYPE;\n\t}\n\n\tswitch (val & SPRD_PMIC_CHG_TYPE_MASK) {\n\tcase SPRD_PMIC_CDP_TYPE:\n\t\ttype = CDP_TYPE;\n\t\tbreak;\n\tcase SPRD_PMIC_DCP_TYPE:\n\t\ttype = DCP_TYPE;\n\t\tbreak;\n\tcase SPRD_PMIC_SDP_TYPE:\n\t\ttype = SDP_TYPE;\n\t\tbreak;\n\tdefault:\n\t\ttype = UNKNOWN_TYPE;\n\t\tbreak;\n\t}\n\n\treturn type;\n}\nEXPORT_SYMBOL_GPL(sprd_pmic_detect_charger_type);\n\nstatic int sprd_pmic_spi_write(void *context, const void *data, size_t count)\n{\n\tstruct device *dev = context;\n\tstruct spi_device *spi = to_spi_device(dev);\n\n\treturn spi_write(spi, data, count);\n}\n\nstatic int sprd_pmic_spi_read(void *context,\n\t\t\t      const void *reg, size_t reg_size,\n\t\t\t      void *val, size_t val_size)\n{\n\tstruct device *dev = context;\n\tstruct spi_device *spi = to_spi_device(dev);\n\tu32 rx_buf[2] = { 0 };\n\tint ret;\n\n\t \n\tif (reg_size != sizeof(u32) || val_size != sizeof(u32))\n\t\treturn -EINVAL;\n\n\t \n\tmemcpy(rx_buf, reg, sizeof(u32));\n\tret = spi_read(spi, rx_buf, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmemcpy(val, rx_buf, val_size);\n\treturn 0;\n}\n\nstatic struct regmap_bus sprd_pmic_regmap = {\n\t.write = sprd_pmic_spi_write,\n\t.read = sprd_pmic_spi_read,\n\t.reg_format_endian_default = REGMAP_ENDIAN_NATIVE,\n\t.val_format_endian_default = REGMAP_ENDIAN_NATIVE,\n};\n\nstatic const struct regmap_config sprd_pmic_config = {\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n\t.max_register = 0xffff,\n};\n\nstatic int sprd_pmic_probe(struct spi_device *spi)\n{\n\tstruct sprd_pmic *ddata;\n\tconst struct sprd_pmic_data *pdata;\n\tint ret, i;\n\n\tpdata = of_device_get_match_data(&spi->dev);\n\tif (!pdata) {\n\t\tdev_err(&spi->dev, \"No matching driver data found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tddata = devm_kzalloc(&spi->dev, sizeof(*ddata), GFP_KERNEL);\n\tif (!ddata)\n\t\treturn -ENOMEM;\n\n\tddata->regmap = devm_regmap_init(&spi->dev, &sprd_pmic_regmap,\n\t\t\t\t\t &spi->dev, &sprd_pmic_config);\n\tif (IS_ERR(ddata->regmap)) {\n\t\tret = PTR_ERR(ddata->regmap);\n\t\tdev_err(&spi->dev, \"Failed to allocate register map %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tspi_set_drvdata(spi, ddata);\n\tddata->dev = &spi->dev;\n\tddata->irq = spi->irq;\n\tddata->pdata = pdata;\n\n\tddata->irq_chip.name = dev_name(&spi->dev);\n\tddata->irq_chip.status_base =\n\t\tpdata->irq_base + SPRD_PMIC_INT_MASK_STATUS;\n\tddata->irq_chip.unmask_base = pdata->irq_base + SPRD_PMIC_INT_EN;\n\tddata->irq_chip.ack_base = 0;\n\tddata->irq_chip.num_regs = 1;\n\tddata->irq_chip.num_irqs = pdata->num_irqs;\n\n\tddata->irqs = devm_kcalloc(&spi->dev,\n\t\t\t\t   pdata->num_irqs, sizeof(struct regmap_irq),\n\t\t\t\t   GFP_KERNEL);\n\tif (!ddata->irqs)\n\t\treturn -ENOMEM;\n\n\tddata->irq_chip.irqs = ddata->irqs;\n\tfor (i = 0; i < pdata->num_irqs; i++)\n\t\tddata->irqs[i].mask = BIT(i);\n\n\tret = devm_regmap_add_irq_chip(&spi->dev, ddata->regmap, ddata->irq,\n\t\t\t\t       IRQF_ONESHOT, 0,\n\t\t\t\t       &ddata->irq_chip, &ddata->irq_data);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"Failed to add PMIC irq chip %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = devm_of_platform_populate(&spi->dev);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"Failed to populate sub-devices %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdevice_init_wakeup(&spi->dev, true);\n\treturn 0;\n}\n\nstatic int sprd_pmic_suspend(struct device *dev)\n{\n\tstruct sprd_pmic *ddata = dev_get_drvdata(dev);\n\n\tif (device_may_wakeup(dev))\n\t\tenable_irq_wake(ddata->irq);\n\n\treturn 0;\n}\n\nstatic int sprd_pmic_resume(struct device *dev)\n{\n\tstruct sprd_pmic *ddata = dev_get_drvdata(dev);\n\n\tif (device_may_wakeup(dev))\n\t\tdisable_irq_wake(ddata->irq);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(sprd_pmic_pm_ops,\n\t\t\t\tsprd_pmic_suspend, sprd_pmic_resume);\n\nstatic const struct of_device_id sprd_pmic_match[] = {\n\t{ .compatible = \"sprd,sc2730\", .data = &sc2730_data },\n\t{ .compatible = \"sprd,sc2731\", .data = &sc2731_data },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, sprd_pmic_match);\n\nstatic const struct spi_device_id sprd_pmic_spi_ids[] = {\n\t{ .name = \"sc2730\", .driver_data = (unsigned long)&sc2730_data },\n\t{ .name = \"sc2731\", .driver_data = (unsigned long)&sc2731_data },\n\t{},\n};\nMODULE_DEVICE_TABLE(spi, sprd_pmic_spi_ids);\n\nstatic struct spi_driver sprd_pmic_driver = {\n\t.driver = {\n\t\t.name = \"sc27xx-pmic\",\n\t\t.of_match_table = sprd_pmic_match,\n\t\t.pm = pm_sleep_ptr(&sprd_pmic_pm_ops),\n\t},\n\t.probe = sprd_pmic_probe,\n\t.id_table = sprd_pmic_spi_ids,\n};\n\nstatic int __init sprd_pmic_init(void)\n{\n\treturn spi_register_driver(&sprd_pmic_driver);\n}\nsubsys_initcall(sprd_pmic_init);\n\nstatic void __exit sprd_pmic_exit(void)\n{\n\tspi_unregister_driver(&sprd_pmic_driver);\n}\nmodule_exit(sprd_pmic_exit);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Spreadtrum SC27xx PMICs driver\");\nMODULE_AUTHOR(\"Baolin Wang <baolin.wang@spreadtrum.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}