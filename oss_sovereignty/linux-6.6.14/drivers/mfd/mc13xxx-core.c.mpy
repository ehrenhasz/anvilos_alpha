{
  "module_name": "mc13xxx-core.c",
  "hash_id": "b996e10a590b07c7e6c286d8ae140062e12b942d13fecf70fad4a56a8e9e5231",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/mc13xxx-core.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/platform_device.h>\n#include <linux/mfd/core.h>\n\n#include \"mc13xxx.h\"\n\n#define MC13XXX_IRQSTAT0\t0\n#define MC13XXX_IRQMASK0\t1\n#define MC13XXX_IRQSTAT1\t3\n#define MC13XXX_IRQMASK1\t4\n\n#define MC13XXX_REVISION\t7\n#define MC13XXX_REVISION_REVMETAL\t(0x07 <<  0)\n#define MC13XXX_REVISION_REVFULL\t(0x03 <<  3)\n#define MC13XXX_REVISION_ICID\t\t(0x07 <<  6)\n#define MC13XXX_REVISION_FIN\t\t(0x03 <<  9)\n#define MC13XXX_REVISION_FAB\t\t(0x03 << 11)\n#define MC13XXX_REVISION_ICIDCODE\t(0x3f << 13)\n\n#define MC34708_REVISION_REVMETAL\t(0x07 <<  0)\n#define MC34708_REVISION_REVFULL\t(0x07 <<  3)\n#define MC34708_REVISION_FIN\t\t(0x07 <<  6)\n#define MC34708_REVISION_FAB\t\t(0x07 <<  9)\n\n#define MC13XXX_PWRCTRL\t\t15\n#define MC13XXX_PWRCTRL_WDIRESET\t(1 << 12)\n\n#define MC13XXX_ADC1\t\t44\n#define MC13XXX_ADC1_ADEN\t\t(1 << 0)\n#define MC13XXX_ADC1_RAND\t\t(1 << 1)\n#define MC13XXX_ADC1_ADSEL\t\t(1 << 3)\n#define MC13XXX_ADC1_ASC\t\t(1 << 20)\n#define MC13XXX_ADC1_ADTRIGIGN\t\t(1 << 21)\n\n#define MC13XXX_ADC2\t\t45\n\nvoid mc13xxx_lock(struct mc13xxx *mc13xxx)\n{\n\tif (!mutex_trylock(&mc13xxx->lock)) {\n\t\tdev_dbg(mc13xxx->dev, \"wait for %s from %ps\\n\",\n\t\t\t\t__func__, __builtin_return_address(0));\n\n\t\tmutex_lock(&mc13xxx->lock);\n\t}\n\tdev_dbg(mc13xxx->dev, \"%s from %ps\\n\",\n\t\t\t__func__, __builtin_return_address(0));\n}\nEXPORT_SYMBOL(mc13xxx_lock);\n\nvoid mc13xxx_unlock(struct mc13xxx *mc13xxx)\n{\n\tdev_dbg(mc13xxx->dev, \"%s from %ps\\n\",\n\t\t\t__func__, __builtin_return_address(0));\n\tmutex_unlock(&mc13xxx->lock);\n}\nEXPORT_SYMBOL(mc13xxx_unlock);\n\nint mc13xxx_reg_read(struct mc13xxx *mc13xxx, unsigned int offset, u32 *val)\n{\n\tint ret;\n\n\tret = regmap_read(mc13xxx->regmap, offset, val);\n\tdev_vdbg(mc13xxx->dev, \"[0x%02x] -> 0x%06x\\n\", offset, *val);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(mc13xxx_reg_read);\n\nint mc13xxx_reg_write(struct mc13xxx *mc13xxx, unsigned int offset, u32 val)\n{\n\tdev_vdbg(mc13xxx->dev, \"[0x%02x] <- 0x%06x\\n\", offset, val);\n\n\tif (val >= BIT(24))\n\t\treturn -EINVAL;\n\n\treturn regmap_write(mc13xxx->regmap, offset, val);\n}\nEXPORT_SYMBOL(mc13xxx_reg_write);\n\nint mc13xxx_reg_rmw(struct mc13xxx *mc13xxx, unsigned int offset,\n\t\tu32 mask, u32 val)\n{\n\tBUG_ON(val & ~mask);\n\tdev_vdbg(mc13xxx->dev, \"[0x%02x] <- 0x%06x (mask: 0x%06x)\\n\",\n\t\t\toffset, val, mask);\n\n\treturn regmap_update_bits(mc13xxx->regmap, offset, mask, val);\n}\nEXPORT_SYMBOL(mc13xxx_reg_rmw);\n\nint mc13xxx_irq_mask(struct mc13xxx *mc13xxx, int irq)\n{\n\tint virq = regmap_irq_get_virq(mc13xxx->irq_data, irq);\n\n\tdisable_irq_nosync(virq);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(mc13xxx_irq_mask);\n\nint mc13xxx_irq_unmask(struct mc13xxx *mc13xxx, int irq)\n{\n\tint virq = regmap_irq_get_virq(mc13xxx->irq_data, irq);\n\n\tenable_irq(virq);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(mc13xxx_irq_unmask);\n\nint mc13xxx_irq_status(struct mc13xxx *mc13xxx, int irq,\n\t\tint *enabled, int *pending)\n{\n\tint ret;\n\tunsigned int offmask = irq < 24 ? MC13XXX_IRQMASK0 : MC13XXX_IRQMASK1;\n\tunsigned int offstat = irq < 24 ? MC13XXX_IRQSTAT0 : MC13XXX_IRQSTAT1;\n\tu32 irqbit = 1 << (irq < 24 ? irq : irq - 24);\n\n\tif (irq < 0 || irq >= ARRAY_SIZE(mc13xxx->irqs))\n\t\treturn -EINVAL;\n\n\tif (enabled) {\n\t\tu32 mask;\n\n\t\tret = mc13xxx_reg_read(mc13xxx, offmask, &mask);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*enabled = mask & irqbit;\n\t}\n\n\tif (pending) {\n\t\tu32 stat;\n\n\t\tret = mc13xxx_reg_read(mc13xxx, offstat, &stat);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*pending = stat & irqbit;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(mc13xxx_irq_status);\n\nint mc13xxx_irq_request(struct mc13xxx *mc13xxx, int irq,\n\t\tirq_handler_t handler, const char *name, void *dev)\n{\n\tint virq = regmap_irq_get_virq(mc13xxx->irq_data, irq);\n\n\treturn devm_request_threaded_irq(mc13xxx->dev, virq, NULL, handler,\n\t\t\t\t\t IRQF_ONESHOT, name, dev);\n}\nEXPORT_SYMBOL(mc13xxx_irq_request);\n\nint mc13xxx_irq_free(struct mc13xxx *mc13xxx, int irq, void *dev)\n{\n\tint virq = regmap_irq_get_virq(mc13xxx->irq_data, irq);\n\n\tdevm_free_irq(mc13xxx->dev, virq, dev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(mc13xxx_irq_free);\n\n#define maskval(reg, mask)\t(((reg) & (mask)) >> __ffs(mask))\nstatic void mc13xxx_print_revision(struct mc13xxx *mc13xxx, u32 revision)\n{\n\tdev_info(mc13xxx->dev, \"%s: rev: %d.%d, \"\n\t\t\t\"fin: %d, fab: %d, icid: %d/%d\\n\",\n\t\t\tmc13xxx->variant->name,\n\t\t\tmaskval(revision, MC13XXX_REVISION_REVFULL),\n\t\t\tmaskval(revision, MC13XXX_REVISION_REVMETAL),\n\t\t\tmaskval(revision, MC13XXX_REVISION_FIN),\n\t\t\tmaskval(revision, MC13XXX_REVISION_FAB),\n\t\t\tmaskval(revision, MC13XXX_REVISION_ICID),\n\t\t\tmaskval(revision, MC13XXX_REVISION_ICIDCODE));\n}\n\nstatic void mc34708_print_revision(struct mc13xxx *mc13xxx, u32 revision)\n{\n\tdev_info(mc13xxx->dev, \"%s: rev %d.%d, fin: %d, fab: %d\\n\",\n\t\t\tmc13xxx->variant->name,\n\t\t\tmaskval(revision, MC34708_REVISION_REVFULL),\n\t\t\tmaskval(revision, MC34708_REVISION_REVMETAL),\n\t\t\tmaskval(revision, MC34708_REVISION_FIN),\n\t\t\tmaskval(revision, MC34708_REVISION_FAB));\n}\n\n \nstruct mc13xxx_variant mc13xxx_variant_mc13783 = {\n\t.name = \"mc13783\",\n\t.print_revision = mc13xxx_print_revision,\n};\nEXPORT_SYMBOL_GPL(mc13xxx_variant_mc13783);\n\nstruct mc13xxx_variant mc13xxx_variant_mc13892 = {\n\t.name = \"mc13892\",\n\t.print_revision = mc13xxx_print_revision,\n};\nEXPORT_SYMBOL_GPL(mc13xxx_variant_mc13892);\n\nstruct mc13xxx_variant mc13xxx_variant_mc34708 = {\n\t.name = \"mc34708\",\n\t.print_revision = mc34708_print_revision,\n};\nEXPORT_SYMBOL_GPL(mc13xxx_variant_mc34708);\n\nstatic const char *mc13xxx_get_chipname(struct mc13xxx *mc13xxx)\n{\n\treturn mc13xxx->variant->name;\n}\n\nint mc13xxx_get_flags(struct mc13xxx *mc13xxx)\n{\n\treturn mc13xxx->flags;\n}\nEXPORT_SYMBOL(mc13xxx_get_flags);\n\n#define MC13XXX_ADC1_CHAN0_SHIFT\t5\n#define MC13XXX_ADC1_CHAN1_SHIFT\t8\n#define MC13783_ADC1_ATO_SHIFT\t\t11\n#define MC13783_ADC1_ATOX\t\t(1 << 19)\n\nstruct mc13xxx_adcdone_data {\n\tstruct mc13xxx *mc13xxx;\n\tstruct completion done;\n};\n\nstatic irqreturn_t mc13xxx_handler_adcdone(int irq, void *data)\n{\n\tstruct mc13xxx_adcdone_data *adcdone_data = data;\n\n\tcomplete_all(&adcdone_data->done);\n\n\treturn IRQ_HANDLED;\n}\n\n#define MC13XXX_ADC_WORKING (1 << 0)\n\nint mc13xxx_adc_do_conversion(struct mc13xxx *mc13xxx, unsigned int mode,\n\t\tunsigned int channel, u8 ato, bool atox,\n\t\tunsigned int *sample)\n{\n\tu32 adc0, adc1, old_adc0;\n\tint i, ret;\n\tstruct mc13xxx_adcdone_data adcdone_data = {\n\t\t.mc13xxx = mc13xxx,\n\t};\n\tinit_completion(&adcdone_data.done);\n\n\tdev_dbg(mc13xxx->dev, \"%s\\n\", __func__);\n\n\tmc13xxx_lock(mc13xxx);\n\n\tif (mc13xxx->adcflags & MC13XXX_ADC_WORKING) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tmc13xxx->adcflags |= MC13XXX_ADC_WORKING;\n\n\tret = mc13xxx_reg_read(mc13xxx, MC13XXX_ADC0, &old_adc0);\n\tif (ret)\n\t\tgoto out;\n\n\tadc0 = MC13XXX_ADC0_ADINC1 | MC13XXX_ADC0_ADINC2 |\n\t       MC13XXX_ADC0_CHRGRAWDIV;\n\tadc1 = MC13XXX_ADC1_ADEN | MC13XXX_ADC1_ADTRIGIGN | MC13XXX_ADC1_ASC;\n\n\t \n\tif (channel > 7 && channel < 16) {\n\t\tadc1 |= MC13XXX_ADC1_ADSEL;\n\t} else if (channel == 16) {\n\t\tadc0 |= MC13XXX_ADC0_ADIN7SEL_UID;\n\t\tchannel = 7;\n\t} else if (channel == 17) {\n\t\tadc0 |= MC13XXX_ADC0_ADIN7SEL_DIE;\n\t\tchannel = 7;\n\t}\n\n\tswitch (mode) {\n\tcase MC13XXX_ADC_MODE_TS:\n\t\tadc0 |= MC13XXX_ADC0_ADREFEN | MC13XXX_ADC0_TSMOD0 |\n\t\t\tMC13XXX_ADC0_TSMOD1;\n\t\tadc1 |= 4 << MC13XXX_ADC1_CHAN1_SHIFT;\n\t\tbreak;\n\n\tcase MC13XXX_ADC_MODE_SINGLE_CHAN:\n\t\tadc0 |= old_adc0 & MC13XXX_ADC0_CONFIG_MASK;\n\t\tadc1 |= (channel & 0x7) << MC13XXX_ADC1_CHAN0_SHIFT;\n\t\tadc1 |= MC13XXX_ADC1_RAND;\n\t\tbreak;\n\n\tcase MC13XXX_ADC_MODE_MULT_CHAN:\n\t\tadc0 |= old_adc0 & MC13XXX_ADC0_CONFIG_MASK;\n\t\tadc1 |= 4 << MC13XXX_ADC1_CHAN1_SHIFT;\n\t\tbreak;\n\n\tdefault:\n\t\tmc13xxx_unlock(mc13xxx);\n\t\treturn -EINVAL;\n\t}\n\n\tadc1 |= ato << MC13783_ADC1_ATO_SHIFT;\n\tif (atox)\n\t\tadc1 |= MC13783_ADC1_ATOX;\n\n\tdev_dbg(mc13xxx->dev, \"%s: request irq\\n\", __func__);\n\tret = mc13xxx_irq_request(mc13xxx, MC13XXX_IRQ_ADCDONE,\n\t\t\tmc13xxx_handler_adcdone, __func__, &adcdone_data);\n\tif (ret)\n\t\tgoto out;\n\n\tmc13xxx_reg_write(mc13xxx, MC13XXX_ADC0, adc0);\n\tmc13xxx_reg_write(mc13xxx, MC13XXX_ADC1, adc1);\n\n\tmc13xxx_unlock(mc13xxx);\n\n\tret = wait_for_completion_interruptible_timeout(&adcdone_data.done, HZ);\n\n\tif (!ret)\n\t\tret = -ETIMEDOUT;\n\n\tmc13xxx_lock(mc13xxx);\n\n\tmc13xxx_irq_free(mc13xxx, MC13XXX_IRQ_ADCDONE, &adcdone_data);\n\n\tif (ret > 0)\n\t\tfor (i = 0; i < 4; ++i) {\n\t\t\tret = mc13xxx_reg_read(mc13xxx,\n\t\t\t\t\tMC13XXX_ADC2, &sample[i]);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\n\tif (mode == MC13XXX_ADC_MODE_TS)\n\t\t \n\t\tmc13xxx_reg_write(mc13xxx, MC13XXX_ADC0, old_adc0);\n\n\tmc13xxx->adcflags &= ~MC13XXX_ADC_WORKING;\nout:\n\tmc13xxx_unlock(mc13xxx);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(mc13xxx_adc_do_conversion);\n\nstatic int mc13xxx_add_subdevice_pdata(struct mc13xxx *mc13xxx,\n\t\tconst char *format, void *pdata, size_t pdata_size)\n{\n\tchar buf[30];\n\tconst char *name = mc13xxx_get_chipname(mc13xxx);\n\n\tstruct mfd_cell cell = {\n\t\t.platform_data = pdata,\n\t\t.pdata_size = pdata_size,\n\t};\n\n\t \n\tif (snprintf(buf, sizeof(buf), format, name) > sizeof(buf))\n\t\treturn -E2BIG;\n\n\tcell.name = kmemdup(buf, strlen(buf) + 1, GFP_KERNEL);\n\tif (!cell.name)\n\t\treturn -ENOMEM;\n\n\treturn mfd_add_devices(mc13xxx->dev, -1, &cell, 1, NULL, 0,\n\t\t\t       regmap_irq_get_domain(mc13xxx->irq_data));\n}\n\nstatic int mc13xxx_add_subdevice(struct mc13xxx *mc13xxx, const char *format)\n{\n\treturn mc13xxx_add_subdevice_pdata(mc13xxx, format, NULL, 0);\n}\n\n#ifdef CONFIG_OF\nstatic int mc13xxx_probe_flags_dt(struct mc13xxx *mc13xxx)\n{\n\tstruct device_node *np = mc13xxx->dev->of_node;\n\n\tif (!np)\n\t\treturn -ENODEV;\n\n\tif (of_property_read_bool(np, \"fsl,mc13xxx-uses-adc\"))\n\t\tmc13xxx->flags |= MC13XXX_USE_ADC;\n\n\tif (of_property_read_bool(np, \"fsl,mc13xxx-uses-codec\"))\n\t\tmc13xxx->flags |= MC13XXX_USE_CODEC;\n\n\tif (of_property_read_bool(np, \"fsl,mc13xxx-uses-rtc\"))\n\t\tmc13xxx->flags |= MC13XXX_USE_RTC;\n\n\tif (of_property_read_bool(np, \"fsl,mc13xxx-uses-touch\"))\n\t\tmc13xxx->flags |= MC13XXX_USE_TOUCHSCREEN;\n\n\treturn 0;\n}\n#else\nstatic inline int mc13xxx_probe_flags_dt(struct mc13xxx *mc13xxx)\n{\n\treturn -ENODEV;\n}\n#endif\n\nint mc13xxx_common_init(struct device *dev)\n{\n\tstruct mc13xxx_platform_data *pdata = dev_get_platdata(dev);\n\tstruct mc13xxx *mc13xxx = dev_get_drvdata(dev);\n\tu32 revision;\n\tint i, ret;\n\n\tmc13xxx->dev = dev;\n\n\tret = mc13xxx_reg_read(mc13xxx, MC13XXX_REVISION, &revision);\n\tif (ret)\n\t\treturn ret;\n\n\tmc13xxx->variant->print_revision(mc13xxx, revision);\n\n\tret = mc13xxx_reg_rmw(mc13xxx, MC13XXX_PWRCTRL,\n\t\t\tMC13XXX_PWRCTRL_WDIRESET, MC13XXX_PWRCTRL_WDIRESET);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(mc13xxx->irqs); i++) {\n\t\tmc13xxx->irqs[i].reg_offset = i / MC13XXX_IRQ_PER_REG;\n\t\tmc13xxx->irqs[i].mask = BIT(i % MC13XXX_IRQ_PER_REG);\n\t}\n\n\tmc13xxx->irq_chip.name = dev_name(dev);\n\tmc13xxx->irq_chip.status_base = MC13XXX_IRQSTAT0;\n\tmc13xxx->irq_chip.mask_base = MC13XXX_IRQMASK0;\n\tmc13xxx->irq_chip.ack_base = MC13XXX_IRQSTAT0;\n\tmc13xxx->irq_chip.irq_reg_stride = MC13XXX_IRQSTAT1 - MC13XXX_IRQSTAT0;\n\tmc13xxx->irq_chip.init_ack_masked = true;\n\tmc13xxx->irq_chip.use_ack = true;\n\tmc13xxx->irq_chip.num_regs = MC13XXX_IRQ_REG_CNT;\n\tmc13xxx->irq_chip.irqs = mc13xxx->irqs;\n\tmc13xxx->irq_chip.num_irqs = ARRAY_SIZE(mc13xxx->irqs);\n\n\tret = regmap_add_irq_chip(mc13xxx->regmap, mc13xxx->irq, IRQF_ONESHOT,\n\t\t\t\t  0, &mc13xxx->irq_chip, &mc13xxx->irq_data);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_init(&mc13xxx->lock);\n\n\tif (mc13xxx_probe_flags_dt(mc13xxx) < 0 && pdata)\n\t\tmc13xxx->flags = pdata->flags;\n\n\tif (pdata) {\n\t\tmc13xxx_add_subdevice_pdata(mc13xxx, \"%s-regulator\",\n\t\t\t&pdata->regulators, sizeof(pdata->regulators));\n\t\tmc13xxx_add_subdevice_pdata(mc13xxx, \"%s-led\",\n\t\t\t\tpdata->leds, sizeof(*pdata->leds));\n\t\tmc13xxx_add_subdevice_pdata(mc13xxx, \"%s-pwrbutton\",\n\t\t\t\tpdata->buttons, sizeof(*pdata->buttons));\n\t\tif (mc13xxx->flags & MC13XXX_USE_CODEC)\n\t\t\tmc13xxx_add_subdevice_pdata(mc13xxx, \"%s-codec\",\n\t\t\t\tpdata->codec, sizeof(*pdata->codec));\n\t\tif (mc13xxx->flags & MC13XXX_USE_TOUCHSCREEN)\n\t\t\tmc13xxx_add_subdevice_pdata(mc13xxx, \"%s-ts\",\n\t\t\t\t&pdata->touch, sizeof(pdata->touch));\n\t} else {\n\t\tmc13xxx_add_subdevice(mc13xxx, \"%s-regulator\");\n\t\tmc13xxx_add_subdevice(mc13xxx, \"%s-led\");\n\t\tmc13xxx_add_subdevice(mc13xxx, \"%s-pwrbutton\");\n\t\tif (mc13xxx->flags & MC13XXX_USE_CODEC)\n\t\t\tmc13xxx_add_subdevice(mc13xxx, \"%s-codec\");\n\t\tif (mc13xxx->flags & MC13XXX_USE_TOUCHSCREEN)\n\t\t\tmc13xxx_add_subdevice(mc13xxx, \"%s-ts\");\n\t}\n\n\tif (mc13xxx->flags & MC13XXX_USE_ADC)\n\t\tmc13xxx_add_subdevice(mc13xxx, \"%s-adc\");\n\n\tif (mc13xxx->flags & MC13XXX_USE_RTC)\n\t\tmc13xxx_add_subdevice(mc13xxx, \"%s-rtc\");\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mc13xxx_common_init);\n\nvoid mc13xxx_common_exit(struct device *dev)\n{\n\tstruct mc13xxx *mc13xxx = dev_get_drvdata(dev);\n\n\tmfd_remove_devices(dev);\n\tregmap_del_irq_chip(mc13xxx->irq, mc13xxx->irq_data);\n\tmutex_destroy(&mc13xxx->lock);\n}\nEXPORT_SYMBOL_GPL(mc13xxx_common_exit);\n\nMODULE_DESCRIPTION(\"Core driver for Freescale MC13XXX PMIC\");\nMODULE_AUTHOR(\"Uwe Kleine-Koenig <u.kleine-koenig@pengutronix.de>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}