{
  "module_name": "tps6594-spi.c",
  "hash_id": "a840475838fe1033252356c4aad8f13ad074183f2ad1128c4b17de0d1a84fc15",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/tps6594-spi.c",
  "human_readable_source": "\n \n\n#include <linux/crc8.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/of_device.h>\n#include <linux/regmap.h>\n#include <linux/spi/spi.h>\n\n#include <linux/mfd/tps6594.h>\n\n#define TPS6594_SPI_PAGE_SHIFT\t5\n#define TPS6594_SPI_READ_BIT\tBIT(4)\n\nstatic bool enable_crc;\nmodule_param(enable_crc, bool, 0444);\nMODULE_PARM_DESC(enable_crc, \"Enable CRC feature for SPI interface\");\n\nDECLARE_CRC8_TABLE(tps6594_spi_crc_table);\n\nstatic int tps6594_spi_reg_read(void *context, unsigned int reg, unsigned int *val)\n{\n\tstruct spi_device *spi = context;\n\tstruct tps6594 *tps = spi_get_drvdata(spi);\n\tu8 buf[4] = { 0 };\n\tsize_t count_rx = 1;\n\tint ret;\n\n\tbuf[0] = reg;\n\tbuf[1] = TPS6594_REG_TO_PAGE(reg) << TPS6594_SPI_PAGE_SHIFT | TPS6594_SPI_READ_BIT;\n\n\tif (tps->use_crc)\n\t\tcount_rx++;\n\n\tret = spi_write_then_read(spi, buf, 2, buf + 2, count_rx);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (tps->use_crc && buf[3] != crc8(tps6594_spi_crc_table, buf, 3, CRC8_INIT_VALUE))\n\t\treturn -EIO;\n\n\t*val = buf[2];\n\n\treturn 0;\n}\n\nstatic int tps6594_spi_reg_write(void *context, unsigned int reg, unsigned int val)\n{\n\tstruct spi_device *spi = context;\n\tstruct tps6594 *tps = spi_get_drvdata(spi);\n\tu8 buf[4] = { 0 };\n\tsize_t count = 3;\n\n\tbuf[0] = reg;\n\tbuf[1] = TPS6594_REG_TO_PAGE(reg) << TPS6594_SPI_PAGE_SHIFT;\n\tbuf[2] = val;\n\n\tif (tps->use_crc)\n\t\tbuf[3] = crc8(tps6594_spi_crc_table, buf, count++, CRC8_INIT_VALUE);\n\n\treturn spi_write(spi, buf, count);\n}\n\nstatic const struct regmap_config tps6594_spi_regmap_config = {\n\t.reg_bits = 16,\n\t.val_bits = 8,\n\t.max_register = TPS6594_REG_DWD_FAIL_CNT_REG,\n\t.volatile_reg = tps6594_is_volatile_reg,\n\t.reg_read = tps6594_spi_reg_read,\n\t.reg_write = tps6594_spi_reg_write,\n\t.use_single_read = true,\n\t.use_single_write = true,\n};\n\nstatic const struct of_device_id tps6594_spi_of_match_table[] = {\n\t{ .compatible = \"ti,tps6594-q1\", .data = (void *)TPS6594, },\n\t{ .compatible = \"ti,tps6593-q1\", .data = (void *)TPS6593, },\n\t{ .compatible = \"ti,lp8764-q1\",  .data = (void *)LP8764,  },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, tps6594_spi_of_match_table);\n\nstatic int tps6594_spi_probe(struct spi_device *spi)\n{\n\tstruct device *dev = &spi->dev;\n\tstruct tps6594 *tps;\n\tconst struct of_device_id *match;\n\n\ttps = devm_kzalloc(dev, sizeof(*tps), GFP_KERNEL);\n\tif (!tps)\n\t\treturn -ENOMEM;\n\n\tspi_set_drvdata(spi, tps);\n\n\ttps->dev = dev;\n\ttps->reg = spi->chip_select;\n\ttps->irq = spi->irq;\n\n\ttps->regmap = devm_regmap_init(dev, NULL, spi, &tps6594_spi_regmap_config);\n\tif (IS_ERR(tps->regmap))\n\t\treturn dev_err_probe(dev, PTR_ERR(tps->regmap), \"Failed to init regmap\\n\");\n\n\tmatch = of_match_device(tps6594_spi_of_match_table, dev);\n\tif (!match)\n\t\treturn dev_err_probe(dev, -EINVAL, \"Failed to find matching chip ID\\n\");\n\ttps->chip_id = (unsigned long)match->data;\n\n\tcrc8_populate_msb(tps6594_spi_crc_table, TPS6594_CRC8_POLYNOMIAL);\n\n\treturn tps6594_device_init(tps, enable_crc);\n}\n\nstatic struct spi_driver tps6594_spi_driver = {\n\t.driver\t= {\n\t\t.name = \"tps6594\",\n\t\t.of_match_table = tps6594_spi_of_match_table,\n\t},\n\t.probe = tps6594_spi_probe,\n};\nmodule_spi_driver(tps6594_spi_driver);\n\nMODULE_AUTHOR(\"Julien Panis <jpanis@baylibre.com>\");\nMODULE_DESCRIPTION(\"TPS6594 SPI Interface Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}