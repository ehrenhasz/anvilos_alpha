{
  "module_name": "tc3589x.c",
  "hash_id": "7d487045c01eeb9725291458227cfaa51bfb8271ccae1b441bbb2d3df2177cc6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/tc3589x.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/tc3589x.h>\n#include <linux/err.h>\n\n \nenum tc3589x_version {\n\tTC3589X_TC35890,\n\tTC3589X_TC35892,\n\tTC3589X_TC35893,\n\tTC3589X_TC35894,\n\tTC3589X_TC35895,\n\tTC3589X_TC35896,\n\tTC3589X_UNKNOWN,\n};\n\n#define TC3589x_CLKMODE_MODCTL_SLEEP\t\t0x0\n#define TC3589x_CLKMODE_MODCTL_OPERATION\t(1 << 0)\n\n \nint tc3589x_reg_read(struct tc3589x *tc3589x, u8 reg)\n{\n\tint ret;\n\n\tret = i2c_smbus_read_byte_data(tc3589x->i2c, reg);\n\tif (ret < 0)\n\t\tdev_err(tc3589x->dev, \"failed to read reg %#x: %d\\n\",\n\t\t\treg, ret);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(tc3589x_reg_read);\n\n \nint tc3589x_reg_write(struct tc3589x *tc3589x, u8 reg, u8 data)\n{\n\tint ret;\n\n\tret = i2c_smbus_write_byte_data(tc3589x->i2c, reg, data);\n\tif (ret < 0)\n\t\tdev_err(tc3589x->dev, \"failed to write reg %#x: %d\\n\",\n\t\t\treg, ret);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(tc3589x_reg_write);\n\n \nint tc3589x_block_read(struct tc3589x *tc3589x, u8 reg, u8 length, u8 *values)\n{\n\tint ret;\n\n\tret = i2c_smbus_read_i2c_block_data(tc3589x->i2c, reg, length, values);\n\tif (ret < 0)\n\t\tdev_err(tc3589x->dev, \"failed to read regs %#x: %d\\n\",\n\t\t\treg, ret);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(tc3589x_block_read);\n\n \nint tc3589x_block_write(struct tc3589x *tc3589x, u8 reg, u8 length,\n\t\t\tconst u8 *values)\n{\n\tint ret;\n\n\tret = i2c_smbus_write_i2c_block_data(tc3589x->i2c, reg, length,\n\t\t\t\t\t     values);\n\tif (ret < 0)\n\t\tdev_err(tc3589x->dev, \"failed to write regs %#x: %d\\n\",\n\t\t\treg, ret);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(tc3589x_block_write);\n\n \nint tc3589x_set_bits(struct tc3589x *tc3589x, u8 reg, u8 mask, u8 val)\n{\n\tint ret;\n\n\tmutex_lock(&tc3589x->lock);\n\n\tret = tc3589x_reg_read(tc3589x, reg);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret &= ~mask;\n\tret |= val;\n\n\tret = tc3589x_reg_write(tc3589x, reg, ret);\n\nout:\n\tmutex_unlock(&tc3589x->lock);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(tc3589x_set_bits);\n\nstatic const struct resource gpio_resources[] = {\n\t{\n\t\t.start\t= TC3589x_INT_GPIIRQ,\n\t\t.end\t= TC3589x_INT_GPIIRQ,\n\t\t.flags\t= IORESOURCE_IRQ,\n\t},\n};\n\nstatic const struct resource keypad_resources[] = {\n\t{\n\t\t.start  = TC3589x_INT_KBDIRQ,\n\t\t.end    = TC3589x_INT_KBDIRQ,\n\t\t.flags  = IORESOURCE_IRQ,\n\t},\n};\n\nstatic const struct mfd_cell tc3589x_dev_gpio[] = {\n\t{\n\t\t.name\t\t= \"tc3589x-gpio\",\n\t\t.num_resources\t= ARRAY_SIZE(gpio_resources),\n\t\t.resources\t= &gpio_resources[0],\n\t\t.of_compatible\t= \"toshiba,tc3589x-gpio\",\n\t},\n};\n\nstatic const struct mfd_cell tc3589x_dev_keypad[] = {\n\t{\n\t\t.name           = \"tc3589x-keypad\",\n\t\t.num_resources  = ARRAY_SIZE(keypad_resources),\n\t\t.resources      = &keypad_resources[0],\n\t\t.of_compatible\t= \"toshiba,tc3589x-keypad\",\n\t},\n};\n\nstatic irqreturn_t tc3589x_irq(int irq, void *data)\n{\n\tstruct tc3589x *tc3589x = data;\n\tint status;\n\nagain:\n\tstatus = tc3589x_reg_read(tc3589x, TC3589x_IRQST);\n\tif (status < 0)\n\t\treturn IRQ_NONE;\n\n\twhile (status) {\n\t\tint bit = __ffs(status);\n\t\tint virq = irq_find_mapping(tc3589x->domain, bit);\n\n\t\thandle_nested_irq(virq);\n\t\tstatus &= ~(1 << bit);\n\t}\n\n\t \n\tstatus = tc3589x_reg_read(tc3589x, TC3589x_IRQST);\n\tif (status)\n\t\tgoto again;\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int tc3589x_irq_map(struct irq_domain *d, unsigned int virq,\n\t\t\t\tirq_hw_number_t hwirq)\n{\n\tstruct tc3589x *tc3589x = d->host_data;\n\n\tirq_set_chip_data(virq, tc3589x);\n\tirq_set_chip_and_handler(virq, &dummy_irq_chip,\n\t\t\t\thandle_edge_irq);\n\tirq_set_nested_thread(virq, 1);\n\tirq_set_noprobe(virq);\n\n\treturn 0;\n}\n\nstatic void tc3589x_irq_unmap(struct irq_domain *d, unsigned int virq)\n{\n\tirq_set_chip_and_handler(virq, NULL, NULL);\n\tirq_set_chip_data(virq, NULL);\n}\n\nstatic const struct irq_domain_ops tc3589x_irq_ops = {\n\t.map    = tc3589x_irq_map,\n\t.unmap  = tc3589x_irq_unmap,\n\t.xlate  = irq_domain_xlate_onecell,\n};\n\nstatic int tc3589x_irq_init(struct tc3589x *tc3589x, struct device_node *np)\n{\n\ttc3589x->domain = irq_domain_add_simple(\n\t\tnp, TC3589x_NR_INTERNAL_IRQS, 0,\n\t\t&tc3589x_irq_ops, tc3589x);\n\n\tif (!tc3589x->domain) {\n\t\tdev_err(tc3589x->dev, \"Failed to create irqdomain\\n\");\n\t\treturn -ENOSYS;\n\t}\n\n\treturn 0;\n}\n\nstatic int tc3589x_chip_init(struct tc3589x *tc3589x)\n{\n\tint manf, ver, ret;\n\n\tmanf = tc3589x_reg_read(tc3589x, TC3589x_MANFCODE);\n\tif (manf < 0)\n\t\treturn manf;\n\n\tver = tc3589x_reg_read(tc3589x, TC3589x_VERSION);\n\tif (ver < 0)\n\t\treturn ver;\n\n\tif (manf != TC3589x_MANFCODE_MAGIC) {\n\t\tdev_err(tc3589x->dev, \"unknown manufacturer: %#x\\n\", manf);\n\t\treturn -EINVAL;\n\t}\n\n\tdev_info(tc3589x->dev, \"manufacturer: %#x, version: %#x\\n\", manf, ver);\n\n\t \n\tret = tc3589x_reg_write(tc3589x, TC3589x_RSTCTRL,\n\t\t\t\tTC3589x_RSTCTRL_TIMRST\n\t\t\t\t| TC3589x_RSTCTRL_ROTRST\n\t\t\t\t| TC3589x_RSTCTRL_KBDRST);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\treturn tc3589x_reg_write(tc3589x, TC3589x_RSTINTCLR, 0x1);\n}\n\nstatic int tc3589x_device_init(struct tc3589x *tc3589x)\n{\n\tint ret = 0;\n\tunsigned int blocks = tc3589x->pdata->block;\n\n\tif (blocks & TC3589x_BLOCK_GPIO) {\n\t\tret = mfd_add_devices(tc3589x->dev, -1, tc3589x_dev_gpio,\n\t\t\t\t      ARRAY_SIZE(tc3589x_dev_gpio), NULL,\n\t\t\t\t      0, tc3589x->domain);\n\t\tif (ret) {\n\t\t\tdev_err(tc3589x->dev, \"failed to add gpio child\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tdev_info(tc3589x->dev, \"added gpio block\\n\");\n\t}\n\n\tif (blocks & TC3589x_BLOCK_KEYPAD) {\n\t\tret = mfd_add_devices(tc3589x->dev, -1, tc3589x_dev_keypad,\n\t\t\t\t      ARRAY_SIZE(tc3589x_dev_keypad), NULL,\n\t\t\t\t      0, tc3589x->domain);\n\t\tif (ret) {\n\t\t\tdev_err(tc3589x->dev, \"failed to keypad child\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tdev_info(tc3589x->dev, \"added keypad block\\n\");\n\t}\n\n\treturn ret;\n}\n\nstatic const struct of_device_id tc3589x_match[] = {\n\t \n\t{ .compatible = \"tc3589x\", .data = (void *) TC3589X_UNKNOWN },\n\t{ .compatible = \"toshiba,tc35890\", .data = (void *) TC3589X_TC35890 },\n\t{ .compatible = \"toshiba,tc35892\", .data = (void *) TC3589X_TC35892 },\n\t{ .compatible = \"toshiba,tc35893\", .data = (void *) TC3589X_TC35893 },\n\t{ .compatible = \"toshiba,tc35894\", .data = (void *) TC3589X_TC35894 },\n\t{ .compatible = \"toshiba,tc35895\", .data = (void *) TC3589X_TC35895 },\n\t{ .compatible = \"toshiba,tc35896\", .data = (void *) TC3589X_TC35896 },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(of, tc3589x_match);\n\nstatic struct tc3589x_platform_data *\ntc3589x_of_probe(struct device *dev, enum tc3589x_version *version)\n{\n\tstruct device_node *np = dev->of_node;\n\tstruct tc3589x_platform_data *pdata;\n\tstruct device_node *child;\n\tconst struct of_device_id *of_id;\n\n\tpdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tof_id = of_match_device(tc3589x_match, dev);\n\tif (!of_id)\n\t\treturn ERR_PTR(-ENODEV);\n\t*version = (uintptr_t) of_id->data;\n\n\tfor_each_child_of_node(np, child) {\n\t\tif (of_device_is_compatible(child, \"toshiba,tc3589x-gpio\"))\n\t\t\tpdata->block |= TC3589x_BLOCK_GPIO;\n\t\tif (of_device_is_compatible(child, \"toshiba,tc3589x-keypad\"))\n\t\t\tpdata->block |= TC3589x_BLOCK_KEYPAD;\n\t}\n\n\treturn pdata;\n}\n\nstatic int tc3589x_probe(struct i2c_client *i2c)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(i2c);\n\tstruct device_node *np = i2c->dev.of_node;\n\tstruct tc3589x_platform_data *pdata = dev_get_platdata(&i2c->dev);\n\tstruct tc3589x *tc3589x;\n\tenum tc3589x_version version;\n\tint ret;\n\n\tif (!pdata) {\n\t\tpdata = tc3589x_of_probe(&i2c->dev, &version);\n\t\tif (IS_ERR(pdata)) {\n\t\t\tdev_err(&i2c->dev, \"No platform data or DT found\\n\");\n\t\t\treturn PTR_ERR(pdata);\n\t\t}\n\t} else {\n\t\t \n\t\tversion = id->driver_data;\n\t}\n\n\tif (!i2c_check_functionality(i2c->adapter, I2C_FUNC_SMBUS_BYTE_DATA\n\t\t\t\t     | I2C_FUNC_SMBUS_I2C_BLOCK))\n\t\treturn -EIO;\n\n\ttc3589x = devm_kzalloc(&i2c->dev, sizeof(struct tc3589x),\n\t\t\t\tGFP_KERNEL);\n\tif (!tc3589x)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&tc3589x->lock);\n\n\ttc3589x->dev = &i2c->dev;\n\ttc3589x->i2c = i2c;\n\ttc3589x->pdata = pdata;\n\n\tswitch (version) {\n\tcase TC3589X_TC35893:\n\tcase TC3589X_TC35895:\n\tcase TC3589X_TC35896:\n\t\ttc3589x->num_gpio = 20;\n\t\tbreak;\n\tcase TC3589X_TC35890:\n\tcase TC3589X_TC35892:\n\tcase TC3589X_TC35894:\n\tcase TC3589X_UNKNOWN:\n\tdefault:\n\t\ttc3589x->num_gpio = 24;\n\t\tbreak;\n\t}\n\n\ti2c_set_clientdata(i2c, tc3589x);\n\n\tret = tc3589x_chip_init(tc3589x);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tc3589x_irq_init(tc3589x, np);\n\tif (ret)\n\t\treturn ret;\n\n\tret = request_threaded_irq(tc3589x->i2c->irq, NULL, tc3589x_irq,\n\t\t\t\t   IRQF_TRIGGER_FALLING | IRQF_ONESHOT,\n\t\t\t\t   \"tc3589x\", tc3589x);\n\tif (ret) {\n\t\tdev_err(tc3589x->dev, \"failed to request IRQ: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = tc3589x_device_init(tc3589x);\n\tif (ret) {\n\t\tdev_err(tc3589x->dev, \"failed to add child devices\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void tc3589x_remove(struct i2c_client *client)\n{\n\tstruct tc3589x *tc3589x = i2c_get_clientdata(client);\n\n\tmfd_remove_devices(tc3589x->dev);\n}\n\nstatic int tc3589x_suspend(struct device *dev)\n{\n\tstruct tc3589x *tc3589x = dev_get_drvdata(dev);\n\tstruct i2c_client *client = tc3589x->i2c;\n\tint ret = 0;\n\n\t \n\tif (!device_may_wakeup(&client->dev))\n\t\tret = tc3589x_reg_write(tc3589x, TC3589x_CLKMODE,\n\t\t\t\tTC3589x_CLKMODE_MODCTL_SLEEP);\n\n\treturn ret;\n}\n\nstatic int tc3589x_resume(struct device *dev)\n{\n\tstruct tc3589x *tc3589x = dev_get_drvdata(dev);\n\tstruct i2c_client *client = tc3589x->i2c;\n\tint ret = 0;\n\n\t \n\tif (!device_may_wakeup(&client->dev))\n\t\tret = tc3589x_reg_write(tc3589x, TC3589x_CLKMODE,\n\t\t\t\tTC3589x_CLKMODE_MODCTL_OPERATION);\n\n\treturn ret;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(tc3589x_dev_pm_ops,\n\t\t\t\ttc3589x_suspend, tc3589x_resume);\n\nstatic const struct i2c_device_id tc3589x_id[] = {\n\t{ \"tc35890\", TC3589X_TC35890 },\n\t{ \"tc35892\", TC3589X_TC35892 },\n\t{ \"tc35893\", TC3589X_TC35893 },\n\t{ \"tc35894\", TC3589X_TC35894 },\n\t{ \"tc35895\", TC3589X_TC35895 },\n\t{ \"tc35896\", TC3589X_TC35896 },\n\t{ \"tc3589x\", TC3589X_UNKNOWN },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, tc3589x_id);\n\nstatic struct i2c_driver tc3589x_driver = {\n\t.driver = {\n\t\t.name\t= \"tc3589x\",\n\t\t.pm\t= pm_sleep_ptr(&tc3589x_dev_pm_ops),\n\t\t.of_match_table = tc3589x_match,\n\t},\n\t.probe\t\t= tc3589x_probe,\n\t.remove\t\t= tc3589x_remove,\n\t.id_table\t= tc3589x_id,\n};\n\nstatic int __init tc3589x_init(void)\n{\n\treturn i2c_add_driver(&tc3589x_driver);\n}\nsubsys_initcall(tc3589x_init);\n\nstatic void __exit tc3589x_exit(void)\n{\n\ti2c_del_driver(&tc3589x_driver);\n}\nmodule_exit(tc3589x_exit);\n\nMODULE_DESCRIPTION(\"TC3589x MFD core driver\");\nMODULE_AUTHOR(\"Hanumath Prasad, Rabin Vincent\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}