{
  "module_name": "acer-ec-a500.c",
  "hash_id": "00ffcb61d0fbba16c0a8d6f303a0318b5c3865f556c35654af50830c15aff4f0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/acer-ec-a500.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/mfd/core.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/reboot.h>\n#include <linux/regmap.h>\n\n#define A500_EC_I2C_ERR_TIMEOUT\t\t500\n#define A500_EC_POWER_CMD_TIMEOUT\t1000\n\n \n#define CMD_SHUTDOWN\t\t\t0x0\n#define CMD_WARM_REBOOT\t\t\t0x0\n#define CMD_COLD_REBOOT\t\t\t0x1\n\nenum {\n\tREG_CURRENT_NOW = 0x03,\n\tREG_SHUTDOWN = 0x52,\n\tREG_WARM_REBOOT = 0x54,\n\tREG_COLD_REBOOT = 0x55,\n};\n\nstatic struct i2c_client *a500_ec_client_pm_off;\n\nstatic int a500_ec_read(void *context, const void *reg_buf, size_t reg_size,\n\t\t\tvoid *val_buf, size_t val_sizel)\n{\n\tstruct i2c_client *client = context;\n\tunsigned int reg, retries = 5;\n\tu16 *ret_val = val_buf;\n\ts32 ret = 0;\n\n\treg = *(u8 *)reg_buf;\n\n\twhile (retries-- > 0) {\n\t\tret = i2c_smbus_read_word_data(client, reg);\n\t\tif (ret >= 0)\n\t\t\tbreak;\n\n\t\tmsleep(A500_EC_I2C_ERR_TIMEOUT);\n\t}\n\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"read 0x%x failed: %d\\n\", reg, ret);\n\t\treturn ret;\n\t}\n\n\t*ret_val = ret;\n\n\tif (reg == REG_CURRENT_NOW)\n\t\tfsleep(10000);\n\n\treturn 0;\n}\n\nstatic int a500_ec_write(void *context, const void *data, size_t count)\n{\n\tstruct i2c_client *client = context;\n\tunsigned int reg, val, retries = 5;\n\ts32 ret = 0;\n\n\treg = *(u8  *)(data + 0);\n\tval = *(u16 *)(data + 1);\n\n\twhile (retries-- > 0) {\n\t\tret = i2c_smbus_write_word_data(client, reg, val);\n\t\tif (ret >= 0)\n\t\t\tbreak;\n\n\t\tmsleep(A500_EC_I2C_ERR_TIMEOUT);\n\t}\n\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"write 0x%x failed: %d\\n\", reg, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct regmap_config a500_ec_regmap_config = {\n\t.name = \"KB930\",\n\t.reg_bits = 8,\n\t.val_bits = 16,\n\t.max_register = 0xff,\n};\n\nstatic const struct regmap_bus a500_ec_regmap_bus = {\n\t.reg_format_endian_default = REGMAP_ENDIAN_NATIVE,\n\t.val_format_endian_default = REGMAP_ENDIAN_LITTLE,\n\t.write = a500_ec_write,\n\t.read = a500_ec_read,\n\t.max_raw_read = 2,\n};\n\nstatic void a500_ec_poweroff(void)\n{\n\ti2c_smbus_write_word_data(a500_ec_client_pm_off,\n\t\t\t\t  REG_SHUTDOWN, CMD_SHUTDOWN);\n\n\tmdelay(A500_EC_POWER_CMD_TIMEOUT);\n}\n\nstatic int a500_ec_restart_notify(struct notifier_block *this,\n\t\t\t\t  unsigned long reboot_mode, void *data)\n{\n\tif (reboot_mode == REBOOT_WARM)\n\t\ti2c_smbus_write_word_data(a500_ec_client_pm_off,\n\t\t\t\t\t  REG_WARM_REBOOT, CMD_WARM_REBOOT);\n\telse\n\t\ti2c_smbus_write_word_data(a500_ec_client_pm_off,\n\t\t\t\t\t  REG_COLD_REBOOT, CMD_COLD_REBOOT);\n\n\tmdelay(A500_EC_POWER_CMD_TIMEOUT);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block a500_ec_restart_handler = {\n\t.notifier_call = a500_ec_restart_notify,\n\t.priority = 200,\n};\n\nstatic const struct mfd_cell a500_ec_cells[] = {\n\t{ .name = \"acer-a500-iconia-battery\", },\n\t{ .name = \"acer-a500-iconia-leds\", },\n};\n\nstatic int a500_ec_probe(struct i2c_client *client)\n{\n\tstruct regmap *regmap;\n\tint err;\n\n\tregmap = devm_regmap_init(&client->dev, &a500_ec_regmap_bus,\n\t\t\t\t  client, &a500_ec_regmap_config);\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\terr = devm_mfd_add_devices(&client->dev, PLATFORM_DEVID_AUTO,\n\t\t\t\t   a500_ec_cells, ARRAY_SIZE(a500_ec_cells),\n\t\t\t\t   NULL, 0, NULL);\n\tif (err) {\n\t\tdev_err(&client->dev, \"failed to add sub-devices: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (of_device_is_system_power_controller(client->dev.of_node)) {\n\t\ta500_ec_client_pm_off = client;\n\n\t\terr = register_restart_handler(&a500_ec_restart_handler);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (!pm_power_off)\n\t\t\tpm_power_off = a500_ec_poweroff;\n\t}\n\n\treturn 0;\n}\n\nstatic void a500_ec_remove(struct i2c_client *client)\n{\n\tif (of_device_is_system_power_controller(client->dev.of_node)) {\n\t\tif (pm_power_off == a500_ec_poweroff)\n\t\t\tpm_power_off = NULL;\n\n\t\tunregister_restart_handler(&a500_ec_restart_handler);\n\t}\n}\n\nstatic const struct of_device_id a500_ec_match[] = {\n\t{ .compatible = \"acer,a500-iconia-ec\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, a500_ec_match);\n\nstatic struct i2c_driver a500_ec_driver = {\n\t.driver = {\n\t\t.name = \"acer-a500-embedded-controller\",\n\t\t.of_match_table = a500_ec_match,\n\t},\n\t.probe = a500_ec_probe,\n\t.remove = a500_ec_remove,\n};\nmodule_i2c_driver(a500_ec_driver);\n\nMODULE_DESCRIPTION(\"Acer Iconia Tab A500 Embedded Controller driver\");\nMODULE_AUTHOR(\"Dmitry Osipenko <digetx@gmail.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}