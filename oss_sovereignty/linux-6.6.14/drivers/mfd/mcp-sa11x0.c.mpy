{
  "module_name": "mcp-sa11x0.c",
  "hash_id": "c36058612814da56e02f6d8e186238047008d8c51911f3ac40d4c35abf114ac2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/mcp-sa11x0.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/mfd/mcp.h>\n\n#include <mach/hardware.h>\n#include <asm/mach-types.h>\n#include <linux/platform_data/mfd-mcp-sa11x0.h>\n\n#define DRIVER_NAME \"sa11x0-mcp\"\n\nstruct mcp_sa11x0 {\n\tvoid __iomem\t*base0;\n\tvoid __iomem\t*base1;\n\tu32\t\tmccr0;\n\tu32\t\tmccr1;\n};\n\n \n#define MCCR0(m)\t((m)->base0 + 0x00)\n#define MCDR0(m)\t((m)->base0 + 0x08)\n#define MCDR1(m)\t((m)->base0 + 0x0c)\n#define MCDR2(m)\t((m)->base0 + 0x10)\n#define MCSR(m)\t\t((m)->base0 + 0x18)\n#define MCCR1(m)\t((m)->base1 + 0x00)\n\n#define priv(mcp)\t((struct mcp_sa11x0 *)mcp_priv(mcp))\n\nstatic void\nmcp_sa11x0_set_telecom_divisor(struct mcp *mcp, unsigned int divisor)\n{\n\tstruct mcp_sa11x0 *m = priv(mcp);\n\n\tdivisor /= 32;\n\n\tm->mccr0 &= ~0x00007f00;\n\tm->mccr0 |= divisor << 8;\n\twritel_relaxed(m->mccr0, MCCR0(m));\n}\n\nstatic void\nmcp_sa11x0_set_audio_divisor(struct mcp *mcp, unsigned int divisor)\n{\n\tstruct mcp_sa11x0 *m = priv(mcp);\n\n\tdivisor /= 32;\n\n\tm->mccr0 &= ~0x0000007f;\n\tm->mccr0 |= divisor;\n\twritel_relaxed(m->mccr0, MCCR0(m));\n}\n\n \nstatic void\nmcp_sa11x0_write(struct mcp *mcp, unsigned int reg, unsigned int val)\n{\n\tstruct mcp_sa11x0 *m = priv(mcp);\n\tint ret = -ETIME;\n\tint i;\n\n\twritel_relaxed(reg << 17 | MCDR2_Wr | (val & 0xffff), MCDR2(m));\n\n\tfor (i = 0; i < 2; i++) {\n\t\tudelay(mcp->rw_timeout);\n\t\tif (readl_relaxed(MCSR(m)) & MCSR_CWC) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret < 0)\n\t\tprintk(KERN_WARNING \"mcp: write timed out\\n\");\n}\n\n \nstatic unsigned int\nmcp_sa11x0_read(struct mcp *mcp, unsigned int reg)\n{\n\tstruct mcp_sa11x0 *m = priv(mcp);\n\tint ret = -ETIME;\n\tint i;\n\n\twritel_relaxed(reg << 17 | MCDR2_Rd, MCDR2(m));\n\n\tfor (i = 0; i < 2; i++) {\n\t\tudelay(mcp->rw_timeout);\n\t\tif (readl_relaxed(MCSR(m)) & MCSR_CRC) {\n\t\t\tret = readl_relaxed(MCDR2(m)) & 0xffff;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret < 0)\n\t\tprintk(KERN_WARNING \"mcp: read timed out\\n\");\n\n\treturn ret;\n}\n\nstatic void mcp_sa11x0_enable(struct mcp *mcp)\n{\n\tstruct mcp_sa11x0 *m = priv(mcp);\n\n\twritel(-1, MCSR(m));\n\tm->mccr0 |= MCCR0_MCE;\n\twritel_relaxed(m->mccr0, MCCR0(m));\n}\n\nstatic void mcp_sa11x0_disable(struct mcp *mcp)\n{\n\tstruct mcp_sa11x0 *m = priv(mcp);\n\n\tm->mccr0 &= ~MCCR0_MCE;\n\twritel_relaxed(m->mccr0, MCCR0(m));\n}\n\n \nstatic struct mcp_ops mcp_sa11x0 = {\n\t.set_telecom_divisor\t= mcp_sa11x0_set_telecom_divisor,\n\t.set_audio_divisor\t= mcp_sa11x0_set_audio_divisor,\n\t.reg_write\t\t= mcp_sa11x0_write,\n\t.reg_read\t\t= mcp_sa11x0_read,\n\t.enable\t\t\t= mcp_sa11x0_enable,\n\t.disable\t\t= mcp_sa11x0_disable,\n};\n\nstatic int mcp_sa11x0_probe(struct platform_device *dev)\n{\n\tstruct mcp_plat_data *data = dev_get_platdata(&dev->dev);\n\tstruct resource *mem0, *mem1;\n\tstruct mcp_sa11x0 *m;\n\tstruct mcp *mcp;\n\tint ret;\n\n\tif (!data)\n\t\treturn -ENODEV;\n\n\tmem0 = platform_get_resource(dev, IORESOURCE_MEM, 0);\n\tmem1 = platform_get_resource(dev, IORESOURCE_MEM, 1);\n\tif (!mem0 || !mem1)\n\t\treturn -ENXIO;\n\n\tif (!request_mem_region(mem0->start, resource_size(mem0),\n\t\t\t\tDRIVER_NAME)) {\n\t\tret = -EBUSY;\n\t\tgoto err_mem0;\n\t}\n\n\tif (!request_mem_region(mem1->start, resource_size(mem1),\n\t\t\t\tDRIVER_NAME)) {\n\t\tret = -EBUSY;\n\t\tgoto err_mem1;\n\t}\n\n\tmcp = mcp_host_alloc(&dev->dev, sizeof(struct mcp_sa11x0));\n\tif (!mcp) {\n\t\tret = -ENOMEM;\n\t\tgoto err_alloc;\n\t}\n\n\tmcp->owner\t\t= THIS_MODULE;\n\tmcp->ops\t\t= &mcp_sa11x0;\n\tmcp->sclk_rate\t\t= data->sclk_rate;\n\n\tm = priv(mcp);\n\tm->mccr0 = data->mccr0 | 0x7f7f;\n\tm->mccr1 = data->mccr1;\n\n\tm->base0 = ioremap(mem0->start, resource_size(mem0));\n\tm->base1 = ioremap(mem1->start, resource_size(mem1));\n\tif (!m->base0 || !m->base1) {\n\t\tret = -ENOMEM;\n\t\tgoto err_ioremap;\n\t}\n\n\tplatform_set_drvdata(dev, mcp);\n\n\t \n\twritel_relaxed(-1, MCSR(m));\n\twritel_relaxed(m->mccr1, MCCR1(m));\n\twritel_relaxed(m->mccr0, MCCR0(m));\n\n\t \n\tmcp->rw_timeout = DIV_ROUND_UP(64 * 3 * 1000000, mcp->sclk_rate);\n\n\tret = mcp_host_add(mcp, data->codec_pdata);\n\tif (ret == 0)\n\t\treturn 0;\n\n err_ioremap:\n\tiounmap(m->base1);\n\tiounmap(m->base0);\n\tmcp_host_free(mcp);\n err_alloc:\n\trelease_mem_region(mem1->start, resource_size(mem1));\n err_mem1:\n\trelease_mem_region(mem0->start, resource_size(mem0));\n err_mem0:\n\treturn ret;\n}\n\nstatic int mcp_sa11x0_remove(struct platform_device *dev)\n{\n\tstruct mcp *mcp = platform_get_drvdata(dev);\n\tstruct mcp_sa11x0 *m = priv(mcp);\n\tstruct resource *mem0, *mem1;\n\n\tif (m->mccr0 & MCCR0_MCE)\n\t\tdev_warn(&dev->dev,\n\t\t\t \"device left active (missing disable call?)\\n\");\n\n\tmem0 = platform_get_resource(dev, IORESOURCE_MEM, 0);\n\tmem1 = platform_get_resource(dev, IORESOURCE_MEM, 1);\n\n\tmcp_host_del(mcp);\n\tiounmap(m->base1);\n\tiounmap(m->base0);\n\tmcp_host_free(mcp);\n\trelease_mem_region(mem1->start, resource_size(mem1));\n\trelease_mem_region(mem0->start, resource_size(mem0));\n\n\treturn 0;\n}\n\nstatic int mcp_sa11x0_suspend(struct device *dev)\n{\n\tstruct mcp_sa11x0 *m = priv(dev_get_drvdata(dev));\n\n\tif (m->mccr0 & MCCR0_MCE)\n\t\tdev_warn(dev, \"device left active (missing disable call?)\\n\");\n\n\twritel(m->mccr0 & ~MCCR0_MCE, MCCR0(m));\n\n\treturn 0;\n}\n\nstatic int mcp_sa11x0_resume(struct device *dev)\n{\n\tstruct mcp_sa11x0 *m = priv(dev_get_drvdata(dev));\n\n\twritel_relaxed(m->mccr1, MCCR1(m));\n\twritel_relaxed(m->mccr0, MCCR0(m));\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops mcp_sa11x0_pm_ops = {\n\t.suspend = mcp_sa11x0_suspend,\n\t.freeze = mcp_sa11x0_suspend,\n\t.poweroff = mcp_sa11x0_suspend,\n\t.resume_noirq = mcp_sa11x0_resume,\n\t.thaw_noirq = mcp_sa11x0_resume,\n\t.restore_noirq = mcp_sa11x0_resume,\n};\n\nstatic struct platform_driver mcp_sa11x0_driver = {\n\t.probe\t\t= mcp_sa11x0_probe,\n\t.remove\t\t= mcp_sa11x0_remove,\n\t.driver\t\t= {\n\t\t.name\t= DRIVER_NAME,\n\t\t.pm\t= pm_sleep_ptr(&mcp_sa11x0_pm_ops),\n\t},\n};\n\n \nmodule_platform_driver(mcp_sa11x0_driver);\n\nMODULE_ALIAS(\"platform:\" DRIVER_NAME);\nMODULE_AUTHOR(\"Russell King <rmk@arm.linux.org.uk>\");\nMODULE_DESCRIPTION(\"SA11x0 multimedia communications port driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}