{
  "module_name": "max14577.c",
  "hash_id": "8956186db80fba08a435f344733d15419e3557d9f00f61fac0bc3c17556a93ac",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/max14577.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/of_device.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/max14577.h>\n#include <linux/mfd/max14577-private.h>\n\n \nconst struct maxim_charger_current maxim_charger_currents[] = {\n\t[MAXIM_DEVICE_TYPE_UNKNOWN] = { 0, 0, 0, 0 },\n\t[MAXIM_DEVICE_TYPE_MAX14577] = {\n\t\t.min\t\t= MAX14577_CHARGER_CURRENT_LIMIT_MIN,\n\t\t.high_start\t= MAX14577_CHARGER_CURRENT_LIMIT_HIGH_START,\n\t\t.high_step\t= MAX14577_CHARGER_CURRENT_LIMIT_HIGH_STEP,\n\t\t.max\t\t= MAX14577_CHARGER_CURRENT_LIMIT_MAX,\n\t},\n\t[MAXIM_DEVICE_TYPE_MAX77836] = {\n\t\t.min\t\t= MAX77836_CHARGER_CURRENT_LIMIT_MIN,\n\t\t.high_start\t= MAX77836_CHARGER_CURRENT_LIMIT_HIGH_START,\n\t\t.high_step\t= MAX77836_CHARGER_CURRENT_LIMIT_HIGH_STEP,\n\t\t.max\t\t= MAX77836_CHARGER_CURRENT_LIMIT_MAX,\n\t},\n};\nEXPORT_SYMBOL_GPL(maxim_charger_currents);\n\n \nint maxim_charger_calc_reg_current(const struct maxim_charger_current *limits,\n\t\tunsigned int min_ua, unsigned int max_ua, u8 *dst)\n{\n\tunsigned int current_bits;\n\n\tif (min_ua > max_ua)\n\t\treturn -EINVAL;\n\n\tif (min_ua > limits->max || max_ua < limits->min)\n\t\treturn -EINVAL;\n\n\tif (max_ua < limits->high_start) {\n\t\t \n\t\t*dst = 0x0;\n\t\treturn 0;\n\t}\n\n\t \n\tmax_ua = min(limits->max, max_ua);\n\tmax_ua -= limits->high_start;\n\t \n\tcurrent_bits = max_ua / limits->high_step;\n\n\t \n\t*dst = 0x1 << CHGCTRL4_MBCICHWRCL_SHIFT;\n\t \n\t*dst |= current_bits << CHGCTRL4_MBCICHWRCH_SHIFT;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(maxim_charger_calc_reg_current);\n\nstatic const struct mfd_cell max14577_devs[] = {\n\t{\n\t\t.name = \"max14577-muic\",\n\t\t.of_compatible = \"maxim,max14577-muic\",\n\t},\n\t{\n\t\t.name = \"max14577-regulator\",\n\t\t.of_compatible = \"maxim,max14577-regulator\",\n\t},\n\t{\n\t\t.name = \"max14577-charger\",\n\t\t.of_compatible = \"maxim,max14577-charger\",\n\t},\n};\n\nstatic const struct mfd_cell max77836_devs[] = {\n\t{\n\t\t.name = \"max77836-muic\",\n\t\t.of_compatible = \"maxim,max77836-muic\",\n\t},\n\t{\n\t\t.name = \"max77836-regulator\",\n\t\t.of_compatible = \"maxim,max77836-regulator\",\n\t},\n\t{\n\t\t.name = \"max77836-charger\",\n\t\t.of_compatible = \"maxim,max77836-charger\",\n\t},\n\t{\n\t\t.name = \"max77836-battery\",\n\t\t.of_compatible = \"maxim,max77836-battery\",\n\t},\n};\n\nstatic const struct of_device_id max14577_dt_match[] = {\n\t{\n\t\t.compatible = \"maxim,max14577\",\n\t\t.data = (void *)MAXIM_DEVICE_TYPE_MAX14577,\n\t},\n\t{\n\t\t.compatible = \"maxim,max77836\",\n\t\t.data = (void *)MAXIM_DEVICE_TYPE_MAX77836,\n\t},\n\t{},\n};\n\nstatic bool max14577_muic_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase MAX14577_REG_INT1 ... MAX14577_REG_STATUS3:\n\t\treturn true;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn false;\n}\n\nstatic bool max77836_muic_volatile_reg(struct device *dev, unsigned int reg)\n{\n\t \n\tif (max14577_muic_volatile_reg(dev, reg))\n\t\treturn true;\n\n\tswitch (reg) {\n\tcase MAX77836_FG_REG_VCELL_MSB ... MAX77836_FG_REG_SOC_LSB:\n\tcase MAX77836_FG_REG_CRATE_MSB ... MAX77836_FG_REG_CRATE_LSB:\n\tcase MAX77836_FG_REG_STATUS_H ... MAX77836_FG_REG_STATUS_L:\n\tcase MAX77836_PMIC_REG_INTSRC:\n\tcase MAX77836_PMIC_REG_TOPSYS_INT:\n\tcase MAX77836_PMIC_REG_TOPSYS_STAT:\n\t\treturn true;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn false;\n}\n\nstatic const struct regmap_config max14577_muic_regmap_config = {\n\t.reg_bits\t= 8,\n\t.val_bits\t= 8,\n\t.volatile_reg\t= max14577_muic_volatile_reg,\n\t.max_register\t= MAX14577_REG_END,\n};\n\nstatic const struct regmap_config max77836_pmic_regmap_config = {\n\t.reg_bits\t= 8,\n\t.val_bits\t= 8,\n\t.volatile_reg\t= max77836_muic_volatile_reg,\n\t.max_register\t= MAX77836_PMIC_REG_END,\n};\n\nstatic const struct regmap_irq max14577_irqs[] = {\n\t \n\t{ .reg_offset = 0, .mask = MAX14577_INT1_ADC_MASK, },\n\t{ .reg_offset = 0, .mask = MAX14577_INT1_ADCLOW_MASK, },\n\t{ .reg_offset = 0, .mask = MAX14577_INT1_ADCERR_MASK, },\n\t \n\t{ .reg_offset = 1, .mask = MAX14577_INT2_CHGTYP_MASK, },\n\t{ .reg_offset = 1, .mask = MAX14577_INT2_CHGDETRUN_MASK, },\n\t{ .reg_offset = 1, .mask = MAX14577_INT2_DCDTMR_MASK, },\n\t{ .reg_offset = 1, .mask = MAX14577_INT2_DBCHG_MASK, },\n\t{ .reg_offset = 1, .mask = MAX14577_INT2_VBVOLT_MASK, },\n\t \n\t{ .reg_offset = 2, .mask = MAX14577_INT3_EOC_MASK, },\n\t{ .reg_offset = 2, .mask = MAX14577_INT3_CGMBC_MASK, },\n\t{ .reg_offset = 2, .mask = MAX14577_INT3_OVP_MASK, },\n\t{ .reg_offset = 2, .mask = MAX14577_INT3_MBCCHGERR_MASK, },\n};\n\nstatic const struct regmap_irq_chip max14577_irq_chip = {\n\t.name\t\t\t= \"max14577\",\n\t.status_base\t\t= MAX14577_REG_INT1,\n\t.unmask_base\t\t= MAX14577_REG_INTMASK1,\n\t.num_regs\t\t= 3,\n\t.irqs\t\t\t= max14577_irqs,\n\t.num_irqs\t\t= ARRAY_SIZE(max14577_irqs),\n};\n\nstatic const struct regmap_irq max77836_muic_irqs[] = {\n\t \n\t{ .reg_offset = 0, .mask = MAX14577_INT1_ADC_MASK, },\n\t{ .reg_offset = 0, .mask = MAX14577_INT1_ADCLOW_MASK, },\n\t{ .reg_offset = 0, .mask = MAX14577_INT1_ADCERR_MASK, },\n\t{ .reg_offset = 0, .mask = MAX77836_INT1_ADC1K_MASK, },\n\t \n\t{ .reg_offset = 1, .mask = MAX14577_INT2_CHGTYP_MASK, },\n\t{ .reg_offset = 1, .mask = MAX14577_INT2_CHGDETRUN_MASK, },\n\t{ .reg_offset = 1, .mask = MAX14577_INT2_DCDTMR_MASK, },\n\t{ .reg_offset = 1, .mask = MAX14577_INT2_DBCHG_MASK, },\n\t{ .reg_offset = 1, .mask = MAX14577_INT2_VBVOLT_MASK, },\n\t{ .reg_offset = 1, .mask = MAX77836_INT2_VIDRM_MASK, },\n\t \n\t{ .reg_offset = 2, .mask = MAX14577_INT3_EOC_MASK, },\n\t{ .reg_offset = 2, .mask = MAX14577_INT3_CGMBC_MASK, },\n\t{ .reg_offset = 2, .mask = MAX14577_INT3_OVP_MASK, },\n\t{ .reg_offset = 2, .mask = MAX14577_INT3_MBCCHGERR_MASK, },\n};\n\nstatic const struct regmap_irq_chip max77836_muic_irq_chip = {\n\t.name\t\t\t= \"max77836-muic\",\n\t.status_base\t\t= MAX14577_REG_INT1,\n\t.unmask_base\t\t= MAX14577_REG_INTMASK1,\n\t.num_regs\t\t= 3,\n\t.irqs\t\t\t= max77836_muic_irqs,\n\t.num_irqs\t\t= ARRAY_SIZE(max77836_muic_irqs),\n};\n\nstatic const struct regmap_irq max77836_pmic_irqs[] = {\n\t{ .reg_offset = 0, .mask = MAX77836_TOPSYS_INT_T120C_MASK, },\n\t{ .reg_offset = 0, .mask = MAX77836_TOPSYS_INT_T140C_MASK, },\n};\n\nstatic const struct regmap_irq_chip max77836_pmic_irq_chip = {\n\t.name\t\t\t= \"max77836-pmic\",\n\t.status_base\t\t= MAX77836_PMIC_REG_TOPSYS_INT,\n\t.mask_base\t\t= MAX77836_PMIC_REG_TOPSYS_INT_MASK,\n\t.num_regs\t\t= 1,\n\t.irqs\t\t\t= max77836_pmic_irqs,\n\t.num_irqs\t\t= ARRAY_SIZE(max77836_pmic_irqs),\n};\n\nstatic void max14577_print_dev_type(struct max14577 *max14577)\n{\n\tu8 reg_data, vendor_id, device_id;\n\tint ret;\n\n\tret = max14577_read_reg(max14577->regmap, MAX14577_REG_DEVICEID,\n\t\t\t&reg_data);\n\tif (ret) {\n\t\tdev_err(max14577->dev,\n\t\t\t\"Failed to read DEVICEID register: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tvendor_id = ((reg_data & DEVID_VENDORID_MASK) >>\n\t\t\t\tDEVID_VENDORID_SHIFT);\n\tdevice_id = ((reg_data & DEVID_DEVICEID_MASK) >>\n\t\t\t\tDEVID_DEVICEID_SHIFT);\n\n\tdev_info(max14577->dev, \"Device type: %u (ID: 0x%x, vendor: 0x%x)\\n\",\n\t\t\tmax14577->dev_type, device_id, vendor_id);\n}\n\n \nstatic int max77836_init(struct max14577 *max14577)\n{\n\tint ret;\n\tu8 intsrc_mask;\n\n\tmax14577->i2c_pmic = i2c_new_dummy_device(max14577->i2c->adapter,\n\t\t\tI2C_ADDR_PMIC);\n\tif (IS_ERR(max14577->i2c_pmic)) {\n\t\tdev_err(max14577->dev, \"Failed to register PMIC I2C device\\n\");\n\t\treturn PTR_ERR(max14577->i2c_pmic);\n\t}\n\ti2c_set_clientdata(max14577->i2c_pmic, max14577);\n\n\tmax14577->regmap_pmic = devm_regmap_init_i2c(max14577->i2c_pmic,\n\t\t\t&max77836_pmic_regmap_config);\n\tif (IS_ERR(max14577->regmap_pmic)) {\n\t\tret = PTR_ERR(max14577->regmap_pmic);\n\t\tdev_err(max14577->dev, \"Failed to allocate PMIC register map: %d\\n\",\n\t\t\t\tret);\n\t\tgoto err;\n\t}\n\n\t \n\tret = max14577_read_reg(max14577->regmap_pmic,\n\t\t\tMAX77836_PMIC_REG_INTSRC_MASK, &intsrc_mask);\n\tif (ret < 0) {\n\t\tdev_err(max14577->dev, \"Failed to read PMIC register\\n\");\n\t\tgoto err;\n\t}\n\n\tintsrc_mask &= ~(MAX77836_INTSRC_MASK_TOP_INT_MASK);\n\tintsrc_mask &= ~(MAX77836_INTSRC_MASK_MUIC_CHG_INT_MASK);\n\tret = max14577_write_reg(max14577->regmap_pmic,\n\t\t\tMAX77836_PMIC_REG_INTSRC_MASK, intsrc_mask);\n\tif (ret < 0) {\n\t\tdev_err(max14577->dev, \"Failed to write PMIC register\\n\");\n\t\tgoto err;\n\t}\n\n\tret = regmap_add_irq_chip(max14577->regmap_pmic, max14577->irq,\n\t\t\tIRQF_ONESHOT | IRQF_SHARED,\n\t\t\t0, &max77836_pmic_irq_chip,\n\t\t\t&max14577->irq_data_pmic);\n\tif (ret != 0) {\n\t\tdev_err(max14577->dev, \"Failed to request PMIC IRQ %d: %d\\n\",\n\t\t\t\tmax14577->irq, ret);\n\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\ti2c_unregister_device(max14577->i2c_pmic);\n\n\treturn ret;\n}\n\n \nstatic void max77836_remove(struct max14577 *max14577)\n{\n\tregmap_del_irq_chip(max14577->irq, max14577->irq_data_pmic);\n\ti2c_unregister_device(max14577->i2c_pmic);\n}\n\nstatic int max14577_i2c_probe(struct i2c_client *i2c)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(i2c);\n\tstruct max14577 *max14577;\n\tstruct max14577_platform_data *pdata = dev_get_platdata(&i2c->dev);\n\tstruct device_node *np = i2c->dev.of_node;\n\tint ret = 0;\n\tconst struct regmap_irq_chip *irq_chip;\n\tconst struct mfd_cell *mfd_devs;\n\tunsigned int mfd_devs_size;\n\tint irq_flags;\n\n\tif (np) {\n\t\tpdata = devm_kzalloc(&i2c->dev, sizeof(*pdata), GFP_KERNEL);\n\t\tif (!pdata)\n\t\t\treturn -ENOMEM;\n\t\ti2c->dev.platform_data = pdata;\n\t}\n\n\tif (!pdata) {\n\t\tdev_err(&i2c->dev, \"No platform data found.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmax14577 = devm_kzalloc(&i2c->dev, sizeof(*max14577), GFP_KERNEL);\n\tif (!max14577)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(i2c, max14577);\n\tmax14577->dev = &i2c->dev;\n\tmax14577->i2c = i2c;\n\tmax14577->irq = i2c->irq;\n\n\tmax14577->regmap = devm_regmap_init_i2c(i2c,\n\t\t\t&max14577_muic_regmap_config);\n\tif (IS_ERR(max14577->regmap)) {\n\t\tret = PTR_ERR(max14577->regmap);\n\t\tdev_err(max14577->dev, \"Failed to allocate register map: %d\\n\",\n\t\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tif (np) {\n\t\tconst struct of_device_id *of_id;\n\n\t\tof_id = of_match_device(max14577_dt_match, &i2c->dev);\n\t\tif (of_id)\n\t\t\tmax14577->dev_type = (uintptr_t)of_id->data;\n\t} else {\n\t\tmax14577->dev_type = id->driver_data;\n\t}\n\n\tmax14577_print_dev_type(max14577);\n\n\tswitch (max14577->dev_type) {\n\tcase MAXIM_DEVICE_TYPE_MAX77836:\n\t\tirq_chip = &max77836_muic_irq_chip;\n\t\tmfd_devs = max77836_devs;\n\t\tmfd_devs_size = ARRAY_SIZE(max77836_devs);\n\t\tirq_flags = IRQF_ONESHOT | IRQF_SHARED;\n\t\tbreak;\n\tcase MAXIM_DEVICE_TYPE_MAX14577:\n\tdefault:\n\t\tirq_chip = &max14577_irq_chip;\n\t\tmfd_devs = max14577_devs;\n\t\tmfd_devs_size = ARRAY_SIZE(max14577_devs);\n\t\tirq_flags = IRQF_ONESHOT;\n\t\tbreak;\n\t}\n\n\tret = regmap_add_irq_chip(max14577->regmap, max14577->irq,\n\t\t\t\t  irq_flags, 0, irq_chip,\n\t\t\t\t  &max14577->irq_data);\n\tif (ret != 0) {\n\t\tdev_err(&i2c->dev, \"Failed to request IRQ %d: %d\\n\",\n\t\t\t\tmax14577->irq, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (max14577->dev_type == MAXIM_DEVICE_TYPE_MAX77836) {\n\t\tret = max77836_init(max14577);\n\t\tif (ret < 0)\n\t\t\tgoto err_max77836;\n\t}\n\n\tret = mfd_add_devices(max14577->dev, -1, mfd_devs,\n\t\t\tmfd_devs_size, NULL, 0, NULL);\n\tif (ret < 0)\n\t\tgoto err_mfd;\n\n\tdevice_init_wakeup(max14577->dev, 1);\n\n\treturn 0;\n\nerr_mfd:\n\tif (max14577->dev_type == MAXIM_DEVICE_TYPE_MAX77836)\n\t\tmax77836_remove(max14577);\nerr_max77836:\n\tregmap_del_irq_chip(max14577->irq, max14577->irq_data);\n\n\treturn ret;\n}\n\nstatic void max14577_i2c_remove(struct i2c_client *i2c)\n{\n\tstruct max14577 *max14577 = i2c_get_clientdata(i2c);\n\n\tmfd_remove_devices(max14577->dev);\n\tregmap_del_irq_chip(max14577->irq, max14577->irq_data);\n\tif (max14577->dev_type == MAXIM_DEVICE_TYPE_MAX77836)\n\t\tmax77836_remove(max14577);\n}\n\nstatic const struct i2c_device_id max14577_i2c_id[] = {\n\t{ \"max14577\", MAXIM_DEVICE_TYPE_MAX14577, },\n\t{ \"max77836\", MAXIM_DEVICE_TYPE_MAX77836, },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, max14577_i2c_id);\n\nstatic int max14577_suspend(struct device *dev)\n{\n\tstruct i2c_client *i2c = to_i2c_client(dev);\n\tstruct max14577 *max14577 = i2c_get_clientdata(i2c);\n\n\tif (device_may_wakeup(dev))\n\t\tenable_irq_wake(max14577->irq);\n\t \n\tdisable_irq(max14577->irq);\n\n\treturn 0;\n}\n\nstatic int max14577_resume(struct device *dev)\n{\n\tstruct i2c_client *i2c = to_i2c_client(dev);\n\tstruct max14577 *max14577 = i2c_get_clientdata(i2c);\n\n\tif (device_may_wakeup(dev))\n\t\tdisable_irq_wake(max14577->irq);\n\tenable_irq(max14577->irq);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(max14577_pm, max14577_suspend, max14577_resume);\n\nstatic struct i2c_driver max14577_i2c_driver = {\n\t.driver = {\n\t\t.name = \"max14577\",\n\t\t.pm = pm_sleep_ptr(&max14577_pm),\n\t\t.of_match_table = max14577_dt_match,\n\t},\n\t.probe = max14577_i2c_probe,\n\t.remove = max14577_i2c_remove,\n\t.id_table = max14577_i2c_id,\n};\n\nstatic int __init max14577_i2c_init(void)\n{\n\tBUILD_BUG_ON(ARRAY_SIZE(max14577_i2c_id) != MAXIM_DEVICE_TYPE_NUM);\n\tBUILD_BUG_ON(ARRAY_SIZE(max14577_dt_match) != MAXIM_DEVICE_TYPE_NUM);\n\n\t \n\tBUILD_BUG_ON(ARRAY_SIZE(maxim_charger_currents) != MAXIM_DEVICE_TYPE_NUM);\n\n\t \n\tBUILD_BUG_ON(MAX14577_CHARGER_CURRENT_LIMIT_HIGH_START +\n\t\t\tMAX14577_CHARGER_CURRENT_LIMIT_HIGH_STEP * 0xf !=\n\t\t\tMAX14577_CHARGER_CURRENT_LIMIT_MAX);\n\tBUILD_BUG_ON(MAX14577_CHARGER_CURRENT_LIMIT_HIGH_STEP == 0);\n\n\tBUILD_BUG_ON(MAX77836_CHARGER_CURRENT_LIMIT_HIGH_START +\n\t\t\tMAX77836_CHARGER_CURRENT_LIMIT_HIGH_STEP * 0xf !=\n\t\t\tMAX77836_CHARGER_CURRENT_LIMIT_MAX);\n\tBUILD_BUG_ON(MAX77836_CHARGER_CURRENT_LIMIT_HIGH_STEP == 0);\n\n\treturn i2c_add_driver(&max14577_i2c_driver);\n}\nmodule_init(max14577_i2c_init);\n\nstatic void __exit max14577_i2c_exit(void)\n{\n\ti2c_del_driver(&max14577_i2c_driver);\n}\nmodule_exit(max14577_i2c_exit);\n\nMODULE_AUTHOR(\"Chanwoo Choi <cw00.choi@samsung.com>, Krzysztof Kozlowski <krzk@kernel.org>\");\nMODULE_DESCRIPTION(\"Maxim 14577/77836 multi-function core driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}