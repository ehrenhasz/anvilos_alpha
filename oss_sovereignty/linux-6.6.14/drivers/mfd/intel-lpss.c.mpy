{
  "module_name": "intel-lpss.c",
  "hash_id": "8d2cc9562298eba81ab28d21bfdf85bf33c23ddd2ae844cf4d62fb9801b1e7f1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/intel-lpss.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clkdev.h>\n#include <linux/clk-provider.h>\n#include <linux/debugfs.h>\n#include <linux/idr.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mfd/core.h>\n#include <linux/pm_qos.h>\n#include <linux/pm_runtime.h>\n#include <linux/property.h>\n#include <linux/seq_file.h>\n#include <linux/io-64-nonatomic-lo-hi.h>\n\n#include <linux/dma/idma64.h>\n\n#include \"intel-lpss.h\"\n\n#define LPSS_DEV_OFFSET\t\t0x000\n#define LPSS_DEV_SIZE\t\t0x200\n#define LPSS_PRIV_OFFSET\t0x200\n#define LPSS_PRIV_SIZE\t\t0x100\n#define LPSS_PRIV_REG_COUNT\t(LPSS_PRIV_SIZE / 4)\n#define LPSS_IDMA64_OFFSET\t0x800\n#define LPSS_IDMA64_SIZE\t0x800\n\n \n#define LPSS_PRIV_RESETS\t\t0x04\n#define LPSS_PRIV_RESETS_IDMA\t\tBIT(2)\n#define LPSS_PRIV_RESETS_FUNC\t\t0x3\n\n#define LPSS_PRIV_ACTIVELTR\t\t0x10\n#define LPSS_PRIV_IDLELTR\t\t0x14\n\n#define LPSS_PRIV_LTR_REQ\t\tBIT(15)\n#define LPSS_PRIV_LTR_SCALE_MASK\tGENMASK(11, 10)\n#define LPSS_PRIV_LTR_SCALE_1US\t\t(2 << 10)\n#define LPSS_PRIV_LTR_SCALE_32US\t(3 << 10)\n#define LPSS_PRIV_LTR_VALUE_MASK\tGENMASK(9, 0)\n\n#define LPSS_PRIV_SSP_REG\t\t0x20\n#define LPSS_PRIV_SSP_REG_DIS_DMA_FIN\tBIT(0)\n\n#define LPSS_PRIV_REMAP_ADDR\t\t0x40\n\n#define LPSS_PRIV_CAPS\t\t\t0xfc\n#define LPSS_PRIV_CAPS_NO_IDMA\t\tBIT(8)\n#define LPSS_PRIV_CAPS_TYPE_MASK\tGENMASK(7, 4)\n#define LPSS_PRIV_CAPS_TYPE_SHIFT\t4\n\n \nenum intel_lpss_dev_type {\n\tLPSS_DEV_I2C = 0,\n\tLPSS_DEV_UART,\n\tLPSS_DEV_SPI,\n};\n\nstruct intel_lpss {\n\tconst struct intel_lpss_platform_info *info;\n\tenum intel_lpss_dev_type type;\n\tstruct clk *clk;\n\tstruct clk_lookup *clock;\n\tstruct mfd_cell *cell;\n\tstruct device *dev;\n\tvoid __iomem *priv;\n\tu32 priv_ctx[LPSS_PRIV_REG_COUNT];\n\tint devid;\n\tu32 caps;\n\tu32 active_ltr;\n\tu32 idle_ltr;\n\tstruct dentry *debugfs;\n};\n\nstatic const struct resource intel_lpss_dev_resources[] = {\n\tDEFINE_RES_MEM_NAMED(LPSS_DEV_OFFSET, LPSS_DEV_SIZE, \"lpss_dev\"),\n\tDEFINE_RES_MEM_NAMED(LPSS_PRIV_OFFSET, LPSS_PRIV_SIZE, \"lpss_priv\"),\n\tDEFINE_RES_IRQ(0),\n};\n\nstatic const struct resource intel_lpss_idma64_resources[] = {\n\tDEFINE_RES_MEM(LPSS_IDMA64_OFFSET, LPSS_IDMA64_SIZE),\n\tDEFINE_RES_IRQ(0),\n};\n\n \nstatic const struct mfd_cell intel_lpss_idma64_cell = {\n\t.name = LPSS_IDMA64_DRIVER_NAME,\n\t.num_resources = ARRAY_SIZE(intel_lpss_idma64_resources),\n\t.resources = intel_lpss_idma64_resources,\n};\n\nstatic const struct mfd_cell intel_lpss_i2c_cell = {\n\t.name = \"i2c_designware\",\n\t.num_resources = ARRAY_SIZE(intel_lpss_dev_resources),\n\t.resources = intel_lpss_dev_resources,\n};\n\nstatic const struct mfd_cell intel_lpss_uart_cell = {\n\t.name = \"dw-apb-uart\",\n\t.num_resources = ARRAY_SIZE(intel_lpss_dev_resources),\n\t.resources = intel_lpss_dev_resources,\n};\n\nstatic const struct mfd_cell intel_lpss_spi_cell = {\n\t.name = \"pxa2xx-spi\",\n\t.num_resources = ARRAY_SIZE(intel_lpss_dev_resources),\n\t.resources = intel_lpss_dev_resources,\n};\n\nstatic DEFINE_IDA(intel_lpss_devid_ida);\nstatic struct dentry *intel_lpss_debugfs;\n\nstatic void intel_lpss_cache_ltr(struct intel_lpss *lpss)\n{\n\tlpss->active_ltr = readl(lpss->priv + LPSS_PRIV_ACTIVELTR);\n\tlpss->idle_ltr = readl(lpss->priv + LPSS_PRIV_IDLELTR);\n}\n\nstatic int intel_lpss_debugfs_add(struct intel_lpss *lpss)\n{\n\tstruct dentry *dir;\n\n\tdir = debugfs_create_dir(dev_name(lpss->dev), intel_lpss_debugfs);\n\tif (IS_ERR(dir))\n\t\treturn PTR_ERR(dir);\n\n\t \n\tintel_lpss_cache_ltr(lpss);\n\n\tdebugfs_create_x32(\"capabilities\", S_IRUGO, dir, &lpss->caps);\n\tdebugfs_create_x32(\"active_ltr\", S_IRUGO, dir, &lpss->active_ltr);\n\tdebugfs_create_x32(\"idle_ltr\", S_IRUGO, dir, &lpss->idle_ltr);\n\n\tlpss->debugfs = dir;\n\treturn 0;\n}\n\nstatic void intel_lpss_debugfs_remove(struct intel_lpss *lpss)\n{\n\tdebugfs_remove_recursive(lpss->debugfs);\n}\n\nstatic void intel_lpss_ltr_set(struct device *dev, s32 val)\n{\n\tstruct intel_lpss *lpss = dev_get_drvdata(dev);\n\tu32 ltr;\n\n\t \n\tltr = readl(lpss->priv + LPSS_PRIV_ACTIVELTR);\n\n\tif (val == PM_QOS_LATENCY_ANY || val < 0) {\n\t\tltr &= ~LPSS_PRIV_LTR_REQ;\n\t} else {\n\t\tltr |= LPSS_PRIV_LTR_REQ;\n\t\tltr &= ~LPSS_PRIV_LTR_SCALE_MASK;\n\t\tltr &= ~LPSS_PRIV_LTR_VALUE_MASK;\n\n\t\tif (val > LPSS_PRIV_LTR_VALUE_MASK)\n\t\t\tltr |= LPSS_PRIV_LTR_SCALE_32US | val >> 5;\n\t\telse\n\t\t\tltr |= LPSS_PRIV_LTR_SCALE_1US | val;\n\t}\n\n\tif (ltr == lpss->active_ltr)\n\t\treturn;\n\n\twritel(ltr, lpss->priv + LPSS_PRIV_ACTIVELTR);\n\twritel(ltr, lpss->priv + LPSS_PRIV_IDLELTR);\n\n\t \n\tintel_lpss_cache_ltr(lpss);\n}\n\nstatic void intel_lpss_ltr_expose(struct intel_lpss *lpss)\n{\n\tlpss->dev->power.set_latency_tolerance = intel_lpss_ltr_set;\n\tdev_pm_qos_expose_latency_tolerance(lpss->dev);\n}\n\nstatic void intel_lpss_ltr_hide(struct intel_lpss *lpss)\n{\n\tdev_pm_qos_hide_latency_tolerance(lpss->dev);\n\tlpss->dev->power.set_latency_tolerance = NULL;\n}\n\nstatic int intel_lpss_assign_devs(struct intel_lpss *lpss)\n{\n\tconst struct mfd_cell *cell;\n\tunsigned int type;\n\n\ttype = lpss->caps & LPSS_PRIV_CAPS_TYPE_MASK;\n\ttype >>= LPSS_PRIV_CAPS_TYPE_SHIFT;\n\n\tswitch (type) {\n\tcase LPSS_DEV_I2C:\n\t\tcell = &intel_lpss_i2c_cell;\n\t\tbreak;\n\tcase LPSS_DEV_UART:\n\t\tcell = &intel_lpss_uart_cell;\n\t\tbreak;\n\tcase LPSS_DEV_SPI:\n\t\tcell = &intel_lpss_spi_cell;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\tlpss->cell = devm_kmemdup(lpss->dev, cell, sizeof(*cell), GFP_KERNEL);\n\tif (!lpss->cell)\n\t\treturn -ENOMEM;\n\n\tlpss->type = type;\n\n\treturn 0;\n}\n\nstatic bool intel_lpss_has_idma(const struct intel_lpss *lpss)\n{\n\treturn (lpss->caps & LPSS_PRIV_CAPS_NO_IDMA) == 0;\n}\n\nstatic void intel_lpss_set_remap_addr(const struct intel_lpss *lpss)\n{\n\tresource_size_t addr = lpss->info->mem->start;\n\n\tlo_hi_writeq(addr, lpss->priv + LPSS_PRIV_REMAP_ADDR);\n}\n\nstatic void intel_lpss_deassert_reset(const struct intel_lpss *lpss)\n{\n\tu32 value = LPSS_PRIV_RESETS_FUNC | LPSS_PRIV_RESETS_IDMA;\n\n\t \n\twritel(value, lpss->priv + LPSS_PRIV_RESETS);\n}\n\nstatic void intel_lpss_init_dev(const struct intel_lpss *lpss)\n{\n\tu32 value = LPSS_PRIV_SSP_REG_DIS_DMA_FIN;\n\n\t \n\twritel(0, lpss->priv + LPSS_PRIV_RESETS);\n\n\tintel_lpss_deassert_reset(lpss);\n\n\tintel_lpss_set_remap_addr(lpss);\n\n\tif (!intel_lpss_has_idma(lpss))\n\t\treturn;\n\n\t \n\tif (lpss->type == LPSS_DEV_SPI)\n\t\twritel(value, lpss->priv + LPSS_PRIV_SSP_REG);\n}\n\nstatic void intel_lpss_unregister_clock_tree(struct clk *clk)\n{\n\tstruct clk *parent;\n\n\twhile (clk) {\n\t\tparent = clk_get_parent(clk);\n\t\tclk_unregister(clk);\n\t\tclk = parent;\n\t}\n}\n\nstatic int intel_lpss_register_clock_divider(struct intel_lpss *lpss,\n\t\t\t\t\t     const char *devname,\n\t\t\t\t\t     struct clk **clk)\n{\n\tchar name[32];\n\tstruct clk *tmp = *clk;\n\n\tsnprintf(name, sizeof(name), \"%s-enable\", devname);\n\ttmp = clk_register_gate(NULL, name, __clk_get_name(tmp), 0,\n\t\t\t\tlpss->priv, 0, 0, NULL);\n\tif (IS_ERR(tmp))\n\t\treturn PTR_ERR(tmp);\n\n\tsnprintf(name, sizeof(name), \"%s-div\", devname);\n\ttmp = clk_register_fractional_divider(NULL, name, __clk_get_name(tmp),\n\t\t\t\t\t      0, lpss->priv, 1, 15, 16, 15,\n\t\t\t\t\t      CLK_FRAC_DIVIDER_POWER_OF_TWO_PS,\n\t\t\t\t\t      NULL);\n\tif (IS_ERR(tmp))\n\t\treturn PTR_ERR(tmp);\n\t*clk = tmp;\n\n\tsnprintf(name, sizeof(name), \"%s-update\", devname);\n\ttmp = clk_register_gate(NULL, name, __clk_get_name(tmp),\n\t\t\t\tCLK_SET_RATE_PARENT, lpss->priv, 31, 0, NULL);\n\tif (IS_ERR(tmp))\n\t\treturn PTR_ERR(tmp);\n\t*clk = tmp;\n\n\treturn 0;\n}\n\nstatic int intel_lpss_register_clock(struct intel_lpss *lpss)\n{\n\tconst struct mfd_cell *cell = lpss->cell;\n\tstruct clk *clk;\n\tchar devname[24];\n\tint ret;\n\n\tif (!lpss->info->clk_rate)\n\t\treturn 0;\n\n\t \n\tclk = clk_register_fixed_rate(NULL, dev_name(lpss->dev), NULL, 0,\n\t\t\t\t      lpss->info->clk_rate);\n\tif (IS_ERR(clk))\n\t\treturn PTR_ERR(clk);\n\n\tsnprintf(devname, sizeof(devname), \"%s.%d\", cell->name, lpss->devid);\n\n\t \n\tif (lpss->type != LPSS_DEV_I2C) {\n\t\tret = intel_lpss_register_clock_divider(lpss, devname, &clk);\n\t\tif (ret)\n\t\t\tgoto err_clk_register;\n\t}\n\n\tret = -ENOMEM;\n\n\t \n\tlpss->clock = clkdev_create(clk, lpss->info->clk_con_id, \"%s\", devname);\n\tif (!lpss->clock)\n\t\tgoto err_clk_register;\n\n\tlpss->clk = clk;\n\n\treturn 0;\n\nerr_clk_register:\n\tintel_lpss_unregister_clock_tree(clk);\n\n\treturn ret;\n}\n\nstatic void intel_lpss_unregister_clock(struct intel_lpss *lpss)\n{\n\tif (IS_ERR_OR_NULL(lpss->clk))\n\t\treturn;\n\n\tclkdev_drop(lpss->clock);\n\tintel_lpss_unregister_clock_tree(lpss->clk);\n}\n\nint intel_lpss_probe(struct device *dev,\n\t\t     const struct intel_lpss_platform_info *info)\n{\n\tstruct intel_lpss *lpss;\n\tint ret;\n\n\tif (!info || !info->mem || info->irq <= 0)\n\t\treturn -EINVAL;\n\n\tlpss = devm_kzalloc(dev, sizeof(*lpss), GFP_KERNEL);\n\tif (!lpss)\n\t\treturn -ENOMEM;\n\n\tlpss->priv = devm_ioremap_uc(dev, info->mem->start + LPSS_PRIV_OFFSET,\n\t\t\t\t  LPSS_PRIV_SIZE);\n\tif (!lpss->priv)\n\t\treturn -ENOMEM;\n\n\tlpss->info = info;\n\tlpss->dev = dev;\n\tlpss->caps = readl(lpss->priv + LPSS_PRIV_CAPS);\n\n\tdev_set_drvdata(dev, lpss);\n\n\tret = intel_lpss_assign_devs(lpss);\n\tif (ret)\n\t\treturn ret;\n\n\tlpss->cell->swnode = info->swnode;\n\tlpss->cell->ignore_resource_conflicts = info->ignore_resource_conflicts;\n\n\tintel_lpss_init_dev(lpss);\n\n\tlpss->devid = ida_simple_get(&intel_lpss_devid_ida, 0, 0, GFP_KERNEL);\n\tif (lpss->devid < 0)\n\t\treturn lpss->devid;\n\n\tret = intel_lpss_register_clock(lpss);\n\tif (ret)\n\t\tgoto err_clk_register;\n\n\tintel_lpss_ltr_expose(lpss);\n\n\tret = intel_lpss_debugfs_add(lpss);\n\tif (ret)\n\t\tdev_warn(dev, \"Failed to create debugfs entries\\n\");\n\n\tif (intel_lpss_has_idma(lpss)) {\n\t\tret = mfd_add_devices(dev, lpss->devid, &intel_lpss_idma64_cell,\n\t\t\t\t      1, info->mem, info->irq, NULL);\n\t\tif (ret)\n\t\t\tdev_warn(dev, \"Failed to add %s, fallback to PIO\\n\",\n\t\t\t\t LPSS_IDMA64_DRIVER_NAME);\n\t}\n\n\tret = mfd_add_devices(dev, lpss->devid, lpss->cell,\n\t\t\t      1, info->mem, info->irq, NULL);\n\tif (ret)\n\t\tgoto err_remove_ltr;\n\n\tdev_pm_set_driver_flags(dev, DPM_FLAG_SMART_SUSPEND);\n\n\treturn 0;\n\nerr_remove_ltr:\n\tintel_lpss_debugfs_remove(lpss);\n\tintel_lpss_ltr_hide(lpss);\n\tintel_lpss_unregister_clock(lpss);\n\nerr_clk_register:\n\tida_simple_remove(&intel_lpss_devid_ida, lpss->devid);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(intel_lpss_probe);\n\nvoid intel_lpss_remove(struct device *dev)\n{\n\tstruct intel_lpss *lpss = dev_get_drvdata(dev);\n\n\tmfd_remove_devices(dev);\n\tintel_lpss_debugfs_remove(lpss);\n\tintel_lpss_ltr_hide(lpss);\n\tintel_lpss_unregister_clock(lpss);\n\tida_simple_remove(&intel_lpss_devid_ida, lpss->devid);\n}\nEXPORT_SYMBOL_GPL(intel_lpss_remove);\n\n#ifdef CONFIG_PM\nstatic int resume_lpss_device(struct device *dev, void *data)\n{\n\tif (!dev_pm_test_driver_flags(dev, DPM_FLAG_SMART_SUSPEND))\n\t\tpm_runtime_resume(dev);\n\n\treturn 0;\n}\n\nint intel_lpss_prepare(struct device *dev)\n{\n\t \n\tdevice_for_each_child_reverse(dev, NULL, resume_lpss_device);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(intel_lpss_prepare);\n\nint intel_lpss_suspend(struct device *dev)\n{\n\tstruct intel_lpss *lpss = dev_get_drvdata(dev);\n\tunsigned int i;\n\n\t \n\tfor (i = 0; i < LPSS_PRIV_REG_COUNT; i++)\n\t\tlpss->priv_ctx[i] = readl(lpss->priv + i * 4);\n\n\t \n\tif (lpss->type != LPSS_DEV_UART)\n\t\twritel(0, lpss->priv + LPSS_PRIV_RESETS);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(intel_lpss_suspend);\n\nint intel_lpss_resume(struct device *dev)\n{\n\tstruct intel_lpss *lpss = dev_get_drvdata(dev);\n\tunsigned int i;\n\n\tintel_lpss_deassert_reset(lpss);\n\n\t \n\tfor (i = 0; i < LPSS_PRIV_REG_COUNT; i++)\n\t\twritel(lpss->priv_ctx[i], lpss->priv + i * 4);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(intel_lpss_resume);\n#endif\n\nstatic int __init intel_lpss_init(void)\n{\n\tintel_lpss_debugfs = debugfs_create_dir(\"intel_lpss\", NULL);\n\treturn 0;\n}\nmodule_init(intel_lpss_init);\n\nstatic void __exit intel_lpss_exit(void)\n{\n\tida_destroy(&intel_lpss_devid_ida);\n\tdebugfs_remove(intel_lpss_debugfs);\n}\nmodule_exit(intel_lpss_exit);\n\nMODULE_AUTHOR(\"Andy Shevchenko <andriy.shevchenko@linux.intel.com>\");\nMODULE_AUTHOR(\"Mika Westerberg <mika.westerberg@linux.intel.com>\");\nMODULE_AUTHOR(\"Heikki Krogerus <heikki.krogerus@linux.intel.com>\");\nMODULE_AUTHOR(\"Jarkko Nikula <jarkko.nikula@linux.intel.com>\");\nMODULE_DESCRIPTION(\"Intel LPSS core driver\");\nMODULE_LICENSE(\"GPL v2\");\n \nMODULE_SOFTDEP(\"pre: platform:\" LPSS_IDMA64_DRIVER_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}