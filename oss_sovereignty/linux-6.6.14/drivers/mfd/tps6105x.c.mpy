{
  "module_name": "tps6105x.c",
  "hash_id": "145381e3d5083691f9b4b0a72ac743ee3c20a098a3f1c97968a5575e798a9a18",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/tps6105x.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n#include <linux/gpio.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/tps6105x.h>\n\nstatic struct regmap_config tps6105x_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = TPS6105X_REG_3,\n};\n\nstatic int tps6105x_startup(struct tps6105x *tps6105x)\n{\n\tint ret;\n\tunsigned int regval;\n\n\tret = regmap_read(tps6105x->regmap, TPS6105X_REG_0, &regval);\n\tif (ret)\n\t\treturn ret;\n\tswitch (regval >> TPS6105X_REG0_MODE_SHIFT) {\n\tcase TPS6105X_REG0_MODE_SHUTDOWN:\n\t\tdev_info(&tps6105x->client->dev,\n\t\t\t \"TPS6105x found in SHUTDOWN mode\\n\");\n\t\tbreak;\n\tcase TPS6105X_REG0_MODE_TORCH:\n\t\tdev_info(&tps6105x->client->dev,\n\t\t\t \"TPS6105x found in TORCH mode\\n\");\n\t\tbreak;\n\tcase TPS6105X_REG0_MODE_TORCH_FLASH:\n\t\tdev_info(&tps6105x->client->dev,\n\t\t\t \"TPS6105x found in FLASH mode\\n\");\n\t\tbreak;\n\tcase TPS6105X_REG0_MODE_VOLTAGE:\n\t\tdev_info(&tps6105x->client->dev,\n\t\t\t \"TPS6105x found in VOLTAGE mode\\n\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n \nstatic struct mfd_cell tps6105x_gpio_cell = {\n\t.name = \"tps6105x-gpio\",\n};\n\nstatic struct mfd_cell tps6105x_leds_cell = {\n\t.name = \"tps6105x-leds\",\n};\n\nstatic struct mfd_cell tps6105x_flash_cell = {\n\t.name = \"tps6105x-flash\",\n};\n\nstatic struct mfd_cell tps6105x_regulator_cell = {\n\t.name = \"tps6105x-regulator\",\n};\n\nstatic int tps6105x_add_device(struct tps6105x *tps6105x,\n\t\t\t       struct mfd_cell *cell)\n{\n\tcell->platform_data = tps6105x;\n\tcell->pdata_size = sizeof(*tps6105x);\n\n\treturn mfd_add_devices(&tps6105x->client->dev,\n\t\t\t       PLATFORM_DEVID_AUTO, cell, 1, NULL, 0, NULL);\n}\n\nstatic struct tps6105x_platform_data *tps6105x_parse_dt(struct device *dev)\n{\n\tstruct device_node *np = dev->of_node;\n\tstruct tps6105x_platform_data *pdata;\n\tstruct device_node *child;\n\n\tif (!np)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (of_get_available_child_count(np) > 1) {\n\t\tdev_err(dev, \"cannot support multiple operational modes\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tpdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn ERR_PTR(-ENOMEM);\n\tpdata->mode = TPS6105X_MODE_SHUTDOWN;\n\tfor_each_available_child_of_node(np, child) {\n\t\tif (child->name && !of_node_cmp(child->name, \"regulator\"))\n\t\t\tpdata->mode = TPS6105X_MODE_VOLTAGE;\n\t\telse if (child->name && !of_node_cmp(child->name, \"led\"))\n\t\t\tpdata->mode = TPS6105X_MODE_TORCH;\n\t}\n\n\treturn pdata;\n}\n\nstatic int tps6105x_probe(struct i2c_client *client)\n{\n\tstruct tps6105x\t\t\t*tps6105x;\n\tstruct tps6105x_platform_data\t*pdata;\n\tint ret;\n\n\tpdata = dev_get_platdata(&client->dev);\n\tif (!pdata)\n\t\tpdata = tps6105x_parse_dt(&client->dev);\n\tif (IS_ERR(pdata)) {\n\t\tdev_err(&client->dev, \"No platform data or DT found\");\n\t\treturn PTR_ERR(pdata);\n\t}\n\n\ttps6105x = devm_kmalloc(&client->dev, sizeof(*tps6105x), GFP_KERNEL);\n\tif (!tps6105x)\n\t\treturn -ENOMEM;\n\n\ttps6105x->regmap = devm_regmap_init_i2c(client, &tps6105x_regmap_config);\n\tif (IS_ERR(tps6105x->regmap))\n\t\treturn PTR_ERR(tps6105x->regmap);\n\n\ti2c_set_clientdata(client, tps6105x);\n\ttps6105x->client = client;\n\ttps6105x->pdata = pdata;\n\n\tret = tps6105x_startup(tps6105x);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"chip initialization failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = tps6105x_add_device(tps6105x, &tps6105x_gpio_cell);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (pdata->mode) {\n\tcase TPS6105X_MODE_SHUTDOWN:\n\t\tdev_info(&client->dev,\n\t\t\t \"present, not used for anything, only GPIO\\n\");\n\t\tbreak;\n\tcase TPS6105X_MODE_TORCH:\n\t\tret = tps6105x_add_device(tps6105x, &tps6105x_leds_cell);\n\t\tbreak;\n\tcase TPS6105X_MODE_TORCH_FLASH:\n\t\tret = tps6105x_add_device(tps6105x, &tps6105x_flash_cell);\n\t\tbreak;\n\tcase TPS6105X_MODE_VOLTAGE:\n\t\tret = tps6105x_add_device(tps6105x, &tps6105x_regulator_cell);\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&client->dev, \"invalid mode: %d\\n\", pdata->mode);\n\t\tbreak;\n\t}\n\n\tif (ret)\n\t\tmfd_remove_devices(&client->dev);\n\n\treturn ret;\n}\n\nstatic void tps6105x_remove(struct i2c_client *client)\n{\n\tstruct tps6105x *tps6105x = i2c_get_clientdata(client);\n\n\tmfd_remove_devices(&client->dev);\n\n\t \n\tregmap_update_bits(tps6105x->regmap, TPS6105X_REG_0,\n\t\tTPS6105X_REG0_MODE_MASK,\n\t\tTPS6105X_MODE_SHUTDOWN << TPS6105X_REG0_MODE_SHIFT);\n}\n\nstatic const struct i2c_device_id tps6105x_id[] = {\n\t{ \"tps61050\", 0 },\n\t{ \"tps61052\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, tps6105x_id);\n\nstatic const struct of_device_id tps6105x_of_match[] = {\n\t{ .compatible = \"ti,tps61050\" },\n\t{ .compatible = \"ti,tps61052\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, tps6105x_of_match);\n\nstatic struct i2c_driver tps6105x_driver = {\n\t.driver = {\n\t\t.name\t= \"tps6105x\",\n\t\t.of_match_table = tps6105x_of_match,\n\t},\n\t.probe\t\t= tps6105x_probe,\n\t.remove\t\t= tps6105x_remove,\n\t.id_table\t= tps6105x_id,\n};\n\nstatic int __init tps6105x_init(void)\n{\n\treturn i2c_add_driver(&tps6105x_driver);\n}\nsubsys_initcall(tps6105x_init);\n\nstatic void __exit tps6105x_exit(void)\n{\n\ti2c_del_driver(&tps6105x_driver);\n}\nmodule_exit(tps6105x_exit);\n\nMODULE_AUTHOR(\"Linus Walleij\");\nMODULE_DESCRIPTION(\"TPS6105x White LED Boost Converter Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}