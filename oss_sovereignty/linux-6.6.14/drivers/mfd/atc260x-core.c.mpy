{
  "module_name": "atc260x-core.c",
  "hash_id": "b24372a9e250aa998b1c5d04e714c7dc2226c43d7bc1ad764c1c6b6dab54370a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/atc260x-core.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/mfd/atc260x/core.h>\n#include <linux/mfd/core.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n\n#define ATC260X_CHIP_REV_MAX\t31\n\nstruct atc260x_init_regs {\n\tunsigned int cmu_devrst;\n\tunsigned int cmu_devrst_ints;\n\tunsigned int ints_msk;\n\tunsigned int pad_en;\n\tunsigned int pad_en_extirq;\n};\n\nstatic void regmap_lock_mutex(void *__mutex)\n{\n\tstruct mutex *mutex = __mutex;\n\n\t \n\tif (system_state > SYSTEM_RUNNING && irqs_disabled())\n\t\tmutex_trylock(mutex);\n\telse\n\t\tmutex_lock(mutex);\n}\n\nstatic void regmap_unlock_mutex(void *__mutex)\n{\n\tstruct mutex *mutex = __mutex;\n\n\tmutex_unlock(mutex);\n}\n\nstatic const struct regmap_config atc2603c_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 16,\n\t.max_register = ATC2603C_SADDR,\n\t.cache_type = REGCACHE_NONE,\n};\n\nstatic const struct regmap_config atc2609a_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 16,\n\t.max_register = ATC2609A_SADDR,\n\t.cache_type = REGCACHE_NONE,\n};\n\nstatic const struct regmap_irq atc2603c_regmap_irqs[] = {\n\tREGMAP_IRQ_REG(ATC2603C_IRQ_AUDIO,\t0, ATC2603C_INTS_MSK_AUDIO),\n\tREGMAP_IRQ_REG(ATC2603C_IRQ_OV,\t\t0, ATC2603C_INTS_MSK_OV),\n\tREGMAP_IRQ_REG(ATC2603C_IRQ_OC,\t\t0, ATC2603C_INTS_MSK_OC),\n\tREGMAP_IRQ_REG(ATC2603C_IRQ_OT,\t\t0, ATC2603C_INTS_MSK_OT),\n\tREGMAP_IRQ_REG(ATC2603C_IRQ_UV,\t\t0, ATC2603C_INTS_MSK_UV),\n\tREGMAP_IRQ_REG(ATC2603C_IRQ_ALARM,\t0, ATC2603C_INTS_MSK_ALARM),\n\tREGMAP_IRQ_REG(ATC2603C_IRQ_ONOFF,\t0, ATC2603C_INTS_MSK_ONOFF),\n\tREGMAP_IRQ_REG(ATC2603C_IRQ_SGPIO,\t0, ATC2603C_INTS_MSK_SGPIO),\n\tREGMAP_IRQ_REG(ATC2603C_IRQ_IR,\t\t0, ATC2603C_INTS_MSK_IR),\n\tREGMAP_IRQ_REG(ATC2603C_IRQ_REMCON,\t0, ATC2603C_INTS_MSK_REMCON),\n\tREGMAP_IRQ_REG(ATC2603C_IRQ_POWER_IN,\t0, ATC2603C_INTS_MSK_POWERIN),\n};\n\nstatic const struct regmap_irq atc2609a_regmap_irqs[] = {\n\tREGMAP_IRQ_REG(ATC2609A_IRQ_AUDIO,\t0, ATC2609A_INTS_MSK_AUDIO),\n\tREGMAP_IRQ_REG(ATC2609A_IRQ_OV,\t\t0, ATC2609A_INTS_MSK_OV),\n\tREGMAP_IRQ_REG(ATC2609A_IRQ_OC,\t\t0, ATC2609A_INTS_MSK_OC),\n\tREGMAP_IRQ_REG(ATC2609A_IRQ_OT,\t\t0, ATC2609A_INTS_MSK_OT),\n\tREGMAP_IRQ_REG(ATC2609A_IRQ_UV,\t\t0, ATC2609A_INTS_MSK_UV),\n\tREGMAP_IRQ_REG(ATC2609A_IRQ_ALARM,\t0, ATC2609A_INTS_MSK_ALARM),\n\tREGMAP_IRQ_REG(ATC2609A_IRQ_ONOFF,\t0, ATC2609A_INTS_MSK_ONOFF),\n\tREGMAP_IRQ_REG(ATC2609A_IRQ_WKUP,\t0, ATC2609A_INTS_MSK_WKUP),\n\tREGMAP_IRQ_REG(ATC2609A_IRQ_IR,\t\t0, ATC2609A_INTS_MSK_IR),\n\tREGMAP_IRQ_REG(ATC2609A_IRQ_REMCON,\t0, ATC2609A_INTS_MSK_REMCON),\n\tREGMAP_IRQ_REG(ATC2609A_IRQ_POWER_IN,\t0, ATC2609A_INTS_MSK_POWERIN),\n};\n\nstatic const struct regmap_irq_chip atc2603c_regmap_irq_chip = {\n\t.name = \"atc2603c\",\n\t.irqs = atc2603c_regmap_irqs,\n\t.num_irqs = ARRAY_SIZE(atc2603c_regmap_irqs),\n\t.num_regs = 1,\n\t.status_base = ATC2603C_INTS_PD,\n\t.unmask_base = ATC2603C_INTS_MSK,\n};\n\nstatic const struct regmap_irq_chip atc2609a_regmap_irq_chip = {\n\t.name = \"atc2609a\",\n\t.irqs = atc2609a_regmap_irqs,\n\t.num_irqs = ARRAY_SIZE(atc2609a_regmap_irqs),\n\t.num_regs = 1,\n\t.status_base = ATC2609A_INTS_PD,\n\t.unmask_base = ATC2609A_INTS_MSK,\n};\n\nstatic const struct resource atc2603c_onkey_resources[] = {\n\tDEFINE_RES_IRQ(ATC2603C_IRQ_ONOFF),\n};\n\nstatic const struct resource atc2609a_onkey_resources[] = {\n\tDEFINE_RES_IRQ(ATC2609A_IRQ_ONOFF),\n};\n\nstatic const struct mfd_cell atc2603c_mfd_cells[] = {\n\t{ .name = \"atc260x-regulator\" },\n\t{ .name = \"atc260x-pwrc\" },\n\t{\n\t\t.name = \"atc260x-onkey\",\n\t\t.num_resources = ARRAY_SIZE(atc2603c_onkey_resources),\n\t\t.resources = atc2603c_onkey_resources,\n\t},\n};\n\nstatic const struct mfd_cell atc2609a_mfd_cells[] = {\n\t{ .name = \"atc260x-regulator\" },\n\t{ .name = \"atc260x-pwrc\" },\n\t{\n\t\t.name = \"atc260x-onkey\",\n\t\t.num_resources = ARRAY_SIZE(atc2609a_onkey_resources),\n\t\t.resources = atc2609a_onkey_resources,\n\t},\n};\n\nstatic const struct atc260x_init_regs atc2603c_init_regs = {\n\t.cmu_devrst = ATC2603C_CMU_DEVRST,\n\t.cmu_devrst_ints = ATC2603C_CMU_DEVRST_INTS,\n\t.ints_msk = ATC2603C_INTS_MSK,\n\t.pad_en = ATC2603C_PAD_EN,\n\t.pad_en_extirq = ATC2603C_PAD_EN_EXTIRQ,\n};\n\nstatic const struct atc260x_init_regs atc2609a_init_regs = {\n\t.cmu_devrst = ATC2609A_CMU_DEVRST,\n\t.cmu_devrst_ints = ATC2609A_CMU_DEVRST_INTS,\n\t.ints_msk = ATC2609A_INTS_MSK,\n\t.pad_en = ATC2609A_PAD_EN,\n\t.pad_en_extirq = ATC2609A_PAD_EN_EXTIRQ,\n};\n\nstatic void atc260x_cmu_reset(struct atc260x *atc260x)\n{\n\tconst struct atc260x_init_regs *regs = atc260x->init_regs;\n\n\t \n\tregmap_update_bits(atc260x->regmap, regs->cmu_devrst,\n\t\t\t   regs->cmu_devrst_ints, ~regs->cmu_devrst_ints);\n\n\t \n\tregmap_update_bits(atc260x->regmap, regs->cmu_devrst,\n\t\t\t   regs->cmu_devrst_ints, regs->cmu_devrst_ints);\n}\n\nstatic void atc260x_dev_init(struct atc260x *atc260x)\n{\n\tconst struct atc260x_init_regs *regs = atc260x->init_regs;\n\n\t \n\tatc260x_cmu_reset(atc260x);\n\n\t \n\tregmap_write(atc260x->regmap, regs->ints_msk, 0);\n\n\t \n\tregmap_update_bits(atc260x->regmap, regs->pad_en,\n\t\t\t   regs->pad_en_extirq, regs->pad_en_extirq);\n}\n\n \nint atc260x_match_device(struct atc260x *atc260x, struct regmap_config *regmap_cfg)\n{\n\tstruct device *dev = atc260x->dev;\n\tconst void *of_data;\n\n\tof_data = of_device_get_match_data(dev);\n\tif (!of_data)\n\t\treturn -ENODEV;\n\n\tatc260x->ic_type = (unsigned long)of_data;\n\n\tswitch (atc260x->ic_type) {\n\tcase ATC2603C:\n\t\t*regmap_cfg = atc2603c_regmap_config;\n\t\tatc260x->regmap_irq_chip = &atc2603c_regmap_irq_chip;\n\t\tatc260x->cells = atc2603c_mfd_cells;\n\t\tatc260x->nr_cells = ARRAY_SIZE(atc2603c_mfd_cells);\n\t\tatc260x->type_name = \"atc2603c\";\n\t\tatc260x->rev_reg = ATC2603C_CHIP_VER;\n\t\tatc260x->init_regs = &atc2603c_init_regs;\n\t\tbreak;\n\tcase ATC2609A:\n\t\t*regmap_cfg = atc2609a_regmap_config;\n\t\tatc260x->regmap_irq_chip = &atc2609a_regmap_irq_chip;\n\t\tatc260x->cells = atc2609a_mfd_cells;\n\t\tatc260x->nr_cells = ARRAY_SIZE(atc2609a_mfd_cells);\n\t\tatc260x->type_name = \"atc2609a\";\n\t\tatc260x->rev_reg = ATC2609A_CHIP_VER;\n\t\tatc260x->init_regs = &atc2609a_init_regs;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Unsupported ATC260x device type: %u\\n\",\n\t\t\tatc260x->ic_type);\n\t\treturn -EINVAL;\n\t}\n\n\tatc260x->regmap_mutex = devm_kzalloc(dev, sizeof(*atc260x->regmap_mutex),\n\t\t\t\t\t     GFP_KERNEL);\n\tif (!atc260x->regmap_mutex)\n\t\treturn -ENOMEM;\n\n\tmutex_init(atc260x->regmap_mutex);\n\n\tregmap_cfg->lock = regmap_lock_mutex,\n\tregmap_cfg->unlock = regmap_unlock_mutex,\n\tregmap_cfg->lock_arg = atc260x->regmap_mutex;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(atc260x_match_device);\n\n \nint atc260x_device_probe(struct atc260x *atc260x)\n{\n\tstruct device *dev = atc260x->dev;\n\tunsigned int chip_rev;\n\tint ret;\n\n\tif (!atc260x->irq) {\n\t\tdev_err(dev, \"No interrupt support\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tatc260x_dev_init(atc260x);\n\n\tret = regmap_read(atc260x->regmap, atc260x->rev_reg, &chip_rev);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to get chip revision\\n\");\n\t\treturn ret;\n\t}\n\n\tif (chip_rev > ATC260X_CHIP_REV_MAX) {\n\t\tdev_err(dev, \"Unknown chip revision: %u\\n\", chip_rev);\n\t\treturn -EINVAL;\n\t}\n\n\tatc260x->ic_ver = __ffs(chip_rev + 1U);\n\n\tdev_info(dev, \"Detected chip type %s rev.%c\\n\",\n\t\t atc260x->type_name, 'A' + atc260x->ic_ver);\n\n\tret = devm_regmap_add_irq_chip(dev, atc260x->regmap, atc260x->irq, IRQF_ONESHOT,\n\t\t\t\t       -1, atc260x->regmap_irq_chip, &atc260x->irq_data);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to add IRQ chip: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = devm_mfd_add_devices(dev, PLATFORM_DEVID_NONE,\n\t\t\t\t   atc260x->cells, atc260x->nr_cells, NULL, 0,\n\t\t\t\t   regmap_irq_get_domain(atc260x->irq_data));\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to add child devices: %d\\n\", ret);\n\t\tregmap_del_irq_chip(atc260x->irq, atc260x->irq_data);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(atc260x_device_probe);\n\nMODULE_DESCRIPTION(\"ATC260x PMICs Core support\");\nMODULE_AUTHOR(\"Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>\");\nMODULE_AUTHOR(\"Cristian Ciocaltea <cristian.ciocaltea@gmail.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}