{
  "module_name": "bd9571mwv.c",
  "hash_id": "0ef109311b5af0b6b7749101931cfd2dd5abd9ed12b251667f0c4228fb1ca960",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/bd9571mwv.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/rohm-generic.h>\n#include <linux/module.h>\n\n#include <linux/mfd/bd9571mwv.h>\n\nstatic const struct mfd_cell bd9571mwv_cells[] = {\n\t{ .name = \"bd9571mwv-regulator\", },\n\t{ .name = \"bd9571mwv-gpio\", },\n};\n\nstatic const struct regmap_range bd9571mwv_readable_yes_ranges[] = {\n\tregmap_reg_range(BD9571MWV_VENDOR_CODE, BD9571MWV_PRODUCT_REVISION),\n\tregmap_reg_range(BD9571MWV_BKUP_MODE_CNT, BD9571MWV_BKUP_MODE_CNT),\n\tregmap_reg_range(BD9571MWV_AVS_SET_MONI, BD9571MWV_AVS_DVFS_VID(3)),\n\tregmap_reg_range(BD9571MWV_VD18_VID, BD9571MWV_VD33_VID),\n\tregmap_reg_range(BD9571MWV_DVFS_VINIT, BD9571MWV_DVFS_VINIT),\n\tregmap_reg_range(BD9571MWV_DVFS_SETVMAX, BD9571MWV_DVFS_MONIVDAC),\n\tregmap_reg_range(BD9571MWV_GPIO_IN, BD9571MWV_GPIO_IN),\n\tregmap_reg_range(BD9571MWV_GPIO_INT, BD9571MWV_GPIO_INTMASK),\n\tregmap_reg_range(BD9571MWV_INT_INTREQ, BD9571MWV_INT_INTMASK),\n};\n\nstatic const struct regmap_access_table bd9571mwv_readable_table = {\n\t.yes_ranges\t= bd9571mwv_readable_yes_ranges,\n\t.n_yes_ranges\t= ARRAY_SIZE(bd9571mwv_readable_yes_ranges),\n};\n\nstatic const struct regmap_range bd9571mwv_writable_yes_ranges[] = {\n\tregmap_reg_range(BD9571MWV_BKUP_MODE_CNT, BD9571MWV_BKUP_MODE_CNT),\n\tregmap_reg_range(BD9571MWV_AVS_VD09_VID(0), BD9571MWV_AVS_VD09_VID(3)),\n\tregmap_reg_range(BD9571MWV_DVFS_SETVID, BD9571MWV_DVFS_SETVID),\n\tregmap_reg_range(BD9571MWV_GPIO_DIR, BD9571MWV_GPIO_OUT),\n\tregmap_reg_range(BD9571MWV_GPIO_INT_SET, BD9571MWV_GPIO_INTMASK),\n\tregmap_reg_range(BD9571MWV_INT_INTREQ, BD9571MWV_INT_INTMASK),\n};\n\nstatic const struct regmap_access_table bd9571mwv_writable_table = {\n\t.yes_ranges\t= bd9571mwv_writable_yes_ranges,\n\t.n_yes_ranges\t= ARRAY_SIZE(bd9571mwv_writable_yes_ranges),\n};\n\nstatic const struct regmap_range bd9571mwv_volatile_yes_ranges[] = {\n\tregmap_reg_range(BD9571MWV_DVFS_MONIVDAC, BD9571MWV_DVFS_MONIVDAC),\n\tregmap_reg_range(BD9571MWV_GPIO_IN, BD9571MWV_GPIO_IN),\n\tregmap_reg_range(BD9571MWV_GPIO_INT, BD9571MWV_GPIO_INT),\n\tregmap_reg_range(BD9571MWV_INT_INTREQ, BD9571MWV_INT_INTREQ),\n};\n\nstatic const struct regmap_access_table bd9571mwv_volatile_table = {\n\t.yes_ranges\t= bd9571mwv_volatile_yes_ranges,\n\t.n_yes_ranges\t= ARRAY_SIZE(bd9571mwv_volatile_yes_ranges),\n};\n\nstatic const struct regmap_config bd9571mwv_regmap_config = {\n\t.reg_bits\t= 8,\n\t.val_bits\t= 8,\n\t.cache_type\t= REGCACHE_RBTREE,\n\t.rd_table\t= &bd9571mwv_readable_table,\n\t.wr_table\t= &bd9571mwv_writable_table,\n\t.volatile_table\t= &bd9571mwv_volatile_table,\n\t.max_register\t= 0xff,\n};\n\nstatic const struct regmap_irq bd9571mwv_irqs[] = {\n\tREGMAP_IRQ_REG(BD9571MWV_IRQ_MD1, 0,\n\t\t       BD9571MWV_INT_INTREQ_MD1_INT),\n\tREGMAP_IRQ_REG(BD9571MWV_IRQ_MD2_E1, 0,\n\t\t       BD9571MWV_INT_INTREQ_MD2_E1_INT),\n\tREGMAP_IRQ_REG(BD9571MWV_IRQ_MD2_E2, 0,\n\t\t       BD9571MWV_INT_INTREQ_MD2_E2_INT),\n\tREGMAP_IRQ_REG(BD9571MWV_IRQ_PROT_ERR, 0,\n\t\t       BD9571MWV_INT_INTREQ_PROT_ERR_INT),\n\tREGMAP_IRQ_REG(BD9571MWV_IRQ_GP, 0,\n\t\t       BD9571MWV_INT_INTREQ_GP_INT),\n\tREGMAP_IRQ_REG(BD9571MWV_IRQ_128H_OF, 0,\n\t\t       BD9571MWV_INT_INTREQ_128H_OF_INT),\n\tREGMAP_IRQ_REG(BD9571MWV_IRQ_WDT_OF, 0,\n\t\t       BD9571MWV_INT_INTREQ_WDT_OF_INT),\n\tREGMAP_IRQ_REG(BD9571MWV_IRQ_BKUP_TRG, 0,\n\t\t       BD9571MWV_INT_INTREQ_BKUP_TRG_INT),\n};\n\nstatic struct regmap_irq_chip bd9571mwv_irq_chip = {\n\t.name\t\t= \"bd9571mwv\",\n\t.status_base\t= BD9571MWV_INT_INTREQ,\n\t.mask_base\t= BD9571MWV_INT_INTMASK,\n\t.ack_base\t= BD9571MWV_INT_INTREQ,\n\t.init_ack_masked = true,\n\t.num_regs\t= 1,\n\t.irqs\t\t= bd9571mwv_irqs,\n\t.num_irqs\t= ARRAY_SIZE(bd9571mwv_irqs),\n};\n\nstatic const struct mfd_cell bd9574mwf_cells[] = {\n\t{ .name = \"bd9574mwf-regulator\", },\n\t{ .name = \"bd9574mwf-gpio\", },\n};\n\nstatic const struct regmap_range bd9574mwf_readable_yes_ranges[] = {\n\tregmap_reg_range(BD9571MWV_VENDOR_CODE, BD9571MWV_PRODUCT_REVISION),\n\tregmap_reg_range(BD9571MWV_BKUP_MODE_CNT, BD9571MWV_BKUP_MODE_CNT),\n\tregmap_reg_range(BD9571MWV_DVFS_VINIT, BD9571MWV_DVFS_SETVMAX),\n\tregmap_reg_range(BD9571MWV_DVFS_SETVID, BD9571MWV_DVFS_MONIVDAC),\n\tregmap_reg_range(BD9571MWV_GPIO_IN, BD9571MWV_GPIO_IN),\n\tregmap_reg_range(BD9571MWV_GPIO_INT, BD9571MWV_GPIO_INTMASK),\n\tregmap_reg_range(BD9571MWV_INT_INTREQ, BD9571MWV_INT_INTMASK),\n};\n\nstatic const struct regmap_access_table bd9574mwf_readable_table = {\n\t.yes_ranges\t= bd9574mwf_readable_yes_ranges,\n\t.n_yes_ranges\t= ARRAY_SIZE(bd9574mwf_readable_yes_ranges),\n};\n\nstatic const struct regmap_range bd9574mwf_writable_yes_ranges[] = {\n\tregmap_reg_range(BD9571MWV_BKUP_MODE_CNT, BD9571MWV_BKUP_MODE_CNT),\n\tregmap_reg_range(BD9571MWV_DVFS_SETVID, BD9571MWV_DVFS_SETVID),\n\tregmap_reg_range(BD9571MWV_GPIO_DIR, BD9571MWV_GPIO_OUT),\n\tregmap_reg_range(BD9571MWV_GPIO_INT_SET, BD9571MWV_GPIO_INTMASK),\n\tregmap_reg_range(BD9571MWV_INT_INTREQ, BD9571MWV_INT_INTMASK),\n};\n\nstatic const struct regmap_access_table bd9574mwf_writable_table = {\n\t.yes_ranges\t= bd9574mwf_writable_yes_ranges,\n\t.n_yes_ranges\t= ARRAY_SIZE(bd9574mwf_writable_yes_ranges),\n};\n\nstatic const struct regmap_range bd9574mwf_volatile_yes_ranges[] = {\n\tregmap_reg_range(BD9571MWV_DVFS_MONIVDAC, BD9571MWV_DVFS_MONIVDAC),\n\tregmap_reg_range(BD9571MWV_GPIO_IN, BD9571MWV_GPIO_IN),\n\tregmap_reg_range(BD9571MWV_GPIO_INT, BD9571MWV_GPIO_INT),\n\tregmap_reg_range(BD9571MWV_INT_INTREQ, BD9571MWV_INT_INTREQ),\n};\n\nstatic const struct regmap_access_table bd9574mwf_volatile_table = {\n\t.yes_ranges\t= bd9574mwf_volatile_yes_ranges,\n\t.n_yes_ranges\t= ARRAY_SIZE(bd9574mwf_volatile_yes_ranges),\n};\n\nstatic const struct regmap_config bd9574mwf_regmap_config = {\n\t.reg_bits\t= 8,\n\t.val_bits\t= 8,\n\t.cache_type\t= REGCACHE_RBTREE,\n\t.rd_table\t= &bd9574mwf_readable_table,\n\t.wr_table\t= &bd9574mwf_writable_table,\n\t.volatile_table\t= &bd9574mwf_volatile_table,\n\t.max_register\t= 0xff,\n};\n\nstatic struct regmap_irq_chip bd9574mwf_irq_chip = {\n\t.name\t\t= \"bd9574mwf\",\n\t.status_base\t= BD9571MWV_INT_INTREQ,\n\t.mask_base\t= BD9571MWV_INT_INTMASK,\n\t.ack_base\t= BD9571MWV_INT_INTREQ,\n\t.init_ack_masked = true,\n\t.num_regs\t= 1,\n\t.irqs\t\t= bd9571mwv_irqs,\n\t.num_irqs\t= ARRAY_SIZE(bd9571mwv_irqs),\n};\n\nstatic int bd957x_identify(struct device *dev, struct regmap *regmap)\n{\n\tunsigned int value;\n\tint ret;\n\n\tret = regmap_read(regmap, BD9571MWV_VENDOR_CODE, &value);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to read vendor code register (ret=%i)\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tif (value != BD9571MWV_VENDOR_CODE_VAL) {\n\t\tdev_err(dev, \"Invalid vendor code ID %02x (expected %02x)\\n\",\n\t\t\tvalue, BD9571MWV_VENDOR_CODE_VAL);\n\t\treturn -EINVAL;\n\t}\n\n\tret = regmap_read(regmap, BD9571MWV_PRODUCT_CODE, &value);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to read product code register (ret=%i)\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\tret = regmap_read(regmap, BD9571MWV_PRODUCT_REVISION, &value);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to read revision register (ret=%i)\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int bd9571mwv_probe(struct i2c_client *client)\n{\n\tconst struct regmap_config *regmap_config;\n\tconst struct regmap_irq_chip *irq_chip;\n\tconst struct mfd_cell *cells;\n\tstruct device *dev = &client->dev;\n\tstruct regmap *regmap;\n\tstruct regmap_irq_chip_data *irq_data;\n\tint ret, num_cells, irq = client->irq;\n\n\t \n\tret = i2c_smbus_read_byte_data(client, BD9571MWV_PRODUCT_CODE);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to read product code\\n\");\n\t\treturn ret;\n\t}\n\n\tswitch (ret) {\n\tcase BD9571MWV_PRODUCT_CODE_BD9571MWV:\n\t\tregmap_config = &bd9571mwv_regmap_config;\n\t\tirq_chip = &bd9571mwv_irq_chip;\n\t\tcells = bd9571mwv_cells;\n\t\tnum_cells = ARRAY_SIZE(bd9571mwv_cells);\n\t\tbreak;\n\tcase BD9571MWV_PRODUCT_CODE_BD9574MWF:\n\t\tregmap_config = &bd9574mwf_regmap_config;\n\t\tirq_chip = &bd9574mwf_irq_chip;\n\t\tcells = bd9574mwf_cells;\n\t\tnum_cells = ARRAY_SIZE(bd9574mwf_cells);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Unsupported device 0x%x\\n\", ret);\n\t\treturn -ENODEV;\n\t}\n\n\tregmap = devm_regmap_init_i2c(client, regmap_config);\n\tif (IS_ERR(regmap)) {\n\t\tdev_err(dev, \"Failed to initialize register map\\n\");\n\t\treturn PTR_ERR(regmap);\n\t}\n\n\tret = bd957x_identify(dev, regmap);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_regmap_add_irq_chip(dev, regmap, irq, IRQF_ONESHOT, 0,\n\t\t\t\t       irq_chip, &irq_data);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to register IRQ chip\\n\");\n\t\treturn ret;\n\t}\n\n\treturn devm_mfd_add_devices(dev, PLATFORM_DEVID_AUTO, cells, num_cells,\n\t\t\t\t    NULL, 0, regmap_irq_get_domain(irq_data));\n}\n\nstatic const struct of_device_id bd9571mwv_of_match_table[] = {\n\t{ .compatible = \"rohm,bd9571mwv\", },\n\t{ .compatible = \"rohm,bd9574mwf\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, bd9571mwv_of_match_table);\n\nstatic const struct i2c_device_id bd9571mwv_id_table[] = {\n\t{ \"bd9571mwv\", 0 },\n\t{   }\n};\nMODULE_DEVICE_TABLE(i2c, bd9571mwv_id_table);\n\nstatic struct i2c_driver bd9571mwv_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"bd9571mwv\",\n\t\t.of_match_table = bd9571mwv_of_match_table,\n\t},\n\t.probe\t\t= bd9571mwv_probe,\n\t.id_table       = bd9571mwv_id_table,\n};\nmodule_i2c_driver(bd9571mwv_driver);\n\nMODULE_AUTHOR(\"Marek Vasut <marek.vasut+renesas@gmail.com>\");\nMODULE_DESCRIPTION(\"BD9571MWV PMIC Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}