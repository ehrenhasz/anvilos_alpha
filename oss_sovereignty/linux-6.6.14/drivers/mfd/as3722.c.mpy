{
  "module_name": "as3722.c",
  "hash_id": "d674bea0d70fe1a17c01b47cb6d3af8cc7e8892f87bdaeca86e2b6d0aec910c0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/as3722.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/as3722.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n#define AS3722_DEVICE_ID\t0x0C\n\nstatic const struct resource as3722_rtc_resource[] = {\n\tDEFINE_RES_IRQ_NAMED(AS3722_IRQ_RTC_ALARM, \"as3722-rtc-alarm\"),\n};\n\nstatic const struct resource as3722_adc_resource[] = {\n\tDEFINE_RES_IRQ_NAMED(AS3722_IRQ_ADC, \"as3722-adc\"),\n};\n\nstatic const struct mfd_cell as3722_devs[] = {\n\t{\n\t\t.name = \"as3722-pinctrl\",\n\t},\n\t{\n\t\t.name = \"as3722-regulator\",\n\t},\n\t{\n\t\t.name = \"as3722-rtc\",\n\t\t.num_resources = ARRAY_SIZE(as3722_rtc_resource),\n\t\t.resources = as3722_rtc_resource,\n\t},\n\t{\n\t\t.name = \"as3722-adc\",\n\t\t.num_resources = ARRAY_SIZE(as3722_adc_resource),\n\t\t.resources = as3722_adc_resource,\n\t},\n\t{\n\t\t.name = \"as3722-power-off\",\n\t},\n\t{\n\t\t.name = \"as3722-wdt\",\n\t},\n};\n\nstatic const struct regmap_irq as3722_irqs[] = {\n\t \n\t[AS3722_IRQ_LID] = {\n\t\t.mask = AS3722_INTERRUPT_MASK1_LID,\n\t},\n\t[AS3722_IRQ_ACOK] = {\n\t\t.mask = AS3722_INTERRUPT_MASK1_ACOK,\n\t},\n\t[AS3722_IRQ_ENABLE1] = {\n\t\t.mask = AS3722_INTERRUPT_MASK1_ENABLE1,\n\t},\n\t[AS3722_IRQ_OCCUR_ALARM_SD0] = {\n\t\t.mask = AS3722_INTERRUPT_MASK1_OCURR_ALARM_SD0,\n\t},\n\t[AS3722_IRQ_ONKEY_LONG_PRESS] = {\n\t\t.mask = AS3722_INTERRUPT_MASK1_ONKEY_LONG,\n\t},\n\t[AS3722_IRQ_ONKEY] = {\n\t\t.mask = AS3722_INTERRUPT_MASK1_ONKEY,\n\t},\n\t[AS3722_IRQ_OVTMP] = {\n\t\t.mask = AS3722_INTERRUPT_MASK1_OVTMP,\n\t},\n\t[AS3722_IRQ_LOWBAT] = {\n\t\t.mask = AS3722_INTERRUPT_MASK1_LOWBAT,\n\t},\n\n\t \n\t[AS3722_IRQ_SD0_LV] = {\n\t\t.mask = AS3722_INTERRUPT_MASK2_SD0_LV,\n\t\t.reg_offset = 1,\n\t},\n\t[AS3722_IRQ_SD1_LV] = {\n\t\t.mask = AS3722_INTERRUPT_MASK2_SD1_LV,\n\t\t.reg_offset = 1,\n\t},\n\t[AS3722_IRQ_SD2_LV] = {\n\t\t.mask = AS3722_INTERRUPT_MASK2_SD2345_LV,\n\t\t.reg_offset = 1,\n\t},\n\t[AS3722_IRQ_PWM1_OV_PROT] = {\n\t\t.mask = AS3722_INTERRUPT_MASK2_PWM1_OV_PROT,\n\t\t.reg_offset = 1,\n\t},\n\t[AS3722_IRQ_PWM2_OV_PROT] = {\n\t\t.mask = AS3722_INTERRUPT_MASK2_PWM2_OV_PROT,\n\t\t.reg_offset = 1,\n\t},\n\t[AS3722_IRQ_ENABLE2] = {\n\t\t.mask = AS3722_INTERRUPT_MASK2_ENABLE2,\n\t\t.reg_offset = 1,\n\t},\n\t[AS3722_IRQ_SD6_LV] = {\n\t\t.mask = AS3722_INTERRUPT_MASK2_SD6_LV,\n\t\t.reg_offset = 1,\n\t},\n\t[AS3722_IRQ_RTC_REP] = {\n\t\t.mask = AS3722_INTERRUPT_MASK2_RTC_REP,\n\t\t.reg_offset = 1,\n\t},\n\n\t \n\t[AS3722_IRQ_RTC_ALARM] = {\n\t\t.mask = AS3722_INTERRUPT_MASK3_RTC_ALARM,\n\t\t.reg_offset = 2,\n\t},\n\t[AS3722_IRQ_GPIO1] = {\n\t\t.mask = AS3722_INTERRUPT_MASK3_GPIO1,\n\t\t.reg_offset = 2,\n\t},\n\t[AS3722_IRQ_GPIO2] = {\n\t\t.mask = AS3722_INTERRUPT_MASK3_GPIO2,\n\t\t.reg_offset = 2,\n\t},\n\t[AS3722_IRQ_GPIO3] = {\n\t\t.mask = AS3722_INTERRUPT_MASK3_GPIO3,\n\t\t.reg_offset = 2,\n\t},\n\t[AS3722_IRQ_GPIO4] = {\n\t\t.mask = AS3722_INTERRUPT_MASK3_GPIO4,\n\t\t.reg_offset = 2,\n\t},\n\t[AS3722_IRQ_GPIO5] = {\n\t\t.mask = AS3722_INTERRUPT_MASK3_GPIO5,\n\t\t.reg_offset = 2,\n\t},\n\t[AS3722_IRQ_WATCHDOG] = {\n\t\t.mask = AS3722_INTERRUPT_MASK3_WATCHDOG,\n\t\t.reg_offset = 2,\n\t},\n\t[AS3722_IRQ_ENABLE3] = {\n\t\t.mask = AS3722_INTERRUPT_MASK3_ENABLE3,\n\t\t.reg_offset = 2,\n\t},\n\n\t \n\t[AS3722_IRQ_TEMP_SD0_SHUTDOWN] = {\n\t\t.mask = AS3722_INTERRUPT_MASK4_TEMP_SD0_SHUTDOWN,\n\t\t.reg_offset = 3,\n\t},\n\t[AS3722_IRQ_TEMP_SD1_SHUTDOWN] = {\n\t\t.mask = AS3722_INTERRUPT_MASK4_TEMP_SD1_SHUTDOWN,\n\t\t.reg_offset = 3,\n\t},\n\t[AS3722_IRQ_TEMP_SD2_SHUTDOWN] = {\n\t\t.mask = AS3722_INTERRUPT_MASK4_TEMP_SD6_SHUTDOWN,\n\t\t.reg_offset = 3,\n\t},\n\t[AS3722_IRQ_TEMP_SD0_ALARM] = {\n\t\t.mask = AS3722_INTERRUPT_MASK4_TEMP_SD0_ALARM,\n\t\t.reg_offset = 3,\n\t},\n\t[AS3722_IRQ_TEMP_SD1_ALARM] = {\n\t\t.mask = AS3722_INTERRUPT_MASK4_TEMP_SD1_ALARM,\n\t\t.reg_offset = 3,\n\t},\n\t[AS3722_IRQ_TEMP_SD6_ALARM] = {\n\t\t.mask = AS3722_INTERRUPT_MASK4_TEMP_SD6_ALARM,\n\t\t.reg_offset = 3,\n\t},\n\t[AS3722_IRQ_OCCUR_ALARM_SD6] = {\n\t\t.mask = AS3722_INTERRUPT_MASK4_OCCUR_ALARM_SD6,\n\t\t.reg_offset = 3,\n\t},\n\t[AS3722_IRQ_ADC] = {\n\t\t.mask = AS3722_INTERRUPT_MASK4_ADC,\n\t\t.reg_offset = 3,\n\t},\n};\n\nstatic const struct regmap_irq_chip as3722_irq_chip = {\n\t.name = \"as3722\",\n\t.irqs = as3722_irqs,\n\t.num_irqs = ARRAY_SIZE(as3722_irqs),\n\t.num_regs = 4,\n\t.status_base = AS3722_INTERRUPT_STATUS1_REG,\n\t.mask_base = AS3722_INTERRUPT_MASK1_REG,\n};\n\nstatic int as3722_check_device_id(struct as3722 *as3722)\n{\n\tu32 val;\n\tint ret;\n\n\t \n\tret = as3722_read(as3722, AS3722_ASIC_ID1_REG, &val);\n\tif (ret < 0) {\n\t\tdev_err(as3722->dev, \"ASIC_ID1 read failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (val != AS3722_DEVICE_ID) {\n\t\tdev_err(as3722->dev, \"Device is not AS3722, ID is 0x%x\\n\", val);\n\t\treturn -ENODEV;\n\t}\n\n\tret = as3722_read(as3722, AS3722_ASIC_ID2_REG, &val);\n\tif (ret < 0) {\n\t\tdev_err(as3722->dev, \"ASIC_ID2 read failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdev_info(as3722->dev, \"AS3722 with revision 0x%x found\\n\", val);\n\treturn 0;\n}\n\nstatic int as3722_configure_pullups(struct as3722 *as3722)\n{\n\tint ret;\n\tu32 val = 0;\n\n\tif (as3722->en_intern_int_pullup)\n\t\tval |= AS3722_INT_PULL_UP;\n\tif (as3722->en_intern_i2c_pullup)\n\t\tval |= AS3722_I2C_PULL_UP;\n\n\tret = as3722_update_bits(as3722, AS3722_IOVOLTAGE_REG,\n\t\t\tAS3722_INT_PULL_UP | AS3722_I2C_PULL_UP, val);\n\tif (ret < 0)\n\t\tdev_err(as3722->dev, \"IOVOLTAGE_REG update failed: %d\\n\", ret);\n\treturn ret;\n}\n\nstatic const struct regmap_range as3722_readable_ranges[] = {\n\tregmap_reg_range(AS3722_SD0_VOLTAGE_REG, AS3722_SD6_VOLTAGE_REG),\n\tregmap_reg_range(AS3722_GPIO0_CONTROL_REG, AS3722_LDO7_VOLTAGE_REG),\n\tregmap_reg_range(AS3722_LDO9_VOLTAGE_REG, AS3722_REG_SEQU_MOD3_REG),\n\tregmap_reg_range(AS3722_SD_PHSW_CTRL_REG, AS3722_PWM_CONTROL_H_REG),\n\tregmap_reg_range(AS3722_WATCHDOG_TIMER_REG, AS3722_WATCHDOG_TIMER_REG),\n\tregmap_reg_range(AS3722_WATCHDOG_SOFTWARE_SIGNAL_REG,\n\t\t\t\t\tAS3722_BATTERY_VOLTAGE_MONITOR2_REG),\n\tregmap_reg_range(AS3722_SD_CONTROL_REG, AS3722_PWM_VCONTROL4_REG),\n\tregmap_reg_range(AS3722_BB_CHARGER_REG, AS3722_SRAM_REG),\n\tregmap_reg_range(AS3722_RTC_ACCESS_REG, AS3722_RTC_ACCESS_REG),\n\tregmap_reg_range(AS3722_RTC_STATUS_REG, AS3722_TEMP_STATUS_REG),\n\tregmap_reg_range(AS3722_ADC0_CONTROL_REG, AS3722_ADC_CONFIGURATION_REG),\n\tregmap_reg_range(AS3722_ASIC_ID1_REG, AS3722_ASIC_ID2_REG),\n\tregmap_reg_range(AS3722_LOCK_REG, AS3722_LOCK_REG),\n\tregmap_reg_range(AS3722_FUSE7_REG, AS3722_FUSE7_REG),\n};\n\nstatic const struct regmap_access_table as3722_readable_table = {\n\t.yes_ranges = as3722_readable_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(as3722_readable_ranges),\n};\n\nstatic const struct regmap_range as3722_writable_ranges[] = {\n\tregmap_reg_range(AS3722_SD0_VOLTAGE_REG, AS3722_SD6_VOLTAGE_REG),\n\tregmap_reg_range(AS3722_GPIO0_CONTROL_REG, AS3722_LDO7_VOLTAGE_REG),\n\tregmap_reg_range(AS3722_LDO9_VOLTAGE_REG, AS3722_GPIO_SIGNAL_OUT_REG),\n\tregmap_reg_range(AS3722_REG_SEQU_MOD1_REG, AS3722_REG_SEQU_MOD3_REG),\n\tregmap_reg_range(AS3722_SD_PHSW_CTRL_REG, AS3722_PWM_CONTROL_H_REG),\n\tregmap_reg_range(AS3722_WATCHDOG_TIMER_REG, AS3722_WATCHDOG_TIMER_REG),\n\tregmap_reg_range(AS3722_WATCHDOG_SOFTWARE_SIGNAL_REG,\n\t\t\t\t\tAS3722_BATTERY_VOLTAGE_MONITOR2_REG),\n\tregmap_reg_range(AS3722_SD_CONTROL_REG, AS3722_PWM_VCONTROL4_REG),\n\tregmap_reg_range(AS3722_BB_CHARGER_REG, AS3722_SRAM_REG),\n\tregmap_reg_range(AS3722_INTERRUPT_MASK1_REG, AS3722_TEMP_STATUS_REG),\n\tregmap_reg_range(AS3722_ADC0_CONTROL_REG, AS3722_ADC1_CONTROL_REG),\n\tregmap_reg_range(AS3722_ADC1_THRESHOLD_HI_MSB_REG,\n\t\t\t\t\tAS3722_ADC_CONFIGURATION_REG),\n\tregmap_reg_range(AS3722_LOCK_REG, AS3722_LOCK_REG),\n};\n\nstatic const struct regmap_access_table as3722_writable_table = {\n\t.yes_ranges = as3722_writable_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(as3722_writable_ranges),\n};\n\nstatic const struct regmap_range as3722_cacheable_ranges[] = {\n\tregmap_reg_range(AS3722_SD0_VOLTAGE_REG, AS3722_LDO11_VOLTAGE_REG),\n\tregmap_reg_range(AS3722_SD_CONTROL_REG, AS3722_LDOCONTROL1_REG),\n};\n\nstatic const struct regmap_access_table as3722_volatile_table = {\n\t.no_ranges = as3722_cacheable_ranges,\n\t.n_no_ranges = ARRAY_SIZE(as3722_cacheable_ranges),\n};\n\nstatic const struct regmap_config as3722_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = AS3722_MAX_REGISTER,\n\t.cache_type = REGCACHE_RBTREE,\n\t.rd_table = &as3722_readable_table,\n\t.wr_table = &as3722_writable_table,\n\t.volatile_table = &as3722_volatile_table,\n};\n\nstatic int as3722_i2c_of_probe(struct i2c_client *i2c,\n\t\t\tstruct as3722 *as3722)\n{\n\tstruct device_node *np = i2c->dev.of_node;\n\tstruct irq_data *irq_data;\n\n\tif (!np) {\n\t\tdev_err(&i2c->dev, \"Device Tree not found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tirq_data = irq_get_irq_data(i2c->irq);\n\tif (!irq_data) {\n\t\tdev_err(&i2c->dev, \"Invalid IRQ: %d\\n\", i2c->irq);\n\t\treturn -EINVAL;\n\t}\n\n\tas3722->en_intern_int_pullup = of_property_read_bool(np,\n\t\t\t\t\t\"ams,enable-internal-int-pullup\");\n\tas3722->en_intern_i2c_pullup = of_property_read_bool(np,\n\t\t\t\t\t\"ams,enable-internal-i2c-pullup\");\n\tas3722->en_ac_ok_pwr_on = of_property_read_bool(np,\n\t\t\t\t\t\"ams,enable-ac-ok-power-on\");\n\tas3722->irq_flags = irqd_get_trigger_type(irq_data);\n\tdev_dbg(&i2c->dev, \"IRQ flags are 0x%08lx\\n\", as3722->irq_flags);\n\treturn 0;\n}\n\nstatic int as3722_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct as3722 *as3722;\n\tunsigned long irq_flags;\n\tint ret;\n\tu8 val = 0;\n\n\tas3722 = devm_kzalloc(&i2c->dev, sizeof(struct as3722), GFP_KERNEL);\n\tif (!as3722)\n\t\treturn -ENOMEM;\n\n\tas3722->dev = &i2c->dev;\n\tas3722->chip_irq = i2c->irq;\n\ti2c_set_clientdata(i2c, as3722);\n\n\tret = as3722_i2c_of_probe(i2c, as3722);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tas3722->regmap = devm_regmap_init_i2c(i2c, &as3722_regmap_config);\n\tif (IS_ERR(as3722->regmap)) {\n\t\tret = PTR_ERR(as3722->regmap);\n\t\tdev_err(&i2c->dev, \"regmap init failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = as3722_check_device_id(as3722);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tirq_flags = as3722->irq_flags | IRQF_ONESHOT;\n\tret = devm_regmap_add_irq_chip(as3722->dev, as3722->regmap,\n\t\t\t\t       as3722->chip_irq,\n\t\t\t\t       irq_flags, -1, &as3722_irq_chip,\n\t\t\t\t       &as3722->irq_data);\n\tif (ret < 0) {\n\t\tdev_err(as3722->dev, \"Failed to add regmap irq: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = as3722_configure_pullups(as3722);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (as3722->en_ac_ok_pwr_on)\n\t\tval = AS3722_CTRL_SEQU1_AC_OK_PWR_ON;\n\tret = as3722_update_bits(as3722, AS3722_CTRL_SEQU1_REG,\n\t\t\tAS3722_CTRL_SEQU1_AC_OK_PWR_ON, val);\n\tif (ret < 0) {\n\t\tdev_err(as3722->dev, \"CTRLsequ1 update failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = devm_mfd_add_devices(&i2c->dev, -1, as3722_devs,\n\t\t\t\t   ARRAY_SIZE(as3722_devs), NULL, 0,\n\t\t\t\t   regmap_irq_get_domain(as3722->irq_data));\n\tif (ret) {\n\t\tdev_err(as3722->dev, \"Failed to add MFD devices: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdevice_init_wakeup(as3722->dev, true);\n\n\tdev_dbg(as3722->dev, \"AS3722 core driver initialized successfully\\n\");\n\treturn 0;\n}\n\nstatic int __maybe_unused as3722_i2c_suspend(struct device *dev)\n{\n\tstruct as3722 *as3722 = dev_get_drvdata(dev);\n\n\tif (device_may_wakeup(dev))\n\t\tenable_irq_wake(as3722->chip_irq);\n\tdisable_irq(as3722->chip_irq);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused as3722_i2c_resume(struct device *dev)\n{\n\tstruct as3722 *as3722 = dev_get_drvdata(dev);\n\n\tenable_irq(as3722->chip_irq);\n\n\tif (device_may_wakeup(dev))\n\t\tdisable_irq_wake(as3722->chip_irq);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id as3722_of_match[] = {\n\t{ .compatible = \"ams,as3722\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, as3722_of_match);\n\nstatic const struct i2c_device_id as3722_i2c_id[] = {\n\t{ \"as3722\", 0 },\n\t{},\n};\nMODULE_DEVICE_TABLE(i2c, as3722_i2c_id);\n\nstatic const struct dev_pm_ops as3722_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(as3722_i2c_suspend, as3722_i2c_resume)\n};\n\nstatic struct i2c_driver as3722_i2c_driver = {\n\t.driver = {\n\t\t.name = \"as3722\",\n\t\t.of_match_table = as3722_of_match,\n\t\t.pm = &as3722_pm_ops,\n\t},\n\t.probe = as3722_i2c_probe,\n\t.id_table = as3722_i2c_id,\n};\n\nmodule_i2c_driver(as3722_i2c_driver);\n\nMODULE_DESCRIPTION(\"I2C support for AS3722 PMICs\");\nMODULE_AUTHOR(\"Florian Lobmaier <florian.lobmaier@ams.com>\");\nMODULE_AUTHOR(\"Laxman Dewangan <ldewangan@nvidia.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}