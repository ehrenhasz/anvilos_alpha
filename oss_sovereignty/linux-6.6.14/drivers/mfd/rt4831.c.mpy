{
  "module_name": "rt4831.c",
  "hash_id": "baf43833759ea928f72aeca1f77a96b5819ef9bcbccb84c17efcbc67659914b7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/rt4831.c",
  "human_readable_source": "\n \n\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/mfd/core.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n\n#define RT4831_REG_REVISION\t0x01\n#define RT4831_REG_ENABLE\t0x08\n#define RT4831_REG_I2CPROT\t0x15\n\n#define RICHTEK_VENDOR_ID\t0x03\n#define RT4831_VID_MASK\t\tGENMASK(1, 0)\n#define RT4831_RESET_MASK\tBIT(7)\n#define RT4831_I2CSAFETMR_MASK\tBIT(0)\n\nstatic const struct mfd_cell rt4831_subdevs[] = {\n\tMFD_CELL_OF(\"rt4831-backlight\", NULL, NULL, 0, 0, \"richtek,rt4831-backlight\"),\n\tMFD_CELL_NAME(\"rt4831-regulator\")\n};\n\nstatic bool rt4831_is_accessible_reg(struct device *dev, unsigned int reg)\n{\n\tif (reg >= RT4831_REG_REVISION && reg <= RT4831_REG_I2CPROT)\n\t\treturn true;\n\treturn false;\n}\n\nstatic const struct regmap_config rt4831_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = RT4831_REG_I2CPROT,\n\n\t.readable_reg = rt4831_is_accessible_reg,\n\t.writeable_reg = rt4831_is_accessible_reg,\n};\n\nstatic int rt4831_probe(struct i2c_client *client)\n{\n\tstruct gpio_desc *enable_gpio;\n\tstruct regmap *regmap;\n\tunsigned int chip_id;\n\tint ret;\n\n\tenable_gpio = devm_gpiod_get_optional(&client->dev, \"enable\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(enable_gpio)) {\n\t\tdev_err(&client->dev, \"Failed to get 'enable' GPIO\\n\");\n\t\treturn PTR_ERR(enable_gpio);\n\t}\n\n\tregmap = devm_regmap_init_i2c(client, &rt4831_regmap_config);\n\tif (IS_ERR(regmap)) {\n\t\tdev_err(&client->dev, \"Failed to initialize regmap\\n\");\n\t\treturn PTR_ERR(regmap);\n\t}\n\n\tret = regmap_read(regmap, RT4831_REG_REVISION, &chip_id);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"Failed to get H/W revision\\n\");\n\t\treturn ret;\n\t}\n\n\tif ((chip_id & RT4831_VID_MASK) != RICHTEK_VENDOR_ID) {\n\t\tdev_err(&client->dev, \"Chip vendor ID 0x%02x not matched\\n\", chip_id);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tret = regmap_update_bits(regmap, RT4831_REG_I2CPROT, RT4831_I2CSAFETMR_MASK,\n\t\t\t\t RT4831_I2CSAFETMR_MASK);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"Failed to enable I2C safety timer\\n\");\n\t\treturn ret;\n\t}\n\n\treturn devm_mfd_add_devices(&client->dev, PLATFORM_DEVID_AUTO, rt4831_subdevs,\n\t\t\t\t    ARRAY_SIZE(rt4831_subdevs), NULL, 0, NULL);\n}\n\nstatic void rt4831_remove(struct i2c_client *client)\n{\n\tstruct regmap *regmap = dev_get_regmap(&client->dev, NULL);\n\tint ret;\n\n\t \n\tret = regmap_update_bits(regmap, RT4831_REG_ENABLE, RT4831_RESET_MASK, RT4831_RESET_MASK);\n\tif (ret)\n\t\tdev_warn(&client->dev, \"Failed to disable outputs (%pe)\\n\", ERR_PTR(ret));\n}\n\nstatic const struct of_device_id __maybe_unused rt4831_of_match[] = {\n\t{ .compatible = \"richtek,rt4831\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, rt4831_of_match);\n\nstatic struct i2c_driver rt4831_driver = {\n\t.driver = {\n\t\t.name = \"rt4831\",\n\t\t.of_match_table = rt4831_of_match,\n\t},\n\t.probe = rt4831_probe,\n\t.remove = rt4831_remove,\n};\nmodule_i2c_driver(rt4831_driver);\n\nMODULE_AUTHOR(\"ChiYuan Huang <cy_huang@richtek.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}