{
  "module_name": "stmpe-i2c.c",
  "hash_id": "d7c53ffef6349f8f4248846ddfce42bf8cab5ae058035d381a63a0ff5ee4f5fe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/stmpe-i2c.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/of_device.h>\n#include \"stmpe.h\"\n\nstatic int i2c_reg_read(struct stmpe *stmpe, u8 reg)\n{\n\tstruct i2c_client *i2c = stmpe->client;\n\n\treturn i2c_smbus_read_byte_data(i2c, reg);\n}\n\nstatic int i2c_reg_write(struct stmpe *stmpe, u8 reg, u8 val)\n{\n\tstruct i2c_client *i2c = stmpe->client;\n\n\treturn i2c_smbus_write_byte_data(i2c, reg, val);\n}\n\nstatic int i2c_block_read(struct stmpe *stmpe, u8 reg, u8 length, u8 *values)\n{\n\tstruct i2c_client *i2c = stmpe->client;\n\n\treturn i2c_smbus_read_i2c_block_data(i2c, reg, length, values);\n}\n\nstatic int i2c_block_write(struct stmpe *stmpe, u8 reg, u8 length,\n\t\tconst u8 *values)\n{\n\tstruct i2c_client *i2c = stmpe->client;\n\n\treturn i2c_smbus_write_i2c_block_data(i2c, reg, length, values);\n}\n\nstatic struct stmpe_client_info i2c_ci = {\n\t.read_byte = i2c_reg_read,\n\t.write_byte = i2c_reg_write,\n\t.read_block = i2c_block_read,\n\t.write_block = i2c_block_write,\n};\n\nstatic const struct of_device_id stmpe_of_match[] = {\n\t{ .compatible = \"st,stmpe610\", .data = (void *)STMPE610, },\n\t{ .compatible = \"st,stmpe801\", .data = (void *)STMPE801, },\n\t{ .compatible = \"st,stmpe811\", .data = (void *)STMPE811, },\n\t{ .compatible = \"st,stmpe1600\", .data = (void *)STMPE1600, },\n\t{ .compatible = \"st,stmpe1601\", .data = (void *)STMPE1601, },\n\t{ .compatible = \"st,stmpe1801\", .data = (void *)STMPE1801, },\n\t{ .compatible = \"st,stmpe2401\", .data = (void *)STMPE2401, },\n\t{ .compatible = \"st,stmpe2403\", .data = (void *)STMPE2403, },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, stmpe_of_match);\n\nstatic int\nstmpe_i2c_probe(struct i2c_client *i2c)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(i2c);\n\tenum stmpe_partnum partnum;\n\tconst struct of_device_id *of_id;\n\n\ti2c_ci.data = (void *)id;\n\ti2c_ci.irq = i2c->irq;\n\ti2c_ci.client = i2c;\n\ti2c_ci.dev = &i2c->dev;\n\n\tof_id = of_match_device(stmpe_of_match, &i2c->dev);\n\tif (!of_id) {\n\t\t \n\t\tdev_info(&i2c->dev, \"matching on node name, compatible is preferred\\n\");\n\t\tpartnum = id->driver_data;\n\t} else\n\t\tpartnum = (uintptr_t)of_id->data;\n\n\treturn stmpe_probe(&i2c_ci, partnum);\n}\n\nstatic void stmpe_i2c_remove(struct i2c_client *i2c)\n{\n\tstruct stmpe *stmpe = dev_get_drvdata(&i2c->dev);\n\n\tstmpe_remove(stmpe);\n}\n\nstatic const struct i2c_device_id stmpe_i2c_id[] = {\n\t{ \"stmpe610\", STMPE610 },\n\t{ \"stmpe801\", STMPE801 },\n\t{ \"stmpe811\", STMPE811 },\n\t{ \"stmpe1600\", STMPE1600 },\n\t{ \"stmpe1601\", STMPE1601 },\n\t{ \"stmpe1801\", STMPE1801 },\n\t{ \"stmpe2401\", STMPE2401 },\n\t{ \"stmpe2403\", STMPE2403 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, stmpe_i2c_id);\n\nstatic struct i2c_driver stmpe_i2c_driver = {\n\t.driver = {\n\t\t.name = \"stmpe-i2c\",\n\t\t.pm = pm_sleep_ptr(&stmpe_dev_pm_ops),\n\t\t.of_match_table = stmpe_of_match,\n\t},\n\t.probe\t\t= stmpe_i2c_probe,\n\t.remove\t\t= stmpe_i2c_remove,\n\t.id_table\t= stmpe_i2c_id,\n};\n\nstatic int __init stmpe_init(void)\n{\n\treturn i2c_add_driver(&stmpe_i2c_driver);\n}\nsubsys_initcall(stmpe_init);\n\nstatic void __exit stmpe_exit(void)\n{\n\ti2c_del_driver(&stmpe_i2c_driver);\n}\nmodule_exit(stmpe_exit);\n\nMODULE_DESCRIPTION(\"STMPE MFD I2C Interface Driver\");\nMODULE_AUTHOR(\"Rabin Vincent <rabin.vincent@stericsson.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}