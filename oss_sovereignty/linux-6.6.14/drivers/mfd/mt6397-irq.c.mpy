{
  "module_name": "mt6397-irq.c",
  "hash_id": "a537ee3089155a701aa07ae3733d40493ccd66550c482a7034c7aaea2ef2777b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/mt6397-irq.c",
  "human_readable_source": "\n\n\n\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/suspend.h>\n#include <linux/mfd/mt6323/core.h>\n#include <linux/mfd/mt6323/registers.h>\n#include <linux/mfd/mt6331/core.h>\n#include <linux/mfd/mt6331/registers.h>\n#include <linux/mfd/mt6397/core.h>\n#include <linux/mfd/mt6397/registers.h>\n\nstatic void mt6397_irq_lock(struct irq_data *data)\n{\n\tstruct mt6397_chip *mt6397 = irq_data_get_irq_chip_data(data);\n\n\tmutex_lock(&mt6397->irqlock);\n}\n\nstatic void mt6397_irq_sync_unlock(struct irq_data *data)\n{\n\tstruct mt6397_chip *mt6397 = irq_data_get_irq_chip_data(data);\n\n\tregmap_write(mt6397->regmap, mt6397->int_con[0],\n\t\t     mt6397->irq_masks_cur[0]);\n\tregmap_write(mt6397->regmap, mt6397->int_con[1],\n\t\t     mt6397->irq_masks_cur[1]);\n\n\tmutex_unlock(&mt6397->irqlock);\n}\n\nstatic void mt6397_irq_disable(struct irq_data *data)\n{\n\tstruct mt6397_chip *mt6397 = irq_data_get_irq_chip_data(data);\n\tint shift = data->hwirq & 0xf;\n\tint reg = data->hwirq >> 4;\n\n\tmt6397->irq_masks_cur[reg] &= ~BIT(shift);\n}\n\nstatic void mt6397_irq_enable(struct irq_data *data)\n{\n\tstruct mt6397_chip *mt6397 = irq_data_get_irq_chip_data(data);\n\tint shift = data->hwirq & 0xf;\n\tint reg = data->hwirq >> 4;\n\n\tmt6397->irq_masks_cur[reg] |= BIT(shift);\n}\n\nstatic int mt6397_irq_set_wake(struct irq_data *irq_data, unsigned int on)\n{\n\tstruct mt6397_chip *mt6397 = irq_data_get_irq_chip_data(irq_data);\n\tint shift = irq_data->hwirq & 0xf;\n\tint reg = irq_data->hwirq >> 4;\n\n\tif (on)\n\t\tmt6397->wake_mask[reg] |= BIT(shift);\n\telse\n\t\tmt6397->wake_mask[reg] &= ~BIT(shift);\n\n\treturn 0;\n}\n\nstatic struct irq_chip mt6397_irq_chip = {\n\t.name = \"mt6397-irq\",\n\t.irq_bus_lock = mt6397_irq_lock,\n\t.irq_bus_sync_unlock = mt6397_irq_sync_unlock,\n\t.irq_enable = mt6397_irq_enable,\n\t.irq_disable = mt6397_irq_disable,\n\t.irq_set_wake = pm_sleep_ptr(mt6397_irq_set_wake),\n};\n\nstatic void mt6397_irq_handle_reg(struct mt6397_chip *mt6397, int reg,\n\t\t\t\t  int irqbase)\n{\n\tunsigned int status = 0;\n\tint i, irq, ret;\n\n\tret = regmap_read(mt6397->regmap, reg, &status);\n\tif (ret) {\n\t\tdev_err(mt6397->dev, \"Failed to read irq status: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (status & BIT(i)) {\n\t\t\tirq = irq_find_mapping(mt6397->irq_domain, irqbase + i);\n\t\t\tif (irq)\n\t\t\t\thandle_nested_irq(irq);\n\t\t}\n\t}\n\n\tregmap_write(mt6397->regmap, reg, status);\n}\n\nstatic irqreturn_t mt6397_irq_thread(int irq, void *data)\n{\n\tstruct mt6397_chip *mt6397 = data;\n\n\tmt6397_irq_handle_reg(mt6397, mt6397->int_status[0], 0);\n\tmt6397_irq_handle_reg(mt6397, mt6397->int_status[1], 16);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int mt6397_irq_domain_map(struct irq_domain *d, unsigned int irq,\n\t\t\t\t irq_hw_number_t hw)\n{\n\tstruct mt6397_chip *mt6397 = d->host_data;\n\n\tirq_set_chip_data(irq, mt6397);\n\tirq_set_chip_and_handler(irq, &mt6397_irq_chip, handle_level_irq);\n\tirq_set_nested_thread(irq, 1);\n\tirq_set_noprobe(irq);\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops mt6397_irq_domain_ops = {\n\t.map = mt6397_irq_domain_map,\n};\n\nstatic int mt6397_irq_pm_notifier(struct notifier_block *notifier,\n\t\t\t\t  unsigned long pm_event, void *unused)\n{\n\tstruct mt6397_chip *chip =\n\t\tcontainer_of(notifier, struct mt6397_chip, pm_nb);\n\n\tswitch (pm_event) {\n\tcase PM_SUSPEND_PREPARE:\n\t\tregmap_write(chip->regmap,\n\t\t\t     chip->int_con[0], chip->wake_mask[0]);\n\t\tregmap_write(chip->regmap,\n\t\t\t     chip->int_con[1], chip->wake_mask[1]);\n\t\tenable_irq_wake(chip->irq);\n\t\tbreak;\n\n\tcase PM_POST_SUSPEND:\n\t\tregmap_write(chip->regmap,\n\t\t\t     chip->int_con[0], chip->irq_masks_cur[0]);\n\t\tregmap_write(chip->regmap,\n\t\t\t     chip->int_con[1], chip->irq_masks_cur[1]);\n\t\tdisable_irq_wake(chip->irq);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nint mt6397_irq_init(struct mt6397_chip *chip)\n{\n\tint ret;\n\n\tmutex_init(&chip->irqlock);\n\n\tswitch (chip->chip_id) {\n\tcase MT6323_CHIP_ID:\n\t\tchip->int_con[0] = MT6323_INT_CON0;\n\t\tchip->int_con[1] = MT6323_INT_CON1;\n\t\tchip->int_status[0] = MT6323_INT_STATUS0;\n\t\tchip->int_status[1] = MT6323_INT_STATUS1;\n\t\tbreak;\n\tcase MT6331_CHIP_ID:\n\t\tchip->int_con[0] = MT6331_INT_CON0;\n\t\tchip->int_con[1] = MT6331_INT_CON1;\n\t\tchip->int_status[0] = MT6331_INT_STATUS_CON0;\n\t\tchip->int_status[1] = MT6331_INT_STATUS_CON1;\n\t\tbreak;\n\tcase MT6391_CHIP_ID:\n\tcase MT6397_CHIP_ID:\n\t\tchip->int_con[0] = MT6397_INT_CON0;\n\t\tchip->int_con[1] = MT6397_INT_CON1;\n\t\tchip->int_status[0] = MT6397_INT_STATUS0;\n\t\tchip->int_status[1] = MT6397_INT_STATUS1;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(chip->dev, \"unsupported chip: 0x%x\\n\", chip->chip_id);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tregmap_write(chip->regmap, chip->int_con[0], 0x0);\n\tregmap_write(chip->regmap, chip->int_con[1], 0x0);\n\n\tchip->pm_nb.notifier_call = mt6397_irq_pm_notifier;\n\tchip->irq_domain = irq_domain_add_linear(chip->dev->of_node,\n\t\t\t\t\t\t MT6397_IRQ_NR,\n\t\t\t\t\t\t &mt6397_irq_domain_ops,\n\t\t\t\t\t\t chip);\n\tif (!chip->irq_domain) {\n\t\tdev_err(chip->dev, \"could not create irq domain\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = devm_request_threaded_irq(chip->dev, chip->irq, NULL,\n\t\t\t\t\tmt6397_irq_thread, IRQF_ONESHOT,\n\t\t\t\t\t\"mt6397-pmic\", chip);\n\tif (ret) {\n\t\tdev_err(chip->dev, \"failed to register irq=%d; err: %d\\n\",\n\t\t\tchip->irq, ret);\n\t\treturn ret;\n\t}\n\n\tregister_pm_notifier(&chip->pm_nb);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}