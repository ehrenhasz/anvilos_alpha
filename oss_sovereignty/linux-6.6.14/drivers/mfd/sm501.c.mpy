{
  "module_name": "sm501.c",
  "hash_id": "8e9bf76e2ee3093413c50674f11c8fd9e50b7cb3338cd5d5b6c3cdfc655801a1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/sm501.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/device.h>\n#include <linux/platform_device.h>\n#include <linux/pci.h>\n#include <linux/platform_data/i2c-gpio.h>\n#include <linux/gpio/driver.h>\n#include <linux/gpio/machine.h>\n#include <linux/slab.h>\n\n#include <linux/sm501.h>\n#include <linux/sm501-regs.h>\n#include <linux/serial_8250.h>\n\n#include <linux/io.h>\n\nstruct sm501_device {\n\tstruct list_head\t\tlist;\n\tstruct platform_device\t\tpdev;\n};\n\nstruct sm501_gpio;\n\n#ifdef CONFIG_MFD_SM501_GPIO\n#include <linux/gpio.h>\n\nstruct sm501_gpio_chip {\n\tstruct gpio_chip\tgpio;\n\tstruct sm501_gpio\t*ourgpio;\t \n\tvoid __iomem\t\t*regbase;\n\tvoid __iomem\t\t*control;\t \n};\n\nstruct sm501_gpio {\n\tstruct sm501_gpio_chip\tlow;\n\tstruct sm501_gpio_chip\thigh;\n\tspinlock_t\t\tlock;\n\n\tunsigned int\t\t registered : 1;\n\tvoid __iomem\t\t*regs;\n\tstruct resource\t\t*regs_res;\n};\n#else\nstruct sm501_gpio {\n\t \n};\n#endif\n\nstruct sm501_devdata {\n\tspinlock_t\t\t\t reg_lock;\n\tstruct mutex\t\t\t clock_lock;\n\tstruct list_head\t\t devices;\n\tstruct sm501_gpio\t\t gpio;\n\n\tstruct device\t\t\t*dev;\n\tstruct resource\t\t\t*io_res;\n\tstruct resource\t\t\t*mem_res;\n\tstruct resource\t\t\t*regs_claim;\n\tstruct sm501_platdata\t\t*platdata;\n\n\n\tunsigned int\t\t\t in_suspend;\n\tunsigned long\t\t\t pm_misc;\n\n\tint\t\t\t\t unit_power[20];\n\tunsigned int\t\t\t pdev_id;\n\tunsigned int\t\t\t irq;\n\tvoid __iomem\t\t\t*regs;\n\tunsigned int\t\t\t rev;\n};\n\n\n#define MHZ (1000 * 1000)\n\n#ifdef DEBUG\nstatic const unsigned int div_tab[] = {\n\t[0]\t\t= 1,\n\t[1]\t\t= 2,\n\t[2]\t\t= 4,\n\t[3]\t\t= 8,\n\t[4]\t\t= 16,\n\t[5]\t\t= 32,\n\t[6]\t\t= 64,\n\t[7]\t\t= 128,\n\t[8]\t\t= 3,\n\t[9]\t\t= 6,\n\t[10]\t        = 12,\n\t[11]\t\t= 24,\n\t[12]\t\t= 48,\n\t[13]\t\t= 96,\n\t[14]\t\t= 192,\n\t[15]\t\t= 384,\n\t[16]\t\t= 5,\n\t[17]\t\t= 10,\n\t[18]\t\t= 20,\n\t[19]\t\t= 40,\n\t[20]\t\t= 80,\n\t[21]\t\t= 160,\n\t[22]\t\t= 320,\n\t[23]\t\t= 604,\n};\n\nstatic unsigned long decode_div(unsigned long pll2, unsigned long val,\n\t\t\t\tunsigned int lshft, unsigned int selbit,\n\t\t\t\tunsigned long mask)\n{\n\tif (val & selbit)\n\t\tpll2 = 288 * MHZ;\n\n\treturn pll2 / div_tab[(val >> lshft) & mask];\n}\n\n#define fmt_freq(x) ((x) / MHZ), ((x) % MHZ), (x)\n\n \n\nstatic void sm501_dump_clk(struct sm501_devdata *sm)\n{\n\tunsigned long misct = smc501_readl(sm->regs + SM501_MISC_TIMING);\n\tunsigned long pm0 = smc501_readl(sm->regs + SM501_POWER_MODE_0_CLOCK);\n\tunsigned long pm1 = smc501_readl(sm->regs + SM501_POWER_MODE_1_CLOCK);\n\tunsigned long pmc = smc501_readl(sm->regs + SM501_POWER_MODE_CONTROL);\n\tunsigned long sdclk0, sdclk1;\n\tunsigned long pll2 = 0;\n\n\tswitch (misct & 0x30) {\n\tcase 0x00:\n\t\tpll2 = 336 * MHZ;\n\t\tbreak;\n\tcase 0x10:\n\t\tpll2 = 288 * MHZ;\n\t\tbreak;\n\tcase 0x20:\n\t\tpll2 = 240 * MHZ;\n\t\tbreak;\n\tcase 0x30:\n\t\tpll2 = 192 * MHZ;\n\t\tbreak;\n\t}\n\n\tsdclk0 = (misct & (1<<12)) ? pll2 : 288 * MHZ;\n\tsdclk0 /= div_tab[((misct >> 8) & 0xf)];\n\n\tsdclk1 = (misct & (1<<20)) ? pll2 : 288 * MHZ;\n\tsdclk1 /= div_tab[((misct >> 16) & 0xf)];\n\n\tdev_dbg(sm->dev, \"MISCT=%08lx, PM0=%08lx, PM1=%08lx\\n\",\n\t\tmisct, pm0, pm1);\n\n\tdev_dbg(sm->dev, \"PLL2 = %ld.%ld MHz (%ld), SDCLK0=%08lx, SDCLK1=%08lx\\n\",\n\t\tfmt_freq(pll2), sdclk0, sdclk1);\n\n\tdev_dbg(sm->dev, \"SDRAM: PM0=%ld, PM1=%ld\\n\", sdclk0, sdclk1);\n\n\tdev_dbg(sm->dev, \"PM0[%c]: \"\n\t\t \"P2 %ld.%ld MHz (%ld), V2 %ld.%ld (%ld), \"\n\t\t \"M %ld.%ld (%ld), MX1 %ld.%ld (%ld)\\n\",\n\t\t (pmc & 3 ) == 0 ? '*' : '-',\n\t\t fmt_freq(decode_div(pll2, pm0, 24, 1<<29, 31)),\n\t\t fmt_freq(decode_div(pll2, pm0, 16, 1<<20, 15)),\n\t\t fmt_freq(decode_div(pll2, pm0, 8,  1<<12, 15)),\n\t\t fmt_freq(decode_div(pll2, pm0, 0,  1<<4,  15)));\n\n\tdev_dbg(sm->dev, \"PM1[%c]: \"\n\t\t\"P2 %ld.%ld MHz (%ld), V2 %ld.%ld (%ld), \"\n\t\t\"M %ld.%ld (%ld), MX1 %ld.%ld (%ld)\\n\",\n\t\t(pmc & 3 ) == 1 ? '*' : '-',\n\t\tfmt_freq(decode_div(pll2, pm1, 24, 1<<29, 31)),\n\t\tfmt_freq(decode_div(pll2, pm1, 16, 1<<20, 15)),\n\t\tfmt_freq(decode_div(pll2, pm1, 8,  1<<12, 15)),\n\t\tfmt_freq(decode_div(pll2, pm1, 0,  1<<4,  15)));\n}\n\nstatic void sm501_dump_regs(struct sm501_devdata *sm)\n{\n\tvoid __iomem *regs = sm->regs;\n\n\tdev_info(sm->dev, \"System Control   %08x\\n\",\n\t\t\tsmc501_readl(regs + SM501_SYSTEM_CONTROL));\n\tdev_info(sm->dev, \"Misc Control     %08x\\n\",\n\t\t\tsmc501_readl(regs + SM501_MISC_CONTROL));\n\tdev_info(sm->dev, \"GPIO Control Low %08x\\n\",\n\t\t\tsmc501_readl(regs + SM501_GPIO31_0_CONTROL));\n\tdev_info(sm->dev, \"GPIO Control Hi  %08x\\n\",\n\t\t\tsmc501_readl(regs + SM501_GPIO63_32_CONTROL));\n\tdev_info(sm->dev, \"DRAM Control     %08x\\n\",\n\t\t\tsmc501_readl(regs + SM501_DRAM_CONTROL));\n\tdev_info(sm->dev, \"Arbitration Ctrl %08x\\n\",\n\t\t\tsmc501_readl(regs + SM501_ARBTRTN_CONTROL));\n\tdev_info(sm->dev, \"Misc Timing      %08x\\n\",\n\t\t\tsmc501_readl(regs + SM501_MISC_TIMING));\n}\n\nstatic void sm501_dump_gate(struct sm501_devdata *sm)\n{\n\tdev_info(sm->dev, \"CurrentGate      %08x\\n\",\n\t\t\tsmc501_readl(sm->regs + SM501_CURRENT_GATE));\n\tdev_info(sm->dev, \"CurrentClock     %08x\\n\",\n\t\t\tsmc501_readl(sm->regs + SM501_CURRENT_CLOCK));\n\tdev_info(sm->dev, \"PowerModeControl %08x\\n\",\n\t\t\tsmc501_readl(sm->regs + SM501_POWER_MODE_CONTROL));\n}\n\n#else\nstatic inline void sm501_dump_gate(struct sm501_devdata *sm) { }\nstatic inline void sm501_dump_regs(struct sm501_devdata *sm) { }\nstatic inline void sm501_dump_clk(struct sm501_devdata *sm) { }\n#endif\n\n \n\nstatic void sm501_sync_regs(struct sm501_devdata *sm)\n{\n\tsmc501_readl(sm->regs);\n}\n\nstatic inline void sm501_mdelay(struct sm501_devdata *sm, unsigned int delay)\n{\n\t \n\n\tif (sm->in_suspend)\n\t\tmdelay(delay);\n\telse\n\t\tmsleep(delay);\n}\n\n \n\nint sm501_misc_control(struct device *dev,\n\t\t       unsigned long set, unsigned long clear)\n{\n\tstruct sm501_devdata *sm = dev_get_drvdata(dev);\n\tunsigned long misc;\n\tunsigned long save;\n\tunsigned long to;\n\n\tspin_lock_irqsave(&sm->reg_lock, save);\n\n\tmisc = smc501_readl(sm->regs + SM501_MISC_CONTROL);\n\tto = (misc & ~clear) | set;\n\n\tif (to != misc) {\n\t\tsmc501_writel(to, sm->regs + SM501_MISC_CONTROL);\n\t\tsm501_sync_regs(sm);\n\n\t\tdev_dbg(sm->dev, \"MISC_CONTROL %08lx\\n\", misc);\n\t}\n\n\tspin_unlock_irqrestore(&sm->reg_lock, save);\n\treturn to;\n}\n\nEXPORT_SYMBOL_GPL(sm501_misc_control);\n\n \n\nunsigned long sm501_modify_reg(struct device *dev,\n\t\t\t       unsigned long reg,\n\t\t\t       unsigned long set,\n\t\t\t       unsigned long clear)\n{\n\tstruct sm501_devdata *sm = dev_get_drvdata(dev);\n\tunsigned long data;\n\tunsigned long save;\n\n\tspin_lock_irqsave(&sm->reg_lock, save);\n\n\tdata = smc501_readl(sm->regs + reg);\n\tdata |= set;\n\tdata &= ~clear;\n\n\tsmc501_writel(data, sm->regs + reg);\n\tsm501_sync_regs(sm);\n\n\tspin_unlock_irqrestore(&sm->reg_lock, save);\n\n\treturn data;\n}\n\nEXPORT_SYMBOL_GPL(sm501_modify_reg);\n\n \n\nint sm501_unit_power(struct device *dev, unsigned int unit, unsigned int to)\n{\n\tstruct sm501_devdata *sm = dev_get_drvdata(dev);\n\tunsigned long mode;\n\tunsigned long gate;\n\tunsigned long clock;\n\n\tmutex_lock(&sm->clock_lock);\n\n\tmode = smc501_readl(sm->regs + SM501_POWER_MODE_CONTROL);\n\tgate = smc501_readl(sm->regs + SM501_CURRENT_GATE);\n\tclock = smc501_readl(sm->regs + SM501_CURRENT_CLOCK);\n\n\tmode &= 3;\t\t \n\n\tif (unit >= ARRAY_SIZE(sm->unit_power)) {\n\t\tdev_err(dev, \"%s: bad unit %d\\n\", __func__, unit);\n\t\tgoto already;\n\t}\n\n\tdev_dbg(sm->dev, \"%s: unit %d, cur %d, to %d\\n\", __func__, unit,\n\t\tsm->unit_power[unit], to);\n\n\tif (to == 0 && sm->unit_power[unit] == 0) {\n\t\tdev_err(sm->dev, \"unit %d is already shutdown\\n\", unit);\n\t\tgoto already;\n\t}\n\n\tsm->unit_power[unit] += to ? 1 : -1;\n\tto = sm->unit_power[unit] ? 1 : 0;\n\n\tif (to) {\n\t\tif (gate & (1 << unit))\n\t\t\tgoto already;\n\t\tgate |= (1 << unit);\n\t} else {\n\t\tif (!(gate & (1 << unit)))\n\t\t\tgoto already;\n\t\tgate &= ~(1 << unit);\n\t}\n\n\tswitch (mode) {\n\tcase 1:\n\t\tsmc501_writel(gate, sm->regs + SM501_POWER_MODE_0_GATE);\n\t\tsmc501_writel(clock, sm->regs + SM501_POWER_MODE_0_CLOCK);\n\t\tmode = 0;\n\t\tbreak;\n\tcase 2:\n\tcase 0:\n\t\tsmc501_writel(gate, sm->regs + SM501_POWER_MODE_1_GATE);\n\t\tsmc501_writel(clock, sm->regs + SM501_POWER_MODE_1_CLOCK);\n\t\tmode = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tgate = -1;\n\t\tgoto already;\n\t}\n\n\tsmc501_writel(mode, sm->regs + SM501_POWER_MODE_CONTROL);\n\tsm501_sync_regs(sm);\n\n\tdev_dbg(sm->dev, \"gate %08lx, clock %08lx, mode %08lx\\n\",\n\t\tgate, clock, mode);\n\n\tsm501_mdelay(sm, 16);\n\n already:\n\tmutex_unlock(&sm->clock_lock);\n\treturn gate;\n}\n\nEXPORT_SYMBOL_GPL(sm501_unit_power);\n\n \nstruct sm501_clock {\n\tunsigned long mclk;\n\tint divider;\n\tint shift;\n\tunsigned int m, n, k;\n};\n\n \n\nstatic int sm501_calc_clock(unsigned long freq,\n\t\t\t    struct sm501_clock *clock,\n\t\t\t    int max_div,\n\t\t\t    unsigned long mclk,\n\t\t\t    long *best_diff)\n{\n\tint ret = 0;\n\tint divider;\n\tint shift;\n\tlong diff;\n\n\t \n\n\tfor (divider = 1; divider <= max_div; divider += 2) {\n\t\t \n\t\tfor (shift = 0; shift < 8; shift++) {\n\t\t\t \n\t\t\tdiff = DIV_ROUND_CLOSEST(mclk, divider << shift) - freq;\n\t\t\tif (diff < 0)\n\t\t\t\tdiff = -diff;\n\n\t\t\t \n\t\t\tif (diff < *best_diff) {\n\t\t\t\t*best_diff = diff;\n\n\t\t\t\tclock->mclk = mclk;\n\t\t\t\tclock->divider = divider;\n\t\t\t\tclock->shift = shift;\n\t\t\t\tret = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n \n\nstatic unsigned long sm501_calc_pll(unsigned long freq,\n\t\t\t\t\tstruct sm501_clock *clock,\n\t\t\t\t\tint max_div)\n{\n\tunsigned long mclk;\n\tunsigned int m, n, k;\n\tlong best_diff = 999999999;\n\n\t \n\tfor (m = 2; m <= 255; m++) {\n\t\tfor (n = 2; n <= 127; n++) {\n\t\t\tfor (k = 0; k <= 1; k++) {\n\t\t\t\tmclk = (24000000UL * m / n) >> k;\n\n\t\t\t\tif (sm501_calc_clock(freq, clock, max_div,\n\t\t\t\t\t\t     mclk, &best_diff)) {\n\t\t\t\t\tclock->m = m;\n\t\t\t\t\tclock->n = n;\n\t\t\t\t\tclock->k = k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\treturn clock->mclk / (clock->divider << clock->shift);\n}\n\n \n\nstatic unsigned long sm501_select_clock(unsigned long freq,\n\t\t\t\t\tstruct sm501_clock *clock,\n\t\t\t\t\tint max_div)\n{\n\tunsigned long mclk;\n\tlong best_diff = 999999999;\n\n\t \n\tfor (mclk = 288000000; mclk <= 336000000; mclk += 48000000) {\n\t\tsm501_calc_clock(freq, clock, max_div, mclk, &best_diff);\n\t}\n\n\t \n\treturn clock->mclk / (clock->divider << clock->shift);\n}\n\n \n\nunsigned long sm501_set_clock(struct device *dev,\n\t\t\t      int clksrc,\n\t\t\t      unsigned long req_freq)\n{\n\tstruct sm501_devdata *sm = dev_get_drvdata(dev);\n\tunsigned long mode = smc501_readl(sm->regs + SM501_POWER_MODE_CONTROL);\n\tunsigned long gate = smc501_readl(sm->regs + SM501_CURRENT_GATE);\n\tunsigned long clock = smc501_readl(sm->regs + SM501_CURRENT_CLOCK);\n\tunsigned int pll_reg = 0;\n\tunsigned long sm501_freq;  \n\tu64 reg;\n\n\tstruct sm501_clock to;\n\n\t \n\n\tswitch (clksrc) {\n\tcase SM501_CLOCK_P2XCLK:\n\t\t \n\n\t\tif (sm->rev >= 0xC0) {\n\t\t\t \n\t\t\tsm501_freq = (sm501_calc_pll(2 * req_freq,\n\t\t\t\t\t\t     &to, 5) / 2);\n\t\t\treg = to.shift & 0x07; \n\t\t\tif (to.divider == 3)\n\t\t\t\treg |= 0x08;  \n\t\t\telse if (to.divider == 5)\n\t\t\t\treg |= 0x10;  \n\t\t\treg |= 0x40;  \n\t\t\tpll_reg = 0x20000 | (to.k << 15) | (to.n << 8) | to.m;\n\t\t} else {\n\t\t\tsm501_freq = (sm501_select_clock(2 * req_freq,\n\t\t\t\t\t\t\t &to, 5) / 2);\n\t\t\treg = to.shift & 0x07; \n\t\t\tif (to.divider == 3)\n\t\t\t\treg |= 0x08;  \n\t\t\telse if (to.divider == 5)\n\t\t\t\treg |= 0x10;  \n\t\t\tif (to.mclk != 288000000)\n\t\t\t\treg |= 0x20;  \n\t\t}\n\t\tbreak;\n\n\tcase SM501_CLOCK_V2XCLK:\n\t\t \n\n\t\tsm501_freq = (sm501_select_clock(2 * req_freq, &to, 3) / 2);\n\t\treg=to.shift & 0x07;\t \n\t\tif (to.divider == 3)\n\t\t\treg |= 0x08;\t \n\t\tif (to.mclk != 288000000)\n\t\t\treg |= 0x10;\t \n\t\tbreak;\n\n\tcase SM501_CLOCK_MCLK:\n\tcase SM501_CLOCK_M1XCLK:\n\t\t \n\n\t\tsm501_freq = sm501_select_clock( req_freq, &to, 3);\n\t\treg=to.shift & 0x07;\t \n\t\tif (to.divider == 3)\n\t\t\treg |= 0x08;\t \n\t\tif (to.mclk != 288000000)\n\t\t\treg |= 0x10;\t \n\t\tbreak;\n\n\tdefault:\n\t\treturn 0;  \n\t}\n\n\tmutex_lock(&sm->clock_lock);\n\n\tmode = smc501_readl(sm->regs + SM501_POWER_MODE_CONTROL);\n\tgate = smc501_readl(sm->regs + SM501_CURRENT_GATE);\n\tclock = smc501_readl(sm->regs + SM501_CURRENT_CLOCK);\n\n\tclock = clock & ~(0xFF << clksrc);\n\tclock |= reg<<clksrc;\n\n\tmode &= 3;\t \n\n\tswitch (mode) {\n\tcase 1:\n\t\tsmc501_writel(gate, sm->regs + SM501_POWER_MODE_0_GATE);\n\t\tsmc501_writel(clock, sm->regs + SM501_POWER_MODE_0_CLOCK);\n\t\tmode = 0;\n\t\tbreak;\n\tcase 2:\n\tcase 0:\n\t\tsmc501_writel(gate, sm->regs + SM501_POWER_MODE_1_GATE);\n\t\tsmc501_writel(clock, sm->regs + SM501_POWER_MODE_1_CLOCK);\n\t\tmode = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tmutex_unlock(&sm->clock_lock);\n\t\treturn -1;\n\t}\n\n\tsmc501_writel(mode, sm->regs + SM501_POWER_MODE_CONTROL);\n\n\tif (pll_reg)\n\t\tsmc501_writel(pll_reg,\n\t\t\t\tsm->regs + SM501_PROGRAMMABLE_PLL_CONTROL);\n\n\tsm501_sync_regs(sm);\n\n\tdev_dbg(sm->dev, \"gate %08lx, clock %08lx, mode %08lx\\n\",\n\t\tgate, clock, mode);\n\n\tsm501_mdelay(sm, 16);\n\tmutex_unlock(&sm->clock_lock);\n\n\tsm501_dump_clk(sm);\n\n\treturn sm501_freq;\n}\n\nEXPORT_SYMBOL_GPL(sm501_set_clock);\n\n \n\nunsigned long sm501_find_clock(struct device *dev,\n\t\t\t       int clksrc,\n\t\t\t       unsigned long req_freq)\n{\n\tstruct sm501_devdata *sm = dev_get_drvdata(dev);\n\tunsigned long sm501_freq;  \n\tstruct sm501_clock to;\n\n\tswitch (clksrc) {\n\tcase SM501_CLOCK_P2XCLK:\n\t\tif (sm->rev >= 0xC0) {\n\t\t\t \n\t\t\tsm501_freq = (sm501_calc_pll(2 * req_freq,\n\t\t\t\t\t\t     &to, 5) / 2);\n\t\t} else {\n\t\t\tsm501_freq = (sm501_select_clock(2 * req_freq,\n\t\t\t\t\t\t\t &to, 5) / 2);\n\t\t}\n\t\tbreak;\n\n\tcase SM501_CLOCK_V2XCLK:\n\t\tsm501_freq = (sm501_select_clock(2 * req_freq, &to, 3) / 2);\n\t\tbreak;\n\n\tcase SM501_CLOCK_MCLK:\n\tcase SM501_CLOCK_M1XCLK:\n\t\tsm501_freq = sm501_select_clock(req_freq, &to, 3);\n\t\tbreak;\n\n\tdefault:\n\t\tsm501_freq = 0;\t\t \n\t}\n\n\treturn sm501_freq;\n}\n\nEXPORT_SYMBOL_GPL(sm501_find_clock);\n\nstatic struct sm501_device *to_sm_device(struct platform_device *pdev)\n{\n\treturn container_of(pdev, struct sm501_device, pdev);\n}\n\n \n\nstatic void sm501_device_release(struct device *dev)\n{\n\tkfree(to_sm_device(to_platform_device(dev)));\n}\n\n \n\nstatic struct platform_device *\nsm501_create_subdev(struct sm501_devdata *sm, char *name,\n\t\t    unsigned int res_count, unsigned int platform_data_size)\n{\n\tstruct sm501_device *smdev;\n\n\tsmdev = kzalloc(sizeof(struct sm501_device) +\n\t\t\t(sizeof(struct resource) * res_count) +\n\t\t\tplatform_data_size, GFP_KERNEL);\n\tif (!smdev)\n\t\treturn NULL;\n\n\tsmdev->pdev.dev.release = sm501_device_release;\n\n\tsmdev->pdev.name = name;\n\tsmdev->pdev.id = sm->pdev_id;\n\tsmdev->pdev.dev.parent = sm->dev;\n\tsmdev->pdev.dev.coherent_dma_mask = 0xffffffff;\n\n\tif (res_count) {\n\t\tsmdev->pdev.resource = (struct resource *)(smdev+1);\n\t\tsmdev->pdev.num_resources = res_count;\n\t}\n\tif (platform_data_size)\n\t\tsmdev->pdev.dev.platform_data = (void *)(smdev+1);\n\n\treturn &smdev->pdev;\n}\n\n \n\nstatic int sm501_register_device(struct sm501_devdata *sm,\n\t\t\t\t struct platform_device *pdev)\n{\n\tstruct sm501_device *smdev = to_sm_device(pdev);\n\tint ptr;\n\tint ret;\n\n\tfor (ptr = 0; ptr < pdev->num_resources; ptr++) {\n\t\tprintk(KERN_DEBUG \"%s[%d] %pR\\n\",\n\t\t       pdev->name, ptr, &pdev->resource[ptr]);\n\t}\n\n\tret = platform_device_register(pdev);\n\n\tif (ret >= 0) {\n\t\tdev_dbg(sm->dev, \"registered %s\\n\", pdev->name);\n\t\tlist_add_tail(&smdev->list, &sm->devices);\n\t} else\n\t\tdev_err(sm->dev, \"error registering %s (%d)\\n\",\n\t\t\tpdev->name, ret);\n\n\treturn ret;\n}\n\n \n\nstatic void sm501_create_subio(struct sm501_devdata *sm,\n\t\t\t       struct resource *res,\n\t\t\t       resource_size_t offs,\n\t\t\t       resource_size_t size)\n{\n\tres->flags = IORESOURCE_MEM;\n\tres->parent = sm->io_res;\n\tres->start = sm->io_res->start + offs;\n\tres->end = res->start + size - 1;\n}\n\n \n\nstatic void sm501_create_mem(struct sm501_devdata *sm,\n\t\t\t     struct resource *res,\n\t\t\t     resource_size_t *offs,\n\t\t\t     resource_size_t size)\n{\n\t*offs -= size;\t\t \n\n\tres->flags = IORESOURCE_MEM;\n\tres->parent = sm->mem_res;\n\tres->start = sm->mem_res->start + *offs;\n\tres->end = res->start + size - 1;\n}\n\n \n\nstatic void sm501_create_irq(struct sm501_devdata *sm,\n\t\t\t     struct resource *res)\n{\n\tres->flags = IORESOURCE_IRQ;\n\tres->parent = NULL;\n\tres->start = res->end = sm->irq;\n}\n\nstatic int sm501_register_usbhost(struct sm501_devdata *sm,\n\t\t\t\t  resource_size_t *mem_avail)\n{\n\tstruct platform_device *pdev;\n\n\tpdev = sm501_create_subdev(sm, \"sm501-usb\", 3, 0);\n\tif (!pdev)\n\t\treturn -ENOMEM;\n\n\tsm501_create_subio(sm, &pdev->resource[0], 0x40000, 0x20000);\n\tsm501_create_mem(sm, &pdev->resource[1], mem_avail, 256*1024);\n\tsm501_create_irq(sm, &pdev->resource[2]);\n\n\treturn sm501_register_device(sm, pdev);\n}\n\nstatic void sm501_setup_uart_data(struct sm501_devdata *sm,\n\t\t\t\t  struct plat_serial8250_port *uart_data,\n\t\t\t\t  unsigned int offset)\n{\n\tuart_data->membase = sm->regs + offset;\n\tuart_data->mapbase = sm->io_res->start + offset;\n\tuart_data->iotype = UPIO_MEM;\n\tuart_data->irq = sm->irq;\n\tuart_data->flags = UPF_BOOT_AUTOCONF | UPF_SKIP_TEST | UPF_SHARE_IRQ;\n\tuart_data->regshift = 2;\n\tuart_data->uartclk = (9600 * 16);\n}\n\nstatic int sm501_register_uart(struct sm501_devdata *sm, int devices)\n{\n\tstruct platform_device *pdev;\n\tstruct plat_serial8250_port *uart_data;\n\n\tpdev = sm501_create_subdev(sm, \"serial8250\", 0,\n\t\t\t\t   sizeof(struct plat_serial8250_port) * 3);\n\tif (!pdev)\n\t\treturn -ENOMEM;\n\n\tuart_data = dev_get_platdata(&pdev->dev);\n\n\tif (devices & SM501_USE_UART0) {\n\t\tsm501_setup_uart_data(sm, uart_data++, 0x30000);\n\t\tsm501_unit_power(sm->dev, SM501_GATE_UART0, 1);\n\t\tsm501_modify_reg(sm->dev, SM501_IRQ_MASK, 1 << 12, 0);\n\t\tsm501_modify_reg(sm->dev, SM501_GPIO63_32_CONTROL, 0x01e0, 0);\n\t}\n\tif (devices & SM501_USE_UART1) {\n\t\tsm501_setup_uart_data(sm, uart_data++, 0x30020);\n\t\tsm501_unit_power(sm->dev, SM501_GATE_UART1, 1);\n\t\tsm501_modify_reg(sm->dev, SM501_IRQ_MASK, 1 << 13, 0);\n\t\tsm501_modify_reg(sm->dev, SM501_GPIO63_32_CONTROL, 0x1e00, 0);\n\t}\n\n\tpdev->id = PLAT8250_DEV_SM501;\n\n\treturn sm501_register_device(sm, pdev);\n}\n\nstatic int sm501_register_display(struct sm501_devdata *sm,\n\t\t\t\t  resource_size_t *mem_avail)\n{\n\tstruct platform_device *pdev;\n\n\tpdev = sm501_create_subdev(sm, \"sm501-fb\", 4, 0);\n\tif (!pdev)\n\t\treturn -ENOMEM;\n\n\tsm501_create_subio(sm, &pdev->resource[0], 0x80000, 0x10000);\n\tsm501_create_subio(sm, &pdev->resource[1], 0x100000, 0x50000);\n\tsm501_create_mem(sm, &pdev->resource[2], mem_avail, *mem_avail);\n\tsm501_create_irq(sm, &pdev->resource[3]);\n\n\treturn sm501_register_device(sm, pdev);\n}\n\n#ifdef CONFIG_MFD_SM501_GPIO\n\nstatic inline struct sm501_devdata *sm501_gpio_to_dev(struct sm501_gpio *gpio)\n{\n\treturn container_of(gpio, struct sm501_devdata, gpio);\n}\n\nstatic int sm501_gpio_get(struct gpio_chip *chip, unsigned offset)\n\n{\n\tstruct sm501_gpio_chip *smgpio = gpiochip_get_data(chip);\n\tunsigned long result;\n\n\tresult = smc501_readl(smgpio->regbase + SM501_GPIO_DATA_LOW);\n\tresult >>= offset;\n\n\treturn result & 1UL;\n}\n\nstatic void sm501_gpio_ensure_gpio(struct sm501_gpio_chip *smchip,\n\t\t\t\t   unsigned long bit)\n{\n\tunsigned long ctrl;\n\n\t \n\n\tif (smc501_readl(smchip->control) & bit) {\n\t\tdev_info(sm501_gpio_to_dev(smchip->ourgpio)->dev,\n\t\t\t \"changing mode of gpio, bit %08lx\\n\", bit);\n\n\t\tctrl = smc501_readl(smchip->control);\n\t\tctrl &= ~bit;\n\t\tsmc501_writel(ctrl, smchip->control);\n\n\t\tsm501_sync_regs(sm501_gpio_to_dev(smchip->ourgpio));\n\t}\n}\n\nstatic void sm501_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\n\n{\n\tstruct sm501_gpio_chip *smchip = gpiochip_get_data(chip);\n\tstruct sm501_gpio *smgpio = smchip->ourgpio;\n\tunsigned long bit = 1 << offset;\n\tvoid __iomem *regs = smchip->regbase;\n\tunsigned long save;\n\tunsigned long val;\n\n\tdev_dbg(sm501_gpio_to_dev(smgpio)->dev, \"%s(%p,%d)\\n\",\n\t\t__func__, chip, offset);\n\n\tspin_lock_irqsave(&smgpio->lock, save);\n\n\tval = smc501_readl(regs + SM501_GPIO_DATA_LOW) & ~bit;\n\tif (value)\n\t\tval |= bit;\n\tsmc501_writel(val, regs);\n\n\tsm501_sync_regs(sm501_gpio_to_dev(smgpio));\n\tsm501_gpio_ensure_gpio(smchip, bit);\n\n\tspin_unlock_irqrestore(&smgpio->lock, save);\n}\n\nstatic int sm501_gpio_input(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct sm501_gpio_chip *smchip = gpiochip_get_data(chip);\n\tstruct sm501_gpio *smgpio = smchip->ourgpio;\n\tvoid __iomem *regs = smchip->regbase;\n\tunsigned long bit = 1 << offset;\n\tunsigned long save;\n\tunsigned long ddr;\n\n\tdev_dbg(sm501_gpio_to_dev(smgpio)->dev, \"%s(%p,%d)\\n\",\n\t\t__func__, chip, offset);\n\n\tspin_lock_irqsave(&smgpio->lock, save);\n\n\tddr = smc501_readl(regs + SM501_GPIO_DDR_LOW);\n\tsmc501_writel(ddr & ~bit, regs + SM501_GPIO_DDR_LOW);\n\n\tsm501_sync_regs(sm501_gpio_to_dev(smgpio));\n\tsm501_gpio_ensure_gpio(smchip, bit);\n\n\tspin_unlock_irqrestore(&smgpio->lock, save);\n\n\treturn 0;\n}\n\nstatic int sm501_gpio_output(struct gpio_chip *chip,\n\t\t\t     unsigned offset, int value)\n{\n\tstruct sm501_gpio_chip *smchip = gpiochip_get_data(chip);\n\tstruct sm501_gpio *smgpio = smchip->ourgpio;\n\tunsigned long bit = 1 << offset;\n\tvoid __iomem *regs = smchip->regbase;\n\tunsigned long save;\n\tunsigned long val;\n\tunsigned long ddr;\n\n\tdev_dbg(sm501_gpio_to_dev(smgpio)->dev, \"%s(%p,%d,%d)\\n\",\n\t\t__func__, chip, offset, value);\n\n\tspin_lock_irqsave(&smgpio->lock, save);\n\n\tval = smc501_readl(regs + SM501_GPIO_DATA_LOW);\n\tif (value)\n\t\tval |= bit;\n\telse\n\t\tval &= ~bit;\n\tsmc501_writel(val, regs);\n\n\tddr = smc501_readl(regs + SM501_GPIO_DDR_LOW);\n\tsmc501_writel(ddr | bit, regs + SM501_GPIO_DDR_LOW);\n\n\tsm501_sync_regs(sm501_gpio_to_dev(smgpio));\n\tsmc501_writel(val, regs + SM501_GPIO_DATA_LOW);\n\n\tsm501_sync_regs(sm501_gpio_to_dev(smgpio));\n\tspin_unlock_irqrestore(&smgpio->lock, save);\n\n\treturn 0;\n}\n\nstatic const struct gpio_chip gpio_chip_template = {\n\t.ngpio\t\t\t= 32,\n\t.direction_input\t= sm501_gpio_input,\n\t.direction_output\t= sm501_gpio_output,\n\t.set\t\t\t= sm501_gpio_set,\n\t.get\t\t\t= sm501_gpio_get,\n};\n\nstatic int sm501_gpio_register_chip(struct sm501_devdata *sm,\n\t\t\t\t\t      struct sm501_gpio *gpio,\n\t\t\t\t\t      struct sm501_gpio_chip *chip)\n{\n\tstruct sm501_platdata *pdata = sm->platdata;\n\tstruct gpio_chip *gchip = &chip->gpio;\n\tint base = pdata->gpio_base;\n\n\tchip->gpio = gpio_chip_template;\n\n\tif (chip == &gpio->high) {\n\t\tif (base > 0)\n\t\t\tbase += 32;\n\t\tchip->regbase = gpio->regs + SM501_GPIO_DATA_HIGH;\n\t\tchip->control = sm->regs + SM501_GPIO63_32_CONTROL;\n\t\tgchip->label  = \"SM501-HIGH\";\n\t} else {\n\t\tchip->regbase = gpio->regs + SM501_GPIO_DATA_LOW;\n\t\tchip->control = sm->regs + SM501_GPIO31_0_CONTROL;\n\t\tgchip->label  = \"SM501-LOW\";\n\t}\n\n\tgchip->base   = base;\n\tchip->ourgpio = gpio;\n\n\treturn gpiochip_add_data(gchip, chip);\n}\n\nstatic int sm501_register_gpio(struct sm501_devdata *sm)\n{\n\tstruct sm501_gpio *gpio = &sm->gpio;\n\tresource_size_t iobase = sm->io_res->start + SM501_GPIO;\n\tint ret;\n\n\tdev_dbg(sm->dev, \"registering gpio block %08llx\\n\",\n\t\t(unsigned long long)iobase);\n\n\tspin_lock_init(&gpio->lock);\n\n\tgpio->regs_res = request_mem_region(iobase, 0x20, \"sm501-gpio\");\n\tif (!gpio->regs_res) {\n\t\tdev_err(sm->dev, \"gpio: failed to request region\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tgpio->regs = ioremap(iobase, 0x20);\n\tif (!gpio->regs) {\n\t\tdev_err(sm->dev, \"gpio: failed to remap registers\\n\");\n\t\tret = -ENXIO;\n\t\tgoto err_claimed;\n\t}\n\n\t \n\n\tret = sm501_gpio_register_chip(sm, gpio, &gpio->low);\n\tif (ret) {\n\t\tdev_err(sm->dev, \"failed to add low chip\\n\");\n\t\tgoto err_mapped;\n\t}\n\n\tret = sm501_gpio_register_chip(sm, gpio, &gpio->high);\n\tif (ret) {\n\t\tdev_err(sm->dev, \"failed to add high chip\\n\");\n\t\tgoto err_low_chip;\n\t}\n\n\tgpio->registered = 1;\n\n\treturn 0;\n\n err_low_chip:\n\tgpiochip_remove(&gpio->low.gpio);\n\n err_mapped:\n\tiounmap(gpio->regs);\n\n err_claimed:\n\trelease_mem_region(iobase, 0x20);\n\n\treturn ret;\n}\n\nstatic void sm501_gpio_remove(struct sm501_devdata *sm)\n{\n\tstruct sm501_gpio *gpio = &sm->gpio;\n\tresource_size_t iobase = sm->io_res->start + SM501_GPIO;\n\n\tif (!sm->gpio.registered)\n\t\treturn;\n\n\tgpiochip_remove(&gpio->low.gpio);\n\tgpiochip_remove(&gpio->high.gpio);\n\n\tiounmap(gpio->regs);\n\trelease_mem_region(iobase, 0x20);\n}\n\nstatic inline int sm501_gpio_isregistered(struct sm501_devdata *sm)\n{\n\treturn sm->gpio.registered;\n}\n#else\nstatic inline int sm501_register_gpio(struct sm501_devdata *sm)\n{\n\treturn 0;\n}\n\nstatic inline void sm501_gpio_remove(struct sm501_devdata *sm)\n{\n}\n\nstatic inline int sm501_gpio_isregistered(struct sm501_devdata *sm)\n{\n\treturn 0;\n}\n#endif\n\nstatic int sm501_register_gpio_i2c_instance(struct sm501_devdata *sm,\n\t\t\t\t\t    struct sm501_platdata_gpio_i2c *iic)\n{\n\tstruct i2c_gpio_platform_data *icd;\n\tstruct platform_device *pdev;\n\tstruct gpiod_lookup_table *lookup;\n\n\tpdev = sm501_create_subdev(sm, \"i2c-gpio\", 0,\n\t\t\t\t   sizeof(struct i2c_gpio_platform_data));\n\tif (!pdev)\n\t\treturn -ENOMEM;\n\n\t \n\tlookup = devm_kzalloc(&pdev->dev, struct_size(lookup, table, 3),\n\t\t\t      GFP_KERNEL);\n\tif (!lookup)\n\t\treturn -ENOMEM;\n\n\tlookup->dev_id = \"i2c-gpio\";\n\tlookup->table[0] = (struct gpiod_lookup)\n\t\tGPIO_LOOKUP_IDX(iic->pin_sda < 32 ? \"SM501-LOW\" : \"SM501-HIGH\",\n\t\t\t\tiic->pin_sda % 32, NULL, 0,\n\t\t\t\tGPIO_ACTIVE_HIGH | GPIO_OPEN_DRAIN);\n\tlookup->table[1] = (struct gpiod_lookup)\n\t\tGPIO_LOOKUP_IDX(iic->pin_scl < 32 ? \"SM501-LOW\" : \"SM501-HIGH\",\n\t\t\t\tiic->pin_scl % 32, NULL, 1,\n\t\t\t\tGPIO_ACTIVE_HIGH | GPIO_OPEN_DRAIN);\n\tgpiod_add_lookup_table(lookup);\n\n\ticd = dev_get_platdata(&pdev->dev);\n\ticd->timeout = iic->timeout;\n\ticd->udelay = iic->udelay;\n\n\t \n\n\tpdev->id = iic->bus_num;\n\n\tdev_info(sm->dev, \"registering i2c-%d: sda=%d, scl=%d\\n\",\n\t\t iic->bus_num,\n\t\t iic->pin_sda, iic->pin_scl);\n\n\treturn sm501_register_device(sm, pdev);\n}\n\nstatic int sm501_register_gpio_i2c(struct sm501_devdata *sm,\n\t\t\t\t   struct sm501_platdata *pdata)\n{\n\tstruct sm501_platdata_gpio_i2c *iic = pdata->gpio_i2c;\n\tint index;\n\tint ret;\n\n\tfor (index = 0; index < pdata->gpio_i2c_nr; index++, iic++) {\n\t\tret = sm501_register_gpio_i2c_instance(sm, iic);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic ssize_t dbg_regs_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buff)\n{\n\tstruct sm501_devdata *sm = dev_get_drvdata(dev)\t;\n\tunsigned int reg;\n\tchar *ptr = buff;\n\tint ret;\n\n\tfor (reg = 0x00; reg < 0x70; reg += 4) {\n\t\tret = sprintf(ptr, \"%08x = %08x\\n\",\n\t\t\t      reg, smc501_readl(sm->regs + reg));\n\t\tptr += ret;\n\t}\n\n\treturn ptr - buff;\n}\n\n\nstatic DEVICE_ATTR_RO(dbg_regs);\n\n \n\nstatic inline void sm501_init_reg(struct sm501_devdata *sm,\n\t\t\t\t  unsigned long reg,\n\t\t\t\t  struct sm501_reg_init *r)\n{\n\tunsigned long tmp;\n\n\ttmp = smc501_readl(sm->regs + reg);\n\ttmp &= ~r->mask;\n\ttmp |= r->set;\n\tsmc501_writel(tmp, sm->regs + reg);\n}\n\n \n\nstatic void sm501_init_regs(struct sm501_devdata *sm,\n\t\t\t    struct sm501_initdata *init)\n{\n\tsm501_misc_control(sm->dev,\n\t\t\t   init->misc_control.set,\n\t\t\t   init->misc_control.mask);\n\n\tsm501_init_reg(sm, SM501_MISC_TIMING, &init->misc_timing);\n\tsm501_init_reg(sm, SM501_GPIO31_0_CONTROL, &init->gpio_low);\n\tsm501_init_reg(sm, SM501_GPIO63_32_CONTROL, &init->gpio_high);\n\n\tif (init->m1xclk) {\n\t\tdev_info(sm->dev, \"setting M1XCLK to %ld\\n\", init->m1xclk);\n\t\tsm501_set_clock(sm->dev, SM501_CLOCK_M1XCLK, init->m1xclk);\n\t}\n\n\tif (init->mclk) {\n\t\tdev_info(sm->dev, \"setting MCLK to %ld\\n\", init->mclk);\n\t\tsm501_set_clock(sm->dev, SM501_CLOCK_MCLK, init->mclk);\n\t}\n\n}\n\n \n\nstatic int sm501_check_clocks(struct sm501_devdata *sm)\n{\n\tunsigned long pwrmode = smc501_readl(sm->regs + SM501_CURRENT_CLOCK);\n\tunsigned long msrc = (pwrmode & SM501_POWERMODE_M_SRC);\n\tunsigned long m1src = (pwrmode & SM501_POWERMODE_M1_SRC);\n\n\treturn ((msrc == 0 && m1src != 0) || (msrc != 0 && m1src == 0));\n}\n\nstatic unsigned int sm501_mem_local[] = {\n\t[0]\t= 4*1024*1024,\n\t[1]\t= 8*1024*1024,\n\t[2]\t= 16*1024*1024,\n\t[3]\t= 32*1024*1024,\n\t[4]\t= 64*1024*1024,\n\t[5]\t= 2*1024*1024,\n};\n\n \n\nstatic int sm501_init_dev(struct sm501_devdata *sm)\n{\n\tstruct sm501_initdata *idata;\n\tstruct sm501_platdata *pdata;\n\tresource_size_t mem_avail;\n\tunsigned long dramctrl;\n\tunsigned long devid;\n\tint ret;\n\n\tmutex_init(&sm->clock_lock);\n\tspin_lock_init(&sm->reg_lock);\n\n\tINIT_LIST_HEAD(&sm->devices);\n\n\tdevid = smc501_readl(sm->regs + SM501_DEVICEID);\n\n\tif ((devid & SM501_DEVICEID_IDMASK) != SM501_DEVICEID_SM501) {\n\t\tdev_err(sm->dev, \"incorrect device id %08lx\\n\", devid);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tsmc501_writel(0, sm->regs + SM501_IRQ_MASK);\n\n\tdramctrl = smc501_readl(sm->regs + SM501_DRAM_CONTROL);\n\tmem_avail = sm501_mem_local[(dramctrl >> 13) & 0x7];\n\n\tdev_info(sm->dev, \"SM501 At %p: Version %08lx, %ld Mb, IRQ %d\\n\",\n\t\t sm->regs, devid, (unsigned long)mem_avail >> 20, sm->irq);\n\n\tsm->rev = devid & SM501_DEVICEID_REVMASK;\n\n\tsm501_dump_gate(sm);\n\n\tret = device_create_file(sm->dev, &dev_attr_dbg_regs);\n\tif (ret)\n\t\tdev_err(sm->dev, \"failed to create debug regs file\\n\");\n\n\tsm501_dump_clk(sm);\n\n\t \n\n\tpdata = sm->platdata;\n\tidata = pdata ? pdata->init : NULL;\n\n\tif (idata) {\n\t\tsm501_init_regs(sm, idata);\n\n\t\tif (idata->devices & SM501_USE_USB_HOST)\n\t\t\tsm501_register_usbhost(sm, &mem_avail);\n\t\tif (idata->devices & (SM501_USE_UART0 | SM501_USE_UART1))\n\t\t\tsm501_register_uart(sm, idata->devices);\n\t\tif (idata->devices & SM501_USE_GPIO)\n\t\t\tsm501_register_gpio(sm);\n\t}\n\n\tif (pdata && pdata->gpio_i2c && pdata->gpio_i2c_nr > 0) {\n\t\tif (!sm501_gpio_isregistered(sm))\n\t\t\tdev_err(sm->dev, \"no gpio available for i2c gpio.\\n\");\n\t\telse\n\t\t\tsm501_register_gpio_i2c(sm, pdata);\n\t}\n\n\tret = sm501_check_clocks(sm);\n\tif (ret) {\n\t\tdev_err(sm->dev, \"M1X and M clocks sourced from different \"\n\t\t\t\t\t\"PLLs\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tsm501_register_display(sm, &mem_avail);\n\n\treturn 0;\n}\n\nstatic int sm501_plat_probe(struct platform_device *dev)\n{\n\tstruct sm501_devdata *sm;\n\tint ret;\n\n\tsm = kzalloc(sizeof(*sm), GFP_KERNEL);\n\tif (!sm) {\n\t\tret = -ENOMEM;\n\t\tgoto err1;\n\t}\n\n\tsm->dev = &dev->dev;\n\tsm->pdev_id = dev->id;\n\tsm->platdata = dev_get_platdata(&dev->dev);\n\n\tret = platform_get_irq(dev, 0);\n\tif (ret < 0)\n\t\tgoto err_res;\n\tsm->irq = ret;\n\n\tsm->io_res = platform_get_resource(dev, IORESOURCE_MEM, 1);\n\tsm->mem_res = platform_get_resource(dev, IORESOURCE_MEM, 0);\n\tif (!sm->io_res || !sm->mem_res) {\n\t\tdev_err(&dev->dev, \"failed to get IO resource\\n\");\n\t\tret = -ENOENT;\n\t\tgoto err_res;\n\t}\n\n\tsm->regs_claim = request_mem_region(sm->io_res->start,\n\t\t\t\t\t    0x100, \"sm501\");\n\tif (!sm->regs_claim) {\n\t\tdev_err(&dev->dev, \"cannot claim registers\\n\");\n\t\tret = -EBUSY;\n\t\tgoto err_res;\n\t}\n\n\tplatform_set_drvdata(dev, sm);\n\n\tsm->regs = ioremap(sm->io_res->start, resource_size(sm->io_res));\n\tif (!sm->regs) {\n\t\tdev_err(&dev->dev, \"cannot remap registers\\n\");\n\t\tret = -EIO;\n\t\tgoto err_claim;\n\t}\n\n\tret = sm501_init_dev(sm);\n\tif (ret)\n\t\tgoto err_unmap;\n\n\treturn 0;\n\n err_unmap:\n\tiounmap(sm->regs);\n err_claim:\n\trelease_mem_region(sm->io_res->start, 0x100);\n err_res:\n\tkfree(sm);\n err1:\n\treturn ret;\n\n}\n\n \n\nstatic void sm501_set_power(struct sm501_devdata *sm, int on)\n{\n\tstruct sm501_platdata *pd = sm->platdata;\n\n\tif (!pd)\n\t\treturn;\n\n\tif (pd->get_power) {\n\t\tif (pd->get_power(sm->dev) == on) {\n\t\t\tdev_dbg(sm->dev, \"is already %d\\n\", on);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (pd->set_power) {\n\t\tdev_dbg(sm->dev, \"setting power to %d\\n\", on);\n\n\t\tpd->set_power(sm->dev, on);\n\t\tsm501_mdelay(sm, 10);\n\t}\n}\n\nstatic int sm501_plat_suspend(struct platform_device *pdev, pm_message_t state)\n{\n\tstruct sm501_devdata *sm = platform_get_drvdata(pdev);\n\n\tsm->in_suspend = 1;\n\tsm->pm_misc = smc501_readl(sm->regs + SM501_MISC_CONTROL);\n\n\tsm501_dump_regs(sm);\n\n\tif (sm->platdata) {\n\t\tif (sm->platdata->flags & SM501_FLAG_SUSPEND_OFF)\n\t\t\tsm501_set_power(sm, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic int sm501_plat_resume(struct platform_device *pdev)\n{\n\tstruct sm501_devdata *sm = platform_get_drvdata(pdev);\n\n\tsm501_set_power(sm, 1);\n\n\tsm501_dump_regs(sm);\n\tsm501_dump_gate(sm);\n\tsm501_dump_clk(sm);\n\n\t \n\n\tif (smc501_readl(sm->regs + SM501_MISC_CONTROL) != sm->pm_misc) {\n\t\tdev_info(sm->dev, \"SM501_MISC_CONTROL changed over sleep\\n\");\n\t\tsmc501_writel(sm->pm_misc, sm->regs + SM501_MISC_CONTROL);\n\n\t\t \n\n\t\tif (sm->platdata && sm->platdata->init) {\n\t\t\tsm501_init_regs(sm, sm->platdata->init);\n\t\t}\n\t}\n\n\t \n\n\tsm501_dump_regs(sm);\n\tsm501_dump_clk(sm);\n\n\tsm->in_suspend = 0;\n\n\treturn 0;\n}\n\n \n\nstatic struct sm501_initdata sm501_pci_initdata = {\n\t.gpio_high\t= {\n\t\t.set\t= 0x3F000000,\t\t \n\t\t.mask\t= 0x0,\n\t},\n\t.misc_timing\t= {\n\t\t.set\t= 0x010100,\t\t \n\t\t.mask\t= 0x1F1F00,\n\t},\n\t.misc_control\t= {\n\t\t.set\t= SM501_MISC_PNL_24BIT,\n\t\t.mask\t= 0,\n\t},\n\n\t.devices\t= SM501_USE_ALL,\n\n\t \n\n\t.mclk\t\t= 72 * MHZ,\n\t.m1xclk\t\t= 144 * MHZ,\n};\n\nstatic struct sm501_platdata_fbsub sm501_pdata_fbsub = {\n\t.flags\t\t= (SM501FB_FLAG_USE_INIT_MODE |\n\t\t\t   SM501FB_FLAG_USE_HWCURSOR |\n\t\t\t   SM501FB_FLAG_USE_HWACCEL |\n\t\t\t   SM501FB_FLAG_DISABLE_AT_EXIT),\n};\n\nstatic struct sm501_platdata_fb sm501_fb_pdata = {\n\t.fb_route\t= SM501_FB_OWN,\n\t.fb_crt\t\t= &sm501_pdata_fbsub,\n\t.fb_pnl\t\t= &sm501_pdata_fbsub,\n};\n\nstatic struct sm501_platdata sm501_pci_platdata = {\n\t.init\t\t= &sm501_pci_initdata,\n\t.fb\t\t= &sm501_fb_pdata,\n\t.gpio_base\t= -1,\n};\n\nstatic int sm501_pci_probe(struct pci_dev *dev,\n\t\t\t\t     const struct pci_device_id *id)\n{\n\tstruct sm501_devdata *sm;\n\tint err;\n\n\tsm = kzalloc(sizeof(*sm), GFP_KERNEL);\n\tif (!sm) {\n\t\terr = -ENOMEM;\n\t\tgoto err1;\n\t}\n\n\t \n\tdev->dev.platform_data = sm->platdata = &sm501_pci_platdata;\n\n\t \n\tsm->pdev_id = 32 + dev->devfn;\n\n\tpci_set_drvdata(dev, sm);\n\n\terr = pci_enable_device(dev);\n\tif (err) {\n\t\tdev_err(&dev->dev, \"cannot enable device\\n\");\n\t\tgoto err2;\n\t}\n\n\tsm->dev = &dev->dev;\n\tsm->irq = dev->irq;\n\n#ifdef __BIG_ENDIAN\n\t \n\n\tsm501_fb_pdata.flags |= SM501_FBPD_SWAP_FB_ENDIAN;\n#endif\n\n\t \n\n\tif (!(pci_resource_flags(dev, 0) & IORESOURCE_MEM)) {\n\t\tdev_err(&dev->dev, \"region #0 is not memory?\\n\");\n\t\terr = -EINVAL;\n\t\tgoto err3;\n\t}\n\n\tif (!(pci_resource_flags(dev, 1) & IORESOURCE_MEM)) {\n\t\tdev_err(&dev->dev, \"region #1 is not memory?\\n\");\n\t\terr = -EINVAL;\n\t\tgoto err3;\n\t}\n\n\t \n\n\tsm->io_res = &dev->resource[1];\n\tsm->mem_res = &dev->resource[0];\n\n\tsm->regs_claim = request_mem_region(sm->io_res->start,\n\t\t\t\t\t    0x100, \"sm501\");\n\tif (!sm->regs_claim) {\n\t\tdev_err(&dev->dev, \"cannot claim registers\\n\");\n\t\terr= -EBUSY;\n\t\tgoto err3;\n\t}\n\n\tsm->regs = pci_ioremap_bar(dev, 1);\n\tif (!sm->regs) {\n\t\tdev_err(&dev->dev, \"cannot remap registers\\n\");\n\t\terr = -EIO;\n\t\tgoto err4;\n\t}\n\n\tsm501_init_dev(sm);\n\treturn 0;\n\n err4:\n\trelease_mem_region(sm->io_res->start, 0x100);\n err3:\n\tpci_disable_device(dev);\n err2:\n\tkfree(sm);\n err1:\n\treturn err;\n}\n\nstatic void sm501_remove_sub(struct sm501_devdata *sm,\n\t\t\t     struct sm501_device *smdev)\n{\n\tlist_del(&smdev->list);\n\tplatform_device_unregister(&smdev->pdev);\n}\n\nstatic void sm501_dev_remove(struct sm501_devdata *sm)\n{\n\tstruct sm501_device *smdev, *tmp;\n\n\tlist_for_each_entry_safe(smdev, tmp, &sm->devices, list)\n\t\tsm501_remove_sub(sm, smdev);\n\n\tdevice_remove_file(sm->dev, &dev_attr_dbg_regs);\n\n\tsm501_gpio_remove(sm);\n}\n\nstatic void sm501_pci_remove(struct pci_dev *dev)\n{\n\tstruct sm501_devdata *sm = pci_get_drvdata(dev);\n\n\tsm501_dev_remove(sm);\n\tiounmap(sm->regs);\n\n\trelease_mem_region(sm->io_res->start, 0x100);\n\n\tpci_disable_device(dev);\n}\n\nstatic int sm501_plat_remove(struct platform_device *dev)\n{\n\tstruct sm501_devdata *sm = platform_get_drvdata(dev);\n\n\tsm501_dev_remove(sm);\n\tiounmap(sm->regs);\n\n\trelease_mem_region(sm->io_res->start, 0x100);\n\n\treturn 0;\n}\n\nstatic const struct pci_device_id sm501_pci_tbl[] = {\n\t{ 0x126f, 0x0501, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },\n\t{ 0, },\n};\n\nMODULE_DEVICE_TABLE(pci, sm501_pci_tbl);\n\nstatic struct pci_driver sm501_pci_driver = {\n\t.name\t\t= \"sm501\",\n\t.id_table\t= sm501_pci_tbl,\n\t.probe\t\t= sm501_pci_probe,\n\t.remove\t\t= sm501_pci_remove,\n};\n\nMODULE_ALIAS(\"platform:sm501\");\n\nstatic const struct of_device_id of_sm501_match_tbl[] = {\n\t{ .compatible = \"smi,sm501\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, of_sm501_match_tbl);\n\nstatic struct platform_driver sm501_plat_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"sm501\",\n\t\t.of_match_table = of_sm501_match_tbl,\n\t},\n\t.probe\t\t= sm501_plat_probe,\n\t.remove\t\t= sm501_plat_remove,\n\t.suspend\t= pm_sleep_ptr(sm501_plat_suspend),\n\t.resume\t\t= pm_sleep_ptr(sm501_plat_resume),\n};\n\nstatic int __init sm501_base_init(void)\n{\n\tint ret;\n\n\tret = platform_driver_register(&sm501_plat_driver);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn pci_register_driver(&sm501_pci_driver);\n}\n\nstatic void __exit sm501_base_exit(void)\n{\n\tplatform_driver_unregister(&sm501_plat_driver);\n\tpci_unregister_driver(&sm501_pci_driver);\n}\n\nmodule_init(sm501_base_init);\nmodule_exit(sm501_base_exit);\n\nMODULE_DESCRIPTION(\"SM501 Core Driver\");\nMODULE_AUTHOR(\"Ben Dooks <ben@simtec.co.uk>, Vincent Sanders\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}