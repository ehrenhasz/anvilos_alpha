{
  "module_name": "ucb1x00-ts.c",
  "hash_id": "99126892e94acbd3132f7e9fb82c0b3a32e1e4e3fa952eaee65711261a188a44",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/ucb1x00-ts.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/input.h>\n#include <linux/device.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/mfd/ucb1x00.h>\n\n#include <mach/collie.h>\n#include <asm/mach-types.h>\n\n\n\nstruct ucb1x00_ts {\n\tstruct input_dev\t*idev;\n\tstruct ucb1x00\t\t*ucb;\n\n\tspinlock_t\t\tirq_lock;\n\tunsigned\t\tirq_disabled;\n\twait_queue_head_t\tirq_wait;\n\tstruct task_struct\t*rtask;\n\tu16\t\t\tx_res;\n\tu16\t\t\ty_res;\n\n\tunsigned int\t\tadcsync:1;\n};\n\nstatic int adcsync;\n\nstatic inline void ucb1x00_ts_evt_add(struct ucb1x00_ts *ts, u16 pressure, u16 x, u16 y)\n{\n\tstruct input_dev *idev = ts->idev;\n\n\tinput_report_abs(idev, ABS_X, x);\n\tinput_report_abs(idev, ABS_Y, y);\n\tinput_report_abs(idev, ABS_PRESSURE, pressure);\n\tinput_report_key(idev, BTN_TOUCH, 1);\n\tinput_sync(idev);\n}\n\nstatic inline void ucb1x00_ts_event_release(struct ucb1x00_ts *ts)\n{\n\tstruct input_dev *idev = ts->idev;\n\n\tinput_report_abs(idev, ABS_PRESSURE, 0);\n\tinput_report_key(idev, BTN_TOUCH, 0);\n\tinput_sync(idev);\n}\n\n \nstatic inline void ucb1x00_ts_mode_int(struct ucb1x00_ts *ts)\n{\n\tucb1x00_reg_write(ts->ucb, UCB_TS_CR,\n\t\t\tUCB_TS_CR_TSMX_POW | UCB_TS_CR_TSPX_POW |\n\t\t\tUCB_TS_CR_TSMY_GND | UCB_TS_CR_TSPY_GND |\n\t\t\tUCB_TS_CR_MODE_INT);\n}\n\n \nstatic inline unsigned int ucb1x00_ts_read_pressure(struct ucb1x00_ts *ts)\n{\n\tif (machine_is_collie()) {\n\t\tucb1x00_io_write(ts->ucb, COLLIE_TC35143_GPIO_TBL_CHK, 0);\n\t\tucb1x00_reg_write(ts->ucb, UCB_TS_CR,\n\t\t\t\t  UCB_TS_CR_TSPX_POW | UCB_TS_CR_TSMX_POW |\n\t\t\t\t  UCB_TS_CR_MODE_POS | UCB_TS_CR_BIAS_ENA);\n\n\t\tudelay(55);\n\n\t\treturn ucb1x00_adc_read(ts->ucb, UCB_ADC_INP_AD2, ts->adcsync);\n\t} else {\n\t\tucb1x00_reg_write(ts->ucb, UCB_TS_CR,\n\t\t\t\t  UCB_TS_CR_TSMX_POW | UCB_TS_CR_TSPX_POW |\n\t\t\t\t  UCB_TS_CR_TSMY_GND | UCB_TS_CR_TSPY_GND |\n\t\t\t\t  UCB_TS_CR_MODE_PRES | UCB_TS_CR_BIAS_ENA);\n\n\t\treturn ucb1x00_adc_read(ts->ucb, UCB_ADC_INP_TSPY, ts->adcsync);\n\t}\n}\n\n \nstatic inline unsigned int ucb1x00_ts_read_xpos(struct ucb1x00_ts *ts)\n{\n\tif (machine_is_collie())\n\t\tucb1x00_io_write(ts->ucb, 0, COLLIE_TC35143_GPIO_TBL_CHK);\n\telse {\n\t\tucb1x00_reg_write(ts->ucb, UCB_TS_CR,\n\t\t\t\t  UCB_TS_CR_TSMX_GND | UCB_TS_CR_TSPX_POW |\n\t\t\t\t  UCB_TS_CR_MODE_PRES | UCB_TS_CR_BIAS_ENA);\n\t\tucb1x00_reg_write(ts->ucb, UCB_TS_CR,\n\t\t\t\t  UCB_TS_CR_TSMX_GND | UCB_TS_CR_TSPX_POW |\n\t\t\t\t  UCB_TS_CR_MODE_PRES | UCB_TS_CR_BIAS_ENA);\n\t}\n\tucb1x00_reg_write(ts->ucb, UCB_TS_CR,\n\t\t\tUCB_TS_CR_TSMX_GND | UCB_TS_CR_TSPX_POW |\n\t\t\tUCB_TS_CR_MODE_POS | UCB_TS_CR_BIAS_ENA);\n\n\tudelay(55);\n\n\treturn ucb1x00_adc_read(ts->ucb, UCB_ADC_INP_TSPY, ts->adcsync);\n}\n\n \nstatic inline unsigned int ucb1x00_ts_read_ypos(struct ucb1x00_ts *ts)\n{\n\tif (machine_is_collie())\n\t\tucb1x00_io_write(ts->ucb, 0, COLLIE_TC35143_GPIO_TBL_CHK);\n\telse {\n\t\tucb1x00_reg_write(ts->ucb, UCB_TS_CR,\n\t\t\t\t  UCB_TS_CR_TSMY_GND | UCB_TS_CR_TSPY_POW |\n\t\t\t\t  UCB_TS_CR_MODE_PRES | UCB_TS_CR_BIAS_ENA);\n\t\tucb1x00_reg_write(ts->ucb, UCB_TS_CR,\n\t\t\t\t  UCB_TS_CR_TSMY_GND | UCB_TS_CR_TSPY_POW |\n\t\t\t\t  UCB_TS_CR_MODE_PRES | UCB_TS_CR_BIAS_ENA);\n\t}\n\n\tucb1x00_reg_write(ts->ucb, UCB_TS_CR,\n\t\t\tUCB_TS_CR_TSMY_GND | UCB_TS_CR_TSPY_POW |\n\t\t\tUCB_TS_CR_MODE_POS | UCB_TS_CR_BIAS_ENA);\n\n\tudelay(55);\n\n\treturn ucb1x00_adc_read(ts->ucb, UCB_ADC_INP_TSPX, ts->adcsync);\n}\n\n \nstatic inline unsigned int ucb1x00_ts_read_xres(struct ucb1x00_ts *ts)\n{\n\tucb1x00_reg_write(ts->ucb, UCB_TS_CR,\n\t\t\tUCB_TS_CR_TSMX_GND | UCB_TS_CR_TSPX_POW |\n\t\t\tUCB_TS_CR_MODE_PRES | UCB_TS_CR_BIAS_ENA);\n\treturn ucb1x00_adc_read(ts->ucb, 0, ts->adcsync);\n}\n\n \nstatic inline unsigned int ucb1x00_ts_read_yres(struct ucb1x00_ts *ts)\n{\n\tucb1x00_reg_write(ts->ucb, UCB_TS_CR,\n\t\t\tUCB_TS_CR_TSMY_GND | UCB_TS_CR_TSPY_POW |\n\t\t\tUCB_TS_CR_MODE_PRES | UCB_TS_CR_BIAS_ENA);\n\treturn ucb1x00_adc_read(ts->ucb, 0, ts->adcsync);\n}\n\nstatic inline int ucb1x00_ts_pen_down(struct ucb1x00_ts *ts)\n{\n\tunsigned int val = ucb1x00_reg_read(ts->ucb, UCB_TS_CR);\n\n\tif (machine_is_collie())\n\t\treturn (!(val & (UCB_TS_CR_TSPX_LOW)));\n\telse\n\t\treturn (val & (UCB_TS_CR_TSPX_LOW | UCB_TS_CR_TSMX_LOW));\n}\n\n \nstatic int ucb1x00_thread(void *_ts)\n{\n\tstruct ucb1x00_ts *ts = _ts;\n\tDECLARE_WAITQUEUE(wait, current);\n\tbool frozen, ignore = false;\n\tint valid = 0;\n\n\tset_freezable();\n\tadd_wait_queue(&ts->irq_wait, &wait);\n\twhile (!kthread_freezable_should_stop(&frozen)) {\n\t\tunsigned int x, y, p;\n\t\tsigned long timeout;\n\n\t\tif (frozen)\n\t\t\tignore = true;\n\n\t\tucb1x00_adc_enable(ts->ucb);\n\n\t\tx = ucb1x00_ts_read_xpos(ts);\n\t\ty = ucb1x00_ts_read_ypos(ts);\n\t\tp = ucb1x00_ts_read_pressure(ts);\n\n\t\t \n\t\tucb1x00_ts_mode_int(ts);\n\t\tucb1x00_adc_disable(ts->ucb);\n\n\t\tmsleep(10);\n\n\t\tucb1x00_enable(ts->ucb);\n\n\n\t\tif (ucb1x00_ts_pen_down(ts)) {\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t\t\tspin_lock_irq(&ts->irq_lock);\n\t\t\tif (ts->irq_disabled) {\n\t\t\t\tts->irq_disabled = 0;\n\t\t\t\tenable_irq(ts->ucb->irq_base + UCB_IRQ_TSPX);\n\t\t\t}\n\t\t\tspin_unlock_irq(&ts->irq_lock);\n\t\t\tucb1x00_disable(ts->ucb);\n\n\t\t\t \n\t\t\tif (valid) {\n\t\t\t\tucb1x00_ts_event_release(ts);\n\t\t\t\tvalid = 0;\n\t\t\t}\n\n\t\t\ttimeout = MAX_SCHEDULE_TIMEOUT;\n\t\t} else {\n\t\t\tucb1x00_disable(ts->ucb);\n\n\t\t\t \n\t\t\tif (!ignore) {\n\t\t\t\tucb1x00_ts_evt_add(ts, p, x, y);\n\t\t\t\tvalid = 1;\n\t\t\t}\n\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\ttimeout = HZ / 100;\n\t\t}\n\n\t\tschedule_timeout(timeout);\n\t}\n\n\tremove_wait_queue(&ts->irq_wait, &wait);\n\n\tts->rtask = NULL;\n\treturn 0;\n}\n\n \nstatic irqreturn_t ucb1x00_ts_irq(int irq, void *id)\n{\n\tstruct ucb1x00_ts *ts = id;\n\n\tspin_lock(&ts->irq_lock);\n\tts->irq_disabled = 1;\n\tdisable_irq_nosync(ts->ucb->irq_base + UCB_IRQ_TSPX);\n\tspin_unlock(&ts->irq_lock);\n\twake_up(&ts->irq_wait);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ucb1x00_ts_open(struct input_dev *idev)\n{\n\tstruct ucb1x00_ts *ts = input_get_drvdata(idev);\n\tunsigned long flags = 0;\n\tint ret = 0;\n\n\tBUG_ON(ts->rtask);\n\n\tif (machine_is_collie())\n\t\tflags = IRQF_TRIGGER_RISING;\n\telse\n\t\tflags = IRQF_TRIGGER_FALLING;\n\n\tts->irq_disabled = 0;\n\n\tinit_waitqueue_head(&ts->irq_wait);\n\tret = request_irq(ts->ucb->irq_base + UCB_IRQ_TSPX, ucb1x00_ts_irq,\n\t\t\t  flags, \"ucb1x00-ts\", ts);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tucb1x00_adc_enable(ts->ucb);\n\tts->x_res = ucb1x00_ts_read_xres(ts);\n\tts->y_res = ucb1x00_ts_read_yres(ts);\n\tucb1x00_adc_disable(ts->ucb);\n\n\tts->rtask = kthread_run(ucb1x00_thread, ts, \"ktsd\");\n\tif (!IS_ERR(ts->rtask)) {\n\t\tret = 0;\n\t} else {\n\t\tfree_irq(ts->ucb->irq_base + UCB_IRQ_TSPX, ts);\n\t\tts->rtask = NULL;\n\t\tret = -EFAULT;\n\t}\n\n out:\n\treturn ret;\n}\n\n \nstatic void ucb1x00_ts_close(struct input_dev *idev)\n{\n\tstruct ucb1x00_ts *ts = input_get_drvdata(idev);\n\n\tif (ts->rtask)\n\t\tkthread_stop(ts->rtask);\n\n\tucb1x00_enable(ts->ucb);\n\tfree_irq(ts->ucb->irq_base + UCB_IRQ_TSPX, ts);\n\tucb1x00_reg_write(ts->ucb, UCB_TS_CR, 0);\n\tucb1x00_disable(ts->ucb);\n}\n\n\n \nstatic int ucb1x00_ts_add(struct ucb1x00_dev *dev)\n{\n\tstruct ucb1x00_ts *ts;\n\tstruct input_dev *idev;\n\tint err;\n\n\tts = kzalloc(sizeof(struct ucb1x00_ts), GFP_KERNEL);\n\tidev = input_allocate_device();\n\tif (!ts || !idev) {\n\t\terr = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tts->ucb = dev->ucb;\n\tts->idev = idev;\n\tts->adcsync = adcsync ? UCB_SYNC : UCB_NOSYNC;\n\tspin_lock_init(&ts->irq_lock);\n\n\tidev->name       = \"Touchscreen panel\";\n\tidev->id.product = ts->ucb->id;\n\tidev->open       = ucb1x00_ts_open;\n\tidev->close      = ucb1x00_ts_close;\n\tidev->dev.parent = &ts->ucb->dev;\n\n\tidev->evbit[0]   = BIT_MASK(EV_ABS) | BIT_MASK(EV_KEY);\n\tidev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);\n\n\tinput_set_drvdata(idev, ts);\n\n\tucb1x00_adc_enable(ts->ucb);\n\tts->x_res = ucb1x00_ts_read_xres(ts);\n\tts->y_res = ucb1x00_ts_read_yres(ts);\n\tucb1x00_adc_disable(ts->ucb);\n\n\tinput_set_abs_params(idev, ABS_X, 0, ts->x_res, 0, 0);\n\tinput_set_abs_params(idev, ABS_Y, 0, ts->y_res, 0, 0);\n\tinput_set_abs_params(idev, ABS_PRESSURE, 0, 0, 0, 0);\n\n\terr = input_register_device(idev);\n\tif (err)\n\t\tgoto fail;\n\n\tdev->priv = ts;\n\n\treturn 0;\n\n fail:\n\tinput_free_device(idev);\n\tkfree(ts);\n\treturn err;\n}\n\nstatic void ucb1x00_ts_remove(struct ucb1x00_dev *dev)\n{\n\tstruct ucb1x00_ts *ts = dev->priv;\n\n\tinput_unregister_device(ts->idev);\n\tkfree(ts);\n}\n\nstatic struct ucb1x00_driver ucb1x00_ts_driver = {\n\t.add\t\t= ucb1x00_ts_add,\n\t.remove\t\t= ucb1x00_ts_remove,\n};\n\nstatic int __init ucb1x00_ts_init(void)\n{\n\treturn ucb1x00_register_driver(&ucb1x00_ts_driver);\n}\n\nstatic void __exit ucb1x00_ts_exit(void)\n{\n\tucb1x00_unregister_driver(&ucb1x00_ts_driver);\n}\n\nmodule_param(adcsync, int, 0444);\nmodule_init(ucb1x00_ts_init);\nmodule_exit(ucb1x00_ts_exit);\n\nMODULE_AUTHOR(\"Russell King <rmk@arm.linux.org.uk>\");\nMODULE_DESCRIPTION(\"UCB1x00 touchscreen driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}