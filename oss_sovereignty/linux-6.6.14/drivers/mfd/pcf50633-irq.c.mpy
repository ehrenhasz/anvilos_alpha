{
  "module_name": "pcf50633-irq.c",
  "hash_id": "519eaac92e23dd24fdea9287bd7d45b3594b2844d4c6a4bba413eda00129bdc0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/pcf50633-irq.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\n#include <linux/mfd/pcf50633/core.h>\n#include <linux/mfd/pcf50633/mbc.h>\n\nint pcf50633_register_irq(struct pcf50633 *pcf, int irq,\n\t\t\tvoid (*handler) (int, void *), void *data)\n{\n\tif (irq < 0 || irq >= PCF50633_NUM_IRQ || !handler)\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(pcf->irq_handler[irq].handler))\n\t\treturn -EBUSY;\n\n\tmutex_lock(&pcf->lock);\n\tpcf->irq_handler[irq].handler = handler;\n\tpcf->irq_handler[irq].data = data;\n\tmutex_unlock(&pcf->lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(pcf50633_register_irq);\n\nint pcf50633_free_irq(struct pcf50633 *pcf, int irq)\n{\n\tif (irq < 0 || irq >= PCF50633_NUM_IRQ)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&pcf->lock);\n\tpcf->irq_handler[irq].handler = NULL;\n\tmutex_unlock(&pcf->lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(pcf50633_free_irq);\n\nstatic int __pcf50633_irq_mask_set(struct pcf50633 *pcf, int irq, u8 mask)\n{\n\tu8 reg, bit;\n\tint idx;\n\n\tidx = irq >> 3;\n\treg = PCF50633_REG_INT1M + idx;\n\tbit = 1 << (irq & 0x07);\n\n\tpcf50633_reg_set_bit_mask(pcf, reg, bit, mask ? bit : 0);\n\n\tmutex_lock(&pcf->lock);\n\n\tif (mask)\n\t\tpcf->mask_regs[idx] |= bit;\n\telse\n\t\tpcf->mask_regs[idx] &= ~bit;\n\n\tmutex_unlock(&pcf->lock);\n\n\treturn 0;\n}\n\nint pcf50633_irq_mask(struct pcf50633 *pcf, int irq)\n{\n\tdev_dbg(pcf->dev, \"Masking IRQ %d\\n\", irq);\n\n\treturn __pcf50633_irq_mask_set(pcf, irq, 1);\n}\nEXPORT_SYMBOL_GPL(pcf50633_irq_mask);\n\nint pcf50633_irq_unmask(struct pcf50633 *pcf, int irq)\n{\n\tdev_dbg(pcf->dev, \"Unmasking IRQ %d\\n\", irq);\n\n\treturn __pcf50633_irq_mask_set(pcf, irq, 0);\n}\nEXPORT_SYMBOL_GPL(pcf50633_irq_unmask);\n\nint pcf50633_irq_mask_get(struct pcf50633 *pcf, int irq)\n{\n\tu8 reg, bits;\n\n\treg =  irq >> 3;\n\tbits = 1 << (irq & 0x07);\n\n\treturn pcf->mask_regs[reg] & bits;\n}\nEXPORT_SYMBOL_GPL(pcf50633_irq_mask_get);\n\nstatic void pcf50633_irq_call_handler(struct pcf50633 *pcf, int irq)\n{\n\tif (pcf->irq_handler[irq].handler)\n\t\tpcf->irq_handler[irq].handler(irq, pcf->irq_handler[irq].data);\n}\n\n \n#define PCF50633_ONKEY1S_TIMEOUT 8\n\nstatic irqreturn_t pcf50633_irq(int irq, void *data)\n{\n\tstruct pcf50633 *pcf = data;\n\tint ret, i, j;\n\tu8 pcf_int[5], chgstat;\n\n\t \n\tret = pcf50633_read_block(pcf, PCF50633_REG_INT1,\n\t\t\t\t\t\tARRAY_SIZE(pcf_int), pcf_int);\n\tif (ret != ARRAY_SIZE(pcf_int)) {\n\t\tdev_err(pcf->dev, \"Error reading INT registers\\n\");\n\n\t\t \n\t\tgoto out;\n\t}\n\n\t \n\tpcf50633_reg_write(pcf, PCF50633_REG_OOCSHDWN,  0x04);\n\n\t \n\tif (pcf_int[0] & (PCF50633_INT1_USBINS | PCF50633_INT1_USBREM)) {\n\t\tchgstat = pcf50633_reg_read(pcf, PCF50633_REG_MBCS2);\n\t\tif (chgstat & (0x3 << 4))\n\t\t\tpcf_int[0] &= ~PCF50633_INT1_USBREM;\n\t\telse\n\t\t\tpcf_int[0] &= ~PCF50633_INT1_USBINS;\n\t}\n\n\t \n\tif (pcf_int[0] & (PCF50633_INT1_ADPINS | PCF50633_INT1_ADPREM)) {\n\t\tchgstat = pcf50633_reg_read(pcf, PCF50633_REG_MBCS2);\n\t\tif (chgstat & (0x3 << 4))\n\t\t\tpcf_int[0] &= ~PCF50633_INT1_ADPREM;\n\t\telse\n\t\t\tpcf_int[0] &= ~PCF50633_INT1_ADPINS;\n\t}\n\n\tdev_dbg(pcf->dev, \"INT1=0x%02x INT2=0x%02x INT3=0x%02x \"\n\t\t\t\"INT4=0x%02x INT5=0x%02x\\n\", pcf_int[0],\n\t\t\tpcf_int[1], pcf_int[2], pcf_int[3], pcf_int[4]);\n\n\t \n\tif ((pcf_int[0] & PCF50633_INT1_SECOND) && pcf->onkey1s_held) {\n\t\tdev_info(pcf->dev, \"ONKEY1S held for %d secs\\n\",\n\t\t\t\t\t\t\tpcf->onkey1s_held);\n\t\tif (pcf->onkey1s_held++ == PCF50633_ONKEY1S_TIMEOUT)\n\t\t\tif (pcf->pdata->force_shutdown)\n\t\t\t\tpcf->pdata->force_shutdown(pcf);\n\t}\n\n\tif (pcf_int[2] & PCF50633_INT3_ONKEY1S) {\n\t\tdev_info(pcf->dev, \"ONKEY1S held\\n\");\n\t\tpcf->onkey1s_held = 1 ;\n\n\t\t \n\t\tpcf50633_reg_clear_bits(pcf, PCF50633_REG_INT1M,\n\t\t\t\t\t\tPCF50633_INT1_SECOND);\n\n\t\t \n\t\tpcf50633_reg_clear_bits(pcf, PCF50633_REG_INT2M,\n\t\t\t\t\t\tPCF50633_INT2_ONKEYR);\n\t}\n\n\tif ((pcf_int[1] & PCF50633_INT2_ONKEYR) && pcf->onkey1s_held) {\n\t\tpcf->onkey1s_held = 0;\n\n\t\t \n\t\tif (pcf->mask_regs[0] & PCF50633_INT1_SECOND)\n\t\t\tpcf50633_reg_set_bit_mask(pcf,\n\t\t\t\t\tPCF50633_REG_INT1M,\n\t\t\t\t\tPCF50633_INT1_SECOND,\n\t\t\t\t\tPCF50633_INT1_SECOND);\n\n\t\tif (pcf->mask_regs[1] & PCF50633_INT2_ONKEYR)\n\t\t\tpcf50633_reg_set_bit_mask(pcf,\n\t\t\t\t\tPCF50633_REG_INT2M,\n\t\t\t\t\tPCF50633_INT2_ONKEYR,\n\t\t\t\t\tPCF50633_INT2_ONKEYR);\n\t}\n\n\t \n\tif (pcf->is_suspended) {\n\t\tpcf->is_suspended = 0;\n\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(pcf_int); i++)\n\t\t\tpcf->resume_reason[i] = pcf_int[i] &\n\t\t\t\t\t\tpcf->pdata->resumers[i];\n\n\t\t \n\t\tpcf_int[1] &= ~(PCF50633_INT2_ONKEYR | PCF50633_INT2_ONKEYF);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(pcf_int); i++) {\n\t\t \n\t\tpcf_int[i] &= ~pcf->mask_regs[i];\n\n\t\tfor (j = 0; j < 8 ; j++)\n\t\t\tif (pcf_int[i] & (1 << j))\n\t\t\t\tpcf50633_irq_call_handler(pcf, (i * 8) + j);\n\t}\n\nout:\n\treturn IRQ_HANDLED;\n}\n\nstatic int pcf50633_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct pcf50633 *pcf = i2c_get_clientdata(client);\n\tint ret;\n\tint i;\n\tu8 res[5];\n\n\n\t \n\tdisable_irq(pcf->irq);\n\n\t \n\tret = pcf50633_read_block(pcf, PCF50633_REG_INT1M,\n\t\t\t\tARRAY_SIZE(pcf->suspend_irq_masks),\n\t\t\t\t\tpcf->suspend_irq_masks);\n\tif (ret < 0) {\n\t\tdev_err(pcf->dev, \"error saving irq masks\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(res); i++)\n\t\tres[i] = ~pcf->pdata->resumers[i];\n\n\tret = pcf50633_write_block(pcf, PCF50633_REG_INT1M,\n\t\t\t\t\tARRAY_SIZE(res), &res[0]);\n\tif (ret < 0) {\n\t\tdev_err(pcf->dev, \"error writing wakeup irq masks\\n\");\n\t\tgoto out;\n\t}\n\n\tpcf->is_suspended = 1;\n\nout:\n\treturn ret;\n}\n\nstatic int pcf50633_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct pcf50633 *pcf = i2c_get_clientdata(client);\n\tint ret;\n\n\t \n\tret = pcf50633_write_block(pcf, PCF50633_REG_INT1M,\n\t\t\t\tARRAY_SIZE(pcf->suspend_irq_masks),\n\t\t\t\t\tpcf->suspend_irq_masks);\n\tif (ret < 0)\n\t\tdev_err(pcf->dev, \"Error restoring saved suspend masks\\n\");\n\n\tenable_irq(pcf->irq);\n\n\treturn ret;\n}\n\nEXPORT_GPL_SIMPLE_DEV_PM_OPS(pcf50633_pm, pcf50633_suspend, pcf50633_resume);\n\nint pcf50633_irq_init(struct pcf50633 *pcf, int irq)\n{\n\tint ret;\n\n\tpcf->irq = irq;\n\n\t \n\tpcf->mask_regs[0] = 0x80;\n\tpcf50633_reg_write(pcf, PCF50633_REG_INT1M, pcf->mask_regs[0]);\n\tpcf50633_reg_write(pcf, PCF50633_REG_INT2M, 0x00);\n\tpcf50633_reg_write(pcf, PCF50633_REG_INT3M, 0x00);\n\tpcf50633_reg_write(pcf, PCF50633_REG_INT4M, 0x00);\n\tpcf50633_reg_write(pcf, PCF50633_REG_INT5M, 0x00);\n\n\tret = request_threaded_irq(irq, NULL, pcf50633_irq,\n\t\t\t\t\tIRQF_TRIGGER_LOW | IRQF_ONESHOT,\n\t\t\t\t\t\"pcf50633\", pcf);\n\n\tif (ret)\n\t\tdev_err(pcf->dev, \"Failed to request IRQ %d\\n\", ret);\n\n\tif (enable_irq_wake(irq) < 0)\n\t\tdev_err(pcf->dev, \"IRQ %u cannot be enabled as wake-up source\"\n\t\t\t\"in this hardware revision\", irq);\n\n\treturn ret;\n}\n\nvoid pcf50633_irq_free(struct pcf50633 *pcf)\n{\n\tfree_irq(pcf->irq, pcf);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}