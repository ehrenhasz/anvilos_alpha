{
  "module_name": "menelaus.c",
  "hash_id": "8abaa0447643121e2a92265a4ad39d49c170d3c7e04360b546b2e40a3915db0d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/menelaus.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/workqueue.h>\n#include <linux/delay.h>\n#include <linux/rtc.h>\n#include <linux/bcd.h>\n#include <linux/slab.h>\n#include <linux/mfd/menelaus.h>\n#include <linux/gpio.h>\n\n#include <asm/mach/irq.h>\n\n\n#define DRIVER_NAME\t\t\t\"menelaus\"\n\n#define MENELAUS_I2C_ADDRESS\t\t0x72\n\n#define MENELAUS_REV\t\t\t0x01\n#define MENELAUS_VCORE_CTRL1\t\t0x02\n#define MENELAUS_VCORE_CTRL2\t\t0x03\n#define MENELAUS_VCORE_CTRL3\t\t0x04\n#define MENELAUS_VCORE_CTRL4\t\t0x05\n#define MENELAUS_VCORE_CTRL5\t\t0x06\n#define MENELAUS_DCDC_CTRL1\t\t0x07\n#define MENELAUS_DCDC_CTRL2\t\t0x08\n#define MENELAUS_DCDC_CTRL3\t\t0x09\n#define MENELAUS_LDO_CTRL1\t\t0x0A\n#define MENELAUS_LDO_CTRL2\t\t0x0B\n#define MENELAUS_LDO_CTRL3\t\t0x0C\n#define MENELAUS_LDO_CTRL4\t\t0x0D\n#define MENELAUS_LDO_CTRL5\t\t0x0E\n#define MENELAUS_LDO_CTRL6\t\t0x0F\n#define MENELAUS_LDO_CTRL7\t\t0x10\n#define MENELAUS_LDO_CTRL8\t\t0x11\n#define MENELAUS_SLEEP_CTRL1\t\t0x12\n#define MENELAUS_SLEEP_CTRL2\t\t0x13\n#define MENELAUS_DEVICE_OFF\t\t0x14\n#define MENELAUS_OSC_CTRL\t\t0x15\n#define MENELAUS_DETECT_CTRL\t\t0x16\n#define MENELAUS_INT_MASK1\t\t0x17\n#define MENELAUS_INT_MASK2\t\t0x18\n#define MENELAUS_INT_STATUS1\t\t0x19\n#define MENELAUS_INT_STATUS2\t\t0x1A\n#define MENELAUS_INT_ACK1\t\t0x1B\n#define MENELAUS_INT_ACK2\t\t0x1C\n#define MENELAUS_GPIO_CTRL\t\t0x1D\n#define MENELAUS_GPIO_IN\t\t0x1E\n#define MENELAUS_GPIO_OUT\t\t0x1F\n#define MENELAUS_BBSMS\t\t\t0x20\n#define MENELAUS_RTC_CTRL\t\t0x21\n#define MENELAUS_RTC_UPDATE\t\t0x22\n#define MENELAUS_RTC_SEC\t\t0x23\n#define MENELAUS_RTC_MIN\t\t0x24\n#define MENELAUS_RTC_HR\t\t\t0x25\n#define MENELAUS_RTC_DAY\t\t0x26\n#define MENELAUS_RTC_MON\t\t0x27\n#define MENELAUS_RTC_YR\t\t\t0x28\n#define MENELAUS_RTC_WKDAY\t\t0x29\n#define MENELAUS_RTC_AL_SEC\t\t0x2A\n#define MENELAUS_RTC_AL_MIN\t\t0x2B\n#define MENELAUS_RTC_AL_HR\t\t0x2C\n#define MENELAUS_RTC_AL_DAY\t\t0x2D\n#define MENELAUS_RTC_AL_MON\t\t0x2E\n#define MENELAUS_RTC_AL_YR\t\t0x2F\n#define MENELAUS_RTC_COMP_MSB\t\t0x30\n#define MENELAUS_RTC_COMP_LSB\t\t0x31\n#define MENELAUS_S1_PULL_EN\t\t0x32\n#define MENELAUS_S1_PULL_DIR\t\t0x33\n#define MENELAUS_S2_PULL_EN\t\t0x34\n#define MENELAUS_S2_PULL_DIR\t\t0x35\n#define MENELAUS_MCT_CTRL1\t\t0x36\n#define MENELAUS_MCT_CTRL2\t\t0x37\n#define MENELAUS_MCT_CTRL3\t\t0x38\n#define MENELAUS_MCT_PIN_ST\t\t0x39\n#define MENELAUS_DEBOUNCE1\t\t0x3A\n\n#define IH_MENELAUS_IRQS\t\t12\n#define MENELAUS_MMC_S1CD_IRQ\t\t0\t \n#define MENELAUS_MMC_S2CD_IRQ\t\t1\t \n#define MENELAUS_MMC_S1D1_IRQ\t\t2\t \n#define MENELAUS_MMC_S2D1_IRQ\t\t3\t \n#define MENELAUS_LOWBAT_IRQ\t\t4\t \n#define MENELAUS_HOTDIE_IRQ\t\t5\t \n#define MENELAUS_UVLO_IRQ\t\t6\t \n#define MENELAUS_TSHUT_IRQ\t\t7\t \n#define MENELAUS_RTCTMR_IRQ\t\t8\t \n#define MENELAUS_RTCALM_IRQ\t\t9\t \n#define MENELAUS_RTCERR_IRQ\t\t10\t \n#define MENELAUS_PSHBTN_IRQ\t\t11\t \n#define MENELAUS_RESERVED12_IRQ\t\t12\t \n#define MENELAUS_RESERVED13_IRQ\t\t13\t \n#define MENELAUS_RESERVED14_IRQ\t\t14\t \n#define MENELAUS_RESERVED15_IRQ\t\t15\t \n\n \n#define VCORE_CTRL1_BYP_COMP\t\t(1 << 5)\n#define VCORE_CTRL1_HW_NSW\t\t(1 << 7)\n\n \n#define GPIO_CTRL_SLOTSELEN\t\t(1 << 5)\n#define GPIO_CTRL_SLPCTLEN\t\t(1 << 6)\n#define GPIO1_DIR_INPUT\t\t\t(1 << 0)\n#define GPIO2_DIR_INPUT\t\t\t(1 << 1)\n#define GPIO3_DIR_INPUT\t\t\t(1 << 2)\n\n \n#define MCT_CTRL1_S1_CMD_OD\t\t(1 << 2)\n#define MCT_CTRL1_S2_CMD_OD\t\t(1 << 3)\n\n \n#define MCT_CTRL2_VS2_SEL_D0\t\t(1 << 0)\n#define MCT_CTRL2_VS2_SEL_D1\t\t(1 << 1)\n#define MCT_CTRL2_S1CD_BUFEN\t\t(1 << 4)\n#define MCT_CTRL2_S2CD_BUFEN\t\t(1 << 5)\n#define MCT_CTRL2_S1CD_DBEN\t\t(1 << 6)\n#define MCT_CTRL2_S2CD_BEN\t\t(1 << 7)\n\n \n#define MCT_CTRL3_SLOT1_EN\t\t(1 << 0)\n#define MCT_CTRL3_SLOT2_EN\t\t(1 << 1)\n#define MCT_CTRL3_S1_AUTO_EN\t\t(1 << 2)\n#define MCT_CTRL3_S2_AUTO_EN\t\t(1 << 3)\n\n \n#define MCT_PIN_ST_S1_CD_ST\t\t(1 << 0)\n#define MCT_PIN_ST_S2_CD_ST\t\t(1 << 1)\n\nstatic void menelaus_work(struct work_struct *_menelaus);\n\nstruct menelaus_chip {\n\tstruct mutex\t\tlock;\n\tstruct i2c_client\t*client;\n\tstruct work_struct\twork;\n#ifdef CONFIG_RTC_DRV_TWL92330\n\tstruct rtc_device\t*rtc;\n\tu8\t\t\trtc_control;\n\tunsigned\t\tuie:1;\n#endif\n\tunsigned\t\tvcore_hw_mode:1;\n\tu8\t\t\tmask1, mask2;\n\tvoid\t\t\t(*handlers[16])(struct menelaus_chip *);\n\tvoid\t\t\t(*mmc_callback)(void *data, u8 mask);\n\tvoid\t\t\t*mmc_callback_data;\n};\n\nstatic struct menelaus_chip *the_menelaus;\n\nstatic int menelaus_write_reg(int reg, u8 value)\n{\n\tint val = i2c_smbus_write_byte_data(the_menelaus->client, reg, value);\n\n\tif (val < 0) {\n\t\tpr_err(DRIVER_NAME \": write error\");\n\t\treturn val;\n\t}\n\n\treturn 0;\n}\n\nstatic int menelaus_read_reg(int reg)\n{\n\tint val = i2c_smbus_read_byte_data(the_menelaus->client, reg);\n\n\tif (val < 0)\n\t\tpr_err(DRIVER_NAME \": read error\");\n\n\treturn val;\n}\n\nstatic int menelaus_enable_irq(int irq)\n{\n\tif (irq > 7) {\n\t\tirq -= 8;\n\t\tthe_menelaus->mask2 &= ~(1 << irq);\n\t\treturn menelaus_write_reg(MENELAUS_INT_MASK2,\n\t\t\t\tthe_menelaus->mask2);\n\t} else {\n\t\tthe_menelaus->mask1 &= ~(1 << irq);\n\t\treturn menelaus_write_reg(MENELAUS_INT_MASK1,\n\t\t\t\tthe_menelaus->mask1);\n\t}\n}\n\nstatic int menelaus_disable_irq(int irq)\n{\n\tif (irq > 7) {\n\t\tirq -= 8;\n\t\tthe_menelaus->mask2 |= (1 << irq);\n\t\treturn menelaus_write_reg(MENELAUS_INT_MASK2,\n\t\t\t\tthe_menelaus->mask2);\n\t} else {\n\t\tthe_menelaus->mask1 |= (1 << irq);\n\t\treturn menelaus_write_reg(MENELAUS_INT_MASK1,\n\t\t\t\tthe_menelaus->mask1);\n\t}\n}\n\nstatic int menelaus_ack_irq(int irq)\n{\n\tif (irq > 7)\n\t\treturn menelaus_write_reg(MENELAUS_INT_ACK2, 1 << (irq - 8));\n\telse\n\t\treturn menelaus_write_reg(MENELAUS_INT_ACK1, 1 << irq);\n}\n\n \nstatic int menelaus_add_irq_work(int irq,\n\t\tvoid (*handler)(struct menelaus_chip *))\n{\n\tint ret = 0;\n\n\tmutex_lock(&the_menelaus->lock);\n\tthe_menelaus->handlers[irq] = handler;\n\tret = menelaus_enable_irq(irq);\n\tmutex_unlock(&the_menelaus->lock);\n\n\treturn ret;\n}\n\n \nstatic int menelaus_remove_irq_work(int irq)\n{\n\tint ret = 0;\n\n\tmutex_lock(&the_menelaus->lock);\n\tret = menelaus_disable_irq(irq);\n\tthe_menelaus->handlers[irq] = NULL;\n\tmutex_unlock(&the_menelaus->lock);\n\n\treturn ret;\n}\n\n \nstatic void menelaus_mmc_cd_work(struct menelaus_chip *menelaus_hw)\n{\n\tint reg;\n\tunsigned char card_mask = 0;\n\n\treg = menelaus_read_reg(MENELAUS_MCT_PIN_ST);\n\tif (reg < 0)\n\t\treturn;\n\n\tif (!(reg & 0x1))\n\t\tcard_mask |= MCT_PIN_ST_S1_CD_ST;\n\n\tif (!(reg & 0x2))\n\t\tcard_mask |= MCT_PIN_ST_S2_CD_ST;\n\n\tif (menelaus_hw->mmc_callback)\n\t\tmenelaus_hw->mmc_callback(menelaus_hw->mmc_callback_data,\n\t\t\t\t\t  card_mask);\n}\n\n \nint menelaus_set_mmc_opendrain(int slot, int enable)\n{\n\tint ret, val;\n\n\tif (slot != 1 && slot != 2)\n\t\treturn -EINVAL;\n\tmutex_lock(&the_menelaus->lock);\n\tret = menelaus_read_reg(MENELAUS_MCT_CTRL1);\n\tif (ret < 0) {\n\t\tmutex_unlock(&the_menelaus->lock);\n\t\treturn ret;\n\t}\n\tval = ret;\n\tif (slot == 1) {\n\t\tif (enable)\n\t\t\tval |= MCT_CTRL1_S1_CMD_OD;\n\t\telse\n\t\t\tval &= ~MCT_CTRL1_S1_CMD_OD;\n\t} else {\n\t\tif (enable)\n\t\t\tval |= MCT_CTRL1_S2_CMD_OD;\n\t\telse\n\t\t\tval &= ~MCT_CTRL1_S2_CMD_OD;\n\t}\n\tret = menelaus_write_reg(MENELAUS_MCT_CTRL1, val);\n\tmutex_unlock(&the_menelaus->lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(menelaus_set_mmc_opendrain);\n\nint menelaus_set_slot_sel(int enable)\n{\n\tint ret;\n\n\tmutex_lock(&the_menelaus->lock);\n\tret = menelaus_read_reg(MENELAUS_GPIO_CTRL);\n\tif (ret < 0)\n\t\tgoto out;\n\tret |= GPIO2_DIR_INPUT;\n\tif (enable)\n\t\tret |= GPIO_CTRL_SLOTSELEN;\n\telse\n\t\tret &= ~GPIO_CTRL_SLOTSELEN;\n\tret = menelaus_write_reg(MENELAUS_GPIO_CTRL, ret);\nout:\n\tmutex_unlock(&the_menelaus->lock);\n\treturn ret;\n}\nEXPORT_SYMBOL(menelaus_set_slot_sel);\n\nint menelaus_set_mmc_slot(int slot, int enable, int power, int cd_en)\n{\n\tint ret, val;\n\n\tif (slot != 1 && slot != 2)\n\t\treturn -EINVAL;\n\tif (power >= 3)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&the_menelaus->lock);\n\n\tret = menelaus_read_reg(MENELAUS_MCT_CTRL2);\n\tif (ret < 0)\n\t\tgoto out;\n\tval = ret;\n\tif (slot == 1) {\n\t\tif (cd_en)\n\t\t\tval |= MCT_CTRL2_S1CD_BUFEN | MCT_CTRL2_S1CD_DBEN;\n\t\telse\n\t\t\tval &= ~(MCT_CTRL2_S1CD_BUFEN | MCT_CTRL2_S1CD_DBEN);\n\t} else {\n\t\tif (cd_en)\n\t\t\tval |= MCT_CTRL2_S2CD_BUFEN | MCT_CTRL2_S2CD_BEN;\n\t\telse\n\t\t\tval &= ~(MCT_CTRL2_S2CD_BUFEN | MCT_CTRL2_S2CD_BEN);\n\t}\n\tret = menelaus_write_reg(MENELAUS_MCT_CTRL2, val);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = menelaus_read_reg(MENELAUS_MCT_CTRL3);\n\tif (ret < 0)\n\t\tgoto out;\n\tval = ret;\n\tif (slot == 1) {\n\t\tif (enable)\n\t\t\tval |= MCT_CTRL3_SLOT1_EN;\n\t\telse\n\t\t\tval &= ~MCT_CTRL3_SLOT1_EN;\n\t} else {\n\t\tint b;\n\n\t\tif (enable)\n\t\t\tval |= MCT_CTRL3_SLOT2_EN;\n\t\telse\n\t\t\tval &= ~MCT_CTRL3_SLOT2_EN;\n\t\tb = menelaus_read_reg(MENELAUS_MCT_CTRL2);\n\t\tb &= ~(MCT_CTRL2_VS2_SEL_D0 | MCT_CTRL2_VS2_SEL_D1);\n\t\tb |= power;\n\t\tret = menelaus_write_reg(MENELAUS_MCT_CTRL2, b);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\t \n\tval &= ~(MCT_CTRL3_S1_AUTO_EN | MCT_CTRL3_S2_AUTO_EN);\n\tret = menelaus_write_reg(MENELAUS_MCT_CTRL3, val);\nout:\n\tmutex_unlock(&the_menelaus->lock);\n\treturn ret;\n}\nEXPORT_SYMBOL(menelaus_set_mmc_slot);\n\nint menelaus_register_mmc_callback(void (*callback)(void *data, u8 card_mask),\n\t\t\t\t   void *data)\n{\n\tint ret = 0;\n\n\tthe_menelaus->mmc_callback_data = data;\n\tthe_menelaus->mmc_callback = callback;\n\tret = menelaus_add_irq_work(MENELAUS_MMC_S1CD_IRQ,\n\t\t\t\t    menelaus_mmc_cd_work);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = menelaus_add_irq_work(MENELAUS_MMC_S2CD_IRQ,\n\t\t\t\t    menelaus_mmc_cd_work);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = menelaus_add_irq_work(MENELAUS_MMC_S1D1_IRQ,\n\t\t\t\t    menelaus_mmc_cd_work);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = menelaus_add_irq_work(MENELAUS_MMC_S2D1_IRQ,\n\t\t\t\t    menelaus_mmc_cd_work);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(menelaus_register_mmc_callback);\n\nvoid menelaus_unregister_mmc_callback(void)\n{\n\tmenelaus_remove_irq_work(MENELAUS_MMC_S1CD_IRQ);\n\tmenelaus_remove_irq_work(MENELAUS_MMC_S2CD_IRQ);\n\tmenelaus_remove_irq_work(MENELAUS_MMC_S1D1_IRQ);\n\tmenelaus_remove_irq_work(MENELAUS_MMC_S2D1_IRQ);\n\n\tthe_menelaus->mmc_callback = NULL;\n\tthe_menelaus->mmc_callback_data = NULL;\n}\nEXPORT_SYMBOL(menelaus_unregister_mmc_callback);\n\nstruct menelaus_vtg {\n\tconst char *name;\n\tu8 vtg_reg;\n\tu8 vtg_shift;\n\tu8 vtg_bits;\n\tu8 mode_reg;\n};\n\nstruct menelaus_vtg_value {\n\tu16 vtg;\n\tu16 val;\n};\n\nstatic int menelaus_set_voltage(const struct menelaus_vtg *vtg, int mV,\n\t\t\t\tint vtg_val, int mode)\n{\n\tint val, ret;\n\tstruct i2c_client *c = the_menelaus->client;\n\n\tmutex_lock(&the_menelaus->lock);\n\n\tret = menelaus_read_reg(vtg->vtg_reg);\n\tif (ret < 0)\n\t\tgoto out;\n\tval = ret & ~(((1 << vtg->vtg_bits) - 1) << vtg->vtg_shift);\n\tval |= vtg_val << vtg->vtg_shift;\n\n\tdev_dbg(&c->dev, \"Setting voltage '%s'\"\n\t\t\t \"to %d mV (reg 0x%02x, val 0x%02x)\\n\",\n\t\t\tvtg->name, mV, vtg->vtg_reg, val);\n\n\tret = menelaus_write_reg(vtg->vtg_reg, val);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = menelaus_write_reg(vtg->mode_reg, mode);\nout:\n\tmutex_unlock(&the_menelaus->lock);\n\tif (ret == 0) {\n\t\t \n\t\tmsleep(1);\n\t}\n\treturn ret;\n}\n\nstatic int menelaus_get_vtg_value(int vtg, const struct menelaus_vtg_value *tbl,\n\t\t\t\t  int n)\n{\n\tint i;\n\n\tfor (i = 0; i < n; i++, tbl++)\n\t\tif (tbl->vtg == vtg)\n\t\t\treturn tbl->val;\n\treturn -EINVAL;\n}\n\n \n\nstatic const struct menelaus_vtg_value vcore_values[] = {\n\t{ 1000, 0 },\n\t{ 1025, 1 },\n\t{ 1050, 2 },\n\t{ 1075, 3 },\n\t{ 1100, 4 },\n\t{ 1125, 5 },\n\t{ 1150, 6 },\n\t{ 1175, 7 },\n\t{ 1200, 8 },\n\t{ 1225, 9 },\n\t{ 1250, 10 },\n\t{ 1275, 11 },\n\t{ 1300, 12 },\n\t{ 1325, 13 },\n\t{ 1350, 14 },\n\t{ 1375, 15 },\n\t{ 1400, 16 },\n\t{ 1425, 17 },\n\t{ 1450, 18 },\n};\n\nint menelaus_set_vcore_hw(unsigned int roof_mV, unsigned int floor_mV)\n{\n\tint fval, rval, val, ret;\n\tstruct i2c_client *c = the_menelaus->client;\n\n\trval = menelaus_get_vtg_value(roof_mV, vcore_values,\n\t\t\t\t      ARRAY_SIZE(vcore_values));\n\tif (rval < 0)\n\t\treturn -EINVAL;\n\tfval = menelaus_get_vtg_value(floor_mV, vcore_values,\n\t\t\t\t      ARRAY_SIZE(vcore_values));\n\tif (fval < 0)\n\t\treturn -EINVAL;\n\n\tdev_dbg(&c->dev, \"Setting VCORE FLOOR to %d mV and ROOF to %d mV\\n\",\n\t       floor_mV, roof_mV);\n\n\tmutex_lock(&the_menelaus->lock);\n\tret = menelaus_write_reg(MENELAUS_VCORE_CTRL3, fval);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = menelaus_write_reg(MENELAUS_VCORE_CTRL4, rval);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (!the_menelaus->vcore_hw_mode) {\n\t\tval = menelaus_read_reg(MENELAUS_VCORE_CTRL1);\n\t\t \n\t\tval |= (VCORE_CTRL1_HW_NSW | VCORE_CTRL1_BYP_COMP);\n\t\tret = menelaus_write_reg(MENELAUS_VCORE_CTRL1, val);\n\t\tthe_menelaus->vcore_hw_mode = 1;\n\t}\n\tmsleep(1);\nout:\n\tmutex_unlock(&the_menelaus->lock);\n\treturn ret;\n}\n\nstatic const struct menelaus_vtg vmem_vtg = {\n\t.name = \"VMEM\",\n\t.vtg_reg = MENELAUS_LDO_CTRL1,\n\t.vtg_shift = 0,\n\t.vtg_bits = 2,\n\t.mode_reg = MENELAUS_LDO_CTRL3,\n};\n\nstatic const struct menelaus_vtg_value vmem_values[] = {\n\t{ 1500, 0 },\n\t{ 1800, 1 },\n\t{ 1900, 2 },\n\t{ 2500, 3 },\n};\n\nint menelaus_set_vmem(unsigned int mV)\n{\n\tint val;\n\n\tif (mV == 0)\n\t\treturn menelaus_set_voltage(&vmem_vtg, 0, 0, 0);\n\n\tval = menelaus_get_vtg_value(mV, vmem_values, ARRAY_SIZE(vmem_values));\n\tif (val < 0)\n\t\treturn -EINVAL;\n\treturn menelaus_set_voltage(&vmem_vtg, mV, val, 0x02);\n}\nEXPORT_SYMBOL(menelaus_set_vmem);\n\nstatic const struct menelaus_vtg vio_vtg = {\n\t.name = \"VIO\",\n\t.vtg_reg = MENELAUS_LDO_CTRL1,\n\t.vtg_shift = 2,\n\t.vtg_bits = 2,\n\t.mode_reg = MENELAUS_LDO_CTRL4,\n};\n\nstatic const struct menelaus_vtg_value vio_values[] = {\n\t{ 1500, 0 },\n\t{ 1800, 1 },\n\t{ 2500, 2 },\n\t{ 2800, 3 },\n};\n\nint menelaus_set_vio(unsigned int mV)\n{\n\tint val;\n\n\tif (mV == 0)\n\t\treturn menelaus_set_voltage(&vio_vtg, 0, 0, 0);\n\n\tval = menelaus_get_vtg_value(mV, vio_values, ARRAY_SIZE(vio_values));\n\tif (val < 0)\n\t\treturn -EINVAL;\n\treturn menelaus_set_voltage(&vio_vtg, mV, val, 0x02);\n}\nEXPORT_SYMBOL(menelaus_set_vio);\n\nstatic const struct menelaus_vtg_value vdcdc_values[] = {\n\t{ 1500, 0 },\n\t{ 1800, 1 },\n\t{ 2000, 2 },\n\t{ 2200, 3 },\n\t{ 2400, 4 },\n\t{ 2800, 5 },\n\t{ 3000, 6 },\n\t{ 3300, 7 },\n};\n\nstatic const struct menelaus_vtg vdcdc2_vtg = {\n\t.name = \"VDCDC2\",\n\t.vtg_reg = MENELAUS_DCDC_CTRL1,\n\t.vtg_shift = 0,\n\t.vtg_bits = 3,\n\t.mode_reg = MENELAUS_DCDC_CTRL2,\n};\n\nstatic const struct menelaus_vtg vdcdc3_vtg = {\n\t.name = \"VDCDC3\",\n\t.vtg_reg = MENELAUS_DCDC_CTRL1,\n\t.vtg_shift = 3,\n\t.vtg_bits = 3,\n\t.mode_reg = MENELAUS_DCDC_CTRL3,\n};\n\nint menelaus_set_vdcdc(int dcdc, unsigned int mV)\n{\n\tconst struct menelaus_vtg *vtg;\n\tint val;\n\n\tif (dcdc != 2 && dcdc != 3)\n\t\treturn -EINVAL;\n\tif (dcdc == 2)\n\t\tvtg = &vdcdc2_vtg;\n\telse\n\t\tvtg = &vdcdc3_vtg;\n\n\tif (mV == 0)\n\t\treturn menelaus_set_voltage(vtg, 0, 0, 0);\n\n\tval = menelaus_get_vtg_value(mV, vdcdc_values,\n\t\t\t\t     ARRAY_SIZE(vdcdc_values));\n\tif (val < 0)\n\t\treturn -EINVAL;\n\treturn menelaus_set_voltage(vtg, mV, val, 0x03);\n}\n\nstatic const struct menelaus_vtg_value vmmc_values[] = {\n\t{ 1850, 0 },\n\t{ 2800, 1 },\n\t{ 3000, 2 },\n\t{ 3100, 3 },\n};\n\nstatic const struct menelaus_vtg vmmc_vtg = {\n\t.name = \"VMMC\",\n\t.vtg_reg = MENELAUS_LDO_CTRL1,\n\t.vtg_shift = 6,\n\t.vtg_bits = 2,\n\t.mode_reg = MENELAUS_LDO_CTRL7,\n};\n\nint menelaus_set_vmmc(unsigned int mV)\n{\n\tint val;\n\n\tif (mV == 0)\n\t\treturn menelaus_set_voltage(&vmmc_vtg, 0, 0, 0);\n\n\tval = menelaus_get_vtg_value(mV, vmmc_values, ARRAY_SIZE(vmmc_values));\n\tif (val < 0)\n\t\treturn -EINVAL;\n\treturn menelaus_set_voltage(&vmmc_vtg, mV, val, 0x02);\n}\nEXPORT_SYMBOL(menelaus_set_vmmc);\n\n\nstatic const struct menelaus_vtg_value vaux_values[] = {\n\t{ 1500, 0 },\n\t{ 1800, 1 },\n\t{ 2500, 2 },\n\t{ 2800, 3 },\n};\n\nstatic const struct menelaus_vtg vaux_vtg = {\n\t.name = \"VAUX\",\n\t.vtg_reg = MENELAUS_LDO_CTRL1,\n\t.vtg_shift = 4,\n\t.vtg_bits = 2,\n\t.mode_reg = MENELAUS_LDO_CTRL6,\n};\n\nint menelaus_set_vaux(unsigned int mV)\n{\n\tint val;\n\n\tif (mV == 0)\n\t\treturn menelaus_set_voltage(&vaux_vtg, 0, 0, 0);\n\n\tval = menelaus_get_vtg_value(mV, vaux_values, ARRAY_SIZE(vaux_values));\n\tif (val < 0)\n\t\treturn -EINVAL;\n\treturn menelaus_set_voltage(&vaux_vtg, mV, val, 0x02);\n}\nEXPORT_SYMBOL(menelaus_set_vaux);\n\nint menelaus_get_slot_pin_states(void)\n{\n\treturn menelaus_read_reg(MENELAUS_MCT_PIN_ST);\n}\nEXPORT_SYMBOL(menelaus_get_slot_pin_states);\n\nint menelaus_set_regulator_sleep(int enable, u32 val)\n{\n\tint t, ret;\n\tstruct i2c_client *c = the_menelaus->client;\n\n\tmutex_lock(&the_menelaus->lock);\n\tret = menelaus_write_reg(MENELAUS_SLEEP_CTRL2, val);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tdev_dbg(&c->dev, \"regulator sleep configuration: %02x\\n\", val);\n\n\tret = menelaus_read_reg(MENELAUS_GPIO_CTRL);\n\tif (ret < 0)\n\t\tgoto out;\n\tt = (GPIO_CTRL_SLPCTLEN | GPIO3_DIR_INPUT);\n\tif (enable)\n\t\tret |= t;\n\telse\n\t\tret &= ~t;\n\tret = menelaus_write_reg(MENELAUS_GPIO_CTRL, ret);\nout:\n\tmutex_unlock(&the_menelaus->lock);\n\treturn ret;\n}\n\n \n\n \nstatic void menelaus_work(struct work_struct *_menelaus)\n{\n\tstruct menelaus_chip *menelaus =\n\t\t\tcontainer_of(_menelaus, struct menelaus_chip, work);\n\tvoid (*handler)(struct menelaus_chip *menelaus);\n\n\twhile (1) {\n\t\tunsigned isr;\n\n\t\tisr = (menelaus_read_reg(MENELAUS_INT_STATUS2)\n\t\t\t\t& ~menelaus->mask2) << 8;\n\t\tisr |= menelaus_read_reg(MENELAUS_INT_STATUS1)\n\t\t\t\t& ~menelaus->mask1;\n\t\tif (!isr)\n\t\t\tbreak;\n\n\t\twhile (isr) {\n\t\t\tint irq = fls(isr) - 1;\n\t\t\tisr &= ~(1 << irq);\n\n\t\t\tmutex_lock(&menelaus->lock);\n\t\t\tmenelaus_disable_irq(irq);\n\t\t\tmenelaus_ack_irq(irq);\n\t\t\thandler = menelaus->handlers[irq];\n\t\t\tif (handler)\n\t\t\t\thandler(menelaus);\n\t\t\tmenelaus_enable_irq(irq);\n\t\t\tmutex_unlock(&menelaus->lock);\n\t\t}\n\t}\n\tenable_irq(menelaus->client->irq);\n}\n\n \nstatic irqreturn_t menelaus_irq(int irq, void *_menelaus)\n{\n\tstruct menelaus_chip *menelaus = _menelaus;\n\n\tdisable_irq_nosync(irq);\n\t(void)schedule_work(&menelaus->work);\n\n\treturn IRQ_HANDLED;\n}\n\n \n\n \n#ifdef CONFIG_RTC_DRV_TWL92330\n\n#define RTC_CTRL_RTC_EN\t\t(1 << 0)\n#define RTC_CTRL_AL_EN\t\t(1 << 1)\n#define RTC_CTRL_MODE12\t\t(1 << 2)\n#define RTC_CTRL_EVERY_MASK\t(3 << 3)\n#define RTC_CTRL_EVERY_SEC\t(0 << 3)\n#define RTC_CTRL_EVERY_MIN\t(1 << 3)\n#define RTC_CTRL_EVERY_HR\t(2 << 3)\n#define RTC_CTRL_EVERY_DAY\t(3 << 3)\n\n#define RTC_UPDATE_EVERY\t0x08\n\n#define RTC_HR_PM\t\t(1 << 7)\n\nstatic void menelaus_to_time(char *regs, struct rtc_time *t)\n{\n\tt->tm_sec = bcd2bin(regs[0]);\n\tt->tm_min = bcd2bin(regs[1]);\n\tif (the_menelaus->rtc_control & RTC_CTRL_MODE12) {\n\t\tt->tm_hour = bcd2bin(regs[2] & 0x1f) - 1;\n\t\tif (regs[2] & RTC_HR_PM)\n\t\t\tt->tm_hour += 12;\n\t} else\n\t\tt->tm_hour = bcd2bin(regs[2] & 0x3f);\n\tt->tm_mday = bcd2bin(regs[3]);\n\tt->tm_mon = bcd2bin(regs[4]) - 1;\n\tt->tm_year = bcd2bin(regs[5]) + 100;\n}\n\nstatic int time_to_menelaus(struct rtc_time *t, int regnum)\n{\n\tint\thour, status;\n\n\tstatus = menelaus_write_reg(regnum++, bin2bcd(t->tm_sec));\n\tif (status < 0)\n\t\tgoto fail;\n\n\tstatus = menelaus_write_reg(regnum++, bin2bcd(t->tm_min));\n\tif (status < 0)\n\t\tgoto fail;\n\n\tif (the_menelaus->rtc_control & RTC_CTRL_MODE12) {\n\t\thour = t->tm_hour + 1;\n\t\tif (hour > 12)\n\t\t\thour = RTC_HR_PM | bin2bcd(hour - 12);\n\t\telse\n\t\t\thour = bin2bcd(hour);\n\t} else\n\t\thour = bin2bcd(t->tm_hour);\n\tstatus = menelaus_write_reg(regnum++, hour);\n\tif (status < 0)\n\t\tgoto fail;\n\n\tstatus = menelaus_write_reg(regnum++, bin2bcd(t->tm_mday));\n\tif (status < 0)\n\t\tgoto fail;\n\n\tstatus = menelaus_write_reg(regnum++, bin2bcd(t->tm_mon + 1));\n\tif (status < 0)\n\t\tgoto fail;\n\n\tstatus = menelaus_write_reg(regnum++, bin2bcd(t->tm_year - 100));\n\tif (status < 0)\n\t\tgoto fail;\n\n\treturn 0;\nfail:\n\tdev_err(&the_menelaus->client->dev, \"rtc write reg %02x, err %d\\n\",\n\t\t\t--regnum, status);\n\treturn status;\n}\n\nstatic int menelaus_read_time(struct device *dev, struct rtc_time *t)\n{\n\tstruct i2c_msg\tmsg[2];\n\tchar\t\tregs[7];\n\tint\t\tstatus;\n\n\t \n\tregs[0] = MENELAUS_RTC_SEC;\n\n\tmsg[0].addr = MENELAUS_I2C_ADDRESS;\n\tmsg[0].flags = 0;\n\tmsg[0].len = 1;\n\tmsg[0].buf = regs;\n\n\tmsg[1].addr = MENELAUS_I2C_ADDRESS;\n\tmsg[1].flags = I2C_M_RD;\n\tmsg[1].len = sizeof(regs);\n\tmsg[1].buf = regs;\n\n\tstatus = i2c_transfer(the_menelaus->client->adapter, msg, 2);\n\tif (status != 2) {\n\t\tdev_err(dev, \"%s error %d\\n\", \"read\", status);\n\t\treturn -EIO;\n\t}\n\n\tmenelaus_to_time(regs, t);\n\tt->tm_wday = bcd2bin(regs[6]);\n\n\treturn 0;\n}\n\nstatic int menelaus_set_time(struct device *dev, struct rtc_time *t)\n{\n\tint\t\tstatus;\n\n\t \n\tstatus = time_to_menelaus(t, MENELAUS_RTC_SEC);\n\tif (status < 0)\n\t\treturn status;\n\tstatus = menelaus_write_reg(MENELAUS_RTC_WKDAY, bin2bcd(t->tm_wday));\n\tif (status < 0) {\n\t\tdev_err(&the_menelaus->client->dev, \"rtc write reg %02x \"\n\t\t\t\t\"err %d\\n\", MENELAUS_RTC_WKDAY, status);\n\t\treturn status;\n\t}\n\n\t \n\tstatus = menelaus_write_reg(MENELAUS_RTC_UPDATE, RTC_UPDATE_EVERY);\n\tif (status < 0)\n\t\tdev_err(&the_menelaus->client->dev, \"rtc commit time, err %d\\n\",\n\t\t\t\tstatus);\n\n\treturn 0;\n}\n\nstatic int menelaus_read_alarm(struct device *dev, struct rtc_wkalrm *w)\n{\n\tstruct i2c_msg\tmsg[2];\n\tchar\t\tregs[6];\n\tint\t\tstatus;\n\n\t \n\tregs[0] = MENELAUS_RTC_AL_SEC;\n\n\tmsg[0].addr = MENELAUS_I2C_ADDRESS;\n\tmsg[0].flags = 0;\n\tmsg[0].len = 1;\n\tmsg[0].buf = regs;\n\n\tmsg[1].addr = MENELAUS_I2C_ADDRESS;\n\tmsg[1].flags = I2C_M_RD;\n\tmsg[1].len = sizeof(regs);\n\tmsg[1].buf = regs;\n\n\tstatus = i2c_transfer(the_menelaus->client->adapter, msg, 2);\n\tif (status != 2) {\n\t\tdev_err(dev, \"%s error %d\\n\", \"alarm read\", status);\n\t\treturn -EIO;\n\t}\n\n\tmenelaus_to_time(regs, &w->time);\n\n\tw->enabled = !!(the_menelaus->rtc_control & RTC_CTRL_AL_EN);\n\n\t \n\tw->pending = 0;\n\n\treturn 0;\n}\n\nstatic int menelaus_set_alarm(struct device *dev, struct rtc_wkalrm *w)\n{\n\tint\t\tstatus;\n\n\tif (the_menelaus->client->irq <= 0 && w->enabled)\n\t\treturn -ENODEV;\n\n\t \n\tif (the_menelaus->rtc_control & RTC_CTRL_AL_EN) {\n\t\tthe_menelaus->rtc_control &= ~RTC_CTRL_AL_EN;\n\t\tstatus = menelaus_write_reg(MENELAUS_RTC_CTRL,\n\t\t\t\tthe_menelaus->rtc_control);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t}\n\n\t \n\tstatus = time_to_menelaus(&w->time, MENELAUS_RTC_AL_SEC);\n\tif (status < 0)\n\t\treturn status;\n\n\t \n\tif (w->enabled) {\n\t\tthe_menelaus->rtc_control |= RTC_CTRL_AL_EN;\n\t\tstatus = menelaus_write_reg(MENELAUS_RTC_CTRL,\n\t\t\t\tthe_menelaus->rtc_control);\n\t}\n\n\treturn status;\n}\n\n#ifdef CONFIG_RTC_INTF_DEV\n\nstatic void menelaus_rtc_update_work(struct menelaus_chip *m)\n{\n\t \n\trtc_update_irq(m->rtc, 1, RTC_IRQF | RTC_UF);\n}\n\nstatic int menelaus_ioctl(struct device *dev, unsigned cmd, unsigned long arg)\n{\n\tint\tstatus;\n\n\tif (the_menelaus->client->irq <= 0)\n\t\treturn -ENOIOCTLCMD;\n\n\tswitch (cmd) {\n\t \n\tcase RTC_AIE_ON:\n\t\tif (the_menelaus->rtc_control & RTC_CTRL_AL_EN)\n\t\t\treturn 0;\n\t\tthe_menelaus->rtc_control |= RTC_CTRL_AL_EN;\n\t\tbreak;\n\tcase RTC_AIE_OFF:\n\t\tif (!(the_menelaus->rtc_control & RTC_CTRL_AL_EN))\n\t\t\treturn 0;\n\t\tthe_menelaus->rtc_control &= ~RTC_CTRL_AL_EN;\n\t\tbreak;\n\t \n\tcase RTC_UIE_ON:\n\t\tif (the_menelaus->uie)\n\t\t\treturn 0;\n\t\tstatus = menelaus_remove_irq_work(MENELAUS_RTCTMR_IRQ);\n\t\tstatus = menelaus_add_irq_work(MENELAUS_RTCTMR_IRQ,\n\t\t\t\tmenelaus_rtc_update_work);\n\t\tif (status == 0)\n\t\t\tthe_menelaus->uie = 1;\n\t\treturn status;\n\tcase RTC_UIE_OFF:\n\t\tif (!the_menelaus->uie)\n\t\t\treturn 0;\n\t\tstatus = menelaus_remove_irq_work(MENELAUS_RTCTMR_IRQ);\n\t\tif (status == 0)\n\t\t\tthe_menelaus->uie = 0;\n\t\treturn status;\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\treturn menelaus_write_reg(MENELAUS_RTC_CTRL, the_menelaus->rtc_control);\n}\n\n#else\n#define menelaus_ioctl\tNULL\n#endif\n\n \n\nstatic const struct rtc_class_ops menelaus_rtc_ops = {\n\t.ioctl\t\t\t= menelaus_ioctl,\n\t.read_time\t\t= menelaus_read_time,\n\t.set_time\t\t= menelaus_set_time,\n\t.read_alarm\t\t= menelaus_read_alarm,\n\t.set_alarm\t\t= menelaus_set_alarm,\n};\n\nstatic void menelaus_rtc_alarm_work(struct menelaus_chip *m)\n{\n\t \n\trtc_update_irq(m->rtc, 1, RTC_IRQF | RTC_AF);\n\n\t \n\tthe_menelaus->rtc_control &= ~RTC_CTRL_AL_EN;\n\tmenelaus_write_reg(MENELAUS_RTC_CTRL, the_menelaus->rtc_control);\n}\n\nstatic inline void menelaus_rtc_init(struct menelaus_chip *m)\n{\n\tint\talarm = (m->client->irq > 0);\n\tint\terr;\n\n\t \n\tif (!(menelaus_read_reg(MENELAUS_OSC_CTRL) & 0x80)) {\n\t\tdev_dbg(&m->client->dev, \"no 32k oscillator\\n\");\n\t\treturn;\n\t}\n\n\tm->rtc = devm_rtc_allocate_device(&m->client->dev);\n\tif (IS_ERR(m->rtc))\n\t\treturn;\n\n\tm->rtc->ops = &menelaus_rtc_ops;\n\n\t \n\tif (alarm) {\n\t\tif (menelaus_add_irq_work(MENELAUS_RTCALM_IRQ,\n\t\t\t\tmenelaus_rtc_alarm_work) < 0) {\n\t\t\tdev_err(&m->client->dev, \"can't handle RTC alarm\\n\");\n\t\t\treturn;\n\t\t}\n\t\tdevice_init_wakeup(&m->client->dev, 1);\n\t}\n\n\t \n\tm->rtc_control = menelaus_read_reg(MENELAUS_RTC_CTRL);\n\tif (!(m->rtc_control & RTC_CTRL_RTC_EN)\n\t\t\t|| (m->rtc_control & RTC_CTRL_AL_EN)\n\t\t\t|| (m->rtc_control & RTC_CTRL_EVERY_MASK)) {\n\t\tif (!(m->rtc_control & RTC_CTRL_RTC_EN)) {\n\t\t\tdev_warn(&m->client->dev, \"rtc clock needs setting\\n\");\n\t\t\tm->rtc_control |= RTC_CTRL_RTC_EN;\n\t\t}\n\t\tm->rtc_control &= ~RTC_CTRL_EVERY_MASK;\n\t\tm->rtc_control &= ~RTC_CTRL_AL_EN;\n\t\tmenelaus_write_reg(MENELAUS_RTC_CTRL, m->rtc_control);\n\t}\n\n\terr = devm_rtc_register_device(m->rtc);\n\tif (err) {\n\t\tif (alarm) {\n\t\t\tmenelaus_remove_irq_work(MENELAUS_RTCALM_IRQ);\n\t\t\tdevice_init_wakeup(&m->client->dev, 0);\n\t\t}\n\t\tthe_menelaus->rtc = NULL;\n\t}\n}\n\n#else\n\nstatic inline void menelaus_rtc_init(struct menelaus_chip *m)\n{\n\t \n}\n\n#endif\n\n \n\nstatic struct i2c_driver menelaus_i2c_driver;\n\nstatic int menelaus_probe(struct i2c_client *client)\n{\n\tstruct menelaus_chip\t*menelaus;\n\tint\t\t\trev = 0;\n\tint\t\t\terr = 0;\n\tstruct menelaus_platform_data *menelaus_pdata =\n\t\t\t\t\tdev_get_platdata(&client->dev);\n\n\tif (the_menelaus) {\n\t\tdev_dbg(&client->dev, \"only one %s for now\\n\",\n\t\t\t\tDRIVER_NAME);\n\t\treturn -ENODEV;\n\t}\n\n\tmenelaus = devm_kzalloc(&client->dev, sizeof(*menelaus), GFP_KERNEL);\n\tif (!menelaus)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, menelaus);\n\n\tthe_menelaus = menelaus;\n\tmenelaus->client = client;\n\n\t \n\trev = menelaus_read_reg(MENELAUS_REV);\n\tif (rev < 0) {\n\t\tpr_err(DRIVER_NAME \": device not found\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tmenelaus_write_reg(MENELAUS_INT_ACK1, 0xff);\n\tmenelaus_write_reg(MENELAUS_INT_ACK2, 0xff);\n\tmenelaus_write_reg(MENELAUS_INT_MASK1, 0xff);\n\tmenelaus_write_reg(MENELAUS_INT_MASK2, 0xff);\n\tmenelaus->mask1 = 0xff;\n\tmenelaus->mask2 = 0xff;\n\n\t \n\tmenelaus_write_reg(MENELAUS_MCT_CTRL1, 0x73);\n\n\tif (client->irq > 0) {\n\t\terr = request_irq(client->irq, menelaus_irq, 0,\n\t\t\t\t  DRIVER_NAME, menelaus);\n\t\tif (err) {\n\t\t\tdev_dbg(&client->dev,  \"can't get IRQ %d, err %d\\n\",\n\t\t\t\t\tclient->irq, err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tmutex_init(&menelaus->lock);\n\tINIT_WORK(&menelaus->work, menelaus_work);\n\n\tpr_info(\"Menelaus rev %d.%d\\n\", rev >> 4, rev & 0x0f);\n\n\terr = menelaus_read_reg(MENELAUS_VCORE_CTRL1);\n\tif (err < 0)\n\t\tgoto fail;\n\tif (err & VCORE_CTRL1_HW_NSW)\n\t\tmenelaus->vcore_hw_mode = 1;\n\telse\n\t\tmenelaus->vcore_hw_mode = 0;\n\n\tif (menelaus_pdata != NULL && menelaus_pdata->late_init != NULL) {\n\t\terr = menelaus_pdata->late_init(&client->dev);\n\t\tif (err < 0)\n\t\t\tgoto fail;\n\t}\n\n\tmenelaus_rtc_init(menelaus);\n\n\treturn 0;\nfail:\n\tfree_irq(client->irq, menelaus);\n\tflush_work(&menelaus->work);\n\treturn err;\n}\n\nstatic void menelaus_remove(struct i2c_client *client)\n{\n\tstruct menelaus_chip\t*menelaus = i2c_get_clientdata(client);\n\n\tfree_irq(client->irq, menelaus);\n\tflush_work(&menelaus->work);\n\tthe_menelaus = NULL;\n}\n\nstatic const struct i2c_device_id menelaus_id[] = {\n\t{ \"menelaus\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, menelaus_id);\n\nstatic struct i2c_driver menelaus_i2c_driver = {\n\t.driver = {\n\t\t.name\t\t= DRIVER_NAME,\n\t},\n\t.probe\t\t= menelaus_probe,\n\t.remove\t\t= menelaus_remove,\n\t.id_table\t= menelaus_id,\n};\n\nmodule_i2c_driver(menelaus_i2c_driver);\n\nMODULE_AUTHOR(\"Texas Instruments, Inc. (and others)\");\nMODULE_DESCRIPTION(\"I2C interface for Menelaus.\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}