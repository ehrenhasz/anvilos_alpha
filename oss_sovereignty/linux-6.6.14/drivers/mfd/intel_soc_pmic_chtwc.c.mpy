{
  "module_name": "intel_soc_pmic_chtwc.c",
  "hash_id": "fb3e1cb7323aa9af7a780b940720912a953028700f599bfac745ff2c8f40eb69",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/intel_soc_pmic_chtwc.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/delay.h>\n#include <linux/dmi.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/intel_soc_pmic.h>\n#include <linux/regmap.h>\n\n \n#define REG_OFFSET_MASK\t\tGENMASK(7, 0)\n#define REG_ADDR_MASK\t\tGENMASK(15, 8)\n#define REG_ADDR_SHIFT\t\t8\n\n#define CHT_WC_IRQLVL1\t\t0x6e02\n#define CHT_WC_IRQLVL1_MASK\t0x6e0e\n\n \n#define CHT_WC_HRV\t\t3\n\n \nenum {\n\tCHT_WC_PWRSRC_IRQ = 0,\n\tCHT_WC_THRM_IRQ,\n\tCHT_WC_BCU_IRQ,\n\tCHT_WC_ADC_IRQ,\n\tCHT_WC_EXT_CHGR_IRQ,\n\tCHT_WC_GPIO_IRQ,\n\t \n\tCHT_WC_CRIT_IRQ = 7,\n};\n\nstatic const struct resource cht_wc_pwrsrc_resources[] = {\n\tDEFINE_RES_IRQ(CHT_WC_PWRSRC_IRQ),\n};\n\nstatic const struct resource cht_wc_ext_charger_resources[] = {\n\tDEFINE_RES_IRQ(CHT_WC_EXT_CHGR_IRQ),\n};\n\nstatic struct mfd_cell cht_wc_dev[] = {\n\t{\n\t\t.name = \"cht_wcove_pwrsrc\",\n\t\t.num_resources = ARRAY_SIZE(cht_wc_pwrsrc_resources),\n\t\t.resources = cht_wc_pwrsrc_resources,\n\t}, {\n\t\t.name = \"cht_wcove_ext_chgr\",\n\t\t.num_resources = ARRAY_SIZE(cht_wc_ext_charger_resources),\n\t\t.resources = cht_wc_ext_charger_resources,\n\t},\n\t{\t.name = \"cht_wcove_region\", },\n\t{\t.name = \"cht_wcove_leds\", },\n};\n\n \nstatic int cht_wc_byte_reg_read(void *context, unsigned int reg,\n\t\t\t\tunsigned int *val)\n{\n\tstruct i2c_client *client = context;\n\tint ret, orig_addr = client->addr;\n\n\tif (!(reg & REG_ADDR_MASK)) {\n\t\tdev_err(&client->dev, \"Error I2C address not specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tclient->addr = (reg & REG_ADDR_MASK) >> REG_ADDR_SHIFT;\n\tret = i2c_smbus_read_byte_data(client, reg & REG_OFFSET_MASK);\n\tclient->addr = orig_addr;\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*val = ret;\n\treturn 0;\n}\n\nstatic int cht_wc_byte_reg_write(void *context, unsigned int reg,\n\t\t\t\t unsigned int val)\n{\n\tstruct i2c_client *client = context;\n\tint ret, orig_addr = client->addr;\n\n\tif (!(reg & REG_ADDR_MASK)) {\n\t\tdev_err(&client->dev, \"Error I2C address not specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tclient->addr = (reg & REG_ADDR_MASK) >> REG_ADDR_SHIFT;\n\tret = i2c_smbus_write_byte_data(client, reg & REG_OFFSET_MASK, val);\n\tclient->addr = orig_addr;\n\n\treturn ret;\n}\n\nstatic const struct regmap_config cht_wc_regmap_cfg = {\n\t.reg_bits = 16,\n\t.val_bits = 8,\n\t.reg_write = cht_wc_byte_reg_write,\n\t.reg_read = cht_wc_byte_reg_read,\n};\n\nstatic const struct regmap_irq cht_wc_regmap_irqs[] = {\n\tREGMAP_IRQ_REG(CHT_WC_PWRSRC_IRQ, 0, BIT(CHT_WC_PWRSRC_IRQ)),\n\tREGMAP_IRQ_REG(CHT_WC_THRM_IRQ, 0, BIT(CHT_WC_THRM_IRQ)),\n\tREGMAP_IRQ_REG(CHT_WC_BCU_IRQ, 0, BIT(CHT_WC_BCU_IRQ)),\n\tREGMAP_IRQ_REG(CHT_WC_ADC_IRQ, 0, BIT(CHT_WC_ADC_IRQ)),\n\tREGMAP_IRQ_REG(CHT_WC_EXT_CHGR_IRQ, 0, BIT(CHT_WC_EXT_CHGR_IRQ)),\n\tREGMAP_IRQ_REG(CHT_WC_GPIO_IRQ, 0, BIT(CHT_WC_GPIO_IRQ)),\n\tREGMAP_IRQ_REG(CHT_WC_CRIT_IRQ, 0, BIT(CHT_WC_CRIT_IRQ)),\n};\n\nstatic const struct regmap_irq_chip cht_wc_regmap_irq_chip = {\n\t.name = \"cht_wc_irq_chip\",\n\t.status_base = CHT_WC_IRQLVL1,\n\t.mask_base = CHT_WC_IRQLVL1_MASK,\n\t.irqs = cht_wc_regmap_irqs,\n\t.num_irqs = ARRAY_SIZE(cht_wc_regmap_irqs),\n\t.num_regs = 1,\n};\n\nstatic const struct dmi_system_id cht_wc_model_dmi_ids[] = {\n\t{\n\t\t \n\t\t.driver_data = (void *)(long)INTEL_CHT_WC_GPD_WIN_POCKET,\n\t\t \n\t\t.matches = {\n\t\t\tDMI_EXACT_MATCH(DMI_BOARD_VENDOR, \"AMI Corporation\"),\n\t\t\tDMI_EXACT_MATCH(DMI_BOARD_NAME, \"Default string\"),\n\t\t\tDMI_EXACT_MATCH(DMI_BOARD_SERIAL, \"Default string\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_NAME, \"Default string\"),\n\t\t},\n\t}, {\n\t\t \n\t\t.driver_data = (void *)(long)INTEL_CHT_WC_XIAOMI_MIPAD2,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Xiaomi Inc\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Mipad2\"),\n\t\t},\n\t}, {\n\t\t \n\t\t.driver_data = (void *)(long)INTEL_CHT_WC_LENOVO_YOGABOOK1,\n\t\t.matches = {\n\t\t\tDMI_EXACT_MATCH(DMI_SYS_VENDOR, \"Intel Corporation\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_NAME, \"CHERRYVIEW D1 PLATFORM\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_VERSION, \"YETI-11\"),\n\t\t},\n\t}, {\n\t\t \n\t\t.driver_data = (void *)(long)INTEL_CHT_WC_LENOVO_YOGABOOK1,\n\t\t.matches = {\n\t\t\t \n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Lenovo YB1-X91\"),\n\t\t},\n\t}, {\n\t\t \n\t\t.driver_data = (void *)(long)INTEL_CHT_WC_LENOVO_YT3_X90,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Intel Corporation\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"CHERRYVIEW D1 PLATFORM\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_VERSION, \"Blade3-10A-001\"),\n\t\t},\n\t},\n\t{ }\n};\n\nstatic int cht_wc_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tconst struct dmi_system_id *id;\n\tstruct intel_soc_pmic *pmic;\n\tacpi_status status;\n\tunsigned long long hrv;\n\tint ret;\n\n\tstatus = acpi_evaluate_integer(ACPI_HANDLE(dev), \"_HRV\", NULL, &hrv);\n\tif (ACPI_FAILURE(status))\n\t\treturn dev_err_probe(dev, -ENODEV, \"Failed to get PMIC hardware revision\\n\");\n\tif (hrv != CHT_WC_HRV)\n\t\treturn dev_err_probe(dev, -ENODEV, \"Invalid PMIC hardware revision: %llu\\n\", hrv);\n\n\tif (client->irq < 0)\n\t\treturn dev_err_probe(dev, -EINVAL, \"Invalid IRQ\\n\");\n\n\tpmic = devm_kzalloc(dev, sizeof(*pmic), GFP_KERNEL);\n\tif (!pmic)\n\t\treturn -ENOMEM;\n\n\tid = dmi_first_match(cht_wc_model_dmi_ids);\n\tif (id)\n\t\tpmic->cht_wc_model = (long)id->driver_data;\n\n\tpmic->irq = client->irq;\n\tpmic->dev = dev;\n\ti2c_set_clientdata(client, pmic);\n\n\tpmic->regmap = devm_regmap_init(dev, NULL, client, &cht_wc_regmap_cfg);\n\tif (IS_ERR(pmic->regmap))\n\t\treturn PTR_ERR(pmic->regmap);\n\n\tret = devm_regmap_add_irq_chip(dev, pmic->regmap, pmic->irq,\n\t\t\t\t       IRQF_ONESHOT | IRQF_SHARED, 0,\n\t\t\t\t       &cht_wc_regmap_irq_chip,\n\t\t\t\t       &pmic->irq_chip_data);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_mfd_add_devices(dev, PLATFORM_DEVID_NONE,\n\t\t\t\tcht_wc_dev, ARRAY_SIZE(cht_wc_dev), NULL, 0,\n\t\t\t\tregmap_irq_get_domain(pmic->irq_chip_data));\n}\n\nstatic void cht_wc_shutdown(struct i2c_client *client)\n{\n\tstruct intel_soc_pmic *pmic = i2c_get_clientdata(client);\n\n\tdisable_irq(pmic->irq);\n}\n\nstatic int cht_wc_suspend(struct device *dev)\n{\n\tstruct intel_soc_pmic *pmic = dev_get_drvdata(dev);\n\n\tdisable_irq(pmic->irq);\n\n\treturn 0;\n}\n\nstatic int cht_wc_resume(struct device *dev)\n{\n\tstruct intel_soc_pmic *pmic = dev_get_drvdata(dev);\n\n\tenable_irq(pmic->irq);\n\n\treturn 0;\n}\nstatic DEFINE_SIMPLE_DEV_PM_OPS(cht_wc_pm_ops, cht_wc_suspend, cht_wc_resume);\n\nstatic const struct i2c_device_id cht_wc_i2c_id[] = {\n\t{ }\n};\n\nstatic const struct acpi_device_id cht_wc_acpi_ids[] = {\n\t{ \"INT34D3\", },\n\t{ }\n};\n\nstatic struct i2c_driver cht_wc_driver = {\n\t.driver\t= {\n\t\t.name\t= \"CHT Whiskey Cove PMIC\",\n\t\t.pm     = pm_sleep_ptr(&cht_wc_pm_ops),\n\t\t.acpi_match_table = cht_wc_acpi_ids,\n\t},\n\t.probe = cht_wc_probe,\n\t.shutdown = cht_wc_shutdown,\n\t.id_table = cht_wc_i2c_id,\n};\nbuiltin_i2c_driver(cht_wc_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}