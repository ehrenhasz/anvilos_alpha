{
  "module_name": "altera-sysmgr.c",
  "hash_id": "76eebd86bc11f9df682e903134272ae4d682e046c03eb1d9c97a5f918e18c703",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/altera-sysmgr.c",
  "human_readable_source": "\n \n\n#include <linux/arm-smccc.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/mfd/altera-sysmgr.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n \nstruct altr_sysmgr {\n\tstruct regmap   *regmap;\n};\n\nstatic struct platform_driver altr_sysmgr_driver;\n\n \nstatic int s10_protected_reg_write(void *base,\n\t\t\t\t   unsigned int reg, unsigned int val)\n{\n\tstruct arm_smccc_res result;\n\tunsigned long sysmgr_base = (unsigned long)base;\n\n\tarm_smccc_smc(INTEL_SIP_SMC_REG_WRITE, sysmgr_base + reg,\n\t\t      val, 0, 0, 0, 0, 0, &result);\n\n\treturn (int)result.a0;\n}\n\n \nstatic int s10_protected_reg_read(void *base,\n\t\t\t\t  unsigned int reg, unsigned int *val)\n{\n\tstruct arm_smccc_res result;\n\tunsigned long sysmgr_base = (unsigned long)base;\n\n\tarm_smccc_smc(INTEL_SIP_SMC_REG_READ, sysmgr_base + reg,\n\t\t      0, 0, 0, 0, 0, 0, &result);\n\n\t*val = (unsigned int)result.a1;\n\n\treturn (int)result.a0;\n}\n\nstatic struct regmap_config altr_sysmgr_regmap_cfg = {\n\t.name = \"altr_sysmgr\",\n\t.reg_bits = 32,\n\t.reg_stride = 4,\n\t.val_bits = 32,\n\t.fast_io = true,\n\t.use_single_read = true,\n\t.use_single_write = true,\n};\n\n \nstruct regmap *altr_sysmgr_regmap_lookup_by_phandle(struct device_node *np,\n\t\t\t\t\t\t    const char *property)\n{\n\tstruct device *dev;\n\tstruct altr_sysmgr *sysmgr;\n\tstruct device_node *sysmgr_np;\n\n\tif (property)\n\t\tsysmgr_np = of_parse_phandle(np, property, 0);\n\telse\n\t\tsysmgr_np = np;\n\n\tif (!sysmgr_np)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tdev = driver_find_device_by_of_node(&altr_sysmgr_driver.driver,\n\t\t\t\t\t    (void *)sysmgr_np);\n\tof_node_put(sysmgr_np);\n\tif (!dev)\n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\n\tsysmgr = dev_get_drvdata(dev);\n\n\treturn sysmgr->regmap;\n}\nEXPORT_SYMBOL_GPL(altr_sysmgr_regmap_lookup_by_phandle);\n\nstatic int sysmgr_probe(struct platform_device *pdev)\n{\n\tstruct altr_sysmgr *sysmgr;\n\tstruct regmap *regmap;\n\tstruct resource *res;\n\tstruct regmap_config sysmgr_config = altr_sysmgr_regmap_cfg;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tvoid __iomem *base;\n\n\tsysmgr = devm_kzalloc(dev, sizeof(*sysmgr), GFP_KERNEL);\n\tif (!sysmgr)\n\t\treturn -ENOMEM;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -ENOENT;\n\n\tsysmgr_config.max_register = resource_size(res) -\n\t\t\t\t     sysmgr_config.reg_stride;\n\tif (of_device_is_compatible(np, \"altr,sys-mgr-s10\")) {\n\t\tsysmgr_config.reg_read = s10_protected_reg_read;\n\t\tsysmgr_config.reg_write = s10_protected_reg_write;\n\n\t\t \n\t\tregmap = devm_regmap_init(dev, NULL,\n\t\t\t\t\t  (void *)(uintptr_t)res->start,\n\t\t\t\t\t  &sysmgr_config);\n\t} else {\n\t\tbase = devm_ioremap(dev, res->start, resource_size(res));\n\t\tif (!base)\n\t\t\treturn -ENOMEM;\n\n\t\tsysmgr_config.max_register = resource_size(res) - 4;\n\t\tregmap = devm_regmap_init_mmio(dev, base, &sysmgr_config);\n\t}\n\n\tif (IS_ERR(regmap)) {\n\t\tpr_err(\"regmap init failed\\n\");\n\t\treturn PTR_ERR(regmap);\n\t}\n\n\tsysmgr->regmap = regmap;\n\n\tplatform_set_drvdata(pdev, sysmgr);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id altr_sysmgr_of_match[] = {\n\t{ .compatible = \"altr,sys-mgr\" },\n\t{ .compatible = \"altr,sys-mgr-s10\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, altr_sysmgr_of_match);\n\nstatic struct platform_driver altr_sysmgr_driver = {\n\t.probe =  sysmgr_probe,\n\t.driver = {\n\t\t.name = \"altr,system_manager\",\n\t\t.of_match_table = altr_sysmgr_of_match,\n\t},\n};\n\nstatic int __init altr_sysmgr_init(void)\n{\n\treturn platform_driver_register(&altr_sysmgr_driver);\n}\ncore_initcall(altr_sysmgr_init);\n\nstatic void __exit altr_sysmgr_exit(void)\n{\n\tplatform_driver_unregister(&altr_sysmgr_driver);\n}\nmodule_exit(altr_sysmgr_exit);\n\nMODULE_AUTHOR(\"Thor Thayer <>\");\nMODULE_DESCRIPTION(\"SOCFPGA System Manager driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}