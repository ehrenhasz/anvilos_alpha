{
  "module_name": "dln2.c",
  "hash_id": "45cc13ac663a7ba73df5e8e679cec4e63e306e15d76b3c8dcfd4bbe2d145d223",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/dln2.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/usb.h>\n#include <linux/mutex.h>\n#include <linux/platform_device.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/dln2.h>\n#include <linux/rculist.h>\n\nstruct dln2_header {\n\t__le16 size;\n\t__le16 id;\n\t__le16 echo;\n\t__le16 handle;\n};\n\nstruct dln2_response {\n\tstruct dln2_header hdr;\n\t__le16 result;\n};\n\n#define DLN2_GENERIC_MODULE_ID\t\t0x00\n#define DLN2_GENERIC_CMD(cmd)\t\tDLN2_CMD(cmd, DLN2_GENERIC_MODULE_ID)\n#define CMD_GET_DEVICE_VER\t\tDLN2_GENERIC_CMD(0x30)\n#define CMD_GET_DEVICE_SN\t\tDLN2_GENERIC_CMD(0x31)\n\n#define DLN2_HW_ID\t\t\t0x200\n#define DLN2_USB_TIMEOUT\t\t200\t \n#define DLN2_MAX_RX_SLOTS\t\t16\n#define DLN2_MAX_URBS\t\t\t16\n#define DLN2_RX_BUF_SIZE\t\t512\n\nenum dln2_handle {\n\tDLN2_HANDLE_EVENT = 0,\t\t \n\tDLN2_HANDLE_CTRL,\n\tDLN2_HANDLE_GPIO,\n\tDLN2_HANDLE_I2C,\n\tDLN2_HANDLE_SPI,\n\tDLN2_HANDLE_ADC,\n\tDLN2_HANDLES\n};\n\n \nstruct dln2_rx_context {\n\t \n\tstruct completion done;\n\n\t \n\tstruct urb *urb;\n\n\t \n\tbool in_use;\n};\n\n \nstruct dln2_mod_rx_slots {\n\t \n\tDECLARE_BITMAP(bmap, DLN2_MAX_RX_SLOTS);\n\n\t \n\twait_queue_head_t wq;\n\n\t \n\tstruct dln2_rx_context slots[DLN2_MAX_RX_SLOTS];\n\n\t \n\tspinlock_t lock;\n};\n\nstruct dln2_dev {\n\tstruct usb_device *usb_dev;\n\tstruct usb_interface *interface;\n\tu8 ep_in;\n\tu8 ep_out;\n\n\tstruct urb *rx_urb[DLN2_MAX_URBS];\n\tvoid *rx_buf[DLN2_MAX_URBS];\n\n\tstruct dln2_mod_rx_slots mod_rx_slots[DLN2_HANDLES];\n\n\tstruct list_head event_cb_list;\n\tspinlock_t event_cb_lock;\n\n\tbool disconnect;\n\tint active_transfers;\n\twait_queue_head_t disconnect_wq;\n\tspinlock_t disconnect_lock;\n};\n\nstruct dln2_event_cb_entry {\n\tstruct list_head list;\n\tu16 id;\n\tstruct platform_device *pdev;\n\tdln2_event_cb_t callback;\n};\n\nint dln2_register_event_cb(struct platform_device *pdev, u16 id,\n\t\t\t   dln2_event_cb_t event_cb)\n{\n\tstruct dln2_dev *dln2 = dev_get_drvdata(pdev->dev.parent);\n\tstruct dln2_event_cb_entry *i, *entry;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tentry->id = id;\n\tentry->callback = event_cb;\n\tentry->pdev = pdev;\n\n\tspin_lock_irqsave(&dln2->event_cb_lock, flags);\n\n\tlist_for_each_entry(i, &dln2->event_cb_list, list) {\n\t\tif (i->id == id) {\n\t\t\tret = -EBUSY;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!ret)\n\t\tlist_add_rcu(&entry->list, &dln2->event_cb_list);\n\n\tspin_unlock_irqrestore(&dln2->event_cb_lock, flags);\n\n\tif (ret)\n\t\tkfree(entry);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(dln2_register_event_cb);\n\nvoid dln2_unregister_event_cb(struct platform_device *pdev, u16 id)\n{\n\tstruct dln2_dev *dln2 = dev_get_drvdata(pdev->dev.parent);\n\tstruct dln2_event_cb_entry *i;\n\tunsigned long flags;\n\tbool found = false;\n\n\tspin_lock_irqsave(&dln2->event_cb_lock, flags);\n\n\tlist_for_each_entry(i, &dln2->event_cb_list, list) {\n\t\tif (i->id == id) {\n\t\t\tlist_del_rcu(&i->list);\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&dln2->event_cb_lock, flags);\n\n\tif (found) {\n\t\tsynchronize_rcu();\n\t\tkfree(i);\n\t}\n}\nEXPORT_SYMBOL(dln2_unregister_event_cb);\n\n \nstatic bool dln2_transfer_complete(struct dln2_dev *dln2, struct urb *urb,\n\t\t\t\t   u16 handle, u16 rx_slot)\n{\n\tstruct device *dev = &dln2->interface->dev;\n\tstruct dln2_mod_rx_slots *rxs = &dln2->mod_rx_slots[handle];\n\tstruct dln2_rx_context *rxc;\n\tunsigned long flags;\n\tbool valid_slot = false;\n\n\tif (rx_slot >= DLN2_MAX_RX_SLOTS)\n\t\tgoto out;\n\n\trxc = &rxs->slots[rx_slot];\n\n\tspin_lock_irqsave(&rxs->lock, flags);\n\tif (rxc->in_use && !rxc->urb) {\n\t\trxc->urb = urb;\n\t\tcomplete(&rxc->done);\n\t\tvalid_slot = true;\n\t}\n\tspin_unlock_irqrestore(&rxs->lock, flags);\n\nout:\n\tif (!valid_slot)\n\t\tdev_warn(dev, \"bad/late response %d/%d\\n\", handle, rx_slot);\n\n\treturn valid_slot;\n}\n\nstatic void dln2_run_event_callbacks(struct dln2_dev *dln2, u16 id, u16 echo,\n\t\t\t\t     void *data, int len)\n{\n\tstruct dln2_event_cb_entry *i;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry_rcu(i, &dln2->event_cb_list, list) {\n\t\tif (i->id == id) {\n\t\t\ti->callback(i->pdev, echo, data, len);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n}\n\nstatic void dln2_rx(struct urb *urb)\n{\n\tstruct dln2_dev *dln2 = urb->context;\n\tstruct dln2_header *hdr = urb->transfer_buffer;\n\tstruct device *dev = &dln2->interface->dev;\n\tu16 id, echo, handle, size;\n\tu8 *data;\n\tint len;\n\tint err;\n\n\tswitch (urb->status) {\n\tcase 0:\n\t\t \n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\tcase -EPIPE:\n\t\t \n\t\tdev_dbg(dev, \"urb shutting down with status %d\\n\", urb->status);\n\t\treturn;\n\tdefault:\n\t\tdev_dbg(dev, \"nonzero urb status received %d\\n\", urb->status);\n\t\tgoto out;\n\t}\n\n\tif (urb->actual_length < sizeof(struct dln2_header)) {\n\t\tdev_err(dev, \"short response: %d\\n\", urb->actual_length);\n\t\tgoto out;\n\t}\n\n\thandle = le16_to_cpu(hdr->handle);\n\tid = le16_to_cpu(hdr->id);\n\techo = le16_to_cpu(hdr->echo);\n\tsize = le16_to_cpu(hdr->size);\n\n\tif (size != urb->actual_length) {\n\t\tdev_err(dev, \"size mismatch: handle %x cmd %x echo %x size %d actual %d\\n\",\n\t\t\thandle, id, echo, size, urb->actual_length);\n\t\tgoto out;\n\t}\n\n\tif (handle >= DLN2_HANDLES) {\n\t\tdev_warn(dev, \"invalid handle %d\\n\", handle);\n\t\tgoto out;\n\t}\n\n\tdata = urb->transfer_buffer + sizeof(struct dln2_header);\n\tlen = urb->actual_length - sizeof(struct dln2_header);\n\n\tif (handle == DLN2_HANDLE_EVENT) {\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&dln2->event_cb_lock, flags);\n\t\tdln2_run_event_callbacks(dln2, id, echo, data, len);\n\t\tspin_unlock_irqrestore(&dln2->event_cb_lock, flags);\n\t} else {\n\t\t \n\t\tif (dln2_transfer_complete(dln2, urb, handle, echo))\n\t\t\treturn;\n\t}\n\nout:\n\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (err < 0)\n\t\tdev_err(dev, \"failed to resubmit RX URB: %d\\n\", err);\n}\n\nstatic void *dln2_prep_buf(u16 handle, u16 cmd, u16 echo, const void *obuf,\n\t\t\t   int *obuf_len, gfp_t gfp)\n{\n\tint len;\n\tvoid *buf;\n\tstruct dln2_header *hdr;\n\n\tlen = *obuf_len + sizeof(*hdr);\n\tbuf = kmalloc(len, gfp);\n\tif (!buf)\n\t\treturn NULL;\n\n\thdr = (struct dln2_header *)buf;\n\thdr->id = cpu_to_le16(cmd);\n\thdr->size = cpu_to_le16(len);\n\thdr->echo = cpu_to_le16(echo);\n\thdr->handle = cpu_to_le16(handle);\n\n\tmemcpy(buf + sizeof(*hdr), obuf, *obuf_len);\n\n\t*obuf_len = len;\n\n\treturn buf;\n}\n\nstatic int dln2_send_wait(struct dln2_dev *dln2, u16 handle, u16 cmd, u16 echo,\n\t\t\t  const void *obuf, int obuf_len)\n{\n\tint ret = 0;\n\tint len = obuf_len;\n\tvoid *buf;\n\tint actual;\n\n\tbuf = dln2_prep_buf(handle, cmd, echo, obuf, &len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = usb_bulk_msg(dln2->usb_dev,\n\t\t\t   usb_sndbulkpipe(dln2->usb_dev, dln2->ep_out),\n\t\t\t   buf, len, &actual, DLN2_USB_TIMEOUT);\n\n\tkfree(buf);\n\n\treturn ret;\n}\n\nstatic bool find_free_slot(struct dln2_dev *dln2, u16 handle, int *slot)\n{\n\tstruct dln2_mod_rx_slots *rxs;\n\tunsigned long flags;\n\n\tif (dln2->disconnect) {\n\t\t*slot = -ENODEV;\n\t\treturn true;\n\t}\n\n\trxs = &dln2->mod_rx_slots[handle];\n\n\tspin_lock_irqsave(&rxs->lock, flags);\n\n\t*slot = find_first_zero_bit(rxs->bmap, DLN2_MAX_RX_SLOTS);\n\n\tif (*slot < DLN2_MAX_RX_SLOTS) {\n\t\tstruct dln2_rx_context *rxc = &rxs->slots[*slot];\n\n\t\tset_bit(*slot, rxs->bmap);\n\t\trxc->in_use = true;\n\t}\n\n\tspin_unlock_irqrestore(&rxs->lock, flags);\n\n\treturn *slot < DLN2_MAX_RX_SLOTS;\n}\n\nstatic int alloc_rx_slot(struct dln2_dev *dln2, u16 handle)\n{\n\tint ret;\n\tint slot;\n\n\t \n\tret = wait_event_interruptible(dln2->mod_rx_slots[handle].wq,\n\t\t\t\t       find_free_slot(dln2, handle, &slot));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn slot;\n}\n\nstatic void free_rx_slot(struct dln2_dev *dln2, u16 handle, int slot)\n{\n\tstruct dln2_mod_rx_slots *rxs;\n\tstruct urb *urb = NULL;\n\tunsigned long flags;\n\tstruct dln2_rx_context *rxc;\n\n\trxs = &dln2->mod_rx_slots[handle];\n\n\tspin_lock_irqsave(&rxs->lock, flags);\n\n\tclear_bit(slot, rxs->bmap);\n\n\trxc = &rxs->slots[slot];\n\trxc->in_use = false;\n\turb = rxc->urb;\n\trxc->urb = NULL;\n\treinit_completion(&rxc->done);\n\n\tspin_unlock_irqrestore(&rxs->lock, flags);\n\n\tif (urb) {\n\t\tint err;\n\t\tstruct device *dev = &dln2->interface->dev;\n\n\t\terr = usb_submit_urb(urb, GFP_KERNEL);\n\t\tif (err < 0)\n\t\t\tdev_err(dev, \"failed to resubmit RX URB: %d\\n\", err);\n\t}\n\n\twake_up_interruptible(&rxs->wq);\n}\n\nstatic int _dln2_transfer(struct dln2_dev *dln2, u16 handle, u16 cmd,\n\t\t\t  const void *obuf, unsigned obuf_len,\n\t\t\t  void *ibuf, unsigned *ibuf_len)\n{\n\tint ret = 0;\n\tint rx_slot;\n\tstruct dln2_response *rsp;\n\tstruct dln2_rx_context *rxc;\n\tstruct device *dev = &dln2->interface->dev;\n\tconst unsigned long timeout = msecs_to_jiffies(DLN2_USB_TIMEOUT);\n\tstruct dln2_mod_rx_slots *rxs = &dln2->mod_rx_slots[handle];\n\tint size;\n\n\tspin_lock(&dln2->disconnect_lock);\n\tif (!dln2->disconnect)\n\t\tdln2->active_transfers++;\n\telse\n\t\tret = -ENODEV;\n\tspin_unlock(&dln2->disconnect_lock);\n\n\tif (ret)\n\t\treturn ret;\n\n\trx_slot = alloc_rx_slot(dln2, handle);\n\tif (rx_slot < 0) {\n\t\tret = rx_slot;\n\t\tgoto out_decr;\n\t}\n\n\tret = dln2_send_wait(dln2, handle, cmd, rx_slot, obuf, obuf_len);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"USB write failed: %d\\n\", ret);\n\t\tgoto out_free_rx_slot;\n\t}\n\n\trxc = &rxs->slots[rx_slot];\n\n\tret = wait_for_completion_interruptible_timeout(&rxc->done, timeout);\n\tif (ret <= 0) {\n\t\tif (!ret)\n\t\t\tret = -ETIMEDOUT;\n\t\tgoto out_free_rx_slot;\n\t} else {\n\t\tret = 0;\n\t}\n\n\tif (dln2->disconnect) {\n\t\tret = -ENODEV;\n\t\tgoto out_free_rx_slot;\n\t}\n\n\t \n\trsp = rxc->urb->transfer_buffer;\n\tsize = le16_to_cpu(rsp->hdr.size);\n\n\tif (size < sizeof(*rsp)) {\n\t\tret = -EPROTO;\n\t\tgoto out_free_rx_slot;\n\t}\n\n\tif (le16_to_cpu(rsp->result) > 0x80) {\n\t\tdev_dbg(dev, \"%d received response with error %d\\n\",\n\t\t\thandle, le16_to_cpu(rsp->result));\n\t\tret = -EREMOTEIO;\n\t\tgoto out_free_rx_slot;\n\t}\n\n\tif (!ibuf)\n\t\tgoto out_free_rx_slot;\n\n\tif (*ibuf_len > size - sizeof(*rsp))\n\t\t*ibuf_len = size - sizeof(*rsp);\n\n\tmemcpy(ibuf, rsp + 1, *ibuf_len);\n\nout_free_rx_slot:\n\tfree_rx_slot(dln2, handle, rx_slot);\nout_decr:\n\tspin_lock(&dln2->disconnect_lock);\n\tdln2->active_transfers--;\n\tspin_unlock(&dln2->disconnect_lock);\n\tif (dln2->disconnect)\n\t\twake_up(&dln2->disconnect_wq);\n\n\treturn ret;\n}\n\nint dln2_transfer(struct platform_device *pdev, u16 cmd,\n\t\t  const void *obuf, unsigned obuf_len,\n\t\t  void *ibuf, unsigned *ibuf_len)\n{\n\tstruct dln2_platform_data *dln2_pdata;\n\tstruct dln2_dev *dln2;\n\tu16 handle;\n\n\tdln2 = dev_get_drvdata(pdev->dev.parent);\n\tdln2_pdata = dev_get_platdata(&pdev->dev);\n\thandle = dln2_pdata->handle;\n\n\treturn _dln2_transfer(dln2, handle, cmd, obuf, obuf_len, ibuf,\n\t\t\t      ibuf_len);\n}\nEXPORT_SYMBOL(dln2_transfer);\n\nstatic int dln2_check_hw(struct dln2_dev *dln2)\n{\n\tint ret;\n\t__le32 hw_type;\n\tint len = sizeof(hw_type);\n\n\tret = _dln2_transfer(dln2, DLN2_HANDLE_CTRL, CMD_GET_DEVICE_VER,\n\t\t\t     NULL, 0, &hw_type, &len);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (len < sizeof(hw_type))\n\t\treturn -EREMOTEIO;\n\n\tif (le32_to_cpu(hw_type) != DLN2_HW_ID) {\n\t\tdev_err(&dln2->interface->dev, \"Device ID 0x%x not supported\\n\",\n\t\t\tle32_to_cpu(hw_type));\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int dln2_print_serialno(struct dln2_dev *dln2)\n{\n\tint ret;\n\t__le32 serial_no;\n\tint len = sizeof(serial_no);\n\tstruct device *dev = &dln2->interface->dev;\n\n\tret = _dln2_transfer(dln2, DLN2_HANDLE_CTRL, CMD_GET_DEVICE_SN, NULL, 0,\n\t\t\t     &serial_no, &len);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (len < sizeof(serial_no))\n\t\treturn -EREMOTEIO;\n\n\tdev_info(dev, \"Diolan DLN2 serial %u\\n\", le32_to_cpu(serial_no));\n\n\treturn 0;\n}\n\nstatic int dln2_hw_init(struct dln2_dev *dln2)\n{\n\tint ret;\n\n\tret = dln2_check_hw(dln2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn dln2_print_serialno(dln2);\n}\n\nstatic void dln2_free_rx_urbs(struct dln2_dev *dln2)\n{\n\tint i;\n\n\tfor (i = 0; i < DLN2_MAX_URBS; i++) {\n\t\tusb_free_urb(dln2->rx_urb[i]);\n\t\tkfree(dln2->rx_buf[i]);\n\t}\n}\n\nstatic void dln2_stop_rx_urbs(struct dln2_dev *dln2)\n{\n\tint i;\n\n\tfor (i = 0; i < DLN2_MAX_URBS; i++)\n\t\tusb_kill_urb(dln2->rx_urb[i]);\n}\n\nstatic void dln2_free(struct dln2_dev *dln2)\n{\n\tdln2_free_rx_urbs(dln2);\n\tusb_put_dev(dln2->usb_dev);\n\tkfree(dln2);\n}\n\nstatic int dln2_setup_rx_urbs(struct dln2_dev *dln2,\n\t\t\t      struct usb_host_interface *hostif)\n{\n\tint i;\n\tconst int rx_max_size = DLN2_RX_BUF_SIZE;\n\n\tfor (i = 0; i < DLN2_MAX_URBS; i++) {\n\t\tdln2->rx_buf[i] = kmalloc(rx_max_size, GFP_KERNEL);\n\t\tif (!dln2->rx_buf[i])\n\t\t\treturn -ENOMEM;\n\n\t\tdln2->rx_urb[i] = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!dln2->rx_urb[i])\n\t\t\treturn -ENOMEM;\n\n\t\tusb_fill_bulk_urb(dln2->rx_urb[i], dln2->usb_dev,\n\t\t\t\t  usb_rcvbulkpipe(dln2->usb_dev, dln2->ep_in),\n\t\t\t\t  dln2->rx_buf[i], rx_max_size, dln2_rx, dln2);\n\t}\n\n\treturn 0;\n}\n\nstatic int dln2_start_rx_urbs(struct dln2_dev *dln2, gfp_t gfp)\n{\n\tstruct device *dev = &dln2->interface->dev;\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < DLN2_MAX_URBS; i++) {\n\t\tret = usb_submit_urb(dln2->rx_urb[i], gfp);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"failed to submit RX URB: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nenum {\n\tDLN2_ACPI_MATCH_GPIO\t= 0,\n\tDLN2_ACPI_MATCH_I2C\t= 1,\n\tDLN2_ACPI_MATCH_SPI\t= 2,\n\tDLN2_ACPI_MATCH_ADC\t= 3,\n};\n\nstatic struct dln2_platform_data dln2_pdata_gpio = {\n\t.handle = DLN2_HANDLE_GPIO,\n};\n\nstatic struct mfd_cell_acpi_match dln2_acpi_match_gpio = {\n\t.adr = DLN2_ACPI_MATCH_GPIO,\n};\n\n \nstatic struct dln2_platform_data dln2_pdata_i2c = {\n\t.handle = DLN2_HANDLE_I2C,\n\t.port = 0,\n};\n\nstatic struct mfd_cell_acpi_match dln2_acpi_match_i2c = {\n\t.adr = DLN2_ACPI_MATCH_I2C,\n};\n\n \nstatic struct dln2_platform_data dln2_pdata_spi = {\n\t.handle = DLN2_HANDLE_SPI,\n\t.port = 0,\n};\n\nstatic struct mfd_cell_acpi_match dln2_acpi_match_spi = {\n\t.adr = DLN2_ACPI_MATCH_SPI,\n};\n\n \nstatic struct dln2_platform_data dln2_pdata_adc = {\n\t.handle = DLN2_HANDLE_ADC,\n\t.port = 0,\n};\n\nstatic struct mfd_cell_acpi_match dln2_acpi_match_adc = {\n\t.adr = DLN2_ACPI_MATCH_ADC,\n};\n\nstatic const struct mfd_cell dln2_devs[] = {\n\t{\n\t\t.name = \"dln2-gpio\",\n\t\t.acpi_match = &dln2_acpi_match_gpio,\n\t\t.platform_data = &dln2_pdata_gpio,\n\t\t.pdata_size = sizeof(struct dln2_platform_data),\n\t},\n\t{\n\t\t.name = \"dln2-i2c\",\n\t\t.acpi_match = &dln2_acpi_match_i2c,\n\t\t.platform_data = &dln2_pdata_i2c,\n\t\t.pdata_size = sizeof(struct dln2_platform_data),\n\t},\n\t{\n\t\t.name = \"dln2-spi\",\n\t\t.acpi_match = &dln2_acpi_match_spi,\n\t\t.platform_data = &dln2_pdata_spi,\n\t\t.pdata_size = sizeof(struct dln2_platform_data),\n\t},\n\t{\n\t\t.name = \"dln2-adc\",\n\t\t.acpi_match = &dln2_acpi_match_adc,\n\t\t.platform_data = &dln2_pdata_adc,\n\t\t.pdata_size = sizeof(struct dln2_platform_data),\n\t},\n};\n\nstatic void dln2_stop(struct dln2_dev *dln2)\n{\n\tint i, j;\n\n\t \n\tspin_lock(&dln2->disconnect_lock);\n\tdln2->disconnect = true;\n\tspin_unlock(&dln2->disconnect_lock);\n\n\t \n\tfor (i = 0; i < DLN2_HANDLES; i++) {\n\t\tstruct dln2_mod_rx_slots *rxs = &dln2->mod_rx_slots[i];\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&rxs->lock, flags);\n\n\t\t \n\t\tfor (j = 0; j < DLN2_MAX_RX_SLOTS; j++) {\n\t\t\tstruct dln2_rx_context *rxc = &rxs->slots[j];\n\n\t\t\tif (rxc->in_use)\n\t\t\t\tcomplete(&rxc->done);\n\t\t}\n\n\t\tspin_unlock_irqrestore(&rxs->lock, flags);\n\t}\n\n\t \n\twait_event(dln2->disconnect_wq, !dln2->active_transfers);\n\n\tdln2_stop_rx_urbs(dln2);\n}\n\nstatic void dln2_disconnect(struct usb_interface *interface)\n{\n\tstruct dln2_dev *dln2 = usb_get_intfdata(interface);\n\n\tdln2_stop(dln2);\n\n\tmfd_remove_devices(&interface->dev);\n\n\tdln2_free(dln2);\n}\n\nstatic int dln2_probe(struct usb_interface *interface,\n\t\t      const struct usb_device_id *usb_id)\n{\n\tstruct usb_host_interface *hostif = interface->cur_altsetting;\n\tstruct usb_endpoint_descriptor *epin;\n\tstruct usb_endpoint_descriptor *epout;\n\tstruct device *dev = &interface->dev;\n\tstruct dln2_dev *dln2;\n\tint ret;\n\tint i, j;\n\n\tif (hostif->desc.bInterfaceNumber != 0)\n\t\treturn -ENODEV;\n\n\tret = usb_find_common_endpoints(hostif, &epin, &epout, NULL, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tdln2 = kzalloc(sizeof(*dln2), GFP_KERNEL);\n\tif (!dln2)\n\t\treturn -ENOMEM;\n\n\tdln2->ep_out = epout->bEndpointAddress;\n\tdln2->ep_in = epin->bEndpointAddress;\n\tdln2->usb_dev = usb_get_dev(interface_to_usbdev(interface));\n\tdln2->interface = interface;\n\tusb_set_intfdata(interface, dln2);\n\tinit_waitqueue_head(&dln2->disconnect_wq);\n\n\tfor (i = 0; i < DLN2_HANDLES; i++) {\n\t\tinit_waitqueue_head(&dln2->mod_rx_slots[i].wq);\n\t\tspin_lock_init(&dln2->mod_rx_slots[i].lock);\n\t\tfor (j = 0; j < DLN2_MAX_RX_SLOTS; j++)\n\t\t\tinit_completion(&dln2->mod_rx_slots[i].slots[j].done);\n\t}\n\n\tspin_lock_init(&dln2->event_cb_lock);\n\tspin_lock_init(&dln2->disconnect_lock);\n\tINIT_LIST_HEAD(&dln2->event_cb_list);\n\n\tret = dln2_setup_rx_urbs(dln2, hostif);\n\tif (ret)\n\t\tgoto out_free;\n\n\tret = dln2_start_rx_urbs(dln2, GFP_KERNEL);\n\tif (ret)\n\t\tgoto out_stop_rx;\n\n\tret = dln2_hw_init(dln2);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to initialize hardware\\n\");\n\t\tgoto out_stop_rx;\n\t}\n\n\tret = mfd_add_hotplug_devices(dev, dln2_devs, ARRAY_SIZE(dln2_devs));\n\tif (ret != 0) {\n\t\tdev_err(dev, \"failed to add mfd devices to core\\n\");\n\t\tgoto out_stop_rx;\n\t}\n\n\treturn 0;\n\nout_stop_rx:\n\tdln2_stop_rx_urbs(dln2);\n\nout_free:\n\tdln2_free(dln2);\n\n\treturn ret;\n}\n\nstatic int dln2_suspend(struct usb_interface *iface, pm_message_t message)\n{\n\tstruct dln2_dev *dln2 = usb_get_intfdata(iface);\n\n\tdln2_stop(dln2);\n\n\treturn 0;\n}\n\nstatic int dln2_resume(struct usb_interface *iface)\n{\n\tstruct dln2_dev *dln2 = usb_get_intfdata(iface);\n\n\tdln2->disconnect = false;\n\n\treturn dln2_start_rx_urbs(dln2, GFP_NOIO);\n}\n\nstatic const struct usb_device_id dln2_table[] = {\n\t{ USB_DEVICE(0xa257, 0x2013) },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(usb, dln2_table);\n\nstatic struct usb_driver dln2_driver = {\n\t.name = \"dln2\",\n\t.probe = dln2_probe,\n\t.disconnect = dln2_disconnect,\n\t.id_table = dln2_table,\n\t.suspend = dln2_suspend,\n\t.resume = dln2_resume,\n};\n\nmodule_usb_driver(dln2_driver);\n\nMODULE_AUTHOR(\"Octavian Purdila <octavian.purdila@intel.com>\");\nMODULE_DESCRIPTION(\"Core driver for the Diolan DLN2 interface adapter\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}