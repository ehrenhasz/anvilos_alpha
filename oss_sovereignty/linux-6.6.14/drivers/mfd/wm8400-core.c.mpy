{
  "module_name": "wm8400-core.c",
  "hash_id": "4a8e8ad2396d32081d374fff11ecacddd02c5f0ce03d7825861674fc7816359a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/wm8400-core.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/bug.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/wm8400-private.h>\n#include <linux/mfd/wm8400-audio.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\nstatic bool wm8400_volatile(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase WM8400_INTERRUPT_STATUS_1:\n\tcase WM8400_INTERRUPT_LEVELS:\n\tcase WM8400_SHUTDOWN_REASON:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int wm8400_register_codec(struct wm8400 *wm8400)\n{\n\tconst struct mfd_cell cell = {\n\t\t.name = \"wm8400-codec\",\n\t\t.platform_data = wm8400,\n\t\t.pdata_size = sizeof(*wm8400),\n\t};\n\n\treturn devm_mfd_add_devices(wm8400->dev, -1, &cell, 1, NULL, 0, NULL);\n}\n\n \nstatic int wm8400_init(struct wm8400 *wm8400,\n\t\t       struct wm8400_platform_data *pdata)\n{\n\tunsigned int reg;\n\tint ret;\n\n\t \n\tret = regmap_read(wm8400->regmap, WM8400_RESET_ID, &reg);\n\tif (ret != 0) {\n\t\tdev_err(wm8400->dev, \"Chip ID register read failed\\n\");\n\t\treturn -EIO;\n\t}\n\tif (reg != 0x6172) {\n\t\tdev_err(wm8400->dev, \"Device is not a WM8400, ID is %x\\n\",\n\t\t\treg);\n\t\treturn -ENODEV;\n\t}\n\n\tret = regmap_read(wm8400->regmap, WM8400_ID, &reg);\n\tif (ret != 0) {\n\t\tdev_err(wm8400->dev, \"ID register read failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\treg = (reg & WM8400_CHIP_REV_MASK) >> WM8400_CHIP_REV_SHIFT;\n\tdev_info(wm8400->dev, \"WM8400 revision %x\\n\", reg);\n\n\tret = wm8400_register_codec(wm8400);\n\tif (ret != 0) {\n\t\tdev_err(wm8400->dev, \"Failed to register codec\\n\");\n\t\treturn ret;\n\t}\n\n\tif (pdata && pdata->platform_init) {\n\t\tret = pdata->platform_init(wm8400->dev);\n\t\tif (ret != 0) {\n\t\t\tdev_err(wm8400->dev, \"Platform init failed: %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t} else\n\t\tdev_warn(wm8400->dev, \"No platform initialisation supplied\\n\");\n\n\treturn 0;\n}\n\nstatic const struct regmap_config wm8400_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 16,\n\t.max_register = WM8400_REGISTER_COUNT - 1,\n\n\t.volatile_reg = wm8400_volatile,\n\n\t.cache_type = REGCACHE_RBTREE,\n};\n\n \nvoid wm8400_reset_codec_reg_cache(struct wm8400 *wm8400)\n{\n\tregmap_reinit_cache(wm8400->regmap, &wm8400_regmap_config);\n}\nEXPORT_SYMBOL_GPL(wm8400_reset_codec_reg_cache);\n\n#if IS_ENABLED(CONFIG_I2C)\nstatic int wm8400_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct wm8400 *wm8400;\n\n\twm8400 = devm_kzalloc(&i2c->dev, sizeof(struct wm8400), GFP_KERNEL);\n\tif (!wm8400)\n\t\treturn -ENOMEM;\n\n\twm8400->regmap = devm_regmap_init_i2c(i2c, &wm8400_regmap_config);\n\tif (IS_ERR(wm8400->regmap))\n\t\treturn PTR_ERR(wm8400->regmap);\n\n\twm8400->dev = &i2c->dev;\n\ti2c_set_clientdata(i2c, wm8400);\n\n\treturn wm8400_init(wm8400, dev_get_platdata(&i2c->dev));\n}\n\nstatic const struct i2c_device_id wm8400_i2c_id[] = {\n       { \"wm8400\", 0 },\n       { }\n};\n\nstatic struct i2c_driver wm8400_i2c_driver = {\n\t.driver = {\n\t\t.name = \"WM8400\",\n\t},\n\t.probe = wm8400_i2c_probe,\n\t.id_table = wm8400_i2c_id,\n};\n#endif\n\nstatic int __init wm8400_driver_init(void)\n{\n\tint ret = -ENODEV;\n\n#if IS_ENABLED(CONFIG_I2C)\n\tret = i2c_add_driver(&wm8400_i2c_driver);\n\tif (ret != 0)\n\t\tpr_err(\"Failed to register I2C driver: %d\\n\", ret);\n#endif\n\n\treturn ret;\n}\nsubsys_initcall(wm8400_driver_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}