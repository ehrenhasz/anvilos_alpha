{
  "module_name": "rz-mtu3.c",
  "hash_id": "00bbd1df68732f2e072d7752f1e49cf424c716fa8374cbdb26c29d13caeda603",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/rz-mtu3.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/rz-mtu3.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n#include <linux/spinlock.h>\n\n#include \"rz-mtu3.h\"\n\nstruct rz_mtu3_priv {\n\tvoid __iomem *mmio;\n\tstruct reset_control *rstc;\n\tspinlock_t lock;\n};\n\n \nstatic const unsigned long rz_mtu3_8bit_ch_reg_offs[][13] = {\n\t[RZ_MTU3_CHAN_0] = MTU_8BIT_CH_0(0x104, 0x090, 0x100, 0x128, 0x101, 0x102, 0x103, 0x126),\n\t[RZ_MTU3_CHAN_1] = MTU_8BIT_CH_1_2(0x184, 0x091, 0x185, 0x180, 0x194, 0x181, 0x182),\n\t[RZ_MTU3_CHAN_2] = MTU_8BIT_CH_1_2(0x204, 0x092, 0x205, 0x200, 0x20c, 0x201, 0x202),\n\t[RZ_MTU3_CHAN_3] = MTU_8BIT_CH_3_4_6_7(0x008, 0x093, 0x02c, 0x000, 0x04c, 0x002, 0x004, 0x005, 0x038),\n\t[RZ_MTU3_CHAN_4] = MTU_8BIT_CH_3_4_6_7(0x009, 0x094, 0x02d, 0x001, 0x04d, 0x003, 0x006, 0x007, 0x039),\n\t[RZ_MTU3_CHAN_5] = MTU_8BIT_CH_5(0xab2, 0x1eb, 0xab4, 0xab6, 0xa84, 0xa85, 0xa86, 0xa94, 0xa95, 0xa96, 0xaa4, 0xaa5, 0xaa6),\n\t[RZ_MTU3_CHAN_6] = MTU_8BIT_CH_3_4_6_7(0x808, 0x893, 0x82c, 0x800, 0x84c, 0x802, 0x804, 0x805, 0x838),\n\t[RZ_MTU3_CHAN_7] = MTU_8BIT_CH_3_4_6_7(0x809, 0x894, 0x82d, 0x801, 0x84d, 0x803, 0x806, 0x807, 0x839),\n\t[RZ_MTU3_CHAN_8] = MTU_8BIT_CH_8(0x404, 0x098, 0x400, 0x406, 0x401, 0x402, 0x403)\n};\n\nstatic const unsigned long rz_mtu3_16bit_ch_reg_offs[][12] = {\n\t[RZ_MTU3_CHAN_0] = MTU_16BIT_CH_0(0x106, 0x108, 0x10a, 0x10c, 0x10e, 0x120, 0x122),\n\t[RZ_MTU3_CHAN_1] = MTU_16BIT_CH_1_2(0x186, 0x188, 0x18a),\n\t[RZ_MTU3_CHAN_2] = MTU_16BIT_CH_1_2(0x206, 0x208, 0x20a),\n\t[RZ_MTU3_CHAN_3] = MTU_16BIT_CH_3_6(0x010, 0x018, 0x01a, 0x024, 0x026, 0x072),\n\t[RZ_MTU3_CHAN_4] = MTU_16BIT_CH_4_7(0x012, 0x01c, 0x01e, 0x028, 0x2a, 0x074, 0x076, 0x040, 0x044, 0x046, 0x048, 0x04a),\n\t[RZ_MTU3_CHAN_5] = MTU_16BIT_CH_5(0xa80, 0xa82, 0xa90, 0xa92, 0xaa0, 0xaa2),\n\t[RZ_MTU3_CHAN_6] = MTU_16BIT_CH_3_6(0x810, 0x818, 0x81a, 0x824, 0x826, 0x872),\n\t[RZ_MTU3_CHAN_7] = MTU_16BIT_CH_4_7(0x812, 0x81c, 0x81e, 0x828, 0x82a, 0x874, 0x876, 0x840, 0x844, 0x846, 0x848, 0x84a)\n};\n\nstatic const unsigned long rz_mtu3_32bit_ch_reg_offs[][5] = {\n\t[RZ_MTU3_CHAN_1] = MTU_32BIT_CH_1(0x1a0, 0x1a4, 0x1a8),\n\t[RZ_MTU3_CHAN_8] = MTU_32BIT_CH_8(0x408, 0x40c, 0x410, 0x414, 0x418)\n};\n\nstatic bool rz_mtu3_is_16bit_shared_reg(u16 offset)\n{\n\treturn (offset == RZ_MTU3_TDDRA || offset == RZ_MTU3_TDDRB ||\n\t\toffset == RZ_MTU3_TCDRA || offset == RZ_MTU3_TCDRB ||\n\t\toffset == RZ_MTU3_TCBRA || offset == RZ_MTU3_TCBRB ||\n\t\toffset == RZ_MTU3_TCNTSA || offset == RZ_MTU3_TCNTSB);\n}\n\nu16 rz_mtu3_shared_reg_read(struct rz_mtu3_channel *ch, u16 offset)\n{\n\tstruct rz_mtu3 *mtu = dev_get_drvdata(ch->dev->parent);\n\tstruct rz_mtu3_priv *priv = mtu->priv_data;\n\n\tif (rz_mtu3_is_16bit_shared_reg(offset))\n\t\treturn readw(priv->mmio + offset);\n\telse\n\t\treturn readb(priv->mmio + offset);\n}\nEXPORT_SYMBOL_GPL(rz_mtu3_shared_reg_read);\n\nu8 rz_mtu3_8bit_ch_read(struct rz_mtu3_channel *ch, u16 offset)\n{\n\tstruct rz_mtu3 *mtu = dev_get_drvdata(ch->dev->parent);\n\tstruct rz_mtu3_priv *priv = mtu->priv_data;\n\tu16 ch_offs;\n\n\tch_offs = rz_mtu3_8bit_ch_reg_offs[ch->channel_number][offset];\n\n\treturn readb(priv->mmio + ch_offs);\n}\nEXPORT_SYMBOL_GPL(rz_mtu3_8bit_ch_read);\n\nu16 rz_mtu3_16bit_ch_read(struct rz_mtu3_channel *ch, u16 offset)\n{\n\tstruct rz_mtu3 *mtu = dev_get_drvdata(ch->dev->parent);\n\tstruct rz_mtu3_priv *priv = mtu->priv_data;\n\tu16 ch_offs;\n\n\t \n\tif (ch->channel_number == RZ_MTU3_CHAN_8)\n\t\treturn 0;\n\n\tch_offs = rz_mtu3_16bit_ch_reg_offs[ch->channel_number][offset];\n\n\treturn readw(priv->mmio + ch_offs);\n}\nEXPORT_SYMBOL_GPL(rz_mtu3_16bit_ch_read);\n\nu32 rz_mtu3_32bit_ch_read(struct rz_mtu3_channel *ch, u16 offset)\n{\n\tstruct rz_mtu3 *mtu = dev_get_drvdata(ch->dev->parent);\n\tstruct rz_mtu3_priv *priv = mtu->priv_data;\n\tu16 ch_offs;\n\n\tif (ch->channel_number != RZ_MTU3_CHAN_1 && ch->channel_number != RZ_MTU3_CHAN_8)\n\t\treturn 0;\n\n\tch_offs = rz_mtu3_32bit_ch_reg_offs[ch->channel_number][offset];\n\n\treturn readl(priv->mmio + ch_offs);\n}\nEXPORT_SYMBOL_GPL(rz_mtu3_32bit_ch_read);\n\nvoid rz_mtu3_8bit_ch_write(struct rz_mtu3_channel *ch, u16 offset, u8 val)\n{\n\tstruct rz_mtu3 *mtu = dev_get_drvdata(ch->dev->parent);\n\tstruct rz_mtu3_priv *priv = mtu->priv_data;\n\tu16 ch_offs;\n\n\tch_offs = rz_mtu3_8bit_ch_reg_offs[ch->channel_number][offset];\n\twriteb(val, priv->mmio + ch_offs);\n}\nEXPORT_SYMBOL_GPL(rz_mtu3_8bit_ch_write);\n\nvoid rz_mtu3_16bit_ch_write(struct rz_mtu3_channel *ch, u16 offset, u16 val)\n{\n\tstruct rz_mtu3 *mtu = dev_get_drvdata(ch->dev->parent);\n\tstruct rz_mtu3_priv *priv = mtu->priv_data;\n\tu16 ch_offs;\n\n\t \n\tif (ch->channel_number == RZ_MTU3_CHAN_8)\n\t\treturn;\n\n\tch_offs = rz_mtu3_16bit_ch_reg_offs[ch->channel_number][offset];\n\twritew(val, priv->mmio + ch_offs);\n}\nEXPORT_SYMBOL_GPL(rz_mtu3_16bit_ch_write);\n\nvoid rz_mtu3_32bit_ch_write(struct rz_mtu3_channel *ch, u16 offset, u32 val)\n{\n\tstruct rz_mtu3 *mtu = dev_get_drvdata(ch->dev->parent);\n\tstruct rz_mtu3_priv *priv = mtu->priv_data;\n\tu16 ch_offs;\n\n\tif (ch->channel_number != RZ_MTU3_CHAN_1 && ch->channel_number != RZ_MTU3_CHAN_8)\n\t\treturn;\n\n\tch_offs = rz_mtu3_32bit_ch_reg_offs[ch->channel_number][offset];\n\twritel(val, priv->mmio + ch_offs);\n}\nEXPORT_SYMBOL_GPL(rz_mtu3_32bit_ch_write);\n\nvoid rz_mtu3_shared_reg_write(struct rz_mtu3_channel *ch, u16 offset, u16 value)\n{\n\tstruct rz_mtu3 *mtu = dev_get_drvdata(ch->dev->parent);\n\tstruct rz_mtu3_priv *priv = mtu->priv_data;\n\n\tif (rz_mtu3_is_16bit_shared_reg(offset))\n\t\twritew(value, priv->mmio + offset);\n\telse\n\t\twriteb((u8)value, priv->mmio + offset);\n}\nEXPORT_SYMBOL_GPL(rz_mtu3_shared_reg_write);\n\nvoid rz_mtu3_shared_reg_update_bit(struct rz_mtu3_channel *ch, u16 offset,\n\t\t\t\t   u16 pos, u8 val)\n{\n\tstruct rz_mtu3 *mtu = dev_get_drvdata(ch->dev->parent);\n\tstruct rz_mtu3_priv *priv = mtu->priv_data;\n\tunsigned long tmdr, flags;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\ttmdr = rz_mtu3_shared_reg_read(ch, offset);\n\t__assign_bit(pos, &tmdr, !!val);\n\trz_mtu3_shared_reg_write(ch, offset, tmdr);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n}\nEXPORT_SYMBOL_GPL(rz_mtu3_shared_reg_update_bit);\n\nstatic u16 rz_mtu3_get_tstr_offset(struct rz_mtu3_channel *ch)\n{\n\tu16 offset;\n\n\tswitch (ch->channel_number) {\n\tcase RZ_MTU3_CHAN_0:\n\tcase RZ_MTU3_CHAN_1:\n\tcase RZ_MTU3_CHAN_2:\n\tcase RZ_MTU3_CHAN_3:\n\tcase RZ_MTU3_CHAN_4:\n\tcase RZ_MTU3_CHAN_8:\n\t\toffset = RZ_MTU3_TSTRA;\n\t\tbreak;\n\tcase RZ_MTU3_CHAN_5:\n\t\toffset = RZ_MTU3_TSTR;\n\t\tbreak;\n\tcase RZ_MTU3_CHAN_6:\n\tcase RZ_MTU3_CHAN_7:\n\t\toffset = RZ_MTU3_TSTRB;\n\t\tbreak;\n\tdefault:\n\t\toffset = 0;\n\t\tbreak;\n\t}\n\n\treturn offset;\n}\n\nstatic u8 rz_mtu3_get_tstr_bit_pos(struct rz_mtu3_channel *ch)\n{\n\tu8 bitpos;\n\n\tswitch (ch->channel_number) {\n\tcase RZ_MTU3_CHAN_0:\n\tcase RZ_MTU3_CHAN_1:\n\tcase RZ_MTU3_CHAN_2:\n\tcase RZ_MTU3_CHAN_6:\n\tcase RZ_MTU3_CHAN_7:\n\t\tbitpos = ch->channel_number;\n\t\tbreak;\n\tcase RZ_MTU3_CHAN_3:\n\t\tbitpos = 6;\n\t\tbreak;\n\tcase RZ_MTU3_CHAN_4:\n\t\tbitpos = 7;\n\t\tbreak;\n\tcase RZ_MTU3_CHAN_5:\n\t\tbitpos = 2;\n\t\tbreak;\n\tcase RZ_MTU3_CHAN_8:\n\t\tbitpos = 3;\n\t\tbreak;\n\tdefault:\n\t\tbitpos = 0;\n\t\tbreak;\n\t}\n\n\treturn bitpos;\n}\n\nstatic void rz_mtu3_start_stop_ch(struct rz_mtu3_channel *ch, bool start)\n{\n\tstruct rz_mtu3 *mtu = dev_get_drvdata(ch->dev->parent);\n\tstruct rz_mtu3_priv *priv = mtu->priv_data;\n\tunsigned long flags, tstr;\n\tu16 offset;\n\tu8 bitpos;\n\n\toffset = rz_mtu3_get_tstr_offset(ch);\n\tbitpos = rz_mtu3_get_tstr_bit_pos(ch);\n\n\t \n\tspin_lock_irqsave(&priv->lock, flags);\n\n\ttstr = rz_mtu3_shared_reg_read(ch, offset);\n\t__assign_bit(bitpos, &tstr, start);\n\trz_mtu3_shared_reg_write(ch, offset, tstr);\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n}\n\nbool rz_mtu3_is_enabled(struct rz_mtu3_channel *ch)\n{\n\tstruct rz_mtu3 *mtu = dev_get_drvdata(ch->dev->parent);\n\tstruct rz_mtu3_priv *priv = mtu->priv_data;\n\tunsigned long flags, tstr;\n\tu16 offset;\n\tu8 bitpos;\n\n\toffset = rz_mtu3_get_tstr_offset(ch);\n\tbitpos = rz_mtu3_get_tstr_bit_pos(ch);\n\n\t \n\tspin_lock_irqsave(&priv->lock, flags);\n\ttstr = rz_mtu3_shared_reg_read(ch, offset);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn tstr & BIT(bitpos);\n}\nEXPORT_SYMBOL_GPL(rz_mtu3_is_enabled);\n\nint rz_mtu3_enable(struct rz_mtu3_channel *ch)\n{\n\t \n\trz_mtu3_start_stop_ch(ch, true);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rz_mtu3_enable);\n\nvoid rz_mtu3_disable(struct rz_mtu3_channel *ch)\n{\n\t \n\trz_mtu3_start_stop_ch(ch, false);\n}\nEXPORT_SYMBOL_GPL(rz_mtu3_disable);\n\nstatic void rz_mtu3_reset_assert(void *data)\n{\n\tstruct rz_mtu3 *mtu = dev_get_drvdata(data);\n\tstruct rz_mtu3_priv *priv = mtu->priv_data;\n\n\tmfd_remove_devices(data);\n\treset_control_assert(priv->rstc);\n}\n\nstatic const struct mfd_cell rz_mtu3_devs[] = {\n\t{\n\t\t.name = \"rz-mtu3-counter\",\n\t},\n\t{\n\t\t.name = \"pwm-rz-mtu3\",\n\t},\n};\n\nstatic int rz_mtu3_probe(struct platform_device *pdev)\n{\n\tstruct rz_mtu3_priv *priv;\n\tstruct rz_mtu3 *ddata;\n\tunsigned int i;\n\tint ret;\n\n\tddata = devm_kzalloc(&pdev->dev, sizeof(*ddata), GFP_KERNEL);\n\tif (!ddata)\n\t\treturn -ENOMEM;\n\n\tddata->priv_data = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!ddata->priv_data)\n\t\treturn -ENOMEM;\n\n\tpriv = ddata->priv_data;\n\n\tpriv->mmio = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->mmio))\n\t\treturn PTR_ERR(priv->mmio);\n\n\tpriv->rstc = devm_reset_control_get_exclusive(&pdev->dev, NULL);\n\tif (IS_ERR(priv->rstc))\n\t\treturn PTR_ERR(priv->rstc);\n\n\tddata->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(ddata->clk))\n\t\treturn PTR_ERR(ddata->clk);\n\n\treset_control_deassert(priv->rstc);\n\tspin_lock_init(&priv->lock);\n\tplatform_set_drvdata(pdev, ddata);\n\n\tfor (i = 0; i < RZ_MTU_NUM_CHANNELS; i++) {\n\t\tddata->channels[i].channel_number = i;\n\t\tddata->channels[i].is_busy = false;\n\t\tmutex_init(&ddata->channels[i].lock);\n\t}\n\n\tret = mfd_add_devices(&pdev->dev, 0, rz_mtu3_devs,\n\t\t\t      ARRAY_SIZE(rz_mtu3_devs), NULL, 0, NULL);\n\tif (ret < 0)\n\t\tgoto err_assert;\n\n\treturn devm_add_action_or_reset(&pdev->dev, rz_mtu3_reset_assert,\n\t\t\t\t\t&pdev->dev);\n\nerr_assert:\n\treset_control_assert(priv->rstc);\n\treturn ret;\n}\n\nstatic const struct of_device_id rz_mtu3_of_match[] = {\n\t{ .compatible = \"renesas,rz-mtu3\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, rz_mtu3_of_match);\n\nstatic struct platform_driver rz_mtu3_driver = {\n\t.probe = rz_mtu3_probe,\n\t.driver\t= {\n\t\t.name = \"rz-mtu3\",\n\t\t.of_match_table = rz_mtu3_of_match,\n\t},\n};\nmodule_platform_driver(rz_mtu3_driver);\n\nMODULE_AUTHOR(\"Biju Das <biju.das.jz@bp.renesas.com>\");\nMODULE_DESCRIPTION(\"Renesas RZ/G2L MTU3a Core Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}