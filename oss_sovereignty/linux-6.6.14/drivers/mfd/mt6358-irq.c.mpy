{
  "module_name": "mt6358-irq.c",
  "hash_id": "e56657a9e17e5276acf52429317f8e1cbfc77b2d0120d42afeb367954ba93311",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/mt6358-irq.c",
  "human_readable_source": "\n\n\n\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/mfd/mt6357/core.h>\n#include <linux/mfd/mt6357/registers.h>\n#include <linux/mfd/mt6358/core.h>\n#include <linux/mfd/mt6358/registers.h>\n#include <linux/mfd/mt6359/core.h>\n#include <linux/mfd/mt6359/registers.h>\n#include <linux/mfd/mt6397/core.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n#define MTK_PMIC_REG_WIDTH 16\n\nstatic const struct irq_top_t mt6357_ints[] = {\n\tMT6357_TOP_GEN(BUCK),\n\tMT6357_TOP_GEN(LDO),\n\tMT6357_TOP_GEN(PSC),\n\tMT6357_TOP_GEN(SCK),\n\tMT6357_TOP_GEN(BM),\n\tMT6357_TOP_GEN(HK),\n\tMT6357_TOP_GEN(AUD),\n\tMT6357_TOP_GEN(MISC),\n};\n\nstatic const struct irq_top_t mt6358_ints[] = {\n\tMT6358_TOP_GEN(BUCK),\n\tMT6358_TOP_GEN(LDO),\n\tMT6358_TOP_GEN(PSC),\n\tMT6358_TOP_GEN(SCK),\n\tMT6358_TOP_GEN(BM),\n\tMT6358_TOP_GEN(HK),\n\tMT6358_TOP_GEN(AUD),\n\tMT6358_TOP_GEN(MISC),\n};\n\nstatic const struct irq_top_t mt6359_ints[] = {\n\tMT6359_TOP_GEN(BUCK),\n\tMT6359_TOP_GEN(LDO),\n\tMT6359_TOP_GEN(PSC),\n\tMT6359_TOP_GEN(SCK),\n\tMT6359_TOP_GEN(BM),\n\tMT6359_TOP_GEN(HK),\n\tMT6359_TOP_GEN(AUD),\n\tMT6359_TOP_GEN(MISC),\n};\n\nstatic struct pmic_irq_data mt6357_irqd = {\n\t.num_top = ARRAY_SIZE(mt6357_ints),\n\t.num_pmic_irqs = MT6357_IRQ_NR,\n\t.top_int_status_reg = MT6357_TOP_INT_STATUS0,\n\t.pmic_ints = mt6357_ints,\n};\n\nstatic struct pmic_irq_data mt6358_irqd = {\n\t.num_top = ARRAY_SIZE(mt6358_ints),\n\t.num_pmic_irqs = MT6358_IRQ_NR,\n\t.top_int_status_reg = MT6358_TOP_INT_STATUS0,\n\t.pmic_ints = mt6358_ints,\n};\n\nstatic struct pmic_irq_data mt6359_irqd = {\n\t.num_top = ARRAY_SIZE(mt6359_ints),\n\t.num_pmic_irqs = MT6359_IRQ_NR,\n\t.top_int_status_reg = MT6359_TOP_INT_STATUS0,\n\t.pmic_ints = mt6359_ints,\n};\n\nstatic void pmic_irq_enable(struct irq_data *data)\n{\n\tunsigned int hwirq = irqd_to_hwirq(data);\n\tstruct mt6397_chip *chip = irq_data_get_irq_chip_data(data);\n\tstruct pmic_irq_data *irqd = chip->irq_data;\n\n\tirqd->enable_hwirq[hwirq] = true;\n}\n\nstatic void pmic_irq_disable(struct irq_data *data)\n{\n\tunsigned int hwirq = irqd_to_hwirq(data);\n\tstruct mt6397_chip *chip = irq_data_get_irq_chip_data(data);\n\tstruct pmic_irq_data *irqd = chip->irq_data;\n\n\tirqd->enable_hwirq[hwirq] = false;\n}\n\nstatic void pmic_irq_lock(struct irq_data *data)\n{\n\tstruct mt6397_chip *chip = irq_data_get_irq_chip_data(data);\n\n\tmutex_lock(&chip->irqlock);\n}\n\nstatic void pmic_irq_sync_unlock(struct irq_data *data)\n{\n\tunsigned int i, top_gp, gp_offset, en_reg, int_regs, shift;\n\tstruct mt6397_chip *chip = irq_data_get_irq_chip_data(data);\n\tstruct pmic_irq_data *irqd = chip->irq_data;\n\n\tfor (i = 0; i < irqd->num_pmic_irqs; i++) {\n\t\tif (irqd->enable_hwirq[i] == irqd->cache_hwirq[i])\n\t\t\tcontinue;\n\n\t\t \n\t\ttop_gp = 0;\n\t\twhile ((top_gp + 1) < irqd->num_top &&\n\t\t       i >= irqd->pmic_ints[top_gp + 1].hwirq_base)\n\t\t\ttop_gp++;\n\n\t\t \n\t\tgp_offset = i - irqd->pmic_ints[top_gp].hwirq_base;\n\t\tint_regs = gp_offset / MTK_PMIC_REG_WIDTH;\n\t\tshift = gp_offset % MTK_PMIC_REG_WIDTH;\n\t\ten_reg = irqd->pmic_ints[top_gp].en_reg +\n\t\t\t (irqd->pmic_ints[top_gp].en_reg_shift * int_regs);\n\n\t\tregmap_update_bits(chip->regmap, en_reg, BIT(shift),\n\t\t\t\t   irqd->enable_hwirq[i] << shift);\n\n\t\tirqd->cache_hwirq[i] = irqd->enable_hwirq[i];\n\t}\n\tmutex_unlock(&chip->irqlock);\n}\n\nstatic struct irq_chip mt6358_irq_chip = {\n\t.name = \"mt6358-irq\",\n\t.flags = IRQCHIP_SKIP_SET_WAKE,\n\t.irq_enable = pmic_irq_enable,\n\t.irq_disable = pmic_irq_disable,\n\t.irq_bus_lock = pmic_irq_lock,\n\t.irq_bus_sync_unlock = pmic_irq_sync_unlock,\n};\n\nstatic void mt6358_irq_sp_handler(struct mt6397_chip *chip,\n\t\t\t\t  unsigned int top_gp)\n{\n\tunsigned int irq_status, sta_reg, status;\n\tunsigned int hwirq, virq;\n\tint i, j, ret;\n\tstruct pmic_irq_data *irqd = chip->irq_data;\n\n\tfor (i = 0; i < irqd->pmic_ints[top_gp].num_int_regs; i++) {\n\t\tsta_reg = irqd->pmic_ints[top_gp].sta_reg +\n\t\t\tirqd->pmic_ints[top_gp].sta_reg_shift * i;\n\n\t\tret = regmap_read(chip->regmap, sta_reg, &irq_status);\n\t\tif (ret) {\n\t\t\tdev_err(chip->dev,\n\t\t\t\t\"Failed to read IRQ status, ret=%d\\n\", ret);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!irq_status)\n\t\t\tcontinue;\n\n\t\tstatus = irq_status;\n\t\tdo {\n\t\t\tj = __ffs(status);\n\n\t\t\thwirq = irqd->pmic_ints[top_gp].hwirq_base +\n\t\t\t\tMTK_PMIC_REG_WIDTH * i + j;\n\n\t\t\tvirq = irq_find_mapping(chip->irq_domain, hwirq);\n\t\t\tif (virq)\n\t\t\t\thandle_nested_irq(virq);\n\n\t\t\tstatus &= ~BIT(j);\n\t\t} while (status);\n\n\t\tregmap_write(chip->regmap, sta_reg, irq_status);\n\t}\n}\n\nstatic irqreturn_t mt6358_irq_handler(int irq, void *data)\n{\n\tstruct mt6397_chip *chip = data;\n\tstruct pmic_irq_data *irqd = chip->irq_data;\n\tunsigned int bit, i, top_irq_status = 0;\n\tint ret;\n\n\tret = regmap_read(chip->regmap,\n\t\t\t  irqd->top_int_status_reg,\n\t\t\t  &top_irq_status);\n\tif (ret) {\n\t\tdev_err(chip->dev,\n\t\t\t\"Failed to read status from the device, ret=%d\\n\", ret);\n\t\treturn IRQ_NONE;\n\t}\n\n\tfor (i = 0; i < irqd->num_top; i++) {\n\t\tbit = BIT(irqd->pmic_ints[i].top_offset);\n\t\tif (top_irq_status & bit) {\n\t\t\tmt6358_irq_sp_handler(chip, i);\n\t\t\ttop_irq_status &= ~bit;\n\t\t\tif (!top_irq_status)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int pmic_irq_domain_map(struct irq_domain *d, unsigned int irq,\n\t\t\t       irq_hw_number_t hw)\n{\n\tstruct mt6397_chip *mt6397 = d->host_data;\n\n\tirq_set_chip_data(irq, mt6397);\n\tirq_set_chip_and_handler(irq, &mt6358_irq_chip, handle_level_irq);\n\tirq_set_nested_thread(irq, 1);\n\tirq_set_noprobe(irq);\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops mt6358_irq_domain_ops = {\n\t.map = pmic_irq_domain_map,\n\t.xlate = irq_domain_xlate_twocell,\n};\n\nint mt6358_irq_init(struct mt6397_chip *chip)\n{\n\tint i, j, ret;\n\tstruct pmic_irq_data *irqd;\n\n\tswitch (chip->chip_id) {\n\tcase MT6357_CHIP_ID:\n\t\tchip->irq_data = &mt6357_irqd;\n\t\tbreak;\n\n\tcase MT6358_CHIP_ID:\n\tcase MT6366_CHIP_ID:\n\t\tchip->irq_data = &mt6358_irqd;\n\t\tbreak;\n\n\tcase MT6359_CHIP_ID:\n\t\tchip->irq_data = &mt6359_irqd;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(chip->dev, \"unsupported chip: 0x%x\\n\", chip->chip_id);\n\t\treturn -ENODEV;\n\t}\n\n\tmutex_init(&chip->irqlock);\n\tirqd = chip->irq_data;\n\tirqd->enable_hwirq = devm_kcalloc(chip->dev,\n\t\t\t\t\t  irqd->num_pmic_irqs,\n\t\t\t\t\t  sizeof(*irqd->enable_hwirq),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!irqd->enable_hwirq)\n\t\treturn -ENOMEM;\n\n\tirqd->cache_hwirq = devm_kcalloc(chip->dev,\n\t\t\t\t\t irqd->num_pmic_irqs,\n\t\t\t\t\t sizeof(*irqd->cache_hwirq),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!irqd->cache_hwirq)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = 0; i < irqd->num_top; i++) {\n\t\tfor (j = 0; j < irqd->pmic_ints[i].num_int_regs; j++)\n\t\t\tregmap_write(chip->regmap,\n\t\t\t\t     irqd->pmic_ints[i].en_reg +\n\t\t\t\t     irqd->pmic_ints[i].en_reg_shift * j, 0);\n\t}\n\n\tchip->irq_domain = irq_domain_add_linear(chip->dev->of_node,\n\t\t\t\t\t\t irqd->num_pmic_irqs,\n\t\t\t\t\t\t &mt6358_irq_domain_ops, chip);\n\tif (!chip->irq_domain) {\n\t\tdev_err(chip->dev, \"Could not create IRQ domain\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = devm_request_threaded_irq(chip->dev, chip->irq, NULL,\n\t\t\t\t\tmt6358_irq_handler, IRQF_ONESHOT,\n\t\t\t\t\tmt6358_irq_chip.name, chip);\n\tif (ret) {\n\t\tdev_err(chip->dev, \"Failed to register IRQ=%d, ret=%d\\n\",\n\t\t\tchip->irq, ret);\n\t\treturn ret;\n\t}\n\n\tenable_irq_wake(chip->irq);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}