{
  "module_name": "bcm2835-pm.c",
  "hash_id": "1824e2d30e0c9298d5bf8c512f37f9df02f679341e35468bbfc45ba9978cf3aa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/bcm2835-pm.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/mfd/bcm2835-pm.h>\n#include <linux/mfd/core.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/types.h>\n#include <linux/watchdog.h>\n\nstatic const struct mfd_cell bcm2835_pm_devs[] = {\n\t{ .name = \"bcm2835-wdt\" },\n};\n\nstatic const struct mfd_cell bcm2835_power_devs[] = {\n\t{ .name = \"bcm2835-power\" },\n};\n\nstatic int bcm2835_pm_get_pdata(struct platform_device *pdev,\n\t\t\t\tstruct bcm2835_pm *pm)\n{\n\tif (of_property_present(pm->dev->of_node, \"reg-names\")) {\n\t\tstruct resource *res;\n\n\t\tpm->base = devm_platform_ioremap_resource_byname(pdev, \"pm\");\n\t\tif (IS_ERR(pm->base))\n\t\t\treturn PTR_ERR(pm->base);\n\n\t\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"asb\");\n\t\tif (res) {\n\t\t\tpm->asb = devm_ioremap_resource(&pdev->dev, res);\n\t\t\tif (IS_ERR(pm->asb))\n\t\t\t\tpm->asb = NULL;\n\t\t}\n\n\t\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\n\t\t\t\t\t\t    \"rpivid_asb\");\n\t\tif (res) {\n\t\t\tpm->rpivid_asb = devm_ioremap_resource(&pdev->dev, res);\n\t\t\tif (IS_ERR(pm->rpivid_asb))\n\t\t\t\tpm->rpivid_asb = NULL;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t \n\tpm->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(pm->base))\n\t\treturn PTR_ERR(pm->base);\n\n\tpm->asb = devm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(pm->asb))\n\t\tpm->asb = NULL;\n\n\tpm->rpivid_asb = devm_platform_ioremap_resource(pdev, 2);\n\tif (IS_ERR(pm->rpivid_asb))\n\t\tpm->rpivid_asb = NULL;\n\n\treturn 0;\n}\n\nstatic int bcm2835_pm_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct bcm2835_pm *pm;\n\tint ret;\n\n\tpm = devm_kzalloc(dev, sizeof(*pm), GFP_KERNEL);\n\tif (!pm)\n\t\treturn -ENOMEM;\n\tplatform_set_drvdata(pdev, pm);\n\n\tpm->dev = dev;\n\n\tret = bcm2835_pm_get_pdata(pdev, pm);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_mfd_add_devices(dev, -1,\n\t\t\t\t   bcm2835_pm_devs, ARRAY_SIZE(bcm2835_pm_devs),\n\t\t\t\t   NULL, 0, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (pm->asb)\n\t\treturn devm_mfd_add_devices(dev, -1, bcm2835_power_devs,\n\t\t\t\t\t    ARRAY_SIZE(bcm2835_power_devs),\n\t\t\t\t\t    NULL, 0, NULL);\n\treturn 0;\n}\n\nstatic const struct of_device_id bcm2835_pm_of_match[] = {\n\t{ .compatible = \"brcm,bcm2835-pm-wdt\", },\n\t{ .compatible = \"brcm,bcm2835-pm\", },\n\t{ .compatible = \"brcm,bcm2711-pm\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, bcm2835_pm_of_match);\n\nstatic struct platform_driver bcm2835_pm_driver = {\n\t.probe\t\t= bcm2835_pm_probe,\n\t.driver = {\n\t\t.name =\t\"bcm2835-pm\",\n\t\t.of_match_table = bcm2835_pm_of_match,\n\t},\n};\nmodule_platform_driver(bcm2835_pm_driver);\n\nMODULE_AUTHOR(\"Eric Anholt <eric@anholt.net>\");\nMODULE_DESCRIPTION(\"Driver for Broadcom BCM2835 PM MFD\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}