{
  "module_name": "si476x-cmd.c",
  "hash_id": "3035a94cc4b9d57aa0e243e9ed7c80005abee0a4f31b94af940e4f9200e647f6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/si476x-cmd.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/atomic.h>\n#include <linux/i2c.h>\n#include <linux/device.h>\n#include <linux/gpio.h>\n#include <linux/videodev2.h>\n\n#include <linux/mfd/si476x-core.h>\n\n#include <asm/unaligned.h>\n\n#define msb(x)                  ((u8)((u16) x >> 8))\n#define lsb(x)                  ((u8)((u16) x &  0x00FF))\n\n\n\n#define CMD_POWER_UP\t\t\t\t0x01\n#define CMD_POWER_UP_A10_NRESP\t\t\t1\n#define CMD_POWER_UP_A10_NARGS\t\t\t5\n\n#define CMD_POWER_UP_A20_NRESP\t\t\t1\n#define CMD_POWER_UP_A20_NARGS\t\t\t5\n\n#define POWER_UP_DELAY_MS\t\t\t110\n\n#define CMD_POWER_DOWN\t\t\t\t0x11\n#define CMD_POWER_DOWN_A10_NRESP\t\t1\n\n#define CMD_POWER_DOWN_A20_NRESP\t\t1\n#define CMD_POWER_DOWN_A20_NARGS\t\t1\n\n#define CMD_FUNC_INFO\t\t\t\t0x12\n#define CMD_FUNC_INFO_NRESP\t\t\t7\n\n#define CMD_SET_PROPERTY\t\t\t0x13\n#define CMD_SET_PROPERTY_NARGS\t\t\t5\n#define CMD_SET_PROPERTY_NRESP\t\t\t1\n\n#define CMD_GET_PROPERTY\t\t\t0x14\n#define CMD_GET_PROPERTY_NARGS\t\t\t3\n#define CMD_GET_PROPERTY_NRESP\t\t\t4\n\n#define CMD_AGC_STATUS\t\t\t\t0x17\n#define CMD_AGC_STATUS_NRESP_A10\t\t2\n#define CMD_AGC_STATUS_NRESP_A20                6\n\n#define PIN_CFG_BYTE(x) (0x7F & (x))\n#define CMD_DIG_AUDIO_PIN_CFG\t\t\t0x18\n#define CMD_DIG_AUDIO_PIN_CFG_NARGS\t\t4\n#define CMD_DIG_AUDIO_PIN_CFG_NRESP\t\t5\n\n#define CMD_ZIF_PIN_CFG\t\t\t\t0x19\n#define CMD_ZIF_PIN_CFG_NARGS\t\t\t4\n#define CMD_ZIF_PIN_CFG_NRESP\t\t\t5\n\n#define CMD_IC_LINK_GPO_CTL_PIN_CFG\t\t0x1A\n#define CMD_IC_LINK_GPO_CTL_PIN_CFG_NARGS\t4\n#define CMD_IC_LINK_GPO_CTL_PIN_CFG_NRESP\t5\n\n#define CMD_ANA_AUDIO_PIN_CFG\t\t\t0x1B\n#define CMD_ANA_AUDIO_PIN_CFG_NARGS\t\t1\n#define CMD_ANA_AUDIO_PIN_CFG_NRESP\t\t2\n\n#define CMD_INTB_PIN_CFG\t\t\t0x1C\n#define CMD_INTB_PIN_CFG_NARGS\t\t\t2\n#define CMD_INTB_PIN_CFG_A10_NRESP\t\t6\n#define CMD_INTB_PIN_CFG_A20_NRESP\t\t3\n\n#define CMD_FM_TUNE_FREQ\t\t\t0x30\n#define CMD_FM_TUNE_FREQ_A10_NARGS\t\t5\n#define CMD_FM_TUNE_FREQ_A20_NARGS\t\t3\n#define CMD_FM_TUNE_FREQ_NRESP\t\t\t1\n\n#define CMD_FM_RSQ_STATUS\t\t\t0x32\n\n#define CMD_FM_RSQ_STATUS_A10_NARGS\t\t1\n#define CMD_FM_RSQ_STATUS_A10_NRESP\t\t17\n#define CMD_FM_RSQ_STATUS_A30_NARGS\t\t1\n#define CMD_FM_RSQ_STATUS_A30_NRESP\t\t23\n\n\n#define CMD_FM_SEEK_START\t\t\t0x31\n#define CMD_FM_SEEK_START_NARGS\t\t\t1\n#define CMD_FM_SEEK_START_NRESP\t\t\t1\n\n#define CMD_FM_RDS_STATUS\t\t\t0x36\n#define CMD_FM_RDS_STATUS_NARGS\t\t\t1\n#define CMD_FM_RDS_STATUS_NRESP\t\t\t16\n\n#define CMD_FM_RDS_BLOCKCOUNT\t\t\t0x37\n#define CMD_FM_RDS_BLOCKCOUNT_NARGS\t\t1\n#define CMD_FM_RDS_BLOCKCOUNT_NRESP\t\t8\n\n#define CMD_FM_PHASE_DIVERSITY\t\t\t0x38\n#define CMD_FM_PHASE_DIVERSITY_NARGS\t\t1\n#define CMD_FM_PHASE_DIVERSITY_NRESP\t\t1\n\n#define CMD_FM_PHASE_DIV_STATUS\t\t\t0x39\n#define CMD_FM_PHASE_DIV_STATUS_NRESP\t\t2\n\n#define CMD_AM_TUNE_FREQ\t\t\t0x40\n#define CMD_AM_TUNE_FREQ_NARGS\t\t\t3\n#define CMD_AM_TUNE_FREQ_NRESP\t\t\t1\n\n#define CMD_AM_RSQ_STATUS\t\t\t0x42\n#define CMD_AM_RSQ_STATUS_NARGS\t\t\t1\n#define CMD_AM_RSQ_STATUS_NRESP\t\t\t13\n\n#define CMD_AM_SEEK_START\t\t\t0x41\n#define CMD_AM_SEEK_START_NARGS\t\t\t1\n#define CMD_AM_SEEK_START_NRESP\t\t\t1\n\n\n#define CMD_AM_ACF_STATUS\t\t\t0x45\n#define CMD_AM_ACF_STATUS_NRESP\t\t\t6\n#define CMD_AM_ACF_STATUS_NARGS\t\t\t1\n\n#define CMD_FM_ACF_STATUS\t\t\t0x35\n#define CMD_FM_ACF_STATUS_NRESP\t\t\t8\n#define CMD_FM_ACF_STATUS_NARGS\t\t\t1\n\n#define CMD_MAX_ARGS_COUNT\t\t\t(10)\n\n\nenum si476x_acf_status_report_bits {\n\tSI476X_ACF_BLEND_INT\t= (1 << 4),\n\tSI476X_ACF_HIBLEND_INT\t= (1 << 3),\n\tSI476X_ACF_HICUT_INT\t= (1 << 2),\n\tSI476X_ACF_CHBW_INT\t= (1 << 1),\n\tSI476X_ACF_SOFTMUTE_INT\t= (1 << 0),\n\n\tSI476X_ACF_SMUTE\t= (1 << 0),\n\tSI476X_ACF_SMATTN\t= 0x1f,\n\tSI476X_ACF_PILOT\t= (1 << 7),\n\tSI476X_ACF_STBLEND\t= ~SI476X_ACF_PILOT,\n};\n\nenum si476x_agc_status_report_bits {\n\tSI476X_AGC_MXHI\t\t= (1 << 5),\n\tSI476X_AGC_MXLO\t\t= (1 << 4),\n\tSI476X_AGC_LNAHI\t= (1 << 3),\n\tSI476X_AGC_LNALO\t= (1 << 2),\n};\n\nenum si476x_errors {\n\tSI476X_ERR_BAD_COMMAND\t\t= 0x10,\n\tSI476X_ERR_BAD_ARG1\t\t= 0x11,\n\tSI476X_ERR_BAD_ARG2\t\t= 0x12,\n\tSI476X_ERR_BAD_ARG3\t\t= 0x13,\n\tSI476X_ERR_BAD_ARG4\t\t= 0x14,\n\tSI476X_ERR_BUSY\t\t\t= 0x18,\n\tSI476X_ERR_BAD_INTERNAL_MEMORY  = 0x20,\n\tSI476X_ERR_BAD_PATCH\t\t= 0x30,\n\tSI476X_ERR_BAD_BOOT_MODE\t= 0x31,\n\tSI476X_ERR_BAD_PROPERTY\t\t= 0x40,\n};\n\nstatic int si476x_core_parse_and_nag_about_error(struct si476x_core *core)\n{\n\tint err;\n\tchar *cause;\n\tu8 buffer[2];\n\n\tif (core->revision != SI476X_REVISION_A10) {\n\t\terr = si476x_core_i2c_xfer(core, SI476X_I2C_RECV,\n\t\t\t\t\t   buffer, sizeof(buffer));\n\t\tif (err == sizeof(buffer)) {\n\t\t\tswitch (buffer[1]) {\n\t\t\tcase SI476X_ERR_BAD_COMMAND:\n\t\t\t\tcause = \"Bad command\";\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\tcase SI476X_ERR_BAD_ARG1:\n\t\t\t\tcause = \"Bad argument #1\";\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\tcase SI476X_ERR_BAD_ARG2:\n\t\t\t\tcause = \"Bad argument #2\";\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\tcase SI476X_ERR_BAD_ARG3:\n\t\t\t\tcause = \"Bad argument #3\";\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\tcase SI476X_ERR_BAD_ARG4:\n\t\t\t\tcause = \"Bad argument #4\";\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\tcase SI476X_ERR_BUSY:\n\t\t\t\tcause = \"Chip is busy\";\n\t\t\t\terr = -EBUSY;\n\t\t\t\tbreak;\n\t\t\tcase SI476X_ERR_BAD_INTERNAL_MEMORY:\n\t\t\t\tcause = \"Bad internal memory\";\n\t\t\t\terr = -EIO;\n\t\t\t\tbreak;\n\t\t\tcase SI476X_ERR_BAD_PATCH:\n\t\t\t\tcause = \"Bad patch\";\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\tcase SI476X_ERR_BAD_BOOT_MODE:\n\t\t\t\tcause = \"Bad boot mode\";\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\tcase SI476X_ERR_BAD_PROPERTY:\n\t\t\t\tcause = \"Bad property\";\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcause = \"Unknown\";\n\t\t\t\terr = -EIO;\n\t\t\t}\n\n\t\t\tdev_err(&core->client->dev,\n\t\t\t\t\"[Chip error status]: %s\\n\", cause);\n\t\t} else {\n\t\t\tdev_err(&core->client->dev,\n\t\t\t\t\"Failed to fetch error code\\n\");\n\t\t\terr = (err >= 0) ? -EIO : err;\n\t\t}\n\t} else {\n\t\terr = -EIO;\n\t}\n\n\treturn err;\n}\n\n \nstatic int si476x_core_send_command(struct si476x_core *core,\n\t\t\t\t    const u8 command,\n\t\t\t\t    const u8 args[],\n\t\t\t\t    const int argn,\n\t\t\t\t    u8 resp[],\n\t\t\t\t    const int respn,\n\t\t\t\t    const int usecs)\n{\n\tstruct i2c_client *client = core->client;\n\tint err;\n\tu8  data[CMD_MAX_ARGS_COUNT + 1];\n\n\tif (argn > CMD_MAX_ARGS_COUNT) {\n\t\terr = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\tif (!client->adapter) {\n\t\terr = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\t \n\tdata[0] = command;\n\tmemcpy(&data[1], args, argn);\n\tdev_dbg(&client->dev, \"Command:\\n %*ph\\n\", argn + 1, data);\n\n\terr = si476x_core_i2c_xfer(core, SI476X_I2C_SEND,\n\t\t\t\t   (char *) data, argn + 1);\n\tif (err != argn + 1) {\n\t\tdev_err(&core->client->dev,\n\t\t\t\"Error while sending command 0x%02x\\n\",\n\t\t\tcommand);\n\t\terr = (err >= 0) ? -EIO : err;\n\t\tgoto exit;\n\t}\n\t \n\tatomic_set(&core->cts, 0);\n\n\t \n\tif (!wait_event_timeout(core->command,\n\t\t\t\tatomic_read(&core->cts),\n\t\t\t\tusecs_to_jiffies(usecs) + 1))\n\t\tdev_warn(&core->client->dev,\n\t\t\t \"(%s) [CMD 0x%02x] Answer timeout.\\n\",\n\t\t\t __func__, command);\n\n\t \n\tif (unlikely(!core->client->irq && command == CMD_POWER_UP)) {\n\t\tif (!wait_event_timeout(core->command,\n\t\t\t\t\tatomic_read(&core->cts),\n\t\t\t\t\tusecs_to_jiffies(usecs) + 1))\n\t\t\tdev_warn(&core->client->dev,\n\t\t\t\t \"(%s) Power up took too much time.\\n\",\n\t\t\t\t __func__);\n\t}\n\n\t \n\terr = si476x_core_i2c_xfer(core, SI476X_I2C_RECV, resp, respn);\n\tif (err != respn) {\n\t\tdev_err(&core->client->dev,\n\t\t\t\"Error while reading response for command 0x%02x\\n\",\n\t\t\tcommand);\n\t\terr = (err >= 0) ? -EIO : err;\n\t\tgoto exit;\n\t}\n\tdev_dbg(&client->dev, \"Response:\\n %*ph\\n\", respn, resp);\n\n\terr = 0;\n\n\tif (resp[0] & SI476X_ERR) {\n\t\tdev_err(&core->client->dev,\n\t\t\t\"[CMD 0x%02x] Chip set error flag\\n\", command);\n\t\terr = si476x_core_parse_and_nag_about_error(core);\n\t\tgoto exit;\n\t}\n\n\tif (!(resp[0] & SI476X_CTS))\n\t\terr = -EBUSY;\nexit:\n\treturn err;\n}\n\nstatic int si476x_cmd_clear_stc(struct si476x_core *core)\n{\n\tint err;\n\tstruct si476x_rsq_status_args args = {\n\t\t.primary\t= false,\n\t\t.rsqack\t\t= false,\n\t\t.attune\t\t= false,\n\t\t.cancel\t\t= false,\n\t\t.stcack\t\t= true,\n\t};\n\n\tswitch (core->power_up_parameters.func) {\n\tcase SI476X_FUNC_FM_RECEIVER:\n\t\terr = si476x_core_cmd_fm_rsq_status(core, &args, NULL);\n\t\tbreak;\n\tcase SI476X_FUNC_AM_RECEIVER:\n\t\terr = si476x_core_cmd_am_rsq_status(core, &args, NULL);\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t}\n\n\treturn err;\n}\n\nstatic int si476x_cmd_tune_seek_freq(struct si476x_core *core,\n\t\t\t\t     uint8_t cmd,\n\t\t\t\t     const uint8_t args[], size_t argn,\n\t\t\t\t     uint8_t *resp, size_t respn)\n{\n\tint err;\n\n\n\tatomic_set(&core->stc, 0);\n\terr = si476x_core_send_command(core, cmd, args, argn, resp, respn,\n\t\t\t\t       SI476X_TIMEOUT_TUNE);\n\tif (!err) {\n\t\twait_event_killable(core->tuning,\n\t\t\t\t    atomic_read(&core->stc));\n\t\tsi476x_cmd_clear_stc(core);\n\t}\n\n\treturn err;\n}\n\n \nint si476x_core_cmd_func_info(struct si476x_core *core,\n\t\t\t      struct si476x_func_info *info)\n{\n\tint err;\n\tu8  resp[CMD_FUNC_INFO_NRESP];\n\n\terr = si476x_core_send_command(core, CMD_FUNC_INFO,\n\t\t\t\t       NULL, 0,\n\t\t\t\t       resp, ARRAY_SIZE(resp),\n\t\t\t\t       SI476X_DEFAULT_TIMEOUT);\n\n\tinfo->firmware.major    = resp[1];\n\tinfo->firmware.minor[0] = resp[2];\n\tinfo->firmware.minor[1] = resp[3];\n\n\tinfo->patch_id = ((u16) resp[4] << 8) | resp[5];\n\tinfo->func     = resp[6];\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(si476x_core_cmd_func_info);\n\n \nint si476x_core_cmd_set_property(struct si476x_core *core,\n\t\t\t\t u16 property, u16 value)\n{\n\tu8       resp[CMD_SET_PROPERTY_NRESP];\n\tconst u8 args[CMD_SET_PROPERTY_NARGS] = {\n\t\t0x00,\n\t\tmsb(property),\n\t\tlsb(property),\n\t\tmsb(value),\n\t\tlsb(value),\n\t};\n\n\treturn si476x_core_send_command(core, CMD_SET_PROPERTY,\n\t\t\t\t\targs, ARRAY_SIZE(args),\n\t\t\t\t\tresp, ARRAY_SIZE(resp),\n\t\t\t\t\tSI476X_DEFAULT_TIMEOUT);\n}\nEXPORT_SYMBOL_GPL(si476x_core_cmd_set_property);\n\n \nint si476x_core_cmd_get_property(struct si476x_core *core, u16 property)\n{\n\tint err;\n\tu8       resp[CMD_GET_PROPERTY_NRESP];\n\tconst u8 args[CMD_GET_PROPERTY_NARGS] = {\n\t\t0x00,\n\t\tmsb(property),\n\t\tlsb(property),\n\t};\n\n\terr = si476x_core_send_command(core, CMD_GET_PROPERTY,\n\t\t\t\t       args, ARRAY_SIZE(args),\n\t\t\t\t       resp, ARRAY_SIZE(resp),\n\t\t\t\t       SI476X_DEFAULT_TIMEOUT);\n\tif (err < 0)\n\t\treturn err;\n\telse\n\t\treturn get_unaligned_be16(resp + 2);\n}\nEXPORT_SYMBOL_GPL(si476x_core_cmd_get_property);\n\n \nint si476x_core_cmd_dig_audio_pin_cfg(struct  si476x_core *core,\n\t\t\t\t      enum si476x_dclk_config dclk,\n\t\t\t\t      enum si476x_dfs_config  dfs,\n\t\t\t\t      enum si476x_dout_config dout,\n\t\t\t\t      enum si476x_xout_config xout)\n{\n\tu8       resp[CMD_DIG_AUDIO_PIN_CFG_NRESP];\n\tconst u8 args[CMD_DIG_AUDIO_PIN_CFG_NARGS] = {\n\t\tPIN_CFG_BYTE(dclk),\n\t\tPIN_CFG_BYTE(dfs),\n\t\tPIN_CFG_BYTE(dout),\n\t\tPIN_CFG_BYTE(xout),\n\t};\n\n\treturn si476x_core_send_command(core, CMD_DIG_AUDIO_PIN_CFG,\n\t\t\t\t\targs, ARRAY_SIZE(args),\n\t\t\t\t\tresp, ARRAY_SIZE(resp),\n\t\t\t\t\tSI476X_DEFAULT_TIMEOUT);\n}\nEXPORT_SYMBOL_GPL(si476x_core_cmd_dig_audio_pin_cfg);\n\n \nint si476x_core_cmd_zif_pin_cfg(struct si476x_core *core,\n\t\t\t\tenum si476x_iqclk_config iqclk,\n\t\t\t\tenum si476x_iqfs_config iqfs,\n\t\t\t\tenum si476x_iout_config iout,\n\t\t\t\tenum si476x_qout_config qout)\n{\n\tu8       resp[CMD_ZIF_PIN_CFG_NRESP];\n\tconst u8 args[CMD_ZIF_PIN_CFG_NARGS] = {\n\t\tPIN_CFG_BYTE(iqclk),\n\t\tPIN_CFG_BYTE(iqfs),\n\t\tPIN_CFG_BYTE(iout),\n\t\tPIN_CFG_BYTE(qout),\n\t};\n\n\treturn si476x_core_send_command(core, CMD_ZIF_PIN_CFG,\n\t\t\t\t\targs, ARRAY_SIZE(args),\n\t\t\t\t\tresp, ARRAY_SIZE(resp),\n\t\t\t\t\tSI476X_DEFAULT_TIMEOUT);\n}\nEXPORT_SYMBOL_GPL(si476x_core_cmd_zif_pin_cfg);\n\n \nint si476x_core_cmd_ic_link_gpo_ctl_pin_cfg(struct si476x_core *core,\n\t\t\t\t\t    enum si476x_icin_config icin,\n\t\t\t\t\t    enum si476x_icip_config icip,\n\t\t\t\t\t    enum si476x_icon_config icon,\n\t\t\t\t\t    enum si476x_icop_config icop)\n{\n\tu8       resp[CMD_IC_LINK_GPO_CTL_PIN_CFG_NRESP];\n\tconst u8 args[CMD_IC_LINK_GPO_CTL_PIN_CFG_NARGS] = {\n\t\tPIN_CFG_BYTE(icin),\n\t\tPIN_CFG_BYTE(icip),\n\t\tPIN_CFG_BYTE(icon),\n\t\tPIN_CFG_BYTE(icop),\n\t};\n\n\treturn si476x_core_send_command(core, CMD_IC_LINK_GPO_CTL_PIN_CFG,\n\t\t\t\t\targs, ARRAY_SIZE(args),\n\t\t\t\t\tresp, ARRAY_SIZE(resp),\n\t\t\t\t\tSI476X_DEFAULT_TIMEOUT);\n}\nEXPORT_SYMBOL_GPL(si476x_core_cmd_ic_link_gpo_ctl_pin_cfg);\n\n \nint si476x_core_cmd_ana_audio_pin_cfg(struct si476x_core *core,\n\t\t\t\t      enum si476x_lrout_config lrout)\n{\n\tu8       resp[CMD_ANA_AUDIO_PIN_CFG_NRESP];\n\tconst u8 args[CMD_ANA_AUDIO_PIN_CFG_NARGS] = {\n\t\tPIN_CFG_BYTE(lrout),\n\t};\n\n\treturn si476x_core_send_command(core, CMD_ANA_AUDIO_PIN_CFG,\n\t\t\t\t\targs, ARRAY_SIZE(args),\n\t\t\t\t\tresp, ARRAY_SIZE(resp),\n\t\t\t\t\tSI476X_DEFAULT_TIMEOUT);\n}\nEXPORT_SYMBOL_GPL(si476x_core_cmd_ana_audio_pin_cfg);\n\n\n \nstatic int si476x_core_cmd_intb_pin_cfg_a10(struct si476x_core *core,\n\t\t\t\t\t    enum si476x_intb_config intb,\n\t\t\t\t\t    enum si476x_a1_config a1)\n{\n\tu8       resp[CMD_INTB_PIN_CFG_A10_NRESP];\n\tconst u8 args[CMD_INTB_PIN_CFG_NARGS] = {\n\t\tPIN_CFG_BYTE(intb),\n\t\tPIN_CFG_BYTE(a1),\n\t};\n\n\treturn si476x_core_send_command(core, CMD_INTB_PIN_CFG,\n\t\t\t\t\targs, ARRAY_SIZE(args),\n\t\t\t\t\tresp, ARRAY_SIZE(resp),\n\t\t\t\t\tSI476X_DEFAULT_TIMEOUT);\n}\n\nstatic int si476x_core_cmd_intb_pin_cfg_a20(struct si476x_core *core,\n\t\t\t\t\t    enum si476x_intb_config intb,\n\t\t\t\t\t    enum si476x_a1_config a1)\n{\n\tu8       resp[CMD_INTB_PIN_CFG_A20_NRESP];\n\tconst u8 args[CMD_INTB_PIN_CFG_NARGS] = {\n\t\tPIN_CFG_BYTE(intb),\n\t\tPIN_CFG_BYTE(a1),\n\t};\n\n\treturn si476x_core_send_command(core, CMD_INTB_PIN_CFG,\n\t\t\t\t\targs, ARRAY_SIZE(args),\n\t\t\t\t\tresp, ARRAY_SIZE(resp),\n\t\t\t\t\tSI476X_DEFAULT_TIMEOUT);\n}\n\n\n\n \nint si476x_core_cmd_am_rsq_status(struct si476x_core *core,\n\t\t\t\t  struct si476x_rsq_status_args *rsqargs,\n\t\t\t\t  struct si476x_rsq_status_report *report)\n{\n\tint err;\n\tu8       resp[CMD_AM_RSQ_STATUS_NRESP];\n\tconst u8 args[CMD_AM_RSQ_STATUS_NARGS] = {\n\t\trsqargs->rsqack << 3 | rsqargs->attune << 2 |\n\t\trsqargs->cancel << 1 | rsqargs->stcack,\n\t};\n\n\terr = si476x_core_send_command(core, CMD_AM_RSQ_STATUS,\n\t\t\t\t       args, ARRAY_SIZE(args),\n\t\t\t\t       resp, ARRAY_SIZE(resp),\n\t\t\t\t       SI476X_DEFAULT_TIMEOUT);\n\t \n\tif (!report)\n\t\treturn err;\n\n\treport->snrhint\t\t= 0x08 & resp[1];\n\treport->snrlint\t\t= 0x04 & resp[1];\n\treport->rssihint\t= 0x02 & resp[1];\n\treport->rssilint\t= 0x01 & resp[1];\n\n\treport->bltf\t\t= 0x80 & resp[2];\n\treport->snr_ready\t= 0x20 & resp[2];\n\treport->rssiready\t= 0x08 & resp[2];\n\treport->afcrl\t\t= 0x02 & resp[2];\n\treport->valid\t\t= 0x01 & resp[2];\n\n\treport->readfreq\t= get_unaligned_be16(resp + 3);\n\treport->freqoff\t\t= resp[5];\n\treport->rssi\t\t= resp[6];\n\treport->snr\t\t= resp[7];\n\treport->lassi\t\t= resp[9];\n\treport->hassi\t\t= resp[10];\n\treport->mult\t\t= resp[11];\n\treport->dev\t\t= resp[12];\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(si476x_core_cmd_am_rsq_status);\n\nint si476x_core_cmd_fm_acf_status(struct si476x_core *core,\n\t\t\t     struct si476x_acf_status_report *report)\n{\n\tint err;\n\tu8       resp[CMD_FM_ACF_STATUS_NRESP];\n\tconst u8 args[CMD_FM_ACF_STATUS_NARGS] = {\n\t\t0x0,\n\t};\n\n\tif (!report)\n\t\treturn -EINVAL;\n\n\terr = si476x_core_send_command(core, CMD_FM_ACF_STATUS,\n\t\t\t\t       args, ARRAY_SIZE(args),\n\t\t\t\t       resp, ARRAY_SIZE(resp),\n\t\t\t\t       SI476X_DEFAULT_TIMEOUT);\n\tif (err < 0)\n\t\treturn err;\n\n\treport->blend_int\t= resp[1] & SI476X_ACF_BLEND_INT;\n\treport->hblend_int\t= resp[1] & SI476X_ACF_HIBLEND_INT;\n\treport->hicut_int\t= resp[1] & SI476X_ACF_HICUT_INT;\n\treport->chbw_int\t= resp[1] & SI476X_ACF_CHBW_INT;\n\treport->softmute_int\t= resp[1] & SI476X_ACF_SOFTMUTE_INT;\n\treport->smute\t\t= resp[2] & SI476X_ACF_SMUTE;\n\treport->smattn\t\t= resp[3] & SI476X_ACF_SMATTN;\n\treport->chbw\t\t= resp[4];\n\treport->hicut\t\t= resp[5];\n\treport->hiblend\t\t= resp[6];\n\treport->pilot\t\t= resp[7] & SI476X_ACF_PILOT;\n\treport->stblend\t\t= resp[7] & SI476X_ACF_STBLEND;\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(si476x_core_cmd_fm_acf_status);\n\nint si476x_core_cmd_am_acf_status(struct si476x_core *core,\n\t\t\t\t  struct si476x_acf_status_report *report)\n{\n\tint err;\n\tu8       resp[CMD_AM_ACF_STATUS_NRESP];\n\tconst u8 args[CMD_AM_ACF_STATUS_NARGS] = {\n\t\t0x0,\n\t};\n\n\tif (!report)\n\t\treturn -EINVAL;\n\n\terr = si476x_core_send_command(core, CMD_AM_ACF_STATUS,\n\t\t\t\t       args, ARRAY_SIZE(args),\n\t\t\t\t       resp, ARRAY_SIZE(resp),\n\t\t\t\t       SI476X_DEFAULT_TIMEOUT);\n\tif (err < 0)\n\t\treturn err;\n\n\treport->blend_int\t= resp[1] & SI476X_ACF_BLEND_INT;\n\treport->hblend_int\t= resp[1] & SI476X_ACF_HIBLEND_INT;\n\treport->hicut_int\t= resp[1] & SI476X_ACF_HICUT_INT;\n\treport->chbw_int\t= resp[1] & SI476X_ACF_CHBW_INT;\n\treport->softmute_int\t= resp[1] & SI476X_ACF_SOFTMUTE_INT;\n\treport->smute\t\t= resp[2] & SI476X_ACF_SMUTE;\n\treport->smattn\t\t= resp[3] & SI476X_ACF_SMATTN;\n\treport->chbw\t\t= resp[4];\n\treport->hicut\t\t= resp[5];\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(si476x_core_cmd_am_acf_status);\n\n\n \nint si476x_core_cmd_fm_seek_start(struct si476x_core *core,\n\t\t\t\t  bool seekup, bool wrap)\n{\n\tu8       resp[CMD_FM_SEEK_START_NRESP];\n\tconst u8 args[CMD_FM_SEEK_START_NARGS] = {\n\t\tseekup << 3 | wrap << 2,\n\t};\n\n\treturn si476x_cmd_tune_seek_freq(core, CMD_FM_SEEK_START,\n\t\t\t\t\t args, sizeof(args),\n\t\t\t\t\t resp, sizeof(resp));\n}\nEXPORT_SYMBOL_GPL(si476x_core_cmd_fm_seek_start);\n\n \nint si476x_core_cmd_fm_rds_status(struct si476x_core *core,\n\t\t\t\t  bool status_only,\n\t\t\t\t  bool mtfifo,\n\t\t\t\t  bool intack,\n\t\t\t\t  struct si476x_rds_status_report *report)\n{\n\tint err;\n\tu8       resp[CMD_FM_RDS_STATUS_NRESP];\n\tconst u8 args[CMD_FM_RDS_STATUS_NARGS] = {\n\t\tstatus_only << 2 | mtfifo << 1 | intack,\n\t};\n\n\terr = si476x_core_send_command(core, CMD_FM_RDS_STATUS,\n\t\t\t\t       args, ARRAY_SIZE(args),\n\t\t\t\t       resp, ARRAY_SIZE(resp),\n\t\t\t\t       SI476X_DEFAULT_TIMEOUT);\n\t \n\tif (err < 0 || report == NULL)\n\t\treturn err;\n\n\treport->rdstpptyint\t= 0x10 & resp[1];\n\treport->rdspiint\t= 0x08 & resp[1];\n\treport->rdssyncint\t= 0x02 & resp[1];\n\treport->rdsfifoint\t= 0x01 & resp[1];\n\n\treport->tpptyvalid\t= 0x10 & resp[2];\n\treport->pivalid\t\t= 0x08 & resp[2];\n\treport->rdssync\t\t= 0x02 & resp[2];\n\treport->rdsfifolost\t= 0x01 & resp[2];\n\n\treport->tp\t\t= 0x20 & resp[3];\n\treport->pty\t\t= 0x1f & resp[3];\n\n\treport->pi\t\t= get_unaligned_be16(resp + 4);\n\treport->rdsfifoused\t= resp[6];\n\n\treport->ble[V4L2_RDS_BLOCK_A]\t= 0xc0 & resp[7];\n\treport->ble[V4L2_RDS_BLOCK_B]\t= 0x30 & resp[7];\n\treport->ble[V4L2_RDS_BLOCK_C]\t= 0x0c & resp[7];\n\treport->ble[V4L2_RDS_BLOCK_D]\t= 0x03 & resp[7];\n\n\treport->rds[V4L2_RDS_BLOCK_A].block = V4L2_RDS_BLOCK_A;\n\treport->rds[V4L2_RDS_BLOCK_A].msb = resp[8];\n\treport->rds[V4L2_RDS_BLOCK_A].lsb = resp[9];\n\n\treport->rds[V4L2_RDS_BLOCK_B].block = V4L2_RDS_BLOCK_B;\n\treport->rds[V4L2_RDS_BLOCK_B].msb = resp[10];\n\treport->rds[V4L2_RDS_BLOCK_B].lsb = resp[11];\n\n\treport->rds[V4L2_RDS_BLOCK_C].block = V4L2_RDS_BLOCK_C;\n\treport->rds[V4L2_RDS_BLOCK_C].msb = resp[12];\n\treport->rds[V4L2_RDS_BLOCK_C].lsb = resp[13];\n\n\treport->rds[V4L2_RDS_BLOCK_D].block = V4L2_RDS_BLOCK_D;\n\treport->rds[V4L2_RDS_BLOCK_D].msb = resp[14];\n\treport->rds[V4L2_RDS_BLOCK_D].lsb = resp[15];\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(si476x_core_cmd_fm_rds_status);\n\nint si476x_core_cmd_fm_rds_blockcount(struct si476x_core *core,\n\t\t\t\tbool clear,\n\t\t\t\tstruct si476x_rds_blockcount_report *report)\n{\n\tint err;\n\tu8       resp[CMD_FM_RDS_BLOCKCOUNT_NRESP];\n\tconst u8 args[CMD_FM_RDS_BLOCKCOUNT_NARGS] = {\n\t\tclear,\n\t};\n\n\tif (!report)\n\t\treturn -EINVAL;\n\n\terr = si476x_core_send_command(core, CMD_FM_RDS_BLOCKCOUNT,\n\t\t\t\t       args, ARRAY_SIZE(args),\n\t\t\t\t       resp, ARRAY_SIZE(resp),\n\t\t\t\t       SI476X_DEFAULT_TIMEOUT);\n\n\tif (!err) {\n\t\treport->expected\t= get_unaligned_be16(resp + 2);\n\t\treport->received\t= get_unaligned_be16(resp + 4);\n\t\treport->uncorrectable\t= get_unaligned_be16(resp + 6);\n\t}\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(si476x_core_cmd_fm_rds_blockcount);\n\nint si476x_core_cmd_fm_phase_diversity(struct si476x_core *core,\n\t\t\t\t       enum si476x_phase_diversity_mode mode)\n{\n\tu8       resp[CMD_FM_PHASE_DIVERSITY_NRESP];\n\tconst u8 args[CMD_FM_PHASE_DIVERSITY_NARGS] = {\n\t\tmode & 0x07,\n\t};\n\n\treturn si476x_core_send_command(core, CMD_FM_PHASE_DIVERSITY,\n\t\t\t\t\targs, ARRAY_SIZE(args),\n\t\t\t\t\tresp, ARRAY_SIZE(resp),\n\t\t\t\t\tSI476X_DEFAULT_TIMEOUT);\n}\nEXPORT_SYMBOL_GPL(si476x_core_cmd_fm_phase_diversity);\n \nint si476x_core_cmd_fm_phase_div_status(struct si476x_core *core)\n{\n\tint err;\n\tu8 resp[CMD_FM_PHASE_DIV_STATUS_NRESP];\n\n\terr = si476x_core_send_command(core, CMD_FM_PHASE_DIV_STATUS,\n\t\t\t\t       NULL, 0,\n\t\t\t\t       resp, ARRAY_SIZE(resp),\n\t\t\t\t       SI476X_DEFAULT_TIMEOUT);\n\n\treturn (err < 0) ? err : resp[1];\n}\nEXPORT_SYMBOL_GPL(si476x_core_cmd_fm_phase_div_status);\n\n\n \nint si476x_core_cmd_am_seek_start(struct si476x_core *core,\n\t\t\t\t  bool seekup, bool wrap)\n{\n\tu8       resp[CMD_AM_SEEK_START_NRESP];\n\tconst u8 args[CMD_AM_SEEK_START_NARGS] = {\n\t\tseekup << 3 | wrap << 2,\n\t};\n\n\treturn si476x_cmd_tune_seek_freq(core,  CMD_AM_SEEK_START,\n\t\t\t\t\t args, sizeof(args),\n\t\t\t\t\t resp, sizeof(resp));\n}\nEXPORT_SYMBOL_GPL(si476x_core_cmd_am_seek_start);\n\n\n\nstatic int si476x_core_cmd_power_up_a10(struct si476x_core *core,\n\t\t\t\t\tstruct si476x_power_up_args *puargs)\n{\n\tu8       resp[CMD_POWER_UP_A10_NRESP];\n\tconst bool intsel = (core->pinmux.a1 == SI476X_A1_IRQ);\n\tconst bool ctsen  = (core->client->irq != 0);\n\tconst u8 args[CMD_POWER_UP_A10_NARGS] = {\n\t\t0xF7,\t\t \n\t\t0x3F & puargs->xcload,\t \n\t\tctsen << 7 | intsel << 6 | 0x07,  \n\t\tpuargs->func << 4 | puargs->freq,\n\t\t0x11,\t\t \n\t};\n\n\treturn si476x_core_send_command(core, CMD_POWER_UP,\n\t\t\t\t\targs, ARRAY_SIZE(args),\n\t\t\t\t\tresp, ARRAY_SIZE(resp),\n\t\t\t\t\tSI476X_TIMEOUT_POWER_UP);\n}\n\nstatic int si476x_core_cmd_power_up_a20(struct si476x_core *core,\n\t\t\t\t struct si476x_power_up_args *puargs)\n{\n\tu8       resp[CMD_POWER_UP_A20_NRESP];\n\tconst bool intsel = (core->pinmux.a1 == SI476X_A1_IRQ);\n\tconst bool ctsen  = (core->client->irq != 0);\n\tconst u8 args[CMD_POWER_UP_A20_NARGS] = {\n\t\tpuargs->ibias6x << 7 | puargs->xstart,\n\t\t0x3F & puargs->xcload,\t \n\t\tctsen << 7 | intsel << 6 | puargs->fastboot << 5 |\n\t\tpuargs->xbiashc << 3 | puargs->xbias,\n\t\tpuargs->func << 4 | puargs->freq,\n\t\t0x10 | puargs->xmode,\n\t};\n\n\treturn si476x_core_send_command(core, CMD_POWER_UP,\n\t\t\t\t\targs, ARRAY_SIZE(args),\n\t\t\t\t\tresp, ARRAY_SIZE(resp),\n\t\t\t\t\tSI476X_TIMEOUT_POWER_UP);\n}\n\nstatic int si476x_core_cmd_power_down_a10(struct si476x_core *core,\n\t\t\t\t\t  struct si476x_power_down_args *pdargs)\n{\n\tu8 resp[CMD_POWER_DOWN_A10_NRESP];\n\n\treturn si476x_core_send_command(core, CMD_POWER_DOWN,\n\t\t\t\t\tNULL, 0,\n\t\t\t\t\tresp, ARRAY_SIZE(resp),\n\t\t\t\t\tSI476X_DEFAULT_TIMEOUT);\n}\n\nstatic int si476x_core_cmd_power_down_a20(struct si476x_core *core,\n\t\t\t\t\t  struct si476x_power_down_args *pdargs)\n{\n\tu8 resp[CMD_POWER_DOWN_A20_NRESP];\n\tconst u8 args[CMD_POWER_DOWN_A20_NARGS] = {\n\t\tpdargs->xosc,\n\t};\n\treturn si476x_core_send_command(core, CMD_POWER_DOWN,\n\t\t\t\t\targs, ARRAY_SIZE(args),\n\t\t\t\t\tresp, ARRAY_SIZE(resp),\n\t\t\t\t\tSI476X_DEFAULT_TIMEOUT);\n}\n\nstatic int si476x_core_cmd_am_tune_freq_a10(struct si476x_core *core,\n\t\t\t\t\tstruct si476x_tune_freq_args *tuneargs)\n{\n\n\tconst int am_freq = tuneargs->freq;\n\tu8       resp[CMD_AM_TUNE_FREQ_NRESP];\n\tconst u8 args[CMD_AM_TUNE_FREQ_NARGS] = {\n\t\t(tuneargs->hd << 6),\n\t\tmsb(am_freq),\n\t\tlsb(am_freq),\n\t};\n\n\treturn si476x_cmd_tune_seek_freq(core, CMD_AM_TUNE_FREQ, args,\n\t\t\t\t\t sizeof(args),\n\t\t\t\t\t resp, sizeof(resp));\n}\n\nstatic int si476x_core_cmd_am_tune_freq_a20(struct si476x_core *core,\n\t\t\t\t\tstruct si476x_tune_freq_args *tuneargs)\n{\n\tconst int am_freq = tuneargs->freq;\n\tu8       resp[CMD_AM_TUNE_FREQ_NRESP];\n\tconst u8 args[CMD_AM_TUNE_FREQ_NARGS] = {\n\t\t(tuneargs->zifsr << 6) | (tuneargs->injside & 0x03),\n\t\tmsb(am_freq),\n\t\tlsb(am_freq),\n\t};\n\n\treturn si476x_cmd_tune_seek_freq(core, CMD_AM_TUNE_FREQ,\n\t\t\t\t\t args, sizeof(args),\n\t\t\t\t\t resp, sizeof(resp));\n}\n\nstatic int si476x_core_cmd_fm_rsq_status_a10(struct si476x_core *core,\n\t\t\t\t\tstruct si476x_rsq_status_args *rsqargs,\n\t\t\t\t\tstruct si476x_rsq_status_report *report)\n{\n\tint err;\n\tu8       resp[CMD_FM_RSQ_STATUS_A10_NRESP];\n\tconst u8 args[CMD_FM_RSQ_STATUS_A10_NARGS] = {\n\t\trsqargs->rsqack << 3 | rsqargs->attune << 2 |\n\t\trsqargs->cancel << 1 | rsqargs->stcack,\n\t};\n\n\terr = si476x_core_send_command(core, CMD_FM_RSQ_STATUS,\n\t\t\t\t       args, ARRAY_SIZE(args),\n\t\t\t\t       resp, ARRAY_SIZE(resp),\n\t\t\t\t       SI476X_DEFAULT_TIMEOUT);\n\t \n\tif (err < 0 || report == NULL)\n\t\treturn err;\n\n\treport->multhint\t= 0x80 & resp[1];\n\treport->multlint\t= 0x40 & resp[1];\n\treport->snrhint\t\t= 0x08 & resp[1];\n\treport->snrlint\t\t= 0x04 & resp[1];\n\treport->rssihint\t= 0x02 & resp[1];\n\treport->rssilint\t= 0x01 & resp[1];\n\n\treport->bltf\t\t= 0x80 & resp[2];\n\treport->snr_ready\t= 0x20 & resp[2];\n\treport->rssiready\t= 0x08 & resp[2];\n\treport->afcrl\t\t= 0x02 & resp[2];\n\treport->valid\t\t= 0x01 & resp[2];\n\n\treport->readfreq\t= get_unaligned_be16(resp + 3);\n\treport->freqoff\t\t= resp[5];\n\treport->rssi\t\t= resp[6];\n\treport->snr\t\t= resp[7];\n\treport->lassi\t\t= resp[9];\n\treport->hassi\t\t= resp[10];\n\treport->mult\t\t= resp[11];\n\treport->dev\t\t= resp[12];\n\treport->readantcap\t= get_unaligned_be16(resp + 13);\n\treport->assi\t\t= resp[15];\n\treport->usn\t\t= resp[16];\n\n\treturn err;\n}\n\nstatic int si476x_core_cmd_fm_rsq_status_a20(struct si476x_core *core,\n\t\t\t\t     struct si476x_rsq_status_args *rsqargs,\n\t\t\t\t     struct si476x_rsq_status_report *report)\n{\n\tint err;\n\tu8       resp[CMD_FM_RSQ_STATUS_A10_NRESP];\n\tconst u8 args[CMD_FM_RSQ_STATUS_A30_NARGS] = {\n\t\trsqargs->primary << 4 | rsqargs->rsqack << 3 |\n\t\trsqargs->attune  << 2 | rsqargs->cancel << 1 |\n\t\trsqargs->stcack,\n\t};\n\n\terr = si476x_core_send_command(core, CMD_FM_RSQ_STATUS,\n\t\t\t\t       args, ARRAY_SIZE(args),\n\t\t\t\t       resp, ARRAY_SIZE(resp),\n\t\t\t\t       SI476X_DEFAULT_TIMEOUT);\n\t \n\tif (err < 0 || report == NULL)\n\t\treturn err;\n\n\treport->multhint\t= 0x80 & resp[1];\n\treport->multlint\t= 0x40 & resp[1];\n\treport->snrhint\t\t= 0x08 & resp[1];\n\treport->snrlint\t\t= 0x04 & resp[1];\n\treport->rssihint\t= 0x02 & resp[1];\n\treport->rssilint\t= 0x01 & resp[1];\n\n\treport->bltf\t\t= 0x80 & resp[2];\n\treport->snr_ready\t= 0x20 & resp[2];\n\treport->rssiready\t= 0x08 & resp[2];\n\treport->afcrl\t\t= 0x02 & resp[2];\n\treport->valid\t\t= 0x01 & resp[2];\n\n\treport->readfreq\t= get_unaligned_be16(resp + 3);\n\treport->freqoff\t\t= resp[5];\n\treport->rssi\t\t= resp[6];\n\treport->snr\t\t= resp[7];\n\treport->lassi\t\t= resp[9];\n\treport->hassi\t\t= resp[10];\n\treport->mult\t\t= resp[11];\n\treport->dev\t\t= resp[12];\n\treport->readantcap\t= get_unaligned_be16(resp + 13);\n\treport->assi\t\t= resp[15];\n\treport->usn\t\t= resp[16];\n\n\treturn err;\n}\n\n\nstatic int si476x_core_cmd_fm_rsq_status_a30(struct si476x_core *core,\n\t\t\t\t\tstruct si476x_rsq_status_args *rsqargs,\n\t\t\t\t\tstruct si476x_rsq_status_report *report)\n{\n\tint err;\n\tu8       resp[CMD_FM_RSQ_STATUS_A30_NRESP];\n\tconst u8 args[CMD_FM_RSQ_STATUS_A30_NARGS] = {\n\t\trsqargs->primary << 4 | rsqargs->rsqack << 3 |\n\t\trsqargs->attune << 2 | rsqargs->cancel << 1 |\n\t\trsqargs->stcack,\n\t};\n\n\terr = si476x_core_send_command(core, CMD_FM_RSQ_STATUS,\n\t\t\t\t       args, ARRAY_SIZE(args),\n\t\t\t\t       resp, ARRAY_SIZE(resp),\n\t\t\t\t       SI476X_DEFAULT_TIMEOUT);\n\t \n\tif (err < 0 || report == NULL)\n\t\treturn err;\n\n\treport->multhint\t= 0x80 & resp[1];\n\treport->multlint\t= 0x40 & resp[1];\n\treport->snrhint\t\t= 0x08 & resp[1];\n\treport->snrlint\t\t= 0x04 & resp[1];\n\treport->rssihint\t= 0x02 & resp[1];\n\treport->rssilint\t= 0x01 & resp[1];\n\n\treport->bltf\t\t= 0x80 & resp[2];\n\treport->snr_ready\t= 0x20 & resp[2];\n\treport->rssiready\t= 0x08 & resp[2];\n\treport->injside         = 0x04 & resp[2];\n\treport->afcrl\t\t= 0x02 & resp[2];\n\treport->valid\t\t= 0x01 & resp[2];\n\n\treport->readfreq\t= get_unaligned_be16(resp + 3);\n\treport->freqoff\t\t= resp[5];\n\treport->rssi\t\t= resp[6];\n\treport->snr\t\t= resp[7];\n\treport->issi\t\t= resp[8];\n\treport->lassi\t\t= resp[9];\n\treport->hassi\t\t= resp[10];\n\treport->mult\t\t= resp[11];\n\treport->dev\t\t= resp[12];\n\treport->readantcap\t= get_unaligned_be16(resp + 13);\n\treport->assi\t\t= resp[15];\n\treport->usn\t\t= resp[16];\n\n\treport->pilotdev\t= resp[17];\n\treport->rdsdev\t\t= resp[18];\n\treport->assidev\t\t= resp[19];\n\treport->strongdev\t= resp[20];\n\treport->rdspi\t\t= get_unaligned_be16(resp + 21);\n\n\treturn err;\n}\n\nstatic int si476x_core_cmd_fm_tune_freq_a10(struct si476x_core *core,\n\t\t\t\t\tstruct si476x_tune_freq_args *tuneargs)\n{\n\tu8       resp[CMD_FM_TUNE_FREQ_NRESP];\n\tconst u8 args[CMD_FM_TUNE_FREQ_A10_NARGS] = {\n\t\t(tuneargs->hd << 6) | (tuneargs->tunemode << 4)\n\t\t| (tuneargs->smoothmetrics << 2),\n\t\tmsb(tuneargs->freq),\n\t\tlsb(tuneargs->freq),\n\t\tmsb(tuneargs->antcap),\n\t\tlsb(tuneargs->antcap)\n\t};\n\n\treturn si476x_cmd_tune_seek_freq(core, CMD_FM_TUNE_FREQ,\n\t\t\t\t\t args, sizeof(args),\n\t\t\t\t\t resp, sizeof(resp));\n}\n\nstatic int si476x_core_cmd_fm_tune_freq_a20(struct si476x_core *core,\n\t\t\t\t\tstruct si476x_tune_freq_args *tuneargs)\n{\n\tu8       resp[CMD_FM_TUNE_FREQ_NRESP];\n\tconst u8 args[CMD_FM_TUNE_FREQ_A20_NARGS] = {\n\t\t(tuneargs->hd << 6) | (tuneargs->tunemode << 4)\n\t\t|  (tuneargs->smoothmetrics << 2) | (tuneargs->injside),\n\t\tmsb(tuneargs->freq),\n\t\tlsb(tuneargs->freq),\n\t};\n\n\treturn si476x_cmd_tune_seek_freq(core, CMD_FM_TUNE_FREQ,\n\t\t\t\t\t args, sizeof(args),\n\t\t\t\t\t resp, sizeof(resp));\n}\n\nstatic int si476x_core_cmd_agc_status_a20(struct si476x_core *core,\n\t\t\t\t\tstruct si476x_agc_status_report *report)\n{\n\tint err;\n\tu8 resp[CMD_AGC_STATUS_NRESP_A20];\n\n\tif (!report)\n\t\treturn -EINVAL;\n\n\terr = si476x_core_send_command(core, CMD_AGC_STATUS,\n\t\t\t\t       NULL, 0,\n\t\t\t\t       resp, ARRAY_SIZE(resp),\n\t\t\t\t       SI476X_DEFAULT_TIMEOUT);\n\tif (err < 0)\n\t\treturn err;\n\n\treport->mxhi\t\t= resp[1] & SI476X_AGC_MXHI;\n\treport->mxlo\t\t= resp[1] & SI476X_AGC_MXLO;\n\treport->lnahi\t\t= resp[1] & SI476X_AGC_LNAHI;\n\treport->lnalo\t\t= resp[1] & SI476X_AGC_LNALO;\n\treport->fmagc1\t\t= resp[2];\n\treport->fmagc2\t\t= resp[3];\n\treport->pgagain\t\t= resp[4];\n\treport->fmwblang\t= resp[5];\n\n\treturn err;\n}\n\nstatic int si476x_core_cmd_agc_status_a10(struct si476x_core *core,\n\t\t\t\t\tstruct si476x_agc_status_report *report)\n{\n\tint err;\n\tu8 resp[CMD_AGC_STATUS_NRESP_A10];\n\n\tif (!report)\n\t\treturn -EINVAL;\n\n\terr = si476x_core_send_command(core, CMD_AGC_STATUS,\n\t\t\t\t       NULL, 0,\n\t\t\t\t       resp, ARRAY_SIZE(resp),\n\t\t\t\t       SI476X_DEFAULT_TIMEOUT);\n\tif (err < 0)\n\t\treturn err;\n\n\treport->mxhi\t= resp[1] & SI476X_AGC_MXHI;\n\treport->mxlo\t= resp[1] & SI476X_AGC_MXLO;\n\treport->lnahi\t= resp[1] & SI476X_AGC_LNAHI;\n\treport->lnalo\t= resp[1] & SI476X_AGC_LNALO;\n\n\treturn err;\n}\n\ntypedef int (*tune_freq_func_t) (struct si476x_core *core,\n\t\t\t\t struct si476x_tune_freq_args *tuneargs);\n\nstatic struct {\n\tint (*power_up)(struct si476x_core *,\n\t\t\tstruct si476x_power_up_args *);\n\tint (*power_down)(struct si476x_core *,\n\t\t\t  struct si476x_power_down_args *);\n\n\ttune_freq_func_t fm_tune_freq;\n\ttune_freq_func_t am_tune_freq;\n\n\tint (*fm_rsq_status)(struct si476x_core *,\n\t\t\t     struct si476x_rsq_status_args *,\n\t\t\t     struct si476x_rsq_status_report *);\n\n\tint (*agc_status)(struct si476x_core *,\n\t\t\t  struct si476x_agc_status_report *);\n\tint (*intb_pin_cfg)(struct si476x_core *core,\n\t\t\t    enum si476x_intb_config intb,\n\t\t\t    enum si476x_a1_config a1);\n} si476x_cmds_vtable[] = {\n\t[SI476X_REVISION_A10] = {\n\t\t.power_up\t= si476x_core_cmd_power_up_a10,\n\t\t.power_down\t= si476x_core_cmd_power_down_a10,\n\t\t.fm_tune_freq\t= si476x_core_cmd_fm_tune_freq_a10,\n\t\t.am_tune_freq\t= si476x_core_cmd_am_tune_freq_a10,\n\t\t.fm_rsq_status\t= si476x_core_cmd_fm_rsq_status_a10,\n\t\t.agc_status\t= si476x_core_cmd_agc_status_a10,\n\t\t.intb_pin_cfg   = si476x_core_cmd_intb_pin_cfg_a10,\n\t},\n\t[SI476X_REVISION_A20] = {\n\t\t.power_up\t= si476x_core_cmd_power_up_a20,\n\t\t.power_down\t= si476x_core_cmd_power_down_a20,\n\t\t.fm_tune_freq\t= si476x_core_cmd_fm_tune_freq_a20,\n\t\t.am_tune_freq\t= si476x_core_cmd_am_tune_freq_a20,\n\t\t.fm_rsq_status\t= si476x_core_cmd_fm_rsq_status_a20,\n\t\t.agc_status\t= si476x_core_cmd_agc_status_a20,\n\t\t.intb_pin_cfg   = si476x_core_cmd_intb_pin_cfg_a20,\n\t},\n\t[SI476X_REVISION_A30] = {\n\t\t.power_up\t= si476x_core_cmd_power_up_a20,\n\t\t.power_down\t= si476x_core_cmd_power_down_a20,\n\t\t.fm_tune_freq\t= si476x_core_cmd_fm_tune_freq_a20,\n\t\t.am_tune_freq\t= si476x_core_cmd_am_tune_freq_a20,\n\t\t.fm_rsq_status\t= si476x_core_cmd_fm_rsq_status_a30,\n\t\t.agc_status\t= si476x_core_cmd_agc_status_a20,\n\t\t.intb_pin_cfg   = si476x_core_cmd_intb_pin_cfg_a20,\n\t},\n};\n\nint si476x_core_cmd_power_up(struct si476x_core *core,\n\t\t\t     struct si476x_power_up_args *args)\n{\n\tBUG_ON(core->revision > SI476X_REVISION_A30 ||\n\t       core->revision == -1);\n\treturn si476x_cmds_vtable[core->revision].power_up(core, args);\n}\nEXPORT_SYMBOL_GPL(si476x_core_cmd_power_up);\n\nint si476x_core_cmd_power_down(struct si476x_core *core,\n\t\t\t       struct si476x_power_down_args *args)\n{\n\tBUG_ON(core->revision > SI476X_REVISION_A30 ||\n\t       core->revision == -1);\n\treturn si476x_cmds_vtable[core->revision].power_down(core, args);\n}\nEXPORT_SYMBOL_GPL(si476x_core_cmd_power_down);\n\nint si476x_core_cmd_fm_tune_freq(struct si476x_core *core,\n\t\t\t\t struct si476x_tune_freq_args *args)\n{\n\tBUG_ON(core->revision > SI476X_REVISION_A30 ||\n\t       core->revision == -1);\n\treturn si476x_cmds_vtable[core->revision].fm_tune_freq(core, args);\n}\nEXPORT_SYMBOL_GPL(si476x_core_cmd_fm_tune_freq);\n\nint si476x_core_cmd_am_tune_freq(struct si476x_core *core,\n\t\t\t\t struct si476x_tune_freq_args *args)\n{\n\tBUG_ON(core->revision > SI476X_REVISION_A30 ||\n\t       core->revision == -1);\n\treturn si476x_cmds_vtable[core->revision].am_tune_freq(core, args);\n}\nEXPORT_SYMBOL_GPL(si476x_core_cmd_am_tune_freq);\n\nint si476x_core_cmd_fm_rsq_status(struct si476x_core *core,\n\t\t\t\t  struct si476x_rsq_status_args *args,\n\t\t\t\t  struct si476x_rsq_status_report *report)\n\n{\n\tBUG_ON(core->revision > SI476X_REVISION_A30 ||\n\t       core->revision == -1);\n\treturn si476x_cmds_vtable[core->revision].fm_rsq_status(core, args,\n\t\t\t\t\t\t\t\treport);\n}\nEXPORT_SYMBOL_GPL(si476x_core_cmd_fm_rsq_status);\n\nint si476x_core_cmd_agc_status(struct si476x_core *core,\n\t\t\t\t  struct si476x_agc_status_report *report)\n\n{\n\tBUG_ON(core->revision > SI476X_REVISION_A30 ||\n\t       core->revision == -1);\n\treturn si476x_cmds_vtable[core->revision].agc_status(core, report);\n}\nEXPORT_SYMBOL_GPL(si476x_core_cmd_agc_status);\n\nint si476x_core_cmd_intb_pin_cfg(struct si476x_core *core,\n\t\t\t    enum si476x_intb_config intb,\n\t\t\t    enum si476x_a1_config a1)\n{\n\tBUG_ON(core->revision > SI476X_REVISION_A30 ||\n\t       core->revision == -1);\n\n\treturn si476x_cmds_vtable[core->revision].intb_pin_cfg(core, intb, a1);\n}\nEXPORT_SYMBOL_GPL(si476x_core_cmd_intb_pin_cfg);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Andrey Smirnov <andrew.smirnov@gmail.com>\");\nMODULE_DESCRIPTION(\"API for command exchange for si476x\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}