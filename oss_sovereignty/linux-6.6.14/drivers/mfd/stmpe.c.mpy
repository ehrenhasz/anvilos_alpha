{
  "module_name": "stmpe.c",
  "hash_id": "3d7fc9f65b1594d1d947a599a5cfa43b53328fceb62478751c3c690089aad1dc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/stmpe.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/gpio/consumer.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/of.h>\n#include <linux/pm.h>\n#include <linux/slab.h>\n#include <linux/mfd/core.h>\n#include <linux/delay.h>\n#include <linux/regulator/consumer.h>\n#include \"stmpe.h\"\n\n \nstruct stmpe_platform_data {\n\tint id;\n\tunsigned int blocks;\n\tunsigned int irq_trigger;\n\tbool autosleep;\n\tint autosleep_timeout;\n};\n\nstatic int __stmpe_enable(struct stmpe *stmpe, unsigned int blocks)\n{\n\treturn stmpe->variant->enable(stmpe, blocks, true);\n}\n\nstatic int __stmpe_disable(struct stmpe *stmpe, unsigned int blocks)\n{\n\treturn stmpe->variant->enable(stmpe, blocks, false);\n}\n\nstatic int __stmpe_reg_read(struct stmpe *stmpe, u8 reg)\n{\n\tint ret;\n\n\tret = stmpe->ci->read_byte(stmpe, reg);\n\tif (ret < 0)\n\t\tdev_err(stmpe->dev, \"failed to read reg %#x: %d\\n\", reg, ret);\n\n\tdev_vdbg(stmpe->dev, \"rd: reg %#x => data %#x\\n\", reg, ret);\n\n\treturn ret;\n}\n\nstatic int __stmpe_reg_write(struct stmpe *stmpe, u8 reg, u8 val)\n{\n\tint ret;\n\n\tdev_vdbg(stmpe->dev, \"wr: reg %#x <= %#x\\n\", reg, val);\n\n\tret = stmpe->ci->write_byte(stmpe, reg, val);\n\tif (ret < 0)\n\t\tdev_err(stmpe->dev, \"failed to write reg %#x: %d\\n\", reg, ret);\n\n\treturn ret;\n}\n\nstatic int __stmpe_set_bits(struct stmpe *stmpe, u8 reg, u8 mask, u8 val)\n{\n\tint ret;\n\n\tret = __stmpe_reg_read(stmpe, reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret &= ~mask;\n\tret |= val;\n\n\treturn __stmpe_reg_write(stmpe, reg, ret);\n}\n\nstatic int __stmpe_block_read(struct stmpe *stmpe, u8 reg, u8 length,\n\t\t\t      u8 *values)\n{\n\tint ret;\n\n\tret = stmpe->ci->read_block(stmpe, reg, length, values);\n\tif (ret < 0)\n\t\tdev_err(stmpe->dev, \"failed to read regs %#x: %d\\n\", reg, ret);\n\n\tdev_vdbg(stmpe->dev, \"rd: reg %#x (%d) => ret %#x\\n\", reg, length, ret);\n\tstmpe_dump_bytes(\"stmpe rd: \", values, length);\n\n\treturn ret;\n}\n\nstatic int __stmpe_block_write(struct stmpe *stmpe, u8 reg, u8 length,\n\t\t\tconst u8 *values)\n{\n\tint ret;\n\n\tdev_vdbg(stmpe->dev, \"wr: regs %#x (%d)\\n\", reg, length);\n\tstmpe_dump_bytes(\"stmpe wr: \", values, length);\n\n\tret = stmpe->ci->write_block(stmpe, reg, length, values);\n\tif (ret < 0)\n\t\tdev_err(stmpe->dev, \"failed to write regs %#x: %d\\n\", reg, ret);\n\n\treturn ret;\n}\n\n \nint stmpe_enable(struct stmpe *stmpe, unsigned int blocks)\n{\n\tint ret;\n\n\tmutex_lock(&stmpe->lock);\n\tret = __stmpe_enable(stmpe, blocks);\n\tmutex_unlock(&stmpe->lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(stmpe_enable);\n\n \nint stmpe_disable(struct stmpe *stmpe, unsigned int blocks)\n{\n\tint ret;\n\n\tmutex_lock(&stmpe->lock);\n\tret = __stmpe_disable(stmpe, blocks);\n\tmutex_unlock(&stmpe->lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(stmpe_disable);\n\n \nint stmpe_reg_read(struct stmpe *stmpe, u8 reg)\n{\n\tint ret;\n\n\tmutex_lock(&stmpe->lock);\n\tret = __stmpe_reg_read(stmpe, reg);\n\tmutex_unlock(&stmpe->lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(stmpe_reg_read);\n\n \nint stmpe_reg_write(struct stmpe *stmpe, u8 reg, u8 val)\n{\n\tint ret;\n\n\tmutex_lock(&stmpe->lock);\n\tret = __stmpe_reg_write(stmpe, reg, val);\n\tmutex_unlock(&stmpe->lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(stmpe_reg_write);\n\n \nint stmpe_set_bits(struct stmpe *stmpe, u8 reg, u8 mask, u8 val)\n{\n\tint ret;\n\n\tmutex_lock(&stmpe->lock);\n\tret = __stmpe_set_bits(stmpe, reg, mask, val);\n\tmutex_unlock(&stmpe->lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(stmpe_set_bits);\n\n \nint stmpe_block_read(struct stmpe *stmpe, u8 reg, u8 length, u8 *values)\n{\n\tint ret;\n\n\tmutex_lock(&stmpe->lock);\n\tret = __stmpe_block_read(stmpe, reg, length, values);\n\tmutex_unlock(&stmpe->lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(stmpe_block_read);\n\n \nint stmpe_block_write(struct stmpe *stmpe, u8 reg, u8 length,\n\t\t      const u8 *values)\n{\n\tint ret;\n\n\tmutex_lock(&stmpe->lock);\n\tret = __stmpe_block_write(stmpe, reg, length, values);\n\tmutex_unlock(&stmpe->lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(stmpe_block_write);\n\n \nint stmpe_set_altfunc(struct stmpe *stmpe, u32 pins, enum stmpe_block block)\n{\n\tstruct stmpe_variant_info *variant = stmpe->variant;\n\tu8 regaddr = stmpe->regs[STMPE_IDX_GPAFR_U_MSB];\n\tint af_bits = variant->af_bits;\n\tint numregs = DIV_ROUND_UP(stmpe->num_gpios * af_bits, 8);\n\tint mask = (1 << af_bits) - 1;\n\tu8 regs[8];\n\tint af, afperreg, ret;\n\n\tif (!variant->get_altfunc)\n\t\treturn 0;\n\n\tafperreg = 8 / af_bits;\n\tmutex_lock(&stmpe->lock);\n\n\tret = __stmpe_enable(stmpe, STMPE_BLOCK_GPIO);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = __stmpe_block_read(stmpe, regaddr, numregs, regs);\n\tif (ret < 0)\n\t\tgoto out;\n\n\taf = variant->get_altfunc(stmpe, block);\n\n\twhile (pins) {\n\t\tint pin = __ffs(pins);\n\t\tint regoffset = numregs - (pin / afperreg) - 1;\n\t\tint pos = (pin % afperreg) * (8 / afperreg);\n\n\t\tregs[regoffset] &= ~(mask << pos);\n\t\tregs[regoffset] |= af << pos;\n\n\t\tpins &= ~(1 << pin);\n\t}\n\n\tret = __stmpe_block_write(stmpe, regaddr, numregs, regs);\n\nout:\n\tmutex_unlock(&stmpe->lock);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(stmpe_set_altfunc);\n\n \n\nstatic struct resource stmpe_gpio_resources[] = {\n\t \n\t{\n\t\t.flags\t= IORESOURCE_IRQ,\n\t},\n};\n\nstatic const struct mfd_cell stmpe_gpio_cell = {\n\t.name\t\t= \"stmpe-gpio\",\n\t.of_compatible\t= \"st,stmpe-gpio\",\n\t.resources\t= stmpe_gpio_resources,\n\t.num_resources\t= ARRAY_SIZE(stmpe_gpio_resources),\n};\n\nstatic const struct mfd_cell stmpe_gpio_cell_noirq = {\n\t.name\t\t= \"stmpe-gpio\",\n\t.of_compatible\t= \"st,stmpe-gpio\",\n\t \n};\n\n \n\nstatic struct resource stmpe_keypad_resources[] = {\n\t \n\t{\n\t\t.name\t= \"KEYPAD\",\n\t\t.flags\t= IORESOURCE_IRQ,\n\t},\n\t{\n\t\t.name\t= \"KEYPAD_OVER\",\n\t\t.flags\t= IORESOURCE_IRQ,\n\t},\n};\n\nstatic const struct mfd_cell stmpe_keypad_cell = {\n\t.name\t\t= \"stmpe-keypad\",\n\t.of_compatible  = \"st,stmpe-keypad\",\n\t.resources\t= stmpe_keypad_resources,\n\t.num_resources\t= ARRAY_SIZE(stmpe_keypad_resources),\n};\n\n \nstatic struct resource stmpe_pwm_resources[] = {\n\t \n\t{\n\t\t.name\t= \"PWM0\",\n\t\t.flags\t= IORESOURCE_IRQ,\n\t},\n\t{\n\t\t.name\t= \"PWM1\",\n\t\t.flags\t= IORESOURCE_IRQ,\n\t},\n\t{\n\t\t.name\t= \"PWM2\",\n\t\t.flags\t= IORESOURCE_IRQ,\n\t},\n};\n\nstatic const struct mfd_cell stmpe_pwm_cell = {\n\t.name\t\t= \"stmpe-pwm\",\n\t.of_compatible  = \"st,stmpe-pwm\",\n\t.resources\t= stmpe_pwm_resources,\n\t.num_resources\t= ARRAY_SIZE(stmpe_pwm_resources),\n};\n\n \nstatic const u8 stmpe801_regs[] = {\n\t[STMPE_IDX_CHIP_ID]\t= STMPE801_REG_CHIP_ID,\n\t[STMPE_IDX_ICR_LSB]\t= STMPE801_REG_SYS_CTRL,\n\t[STMPE_IDX_GPMR_LSB]\t= STMPE801_REG_GPIO_MP_STA,\n\t[STMPE_IDX_GPSR_LSB]\t= STMPE801_REG_GPIO_SET_PIN,\n\t[STMPE_IDX_GPCR_LSB]\t= STMPE801_REG_GPIO_SET_PIN,\n\t[STMPE_IDX_GPDR_LSB]\t= STMPE801_REG_GPIO_DIR,\n\t[STMPE_IDX_IEGPIOR_LSB] = STMPE801_REG_GPIO_INT_EN,\n\t[STMPE_IDX_ISGPIOR_MSB] = STMPE801_REG_GPIO_INT_STA,\n\n};\n\nstatic struct stmpe_variant_block stmpe801_blocks[] = {\n\t{\n\t\t.cell\t= &stmpe_gpio_cell,\n\t\t.irq\t= 0,\n\t\t.block\t= STMPE_BLOCK_GPIO,\n\t},\n};\n\nstatic struct stmpe_variant_block stmpe801_blocks_noirq[] = {\n\t{\n\t\t.cell\t= &stmpe_gpio_cell_noirq,\n\t\t.block\t= STMPE_BLOCK_GPIO,\n\t},\n};\n\nstatic int stmpe801_enable(struct stmpe *stmpe, unsigned int blocks,\n\t\t\t   bool enable)\n{\n\tif (blocks & STMPE_BLOCK_GPIO)\n\t\treturn 0;\n\telse\n\t\treturn -EINVAL;\n}\n\nstatic struct stmpe_variant_info stmpe801 = {\n\t.name\t\t= \"stmpe801\",\n\t.id_val\t\t= STMPE801_ID,\n\t.id_mask\t= 0xffff,\n\t.num_gpios\t= 8,\n\t.regs\t\t= stmpe801_regs,\n\t.blocks\t\t= stmpe801_blocks,\n\t.num_blocks\t= ARRAY_SIZE(stmpe801_blocks),\n\t.num_irqs\t= STMPE801_NR_INTERNAL_IRQS,\n\t.enable\t\t= stmpe801_enable,\n};\n\nstatic struct stmpe_variant_info stmpe801_noirq = {\n\t.name\t\t= \"stmpe801\",\n\t.id_val\t\t= STMPE801_ID,\n\t.id_mask\t= 0xffff,\n\t.num_gpios\t= 8,\n\t.regs\t\t= stmpe801_regs,\n\t.blocks\t\t= stmpe801_blocks_noirq,\n\t.num_blocks\t= ARRAY_SIZE(stmpe801_blocks_noirq),\n\t.enable\t\t= stmpe801_enable,\n};\n\n \n\nstatic struct resource stmpe_ts_resources[] = {\n\t \n\t{\n\t\t.name\t= \"TOUCH_DET\",\n\t\t.flags\t= IORESOURCE_IRQ,\n\t},\n\t{\n\t\t.name\t= \"FIFO_TH\",\n\t\t.flags\t= IORESOURCE_IRQ,\n\t},\n};\n\nstatic const struct mfd_cell stmpe_ts_cell = {\n\t.name\t\t= \"stmpe-ts\",\n\t.of_compatible\t= \"st,stmpe-ts\",\n\t.resources\t= stmpe_ts_resources,\n\t.num_resources\t= ARRAY_SIZE(stmpe_ts_resources),\n};\n\n \n\nstatic struct resource stmpe_adc_resources[] = {\n\t \n\t{\n\t\t.name\t= \"STMPE_TEMP_SENS\",\n\t\t.flags\t= IORESOURCE_IRQ,\n\t},\n\t{\n\t\t.name\t= \"STMPE_ADC\",\n\t\t.flags\t= IORESOURCE_IRQ,\n\t},\n};\n\nstatic const struct mfd_cell stmpe_adc_cell = {\n\t.name\t\t= \"stmpe-adc\",\n\t.of_compatible\t= \"st,stmpe-adc\",\n\t.resources\t= stmpe_adc_resources,\n\t.num_resources\t= ARRAY_SIZE(stmpe_adc_resources),\n};\n\n \n\nstatic const u8 stmpe811_regs[] = {\n\t[STMPE_IDX_CHIP_ID]\t= STMPE811_REG_CHIP_ID,\n\t[STMPE_IDX_SYS_CTRL]\t= STMPE811_REG_SYS_CTRL,\n\t[STMPE_IDX_SYS_CTRL2]\t= STMPE811_REG_SYS_CTRL2,\n\t[STMPE_IDX_ICR_LSB]\t= STMPE811_REG_INT_CTRL,\n\t[STMPE_IDX_IER_LSB]\t= STMPE811_REG_INT_EN,\n\t[STMPE_IDX_ISR_MSB]\t= STMPE811_REG_INT_STA,\n\t[STMPE_IDX_GPMR_LSB]\t= STMPE811_REG_GPIO_MP_STA,\n\t[STMPE_IDX_GPSR_LSB]\t= STMPE811_REG_GPIO_SET_PIN,\n\t[STMPE_IDX_GPCR_LSB]\t= STMPE811_REG_GPIO_CLR_PIN,\n\t[STMPE_IDX_GPDR_LSB]\t= STMPE811_REG_GPIO_DIR,\n\t[STMPE_IDX_GPRER_LSB]\t= STMPE811_REG_GPIO_RE,\n\t[STMPE_IDX_GPFER_LSB]\t= STMPE811_REG_GPIO_FE,\n\t[STMPE_IDX_GPAFR_U_MSB]\t= STMPE811_REG_GPIO_AF,\n\t[STMPE_IDX_IEGPIOR_LSB]\t= STMPE811_REG_GPIO_INT_EN,\n\t[STMPE_IDX_ISGPIOR_MSB]\t= STMPE811_REG_GPIO_INT_STA,\n\t[STMPE_IDX_GPEDR_LSB]\t= STMPE811_REG_GPIO_ED,\n};\n\nstatic struct stmpe_variant_block stmpe811_blocks[] = {\n\t{\n\t\t.cell\t= &stmpe_gpio_cell,\n\t\t.irq\t= STMPE811_IRQ_GPIOC,\n\t\t.block\t= STMPE_BLOCK_GPIO,\n\t},\n\t{\n\t\t.cell\t= &stmpe_ts_cell,\n\t\t.irq\t= STMPE811_IRQ_TOUCH_DET,\n\t\t.block\t= STMPE_BLOCK_TOUCHSCREEN,\n\t},\n\t{\n\t\t.cell\t= &stmpe_adc_cell,\n\t\t.irq\t= STMPE811_IRQ_TEMP_SENS,\n\t\t.block\t= STMPE_BLOCK_ADC,\n\t},\n};\n\nstatic int stmpe811_enable(struct stmpe *stmpe, unsigned int blocks,\n\t\t\t   bool enable)\n{\n\tunsigned int mask = 0;\n\n\tif (blocks & STMPE_BLOCK_GPIO)\n\t\tmask |= STMPE811_SYS_CTRL2_GPIO_OFF;\n\n\tif (blocks & STMPE_BLOCK_ADC)\n\t\tmask |= STMPE811_SYS_CTRL2_ADC_OFF;\n\n\tif (blocks & STMPE_BLOCK_TOUCHSCREEN)\n\t\tmask |= STMPE811_SYS_CTRL2_TSC_OFF;\n\n\treturn __stmpe_set_bits(stmpe, stmpe->regs[STMPE_IDX_SYS_CTRL2], mask,\n\t\t\t\tenable ? 0 : mask);\n}\n\nint stmpe811_adc_common_init(struct stmpe *stmpe)\n{\n\tint ret;\n\tu8 adc_ctrl1, adc_ctrl1_mask;\n\n\tadc_ctrl1 = STMPE_SAMPLE_TIME(stmpe->sample_time) |\n\t\t    STMPE_MOD_12B(stmpe->mod_12b) |\n\t\t    STMPE_REF_SEL(stmpe->ref_sel);\n\tadc_ctrl1_mask = STMPE_SAMPLE_TIME(0xff) | STMPE_MOD_12B(0xff) |\n\t\t\t STMPE_REF_SEL(0xff);\n\n\tret = stmpe_set_bits(stmpe, STMPE811_REG_ADC_CTRL1,\n\t\t\tadc_ctrl1_mask, adc_ctrl1);\n\tif (ret) {\n\t\tdev_err(stmpe->dev, \"Could not setup ADC\\n\");\n\t\treturn ret;\n\t}\n\n\tret = stmpe_set_bits(stmpe, STMPE811_REG_ADC_CTRL2,\n\t\t\tSTMPE_ADC_FREQ(0xff), STMPE_ADC_FREQ(stmpe->adc_freq));\n\tif (ret) {\n\t\tdev_err(stmpe->dev, \"Could not setup ADC\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(stmpe811_adc_common_init);\n\nstatic int stmpe811_get_altfunc(struct stmpe *stmpe, enum stmpe_block block)\n{\n\t \n\treturn block != STMPE_BLOCK_TOUCHSCREEN;\n}\n\nstatic struct stmpe_variant_info stmpe811 = {\n\t.name\t\t= \"stmpe811\",\n\t.id_val\t\t= 0x0811,\n\t.id_mask\t= 0xffff,\n\t.num_gpios\t= 8,\n\t.af_bits\t= 1,\n\t.regs\t\t= stmpe811_regs,\n\t.blocks\t\t= stmpe811_blocks,\n\t.num_blocks\t= ARRAY_SIZE(stmpe811_blocks),\n\t.num_irqs\t= STMPE811_NR_INTERNAL_IRQS,\n\t.enable\t\t= stmpe811_enable,\n\t.get_altfunc\t= stmpe811_get_altfunc,\n};\n\n \nstatic struct stmpe_variant_info stmpe610 = {\n\t.name\t\t= \"stmpe610\",\n\t.id_val\t\t= 0x0811,\n\t.id_mask\t= 0xffff,\n\t.num_gpios\t= 6,\n\t.af_bits\t= 1,\n\t.regs\t\t= stmpe811_regs,\n\t.blocks\t\t= stmpe811_blocks,\n\t.num_blocks\t= ARRAY_SIZE(stmpe811_blocks),\n\t.num_irqs\t= STMPE811_NR_INTERNAL_IRQS,\n\t.enable\t\t= stmpe811_enable,\n\t.get_altfunc\t= stmpe811_get_altfunc,\n};\n\n \n\nstatic const u8 stmpe1600_regs[] = {\n\t[STMPE_IDX_CHIP_ID]\t= STMPE1600_REG_CHIP_ID,\n\t[STMPE_IDX_SYS_CTRL]\t= STMPE1600_REG_SYS_CTRL,\n\t[STMPE_IDX_ICR_LSB]\t= STMPE1600_REG_SYS_CTRL,\n\t[STMPE_IDX_GPMR_LSB]\t= STMPE1600_REG_GPMR_LSB,\n\t[STMPE_IDX_GPMR_CSB]\t= STMPE1600_REG_GPMR_MSB,\n\t[STMPE_IDX_GPSR_LSB]\t= STMPE1600_REG_GPSR_LSB,\n\t[STMPE_IDX_GPSR_CSB]\t= STMPE1600_REG_GPSR_MSB,\n\t[STMPE_IDX_GPCR_LSB]\t= STMPE1600_REG_GPSR_LSB,\n\t[STMPE_IDX_GPCR_CSB]\t= STMPE1600_REG_GPSR_MSB,\n\t[STMPE_IDX_GPDR_LSB]\t= STMPE1600_REG_GPDR_LSB,\n\t[STMPE_IDX_GPDR_CSB]\t= STMPE1600_REG_GPDR_MSB,\n\t[STMPE_IDX_IEGPIOR_LSB]\t= STMPE1600_REG_IEGPIOR_LSB,\n\t[STMPE_IDX_IEGPIOR_CSB]\t= STMPE1600_REG_IEGPIOR_MSB,\n\t[STMPE_IDX_ISGPIOR_LSB]\t= STMPE1600_REG_ISGPIOR_LSB,\n};\n\nstatic struct stmpe_variant_block stmpe1600_blocks[] = {\n\t{\n\t\t.cell\t= &stmpe_gpio_cell,\n\t\t.irq\t= 0,\n\t\t.block\t= STMPE_BLOCK_GPIO,\n\t},\n};\n\nstatic int stmpe1600_enable(struct stmpe *stmpe, unsigned int blocks,\n\t\t\t   bool enable)\n{\n\tif (blocks & STMPE_BLOCK_GPIO)\n\t\treturn 0;\n\telse\n\t\treturn -EINVAL;\n}\n\nstatic struct stmpe_variant_info stmpe1600 = {\n\t.name\t\t= \"stmpe1600\",\n\t.id_val\t\t= STMPE1600_ID,\n\t.id_mask\t= 0xffff,\n\t.num_gpios\t= 16,\n\t.af_bits\t= 0,\n\t.regs\t\t= stmpe1600_regs,\n\t.blocks\t\t= stmpe1600_blocks,\n\t.num_blocks\t= ARRAY_SIZE(stmpe1600_blocks),\n\t.num_irqs\t= STMPE1600_NR_INTERNAL_IRQS,\n\t.enable\t\t= stmpe1600_enable,\n};\n\n \n\nstatic const u8 stmpe1601_regs[] = {\n\t[STMPE_IDX_CHIP_ID]\t= STMPE1601_REG_CHIP_ID,\n\t[STMPE_IDX_SYS_CTRL]\t= STMPE1601_REG_SYS_CTRL,\n\t[STMPE_IDX_SYS_CTRL2]\t= STMPE1601_REG_SYS_CTRL2,\n\t[STMPE_IDX_ICR_LSB]\t= STMPE1601_REG_ICR_LSB,\n\t[STMPE_IDX_IER_MSB]\t= STMPE1601_REG_IER_MSB,\n\t[STMPE_IDX_IER_LSB]\t= STMPE1601_REG_IER_LSB,\n\t[STMPE_IDX_ISR_MSB]\t= STMPE1601_REG_ISR_MSB,\n\t[STMPE_IDX_GPMR_LSB]\t= STMPE1601_REG_GPIO_MP_LSB,\n\t[STMPE_IDX_GPMR_CSB]\t= STMPE1601_REG_GPIO_MP_MSB,\n\t[STMPE_IDX_GPSR_LSB]\t= STMPE1601_REG_GPIO_SET_LSB,\n\t[STMPE_IDX_GPSR_CSB]\t= STMPE1601_REG_GPIO_SET_MSB,\n\t[STMPE_IDX_GPCR_LSB]\t= STMPE1601_REG_GPIO_CLR_LSB,\n\t[STMPE_IDX_GPCR_CSB]\t= STMPE1601_REG_GPIO_CLR_MSB,\n\t[STMPE_IDX_GPDR_LSB]\t= STMPE1601_REG_GPIO_SET_DIR_LSB,\n\t[STMPE_IDX_GPDR_CSB]\t= STMPE1601_REG_GPIO_SET_DIR_MSB,\n\t[STMPE_IDX_GPEDR_LSB]\t= STMPE1601_REG_GPIO_ED_LSB,\n\t[STMPE_IDX_GPEDR_CSB]\t= STMPE1601_REG_GPIO_ED_MSB,\n\t[STMPE_IDX_GPRER_LSB]\t= STMPE1601_REG_GPIO_RE_LSB,\n\t[STMPE_IDX_GPRER_CSB]\t= STMPE1601_REG_GPIO_RE_MSB,\n\t[STMPE_IDX_GPFER_LSB]\t= STMPE1601_REG_GPIO_FE_LSB,\n\t[STMPE_IDX_GPFER_CSB]\t= STMPE1601_REG_GPIO_FE_MSB,\n\t[STMPE_IDX_GPPUR_LSB]\t= STMPE1601_REG_GPIO_PU_LSB,\n\t[STMPE_IDX_GPAFR_U_MSB]\t= STMPE1601_REG_GPIO_AF_U_MSB,\n\t[STMPE_IDX_IEGPIOR_LSB]\t= STMPE1601_REG_INT_EN_GPIO_MASK_LSB,\n\t[STMPE_IDX_IEGPIOR_CSB]\t= STMPE1601_REG_INT_EN_GPIO_MASK_MSB,\n\t[STMPE_IDX_ISGPIOR_MSB]\t= STMPE1601_REG_INT_STA_GPIO_MSB,\n};\n\nstatic struct stmpe_variant_block stmpe1601_blocks[] = {\n\t{\n\t\t.cell\t= &stmpe_gpio_cell,\n\t\t.irq\t= STMPE1601_IRQ_GPIOC,\n\t\t.block\t= STMPE_BLOCK_GPIO,\n\t},\n\t{\n\t\t.cell\t= &stmpe_keypad_cell,\n\t\t.irq\t= STMPE1601_IRQ_KEYPAD,\n\t\t.block\t= STMPE_BLOCK_KEYPAD,\n\t},\n\t{\n\t\t.cell\t= &stmpe_pwm_cell,\n\t\t.irq\t= STMPE1601_IRQ_PWM0,\n\t\t.block\t= STMPE_BLOCK_PWM,\n\t},\n};\n\n \nstatic const int stmpe_autosleep_delay[] = {\n\t4, 16, 32, 64, 128, 256, 512, 1024,\n};\n\nstatic int stmpe_round_timeout(int timeout)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(stmpe_autosleep_delay); i++) {\n\t\tif (stmpe_autosleep_delay[i] >= timeout)\n\t\t\treturn i;\n\t}\n\n\t \n\treturn -EINVAL;\n}\n\nstatic int stmpe_autosleep(struct stmpe *stmpe, int autosleep_timeout)\n{\n\tint ret;\n\n\tif (!stmpe->variant->enable_autosleep)\n\t\treturn -ENOSYS;\n\n\tmutex_lock(&stmpe->lock);\n\tret = stmpe->variant->enable_autosleep(stmpe, autosleep_timeout);\n\tmutex_unlock(&stmpe->lock);\n\n\treturn ret;\n}\n\n \nstatic int stmpe1601_autosleep(struct stmpe *stmpe,\n\t\tint autosleep_timeout)\n{\n\tint ret, timeout;\n\n\t \n\ttimeout = stmpe_round_timeout(autosleep_timeout);\n\tif (timeout < 0) {\n\t\tdev_err(stmpe->dev, \"invalid timeout\\n\");\n\t\treturn timeout;\n\t}\n\n\tret = __stmpe_set_bits(stmpe, stmpe->regs[STMPE_IDX_SYS_CTRL2],\n\t\t\tSTMPE1601_AUTOSLEEP_TIMEOUT_MASK,\n\t\t\ttimeout);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn __stmpe_set_bits(stmpe, stmpe->regs[STMPE_IDX_SYS_CTRL2],\n\t\t\tSTPME1601_AUTOSLEEP_ENABLE,\n\t\t\tSTPME1601_AUTOSLEEP_ENABLE);\n}\n\nstatic int stmpe1601_enable(struct stmpe *stmpe, unsigned int blocks,\n\t\t\t    bool enable)\n{\n\tunsigned int mask = 0;\n\n\tif (blocks & STMPE_BLOCK_GPIO)\n\t\tmask |= STMPE1601_SYS_CTRL_ENABLE_GPIO;\n\telse\n\t\tmask &= ~STMPE1601_SYS_CTRL_ENABLE_GPIO;\n\n\tif (blocks & STMPE_BLOCK_KEYPAD)\n\t\tmask |= STMPE1601_SYS_CTRL_ENABLE_KPC;\n\telse\n\t\tmask &= ~STMPE1601_SYS_CTRL_ENABLE_KPC;\n\n\tif (blocks & STMPE_BLOCK_PWM)\n\t\tmask |= STMPE1601_SYS_CTRL_ENABLE_SPWM;\n\telse\n\t\tmask &= ~STMPE1601_SYS_CTRL_ENABLE_SPWM;\n\n\treturn __stmpe_set_bits(stmpe, stmpe->regs[STMPE_IDX_SYS_CTRL], mask,\n\t\t\t\tenable ? mask : 0);\n}\n\nstatic int stmpe1601_get_altfunc(struct stmpe *stmpe, enum stmpe_block block)\n{\n\tswitch (block) {\n\tcase STMPE_BLOCK_PWM:\n\t\treturn 2;\n\n\tcase STMPE_BLOCK_KEYPAD:\n\t\treturn 1;\n\n\tcase STMPE_BLOCK_GPIO:\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic struct stmpe_variant_info stmpe1601 = {\n\t.name\t\t= \"stmpe1601\",\n\t.id_val\t\t= 0x0210,\n\t.id_mask\t= 0xfff0,\t \n\t.num_gpios\t= 16,\n\t.af_bits\t= 2,\n\t.regs\t\t= stmpe1601_regs,\n\t.blocks\t\t= stmpe1601_blocks,\n\t.num_blocks\t= ARRAY_SIZE(stmpe1601_blocks),\n\t.num_irqs\t= STMPE1601_NR_INTERNAL_IRQS,\n\t.enable\t\t= stmpe1601_enable,\n\t.get_altfunc\t= stmpe1601_get_altfunc,\n\t.enable_autosleep\t= stmpe1601_autosleep,\n};\n\n \nstatic const u8 stmpe1801_regs[] = {\n\t[STMPE_IDX_CHIP_ID]\t= STMPE1801_REG_CHIP_ID,\n\t[STMPE_IDX_SYS_CTRL]\t= STMPE1801_REG_SYS_CTRL,\n\t[STMPE_IDX_ICR_LSB]\t= STMPE1801_REG_INT_CTRL_LOW,\n\t[STMPE_IDX_IER_LSB]\t= STMPE1801_REG_INT_EN_MASK_LOW,\n\t[STMPE_IDX_ISR_LSB]\t= STMPE1801_REG_INT_STA_LOW,\n\t[STMPE_IDX_GPMR_LSB]\t= STMPE1801_REG_GPIO_MP_LOW,\n\t[STMPE_IDX_GPMR_CSB]\t= STMPE1801_REG_GPIO_MP_MID,\n\t[STMPE_IDX_GPMR_MSB]\t= STMPE1801_REG_GPIO_MP_HIGH,\n\t[STMPE_IDX_GPSR_LSB]\t= STMPE1801_REG_GPIO_SET_LOW,\n\t[STMPE_IDX_GPSR_CSB]\t= STMPE1801_REG_GPIO_SET_MID,\n\t[STMPE_IDX_GPSR_MSB]\t= STMPE1801_REG_GPIO_SET_HIGH,\n\t[STMPE_IDX_GPCR_LSB]\t= STMPE1801_REG_GPIO_CLR_LOW,\n\t[STMPE_IDX_GPCR_CSB]\t= STMPE1801_REG_GPIO_CLR_MID,\n\t[STMPE_IDX_GPCR_MSB]\t= STMPE1801_REG_GPIO_CLR_HIGH,\n\t[STMPE_IDX_GPDR_LSB]\t= STMPE1801_REG_GPIO_SET_DIR_LOW,\n\t[STMPE_IDX_GPDR_CSB]\t= STMPE1801_REG_GPIO_SET_DIR_MID,\n\t[STMPE_IDX_GPDR_MSB]\t= STMPE1801_REG_GPIO_SET_DIR_HIGH,\n\t[STMPE_IDX_GPRER_LSB]\t= STMPE1801_REG_GPIO_RE_LOW,\n\t[STMPE_IDX_GPRER_CSB]\t= STMPE1801_REG_GPIO_RE_MID,\n\t[STMPE_IDX_GPRER_MSB]\t= STMPE1801_REG_GPIO_RE_HIGH,\n\t[STMPE_IDX_GPFER_LSB]\t= STMPE1801_REG_GPIO_FE_LOW,\n\t[STMPE_IDX_GPFER_CSB]\t= STMPE1801_REG_GPIO_FE_MID,\n\t[STMPE_IDX_GPFER_MSB]\t= STMPE1801_REG_GPIO_FE_HIGH,\n\t[STMPE_IDX_GPPUR_LSB]\t= STMPE1801_REG_GPIO_PULL_UP_LOW,\n\t[STMPE_IDX_IEGPIOR_LSB]\t= STMPE1801_REG_INT_EN_GPIO_MASK_LOW,\n\t[STMPE_IDX_IEGPIOR_CSB]\t= STMPE1801_REG_INT_EN_GPIO_MASK_MID,\n\t[STMPE_IDX_IEGPIOR_MSB]\t= STMPE1801_REG_INT_EN_GPIO_MASK_HIGH,\n\t[STMPE_IDX_ISGPIOR_MSB]\t= STMPE1801_REG_INT_STA_GPIO_HIGH,\n};\n\nstatic struct stmpe_variant_block stmpe1801_blocks[] = {\n\t{\n\t\t.cell\t= &stmpe_gpio_cell,\n\t\t.irq\t= STMPE1801_IRQ_GPIOC,\n\t\t.block\t= STMPE_BLOCK_GPIO,\n\t},\n\t{\n\t\t.cell\t= &stmpe_keypad_cell,\n\t\t.irq\t= STMPE1801_IRQ_KEYPAD,\n\t\t.block\t= STMPE_BLOCK_KEYPAD,\n\t},\n};\n\nstatic int stmpe1801_enable(struct stmpe *stmpe, unsigned int blocks,\n\t\t\t    bool enable)\n{\n\tunsigned int mask = 0;\n\tif (blocks & STMPE_BLOCK_GPIO)\n\t\tmask |= STMPE1801_MSK_INT_EN_GPIO;\n\n\tif (blocks & STMPE_BLOCK_KEYPAD)\n\t\tmask |= STMPE1801_MSK_INT_EN_KPC;\n\n\treturn __stmpe_set_bits(stmpe, STMPE1801_REG_INT_EN_MASK_LOW, mask,\n\t\t\t\tenable ? mask : 0);\n}\n\nstatic int stmpe_reset(struct stmpe *stmpe)\n{\n\tu16 id_val = stmpe->variant->id_val;\n\tunsigned long timeout;\n\tint ret = 0;\n\tu8 reset_bit;\n\n\tif (id_val == STMPE811_ID)\n\t\t \n\t\treset_bit = STMPE811_SYS_CTRL_RESET;\n\telse\n\t\t \n\t\treset_bit = STMPE_SYS_CTRL_RESET;\n\n\tret = __stmpe_set_bits(stmpe, stmpe->regs[STMPE_IDX_SYS_CTRL],\n\t\t\t       reset_bit, reset_bit);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmsleep(10);\n\n\ttimeout = jiffies + msecs_to_jiffies(100);\n\twhile (time_before(jiffies, timeout)) {\n\t\tret = __stmpe_reg_read(stmpe, stmpe->regs[STMPE_IDX_SYS_CTRL]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (!(ret & reset_bit))\n\t\t\treturn 0;\n\t\tusleep_range(100, 200);\n\t}\n\treturn -EIO;\n}\n\nstatic struct stmpe_variant_info stmpe1801 = {\n\t.name\t\t= \"stmpe1801\",\n\t.id_val\t\t= STMPE1801_ID,\n\t.id_mask\t= 0xfff0,\n\t.num_gpios\t= 18,\n\t.af_bits\t= 0,\n\t.regs\t\t= stmpe1801_regs,\n\t.blocks\t\t= stmpe1801_blocks,\n\t.num_blocks\t= ARRAY_SIZE(stmpe1801_blocks),\n\t.num_irqs\t= STMPE1801_NR_INTERNAL_IRQS,\n\t.enable\t\t= stmpe1801_enable,\n\t \n\t.get_altfunc\t= NULL,\n};\n\n \n\nstatic const u8 stmpe24xx_regs[] = {\n\t[STMPE_IDX_CHIP_ID]\t= STMPE24XX_REG_CHIP_ID,\n\t[STMPE_IDX_SYS_CTRL]\t= STMPE24XX_REG_SYS_CTRL,\n\t[STMPE_IDX_SYS_CTRL2]\t= STMPE24XX_REG_SYS_CTRL2,\n\t[STMPE_IDX_ICR_LSB]\t= STMPE24XX_REG_ICR_LSB,\n\t[STMPE_IDX_IER_MSB]\t= STMPE24XX_REG_IER_MSB,\n\t[STMPE_IDX_IER_LSB]\t= STMPE24XX_REG_IER_LSB,\n\t[STMPE_IDX_ISR_MSB]\t= STMPE24XX_REG_ISR_MSB,\n\t[STMPE_IDX_GPMR_LSB]\t= STMPE24XX_REG_GPMR_LSB,\n\t[STMPE_IDX_GPMR_CSB]\t= STMPE24XX_REG_GPMR_CSB,\n\t[STMPE_IDX_GPMR_MSB]\t= STMPE24XX_REG_GPMR_MSB,\n\t[STMPE_IDX_GPSR_LSB]\t= STMPE24XX_REG_GPSR_LSB,\n\t[STMPE_IDX_GPSR_CSB]\t= STMPE24XX_REG_GPSR_CSB,\n\t[STMPE_IDX_GPSR_MSB]\t= STMPE24XX_REG_GPSR_MSB,\n\t[STMPE_IDX_GPCR_LSB]\t= STMPE24XX_REG_GPCR_LSB,\n\t[STMPE_IDX_GPCR_CSB]\t= STMPE24XX_REG_GPCR_CSB,\n\t[STMPE_IDX_GPCR_MSB]\t= STMPE24XX_REG_GPCR_MSB,\n\t[STMPE_IDX_GPDR_LSB]\t= STMPE24XX_REG_GPDR_LSB,\n\t[STMPE_IDX_GPDR_CSB]\t= STMPE24XX_REG_GPDR_CSB,\n\t[STMPE_IDX_GPDR_MSB]\t= STMPE24XX_REG_GPDR_MSB,\n\t[STMPE_IDX_GPRER_LSB]\t= STMPE24XX_REG_GPRER_LSB,\n\t[STMPE_IDX_GPRER_CSB]\t= STMPE24XX_REG_GPRER_CSB,\n\t[STMPE_IDX_GPRER_MSB]\t= STMPE24XX_REG_GPRER_MSB,\n\t[STMPE_IDX_GPFER_LSB]\t= STMPE24XX_REG_GPFER_LSB,\n\t[STMPE_IDX_GPFER_CSB]\t= STMPE24XX_REG_GPFER_CSB,\n\t[STMPE_IDX_GPFER_MSB]\t= STMPE24XX_REG_GPFER_MSB,\n\t[STMPE_IDX_GPPUR_LSB]\t= STMPE24XX_REG_GPPUR_LSB,\n\t[STMPE_IDX_GPPDR_LSB]\t= STMPE24XX_REG_GPPDR_LSB,\n\t[STMPE_IDX_GPAFR_U_MSB]\t= STMPE24XX_REG_GPAFR_U_MSB,\n\t[STMPE_IDX_IEGPIOR_LSB]\t= STMPE24XX_REG_IEGPIOR_LSB,\n\t[STMPE_IDX_IEGPIOR_CSB]\t= STMPE24XX_REG_IEGPIOR_CSB,\n\t[STMPE_IDX_IEGPIOR_MSB]\t= STMPE24XX_REG_IEGPIOR_MSB,\n\t[STMPE_IDX_ISGPIOR_MSB]\t= STMPE24XX_REG_ISGPIOR_MSB,\n\t[STMPE_IDX_GPEDR_LSB]\t= STMPE24XX_REG_GPEDR_LSB,\n\t[STMPE_IDX_GPEDR_CSB]\t= STMPE24XX_REG_GPEDR_CSB,\n\t[STMPE_IDX_GPEDR_MSB]\t= STMPE24XX_REG_GPEDR_MSB,\n};\n\nstatic struct stmpe_variant_block stmpe24xx_blocks[] = {\n\t{\n\t\t.cell\t= &stmpe_gpio_cell,\n\t\t.irq\t= STMPE24XX_IRQ_GPIOC,\n\t\t.block\t= STMPE_BLOCK_GPIO,\n\t},\n\t{\n\t\t.cell\t= &stmpe_keypad_cell,\n\t\t.irq\t= STMPE24XX_IRQ_KEYPAD,\n\t\t.block\t= STMPE_BLOCK_KEYPAD,\n\t},\n\t{\n\t\t.cell\t= &stmpe_pwm_cell,\n\t\t.irq\t= STMPE24XX_IRQ_PWM0,\n\t\t.block\t= STMPE_BLOCK_PWM,\n\t},\n};\n\nstatic int stmpe24xx_enable(struct stmpe *stmpe, unsigned int blocks,\n\t\t\t    bool enable)\n{\n\tunsigned int mask = 0;\n\n\tif (blocks & STMPE_BLOCK_GPIO)\n\t\tmask |= STMPE24XX_SYS_CTRL_ENABLE_GPIO;\n\n\tif (blocks & STMPE_BLOCK_KEYPAD)\n\t\tmask |= STMPE24XX_SYS_CTRL_ENABLE_KPC;\n\n\treturn __stmpe_set_bits(stmpe, stmpe->regs[STMPE_IDX_SYS_CTRL], mask,\n\t\t\t\tenable ? mask : 0);\n}\n\nstatic int stmpe24xx_get_altfunc(struct stmpe *stmpe, enum stmpe_block block)\n{\n\tswitch (block) {\n\tcase STMPE_BLOCK_ROTATOR:\n\t\treturn 2;\n\n\tcase STMPE_BLOCK_KEYPAD:\n\tcase STMPE_BLOCK_PWM:\n\t\treturn 1;\n\n\tcase STMPE_BLOCK_GPIO:\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic struct stmpe_variant_info stmpe2401 = {\n\t.name\t\t= \"stmpe2401\",\n\t.id_val\t\t= 0x0101,\n\t.id_mask\t= 0xffff,\n\t.num_gpios\t= 24,\n\t.af_bits\t= 2,\n\t.regs\t\t= stmpe24xx_regs,\n\t.blocks\t\t= stmpe24xx_blocks,\n\t.num_blocks\t= ARRAY_SIZE(stmpe24xx_blocks),\n\t.num_irqs\t= STMPE24XX_NR_INTERNAL_IRQS,\n\t.enable\t\t= stmpe24xx_enable,\n\t.get_altfunc\t= stmpe24xx_get_altfunc,\n};\n\nstatic struct stmpe_variant_info stmpe2403 = {\n\t.name\t\t= \"stmpe2403\",\n\t.id_val\t\t= 0x0120,\n\t.id_mask\t= 0xffff,\n\t.num_gpios\t= 24,\n\t.af_bits\t= 2,\n\t.regs\t\t= stmpe24xx_regs,\n\t.blocks\t\t= stmpe24xx_blocks,\n\t.num_blocks\t= ARRAY_SIZE(stmpe24xx_blocks),\n\t.num_irqs\t= STMPE24XX_NR_INTERNAL_IRQS,\n\t.enable\t\t= stmpe24xx_enable,\n\t.get_altfunc\t= stmpe24xx_get_altfunc,\n\t.enable_autosleep\t= stmpe1601_autosleep,  \n};\n\nstatic struct stmpe_variant_info *stmpe_variant_info[STMPE_NBR_PARTS] = {\n\t[STMPE610]\t= &stmpe610,\n\t[STMPE801]\t= &stmpe801,\n\t[STMPE811]\t= &stmpe811,\n\t[STMPE1600]\t= &stmpe1600,\n\t[STMPE1601]\t= &stmpe1601,\n\t[STMPE1801]\t= &stmpe1801,\n\t[STMPE2401]\t= &stmpe2401,\n\t[STMPE2403]\t= &stmpe2403,\n};\n\n \nstatic struct stmpe_variant_info *stmpe_noirq_variant_info[STMPE_NBR_PARTS] = {\n\t[STMPE801]\t= &stmpe801_noirq,\n};\n\nstatic irqreturn_t stmpe_irq(int irq, void *data)\n{\n\tstruct stmpe *stmpe = data;\n\tstruct stmpe_variant_info *variant = stmpe->variant;\n\tint num = DIV_ROUND_UP(variant->num_irqs, 8);\n\tu8 israddr;\n\tu8 isr[3];\n\tint ret;\n\tint i;\n\n\tif (variant->id_val == STMPE801_ID ||\n\t    variant->id_val == STMPE1600_ID) {\n\t\tint base = irq_find_mapping(stmpe->domain, 0);\n\n\t\thandle_nested_irq(base);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (variant->id_val == STMPE1801_ID)\n\t\tisraddr = stmpe->regs[STMPE_IDX_ISR_LSB];\n\telse\n\t\tisraddr = stmpe->regs[STMPE_IDX_ISR_MSB];\n\n\tret = stmpe_block_read(stmpe, israddr, num, isr);\n\tif (ret < 0)\n\t\treturn IRQ_NONE;\n\n\tfor (i = 0; i < num; i++) {\n\t\tint bank = num - i - 1;\n\t\tu8 status = isr[i];\n\t\tu8 clear;\n\n\t\tstatus &= stmpe->ier[bank];\n\t\tif (!status)\n\t\t\tcontinue;\n\n\t\tclear = status;\n\t\twhile (status) {\n\t\t\tint bit = __ffs(status);\n\t\t\tint line = bank * 8 + bit;\n\t\t\tint nestedirq = irq_find_mapping(stmpe->domain, line);\n\n\t\t\thandle_nested_irq(nestedirq);\n\t\t\tstatus &= ~(1 << bit);\n\t\t}\n\n\t\tstmpe_reg_write(stmpe, israddr + i, clear);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void stmpe_irq_lock(struct irq_data *data)\n{\n\tstruct stmpe *stmpe = irq_data_get_irq_chip_data(data);\n\n\tmutex_lock(&stmpe->irq_lock);\n}\n\nstatic void stmpe_irq_sync_unlock(struct irq_data *data)\n{\n\tstruct stmpe *stmpe = irq_data_get_irq_chip_data(data);\n\tstruct stmpe_variant_info *variant = stmpe->variant;\n\tint num = DIV_ROUND_UP(variant->num_irqs, 8);\n\tint i;\n\n\tfor (i = 0; i < num; i++) {\n\t\tu8 new = stmpe->ier[i];\n\t\tu8 old = stmpe->oldier[i];\n\n\t\tif (new == old)\n\t\t\tcontinue;\n\n\t\tstmpe->oldier[i] = new;\n\t\tstmpe_reg_write(stmpe, stmpe->regs[STMPE_IDX_IER_LSB + i], new);\n\t}\n\n\tmutex_unlock(&stmpe->irq_lock);\n}\n\nstatic void stmpe_irq_mask(struct irq_data *data)\n{\n\tstruct stmpe *stmpe = irq_data_get_irq_chip_data(data);\n\tint offset = data->hwirq;\n\tint regoffset = offset / 8;\n\tint mask = 1 << (offset % 8);\n\n\tstmpe->ier[regoffset] &= ~mask;\n}\n\nstatic void stmpe_irq_unmask(struct irq_data *data)\n{\n\tstruct stmpe *stmpe = irq_data_get_irq_chip_data(data);\n\tint offset = data->hwirq;\n\tint regoffset = offset / 8;\n\tint mask = 1 << (offset % 8);\n\n\tstmpe->ier[regoffset] |= mask;\n}\n\nstatic struct irq_chip stmpe_irq_chip = {\n\t.name\t\t\t= \"stmpe\",\n\t.irq_bus_lock\t\t= stmpe_irq_lock,\n\t.irq_bus_sync_unlock\t= stmpe_irq_sync_unlock,\n\t.irq_mask\t\t= stmpe_irq_mask,\n\t.irq_unmask\t\t= stmpe_irq_unmask,\n};\n\nstatic int stmpe_irq_map(struct irq_domain *d, unsigned int virq,\n                                irq_hw_number_t hwirq)\n{\n\tstruct stmpe *stmpe = d->host_data;\n\tstruct irq_chip *chip = NULL;\n\n\tif (stmpe->variant->id_val != STMPE801_ID)\n\t\tchip = &stmpe_irq_chip;\n\n\tirq_set_chip_data(virq, stmpe);\n\tirq_set_chip_and_handler(virq, chip, handle_edge_irq);\n\tirq_set_nested_thread(virq, 1);\n\tirq_set_noprobe(virq);\n\n\treturn 0;\n}\n\nstatic void stmpe_irq_unmap(struct irq_domain *d, unsigned int virq)\n{\n\t\tirq_set_chip_and_handler(virq, NULL, NULL);\n\t\tirq_set_chip_data(virq, NULL);\n}\n\nstatic const struct irq_domain_ops stmpe_irq_ops = {\n        .map    = stmpe_irq_map,\n        .unmap  = stmpe_irq_unmap,\n        .xlate  = irq_domain_xlate_twocell,\n};\n\nstatic int stmpe_irq_init(struct stmpe *stmpe, struct device_node *np)\n{\n\tint base = 0;\n\tint num_irqs = stmpe->variant->num_irqs;\n\n\tstmpe->domain = irq_domain_add_simple(np, num_irqs, base,\n\t\t\t\t\t      &stmpe_irq_ops, stmpe);\n\tif (!stmpe->domain) {\n\t\tdev_err(stmpe->dev, \"Failed to create irqdomain\\n\");\n\t\treturn -ENOSYS;\n\t}\n\n\treturn 0;\n}\n\nstatic int stmpe_chip_init(struct stmpe *stmpe)\n{\n\tunsigned int irq_trigger = stmpe->pdata->irq_trigger;\n\tint autosleep_timeout = stmpe->pdata->autosleep_timeout;\n\tstruct stmpe_variant_info *variant = stmpe->variant;\n\tu8 icr = 0;\n\tunsigned int id;\n\tu8 data[2];\n\tint ret;\n\n\tret = stmpe_block_read(stmpe, stmpe->regs[STMPE_IDX_CHIP_ID],\n\t\t\t       ARRAY_SIZE(data), data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tid = (data[0] << 8) | data[1];\n\tif ((id & variant->id_mask) != variant->id_val) {\n\t\tdev_err(stmpe->dev, \"unknown chip id: %#x\\n\", id);\n\t\treturn -EINVAL;\n\t}\n\n\tdev_info(stmpe->dev, \"%s detected, chip id: %#x\\n\", variant->name, id);\n\n\t \n\tret = stmpe_disable(stmpe, ~0);\n\tif (ret)\n\t\treturn ret;\n\n\tret =  stmpe_reset(stmpe);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (stmpe->irq >= 0) {\n\t\tif (id == STMPE801_ID || id == STMPE1600_ID)\n\t\t\ticr = STMPE_SYS_CTRL_INT_EN;\n\t\telse\n\t\t\ticr = STMPE_ICR_LSB_GIM;\n\n\t\t \n\t\tif (id != STMPE801_ID && id != STMPE1600_ID) {\n\t\t\tif (irq_trigger == IRQF_TRIGGER_FALLING ||\n\t\t\t\t\tirq_trigger == IRQF_TRIGGER_RISING)\n\t\t\t\ticr |= STMPE_ICR_LSB_EDGE;\n\t\t}\n\n\t\tif (irq_trigger == IRQF_TRIGGER_RISING ||\n\t\t\t\tirq_trigger == IRQF_TRIGGER_HIGH) {\n\t\t\tif (id == STMPE801_ID || id == STMPE1600_ID)\n\t\t\t\ticr |= STMPE_SYS_CTRL_INT_HI;\n\t\t\telse\n\t\t\t\ticr |= STMPE_ICR_LSB_HIGH;\n\t\t}\n\t}\n\n\tif (stmpe->pdata->autosleep) {\n\t\tret = stmpe_autosleep(stmpe, autosleep_timeout);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn stmpe_reg_write(stmpe, stmpe->regs[STMPE_IDX_ICR_LSB], icr);\n}\n\nstatic int stmpe_add_device(struct stmpe *stmpe, const struct mfd_cell *cell)\n{\n\treturn mfd_add_devices(stmpe->dev, stmpe->pdata->id, cell, 1,\n\t\t\t       NULL, 0, stmpe->domain);\n}\n\nstatic int stmpe_devices_init(struct stmpe *stmpe)\n{\n\tstruct stmpe_variant_info *variant = stmpe->variant;\n\tunsigned int platform_blocks = stmpe->pdata->blocks;\n\tint ret = -EINVAL;\n\tint i, j;\n\n\tfor (i = 0; i < variant->num_blocks; i++) {\n\t\tstruct stmpe_variant_block *block = &variant->blocks[i];\n\n\t\tif (!(platform_blocks & block->block))\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < block->cell->num_resources; j++) {\n\t\t\tstruct resource *res =\n\t\t\t\t(struct resource *) &block->cell->resources[j];\n\n\t\t\t \n\t\t\tif (res->flags & IORESOURCE_IRQ)\n\t\t\t\tres->start = res->end = block->irq + j;\n\t\t}\n\n\t\tplatform_blocks &= ~block->block;\n\t\tret = stmpe_add_device(stmpe, block->cell);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (platform_blocks)\n\t\tdev_warn(stmpe->dev,\n\t\t\t \"platform wants blocks (%#x) not present on variant\",\n\t\t\t platform_blocks);\n\n\treturn ret;\n}\n\nstatic void stmpe_of_probe(struct stmpe_platform_data *pdata,\n\t\t\t   struct device_node *np)\n{\n\tstruct device_node *child;\n\n\tpdata->id = of_alias_get_id(np, \"stmpe-i2c\");\n\tif (pdata->id < 0)\n\t\tpdata->id = -1;\n\n\tof_property_read_u32(np, \"st,autosleep-timeout\",\n\t\t\t&pdata->autosleep_timeout);\n\n\tpdata->autosleep = (pdata->autosleep_timeout) ? true : false;\n\n\tfor_each_available_child_of_node(np, child) {\n\t\tif (of_device_is_compatible(child, stmpe_gpio_cell.of_compatible))\n\t\t\tpdata->blocks |= STMPE_BLOCK_GPIO;\n\t\telse if (of_device_is_compatible(child, stmpe_keypad_cell.of_compatible))\n\t\t\tpdata->blocks |= STMPE_BLOCK_KEYPAD;\n\t\telse if (of_device_is_compatible(child, stmpe_ts_cell.of_compatible))\n\t\t\tpdata->blocks |= STMPE_BLOCK_TOUCHSCREEN;\n\t\telse if (of_device_is_compatible(child, stmpe_adc_cell.of_compatible))\n\t\t\tpdata->blocks |= STMPE_BLOCK_ADC;\n\t\telse if (of_device_is_compatible(child, stmpe_pwm_cell.of_compatible))\n\t\t\tpdata->blocks |= STMPE_BLOCK_PWM;\n\t}\n}\n\n \nint stmpe_probe(struct stmpe_client_info *ci, enum stmpe_partnum partnum)\n{\n\tstruct stmpe_platform_data *pdata;\n\tstruct device_node *np = ci->dev->of_node;\n\tstruct stmpe *stmpe;\n\tstruct gpio_desc *irq_gpio;\n\tint ret;\n\tu32 val;\n\n\tpdata = devm_kzalloc(ci->dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn -ENOMEM;\n\n\tstmpe_of_probe(pdata, np);\n\n\tif (!of_property_present(np, \"interrupts\"))\n\t\tci->irq = -1;\n\n\tstmpe = devm_kzalloc(ci->dev, sizeof(struct stmpe), GFP_KERNEL);\n\tif (!stmpe)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&stmpe->irq_lock);\n\tmutex_init(&stmpe->lock);\n\n\tif (!of_property_read_u32(np, \"st,sample-time\", &val))\n\t\tstmpe->sample_time = val;\n\tif (!of_property_read_u32(np, \"st,mod-12b\", &val))\n\t\tstmpe->mod_12b = val;\n\tif (!of_property_read_u32(np, \"st,ref-sel\", &val))\n\t\tstmpe->ref_sel = val;\n\tif (!of_property_read_u32(np, \"st,adc-freq\", &val))\n\t\tstmpe->adc_freq = val;\n\n\tstmpe->dev = ci->dev;\n\tstmpe->client = ci->client;\n\tstmpe->pdata = pdata;\n\tstmpe->ci = ci;\n\tstmpe->partnum = partnum;\n\tstmpe->variant = stmpe_variant_info[partnum];\n\tstmpe->regs = stmpe->variant->regs;\n\tstmpe->num_gpios = stmpe->variant->num_gpios;\n\tstmpe->vcc = devm_regulator_get_optional(ci->dev, \"vcc\");\n\tif (!IS_ERR(stmpe->vcc)) {\n\t\tret = regulator_enable(stmpe->vcc);\n\t\tif (ret)\n\t\t\tdev_warn(ci->dev, \"failed to enable VCC supply\\n\");\n\t}\n\tstmpe->vio = devm_regulator_get_optional(ci->dev, \"vio\");\n\tif (!IS_ERR(stmpe->vio)) {\n\t\tret = regulator_enable(stmpe->vio);\n\t\tif (ret)\n\t\t\tdev_warn(ci->dev, \"failed to enable VIO supply\\n\");\n\t}\n\tdev_set_drvdata(stmpe->dev, stmpe);\n\n\tif (ci->init)\n\t\tci->init(stmpe);\n\n\tirq_gpio = devm_gpiod_get_optional(ci->dev, \"irq\", GPIOD_ASIS);\n\tret = PTR_ERR_OR_ZERO(irq_gpio);\n\tif (ret) {\n\t\tdev_err(stmpe->dev, \"failed to request IRQ GPIO: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (irq_gpio) {\n\t\tstmpe->irq = gpiod_to_irq(irq_gpio);\n\t\tpdata->irq_trigger = gpiod_is_active_low(irq_gpio) ?\n\t\t\t\t\tIRQF_TRIGGER_LOW : IRQF_TRIGGER_HIGH;\n\t} else {\n\t\tstmpe->irq = ci->irq;\n\t\tpdata->irq_trigger = IRQF_TRIGGER_NONE;\n\t}\n\n\tif (stmpe->irq < 0) {\n\t\t \n\t\tdev_info(stmpe->dev,\n\t\t\t\"%s configured in no-irq mode by platform data\\n\",\n\t\t\tstmpe->variant->name);\n\t\tif (!stmpe_noirq_variant_info[stmpe->partnum]) {\n\t\t\tdev_err(stmpe->dev,\n\t\t\t\t\"%s does not support no-irq mode!\\n\",\n\t\t\t\tstmpe->variant->name);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tstmpe->variant = stmpe_noirq_variant_info[stmpe->partnum];\n\t} else if (pdata->irq_trigger == IRQF_TRIGGER_NONE) {\n\t\tpdata->irq_trigger = irq_get_trigger_type(stmpe->irq);\n\t}\n\n\tret = stmpe_chip_init(stmpe);\n\tif (ret)\n\t\treturn ret;\n\n\tif (stmpe->irq >= 0) {\n\t\tret = stmpe_irq_init(stmpe, np);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = devm_request_threaded_irq(ci->dev, stmpe->irq, NULL,\n\t\t\t\tstmpe_irq, pdata->irq_trigger | IRQF_ONESHOT,\n\t\t\t\t\"stmpe\", stmpe);\n\t\tif (ret) {\n\t\t\tdev_err(stmpe->dev, \"failed to request IRQ: %d\\n\",\n\t\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = stmpe_devices_init(stmpe);\n\tif (!ret)\n\t\treturn 0;\n\n\tdev_err(stmpe->dev, \"failed to add children\\n\");\n\tmfd_remove_devices(stmpe->dev);\n\n\treturn ret;\n}\n\nvoid stmpe_remove(struct stmpe *stmpe)\n{\n\tif (!IS_ERR(stmpe->vio) && regulator_is_enabled(stmpe->vio))\n\t\tregulator_disable(stmpe->vio);\n\tif (!IS_ERR(stmpe->vcc) && regulator_is_enabled(stmpe->vcc))\n\t\tregulator_disable(stmpe->vcc);\n\n\t__stmpe_disable(stmpe, STMPE_BLOCK_ADC);\n\n\tmfd_remove_devices(stmpe->dev);\n}\n\nstatic int stmpe_suspend(struct device *dev)\n{\n\tstruct stmpe *stmpe = dev_get_drvdata(dev);\n\n\tif (stmpe->irq >= 0 && device_may_wakeup(dev))\n\t\tenable_irq_wake(stmpe->irq);\n\n\treturn 0;\n}\n\nstatic int stmpe_resume(struct device *dev)\n{\n\tstruct stmpe *stmpe = dev_get_drvdata(dev);\n\n\tif (stmpe->irq >= 0 && device_may_wakeup(dev))\n\t\tdisable_irq_wake(stmpe->irq);\n\n\treturn 0;\n}\n\nEXPORT_GPL_SIMPLE_DEV_PM_OPS(stmpe_dev_pm_ops,\n\t\t\t     stmpe_suspend, stmpe_resume);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}