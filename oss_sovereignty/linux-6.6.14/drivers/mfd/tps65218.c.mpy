{
  "module_name": "tps65218.c",
  "hash_id": "3f1e159272435ad7b1fdafb8a9d13f56c9daecced3bce823e3cf81b23ae65ccc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/tps65218.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/init.h>\n#include <linux/i2c.h>\n#include <linux/slab.h>\n#include <linux/regmap.h>\n#include <linux/err.h>\n#include <linux/of.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/mutex.h>\n\n#include <linux/mfd/core.h>\n#include <linux/mfd/tps65218.h>\n\n#define TPS65218_PASSWORD_REGS_UNLOCK   0x7D\n\nstatic const struct mfd_cell tps65218_cells[] = {\n\t{\n\t\t.name = \"tps65218-pwrbutton\",\n\t\t.of_compatible = \"ti,tps65218-pwrbutton\",\n\t},\n\t{\n\t\t.name = \"tps65218-gpio\",\n\t\t.of_compatible = \"ti,tps65218-gpio\",\n\t},\n\t{ .name = \"tps65218-regulator\", },\n};\n\n \nint tps65218_reg_write(struct tps65218 *tps, unsigned int reg,\n\t\t\tunsigned int val, unsigned int level)\n{\n\tint ret;\n\tunsigned int xor_reg_val;\n\n\tswitch (level) {\n\tcase TPS65218_PROTECT_NONE:\n\t\treturn regmap_write(tps->regmap, reg, val);\n\tcase TPS65218_PROTECT_L1:\n\t\txor_reg_val = reg ^ TPS65218_PASSWORD_REGS_UNLOCK;\n\t\tret = regmap_write(tps->regmap, TPS65218_REG_PASSWORD,\n\t\t\t\t\t\t\txor_reg_val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\treturn regmap_write(tps->regmap, reg, val);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\nEXPORT_SYMBOL_GPL(tps65218_reg_write);\n\n \nstatic int tps65218_update_bits(struct tps65218 *tps, unsigned int reg,\n\t\tunsigned int mask, unsigned int val, unsigned int level)\n{\n\tint ret;\n\tunsigned int data;\n\n\tret = regmap_read(tps->regmap, reg, &data);\n\tif (ret) {\n\t\tdev_err(tps->dev, \"Read from reg 0x%x failed\\n\", reg);\n\t\treturn ret;\n\t}\n\n\tdata &= ~mask;\n\tdata |= val & mask;\n\n\tmutex_lock(&tps->tps_lock);\n\tret = tps65218_reg_write(tps, reg, data, level);\n\tif (ret)\n\t\tdev_err(tps->dev, \"Write for reg 0x%x failed\\n\", reg);\n\tmutex_unlock(&tps->tps_lock);\n\n\treturn ret;\n}\n\nint tps65218_set_bits(struct tps65218 *tps, unsigned int reg,\n\t\tunsigned int mask, unsigned int val, unsigned int level)\n{\n\treturn tps65218_update_bits(tps, reg, mask, val, level);\n}\nEXPORT_SYMBOL_GPL(tps65218_set_bits);\n\nint tps65218_clear_bits(struct tps65218 *tps, unsigned int reg,\n\t\tunsigned int mask, unsigned int level)\n{\n\treturn tps65218_update_bits(tps, reg, mask, 0, level);\n}\nEXPORT_SYMBOL_GPL(tps65218_clear_bits);\n\nstatic const struct regmap_range tps65218_yes_ranges[] = {\n\tregmap_reg_range(TPS65218_REG_INT1, TPS65218_REG_INT2),\n\tregmap_reg_range(TPS65218_REG_STATUS, TPS65218_REG_STATUS),\n};\n\nstatic const struct regmap_access_table tps65218_volatile_table = {\n\t.yes_ranges = tps65218_yes_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(tps65218_yes_ranges),\n};\n\nstatic const struct regmap_config tps65218_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.cache_type = REGCACHE_RBTREE,\n\t.volatile_table = &tps65218_volatile_table,\n};\n\nstatic const struct regmap_irq tps65218_irqs[] = {\n\t \n\t[TPS65218_PRGC_IRQ] = {\n\t\t.mask = TPS65218_INT1_PRGC,\n\t},\n\t[TPS65218_CC_AQC_IRQ] = {\n\t\t.mask = TPS65218_INT1_CC_AQC,\n\t},\n\t[TPS65218_HOT_IRQ] = {\n\t\t.mask = TPS65218_INT1_HOT,\n\t},\n\t[TPS65218_PB_IRQ] = {\n\t\t.mask = TPS65218_INT1_PB,\n\t},\n\t[TPS65218_AC_IRQ] = {\n\t\t.mask = TPS65218_INT1_AC,\n\t},\n\t[TPS65218_VPRG_IRQ] = {\n\t\t.mask = TPS65218_INT1_VPRG,\n\t},\n\t[TPS65218_INVALID1_IRQ] = {\n\t},\n\t[TPS65218_INVALID2_IRQ] = {\n\t},\n\t \n\t[TPS65218_LS1_I_IRQ] = {\n\t\t.mask = TPS65218_INT2_LS1_I,\n\t\t.reg_offset = 1,\n\t},\n\t[TPS65218_LS2_I_IRQ] = {\n\t\t.mask = TPS65218_INT2_LS2_I,\n\t\t.reg_offset = 1,\n\t},\n\t[TPS65218_LS3_I_IRQ] = {\n\t\t.mask = TPS65218_INT2_LS3_I,\n\t\t.reg_offset = 1,\n\t},\n\t[TPS65218_LS1_F_IRQ] = {\n\t\t.mask = TPS65218_INT2_LS1_F,\n\t\t.reg_offset = 1,\n\t},\n\t[TPS65218_LS2_F_IRQ] = {\n\t\t.mask = TPS65218_INT2_LS2_F,\n\t\t.reg_offset = 1,\n\t},\n\t[TPS65218_LS3_F_IRQ] = {\n\t\t.mask = TPS65218_INT2_LS3_F,\n\t\t.reg_offset = 1,\n\t},\n\t[TPS65218_INVALID3_IRQ] = {\n\t},\n\t[TPS65218_INVALID4_IRQ] = {\n\t},\n};\n\nstatic struct regmap_irq_chip tps65218_irq_chip = {\n\t.name = \"tps65218\",\n\t.irqs = tps65218_irqs,\n\t.num_irqs = ARRAY_SIZE(tps65218_irqs),\n\n\t.num_regs = 2,\n\t.mask_base = TPS65218_REG_INT_MASK1,\n\t.status_base = TPS65218_REG_INT1,\n};\n\nstatic const struct of_device_id of_tps65218_match_table[] = {\n\t{ .compatible = \"ti,tps65218\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, of_tps65218_match_table);\n\nstatic int tps65218_voltage_set_strict(struct tps65218 *tps)\n{\n\tu32 strict;\n\n\tif (of_property_read_u32(tps->dev->of_node,\n\t\t\t\t \"ti,strict-supply-voltage-supervision\",\n\t\t\t\t &strict))\n\t\treturn 0;\n\n\tif (strict != 0 && strict != 1) {\n\t\tdev_err(tps->dev,\n\t\t\t\"Invalid ti,strict-supply-voltage-supervision value\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttps65218_update_bits(tps, TPS65218_REG_CONFIG1,\n\t\t\t     TPS65218_CONFIG1_STRICT,\n\t\t\t     strict ? TPS65218_CONFIG1_STRICT : 0,\n\t\t\t     TPS65218_PROTECT_L1);\n\treturn 0;\n}\n\nstatic int tps65218_voltage_set_uv_hyst(struct tps65218 *tps)\n{\n\tu32 hyst;\n\n\tif (of_property_read_u32(tps->dev->of_node,\n\t\t\t\t \"ti,under-voltage-hyst-microvolt\", &hyst))\n\t\treturn 0;\n\n\tif (hyst != 400000 && hyst != 200000) {\n\t\tdev_err(tps->dev,\n\t\t\t\"Invalid ti,under-voltage-hyst-microvolt value\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttps65218_update_bits(tps, TPS65218_REG_CONFIG2,\n\t\t\t     TPS65218_CONFIG2_UVLOHYS,\n\t\t\t     hyst == 400000 ? TPS65218_CONFIG2_UVLOHYS : 0,\n\t\t\t     TPS65218_PROTECT_L1);\n\treturn 0;\n}\n\nstatic int tps65218_voltage_set_uvlo(struct tps65218 *tps)\n{\n\tu32 uvlo;\n\tint uvloval;\n\n\tif (of_property_read_u32(tps->dev->of_node,\n\t\t\t\t \"ti,under-voltage-limit-microvolt\", &uvlo))\n\t\treturn 0;\n\n\tswitch (uvlo) {\n\tcase 2750000:\n\t\tuvloval = TPS65218_CONFIG1_UVLO_2750000;\n\t\tbreak;\n\tcase 2950000:\n\t\tuvloval = TPS65218_CONFIG1_UVLO_2950000;\n\t\tbreak;\n\tcase 3250000:\n\t\tuvloval = TPS65218_CONFIG1_UVLO_3250000;\n\t\tbreak;\n\tcase 3350000:\n\t\tuvloval = TPS65218_CONFIG1_UVLO_3350000;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(tps->dev,\n\t\t\t\"Invalid ti,under-voltage-limit-microvolt value\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttps65218_update_bits(tps, TPS65218_REG_CONFIG1,\n\t\t\t     TPS65218_CONFIG1_UVLO_MASK, uvloval,\n\t\t\t     TPS65218_PROTECT_L1);\n\treturn 0;\n}\n\nstatic int tps65218_probe(struct i2c_client *client)\n{\n\tstruct tps65218 *tps;\n\tint ret;\n\tunsigned int chipid;\n\n\ttps = devm_kzalloc(&client->dev, sizeof(*tps), GFP_KERNEL);\n\tif (!tps)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, tps);\n\ttps->dev = &client->dev;\n\ttps->irq = client->irq;\n\ttps->regmap = devm_regmap_init_i2c(client, &tps65218_regmap_config);\n\tif (IS_ERR(tps->regmap)) {\n\t\tret = PTR_ERR(tps->regmap);\n\t\tdev_err(tps->dev, \"Failed to allocate register map: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tmutex_init(&tps->tps_lock);\n\n\tret = devm_regmap_add_irq_chip(&client->dev, tps->regmap, tps->irq,\n\t\t\t\t       IRQF_ONESHOT, 0, &tps65218_irq_chip,\n\t\t\t\t       &tps->irq_data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_read(tps->regmap, TPS65218_REG_CHIPID, &chipid);\n\tif (ret) {\n\t\tdev_err(tps->dev, \"Failed to read chipid: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\ttps->rev = chipid & TPS65218_CHIPID_REV_MASK;\n\n\tret = tps65218_voltage_set_strict(tps);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tps65218_voltage_set_uvlo(tps);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tps65218_voltage_set_uv_hyst(tps);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mfd_add_devices(tps->dev, PLATFORM_DEVID_AUTO, tps65218_cells,\n\t\t\t      ARRAY_SIZE(tps65218_cells), NULL, 0,\n\t\t\t      regmap_irq_get_domain(tps->irq_data));\n\n\treturn ret;\n}\n\nstatic const struct i2c_device_id tps65218_id_table[] = {\n\t{ \"tps65218\", TPS65218 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(i2c, tps65218_id_table);\n\nstatic struct i2c_driver tps65218_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"tps65218\",\n\t\t.of_match_table = of_tps65218_match_table,\n\t},\n\t.probe\t\t= tps65218_probe,\n\t.id_table       = tps65218_id_table,\n};\n\nmodule_i2c_driver(tps65218_driver);\n\nMODULE_AUTHOR(\"J Keerthy <j-keerthy@ti.com>\");\nMODULE_DESCRIPTION(\"TPS65218 chip family multi-function driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}