{
  "module_name": "qcom-spmi-pmic.c",
  "hash_id": "8f23235a7eef2b6902b154a2ec1786636f3f6414fad9c00b0d578de9d5e22989",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/qcom-spmi-pmic.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/gfp.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/spmi.h>\n#include <linux/types.h>\n#include <linux/regmap.h>\n#include <linux/of_platform.h>\n#include <soc/qcom/qcom-spmi-pmic.h>\n\n#define PMIC_REV2\t\t0x101\n#define PMIC_REV3\t\t0x102\n#define PMIC_REV4\t\t0x103\n#define PMIC_TYPE\t\t0x104\n#define PMIC_SUBTYPE\t\t0x105\n#define PMIC_FAB_ID\t\t0x1f2\n\n#define PMIC_TYPE_VALUE\t\t0x51\n\n#define PMIC_REV4_V2\t\t0x02\n\nstruct qcom_spmi_dev {\n\tint num_usids;\n\tstruct qcom_spmi_pmic pmic;\n};\n\nstatic DEFINE_MUTEX(pmic_spmi_revid_lock);\n\n#define N_USIDS(n)\t\t((void *)n)\n\nstatic const struct of_device_id pmic_spmi_id_table[] = {\n\t{ .compatible = \"qcom,pm660\", .data = N_USIDS(2) },\n\t{ .compatible = \"qcom,pm660l\", .data = N_USIDS(2) },\n\t{ .compatible = \"qcom,pm8004\", .data = N_USIDS(2) },\n\t{ .compatible = \"qcom,pm8005\", .data = N_USIDS(2) },\n\t{ .compatible = \"qcom,pm8019\", .data = N_USIDS(2) },\n\t{ .compatible = \"qcom,pm8028\", .data = N_USIDS(2) },\n\t{ .compatible = \"qcom,pm8110\", .data = N_USIDS(2) },\n\t{ .compatible = \"qcom,pm8150\", .data = N_USIDS(2) },\n\t{ .compatible = \"qcom,pm8150b\", .data = N_USIDS(2) },\n\t{ .compatible = \"qcom,pm8150c\", .data = N_USIDS(2) },\n\t{ .compatible = \"qcom,pm8150l\", .data = N_USIDS(2) },\n\t{ .compatible = \"qcom,pm8226\", .data = N_USIDS(2) },\n\t{ .compatible = \"qcom,pm8841\", .data = N_USIDS(2) },\n\t{ .compatible = \"qcom,pm8901\", .data = N_USIDS(2) },\n\t{ .compatible = \"qcom,pm8909\", .data = N_USIDS(2) },\n\t{ .compatible = \"qcom,pm8916\", .data = N_USIDS(2) },\n\t{ .compatible = \"qcom,pm8941\", .data = N_USIDS(2) },\n\t{ .compatible = \"qcom,pm8950\", .data = N_USIDS(2) },\n\t{ .compatible = \"qcom,pm8994\", .data = N_USIDS(2) },\n\t{ .compatible = \"qcom,pm8998\", .data = N_USIDS(2) },\n\t{ .compatible = \"qcom,pma8084\", .data = N_USIDS(2) },\n\t{ .compatible = \"qcom,pmd9635\", .data = N_USIDS(2) },\n\t{ .compatible = \"qcom,pmi8950\", .data = N_USIDS(2) },\n\t{ .compatible = \"qcom,pmi8962\", .data = N_USIDS(2) },\n\t{ .compatible = \"qcom,pmi8994\", .data = N_USIDS(2) },\n\t{ .compatible = \"qcom,pmi8998\", .data = N_USIDS(2) },\n\t{ .compatible = \"qcom,pmk8002\", .data = N_USIDS(2) },\n\t{ .compatible = \"qcom,pmp8074\", .data = N_USIDS(2) },\n\t{ .compatible = \"qcom,smb2351\", .data = N_USIDS(2) },\n\t{ .compatible = \"qcom,spmi-pmic\", .data = N_USIDS(1) },\n\t{ }\n};\n\n \nstatic struct spmi_device *qcom_pmic_get_base_usid(struct spmi_device *sdev, struct qcom_spmi_dev *ctx)\n{\n\tstruct device_node *spmi_bus;\n\tstruct device_node *child;\n\tint function_parent_usid, ret;\n\tu32 pmic_addr;\n\n\t \n\tif (sdev->usid % ctx->num_usids == 0) {\n\t\tget_device(&sdev->dev);\n\t\treturn sdev;\n\t}\n\n\tfunction_parent_usid = sdev->usid;\n\n\t \n\tspmi_bus = of_get_parent(sdev->dev.of_node);\n\tsdev = ERR_PTR(-ENODATA);\n\tfor_each_child_of_node(spmi_bus, child) {\n\t\tret = of_property_read_u32_index(child, \"reg\", 0, &pmic_addr);\n\t\tif (ret) {\n\t\t\tof_node_put(child);\n\t\t\tsdev = ERR_PTR(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (pmic_addr == function_parent_usid - (ctx->num_usids - 1)) {\n\t\t\tsdev = spmi_device_from_of(child);\n\t\t\tif (!sdev) {\n\t\t\t\t \n\t\t\t\tsdev = ERR_PTR(-EPROBE_DEFER);\n\t\t\t}\n\t\t\tof_node_put(child);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tof_node_put(spmi_bus);\n\n\treturn sdev;\n}\n\nstatic int pmic_spmi_get_base_revid(struct spmi_device *sdev, struct qcom_spmi_dev *ctx)\n{\n\tstruct qcom_spmi_dev *base_ctx;\n\tstruct spmi_device *base;\n\tint ret = 0;\n\n\tbase = qcom_pmic_get_base_usid(sdev, ctx);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\t \n\tmutex_lock(&pmic_spmi_revid_lock);\n\tbase_ctx = spmi_device_get_drvdata(base);\n\tif (!base_ctx) {\n\t\tret = -EPROBE_DEFER;\n\t\tgoto out_unlock;\n\t}\n\tmemcpy(&ctx->pmic, &base_ctx->pmic, sizeof(ctx->pmic));\nout_unlock:\n\tmutex_unlock(&pmic_spmi_revid_lock);\n\n\tput_device(&base->dev);\n\n\treturn ret;\n}\n\nstatic int pmic_spmi_load_revid(struct regmap *map, struct device *dev,\n\t\t\t\t struct qcom_spmi_pmic *pmic)\n{\n\tint ret;\n\n\tret = regmap_read(map, PMIC_TYPE, &pmic->type);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (pmic->type != PMIC_TYPE_VALUE)\n\t\treturn ret;\n\n\tret = regmap_read(map, PMIC_SUBTYPE, &pmic->subtype);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpmic->name = of_match_device(pmic_spmi_id_table, dev)->compatible;\n\n\tret = regmap_read(map, PMIC_REV2, &pmic->rev2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_read(map, PMIC_REV3, &pmic->minor);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_read(map, PMIC_REV4, &pmic->major);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (pmic->subtype == PMI8998_SUBTYPE || pmic->subtype == PM660_SUBTYPE) {\n\t\tret = regmap_read(map, PMIC_FAB_ID, &pmic->fab_id);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif ((pmic->subtype == PM8941_SUBTYPE || pmic->subtype == PM8226_SUBTYPE) &&\n\t    pmic->major < PMIC_REV4_V2)\n\t\tpmic->major++;\n\n\tif (pmic->subtype == PM8110_SUBTYPE)\n\t\tpmic->minor = pmic->rev2;\n\n\tdev_dbg(dev, \"%x: %s v%d.%d\\n\",\n\t\tpmic->subtype, pmic->name, pmic->major, pmic->minor);\n\n\treturn 0;\n}\n\n \nconst struct qcom_spmi_pmic *qcom_pmic_get(struct device *dev)\n{\n\tstruct spmi_device *sdev;\n\tstruct qcom_spmi_dev *spmi;\n\n\t \n\tif (!of_match_device(pmic_spmi_id_table, dev->parent))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tsdev = to_spmi_device(dev->parent);\n\tspmi = dev_get_drvdata(&sdev->dev);\n\n\treturn &spmi->pmic;\n}\nEXPORT_SYMBOL(qcom_pmic_get);\n\nstatic const struct regmap_config spmi_regmap_config = {\n\t.reg_bits\t= 16,\n\t.val_bits\t= 8,\n\t.max_register\t= 0xffff,\n\t.fast_io\t= true,\n};\n\nstatic int pmic_spmi_probe(struct spmi_device *sdev)\n{\n\tstruct regmap *regmap;\n\tstruct qcom_spmi_dev *ctx;\n\tint ret;\n\n\tregmap = devm_regmap_init_spmi_ext(sdev, &spmi_regmap_config);\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\tctx = devm_kzalloc(&sdev->dev, sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->num_usids = (uintptr_t)of_device_get_match_data(&sdev->dev);\n\n\t \n\tif (sdev->usid % ctx->num_usids == 0) {\n\t\tret = pmic_spmi_load_revid(regmap, &sdev->dev, &ctx->pmic);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tret = pmic_spmi_get_base_revid(sdev, ctx);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tmutex_lock(&pmic_spmi_revid_lock);\n\tspmi_device_set_drvdata(sdev, ctx);\n\tmutex_unlock(&pmic_spmi_revid_lock);\n\n\treturn devm_of_platform_populate(&sdev->dev);\n}\n\nstatic void pmic_spmi_remove(struct spmi_device *sdev)\n{\n\tmutex_lock(&pmic_spmi_revid_lock);\n\tspmi_device_set_drvdata(sdev, NULL);\n\tmutex_unlock(&pmic_spmi_revid_lock);\n}\n\nMODULE_DEVICE_TABLE(of, pmic_spmi_id_table);\n\nstatic struct spmi_driver pmic_spmi_driver = {\n\t.probe = pmic_spmi_probe,\n\t.remove = pmic_spmi_remove,\n\t.driver = {\n\t\t.name = \"pmic-spmi\",\n\t\t.of_match_table = pmic_spmi_id_table,\n\t},\n};\nmodule_spmi_driver(pmic_spmi_driver);\n\nMODULE_DESCRIPTION(\"Qualcomm SPMI PMIC driver\");\nMODULE_ALIAS(\"spmi:spmi-pmic\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Josh Cartwright <joshc@codeaurora.org>\");\nMODULE_AUTHOR(\"Stanimir Varbanov <svarbanov@mm-sol.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}