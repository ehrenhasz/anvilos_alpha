{
  "module_name": "ipaq-micro.c",
  "hash_id": "650b708e931fd65d71f0d37f6079dd8decbfd621e4c2ebc14e29e9a8f270887f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/ipaq-micro.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/pm.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/platform_device.h>\n#include <linux/io.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/ipaq-micro.h>\n#include <linux/string.h>\n#include <linux/random.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n\n#include <mach/hardware.h>\n\nstatic void ipaq_micro_trigger_tx(struct ipaq_micro *micro)\n{\n\tstruct ipaq_micro_txdev *tx = &micro->tx;\n\tstruct ipaq_micro_msg *msg = micro->msg;\n\tint i, bp;\n\tu8 checksum;\n\tu32 val;\n\n\tbp = 0;\n\ttx->buf[bp++] = CHAR_SOF;\n\n\tchecksum = ((msg->id & 0x0f) << 4) | (msg->tx_len & 0x0f);\n\ttx->buf[bp++] = checksum;\n\n\tfor (i = 0; i < msg->tx_len; i++) {\n\t\ttx->buf[bp++] = msg->tx_data[i];\n\t\tchecksum += msg->tx_data[i];\n\t}\n\n\ttx->buf[bp++] = checksum;\n\ttx->len = bp;\n\ttx->index = 0;\n\n\t \n\tval = readl(micro->base + UTCR3);\n\tval |= UTCR3_TIE;\n\twritel(val, micro->base + UTCR3);\n}\n\nint ipaq_micro_tx_msg(struct ipaq_micro *micro, struct ipaq_micro_msg *msg)\n{\n\tunsigned long flags;\n\n\tdev_dbg(micro->dev, \"TX msg: %02x, %d bytes\\n\", msg->id, msg->tx_len);\n\n\tspin_lock_irqsave(&micro->lock, flags);\n\tif (micro->msg) {\n\t\tlist_add_tail(&msg->node, &micro->queue);\n\t\tspin_unlock_irqrestore(&micro->lock, flags);\n\t\treturn 0;\n\t}\n\tmicro->msg = msg;\n\tipaq_micro_trigger_tx(micro);\n\tspin_unlock_irqrestore(&micro->lock, flags);\n\treturn 0;\n}\nEXPORT_SYMBOL(ipaq_micro_tx_msg);\n\nstatic void micro_rx_msg(struct ipaq_micro *micro, u8 id, int len, u8 *data)\n{\n\tdev_dbg(micro->dev, \"RX msg: %02x, %d bytes\\n\", id, len);\n\n\tspin_lock(&micro->lock);\n\tswitch (id) {\n\tcase MSG_VERSION:\n\tcase MSG_EEPROM_READ:\n\tcase MSG_EEPROM_WRITE:\n\tcase MSG_BACKLIGHT:\n\tcase MSG_NOTIFY_LED:\n\tcase MSG_THERMAL_SENSOR:\n\tcase MSG_BATTERY:\n\t\t \n\t\tif (micro->msg && micro->msg->id == id) {\n\t\t\tstruct ipaq_micro_msg *msg = micro->msg;\n\n\t\t\tmemcpy(msg->rx_data, data, len);\n\t\t\tmsg->rx_len = len;\n\t\t\tcomplete(&micro->msg->ack);\n\t\t\tif (!list_empty(&micro->queue)) {\n\t\t\t\tmicro->msg = list_entry(micro->queue.next,\n\t\t\t\t\t\t\tstruct ipaq_micro_msg,\n\t\t\t\t\t\t\tnode);\n\t\t\t\tlist_del_init(&micro->msg->node);\n\t\t\t\tipaq_micro_trigger_tx(micro);\n\t\t\t} else\n\t\t\t\tmicro->msg = NULL;\n\t\t\tdev_dbg(micro->dev, \"OK RX message 0x%02x\\n\", id);\n\t\t} else {\n\t\t\tdev_err(micro->dev,\n\t\t\t\t\"out of band RX message 0x%02x\\n\", id);\n\t\t\tif (!micro->msg)\n\t\t\t\tdev_info(micro->dev, \"no message queued\\n\");\n\t\t\telse\n\t\t\t\tdev_info(micro->dev, \"expected message %02x\\n\",\n\t\t\t\t\t micro->msg->id);\n\t\t}\n\t\tbreak;\n\tcase MSG_KEYBOARD:\n\t\tif (micro->key)\n\t\t\tmicro->key(micro->key_data, len, data);\n\t\telse\n\t\t\tdev_dbg(micro->dev, \"key message ignored, no handle\\n\");\n\t\tbreak;\n\tcase MSG_TOUCHSCREEN:\n\t\tif (micro->ts)\n\t\t\tmicro->ts(micro->ts_data, len, data);\n\t\telse\n\t\t\tdev_dbg(micro->dev, \"touchscreen message ignored, no handle\\n\");\n\t\tbreak;\n\tdefault:\n\t\tdev_err(micro->dev,\n\t\t\t\"unknown msg %d [%d] %*ph\\n\", id, len, len, data);\n\t}\n\tspin_unlock(&micro->lock);\n}\n\nstatic void micro_process_char(struct ipaq_micro *micro, u8 ch)\n{\n\tstruct ipaq_micro_rxdev *rx = &micro->rx;\n\n\tswitch (rx->state) {\n\tcase STATE_SOF:\t \n\t\tif (ch == CHAR_SOF)\n\t\t\trx->state = STATE_ID;  \n\t\tbreak;\n\tcase STATE_ID:  \n\t\trx->id = (ch & 0xf0) >> 4;\n\t\trx->len = (ch & 0x0f);\n\t\trx->index = 0;\n\t\trx->chksum = ch;\n\t\trx->state = (rx->len > 0) ? STATE_DATA : STATE_CHKSUM;\n\t\tbreak;\n\tcase STATE_DATA:  \n\t\trx->chksum += ch;\n\t\trx->buf[rx->index] = ch;\n\t\tif (++rx->index == rx->len)\n\t\t\trx->state = STATE_CHKSUM;\n\t\tbreak;\n\tcase STATE_CHKSUM:  \n\t\tif (ch == rx->chksum)\n\t\t\tmicro_rx_msg(micro, rx->id, rx->len, rx->buf);\n\t\trx->state = STATE_SOF;\n\t\tbreak;\n\t}\n}\n\nstatic void micro_rx_chars(struct ipaq_micro *micro)\n{\n\tu32 status, ch;\n\n\twhile ((status = readl(micro->base + UTSR1)) & UTSR1_RNE) {\n\t\tch = readl(micro->base + UTDR);\n\t\tif (status & UTSR1_PRE)\n\t\t\tdev_err(micro->dev, \"rx: parity error\\n\");\n\t\telse if (status & UTSR1_FRE)\n\t\t\tdev_err(micro->dev, \"rx: framing error\\n\");\n\t\telse if (status & UTSR1_ROR)\n\t\t\tdev_err(micro->dev, \"rx: overrun error\\n\");\n\t\tmicro_process_char(micro, ch);\n\t}\n}\n\nstatic void ipaq_micro_get_version(struct ipaq_micro *micro)\n{\n\tstruct ipaq_micro_msg msg = {\n\t\t.id = MSG_VERSION,\n\t};\n\n\tipaq_micro_tx_msg_sync(micro, &msg);\n\tif (msg.rx_len == 4) {\n\t\tmemcpy(micro->version, msg.rx_data, 4);\n\t\tmicro->version[4] = '\\0';\n\t} else if (msg.rx_len == 9) {\n\t\tmemcpy(micro->version, msg.rx_data, 4);\n\t\tmicro->version[4] = '\\0';\n\t\t \n\t} else {\n\t\tdev_err(micro->dev,\n\t\t\t\"illegal version message %d bytes\\n\", msg.rx_len);\n\t}\n}\n\nstatic void ipaq_micro_eeprom_read(struct ipaq_micro *micro,\n\t\t\t\t   u8 address, u8 len, u8 *data)\n{\n\tstruct ipaq_micro_msg msg = {\n\t\t.id = MSG_EEPROM_READ,\n\t};\n\tu8 i;\n\n\tfor (i = 0; i < len; i++) {\n\t\tmsg.tx_data[0] = address + i;\n\t\tmsg.tx_data[1] = 1;\n\t\tmsg.tx_len = 2;\n\t\tipaq_micro_tx_msg_sync(micro, &msg);\n\t\tmemcpy(data + (i * 2), msg.rx_data, 2);\n\t}\n}\n\nstatic char *ipaq_micro_str(u8 *wchar, u8 len)\n{\n\tchar retstr[256];\n\tu8 i;\n\n\tfor (i = 0; i < len / 2; i++)\n\t\tretstr[i] = wchar[i * 2];\n\treturn kstrdup(retstr, GFP_KERNEL);\n}\n\nstatic u16 ipaq_micro_to_u16(u8 *data)\n{\n\treturn data[1] << 8 | data[0];\n}\n\nstatic void __init ipaq_micro_eeprom_dump(struct ipaq_micro *micro)\n{\n\tu8 dump[256];\n\tchar *str;\n\n\tipaq_micro_eeprom_read(micro, 0, 128, dump);\n\tstr = ipaq_micro_str(dump, 10);\n\tif (str) {\n\t\tdev_info(micro->dev, \"HW version %s\\n\", str);\n\t\tkfree(str);\n\t}\n\tstr = ipaq_micro_str(dump+10, 40);\n\tif (str) {\n\t\tdev_info(micro->dev, \"serial number: %s\\n\", str);\n\t\t \n\t\tadd_device_randomness(str, strlen(str));\n\t\tkfree(str);\n\t}\n\tstr = ipaq_micro_str(dump+50, 20);\n\tif (str) {\n\t\tdev_info(micro->dev, \"module ID: %s\\n\", str);\n\t\tkfree(str);\n\t}\n\tstr = ipaq_micro_str(dump+70, 10);\n\tif (str) {\n\t\tdev_info(micro->dev, \"product revision: %s\\n\", str);\n\t\tkfree(str);\n\t}\n\tdev_info(micro->dev, \"product ID: %u\\n\", ipaq_micro_to_u16(dump+80));\n\tdev_info(micro->dev, \"frame rate: %u fps\\n\",\n\t\t ipaq_micro_to_u16(dump+82));\n\tdev_info(micro->dev, \"page mode: %u\\n\", ipaq_micro_to_u16(dump+84));\n\tdev_info(micro->dev, \"country ID: %u\\n\", ipaq_micro_to_u16(dump+86));\n\tdev_info(micro->dev, \"color display: %s\\n\",\n\t\t ipaq_micro_to_u16(dump+88) ? \"yes\" : \"no\");\n\tdev_info(micro->dev, \"ROM size: %u MiB\\n\", ipaq_micro_to_u16(dump+90));\n\tdev_info(micro->dev, \"RAM size: %u KiB\\n\", ipaq_micro_to_u16(dump+92));\n\tdev_info(micro->dev, \"screen: %u x %u\\n\",\n\t\t ipaq_micro_to_u16(dump+94), ipaq_micro_to_u16(dump+96));\n}\n\nstatic void micro_tx_chars(struct ipaq_micro *micro)\n{\n\tstruct ipaq_micro_txdev *tx = &micro->tx;\n\tu32 val;\n\n\twhile ((tx->index < tx->len) &&\n\t       (readl(micro->base + UTSR1) & UTSR1_TNF)) {\n\t\twritel(tx->buf[tx->index], micro->base + UTDR);\n\t\ttx->index++;\n\t}\n\n\t \n\tval = readl(micro->base + UTCR3);\n\tval &= ~UTCR3_TIE;\n\twritel(val, micro->base + UTCR3);\n}\n\nstatic void micro_reset_comm(struct ipaq_micro *micro)\n{\n\tstruct ipaq_micro_rxdev *rx = &micro->rx;\n\tu32 val;\n\n\tif (micro->msg)\n\t\tcomplete(&micro->msg->ack);\n\n\t \n\trx->state = STATE_SOF;   \n\n\t \n\twritel(0x01, micro->sdlc + 0x0);  \n\n\t \n\twritel(0x0, micro->base + UTCR3);\n\n\t \n\twritel(UTCR0_8BitData | UTCR0_1StpBit, micro->base + UTCR0);\n\n\t \n\twritel(0x0, micro->base + UTCR1);\n\twritel(0x1, micro->base + UTCR2);\n\n\t \n\twritel(0xff, micro->base + UTSR0);\n\n\t \n\twritel(UTCR3_TXE | UTCR3_RXE | UTCR3_RIE, micro->base + UTCR3);\n\tval = readl(micro->base + UTCR3);\n\tval &= ~UTCR3_TIE;\n\twritel(val, micro->base + UTCR3);\n}\n\nstatic irqreturn_t micro_serial_isr(int irq, void *dev_id)\n{\n\tstruct ipaq_micro *micro = dev_id;\n\tstruct ipaq_micro_txdev *tx = &micro->tx;\n\tu32 status;\n\n\tstatus = readl(micro->base + UTSR0);\n\tdo {\n\t\tif (status & (UTSR0_RID | UTSR0_RFS)) {\n\t\t\tif (status & UTSR0_RID)\n\t\t\t\t \n\t\t\t\twritel(UTSR0_RID, micro->base + UTSR0);\n\t\t\tmicro_rx_chars(micro);\n\t\t}\n\n\t\t \n\t\tif (status & (UTSR0_RBB | UTSR0_REB))\n\t\t\twritel(status & (UTSR0_RBB | UTSR0_REB),\n\t\t\t       micro->base + UTSR0);\n\n\t\tif (status & UTSR0_TFS)\n\t\t\tmicro_tx_chars(micro);\n\n\t\tstatus = readl(micro->base + UTSR0);\n\n\t} while (((tx->index < tx->len) && (status & UTSR0_TFS)) ||\n\t\t (status & (UTSR0_RFS | UTSR0_RID)));\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct mfd_cell micro_cells[] = {\n\t{ .name = \"ipaq-micro-backlight\", },\n\t{ .name = \"ipaq-micro-battery\", },\n\t{ .name = \"ipaq-micro-keys\", },\n\t{ .name = \"ipaq-micro-ts\", },\n\t{ .name = \"ipaq-micro-leds\", },\n};\n\nstatic int __maybe_unused micro_resume(struct device *dev)\n{\n\tstruct ipaq_micro *micro = dev_get_drvdata(dev);\n\n\tmicro_reset_comm(micro);\n\tmdelay(10);\n\n\treturn 0;\n}\n\nstatic int __init micro_probe(struct platform_device *pdev)\n{\n\tstruct ipaq_micro *micro;\n\tint ret;\n\tint irq;\n\n\tmicro = devm_kzalloc(&pdev->dev, sizeof(*micro), GFP_KERNEL);\n\tif (!micro)\n\t\treturn -ENOMEM;\n\n\tmicro->dev = &pdev->dev;\n\n\tmicro->base = devm_platform_get_and_ioremap_resource(pdev, 0, NULL);\n\tif (IS_ERR(micro->base))\n\t\treturn PTR_ERR(micro->base);\n\n\tmicro->sdlc = devm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(micro->sdlc))\n\t\treturn PTR_ERR(micro->sdlc);\n\n\tmicro_reset_comm(micro);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn -EINVAL;\n\tret = devm_request_irq(&pdev->dev, irq, micro_serial_isr,\n\t\t\t       IRQF_SHARED, \"ipaq-micro\",\n\t\t\t       micro);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"unable to grab serial port IRQ\\n\");\n\t\treturn ret;\n\t} else\n\t\tdev_info(&pdev->dev, \"grabbed serial port IRQ\\n\");\n\n\tspin_lock_init(&micro->lock);\n\tINIT_LIST_HEAD(&micro->queue);\n\tplatform_set_drvdata(pdev, micro);\n\n\tret = mfd_add_devices(&pdev->dev, pdev->id, micro_cells,\n\t\t\t      ARRAY_SIZE(micro_cells), NULL, 0, NULL);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"error adding MFD cells\");\n\t\treturn ret;\n\t}\n\n\t \n\tipaq_micro_get_version(micro);\n\tdev_info(&pdev->dev, \"Atmel micro ASIC version %s\\n\", micro->version);\n\tipaq_micro_eeprom_dump(micro);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops micro_dev_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(NULL, micro_resume)\n};\n\nstatic struct platform_driver micro_device_driver = {\n\t.driver   = {\n\t\t.name\t= \"ipaq-h3xxx-micro\",\n\t\t.pm\t= &micro_dev_pm_ops,\n\t\t.suppress_bind_attrs = true,\n\t},\n};\nbuiltin_platform_driver_probe(micro_device_driver, micro_probe);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}