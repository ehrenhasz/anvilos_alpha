{
  "module_name": "retu-mfd.c",
  "hash_id": "8a2295e7d8cba01b56aa1bfff1e2b4b53aa063cafb5be9054d0af79b258fb3bd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/retu-mfd.c",
  "human_readable_source": " \n\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/irq.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/retu.h>\n#include <linux/interrupt.h>\n#include <linux/moduleparam.h>\n\n \n#define RETU_REG_ASICR\t\t0x00\t\t \n#define RETU_REG_ASICR_VILMA\t(1 << 7)\t \n#define RETU_REG_IDR\t\t0x01\t\t \n#define RETU_REG_IMR\t\t0x02\t\t \n#define TAHVO_REG_IMR\t\t0x03\t\t \n\n \n#define RETU_INT_PWR\t\t0\t\t \n\nstruct retu_dev {\n\tstruct regmap\t\t\t*regmap;\n\tstruct device\t\t\t*dev;\n\tstruct mutex\t\t\tmutex;\n\tstruct regmap_irq_chip_data\t*irq_data;\n};\n\nstatic const struct resource retu_pwrbutton_res[] = {\n\t{\n\t\t.name\t= \"retu-pwrbutton\",\n\t\t.start\t= RETU_INT_PWR,\n\t\t.end\t= RETU_INT_PWR,\n\t\t.flags\t= IORESOURCE_IRQ,\n\t},\n};\n\nstatic const struct mfd_cell retu_devs[] = {\n\t{\n\t\t.name\t\t= \"retu-wdt\"\n\t},\n\t{\n\t\t.name\t\t= \"retu-pwrbutton\",\n\t\t.resources\t= retu_pwrbutton_res,\n\t\t.num_resources\t= ARRAY_SIZE(retu_pwrbutton_res),\n\t}\n};\n\nstatic struct regmap_irq retu_irqs[] = {\n\t[RETU_INT_PWR] = {\n\t\t.mask = 1 << RETU_INT_PWR,\n\t}\n};\n\nstatic struct regmap_irq_chip retu_irq_chip = {\n\t.name\t\t= \"RETU\",\n\t.irqs\t\t= retu_irqs,\n\t.num_irqs\t= ARRAY_SIZE(retu_irqs),\n\t.num_regs\t= 1,\n\t.status_base\t= RETU_REG_IDR,\n\t.mask_base\t= RETU_REG_IMR,\n\t.ack_base\t= RETU_REG_IDR,\n};\n\n \nstatic struct retu_dev *retu_pm_power_off;\n\nstatic const struct resource tahvo_usb_res[] = {\n\t{\n\t\t.name\t= \"tahvo-usb\",\n\t\t.start\t= TAHVO_INT_VBUS,\n\t\t.end\t= TAHVO_INT_VBUS,\n\t\t.flags\t= IORESOURCE_IRQ,\n\t},\n};\n\nstatic const struct mfd_cell tahvo_devs[] = {\n\t{\n\t\t.name\t\t= \"tahvo-usb\",\n\t\t.resources\t= tahvo_usb_res,\n\t\t.num_resources\t= ARRAY_SIZE(tahvo_usb_res),\n\t},\n};\n\nstatic struct regmap_irq tahvo_irqs[] = {\n\t[TAHVO_INT_VBUS] = {\n\t\t.mask = 1 << TAHVO_INT_VBUS,\n\t}\n};\n\nstatic struct regmap_irq_chip tahvo_irq_chip = {\n\t.name\t\t= \"TAHVO\",\n\t.irqs\t\t= tahvo_irqs,\n\t.num_irqs\t= ARRAY_SIZE(tahvo_irqs),\n\t.num_regs\t= 1,\n\t.status_base\t= RETU_REG_IDR,\n\t.mask_base\t= TAHVO_REG_IMR,\n\t.ack_base\t= RETU_REG_IDR,\n};\n\nstatic const struct retu_data {\n\tchar\t\t\t*chip_name;\n\tchar\t\t\t*companion_name;\n\tstruct regmap_irq_chip\t*irq_chip;\n\tconst struct mfd_cell\t*children;\n\tint\t\t\tnchildren;\n} retu_data[] = {\n\t[0] = {\n\t\t.chip_name\t= \"Retu\",\n\t\t.companion_name\t= \"Vilma\",\n\t\t.irq_chip\t= &retu_irq_chip,\n\t\t.children\t= retu_devs,\n\t\t.nchildren\t= ARRAY_SIZE(retu_devs),\n\t},\n\t[1] = {\n\t\t.chip_name\t= \"Tahvo\",\n\t\t.companion_name\t= \"Betty\",\n\t\t.irq_chip\t= &tahvo_irq_chip,\n\t\t.children\t= tahvo_devs,\n\t\t.nchildren\t= ARRAY_SIZE(tahvo_devs),\n\t}\n};\n\nint retu_read(struct retu_dev *rdev, u8 reg)\n{\n\tint ret;\n\tint value;\n\n\tmutex_lock(&rdev->mutex);\n\tret = regmap_read(rdev->regmap, reg, &value);\n\tmutex_unlock(&rdev->mutex);\n\n\treturn ret ? ret : value;\n}\nEXPORT_SYMBOL_GPL(retu_read);\n\nint retu_write(struct retu_dev *rdev, u8 reg, u16 data)\n{\n\tint ret;\n\n\tmutex_lock(&rdev->mutex);\n\tret = regmap_write(rdev->regmap, reg, data);\n\tmutex_unlock(&rdev->mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(retu_write);\n\nstatic void retu_power_off(void)\n{\n\tstruct retu_dev *rdev = retu_pm_power_off;\n\tint reg;\n\n\tmutex_lock(&retu_pm_power_off->mutex);\n\n\t \n\tregmap_read(rdev->regmap, RETU_REG_CC1, &reg);\n\tregmap_write(rdev->regmap, RETU_REG_CC1, reg | 2);\n\n\t \n\tregmap_write(rdev->regmap, RETU_REG_WATCHDOG, 0);\n\n\t \n\tfor (;;)\n\t\tcpu_relax();\n\n\tmutex_unlock(&retu_pm_power_off->mutex);\n}\n\nstatic int retu_regmap_read(void *context, const void *reg, size_t reg_size,\n\t\t\t    void *val, size_t val_size)\n{\n\tint ret;\n\tstruct device *dev = context;\n\tstruct i2c_client *i2c = to_i2c_client(dev);\n\n\tBUG_ON(reg_size != 1 || val_size != 2);\n\n\tret = i2c_smbus_read_word_data(i2c, *(u8 const *)reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*(u16 *)val = ret;\n\treturn 0;\n}\n\nstatic int retu_regmap_write(void *context, const void *data, size_t count)\n{\n\tu8 reg;\n\tu16 val;\n\tstruct device *dev = context;\n\tstruct i2c_client *i2c = to_i2c_client(dev);\n\n\tBUG_ON(count != sizeof(reg) + sizeof(val));\n\tmemcpy(&reg, data, sizeof(reg));\n\tmemcpy(&val, data + sizeof(reg), sizeof(val));\n\treturn i2c_smbus_write_word_data(i2c, reg, val);\n}\n\nstatic struct regmap_bus retu_bus = {\n\t.read = retu_regmap_read,\n\t.write = retu_regmap_write,\n\t.val_format_endian_default = REGMAP_ENDIAN_NATIVE,\n};\n\nstatic const struct regmap_config retu_config = {\n\t.reg_bits = 8,\n\t.val_bits = 16,\n};\n\nstatic int retu_probe(struct i2c_client *i2c)\n{\n\tstruct retu_data const *rdat;\n\tstruct retu_dev *rdev;\n\tint ret;\n\n\tif (i2c->addr > ARRAY_SIZE(retu_data))\n\t\treturn -ENODEV;\n\trdat = &retu_data[i2c->addr - 1];\n\n\trdev = devm_kzalloc(&i2c->dev, sizeof(*rdev), GFP_KERNEL);\n\tif (rdev == NULL)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(i2c, rdev);\n\trdev->dev = &i2c->dev;\n\tmutex_init(&rdev->mutex);\n\trdev->regmap = devm_regmap_init(&i2c->dev, &retu_bus, &i2c->dev,\n\t\t\t\t\t&retu_config);\n\tif (IS_ERR(rdev->regmap))\n\t\treturn PTR_ERR(rdev->regmap);\n\n\tret = retu_read(rdev, RETU_REG_ASICR);\n\tif (ret < 0) {\n\t\tdev_err(rdev->dev, \"could not read %s revision: %d\\n\",\n\t\t\trdat->chip_name, ret);\n\t\treturn ret;\n\t}\n\n\tdev_info(rdev->dev, \"%s%s%s v%d.%d found\\n\", rdat->chip_name,\n\t\t (ret & RETU_REG_ASICR_VILMA) ? \" & \" : \"\",\n\t\t (ret & RETU_REG_ASICR_VILMA) ? rdat->companion_name : \"\",\n\t\t (ret >> 4) & 0x7, ret & 0xf);\n\n\t \n\tret = retu_write(rdev, rdat->irq_chip->mask_base, 0xffff);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_add_irq_chip(rdev->regmap, i2c->irq, IRQF_ONESHOT, -1,\n\t\t\t\t  rdat->irq_chip, &rdev->irq_data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = mfd_add_devices(rdev->dev, -1, rdat->children, rdat->nchildren,\n\t\t\t      NULL, regmap_irq_chip_get_base(rdev->irq_data),\n\t\t\t      NULL);\n\tif (ret < 0) {\n\t\tregmap_del_irq_chip(i2c->irq, rdev->irq_data);\n\t\treturn ret;\n\t}\n\n\tif (i2c->addr == 1 && !pm_power_off) {\n\t\tretu_pm_power_off = rdev;\n\t\tpm_power_off\t  = retu_power_off;\n\t}\n\n\treturn 0;\n}\n\nstatic void retu_remove(struct i2c_client *i2c)\n{\n\tstruct retu_dev *rdev = i2c_get_clientdata(i2c);\n\n\tif (retu_pm_power_off == rdev) {\n\t\tpm_power_off\t  = NULL;\n\t\tretu_pm_power_off = NULL;\n\t}\n\tmfd_remove_devices(rdev->dev);\n\tregmap_del_irq_chip(i2c->irq, rdev->irq_data);\n}\n\nstatic const struct i2c_device_id retu_id[] = {\n\t{ \"retu\", 0 },\n\t{ \"tahvo\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, retu_id);\n\nstatic const struct of_device_id retu_of_match[] = {\n\t{ .compatible = \"nokia,retu\" },\n\t{ .compatible = \"nokia,tahvo\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, retu_of_match);\n\nstatic struct i2c_driver retu_driver = {\n\t.driver\t\t= {\n\t\t.name = \"retu-mfd\",\n\t\t.of_match_table = retu_of_match,\n\t},\n\t.probe\t\t= retu_probe,\n\t.remove\t\t= retu_remove,\n\t.id_table\t= retu_id,\n};\nmodule_i2c_driver(retu_driver);\n\nMODULE_DESCRIPTION(\"Retu MFD driver\");\nMODULE_AUTHOR(\"Juha Yrj\u00f6l\u00e4\");\nMODULE_AUTHOR(\"David Weinehall\");\nMODULE_AUTHOR(\"Mikko Ylinen\");\nMODULE_AUTHOR(\"Aaro Koskinen <aaro.koskinen@iki.fi>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}