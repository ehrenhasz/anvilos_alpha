{
  "module_name": "rsmu_i2c.c",
  "hash_id": "0426c012f2eb32b6c603968f58196bbd5ba28a6945e1925618d198a3aa483c7d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/rsmu_i2c.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/rsmu.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n#include \"rsmu.h\"\n\n \n#define\tRSMU_CM_PAGE_ADDR\t\t0xFC\n#define RSMU_CM_PAGE_MASK\t\t0xFFFFFF00\n#define RSMU_CM_ADDRESS_MASK\t\t0x000000FF\n\n \n#define\tRSMU_SABRE_PAGE_ADDR\t\t0x7F\n#define\tRSMU_SABRE_PAGE_WINDOW\t\t128\n\nstatic const struct regmap_range_cfg rsmu_sabre_range_cfg[] = {\n\t{\n\t\t.range_min = 0,\n\t\t.range_max = 0x400,\n\t\t.selector_reg = RSMU_SABRE_PAGE_ADDR,\n\t\t.selector_mask = 0xFF,\n\t\t.selector_shift = 0,\n\t\t.window_start = 0,\n\t\t.window_len = RSMU_SABRE_PAGE_WINDOW,\n\t}\n};\n\nstatic bool rsmu_sabre_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase RSMU_SABRE_PAGE_ADDR:\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nstatic int rsmu_read_device(struct rsmu_ddata *rsmu, u8 reg, u8 *buf, u16 bytes)\n{\n\tstruct i2c_client *client = to_i2c_client(rsmu->dev);\n\tstruct i2c_msg msg[2];\n\tint cnt;\n\n\tmsg[0].addr = client->addr;\n\tmsg[0].flags = 0;\n\tmsg[0].len = 1;\n\tmsg[0].buf = &reg;\n\n\tmsg[1].addr = client->addr;\n\tmsg[1].flags = I2C_M_RD;\n\tmsg[1].len = bytes;\n\tmsg[1].buf = buf;\n\n\tcnt = i2c_transfer(client->adapter, msg, 2);\n\n\tif (cnt < 0) {\n\t\tdev_err(rsmu->dev, \"i2c_transfer failed at addr: %04x!\", reg);\n\t\treturn cnt;\n\t} else if (cnt != 2) {\n\t\tdev_err(rsmu->dev,\n\t\t\t\"i2c_transfer sent only %d of 2 messages\", cnt);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int rsmu_write_device(struct rsmu_ddata *rsmu, u8 reg, u8 *buf, u16 bytes)\n{\n\tstruct i2c_client *client = to_i2c_client(rsmu->dev);\n\tu8 msg[RSMU_MAX_WRITE_COUNT + 1];  \n\tint cnt;\n\n\tif (bytes > RSMU_MAX_WRITE_COUNT)\n\t\treturn -EINVAL;\n\n\tmsg[0] = reg;\n\tmemcpy(&msg[1], buf, bytes);\n\n\tcnt = i2c_master_send(client, msg, bytes + 1);\n\n\tif (cnt < 0) {\n\t\tdev_err(&client->dev,\n\t\t\t\"i2c_master_send failed at addr: %04x!\", reg);\n\t\treturn cnt;\n\t}\n\n\treturn 0;\n}\n\nstatic int rsmu_write_page_register(struct rsmu_ddata *rsmu, u32 reg)\n{\n\tu32 page = reg & RSMU_CM_PAGE_MASK;\n\tu8 buf[4];\n\tint err;\n\n\t \n\tif (reg < RSMU_CM_SCSR_BASE)\n\t\treturn 0;\n\n\t \n\tif (rsmu->page == page)\n\t\treturn 0;\n\n\tbuf[0] = 0x0;\n\tbuf[1] = (u8)((page >> 8) & 0xFF);\n\tbuf[2] = (u8)((page >> 16) & 0xFF);\n\tbuf[3] = (u8)((page >> 24) & 0xFF);\n\n\terr = rsmu_write_device(rsmu, RSMU_CM_PAGE_ADDR, buf, sizeof(buf));\n\tif (err)\n\t\tdev_err(rsmu->dev, \"Failed to set page offset 0x%x\\n\", page);\n\telse\n\t\t \n\t\trsmu->page = page;\n\n\treturn err;\n}\n\nstatic int rsmu_reg_read(void *context, unsigned int reg, unsigned int *val)\n{\n\tstruct rsmu_ddata *rsmu = i2c_get_clientdata((struct i2c_client *)context);\n\tu8 addr = (u8)(reg & RSMU_CM_ADDRESS_MASK);\n\tint err;\n\n\terr = rsmu_write_page_register(rsmu, reg);\n\tif (err)\n\t\treturn err;\n\n\terr = rsmu_read_device(rsmu, addr, (u8 *)val, 1);\n\tif (err)\n\t\tdev_err(rsmu->dev, \"Failed to read offset address 0x%x\\n\", addr);\n\n\treturn err;\n}\n\nstatic int rsmu_reg_write(void *context, unsigned int reg, unsigned int val)\n{\n\tstruct rsmu_ddata *rsmu = i2c_get_clientdata((struct i2c_client *)context);\n\tu8 addr = (u8)(reg & RSMU_CM_ADDRESS_MASK);\n\tu8 data = (u8)val;\n\tint err;\n\n\terr = rsmu_write_page_register(rsmu, reg);\n\tif (err)\n\t\treturn err;\n\n\terr = rsmu_write_device(rsmu, addr, &data, 1);\n\tif (err)\n\t\tdev_err(rsmu->dev,\n\t\t\t\"Failed to write offset address 0x%x\\n\", addr);\n\n\treturn err;\n}\n\nstatic const struct regmap_config rsmu_cm_regmap_config = {\n\t.reg_bits = 32,\n\t.val_bits = 8,\n\t.max_register = 0x20120000,\n\t.reg_read = rsmu_reg_read,\n\t.reg_write = rsmu_reg_write,\n\t.cache_type = REGCACHE_NONE,\n};\n\nstatic const struct regmap_config rsmu_sabre_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = 0x400,\n\t.ranges = rsmu_sabre_range_cfg,\n\t.num_ranges = ARRAY_SIZE(rsmu_sabre_range_cfg),\n\t.volatile_reg = rsmu_sabre_volatile_reg,\n\t.cache_type = REGCACHE_RBTREE,\n\t.can_multi_write = true,\n};\n\nstatic const struct regmap_config rsmu_sl_regmap_config = {\n\t.reg_bits = 16,\n\t.val_bits = 8,\n\t.reg_format_endian = REGMAP_ENDIAN_BIG,\n\t.max_register = 0x340,\n\t.cache_type = REGCACHE_NONE,\n\t.can_multi_write = true,\n};\n\nstatic int rsmu_i2c_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tconst struct regmap_config *cfg;\n\tstruct rsmu_ddata *rsmu;\n\tint ret;\n\n\trsmu = devm_kzalloc(&client->dev, sizeof(*rsmu), GFP_KERNEL);\n\tif (!rsmu)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, rsmu);\n\n\trsmu->dev = &client->dev;\n\trsmu->type = (enum rsmu_type)id->driver_data;\n\n\tswitch (rsmu->type) {\n\tcase RSMU_CM:\n\t\tcfg = &rsmu_cm_regmap_config;\n\t\tbreak;\n\tcase RSMU_SABRE:\n\t\tcfg = &rsmu_sabre_regmap_config;\n\t\tbreak;\n\tcase RSMU_SL:\n\t\tcfg = &rsmu_sl_regmap_config;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(rsmu->dev, \"Unsupported RSMU device type: %d\\n\", rsmu->type);\n\t\treturn -ENODEV;\n\t}\n\n\tif (rsmu->type == RSMU_CM)\n\t\trsmu->regmap = devm_regmap_init(&client->dev, NULL, client, cfg);\n\telse\n\t\trsmu->regmap = devm_regmap_init_i2c(client, cfg);\n\tif (IS_ERR(rsmu->regmap)) {\n\t\tret = PTR_ERR(rsmu->regmap);\n\t\tdev_err(rsmu->dev, \"Failed to allocate register map: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn rsmu_core_init(rsmu);\n}\n\nstatic void rsmu_i2c_remove(struct i2c_client *client)\n{\n\tstruct rsmu_ddata *rsmu = i2c_get_clientdata(client);\n\n\trsmu_core_exit(rsmu);\n}\n\nstatic const struct i2c_device_id rsmu_i2c_id[] = {\n\t{ \"8a34000\",  RSMU_CM },\n\t{ \"8a34001\",  RSMU_CM },\n\t{ \"82p33810\", RSMU_SABRE },\n\t{ \"82p33811\", RSMU_SABRE },\n\t{ \"8v19n850\", RSMU_SL },\n\t{ \"8v19n851\", RSMU_SL },\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, rsmu_i2c_id);\n\nstatic const struct of_device_id rsmu_i2c_of_match[] = {\n\t{ .compatible = \"idt,8a34000\",  .data = (void *)RSMU_CM },\n\t{ .compatible = \"idt,8a34001\",  .data = (void *)RSMU_CM },\n\t{ .compatible = \"idt,82p33810\", .data = (void *)RSMU_SABRE },\n\t{ .compatible = \"idt,82p33811\", .data = (void *)RSMU_SABRE },\n\t{ .compatible = \"idt,8v19n850\", .data = (void *)RSMU_SL },\n\t{ .compatible = \"idt,8v19n851\", .data = (void *)RSMU_SL },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, rsmu_i2c_of_match);\n\nstatic struct i2c_driver rsmu_i2c_driver = {\n\t.driver = {\n\t\t.name = \"rsmu-i2c\",\n\t\t.of_match_table = rsmu_i2c_of_match,\n\t},\n\t.probe = rsmu_i2c_probe,\n\t.remove\t= rsmu_i2c_remove,\n\t.id_table = rsmu_i2c_id,\n};\n\nstatic int __init rsmu_i2c_init(void)\n{\n\treturn i2c_add_driver(&rsmu_i2c_driver);\n}\nsubsys_initcall(rsmu_i2c_init);\n\nstatic void __exit rsmu_i2c_exit(void)\n{\n\ti2c_del_driver(&rsmu_i2c_driver);\n}\nmodule_exit(rsmu_i2c_exit);\n\nMODULE_DESCRIPTION(\"Renesas SMU I2C driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}