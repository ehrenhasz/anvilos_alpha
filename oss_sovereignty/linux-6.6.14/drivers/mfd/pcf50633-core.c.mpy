{
  "module_name": "pcf50633-core.c",
  "hash_id": "2aef5cbc551b2d22bf391d7bba163ea5f349cc3d41a38fe959009eb23002ffa3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/pcf50633-core.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/sysfs.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/interrupt.h>\n#include <linux/workqueue.h>\n#include <linux/platform_device.h>\n#include <linux/i2c.h>\n#include <linux/pm.h>\n#include <linux/slab.h>\n#include <linux/regmap.h>\n#include <linux/err.h>\n\n#include <linux/mfd/pcf50633/core.h>\n\n \nint pcf50633_read_block(struct pcf50633 *pcf, u8 reg,\n\t\t\t\t\tint nr_regs, u8 *data)\n{\n\tint ret;\n\n\tret = regmap_raw_read(pcf->regmap, reg, data, nr_regs);\n\tif (ret != 0)\n\t\treturn ret;\n\n\treturn nr_regs;\n}\nEXPORT_SYMBOL_GPL(pcf50633_read_block);\n\n \nint pcf50633_write_block(struct pcf50633 *pcf , u8 reg,\n\t\t\t\t\tint nr_regs, u8 *data)\n{\n\treturn regmap_raw_write(pcf->regmap, reg, data, nr_regs);\n}\nEXPORT_SYMBOL_GPL(pcf50633_write_block);\n\nu8 pcf50633_reg_read(struct pcf50633 *pcf, u8 reg)\n{\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read(pcf->regmap, reg, &val);\n\tif (ret < 0)\n\t\treturn -1;\n\n\treturn val;\n}\nEXPORT_SYMBOL_GPL(pcf50633_reg_read);\n\nint pcf50633_reg_write(struct pcf50633 *pcf, u8 reg, u8 val)\n{\n\treturn regmap_write(pcf->regmap, reg, val);\n}\nEXPORT_SYMBOL_GPL(pcf50633_reg_write);\n\nint pcf50633_reg_set_bit_mask(struct pcf50633 *pcf, u8 reg, u8 mask, u8 val)\n{\n\treturn regmap_update_bits(pcf->regmap, reg, mask, val);\n}\nEXPORT_SYMBOL_GPL(pcf50633_reg_set_bit_mask);\n\nint pcf50633_reg_clear_bits(struct pcf50633 *pcf, u8 reg, u8 val)\n{\n\treturn regmap_update_bits(pcf->regmap, reg, val, 0);\n}\nEXPORT_SYMBOL_GPL(pcf50633_reg_clear_bits);\n\n \nstatic ssize_t dump_regs_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct pcf50633 *pcf = dev_get_drvdata(dev);\n\tu8 dump[16];\n\tint n, n1, idx = 0;\n\tchar *buf1 = buf;\n\tstatic u8 address_no_read[] = {  \n\t\tPCF50633_REG_INT1,\n\t\tPCF50633_REG_INT2,\n\t\tPCF50633_REG_INT3,\n\t\tPCF50633_REG_INT4,\n\t\tPCF50633_REG_INT5,\n\t\t0  \n\t};\n\n\tfor (n = 0; n < 256; n += sizeof(dump)) {\n\t\tfor (n1 = 0; n1 < sizeof(dump); n1++)\n\t\t\tif (n == address_no_read[idx]) {\n\t\t\t\tidx++;\n\t\t\t\tdump[n1] = 0x00;\n\t\t\t} else\n\t\t\t\tdump[n1] = pcf50633_reg_read(pcf, n + n1);\n\n\t\tbuf1 += sprintf(buf1, \"%*ph\\n\", (int)sizeof(dump), dump);\n\t}\n\n\treturn buf1 - buf;\n}\nstatic DEVICE_ATTR_ADMIN_RO(dump_regs);\n\nstatic ssize_t resume_reason_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct pcf50633 *pcf = dev_get_drvdata(dev);\n\tint n;\n\n\tn = sprintf(buf, \"%02x%02x%02x%02x%02x\\n\",\n\t\t\t\tpcf->resume_reason[0],\n\t\t\t\tpcf->resume_reason[1],\n\t\t\t\tpcf->resume_reason[2],\n\t\t\t\tpcf->resume_reason[3],\n\t\t\t\tpcf->resume_reason[4]);\n\n\treturn n;\n}\nstatic DEVICE_ATTR_ADMIN_RO(resume_reason);\n\nstatic struct attribute *pcf_sysfs_entries[] = {\n\t&dev_attr_dump_regs.attr,\n\t&dev_attr_resume_reason.attr,\n\tNULL,\n};\n\nstatic struct attribute_group pcf_attr_group = {\n\t.name\t= NULL,\t\t\t \n\t.attrs\t= pcf_sysfs_entries,\n};\n\nstatic void\npcf50633_client_dev_register(struct pcf50633 *pcf, const char *name,\n\t\t\t\t\t\tstruct platform_device **pdev)\n{\n\tint ret;\n\n\t*pdev = platform_device_alloc(name, -1);\n\tif (!*pdev) {\n\t\tdev_err(pcf->dev, \"Failed to allocate %s\\n\", name);\n\t\treturn;\n\t}\n\n\t(*pdev)->dev.parent = pcf->dev;\n\n\tret = platform_device_add(*pdev);\n\tif (ret) {\n\t\tdev_err(pcf->dev, \"Failed to register %s: %d\\n\", name, ret);\n\t\tplatform_device_put(*pdev);\n\t\t*pdev = NULL;\n\t}\n}\n\nstatic const struct regmap_config pcf50633_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n};\n\nstatic int pcf50633_probe(struct i2c_client *client)\n{\n\tstruct pcf50633 *pcf;\n\tstruct platform_device *pdev;\n\tstruct pcf50633_platform_data *pdata = dev_get_platdata(&client->dev);\n\tint i, j, ret;\n\tint version, variant;\n\n\tif (!client->irq) {\n\t\tdev_err(&client->dev, \"Missing IRQ\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tpcf = devm_kzalloc(&client->dev, sizeof(*pcf), GFP_KERNEL);\n\tif (!pcf)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, pcf);\n\tpcf->dev = &client->dev;\n\tpcf->pdata = pdata;\n\n\tmutex_init(&pcf->lock);\n\n\tpcf->regmap = devm_regmap_init_i2c(client, &pcf50633_regmap_config);\n\tif (IS_ERR(pcf->regmap)) {\n\t\tret = PTR_ERR(pcf->regmap);\n\t\tdev_err(pcf->dev, \"Failed to allocate register map: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tversion = pcf50633_reg_read(pcf, 0);\n\tvariant = pcf50633_reg_read(pcf, 1);\n\tif (version < 0 || variant < 0) {\n\t\tdev_err(pcf->dev, \"Unable to probe pcf50633\\n\");\n\t\tret = -ENODEV;\n\t\treturn ret;\n\t}\n\n\tdev_info(pcf->dev, \"Probed device version %d variant %d\\n\",\n\t\t\t\t\t\t\tversion, variant);\n\n\tpcf50633_irq_init(pcf, client->irq);\n\n\t \n\tpcf50633_client_dev_register(pcf, \"pcf50633-input\", &pcf->input_pdev);\n\tpcf50633_client_dev_register(pcf, \"pcf50633-rtc\", &pcf->rtc_pdev);\n\tpcf50633_client_dev_register(pcf, \"pcf50633-mbc\", &pcf->mbc_pdev);\n\tpcf50633_client_dev_register(pcf, \"pcf50633-adc\", &pcf->adc_pdev);\n\tpcf50633_client_dev_register(pcf, \"pcf50633-backlight\", &pcf->bl_pdev);\n\n\n\tfor (i = 0; i < PCF50633_NUM_REGULATORS; i++) {\n\t\tpdev = platform_device_alloc(\"pcf50633-regulator\", i);\n\t\tif (!pdev) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err2;\n\t\t}\n\n\t\tpdev->dev.parent = pcf->dev;\n\t\tret = platform_device_add_data(pdev, &pdata->reg_init_data[i],\n\t\t\t\t\t       sizeof(pdata->reg_init_data[i]));\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tret = platform_device_add(pdev);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tpcf->regulator_pdev[i] = pdev;\n\t}\n\n\tret = sysfs_create_group(&client->dev.kobj, &pcf_attr_group);\n\tif (ret)\n\t\tdev_warn(pcf->dev, \"error creating sysfs entries\\n\");\n\n\tif (pdata->probe_done)\n\t\tpdata->probe_done(pcf);\n\n\treturn 0;\n\nerr:\n\tplatform_device_put(pdev);\nerr2:\n\tfor (j = 0; j < i; j++)\n\t\tplatform_device_put(pcf->regulator_pdev[j]);\n\n\treturn ret;\n}\n\nstatic void pcf50633_remove(struct i2c_client *client)\n{\n\tstruct pcf50633 *pcf = i2c_get_clientdata(client);\n\tint i;\n\n\tsysfs_remove_group(&client->dev.kobj, &pcf_attr_group);\n\tpcf50633_irq_free(pcf);\n\n\tplatform_device_unregister(pcf->input_pdev);\n\tplatform_device_unregister(pcf->rtc_pdev);\n\tplatform_device_unregister(pcf->mbc_pdev);\n\tplatform_device_unregister(pcf->adc_pdev);\n\tplatform_device_unregister(pcf->bl_pdev);\n\n\tfor (i = 0; i < PCF50633_NUM_REGULATORS; i++)\n\t\tplatform_device_unregister(pcf->regulator_pdev[i]);\n}\n\nstatic const struct i2c_device_id pcf50633_id_table[] = {\n\t{\"pcf50633\", 0x73},\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, pcf50633_id_table);\n\nstatic struct i2c_driver pcf50633_driver = {\n\t.driver = {\n\t\t.name\t= \"pcf50633\",\n\t\t.pm\t= pm_sleep_ptr(&pcf50633_pm),\n\t},\n\t.id_table = pcf50633_id_table,\n\t.probe = pcf50633_probe,\n\t.remove = pcf50633_remove,\n};\n\nstatic int __init pcf50633_init(void)\n{\n\treturn i2c_add_driver(&pcf50633_driver);\n}\n\nstatic void __exit pcf50633_exit(void)\n{\n\ti2c_del_driver(&pcf50633_driver);\n}\n\nMODULE_DESCRIPTION(\"I2C chip driver for NXP PCF50633 PMU\");\nMODULE_AUTHOR(\"Harald Welte <laforge@openmoko.org>\");\nMODULE_LICENSE(\"GPL\");\n\nsubsys_initcall(pcf50633_init);\nmodule_exit(pcf50633_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}