{
  "module_name": "rave-sp.c",
  "hash_id": "e8d0430b77c6945b4deec4b4b2ee313d6599f6728706e2f609fe0425bb56c708",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/rave-sp.c",
  "human_readable_source": "\n\n \n\n#include <linux/atomic.h>\n#include <linux/crc-ccitt.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/mfd/rave-sp.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/sched.h>\n#include <linux/serdev.h>\n#include <asm/unaligned.h>\n\n \n#define RAVE_SP_STX\t\t\t0x02\n#define RAVE_SP_ETX\t\t\t0x03\n#define RAVE_SP_DLE\t\t\t0x10\n\n#define RAVE_SP_MAX_DATA_SIZE\t\t64\n#define RAVE_SP_CHECKSUM_8B2C\t\t1\n#define RAVE_SP_CHECKSUM_CCITT\t\t2\n#define RAVE_SP_CHECKSUM_SIZE\t\tRAVE_SP_CHECKSUM_CCITT\n \n#define RAVE_SP_RX_BUFFER_SIZE\t\t\t\t\\\n\t(RAVE_SP_MAX_DATA_SIZE + RAVE_SP_CHECKSUM_SIZE)\n\n#define RAVE_SP_STX_ETX_SIZE\t\t2\n \n#define RAVE_SP_TX_BUFFER_SIZE\t\t\t\t\\\n\t(RAVE_SP_STX_ETX_SIZE + 2 * RAVE_SP_RX_BUFFER_SIZE)\n\n \nenum rave_sp_deframer_state {\n\tRAVE_SP_EXPECT_SOF,\n\tRAVE_SP_EXPECT_DATA,\n\tRAVE_SP_EXPECT_ESCAPED_DATA,\n};\n\n \nstruct rave_sp_deframer {\n\tenum rave_sp_deframer_state state;\n\tunsigned char data[RAVE_SP_RX_BUFFER_SIZE];\n\tsize_t length;\n};\n\n \nstruct rave_sp_reply {\n\tsize_t length;\n\tvoid  *data;\n\tu8     code;\n\tu8     ackid;\n\tstruct completion received;\n};\n\n \nstruct rave_sp_checksum {\n\tsize_t length;\n\tvoid (*subroutine)(const u8 *, size_t, u8 *);\n};\n\nstruct rave_sp_version {\n\tu8     hardware;\n\t__le16 major;\n\tu8     minor;\n\tu8     letter[2];\n} __packed;\n\nstruct rave_sp_status {\n\tstruct rave_sp_version bootloader_version;\n\tstruct rave_sp_version firmware_version;\n\tu16 rdu_eeprom_flag;\n\tu16 dds_eeprom_flag;\n\tu8  pic_flag;\n\tu8  orientation;\n\tu32 etc;\n\ts16 temp[2];\n\tu8  backlight_current[3];\n\tu8  dip_switch;\n\tu8  host_interrupt;\n\tu16 voltage_28;\n\tu8  i2c_device_status;\n\tu8  power_status;\n\tu8  general_status;\n\tu8  deprecated1;\n\tu8  power_led_status;\n\tu8  deprecated2;\n\tu8  periph_power_shutoff;\n} __packed;\n\n \nstruct rave_sp_variant_cmds {\n\tint (*translate)(enum rave_sp_command);\n\tint (*get_status)(struct rave_sp *sp, struct rave_sp_status *);\n};\n\n \nstruct rave_sp_variant {\n\tconst struct rave_sp_checksum *checksum;\n\tstruct rave_sp_variant_cmds cmd;\n};\n\n \nstruct rave_sp {\n\tstruct serdev_device *serdev;\n\tstruct rave_sp_deframer deframer;\n\tatomic_t ackid;\n\tstruct mutex bus_lock;\n\tstruct mutex reply_lock;\n\tstruct rave_sp_reply *reply;\n\n\tconst struct rave_sp_variant *variant;\n\tstruct blocking_notifier_head event_notifier_list;\n\n\tconst char *part_number_firmware;\n\tconst char *part_number_bootloader;\n};\n\nstatic bool rave_sp_id_is_event(u8 code)\n{\n\treturn (code & 0xF0) == RAVE_SP_EVNT_BASE;\n}\n\nstatic void rave_sp_unregister_event_notifier(struct device *dev, void *res)\n{\n\tstruct rave_sp *sp = dev_get_drvdata(dev->parent);\n\tstruct notifier_block *nb = *(struct notifier_block **)res;\n\tstruct blocking_notifier_head *bnh = &sp->event_notifier_list;\n\n\tWARN_ON(blocking_notifier_chain_unregister(bnh, nb));\n}\n\nint devm_rave_sp_register_event_notifier(struct device *dev,\n\t\t\t\t\t struct notifier_block *nb)\n{\n\tstruct rave_sp *sp = dev_get_drvdata(dev->parent);\n\tstruct notifier_block **rcnb;\n\tint ret;\n\n\trcnb = devres_alloc(rave_sp_unregister_event_notifier,\n\t\t\t    sizeof(*rcnb), GFP_KERNEL);\n\tif (!rcnb)\n\t\treturn -ENOMEM;\n\n\tret = blocking_notifier_chain_register(&sp->event_notifier_list, nb);\n\tif (!ret) {\n\t\t*rcnb = nb;\n\t\tdevres_add(dev, rcnb);\n\t} else {\n\t\tdevres_free(rcnb);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(devm_rave_sp_register_event_notifier);\n\nstatic void csum_8b2c(const u8 *buf, size_t size, u8 *crc)\n{\n\t*crc = *buf++;\n\tsize--;\n\n\twhile (size--)\n\t\t*crc += *buf++;\n\n\t*crc = 1 + ~(*crc);\n}\n\nstatic void csum_ccitt(const u8 *buf, size_t size, u8 *crc)\n{\n\tconst u16 calculated = crc_ccitt_false(0xffff, buf, size);\n\n\t \n\tput_unaligned_be16(calculated, crc);\n}\n\nstatic void *stuff(unsigned char *dest, const unsigned char *src, size_t n)\n{\n\twhile (n--) {\n\t\tconst unsigned char byte = *src++;\n\n\t\tswitch (byte) {\n\t\tcase RAVE_SP_STX:\n\t\tcase RAVE_SP_ETX:\n\t\tcase RAVE_SP_DLE:\n\t\t\t*dest++ = RAVE_SP_DLE;\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\t*dest++ = byte;\n\t\t}\n\t}\n\n\treturn dest;\n}\n\nstatic int rave_sp_write(struct rave_sp *sp, const u8 *data, u8 data_size)\n{\n\tconst size_t checksum_length = sp->variant->checksum->length;\n\tunsigned char frame[RAVE_SP_TX_BUFFER_SIZE];\n\tunsigned char crc[RAVE_SP_CHECKSUM_SIZE];\n\tunsigned char *dest = frame;\n\tsize_t length;\n\n\tif (WARN_ON(checksum_length > sizeof(crc)))\n\t\treturn -ENOMEM;\n\n\tif (WARN_ON(data_size > sizeof(frame)))\n\t\treturn -ENOMEM;\n\n\tsp->variant->checksum->subroutine(data, data_size, crc);\n\n\t*dest++ = RAVE_SP_STX;\n\tdest = stuff(dest, data, data_size);\n\tdest = stuff(dest, crc, checksum_length);\n\t*dest++ = RAVE_SP_ETX;\n\n\tlength = dest - frame;\n\n\tprint_hex_dump_debug(\"rave-sp tx: \", DUMP_PREFIX_NONE,\n\t\t\t     16, 1, frame, length, false);\n\n\treturn serdev_device_write(sp->serdev, frame, length, HZ);\n}\n\nstatic u8 rave_sp_reply_code(u8 command)\n{\n\t \n\tswitch (command) {\n\tcase 0xA0 ... 0xBE:\n\t\t \n\t\treturn command + 0x20;\n\tcase 0xE0 ... 0xEF:\n\t\t \n\t\treturn command | 0x01;\n\tdefault:\n\t\t \n\t\treturn command + 0x40;\n\t}\n}\n\nint rave_sp_exec(struct rave_sp *sp,\n\t\t void *__data,  size_t data_size,\n\t\t void *reply_data, size_t reply_data_size)\n{\n\tstruct rave_sp_reply reply = {\n\t\t.data     = reply_data,\n\t\t.length   = reply_data_size,\n\t\t.received = COMPLETION_INITIALIZER_ONSTACK(reply.received),\n\t};\n\tunsigned char *data = __data;\n\tint command, ret = 0;\n\tu8 ackid;\n\n\tcommand = sp->variant->cmd.translate(data[0]);\n\tif (command < 0)\n\t\treturn command;\n\n\tackid       = atomic_inc_return(&sp->ackid);\n\treply.ackid = ackid;\n\treply.code  = rave_sp_reply_code((u8)command),\n\n\tmutex_lock(&sp->bus_lock);\n\n\tmutex_lock(&sp->reply_lock);\n\tsp->reply = &reply;\n\tmutex_unlock(&sp->reply_lock);\n\n\tdata[0] = command;\n\tdata[1] = ackid;\n\n\trave_sp_write(sp, data, data_size);\n\n\tif (!wait_for_completion_timeout(&reply.received, HZ)) {\n\t\tdev_err(&sp->serdev->dev, \"Command timeout\\n\");\n\t\tret = -ETIMEDOUT;\n\n\t\tmutex_lock(&sp->reply_lock);\n\t\tsp->reply = NULL;\n\t\tmutex_unlock(&sp->reply_lock);\n\t}\n\n\tmutex_unlock(&sp->bus_lock);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(rave_sp_exec);\n\nstatic void rave_sp_receive_event(struct rave_sp *sp,\n\t\t\t\t  const unsigned char *data, size_t length)\n{\n\tu8 cmd[] = {\n\t\t[0] = rave_sp_reply_code(data[0]),\n\t\t[1] = data[1],\n\t};\n\n\trave_sp_write(sp, cmd, sizeof(cmd));\n\n\tblocking_notifier_call_chain(&sp->event_notifier_list,\n\t\t\t\t     rave_sp_action_pack(data[0], data[2]),\n\t\t\t\t     NULL);\n}\n\nstatic void rave_sp_receive_reply(struct rave_sp *sp,\n\t\t\t\t  const unsigned char *data, size_t length)\n{\n\tstruct device *dev = &sp->serdev->dev;\n\tstruct rave_sp_reply *reply;\n\tconst  size_t payload_length = length - 2;\n\n\tmutex_lock(&sp->reply_lock);\n\treply = sp->reply;\n\n\tif (reply) {\n\t\tif (reply->code == data[0] && reply->ackid == data[1] &&\n\t\t    payload_length >= reply->length) {\n\t\t\t \n\t\t\tmemcpy(reply->data, &data[2], reply->length);\n\t\t\tcomplete(&reply->received);\n\t\t\tsp->reply = NULL;\n\t\t} else {\n\t\t\tdev_err(dev, \"Ignoring incorrect reply\\n\");\n\t\t\tdev_dbg(dev, \"Code:   expected = 0x%08x received = 0x%08x\\n\",\n\t\t\t\treply->code, data[0]);\n\t\t\tdev_dbg(dev, \"ACK ID: expected = 0x%08x received = 0x%08x\\n\",\n\t\t\t\treply->ackid, data[1]);\n\t\t\tdev_dbg(dev, \"Length: expected = %zu received = %zu\\n\",\n\t\t\t\treply->length, payload_length);\n\t\t}\n\t}\n\n\tmutex_unlock(&sp->reply_lock);\n}\n\nstatic void rave_sp_receive_frame(struct rave_sp *sp,\n\t\t\t\t  const unsigned char *data,\n\t\t\t\t  size_t length)\n{\n\tconst size_t checksum_length = sp->variant->checksum->length;\n\tconst size_t payload_length  = length - checksum_length;\n\tconst u8 *crc_reported       = &data[payload_length];\n\tstruct device *dev           = &sp->serdev->dev;\n\tu8 crc_calculated[RAVE_SP_CHECKSUM_SIZE];\n\n\tif (unlikely(checksum_length > sizeof(crc_calculated))) {\n\t\tdev_warn(dev, \"Checksum too long, dropping\\n\");\n\t\treturn;\n\t}\n\n\tprint_hex_dump_debug(\"rave-sp rx: \", DUMP_PREFIX_NONE,\n\t\t\t     16, 1, data, length, false);\n\n\tif (unlikely(length <= checksum_length)) {\n\t\tdev_warn(dev, \"Dropping short frame\\n\");\n\t\treturn;\n\t}\n\n\tsp->variant->checksum->subroutine(data, payload_length,\n\t\t\t\t\t  crc_calculated);\n\n\tif (memcmp(crc_calculated, crc_reported, checksum_length)) {\n\t\tdev_warn(dev, \"Dropping bad frame\\n\");\n\t\treturn;\n\t}\n\n\tif (rave_sp_id_is_event(data[0]))\n\t\trave_sp_receive_event(sp, data, length);\n\telse\n\t\trave_sp_receive_reply(sp, data, length);\n}\n\nstatic int rave_sp_receive_buf(struct serdev_device *serdev,\n\t\t\t       const unsigned char *buf, size_t size)\n{\n\tstruct device *dev = &serdev->dev;\n\tstruct rave_sp *sp = dev_get_drvdata(dev);\n\tstruct rave_sp_deframer *deframer = &sp->deframer;\n\tconst unsigned char *src = buf;\n\tconst unsigned char *end = buf + size;\n\n\twhile (src < end) {\n\t\tconst unsigned char byte = *src++;\n\n\t\tswitch (deframer->state) {\n\t\tcase RAVE_SP_EXPECT_SOF:\n\t\t\tif (byte == RAVE_SP_STX)\n\t\t\t\tdeframer->state = RAVE_SP_EXPECT_DATA;\n\t\t\tbreak;\n\n\t\tcase RAVE_SP_EXPECT_DATA:\n\t\t\t \n\t\t\tswitch (byte) {\n\t\t\tcase RAVE_SP_ETX:\n\t\t\t\trave_sp_receive_frame(sp,\n\t\t\t\t\t\t      deframer->data,\n\t\t\t\t\t\t      deframer->length);\n\t\t\t\t \n\t\t\t\tgoto reset_framer;\n\t\t\tcase RAVE_SP_STX:\n\t\t\t\tdev_warn(dev, \"Bad frame: STX before ETX\\n\");\n\t\t\t\t \n\t\t\t\tgoto reset_framer;\n\t\t\tcase RAVE_SP_DLE:\n\t\t\t\tdeframer->state = RAVE_SP_EXPECT_ESCAPED_DATA;\n\t\t\t\t \n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t \n\n\t\t\tfallthrough;\n\n\t\tcase RAVE_SP_EXPECT_ESCAPED_DATA:\n\t\t\tif (deframer->length == sizeof(deframer->data)) {\n\t\t\t\tdev_warn(dev, \"Bad frame: Too long\\n\");\n\t\t\t\t \n\t\t\t\tgoto reset_framer;\n\t\t\t}\n\n\t\t\tdeframer->data[deframer->length++] = byte;\n\n\t\t\t \n\t\t\tdeframer->state = RAVE_SP_EXPECT_DATA;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\treturn size;\n\nreset_framer:\n\t \n\tdeframer->state  = RAVE_SP_EXPECT_SOF;\n\tdeframer->length = 0;\n\n\treturn src - buf;\n}\n\nstatic int rave_sp_rdu1_cmd_translate(enum rave_sp_command command)\n{\n\tif (command >= RAVE_SP_CMD_STATUS &&\n\t    command <= RAVE_SP_CMD_CONTROL_EVENTS)\n\t\treturn command;\n\n\treturn -EINVAL;\n}\n\nstatic int rave_sp_rdu2_cmd_translate(enum rave_sp_command command)\n{\n\tif (command >= RAVE_SP_CMD_GET_FIRMWARE_VERSION &&\n\t    command <= RAVE_SP_CMD_GET_GPIO_STATE)\n\t\treturn command;\n\n\tif (command == RAVE_SP_CMD_REQ_COPPER_REV) {\n\t\t \n\t\treturn 0x28;\n\t}\n\n\treturn rave_sp_rdu1_cmd_translate(command);\n}\n\nstatic int rave_sp_default_cmd_translate(enum rave_sp_command command)\n{\n\t \n\tswitch (command) {\n\tcase RAVE_SP_CMD_GET_FIRMWARE_VERSION:\n\t\treturn 0x11;\n\tcase RAVE_SP_CMD_GET_BOOTLOADER_VERSION:\n\t\treturn 0x12;\n\tcase RAVE_SP_CMD_BOOT_SOURCE:\n\t\treturn 0x14;\n\tcase RAVE_SP_CMD_SW_WDT:\n\t\treturn 0x1C;\n\tcase RAVE_SP_CMD_PET_WDT:\n\t\treturn 0x1D;\n\tcase RAVE_SP_CMD_RESET:\n\t\treturn 0x1E;\n\tcase RAVE_SP_CMD_RESET_REASON:\n\t\treturn 0x1F;\n\tcase RAVE_SP_CMD_RMB_EEPROM:\n\t\treturn 0x20;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const char *devm_rave_sp_version(struct device *dev,\n\t\t\t\t\tstruct rave_sp_version *version)\n{\n\t \n\treturn devm_kasprintf(dev, GFP_KERNEL, \"%02d%02d%02d.%c%c\\n\",\n\t\t\t      version->hardware,\n\t\t\t      le16_to_cpu(version->major),\n\t\t\t      version->minor,\n\t\t\t      version->letter[0],\n\t\t\t      version->letter[1]);\n}\n\nstatic int rave_sp_rdu1_get_status(struct rave_sp *sp,\n\t\t\t\t   struct rave_sp_status *status)\n{\n\tu8 cmd[] = {\n\t\t[0] = RAVE_SP_CMD_STATUS,\n\t\t[1] = 0\n\t};\n\n\treturn rave_sp_exec(sp, cmd, sizeof(cmd), status, sizeof(*status));\n}\n\nstatic int rave_sp_emulated_get_status(struct rave_sp *sp,\n\t\t\t\t       struct rave_sp_status *status)\n{\n\tu8 cmd[] = {\n\t\t[0] = RAVE_SP_CMD_GET_FIRMWARE_VERSION,\n\t\t[1] = 0,\n\t};\n\tint ret;\n\n\tret = rave_sp_exec(sp, cmd, sizeof(cmd), &status->firmware_version,\n\t\t\t   sizeof(status->firmware_version));\n\tif (ret)\n\t\treturn ret;\n\n\tcmd[0] = RAVE_SP_CMD_GET_BOOTLOADER_VERSION;\n\treturn rave_sp_exec(sp, cmd, sizeof(cmd), &status->bootloader_version,\n\t\t\t    sizeof(status->bootloader_version));\n}\n\nstatic int rave_sp_get_status(struct rave_sp *sp)\n{\n\tstruct device *dev = &sp->serdev->dev;\n\tstruct rave_sp_status status;\n\tconst char *version;\n\tint ret;\n\n\tret = sp->variant->cmd.get_status(sp, &status);\n\tif (ret)\n\t\treturn ret;\n\n\tversion = devm_rave_sp_version(dev, &status.firmware_version);\n\tif (!version)\n\t\treturn -ENOMEM;\n\n\tsp->part_number_firmware = version;\n\n\tversion = devm_rave_sp_version(dev, &status.bootloader_version);\n\tif (!version)\n\t\treturn -ENOMEM;\n\n\tsp->part_number_bootloader = version;\n\n\treturn 0;\n}\n\nstatic const struct rave_sp_checksum rave_sp_checksum_8b2c = {\n\t.length     = 1,\n\t.subroutine = csum_8b2c,\n};\n\nstatic const struct rave_sp_checksum rave_sp_checksum_ccitt = {\n\t.length     = 2,\n\t.subroutine = csum_ccitt,\n};\n\nstatic const struct rave_sp_variant rave_sp_legacy = {\n\t.checksum = &rave_sp_checksum_ccitt,\n\t.cmd = {\n\t\t.translate = rave_sp_default_cmd_translate,\n\t\t.get_status = rave_sp_emulated_get_status,\n\t},\n};\n\nstatic const struct rave_sp_variant rave_sp_rdu1 = {\n\t.checksum = &rave_sp_checksum_8b2c,\n\t.cmd = {\n\t\t.translate = rave_sp_rdu1_cmd_translate,\n\t\t.get_status = rave_sp_rdu1_get_status,\n\t},\n};\n\nstatic const struct rave_sp_variant rave_sp_rdu2 = {\n\t.checksum = &rave_sp_checksum_ccitt,\n\t.cmd = {\n\t\t.translate = rave_sp_rdu2_cmd_translate,\n\t\t.get_status = rave_sp_emulated_get_status,\n\t},\n};\n\nstatic const struct of_device_id rave_sp_dt_ids[] = {\n\t{ .compatible = \"zii,rave-sp-niu\",  .data = &rave_sp_legacy },\n\t{ .compatible = \"zii,rave-sp-mezz\", .data = &rave_sp_legacy },\n\t{ .compatible = \"zii,rave-sp-esb\",  .data = &rave_sp_legacy },\n\t{ .compatible = \"zii,rave-sp-rdu1\", .data = &rave_sp_rdu1   },\n\t{ .compatible = \"zii,rave-sp-rdu2\", .data = &rave_sp_rdu2   },\n\t{   }\n};\n\nstatic const struct serdev_device_ops rave_sp_serdev_device_ops = {\n\t.receive_buf  = rave_sp_receive_buf,\n\t.write_wakeup = serdev_device_write_wakeup,\n};\n\nstatic int rave_sp_probe(struct serdev_device *serdev)\n{\n\tstruct device *dev = &serdev->dev;\n\tconst char *unknown = \"unknown\\n\";\n\tstruct rave_sp *sp;\n\tu32 baud;\n\tint ret;\n\n\tif (of_property_read_u32(dev->of_node, \"current-speed\", &baud)) {\n\t\tdev_err(dev,\n\t\t\t\"'current-speed' is not specified in device node\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsp = devm_kzalloc(dev, sizeof(*sp), GFP_KERNEL);\n\tif (!sp)\n\t\treturn -ENOMEM;\n\n\tsp->serdev = serdev;\n\tdev_set_drvdata(dev, sp);\n\n\tsp->variant = of_device_get_match_data(dev);\n\tif (!sp->variant)\n\t\treturn -ENODEV;\n\n\tmutex_init(&sp->bus_lock);\n\tmutex_init(&sp->reply_lock);\n\tBLOCKING_INIT_NOTIFIER_HEAD(&sp->event_notifier_list);\n\n\tserdev_device_set_client_ops(serdev, &rave_sp_serdev_device_ops);\n\tret = devm_serdev_device_open(dev, serdev);\n\tif (ret)\n\t\treturn ret;\n\n\tserdev_device_set_baudrate(serdev, baud);\n\tserdev_device_set_flow_control(serdev, false);\n\n\tret = serdev_device_set_parity(serdev, SERDEV_PARITY_NONE);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to set parity\\n\");\n\t\treturn ret;\n\t}\n\n\tret = rave_sp_get_status(sp);\n\tif (ret) {\n\t\tdev_warn(dev, \"Failed to get firmware status: %d\\n\", ret);\n\t\tsp->part_number_firmware   = unknown;\n\t\tsp->part_number_bootloader = unknown;\n\t}\n\n\t \n\tdev_info(dev, \"Firmware version: %s\",   sp->part_number_firmware);\n\tdev_info(dev, \"Bootloader version: %s\", sp->part_number_bootloader);\n\n\treturn devm_of_platform_populate(dev);\n}\n\nMODULE_DEVICE_TABLE(of, rave_sp_dt_ids);\n\nstatic struct serdev_device_driver rave_sp_drv = {\n\t.probe\t\t\t= rave_sp_probe,\n\t.driver = {\n\t\t.name\t\t= \"rave-sp\",\n\t\t.of_match_table\t= rave_sp_dt_ids,\n\t},\n};\nmodule_serdev_device_driver(rave_sp_drv);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Andrey Vostrikov <andrey.vostrikov@cogentembedded.com>\");\nMODULE_AUTHOR(\"Nikita Yushchenko <nikita.yoush@cogentembedded.com>\");\nMODULE_AUTHOR(\"Andrey Smirnov <andrew.smirnov@gmail.com>\");\nMODULE_DESCRIPTION(\"RAVE SP core driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}