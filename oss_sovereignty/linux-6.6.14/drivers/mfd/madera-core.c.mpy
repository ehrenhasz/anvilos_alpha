{
  "module_name": "madera-core.c",
  "hash_id": "247442d80b93fb145deadd5f7973fb49e358b38cb31ae0baabf6d7553648748f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/madera-core.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/gpio/consumer.h>\n#include <linux/mfd/core.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/notifier.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/regulator/machine.h>\n#include <linux/regulator/of_regulator.h>\n\n#include <linux/mfd/madera/core.h>\n#include <linux/mfd/madera/registers.h>\n\n#include \"madera.h\"\n\n#define CS47L15_SILICON_ID\t0x6370\n#define CS47L35_SILICON_ID\t0x6360\n#define CS47L85_SILICON_ID\t0x6338\n#define CS47L90_SILICON_ID\t0x6364\n#define CS47L92_SILICON_ID\t0x6371\n\n#define MADERA_32KZ_MCLK2\t1\n\n#define MADERA_RESET_MIN_US\t2000\n#define MADERA_RESET_MAX_US\t3000\n\n#define ERRATA_DCVDD_MIN_US\t10000\n#define ERRATA_DCVDD_MAX_US\t15000\n\nstatic const char * const madera_core_supplies[] = {\n\t\"AVDD\",\n\t\"DBVDD1\",\n};\n\nstatic const struct mfd_cell madera_ldo1_devs[] = {\n\t{\n\t\t.name = \"madera-ldo1\",\n\t\t.level = MFD_DEP_LEVEL_HIGH,\n\t},\n};\n\nstatic const char * const cs47l15_supplies[] = {\n\t\"MICVDD\",\n\t\"CPVDD1\",\n\t\"SPKVDD\",\n};\n\nstatic const struct mfd_cell cs47l15_devs[] = {\n\t{ .name = \"madera-pinctrl\", },\n\t{ .name = \"madera-irq\", },\n\t{ .name = \"madera-gpio\", },\n\t{\n\t\t.name = \"madera-extcon\",\n\t\t.parent_supplies = cs47l15_supplies,\n\t\t.num_parent_supplies = 1,  \n\t},\n\t{\n\t\t.name = \"cs47l15-codec\",\n\t\t.parent_supplies = cs47l15_supplies,\n\t\t.num_parent_supplies = ARRAY_SIZE(cs47l15_supplies),\n\t},\n};\n\nstatic const char * const cs47l35_supplies[] = {\n\t\"MICVDD\",\n\t\"DBVDD2\",\n\t\"CPVDD1\",\n\t\"CPVDD2\",\n\t\"SPKVDD\",\n};\n\nstatic const struct mfd_cell cs47l35_devs[] = {\n\t{ .name = \"madera-pinctrl\", },\n\t{ .name = \"madera-irq\", },\n\t{ .name = \"madera-micsupp\", },\n\t{ .name = \"madera-gpio\", },\n\t{\n\t\t.name = \"madera-extcon\",\n\t\t.parent_supplies = cs47l35_supplies,\n\t\t.num_parent_supplies = 1,  \n\t},\n\t{\n\t\t.name = \"cs47l35-codec\",\n\t\t.parent_supplies = cs47l35_supplies,\n\t\t.num_parent_supplies = ARRAY_SIZE(cs47l35_supplies),\n\t},\n};\n\nstatic const char * const cs47l85_supplies[] = {\n\t\"MICVDD\",\n\t\"DBVDD2\",\n\t\"DBVDD3\",\n\t\"DBVDD4\",\n\t\"CPVDD1\",\n\t\"CPVDD2\",\n\t\"SPKVDDL\",\n\t\"SPKVDDR\",\n};\n\nstatic const struct mfd_cell cs47l85_devs[] = {\n\t{ .name = \"madera-pinctrl\", },\n\t{ .name = \"madera-irq\", },\n\t{ .name = \"madera-micsupp\", },\n\t{ .name = \"madera-gpio\", },\n\t{\n\t\t.name = \"madera-extcon\",\n\t\t.parent_supplies = cs47l85_supplies,\n\t\t.num_parent_supplies = 1,  \n\t},\n\t{\n\t\t.name = \"cs47l85-codec\",\n\t\t.parent_supplies = cs47l85_supplies,\n\t\t.num_parent_supplies = ARRAY_SIZE(cs47l85_supplies),\n\t},\n};\n\nstatic const char * const cs47l90_supplies[] = {\n\t\"MICVDD\",\n\t\"DBVDD2\",\n\t\"DBVDD3\",\n\t\"DBVDD4\",\n\t\"CPVDD1\",\n\t\"CPVDD2\",\n};\n\nstatic const struct mfd_cell cs47l90_devs[] = {\n\t{ .name = \"madera-pinctrl\", },\n\t{ .name = \"madera-irq\", },\n\t{ .name = \"madera-micsupp\", },\n\t{ .name = \"madera-gpio\", },\n\t{\n\t\t.name = \"madera-extcon\",\n\t\t.parent_supplies = cs47l90_supplies,\n\t\t.num_parent_supplies = 1,  \n\t},\n\t{\n\t\t.name = \"cs47l90-codec\",\n\t\t.parent_supplies = cs47l90_supplies,\n\t\t.num_parent_supplies = ARRAY_SIZE(cs47l90_supplies),\n\t},\n};\n\nstatic const char * const cs47l92_supplies[] = {\n\t\"MICVDD\",\n\t\"CPVDD1\",\n\t\"CPVDD2\",\n};\n\nstatic const struct mfd_cell cs47l92_devs[] = {\n\t{ .name = \"madera-pinctrl\", },\n\t{ .name = \"madera-irq\", },\n\t{ .name = \"madera-micsupp\", },\n\t{ .name = \"madera-gpio\", },\n\t{\n\t\t.name = \"madera-extcon\",\n\t\t.parent_supplies = cs47l92_supplies,\n\t\t.num_parent_supplies = 1,  \n\t},\n\t{\n\t\t.name = \"cs47l92-codec\",\n\t\t.parent_supplies = cs47l92_supplies,\n\t\t.num_parent_supplies = ARRAY_SIZE(cs47l92_supplies),\n\t},\n};\n\n \nconst char *madera_name_from_type(enum madera_type type)\n{\n\tswitch (type) {\n\tcase CS47L15:\n\t\treturn \"CS47L15\";\n\tcase CS47L35:\n\t\treturn \"CS47L35\";\n\tcase CS47L85:\n\t\treturn \"CS47L85\";\n\tcase CS47L90:\n\t\treturn \"CS47L90\";\n\tcase CS47L91:\n\t\treturn \"CS47L91\";\n\tcase CS42L92:\n\t\treturn \"CS42L92\";\n\tcase CS47L92:\n\t\treturn \"CS47L92\";\n\tcase CS47L93:\n\t\treturn \"CS47L93\";\n\tcase WM1840:\n\t\treturn \"WM1840\";\n\tdefault:\n\t\treturn \"Unknown\";\n\t}\n}\nEXPORT_SYMBOL_GPL(madera_name_from_type);\n\n#define MADERA_BOOT_POLL_INTERVAL_USEC\t\t5000\n#define MADERA_BOOT_POLL_TIMEOUT_USEC\t\t25000\n\nstatic int madera_wait_for_boot_noack(struct madera *madera)\n{\n\tktime_t timeout;\n\tunsigned int val = 0;\n\tint ret = 0;\n\n\t \n\ttimeout = ktime_add_us(ktime_get(), MADERA_BOOT_POLL_TIMEOUT_USEC);\n\tregmap_read(madera->regmap, MADERA_IRQ1_RAW_STATUS_1, &val);\n\twhile (!(val & MADERA_BOOT_DONE_STS1) &&\n\t       !ktime_after(ktime_get(), timeout)) {\n\t\tusleep_range(MADERA_BOOT_POLL_INTERVAL_USEC / 2,\n\t\t\t     MADERA_BOOT_POLL_INTERVAL_USEC);\n\t\tregmap_read(madera->regmap, MADERA_IRQ1_RAW_STATUS_1, &val);\n\t}\n\n\tif (!(val & MADERA_BOOT_DONE_STS1)) {\n\t\tdev_err(madera->dev, \"Polling BOOT_DONE_STS timed out\\n\");\n\t\tret = -ETIMEDOUT;\n\t}\n\n\treturn ret;\n}\n\nstatic int madera_wait_for_boot(struct madera *madera)\n{\n\tint ret = madera_wait_for_boot_noack(madera);\n\n\t \n\tregmap_write(madera->regmap, MADERA_IRQ1_STATUS_1,\n\t\t     MADERA_BOOT_DONE_EINT1);\n\n\tpm_runtime_mark_last_busy(madera->dev);\n\n\treturn ret;\n}\n\nstatic int madera_soft_reset(struct madera *madera)\n{\n\tint ret;\n\n\tret = regmap_write(madera->regmap, MADERA_SOFTWARE_RESET, 0);\n\tif (ret != 0) {\n\t\tdev_err(madera->dev, \"Failed to soft reset device: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tusleep_range(MADERA_RESET_MIN_US, MADERA_RESET_MAX_US);\n\n\treturn 0;\n}\n\nstatic void madera_enable_hard_reset(struct madera *madera)\n{\n\t \n\tgpiod_set_raw_value_cansleep(madera->pdata.reset, 0);\n}\n\nstatic void madera_disable_hard_reset(struct madera *madera)\n{\n\tgpiod_set_raw_value_cansleep(madera->pdata.reset, 1);\n\n\tusleep_range(MADERA_RESET_MIN_US, MADERA_RESET_MAX_US);\n}\n\nstatic int __maybe_unused madera_runtime_resume(struct device *dev)\n{\n\tstruct madera *madera = dev_get_drvdata(dev);\n\tint ret;\n\n\tdev_dbg(dev, \"Leaving sleep mode\\n\");\n\n\tif (!madera->reset_errata)\n\t\tmadera_enable_hard_reset(madera);\n\n\tret = regulator_enable(madera->dcvdd);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to enable DCVDD: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tregcache_cache_only(madera->regmap, false);\n\tregcache_cache_only(madera->regmap_32bit, false);\n\n\tif (madera->reset_errata)\n\t\tusleep_range(ERRATA_DCVDD_MIN_US, ERRATA_DCVDD_MAX_US);\n\telse\n\t\tmadera_disable_hard_reset(madera);\n\n\tif (!madera->pdata.reset || madera->reset_errata) {\n\t\tret = madera_wait_for_boot(madera);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tret = madera_soft_reset(madera);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to reset: %d\\n\", ret);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tret = madera_wait_for_boot(madera);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regcache_sync(madera->regmap);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to restore 16-bit register cache\\n\");\n\t\tgoto err;\n\t}\n\n\tret = regcache_sync(madera->regmap_32bit);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to restore 32-bit register cache\\n\");\n\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tregcache_cache_only(madera->regmap_32bit, true);\n\tregcache_cache_only(madera->regmap, true);\n\tregulator_disable(madera->dcvdd);\n\n\treturn ret;\n}\n\nstatic int __maybe_unused madera_runtime_suspend(struct device *dev)\n{\n\tstruct madera *madera = dev_get_drvdata(dev);\n\n\tdev_dbg(madera->dev, \"Entering sleep mode\\n\");\n\n\tregcache_cache_only(madera->regmap, true);\n\tregcache_mark_dirty(madera->regmap);\n\tregcache_cache_only(madera->regmap_32bit, true);\n\tregcache_mark_dirty(madera->regmap_32bit);\n\n\tregulator_disable(madera->dcvdd);\n\n\treturn 0;\n}\n\nconst struct dev_pm_ops madera_pm_ops = {\n\tSET_RUNTIME_PM_OPS(madera_runtime_suspend,\n\t\t\t   madera_runtime_resume,\n\t\t\t   NULL)\n};\nEXPORT_SYMBOL_GPL(madera_pm_ops);\n\nconst struct of_device_id madera_of_match[] = {\n\t{ .compatible = \"cirrus,cs47l15\", .data = (void *)CS47L15 },\n\t{ .compatible = \"cirrus,cs47l35\", .data = (void *)CS47L35 },\n\t{ .compatible = \"cirrus,cs47l85\", .data = (void *)CS47L85 },\n\t{ .compatible = \"cirrus,cs47l90\", .data = (void *)CS47L90 },\n\t{ .compatible = \"cirrus,cs47l91\", .data = (void *)CS47L91 },\n\t{ .compatible = \"cirrus,cs42l92\", .data = (void *)CS42L92 },\n\t{ .compatible = \"cirrus,cs47l92\", .data = (void *)CS47L92 },\n\t{ .compatible = \"cirrus,cs47l93\", .data = (void *)CS47L93 },\n\t{ .compatible = \"cirrus,wm1840\", .data = (void *)WM1840 },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, madera_of_match);\nEXPORT_SYMBOL_GPL(madera_of_match);\n\nstatic int madera_get_reset_gpio(struct madera *madera)\n{\n\tstruct gpio_desc *reset;\n\n\tif (madera->pdata.reset)\n\t\treturn 0;\n\n\treset = devm_gpiod_get_optional(madera->dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(reset))\n\t\treturn dev_err_probe(madera->dev, PTR_ERR(reset),\n\t\t\t\t\"Failed to request /RESET\");\n\n\t \n\tif (!reset)\n\t\tdev_warn(madera->dev,\n\t\t\t \"Running without reset GPIO is not recommended\\n\");\n\n\tmadera->pdata.reset = reset;\n\n\treturn 0;\n}\n\nstatic void madera_set_micbias_info(struct madera *madera)\n{\n\t \n\tswitch (madera->type) {\n\tcase CS47L15:\n\t\tmadera->num_micbias = 1;\n\t\tmadera->num_childbias[0] = 3;\n\t\treturn;\n\tcase CS47L35:\n\t\tmadera->num_micbias = 2;\n\t\tmadera->num_childbias[0] = 2;\n\t\tmadera->num_childbias[1] = 2;\n\t\treturn;\n\tcase CS47L85:\n\tcase WM1840:\n\t\tmadera->num_micbias = 4;\n\t\t \n\t\treturn;\n\tcase CS47L90:\n\tcase CS47L91:\n\t\tmadera->num_micbias = 2;\n\t\tmadera->num_childbias[0] = 4;\n\t\tmadera->num_childbias[1] = 4;\n\t\treturn;\n\tcase CS42L92:\n\tcase CS47L92:\n\tcase CS47L93:\n\t\tmadera->num_micbias = 2;\n\t\tmadera->num_childbias[0] = 4;\n\t\tmadera->num_childbias[1] = 2;\n\t\treturn;\n\tdefault:\n\t\treturn;\n\t}\n}\n\nint madera_dev_init(struct madera *madera)\n{\n\tstruct device *dev = madera->dev;\n\tunsigned int hwid;\n\tint (*patch_fn)(struct madera *) = NULL;\n\tconst struct mfd_cell *mfd_devs;\n\tint n_devs = 0;\n\tint i, ret;\n\n\tdev_set_drvdata(madera->dev, madera);\n\tBLOCKING_INIT_NOTIFIER_HEAD(&madera->notifier);\n\tmutex_init(&madera->dapm_ptr_lock);\n\n\tmadera_set_micbias_info(madera);\n\n\t \n\tif (dev_get_platdata(madera->dev)) {\n\t\tmemcpy(&madera->pdata, dev_get_platdata(madera->dev),\n\t\t       sizeof(madera->pdata));\n\t}\n\n\tmadera->mclk[MADERA_MCLK1].id = \"mclk1\";\n\tmadera->mclk[MADERA_MCLK2].id = \"mclk2\";\n\tmadera->mclk[MADERA_MCLK3].id = \"mclk3\";\n\n\tret = devm_clk_bulk_get_optional(madera->dev, ARRAY_SIZE(madera->mclk),\n\t\t\t\t\t madera->mclk);\n\tif (ret) {\n\t\tdev_err(madera->dev, \"Failed to get clocks: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (!madera->mclk[MADERA_MCLK2].clk)\n\t\tdev_warn(madera->dev, \"Missing MCLK2, requires 32kHz clock\\n\");\n\n\tret = madera_get_reset_gpio(madera);\n\tif (ret)\n\t\treturn ret;\n\n\tregcache_cache_only(madera->regmap, true);\n\tregcache_cache_only(madera->regmap_32bit, true);\n\n\tfor (i = 0; i < ARRAY_SIZE(madera_core_supplies); i++)\n\t\tmadera->core_supplies[i].supply = madera_core_supplies[i];\n\n\tmadera->num_core_supplies = ARRAY_SIZE(madera_core_supplies);\n\n\t \n\tswitch (madera->type) {\n\tcase CS47L15:\n\t\tmadera->reset_errata = true;\n\t\tbreak;\n\tcase CS47L35:\n\tcase CS47L90:\n\tcase CS47L91:\n\tcase CS42L92:\n\tcase CS47L92:\n\tcase CS47L93:\n\t\tbreak;\n\tcase CS47L85:\n\tcase WM1840:\n\t\tret = mfd_add_devices(madera->dev, PLATFORM_DEVID_NONE,\n\t\t\t\t      madera_ldo1_devs,\n\t\t\t\t      ARRAY_SIZE(madera_ldo1_devs),\n\t\t\t\t      NULL, 0, NULL);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to add LDO1 child: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tdev_err(madera->dev, \"Unknown device type %d\\n\", madera->type);\n\t\treturn -ENODEV;\n\t}\n\n\tret = devm_regulator_bulk_get(dev, madera->num_core_supplies,\n\t\t\t\t      madera->core_supplies);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to request core supplies: %d\\n\", ret);\n\t\tgoto err_devs;\n\t}\n\n\t \n\tmadera->dcvdd = regulator_get(madera->dev, \"DCVDD\");\n\tif (IS_ERR(madera->dcvdd)) {\n\t\tret = PTR_ERR(madera->dcvdd);\n\t\tdev_err(dev, \"Failed to request DCVDD: %d\\n\", ret);\n\t\tgoto err_devs;\n\t}\n\n\tret = regulator_bulk_enable(madera->num_core_supplies,\n\t\t\t\t    madera->core_supplies);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to enable core supplies: %d\\n\", ret);\n\t\tgoto err_dcvdd;\n\t}\n\n\tif (madera->reset_errata)\n\t\tmadera_disable_hard_reset(madera);\n\n\tret = regulator_enable(madera->dcvdd);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to enable DCVDD: %d\\n\", ret);\n\t\tgoto err_enable;\n\t}\n\n\tif (madera->reset_errata)\n\t\tusleep_range(ERRATA_DCVDD_MIN_US, ERRATA_DCVDD_MAX_US);\n\telse\n\t\tmadera_disable_hard_reset(madera);\n\n\tregcache_cache_only(madera->regmap, false);\n\tregcache_cache_only(madera->regmap_32bit, false);\n\n\tret = madera_wait_for_boot_noack(madera);\n\tif (ret) {\n\t\tdev_err(madera->dev, \"Device failed initial boot: %d\\n\", ret);\n\t\tgoto err_reset;\n\t}\n\n\t \n\tret = regmap_read(madera->regmap, MADERA_SOFTWARE_RESET, &hwid);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to read ID register: %d\\n\", ret);\n\t\tgoto err_reset;\n\t}\n\n\tswitch (hwid) {\n\tcase CS47L15_SILICON_ID:\n\t\tif (IS_ENABLED(CONFIG_MFD_CS47L15)) {\n\t\t\tswitch (madera->type) {\n\t\t\tcase CS47L15:\n\t\t\t\tpatch_fn = &cs47l15_patch;\n\t\t\t\tmfd_devs = cs47l15_devs;\n\t\t\t\tn_devs = ARRAY_SIZE(cs47l15_devs);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase CS47L35_SILICON_ID:\n\t\tif (IS_ENABLED(CONFIG_MFD_CS47L35)) {\n\t\t\tswitch (madera->type) {\n\t\t\tcase CS47L35:\n\t\t\t\tpatch_fn = cs47l35_patch;\n\t\t\t\tmfd_devs = cs47l35_devs;\n\t\t\t\tn_devs = ARRAY_SIZE(cs47l35_devs);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase CS47L85_SILICON_ID:\n\t\tif (IS_ENABLED(CONFIG_MFD_CS47L85)) {\n\t\t\tswitch (madera->type) {\n\t\t\tcase CS47L85:\n\t\t\tcase WM1840:\n\t\t\t\tpatch_fn = cs47l85_patch;\n\t\t\t\tmfd_devs = cs47l85_devs;\n\t\t\t\tn_devs = ARRAY_SIZE(cs47l85_devs);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase CS47L90_SILICON_ID:\n\t\tif (IS_ENABLED(CONFIG_MFD_CS47L90)) {\n\t\t\tswitch (madera->type) {\n\t\t\tcase CS47L90:\n\t\t\tcase CS47L91:\n\t\t\t\tpatch_fn = cs47l90_patch;\n\t\t\t\tmfd_devs = cs47l90_devs;\n\t\t\t\tn_devs = ARRAY_SIZE(cs47l90_devs);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase CS47L92_SILICON_ID:\n\t\tif (IS_ENABLED(CONFIG_MFD_CS47L92)) {\n\t\t\tswitch (madera->type) {\n\t\t\tcase CS42L92:\n\t\t\tcase CS47L92:\n\t\t\tcase CS47L93:\n\t\t\t\tpatch_fn = cs47l92_patch;\n\t\t\t\tmfd_devs = cs47l92_devs;\n\t\t\t\tn_devs = ARRAY_SIZE(cs47l92_devs);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(madera->dev, \"Unknown device ID: %x\\n\", hwid);\n\t\tret = -EINVAL;\n\t\tgoto err_reset;\n\t}\n\n\tif (!n_devs) {\n\t\tdev_err(madera->dev, \"Device ID 0x%x not a %s\\n\", hwid,\n\t\t\tmadera->type_name);\n\t\tret = -ENODEV;\n\t\tgoto err_reset;\n\t}\n\n\t \n\tif (!madera->pdata.reset || madera->reset_errata) {\n\t\tret = madera_soft_reset(madera);\n\t\tif (ret)\n\t\t\tgoto err_reset;\n\t}\n\n\tret = madera_wait_for_boot(madera);\n\tif (ret) {\n\t\tdev_err(madera->dev, \"Failed to clear boot done: %d\\n\", ret);\n\t\tgoto err_reset;\n\t}\n\n\tret = regmap_read(madera->regmap, MADERA_HARDWARE_REVISION,\n\t\t\t  &madera->rev);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to read revision register: %d\\n\", ret);\n\t\tgoto err_reset;\n\t}\n\tmadera->rev &= MADERA_HW_REVISION_MASK;\n\n\tdev_info(dev, \"%s silicon revision %d\\n\", madera->type_name,\n\t\t madera->rev);\n\n\t \n\tif (patch_fn) {\n\t\tret = patch_fn(madera);\n\t\tif (ret) {\n\t\t\tdev_err(madera->dev, \"Failed to apply patch %d\\n\", ret);\n\t\t\tgoto err_reset;\n\t\t}\n\t}\n\n\t \n\tret = clk_prepare_enable(madera->mclk[MADERA_MCLK2].clk);\n\tif (ret) {\n\t\tdev_err(madera->dev, \"Failed to enable 32k clock: %d\\n\", ret);\n\t\tgoto err_reset;\n\t}\n\n\tret = regmap_update_bits(madera->regmap,\n\t\t\tMADERA_CLOCK_32K_1,\n\t\t\tMADERA_CLK_32K_ENA_MASK | MADERA_CLK_32K_SRC_MASK,\n\t\t\tMADERA_CLK_32K_ENA | MADERA_32KZ_MCLK2);\n\tif (ret) {\n\t\tdev_err(madera->dev, \"Failed to init 32k clock: %d\\n\", ret);\n\t\tgoto err_clock;\n\t}\n\n\tpm_runtime_set_active(madera->dev);\n\tpm_runtime_enable(madera->dev);\n\tpm_runtime_set_autosuspend_delay(madera->dev, 100);\n\tpm_runtime_use_autosuspend(madera->dev);\n\n\t \n\tret = mfd_add_devices(madera->dev, PLATFORM_DEVID_NONE,\n\t\t\t      mfd_devs, n_devs,\n\t\t\t      NULL, 0, NULL);\n\tif (ret) {\n\t\tdev_err(madera->dev, \"Failed to add subdevices: %d\\n\", ret);\n\t\tgoto err_pm_runtime;\n\t}\n\n\treturn 0;\n\nerr_pm_runtime:\n\tpm_runtime_disable(madera->dev);\nerr_clock:\n\tclk_disable_unprepare(madera->mclk[MADERA_MCLK2].clk);\nerr_reset:\n\tmadera_enable_hard_reset(madera);\n\tregulator_disable(madera->dcvdd);\nerr_enable:\n\tregulator_bulk_disable(madera->num_core_supplies,\n\t\t\t       madera->core_supplies);\nerr_dcvdd:\n\tregulator_put(madera->dcvdd);\nerr_devs:\n\tmfd_remove_devices(dev);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(madera_dev_init);\n\nint madera_dev_exit(struct madera *madera)\n{\n\t \n\tdisable_irq(madera->irq);\n\n\tpm_runtime_get_sync(madera->dev);\n\n\tmfd_remove_devices(madera->dev);\n\n\tpm_runtime_disable(madera->dev);\n\n\tregulator_disable(madera->dcvdd);\n\tregulator_put(madera->dcvdd);\n\n\tmfd_remove_devices_late(madera->dev);\n\n\tpm_runtime_set_suspended(madera->dev);\n\tpm_runtime_put_noidle(madera->dev);\n\n\tclk_disable_unprepare(madera->mclk[MADERA_MCLK2].clk);\n\n\tmadera_enable_hard_reset(madera);\n\n\tregulator_bulk_disable(madera->num_core_supplies,\n\t\t\t       madera->core_supplies);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(madera_dev_exit);\n\nMODULE_DESCRIPTION(\"Madera core MFD driver\");\nMODULE_AUTHOR(\"Richard Fitzgerald <rf@opensource.cirrus.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}