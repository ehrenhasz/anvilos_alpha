{
  "module_name": "lp3943.c",
  "hash_id": "390316d2b01dfad6db6e86c72d3e22a783a9ce67403b82a6d2a56e4b8aa077c1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/lp3943.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/gpio.h>\n#include <linux/i2c.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/lp3943.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n\n#define LP3943_MAX_REGISTERS\t\t0x09\n\n \nstatic const struct lp3943_reg_cfg lp3943_mux_cfg[] = {\n\t \n\t{ LP3943_REG_MUX0, 0x03, 0 },\n\t{ LP3943_REG_MUX0, 0x0C, 2 },\n\t{ LP3943_REG_MUX0, 0x30, 4 },\n\t{ LP3943_REG_MUX0, 0xC0, 6 },\n\t{ LP3943_REG_MUX1, 0x03, 0 },\n\t{ LP3943_REG_MUX1, 0x0C, 2 },\n\t{ LP3943_REG_MUX1, 0x30, 4 },\n\t{ LP3943_REG_MUX1, 0xC0, 6 },\n\t{ LP3943_REG_MUX2, 0x03, 0 },\n\t{ LP3943_REG_MUX2, 0x0C, 2 },\n\t{ LP3943_REG_MUX2, 0x30, 4 },\n\t{ LP3943_REG_MUX2, 0xC0, 6 },\n\t{ LP3943_REG_MUX3, 0x03, 0 },\n\t{ LP3943_REG_MUX3, 0x0C, 2 },\n\t{ LP3943_REG_MUX3, 0x30, 4 },\n\t{ LP3943_REG_MUX3, 0xC0, 6 },\n};\n\nstatic const struct mfd_cell lp3943_devs[] = {\n\t{\n\t\t.name = \"lp3943-pwm\",\n\t\t.of_compatible = \"ti,lp3943-pwm\",\n\t},\n\t{\n\t\t.name = \"lp3943-gpio\",\n\t\t.of_compatible = \"ti,lp3943-gpio\",\n\t},\n};\n\nint lp3943_read_byte(struct lp3943 *lp3943, u8 reg, u8 *read)\n{\n\tint ret;\n\tunsigned int val;\n\n\tret = regmap_read(lp3943->regmap, reg, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*read = (u8)val;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(lp3943_read_byte);\n\nint lp3943_write_byte(struct lp3943 *lp3943, u8 reg, u8 data)\n{\n\treturn regmap_write(lp3943->regmap, reg, data);\n}\nEXPORT_SYMBOL_GPL(lp3943_write_byte);\n\nint lp3943_update_bits(struct lp3943 *lp3943, u8 reg, u8 mask, u8 data)\n{\n\treturn regmap_update_bits(lp3943->regmap, reg, mask, data);\n}\nEXPORT_SYMBOL_GPL(lp3943_update_bits);\n\nstatic const struct regmap_config lp3943_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = LP3943_MAX_REGISTERS,\n};\n\nstatic int lp3943_probe(struct i2c_client *cl)\n{\n\tstruct lp3943 *lp3943;\n\tstruct device *dev = &cl->dev;\n\n\tlp3943 = devm_kzalloc(dev, sizeof(*lp3943), GFP_KERNEL);\n\tif (!lp3943)\n\t\treturn -ENOMEM;\n\n\tlp3943->regmap = devm_regmap_init_i2c(cl, &lp3943_regmap_config);\n\tif (IS_ERR(lp3943->regmap))\n\t\treturn PTR_ERR(lp3943->regmap);\n\n\tlp3943->pdata = dev_get_platdata(dev);\n\tlp3943->dev = dev;\n\tlp3943->mux_cfg = lp3943_mux_cfg;\n\ti2c_set_clientdata(cl, lp3943);\n\n\treturn devm_mfd_add_devices(dev, -1, lp3943_devs,\n\t\t\t\t    ARRAY_SIZE(lp3943_devs),\n\t\t\t\t    NULL, 0, NULL);\n}\n\nstatic const struct i2c_device_id lp3943_ids[] = {\n\t{ \"lp3943\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, lp3943_ids);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id lp3943_of_match[] = {\n\t{ .compatible = \"ti,lp3943\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, lp3943_of_match);\n#endif\n\nstatic struct i2c_driver lp3943_driver = {\n\t.probe = lp3943_probe,\n\t.driver = {\n\t\t.name = \"lp3943\",\n\t\t.of_match_table = of_match_ptr(lp3943_of_match),\n\t},\n\t.id_table = lp3943_ids,\n};\n\nmodule_i2c_driver(lp3943_driver);\n\nMODULE_DESCRIPTION(\"LP3943 MFD Core Driver\");\nMODULE_AUTHOR(\"Milo Kim\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}