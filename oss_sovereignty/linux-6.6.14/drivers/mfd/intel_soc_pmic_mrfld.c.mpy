{
  "module_name": "intel_soc_pmic_mrfld.c",
  "hash_id": "a70868e87b7ea1bb45578815646d3e517fbcc62394fb818176e4de16bd9f0407",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/intel_soc_pmic_mrfld.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/interrupt.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/intel_soc_pmic.h>\n#include <linux/mfd/intel_soc_pmic_mrfld.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n#include <asm/intel_scu_ipc.h>\n\n \nstatic struct resource irq_level2_resources[] = {\n\tDEFINE_RES_IRQ(0),  \n\tDEFINE_RES_IRQ(0),  \n\tDEFINE_RES_IRQ(0),  \n\tDEFINE_RES_IRQ(0),  \n\tDEFINE_RES_IRQ(0),  \n\tDEFINE_RES_IRQ(0),  \n\tDEFINE_RES_IRQ(0),  \n};\n\nstatic const struct mfd_cell bcove_dev[] = {\n\t{\n\t\t.name = \"mrfld_bcove_pwrbtn\",\n\t\t.num_resources = 1,\n\t\t.resources = &irq_level2_resources[0],\n\t}, {\n\t\t.name = \"mrfld_bcove_tmu\",\n\t\t.num_resources = 1,\n\t\t.resources = &irq_level2_resources[1],\n\t}, {\n\t\t.name = \"mrfld_bcove_thermal\",\n\t\t.num_resources = 1,\n\t\t.resources = &irq_level2_resources[2],\n\t}, {\n\t\t.name = \"mrfld_bcove_bcu\",\n\t\t.num_resources = 1,\n\t\t.resources = &irq_level2_resources[3],\n\t}, {\n\t\t.name = \"mrfld_bcove_adc\",\n\t\t.num_resources = 1,\n\t\t.resources = &irq_level2_resources[4],\n\t}, {\n\t\t.name = \"mrfld_bcove_charger\",\n\t\t.num_resources = 1,\n\t\t.resources = &irq_level2_resources[5],\n\t}, {\n\t\t.name = \"mrfld_bcove_pwrsrc\",\n\t\t.num_resources = 1,\n\t\t.resources = &irq_level2_resources[5],\n\t}, {\n\t\t.name = \"mrfld_bcove_gpio\",\n\t\t.num_resources = 1,\n\t\t.resources = &irq_level2_resources[6],\n\t},\n\t{\t.name = \"mrfld_bcove_region\", },\n};\n\nstatic int bcove_ipc_byte_reg_read(void *context, unsigned int reg,\n\t\t\t\t    unsigned int *val)\n{\n\tstruct intel_soc_pmic *pmic = context;\n\tu8 ipc_out;\n\tint ret;\n\n\tret = intel_scu_ipc_dev_ioread8(pmic->scu, reg, &ipc_out);\n\tif (ret)\n\t\treturn ret;\n\n\t*val = ipc_out;\n\treturn 0;\n}\n\nstatic int bcove_ipc_byte_reg_write(void *context, unsigned int reg,\n\t\t\t\t     unsigned int val)\n{\n\tstruct intel_soc_pmic *pmic = context;\n\tu8 ipc_in = val;\n\n\treturn intel_scu_ipc_dev_iowrite8(pmic->scu, reg, ipc_in);\n}\n\nstatic const struct regmap_config bcove_regmap_config = {\n\t.reg_bits = 16,\n\t.val_bits = 8,\n\t.max_register = 0xff,\n\t.reg_write = bcove_ipc_byte_reg_write,\n\t.reg_read = bcove_ipc_byte_reg_read,\n};\n\nstatic int bcove_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct intel_soc_pmic *pmic;\n\tunsigned int i;\n\tint ret;\n\n\tpmic = devm_kzalloc(dev, sizeof(*pmic), GFP_KERNEL);\n\tif (!pmic)\n\t\treturn -ENOMEM;\n\n\tpmic->scu = devm_intel_scu_ipc_dev_get(dev);\n\tif (!pmic->scu)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, pmic);\n\tpmic->dev = &pdev->dev;\n\n\tpmic->regmap = devm_regmap_init(dev, NULL, pmic, &bcove_regmap_config);\n\tif (IS_ERR(pmic->regmap))\n\t\treturn PTR_ERR(pmic->regmap);\n\n\tfor (i = 0; i < ARRAY_SIZE(irq_level2_resources); i++) {\n\t\tret = platform_get_irq(pdev, i);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tirq_level2_resources[i].start = ret;\n\t\tirq_level2_resources[i].end = ret;\n\t}\n\n\treturn devm_mfd_add_devices(dev, PLATFORM_DEVID_NONE,\n\t\t\t\t    bcove_dev, ARRAY_SIZE(bcove_dev),\n\t\t\t\t    NULL, 0, NULL);\n}\n\nstatic const struct acpi_device_id bcove_acpi_ids[] = {\n\t{ \"INTC100E\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(acpi, bcove_acpi_ids);\n\nstatic struct platform_driver bcove_driver = {\n\t.driver = {\n\t\t.name = \"intel_soc_pmic_mrfld\",\n\t\t.acpi_match_table = bcove_acpi_ids,\n\t},\n\t.probe = bcove_probe,\n};\nmodule_platform_driver(bcove_driver);\n\nMODULE_DESCRIPTION(\"IPC driver for Intel SoC Basin Cove PMIC\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}