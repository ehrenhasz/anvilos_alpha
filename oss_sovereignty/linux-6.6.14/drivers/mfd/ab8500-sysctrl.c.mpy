{
  "module_name": "ab8500-sysctrl.c",
  "hash_id": "4c885634e0e60d4a47f431ff4c10227c57e6d7355b107c1aaf5c484f56047d5b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/ab8500-sysctrl.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/reboot.h>\n#include <linux/signal.h>\n#include <linux/power_supply.h>\n#include <linux/mfd/abx500.h>\n#include <linux/mfd/abx500/ab8500.h>\n#include <linux/mfd/abx500/ab8500-sysctrl.h>\n\n \n#define AB8500_ALARM_MIN_LOW  0x08\n#define AB8500_ALARM_MIN_MID 0x09\n#define RTC_CTRL 0x0B\n#define RTC_ALARM_ENABLE 0x4\n\nstatic struct device *sysctrl_dev;\n\nstatic void ab8500_power_off(void)\n{\n\tsigset_t old;\n\tsigset_t all;\n\tstatic const char * const pss[] = {\"ab8500_ac\", \"pm2301\", \"ab8500_usb\"};\n\tint i;\n\tbool charger_present = false;\n\tunion power_supply_propval val;\n\tstruct power_supply *psy;\n\tint ret;\n\n\tif (sysctrl_dev == NULL) {\n\t\tpr_err(\"%s: sysctrl not initialized\\n\", __func__);\n\t\treturn;\n\t}\n\n\t \n\n\tfor (i = 0; i < ARRAY_SIZE(pss); i++) {\n\t\tpsy = power_supply_get_by_name(pss[i]);\n\t\tif (!psy)\n\t\t\tcontinue;\n\n\t\tret = power_supply_get_property(psy, POWER_SUPPLY_PROP_ONLINE,\n\t\t\t\t&val);\n\t\tpower_supply_put(psy);\n\n\t\tif (!ret && val.intval) {\n\t\t\tcharger_present = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!charger_present)\n\t\tgoto shutdown;\n\n\t \n\tpsy = power_supply_get_by_name(\"ab8500_btemp\");\n\tif (psy) {\n\t\tret = power_supply_get_property(psy,\n\t\t\t\tPOWER_SUPPLY_PROP_TECHNOLOGY, &val);\n\t\tif (!ret && val.intval != POWER_SUPPLY_TECHNOLOGY_UNKNOWN) {\n\t\t\tpr_info(\"Charger '%s' is connected with known battery\",\n\t\t\t\tpss[i]);\n\t\t\tpr_info(\" - Rebooting.\\n\");\n\t\t\tmachine_restart(\"charging\");\n\t\t}\n\t\tpower_supply_put(psy);\n\t}\n\nshutdown:\n\tsigfillset(&all);\n\n\tif (!sigprocmask(SIG_BLOCK, &all, &old)) {\n\t\t(void)ab8500_sysctrl_set(AB8500_STW4500CTRL1,\n\t\t\t\t\t AB8500_STW4500CTRL1_SWOFF |\n\t\t\t\t\t AB8500_STW4500CTRL1_SWRESET4500N);\n\t\t(void)sigprocmask(SIG_SETMASK, &old, NULL);\n\t}\n}\n\nstatic inline bool valid_bank(u8 bank)\n{\n\treturn ((bank == AB8500_SYS_CTRL1_BLOCK) ||\n\t\t(bank == AB8500_SYS_CTRL2_BLOCK));\n}\n\nint ab8500_sysctrl_read(u16 reg, u8 *value)\n{\n\tu8 bank;\n\n\tif (sysctrl_dev == NULL)\n\t\treturn -EPROBE_DEFER;\n\n\tbank = (reg >> 8);\n\tif (!valid_bank(bank))\n\t\treturn -EINVAL;\n\n\treturn abx500_get_register_interruptible(sysctrl_dev, bank,\n\t\t(u8)(reg & 0xFF), value);\n}\nEXPORT_SYMBOL(ab8500_sysctrl_read);\n\nint ab8500_sysctrl_write(u16 reg, u8 mask, u8 value)\n{\n\tu8 bank;\n\n\tif (sysctrl_dev == NULL)\n\t\treturn -EPROBE_DEFER;\n\n\tbank = (reg >> 8);\n\tif (!valid_bank(bank)) {\n\t\tpr_err(\"invalid bank\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn abx500_mask_and_set_register_interruptible(sysctrl_dev, bank,\n\t\t(u8)(reg & 0xFF), mask, value);\n}\nEXPORT_SYMBOL(ab8500_sysctrl_write);\n\nstatic int ab8500_sysctrl_probe(struct platform_device *pdev)\n{\n\tsysctrl_dev = &pdev->dev;\n\n\tif (!pm_power_off)\n\t\tpm_power_off = ab8500_power_off;\n\n\treturn 0;\n}\n\nstatic int ab8500_sysctrl_remove(struct platform_device *pdev)\n{\n\tsysctrl_dev = NULL;\n\n\tif (pm_power_off == ab8500_power_off)\n\t\tpm_power_off = NULL;\n\n\treturn 0;\n}\n\nstatic const struct of_device_id ab8500_sysctrl_match[] = {\n\t{ .compatible = \"stericsson,ab8500-sysctrl\", },\n\t{}\n};\n\nstatic struct platform_driver ab8500_sysctrl_driver = {\n\t.driver = {\n\t\t.name = \"ab8500-sysctrl\",\n\t\t.of_match_table = ab8500_sysctrl_match,\n\t},\n\t.probe = ab8500_sysctrl_probe,\n\t.remove = ab8500_sysctrl_remove,\n};\n\nstatic int __init ab8500_sysctrl_init(void)\n{\n\treturn platform_driver_register(&ab8500_sysctrl_driver);\n}\narch_initcall(ab8500_sysctrl_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}