{
  "module_name": "tps65086.c",
  "hash_id": "98afde757534edd998d4b482442b5f81c630ead1ee0e8765d2dd20b6fe7d73b8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/tps65086.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/mfd/core.h>\n#include <linux/module.h>\n\n#include <linux/mfd/tps65086.h>\n\nstatic const struct mfd_cell tps65086_cells[] = {\n\t{ .name = \"tps65086-regulator\", },\n\t{ .name = \"tps65086-gpio\", },\n\t{ .name = \"tps65086-reset\", },\n};\n\nstatic const struct regmap_range tps65086_yes_ranges[] = {\n\tregmap_reg_range(TPS65086_IRQ, TPS65086_IRQ),\n\tregmap_reg_range(TPS65086_PMICSTAT, TPS65086_SHUTDNSRC),\n\tregmap_reg_range(TPS65086_GPOCTRL, TPS65086_GPOCTRL),\n\tregmap_reg_range(TPS65086_PG_STATUS1, TPS65086_OC_STATUS),\n};\n\nstatic const struct regmap_access_table tps65086_volatile_table = {\n\t.yes_ranges = tps65086_yes_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(tps65086_yes_ranges),\n};\n\nstatic const struct regmap_config tps65086_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.cache_type = REGCACHE_RBTREE,\n\t.volatile_table = &tps65086_volatile_table,\n};\n\nstatic const struct regmap_irq tps65086_irqs[] = {\n\tREGMAP_IRQ_REG(TPS65086_IRQ_DIETEMP, 0, TPS65086_IRQ_DIETEMP_MASK),\n\tREGMAP_IRQ_REG(TPS65086_IRQ_SHUTDN, 0, TPS65086_IRQ_SHUTDN_MASK),\n\tREGMAP_IRQ_REG(TPS65086_IRQ_FAULT, 0, TPS65086_IRQ_FAULT_MASK),\n};\n\nstatic struct regmap_irq_chip tps65086_irq_chip = {\n\t.name = \"tps65086\",\n\t.status_base = TPS65086_IRQ,\n\t.mask_base = TPS65086_IRQ_MASK,\n\t.ack_base = TPS65086_IRQ,\n\t.init_ack_masked = true,\n\t.num_regs = 1,\n\t.irqs = tps65086_irqs,\n\t.num_irqs = ARRAY_SIZE(tps65086_irqs),\n};\n\nstatic const struct of_device_id tps65086_of_match_table[] = {\n\t{ .compatible = \"ti,tps65086\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, tps65086_of_match_table);\n\nstatic int tps65086_probe(struct i2c_client *client)\n{\n\tstruct tps65086 *tps;\n\tunsigned int version;\n\tint ret;\n\n\ttps = devm_kzalloc(&client->dev, sizeof(*tps), GFP_KERNEL);\n\tif (!tps)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, tps);\n\ttps->dev = &client->dev;\n\ttps->irq = client->irq;\n\n\ttps->regmap = devm_regmap_init_i2c(client, &tps65086_regmap_config);\n\tif (IS_ERR(tps->regmap)) {\n\t\tdev_err(tps->dev, \"Failed to initialize register map\\n\");\n\t\treturn PTR_ERR(tps->regmap);\n\t}\n\n\t \n\tret = regmap_read(tps->regmap, TPS65086_DEVICEID1, &tps->chip_id);\n\tif (ret) {\n\t\tdev_err(tps->dev, \"Failed to read revision register 1\\n\");\n\t\treturn ret;\n\t}\n\n\tret = regmap_read(tps->regmap, TPS65086_DEVICEID2, &version);\n\tif (ret) {\n\t\tdev_err(tps->dev, \"Failed to read revision register 2\\n\");\n\t\treturn ret;\n\t}\n\n\tdev_info(tps->dev, \"Device: TPS65086%01lX, OTP: %c, Rev: %ld\\n\",\n\t\t (version & TPS65086_DEVICEID2_PART_MASK),\n\t\t (char)((version & TPS65086_DEVICEID2_OTP_MASK) >> 4) + 'A',\n\t\t (version & TPS65086_DEVICEID2_REV_MASK) >> 6);\n\n\tif (tps->irq > 0) {\n\t\tret = regmap_add_irq_chip(tps->regmap, tps->irq, IRQF_ONESHOT, 0,\n\t\t\t\t\t  &tps65086_irq_chip, &tps->irq_data);\n\t\tif (ret) {\n\t\t\tdev_err(tps->dev, \"Failed to register IRQ chip\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = mfd_add_devices(tps->dev, PLATFORM_DEVID_AUTO, tps65086_cells,\n\t\t\t      ARRAY_SIZE(tps65086_cells), NULL, 0,\n\t\t\t      regmap_irq_get_domain(tps->irq_data));\n\tif (ret && tps->irq > 0)\n\t\tregmap_del_irq_chip(tps->irq, tps->irq_data);\n\n\treturn ret;\n}\n\nstatic void tps65086_remove(struct i2c_client *client)\n{\n\tstruct tps65086 *tps = i2c_get_clientdata(client);\n\n\tif (tps->irq > 0)\n\t\tregmap_del_irq_chip(tps->irq, tps->irq_data);\n}\n\nstatic const struct i2c_device_id tps65086_id_table[] = {\n\t{ \"tps65086\", 0 },\n\t{   }\n};\nMODULE_DEVICE_TABLE(i2c, tps65086_id_table);\n\nstatic struct i2c_driver tps65086_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"tps65086\",\n\t\t.of_match_table = tps65086_of_match_table,\n\t},\n\t.probe\t\t= tps65086_probe,\n\t.remove\t\t= tps65086_remove,\n\t.id_table       = tps65086_id_table,\n};\nmodule_i2c_driver(tps65086_driver);\n\nMODULE_AUTHOR(\"Andrew F. Davis <afd@ti.com>\");\nMODULE_DESCRIPTION(\"TPS65086 PMIC Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}