{
  "module_name": "intel_pmc_bxt.c",
  "hash_id": "8206e4c0bbcb216cd6a98f0d29f1d6a929d695102dfae374655a9fa57fd22141",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/intel_pmc_bxt.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/io-64-nonatomic-lo-hi.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/intel_pmc_bxt.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/platform_data/itco_wdt.h>\n\n#include <asm/intel_scu_ipc.h>\n\n \n#define S0IX_RESIDENCY_IN_USECS(d, s)\t\t\\\n({\t\t\t\t\t\t\\\n\tu64 result = 10ull * ((d) + (s));\t\\\n\tdo_div(result, 192);\t\t\t\\\n\tresult;\t\t\t\t\t\\\n})\n\n \n#define PLAT_RESOURCE_IPC_INDEX\t\t0\n#define PLAT_RESOURCE_IPC_SIZE\t\t0x1000\n#define PLAT_RESOURCE_GCR_OFFSET\t0x1000\n#define PLAT_RESOURCE_GCR_SIZE\t\t0x1000\n#define PLAT_RESOURCE_BIOS_DATA_INDEX\t1\n#define PLAT_RESOURCE_BIOS_IFACE_INDEX\t2\n#define PLAT_RESOURCE_TELEM_SSRAM_INDEX\t3\n#define PLAT_RESOURCE_ISP_DATA_INDEX\t4\n#define PLAT_RESOURCE_ISP_IFACE_INDEX\t5\n#define PLAT_RESOURCE_GTD_DATA_INDEX\t6\n#define PLAT_RESOURCE_GTD_IFACE_INDEX\t7\n#define PLAT_RESOURCE_ACPI_IO_INDEX\t0\n\n \n#define SMI_EN_OFFSET\t\t\t0x0040\n#define SMI_EN_SIZE\t\t\t4\n#define TCO_BASE_OFFSET\t\t\t0x0060\n#define TCO_REGS_SIZE\t\t\t16\n#define TELEM_SSRAM_SIZE\t\t240\n#define TELEM_PMC_SSRAM_OFFSET\t\t0x1b00\n#define TELEM_PUNIT_SSRAM_OFFSET\t0x1a00\n\n \n#define PMC_NORTHPEAK_CTRL\t\t0xed\n\nstatic inline bool is_gcr_valid(u32 offset)\n{\n\treturn offset < PLAT_RESOURCE_GCR_SIZE - 8;\n}\n\n \nint intel_pmc_gcr_read64(struct intel_pmc_dev *pmc, u32 offset, u64 *data)\n{\n\tif (!is_gcr_valid(offset))\n\t\treturn -EINVAL;\n\n\tspin_lock(&pmc->gcr_lock);\n\t*data = readq(pmc->gcr_mem_base + offset);\n\tspin_unlock(&pmc->gcr_lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(intel_pmc_gcr_read64);\n\n \nint intel_pmc_gcr_update(struct intel_pmc_dev *pmc, u32 offset, u32 mask, u32 val)\n{\n\tu32 new_val;\n\n\tif (!is_gcr_valid(offset))\n\t\treturn -EINVAL;\n\n\tspin_lock(&pmc->gcr_lock);\n\tnew_val = readl(pmc->gcr_mem_base + offset);\n\n\tnew_val = (new_val & ~mask) | (val & mask);\n\twritel(new_val, pmc->gcr_mem_base + offset);\n\n\tnew_val = readl(pmc->gcr_mem_base + offset);\n\tspin_unlock(&pmc->gcr_lock);\n\n\t \n\treturn (new_val & mask) != (val & mask) ? -EIO : 0;\n}\nEXPORT_SYMBOL_GPL(intel_pmc_gcr_update);\n\n \nint intel_pmc_s0ix_counter_read(struct intel_pmc_dev *pmc, u64 *data)\n{\n\tu64 deep, shlw;\n\n\tspin_lock(&pmc->gcr_lock);\n\tdeep = readq(pmc->gcr_mem_base + PMC_GCR_TELEM_DEEP_S0IX_REG);\n\tshlw = readq(pmc->gcr_mem_base + PMC_GCR_TELEM_SHLW_S0IX_REG);\n\tspin_unlock(&pmc->gcr_lock);\n\n\t*data = S0IX_RESIDENCY_IN_USECS(deep, shlw);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(intel_pmc_s0ix_counter_read);\n\n \nstatic ssize_t simplecmd_store(struct device *dev, struct device_attribute *attr,\n\t\t\t       const char *buf, size_t count)\n{\n\tstruct intel_pmc_dev *pmc = dev_get_drvdata(dev);\n\tstruct intel_scu_ipc_dev *scu = pmc->scu;\n\tint subcmd;\n\tint cmd;\n\tint ret;\n\n\tret = sscanf(buf, \"%d %d\", &cmd, &subcmd);\n\tif (ret != 2) {\n\t\tdev_err(dev, \"Invalid values, expected: cmd subcmd\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = intel_scu_ipc_dev_simple_command(scu, cmd, subcmd);\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\nstatic DEVICE_ATTR_WO(simplecmd);\n\n \nstatic ssize_t northpeak_store(struct device *dev, struct device_attribute *attr,\n\t\t\t       const char *buf, size_t count)\n{\n\tstruct intel_pmc_dev *pmc = dev_get_drvdata(dev);\n\tstruct intel_scu_ipc_dev *scu = pmc->scu;\n\tunsigned long val;\n\tint subcmd;\n\tint ret;\n\n\tret = kstrtoul(buf, 0, &val);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (val)\n\t\tsubcmd = 1;\n\telse\n\t\tsubcmd = 0;\n\n\tret = intel_scu_ipc_dev_simple_command(scu, PMC_NORTHPEAK_CTRL, subcmd);\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\nstatic DEVICE_ATTR_WO(northpeak);\n\nstatic struct attribute *intel_pmc_attrs[] = {\n\t&dev_attr_northpeak.attr,\n\t&dev_attr_simplecmd.attr,\n\tNULL\n};\n\nstatic const struct attribute_group intel_pmc_group = {\n\t.attrs = intel_pmc_attrs,\n};\n\nstatic const struct attribute_group *intel_pmc_groups[] = {\n\t&intel_pmc_group,\n\tNULL\n};\n\nstatic struct resource punit_res[6];\n\nstatic struct mfd_cell punit = {\n\t.name = \"intel_punit_ipc\",\n\t.resources = punit_res,\n};\n\nstatic struct itco_wdt_platform_data tco_pdata = {\n\t.name = \"Apollo Lake SoC\",\n\t.version = 5,\n\t.no_reboot_use_pmc = true,\n};\n\nstatic struct resource tco_res[2];\n\nstatic const struct mfd_cell tco = {\n\t.name = \"iTCO_wdt\",\n\t.ignore_resource_conflicts = true,\n\t.resources = tco_res,\n\t.num_resources = ARRAY_SIZE(tco_res),\n\t.platform_data = &tco_pdata,\n\t.pdata_size = sizeof(tco_pdata),\n};\n\nstatic const struct resource telem_res[] = {\n\tDEFINE_RES_MEM(TELEM_PUNIT_SSRAM_OFFSET, TELEM_SSRAM_SIZE),\n\tDEFINE_RES_MEM(TELEM_PMC_SSRAM_OFFSET, TELEM_SSRAM_SIZE),\n};\n\nstatic const struct mfd_cell telem = {\n\t.name = \"intel_telemetry\",\n\t.resources = telem_res,\n\t.num_resources = ARRAY_SIZE(telem_res),\n};\n\nstatic int intel_pmc_get_tco_resources(struct platform_device *pdev)\n{\n\tstruct resource *res;\n\n\tif (acpi_has_watchdog())\n\t\treturn 0;\n\n\tres = platform_get_resource(pdev, IORESOURCE_IO,\n\t\t\t\t    PLAT_RESOURCE_ACPI_IO_INDEX);\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"Failed to get IO resource\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttco_res[0].flags = IORESOURCE_IO;\n\ttco_res[0].start = res->start + TCO_BASE_OFFSET;\n\ttco_res[0].end = tco_res[0].start + TCO_REGS_SIZE - 1;\n\ttco_res[1].flags = IORESOURCE_IO;\n\ttco_res[1].start = res->start + SMI_EN_OFFSET;\n\ttco_res[1].end = tco_res[1].start + SMI_EN_SIZE - 1;\n\n\treturn 0;\n}\n\nstatic int intel_pmc_get_resources(struct platform_device *pdev,\n\t\t\t\t   struct intel_pmc_dev *pmc,\n\t\t\t\t   struct intel_scu_ipc_data *scu_data)\n{\n\tstruct resource gcr_res;\n\tsize_t npunit_res = 0;\n\tstruct resource *res;\n\tint ret;\n\n\tscu_data->irq = platform_get_irq_optional(pdev, 0);\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM,\n\t\t\t\t    PLAT_RESOURCE_IPC_INDEX);\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"Failed to get IPC resource\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tscu_data->mem.flags = res->flags;\n\tscu_data->mem.start = res->start;\n\tscu_data->mem.end = res->start + PLAT_RESOURCE_IPC_SIZE - 1;\n\n\t \n\tgcr_res.flags = res->flags;\n\tgcr_res.start = res->start + PLAT_RESOURCE_GCR_OFFSET;\n\tgcr_res.end = gcr_res.start + PLAT_RESOURCE_GCR_SIZE - 1;\n\n\tpmc->gcr_mem_base = devm_ioremap_resource(&pdev->dev, &gcr_res);\n\tif (IS_ERR(pmc->gcr_mem_base))\n\t\treturn PTR_ERR(pmc->gcr_mem_base);\n\n\t \n\tret = intel_pmc_get_tco_resources(pdev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tres = platform_get_resource(pdev, IORESOURCE_MEM,\n\t\t\t\t    PLAT_RESOURCE_BIOS_DATA_INDEX);\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"Failed to get resource of P-unit BIOS data\\n\");\n\t\treturn -EINVAL;\n\t}\n\tpunit_res[npunit_res++] = *res;\n\n\t \n\tres = platform_get_resource(pdev, IORESOURCE_MEM,\n\t\t\t\t    PLAT_RESOURCE_BIOS_IFACE_INDEX);\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"Failed to get resource of P-unit BIOS interface\\n\");\n\t\treturn -EINVAL;\n\t}\n\tpunit_res[npunit_res++] = *res;\n\n\t \n\tres = platform_get_resource(pdev, IORESOURCE_MEM,\n\t\t\t\t    PLAT_RESOURCE_ISP_DATA_INDEX);\n\tif (res)\n\t\tpunit_res[npunit_res++] = *res;\n\n\t \n\tres = platform_get_resource(pdev, IORESOURCE_MEM,\n\t\t\t\t    PLAT_RESOURCE_ISP_IFACE_INDEX);\n\tif (res)\n\t\tpunit_res[npunit_res++] = *res;\n\n\t \n\tres = platform_get_resource(pdev, IORESOURCE_MEM,\n\t\t\t\t    PLAT_RESOURCE_GTD_DATA_INDEX);\n\tif (res)\n\t\tpunit_res[npunit_res++] = *res;\n\n\t \n\tres = platform_get_resource(pdev, IORESOURCE_MEM,\n\t\t\t\t    PLAT_RESOURCE_GTD_IFACE_INDEX);\n\tif (res)\n\t\tpunit_res[npunit_res++] = *res;\n\n\tpunit.num_resources = npunit_res;\n\n\t \n\tres = platform_get_resource(pdev, IORESOURCE_MEM,\n\t\t\t\t    PLAT_RESOURCE_TELEM_SSRAM_INDEX);\n\tif (res)\n\t\tpmc->telem_base = res;\n\n\treturn 0;\n}\n\nstatic int intel_pmc_create_devices(struct intel_pmc_dev *pmc)\n{\n\tint ret;\n\n\tif (!acpi_has_watchdog()) {\n\t\tret = devm_mfd_add_devices(pmc->dev, PLATFORM_DEVID_AUTO, &tco,\n\t\t\t\t\t   1, NULL, 0, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = devm_mfd_add_devices(pmc->dev, PLATFORM_DEVID_AUTO, &punit, 1,\n\t\t\t\t   NULL, 0, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tif (pmc->telem_base) {\n\t\tret = devm_mfd_add_devices(pmc->dev, PLATFORM_DEVID_AUTO,\n\t\t\t\t\t   &telem, 1, pmc->telem_base, 0, NULL);\n\t}\n\n\treturn ret;\n}\n\nstatic const struct acpi_device_id intel_pmc_acpi_ids[] = {\n\t{ \"INT34D2\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, intel_pmc_acpi_ids);\n\nstatic int intel_pmc_probe(struct platform_device *pdev)\n{\n\tstruct intel_scu_ipc_data scu_data = {};\n\tstruct intel_pmc_dev *pmc;\n\tint ret;\n\n\tpmc = devm_kzalloc(&pdev->dev, sizeof(*pmc), GFP_KERNEL);\n\tif (!pmc)\n\t\treturn -ENOMEM;\n\n\tpmc->dev = &pdev->dev;\n\tspin_lock_init(&pmc->gcr_lock);\n\n\tret = intel_pmc_get_resources(pdev, pmc, &scu_data);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to request resources\\n\");\n\t\treturn ret;\n\t}\n\n\tpmc->scu = devm_intel_scu_ipc_register(&pdev->dev, &scu_data);\n\tif (IS_ERR(pmc->scu))\n\t\treturn PTR_ERR(pmc->scu);\n\n\tplatform_set_drvdata(pdev, pmc);\n\n\tret = intel_pmc_create_devices(pmc);\n\tif (ret)\n\t\tdev_err(&pdev->dev, \"Failed to create PMC devices\\n\");\n\n\treturn ret;\n}\n\nstatic struct platform_driver intel_pmc_driver = {\n\t.probe = intel_pmc_probe,\n\t.driver = {\n\t\t.name = \"intel_pmc_bxt\",\n\t\t.acpi_match_table = intel_pmc_acpi_ids,\n\t\t.dev_groups = intel_pmc_groups,\n\t},\n};\nmodule_platform_driver(intel_pmc_driver);\n\nMODULE_AUTHOR(\"Mika Westerberg <mika.westerberg@linux.intel.com>\");\nMODULE_AUTHOR(\"Zha Qipeng <qipeng.zha@intel.com>\");\nMODULE_DESCRIPTION(\"Intel Broxton PMC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}