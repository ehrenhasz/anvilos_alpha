{
  "module_name": "janz-cmodio.c",
  "hash_id": "ad54ab809c6c446fcb26312cb57a5107133c1aa44a96c69f0698d0033fb12e68",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/janz-cmodio.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/mfd/core.h>\n\n#include <linux/mfd/janz.h>\n\n#define DRV_NAME \"janz-cmodio\"\n\n \n#define CMODIO_MODULBUS_SIZE\t0x200\n\n \n#define CMODIO_MAX_MODULES\t4\n\n \nstatic unsigned int num_modules = CMODIO_MAX_MODULES;\nstatic char *modules[CMODIO_MAX_MODULES] = {\n\t\"empty\", \"empty\", \"empty\", \"empty\",\n};\n\nmodule_param_array(modules, charp, &num_modules, S_IRUGO);\nMODULE_PARM_DESC(modules, \"MODULbus modules attached to the carrier board\");\n\n \nstatic unsigned int cmodio_id;\n\nstruct cmodio_device {\n\t \n\tstruct pci_dev *pdev;\n\n\t \n\tstruct janz_cmodio_onboard_regs __iomem *ctrl;\n\n\t \n\tu8 hex;\n\n\t \n\tstruct mfd_cell cells[CMODIO_MAX_MODULES];\n\tstruct resource resources[3 * CMODIO_MAX_MODULES];\n\tstruct janz_platform_data pdata[CMODIO_MAX_MODULES];\n};\n\n \n\nstatic int cmodio_setup_subdevice(struct cmodio_device *priv,\n\t\t\t\t\t    char *name, unsigned int devno,\n\t\t\t\t\t    unsigned int modno)\n{\n\tstruct janz_platform_data *pdata;\n\tstruct mfd_cell *cell;\n\tstruct resource *res;\n\tstruct pci_dev *pci;\n\n\tpci = priv->pdev;\n\tcell = &priv->cells[devno];\n\tres = &priv->resources[devno * 3];\n\tpdata = &priv->pdata[devno];\n\n\tcell->name = name;\n\tcell->resources = res;\n\tcell->num_resources = 3;\n\n\t \n\tcell->id = cmodio_id++;\n\n\t \n\tpdata->modno = modno;\n\tcell->platform_data = pdata;\n\tcell->pdata_size = sizeof(*pdata);\n\n\t \n\tres->flags = IORESOURCE_MEM;\n\tres->parent = &pci->resource[3];\n\tres->start = pci->resource[3].start + (CMODIO_MODULBUS_SIZE * modno);\n\tres->end = res->start + CMODIO_MODULBUS_SIZE - 1;\n\tres++;\n\n\t \n\tres->flags = IORESOURCE_MEM;\n\tres->parent = &pci->resource[4];\n\tres->start = pci->resource[4].start;\n\tres->end = pci->resource[4].end;\n\tres++;\n\n\t \n\tres->flags = IORESOURCE_IRQ;\n\tres->parent = NULL;\n\tres->start = 0;\n\tres->end = 0;\n\tres++;\n\n\treturn 0;\n}\n\n \nstatic int cmodio_probe_submodules(struct cmodio_device *priv)\n{\n\tstruct pci_dev *pdev = priv->pdev;\n\tunsigned int num_probed = 0;\n\tchar *name;\n\tint i;\n\n\tfor (i = 0; i < num_modules; i++) {\n\t\tname = modules[i];\n\t\tif (!strcmp(name, \"\") || !strcmp(name, \"empty\"))\n\t\t\tcontinue;\n\n\t\tdev_dbg(&priv->pdev->dev, \"MODULbus %d: name %s\\n\", i, name);\n\t\tcmodio_setup_subdevice(priv, name, num_probed, i);\n\t\tnum_probed++;\n\t}\n\n\t \n\tif (num_probed == 0) {\n\t\tdev_err(&priv->pdev->dev, \"no MODULbus modules specified, \"\n\t\t\t\t\t  \"please set the ``modules'' kernel \"\n\t\t\t\t\t  \"parameter according to your \"\n\t\t\t\t\t  \"hardware configuration\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn mfd_add_devices(&pdev->dev, 0, priv->cells,\n\t\t\t       num_probed, NULL, pdev->irq, NULL);\n}\n\n \n\nstatic ssize_t modulbus_number_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct cmodio_device *priv = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%x\\n\", priv->hex);\n}\n\nstatic DEVICE_ATTR_RO(modulbus_number);\n\nstatic struct attribute *cmodio_sysfs_attrs[] = {\n\t&dev_attr_modulbus_number.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group cmodio_sysfs_attr_group = {\n\t.attrs = cmodio_sysfs_attrs,\n};\n\n \n\nstatic int cmodio_pci_probe(struct pci_dev *dev,\n\t\t\t\t      const struct pci_device_id *id)\n{\n\tstruct cmodio_device *priv;\n\tint ret;\n\n\tpriv = devm_kzalloc(&dev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpci_set_drvdata(dev, priv);\n\tpriv->pdev = dev;\n\n\t \n\tret = pci_enable_device(dev);\n\tif (ret) {\n\t\tdev_err(&dev->dev, \"unable to enable device\\n\");\n\t\treturn ret;\n\t}\n\n\tpci_set_master(dev);\n\tret = pci_request_regions(dev, DRV_NAME);\n\tif (ret) {\n\t\tdev_err(&dev->dev, \"unable to request regions\\n\");\n\t\tgoto out_pci_disable_device;\n\t}\n\n\t \n\tpriv->ctrl = pci_ioremap_bar(dev, 4);\n\tif (!priv->ctrl) {\n\t\tdev_err(&dev->dev, \"unable to remap onboard regs\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_pci_release_regions;\n\t}\n\n\t \n\tpriv->hex = ioread8(&priv->ctrl->int_enable);\n\n\t \n\tret = sysfs_create_group(&dev->dev.kobj, &cmodio_sysfs_attr_group);\n\tif (ret) {\n\t\tdev_err(&dev->dev, \"unable to create sysfs attributes\\n\");\n\t\tgoto out_unmap_ctrl;\n\t}\n\n\t \n\tiowrite8(0xf, &priv->ctrl->int_disable);\n\n\t \n\tret = cmodio_probe_submodules(priv);\n\tif (ret) {\n\t\tdev_err(&dev->dev, \"unable to probe submodules\\n\");\n\t\tgoto out_sysfs_remove_group;\n\t}\n\n\treturn 0;\n\nout_sysfs_remove_group:\n\tsysfs_remove_group(&dev->dev.kobj, &cmodio_sysfs_attr_group);\nout_unmap_ctrl:\n\tiounmap(priv->ctrl);\nout_pci_release_regions:\n\tpci_release_regions(dev);\nout_pci_disable_device:\n\tpci_disable_device(dev);\n\n\treturn ret;\n}\n\nstatic void cmodio_pci_remove(struct pci_dev *dev)\n{\n\tstruct cmodio_device *priv = pci_get_drvdata(dev);\n\n\tmfd_remove_devices(&dev->dev);\n\tsysfs_remove_group(&dev->dev.kobj, &cmodio_sysfs_attr_group);\n\tiounmap(priv->ctrl);\n\tpci_release_regions(dev);\n\tpci_disable_device(dev);\n}\n\n#define PCI_VENDOR_ID_JANZ\t\t0x13c3\n\n \nstatic const struct pci_device_id cmodio_pci_ids[] = {\n\t{ PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9030, PCI_VENDOR_ID_JANZ, 0x0101 },\n\t{ PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9050, PCI_VENDOR_ID_JANZ, 0x0100 },\n\t{ PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9030, PCI_VENDOR_ID_JANZ, 0x0201 },\n\t{ PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9030, PCI_VENDOR_ID_JANZ, 0x0202 },\n\t{ PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9050, PCI_VENDOR_ID_JANZ, 0x0201 },\n\t{ PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9050, PCI_VENDOR_ID_JANZ, 0x0202 },\n\t{ 0, }\n};\nMODULE_DEVICE_TABLE(pci, cmodio_pci_ids);\n\nstatic struct pci_driver cmodio_pci_driver = {\n\t.name     = DRV_NAME,\n\t.id_table = cmodio_pci_ids,\n\t.probe    = cmodio_pci_probe,\n\t.remove   = cmodio_pci_remove,\n};\n\nmodule_pci_driver(cmodio_pci_driver);\n\nMODULE_AUTHOR(\"Ira W. Snyder <iws@ovro.caltech.edu>\");\nMODULE_DESCRIPTION(\"Janz CMOD-IO PCI MODULbus Carrier Board Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}