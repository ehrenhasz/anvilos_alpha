{
  "module_name": "intel-m10-bmc-pmci.c",
  "hash_id": "0348729c9d598694ef2c62103c873e12ccfdf8687242f29a60286d159e9bbab1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/intel-m10-bmc-pmci.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/device.h>\n#include <linux/dfl.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/intel-m10-bmc.h>\n#include <linux/minmax.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n\nstruct m10bmc_pmci_device {\n\tvoid __iomem *base;\n\tstruct intel_m10bmc m10bmc;\n\tstruct mutex flash_mutex;\t \n\tbool flash_busy;\n};\n\n \n#define INDIRECT_CMD_OFF\t0\n#define INDIRECT_CMD_CLR\t0\n#define INDIRECT_CMD_RD\t\tBIT(0)\n#define INDIRECT_CMD_WR\t\tBIT(1)\n#define INDIRECT_CMD_ACK\tBIT(2)\n\n#define INDIRECT_ADDR_OFF\t0x4\n#define INDIRECT_RD_OFF\t\t0x8\n#define INDIRECT_WR_OFF\t\t0xc\n\n#define INDIRECT_INT_US\t\t1\n#define INDIRECT_TIMEOUT_US\t10000\n\nstruct indirect_ctx {\n\tvoid __iomem *base;\n\tstruct device *dev;\n};\n\nstatic int indirect_clear_cmd(struct indirect_ctx *ctx)\n{\n\tunsigned int cmd;\n\tint ret;\n\n\twritel(INDIRECT_CMD_CLR, ctx->base + INDIRECT_CMD_OFF);\n\n\tret = readl_poll_timeout(ctx->base + INDIRECT_CMD_OFF, cmd,\n\t\t\t\t cmd == INDIRECT_CMD_CLR,\n\t\t\t\t INDIRECT_INT_US, INDIRECT_TIMEOUT_US);\n\tif (ret)\n\t\tdev_err(ctx->dev, \"timed out waiting clear cmd (residual cmd=0x%x)\\n\", cmd);\n\n\treturn ret;\n}\n\nstatic int indirect_reg_read(void *context, unsigned int reg, unsigned int *val)\n{\n\tstruct indirect_ctx *ctx = context;\n\tunsigned int cmd, ack, tmpval;\n\tint ret, ret2;\n\n\tcmd = readl(ctx->base + INDIRECT_CMD_OFF);\n\tif (cmd != INDIRECT_CMD_CLR)\n\t\tdev_warn(ctx->dev, \"residual cmd 0x%x on read entry\\n\", cmd);\n\n\twritel(reg, ctx->base + INDIRECT_ADDR_OFF);\n\twritel(INDIRECT_CMD_RD, ctx->base + INDIRECT_CMD_OFF);\n\n\tret = readl_poll_timeout(ctx->base + INDIRECT_CMD_OFF, ack,\n\t\t\t\t (ack & INDIRECT_CMD_ACK) == INDIRECT_CMD_ACK,\n\t\t\t\t INDIRECT_INT_US, INDIRECT_TIMEOUT_US);\n\tif (ret)\n\t\tdev_err(ctx->dev, \"read timed out on reg 0x%x ack 0x%x\\n\", reg, ack);\n\telse\n\t\ttmpval = readl(ctx->base + INDIRECT_RD_OFF);\n\n\tret2 = indirect_clear_cmd(ctx);\n\n\tif (ret)\n\t\treturn ret;\n\tif (ret2)\n\t\treturn ret2;\n\n\t*val = tmpval;\n\treturn 0;\n}\n\nstatic int indirect_reg_write(void *context, unsigned int reg, unsigned int val)\n{\n\tstruct indirect_ctx *ctx = context;\n\tunsigned int cmd, ack;\n\tint ret, ret2;\n\n\tcmd = readl(ctx->base + INDIRECT_CMD_OFF);\n\tif (cmd != INDIRECT_CMD_CLR)\n\t\tdev_warn(ctx->dev, \"residual cmd 0x%x on write entry\\n\", cmd);\n\n\twritel(val, ctx->base + INDIRECT_WR_OFF);\n\twritel(reg, ctx->base + INDIRECT_ADDR_OFF);\n\twritel(INDIRECT_CMD_WR, ctx->base + INDIRECT_CMD_OFF);\n\n\tret = readl_poll_timeout(ctx->base + INDIRECT_CMD_OFF, ack,\n\t\t\t\t (ack & INDIRECT_CMD_ACK) == INDIRECT_CMD_ACK,\n\t\t\t\t INDIRECT_INT_US, INDIRECT_TIMEOUT_US);\n\tif (ret)\n\t\tdev_err(ctx->dev, \"write timed out on reg 0x%x ack 0x%x\\n\", reg, ack);\n\n\tret2 = indirect_clear_cmd(ctx);\n\n\tif (ret)\n\t\treturn ret;\n\treturn ret2;\n}\n\nstatic void pmci_write_fifo(void __iomem *base, const u32 *buf, size_t count)\n{\n\twhile (count--)\n\t\twritel(*buf++, base);\n}\n\nstatic void pmci_read_fifo(void __iomem *base, u32 *buf, size_t count)\n{\n\twhile (count--)\n\t\t*buf++ = readl(base);\n}\n\nstatic u32 pmci_get_write_space(struct m10bmc_pmci_device *pmci)\n{\n\tu32 val;\n\tint ret;\n\n\tret = read_poll_timeout(readl, val,\n\t\t\t\tFIELD_GET(M10BMC_N6000_FLASH_FIFO_SPACE, val) ==\n\t\t\t\tM10BMC_N6000_FIFO_MAX_WORDS,\n\t\t\t\tM10BMC_FLASH_INT_US, M10BMC_FLASH_TIMEOUT_US,\n\t\t\t\tfalse, pmci->base + M10BMC_N6000_FLASH_CTRL);\n\tif (ret == -ETIMEDOUT)\n\t\treturn 0;\n\n\treturn FIELD_GET(M10BMC_N6000_FLASH_FIFO_SPACE, val) * M10BMC_N6000_FIFO_WORD_SIZE;\n}\n\nstatic int pmci_flash_bulk_write(struct intel_m10bmc *m10bmc, const u8 *buf, u32 size)\n{\n\tstruct m10bmc_pmci_device *pmci = container_of(m10bmc, struct m10bmc_pmci_device, m10bmc);\n\tu32 blk_size, offset = 0, write_count;\n\n\twhile (size) {\n\t\tblk_size = min(pmci_get_write_space(pmci), size);\n\t\tif (blk_size == 0) {\n\t\t\tdev_err(m10bmc->dev, \"get FIFO available size fail\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (size < M10BMC_N6000_FIFO_WORD_SIZE)\n\t\t\tbreak;\n\n\t\twrite_count = blk_size / M10BMC_N6000_FIFO_WORD_SIZE;\n\t\tpmci_write_fifo(pmci->base + M10BMC_N6000_FLASH_FIFO,\n\t\t\t\t(u32 *)(buf + offset), write_count);\n\n\t\tsize -= blk_size;\n\t\toffset += blk_size;\n\t}\n\n\t \n\tif (size) {\n\t\tu32 tmp = 0;\n\n\t\tmemcpy(&tmp, buf + offset, size);\n\t\tpmci_write_fifo(pmci->base + M10BMC_N6000_FLASH_FIFO, &tmp, 1);\n\t}\n\n\treturn 0;\n}\n\nstatic int pmci_flash_bulk_read(struct intel_m10bmc *m10bmc, u8 *buf, u32 addr, u32 size)\n{\n\tstruct m10bmc_pmci_device *pmci = container_of(m10bmc, struct m10bmc_pmci_device, m10bmc);\n\tu32 blk_size, offset = 0, val, full_read_count, read_count;\n\tint ret;\n\n\twhile (size) {\n\t\tblk_size = min_t(u32, size, M10BMC_N6000_READ_BLOCK_SIZE);\n\t\tfull_read_count = blk_size / M10BMC_N6000_FIFO_WORD_SIZE;\n\n\t\tread_count = full_read_count;\n\t\tif (full_read_count * M10BMC_N6000_FIFO_WORD_SIZE < blk_size)\n\t\t\tread_count++;\n\n\t\twritel(addr + offset, pmci->base + M10BMC_N6000_FLASH_ADDR);\n\t\twritel(FIELD_PREP(M10BMC_N6000_FLASH_READ_COUNT, read_count) |\n\t\t       M10BMC_N6000_FLASH_RD_MODE,\n\t\t       pmci->base + M10BMC_N6000_FLASH_CTRL);\n\n\t\tret = readl_poll_timeout((pmci->base + M10BMC_N6000_FLASH_CTRL), val,\n\t\t\t\t\t !(val & M10BMC_N6000_FLASH_BUSY),\n\t\t\t\t\t M10BMC_FLASH_INT_US, M10BMC_FLASH_TIMEOUT_US);\n\t\tif (ret) {\n\t\t\tdev_err(m10bmc->dev, \"read timed out on reading flash 0x%xn\", val);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpmci_read_fifo(pmci->base + M10BMC_N6000_FLASH_FIFO,\n\t\t\t       (u32 *)(buf + offset), full_read_count);\n\n\t\tsize -= blk_size;\n\t\toffset += blk_size;\n\n\t\tif (full_read_count < read_count)\n\t\t\tbreak;\n\n\t\twritel(0, pmci->base + M10BMC_N6000_FLASH_CTRL);\n\t}\n\n\t \n\tif (size) {\n\t\tu32 tmp;\n\n\t\tpmci_read_fifo(pmci->base + M10BMC_N6000_FLASH_FIFO, &tmp, 1);\n\t\tmemcpy(buf + offset, &tmp, size);\n\n\t\twritel(0, pmci->base + M10BMC_N6000_FLASH_CTRL);\n\t}\n\n\treturn 0;\n}\n\nstatic int m10bmc_pmci_set_flash_host_mux(struct intel_m10bmc *m10bmc, bool request)\n{\n\tu32 ctrl;\n\tint ret;\n\n\tret = regmap_update_bits(m10bmc->regmap, M10BMC_N6000_FLASH_MUX_CTRL,\n\t\t\t\t M10BMC_N6000_FLASH_HOST_REQUEST,\n\t\t\t\t FIELD_PREP(M10BMC_N6000_FLASH_HOST_REQUEST, request));\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_read_poll_timeout(m10bmc->regmap,\n\t\t\t\t\tM10BMC_N6000_FLASH_MUX_CTRL, ctrl,\n\t\t\t\t\trequest ?\n\t\t\t\t\t(get_flash_mux(ctrl) == M10BMC_N6000_FLASH_MUX_HOST) :\n\t\t\t\t\t(get_flash_mux(ctrl) != M10BMC_N6000_FLASH_MUX_HOST),\n\t\t\t\t\tM10BMC_FLASH_INT_US, M10BMC_FLASH_TIMEOUT_US);\n}\n\nstatic int m10bmc_pmci_flash_read(struct intel_m10bmc *m10bmc, u8 *buf, u32 addr, u32 size)\n{\n\tstruct m10bmc_pmci_device *pmci = container_of(m10bmc, struct m10bmc_pmci_device, m10bmc);\n\tint ret, ret2;\n\n\tmutex_lock(&pmci->flash_mutex);\n\tif (pmci->flash_busy) {\n\t\tret = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\tret = m10bmc_pmci_set_flash_host_mux(m10bmc, true);\n\tif (ret)\n\t\tgoto mux_fail;\n\n\tret = pmci_flash_bulk_read(m10bmc, buf, addr, size);\n\nmux_fail:\n\tret2 = m10bmc_pmci_set_flash_host_mux(m10bmc, false);\n\nunlock:\n\tmutex_unlock(&pmci->flash_mutex);\n\tif (ret)\n\t\treturn ret;\n\treturn ret2;\n}\n\nstatic int m10bmc_pmci_flash_write(struct intel_m10bmc *m10bmc, const u8 *buf, u32 offset, u32 size)\n{\n\tstruct m10bmc_pmci_device *pmci = container_of(m10bmc, struct m10bmc_pmci_device, m10bmc);\n\tint ret;\n\n\tmutex_lock(&pmci->flash_mutex);\n\tWARN_ON_ONCE(!pmci->flash_busy);\n\t \n\tret = pmci_flash_bulk_write(m10bmc, buf + offset, size);\n\tmutex_unlock(&pmci->flash_mutex);\n\n\treturn ret;\n}\n\nstatic int m10bmc_pmci_flash_lock(struct intel_m10bmc *m10bmc)\n{\n\tstruct m10bmc_pmci_device *pmci = container_of(m10bmc, struct m10bmc_pmci_device, m10bmc);\n\tint ret = 0;\n\n\tmutex_lock(&pmci->flash_mutex);\n\tif (pmci->flash_busy) {\n\t\tret = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\tpmci->flash_busy = true;\n\nunlock:\n\tmutex_unlock(&pmci->flash_mutex);\n\treturn ret;\n}\n\nstatic void m10bmc_pmci_flash_unlock(struct intel_m10bmc *m10bmc)\n{\n\tstruct m10bmc_pmci_device *pmci = container_of(m10bmc, struct m10bmc_pmci_device, m10bmc);\n\n\tmutex_lock(&pmci->flash_mutex);\n\tWARN_ON_ONCE(!pmci->flash_busy);\n\tpmci->flash_busy = false;\n\tmutex_unlock(&pmci->flash_mutex);\n}\n\nstatic const struct intel_m10bmc_flash_bulk_ops m10bmc_pmci_flash_bulk_ops = {\n\t.read = m10bmc_pmci_flash_read,\n\t.write = m10bmc_pmci_flash_write,\n\t.lock_write = m10bmc_pmci_flash_lock,\n\t.unlock_write = m10bmc_pmci_flash_unlock,\n};\n\nstatic const struct regmap_range m10bmc_pmci_regmap_range[] = {\n\tregmap_reg_range(M10BMC_N6000_SYS_BASE, M10BMC_N6000_SYS_END),\n};\n\nstatic const struct regmap_access_table m10bmc_pmci_access_table = {\n\t.yes_ranges\t= m10bmc_pmci_regmap_range,\n\t.n_yes_ranges\t= ARRAY_SIZE(m10bmc_pmci_regmap_range),\n};\n\nstatic struct regmap_config m10bmc_pmci_regmap_config = {\n\t.reg_bits = 32,\n\t.reg_stride = 4,\n\t.val_bits = 32,\n\t.wr_table = &m10bmc_pmci_access_table,\n\t.rd_table = &m10bmc_pmci_access_table,\n\t.reg_read = &indirect_reg_read,\n\t.reg_write = &indirect_reg_write,\n\t.max_register = M10BMC_N6000_SYS_END,\n};\n\nstatic struct mfd_cell m10bmc_pmci_n6000_bmc_subdevs[] = {\n\t{ .name = \"n6000bmc-hwmon\" },\n\t{ .name = \"n6000bmc-sec-update\" },\n};\n\nstatic const struct m10bmc_csr_map m10bmc_n6000_csr_map = {\n\t.base = M10BMC_N6000_SYS_BASE,\n\t.build_version = M10BMC_N6000_BUILD_VER,\n\t.fw_version = NIOS2_N6000_FW_VERSION,\n\t.mac_low = M10BMC_N6000_MAC_LOW,\n\t.mac_high = M10BMC_N6000_MAC_HIGH,\n\t.doorbell = M10BMC_N6000_DOORBELL,\n\t.auth_result = M10BMC_N6000_AUTH_RESULT,\n\t.bmc_prog_addr = M10BMC_N6000_BMC_PROG_ADDR,\n\t.bmc_reh_addr = M10BMC_N6000_BMC_REH_ADDR,\n\t.bmc_magic = M10BMC_N6000_BMC_PROG_MAGIC,\n\t.sr_prog_addr = M10BMC_N6000_SR_PROG_ADDR,\n\t.sr_reh_addr = M10BMC_N6000_SR_REH_ADDR,\n\t.sr_magic = M10BMC_N6000_SR_PROG_MAGIC,\n\t.pr_prog_addr = M10BMC_N6000_PR_PROG_ADDR,\n\t.pr_reh_addr = M10BMC_N6000_PR_REH_ADDR,\n\t.pr_magic = M10BMC_N6000_PR_PROG_MAGIC,\n\t.rsu_update_counter = M10BMC_N6000_STAGING_FLASH_COUNT,\n};\n\nstatic const struct intel_m10bmc_platform_info m10bmc_pmci_n6000 = {\n\t.cells = m10bmc_pmci_n6000_bmc_subdevs,\n\t.n_cells = ARRAY_SIZE(m10bmc_pmci_n6000_bmc_subdevs),\n\t.csr_map = &m10bmc_n6000_csr_map,\n};\n\nstatic int m10bmc_pmci_probe(struct dfl_device *ddev)\n{\n\tstruct device *dev = &ddev->dev;\n\tstruct m10bmc_pmci_device *pmci;\n\tstruct indirect_ctx *ctx;\n\tint ret;\n\n\tpmci = devm_kzalloc(dev, sizeof(*pmci), GFP_KERNEL);\n\tif (!pmci)\n\t\treturn -ENOMEM;\n\n\tpmci->m10bmc.flash_bulk_ops = &m10bmc_pmci_flash_bulk_ops;\n\tpmci->m10bmc.dev = dev;\n\n\tpmci->base = devm_ioremap_resource(dev, &ddev->mmio_res);\n\tif (IS_ERR(pmci->base))\n\t\treturn PTR_ERR(pmci->base);\n\n\tctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&pmci->flash_mutex);\n\n\tctx->base = pmci->base + M10BMC_N6000_INDIRECT_BASE;\n\tctx->dev = dev;\n\tindirect_clear_cmd(ctx);\n\tpmci->m10bmc.regmap = devm_regmap_init(dev, NULL, ctx, &m10bmc_pmci_regmap_config);\n\n\tif (IS_ERR(pmci->m10bmc.regmap)) {\n\t\tret = PTR_ERR(pmci->m10bmc.regmap);\n\t\tgoto destroy_mutex;\n\t}\n\n\tret = m10bmc_dev_init(&pmci->m10bmc, &m10bmc_pmci_n6000);\n\tif (ret)\n\t\tgoto destroy_mutex;\n\treturn 0;\n\ndestroy_mutex:\n\tmutex_destroy(&pmci->flash_mutex);\n\treturn ret;\n}\n\nstatic void m10bmc_pmci_remove(struct dfl_device *ddev)\n{\n\tstruct intel_m10bmc *m10bmc = dev_get_drvdata(&ddev->dev);\n\tstruct m10bmc_pmci_device *pmci = container_of(m10bmc, struct m10bmc_pmci_device, m10bmc);\n\n\tmutex_destroy(&pmci->flash_mutex);\n}\n\n#define FME_FEATURE_ID_M10BMC_PMCI\t0x12\n\nstatic const struct dfl_device_id m10bmc_pmci_ids[] = {\n\t{ FME_ID, FME_FEATURE_ID_M10BMC_PMCI },\n\t{ }\n};\nMODULE_DEVICE_TABLE(dfl, m10bmc_pmci_ids);\n\nstatic struct dfl_driver m10bmc_pmci_driver = {\n\t.drv\t= {\n\t\t.name       = \"intel-m10-bmc\",\n\t\t.dev_groups = m10bmc_dev_groups,\n\t},\n\t.id_table = m10bmc_pmci_ids,\n\t.probe    = m10bmc_pmci_probe,\n\t.remove   = m10bmc_pmci_remove,\n};\n\nmodule_dfl_driver(m10bmc_pmci_driver);\n\nMODULE_DESCRIPTION(\"MAX10 BMC PMCI-based interface\");\nMODULE_AUTHOR(\"Intel Corporation\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(INTEL_M10_BMC_CORE);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}