{
  "module_name": "qcom-pm8xxx.c",
  "hash_id": "ebadf0327ee91f954d590b12fc449a9272bae63ed068416bb563f35037f88c2b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/qcom-pm8xxx.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"%s: \" fmt, __func__\n\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/ssbi.h>\n#include <linux/regmap.h>\n#include <linux/of_platform.h>\n#include <linux/mfd/core.h>\n\n#define\tSSBI_REG_ADDR_IRQ_BASE\t\t0x1BB\n\n#define\tSSBI_REG_ADDR_IRQ_ROOT\t\t(SSBI_REG_ADDR_IRQ_BASE + 0)\n#define\tSSBI_REG_ADDR_IRQ_M_STATUS1\t(SSBI_REG_ADDR_IRQ_BASE + 1)\n#define\tSSBI_REG_ADDR_IRQ_M_STATUS2\t(SSBI_REG_ADDR_IRQ_BASE + 2)\n#define\tSSBI_REG_ADDR_IRQ_M_STATUS3\t(SSBI_REG_ADDR_IRQ_BASE + 3)\n#define\tSSBI_REG_ADDR_IRQ_M_STATUS4\t(SSBI_REG_ADDR_IRQ_BASE + 4)\n#define\tSSBI_REG_ADDR_IRQ_BLK_SEL\t(SSBI_REG_ADDR_IRQ_BASE + 5)\n#define\tSSBI_REG_ADDR_IRQ_IT_STATUS\t(SSBI_REG_ADDR_IRQ_BASE + 6)\n#define\tSSBI_REG_ADDR_IRQ_CONFIG\t(SSBI_REG_ADDR_IRQ_BASE + 7)\n#define\tSSBI_REG_ADDR_IRQ_RT_STATUS\t(SSBI_REG_ADDR_IRQ_BASE + 8)\n\n#define\tPM8821_SSBI_REG_ADDR_IRQ_BASE\t0x100\n#define\tPM8821_SSBI_REG_ADDR_IRQ_MASTER0 (PM8821_SSBI_REG_ADDR_IRQ_BASE + 0x30)\n#define\tPM8821_SSBI_REG_ADDR_IRQ_MASTER1 (PM8821_SSBI_REG_ADDR_IRQ_BASE + 0xb0)\n#define\tPM8821_SSBI_REG(m, b, offset) \\\n\t\t\t((m == 0) ? \\\n\t\t\t(PM8821_SSBI_REG_ADDR_IRQ_MASTER0 + b + offset) : \\\n\t\t\t(PM8821_SSBI_REG_ADDR_IRQ_MASTER1 + b + offset))\n#define\tPM8821_SSBI_ADDR_IRQ_ROOT(m, b)\t\tPM8821_SSBI_REG(m, b, 0x0)\n#define\tPM8821_SSBI_ADDR_IRQ_CLEAR(m, b)\tPM8821_SSBI_REG(m, b, 0x01)\n#define\tPM8821_SSBI_ADDR_IRQ_MASK(m, b)\t\tPM8821_SSBI_REG(m, b, 0x08)\n#define\tPM8821_SSBI_ADDR_IRQ_RT_STATUS(m, b)\tPM8821_SSBI_REG(m, b, 0x0f)\n\n#define\tPM8821_BLOCKS_PER_MASTER\t7\n\n#define\tPM_IRQF_LVL_SEL\t\t\t0x01\t \n#define\tPM_IRQF_MASK_FE\t\t\t0x02\t \n#define\tPM_IRQF_MASK_RE\t\t\t0x04\t \n#define\tPM_IRQF_CLR\t\t\t0x08\t \n#define\tPM_IRQF_BITS_MASK\t\t0x70\n#define\tPM_IRQF_BITS_SHIFT\t\t4\n#define\tPM_IRQF_WRITE\t\t\t0x80\n\n#define\tPM_IRQF_MASK_ALL\t\t(PM_IRQF_MASK_FE | \\\n\t\t\t\t\tPM_IRQF_MASK_RE)\n\n#define REG_HWREV\t\t0x002   \n#define REG_HWREV_2\t\t0x0E8   \n\n#define PM8XXX_NR_IRQS\t\t256\n#define PM8821_NR_IRQS\t\t112\n\nstruct pm_irq_data {\n\tint num_irqs;\n\tstruct irq_chip *irq_chip;\n\tirq_handler_t irq_handler;\n};\n\nstruct pm_irq_chip {\n\tstruct regmap\t\t*regmap;\n\tspinlock_t\t\tpm_irq_lock;\n\tstruct irq_domain\t*irqdomain;\n\tunsigned int\t\tnum_blocks;\n\tunsigned int\t\tnum_masters;\n\tconst struct pm_irq_data *pm_irq_data;\n\t \n\tu8\t\t\tconfig[];\n};\n\nstatic int pm8xxx_read_block_irq(struct pm_irq_chip *chip, unsigned int bp,\n\t\t\t\t unsigned int *ip)\n{\n\tint\trc;\n\n\tspin_lock(&chip->pm_irq_lock);\n\trc = regmap_write(chip->regmap, SSBI_REG_ADDR_IRQ_BLK_SEL, bp);\n\tif (rc) {\n\t\tpr_err(\"Failed Selecting Block %d rc=%d\\n\", bp, rc);\n\t\tgoto bail;\n\t}\n\n\trc = regmap_read(chip->regmap, SSBI_REG_ADDR_IRQ_IT_STATUS, ip);\n\tif (rc)\n\t\tpr_err(\"Failed Reading Status rc=%d\\n\", rc);\nbail:\n\tspin_unlock(&chip->pm_irq_lock);\n\treturn rc;\n}\n\nstatic int\npm8xxx_config_irq(struct pm_irq_chip *chip, unsigned int bp, unsigned int cp)\n{\n\tint\trc;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chip->pm_irq_lock, flags);\n\trc = regmap_write(chip->regmap, SSBI_REG_ADDR_IRQ_BLK_SEL, bp);\n\tif (rc) {\n\t\tpr_err(\"Failed Selecting Block %d rc=%d\\n\", bp, rc);\n\t\tgoto bail;\n\t}\n\n\tcp |= PM_IRQF_WRITE;\n\trc = regmap_write(chip->regmap, SSBI_REG_ADDR_IRQ_CONFIG, cp);\n\tif (rc)\n\t\tpr_err(\"Failed Configuring IRQ rc=%d\\n\", rc);\nbail:\n\tspin_unlock_irqrestore(&chip->pm_irq_lock, flags);\n\treturn rc;\n}\n\nstatic int pm8xxx_irq_block_handler(struct pm_irq_chip *chip, int block)\n{\n\tint pmirq, i, ret = 0;\n\tunsigned int bits;\n\n\tret = pm8xxx_read_block_irq(chip, block, &bits);\n\tif (ret) {\n\t\tpr_err(\"Failed reading %d block ret=%d\", block, ret);\n\t\treturn ret;\n\t}\n\tif (!bits) {\n\t\tpr_err(\"block bit set in master but no irqs: %d\", block);\n\t\treturn 0;\n\t}\n\n\t \n\tfor (i = 0; i < 8; i++) {\n\t\tif (bits & (1 << i)) {\n\t\t\tpmirq = block * 8 + i;\n\t\t\tgeneric_handle_domain_irq(chip->irqdomain, pmirq);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int pm8xxx_irq_master_handler(struct pm_irq_chip *chip, int master)\n{\n\tunsigned int blockbits;\n\tint block_number, i, ret = 0;\n\n\tret = regmap_read(chip->regmap, SSBI_REG_ADDR_IRQ_M_STATUS1 + master,\n\t\t\t  &blockbits);\n\tif (ret) {\n\t\tpr_err(\"Failed to read master %d ret=%d\\n\", master, ret);\n\t\treturn ret;\n\t}\n\tif (!blockbits) {\n\t\tpr_err(\"master bit set in root but no blocks: %d\", master);\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < 8; i++)\n\t\tif (blockbits & (1 << i)) {\n\t\t\tblock_number = master * 8 + i;\t \n\t\t\tret |= pm8xxx_irq_block_handler(chip, block_number);\n\t\t}\n\treturn ret;\n}\n\nstatic irqreturn_t pm8xxx_irq_handler(int irq, void *data)\n{\n\tstruct pm_irq_chip *chip = data;\n\tunsigned int root;\n\tint\ti, ret, masters = 0;\n\n\tret = regmap_read(chip->regmap, SSBI_REG_ADDR_IRQ_ROOT, &root);\n\tif (ret) {\n\t\tpr_err(\"Can't read root status ret=%d\\n\", ret);\n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\tmasters = root >> 1;\n\n\t \n\tfor (i = 0; i < chip->num_masters; i++)\n\t\tif (masters & (1 << i))\n\t\t\tpm8xxx_irq_master_handler(chip, i);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void pm8821_irq_block_handler(struct pm_irq_chip *chip,\n\t\t\t\t     int master, int block)\n{\n\tint pmirq, i, ret;\n\tunsigned int bits;\n\n\tret = regmap_read(chip->regmap,\n\t\t\t  PM8821_SSBI_ADDR_IRQ_ROOT(master, block), &bits);\n\tif (ret) {\n\t\tpr_err(\"Reading block %d failed ret=%d\", block, ret);\n\t\treturn;\n\t}\n\n\t \n\tblock += (master * PM8821_BLOCKS_PER_MASTER) - 1;\n\n\t \n\tfor (i = 0; i < 8; i++) {\n\t\tif (bits & BIT(i)) {\n\t\t\tpmirq = block * 8 + i;\n\t\t\tgeneric_handle_domain_irq(chip->irqdomain, pmirq);\n\t\t}\n\t}\n}\n\nstatic inline void pm8821_irq_master_handler(struct pm_irq_chip *chip,\n\t\t\t\t\t     int master, u8 master_val)\n{\n\tint block;\n\n\tfor (block = 1; block < 8; block++)\n\t\tif (master_val & BIT(block))\n\t\t\tpm8821_irq_block_handler(chip, master, block);\n}\n\nstatic irqreturn_t pm8821_irq_handler(int irq, void *data)\n{\n\tstruct pm_irq_chip *chip = data;\n\tunsigned int master;\n\tint ret;\n\n\tret = regmap_read(chip->regmap,\n\t\t\t  PM8821_SSBI_REG_ADDR_IRQ_MASTER0, &master);\n\tif (ret) {\n\t\tpr_err(\"Failed to read master 0 ret=%d\\n\", ret);\n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\tif (master & GENMASK(7, 1))\n\t\tpm8821_irq_master_handler(chip, 0, master);\n\n\t \n\tif (!(master & BIT(0)))\n\t\treturn IRQ_NONE;\n\n\tret = regmap_read(chip->regmap,\n\t\t\t  PM8821_SSBI_REG_ADDR_IRQ_MASTER1, &master);\n\tif (ret) {\n\t\tpr_err(\"Failed to read master 1 ret=%d\\n\", ret);\n\t\treturn IRQ_NONE;\n\t}\n\n\tpm8821_irq_master_handler(chip, 1, master);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void pm8xxx_irq_mask_ack(struct irq_data *d)\n{\n\tstruct pm_irq_chip *chip = irq_data_get_irq_chip_data(d);\n\tunsigned int pmirq = irqd_to_hwirq(d);\n\tu8\tblock, config;\n\n\tblock = pmirq / 8;\n\n\tconfig = chip->config[pmirq] | PM_IRQF_MASK_ALL | PM_IRQF_CLR;\n\tpm8xxx_config_irq(chip, block, config);\n}\n\nstatic void pm8xxx_irq_unmask(struct irq_data *d)\n{\n\tstruct pm_irq_chip *chip = irq_data_get_irq_chip_data(d);\n\tunsigned int pmirq = irqd_to_hwirq(d);\n\tu8\tblock, config;\n\n\tblock = pmirq / 8;\n\n\tconfig = chip->config[pmirq];\n\tpm8xxx_config_irq(chip, block, config);\n}\n\nstatic int pm8xxx_irq_set_type(struct irq_data *d, unsigned int flow_type)\n{\n\tstruct pm_irq_chip *chip = irq_data_get_irq_chip_data(d);\n\tunsigned int pmirq = irqd_to_hwirq(d);\n\tint irq_bit;\n\tu8 block, config;\n\n\tblock = pmirq / 8;\n\tirq_bit  = pmirq % 8;\n\n\tchip->config[pmirq] = (irq_bit << PM_IRQF_BITS_SHIFT)\n\t\t\t\t\t\t\t| PM_IRQF_MASK_ALL;\n\tif (flow_type & (IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING)) {\n\t\tif (flow_type & IRQF_TRIGGER_RISING)\n\t\t\tchip->config[pmirq] &= ~PM_IRQF_MASK_RE;\n\t\tif (flow_type & IRQF_TRIGGER_FALLING)\n\t\t\tchip->config[pmirq] &= ~PM_IRQF_MASK_FE;\n\t} else {\n\t\tchip->config[pmirq] |= PM_IRQF_LVL_SEL;\n\n\t\tif (flow_type & IRQF_TRIGGER_HIGH)\n\t\t\tchip->config[pmirq] &= ~PM_IRQF_MASK_RE;\n\t\telse\n\t\t\tchip->config[pmirq] &= ~PM_IRQF_MASK_FE;\n\t}\n\n\tconfig = chip->config[pmirq] | PM_IRQF_CLR;\n\treturn pm8xxx_config_irq(chip, block, config);\n}\n\nstatic int pm8xxx_irq_get_irqchip_state(struct irq_data *d,\n\t\t\t\t\tenum irqchip_irq_state which,\n\t\t\t\t\tbool *state)\n{\n\tstruct pm_irq_chip *chip = irq_data_get_irq_chip_data(d);\n\tunsigned int pmirq = irqd_to_hwirq(d);\n\tunsigned int bits;\n\tunsigned long flags;\n\tint irq_bit;\n\tu8 block;\n\tint rc;\n\n\tif (which != IRQCHIP_STATE_LINE_LEVEL)\n\t\treturn -EINVAL;\n\n\tblock = pmirq / 8;\n\tirq_bit = pmirq % 8;\n\n\tspin_lock_irqsave(&chip->pm_irq_lock, flags);\n\trc = regmap_write(chip->regmap, SSBI_REG_ADDR_IRQ_BLK_SEL, block);\n\tif (rc) {\n\t\tpr_err(\"Failed Selecting Block %d rc=%d\\n\", block, rc);\n\t\tgoto bail;\n\t}\n\n\trc = regmap_read(chip->regmap, SSBI_REG_ADDR_IRQ_RT_STATUS, &bits);\n\tif (rc) {\n\t\tpr_err(\"Failed Reading Status rc=%d\\n\", rc);\n\t\tgoto bail;\n\t}\n\n\t*state = !!(bits & BIT(irq_bit));\nbail:\n\tspin_unlock_irqrestore(&chip->pm_irq_lock, flags);\n\n\treturn rc;\n}\n\nstatic struct irq_chip pm8xxx_irq_chip = {\n\t.name\t\t= \"pm8xxx\",\n\t.irq_mask_ack\t= pm8xxx_irq_mask_ack,\n\t.irq_unmask\t= pm8xxx_irq_unmask,\n\t.irq_set_type\t= pm8xxx_irq_set_type,\n\t.irq_get_irqchip_state = pm8xxx_irq_get_irqchip_state,\n\t.flags\t\t= IRQCHIP_MASK_ON_SUSPEND | IRQCHIP_SKIP_SET_WAKE,\n};\n\nstatic void pm8xxx_irq_domain_map(struct pm_irq_chip *chip,\n\t\t\t\t  struct irq_domain *domain, unsigned int irq,\n\t\t\t\t  irq_hw_number_t hwirq, unsigned int type)\n{\n\tirq_domain_set_info(domain, irq, hwirq, chip->pm_irq_data->irq_chip,\n\t\t\t    chip, handle_level_irq, NULL, NULL);\n\tirq_set_noprobe(irq);\n}\n\nstatic int pm8xxx_irq_domain_alloc(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t   unsigned int nr_irqs, void *data)\n{\n\tstruct pm_irq_chip *chip = domain->host_data;\n\tstruct irq_fwspec *fwspec = data;\n\tirq_hw_number_t hwirq;\n\tunsigned int type;\n\tint ret, i;\n\n\tret = irq_domain_translate_twocell(domain, fwspec, &hwirq, &type);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < nr_irqs; i++)\n\t\tpm8xxx_irq_domain_map(chip, domain, virq + i, hwirq + i, type);\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops pm8xxx_irq_domain_ops = {\n\t.alloc = pm8xxx_irq_domain_alloc,\n\t.free = irq_domain_free_irqs_common,\n\t.translate = irq_domain_translate_twocell,\n};\n\nstatic void pm8821_irq_mask_ack(struct irq_data *d)\n{\n\tstruct pm_irq_chip *chip = irq_data_get_irq_chip_data(d);\n\tunsigned int pmirq = irqd_to_hwirq(d);\n\tu8 block, master;\n\tint irq_bit, rc;\n\n\tblock = pmirq / 8;\n\tmaster = block / PM8821_BLOCKS_PER_MASTER;\n\tirq_bit = pmirq % 8;\n\tblock %= PM8821_BLOCKS_PER_MASTER;\n\n\trc = regmap_update_bits(chip->regmap,\n\t\t\t\tPM8821_SSBI_ADDR_IRQ_MASK(master, block),\n\t\t\t\tBIT(irq_bit), BIT(irq_bit));\n\tif (rc) {\n\t\tpr_err(\"Failed to mask IRQ:%d rc=%d\\n\", pmirq, rc);\n\t\treturn;\n\t}\n\n\trc = regmap_update_bits(chip->regmap,\n\t\t\t\tPM8821_SSBI_ADDR_IRQ_CLEAR(master, block),\n\t\t\t\tBIT(irq_bit), BIT(irq_bit));\n\tif (rc)\n\t\tpr_err(\"Failed to CLEAR IRQ:%d rc=%d\\n\", pmirq, rc);\n}\n\nstatic void pm8821_irq_unmask(struct irq_data *d)\n{\n\tstruct pm_irq_chip *chip = irq_data_get_irq_chip_data(d);\n\tunsigned int pmirq = irqd_to_hwirq(d);\n\tint irq_bit, rc;\n\tu8 block, master;\n\n\tblock = pmirq / 8;\n\tmaster = block / PM8821_BLOCKS_PER_MASTER;\n\tirq_bit = pmirq % 8;\n\tblock %= PM8821_BLOCKS_PER_MASTER;\n\n\trc = regmap_update_bits(chip->regmap,\n\t\t\t\tPM8821_SSBI_ADDR_IRQ_MASK(master, block),\n\t\t\t\tBIT(irq_bit), ~BIT(irq_bit));\n\tif (rc)\n\t\tpr_err(\"Failed to read/write unmask IRQ:%d rc=%d\\n\", pmirq, rc);\n\n}\n\nstatic int pm8821_irq_get_irqchip_state(struct irq_data *d,\n\t\t\t\t\tenum irqchip_irq_state which,\n\t\t\t\t\tbool *state)\n{\n\tstruct pm_irq_chip *chip = irq_data_get_irq_chip_data(d);\n\tint rc, pmirq = irqd_to_hwirq(d);\n\tu8 block, irq_bit, master;\n\tunsigned int bits;\n\n\tblock = pmirq / 8;\n\tmaster = block / PM8821_BLOCKS_PER_MASTER;\n\tirq_bit = pmirq % 8;\n\tblock %= PM8821_BLOCKS_PER_MASTER;\n\n\trc = regmap_read(chip->regmap,\n\t\tPM8821_SSBI_ADDR_IRQ_RT_STATUS(master, block), &bits);\n\tif (rc) {\n\t\tpr_err(\"Reading Status of IRQ %d failed rc=%d\\n\", pmirq, rc);\n\t\treturn rc;\n\t}\n\n\t*state = !!(bits & BIT(irq_bit));\n\n\treturn rc;\n}\n\nstatic struct irq_chip pm8821_irq_chip = {\n\t.name\t\t= \"pm8821\",\n\t.irq_mask_ack\t= pm8821_irq_mask_ack,\n\t.irq_unmask\t= pm8821_irq_unmask,\n\t.irq_get_irqchip_state = pm8821_irq_get_irqchip_state,\n\t.flags\t\t= IRQCHIP_MASK_ON_SUSPEND | IRQCHIP_SKIP_SET_WAKE,\n};\n\nstatic const struct regmap_config ssbi_regmap_config = {\n\t.reg_bits = 16,\n\t.val_bits = 8,\n\t.max_register = 0x3ff,\n\t.fast_io = true,\n\t.reg_read = ssbi_reg_read,\n\t.reg_write = ssbi_reg_write\n};\n\nstatic const struct pm_irq_data pm8xxx_data = {\n\t.num_irqs = PM8XXX_NR_IRQS,\n\t.irq_chip = &pm8xxx_irq_chip,\n\t.irq_handler = pm8xxx_irq_handler,\n};\n\nstatic const struct pm_irq_data pm8821_data = {\n\t.num_irqs = PM8821_NR_IRQS,\n\t.irq_chip = &pm8821_irq_chip,\n\t.irq_handler = pm8821_irq_handler,\n};\n\nstatic const struct of_device_id pm8xxx_id_table[] = {\n\t{ .compatible = \"qcom,pm8058\", .data = &pm8xxx_data},\n\t{ .compatible = \"qcom,pm8821\", .data = &pm8821_data},\n\t{ .compatible = \"qcom,pm8921\", .data = &pm8xxx_data},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, pm8xxx_id_table);\n\nstatic int pm8xxx_probe(struct platform_device *pdev)\n{\n\tconst struct pm_irq_data *data;\n\tstruct regmap *regmap;\n\tint irq, rc;\n\tunsigned int val;\n\tstruct pm_irq_chip *chip;\n\n\tdata = of_device_get_match_data(&pdev->dev);\n\tif (!data) {\n\t\tdev_err(&pdev->dev, \"No matching driver data found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tregmap = devm_regmap_init(&pdev->dev, NULL, pdev->dev.parent,\n\t\t\t\t  &ssbi_regmap_config);\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\t \n\trc = regmap_read(regmap, REG_HWREV, &val);\n\tif (rc) {\n\t\tpr_err(\"Failed to read hw rev reg %d:rc=%d\\n\", REG_HWREV, rc);\n\t\treturn rc;\n\t}\n\tpr_info(\"PMIC revision 1: %02X\\n\", val);\n\n\t \n\trc = regmap_read(regmap, REG_HWREV_2, &val);\n\tif (rc) {\n\t\tpr_err(\"Failed to read hw rev 2 reg %d:rc=%d\\n\",\n\t\t\tREG_HWREV_2, rc);\n\t\treturn rc;\n\t}\n\tpr_info(\"PMIC revision 2: %02X\\n\", val);\n\n\tchip = devm_kzalloc(&pdev->dev,\n\t\t\t    struct_size(chip, config, data->num_irqs),\n\t\t\t    GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, chip);\n\tchip->regmap = regmap;\n\tchip->num_blocks = DIV_ROUND_UP(data->num_irqs, 8);\n\tchip->num_masters = DIV_ROUND_UP(chip->num_blocks, 8);\n\tchip->pm_irq_data = data;\n\tspin_lock_init(&chip->pm_irq_lock);\n\n\tchip->irqdomain = irq_domain_add_linear(pdev->dev.of_node,\n\t\t\t\t\t\tdata->num_irqs,\n\t\t\t\t\t\t&pm8xxx_irq_domain_ops,\n\t\t\t\t\t\tchip);\n\tif (!chip->irqdomain)\n\t\treturn -ENODEV;\n\n\trc = devm_request_irq(&pdev->dev, irq, data->irq_handler, 0, dev_name(&pdev->dev), chip);\n\tif (rc)\n\t\treturn rc;\n\n\tirq_set_irq_wake(irq, 1);\n\n\trc = of_platform_populate(pdev->dev.of_node, NULL, NULL, &pdev->dev);\n\tif (rc)\n\t\tirq_domain_remove(chip->irqdomain);\n\n\treturn rc;\n}\n\nstatic int pm8xxx_remove_child(struct device *dev, void *unused)\n{\n\tplatform_device_unregister(to_platform_device(dev));\n\treturn 0;\n}\n\nstatic int pm8xxx_remove(struct platform_device *pdev)\n{\n\tstruct pm_irq_chip *chip = platform_get_drvdata(pdev);\n\n\tdevice_for_each_child(&pdev->dev, NULL, pm8xxx_remove_child);\n\tirq_domain_remove(chip->irqdomain);\n\n\treturn 0;\n}\n\nstatic struct platform_driver pm8xxx_driver = {\n\t.probe\t\t= pm8xxx_probe,\n\t.remove\t\t= pm8xxx_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"pm8xxx-core\",\n\t\t.of_match_table = pm8xxx_id_table,\n\t},\n};\n\nstatic int __init pm8xxx_init(void)\n{\n\treturn platform_driver_register(&pm8xxx_driver);\n}\nsubsys_initcall(pm8xxx_init);\n\nstatic void __exit pm8xxx_exit(void)\n{\n\tplatform_driver_unregister(&pm8xxx_driver);\n}\nmodule_exit(pm8xxx_exit);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"PMIC 8xxx core driver\");\nMODULE_VERSION(\"1.0\");\nMODULE_ALIAS(\"platform:pm8xxx-core\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}