{
  "module_name": "twl4030-power.c",
  "hash_id": "3d5b56dd4ed4d0eb07c2fd0d20d87e4fabd7b3008042937976ce86661372e51d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/twl4030-power.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/pm.h>\n#include <linux/mfd/twl.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n\n#include <asm/mach-types.h>\n\nstatic u8 twl4030_start_script_address = 0x2b;\n\n \n#define PWR_STOPON_PRWON\tBIT(6)\n#define PWR_STOPON_SYSEN\tBIT(5)\n#define PWR_ENABLE_WARMRESET\tBIT(4)\n#define PWR_LVL_WAKEUP\t\tBIT(3)\n#define PWR_DEVACT\t\tBIT(2)\n#define PWR_DEVSLP\t\tBIT(1)\n#define PWR_DEVOFF\t\tBIT(0)\n\n \n#define STARTON_SWBUG\t\tBIT(7)\t \n#define STARTON_VBUS\t\tBIT(5)\t \n#define STARTON_VBAT\t\tBIT(4)\t \n#define STARTON_RTC\t\tBIT(3)\t \n#define STARTON_USB\t\tBIT(2)\t \n#define STARTON_CHG\t\tBIT(1)\t \n#define STARTON_PWON\t\tBIT(0)\t \n\n#define SEQ_OFFSYNC\t\t(1 << 0)\n\n#define PHY_TO_OFF_PM_MASTER(p)\t\t(p - 0x36)\n#define PHY_TO_OFF_PM_RECEIVER(p)\t(p - 0x5b)\n\n \n#define R_HFCLKOUT_DEV_GRP \tPHY_TO_OFF_PM_RECEIVER(0xe6)\n\n \n#define R_P1_SW_EVENTS\t\tPHY_TO_OFF_PM_MASTER(0x46)\n#define R_P2_SW_EVENTS\t\tPHY_TO_OFF_PM_MASTER(0x47)\n#define R_P3_SW_EVENTS\t\tPHY_TO_OFF_PM_MASTER(0x48)\n#define R_CFG_P1_TRANSITION\tPHY_TO_OFF_PM_MASTER(0x36)\n#define R_CFG_P2_TRANSITION\tPHY_TO_OFF_PM_MASTER(0x37)\n#define R_CFG_P3_TRANSITION\tPHY_TO_OFF_PM_MASTER(0x38)\n\n#define END_OF_SCRIPT\t\t0x3f\n\n#define R_SEQ_ADD_A2S\t\tPHY_TO_OFF_PM_MASTER(0x55)\n#define R_SEQ_ADD_S2A12\t\tPHY_TO_OFF_PM_MASTER(0x56)\n#define\tR_SEQ_ADD_S2A3\t\tPHY_TO_OFF_PM_MASTER(0x57)\n#define\tR_SEQ_ADD_WARM\t\tPHY_TO_OFF_PM_MASTER(0x58)\n#define R_MEMORY_ADDRESS\tPHY_TO_OFF_PM_MASTER(0x59)\n#define R_MEMORY_DATA\t\tPHY_TO_OFF_PM_MASTER(0x5a)\n\n \n#define DEV_GRP_OFFSET\t\t0\n#define TYPE_OFFSET\t\t1\n#define REMAP_OFFSET\t\t2\n#define DEDICATED_OFFSET\t3\n\n \n\n \n#define DEV_GRP_SHIFT\t\t5\n#define DEV_GRP_MASK\t\t(7 << DEV_GRP_SHIFT)\n\n \n#define TYPE_SHIFT\t\t0\n#define TYPE_MASK\t\t(7 << TYPE_SHIFT)\n#define TYPE2_SHIFT\t\t3\n#define TYPE2_MASK\t\t(3 << TYPE2_SHIFT)\n\n \n#define SLEEP_STATE_SHIFT\t0\n#define SLEEP_STATE_MASK\t(0xf << SLEEP_STATE_SHIFT)\n#define OFF_STATE_SHIFT\t\t4\n#define OFF_STATE_MASK\t\t(0xf << OFF_STATE_SHIFT)\n\nstatic u8 res_config_addrs[] = {\n\t[RES_VAUX1]\t= 0x17,\n\t[RES_VAUX2]\t= 0x1b,\n\t[RES_VAUX3]\t= 0x1f,\n\t[RES_VAUX4]\t= 0x23,\n\t[RES_VMMC1]\t= 0x27,\n\t[RES_VMMC2]\t= 0x2b,\n\t[RES_VPLL1]\t= 0x2f,\n\t[RES_VPLL2]\t= 0x33,\n\t[RES_VSIM]\t= 0x37,\n\t[RES_VDAC]\t= 0x3b,\n\t[RES_VINTANA1]\t= 0x3f,\n\t[RES_VINTANA2]\t= 0x43,\n\t[RES_VINTDIG]\t= 0x47,\n\t[RES_VIO]\t= 0x4b,\n\t[RES_VDD1]\t= 0x55,\n\t[RES_VDD2]\t= 0x63,\n\t[RES_VUSB_1V5]\t= 0x71,\n\t[RES_VUSB_1V8]\t= 0x74,\n\t[RES_VUSB_3V1]\t= 0x77,\n\t[RES_VUSBCP]\t= 0x7a,\n\t[RES_REGEN]\t= 0x7f,\n\t[RES_NRES_PWRON] = 0x82,\n\t[RES_CLKEN]\t= 0x85,\n\t[RES_SYSEN]\t= 0x88,\n\t[RES_HFCLKOUT]\t= 0x8b,\n\t[RES_32KCLKOUT]\t= 0x8e,\n\t[RES_RESET]\t= 0x91,\n\t[RES_MAIN_REF]\t= 0x94,\n};\n\n \nenum {\n\tTWL_REMAP_OFF = 0,\n\tTWL_REMAP_SLEEP = 8,\n\tTWL_REMAP_ACTIVE = 9,\n};\n\n \n#define TWL_DFLT_DELAY\t\t2\t \n#define TWL_DEV_GRP_P123\t(DEV_GRP_P1 | DEV_GRP_P2 | DEV_GRP_P3)\n#define TWL_RESOURCE_SET(res, state)\t\t\t\t\t\\\n\t{ MSG_SINGULAR(DEV_GRP_NULL, (res), (state)), TWL_DFLT_DELAY }\n#define TWL_RESOURCE_ON(res)\tTWL_RESOURCE_SET(res, RES_STATE_ACTIVE)\n#define TWL_RESOURCE_OFF(res)\tTWL_RESOURCE_SET(res, RES_STATE_OFF)\n#define TWL_RESOURCE_RESET(res)\tTWL_RESOURCE_SET(res, RES_STATE_WRST)\n \n#define TWL_RESOURCE_SET_ACTIVE(res, state)\t\t\t       \t\\\n\t{ MSG_SINGULAR(DEV_GRP_NULL, (res), RES_STATE_ACTIVE), (state) }\n#define TWL_RESOURCE_GROUP_RESET(group, type1, type2)\t\t\t\\\n\t{ MSG_BROADCAST(DEV_GRP_NULL, (group), (type1), (type2),\t\\\n\t\tRES_STATE_WRST), TWL_DFLT_DELAY }\n#define TWL_RESOURCE_GROUP_SLEEP(group, type, type2)\t\t\t\\\n\t{ MSG_BROADCAST(DEV_GRP_NULL, (group), (type), (type2),\t\t\\\n\t\tRES_STATE_SLEEP), TWL_DFLT_DELAY }\n#define TWL_RESOURCE_GROUP_ACTIVE(group, type, type2)\t\t\t\\\n\t{ MSG_BROADCAST(DEV_GRP_NULL, (group), (type), (type2),\t\t\\\n\t\tRES_STATE_ACTIVE), TWL_DFLT_DELAY }\n#define TWL_REMAP_SLEEP(res, devgrp, typ, typ2)\t\t\t\t\\\n\t{ .resource = (res), .devgroup = (devgrp),\t\t\t\\\n\t  .type = (typ), .type2 = (typ2),\t\t\t\t\\\n\t  .remap_off = TWL_REMAP_OFF,\t\t\t\t\t\\\n\t  .remap_sleep = TWL_REMAP_SLEEP, }\n#define TWL_REMAP_OFF(res, devgrp, typ, typ2)\t\t\t\t\\\n\t{ .resource = (res), .devgroup = (devgrp),\t\t\t\\\n\t  .type = (typ), .type2 = (typ2),\t\t\t\t\\\n\t  .remap_off = TWL_REMAP_OFF, .remap_sleep = TWL_REMAP_OFF, }\n\nstatic int twl4030_write_script_byte(u8 address, u8 byte)\n{\n\tint err;\n\n\terr = twl_i2c_write_u8(TWL_MODULE_PM_MASTER, address, R_MEMORY_ADDRESS);\n\tif (err)\n\t\tgoto out;\n\terr = twl_i2c_write_u8(TWL_MODULE_PM_MASTER, byte, R_MEMORY_DATA);\nout:\n\treturn err;\n}\n\nstatic int twl4030_write_script_ins(u8 address, u16 pmb_message,\n\t\t\t\t\t   u8 delay, u8 next)\n{\n\tint err;\n\n\taddress *= 4;\n\terr = twl4030_write_script_byte(address++, pmb_message >> 8);\n\tif (err)\n\t\tgoto out;\n\terr = twl4030_write_script_byte(address++, pmb_message & 0xff);\n\tif (err)\n\t\tgoto out;\n\terr = twl4030_write_script_byte(address++, delay);\n\tif (err)\n\t\tgoto out;\n\terr = twl4030_write_script_byte(address++, next);\nout:\n\treturn err;\n}\n\nstatic int twl4030_write_script(u8 address, struct twl4030_ins *script,\n\t\t\t\t       int len)\n{\n\tint err = -EINVAL;\n\n\tfor (; len; len--, address++, script++) {\n\t\tif (len == 1) {\n\t\t\terr = twl4030_write_script_ins(address,\n\t\t\t\t\t\tscript->pmb_message,\n\t\t\t\t\t\tscript->delay,\n\t\t\t\t\t\tEND_OF_SCRIPT);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\terr = twl4030_write_script_ins(address,\n\t\t\t\t\t\tscript->pmb_message,\n\t\t\t\t\t\tscript->delay,\n\t\t\t\t\t\taddress + 1);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn err;\n}\n\nstatic int twl4030_config_wakeup3_sequence(u8 address)\n{\n\tint err;\n\tu8 data;\n\n\t \n\terr = twl_i2c_write_u8(TWL_MODULE_PM_MASTER, address, R_SEQ_ADD_S2A3);\n\tif (err)\n\t\tgoto out;\n\n\t \n\terr = twl_i2c_read_u8(TWL_MODULE_PM_MASTER, &data, R_P3_SW_EVENTS);\n\tif (err)\n\t\tgoto out;\n\tdata |= PWR_LVL_WAKEUP;\n\terr = twl_i2c_write_u8(TWL_MODULE_PM_MASTER, data, R_P3_SW_EVENTS);\nout:\n\tif (err)\n\t\tpr_err(\"TWL4030 wakeup sequence for P3 config error\\n\");\n\treturn err;\n}\n\nstatic int\ntwl4030_config_wakeup12_sequence(const struct twl4030_power_data *pdata,\n\t\t\t\t u8 address)\n{\n\tint err = 0;\n\tu8 data;\n\n\t \n\terr = twl_i2c_write_u8(TWL_MODULE_PM_MASTER, address, R_SEQ_ADD_S2A12);\n\tif (err)\n\t\tgoto out;\n\n\t \n\terr = twl_i2c_read_u8(TWL_MODULE_PM_MASTER, &data, R_P1_SW_EVENTS);\n\tif (err)\n\t\tgoto out;\n\n\tdata |= PWR_LVL_WAKEUP;\n\terr = twl_i2c_write_u8(TWL_MODULE_PM_MASTER, data, R_P1_SW_EVENTS);\n\tif (err)\n\t\tgoto out;\n\n\terr = twl_i2c_read_u8(TWL_MODULE_PM_MASTER, &data, R_P2_SW_EVENTS);\n\tif (err)\n\t\tgoto out;\n\n\tdata |= PWR_LVL_WAKEUP;\n\terr = twl_i2c_write_u8(TWL_MODULE_PM_MASTER, data, R_P2_SW_EVENTS);\n\tif (err)\n\t\tgoto out;\n\n\tif (pdata->ac_charger_quirk || machine_is_omap_3430sdp() ||\n\t    machine_is_omap_ldp()) {\n\t\t \n\t\terr = twl_i2c_read_u8(TWL_MODULE_PM_MASTER, &data,\n\t\t\t\t      R_CFG_P1_TRANSITION);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tdata &= ~STARTON_CHG;\n\t\terr = twl_i2c_write_u8(TWL_MODULE_PM_MASTER, data,\n\t\t\t\t       R_CFG_P1_TRANSITION);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\nout:\n\tif (err)\n\t\tpr_err(\"TWL4030 wakeup sequence for P1 and P2\" \\\n\t\t\t\"config error\\n\");\n\treturn err;\n}\n\nstatic int twl4030_config_sleep_sequence(u8 address)\n{\n\tint err;\n\n\t \n\terr = twl_i2c_write_u8(TWL_MODULE_PM_MASTER, address, R_SEQ_ADD_A2S);\n\n\tif (err)\n\t\tpr_err(\"TWL4030 sleep sequence config error\\n\");\n\n\treturn err;\n}\n\nstatic int twl4030_config_warmreset_sequence(u8 address)\n{\n\tint err;\n\tu8 rd_data;\n\n\t \n\terr = twl_i2c_write_u8(TWL_MODULE_PM_MASTER, address, R_SEQ_ADD_WARM);\n\tif (err)\n\t\tgoto out;\n\n\t \n\terr = twl_i2c_read_u8(TWL_MODULE_PM_MASTER, &rd_data, R_P1_SW_EVENTS);\n\tif (err)\n\t\tgoto out;\n\n\trd_data |= PWR_ENABLE_WARMRESET;\n\terr = twl_i2c_write_u8(TWL_MODULE_PM_MASTER, rd_data, R_P1_SW_EVENTS);\n\tif (err)\n\t\tgoto out;\n\n\terr = twl_i2c_read_u8(TWL_MODULE_PM_MASTER, &rd_data, R_P2_SW_EVENTS);\n\tif (err)\n\t\tgoto out;\n\n\trd_data |= PWR_ENABLE_WARMRESET;\n\terr = twl_i2c_write_u8(TWL_MODULE_PM_MASTER, rd_data, R_P2_SW_EVENTS);\n\tif (err)\n\t\tgoto out;\n\n\terr = twl_i2c_read_u8(TWL_MODULE_PM_MASTER, &rd_data, R_P3_SW_EVENTS);\n\tif (err)\n\t\tgoto out;\n\n\trd_data |= PWR_ENABLE_WARMRESET;\n\terr = twl_i2c_write_u8(TWL_MODULE_PM_MASTER, rd_data, R_P3_SW_EVENTS);\nout:\n\tif (err)\n\t\tpr_err(\"TWL4030 warmreset seq config error\\n\");\n\treturn err;\n}\n\nstatic int twl4030_configure_resource(struct twl4030_resconfig *rconfig)\n{\n\tint rconfig_addr;\n\tint err;\n\tu8 type;\n\tu8 grp;\n\tu8 remap;\n\n\tif (rconfig->resource > TOTAL_RESOURCES) {\n\t\tpr_err(\"TWL4030 Resource %d does not exist\\n\",\n\t\t\trconfig->resource);\n\t\treturn -EINVAL;\n\t}\n\n\trconfig_addr = res_config_addrs[rconfig->resource];\n\n\t \n\terr = twl_i2c_read_u8(TWL_MODULE_PM_RECEIVER, &grp,\n\t\t\t      rconfig_addr + DEV_GRP_OFFSET);\n\tif (err) {\n\t\tpr_err(\"TWL4030 Resource %d group could not be read\\n\",\n\t\t\trconfig->resource);\n\t\treturn err;\n\t}\n\n\tif (rconfig->devgroup != TWL4030_RESCONFIG_UNDEF) {\n\t\tgrp &= ~DEV_GRP_MASK;\n\t\tgrp |= rconfig->devgroup << DEV_GRP_SHIFT;\n\t\terr = twl_i2c_write_u8(TWL_MODULE_PM_RECEIVER,\n\t\t\t\t       grp, rconfig_addr + DEV_GRP_OFFSET);\n\t\tif (err < 0) {\n\t\t\tpr_err(\"TWL4030 failed to program devgroup\\n\");\n\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\terr = twl_i2c_read_u8(TWL_MODULE_PM_RECEIVER, &type,\n\t\t\t\trconfig_addr + TYPE_OFFSET);\n\tif (err < 0) {\n\t\tpr_err(\"TWL4030 Resource %d type could not be read\\n\",\n\t\t\trconfig->resource);\n\t\treturn err;\n\t}\n\n\tif (rconfig->type != TWL4030_RESCONFIG_UNDEF) {\n\t\ttype &= ~TYPE_MASK;\n\t\ttype |= rconfig->type << TYPE_SHIFT;\n\t}\n\n\tif (rconfig->type2 != TWL4030_RESCONFIG_UNDEF) {\n\t\ttype &= ~TYPE2_MASK;\n\t\ttype |= rconfig->type2 << TYPE2_SHIFT;\n\t}\n\n\terr = twl_i2c_write_u8(TWL_MODULE_PM_RECEIVER,\n\t\t\t\ttype, rconfig_addr + TYPE_OFFSET);\n\tif (err < 0) {\n\t\tpr_err(\"TWL4030 failed to program resource type\\n\");\n\t\treturn err;\n\t}\n\n\t \n\terr = twl_i2c_read_u8(TWL_MODULE_PM_RECEIVER, &remap,\n\t\t\t      rconfig_addr + REMAP_OFFSET);\n\tif (err < 0) {\n\t\tpr_err(\"TWL4030 Resource %d remap could not be read\\n\",\n\t\t\trconfig->resource);\n\t\treturn err;\n\t}\n\n\tif (rconfig->remap_off != TWL4030_RESCONFIG_UNDEF) {\n\t\tremap &= ~OFF_STATE_MASK;\n\t\tremap |= rconfig->remap_off << OFF_STATE_SHIFT;\n\t}\n\n\tif (rconfig->remap_sleep != TWL4030_RESCONFIG_UNDEF) {\n\t\tremap &= ~SLEEP_STATE_MASK;\n\t\tremap |= rconfig->remap_sleep << SLEEP_STATE_SHIFT;\n\t}\n\n\terr = twl_i2c_write_u8(TWL_MODULE_PM_RECEIVER,\n\t\t\t       remap,\n\t\t\t       rconfig_addr + REMAP_OFFSET);\n\tif (err < 0) {\n\t\tpr_err(\"TWL4030 failed to program remap\\n\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int load_twl4030_script(const struct twl4030_power_data *pdata,\n\t\t\t       struct twl4030_script *tscript,\n\t\t\t       u8 address)\n{\n\tint err;\n\tstatic int order;\n\n\t \n\tif ((address + tscript->size) > END_OF_SCRIPT) {\n\t\tpr_err(\"TWL4030 scripts too big error\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = twl4030_write_script(address, tscript->script, tscript->size);\n\tif (err)\n\t\tgoto out;\n\n\tif (tscript->flags & TWL4030_WRST_SCRIPT) {\n\t\terr = twl4030_config_warmreset_sequence(address);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\tif (tscript->flags & TWL4030_WAKEUP12_SCRIPT) {\n\t\t \n\t\terr = twl_i2c_write_u8(TWL_MODULE_PM_MASTER, END_OF_SCRIPT,\n\t\t\t\t       R_SEQ_ADD_A2S);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = twl4030_config_wakeup12_sequence(pdata, address);\n\t\tif (err)\n\t\t\tgoto out;\n\t\torder = 1;\n\t}\n\tif (tscript->flags & TWL4030_WAKEUP3_SCRIPT) {\n\t\terr = twl4030_config_wakeup3_sequence(address);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\tif (tscript->flags & TWL4030_SLEEP_SCRIPT) {\n\t\tif (!order)\n\t\t\tpr_warn(\"TWL4030: Bad order of scripts (sleep script before wakeup) Leads to boot failure on some boards\\n\");\n\t\terr = twl4030_config_sleep_sequence(address);\n\t}\nout:\n\treturn err;\n}\n\nint twl4030_remove_script(u8 flags)\n{\n\tint err = 0;\n\n\terr = twl_i2c_write_u8(TWL_MODULE_PM_MASTER, TWL4030_PM_MASTER_KEY_CFG1,\n\t\t\t       TWL4030_PM_MASTER_PROTECT_KEY);\n\tif (err) {\n\t\tpr_err(\"twl4030: unable to unlock PROTECT_KEY\\n\");\n\t\treturn err;\n\t}\n\n\terr = twl_i2c_write_u8(TWL_MODULE_PM_MASTER, TWL4030_PM_MASTER_KEY_CFG2,\n\t\t\t       TWL4030_PM_MASTER_PROTECT_KEY);\n\tif (err) {\n\t\tpr_err(\"twl4030: unable to unlock PROTECT_KEY\\n\");\n\t\treturn err;\n\t}\n\n\tif (flags & TWL4030_WRST_SCRIPT) {\n\t\terr = twl_i2c_write_u8(TWL_MODULE_PM_MASTER, END_OF_SCRIPT,\n\t\t\t\t       R_SEQ_ADD_WARM);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (flags & TWL4030_WAKEUP12_SCRIPT) {\n\t\terr = twl_i2c_write_u8(TWL_MODULE_PM_MASTER, END_OF_SCRIPT,\n\t\t\t\t       R_SEQ_ADD_S2A12);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (flags & TWL4030_WAKEUP3_SCRIPT) {\n\t\terr = twl_i2c_write_u8(TWL_MODULE_PM_MASTER, END_OF_SCRIPT,\n\t\t\t\t       R_SEQ_ADD_S2A3);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (flags & TWL4030_SLEEP_SCRIPT) {\n\t\terr = twl_i2c_write_u8(TWL_MODULE_PM_MASTER, END_OF_SCRIPT,\n\t\t\t\t       R_SEQ_ADD_A2S);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = twl_i2c_write_u8(TWL_MODULE_PM_MASTER, 0,\n\t\t\t       TWL4030_PM_MASTER_PROTECT_KEY);\n\tif (err)\n\t\tpr_err(\"TWL4030 Unable to relock registers\\n\");\n\n\treturn err;\n}\n\nstatic int\ntwl4030_power_configure_scripts(const struct twl4030_power_data *pdata)\n{\n\tint err;\n\tint i;\n\tu8 address = twl4030_start_script_address;\n\n\tfor (i = 0; i < pdata->num; i++) {\n\t\terr = load_twl4030_script(pdata, pdata->scripts[i], address);\n\t\tif (err)\n\t\t\treturn err;\n\t\taddress += pdata->scripts[i]->size;\n\t}\n\n\treturn 0;\n}\n\nstatic void twl4030_patch_rconfig(struct twl4030_resconfig *common,\n\t\t\t\t  struct twl4030_resconfig *board)\n{\n\twhile (common->resource) {\n\t\tstruct twl4030_resconfig *b = board;\n\n\t\twhile (b->resource) {\n\t\t\tif (b->resource == common->resource) {\n\t\t\t\t*common = *b;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tb++;\n\t\t}\n\t\tcommon++;\n\t}\n}\n\nstatic int\ntwl4030_power_configure_resources(const struct twl4030_power_data *pdata)\n{\n\tstruct twl4030_resconfig *resconfig = pdata->resource_config;\n\tstruct twl4030_resconfig *boardconf = pdata->board_config;\n\tint err;\n\n\tif (resconfig) {\n\t\tif (boardconf)\n\t\t\ttwl4030_patch_rconfig(resconfig, boardconf);\n\n\t\twhile (resconfig->resource) {\n\t\t\terr = twl4030_configure_resource(resconfig);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tresconfig++;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int twl4030_starton_mask_and_set(u8 bitmask, u8 bitvalues)\n{\n\tu8 regs[3] = { TWL4030_PM_MASTER_CFG_P1_TRANSITION,\n\t\t       TWL4030_PM_MASTER_CFG_P2_TRANSITION,\n\t\t       TWL4030_PM_MASTER_CFG_P3_TRANSITION, };\n\tu8 val;\n\tint i, err;\n\n\terr = twl_i2c_write_u8(TWL_MODULE_PM_MASTER, TWL4030_PM_MASTER_KEY_CFG1,\n\t\t\t       TWL4030_PM_MASTER_PROTECT_KEY);\n\tif (err)\n\t\tgoto relock;\n\terr = twl_i2c_write_u8(TWL_MODULE_PM_MASTER,\n\t\t\t       TWL4030_PM_MASTER_KEY_CFG2,\n\t\t\t       TWL4030_PM_MASTER_PROTECT_KEY);\n\tif (err)\n\t\tgoto relock;\n\n\tfor (i = 0; i < sizeof(regs); i++) {\n\t\terr = twl_i2c_read_u8(TWL_MODULE_PM_MASTER,\n\t\t\t\t      &val, regs[i]);\n\t\tif (err)\n\t\t\tbreak;\n\t\tval = (~bitmask & val) | (bitmask & bitvalues);\n\t\terr = twl_i2c_write_u8(TWL_MODULE_PM_MASTER,\n\t\t\t\t       val, regs[i]);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tif (err)\n\t\tpr_err(\"TWL4030 Register access failed: %i\\n\", err);\n\nrelock:\n\treturn twl_i2c_write_u8(TWL_MODULE_PM_MASTER, 0,\n\t\t\t\tTWL4030_PM_MASTER_PROTECT_KEY);\n}\n\n \nvoid twl4030_power_off(void)\n{\n\tint err;\n\n\t \n\terr = twl4030_starton_mask_and_set(STARTON_VBUS | STARTON_CHG, 0);\n\tif (err)\n\t\tpr_err(\"TWL4030 Unable to configure start-up\\n\");\n\n\terr = twl_i2c_write_u8(TWL_MODULE_PM_MASTER, PWR_DEVOFF,\n\t\t\t       TWL4030_PM_MASTER_P1_SW_EVENTS);\n\tif (err)\n\t\tpr_err(\"TWL4030 Unable to power off\\n\");\n}\n\nstatic bool twl4030_power_use_poweroff(const struct twl4030_power_data *pdata,\n\t\t\t\t\tstruct device_node *node)\n{\n\tif (pdata && pdata->use_poweroff)\n\t\treturn true;\n\n\tif (of_property_read_bool(node, \"ti,system-power-controller\"))\n\t\treturn true;\n\n\tif (of_property_read_bool(node, \"ti,use_poweroff\"))\n\t\treturn true;\n\n\treturn false;\n}\n\n#ifdef CONFIG_OF\n\n \n\nstatic struct twl4030_ins omap3_wrst_seq[] = {\n\tTWL_RESOURCE_OFF(RES_NRES_PWRON),\n\tTWL_RESOURCE_OFF(RES_RESET),\n\tTWL_RESOURCE_RESET(RES_MAIN_REF),\n\tTWL_RESOURCE_GROUP_RESET(RES_GRP_ALL, RES_TYPE_R0, RES_TYPE2_R2),\n\tTWL_RESOURCE_RESET(RES_VUSB_3V1),\n\tTWL_RESOURCE_RESET(RES_VMMC1),\n\tTWL_RESOURCE_GROUP_RESET(RES_GRP_ALL, RES_TYPE_R0, RES_TYPE2_R1),\n\tTWL_RESOURCE_GROUP_RESET(RES_GRP_RC, RES_TYPE_ALL, RES_TYPE2_R0),\n\tTWL_RESOURCE_ON(RES_RESET),\n\tTWL_RESOURCE_ON(RES_NRES_PWRON),\n};\n\nstatic struct twl4030_script omap3_wrst_script = {\n\t.script\t= omap3_wrst_seq,\n\t.size\t= ARRAY_SIZE(omap3_wrst_seq),\n\t.flags\t= TWL4030_WRST_SCRIPT,\n};\n\nstatic struct twl4030_script *omap3_reset_scripts[] = {\n\t&omap3_wrst_script,\n};\n\nstatic struct twl4030_resconfig omap3_rconfig[] = {\n\tTWL_REMAP_SLEEP(RES_HFCLKOUT, DEV_GRP_P3, -1, -1),\n\tTWL_REMAP_SLEEP(RES_VDD1, DEV_GRP_P1, -1, -1),\n\tTWL_REMAP_SLEEP(RES_VDD2, DEV_GRP_P1, -1, -1),\n\t{ 0, 0 },\n};\n\nstatic struct twl4030_power_data omap3_reset = {\n\t.scripts\t\t= omap3_reset_scripts,\n\t.num\t\t\t= ARRAY_SIZE(omap3_reset_scripts),\n\t.resource_config\t= omap3_rconfig,\n};\n\n \n\n \nstatic struct twl4030_ins omap3_idle_sleep_on_seq[] = {\n\tTWL_RESOURCE_GROUP_SLEEP(RES_GRP_ALL, RES_TYPE_ALL, 0),\n};\n\nstatic struct twl4030_script omap3_idle_sleep_on_script = {\n\t.script\t= omap3_idle_sleep_on_seq,\n\t.size\t= ARRAY_SIZE(omap3_idle_sleep_on_seq),\n\t.flags\t= TWL4030_SLEEP_SCRIPT,\n};\n\n \nstatic struct twl4030_ins omap3_idle_wakeup_p12_seq[] = {\n\tTWL_RESOURCE_GROUP_ACTIVE(RES_GRP_ALL, RES_TYPE_ALL, 0),\n};\n\nstatic struct twl4030_script omap3_idle_wakeup_p12_script = {\n\t.script\t= omap3_idle_wakeup_p12_seq,\n\t.size\t= ARRAY_SIZE(omap3_idle_wakeup_p12_seq),\n\t.flags\t= TWL4030_WAKEUP12_SCRIPT,\n};\n\n \nstatic struct twl4030_ins omap3_idle_wakeup_p3_seq[] = {\n\tTWL_RESOURCE_SET_ACTIVE(RES_CLKEN, 0x37),\n\tTWL_RESOURCE_GROUP_ACTIVE(RES_GRP_ALL, RES_TYPE_ALL, 0),\n};\n\nstatic struct twl4030_script omap3_idle_wakeup_p3_script = {\n\t.script\t= omap3_idle_wakeup_p3_seq,\n\t.size\t= ARRAY_SIZE(omap3_idle_wakeup_p3_seq),\n\t.flags\t= TWL4030_WAKEUP3_SCRIPT,\n};\n\nstatic struct twl4030_script *omap3_idle_scripts[] = {\n\t&omap3_idle_wakeup_p12_script,\n\t&omap3_idle_wakeup_p3_script,\n\t&omap3_wrst_script,\n\t&omap3_idle_sleep_on_script,\n};\n\n \nstatic struct twl4030_resconfig omap3_idle_rconfig[] = {\n\tTWL_REMAP_SLEEP(RES_VAUX1, TWL4030_RESCONFIG_UNDEF, 0, 0),\n\tTWL_REMAP_SLEEP(RES_VAUX2, TWL4030_RESCONFIG_UNDEF, 0, 0),\n\tTWL_REMAP_SLEEP(RES_VAUX3, TWL4030_RESCONFIG_UNDEF, 0, 0),\n\tTWL_REMAP_SLEEP(RES_VAUX4, TWL4030_RESCONFIG_UNDEF, 0, 0),\n\tTWL_REMAP_SLEEP(RES_VMMC1, TWL4030_RESCONFIG_UNDEF, 0, 0),\n\tTWL_REMAP_SLEEP(RES_VMMC2, TWL4030_RESCONFIG_UNDEF, 0, 0),\n\tTWL_REMAP_OFF(RES_VPLL1, DEV_GRP_P1, 3, 1),\n\tTWL_REMAP_SLEEP(RES_VPLL2, DEV_GRP_P1, 0, 0),\n\tTWL_REMAP_SLEEP(RES_VSIM, TWL4030_RESCONFIG_UNDEF, 0, 0),\n\tTWL_REMAP_SLEEP(RES_VDAC, TWL4030_RESCONFIG_UNDEF, 0, 0),\n\tTWL_REMAP_SLEEP(RES_VINTANA1, TWL_DEV_GRP_P123, 1, 2),\n\tTWL_REMAP_SLEEP(RES_VINTANA2, TWL_DEV_GRP_P123, 0, 2),\n\tTWL_REMAP_SLEEP(RES_VINTDIG, TWL_DEV_GRP_P123, 1, 2),\n\tTWL_REMAP_SLEEP(RES_VIO, TWL_DEV_GRP_P123, 2, 2),\n\tTWL_REMAP_OFF(RES_VDD1, DEV_GRP_P1, 4, 1),\n\tTWL_REMAP_OFF(RES_VDD2, DEV_GRP_P1, 3, 1),\n\tTWL_REMAP_SLEEP(RES_VUSB_1V5, TWL4030_RESCONFIG_UNDEF, 0, 0),\n\tTWL_REMAP_SLEEP(RES_VUSB_1V8, TWL4030_RESCONFIG_UNDEF, 0, 0),\n\tTWL_REMAP_SLEEP(RES_VUSB_3V1, TWL_DEV_GRP_P123, 0, 0),\n\t \n\tTWL_REMAP_SLEEP(RES_REGEN, TWL_DEV_GRP_P123, 2, 1),\n\tTWL_REMAP_SLEEP(RES_NRES_PWRON, TWL_DEV_GRP_P123, 0, 1),\n\tTWL_REMAP_SLEEP(RES_CLKEN, TWL_DEV_GRP_P123, 3, 2),\n\tTWL_REMAP_SLEEP(RES_SYSEN, TWL_DEV_GRP_P123, 6, 1),\n\tTWL_REMAP_SLEEP(RES_HFCLKOUT, DEV_GRP_P3, 0, 2),\n\tTWL_REMAP_SLEEP(RES_32KCLKOUT, TWL_DEV_GRP_P123, 0, 0),\n\tTWL_REMAP_SLEEP(RES_RESET, TWL_DEV_GRP_P123, 6, 0),\n\tTWL_REMAP_SLEEP(RES_MAIN_REF, TWL_DEV_GRP_P123, 0, 0),\n\t{   },\n};\n\nstatic struct twl4030_power_data omap3_idle = {\n\t.scripts\t\t= omap3_idle_scripts,\n\t.num\t\t\t= ARRAY_SIZE(omap3_idle_scripts),\n\t.resource_config\t= omap3_idle_rconfig,\n};\n\n \nstatic struct twl4030_resconfig osc_off_rconfig[] = {\n\tTWL_REMAP_OFF(RES_CLKEN, DEV_GRP_P1 | DEV_GRP_P3, 3, 2),\n\t{   },\n};\n\nstatic struct twl4030_power_data osc_off_idle = {\n\t.scripts\t\t= omap3_idle_scripts,\n\t.num\t\t\t= ARRAY_SIZE(omap3_idle_scripts),\n\t.resource_config\t= omap3_idle_rconfig,\n\t.board_config\t\t= osc_off_rconfig,\n};\n\nstatic struct twl4030_power_data omap3_idle_ac_quirk = {\n\t.scripts\t\t= omap3_idle_scripts,\n\t.num\t\t\t= ARRAY_SIZE(omap3_idle_scripts),\n\t.resource_config\t= omap3_idle_rconfig,\n\t.ac_charger_quirk\t= true,\n};\n\nstatic struct twl4030_power_data omap3_idle_ac_quirk_osc_off = {\n\t.scripts\t\t= omap3_idle_scripts,\n\t.num\t\t\t= ARRAY_SIZE(omap3_idle_scripts),\n\t.resource_config\t= omap3_idle_rconfig,\n\t.board_config\t\t= osc_off_rconfig,\n\t.ac_charger_quirk\t= true,\n};\n\nstatic const struct of_device_id twl4030_power_of_match[] = {\n\t{\n\t\t.compatible = \"ti,twl4030-power\",\n\t},\n\t{\n\t\t.compatible = \"ti,twl4030-power-reset\",\n\t\t.data = &omap3_reset,\n\t},\n\t{\n\t\t.compatible = \"ti,twl4030-power-idle\",\n\t\t.data = &omap3_idle,\n\t},\n\t{\n\t\t.compatible = \"ti,twl4030-power-idle-osc-off\",\n\t\t.data = &osc_off_idle,\n\t},\n\t{\n\t\t.compatible = \"ti,twl4030-power-omap3-sdp\",\n\t\t.data = &omap3_idle_ac_quirk,\n\t},\n\t{\n\t\t.compatible = \"ti,twl4030-power-omap3-ldp\",\n\t\t.data = &omap3_idle_ac_quirk_osc_off,\n\t},\n\t{\n\t\t.compatible = \"ti,twl4030-power-omap3-evm\",\n\t\t.data = &omap3_idle_ac_quirk,\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, twl4030_power_of_match);\n#endif\t \n\nstatic int twl4030_power_probe(struct platform_device *pdev)\n{\n\tconst struct twl4030_power_data *pdata = dev_get_platdata(&pdev->dev);\n\tstruct device_node *node = pdev->dev.of_node;\n\tconst struct of_device_id *match;\n\tint err = 0;\n\tint err2 = 0;\n\tu8 val;\n\n\tif (!pdata && !node) {\n\t\tdev_err(&pdev->dev, \"Platform data is missing\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = twl_i2c_write_u8(TWL_MODULE_PM_MASTER, TWL4030_PM_MASTER_KEY_CFG1,\n\t\t\t       TWL4030_PM_MASTER_PROTECT_KEY);\n\terr |= twl_i2c_write_u8(TWL_MODULE_PM_MASTER,\n\t\t\t       TWL4030_PM_MASTER_KEY_CFG2,\n\t\t\t       TWL4030_PM_MASTER_PROTECT_KEY);\n\n\tif (err) {\n\t\tpr_err(\"TWL4030 Unable to unlock registers\\n\");\n\t\treturn err;\n\t}\n\n\tmatch = of_match_device(of_match_ptr(twl4030_power_of_match),\n\t\t\t\t&pdev->dev);\n\tif (match && match->data)\n\t\tpdata = match->data;\n\n\tif (pdata) {\n\t\terr = twl4030_power_configure_scripts(pdata);\n\t\tif (err) {\n\t\t\tpr_err(\"TWL4030 failed to load scripts\\n\");\n\t\t\tgoto relock;\n\t\t}\n\t\terr = twl4030_power_configure_resources(pdata);\n\t\tif (err) {\n\t\t\tpr_err(\"TWL4030 failed to configure resource\\n\");\n\t\t\tgoto relock;\n\t\t}\n\t}\n\n\t \n\tif (twl4030_power_use_poweroff(pdata, node) && !pm_power_off) {\n\t\t \n\t\terr = twl_i2c_read_u8(TWL_MODULE_PM_MASTER, &val,\n\t\t\t\t      TWL4030_PM_MASTER_CFG_P123_TRANSITION);\n\t\tif (err) {\n\t\t\tpr_warn(\"TWL4030 Unable to read registers\\n\");\n\t\t} else if (!(val & SEQ_OFFSYNC)) {\n\t\t\tval |= SEQ_OFFSYNC;\n\t\t\terr = twl_i2c_write_u8(TWL_MODULE_PM_MASTER, val,\n\t\t\t\t\tTWL4030_PM_MASTER_CFG_P123_TRANSITION);\n\t\t\tif (err) {\n\t\t\t\tpr_err(\"TWL4030 Unable to setup SEQ_OFFSYNC\\n\");\n\t\t\t\tgoto relock;\n\t\t\t}\n\t\t}\n\n\t\tpm_power_off = twl4030_power_off;\n\t}\n\nrelock:\n\terr2 = twl_i2c_write_u8(TWL_MODULE_PM_MASTER, 0,\n\t\t\t       TWL4030_PM_MASTER_PROTECT_KEY);\n\tif (err2) {\n\t\tpr_err(\"TWL4030 Unable to relock registers\\n\");\n\t\treturn err2;\n\t}\n\n\treturn err;\n}\n\nstatic struct platform_driver twl4030_power_driver = {\n\t.driver = {\n\t\t.name\t= \"twl4030_power\",\n\t\t.of_match_table = of_match_ptr(twl4030_power_of_match),\n\t},\n\t.probe\t\t= twl4030_power_probe,\n};\n\nmodule_platform_driver(twl4030_power_driver);\n\nMODULE_AUTHOR(\"Nokia Corporation\");\nMODULE_AUTHOR(\"Texas Instruments, Inc.\");\nMODULE_DESCRIPTION(\"Power management for TWL4030\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:twl4030_power\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}