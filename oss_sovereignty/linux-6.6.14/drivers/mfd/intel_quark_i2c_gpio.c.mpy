{
  "module_name": "intel_quark_i2c_gpio.c",
  "hash_id": "fd36ca3b0d03001f2b967702d493be39a01a4309a4f293a6dd436ae78a57689d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/intel_quark_i2c_gpio.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/mfd/core.h>\n#include <linux/clkdev.h>\n#include <linux/clk-provider.h>\n#include <linux/dmi.h>\n#include <linux/i2c.h>\n#include <linux/property.h>\n\n \n#define MFD_I2C_BAR\t\t0\n#define MFD_GPIO_BAR\t\t1\n\n \n#define MFD_ACPI_MATCH_GPIO\t0ULL\n#define MFD_ACPI_MATCH_I2C\t1ULL\n\n#define INTEL_QUARK_IORES_MEM\t0\n#define INTEL_QUARK_IORES_IRQ\t1\n\n#define INTEL_QUARK_I2C_CONTROLLER_CLK \"i2c_designware.0\"\n\n \n#define INTEL_QUARK_I2C_CLK_HZ\t33000000\n\nstruct intel_quark_mfd {\n\tstruct clk\t\t*i2c_clk;\n\tstruct clk_lookup\t*i2c_clk_lookup;\n};\n\nstatic const struct property_entry intel_quark_i2c_controller_standard_properties[] = {\n\tPROPERTY_ENTRY_U32(\"clock-frequency\", I2C_MAX_STANDARD_MODE_FREQ),\n\t{ }\n};\n\nstatic const struct software_node intel_quark_i2c_controller_standard_node = {\n\t.name = \"intel-quark-i2c-controller\",\n\t.properties = intel_quark_i2c_controller_standard_properties,\n};\n\nstatic const struct property_entry intel_quark_i2c_controller_fast_properties[] = {\n\tPROPERTY_ENTRY_U32(\"clock-frequency\", I2C_MAX_FAST_MODE_FREQ),\n\t{ }\n};\n\nstatic const struct software_node intel_quark_i2c_controller_fast_node = {\n\t.name = \"intel-quark-i2c-controller\",\n\t.properties = intel_quark_i2c_controller_fast_properties,\n};\n\nstatic const struct dmi_system_id dmi_platform_info[] = {\n\t{\n\t\t.matches = {\n\t\t\tDMI_EXACT_MATCH(DMI_BOARD_NAME, \"Galileo\"),\n\t\t},\n\t\t.driver_data = (void *)&intel_quark_i2c_controller_standard_node,\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_EXACT_MATCH(DMI_BOARD_NAME, \"GalileoGen2\"),\n\t\t},\n\t\t.driver_data = (void *)&intel_quark_i2c_controller_fast_node,\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_EXACT_MATCH(DMI_BOARD_NAME, \"SIMATIC IOT2000\"),\n\t\t},\n\t\t.driver_data = (void *)&intel_quark_i2c_controller_fast_node,\n\t},\n\t{}\n};\n\n \nstatic struct resource intel_quark_i2c_res[] = {\n\t[INTEL_QUARK_IORES_MEM] = {\n\t\t.flags = IORESOURCE_MEM,\n\t},\n\t[INTEL_QUARK_IORES_IRQ] = {\n\t\t.flags = IORESOURCE_IRQ,\n\t},\n};\n\nstatic struct mfd_cell_acpi_match intel_quark_acpi_match_i2c = {\n\t.adr = MFD_ACPI_MATCH_I2C,\n};\n\n \nstatic struct resource intel_quark_gpio_res[] = {\n\t[INTEL_QUARK_IORES_MEM] = {\n\t\t.flags = IORESOURCE_MEM,\n\t},\n\t[INTEL_QUARK_IORES_IRQ] = {\n\t\t.flags = IORESOURCE_IRQ,\n\t},\n};\n\nstatic struct mfd_cell_acpi_match intel_quark_acpi_match_gpio = {\n\t.adr = MFD_ACPI_MATCH_GPIO,\n};\n\nstatic const struct software_node intel_quark_gpio_controller_node = {\n\t.name = \"intel-quark-gpio-controller\",\n};\n\nstatic const struct property_entry intel_quark_gpio_portA_properties[] = {\n\tPROPERTY_ENTRY_U32(\"reg\", 0),\n\tPROPERTY_ENTRY_U32(\"snps,nr-gpios\", 8),\n\tPROPERTY_ENTRY_U32(\"gpio-base\", 8),\n\t{ }\n};\n\nstatic const struct software_node intel_quark_gpio_portA_node = {\n\t.name = \"portA\",\n\t.parent = &intel_quark_gpio_controller_node,\n\t.properties = intel_quark_gpio_portA_properties,\n};\n\nstatic const struct software_node *intel_quark_gpio_node_group[] = {\n\t&intel_quark_gpio_controller_node,\n\t&intel_quark_gpio_portA_node,\n\tNULL\n};\n\nstatic struct mfd_cell intel_quark_mfd_cells[] = {\n\t[MFD_I2C_BAR] = {\n\t\t.id = MFD_I2C_BAR,\n\t\t.name = \"i2c_designware\",\n\t\t.acpi_match = &intel_quark_acpi_match_i2c,\n\t\t.num_resources = ARRAY_SIZE(intel_quark_i2c_res),\n\t\t.resources = intel_quark_i2c_res,\n\t\t.ignore_resource_conflicts = true,\n\t},\n\t[MFD_GPIO_BAR] = {\n\t\t.id = MFD_GPIO_BAR,\n\t\t.name = \"gpio-dwapb\",\n\t\t.acpi_match = &intel_quark_acpi_match_gpio,\n\t\t.num_resources = ARRAY_SIZE(intel_quark_gpio_res),\n\t\t.resources = intel_quark_gpio_res,\n\t\t.ignore_resource_conflicts = true,\n\t},\n};\n\nstatic const struct pci_device_id intel_quark_mfd_ids[] = {\n\t{ PCI_VDEVICE(INTEL, 0x0934), },\n\t{},\n};\nMODULE_DEVICE_TABLE(pci, intel_quark_mfd_ids);\n\nstatic int intel_quark_register_i2c_clk(struct device *dev)\n{\n\tstruct intel_quark_mfd *quark_mfd = dev_get_drvdata(dev);\n\tstruct clk *i2c_clk;\n\n\ti2c_clk = clk_register_fixed_rate(dev,\n\t\t\t\t\t  INTEL_QUARK_I2C_CONTROLLER_CLK, NULL,\n\t\t\t\t\t  0, INTEL_QUARK_I2C_CLK_HZ);\n\tif (IS_ERR(i2c_clk))\n\t\treturn PTR_ERR(i2c_clk);\n\n\tquark_mfd->i2c_clk = i2c_clk;\n\tquark_mfd->i2c_clk_lookup = clkdev_create(i2c_clk, NULL,\n\t\t\t\t\t\tINTEL_QUARK_I2C_CONTROLLER_CLK);\n\n\tif (!quark_mfd->i2c_clk_lookup) {\n\t\tclk_unregister(quark_mfd->i2c_clk);\n\t\tdev_err(dev, \"Fixed clk register failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void intel_quark_unregister_i2c_clk(struct device *dev)\n{\n\tstruct intel_quark_mfd *quark_mfd = dev_get_drvdata(dev);\n\n\tif (!quark_mfd->i2c_clk_lookup)\n\t\treturn;\n\n\tclkdev_drop(quark_mfd->i2c_clk_lookup);\n\tclk_unregister(quark_mfd->i2c_clk);\n}\n\nstatic int intel_quark_i2c_setup(struct pci_dev *pdev)\n{\n\tstruct mfd_cell *cell = &intel_quark_mfd_cells[MFD_I2C_BAR];\n\tstruct resource *res = intel_quark_i2c_res;\n\tconst struct dmi_system_id *dmi_id;\n\n\tres[INTEL_QUARK_IORES_MEM].start = pci_resource_start(pdev, MFD_I2C_BAR);\n\tres[INTEL_QUARK_IORES_MEM].end = pci_resource_end(pdev, MFD_I2C_BAR);\n\n\tres[INTEL_QUARK_IORES_IRQ].start = pci_irq_vector(pdev, 0);\n\tres[INTEL_QUARK_IORES_IRQ].end = pci_irq_vector(pdev, 0);\n\n\t \n\tcell->swnode = &intel_quark_i2c_controller_standard_node;\n\n\tdmi_id = dmi_first_match(dmi_platform_info);\n\tif (dmi_id)\n\t\tcell->swnode = (struct software_node *)dmi_id->driver_data;\n\n\treturn 0;\n}\n\nstatic int intel_quark_gpio_setup(struct pci_dev *pdev)\n{\n\tstruct mfd_cell *cell = &intel_quark_mfd_cells[MFD_GPIO_BAR];\n\tstruct resource *res = intel_quark_gpio_res;\n\tint ret;\n\n\tres[INTEL_QUARK_IORES_MEM].start = pci_resource_start(pdev, MFD_GPIO_BAR);\n\tres[INTEL_QUARK_IORES_MEM].end = pci_resource_end(pdev, MFD_GPIO_BAR);\n\n\tres[INTEL_QUARK_IORES_IRQ].start = pci_irq_vector(pdev, 0);\n\tres[INTEL_QUARK_IORES_IRQ].end = pci_irq_vector(pdev, 0);\n\n\tret = software_node_register_node_group(intel_quark_gpio_node_group);\n\tif (ret)\n\t\treturn ret;\n\n\tcell->swnode = &intel_quark_gpio_controller_node;\n\treturn 0;\n}\n\nstatic int intel_quark_mfd_probe(struct pci_dev *pdev,\n\t\t\t\t const struct pci_device_id *id)\n{\n\tstruct intel_quark_mfd *quark_mfd;\n\tint ret;\n\n\tret = pcim_enable_device(pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tquark_mfd = devm_kzalloc(&pdev->dev, sizeof(*quark_mfd), GFP_KERNEL);\n\tif (!quark_mfd)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(&pdev->dev, quark_mfd);\n\n\tret = intel_quark_register_i2c_clk(&pdev->dev);\n\tif (ret)\n\t\treturn ret;\n\n\tpci_set_master(pdev);\n\n\t \n\tret = pci_alloc_irq_vectors(pdev, 1, 1, PCI_IRQ_ALL_TYPES);\n\tif (ret < 0)\n\t\tgoto err_unregister_i2c_clk;\n\n\tret = intel_quark_i2c_setup(pdev);\n\tif (ret)\n\t\tgoto err_free_irq_vectors;\n\n\tret = intel_quark_gpio_setup(pdev);\n\tif (ret)\n\t\tgoto err_free_irq_vectors;\n\n\tret = mfd_add_devices(&pdev->dev, 0, intel_quark_mfd_cells,\n\t\t\t      ARRAY_SIZE(intel_quark_mfd_cells), NULL, 0,\n\t\t\t      NULL);\n\tif (ret)\n\t\tgoto err_unregister_gpio_node_group;\n\n\treturn 0;\n\nerr_unregister_gpio_node_group:\n\tsoftware_node_unregister_node_group(intel_quark_gpio_node_group);\nerr_free_irq_vectors:\n\tpci_free_irq_vectors(pdev);\nerr_unregister_i2c_clk:\n\tintel_quark_unregister_i2c_clk(&pdev->dev);\n\treturn ret;\n}\n\nstatic void intel_quark_mfd_remove(struct pci_dev *pdev)\n{\n\tmfd_remove_devices(&pdev->dev);\n\tsoftware_node_unregister_node_group(intel_quark_gpio_node_group);\n\tpci_free_irq_vectors(pdev);\n\tintel_quark_unregister_i2c_clk(&pdev->dev);\n}\n\nstatic struct pci_driver intel_quark_mfd_driver = {\n\t.name\t\t= \"intel_quark_mfd_i2c_gpio\",\n\t.id_table\t= intel_quark_mfd_ids,\n\t.probe\t\t= intel_quark_mfd_probe,\n\t.remove\t\t= intel_quark_mfd_remove,\n};\n\nmodule_pci_driver(intel_quark_mfd_driver);\n\nMODULE_AUTHOR(\"Raymond Tan <raymond.tan@intel.com>\");\nMODULE_DESCRIPTION(\"Intel Quark MFD PCI driver for I2C & GPIO\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}