{
  "module_name": "rohm-bd9576.c",
  "hash_id": "f5110ba6261c4e30497bed9cb3d30e08ce33f5a2ec32d20d27ba74716194e44e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/rohm-bd9576.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/irq.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/rohm-bd957x.h>\n#include <linux/mfd/rohm-generic.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n#include <linux/types.h>\n\nenum {\n\tBD957X_REGULATOR_CELL,\n\tBD957X_WDT_CELL,\n};\n\n \nstatic const struct resource bd9576_regulator_irqs[] = {\n\tDEFINE_RES_IRQ_NAMED(BD9576_INT_THERM, \"bd9576-temp\"),\n\tDEFINE_RES_IRQ_NAMED(BD9576_INT_OVD, \"bd9576-ovd\"),\n\tDEFINE_RES_IRQ_NAMED(BD9576_INT_UVD, \"bd9576-uvd\"),\n};\n\nstatic struct mfd_cell bd9573_mfd_cells[] = {\n\t[BD957X_REGULATOR_CELL]\t= { .name = \"bd9573-regulator\", },\n\t[BD957X_WDT_CELL]\t= { .name = \"bd9576-wdt\", },\n};\n\nstatic struct mfd_cell bd9576_mfd_cells[] = {\n\t[BD957X_REGULATOR_CELL]\t= { .name = \"bd9576-regulator\", },\n\t[BD957X_WDT_CELL]\t= { .name = \"bd9576-wdt\", },\n};\n\nstatic const struct regmap_range volatile_ranges[] = {\n\tregmap_reg_range(BD957X_REG_SMRB_ASSERT, BD957X_REG_SMRB_ASSERT),\n\tregmap_reg_range(BD957X_REG_PMIC_INTERNAL_STAT,\n\t\t\t BD957X_REG_PMIC_INTERNAL_STAT),\n\tregmap_reg_range(BD957X_REG_INT_THERM_STAT, BD957X_REG_INT_THERM_STAT),\n\tregmap_reg_range(BD957X_REG_INT_OVP_STAT, BD957X_REG_INT_SYS_STAT),\n\tregmap_reg_range(BD957X_REG_INT_MAIN_STAT, BD957X_REG_INT_MAIN_STAT),\n};\n\nstatic const struct regmap_access_table volatile_regs = {\n\t.yes_ranges = &volatile_ranges[0],\n\t.n_yes_ranges = ARRAY_SIZE(volatile_ranges),\n};\n\nstatic struct regmap_config bd957x_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.volatile_table = &volatile_regs,\n\t.max_register = BD957X_MAX_REGISTER,\n\t.cache_type = REGCACHE_RBTREE,\n};\n\nstatic struct regmap_irq bd9576_irqs[] = {\n\tREGMAP_IRQ_REG(BD9576_INT_THERM, 0, BD957X_MASK_INT_MAIN_THERM),\n\tREGMAP_IRQ_REG(BD9576_INT_OVP, 0, BD957X_MASK_INT_MAIN_OVP),\n\tREGMAP_IRQ_REG(BD9576_INT_SCP, 0, BD957X_MASK_INT_MAIN_SCP),\n\tREGMAP_IRQ_REG(BD9576_INT_OCP, 0, BD957X_MASK_INT_MAIN_OCP),\n\tREGMAP_IRQ_REG(BD9576_INT_OVD, 0, BD957X_MASK_INT_MAIN_OVD),\n\tREGMAP_IRQ_REG(BD9576_INT_UVD, 0, BD957X_MASK_INT_MAIN_UVD),\n\tREGMAP_IRQ_REG(BD9576_INT_UVP, 0, BD957X_MASK_INT_MAIN_UVP),\n\tREGMAP_IRQ_REG(BD9576_INT_SYS, 0, BD957X_MASK_INT_MAIN_SYS),\n};\n\nstatic struct regmap_irq_chip bd9576_irq_chip = {\n\t.name = \"bd9576_irq\",\n\t.irqs = &bd9576_irqs[0],\n\t.num_irqs = ARRAY_SIZE(bd9576_irqs),\n\t.status_base = BD957X_REG_INT_MAIN_STAT,\n\t.mask_base = BD957X_REG_INT_MAIN_MASK,\n\t.ack_base = BD957X_REG_INT_MAIN_STAT,\n\t.init_ack_masked = true,\n\t.num_regs = 1,\n\t.irq_reg_stride = 1,\n};\n\nstatic int bd957x_i2c_probe(struct i2c_client *i2c)\n{\n\tint ret;\n\tstruct regmap *regmap;\n\tstruct mfd_cell *cells;\n\tint num_cells;\n\tunsigned long chip_type;\n\tstruct irq_domain *domain;\n\tbool usable_irqs;\n\n\tchip_type = (unsigned long)of_device_get_match_data(&i2c->dev);\n\n\tswitch (chip_type) {\n\tcase ROHM_CHIP_TYPE_BD9576:\n\t\tcells = bd9576_mfd_cells;\n\t\tnum_cells = ARRAY_SIZE(bd9576_mfd_cells);\n\t\tusable_irqs = !!i2c->irq;\n\t\tbreak;\n\tcase ROHM_CHIP_TYPE_BD9573:\n\t\tcells = bd9573_mfd_cells;\n\t\tnum_cells = ARRAY_SIZE(bd9573_mfd_cells);\n\t\t \n\t\tusable_irqs = false;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&i2c->dev, \"Unknown device type\");\n\t\treturn -EINVAL;\n\t}\n\n\tregmap = devm_regmap_init_i2c(i2c, &bd957x_regmap);\n\tif (IS_ERR(regmap))\n\t\treturn dev_err_probe(&i2c->dev, PTR_ERR(regmap),\n\t\t\t\t     \"Failed to initialize Regmap\\n\");\n\n\t \n\tif (usable_irqs) {\n\t\tstruct regmap_irq_chip_data *irq_data;\n\t\tstruct mfd_cell *regulators;\n\n\t\tregulators = &bd9576_mfd_cells[BD957X_REGULATOR_CELL];\n\t\tregulators->resources = bd9576_regulator_irqs;\n\t\tregulators->num_resources = ARRAY_SIZE(bd9576_regulator_irqs);\n\n\t\tret = devm_regmap_add_irq_chip(&i2c->dev, regmap, i2c->irq,\n\t\t\t\t\t       IRQF_ONESHOT, 0,\n\t\t\t\t\t       &bd9576_irq_chip, &irq_data);\n\t\tif (ret)\n\t\t\treturn dev_err_probe(&i2c->dev, ret,\n\t\t\t\t\t     \"Failed to add IRQ chip\\n\");\n\n\t\tdomain = regmap_irq_get_domain(irq_data);\n\t} else {\n\t\tret = regmap_update_bits(regmap, BD957X_REG_INT_MAIN_MASK,\n\t\t\t\t\t BD957X_MASK_INT_ALL,\n\t\t\t\t\t BD957X_MASK_INT_ALL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tdomain = NULL;\n\t}\n\n\tret = devm_mfd_add_devices(&i2c->dev, PLATFORM_DEVID_AUTO, cells,\n\t\t\t\t   num_cells, NULL, 0, domain);\n\tif (ret)\n\t\tdev_err_probe(&i2c->dev, ret, \"Failed to create subdevices\\n\");\n\n\treturn ret;\n}\n\nstatic const struct of_device_id bd957x_of_match[] = {\n\t{ .compatible = \"rohm,bd9576\", .data = (void *)ROHM_CHIP_TYPE_BD9576, },\n\t{ .compatible = \"rohm,bd9573\", .data = (void *)ROHM_CHIP_TYPE_BD9573, },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, bd957x_of_match);\n\nstatic struct i2c_driver bd957x_drv = {\n\t.driver = {\n\t\t.name = \"rohm-bd957x\",\n\t\t.of_match_table = bd957x_of_match,\n\t},\n\t.probe = bd957x_i2c_probe,\n};\nmodule_i2c_driver(bd957x_drv);\n\nMODULE_AUTHOR(\"Matti Vaittinen <matti.vaittinen@fi.rohmeurope.com>\");\nMODULE_DESCRIPTION(\"ROHM BD9576MUF and BD9573MUF Power Management IC driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}