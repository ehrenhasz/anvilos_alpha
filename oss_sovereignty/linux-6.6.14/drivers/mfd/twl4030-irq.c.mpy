{
  "module_name": "twl4030-irq.c",
  "hash_id": "7243695ff0530aaa35df28995a91c393b9cc0e884acfb4786fc5a0011961ceba",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/twl4030-irq.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/irqdomain.h>\n#include <linux/mfd/twl.h>\n\n#include \"twl-core.h\"\n\n \n#define TWL4030_CORE_NR_IRQS\t8\n#define TWL4030_PWR_NR_IRQS\t8\n\n \n#define REG_PIH_ISR_P1\t\t\t0x01\n#define REG_PIH_ISR_P2\t\t\t0x02\n#define REG_PIH_SIR\t\t\t0x03\t \n\n \nstatic int irq_line;\n\nstruct sih {\n\tchar\tname[8];\n\tu8\tmodule;\t\t\t \n\tu8\tcontrol_offset;\t\t \n\tbool\tset_cor;\n\n\tu8\tbits;\t\t\t \n\tu8\tbytes_ixr;\t\t \n\n\tu8\tedr_offset;\n\tu8\tbytes_edr;\t\t \n\n\tu8\tirq_lines;\t\t \n\n\t \n\tstruct sih_irq_data {\n\t\tu8\tisr_offset;\n\t\tu8\timr_offset;\n\t} mask[2];\n\t \n};\n\nstatic const struct sih *sih_modules;\nstatic int nr_sih_modules;\n\n#define SIH_INITIALIZER(modname, nbits) \\\n\t.module\t\t= TWL4030_MODULE_ ## modname, \\\n\t.control_offset = TWL4030_ ## modname ## _SIH_CTRL, \\\n\t.bits\t\t= nbits, \\\n\t.bytes_ixr\t= DIV_ROUND_UP(nbits, 8), \\\n\t.edr_offset\t= TWL4030_ ## modname ## _EDR, \\\n\t.bytes_edr\t= DIV_ROUND_UP((2*(nbits)), 8), \\\n\t.irq_lines\t= 2, \\\n\t.mask = { { \\\n\t\t.isr_offset\t= TWL4030_ ## modname ## _ISR1, \\\n\t\t.imr_offset\t= TWL4030_ ## modname ## _IMR1, \\\n\t}, \\\n\t{ \\\n\t\t.isr_offset\t= TWL4030_ ## modname ## _ISR2, \\\n\t\t.imr_offset\t= TWL4030_ ## modname ## _IMR2, \\\n\t}, },\n\n \n#define TWL4030_INT_PWR_EDR\t\tTWL4030_INT_PWR_EDR1\n#define TWL4030_MODULE_KEYPAD_KEYP\tTWL4030_MODULE_KEYPAD\n#define TWL4030_MODULE_INT_PWR\t\tTWL4030_MODULE_INT\n\n\n \n \nstatic const struct sih sih_modules_twl4030[6] = {\n\t[0] = {\n\t\t.name\t\t= \"gpio\",\n\t\t.module\t\t= TWL4030_MODULE_GPIO,\n\t\t.control_offset\t= REG_GPIO_SIH_CTRL,\n\t\t.set_cor\t= true,\n\t\t.bits\t\t= TWL4030_GPIO_MAX,\n\t\t.bytes_ixr\t= 3,\n\t\t \n\t\t.edr_offset\t= REG_GPIO_EDR1,\n\t\t.bytes_edr\t= 5,\n\t\t.irq_lines\t= 2,\n\t\t.mask = { {\n\t\t\t.isr_offset\t= REG_GPIO_ISR1A,\n\t\t\t.imr_offset\t= REG_GPIO_IMR1A,\n\t\t}, {\n\t\t\t.isr_offset\t= REG_GPIO_ISR1B,\n\t\t\t.imr_offset\t= REG_GPIO_IMR1B,\n\t\t}, },\n\t},\n\t[1] = {\n\t\t.name\t\t= \"keypad\",\n\t\t.set_cor\t= true,\n\t\tSIH_INITIALIZER(KEYPAD_KEYP, 4)\n\t},\n\t[2] = {\n\t\t.name\t\t= \"bci\",\n\t\t.module\t\t= TWL4030_MODULE_INTERRUPTS,\n\t\t.control_offset\t= TWL4030_INTERRUPTS_BCISIHCTRL,\n\t\t.set_cor\t= true,\n\t\t.bits\t\t= 12,\n\t\t.bytes_ixr\t= 2,\n\t\t.edr_offset\t= TWL4030_INTERRUPTS_BCIEDR1,\n\t\t \n\t\t.bytes_edr\t= 3,\n\t\t.irq_lines\t= 2,\n\t\t.mask = { {\n\t\t\t.isr_offset\t= TWL4030_INTERRUPTS_BCIISR1A,\n\t\t\t.imr_offset\t= TWL4030_INTERRUPTS_BCIIMR1A,\n\t\t}, {\n\t\t\t.isr_offset\t= TWL4030_INTERRUPTS_BCIISR1B,\n\t\t\t.imr_offset\t= TWL4030_INTERRUPTS_BCIIMR1B,\n\t\t}, },\n\t},\n\t[3] = {\n\t\t.name\t\t= \"madc\",\n\t\tSIH_INITIALIZER(MADC, 4)\n\t},\n\t[4] = {\n\t\t \n\t\t.name\t\t= \"usb\",\n\t},\n\t[5] = {\n\t\t.name\t\t= \"power\",\n\t\t.set_cor\t= true,\n\t\tSIH_INITIALIZER(INT_PWR, 8)\n\t},\n\t\t \n};\n\nstatic const struct sih sih_modules_twl5031[8] = {\n\t[0] = {\n\t\t.name\t\t= \"gpio\",\n\t\t.module\t\t= TWL4030_MODULE_GPIO,\n\t\t.control_offset\t= REG_GPIO_SIH_CTRL,\n\t\t.set_cor\t= true,\n\t\t.bits\t\t= TWL4030_GPIO_MAX,\n\t\t.bytes_ixr\t= 3,\n\t\t \n\t\t.edr_offset\t= REG_GPIO_EDR1,\n\t\t.bytes_edr\t= 5,\n\t\t.irq_lines\t= 2,\n\t\t.mask = { {\n\t\t\t.isr_offset\t= REG_GPIO_ISR1A,\n\t\t\t.imr_offset\t= REG_GPIO_IMR1A,\n\t\t}, {\n\t\t\t.isr_offset\t= REG_GPIO_ISR1B,\n\t\t\t.imr_offset\t= REG_GPIO_IMR1B,\n\t\t}, },\n\t},\n\t[1] = {\n\t\t.name\t\t= \"keypad\",\n\t\t.set_cor\t= true,\n\t\tSIH_INITIALIZER(KEYPAD_KEYP, 4)\n\t},\n\t[2] = {\n\t\t.name\t\t= \"bci\",\n\t\t.module\t\t= TWL5031_MODULE_INTERRUPTS,\n\t\t.control_offset\t= TWL5031_INTERRUPTS_BCISIHCTRL,\n\t\t.bits\t\t= 7,\n\t\t.bytes_ixr\t= 1,\n\t\t.edr_offset\t= TWL5031_INTERRUPTS_BCIEDR1,\n\t\t \n\t\t.bytes_edr\t= 2,\n\t\t.irq_lines\t= 2,\n\t\t.mask = { {\n\t\t\t.isr_offset\t= TWL5031_INTERRUPTS_BCIISR1,\n\t\t\t.imr_offset\t= TWL5031_INTERRUPTS_BCIIMR1,\n\t\t}, {\n\t\t\t.isr_offset\t= TWL5031_INTERRUPTS_BCIISR2,\n\t\t\t.imr_offset\t= TWL5031_INTERRUPTS_BCIIMR2,\n\t\t}, },\n\t},\n\t[3] = {\n\t\t.name\t\t= \"madc\",\n\t\tSIH_INITIALIZER(MADC, 4)\n\t},\n\t[4] = {\n\t\t \n\t\t.name\t\t= \"usb\",\n\t},\n\t[5] = {\n\t\t.name\t\t= \"power\",\n\t\t.set_cor\t= true,\n\t\tSIH_INITIALIZER(INT_PWR, 8)\n\t},\n\t[6] = {\n\t\t \n\t\t.name\t\t= \"eci_dbi\",\n\t\t.module\t\t= TWL5031_MODULE_ACCESSORY,\n\t\t.bits\t\t= 9,\n\t\t.bytes_ixr\t= 2,\n\t\t.irq_lines\t= 1,\n\t\t.mask = { {\n\t\t\t.isr_offset\t= TWL5031_ACIIDR_LSB,\n\t\t\t.imr_offset\t= TWL5031_ACIIMR_LSB,\n\t\t}, },\n\n\t},\n\t[7] = {\n\t\t \n\t\t.name\t\t= \"audio\",\n\t\t.module\t\t= TWL5031_MODULE_ACCESSORY,\n\t\t.control_offset\t= TWL5031_ACCSIHCTRL,\n\t\t.bits\t\t= 2,\n\t\t.bytes_ixr\t= 1,\n\t\t.edr_offset\t= TWL5031_ACCEDR1,\n\t\t \n\t\t.bytes_edr\t= 1,\n\t\t.irq_lines\t= 2,\n\t\t.mask = { {\n\t\t\t.isr_offset\t= TWL5031_ACCISR1,\n\t\t\t.imr_offset\t= TWL5031_ACCIMR1,\n\t\t}, {\n\t\t\t.isr_offset\t= TWL5031_ACCISR2,\n\t\t\t.imr_offset\t= TWL5031_ACCIMR2,\n\t\t}, },\n\t},\n};\n\n#undef TWL4030_MODULE_KEYPAD_KEYP\n#undef TWL4030_MODULE_INT_PWR\n#undef TWL4030_INT_PWR_EDR\n\n \n\nstatic unsigned twl4030_irq_base;\n\n \nstatic irqreturn_t handle_twl4030_pih(int irq, void *devid)\n{\n\tirqreturn_t\tret;\n\tu8\t\tpih_isr;\n\n\tret = twl_i2c_read_u8(TWL_MODULE_PIH, &pih_isr,\n\t\t\t      REG_PIH_ISR_P1);\n\tif (ret) {\n\t\tpr_warn(\"twl4030: I2C error %d reading PIH ISR\\n\", ret);\n\t\treturn IRQ_NONE;\n\t}\n\n\twhile (pih_isr) {\n\t\tunsigned long\tpending = __ffs(pih_isr);\n\t\tunsigned int\tirq;\n\n\t\tpih_isr &= ~BIT(pending);\n\t\tirq = pending + twl4030_irq_base;\n\t\thandle_nested_irq(irq);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \n\n \nstatic int twl4030_init_sih_modules(unsigned line)\n{\n\tconst struct sih *sih;\n\tu8 buf[4];\n\tint i;\n\tint status;\n\n\t \n\tif (line > 1)\n\t\treturn -EINVAL;\n\n\tirq_line = line;\n\n\t \n\tmemset(buf, 0xff, sizeof(buf));\n\tsih = sih_modules;\n\tfor (i = 0; i < nr_sih_modules; i++, sih++) {\n\t\t \n\t\tif (!sih->bytes_ixr)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (sih->irq_lines <= line)\n\t\t\tcontinue;\n\n\t\tstatus = twl_i2c_write(sih->module, buf,\n\t\t\t\tsih->mask[line].imr_offset, sih->bytes_ixr);\n\t\tif (status < 0)\n\t\t\tpr_err(\"twl4030: err %d initializing %s %s\\n\",\n\t\t\t\t\tstatus, sih->name, \"IMR\");\n\n\t\t \n\t\tif (sih->set_cor) {\n\t\t\tstatus = twl_i2c_write_u8(sih->module,\n\t\t\t\t\tTWL4030_SIH_CTRL_COR_MASK,\n\t\t\t\t\tsih->control_offset);\n\t\t\tif (status < 0)\n\t\t\t\tpr_err(\"twl4030: err %d initializing %s %s\\n\",\n\t\t\t\t\t\tstatus, sih->name, \"SIH_CTRL\");\n\t\t}\n\t}\n\n\tsih = sih_modules;\n\tfor (i = 0; i < nr_sih_modules; i++, sih++) {\n\t\tu8 rxbuf[4];\n\t\tint j;\n\n\t\t \n\t\tif (!sih->bytes_ixr)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (sih->irq_lines <= line)\n\t\t\tcontinue;\n\n\t\t \n\t\tfor (j = 0; j < 2; j++) {\n\t\t\tstatus = twl_i2c_read(sih->module, rxbuf,\n\t\t\t\tsih->mask[line].isr_offset, sih->bytes_ixr);\n\t\t\tif (status < 0)\n\t\t\t\tpr_warn(\"twl4030: err %d initializing %s %s\\n\",\n\t\t\t\t\tstatus, sih->name, \"ISR\");\n\n\t\t\tif (!sih->set_cor) {\n\t\t\t\tstatus = twl_i2c_write(sih->module, buf,\n\t\t\t\t\tsih->mask[line].isr_offset,\n\t\t\t\t\tsih->bytes_ixr);\n\t\t\t\tif (status < 0)\n\t\t\t\t\tpr_warn(\"twl4030: write failed: %d\\n\",\n\t\t\t\t\t\tstatus);\n\t\t\t}\n\t\t\t \n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic inline void activate_irq(int irq)\n{\n\tirq_clear_status_flags(irq, IRQ_NOREQUEST | IRQ_NOPROBE);\n}\n\n \n\nstruct sih_agent {\n\tint\t\t\tirq_base;\n\tconst struct sih\t*sih;\n\n\tu32\t\t\timr;\n\tbool\t\t\timr_change_pending;\n\n\tu32\t\t\tedge_change;\n\n\tstruct mutex\t\tirq_lock;\n\tchar\t\t\t*irq_name;\n};\n\n \n\n \n\nstatic void twl4030_sih_mask(struct irq_data *data)\n{\n\tstruct sih_agent *agent = irq_data_get_irq_chip_data(data);\n\n\tagent->imr |= BIT(data->irq - agent->irq_base);\n\tagent->imr_change_pending = true;\n}\n\nstatic void twl4030_sih_unmask(struct irq_data *data)\n{\n\tstruct sih_agent *agent = irq_data_get_irq_chip_data(data);\n\n\tagent->imr &= ~BIT(data->irq - agent->irq_base);\n\tagent->imr_change_pending = true;\n}\n\nstatic int twl4030_sih_set_type(struct irq_data *data, unsigned trigger)\n{\n\tstruct sih_agent *agent = irq_data_get_irq_chip_data(data);\n\n\tif (trigger & ~(IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING))\n\t\treturn -EINVAL;\n\n\tif (irqd_get_trigger_type(data) != trigger)\n\t\tagent->edge_change |= BIT(data->irq - agent->irq_base);\n\n\treturn 0;\n}\n\nstatic void twl4030_sih_bus_lock(struct irq_data *data)\n{\n\tstruct sih_agent\t*agent = irq_data_get_irq_chip_data(data);\n\n\tmutex_lock(&agent->irq_lock);\n}\n\nstatic void twl4030_sih_bus_sync_unlock(struct irq_data *data)\n{\n\tstruct sih_agent\t*agent = irq_data_get_irq_chip_data(data);\n\tconst struct sih\t*sih = agent->sih;\n\tint\t\t\tstatus;\n\n\tif (agent->imr_change_pending) {\n\t\tunion {\n\t\t\t__le32\tword;\n\t\t\tu8\tbytes[4];\n\t\t} imr;\n\n\t\t \n\t\timr.word = cpu_to_le32(agent->imr);\n\t\tagent->imr_change_pending = false;\n\n\t\t \n\t\tstatus = twl_i2c_write(sih->module, imr.bytes,\n\t\t\t\tsih->mask[irq_line].imr_offset,\n\t\t\t\tsih->bytes_ixr);\n\t\tif (status)\n\t\t\tpr_err(\"twl4030: %s, %s --> %d\\n\", __func__,\n\t\t\t\t\t\"write\", status);\n\t}\n\n\tif (agent->edge_change) {\n\t\tu32\t\tedge_change;\n\t\tu8\t\tbytes[6];\n\n\t\tedge_change = agent->edge_change;\n\t\tagent->edge_change = 0;\n\n\t\t \n\t\tstatus = twl_i2c_read(sih->module, bytes,\n\t\t\t\tsih->edr_offset, sih->bytes_edr);\n\t\tif (status) {\n\t\t\tpr_err(\"twl4030: %s, %s --> %d\\n\", __func__,\n\t\t\t\t\t\"read\", status);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\twhile (edge_change) {\n\t\t\tint\t\ti = fls(edge_change) - 1;\n\t\t\tint\t\tbyte = i >> 2;\n\t\t\tint\t\toff = (i & 0x3) * 2;\n\t\t\tunsigned int\ttype;\n\n\t\t\tbytes[byte] &= ~(0x03 << off);\n\n\t\t\ttype = irq_get_trigger_type(i + agent->irq_base);\n\t\t\tif (type & IRQ_TYPE_EDGE_RISING)\n\t\t\t\tbytes[byte] |= BIT(off + 1);\n\t\t\tif (type & IRQ_TYPE_EDGE_FALLING)\n\t\t\t\tbytes[byte] |= BIT(off + 0);\n\n\t\t\tedge_change &= ~BIT(i);\n\t\t}\n\n\t\t \n\t\tstatus = twl_i2c_write(sih->module, bytes,\n\t\t\t\tsih->edr_offset, sih->bytes_edr);\n\t\tif (status)\n\t\t\tpr_err(\"twl4030: %s, %s --> %d\\n\", __func__,\n\t\t\t\t\t\"write\", status);\n\t}\n\n\tmutex_unlock(&agent->irq_lock);\n}\n\nstatic struct irq_chip twl4030_sih_irq_chip = {\n\t.name\t\t= \"twl4030\",\n\t.irq_mask\t= twl4030_sih_mask,\n\t.irq_unmask\t= twl4030_sih_unmask,\n\t.irq_set_type\t= twl4030_sih_set_type,\n\t.irq_bus_lock\t= twl4030_sih_bus_lock,\n\t.irq_bus_sync_unlock = twl4030_sih_bus_sync_unlock,\n\t.flags\t\t= IRQCHIP_SKIP_SET_WAKE,\n};\n\n \n\nstatic inline int sih_read_isr(const struct sih *sih)\n{\n\tint status;\n\tunion {\n\t\tu8 bytes[4];\n\t\t__le32 word;\n\t} isr;\n\n\t \n\n\tisr.word = 0;\n\tstatus = twl_i2c_read(sih->module, isr.bytes,\n\t\t\tsih->mask[irq_line].isr_offset, sih->bytes_ixr);\n\n\treturn (status < 0) ? status : le32_to_cpu(isr.word);\n}\n\n \nstatic irqreturn_t handle_twl4030_sih(int irq, void *data)\n{\n\tstruct sih_agent *agent = irq_get_handler_data(irq);\n\tconst struct sih *sih = agent->sih;\n\tint isr;\n\n\t \n\tisr = sih_read_isr(sih);\n\n\tif (isr < 0) {\n\t\tpr_err(\"twl4030: %s SIH, read ISR error %d\\n\",\n\t\t\tsih->name, isr);\n\t\t \n\t\treturn IRQ_HANDLED;\n\t}\n\n\twhile (isr) {\n\t\tirq = fls(isr);\n\t\tirq--;\n\t\tisr &= ~BIT(irq);\n\n\t\tif (irq < sih->bits)\n\t\t\thandle_nested_irq(agent->irq_base + irq);\n\t\telse\n\t\t\tpr_err(\"twl4030: %s SIH, invalid ISR bit %d\\n\",\n\t\t\t\tsih->name, irq);\n\t}\n\treturn IRQ_HANDLED;\n}\n\n \nint twl4030_sih_setup(struct device *dev, int module, int irq_base)\n{\n\tint\t\t\tsih_mod;\n\tconst struct sih\t*sih = NULL;\n\tstruct sih_agent\t*agent;\n\tint\t\t\ti, irq;\n\tint\t\t\tstatus = -EINVAL;\n\n\t \n\tfor (sih_mod = 0, sih = sih_modules; sih_mod < nr_sih_modules;\n\t\t\tsih_mod++, sih++) {\n\t\tif (sih->module == module && sih->set_cor) {\n\t\t\tstatus = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (status < 0) {\n\t\tdev_err(dev, \"module to setup SIH for not found\\n\");\n\t\treturn status;\n\t}\n\n\tagent = kzalloc(sizeof(*agent), GFP_KERNEL);\n\tif (!agent)\n\t\treturn -ENOMEM;\n\n\tagent->irq_base = irq_base;\n\tagent->sih = sih;\n\tagent->imr = ~0;\n\tmutex_init(&agent->irq_lock);\n\n\tfor (i = 0; i < sih->bits; i++) {\n\t\tirq = irq_base + i;\n\n\t\tirq_set_chip_data(irq, agent);\n\t\tirq_set_chip_and_handler(irq, &twl4030_sih_irq_chip,\n\t\t\t\t\t handle_edge_irq);\n\t\tirq_set_nested_thread(irq, 1);\n\t\tactivate_irq(irq);\n\t}\n\n\t \n\tirq = sih_mod + twl4030_irq_base;\n\tirq_set_handler_data(irq, agent);\n\tagent->irq_name = kasprintf(GFP_KERNEL, \"twl4030_%s\", sih->name);\n\tstatus = request_threaded_irq(irq, NULL, handle_twl4030_sih,\n\t\t\t\t      IRQF_EARLY_RESUME | IRQF_ONESHOT,\n\t\t\t\t      agent->irq_name ?: sih->name, NULL);\n\n\tdev_info(dev, \"%s (irq %d) chaining IRQs %d..%d\\n\", sih->name,\n\t\t\tirq, irq_base, irq_base + i - 1);\n\n\treturn status < 0 ? status : irq_base;\n}\n\n \n\n \n\n \n#define twl_irq_line\t0\n\nint twl4030_init_irq(struct device *dev, int irq_num)\n{\n\tstatic struct irq_chip\ttwl4030_irq_chip;\n\tint\t\t\tstatus, i;\n\tint\t\t\tirq_base, irq_end, nr_irqs;\n\tstruct\t\t\tdevice_node *node = dev->of_node;\n\n\t \n\tnr_irqs = TWL4030_PWR_NR_IRQS + TWL4030_CORE_NR_IRQS;\n\n\tirq_base = irq_alloc_descs(-1, 0, nr_irqs, 0);\n\tif (irq_base < 0) {\n\t\tdev_err(dev, \"Fail to allocate IRQ descs\\n\");\n\t\treturn irq_base;\n\t}\n\n\tirq_domain_add_legacy(node, nr_irqs, irq_base, 0,\n\t\t\t      &irq_domain_simple_ops, NULL);\n\n\tirq_end = irq_base + TWL4030_CORE_NR_IRQS;\n\n\t \n\tstatus = twl4030_init_sih_modules(twl_irq_line);\n\tif (status < 0)\n\t\treturn status;\n\n\ttwl4030_irq_base = irq_base;\n\n\t \n\ttwl4030_irq_chip = dummy_irq_chip;\n\ttwl4030_irq_chip.name = \"twl4030\";\n\n\ttwl4030_sih_irq_chip.irq_ack = dummy_irq_chip.irq_ack;\n\n\tfor (i = irq_base; i < irq_end; i++) {\n\t\tirq_set_chip_and_handler(i, &twl4030_irq_chip,\n\t\t\t\t\t handle_simple_irq);\n\t\tirq_set_nested_thread(i, 1);\n\t\tactivate_irq(i);\n\t}\n\n\tdev_info(dev, \"%s (irq %d) chaining IRQs %d..%d\\n\", \"PIH\",\n\t\t\tirq_num, irq_base, irq_end);\n\n\t \n\tstatus = twl4030_sih_setup(dev, TWL4030_MODULE_INT, irq_end);\n\tif (status < 0) {\n\t\tdev_err(dev, \"sih_setup PWR INT --> %d\\n\", status);\n\t\tgoto fail;\n\t}\n\n\t \n\tstatus = request_threaded_irq(irq_num, NULL, handle_twl4030_pih,\n\t\t\t\t      IRQF_ONESHOT,\n\t\t\t\t      \"TWL4030-PIH\", NULL);\n\tif (status < 0) {\n\t\tdev_err(dev, \"could not claim irq%d: %d\\n\", irq_num, status);\n\t\tgoto fail_rqirq;\n\t}\n\tenable_irq_wake(irq_num);\n\n\treturn irq_base;\nfail_rqirq:\n\t \nfail:\n\tfor (i = irq_base; i < irq_end; i++) {\n\t\tirq_set_nested_thread(i, 0);\n\t\tirq_set_chip_and_handler(i, NULL, NULL);\n\t}\n\n\treturn status;\n}\n\nvoid twl4030_exit_irq(void)\n{\n\t \n\tif (twl4030_irq_base)\n\t\tpr_err(\"twl4030: can't yet clean up IRQs?\\n\");\n}\n\nint twl4030_init_chip_irq(const char *chip)\n{\n\tif (!strcmp(chip, \"twl5031\")) {\n\t\tsih_modules = sih_modules_twl5031;\n\t\tnr_sih_modules = ARRAY_SIZE(sih_modules_twl5031);\n\t} else {\n\t\tsih_modules = sih_modules_twl4030;\n\t\tnr_sih_modules = ARRAY_SIZE(sih_modules_twl4030);\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}