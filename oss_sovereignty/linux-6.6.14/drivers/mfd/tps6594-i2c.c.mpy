{
  "module_name": "tps6594-i2c.c",
  "hash_id": "d57062696bb04f4fd65269ef6a7d21fea60043afbf2d8e9dcbb6288bb9b86eb8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/tps6594-i2c.c",
  "human_readable_source": "\n \n\n#include <linux/crc8.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/of_device.h>\n#include <linux/regmap.h>\n\n#include <linux/mfd/tps6594.h>\n\nstatic bool enable_crc;\nmodule_param(enable_crc, bool, 0444);\nMODULE_PARM_DESC(enable_crc, \"Enable CRC feature for I2C interface\");\n\nDECLARE_CRC8_TABLE(tps6594_i2c_crc_table);\n\nstatic int tps6594_i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)\n{\n\tint ret = i2c_transfer(adap, msgs, num);\n\n\tif (ret == num)\n\t\treturn 0;\n\telse if (ret < 0)\n\t\treturn ret;\n\telse\n\t\treturn -EIO;\n}\n\nstatic int tps6594_i2c_reg_read_with_crc(struct i2c_client *client, u8 page, u8 reg, u8 *val)\n{\n\tstruct i2c_msg msgs[2];\n\tu8 buf_rx[] = { 0, 0 };\n\t \n\tconst u8 addr = client->addr + page;\n\t \n\tu8 crc_data[] = { addr << 1, reg, addr << 1 | 1, 0 };\n\tint ret;\n\n\t \n\tmsgs[0].addr = addr;\n\tmsgs[0].flags = 0;\n\tmsgs[0].len = 1;\n\tmsgs[0].buf = &reg;\n\n\t \n\tmsgs[1].addr = msgs[0].addr;\n\tmsgs[1].flags = I2C_M_RD;\n\tmsgs[1].len = 2;\n\tmsgs[1].buf = buf_rx;\n\n\tret = tps6594_i2c_transfer(client->adapter, msgs, 2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcrc_data[sizeof(crc_data) - 1] = *val = buf_rx[0];\n\tif (buf_rx[1] != crc8(tps6594_i2c_crc_table, crc_data, sizeof(crc_data), CRC8_INIT_VALUE))\n\t\treturn -EIO;\n\n\treturn ret;\n}\n\nstatic int tps6594_i2c_reg_write_with_crc(struct i2c_client *client, u8 page, u8 reg, u8 val)\n{\n\tstruct i2c_msg msg;\n\tu8 buf[] = { reg, val, 0 };\n\t \n\tconst u8 addr = client->addr + page;\n\t \n\tconst u8 crc_data[] = { addr << 1, reg, val };\n\n\t \n\tmsg.addr = addr;\n\tmsg.flags = client->flags & I2C_M_TEN;\n\tmsg.len = sizeof(buf);\n\tmsg.buf = buf;\n\n\tbuf[msg.len - 1] = crc8(tps6594_i2c_crc_table, crc_data, sizeof(crc_data), CRC8_INIT_VALUE);\n\n\treturn tps6594_i2c_transfer(client->adapter, &msg, 1);\n}\n\nstatic int tps6594_i2c_read(void *context, const void *reg_buf, size_t reg_size,\n\t\t\t    void *val_buf, size_t val_size)\n{\n\tstruct i2c_client *client = context;\n\tstruct tps6594 *tps = i2c_get_clientdata(client);\n\tstruct i2c_msg msgs[2];\n\tconst u8 *reg_bytes = reg_buf;\n\tu8 *val_bytes = val_buf;\n\tconst u8 page = reg_bytes[1];\n\tu8 reg = reg_bytes[0];\n\tint ret = 0;\n\tint i;\n\n\tif (tps->use_crc) {\n\t\t \n\t\tfor (i = 0 ; ret == 0 && i < val_size ; i++)\n\t\t\tret = tps6594_i2c_reg_read_with_crc(client, page, reg + i, val_bytes + i);\n\n\t\treturn ret;\n\t}\n\n\t \n\tmsgs[0].addr = client->addr + page;\n\tmsgs[0].flags = 0;\n\tmsgs[0].len = 1;\n\tmsgs[0].buf = &reg;\n\n\t \n\tmsgs[1].addr = msgs[0].addr;\n\tmsgs[1].flags = I2C_M_RD;\n\tmsgs[1].len = val_size;\n\tmsgs[1].buf = val_bytes;\n\n\treturn tps6594_i2c_transfer(client->adapter, msgs, 2);\n}\n\nstatic int tps6594_i2c_write(void *context, const void *data, size_t count)\n{\n\tstruct i2c_client *client = context;\n\tstruct tps6594 *tps = i2c_get_clientdata(client);\n\tstruct i2c_msg msg;\n\tconst u8 *bytes = data;\n\tu8 *buf;\n\tconst u8 page = bytes[1];\n\tconst u8 reg = bytes[0];\n\tint ret = 0;\n\tint i;\n\n\tif (tps->use_crc) {\n\t\t \n\t\tfor (i = 0 ; ret == 0 && i < count - 2 ; i++)\n\t\t\tret = tps6594_i2c_reg_write_with_crc(client, page, reg + i, bytes[i + 2]);\n\n\t\treturn ret;\n\t}\n\n\t \n\tbuf = kzalloc(--count, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tbuf[0] = reg;\n\tfor (i = 0 ; i < count - 1 ; i++)\n\t\tbuf[i + 1] = bytes[i + 2];\n\n\t \n\tmsg.addr = client->addr + page;\n\tmsg.flags = client->flags & I2C_M_TEN;\n\tmsg.len = count;\n\tmsg.buf = buf;\n\n\tret = tps6594_i2c_transfer(client->adapter, &msg, 1);\n\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic const struct regmap_config tps6594_i2c_regmap_config = {\n\t.reg_bits = 16,\n\t.val_bits = 8,\n\t.max_register = TPS6594_REG_DWD_FAIL_CNT_REG,\n\t.volatile_reg = tps6594_is_volatile_reg,\n\t.read = tps6594_i2c_read,\n\t.write = tps6594_i2c_write,\n};\n\nstatic const struct of_device_id tps6594_i2c_of_match_table[] = {\n\t{ .compatible = \"ti,tps6594-q1\", .data = (void *)TPS6594, },\n\t{ .compatible = \"ti,tps6593-q1\", .data = (void *)TPS6593, },\n\t{ .compatible = \"ti,lp8764-q1\",  .data = (void *)LP8764,  },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, tps6594_i2c_of_match_table);\n\nstatic int tps6594_i2c_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct tps6594 *tps;\n\tconst struct of_device_id *match;\n\n\ttps = devm_kzalloc(dev, sizeof(*tps), GFP_KERNEL);\n\tif (!tps)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, tps);\n\n\ttps->dev = dev;\n\ttps->reg = client->addr;\n\ttps->irq = client->irq;\n\n\ttps->regmap = devm_regmap_init(dev, NULL, client, &tps6594_i2c_regmap_config);\n\tif (IS_ERR(tps->regmap))\n\t\treturn dev_err_probe(dev, PTR_ERR(tps->regmap), \"Failed to init regmap\\n\");\n\n\tmatch = of_match_device(tps6594_i2c_of_match_table, dev);\n\tif (!match)\n\t\treturn dev_err_probe(dev, -EINVAL, \"Failed to find matching chip ID\\n\");\n\ttps->chip_id = (unsigned long)match->data;\n\n\tcrc8_populate_msb(tps6594_i2c_crc_table, TPS6594_CRC8_POLYNOMIAL);\n\n\treturn tps6594_device_init(tps, enable_crc);\n}\n\nstatic struct i2c_driver tps6594_i2c_driver = {\n\t.driver\t= {\n\t\t.name = \"tps6594\",\n\t\t.of_match_table = tps6594_i2c_of_match_table,\n\t},\n\t.probe = tps6594_i2c_probe,\n};\nmodule_i2c_driver(tps6594_i2c_driver);\n\nMODULE_AUTHOR(\"Julien Panis <jpanis@baylibre.com>\");\nMODULE_DESCRIPTION(\"TPS6594 I2C Interface Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}