{
  "module_name": "ucb1x00-core.c",
  "hash_id": "fc5b2a7ac33dd436f6ea88dfee431942fcd57e29c943d7693177b9c3df263b43",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/ucb1x00-core.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/device.h>\n#include <linux/mutex.h>\n#include <linux/mfd/ucb1x00.h>\n#include <linux/pm.h>\n#include <linux/gpio/driver.h>\n\nstatic DEFINE_MUTEX(ucb1x00_mutex);\nstatic LIST_HEAD(ucb1x00_drivers);\nstatic LIST_HEAD(ucb1x00_devices);\n\n \nvoid ucb1x00_io_set_dir(struct ucb1x00 *ucb, unsigned int in, unsigned int out)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ucb->io_lock, flags);\n\tucb->io_dir |= out;\n\tucb->io_dir &= ~in;\n\n\tucb1x00_reg_write(ucb, UCB_IO_DIR, ucb->io_dir);\n\tspin_unlock_irqrestore(&ucb->io_lock, flags);\n}\n\n \nvoid ucb1x00_io_write(struct ucb1x00 *ucb, unsigned int set, unsigned int clear)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ucb->io_lock, flags);\n\tucb->io_out |= set;\n\tucb->io_out &= ~clear;\n\n\tucb1x00_reg_write(ucb, UCB_IO_DATA, ucb->io_out);\n\tspin_unlock_irqrestore(&ucb->io_lock, flags);\n}\n\n \nunsigned int ucb1x00_io_read(struct ucb1x00 *ucb)\n{\n\treturn ucb1x00_reg_read(ucb, UCB_IO_DATA);\n}\n\nstatic void ucb1x00_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\n{\n\tstruct ucb1x00 *ucb = gpiochip_get_data(chip);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ucb->io_lock, flags);\n\tif (value)\n\t\tucb->io_out |= 1 << offset;\n\telse\n\t\tucb->io_out &= ~(1 << offset);\n\n\tucb1x00_enable(ucb);\n\tucb1x00_reg_write(ucb, UCB_IO_DATA, ucb->io_out);\n\tucb1x00_disable(ucb);\n\tspin_unlock_irqrestore(&ucb->io_lock, flags);\n}\n\nstatic int ucb1x00_gpio_get(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct ucb1x00 *ucb = gpiochip_get_data(chip);\n\tunsigned val;\n\n\tucb1x00_enable(ucb);\n\tval = ucb1x00_reg_read(ucb, UCB_IO_DATA);\n\tucb1x00_disable(ucb);\n\n\treturn !!(val & (1 << offset));\n}\n\nstatic int ucb1x00_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct ucb1x00 *ucb = gpiochip_get_data(chip);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ucb->io_lock, flags);\n\tucb->io_dir &= ~(1 << offset);\n\tucb1x00_enable(ucb);\n\tucb1x00_reg_write(ucb, UCB_IO_DIR, ucb->io_dir);\n\tucb1x00_disable(ucb);\n\tspin_unlock_irqrestore(&ucb->io_lock, flags);\n\n\treturn 0;\n}\n\nstatic int ucb1x00_gpio_direction_output(struct gpio_chip *chip, unsigned offset\n\t\t, int value)\n{\n\tstruct ucb1x00 *ucb = gpiochip_get_data(chip);\n\tunsigned long flags;\n\tunsigned old, mask = 1 << offset;\n\n\tspin_lock_irqsave(&ucb->io_lock, flags);\n\told = ucb->io_out;\n\tif (value)\n\t\tucb->io_out |= mask;\n\telse\n\t\tucb->io_out &= ~mask;\n\n\tucb1x00_enable(ucb);\n\tif (old != ucb->io_out)\n\t\tucb1x00_reg_write(ucb, UCB_IO_DATA, ucb->io_out);\n\n\tif (!(ucb->io_dir & mask)) {\n\t\tucb->io_dir |= mask;\n\t\tucb1x00_reg_write(ucb, UCB_IO_DIR, ucb->io_dir);\n\t}\n\tucb1x00_disable(ucb);\n\tspin_unlock_irqrestore(&ucb->io_lock, flags);\n\n\treturn 0;\n}\n\nstatic int ucb1x00_to_irq(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct ucb1x00 *ucb = gpiochip_get_data(chip);\n\n\treturn ucb->irq_base > 0 ? ucb->irq_base + offset : -ENXIO;\n}\n\n \n\n \nvoid ucb1x00_adc_enable(struct ucb1x00 *ucb)\n{\n\tmutex_lock(&ucb->adc_mutex);\n\n\tucb->adc_cr |= UCB_ADC_ENA;\n\n\tucb1x00_enable(ucb);\n\tucb1x00_reg_write(ucb, UCB_ADC_CR, ucb->adc_cr);\n}\n\n \nunsigned int ucb1x00_adc_read(struct ucb1x00 *ucb, int adc_channel, int sync)\n{\n\tunsigned int val;\n\n\tif (sync)\n\t\tadc_channel |= UCB_ADC_SYNC_ENA;\n\n\tucb1x00_reg_write(ucb, UCB_ADC_CR, ucb->adc_cr | adc_channel);\n\tucb1x00_reg_write(ucb, UCB_ADC_CR, ucb->adc_cr | adc_channel | UCB_ADC_START);\n\n\tfor (;;) {\n\t\tval = ucb1x00_reg_read(ucb, UCB_ADC_DATA);\n\t\tif (val & UCB_ADC_DAT_VAL)\n\t\t\tbreak;\n\t\t \n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tschedule_timeout(1);\n\t}\n\n\treturn UCB_ADC_DAT(val);\n}\n\n \nvoid ucb1x00_adc_disable(struct ucb1x00 *ucb)\n{\n\tucb->adc_cr &= ~UCB_ADC_ENA;\n\tucb1x00_reg_write(ucb, UCB_ADC_CR, ucb->adc_cr);\n\tucb1x00_disable(ucb);\n\n\tmutex_unlock(&ucb->adc_mutex);\n}\n\n \nstatic void ucb1x00_irq(struct irq_desc *desc)\n{\n\tstruct ucb1x00 *ucb = irq_desc_get_handler_data(desc);\n\tunsigned int isr, i;\n\n\tucb1x00_enable(ucb);\n\tisr = ucb1x00_reg_read(ucb, UCB_IE_STATUS);\n\tucb1x00_reg_write(ucb, UCB_IE_CLEAR, isr);\n\tucb1x00_reg_write(ucb, UCB_IE_CLEAR, 0);\n\n\tfor (i = 0; i < 16 && isr; i++, isr >>= 1)\n\t\tif (isr & 1)\n\t\t\tgeneric_handle_irq(ucb->irq_base + i);\n\tucb1x00_disable(ucb);\n}\n\nstatic void ucb1x00_irq_update(struct ucb1x00 *ucb, unsigned mask)\n{\n\tucb1x00_enable(ucb);\n\tif (ucb->irq_ris_enbl & mask)\n\t\tucb1x00_reg_write(ucb, UCB_IE_RIS, ucb->irq_ris_enbl &\n\t\t\t\t  ucb->irq_mask);\n\tif (ucb->irq_fal_enbl & mask)\n\t\tucb1x00_reg_write(ucb, UCB_IE_FAL, ucb->irq_fal_enbl &\n\t\t\t\t  ucb->irq_mask);\n\tucb1x00_disable(ucb);\n}\n\nstatic void ucb1x00_irq_noop(struct irq_data *data)\n{\n}\n\nstatic void ucb1x00_irq_mask(struct irq_data *data)\n{\n\tstruct ucb1x00 *ucb = irq_data_get_irq_chip_data(data);\n\tunsigned mask = 1 << (data->irq - ucb->irq_base);\n\n\traw_spin_lock(&ucb->irq_lock);\n\tucb->irq_mask &= ~mask;\n\tucb1x00_irq_update(ucb, mask);\n\traw_spin_unlock(&ucb->irq_lock);\n}\n\nstatic void ucb1x00_irq_unmask(struct irq_data *data)\n{\n\tstruct ucb1x00 *ucb = irq_data_get_irq_chip_data(data);\n\tunsigned mask = 1 << (data->irq - ucb->irq_base);\n\n\traw_spin_lock(&ucb->irq_lock);\n\tucb->irq_mask |= mask;\n\tucb1x00_irq_update(ucb, mask);\n\traw_spin_unlock(&ucb->irq_lock);\n}\n\nstatic int ucb1x00_irq_set_type(struct irq_data *data, unsigned int type)\n{\n\tstruct ucb1x00 *ucb = irq_data_get_irq_chip_data(data);\n\tunsigned mask = 1 << (data->irq - ucb->irq_base);\n\n\traw_spin_lock(&ucb->irq_lock);\n\tif (type & IRQ_TYPE_EDGE_RISING)\n\t\tucb->irq_ris_enbl |= mask;\n\telse\n\t\tucb->irq_ris_enbl &= ~mask;\n\n\tif (type & IRQ_TYPE_EDGE_FALLING)\n\t\tucb->irq_fal_enbl |= mask;\n\telse\n\t\tucb->irq_fal_enbl &= ~mask;\n\tif (ucb->irq_mask & mask) {\n\t\tucb1x00_reg_write(ucb, UCB_IE_RIS, ucb->irq_ris_enbl &\n\t\t\t\t  ucb->irq_mask);\n\t\tucb1x00_reg_write(ucb, UCB_IE_FAL, ucb->irq_fal_enbl &\n\t\t\t\t  ucb->irq_mask);\n\t}\n\traw_spin_unlock(&ucb->irq_lock);\n\n\treturn 0;\n}\n\nstatic int ucb1x00_irq_set_wake(struct irq_data *data, unsigned int on)\n{\n\tstruct ucb1x00 *ucb = irq_data_get_irq_chip_data(data);\n\tstruct ucb1x00_plat_data *pdata = ucb->mcp->attached_device.platform_data;\n\tunsigned mask = 1 << (data->irq - ucb->irq_base);\n\n\tif (!pdata || !pdata->can_wakeup)\n\t\treturn -EINVAL;\n\n\traw_spin_lock(&ucb->irq_lock);\n\tif (on)\n\t\tucb->irq_wake |= mask;\n\telse\n\t\tucb->irq_wake &= ~mask;\n\traw_spin_unlock(&ucb->irq_lock);\n\n\treturn 0;\n}\n\nstatic struct irq_chip ucb1x00_irqchip = {\n\t.name = \"ucb1x00\",\n\t.irq_ack = ucb1x00_irq_noop,\n\t.irq_mask = ucb1x00_irq_mask,\n\t.irq_unmask = ucb1x00_irq_unmask,\n\t.irq_set_type = ucb1x00_irq_set_type,\n\t.irq_set_wake = ucb1x00_irq_set_wake,\n};\n\nstatic int ucb1x00_add_dev(struct ucb1x00 *ucb, struct ucb1x00_driver *drv)\n{\n\tstruct ucb1x00_dev *dev;\n\tint ret;\n\n\tdev = kmalloc(sizeof(struct ucb1x00_dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tdev->ucb = ucb;\n\tdev->drv = drv;\n\n\tret = drv->add(dev);\n\tif (ret) {\n\t\tkfree(dev);\n\t\treturn ret;\n\t}\n\n\tlist_add_tail(&dev->dev_node, &ucb->devs);\n\tlist_add_tail(&dev->drv_node, &drv->devs);\n\n\treturn ret;\n}\n\nstatic void ucb1x00_remove_dev(struct ucb1x00_dev *dev)\n{\n\tdev->drv->remove(dev);\n\tlist_del(&dev->dev_node);\n\tlist_del(&dev->drv_node);\n\tkfree(dev);\n}\n\n \nstatic int ucb1x00_detect_irq(struct ucb1x00 *ucb)\n{\n\tunsigned long mask;\n\n\tmask = probe_irq_on();\n\n\t \n\tucb1x00_reg_write(ucb, UCB_IE_RIS, UCB_IE_ADC);\n\tucb1x00_reg_write(ucb, UCB_IE_FAL, UCB_IE_ADC);\n\tucb1x00_reg_write(ucb, UCB_IE_CLEAR, 0xffff);\n\tucb1x00_reg_write(ucb, UCB_IE_CLEAR, 0);\n\n\t \n\tucb1x00_reg_write(ucb, UCB_ADC_CR, UCB_ADC_ENA);\n\tucb1x00_reg_write(ucb, UCB_ADC_CR, UCB_ADC_ENA | UCB_ADC_START);\n\n\t \n\twhile ((ucb1x00_reg_read(ucb, UCB_ADC_DATA) & UCB_ADC_DAT_VAL) == 0);\n\tucb1x00_reg_write(ucb, UCB_ADC_CR, 0);\n\n\t \n\tucb1x00_reg_write(ucb, UCB_IE_RIS, 0);\n\tucb1x00_reg_write(ucb, UCB_IE_FAL, 0);\n\tucb1x00_reg_write(ucb, UCB_IE_CLEAR, 0xffff);\n\tucb1x00_reg_write(ucb, UCB_IE_CLEAR, 0);\n\n\t \n\treturn probe_irq_off(mask);\n}\n\nstatic void ucb1x00_release(struct device *dev)\n{\n\tstruct ucb1x00 *ucb = classdev_to_ucb1x00(dev);\n\tkfree(ucb);\n}\n\nstatic struct class ucb1x00_class = {\n\t.name\t\t= \"ucb1x00\",\n\t.dev_release\t= ucb1x00_release,\n};\n\nstatic int ucb1x00_probe(struct mcp *mcp)\n{\n\tstruct ucb1x00_plat_data *pdata = mcp->attached_device.platform_data;\n\tstruct ucb1x00_driver *drv;\n\tstruct ucb1x00 *ucb;\n\tunsigned id, i, irq_base;\n\tint ret = -ENODEV;\n\n\t \n\tif (pdata && pdata->reset)\n\t\tpdata->reset(UCB_RST_PROBE);\n\n\tmcp_enable(mcp);\n\tid = mcp_reg_read(mcp, UCB_ID);\n\tmcp_disable(mcp);\n\n\tif (id != UCB_ID_1200 && id != UCB_ID_1300 && id != UCB_ID_TC35143) {\n\t\tprintk(KERN_WARNING \"UCB1x00 ID not found: %04x\\n\", id);\n\t\tgoto out;\n\t}\n\n\tucb = kzalloc(sizeof(struct ucb1x00), GFP_KERNEL);\n\tret = -ENOMEM;\n\tif (!ucb)\n\t\tgoto out;\n\n\tdevice_initialize(&ucb->dev);\n\tucb->dev.class = &ucb1x00_class;\n\tucb->dev.parent = &mcp->attached_device;\n\tdev_set_name(&ucb->dev, \"ucb1x00\");\n\n\traw_spin_lock_init(&ucb->irq_lock);\n\tspin_lock_init(&ucb->io_lock);\n\tmutex_init(&ucb->adc_mutex);\n\n\tucb->id  = id;\n\tucb->mcp = mcp;\n\n\tret = device_add(&ucb->dev);\n\tif (ret)\n\t\tgoto err_dev_add;\n\n\tucb1x00_enable(ucb);\n\tucb->irq = ucb1x00_detect_irq(ucb);\n\tucb1x00_disable(ucb);\n\tif (!ucb->irq) {\n\t\tdev_err(&ucb->dev, \"IRQ probe failed\\n\");\n\t\tret = -ENODEV;\n\t\tgoto err_no_irq;\n\t}\n\n\tucb->gpio.base = -1;\n\tirq_base = pdata ? pdata->irq_base : 0;\n\tucb->irq_base = irq_alloc_descs(-1, irq_base, 16, -1);\n\tif (ucb->irq_base < 0) {\n\t\tdev_err(&ucb->dev, \"unable to allocate 16 irqs: %d\\n\",\n\t\t\tucb->irq_base);\n\t\tret = ucb->irq_base;\n\t\tgoto err_irq_alloc;\n\t}\n\n\tfor (i = 0; i < 16; i++) {\n\t\tunsigned irq = ucb->irq_base + i;\n\n\t\tirq_set_chip_and_handler(irq, &ucb1x00_irqchip, handle_edge_irq);\n\t\tirq_set_chip_data(irq, ucb);\n\t\tirq_clear_status_flags(irq, IRQ_NOREQUEST);\n\t}\n\n\tirq_set_irq_type(ucb->irq, IRQ_TYPE_EDGE_RISING);\n\tirq_set_chained_handler_and_data(ucb->irq, ucb1x00_irq, ucb);\n\n\tif (pdata && pdata->gpio_base) {\n\t\tucb->gpio.label = dev_name(&ucb->dev);\n\t\tucb->gpio.parent = &ucb->dev;\n\t\tucb->gpio.owner = THIS_MODULE;\n\t\tucb->gpio.base = pdata->gpio_base;\n\t\tucb->gpio.ngpio = 10;\n\t\tucb->gpio.set = ucb1x00_gpio_set;\n\t\tucb->gpio.get = ucb1x00_gpio_get;\n\t\tucb->gpio.direction_input = ucb1x00_gpio_direction_input;\n\t\tucb->gpio.direction_output = ucb1x00_gpio_direction_output;\n\t\tucb->gpio.to_irq = ucb1x00_to_irq;\n\t\tret = gpiochip_add_data(&ucb->gpio, ucb);\n\t\tif (ret)\n\t\t\tgoto err_gpio_add;\n\t} else\n\t\tdev_info(&ucb->dev, \"gpio_base not set so no gpiolib support\");\n\n\tmcp_set_drvdata(mcp, ucb);\n\n\tif (pdata)\n\t\tdevice_set_wakeup_capable(&ucb->dev, pdata->can_wakeup);\n\n\tINIT_LIST_HEAD(&ucb->devs);\n\tmutex_lock(&ucb1x00_mutex);\n\tlist_add_tail(&ucb->node, &ucb1x00_devices);\n\tlist_for_each_entry(drv, &ucb1x00_drivers, node) {\n\t\tucb1x00_add_dev(ucb, drv);\n\t}\n\tmutex_unlock(&ucb1x00_mutex);\n\n\treturn ret;\n\n err_gpio_add:\n\tirq_set_chained_handler(ucb->irq, NULL);\n err_irq_alloc:\n\tif (ucb->irq_base > 0)\n\t\tirq_free_descs(ucb->irq_base, 16);\n err_no_irq:\n\tdevice_del(&ucb->dev);\n err_dev_add:\n\tput_device(&ucb->dev);\n out:\n\tif (pdata && pdata->reset)\n\t\tpdata->reset(UCB_RST_PROBE_FAIL);\n\treturn ret;\n}\n\nstatic void ucb1x00_remove(struct mcp *mcp)\n{\n\tstruct ucb1x00_plat_data *pdata = mcp->attached_device.platform_data;\n\tstruct ucb1x00 *ucb = mcp_get_drvdata(mcp);\n\tstruct list_head *l, *n;\n\n\tmutex_lock(&ucb1x00_mutex);\n\tlist_del(&ucb->node);\n\tlist_for_each_safe(l, n, &ucb->devs) {\n\t\tstruct ucb1x00_dev *dev = list_entry(l, struct ucb1x00_dev, dev_node);\n\t\tucb1x00_remove_dev(dev);\n\t}\n\tmutex_unlock(&ucb1x00_mutex);\n\n\tif (ucb->gpio.base != -1)\n\t\tgpiochip_remove(&ucb->gpio);\n\n\tirq_set_chained_handler(ucb->irq, NULL);\n\tirq_free_descs(ucb->irq_base, 16);\n\tdevice_unregister(&ucb->dev);\n\n\tif (pdata && pdata->reset)\n\t\tpdata->reset(UCB_RST_REMOVE);\n}\n\nint ucb1x00_register_driver(struct ucb1x00_driver *drv)\n{\n\tstruct ucb1x00 *ucb;\n\n\tINIT_LIST_HEAD(&drv->devs);\n\tmutex_lock(&ucb1x00_mutex);\n\tlist_add_tail(&drv->node, &ucb1x00_drivers);\n\tlist_for_each_entry(ucb, &ucb1x00_devices, node) {\n\t\tucb1x00_add_dev(ucb, drv);\n\t}\n\tmutex_unlock(&ucb1x00_mutex);\n\treturn 0;\n}\n\nvoid ucb1x00_unregister_driver(struct ucb1x00_driver *drv)\n{\n\tstruct list_head *n, *l;\n\n\tmutex_lock(&ucb1x00_mutex);\n\tlist_del(&drv->node);\n\tlist_for_each_safe(l, n, &drv->devs) {\n\t\tstruct ucb1x00_dev *dev = list_entry(l, struct ucb1x00_dev, drv_node);\n\t\tucb1x00_remove_dev(dev);\n\t}\n\tmutex_unlock(&ucb1x00_mutex);\n}\n\nstatic int ucb1x00_suspend(struct device *dev)\n{\n\tstruct ucb1x00_plat_data *pdata = dev_get_platdata(dev);\n\tstruct ucb1x00 *ucb = dev_get_drvdata(dev);\n\tstruct ucb1x00_dev *udev;\n\n\tmutex_lock(&ucb1x00_mutex);\n\tlist_for_each_entry(udev, &ucb->devs, dev_node) {\n\t\tif (udev->drv->suspend)\n\t\t\tudev->drv->suspend(udev);\n\t}\n\tmutex_unlock(&ucb1x00_mutex);\n\n\tif (ucb->irq_wake) {\n\t\tunsigned long flags;\n\n\t\traw_spin_lock_irqsave(&ucb->irq_lock, flags);\n\t\tucb1x00_enable(ucb);\n\t\tucb1x00_reg_write(ucb, UCB_IE_RIS, ucb->irq_ris_enbl &\n\t\t\t\t  ucb->irq_wake);\n\t\tucb1x00_reg_write(ucb, UCB_IE_FAL, ucb->irq_fal_enbl &\n\t\t\t\t  ucb->irq_wake);\n\t\tucb1x00_disable(ucb);\n\t\traw_spin_unlock_irqrestore(&ucb->irq_lock, flags);\n\n\t\tenable_irq_wake(ucb->irq);\n\t} else if (pdata && pdata->reset)\n\t\tpdata->reset(UCB_RST_SUSPEND);\n\n\treturn 0;\n}\n\nstatic int ucb1x00_resume(struct device *dev)\n{\n\tstruct ucb1x00_plat_data *pdata = dev_get_platdata(dev);\n\tstruct ucb1x00 *ucb = dev_get_drvdata(dev);\n\tstruct ucb1x00_dev *udev;\n\n\tif (!ucb->irq_wake && pdata && pdata->reset)\n\t\tpdata->reset(UCB_RST_RESUME);\n\n\tucb1x00_enable(ucb);\n\tucb1x00_reg_write(ucb, UCB_IO_DATA, ucb->io_out);\n\tucb1x00_reg_write(ucb, UCB_IO_DIR, ucb->io_dir);\n\n\tif (ucb->irq_wake) {\n\t\tunsigned long flags;\n\n\t\traw_spin_lock_irqsave(&ucb->irq_lock, flags);\n\t\tucb1x00_reg_write(ucb, UCB_IE_RIS, ucb->irq_ris_enbl &\n\t\t\t\t  ucb->irq_mask);\n\t\tucb1x00_reg_write(ucb, UCB_IE_FAL, ucb->irq_fal_enbl &\n\t\t\t\t  ucb->irq_mask);\n\t\traw_spin_unlock_irqrestore(&ucb->irq_lock, flags);\n\n\t\tdisable_irq_wake(ucb->irq);\n\t}\n\tucb1x00_disable(ucb);\n\n\tmutex_lock(&ucb1x00_mutex);\n\tlist_for_each_entry(udev, &ucb->devs, dev_node) {\n\t\tif (udev->drv->resume)\n\t\t\tudev->drv->resume(udev);\n\t}\n\tmutex_unlock(&ucb1x00_mutex);\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(ucb1x00_pm_ops,\n\t\t\t\tucb1x00_suspend, ucb1x00_resume);\n\nstatic struct mcp_driver ucb1x00_driver = {\n\t.drv\t\t= {\n\t\t.name\t= \"ucb1x00\",\n\t\t.owner\t= THIS_MODULE,\n\t\t.pm\t= pm_sleep_ptr(&ucb1x00_pm_ops),\n\t},\n\t.probe\t\t= ucb1x00_probe,\n\t.remove\t\t= ucb1x00_remove,\n};\n\nstatic int __init ucb1x00_init(void)\n{\n\tint ret = class_register(&ucb1x00_class);\n\tif (ret == 0) {\n\t\tret = mcp_driver_register(&ucb1x00_driver);\n\t\tif (ret)\n\t\t\tclass_unregister(&ucb1x00_class);\n\t}\n\treturn ret;\n}\n\nstatic void __exit ucb1x00_exit(void)\n{\n\tmcp_driver_unregister(&ucb1x00_driver);\n\tclass_unregister(&ucb1x00_class);\n}\n\nmodule_init(ucb1x00_init);\nmodule_exit(ucb1x00_exit);\n\nEXPORT_SYMBOL(ucb1x00_io_set_dir);\nEXPORT_SYMBOL(ucb1x00_io_write);\nEXPORT_SYMBOL(ucb1x00_io_read);\n\nEXPORT_SYMBOL(ucb1x00_adc_enable);\nEXPORT_SYMBOL(ucb1x00_adc_read);\nEXPORT_SYMBOL(ucb1x00_adc_disable);\n\nEXPORT_SYMBOL(ucb1x00_register_driver);\nEXPORT_SYMBOL(ucb1x00_unregister_driver);\n\nMODULE_ALIAS(\"mcp:ucb1x00\");\nMODULE_AUTHOR(\"Russell King <rmk@arm.linux.org.uk>\");\nMODULE_DESCRIPTION(\"UCB1x00 core driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}