{
  "module_name": "kempld-core.c",
  "hash_id": "b4b5f43d8720761ac4390f64b9c6fcf37bb12ea6615f8c386b5bb531d1eaac7b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/kempld-core.c",
  "human_readable_source": "\n \n\n#include <linux/platform_device.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/kempld.h>\n#include <linux/module.h>\n#include <linux/dmi.h>\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/acpi.h>\n\n#define MAX_ID_LEN 4\nstatic char force_device_id[MAX_ID_LEN + 1] = \"\";\nmodule_param_string(force_device_id, force_device_id,\n\t\t    sizeof(force_device_id), 0);\nMODULE_PARM_DESC(force_device_id, \"Override detected product\");\n\n \nstatic void kempld_get_hardware_mutex(struct kempld_device_data *pld)\n{\n\t \n\twhile (ioread8(pld->io_index) & KEMPLD_MUTEX_KEY)\n\t\tusleep_range(1000, 3000);\n}\n\nstatic void kempld_release_hardware_mutex(struct kempld_device_data *pld)\n{\n\t \n\tiowrite8(KEMPLD_MUTEX_KEY, pld->io_index);\n}\n\nstatic int kempld_get_info_generic(struct kempld_device_data *pld)\n{\n\tu16 version;\n\tu8 spec;\n\n\tkempld_get_mutex(pld);\n\n\tversion = kempld_read16(pld, KEMPLD_VERSION);\n\tspec = kempld_read8(pld, KEMPLD_SPEC);\n\tpld->info.buildnr = kempld_read16(pld, KEMPLD_BUILDNR);\n\n\tpld->info.minor = KEMPLD_VERSION_GET_MINOR(version);\n\tpld->info.major = KEMPLD_VERSION_GET_MAJOR(version);\n\tpld->info.number = KEMPLD_VERSION_GET_NUMBER(version);\n\tpld->info.type = KEMPLD_VERSION_GET_TYPE(version);\n\n\tif (spec == 0xff) {\n\t\tpld->info.spec_minor = 0;\n\t\tpld->info.spec_major = 1;\n\t} else {\n\t\tpld->info.spec_minor = KEMPLD_SPEC_GET_MINOR(spec);\n\t\tpld->info.spec_major = KEMPLD_SPEC_GET_MAJOR(spec);\n\t}\n\n\tif (pld->info.spec_major > 0)\n\t\tpld->feature_mask = kempld_read16(pld, KEMPLD_FEATURE);\n\telse\n\t\tpld->feature_mask = 0;\n\n\tkempld_release_mutex(pld);\n\n\treturn 0;\n}\n\nenum kempld_cells {\n\tKEMPLD_I2C = 0,\n\tKEMPLD_WDT,\n\tKEMPLD_GPIO,\n\tKEMPLD_UART,\n};\n\nstatic const char *kempld_dev_names[] = {\n\t[KEMPLD_I2C] = \"kempld-i2c\",\n\t[KEMPLD_WDT] = \"kempld-wdt\",\n\t[KEMPLD_GPIO] = \"kempld-gpio\",\n\t[KEMPLD_UART] = \"kempld-uart\",\n};\n\n#define KEMPLD_MAX_DEVS\tARRAY_SIZE(kempld_dev_names)\n\nstatic int kempld_register_cells_generic(struct kempld_device_data *pld)\n{\n\tstruct mfd_cell devs[KEMPLD_MAX_DEVS] = {};\n\tint i = 0;\n\n\tif (pld->feature_mask & KEMPLD_FEATURE_BIT_I2C)\n\t\tdevs[i++].name = kempld_dev_names[KEMPLD_I2C];\n\n\tif (pld->feature_mask & KEMPLD_FEATURE_BIT_WATCHDOG)\n\t\tdevs[i++].name = kempld_dev_names[KEMPLD_WDT];\n\n\tif (pld->feature_mask & KEMPLD_FEATURE_BIT_GPIO)\n\t\tdevs[i++].name = kempld_dev_names[KEMPLD_GPIO];\n\n\tif (pld->feature_mask & KEMPLD_FEATURE_MASK_UART)\n\t\tdevs[i++].name = kempld_dev_names[KEMPLD_UART];\n\n\treturn mfd_add_devices(pld->dev, -1, devs, i, NULL, 0, NULL);\n}\n\nstatic struct resource kempld_ioresource = {\n\t.start\t= KEMPLD_IOINDEX,\n\t.end\t= KEMPLD_IODATA,\n\t.flags\t= IORESOURCE_IO,\n};\n\nstatic const struct kempld_platform_data kempld_platform_data_generic = {\n\t.pld_clock\t\t= KEMPLD_CLK,\n\t.ioresource\t\t= &kempld_ioresource,\n\t.get_hardware_mutex\t= kempld_get_hardware_mutex,\n\t.release_hardware_mutex\t= kempld_release_hardware_mutex,\n\t.get_info\t\t= kempld_get_info_generic,\n\t.register_cells\t\t= kempld_register_cells_generic,\n};\n\nstatic struct platform_device *kempld_pdev;\n\nstatic int kempld_create_platform_device(const struct dmi_system_id *id)\n{\n\tconst struct kempld_platform_data *pdata = id->driver_data;\n\tint ret;\n\n\tkempld_pdev = platform_device_alloc(\"kempld\", -1);\n\tif (!kempld_pdev)\n\t\treturn -ENOMEM;\n\n\tret = platform_device_add_data(kempld_pdev, pdata, sizeof(*pdata));\n\tif (ret)\n\t\tgoto err;\n\n\tret = platform_device_add_resources(kempld_pdev, pdata->ioresource, 1);\n\tif (ret)\n\t\tgoto err;\n\n\tret = platform_device_add(kempld_pdev);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tplatform_device_put(kempld_pdev);\n\treturn ret;\n}\n\n \nu8 kempld_read8(struct kempld_device_data *pld, u8 index)\n{\n\tiowrite8(index, pld->io_index);\n\treturn ioread8(pld->io_data);\n}\nEXPORT_SYMBOL_GPL(kempld_read8);\n\n \nvoid kempld_write8(struct kempld_device_data *pld, u8 index, u8 data)\n{\n\tiowrite8(index, pld->io_index);\n\tiowrite8(data, pld->io_data);\n}\nEXPORT_SYMBOL_GPL(kempld_write8);\n\n \nu16 kempld_read16(struct kempld_device_data *pld, u8 index)\n{\n\treturn kempld_read8(pld, index) | kempld_read8(pld, index + 1) << 8;\n}\nEXPORT_SYMBOL_GPL(kempld_read16);\n\n \nvoid kempld_write16(struct kempld_device_data *pld, u8 index, u16 data)\n{\n\tkempld_write8(pld, index, (u8)data);\n\tkempld_write8(pld, index + 1, (u8)(data >> 8));\n}\nEXPORT_SYMBOL_GPL(kempld_write16);\n\n \nu32 kempld_read32(struct kempld_device_data *pld, u8 index)\n{\n\treturn kempld_read16(pld, index) | kempld_read16(pld, index + 2) << 16;\n}\nEXPORT_SYMBOL_GPL(kempld_read32);\n\n \nvoid kempld_write32(struct kempld_device_data *pld, u8 index, u32 data)\n{\n\tkempld_write16(pld, index, (u16)data);\n\tkempld_write16(pld, index + 2, (u16)(data >> 16));\n}\nEXPORT_SYMBOL_GPL(kempld_write32);\n\n \nvoid kempld_get_mutex(struct kempld_device_data *pld)\n{\n\tconst struct kempld_platform_data *pdata = dev_get_platdata(pld->dev);\n\n\tmutex_lock(&pld->lock);\n\tpdata->get_hardware_mutex(pld);\n}\nEXPORT_SYMBOL_GPL(kempld_get_mutex);\n\n \nvoid kempld_release_mutex(struct kempld_device_data *pld)\n{\n\tconst struct kempld_platform_data *pdata = dev_get_platdata(pld->dev);\n\n\tpdata->release_hardware_mutex(pld);\n\tmutex_unlock(&pld->lock);\n}\nEXPORT_SYMBOL_GPL(kempld_release_mutex);\n\n \nstatic int kempld_get_info(struct kempld_device_data *pld)\n{\n\tint ret;\n\tconst struct kempld_platform_data *pdata = dev_get_platdata(pld->dev);\n\tchar major, minor;\n\n\tret = pdata->get_info(pld);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\tif (pld->info.major < 10)\n\t\tmajor = pld->info.major + '0';\n\telse\n\t\tmajor = (pld->info.major - 10) + 'A';\n\tif (pld->info.minor < 10)\n\t\tminor = pld->info.minor + '0';\n\telse\n\t\tminor = (pld->info.minor - 10) + 'A';\n\n\tret = scnprintf(pld->info.version, sizeof(pld->info.version),\n\t\t\t\"P%X%c%c.%04X\", pld->info.number, major, minor,\n\t\t\tpld->info.buildnr);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \nstatic int kempld_register_cells(struct kempld_device_data *pld)\n{\n\tconst struct kempld_platform_data *pdata = dev_get_platdata(pld->dev);\n\n\treturn pdata->register_cells(pld);\n}\n\nstatic const char *kempld_get_type_string(struct kempld_device_data *pld)\n{\n\tconst char *version_type;\n\n\tswitch (pld->info.type) {\n\tcase 0:\n\t\tversion_type = \"release\";\n\t\tbreak;\n\tcase 1:\n\t\tversion_type = \"debug\";\n\t\tbreak;\n\tcase 2:\n\t\tversion_type = \"custom\";\n\t\tbreak;\n\tdefault:\n\t\tversion_type = \"unspecified\";\n\t\tbreak;\n\t}\n\n\treturn version_type;\n}\n\nstatic ssize_t pld_version_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct kempld_device_data *pld = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%s\\n\", pld->info.version);\n}\n\nstatic ssize_t pld_specification_show(struct device *dev,\n\t\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct kempld_device_data *pld = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%d.%d\\n\", pld->info.spec_major, pld->info.spec_minor);\n}\n\nstatic ssize_t pld_type_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct kempld_device_data *pld = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%s\\n\", kempld_get_type_string(pld));\n}\n\nstatic DEVICE_ATTR_RO(pld_version);\nstatic DEVICE_ATTR_RO(pld_specification);\nstatic DEVICE_ATTR_RO(pld_type);\n\nstatic struct attribute *pld_attributes[] = {\n\t&dev_attr_pld_version.attr,\n\t&dev_attr_pld_specification.attr,\n\t&dev_attr_pld_type.attr,\n\tNULL\n};\n\nstatic const struct attribute_group pld_attr_group = {\n\t.attrs = pld_attributes,\n};\n\nstatic int kempld_detect_device(struct kempld_device_data *pld)\n{\n\tu8 index_reg;\n\tint ret;\n\n\tmutex_lock(&pld->lock);\n\n\t \n\tindex_reg = ioread8(pld->io_index);\n\tif (index_reg == 0xff && ioread8(pld->io_data) == 0xff) {\n\t\tmutex_unlock(&pld->lock);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (!(index_reg & KEMPLD_MUTEX_KEY)) {\n\t\tiowrite8(KEMPLD_MUTEX_KEY, pld->io_index);\n\t\t \n\t\tiowrite8(KEMPLD_MUTEX_KEY, pld->io_index);\n\t}\n\n\tmutex_unlock(&pld->lock);\n\n\tret = kempld_get_info(pld);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_info(pld->dev, \"Found Kontron PLD - %s (%s), spec %d.%d\\n\",\n\t\t pld->info.version, kempld_get_type_string(pld),\n\t\t pld->info.spec_major, pld->info.spec_minor);\n\n\tret = sysfs_create_group(&pld->dev->kobj, &pld_attr_group);\n\tif (ret)\n\t\treturn ret;\n\n\tret = kempld_register_cells(pld);\n\tif (ret)\n\t\tsysfs_remove_group(&pld->dev->kobj, &pld_attr_group);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_ACPI\nstatic int kempld_get_acpi_data(struct platform_device *pdev)\n{\n\tstruct list_head resource_list;\n\tstruct resource *resources;\n\tstruct resource_entry *rentry;\n\tstruct device *dev = &pdev->dev;\n\tstruct acpi_device *acpi_dev = ACPI_COMPANION(dev);\n\tconst struct kempld_platform_data *pdata;\n\tint ret;\n\tint count;\n\n\tpdata = acpi_device_get_match_data(dev);\n\tret = platform_device_add_data(pdev, pdata,\n\t\t\t\t       sizeof(struct kempld_platform_data));\n\tif (ret)\n\t\treturn ret;\n\n\tINIT_LIST_HEAD(&resource_list);\n\tret = acpi_dev_get_resources(acpi_dev, &resource_list, NULL, NULL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tcount = ret;\n\n\tif (count == 0) {\n\t\tret = platform_device_add_resources(pdev, pdata->ioresource, 1);\n\t\tgoto out;\n\t}\n\n\tresources = devm_kcalloc(&acpi_dev->dev, count, sizeof(*resources),\n\t\t\t\t GFP_KERNEL);\n\tif (!resources) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tcount = 0;\n\tlist_for_each_entry(rentry, &resource_list, node) {\n\t\tmemcpy(&resources[count], rentry->res,\n\t\t       sizeof(*resources));\n\t\tcount++;\n\t}\n\tret = platform_device_add_resources(pdev, resources, count);\n\nout:\n\tacpi_dev_free_resource_list(&resource_list);\n\n\treturn ret;\n}\n#else\nstatic int kempld_get_acpi_data(struct platform_device *pdev)\n{\n\treturn -ENODEV;\n}\n#endif  \n\nstatic int kempld_probe(struct platform_device *pdev)\n{\n\tconst struct kempld_platform_data *pdata;\n\tstruct device *dev = &pdev->dev;\n\tstruct kempld_device_data *pld;\n\tstruct resource *ioport;\n\tint ret;\n\n\tif (kempld_pdev == NULL) {\n\t\t \n\t\tret = kempld_get_acpi_data(pdev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else if (kempld_pdev != pdev) {\n\t\t \n\t\tdev_notice(dev, \"platform device exists - not using ACPI\\n\");\n\t\treturn -ENODEV;\n\t}\n\tpdata = dev_get_platdata(dev);\n\n\tpld = devm_kzalloc(dev, sizeof(*pld), GFP_KERNEL);\n\tif (!pld)\n\t\treturn -ENOMEM;\n\n\tioport = platform_get_resource(pdev, IORESOURCE_IO, 0);\n\tif (!ioport)\n\t\treturn -EINVAL;\n\n\tpld->io_base = devm_ioport_map(dev, ioport->start,\n\t\t\t\t\tresource_size(ioport));\n\tif (!pld->io_base)\n\t\treturn -ENOMEM;\n\n\tpld->io_index = pld->io_base;\n\tpld->io_data = pld->io_base + 1;\n\tpld->pld_clock = pdata->pld_clock;\n\tpld->dev = dev;\n\n\tmutex_init(&pld->lock);\n\tplatform_set_drvdata(pdev, pld);\n\n\treturn kempld_detect_device(pld);\n}\n\nstatic int kempld_remove(struct platform_device *pdev)\n{\n\tstruct kempld_device_data *pld = platform_get_drvdata(pdev);\n\tconst struct kempld_platform_data *pdata = dev_get_platdata(pld->dev);\n\n\tsysfs_remove_group(&pld->dev->kobj, &pld_attr_group);\n\n\tmfd_remove_devices(&pdev->dev);\n\tpdata->release_hardware_mutex(pld);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id kempld_acpi_table[] = {\n\t{ \"KEM0000\", (kernel_ulong_t)&kempld_platform_data_generic },\n\t{ \"KEM0001\", (kernel_ulong_t)&kempld_platform_data_generic },\n\t{}\n};\nMODULE_DEVICE_TABLE(acpi, kempld_acpi_table);\n#endif\n\nstatic struct platform_driver kempld_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"kempld\",\n\t\t.acpi_match_table = ACPI_PTR(kempld_acpi_table),\n\t},\n\t.probe\t\t= kempld_probe,\n\t.remove\t\t= kempld_remove,\n};\n\nstatic const struct dmi_system_id kempld_dmi_table[] __initconst = {\n\t{\n\t\t.ident = \"BBD6\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Kontron\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"COMe-bBD\"),\n\t\t},\n\t\t.driver_data = (void *)&kempld_platform_data_generic,\n\t\t.callback = kempld_create_platform_device,\n\t}, {\n\t\t.ident = \"BBL6\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Kontron\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"COMe-bBL6\"),\n\t\t},\n\t\t.driver_data = (void *)&kempld_platform_data_generic,\n\t\t.callback = kempld_create_platform_device,\n\t}, {\n\t\t.ident = \"BDV7\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Kontron\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"COMe-bDV7\"),\n\t\t},\n\t\t.driver_data = (void *)&kempld_platform_data_generic,\n\t\t.callback = kempld_create_platform_device,\n\t}, {\n\t\t.ident = \"BHL6\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Kontron\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"COMe-bHL6\"),\n\t\t},\n\t\t.driver_data = (void *)&kempld_platform_data_generic,\n\t\t.callback = kempld_create_platform_device,\n\t}, {\n\t\t.ident = \"BKL6\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Kontron\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"COMe-bKL6\"),\n\t\t},\n\t\t.driver_data = (void *)&kempld_platform_data_generic,\n\t\t.callback = kempld_create_platform_device,\n\t}, {\n\t\t.ident = \"BSL6\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Kontron\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"COMe-bSL6\"),\n\t\t},\n\t\t.driver_data = (void *)&kempld_platform_data_generic,\n\t\t.callback = kempld_create_platform_device,\n\t}, {\n\t\t.ident = \"CAL6\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Kontron\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"COMe-cAL\"),\n\t\t},\n\t\t.driver_data = (void *)&kempld_platform_data_generic,\n\t\t.callback = kempld_create_platform_device,\n\t}, {\n\t\t.ident = \"CBL6\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Kontron\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"COMe-cBL6\"),\n\t\t},\n\t\t.driver_data = (void *)&kempld_platform_data_generic,\n\t\t.callback = kempld_create_platform_device,\n\t}, {\n\t\t.ident = \"CBW6\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Kontron\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"COMe-cBW6\"),\n\t\t},\n\t\t.driver_data = (void *)&kempld_platform_data_generic,\n\t\t.callback = kempld_create_platform_device,\n\t}, {\n\t\t.ident = \"CCR2\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Kontron\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"COMe-bIP2\"),\n\t\t},\n\t\t.driver_data = (void *)&kempld_platform_data_generic,\n\t\t.callback = kempld_create_platform_device,\n\t}, {\n\t\t.ident = \"CCR6\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Kontron\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"COMe-bIP6\"),\n\t\t},\n\t\t.driver_data = (void *)&kempld_platform_data_generic,\n\t\t.callback = kempld_create_platform_device,\n\t}, {\n\t\t.ident = \"CDV7\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Kontron\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"COMe-cDV7\"),\n\t\t},\n\t\t.driver_data = (void *)&kempld_platform_data_generic,\n\t\t.callback = kempld_create_platform_device,\n\t}, {\n\t\t.ident = \"CHL6\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Kontron\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"COMe-cHL6\"),\n\t\t},\n\t\t.driver_data = (void *)&kempld_platform_data_generic,\n\t\t.callback = kempld_create_platform_device,\n\t}, {\n\t\t.ident = \"CHR2\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Kontron\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"ETXexpress-SC T2\"),\n\t\t},\n\t\t.driver_data = (void *)&kempld_platform_data_generic,\n\t\t.callback = kempld_create_platform_device,\n\t}, {\n\t\t.ident = \"CHR2\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Kontron\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"ETXe-SC T2\"),\n\t\t},\n\t\t.driver_data = (void *)&kempld_platform_data_generic,\n\t\t.callback = kempld_create_platform_device,\n\t}, {\n\t\t.ident = \"CHR2\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Kontron\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"COMe-bSC2\"),\n\t\t},\n\t\t.driver_data = (void *)&kempld_platform_data_generic,\n\t\t.callback = kempld_create_platform_device,\n\t}, {\n\t\t.ident = \"CHR6\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Kontron\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"ETXexpress-SC T6\"),\n\t\t},\n\t\t.driver_data = (void *)&kempld_platform_data_generic,\n\t\t.callback = kempld_create_platform_device,\n\t}, {\n\t\t.ident = \"CHR6\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Kontron\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"ETXe-SC T6\"),\n\t\t},\n\t\t.driver_data = (void *)&kempld_platform_data_generic,\n\t\t.callback = kempld_create_platform_device,\n\t}, {\n\t\t.ident = \"CHR6\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Kontron\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"COMe-bSC6\"),\n\t\t},\n\t\t.driver_data = (void *)&kempld_platform_data_generic,\n\t\t.callback = kempld_create_platform_device,\n\t}, {\n\t\t.ident = \"CKL6\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Kontron\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"COMe-cKL6\"),\n\t\t},\n\t\t.driver_data = (void *)&kempld_platform_data_generic,\n\t\t.callback = kempld_create_platform_device,\n\t}, {\n\t\t.ident = \"CNTG\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Kontron\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"ETXexpress-PC\"),\n\t\t},\n\t\t.driver_data = (void *)&kempld_platform_data_generic,\n\t\t.callback = kempld_create_platform_device,\n\t}, {\n\t\t.ident = \"CNTG\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Kontron\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"COMe-bPC2\"),\n\t\t},\n\t\t.driver_data = (void *)&kempld_platform_data_generic,\n\t\t.callback = kempld_create_platform_device,\n\t}, {\n\t\t.ident = \"CNTX\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Kontron\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"PXT\"),\n\t\t},\n\t\t.driver_data = (void *)&kempld_platform_data_generic,\n\t\t.callback = kempld_create_platform_device,\n\t}, {\n\t\t.ident = \"CSL6\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Kontron\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"COMe-cSL6\"),\n\t\t},\n\t\t.driver_data = (void *)&kempld_platform_data_generic,\n\t\t.callback = kempld_create_platform_device,\n\t}, {\n\t\t.ident = \"CVV6\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Kontron\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"COMe-cBT\"),\n\t\t},\n\t\t.driver_data = (void *)&kempld_platform_data_generic,\n\t\t.callback = kempld_create_platform_device,\n\t}, {\n\t\t.ident = \"FRI2\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Kontron\"),\n\t\t\tDMI_MATCH(DMI_BIOS_VERSION, \"FRI2\"),\n\t\t},\n\t\t.driver_data = (void *)&kempld_platform_data_generic,\n\t\t.callback = kempld_create_platform_device,\n\t}, {\n\t\t.ident = \"FRI2\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Fish River Island II\"),\n\t\t},\n\t\t.driver_data = (void *)&kempld_platform_data_generic,\n\t\t.callback = kempld_create_platform_device,\n\t}, {\n\t\t.ident = \"A203\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Kontron\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"KBox A-203\"),\n\t\t},\n\t\t.driver_data = (void *)&kempld_platform_data_generic,\n\t\t.callback = kempld_create_platform_device,\n\t}, {\n\t\t.ident = \"M4A1\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Kontron\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"COMe-m4AL\"),\n\t\t},\n\t\t.driver_data = (void *)&kempld_platform_data_generic,\n\t\t.callback = kempld_create_platform_device,\n\t}, {\n\t\t.ident = \"MAL1\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Kontron\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"COMe-mAL10\"),\n\t\t},\n\t\t.driver_data = (void *)&kempld_platform_data_generic,\n\t\t.callback = kempld_create_platform_device,\n\t}, {\n\t\t.ident = \"MAPL\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Kontron\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"mITX-APL\"),\n\t\t},\n\t\t.driver_data = (void *)&kempld_platform_data_generic,\n\t\t.callback = kempld_create_platform_device,\n\t}, {\n\t\t.ident = \"MBR1\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Kontron\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"ETX-OH\"),\n\t\t},\n\t\t.driver_data = (void *)&kempld_platform_data_generic,\n\t\t.callback = kempld_create_platform_device,\n\t}, {\n\t\t.ident = \"MVV1\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Kontron\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"COMe-mBT\"),\n\t\t},\n\t\t.driver_data = (void *)&kempld_platform_data_generic,\n\t\t.callback = kempld_create_platform_device,\n\t}, {\n\t\t.ident = \"NTC1\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Kontron\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"nanoETXexpress-TT\"),\n\t\t},\n\t\t.driver_data = (void *)&kempld_platform_data_generic,\n\t\t.callback = kempld_create_platform_device,\n\t}, {\n\t\t.ident = \"NTC1\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Kontron\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"nETXe-TT\"),\n\t\t},\n\t\t.driver_data = (void *)&kempld_platform_data_generic,\n\t\t.callback = kempld_create_platform_device,\n\t}, {\n\t\t.ident = \"NTC1\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Kontron\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"COMe-mTT\"),\n\t\t},\n\t\t.driver_data = (void *)&kempld_platform_data_generic,\n\t\t.callback = kempld_create_platform_device,\n\t}, {\n\t\t.ident = \"NUP1\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Kontron\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"COMe-mCT\"),\n\t\t},\n\t\t.driver_data = (void *)&kempld_platform_data_generic,\n\t\t.callback = kempld_create_platform_device,\n\t}, {\n\t\t.ident = \"PAPL\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Kontron\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"pITX-APL\"),\n\t\t},\n\t\t.driver_data = (void *)&kempld_platform_data_generic,\n\t\t.callback = kempld_create_platform_device,\n\t}, {\n\t\t.ident = \"SXAL\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Kontron\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"SMARC-sXAL\"),\n\t\t},\n\t\t.driver_data = (void *)&kempld_platform_data_generic,\n\t\t.callback = kempld_create_platform_device,\n\t}, {\n\t\t.ident = \"SXAL4\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Kontron\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"SMARC-sXA4\"),\n\t\t},\n\t\t.driver_data = (void *)&kempld_platform_data_generic,\n\t\t.callback = kempld_create_platform_device,\n\t}, {\n\t\t.ident = \"UNP1\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Kontron\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"microETXexpress-DC\"),\n\t\t},\n\t\t.driver_data = (void *)&kempld_platform_data_generic,\n\t\t.callback = kempld_create_platform_device,\n\t}, {\n\t\t.ident = \"UNP1\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Kontron\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"COMe-cDC2\"),\n\t\t},\n\t\t.driver_data = (void *)&kempld_platform_data_generic,\n\t\t.callback = kempld_create_platform_device,\n\t}, {\n\t\t.ident = \"UNTG\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Kontron\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"microETXexpress-PC\"),\n\t\t},\n\t\t.driver_data = (void *)&kempld_platform_data_generic,\n\t\t.callback = kempld_create_platform_device,\n\t}, {\n\t\t.ident = \"UNTG\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Kontron\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"COMe-cPC2\"),\n\t\t},\n\t\t.driver_data = (void *)&kempld_platform_data_generic,\n\t\t.callback = kempld_create_platform_device,\n\t}, {\n\t\t.ident = \"UUP6\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Kontron\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"COMe-cCT6\"),\n\t\t},\n\t\t.driver_data = (void *)&kempld_platform_data_generic,\n\t\t.callback = kempld_create_platform_device,\n\t}, {\n\t\t.ident = \"UTH6\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Kontron\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"COMe-cTH6\"),\n\t\t},\n\t\t.driver_data = (void *)&kempld_platform_data_generic,\n\t\t.callback = kempld_create_platform_device,\n\t}, {\n\t\t.ident = \"Q7AL\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Kontron\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"Qseven-Q7AL\"),\n\t\t},\n\t\t.driver_data = (void *)&kempld_platform_data_generic,\n\t\t.callback = kempld_create_platform_device,\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(dmi, kempld_dmi_table);\n\nstatic int __init kempld_init(void)\n{\n\tconst struct dmi_system_id *id;\n\n\tif (force_device_id[0]) {\n\t\tfor (id = kempld_dmi_table;\n\t\t     id->matches[0].slot != DMI_NONE; id++)\n\t\t\tif (strstr(id->ident, force_device_id))\n\t\t\t\tif (id->callback && !id->callback(id))\n\t\t\t\t\tbreak;\n\t\tif (id->matches[0].slot == DMI_NONE)\n\t\t\treturn -ENODEV;\n\t} else {\n\t\tdmi_check_system(kempld_dmi_table);\n\t}\n\n\treturn platform_driver_register(&kempld_driver);\n}\n\nstatic void __exit kempld_exit(void)\n{\n\tif (kempld_pdev)\n\t\tplatform_device_unregister(kempld_pdev);\n\n\tplatform_driver_unregister(&kempld_driver);\n}\n\nmodule_init(kempld_init);\nmodule_exit(kempld_exit);\n\nMODULE_DESCRIPTION(\"KEM PLD Core Driver\");\nMODULE_AUTHOR(\"Michael Brunner <michael.brunner@kontron.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:kempld-core\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}