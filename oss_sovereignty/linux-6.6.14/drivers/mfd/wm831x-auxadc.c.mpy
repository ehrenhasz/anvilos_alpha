{
  "module_name": "wm831x-auxadc.c",
  "hash_id": "e8df86fb68daee67954373a736895670faa8ff040edfd57bdf9ea01292c2d50b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/wm831x-auxadc.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/mfd/core.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n\n#include <linux/mfd/wm831x/core.h>\n#include <linux/mfd/wm831x/pdata.h>\n#include <linux/mfd/wm831x/irq.h>\n#include <linux/mfd/wm831x/auxadc.h>\n#include <linux/mfd/wm831x/otp.h>\n#include <linux/mfd/wm831x/regulator.h>\n\nstruct wm831x_auxadc_req {\n\tstruct list_head list;\n\tenum wm831x_auxadc input;\n\tint val;\n\tstruct completion done;\n};\n\nstatic int wm831x_auxadc_read_irq(struct wm831x *wm831x,\n\t\t\t\t  enum wm831x_auxadc input)\n{\n\tstruct wm831x_auxadc_req *req;\n\tint ret;\n\tbool ena = false;\n\n\treq = kzalloc(sizeof(*req), GFP_KERNEL);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\tinit_completion(&req->done);\n\treq->input = input;\n\treq->val = -ETIMEDOUT;\n\n\tmutex_lock(&wm831x->auxadc_lock);\n\n\t \n\tlist_add(&req->list, &wm831x->auxadc_pending);\n\n\tena = !wm831x->auxadc_active;\n\n\tif (ena) {\n\t\tret = wm831x_set_bits(wm831x, WM831X_AUXADC_CONTROL,\n\t\t\t\t      WM831X_AUX_ENA, WM831X_AUX_ENA);\n\t\tif (ret != 0) {\n\t\t\tdev_err(wm831x->dev, \"Failed to enable AUXADC: %d\\n\",\n\t\t\t\tret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tif (!(wm831x->auxadc_active & (1 << input))) {\n\t\tret = wm831x_set_bits(wm831x, WM831X_AUXADC_SOURCE,\n\t\t\t\t      1 << input, 1 << input);\n\t\tif (ret != 0) {\n\t\t\tdev_err(wm831x->dev,\n\t\t\t\t\"Failed to set AUXADC source: %d\\n\", ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\twm831x->auxadc_active |= 1 << input;\n\t}\n\n\t \n\tif (ena) {\n\t\tret = wm831x_set_bits(wm831x, WM831X_AUXADC_CONTROL,\n\t\t\t\t      WM831X_AUX_CVT_ENA |\n\t\t\t\t      WM831X_AUX_RATE_MASK,\n\t\t\t\t      WM831X_AUX_CVT_ENA |\n\t\t\t\t      WM831X_AUX_RATE_MASK);\n\t\tif (ret != 0) {\n\t\t\tdev_err(wm831x->dev, \"Failed to start AUXADC: %d\\n\",\n\t\t\t\tret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tmutex_unlock(&wm831x->auxadc_lock);\n\n\t \n\twait_for_completion_timeout(&req->done, msecs_to_jiffies(500));\n\n\tmutex_lock(&wm831x->auxadc_lock);\n\tret = req->val;\n\nout:\n\tlist_del(&req->list);\n\tmutex_unlock(&wm831x->auxadc_lock);\n\n\tkfree(req);\n\n\treturn ret;\n}\n\nstatic irqreturn_t wm831x_auxadc_irq(int irq, void *irq_data)\n{\n\tstruct wm831x *wm831x = irq_data;\n\tstruct wm831x_auxadc_req *req;\n\tint ret, input, val;\n\n\tret = wm831x_reg_read(wm831x, WM831X_AUXADC_DATA);\n\tif (ret < 0) {\n\t\tdev_err(wm831x->dev,\n\t\t\t\"Failed to read AUXADC data: %d\\n\", ret);\n\t\treturn IRQ_NONE;\n\t}\n\n\tinput = ((ret & WM831X_AUX_DATA_SRC_MASK)\n\t\t >> WM831X_AUX_DATA_SRC_SHIFT) - 1;\n\n\tif (input == 14)\n\t\tinput = WM831X_AUX_CAL;\n\n\tval = ret & WM831X_AUX_DATA_MASK;\n\n\tmutex_lock(&wm831x->auxadc_lock);\n\n\t \n\twm831x_set_bits(wm831x, WM831X_AUXADC_SOURCE,\n\t\t\t1 << input, 0);\n\twm831x->auxadc_active &= ~(1 << input);\n\n\t \n\tif (!wm831x->auxadc_active)\n\t\twm831x_reg_write(wm831x, WM831X_AUXADC_CONTROL, 0);\n\n\t \n\tlist_for_each_entry(req, &wm831x->auxadc_pending, list) {\n\t\tif (req->input == input) {\n\t\t\treq->val = val;\n\t\t\tcomplete(&req->done);\n\t\t}\n\t}\n\n\tmutex_unlock(&wm831x->auxadc_lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int wm831x_auxadc_read_polled(struct wm831x *wm831x,\n\t\t\t\t     enum wm831x_auxadc input)\n{\n\tint ret, src, timeout;\n\n\tmutex_lock(&wm831x->auxadc_lock);\n\n\tret = wm831x_set_bits(wm831x, WM831X_AUXADC_CONTROL,\n\t\t\t      WM831X_AUX_ENA, WM831X_AUX_ENA);\n\tif (ret < 0) {\n\t\tdev_err(wm831x->dev, \"Failed to enable AUXADC: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\t \n\tsrc = input;\n\tret = wm831x_reg_write(wm831x, WM831X_AUXADC_SOURCE,\n\t\t\t       1 << src);\n\tif (ret < 0) {\n\t\tdev_err(wm831x->dev, \"Failed to set AUXADC source: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = wm831x_set_bits(wm831x, WM831X_AUXADC_CONTROL,\n\t\t\t      WM831X_AUX_CVT_ENA, WM831X_AUX_CVT_ENA);\n\tif (ret < 0) {\n\t\tdev_err(wm831x->dev, \"Failed to start AUXADC: %d\\n\", ret);\n\t\tgoto disable;\n\t}\n\n\t \n\ttimeout = 5;\n\twhile (timeout) {\n\t\tmsleep(1);\n\n\t\tret = wm831x_reg_read(wm831x,\n\t\t\t\t      WM831X_INTERRUPT_STATUS_1);\n\t\tif (ret < 0) {\n\t\t\tdev_err(wm831x->dev,\n\t\t\t\t\"ISR 1 read failed: %d\\n\", ret);\n\t\t\tgoto disable;\n\t\t}\n\n\t\t \n\t\tif (ret & WM831X_AUXADC_DATA_EINT) {\n\t\t\twm831x_reg_write(wm831x,\n\t\t\t\t\t WM831X_INTERRUPT_STATUS_1,\n\t\t\t\t\t WM831X_AUXADC_DATA_EINT);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tdev_err(wm831x->dev,\n\t\t\t\t\"AUXADC conversion timeout\\n\");\n\t\t\tret = -EBUSY;\n\t\t\tgoto disable;\n\t\t}\n\t}\n\n\tret = wm831x_reg_read(wm831x, WM831X_AUXADC_DATA);\n\tif (ret < 0) {\n\t\tdev_err(wm831x->dev,\n\t\t\t\"Failed to read AUXADC data: %d\\n\", ret);\n\t\tgoto disable;\n\t}\n\n\tsrc = ((ret & WM831X_AUX_DATA_SRC_MASK)\n\t       >> WM831X_AUX_DATA_SRC_SHIFT) - 1;\n\n\tif (src == 14)\n\t\tsrc = WM831X_AUX_CAL;\n\n\tif (src != input) {\n\t\tdev_err(wm831x->dev, \"Data from source %d not %d\\n\",\n\t\t\tsrc, input);\n\t\tret = -EINVAL;\n\t} else {\n\t\tret &= WM831X_AUX_DATA_MASK;\n\t}\n\ndisable:\n\twm831x_set_bits(wm831x, WM831X_AUXADC_CONTROL, WM831X_AUX_ENA, 0);\nout:\n\tmutex_unlock(&wm831x->auxadc_lock);\n\treturn ret;\n}\n\n \nint wm831x_auxadc_read(struct wm831x *wm831x, enum wm831x_auxadc input)\n{\n\treturn wm831x->auxadc_read(wm831x, input);\n}\nEXPORT_SYMBOL_GPL(wm831x_auxadc_read);\n\n \nint wm831x_auxadc_read_uv(struct wm831x *wm831x, enum wm831x_auxadc input)\n{\n\tint ret;\n\n\tret = wm831x_auxadc_read(wm831x, input);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret *= 1465;\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(wm831x_auxadc_read_uv);\n\nvoid wm831x_auxadc_init(struct wm831x *wm831x)\n{\n\tint ret;\n\n\tmutex_init(&wm831x->auxadc_lock);\n\tINIT_LIST_HEAD(&wm831x->auxadc_pending);\n\n\tif (wm831x->irq) {\n\t\twm831x->auxadc_read = wm831x_auxadc_read_irq;\n\n\t\tret = request_threaded_irq(wm831x_irq(wm831x,\n\t\t\t\t\t\t      WM831X_IRQ_AUXADC_DATA),\n\t\t\t\t\t   NULL, wm831x_auxadc_irq,\n\t\t\t\t\t   IRQF_ONESHOT,\n\t\t\t\t\t   \"auxadc\", wm831x);\n\t\tif (ret < 0) {\n\t\t\tdev_err(wm831x->dev, \"AUXADC IRQ request failed: %d\\n\",\n\t\t\t\tret);\n\t\t\twm831x->auxadc_read = NULL;\n\t\t}\n\t}\n\n\tif (!wm831x->auxadc_read)\n\t\twm831x->auxadc_read = wm831x_auxadc_read_polled;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}