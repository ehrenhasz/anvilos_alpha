{
  "module_name": "max77686.c",
  "hash_id": "95ef93dc5b6a7ec6452a289396dc0bda4e4a63d715290c7e139b70baf87d82c0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/max77686.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/pm_runtime.h>\n#include <linux/module.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/max77686.h>\n#include <linux/mfd/max77686-private.h>\n#include <linux/err.h>\n#include <linux/of.h>\n\nstatic const struct mfd_cell max77686_devs[] = {\n\t{ .name = \"max77686-pmic\", },\n\t{ .name = \"max77686-rtc\", },\n\t{ .name = \"max77686-clk\", },\n};\n\nstatic const struct mfd_cell max77802_devs[] = {\n\t{ .name = \"max77802-pmic\", },\n\t{ .name = \"max77802-clk\", },\n\t{ .name = \"max77802-rtc\", },\n};\n\nstatic bool max77802_pmic_is_accessible_reg(struct device *dev,\n\t\t\t\t\t    unsigned int reg)\n{\n\treturn reg < MAX77802_REG_PMIC_END;\n}\n\nstatic bool max77802_rtc_is_accessible_reg(struct device *dev,\n\t\t\t\t\t   unsigned int reg)\n{\n\treturn (reg >= MAX77802_RTC_INT && reg < MAX77802_RTC_END);\n}\n\nstatic bool max77802_is_accessible_reg(struct device *dev, unsigned int reg)\n{\n\treturn (max77802_pmic_is_accessible_reg(dev, reg) ||\n\t\tmax77802_rtc_is_accessible_reg(dev, reg));\n}\n\nstatic bool max77802_pmic_is_precious_reg(struct device *dev, unsigned int reg)\n{\n\treturn (reg == MAX77802_REG_INTSRC || reg == MAX77802_REG_INT1 ||\n\t\treg == MAX77802_REG_INT2);\n}\n\nstatic bool max77802_rtc_is_precious_reg(struct device *dev, unsigned int reg)\n{\n\treturn (reg == MAX77802_RTC_INT ||\n\t\treg == MAX77802_RTC_UPDATE0 ||\n\t\treg == MAX77802_RTC_UPDATE1);\n}\n\nstatic bool max77802_is_precious_reg(struct device *dev, unsigned int reg)\n{\n\treturn (max77802_pmic_is_precious_reg(dev, reg) ||\n\t\tmax77802_rtc_is_precious_reg(dev, reg));\n}\n\nstatic bool max77802_pmic_is_volatile_reg(struct device *dev, unsigned int reg)\n{\n\treturn (max77802_is_precious_reg(dev, reg) ||\n\t\treg == MAX77802_REG_STATUS1 || reg == MAX77802_REG_STATUS2 ||\n\t\treg == MAX77802_REG_PWRON);\n}\n\nstatic bool max77802_rtc_is_volatile_reg(struct device *dev, unsigned int reg)\n{\n\treturn (max77802_rtc_is_precious_reg(dev, reg) ||\n\t\treg == MAX77802_RTC_SEC ||\n\t\treg == MAX77802_RTC_MIN ||\n\t\treg == MAX77802_RTC_HOUR ||\n\t\treg == MAX77802_RTC_WEEKDAY ||\n\t\treg == MAX77802_RTC_MONTH ||\n\t\treg == MAX77802_RTC_YEAR ||\n\t\treg == MAX77802_RTC_MONTHDAY);\n}\n\nstatic bool max77802_is_volatile_reg(struct device *dev, unsigned int reg)\n{\n\treturn (max77802_pmic_is_volatile_reg(dev, reg) ||\n\t\tmax77802_rtc_is_volatile_reg(dev, reg));\n}\n\nstatic const struct regmap_config max77686_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n};\n\nstatic const struct regmap_config max77802_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.writeable_reg = max77802_is_accessible_reg,\n\t.readable_reg = max77802_is_accessible_reg,\n\t.precious_reg = max77802_is_precious_reg,\n\t.volatile_reg = max77802_is_volatile_reg,\n\t.name = \"max77802-pmic\",\n\t.cache_type = REGCACHE_RBTREE,\n};\n\nstatic const struct regmap_irq max77686_irqs[] = {\n\t \n\t{ .reg_offset = 0, .mask = MAX77686_INT1_PWRONF_MSK, },\n\t{ .reg_offset = 0, .mask = MAX77686_INT1_PWRONR_MSK, },\n\t{ .reg_offset = 0, .mask = MAX77686_INT1_JIGONBF_MSK, },\n\t{ .reg_offset = 0, .mask = MAX77686_INT1_JIGONBR_MSK, },\n\t{ .reg_offset = 0, .mask = MAX77686_INT1_ACOKBF_MSK, },\n\t{ .reg_offset = 0, .mask = MAX77686_INT1_ACOKBR_MSK, },\n\t{ .reg_offset = 0, .mask = MAX77686_INT1_ONKEY1S_MSK, },\n\t{ .reg_offset = 0, .mask = MAX77686_INT1_MRSTB_MSK, },\n\t \n\t{ .reg_offset = 1, .mask = MAX77686_INT2_140C_MSK, },\n\t{ .reg_offset = 1, .mask = MAX77686_INT2_120C_MSK, },\n};\n\nstatic const struct regmap_irq_chip max77686_irq_chip = {\n\t.name\t\t\t= \"max77686-pmic\",\n\t.status_base\t\t= MAX77686_REG_INT1,\n\t.mask_base\t\t= MAX77686_REG_INT1MSK,\n\t.num_regs\t\t= 2,\n\t.irqs\t\t\t= max77686_irqs,\n\t.num_irqs\t\t= ARRAY_SIZE(max77686_irqs),\n};\n\nstatic const struct regmap_irq_chip max77802_irq_chip = {\n\t.name\t\t\t= \"max77802-pmic\",\n\t.status_base\t\t= MAX77802_REG_INT1,\n\t.mask_base\t\t= MAX77802_REG_INT1MSK,\n\t.num_regs\t\t= 2,\n\t.irqs\t\t\t= max77686_irqs,  \n\t.num_irqs\t\t= ARRAY_SIZE(max77686_irqs),\n};\n\nstatic const struct of_device_id max77686_pmic_dt_match[] = {\n\t{\n\t\t.compatible = \"maxim,max77686\",\n\t\t.data = (void *)TYPE_MAX77686,\n\t},\n\t{\n\t\t.compatible = \"maxim,max77802\",\n\t\t.data = (void *)TYPE_MAX77802,\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, max77686_pmic_dt_match);\n\nstatic int max77686_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct max77686_dev *max77686 = NULL;\n\tunsigned int data;\n\tint ret = 0;\n\tconst struct regmap_config *config;\n\tconst struct regmap_irq_chip *irq_chip;\n\tconst struct mfd_cell *cells;\n\tint n_devs;\n\n\tmax77686 = devm_kzalloc(&i2c->dev,\n\t\t\t\tsizeof(struct max77686_dev), GFP_KERNEL);\n\tif (!max77686)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(i2c, max77686);\n\tmax77686->type = (unsigned long)of_device_get_match_data(&i2c->dev);\n\tmax77686->dev = &i2c->dev;\n\tmax77686->i2c = i2c;\n\n\tmax77686->irq = i2c->irq;\n\n\tif (max77686->type == TYPE_MAX77686) {\n\t\tconfig = &max77686_regmap_config;\n\t\tirq_chip = &max77686_irq_chip;\n\t\tcells =  max77686_devs;\n\t\tn_devs = ARRAY_SIZE(max77686_devs);\n\t} else {\n\t\tconfig = &max77802_regmap_config;\n\t\tirq_chip = &max77802_irq_chip;\n\t\tcells =  max77802_devs;\n\t\tn_devs = ARRAY_SIZE(max77802_devs);\n\t}\n\n\tmax77686->regmap = devm_regmap_init_i2c(i2c, config);\n\tif (IS_ERR(max77686->regmap)) {\n\t\tret = PTR_ERR(max77686->regmap);\n\t\tdev_err(max77686->dev, \"Failed to allocate register map: %d\\n\",\n\t\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_read(max77686->regmap, MAX77686_REG_DEVICE_ID, &data);\n\tif (ret < 0) {\n\t\tdev_err(max77686->dev,\n\t\t\t\"device not found on this channel (this is not an error)\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = devm_regmap_add_irq_chip(&i2c->dev, max77686->regmap,\n\t\t\t\t       max77686->irq,\n\t\t\t\t       IRQF_ONESHOT | IRQF_SHARED, 0, irq_chip,\n\t\t\t\t       &max77686->irq_data);\n\tif (ret < 0) {\n\t\tdev_err(&i2c->dev, \"failed to add PMIC irq chip: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = devm_mfd_add_devices(max77686->dev, -1, cells, n_devs, NULL,\n\t\t\t\t   0, NULL);\n\tif (ret < 0) {\n\t\tdev_err(&i2c->dev, \"failed to add MFD devices: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int max77686_suspend(struct device *dev)\n{\n\tstruct i2c_client *i2c = to_i2c_client(dev);\n\tstruct max77686_dev *max77686 = i2c_get_clientdata(i2c);\n\n\tif (device_may_wakeup(dev))\n\t\tenable_irq_wake(max77686->irq);\n\n\t \n\tdisable_irq(max77686->irq);\n\n\treturn 0;\n}\n\nstatic int max77686_resume(struct device *dev)\n{\n\tstruct i2c_client *i2c = to_i2c_client(dev);\n\tstruct max77686_dev *max77686 = i2c_get_clientdata(i2c);\n\n\tif (device_may_wakeup(dev))\n\t\tdisable_irq_wake(max77686->irq);\n\n\tenable_irq(max77686->irq);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(max77686_pm, max77686_suspend, max77686_resume);\n\nstatic struct i2c_driver max77686_i2c_driver = {\n\t.driver = {\n\t\t   .name = \"max77686\",\n\t\t   .pm = pm_sleep_ptr(&max77686_pm),\n\t\t   .of_match_table = max77686_pmic_dt_match,\n\t},\n\t.probe = max77686_i2c_probe,\n};\n\nmodule_i2c_driver(max77686_i2c_driver);\n\nMODULE_DESCRIPTION(\"MAXIM 77686/802 multi-function core driver\");\nMODULE_AUTHOR(\"Chiwoong Byun <woong.byun@samsung.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}