{
  "module_name": "rohm-bd718x7.c",
  "hash_id": "1180d04df03ab85cd81a2551f3cd4d4b460854b5e099be15bef69c518828c06e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/rohm-bd718x7.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n#include <linux/gpio_keys.h>\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/interrupt.h>\n#include <linux/mfd/rohm-bd718x7.h>\n#include <linux/mfd/core.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n#include <linux/types.h>\n\nstatic struct gpio_keys_button button = {\n\t.code = KEY_POWER,\n\t.gpio = -1,\n\t.type = EV_KEY,\n};\n\nstatic struct gpio_keys_platform_data bd718xx_powerkey_data = {\n\t.buttons = &button,\n\t.nbuttons = 1,\n\t.name = \"bd718xx-pwrkey\",\n};\n\nstatic struct mfd_cell bd71837_mfd_cells[] = {\n\t{\n\t\t.name = \"gpio-keys\",\n\t\t.platform_data = &bd718xx_powerkey_data,\n\t\t.pdata_size = sizeof(bd718xx_powerkey_data),\n\t},\n\t{ .name = \"bd71837-clk\", },\n\t{ .name = \"bd71837-pmic\", },\n};\n\nstatic struct mfd_cell bd71847_mfd_cells[] = {\n\t{\n\t\t.name = \"gpio-keys\",\n\t\t.platform_data = &bd718xx_powerkey_data,\n\t\t.pdata_size = sizeof(bd718xx_powerkey_data),\n\t},\n\t{ .name = \"bd71847-clk\", },\n\t{ .name = \"bd71847-pmic\", },\n};\n\nstatic const struct regmap_irq bd718xx_irqs[] = {\n\tREGMAP_IRQ_REG(BD718XX_INT_SWRST, 0, BD718XX_INT_SWRST_MASK),\n\tREGMAP_IRQ_REG(BD718XX_INT_PWRBTN_S, 0, BD718XX_INT_PWRBTN_S_MASK),\n\tREGMAP_IRQ_REG(BD718XX_INT_PWRBTN_L, 0, BD718XX_INT_PWRBTN_L_MASK),\n\tREGMAP_IRQ_REG(BD718XX_INT_PWRBTN, 0, BD718XX_INT_PWRBTN_MASK),\n\tREGMAP_IRQ_REG(BD718XX_INT_WDOG, 0, BD718XX_INT_WDOG_MASK),\n\tREGMAP_IRQ_REG(BD718XX_INT_ON_REQ, 0, BD718XX_INT_ON_REQ_MASK),\n\tREGMAP_IRQ_REG(BD718XX_INT_STBY_REQ, 0, BD718XX_INT_STBY_REQ_MASK),\n};\n\nstatic struct regmap_irq_chip bd718xx_irq_chip = {\n\t.name = \"bd718xx-irq\",\n\t.irqs = bd718xx_irqs,\n\t.num_irqs = ARRAY_SIZE(bd718xx_irqs),\n\t.num_regs = 1,\n\t.irq_reg_stride = 1,\n\t.status_base = BD718XX_REG_IRQ,\n\t.mask_base = BD718XX_REG_MIRQ,\n\t.ack_base = BD718XX_REG_IRQ,\n\t.init_ack_masked = true,\n};\n\nstatic const struct regmap_range pmic_status_range = {\n\t.range_min = BD718XX_REG_IRQ,\n\t.range_max = BD718XX_REG_POW_STATE,\n};\n\nstatic const struct regmap_access_table volatile_regs = {\n\t.yes_ranges = &pmic_status_range,\n\t.n_yes_ranges = 1,\n};\n\nstatic const struct regmap_config bd718xx_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.volatile_table = &volatile_regs,\n\t.max_register = BD718XX_MAX_REGISTER - 1,\n\t.cache_type = REGCACHE_RBTREE,\n};\n\nstatic int bd718xx_init_press_duration(struct regmap *regmap,\n\t\t\t\t       struct device *dev)\n{\n\tu32 short_press_ms, long_press_ms;\n\tu32 short_press_value, long_press_value;\n\tint ret;\n\n\tret = of_property_read_u32(dev->of_node, \"rohm,short-press-ms\",\n\t\t\t\t   &short_press_ms);\n\tif (!ret) {\n\t\tshort_press_value = min(15u, (short_press_ms + 250) / 500);\n\t\tret = regmap_update_bits(regmap, BD718XX_REG_PWRONCONFIG0,\n\t\t\t\t\t BD718XX_PWRBTN_PRESS_DURATION_MASK,\n\t\t\t\t\t short_press_value);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to init pwron short press\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = of_property_read_u32(dev->of_node, \"rohm,long-press-ms\",\n\t\t\t\t   &long_press_ms);\n\tif (!ret) {\n\t\tlong_press_value = min(15u, (long_press_ms + 500) / 1000);\n\t\tret = regmap_update_bits(regmap, BD718XX_REG_PWRONCONFIG1,\n\t\t\t\t\t BD718XX_PWRBTN_PRESS_DURATION_MASK,\n\t\t\t\t\t long_press_value);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to init pwron long press\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int bd718xx_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct regmap *regmap;\n\tstruct regmap_irq_chip_data *irq_data;\n\tint ret;\n\tunsigned int chip_type;\n\tstruct mfd_cell *mfd;\n\tint cells;\n\n\tif (!i2c->irq) {\n\t\tdev_err(&i2c->dev, \"No IRQ configured\\n\");\n\t\treturn -EINVAL;\n\t}\n\tchip_type = (unsigned int)(uintptr_t)\n\t\t    of_device_get_match_data(&i2c->dev);\n\tswitch (chip_type) {\n\tcase ROHM_CHIP_TYPE_BD71837:\n\t\tmfd = bd71837_mfd_cells;\n\t\tcells = ARRAY_SIZE(bd71837_mfd_cells);\n\t\tbreak;\n\tcase ROHM_CHIP_TYPE_BD71847:\n\t\tmfd = bd71847_mfd_cells;\n\t\tcells = ARRAY_SIZE(bd71847_mfd_cells);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&i2c->dev, \"Unknown device type\");\n\t\treturn -EINVAL;\n\t}\n\n\tregmap = devm_regmap_init_i2c(i2c, &bd718xx_regmap_config);\n\tif (IS_ERR(regmap))\n\t\treturn dev_err_probe(&i2c->dev, PTR_ERR(regmap),\n\t\t\t\t     \"regmap initialization failed\\n\");\n\n\tret = devm_regmap_add_irq_chip(&i2c->dev, regmap, i2c->irq,\n\t\t\t\t       IRQF_ONESHOT, 0, &bd718xx_irq_chip,\n\t\t\t\t       &irq_data);\n\tif (ret)\n\t\treturn dev_err_probe(&i2c->dev, ret, \"Failed to add irq_chip\\n\");\n\n\tret = bd718xx_init_press_duration(regmap, &i2c->dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_irq_get_virq(irq_data, BD718XX_INT_PWRBTN_S);\n\n\tif (ret < 0)\n\t\treturn dev_err_probe(&i2c->dev, ret, \"Failed to get the IRQ\\n\");\n\n\tbutton.irq = ret;\n\n\tret = devm_mfd_add_devices(&i2c->dev, PLATFORM_DEVID_AUTO,\n\t\t\t\t   mfd, cells, NULL, 0,\n\t\t\t\t   regmap_irq_get_domain(irq_data));\n\tif (ret)\n\t\tdev_err_probe(&i2c->dev, ret, \"Failed to create subdevices\\n\");\n\n\treturn ret;\n}\n\nstatic const struct of_device_id bd718xx_of_match[] = {\n\t{\n\t\t.compatible = \"rohm,bd71837\",\n\t\t.data = (void *)ROHM_CHIP_TYPE_BD71837,\n\t},\n\t{\n\t\t.compatible = \"rohm,bd71847\",\n\t\t.data = (void *)ROHM_CHIP_TYPE_BD71847,\n\t},\n\t{\n\t\t.compatible = \"rohm,bd71850\",\n\t\t.data = (void *)ROHM_CHIP_TYPE_BD71847,\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, bd718xx_of_match);\n\nstatic struct i2c_driver bd718xx_i2c_driver = {\n\t.driver = {\n\t\t.name = \"rohm-bd718x7\",\n\t\t.of_match_table = bd718xx_of_match,\n\t},\n\t.probe = bd718xx_i2c_probe,\n};\n\nstatic int __init bd718xx_i2c_init(void)\n{\n\treturn i2c_add_driver(&bd718xx_i2c_driver);\n}\n\n \nsubsys_initcall(bd718xx_i2c_init);\n\nstatic void __exit bd718xx_i2c_exit(void)\n{\n\ti2c_del_driver(&bd718xx_i2c_driver);\n}\nmodule_exit(bd718xx_i2c_exit);\n\nMODULE_AUTHOR(\"Matti Vaittinen <matti.vaittinen@fi.rohmeurope.com>\");\nMODULE_DESCRIPTION(\"ROHM BD71837/BD71847 Power Management IC driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}