{
  "module_name": "atmel-flexcom.c",
  "hash_id": "e690b3832e7d103e0224725179b91dedd8959a83cc8cbc70e4afee93d796f732",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/atmel-flexcom.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/clk.h>\n#include <dt-bindings/mfd/atmel-flexcom.h>\n\n \n#define FLEX_MR\t\t0x0\t \n#define FLEX_VERSION\t0xfc\t \n\n \n#define FLEX_MR_OPMODE_OFFSET\t(0)   \n#define FLEX_MR_OPMODE_MASK\t(0x3 << FLEX_MR_OPMODE_OFFSET)\n#define FLEX_MR_OPMODE(opmode)\t(((opmode) << FLEX_MR_OPMODE_OFFSET) &\t\\\n\t\t\t\t FLEX_MR_OPMODE_MASK)\n\nstruct atmel_flexcom {\n\tvoid __iomem *base;\n\tu32 opmode;\n\tstruct clk *clk;\n};\n\nstatic int atmel_flexcom_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct atmel_flexcom *ddata;\n\tint err;\n\n\tddata = devm_kzalloc(&pdev->dev, sizeof(*ddata), GFP_KERNEL);\n\tif (!ddata)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, ddata);\n\n\terr = of_property_read_u32(np, \"atmel,flexcom-mode\", &ddata->opmode);\n\tif (err)\n\t\treturn err;\n\n\tif (ddata->opmode < ATMEL_FLEXCOM_MODE_USART ||\n\t    ddata->opmode > ATMEL_FLEXCOM_MODE_TWI)\n\t\treturn -EINVAL;\n\n\tddata->base = devm_platform_get_and_ioremap_resource(pdev, 0, NULL);\n\tif (IS_ERR(ddata->base))\n\t\treturn PTR_ERR(ddata->base);\n\n\tddata->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(ddata->clk))\n\t\treturn PTR_ERR(ddata->clk);\n\n\terr = clk_prepare_enable(ddata->clk);\n\tif (err)\n\t\treturn err;\n\n\t \n\twritel(FLEX_MR_OPMODE(ddata->opmode), ddata->base + FLEX_MR);\n\n\tclk_disable_unprepare(ddata->clk);\n\n\treturn devm_of_platform_populate(&pdev->dev);\n}\n\nstatic const struct of_device_id atmel_flexcom_of_match[] = {\n\t{ .compatible = \"atmel,sama5d2-flexcom\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, atmel_flexcom_of_match);\n\nstatic int __maybe_unused atmel_flexcom_resume_noirq(struct device *dev)\n{\n\tstruct atmel_flexcom *ddata = dev_get_drvdata(dev);\n\tint err;\n\tu32 val;\n\n\terr = clk_prepare_enable(ddata->clk);\n\tif (err)\n\t\treturn err;\n\n\tval = FLEX_MR_OPMODE(ddata->opmode),\n\twritel(val, ddata->base + FLEX_MR);\n\n\tclk_disable_unprepare(ddata->clk);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops __maybe_unused atmel_flexcom_pm_ops = {\n\t.resume_noirq = atmel_flexcom_resume_noirq,\n};\n\nstatic struct platform_driver atmel_flexcom_driver = {\n\t.probe\t= atmel_flexcom_probe,\n\t.driver\t= {\n\t\t.name\t\t= \"atmel_flexcom\",\n\t\t.pm\t\t= pm_ptr(&atmel_flexcom_pm_ops),\n\t\t.of_match_table\t= atmel_flexcom_of_match,\n\t},\n};\n\nmodule_platform_driver(atmel_flexcom_driver);\n\nMODULE_AUTHOR(\"Cyrille Pitchen <cyrille.pitchen@atmel.com>\");\nMODULE_DESCRIPTION(\"Atmel Flexcom MFD driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}