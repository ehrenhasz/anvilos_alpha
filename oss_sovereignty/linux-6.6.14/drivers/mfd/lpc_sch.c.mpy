{
  "module_name": "lpc_sch.c",
  "hash_id": "88f39d5a8fba7e0895d48669931fbee0c70e92319da3abf295fa5d94a5246438",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/lpc_sch.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/acpi.h>\n#include <linux/pci.h>\n#include <linux/mfd/core.h>\n\n#define SMBASE\t\t0x40\n#define SMBUS_IO_SIZE\t64\n\n#define GPIO_BASE\t0x44\n#define GPIO_IO_SIZE\t64\n#define GPIO_IO_SIZE_CENTERTON\t128\n\n#define WDTBASE\t\t0x84\n#define WDT_IO_SIZE\t64\n\nenum sch_chipsets {\n\tLPC_SCH = 0,\t\t \n\tLPC_ITC,\t\t \n\tLPC_CENTERTON,\t\t \n\tLPC_QUARK_X1000,\t \n};\n\nstruct lpc_sch_info {\n\tunsigned int io_size_smbus;\n\tunsigned int io_size_gpio;\n\tunsigned int io_size_wdt;\n};\n\nstatic struct lpc_sch_info sch_chipset_info[] = {\n\t[LPC_SCH] = {\n\t\t.io_size_smbus = SMBUS_IO_SIZE,\n\t\t.io_size_gpio = GPIO_IO_SIZE,\n\t},\n\t[LPC_ITC] = {\n\t\t.io_size_smbus = SMBUS_IO_SIZE,\n\t\t.io_size_gpio = GPIO_IO_SIZE,\n\t\t.io_size_wdt = WDT_IO_SIZE,\n\t},\n\t[LPC_CENTERTON] = {\n\t\t.io_size_smbus = SMBUS_IO_SIZE,\n\t\t.io_size_gpio = GPIO_IO_SIZE_CENTERTON,\n\t\t.io_size_wdt = WDT_IO_SIZE,\n\t},\n\t[LPC_QUARK_X1000] = {\n\t\t.io_size_gpio = GPIO_IO_SIZE,\n\t\t.io_size_wdt = WDT_IO_SIZE,\n\t},\n};\n\nstatic const struct pci_device_id lpc_sch_ids[] = {\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_SCH_LPC), LPC_SCH },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_ITC_LPC), LPC_ITC },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_CENTERTON_ILB), LPC_CENTERTON },\n\t{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_QUARK_X1000_ILB), LPC_QUARK_X1000 },\n\t{ 0, }\n};\nMODULE_DEVICE_TABLE(pci, lpc_sch_ids);\n\n#define LPC_NO_RESOURCE\t\t1\n#define LPC_SKIP_RESOURCE\t2\n\nstatic int lpc_sch_get_io(struct pci_dev *pdev, int where, const char *name,\n\t\t\t  struct resource *res, int size)\n{\n\tunsigned int base_addr_cfg;\n\tunsigned short base_addr;\n\n\tif (size == 0)\n\t\treturn LPC_NO_RESOURCE;\n\n\tpci_read_config_dword(pdev, where, &base_addr_cfg);\n\tbase_addr = 0;\n\tif (!(base_addr_cfg & (1 << 31)))\n\t\tdev_warn(&pdev->dev, \"Decode of the %s I/O range disabled\\n\",\n\t\t\t name);\n\telse\n\t\tbase_addr = (unsigned short)base_addr_cfg;\n\n\tif (base_addr == 0) {\n\t\tdev_warn(&pdev->dev, \"I/O space for %s uninitialized\\n\", name);\n\t\treturn LPC_SKIP_RESOURCE;\n\t}\n\n\tres->start = base_addr;\n\tres->end = base_addr + size - 1;\n\tres->flags = IORESOURCE_IO;\n\n\treturn 0;\n}\n\nstatic int lpc_sch_populate_cell(struct pci_dev *pdev, int where,\n\t\t\t\t const char *name, int size, int id,\n\t\t\t\t struct mfd_cell *cell)\n{\n\tstruct resource *res;\n\tint ret;\n\n\tres = devm_kzalloc(&pdev->dev, sizeof(*res), GFP_KERNEL);\n\tif (!res)\n\t\treturn -ENOMEM;\n\n\tret = lpc_sch_get_io(pdev, where, name, res, size);\n\tif (ret)\n\t\treturn ret;\n\n\tmemset(cell, 0, sizeof(*cell));\n\n\tcell->name = name;\n\tcell->resources = res;\n\tcell->num_resources = 1;\n\tcell->ignore_resource_conflicts = true;\n\tcell->id = id;\n\n\treturn 0;\n}\n\nstatic int lpc_sch_probe(struct pci_dev *dev, const struct pci_device_id *id)\n{\n\tstruct mfd_cell lpc_sch_cells[3];\n\tstruct lpc_sch_info *info = &sch_chipset_info[id->driver_data];\n\tunsigned int cells = 0;\n\tint ret;\n\n\tret = lpc_sch_populate_cell(dev, SMBASE, \"isch_smbus\",\n\t\t\t\t    info->io_size_smbus,\n\t\t\t\t    id->device, &lpc_sch_cells[cells]);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret == 0)\n\t\tcells++;\n\n\tret = lpc_sch_populate_cell(dev, GPIO_BASE, \"sch_gpio\",\n\t\t\t\t    info->io_size_gpio,\n\t\t\t\t    id->device, &lpc_sch_cells[cells]);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret == 0)\n\t\tcells++;\n\n\tret = lpc_sch_populate_cell(dev, WDTBASE, \"ie6xx_wdt\",\n\t\t\t\t    info->io_size_wdt,\n\t\t\t\t    id->device, &lpc_sch_cells[cells]);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret == 0)\n\t\tcells++;\n\n\tif (cells == 0) {\n\t\tdev_err(&dev->dev, \"All decode registers disabled.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn mfd_add_devices(&dev->dev, 0, lpc_sch_cells, cells, NULL, 0, NULL);\n}\n\nstatic void lpc_sch_remove(struct pci_dev *dev)\n{\n\tmfd_remove_devices(&dev->dev);\n}\n\nstatic struct pci_driver lpc_sch_driver = {\n\t.name\t\t= \"lpc_sch\",\n\t.id_table\t= lpc_sch_ids,\n\t.probe\t\t= lpc_sch_probe,\n\t.remove\t\t= lpc_sch_remove,\n};\n\nmodule_pci_driver(lpc_sch_driver);\n\nMODULE_AUTHOR(\"Denis Turischev <denis@compulab.co.il>\");\nMODULE_DESCRIPTION(\"LPC interface for Intel Poulsbo SCH\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}