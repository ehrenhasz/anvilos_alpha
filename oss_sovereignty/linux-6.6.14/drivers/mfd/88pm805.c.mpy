{
  "module_name": "88pm805.c",
  "hash_id": "a3309875416be9374a2ee56ddf954215768018c399df4eea658c335a0abd7752",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/88pm805.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/irq.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/88pm80x.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n\nstatic const struct i2c_device_id pm80x_id_table[] = {\n\t{\"88PM805\", 0},\n\t{}  \n};\nMODULE_DEVICE_TABLE(i2c, pm80x_id_table);\n\n \nenum {\n\tPM805_IRQ_LDO_OFF,\t \n\tPM805_IRQ_SRC_DPLL_LOCK,\t \n\tPM805_IRQ_CLIP_FAULT,\n\tPM805_IRQ_MIC_CONFLICT,\n\tPM805_IRQ_HP2_SHRT,\n\tPM805_IRQ_HP1_SHRT,\t \n\tPM805_IRQ_FINE_PLL_FAULT,\n\tPM805_IRQ_RAW_PLL_FAULT,\n\tPM805_IRQ_VOLP_BTN_DET,\n\tPM805_IRQ_VOLM_BTN_DET,\n\tPM805_IRQ_SHRT_BTN_DET,\t \n\tPM805_IRQ_MIC_DET,\t \n\n\tPM805_MAX_IRQ,\n};\n\nstatic struct resource codec_resources[] = {\n\t \n\tDEFINE_RES_IRQ_NAMED(PM805_IRQ_MIC_DET, \"micin\"),\n\n\t \n\tDEFINE_RES_IRQ_NAMED(PM805_IRQ_HP1_SHRT, \"audio-short1\"),\n\n\t \n\tDEFINE_RES_IRQ_NAMED(PM805_IRQ_HP2_SHRT, \"audio-short2\"),\n};\n\nstatic const struct mfd_cell codec_devs[] = {\n\t{\n\t .name = \"88pm80x-codec\",\n\t .num_resources = ARRAY_SIZE(codec_resources),\n\t .resources = &codec_resources[0],\n\t .id = -1,\n\t },\n};\n\nstatic struct regmap_irq pm805_irqs[] = {\n\t \n\t[PM805_IRQ_LDO_OFF] = {\n\t\t.mask = PM805_INT1_HP1_SHRT,\n\t},\n\t[PM805_IRQ_SRC_DPLL_LOCK] = {\n\t\t.mask = PM805_INT1_HP2_SHRT,\n\t},\n\t[PM805_IRQ_CLIP_FAULT] = {\n\t\t.mask = PM805_INT1_MIC_CONFLICT,\n\t},\n\t[PM805_IRQ_MIC_CONFLICT] = {\n\t\t.mask = PM805_INT1_CLIP_FAULT,\n\t},\n\t[PM805_IRQ_HP2_SHRT] = {\n\t\t.mask = PM805_INT1_LDO_OFF,\n\t},\n\t[PM805_IRQ_HP1_SHRT] = {\n\t\t.mask = PM805_INT1_SRC_DPLL_LOCK,\n\t},\n\t \n\t[PM805_IRQ_FINE_PLL_FAULT] = {\n\t\t.reg_offset = 1,\n\t\t.mask = PM805_INT2_MIC_DET,\n\t},\n\t[PM805_IRQ_RAW_PLL_FAULT] = {\n\t\t.reg_offset = 1,\n\t\t.mask = PM805_INT2_SHRT_BTN_DET,\n\t},\n\t[PM805_IRQ_VOLP_BTN_DET] = {\n\t\t.reg_offset = 1,\n\t\t.mask = PM805_INT2_VOLM_BTN_DET,\n\t},\n\t[PM805_IRQ_VOLM_BTN_DET] = {\n\t\t.reg_offset = 1,\n\t\t.mask = PM805_INT2_VOLP_BTN_DET,\n\t},\n\t[PM805_IRQ_SHRT_BTN_DET] = {\n\t\t.reg_offset = 1,\n\t\t.mask = PM805_INT2_RAW_PLL_FAULT,\n\t},\n\t[PM805_IRQ_MIC_DET] = {\n\t\t.reg_offset = 1,\n\t\t.mask = PM805_INT2_FINE_PLL_FAULT,\n\t},\n};\n\nstatic int device_irq_init_805(struct pm80x_chip *chip)\n{\n\tstruct regmap *map = chip->regmap;\n\tunsigned long flags = IRQF_ONESHOT;\n\tint data, mask, ret = -EINVAL;\n\n\tif (!map || !chip->irq) {\n\t\tdev_err(chip->dev, \"incorrect parameters\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tmask =\n\t    PM805_STATUS0_INT_CLEAR | PM805_STATUS0_INV_INT |\n\t    PM800_STATUS0_INT_MASK;\n\n\tdata = PM805_STATUS0_INT_CLEAR;\n\tret = regmap_update_bits(map, PM805_INT_STATUS0, mask, data);\n\t \n\tusleep_range(1000, 3000);\n\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret =\n\t    regmap_add_irq_chip(chip->regmap, chip->irq, flags, -1,\n\t\t\t\tchip->regmap_irq_chip, &chip->irq_data);\n\nout:\n\treturn ret;\n}\n\nstatic void device_irq_exit_805(struct pm80x_chip *chip)\n{\n\tregmap_del_irq_chip(chip->irq, chip->irq_data);\n}\n\nstatic struct regmap_irq_chip pm805_irq_chip = {\n\t.name = \"88pm805\",\n\t.irqs = pm805_irqs,\n\t.num_irqs = ARRAY_SIZE(pm805_irqs),\n\n\t.num_regs = 2,\n\t.status_base = PM805_INT_STATUS1,\n\t.mask_base = PM805_INT_MASK1,\n\t.ack_base = PM805_INT_STATUS1,\n};\n\nstatic int device_805_init(struct pm80x_chip *chip)\n{\n\tint ret = 0;\n\tstruct regmap *map = chip->regmap;\n\n\tif (!map) {\n\t\tdev_err(chip->dev, \"regmap is invalid\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tchip->regmap_irq_chip = &pm805_irq_chip;\n\n\tret = device_irq_init_805(chip);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"Failed to init pm805 irq!\\n\");\n\t\tgoto out_irq_init;\n\t}\n\n\tret = mfd_add_devices(chip->dev, 0, &codec_devs[0],\n\t\t\t      ARRAY_SIZE(codec_devs), &codec_resources[0], 0,\n\t\t\t      NULL);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"Failed to add codec subdev\\n\");\n\t\tgoto out_codec;\n\t} else\n\t\tdev_info(chip->dev, \"[%s]:Added mfd codec_devs\\n\", __func__);\n\n\treturn 0;\n\nout_codec:\n\tdevice_irq_exit_805(chip);\nout_irq_init:\n\treturn ret;\n}\n\nstatic int pm805_probe(struct i2c_client *client)\n{\n\tint ret = 0;\n\tstruct pm80x_chip *chip;\n\tstruct pm80x_platform_data *pdata = dev_get_platdata(&client->dev);\n\n\tret = pm80x_init(client);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"pm805_init fail!\\n\");\n\t\tgoto out_init;\n\t}\n\n\tchip = i2c_get_clientdata(client);\n\n\tret = device_805_init(chip);\n\tif (ret) {\n\t\tdev_err(chip->dev, \"Failed to initialize 88pm805 devices\\n\");\n\t\tgoto err_805_init;\n\t}\n\n\tif (pdata && pdata->plat_config)\n\t\tpdata->plat_config(chip, pdata);\n\nerr_805_init:\n\tpm80x_deinit();\nout_init:\n\treturn ret;\n}\n\nstatic void pm805_remove(struct i2c_client *client)\n{\n\tstruct pm80x_chip *chip = i2c_get_clientdata(client);\n\n\tmfd_remove_devices(chip->dev);\n\tdevice_irq_exit_805(chip);\n\n\tpm80x_deinit();\n}\n\nstatic struct i2c_driver pm805_driver = {\n\t.driver = {\n\t\t.name = \"88PM805\",\n\t\t.pm = pm_sleep_ptr(&pm80x_pm_ops),\n\t\t},\n\t.probe = pm805_probe,\n\t.remove = pm805_remove,\n\t.id_table = pm80x_id_table,\n};\n\nstatic int __init pm805_i2c_init(void)\n{\n\treturn i2c_add_driver(&pm805_driver);\n}\nsubsys_initcall(pm805_i2c_init);\n\nstatic void __exit pm805_i2c_exit(void)\n{\n\ti2c_del_driver(&pm805_driver);\n}\nmodule_exit(pm805_i2c_exit);\n\nMODULE_DESCRIPTION(\"PMIC Driver for Marvell 88PM805\");\nMODULE_AUTHOR(\"Qiao Zhou <zhouqiao@marvell.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}