{
  "module_name": "gateworks-gsc.c",
  "hash_id": "388fbdb3ecf8a3ddc5e7e04104171f645818d38016e506665501997a2cb7bd7d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/gateworks-gsc.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/mfd/gsc.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n#include <asm/unaligned.h>\n\n \n#define I2C_RETRIES\t3\n\nint gsc_write(void *context, unsigned int reg, unsigned int val)\n{\n\tstruct i2c_client *client = context;\n\tint retry, ret;\n\n\tfor (retry = 0; retry < I2C_RETRIES; retry++) {\n\t\tret = i2c_smbus_write_byte_data(client, reg, val);\n\t\t \n\t\tif (ret != -EAGAIN && ret != -EIO)\n\t\t\tbreak;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(gsc_write);\n\nint gsc_read(void *context, unsigned int reg, unsigned int *val)\n{\n\tstruct i2c_client *client = context;\n\tint retry, ret;\n\n\tfor (retry = 0; retry < I2C_RETRIES; retry++) {\n\t\tret = i2c_smbus_read_byte_data(client, reg);\n\t\t \n\t\tif (ret != -EAGAIN && ret != -EIO)\n\t\t\tbreak;\n\t}\n\t*val = ret & 0xff;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(gsc_read);\n\n \nstatic int gsc_powerdown(struct gsc_dev *gsc, unsigned long secs)\n{\n\tint ret;\n\tunsigned char regs[4];\n\n\tdev_info(&gsc->i2c->dev, \"GSC powerdown for %ld seconds\\n\",\n\t\t secs);\n\n\tput_unaligned_le32(secs, regs);\n\tret = regmap_bulk_write(gsc->regmap, GSC_TIME_ADD, regs, 4);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_update_bits(gsc->regmap, GSC_CTRL_1,\n\t\t\t\t BIT(GSC_CTRL_1_SLEEP_ADD),\n\t\t\t\t BIT(GSC_CTRL_1_SLEEP_ADD));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_update_bits(gsc->regmap, GSC_CTRL_1,\n\t\t\t\t BIT(GSC_CTRL_1_SLEEP_ACTIVATE) |\n\t\t\t\t BIT(GSC_CTRL_1_SLEEP_ENABLE),\n\t\t\t\t BIT(GSC_CTRL_1_SLEEP_ACTIVATE) |\n\t\t\t\t BIT(GSC_CTRL_1_SLEEP_ENABLE));\n\n\n\treturn ret;\n}\n\nstatic ssize_t gsc_show(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct gsc_dev *gsc = dev_get_drvdata(dev);\n\tconst char *name = attr->attr.name;\n\tint rz = 0;\n\n\tif (strcasecmp(name, \"fw_version\") == 0)\n\t\trz = sprintf(buf, \"%d\\n\", gsc->fwver);\n\telse if (strcasecmp(name, \"fw_crc\") == 0)\n\t\trz = sprintf(buf, \"0x%04x\\n\", gsc->fwcrc);\n\telse\n\t\tdev_err(dev, \"invalid command: '%s'\\n\", name);\n\n\treturn rz;\n}\n\nstatic ssize_t gsc_store(struct device *dev, struct device_attribute *attr,\n\t\t\t const char *buf, size_t count)\n{\n\tstruct gsc_dev *gsc = dev_get_drvdata(dev);\n\tconst char *name = attr->attr.name;\n\tlong value;\n\n\tif (strcasecmp(name, \"powerdown\") == 0) {\n\t\tif (kstrtol(buf, 0, &value) == 0)\n\t\t\tgsc_powerdown(gsc, value);\n\t} else {\n\t\tdev_err(dev, \"invalid command: '%s\\n\", name);\n\t}\n\n\treturn count;\n}\n\nstatic struct device_attribute attr_fwver =\n\t__ATTR(fw_version, 0440, gsc_show, NULL);\nstatic struct device_attribute attr_fwcrc =\n\t__ATTR(fw_crc, 0440, gsc_show, NULL);\nstatic struct device_attribute attr_pwrdown =\n\t__ATTR(powerdown, 0220, NULL, gsc_store);\n\nstatic struct attribute *gsc_attrs[] = {\n\t&attr_fwver.attr,\n\t&attr_fwcrc.attr,\n\t&attr_pwrdown.attr,\n\tNULL,\n};\n\nstatic struct attribute_group attr_group = {\n\t.attrs = gsc_attrs,\n};\n\nstatic const struct of_device_id gsc_of_match[] = {\n\t{ .compatible = \"gw,gsc\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, gsc_of_match);\n\nstatic struct regmap_bus gsc_regmap_bus = {\n\t.reg_read = gsc_read,\n\t.reg_write = gsc_write,\n};\n\nstatic const struct regmap_config gsc_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.cache_type = REGCACHE_NONE,\n\t.max_register = GSC_WP,\n};\n\nstatic const struct regmap_irq gsc_irqs[] = {\n\tREGMAP_IRQ_REG(GSC_IRQ_PB, 0, BIT(GSC_IRQ_PB)),\n\tREGMAP_IRQ_REG(GSC_IRQ_KEY_ERASED, 0, BIT(GSC_IRQ_KEY_ERASED)),\n\tREGMAP_IRQ_REG(GSC_IRQ_EEPROM_WP, 0, BIT(GSC_IRQ_EEPROM_WP)),\n\tREGMAP_IRQ_REG(GSC_IRQ_RESV, 0, BIT(GSC_IRQ_RESV)),\n\tREGMAP_IRQ_REG(GSC_IRQ_GPIO, 0, BIT(GSC_IRQ_GPIO)),\n\tREGMAP_IRQ_REG(GSC_IRQ_TAMPER, 0, BIT(GSC_IRQ_TAMPER)),\n\tREGMAP_IRQ_REG(GSC_IRQ_WDT_TIMEOUT, 0, BIT(GSC_IRQ_WDT_TIMEOUT)),\n\tREGMAP_IRQ_REG(GSC_IRQ_SWITCH_HOLD, 0, BIT(GSC_IRQ_SWITCH_HOLD)),\n};\n\nstatic const struct regmap_irq_chip gsc_irq_chip = {\n\t.name = \"gateworks-gsc\",\n\t.irqs = gsc_irqs,\n\t.num_irqs = ARRAY_SIZE(gsc_irqs),\n\t.num_regs = 1,\n\t.status_base = GSC_IRQ_STATUS,\n\t.unmask_base = GSC_IRQ_ENABLE,\n\t.ack_base = GSC_IRQ_STATUS,\n\t.ack_invert = true,\n};\n\nstatic int gsc_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct gsc_dev *gsc;\n\tstruct regmap_irq_chip_data *irq_data;\n\tint ret;\n\tunsigned int reg;\n\n\tgsc = devm_kzalloc(dev, sizeof(*gsc), GFP_KERNEL);\n\tif (!gsc)\n\t\treturn -ENOMEM;\n\n\tgsc->dev = &client->dev;\n\tgsc->i2c = client;\n\ti2c_set_clientdata(client, gsc);\n\n\tgsc->regmap = devm_regmap_init(dev, &gsc_regmap_bus, client,\n\t\t\t\t       &gsc_regmap_config);\n\tif (IS_ERR(gsc->regmap))\n\t\treturn PTR_ERR(gsc->regmap);\n\n\tif (regmap_read(gsc->regmap, GSC_FW_VER, &reg))\n\t\treturn -EIO;\n\tgsc->fwver = reg;\n\n\tregmap_read(gsc->regmap, GSC_FW_CRC, &reg);\n\tgsc->fwcrc = reg;\n\tregmap_read(gsc->regmap, GSC_FW_CRC + 1, &reg);\n\tgsc->fwcrc |= reg << 8;\n\n\tgsc->i2c_hwmon = devm_i2c_new_dummy_device(dev, client->adapter,\n\t\t\t\t\t\t   GSC_HWMON);\n\tif (IS_ERR(gsc->i2c_hwmon)) {\n\t\tdev_err(dev, \"Failed to allocate I2C device for HWMON\\n\");\n\t\treturn PTR_ERR(gsc->i2c_hwmon);\n\t}\n\n\tret = devm_regmap_add_irq_chip(dev, gsc->regmap, client->irq,\n\t\t\t\t       IRQF_ONESHOT | IRQF_SHARED |\n\t\t\t\t       IRQF_TRIGGER_LOW, 0,\n\t\t\t\t       &gsc_irq_chip, &irq_data);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_info(dev, \"Gateworks System Controller v%d: fw 0x%04x\\n\",\n\t\t gsc->fwver, gsc->fwcrc);\n\n\tret = sysfs_create_group(&dev->kobj, &attr_group);\n\tif (ret)\n\t\tdev_err(dev, \"failed to create sysfs attrs\\n\");\n\n\tret = devm_of_platform_populate(dev);\n\tif (ret) {\n\t\tsysfs_remove_group(&dev->kobj, &attr_group);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void gsc_remove(struct i2c_client *client)\n{\n\tsysfs_remove_group(&client->dev.kobj, &attr_group);\n}\n\nstatic struct i2c_driver gsc_driver = {\n\t.driver = {\n\t\t.name\t= \"gateworks-gsc\",\n\t\t.of_match_table = gsc_of_match,\n\t},\n\t.probe\t\t= gsc_probe,\n\t.remove\t\t= gsc_remove,\n};\nmodule_i2c_driver(gsc_driver);\n\nMODULE_AUTHOR(\"Tim Harvey <tharvey@gateworks.com>\");\nMODULE_DESCRIPTION(\"I2C Core interface for GSC\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}