{
  "module_name": "mcp-core.c",
  "hash_id": "0e5b84f9395df3404a9be6fbfa696f104856e2ae6efc59a881e23451d474633e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/mcp-core.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/device.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/mfd/mcp.h>\n\n\n#define to_mcp(d)\t\tcontainer_of(d, struct mcp, attached_device)\n#define to_mcp_driver(d)\tcontainer_of(d, struct mcp_driver, drv)\n\nstatic int mcp_bus_match(struct device *dev, struct device_driver *drv)\n{\n\treturn 1;\n}\n\nstatic int mcp_bus_probe(struct device *dev)\n{\n\tstruct mcp *mcp = to_mcp(dev);\n\tstruct mcp_driver *drv = to_mcp_driver(dev->driver);\n\n\treturn drv->probe(mcp);\n}\n\nstatic void mcp_bus_remove(struct device *dev)\n{\n\tstruct mcp *mcp = to_mcp(dev);\n\tstruct mcp_driver *drv = to_mcp_driver(dev->driver);\n\n\tdrv->remove(mcp);\n}\n\nstatic struct bus_type mcp_bus_type = {\n\t.name\t\t= \"mcp\",\n\t.match\t\t= mcp_bus_match,\n\t.probe\t\t= mcp_bus_probe,\n\t.remove\t\t= mcp_bus_remove,\n};\n\n \nvoid mcp_set_telecom_divisor(struct mcp *mcp, unsigned int div)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mcp->lock, flags);\n\tmcp->ops->set_telecom_divisor(mcp, div);\n\tspin_unlock_irqrestore(&mcp->lock, flags);\n}\nEXPORT_SYMBOL(mcp_set_telecom_divisor);\n\n \nvoid mcp_set_audio_divisor(struct mcp *mcp, unsigned int div)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mcp->lock, flags);\n\tmcp->ops->set_audio_divisor(mcp, div);\n\tspin_unlock_irqrestore(&mcp->lock, flags);\n}\nEXPORT_SYMBOL(mcp_set_audio_divisor);\n\n \nvoid mcp_reg_write(struct mcp *mcp, unsigned int reg, unsigned int val)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mcp->lock, flags);\n\tmcp->ops->reg_write(mcp, reg, val);\n\tspin_unlock_irqrestore(&mcp->lock, flags);\n}\nEXPORT_SYMBOL(mcp_reg_write);\n\n \nunsigned int mcp_reg_read(struct mcp *mcp, unsigned int reg)\n{\n\tunsigned long flags;\n\tunsigned int val;\n\n\tspin_lock_irqsave(&mcp->lock, flags);\n\tval = mcp->ops->reg_read(mcp, reg);\n\tspin_unlock_irqrestore(&mcp->lock, flags);\n\n\treturn val;\n}\nEXPORT_SYMBOL(mcp_reg_read);\n\n \nvoid mcp_enable(struct mcp *mcp)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mcp->lock, flags);\n\tif (mcp->use_count++ == 0)\n\t\tmcp->ops->enable(mcp);\n\tspin_unlock_irqrestore(&mcp->lock, flags);\n}\nEXPORT_SYMBOL(mcp_enable);\n\n \nvoid mcp_disable(struct mcp *mcp)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mcp->lock, flags);\n\tif (--mcp->use_count == 0)\n\t\tmcp->ops->disable(mcp);\n\tspin_unlock_irqrestore(&mcp->lock, flags);\n}\nEXPORT_SYMBOL(mcp_disable);\n\nstatic void mcp_release(struct device *dev)\n{\n\tstruct mcp *mcp = container_of(dev, struct mcp, attached_device);\n\n\tkfree(mcp);\n}\n\nstruct mcp *mcp_host_alloc(struct device *parent, size_t size)\n{\n\tstruct mcp *mcp;\n\n\tmcp = kzalloc(sizeof(struct mcp) + size, GFP_KERNEL);\n\tif (mcp) {\n\t\tspin_lock_init(&mcp->lock);\n\t\tdevice_initialize(&mcp->attached_device);\n\t\tmcp->attached_device.parent = parent;\n\t\tmcp->attached_device.bus = &mcp_bus_type;\n\t\tmcp->attached_device.dma_mask = parent->dma_mask;\n\t\tmcp->attached_device.release = mcp_release;\n\t}\n\treturn mcp;\n}\nEXPORT_SYMBOL(mcp_host_alloc);\n\nint mcp_host_add(struct mcp *mcp, void *pdata)\n{\n\tmcp->attached_device.platform_data = pdata;\n\tdev_set_name(&mcp->attached_device, \"mcp0\");\n\treturn device_add(&mcp->attached_device);\n}\nEXPORT_SYMBOL(mcp_host_add);\n\nvoid mcp_host_del(struct mcp *mcp)\n{\n\tdevice_del(&mcp->attached_device);\n}\nEXPORT_SYMBOL(mcp_host_del);\n\nvoid mcp_host_free(struct mcp *mcp)\n{\n\tput_device(&mcp->attached_device);\n}\nEXPORT_SYMBOL(mcp_host_free);\n\nint mcp_driver_register(struct mcp_driver *mcpdrv)\n{\n\tmcpdrv->drv.bus = &mcp_bus_type;\n\treturn driver_register(&mcpdrv->drv);\n}\nEXPORT_SYMBOL(mcp_driver_register);\n\nvoid mcp_driver_unregister(struct mcp_driver *mcpdrv)\n{\n\tdriver_unregister(&mcpdrv->drv);\n}\nEXPORT_SYMBOL(mcp_driver_unregister);\n\nstatic int __init mcp_init(void)\n{\n\treturn bus_register(&mcp_bus_type);\n}\n\nstatic void __exit mcp_exit(void)\n{\n\tbus_unregister(&mcp_bus_type);\n}\n\nmodule_init(mcp_init);\nmodule_exit(mcp_exit);\n\nMODULE_AUTHOR(\"Russell King <rmk@arm.linux.org.uk>\");\nMODULE_DESCRIPTION(\"Core multimedia communications port driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}