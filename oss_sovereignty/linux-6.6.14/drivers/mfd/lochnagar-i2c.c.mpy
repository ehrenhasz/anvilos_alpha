{
  "module_name": "lochnagar-i2c.c",
  "hash_id": "d41ef5cafb0b75597cc461d2108be6e11a9ad74cf441a07320285ea4f171076b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/lochnagar-i2c.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/lockdep.h>\n#include <linux/mfd/core.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/regmap.h>\n\n#include <linux/mfd/lochnagar.h>\n#include <linux/mfd/lochnagar1_regs.h>\n#include <linux/mfd/lochnagar2_regs.h>\n\n#define LOCHNAGAR_BOOT_RETRIES\t\t10\n#define LOCHNAGAR_BOOT_DELAY_MS\t\t350\n\n#define LOCHNAGAR_CONFIG_POLL_US\t10000\n\nstatic bool lochnagar1_readable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase LOCHNAGAR_SOFTWARE_RESET:\n\tcase LOCHNAGAR_FIRMWARE_ID1...LOCHNAGAR_FIRMWARE_ID2:\n\tcase LOCHNAGAR1_CDC_AIF1_SEL...LOCHNAGAR1_CDC_AIF3_SEL:\n\tcase LOCHNAGAR1_CDC_MCLK1_SEL...LOCHNAGAR1_CDC_MCLK2_SEL:\n\tcase LOCHNAGAR1_CDC_AIF_CTRL1...LOCHNAGAR1_CDC_AIF_CTRL2:\n\tcase LOCHNAGAR1_EXT_AIF_CTRL:\n\tcase LOCHNAGAR1_DSP_AIF1_SEL...LOCHNAGAR1_DSP_AIF2_SEL:\n\tcase LOCHNAGAR1_DSP_CLKIN_SEL:\n\tcase LOCHNAGAR1_DSP_AIF:\n\tcase LOCHNAGAR1_GF_AIF1...LOCHNAGAR1_GF_AIF2:\n\tcase LOCHNAGAR1_PSIA_AIF:\n\tcase LOCHNAGAR1_PSIA1_SEL...LOCHNAGAR1_PSIA2_SEL:\n\tcase LOCHNAGAR1_SPDIF_AIF_SEL:\n\tcase LOCHNAGAR1_GF_AIF3_SEL...LOCHNAGAR1_GF_AIF4_SEL:\n\tcase LOCHNAGAR1_GF_CLKOUT1_SEL:\n\tcase LOCHNAGAR1_GF_AIF1_SEL...LOCHNAGAR1_GF_AIF2_SEL:\n\tcase LOCHNAGAR1_GF_GPIO2...LOCHNAGAR1_GF_GPIO7:\n\tcase LOCHNAGAR1_RST:\n\tcase LOCHNAGAR1_LED1...LOCHNAGAR1_LED2:\n\tcase LOCHNAGAR1_I2C_CTRL:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config lochnagar1_i2c_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.reg_format_endian = REGMAP_ENDIAN_BIG,\n\t.val_format_endian = REGMAP_ENDIAN_BIG,\n\n\t.max_register = 0x50,\n\t.readable_reg = lochnagar1_readable_register,\n\n\t.use_single_read = true,\n\t.use_single_write = true,\n\n\t.cache_type = REGCACHE_RBTREE,\n};\n\nstatic const struct reg_sequence lochnagar1_patch[] = {\n\t{ 0x40, 0x0083 },\n\t{ 0x47, 0x0018 },\n\t{ 0x50, 0x0000 },\n};\n\nstatic bool lochnagar2_readable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase LOCHNAGAR_SOFTWARE_RESET:\n\tcase LOCHNAGAR_FIRMWARE_ID1...LOCHNAGAR_FIRMWARE_ID2:\n\tcase LOCHNAGAR2_CDC_AIF1_CTRL...LOCHNAGAR2_CDC_AIF3_CTRL:\n\tcase LOCHNAGAR2_DSP_AIF1_CTRL...LOCHNAGAR2_DSP_AIF2_CTRL:\n\tcase LOCHNAGAR2_PSIA1_CTRL...LOCHNAGAR2_PSIA2_CTRL:\n\tcase LOCHNAGAR2_GF_AIF3_CTRL...LOCHNAGAR2_GF_AIF4_CTRL:\n\tcase LOCHNAGAR2_GF_AIF1_CTRL...LOCHNAGAR2_GF_AIF2_CTRL:\n\tcase LOCHNAGAR2_SPDIF_AIF_CTRL:\n\tcase LOCHNAGAR2_USB_AIF1_CTRL...LOCHNAGAR2_USB_AIF2_CTRL:\n\tcase LOCHNAGAR2_ADAT_AIF_CTRL:\n\tcase LOCHNAGAR2_CDC_MCLK1_CTRL...LOCHNAGAR2_CDC_MCLK2_CTRL:\n\tcase LOCHNAGAR2_DSP_CLKIN_CTRL:\n\tcase LOCHNAGAR2_PSIA1_MCLK_CTRL...LOCHNAGAR2_PSIA2_MCLK_CTRL:\n\tcase LOCHNAGAR2_SPDIF_MCLK_CTRL:\n\tcase LOCHNAGAR2_GF_CLKOUT1_CTRL...LOCHNAGAR2_GF_CLKOUT2_CTRL:\n\tcase LOCHNAGAR2_ADAT_MCLK_CTRL:\n\tcase LOCHNAGAR2_SOUNDCARD_MCLK_CTRL:\n\tcase LOCHNAGAR2_GPIO_FPGA_GPIO1...LOCHNAGAR2_GPIO_FPGA_GPIO6:\n\tcase LOCHNAGAR2_GPIO_CDC_GPIO1...LOCHNAGAR2_GPIO_CDC_GPIO8:\n\tcase LOCHNAGAR2_GPIO_DSP_GPIO1...LOCHNAGAR2_GPIO_DSP_GPIO6:\n\tcase LOCHNAGAR2_GPIO_GF_GPIO2...LOCHNAGAR2_GPIO_GF_GPIO7:\n\tcase LOCHNAGAR2_GPIO_CDC_AIF1_BCLK...LOCHNAGAR2_GPIO_CDC_AIF3_TXDAT:\n\tcase LOCHNAGAR2_GPIO_DSP_AIF1_BCLK...LOCHNAGAR2_GPIO_DSP_AIF2_TXDAT:\n\tcase LOCHNAGAR2_GPIO_PSIA1_BCLK...LOCHNAGAR2_GPIO_PSIA2_TXDAT:\n\tcase LOCHNAGAR2_GPIO_GF_AIF3_BCLK...LOCHNAGAR2_GPIO_GF_AIF4_TXDAT:\n\tcase LOCHNAGAR2_GPIO_GF_AIF1_BCLK...LOCHNAGAR2_GPIO_GF_AIF2_TXDAT:\n\tcase LOCHNAGAR2_GPIO_DSP_UART1_RX...LOCHNAGAR2_GPIO_DSP_UART2_TX:\n\tcase LOCHNAGAR2_GPIO_GF_UART2_RX...LOCHNAGAR2_GPIO_GF_UART2_TX:\n\tcase LOCHNAGAR2_GPIO_USB_UART_RX:\n\tcase LOCHNAGAR2_GPIO_CDC_PDMCLK1...LOCHNAGAR2_GPIO_CDC_PDMDAT2:\n\tcase LOCHNAGAR2_GPIO_CDC_DMICCLK1...LOCHNAGAR2_GPIO_CDC_DMICDAT4:\n\tcase LOCHNAGAR2_GPIO_DSP_DMICCLK1...LOCHNAGAR2_GPIO_DSP_DMICDAT2:\n\tcase LOCHNAGAR2_GPIO_I2C2_SCL...LOCHNAGAR2_GPIO_I2C4_SDA:\n\tcase LOCHNAGAR2_GPIO_DSP_STANDBY:\n\tcase LOCHNAGAR2_GPIO_CDC_MCLK1...LOCHNAGAR2_GPIO_CDC_MCLK2:\n\tcase LOCHNAGAR2_GPIO_DSP_CLKIN:\n\tcase LOCHNAGAR2_GPIO_PSIA1_MCLK...LOCHNAGAR2_GPIO_PSIA2_MCLK:\n\tcase LOCHNAGAR2_GPIO_GF_GPIO1...LOCHNAGAR2_GPIO_GF_GPIO5:\n\tcase LOCHNAGAR2_GPIO_DSP_GPIO20:\n\tcase LOCHNAGAR2_GPIO_CHANNEL1...LOCHNAGAR2_GPIO_CHANNEL16:\n\tcase LOCHNAGAR2_MINICARD_RESETS:\n\tcase LOCHNAGAR2_ANALOGUE_PATH_CTRL1...LOCHNAGAR2_ANALOGUE_PATH_CTRL2:\n\tcase LOCHNAGAR2_COMMS_CTRL4:\n\tcase LOCHNAGAR2_SPDIF_CTRL:\n\tcase LOCHNAGAR2_IMON_CTRL1...LOCHNAGAR2_IMON_CTRL4:\n\tcase LOCHNAGAR2_IMON_DATA1...LOCHNAGAR2_IMON_DATA2:\n\tcase LOCHNAGAR2_POWER_CTRL:\n\tcase LOCHNAGAR2_MICVDD_CTRL1:\n\tcase LOCHNAGAR2_MICVDD_CTRL2:\n\tcase LOCHNAGAR2_VDDCORE_CDC_CTRL1:\n\tcase LOCHNAGAR2_VDDCORE_CDC_CTRL2:\n\tcase LOCHNAGAR2_SOUNDCARD_AIF_CTRL:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool lochnagar2_volatile_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase LOCHNAGAR2_GPIO_CHANNEL1...LOCHNAGAR2_GPIO_CHANNEL16:\n\tcase LOCHNAGAR2_ANALOGUE_PATH_CTRL1:\n\tcase LOCHNAGAR2_IMON_CTRL3...LOCHNAGAR2_IMON_CTRL4:\n\tcase LOCHNAGAR2_IMON_DATA1...LOCHNAGAR2_IMON_DATA2:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config lochnagar2_i2c_regmap = {\n\t.reg_bits = 16,\n\t.val_bits = 16,\n\t.reg_format_endian = REGMAP_ENDIAN_BIG,\n\t.val_format_endian = REGMAP_ENDIAN_BIG,\n\n\t.max_register = 0x1F1F,\n\t.readable_reg = lochnagar2_readable_register,\n\t.volatile_reg = lochnagar2_volatile_register,\n\n\t.cache_type = REGCACHE_RBTREE,\n};\n\nstatic const struct reg_sequence lochnagar2_patch[] = {\n\t{ 0x00EE, 0x0000 },\n};\n\nstruct lochnagar_config {\n\tint id;\n\tconst char * const name;\n\tenum lochnagar_type type;\n\tconst struct regmap_config *regmap;\n\tconst struct reg_sequence *patch;\n\tint npatch;\n};\n\nstatic struct lochnagar_config lochnagar_configs[] = {\n\t{\n\t\t.id = 0x50,\n\t\t.name = \"lochnagar1\",\n\t\t.type = LOCHNAGAR1,\n\t\t.regmap = &lochnagar1_i2c_regmap,\n\t\t.patch = lochnagar1_patch,\n\t\t.npatch = ARRAY_SIZE(lochnagar1_patch),\n\t},\n\t{\n\t\t.id = 0xCB58,\n\t\t.name = \"lochnagar2\",\n\t\t.type = LOCHNAGAR2,\n\t\t.regmap = &lochnagar2_i2c_regmap,\n\t\t.patch = lochnagar2_patch,\n\t\t.npatch = ARRAY_SIZE(lochnagar2_patch),\n\t},\n};\n\nstatic const struct of_device_id lochnagar_of_match[] = {\n\t{ .compatible = \"cirrus,lochnagar1\", .data = &lochnagar_configs[0] },\n\t{ .compatible = \"cirrus,lochnagar2\", .data = &lochnagar_configs[1] },\n\t{},\n};\n\nstatic int lochnagar_wait_for_boot(struct regmap *regmap, unsigned int *id)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < LOCHNAGAR_BOOT_RETRIES; ++i) {\n\t\tmsleep(LOCHNAGAR_BOOT_DELAY_MS);\n\n\t\t \n\t\tret = regmap_read(regmap, LOCHNAGAR_SOFTWARE_RESET, id);\n\t\tif (!ret)\n\t\t\treturn ret;\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\n \nint lochnagar_update_config(struct lochnagar *lochnagar)\n{\n\tstruct regmap *regmap = lochnagar->regmap;\n\tunsigned int done = LOCHNAGAR2_ANALOGUE_PATH_UPDATE_STS_MASK;\n\tint timeout_ms = LOCHNAGAR_BOOT_DELAY_MS * LOCHNAGAR_BOOT_RETRIES;\n\tunsigned int val = 0;\n\tint ret;\n\n\tlockdep_assert_held(&lochnagar->analogue_config_lock);\n\n\tif (lochnagar->type != LOCHNAGAR2)\n\t\treturn 0;\n\n\t \n\tret = regmap_write(regmap, LOCHNAGAR2_ANALOGUE_PATH_CTRL1, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_write(regmap, LOCHNAGAR2_ANALOGUE_PATH_CTRL1,\n\t\t\t   LOCHNAGAR2_ANALOGUE_PATH_UPDATE_MASK);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_read_poll_timeout(regmap,\n\t\t\t\t       LOCHNAGAR2_ANALOGUE_PATH_CTRL1, val,\n\t\t\t\t       (val & done), LOCHNAGAR_CONFIG_POLL_US,\n\t\t\t\t       timeout_ms * 1000);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(lochnagar_update_config);\n\nstatic int lochnagar_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct device *dev = &i2c->dev;\n\tconst struct lochnagar_config *config = NULL;\n\tconst struct of_device_id *of_id;\n\tstruct lochnagar *lochnagar;\n\tstruct gpio_desc *reset, *present;\n\tunsigned int val;\n\tunsigned int firmwareid;\n\tunsigned int devid, rev;\n\tint ret;\n\n\tlochnagar = devm_kzalloc(dev, sizeof(*lochnagar), GFP_KERNEL);\n\tif (!lochnagar)\n\t\treturn -ENOMEM;\n\n\tof_id = of_match_device(lochnagar_of_match, dev);\n\tif (!of_id)\n\t\treturn -EINVAL;\n\n\tconfig = of_id->data;\n\n\tlochnagar->dev = dev;\n\tmutex_init(&lochnagar->analogue_config_lock);\n\n\tdev_set_drvdata(dev, lochnagar);\n\n\treset = devm_gpiod_get(dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(reset)) {\n\t\tret = PTR_ERR(reset);\n\t\tdev_err(dev, \"Failed to get reset GPIO: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpresent = devm_gpiod_get_optional(dev, \"present\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(present)) {\n\t\tret = PTR_ERR(present);\n\t\tdev_err(dev, \"Failed to get present GPIO: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tmsleep(20);\n\n\t \n\tgpiod_set_value_cansleep(reset, 1);\n\n\t \n\tlochnagar->type = config->type;\n\n\tlochnagar->regmap = devm_regmap_init_i2c(i2c, config->regmap);\n\tif (IS_ERR(lochnagar->regmap)) {\n\t\tret = PTR_ERR(lochnagar->regmap);\n\t\tdev_err(dev, \"Failed to allocate register map: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = lochnagar_wait_for_boot(lochnagar->regmap, &val);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to read device ID: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdevid = val & LOCHNAGAR_DEVICE_ID_MASK;\n\trev = val & LOCHNAGAR_REV_ID_MASK;\n\n\tif (devid != config->id) {\n\t\tdev_err(dev,\n\t\t\t\"ID does not match %s (expected 0x%x got 0x%x)\\n\",\n\t\t\tconfig->name, config->id, devid);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tret = regmap_read(lochnagar->regmap, LOCHNAGAR_FIRMWARE_ID1, &val);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to read firmware id 1: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tfirmwareid = val;\n\n\tret = regmap_read(lochnagar->regmap, LOCHNAGAR_FIRMWARE_ID2, &val);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to read firmware id 2: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tfirmwareid |= (val << config->regmap->val_bits);\n\n\tdev_info(dev, \"Found %s (0x%x) revision %u firmware 0x%.6x\\n\",\n\t\t config->name, devid, rev + 1, firmwareid);\n\n\tret = regmap_register_patch(lochnagar->regmap, config->patch,\n\t\t\t\t    config->npatch);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to register patch: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = devm_of_platform_populate(dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to populate child nodes: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic struct i2c_driver lochnagar_i2c_driver = {\n\t.driver = {\n\t\t.name = \"lochnagar\",\n\t\t.of_match_table = lochnagar_of_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe = lochnagar_i2c_probe,\n};\n\nstatic int __init lochnagar_i2c_init(void)\n{\n\tint ret;\n\n\tret = i2c_add_driver(&lochnagar_i2c_driver);\n\tif (ret)\n\t\tpr_err(\"Failed to register Lochnagar driver: %d\\n\", ret);\n\n\treturn ret;\n}\nsubsys_initcall(lochnagar_i2c_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}