{
  "module_name": "ti-lmu.c",
  "hash_id": "b931d393062d04b9cc371675caeaf94b5ef66718a74a92999219585a59ebd655",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/ti-lmu.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/ti-lmu.h>\n#include <linux/mfd/ti-lmu-register.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n\nstruct ti_lmu_data {\n\tconst struct mfd_cell *cells;\n\tint num_cells;\n\tunsigned int max_register;\n};\n\nstatic int ti_lmu_enable_hw(struct ti_lmu *lmu, enum ti_lmu_id id)\n{\n\tif (lmu->en_gpio)\n\t\tgpiod_set_value(lmu->en_gpio, 1);\n\n\t \n\tusleep_range(1000, 1500);\n\n\t \n\tif (id == LM3631) {\n\t\treturn regmap_update_bits(lmu->regmap, LM3631_REG_DEVCTRL,\n\t\t\t\t\t  LM3631_LCD_EN_MASK,\n\t\t\t\t\t  LM3631_LCD_EN_MASK);\n\t}\n\n\treturn 0;\n}\n\nstatic void ti_lmu_disable_hw(void *data)\n{\n\tstruct ti_lmu *lmu = data;\n\tif (lmu->en_gpio)\n\t\tgpiod_set_value(lmu->en_gpio, 0);\n}\n\n#define LM363X_REGULATOR(_id)\t\t\t\\\n{\t\t\t\t\t\t\\\n\t.name          = \"lm363x-regulator\",\t\\\n\t.id            = _id,\t\t\t\\\n\t.of_compatible = \"ti,lm363x-regulator\",\t\\\n}\t\t\t\t\t\t\\\n\nstatic const struct mfd_cell lm3631_devices[] = {\n\tLM363X_REGULATOR(LM3631_BOOST),\n\tLM363X_REGULATOR(LM3631_LDO_CONT),\n\tLM363X_REGULATOR(LM3631_LDO_OREF),\n\tLM363X_REGULATOR(LM3631_LDO_POS),\n\tLM363X_REGULATOR(LM3631_LDO_NEG),\n\t{\n\t\t.name          = \"ti-lmu-backlight\",\n\t\t.id            = LM3631,\n\t\t.of_compatible = \"ti,lm3631-backlight\",\n\t},\n};\n\nstatic const struct mfd_cell lm3632_devices[] = {\n\tLM363X_REGULATOR(LM3632_BOOST),\n\tLM363X_REGULATOR(LM3632_LDO_POS),\n\tLM363X_REGULATOR(LM3632_LDO_NEG),\n\t{\n\t\t.name          = \"ti-lmu-backlight\",\n\t\t.id            = LM3632,\n\t\t.of_compatible = \"ti,lm3632-backlight\",\n\t},\n};\n\nstatic const struct mfd_cell lm3633_devices[] = {\n\t{\n\t\t.name          = \"ti-lmu-backlight\",\n\t\t.id            = LM3633,\n\t\t.of_compatible = \"ti,lm3633-backlight\",\n\t},\n\t{\n\t\t.name          = \"lm3633-leds\",\n\t\t.of_compatible = \"ti,lm3633-leds\",\n\t},\n\t \n\t{\n\t\t.name          = \"ti-lmu-fault-monitor\",\n\t\t.id            = LM3633,\n\t\t.of_compatible = \"ti,lm3633-fault-monitor\",\n\t},\n};\n\nstatic const struct mfd_cell lm3695_devices[] = {\n\t{\n\t\t.name          = \"ti-lmu-backlight\",\n\t\t.id            = LM3695,\n\t\t.of_compatible = \"ti,lm3695-backlight\",\n\t},\n};\n\nstatic const struct mfd_cell lm36274_devices[] = {\n\tLM363X_REGULATOR(LM36274_BOOST),\n\tLM363X_REGULATOR(LM36274_LDO_POS),\n\tLM363X_REGULATOR(LM36274_LDO_NEG),\n\t{\n\t\t.name          = \"lm36274-leds\",\n\t\t.id            = LM36274,\n\t\t.of_compatible = \"ti,lm36274-backlight\",\n\t},\n};\n\n#define TI_LMU_DATA(chip, max_reg)\t\t\\\nstatic const struct ti_lmu_data chip##_data =\t\\\n{\t\t\t\t\t\t\\\n\t.cells = chip##_devices,\t\t\\\n\t.num_cells = ARRAY_SIZE(chip##_devices),\\\n\t.max_register = max_reg,\t\t\\\n}\t\t\t\t\t\t\\\n\nTI_LMU_DATA(lm3631, LM3631_MAX_REG);\nTI_LMU_DATA(lm3632, LM3632_MAX_REG);\nTI_LMU_DATA(lm3633, LM3633_MAX_REG);\nTI_LMU_DATA(lm3695, LM3695_MAX_REG);\nTI_LMU_DATA(lm36274, LM36274_MAX_REG);\n\nstatic int ti_lmu_probe(struct i2c_client *cl)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(cl);\n\tstruct device *dev = &cl->dev;\n\tconst struct ti_lmu_data *data;\n\tstruct regmap_config regmap_cfg;\n\tstruct ti_lmu *lmu;\n\tint ret;\n\n\t \n\tdata = of_device_get_match_data(dev);\n\tif (!data)\n\t\treturn -ENODEV;\n\n\tlmu = devm_kzalloc(dev, sizeof(*lmu), GFP_KERNEL);\n\tif (!lmu)\n\t\treturn -ENOMEM;\n\n\tlmu->dev = &cl->dev;\n\n\t \n\tmemset(&regmap_cfg, 0, sizeof(struct regmap_config));\n\tregmap_cfg.reg_bits = 8;\n\tregmap_cfg.val_bits = 8;\n\tregmap_cfg.name = id->name;\n\tregmap_cfg.max_register = data->max_register;\n\n\tlmu->regmap = devm_regmap_init_i2c(cl, &regmap_cfg);\n\tif (IS_ERR(lmu->regmap))\n\t\treturn PTR_ERR(lmu->regmap);\n\n\t \n\tlmu->en_gpio = devm_gpiod_get_optional(dev, \"enable\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(lmu->en_gpio)) {\n\t\tret = PTR_ERR(lmu->en_gpio);\n\t\tdev_err(dev, \"Can not request enable GPIO: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = ti_lmu_enable_hw(lmu, id->driver_data);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(dev, ti_lmu_disable_hw, lmu);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tBLOCKING_INIT_NOTIFIER_HEAD(&lmu->notifier);\n\n\ti2c_set_clientdata(cl, lmu);\n\n\treturn devm_mfd_add_devices(lmu->dev, 0, data->cells,\n\t\t\t\t    data->num_cells, NULL, 0, NULL);\n}\n\nstatic const struct of_device_id ti_lmu_of_match[] = {\n\t{ .compatible = \"ti,lm3631\", .data = &lm3631_data },\n\t{ .compatible = \"ti,lm3632\", .data = &lm3632_data },\n\t{ .compatible = \"ti,lm3633\", .data = &lm3633_data },\n\t{ .compatible = \"ti,lm3695\", .data = &lm3695_data },\n\t{ .compatible = \"ti,lm36274\", .data = &lm36274_data },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ti_lmu_of_match);\n\nstatic const struct i2c_device_id ti_lmu_ids[] = {\n\t{ \"lm3631\", LM3631 },\n\t{ \"lm3632\", LM3632 },\n\t{ \"lm3633\", LM3633 },\n\t{ \"lm3695\", LM3695 },\n\t{ \"lm36274\", LM36274 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, ti_lmu_ids);\n\nstatic struct i2c_driver ti_lmu_driver = {\n\t.probe = ti_lmu_probe,\n\t.driver = {\n\t\t.name = \"ti-lmu\",\n\t\t.of_match_table = ti_lmu_of_match,\n\t},\n\t.id_table = ti_lmu_ids,\n};\n\nmodule_i2c_driver(ti_lmu_driver);\n\nMODULE_DESCRIPTION(\"TI LMU MFD Core Driver\");\nMODULE_AUTHOR(\"Milo Kim\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}