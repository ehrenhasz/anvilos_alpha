{
  "module_name": "da9052-i2c.c",
  "hash_id": "ee94000a575de04fa8cadb6858cd7fced26323818992ec1b71add49ef315580d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/da9052-i2c.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/input.h>\n#include <linux/mfd/core.h>\n#include <linux/i2c.h>\n#include <linux/err.h>\n#include <linux/of.h>\n\n#include <linux/mfd/da9052/da9052.h>\n#include <linux/mfd/da9052/reg.h>\n\n\n \nstatic inline bool i2c_safe_reg(unsigned char reg)\n{\n\tswitch (reg) {\n\tcase DA9052_STATUS_A_REG:\n\tcase DA9052_STATUS_B_REG:\n\tcase DA9052_STATUS_C_REG:\n\tcase DA9052_STATUS_D_REG:\n\tcase DA9052_ADC_RES_L_REG:\n\tcase DA9052_ADC_RES_H_REG:\n\tcase DA9052_VDD_RES_REG:\n\tcase DA9052_ICHG_AV_REG:\n\tcase DA9052_TBAT_RES_REG:\n\tcase DA9052_ADCIN4_RES_REG:\n\tcase DA9052_ADCIN5_RES_REG:\n\tcase DA9052_ADCIN6_RES_REG:\n\tcase DA9052_TJUNC_RES_REG:\n\tcase DA9052_TSI_X_MSB_REG:\n\tcase DA9052_TSI_Y_MSB_REG:\n\tcase DA9052_TSI_LSB_REG:\n\tcase DA9052_TSI_Z_MSB_REG:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n \nstatic int da9052_i2c_fix(struct da9052 *da9052, unsigned char reg)\n{\n\tint val;\n\n\tswitch (da9052->chip_id) {\n\tcase DA9052:\n\tcase DA9053_AA:\n\tcase DA9053_BA:\n\tcase DA9053_BB:\n\t\t \n\t\tif (!i2c_safe_reg(reg))\n\t\t\treturn regmap_read(da9052->regmap,\n\t\t\t\t\t   DA9052_PARK_REGISTER,\n\t\t\t\t\t   &val);\n\t\tbreak;\n\tcase DA9053_BC:\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int da9052_i2c_disable_multiwrite(struct da9052 *da9052)\n{\n\tint reg_val, ret;\n\n\tret = regmap_read(da9052->regmap, DA9052_CONTROL_B_REG, &reg_val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!(reg_val & DA9052_CONTROL_B_WRITEMODE)) {\n\t\treg_val |= DA9052_CONTROL_B_WRITEMODE;\n\t\tret = regmap_write(da9052->regmap, DA9052_CONTROL_B_REG,\n\t\t\t\t   reg_val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id da9052_i2c_id[] = {\n\t{\"da9052\", DA9052},\n\t{\"da9053-aa\", DA9053_AA},\n\t{\"da9053-ba\", DA9053_BA},\n\t{\"da9053-bb\", DA9053_BB},\n\t{\"da9053-bc\", DA9053_BC},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, da9052_i2c_id);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id dialog_dt_ids[] = {\n\t{ .compatible = \"dlg,da9052\", .data = &da9052_i2c_id[0] },\n\t{ .compatible = \"dlg,da9053-aa\", .data = &da9052_i2c_id[1] },\n\t{ .compatible = \"dlg,da9053-ba\", .data = &da9052_i2c_id[2] },\n\t{ .compatible = \"dlg,da9053-bb\", .data = &da9052_i2c_id[3] },\n\t{ .compatible = \"dlg,da9053-bc\", .data = &da9052_i2c_id[4] },\n\t{   }\n};\n#endif\n\nstatic int da9052_i2c_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct da9052 *da9052;\n\tint ret;\n\n\tda9052 = devm_kzalloc(&client->dev, sizeof(struct da9052), GFP_KERNEL);\n\tif (!da9052)\n\t\treturn -ENOMEM;\n\n\tda9052->dev = &client->dev;\n\tda9052->chip_irq = client->irq;\n\tda9052->fix_io = da9052_i2c_fix;\n\n\ti2c_set_clientdata(client, da9052);\n\n\tda9052->regmap = devm_regmap_init_i2c(client, &da9052_regmap_config);\n\tif (IS_ERR(da9052->regmap)) {\n\t\tret = PTR_ERR(da9052->regmap);\n\t\tdev_err(&client->dev, \"Failed to allocate register map: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tret = da9052_i2c_disable_multiwrite(da9052);\n\tif (ret < 0)\n\t\treturn ret;\n\n#ifdef CONFIG_OF\n\tif (!id)\n\t\tid = of_device_get_match_data(&client->dev);\n#endif\n\n\tif (!id) {\n\t\tret = -ENODEV;\n\t\tdev_err(&client->dev, \"id is null.\\n\");\n\t\treturn ret;\n\t}\n\n\treturn da9052_device_init(da9052, id->driver_data);\n}\n\nstatic void da9052_i2c_remove(struct i2c_client *client)\n{\n\tstruct da9052 *da9052 = i2c_get_clientdata(client);\n\n\tda9052_device_exit(da9052);\n}\n\nstatic struct i2c_driver da9052_i2c_driver = {\n\t.probe = da9052_i2c_probe,\n\t.remove = da9052_i2c_remove,\n\t.id_table = da9052_i2c_id,\n\t.driver = {\n\t\t.name = \"da9052\",\n#ifdef CONFIG_OF\n\t\t.of_match_table = dialog_dt_ids,\n#endif\n\t},\n};\n\nstatic int __init da9052_i2c_init(void)\n{\n\tint ret;\n\n\tret = i2c_add_driver(&da9052_i2c_driver);\n\tif (ret != 0) {\n\t\tpr_err(\"DA9052 I2C registration failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nsubsys_initcall(da9052_i2c_init);\n\nstatic void __exit da9052_i2c_exit(void)\n{\n\ti2c_del_driver(&da9052_i2c_driver);\n}\nmodule_exit(da9052_i2c_exit);\n\nMODULE_AUTHOR(\"David Dajun Chen <dchen@diasemi.com>\");\nMODULE_DESCRIPTION(\"I2C driver for Dialog DA9052 PMIC\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}