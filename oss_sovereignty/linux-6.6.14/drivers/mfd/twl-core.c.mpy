{
  "module_name": "twl-core.c",
  "hash_id": "259d0362a511ce4354a200f06f90b64d1d6a5ce700d906b16bf4aad7557b96dc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/twl-core.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/of_platform.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n\n#include <linux/regulator/machine.h>\n\n#include <linux/i2c.h>\n#include <linux/mfd/twl.h>\n\n \n#include <linux/mfd/twl4030-audio.h>\n\n#include \"twl-core.h\"\n\n \n\n#define DRIVER_NAME\t\t\t\"twl\"\n\n \n\n \n\n \n#define TWL4030_BASEADD_USB\t\t0x0000\n\n \n#define TWL4030_BASEADD_AUDIO_VOICE\t0x0000\n#define TWL4030_BASEADD_GPIO\t\t0x0098\n#define TWL4030_BASEADD_INTBR\t\t0x0085\n#define TWL4030_BASEADD_PIH\t\t0x0080\n#define TWL4030_BASEADD_TEST\t\t0x004C\n\n \n#define TWL4030_BASEADD_INTERRUPTS\t0x00B9\n#define TWL4030_BASEADD_LED\t\t0x00EE\n#define TWL4030_BASEADD_MADC\t\t0x0000\n#define TWL4030_BASEADD_MAIN_CHARGE\t0x0074\n#define TWL4030_BASEADD_PRECHARGE\t0x00AA\n#define TWL4030_BASEADD_PWM\t\t0x00F8\n#define TWL4030_BASEADD_KEYPAD\t\t0x00D2\n\n#define TWL5031_BASEADD_ACCESSORY\t0x0074  \n#define TWL5031_BASEADD_INTERRUPTS\t0x00B9  \n\n \n#define TWL4030_BASEADD_BACKUP\t\t0x0014\n#define TWL4030_BASEADD_INT\t\t0x002E\n#define TWL4030_BASEADD_PM_MASTER\t0x0036\n\n#define TWL4030_BASEADD_PM_RECEIVER\t0x005B\n#define TWL4030_DCDC_GLOBAL_CFG\t\t0x06\n#define SMARTREFLEX_ENABLE\t\tBIT(3)\n\n#define TWL4030_BASEADD_RTC\t\t0x001C\n#define TWL4030_BASEADD_SECURED_REG\t0x0000\n\n \n\n\n \n#define TWL6030_BASEADD_RTC\t\t0x0000\n#define TWL6030_BASEADD_SECURED_REG\t0x0017\n#define TWL6030_BASEADD_PM_MASTER\t0x001F\n#define TWL6030_BASEADD_PM_SLAVE_MISC\t0x0030  \n#define TWL6030_BASEADD_PM_MISC\t\t0x00E2\n#define TWL6030_BASEADD_PM_PUPD\t\t0x00F0\n\n \n#define TWL6030_BASEADD_USB\t\t0x0000\n#define TWL6030_BASEADD_GPADC_CTRL\t0x002E\n#define TWL6030_BASEADD_AUX\t\t0x0090\n#define TWL6030_BASEADD_PWM\t\t0x00BA\n#define TWL6030_BASEADD_GASGAUGE\t0x00C0\n#define TWL6030_BASEADD_PIH\t\t0x00D0\n#define TWL6032_BASEADD_CHARGER\t\t0x00DA\n#define TWL6030_BASEADD_CHARGER\t\t0x00E0\n#define TWL6030_BASEADD_LED\t\t0x00F4\n\n \n#define TWL6030_BASEADD_DIEID\t\t0x00C0\n\n \n#define TWL6030_BASEADD_AUDIO\t\t0x0000\n#define TWL6030_BASEADD_RSV\t\t0x0000\n#define TWL6030_BASEADD_ZERO\t\t0x0000\n\n \n#define R_CFG_BOOT\t\t\t0x05\n\n \n#define HFCLK_FREQ_19p2_MHZ\t\t(1 << 0)\n#define HFCLK_FREQ_26_MHZ\t\t(2 << 0)\n#define HFCLK_FREQ_38p4_MHZ\t\t(3 << 0)\n#define HIGH_PERF_SQ\t\t\t(1 << 3)\n#define CK32K_LOWPWR_EN\t\t\t(1 << 7)\n\n \n\n \nstruct twl_client {\n\tstruct i2c_client *client;\n\tstruct regmap *regmap;\n};\n\n \nstruct twl_mapping {\n\tunsigned char sid;\t \n\tunsigned char base;\t \n};\n\nstruct twl_private {\n\tbool ready;  \n\tu32 twl_idcode;  \n\tunsigned int twl_id;\n\n\tstruct twl_mapping *twl_map;\n\tstruct twl_client *twl_modules;\n};\n\nstatic struct twl_private *twl_priv;\n\nstatic struct twl_mapping twl4030_map[] = {\n\t \n\n\t \n\t{ 0, TWL4030_BASEADD_USB },\n\t{ 1, TWL4030_BASEADD_PIH },\n\t{ 2, TWL4030_BASEADD_MAIN_CHARGE },\n\t{ 3, TWL4030_BASEADD_PM_MASTER },\n\t{ 3, TWL4030_BASEADD_PM_RECEIVER },\n\n\t{ 3, TWL4030_BASEADD_RTC },\n\t{ 2, TWL4030_BASEADD_PWM },\n\t{ 2, TWL4030_BASEADD_LED },\n\t{ 3, TWL4030_BASEADD_SECURED_REG },\n\n\t \n\t{ 1, TWL4030_BASEADD_AUDIO_VOICE },\n\t{ 1, TWL4030_BASEADD_GPIO },\n\t{ 1, TWL4030_BASEADD_INTBR },\n\t{ 1, TWL4030_BASEADD_TEST },\n\t{ 2, TWL4030_BASEADD_KEYPAD },\n\n\t{ 2, TWL4030_BASEADD_MADC },\n\t{ 2, TWL4030_BASEADD_INTERRUPTS },\n\t{ 2, TWL4030_BASEADD_PRECHARGE },\n\t{ 3, TWL4030_BASEADD_BACKUP },\n\t{ 3, TWL4030_BASEADD_INT },\n\n\t{ 2, TWL5031_BASEADD_ACCESSORY },\n\t{ 2, TWL5031_BASEADD_INTERRUPTS },\n};\n\nstatic const struct reg_default twl4030_49_defaults[] = {\n\t \n\t{ 0x01, 0x00},  \n\t{ 0x02, 0x00},  \n\t \n\t{ 0x04, 0x00},  \n\t{ 0x05, 0x00},  \n\t{ 0x06, 0x00},  \n\t{ 0x07, 0x00},  \n\t{ 0x08, 0x00},  \n\t{ 0x09, 0x00},  \n\t{ 0x0a, 0x0f},  \n\t{ 0x0b, 0x0f},  \n\t{ 0x0c, 0x0f},  \n\t{ 0x0d, 0x0f},  \n\t{ 0x0e, 0x00},  \n\t{ 0x0f, 0x00},  \n\t{ 0x10, 0x3f},  \n\t{ 0x11, 0x3f},  \n\t{ 0x12, 0x3f},  \n\t{ 0x13, 0x3f},  \n\t{ 0x14, 0x25},  \n\t{ 0x15, 0x00},  \n\t{ 0x16, 0x00},  \n\t{ 0x17, 0x00},  \n\t{ 0x18, 0x00},  \n\t{ 0x19, 0x32},  \n\t{ 0x1a, 0x32},  \n\t{ 0x1b, 0x32},  \n\t{ 0x1c, 0x32},  \n\t{ 0x1d, 0x00},  \n\t{ 0x1e, 0x00},  \n\t{ 0x1f, 0x55},  \n\t{ 0x20, 0x00},  \n\t{ 0x21, 0x00},  \n\t{ 0x22, 0x00},  \n\t{ 0x23, 0x00},  \n\t{ 0x24, 0x00},  \n\t{ 0x25, 0x00},  \n\t{ 0x26, 0x00},  \n\t{ 0x27, 0x00},  \n\t{ 0x28, 0x00},  \n\t{ 0x29, 0x00},  \n\t{ 0x2a, 0x00},  \n\t{ 0x2b, 0x05},  \n\t{ 0x2c, 0x00},  \n\t{ 0x2d, 0x00},  \n\t{ 0x2e, 0x00},  \n\t{ 0x2f, 0x00},  \n\t{ 0x30, 0x13},  \n\t{ 0x31, 0x00},  \n\t{ 0x32, 0x00},  \n\t{ 0x33, 0x00},  \n\t{ 0x34, 0x00},  \n\t{ 0x35, 0x79},  \n\t{ 0x36, 0x11},  \n\t{ 0x37, 0x00},  \n\t{ 0x38, 0x00},  \n\t{ 0x39, 0x00},  \n\t{ 0x3a, 0x06},  \n\t{ 0x3b, 0x00},  \n\t{ 0x3c, 0x44},  \n\t{ 0x3d, 0x69},  \n\t{ 0x3e, 0x00},  \n\t{ 0x3f, 0x00},  \n\t \n\t{ 0x43, 0x00},  \n\t{ 0x44, 0x32},  \n\t{ 0x45, 0x00},  \n\t{ 0x46, 0x00},  \n\t{ 0x47, 0x00},  \n\t{ 0x48, 0x00},  \n\t{ 0x49, 0x00},  \n\t \n};\n\nstatic bool twl4030_49_nop_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase 0x00:\n\tcase 0x03:\n\tcase 0x40:\n\tcase 0x41:\n\tcase 0x42:\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nstatic const struct regmap_range twl4030_49_volatile_ranges[] = {\n\tregmap_reg_range(TWL4030_BASEADD_TEST, 0xff),\n};\n\nstatic const struct regmap_access_table twl4030_49_volatile_table = {\n\t.yes_ranges = twl4030_49_volatile_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(twl4030_49_volatile_ranges),\n};\n\nstatic const struct regmap_config twl4030_regmap_config[4] = {\n\t{\n\t\t \n\t\t.reg_bits = 8,\n\t\t.val_bits = 8,\n\t\t.max_register = 0xff,\n\t},\n\t{\n\t\t \n\t\t.reg_bits = 8,\n\t\t.val_bits = 8,\n\t\t.max_register = 0xff,\n\n\t\t.readable_reg = twl4030_49_nop_reg,\n\t\t.writeable_reg = twl4030_49_nop_reg,\n\n\t\t.volatile_table = &twl4030_49_volatile_table,\n\n\t\t.reg_defaults = twl4030_49_defaults,\n\t\t.num_reg_defaults = ARRAY_SIZE(twl4030_49_defaults),\n\t\t.cache_type = REGCACHE_RBTREE,\n\t},\n\t{\n\t\t \n\t\t.reg_bits = 8,\n\t\t.val_bits = 8,\n\t\t.max_register = 0xff,\n\t},\n\t{\n\t\t \n\t\t.reg_bits = 8,\n\t\t.val_bits = 8,\n\t\t.max_register = 0xff,\n\t},\n};\n\nstatic struct twl_mapping twl6030_map[] = {\n\t \n\n\t \n\t{ 1, TWL6030_BASEADD_USB },\n\t{ 1, TWL6030_BASEADD_PIH },\n\t{ 1, TWL6030_BASEADD_CHARGER },\n\t{ 0, TWL6030_BASEADD_PM_MASTER },\n\t{ 0, TWL6030_BASEADD_PM_SLAVE_MISC },\n\n\t{ 0, TWL6030_BASEADD_RTC },\n\t{ 1, TWL6030_BASEADD_PWM },\n\t{ 1, TWL6030_BASEADD_LED },\n\t{ 0, TWL6030_BASEADD_SECURED_REG },\n\n\t \n\t{ 0, TWL6030_BASEADD_ZERO },\n\t{ 1, TWL6030_BASEADD_ZERO },\n\t{ 2, TWL6030_BASEADD_ZERO },\n\t{ 1, TWL6030_BASEADD_GPADC_CTRL },\n\t{ 1, TWL6030_BASEADD_GASGAUGE },\n\n\t \n\t{ 1, TWL6032_BASEADD_CHARGER },\n};\n\nstatic const struct regmap_config twl6030_regmap_config[3] = {\n\t{\n\t\t \n\t\t.reg_bits = 8,\n\t\t.val_bits = 8,\n\t\t.max_register = 0xff,\n\t},\n\t{\n\t\t \n\t\t.reg_bits = 8,\n\t\t.val_bits = 8,\n\t\t.max_register = 0xff,\n\t},\n\t{\n\t\t \n\t\t.reg_bits = 8,\n\t\t.val_bits = 8,\n\t\t.max_register = 0xff,\n\t},\n};\n\n \n\nstatic inline int twl_get_num_slaves(void)\n{\n\tif (twl_class_is_4030())\n\t\treturn 4;  \n\telse\n\t\treturn 3;  \n}\n\nstatic inline int twl_get_last_module(void)\n{\n\tif (twl_class_is_4030())\n\t\treturn TWL4030_MODULE_LAST;\n\telse\n\t\treturn TWL6030_MODULE_LAST;\n}\n\n \n\nunsigned int twl_rev(void)\n{\n\treturn twl_priv ? twl_priv->twl_id : 0;\n}\nEXPORT_SYMBOL(twl_rev);\n\n \nstatic struct regmap *twl_get_regmap(u8 mod_no)\n{\n\tint sid;\n\tstruct twl_client *twl;\n\n\tif (unlikely(!twl_priv || !twl_priv->ready)) {\n\t\tpr_err(\"%s: not initialized\\n\", DRIVER_NAME);\n\t\treturn NULL;\n\t}\n\tif (unlikely(mod_no >= twl_get_last_module())) {\n\t\tpr_err(\"%s: invalid module number %d\\n\", DRIVER_NAME, mod_no);\n\t\treturn NULL;\n\t}\n\n\tsid = twl_priv->twl_map[mod_no].sid;\n\ttwl = &twl_priv->twl_modules[sid];\n\n\treturn twl->regmap;\n}\n\n \nint twl_i2c_write(u8 mod_no, u8 *value, u8 reg, unsigned num_bytes)\n{\n\tstruct regmap *regmap = twl_get_regmap(mod_no);\n\tint ret;\n\n\tif (!regmap)\n\t\treturn -EPERM;\n\n\tret = regmap_bulk_write(regmap, twl_priv->twl_map[mod_no].base + reg,\n\t\t\t\tvalue, num_bytes);\n\n\tif (ret)\n\t\tpr_err(\"%s: Write failed (mod %d, reg 0x%02x count %d)\\n\",\n\t\t       DRIVER_NAME, mod_no, reg, num_bytes);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(twl_i2c_write);\n\n \nint twl_i2c_read(u8 mod_no, u8 *value, u8 reg, unsigned num_bytes)\n{\n\tstruct regmap *regmap = twl_get_regmap(mod_no);\n\tint ret;\n\n\tif (!regmap)\n\t\treturn -EPERM;\n\n\tret = regmap_bulk_read(regmap, twl_priv->twl_map[mod_no].base + reg,\n\t\t\t       value, num_bytes);\n\n\tif (ret)\n\t\tpr_err(\"%s: Read failed (mod %d, reg 0x%02x count %d)\\n\",\n\t\t       DRIVER_NAME, mod_no, reg, num_bytes);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(twl_i2c_read);\n\n \nint twl_set_regcache_bypass(u8 mod_no, bool enable)\n{\n\tstruct regmap *regmap = twl_get_regmap(mod_no);\n\n\tif (!regmap)\n\t\treturn -EPERM;\n\n\tregcache_cache_bypass(regmap, enable);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(twl_set_regcache_bypass);\n\n \n\n \nstatic int twl_read_idcode_register(void)\n{\n\tint err;\n\n\terr = twl_i2c_write_u8(TWL4030_MODULE_INTBR, TWL_EEPROM_R_UNLOCK,\n\t\t\t\t\t\tREG_UNLOCK_TEST_REG);\n\tif (err) {\n\t\tpr_err(\"TWL4030 Unable to unlock IDCODE registers -%d\\n\", err);\n\t\tgoto fail;\n\t}\n\n\terr = twl_i2c_read(TWL4030_MODULE_INTBR, (u8 *)(&twl_priv->twl_idcode),\n\t\t\t\t\t\tREG_IDCODE_7_0, 4);\n\tif (err) {\n\t\tpr_err(\"TWL4030: unable to read IDCODE -%d\\n\", err);\n\t\tgoto fail;\n\t}\n\n\terr = twl_i2c_write_u8(TWL4030_MODULE_INTBR, 0x0, REG_UNLOCK_TEST_REG);\n\tif (err)\n\t\tpr_err(\"TWL4030 Unable to relock IDCODE registers -%d\\n\", err);\nfail:\n\treturn err;\n}\n\n \nint twl_get_type(void)\n{\n\treturn TWL_SIL_TYPE(twl_priv->twl_idcode);\n}\nEXPORT_SYMBOL_GPL(twl_get_type);\n\n \nint twl_get_version(void)\n{\n\treturn TWL_SIL_REV(twl_priv->twl_idcode);\n}\nEXPORT_SYMBOL_GPL(twl_get_version);\n\n \nint twl_get_hfclk_rate(void)\n{\n\tu8 ctrl;\n\tint rate;\n\n\ttwl_i2c_read_u8(TWL_MODULE_PM_MASTER, &ctrl, R_CFG_BOOT);\n\n\tswitch (ctrl & 0x3) {\n\tcase HFCLK_FREQ_19p2_MHZ:\n\t\trate = 19200000;\n\t\tbreak;\n\tcase HFCLK_FREQ_26_MHZ:\n\t\trate = 26000000;\n\t\tbreak;\n\tcase HFCLK_FREQ_38p4_MHZ:\n\t\trate = 38400000;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"TWL4030: HFCLK is not configured\\n\");\n\t\trate = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn rate;\n}\nEXPORT_SYMBOL_GPL(twl_get_hfclk_rate);\n\n \n\n \nstatic inline int protect_pm_master(void)\n{\n\tint e = 0;\n\n\te = twl_i2c_write_u8(TWL_MODULE_PM_MASTER, 0,\n\t\t\t     TWL4030_PM_MASTER_PROTECT_KEY);\n\treturn e;\n}\n\nstatic inline int unprotect_pm_master(void)\n{\n\tint e = 0;\n\n\te |= twl_i2c_write_u8(TWL_MODULE_PM_MASTER, TWL4030_PM_MASTER_KEY_CFG1,\n\t\t\t      TWL4030_PM_MASTER_PROTECT_KEY);\n\te |= twl_i2c_write_u8(TWL_MODULE_PM_MASTER, TWL4030_PM_MASTER_KEY_CFG2,\n\t\t\t      TWL4030_PM_MASTER_PROTECT_KEY);\n\n\treturn e;\n}\n\nstatic void clocks_init(struct device *dev)\n{\n\tint e = 0;\n\tstruct clk *osc;\n\tu32 rate;\n\tu8 ctrl = HFCLK_FREQ_26_MHZ;\n\n\tosc = clk_get(dev, \"fck\");\n\tif (IS_ERR(osc)) {\n\t\tprintk(KERN_WARNING \"Skipping twl internal clock init and \"\n\t\t\t\t\"using bootloader value (unknown osc rate)\\n\");\n\t\treturn;\n\t}\n\n\trate = clk_get_rate(osc);\n\tclk_put(osc);\n\n\tswitch (rate) {\n\tcase 19200000:\n\t\tctrl = HFCLK_FREQ_19p2_MHZ;\n\t\tbreak;\n\tcase 26000000:\n\t\tctrl = HFCLK_FREQ_26_MHZ;\n\t\tbreak;\n\tcase 38400000:\n\t\tctrl = HFCLK_FREQ_38p4_MHZ;\n\t\tbreak;\n\t}\n\n\tctrl |= HIGH_PERF_SQ;\n\n\te |= unprotect_pm_master();\n\t \n\te |= twl_i2c_write_u8(TWL_MODULE_PM_MASTER, ctrl, R_CFG_BOOT);\n\te |= protect_pm_master();\n\n\tif (e < 0)\n\t\tpr_err(\"%s: clock init err [%d]\\n\", DRIVER_NAME, e);\n}\n\n \n\n\nstatic void twl_remove(struct i2c_client *client)\n{\n\tunsigned i, num_slaves;\n\n\tif (twl_class_is_4030())\n\t\ttwl4030_exit_irq();\n\telse\n\t\ttwl6030_exit_irq();\n\n\tnum_slaves = twl_get_num_slaves();\n\tfor (i = 0; i < num_slaves; i++) {\n\t\tstruct twl_client\t*twl = &twl_priv->twl_modules[i];\n\n\t\tif (twl->client && twl->client != client)\n\t\t\ti2c_unregister_device(twl->client);\n\t\ttwl->client = NULL;\n\t}\n\ttwl_priv->ready = false;\n}\n\nstatic struct of_dev_auxdata twl_auxdata_lookup[] = {\n\tOF_DEV_AUXDATA(\"ti,twl4030-gpio\", 0, \"twl4030-gpio\", NULL),\n\t{   },\n};\n\n \nstatic int\ntwl_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct device_node\t\t*node = client->dev.of_node;\n\tstruct platform_device\t\t*pdev;\n\tconst struct regmap_config\t*twl_regmap_config;\n\tint\t\t\t\tirq_base = 0;\n\tint\t\t\t\tstatus;\n\tunsigned\t\t\ti, num_slaves;\n\n\tif (!node) {\n\t\tdev_err(&client->dev, \"no platform data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (twl_priv) {\n\t\tdev_dbg(&client->dev, \"only one instance of %s allowed\\n\",\n\t\t\tDRIVER_NAME);\n\t\treturn -EBUSY;\n\t}\n\n\tpdev = platform_device_alloc(DRIVER_NAME, -1);\n\tif (!pdev) {\n\t\tdev_err(&client->dev, \"can't alloc pdev\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tstatus = platform_device_add(pdev);\n\tif (status) {\n\t\tplatform_device_put(pdev);\n\t\treturn status;\n\t}\n\n\tif (i2c_check_functionality(client->adapter, I2C_FUNC_I2C) == 0) {\n\t\tdev_dbg(&client->dev, \"can't talk I2C?\\n\");\n\t\tstatus = -EIO;\n\t\tgoto free;\n\t}\n\n\ttwl_priv = devm_kzalloc(&client->dev, sizeof(struct twl_private),\n\t\t\t\tGFP_KERNEL);\n\tif (!twl_priv) {\n\t\tstatus = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\tif ((id->driver_data) & TWL6030_CLASS) {\n\t\ttwl_priv->twl_id = TWL6030_CLASS_ID;\n\t\ttwl_priv->twl_map = &twl6030_map[0];\n\t\ttwl_regmap_config = twl6030_regmap_config;\n\t} else {\n\t\ttwl_priv->twl_id = TWL4030_CLASS_ID;\n\t\ttwl_priv->twl_map = &twl4030_map[0];\n\t\ttwl_regmap_config = twl4030_regmap_config;\n\t}\n\n\tnum_slaves = twl_get_num_slaves();\n\ttwl_priv->twl_modules = devm_kcalloc(&client->dev,\n\t\t\t\t\t num_slaves,\n\t\t\t\t\t sizeof(struct twl_client),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!twl_priv->twl_modules) {\n\t\tstatus = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\tfor (i = 0; i < num_slaves; i++) {\n\t\tstruct twl_client *twl = &twl_priv->twl_modules[i];\n\n\t\tif (i == 0) {\n\t\t\ttwl->client = client;\n\t\t} else {\n\t\t\ttwl->client = i2c_new_dummy_device(client->adapter,\n\t\t\t\t\t\t    client->addr + i);\n\t\t\tif (IS_ERR(twl->client)) {\n\t\t\t\tdev_err(&client->dev,\n\t\t\t\t\t\"can't attach client %d\\n\", i);\n\t\t\t\tstatus = PTR_ERR(twl->client);\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\n\t\ttwl->regmap = devm_regmap_init_i2c(twl->client,\n\t\t\t\t\t\t   &twl_regmap_config[i]);\n\t\tif (IS_ERR(twl->regmap)) {\n\t\t\tstatus = PTR_ERR(twl->regmap);\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Failed to allocate regmap %d, err: %d\\n\", i,\n\t\t\t\tstatus);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\ttwl_priv->ready = true;\n\n\t \n\tclocks_init(&client->dev);\n\n\t \n\tif (twl_class_is_4030()) {\n\t\tstatus = twl_read_idcode_register();\n\t\tWARN(status < 0, \"Error: reading twl_idcode register value\\n\");\n\t}\n\n\t \n\tif (client->irq) {\n\t\tif (twl_class_is_4030()) {\n\t\t\ttwl4030_init_chip_irq(id->name);\n\t\t\tirq_base = twl4030_init_irq(&client->dev, client->irq);\n\t\t} else {\n\t\t\tirq_base = twl6030_init_irq(&client->dev, client->irq);\n\t\t}\n\n\t\tif (irq_base < 0) {\n\t\t\tstatus = irq_base;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t \n\tif (twl_class_is_4030()) {\n\t\tu8 temp;\n\n\t\ttwl_i2c_read_u8(TWL4030_MODULE_INTBR, &temp, REG_GPPUPDCTR1);\n\t\ttemp &= ~(SR_I2C_SDA_CTRL_PU | SR_I2C_SCL_CTRL_PU | \\\n\t\t\tI2C_SDA_CTRL_PU | I2C_SCL_CTRL_PU);\n\t\ttwl_i2c_write_u8(TWL4030_MODULE_INTBR, temp, REG_GPPUPDCTR1);\n\n\t\ttwl_i2c_read_u8(TWL_MODULE_PM_RECEIVER, &temp,\n\t\t\t\tTWL4030_DCDC_GLOBAL_CFG);\n\t\ttemp |= SMARTREFLEX_ENABLE;\n\t\ttwl_i2c_write_u8(TWL_MODULE_PM_RECEIVER, temp,\n\t\t\t\t TWL4030_DCDC_GLOBAL_CFG);\n\t}\n\n\tstatus = of_platform_populate(node, NULL, twl_auxdata_lookup,\n\t\t\t\t      &client->dev);\n\nfail:\n\tif (status < 0)\n\t\ttwl_remove(client);\nfree:\n\tif (status < 0)\n\t\tplatform_device_unregister(pdev);\n\n\treturn status;\n}\n\nstatic int __maybe_unused twl_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\n\tif (client->irq)\n\t\tdisable_irq(client->irq);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused twl_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\n\tif (client->irq)\n\t\tenable_irq(client->irq);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(twl_dev_pm_ops, twl_suspend, twl_resume);\n\nstatic const struct i2c_device_id twl_ids[] = {\n\t{ \"twl4030\", TWL4030_VAUX2 },\t \n\t{ \"twl5030\", 0 },\t\t \n\t{ \"twl5031\", TWL5031 },\t\t \n\t{ \"tps65950\", 0 },\t\t \n\t{ \"tps65930\", TPS_SUBSET },\t \n\t{ \"tps65920\", TPS_SUBSET },\t \n\t{ \"tps65921\", TPS_SUBSET },\t \n\t{ \"twl6030\", TWL6030_CLASS },\t \n\t{ \"twl6032\", TWL6030_CLASS | TWL6032_SUBCLASS },  \n\t{   },\n};\n\n \nstatic struct i2c_driver twl_driver = {\n\t.driver.name\t= DRIVER_NAME,\n\t.driver.pm\t= &twl_dev_pm_ops,\n\t.id_table\t= twl_ids,\n\t.probe\t\t= twl_probe,\n\t.remove\t\t= twl_remove,\n};\nbuiltin_i2c_driver(twl_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}