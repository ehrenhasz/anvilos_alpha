{
  "module_name": "ene-kb3930.c",
  "hash_id": "85e4719918ca3d35a34834bb1f0181c6f4784a00b5ee34929d7378a9e61fd4b2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/ene-kb3930.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/mfd/core.h>\n#include <linux/module.h>\n#include <linux/reboot.h>\n#include <linux/regmap.h>\n\n \nenum {\n\tEC_DATA_IN\t= 0x00,\n\tEC_RAM_OUT\t= 0x80,\n\tEC_RAM_IN\t= 0x81,\n};\n\n \nenum {\n\tEC_MODEL\t= 0x30,\n\tEC_VERSION_MAJ\t= 0x31,\n\tEC_VERSION_MIN\t= 0x32,\n};\n\nstruct kb3930 {\n\tstruct i2c_client *client;\n\tstruct regmap *ram_regmap;\n\tstruct gpio_descs *off_gpios;\n};\n\nstatic struct kb3930 *kb3930_power_off;\n\n#define EC_GPIO_WAVE\t\t0\n#define EC_GPIO_OFF_MODE\t1\n\n#define EC_OFF_MODE_REBOOT\t0\n#define EC_OFF_MODE_POWER\t1\n\nstatic void kb3930_off(struct kb3930 *ddata, int off_mode)\n{\n\tgpiod_direction_output(ddata->off_gpios->desc[EC_GPIO_OFF_MODE],\n\t\t\t       off_mode);\n\n\t \n\twhile (1) {\n\t\tmdelay(50);\n\t\tgpiod_direction_output(ddata->off_gpios->desc[EC_GPIO_WAVE], 0);\n\t\tmdelay(50);\n\t\tgpiod_direction_output(ddata->off_gpios->desc[EC_GPIO_WAVE], 1);\n\t}\n}\n\nstatic int kb3930_restart(struct notifier_block *this,\n\t\t\t  unsigned long mode, void *cmd)\n{\n\tkb3930_off(kb3930_power_off, EC_OFF_MODE_REBOOT);\n\treturn NOTIFY_DONE;\n}\n\nstatic void kb3930_pm_power_off(void)\n{\n\tkb3930_off(kb3930_power_off, EC_OFF_MODE_POWER);\n}\n\nstatic struct notifier_block kb3930_restart_nb = {\n\t.notifier_call = kb3930_restart,\n};\n\nstatic const struct mfd_cell ariel_ec_cells[] = {\n\t{ .name = \"dell-wyse-ariel-led\", },\n\t{ .name = \"dell-wyse-ariel-power\", },\n};\n\nstatic int kb3930_ec_ram_reg_write(void *context, unsigned int reg,\n\t\t\t\t   unsigned int val)\n{\n\tstruct kb3930 *ddata = context;\n\n\treturn i2c_smbus_write_word_data(ddata->client, EC_RAM_OUT,\n\t\t\t\t\t (val << 8) | reg);\n}\n\nstatic int kb3930_ec_ram_reg_read(void *context, unsigned int reg,\n\t\t\t\t  unsigned int *val)\n{\n\tstruct kb3930 *ddata = context;\n\tint ret;\n\n\tret = i2c_smbus_write_word_data(ddata->client, EC_RAM_IN, reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = i2c_smbus_read_word_data(ddata->client, EC_DATA_IN);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*val = ret >> 8;\n\treturn 0;\n}\n\nstatic const struct regmap_config kb3930_ram_regmap_config = {\n\t.name = \"ec_ram\",\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.reg_stride = 1,\n\t.max_register = 0xff,\n\t.reg_write = kb3930_ec_ram_reg_write,\n\t.reg_read = kb3930_ec_ram_reg_read,\n\t.fast_io = false,\n};\n\nstatic int kb3930_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct kb3930 *ddata;\n\tunsigned int model;\n\tint ret;\n\n\tddata = devm_kzalloc(dev, sizeof(*ddata), GFP_KERNEL);\n\tif (!ddata)\n\t\treturn -ENOMEM;\n\n\tkb3930_power_off = ddata;\n\tddata->client = client;\n\ti2c_set_clientdata(client, ddata);\n\n\tddata->ram_regmap = devm_regmap_init(dev, NULL, ddata,\n\t\t\t\t\t     &kb3930_ram_regmap_config);\n\tif (IS_ERR(ddata->ram_regmap))\n\t\treturn PTR_ERR(ddata->ram_regmap);\n\n\tret = regmap_read(ddata->ram_regmap, EC_MODEL, &model);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (model != 'J') {\n\t\tdev_err(dev, \"unknown board model: %02x\\n\", model);\n\t\treturn -ENODEV;\n\t}\n\n\tret = devm_mfd_add_devices(dev, PLATFORM_DEVID_AUTO,\n\t\t\t\t   ariel_ec_cells,\n\t\t\t\t   ARRAY_SIZE(ariel_ec_cells),\n\t\t\t\t   NULL, 0, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tif (of_property_read_bool(np, \"system-power-controller\")) {\n\t\tddata->off_gpios =\n\t\t\tdevm_gpiod_get_array_optional(dev, \"off\", GPIOD_IN);\n\t\tif (IS_ERR(ddata->off_gpios))\n\t\t\treturn PTR_ERR(ddata->off_gpios);\n\t\tif (ddata->off_gpios->ndescs < 2) {\n\t\t\tdev_err(dev, \"invalid off-gpios property\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (ddata->off_gpios) {\n\t\tregister_restart_handler(&kb3930_restart_nb);\n\t\tif (!pm_power_off)\n\t\t\tpm_power_off = kb3930_pm_power_off;\n\t}\n\n\treturn 0;\n}\n\nstatic void kb3930_remove(struct i2c_client *client)\n{\n\tstruct kb3930 *ddata = i2c_get_clientdata(client);\n\n\tif (ddata->off_gpios) {\n\t\tif (pm_power_off == kb3930_pm_power_off)\n\t\t\tpm_power_off = NULL;\n\t\tunregister_restart_handler(&kb3930_restart_nb);\n\t}\n\tkb3930_power_off = NULL;\n}\n\nstatic const struct of_device_id kb3930_dt_ids[] = {\n\t{ .compatible = \"ene,kb3930\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, kb3930_dt_ids);\n\nstatic struct i2c_driver kb3930_driver = {\n\t.probe = kb3930_probe,\n\t.remove = kb3930_remove,\n\t.driver = {\n\t\t.name = \"ene-kb3930\",\n\t\t.of_match_table = kb3930_dt_ids,\n\t},\n};\nmodule_i2c_driver(kb3930_driver);\n\nMODULE_AUTHOR(\"Lubomir Rintel <lkundrak@v3.sk>\");\nMODULE_DESCRIPTION(\"ENE KB3930 Embedded Controller Driver\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}