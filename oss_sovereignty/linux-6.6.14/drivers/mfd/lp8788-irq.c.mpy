{
  "module_name": "lp8788-irq.c",
  "hash_id": "b36e95790560294ca815f636541f54fb9387b811646557a8aa4f8c36ab59b5e1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/lp8788-irq.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/device.h>\n#include <linux/mfd/lp8788.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n \n#define LP8788_INT_1\t\t\t0x00\n#define LP8788_INTEN_1\t\t\t0x03\n\n#define BASE_INTEN_ADDR\t\t\tLP8788_INTEN_1\n#define SIZE_REG\t\t\t8\n#define NUM_REGS\t\t\t3\n\n \nstruct lp8788_irq_data {\n\tstruct lp8788 *lp;\n\tstruct mutex irq_lock;\n\tstruct irq_domain *domain;\n\tint enabled[LP8788_INT_MAX];\n};\n\nstatic inline u8 _irq_to_addr(enum lp8788_int_id id)\n{\n\treturn id / SIZE_REG;\n}\n\nstatic inline u8 _irq_to_enable_addr(enum lp8788_int_id id)\n{\n\treturn _irq_to_addr(id) + BASE_INTEN_ADDR;\n}\n\nstatic inline u8 _irq_to_mask(enum lp8788_int_id id)\n{\n\treturn 1 << (id % SIZE_REG);\n}\n\nstatic inline u8 _irq_to_val(enum lp8788_int_id id, int enable)\n{\n\treturn enable << (id % SIZE_REG);\n}\n\nstatic void lp8788_irq_enable(struct irq_data *data)\n{\n\tstruct lp8788_irq_data *irqd = irq_data_get_irq_chip_data(data);\n\n\tirqd->enabled[data->hwirq] = 1;\n}\n\nstatic void lp8788_irq_disable(struct irq_data *data)\n{\n\tstruct lp8788_irq_data *irqd = irq_data_get_irq_chip_data(data);\n\n\tirqd->enabled[data->hwirq] = 0;\n}\n\nstatic void lp8788_irq_bus_lock(struct irq_data *data)\n{\n\tstruct lp8788_irq_data *irqd = irq_data_get_irq_chip_data(data);\n\n\tmutex_lock(&irqd->irq_lock);\n}\n\nstatic void lp8788_irq_bus_sync_unlock(struct irq_data *data)\n{\n\tstruct lp8788_irq_data *irqd = irq_data_get_irq_chip_data(data);\n\tenum lp8788_int_id irq = data->hwirq;\n\tu8 addr, mask, val;\n\n\taddr = _irq_to_enable_addr(irq);\n\tmask = _irq_to_mask(irq);\n\tval = _irq_to_val(irq, irqd->enabled[irq]);\n\n\tlp8788_update_bits(irqd->lp, addr, mask, val);\n\n\tmutex_unlock(&irqd->irq_lock);\n}\n\nstatic struct irq_chip lp8788_irq_chip = {\n\t.name\t\t\t= \"lp8788\",\n\t.irq_enable\t\t= lp8788_irq_enable,\n\t.irq_disable\t\t= lp8788_irq_disable,\n\t.irq_bus_lock\t\t= lp8788_irq_bus_lock,\n\t.irq_bus_sync_unlock\t= lp8788_irq_bus_sync_unlock,\n};\n\nstatic irqreturn_t lp8788_irq_handler(int irq, void *ptr)\n{\n\tstruct lp8788_irq_data *irqd = ptr;\n\tstruct lp8788 *lp = irqd->lp;\n\tu8 status[NUM_REGS], addr, mask;\n\tbool handled = false;\n\tint i;\n\n\tif (lp8788_read_multi_bytes(lp, LP8788_INT_1, status, NUM_REGS))\n\t\treturn IRQ_NONE;\n\n\tfor (i = 0 ; i < LP8788_INT_MAX ; i++) {\n\t\taddr = _irq_to_addr(i);\n\t\tmask = _irq_to_mask(i);\n\n\t\t \n\t\tif (status[addr] & mask) {\n\t\t\thandle_nested_irq(irq_find_mapping(irqd->domain, i));\n\t\t\thandled = true;\n\t\t}\n\t}\n\n\treturn handled ? IRQ_HANDLED : IRQ_NONE;\n}\n\nstatic int lp8788_irq_map(struct irq_domain *d, unsigned int virq,\n\t\t\tirq_hw_number_t hwirq)\n{\n\tstruct lp8788_irq_data *irqd = d->host_data;\n\tstruct irq_chip *chip = &lp8788_irq_chip;\n\n\tirq_set_chip_data(virq, irqd);\n\tirq_set_chip_and_handler(virq, chip, handle_edge_irq);\n\tirq_set_nested_thread(virq, 1);\n\tirq_set_noprobe(virq);\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops lp8788_domain_ops = {\n\t.map = lp8788_irq_map,\n};\n\nint lp8788_irq_init(struct lp8788 *lp, int irq)\n{\n\tstruct lp8788_irq_data *irqd;\n\tint ret;\n\n\tif (irq <= 0) {\n\t\tdev_warn(lp->dev, \"invalid irq number: %d\\n\", irq);\n\t\treturn 0;\n\t}\n\n\tirqd = devm_kzalloc(lp->dev, sizeof(*irqd), GFP_KERNEL);\n\tif (!irqd)\n\t\treturn -ENOMEM;\n\n\tirqd->lp = lp;\n\tirqd->domain = irq_domain_add_linear(lp->dev->of_node, LP8788_INT_MAX,\n\t\t\t\t\t&lp8788_domain_ops, irqd);\n\tif (!irqd->domain) {\n\t\tdev_err(lp->dev, \"failed to add irq domain err\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tlp->irqdm = irqd->domain;\n\tmutex_init(&irqd->irq_lock);\n\n\tret = request_threaded_irq(irq, NULL, lp8788_irq_handler,\n\t\t\t\tIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\n\t\t\t\t\"lp8788-irq\", irqd);\n\tif (ret) {\n\t\tirq_domain_remove(lp->irqdm);\n\t\tdev_err(lp->dev, \"failed to create a thread for IRQ_N\\n\");\n\t\treturn ret;\n\t}\n\n\tlp->irq = irq;\n\n\treturn 0;\n}\n\nvoid lp8788_irq_exit(struct lp8788 *lp)\n{\n\tif (lp->irq)\n\t\tfree_irq(lp->irq, lp->irqdm);\n\tif (lp->irqdm)\n\t\tirq_domain_remove(lp->irqdm);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}