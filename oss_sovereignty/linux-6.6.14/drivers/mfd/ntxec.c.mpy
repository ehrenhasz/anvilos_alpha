{
  "module_name": "ntxec.c",
  "hash_id": "6adfee8b4a433440782302c194b4273da7b069edde1ba8fc75a5a278446dad25",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/ntxec.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/i2c.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/ntxec.h>\n#include <linux/module.h>\n#include <linux/pm.h>\n#include <linux/reboot.h>\n#include <linux/regmap.h>\n#include <linux/types.h>\n#include <asm/unaligned.h>\n\n#define NTXEC_REG_VERSION\t0x00\n#define NTXEC_REG_POWEROFF\t0x50\n#define NTXEC_REG_POWERKEEP\t0x70\n#define NTXEC_REG_RESET\t\t0x90\n\n#define NTXEC_POWEROFF_VALUE\t0x0100\n#define NTXEC_POWERKEEP_VALUE\t0x0800\n#define NTXEC_RESET_VALUE\t0xff00\n\nstatic struct i2c_client *poweroff_restart_client;\n\nstatic void ntxec_poweroff(void)\n{\n\tint res;\n\tu8 buf[3] = { NTXEC_REG_POWEROFF };\n\tstruct i2c_msg msgs[] = {\n\t\t{\n\t\t\t.addr = poweroff_restart_client->addr,\n\t\t\t.flags = 0,\n\t\t\t.len = sizeof(buf),\n\t\t\t.buf = buf,\n\t\t},\n\t};\n\n\tput_unaligned_be16(NTXEC_POWEROFF_VALUE, buf + 1);\n\n\tres = i2c_transfer(poweroff_restart_client->adapter, msgs, ARRAY_SIZE(msgs));\n\tif (res < 0)\n\t\tdev_warn(&poweroff_restart_client->dev,\n\t\t\t \"Failed to power off (err = %d)\\n\", res);\n\n\t \n\tmsleep(5000);\n}\n\nstatic int ntxec_restart(struct notifier_block *nb,\n\t\t\t unsigned long action, void *data)\n{\n\tint res;\n\tu8 buf[3] = { NTXEC_REG_RESET };\n\t \n\tstruct i2c_msg msgs[] = {\n\t\t{\n\t\t\t.addr = poweroff_restart_client->addr,\n\t\t\t.flags = 0,\n\t\t\t.len = sizeof(buf) - 1,\n\t\t\t.buf = buf,\n\t\t},\n\t};\n\n\tput_unaligned_be16(NTXEC_RESET_VALUE, buf + 1);\n\n\tres = i2c_transfer(poweroff_restart_client->adapter, msgs, ARRAY_SIZE(msgs));\n\tif (res < 0)\n\t\tdev_warn(&poweroff_restart_client->dev,\n\t\t\t \"Failed to restart (err = %d)\\n\", res);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block ntxec_restart_handler = {\n\t.notifier_call = ntxec_restart,\n\t.priority = 128,\n};\n\nstatic int regmap_ignore_write(void *context,\n\t\t\t       unsigned int reg, unsigned int val)\n\n{\n\tstruct regmap *regmap = context;\n\n\tregmap_write(regmap, reg, val);\n\n\treturn 0;\n}\n\nstatic int regmap_wrap_read(void *context, unsigned int reg,\n\t\t\t    unsigned int *val)\n{\n\tstruct regmap *regmap = context;\n\n\treturn regmap_read(regmap, reg, val);\n}\n\n \nstatic const struct regmap_config regmap_config_noack = {\n\t.name = \"ntxec_noack\",\n\t.reg_bits = 8,\n\t.val_bits = 16,\n\t.cache_type = REGCACHE_NONE,\n\t.reg_write = regmap_ignore_write,\n\t.reg_read = regmap_wrap_read\n};\n\nstatic const struct regmap_config regmap_config = {\n\t.name = \"ntxec\",\n\t.reg_bits = 8,\n\t.val_bits = 16,\n\t.cache_type = REGCACHE_NONE,\n\t.val_format_endian = REGMAP_ENDIAN_BIG,\n};\n\nstatic const struct mfd_cell ntxec_subdev[] = {\n\t{ .name = \"ntxec-rtc\" },\n\t{ .name = \"ntxec-pwm\" },\n};\n\nstatic const struct mfd_cell ntxec_subdev_pwm[] = {\n\t{ .name = \"ntxec-pwm\" },\n};\n\nstatic int ntxec_probe(struct i2c_client *client)\n{\n\tstruct ntxec *ec;\n\tunsigned int version;\n\tint res;\n\tconst struct mfd_cell *subdevs;\n\tsize_t n_subdevs;\n\n\tec = devm_kmalloc(&client->dev, sizeof(*ec), GFP_KERNEL);\n\tif (!ec)\n\t\treturn -ENOMEM;\n\n\tec->dev = &client->dev;\n\n\tec->regmap = devm_regmap_init_i2c(client, &regmap_config);\n\tif (IS_ERR(ec->regmap)) {\n\t\tdev_err(ec->dev, \"Failed to set up regmap for device\\n\");\n\t\treturn PTR_ERR(ec->regmap);\n\t}\n\n\t \n\tres = regmap_read(ec->regmap, NTXEC_REG_VERSION, &version);\n\tif (res < 0) {\n\t\tdev_err(ec->dev, \"Failed to read firmware version number\\n\");\n\t\treturn res;\n\t}\n\n\t \n\tswitch (version) {\n\tcase NTXEC_VERSION_KOBO_AURA:\n\tcase NTXEC_VERSION_TOLINO_VISION:\n\t\tsubdevs = ntxec_subdev;\n\t\tn_subdevs = ARRAY_SIZE(ntxec_subdev);\n\t\tbreak;\n\tcase NTXEC_VERSION_TOLINO_SHINE2:\n\t\tsubdevs = ntxec_subdev_pwm;\n\t\tn_subdevs = ARRAY_SIZE(ntxec_subdev_pwm);\n\t\t \n\t\tec->regmap = devm_regmap_init(ec->dev, NULL,\n\t\t\t\t\t      ec->regmap,\n\t\t\t\t\t      &regmap_config_noack);\n\t\tif (IS_ERR(ec->regmap))\n\t\t\treturn PTR_ERR(ec->regmap);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(ec->dev,\n\t\t\t\"Netronix embedded controller version %04x is not supported.\\n\",\n\t\t\tversion);\n\t\treturn -ENODEV;\n\t}\n\n\tdev_info(ec->dev,\n\t\t \"Netronix embedded controller version %04x detected.\\n\", version);\n\n\tif (of_device_is_system_power_controller(ec->dev->of_node)) {\n\t\t \n\t\tres = regmap_write(ec->regmap, NTXEC_REG_POWERKEEP,\n\t\t\t\t   NTXEC_POWERKEEP_VALUE);\n\t\tif (res < 0)\n\t\t\treturn res;\n\n\t\tif (poweroff_restart_client)\n\t\t\t \n\t\t\tdev_err(ec->dev, \"poweroff_restart_client already assigned\\n\");\n\t\telse\n\t\t\tpoweroff_restart_client = client;\n\n\t\tif (pm_power_off)\n\t\t\t \n\t\t\tdev_err(ec->dev, \"pm_power_off already assigned\\n\");\n\t\telse\n\t\t\tpm_power_off = ntxec_poweroff;\n\n\t\tres = register_restart_handler(&ntxec_restart_handler);\n\t\tif (res)\n\t\t\tdev_err(ec->dev,\n\t\t\t\t\"Failed to register restart handler: %d\\n\", res);\n\t}\n\n\ti2c_set_clientdata(client, ec);\n\n\tres = devm_mfd_add_devices(ec->dev, PLATFORM_DEVID_NONE,\n\t\t\t\t   subdevs, n_subdevs, NULL, 0, NULL);\n\tif (res)\n\t\tdev_err(ec->dev, \"Failed to add subdevices: %d\\n\", res);\n\n\treturn res;\n}\n\nstatic void ntxec_remove(struct i2c_client *client)\n{\n\tif (client == poweroff_restart_client) {\n\t\tpoweroff_restart_client = NULL;\n\t\tpm_power_off = NULL;\n\t\tunregister_restart_handler(&ntxec_restart_handler);\n\t}\n}\n\nstatic const struct of_device_id of_ntxec_match_table[] = {\n\t{ .compatible = \"netronix,ntxec\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, of_ntxec_match_table);\n\nstatic struct i2c_driver ntxec_driver = {\n\t.driver = {\n\t\t.name = \"ntxec\",\n\t\t.of_match_table = of_ntxec_match_table,\n\t},\n\t.probe = ntxec_probe,\n\t.remove = ntxec_remove,\n};\nmodule_i2c_driver(ntxec_driver);\n\nMODULE_AUTHOR(\"Jonathan Neusch\u00e4fer <j.neuschaefer@gmx.net>\");\nMODULE_DESCRIPTION(\"Core driver for Netronix EC\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}