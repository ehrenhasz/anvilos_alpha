{
  "module_name": "rn5t618.c",
  "hash_id": "ba0e201094f025e781508ef996ae8d579742b50ec4f148520e826531e8a2f6ce",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/rn5t618.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/rn5t618.h>\n#include <linux/module.h>\n#include <linux/of_device.h>\n#include <linux/platform_device.h>\n#include <linux/reboot.h>\n#include <linux/regmap.h>\n\nstatic const struct mfd_cell rn5t618_cells[] = {\n\t{ .name = \"rn5t618-regulator\" },\n\t{ .name = \"rn5t618-wdt\" },\n};\n\nstatic const struct mfd_cell rc5t619_cells[] = {\n\t{ .name = \"rn5t618-adc\" },\n\t{ .name = \"rn5t618-power\" },\n\t{ .name = \"rn5t618-regulator\" },\n\t{ .name = \"rc5t619-rtc\" },\n\t{ .name = \"rn5t618-wdt\" },\n};\n\nstatic bool rn5t618_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase RN5T618_WATCHDOGCNT:\n\tcase RN5T618_DCIRQ:\n\tcase RN5T618_ILIMDATAH ... RN5T618_AIN0DATAL:\n\tcase RN5T618_ADCCNT3:\n\tcase RN5T618_IR_ADC1 ... RN5T618_IR_ADC3:\n\tcase RN5T618_IR_GPR:\n\tcase RN5T618_IR_GPF:\n\tcase RN5T618_MON_IOIN:\n\tcase RN5T618_INTMON:\n\tcase RN5T618_RTC_CTRL1 ... RN5T618_RTC_CTRL2:\n\tcase RN5T618_RTC_SECONDS ... RN5T618_RTC_YEAR:\n\tcase RN5T618_CHGCTL1:\n\tcase RN5T618_REGISET1 ... RN5T618_REGISET2:\n\tcase RN5T618_CHGSTATE:\n\tcase RN5T618_CHGCTRL_IRR ... RN5T618_CHGERR_MONI:\n\tcase RN5T618_GCHGDET:\n\tcase RN5T618_CONTROL ... RN5T618_CC_AVEREG0:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config rn5t618_regmap_config = {\n\t.reg_bits\t= 8,\n\t.val_bits\t= 8,\n\t.volatile_reg\t= rn5t618_volatile_reg,\n\t.max_register\t= RN5T618_MAX_REG,\n\t.cache_type\t= REGCACHE_RBTREE,\n};\n\nstatic const struct regmap_irq rc5t619_irqs[] = {\n\tREGMAP_IRQ_REG(RN5T618_IRQ_SYS, 0, BIT(0)),\n\tREGMAP_IRQ_REG(RN5T618_IRQ_DCDC, 0, BIT(1)),\n\tREGMAP_IRQ_REG(RN5T618_IRQ_RTC, 0, BIT(2)),\n\tREGMAP_IRQ_REG(RN5T618_IRQ_ADC, 0, BIT(3)),\n\tREGMAP_IRQ_REG(RN5T618_IRQ_GPIO, 0, BIT(4)),\n\tREGMAP_IRQ_REG(RN5T618_IRQ_CHG, 0, BIT(6)),\n};\n\nstatic const struct regmap_irq_chip rc5t619_irq_chip = {\n\t.name = \"rc5t619\",\n\t.irqs = rc5t619_irqs,\n\t.num_irqs = ARRAY_SIZE(rc5t619_irqs),\n\t.num_regs = 1,\n\t.status_base = RN5T618_INTMON,\n\t.unmask_base = RN5T618_INTEN,\n};\n\nstatic struct i2c_client *rn5t618_pm_power_off;\nstatic struct notifier_block rn5t618_restart_handler;\n\nstatic int rn5t618_irq_init(struct rn5t618 *rn5t618)\n{\n\tconst struct regmap_irq_chip *irq_chip = NULL;\n\tint ret;\n\n\tif (!rn5t618->irq)\n\t\treturn 0;\n\n\tswitch (rn5t618->variant) {\n\tcase RC5T619:\n\t\tirq_chip = &rc5t619_irq_chip;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(rn5t618->dev, \"Currently no IRQ support for variant %d\\n\",\n\t\t\t(int)rn5t618->variant);\n\t\treturn -ENOENT;\n\t}\n\n\tret = devm_regmap_add_irq_chip(rn5t618->dev, rn5t618->regmap,\n\t\t\t\t       rn5t618->irq,\n\t\t\t\t       IRQF_TRIGGER_LOW | IRQF_ONESHOT,\n\t\t\t\t       0, irq_chip, &rn5t618->irq_data);\n\tif (ret)\n\t\tdev_err(rn5t618->dev, \"Failed to register IRQ chip\\n\");\n\n\treturn ret;\n}\n\nstatic void rn5t618_trigger_poweroff_sequence(bool repower)\n{\n\tint ret;\n\n\t \n\tret = i2c_smbus_read_byte_data(rn5t618_pm_power_off, RN5T618_REPCNT);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tret &= ~RN5T618_REPCNT_REPWRON;\n\tif (repower)\n\t\tret |= RN5T618_REPCNT_REPWRON;\n\n\tret = i2c_smbus_write_byte_data(rn5t618_pm_power_off,\n\t\t\t\t\tRN5T618_REPCNT, (u8)ret);\n\tif (ret < 0)\n\t\tgoto err;\n\n\t \n\tret = i2c_smbus_read_byte_data(rn5t618_pm_power_off, RN5T618_SLPCNT);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tret |= RN5T618_SLPCNT_SWPWROFF;\n\n\tret = i2c_smbus_write_byte_data(rn5t618_pm_power_off,\n\t\t\t\t\tRN5T618_SLPCNT, (u8)ret);\n\tif (ret < 0)\n\t\tgoto err;\n\n\treturn;\n\nerr:\n\tdev_alert(&rn5t618_pm_power_off->dev, \"Failed to shutdown (err = %d)\\n\", ret);\n}\n\nstatic void rn5t618_power_off(void)\n{\n\trn5t618_trigger_poweroff_sequence(false);\n}\n\nstatic int rn5t618_restart(struct notifier_block *this,\n\t\t\t    unsigned long mode, void *cmd)\n{\n\trn5t618_trigger_poweroff_sequence(true);\n\n\t \n\tmdelay(1);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic const struct of_device_id rn5t618_of_match[] = {\n\t{ .compatible = \"ricoh,rn5t567\", .data = (void *)RN5T567 },\n\t{ .compatible = \"ricoh,rn5t618\", .data = (void *)RN5T618 },\n\t{ .compatible = \"ricoh,rc5t619\", .data = (void *)RC5T619 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, rn5t618_of_match);\n\nstatic int rn5t618_i2c_probe(struct i2c_client *i2c)\n{\n\tconst struct of_device_id *of_id;\n\tstruct rn5t618 *priv;\n\tint ret;\n\n\tof_id = of_match_device(rn5t618_of_match, &i2c->dev);\n\tif (!of_id) {\n\t\tdev_err(&i2c->dev, \"Failed to find matching DT ID\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpriv = devm_kzalloc(&i2c->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(i2c, priv);\n\tpriv->variant = (long)of_id->data;\n\tpriv->irq = i2c->irq;\n\tpriv->dev = &i2c->dev;\n\n\tpriv->regmap = devm_regmap_init_i2c(i2c, &rn5t618_regmap_config);\n\tif (IS_ERR(priv->regmap)) {\n\t\tret = PTR_ERR(priv->regmap);\n\t\tdev_err(&i2c->dev, \"regmap init failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (priv->variant == RC5T619)\n\t\tret = devm_mfd_add_devices(&i2c->dev, PLATFORM_DEVID_NONE,\n\t\t\t\t\t   rc5t619_cells,\n\t\t\t\t\t   ARRAY_SIZE(rc5t619_cells),\n\t\t\t\t\t   NULL, 0, NULL);\n\telse\n\t\tret = devm_mfd_add_devices(&i2c->dev, PLATFORM_DEVID_NONE,\n\t\t\t\t\t   rn5t618_cells,\n\t\t\t\t\t   ARRAY_SIZE(rn5t618_cells),\n\t\t\t\t\t   NULL, 0, NULL);\n\tif (ret) {\n\t\tdev_err(&i2c->dev, \"failed to add sub-devices: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\trn5t618_pm_power_off = i2c;\n\tif (of_device_is_system_power_controller(i2c->dev.of_node)) {\n\t\tif (!pm_power_off)\n\t\t\tpm_power_off = rn5t618_power_off;\n\t\telse\n\t\t\tdev_warn(&i2c->dev, \"Poweroff callback already assigned\\n\");\n\t}\n\n\trn5t618_restart_handler.notifier_call = rn5t618_restart;\n\trn5t618_restart_handler.priority = 192;\n\n\tret = register_restart_handler(&rn5t618_restart_handler);\n\tif (ret) {\n\t\tdev_err(&i2c->dev, \"cannot register restart handler, %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn rn5t618_irq_init(priv);\n}\n\nstatic void rn5t618_i2c_remove(struct i2c_client *i2c)\n{\n\tif (i2c == rn5t618_pm_power_off) {\n\t\trn5t618_pm_power_off = NULL;\n\t\tpm_power_off = NULL;\n\t}\n\n\tunregister_restart_handler(&rn5t618_restart_handler);\n}\n\nstatic int __maybe_unused rn5t618_i2c_suspend(struct device *dev)\n{\n\tstruct rn5t618 *priv = dev_get_drvdata(dev);\n\n\tif (priv->irq)\n\t\tdisable_irq(priv->irq);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused rn5t618_i2c_resume(struct device *dev)\n{\n\tstruct rn5t618 *priv = dev_get_drvdata(dev);\n\n\tif (priv->irq)\n\t\tenable_irq(priv->irq);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(rn5t618_i2c_dev_pm_ops,\n\t\t\trn5t618_i2c_suspend,\n\t\t\trn5t618_i2c_resume);\n\nstatic struct i2c_driver rn5t618_i2c_driver = {\n\t.driver = {\n\t\t.name = \"rn5t618\",\n\t\t.of_match_table = rn5t618_of_match,\n\t\t.pm = &rn5t618_i2c_dev_pm_ops,\n\t},\n\t.probe = rn5t618_i2c_probe,\n\t.remove = rn5t618_i2c_remove,\n};\n\nmodule_i2c_driver(rn5t618_i2c_driver);\n\nMODULE_AUTHOR(\"Beniamino Galvani <b.galvani@gmail.com>\");\nMODULE_DESCRIPTION(\"Ricoh RN5T567/618 MFD driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}