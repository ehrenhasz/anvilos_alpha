{
  "module_name": "atmel-smc.c",
  "hash_id": "3f5a498d025abe6cc37acb3119f74c9e6fa5f6b960d43849d9d656688e9847dd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/atmel-smc.c",
  "human_readable_source": "\n \n\n#include <linux/mfd/syscon/atmel-smc.h>\n#include <linux/string.h>\n\n \nvoid atmel_smc_cs_conf_init(struct atmel_smc_cs_conf *conf)\n{\n\tmemset(conf, 0, sizeof(*conf));\n}\nEXPORT_SYMBOL_GPL(atmel_smc_cs_conf_init);\n\n \nstatic int atmel_smc_cs_encode_ncycles(unsigned int ncycles,\n\t\t\t\t       unsigned int msbpos,\n\t\t\t\t       unsigned int msbwidth,\n\t\t\t\t       unsigned int msbfactor,\n\t\t\t\t       unsigned int *encodedval)\n{\n\tunsigned int lsbmask = GENMASK(msbpos - 1, 0);\n\tunsigned int msbmask = GENMASK(msbwidth - 1, 0);\n\tunsigned int msb, lsb;\n\tint ret = 0;\n\n\tmsb = ncycles / msbfactor;\n\tlsb = ncycles % msbfactor;\n\n\tif (lsb > lsbmask) {\n\t\tlsb = 0;\n\t\tmsb++;\n\t}\n\n\t \n\tif (msb > msbmask) {\n\t\tmsb = msbmask;\n\t\tlsb = lsbmask;\n\t\tret = -ERANGE;\n\t}\n\n\t*encodedval = (msb << msbpos) | lsb;\n\n\treturn ret;\n}\n\n \nint atmel_smc_cs_conf_set_timing(struct atmel_smc_cs_conf *conf,\n\t\t\t\t unsigned int shift, unsigned int ncycles)\n{\n\tunsigned int val;\n\tint ret;\n\n\tif (shift != ATMEL_HSMC_TIMINGS_TCLR_SHIFT &&\n\t    shift != ATMEL_HSMC_TIMINGS_TADL_SHIFT &&\n\t    shift != ATMEL_HSMC_TIMINGS_TAR_SHIFT &&\n\t    shift != ATMEL_HSMC_TIMINGS_TRR_SHIFT &&\n\t    shift != ATMEL_HSMC_TIMINGS_TWB_SHIFT)\n\t\treturn -EINVAL;\n\n\t \n\tret = atmel_smc_cs_encode_ncycles(ncycles, 3, 1, 64, &val);\n\tconf->timings &= ~GENMASK(shift + 3, shift);\n\tconf->timings |= val << shift;\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(atmel_smc_cs_conf_set_timing);\n\n \nint atmel_smc_cs_conf_set_setup(struct atmel_smc_cs_conf *conf,\n\t\t\t\tunsigned int shift, unsigned int ncycles)\n{\n\tunsigned int val;\n\tint ret;\n\n\tif (shift != ATMEL_SMC_NWE_SHIFT && shift != ATMEL_SMC_NCS_WR_SHIFT &&\n\t    shift != ATMEL_SMC_NRD_SHIFT && shift != ATMEL_SMC_NCS_RD_SHIFT)\n\t\treturn -EINVAL;\n\n\t \n\tret = atmel_smc_cs_encode_ncycles(ncycles, 5, 1, 128, &val);\n\tconf->setup &= ~GENMASK(shift + 7, shift);\n\tconf->setup |= val << shift;\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(atmel_smc_cs_conf_set_setup);\n\n \nint atmel_smc_cs_conf_set_pulse(struct atmel_smc_cs_conf *conf,\n\t\t\t\tunsigned int shift, unsigned int ncycles)\n{\n\tunsigned int val;\n\tint ret;\n\n\tif (shift != ATMEL_SMC_NWE_SHIFT && shift != ATMEL_SMC_NCS_WR_SHIFT &&\n\t    shift != ATMEL_SMC_NRD_SHIFT && shift != ATMEL_SMC_NCS_RD_SHIFT)\n\t\treturn -EINVAL;\n\n\t \n\tret = atmel_smc_cs_encode_ncycles(ncycles, 6, 1, 256, &val);\n\tconf->pulse &= ~GENMASK(shift + 7, shift);\n\tconf->pulse |= val << shift;\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(atmel_smc_cs_conf_set_pulse);\n\n \nint atmel_smc_cs_conf_set_cycle(struct atmel_smc_cs_conf *conf,\n\t\t\t\tunsigned int shift, unsigned int ncycles)\n{\n\tunsigned int val;\n\tint ret;\n\n\tif (shift != ATMEL_SMC_NWE_SHIFT && shift != ATMEL_SMC_NRD_SHIFT)\n\t\treturn -EINVAL;\n\n\t \n\tret = atmel_smc_cs_encode_ncycles(ncycles, 7, 2, 256, &val);\n\tconf->cycle &= ~GENMASK(shift + 15, shift);\n\tconf->cycle |= val << shift;\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(atmel_smc_cs_conf_set_cycle);\n\n \nvoid atmel_smc_cs_conf_apply(struct regmap *regmap, int cs,\n\t\t\t     const struct atmel_smc_cs_conf *conf)\n{\n\tregmap_write(regmap, ATMEL_SMC_SETUP(cs), conf->setup);\n\tregmap_write(regmap, ATMEL_SMC_PULSE(cs), conf->pulse);\n\tregmap_write(regmap, ATMEL_SMC_CYCLE(cs), conf->cycle);\n\tregmap_write(regmap, ATMEL_SMC_MODE(cs), conf->mode);\n}\nEXPORT_SYMBOL_GPL(atmel_smc_cs_conf_apply);\n\n \nvoid atmel_hsmc_cs_conf_apply(struct regmap *regmap,\n\t\t\t      const struct atmel_hsmc_reg_layout *layout,\n\t\t\t      int cs, const struct atmel_smc_cs_conf *conf)\n{\n\tregmap_write(regmap, ATMEL_HSMC_SETUP(layout, cs), conf->setup);\n\tregmap_write(regmap, ATMEL_HSMC_PULSE(layout, cs), conf->pulse);\n\tregmap_write(regmap, ATMEL_HSMC_CYCLE(layout, cs), conf->cycle);\n\tregmap_write(regmap, ATMEL_HSMC_TIMINGS(layout, cs), conf->timings);\n\tregmap_write(regmap, ATMEL_HSMC_MODE(layout, cs), conf->mode);\n}\nEXPORT_SYMBOL_GPL(atmel_hsmc_cs_conf_apply);\n\n \nvoid atmel_smc_cs_conf_get(struct regmap *regmap, int cs,\n\t\t\t   struct atmel_smc_cs_conf *conf)\n{\n\tregmap_read(regmap, ATMEL_SMC_SETUP(cs), &conf->setup);\n\tregmap_read(regmap, ATMEL_SMC_PULSE(cs), &conf->pulse);\n\tregmap_read(regmap, ATMEL_SMC_CYCLE(cs), &conf->cycle);\n\tregmap_read(regmap, ATMEL_SMC_MODE(cs), &conf->mode);\n}\nEXPORT_SYMBOL_GPL(atmel_smc_cs_conf_get);\n\n \nvoid atmel_hsmc_cs_conf_get(struct regmap *regmap,\n\t\t\t    const struct atmel_hsmc_reg_layout *layout,\n\t\t\t    int cs, struct atmel_smc_cs_conf *conf)\n{\n\tregmap_read(regmap, ATMEL_HSMC_SETUP(layout, cs), &conf->setup);\n\tregmap_read(regmap, ATMEL_HSMC_PULSE(layout, cs), &conf->pulse);\n\tregmap_read(regmap, ATMEL_HSMC_CYCLE(layout, cs), &conf->cycle);\n\tregmap_read(regmap, ATMEL_HSMC_TIMINGS(layout, cs), &conf->timings);\n\tregmap_read(regmap, ATMEL_HSMC_MODE(layout, cs), &conf->mode);\n}\nEXPORT_SYMBOL_GPL(atmel_hsmc_cs_conf_get);\n\nstatic const struct atmel_hsmc_reg_layout sama5d3_reg_layout = {\n\t.timing_regs_offset = 0x600,\n};\n\nstatic const struct atmel_hsmc_reg_layout sama5d2_reg_layout = {\n\t.timing_regs_offset = 0x700,\n};\n\nstatic const struct of_device_id atmel_smc_ids[] __maybe_unused = {\n\t{ .compatible = \"atmel,at91sam9260-smc\", .data = NULL },\n\t{ .compatible = \"atmel,sama5d3-smc\", .data = &sama5d3_reg_layout },\n\t{ .compatible = \"atmel,sama5d2-smc\", .data = &sama5d2_reg_layout },\n\t{   },\n};\n\n \nconst struct atmel_hsmc_reg_layout *\natmel_hsmc_get_reg_layout(struct device_node *np)\n{\n\tconst struct of_device_id *match;\n\n\tmatch = of_match_node(atmel_smc_ids, np);\n\n\treturn match ? match->data : ERR_PTR(-EINVAL);\n}\nEXPORT_SYMBOL_GPL(atmel_hsmc_get_reg_layout);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}