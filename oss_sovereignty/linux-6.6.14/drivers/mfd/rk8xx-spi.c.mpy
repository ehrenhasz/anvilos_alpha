{
  "module_name": "rk8xx-spi.c",
  "hash_id": "6bcf4f159155a436d7c28c192e8e57942474fdf6b364379b57ce11edd95a523d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/rk8xx-spi.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/rk808.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/spi/spi.h>\n\n#define RK806_ADDR_SIZE 2\n#define RK806_CMD_WITH_SIZE(CMD, VALUE_BYTES) \\\n\t(RK806_CMD_##CMD | RK806_CMD_CRC_DIS | (VALUE_BYTES - 1))\n\nstatic const struct regmap_range rk806_volatile_ranges[] = {\n\tregmap_reg_range(RK806_POWER_EN0, RK806_POWER_EN5),\n\tregmap_reg_range(RK806_DVS_START_CTRL, RK806_INT_MSK1),\n};\n\nstatic const struct regmap_access_table rk806_volatile_table = {\n\t.yes_ranges = rk806_volatile_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(rk806_volatile_ranges),\n};\n\nstatic const struct regmap_config rk806_regmap_config_spi = {\n\t.reg_bits = 16,\n\t.val_bits = 8,\n\t.max_register = RK806_BUCK_RSERVE_REG5,\n\t.cache_type = REGCACHE_RBTREE,\n\t.volatile_table = &rk806_volatile_table,\n};\n\nstatic int rk806_spi_bus_write(void *context, const void *vdata, size_t count)\n{\n\tstruct device *dev = context;\n\tstruct spi_device *spi = to_spi_device(dev);\n\tstruct spi_transfer xfer[2] = { 0 };\n\t \n\tsize_t val_size = count - RK806_ADDR_SIZE;\n\tchar cmd;\n\n\tif (val_size < 1 || val_size > (RK806_CMD_LEN_MSK + 1))\n\t\treturn -EINVAL;\n\n\tcmd = RK806_CMD_WITH_SIZE(WRITE, val_size);\n\n\txfer[0].tx_buf = &cmd;\n\txfer[0].len = sizeof(cmd);\n\txfer[1].tx_buf = vdata;\n\txfer[1].len = count;\n\n\treturn spi_sync_transfer(spi, xfer, ARRAY_SIZE(xfer));\n}\n\nstatic int rk806_spi_bus_read(void *context, const void *vreg, size_t reg_size,\n\t\t\t      void *val, size_t val_size)\n{\n\tstruct device *dev = context;\n\tstruct spi_device *spi = to_spi_device(dev);\n\tchar txbuf[3] = { 0 };\n\n\tif (reg_size != RK806_ADDR_SIZE ||\n\t    val_size < 1 || val_size > (RK806_CMD_LEN_MSK + 1))\n\t\treturn -EINVAL;\n\n\t \n\ttxbuf[0] = RK806_CMD_WITH_SIZE(READ, val_size);\n\tmemcpy(txbuf+1, vreg, reg_size);\n\n\treturn spi_write_then_read(spi, txbuf, sizeof(txbuf), val, val_size);\n}\n\nstatic const struct regmap_bus rk806_regmap_bus_spi = {\n\t.write = rk806_spi_bus_write,\n\t.read = rk806_spi_bus_read,\n\t.reg_format_endian_default = REGMAP_ENDIAN_LITTLE,\n};\n\nstatic int rk8xx_spi_probe(struct spi_device *spi)\n{\n\tstruct regmap *regmap;\n\n\tregmap = devm_regmap_init(&spi->dev, &rk806_regmap_bus_spi,\n\t\t\t\t  &spi->dev, &rk806_regmap_config_spi);\n\tif (IS_ERR(regmap))\n\t\treturn dev_err_probe(&spi->dev, PTR_ERR(regmap),\n\t\t\t\t     \"Failed to init regmap\\n\");\n\n\treturn rk8xx_probe(&spi->dev, RK806_ID, spi->irq, regmap);\n}\n\nstatic const struct of_device_id rk8xx_spi_of_match[] = {\n\t{ .compatible = \"rockchip,rk806\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, rk8xx_spi_of_match);\n\nstatic const struct spi_device_id rk8xx_spi_id_table[] = {\n\t{ \"rk806\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(spi, rk8xx_spi_id_table);\n\nstatic struct spi_driver rk8xx_spi_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"rk8xx-spi\",\n\t\t.of_match_table = rk8xx_spi_of_match,\n\t},\n\t.probe\t\t= rk8xx_spi_probe,\n\t.id_table\t= rk8xx_spi_id_table,\n};\nmodule_spi_driver(rk8xx_spi_driver);\n\nMODULE_AUTHOR(\"Xu Shengfei <xsf@rock-chips.com>\");\nMODULE_DESCRIPTION(\"RK8xx SPI PMIC driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}