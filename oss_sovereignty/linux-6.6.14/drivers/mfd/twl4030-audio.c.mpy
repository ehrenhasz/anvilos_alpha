{
  "module_name": "twl4030-audio.c",
  "hash_id": "92e228254cf4fe8dcbf2de46ee3465244f09e891108e63b414e935e7204bd97c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/twl4030-audio.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/mfd/twl.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/twl4030-audio.h>\n\n#define TWL4030_AUDIO_CELLS\t2\n\nstatic struct platform_device *twl4030_audio_dev;\n\nstruct twl4030_audio_resource {\n\tint request_count;\n\tu8 reg;\n\tu8 mask;\n};\n\nstruct twl4030_audio {\n\tunsigned int audio_mclk;\n\tstruct mutex mutex;\n\tstruct twl4030_audio_resource resource[TWL4030_AUDIO_RES_MAX];\n\tstruct mfd_cell cells[TWL4030_AUDIO_CELLS];\n};\n\n \nstatic int twl4030_audio_set_resource(enum twl4030_audio_res id, int enable)\n{\n\tstruct twl4030_audio *audio = platform_get_drvdata(twl4030_audio_dev);\n\tu8 val;\n\n\ttwl_i2c_read_u8(TWL4030_MODULE_AUDIO_VOICE, &val,\n\t\t\taudio->resource[id].reg);\n\n\tif (enable)\n\t\tval |= audio->resource[id].mask;\n\telse\n\t\tval &= ~audio->resource[id].mask;\n\n\ttwl_i2c_write_u8(TWL4030_MODULE_AUDIO_VOICE,\n\t\t\t\t\tval, audio->resource[id].reg);\n\n\treturn val;\n}\n\nstatic inline int twl4030_audio_get_resource(enum twl4030_audio_res id)\n{\n\tstruct twl4030_audio *audio = platform_get_drvdata(twl4030_audio_dev);\n\tu8 val;\n\n\ttwl_i2c_read_u8(TWL4030_MODULE_AUDIO_VOICE, &val,\n\t\t\taudio->resource[id].reg);\n\n\treturn val;\n}\n\n \nint twl4030_audio_enable_resource(enum twl4030_audio_res id)\n{\n\tstruct twl4030_audio *audio = platform_get_drvdata(twl4030_audio_dev);\n\tint val;\n\n\tif (id >= TWL4030_AUDIO_RES_MAX) {\n\t\tdev_err(&twl4030_audio_dev->dev,\n\t\t\t\t\"Invalid resource ID (%u)\\n\", id);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&audio->mutex);\n\tif (!audio->resource[id].request_count)\n\t\t \n\t\tval = twl4030_audio_set_resource(id, 1);\n\telse\n\t\tval = twl4030_audio_get_resource(id);\n\n\taudio->resource[id].request_count++;\n\tmutex_unlock(&audio->mutex);\n\n\treturn val;\n}\nEXPORT_SYMBOL_GPL(twl4030_audio_enable_resource);\n\n \nint twl4030_audio_disable_resource(enum twl4030_audio_res id)\n{\n\tstruct twl4030_audio *audio = platform_get_drvdata(twl4030_audio_dev);\n\tint val;\n\n\tif (id >= TWL4030_AUDIO_RES_MAX) {\n\t\tdev_err(&twl4030_audio_dev->dev,\n\t\t\t\t\"Invalid resource ID (%u)\\n\", id);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&audio->mutex);\n\tif (!audio->resource[id].request_count) {\n\t\tdev_err(&twl4030_audio_dev->dev,\n\t\t\t\"Resource has been disabled already (%u)\\n\", id);\n\t\tmutex_unlock(&audio->mutex);\n\t\treturn -EPERM;\n\t}\n\taudio->resource[id].request_count--;\n\n\tif (!audio->resource[id].request_count)\n\t\t \n\t\tval = twl4030_audio_set_resource(id, 0);\n\telse\n\t\tval = twl4030_audio_get_resource(id);\n\n\tmutex_unlock(&audio->mutex);\n\n\treturn val;\n}\nEXPORT_SYMBOL_GPL(twl4030_audio_disable_resource);\n\nunsigned int twl4030_audio_get_mclk(void)\n{\n\tstruct twl4030_audio *audio = platform_get_drvdata(twl4030_audio_dev);\n\n\treturn audio->audio_mclk;\n}\nEXPORT_SYMBOL_GPL(twl4030_audio_get_mclk);\n\nstatic bool twl4030_audio_has_codec(struct twl4030_audio_data *pdata,\n\t\t\t      struct device_node *parent)\n{\n\tstruct device_node *node;\n\n\tif (pdata && pdata->codec)\n\t\treturn true;\n\n\tnode = of_get_child_by_name(parent, \"codec\");\n\tif (node) {\n\t\tof_node_put(node);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool twl4030_audio_has_vibra(struct twl4030_audio_data *pdata,\n\t\t\t      struct device_node *node)\n{\n\tint vibra;\n\n\tif (pdata && pdata->vibra)\n\t\treturn true;\n\n\tif (!of_property_read_u32(node, \"ti,enable-vibra\", &vibra) && vibra)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int twl4030_audio_probe(struct platform_device *pdev)\n{\n\tstruct twl4030_audio *audio;\n\tstruct twl4030_audio_data *pdata = dev_get_platdata(&pdev->dev);\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct mfd_cell *cell = NULL;\n\tint ret, childs = 0;\n\tu8 val;\n\n\tif (!pdata && !node) {\n\t\tdev_err(&pdev->dev, \"Platform data is missing\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\taudio = devm_kzalloc(&pdev->dev, sizeof(struct twl4030_audio),\n\t\t\t     GFP_KERNEL);\n\tif (!audio)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&audio->mutex);\n\taudio->audio_mclk = twl_get_hfclk_rate();\n\n\t \n\tswitch (audio->audio_mclk) {\n\tcase 19200000:\n\t\tval = TWL4030_APLL_INFREQ_19200KHZ;\n\t\tbreak;\n\tcase 26000000:\n\t\tval = TWL4030_APLL_INFREQ_26000KHZ;\n\t\tbreak;\n\tcase 38400000:\n\t\tval = TWL4030_APLL_INFREQ_38400KHZ;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&pdev->dev, \"Invalid audio_mclk\\n\");\n\t\treturn -EINVAL;\n\t}\n\ttwl_i2c_write_u8(TWL4030_MODULE_AUDIO_VOICE, val, TWL4030_REG_APLL_CTL);\n\n\t \n\taudio->resource[TWL4030_AUDIO_RES_POWER].reg = TWL4030_REG_CODEC_MODE;\n\taudio->resource[TWL4030_AUDIO_RES_POWER].mask = TWL4030_CODECPDZ;\n\n\t \n\taudio->resource[TWL4030_AUDIO_RES_APLL].reg = TWL4030_REG_APLL_CTL;\n\taudio->resource[TWL4030_AUDIO_RES_APLL].mask = TWL4030_APLL_EN;\n\n\tif (twl4030_audio_has_codec(pdata, node)) {\n\t\tcell = &audio->cells[childs];\n\t\tcell->name = \"twl4030-codec\";\n\t\tif (pdata) {\n\t\t\tcell->platform_data = pdata->codec;\n\t\t\tcell->pdata_size = sizeof(*pdata->codec);\n\t\t}\n\t\tchilds++;\n\t}\n\tif (twl4030_audio_has_vibra(pdata, node)) {\n\t\tcell = &audio->cells[childs];\n\t\tcell->name = \"twl4030-vibra\";\n\t\tif (pdata) {\n\t\t\tcell->platform_data = pdata->vibra;\n\t\t\tcell->pdata_size = sizeof(*pdata->vibra);\n\t\t}\n\t\tchilds++;\n\t}\n\n\tplatform_set_drvdata(pdev, audio);\n\ttwl4030_audio_dev = pdev;\n\n\tif (childs)\n\t\tret = mfd_add_devices(&pdev->dev, pdev->id, audio->cells,\n\t\t\t\t      childs, NULL, 0, NULL);\n\telse {\n\t\tdev_err(&pdev->dev, \"No platform data found for childs\\n\");\n\t\tret = -ENODEV;\n\t}\n\n\tif (ret)\n\t\ttwl4030_audio_dev = NULL;\n\n\treturn ret;\n}\n\nstatic int twl4030_audio_remove(struct platform_device *pdev)\n{\n\tmfd_remove_devices(&pdev->dev);\n\ttwl4030_audio_dev = NULL;\n\n\treturn 0;\n}\n\nstatic const struct of_device_id twl4030_audio_of_match[] = {\n\t{.compatible = \"ti,twl4030-audio\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, twl4030_audio_of_match);\n\nstatic struct platform_driver twl4030_audio_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"twl4030-audio\",\n\t\t.of_match_table = twl4030_audio_of_match,\n\t},\n\t.probe\t\t= twl4030_audio_probe,\n\t.remove\t\t= twl4030_audio_remove,\n};\n\nmodule_platform_driver(twl4030_audio_driver);\n\nMODULE_AUTHOR(\"Peter Ujfalusi <peter.ujfalusi@ti.com>\");\nMODULE_DESCRIPTION(\"TWL4030 audio block MFD driver\");\nMODULE_ALIAS(\"platform:twl4030-audio\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}