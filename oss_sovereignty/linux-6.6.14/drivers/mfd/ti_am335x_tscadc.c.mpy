{
  "module_name": "ti_am335x_tscadc.c",
  "hash_id": "10ffb508f960dca268bd36cb70444e89d010821cbe4ecaad9b00ddb83b13c97e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/ti_am335x_tscadc.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/clk.h>\n#include <linux/regmap.h>\n#include <linux/mfd/core.h>\n#include <linux/pm_runtime.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/sched.h>\n\n#include <linux/mfd/ti_am335x_tscadc.h>\n\nstatic const struct regmap_config tscadc_regmap_config = {\n\t.name = \"ti_tscadc\",\n\t.reg_bits = 32,\n\t.reg_stride = 4,\n\t.val_bits = 32,\n};\n\nvoid am335x_tsc_se_set_cache(struct ti_tscadc_dev *tscadc, u32 val)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tscadc->reg_lock, flags);\n\ttscadc->reg_se_cache |= val;\n\tif (tscadc->adc_waiting)\n\t\twake_up(&tscadc->reg_se_wait);\n\telse if (!tscadc->adc_in_use)\n\t\tregmap_write(tscadc->regmap, REG_SE, tscadc->reg_se_cache);\n\n\tspin_unlock_irqrestore(&tscadc->reg_lock, flags);\n}\nEXPORT_SYMBOL_GPL(am335x_tsc_se_set_cache);\n\nstatic void am335x_tscadc_need_adc(struct ti_tscadc_dev *tscadc)\n{\n\tDEFINE_WAIT(wait);\n\tu32 reg;\n\n\tregmap_read(tscadc->regmap, REG_ADCFSM, &reg);\n\tif (reg & SEQ_STATUS) {\n\t\ttscadc->adc_waiting = true;\n\t\tprepare_to_wait(&tscadc->reg_se_wait, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tspin_unlock_irq(&tscadc->reg_lock);\n\n\t\tschedule();\n\n\t\tspin_lock_irq(&tscadc->reg_lock);\n\t\tfinish_wait(&tscadc->reg_se_wait, &wait);\n\n\t\t \n\t\tregmap_read(tscadc->regmap, REG_ADCFSM, &reg);\n\t\tWARN_ON((reg & SEQ_STATUS) && !(reg & CHARGE_STEP));\n\t\ttscadc->adc_waiting = false;\n\t}\n\ttscadc->adc_in_use = true;\n}\n\nvoid am335x_tsc_se_set_once(struct ti_tscadc_dev *tscadc, u32 val)\n{\n\tspin_lock_irq(&tscadc->reg_lock);\n\tam335x_tscadc_need_adc(tscadc);\n\n\tregmap_write(tscadc->regmap, REG_SE, val);\n\tspin_unlock_irq(&tscadc->reg_lock);\n}\nEXPORT_SYMBOL_GPL(am335x_tsc_se_set_once);\n\nvoid am335x_tsc_se_adc_done(struct ti_tscadc_dev *tscadc)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tscadc->reg_lock, flags);\n\ttscadc->adc_in_use = false;\n\tregmap_write(tscadc->regmap, REG_SE, tscadc->reg_se_cache);\n\tspin_unlock_irqrestore(&tscadc->reg_lock, flags);\n}\nEXPORT_SYMBOL_GPL(am335x_tsc_se_adc_done);\n\nvoid am335x_tsc_se_clr(struct ti_tscadc_dev *tscadc, u32 val)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tscadc->reg_lock, flags);\n\ttscadc->reg_se_cache &= ~val;\n\tregmap_write(tscadc->regmap, REG_SE, tscadc->reg_se_cache);\n\tspin_unlock_irqrestore(&tscadc->reg_lock, flags);\n}\nEXPORT_SYMBOL_GPL(am335x_tsc_se_clr);\n\nstatic void tscadc_idle_config(struct ti_tscadc_dev *tscadc)\n{\n\tunsigned int idleconfig;\n\n\tidleconfig = STEPCONFIG_INM_ADCREFM | STEPCONFIG_INP_ADCREFM;\n\tif (ti_adc_with_touchscreen(tscadc))\n\t\tidleconfig |= STEPCONFIG_YNN | STEPCONFIG_YPN;\n\n\tregmap_write(tscadc->regmap, REG_IDLECONFIG, idleconfig);\n}\n\nstatic\tint ti_tscadc_probe(struct platform_device *pdev)\n{\n\tstruct ti_tscadc_dev *tscadc;\n\tstruct resource *res;\n\tstruct clk *clk;\n\tstruct device_node *node;\n\tstruct mfd_cell *cell;\n\tstruct property *prop;\n\tconst __be32 *cur;\n\tbool use_tsc = false, use_mag = false;\n\tu32 val;\n\tint err;\n\tint tscmag_wires = 0, adc_channels = 0, cell_idx = 0, total_channels;\n\tint readouts = 0, mag_tracks = 0;\n\n\t \n\ttscadc = devm_kzalloc(&pdev->dev, sizeof(*tscadc), GFP_KERNEL);\n\tif (!tscadc)\n\t\treturn -ENOMEM;\n\n\ttscadc->dev = &pdev->dev;\n\n\tif (!pdev->dev.of_node) {\n\t\tdev_err(&pdev->dev, \"Could not find valid DT data.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttscadc->data = of_device_get_match_data(&pdev->dev);\n\n\tif (ti_adc_with_touchscreen(tscadc)) {\n\t\tnode = of_get_child_by_name(pdev->dev.of_node, \"tsc\");\n\t\tof_property_read_u32(node, \"ti,wires\", &tscmag_wires);\n\t\terr = of_property_read_u32(node, \"ti,coordinate-readouts\",\n\t\t\t\t\t   &readouts);\n\t\tif (err < 0)\n\t\t\tof_property_read_u32(node, \"ti,coordiante-readouts\",\n\t\t\t\t\t     &readouts);\n\n\t\tof_node_put(node);\n\n\t\tif (tscmag_wires)\n\t\t\tuse_tsc = true;\n\t} else {\n\t\t \n\t\tmag_tracks = 0;\n\t\ttscmag_wires = mag_tracks * 2;\n\t\tif (tscmag_wires)\n\t\t\tuse_mag = true;\n\t}\n\n\tnode = of_get_child_by_name(pdev->dev.of_node, \"adc\");\n\tof_property_for_each_u32(node, \"ti,adc-channels\", prop, cur, val) {\n\t\tadc_channels++;\n\t\tif (val > 7) {\n\t\t\tdev_err(&pdev->dev, \" PIN numbers are 0..7 (not %d)\\n\",\n\t\t\t\tval);\n\t\t\tof_node_put(node);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tof_node_put(node);\n\n\ttotal_channels = tscmag_wires + adc_channels;\n\tif (total_channels > 8) {\n\t\tdev_err(&pdev->dev, \"Number of i/p channels more than 8\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (total_channels == 0) {\n\t\tdev_err(&pdev->dev, \"Need at least one channel.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (use_tsc && (readouts * 2 + 2 + adc_channels > 16)) {\n\t\tdev_err(&pdev->dev, \"Too many step configurations requested\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = platform_get_irq(pdev, 0);\n\tif (err < 0)\n\t\treturn err;\n\telse\n\t\ttscadc->irq = err;\n\n\ttscadc->tscadc_base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(tscadc->tscadc_base))\n\t\treturn PTR_ERR(tscadc->tscadc_base);\n\n\ttscadc->tscadc_phys_base = res->start;\n\ttscadc->regmap = devm_regmap_init_mmio(&pdev->dev,\n\t\t\t\t\t       tscadc->tscadc_base,\n\t\t\t\t\t       &tscadc_regmap_config);\n\tif (IS_ERR(tscadc->regmap)) {\n\t\tdev_err(&pdev->dev, \"regmap init failed\\n\");\n\t\treturn PTR_ERR(tscadc->regmap);\n\t}\n\n\tspin_lock_init(&tscadc->reg_lock);\n\tinit_waitqueue_head(&tscadc->reg_se_wait);\n\n\tpm_runtime_enable(&pdev->dev);\n\tpm_runtime_get_sync(&pdev->dev);\n\n\t \n\tclk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(clk)) {\n\t\tdev_err(&pdev->dev, \"failed to get fck\\n\");\n\t\terr = PTR_ERR(clk);\n\t\tgoto err_disable_clk;\n\t}\n\n\ttscadc->clk_div = (clk_get_rate(clk) / tscadc->data->target_clk_rate) - 1;\n\tregmap_write(tscadc->regmap, REG_CLKDIV, tscadc->clk_div);\n\n\t \n\ttscadc->ctrl = CNTRLREG_STEPID;\n\tif (ti_adc_with_touchscreen(tscadc)) {\n\t\ttscadc->ctrl |= CNTRLREG_TSC_STEPCONFIGWRT;\n\t\tif (use_tsc) {\n\t\t\ttscadc->ctrl |= CNTRLREG_TSC_ENB;\n\t\t\tif (tscmag_wires == 5)\n\t\t\t\ttscadc->ctrl |= CNTRLREG_TSC_5WIRE;\n\t\t\telse\n\t\t\t\ttscadc->ctrl |= CNTRLREG_TSC_4WIRE;\n\t\t}\n\t} else {\n\t\ttscadc->ctrl |= CNTRLREG_MAG_PREAMP_PWRDOWN |\n\t\t\t\tCNTRLREG_MAG_PREAMP_BYPASS;\n\t}\n\tregmap_write(tscadc->regmap, REG_CTRL, tscadc->ctrl);\n\n\ttscadc_idle_config(tscadc);\n\n\t \n\tregmap_write(tscadc->regmap, REG_CTRL, tscadc->ctrl | CNTRLREG_SSENB);\n\n\t \n\tif (use_tsc || use_mag) {\n\t\tcell = &tscadc->cells[cell_idx++];\n\t\tcell->name = tscadc->data->secondary_feature_name;\n\t\tcell->of_compatible = tscadc->data->secondary_feature_compatible;\n\t\tcell->platform_data = &tscadc;\n\t\tcell->pdata_size = sizeof(tscadc);\n\t}\n\n\t \n\tif (adc_channels > 0) {\n\t\tcell = &tscadc->cells[cell_idx++];\n\t\tcell->name = tscadc->data->adc_feature_name;\n\t\tcell->of_compatible = tscadc->data->adc_feature_compatible;\n\t\tcell->platform_data = &tscadc;\n\t\tcell->pdata_size = sizeof(tscadc);\n\t}\n\n\terr = mfd_add_devices(&pdev->dev, PLATFORM_DEVID_AUTO,\n\t\t\t      tscadc->cells, cell_idx, NULL, 0, NULL);\n\tif (err < 0)\n\t\tgoto err_disable_clk;\n\n\tplatform_set_drvdata(pdev, tscadc);\n\treturn 0;\n\nerr_disable_clk:\n\tpm_runtime_put_sync(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\n\treturn err;\n}\n\nstatic int ti_tscadc_remove(struct platform_device *pdev)\n{\n\tstruct ti_tscadc_dev *tscadc = platform_get_drvdata(pdev);\n\n\tregmap_write(tscadc->regmap, REG_SE, 0x00);\n\n\tpm_runtime_put_sync(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\n\tmfd_remove_devices(tscadc->dev);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused ti_tscadc_can_wakeup(struct device *dev, void *data)\n{\n\treturn device_may_wakeup(dev);\n}\n\nstatic int __maybe_unused tscadc_suspend(struct device *dev)\n{\n\tstruct ti_tscadc_dev *tscadc = dev_get_drvdata(dev);\n\n\tregmap_write(tscadc->regmap, REG_SE, 0x00);\n\tif (device_for_each_child(dev, NULL, ti_tscadc_can_wakeup)) {\n\t\tu32 ctrl;\n\n\t\tregmap_read(tscadc->regmap, REG_CTRL, &ctrl);\n\t\tctrl &= ~(CNTRLREG_POWERDOWN);\n\t\tctrl |= CNTRLREG_SSENB;\n\t\tregmap_write(tscadc->regmap, REG_CTRL, ctrl);\n\t}\n\tpm_runtime_put_sync(dev);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused tscadc_resume(struct device *dev)\n{\n\tstruct ti_tscadc_dev *tscadc = dev_get_drvdata(dev);\n\n\tpm_runtime_get_sync(dev);\n\n\tregmap_write(tscadc->regmap, REG_CLKDIV, tscadc->clk_div);\n\tregmap_write(tscadc->regmap, REG_CTRL, tscadc->ctrl);\n\ttscadc_idle_config(tscadc);\n\tregmap_write(tscadc->regmap, REG_CTRL, tscadc->ctrl | CNTRLREG_SSENB);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(tscadc_pm_ops, tscadc_suspend, tscadc_resume);\n\nstatic const struct ti_tscadc_data tscdata = {\n\t.adc_feature_name = \"TI-am335x-adc\",\n\t.adc_feature_compatible = \"ti,am3359-adc\",\n\t.secondary_feature_name = \"TI-am335x-tsc\",\n\t.secondary_feature_compatible = \"ti,am3359-tsc\",\n\t.target_clk_rate = TSC_ADC_CLK,\n};\n\nstatic const struct ti_tscadc_data magdata = {\n\t.adc_feature_name = \"TI-am43xx-adc\",\n\t.adc_feature_compatible = \"ti,am4372-adc\",\n\t.secondary_feature_name = \"TI-am43xx-mag\",\n\t.secondary_feature_compatible = \"ti,am4372-mag\",\n\t.target_clk_rate = MAG_ADC_CLK,\n};\n\nstatic const struct of_device_id ti_tscadc_dt_ids[] = {\n\t{ .compatible = \"ti,am3359-tscadc\", .data = &tscdata },\n\t{ .compatible = \"ti,am4372-magadc\", .data = &magdata },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ti_tscadc_dt_ids);\n\nstatic struct platform_driver ti_tscadc_driver = {\n\t.driver = {\n\t\t.name   = \"ti_am3359-tscadc\",\n\t\t.pm\t= &tscadc_pm_ops,\n\t\t.of_match_table = ti_tscadc_dt_ids,\n\t},\n\t.probe\t= ti_tscadc_probe,\n\t.remove\t= ti_tscadc_remove,\n\n};\n\nmodule_platform_driver(ti_tscadc_driver);\n\nMODULE_DESCRIPTION(\"TI touchscreen/magnetic stripe reader/ADC MFD controller driver\");\nMODULE_AUTHOR(\"Rachna Patil <rachna@ti.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}