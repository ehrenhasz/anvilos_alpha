{
  "module_name": "max77714.c",
  "hash_id": "2d72cbecea070b018eb2dfa150f404867bdead64302b3de85b1997acb290d62b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/max77714.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/max77714.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n\nstatic const struct mfd_cell max77714_cells[] = {\n\t{ .name = \"max77714-watchdog\" },\n\t{ .name = \"max77714-rtc\" },\n};\n\nstatic const struct regmap_range max77714_readable_ranges[] = {\n\tregmap_reg_range(MAX77714_INT_TOP,     MAX77714_INT_TOP),\n\tregmap_reg_range(MAX77714_INT_TOPM,    MAX77714_INT_TOPM),\n\tregmap_reg_range(MAX77714_32K_STATUS,  MAX77714_32K_CONFIG),\n\tregmap_reg_range(MAX77714_CNFG_GLBL2,  MAX77714_CNFG2_ONOFF),\n};\n\nstatic const struct regmap_range max77714_writable_ranges[] = {\n\tregmap_reg_range(MAX77714_INT_TOPM,    MAX77714_INT_TOPM),\n\tregmap_reg_range(MAX77714_32K_CONFIG,  MAX77714_32K_CONFIG),\n\tregmap_reg_range(MAX77714_CNFG_GLBL2,  MAX77714_CNFG2_ONOFF),\n};\n\nstatic const struct regmap_access_table max77714_readable_table = {\n\t.yes_ranges = max77714_readable_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(max77714_readable_ranges),\n};\n\nstatic const struct regmap_access_table max77714_writable_table = {\n\t.yes_ranges = max77714_writable_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(max77714_writable_ranges),\n};\n\nstatic const struct regmap_config max77714_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = MAX77714_CNFG2_ONOFF,\n\t.rd_table = &max77714_readable_table,\n\t.wr_table = &max77714_writable_table,\n};\n\nstatic const struct regmap_irq max77714_top_irqs[] = {\n\tREGMAP_IRQ_REG(MAX77714_IRQ_TOP_ONOFF,   0, MAX77714_INT_TOP_ONOFF),\n\tREGMAP_IRQ_REG(MAX77714_IRQ_TOP_RTC,     0, MAX77714_INT_TOP_RTC),\n\tREGMAP_IRQ_REG(MAX77714_IRQ_TOP_GPIO,    0, MAX77714_INT_TOP_GPIO),\n\tREGMAP_IRQ_REG(MAX77714_IRQ_TOP_LDO,     0, MAX77714_INT_TOP_LDO),\n\tREGMAP_IRQ_REG(MAX77714_IRQ_TOP_SD,      0, MAX77714_INT_TOP_SD),\n\tREGMAP_IRQ_REG(MAX77714_IRQ_TOP_GLBL,    0, MAX77714_INT_TOP_GLBL),\n};\n\nstatic const struct regmap_irq_chip max77714_irq_chip = {\n\t.name\t\t\t= \"max77714-pmic\",\n\t.status_base\t\t= MAX77714_INT_TOP,\n\t.mask_base\t\t= MAX77714_INT_TOPM,\n\t.num_regs\t\t= 1,\n\t.irqs\t\t\t= max77714_top_irqs,\n\t.num_irqs\t\t= ARRAY_SIZE(max77714_top_irqs),\n};\n\n \nstatic int max77714_setup_xosc(struct device *dev, struct regmap *regmap)\n{\n\t \n\tstatic const unsigned int load_cap[4] = {0, 10, 12, 22};  \n\tunsigned int load_cap_idx;\n\tunsigned int status;\n\tint err;\n\n\terr = regmap_update_bits(regmap, MAX77714_32K_CONFIG,\n\t\t\t\t MAX77714_32K_CONFIG_XOSC_RETRY,\n\t\t\t\t MAX77714_32K_CONFIG_XOSC_RETRY);\n\tif (err)\n\t\treturn dev_err_probe(dev, err, \"Failed to configure the external oscillator\\n\");\n\n\terr = regmap_read(regmap, MAX77714_32K_STATUS, &status);\n\tif (err)\n\t\treturn dev_err_probe(dev, err, \"Failed to read external oscillator status\\n\");\n\n\tload_cap_idx = (status >> MAX77714_32K_STATUS_32KLOAD_SHF)\n\t\t& MAX77714_32K_STATUS_32KLOAD_MSK;\n\n\tdev_info(dev, \"Using %s oscillator, %d pF load cap\\n\",\n\t\t status & MAX77714_32K_STATUS_32KSOURCE ? \"internal\" : \"external\",\n\t\t load_cap[load_cap_idx]);\n\n\treturn 0;\n}\n\nstatic int max77714_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct regmap *regmap;\n\tstruct regmap_irq_chip_data *irq_data;\n\tint err;\n\n\tregmap = devm_regmap_init_i2c(client, &max77714_regmap_config);\n\tif (IS_ERR(regmap))\n\t\treturn dev_err_probe(dev, PTR_ERR(regmap),\n\t\t\t\t     \"Failed to initialise regmap\\n\");\n\n\terr = max77714_setup_xosc(dev, regmap);\n\tif (err)\n\t\treturn err;\n\n\terr = devm_regmap_add_irq_chip(dev, regmap, client->irq,\n\t\t\t\t       IRQF_ONESHOT | IRQF_SHARED, 0,\n\t\t\t\t       &max77714_irq_chip, &irq_data);\n\tif (err)\n\t\treturn dev_err_probe(dev, err, \"Failed to add PMIC IRQ chip\\n\");\n\n\terr =  devm_mfd_add_devices(dev, PLATFORM_DEVID_NONE,\n\t\t\t\t    max77714_cells, ARRAY_SIZE(max77714_cells),\n\t\t\t\t    NULL, 0, NULL);\n\tif (err)\n\t\treturn dev_err_probe(dev, err, \"Failed to register child devices\\n\");\n\n\treturn 0;\n}\n\nstatic const struct of_device_id max77714_dt_match[] = {\n\t{ .compatible = \"maxim,max77714\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, max77714_dt_match);\n\nstatic struct i2c_driver max77714_driver = {\n\t.driver = {\n\t\t.name = \"max77714\",\n\t\t.of_match_table = max77714_dt_match,\n\t},\n\t.probe = max77714_probe,\n};\nmodule_i2c_driver(max77714_driver);\n\nMODULE_DESCRIPTION(\"Maxim MAX77714 MFD core driver\");\nMODULE_AUTHOR(\"Luca Ceresoli <luca.ceresoli@bootlin.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}