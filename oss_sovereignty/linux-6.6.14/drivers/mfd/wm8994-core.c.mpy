{
  "module_name": "wm8994-core.c",
  "hash_id": "7cc51f72b92532a1be6c0c03f85b47176ef15714da3b2803260049ece4fed06a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/wm8994-core.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/mfd/core.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/regulator/machine.h>\n\n#include <linux/mfd/wm8994/core.h>\n#include <linux/mfd/wm8994/pdata.h>\n#include <linux/mfd/wm8994/registers.h>\n\n#include \"wm8994.h\"\n\nstatic const struct mfd_cell wm8994_regulator_devs[] = {\n\t{\n\t\t.name = \"wm8994-ldo\",\n\t\t.id = 0,\n\t\t.pm_runtime_no_callbacks = true,\n\t},\n\t{\n\t\t.name = \"wm8994-ldo\",\n\t\t.id = 1,\n\t\t.pm_runtime_no_callbacks = true,\n\t},\n};\n\nstatic const struct resource wm8994_codec_resources[] = {\n\t{\n\t\t.start = WM8994_IRQ_TEMP_SHUT,\n\t\t.end   = WM8994_IRQ_TEMP_WARN,\n\t\t.flags = IORESOURCE_IRQ,\n\t},\n};\n\nstatic const struct resource wm8994_gpio_resources[] = {\n\t{\n\t\t.start = WM8994_IRQ_GPIO(1),\n\t\t.end   = WM8994_IRQ_GPIO(11),\n\t\t.flags = IORESOURCE_IRQ,\n\t},\n};\n\nstatic const struct mfd_cell wm8994_devs[] = {\n\t{\n\t\t.name = \"wm8994-codec\",\n\t\t.num_resources = ARRAY_SIZE(wm8994_codec_resources),\n\t\t.resources = wm8994_codec_resources,\n\t},\n\n\t{\n\t\t.name = \"wm8994-gpio\",\n\t\t.num_resources = ARRAY_SIZE(wm8994_gpio_resources),\n\t\t.resources = wm8994_gpio_resources,\n\t\t.pm_runtime_no_callbacks = true,\n\t},\n};\n\n \nstatic const char *wm1811_main_supplies[] = {\n\t\"DBVDD1\",\n\t\"DBVDD2\",\n\t\"DBVDD3\",\n\t\"DCVDD\",\n\t\"AVDD1\",\n\t\"AVDD2\",\n\t\"CPVDD\",\n\t\"SPKVDD1\",\n\t\"SPKVDD2\",\n};\n\nstatic const char *wm8994_main_supplies[] = {\n\t\"DBVDD\",\n\t\"DCVDD\",\n\t\"AVDD1\",\n\t\"AVDD2\",\n\t\"CPVDD\",\n\t\"SPKVDD1\",\n\t\"SPKVDD2\",\n};\n\nstatic const char *wm8958_main_supplies[] = {\n\t\"DBVDD1\",\n\t\"DBVDD2\",\n\t\"DBVDD3\",\n\t\"DCVDD\",\n\t\"AVDD1\",\n\t\"AVDD2\",\n\t\"CPVDD\",\n\t\"SPKVDD1\",\n\t\"SPKVDD2\",\n};\n\nstatic int wm8994_suspend(struct device *dev)\n{\n\tstruct wm8994 *wm8994 = dev_get_drvdata(dev);\n\tint ret;\n\n\t \n\tswitch (wm8994->type) {\n\tcase WM8958:\n\tcase WM1811:\n\t\tret = wm8994_reg_read(wm8994, WM8958_MIC_DETECT_1);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Failed to read power status: %d\\n\", ret);\n\t\t} else if (ret & WM8958_MICD_ENA) {\n\t\t\tdev_dbg(dev, \"CODEC still active, ignoring suspend\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tif (!wm8994->ldo_ena_always_driven)\n\t\twm8994_set_bits(wm8994, WM8994_PULL_CONTROL_2,\n\t\t\t\tWM8994_LDO1ENA_PD | WM8994_LDO2ENA_PD,\n\t\t\t\tWM8994_LDO1ENA_PD | WM8994_LDO2ENA_PD);\n\n\t \n\twm8994_reg_write(wm8994, WM8994_SOFTWARE_RESET,\n\t\t\t wm8994_reg_read(wm8994, WM8994_SOFTWARE_RESET));\n\n\tregcache_mark_dirty(wm8994->regmap);\n\n\t \n\tret = regcache_sync_region(wm8994->regmap, WM8994_GPIO_1,\n\t\t\t\t   WM8994_GPIO_11);\n\tif (ret != 0)\n\t\tdev_err(dev, \"Failed to restore GPIO registers: %d\\n\", ret);\n\n\t \n\tret = regcache_sync_region(wm8994->regmap,\n\t\t\t\t   WM8994_INTERRUPT_STATUS_1_MASK,\n\t\t\t\t   WM8994_INTERRUPT_STATUS_1_MASK);\n\tif (ret != 0)\n\t\tdev_err(dev, \"Failed to restore interrupt mask: %d\\n\", ret);\n\n\tregcache_cache_only(wm8994->regmap, true);\n\twm8994->suspended = true;\n\n\tret = regulator_bulk_disable(wm8994->num_supplies,\n\t\t\t\t     wm8994->supplies);\n\tif (ret != 0) {\n\t\tdev_err(dev, \"Failed to disable supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int wm8994_resume(struct device *dev)\n{\n\tstruct wm8994 *wm8994 = dev_get_drvdata(dev);\n\tint ret;\n\n\t \n\tif (!wm8994->suspended)\n\t\treturn 0;\n\n\tret = regulator_bulk_enable(wm8994->num_supplies,\n\t\t\t\t    wm8994->supplies);\n\tif (ret != 0) {\n\t\tdev_err(dev, \"Failed to enable supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tregcache_cache_only(wm8994->regmap, false);\n\tret = regcache_sync(wm8994->regmap);\n\tif (ret != 0) {\n\t\tdev_err(dev, \"Failed to restore register map: %d\\n\", ret);\n\t\tgoto err_enable;\n\t}\n\n\t \n\twm8994_set_bits(wm8994, WM8994_PULL_CONTROL_2,\n\t\t\tWM8994_LDO1ENA_PD | WM8994_LDO2ENA_PD,\n\t\t\t0);\n\n\twm8994->suspended = false;\n\n\treturn 0;\n\nerr_enable:\n\tregulator_bulk_disable(wm8994->num_supplies, wm8994->supplies);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_REGULATOR\nstatic int wm8994_ldo_in_use(struct wm8994_pdata *pdata, int ldo)\n{\n\tstruct wm8994_ldo_pdata *ldo_pdata;\n\n\tif (!pdata)\n\t\treturn 0;\n\n\tldo_pdata = &pdata->ldo[ldo];\n\n\tif (!ldo_pdata->init_data)\n\t\treturn 0;\n\n\treturn ldo_pdata->init_data->num_consumer_supplies != 0;\n}\n#else\nstatic int wm8994_ldo_in_use(struct wm8994_pdata *pdata, int ldo)\n{\n\treturn 0;\n}\n#endif\n\nstatic const struct reg_sequence wm8994_revc_patch[] = {\n\t{ 0x102, 0x3 },\n\t{ 0x56, 0x3 },\n\t{ 0x817, 0x0 },\n\t{ 0x102, 0x0 },\n};\n\nstatic const struct reg_sequence wm8958_reva_patch[] = {\n\t{ 0x102, 0x3 },\n\t{ 0xcb, 0x81 },\n\t{ 0x817, 0x0 },\n\t{ 0x102, 0x0 },\n};\n\nstatic const struct reg_sequence wm1811_reva_patch[] = {\n\t{ 0x102, 0x3 },\n\t{ 0x56, 0xc07 },\n\t{ 0x5d, 0x7e },\n\t{ 0x5e, 0x0 },\n\t{ 0x102, 0x0 },\n};\n\n#ifdef CONFIG_OF\nstatic int wm8994_set_pdata_from_of(struct wm8994 *wm8994)\n{\n\tstruct device_node *np = wm8994->dev->of_node;\n\tstruct wm8994_pdata *pdata = &wm8994->pdata;\n\tint i;\n\n\tif (!np)\n\t\treturn 0;\n\n\tif (of_property_read_u32_array(np, \"wlf,gpio-cfg\", pdata->gpio_defaults,\n\t\t\t\t       ARRAY_SIZE(pdata->gpio_defaults)) >= 0) {\n\t\tfor (i = 0; i < ARRAY_SIZE(pdata->gpio_defaults); i++) {\n\t\t\tif (wm8994->pdata.gpio_defaults[i] == 0)\n\t\t\t\tpdata->gpio_defaults[i]\n\t\t\t\t\t= WM8994_CONFIGURE_GPIO;\n\t\t}\n\t}\n\n\tof_property_read_u32_array(np, \"wlf,micbias-cfg\", pdata->micbias,\n\t\t\t\t   ARRAY_SIZE(pdata->micbias));\n\n\tpdata->lineout1_diff = !of_property_read_bool(np, \"wlf,lineout1-se\");\n\tpdata->lineout2_diff = !of_property_read_bool(np, \"wlf,lineout2-se\");\n\tpdata->lineout1fb = of_property_read_bool(np, \"wlf,lineout1-feedback\");\n\tpdata->lineout2fb = of_property_read_bool(np, \"wlf,lineout2-feedback\") ||\n\t\tof_property_read_bool(np, \"wlf,ldoena-always-driven\");\n\n\tpdata->spkmode_pu = of_property_read_bool(np, \"wlf,spkmode-pu\");\n\n\tpdata->csnaddr_pd = of_property_read_bool(np, \"wlf,csnaddr-pd\");\n\n\treturn 0;\n}\n#else\nstatic int wm8994_set_pdata_from_of(struct wm8994 *wm8994)\n{\n\treturn 0;\n}\n#endif\n\n \nstatic int wm8994_device_init(struct wm8994 *wm8994, int irq)\n{\n\tstruct wm8994_pdata *pdata;\n\tstruct regmap_config *regmap_config;\n\tconst struct reg_sequence *regmap_patch = NULL;\n\tconst char *devname;\n\tint ret, i, patch_regs = 0;\n\tint pulls = 0;\n\n\tif (dev_get_platdata(wm8994->dev)) {\n\t\tpdata = dev_get_platdata(wm8994->dev);\n\t\twm8994->pdata = *pdata;\n\t}\n\tpdata = &wm8994->pdata;\n\n\tret = wm8994_set_pdata_from_of(wm8994);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t \n\tret = mfd_add_devices(wm8994->dev, 0,\n\t\t\t      wm8994_regulator_devs,\n\t\t\t      ARRAY_SIZE(wm8994_regulator_devs),\n\t\t\t      NULL, 0, NULL);\n\tif (ret != 0) {\n\t\tdev_err(wm8994->dev, \"Failed to add children: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tswitch (wm8994->type) {\n\tcase WM1811:\n\t\twm8994->num_supplies = ARRAY_SIZE(wm1811_main_supplies);\n\t\tbreak;\n\tcase WM8994:\n\t\twm8994->num_supplies = ARRAY_SIZE(wm8994_main_supplies);\n\t\tbreak;\n\tcase WM8958:\n\t\twm8994->num_supplies = ARRAY_SIZE(wm8958_main_supplies);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tgoto err;\n\t}\n\n\twm8994->supplies = devm_kcalloc(wm8994->dev,\n\t\t\t\t\twm8994->num_supplies,\n\t\t\t\t\tsizeof(struct regulator_bulk_data),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!wm8994->supplies) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tswitch (wm8994->type) {\n\tcase WM1811:\n\t\tfor (i = 0; i < ARRAY_SIZE(wm1811_main_supplies); i++)\n\t\t\twm8994->supplies[i].supply = wm1811_main_supplies[i];\n\t\tbreak;\n\tcase WM8994:\n\t\tfor (i = 0; i < ARRAY_SIZE(wm8994_main_supplies); i++)\n\t\t\twm8994->supplies[i].supply = wm8994_main_supplies[i];\n\t\tbreak;\n\tcase WM8958:\n\t\tfor (i = 0; i < ARRAY_SIZE(wm8958_main_supplies); i++)\n\t\t\twm8994->supplies[i].supply = wm8958_main_supplies[i];\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tgoto err;\n\t}\n\n\t \n\tret = regulator_bulk_get(wm8994->dev, wm8994->num_supplies,\n\t\t\t\t wm8994->supplies);\n\tif (ret != 0) {\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(wm8994->dev, \"Failed to get supplies: %d\\n\",\n\t\t\t\tret);\n\t\tgoto err;\n\t}\n\n\tret = regulator_bulk_enable(wm8994->num_supplies, wm8994->supplies);\n\tif (ret != 0) {\n\t\tdev_err(wm8994->dev, \"Failed to enable supplies: %d\\n\", ret);\n\t\tgoto err_regulator_free;\n\t}\n\n\tret = wm8994_reg_read(wm8994, WM8994_SOFTWARE_RESET);\n\tif (ret < 0) {\n\t\tdev_err(wm8994->dev, \"Failed to read ID register\\n\");\n\t\tgoto err_enable;\n\t}\n\tswitch (ret) {\n\tcase 0x1811:\n\t\tdevname = \"WM1811\";\n\t\tif (wm8994->type != WM1811)\n\t\t\tdev_warn(wm8994->dev, \"Device registered as type %d\\n\",\n\t\t\t\t wm8994->type);\n\t\twm8994->type = WM1811;\n\t\tbreak;\n\tcase 0x8994:\n\t\tdevname = \"WM8994\";\n\t\tif (wm8994->type != WM8994)\n\t\t\tdev_warn(wm8994->dev, \"Device registered as type %d\\n\",\n\t\t\t\t wm8994->type);\n\t\twm8994->type = WM8994;\n\t\tbreak;\n\tcase 0x8958:\n\t\tdevname = \"WM8958\";\n\t\tif (wm8994->type != WM8958)\n\t\t\tdev_warn(wm8994->dev, \"Device registered as type %d\\n\",\n\t\t\t\t wm8994->type);\n\t\twm8994->type = WM8958;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(wm8994->dev, \"Device is not a WM8994, ID is %x\\n\",\n\t\t\tret);\n\t\tret = -EINVAL;\n\t\tgoto err_enable;\n\t}\n\n\tret = wm8994_reg_read(wm8994, WM8994_CHIP_REVISION);\n\tif (ret < 0) {\n\t\tdev_err(wm8994->dev, \"Failed to read revision register: %d\\n\",\n\t\t\tret);\n\t\tgoto err_enable;\n\t}\n\twm8994->revision = ret & WM8994_CHIP_REV_MASK;\n\twm8994->cust_id = (ret & WM8994_CUST_ID_MASK) >> WM8994_CUST_ID_SHIFT;\n\n\tswitch (wm8994->type) {\n\tcase WM8994:\n\t\tswitch (wm8994->revision) {\n\t\tcase 0:\n\t\tcase 1:\n\t\t\tdev_warn(wm8994->dev,\n\t\t\t\t \"revision %c not fully supported\\n\",\n\t\t\t\t 'A' + wm8994->revision);\n\t\t\tbreak;\n\t\tcase 2:\n\t\tcase 3:\n\t\tdefault:\n\t\t\tregmap_patch = wm8994_revc_patch;\n\t\t\tpatch_regs = ARRAY_SIZE(wm8994_revc_patch);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase WM8958:\n\t\tswitch (wm8994->revision) {\n\t\tcase 0:\n\t\t\tregmap_patch = wm8958_reva_patch;\n\t\t\tpatch_regs = ARRAY_SIZE(wm8958_reva_patch);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase WM1811:\n\t\t \n\t\tif (wm8994->revision > 1)\n\t\t\twm8994->revision++;\n\n\t\tregmap_patch = wm1811_reva_patch;\n\t\tpatch_regs = ARRAY_SIZE(wm1811_reva_patch);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tdev_info(wm8994->dev, \"%s revision %c CUST_ID %02x\\n\", devname,\n\t\t 'A' + wm8994->revision, wm8994->cust_id);\n\n\tswitch (wm8994->type) {\n\tcase WM1811:\n\t\tregmap_config = &wm1811_regmap_config;\n\t\tbreak;\n\tcase WM8994:\n\t\tregmap_config = &wm8994_regmap_config;\n\t\tbreak;\n\tcase WM8958:\n\t\tregmap_config = &wm8958_regmap_config;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(wm8994->dev, \"Unknown device type %d\\n\", wm8994->type);\n\t\tret = -EINVAL;\n\t\tgoto err_enable;\n\t}\n\n\tret = regmap_reinit_cache(wm8994->regmap, regmap_config);\n\tif (ret != 0) {\n\t\tdev_err(wm8994->dev, \"Failed to reinit register cache: %d\\n\",\n\t\t\tret);\n\t\tgoto err_enable;\n\t}\n\n\t \n\tret = wm8994_reg_write(wm8994, WM8994_SOFTWARE_RESET,\n\t\t\t       wm8994_reg_read(wm8994, WM8994_SOFTWARE_RESET));\n\tif (ret != 0) {\n\t\tdev_err(wm8994->dev, \"Failed to reset device: %d\\n\", ret);\n\t\tgoto err_enable;\n\t}\n\n\tif (regmap_patch) {\n\t\tret = regmap_register_patch(wm8994->regmap, regmap_patch,\n\t\t\t\t\t    patch_regs);\n\t\tif (ret != 0) {\n\t\t\tdev_err(wm8994->dev, \"Failed to register patch: %d\\n\",\n\t\t\t\tret);\n\t\t\tgoto err_enable;\n\t\t}\n\t}\n\n\twm8994->irq_base = pdata->irq_base;\n\twm8994->gpio_base = pdata->gpio_base;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(pdata->gpio_defaults); i++) {\n\t\tif (pdata->gpio_defaults[i]) {\n\t\t\twm8994_set_bits(wm8994, WM8994_GPIO_1 + i,\n\t\t\t\t\t0xffff, pdata->gpio_defaults[i]);\n\t\t}\n\t}\n\n\twm8994->ldo_ena_always_driven = pdata->ldo_ena_always_driven;\n\n\tif (pdata->spkmode_pu)\n\t\tpulls |= WM8994_SPKMODE_PU;\n\tif (pdata->csnaddr_pd)\n\t\tpulls |= WM8994_CSNADDR_PD;\n\n\t \n\twm8994_set_bits(wm8994, WM8994_PULL_CONTROL_2,\n\t\t\tWM8994_LDO1ENA_PD | WM8994_LDO2ENA_PD |\n\t\t\tWM8994_SPKMODE_PU | WM8994_CSNADDR_PD,\n\t\t\tpulls);\n\n\t \n\tfor (i = 0; i < WM8994_NUM_LDO_REGS; i++) {\n\t\tif (wm8994_ldo_in_use(pdata, i))\n\t\t\twm8994_set_bits(wm8994, WM8994_LDO_1 + i,\n\t\t\t\t\tWM8994_LDO1_DISCH, WM8994_LDO1_DISCH);\n\t\telse\n\t\t\twm8994_set_bits(wm8994, WM8994_LDO_1 + i,\n\t\t\t\t\tWM8994_LDO1_DISCH, 0);\n\t}\n\n\twm8994_irq_init(wm8994);\n\n\tret = mfd_add_devices(wm8994->dev, -1,\n\t\t\t      wm8994_devs, ARRAY_SIZE(wm8994_devs),\n\t\t\t      NULL, 0, NULL);\n\tif (ret != 0) {\n\t\tdev_err(wm8994->dev, \"Failed to add children: %d\\n\", ret);\n\t\tgoto err_irq;\n\t}\n\n\tpm_runtime_set_active(wm8994->dev);\n\tpm_runtime_enable(wm8994->dev);\n\tpm_runtime_idle(wm8994->dev);\n\n\treturn 0;\n\nerr_irq:\n\twm8994_irq_exit(wm8994);\nerr_enable:\n\tregulator_bulk_disable(wm8994->num_supplies,\n\t\t\t       wm8994->supplies);\nerr_regulator_free:\n\tregulator_bulk_free(wm8994->num_supplies, wm8994->supplies);\nerr:\n\tmfd_remove_devices(wm8994->dev);\n\treturn ret;\n}\n\nstatic void wm8994_device_exit(struct wm8994 *wm8994)\n{\n\tpm_runtime_get_sync(wm8994->dev);\n\tpm_runtime_disable(wm8994->dev);\n\tpm_runtime_put_noidle(wm8994->dev);\n\twm8994_irq_exit(wm8994);\n\tregulator_bulk_disable(wm8994->num_supplies, wm8994->supplies);\n\tregulator_bulk_free(wm8994->num_supplies, wm8994->supplies);\n\tmfd_remove_devices(wm8994->dev);\n}\n\nstatic const struct of_device_id wm8994_of_match[] = {\n\t{ .compatible = \"wlf,wm1811\", .data = (void *)WM1811 },\n\t{ .compatible = \"wlf,wm8994\", .data = (void *)WM8994 },\n\t{ .compatible = \"wlf,wm8958\", .data = (void *)WM8958 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, wm8994_of_match);\n\nstatic int wm8994_i2c_probe(struct i2c_client *i2c)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(i2c);\n\tconst struct of_device_id *of_id;\n\tstruct wm8994 *wm8994;\n\tint ret;\n\n\twm8994 = devm_kzalloc(&i2c->dev, sizeof(struct wm8994), GFP_KERNEL);\n\tif (wm8994 == NULL)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(i2c, wm8994);\n\twm8994->dev = &i2c->dev;\n\twm8994->irq = i2c->irq;\n\n\tif (i2c->dev.of_node) {\n\t\tof_id = of_match_device(wm8994_of_match, &i2c->dev);\n\t\tif (of_id)\n\t\t\twm8994->type = (uintptr_t)of_id->data;\n\t} else {\n\t\twm8994->type = id->driver_data;\n\t}\n\n\twm8994->regmap = devm_regmap_init_i2c(i2c, &wm8994_base_regmap_config);\n\tif (IS_ERR(wm8994->regmap)) {\n\t\tret = PTR_ERR(wm8994->regmap);\n\t\tdev_err(wm8994->dev, \"Failed to allocate register map: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\treturn wm8994_device_init(wm8994, i2c->irq);\n}\n\nstatic void wm8994_i2c_remove(struct i2c_client *i2c)\n{\n\tstruct wm8994 *wm8994 = i2c_get_clientdata(i2c);\n\n\twm8994_device_exit(wm8994);\n}\n\nstatic const struct i2c_device_id wm8994_i2c_id[] = {\n\t{ \"wm1811\", WM1811 },\n\t{ \"wm1811a\", WM1811 },\n\t{ \"wm8994\", WM8994 },\n\t{ \"wm8958\", WM8958 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, wm8994_i2c_id);\n\nstatic const struct dev_pm_ops wm8994_pm_ops = {\n\tRUNTIME_PM_OPS(wm8994_suspend, wm8994_resume, NULL)\n};\n\nstatic struct i2c_driver wm8994_i2c_driver = {\n\t.driver = {\n\t\t.name = \"wm8994\",\n\t\t.pm = pm_ptr(&wm8994_pm_ops),\n\t\t.of_match_table = wm8994_of_match,\n\t},\n\t.probe = wm8994_i2c_probe,\n\t.remove = wm8994_i2c_remove,\n\t.id_table = wm8994_i2c_id,\n};\n\nmodule_i2c_driver(wm8994_i2c_driver);\n\nMODULE_DESCRIPTION(\"Core support for the WM8994 audio CODEC\");\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Mark Brown <broonie@opensource.wolfsonmicro.com>\");\nMODULE_SOFTDEP(\"pre: wm8994_regulator\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}