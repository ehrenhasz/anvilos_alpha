{
  "module_name": "wm8350-core.c",
  "hash_id": "ce034c7253ba1e0203137d1e8afd0d24eef0f3b37856335843c5d1016824e41e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/wm8350-core.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/bug.h>\n#include <linux/device.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/regmap.h>\n#include <linux/workqueue.h>\n\n#include <linux/mfd/wm8350/core.h>\n#include <linux/mfd/wm8350/audio.h>\n#include <linux/mfd/wm8350/comparator.h>\n#include <linux/mfd/wm8350/gpio.h>\n#include <linux/mfd/wm8350/pmic.h>\n#include <linux/mfd/wm8350/rtc.h>\n#include <linux/mfd/wm8350/supply.h>\n#include <linux/mfd/wm8350/wdt.h>\n\n#define WM8350_CLOCK_CONTROL_1\t\t0x28\n#define WM8350_AIF_TEST\t\t\t0x74\n\n \n#define WM8350_BUS_DEBUG 0\n#if WM8350_BUS_DEBUG\n#define dump(regs, src) do { \\\n\tint i_; \\\n\tu16 *src_ = src; \\\n\tprintk(KERN_DEBUG); \\\n\tfor (i_ = 0; i_ < regs; i_++) \\\n\t\tprintk(\" 0x%4.4x\", *src_++); \\\n\tprintk(\"\\n\"); \\\n} while (0);\n#else\n#define dump(bytes, src)\n#endif\n\n#define WM8350_LOCK_DEBUG 0\n#if WM8350_LOCK_DEBUG\n#define ldbg(format, arg...) printk(format, ## arg)\n#else\n#define ldbg(format, arg...)\n#endif\n\n \nstatic DEFINE_MUTEX(reg_lock_mutex);\n\n \nint wm8350_clear_bits(struct wm8350 *wm8350, u16 reg, u16 mask)\n{\n\treturn regmap_update_bits(wm8350->regmap, reg, mask, 0);\n}\nEXPORT_SYMBOL_GPL(wm8350_clear_bits);\n\nint wm8350_set_bits(struct wm8350 *wm8350, u16 reg, u16 mask)\n{\n\treturn regmap_update_bits(wm8350->regmap, reg, mask, mask);\n}\nEXPORT_SYMBOL_GPL(wm8350_set_bits);\n\nu16 wm8350_reg_read(struct wm8350 *wm8350, int reg)\n{\n\tunsigned int data;\n\tint err;\n\n\terr = regmap_read(wm8350->regmap, reg, &data);\n\tif (err)\n\t\tdev_err(wm8350->dev, \"read from reg R%d failed\\n\", reg);\n\n\treturn data;\n}\nEXPORT_SYMBOL_GPL(wm8350_reg_read);\n\nint wm8350_reg_write(struct wm8350 *wm8350, int reg, u16 val)\n{\n\tint ret;\n\n\tret = regmap_write(wm8350->regmap, reg, val);\n\n\tif (ret)\n\t\tdev_err(wm8350->dev, \"write to reg R%d failed\\n\", reg);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(wm8350_reg_write);\n\nint wm8350_block_read(struct wm8350 *wm8350, int start_reg, int regs,\n\t\t      u16 *dest)\n{\n\tint err = 0;\n\n\terr = regmap_bulk_read(wm8350->regmap, start_reg, dest, regs);\n\tif (err)\n\t\tdev_err(wm8350->dev, \"block read starting from R%d failed\\n\",\n\t\t\tstart_reg);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(wm8350_block_read);\n\nint wm8350_block_write(struct wm8350 *wm8350, int start_reg, int regs,\n\t\t       u16 *src)\n{\n\tint ret = 0;\n\n\tret = regmap_bulk_write(wm8350->regmap, start_reg, src, regs);\n\tif (ret)\n\t\tdev_err(wm8350->dev, \"block write starting at R%d failed\\n\",\n\t\t\tstart_reg);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(wm8350_block_write);\n\n \nint wm8350_reg_lock(struct wm8350 *wm8350)\n{\n\tint ret;\n\n\tmutex_lock(&reg_lock_mutex);\n\n\tldbg(__func__);\n\n\tret = wm8350_reg_write(wm8350, WM8350_SECURITY, WM8350_LOCK_KEY);\n\tif (ret)\n\t\tdev_err(wm8350->dev, \"lock failed\\n\");\n\n\twm8350->unlocked = false;\n\n\tmutex_unlock(&reg_lock_mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(wm8350_reg_lock);\n\n \nint wm8350_reg_unlock(struct wm8350 *wm8350)\n{\n\tint ret;\n\n\tmutex_lock(&reg_lock_mutex);\n\n\tldbg(__func__);\n\n\tret = wm8350_reg_write(wm8350, WM8350_SECURITY, WM8350_UNLOCK_KEY);\n\tif (ret)\n\t\tdev_err(wm8350->dev, \"unlock failed\\n\");\n\n\twm8350->unlocked = true;\n\n\tmutex_unlock(&reg_lock_mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(wm8350_reg_unlock);\n\nint wm8350_read_auxadc(struct wm8350 *wm8350, int channel, int scale, int vref)\n{\n\tu16 reg, result = 0;\n\n\tif (channel < WM8350_AUXADC_AUX1 || channel > WM8350_AUXADC_TEMP)\n\t\treturn -EINVAL;\n\tif (channel >= WM8350_AUXADC_USB && channel <= WM8350_AUXADC_TEMP\n\t    && (scale != 0 || vref != 0))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&wm8350->auxadc_mutex);\n\n\t \n\treg = wm8350_reg_read(wm8350, WM8350_POWER_MGMT_5);\n\twm8350_reg_write(wm8350, WM8350_POWER_MGMT_5, reg | WM8350_AUXADC_ENA);\n\n\tif (scale || vref) {\n\t\treg = scale << 13;\n\t\treg |= vref << 12;\n\t\twm8350_reg_write(wm8350, WM8350_AUX1_READBACK + channel, reg);\n\t}\n\n\treg = wm8350_reg_read(wm8350, WM8350_DIGITISER_CONTROL_1);\n\treg |= 1 << channel | WM8350_AUXADC_POLL;\n\twm8350_reg_write(wm8350, WM8350_DIGITISER_CONTROL_1, reg);\n\n\t \n\ttry_wait_for_completion(&wm8350->auxadc_done);\n\n\t \n\twait_for_completion_timeout(&wm8350->auxadc_done, msecs_to_jiffies(5));\n\n\treg = wm8350_reg_read(wm8350, WM8350_DIGITISER_CONTROL_1);\n\tif (reg & WM8350_AUXADC_POLL)\n\t\tdev_err(wm8350->dev, \"adc chn %d read timeout\\n\", channel);\n\telse\n\t\tresult = wm8350_reg_read(wm8350,\n\t\t\t\t\t WM8350_AUX1_READBACK + channel);\n\n\t \n\treg = wm8350_reg_read(wm8350, WM8350_POWER_MGMT_5);\n\twm8350_reg_write(wm8350, WM8350_POWER_MGMT_5,\n\t\t\t reg & ~WM8350_AUXADC_ENA);\n\n\tmutex_unlock(&wm8350->auxadc_mutex);\n\n\treturn result & WM8350_AUXADC_DATA1_MASK;\n}\nEXPORT_SYMBOL_GPL(wm8350_read_auxadc);\n\nstatic irqreturn_t wm8350_auxadc_irq(int irq, void *irq_data)\n{\n\tstruct wm8350 *wm8350 = irq_data;\n\n\tcomplete(&wm8350->auxadc_done);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void wm8350_client_dev_register(struct wm8350 *wm8350,\n\t\t\t\t       const char *name,\n\t\t\t\t       struct platform_device **pdev)\n{\n\tint ret;\n\n\t*pdev = platform_device_alloc(name, -1);\n\tif (*pdev == NULL) {\n\t\tdev_err(wm8350->dev, \"Failed to allocate %s\\n\", name);\n\t\treturn;\n\t}\n\n\t(*pdev)->dev.parent = wm8350->dev;\n\tplatform_set_drvdata(*pdev, wm8350);\n\tret = platform_device_add(*pdev);\n\tif (ret != 0) {\n\t\tdev_err(wm8350->dev, \"Failed to register %s: %d\\n\", name, ret);\n\t\tplatform_device_put(*pdev);\n\t\t*pdev = NULL;\n\t}\n}\n\nint wm8350_device_init(struct wm8350 *wm8350, int irq,\n\t\t       struct wm8350_platform_data *pdata)\n{\n\tint ret;\n\tunsigned int id1, id2, mask_rev;\n\tunsigned int cust_id, mode, chip_rev;\n\n\tdev_set_drvdata(wm8350->dev, wm8350);\n\n\t \n\tret = regmap_read(wm8350->regmap, WM8350_RESET_ID, &id1);\n\tif (ret != 0) {\n\t\tdev_err(wm8350->dev, \"Failed to read ID: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tret = regmap_read(wm8350->regmap, WM8350_ID, &id2);\n\tif (ret != 0) {\n\t\tdev_err(wm8350->dev, \"Failed to read ID: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tret = regmap_read(wm8350->regmap, WM8350_REVISION, &mask_rev);\n\tif (ret != 0) {\n\t\tdev_err(wm8350->dev, \"Failed to read revision: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tif (id1 != 0x6143) {\n\t\tdev_err(wm8350->dev,\n\t\t\t\"Device with ID %x is not a WM8350\\n\", id1);\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\tmode = (id2 & WM8350_CONF_STS_MASK) >> 10;\n\tcust_id = id2 & WM8350_CUST_ID_MASK;\n\tchip_rev = (id2 & WM8350_CHIP_REV_MASK) >> 12;\n\tdev_info(wm8350->dev,\n\t\t \"CONF_STS %d, CUST_ID %d, MASK_REV %d, CHIP_REV %d\\n\",\n\t\t mode, cust_id, mask_rev, chip_rev);\n\n\tif (cust_id != 0) {\n\t\tdev_err(wm8350->dev, \"Unsupported CUST_ID\\n\");\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\tswitch (mask_rev) {\n\tcase 0:\n\t\twm8350->pmic.max_dcdc = WM8350_DCDC_6;\n\t\twm8350->pmic.max_isink = WM8350_ISINK_B;\n\n\t\tswitch (chip_rev) {\n\t\tcase WM8350_REV_E:\n\t\t\tdev_info(wm8350->dev, \"WM8350 Rev E\\n\");\n\t\t\tbreak;\n\t\tcase WM8350_REV_F:\n\t\t\tdev_info(wm8350->dev, \"WM8350 Rev F\\n\");\n\t\t\tbreak;\n\t\tcase WM8350_REV_G:\n\t\t\tdev_info(wm8350->dev, \"WM8350 Rev G\\n\");\n\t\t\twm8350->power.rev_g_coeff = 1;\n\t\t\tbreak;\n\t\tcase WM8350_REV_H:\n\t\t\tdev_info(wm8350->dev, \"WM8350 Rev H\\n\");\n\t\t\twm8350->power.rev_g_coeff = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tdev_err(wm8350->dev, \"Unknown WM8350 CHIP_REV\\n\");\n\t\t\tret = -ENODEV;\n\t\t\tgoto err;\n\t\t}\n\t\tbreak;\n\n\tcase 1:\n\t\twm8350->pmic.max_dcdc = WM8350_DCDC_4;\n\t\twm8350->pmic.max_isink = WM8350_ISINK_A;\n\n\t\tswitch (chip_rev) {\n\t\tcase 0:\n\t\t\tdev_info(wm8350->dev, \"WM8351 Rev A\\n\");\n\t\t\twm8350->power.rev_g_coeff = 1;\n\t\t\tbreak;\n\n\t\tcase 1:\n\t\t\tdev_info(wm8350->dev, \"WM8351 Rev B\\n\");\n\t\t\twm8350->power.rev_g_coeff = 1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_err(wm8350->dev, \"Unknown WM8351 CHIP_REV\\n\");\n\t\t\tret = -ENODEV;\n\t\t\tgoto err;\n\t\t}\n\t\tbreak;\n\n\tcase 2:\n\t\twm8350->pmic.max_dcdc = WM8350_DCDC_6;\n\t\twm8350->pmic.max_isink = WM8350_ISINK_B;\n\n\t\tswitch (chip_rev) {\n\t\tcase 0:\n\t\t\tdev_info(wm8350->dev, \"WM8352 Rev A\\n\");\n\t\t\twm8350->power.rev_g_coeff = 1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_err(wm8350->dev, \"Unknown WM8352 CHIP_REV\\n\");\n\t\t\tret = -ENODEV;\n\t\t\tgoto err;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(wm8350->dev, \"Unknown MASK_REV\\n\");\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\tmutex_init(&wm8350->auxadc_mutex);\n\tinit_completion(&wm8350->auxadc_done);\n\n\tret = wm8350_irq_init(wm8350, irq, pdata);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tif (wm8350->irq_base) {\n\t\tret = request_threaded_irq(wm8350->irq_base +\n\t\t\t\t\t   WM8350_IRQ_AUXADC_DATARDY,\n\t\t\t\t\t   NULL, wm8350_auxadc_irq,\n\t\t\t\t\t   IRQF_ONESHOT,\n\t\t\t\t\t   \"auxadc\", wm8350);\n\t\tif (ret < 0)\n\t\t\tdev_warn(wm8350->dev,\n\t\t\t\t \"Failed to request AUXADC IRQ: %d\\n\", ret);\n\t}\n\n\tif (pdata && pdata->init) {\n\t\tret = pdata->init(wm8350);\n\t\tif (ret != 0) {\n\t\t\tdev_err(wm8350->dev, \"Platform init() failed: %d\\n\",\n\t\t\t\tret);\n\t\t\tgoto err_irq;\n\t\t}\n\t}\n\n\twm8350_reg_write(wm8350, WM8350_SYSTEM_INTERRUPTS_MASK, 0x0);\n\n\twm8350_client_dev_register(wm8350, \"wm8350-codec\",\n\t\t\t\t   &(wm8350->codec.pdev));\n\twm8350_client_dev_register(wm8350, \"wm8350-gpio\",\n\t\t\t\t   &(wm8350->gpio.pdev));\n\twm8350_client_dev_register(wm8350, \"wm8350-hwmon\",\n\t\t\t\t   &(wm8350->hwmon.pdev));\n\twm8350_client_dev_register(wm8350, \"wm8350-power\",\n\t\t\t\t   &(wm8350->power.pdev));\n\twm8350_client_dev_register(wm8350, \"wm8350-rtc\", &(wm8350->rtc.pdev));\n\twm8350_client_dev_register(wm8350, \"wm8350-wdt\", &(wm8350->wdt.pdev));\n\n\treturn 0;\n\nerr_irq:\n\twm8350_irq_exit(wm8350);\nerr:\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(wm8350_device_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}