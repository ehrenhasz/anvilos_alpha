{
  "module_name": "tps65010.c",
  "hash_id": "c1dabfccfa0173c1170904b33f092953e5a3546806a89791b89f8cb629f8ab7a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/tps65010.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/i2c.h>\n#include <linux/delay.h>\n#include <linux/workqueue.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/platform_device.h>\n\n#include <linux/mfd/tps65010.h>\n\n#include <linux/gpio/driver.h>\n\n\n \n\n#define\tDRIVER_VERSION\t\"2 May 2005\"\n#define\tDRIVER_NAME\t(tps65010_driver.driver.name)\n\nMODULE_DESCRIPTION(\"TPS6501x Power Management Driver\");\nMODULE_LICENSE(\"GPL\");\n\nstatic struct i2c_driver tps65010_driver;\n\n \n\n \nenum tps_model {\n\tTPS65010,\n\tTPS65011,\n\tTPS65012,\n\tTPS65013,\n};\n\nstruct tps65010 {\n\tstruct i2c_client\t*client;\n\tstruct mutex\t\tlock;\n\tstruct delayed_work\twork;\n\tstruct dentry\t\t*file;\n\tunsigned\t\tcharging:1;\n\tunsigned\t\tpor:1;\n\tunsigned\t\tmodel:8;\n\tu16\t\t\tvbus;\n\tunsigned long\t\tflags;\n#define\tFLAG_VBUS_CHANGED\t0\n#define\tFLAG_IRQ_ENABLE\t\t1\n\n\t \n\tu8\t\t\tchgstatus, regstatus, chgconf;\n\tu8\t\t\tnmask1, nmask2;\n\n\tu8\t\t\toutmask;\n\tstruct gpio_chip\tchip;\n\tstruct platform_device\t*leds;\n};\n\n#define\tPOWER_POLL_DELAY\tmsecs_to_jiffies(5000)\n\n \n\n#if\tdefined(DEBUG) || defined(CONFIG_DEBUG_FS)\n\nstatic void dbg_chgstat(char *buf, size_t len, u8 chgstatus)\n{\n\tsnprintf(buf, len, \"%02x%s%s%s%s%s%s%s%s\\n\",\n\t\tchgstatus,\n\t\t(chgstatus & TPS_CHG_USB) ? \" USB\" : \"\",\n\t\t(chgstatus & TPS_CHG_AC) ? \" AC\" : \"\",\n\t\t(chgstatus & TPS_CHG_THERM) ? \" therm\" : \"\",\n\t\t(chgstatus & TPS_CHG_TERM) ? \" done\" :\n\t\t\t((chgstatus & (TPS_CHG_USB|TPS_CHG_AC))\n\t\t\t\t? \" (charging)\" : \"\"),\n\t\t(chgstatus & TPS_CHG_TAPER_TMO) ? \" taper_tmo\" : \"\",\n\t\t(chgstatus & TPS_CHG_CHG_TMO) ? \" charge_tmo\" : \"\",\n\t\t(chgstatus & TPS_CHG_PRECHG_TMO) ? \" prechg_tmo\" : \"\",\n\t\t(chgstatus & TPS_CHG_TEMP_ERR) ? \" temp_err\" : \"\");\n}\n\nstatic void dbg_regstat(char *buf, size_t len, u8 regstatus)\n{\n\tsnprintf(buf, len, \"%02x %s%s%s%s%s%s%s%s\\n\",\n\t\tregstatus,\n\t\t(regstatus & TPS_REG_ONOFF) ? \"off\" : \"(on)\",\n\t\t(regstatus & TPS_REG_COVER) ? \" uncover\" : \"\",\n\t\t(regstatus & TPS_REG_UVLO) ? \" UVLO\" : \"\",\n\t\t(regstatus & TPS_REG_NO_CHG) ? \" NO_CHG\" : \"\",\n\t\t(regstatus & TPS_REG_PG_LD02) ? \" ld02_bad\" : \"\",\n\t\t(regstatus & TPS_REG_PG_LD01) ? \" ld01_bad\" : \"\",\n\t\t(regstatus & TPS_REG_PG_MAIN) ? \" main_bad\" : \"\",\n\t\t(regstatus & TPS_REG_PG_CORE) ? \" core_bad\" : \"\");\n}\n\nstatic void dbg_chgconf(int por, char *buf, size_t len, u8 chgconfig)\n{\n\tconst char *hibit;\n\n\tif (por)\n\t\thibit = (chgconfig & TPS_CHARGE_POR)\n\t\t\t\t? \"POR=69ms\" : \"POR=1sec\";\n\telse\n\t\thibit = (chgconfig & TPS65013_AUA) ? \"AUA\" : \"\";\n\n\tsnprintf(buf, len, \"%02x %s%s%s AC=%d%% USB=%dmA %sCharge\\n\",\n\t\tchgconfig, hibit,\n\t\t(chgconfig & TPS_CHARGE_RESET) ? \" reset\" : \"\",\n\t\t(chgconfig & TPS_CHARGE_FAST) ? \" fast\" : \"\",\n\t\t({int p; switch ((chgconfig >> 3) & 3) {\n\t\tcase 3:\t\tp = 100; break;\n\t\tcase 2:\t\tp = 75; break;\n\t\tcase 1:\t\tp = 50; break;\n\t\tdefault:\tp = 25; break;\n\t\t}; p; }),\n\t\t(chgconfig & TPS_VBUS_CHARGING)\n\t\t\t? ((chgconfig & TPS_VBUS_500MA) ? 500 : 100)\n\t\t\t: 0,\n\t\t(chgconfig & TPS_CHARGE_ENABLE) ? \"\" : \"No\");\n}\n\n#endif\n\n#ifdef\tDEBUG\n\nstatic void show_chgstatus(const char *label, u8 chgstatus)\n{\n\tchar buf [100];\n\n\tdbg_chgstat(buf, sizeof buf, chgstatus);\n\tpr_debug(\"%s: %s %s\", DRIVER_NAME, label, buf);\n}\n\nstatic void show_regstatus(const char *label, u8 regstatus)\n{\n\tchar buf [100];\n\n\tdbg_regstat(buf, sizeof buf, regstatus);\n\tpr_debug(\"%s: %s %s\", DRIVER_NAME, label, buf);\n}\n\nstatic void show_chgconfig(int por, const char *label, u8 chgconfig)\n{\n\tchar buf [100];\n\n\tdbg_chgconf(por, buf, sizeof buf, chgconfig);\n\tpr_debug(\"%s: %s %s\", DRIVER_NAME, label, buf);\n}\n\n#else\n\nstatic inline void show_chgstatus(const char *label, u8 chgstatus) { }\nstatic inline void show_regstatus(const char *label, u8 chgstatus) { }\nstatic inline void show_chgconfig(int por, const char *label, u8 chgconfig) { }\n\n#endif\n\n#ifdef\tCONFIG_DEBUG_FS\n\nstatic int dbg_show(struct seq_file *s, void *_)\n{\n\tstruct tps65010\t*tps = s->private;\n\tu8\t\tvalue, v2;\n\tunsigned\ti;\n\tchar\t\tbuf[100];\n\tconst char\t*chip;\n\n\tswitch (tps->model) {\n\tcase TPS65010:\tchip = \"tps65010\"; break;\n\tcase TPS65011:\tchip = \"tps65011\"; break;\n\tcase TPS65012:\tchip = \"tps65012\"; break;\n\tcase TPS65013:\tchip = \"tps65013\"; break;\n\tdefault:\tchip = NULL; break;\n\t}\n\tseq_printf(s, \"driver  %s\\nversion %s\\nchip    %s\\n\\n\",\n\t\t\tDRIVER_NAME, DRIVER_VERSION, chip);\n\n\tmutex_lock(&tps->lock);\n\n\t \n\n\tseq_printf(s, \"%scharging\\n\\n\", tps->charging ? \"\" : \"(not) \");\n\n\n\t \n\tvalue = i2c_smbus_read_byte_data(tps->client, TPS_CHGCONFIG);\n\tdbg_chgconf(tps->por, buf, sizeof buf, value);\n\tseq_printf(s, \"chgconfig %s\", buf);\n\n\tvalue = i2c_smbus_read_byte_data(tps->client, TPS_CHGSTATUS);\n\tdbg_chgstat(buf, sizeof buf, value);\n\tseq_printf(s, \"chgstat   %s\", buf);\n\tvalue = i2c_smbus_read_byte_data(tps->client, TPS_MASK1);\n\tdbg_chgstat(buf, sizeof buf, value);\n\tseq_printf(s, \"mask1     %s\", buf);\n\t \n\n\tvalue = i2c_smbus_read_byte_data(tps->client, TPS_REGSTATUS);\n\tdbg_regstat(buf, sizeof buf, value);\n\tseq_printf(s, \"regstat   %s\", buf);\n\tvalue = i2c_smbus_read_byte_data(tps->client, TPS_MASK2);\n\tdbg_regstat(buf, sizeof buf, value);\n\tseq_printf(s, \"mask2     %s\\n\", buf);\n\t \n\n\tqueue_delayed_work(system_power_efficient_wq, &tps->work,\n\t\t\t   POWER_POLL_DELAY);\n\n\t \n\tvalue = i2c_smbus_read_byte_data(tps->client, TPS_VDCDC1);\n\tseq_printf(s, \"vdcdc1    %02x\\n\", value);\n\n\t \n\tvalue = i2c_smbus_read_byte_data(tps->client, TPS_VDCDC2);\n\tseq_printf(s, \"vdcdc2    %02x\\n\", value);\n\n\t \n\tvalue = i2c_smbus_read_byte_data(tps->client, TPS_VREGS1);\n\tseq_printf(s, \"vregs1    %02x\\n\\n\", value);\n\n\n\t \n\tvalue = i2c_smbus_read_byte_data(tps->client, TPS_LED1_ON);\n\tv2 = i2c_smbus_read_byte_data(tps->client, TPS_LED1_PER);\n\tseq_printf(s, \"led1 %s, on=%02x, per=%02x, %d/%d msec\\n\",\n\t\t(value & 0x80)\n\t\t\t? ((v2 & 0x80) ? \"on\" : \"off\")\n\t\t\t: ((v2 & 0x80) ? \"blink\" : \"(nPG)\"),\n\t\tvalue, v2,\n\t\t(value & 0x7f) * 10, (v2 & 0x7f) * 100);\n\n\tvalue = i2c_smbus_read_byte_data(tps->client, TPS_LED2_ON);\n\tv2 = i2c_smbus_read_byte_data(tps->client, TPS_LED2_PER);\n\tseq_printf(s, \"led2 %s, on=%02x, per=%02x, %d/%d msec\\n\",\n\t\t(value & 0x80)\n\t\t\t? ((v2 & 0x80) ? \"on\" : \"off\")\n\t\t\t: ((v2 & 0x80) ? \"blink\" : \"off\"),\n\t\tvalue, v2,\n\t\t(value & 0x7f) * 10, (v2 & 0x7f) * 100);\n\n\tvalue = i2c_smbus_read_byte_data(tps->client, TPS_DEFGPIO);\n\tv2 = i2c_smbus_read_byte_data(tps->client, TPS_MASK3);\n\tseq_printf(s, \"defgpio %02x mask3 %02x\\n\", value, v2);\n\n\tfor (i = 0; i < 4; i++) {\n\t\tif (value & (1 << (4 + i)))\n\t\t\tseq_printf(s, \"  gpio%d-out %s\\n\", i + 1,\n\t\t\t\t(value & (1 << i)) ? \"low\" : \"hi \");\n\t\telse\n\t\t\tseq_printf(s, \"  gpio%d-in  %s %s %s\\n\", i + 1,\n\t\t\t\t(value & (1 << i)) ? \"hi \" : \"low\",\n\t\t\t\t(v2 & (1 << i)) ? \"no-irq\" : \"irq\",\n\t\t\t\t(v2 & (1 << (4 + i))) ? \"rising\" : \"falling\");\n\t}\n\n\tmutex_unlock(&tps->lock);\n\treturn 0;\n}\n\nstatic int dbg_tps_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, dbg_show, inode->i_private);\n}\n\nstatic const struct file_operations debug_fops = {\n\t.open\t\t= dbg_tps_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\n#define\tDEBUG_FOPS\t&debug_fops\n\n#else\n#define\tDEBUG_FOPS\tNULL\n#endif\n\n \n\n \nstatic void tps65010_interrupt(struct tps65010 *tps)\n{\n\tu8 tmp = 0, mask, poll;\n\n\t \n\tpoll = 0;\n\n\t \n\tif (tps->nmask2) {\n\t\ttmp = i2c_smbus_read_byte_data(tps->client, TPS_REGSTATUS);\n\t\tmask = tmp ^ tps->regstatus;\n\t\ttps->regstatus = tmp;\n\t\tmask &= tps->nmask2;\n\t} else\n\t\tmask = 0;\n\tif (mask) {\n\t\ttps->regstatus =  tmp;\n\t\t \n\n\t\t \n\t\tif (tmp & TPS_REG_ONOFF) {\n\t\t\tpr_info(\"%s: power off button\\n\", DRIVER_NAME);\n#if 0\n\t\t\t \n\t\t\thibernate();\n#endif\n\t\t\tpoll = 1;\n\t\t}\n\t}\n\n\t \n\tif (tps->nmask1) {\n\t\ttmp = i2c_smbus_read_byte_data(tps->client, TPS_CHGSTATUS);\n\t\tmask = tmp ^ tps->chgstatus;\n\t\ttps->chgstatus = tmp;\n\t\tmask &= tps->nmask1;\n\t} else\n\t\tmask = 0;\n\tif (mask) {\n\t\tunsigned\tcharging = 0;\n\n\t\tshow_chgstatus(\"chg/irq\", tmp);\n\t\tif (tmp & (TPS_CHG_USB|TPS_CHG_AC))\n\t\t\tshow_chgconfig(tps->por, \"conf\", tps->chgconf);\n\n\t\t \n\t\tif (!(tps->chgstatus & ~(TPS_CHG_USB|TPS_CHG_AC))\n\t\t\t\t&& (tps->chgstatus & (TPS_CHG_USB|TPS_CHG_AC))\n\t\t\t\t&& (tps->chgconf & TPS_CHARGE_ENABLE)\n\t\t\t\t) {\n\t\t\tif (tps->chgstatus & TPS_CHG_USB) {\n\t\t\t\t \n\t\t\t\tif (mask & TPS_CHG_USB)\n\t\t\t\t\tset_bit(FLAG_VBUS_CHANGED, &tps->flags);\n\t\t\t\tcharging = 1;\n\t\t\t} else if (tps->chgstatus & TPS_CHG_AC)\n\t\t\t\tcharging = 1;\n\t\t}\n\t\tif (charging != tps->charging) {\n\t\t\ttps->charging = charging;\n\t\t\tpr_info(\"%s: battery %scharging\\n\",\n\t\t\t\tDRIVER_NAME, charging ? \"\" :\n\t\t\t\t((tps->chgstatus & (TPS_CHG_USB|TPS_CHG_AC))\n\t\t\t\t\t? \"NOT \" : \"dis\"));\n\t\t}\n\t}\n\n\t \n\tif ((tps->model != TPS65013 || !tps->charging)\n\t\t\t&& (tps->chgstatus & (TPS_CHG_USB|TPS_CHG_AC)))\n\t\tpoll = 1;\n\tif (poll)\n\t\tqueue_delayed_work(system_power_efficient_wq, &tps->work,\n\t\t\t\t   POWER_POLL_DELAY);\n\n\t \n}\n\n \nstatic void tps65010_work(struct work_struct *work)\n{\n\tstruct tps65010\t\t*tps;\n\n\ttps = container_of(to_delayed_work(work), struct tps65010, work);\n\tmutex_lock(&tps->lock);\n\n\ttps65010_interrupt(tps);\n\n\tif (test_and_clear_bit(FLAG_VBUS_CHANGED, &tps->flags)) {\n\t\tu8\tchgconfig, tmp;\n\n\t\tchgconfig = i2c_smbus_read_byte_data(tps->client,\n\t\t\t\t\tTPS_CHGCONFIG);\n\t\tchgconfig &= ~(TPS_VBUS_500MA | TPS_VBUS_CHARGING);\n\t\tif (tps->vbus == 500)\n\t\t\tchgconfig |= TPS_VBUS_500MA | TPS_VBUS_CHARGING;\n\t\telse if (tps->vbus >= 100)\n\t\t\tchgconfig |= TPS_VBUS_CHARGING;\n\n\t\ti2c_smbus_write_byte_data(tps->client,\n\t\t\t\t\t  TPS_CHGCONFIG, chgconfig);\n\n\t\t \n\t\ttmp = i2c_smbus_read_byte_data(tps->client, TPS_CHGCONFIG);\n\t\ttps->chgconf = tmp;\n\t\tshow_chgconfig(tps->por, \"update vbus\", tmp);\n\t}\n\n\tif (test_and_clear_bit(FLAG_IRQ_ENABLE, &tps->flags))\n\t\tenable_irq(tps->client->irq);\n\n\tmutex_unlock(&tps->lock);\n}\n\nstatic irqreturn_t tps65010_irq(int irq, void *_tps)\n{\n\tstruct tps65010\t\t*tps = _tps;\n\n\tdisable_irq_nosync(irq);\n\tset_bit(FLAG_IRQ_ENABLE, &tps->flags);\n\tqueue_delayed_work(system_power_efficient_wq, &tps->work, 0);\n\treturn IRQ_HANDLED;\n}\n\n \n\n \nstatic void\ntps65010_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\n{\n\tif (offset < 4)\n\t\ttps65010_set_gpio_out_value(offset + 1, value);\n\telse if (offset < 6)\n\t\ttps65010_set_led(offset - 3, value ? ON : OFF);\n\telse\n\t\ttps65010_set_vib(value);\n}\n\nstatic int\ntps65010_output(struct gpio_chip *chip, unsigned offset, int value)\n{\n\t \n\tif (offset < 4) {\n\t\tstruct tps65010\t\t*tps;\n\n\t\ttps = gpiochip_get_data(chip);\n\t\tif (!(tps->outmask & (1 << offset)))\n\t\t\treturn -EINVAL;\n\t\ttps65010_set_gpio_out_value(offset + 1, value);\n\t} else if (offset < 6)\n\t\ttps65010_set_led(offset - 3, value ? ON : OFF);\n\telse\n\t\ttps65010_set_vib(value);\n\n\treturn 0;\n}\n\nstatic int tps65010_gpio_get(struct gpio_chip *chip, unsigned offset)\n{\n\tint\t\t\tvalue;\n\tstruct tps65010\t\t*tps;\n\n\ttps = gpiochip_get_data(chip);\n\n\tif (offset < 4) {\n\t\tvalue = i2c_smbus_read_byte_data(tps->client, TPS_DEFGPIO);\n\t\tif (value < 0)\n\t\t\treturn value;\n\t\tif (value & (1 << (offset + 4)))\t \n\t\t\treturn !(value & (1 << offset));\n\t\telse\t\t\t\t\t \n\t\t\treturn !!(value & (1 << offset));\n\t}\n\n\t \n\treturn 0;\n}\n\n\n \n\nstatic struct tps65010 *the_tps;\n\nstatic void tps65010_remove(struct i2c_client *client)\n{\n\tstruct tps65010\t\t*tps = i2c_get_clientdata(client);\n\tstruct tps65010_board\t*board = dev_get_platdata(&client->dev);\n\n\tif (board && board->teardown)\n\t\tboard->teardown(client, &tps->chip);\n\tif (client->irq > 0)\n\t\tfree_irq(client->irq, tps);\n\tcancel_delayed_work_sync(&tps->work);\n\tdebugfs_remove(tps->file);\n\tthe_tps = NULL;\n}\n\nstatic int tps65010_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct tps65010\t\t*tps;\n\tint\t\t\tstatus;\n\tstruct tps65010_board\t*board = dev_get_platdata(&client->dev);\n\n\tif (the_tps) {\n\t\tdev_dbg(&client->dev, \"only one tps6501x chip allowed\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\n\t\treturn -EINVAL;\n\n\ttps = devm_kzalloc(&client->dev, sizeof(*tps), GFP_KERNEL);\n\tif (!tps)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&tps->lock);\n\tINIT_DELAYED_WORK(&tps->work, tps65010_work);\n\ttps->client = client;\n\ttps->model = id->driver_data;\n\n\t \n\tif (client->irq > 0) {\n\t\tstatus = request_irq(client->irq, tps65010_irq,\n\t\t\t\t     IRQF_TRIGGER_FALLING, DRIVER_NAME, tps);\n\t\tif (status < 0) {\n\t\t\tdev_dbg(&client->dev, \"can't get IRQ %d, err %d\\n\",\n\t\t\t\t\tclient->irq, status);\n\t\t\treturn status;\n\t\t}\n\t\t \n\t\tdisable_irq(client->irq);\n\t\tset_bit(FLAG_IRQ_ENABLE, &tps->flags);\n\t} else\n\t\tdev_warn(&client->dev, \"IRQ not configured!\\n\");\n\n\n\tswitch (tps->model) {\n\tcase TPS65010:\n\tcase TPS65012:\n\t\ttps->por = 1;\n\t\tbreak;\n\t \n\t}\n\ttps->chgconf = i2c_smbus_read_byte_data(client, TPS_CHGCONFIG);\n\tshow_chgconfig(tps->por, \"conf/init\", tps->chgconf);\n\n\tshow_chgstatus(\"chg/init\",\n\t\ti2c_smbus_read_byte_data(client, TPS_CHGSTATUS));\n\tshow_regstatus(\"reg/init\",\n\t\ti2c_smbus_read_byte_data(client, TPS_REGSTATUS));\n\n\tpr_debug(\"%s: vdcdc1 0x%02x, vdcdc2 %02x, vregs1 %02x\\n\", DRIVER_NAME,\n\t\ti2c_smbus_read_byte_data(client, TPS_VDCDC1),\n\t\ti2c_smbus_read_byte_data(client, TPS_VDCDC2),\n\t\ti2c_smbus_read_byte_data(client, TPS_VREGS1));\n\tpr_debug(\"%s: defgpio 0x%02x, mask3 0x%02x\\n\", DRIVER_NAME,\n\t\ti2c_smbus_read_byte_data(client, TPS_DEFGPIO),\n\t\ti2c_smbus_read_byte_data(client, TPS_MASK3));\n\n\ti2c_set_clientdata(client, tps);\n\tthe_tps = tps;\n\n#if\tdefined(CONFIG_USB_GADGET) && !defined(CONFIG_USB_OTG)\n\t \n\ttps->vbus = 100;\n#endif\n\n\t \n\ttps->nmask1 = ~0;\n\t(void) i2c_smbus_write_byte_data(client, TPS_MASK1, ~tps->nmask1);\n\n\ttps->nmask2 = TPS_REG_ONOFF;\n\tif (tps->model == TPS65013)\n\t\ttps->nmask2 |= TPS_REG_NO_CHG;\n\t(void) i2c_smbus_write_byte_data(client, TPS_MASK2, ~tps->nmask2);\n\n\t(void) i2c_smbus_write_byte_data(client, TPS_MASK3, 0x0f\n\t\t| i2c_smbus_read_byte_data(client, TPS_MASK3));\n\n\ttps65010_work(&tps->work.work);\n\n\ttps->file = debugfs_create_file(DRIVER_NAME, S_IRUGO, NULL,\n\t\t\t\ttps, DEBUG_FOPS);\n\n\t \n\tif (board) {\n\t\ttps->outmask = board->outmask;\n\n\t\ttps->chip.label = client->name;\n\t\ttps->chip.parent = &client->dev;\n\t\ttps->chip.owner = THIS_MODULE;\n\n\t\ttps->chip.set = tps65010_gpio_set;\n\t\ttps->chip.direction_output = tps65010_output;\n\n\t\t \n\t\ttps->chip.get = tps65010_gpio_get;\n\n\t\ttps->chip.base = -1;\n\t\ttps->chip.ngpio = 7;\n\t\ttps->chip.can_sleep = 1;\n\n\t\tstatus = gpiochip_add_data(&tps->chip, tps);\n\t\tif (status < 0)\n\t\t\tdev_err(&client->dev, \"can't add gpiochip, err %d\\n\",\n\t\t\t\t\tstatus);\n\t\telse if (board->setup) {\n\t\t\tstatus = board->setup(client, &tps->chip);\n\t\t\tif (status < 0) {\n\t\t\t\tdev_dbg(&client->dev,\n\t\t\t\t\t\"board %s %s err %d\\n\",\n\t\t\t\t\t\"setup\", client->name, status);\n\t\t\t\tstatus = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id tps65010_id[] = {\n\t{ \"tps65010\", TPS65010 },\n\t{ \"tps65011\", TPS65011 },\n\t{ \"tps65012\", TPS65012 },\n\t{ \"tps65013\", TPS65013 },\n\t{ \"tps65014\", TPS65011 },\t \n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, tps65010_id);\n\nstatic struct i2c_driver tps65010_driver = {\n\t.driver = {\n\t\t.name\t= \"tps65010\",\n\t},\n\t.probe = tps65010_probe,\n\t.remove\t= tps65010_remove,\n\t.id_table = tps65010_id,\n};\n\n \n\n \nint tps65010_set_vbus_draw(unsigned mA)\n{\n\tunsigned long\tflags;\n\n\tif (!the_tps)\n\t\treturn -ENODEV;\n\n\t \n\tlocal_irq_save(flags);\n\tif (mA >= 500)\n\t\tmA = 500;\n\telse if (mA >= 100)\n\t\tmA = 100;\n\telse\n\t\tmA = 0;\n\tthe_tps->vbus = mA;\n\tif ((the_tps->chgstatus & TPS_CHG_USB)\n\t\t\t&& test_and_set_bit(\n\t\t\t\tFLAG_VBUS_CHANGED, &the_tps->flags)) {\n\t\t \n\t\tqueue_delayed_work(system_power_efficient_wq, &the_tps->work,\n\t\t\t\t   0);\n\t}\n\tlocal_irq_restore(flags);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(tps65010_set_vbus_draw);\n\n \n \nint tps65010_set_gpio_out_value(unsigned gpio, unsigned value)\n{\n\tint\t status;\n\tunsigned defgpio;\n\n\tif (!the_tps)\n\t\treturn -ENODEV;\n\tif ((gpio < GPIO1) || (gpio > GPIO4))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&the_tps->lock);\n\n\tdefgpio = i2c_smbus_read_byte_data(the_tps->client, TPS_DEFGPIO);\n\n\t \n\tdefgpio |= 1 << (gpio + 3);\n\n\t \n\tswitch (value) {\n\tcase LOW:\n\t\tdefgpio |= 1 << (gpio - 1);     \n\t\tbreak;\n\t \n\tdefault:\n\t\tdefgpio &= ~(1 << (gpio - 1));  \n\t\tbreak;\n\t}\n\n\tstatus = i2c_smbus_write_byte_data(the_tps->client,\n\t\tTPS_DEFGPIO, defgpio);\n\n\tpr_debug(\"%s: gpio%dout = %s, defgpio 0x%02x\\n\", DRIVER_NAME,\n\t\tgpio, value ? \"high\" : \"low\",\n\t\ti2c_smbus_read_byte_data(the_tps->client, TPS_DEFGPIO));\n\n\tmutex_unlock(&the_tps->lock);\n\treturn status;\n}\nEXPORT_SYMBOL(tps65010_set_gpio_out_value);\n\n \n \nint tps65010_set_led(unsigned led, unsigned mode)\n{\n\tint\t status;\n\tunsigned led_on, led_per, offs;\n\n\tif (!the_tps)\n\t\treturn -ENODEV;\n\n\tif (led == LED1)\n\t\toffs = 0;\n\telse {\n\t\toffs = 2;\n\t\tled = LED2;\n\t}\n\n\tmutex_lock(&the_tps->lock);\n\n\tpr_debug(\"%s: led%i_on   0x%02x\\n\", DRIVER_NAME, led,\n\t\ti2c_smbus_read_byte_data(the_tps->client,\n\t\t\t\tTPS_LED1_ON + offs));\n\n\tpr_debug(\"%s: led%i_per  0x%02x\\n\", DRIVER_NAME, led,\n\t\ti2c_smbus_read_byte_data(the_tps->client,\n\t\t\t\tTPS_LED1_PER + offs));\n\n\tswitch (mode) {\n\tcase OFF:\n\t\tled_on  = 1 << 7;\n\t\tled_per = 0 << 7;\n\t\tbreak;\n\tcase ON:\n\t\tled_on  = 1 << 7;\n\t\tled_per = 1 << 7;\n\t\tbreak;\n\tcase BLINK:\n\t\tled_on  = 0x30 | (0 << 7);\n\t\tled_per = 0x08 | (1 << 7);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"%s: Wrong mode parameter for set_led()\\n\",\n\t\t       DRIVER_NAME);\n\t\tmutex_unlock(&the_tps->lock);\n\t\treturn -EINVAL;\n\t}\n\n\tstatus = i2c_smbus_write_byte_data(the_tps->client,\n\t\t\tTPS_LED1_ON + offs, led_on);\n\n\tif (status != 0) {\n\t\tprintk(KERN_ERR \"%s: Failed to write led%i_on register\\n\",\n\t\t       DRIVER_NAME, led);\n\t\tmutex_unlock(&the_tps->lock);\n\t\treturn status;\n\t}\n\n\tpr_debug(\"%s: led%i_on   0x%02x\\n\", DRIVER_NAME, led,\n\t\ti2c_smbus_read_byte_data(the_tps->client, TPS_LED1_ON + offs));\n\n\tstatus = i2c_smbus_write_byte_data(the_tps->client,\n\t\t\tTPS_LED1_PER + offs, led_per);\n\n\tif (status != 0) {\n\t\tprintk(KERN_ERR \"%s: Failed to write led%i_per register\\n\",\n\t\t       DRIVER_NAME, led);\n\t\tmutex_unlock(&the_tps->lock);\n\t\treturn status;\n\t}\n\n\tpr_debug(\"%s: led%i_per  0x%02x\\n\", DRIVER_NAME, led,\n\t\ti2c_smbus_read_byte_data(the_tps->client,\n\t\t\t\tTPS_LED1_PER + offs));\n\n\tmutex_unlock(&the_tps->lock);\n\n\treturn status;\n}\nEXPORT_SYMBOL(tps65010_set_led);\n\n \n \nint tps65010_set_vib(unsigned value)\n{\n\tint\t status;\n\tunsigned vdcdc2;\n\n\tif (!the_tps)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&the_tps->lock);\n\n\tvdcdc2 = i2c_smbus_read_byte_data(the_tps->client, TPS_VDCDC2);\n\tvdcdc2 &= ~(1 << 1);\n\tif (value)\n\t\tvdcdc2 |= (1 << 1);\n\tstatus = i2c_smbus_write_byte_data(the_tps->client,\n\t\tTPS_VDCDC2, vdcdc2);\n\n\tpr_debug(\"%s: vibrator %s\\n\", DRIVER_NAME, value ? \"on\" : \"off\");\n\n\tmutex_unlock(&the_tps->lock);\n\treturn status;\n}\nEXPORT_SYMBOL(tps65010_set_vib);\n\n \n \nint tps65010_set_low_pwr(unsigned mode)\n{\n\tint\t status;\n\tunsigned vdcdc1;\n\n\tif (!the_tps)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&the_tps->lock);\n\n\tpr_debug(\"%s: %s low_pwr, vdcdc1 0x%02x\\n\", DRIVER_NAME,\n\t\tmode ? \"enable\" : \"disable\",\n\t\ti2c_smbus_read_byte_data(the_tps->client, TPS_VDCDC1));\n\n\tvdcdc1 = i2c_smbus_read_byte_data(the_tps->client, TPS_VDCDC1);\n\n\tswitch (mode) {\n\tcase OFF:\n\t\tvdcdc1 &= ~TPS_ENABLE_LP;  \n\t\tbreak;\n\t \n\tdefault:\n\t\tvdcdc1 |= TPS_ENABLE_LP;   \n\t\tbreak;\n\t}\n\n\tstatus = i2c_smbus_write_byte_data(the_tps->client,\n\t\t\tTPS_VDCDC1, vdcdc1);\n\n\tif (status != 0)\n\t\tprintk(KERN_ERR \"%s: Failed to write vdcdc1 register\\n\",\n\t\t\tDRIVER_NAME);\n\telse\n\t\tpr_debug(\"%s: vdcdc1 0x%02x\\n\", DRIVER_NAME,\n\t\t\ti2c_smbus_read_byte_data(the_tps->client, TPS_VDCDC1));\n\n\tmutex_unlock(&the_tps->lock);\n\n\treturn status;\n}\nEXPORT_SYMBOL(tps65010_set_low_pwr);\n\n \n \nint tps65010_config_vregs1(unsigned value)\n{\n\tint\t status;\n\n\tif (!the_tps)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&the_tps->lock);\n\n\tpr_debug(\"%s: vregs1 0x%02x\\n\", DRIVER_NAME,\n\t\t\ti2c_smbus_read_byte_data(the_tps->client, TPS_VREGS1));\n\n\tstatus = i2c_smbus_write_byte_data(the_tps->client,\n\t\t\tTPS_VREGS1, value);\n\n\tif (status != 0)\n\t\tprintk(KERN_ERR \"%s: Failed to write vregs1 register\\n\",\n\t\t\tDRIVER_NAME);\n\telse\n\t\tpr_debug(\"%s: vregs1 0x%02x\\n\", DRIVER_NAME,\n\t\t\ti2c_smbus_read_byte_data(the_tps->client, TPS_VREGS1));\n\n\tmutex_unlock(&the_tps->lock);\n\n\treturn status;\n}\nEXPORT_SYMBOL(tps65010_config_vregs1);\n\nint tps65010_config_vdcdc2(unsigned value)\n{\n\tstruct i2c_client *c;\n\tint\t status;\n\n\tif (!the_tps)\n\t\treturn -ENODEV;\n\n\tc = the_tps->client;\n\tmutex_lock(&the_tps->lock);\n\n\tpr_debug(\"%s: vdcdc2 0x%02x\\n\", DRIVER_NAME,\n\t\t i2c_smbus_read_byte_data(c, TPS_VDCDC2));\n\n\tstatus = i2c_smbus_write_byte_data(c, TPS_VDCDC2, value);\n\n\tif (status != 0)\n\t\tprintk(KERN_ERR \"%s: Failed to write vdcdc2 register\\n\",\n\t\t\tDRIVER_NAME);\n\telse\n\t\tpr_debug(\"%s: vregs1 0x%02x\\n\", DRIVER_NAME,\n\t\t\t i2c_smbus_read_byte_data(c, TPS_VDCDC2));\n\n\tmutex_unlock(&the_tps->lock);\n\treturn status;\n}\nEXPORT_SYMBOL(tps65010_config_vdcdc2);\n\n \n \n\n \n\nint tps65013_set_low_pwr(unsigned mode)\n{\n\tint\t status;\n\tunsigned vdcdc1, chgconfig;\n\n\tif (!the_tps || the_tps->por)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&the_tps->lock);\n\n\tpr_debug(\"%s: %s low_pwr, chgconfig 0x%02x vdcdc1 0x%02x\\n\",\n\t\tDRIVER_NAME,\n\t\tmode ? \"enable\" : \"disable\",\n\t\ti2c_smbus_read_byte_data(the_tps->client, TPS_CHGCONFIG),\n\t\ti2c_smbus_read_byte_data(the_tps->client, TPS_VDCDC1));\n\n\tchgconfig = i2c_smbus_read_byte_data(the_tps->client, TPS_CHGCONFIG);\n\tvdcdc1 = i2c_smbus_read_byte_data(the_tps->client, TPS_VDCDC1);\n\n\tswitch (mode) {\n\tcase OFF:\n\t\tchgconfig &= ~TPS65013_AUA;  \n\t\tvdcdc1 &= ~TPS_ENABLE_LP;  \n\t\tbreak;\n\t \n\tdefault:\n\t\tchgconfig |= TPS65013_AUA;   \n\t\tvdcdc1 |= TPS_ENABLE_LP;   \n\t\tbreak;\n\t}\n\n\tstatus = i2c_smbus_write_byte_data(the_tps->client,\n\t\t\tTPS_CHGCONFIG, chgconfig);\n\tif (status != 0) {\n\t\tprintk(KERN_ERR \"%s: Failed to write chconfig register\\n\",\n\t DRIVER_NAME);\n\t\tmutex_unlock(&the_tps->lock);\n\t\treturn status;\n\t}\n\n\tchgconfig = i2c_smbus_read_byte_data(the_tps->client, TPS_CHGCONFIG);\n\tthe_tps->chgconf = chgconfig;\n\tshow_chgconfig(0, \"chgconf\", chgconfig);\n\n\tstatus = i2c_smbus_write_byte_data(the_tps->client,\n\t\t\tTPS_VDCDC1, vdcdc1);\n\n\tif (status != 0)\n\t\tprintk(KERN_ERR \"%s: Failed to write vdcdc1 register\\n\",\n\t DRIVER_NAME);\n\telse\n\t\tpr_debug(\"%s: vdcdc1 0x%02x\\n\", DRIVER_NAME,\n\t\t\ti2c_smbus_read_byte_data(the_tps->client, TPS_VDCDC1));\n\n\tmutex_unlock(&the_tps->lock);\n\n\treturn status;\n}\nEXPORT_SYMBOL(tps65013_set_low_pwr);\n\n \n\nstatic int __init tps_init(void)\n{\n\treturn i2c_add_driver(&tps65010_driver);\n}\n \nsubsys_initcall(tps_init);\n\nstatic void __exit tps_exit(void)\n{\n\ti2c_del_driver(&tps65010_driver);\n}\nmodule_exit(tps_exit);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}