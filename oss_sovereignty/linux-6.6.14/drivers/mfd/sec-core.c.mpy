{
  "module_name": "sec-core.c",
  "hash_id": "c5d6c259ba7c328981898a3f8a740b07eeb0ac98d72fe7906c2206f167736db4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/sec-core.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/of.h>\n#include <linux/interrupt.h>\n#include <linux/pm_runtime.h>\n#include <linux/mutex.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/samsung/core.h>\n#include <linux/mfd/samsung/irq.h>\n#include <linux/mfd/samsung/s2mpa01.h>\n#include <linux/mfd/samsung/s2mps11.h>\n#include <linux/mfd/samsung/s2mps13.h>\n#include <linux/mfd/samsung/s2mps14.h>\n#include <linux/mfd/samsung/s2mps15.h>\n#include <linux/mfd/samsung/s2mpu02.h>\n#include <linux/mfd/samsung/s5m8767.h>\n#include <linux/regmap.h>\n\nstatic const struct mfd_cell s5m8767_devs[] = {\n\t{ .name = \"s5m8767-pmic\", },\n\t{ .name = \"s5m-rtc\", },\n\t{\n\t\t.name = \"s5m8767-clk\",\n\t\t.of_compatible = \"samsung,s5m8767-clk\",\n\t},\n};\n\nstatic const struct mfd_cell s2mps11_devs[] = {\n\t{ .name = \"s2mps11-regulator\", },\n\t{ .name = \"s2mps14-rtc\", },\n\t{\n\t\t.name = \"s2mps11-clk\",\n\t\t.of_compatible = \"samsung,s2mps11-clk\",\n\t},\n};\n\nstatic const struct mfd_cell s2mps13_devs[] = {\n\t{ .name = \"s2mps13-regulator\", },\n\t{ .name = \"s2mps13-rtc\", },\n\t{\n\t\t.name = \"s2mps13-clk\",\n\t\t.of_compatible = \"samsung,s2mps13-clk\",\n\t},\n};\n\nstatic const struct mfd_cell s2mps14_devs[] = {\n\t{ .name = \"s2mps14-regulator\", },\n\t{ .name = \"s2mps14-rtc\", },\n\t{\n\t\t.name = \"s2mps14-clk\",\n\t\t.of_compatible = \"samsung,s2mps14-clk\",\n\t},\n};\n\nstatic const struct mfd_cell s2mps15_devs[] = {\n\t{ .name = \"s2mps15-regulator\", },\n\t{ .name = \"s2mps15-rtc\", },\n\t{\n\t\t.name = \"s2mps13-clk\",\n\t\t.of_compatible = \"samsung,s2mps13-clk\",\n\t},\n};\n\nstatic const struct mfd_cell s2mpa01_devs[] = {\n\t{ .name = \"s2mpa01-pmic\", },\n\t{ .name = \"s2mps14-rtc\", },\n};\n\nstatic const struct mfd_cell s2mpu02_devs[] = {\n\t{ .name = \"s2mpu02-regulator\", },\n};\n\nstatic const struct of_device_id sec_dt_match[] = {\n\t{\n\t\t.compatible = \"samsung,s5m8767-pmic\",\n\t\t.data = (void *)S5M8767X,\n\t}, {\n\t\t.compatible = \"samsung,s2mps11-pmic\",\n\t\t.data = (void *)S2MPS11X,\n\t}, {\n\t\t.compatible = \"samsung,s2mps13-pmic\",\n\t\t.data = (void *)S2MPS13X,\n\t}, {\n\t\t.compatible = \"samsung,s2mps14-pmic\",\n\t\t.data = (void *)S2MPS14X,\n\t}, {\n\t\t.compatible = \"samsung,s2mps15-pmic\",\n\t\t.data = (void *)S2MPS15X,\n\t}, {\n\t\t.compatible = \"samsung,s2mpa01-pmic\",\n\t\t.data = (void *)S2MPA01,\n\t}, {\n\t\t.compatible = \"samsung,s2mpu02-pmic\",\n\t\t.data = (void *)S2MPU02,\n\t}, {\n\t\t \n\t},\n};\nMODULE_DEVICE_TABLE(of, sec_dt_match);\n\nstatic bool s2mpa01_volatile(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase S2MPA01_REG_INT1M:\n\tcase S2MPA01_REG_INT2M:\n\tcase S2MPA01_REG_INT3M:\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nstatic bool s2mps11_volatile(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase S2MPS11_REG_INT1M:\n\tcase S2MPS11_REG_INT2M:\n\tcase S2MPS11_REG_INT3M:\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nstatic bool s2mpu02_volatile(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase S2MPU02_REG_INT1M:\n\tcase S2MPU02_REG_INT2M:\n\tcase S2MPU02_REG_INT3M:\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nstatic const struct regmap_config sec_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n};\n\nstatic const struct regmap_config s2mpa01_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = S2MPA01_REG_LDO_OVCB4,\n\t.volatile_reg = s2mpa01_volatile,\n\t.cache_type = REGCACHE_FLAT,\n};\n\nstatic const struct regmap_config s2mps11_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = S2MPS11_REG_L38CTRL,\n\t.volatile_reg = s2mps11_volatile,\n\t.cache_type = REGCACHE_FLAT,\n};\n\nstatic const struct regmap_config s2mps13_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = S2MPS13_REG_LDODSCH5,\n\t.volatile_reg = s2mps11_volatile,\n\t.cache_type = REGCACHE_FLAT,\n};\n\nstatic const struct regmap_config s2mps14_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = S2MPS14_REG_LDODSCH3,\n\t.volatile_reg = s2mps11_volatile,\n\t.cache_type = REGCACHE_FLAT,\n};\n\nstatic const struct regmap_config s2mps15_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = S2MPS15_REG_LDODSCH4,\n\t.volatile_reg = s2mps11_volatile,\n\t.cache_type = REGCACHE_FLAT,\n};\n\nstatic const struct regmap_config s2mpu02_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = S2MPU02_REG_DVSDATA,\n\t.volatile_reg = s2mpu02_volatile,\n\t.cache_type = REGCACHE_FLAT,\n};\n\nstatic const struct regmap_config s5m8767_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = S5M8767_REG_LDO28CTRL,\n\t.volatile_reg = s2mps11_volatile,\n\t.cache_type = REGCACHE_FLAT,\n};\n\nstatic void sec_pmic_dump_rev(struct sec_pmic_dev *sec_pmic)\n{\n\tunsigned int val;\n\n\t \n\tif (!regmap_read(sec_pmic->regmap_pmic, S2MPS11_REG_ID, &val))\n\t\tdev_dbg(sec_pmic->dev, \"Revision: 0x%x\\n\", val);\n}\n\nstatic void sec_pmic_configure(struct sec_pmic_dev *sec_pmic)\n{\n\tint err;\n\n\tif (sec_pmic->device_type != S2MPS13X)\n\t\treturn;\n\n\tif (sec_pmic->pdata->disable_wrstbi) {\n\t\t \n\t\terr = regmap_update_bits(sec_pmic->regmap_pmic,\n\t\t\t\t\t S2MPS13_REG_WRSTBI,\n\t\t\t\t\t S2MPS13_REG_WRSTBI_MASK, 0x0);\n\t\tif (err)\n\t\t\tdev_warn(sec_pmic->dev,\n\t\t\t\t \"Cannot initialize WRSTBI config: %d\\n\",\n\t\t\t\t err);\n\t}\n}\n\n \nstatic struct sec_platform_data *\nsec_pmic_i2c_parse_dt_pdata(struct device *dev)\n{\n\tstruct sec_platform_data *pd;\n\n\tpd = devm_kzalloc(dev, sizeof(*pd), GFP_KERNEL);\n\tif (!pd)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpd->manual_poweroff = of_property_read_bool(dev->of_node,\n\t\t\t\t\t\t\"samsung,s2mps11-acokb-ground\");\n\tpd->disable_wrstbi = of_property_read_bool(dev->of_node,\n\t\t\t\t\t\t\"samsung,s2mps11-wrstbi-ground\");\n\treturn pd;\n}\n\nstatic int sec_pmic_probe(struct i2c_client *i2c)\n{\n\tconst struct regmap_config *regmap;\n\tstruct sec_platform_data *pdata;\n\tconst struct mfd_cell *sec_devs;\n\tstruct sec_pmic_dev *sec_pmic;\n\tint ret, num_sec_devs;\n\n\tsec_pmic = devm_kzalloc(&i2c->dev, sizeof(struct sec_pmic_dev),\n\t\t\t\tGFP_KERNEL);\n\tif (sec_pmic == NULL)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(i2c, sec_pmic);\n\tsec_pmic->dev = &i2c->dev;\n\tsec_pmic->i2c = i2c;\n\tsec_pmic->irq = i2c->irq;\n\n\tpdata = sec_pmic_i2c_parse_dt_pdata(sec_pmic->dev);\n\tif (IS_ERR(pdata)) {\n\t\tret = PTR_ERR(pdata);\n\t\treturn ret;\n\t}\n\n\tsec_pmic->device_type = (unsigned long)of_device_get_match_data(sec_pmic->dev);\n\tsec_pmic->pdata = pdata;\n\n\tswitch (sec_pmic->device_type) {\n\tcase S2MPA01:\n\t\tregmap = &s2mpa01_regmap_config;\n\t\tbreak;\n\tcase S2MPS11X:\n\t\tregmap = &s2mps11_regmap_config;\n\t\tbreak;\n\tcase S2MPS13X:\n\t\tregmap = &s2mps13_regmap_config;\n\t\tbreak;\n\tcase S2MPS14X:\n\t\tregmap = &s2mps14_regmap_config;\n\t\tbreak;\n\tcase S2MPS15X:\n\t\tregmap = &s2mps15_regmap_config;\n\t\tbreak;\n\tcase S5M8767X:\n\t\tregmap = &s5m8767_regmap_config;\n\t\tbreak;\n\tcase S2MPU02:\n\t\tregmap = &s2mpu02_regmap_config;\n\t\tbreak;\n\tdefault:\n\t\tregmap = &sec_regmap_config;\n\t\tbreak;\n\t}\n\n\tsec_pmic->regmap_pmic = devm_regmap_init_i2c(i2c, regmap);\n\tif (IS_ERR(sec_pmic->regmap_pmic)) {\n\t\tret = PTR_ERR(sec_pmic->regmap_pmic);\n\t\tdev_err(&i2c->dev, \"Failed to allocate register map: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tsec_irq_init(sec_pmic);\n\n\tpm_runtime_set_active(sec_pmic->dev);\n\n\tswitch (sec_pmic->device_type) {\n\tcase S5M8767X:\n\t\tsec_devs = s5m8767_devs;\n\t\tnum_sec_devs = ARRAY_SIZE(s5m8767_devs);\n\t\tbreak;\n\tcase S2MPA01:\n\t\tsec_devs = s2mpa01_devs;\n\t\tnum_sec_devs = ARRAY_SIZE(s2mpa01_devs);\n\t\tbreak;\n\tcase S2MPS11X:\n\t\tsec_devs = s2mps11_devs;\n\t\tnum_sec_devs = ARRAY_SIZE(s2mps11_devs);\n\t\tbreak;\n\tcase S2MPS13X:\n\t\tsec_devs = s2mps13_devs;\n\t\tnum_sec_devs = ARRAY_SIZE(s2mps13_devs);\n\t\tbreak;\n\tcase S2MPS14X:\n\t\tsec_devs = s2mps14_devs;\n\t\tnum_sec_devs = ARRAY_SIZE(s2mps14_devs);\n\t\tbreak;\n\tcase S2MPS15X:\n\t\tsec_devs = s2mps15_devs;\n\t\tnum_sec_devs = ARRAY_SIZE(s2mps15_devs);\n\t\tbreak;\n\tcase S2MPU02:\n\t\tsec_devs = s2mpu02_devs;\n\t\tnum_sec_devs = ARRAY_SIZE(s2mpu02_devs);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&i2c->dev, \"Unsupported device type (%lu)\\n\",\n\t\t\tsec_pmic->device_type);\n\t\treturn -ENODEV;\n\t}\n\tret = devm_mfd_add_devices(sec_pmic->dev, -1, sec_devs, num_sec_devs,\n\t\t\t\t   NULL, 0, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tsec_pmic_configure(sec_pmic);\n\tsec_pmic_dump_rev(sec_pmic);\n\n\treturn ret;\n}\n\nstatic void sec_pmic_shutdown(struct i2c_client *i2c)\n{\n\tstruct sec_pmic_dev *sec_pmic = i2c_get_clientdata(i2c);\n\tunsigned int reg, mask;\n\n\tif (!sec_pmic->pdata->manual_poweroff)\n\t\treturn;\n\n\tswitch (sec_pmic->device_type) {\n\tcase S2MPS11X:\n\t\treg = S2MPS11_REG_CTRL1;\n\t\tmask = S2MPS11_CTRL1_PWRHOLD_MASK;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tdev_warn(sec_pmic->dev,\n\t\t\t\"Unsupported device %lu for manual power off\\n\",\n\t\t\tsec_pmic->device_type);\n\t\treturn;\n\t}\n\n\tregmap_update_bits(sec_pmic->regmap_pmic, reg, mask, 0);\n}\n\nstatic int sec_pmic_suspend(struct device *dev)\n{\n\tstruct i2c_client *i2c = to_i2c_client(dev);\n\tstruct sec_pmic_dev *sec_pmic = i2c_get_clientdata(i2c);\n\n\tif (device_may_wakeup(dev))\n\t\tenable_irq_wake(sec_pmic->irq);\n\t \n\tdisable_irq(sec_pmic->irq);\n\n\treturn 0;\n}\n\nstatic int sec_pmic_resume(struct device *dev)\n{\n\tstruct i2c_client *i2c = to_i2c_client(dev);\n\tstruct sec_pmic_dev *sec_pmic = i2c_get_clientdata(i2c);\n\n\tif (device_may_wakeup(dev))\n\t\tdisable_irq_wake(sec_pmic->irq);\n\tenable_irq(sec_pmic->irq);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(sec_pmic_pm_ops,\n\t\t\t\tsec_pmic_suspend, sec_pmic_resume);\n\nstatic struct i2c_driver sec_pmic_driver = {\n\t.driver = {\n\t\t   .name = \"sec_pmic\",\n\t\t   .pm = pm_sleep_ptr(&sec_pmic_pm_ops),\n\t\t   .of_match_table = sec_dt_match,\n\t},\n\t.probe = sec_pmic_probe,\n\t.shutdown = sec_pmic_shutdown,\n};\nmodule_i2c_driver(sec_pmic_driver);\n\nMODULE_AUTHOR(\"Sangbeom Kim <sbkim73@samsung.com>\");\nMODULE_DESCRIPTION(\"Core support for the S5M MFD\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}