{
  "module_name": "intel-m10-bmc-core.c",
  "hash_id": "85c847252fa7ec0ffab51633dd43ebc320bfc2fa670a88027acb551721ef29dc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/intel-m10-bmc-core.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/device.h>\n#include <linux/dev_printk.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/intel-m10-bmc.h>\n#include <linux/module.h>\n\nvoid m10bmc_fw_state_set(struct intel_m10bmc *m10bmc, enum m10bmc_fw_state new_state)\n{\n\t \n\tif (!m10bmc->info->handshake_sys_reg_nranges)\n\t\treturn;\n\n\tdown_write(&m10bmc->bmcfw_lock);\n\tm10bmc->bmcfw_state = new_state;\n\tup_write(&m10bmc->bmcfw_lock);\n}\nEXPORT_SYMBOL_NS_GPL(m10bmc_fw_state_set, INTEL_M10_BMC_CORE);\n\n \nstatic bool m10bmc_reg_always_available(struct intel_m10bmc *m10bmc, unsigned int offset)\n{\n\tif (!m10bmc->info->handshake_sys_reg_nranges)\n\t\treturn true;\n\n\treturn !regmap_reg_in_ranges(offset, m10bmc->info->handshake_sys_reg_ranges,\n\t\t\t\t     m10bmc->info->handshake_sys_reg_nranges);\n}\n\n \nstatic bool m10bmc_handshake_reg_unavailable(struct intel_m10bmc *m10bmc)\n{\n\treturn m10bmc->bmcfw_state == M10BMC_FW_STATE_SEC_UPDATE_PREPARE ||\n\t       m10bmc->bmcfw_state == M10BMC_FW_STATE_SEC_UPDATE_WRITE;\n}\n\n \nint m10bmc_sys_read(struct intel_m10bmc *m10bmc, unsigned int offset, unsigned int *val)\n{\n\tconst struct m10bmc_csr_map *csr_map = m10bmc->info->csr_map;\n\tint ret;\n\n\tif (m10bmc_reg_always_available(m10bmc, offset))\n\t\treturn m10bmc_raw_read(m10bmc, csr_map->base + offset, val);\n\n\tdown_read(&m10bmc->bmcfw_lock);\n\tif (m10bmc_handshake_reg_unavailable(m10bmc))\n\t\tret = -EBUSY;\t \n\telse\n\t\tret = m10bmc_raw_read(m10bmc, csr_map->base + offset, val);\n\tup_read(&m10bmc->bmcfw_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(m10bmc_sys_read, INTEL_M10_BMC_CORE);\n\nint m10bmc_sys_update_bits(struct intel_m10bmc *m10bmc, unsigned int offset,\n\t\t\t   unsigned int msk, unsigned int val)\n{\n\tconst struct m10bmc_csr_map *csr_map = m10bmc->info->csr_map;\n\tint ret;\n\n\tif (m10bmc_reg_always_available(m10bmc, offset))\n\t\treturn regmap_update_bits(m10bmc->regmap, csr_map->base + offset, msk, val);\n\n\tdown_read(&m10bmc->bmcfw_lock);\n\tif (m10bmc_handshake_reg_unavailable(m10bmc))\n\t\tret = -EBUSY;\t \n\telse\n\t\tret = regmap_update_bits(m10bmc->regmap, csr_map->base + offset, msk, val);\n\tup_read(&m10bmc->bmcfw_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(m10bmc_sys_update_bits, INTEL_M10_BMC_CORE);\n\nstatic ssize_t bmc_version_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct intel_m10bmc *ddata = dev_get_drvdata(dev);\n\tunsigned int val;\n\tint ret;\n\n\tret = m10bmc_sys_read(ddata, ddata->info->csr_map->build_version, &val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"0x%x\\n\", val);\n}\nstatic DEVICE_ATTR_RO(bmc_version);\n\nstatic ssize_t bmcfw_version_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct intel_m10bmc *ddata = dev_get_drvdata(dev);\n\tunsigned int val;\n\tint ret;\n\n\tret = m10bmc_sys_read(ddata, ddata->info->csr_map->fw_version, &val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"0x%x\\n\", val);\n}\nstatic DEVICE_ATTR_RO(bmcfw_version);\n\nstatic ssize_t mac_address_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct intel_m10bmc *ddata = dev_get_drvdata(dev);\n\tunsigned int macaddr_low, macaddr_high;\n\tint ret;\n\n\tret = m10bmc_sys_read(ddata, ddata->info->csr_map->mac_low, &macaddr_low);\n\tif (ret)\n\t\treturn ret;\n\n\tret = m10bmc_sys_read(ddata, ddata->info->csr_map->mac_high, &macaddr_high);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"%02x:%02x:%02x:%02x:%02x:%02x\\n\",\n\t\t\t  (u8)FIELD_GET(M10BMC_N3000_MAC_BYTE1, macaddr_low),\n\t\t\t  (u8)FIELD_GET(M10BMC_N3000_MAC_BYTE2, macaddr_low),\n\t\t\t  (u8)FIELD_GET(M10BMC_N3000_MAC_BYTE3, macaddr_low),\n\t\t\t  (u8)FIELD_GET(M10BMC_N3000_MAC_BYTE4, macaddr_low),\n\t\t\t  (u8)FIELD_GET(M10BMC_N3000_MAC_BYTE5, macaddr_high),\n\t\t\t  (u8)FIELD_GET(M10BMC_N3000_MAC_BYTE6, macaddr_high));\n}\nstatic DEVICE_ATTR_RO(mac_address);\n\nstatic ssize_t mac_count_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct intel_m10bmc *ddata = dev_get_drvdata(dev);\n\tunsigned int macaddr_high;\n\tint ret;\n\n\tret = m10bmc_sys_read(ddata, ddata->info->csr_map->mac_high, &macaddr_high);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"%u\\n\", (u8)FIELD_GET(M10BMC_N3000_MAC_COUNT, macaddr_high));\n}\nstatic DEVICE_ATTR_RO(mac_count);\n\nstatic struct attribute *m10bmc_attrs[] = {\n\t&dev_attr_bmc_version.attr,\n\t&dev_attr_bmcfw_version.attr,\n\t&dev_attr_mac_address.attr,\n\t&dev_attr_mac_count.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group m10bmc_group = {\n\t.attrs = m10bmc_attrs,\n};\n\nconst struct attribute_group *m10bmc_dev_groups[] = {\n\t&m10bmc_group,\n\tNULL,\n};\nEXPORT_SYMBOL_NS_GPL(m10bmc_dev_groups, INTEL_M10_BMC_CORE);\n\nint m10bmc_dev_init(struct intel_m10bmc *m10bmc, const struct intel_m10bmc_platform_info *info)\n{\n\tint ret;\n\n\tm10bmc->info = info;\n\tdev_set_drvdata(m10bmc->dev, m10bmc);\n\tinit_rwsem(&m10bmc->bmcfw_lock);\n\n\tret = devm_mfd_add_devices(m10bmc->dev, PLATFORM_DEVID_AUTO,\n\t\t\t\t   info->cells, info->n_cells,\n\t\t\t\t   NULL, 0, NULL);\n\tif (ret)\n\t\tdev_err(m10bmc->dev, \"Failed to register sub-devices: %d\\n\", ret);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(m10bmc_dev_init, INTEL_M10_BMC_CORE);\n\nMODULE_DESCRIPTION(\"Intel MAX 10 BMC core driver\");\nMODULE_AUTHOR(\"Intel Corporation\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}