{
  "module_name": "stpmic1.c",
  "hash_id": "8bad0f1573339115baba2e1b8b13a3ce2750934dac96b1722bbea241f8a111f6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/stpmic1.c",
  "human_readable_source": "\n\n\n\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/stpmic1.h>\n#include <linux/module.h>\n#include <linux/reboot.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/of_platform.h>\n#include <linux/pm_wakeirq.h>\n#include <linux/regmap.h>\n\n#include <dt-bindings/mfd/st,stpmic1.h>\n\n#define STPMIC1_MAIN_IRQ 0\n\nstatic const struct regmap_range stpmic1_readable_ranges[] = {\n\tregmap_reg_range(TURN_ON_SR, VERSION_SR),\n\tregmap_reg_range(MAIN_CR, LDO6_STDBY_CR),\n\tregmap_reg_range(BST_SW_CR, BST_SW_CR),\n\tregmap_reg_range(INT_PENDING_R1, INT_PENDING_R4),\n\tregmap_reg_range(INT_CLEAR_R1, INT_CLEAR_R4),\n\tregmap_reg_range(INT_MASK_R1, INT_MASK_R4),\n\tregmap_reg_range(INT_SET_MASK_R1, INT_SET_MASK_R4),\n\tregmap_reg_range(INT_CLEAR_MASK_R1, INT_CLEAR_MASK_R4),\n\tregmap_reg_range(INT_SRC_R1, INT_SRC_R1),\n};\n\nstatic const struct regmap_range stpmic1_writeable_ranges[] = {\n\tregmap_reg_range(MAIN_CR, LDO6_STDBY_CR),\n\tregmap_reg_range(BST_SW_CR, BST_SW_CR),\n\tregmap_reg_range(INT_CLEAR_R1, INT_CLEAR_R4),\n\tregmap_reg_range(INT_SET_MASK_R1, INT_SET_MASK_R4),\n\tregmap_reg_range(INT_CLEAR_MASK_R1, INT_CLEAR_MASK_R4),\n};\n\nstatic const struct regmap_range stpmic1_volatile_ranges[] = {\n\tregmap_reg_range(TURN_ON_SR, VERSION_SR),\n\tregmap_reg_range(WCHDG_CR, WCHDG_CR),\n\tregmap_reg_range(INT_PENDING_R1, INT_PENDING_R4),\n\tregmap_reg_range(INT_SRC_R1, INT_SRC_R4),\n};\n\nstatic const struct regmap_access_table stpmic1_readable_table = {\n\t.yes_ranges = stpmic1_readable_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(stpmic1_readable_ranges),\n};\n\nstatic const struct regmap_access_table stpmic1_writeable_table = {\n\t.yes_ranges = stpmic1_writeable_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(stpmic1_writeable_ranges),\n};\n\nstatic const struct regmap_access_table stpmic1_volatile_table = {\n\t.yes_ranges = stpmic1_volatile_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(stpmic1_volatile_ranges),\n};\n\nstatic const struct regmap_config stpmic1_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.cache_type = REGCACHE_RBTREE,\n\t.max_register = PMIC_MAX_REGISTER_ADDRESS,\n\t.rd_table = &stpmic1_readable_table,\n\t.wr_table = &stpmic1_writeable_table,\n\t.volatile_table = &stpmic1_volatile_table,\n};\n\nstatic const struct regmap_irq stpmic1_irqs[] = {\n\tREGMAP_IRQ_REG(IT_PONKEY_F, 0, 0x01),\n\tREGMAP_IRQ_REG(IT_PONKEY_R, 0, 0x02),\n\tREGMAP_IRQ_REG(IT_WAKEUP_F, 0, 0x04),\n\tREGMAP_IRQ_REG(IT_WAKEUP_R, 0, 0x08),\n\tREGMAP_IRQ_REG(IT_VBUS_OTG_F, 0, 0x10),\n\tREGMAP_IRQ_REG(IT_VBUS_OTG_R, 0, 0x20),\n\tREGMAP_IRQ_REG(IT_SWOUT_F, 0, 0x40),\n\tREGMAP_IRQ_REG(IT_SWOUT_R, 0, 0x80),\n\n\tREGMAP_IRQ_REG(IT_CURLIM_BUCK1, 1, 0x01),\n\tREGMAP_IRQ_REG(IT_CURLIM_BUCK2, 1, 0x02),\n\tREGMAP_IRQ_REG(IT_CURLIM_BUCK3, 1, 0x04),\n\tREGMAP_IRQ_REG(IT_CURLIM_BUCK4, 1, 0x08),\n\tREGMAP_IRQ_REG(IT_OCP_OTG, 1, 0x10),\n\tREGMAP_IRQ_REG(IT_OCP_SWOUT, 1, 0x20),\n\tREGMAP_IRQ_REG(IT_OCP_BOOST, 1, 0x40),\n\tREGMAP_IRQ_REG(IT_OVP_BOOST, 1, 0x80),\n\n\tREGMAP_IRQ_REG(IT_CURLIM_LDO1, 2, 0x01),\n\tREGMAP_IRQ_REG(IT_CURLIM_LDO2, 2, 0x02),\n\tREGMAP_IRQ_REG(IT_CURLIM_LDO3, 2, 0x04),\n\tREGMAP_IRQ_REG(IT_CURLIM_LDO4, 2, 0x08),\n\tREGMAP_IRQ_REG(IT_CURLIM_LDO5, 2, 0x10),\n\tREGMAP_IRQ_REG(IT_CURLIM_LDO6, 2, 0x20),\n\tREGMAP_IRQ_REG(IT_SHORT_SWOTG, 2, 0x40),\n\tREGMAP_IRQ_REG(IT_SHORT_SWOUT, 2, 0x80),\n\n\tREGMAP_IRQ_REG(IT_TWARN_F, 3, 0x01),\n\tREGMAP_IRQ_REG(IT_TWARN_R, 3, 0x02),\n\tREGMAP_IRQ_REG(IT_VINLOW_F, 3, 0x04),\n\tREGMAP_IRQ_REG(IT_VINLOW_R, 3, 0x08),\n\tREGMAP_IRQ_REG(IT_SWIN_F, 3, 0x40),\n\tREGMAP_IRQ_REG(IT_SWIN_R, 3, 0x80),\n};\n\nstatic const struct regmap_irq_chip stpmic1_regmap_irq_chip = {\n\t.name = \"pmic_irq\",\n\t.status_base = INT_PENDING_R1,\n\t.mask_base = INT_SET_MASK_R1,\n\t.unmask_base = INT_CLEAR_MASK_R1,\n\t.mask_unmask_non_inverted = true,\n\t.ack_base = INT_CLEAR_R1,\n\t.num_regs = STPMIC1_PMIC_NUM_IRQ_REGS,\n\t.irqs = stpmic1_irqs,\n\t.num_irqs = ARRAY_SIZE(stpmic1_irqs),\n};\n\nstatic int stpmic1_power_off(struct sys_off_data *data)\n{\n\tstruct stpmic1 *ddata = data->cb_data;\n\n\tregmap_update_bits(ddata->regmap, MAIN_CR,\n\t\t\t   SOFTWARE_SWITCH_OFF, SOFTWARE_SWITCH_OFF);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int stpmic1_probe(struct i2c_client *i2c)\n{\n\tstruct stpmic1 *ddata;\n\tstruct device *dev = &i2c->dev;\n\tint ret;\n\tstruct device_node *np = dev->of_node;\n\tu32 reg;\n\n\tddata = devm_kzalloc(dev, sizeof(struct stpmic1), GFP_KERNEL);\n\tif (!ddata)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(i2c, ddata);\n\tddata->dev = dev;\n\n\tddata->regmap = devm_regmap_init_i2c(i2c, &stpmic1_regmap_config);\n\tif (IS_ERR(ddata->regmap))\n\t\treturn PTR_ERR(ddata->regmap);\n\n\tddata->irq = of_irq_get(np, STPMIC1_MAIN_IRQ);\n\tif (ddata->irq < 0) {\n\t\tdev_err(dev, \"Failed to get main IRQ: %d\\n\", ddata->irq);\n\t\treturn ddata->irq;\n\t}\n\n\tret = regmap_read(ddata->regmap, VERSION_SR, &reg);\n\tif (ret) {\n\t\tdev_err(dev, \"Unable to read PMIC version\\n\");\n\t\treturn ret;\n\t}\n\tdev_info(dev, \"PMIC Chip Version: 0x%x\\n\", reg);\n\n\t \n\tret = devm_regmap_add_irq_chip(dev, ddata->regmap, ddata->irq,\n\t\t\t\t       IRQF_ONESHOT | IRQF_SHARED,\n\t\t\t\t       0, &stpmic1_regmap_irq_chip,\n\t\t\t\t       &ddata->irq_data);\n\tif (ret) {\n\t\tdev_err(dev, \"IRQ Chip registration failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = devm_register_sys_off_handler(ddata->dev,\n\t\t\t\t\t    SYS_OFF_MODE_POWER_OFF,\n\t\t\t\t\t    SYS_OFF_PRIO_DEFAULT,\n\t\t\t\t\t    stpmic1_power_off,\n\t\t\t\t\t    ddata);\n\tif (ret) {\n\t\tdev_err(ddata->dev, \"failed to register sys-off handler: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn devm_of_platform_populate(dev);\n}\n\nstatic int stpmic1_suspend(struct device *dev)\n{\n\tstruct i2c_client *i2c = to_i2c_client(dev);\n\tstruct stpmic1 *pmic_dev = i2c_get_clientdata(i2c);\n\n\tdisable_irq(pmic_dev->irq);\n\n\treturn 0;\n}\n\nstatic int stpmic1_resume(struct device *dev)\n{\n\tstruct i2c_client *i2c = to_i2c_client(dev);\n\tstruct stpmic1 *pmic_dev = i2c_get_clientdata(i2c);\n\tint ret;\n\n\tret = regcache_sync(pmic_dev->regmap);\n\tif (ret)\n\t\treturn ret;\n\n\tenable_irq(pmic_dev->irq);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(stpmic1_pm, stpmic1_suspend, stpmic1_resume);\n\nstatic const struct of_device_id stpmic1_of_match[] = {\n\t{ .compatible = \"st,stpmic1\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, stpmic1_of_match);\n\nstatic struct i2c_driver stpmic1_driver = {\n\t.driver = {\n\t\t.name = \"stpmic1\",\n\t\t.of_match_table = stpmic1_of_match,\n\t\t.pm = pm_sleep_ptr(&stpmic1_pm),\n\t},\n\t.probe = stpmic1_probe,\n};\n\nmodule_i2c_driver(stpmic1_driver);\n\nMODULE_DESCRIPTION(\"STPMIC1 PMIC Driver\");\nMODULE_AUTHOR(\"Pascal Paillet <p.paillet@st.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}