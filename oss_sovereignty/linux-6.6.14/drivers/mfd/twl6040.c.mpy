{
  "module_name": "twl6040.c",
  "hash_id": "97bcc8d84fc397dd961d7895c5f910444d3e5db74c65b3911bc767ce8be86f52",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/twl6040.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/err.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/gpio/consumer.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/twl6040.h>\n#include <linux/regulator/consumer.h>\n\n#define VIBRACTRL_MEMBER(reg) ((reg == TWL6040_REG_VIBCTLL) ? 0 : 1)\n#define TWL6040_NUM_SUPPLIES\t(2)\n\nstatic const struct reg_default twl6040_defaults[] = {\n\t{ 0x01, 0x4B },  \n\t{ 0x02, 0x00 },  \n\t{ 0x03, 0x00 },  \n\t{ 0x04, 0x00 },  \n\t{ 0x05, 0x00 },  \n\t{ 0x06, 0x00 },  \n\t{ 0x07, 0x60 },  \n\t{ 0x08, 0x00 },  \n\t{ 0x09, 0x4A },  \n\t{ 0x0A, 0x00 },  \n\t{ 0x0B, 0x00 },  \n\t{ 0x0C, 0x00 },  \n\t{ 0x0D, 0x00 },  \n\t{ 0x0E, 0x00 },  \n\t{ 0x0F, 0x1B },  \n\t{ 0x10, 0x00 },  \n\t{ 0x11, 0x00 },  \n\t{ 0x12, 0x00 },  \n\t{ 0x13, 0x00 },  \n\t{ 0x14, 0x00 },  \n\t{ 0x15, 0x00 },  \n\t{ 0x16, 0x00 },  \n\t{ 0x17, 0x00 },  \n\t{ 0x18, 0x00 },  \n\t{ 0x19, 0x00 },  \n\t{ 0x1A, 0x00 },  \n\t{ 0x1B, 0x00 },  \n\t{ 0x1C, 0x00 },  \n\t{ 0x1D, 0x00 },  \n\t{ 0x1E, 0x00 },  \n\t{ 0x1F, 0x00 },  \n\t{ 0x20, 0x00 },  \n\t \n\t \n\t \n\t \n\t \n\t{ 0x2D, 0x08 },  \n\t{ 0x2E, 0x00 },  \n};\n\nstatic struct reg_sequence twl6040_patch[] = {\n\t \n\t{ TWL6040_REG_ACCCTL,\n\t\tTWL6040_I2CSEL | TWL6040_INTCLRMODE | TWL6040_I2CMODE(1) },\n};\n\n\nstatic bool twl6040_has_vibra(struct device_node *parent)\n{\n\tstruct device_node *node;\n\n\tnode = of_get_child_by_name(parent, \"vibra\");\n\tif (node) {\n\t\tof_node_put(node);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nint twl6040_reg_read(struct twl6040 *twl6040, unsigned int reg)\n{\n\tint ret;\n\tunsigned int val;\n\n\tret = regmap_read(twl6040->regmap, reg, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn val;\n}\nEXPORT_SYMBOL(twl6040_reg_read);\n\nint twl6040_reg_write(struct twl6040 *twl6040, unsigned int reg, u8 val)\n{\n\tint ret;\n\n\tret = regmap_write(twl6040->regmap, reg, val);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(twl6040_reg_write);\n\nint twl6040_set_bits(struct twl6040 *twl6040, unsigned int reg, u8 mask)\n{\n\treturn regmap_update_bits(twl6040->regmap, reg, mask, mask);\n}\nEXPORT_SYMBOL(twl6040_set_bits);\n\nint twl6040_clear_bits(struct twl6040 *twl6040, unsigned int reg, u8 mask)\n{\n\treturn regmap_update_bits(twl6040->regmap, reg, mask, 0);\n}\nEXPORT_SYMBOL(twl6040_clear_bits);\n\n \nstatic int twl6040_power_up_manual(struct twl6040 *twl6040)\n{\n\tu8 ldoctl, ncpctl, lppllctl;\n\tint ret;\n\n\t \n\tldoctl = TWL6040_HSLDOENA | TWL6040_REFENA | TWL6040_OSCENA;\n\tret = twl6040_reg_write(twl6040, TWL6040_REG_LDOCTL, ldoctl);\n\tif (ret)\n\t\treturn ret;\n\tusleep_range(10000, 10500);\n\n\t \n\tncpctl = TWL6040_NCPENA;\n\tret = twl6040_reg_write(twl6040, TWL6040_REG_NCPCTL, ncpctl);\n\tif (ret)\n\t\tgoto ncp_err;\n\tusleep_range(1000, 1500);\n\n\t \n\tldoctl |= TWL6040_LSLDOENA;\n\tret = twl6040_reg_write(twl6040, TWL6040_REG_LDOCTL, ldoctl);\n\tif (ret)\n\t\tgoto lsldo_err;\n\tusleep_range(1000, 1500);\n\n\t \n\tlppllctl = TWL6040_LPLLENA;\n\tret = twl6040_reg_write(twl6040, TWL6040_REG_LPPLLCTL, lppllctl);\n\tif (ret)\n\t\tgoto lppll_err;\n\tusleep_range(5000, 5500);\n\n\t \n\tldoctl &= ~TWL6040_OSCENA;\n\tret = twl6040_reg_write(twl6040, TWL6040_REG_LDOCTL, ldoctl);\n\tif (ret)\n\t\tgoto osc_err;\n\n\treturn 0;\n\nosc_err:\n\tlppllctl &= ~TWL6040_LPLLENA;\n\ttwl6040_reg_write(twl6040, TWL6040_REG_LPPLLCTL, lppllctl);\nlppll_err:\n\tldoctl &= ~TWL6040_LSLDOENA;\n\ttwl6040_reg_write(twl6040, TWL6040_REG_LDOCTL, ldoctl);\nlsldo_err:\n\tncpctl &= ~TWL6040_NCPENA;\n\ttwl6040_reg_write(twl6040, TWL6040_REG_NCPCTL, ncpctl);\nncp_err:\n\tldoctl &= ~(TWL6040_HSLDOENA | TWL6040_REFENA | TWL6040_OSCENA);\n\ttwl6040_reg_write(twl6040, TWL6040_REG_LDOCTL, ldoctl);\n\n\tdev_err(twl6040->dev, \"manual power-up failed\\n\");\n\treturn ret;\n}\n\n \nstatic void twl6040_power_down_manual(struct twl6040 *twl6040)\n{\n\tu8 ncpctl, ldoctl, lppllctl;\n\n\tncpctl = twl6040_reg_read(twl6040, TWL6040_REG_NCPCTL);\n\tldoctl = twl6040_reg_read(twl6040, TWL6040_REG_LDOCTL);\n\tlppllctl = twl6040_reg_read(twl6040, TWL6040_REG_LPPLLCTL);\n\n\t \n\tldoctl |= TWL6040_OSCENA;\n\ttwl6040_reg_write(twl6040, TWL6040_REG_LDOCTL, ldoctl);\n\tusleep_range(1000, 1500);\n\n\t \n\tlppllctl &= ~TWL6040_LPLLENA;\n\ttwl6040_reg_write(twl6040, TWL6040_REG_LPPLLCTL, lppllctl);\n\n\t \n\tldoctl &= ~TWL6040_LSLDOENA;\n\ttwl6040_reg_write(twl6040, TWL6040_REG_LDOCTL, ldoctl);\n\n\t \n\tncpctl &= ~TWL6040_NCPENA;\n\ttwl6040_reg_write(twl6040, TWL6040_REG_NCPCTL, ncpctl);\n\n\t \n\tldoctl &= ~(TWL6040_HSLDOENA | TWL6040_REFENA | TWL6040_OSCENA);\n\ttwl6040_reg_write(twl6040, TWL6040_REG_LDOCTL, ldoctl);\n}\n\nstatic irqreturn_t twl6040_readyint_handler(int irq, void *data)\n{\n\tstruct twl6040 *twl6040 = data;\n\n\tcomplete(&twl6040->ready);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t twl6040_thint_handler(int irq, void *data)\n{\n\tstruct twl6040 *twl6040 = data;\n\tu8 status;\n\n\tstatus = twl6040_reg_read(twl6040, TWL6040_REG_STATUS);\n\tif (status & TWL6040_TSHUTDET) {\n\t\tdev_warn(twl6040->dev, \"Thermal shutdown, powering-off\");\n\t\ttwl6040_power(twl6040, 0);\n\t} else {\n\t\tdev_warn(twl6040->dev, \"Leaving thermal shutdown, powering-on\");\n\t\ttwl6040_power(twl6040, 1);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int twl6040_power_up_automatic(struct twl6040 *twl6040)\n{\n\tint time_left;\n\n\tgpiod_set_value_cansleep(twl6040->audpwron, 1);\n\n\ttime_left = wait_for_completion_timeout(&twl6040->ready,\n\t\t\t\t\t\tmsecs_to_jiffies(144));\n\tif (!time_left) {\n\t\tu8 intid;\n\n\t\tdev_warn(twl6040->dev, \"timeout waiting for READYINT\\n\");\n\t\tintid = twl6040_reg_read(twl6040, TWL6040_REG_INTID);\n\t\tif (!(intid & TWL6040_READYINT)) {\n\t\t\tdev_err(twl6040->dev, \"automatic power-up failed\\n\");\n\t\t\tgpiod_set_value_cansleep(twl6040->audpwron, 0);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint twl6040_power(struct twl6040 *twl6040, int on)\n{\n\tint ret = 0;\n\n\tmutex_lock(&twl6040->mutex);\n\n\tif (on) {\n\t\t \n\t\tif (twl6040->power_count++)\n\t\t\tgoto out;\n\n\t\tret = clk_prepare_enable(twl6040->clk32k);\n\t\tif (ret) {\n\t\t\ttwl6040->power_count = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tregcache_cache_only(twl6040->regmap, false);\n\n\t\tif (twl6040->audpwron) {\n\t\t\t \n\t\t\tret = twl6040_power_up_automatic(twl6040);\n\t\t\tif (ret) {\n\t\t\t\tclk_disable_unprepare(twl6040->clk32k);\n\t\t\t\ttwl6040->power_count = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tret = twl6040_power_up_manual(twl6040);\n\t\t\tif (ret) {\n\t\t\t\tclk_disable_unprepare(twl6040->clk32k);\n\t\t\t\ttwl6040->power_count = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tusleep_range(10000, 12000);\n\n\t\t \n\t\tret = regcache_sync(twl6040->regmap);\n\t\tif (ret) {\n\t\t\tdev_err(twl6040->dev, \"Failed to sync with the HW: %i\\n\",\n\t\t\t\tret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\ttwl6040->pll = TWL6040_SYSCLK_SEL_LPPLL;\n\t\ttwl6040->sysclk_rate = 19200000;\n\t} else {\n\t\t \n\t\tif (!twl6040->power_count) {\n\t\t\tdev_err(twl6040->dev,\n\t\t\t\t\"device is already powered-off\\n\");\n\t\t\tret = -EPERM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (--twl6040->power_count)\n\t\t\tgoto out;\n\n\t\tif (twl6040->audpwron) {\n\t\t\t \n\t\t\tgpiod_set_value_cansleep(twl6040->audpwron, 0);\n\n\t\t\t \n\t\t\tusleep_range(500, 700);\n\t\t} else {\n\t\t\t \n\t\t\ttwl6040_power_down_manual(twl6040);\n\t\t}\n\n\t\t \n\t\tregcache_cache_only(twl6040->regmap, true);\n\t\tregcache_mark_dirty(twl6040->regmap);\n\n\t\ttwl6040->sysclk_rate = 0;\n\n\t\tif (twl6040->pll == TWL6040_SYSCLK_SEL_HPPLL) {\n\t\t\tclk_disable_unprepare(twl6040->mclk);\n\t\t\ttwl6040->mclk_rate = 0;\n\t\t}\n\n\t\tclk_disable_unprepare(twl6040->clk32k);\n\t}\n\nout:\n\tmutex_unlock(&twl6040->mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL(twl6040_power);\n\nint twl6040_set_pll(struct twl6040 *twl6040, int pll_id,\n\t\t    unsigned int freq_in, unsigned int freq_out)\n{\n\tu8 hppllctl, lppllctl;\n\tint ret = 0;\n\n\tmutex_lock(&twl6040->mutex);\n\n\thppllctl = twl6040_reg_read(twl6040, TWL6040_REG_HPPLLCTL);\n\tlppllctl = twl6040_reg_read(twl6040, TWL6040_REG_LPPLLCTL);\n\n\t \n\tif (pll_id != twl6040->pll) {\n\t\ttwl6040->sysclk_rate = 0;\n\t\ttwl6040->mclk_rate = 0;\n\t}\n\n\tswitch (pll_id) {\n\tcase TWL6040_SYSCLK_SEL_LPPLL:\n\t\t \n\t\t \n\t\tif (twl6040->sysclk_rate != freq_out) {\n\t\t\tswitch (freq_out) {\n\t\t\tcase 17640000:\n\t\t\t\tlppllctl |= TWL6040_LPLLFIN;\n\t\t\t\tbreak;\n\t\t\tcase 19200000:\n\t\t\t\tlppllctl &= ~TWL6040_LPLLFIN;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdev_err(twl6040->dev,\n\t\t\t\t\t\"freq_out %d not supported\\n\",\n\t\t\t\t\tfreq_out);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto pll_out;\n\t\t\t}\n\t\t\ttwl6040_reg_write(twl6040, TWL6040_REG_LPPLLCTL,\n\t\t\t\t\t  lppllctl);\n\t\t}\n\n\t\t \n\t\tif (twl6040->pll == pll_id)\n\t\t\tbreak;\n\n\t\tswitch (freq_in) {\n\t\tcase 32768:\n\t\t\tlppllctl |= TWL6040_LPLLENA;\n\t\t\ttwl6040_reg_write(twl6040, TWL6040_REG_LPPLLCTL,\n\t\t\t\t\t  lppllctl);\n\t\t\tmdelay(5);\n\t\t\tlppllctl &= ~TWL6040_HPLLSEL;\n\t\t\ttwl6040_reg_write(twl6040, TWL6040_REG_LPPLLCTL,\n\t\t\t\t\t  lppllctl);\n\t\t\thppllctl &= ~TWL6040_HPLLENA;\n\t\t\ttwl6040_reg_write(twl6040, TWL6040_REG_HPPLLCTL,\n\t\t\t\t\t  hppllctl);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(twl6040->dev,\n\t\t\t\t\"freq_in %d not supported\\n\", freq_in);\n\t\t\tret = -EINVAL;\n\t\t\tgoto pll_out;\n\t\t}\n\n\t\tclk_disable_unprepare(twl6040->mclk);\n\t\tbreak;\n\tcase TWL6040_SYSCLK_SEL_HPPLL:\n\t\t \n\t\tif (freq_out != 19200000) {\n\t\t\tdev_err(twl6040->dev,\n\t\t\t\t\"freq_out %d not supported\\n\", freq_out);\n\t\t\tret = -EINVAL;\n\t\t\tgoto pll_out;\n\t\t}\n\n\t\tif (twl6040->mclk_rate != freq_in) {\n\t\t\thppllctl &= ~TWL6040_MCLK_MSK;\n\n\t\t\tswitch (freq_in) {\n\t\t\tcase 12000000:\n\t\t\t\t \n\t\t\t\thppllctl |= TWL6040_MCLK_12000KHZ |\n\t\t\t\t\t    TWL6040_HPLLENA;\n\t\t\t\tbreak;\n\t\t\tcase 19200000:\n\t\t\t\t \n\t\t\t\thppllctl |= TWL6040_MCLK_19200KHZ |\n\t\t\t\t\t    TWL6040_HPLLBP | TWL6040_HPLLENA;\n\t\t\t\tbreak;\n\t\t\tcase 26000000:\n\t\t\t\t \n\t\t\t\thppllctl |= TWL6040_MCLK_26000KHZ |\n\t\t\t\t\t    TWL6040_HPLLENA;\n\t\t\t\tbreak;\n\t\t\tcase 38400000:\n\t\t\t\t \n\t\t\t\thppllctl |= TWL6040_MCLK_38400KHZ |\n\t\t\t\t\t    TWL6040_HPLLBP | TWL6040_HPLLENA;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdev_err(twl6040->dev,\n\t\t\t\t\t\"freq_in %d not supported\\n\", freq_in);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto pll_out;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (pll_id != twl6040->pll)\n\t\t\t\tclk_prepare_enable(twl6040->mclk);\n\t\t\t \n\t\t\thppllctl |= TWL6040_HPLLSQRENA;\n\n\t\t\ttwl6040_reg_write(twl6040, TWL6040_REG_HPPLLCTL,\n\t\t\t\t\t  hppllctl);\n\t\t\tusleep_range(500, 700);\n\t\t\tlppllctl |= TWL6040_HPLLSEL;\n\t\t\ttwl6040_reg_write(twl6040, TWL6040_REG_LPPLLCTL,\n\t\t\t\t\t  lppllctl);\n\t\t\tlppllctl &= ~TWL6040_LPLLENA;\n\t\t\ttwl6040_reg_write(twl6040, TWL6040_REG_LPPLLCTL,\n\t\t\t\t\t  lppllctl);\n\n\t\t\ttwl6040->mclk_rate = freq_in;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(twl6040->dev, \"unknown pll id %d\\n\", pll_id);\n\t\tret = -EINVAL;\n\t\tgoto pll_out;\n\t}\n\n\ttwl6040->sysclk_rate = freq_out;\n\ttwl6040->pll = pll_id;\n\npll_out:\n\tmutex_unlock(&twl6040->mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL(twl6040_set_pll);\n\nint twl6040_get_pll(struct twl6040 *twl6040)\n{\n\tif (twl6040->power_count)\n\t\treturn twl6040->pll;\n\telse\n\t\treturn -ENODEV;\n}\nEXPORT_SYMBOL(twl6040_get_pll);\n\nunsigned int twl6040_get_sysclk(struct twl6040 *twl6040)\n{\n\treturn twl6040->sysclk_rate;\n}\nEXPORT_SYMBOL(twl6040_get_sysclk);\n\n \nint twl6040_get_vibralr_status(struct twl6040 *twl6040)\n{\n\tunsigned int reg;\n\tint ret;\n\tu8 status;\n\n\tret = regmap_read(twl6040->regmap, TWL6040_REG_VIBCTLL, &reg);\n\tif (ret != 0)\n\t\treturn ret;\n\tstatus = reg;\n\n\tret = regmap_read(twl6040->regmap, TWL6040_REG_VIBCTLR, &reg);\n\tif (ret != 0)\n\t\treturn ret;\n\tstatus |= reg;\n\n\tstatus &= (TWL6040_VIBENA | TWL6040_VIBSEL);\n\n\treturn status;\n}\nEXPORT_SYMBOL(twl6040_get_vibralr_status);\n\nstatic struct resource twl6040_vibra_rsrc[] = {\n\t{\n\t\t.flags = IORESOURCE_IRQ,\n\t},\n};\n\nstatic struct resource twl6040_codec_rsrc[] = {\n\t{\n\t\t.flags = IORESOURCE_IRQ,\n\t},\n};\n\nstatic bool twl6040_readable_reg(struct device *dev, unsigned int reg)\n{\n\t \n\tif (!reg)\n\t\treturn false;\n\treturn true;\n}\n\nstatic bool twl6040_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase TWL6040_REG_ASICID:\n\tcase TWL6040_REG_ASICREV:\n\tcase TWL6040_REG_INTID:\n\tcase TWL6040_REG_LPPLLCTL:\n\tcase TWL6040_REG_HPPLLCTL:\n\tcase TWL6040_REG_STATUS:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool twl6040_writeable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase TWL6040_REG_ASICID:\n\tcase TWL6040_REG_ASICREV:\n\tcase TWL6040_REG_STATUS:\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nstatic const struct regmap_config twl6040_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.reg_defaults = twl6040_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(twl6040_defaults),\n\n\t.max_register = TWL6040_REG_STATUS,  \n\n\t.readable_reg = twl6040_readable_reg,\n\t.volatile_reg = twl6040_volatile_reg,\n\t.writeable_reg = twl6040_writeable_reg,\n\n\t.cache_type = REGCACHE_MAPLE,\n\t.use_single_read = true,\n\t.use_single_write = true,\n};\n\nstatic const struct regmap_irq twl6040_irqs[] = {\n\t{ .reg_offset = 0, .mask = TWL6040_THINT, },\n\t{ .reg_offset = 0, .mask = TWL6040_PLUGINT | TWL6040_UNPLUGINT, },\n\t{ .reg_offset = 0, .mask = TWL6040_HOOKINT, },\n\t{ .reg_offset = 0, .mask = TWL6040_HFINT, },\n\t{ .reg_offset = 0, .mask = TWL6040_VIBINT, },\n\t{ .reg_offset = 0, .mask = TWL6040_READYINT, },\n};\n\nstatic struct regmap_irq_chip twl6040_irq_chip = {\n\t.name = \"twl6040\",\n\t.irqs = twl6040_irqs,\n\t.num_irqs = ARRAY_SIZE(twl6040_irqs),\n\n\t.num_regs = 1,\n\t.status_base = TWL6040_REG_INTID,\n\t.mask_base = TWL6040_REG_INTMR,\n};\n\nstatic int twl6040_probe(struct i2c_client *client)\n{\n\tstruct device_node *node = client->dev.of_node;\n\tstruct twl6040 *twl6040;\n\tstruct mfd_cell *cell = NULL;\n\tint irq, ret, children = 0;\n\n\tif (!node) {\n\t\tdev_err(&client->dev, \"of node is missing\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!client->irq) {\n\t\tdev_err(&client->dev, \"Invalid IRQ configuration\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttwl6040 = devm_kzalloc(&client->dev, sizeof(struct twl6040),\n\t\t\t       GFP_KERNEL);\n\tif (!twl6040)\n\t\treturn -ENOMEM;\n\n\ttwl6040->regmap = devm_regmap_init_i2c(client, &twl6040_regmap_config);\n\tif (IS_ERR(twl6040->regmap))\n\t\treturn PTR_ERR(twl6040->regmap);\n\n\ti2c_set_clientdata(client, twl6040);\n\n\ttwl6040->clk32k = devm_clk_get(&client->dev, \"clk32k\");\n\tif (IS_ERR(twl6040->clk32k)) {\n\t\tif (PTR_ERR(twl6040->clk32k) == -EPROBE_DEFER)\n\t\t\treturn -EPROBE_DEFER;\n\t\tdev_dbg(&client->dev, \"clk32k is not handled\\n\");\n\t\ttwl6040->clk32k = NULL;\n\t}\n\n\ttwl6040->mclk = devm_clk_get(&client->dev, \"mclk\");\n\tif (IS_ERR(twl6040->mclk)) {\n\t\tif (PTR_ERR(twl6040->mclk) == -EPROBE_DEFER)\n\t\t\treturn -EPROBE_DEFER;\n\t\tdev_dbg(&client->dev, \"mclk is not handled\\n\");\n\t\ttwl6040->mclk = NULL;\n\t}\n\n\ttwl6040->supplies[0].supply = \"vio\";\n\ttwl6040->supplies[1].supply = \"v2v1\";\n\tret = devm_regulator_bulk_get(&client->dev, TWL6040_NUM_SUPPLIES,\n\t\t\t\t      twl6040->supplies);\n\tif (ret != 0) {\n\t\tdev_err(&client->dev, \"Failed to get supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regulator_bulk_enable(TWL6040_NUM_SUPPLIES, twl6040->supplies);\n\tif (ret != 0) {\n\t\tdev_err(&client->dev, \"Failed to enable supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\ttwl6040->dev = &client->dev;\n\ttwl6040->irq = client->irq;\n\n\tmutex_init(&twl6040->mutex);\n\tinit_completion(&twl6040->ready);\n\n\tregmap_register_patch(twl6040->regmap, twl6040_patch,\n\t\t\t      ARRAY_SIZE(twl6040_patch));\n\n\ttwl6040->rev = twl6040_reg_read(twl6040, TWL6040_REG_ASICREV);\n\tif (twl6040->rev < 0) {\n\t\tdev_err(&client->dev, \"Failed to read revision register: %d\\n\",\n\t\t\ttwl6040->rev);\n\t\tret = twl6040->rev;\n\t\tgoto gpio_err;\n\t}\n\n\t \n\tif (twl6040_get_revid(twl6040) > TWL6040_REV_ES1_0) {\n\t\ttwl6040->audpwron = devm_gpiod_get_optional(&client->dev,\n\t\t\t\t\t\t\t    \"ti,audpwron\",\n\t\t\t\t\t\t\t    GPIOD_OUT_LOW);\n\t\tret = PTR_ERR_OR_ZERO(twl6040->audpwron);\n\t\tif (ret)\n\t\t\tgoto gpio_err;\n\n\t\tgpiod_set_consumer_name(twl6040->audpwron, \"audpwron\");\n\n\t\t \n\t\ttwl6040_reg_read(twl6040, TWL6040_REG_INTID);\n\t}\n\n\tret = regmap_add_irq_chip(twl6040->regmap, twl6040->irq, IRQF_ONESHOT,\n\t\t\t\t  0, &twl6040_irq_chip, &twl6040->irq_data);\n\tif (ret < 0)\n\t\tgoto gpio_err;\n\n\ttwl6040->irq_ready = regmap_irq_get_virq(twl6040->irq_data,\n\t\t\t\t\t\t TWL6040_IRQ_READY);\n\ttwl6040->irq_th = regmap_irq_get_virq(twl6040->irq_data,\n\t\t\t\t\t      TWL6040_IRQ_TH);\n\n\tret = devm_request_threaded_irq(twl6040->dev, twl6040->irq_ready, NULL,\n\t\t\t\t\ttwl6040_readyint_handler, IRQF_ONESHOT,\n\t\t\t\t\t\"twl6040_irq_ready\", twl6040);\n\tif (ret) {\n\t\tdev_err(twl6040->dev, \"READY IRQ request failed: %d\\n\", ret);\n\t\tgoto readyirq_err;\n\t}\n\n\tret = devm_request_threaded_irq(twl6040->dev, twl6040->irq_th, NULL,\n\t\t\t\t\ttwl6040_thint_handler, IRQF_ONESHOT,\n\t\t\t\t\t\"twl6040_irq_th\", twl6040);\n\tif (ret) {\n\t\tdev_err(twl6040->dev, \"Thermal IRQ request failed: %d\\n\", ret);\n\t\tgoto readyirq_err;\n\t}\n\n\t \n\tirq = regmap_irq_get_virq(twl6040->irq_data, TWL6040_IRQ_PLUG);\n\tcell = &twl6040->cells[children];\n\tcell->name = \"twl6040-codec\";\n\ttwl6040_codec_rsrc[0].start = irq;\n\ttwl6040_codec_rsrc[0].end = irq;\n\tcell->resources = twl6040_codec_rsrc;\n\tcell->num_resources = ARRAY_SIZE(twl6040_codec_rsrc);\n\tchildren++;\n\n\t \n\tif (twl6040_has_vibra(node)) {\n\t\tirq = regmap_irq_get_virq(twl6040->irq_data, TWL6040_IRQ_VIB);\n\n\t\tcell = &twl6040->cells[children];\n\t\tcell->name = \"twl6040-vibra\";\n\t\ttwl6040_vibra_rsrc[0].start = irq;\n\t\ttwl6040_vibra_rsrc[0].end = irq;\n\t\tcell->resources = twl6040_vibra_rsrc;\n\t\tcell->num_resources = ARRAY_SIZE(twl6040_vibra_rsrc);\n\t\tchildren++;\n\t}\n\n\t \n\tcell = &twl6040->cells[children];\n\tcell->name = \"twl6040-gpo\";\n\tchildren++;\n\n\t \n\tcell = &twl6040->cells[children];\n\tcell->name = \"twl6040-pdmclk\";\n\tchildren++;\n\n\t \n\tregcache_cache_only(twl6040->regmap, true);\n\tregcache_mark_dirty(twl6040->regmap);\n\n\tret = mfd_add_devices(&client->dev, -1, twl6040->cells, children,\n\t\t\t      NULL, 0, NULL);\n\tif (ret)\n\t\tgoto readyirq_err;\n\n\treturn 0;\n\nreadyirq_err:\n\tregmap_del_irq_chip(twl6040->irq, twl6040->irq_data);\ngpio_err:\n\tregulator_bulk_disable(TWL6040_NUM_SUPPLIES, twl6040->supplies);\n\treturn ret;\n}\n\nstatic void twl6040_remove(struct i2c_client *client)\n{\n\tstruct twl6040 *twl6040 = i2c_get_clientdata(client);\n\n\tif (twl6040->power_count)\n\t\ttwl6040_power(twl6040, 0);\n\n\tregmap_del_irq_chip(twl6040->irq, twl6040->irq_data);\n\n\tmfd_remove_devices(&client->dev);\n\n\tregulator_bulk_disable(TWL6040_NUM_SUPPLIES, twl6040->supplies);\n}\n\nstatic const struct i2c_device_id twl6040_i2c_id[] = {\n\t{ \"twl6040\", 0, },\n\t{ \"twl6041\", 0, },\n\t{ },\n};\nMODULE_DEVICE_TABLE(i2c, twl6040_i2c_id);\n\nstatic struct i2c_driver twl6040_driver = {\n\t.driver = {\n\t\t.name = \"twl6040\",\n\t},\n\t.probe\t\t= twl6040_probe,\n\t.remove\t\t= twl6040_remove,\n\t.id_table\t= twl6040_i2c_id,\n};\n\nmodule_i2c_driver(twl6040_driver);\n\nMODULE_DESCRIPTION(\"TWL6040 MFD\");\nMODULE_AUTHOR(\"Misael Lopez Cruz <misael.lopez@ti.com>\");\nMODULE_AUTHOR(\"Jorge Eduardo Candelaria <jorge.candelaria@ti.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}