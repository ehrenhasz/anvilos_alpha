{
  "module_name": "wm97xx-core.c",
  "hash_id": "d68eae3e4ab0921b1c80ae992c4420117580629df3531e8045485566c8f12cf4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/wm97xx-core.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/wm97xx.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/wm97xx.h>\n#include <sound/ac97/codec.h>\n#include <sound/ac97/compat.h>\n\n#define WM9705_VENDOR_ID 0x574d4c05\n#define WM9712_VENDOR_ID 0x574d4c12\n#define WM9713_VENDOR_ID 0x574d4c13\n#define WM97xx_VENDOR_ID_MASK 0xffffffff\n\nstruct wm97xx_priv {\n\tstruct regmap *regmap;\n\tstruct snd_ac97 *ac97;\n\tstruct device *dev;\n\tstruct wm97xx_platform_data codec_pdata;\n};\n\nstatic bool wm97xx_readable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase AC97_RESET ... AC97_PCM_SURR_DAC_RATE:\n\tcase AC97_PCM_LR_ADC_RATE:\n\tcase AC97_CENTER_LFE_MASTER:\n\tcase AC97_SPDIF ... AC97_LINE1_LEVEL:\n\tcase AC97_GPIO_CFG ... 0x5c:\n\tcase AC97_CODEC_CLASS_REV ... AC97_PCI_SID:\n\tcase 0x74 ... AC97_VENDOR_ID2:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool wm97xx_writeable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase AC97_VENDOR_ID1:\n\tcase AC97_VENDOR_ID2:\n\t\treturn false;\n\tdefault:\n\t\treturn wm97xx_readable_reg(dev, reg);\n\t}\n}\n\nstatic const struct reg_default wm9705_reg_defaults[] = {\n\t{ 0x02, 0x8000 },\n\t{ 0x04, 0x8000 },\n\t{ 0x06, 0x8000 },\n\t{ 0x0a, 0x8000 },\n\t{ 0x0c, 0x8008 },\n\t{ 0x0e, 0x8008 },\n\t{ 0x10, 0x8808 },\n\t{ 0x12, 0x8808 },\n\t{ 0x14, 0x8808 },\n\t{ 0x16, 0x8808 },\n\t{ 0x18, 0x8808 },\n\t{ 0x1a, 0x0000 },\n\t{ 0x1c, 0x8000 },\n\t{ 0x20, 0x0000 },\n\t{ 0x22, 0x0000 },\n\t{ 0x26, 0x000f },\n\t{ 0x28, 0x0605 },\n\t{ 0x2a, 0x0000 },\n\t{ 0x2c, 0xbb80 },\n\t{ 0x32, 0xbb80 },\n\t{ 0x34, 0x2000 },\n\t{ 0x5a, 0x0000 },\n\t{ 0x5c, 0x0000 },\n\t{ 0x72, 0x0808 },\n\t{ 0x74, 0x0000 },\n\t{ 0x76, 0x0006 },\n\t{ 0x78, 0x0000 },\n\t{ 0x7a, 0x0000 },\n};\n\nstatic const struct regmap_config wm9705_regmap_config = {\n\t.reg_bits = 16,\n\t.reg_stride = 2,\n\t.val_bits = 16,\n\t.max_register = 0x7e,\n\t.cache_type = REGCACHE_RBTREE,\n\n\t.reg_defaults = wm9705_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(wm9705_reg_defaults),\n\t.volatile_reg = regmap_ac97_default_volatile,\n\t.readable_reg = wm97xx_readable_reg,\n\t.writeable_reg = wm97xx_writeable_reg,\n};\n\nstatic struct mfd_cell wm9705_cells[] = {\n\t{ .name = \"wm9705-codec\", },\n\t{ .name = \"wm97xx-ts\", },\n};\n\nstatic bool wm9712_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase AC97_REC_GAIN:\n\t\treturn true;\n\tdefault:\n\t\treturn regmap_ac97_default_volatile(dev, reg);\n\t}\n}\n\nstatic const struct reg_default wm9712_reg_defaults[] = {\n\t{ 0x02, 0x8000 },\n\t{ 0x04, 0x8000 },\n\t{ 0x06, 0x8000 },\n\t{ 0x08, 0x0f0f },\n\t{ 0x0a, 0xaaa0 },\n\t{ 0x0c, 0xc008 },\n\t{ 0x0e, 0x6808 },\n\t{ 0x10, 0xe808 },\n\t{ 0x12, 0xaaa0 },\n\t{ 0x14, 0xad00 },\n\t{ 0x16, 0x8000 },\n\t{ 0x18, 0xe808 },\n\t{ 0x1a, 0x3000 },\n\t{ 0x1c, 0x8000 },\n\t{ 0x20, 0x0000 },\n\t{ 0x22, 0x0000 },\n\t{ 0x26, 0x000f },\n\t{ 0x28, 0x0605 },\n\t{ 0x2a, 0x0410 },\n\t{ 0x2c, 0xbb80 },\n\t{ 0x2e, 0xbb80 },\n\t{ 0x32, 0xbb80 },\n\t{ 0x34, 0x2000 },\n\t{ 0x4c, 0xf83e },\n\t{ 0x4e, 0xffff },\n\t{ 0x50, 0x0000 },\n\t{ 0x52, 0x0000 },\n\t{ 0x56, 0xf83e },\n\t{ 0x58, 0x0008 },\n\t{ 0x5c, 0x0000 },\n\t{ 0x60, 0xb032 },\n\t{ 0x62, 0x3e00 },\n\t{ 0x64, 0x0000 },\n\t{ 0x76, 0x0006 },\n\t{ 0x78, 0x0001 },\n\t{ 0x7a, 0x0000 },\n};\n\nstatic const struct regmap_config wm9712_regmap_config = {\n\t.reg_bits = 16,\n\t.reg_stride = 2,\n\t.val_bits = 16,\n\t.max_register = 0x7e,\n\t.cache_type = REGCACHE_RBTREE,\n\n\t.reg_defaults = wm9712_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(wm9712_reg_defaults),\n\t.volatile_reg = wm9712_volatile_reg,\n\t.readable_reg = wm97xx_readable_reg,\n\t.writeable_reg = wm97xx_writeable_reg,\n};\n\nstatic struct mfd_cell wm9712_cells[] = {\n\t{ .name = \"wm9712-codec\", },\n\t{ .name = \"wm97xx-ts\", },\n};\n\nstatic const struct reg_default wm9713_reg_defaults[] = {\n\t{ 0x02, 0x8080 },\t \n\t{ 0x04, 0x8080 },\t \n\t{ 0x06, 0x8080 },\t \n\t{ 0x08, 0xc880 },\t \n\t{ 0x0a, 0xe808 },\t \n\t{ 0x0c, 0xe808 },\t \n\t{ 0x0e, 0x0808 },\t \n\t{ 0x10, 0x00da },\t \n\t{ 0x12, 0x8000 },\t \n\t{ 0x14, 0xd600 },\t \n\t{ 0x16, 0xaaa0 },\t \n\t{ 0x18, 0xaaa0 },\t \n\t{ 0x1a, 0xaaa0 },\t \n\t{ 0x1c, 0x0000 },\t \n\t{ 0x1e, 0x0000 },\t \n\t{ 0x20, 0x0f0f },\t \n\t{ 0x22, 0x0040 },\t \n\t{ 0x24, 0x0000 },\t \n\t{ 0x26, 0x7f00 },\t \n\t{ 0x28, 0x0405 },\t \n\t{ 0x2a, 0x0410 },\t \n\t{ 0x2c, 0xbb80 },\t \n\t{ 0x2e, 0xbb80 },\t \n\t{ 0x32, 0xbb80 },\t \n\t{ 0x36, 0x4523 },\t \n\t{ 0x3a, 0x2000 },\t \n\t{ 0x3c, 0xfdff },\t \n\t{ 0x3e, 0xffff },\t \n\t{ 0x40, 0x0000 },\t \n\t{ 0x42, 0x0000 },\t \n\t{ 0x44, 0x0080 },\t \n\t{ 0x46, 0x0000 },\t \n\n\t{ 0x4c, 0xfffe },\t \n\t{ 0x4e, 0xffff },\t \n\t{ 0x50, 0x0000 },\t \n\t{ 0x52, 0x0000 },\t \n\t\t\t\t \n\t{ 0x56, 0xfffe },\t \n\t{ 0x58, 0x4000 },\t \n\t{ 0x5a, 0x0000 },\t \n\t{ 0x5c, 0x0000 },\t \n\t{ 0x60, 0xb032 },\t \n\t{ 0x62, 0x3e00 },\t \n\t{ 0x64, 0x0000 },\t \n\t{ 0x74, 0x0000 },\t \n\t{ 0x76, 0x0006 },\t \n\t{ 0x78, 0x0001 },\t \n\t{ 0x7a, 0x0000 },\t \n};\n\nstatic const struct regmap_config wm9713_regmap_config = {\n\t.reg_bits = 16,\n\t.reg_stride = 2,\n\t.val_bits = 16,\n\t.max_register = 0x7e,\n\t.cache_type = REGCACHE_RBTREE,\n\n\t.reg_defaults = wm9713_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(wm9713_reg_defaults),\n\t.volatile_reg = regmap_ac97_default_volatile,\n\t.readable_reg = wm97xx_readable_reg,\n\t.writeable_reg = wm97xx_writeable_reg,\n};\n\nstatic struct mfd_cell wm9713_cells[] = {\n\t{ .name = \"wm9713-codec\", },\n\t{ .name = \"wm97xx-ts\", },\n};\n\nstatic int wm97xx_ac97_probe(struct ac97_codec_device *adev)\n{\n\tstruct wm97xx_priv *wm97xx;\n\tconst struct regmap_config *config;\n\tstruct wm97xx_platform_data *codec_pdata;\n\tstruct mfd_cell *cells;\n\tint ret = -ENODEV, nb_cells, i;\n\tstruct wm97xx_pdata *pdata = snd_ac97_codec_get_platdata(adev);\n\n\twm97xx = devm_kzalloc(ac97_codec_dev2dev(adev),\n\t\t\t      sizeof(*wm97xx), GFP_KERNEL);\n\tif (!wm97xx)\n\t\treturn -ENOMEM;\n\n\twm97xx->dev = ac97_codec_dev2dev(adev);\n\twm97xx->ac97 = snd_ac97_compat_alloc(adev);\n\tif (IS_ERR(wm97xx->ac97))\n\t\treturn PTR_ERR(wm97xx->ac97);\n\n\n\tac97_set_drvdata(adev, wm97xx);\n\tdev_info(wm97xx->dev, \"wm97xx core found, id=0x%x\\n\",\n\t\t adev->vendor_id);\n\n\tcodec_pdata = &wm97xx->codec_pdata;\n\tcodec_pdata->ac97 = wm97xx->ac97;\n\tcodec_pdata->batt_pdata = pdata ? pdata->batt_pdata : NULL;\n\n\tswitch (adev->vendor_id) {\n\tcase WM9705_VENDOR_ID:\n\t\tconfig = &wm9705_regmap_config;\n\t\tcells = wm9705_cells;\n\t\tnb_cells = ARRAY_SIZE(wm9705_cells);\n\t\tbreak;\n\tcase WM9712_VENDOR_ID:\n\t\tconfig = &wm9712_regmap_config;\n\t\tcells = wm9712_cells;\n\t\tnb_cells = ARRAY_SIZE(wm9712_cells);\n\t\tbreak;\n\tcase WM9713_VENDOR_ID:\n\t\tconfig = &wm9713_regmap_config;\n\t\tcells = wm9713_cells;\n\t\tnb_cells = ARRAY_SIZE(wm9713_cells);\n\t\tbreak;\n\tdefault:\n\t\tgoto err_free_compat;\n\t}\n\n\tfor (i = 0; i < nb_cells; i++) {\n\t\tcells[i].platform_data = codec_pdata;\n\t\tcells[i].pdata_size = sizeof(*codec_pdata);\n\t}\n\n\tcodec_pdata->regmap = devm_regmap_init_ac97(wm97xx->ac97, config);\n\tif (IS_ERR(codec_pdata->regmap)) {\n\t\tret = PTR_ERR(codec_pdata->regmap);\n\t\tgoto err_free_compat;\n\t}\n\n\tret = devm_mfd_add_devices(wm97xx->dev, PLATFORM_DEVID_NONE,\n\t\t\t\t   cells, nb_cells, NULL, 0, NULL);\n\tif (ret)\n\t\tgoto err_free_compat;\n\n\treturn ret;\n\nerr_free_compat:\n\tsnd_ac97_compat_release(wm97xx->ac97);\n\treturn ret;\n}\n\nstatic void wm97xx_ac97_remove(struct ac97_codec_device *adev)\n{\n\tstruct wm97xx_priv *wm97xx = ac97_get_drvdata(adev);\n\n\tsnd_ac97_compat_release(wm97xx->ac97);\n}\n\nstatic const struct ac97_id wm97xx_ac97_ids[] = {\n\t{ .id = WM9705_VENDOR_ID, .mask = WM97xx_VENDOR_ID_MASK },\n\t{ .id = WM9712_VENDOR_ID, .mask = WM97xx_VENDOR_ID_MASK },\n\t{ .id = WM9713_VENDOR_ID, .mask = WM97xx_VENDOR_ID_MASK },\n\t{ }\n};\n\nstatic struct ac97_codec_driver wm97xx_ac97_driver = {\n\t.driver = {\n\t\t.name = \"wm97xx-core\",\n\t},\n\t.probe\t\t= wm97xx_ac97_probe,\n\t.remove\t\t= wm97xx_ac97_remove,\n\t.id_table\t= wm97xx_ac97_ids,\n};\n\nstatic int __init wm97xx_module_init(void)\n{\n\treturn snd_ac97_codec_driver_register(&wm97xx_ac97_driver);\n}\nmodule_init(wm97xx_module_init);\n\nstatic void __exit wm97xx_module_exit(void)\n{\n\tsnd_ac97_codec_driver_unregister(&wm97xx_ac97_driver);\n}\nmodule_exit(wm97xx_module_exit);\n\nMODULE_DESCRIPTION(\"WM9712, WM9713 core driver\");\nMODULE_AUTHOR(\"Robert Jarzmik <robert.jarzmik@free.fr>\");\nMODULE_LICENSE(\"GPL\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}