{
  "module_name": "hi655x-pmic.c",
  "hash_id": "d5481c3817129a9dad2c3b5ba31767dc220e8da562dedddd571f195937bb3faf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mfd/hi655x-pmic.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/mfd/core.h>\n#include <linux/mfd/hi655x-pmic.h>\n#include <linux/module.h>\n#include <linux/gpio/consumer.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\nstatic const struct regmap_irq hi655x_irqs[] = {\n\t{ .reg_offset = 0, .mask = OTMP_D1R_INT_MASK },\n\t{ .reg_offset = 0, .mask = VSYS_2P5_R_INT_MASK },\n\t{ .reg_offset = 0, .mask = VSYS_UV_D3R_INT_MASK },\n\t{ .reg_offset = 0, .mask = VSYS_6P0_D200UR_INT_MASK },\n\t{ .reg_offset = 0, .mask = PWRON_D4SR_INT_MASK },\n\t{ .reg_offset = 0, .mask = PWRON_D20F_INT_MASK },\n\t{ .reg_offset = 0, .mask = PWRON_D20R_INT_MASK },\n\t{ .reg_offset = 0, .mask = RESERVE_INT_MASK },\n};\n\nstatic const struct regmap_irq_chip hi655x_irq_chip = {\n\t.name = \"hi655x-pmic\",\n\t.irqs = hi655x_irqs,\n\t.num_regs = 1,\n\t.num_irqs = ARRAY_SIZE(hi655x_irqs),\n\t.status_base = HI655X_IRQ_STAT_BASE,\n\t.ack_base = HI655X_IRQ_STAT_BASE,\n\t.mask_base = HI655X_IRQ_MASK_BASE,\n};\n\nstatic struct regmap_config hi655x_regmap_config = {\n\t.reg_bits = 32,\n\t.reg_stride = HI655X_STRIDE,\n\t.val_bits = 8,\n\t.max_register = HI655X_BUS_ADDR(0x400) - HI655X_STRIDE,\n};\n\nstatic const struct resource pwrkey_resources[] = {\n\t{\n\t\t.name\t= \"down\",\n\t\t.start\t= PWRON_D20R_INT,\n\t\t.end\t= PWRON_D20R_INT,\n\t\t.flags\t= IORESOURCE_IRQ,\n\t}, {\n\t\t.name\t= \"up\",\n\t\t.start\t= PWRON_D20F_INT,\n\t\t.end\t= PWRON_D20F_INT,\n\t\t.flags\t= IORESOURCE_IRQ,\n\t}, {\n\t\t.name\t= \"hold 4s\",\n\t\t.start\t= PWRON_D4SR_INT,\n\t\t.end\t= PWRON_D4SR_INT,\n\t\t.flags\t= IORESOURCE_IRQ,\n\t},\n};\n\nstatic const struct mfd_cell hi655x_pmic_devs[] = {\n\t{\n\t\t.name\t\t= \"hi65xx-powerkey\",\n\t\t.num_resources\t= ARRAY_SIZE(pwrkey_resources),\n\t\t.resources\t= &pwrkey_resources[0],\n\t},\n\t{\t.name\t\t= \"hi655x-regulator\",\t},\n\t{\t.name\t\t= \"hi655x-clk\",\t\t},\n};\n\nstatic void hi655x_local_irq_clear(struct regmap *map)\n{\n\tint i;\n\n\tregmap_write(map, HI655X_ANA_IRQM_BASE, HI655X_IRQ_CLR);\n\tfor (i = 0; i < HI655X_IRQ_ARRAY; i++) {\n\t\tregmap_write(map, HI655X_IRQ_STAT_BASE + i * HI655X_STRIDE,\n\t\t\t     HI655X_IRQ_CLR);\n\t}\n}\n\nstatic int hi655x_pmic_probe(struct platform_device *pdev)\n{\n\tint ret;\n\tstruct hi655x_pmic *pmic;\n\tstruct device *dev = &pdev->dev;\n\tvoid __iomem *base;\n\n\tpmic = devm_kzalloc(dev, sizeof(*pmic), GFP_KERNEL);\n\tif (!pmic)\n\t\treturn -ENOMEM;\n\tpmic->dev = dev;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tpmic->regmap = devm_regmap_init_mmio_clk(dev, NULL, base,\n\t\t\t\t\t\t &hi655x_regmap_config);\n\tif (IS_ERR(pmic->regmap))\n\t\treturn PTR_ERR(pmic->regmap);\n\n\tregmap_read(pmic->regmap, HI655X_BUS_ADDR(HI655X_VER_REG), &pmic->ver);\n\tif ((pmic->ver < PMU_VER_START) || (pmic->ver > PMU_VER_END)) {\n\t\tdev_warn(dev, \"PMU version %d unsupported\\n\", pmic->ver);\n\t\treturn -EINVAL;\n\t}\n\n\thi655x_local_irq_clear(pmic->regmap);\n\n\tpmic->gpio = devm_gpiod_get_optional(dev, \"pmic\", GPIOD_IN);\n\tif (IS_ERR(pmic->gpio))\n\t\treturn dev_err_probe(dev, PTR_ERR(pmic->gpio),\n\t\t\t\t\"Failed to request hi655x pmic-gpio\");\n\n\tret = regmap_add_irq_chip(pmic->regmap, gpiod_to_irq(pmic->gpio),\n\t\t\t\t  IRQF_TRIGGER_LOW | IRQF_NO_SUSPEND, 0,\n\t\t\t\t  &hi655x_irq_chip, &pmic->irq_data);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to obtain 'hi655x_pmic_irq' %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, pmic);\n\n\tret = mfd_add_devices(dev, PLATFORM_DEVID_AUTO, hi655x_pmic_devs,\n\t\t\t      ARRAY_SIZE(hi655x_pmic_devs), NULL, 0,\n\t\t\t      regmap_irq_get_domain(pmic->irq_data));\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to register device %d\\n\", ret);\n\t\tregmap_del_irq_chip(gpiod_to_irq(pmic->gpio), pmic->irq_data);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int hi655x_pmic_remove(struct platform_device *pdev)\n{\n\tstruct hi655x_pmic *pmic = platform_get_drvdata(pdev);\n\n\tregmap_del_irq_chip(gpiod_to_irq(pmic->gpio), pmic->irq_data);\n\tmfd_remove_devices(&pdev->dev);\n\treturn 0;\n}\n\nstatic const struct of_device_id hi655x_pmic_match[] = {\n\t{ .compatible = \"hisilicon,hi655x-pmic\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, hi655x_pmic_match);\n\nstatic struct platform_driver hi655x_pmic_driver = {\n\t.driver\t= {\n\t\t.name =\t\"hi655x-pmic\",\n\t\t.of_match_table = hi655x_pmic_match,\n\t},\n\t.probe  = hi655x_pmic_probe,\n\t.remove = hi655x_pmic_remove,\n};\nmodule_platform_driver(hi655x_pmic_driver);\n\nMODULE_AUTHOR(\"Chen Feng <puck.chen@hisilicon.com>\");\nMODULE_DESCRIPTION(\"Hisilicon hi655x PMIC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}